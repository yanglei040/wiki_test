{"hands_on_practices": [{"introduction": "归纳证明是验证递归算法正确性的强大工具，它依赖于一个坚实的“基础情形”（base case）和一个逻辑严谨的“归纳步骤”（inductive step）。这个练习将带你分析一个经典的归并排序算法，其中一个看似无害的基础情形选择，却破坏了整个算法的正确性。通过这个练习，你将学会如何识别并修复归纳证明链条中的薄弱环节，确保算法在所有情况下都能正确运行。[@problem_id:3213544]", "problem": "一位程序员在长度为 $n$ 的数组 $A$ 上实现了一个递归归并排序，其结构如下：如果 $|A| \\le 2$，则返回 $A$ 不变；否则，将 $A$ 分成两半 $L$ 和 $R$，对它们进行递归排序以得到 $L'$ 和 $R'$，然后返回 $\\operatorname{Merge}(L', R')$。已知合并例程 $\\operatorname{Merge}(X, Y)$ 在其两个输入 $X$ 和 $Y$ 都按非递减顺序排序的前提条件下是正确的，此时它会将其元素以非递减顺序返回在一个单一的已排序数组中。\n\n仅使用关于递归算法和归并排序正确性的基本原理，即：\n- 正确性证明通过对 $n$ 的数学归纳法进行：一个有效的归纳基础必须为最小的 $n$ 建立该性质，而归纳步骤必须假设对于严格更小的规模是正确的，然后通过在其前提条件下使用一个正确的组合步骤来为 $n$ 证明该性质。\n- 合并例程的正确性要求 $\\operatorname{Merge}$ 的每个输入都已经是按非递减顺序排序的。\n\n观察到此实现在处理大小为 $2$ 的数组时会产生不正确的结果，并且同样的缺陷会传播到更大的数组中，因为一些递归子问题的大小为 $2$。\n\n以下哪个陈述精确地诊断了该缺陷，并提出了一个能保留预期归并排序结构的最小化修正？\n\nA. 该算法违反了 $\\operatorname{Merge}$ 的前提条件，因为基本情况允许返回大小为 $2$ 的未排序数组，因此一些输入到 $\\operatorname{Merge}$ 的递归子数组是未排序的。将基本情况更改为 $|A| \\le 1$ 可确保到达合并步骤的每个子数组都是通过合并已排序的子数组构建的，从而恢复了正确性。\n\nB. 当 $n = 2$ 时，分割例程必定不正确，因为无法形成两半，这是错误的根源。最小化的修正是调整分割索引，以便当 $n = 2$ 时它能产生大小为 $1$ 和 $1$ 的两半。\n\nC. 基本情况 $|A| \\le 2$ 将时间复杂度从 $O(n \\log n)$ 更改为 $O(n)$，而这种降低的复杂度是不正确排序的原因。最小化的修复是增加更多的递归层级以恢复 $O(n \\log n)$。\n\nD. 该算法未能对元素对进行排序，因为它在 $|A| = 2$ 时返回它们不变，这在更高层级上违反了 $\\operatorname{Merge}$ 的已排序输入前提条件。一个最小化的修正是通过在返回前对两个元素执行一次比较并交换来处理 $|A| = 2$ 的基本情况，从而确保所有输入到 $\\operatorname{Merge}$ 的数组都是已排序的。\n\nE. 不正确的排序是由于合并例程不稳定而引起的；用一个稳定的合并替换它可以修复大小为 $2$ 的数组，而无需更改基本情况。", "solution": "我们从递归和归并排序结构的基本原理来分析该算法。\n\n归并排序的正确性通常通过对 $n = |A|$ 的归纳法来建立：\n- 归纳基础：对于最小的规模，返回的结果必须按非递减顺序排序。一个典型的归纳基础是 $n \\le 1$，因为任何大小为 $0$ 或 $1$ 的数组都是自然有序的。\n- 归纳步骤：假设对严格更小规模的递归调用返回已排序的数组。在此假设下，合并例程 $\\operatorname{Merge}(L', R')$ 必须接收两个已排序的数组并返回它们的排序后的串联结果，这依赖于 $L'$ 和 $R'$ 已排序的前提条件。\n\n在给定的实现中，基本情况是 $|A| \\le 2$ 并且它返回 $A$ 不变。如果 $|A| = 2$ 且 $A = [a_1, a_2]$ 同时 $a_1 > a_2$，那么 $A$ 是未排序的。返回 $A$ 不变违反了基本情况所期望的属性。此外，当 $n > 2$ 时，递归会产生大小包含 $2$ 的子问题，而这些子问题将返回未排序的数组，然后这些数组被传递给 $\\operatorname{Merge}$，从而违反了 $\\operatorname{Merge}$ 的前提条件。这打破了归纳链：对于 $n = 2$ 的情况，递归结果是已排序的这一归纳假设是错误的，因此归纳步骤不能依赖于 $\\operatorname{Merge}$ 的正确性。\n\n一个具体的反例说明了这种传播：设 $A = [2, 1, 3, 4]$。分割产生 $L = [2, 1]$ 和 $R = [3, 4]$。由于有缺陷的基本情况，$L' = [2, 1]$ (未排序) 且 $R' = [3, 4]$ (已排序)。将 $L'$ 和 $R'$ 传递给 $\\operatorname{Merge}$ 违反了其前提条件，一个典型的合并操作会首先选择 $2$ (来自 $L'$)，然后是 $1$，然后是 $3, 4$，产生 $[2, 1, 3, 4]$，这是未排序的。\n\n基于这些原理，我们评估每个选项。\n\n选项 A：它正确地指出了 $\\operatorname{Merge}$ 的前提条件被违反，因为基本情况在 $|A| = 2$ 时返回了未排序的数组。将基本情况更改为 $|A| \\le 1$ 确保递归会继续直到单元素数组，而单元素数组是自然有序的。然后，根据归纳假设，每个递归调用都返回已排序的输出；因此，在每一层，所有输入到 $\\operatorname{Merge}$ 的数组都满足已排序输入的前提条件，从而恢复了正确性。这个诊断和修复与归纳证明框架是一致的。结论：正确。\n\n选项 B：它声称当 $n = 2$ 时，分割例程是错误的根源。然而，在给定的实现下，当 $|A| \\le 2$ 时，算法立即返回 $A$ 而不执行任何分割。因此在 $n = 2$ 时不存在不正确的分割。此外，对于 $n > 2$ 的情况，虽然标准的分割在处理大小为 2 的数组时会产生大小为 1 和 1 的两半，但这种情况在这里从不发生，因为基本情况阻止了在 $n=2$ 时的递归。缺陷不在于分割，而在于基本情况返回了可能未排序的元素对。结论：不正确。\n\n选项 C：它断言时间复杂度渐进地变为 $O(n)$，并将不正确的排序归咎于此。对于足够大的 $n$，基本情况 $|A| \\le 2$ 不会改变总体的渐进时间复杂度；对于 $n > 2$，算法在分割和合并方面仍然执行大约 $O(n \\log n)$ 的工作。此外，不正确的排序是一个正确性问题，而不是一个复杂度问题。在这种情况下，时间复杂度不可能是逻辑上未排序的原因。结论：不正确。\n\n选项 D：它诊断出当 $|A| = 2$ 时，返回的元素对是未排序的，从而违反了 $\\operatorname{Merge}$ 的前提条件。提议的最小化修正——在返回前对两个元素执行一次比较并交换——确保了所有在大小为 $2$ 时返回的数组都是已排序的。通过这个修复，归纳假设对于 $n = 2$ 成立，并由此推广到更大的 $n$，因为所有输入到 $\\operatorname{Merge}$ 的数组都变成了已排序的，满足了其前提条件。这在修复基本情况的同时，保留了预期的递归结构。结论：正确。\n\n选项 E：它将问题归因于合并的不稳定性。稳定性影响相等键的相对顺序；它不影响输出是否全局按非递减顺序排序。在当前的基本情况下，包含不同元素的大小为 $2$ 的数组是未排序的，无论选择稳定还是不稳定的合并，都无法修复当其输入未排序时违反 $\\operatorname{Merge}$ 前提条件的问题。结论：不正确。\n\n因此，正确的选项是 A 和 D。两者都指出了由基本情况引起的对已排序输入前提条件的违反，并提出了最小化的、有效的修复方案：要么将基本情况缩减为 $|A| \\le 1$，要么在 $|A| = 2$ 时显式地对元素对进行排序。", "answer": "$$\\boxed{AD}$$", "id": "3213544"}, {"introduction": "学会构造归纳证明很重要，但学会识别一个看似合理却存在谬误的证明同样重要。本练习提供了一个有缺陷的排序算法，并附上了一份试图证明其正确性的归纳论证。你的任务是扮演一个严谨的审查者，找出该证明在逻辑上的致命缺陷，而不是仅仅指出算法本身的错误。[@problem_id:3261411] 这将锻炼你对归纳推理中每一步的有效性进行批判性思考的能力。", "problem": "考虑以下旨在对全序关系 $\\leq$ 下的数组进行排序的算法。给定一个数组 $A[1..n]$，其中 $n \\in \\mathbb{N}$，执行一次从左到右的遍历：对于每个从 $1$ 到 $n-1$ 的 $i$，如果 $A[i] > A[i+1]$，则交换 $A[i]$ 和 $A[i+1]$。完成这一次遍历后，算法停止。将此过程称为“单次遍历相邻交换”例程。\n\n一位同事提出了以下归纳证明，以证明该例程能正确排序任何输入数组。\n\n断言：对于所有 $n \\in \\mathbb{N}$ 且 $n \\geq 1$，单次从左到右的相邻交换遍历可对任何数组 $A[1..n]$ 进行排序。\n\n关于 $n$ 的归纳证明提案：\n- 基础情形：对于 $n = 1$，数组显然已排序。对于 $n = 2$，单次比较和可能的交换会产生有序的结果。\n- 归纳步骤：假设对于某个 $k \\geq 2$，任何长度为 $k$ 的数组在经过单次从左到右的相邻交换遍历后都会被排序。考虑任何数组 $A[1..k+1]$。在遍历过程中，$A[1..k+1]$ 中的最大元素会移动到位置 $k+1$。此外，前 $k$ 个位置会像在对长度为 $k$ 的数组进行遍历时一样，在它们之间进行相同的 $(k-1)$ 次相邻比较。因此，根据归纳假设，经过这次遍历后，前 $k$ 个元素被排序，并且由于最大值位于位置 $k+1$，整个数组都被排序。\n\n你的任务是找出此证明中确切的逻辑缺陷。请仅依据以下基本原则，选择最准确地诊断出错误的选项：\n- 全序关系 $\\leq$ 下已排序数组的定义：数组 $A$ 按非降序排序，当且仅当对于所有满足 $1 \\leq i  n$ 的 $i$，$A[i] \\leq A[i+1]$。\n- 逆序对的定义：一对索引 $(i,j)$，满足 $1 \\leq i  j \\leq n$ 且 $A[i] > A[j]$。\n- 数学归纳法原理：要证明一个命题 $P(n)$ 对所有 $n \\geq n_0$ 成立，需证明 $P(n_0)$（基础情形）成立，并证明对于所有 $k \\geq n_0$，$P(k)$ 蕴含 $P(k+1)$（归纳步骤）。\n\n哪个陈述最准确地指出了该缺陷？\n\nA. 归纳步骤非法地将归纳假设应用于前 $k$ 个元素，仿佛它们是独立处理的，而忽略了后续在位置 $k$ 和 $k+1$ 之间的比较会改变前 $k$ 个元素的内容并可能重新引入相邻逆序对；该假设被用于一个算法实际上并未解决的子问题上。\n\nB. 归纳无法开始，因为基础情形忽略了 $n = 0$ 的情况，因此该证明未能确立命题对所有 $n \\geq 0$ 成立。\n\nC. 该证明混淆了“无相邻逆序对”的性质与“有序性”，这两者在全序关系下并非等价。\n\nD. 该证明依赖于最小元素在一次遍历中移动到最前面，但算法只保证最大元素移动到最后面，因此其推理不适用。", "solution": "问题陈述在算法分析和证明技术领域提出了一个有效的任务。它为一个简单排序算法（冒泡排序的一轮）的正确性提供了一个有缺陷的归纳证明，并要求找出其中的逻辑错误。该问题是自洽的，科学上根植于计算机科学原理，并且是客观的。不存在会妨碍进行严谨分析的矛盾、歧义或信息缺失。\n\n被“证明”的断言是：对于所有 $n \\in \\mathbb{N}$ 且 $n \\geq 1$，单次从左到右的相邻交换遍历可对任何数组 $A[1..n]$ 进行排序。这个断言是错误的。对于 $n=3$ 的一个简单反例是数组 $A = [3, 2, 1]$。\n- 遍历从 $i = 1$ 开始。因为 $A[1] > A[2]$（即 $3 > 2$），我们交换它们。数组变为 $[2, 3, 1]$。\n- 接着，当 $i = 2$ 时。因为 $A[2] > A[3]$（即 $3 > 1$），我们交换它们。数组变为 $[2, 1, 3]$。\n- 遍历结束。最终数组为 $[2, 1, 3]$，它没有被排序，因为 $A[1] > A[2]$。\n\n任务是找出归纳证明中的缺陷，而不仅仅是证明该断言是错误的。让我们分析所提供的证明结构。\n\n**关于 $n$ 的归纳证明提案：**\n- **基础情形：** 对于 $n = 1$，一个数组 $A[1..1]$ 没有可比较的对，因此是平凡有序的。这是正确的。对于 $n = 2$，一个数组 $A[1..2]$ 会在 $A[1]$ 和 $A[2]$ 之间进行一次比较。如果 $A[1] > A[2]$，它们会被交换。无论哪种情况，最终数组都是有序的。这也是正确的。基础情形成立。\n\n- **归纳步骤：** 证明假设了归纳假设 (IH) $P(k)$：对于某个 $k \\geq 2$，任何长度为 $k$ 的数组在经过单次遍历后都会被排序。然后它试图证明 $P(k+1)$。对于一个数组 $A[1..k+1]$，证明 $P(k+1)$ 的论证基于两个断言：\n  1. “在遍历过程中，$A[1..k+1]$ 中的最大元素会移动到位置 $k+1$。” 这个断言是正确的。最大元素一旦被移动的比较窗口 $[i, i+1]$ 遇到，它将总是大于其右侧的元素，导致它被反复向右交换，直到到达遍历的最终位置。\n  2. “此外，前 $k$ 个位置会像在对长度为 $k$ 的数组进行遍历时一样，在它们之间进行相同的 $(k-1)$ 次相邻比较。因此，根据归纳假设，经过这次遍历后，前 $k$ 个元素被排序……”\n\n第二个断言包含关键缺陷。归纳假设适用于在大小为 $k$ 的数组上作为独立过程执行的“单次遍历相邻交换”例程。在大小为 $k+1$ 的数组上运行的算法并**不是**孤立地对前 $k$ 个元素执行该例程。\n\n循环从 $i=1$ 运行到 $k$。前 $k-1$ 次迭代（$i=1, \\dots, k-1$）只涉及最初位于位置 $1, \\dots, k$ 的元素。然而，循环的最后一次迭代，即 $i=k$ 时，会比较 $A[k]$ 和 $A[k+1]$。如果这里发生交换，原来在 $A[k+1]$ 的元素会被移动到位置 $k$。这个位于位置 $k$ 的新元素可能比位置 $k-1$ 的元素小，从而在前缀 $A[1..k]$ 内产生一个新的相邻逆序对。\n\n让我们重新审视我们的反例 $A = [3, 2, 1]$，其中 $k+1 = 3$（因此 $k=2$）。\n- IH 是 $P(2)$，这是正确的：对长度为 $2$ 的数组进行一次遍历会将其排序。\n- 我们考虑长度为 $3$ 的数组 $A = [3, 2, 1]$。\n- 遍历开始。对于 $i=1$，$[3, 2]$ 被交换得到 $[2, 3, 1]$。在这个中间点，前缀 $A[1..2]$ 确实是有序的。\n- 证明的推理在下一步失败了。对于 $i=2$，我们比较 $A[2]=3$ 和 $A[3]=1$。我们交换它们。数组变为 $[2, 1, 3]$。\n- 证明在整个遍历*结束*时将 IH 应用于子数组 $A[1..k]$。在我们的遍历结束时，数组是 $[2, 1, 3]$。前缀 $A[1..2]$ 是 $[2, 1]$，它没有被排序。涉及 $A[3]$ 的交换破坏了前缀的有序属性。\n- 根本错误在于将归纳假设应用于一个算法并未独立解决的子问题。子数组 $A[1..k]$ 的状态因其与元素 $A[k+1]$ 的交互而改变。\n\n现在，我们来评估每个选项。\n\n**A. 归纳步骤非法地将归纳假设应用于前 $k$ 个元素，仿佛它们是独立处理的，而忽略了后续在位置 $k$ 和 $k+1$ 之间的比较会改变前 $k$ 个元素的内容并可能重新引入相邻逆序对；该假设被用于一个算法实际上并未解决的子问题上。**\n这个选项准确而精确地描述了上述分析中发现的缺陷。核心错误是错误地将归纳假设应用于一个由于与子问题范围外的元素（特别是 $A[k]$ 和 $A[k+1]$ 之间的交换）发生交互而并非自洽的子问题。如我们的反例所示，这次交换确实可以在前缀 $A[1..k]$ 中引入一个新的逆序对。该陈述是**正确的**。\n\n**B. 归纳无法开始，因为基础情形忽略了 $n = 0$ 的情况，因此该证明未能确立命题对所有 $n \\geq 0$ 成立。**\n该断言明确针对“$n \\in \\mathbb{N}$ 且 $n \\geq 1$”。对于一个命题 $P(n)$ 对所有 $n \\geq n_0$ 成立的归纳证明，只需要建立基础情形 $P(n_0)$。在这里，$n_0=1$。该证明正确地建立了 $n=1$（甚至 $n=2$）的基础情形。没有要求证明 $n=0$ 的情况。该陈述是**不正确的**。\n\n**C. 该证明混淆了“无相邻逆序对”的性质与“有序性”，这两者在全序关系下并非等价。**\n这个陈述在全序关系的背景下是事实错误的。问题本身将已排序数组定义为：对于所有满足 $1 \\leq i  n$ 的 $i$，$A[i] \\leq A[i+1]$。这恰好是“无相邻逆序对”的定义。如果没有相邻逆序对（即对所有 $i$ 都有 $A[i] \\leq A[i+1]$），那么根据全序关系 $\\leq$ 的传递性，对于任何 $i  j$，我们有 $A[i] \\leq A[i+1] \\leq \\dots \\leq A[j]$，这意味着 $A[i] \\leq A[j]$。这表明整个数组是有序的（即没有任何类型的逆序对）。因此，“无相邻逆序对”的性质等价于“有序性”。该陈述是**不正确的**。\n\n**D. 该证明依赖于最小元素在一次遍历中移动到最前面，但算法只保证最大元素移动到最后面，因此其推理不适用。**\n证明文本明确指出，“……$A[1..k+1]$ 中的最大元素会移动到位置 $k+1$。”它没有对最小元素做任何声明。该算法（冒泡排序的一轮）确实会将最大元素移动到末尾，但通常不会将最小元素移动到开头。这个选项曲解了证明中提出的论点。证明依赖于算法的一个正确属性（最大值移到末尾），但由此得出了一个有缺陷的结论。该陈述是**不正确的**。\n\n因此，选项A是唯一正确指出归纳步骤中逻辑谬误的选项。", "answer": "$$\\boxed{A}$$", "id": "3261411"}, {"introduction": "当算法处理的对象（如图）的复杂度由多个参数（如节点的数量$n$和边的数量$m$）共同决定时，我们应如何设计归纳证明？这个练习要求你为一个在图上操作的递归过程选择一个合适的归纳方案。这不仅仅是应用归纳法，更是要设计归纳策略，确保递归的每一步都朝着一个明确定义的“更小”的问题前进，从而保证证明的有效性和算法的终止性。[@problem_id:3261412]", "problem": "考虑一个定义在具有 $n$ 个节点和 $m$ 条边的有限、简单、无向图 $G$ 上的递归过程。该过程如下：\n- 如果 $G$ 有一个孤立节点 $v$（度为 $0$），则移除 $v$ 得到图 $G - v$，并对 $G - v$ 递归调用该过程。\n- 否则，选择任意一条边 $e$ 并移除 $e$ 得到图 $G - e$，然后对 $G - e$ 递归调用该过程。\n\n我们的目标是证明，对于所有具有参数 $n$ 和 $m$ 的有限图，该过程会终止，并且递归调用的总次数（包括初始调用）至多为 $n + m$。你必须确定一个合适的归纳方案，并证明其对于进行该证明是有效的。\n\n你可以依赖的基础知识：\n- 自然数上的数学归纳法原理及其强形式（强归纳法），它要求存在一个在每一步递归中都严格递减的良基度量。\n- 移除一个孤立节点 $v$ 会使 $n$ 减少 $1$ 而 $m$ 保持不变，移除一条边 $e$ 会使 $m$ 减少 $1$ 而 $n$ 保持不变这一事实。\n- $\\mathbb{N} \\times \\mathbb{N}$ 上的字典序是良基序，$\\mathbb{N}$ 上的常规序也是良基序。\n\n下列哪种归纳方案适用于此证明？选择所有适用的选项。\n\nA. 仅对 $n$ 进行归纳。\nB. 仅对 $m$ 进行归纳。\nC. 对有序对 $(n, m)$ 进行字典序归纳，其顺序定义为：若 $n'  n$，或 $n' = n$ 且 $m'  m$，则 $(n', m')  (n, m)$。\nD. 对和 $n + m$进行归纳。\nE. 对 $\\max\\{n, m\\}$进行强归纳。", "solution": "问题要求我们确定有效的归纳方案，以证明一个作用于具有 $n$ 个节点和 $m$ 条边的图 $G$ 上的给定递归过程的性质。一个归纳方案对于递归过程的有效性取决于是否存在一个在每次递归调用中都严格递减的良基度量。这确保了递归过程必然终止，并且归纳假设可以在每一步被应用。\n\n在任何时刻，问题的状态由图 $G$ 定义，它可以由非负整数的有序对 $(n, m)$ 来表征，分别代表节点数和边数。所有可能状态的集合是 $\\mathbb{N}_0 \\times \\mathbb{N}_0$，其中 $\\mathbb{N}_0 = \\{0, 1, 2, \\dots\\}$。\n\n该过程为递归调用定义了两种不同的情况：\n1.  如果 $G$ 包含一个孤立节点 $v$，则对图 $G-v$ 调用该过程。新图的参数为 $(n', m') = (n-1, m)$。\n2.  否则（如果 $G$ 没有孤立节点，并且不是空图），移除一条边 $e$，并对 $G-e$ 调用该过程。新图的参数为 $(n', m') = (n, m-1)$。\n\n要使一个归纳方案适用，其所基于的度量必须在这两种转换中都严格递减。\n\n关于待证命题——调用次数至多为 $n+m$——有必要作一简短的开场白。一个简单的分析表明，直到图变为空图（参数为 $(0,0)$），调用的次数恰好是 $n+m+1$，前提是假设该过程在到达一个两种情况都不适用的状态（即空图）时终止。然而，这个差异并不改变当前的问题，该问题关心的是对于给定的递归关系，归纳方案的结构有效性，而不是具体命题的真实性。一个合适的方案是能提供一个随每次递归调用都严格递减的良基度量，从而使得归纳假设能被应用于证明该过程的任何可证性质。\n\n我们现在评估每种提出的归纳方案。\n\n**A. 仅对 $n$ 进行归纳。**\n该方案使用节点数 $n$ 作为度量。归纳原理要求对于任何递归调用，新图中的 $n$ 值必须严格小于原图中的 $n$ 值。\n- 在情况1中，新状态为 $(n-1, m)$。这里，$n$ 减少到 $n-1$，这与该归纳方案一致。\n- 在情况2中，新状态为 $(n, m-1)$。这里，$n$ 保持不变。由于度量没有严格递减，归纳假设（该假设适用于节点数少于 $n$ 的图）无法被应用。\n因此，仅对 $n$ 进行归纳对于此过程不是一个有效的方案。\n**结论：不正确。**\n\n**B. 仅对 $m$ 进行归纳。**\n该方案使用边数 $m$ 作为度量。归纳原理要求对于任何递归调用，新图中的 $m$ 值必须严格小于原图中的 $m$ 值。\n- 在情况1中，新状态为 $(n-1, m)$。这里，$m$ 保持不变。由于度量没有严格递减，归纳假设（该假设适用于边数少于 $m$ 的图）无法被应用。\n- 在情况2中，新状态为 $(n, m-1)$。这里，$m$ 减少到 $m-1$，这与该归纳方案一致。\n因为该方案在情况1下失败，所以仅对 $m$ 进行归纳对于此过程不是一个有效的方案。\n**结论：不正确。**\n\n**C. 对有序对 $(n, m)$ 进行字典序归纳。**\n该方案使用有序对 $(n, m)$ 作为度量，采用良基的字典序。一个元素 $(n', m')$ 严格小于 $(n, m)$ 当且仅当 ($n'  n$) 或者 ($n' = n$ 且 $m'  m$)。\n- 在情况1中，状态从 $(n, m)$ 转换到 $(n-1, m)$。由于 $n-1  n$，新对 $(n-1, m)$ 在字典序中严格小于 $(n, m)$。\n- 在情况2中，状态从 $(n, m)$ 转换到 $(n, m-1)$。由于 $n=n$ 且 $m-1  m$，新对 $(n, m-1)$ 在字典序中严格小于 $(n, m)$。\n在两种可能的情况下，度量 $(n, m)$ 都根据字典序严格递减。由于这个序是良基的，该归纳方案适用于关于此过程的证明。\n**结论：正确。**\n\n**D. 对和 $n+m$进行归纳。**\n该方案使用标量值 $s = n+m$ 作为度量。在自然数上的标准（或强）归纳法要求这个和在每次递归调用中都严格递减。\n- 在情况1中，状态从 $(n, m)$ 转换到 $(n-1, m)$。新的和是 $s' = (n-1)+m = n+m-1 = s-1$。由于 $s'  s$，度量严格递减。\n- 在情况2中，状态从 $(n, m)$ 转换到 $(n, m-1)$。新的和是 $s' = n+(m-1) = n+m-1 = s-1$。由于 $s'  s$，度量严格递减。\n在两种情况下，度量 $n+m$ 都严格递减。自然数上的常规序是良基的，所以对和 $n+m$ 进行归纳是一个合适的方案。\n**结论：正确。**\n\n**E. 对 $\\max\\{n, m\\}$进行强归纳。**\n该方案使用标量值 $k = \\max\\{n, m\\}$ 作为度量。强归纳法要求对于每个递归调用，新的度量 $k' = \\max\\{n', m'\\}$ 都严格小于 $k$。\n我们来分析状态转换：\n- 在情况1中，转换是 $(n, m) \\to (n-1, m)$。考虑一个参数为 $(n, m) = (5, 5)$ 的图。那么 $k = \\max\\{5, 5\\} = 5$。如果这个图有一个孤立节点，过程会对一个参数为 $(n', m') = (4, 5)$ 的图进行递归。新的度量是 $k' = \\max\\{4, 5\\} = 5$。这里 $k' = k$，所以度量没有严格递减。\n- 在情况2中，转换是 $(n, m) \\to (n, m-1)$。考虑一个参数为 $(n, m) = (5, 5)$ 的图。那么 $k = \\max\\{5, 5\\} = 5$。如果这个图没有孤立节点，过程会对一个参数为 $(n', m') = (5, 4)$ 的图进行递归。新的度量是 $k' = \\max\\{5, 4\\} = 5$。这里 $k' = k$ 仍然成立，所以度量没有严格递减。\n由于我们为两种情况都找到了度量 $\\max\\{n, m\\}$ 没有严格递减的反例，所以这个归纳方案是不合适的。\n**结论：不正确。**\n\n总而言之，只有对 $(n, m)$ 的字典序归纳和对和 $n+m$ 的归纳提供了一个保证在每一步递归中都递减的度量，因此它们是选项中仅有的适合用于证明该算法性质的方案。", "answer": "$$\\boxed{CD}$$", "id": "3261412"}]}