{"hands_on_practices": [{"introduction": "判断一个字符串是否为回文串是递归的一个经典应用。通过将问题转化为检查更小的子串，我们可以优雅地解决它。这个练习将引导你使用尾递归来解决这个问题，你需要比较字符串的两端并向内收缩，同时将检查的边界作为状态在递归调用中向前传递。这是一个很好的起点，因为它将递归思想与尾递归的特定结构清晰地结合在一起。[@problem_id:3278431]", "problem": "给定一个关于有限字符串的回文形式化定义。设一个有限字母表上的有限字符串表示为 $s$，其长度为 $n = |s|$。定义反转操作符 $\\operatorname{rev}(s)$，它生成一个字符顺序相反的字符串。一个字符串 $s$ 是回文，当且仅当 $s = \\operatorname{rev}(s)$，这等价于逐点条件 $\\forall i \\in \\{0,1,\\dots,n-1\\},\\ s[i] = s[n-1-i]$。您的任务是设计并实现一个尾递归算法，用于判断给定字符串在经过规范化处理后是否为回文。规范化的定义是将输入字符串 $s$ 映射到 $\\nu(s)$，具体操作为移除所有非字母数字（字母或数字）的字符，并将剩余字符转换为小写，同时保持原有顺序。形式上，如果 $s = s_0 s_1 \\dots s_{n-1}$，那么\n$$\n\\nu(s) = \\text{concat} \\left( \\left\\{ \\operatorname{lower}(s_i) \\mid s_i \\text{ is alphanumeric} \\right\\} \\right),\n$$\n其中 $\\operatorname{lower}(\\cdot)$ 将大写字母映射为小写字母，并保持数字不变，而 concat 按原始顺序连接字符。\n\n从递归的基本定义出发，尾递归函数是一种递归函数，其中递归调用是该函数执行路径中的最后一个操作。请使用一个关于规范化字符串 $\\nu(s)$ 的索引 $l$ 和 $r$ 的谓词 $P(l,r)$（其中 $0 \\le l \\le r  |\\nu(s)|$）来形式化回文判定问题。该谓词返回一个布尔值，指示由 $l$ 和 $r$ 界定的子字符串是否为回文。函数 $P(l,r)$ 必须是尾递归的，即递归调用（如果存在）是函数执行的最后一个动作。基本情况必须确保终止，而递归步骤必须严格减小问题规模。\n\n您的程序必须在 $\\nu(s)$ 上实现这个尾递归谓词，并将其应用于以下输入字符串测试套件：\n- $s_1 =$ \"racecar\"\n- $s_2 =$ \"\"\n- $s_3 =$ \"a\"\n- $s_4 =$ \"A man, a plan, a canal: Panama\"\n- $s_5 =$ \"No 'x' in Nixon\"\n- $s_6 =$ \"abca\"\n- $s_7 =$ \"abc\"\n- $s_8 =$ \"!!!\"\n- $s_9 =$ \"Was it a car or a cat I saw?\"\n- $s_{10} =$ \"abcbaX\"\n\n覆盖性设计：\n- 用例 $s_1$ 测试一个只包含小写字母的简单回文。\n- 用例 $s_2$ 测试空字符串，其在规范化后仍为空，根据定义应被视为空真回文。\n- 用例 $s_3$ 测试单字符字符串，它始终是回文。\n- 用例 $s_4$、$s_5$ 和 $s_9$ 测试在规范化下的回文，包括混合大小写和标点符号的情况。在这种情况下，只考虑字母数字字符，并且字母的比较不区分大小写。\n- 用例 $s_6$、$s_7$ 和 $s_{10}$ 测试在规范化后明显不是回文的字符串。\n- 用例 $s_8$ 测试一个在规范化后变为空字符串的字符串。\n\n每个测试用例都必须产生一个布尔结果。您的程序应生成单行输出，其中包含 $[s_1,s_2,\\dots,s_{10}]$ 的结果，形式为一个用方括号括起来的逗号分隔列表，并使用编程语言的布尔字面量表示（对于 Python，即 \"True\" 和 \"False\"）。例如，输出格式必须严格符合 $[b_1,b_2,\\dots,b_{10}]$ 的形式，其中每个 $b_i$ 要么是字面量 \"True\"，要么是 \"False\"。程序不读取任何输入；它必须是自包含的，并使用嵌入在代码中的指定测试套件。", "solution": "该问题要求设计并实现一个尾递归算法，用以确定一个给定字符串在经过特定规范化过程后是否为回文。解决方案分两个主要阶段展开：首先，定义字符串规范化；其次，为回文检查构建尾递归谓词。\n\n### 步骤 1：字符串规范化\n\n问题定义了一个规范化函数 $\\nu(s)$，该函数为回文检查准备输入字符串 $s$。该过程按顺序包括两个操作：\n1.  **过滤**：从字符串中移除所有非字母数字（即非 'a'-'z'、'A'-'Z' 的字母或 '0'-'9' 的数字）的字符。\n2.  **大小写转换**：所有剩余的字符（保证为字母数字字符）都被转换为等效的小写形式。大写字母映射为小写，而数字保持不变。\n\n形式上，对于一个字符串 $s = s_0 s_1 \\dots s_{n-1}$，其规范化字符串 $\\nu(s)$ 由下式给出：\n$$\n\\nu(s) = \\text{concat} \\left( \\left\\{ \\operatorname{lower}(s_i) \\mid s_i \\text{ is alphanumeric} \\right\\} \\right)\n$$\n例如，将此过程应用于字符串 $s_4 = \\text{\"A man, a plan, a canal: Panama\"}$：\n1.  过滤掉空格、逗号和冒号后得到 `\"AmanaplanacanalPanama\"`。\n2.  转换为小写后得到规范化字符串 $\\nu(s_4) = \\text{\"amanaplanacanalpanama\"}$。\n\n对于像 $s_8 = \\text{\"!!!\"}$ 这样的字符串，所有字符都是非字母数字字符，因此它们都被移除。最终的规范化字符串是空字符串，即 $\\nu(s_8) = \\text{\"\"}$。\n\n### 步骤 2：尾递归回文谓词\n\n回文是一个正向和反向读取都相同的序列。对于一个长度为 $m = |s'|$ 的规范化字符串 $s' = \\nu(s)$，这等价于条件 $s'[i] = s'[m-1-i]$ 对所有 $i \\in \\{0, 1, \\dots, m-1\\}$ 都成立。我们可以使用一个递归谓词 $P(l, r)$ 来为此属性构建一个判定算法，该谓词评估 $s'$ 中从索引 $l$ 到索引 $r$（含）的子字符串是否构成回文。对整个字符串 $s'$ 的初始检查通过调用 $P(0, m-1)$ 来完成。\n\n$P(l, r)$ 的设计必须是尾递归的，这意味着递归调用（如果发生）必须是函数执行的绝对最后一个操作。\n\n**基本情况：** 递归必须终止。当“外部”指针（由索引 $l$ 和 $r$ 表示）相遇或交错时，回文检查可以停止。\n- 如果 $l = r$，子字符串只有一个字符，它始终是回文。\n- 如果 $l > r$，子字符串为空（例如，原字符串有偶数个字符且所有字符对都匹配）。空字符串是虚真回文。\n综合这些情况，终止的基本情况是 $l \\ge r$。在这种情况下，谓词 $P(l,r)$ 必须返回 $\\text{True}$。\n\n**递归步骤：** 对于 $l  r$ 的情况，我们比较当前子字符串两端的字符 $s'[l]$ 和 $s'[r]$。\n1.  如果 $s'[l] \\neq s'[r]$，则该子字符串不是回文。无需进一步检查。函数必须终止并返回 $\\text{False}$。这是一个非递归的终止路径。\n2.  如果 $s'[l] = s'[r]$，则外部字符匹配。问题被简化为确定内部子字符串（从索引 $l+1$ 到 $r-1$）是否也是回文。函数必须接着找出 $P(l+1, r-1)$ 的值。为满足尾递归约束，函数必须直接返回此递归调用的结果，而无需进行任何进一步的计算。\n\n这个逻辑被以下关于字符串 $s'$ 的谓词 $P(l,r)$ 的分段定义形式化地捕捉到：\n$$\nP(l,r) =\n\\begin{cases}\n\\text{True}   \\text{if } l \\ge r \\\\\n\\text{False}  \\text{if } l  r \\text{ and } s'[l] \\neq s'[r] \\\\\nP(l+1, r-1)  \\text{if } l  r \\text{ and } s'[l] = s'[r]\n\\end{cases}\n$$\n\n**示例演练：**\n我们来分析 $s_{10} = \\text{\"abcbaX\"}$。\n1.  **规范化**：$\\nu(s_{10}) = s' = \\text{\"abcbax\"}$。长度为 $m=6$。\n2.  **初始调用**：我们评估 $P(0, 5)$。\n    - $P(0, 5)$：$l=0, r=5$。我们检查 $s'[0] \\overset{?}{=} s'[5]$。即 $\\text{'a'} \\overset{?}{=} \\text{'x'}$。该条件为假。函数返回 $\\text{False}$。过程终止。\n\n我们来分析 $s_9 = \\text{\"Was it a car or a cat I saw?\"}$。\n1.  **规范化**：$\\nu(s_9) = s' = \\text{\"wasitacaroracatisaw\"}$。长度为 $m=19$。\n2.  **初始调用**：我们评估 $P(0, 18)$。\n    - $P(0, 18)$: $l=0, r=18$。$s'[0]=\\text{'w'}, s'[18]=\\text{'w'}$。它们匹配。返回 $P(1, 17)$。\n    - $P(1, 17)$: $l=1, r=17$。$s'[1]=\\text{'a'}, s'[17]=\\text{'a'}$。它们匹配。返回 $P(2, 16)$。\n    - ... 这个过程一直持续到中心。\n    - $P(8, 10)$: $l=8, r=10$。$s'[8]=\\text{'r'}, s'[10]=\\text{'r'}$。它们匹配。返回 $P(9, 9)$。\n    - $P(9, 9)$: $l=9, r=9$。满足基本情况 $l \\ge r$。函数返回 $\\text{True}$。\n\n这个最终的 $\\text{True}$ 结果会沿着尾调用链向上传播，成为初始调用的最终结果。因此，$s_9$ 在规范化后是回文。\n\n这种结构化的递归公式正确地解决了问题，并遵守了尾递归的要求。实现将包括一个规范化函数和一个用于谓词 $P(l,r)$ 的函数，该函数会递归地调用自身。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the palindrome problem for a given test suite using a \n    tail-recursive approach on normalized strings.\n    \"\"\"\n\n    # The test suite of input strings as per the problem statement.\n    test_cases = [\n        \"racecar\",                          # s_1\n        \"\",                                 # s_2\n        \"a\",                                # s_3\n        \"A man, a plan, a canal: Panama\",   # s_4\n        \"No 'x' in Nixon\",                  # s_5\n        \"abca\",                             # s_6\n        \"abc\",                              # s_7\n        \"!!!\",                             # s_8\n        \"Was it a car or a cat I saw?\",     # s_9\n        \"abcbaX\",                           # s_10\n    ]\n\n    def normalize_string(s: str) -> str:\n        \"\"\"\n        Applies the normalization function nu(s).\n        Removes non-alphanumeric characters and converts to lowercase.\n        \"\"\"\n        return \"\".join(char.lower() for char in s if char.isalnum())\n\n    def is_palindrome_tail_recursive(s_prime: str, l: int, r: int) -> bool:\n        \"\"\"\n        Implements the tail-recursive predicate P(l, r) to check if the\n        substring of s_prime from index l to r is a palindrome.\n        \n        Args:\n            s_prime: The normalized string.\n            l: The left index of the substring.\n            r: The right index of the substring.\n        \n        Returns:\n            True if the substring is a palindrome, False otherwise.\n        \"\"\"\n        # Base Case: If indices cross or meet, the substring is a palindrome.\n        # This handles empty strings (l=0, r=-1) and single-char strings (l=r=0).\n        if l >= r:\n            return True\n        \n        # Recursive Step:\n        # 1. Check if the outer characters are different.\n        if s_prime[l] != s_prime[r]:\n            return False\n        \n        # 2. If they are the same, the result depends on the inner substring.\n        #    This is a tail call as it's the final action of the function.\n        return is_palindrome_tail_recursive(s_prime, l + 1, r - 1)\n\n    results = []\n    for s in test_cases:\n        # 1. Normalize the input string s.\n        normalized_s = normalize_string(s)\n        \n        # 2. Apply the tail-recursive predicate P(l, r) to the normalized string.\n        # The initial call covers the entire string.\n        is_pal = is_palindrome_tail_recursive(normalized_s, 0, len(normalized_s) - 1)\n        \n        results.append(is_pal)\n\n    # Format the final output as a comma-separated list of booleans in brackets.\n    # The map(str, ...) ensures Python's \"True\" and \"False\" literals are used.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3278431"}, {"introduction": "将整数转换为不同进制的字符串是计算机科学中的一个基本问题，其核心是数论中的除法算法。一个常规的递归解法会以相反的顺序生成数字，但通过使用尾递归和累加器，我们可以直接构建出正确顺序的字符串。这个练习将展示如何运用累加器模式，在递归调用之间逐步构建最终结果，这对于掌握尾递归处理状态转换的技巧至关重要。[@problem_id:3278420]", "problem": "你的任务是设计、实现并验证一个尾递归函数，该函数能将任意整数转换为其在给定基数下的字符串表示。所要求的函数必须遵守尾递归的约束：在递归分支中，递归调用必须是最后执行的操作。不允许使用循环。对于大于$10$的基数，其数字字母表必须是大写序列$0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ$，其中数值$10$到$35$由$A$到$Z$表示。基数$b$被限制在闭区间$2 \\leq b \\leq 36$内。\n\n你的实现应基于除法算法：对于任意整数$n$和$b$（其中$b \\geq 2$），存在唯一的整数$q$和$r$，使得$n = q \\cdot b + r$成立，且$0 \\leq r  b$。利用该算法，每个非零整数$n$都可以表示为一个有限的b进制数字序列$d_k, d_{k-1}, \\dots, d_0$，使得$n = \\sum_{i=0}^{k} d_i \\cdot b^i$且每个$d_i \\in \\{0,1,\\dots,b-1\\}$。你的函数必须使用尾递归来累积正确的字符串，在非基本情况（递归情况）下，递归调用返回后不执行任何额外工作。\n\n要求和规则：\n- 实现一个尾递归核心，按正确的从左到右顺序累积数字。使用一个向前传递并在递归调用前修改的累加器，确保递归分支中的最后操作是递归调用本身。对于负数$n$，使用一个单独的前缀累加器来存储符号，并对$|n|$应用除法算法。$n=0$的表示必须是无符号的单个数字字符串$0$。\n- 函数必须验证$b$的有效性，并以数学上一致的方式处理所有整数$n$（正数、负数和零）。\n- 不要使用任何迭代结构，如 for 循环或 while 循环。\n\n测试套件：\n在以下有序对$(n,b)$上评估你的程序，覆盖典型和边界场景：\n1. $(0,2)$\n2. $(12345,10)$\n3. $(-255,16)$\n4. $(987654321,36)$\n5. $(1,2)$\n6. $(35,36)$\n\n最终输出格式：\n- 对于每个测试用例，计算其b进制字符串表示，然后根据映射关系：$'0' \\mapsto 0$, $'1' \\mapsto 1$, $\\dots$, $'9' \\mapsto 9$, $'A' \\mapsto 10$, $\\dots$, $'Z' \\mapsto 35$，将该字符串转换为整数数字值列表。如果表示为负数，则在列表开头包含一个-1来表示负号。\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素本身也是一个逗号分隔的整数列表，描述了一个测试用例的数字值。例如，格式必须类似于$[[a_1,a_2], [b_1,b_2,b_3]]$，但在外部列表中逗号后没有空格（确切的打印格式必须由你的程序处理）。", "solution": "将整数转换为其在给定基数下的字符串表示是计算机科学中的一项基本任务，其根源在于数论原理。该解决方案必须使用尾递归实现，这是一种特殊的递归模式，其中递归调用是函数中的最后一个操作。\n\n此转换的数学基础是**除法算法**。对于任意整数$n$（待转换的数）和整数基数$b \\geq 2$，存在唯一的整数$q$（商）和$r$（余数），使得：\n$$n = q \\cdot b + r \\quad \\text{其中} \\quad 0 \\leq r  b$$\n该算法使我们能够系统地提取$n$在基数$b$下的各位数字。余数$r$对应最低有效位。后续的数字通过对商$q$重复应用相同的算法来找到。例如，如果$n_0 = n$，我们得到$n_0 = q_0 \\cdot b + d_0$。然后对于$n_1 = q_0$，我们得到$n_1 = q_1 \\cdot b + d_1$，依此类推。此过程持续进行，直到商变为$0$。余数序列$d_0, d_1, d_2, \\dots$代表了$n$在基数$b$下的数字，顺序为从右到左（从最低有效位到最高有效位）。\n\n为了满足尾递归的要求，我们设计一个核心递归函数，它接受当前数字、基数和一个累加器作为参数。累加器的作用是构建最终的字符串表示。由于除法算法从右到左生成数字，因此每个新数字都必须前置到累加器中，以按正确的从左到右顺序构造最终字符串。\n\n尾递归辅助函数的结构，我们称之为$\\text{convert\\_recursive}(num, base, acc)$，如下所示：\n1.  **基本情况**：如果$num = 0$，则过程完成。在累加器$acc$中构建的字符串就是最终结果，并被返回。如果初始数字为$0$，累加器将为空，这必须作为特殊情况处理，返回\"0\"。\n2.  **递归步骤**：如果$num  0$：\n    a. 计算商$q = \\lfloor num / base \\rfloor$和余数$r = num \\pmod{base}$。\n    b. 将余数$r$转换为其对应的字符表示。我们使用字符集`$0123456789\\text{ABCDEFGHIJKLMNOPQRSTUVWXYZ}$`进行此映射。设此字符为$c_r$。\n    c. 将此字符前置到累加器：$acc_{new} = c_r + acc_{old}$。\n    d. 进行尾递归调用：$\\text{return convert\\_recursive}(q, base, acc_{new})$。因为此调用是最后的操作，所以该函数是尾递归的。\n\n一个主包装函数将在启动递归前处理初步检查和特殊情况：\n-   **基数验证**：它首先验证基数$b$是否在允许的范围$2 \\leq b \\leq 36$内。\n-   **零处理**：如果输入整数$n$为$0$，函数立即返回字符串“$0$”，绕过递归逻辑。\n-   **符号处理**：如果$n$是负数，则存储负号，并对绝对值$|n|$应用递归转换。递归完成后，将符号前置到最终结果。\n\n最后一步是将生成的字符串表示处理成指定的输出格式。这包括：\n1.  创建一个字符到值的映射（例如，$'0' \\to 0, \\dots, '9' \\to 9, 'A' \\to 10, \\dots, 'Z' \\to 35$）。\n2.  遍历b进制字符串的字符。\n3.  如果字符串表示一个负数（由前导`'-'`字符表示），则输出列表以$-1$开头。\n4.  每个后续字符都使用该映射转换为其整数值，并附加到列表中。\n\n这个完整、基于原则的过程确保了正确性，遵守了问题的所有约束，并为给定的测试套件生成了所需的输出格式。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the integer-to-base-string conversion problem using tail recursion for the given test suite.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0, 2),\n        (12345, 10),\n        (-255, 16),\n        (987654321, 36),\n        (1, 2),\n        (35, 36),\n    ]\n\n    # The alphabet of digits for bases up to 36.\n    DIGITS = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    \n    # Pre-computed map for converting character digits to integer values.\n    DIGIT_MAP = {char: val for val, char in enumerate(DIGITS)}\n\n    def _int_to_base_str_recursive(num, base, acc):\n        \"\"\"\n        The core tail-recursive helper function. This function must not be called directly.\n        It builds the string representation by prepending digits to an accumulator.\n        \"\"\"\n        if num == 0:\n            # Base case: when the number is reduced to 0, return the accumulated string.\n            return acc\n        \n        quotient = num // base\n        remainder = num % base\n        \n        # Prepend the new digit to the accumulator and make the tail call.\n        return _int_to_base_str_recursive(quotient, base, DIGITS[remainder] + acc)\n\n    def int_to_base_str(n, b):\n        \"\"\"\n        Main function to convert an integer to its base-b string representation.\n        It handles validation, special cases (zero), and sign before calling the\n        tail-recursive helper.\n        \"\"\"\n        if not isinstance(b, int) or not (2 = b = 36):\n            raise ValueError(\"Base must be an integer between 2 and 36.\")\n        \n        if n == 0:\n            return \"0\"\n            \n        sign = \"\"\n        if n  0:\n            sign = \"-\"\n            n = -n\n        \n        # Initial call to the recursive helper with an empty accumulator.\n        # If the number was initially 0, this part is skipped. The _recursive\n        # function needs a non-empty result, so this initial empty string\n        # is fine because n>0 here.\n        num_str = _int_to_base_str_recursive(n, b, \"\")\n        \n        return sign + num_str\n\n    def format_output_string(s):\n        \"\"\"\n        Converts the string representation (e.g., \"-FF\") into the required\n        list of integer values (e.g., [-1, 15, 15]).\n        \"\"\"\n        result_list = []\n        is_negative = s.startswith('-')\n        \n        if is_negative:\n            result_list.append(-1)\n            s = s[1:]\n            \n        for char in s:\n            result_list.append(DIGIT_MAP[char])\n            \n        return result_list\n\n    results = []\n    for n, b in test_cases:\n        base_str = int_to_base_str(n, b)\n        formatted_result = format_output_string(base_str)\n        results.append(formatted_result)\n\n    # Format the final output string exactly as required.\n    # e.g., [[0],[1,2,3,4,5],[-1,15,15],...]\n    inner_parts = [f\"[{','.join(map(str, r))}]\" for r in results]\n    final_output_str = f\"[{','.join(inner_parts)}]\"\n\n    print(final_output_str)\n\nsolve()\n```", "id": "3278420"}, {"introduction": "仅仅学会编写尾递归函数是不够的，理解其为何重要才是关键。这个练习将带你深入探究尾递归的核心优势：通过启用尾调用优化（TCO）来避免栈溢出。你将实现并对比一个普通的尾递归版本和一个模拟TCO的版本，通过亲手测量和比较它们的调用栈深度，你将对栈空间复杂度从 $O(n)$ 优化到 $O(1)$ 的过程获得具体而深刻的理解。[@problem_id:3278410]", "problem": "要求您从第一性原理出发，设计并实现一个使用累加器的尾递归列表反转模式。您必须依赖的基础包括：(i) 单链表的定义，其中在列表前端添加元素（通常称为“cons”）的构造函数在常数时间 $O(1)$ 内运行；(ii) 尾调用的定义，即作为函数最后一个操作的递归调用；以及 (iii) 随机存取机（RAM）的标准成本模型，其中对固定大小数据的每个原始操作成本为 $O(1)$，运行时间是所有执行的原始操作成本的总和。您还必须分析在使用和不使用尾调用优化（TCO）情况下的调用栈空间使用情况，其中尾调用优化（TCO）指运行时系统为尾调用重用当前栈帧的转换，从而防止额外的栈增长。您的程序必须以忠实于单链表模型（常数时间前端插入）的方式实现算法，并且必须对实现进行插桩，以计算元素转移步骤的数量以及反转函数达到的最大调用栈深度。\n\n任务要求如下：\n1. 在单链表表示上，使用累加器 $R$ 构建一个尾递归反转。设 $X$ 表示输入列表，$n$ 表示 $|X|$。算法必须具有以下形式：在每一步中，剥离输入的头部 $h$ 并设置 $R \\leftarrow \\mathrm{cons}(h,R)$，然后对其余部分进行尾调用，以便当输入为空时，$R$ 是结果。使用允许 $O(1)$ 前端插入的表示（您不能依赖于在前端插入成本超过 $O(1)$ 的动态数组）。\n2. 实现反转的两种变体：\n   - 一个普通的尾递归函数（不假定语言运行时支持尾调用优化（TCO））。\n   - 一个使用蹦床（trampoline）或等效迭代转换的 TCO 模拟变体，保证调用栈使用量为 $O(1)$，与 $n$ 无关。\n3. 对两种变体进行插桩以记录：\n   - 元素转移步骤的数量，根据构造应等于 $n$。\n   - 反转函数所致的最大递归深度。对于没有尾调用优化（TCO）的普通变体，这应该是 $n+1$（包括基准调用帧）。对于 TCO 模拟变体，这应该是 $1$。\n4. 使用宿主语言的递归深度限制 $L$ 来防止崩溃。对于列表长度为 $m$ 且满足 $m+1 > L$ 的测试，不要运行普通的递归变体；相反，对于因预测的溢出而无法获得的字段，报告一个哨兵值。\n5. 时间和空间推理：根据成本模型论证为什么总工作量是 $O(n)$，以及为什么在没有尾调用优化（TCO）的情况下调用栈消耗是 $O(n)$，而在有尾调用优化（TCO）的情况下是 $O(1)$。\n\n测试套件：\n为以下输入列表 $X$ 提供结果：\n- $X_1 = [\\,]$。\n- $X_2 = [7]$。\n- $X_3 = [1,2,3,4,5]$。\n- $X_4 = [0,1,2,\\dots,799]$（长度 $800$）。\n- $X_5 = [0,1,2,\\dots,(L+49)]$ 其中 $L$ 是运行时的宿主语言递归限制，长度为 $L+50$。对于这最后一个情况，您必须跳过执行普通递归变体，并将其视为预测的溢出。\n\n对于每个长度为 $n$ 的输入列表 $X$ 的测试用例，您必须生成一个形式如下的单一结果记录：\n$ [ \\text{ok\\_tramp}, \\text{plain\\_status}, \\text{steps}, \\text{stack\\_plain}, \\text{stack\\_tramp}, \\text{overflow\\_predicted} ] $\n其语义如下：\n- $\\text{ok\\_tramp}$ 是一个布尔值，指示 TCO 模拟变体是否返回 $X$ 的精确反转。\n- $\\text{plain\\_status}$ 是一个整数：如果普通变体被执行并返回了正确反转，则为 $1$；如果被执行但返回了不正确的结果，则为 $0$；如果因预测溢出而被跳过，则为 $-1$。\n- $\\text{steps}$ 是在被执行的变体中观察到的元素转移步骤的整数数量（当普通变体被跳过时，报告 TCO 模拟变体的计数）。这应等于 $n$。\n- $\\text{stack\\_plain}$ 是普通变体（如果执行）的反转函数所致的最大调用栈深度，如果跳过则为 $-1$。\n- $\\text{stack\\_tramp}$ 是 TCO 模拟变体的反转函数所致的最大调用栈深度（预期为 $1$）。\n- $\\text{overflow\\_predicted}$ 是一个布尔值，指示是否 $n+1 > L$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含 $X_1$ 到 $X_5$ 的结果记录列表，形式为逗号分隔的列表，并用方括号括起来（例如，\"[[...],[...],...]\"）。不应打印任何额外的文本。所有使用或报告的数字都是无单位的。此问题中没有角度或百分比；除了无单位的整数和布尔值外，不需要任何单位说明。", "solution": "我们从基本定义和成本模型开始。\n\n单链表要么是空的，要么是一个对 $(h,t)$，其中 $h$ 是头值，$t$ 是剩余的列表。构造 $\\mathrm{cons}(h,R)$ 的时间复杂度为 $O(1)$，将一个节点解构为 $h$ 和 $t$ 的时间复杂度为 $O(1)$。尾调用是在函数语法上处于最终位置的调用；在调用者中没有后续工作。在随机存取机（RAM）成本模型下，对固定大小数据的每个原始操作都是 $O(1)$。\n\n我们用一个显式累加器 $R$ 来构造反转函数：\n- 待维护的状态不变量：在从前往后处理输入列表 $X$ 的 $k$ 个元素后，累加器 $R$ 等于已处理前缀的反转，即 $R = \\mathrm{rev}(X[0..k-1])$。\n- 转移：如果输入非空，头为 $h$，尾为 $t$，则定义 $R' \\leftarrow \\mathrm{cons}(h,R)$ 并对 $(t,R')$ 进行递归（尾调用）。\n- 基本情况：当输入为空时，返回 $R$。\n\n正确性证明通过对 $n = |X|$ 进行归纳来进行。\n基本情况（$n=0$）：输入为空。不变量给出 $R = \\mathrm{rev}([]) = []$，因此返回 $R$ 是正确的。\n归纳步骤：假设对于长度为 $n-1$ 的列表是正确的。设 $X = [h] \\cdot T$ 且 $|T| = n-1$。算法的一步设置 $R' \\leftarrow \\mathrm{cons}(h,R)$ 并对 $(T,R')$ 进行递归。根据应用于 $T$ 的归纳假设，递归调用返回累加到 $R'$ 上的 $\\mathrm{rev}(T)$，根据不变量的构造，这等于 $\\mathrm{rev}([h] \\cdot T)$。因此，算法返回 $\\mathrm{rev}(X)$。\n\n时间复杂度遵循 RAM 模型。$n$ 个元素中的每一个都只被检查一次，每一步执行常数数量的工作：解构节点并通过 $\\mathrm{cons}$ 构造一个新节点。因此，总运行时间为 $O(n)$。\n\n调用栈上的空间复杂度取决于尾调用优化（TCO）。如果没有尾调用优化（TCO），每个尾调用仍然会分配一个新帧，因此递归深度达到 $n+1$，包括最后的基准调用；因此调用栈空间为 $O(n)$。有了尾调用优化（TCO），运行时会为尾调用重用当前帧，所以调用栈深度保持常数 $O(1)$。在像 Python 这样不应用尾调用优化（TCO）的语言中，我们可以使用蹦床（trampoline）或等效的迭代转换来模拟它：我们不在循环中进行尾调用，而是在循环中更新状态变量 $(X,R)$ 并进行迭代。这保留了 $O(n)$ 的运行时间，并将调用栈使用量减少到 $O(1)$。\n\n为遵循每步 $O(1)$ 模型的实现细节：\n- 我们将列表表示为一个单链表结构，其中空列表是一个特殊的哨兵值（如 $\\text{None}$），非空列表是一个对 $(h,t)$。这使得 $\\mathrm{cons}$ 的时间复杂度为 $O(1)$ 并与理论分析相匹配。我们仅为输入和输出提供与宿主语言数组之间的转换器。\n- 普通的尾递归函数接受 $(X,R)$ 和一个记录当前递归深度的显式参数 $d$；它在进入时更新观察到的最大深度。每个非空步骤都会增加一个步数计数器，并以深度 $d+1$ 对 $(t,\\mathrm{cons}(h,R))$ 进行尾调用。基准情况返回 $R$。\n- TCO 模拟变体在一个循环内执行相同的状态转换。它同样计算步数，但不执行递归调用，因此其最大调用深度贡献为 $1$。\n- 为避免在有递归限制 $L$ 的环境中崩溃，当 $n+1 > L$ 时我们预测溢出。对于这种情况，我们跳过执行普通递归变体，并为那些本应在普通变体上测量的字段报告一个哨兵值 $-1$，同时我们将一个表示溢出预测的布尔值设置为 $\\text{True}$。对于其他情况，我们执行两种变体并报告它们的测量结果。在所有情况下，我们都会检查 TCO 模拟的结果是否等于真实的反转结果。\n\n对于测试套件，设 $X_1 = [\\,]$ 因此 $n=0$，$X_2 = [7]$ 因此 $n=1$，$X_3 = [1,2,3,4,5]$ 因此 $n=5$，$X_4 = [0,1,2,\\dots,799]$ 因此 $n=800$，以及 $X_5 = [0,1,2,\\dots,(L+49)]$ 因此 $n=L+50$。对于 $X_1$ 到 $X_4$，普通变体应该能运行，并展示最大深度 $n+1$ 和步数 $n$，而 TCO 模拟变体应显示最大深度 $1$ 和步数 $n$。对于 $X_5$，我们预测普通变体将溢出，因为 $n+1 > L$，所以跳过它，并将其字段报告为 $-1$，同时将溢出预测设置为 $\\text{True}$；TCO 模拟变体仍以 $O(n)$ 时间和 $O(1)$ 栈空间执行。\n\n最后，程序按 $X_1$ 到 $X_5$ 的顺序为每个测试聚合一条记录，并打印包含这些记录的外部列表的单行内容，以符合所需的输出格式。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport sys\nimport numpy as np  # permitted; not strictly required\n\n# Singly linked list representation:\n# Empty list is None; node is a tuple (head, tail)\n\ndef cons(h, t):\n    return (h, t)\n\ndef from_pylist(lst):\n    head = None\n    for x in reversed(lst):\n        head = cons(x, head)\n    return head\n\ndef to_pylist(node):\n    out = []\n    while node is not None:\n        out.append(node[0])\n        node = node[1]\n    return out\n\ndef reverse_tail_plain(node, acc, depth, metrics):\n    # metrics: dict with keys 'steps', 'max_depth'\n    # Record call depth on entry.\n    if depth > metrics['max_depth']:\n        metrics['max_depth'] = depth\n    if node is None:\n        return acc\n    # Transfer one element: move head to front of acc.\n    metrics['steps'] += 1\n    h, t = node\n    return reverse_tail_plain(t, cons(h, acc), depth + 1, metrics)\n\ndef reverse_tail_trampoline(node, acc, metrics):\n    # metrics: dict with keys 'steps', 'max_depth'\n    # Simulate TCO by iterative loop; only one call frame.\n    # We record the function's call depth contribution as 1.\n    if metrics['max_depth']  1:\n        metrics['max_depth'] = 1\n    while node is not None:\n        metrics['steps'] += 1\n        h, t = node\n        acc = cons(h, acc)\n        node = t\n    return acc\n\ndef solve():\n    # Define the recursion limit L from the runtime.\n    L = sys.getrecursionlimit()\n\n    # Define the test cases from the problem statement.\n    X1 = []\n    X2 = [7]\n    X3 = [1, 2, 3, 4, 5]\n    X4 = list(range(800))\n    X5 = list(range(L + 50))  # length L+50 triggers overflow if using plain recursion\n\n    test_cases = [X1, X2, X3, X4, X5]\n\n    results = []\n    for xs in test_cases:\n        n = len(xs)\n        linked = from_pylist(xs)\n        expected = list(reversed(xs))\n\n        # Trampoline/TCO-simulated variant\n        metrics_tramp = {'steps': 0, 'max_depth': 0}\n        tramp_result_linked = reverse_tail_trampoline(linked, None, metrics_tramp)\n        tramp_result = to_pylist(tramp_result_linked)\n        ok_tramp = (tramp_result == expected)\n        stack_tramp = metrics_tramp['max_depth']\n        steps_tramp = metrics_tramp['steps']\n\n        # Decide if plain recursion is safe to run\n        overflow_predicted = (n + 1) > L\n\n        if not overflow_predicted:\n            metrics_plain = {'steps': 0, 'max_depth': 0}\n            plain_result_linked = reverse_tail_plain(linked, None, 1, metrics_plain)\n            plain_result = to_pylist(plain_result_linked)\n            ok_plain = (plain_result == expected)\n            plain_status = 1 if ok_plain else 0\n            stack_plain = metrics_plain['max_depth']\n            steps_plain = metrics_plain['steps']\n            # Steps should match n; report from either; choose plain's count\n            steps_report = steps_plain\n        else:\n            # Skip executing plain recursion to avoid overflow\n            plain_status = -1\n            stack_plain = -1\n            steps_report = steps_tramp  # report trampoline steps\n\n        result_record = [ok_tramp, plain_status, steps_report, stack_plain, stack_tramp, overflow_predicted]\n        results.append(result_record)\n\n    # Final print statement in the exact required format.\n    # Single line with the list of result records.\n    def fmt(item):\n        if isinstance(item, bool):\n            return \"True\" if item else \"False\"\n        elif isinstance(item, list):\n            return \"[\" + \",\".join(fmt(x) for x in item) + \"]\"\n        else:\n            return str(item)\n\n    print(fmt(results))\n\nsolve()\n```", "id": "3278410"}]}