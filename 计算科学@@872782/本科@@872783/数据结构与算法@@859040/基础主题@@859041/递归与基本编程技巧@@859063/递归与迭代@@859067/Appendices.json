{"hands_on_practices": [{"introduction": "本练习探讨了一个关于基本数据结构的经典问题：单向链表。虽然在单向链表中正向迭代轻而易举，但反向遍历却是不可能的。这个实践 [@problem_id:3265361] 将挑战你，让你看到递归如何优雅地利用隐式调用栈的“后进先出”($\\text{LIFO}$)特性来模拟反向遍历以进行比较，并将其与需要巧妙进行显式指针操作的迭代方法进行对比。", "problem": "您的任务是在数据结构与算法中递归与迭代的背景下，设计并实现两种算法，来判断一个有限的整数单链表是否为回文。回文是一个正向和反向读取都相同的序列。形式上，对于一个节点值序列 $\\{a_1, a_2, \\dots, a_n\\}$，该序列是回文的当且仅当对于所有 $i \\in \\{1, 2, \\dots, n\\}$，都有 $a_i = a_{n+1-i}$，其中 $n$ 是节点数。该链表是单向链接的，意味着每个节点包含一个指向其后继节点的指针。\n\n推理的基本依据：\n- 单链表的定义：一个节点的集合，其中每个节点存储一个值和一个指向下一个节点的指针；最后一个节点指向空。\n- 回文的定义：一个序列 $\\{a_1, a_2, \\dots, a_n\\}$，它对所有有效索引 $i$ 都满足 $a_i = a_{n+1-i}$。\n- 递归：通过将问题简化为形式相同的子问题直至达到基本情况来解决问题。递归利用调用栈（后进先出，LIFO）来记录跨调用的状态。\n- 迭代：使用显式循环和指针操作；在单链表中，不直接支持反向遍历。\n\n您的程序必须实现并比较两种不同的方法：\n1. 一种使用调用栈模拟反向遍历的递归解法：递归函数必须深入到链表的末尾，并在回溯时，将从尾部开始的节点值与一个从头部开始向前移动的指针所指的节点值进行比较。该方法必须以时间复杂度 $\\mathcal{O}(n)$ 和因调用栈产生的空间复杂度 $\\mathcal{O}(n)$ 运行。\n2. 一种不依赖递归的迭代解法。它必须以时间复杂度 $\\mathcal{O}(n)$ 运行，并且可能需要对链表进行第二次遍历或使用额外空间。一种有效的方法是使用两个指针定位中点，原地反转后半部分，然后比较前半部分和反转后的后半部分的相应节点；这需要为反转和比较进行第二次遍历，并以 $\\mathcal{O}(1)$ 的辅助内存空间复杂度运行。\n\n输入模型和测试套件规范：\n- 无外部输入。程序必须根据以下数组测试套件在内部构建单链表（每个数组表示从头到尾的节点值序列）：\n  - 测试用例 1：$\\left[\\,\\right]$（空链表）\n  - 测试用例 2：$\\left[\\,42\\,\\right]$\n  - 测试用例 3：$\\left[\\,1, 2, 2, 1\\,\\right]$\n  - 测试用例 4：$\\left[\\,1, 2, 3, 2, 1\\,\\right]$\n  - 测试用例 5：$\\left[\\,1, 2, 3, 4\\,\\right]$\n  - 测试用例 6：$\\left[\\,3, 4, 5, 4, 6\\,\\right]$\n  - 测试用例 7：$\\left[\\,0, 0\\,\\right]$\n  - 测试用例 8：$\\left[\\,{-1}, 2, {-1}\\,\\right]$\n- 对于每个测试用例，构建两个独立的链表（以避免方法之间的干扰），并运行迭代和递归两种算法。\n\n答案规范：\n- 对于每个测试用例 $i$，产生两个布尔结果：首先是迭代方法的结果，然后是递归方法的结果。最终输出是一个扁平列表，按顺序汇总了所有测试用例的所有结果，因此输出包含 $2 \\times 8 = 16$ 个条目。\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，$\\left[\\text{result}_1,\\text{result}_2,\\dots\\right]$）。作为格式示例，布尔值打印为 $\\text{True}$ 或 $\\text{False}$。\n- 最终聚合列表中唯一允许的类型是布尔值。\n\n科学真实性和约束：\n- 将空链表视作回文。\n- 正确处理偶数长度和奇数长度的链表。\n- 确保算法遵循其各自方法指定的时空复杂度约束。", "solution": "问题陈述的有效性已得到确认。这是一个来自数据结构与算法领域的、提法恰当且具有科学依据的问题，其规范清晰完整。我现在将开始提供解决方案。\n\n该问题要求实现两种不同的算法来判断单链表是否为回文。一个序列 $\\{a_1, a_2, \\dots, a_n\\}$ 是回文，如果对所有 $i \\in \\{1, \\dots, n\\}$ 都有 $a_i = a_{n+1-i}$。核心挑战源于单链表的单向性，这使得简单的反向遍历无法实现。\n\n### 1. 迭代方法\n\n迭代解法必须以 $\\mathcal{O}(n)$ 的时间复杂度和 $\\mathcal{O}(1)$ 的辅助空间复杂度运行。这可以通过一个原地操作链表指针的多遍算法来实现。\n\n**原理：**基本思想是比较链表的前半部分与反转后的后半部分。\n1.  **寻找中点：**第一步是找到链表的中间位置。使用“快慢指针”技术可以高效地完成此操作。将两个指针 `slow` 和 `fast` 初始化为链表的头部。在循环的每次迭代中，`slow` 前进一个节点，而 `fast` 前进两个节点。当 `fast` 指针到达链表末尾（或末尾前一个节点）时，`slow` 指针将位于前半部分的最后一个节点。这一遍遍历耗时 $\\mathcal{O}(n)$。\n2.  **反转后半部分：**对应于后半部分的子链表（从 `slow` 指针之后的节点开始）被原地反转。这是一个标准的链表反转算法，它遍历子链表，将每个节点的 `next` 指针更改为指向其前驱节点。由于遍历了半个链表，此操作也需要 $\\mathcal{O}(n)$ 的时间。\n3.  **比较：**初始化两个指针：一个在原始链表的头部（前半部分的起点），另一个在新反转的后半部分的头部。这两个指针同步前进，并比较它们对应的节点值。如果在任何一点发现不匹配，则链表不是回文。如果遍历完成而没有不匹配，则链表是回文。这一比较过程耗时 $\\mathcal{O}(n)$。\n4.  **恢复（可选）：**为了成为一个非破坏性函数，可以通过再次反转后半部分并将其重新链接到前半部分的末尾来恢复链表的原始结构。此步骤与第一次反转具有相同的 $\\mathcal{O}(n)$ 复杂度。\n\n总体时间复杂度是这些线性遍历的总和，仍然是 $\\mathcal{O}(n)$。空间复杂度为 $\\mathcal{O}(1)$，因为无论链表大小 $n$ 如何，都只使用了几个额外的指针。\n\n### 2. 递归方法\n\n递归解法必须满足 $\\mathcal{O}(n)$ 的时间复杂度和 $\\mathcal{O}(n)$ 的空间复杂度，其中空间使用归因于函数调用栈。\n\n**原理：**该方法利用函数调用栈的后进先出（LIFO）特性来模拟反向遍历。比较逻辑在递归回溯时执行。\n1.  **前向指针：**维护一个指针（我们称之为 `front_pointer`），用于从头到尾遍历列表。该指针定义在所有递归调用都可访问的作用域中（例如，在 Python 中作为 `nonlocal` 变量，或在类中作为实例变量）。\n2.  **递归遍历：**定义一个递归函数，我们称之为 `check(current_node)`。它首先用 `check(current_node.next)` 调用自身，从而有效地遍历到链表的末尾。递归的基准情况是当 `current_node` 为空时（即我们已经越过了链表尾部）。\n3.  **回溯时比较：**在递归调用返回后，执行处于“回溯”阶段。此时，`current_node` 代表链表后半部分的一个节点，从尾部向中间移动，而 `front_pointer` 指向链表前半部分的一个节点，从头部向中间移动。比较 `current_node` 和 `front_pointer` 所指向节点的值。\n4.  **状态传播：**如果值匹配，`front_pointer` 前进到其下一个节点，函数返回 `True`。如果出现不匹配，或者更深层的递归调用返回了 `False`，该函数会立即将 `False` 向上层调用栈传播，从而停止进一步的比较。\n\n时间复杂度为 $\\mathcal{O}(n)$，因为每个节点在递归深入和回溯时各被访问一次。空间复杂度为 $\\mathcal{O}(n)$，因为递归调用栈的最大深度等于节点数 $n$。\n\n两种算法都在指定的约束条件下正确地解决了问题，展示了迭代的指针操作技术与递归的基于栈的逻辑之间的鲜明对比。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass ListNode:\n    \"\"\"\n    Definition for a singly-linked list node.\n    \"\"\"\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n    def __repr__(self):\n        return f\"ListNode({self.val})\"\n\ndef build_linked_list(arr):\n    \"\"\"\n    Constructs a singly linked list from a Python list of values.\n    \"\"\"\n    if not arr:\n        return None\n    head = ListNode(arr[0])\n    current = head\n    for val in arr[1:]:\n        current.next = ListNode(val)\n        current = current.next\n    return head\n\ndef is_palindrome_iterative(head: ListNode | None) -> bool:\n    \"\"\"\n    Determines if a linked list is a palindrome using an iterative approach.\n    Time complexity: O(n), Space complexity: O(1).\n    \"\"\"\n    if not head or not head.next:\n        return True\n\n    # 1. Find the end of the first half using the slow/fast pointer method.\n    slow = head\n    fast = head\n    while fast.next and fast.next.next:\n        slow = slow.next\n        fast = fast.next.next\n    \n    # 2. Reverse the second half of the list.\n    def reverse_list(node: ListNode | None) -> ListNode | None:\n        prev_node = None\n        curr_node = node\n        while curr_node:\n            next_temp = curr_node.next\n            curr_node.next = prev_node\n            prev_node = curr_node\n            curr_node = next_temp\n        return prev_node\n\n    second_half_head = reverse_list(slow.next)\n    \n    # 3. Compare the first half with the reversed second half.\n    first_half_ptr = head\n    second_half_ptr = second_half_head\n    is_palindrome = True\n    while second_half_ptr:\n        if first_half_ptr.val != second_half_ptr.val:\n            is_palindrome = False\n            break\n        first_half_ptr = first_half_ptr.next\n        second_half_ptr = second_half_ptr.next\n        \n    # 4. Restore the list (optional, but good practice).\n    slow.next = reverse_list(second_half_head)\n    \n    return is_palindrome\n\ndef is_palindrome_recursive(head: ListNode | None) -> bool:\n    \"\"\"\n    Determines if a linked list is a palindrome using a recursive approach.\n    Time complexity: O(n), Space complexity: O(n) for the call stack.\n    \"\"\"\n    front_pointer = head\n\n    def check_recursively(current_node: ListNode | None) -> bool:\n        nonlocal front_pointer\n        if current_node:\n            # Recurse to the end of the list.\n            if not check_recursively(current_node.next):\n                return False\n            \n            # On unwind, compare the current node with the front pointer.\n            if front_pointer.val != current_node.val:\n                return False\n            \n            # Advance the front pointer.\n            front_pointer = front_pointer.next\n        return True\n\n    return check_recursively(head)\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    test_cases = [\n        [],\n        [42],\n        [1, 2, 2, 1],\n        [1, 2, 3, 2, 1],\n        [1, 2, 3, 4],\n        [3, 4, 5, 4, 6],\n        [0, 0],\n        [-1, 2, -1],\n    ]\n\n    results = []\n    for case_arr in test_cases:\n        # Create two separate lists for each method to avoid interference.\n        list_for_iterative = build_linked_list(case_arr)\n        list_for_recursive = build_linked_list(case_arr)\n\n        # Run the iterative algorithm.\n        result_iterative = is_palindrome_iterative(list_for_iterative)\n        results.append(result_iterative)\n\n        # Run the recursive algorithm.\n        result_recursive = is_palindrome_recursive(list_for_recursive)\n        results.append(result_recursive)\n\n    # The problem asks for numpy to be imported. The variable np remains unused.\n    _ = np # This line is to satisfy linters that flag unused imports.\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3265361"}, {"introduction": "在前一个概念的基础上，我们现在转向一个更复杂的、类似树形的数据结构。这个问题 [@problem_id:3265439] 涉及“扁平化”一个多级链表，这是一个天然适合深度优先遍历的任务。你将分别通过递归和使用显式栈的迭代方式来实现这一过程，从而直接、亲身体验迭代方法如何精确地模拟递归调用栈的机制。", "problem": "给定一个多级单向链表，其中每个节点包含一个整数值和最多两个指针：一个 next 指针和一个 child 指针。next 指针沿主层级链接节点，而 child 指针可能指向另一个单向链表的头部（其节点本身也可能带有 child 指针），从而形成一个有限有向无环结构。任务是实现两个函数，将整个结构以深度优先前序的方式扁平化为一个单层单向链表，一个使用递归，另一个使用显式栈进行迭代，然后验证两种方法产生相同的输出。\n\n从以下基本概念开始：\n- 单向链表是一个节点序列，其中每个节点包含一个值和一个指向下一个节点的指针。在此问题中，节点还可能包含一个指向子列表的指针。不存在循环；因此，遍历会终止。\n- 深度优先遍历在处理其后代之前先处理节点，并确保在进入子节点时，对未处理的 next 指针遵循后进先出 (LIFO) 顺序。这等同于在递归中使用隐式调用栈或在迭代中使用显式栈。\n\n形式上，扁平化语义定义如下。设多级列表为一个有限有向无环图，其中每个节点最多有一条类型为 next 的出边和最多一条类型为 child 的出边。扁平化操作通过以下方式生成一个单层列表：\n- 访问一个节点 $x$，输出 $x$ 的值。\n- 如果 $x$ 有一个指向子列表头部的 child 指针，则接下来按顺序完全扁平化该子列表，然后再继续处理 $x$ 的原始 next 后继节点。\n- 扁平化后，所有 child 指针必须设置为空，并且 next 指针必须形成与所述深度优先前序匹配的单层列表。\n这是对由 child 边引出的隐式树状扩展的严格前序遍历，其不变量是节点的子列表紧接在该节点之后拼接，而原始的 next 后继节点在拼接的子列表的尾部之后恢复。\n\n实现两个函数：\n- 一个基于递归的扁平化函数，它使用隐式调用栈进入子列表，并返回扁平化列表的头部。\n- 一个基于迭代的扁平化函数，它使用显式栈数据结构来模拟调用栈的 LIFO 行为。\n\n约束和假设：\n- 节点值为整数。为清晰起见，在单个测试用例中所有值都是唯一的。\n- 不存在循环；每个指针图都是有限且无环的。\n- 两种实现都必须原地执行扁平化，调整指针而不分配新节点，并且必须将所有 child 指针设置为空。\n\n测试套件和参数以覆盖多个方面：\n- 情况 $1$ (边界：空结构)：顶层链为空，即 head 为 null。预期的扁平化顺序是空列表 $[]$。\n- 情况 $2$ (边界：单个节点)：顶层 next 链为 $1$。没有子节点。预期的扁平化顺序是 $[1]$。\n- 情况 $3$ (一般情况，包含多个子节点和嵌套子节点)：顶层 next 链为 $1 \\to 2 \\to 3 \\to 4$。子节点：节点 $2$ 有子节点 $7 \\to 8$，节点 $8$ 有子节点 $11$，节点 $3$ 有子节点 $9 \\to 10$。根据定义，预期的扁平化顺序是 $[1,2,7,8,11,3,9,10,4]$。\n- 情况 $4$ (深度嵌套)：顶层 next 链为 $1 \\to 2 \\to 3$。子节点：节点 $1$ 有子节点 $4$，节点 $4$ 有子节点 $5$，节点 $5$ 有子节点 $6$。预期的扁平化顺序是 $[1,4,5,6,2,3]$。\n- 情况 $5$ (不同位置的多个子节点)：顶层 next 链为 $1 \\to 2 \\to 3 \\to 4 \\to 5$。子节点：节点 $2$ 有子节点 $6$，节点 $4$ 有子节点 $7 \\to 8 \\to 9$。预期的扁平化顺序是 $[1,2,6,3,4,7,8,9,5]$。\n\n您的程序必须：\n- 完全按照规定构建测试结构。\n- 使用基于递归的方法生成扁平化序列，并独立地使用带显式栈的基于迭代的方法生成扁平化序列。\n- 验证每个测试用例的两个序列是否相同。\n- 最终输出格式：一个单行，包含一个用方括号括起来的逗号分隔列表，其中每个元素对应一个测试用例。对于测试用例 $i$，当且仅当它与基于迭代的方法生成的序列匹配时，输出扁平化序列（使用基于递归的方法）作为一个整数列表；否则，为该情况输出单元素列表 $[-1]$。例如，输出应类似于 $[[a_1],[a_2],[a_3],[a_4],[a_5]]$，不带空格连接，例如 $[[a_1],[a_2],[a_3],[a_4],[a_5]]$，其中每个 $[a_i]$ 是一个整数列表。\n\n不允许外部输入或文件；程序必须完全自包含且可运行。", "solution": "该问题要求实现并验证两种不同的方法——一种递归，一种迭代——来扁平化一个多级单向链表。该结构是一个有限有向无环图，其中每个节点拥有一个整数值、一个定义主链的 `next` 指针，以及一个指向子链头部的 `child` 指针。扁平化必须遵循严格的深度优先前序遍历，最终形成一个单层链表。实现必须是原地的，即它们通过修改现有指针来完成，而不分配新节点，并且必须将所有 `child` 指针设置为 `null`。\n\n首先，我们定义节点的结构，记为 $N$。每个节点 $N$ 包含三个部分：一个整数值 $v$、一个指向下一个节点的指针 $N_{next}$ 和一个指向子节点的指针 $N_{child}$。\n\n$$N = (v, N_{next}, N_{child})$$\n\n扁平化操作通过将子列表拼接在其父节点之后，将多级结构转换为线性序列。如果一个节点 $N_i$ 有一个由 $N_c$ 作为头部的子列表，并且其后继节点为 $N_j$，那么结构 $... \\to N_i \\to N_j \\to ...$（其中 $N_i$ 有子节点 $N_c$）将被转换。以 $N_c$ 开始的子列表被扁平化为一个从 $N_c$ 到其尾部 $T_c$ 的线性片段。然后，这个片段被插入到 $N_i$ 和 $N_j$ 之间，形成序列 $... \\to N_i \\to N_c \\to ... \\to T_c \\to N_j \\to ...$。在此过程中，所有的 $N_{child}$ 指针都被设置为 `null`。\n\n### 递归扁平化\n\n递归方法非常适合解决此问题，因为扁平化的定义本身就是递归的。一个扁平化列表的函数可以调用自身来扁平化遇到的任何子列表。一个健壮的递归实现涉及一个辅助函数，该函数接收一个列表的头部，将其扁平化，并返回现在已扁平化的列表的尾节点。返回的这个尾节点对于正确拼接列表段至关重要。\n\n我们定义一个函数 $\\text{FlattenRecursive}(h)$，其中 $h$ 是一个列表段的头部。该函数返回扁平化段的尾节点。\n算法流程如下：\n1.  初始化一个指针 `current` 指向头节点 $h$。\n2.  使用 `current` 指针逐层遍历列表。\n3.  在每个 `current` 节点：\n    a. 如果存在子指针 $N_{child}$：\n        i.  存储原始的 next 指针，$N_{next} = \\text{current.next}$。\n        ii. 在子列表上递归调用该函数：$T_c = \\text{FlattenRecursive}(\\text{current.child})$。$T_c$ 是扁平化后子列表的尾节点。\n        iii. 将扁平化的子列表拼接到主列表中：\n            - 设置 $\\text{current.next} = \\text{current.child}$。\n            - 设置 $\\text{current.child} = \\text{null}$。\n            - 将子列表的尾节点链接到原始的 next 节点：$T_c.\\text{next} = N_{next}$。\n        iv. 为了继续遍历，将 `current` 指针更新到新插入段的末尾，即 $T_c$。这确保了循环的下一次迭代能正确处理拼接段之后的部分。\n    b. 如果 `current.next` 为 null，意味着我们已到达当前遍历路径的末尾。此 `current` 节点是至此已扁平化列表的尾节点，因此返回它。\n    c. 将 `current` 前进到 `current.next`。\n\n递归的基准情况是一个没有子节点的列表段，在这种情况下，遍历仅找到并返回该线性段的尾节点。\n\n### 迭代扁平化\n\n迭代方法必须模拟递归调用栈的 LIFO（后进先出）行为。为此，使用一个显式栈数据结构。该栈将存储需要稍后处理的节点指针。具体来说，当我们进入一个子列表时，必须保存父节点的原始 `next` 指针，以便稍后连接。\n\n迭代算法 $\\text{FlattenIterative}(h)$ 的操作如下：\n1.  如果头部 $h$ 为 `null`，则列表为空，直接返回。\n2.  初始化一个空栈 $S$。\n3.  初始化一个指针 `current` 指向头节点 $h$。\n4.  开始一个循环，只要 `current` 不为 `null` 就继续。\n5.  在循环内部，对于 `current` 节点：\n    a. 如果存在子指针 $\\text{current.child}$：\n        i.  如果 `next` 指针 $\\text{current.next}$ 也存在，则将其推入栈 $S$。这会保存当前层级列表的其余部分，以便在整个子分支被扁平化并附加后进行处理。\n        ii. 提升子列表成为主列表的下一部分：$\\text{current.next} = \\text{current.child}$。\n        iii. 将子指针置空：$\\text{current.child} = \\text{null}$。\n    b. 如果 `current` 节点现在位于链的末尾（即 $\\text{current.next}$ 为 `null`）并且栈 $S$ 不为空，这表示我们已经处理完一个（可能是嵌套的）子分支。现在必须将这个分支连接回先前保存的列表段。\n        i.  从栈 $S$ 中弹出一个节点，并将其设置为下一个节点：$\\text{current.next} = S.\\text{pop()}$。\n    c. 将 `current` 前进到下一个节点：$\\text{current} = \\text{current.next}$。\n\n这个迭代过程以深度优先的方式系统地探索结构。将 `next` 指针推入栈并立即处理 `child` 指针确保了前序遍历。当一个分支被遍历完时，栈提供了继续处理的连接点，完美地模仿了从递归调用返回的行为。\n\n### 验证\n为验证正确性，对于每个测试用例，我们必须创建初始结构的两个相同副本。一个副本传递给递归函数，另一个传递给迭代函数。两个函数都完成后，遍历生成的单层列表，并将其节点值收集到两个序列中。然后比较这两个序列。如果它们相同，则验证成功。否则，实现之间存在差异。这种比较验证了两种实现算法的逻辑等价性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass Node:\n    \"\"\"Node definition for the multi-level singly linked list.\"\"\"\n    def __init__(self, val, next_node=None, child=None):\n        self.val = val\n        self.next = next_node\n        self.child = child\n\n    def __repr__(self):\n        return f\"Node({self.val})\"\n\ndef _flatten_recursive(current):\n    \"\"\"\n    Recursive helper that flattens the list starting at `current`\n    and returns the tail of the flattened list.\n    \"\"\"\n    if not current:\n        return None\n\n    tail = current\n    while tail.next:\n        tail = tail.next\n\n    it = current\n    while it:\n        if it.child:\n            original_next = it.next\n            child_tail = _flatten_recursive(it.child)\n            \n            # Splice the flattened child list\n            it.next = it.child\n            it.child = None\n            \n            child_tail.next = original_next\n            \n            # Update the main tail if the new segment is at the end\n            if original_next is None:\n                tail = child_tail\n            \n            # Continue traversal from the end of the spliced segment\n            it = child_tail\n        else:\n            it = it.next\n            \n    return tail\n\ndef flatten_recursive(head):\n    \"\"\"\n    Main recursive function to flatten the list.\n    It calls a helper that performs the actual an-place flattening.\n    \"\"\"\n    if head:\n        _flatten_recursive(head)\n    return head\n\ndef flatten_iterative(head):\n    \"\"\"\n    Iterative function to flatten the list in-place using a stack.\n    \"\"\"\n    if not head:\n        return None\n\n    stack = []\n    current = head\n    \n    while current:\n        if current.child:\n            # If there's a next node, save it to the stack to process later\n            if current.next:\n                stack.append(current.next)\n            \n            # Promote child to be the next node\n            current.next = current.child\n            current.child = None\n            \n        # If we reach the end of a chain and the stack has saved pointers\n        if not current.next and stack:\n            # Pop from stack to connect the chain\n            current.next = stack.pop()\n        \n        # Move to the next node\n        current = current.next\n        \n    return head\n\ndef build_structure(nodes_def):\n    \"\"\"\n    Helper to build the list structure from a dictionary definition.\n    `nodes_def` is a dict of val -> (next_val, child_val).\n    \"\"\"\n    if not nodes_def:\n        return None\n        \n    nodes = {val: Node(val) for val in nodes_def}\n    for val, (next_val, child_val) in nodes_def.items():\n        if next_val is not None:\n            nodes[val].next = nodes[next_val]\n        if child_val is not None:\n            nodes[val].child = nodes[child_val]\n            \n    # Find head (node with no incoming edges, assumed to be the smallest value for simplicity)\n    # This is a simplification; a more robust way would be to pass the head's value.\n    in_degrees = {val: 0 for val in nodes}\n    for _, (next_val, child_val) in nodes_def.items():\n        if next_val is not None:\n            in_degrees[next_val] += 1\n        if child_val is not None:\n            in_degrees[child_val] += 1\n    \n    head_val = min([val for val, deg in in_degrees.items() if deg == 0 and val in nodes_def])\n    return nodes.get(head_val)\n\n\ndef build_from_case(case_def):\n    \"\"\"\n    Builds the test case structure. \n    case_def is a tuple: (head_val, definition_dict).\n    \"\"\"\n    if not case_def:\n        return None\n    head_val, nodes_def = case_def\n    if not nodes_def:\n        return None if head_val is None else Node(head_val)\n\n    nodes = {val: Node(val) for val in nodes_def}\n    for val, connections in nodes_def.items():\n        next_val, child_val = connections\n        if next_val in nodes:\n            nodes[val].next = nodes[next_val]\n        if child_val in nodes:\n            nodes[val].child = nodes[child_val]\n    return nodes.get(head_val)\n\ndef deepcopy_structure(head):\n    \"\"\"\n    Performs a deep copy of the graph structure to ensure tests are independent.\n    Uses a memoization dictionary to handle DAGs correctly.\n    \"\"\"\n    if not head:\n        return None\n    \n    memo = {}\n\n    def copy_node(node):\n        if not node:\n            return None\n        if id(node) in memo:\n            return memo[id(node)]\n        \n        new_node = Node(node.val)\n        memo[id(node)] = new_node\n        \n        new_node.next = copy_node(node.next)\n        new_node.child = copy_node(node.child)\n        \n        return new_node\n        \n    return copy_node(head)\n\ndef get_list_values(head):\n    \"\"\"Converts a flattened linked list to a Python list of values.\"\"\"\n    values = []\n    current = head\n    while current:\n        values.append(current.val)\n        current = current.next\n    return values\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, run flatteners, and verify results.\n    \"\"\"\n    # Test cases defined as (head_value, {node_val: (next_val, child_val)})\n    test_cases = [\n        # Case 1: Empty structure\n        (None, {}),\n        # Case 2: Single node\n        (1, {1: (None, None)}),\n        # Case 3: General case\n        (1, {\n            1: (2, None), 2: (3, 7), 3: (4, 9), 4: (None, None),\n            7: (8, None), 8: (None, 11), 11: (None, None),\n            9: (10, None), 10: (None, None)\n        }),\n        # Case 4: Deep nesting\n        (1, {\n            1: (2, 4), 2: (3, None), 3: (None, None),\n            4: (None, 5), 5: (None, 6), 6: (None, None)\n        }),\n        # Case 5: Multiple children\n        (1, {\n            1: (2, None), 2: (3, 6), 3: (4, None), 4: (5, 7), 5: (None, None),\n            6: (None, None),\n            7: (8, None), 8: (9, None), 9: (None, None)\n        })\n    ]\n\n    results = []\n    for case_def in test_cases:\n        # Build two identical copies for recursive and iterative functions\n        head1 = build_from_case(case_def)\n        head2 = deepcopy_structure(head1)\n\n        # Flatten using both methods\n        result_head_rec = flatten_recursive(head1)\n        result_head_iter = flatten_iterative(head2)\n\n        # Convert to lists for comparison\n        list_rec = get_list_values(result_head_rec)\n        list_iter = get_list_values(result_head_iter)\n        \n        # Verify and store result\n        if list_rec == list_iter:\n            results.append(list_rec)\n        else:\n            results.append([-1])\n\n    # Final print statement in the exact required format\n    # The format is a string representation of a list of lists.\n    # Ex: [[1, 2], [3, 4], [-1]]\n    formatted_results = [f\"[{','.join(map(str, res))}]\" if res != [-1] else \"[-1]\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3265439"}, {"introduction": "我们最后的实践展示了递归最优雅和强大的应用之一：分治范式。Tromino 骨牌平铺谜题 [@problem_id:3265455] 是一个绝佳的例子，它说明了一个看似复杂的问题如何通过将其分解为更小的、自相似的子问题来优雅地解决。通过实现递归解法并分析其迭代模拟所需的状态，你将对递归深度与空间复杂度之间的关系有一个具体而定量的理解。", "problem": "您需要研究一个经典的分治法平铺问题，通过显式栈模拟来比较递归和迭代。考虑一个大小为 $2^n \\times 2^n$ 的方形棋盘，其中在坐标 $(r_m,c_m)$ 处缺失一个单位方块。行和列的索引从 $0$ 到 $2^n-1$。一个L形三格骨牌（tromino）是由3个单位方块组成的多格骨牌（polyomino），形状为一个直角。\n\n您的任务是实现两种算法，给定 $(n,r_m,c_m)$，使用L形三格骨牌来平铺该棋盘，使得除缺失的方块外，所有单位方块都被恰好覆盖一次。\n\n设计的基本依据：使用递归的定义、过程式编程中函数调用栈的操作模型，以及在2的幂次网格上的分治法原则。每个递归子问题应对应于当前棋盘的一个象限，当子问题大小变为 $1 \\times 1$ 时必须达到终止条件。\n\n算法要求：\n- 实现一个递归算法，给定当前子棋盘的原点 $(r_0,c_0)$、大小指数 $k$（因此边长为 $2^k$）以及该子棋盘内唯一的缺失方块 $(r_m,c_m)$，在中心放置一个L形三格骨牌，将问题简化为四个子问题。基本情况 $k=0$ 不进行任何放置。该递归例程必须生成一个放置列表，每个放置项是该步骤中放置的三格骨牌所覆盖的3个坐标。同时，计算递归调用的总次数（包括基本情况的调用）。\n- 通过显式模拟调用栈，将上述设计转换为迭代算法。定义一个栈帧，其中恰好包含为一个子问题重现递归步骤所需的状态：$(r_0,c_0,k,r_m,c_m)$。通过重复以下操作执行深度优先遍历：弹出一个栈帧，如果 $k>0$ 则放置中心的三格骨牌，并压入四个子栈帧。在执行期间，跟踪显式栈上同时存在的最大栈帧数。\n\n对于每个输入 $(n,r_m,c_m)$，计算以下量：\n- $t$：递归算法产生的L形三格骨牌放置数量。\n- $s$：在迭代模拟过程中观察到的最大显式栈大小（以栈帧为单位）。\n- $r$：递归算法执行的递归调用总次数，包括基本情况的调用。\n\n测试套件：\n使用以下参数集，每个参数集表示为 $(n,r_m,c_m)$，使用从零开始的索引：\n- $(0,0,0)$\n- $(1,0,1)$\n- $(2,1,2)$\n- $(3,7,7)$\n- $(4,5,10)$\n\n最终输出格式：\n您的程序必须生成单行输出，包含所有测试用例的结果，形式为一个三元组列表，格式严格为\n$[[t_1,s_1,r_1],[t_2,s_2,r_2],\\dots,[t_5,s_5,r_5]]$\n其中不含任何空格。所有 $t_i$、$s_i$ 和 $r_i$ 都必须是整数。不允许有其他输出。\n\n科学真实性和约束条件：\n- 将所有坐标和大小视为整数。\n- 角度和物理单位在此无关紧要。\n- 算法必须从第一性原理推导：基于象限的递归以及对该递归的显式栈模拟。\n- 不得使用任何外部随机性。只要算法是正确的分治平铺例程，放置的顺序对于评分指标无关紧要。\n\n您的实现必须是一个完整的、可运行的程序，测试套件需硬编码，且不得要求任何输入。它应该严格按照要求的格式打印一行输出。", "solution": "我们从递归、调用栈和分治法的基础定义开始。递归是一种根据自身在严格更小的输入上定义计算的方法，而函数调用栈为每个活动调用记录了在子调用返回后恢复执行所需的状态。分治法要求我们将一个问题划分为多个规模更小的子问题，这些子问题共同覆盖了原问题，然后解决这些子问题，并合并它们的解。对于2的幂次网格的平铺问题，标准的划分方法是将其划分为四个大小相等的象限。\n\n问题详述：给定一个大小为 $2^n \\times 2^n$ 的棋盘，在 $(r_m,c_m)$ 处恰好缺失一个方块，我们必须用L形三格骨牌平铺剩余区域。递归不变量如下：对于任何调用 $\\mathrm{tile}(r_0,c_0,k,r_m,c_m)$，其中子棋盘是行 $r \\in \\{r_0,\\dots,r_0+2^k-1\\}$ 和列 $c \\in \\{c_0,\\dots,c_0+2^k-1\\}$ 构成的正方形，并且其中恰好缺失一个方块 $(r_m,c_m)$，该算法会使用L形三格骨牌平铺该子棋盘，但留下 $(r_m,c_m)$。\n\n基本情况：如果 $k=0$，子棋盘的边长为 $2^0=1$，因此它本身就是那个缺失的单位方块。无需进行放置，不变量成立。\n\n归纳步骤：假设 $k>0$。定义 $h=2^{k-1}$。该子棋盘被划分为四个象限：\n- 左上象限：行 $[r_0,r_0+h-1]$，列 $[c_0,c_0+h-1]$，\n- 右上象限：行 $[r_0,r_0+h-1]$，列 $[c_0+h,c_0+2h-1]$，\n- 左下象限：行 $[r_0+h,r_0+2h-1]$，列 $[c_0,c_0+h-1]$，\n- 右下象限：行 $[r_0+h,r_0+2h-1]$，列 $[c_0+h,c_0+2h-1]$。\n\n这些象限中恰好有一个包含真正的缺失方块 $(r_m,c_m)$。设环绕象限边界的四个中心方块为\n- 左上象限中的 $(r_0+h-1,c_0+h-1)$，\n- 右上象限中的 $(r_0+h-1,c_0+h)$，\n- 左下象限中的 $(r_0+h,c_0+h-1)$，\n- 右下象限中的 $(r_0+h,c_0+h)$。\n\n放置一个L形三格骨牌，恰好覆盖不包含 $(r_m,c_m)$ 的那三个象限的中心方块，这使得四个象限中的每一个都恰好有一个缺失方块：一个是其象限内的真正缺失方块 $(r_m,c_m)$，另外三个则是新覆盖的中心方块，它们在各自的象限中充当“人为的”缺失方块，因为三格骨牌覆盖了那个方块而不是让它保持可用。根据归纳假设，对每个象限及其对应的缺失方块进行递归平铺，会产生对整个子棋盘的有效平铺。这通过结构归纳法确立了部分正确性。算法的终止性是显然的，因为在每次递归下降中 $k$ 减1，在有限步内会达到 $k=0$。\n\n基于这些原理，递归算法被完全指定如下：\n- 参数 $(r_0,c_0,k,r_m,c_m)$，\n- 基本情况 $k=0$，\n- $h=2^{k-1}$ 的计算，\n- 一次中心三格骨牌的放置，覆盖不在 $(r_m,c_m)$ 所在象限的三个中心方块，\n- 对四个象限及其相应缺失方块的四次递归调用。\n\n数量计算：\n\n$1.$ 三格骨牌数量 $t$。单位方块的总数为 $2^n \\cdot 2^n = 4^n$。由于恰好缺失一个单位方块，被覆盖的方块数量为 $4^n-1$。每个三格骨牌覆盖 $3$ 个方块，因此根据面积守恒，放置的数量必须是\n$$\nt=\\frac{4^n-1}{3}.\n$$\n这个公式是不变量和面积计算的结果。\n\n$2.$ 递归调用总次数 $r$。设 $R(n)$ 是递归算法在大小为 $2^n \\times 2^n$ 的棋盘上进行的调用次数，包括内部调用和基本情况调用。递归树是一个高度为 $n$ 的满四叉树（根在高度 $n$，叶子在高度 $0$），因为每个指数 $k>0$ 的内部节点恰好生成4个指数为 $k-1$ 的递归子调用，而基本情况 $k=0$ 不产生子调用。因此 $R(n)$ 满足\n$$\nR(0)=1,\\quad R(n)=1+4\\,R(n-1)\\ \\text{for}\\ n\\ge 1,\n$$\n解得\n$$\nR(n)=\\frac{4^{n+1}-1}{3}.\n$$\n\n$3.$ 迭代模拟的最大显式栈大小 $s$。一个显式栈模拟，它弹出一个栈帧，如果 $k>0$ 则通过压入其四个子节点来扩展它，并以深度优先的顺序重复，这实现了对同一满四叉递归树的后进先出遍历。每次扩展一个内部栈帧时，栈大小因弹出而变化-1，因压入而变化+4，净变化为+3。每次弹出一个基本情况的栈帧时，栈大小变化-1。沿着从根到第一个叶子的单条深度优先路径，在达到 $k=0$ 之前恰好有 $n$ 次扩展。在深度 $k=1$（路径上最后一个内部帧）处压入子节点后，栈的大小立即变为\n$$\ns=1+3n,\n$$\n从根处的初始栈大小1开始，每次扩展增加3。后续的任何操作都无法创建更大的栈，因为所有进一步的操作要么是弹出叶子节点，要么是在较浅的层级扩展兄弟节点，这在深度优先遍历中不可能超过这个峰值。因此，同时存在的最大栈帧数与 $n$ 呈线性关系，其精确值为 $s=1+3n$，且与 $(r_m,c_m)$ 无关。\n\n镜像一个递归帧所需的迭代状态恰好是 $(r_0,c_0,k,r_m,c_m)$：\n- $(r_0,c_0)$ 标识子棋盘的位置，\n- $k$ 标识边长 $2^k$，\n- $(r_m,c_m)$ 标识该子棋盘中唯一的缺失方块。\n不需要额外的状态，因为中心三格骨牌和子问题的计算是这些参数的纯函数。\n\n对于测试套件 $(0,0,0)$、$(1,0,1)$、$(2,1,2)$、$(3,7,7)$、$(4,5,10)$，程序构造递归放置以计算 $t$ 并计数 $r$，并模拟迭代算法以计算 $s$。输出为严格要求格式的单行 $[[t_1,s_1,r_1],[t_2,s_2,r_2],[t_3,s_3,r_3],[t_4,s_4,r_4],[t_5,s_5,r_5]]$，不含空格。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef recursive_tromino(n, missing_r, missing_c):\n    \"\"\"\n    Recursive tiling of a 2^n x 2^n board with one missing cell at (missing_r, missing_c).\n    Returns (placements, call_count), where placements is a list of tromino placements,\n    each placement is a tuple of three (r, c) integer coordinate pairs.\n    call_count counts all recursive calls including base cases.\n    \"\"\"\n    placements = []\n    call_count = [0]  # use list for mutability in nested scope\n\n    def tile(r0, c0, k, mr, mc):\n        call_count[0] += 1\n        if k == 0:\n            return\n        h = 1  (k - 1)\n        mid_r = r0 + h\n        mid_c = c0 + h\n\n        # Determine quadrant of the missing cell\n        # Quadrants: 0=top-left, 1=top-right, 2=bottom-left, 3=bottom-right\n        quad = 0\n        if mr  r0 + h:\n            if mc  c0 + h:\n                quad = 0\n            else:\n                quad = 1\n        else:\n            if mc  c0 + h:\n                quad = 2\n            else:\n                quad = 3\n\n        # Central cells adjacent to the center for each quadrant\n        centers = [\n            (mid_r - 1, mid_c - 1),  # top-left center\n            (mid_r - 1, mid_c),      # top-right center\n            (mid_r,     mid_c - 1),  # bottom-left center\n            (mid_r,     mid_c),      # bottom-right center\n        ]\n\n        # Place tromino covering the three centers not in 'quad'\n        placement = tuple(centers[i] for i in range(4) if i != quad)\n        placements.append(placement)\n\n        # For each quadrant, define its origin and missing cell\n        quads = [\n            (r0,       c0      ),  # top-left\n            (r0,       c0 + h  ),  # top-right\n            (r0 + h,   c0      ),  # bottom-left\n            (r0 + h,   c0 + h  ),  # bottom-right\n        ]\n\n        for i in range(4):\n            nr0, nc0 = quads[i]\n            if i == quad:\n                nmr, nmc = mr, mc\n            else:\n                nmr, nmc = centers[i]\n            tile(nr0, nc0, k - 1, nmr, nmc)\n\n    # Kick off recursion\n    if n > 0:\n        tile(0, 0, n, missing_r, missing_c)\n    else: # n == 0 base case\n        call_count[0] = 1\n\n    return placements, call_count[0]\n\n\ndef iterative_tromino_max_stack(n, missing_r, missing_c):\n    \"\"\"\n    Iterative simulation of the same tiling using an explicit stack of frames (r0, c0, k, mr, mc).\n    Returns the maximum number of frames that were on the stack at any moment.\n    \"\"\"\n    if n == 0:\n        return 1\n    stack = [(0, 0, n, missing_r, missing_c)]\n    max_stack = len(stack)\n\n    while stack:\n        if len(stack) > max_stack:\n            max_stack = len(stack)\n        r0, c0, k, mr, mc = stack.pop()\n        if k == 0:\n            continue\n        h = 1  (k - 1)\n        mid_r = r0 + h\n        mid_c = c0 + h\n\n        # Determine quadrant of the missing cell\n        if mr  r0 + h:\n            quad = 0 if mc  c0 + h else 1\n        else:\n            quad = 2 if mc  c0 + h else 3\n\n        centers = [\n            (mid_r - 1, mid_c - 1),  # top-left center\n            (mid_r - 1, mid_c),      # top-right center\n            (mid_r,     mid_c - 1),  # bottom-left center\n            (mid_r,     mid_c),      # bottom-right center\n        ]\n\n        quads = [\n            (r0,       c0      ),  # top-left\n            (r0,       c0 + h  ),  # top-right\n            (r0 + h,   c0      ),  # bottom-left\n            (r0 + h,   c0 + h  ),  # bottom-right\n        ]\n\n        # Push children onto the stack for depth-first traversal.\n        # To emulate a natural DFS order, we push in reverse order.\n        for i in (3, 2, 1, 0):\n            nr0, nc0 = quads[i]\n            if i == quad:\n                nmr, nmc = mr, mc\n            else:\n                nmr, nmc = centers[i]\n            stack.append((nr0, nc0, k - 1, nmr, nmc))\n\n    return max_stack\n\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case is a tuple (n, r_m, c_m)\n    test_cases = [\n        (0, 0, 0),\n        (1, 0, 1),\n        (2, 1, 2),\n        (3, 7, 7),\n        (4, 5, 10),\n    ]\n\n    results = []\n    for n, rm, cm in test_cases:\n        placements, rec_calls = recursive_tromino(n, rm, cm)\n        max_stack = iterative_tromino_max_stack(n, rm, cm)\n        tromino_count = len(placements)\n        results.append([tromino_count, max_stack, rec_calls])\n\n    # Serialize without spaces: e.g., [[a,b,c],[d,e,f],...]\n    def serialize_nested(list_of_lists):\n        inner = []\n        for triple in list_of_lists:\n            inner.append(\"[\" + \",\".join(str(x) for x in triple) + \"]\")\n        return \"[\" + \",\".join(inner) + \"]\"\n\n    print(serialize_nested(results))\n\nsolve()\n```", "id": "3265455"}]}