{"hands_on_practices": [{"introduction": "在我们利用位运算施展巧妙的技巧之前，我们必须首先掌握其基本原理。第一个练习 [@problem_id:15138] 是一个直接的热身，要求你手动计算一个表达式的结果。你需要将数字转换为二进制，逐位应用基本的 `AND`、`OR` 和 `XOR` 运算，然后再转换回十进制，这个过程将巩固核心定义，为更复杂的应用打下坚实的基础。", "problem": "在数字系统和逻辑学中，可以对整数的二进制表示进行运算。这些运算被称为按位运算。本题要求使用三种基本的按位运算：`AND`、`OR` 和 `XOR`。\n\n这些运算对单个比特的定义如下：\n- **`AND`**：当且仅当两个输入比特都为 1 时，结果为 1。\n  - `0 AND 0 = 0`\n  - `0 AND 1 = 0`\n  - `1 AND 0 = 0`\n  - `1 AND 1 = 1`\n- **`OR`**：只要至少有一个输入比特为 1，结果就为 1。\n  - `0 OR 0 = 0`\n  - `0 OR 1 = 1`\n  - `1 OR 0 = 1`\n  - `1 OR 1 = 1`\n- **`XOR` (异或)**：当且仅当输入比特不同时，结果为 1。\n  - `0 XOR 0 = 0`\n  - `0 XOR 1 = 1`\n  - `1 XOR 0 = 1`\n  - `1 XOR 1 = 0`\n\n要将这些运算应用于整数，首先需要将每个整数转换为其二进制（以 2 为基）表示。然后对每一对对应的比特执行运算。对于本题，如果二进制表示的长度不同，应在较短的那个前面填充前导零，使其长度与较长的那个相匹配。得到的二进制字符串随后被转换回十进制（以 10 为基）整数。\n\n给定整数 $A = 29$ 和 $B = 14$，求表达式 `(A OR B) XOR (A AND B)` 的最终整数值。", "solution": "我们有整数\n$$A=29,\\quad B=14.$$\n步骤 1：转换为二进制（将 $B$ 填充至 5 位）：\n$$29_{10}=(11101)_2,\\qquad 14_{10}=(01110)_2.$$\n步骤 2：计算按位 `OR`：\n$$(11101)_2\\;{\\rm OR}\\;(01110)_2=(11111)_2.$$\n步骤 3：计算按位 `AND`：\n$$(11101)_2\\;{\\rm AND}\\;(01110)_2=(01100)_2.$$\n步骤 4：计算这两个结果的 `XOR`：\n$$(11111)_2\\;{\\rm XOR}\\;(01100)_2=(10011)_2.$$\n步骤 5：转换回十进制：\n$$(10011)_2=1\\cdot2^4+0\\cdot2^3+0\\cdot2^2+1\\cdot2^1+1\\cdot2^0=16+2+1=19.$$\n因此\n$$(A\\;{\\rm OR}\\;B)\\;{\\rm XOR}\\;(A\\;{\\rm AND}\\;B)=19.$$", "answer": "$$\\boxed{19}$$", "id": "15138"}, {"introduction": "掌握了基本操作后，让我们见识一下位运算的“魔力”。这个问题 [@problem_id:3275306] 介绍了一种经典而优雅的算法，它巧妙地利用了异或（XOR）运算的特殊性质，即任何数与自身异或结果为零（$a \\oplus a = 0$）。通过应用这一洞见，你能够以惊人的效率在一个数组中找出那个唯一的元素，这展示了位运算如何带来高度优化的代码。", "problem": "给定一个静态数组，即一个长度固定的连续内存块，其中每个元素都恰好出现两次，只有一个元素恰好出现一次。目标是仅使用按位异或运算来找出这个单一元素。静态数组支持常数时间的随机访问，其逻辑模型是元素占据从 $0$ 到 $n-1$ 的连续索引，其中 $n$ 表示元素数量。\n\n从以下离散二进制运算和静态数组的基本原则出发：\n- 一个长度为 $n$ 的静态数组 $A$ 是一个连续存储的序列 $(A[0], A[1], \\dots, A[n-1])$，其大小 $n$ 不会改变。\n- 按位异或（表示为 $\\oplus$）是一种对整数进行的二元运算，它在其二进制补码表示上按位定义，具有以下经过充分检验的代数性质：$a \\oplus a = 0$，$a \\oplus 0 = a$，交换律 $a \\oplus b = b \\oplus a$，以及结合律 $(a \\oplus b) \\oplus c = a \\oplus (b \\oplus c)$。\n\n请基于这些原则，推导出一个算法来计算那个只出现一次的单一元素，过程中不得依赖任何快捷公式。您的算法必须：\n- 读取一个静态数组 $A$ 并生成一个整数。\n- 仅使用按位异по运算 $\\oplus$ 来组合数组元素；不得使用任何哈希、排序或除 $O(1)$ 额外内存之外的辅助数据结构。\n- 在 $O(n)$ 时间和 $O(1)$ 空间内运行。\n\n本问题不涉及任何物理单位、角度或百分比。\n\n为便于测试，请将您的算法应用于以下静态数组测试套件，每个数组都满足除一个元素外，所有其他元素都恰好出现两次的条件：\n- 测试 $1$：数组 $[\\,2,\\,1,\\,4,\\,5,\\,2,\\,4,\\,1\\,]$。\n- 测试 $2$：数组 $[\\,42\\,]$。\n- 测试 $3$：数组 $[\\,{-7},\\,{-7},\\,0,\\,0,\\,{-3}\\,]$。\n- 测试 $4$：数组 $[\\,2147483647,\\,99,\\,2147483647\\,]$。\n- 测试 $5$：数组 $[\\,8,\\,9,\\,9,\\,10,\\,10,\\,11,\\,11,\\,12,\\,12,\\,8,\\,13\\,]$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔的结果列表。具体来说，如果测试 $1$ 到测试 $5$ 的结果分别是 $r_1, r_2, r_3, r_4, r_5$，则打印该行\n$[r_1,r_2,r_3,r_4,r_5]$。", "solution": "该问题已被验证并确定为是合理的。它具有科学依据，定义明确且客观。该问题是一个基于按位运算数学特性的、可形式化的算法设计练习。所有必要信息均已提供，且约束条件一致明确。\n\n目标是设计一种算法，用于在一个长度为 $n$ 的静态数组 $A$ 中找出唯一的元素，而所有其他元素都恰好出现两次。该算法受限于仅使用按位异或（XOR）运算（表示为 $\\oplus$）来组合元素，并且必须在 $O(n)$ 时间和 $O(1)$ 空间内运行。\n\n算法的推导过程源于问题陈述中提供的 XOR 运算的基本代数性质：\n1.  自身求反性质：$a \\oplus a = 0$，对于任意整数 $a$。\n2.  单位元：$a \\oplus 0 = a$，对于任意整数 $a$。\n3.  交换律：$a \\oplus b = b \\oplus a$，对于任意整数 $a, b$。\n4.  结合律：$(a \\oplus b) \\oplus c = a \\oplus (b \\oplus c)$，对于任意整数 $a, b, c$。\n\n考虑对数组 $A$ 的所有元素进行 XOR 运算得到的结果 $R$：\n$$ R = A[0] \\oplus A[1] \\oplus \\dots \\oplus A[n-1] = \\bigoplus_{i=0}^{n-1} A[i] $$\n问题陈述说明，该数组由一个数字多重集构成，其中除一个唯一元素外，每个元素都出现两次。设出现两次的不同元素集合为 $\\{v_1, v_2, \\dots, v_k\\}$，唯一元素为 $u$。因此，数组 $A$ 是多重集 $\\{v_1, v_1, v_2, v_2, \\dots, v_k, v_k, u\\}$ 的一个排列。\n\n由于 XOR 的交换律和结合律，总 XOR 和中的运算顺序不影响最终结果。我们可以重新组合数组中的元素，将相同的值配对：\n$$ R = (v_1 \\oplus v_1) \\oplus (v_2 \\oplus v_2) \\oplus \\dots \\oplus (v_k \\oplus v_k) \\oplus u $$\n对每一对应用自身求反性质 $a \\oplus a = 0$：\n$$ v_i \\oplus v_i = 0 \\quad \\text{for } i = 1, \\dots, k $$\n将此结果代入 $R$ 的表达式中：\n$$ R = 0 \\oplus 0 \\oplus \\dots \\oplus 0 \\oplus u $$\n任意数量的 $0$ 进行 XOR 求和的结果是 $0$。因此，表达式简化为：\n$$ R = 0 \\oplus u $$\n最后，应用单位元性质 $a \\oplus 0 = a$：\n$$ R = u $$\n此推导严谨地证明了数组中所有元素的 XOR 和恰好等于唯一元素 $u$。\n\n这引导出以下算法：\n1.  初始化一个累加器变量为 $0$，这是 XOR 运算的单位元。\n2.  从索引 $i=0$ 到 $n-1$ 遍历数组 $A$。\n3.  对于每个元素 $A[i]$，通过计算 `accumulator = accumulator` $\\oplus$ `A[i]` 来更新累加器。\n4.  迭代完成后，累加器的最终值就是那个唯一的元素。\n\n该算法对 $n$ 个元素中的每一个访问一次，每次执行一次常数时间的 XOR 运算。因此，其时间复杂度为 $O(n)$。该算法只需要一个变量作为累加器，因此其空间复杂度为 $O(1)$。这些复杂度满足问题的要求。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and applies an algorithm to find the single unique element in arrays\n    where all other elements appear twice, using only bitwise XOR operations.\n    \"\"\"\n\n    def find_unique_element(arr: np.ndarray) - np.int64:\n        \"\"\"\n        Computes the unique element in an array by XORing all its elements.\n\n        This method is based on the algebraic properties of XOR:\n        1. a ^ a = 0 (self-inverse)\n        2. a ^ 0 = a (identity)\n        3. a ^ b = b ^ a (commutativity)\n        4. (a ^ b) ^ c = a ^ (b ^ c) (associativity)\n\n        The XOR sum of all elements simplifies to the unique element because all\n        paired elements cancel each other out (e.g., v1^v1^v2^v2^u = 0^0^u = u).\n\n        Args:\n            arr: A NumPy array of integers where one element appears once\n                 and all others appear twice.\n\n        Returns:\n            The integer that appears exactly once in the array.\n        \"\"\"\n        # The identity element for the XOR operation is 0.\n        # We use a fixed-size integer type consistent with a static array model.\n        accumulator = np.int64(0)\n        \n        # Iterate through all elements of the array.\n        for element in arr:\n            # Update the accumulator by XORing it with the current element.\n            accumulator ^= element\n            \n        return accumulator\n\n    # Define the test cases from the problem statement.\n    # The arrays are defined with a 64-bit integer type to accommodate the\n    # full range of values including negatives and large numbers.\n    test_cases = [\n        np.array([2, 1, 4, 5, 2, 4, 1], dtype=np.int64),\n        np.array([42], dtype=np.int64),\n        np.array([-7, -7, 0, 0, -3], dtype=np.int64),\n        np.array([2147483647, 99, 2147483647], dtype=np.int64),\n        np.array([8, 9, 9, 10, 10, 11, 11, 12, 12, 8, 13], dtype=np.int64),\n    ]\n\n    results = []\n    for case in test_cases:\n        # For each test case, apply the derived algorithm.\n        unique_element = find_unique_element(case)\n        results.append(unique_element)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3275306"}, {"introduction": "优秀的解题者不仅会应用已知的技巧，更懂得理解其底层原理并加以推广。最后一个练习 [@problem_id:3217582] 将挑战你将前一个问题的逻辑扩展到一个更复杂的场景。你不能再仅仅依赖异或的自反性质，而是需要更深入地分析数字的位模式，利用模运算来逐位重构目标数字，这是一种强大的技术，适用于解决众多难题。", "problem": "要求您设计并实现一个基于位运算的算法，用于在一个多重集中恢复一个与其他所有整数重数不同的单一整数。假设有一个整数数组，其中包含带符号的 $64$ 位整数，每个不同的整数都恰好出现 $k$ 次，只有一个整数例外，它恰好出现 $p$ 次，且 $1 \\le p  k$。目标是基于二进制表示和模运算的基本原理，在与元素数量成线性关系的时间内，并使用相对于输入大小为常数的辅助空间，计算出这个唯一的整数，且不依赖于哈希或排序。保证输入中的所有整数都在带符号的 $64$ 位范围内，即 $\\left[-2^{63},2^{63}-1\\right]$。\n\n使用的基本原理：\n- 整数的二进制表示和位运算，包括对 $64$ 位固定字长上的按位与、按位或和移位操作，其中带符号值使用二进制补码编码。\n- 以 $k$ 为模的模运算，特别是模约简对加法的分配律。\n- 二进制补码中位的语义，包括位于位置 $63$ 的表示符号的最高有效位 (MSB)，以及位于位置 $0$ 的最低有效位 (LSB)。\n\n您的程序必须为以下每个测试用例计算出唯一的整数，每个测试用例均指定为一个三元组 $\\left(\\text{array},k,p\\right)$：\n- 测试用例 1：$\\left(\\left[2,2,2,7,-1,-1,-1,42,42,42\\right],3,1\\right)$\n- 测试用例 2：$\\left(\\left[13,13,0,0,0,0,0,-4,-4,-4,-4,-4,22,22,22,22,22\\right],5,2\\right)$\n- 测试用例 3：$\\left(\\left[0,0,0,5,5,5,5,-7,-7,-7,-7\\right],4,3\\right)$\n- 测试用例 4：$\\left(\\left[-15,-15,-15,-15,-15,-15,1,1,1,1,1,1,1,3,3,3,3,3,3,3\\right],7,6\\right)$\n- 测试用例 5：$\\left(\\left[-8,-8,17,17,1152921504606847099\\right],2,1\\right)$ 其中 $1152921504606847099=2^{60}+123$。\n- 测试用例 6：$\\left(\\left[-4611686018427387897,-4611686018427387897,9,9,9,0,0,0\\right],3,2\\right)$ 其中 $-4611686018427387897=-2^{62}+7$。\n\n您的算法除了给定的重数和固定字长的二进制补码模型外，不能假设任何其他属性，并且必须通过对位级结构和模属性进行推理来重构答案。整个测试套件的最终输出必须是对应每个测试用例唯一数字的整数列表，以单行形式生成，并作为用方括号括起来的逗号分隔列表。例如，输出格式必须是 $\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\ldots\\right]$。此问题中不涉及物理单位、角度或百分比；所有输出都是纯整数。", "solution": "问题陈述经过严格验证，被认为是自洽的、有科学依据的、良定的和客观的。这是一个基于计算机科学和数学基本原理的算法设计中的正式问题。\n\n解决此问题的核心原理是逐位重构这个唯一的整数。这可以通过利用模运算的性质，分析数组中所有数字在每个位上的比特总和来实现。这些整数是带符号的 $64$ 位值，这意味着我们必须考虑 $W=64$ 的位宽。问题对时间（$O(N)$，其中 $N$ 是元素数量）和空间（$O(1)$）的限制排除了排序或使用辅助数据结构（如哈希表）的方法。\n\n设输入数组为 $A$。该数组包含一个整数多重集，其中每个不同的数都出现 $k$ 次，只有一个唯一的整数例外，我们称之为 $x$，它出现 $p$ 次，且 $1 \\le p  k$。设其他不同整数的集合为 $\\{y_1, y_2, \\ldots, y_m\\}$。\n\n考虑单个比特位 $j$，其中 $j$ 的范围从 $0$（最低有效位，LSB）到 $63$（最高有效位，MSB）。设 $b_j(n) \\in \\{0, 1\\}$ 为整数 $n$ 的第 $j$ 位的值。该算法的基础是计算数组 $A$ 中所有数字的第 $j$ 位之和。设这个和为 $S_j$：\n$$ S_j = \\sum_{n \\in A} b_j(n) $$\n这个和可以根据数字的重数进行划分。唯一的数字 $x$ 对这个和的贡献是 $p \\cdot b_j(x)$，而其他每个数字 $y_i$ 的贡献是 $k \\cdot b_j(y_i)$。因此，总和可以表示为：\n$$ S_j = p \\cdot b_j(x) + \\sum_{i=1}^{m} k \\cdot b_j(y_i) = p \\cdot b_j(x) + k \\sum_{i=1}^{m} b_j(y_i) $$\n第二项 $k \\sum_{i=1}^{m} b_j(y_i)$ 根据定义是 $k$ 的整数倍。设 $N_j = \\sum_{i=1}^{m} b_j(y_i)$，这只是第 $j$ 位为1的“非唯一”数字的计数。方程变为：\n$$ S_j = p \\cdot b_j(x) + k \\cdot N_j $$\n现在，我们应用模为 $k$ 的模运算。对该方程取模 $k$：\n$$ S_j \\pmod k = (p \\cdot b_j(x) + k \\cdot N_j) \\pmod k $$\n利用模加法的性质 $(a+b) \\pmod k = ((a \\pmod k) + (b \\pmod k)) \\pmod k$：\n$$ S_j \\pmod k = (p \\cdot b_j(x) \\pmod k + k \\cdot N_j \\pmod k) \\pmod k $$\n因为 $k \\cdot N_j \\pmod k = 0$，方程简化为：\n$$ S_j \\pmod k = (p \\cdot b_j(x)) \\pmod k $$\n我们必须确定 $b_j(x)$ 的值，它只能是 $0$ 或 $1$。\n情况1：唯一数 $x$ 的第 $j$ 位是 $0$，即 $b_j(x) = 0$。在这种情况下，方程变为 $S_j \\pmod k = (p \\cdot 0) \\pmod k = 0$。\n情况2：唯一数 $x$ 的第 $j$ 位是 $1$，即 $b_j(x) = 1$。在这种情况下，方程变为 $S_j \\pmod k = (p \\cdot 1) \\pmod k = p \\pmod k$。根据题目约束 $1 \\le p  k$，我们知道 $p$ 不是 $k$ 的倍数，具体来说 $p \\pmod k = p$。因此，如果 $b_j(x)=1$，那么 $S_j \\pmod k = p$，这是一个非零值。\n\n结合这两种情况，可以得出一个明确的决策规则：\n- 如果 $S_j \\pmod k = 0$，那么 $b_j(x)$ 必定是 $0$。\n- 如果 $S_j \\pmod k \\neq 0$，那么 $b_j(x)$ 必定是 $1$。\n\n这个逻辑使我们能够独立地确定唯一数 $x$ 的每一位。算法流程如下：\n1.  将一个 $64$ 位的结果整数 `result` 初始化为 $0$。\n2.  对从 $0$ 到 $63$ 的每个比特位 $j$ 进行迭代。\n3.  对于每个 $j$，计算输入数组中所有数字的第 $j$ 位之和 $S_j$。\n4.  计算 $S_j \\pmod k$。\n5.  如果结果非零，则表示唯一数 $x$ 的第 $j$ 位是 $1$。在这种情况下，使用与掩码的按位或操作来设置 `result` 的第 $j$ 位：`result |= (1  j)`。\n\n这个过程对于二进制补码表示的带符号整数是成立的。位逻辑作用于数字的二进制表示，而计数属性与一个位是正数表示的一部分还是负数表示的一部分无关。当一个数是负数时，使用的是它的二进制补码表示。对每个位置的位相加可以正确地计算所有数字（无论正负）的贡献。在遍历所有 $64$ 个位之后，`result` 变量将持有唯一数 $x$ 的完整的 $64$ 位二进制补码表示。\n\n实现必须小心处理 $64$ 位带符号整数。由于标准 Python 整数具有任意精度，我们将使用 `numpy.int64` 和 `numpy.uint64` 来强制执行问题中指定的固定宽度语义，特别是对于像移位和掩码这样的位运算，以确保符号扩展和位模式被正确处理。\n对于输入中的每个数字 `num` 和每个比特位 `j`，我们提取其第 $j$ 位。通过将 `num` 转换为一个无符号的 $64$ 位整数 `numpy.uint64(num)`，然后使用位运算，可以可靠地完成此操作。这可以防止对负数进行右移操作时出现符号扩展问题。最终累积的位模式存储在一个 `numpy.uint64` 变量中，然后被转换回 `numpy.int64`，以产生最终的带符号整数结果。\n\n时间复杂度由两个嵌套循环决定。外层循环运行固定的 $64$ 次。内层循环遍历输入数组的 $N$ 个元素。这给出了 $O(64 \\cdot N)$ 的总时间复杂度，即 $O(N)$。空间复杂度是 $O(1)$，因为我们只使用了几个固定大小的变量（例如，用于位和与结果），而与输入大小 $N$ 无关。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef find_unique_integer(arr, k, p):\n    \"\"\"\n    Finds the integer that appears p times in an array where all other\n    distinct integers appear k times.\n\n    The algorithm reconstructs the unique integer bit by bit. For each bit\n    position j from 0 to 63, it sums the j-th bits of all numbers in the\n    array. Let this sum be S_j. The sum of bits from numbers that appear k\n    times will be a multiple of k. Thus, S_j mod k will reveal the j-th\n    bit of the unique number.\n\n    Specifically, S_j = (p * b_j(x)) + (k * M), where b_j(x) is the j-th\n    bit of the unique number x, and M is an integer.\n    So, S_j mod k = (p * b_j(x)) mod k.\n    Since 1 = p  k, p is not a multiple of k.\n    - If b_j(x) = 0, then S_j mod k = 0.\n    - If b_j(x) = 1, then S_j mod k = p != 0.\n    Thus, a non-zero remainder implies the j-th bit of x is 1.\n\n    Args:\n        arr (list): A list of integers.\n        k (int): The multiplicity of the non-unique numbers.\n        p (int): The multiplicity of the unique number.\n\n    Returns:\n        numpy.int64: The integer with unique multiplicity.\n    \"\"\"\n    \n    # The result is built up as an unsigned 64-bit integer to correctly handle\n    # bitwise operations on all 64 bits, including the sign bit.\n    result_unsigned = np.uint64(0)\n    \n    # Iterate over each of the 64 bit positions\n    for j in range(64):\n        bit_sum = 0\n        \n        # Create a mask to isolate the j-th bit. Must be uint64 to avoid overflow warnings\n        # for j=63, as 1  63 would be negative in signed int64.\n        bit_mask = np.uint64(1)  np.uint64(j)\n        \n        for num_py in arr:\n            # Cast the Python int to a numpy 64-bit signed integer to work with\n            # a fixed-width two's complement representation.\n            num_np = np.int64(num_py)\n            \n            # To check the j-th bit correctly for both positive and negative numbers,\n            # we cast the number's bit pattern to its unsigned equivalent.\n            # This ensures that bitwise operations (like ) treat all bits,\n            # including the MSB (sign bit), uniformly as data.\n            if (np.uint64(num_np)  bit_mask):\n                bit_sum += 1\n        \n        # If the sum of bits at this position is not a multiple of k,\n        # it means the unique number has a '1' at this bit position.\n        if bit_sum % k != 0:\n            # Set the corresponding bit in our result.\n            result_unsigned |= bit_mask\n            \n    # Cast the final unsigned bit pattern back to a signed 64-bit integer.\n    # This correctly reinterprets the two's complement representation.\n    return np.int64(result_unsigned)\n\ndef solve():\n    \"\"\"\n    Defines test cases and runs the solver for each, printing the final results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        ([2,2,2,7,-1,-1,-1,42,42,42], 3, 1),\n        ([13,13,0,0,0,0,0,-4,-4,-4,-4,-4,22,22,22,22,22], 5, 2),\n        ([0,0,0,5,5,5,5,-7,-7,-7,-7], 4, 3),\n        ([-15,-15,-15,-15,-15,-15,1,1,1,1,1,1,1,3,3,3,3,3,3,3], 7, 6),\n        ([-8,-8,17,17,1152921504606847099], 2, 1),\n        ([-4611686018427387897,-4611686018427387897,9,9,9,0,0,0], 3, 2),\n    ]\n\n    results = []\n    for arr, k, p in test_cases:\n        # The parameter 'p' is not strictly necessary for this implementation\n        # but is passed for completeness according to the problem statement.\n        result = find_unique_integer(arr, k, p)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3217582"}]}