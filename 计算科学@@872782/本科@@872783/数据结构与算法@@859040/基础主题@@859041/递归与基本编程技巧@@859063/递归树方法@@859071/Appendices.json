{"hands_on_practices": [{"introduction": "递归树方法的一个常见应用场景是分析每层递归工作量大致相等的情形。本练习 [@problem_id:3265011] 探讨了一个典型的分治算法，其中每层的非递归工作量都与 $n$ 和该层的深度有关。通过从第一性原理出发，构建并求和递归树的每一层成本，我们将推导出总运行时间，并理解为何最终的复杂度会出现 $n (\\ln n)^2$ 这样的形式。", "problem": "您正在分析一个分治算法的运行时间，该算法对于大小为 $n$ 的输入，将问题分解为 $2$ 个大小为 $n/2$ 的子问题，并在进行递归调用前执行 $g(n)$ 单位的非递归工作。您希望整个递归树的总工作量量级为 $\\mathcal{O}\\!\\left(n(\\ln n)^{2}\\right)$。考虑 $g(n)=n\\ln n$ 这一具体选择，并定义递推关系\n$$\nT(n)=2\\,T\\!\\left(\\frac{n}{2}\\right)+n\\ln n,\\quad T(1)=0,\n$$\n并简化假设 $n$ 是 $2$ 的幂。使用第一性原理的递归树方法（计算每层的节点数和每个节点的工作量），推导 $T(n)$ 作为 $n$ 的函数的精确闭式表达式。将您的最终答案表示为关于 $n$ 的单个简化解析表达式。除非指明底数，否则所有对数均为自然对数。最终答案中不要使用渐近符号。", "solution": "首先将对问题陈述进行严格的验证过程。\n\n### 第 1 步：提取已知条件\n从问题陈述中逐字提取的已知条件如下：\n- 递推关系：$T(n)=2\\,T\\!\\left(\\frac{n}{2}\\right)+n\\ln n$\n- 基本情况：$T(1)=0$\n- 假设：$n$ 是 $2$ 的幂。\n- 方法：基于第一性原理的递归树方法。\n- 期望输出：$T(n)$ 的精确闭式表达式。\n- 对数约定：除非明确指出底数，否则所有对数都是自然对数，记为 $\\ln$。\n\n陈述中还包括一个上下文备注，即对于函数 $g(n)=n\\ln n$，总工作量的量级预计为 $\\mathcal{O}\\!\\left(n(\\ln n)^{2}\\right)$。这可作为对最终结果进行渐近检查的指南。\n\n### 第 2 步：使用提取的已知条件进行验证\n根据既定标准对问题进行评估：\n- **科学依据：** 该问题是算法分析中的一个标准练习，这是计算机科学和离散数学的核心课题。该递推关系是分治算法的典型形式。所涉及的对象和运算都有明确的数学定义。该问题是科学合理的。\n- **适定性：** 该问题是适定的。它提供了一个常系数线性递推关系、一个已定义的非齐次项 ($n\\ln n$) 和一个必要的基本情况 ($T(1)=0$)。$n$ 是 $2$ 的幂这一约束确保了 $T$ 的参数在整个递归过程中保持为整数，从而简化了分析。这些条件保证了唯一精确解的存在。\n- **客观性：** 该问题以精确、形式化的数学语言陈述，没有任何主观性、模糊性或基于观点的主张。\n\n基于此分析，该问题没有任何科学或逻辑上的缺陷，是自包含的，且结构清晰明确。因此，判定该问题为 **有效**。\n\n### 第 3 步：结论与行动\n该问题有效。现在将推导完整的解答。\n\n问题要求在 $n$ 是 $2$ 的幂的假设下，解出递推关系\n$$\nT(n)=2T\\left(\\frac{n}{2}\\right)+n\\ln(n)\n$$\n及其基本情况 $T(1)=0$。我们将按照规定使用递归树方法。\n\n递归树将递归调用的成本可视化。树中的每个节点代表为特定大小的子问题所执行的非递归工作。树的根节点对应大小为 $n$ 的初始问题。根节点的非递归工作量为 $n\\ln(n)$。根节点有两个子节点，每个子节点代表一个大小为 $n/2$ 的子问题。\n\n让我们逐层分析这棵树。我们定义根节点位于第 $i=0$ 层。\n- **第 $i=0$ 层**：有 $1=2^0$ 个节点，对应于大小为 $n/2^0 = n$ 的问题。该节点的工作量为 $n\\ln(n)$。该层的总工作量为 $1 \\cdot n\\ln(n) = n\\ln(n)$。\n- **第 $i=1$ 层**：有 $2=2^1$ 个节点，每个节点对应大小为 $n/2^1 = n/2$ 的子问题。每个节点的工作量为 $(n/2)\\ln(n/2)$。该层的总工作量为 $2 \\cdot (n/2)\\ln(n/2) = n\\ln(n/2)$。\n- **第 $i$ 层**：通过归纳法，在深度为 $i$ 时，有 $2^i$ 个节点。每个节点对应大小为 $n/2^i$ 的子问题。在每个此类节点上执行的非递归工作量为 $(n/2^i)\\ln(n/2^i)$。第 $i$ 层的总工作量是节点数与每个节点工作量的乘积：\n$$\n\\text{Work}_{\\text{level } i} = 2^i \\cdot \\left(\\frac{n}{2^i}\\right) \\ln\\left(\\frac{n}{2^i}\\right) = n \\ln\\left(\\frac{n}{2^i}\\right)\n$$\n当子问题的大小变为 $1$ 时，递归终止。设 $k$ 为此时树的深度。我们将子问题大小设为 $1$：\n$$\n\\frac{n}{2^k} = 1 \\implies n = 2^k \\implies k = \\log_2(n)\n$$\n由于我们假设 $n$ 是 $2$ 的幂，所以 $k$ 是一个整数。树共有 $k+1$ 层，索引从 $i=0$ 到 $i=k$。叶节点位于第 $k$ 层。\n叶节点（第 $k$ 层）的工作量对应于基本情况 $T(1)$。问题陈述中 $T(1)=0$，因此叶节点层的总工作量为 $2^k \\cdot T(1) = n \\cdot 0 = 0$。\n\n总工作量 $T(n)$ 是从根节点到叶节点前一层（即从 $i=0$ 到 $i=k-1$）所有层级工作量的总和。\n$$\nT(n) = \\sum_{i=0}^{k-1} \\text{Work}_{\\text{level } i} = \\sum_{i=0}^{\\log_2(n)-1} n \\ln\\left(\\frac{n}{2^i}\\right)\n$$\n现在我们来计算这个和。\n$$\nT(n) = n \\sum_{i=0}^{\\log_2(n)-1} \\left[ \\ln(n) - \\ln(2^i) \\right] = n \\sum_{i=0}^{\\log_2(n)-1} \\left[ \\ln(n) - i\\ln(2) \\right]\n$$\n为简化计算过程中的符号，我们代入 $k=\\log_2(n)$。\n$$\nT(n) = n \\sum_{i=0}^{k-1} (\\ln(n) - i\\ln(2))\n$$\n我们可以将求和分为两部分：\n$$\nT(n) = n \\left[ \\sum_{i=0}^{k-1} \\ln(n) - \\sum_{i=0}^{k-1} i\\ln(2) \\right] = n \\left[ \\ln(n) \\sum_{i=0}^{k-1} 1 - \\ln(2) \\sum_{i=0}^{k-1} i \\right]\n$$\n第一个和是 $k$ 个项的和：$\\sum_{i=0}^{k-1} 1 = k$。\n第二个和是等差数列的和：$\\sum_{i=0}^{k-1} i = \\frac{(k-1)k}{2}$。\n将这些结果代回 $T(n)$ 的表达式中：\n$$\nT(n) = n \\left[ k\\ln(n) - \\ln(2) \\frac{k(k-1)}{2} \\right]\n$$\n为了得到以 $n$ 表示的最终表达式，我们代入 $k = \\log_2(n)$。使用换底公式 $\\log_2(n) = \\frac{\\ln(n)}{\\ln(2)}$ 会很方便。\n$$\nT(n) = n \\left[ \\frac{\\ln(n)}{\\ln(2)} \\ln(n) - \\frac{\\ln(2)}{2} \\frac{\\ln(n)}{\\ln(2)} \\left(\\frac{\\ln(n)}{\\ln(2)} - 1\\right) \\right]\n$$\n$$\nT(n) = n \\left[ \\frac{(\\ln(n))^2}{\\ln(2)} - \\frac{\\ln(n)}{2} \\left(\\frac{\\ln(n) - \\ln(2)}{\\ln(2)}\\right) \\right]\n$$\n提出公因式 $\\frac{n}{\\ln(2)}$：\n$$\nT(n) = \\frac{n}{\\ln(2)} \\left[ (\\ln(n))^2 - \\frac{\\ln(n)}{2}(\\ln(n) - \\ln(2)) \\right]\n$$\n$$\nT(n) = \\frac{n}{\\ln(2)} \\left[ (\\ln(n))^2 - \\frac{1}{2}(\\ln(n))^2 + \\frac{1}{2}\\ln(n)\\ln(2) \\right]\n$$\n$$\nT(n) = \\frac{n}{\\ln(2)} \\left[ \\frac{1}{2}(\\ln(n))^2 + \\frac{1}{2}\\ln(n)\\ln(2) \\right]\n$$\n从括号内的项中提出因子 $\\frac{1}{2}$ 和 $\\ln(n)$ 得：\n$$\nT(n) = \\frac{n}{2\\ln(2)} \\left[ (\\ln(n))^2 + \\ln(n)\\ln(2) \\right] = \\frac{n \\ln(n) (\\ln(n) + \\ln(2))}{2 \\ln(2)}\n$$\n这就是 $T(n)$ 的精确闭式表达式。首项与 $n(\\ln n)^2$ 成正比，这与问题描述中提到的量级 $\\mathcal{O}(n(\\ln n)^2)$ 一致。\n对基本情况 $T(1)=0$ 进行检验，确认结果：\n$$\nT(1) = \\frac{1 \\ln(1) (\\ln(1) + \\ln(2))}{2 \\ln(2)} = \\frac{1 \\cdot 0 \\cdot (0 + \\ln(2))}{2 \\ln(2)} = 0\n$$\n推导完成，结果已验证。", "answer": "$$\n\\boxed{\\frac{n \\ln(n) (\\ln(n) + \\ln(2))}{2 \\ln(2)}}\n$$", "id": "3265011"}, {"introduction": "与上一练习不同，并非所有递归算法的成本都均匀分布在递归树的各个层级。在本练习 [@problem_id:3248716] 中，我们将分析一种“叶节点主导”的情形。这里的关键在于，尽管每次划分和合并的成本（$f(n) = \\sqrt{n}$）随着问题规模的减小而降低，但子问题的数量增长得非常快，导致总成本的绝大部分集中在递归树最底层的叶节点上。", "problem": "一个对大小为 $n$ 的输入进行的分治过程，其分割步骤会产生 2 个大小为 $n/3$ 的子问题，并在递归调用之外产生与 $\\sqrt{n}$ 成正比的额外非递归成本。令 $T(n)$ 表示总工作量。假设 $n$ 被限制为 3 的幂，以便分割是精确的，并使用基准条件 $T(1)=\\Theta(1)$。请不要引用任何已有的定理，而是从第一性原理出发，通过对递归结构和各递归层级的总工作量进行推理，推导出 $T(n)$ 的一个紧渐近表达式。你的最终答案必须是一个单一的闭式解析表达式。无需四舍五入，也不涉及物理单位。递推关系为\n$$\nT(n)=2\\,T\\!\\left(\\frac{n}{3}\\right)+\\sqrt{n}.\n$$\n请以大西塔符号（Big-Theta notation）的形式提供最终的单一解析表达式。", "solution": "用户希望我解决并提供对提示中所述问题的解答。\n\n### 步骤1：提取已知条件\n- 递推关系：$T(n) = 2T(n/3) + \\sqrt{n}$\n- 对 $n$ 的约束：$n$ 是 3 的幂。\n- 基准情形：$T(1) = \\Theta(1)$。\n\n### 步骤2：使用提取的已知条件进行验证\n该问题是计算机科学领域（算法分析）中的一个标准递推关系分析问题。\n- **科学依据**：该问题在数学上是明确定义的，并使用了既定概念来分析算法复杂度。它是合理的。\n- **良态的**：递推关系、基准情形和对 $n$ 的约束都已提供，构成了一个完整的规范，可以推导出唯一的渐近解。\n- **客观性**：该问题使用精确、客观的数学语言陈述。\n- **其他缺陷**：该问题没有表现出任何其他无效标志。它不是不完整、矛盾、不切实际、病态或微不足道的。避免使用已有定理的指令是对求解方法的教学约束，而不是问题本身的缺陷。\n\n### 步骤3：结论与行动\n问题有效。将提供解决方案。\n\n***\n\n我们被要求找到满足递推关系 $T(n) = 2T(n/3) + \\sqrt{n}$ 的 $T(n)$ 的一个紧渐近表达式。我们将使用递归树方法从第一性原理来解决这个问题。\n\n让我们假设非递归成本为 $c_1\\sqrt{n}$（对于某个常数 $c_1  0$），基准情形为 $T(1) = c_2$（对于某个常数 $c_2  0$），这与 $T(1) = \\Theta(1)$ 一致。递推关系为 $T(n) = 2T(n/3) + c_1\\sqrt{n}$。\n\n我们构建一个递归树来可视化所做的工作。\n树的根代表大小为 $n$ 的初始问题。在根节点完成的非递归工作量是 $c_1\\sqrt{n}$。这是第 0 层。\n根节点产生 2 个大小为 $n/3$ 的子问题。它们构成树的第 1 层。\n在递归树的第 $i$ 层（其中根在第 0 层），我们有：\n- 节点（子问题）数量：$2^i$。\n- 每个子问题的大小：$n/3^i$。\n- 每个节点完成的工作量（非递归部分）：$c_1\\sqrt{n/3^i} = c_1\\frac{\\sqrt{n}}{(\\sqrt{3})^i}$。\n- 第 $i$ 层所有节点完成的总工作量：$W_i = 2^i \\times \\left(c_1\\frac{\\sqrt{n}}{(\\sqrt{3})^i}\\right) = c_1\\sqrt{n}\\left(\\frac{2}{\\sqrt{3}}\\right)^i$。\n\n当子问题的大小变为 1 时，递归终止。设 $d$ 为树的深度。这发生在 $n/3^d = 1$ 时，这意味着 $3^d = n$，所以 $d = \\log_3(n)$。\n\n总工作量 $T(n)$ 是从第 0 层到第 $d$ 层所有层级完成的工作量之和。\n$$ T(n) = \\sum_{i=0}^{d} W_i $$\n这个总和可以分为内部节点（第 0 层到第 $d-1$ 层）的工作量之和与叶节点（第 $d$ 层）的工作量之和。\n\n叶子层的工作量 $W_d$ 对应于基准情形。\n在第 $d$ 层，有 $2^d$ 个节点，每个节点对应一个大小为 $n/3^d = 1$ 的问题。每个问题的工作量是 $T(1) = c_2$。\n所以，叶子节点处的总工作量是 $W_{leaves} = 2^d \\cdot T(1) = c_2 \\cdot 2^d$。\n因为 $d = \\log_3(n)$，我们有 $2^d = 2^{\\log_3(n)}$。使用对数恒等式 $a^{\\log_b(c)} = c^{\\log_b(a)}$，我们得到：\n$2^{\\log_3(n)} = n^{\\log_3(2)}$。\n因此，叶子节点处的工作量是 $W_{leaves} = c_2 n^{\\log_3(2)}$。\n\n内部节点的工作量是从 $i=0$ 到 $d-1$ 的总和：\n$$ W_{internal} = \\sum_{i=0}^{d-1} W_i = \\sum_{i=0}^{d-1} c_1\\sqrt{n}\\left(\\frac{2}{\\sqrt{3}}\\right)^i = c_1\\sqrt{n} \\sum_{i=0}^{d-1} \\left(\\frac{2}{\\sqrt{3}}\\right)^i $$\n这是一个公比为 $r = 2/\\sqrt{3}$ 的几何级数。由于 $4  3$，我们有 $2  \\sqrt{3}$，所以 $r  1$。\n有限几何级数的和由 $\\sum_{k=0}^{m-1} r^k = \\frac{r^m - 1}{r - 1}$ 给出。\n这里，$m=d$ 且 $r = 2/\\sqrt{3}$。\n$$ W_{internal} = c_1\\sqrt{n} \\left( \\frac{(2/\\sqrt{3})^d - 1}{2/\\sqrt{3} - 1} \\right) $$\n让我们简化常数部分：$\\frac{1}{2/\\sqrt{3} - 1} = \\frac{\\sqrt{3}}{2 - \\sqrt{3}}$。设这个常数为 $C_3$。\n$$ W_{internal} = c_1 C_3 \\sqrt{n} \\left( \\left(\\frac{2}{\\sqrt{3}}\\right)^d - 1 \\right) $$\n现在，代入 $d = \\log_3(n)$：\n$$ \\left(\\frac{2}{\\sqrt{3}}\\right)^d = \\frac{2^d}{(\\sqrt{3})^d} = \\frac{2^{\\log_3(n)}}{(3^{1/2})^{\\log_3(n)}} = \\frac{n^{\\log_3(2)}}{(3^{\\log_3(n)})^{1/2}} = \\frac{n^{\\log_3(2)}}{n^{1/2}} $$\n将此代回 $W_{internal}$ 的表达式中：\n$$ W_{internal} = c_1 C_3 \\sqrt{n} \\left( \\frac{n^{\\log_3(2)}}{n^{1/2}} - 1 \\right) = c_1 C_3 \\left( \\sqrt{n} \\frac{n^{\\log_3(2)}}{\\sqrt{n}} - \\sqrt{n} \\right) = c_1 C_3 \\left( n^{\\log_3(2)} - \\sqrt{n} \\right) $$\n\n总工作量是 $T(n) = W_{internal} + W_{leaves}$。\n$$ T(n) = c_1 C_3 \\left( n^{\\log_3(2)} - \\sqrt{n} \\right) + c_2 n^{\\log_3(2)} $$\n$$ T(n) = (c_1 C_3 + c_2) n^{\\log_3(2)} - c_1 C_3 \\sqrt{n} $$\n为了找到紧渐近界，我们比较 $n^{\\log_3(2)}$ 和 $\\sqrt{n} = n^{1/2}$ 这两项。我们需要比较指数 $\\log_3(2)$ 和 $1/2$。\n我们有 $\\log_3(2) = \\frac{\\ln(2)}{\\ln(3)} \\approx \\frac{0.693}{1.098} \\approx 0.6309$。\n由于 $\\log_3(2)  1/2$，对于大的 $n$，项 $(c_1 C_3 + c_2) n^{\\log_3(2)}$ 主导项 $-c_1 C_3 \\sqrt{n}$。\n系数 $(c_1 C_3 + c_2)$ 和 $-c_1 C_3$ 是常数。\n因此，$T(n)$ 的渐近行为由主导项决定：\n$$ T(n) = \\Theta\\left(n^{\\log_3(2)}\\right) $$\n这就完成了从第一性原理的推导。", "answer": "$$\\boxed{\\Theta\\left(n^{\\log_{3}(2)}\\right)}$$", "id": "3248716"}, {"introduction": "递归树方法不仅能分析时间复杂度，它同样是分析空间复杂度的有力工具。本练习 [@problem_id:3265136] 将我们的视角从“总工作量”转移到“峰值内存使用”。我们将通过分析一个算法在深度优先递归调用期间的栈内存分配，来理解如何建立并求解关于最大内存占用的递归关系，从而展示该方法在不同资源分析中的普适性。", "problem": "考虑一个作用于大小为 $n \\in \\mathbb{N}$ 的输入的递归过程，其中 $n$ 是 $2$ 的幂。对于每一次参数 $m  1$ 的调用，该过程会分配恰好 $\\alpha \\,\\ln m$ 单位的栈内存（其中 $\\alpha  0$ 是一个固定常数，$\\ln$ 表示自然对数），然后以深度优先的顺序进行两次递归调用：首先是对大小为 $m/2$ 的输入进行调用，在该调用返回后，再对大小为 $m/4$ 的输入进行调用。大小为 $\\alpha \\,\\ln m$ 的栈帧会一直保持分配状态，直到两次递归调用都返回。对于 $m \\leq 1$，该过程立即返回，不分配任何内存。忽略任何未明确说明的内存开销。\n\n仅使用算法分析中关于递归树和调用栈的基本原理，推导在输入大小为 $n$ 的执行过程中任意时刻使用的最大瞬时栈内存 $M(n)$ 的精确闭式表达式。您的分析必须基于递归树的结构特性（节点标签和深度）以及调用栈帧在其返回前持续存在的定义进行推理。请用一个包含 $n$ 和 $\\alpha$ 的单一解析表达式来表示您的最终答案，使用初等函数，并可以利用 $n$ 是 $2$ 的幂这一事实。在您的最终答案中不要使用渐近符号。", "solution": "### 第一步：提取已知条件\n- 输入大小为 $n \\in \\mathbb{N}$，其中 $n$ 是 $2$ 的幂。\n- 递归过程是为参数 $m$ 定义的。\n- 对于 $m  1$，过程分配 $\\alpha \\ln m$ 单位的栈内存，其中 $\\alpha  0$ 是一个常数。\n- 该过程以深度优先顺序进行两次递归调用：首先是对大小为 $m/2$ 的输入，然后是对大小为 $m/4$ 的输入。\n- 大小为 $\\alpha \\ln m$ 的栈帧会一直保持分配状态，直到对 $m/2$ 和 $m/4$ 的两次递归调用都返回。\n- 对于 $m \\leq 1$，过程不分配内存并返回。\n- 目标是找到最大瞬时栈内存 $M(n)$ 的一个关于 $n$ 和 $\\alpha$ 的精确闭式表达式。\n\n### 第二步：使用提取的已知条件进行验证\n该问题具有科学依据、良构性和客观性。\n- **科学依据：** 该问题涉及递归、调用栈和算法分析，这些都是计算机科学（一门形式化的STEM学科）的核心概念。对数和求和的使用在数学上是合理的。\n- **良构性：** 问题陈述清晰且自成体系。约束条件（$n$ 是 $2$ 的幂，深度优先顺序）和内存分配规则都得到了精确规定。这种结构确保了存在一个唯一的、有意义的解。\n- **客观性：** 语言正式且无歧义。各数量都经过了数学上的精确定义（例如 $\\alpha \\ln m$）。不存在主观或基于观点的内容。\n\n该问题没有任何无效性缺陷。它是算法分析中的一个标准问题。\n\n### 第三步：结论与行动\n问题有效。将提供完整解答。\n\n### 解题推导\n设 $M(m)$ 为在对大小为 $m$ 的输入执行该过程期间任意时刻使用的最大瞬时栈内存。我们需要求的是 $M(n)$。\n\n问题陈述，对于一个输入 $m  1$，会分配一个大小为 $\\alpha \\ln m$ 的栈帧。该帧在过程进行两次连续的、深度优先的调用期间持续存在：首先是 `procedure(m/2)`，然后是 `procedure(m/4)`。\n\n让我们分析 `procedure(m)` 执行期间的内存使用情况。\n1.  `procedure(m)` 的栈帧被压入栈中，消耗 $\\alpha \\ln m$ 的内存。\n2.  进行第一次递归调用 `procedure(m/2)`。在此子问题执行的整个过程中，栈中都包含 `procedure(m)` 的栈帧。此阶段的最大内存使用量是当前栈帧的内存与子问题 `procedure(m/2)` 所需最大内存之和。这个最大值为 $\\alpha \\ln m + M(m/2)$。\n3.  在 `procedure(m/2)` 完成并返回后，进行第二次递归调用 `procedure(m/4)`。同样，此阶段的最大内存使用量是 $\\alpha \\ln m + M(m/4)$。\n\n由于这两个阶段是顺序发生的，`procedure(m)` 执行期间的总最大内存使用量是每个阶段峰值使用量的最大值。这给了我们以下关于 $M(m)$ 的递推关系：\n$$M(m) = \\alpha \\ln m + \\max\\left( M(m/2), M(m/4) \\right) \\quad \\text{for } m  1$$\n基本情况由 $m \\leq 1$ 的条件给出，此时不分配内存。因此：\n$$M(m) = 0 \\quad \\text{for } m \\leq 1$$\n\n为了解这个递推关系，我们首先需要简化 $\\max$ 项。我们来证明对于 $m \\ge 1$，$M(m)$ 是 $m$ 的单调递增函数。\n基本情况：\n$M(1) = 0$。\n$M(2) = \\alpha \\ln 2 + \\max(M(1), M(1/2)) = \\alpha \\ln 2 + \\max(0, 0) = \\alpha \\ln 2$。\n由于 $\\alpha  0$ 且 $\\ln 2  0$，我们有 $M(2)  M(1)$。\n现在，我们进行归纳假设，对于所有满足 $2 \\le k  m$ 的 2 的幂 $k$，$M(k)  M(k/2)$。\n我们想证明 $M(m)  M(m/2)$。根据我们的归纳假设，由于 $m/2  m$，我们有 $M(m/2)  M((m/2)/2) = M(m/4)$。\n因此，$\\max(M(m/2), M(m/4)) = M(m/2)$。\n对于 $m  2$，递推关系变为：\n$$M(m) = \\alpha \\ln m + M(m/2)$$\n我们必须证明 $M(m)  M(m/2)$。这是显而易见的：\n$M(m) = M(m/2) + \\alpha \\ln m$。由于 $m  1$ 且 $\\alpha  0$，项 $\\alpha \\ln m$ 是严格为正的。因此，$M(m)  M(m/2)$。归纳假设成立。\n\n对于 $n  1$，简化的递推关系是：\n$$M(n) = \\alpha \\ln n + M(n/2)$$\n基本情况为 $M(1) = 0$。由于 $n$ 是 $2$ 的幂，设 $n=2^k$，其中 $k \\ge 0$ 是某个整数。注意 $k = \\log_2 n$。\n我们可以通过展开递推关系来求解：\n$$M(n) = M(2^k) = \\alpha \\ln(2^k) + M(2^{k-1})$$\n$$M(2^k) = \\alpha \\ln(2^k) + \\left(\\alpha \\ln(2^{k-1}) + M(2^{k-2})\\right)$$\n$$M(2^k) = \\alpha \\ln(2^k) + \\alpha \\ln(2^{k-1}) + \\alpha \\ln(2^{k-2}) + \\dots + M(2^1)$$\n最后一步是 $M(2^1) = M(2) = \\alpha \\ln 2 + M(1) = \\alpha \\ln 2$。\n所以，我们得到一个和式：\n$$M(n) = \\alpha \\left( \\ln(2^k) + \\ln(2^{k-1}) + \\dots + \\ln(2^1) \\right)$$\n$$M(n) = \\alpha \\sum_{i=1}^{k} \\ln(2^i)$$\n利用对数性质 $\\ln(x^y) = y \\ln x$：\n$$M(n) = \\alpha \\sum_{i=1}^{k} i \\ln 2 = \\alpha \\ln 2 \\sum_{i=1}^{k} i$$\n前 $k$ 个整数的和由公式 $\\sum_{i=1}^{k} i = \\frac{k(k+1)}{2}$ 给出。\n将此代入我们关于 $M(n)$ 的表达式中：\n$$M(n) = \\alpha \\ln 2 \\left( \\frac{k(k+1)}{2} \\right)$$\n现在，我们必须用 $n$ 和 $\\alpha$ 来表示结果。我们代入 $k = \\log_2 n = \\frac{\\ln n}{\\ln 2}$：\n$$M(n) = \\frac{\\alpha \\ln 2}{2} \\left( \\frac{\\ln n}{\\ln 2} \\right) \\left( \\frac{\\ln n}{\\ln 2} + 1 \\right)$$\n$$M(n) = \\frac{\\alpha \\ln n}{2} \\left( \\frac{\\ln n}{\\ln 2} + 1 \\right)$$\n为了得到更紧凑的形式，我们继续化简：\n$$M(n) = \\frac{\\alpha \\ln n}{2} \\left( \\frac{\\ln n + \\ln 2}{\\ln 2} \\right)$$\n使用对数性质 $\\ln a + \\ln b = \\ln(ab)$：\n$$M(n) = \\frac{\\alpha (\\ln n) (\\ln(2n))}{2 \\ln 2}$$\n这就是最大瞬时栈内存的精确闭式表达式。", "answer": "$$\\boxed{\\frac{\\alpha (\\ln n) (\\ln(2n))}{2 \\ln 2}}$$", "id": "3265136"}]}