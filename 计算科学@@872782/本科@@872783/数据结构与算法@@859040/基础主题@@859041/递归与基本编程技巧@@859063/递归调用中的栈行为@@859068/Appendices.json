{"hands_on_practices": [{"introduction": "递归的强大功能伴随着一个实际的代价：内存消耗。每一次函数调用都会在调用栈上创建一个新的栈帧，用于存储局部变量、返回地址等信息。这个练习将理论与物理现实联系起来，通过一个简化的场景，让你亲手计算在给定的内存限制下，一个递归函数在导致“栈溢出”之前所能达到的最大深度 [@problem_id:3274462]。", "problem": "考虑一个运行在操作系统上的单线程程序，该操作系统对每个线程强制执行固定的栈大小限制。一个递归函数在编译时没有进行尾调用优化，并且每次调用时，都会在其栈帧上分配一个大小为 $1 \\text{ kilobyte}$ 的局部对象。假设没有其他局部变量，并且任何每帧的固定开销（例如保存的返回地址和帧指针）相对于分配的对象来说可以忽略不计，因此每次调用的主要栈使用量就是这个 $1 \\text{ kilobyte}$ 的对象。该线程的栈大小限制为 $2 \\text{ megabytes}$，并且此外未被使用。\n\n根据递归中栈帧分配的基本原理以及二进制定义 $1 \\text{ kilobyte} = 2^{10} \\text{ bytes}$ 和 $1 \\text{ megabyte} = 2^{20} \\text{ bytes}$，确定在不导致栈溢出的情况下可以实现的最大递归深度（即同时活动的递归调用次数）。\n\n请以单个整数形式给出你的答案。不需要进行四舍五入。", "solution": "问题要求在给定栈使用特定限制的情况下，计算一个函数的最大递归深度。我们已知总可用栈大小和每次递归调用所消耗的栈空间量。解答此题需要计算总可用栈空间能容纳多少个这样的栈帧。\n\n设 $S_{\\text{total}}$ 为线程的总栈大小限制。\n设 $S_{\\text{frame}}$ 为每次递归函数调用所分配的栈空间（即一个栈帧的大小）。\n设 $D_{\\text{max}}$ 为最大递归深度。\n\n根据题目描述，我们已知：\n总栈大小为 $S_{\\text{total}} = 2 \\text{ megabytes}$。\n每次调用的栈使用量主要是一个大小为 $S_{\\text{frame}} = 1 \\text{ kilobyte}$ 的局部对象。题目说明要忽略任何其他开销。\n单位的二进制定义如下：\n$1 \\text{ kilobyte} = 2^{10} \\text{ bytes}$\n$1 \\text{ megabyte} = 2^{20} \\text{ bytes}$\n\n为了求出最大递归深度，我们必须首先将总栈大小和每帧的栈使用量用相同的单位表示，我们选择使用字节（bytes）作为单位。\n\n首先，我们将总栈大小 $S_{\\text{total}}$ 转换为字节：\n$$S_{\\text{total}} = 2 \\text{ megabytes} = 2 \\times (1 \\text{ megabyte}) = 2 \\times (2^{20} \\text{ bytes})$$\n使用指数性质 $a^m \\times a^n = a^{m+n}$，其中 $a=2$，$m=1$，$n=20$：\n$$S_{\\text{total}} = 2^1 \\times 2^{20} \\text{ bytes} = 2^{1+20} \\text{ bytes} = 2^{21} \\text{ bytes}$$\n\n接下来，我们将每帧的栈使用量 $S_{\\text{frame}}$ 转换为字节：\n$$S_{\\text{frame}} = 1 \\text{ kilobyte} = 1 \\times (1 \\text{ kilobyte}) = 1 \\times (2^{10} \\text{ bytes}) = 2^{10} \\text{ bytes}$$\n\n最大递归深度 $D_{\\text{max}}$ 是在超出总栈大小限制之前可以分配的栈帧总数。由于题目明确指出栈此外未被使用且每帧开销可忽略不计，我们可以通过将总可用栈大小除以单个栈帧的大小来计算 $D_{\\text{max}}$。\n$$D_{\\text{max}} = \\frac{S_{\\text{total}}}{S_{\\text{frame}}}$$\n\n代入以字节为单位的值：\n$$D_{\\text{max}} = \\frac{2^{21} \\text{ bytes}}{2^{10} \\text{ bytes}}$$\n\n使用指数性质 $\\frac{a^m}{a^n} = a^{m-n}$，其中 $a=2$，$m=21$，$n=10$：\n$$D_{\\text{max}} = 2^{21-10} = 2^{11}$$\n\n最后，我们计算 $2^{11}$ 的整数值：\n$$2^{11} = 2 \\times 2^{10} = 2 \\times 1024 = 2048$$\n\n因此，在不导致栈溢出的情况下可以实现的最大递归深度为 $2048$。这个数字代表了同时活动的递归调用的总数。", "answer": "$$\\boxed{2048}$$", "id": "3274462"}, {"introduction": "除了物理内存限制，递归的栈深度也是衡量算法空间复杂度的关键指标。一个算法占用的最大栈空间与其输入规模有何关系？这个练习将引导你分析一个常见的递归模式，推导出其最大栈深度与输入值的对数关系，从而揭示递归算法在空间效率上的特征 [@problem_id:3274586]。", "problem": "考虑一个作用于非负整数集合的确定性过程，该过程使用标准的后进先出（LIFO）调用栈。运行时系统不执行尾调用优化，因此每次过程调用都会将一个新的激活记录（AR）推入栈中，并且该AR会一直保留在栈上，直到其调用返回。定义一个作用于输入 $x \\in \\mathbb{Z}_{\\ge 0}$ 的函数 $f$ 如下：如果 $x = 0$，则 $f$ 立即返回，不进行任何进一步的调用；如果 $x > 0$，则 $f$ 进行一次对 $f(\\lfloor x/2 \\rfloor)$ 的递归调用，并在该调用返回后返回。最大栈深度定义为在单次调用 $f(x)$ 的执行期间，栈上同时存在的激活记录的最大数量，包括初始调用和任何递归调用，如果达到基例，也包括其基例帧。从整数除法、地板函数以及递归下的调用栈行为等核心定义出发，确定输入为 $x = 10^{9}$ 时的确切最大栈深度。给出你的最终答案，它应该是一个精确的整数。无需四舍五入。", "solution": "设 $D(x)$ 表示调用函数 $f(x)$ 时的最大栈深度，其中 $x \\in \\mathbb{Z}_{\\ge 0}$。问题定义了函数 $f$ 和调用栈的行为。\n\n根据问题描述：\n1.  调用 $f(x)$ 会将一个新的激活记录（AR）推入栈中。\n2.  如果 $x=0$，函数返回。在此调用期间，栈上的最大AR数量为 $1$（即 $f(0)$ 本身）。因此，最大深度的基例是 $D(0) = 1$。\n3.  如果 $x > 0$，函数 $f(x)$ 进行一次对 $f(\\lfloor x/2 \\rfloor)$ 的递归调用。在 $f(\\lfloor x/2 \\rfloor)$ 的调用执行期间，$f(x)$ 的AR会一直保留在栈上。执行 $f(x)$ 的最大栈深度将是 $f(x)$ 本身的 $1$ 个AR，加上在对 $f(\\lfloor x/2 \\rfloor)$ 的嵌套调用期间达到的最大深度。\n\n这为我们提供了最大栈深度 $D(x)$ 的以下递推关系：\n$$\nD(x) = \\begin{cases}\n1  \\text{ if } x = 0 \\\\\n1 + D(\\lfloor x/2 \\rfloor)  \\text{ if } x > 0\n\\end{cases}\n$$\n\n为了找到 $x = 10^9$ 时的最大栈深度，我们需要解这个递推式。我们可以对任意 $x > 0$ 展开此递推式。令 $x_0 = x$，并定义序列 $x_{i+1} = \\lfloor x_i/2 \\rfloor$（对于 $i \\ge 0$）。由于 $x$ 是一个正整数，该序列将严格递减，直到达到 $0$。设 $m$ 是使参数变为 $0$ 所需的步数，使得 $x_m = 0$ 且 $x_{m-1} > 0$。\n\n展开递推式：\n$$\n\\begin{aligned}\nD(x) = 1 + D(x_1) \\\\\n= 1 + (1 + D(x_2)) \\\\\n= 1 + 1 + (1 + D(x_3)) \\\\\n\\vdots \\\\\n= \\underbrace{1 + 1 + \\cdots + 1}_{m \\text{ times}} + D(x_m) \\\\\n= m + D(0)\n\\end{aligned}\n$$\n使用基例 $D(0) = 1$，我们得到：\n$$D(x) = m + 1$$\n这里，$m$ 是从 $x$ 变为 $0$ 所需应用变换 $n \\to \\lfloor n/2 \\rfloor$ 的次数。\n\n对于一个整数 $n$，操作 $n \\to \\lfloor n/2 \\rfloor$ 等价于其二进制表示的右移一位。将一个正整数 $x$ 减至 $0$ 所需的此类操作次数等于 $x$ 的二进制表示的位数。\n\n对于任何正整数 $x$，其二进制表示的位数（我们称之为 $k$）由 $k = \\lfloor \\log_2(x) \\rfloor + 1$ 给出。\n因此，我们有 $m = k = \\lfloor \\log_2(x) \\rfloor + 1$。\n\n将此代入我们对 $D(x)$ 的表达式中：\n$$D(x) = m + 1 = (\\lfloor \\log_2(x) \\rfloor + 1) + 1 = \\lfloor \\log_2(x) \\rfloor + 2$$\n此公式对任何整数 $x > 0$ 均有效。\n\n我们需要计算输入为 $x = 10^9$ 时的最大栈深度。使用推导出的公式：\n$$D(10^9) = \\lfloor \\log_2(10^9) \\rfloor + 2$$\n为了计算 $\\lfloor \\log_2(10^9) \\rfloor$，我们需要找到一个整数 $k$ 使得 $2^k \\le 10^9  2^{k+1}$。\n让我们分析 $2$ 的幂与 $10$ 的幂的关系。我们知道 $2^{10} = 1024$，它略大于 $10^3 = 1000$。\n\n从 $10^3 \\approx 2^{10}$ 出发，我们可以将两边都取 $3$ 次方：\n$(10^3)^3 \\approx (2^{10})^3$\n$10^9 \\approx 2^{30}$\n取以 $2$ 为底的对数，我们得到 $\\log_2(10^9) \\approx 30$。这意味着 $\\lfloor \\log_2(10^9) \\rfloor$ 可能为 29。\n\n现在我们必须检查 $\\log_2(10^9)$ 是否大于或等于 $29$。这等价于检查 $10^9 \\ge 2^{29}$ 是否成立。\n$$2^{29} = \\frac{2^{30}}{2} = \\frac{(2^{10})^3}{2} = \\frac{(1024)^3}{2}$$\n我们正在比较 $10^9$ 和 $\\frac{1024^3}{2}$。让我们重新整理这个比较：\n$$2 \\cdot 10^9 \\quad \\text{vs} \\quad 1024^3$$\n$$2 \\cdot (1000)^3 \\quad \\text{vs} \\quad (1024)^3$$\n两边同除以 $(1000)^3$：\n$$2 \\quad \\text{vs} \\quad \\left(\\frac{1024}{1000}\\right)^3$$\n$$2 \\quad \\text{vs} \\quad (1.024)^3$$\n让我们计算 $(1.024)^3$：\n$(1.024)^2 = 1.048576$\n$(1.024)^3 = 1.048576 \\times 1.024 = 1.073741824$\n现在比较变为：\n$$2 \\quad \\text{vs} \\quad 1.073741824$$\n显然，$2  1.073741824$。\n这意味着 $2 \\cdot 10^9  1024^3$，也就是说 $10^9  \\frac{1024^3}{2} = 2^{29}$。\n\n所以我们建立了不等式：\n$$2^{29}  10^9  2^{30}$$\n对所有部分取以 $2$ 为底的对数：\n$$\\log_2(2^{29})  \\log_2(10^9)  \\log_2(2^{30})$$\n$$29  \\log_2(10^9)  30$$\n因此，$\\log_2(10^9)$ 的地板函数值为 $29$：\n$$\\lfloor \\log_2(10^9) \\rfloor = 29$$\n最后，我们可以计算最大栈深度：\n$$D(10^9) = \\lfloor \\log_2(10^9) \\rfloor + 2 = 29 + 2 = 31$$\n输入 $x = 10^9$ 时的确切最大栈深度是 $31$。", "answer": "$$\\boxed{31}$$", "id": "3274586"}, {"introduction": "递归的“魔力”背后是调用栈的系统性工作。为了真正揭开这层面纱，最好的方法莫过于亲手模拟这个过程。本练习要求你使用一个显式的数据结构——栈，来实现一个典型的递归算法（树的后序遍历），从而将隐式的函数调用机制转化为显式的栈操作，加深对递归工作原理的理解 [@problem_id:3274439]。", "problem": "您必须仅使用一个标准的栈数据结构，实现一个二叉树的非递归后序遍历。遍历顺序必须是先访问左子树，然后是右子树，最后是节点本身。程序必须是自包含的，内部定义测试用例，并以下面指定的确切格式生成单行输出。\n\n推导和算法设计的基本依据必须从以下已确立的定义和事实开始：\n- 二叉树是节点的有限集合，其中每个节点最多有两个子节点，通常称为左子节点和右子节点。后序遍历只有在访问了节点的左右子树之后，才会访问该节点。\n- 栈是一种至少支持 push、pop、peek 和 is-empty 操作的数据结构，并表现出后进先出（LIFO）的行为。\n- 递归函数的程序执行会在调用栈上构建和展开栈帧；这是运行时用来管理函数调用的隐式栈。\n\n此问题的树表示法：\n- 每棵树定义为一个三元组列表 $\\left(v,\\ell,r\\right)$，每个节点一个三元组，其中 $v$ 是节点的整数值，$\\ell$ 是左子节点的索引， $r$ 是右子节点的索引。索引 $-1$ 表示空子节点。列表索引是节点标识符。对于所有非空树，根节点位于索引 $0$ 处。对于空树，列表为空，其后序遍历也为空列表。\n\n实现一个函数，给定这样一个列表，返回其后序遍历（一个整数列表），要求不使用递归，并且仅使用一个栈来模拟调用栈的行为。除了栈和常数数量的标量变量外，不允许使用其他辅助数据结构。\n\n您的程序需要使用的测试套件：\n- 案例 $1$ (平衡树): `[(1,1,2),(2,3,4),(3,5,6),(4,-1,-1),(5,-1,-1),(6,-1,-1),(7,-1,-1)]`\n- 案例 $2$ (单节点树): `[(42,-1,-1)]`\n- 案例 $3$ (左斜树): `[(10,1,-1),(20,2,-1),(30,3,-1),(40,-1,-1)]`\n- 案例 $4$ (右斜树): `[(11,-1,1),(22,-1,2),(33,-1,3),(44,-1,-1)]`\n- 案例 $5$ (混合缺失子节点): `[(5,1,2),(2,-1,3),(9,4,-1),(3,-1,-1),(7,-1,5),(8,-1,-1)]`\n- 案例 $6$ (空树): `[]`\n\n您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表（例如，`[[...],[...],...]`）。每个测试用例的结果必须是表示该树后序遍历的整数列表。\n\n最终输出纯粹是整数和整数列表。不涉及物理单位、角度单位或百分比。", "solution": "目标是使用单个栈，以迭代方式对二叉树执行后序遍历（左、右、根）。这模拟了递归遍历期间系统调用栈的行为。\n\n迭代后序遍历的主要挑战在于确定何时可以访问一个节点。一个节点 $N$ 只有在其左右子树的遍历都完成后才能被处理。使用单个栈时，当我们在探索完一个子树后返回到一个节点 $N$ 时，我们需要知道我们是从其左子节点返回的（这种情况下我们必须接着遍历右子树），还是从其右子节点返回的（这种情况下我们最终可以处理节点 $N$）。\n\n为了解决这种模糊性，我们使用一个栈和两个状态跟踪变量：\n1.  一个指针 `current_node_idx`，用于跟踪当前正在探索的节点。\n2.  一个指针 `last_visited_node_idx`，用于存储最近访问过（即添加到输出中）的节点的索引。\n\n算法流程如下：\n1.  一个主循环持续进行，只要还有待处理的节点（即 `current_node_idx` 不为 null（用索引 $-1$ 表示）或栈不为空），循环就继续。\n\n2.  **沿树向下遍历**：如果 `current_node_idx` 有效，意味着我们正在向下遍历。我们将 `current_node_idx` 推入栈中以标记我们的路径，然后前往其左子节点。重复此过程，在从当前位置沿最左路径向下时将节点推入栈中。\n\n3.  **向上回溯并遍历右子树**：当 `current_node_idx` 变为 null（$-1$）时，表示我们已经到达了路径的底部（一个 null 左子节点）。现在我们必须查看栈顶的节点，称其索引为 `peek_node_idx`，但先不弹出它。这是我们刚来自的 null 节点的父节点。我们必须决定下一步做什么：\n   - **情况 A：遍历右子树。** 我们检查 `peek_node_idx` 是否有右子节点。如果其右子节点存在且*不是* `last_visited_node_idx`，这意味着我们已经完成了 `peek_node_idx` 的左子树遍历，现在必须开始遍历其右子树。我们将 `current_node_idx` 设置为这个右子节点的索引，并继续循环。\n   - **情况 B：访问当前节点。** 如果 `peek_node_idx` 没有右子节点，或者其右子节点是 `last_visited_node_idx`，这确认了它的两个子树都已完全遍历。现在是“访问” `peek_node_idx` 处节点的正确时机。我们从栈中弹出其索引，将其值追加到我们的结果列表中，并更新 `last_visited_node_idx` 为 `peek_node_idx`。我们保持 `current_node_idx` 为 $-1$，以确保在下一次迭代中，我们再次从栈顶开始处理，从而有效地在树中向上移动。\n\n这个逻辑正确地模拟了递归调用的回溯过程。`last_visited_node_idx` 变量是关键，它提供了必要的上下文来区分是从左子节点返回还是从右子节点返回，从而确保每个节点都按正确的后序顺序被访问。对于空树，遍历结果是一个空列表，这是一个在开始时就处理的基准情况。\n\n该算法利用一个栈和常数数量的标量变量（`current_node_idx`、`last_visited_node_idx` 以及循环内的临时变量），满足了所有问题约束。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef post_order_iterative(tree_list: list[tuple[int, int, int]]) - list[int]:\n    \"\"\"\n    Performs a non-recursive post-order traversal of a binary tree.\n\n    The tree is represented as a list of (value, left_idx, right_idx) tuples.\n    The algorithm uses a single stack to emulate the call stack of a recursive\n    function, satisfying the problem constraints.\n\n    Args:\n        tree_list: A list representing the nodes of the tree. Each element is\n                   a tuple (value, left_child_index, right_child_index). An\n                   index of -1 indicates a null child.\n\n    Returns:\n        A list of integers representing the post-order traversal of the tree.\n    \"\"\"\n    # An empty tree has an empty traversal.\n    if not tree_list:\n        return []\n\n    result = []\n    stack = []\n    \n    # current_node_idx tracks the node to be processed.\n    # We start with the root, which is always at index 0 for a non-empty tree.\n    current_node_idx = 0\n    \n    # last_visited_node_idx tracks the most recently processed node. This is\n    # crucial for determining if we are returning from a left or right child.\n    last_visited_node_idx = -1\n\n    while current_node_idx != -1 or stack:\n        if current_node_idx != -1:\n            # We are descending. Go left as far as possible.\n            # Push the current node index onto the stack to remember the path.\n            stack.append(current_node_idx)\n            _, left_child_idx, _ = tree_list[current_node_idx]\n            current_node_idx = left_child_idx\n        else:\n            # We have hit a dead end (null left child). Look at the stack.\n            peek_node_idx = stack[-1]  # Peek at the top of the stack\n            \n            # Get the right child of the node on top of the stack.\n            _, _, right_child_idx = tree_list[peek_node_idx]\n\n            if right_child_idx != -1 and right_child_idx != last_visited_node_idx:\n                # If there's a right child and we haven't visited its subtree yet,\n                # switch to traversing the right subtree.\n                current_node_idx = right_child_idx\n            else:\n                # If there is no right child, or we have already visited the\n                # right subtree, then it's time to process this node.\n                \n                # Pop the node index from the stack.\n                popped_node_idx = stack.pop()\n                \n                # Get the node's value and add it to the result.\n                value, _, _ = tree_list[popped_node_idx]\n                result.append(value)\n                \n                # Mark this node as the last one visited.\n                last_visited_node_idx = popped_node_idx\n                \n                # Keep current_node_idx as -1 to continue processing from the stack,\n                # effectively moving up the tree.\n                current_node_idx = -1\n                \n    return result\n\ndef solve():\n    \"\"\"\n    Defines test cases, runs the traversal algorithm on each, and prints\n    the results in the specified format.\n    \"\"\"\n    # The test suite provided in the problem statement.\n    test_cases = [\n        # Case 1 (balanced tree)\n        [(1, 1, 2), (2, 3, 4), (3, 5, 6), (4, -1, -1), (5, -1, -1), (6, -1, -1), (7, -1, -1)],\n        # Case 2 (single node)\n        [(42, -1, -1)],\n        # Case 3 (left-skewed)\n        [(10, 1, -1), (20, 2, -1), (30, 3, -1), (40, -1, -1)],\n        # Case 4 (right-skewed)\n        [(11, -1, 1), (22, -1, 2), (33, -1, 3), (44, -1, -1)],\n        # Case 5 (mixed missing children)\n        [(5, 1, 2), (2, -1, 3), (9, 4, -1), (3, -1, -1), (7, -1, 5), (8, -1, -1)],\n        # Case 6 (empty tree)\n        []\n    ]\n\n    all_results = []\n    for tree in test_cases:\n        traversal_result = post_order_iterative(tree)\n        all_results.append(traversal_result)\n\n    # Convert each result list to its string representation and join them.\n    # The final output must match the format: [[...],[...],...]\n    output_str = f\"[{','.join(map(str, all_results))}]\"\n    print(output_str)\n\nsolve()\n```", "id": "3274439"}]}