{"hands_on_practices": [{"introduction": "写出递归函数只是第一步，理解其性能同样至关重要。本练习将带你分析一个非标准的递归关系 $T(n) = T(\\sqrt{n}) + \\ln n$，这是一个在评估复杂算法效率时经常遇到的挑战。通过这个练习，你将掌握一种强大的技术来精确量化递归调用的成本，从而深入理解算法的性能表现。[@problem_id:3264680]", "problem": "考虑一个递归过程，它作用于大小为 $n$ 的输入，在对大小为 $\\sqrt{n}$ 的输入进行单次递归调用之前，执行恰好 $\\ln n$ 次原语操作，并在输入大小达到 $2$ 时终止。设 $T(n)$ 表示该过程在输入大小为 $n$ 时执行的原语操作的总次数，包括所有递归调用。假设基本情况的成本为 $T(2)$，一个固定常数，并且 $\\ln$ 表示自然对数。为避免平方根递归带来的取整问题，假设输入大小被限制在集合 $\\{2^{2^{k}} : k \\in \\mathbb{N}, k \\geq 0\\}$ 中，这样每次递归调用都会恰好落在一个整数上，直到达到基本情况 $2$。\n\n从递归作为重复自我归约的基本定义和每次调用的精确操作计数出发，根据所述假设，推导出一个关于 $n$ 和 $T(2)$ 的 $T(n)$ 的封闭形式表达式。你的答案必须是一个精确的解析表达式，而不是渐近形式，并且应使用自然对数表示。", "solution": "问题陈述已经过分析，并被确定为有效。这是一个在算法分析领域中定义明确的问题，没有科学或逻辑上的不一致之处。所提供的假设，特别是对输入大小 $n$ 的域限制，确保了递归关系可以被精确无歧义地求解。\n\n该问题描述了一个递归过程。设 $T(n)$ 为输入大小为 $n$ 时的原语操作总数。该过程执行 $\\ln n$ 次操作，然后对大小为 $\\sqrt{n}$ 的输入进行递归调用。因此，总成本 $T(n)$ 是当前步骤的成本与递归子问题成本之和。这可以表示为以下递归关系：\n$$T(n) = \\ln(n) + T(\\sqrt{n})$$\n当输入大小达到 $2$ 时，递归终止，此时的成本是一个常数，记为 $T(2)$。这为递归关系提供了基本情况。\n\n为了找到 $T(n)$ 的封闭形式表达式，我们可以使用重复代入法，也称为展开法或迭代法。\n\n从 $T(n)$ 的递归关系开始：\n$$T(n) = \\ln(n) + T(n^{1/2})$$\n我们代入递归项 $T(n^{1/2})$ 的表达式：\n$$T(n^{1/2}) = \\ln(n^{1/2}) + T((n^{1/2})^{1/2}) = \\ln(n^{1/2}) + T(n^{1/4})$$\n将此代回 $T(n)$ 的方程中：\n$$T(n) = \\ln(n) + \\ln(n^{1/2}) + T(n^{1/4})$$\n使用对数性质 $\\ln(x^y) = y \\ln(x)$，这变为：\n$$T(n) = \\ln(n) + \\frac{1}{2}\\ln(n) + T(n^{1/4})$$\n我们可以重复这个代入过程。下一步得到：\n$$T(n) = \\ln(n) + \\frac{1}{2}\\ln(n) + \\ln(n^{1/4}) + T(n^{1/8})$$\n$$T(n) = \\ln(n) + \\frac{1}{2}\\ln(n) + \\frac{1}{4}\\ln(n) + T(n^{1/8})$$\n一个清晰的模式出现了。经过 $m$ 步展开后，$T(n)$ 的表达式为：\n$$T(n) = \\ln(n) \\left(1 + \\frac{1}{2} + \\frac{1}{4} + \\dots + \\frac{1}{2^{m-1}}\\right) + T(n^{1/2^m})$$\n$$T(n) = \\ln(n) \\sum_{i=0}^{m-1} \\left(\\frac{1}{2}\\right)^i + T(n^{1/2^m})$$\n当输入大小达到基本情况 $2$ 时，递归终止。我们需要找到发生这种情况所需的步数 $m$。\n$$n^{1/2^m} = 2$$\n为了解出 $m$，我们对两边取自然对数：\n$$\\ln(n^{1/2^m}) = \\ln(2)$$\n$$\\frac{1}{2^m} \\ln(n) = \\ln(2)$$\n对 $\\frac{1}{2^m}$ 进行整理得到：\n$$\\frac{1}{2^m} = \\frac{\\ln(2)}{\\ln(n)}$$\n展开式中的项 $T(n^{1/2^m})$ 变为 $T(2)$。\n\n$T(n)$ 表达式中的和是一个有限几何级数：\n$$S_m = \\sum_{i=0}^{m-1} \\left(\\frac{1}{2}\\right)^i = \\frac{1 - (1/2)^m}{1 - 1/2}$$\n$$S_m = \\frac{1 - (1/2)^m}{1/2} = 2\\left(1 - \\left(\\frac{1}{2}\\right)^m\\right)$$\n现在我们将这个和代回到 $T(n)$ 的方程中：\n$$T(n) = \\ln(n) \\cdot 2\\left(1 - \\left(\\frac{1}{2}\\right)^m\\right) + T(2)$$\n我们可以使用我们之前推导出的关系 $\\frac{1}{2^m} = \\frac{\\ln(2)}{\\ln(n)}$ 来替换项 $(1/2)^m$：\n$$T(n) = 2\\ln(n) \\left(1 - \\frac{\\ln(2)}{\\ln(n)}\\right) + T(2)$$\n将 $2\\ln(n)$ 项分配到括号内：\n$$T(n) = 2\\ln(n) \\cdot 1 - 2\\ln(n) \\cdot \\frac{\\ln(2)}{\\ln(n)} + T(2)$$\n$$T(n) = 2\\ln(n) - 2\\ln(2) + T(2)$$\n使用对数性质 $\\ln(a) - \\ln(b) = \\ln(a/b)$，这可以写得更紧凑：\n$$T(n) = 2(\\ln(n) - \\ln(2)) + T(2) = 2\\ln\\left(\\frac{n}{2}\\right) + T(2)$$\n为确保正确性，我们可以通过将其代回原始递归关系 $T(n) = \\ln(n) + T(\\sqrt{n})$ 来验证这个封闭形式解：\n\\begin{align*}\n\\text{右侧} = \\ln(n) + T(\\sqrt{n}) \\\\\n= \\ln(n) + \\left(2\\ln(\\sqrt{n}) - 2\\ln(2) + T(2)\\right) \\\\\n= \\ln(n) + \\left(2\\ln(n^{1/2}) - 2\\ln(2) + T(2)\\right) \\\\\n= \\ln(n) + \\left(2 \\cdot \\frac{1}{2}\\ln(n) - 2\\ln(2) + T(2)\\right) \\\\\n= \\ln(n) + \\ln(n) - 2\\ln(2) + T(2) \\\\\n= 2\\ln(n) - 2\\ln(2) + T(2)\n\\end{align*}\n这个结果与我们推导出的 $T(n)$ 表达式相匹配，证实了解是正确的。基本情况的检验 $T(2) = 2\\ln(2) - 2\\ln(2) + T(2) = T(2)$ 也成立。假设 $n$ 在集合 $\\{2^{2^{k}} : k \\in \\mathbb{N}, k \\geq 0\\}$ 中，这保证了在取平方根时，$T$ 的参数始终是 $2$ 的整数次幂，直到达到 $2$。例如，如果 $n=2^{2^k}$，那么 $\\sqrt{n}=2^{2^{k-1}}$，依此类推，经过 $k$ 步后达到 $2^{2^0}=2$。这验证了我们推导结构的正确性。\n\n$T(n)$ 的最终封闭形式表达式是关于 $n$ 和常数 $T(2)$ 的函数。", "answer": "$$\\boxed{2\\ln(n) - 2\\ln(2) + T(2)}$$", "id": "3264680"}, {"introduction": "现在，让我们从理论转向一个具体的可视化应用。这个问题要求我们使用分治策略在一个二维矩阵中寻找最大的空白区域，其核心挑战在于如何有效地分割问题空间。这个问题不仅能锻炼你将递归思想应用于几何问题的能力，还能让你体会到记忆化（memoization）在处理重叠子问题时的巨大威力。[@problem_id:3264651]", "problem": "设计并实现一个递归的分治算法，用于计算二元矩阵中最大轴对齐空矩形的面积。该矩阵有 $n$ 行和 $m$ 列，每个条目要么是 $0$（空）要么是 $1$（障碍物）。一个轴对齐矩形由一个连续的行区间 $[r_0,r_1]$ 和一个连续的列区间 $[c_0,c_1]$ 定义，其中 $0 \\le r_0 \\le r_1  n$ 且 $0 \\le c_0 \\le c_1  m$。如果一个矩形内的每个单元格都包含 $0$，则该矩形是空的。矩形的面积为 $(r_1 - r_0 + 1) \\cdot (c_1 - c_0 + 1)$。\n\n你必须从以下基本原则推導出你的方法：\n- 递归的定义：一个定义在某个域上的函数，它将一个问题实例归约为严格更小的实例，并在基准情形下停止。\n- 分治的定义：一种将问题划分为覆盖所有解的子问题，递归地解决每个子问题，并合并它们结果的方法。\n\n需要实现的算法规范：\n- 给定一个由行边界 $[r_0,r_1]$ 和列边界 $[c_0,c_1]$ 定义的子矩阵，如果它不包含障碍物 ($1$)，则最大空矩形就是整个子矩阵。如果它在位置 $(i,j)$ 至少包含一个障碍物，那么该子矩阵内的任何空矩形都完全位于沿该障碍物的行和列划分得到的四个条形子矩阵中的至少一个之内：\n  - 顶部条形区域：行 $[r_0,i-1]$，列 $[c_0,c_1]$。\n  - 底部条形区域：行 $[i+1,r_1]$，列 $[c_0,c_1]$。\n  - 左侧条形区域：行 $[r_0,r_1]$，列 $[c_0,j-1]$。\n  - 右侧条形区域：行 $[r_0,r_1]$，列 $[j+1,c_1]$。\n- 递归地计算每个条形区域中的最大空矩形面积，并取最大值。递归必须在 $r_0  r_1$ 或 $c_0  c_1$ 的退化子矩阵上停止，此时面积为 $0$。\n\n程序要求：\n- 使用递归和记忆化实现上述算法，记忆化以子矩阵边界 $(r_0,r_1,c_0,c_1)$ 为键，以避免重复工作。\n- 使用前缀和结构在 $O(1)$ 时间内测试给定子矩阵是否包含障碍物，而不透露任何用于最终结果的快捷公式。\n\n测试套件：\n在以下矩阵集上评估你的程序，每个矩阵都明确地以整数 $0$（空）和 $1$（障碍物）的列表的列表形式给出。对于每个矩阵，预期的输出是一个等于最大空矩形面积的整数。\n\n- 测试用例 1 (一般混合情况，$5 \\times 7$):\n  $\n  \\begin{array}{ccccccc}\n  0  0  1  0  0  0  0 \\\\\n  0  0  1  0  1  0  0 \\\\\n  0  0  0  0  1  0  0 \\\\\n  1  1  0  0  0  0  0 \\\\\n  0  0  0  0  0  1  0 \\\\\n  \\end{array}\n  $\n\n- 测试用例 2 (全空，$4 \\times 4$):\n  $\n  \\begin{array}{cccc}\n  0  0  0  0 \\\\\n  0  0  0  0 \\\\\n  0  0  0  0 \\\\\n  0  0  0  0 \\\\\n  \\end{array}\n  $\n\n- 测试用例 3 (全是障碍物，$3 \\times 5$):\n  $\n  \\begin{array}{ccccc}\n  1  1  1  1  1 \\\\\n  1  1  1  1  1 \\\\\n  1  1  1  1  1 \\\\\n  \\end{array}\n  $\n\n- 测试用例 4 (单行，$1 \\times 8$):\n  $\n  \\begin{array}{cccccccc}\n  0  1  0  0  0  1  0  0\n  \\end{array}\n  $\n\n- 测试用例 5 (单列，$7 \\times 1$):\n  $\n  \\begin{array}{c}\n  1 \\\\\n  0 \\\\\n  0 \\\\\n  1 \\\\\n  0 \\\\\n  0 \\\\\n  0 \\\\\n  \\end{array}\n  $\n\n- 测试用例 6 (环状障碍物，$6 \\times 6$):\n  $\n  \\begin{array}{cccccc}\n  0  0  0  0  0  0 \\\\\n  0  1  1  1  1  0 \\\\\n  0  1  0  0  1  0 \\\\\n  0  1  0  0  1  0 \\\\\n  0  1  1  1  1  0 \\\\\n  0  0  0  0  0  0 \\\\\n  \\end{array}\n  $\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$[result_1,result_2,\\dots,result_k]$），顺序与上述测试用例相同。", "solution": "所提供的问题是有效的。这是一个定义明确的算法任务，基于计算机科学的既定原则，特别是递归、分治和动态规划（记忆化）。问题陈述是自洽的、逻辑一致的，并且是客观呈现的。\n\n问题的核心是设计一个递归算法，以找到二元矩阵中最大的轴对齐空矩形。解决方案将遵循指定的分治方法。\n\n**1. 基本原则**\n\n如要求所述，该解决方案建立在递归和分治的原则之上。\n\n- **递归**：在大小为 $n \\times m$ 的矩阵中寻找最大空矩形的问题，被归约为在严格更小的子矩阵中寻找最大空矩形。该过程在基准情形下终止：子矩阵要么没有障碍物，要么是退化的（例如，宽度或高度为非正数）。\n- **分治**：“分割”步骤由障碍物的存在决定。问题陈述提供了关键的洞见：如果一个子矩阵在位置 $(i, j)$ 包含障碍物，那么该子矩阵内的任何有效空矩形都不能包含 $(i, j)$。因此，这样的矩形必须完全位于四个区域之一：第 $i$ 行之上、第 $i$ 行之下、第 $j$ 列之左或第 $j$ 列之右。这将搜索空间划分为四个新的子问题。“合并”步骤只是取这些子问题中发现的最大面积。\n\n**2. 算法设计与数据结构**\n\n为了高效地实现这一策略，我们采用两种关键数据结构：用于快速查询的前缀和矩阵，以及用于避免冗余计算的记忆化缓存。\n\n- **前缀和矩阵 ($S$)**：为了满足在 $O(1)$ 时间内检查子矩阵中障碍物的要求，我们预处理输入矩阵 $M$。我们构建一个大小为 $(n+1) \\times (m+1)$ 的前缀和矩阵 $S$，其中 $S[r+1][c+1]$ 存储从 $(0, 0)$ 到 $(r, c)$ 的矩形内障碍物的总数。其构建公式为：\n    $$ S[r+1][c+1] = M[r][c] + S[r][c+1] + S[r+1][c] - S[r][c] $$\n    有了这个结构，任何由行 $[r_0, r_1]$ 和列 $[c_0, c_1]$ 定义的子矩阵中的障碍物数量可以在 $O(1)$ 时间内计算出来：\n    $$ \\text{count} = S[r_1+1][c_1+1] - S[r_0][c_1+1] - S[r_1+1][c_0] + S[r_0][c_0] $$\n    当且仅当此计数为 $0$ 时，子矩阵为空。\n\n- **记忆化缓存 ($\\text{memo}$)**：递归方法会产生重叠子问题。例如，行 $[0, 5]$ 和列 $[0, 5]$ 的子矩阵可能被位于 $(3, 3)$ 的障碍物分割，从而生成包括行 $[0, 5]$ 和列 $[0, 2]$ 的子问题。这同一个子问题可能由父问题中的不同分割方式生成。为防止重复计算，我们使用一个哈希映射（在 Python 中是字典），我们称之为 $\\text{memo}$，来缓存结果。键是子矩阵边界的元组 $(r_0, r_1, c_0, c_1)$，值是计算出的最大面积。\n\n**3. 递归函数 $F(r_0, r_1, c_0, c_1)$**\n\n该算法被封装在一个递归函数中，我们将其表示为 $F$，它对子矩阵边界进行操作。\n\n- **步骤 1：基准情形与记忆化查找**\n    1. 如果 $r_0  r_1$ 或 $c_0  c_1$，子矩阵是退化的，不能包含任何矩形。面积为 $0$。\n    2. 检查子问题 $(r_0, r_1, c_0, c_1)$ 的结果是否存在于 $\\text{memo}$ 缓存中。如果存在，立即返回缓存的值。\n\n- **步骤 2：检查障碍物**\n    1. 使用前缀和矩阵 $S$ 来确定从 $(r_0, c_0)$ 到 $(r_1, c_1)$ 的子矩阵是否包含任何障碍物。\n    2. 如果不包含障碍物，最大空矩形就是子矩阵本身。面积为 $(r_1 - r_0 + 1) \\cdot (c_1 - c_0 + 1)$。将此结果存储在 $\\text{memo}$ 中并返回。这是第二个基准情形。\n\n- **步骤 3：递归分解**\n    1. 如果存在障碍物，我们必须分割问题。根据问题规范，我们需要找到一个障碍物作为枢轴点。一种确定性的方法是扫描子矩阵（例如，以行主序）并选择找到的第一个位于位置 $(i, j)$ 的障碍物。\n    2. 对由障碍物 $(i, j)$ 创建的四个条形区域进行四次递归调用：\n        - 顶部条形区域：$F(r_0, i-1, c_0, c_1)$\n        - 底部条形区域：$F(i+1, r_1, c_0, c_1)$\n        - 左侧条形区域：$F(r_0, r_1, c_0, j-1)$\n        - 右侧条形区域：$F(r_0, r_1, j+1, c_1)$\n    3. 当前子问题的最大面积是这四次递归调用结果中的最大值。\n    4. 将此最大面积存储在 $(r_0, r_1, c_0, c_1)$ 的 $\\text{memo}$ 缓存中并返回它。\n\n解决整个问题的初始调用将是 $F(0, n-1, 0, m-1)$。这种系统的、带记忆化的递归保证了每个可能的空矩形都被考虑到，并且最大面积被正确识别。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Drives the computation for all test cases and prints the final result.\n    \"\"\"\n    test_cases = [\n        # Test case 1 (general mixed case, 5x7)\n        [\n            [0, 0, 1, 0, 0, 0, 0],\n            [0, 0, 1, 0, 1, 0, 0],\n            [0, 0, 0, 0, 1, 0, 0],\n            [1, 1, 0, 0, 0, 0, 0],\n            [0, 0, 0, 0, 0, 1, 0],\n        ],\n        # Test case 2 (all empty, 4x4)\n        [\n            [0, 0, 0, 0],\n            [0, 0, 0, 0],\n            [0, 0, 0, 0],\n            [0, 0, 0, 0],\n        ],\n        # Test case 3 (all obstacles, 3x5)\n        [\n            [1, 1, 1, 1, 1],\n            [1, 1, 1, 1, 1],\n            [1, 1, 1, 1, 1],\n        ],\n        # Test case 4 (single row, 1x8)\n        [\n            [0, 1, 0, 0, 0, 1, 0, 0]\n        ],\n        # Test case 5 (single column, 7x1)\n        [\n            [1],\n            [0],\n            [0],\n            [1],\n            [0],\n            [0],\n            [0],\n        ],\n        # Test case 6 (ring-like obstacles, 6x6)\n        [\n            [0, 0, 0, 0, 0, 0],\n            [0, 1, 1, 1, 1, 0],\n            [0, 1, 0, 0, 1, 0],\n            [0, 1, 0, 0, 1, 0],\n            [0, 1, 1, 1, 1, 0],\n            [0, 0, 0, 0, 0, 0],\n        ],\n    ]\n\n    class LargestEmptyRectangleSolver:\n        \"\"\"\n        Encapsulates the logic for solving the problem for a single matrix.\n        \"\"\"\n        def __init__(self, matrix_data):\n            if not matrix_data or not matrix_data[0]:\n                self.matrix = np.array([[]])\n            else:\n                self.matrix = np.array(matrix_data, dtype=int)\n            \n            self.n, self.m = self.matrix.shape\n            self.memo = {}\n            if self.n > 0 and self.m > 0:\n                self.prefix_sum = self._build_prefix_sum()\n\n        def _build_prefix_sum(self):\n            \"\"\"Builds a 2D prefix sum array for O(1) obstacle queries.\"\"\"\n            s = np.zeros((self.n + 1, self.m + 1), dtype=int)\n            for r in range(self.n):\n                for c in range(self.m):\n                    s[r + 1, c + 1] = self.matrix[r, c] + s[r, c + 1] + s[r + 1, c] - s[r, c]\n            return s\n\n        def _has_obstacle(self, r0, r1, c0, c1):\n            \"\"\"Checks if a submatrix contains any obstacles in O(1) time.\"\"\"\n            count = self.prefix_sum[r1 + 1, c1 + 1] - self.prefix_sum[r0, c1 + 1] - \\\n                    self.prefix_sum[r1 + 1, c0] + self.prefix_sum[r0, c0]\n            return count > 0\n\n        def _find_max_area(self, r0, r1, c0, c1):\n            \"\"\"\n            Recursively computes the area of the largest empty rectangle\n            in the submatrix defined by (r0, r1, c0, c1).\n            \"\"\"\n            # Base case: degenerate submatrix\n            if r0 > r1 or c0 > c1:\n                return 0\n\n            bounds = (r0, r1, c0, c1)\n            # Memoization check\n            if bounds in self.memo:\n                return self.memo[bounds]\n\n            # Base case: submatrix contains no obstacles\n            if not self._has_obstacle(r0, r1, c0, c1):\n                area = (r1 - r0 + 1) * (c1 - c0 + 1)\n                self.memo[bounds] = area\n                return area\n\n            # Recursive step: find an obstacle and divide the problem\n            # Find the first obstacle to use as a pivot\n            pivot_i, pivot_j = -1, -1\n            for i in range(r0, r1 + 1):\n                for j in range(c0, c1 + 1):\n                    if self.matrix[i, j] == 1:\n                        pivot_i, pivot_j = i, j\n                        break\n                if pivot_i != -1:\n                    break\n            \n            # Recurse on the four sub-strips\n            area_top = self._find_max_area(r0, pivot_i - 1, c0, c1)\n            area_bottom = self._find_max_area(pivot_i + 1, r1, c0, c1)\n            area_left = self._find_max_area(r0, r1, c0, pivot_j - 1)\n            area_right = self._find_max_area(r0, r1, pivot_j + 1, c1)\n\n            max_area = max(area_top, area_bottom, area_left, area_right)\n            self.memo[bounds] = max_area\n            return max_area\n\n        def run(self):\n            \"\"\"Initializes the recursive computation.\"\"\"\n            if self.n == 0 or self.m == 0:\n                return 0\n            return self._find_max_area(0, self.n - 1, 0, self.m - 1)\n\n    results = []\n    for case in test_cases:\n        solver = LargestEmptyRectangleSolver(case)\n        result = solver.run()\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3264651"}]}