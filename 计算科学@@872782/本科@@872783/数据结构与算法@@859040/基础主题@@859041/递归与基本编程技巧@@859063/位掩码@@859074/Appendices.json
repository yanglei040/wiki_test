{"hands_on_practices": [{"introduction": "本练习从一个基本概念入手：位掩码和位位置集合之间的一一对应关系 [@problem_id:3217117]。通过探索如何将一个集合划分为两个不相交的子集，且这两个子集的并集等于原集合，你将加深对集合运算（如并集和交集）如何直接转换为位运算（按位“或”与按位“与”）的理解。这个练习为更复杂的位掩码操作奠定了坚实的基础。", "problem": "给定一个非负整数掩码 $M$。将一个掩码解释为其标准二进制表示中值为1的位的位置集合。这样，$M$的子掩码就是任意一个非负整数，其值为1的位的集合是$M$对应集合的子集。两个掩码 $A$ 和 $B$ 构成一个有序对 $(A,B)$。请仅使用集合运算和位掩码操作的基本定义，确定 $M$ 的子掩码构成的有序对 $(A,B)$ 的确切数量，这些有序对需要满足：$A$ 和 $B$ 中值为1的位的位置集合满足 $A \\cap B = \\emptyset$ 和 $A \\cup B = M$。为使问题具体，设 $M$ 是十六进制表示为 $\\mathrm{1F3A7C}$ 的整数。请给出精确整数形式的最终答案，无需进行舍入。", "solution": "问题要求计算满足以下条件的非负整数有序对 $(A,B)$ 的数量：$A$ 和 $B$ 是给定掩码 $M$ 的子掩码，并且满足条件 $A \\cap B = \\emptyset$ 和 $A \\cup B = M$。问题指出，这些掩码应被解释为其值为1的位的位置集合。\n\n设 $S_M$ 是 $M$ 的二进制表示中为1的位的位置集合。条件“$A$ 和 $B$ 是 $M$ 的子掩码”等价于说它们对应的为1的位的位置集合 $S_A$ 和 $S_B$ 是 $S_M$ 的子集。即 $S_A \\subseteq S_M$ 且 $S_B \\subseteq S_M$。\n\n问题给出的条件是：\n1.  $A \\cap B = \\emptyset$：这意味着 $A$ 中为1的位的位置集合与 $B$ 中为1的位的位置集合不相交。用集合符号表示为 $S_A \\cap S_B = \\emptyset$。就整数本身的位运算而言，这等价于 $(A \\text{  } B) = 0$。\n2.  $A \\cup B = M$：这意味着 $A$ 和 $B$ 中为1的位的位置集合的并集等于 $M$ 中为1的位的位置集合。用集合符号表示为 $S_A \\cup S_B = S_M$。就位运算而言，这等价于 $(A \\text{ | } B) = M$。\n\n这两个集合论条件，$S_A \\cup S_B = S_M$ 和 $S_A \\cap S_B = \\emptyset$，共同意味着集合 $S_A$ 和 $S_B$ 构成了集合 $S_M$ 的一个划分。我们的任务是计算这种有序集合对 $(S_A, S_B)$ 的数量。\n\n让我们逐位分析这些约束。考虑任意整数 $i \\ge 0$ 的第 $i$ 个比特位。\n\n情况1：$M$ 的第 $i$ 位是 $0$。\n由于 $A$ 和 $B$ 必须是 $M$ 的子掩码，它们的第 $i$ 位也必须是 $0$。这是因为 $S_A \\subseteq S_M$ 且 $S_B \\subseteq S_M$，所以如果 $i \\notin S_M$，则必然有 $i \\notin S_A$ 且 $i \\notin S_B$。对于这个比特位，条件是满足的：$(A \\text{ OR } B)$ 的第 $i$ 位是 $0 \\text{ OR } 0 = 0$，与 $M$ 匹配；$(A \\text{ AND } B)$ 的第 $i$ 位是 $0 \\text{ AND } 0 = 0$，与空交集一致。对于任何这样的比特位， $A$ 和 $B$ 中对应的比特只有一个可能的选择（它们都必须是 $0$）。\n\n情况2：$M$ 的第 $i$ 位是 $1$。\n这意味着 $i \\in S_M$。\n条件 $S_A \\cup S_B = S_M$ 意味着对于这个位置 $i$，我们必须有 $i \\in S_A$ 或 $i \\in S_B$。\n条件 $S_A \\cap S_B = \\emptyset$ 意味着 $i$ 不能同时在 $S_A$ 和 $S_B$ 中。\n结合这两个要求，对于 $M$ 中为$1$的每个比特位 $i$，$A$ 或 $B$ 中必须有且仅有一个在该位置为$1$。这为每个这样的比特位提供了两种可能性：\na) $A$ 的第 $i$ 位是 $1$，而 $B$ 的第 $i$ 位是 $0$。\nb) $A$ 的第 $i$ 位是 $0$，而 $B$ 的第 $i$ 位是 $1$。\n\n由于每个比特位的选择独立于所有其他比特位的选择，有序对 $(A,B)$ 的总数可以通过将每个比特位的选择数相乘得到。\n设 $N$ 是 $M$ 的二进制表示中为$1$的位的数量。这也被称为 $M$ 的置位位数（population count）或汉明权重（Hamming weight）。对于 $M$ 中为$1$的 $N$ 个比特位中的每一个，有 $2$ 种可能的方式将该位分配给 $A$ 或 $B$。对于所有其他 $M$ 中为$0$的比特位，只有 $1$ 种选择（$A$ 和 $B$ 都必须为 $0$）。\n\n因此，有序对 $(A,B)$ 的总数是 $2^N$。\n\n问题提供了一个十六进制的具体值 $M = \\mathrm{1F3A7C}_{16}$。我们必须找出其二进制表示中为$1$的位的数量 $N$。我们将每个十六进制数字转换为其等效的4位二进制数：\n- $1_{16} = 0001_2$ (包含 $1$ 个 1)\n- $F_{16} = 1111_2$ (包含 $4$ 个 1)\n- $3_{16} = 0011_2$ (包含 $2$ 个 1)\n- $A_{16} = 1010_2$ (包含 $2$ 个 1)\n- $7_{16} = 0111_2$ (包含 $3$ 个 1)\n- $C_{16} = 1100_2$ (包含 $2$ 个 1)\n\n$M$ 的二进制表示是 $0001\\ 1111\\ 0011\\ 1010\\ 0111\\ 1100_2$。\n为$1$的位的总数 $N$ 是每个十六进制数字中为$1$的位的数量之和：\n$N = 1 + 4 + 2 + 2 + 3 + 2 = 14$。\n\n有序对 $(A,B)$ 的总数是 $2^N = 2^{14}$。\n我们计算这个值：\n$2^{10} = 1024$\n$2^{14} = 2^4 \\times 2^{10} = 16 \\times 1024$\n$16 \\times 1024 = 16 \\times (1000 + 24) = 16000 + 16 \\times 24 = 16000 + 384 = 16384$。\n\n因此，恰好有 $16384$ 个这样的有序对 $(A,B)$。", "answer": "$$\\boxed{16384}$$", "id": "3217117"}, {"introduction": "许多问题都可以建模为在状态空间图中寻找路径。本练习将展示位掩码如何紧凑地表示状态，将一个看似复杂的转换问题转化为一个经典的最短路径搜索问题 [@problem_id:3217223]。你将使用广度优先搜索（BFS）算法来寻找达到目标状态所需的最少操作次数（通过异或运算 $\\oplus$ 进行切换），这是一种适用于解决谜题、游戏和优化问题的强大技术。", "problem": "给定一个初始位掩码 $m$，一个目标位掩码 $g$，以及一个有限的翻转掩码列表 $t_i$，$i \\in \\{1,2,\\dots,k\\}$。一次翻转操作会将按位异或（XOR）应用于当前掩码：如果当前掩码是 $x$，应用翻转掩码 $t_i$ 会将其转换为 $x \\oplus t_i$。所有掩码都限制在固定的位宽 $B$ 内，这意味着只考虑最低的 $B$ 位，并且所有操作都在集合 $\\{0,1,\\dots,2^B-1\\}$ 内进行。\n\n构建一个程序，确定将 $m$ 转换为 $g$ 所需的最少翻转操作次数，如果 $g$ 在任何翻转序列下都无法从 $m$ 到达，则返回 $-1$。您的程序必须生成单行输出，该输出是一个用方括号括起来的逗号分隔列表，汇总了给定测试套件的结果。\n\n推理必须从基本定义和事实出发：\n- 按位异或（XOR），写作 $\\oplus$，是按位定义的，使用模2加法且不带进位。对于任何位宽为 $B$ 的位掩码 $a$ 和 $b$，$a \\oplus b$ 是一个掩码，其在位位置 $j \\in \\{0,1,\\dots,B-1\\}$ 上的位为 $(a_j + b_j) \\bmod 2$。\n- XOR 遵循代数性质：$a \\oplus a = 0$，$a \\oplus 0 = a$，交换律 $a \\oplus b = b \\oplus a$，以及结合律 $(a \\oplus b) \\oplus c = a \\oplus (b \\oplus c)$。在 $\\oplus$ 运算下，每个元素都是自身的逆元。\n- 在无权图上进行的广度优先搜索（BFS）按路径长度的非递减顺序探索顶点，因此能找到从源点到任何可达顶点的最短路径。\n\n将可达的掩码建模为一个无权有向图的顶点，其顶点集为 $V = \\{0,1,\\dots,2^B-1\\}$。当且仅当存在某个翻转掩码 $t_i$ 使得 $y = x \\oplus t_i$ 时，从 $x$ 到 $y$ 存在一条边。从顶点 $m$ 开始，问题要求计算该图中到顶点 $g$ 的最短路径长度。如果 $g$ 无法从 $m$ 到达，则答案为 $-1$。\n\n输入协议由下面的测试套件固定；您的程序不得读取任何外部输入。最终输出格式必须是单行，包含一个整数列表，表示每个测试用例的最少翻转次数，格式严格为 $[r_1,r_2,\\dots,r_n]$，不含空格。\n\n测试套件（每个用例是一个四元组 $(B,m,g,\\{t_i\\})$）：\n- 用例 $1$：$B = 8$，$m = 26$，$g = 229$，$\\{t_i\\} = [160,39,255,91]$。\n- 用例 $2$：$B = 8$，$m = 123$，$g = 123$，$\\{t_i\\} = [5,7,200]$。\n- 用例 $3$：$B = 8$，$m = 0$，$g = 4$，$\\{t_i\\} = [1,2]$。\n- 用例 $4$：$B = 8$，$m = 42$，$g = 40$，$\\{t_i\\} = [0,5,5,7]$。\n- 用例 $5$：$B = 4$，$m = 0$，$g = 11$，$\\{t_i\\} = [1,2,4,8]$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表，例如 $[r_1,r_2,r_3,r_4,r_5]$。预期输出为整数；对于不可达的目标，输出 $-1$。", "solution": "问题要求计算将初始位掩码 $m$ 转换为目标位掩码 $g$ 所需的最少翻转操作次数。这是一个经典的无权图最短路径问题。其解法可以通过首先将问题形式化为图论模型，然后应用合适的搜索算法来系统地推导出来。\n\n首先，我们来定义状态空间的结构。所有固定位宽 $B$ 的可能位掩码的集合构成了图的顶点集 $V$，其中 $V = \\{0, 1, \\dots, 2^B - 1\\}$。一次操作包括从给定列表 $\\{t_1, t_2, \\dots, t_k\\}$ 中应用一个翻转掩码 $t_i$。翻转的效果由按位异或（XOR）操作定义，记为 $\\oplus$。如果当前掩码是 $x$，应用翻转掩码 $t_i$ 会得到新掩码 $x' = x \\oplus t_i$。\n\n这种转换定义了我们图的边。如果存在一个翻转掩码 $t_i$ 使得 $v = u \\oplus t_i$，那么两个顶点（掩码）$u$ 和 $v$ 之间就存在一条边。XOR 操作是其自身的逆运算，即 $(u \\oplus t_i) \\oplus t_i = u \\oplus (t_i \\oplus t_i) = u \\oplus 0 = u$。这意味着如果存在一条从 $u$ 到 $v$ 的边，那么也存在一条从 $v$ 到 $u$ 的边。因此，该图是无向的。每条边代表一次翻转操作，所以该图是无权的。因此，问题等价于寻找从起始顶点 $m$ 到目标顶点 $g$ 的最短路径长度。\n\n在无权图中寻找最短路径最适合的算法是广度优先搜索（BFS）。BFS 逐层系统地探索图，保证它能以最少的边数发现到任何可达顶点的路径。\n\n另一个视角揭示了其底层的代数结构。一个包含 $L$ 次翻转操作的序列 $t_{i_1}, t_{i_2}, \\dots, t_{i_L}$ 将 $m$ 转换为 $g$ 的过程如下：\n$$ g = m \\oplus t_{i_1} \\oplus t_{i_2} \\oplus \\dots \\oplus t_{i_L} $$\n根据 XOR 的结合律和交换律，我们可以重排这个表达式。将等式两边与 $m$ 进行 XOR 运算可得：\n$$ m \\oplus g = (m \\oplus m) \\oplus (t_{i_1} \\oplus t_{i_2} \\oplus \\dots \\oplus t_{i_L}) $$\n$$ m \\oplus g = 0 \\oplus (t_{i_1} \\oplus t_{i_2} \\oplus \\dots \\oplus t_{i_L}) $$\n令 $D = m \\oplus g$ 为“差异掩码”。问题等价于从集合 $\\{t_i\\}$ 中找出能异或得到 $D$ 的最少数量的翻转掩码。这将问题重构为寻找从零掩码 $0$ 到掩码 $D$ 的最短路径。这是一个在二元域 $\\mathbb{F}_2$ 上的向量空间问题。虽然这个观点在概念上很优雅，但无论从 $m$ 搜索到 $g$ 还是从 $0$ 搜索到 $D$，BFS 算法仍然是实用的解决方法。我们将坚持从 $m$ 搜索到 $g$ 的直接表述。\n\nBFS 算法的流程如下：\n$1.$ 初始化一个队列来管理待访问的顶点。队列将存储形如 $(mask, distance)$ 的元组。将起始状态 $(m, 0)$ 添加到队列中。\n$2.$ 初始化一个集合或布尔数组 `visited`，用于记录已经入队的掩码。这对于防止循环和冗余计算至关重要。将 $m$ 添加到 `visited` 集合中。\n$3.$ 如果 $m=g$，则距离为 $0$。这个平凡情况由初始状态处理。\n$4.$ 当队列不为空时循环：\n    a. 出队当前状态 `(current_mask, current_dist)`。\n    b. 对于所提供列表中的每个唯一的翻转掩码 $t_j$：\n        i. 计算 `next_mask` 为 `current_mask` $\\oplus$ $t_j$。\n        ii. 如果 `next_mask` 是目标 $g$，则已找到最短路径。其长度为 `current_dist` $+ 1$。算法可以终止并返回此值。\n        iii. 如果 `next_mask` 尚未被访问，则将其添加到 `visited` 集合中，并以新的距离入队：`(next_mask, current_dist + 1)`。\n$5.$ 如果队列变空且尚未找到目标 $g$，则意味着 $g$ 与 $m$ 不在图的同一个连通分量中。因此，$g$ 是不可达的。在这种情况下，函数应返回 $-1$。\n\n输入列表 $\\{t_i\\}$ 中的重复翻转掩码不会增加新的转换，可以被过滤成一个唯一的集合。值为 $0$ 的翻转掩码也是一个有效操作，对应于自环（$x \\oplus 0 = x$），`visited` 集合可以正确处理这种情况。\n\n这种基于 BFS 的方法为解决给定任意参数 $B$、$m$、$g$ 和 $\\{t_i\\}$ 的问题提供了一个完整且正确的算法。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport collections\n\ndef find_min_toggles(B, m, g, toggles):\n    \"\"\"\n    Determines the minimum number of toggle operations to transform mask m into g.\n\n    This function models the problem as a shortest path search on an unweighted graph\n    of possible bit masks. Vertices are the masks, and an edge exists between two masks\n    if one can be transformed into the other by a single toggle operation (XOR).\n    Breadth-First Search (BFS) is used to find the shortest path from m to g.\n\n    Args:\n        B (int): The bit-width of the masks. All masks are in the range [0, 2**B - 1].\n        m (int): The initial bit mask.\n        g (int): The target bit mask.\n        toggles (list[int]): A list of toggle masks.\n\n    Returns:\n        int: The minimum number of operations, or -1 if g is unreachable from m.\n    \"\"\"\n    # If the start and target masks are the same, 0 operations are needed.\n    if m == g:\n        return 0\n\n    # Use a set of unique toggles to avoid redundant computations.\n    # A toggle of 0 results in a self-loop (x -> x ^ 0 = x) and does not help\n    # reach new states, so it can be safely ignored.\n    unique_toggles = {t for t in toggles if t != 0}\n\n    # The queue for BFS stores tuples of (mask, distance_from_m).\n    # Initialize with the starting mask and a distance of 0.\n    queue = collections.deque([(m, 0)])\n\n    # A set to keep track of visited masks to avoid cycles and redundant exploration.\n    visited = {m}\n\n    # Perform the BFS.\n    while queue:\n        current_mask, dist = queue.popleft()\n\n        # Explore all possible next states from the current mask.\n        for t in unique_toggles:\n            next_mask = current_mask ^ t\n\n            # If the next mask is the target, we have found the shortest path.\n            if next_mask == g:\n                return dist + 1\n\n            # If the next mask has not been visited, add it to the queue and visited set.\n            if next_mask not in visited:\n                visited.add(next_mask)\n                queue.append((next_mask, dist + 1))\n\n    # If the queue is exhausted and the target was not found, it is unreachable.\n    return -1\n\ndef solve():\n    \"\"\"\n    Solves the problem for the suite of test cases provided in the prompt.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: B=8, m=26, g=229, {t_i}=[160,39,255,91]\n        (8, 26, 229, [160, 39, 255, 91]),\n        # Case 2: B=8, m=123, g=123, {t_i}=[5,7,200]\n        (8, 123, 123, [5, 7, 200]),\n        # Case 3: B=8, m=0, g=4, {t_i}=[1,2]\n        (8, 0, 4, [1, 2]),\n        # Case 4: B=8, m=42, g=40, {t_i}=[0,5,5,7]\n        (8, 42, 40, [0, 5, 5, 7]),\n        # Case 5: B=4, m=0, g=11, {t_i}=[1,2,4,8]\n        (4, 0, 11, [1, 2, 4, 8]),\n    ]\n\n    results = []\n    for B, m, g, toggles in test_cases:\n        result = find_min_toggles(B, m, g, toggles)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3217223"}, {"introduction": "最后的这个练习揭示了位运算与线性代数之间深刻的联系 [@problem_id:3217249]。经典的“电灯开关”问题可以被优雅地建模为在有限域 $GF(2)$ 上的线性方程组 $A x = b$，其中加法就是异或（XOR）运算。你将使用位运算实现高斯消元法来求解这个方程组，从而掌握一种解决一类问题的高效方法，这类问题在纠错码和密码学等领域都有应用。", "problem": "给定 $N$ 个电灯开关和 $N$ 个灯泡。开关 $i$ 可以切换一组灯泡的状态。这组灯泡由一个十进制非负整数掩码 $m_i$ 表示，其中最低有效位（位 $0$）对应灯泡 $1$，位 $1$ 对应灯泡 $2$，通常位 $j$ 对应灯泡 $j+1$。切换是模 $2$ 累加的：按下一个开关会翻转其对应子集中每个灯泡的状态；按同一个开关两次相当于没有按。\n\n你的目标是按下一系列开关，使得从所有灯泡都关闭的初始状态开始，最终只有灯泡 $1$ 是亮的。按动开关的顺序无关紧要，因为切换操作在模 $2$ 加法下满足交换律。因此，任何解决方案都可以表示为一个二进制决策向量 $x \\in \\{0,1\\}^N$，其中当且仅当开关 $i$ 被按了奇数次时，$x_i = 1$。设 $A \\in \\{0,1\\}^{N \\times N}$ 为一个矩阵，其元素 $A_{j,i} = 1$ 当且仅当开关 $i$ 切换灯泡 $j$ 的状态，否则 $A_{j,i} = 0$。设 $b \\in \\{0,1\\}^N$ 为目标向量，其中 $b_1 = 1$ 且对于所有 $j \\neq 1$ 有 $b_j = 0$。你必须求解在二元有限域（GF($2$)）上的线性方程组：\n$$\nA x = b \\quad \\text{over GF}(2).\n$$\n如果方程组无解，你必须指出其不可能性。如果方程组至少有一个解，由于自由变量的存在，可能会有多个解。在这种情况下，你必须返回通过在 GF($2$) 上使用固定的列顺序 $1,2,\\dots,N$ 进行高斯消元，并将所有自由变量设置为 $0$ 所得到的规范解。\n\n你的程序必须：\n- 通过设置 $A_{j,i} = 1$ 当且仅当 $m_i$ 的第 $(j-1)$ 位为 $1$，从掩码 $m_i$ 构建矩阵 $A$。\n- 使用对应于按位异或（异或表示为 XOR，等于模 $2$ 加法）的行操作，在 GF($2$) 上求解 $A x = b$。\n- 如果无解，则为该测试用例输出空列表。\n- 如果有解，则输出按下的开关索引序列，作为一个按升序排列的、以 $1$ 为基准的整数列表，对应于规范解中所有 $x_i = 1$ 的 $i$。\n\n你可以不经证明直接使用的基本事实：\n- 位的布尔代数规则，包括异或（XOR）是可结合和可交换的，以及对于任何位 $a$，$a \\oplus a = 0$。\n- GF($2$) 上线性方程组的性质，以及使用行交换和行异或的高斯消元法会保持解集不变。\n- 将一个 $N$ 位的向量表示为一个非负整数掩码，等同于将这些位打包到该整数的二进制表示中。\n\n使用位掩码将增广矩阵的行表示为整数，并使用位运算进行行操作来实现你的解决方案。\n\n测试套件：\n- 测试用例 $1$：$N = 5$，掩码 $[13,22,19,26,21]$。\n- 测试用例 $2$：$N = 4$，掩码 $[1,2,7,4]$。\n- 测试用例 $3$：$N = 1$，掩码 $[1]$。\n- 测试用例 $4$：$N = 3$，掩码 $[2,4,6]$。\n- 测试用例 $5$：$N = 5$，掩码 $[0,1,0,0,0]$。\n\n输出规格：\n- 对于每个测试用例，输出一个以 $1$ 为基准的、按升序排列的开关索引列表，表示为实现仅灯泡 $1$ 亮起所需按下的开关，此解为上述的规范解。如果不可能，则为该测试用例输出空列表 $[]$。\n- 你的程序应生成单行输出，其中包含所有测试用例的结果，按给定顺序排列，形式为用方括号括起来的逗号分隔列表，不含空格。每个元素是单个测试用例的列表。例如，如果有三个测试用例，一个有效的输出格式是 $[[1,3],[],[2]]$。", "solution": "该问题要求在二元有限域 GF($2$) 上求解线性方程组 $A x = b$。该方程组由 $N$ 个开关和 $N$ 个灯泡定义，其中每个开关对灯泡的作用由一个整数掩码给出。目标是找到一组要按下的开关（由向量 $x \\in \\{0,1\\}^N$ 表示），使得从所有灯泡都关闭的状态开始，最终只有第一个灯泡被点亮。\n\n首先，我们必须通过为方程组 $Ax=b$ 构建增广矩阵 $[A|b]$ 来将问题形式化。设 $N$ 是开关和灯泡的数量。矩阵 $A$ 是一个 $N \\times N$ 矩阵，其中当开关 $i$ 切换灯泡 $j$ 的状态时，元素 $A_{j,i}$ 为 $1$，否则为 $0$。问题陈述，掩码 $m_i$ 的第 $k$ 位对应灯泡 $k+1$。因此，如果掩码 $m_i$ 的第 $(j-1)$ 位为 $1$，则 $A_{j,i} = 1$。这意味着 $A$ 的第 $i$ 列是掩码 $m_i$ 的向量表示。目标状态向量 $b$ 是 $[1, 0, \\dots, 0]^T$，表示只有灯泡 $1$ 是亮的。\n\n为了高效地求解该方程组，我们采用在 GF($2$) 上的高斯消元法，其中加法是按位异或（XOR）操作，乘法是按位与（AND）操作。问题指定了将增广矩阵的行表示为整数，并使用位运算。增广矩阵 $[A|b]$ 的一行有 $N+1$ 个元素。我们可以将第 $j$ 行 $[A_{j,1}, \\dots, A_{j,N}, b_j]$ 表示为单个整数。我们用位 $0, \\dots, N-1$ 来存储 $x_1, \\dots, x_N$ 的系数（即 $A$ 的列），用位 $N$ 来存储增广部分 $b_j$。矩阵 $A$ 的第 $j$ 行（对于 $j=1, \\dots, N$）是通过从每个给定的掩码 $m_1, \\dots, m_N$ 中取其第 $(j-1)$ 位来构建的。\n\n使用高斯消元法的求解过程包括两个主要阶段：\n\n1.  **前向消元**：将增广矩阵转换为行阶梯形。我们遍历列 $j=0, \\dots, N-1$ 和行 $i=0, \\dots, N-1$。对于每一列 $j$，我们在行 $k \\geq i$ 中寻找一个主元（一个 $1$）。如果找到主元，我们将第 $k$ 行与第 $i$ 行交换，并使用新的主元行，通过将其与列 $j$ 中有 $1$ 的任何其他行进行异或操作，来消除该列中主元下方的所有 $1$。这个过程确定了主元列（对应基本变量）和非主元列（对应自由变量）。\n\n2.  **一致性检查和回代**：前向消元后，我们检查不一致性。如果任何行形如 $[0, \\dots, 0 | 1]$，则方程组无解。这对应于等于 $2^N$ 的整数表示。如果方程组是一致的，我们找到指定的规范解：所有自由变量都设置为 $0$。然后我们使用回代法求解基本（主元）变量，从最后一个主元行开始向上移动。对于对应于主元变量 $x_p$ 的主元行 $i$，方程的形式为 $x_p \\oplus \\bigoplus_{kp, k \\text{ is col index}} c_k x_k = b'_i$。由于 $kp$ 的变量 $x_k$ 已经确定（或者是自由变量并被设置为 $0$），我们可以求解 $x_p$ 为 $x_p = b'_i \\oplus \\bigoplus_{kp} c_k x_k$。\n\n最终的解向量 $x$ 指示了要按哪些开关。输出是一个排序好的、以 $1$ 为基准的开关索引 $i$ 的列表，其中 $x_i=1$。如果不存在解，则返回一个空列表。\n\n让我们用一个例子来说明：$N=3$，掩码 $m=[2,4,6]$。根据问题定义，矩阵 $A$ 的第 $i$ 列由掩码 $m_i$ 的位构成。$m_1=2=(010)_2$, $m_2=4=(100)_2$, $m_3=6=(110)_2$。因此，$A$ 的第1列是 $[0, 1, 0]^T$，第2列是 $[0, 0, 1]^T$，第3列是 $[0, 1, 1]^T$。矩阵 $A$ 为：\n$$A = \\begin{pmatrix} 0  0  0 \\\\ 1  0  1 \\\\ 0  1  1 \\end{pmatrix}$$\n目标向量 $b$ 是 $[1, 0, 0]^T$。增广矩阵 $[A|b]$ 为：\n$$\\begin{pmatrix} 0  0  0  |  1 \\\\ 1  0  1  |  0 \\\\ 0  1  1  |  0 \\end{pmatrix}$$\n第一行方程为 $0 \\cdot x_1 + 0 \\cdot x_2 + 0 \\cdot x_3 = 1$，即 $0=1$。这是一个矛盾，因此方程组不一致，没有解。对于这个例子，输出应为 `[]`。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        (5, [13, 22, 19, 26, 21]),\n        (4, [1, 2, 7, 4]),\n        (1, [1]),\n        (3, [2, 4, 6]),\n        (5, [0, 1, 0, 0, 0]),\n    ]\n\n    results = []\n    for N, masks in test_cases:\n        result = solve_single_case(N, masks)\n        results.append(result)\n\n    # Format the final output string\n    # e.g., [[1,3,5],[1],[1],[2],[2]]\n    output_str = \"[\" + \",\".join(map(str, results)).replace(\" \", \"\") + \"]\"\n    print(output_str)\n\ndef solve_single_case(N, masks):\n    \"\"\"\n    Solves a single instance of the lights and switches problem.\n    Args:\n        N: The number of switches and bulbs.\n        masks: A list of integers representing the switch-bulb connections.\n    Returns:\n        A sorted list of 1-indexed switch numbers to press for the canonical solution,\n        or an empty list if no solution exists.\n    \"\"\"\n    \n    # Step 1: Construct the augmented matrix as a list of integers.\n    # Each integer represents a row. Bit i corresponds to variable x_{i+1} (column i).\n    # Bit N corresponds to the augmented part (vector b).\n    aug_matrix = [0] * N\n    for j in range(N):  # Corresponds to row j, for bulb j+1\n        row_mask = 0\n        for i in range(N):  # Corresponds to column i, for switch i+1\n            # A_{j,i} is 1 if switch i+1 toggles bulb j+1.\n            # This is given by the j-th bit of masks[i].\n            if (masks[i] >> j)  1:\n                row_mask |= (1  i)\n\n        # The target vector b has b_1 = 1, b_j = 0 for j!=1.\n        # This affects the first row (j=0).\n        if j == 0:\n            row_mask |= (1  N)\n        \n        aug_matrix[j] = row_mask\n\n    # Step 2: Forward elimination to achieve row echelon form.\n    pivot_row = 0\n    pivot_cols = []\n    for j in range(N):  # Iterate through columns to find pivots\n        if pivot_row == N:\n            break\n        \n        # Find a row >= pivot_row with a 1 in the current column j\n        i = pivot_row\n        while i  N and (aug_matrix[i] >> j)  1 == 0:\n            i += 1\n            \n        if i  N:  # A pivot is found at (i, j)\n            # Swap rows to bring the pivot to the diagonal position (pivot_row, j)\n            aug_matrix[pivot_row], aug_matrix[i] = aug_matrix[i], aug_matrix[pivot_row]\n            \n            pivot_val = aug_matrix[pivot_row]\n            \n            # Eliminate 1s below the pivot in the current column j\n            for k in range(pivot_row + 1, N):\n                if (aug_matrix[k] >> j)  1:\n                    aug_matrix[k] ^= pivot_val\n            \n            pivot_cols.append(j)\n            pivot_row += 1\n\n    # Step 3: Check for inconsistency.\n    # This occurs if we have a row [0, 0, ..., 0 | 1].\n    for i in range(pivot_row, N):\n        if aug_matrix[i] == (1  N):\n            return []  # No solution\n\n    # Step 4: Back substitution to find the canonical solution.\n    # Free variables (non-pivot columns) are implicitly set to 0.\n    x = [0] * N\n    # Iterate backwards through the pivot rows\n    for i in range(pivot_row - 1, -1, -1):\n        pivot_col = pivot_cols[i]\n        row_val = aug_matrix[i]\n        \n        # Calculate the sum of terms involving already-determined variables\n        # The equation for this row is: x_{pivot_col} + sum_{k>pivot_col} c_k*x_k = b'\n        rhs_sum = 0\n        for k in range(pivot_col + 1, N):\n            if (row_val >> k)  1:\n                rhs_sum ^= x[k]\n        \n        # The augmented bit for this row\n        b_val = (row_val >> N)  1\n        \n        # Solve for x_{pivot_col}\n        x[pivot_col] = b_val ^ rhs_sum\n        \n    # Step 5: Format the output as a sorted list of 1-indexed switch numbers.\n    solution = []\n    for i in range(N):\n        if x[i] == 1:\n            solution.append(i + 1)\n            \n    return solution\n\nsolve()\n\n```", "id": "3217249"}]}