{"hands_on_practices": [{"introduction": "我们将从最直观的内存分配策略——首次适配（first-fit）算法——开始我们的实践之旅。这个练习的目标是亲手构造一个会导致严重外部碎片化的操作序列，让你直观地感受到即使总有足够的空闲内存，分配请求也可能因为内存不连续而失败。通过这个实践[@problem_id:3239139]，你将深刻理解为何需要更复杂的内存分配器来应对碎片化问题。", "problem": "设计并实现一个模拟堆内存管理器，该管理器使用“首次适应”策略来满足分配请求。堆被建模为一个划分为多个块的连续地址数组。每个块都有一个以抽象单位计量的大小和一个指示其是被分配还是空闲的状态。分配器必须在分配时实现块分裂，在释放时实现相邻空闲块的合并。“首次适应”策略从堆的起始位置开始搜索块，并选择大小至少为请求大小的第一个空闲块。如果所选空闲块大于请求大小，则它被分裂为一个大小为请求大小的已分配块和一个代表剩余容量的残留空闲块。如果一个块的大小恰好等于请求大小，则它仅被标记为已分配，而不进行分裂。\n\n基础知识：\n- 堆内存是一个连续的地址空间；连续分配请求需要单个不间断的地址范围。\n- “首次适应”是一种广泛使用的堆分配策略：一个大小为 $s$ 的请求从头开始扫描空闲列表，直到找到第一个大小至少为 $s$ 的空闲块，并将分配放置在那里。\n- 外部碎片是指总空闲内存足以满足一个请求，但由于空闲内存被分割在多个非连续的块中而无法使用的现象。在此问题中，一个定量的外部碎片度量是最大连续空闲区域（空闲块）的数量以及最大此类区域的大小。\n\n您必须：\n- 实现一个具有以下操作的“首次适应”分配器：\n  - 如果存在合适的空闲块，则分配一个大小为 $s$ 的块。返回一个唯一引用该已分配块的句柄（一个标识符）。如果不存在合适的空闲块，则分配失败。\n  - 通过句柄释放先前分配的块，并将其与任何相邻的空闲块合并，以恢复最大的连续空闲区域。\n- 对所有块使用精确的整数大小。此问题中没有物理单位。\n- 提供在任何时间点计算以下指标的函数：\n  - 空闲块的数量（每个块都是一个最大连续空闲区域）。\n  - 最大空闲块的大小。\n  - 总空闲内存，计算为所有空闲块大小的总和。\n- 实现一个测试，该测试（在特定的分配和释放序列之后）尝试一次大小为 $s^\\ast$ 的最终分配，报告在“首次适应”策略下它是否会成功，然后立即撤销该尝试，以使堆返回到其先前的状态。\n\n关于最坏情况外部碎片的核心要求：\n- 构建一个请求序列，在“首次适应”策略下产生 $O(N)$ 数量级的最坏情况外部碎片。具体来说，对于一个容量至少为 $3N$ 个单位的堆，执行 $2N$ 次大小为 $1$ 的分配，然后在这 $2N$ 个块中释放每隔一个已分配的块（例如，按分配顺序释放位置 $0,2,4,\\ldots,2N-2$ 处的块）。这将产生 $N$ 个大小为 $1$ 的空闲块与 $N$ 个大小为 $1$ 的已分配块交错排列，空闲块之间没有邻接关系，因此合并无法减少它们的数量。形成此模式后，尝试分配一个大小为 $N$ 的块，并报告该分配是否会成功。\n\n测试套件：\n- 用例 $1$：堆大小 $30$，$N=10$。执行上述 $O(N)$ 碎片化构造。尝试一次大小为 $10$ 的最终分配。\n- 用例 $2$：堆大小 $3$，$N=1$。执行相同的构造，然后尝试一次大小为 $1$ 的最终分配。\n- 用例 $3$：堆大小 $12$。分配 $12$ 个大小均为 $1$ 的块，全部释放，然后尝试一次大小为 $12$ 的最终分配。\n- 用例 $4$：堆大小 $20$。依次分配大小为 $[3,2,5,2,3,2,1,2]$ 的块，然后释放第 $2$、第 $4$、第 $6$ 和第 $8$ 个已分配的块（这些块的大小均为 $2,2,2,2$），并尝试一次大小为 $5$ 的最终分配。\n\n对每个测试用例，按以下确切顺序生成结果列表：\n- 空闲块的数量（一个整数）。\n- 最大空闲块的大小（一个整数）。\n- 总空闲内存（一个整数）。\n- 最终尝试的分配是否会成功（一个布尔值）。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含所有测试用例的结果。结果是一个逗号分隔的列表，用方括号括起来，其中每个测试用例的结果本身也是一个逗号分隔的列表，用方括号括起来。例如，输出应类似于 $[[a_1,b_1,c_1,d_1],[a_2,b_2,c_2,d_2],[a_3,b_3,c_3,d_3],[a_4,b_4,c_4,d_4]]$，不含空格。\n\n您的实现必须是自包含和确定性的，不需要任何输入，并精确生成一行符合指定格式的输出。", "solution": "问题陈述在形式上是有效的。其科学基础植根于计算机科学原理，特别是动态内存管理算法。该问题定义明确，为确定性模拟提供了所有必要的数据、约束和定义。语言客观且无歧义。因此，我们可以着手提供解决方案。\n\n基于“首次适应”策略的模拟堆内存管理器的设计，需要一种能够高效表示内存分区（划分为空闲块和已分配块）并支持分配（带块分裂）和释放（带块合并）操作的数据结构。\n\n双向链表是用于此目的的典型数据结构。列表中的每个节点代表一个连续的内存块。使用指向内存顺序中前一个和后一个块的指针，可以实现高效遍历，并且关键地，可以以常数时间访问相邻块，这对于释放过程中的合并操作至关重要。\n\n在我们的模型中，每个块都将是一个具有以下属性的对象：\n- `size`：一个表示块大小的整数。\n- `is_free`：一个布尔标志，如果块可用于分配，则为 `True`，否则为 `False`。\n- `start_addr`：块在堆内的起始地址（偏移量），提供唯一的空间引用。\n- `prev_block`：一个指向堆内存空间中逻辑上位于前一个块的引用。\n- `next_block`：一个指向堆内存空间中逻辑上位于后一个块的引用。\n\n堆管理器本身初始化时包含一个跨越整个堆容量的单一空闲块。分配通过一个字典进行跟踪，该字典将成功分配后返回的唯一整数句柄映射到相应的块对象。\n\n核心操作实现如下：\n\n**1. 分配 (`allocate(s)`)**\n“首次适应”算法要求从头开始对堆进行线性扫描。我们从头部开始遍历块的双向链表，寻找满足两个条件的第一个块 `b`：`b.is_free` 为 `True`，并且其大小 `b.size` 大于或等于请求的大小 `s`。\n\n- 如果没有找到这样的块，说明可用内存过于零碎或不足，分配请求失败。\n- 如果找到了合适的块 `b`：\n    - **精确匹配**：如果 `b.size == s`，该块仅被标记为已分配 (`b.is_free = False`)。列表结构无需改变。\n    - **分裂**：如果 `b.size > s`，该块必须被分裂。原始块 `b` 的大小调整为 `s` 并标记为已分配。一个大小为 `b.size - s` 的新空闲块紧随其后被创建并插入列表中。此操作涉及更新 `b` 及其原始后继节点的指针以插入新的残留空闲块，从而维护双向链表的完整性。\n\n系统会生成一个唯一的句柄并与分配的块关联，然后将其返回给调用者。\n\n**2. 释放 (`free(handle)`)**\n释放操作首先使用提供的 `handle` 来检索要释放的块。该块的状态更改为 `is_free = True`。关键步骤是合并，它通过将相邻的空闲块合并成一个单一、更大的空闲块来应对外部碎片。\n\n释放一个块 `B` 后，我们检查其邻居——前一个块 `A` 和后一个块 `C`。\n- 如果 `C` 存在且为空闲，则 `B` 和 `C` 合并。这通过将 `C` 的大小加到 `B` 的大小上，并更新 `B` 的 `next_block` 指针以绕过 `C` 来实现，从而有效地从列表中移除 `C`。\n- 随后，如果 `A` 存在且为空闲，则现在可能更大的块 `B` 被合并到 `A` 中。这通过将 `B` 的大小加到 `A` 的大小上，并更新 `A` 的 `next_block` 指针以绕过 `B` 来实现。\n\n这种双向检查确保一个新释放的块会与其所有相邻的空闲邻居合并，从而在该位置恢复可能的最大连续空闲空间。\n\n**3. 指标与测试**\n所需的指标——空闲块数量、最大空闲块大小和总空闲内存——通过直接遍历链表来计算，对 `is_free` 为 `True` 的块累积计数、最大值和总和。\n\n测试大小为 `s*` 的潜在分配的函数是以事务方式实现的。它首先使用标准的 `allocate` 方法尝试分配。如果分配失败，则返回 `False`。如果成功，它会获得一个句柄，返回 `True`，并立即用该句柄调用 `free` 方法。根据我们的设计，`free` 操作及其包含的合并逻辑，能够正确地逆转分裂或精确匹配分配所做的状态更改，从而将堆恢复到测试前的精确状态。\n\n提供的测试用例旨在验证分配器行为的特定方面。用例 `$3$` 展示了完美的合并。用例 `$4$` 举例说明了外部碎片，即总空闲内存超过请求大小，但分配仍然失败。用例 `$1$` 和 `$2$` 为“首次适应”算法构造了一种特定的最坏情况碎片模式，在这种模式下，大量小的、非连续的空闲块使得分配器尽管总空闲空间充足，却无法满足一个大的请求。我们的实现正确地模拟了这些现象。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the heap memory manager simulation problem.\n    \"\"\"\n\n    class Block:\n        \"\"\"Represents a block of memory in the heap.\"\"\"\n        def __init__(self, size, start_addr):\n            self.size = size\n            self.is_free = True\n            self.start_addr = start_addr\n            self.prev_block = None\n            self.next_block = None\n\n        def __repr__(self):\n            state = \"F\" if self.is_free else \"A\"\n            return f\"[{state}({self.size})@{self.start_addr}]\"\n\n    class HeapManager:\n        \"\"\"Implements a first-fit heap memory manager.\"\"\"\n        def __init__(self, total_size):\n            self.total_size = total_size\n            self.head = Block(total_size, 0)\n            self.allocations = {}\n            self.next_handle = 1\n\n        def allocate(self, req_size):\n            \"\"\"Allocates a block of memory using first-fit strategy.\"\"\"\n            if req_size == 0:\n                return None\n            \n            current_block = self.head\n            while current_block:\n                if current_block.is_free and current_block.size >= req_size:\n                    # Found a suitable block\n                    if current_block.size > req_size:\n                        # Split the block\n                        new_free_block = Block(\n                            size=current_block.size - req_size,\n                            start_addr=current_block.start_addr + req_size\n                        )\n                        new_free_block.prev_block = current_block\n                        new_free_block.next_block = current_block.next_block\n                        \n                        if current_block.next_block:\n                            current_block.next_block.prev_block = new_free_block\n                        \n                        current_block.size = req_size\n                        current_block.next_block = new_free_block\n\n                    # Mark the block as allocated\n                    current_block.is_free = False\n                    handle = self.next_handle\n                    self.allocations[handle] = current_block\n                    self.next_handle += 1\n                    return handle\n\n                current_block = current_block.next_block\n            \n            return None # Allocation failed\n\n        def free(self, handle):\n            \"\"\"Frees a previously allocated block and coalesces neighbors.\"\"\"\n            if handle not in self.allocations:\n                return\n\n            block_to_free = self.allocations.pop(handle)\n            block_to_free.is_free = True\n\n            # Coalesce with next block\n            if block_to_free.next_block and block_to_free.next_block.is_free:\n                next_b = block_to_free.next_block\n                block_to_free.size += next_b.size\n                block_to_free.next_block = next_b.next_block\n                if next_b.next_block:\n                    next_b.next_block.prev_block = block_to_free\n\n            # Coalesce with previous block\n            if block_to_free.prev_block and block_to_free.prev_block.is_free:\n                prev_b = block_to_free.prev_block\n                prev_b.size += block_to_free.size\n                prev_b.next_block = block_to_free.next_block\n                if block_to_free.next_block:\n                    block_to_free.next_block.prev_block = prev_b\n        \n        def get_metrics(self):\n            \"\"\"Computes the required heap metrics.\"\"\"\n            num_free_blocks = 0\n            max_free_block_size = 0\n            total_free_memory = 0\n            \n            current_block = self.head\n            while current_block:\n                if current_block.is_free:\n                    num_free_blocks += 1\n                    total_free_memory += current_block.size\n                    if current_block.size > max_free_block_size:\n                        max_free_block_size = current_block.size\n                current_block = current_block.next_block\n            \n            return num_free_blocks, max_free_block_size, total_free_memory\n\n        def test_allocate(self, req_size):\n            \"\"\"Tests if an allocation would succeed and reverts the heap state.\"\"\"\n            handle = self.allocate(req_size)\n            if handle is None:\n                return False\n            else:\n                self.free(handle)\n                return True\n\n    all_results = []\n\n    # Case 1\n    heap1 = HeapManager(30)\n    n1 = 10\n    handles1 = [heap1.allocate(1) for _ in range(2 * n1)]\n    for i in range(0, 2 * n1, 2):\n        heap1.free(handles1[i])\n    metrics1 = heap1.get_metrics()\n    success1 = heap1.test_allocate(10)\n    all_results.append([*metrics1, success1])\n\n    # Case 2\n    heap2 = HeapManager(3)\n    n2 = 1\n    handles2 = [heap2.allocate(1) for _ in range(2 * n2)]\n    for i in range(0, 2 * n2, 2):\n        heap2.free(handles2[i])\n    metrics2 = heap2.get_metrics()\n    success2 = heap2.test_allocate(1)\n    all_results.append([*metrics2, success2])\n    \n    # Case 3\n    heap3 = HeapManager(12)\n    handles3 = [heap3.allocate(1) for _ in range(12)]\n    for handle in handles3:\n        heap3.free(handle)\n    metrics3 = heap3.get_metrics()\n    success3 = heap3.test_allocate(12)\n    all_results.append([*metrics3, success3])\n\n    # Case 4\n    heap4 = HeapManager(20)\n    alloc_sizes = [3, 2, 5, 2, 3, 2, 1, 2]\n    handles4 = [heap4.allocate(size) for size in alloc_sizes]\n    handles_to_free_indices = [1, 3, 5, 7] # 2nd, 4th, 6th, 8th (0-indexed)\n    for index in handles_to_free_indices:\n        heap4.free(handles4[index])\n    metrics4 = heap4.get_metrics()\n    success4 = heap4.test_allocate(5)\n    all_results.append([*metrics4, success4])\n\n    # Format the final output string\n    result_str = \",\".join([f\"[{','.join(map(str, res))}]\" for res in all_results])\n    print(f\"[{result_str}]\")\n\nsolve()\n```", "id": "3239139"}, {"introduction": "在首次适配算法的基础上，我们来探索一种常见的变体：下次适配（next-fit）算法。该算法引入了一个“流浪指针”以避免每次都从头开始搜索，旨在提高平均分配效率，但它也带来了独特的碎片化行为。通过实现下次适配分配器并分析其对堆起始区域碎片化的影响[@problem_id:3239067]，你将体会到算法设计中的权衡与取舍。", "problem": "实现一个完整的、可运行的程序，该程序模拟一个带有移动指针的下一个适配（next-fit）堆分配器，并测量堆起始部分的碎片化程度。模拟必须遵循以下形式化模型和规则。\n\n模型和基本原理：堆是一个大小为 $H$（以抽象单位计量）的连续线性内存。它表示为区间 $[0,H)$ 的一个有序分区，其中每个块都有一个起始地址 $s$ 和一个长度 $\\ell$，满足 $s \\in \\mathbb{Z}_{\\ge 0}$，$\\ell \\in \\mathbb{Z}_{>0}$，以及 $s + \\ell \\le H$。每个块要么是空闲的，要么是已分配的。分配器维护一个移动指针 $\\rho \\in [0,H]$，该指针标记下一次搜索空闲块的起始地址。初始时，堆由一个从地址 0 开始、长度为 $H$ 的单一空闲块组成，并且移动指针设置为 $\\rho = 0$。\n\n分配规则（下一个适配与分割）：当收到一个大小为 $r \\in \\mathbb{Z}_{>0}$ 的分配请求时，分配器从起始地址 $s$ 满足 $s \\ge \\rho$ 的第一个块开始，按起始地址递增的顺序搜索块，并在到达末尾后回绕到 $s = 0$。第一个长度 $\\ell \\ge r$ 的空闲块被选中。如果找到这样的块，它将被分割成两个块：一个是从其起始地址 $s$ 开始、长度为 $r$ 的已分配块，以及一个（如果 $\\ell > r$）从地址 $s + r$ 开始、长度为 $\\ell - r$ 的空闲剩余块。成功分配后，移动指针 $\\rho$ 会更新为紧邻已分配部分之后的块的起始地址：具体来说，如果存在空闲剩余块，则 $\\rho \\leftarrow s + r$；否则，$\\rho$ 成为堆顺序中下一个块的起始地址，如果分配消耗了最后一个块，则回绕到 0。如果没有合适的空闲块存在，分配将静默失败，并且堆保持不变。\n\n释放规则（合并）：当释放一个由其唯一标识符标识的已分配块时，该块变为空闲状态。如果其在内存顺序上的直接前驱或后继是空闲的，分配器会通过合并它们的区间，将所有相邻的空闲块合并成一个单一的空闲块。在释放过程中，移动指针 $\\rho$ 保持不变。\n\n堆起始部分的碎片化度量：对于给定的前缀长度 $P \\in \\mathbb{Z}_{\\ge 0}$，定义前缀区间 $I_P = [0,P) \\cap [0,H)$。设所有操作后空闲块的集合为 $\\{[s_i, s_i + \\ell_i)\\}_{i=1}^m$。对于每个空闲块，定义其与前缀的重叠部分为 $u_i(P) = \\max\\{0, \\min\\{s_i + \\ell_i, P\\} - \\max\\{s_i, 0\\}\\}$。前缀中的总空闲单元数为\n$$\nS(P) = \\sum_{i=1}^m u_i(P).\n$$\n前缀中的空闲碎片数量为\n$$\nk(P) = \\left|\\left\\{ i \\in \\{1,\\dots,m\\} \\ \\middle| \\ u_i(P) > 0 \\right\\}\\right|.\n$$\n定义前缀的碎片化指数为\n$$\nF(P) = \n\\begin{cases}\n\\dfrac{k(P)}{S(P)}  \\text{if } S(P) > 0, \\\\\n0  \\text{if } S(P) = 0.\n\\end{cases}\n$$\n该指数是一个无单位的十进制量，并且必须以小数形式报告，而不是百分比。\n\n程序要求：完全按照规定实现带有分割和合并功能的下一个适配分配器。通过应用一系列操作来模拟每个测试用例，然后计算指定前缀 $I_P$ 的碎片化指数 $F(P)$。\n\n测试套件：您的程序必须按顺序执行以下四个测试用例。每个操作是一个元组，其中第一个组件要么是带有大小 $r$ 和标识符 $\\text{id}$ 的字符串 $\\text{\"alloc\"}$，要么是带有标识符 $\\text{id}$ 的字符串 $\\text{\"free\"}$。\n\n测试用例 1：\n- 堆大小 $H = 64$。\n- 前缀长度 $P = 16$。\n- 操作顺序：\n  $$(\\text{\"alloc\"}, 1, 16), (\\text{\"alloc\"}, 2, 24), (\\text{\"free\"}, 1), (\\text{\"alloc\"}, 3, 8), (\\text{\"alloc\"}, 4, 8), (\\text{\"alloc\"}, 5, 8), (\\text{\"alloc\"}, 6, 8), (\\text{\"alloc\"}, 7, 4), (\\text{\"free\"}, 6), (\\text{\"alloc\"}, 8, 2)。$$\n\n测试用例 2（零长度前缀的边界情况）：\n- 堆大小 $H = 32$。\n- 前缀长度 $P = 0$。\n- 操作顺序：\n  $$(\\text{\"alloc\"}, 1, 32), (\\text{\"free\"}, 1)。$$\n\n测试用例 3（包含回绕和因合并导致的低前缀碎片化的理想情况）：\n- 堆大小 $H = 64$。\n- 前缀长度 $P = 32$。\n- 操作顺序：\n  $$(\\text{\"alloc\"}, 1, 32), (\\text{\"alloc\"}, 2, 16), (\\text{\"alloc\"}, 3, 8), (\\text{\"free\"}, 1), (\\text{\"alloc\"}, 4, 4), (\\text{\"alloc\"}, 5, 4), (\\text{\"alloc\"}, 6, 8), (\\text{\"free\"}, 6)。$$\n\n测试用例 4（因下一个适配的偏向性和选择性释放导致在起始附近出现多个小空闲碎片的边缘情况）：\n- 堆大小 $H = 40$。\n- 前缀长度 $P = 20$。\n- 操作顺序：\n  $$(\\text{\"alloc\"}, 1, 10), (\\text{\"alloc\"}, 2, 10), (\\text{\"alloc\"}, 3, 10), (\\text{\"alloc\"}, 4, 10), (\\text{\"free\"}, 1), (\\text{\"alloc\"}, 5, 5), (\\text{\"alloc\"}, 6, 5), (\\text{\"free\"}, 2), (\\text{\"alloc\"}, 7, 4), (\\text{\"free\"}, 6)。$$\n\n最终输出格式：您的程序应生成单行输出，其中包含四个测试用例的碎片化指数，按顺序排列，作为一个用方括号括起来的逗号分隔列表。例如，它应该看起来像\n$$\n[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4],\n$$\n其中每个 $\\text{result}_i$ 是对应于第 $i$ 个测试用例的 $F(P)$ 的小数值。不应打印任何其他文本。", "solution": "问题陈述已经过验证，被认为是有效的。它对一个下一个适配堆分配模拟提供了自包含、科学上合理且定义明确的描述。分配、释放和碎片化度量的规则被形式化且无歧义地定义，从而允许一个唯一且可验证的解决方案。\n\n该解决方案将通过创建一个类来模拟堆分配器，在 Python 中实现。该模型的核心是一个动态的对象列表，每个对象代表一个内存块。\n\n**1. 数据结构**\n\n堆是一个大小为 `H` 的连续内存空间。我们可以通过维护一个按起始地址排序的块列表来模拟其状态。每个块必须存储其起始地址 `s`、长度 `l` 及其状态（空闲或已分配）。每个已分配的块还关联一个唯一标识符。一个 Python 类，我们称之为 `Block`，是对此的合适表示：\n- `start`：一个整数，表示块的起始地址 `s`。\n- `size`：一个正整数，表示块的长度 `l`。\n- `is_free`：一个布尔标志，指示块是否空闲。\n- `id`：已分配块的标识符，如果为空闲则为 `None`。\n\n主要的 `NextFitAllocator` 类将管理堆的整体状态：\n- `H`：堆的总大小。\n- `blocks`：一个 `Block` 对象的 Python 列表，始终按 `start` 属性排序。初始时，此列表包含一个 `start`$=0$ 且 `size`$=H$ 的单一空闲块。\n- `rho`：移动指针 `rho`，一个整数，存储下一次分配搜索的起始地址。它被初始化为 `0`。\n- `allocated_map`：一个将唯一块标识符（`id`）映射到其对应 `Block` 对象的字典。这使得在释放请求期间能够实现平均时间复杂度为 $O(1)$ 的查找。\n\n**2. 分配逻辑（`allocate` 方法）**\n\n大小为 `r` 的请求的分配过程遵循下一个适配策略。\n\n- **搜索启动**：搜索从移动指针 `rho` 的位置开始。我们首先在已排序的列表中找到第一个其起始地址 `s` 大于或等于 `rho` 的块的索引。设此索引为 `start_idx`。\n- **搜索执行**：从 `start_idx` 到 `blocks` 列表的末尾搜索合适的空闲块。如果未找到块，搜索将回绕并从列表的开头继续，直到 `start_idx - 1`。\n- **块选择**：遇到的第一个大小 `l >= r` 的空闲块被选中用于分配。\n- **分割**：如果所选块的大小 `l` 严格大于请求的大小 `r`，则该块被分割。原始块的大小被调整为 `r`，标记为已分配，并被赋予给定的标识符。然后创建一个新的空闲块，起始地址为 `s+r`，大小为 `l-r`，并插入到 `blocks` 列表中紧随新分配的块之后，以保持排序顺序。\n- **移动指针更新**：\n    - 如果块被分割，会创建一个新的空闲块。移动指针 `rho` 更新为这个新的剩余块的起始地址，即 `rho` $\\leftarrow$ `s+r`。\n    - 如果分配是精确匹配（`l==r`），移动指针 `rho` 会移动到内存顺序中下一个块的起始地址。如果分配的块是堆中的最后一个，`rho` 会回绕到 `0`。\n- **失败**：如果搜索完成而没有找到任何合适的空闲块，则分配请求将按规定静默失败，并且堆状态保持不变。\n\n**3. 释放逻辑（`free` 方法）**\n\n释放操作涉及将一个块设置为空闲状态，并将其与相邻的空闲块合并。\n\n- **块识别**：使用 `allocated_map` 及其给定的 `id` 可以高效地定位要释放的块。\n- **释放**：将块的 `is_free` 标志设置为 `True`，并将其 `id` 设置回 `None`。\n- **合并**：为了维护具有最大可能连续空闲块的内存模型，我们必须检查相邻的空闲邻居。\n    1.  **与后继合并**：检查 `blocks` 列表中紧随新释放块之后的块（如果存在）。如果它也是空闲的，则将其合并到当前块中。当前块的大小增加后继块的大小，然后从列表中移除后继块。\n    2.  **与前驱合并**：检查紧接在新释放块之前的块（如果存在）。如果它也是空闲的，则将当前块合并到其前驱中。前驱的大小增加当前块的大小，然后从列表中移除当前块。\n操作的顺序很重要；先检查后继再检查前驱可以简化索引管理。移动指针 `rho` 不受释放操作的影响。\n\n**4. 碎片化度量计算（`calculate_fragmentation` 方法）**\n\n在测试用例的所有操作完成后，计算给定前缀长度 `P` 的碎片化指数 `F(P)`。\n\n- **初始化**：初始化两个累加器：`S_P`（用于前缀中的总空闲单元数，$S(P)$）为 `0`，以及 `k_P`（用于前缀中的空闲碎片数量，$k(P)$）为 `0`。\n- **迭代**：该方法遍历最终堆配置中的所有块。\n- **重叠计算**：对于每个空闲块 $[s_i, s_i + \\ell_i)$，使用公式 $u_i(P) = \\max\\{0, \\min\\{s_i + \\ell_i, P\\} - \\max\\{s_i, 0\\}\\}$ 计算其与前缀区间 $[0, P)$ 的重叠部分 `u_i(P)`。\n- **累加**：如果计算出的重叠 `u_i(P)` 大于 `0`，则意味着该块对前缀内的空闲空间有贡献。`S_P` 增加 `u_i(P)`，`k_P` 增加 `1`。\n- **最终计算**：碎片化指数 `F(P)` 计算为比率 `k_P / S_P`。如果 `S_P` 为 `0`（即前缀中没有空闲空间），则 `F(P)` 定义为 `0`。\n\n这种结构化的方法确保了正确且稳健的实现，该实现精确地遵循了问题陈述中提供的形式化模型。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass Block:\n    \"\"\"Represents a block of memory in the heap.\"\"\"\n    def __init__(self, start, size, is_free=True, block_id=None):\n        self.start = start\n        self.size = size\n        self.is_free = is_free\n        self.id = block_id\n\n    def __repr__(self):\n        state = \"F\" if self.is_free else \"A\"\n        return f\"Block(s={self.start}, l={self.size}, {state}, id={self.id})\"\n\nclass NextFitAllocator:\n    \"\"\"Implements a next-fit heap allocator with a roving pointer.\"\"\"\n    def __init__(self, H):\n        self.H = H\n        self.blocks = [Block(0, H)]\n        self.rho = 0\n        self.allocated_map = {}\n\n    def allocate(self, req_id, req_size):\n        \"\"\"Allocates a block of memory using the next-fit algorithm.\"\"\"\n        start_idx = 0\n        for i, block in enumerate(self.blocks):\n            if block.start >= self.rho:\n                start_idx = i\n                break\n        \n        # Create a search order that wraps around\n        search_order = list(range(start_idx, len(self.blocks))) + list(range(0, start_idx))\n        \n        found_block_idx = -1\n        for i in search_order:\n            block = self.blocks[i]\n            if block.is_free and block.size >= req_size:\n                found_block_idx = i\n                break\n\n        if found_block_idx == -1:\n            return  # Silent failure\n\n        block_to_alloc = self.blocks[found_block_idx]\n        original_start = block_to_alloc.start\n        original_size = block_to_alloc.size\n\n        if original_size > req_size:\n            # Split the block\n            block_to_alloc.size = req_size\n            block_to_alloc.is_free = False\n            block_to_alloc.id = req_id\n            \n            new_free_block = Block(original_start + req_size, original_size - req_size)\n            self.blocks.insert(found_block_idx + 1, new_free_block)\n            \n            # Update rho to start of the new free remainder block\n            self.rho = new_free_block.start\n        else:  # Exact fit: original_size == req_size\n            block_to_alloc.is_free = False\n            block_to_alloc.id = req_id\n            \n            # Update rho to the start of the next block, wrapping if necessary\n            next_block_idx = (found_block_idx + 1) % len(self.blocks)\n            self.rho = self.blocks[next_block_idx].start\n        \n        self.allocated_map[req_id] = block_to_alloc\n\n    def free(self, req_id):\n        \"\"\"Frees an allocated block and coalesces with adjacent free blocks.\"\"\"\n        if req_id not in self.allocated_map:\n            return\n\n        block_to_free = self.allocated_map.pop(req_id)\n        block_to_free.is_free = True\n        block_to_free.id = None\n\n        try:\n            current_idx = self.blocks.index(block_to_free)\n        except ValueError:\n            return # Should not happen in a correct simulation\n\n        # 1. Coalesce with successor\n        if current_idx + 1 < len(self.blocks) and self.blocks[current_idx + 1].is_free:\n            successor = self.blocks[current_idx + 1]\n            block_to_free.size += successor.size\n            self.blocks.pop(current_idx + 1)\n\n        # 2. Coalesce with predecessor\n        if current_idx > 0 and self.blocks[current_idx - 1].is_free:\n            predecessor = self.blocks[current_idx - 1]\n            predecessor.size += block_to_free.size\n            self.blocks.pop(current_idx)\n\n    def calculate_fragmentation(self, P):\n        \"\"\"Calculates the fragmentation index F(P) for a given prefix length P.\"\"\"\n        total_free_units_in_prefix = 0\n        num_free_fragments_in_prefix = 0\n\n        for block in self.blocks:\n            if block.is_free:\n                # Calculate overlap: u_i(P) = max(0, min(s_i + l_i, P) - max(s_i, 0))\n                overlap_start = max(block.start, 0)\n                overlap_end = min(block.start + block.size, P)\n                \n                overlap_size = max(0, overlap_end - overlap_start)\n\n                if overlap_size > 0:\n                    total_free_units_in_prefix += overlap_size\n                    num_free_fragments_in_prefix += 1\n        \n        if total_free_units_in_prefix == 0:\n            return 0.0\n        \n        return num_free_fragments_in_prefix / total_free_units_in_prefix\n\ndef solve():\n    test_cases = [\n        {\n            \"H\": 64, \"P\": 16, \"ops\": [\n                (\"alloc\", 1, 16), (\"alloc\", 2, 24), (\"free\", 1), (\"alloc\", 3, 8),\n                (\"alloc\", 4, 8), (\"alloc\", 5, 8), (\"alloc\", 6, 8), (\"alloc\", 7, 4),\n                (\"free\", 6), (\"alloc\", 8, 2)\n            ]\n        },\n        {\n            \"H\": 32, \"P\": 0, \"ops\": [\n                (\"alloc\", 1, 32), (\"free\", 1)\n            ]\n        },\n        {\n            \"H\": 64, \"P\": 32, \"ops\": [\n                (\"alloc\", 1, 32), (\"alloc\", 2, 16), (\"alloc\", 3, 8), (\"free\", 1),\n                (\"alloc\", 4, 4), (\"alloc\", 5, 4), (\"alloc\", 6, 8), (\"free\", 6)\n            ]\n        },\n        {\n            \"H\": 40, \"P\": 20, \"ops\": [\n                (\"alloc\", 1, 10), (\"alloc\", 2, 10), (\"alloc\", 3, 10), (\"alloc\", 4, 10),\n                (\"free\", 1), (\"alloc\", 5, 5), (\"alloc\", 6, 5), (\"free\", 2),\n                (\"alloc\", 7, 4), (\"free\", 6)\n            ]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        allocator = NextFitAllocator(case[\"H\"])\n        for op in case[\"ops\"]:\n            if op[0] == \"alloc\":\n                allocator.allocate(req_id=op[1], req_size=op[2])\n            elif op[0] == \"free\":\n                allocator.free(req_id=op[1])\n        \n        result = allocator.calculate_fragmentation(case[\"P\"])\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3239067"}, {"introduction": "现在，让我们超越简单的顺序适配策略，挑战一个更高级的内存分配器：伙伴系统（buddy system）。这种方法采用分离式空闲链表，根据大小（通常是$2$的幂）来组织空闲块，并通过块的分裂与合并来高效管理内存。实现伙伴系统[@problem_id:3239041]是理解现代内存管理的关键一步，它将揭示结构化的块大小管理如何能够有效控制碎片，并为内存的申请和释放提供可预测的性能。", "problem": "你需要实现一个分离式适配堆分配器，该分配器为2的幂次大小的对象使用独立的空闲链表。该分配器在固定大小的页上运行，并使用伙伴系统的分裂与合并原则。分配器必须支持在模拟堆中分配和释放对象，并按大小类维护分离的空闲链表。所有大小都以字节为单位，除非明确说明是句柄，否则所有报告的数量都必须以字节为单位。\n\n基本和核心定义：\n- 内存被建模为一个离散的地址空间，分割成大小为 $2^{12}$ 字节的页。每个页由一个整数页索引标识，并具有在 $\\{0, 1, 2, \\dots, 2^{12}-1\\}$ 范围内的字节偏移量。\n- 分配器为大小类 $C = \\{2^4, 2^5, \\dots, 2^{12}\\}$ 字节维护不相交的空闲链表。每个用于类 $s \\in C$ 的空闲链表包含大小恰好为 $s$ 字节的空闲块。\n- 请求的大小会向上取整到不小于 $2^4$ 的最接近的2的幂，即给定请求大小 $n$，分配器计算 $r = 2^{\\lceil \\log_2(\\max(n, 2^4)) \\rceil}$ 并确保 $r \\le 2^{12}$。对于 $n \\le 0$ 或 $n > 2^{12}$ 的请求 $n$ 必须失败。\n- 分配使用带分裂的分离式适配策略：如果存在大小为 $r$ 的空闲块，则分配它。如果没有，则选择存在可用空闲块的最小大小 $S \\in C$（其中 $S \\ge r$）；将其反复对半分裂，直到产生一个大小为 $r$ 的块。具体来说，在偏移量 $o$ 处分裂一个大小为 $S$ 的块，会产生两个伙伴块，分别位于偏移量 $o$ 和 $o + S/2$ 处，每个大小为 $S/2$。将未使用的另一半重新插入其对应的空闲链表。\n- 释放使用伙伴合并策略：给定一个在偏移量 $o$ 处、大小为 $s$ 的块，其伙伴位于偏移量 $b = o \\oplus s$ (按位异或)。如果其伙伴存在且在同一页内是空闲的，则将两者都从其空闲链表中移除，并将它们合并成一个大小为 $2s$ 的块，新块位于偏移量 $o' = o \\wedge \\neg s$ (按位与 $s$ 的取反)。然后向上重复此过程，直到不存在空闲的伙伴或达到页大小 $2^{12}$。\n- 句柄：对于在页索引 $p$ 和偏移量 $o$ 处分配的块，分配器返回一个句柄 $h = p \\cdot 2^{12} + o$。这在模拟堆中唯一地标识了该分配。分配失败时返回哨兵值 $-1$。\n- 操作：实现函数 $\\mathrm{alloc}(n)$ 和 $\\mathrm{free}(h)$。函数 $\\mathrm{alloc}(n)$ 返回一个句柄 $h$ 或 $-1$。函数 $\\mathrm{free}(h)$ 返回一个布尔值表示成功 (true) 或失败 (false)，其中失败情况包括无效句柄、重复释放或不存在的页引用。\n\n科学真实性和约束条件：\n- 分配器开始时没有任何页。当需要满足分配请求时，它必须创建一个新页（大小为 $2^{12}$ 字节）。每个新创建的页都会向最大的空闲链表提供一个大小为 $2^{12}$ 字节的空闲块。\n- 分配器单次请求分配的内存绝不能超过 $2^{12}$ 字节；没有用于多块连续分配的机制。\n- 必须保持空闲链表不变量：每个空闲块都只属于其大小类的一个空闲链表，且任何块都不会出现在多个链表中。\n\n测试套件：\n对于每个测试用例，应用指定的操作并计算所需的输出。所有大小均以字节为单位。必须实现以下测试用例：\n\n- 测试用例 1 (正常路径，向大小类取整):\n  - 操作: $\\mathrm{alloc}(20)$, $\\mathrm{alloc}(30)$, $\\mathrm{alloc}(100)$, $\\mathrm{alloc}(2000)$。\n  - 输出: 每个请求的实际分配类大小列表，即每次分配所分配块的大小（以字节为单位）。预期大小遵循向上取整到不小于 $2^4$ 的2的幂的规则。\n\n- 测试用例 2 (分裂并完全合并回一个整页):\n  - 操作: $\\mathrm{alloc}(1000)$, $\\mathrm{alloc}(1000)$，然后 $\\mathrm{free}$ 第一个句柄，再 $\\mathrm{free}$ 第二个句柄。\n  - 输出: 分配器中剩余的大小为 $2^{12}$ 的空闲块的整数数量。如果伙伴合并正确，这将导致所用页产生一个大小为 $2^{12}$ 字节的空闲块。\n\n- 测试用例 3 (超出最大类的分配失败):\n  - 操作: $\\mathrm{alloc}(5000)$。\n  - 输出: 一个布尔值，指示分配是否失败 (因为 $5000 > 2^{12}$，所以失败为 true)。\n\n- 测试用例 4 (大量小块分配下的多页创建):\n  - 操作: 执行 $260$ 次 $\\mathrm{alloc}(16)$ 分配。\n  - 输出: 分配器创建的页数的整数值。由于每个大小为 $2^{12}$ 的页可以分裂成 $2^{12} / 2^4 = 256$ 个 16 字节的块，因此 260 次分配会强制创建 2 个页。\n\n- 测试用例 5 (重复释放检测):\n  - 操作: $h \\leftarrow \\mathrm{alloc}(32)$，然后 $\\mathrm{free}(h)$，再 $\\mathrm{free}(h)$ 一次。\n  - 输出: 一个布尔值，指示第二次 $\\mathrm{free}$ 是否失败 (失败为 true)。\n\n- 测试用例 6 (无效句柄释放检测):\n  - 操作: 在一个全新的分配器上执行 $\\mathrm{free}(123456)$。\n  - 输出: 一个布尔值，指示 $\\mathrm{free}$ 是否失败 (失败为 true)。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个条目按顺序对应一个测试用例的结果：$[\\text{result}_1, \\text{result}_2, \\dots, \\text{result}_6]$。如上所述，条目可以是整数、布尔值或整数列表。该行前后不得有任何多余的文本。", "solution": "问题陈述已经过验证并被认为是有效的。它在科学上基于内存管理算法的原理，特别是伙伴系统。该问题定义明确，所有必要的常数、算法和边界条件都已清晰定义。它是客观的，并提供了一套可形式化和可验证的测试用例。\n\n任务是实现一个基于伙伴系统的分离式适配堆分配器。内存以大小为 $2^{12}$ 字节的页进行管理。分配请求的大小会向上取整到最接近的2的幂，范围从最小 $2^4$ 字节到最大 $2^{12}$ 字节。分配器的核心依赖于两个基本操作：分裂较大的块以满足较小的请求，以及合并相邻的空闲“伙伴”块以形成更大的块，从而减轻外部碎片。\n\n将采用基于类的设计来封装分配器的状态和逻辑。\n\n**1. 数据结构**\n\n分配器的状态由三个主要数据结构管理：\n\n- **空闲链表 (`free_lists`)**：分配器使用分离式适配策略，这要求为每个大小类设置单独的空闲块列表。大小类是2的幂，即 $C = \\{2^4, 2^5, \\dots, 2^{12}\\}$。使用字典是实现这一点的自然选择，它将每个大小 $s \\in C$ 映射到该大小的空闲块句柄集合。为了确保在合并过程中能高效地查找伙伴，每个大小类的句柄集合将是一个集合（set），为插入、删除和成员资格测试提供平均 $O(1)$ 的时间复杂度。块由其句柄标识，句柄是一个整数，计算方式为 $h = p \\cdot 2^{12} + o$，其中 $p$ 是页索引，$o$ 是页内字节偏移量。\n\n- **已分配块 (`allocated_blocks`)**：需要一个独立的字典来跟踪当前已分配的块。此结构将已分配块的句柄 $h$ 映射到其大小 $s$。这对于 `free(h)` 操作至关重要，该操作需要知道被释放块的大小才能找到其伙伴。该字典还用作验证句柄和检测重复释放（即释放一个已经空闲的块）的权威记录。\n\n- **页管理 (`next_page_idx`)**：分配器开始时没有内存页。页是按需创建的。一个简单的整数计数器 `next_page_idx` 跟踪已创建的页数，下一个新页的索引将是 `next_page_idx`。当创建新页时，`next_page_idx` 会递增，并且一个大小为 $2^{12}$ 的空闲块会被添加到相应的空闲链表中。\n\n**2. 算法设计：分配 `alloc(n)`**\n\n分配过程遵循一系列明确定义的步骤：\n\n- **请求验证和大小调整**：首先验证一个传入的 $n$ 字节请求。$n \\le 0$ 或 $n > 2^{12}$ 的请求是无效的，会立即失败。对于有效请求，大小会向上取整到不小于 $2^4$ 的最接近的2的幂 $r$。这通过公式 $r = 2^{\\lceil \\log_2(\\max(n, 2^4)) \\rceil}$ 计算。可以使用 `numpy.log2` 和 `numpy.ceil` 高效地实现这一点。\n\n- **块搜索**：分配器在其 `free_lists` 中搜索可用的块。它首先检查大小恰好为所需大小 $r$ 的空闲链表。如果该列表不为空，则从中取出一个块。如果没有，则继续搜索下一个更大的大小类（$2r, 4r, \\dots, 2^{12}$），直到找到一个非空的空闲链表。\n\n- **页供应**：如果搜索未能找到足够大的空闲块来满足请求（即，所有空闲链表都为空，或只包含小于 $r$ 的块），分配器必须提供一个新页。创建一个大小为 $2^{12}$ 的新页，其对应的块句柄（在页 `next_page_idx`，偏移量为 `0`）被添加到大小为 $2^{12}$ 的空闲链表中。然后重新开始搜索要分裂的块，此时由于有了这个新的整页块，搜索保证会成功。\n\n- **分裂**：一旦找到一个大小为 $S \\ge r$ 的块并从其空闲链表中移除，如果 $S > r$，则递归地分裂它。在偏移量 $o$ 处分裂一个大小为 $S$ 的块会产生两个大小为 $S/2$ 的伙伴块：一个在偏移量 $o$ 处，其伙伴在偏移量 $o + S/2$ 处。伙伴块立即被添加到大小为 $S/2$ 的空闲链表中。第一个块（在偏移量 $o$ 处）被保留，并重复此过程，将其大小减半，直到获得所需大小 $r$ 的块。然后该块被分配。\n\n- **最终处理**：最终大小为 $r$ 的块的句柄及其大小被记录在 `allocated_blocks` 映射中，并将句柄返回给调用者。分配失败时返回 $-1$。\n\n**3. 算法设计：释放 `free(h)`**\n\n释放通过合并来逆转分配过程：\n\n- **句柄验证**：第一个也是最关键的步骤是验证句柄 $h$。函数检查 $h$ 是否作为键存在于 `allocated_blocks` 映射中。如果不存在，则该句柄无效（它从未被分配，或者已经被释放）。在这种情况下，操作失败并返回 `false`。\n\n- **伙伴识别与合并**：如果句柄有效，则检索其大小 $s$。该块从 `allocated_blocks` 映射中移除。核心合并循环开始。对于页 $p$ 内偏移量为 $o$、大小为 $s$ 的块，其唯一的相同大小的伙伴位于同一页的偏移量 $o \\oplus s$ 处。分配器检查其伙伴的句柄是否存在于大小为 $s$ 的空闲链表中。\n  - 如果伙伴是空闲的，则将其从其空闲链表中移除。这两个块合并成一个大小为 $2s$ 的单个块。这个新的父块的偏移量由 $o' = o \\wedge \\neg s$ 给出，这有效地清除了对应于大小 $s$ 的位，从而得到对齐的 $2s$ 大小块的基地址。然后对这个新的、更大的块重复合并过程。\n  - 如果伙伴不是空闲的（即已被分配），则合并停止。\n\n- **最终处理**：当发现伙伴已被分配或块大小达到页大小 $2^{12}$ 时，循环终止。最终产生的块（可能是原始块或一个更大的、合并后的块）被添加到适当的空闲链表中。函数返回 `true` 表示成功。这种系统性的合并是伙伴系统通过主动重建更大的空闲块来对抗外部碎片的机制。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass BuddyAllocator:\n    \"\"\"\n    Implements a segregated-fit heap allocator with a buddy system for splitting and coalescing.\n    \"\"\"\n    def __init__(self):\n        \"\"\"Initializes the allocator with no pages.\"\"\"\n        self.PAGE_SIZE = 2**12\n        self.MIN_ALLOC_SIZE = 2**4\n        self.MAX_ALLOC_SIZE = self.PAGE_SIZE\n\n        # Size classes are powers of two from MIN_ALLOC_SIZE to MAX_ALLOC_SIZE.\n        self.size_classes = [2**i for i in range(int(np.log2(self.MIN_ALLOC_SIZE)), int(np.log2(self.MAX_ALLOC_SIZE)) + 1)]\n\n        # Free lists: a dictionary mapping size class to a set of handles of free blocks.\n        self.free_lists = {s: set() for s in self.size_classes}\n\n        # Allocated blocks: a dictionary mapping handle to its size.\n        self.allocated_blocks = {}\n\n        # Page management.\n        self.next_page_idx = 0\n\n    def _get_handle(self, page_idx, offset):\n        \"\"\"Computes a handle from a page index and offset.\"\"\"\n        return page_idx * self.PAGE_SIZE + offset\n\n    def _parse_handle(self, handle):\n        \"\"\"Decomposes a handle into its page index and offset.\"\"\"\n        page_idx = handle // self.PAGE_SIZE\n        offset = handle % self.PAGE_SIZE\n        return page_idx, offset\n\n    def _calculate_rounded_size(self, n):\n        \"\"\"Rounds up a request size to the nearest valid power of two.\"\"\"\n        if not (0 < n <= self.MAX_ALLOC_SIZE):\n            return None\n        \n        req_size = max(n, self.MIN_ALLOC_SIZE)\n        \n        # Use numpy for direct implementation of the formula: 2^ceil(log2(size))\n        power = np.ceil(np.log2(req_size))\n        return 2**int(power)\n\n    def alloc(self, n):\n        \"\"\"Allocates a block of memory of size n.\"\"\"\n        rounded_size = self._calculate_rounded_size(n)\n        if rounded_size is None:\n            return -1\n\n        target_size = rounded_size\n        \n        # Find the smallest available block size that fits the request.\n        alloc_size = -1\n        for s in self.size_classes:\n            if s >= target_size and len(self.free_lists[s]) > 0:\n                alloc_size = s\n                break\n        \n        # If no block is available, create a new page.\n        if alloc_size == -1:\n            page_idx = self.next_page_idx\n            self.next_page_idx += 1\n            \n            new_block_handle = self._get_handle(page_idx, 0)\n            self.free_lists[self.MAX_ALLOC_SIZE].add(new_block_handle)\n            alloc_size = self.MAX_ALLOC_SIZE\n        \n        # Get a block from the selected free list.\n        block_handle = self.free_lists[alloc_size].pop()\n        current_page, current_offset = self._parse_handle(block_handle)\n        \n        # Split the block down to the required size.\n        current_size = alloc_size\n        while current_size > target_size:\n            current_size //= 2\n            buddy_offset = current_offset + current_size\n            buddy_handle = self._get_handle(current_page, buddy_offset)\n            self.free_lists[current_size].add(buddy_handle)\n            \n        # Allocate the final block.\n        final_handle = self._get_handle(current_page, current_offset)\n        self.allocated_blocks[final_handle] = target_size\n        return final_handle\n\n    def free(self, handle):\n        \"\"\"Frees a previously allocated block of memory.\"\"\"\n        # 1. Validate handle against the map of allocated blocks.\n        if handle not in self.allocated_blocks:\n            return False\n            \n        page_idx, offset = self._parse_handle(handle)\n        if page_idx >= self.next_page_idx:\n            return False\n\n        # 2. Retrieve size and remove from allocated map.\n        size = self.allocated_blocks.pop(handle)\n        \n        current_page = page_idx\n        current_offset = offset\n        current_size = size\n\n        # 3. Coalesce with buddy if buddy is free.\n        while current_size < self.MAX_ALLOC_SIZE:\n            buddy_offset = current_offset ^ current_size\n            buddy_handle = self._get_handle(current_page, buddy_offset)\n            \n            if buddy_handle in self.free_lists[current_size]:\n                self.free_lists[current_size].remove(buddy_handle)\n                current_offset = current_offset  (~current_size)\n                current_size *= 2\n            else:\n                break\n        \n        # 4. Add the final (possibly coalesced) block to the free list.\n        final_handle = self._get_handle(current_page, current_offset)\n        self.free_lists[current_size].add(final_handle)\n        \n        return True\n\ndef run_test_case_1():\n    allocator = BuddyAllocator()\n    requests = [20, 30, 100, 2000]\n    allocated_sizes = []\n    for req in requests:\n        handle = allocator.alloc(req)\n        if handle != -1:\n            allocated_sizes.append(allocator.allocated_blocks[handle])\n    return allocated_sizes\n\ndef run_test_case_2():\n    allocator = BuddyAllocator()\n    h1 = allocator.alloc(1000)\n    h2 = allocator.alloc(1000)\n    allocator.free(h1)\n    allocator.free(h2)\n    return len(allocator.free_lists[allocator.MAX_ALLOC_SIZE])\n\ndef run_test_case_3():\n    allocator = BuddyAllocator()\n    handle = allocator.alloc(5000)\n    return handle == -1\n\ndef run_test_case_4():\n    allocator = BuddyAllocator()\n    for _ in range(260):\n        allocator.alloc(16)\n    return allocator.next_page_idx\n\ndef run_test_case_5():\n    allocator = BuddyAllocator()\n    h = allocator.alloc(32)\n    allocator.free(h)\n    second_free_success = allocator.free(h)\n    return not second_free_success\n\ndef run_test_case_6():\n    allocator = BuddyAllocator()\n    free_success = allocator.free(123456)\n    return not free_success\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        run_test_case_1,\n        run_test_case_2,\n        run_test_case_3,\n        run_test_case_4,\n        run_test_case_5,\n        run_test_case_6,\n    ]\n\n    results = [test() for test in test_cases]\n\n    # The problem asks for the standard string representation of Python objects.\n    # str([1, 2]) -> '[1, 2]' (with space)\n    # str(True) -> 'True' (capitalized)\n    # The default behavior of map(str,...) is the most faithful interpretation.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3239041"}]}