{"hands_on_practices": [{"introduction": "抽象数据类型（ADT）的核心原则是将“做什么”（接口与行为）与“如何做”（实现）清晰地分离开来。本练习将通过为一个具有固定容量和覆写特性的 `RingBuffer`（循环缓冲区）创建一个纯粹的ADT规范，来实践这一重要思想。我们将使用序列等抽象数学概念来精确描述其行为，从而加深对数据结构抽象思维的理解，并学会区分抽象定义与具体的实现细节 [@problem_id:3202558]。", "problem": "一个抽象数据类型由一个状态集 $S$、一个具有精确定义域和上域的操作集 $Ops$ 以及约束这些操作如何转换状态和产生结果的公理来定义。对于一个标准的先进先出队列 (Queue)，其状态是元素集 $E$ 上的一个序列（其中 $E$ 是固定的但其他方面是任意的），诸如 $enqueue$、$dequeue$ 和 $front$ 等操作在该序列上定义，并通过公理来强制执行先进先出的原则。一个纯粹的抽象数据类型规范必须只涉及数学对象，如集合、序列以及全函数或偏函数，并且绝不能限定于实现细节，如数组、指针、索引或模运算。\n\n考虑将一个 RingBuffer (循环队列) 定义为一个具有写满时覆盖语义的纯粹的抽象数据类型。其容量在创建时固定，之后不再改变。其意图是，当缓冲区满时发生 $enqueue$ 操作，最旧的元素将被丢弃以便为新元素腾出空间；所有其他行为（如 $dequeue$ 和 $front$）必须保留剩余元素的先进先出顺序。相比之下，一个标准的 Queue 抽象数据类型在概念上是无界的，从不覆盖元素；当一个 Queue 用有限容器实现时，这种有限性是一个实现上的约束，而不是该抽象数据类型公理的一部分。\n\n哪个选项最正确地给出了一个具有写满时覆盖语义的 RingBuffer 的纯粹抽象数据类型规范，并将其公理与标准 Queue 抽象数据类型的公理进行了明确对比，且没有涉及表示细节？\n\nA. 状态是序列 $s \\in E^{\\le k}$，其中 $k \\in \\mathbb{N}$ 在创建时固定且 $|s| \\le k$。操作是偏函数：\n- $empty(s)$ 当且仅当 $|s| = 0$ 时返回 $\\mathsf{true}$；$full(s)$ 当且仅当 $|s| = k$ 时返回 $\\mathsf{true}$；$size(s) = |s|$；$capacity(s) = k$。\n- $enqueue(s, x)$ 返回一个新状态 $s'$，定义如下：如果 $|s|  k$，则 $s' = s \\cdot x$；否则 $s' = drop\\_1(s) \\cdot x$，其中 $drop\\_1(s)$ 移除 $s$ 的第一个（最旧的）元素，$\\cdot$ 表示序列连接。\n- $dequeue(s)$ 仅在 $|s|  0$ 时有定义，并返回一个对 $(y, s')$，其中 $y$ 等于 $s$ 的第一个元素，$s'$ 等于 $drop\\_1(s)$；$front(s)$ 仅在 $|s|  0$ 时有定义，并返回第一个元素。\n公理强制要求在 $enqueue$ 和 $dequeue$ 操作下序列顺序得以保留，$capacity(s)$ 是一个等于 $k$ 的不变量，并且 $enqueue$ 操作永远不会使 $|s|$ 超过 $k$。相比之下，一个标准的 Queue 的状态为 $s \\in E^{*}$（对 $|s|$ 没有限制），$full(s)$ 总是 $\\mathsf{false}$，且 $enqueue(s, x)$ 总是产生 $s' = s \\cdot x$（从不覆盖）。\n\nB. 状态由数组索引 $head, tail \\in \\mathbb{Z}$ 和一个固定数组 $A[0..k-1]$ 给出。$enqueue$ 操作将 $x$ 写入 $A[tail]$，然后设置 $tail := (tail + 1) \\bmod k$，如果 $tail = head$ 则设置 $head := (head + 1) \\bmod k$。$dequeue$ 操作读取 $A[head]$ 并设置 $head := (head + 1) \\bmod k$。这与 Queue 的不同之处在于它在索引上使用了模运算，但其他方面是相同的。\n\nC. 状态是序列 $s \\in E^{*}$，带有一个可变的容量函数 $capacity(s)$，它可以在需要时增长。$enqueue(s, x)$ 操作总是返回 $s' = s \\cdot x$，并且如果 $|s| = capacity(s)$，则 $capacity(s') := capacity(s) + 1$。这与 Queue 的不同之处在于它跟踪一个可自动调整大小的容量。\n\nD. 状态是序列 $s \\in E^{\\le k}$，但是当 $|s| = k$ 时，$enqueue(s, x)$ 返回一个错误而不修改 $s$，而对 $|s| = 0$ 的 $dequeue(s)$ 返回一个特殊值 $\\bot \\in E$。这与 Queue 的不同之处在于它有容量并在满时返回错误，但除此之外，公理是相同的。\n\nE. 状态是最多包含 $k$ 个元素的集合 $S \\subseteq E$。当 $|S| = k$ 时，$enqueue(S, x)$ 操作从 $S$ 中移除一个任意元素并插入 $x$。$dequeue(S)$ 操作返回 $S$ 中的任何元素。这与 Queue 的不同之处在于它限制了基数，但通过完全避免使用序列来保持其抽象性质。", "solution": "问题要求为具有固定容量和写满时覆盖语义的 RingBuffer (或循环队列) 构建一个纯粹的抽象数据类型 (ADT) 的规范。纯粹的 ADT 必须使用抽象的数学概念（如集合和序列）来定义，并且必须不包含任何实现细节，如数组、索引或指针。该规范还必须与标准的、无界 Queue ADT 的规范进行对比。\n\n首先，让我们为一个基于序列的数据结构建立纯粹 ADT 规范的核心原则。\n- **状态空间**：ADT 的状态由一个数学对象表示。对于一个有序集合，序列是自然的选择。一个标准的、无界的队列的状态空间是 $s \\in E^*$，其中 $E$ 是元素集，$E^*$ 是 $E$ 上所有有限序列的集合。对于一个容量为 $k$ 的固定容量 RingBuffer，其状态必须是一个长度 $|s|$ 不超过 $k$ 的序列 $s$。因此，状态空间是 $E^{\\le k} = \\{s \\in E^* | |s| \\le k \\}$。\n- **操作**：操作被定义为状态空间上的数学函数。它们将一个状态（可能还有其他参数）映射到一个新状态和/或一个结果值。\n- **公理**：这些是描述操作行为的形式化规则。例如，它们定义了 $enqueue$ 和 $dequeue$ 如何相互作用以强制执行先进先出 (FIFO) 原则。\n\n现在，让我们来为具有固定容量 $k \\in \\mathbb{N}$ 和写满时覆盖语义的 RingBuffer 定义所需的 ADT。\n- 设状态为一个序列 $s \\in E^{\\le k}$。队列的头部（最旧的元素）是序列的第一个元素，尾部（最新的元素）是最后一个元素。\n- 操作 $enqueue(s, x)$ 必须处理两种情况：\n    1. 如果缓冲区未满，即 $|s|  k$，新元素 $x$ 被附加到序列末尾。新状态为 $s' = s \\cdot x$，其中 $\\cdot$ 表示序列连接。\n    2. 如果缓冲区已满，即 $|s| = k$，必须移除最旧的元素以腾出空间。最旧的元素是序列中的第一个元素。设 $drop\\_1(s)$ 是返回移除了第一个元素的序列 $s$ 的操作。然后将新元素 $x$ 附加到末尾。新状态为 $s' = drop\\_1(s) \\cdot x$。\n- 操作 $dequeue(s)$ 是一个偏函数，仅当缓冲区不为空 ($|s|  0$) 时有定义。它必须返回最旧的元素（序列的第一个元素）和新状态，即移除了第一个元素的序列。因此，$dequeue(s)$ 返回一个对 $(y, s')$，其中 $y$ 是 $s$ 的第一个元素，$s'$ 是 $drop\\_1(s)$。\n- 操作 $front(s)$ 也是一个偏函数，为 $|s|  0$ 定义。它返回最旧的元素（序列的第一个元素），而不修改状态。\n- 辅助操作如 $size(s)=|s|$、$capacity(s)=k$、$empty(s) \\iff |s|=0$ 和 $full(s) \\iff |s|=k$ 完善了该规范。\n\n这个规范是纯粹的，因为它完全依赖于序列的数学理论。它与标准的 Queue ADT 形成对比，后者的状态空间是 $E^*$（无界的），$full(s)$ 永不为真，且 $enqueue$ 的公理总是 $enqueue(s, x) \\rightarrow s \\cdot x$，没有覆盖的情况。\n\n现在，我们根据这个形式化的推导来评估每个选项。\n\n**选项 A**\n- **状态**：定义为序列 $s \\in E^{\\le k}$，具有固定容量 $k$。这正确地为一个固定容量的结构建模。\n- **操作**：\n    - 基于序列长度 $|s|$ 的 $empty(s)$、$full(s)$、$size(s)$ 和 $capacity(s)$ 的定义是正确的。\n    - $enqueue(s, x)$ 的定义正确地区分了未满情况（$|s|  k$），此时返回 $s \\cdot x$，和已满情况，此时返回 $drop\\_1(s) \\cdot x$。这使用抽象的序列操作精确地捕捉了写满时覆盖的语义。\n    - $dequeue(s)$ 和 $front(s)$ 的定义正确地将序列的第一个元素确定为要返回/移除的元素，从而保留了 FIFO 原则。\n- **纯粹性**：该规范只使用了序列、序列长度、连接以及按位置（第一个）访问/移除元素。它避免了如数组、索引和模运算等实现细节。这是一个纯粹的 ADT 规范。\n- **与 Queue 的对比**：对比是准确的。一个标准的 Queue 的状态为 $s \\in E^*$，永不为满，其 $enqueue$ 操作更简单，从不覆盖。\n- **结论**：**正确**。该选项为所描述的 RingBuffer 提供了一个完美的纯粹 ADT 规范。\n\n**选项 B**\n- **状态**：使用一个数组 $A[0..k-1]$ 和整数索引 $head$ 和 $tail$ 来定义。\n- **操作**：使用数组访问和对索引的模运算来定义，例如 $tail := (tail + 1) \\bmod k$。\n- **纯粹性**：这直接违反了对纯粹 ADT 规范的要求。它描述的是 RingBuffer 的一种常见**实现**，而不是其抽象类型。问题明确禁止提及“数组、指针、索引或模运算”。\n- **结论**：**不正确**。\n\n**选项 C**\n- **状态**：定义为序列 $s \\in E^*$，这意味着概念上大小是无界的。它引入了一个“可变的容量函数”。\n- **操作**：$enqueue$ 操作总是附加元素，如果达到容量，容量本身会增长。\n- **行为**：这描述的是一个动态调整大小的队列，而不是一个具有**固定容量**和**覆盖**语义的 RingBuffer。所指定的行为与要求根本不同。\n- **结论**：**不正确**。\n\n**选项 D**\n- **状态**：定义为序列 $s \\in E^{\\le k}$，这是一个正确的起点。\n- **操作**：当 $|s|=k$ 时，$enqueue(s, x)$ 操作“返回一个错误而不修改 $s$”。\n- **行为**：这描述的是一个**有界队列**，它在满时会发出错误信号或阻塞。它没有实现指定的“写满时覆盖”语义，即丢弃最旧的元素为新元素腾出空间。\n- **结论**：**不正确**。\n\n**选项 E**\n- **状态**：定义为集合 $S \\subseteq E$。集合是不同元素的无序集合。\n- **行为**：使用集合作为状态从根本上破坏了 FIFO 原则。顺序对于队列至关重要。操作证实了这一缺陷：满时的 $enqueue$ 移除一个“任意”元素，而 $dequeue$ 返回“任何”元素。这不是一个队列。\n- **结论**：**不正确**。\n\n基于以上分析，选项 A 是唯一一个为具有写满时覆盖语义的 RingBuffer 提供了正确且纯粹的 ADT 规范的选项，与问题陈述的所有要求一致。", "answer": "$$\\boxed{A}$$", "id": "3202558"}, {"introduction": "在现实世界的应用中，我们常常需要将简单的ADT组合起来，构建出功能更强大的ADT。本练习将挑战我们使用两个堆（heap）来设计一个 `OnlineMedian`（在线中位数）ADT，这是一个解决流数据中位数查询问题的经典而优雅的方案。这个过程将引导我们思考关键的实现细节，例如如何维护数据结构不变量，以及如何高效地处理删除操作，从而满足严格的 $O(\\log n)$ 时间复杂度要求 [@problem_id:3202610]。", "problem": "考虑设计一个用于在线中位数服务的抽象数据类型 (ADT)，该服务存储一个可比较键的多重集并支持流式更新。该 ADT 命名为 OnlineMedian，必须支持以下具有明确定义语义的操作：插入一个键 $\\;x\\;$ 作为 $\\;\\mathrm{insert}(x)$，如果键 $\\;x\\;$ 存在则删除其一次出现作为 $\\;\\mathrm{delete}(x)$，查询当前中位数作为 $\\;\\mathrm{median}()\\;$，报告当前大小作为 $\\;\\mathrm{size}()\\;$，以及测试是否为空作为 $\\;\\mathrm{isEmpty}()\\;$。中位数必须确定性地定义为下中位数：对于一个大小为 $\\;n\\;$ 的多重集，如果 $\\;n\\;$ 是奇数，$\\;\\mathrm{median}()\\;$ 返回排序后的唯一中间元素；如果 $\\;n\\;$ 是偶数，它返回排序后排名为 $\\;\\lfloor n/2 \\rfloor\\;$ 的元素，也就是下半部分的最大值。ADT 必须维持一个不变式，即 $\\;\\mathrm{median}()\\;$ 返回存储的键之一（而不是一个平均值）。实现约束是 OnlineMedian 必须恰好使用两个堆来实现：一个最大二叉堆（优先队列）$\\;H_{\\mathrm{low}}\\;$ 存储下半部分，一个最小二叉堆 $\\;H_{\\mathrm{high}}\\;$ 存储上半部分。目标是在任意的 $\\;\\mathrm{insert}\\;$ 和 $\\;\\mathrm{delete}\\;$ 操作流下保持正确性，并使每个操作的时间复杂度保持在 $\\;O(\\log n)\\;$，其中 $\\;n\\;$ 是当前大小，这包括更新后任何必要的再平衡。此外，设计必须在删除和再平衡操作下保持稳定，即所选的中位数仅在集合更新和堆分区边界逻辑上强制其改变时才改变，而不是由于实现上的偶然因素；具体来说，对等于中位数的键的重复插入和删除不能导致 $\\;\\mathrm{median}()\\;$ 的不确定性振荡。\n\n从基本定义和经过充分检验的事实出发：\n- 二叉堆是一个具有堆序性质的完全二叉树；最大二叉堆的根节点总是最大键，最小二叉堆的根节点总是最小键。\n- 标准的堆操作（插入、提取根节点、适用时的增加/减少键）在堆大小为 $\\;m\\;$ 时运行时间为 $\\;O(\\log m)\\;$，因为完全二叉树的高度是 $\\;O(\\log m)\\;$。\n- 由二叉堆实现的优先队列支持在 $\\;O(1)\\;$ 时间内访问根节点，在 $\\;O(\\log m)\\;$ 时间内进行更新。\n\n下面的哪个选项给出了一个正确的 ADT 规范，连同不变式、删除策略和再平衡规则，这些都足以确保 $\\;\\mathrm{median}()\\;$ 的正确性以及在删除和再平衡下的稳定性，同时将每个操作的时间复杂度保持在 $\\;O(\\log n)\\;$？\n\nA. 维护两个堆，其不变式为：$\\;|H_{\\mathrm{low}}| \\in \\{|H_{\\mathrm{high}}|, |H_{\\mathrm{high}}|+1\\}\\;$ 且 $\\;H_{\\mathrm{low}}\\;$ 中的每个键都 $\\;\\le\\;$ $\\;H_{\\mathrm{high}}\\;$ 中的每个键。对于所有 $\\;n \\ge 1\\;$，定义 $\\;\\mathrm{median}()\\;$ 为 $\\;H_{\\mathrm{low}}\\;$ 的根节点（下中位数）。实现 $\\;\\mathrm{insert}(x)\\;$ 时，如果 $\\;x \\le \\mathrm{root}(H_{\\mathrm{low}})\\;$（或者如果 $\\;H_{\\mathrm{low}}\\;$ 为空），则将 $\\;x\\;$ 插入 $\\;H_{\\mathrm{low}}\\;$，否则插入 $\\;H_{\\mathrm{high}}\\;$。插入后，如果 $\\;|H_{\\mathrm{low}}| = |H_{\\mathrm{high}}|+2\\;$，将 $\\;\\mathrm{root}(H_{\\mathrm{low}})\\;$ 移动到 $\\;H_{\\mathrm{high}}\\;$；如果 $\\;|H_{\\mathrm{high}}| = |H_{\\mathrm{low}}|+1\\;$，将 $\\;\\mathrm{root}(H_{\\mathrm{high}})\\;$ 移动到 $\\;H_{\\mathrm{low}}\\;$。通过哈希表中的按值计数器实现 $\\;\\mathrm{delete}(x)\\;$ 的惰性删除：在删除时递减 $\\;x\\;$ 的计数器，并在访问 $\\;\\mathrm{root}(H_{\\mathrm{low}})\\;$ 或 $\\;\\mathrm{root}(H_{\\mathrm{high}})\\;$ 时，重复弹出其计数器指示没有活动实例的过期根节点。删除后使用相同的大小规则进行再平衡。论证在维护的分区下 $\\;\\mathrm{median}()\\;$ 是正确的，并且每个 $\\;\\mathrm{insert}\\;$ 和 $\\;\\mathrm{delete}\\;$ 执行常数数量的堆操作，每个操作为 $\\;O(\\log n)\\;$，外加 $\\;O(1)\\;$ 的哈希表更新，并且修剪过期根节点在每次更新中的均摊成本为 $\\;O(1)\\;$。\n\nB. 维护两个堆，其不变式为 $\\;H_{\\mathrm{low}}\\;$ 中的每个键都 $\\;\\;$ $\\;H_{\\mathrm{high}}\\;$ 中的每个键，但允许 $\\;|H_{\\mathrm{low}}|-|H_{\\mathrm{high}}|\\;$ 无界增长。无论 $\\;n\\;$ 为何值，都将 $\\;\\mathrm{median}()\\;$ 定义为 $\\;H_{\\mathrm{low}}\\;$ 的根节点，并且从不进行大小再平衡，因为堆访问是 $\\;O(1)\\;$ 且堆插入是 $\\;O(\\log n)\\;$。处理 $\\;\\mathrm{delete}(x)\\;$ 的方法是，如果 $\\;x\\;$ 位于某个堆的根节点，则从该堆中删除它；否则什么都不做，直到 $\\;x\\;$ 到达根节点。\n\nC. 维持与选项A中相同的分区，但每当 $\\;|H_{\\mathrm{low}}|-|H_{\\mathrm{high}}| = 1\\;$ 时，通过提取所有元素并重新分区来重建两个堆，以恢复大小的精确相等。当 $\\;n\\;$ 为偶数时，将 $\\;\\mathrm{median}()\\;$ 定义为两个根节点的平均值，当 $\\;n\\;$ 为奇数时，定义为 $\\;\\mathrm{root}(H_{\\mathrm{low}})\\;$。通过线性扫描两个堆来找到 $\\;x\\;$，然后通过上浮或下沉来修复堆，以实现 $\\;\\mathrm{delete}(x)\\;$。\n\nD. 维护两个堆，其大小不变式为 $\\;||H_{\\mathrm{low}}|-|H_{\\mathrm{high}}|| \\le 2\\;$，排序不变式为 $\\;H_{\\mathrm{low}}\\;$ 中的每个键都 $\\;\\le\\;$ $\\;H_{\\mathrm{high}}\\;$ 中的每个键。将 $\\;\\mathrm{median}()\\;$ 定义为较大堆的根节点；当大小相差 $\\;2\\;$ 时，返回较大堆的根节点，并且仅当差异达到 $\\;3\\;$ 时才进行再平衡。通过对支持堆的数组进行线性搜索，从当前包含 $\\;x\\;$ 的堆中移除它，然后重新堆化，以实现 $\\;\\mathrm{delete}(x)\\;$。\n\n选择满足所有要求的唯一最佳选项。", "solution": "### 问题验证\n\n**步骤 1：提取已知条件**\n\n*   **ADT:** `OnlineMedian`，用于一个可比较键的多重集。\n*   **操作:** `insert(x)`, `delete(x)`, `median()`, `size()`, `isEmpty()`。\n*   **大小 `n`:** 多重集中当前键的数量。\n*   **中位数定义:** 确定性地定义为“下中位数”。\n    *   如果 `n` 是奇数，中位数是排序后的唯一中间元素。\n    *   如果 `n` 是偶数，中位数是排序后排名为 `\\lfloor n/2 \\rfloor` 的元素。\n    *   问题陈述也称之为“下半部分的最大值”。\n    *   中位数必须是存储的键，而不是平均值。\n*   **实现约束:** 恰好使用两个二叉堆：\n    *   `H_low`: 一个用于下半部分的最大二叉堆。\n    *   `H_high`: 一个用于上半部分的最小二叉堆。\n*   **性能约束:** 所有操作必须在 `O(\\log n)` 时间内完成。\n*   **稳定性约束:** 中位数应仅在逻辑上必要时才改变，并且不应因为对中位数键的重复插入/删除等实现细节而产生振荡。\n*   **已知事实:** 二叉堆的标准属性，包括更新为 `O(\\log m)` 和根访问为 `O(1)`。\n\n**步骤 2：使用提取的已知条件进行验证**\n\n首先，让我们精确地形式化中位数的定义。设多重集排序为 `$e_1 \\le e_2 \\le \\dots \\le e_n$`。\n*   如果 `n` 是奇数，设 `n = 2k+1`。 “唯一的中间元素”位于排名 `k+1` 的位置。这也是 `\\lceil n/2 \\rceil`。\n*   如果 `n` 是偶数，设 `n = 2k`。问题陈述中位数位于排名 `\\lfloor n/2 \\rfloor = k` 的位置。请注意，标准定义有时使用排名 `k+1`（两个中心元素中较小的一个）。然而，这个问题给出了一个明确的定义。让我们验证一致性。对于 `n=5`，排名是 `3`。对于 `n=6`，排名是 `3`。这对于奇数情况不等于 `\\lfloor n/2 \\rfloor`（`\\lfloor 5/2 \\rfloor = 2`）。让我们遵循问题的分段定义。\n    *   奇数 `n=2k+1`：排名 `k+1`。例如 `n=5`，排名 `3`。\n    *   偶数 `n=2k`：排名 `k`。例如 `n=4`，排名 `2`。\n一个统一该排名的公式是 `\\lceil n/2 \\rceil`。\n    *   对于 `n=2k+1`，`\\lceil (2k+1)/2 \\rceil = \\lceil k+0.5 \\rceil = k+1`。这匹配。\n    *   对于 `n=2k`，`\\lceil (2k)/2 \\rceil = k`。问题说排名是 `\\lfloor n/2 \\rfloor=k`。这也匹配。\n因此，中位数是在1-索引排序的多重集中排名为 `r = \\lceil n/2 \\rceil` 的元素。\n\n问题提出了一种双堆结构来找到这个中位数。这是算法设计中一个标准且被广泛理解的方法。在 `O(\\log n)` 时间内实现 `delete(x)` 的要求是一个不小的扩展，但可以解决，通常使用惰性删除或通过哈希表增强堆。问题定义明确，在计算机科学中有科学依据，并且所有术语都已指定。它不是不完整、矛盾或不适定的。\n\n**步骤 3：结论与行动**\n\n问题陈述是**有效的**。我们可以继续进行解答。\n\n### 基于原则的推导与选项分析\n\n目标是将 `n` 个元素划分为下半部分 `L` 和上半部分 `H`，以便能够高效地找到中位数。中位数是排名为 `\\lceil n/2 \\rceil` 的元素，也就是 `\\lceil n/2 \\rceil` 个最小元素集合中的最大元素。\n\n这自然引出了以下设计：\n1.  `H_low`（一个最大堆）将存储 `\\lceil n/2 \\rceil` 个最小的元素。\n2.  `H_high`（一个最小堆）将存储剩下的 `\\lfloor n/2 \\rfloor` 个最大的元素。\n\n从这个设计中，出现了两个核心不变式：\n*   **分区不变式:** `H_low` 中的每个键必须小于或等于 `H_high` 中的每个键。如果 `max(H_low) \\le min(H_high)`，即 `root(H_low) \\le root(H_high)`，这个不变式就得以维持。\n*   **大小不变式:** 堆的大小必须是 `|H_low| = \\lceil n/2 \\rceil` 和 `|H_high| = \\lfloor n/2 \\rfloor`。这等价于要求 `|H_low| = |H_high|`（当 `n` 为偶数时）或 `|H_low| = |H_high| + 1`（当 `n` 为奇数时）。\n\n有了这些不变式，`median()` 就是下半部分的最大值，即 `root(H_low)`。访问根节点是 `O(1)`。\n\n**操作：**\n*   **`insert(x)`**: 为了维持分区不变式，如果 `x` 小于或等于当前中位数（`root(H_low)`），它必须属于下半部分集合。所以，我们将 `x` 插入到 `H_low`。否则，我们将其插入到 `H_high`。插入后，大小不变式可能会被违反。需要一个再平衡步骤：如果一个堆变得过大，它的根节点被提取并插入到另一个堆中。这涉及常数数量的堆操作，使得 `insert(x)` 成为一个 `O(\\log n)` 操作。\n*   **`delete(x)`**: 在堆中找到任意元素 `x` 需要 `O(n)` 时间，这违反了性能约束。为了达到 `O(\\log n)`，需要一种更复杂的方法。不能简单地用哈希表的指针来增强堆，因为元素在堆操作期间会移动。标准且最稳健的解决方案是**惰性删除**。我们维护一个哈希表来记录元素的计数。一个 `delete(x)` 操作仅在 `O(1)` 时间内递减一个计数器。堆中将包含计数为零的“过期”元素。当这些过期元素到达任一堆的根部，并且在进行中位数查询或再平衡步骤时需要它们时，必须将它们物理删除。这个清理过程（例如，`while count[root(H)] == 0: H.extract_root()`）会增加成本。虽然单个操作可能触发多次这样的删除，但这个成本在每次更新操作中均摊为 `O(\\log n)`，因为每个元素只被插入一次，标记为删除一次，并且最多从堆中物理删除一次。\n\n现在，我们基于这个设计来评估给出的选项。\n\n**A. 维护两个堆，其不变式为：`|H_{\\mathrm{low}}| \\in \\{|H_{\\mathrm{high}}|, |H_{\\mathrm{high}}|+1\\}` 且 `H_{\\mathrm{low}}` 中的每个键都 `\\le` `H_{\\mathrm{high}}` 中的每个键。定义 `median()` 为 `H_{\\mathrm{low}}` 的根节点。……通过哈希表中的按值计数器实现 `delete(x)` 的惰性删除……**\n\n*   **分析:** 这个选项正确地确定了大小不变式 `|H_{\\mathrm{low}}| = \\lceil n/2 \\rceil` 和分区不变式 `max(H_{low}) \\le min(H_{high})`。将 `median()` 定义为 `root(H_{\\mathrm{low}})` 是这些不变式的直接结果。插入逻辑（`x \\le root(H_{\\mathrm{low}})` 指向 `H_{\\mathrm{low}}`）和再平衡规则完全正确。关键是，它提出了使用哈希表进行惰性删除来处理 `delete(x)`，这是实现所需 `O(\\log n)` 均摊时间复杂度的正确方法。当访问根节点时，修剪过期根节点被正确地确定为必要步骤。时间复杂度分析是合理的；每个操作需要常数数量的堆操作和哈希表查找，导致总的均摊时间为 `O(\\log n)`。稳定性也得到了保证，因为等于中位数的元素被确定性地放置在 `H_{\\mathrm{low}}` 中。\n*   **结论:** **正确**。\n\n**B. 维护两个堆，其不变式为 `H_{\\mathrm{low}}` 中的每个键都 `` `H_{\\mathrm{high}}` 中的每个键，但允许 `|H_{\\mathrm{low}}|-|H_{\\mathrm{high}}|$ 无界增长。无论 `n` 为何值，都将 `median()` 定义为 `H_{\\mathrm{low}}` 的根节点，并且从不进行大小再平衡……**\n\n*   **分析:** 这个选项有多个致命缺陷。首先，如果 `|H_{\\mathrm{low}}|-|H_{\\mathrm{high}}|` 是无界的，那么堆就不再代表数据的下半部分和上半部分。`root(H_{\\mathrm{low}})` 将不是中位数。放弃再平衡使得整个双堆中位数查找算法的前提失效。其次，删除策略——“什么都不做，直到 `x` 到达根节点”——不是一个有效的算法，因为不能保证一个元素最终会到达根节点。第三，严格不等式 `key_low  key_high` 对于多重集是有问题的，因为不清楚如何放置边界值 `max(H_{low})` 的重复项。\n*   **结论:** **不正确**。\n\n**C. 维持与选项A中相同的分区，但每当 `|H_{\\mathrm{low}}|-|H_{\\mathrm{high}}| = 1` 时，通过提取所有元素并重新分区来重建两个堆……当 `n` 为偶数时，将 `median()` 定义为两个根节点的平均值……通过线性扫描两个堆来实现 `delete(x)`……**\n\n*   **分析:** 这个选项由于几个原因是不正确的。重建堆的再平衡策略效率极低，需要 `O(n)` 或 `O(n \\log n)` 时间，这违反了每个操作 `O(\\log n)` 的约束。当 `n` 为偶数时将中位数定义为平均值直接与问题要求中位数必须是存储的键之一相矛盾。最后，用线性扫描实现 `delete(x)` 是一个 `O(n)` 操作，再次违反了时间复杂度约束。\n*   **结论:** **不正确**。\n\n**D. 维护两个堆，其大小不变式为 `||H_{\\mathrm{low}}|-|H_{\\mathrm{high}}|| \\le 2`……将 `median()` 定义为较大堆的根节点……通过线性搜索实现 `delete(x)`……**\n\n*   **分析:** 这个选项也是有缺陷的。大小不变式 `||H_{\\mathrm{low}}|-|H_{\\mathrm{high}}|| \\le 2` 太宽松了。如果 `n=10`，正确的划分是 `(5,5)`。这个不变式将允许 `(6,4)`。在这种情况下，`H_{\\mathrm{low}}` 的大小为 `6`，其根节点可能是排名为 `6` 的元素，而不是所需排名为 `5` 的中位数。将中位数定义为“较大堆的根节点”不是一种找到第 `\\lceil n/2 \\rceil` 个元素的一致方法。与选项C一样，它也提出了 `O(n)` 的线性搜索来进行删除，违反了性能要求。\n*   **结论:** **不正确**。\n\n根据详细分析，选项A是唯一一个为 `OnlineMedian` ADT 提供了正确、全面且高效的规范，满足了问题陈述中列出的所有约束。", "answer": "$$\\boxed{A}$$", "id": "3202610"}, {"introduction": "对单个操作的最坏情况分析有时会过于悲观，无法准确反映数据结构在一系列操作下的真实效率。本练习旨在介绍摊还分析（amortized analysis），这是一种评估算法在操作序列上平均性能的强大工具。我们将对一个单调队列应用势能法（potential method），以数学方式证明其在处理滑动窗口最大值等问题时，每个元素处理的平均成本可以达到常数级别 $O(1)$ [@problem_id:3202646]。", "problem": "考虑设计一个用于计算有限序列上滑动窗口最大值的抽象数据类型（ADT），该ADT为一个单调队列。该ADT维护一个双端队列，其中存储数对 $(v,i)$，$v$ 是值，$i$ 是其索引。该队列强制满足一个不变性：队列中的值从队头到队尾严格递减，而索引从队头到队尾严格递增。一个固定宽度为 $w$ 的滑动窗口在序列位置 $\\{0,1,\\ldots,n-1\\}$ 上维护。在步骤 $i$，窗口是索引集合 $\\{i-w+1,\\ldots,i\\}$ 与 $\\{0,\\ldots,i\\}$ 的交集。\n\n其接口包含操作 $\\operatorname{push}(x,i)$、$\\operatorname{expire}(i)$ 和 $\\operatorname{max}()$。操作 $\\operatorname{push}(x,i)$ 通过从队尾反复移除值严格小于 $x$ 的数对，然后在队尾追加 $(x,i)$，来维持值的递减不变性。操作 $\\operatorname{expire}(i)$ 通过在队头数对的索引严格小于 $i-w+1$ 时反复移除它，来维持窗口不变性。操作 $\\operatorname{max}()$ 返回存储在队头的值，在不变性的保证下，该值即为窗口最大值。对于从 $0$ 到 $n-1$ 的每个索引 $i$，客户端执行操作序列 $\\operatorname{expire}(i)$，然后是 $\\operatorname{push}(a_i,i)$，最后是 $\\operatorname{max}()$，其中 $(a_0,a_1,\\ldots,a_{n-1})$ 是输入序列。\n\n采用以下单位成本模型：ADT实现在 $\\operatorname{push}$ 和 $\\operatorname{expire}$ 期间执行的每个双端队列基本操作 $\\operatorname{pushBack}$、$\\operatorname{popBack}$ 和 $\\operatorname{popFront}$ 的实际成本为 $1$，每次调用 $\\operatorname{max}()$ 的实际成本为 $1$。其他操作不产生任何成本。使用摊还分析，从摊还成本的核心定义和一个基于数据结构大小的有效势函数出发，推导出一个紧确的常数 $c$，使得在此模型下，对于任何长度为 $n$ 的输入，每个被处理元素的平均成本至多为 $c$。将最终答案表示为单个不带单位的实数。无需四舍五入。", "solution": "该问题要求使用摊还分析中的势能法，为一个特定的抽象数据类型（ADT）——单调队列——处理每个元素的平均成本推导出一个紧确的常数上界。\n\n让我们首先形式化分析的各个组成部分。我们正在处理一个包含 $n$ 个元素的序列 $(a_0, a_1, \\ldots, a_{n-1})$。对于索引 $i \\in \\{0, 1, \\ldots, n-1\\}$ 上的每个元素 $a_i$，会执行一个包含三个ADT操作的序列：$\\operatorname{expire}(i)$、$\\operatorname{push}(a_i, i)$ 和 $\\operatorname{max}()$。我们将分析这个操作序列的成本，并将其称为“步骤 $i$”。\n\n设 $a_i$ 表示步骤 $i$ 的实际成本，$\\hat{a}_i$ 表示其摊还成本。这些量之间的关系由势能法的基本方程给出：\n$$ \\hat{a}_i = a_i + \\Phi_i - \\Phi_{i-1} $$\n其中 $\\Phi_i$ 是步骤 $i$ 完成后数据结构的势，$\\Phi_{i-1}$ 是步骤 $i$ 开始前一刻的势。为使分析有效，势函数 $\\Phi$ 必须对所有 $k \\ge 0$ 满足条件 $\\Phi_k \\ge \\Phi_{-1}$，其中 $\\Phi_{-1}$ 是初始（空）数据结构的势。我们将设置 $\\Phi_{-1} = 0$。这确保了总实际成本受总摊还成本的约束：\n$$ \\sum_{k=0}^{n-1} a_k = \\sum_{k=0}^{n-1} (\\hat{a}_k - \\Phi_k + \\Phi_{k-1}) = \\left( \\sum_{k=0}^{n-1} \\hat{a}_k \\right) - \\Phi_{n-1} + \\Phi_{-1} \\le \\sum_{k=0}^{n-1} \\hat{a}_k $$\n\n接下来，我们确定步骤 $i$ 的实际成本 $a_i$。该成本由所提供的单位成本模型定义。\n在步骤 $i$，操作 $\\operatorname{expire}(i)$ 执行若干次 $\\operatorname{popFront}$ 操作。设此次数为 $k_{ei} \\ge 0$。产生的成本为 $k_{ei} \\times 1 = k_{ei}$。\n操作 $\\operatorname{push}(a_i, i)$ 首先执行若干次 $\\operatorname{popBack}$ 操作。设此次数为 $k_{pi} \\ge 0$。产生的成本为 $k_{pi} \\times 1 = k_{pi}$。然后它执行恰好一次 $\\operatorname{pushBack}$ 操作，产生成本 $1$。\n最后，操作 $\\operatorname{max}()$ 被调用一次，产生成本 $1$。\n步骤 $i$ 的总实际成本是这些成本的总和：\n$$ a_i = k_{ei} + k_{pi} + 1 + 1 = k_{ei} + k_{pi} + 2 $$\n\n问题指明势函数应基于数据结构的大小。设 $S_k$ 为步骤 $k$ 完成后双端队列中数对 $(v,i)$ 的数量。势函数的一个自然选择是该大小的线性函数：\n$$ \\Phi_k = \\alpha S_k $$\n其中 $\\alpha  0$ 是某个常数。初始状态是空队列，所以 $S_{-1}=0$ 且 $\\Phi_{-1} = \\alpha S_{-1} = 0$。由于大小 $S_k$ 总是非负的，对于任何 $\\alpha  0$，条件 $\\Phi_k \\ge 0$ 都得到满足。\n\n现在，我们计算步骤 $i$ 期间势的变化，即 $\\Delta\\Phi_i = \\Phi_i - \\Phi_{i-1} = \\alpha(S_i - S_{i-1})$。为了找到大小的变化 $S_i - S_{i-1}$，我们考虑在步骤 $i$ 期间所有修改队列大小的基本操作。有 $k_{ei}$ 次通过 $\\operatorname{popFront}$ 的移除操作，$k_{pi}$ 次通过 $\\operatorname{popBack}$ 的移除操作，以及一次通过 $\\operatorname{pushBack}$ 的添加操作。因此，元素数量的净变化是：\n$$ S_i - S_{i-1} = 1 - k_{ei} - k_{pi} $$\n势的变化因此是：\n$$ \\Delta\\Phi_i = \\alpha (1 - k_{ei} - k_{pi}) $$\n\n我们现在可以表示摊还成本 $\\hat{a}_i$：\n$$ \\hat{a}_i = a_i + \\Delta\\Phi_i = (k_{ei} + k_{pi} + 2) + \\alpha (1 - k_{ei} - k_{pi}) $$\n重新整理各项，我们得到：\n$$ \\hat{a}_i = (2 + \\alpha) + (1 - \\alpha)k_{ei} + (1 - \\alpha)k_{pi} = (2 + \\alpha) + (1 - \\alpha)(k_{ei} + k_{pi}) $$\n我们的目标是找到 $\\hat{a}_i$ 的一个常数上界，该上界独立于输入序列，这意味着它必须独立于 $k_{ei}$ 和 $k_{pi}$ 的值。由于 $k_{ei} \\ge 0$ 且 $k_{pi} \\ge 0$，如果项 $(1 - \\alpha)(k_{ei} + k_{pi})$ 的系数为非正，它将不会增加成本。我们必须施加条件：\n$$ 1 - \\alpha \\le 0 \\implies \\alpha \\ge 1 $$\n在此条件下，$(1 - \\alpha)(k_{ei} + k_{pi}) \\le 0$，所以我们得到了摊还成本的一个上界：\n$$ \\hat{a}_i \\le 2 + \\alpha $$\n为了用此方法找到最紧确的上界 $c$，我们必须选择满足 $\\alpha \\ge 1$ 且能最小化表达式 $2 + \\alpha$ 的 $\\alpha$ 值。最小值在 $\\alpha$ 有效范围的下界处取得，即 $\\alpha = 1$。\n\n令 $\\alpha = 1$，摊还成本变为：\n$$ \\hat{a}_i = (2 + 1) + (1 - 1)(k_{ei} + k_{pi}) = 3 $$\n通过这个选择，每一步 $i$ 的摊还成本恰好为 $3$。因此，处理 $n$ 个元素的总摊还成本是 $\\sum_{i=0}^{n-1} \\hat{a}_i = 3n$。总实际成本受此值约束，$\\sum_{i=0}^{n-1} a_i \\le 3n$。\n因此，每个被处理元素的平均成本受如下约束：\n$$ \\frac{1}{n} \\sum_{i=0}^{n-1} a_i \\le \\frac{3n}{n} = 3 $$\n这给出了常数 $c = 3$。\n\n为确认该界是紧确的，我们必须展示一个输入序列，其每个元素的平均成本趋近于 $3$。考虑严格递增序列 $a_i = i$，其中 $i \\in \\{0, \\ldots, n-1\\}$，窗口宽度 $w \\ge n$。\n在步骤 $i=0$：$\\operatorname{expire}(0)$ 不做任何事 ($k_{e0}=0$)。$\\operatorname{push}(0,0)$ 向空队列中添加元素 ($k_{p0}=0$)。成本为 $a_0 = 0+0+2=2$。队列状态为 $[(0,0)]$。\n在步骤 $i=1$：$\\operatorname{expire}(1)$ 不做任何事 ($k_{e1}=0$ 因为 $w \\ge n$)。对于 $\\operatorname{push}(1,1)$，由于 $1  0$，元素 $(0,0)$ 通过 $\\operatorname{popBack}$ 被移除 ($k_{p1}=1$)。然后添加 $(1,1)$。成本为 $a_1 = 0+1+2=3$。队列状态为 $[(1,1)]$。\n对于任何后续步骤 $i  0$：$\\operatorname{expire}(i)$ 不做任何事。队列包含单个元素 $(i-1, i-1)$。由于 $a_i = i  i-1$，$\\operatorname{push}(i,i)$ 操作执行一次 $\\operatorname{popBack}$ ($k_{pi}=1$)。成本为 $a_i = k_{ei} + k_{pi} + 2 = 0 + 1 + 2 = 3$。\n处理 $n$ 个元素的总实际成本为 $a_0 + \\sum_{i=1}^{n-1} a_i = 2 + (n-1) \\times 3 = 3n - 1$。\n平均成本为 $\\frac{3n-1}{n} = 3 - \\frac{1}{n}$。当 $n \\to \\infty$ 时，该平均成本趋近于 $3$。\n这确认了 $c=3$ 确实是一个紧确常数。", "answer": "$$\\boxed{3}$$", "id": "3202646"}]}