{"hands_on_practices": [{"introduction": "算法的正确性是其最基本也是最重要的属性。一个高效但结果错误的算法是毫无价值的。本练习将带你深入“正确性”这一核心属性，通过循环不变量的视角来形式化地证明一个算法的正确性，并揭示为何看似微不足道的边界条件是保证算法正确无误的关键。[@problem_id:3226962]", "problem": "给定一个数组 $A[0\\,..\\,n-1]$，其中 $n \\ge 1$，且下述算法声称可以计算出 $m = \\min\\{A[j] \\mid 0 \\le j \\le n-1\\}$。\n\n算法描述（使用常规的顺序和条件控制，以及整数索引和比较）：\n- 前置条件：$n \\ge 1$。\n- 初始化 $m \\leftarrow A[0]$，$i \\leftarrow 1$。\n- 定义循环不变量 $I(i,m)$ 为：$m = \\min\\{A[j] \\mid 0 \\le j  i\\}$ 且 $1 \\le i \\le n-1$。\n- 当 $i  n-1$ 时循环：\n  - 如果 $A[i]  m$，则设置 $m \\leftarrow A[i]$。\n  - 设置 $i \\leftarrow i + 1$。\n- 返回 $m$。\n\n以通过循环不变量证明迭代算法正确性的方法的标准定义为基础：循环不变量 $I$ 必须在初始化时成立，在保持步骤中得以维持，并与明确定义的终止状态相结合以推导出后置条件；部分正确性意味着，在前置条件下，如果算法终止，则后置条件成立；完全正确性还额外要求算法必须终止。\n\n假设你已经基于这些基本定义，为上述算法形式化地证明了 $I(i,m)$ 的初始化和保持属性，因此在每次循环测试开始时，$I(i,m)$ 都成立。然而，观察到当 $A[n-1]$ 严格小于所有 $A[0], A[1], \\dots, A[n-2]$ 时，该算法会返回不正确的结果。\n\n除了 $I(i,m)$ 在初始化和保持步骤中成立这一事实之外，还必须验证哪个附加属性，才能完成一个正确的证明，以表明该算法在 $n \\ge 1$ 的前置条件下返回 $m = \\min\\{A[j] \\mid 0 \\le j \\le n-1\\}$？\n\nA. 不变量 $I(i,m)$ 本身在每次迭代时都蕴含了后置条件，而无需考虑循环如何或何时终止。\n\nB. 初始化必须设置 $i \\leftarrow 0$ 而不是 $i \\leftarrow 1$。\n\nC. 终止和边界条件必须确保循环在 $i = n$ 时精确退出，这样在终止时，$I(i,m)$ 能蕴含 $m = \\min\\{A[j] \\mid 0 \\le j \\le n-1\\}$。\n\nD. 算法必须是非确定性的，以便能够探索所有可能的索引顺序，从而隐式地覆盖边界情况。\n\nE. 必须证明随着 $i$ 的推进，$m$ 是单调非增的，以确保无论终止状态如何，都能向后置条件取得进展。", "solution": "用户要求对所提供问题陈述中关于算法正确性的部分进行严格验证，然后对解决方案进行形式化推导，并对所有选项进行评估。\n\n### 问题验证\n\n**第一步：提取已知条件**\n\n- **数组：** $A[0\\,..\\,n-1]$，其中 $n \\ge 1$。\n- **算法目标：** 计算 $m = \\min\\{A[j] \\mid 0 \\le j \\le n-1\\}$。\n- **算法步骤：**\n    1. 前置条件：$n \\ge 1$。\n    2. 初始化：$m \\leftarrow A[0]$，$i \\leftarrow 1$。\n    3. 循环不变量 $I(i,m)$：$m = \\min\\{A[j] \\mid 0 \\le j  i\\}$ 且 $1 \\le i \\le n-1$。\n    4. 循环：`while` $i  n-1$ `do`:\n       - `if` $A[i]  m$ `then` 设置 $m \\leftarrow A[i]$。\n       - 设置 $i \\leftarrow i + 1$。\n    5. 返回：$m$。\n- **提供的信息：**\n    1. 循环不变量 $I(i,m)$ 的初始化和保持属性已被形式化证明。\n    2. 当 $A[n-1]$ 严格小于所有其他元素 $A[0], \\dots, A[n-2]$ 时，算法会返回不正确的结果。\n- **问题：** 必须验证哪个附加属性，才能完成一个正确的证明，以表明该算法返回 $m = \\min\\{A[j] \\mid 0 \\le j \\le n-1\\}$？\n\n**第二步：使用提取的已知条件进行验证**\n\n- **科学基础：** 该问题基于使用循环不变量证明算法正确性的形式化方法，这是理论计算机科学和软件工程的基石。前置条件、后置条件、循环不变量、初始化、保持和终止等概念都是标准且定义明确的。\n- **良定性：** 该问题提出了一个有缺陷的算法，并要求找出其形式化正确性证明中缺失的元素。这是一种标准且有效的教学结构。该问题是良定的，因为它将分析引向循环不变量证明的三部分结构。\n- **客观性：** 该问题以客观、形式化的语言陈述。\n- **一致性和完整性：** 问题陈述是内部一致的。它提供了一个算法、一个循环不变量以及一个关于其失败的关键观察。这个观察（当 $A[n-1]$ 是最小值时失败）直接指向了算法逻辑中的缺陷，即循环的边界条件。所提供的不变量 $I(i,m)$ 的定义带有约束 $1 \\le i \\le n-1$。对于 $n=1$ 的情况，这个约束变为 $1 \\le i \\le 0$，这是不可能的。这意味着分析是针对 $n \\ge 2$ 的，这与循环结构和观察结果是一致的。对于其诊断证明结构中失败的目的而言，该问题没有信息不足。\n\n**第三步：结论与行动**\n\n问题陈述是**有效的**。它是一个关于使用循环不变量对算法进行形式化验证的良构问题。我现在将着手解决。\n\n### 解题推导\n\n使用循环不变量证明带循环的算法的部分正确性的标准方法需要证明三个属性：\n\n1.  **初始化：** 循环不变量在循环第一次迭代之前为真。\n2.  **保持：** 如果循环不变量在一次迭代开始时为真，那么在该次迭代结束时它仍然为真。\n3.  **终止：** 当循环终止时，循环不变量和终止条件的组合蕴含了算法所需的后置条件。\n\n问题陈述表明，初始化和保持属性已经得到证明。任务是找出完成一个完整且正确证明所缺失的部分。这引导我们关注第三个属性：终止。\n\n让我们分析算法在终止时的状态。\n- 循环条件是 $i  n-1$。\n- 当此条件为假时，即当 $i \\ge n-1$ 时，循环终止。\n- 变量 $i$ 初始化为 $1$ 并在每次迭代中加 $1$。因此，循环将在 $i$ 首次等于 $n-1$ 时精确终止。\n- 循环不变量 $I(i,m)$ 被假定在每次循环测试开始时都成立。这意味着当最后的测试 $i  n-1$ 执行并失败时，前一次迭代结束时的不变量仍然成立。此时，$i = n-1$。\n- 不变量被陈述为 $I(i,m): m = \\min\\{A[j] \\mid 0 \\le j  i\\}$ 且 $1 \\le i \\le n-1$。\n- 因此，在终止时，我们有 $i = n-1$ 且不变量对 $i$ 的这个值成立。这给了我们这个属性：$m = \\min\\{A[j] \\mid 0 \\le j  n-1\\}$。\n\n然后算法返回这个 $m$ 值。然而，期望的后置条件是 $m = \\min\\{A[j] \\mid 0 \\le j \\le n-1\\}$。\n\n在终止时推导出的属性是 $m = \\min\\{A[0], A[1], \\dots, A[n-2]\\}$。\n期望的后置条件是 $m = \\min\\{A[0], A[1], \\dots, A[n-1]\\}$。\n\n很明显，终止时的属性并不蕴含后置条件。具体来说，元素 $A[n-1]$ 从未被比较过，所以如果它是最小值，算法将返回一个不正确的结果。这与问题陈述中给出的观察相符。\n\n要完成一个正确的证明，必须验证的“附加属性”正是这第三步：证明不变量和终止条件共同蕴含后置条件。给定的算法在这一验证步骤中失败了。一个正确的证明需要一个能够满足这一步骤的算法。这通常需要更改循环以处理所有元素，例如，`while` $i  n$。这将导致在 $i=n$ 时终止，如果此时不变量成立，我们将得到 $m = \\min\\{A[j] \\mid 0 \\le j  n\\}$，这是正确的后置条件。\n\n### 选项评估\n\n**A. 不变量 $I(i,m)$ 本身在每次迭代时都蕴含了后置条件，而无需考虑循环如何或何时终止。**\n这个陈述误解了循环不变量的功能。循环不变量建立了一个在算法部分执行（直到迭代 $i$）期间成立的属性。只有在终止时，当 $i$ 达到其最终值时，不变量才能被用来确立最终的后置条件。对于一个中间的 $i  n-1$，不变量不能蕴含整个数组的结果。\n**结论：不正确。**\n\n**B. 初始化必须设置 $i \\leftarrow 0$ 而不是 $i \\leftarrow 1$。**\n将初始化更改为 $i \\leftarrow 0$ 而保持算法其余部分不变，并不能解决根本问题。循环条件仍然是 $i  n-1$，因此循环仍然会在处理 $A[n-1]$ 之前终止。这个更改没有解决终止条件中的错误。\n**结论：不正确。**\n\n**C. 终止和边界条件必须确保循环在 $i = n$ 时精确退出，这样在终止时，$I(i,m)$ 能蕴含 $m = \\min\\{A[j] \\mid 0 \\le j \\le n-1\\}$。**\n这个选项正确地指出了证明中缺失的部分。循环不变量证明的第三步要求证明不变量与循环条件的否定相结合，能蕴含后置条件。这个选项准确地描述了要使这一步成功所需要的东西：循环必须处理所有元素，对于这个索引方案，这意味着在 $i=n$ 时终止。在 $i=n$ 时，不变量 $m = \\min\\{A[j] \\mid 0 \\le j  i\\}$ 将变为 $m = \\min\\{A[j] \\mid 0 \\le j  n\\}$，这正是期望的后置条件。当前算法的失败之处恰恰是它无法满足这个终止属性。\n**结论：正确。**\n\n**D. 算法必须是非确定性的，以便能够探索所有可能的索引顺序，从而隐式地覆盖边界情况。**\n对于一个简单的差一错误来说，引入非确定性是一个不相关且过于复杂的解决方案。该算法可以确定性地被修正。这种方法与针对这类问题的循环不变量标准证明方法无关。\n**结论：不正确。**\n\n**E. 必须证明随着 $i$ 的推进，$m$ 是单调非增的，以确保无论终止状态如何，都能向后置条件取得进展。**\n虽然在这个算法中 $m$ 确实是单调非增的（它只会被更新为更小的值），但这个属性不足以证明其正确性。算法可以向一个并非正确最终答案的值“取得进展”。终止状态至关重要；如果不处理所有元素，$m$ 的非增性质并不能保证它达到全局最小值。循环不变量的证明结构要求在终止时有一个特定的论证，而这个属性没有提供。\n**结论：不正确。**", "answer": "$$\\boxed{C}$$", "id": "3226962"}, {"introduction": "在确保算法正确之后，我们通常关心其效率。对于递归算法，其时间复杂度通常通过一个递推关系来描述。解决这些递推关系是算法分析中的一项核心技能，本练习将通过一个非标准的递推关系，引导你运用变量替换的技巧来求解其时间复杂度。[@problem_id:3227010]", "problem": "考虑一个确定性算法，其在大小为 $N$ 的输入上的运行时间由以下递推关系决定：\n$$\nT(N) = \\sqrt{N}\\, T\\!\\left(\\sqrt{N}\\right) + N,\n$$\n对于所有形式为 $N = 2^{2^{k}}$（其中 $k \\in \\mathbb{N}$）的 $N$，且基准条件为 $T(2) = c_{0}$，其中 $c_{0} \\ge 0$ 是一个固定的常数。在标准的字随机存取机（word-RAM）成本模型下工作，其中对常数大小字长的操作数进行的每次算术或比较操作的成本为单位成本，并将 $T(N)$ 解释为最坏情况下作为输入大小 $N$ 的函数的原始操作次数。\n\n仅使用渐近增长和源于递归算法的递推关系的基本定义，从第一性原理出发，推导出一个紧密的渐近增长率 $f(N)$，使得 $T(N) \\in \\Theta\\!\\big(f(N)\\big)$。只报告主导阶函数 $f(N)$（即，忽略乘法常数因子），并在最终表达式中使用自然对数 $\\ln$。你的最终答案必须是单一的封闭形式解析表达式 $f(N)$。", "solution": "问题要求为由递推关系定义的函数 $T(N)$ 找到一个紧密的渐近界 $f(N)$：\n$$\nT(N) = \\sqrt{N}\\, T\\!\\left(\\sqrt{N}\\right) + N\n$$\n该递推关系对于形式为 $N = 2^{2^{k}}$（其中 $k \\in \\mathbb{N}$）的输入大小 $N$ 成立。基准情况为 $T(2) = c_{0}$，其中 $c_{0} \\ge 0$ 是一个常数。基准情况 $N=2$ 对应于 $2 = 2^{2^k}$，这意味着 $1 = 2^k$，因此 $k=0$。这确定了自然数集合被取为 $\\mathbb{N} = \\{0, 1, 2, \\ldots\\}$。\n\n给定的递推关系不符合主定理的标准形式，因为递归项的系数是 $\\sqrt{N}$。我们将使用变量替换，从第一性原理出发解决这个递推关系。\n\n首先，我们通过两边同除以 $N$ 来对递推关系进行归一化：\n$$\n\\frac{T(N)}{N} = \\frac{\\sqrt{N}\\, T\\!\\left(\\sqrt{N}\\right)}{N} + \\frac{N}{N}\n$$\n$$\n\\frac{T(N)}{N} = \\frac{T\\!\\left(\\sqrt{N}\\right)}{\\sqrt{N}} + 1\n$$\n这个变换揭示了一个更简单的结构。我们定义一个新函数 $G(N)$ 为：\n$$\nG(N) = \\frac{T(N)}{N}\n$$\n将 $G(N)$ 代入变换后的递推关系，我们得到：\n$$\nG(N) = G\\!\\left(\\sqrt{N}\\right) + 1\n$$\n这是一个关于 $G(N)$ 的简单得多的递推关系。我们可以利用 $N$ 的指定结构，通过展开来解决它。问题说明 $N$ 的形式为 $N=2^{2^k}$。\n让我们重复应用 $G(N)$ 的递推关系：\n$$\n\\begin{aligned}\nG(N) = G\\!\\left(N^{1/2}\\right) + 1 \\\\\n= \\left(G\\!\\left(\\left(N^{1/2}\\right)^{1/2}\\right) + 1\\right) + 1 = G\\!\\left(N^{1/4}\\right) + 2 \\\\\n= \\left(G\\!\\left(\\left(N^{1/4}\\right)^{1/2}\\right) + 1\\right) + 2 = G\\!\\left(N^{1/8}\\right) + 3\n\\end{aligned}\n$$\n通过重复这个过程 $m$ 次，我们可以看到一个模式：\n$$\nG(N) = G\\!\\left(N^{1/2^m}\\right) + m\n$$\n当 $G$ 的参数达到基准情况 $N=2$ 时，展开停止。所以我们设 $N^{1/2^m} = 2$。\n为了解出 $m$，我们对两边取以 2 为底的对数：\n$$\n\\log_{2}\\left(N^{1/2^m}\\right) = \\log_{2}(2)\n$$\n$$\n\\frac{1}{2^m} \\log_{2}(N) = 1\n$$\n$$\n2^m = \\log_{2}(N)\n$$\n再次取以 2 为底的对数：\n$$\n\\log_{2}\\left(2^m\\right) = \\log_{2}(\\log_{2}(N))\n$$\n$$\nm = \\log_{2}(\\log_{2}(N))\n$$\n现在，我们将 $m$ 的这个表达式代回 $G(N)$ 的方程中：\n$$\nG(N) = G(2) + \\log_{2}(\\log_{2}(N))\n$$\n$G(2)$ 的值可以从 $T(N)$ 的基准情况得到：\n$$\nG(2) = \\frac{T(2)}{2} = \\frac{c_{0}}{2}\n$$\n所以，$G(N)$ 的精确表达式是：\n$$\nG(N) = \\frac{c_{0}}{2} + \\log_{2}(\\log_{2}(N))\n$$\n为了求得 $T(N)$，我们反转最初的替换 $G(N) = T(N)/N$：\n$$\nT(N) = N \\cdot G(N) = N \\left(\\frac{c_{0}}{2} + \\log_{2}(\\log_{2}(N))\\right)\n$$\n$$\nT(N) = \\frac{c_{0}}{2}N + N\\log_{2}(\\log_{2}(N))\n$$\n我们被要求找到一个紧密的渐近增长率 $f(N)$，使得 $T(N) \\in \\Theta(f(N))$。我们必须在 $N \\to \\infty$ 时，确定 $T(N)$ 表达式中的主导项。这两个项是 $\\frac{c_{0}}{2}N$ 和 $N\\log_{2}(\\log_{2}(N))$。当 $N \\to \\infty$ 时，函数 $\\log_{2}(\\log_{2}(N))$ 无界增长。因此，项 $N\\log_{2}(\\log_{2}(N))$ 的渐近增长速度快于线性项 $N$。\n因此，$T(N)$ 的渐近行为由第二项决定：\n$$\nT(N) \\in \\Theta\\left(N\\log_{2}(\\log_{2}(N))\\right)\n$$\n问题要求最终表达式使用自然对数 $\\ln$。我们可以使用换底公式 $\\log_{b}(x) = \\frac{\\ln(x)}{\\ln(b)}$ 来转换对数的底。\n$$\n\\log_{2}(\\log_{2}(N)) = \\frac{\\ln(\\log_{2}(N))}{\\ln(2)} = \\frac{\\ln\\left(\\frac{\\ln(N)}{\\ln(2)}\\right)}{\\ln(2)} = \\frac{\\ln(\\ln(N)) - \\ln(\\ln(2))}{\\ln(2)}\n$$\n对于大的 $N$，$\\ln(\\ln(N))$ 是这个表达式的主导部分。项 $\\ln(\\ln(2))$ 是一个常数。因此：\n$$\n\\log_{2}(\\log_{2}(N)) = \\frac{1}{\\ln(2)}\\ln(\\ln(N)) - \\frac{\\ln(\\ln(2))}{\\ln(2)}\n$$\n渐近地，$\\log_{2}(\\log_{2}(N)) \\in \\Theta(\\ln(\\ln(N)))$，因为在 $\\Theta$ 记号中忽略了常数因子和低阶加法常数。\n将此代入 $T(N)$ 的渐近界中：\n$$\nT(N) \\in \\Theta(N \\cdot \\ln(\\ln(N)))\n$$\n问题要求给出主导阶函数 $f(N)$，并忽略乘法常数因子。这个函数是：\n$$\nf(N) = N \\ln(\\ln(N))\n$$", "answer": "$$\n\\boxed{N \\ln(\\ln(N))}\n$$", "id": "3227010"}, {"introduction": "理论上的时间复杂度分析（如大O记号）描述了算法在输入规模趋于无穷时的长期性能，但忽略了常数因子和低阶项。在实际应用中，对于中小型输入，这些被忽略的因素可能起决定性作用。本练习通过一个具体例子，让你亲手计算和比较一个多项式时间算法和一个指数时间算法的性能拐点，深刻理解渐进复杂度和实际性能之间的差异。[@problem_id:3226973]", "problem": "在随机存取机（RAM）模型中，算法是一个有限的、定义明确的过程，它将输入映射到输出，并执行一系列基本操作，其操作次数可以表示为输入大小的函数。对于输入大小 $N \\in \\mathbb{N}$ 且 $N \\geq 1$，考虑两种算法 $A$ 和 $B$，它们的精确时间复杂度（基本操作计数）分别由 $C_{A}(N)$ 和 $C_{B}(N)$ 给出。假设每个基本操作的单位成本为1。\n\n算法 $A$ 的精确时间复杂度为 $C_{A}(N) = 1000 N^{2}$，算法 $B$ 的精确时间复杂度为 $C_{B}(N) = \\frac{2^{N}}{1000}$。尽管从增长率的角度来看，算法 $B$ 的渐近性能比算法 $A$ 差，但由于其前导常数较小以及精确成本函数的具体结构，它可能在某些有限的 $N$ 值下更快。\n\n根据基本定义，对于固定的输入大小 $N$，具有较少精确基本操作计数的算法速度更快。请确定使得算法 $B$ 比算法 $A$ 更快的最大整数 $N$；即，找到满足 $C_{B}(N)  C_{A}(N)$ 的最大 $N \\in \\mathbb{N}$。请将您的最终答案表示为单个整数。", "solution": "问题要求找到最大的整数 $N \\in \\mathbb{N}$（其中 $N \\geq 1$），使得算法 $B$ 比算法 $A$ 更快。根据问题的定义，这意味着我们必须找到满足不等式 $C_{B}(N)  C_{A}(N)$ 的最大整数 $N$。\n\n首先，我们陈述算法 $A$ 和 $B$ 的精确时间复杂度的已知条件：\n$$ C_{A}(N) = 1000 N^{2} $$\n$$ C_{B}(N) = \\frac{2^{N}}{1000} $$\n\n算法 $B$ 比算法 $A$ 更快的条件可以转化为以下不等式：\n$$ \\frac{2^{N}}{1000}  1000 N^{2} $$\n\n为了分析这个不等式，我们可以重新排列各项。将两边同乘以 $1000$ 得：\n$$ 2^{N}  1000^{2} N^{2} $$\n$$ 2^{N}  (10^3)^{2} N^{2} $$\n$$ 2^{N}  10^6 N^{2} $$\n\n这是一个超越不等式，无法使用初等代数运算求解 $N$。我们必须分析不等式两边函数的行为。设 $g(N) = 2^{N}$ 和 $h(N) = 10^6 N^{2}$。算法复杂度的基本原理是，对于足够大的 $N$，指数函数（如 $g(N)$）的增长速度远快于多项式函数（如 $h(N)$）。这意味着不等式 $g(N)  h(N)$ 会在 $N$ 的某个初始整数范围内成立，但当 $N$ 增大并超过一个“交叉”点后，该不等式将不再成立并一直保持不成立状态。问题要求的是使该不等式仍然成立的最大整数 $N$。\n\n为了定位这个交叉点，我们可以研究方程 $2^{x} = 10^6 x^{2}$ 的近似实数解。对两边取以 2 为底的对数，得到：\n$$ \\log_{2}(2^{x}) = \\log_{2}(10^6 x^{2}) $$\n$$ x = \\log_{2}(10^6) + \\log_{2}(x^{2}) $$\n$$ x = 6 \\log_{2}(10) + 2 \\log_{2}(x) $$\n\n使用已知值 $\\log_{2}(10) \\approx 3.321928$，我们可以将方程写为：\n$$ x \\approx 6(3.321928) + 2 \\log_{2}(x) $$\n$$ x \\approx 19.931568 + 2 \\log_{2}(x) $$\n\n这个方程可以通过数值方法或迭代法求解。解代表了成本相等的点。我们所求的整数将是这个值的向下取整，或一个非常接近它的整数。让我们在预期的交叉点附近测试整数 $N$ 的值。根据快速的迭代估算，解位于 $N=29$ 和 $N=30$ 之间。现在我们将这两个整数值直接代入不等式 $2^{N}  10^6 N^{2}$ 中进行检验。\n\n情况1：测试 $N=29$\n我们需要确定是否 $2^{29}  10^6 (29)^{2}$。\n首先，计算左侧（LHS）：\n$$ \\text{LHS} = 2^{29} = 536,870,912 $$\n接着，计算右侧（RHS）：\n$$ \\text{RHS} = 10^6 \\times (29)^{2} = 1,000,000 \\times 841 = 841,000,000 $$\n比较这两个值，我们发现：\n$$ 536,870,912  841,000,000 $$\n对于 $N=29$，不等式成立。因此，当输入大小为 $N=29$ 时，算法 $B$ 比算法 $A$ 更快。\n\n情况2：测试 $N=30$\n我们需要确定是否 $2^{30}  10^6 (30)^{2}$。\n首先，计算左侧：\n$$ \\text{LHS} = 2^{30} = 2 \\times 2^{29} = 2 \\times 536,870,912 = 1,073,741,824 $$\n接着，计算右侧：\n$$ \\text{RHS} = 10^6 \\times (30)^{2} = 1,000,000 \\times 900 = 900,000,000 $$\n比较这两个值，我们发现：\n$$ 1,073,741,824 \\not 900,000,000 $$\n对于 $N=30$，不等式不成立。当输入大小为 $N=30$ 时，算法 $A$ 比算法 $B$ 更快。\n\n由于指数函数 $2^N$ 在 $N$ 大于它们的交叉点（我们已确定在 $29$ 和 $30$ 之间）之后，其增长速度持续快于多项式函数 $10^6 N^2$，因此对于任何整数 $N \\ge 30$，不等式 $C_B(N)  C_A(N)$ 都不会成立。\n\n因此，使得算法 $B$ 比算法 $A$ 更快的最大整数 $N$ 是 $29$。", "answer": "$$\\boxed{29}$$", "id": "3226973"}]}