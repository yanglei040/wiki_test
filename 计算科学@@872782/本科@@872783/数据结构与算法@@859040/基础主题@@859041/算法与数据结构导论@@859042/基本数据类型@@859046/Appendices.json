{"hands_on_practices": [{"introduction": "在计算机的底层，所有算术运算最终都归结为对二进制位的操作。乘以或除以 $2$ 的幂是基本运算，它们可以通过位移操作高效完成。本练习 [@problem_id:3260707] 将指导你从二进制位值制的第一性原理出发，推导出如何仅用位移操作来实现这些运算，从而加深你对抽象数学运算与具体硬件实现之间联系的理解。", "problem": "您的任务是仅使用有符号整数上定义的位移位运算符的语义来实现整数与2的幂的乘法和除法。目标是从二进制位置数字系统和二进制补码表示法出发进行推理，从而推导并实现正确的运算，而不依赖于显式的乘法、除法或求幂运算符。\n\n使用的基本原理：\n- 二进制位置数字系统：任何非负整数 $n$ 都可以表示为 $n = \\sum_{i=0}^{m} b_i \\cdot 2^i$，其中每个 $b_i \\in \\{0,1\\}$，$m$ 是一个非负整数。在二进制补码表示法中，负整数在算术右移下会无限扩展符号位，从而保持代数结构。\n- 有符号整数上的位移位运算符语义：对于非负整数位移量 $k$，左移将每个比特位 $i$ 移动到位置 $i+k$，而算术右移将每个比特位 $i$ 移动到 $i-k$，并对负值复制符号位。\n\n任务：\n- 实现两个作用于有符号数学整数的函数：\n  1. $f_{\\text{mul}}(n,k)$，仅使用左移位运算符语义返回乘积 $n \\cdot 2^k$。\n  2. $f_{\\text{div\\_floor}}(n,k)$，仅使用算术右移位运算符语义返回向下取整的除法结果 $\\left\\lfloor \\dfrac{n}{2^k} \\right\\rfloor$。\n- 约束条件：\n  - 输入 $n$ 和 $k$ 是数学整数，且 $k \\ge 0$。\n  - 实现中不得使用乘法、除法或求幂运算符。仅使用位移位运算符来实现所需的操作。\n  - 在无界精度的有符号整数上作为数学对象进行操作；不要假设固定的字长。\n\n测试套件：\n- 使用以下参数对 $(n,k)$ 来验证正确性和边界行为：\n  - $(13, 2)$ 意为 $n = 13$, $k = 2$。\n  - $(-13, 2)$ 意为 $n = -13$, $k = 2$。\n  - $(0, 5)$ 意为 $n = 0$, $k = 5$。\n  - $(1, 0)$ 意为 $n = 1$, $k = 0$。\n  - $(-1, 1)$ 意为 $n = -1$, $k = 1$。\n  - $(123456789, 3)$ 意为 $n = 123456789$, $k = 3$。\n  - $(-1073741824, 5)$ 意为 $n = -1073741824$, $k = 5$。\n  - $(7, 63)$ 意为 $n = 7$, $k = 63$。\n- 对于每个测试用例，计算两个整数：$f_{\\text{mul}}(n,k)$ 和 $f_{\\text{div\\_floor}}(n,k)$。\n\n最终输出格式要求：\n- 您的程序应生成单行输出，其中包含结果，格式为一个逗号分隔的列表，并用方括号括起来。列表中的每个结果本身是一个包含两个整数元素的列表，无空格，并按测试套件的顺序排列，例如：\n- 确切格式为 $[[a_1,b_1],[a_2,b_2],\\dots,[a_8,b_8]]$，其中 $a_i = f_{\\text{mul}}(n_i,k_i)$，$b_i = f_{\\text{div\\_floor}}(n_i,k_i)$，对应第 $i$ 个测试用例。", "solution": "问题陈述经评估有效。它在科学上以二进制算术和二进制补码表示法为基础，问题设定良好，目标和约束明确，并使用客观、明确的语言进行表述。任务是从第一性原理出发，仅使用位移位运算的语义等价物来推导和实现整数与2的幂的乘法和除法。\n\n我们将根据所提供的基本原理，为两个所需的函数 $f_{\\text{mul}}(n,k)$ 和 $f_{\\text{div\\_floor}}(n,k)$ 推导解决方案。\n\n### $f_{\\text{mul}}(n,k) = n \\cdot 2^k$ 的推导\n\n问题是计算一个整数 $n$ 与2的幂 $2^k$（其中 $k \\ge 0$）的乘积，且仅使用左位移语义。\n\n首先，考虑一个非负整数 $n$。根据二进制位置数字系统，$n$ 可以表示为2的幂之和：\n$$n = \\sum_{i=0}^{m} b_i \\cdot 2^i$$\n其中 $b_i \\in \\{0, 1\\}$ 是 $n$ 在位置 $i$ 的二进制数字（比特），$m$ 是表示 $n$ 所需的2的最高次幂。\n\n将 $n$ 乘以 $2^k$ 得到：\n$$n \\cdot 2^k = \\left( \\sum_{i=0}^{m} b_i \\cdot 2^i \\right) \\cdot 2^k$$\n根据乘法对加法的分配律以及指数定律（$a^x \\cdot a^y = a^{x+y}$），我们可以将其重写为：\n$$n \\cdot 2^k = \\sum_{i=0}^{m} (b_i \\cdot 2^i \\cdot 2^k) = \\sum_{i=0}^{m} b_i \\cdot 2^{i+k}$$\n这个结果和表示一个新的整数，其中每个原始在位置 $i$ 的比特 $b_i$（贡献值为 $b_i \\cdot 2^i$）现在位于位置 $i+k$（贡献值为 $b_i \\cdot 2^{i+k}$）。这精确地描述了逻辑左移 $k$ 位的操作。从位置 $0$ 到 $k-1$ 的新低位比特用零填充。\n\n对于负整数，我们依赖于二进制补码表示法。在这个系统中，对有符号整数执行左位移（其中右侧新引入的比特为零）在算术上等同于乘以 $2^k$，前提是没有因溢出而丢失有效位。问题指定使用无界精度整数，这对应于 Python 的任意精度整数类型。这种抽象确保不会发生溢出。因此，左移操作对所有整数 $n$ 均有效。\n\n因此，函数 $f_{\\text{mul}}(n, k)$ 可以使用左位移操作来实现，在包括 Python 在内的许多编程语言中，该操作表示为 ``。\n$$f_{\\text{mul}}(n,k) \\equiv n \\ll k$$\n\n### $f_{\\text{div\\_floor}}(n,k) = \\lfloor \\frac{n}{2^k} \\rfloor$ 的推导\n\n问题是计算一个整数 $n$ 除以2的幂 $2^k$（其中 $k \\ge 0$）的向下取整结果，且仅使用算术右位移语义。\n\n首先，考虑一个非负整数 $n$，表示为 $n = \\sum_{i=0}^{m} b_i \\cdot 2^i$。\n将 $n$ 除以 $2^k$ 得到：\n$$\\frac{n}{2^k} = \\frac{1}{2^k} \\sum_{i=0}^{m} b_i \\cdot 2^i = \\sum_{i=0}^{m} b_i \\cdot 2^{i-k}$$\n我们可以在索引 $i=k$ 处将此和式拆分：\n$$\\frac{n}{2^k} = \\sum_{i=k}^{m} b_i \\cdot 2^{i-k} + \\sum_{i=0}^{k-1} b_i \\cdot 2^{i-k}$$\n第一项 $\\sum_{i=k}^{m} b_i \\cdot 2^{i-k}$ 是一个整数。它对应于 $n$ 的二进制表示右移 $k$ 位，位置 $0$ 到 $k-1$ 的比特被丢弃。\n第二项 $\\sum_{i=0}^{k-1} b_i \\cdot 2^{i-k}$ 是一个非负项的和。其值满足 $0 \\le \\sum_{i=0}^{k-1} b_i \\cdot 2^{i-k}  1$。这一项代表除法的小数部分。\n\n一个数的向下取整是小于或等于该数的最大整数。由于第二项是小于1的非负分数，整个表达式的向下取整结果就是整数部分：\n$$\\left\\lfloor \\frac{n}{2^k} \\right\\rfloor = \\sum_{i=k}^{m} b_i \\cdot 2^{i-k}$$\n这个操作精确地对应算术右移。对于非负数，算术右移与逻辑右移相同：比特向右移动 $k$ 位，空出的 $k$ 个最高位用 $0$ 填充，而 $0$ 正是非负数的符号位。\n\n现在，考虑一个负整数 $n$。向下取整除法 $\\lfloor \\frac{n}{d} \\rfloor$ 向负无穷大方向舍入。例如，$\\lfloor \\frac{-13}{4} \\rfloor = \\lfloor -3.25 \\rfloor = -4$。这与截断（向零舍入）不同，后者将得到 $-3$。问题明确要求向下取整除法，而对二进制补码数进行算术右移的定义正是为了产生这个确切的结果。在算术右移中，比特向右移动，空出的高位比特用原始符号位的副本填充。对于负数，符号位是 $1$，所以新比特是 $1$。这个过程正确地保留了符号，并将数值朝负无穷大方向舍入。\n\nPython 的整数右移运算符 `>>` 实现的是算术右移。对于正整数和负整数，此行为都有保证，并直接对应于除以2的幂的向下取整除法。\n\n因此，函数 $f_{\\text{div\\_floor}}(n, k)$ 可以使用算术右位移操作来实现。\n$$f_{\\text{div\\_floor}}(n,k) \\equiv n \\gg k$$\n\n实现将把这两个推导出的等价关系应用到所提供的测试套件中。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of implementing multiplication and floor division by powers\n    of two using only bit shift operators, based on first principles of binary\n    arithmetic and two's complement representation.\n    \"\"\"\n    \n    # Define the functions based on the derived principles.\n    # f_mul(n, k) computes n * 2**k using the left shift operator.\n    # The derivation showed that n  k is equivalent to n * 2**k for all integers n\n    # and non-negative integers k, within an unbounded integer model.\n    f_mul = lambda n, k: n  k\n\n    # f_div_floor(n, k) computes floor(n / 2**k) using the arithmetic right shift operator.\n    # The derivation showed that n >> k (arithmetic right shift) is equivalent to\n    # floor(n / 2**k) for all integers n and non-negative integers k.\n    f_div_floor = lambda n, k: n >> k\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (13, 2),\n        (-13, 2),\n        (0, 5),\n        (1, 0),\n        (-1, 1),\n        (123456789, 3),\n        (-1073741824, 5),\n        (7, 63)\n    ]\n\n    results = []\n    for n, k in test_cases:\n        # Calculate the multiplication and division results for the current case.\n        mul_result = f_mul(n, k)\n        div_result = f_div_floor(n, k)\n        \n        # Append the pair of results to the list.\n        results.append([mul_result, div_result])\n\n    # Format the final output string exactly as specified:\n    # A comma-separated list of two-element lists, with no whitespace.\n    # e.g., [[a_1,b_1],[a_2,b_2],...]\n    output_str = f\"[{','.join(f'[{res[0]},{res[1]}]' for res in results)}]\"\n    \n    # Final print statement in the exact required format.\n    print(output_str)\n\nsolve()\n```", "id": "3260707"}, {"introduction": "除了算术等效操作外，位运算还拥有强大的逻辑能力。异或（XOR）运算符独特的代数性质——如自反性——使其能够实现一些巧妙的算法，例如在不使用临时变量的情况下交换两个整数的值。这个经典练习 [@problem_id:3260585] 不仅提供了一个节省空间的解决方案，更能引导你超越传统的算术思维，深入理解位运算的逻辑结构。", "problem": "你需要编写一个完整的程序，该程序定义并使用一个函数，在不使用任何临时变量的情况下，仅通过位运算来交换两个原生整数。目标是从第一性原理出发，论证这种交换为何是可能且正确的。程序必须实现该函数，在提供的测试集上运行，并按指定格式打印汇总结果。\n\n在你的推理和算法设计中，应以下列定义为基础：整数以二进制形式表示为位序列，位运算独立作用于每个位。按位异或 (XOR) 将用 $\\oplus$ 表示，按位与将用 $\\land$ 表示，按位或将用 $\\lor$ 表示。除这些表示和运算外，不应需要任何其他假设。\n\n交换函数的约束条件：\n- 函数必须接受两个整数 $a$ 和 $b$，并返回交换后的值。\n- 函数不得分配或使用任何额外的临时变量。\n- 函数必须仅使用位运算；在交换函数内部不允许使用算术运算（如 $+$、$-$、$\\times$、$\\div$）、元组解包以及任何库或语言特定的交换结构。\n- 函数必须在 $\\mathcal{O}(1)$ 时间内执行，并使用 $\\mathcal{O}(1)$ 的空间。\n\n你的程序需要执行的测试集：\n- 情况 1：$a = 3$, $b = 5$。\n- 情况 2：$a = 0$, $b = 0$。\n- 情况 3：$a = 0$, $b = 42$。\n- 情况 4：$a = -7$, $b = 13$。\n- 情况 5：$a = 2^{63} - 1$, $b = -2^{63}$。\n- 情况 6：$a = 123456789$, $b = 987654321$。\n- 情况 7：$a = 1$, $b = 1$。\n\n你的程序必须对每个测试用例应用交换函数，并生成一行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。列表中的每个元素本身必须是一个双整数列表 $[a',b']$，表示相应测试用例交换后的值，其中 $a'$ 是 $a$ 的新值（原为 $b$ 的值），$b'$ 是 $b$ 的新值（原为 $a$ 的值）。例如，输出格式应类似于 $[[b_1,a_1],[b_2,a_2],\\dots]$，不含空格。", "solution": "该问题是有效的。它提出了一个计算逻辑中明确定义的任务，该任务基于位运算的基本代数性质。所有约束条件都是一致的，目标也很明确。\n\n任务是交换两个整数变量（我们称之为 $a$ 和 $b$）的值，而不使用辅助的临时变量。约束条件将允许的操作限制为仅位运算。解决方案的关键在于按位异或 (XOR) 运算的性质，该运算用符号 $\\oplus$ 表示。\n\n从第一性原理出发的论证依赖于整数集合在按位异或运算下形成的代数结构。由于位运算独立作用于整数二进制表示中的每一位，我们可以在单个位的层面上分析其性质。集合 $\\{0, 1\\}$ 与异或运算构成一个阿贝尔群。其关键性质如下：\n\n1.  **交换律**：$x \\oplus y = y \\oplus x$。操作数的顺序无关紧要。\n2.  **结合律**：$(x \\oplus y) \\oplus z = x \\oplus (y \\oplus z)$。运算的分组无关紧要。\n3.  **单位元**：存在单位元 $0$，使得 $x \\oplus 0 = x$。\n4.  **自反逆元**：每个元素都是其自身的逆元，即 $x \\oplus x = 0$。\n\n这些为单个位建立的性质可以推广到任意位长度的整数，因为这些运算是逐位应用的。\n\n设变量的初始值为 $a_0$ 和 $b_0$。交换是通过使用异或运算的一系列三次赋值来实现的。\n\n**步骤 1：**通过将 $a$ 与 $b$ 进行异或运算来更新 $a$ 的值。\n$$a \\leftarrow a \\oplus b$$\n此步骤后，变量 $a$ 持有的值为 $a_1 = a_0 \\oplus b_0$。变量 $b$ 仍持有其原始值 $b_0$。此时变量的状态为 $(a_1, b_0)$。\n\n**步骤 2：**通过将 $b$ 与 $a$ 的新值进行异或运算来更新 $b$ 的值。\n$$b \\leftarrow a \\oplus b$$\n代入变量的当前值 ($a=a_1$, $b=b_0$)，我们得到：\n$$b \\leftarrow a_1 \\oplus b_0$$\n现在，代入步骤 1 中 $a_1$ 的表达式：\n$$b \\leftarrow (a_0 \\oplus b_0) \\oplus b_0$$\n根据结合律，我们可以重新组合各项：\n$$b \\leftarrow a_0 \\oplus (b_0 \\oplus b_0)$$\n根据自反逆元性质 ($b_0 \\oplus b_0 = 0$)：\n$$b \\leftarrow a_0 \\oplus 0$$\n最后，根据单位元性质 ($a_0 \\oplus 0 = a_0$)：\n$$b \\leftarrow a_0$$\n此步骤后，变量 $b$ 正确地持有了 $a$ 的原始值，即 $a_0$。变量 $a$ 仍持有值 $a_1 = a_0 \\oplus b_0$。此时状态为 $(a_1, a_0)$。\n\n**步骤 3：**最后一次更新 $a$ 的值，方法是将其与 $b$ 的新值进行异或运算。\n$$a \\leftarrow a \\oplus b$$\n代入当前值 ($a=a_1$, $b=a_0$)：\n$$a \\leftarrow a_1 \\oplus a_0$$\n现在，代入步骤 1 中 $a_1$ 的表达式：\n$$a \\leftarrow (a_0 \\oplus b_0) \\oplus a_0$$\n根据交换律重新排序各项：\n$$a \\leftarrow (b_0 \\oplus a_0) \\oplus a_0$$\n根据结合律重新分组：\n$$a \\leftarrow b_0 \\oplus (a_0 \\oplus a_0)$$\n根据自反逆元性质 ($a_0 \\oplus a_0 = 0$)：\n$$a \\leftarrow b_0 \\oplus 0$$\n最后，根据单位元性质 ($b_0 \\oplus 0 = b_0$)：\n$$a \\leftarrow b_0$$\n此最后步骤之后，变量 $a$ 现在持有了 $b$ 的原始值，即 $b_0$。变量 $b$ 继续持有 $a_0$。\n\n变量的最终状态为 $(b_0, a_0)$。值已成功交换。该算法遵守所有规定的约束：它不使用临时变量，完全依赖于位运算，并且由固定数量的操作组成，因此时间复杂度为 $\\mathcal{O}(1)$，空间复杂度为 $\\mathcal{O}(1)$。\n\n实现部分将定义一个函数，该函数接受两个整数并应用这个三步异或序列，返回新的值。然后，将对提供的测试集中的每个案例执行此函数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of swapping integers using bitwise XOR and\n    prints the results for a given test suite.\n    \"\"\"\n\n    def xor_swap(a, b):\n        \"\"\"\n        Swaps two integers using only bitwise XOR operations.\n\n        This function implements the classic XOR swap algorithm, which swaps the\n        values of two variables without using a temporary variable. The logic\n        relies on the algebraic properties of the XOR operation.\n\n        Args:\n            a: The first integer.\n            b: The second integer.\n\n        Returns:\n            A tuple (a, b) with the swapped values.\n        \"\"\"\n        # Let initial values be a_0 and b_0.\n        # Step 1: a becomes a_0 ^ b_0. b is still b_0.\n        a = a ^ b\n        # Step 2: b becomes (a_0 ^ b_0) ^ b_0 = a_0 ^ (b_0 ^ b_0) = a_0 ^ 0 = a_0.\n        # So b now holds the original value of a.\n        b = a ^ b\n        # Step 3: a becomes (a_0 ^ b_0) ^ a_0 = (a_0 ^ a_0) ^ b_0 = 0 ^ b_0 = b_0.\n        # So a now holds the original value of b.\n        a = a ^ b\n        return a, b\n\n    # Define the test cases from the problem statement.\n    # Python integers have arbitrary precision, which correctly models\n    # the behavior of two's complement arithmetic for bitwise operations\n    # on fixed-width integers, including the large integer case.\n    test_cases = [\n        (3, 5),                       # Case 1\n        (0, 0),                       # Case 2\n        (0, 42),                      # Case 3\n        (-7, 13),                     # Case 4\n        (2**63 - 1, -2**63),          # Case 5\n        (123456789, 987654321),       # Case 6\n        (1, 1),                       # Case 7\n    ]\n\n    results = []\n    for a_val, b_val in test_cases:\n        swapped_a, swapped_b = xor_swap(a_val, b_val)\n        results.append((swapped_a, swapped_b))\n\n    # Format the output exactly as specified: [[b1,a1],[b2,a2],...]\n    # with no spaces.\n    result_strings = [f\"[{res[0]},{res[1]}]\" for res in results]\n    final_output = f\"[{','.join(result_strings)}]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "3260585"}, {"introduction": "掌握了位运算的基础后，我们可以挑战更复杂的算法问题，例如高效地反转一个整数的所有二进制位。这个问题并非无足轻重，它在快速傅里叶变换（FFT）等算法中有关鍵作用。这个练习 [@problem_id:3260780] 旨在引导你使用分治策略，通过掩码和移位并行地操作位块，设计出一种高效的位反转算法，这是将算法思想直接应用于位级数据结构的一个绝佳范例。", "problem": "给定一个固定宽度为 $32$ 位的原始数据类型“无符号整数”。根据定义，一个 $32$ 位无符号整数是任何满足 $0 \\le x \\le 2^{32}-1$ 的整数 $x$，其二进制表示为一个位序列 $b_{31}b_{30}\\dots b_{1}b_{0}$，其中每个 $b_{i} \\in \\{0,1\\}$ 且 $x = \\sum_{i=0}^{31} b_{i} \\cdot 2^{i}$。$x$ 的位反转是整数 $y$，其二进制表示为 $b_{0}b_{1}\\dots b_{30}b_{31}$，等价于 $y = \\sum_{i=0}^{31} b_{i} \\cdot 2^{31-i}$。\n\n任务：从第一性原理出发，高效地实现一个计算 $32$ 位无符号整数位反转的函数，并为给定的测试套件输出结果。只能使用在 $32$ 位字上的字级位运算和定宽算术，即位与 ($AND$)、位或 ($OR$)、位异或 ($XOR$)、位非 ($NOT$) 以及逻辑移位（$\\ll$ 和 $\\gg$）。算法设计必须在标准字长随机存取机（字长 $w = 32$）上以 $O(1)$ 的字操作运行，并且不能遍历所有单个位。函数必须返回一个无符号的 $32$ 位结果，即结果对 $2^{32}$ 取模。\n\n在您的推理和设计中必须依赖的基础原理：\n- 二进制位置表示法 $x = \\sum_{i=0}^{31} b_{i} \\cdot 2^{i}$，其中 $b_{i} \\in \\{0,1\\}$。\n- 在 $32$ 位字上，字级位运算 $AND$、$OR$、$XOR$、$NOT$ 和定宽逻辑移位 $\\ll$ 与 $\\gg$ 的语义。\n- 代数事实：掩码操作选择位的子集，移位 $k$ 个位置在定宽字内相当于乘以或除以 $2^{k}$，并丢弃溢出的位。\n\n输入：无外部输入。您的程序必须嵌入并处理以下 $32$ 位无符号整数的测试套件：\n- $0$\n- $1$\n- $2^{32}-1$（即 $4294967295$）\n- $43261596$\n- $2863311530$（即 $0xAAAAAAAA$）\n- $15$\n- $2147483649$（即 $0x80000001$）\n- $65535$（即 $0x0000FFFF$）\n- $4042322160$（即 $0xF0F0F0F0$）\n\n输出：对于上面按序列出的每个测试值 $x$，计算其定义的位反转 $y$，并将其解释为 $32$ 位无符号整数。您的程序应生成单行输出，其中包含一个逗号分隔的十进制整数列表，用方括号括起来，不含空格，例如，对于九个测试值，按顺序为 $[r_1,r_2,\\dots,r_9]$。\n\n答案类型：每个项目都是一个整数。此问题不涉及物理单位或角度。\n\n要求与限制摘要：\n- 实现一个函数，映射 $x \\mapsto y$，其中 $y$ 是 $x$ 的 $32$ 位位反转。\n- 只能使用在 $32$ 位字上的字级位运算和定宽逻辑移位。\n- 算法必须以 $O(1)$ 的字操作运行，且不能按位遍历。\n- 应用模 $2^{32}$ 语义以确保最终结果是一个 $32$ 位无符号整数。", "solution": "该问题是有效的。这是一个定义明确的计算任务，基于计算机科学中二进制算术和位运算的基本原理。所有提供的定义、约束和数据都是一致、完整且可形式化为一个可解问题的。\n\n任务是计算一个 $32$ 位无符号整数 $x$ 的位反转。一个二进制表示为 $b_{31}b_{30}\\dots b_{1}b_{0}$ 的整数 $x$（定义为 $x = \\sum_{i=0}^{31} b_{i} \\cdot 2^{i}$）必须被转换为一个具有反转二进制表示 $b_{0}b_{1}\\dots b_{30}b_{31}$ 的整数 $y$（定义为 $y = \\sum_{i=0}^{31} b_{i} \\cdot 2^{31-i}$）。实现被限制为只能使用字级位运算（$AND$、$OR$、$XOR$、$NOT$）和逻辑移位（$\\ll, \\gg$），并且对于 $32$ 位的字长，必须在 $O(1)$ 的字操作内完成，排除了逐位迭代的算法。\n\n一个朴素的方法是迭代 $i$ 从 $0$ 到 $31$，提取 $x$ 的第 $i$ 位，并将其放置到结果变量的第 $(31-i)$ 位上。这需要一个 $32$ 次迭代的循环，使其成为一个 $O(w)$ 算法，其中 $w=32$ 是字宽。该方法被问题的约束明确禁止。\n\n所要求的高效算法基于分治原则，通过交换逐渐变小的相邻位块来分阶段执行反转。对于一个 $32$ 位的字，这需要 $\\log_2(32) = 5$ 个阶段。每个阶段使用常数数量的位移、掩码和逻辑运算，因此总复杂度为 $O(\\log_2 w)$，对于固定的字长 $w=32$ 来说这是一个常数。这些操作在整个 $32$ 位字上同时执行。\n\n算法过程如下，从输入整数 $x$ 开始：\n\n1.  **阶段 1：交换相邻的 16 位块。**\n    将最高位的 $16$ 位（$b_{31}\\dots b_{16}$）与最低位的 $16$ 位（$b_{15}\\dots b_{0}$）交换。这通过将数字逻辑右移 $16$ 位以将上半部分下移，以及逻辑左移 $16$ 位以将下半部分上移，然后用位或（$OR$）组合结果来实现。对于一个 $32$ 位的字，这可以写成：\n    $$x \\leftarrow (x \\gg 16) \\lor (x \\ll 16)$$\n    此步骤后，位顺序为 $b_{15}b_{14}\\dots b_{0}b_{31}b_{30}\\dots b_{16}$。\n\n2.  **阶段 2：交换相邻的 8 位块。**\n    在每个现已交换的 $16$ 位段内，交换相邻的 $8$ 位块。此操作在整个 $32$ 位字上执行。我们使用一个掩码来隔离需要移动的位。掩码 $0x00FF00FF$ 选择右移后处于正确最终位置的 $8$ 位块，而其位补码 $0xFF00FF00$ 则选择用于左移的块。\n    $$x \\leftarrow ((x \\gg 8) \\land 0x00FF00FF) \\lor ((x \\ll 8) \\land 0xFF00FF00)$$\n    位顺序变为 $b_{7}\\dots b_{0}b_{15}\\dots b_{8}b_{23}\\dots b_{16}b_{31}\\dots b_{24}$。\n\n3.  **阶段 3：交换相邻的 4 位块（半字节）。**\n    此阶段在每个 $8$ 位段内交换相邻的 $4$ 位块，同样作用于整个字。使用掩码 $0x0F0F0F0F$ 和 $0xF0F0F0F0$。\n    $$x \\leftarrow ((x \\gg 4) \\land 0x0F0F0F0F) \\lor ((x \\ll 4) \\land 0xF0F0F0F0)$$\n\n4.  **阶段 4：交换相邻的 2 位块。**\n    此阶段在每个 $4$ 位段内交换相邻的位对。使用掩码 $0x33333333$（二进制 $0011\\dots$）和 $0xCCCCCCCC$（二进制 $1100\\dots$）。\n    $$x \\leftarrow ((x \\gg 2) \\land 0x33333333) \\lor ((x \\ll 2) \\land 0xCCCCCCCC)$$\n\n5.  **阶段 5：交换相邻的 1 位块。**\n    最后阶段交换所有相邻的位（奇数索引位与偶数索引位）。使用掩码 $0x55555555$（二进制 $0101\\dots$）和 $0xAAAAAAAA$（二进制 $1010\\dots$）。\n    $$x \\leftarrow ((x \\gg 1) \\land 0x55555555) \\lor ((x \\ll 1) \\land 0xAAAAAAAA)$$\n\n经过这五个阶段后，原始整数 $x$ 的位被完全反转，得到期望的结果 $y$。实现将使用 `numpy.uint32` 来确保所有运算都符合定宽 $32$ 位无符号算术的语义。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes bit-reversals for a test suite of 32-bit unsigned integers\n    and prints the results in the specified format.\n    \"\"\"\n\n    def reverse_bits(x: int) - int:\n        \"\"\"\n        Computes the bit-reversal of a 32-bit unsigned integer using a\n        5-stage divide-and-conquer algorithm with word-level bitwise operations.\n        This algorithm runs in O(1) word operations for a fixed word size.\n\n        Args:\n            x: An integer to be treated as a 32-bit unsigned value.\n\n        Returns:\n            The bit-reversed integer as a 32-bit unsigned value.\n        \"\"\"\n        # Convert to numpy.uint32 to enforce 32-bit unsigned arithmetic.\n        # This correctly handles shifts and overflows as per a 32-bit word,\n        # which is fundamental to the algorithm's correctness.\n        n = np.uint32(x)\n\n        # Stage 1: Swap adjacent 16-bit blocks.\n        # The expression (n >> 16) moves the upper 16 bits to the lower half,\n        # and (n  16) moves the lower 16 bits to the upper half.\n        # The bitwise OR combines them.\n        n = (n >> np.uint32(16)) | (n  np.uint32(16))\n\n        # Stage 2: Swap adjacent 8-bit blocks within each 16-bit block.\n        # The mask 0x00FF00FF isolates the even-indexed 8-bit blocks after a right shift.\n        # The mask 0xFF00FF00 isolates the odd-indexed 8-bit blocks after a left shift.\n        n = ((n >> np.uint32(8))  np.uint32(0x00FF00FF)) | ((n  np.uint32(8))  np.uint32(0xFF00FF00))\n\n        # Stage 3: Swap adjacent 4-bit blocks (nybbles) within each 8-bit block.\n        # The masks select alternating nybbles for shifting and merging.\n        n = ((n >> np.uint32(4))  np.uint32(0x0F0F0F0F)) | ((n  np.uint32(4))  np.uint32(0xF0F0F0F0))\n\n        # Stage 4: Swap adjacent 2-bit blocks.\n        # The masks 0x33333333 (0011...b) and 0xCCCCCCCC (1100...b) facilitate the swap.\n        n = ((n >> np.uint32(2))  np.uint32(0x33333333)) | ((n  np.uint32(2))  np.uint32(0xCCCCCCCC))\n\n        # Stage 5: Swap adjacent 1-bit blocks.\n        # The masks 0x55555555 (0101...b) and 0xAAAAAAAA (1010...b) swap odd/even bits.\n        n = ((n >> np.uint32(1))  np.uint32(0x55555555)) | ((n  np.uint32(1))  np.uint32(0xAAAAAAAA))\n\n        # Convert back to a standard Python int for the final list formatting.\n        return int(n)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        0,\n        1,\n        4294967295,  # 2**32 - 1\n        43261596,\n        2863311530,  # 0xAAAAAAAA\n        15,\n        2147483649,  # 0x80000001\n        65535,       # 0x0000FFFF\n        4042322160,  # 0xF0F0F0F0\n    ]\n\n    results = []\n    for case in test_cases:\n        result = reverse_bits(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3260780"}]}