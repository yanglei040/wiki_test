{"hands_on_practices": [{"introduction": "理论知识只有在实践中才能得到检验。本节我们将通过一系列动手练习，深化对开放寻址中删除操作的理解。第一个练习是一个动手谜题，要求你像一名散列表的“机械师”一样思考，通过规划一系列插入和删除操作，以最低的成本达到一个特定的状态。这个练习将巩固你对“墓碑”如何产生以及在线性探测中基本探测成本的理解。[@problem_id:3227311]", "problem": "考虑一个使用开放寻址法和线性探测法的散列表。该表的大小为 $m=7$，槽位索引为 $0,1,2,3,4,5,6$。键为整数，散列函数为 $h(k)=k \\bmod 7$。一次成功的删除操作会将已删除的槽位标记为墓碑（记为 $\\dagger$），而不是将其置空；对某个键的搜索从 $h(k)$ 开始，并对后续索引（模7）进行线性探测，直到找到该键或一个空槽位，而墓碑不会终止搜索。插入一个键 $k$ 时，从 $h(k)$ 开始进行线性探测，直到找到一个空槽位或第一个墓碑，然后将该键存储在那里。成本模型是开放寻址法的标准模型：在搜索、插入或删除过程中的每次槽位检查计为一次探测。\n\n从一个空表开始，你可以选择任意整数键，并执行任意的插入和删除操作序列。你的目标是达到一个最终状态，在该状态下，表中恰好在槽位 $2$、$4$ 和 $6$ 处有墓碑，而所有其他槽位均为空，且表中没有剩余的活动键。在上述规则下，要达到这样的最终状态，在整个操作序列中所需的槽位检查（探测）的最小总数是多少？请给出精确的整数答案，不带单位。", "solution": "问题要求，将一个大小为 $m=7$ 的空散列表转换到一个在槽位 $2$、$4$ 和 $6$ 处有墓碑，而所有其他槽位均为空的状态，所需的槽位检查（探测）的最小总数是多少。该散列表使用开放寻址法和线性探测法，散列函数为 $h(k) = k \\bmod 7$。\n\n首先，我们来分析创建单个墓碑的过程。要在槽位 $i$ 处创建一个墓碑，需要先将一个键插入该槽位，然后删除同一个键。这至少需要一次插入和一次删除操作。\n\n任何操作（插入、搜索或删除）的成本定义为所检查的槽位数。由于每个操作都必须检查至少一个槽位，因此任何单个操作的成本至少为 $1$。因此，创建一个墓碑的最小成本至少是 $1$（用于插入）$+ 1$（用于删除）$= 2$ 次探测。\n\n我们的目标是在槽位 $2$、$4$ 和 $6$ 处创建三个不同的墓碑。由于每个墓碑的创建至少需要两次探测，并且为一个墓碑进行的操作不会免除为另一个墓碑进行操作的需要，因此创建三个墓碑的总探测次数必须至少为 $3 \\times 2 = 6$。这就确定了总成本的一个下限。\n\n现在，我们必须确定这个 $6$ 次探测的下限是否可以实现。为此，我们需要构造一个操作序列，该序列能达到目标状态，且总成本恰好为 $6$。总成本为 $6$ 要求三次必要的插入和三次必要的删除操作的成本都恰好为 $1$ 次探测。\n\n让我们分析一下插入和删除的成本。\n插入键 $k$ 的成本是从索引 $h(k)$ 开始探测直到找到一个可用槽位的探测次数。可用槽位定义为空槽位或第一个包含墓碑的槽位。如果索引 $h(k)$ 处的槽位本身就是可用的，则成本可最小化为 $1$。\n删除位于槽位 $i$ 的键 $k$ 的成本是从 $h(k)$ 开始探测直到到达槽位 $i$ 的探测次数。如果键 $k$ 的放置位置满足 $h(k)=i$，则成本可最小化为 $1$。\n\n为了使在槽位 $i$ 处创建墓碑的插入和删除成本都为 $1$，我们应该选择一个键 $k$ 使得 $h(k)=i$。让我们基于这个原则设计一个操作序列。我们需要在槽位 $i_1=2$、$i_2=4$ 和 $i_3=6$ 处创建墓碑。\n\n我们可以选择三个不同的键 $k_1, k_2, k_3$，使其散列值分别对应于期望的墓碑位置。让我们选择 $k_1=2$、$k_2=4$ 和 $k_3=6$。\n$h(k_1) = 2 \\bmod 7 = 2$\n$h(k_2) = 4 \\bmod 7 = 4$\n$h(k_3) = 6 \\bmod 7 = 6$\n\n考虑以下操作序列，从一个空表开始。\n\n1.  **插入键 $k_1=2$**：探测从 $h(2)=2$ 开始。槽位 $2$ 是空的。键 $2$ 被放置在槽位 $2$ 中。\n    探测次数：$1$。\n    表状态：`[ , , 2, , , , ]`。\n    累计探测次数：$1$。\n\n2.  **插入键 $k_2=4$**：探测从 $h(4)=4$ 开始。槽位 $4$ 是空的。键 $4$ 被放置在槽位 $4$ 中。\n    探测次数：$1$。\n    表状态：`[ , , 2, , 4, , ]`。\n    累计探测次数：$1+1=2$。\n\n3.  **插入键 $k_3=6$**：探测从 $h(6)=6$ 开始。槽位 $6$ 是空的。键 $6$ 被放置在槽位 $6$ 中。\n    探测次数：$1$。\n    表状态：`[ , , 2, , 4, , 6]`。\n    累计探测次数：$2+1=3$。\n\n此时，所有必要的键都已在表中。现在我们删除它们以创建墓碑。\n\n4.  **删除键 $k_1=2$**：搜索从 $h(2)=2$ 开始。在第一个探测的槽位，即索引 $2$ 处，找到了键 $2$。该槽位被标记为墓碑（$\\dagger$）。\n    探测次数：$1$。\n    表状态：`[ , , †, , 4, , 6]`。\n    累计探测次数：$3+1=4$。\n\n5.  **删除键 $k_2=4$**：搜索从 $h(4)=4$ 开始。在槽位 $4$ 处找到键 $4$。该槽位被标记为墓碑。\n    探测次数：$1$。\n    表状态：`[ , , †, , †, , 6]`。\n    累计探测次数：$4+1=5$。\n\n6.  **删除键 $k_3=6$**：搜索从 $h(6)=6$ 开始。在槽位 $6$ 处找到键 $6$。该槽位被标记为墓碑。\n    探测次数：$1$。\n    表状态：`[ , , †, , †, , †]`。\n    累计探测次数：$5+1=6$。\n\n表的最终状态是在槽位 $2$、$4$ 和 $6$ 处有墓碑，而所有其他槽位（$0, 1, 3, 5$）均为空。这完全符合问题的要求。该序列的总探测次数为 $6$。\n\n既然我们已经确定了 $6$ 次探测的下限，并展示了一个实现此成本的操作序列，那么最小总探测次数必定是 $6$。任何其他的键选择或操作顺序都无法得到更低的成本。例如，使用一个散列到与其最终位置 $i$ 不同的值（即 $h(k) \\neq i$）的键 $k$，将导致插入（由于冲突或槽位已被占用）和删除的探测次数都大于 $1$，从而增加总成本。特定的插入规则（在第一个墓碑处停止）不会改变这个最优策略，因为成本最小的路径涉及向空槽位中插入。", "answer": "$$\\boxed{6}$$", "id": "3227311"}, {"introduction": "虽然“墓碑”解决了删除问题，但它们也引入了自身的性能问题。这个练习将我们的重点从操作机制转向理论极限。你将推导出一个散列表在保证新插入操作总能成功的前提下，可以容纳的“墓碑”数量的上限，从而将二次探测的数学特性与实际的系统性能保证联系起来。[@problem_id:3227267]", "problem": "一个大小为 $m$ 的哈希表使用开放定址法，其二次探测由以下探测序列定义：\n$$\nh(k,i) \\equiv \\big(h(k,0) + i^2\\big) \\bmod m \\quad \\text{for } i=0,1,2,\\dots,\n$$\n其中 $m$ 是一个奇素数，且 $h(k,0) \\in \\{0,1,\\dots,m-1\\}$ 是键 $k$ 的基地址。删除操作通过在被删除的单元格中放置一个墓碑来实现。在查找过程中，墓碑被视作已占用（探测会继续），而在插入过程中，实现仅会将键插入到真正为空的单元格中；在执行周期性重建之前，墓碑单元格不会被重用。\n\n假设在某个时刻，表中恰好有 $T$ 个墓碑和 $m-T$ 个真正为空的单元格（没有活动的键）。当且仅当键 $k$ 的探测序列遇到至少一个真正为空的单元格时，插入操作才会成功。\n\n请从基本原理出发，推导出最大的整数 $T_{\\max}(m)$，使得无论这 $T_{\\max}(m)$ 个墓碑如何放置在表中，也无论插入哪个键（即对于任何基地址 $h(k,0)$），插入操作都保证成功。你的最终答案必须是一个关于 $m$ 的闭式表达式，并且不得包含不等式或等式。", "solution": "问题要求找出最大的整数 $T_{\\max}(m)$，它代表墓碑的数量，使得向大小为 $m$ 的哈希表中插入一个键的操作保证成功，无论这 $T_{\\max}(m)$ 个墓碑的放置位置以及被插入键的初始哈希值如何。\n\n当且仅当待插入键的探测序列完全由被墓碑占用的位置组成时，插入操作才会失败。如果一个探测序列不可能完全由墓碑组成，那么插入操作就保证成功。\n\n该哈希表使用开放定址法和二次探测。表的大小为 $m$，它是一个奇素数。对于一个基地址为 $h(k,0) = h_0$ 的键 $k$，其探测序列由以下索引序列定义：\n$$h(k,i) = (h_0 + i^2) \\bmod m, \\quad \\text{for } i=0, 1, 2, \\dots$$\n令 $S_{h_0}$ 为该探测序列访问过的不同表索引的集合。被访问的位置由添加到基地址 $h_0$ 的偏移量集合 $\\{i^2 \\bmod m\\}$ 决定。我们必须首先确定这个集合的大小，即 $|S_{h_0}|$。\n\n$S_{h_0}$ 的大小等于 $(h_0 + i^2) \\bmod m$ 的不同值的数量。由于加上 $h_0$ 并对 $m$ 取模只是对索引进行循环移位，因此被访问位置集合的大小等于唯一偏移值集合 $\\{i^2 \\bmod m \\text{ for } i=0, 1, 2, \\dots\\}$ 的大小。\n\n我们计算 $i \\in \\{0, 1, \\dots, m-1\\}$ 时 $i^2 \\bmod m$ 的不同值的数量。\n1. 对于 $i=0$，我们有 $0^2 \\equiv 0 \\pmod m$。这提供了一个唯一的值。\n2. 对于 $i \\in \\{1, 2, \\dots, m-1\\}$，我们研究何时两个平方数模 $m$ 同余。令 $x, y \\in \\{1, 2, \\dots, m-1\\}$。同余式 $x^2 \\equiv y^2 \\pmod m$ 等价于 $x^2 - y^2 \\equiv 0 \\pmod m$，可以因式分解为 $(x-y)(x+y) \\equiv 0 \\pmod m$。\n因为 $m$ 是一个素数，这意味着 $m$ 必须整除 $(x-y)$ 或者 $m$ 必须整除 $(x+y)$。\n- 如果 $m | (x-y)$，因为 $x, y \\in \\{1, \\dots, m-1\\}$，所以必有 $x=y$。\n- 如果 $m | (x+y)$，因为 $2 \\le x+y \\le 2(m-1)$，所以必有 $x+y=m$ 或 $x+y=2m$。后者仅在 $x=y=m$ 时可能，但这不在我们的范围内。所以，$x+y=m$。\n\n这意味着对于任何 $x \\in \\{1, \\dots, m-1\\}$，它的平方 $x^2 \\pmod m$ 与 $y=m-x$ 的平方相同，因为 $(m-x)^2 = m^2 - 2mx + x^2 \\equiv x^2 \\pmod m$。\n非零值 $\\{1, \\dots, m-1\\}$ 可以被划分为 $(m-1)/2$ 个形如 $\\{x, m-x\\}$ 的数对。例如，$\\{1, m-1\\}, \\{2, m-2\\}, \\dots, \\{ (m-1)/2, (m+1)/2 \\}$。每个数对中的所有元素模 $m$ 的平方都相同。\n对于 $x \\in \\{1, 2, \\dots, (m-1)/2\\}$，其平方值 $x^2$ 模 $m$ 都是不同的。如果对于 $1 \\le x  y \\le (m-1)/2$ 有 $x^2 \\equiv y^2 \\pmod m$，那么 $y-x \\not\\equiv 0 \\pmod m$ 并且 $y+x \\not\\equiv 0 \\pmod m$，因为 $2  x+y  m-1  m$，这导致矛盾。\n因此，对于 $i^2 \\pmod m$ 恰好有 $(m-1)/2$ 个不同的非零值。这些是模 $m$ 的二次剩余。\n\n将单个值 $0$（来自 $i=0$）与 $(m-1)/2$ 个非零值结合，得到 $i^2 \\pmod m$ 的不同偏移总数为 $1 + \\frac{m-1}{2} = \\frac{m+1}{2}$。\n因此，对于奇素数模 $m$ 的二次探测，任何探测序列都会恰好访问 $|S_{h_0}| = \\frac{m+1}{2}$ 个不同的单元格。\n\n如果对于 $T$ 个墓碑的任何放置方式和任何起始哈希值 $h_0$，探测序列 $S_{h_0}$ 都不是墓碑位置集合的子集，那么插入操作就保证成功。表中只包含墓碑和空单元格。如果探测序列中的一个位置不是墓碑，它就必须是空的，插入操作就会成功。\n\n令 $N_S = \\frac{m+1}{2}$ 为任何探测序列中的单元格数量。\n令 $T$ 为表中的墓碑数量。\n要使插入失败，其探测序列中的所有 $N_S$ 个单元格都必须被墓碑占据。这只有在墓碑数量至少等于探测序列中的单元格数量时才可能，即 $T \\ge N_S$。\n\n反之，如果墓碑数量 $T$ 严格小于任何探测序列中的单元格数量，即 $T  N_S$，那么一个探测序列的所有单元格都不可能都是墓碑。根据鸽巢原理，如果一个探测序列访问 $N_S$ 个不同的单元格，而表中只有 $T  N_S$ 个墓碑，那么被访问的单元格中至少有一个不能是墓碑。由于表中没有其他键，这个单元格必须是空的。因此，插入操作保证成功。\n\n保证成功的条件是 $T  \\frac{m+1}{2}$。\n由于 $T$ 必须是一个整数，满足此不等式的最大整数 $T$ 是\n$$T = \\left\\lfloor \\frac{m+1}{2} - \\epsilon \\right\\rfloor$$\n其中 $\\epsilon$ 是一个无穷小的正数。由于 $m$ 是一个奇素数，$m+1$ 是一个偶数，所以 $\\frac{m+1}{2}$ 是一个整数。严格小于 $\\frac{m+1}{2}$ 的最大整数是 $\\frac{m+1}{2} - 1$。\n$$T_{\\max}(m) = \\frac{m+1}{2} - 1 = \\frac{m+1-2}{2} = \\frac{m-1}{2}$$\n\n为了确认这是最大可能值，我们必须证明当 $T = T_{\\max}(m) + 1$ 时，成功不是必然的。\n令 $T = \\frac{m-1}{2} + 1 = \\frac{m+1}{2}$。\n用这么多的墓碑，我们可以构建一个插入失败的场景。选择一个任意的基地址，比如 $h_0=0$。探测序列 $S_0$ 会访问 $\\frac{m+1}{2}$ 个不同的单元格。我们可以将这 $T = \\frac{m+1}{2}$ 个墓碑精确地放置在这 $\\frac{m+1}{2}$ 个位置上。然后，一个 $h(k,0)=0$ 的键的插入将会失败，因为它的整个探测序列都由墓碑组成。\n由于当 $T=\\frac{m+1}{2}$ 时，存在一种墓碑放置方式和一种键的选择使得插入失败，因此对于这个 $T$ 值，成功不是必然的。\n\n因此，保证插入成功的最大整数 $T_{\\max}(m)$ 是 $\\frac{m-1}{2}$。", "answer": "$$\\boxed{\\frac{m-1}{2}}$$", "id": "3227267"}, {"introduction": "对于“墓碑”的一个常见担忧是，一个“糟糕”的“墓碑”布局是否可能将探测序列困在一个循环中，使其无法找到已知存在的空槽。这个概念性问题将作为双重散列的一个“迷思破解者”。它将促使你依据探测序列的基本数学保证，来判断这种“陷阱”是否真的可能出现。[@problem_id:3227213]", "problem": "给定一个使用双重哈希的开放定址哈希表。该表的大小为 $m$，主哈希函数为 $h_1(k)$，辅助（步长）哈希函数为 $h_2(k)$。对于一个键 $k$，探测序列定义为\n$$\ni_t \\equiv \\big(h_1(k) + t \\cdot h_2(k)\\big) \\bmod m \\quad \\text{for} \\quad t \\in \\{0,1,2,\\dots\\}.\n$$\n删除操作不会清空单元格；而是设置一个特殊的墓碑标记 $\\mathsf{T}$，它既不是“空的”，也不是“被任何键占用”。一个实际为空的单元格用 $\\mathsf{E}$ 表示。插入算法采用标准的“记住第一个墓碑”规则：\n- 它按顺序扫描 $i_0,i_1,\\dots$，如果遇到键 $k$ 或空单元格 $\\mathsf{E}$，则提前停止。\n- 它记录遇到的第一个墓碑 $\\mathsf{T}$ 的索引（如果有的话）。\n- 如果在找到键 $k$ 之前找到了一个空单元格 $\\mathsf{E}$，它会插入到记录的最早的 $\\mathsf{T}$ 位置（如果存在）；否则插入到该 $\\mathsf{E}$ 位置。\n- 如果在最多 $m$ 次探测后没有找到空单元格 $\\mathsf{E}$ 且键 $k$ 不存在，它会插入到记录的最早的 $\\mathsf{T}$ 位置；如果没有记录墓碑，则报告哈希表已满。\n\n假设有以下标准设计约束：\n- $m$ 是一个质数，\n- 对于每个 $k$，$h_2(k) \\in \\{1,2,\\dots,m-1\\}$（特别地，$h_2(k) \\not\\equiv 0 \\pmod m$）。\n\n众所周知，这些约束意味着对于任何固定的键 $k$，探测序列 $i_0,i_1,\\dots,i_{m-1}$ 是 $m$ 个表索引的一个排列。\n\n问题：在上述假设下，是否存在任意有限次的删除序列，能够产生一种墓碑的配置，形成一个“墓碑循环”，从而在以下意义上捕获某个键 $k$ 的后续插入探测序列：即使表中某处至少存在一个实际为空的单元格 $\\mathsf{E}$，对 $k$ 的插入操作也无法以有效放置而终止？\n\n选择正确的选项。\n\nA. 不会。因为 $i_0,i_1,\\dots,i_{m-1}$ 会精确地访问每个索引一次，并且如果未遇到 $\\mathsf{E}$，插入操作会重用第一个墓碑 $\\mathsf{T}$，所以在所述假设下，探测不会被任何墓碑的排列所困住。\n\nB. 会。墓碑可以排列成迫使探测在访问完所有 $m$ 个不同索引之前重复访问某些位置，从而创建一个无限循环，即使使用“记住第一个墓碑”规则也无法终止。\n\nC. 会。墓碑通过被“跳过”而动态地改变了有效步长，这可能导致一个不与任何 $\\mathsf{E}$ 单元格相交的更短的模循环。\n\nD. 会。当负载因子 $\\alpha$ 超过某个绝对常数 $c \\in (0,1)$ 时，即使在所述假设下，捕获探测的墓碑循环也会以非零概率出现。", "solution": "描述了使用双重哈希的开放定址、用于删除的墓碑以及特定插入算法的问题陈述是有效的、自洽的且科学上合理的。它定义明确，没有矛盾或歧义。\n\n问题在于，一个删除序列是否能创造出一种墓碑配置来“捕获”一个插入探测。对于一个键 $k$ 的探测，如果尽管表中至少存在一个空单元格（$\\mathsf{E}$），插入算法仍无法放置该键，则称其被“捕获”。\n\n让我们分析将键 $k$ 插入大小为 $m$ 的哈希表的过程。\n\n**1. 探测序列的生成**\n探测序列由以下公式生成：\n$$i_t \\equiv \\big(h_1(k) + t \\cdot h_2(k)\\big) \\pmod m$$\n对于探测尝试 $t = 0, 1, 2, \\dots$。\n\n问题陈述了两个关键约束：\n- 表大小 $m$ 是一个质数。\n- 对于任意键 $k$，辅助哈希函数产生 $h_2(k) \\in \\{1, 2, \\dots, m-1\\}$。这意味着 $h_2(k)$ 不是 $m$ 的倍数。\n\n因为 $m$ 是质数，所以范围 $\\{1, 2, \\dots, m-1\\}$ 中的任何整数 $h_2(k)$ 都与 $m$ 互质，即 $\\gcd(h_2(k), m) = 1$。\n探测序列 $i_t$ 是一个模 $m$ 的算术级数。数论中的一个已知结果表明，如果一个模 $m$ 算术级数的步长（这里是 $h_2(k)$）与模数 $m$ 互质，那么该级数将在重复之前恰好访问每个模 $m$ 的余数一次。\n因此，索引序列 $i_0, i_1, \\dots, i_{m-1}$ 构成了所有表索引集合 $\\{0, 1, \\dots, m-1\\}$ 的一个排列。\n关键在于，这个探测序列的生成仅依赖于键 $k$ 和哈希函数 $h_1$ 和 $h_2$。它完全独立于表单元格的当前状态（无论它们包含键、墓碑 $\\mathsf{T}$ 还是为空 $\\mathsf{E}$）。“墓碑循环”会改变探测序列的说法从根本上是错误的。对于给定的键 $k$，该序列是*先验*固定的。\n\n**2. 插入算法与终止**\n对于键 $k$ 的插入算法涉及扫描索引为 $i_0, i_1, i_2, \\dots$ 的单元格。算法的终止由规则决定：“如果遇到键 $k$ 或空单元格 $\\mathsf{E}$，则提前停止。”\n\n问题预设了表中某处至少有一个空单元格 $\\mathsf{E}$。\n根据第1点，我们已经确定探测序列 $i_0, i_1, \\dots, i_{m-1}$ 将精确地访问表中的每一个单元格一次。由于至少有一个单元格是空的，因此从数学上保证该探测序列在最多 $m$ 步内（即对于某个 $t \\in \\{0, 1, \\dots, m-1\\}$）会遇到一个空单元格 $\\mathsf{E}$。\n\n当在某个索引 $i_t$ 处遇到第一个空单元格 $\\mathsf{E}$ 时，扫描的停止条件被满足，扫描终止。\n终止后，算法继续放置键 $k$。放置规则是：“如果找到了一个空单元格 $\\mathsf{E}$……，它会插入到记录的最早的 $\\mathsf{T}$ 位置（如果存在）；否则插入到该 $\\mathsf{E}$ 位置。”这个规则保证了总能为插入确定一个有效的位置。\n\n只有当表被报告为已满时，插入才会失败。发生这种情况的条件是：“如果在最多 $m$ 次探测后没有找到空单元格 $\\mathsf{E}$……”。然而，如上所述，如果表中至少存在一个 $\\mathsf{E}$ 单元格，这个条件就永远不会满足。\n\n因此，插入探测不可能被“捕获”。保证覆盖所有表索引的探测序列与在找到空单元格时终止的插入算法相结合，使得这种捕获成为不可能。问题的答案必须是“不会”。\n\n**3. 评估选项**\n\n**A. 不会。因为 $i_0,i_1,\\dots,i_{m-1}$ 会精确地访问每个索引一次，并且如果未遇到 $\\mathsf{E}$，插入操作会重用第一个墓碑 $\\mathsf{T}$，所以在所述假设下，探测不会被任何墓碑的排列所困住。**\n该选项正确地得出结论“不会”。其提供的主要理由，即探测序列 $i_0, i_1, \\dots, i_{m-1}$ 会精确地访问每个索引一次，是正确论证的核心。此属性保证了现有的空单元格 $\\mathsf{E}$ 将被找到，从而确保搜索的终止并导致成功插入。理由的第二部分在措辞上（“如果未遇到 $\\mathsf{E}$”）略有不精确，但这并不影响要点。关键事实是，如果存在空位，搜索*必定*会找到一个 `E`。因为结论正确且基本推理合理，所以这是最佳选项。\n结论：**正确**。\n\n**B. 会。墓碑可以排列成迫使探测在访问完所有 $m$ 个不同索引之前重复访问某些位置，从而创建一个无限循环，即使使用“记住第一个墓碑”规则也无法终止。**\n该选项错误地得出结论“会”。其推理存在缺陷。它声称墓碑可以改变探测序列，导致其“在访问完所有 $m$ 个不同索引之前重复访问某些位置”。如第1点所述，探测序列完全由 $k$、$h_1$、$h_2$ 和 $m$ 决定，完全不受表单元格内容的影响。问题中的约束保证了前 $m$ 次探测 $i_0, \\dots, i_{m-1}$ 都是不同的。因此，该选项的前提是错误的。\n结论：**不正确**。\n\n**C. 会。墓碑通过被“跳过”而动态地改变了有效步长，这可能导致一个不与任何 $\\mathsf{E}$ 单元格相交的更短的模循环。**\n该选项错误地得出结论“会”。与选项 B 类似，其推理基于一个错误的前提。算法并不会以一种修改探测序列本身的方式“跳过”墓碑。对于每一步 $t$，都会计算索引 $i_t$，并检查该索引处的单元格。对于给定的键 $k$，步长 $h_2(k)$ 在整个探测过程中是恒定的。表单元格的状态不会“动态地改变有效步长”。因此，其推理是谬误的。\n结论：**不正确**。\n\n**D. 会。当负载因子 $\\alpha$ 超过某个绝对常数 $c \\in (0,1)$ 时，即使在所述假设下，捕获探测的墓碑循环也会以非零概率出现。**\n该选项错误地得出结论“会”。其援引负载因子 $\\alpha$ 的推理与被“捕获”的逻辑可能性无关。虽然高密度的墓碑和键（高有效负载因子）会导致更长的平均探测长度并降低性能，但它不能从根本上“捕获”问题中定义的探测。探测序列访问每个单元格（包括任何现有的空单元格）的数学保证在任何负载因子下都成立。这是一个关于可能性而非概率或性能的问题，在所述规则下，捕获情景在逻辑上是不可能的。\n结论：**不正确**。", "answer": "$$\\boxed{A}$$", "id": "3227213"}]}