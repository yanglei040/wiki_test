{"hands_on_practices": [{"introduction": "我们从一个有趣的思想实验开始，它将揭示最大堆的一个基本但并非显而易见的性质。这个练习不要求复杂的计算或编程，而是要求你基于最大堆的定义进行严谨的逻辑推理。通过解决这个问题 [@problem_id:3219605]，你将对堆的结构性约束有更深刻的直观理解。", "problem": "考虑一个大小为 $n \\geq 2$ 的输入数组 $A$，其中包含 $n$ 个不同的实数键。该数组是这些键的一个均匀随机排列。二叉最大堆定义为一个完全二叉树，其中对于每个键为 $k_{\\text{parent}}$ 的节点及其任意子节点（键为 $k_{\\text{child}}$），都满足堆序性质 $k_{\\text{parent}} \\geq k_{\\text{child}}$。在以数组为基础、索引从 $1$ 开始的标准二叉堆表示中，索引为 $i$ 的节点其子节点位于索引 $2i$ 和 $2i+1$ 处（当这些索引不超过 $n$ 时）。叶节点是没有任何子节点的节点，等价于任何满足 $2i > n$ 的索引 $i$。\n\n应用标准的自底向上建堆过程 buildHeap（也称为 Floyd 建堆算法，通过从索引 $\\lfloor n/2 \\rfloor$ 向下到 $1$ 重复执行下沉操作）将数组 $A$ 转换为一个二叉最大堆。令 $m$ 表示 $A$ 中唯一的最小键。\n\n在 buildHeap 完成后，存储 $m$ 的数组位置是最终形成的最大堆中的一个叶节点，这一事件的概率（作为一个实数）的精确值是多少？请提供一个精确值，无需四舍五入。", "solution": "问题要求计算在一个数组 $A$ 上使用标准 `buildHeap` 算法将其转换为最大堆后，其中唯一的最小元素 $m$ 位于叶节点的概率。初始数组 $A$ 是 $n$ 个不同实数键的一个均匀随机排列，其中 $n \\geq 2$。\n\n首先，我们必须分析 `buildHeap` 过程完成后数组的最终状态的性质。根据定义，该过程将输入数组正确地转换为一个满足最大堆性质的数据结构。设 `buildHeap` 操作后的数组为 $A'$。\n\n二叉最大堆的性质规定，对于任何非叶节点的索引 $i$，其键必须大于或等于其子节点的键。根据问题中指定的从 $1$ 开始的索引，对于任何非叶节点索引 $i$，必须满足以下条件：\n$A'[i] \\geq A'[2i]$\n并且，如果右子节点存在（$2i+1 \\leq n$），\n$A'[i] \\geq A'[2i+1]$\n\n一个索引为 $i$ 的节点是非叶节点，当且仅当它至少有一个子节点。在一个大小为 $n$ 的数组表示的完全二叉树结构中，这等价于条件 $2i \\leq n$，即 $i \\leq \\lfloor n/2 \\rfloor$。相反，如果 $i > \\lfloor n/2 \\rfloor$，则该节点是叶节点。\n\n设 $m$ 是这 $n$ 个不同键中唯一的最小键。我们假设，为了引出矛盾，在 `buildHeap` 算法终止后，元素 $m$ 位于数组 $A'$ 中的一个非叶节点位置 $j$。\n这意味着 $A'[j] = m$ 并且 $j$ 必须满足非叶节点的条件，即 $j \\leq \\lfloor n/2 \\rfloor$。\n\n因为 $j$ 是一个非叶节点，它必须至少有一个子节点，即位于索引 $2j$ 的左子节点。该子节点位置的键是 $A'[2j]$。\n根据最大堆的性质，我们必须有 $A'[j] \\geq A'[2j]$。\n将 $A'[j] = m$ 代入，这个不等式变为 $m \\geq A'[2j]$。\n\n然而，问题陈述 $m$ 是所有 $n$ 个键中唯一的最小键，并且所有 $n$ 个键都是不同的。这意味着对于集合中的任何其他键 $k'$，都有 $m  k'$。\n键 $A'[2j]$ 是数组中的一个键。由于所有键都是不同的，$A'[2j]$ 不能等于 $m$。因此，我们必然有：\n$m  A'[2j]$。\n\n我们现在得到了一个矛盾。最大堆的性质要求 $m \\geq A'[2j]$，而 $m$ 作为唯一最小值的定义要求 $m  A'[2j]$。这两个条件不能同时成立。\n\n因此，我们的初始假设必定是错误的。唯一的最小元素 $m$ 不能位于最终最大堆中的非叶节点位置。\n堆中所有位置的集合是叶节点位置和非叶节点位置的不相交并集。如果 $m$ 的位置不是非叶节点位置，那么它必须是叶节点位置。\n\n这个结论对于任何作为最大堆的数组都成立，无论它是如何构建的。由于对任何初始排列应用 `buildHeap` 算法都会得到一个有效的最大堆，因此最小元素 $m$ 在最终配置中将始终位于叶节点。\n\n事件“存储 $m$ 的数组位置是最终形成的最大堆中的一个叶节点”是一个必然事件。对于每一个可能的初始随机排列，该事件都会发生。根据定义，必然事件的概率为 $1$。\n关于随机排列和 `buildHeap` 过程细节的信息，虽然定义了问题的背景，但最终与最小元素位置的最终属性无关，该属性仅由最大堆的静态性质决定。\n因此，概率为 $1$。", "answer": "$$\n\\boxed{1}\n$$", "id": "3219605"}, {"introduction": "在理解了堆的宏观属性后，现在是时候深入研究`buildHeap`算法的内部机制了。这个实践练习要求你精确地模拟自底向上建堆的整个过程，并追踪一个特定元素在数组中的最终位置。完成这个挑战 [@problem_id:3219649] 将极大地巩固你对`sift-down`操作和元素交换细节的掌握。", "problem": "给定任务是预测在一个数组上执行自底向上的堆构造后，起始于指定索引的元素的最终位置。所讨论的结构是一个用数组表示的二叉最大堆，采用从零开始的索引。堆属性要求，对于每个有子节点的索引 $j$，其键值必须大于或等于其每个子节点的键值。数组到树的映射关系如下：对于任何索引 $j$，其左子节点（如果存在）位于索引 $2j + 1$ 处，右子节点（如果存在）位于索引 $2j + 2$ 处。任何索引 $k  0$ 的父节点位于索引 $\\left\\lfloor \\dfrac{k - 1}{2} \\right\\rfloor$ 处。\n\n请仅从基本定义出发：二叉堆属性、上述数组表示映射关系，以及基于比较的堆作为由键值比较引出的偏序的定义。考虑标准的自底向上堆构造过程，该过程通过从内部节点到叶子节点重复使用向下调整进行局部恢复来强制满足堆属性。在对索引 $j$ 处的节点进行向下调整时，假设遵循以下确定性的比较和关系处理规则：\n- 在存在的子节点中，考虑键值最大的那个。如果两个子节点都存在且键值相等，则选择索引为 $2j + 1$ 的左子节点。\n- 仅当所选子节点的键值严格大于索引 $j$ 处节点的键值时，才在两者之间执行交换。\n- 在发生交换的子节点索引处继续此过程，当无需交换或到达叶子节点时停止。\n\n自底向上的构造过程以降序访问索引，从最后一个内部节点到根节点。最后一个内部节点的索引为 $\\left\\lfloor \\dfrac{n - 2}{2} \\right\\rfloor$，其中 $n$ 是数组长度。对于按此顺序访问的每个索引 $j$，从 $j$ 开始执行上述的向下调整。\n\n您的程序必须为每个给定的由整数数组和初始索引 $i$ 组成的对，确定在堆完全构建后，起始于索引 $i$ 的元素的最终索引位置。元素的身份必须通过其原始索引而不是其键值来跟踪，以便正确处理重复的键值。\n\n全程使用从零开始的索引。每个案例的结果都是一个整数索引。不涉及物理单位或角度。\n\n实现一个完整的、可运行的程序，使用以下测试套件，并生成最终位置，形式为单行输出，包含一个用方括号括起来的逗号分隔列表，结果顺序与测试案例相同。每个数组按字面形式给出，并指定每个索引 $i$。测试套件如下：\n- 案例 1：数组 $[\\,3,\\,1,\\,6,\\,5,\\,2,\\,4\\,]$，$i = 1$。\n- 案例 2：数组 $[\\,9,\\,7,\\,8,\\,3,\\,2,\\,1,\\,5\\,]$，$i = 6$。\n- 案例 3：数组 $[\\,1,\\,2,\\,3,\\,4\\,]$，$i = 0$。\n- 案例 4：数组 $[\\,1,\\,2,\\,2\\,]$，$i = 0$。\n- 案例 5：数组 $[\\,10,\\,9,\\,8,\\,7,\\,6,\\,5\\,]$，$i = 4$。\n- 案例 6：数组 $[\\,2,\\,2,\\,2,\\,2\\,]$，$i = 2$。\n- 案例 7：数组 $[\\,1,\\,2\\,]$，$i = 1$。\n- 案例 8：数组 $[\\,{-3},\\,{-1},\\,{-2}\\,]$，$i = 0$。\n- 案例 9：数组 $[\\,0,\\,1,\\,2,\\,3,\\,4,\\,5,\\,6\\,]$，$i = 6$。\n- 案例 10：数组 $[\\,7\\,]$，$i = 0$。\n\n您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表的结果（例如，$[r_1,r_2,\\dots,r_{10}]$），其中每个 $r_k$ 是案例 $k$ 的最终索引。", "solution": "该问题要求确定在对一个数组执行标准的自底向上最大堆构造（建堆）后，一个初始位于给定索引 $i$ 的元素的最终索引。由于为堆操作提供了精确的规则，该过程是确定性的。\n\n为解决此问题，我们必须模拟堆的构造过程，同时跟踪我们感兴趣的特定元素的位置。由于数组可能包含重复的键值，元素的身份必须与其原始位置绑定。我们通过将输入的键数组（例如 `arr`）转换为一个增强的对偶数组来实现这一点。原始数组中索引 $k$ 处的每个元素都表示为一个元组 $(key, original\\_index)$，即 $(arr[k], k)$。所有后续操作都在这个增强数组上进行。\n\n堆构造算法，通常称为 `build_heap`，在一个大小为 $n$ 的数组上操作。它以逆序遍历准二叉树的内部节点，从最后一个父节点到根节点。在一个从零开始的数组中，最后一个父节点的索引由 $\\left\\lfloor \\dfrac{n - 2}{2} \\right\\rfloor$ 给出。循环从该索引递减至 $0$。对于此范围内的每个索引 $j$，都会调用一个向下调整过程 `sift_down`，以强制满足以 $j$ 为根的子树的最大堆属性。\n\n`sift_down(j)` 过程是堆构造的核心。它确保索引 $j$ 处的元素在其子树内被正确放置。该过程如下：\n1.  设当前节点位于索引 `root` 处，初始为 $j$。\n2.  确定该节点的子节点。左子节点位于索引 $2 \\cdot \\text{root} + 1$，右子节点位于 $2 \\cdot \\text{root} + 2$。\n3.  选择键值最大的子节点。根据指定规则：\n    - 如果两个子节点都存在且键值相等，则选择左子节点（位于 $2 \\cdot \\text{root} + 1$ 处）。\n    - 否则，选择键值严格较大的子节点。\n4.  如果所选子节点的键值严格大于 `root` 处当前节点的键值，则在该节点与所选子节点之间执行交换。\n5.  如果发生了交换，`sift_down` 过程从子节点的索引处（现在持有最初位于 `root` 的元素）递归（或迭代）地继续。\n6.  当当前节点的键值大于或等于其子节点的键值时，或当到达叶子节点（即没有子节点）时，过程终止。\n\n通过将此 `build_heap` 过程应用于增强数组，元素（包括其原始索引）被重新排列以满足最大堆属性。算法完成后，最终的数组是一个有效的最大堆。通过在最终数组中搜索 `original_index` 与给定初始索引 $i$ 匹配的元组，可以找到被跟踪元素的最终位置。\n\n让我们追踪案例 3：数组 $[\\,1,\\,2,\\,3,\\,4\\,]$，要跟踪的元素起始于索引 $i = 0$。\n- 初始键数组为 $[\\,1,\\,2,\\,3,\\,4\\,]$。大小为 $n = 4$。我们跟踪原始索引为 $0$ 的元素。\n- 增强数组为 $A = [\\,(1, 0),\\,(2, 1),\\,(3, 2),\\,(4, 3)\\,]$。\n- `build_heap` 过程从索引 $\\left\\lfloor \\dfrac{4 - 2}{2} \\right\\rfloor = 1$ 处的最后一个父节点开始。循环将对 $j=1$ 和 $j=0$ 执行。\n\n- **第 1 步：`sift_down(1)`**\n  - 索引 1 处的节点是 $(2, 1)$。其左子节点位于索引 $2(1) + 1 = 3$ 处，即 $(4, 3)$。没有右子节点。\n  - 子节点的键值 $4$ 严格大于节点的键值 $2$。执行交换。\n  - 数组变为 $A = [\\,(1, 0),\\,(4, 3),\\,(3, 2),\\,(2, 1)\\,]$。\n  - 过程从 $(2, 1)$ 的新位置（即索引 3）继续。这是一个叶子节点，因此 `sift_down(1)` 终止。\n\n- **第 2 步：`sift_down(0)`**\n  - 索引 0 处的节点是 $(1, 0)$。其子节点位于索引 1 和 2 处：$(4, 3)$ 和 $(3, 2)$。\n  - 键值最大的子节点是位于索引 1 处的 $(4, 3)$。\n  - 该子节点的键值 $4$ 严格大于节点的键值 $1$。执行交换。\n  - 数组变为 $A = [\\,(4, 3),\\,(1, 0),\\,(3, 2),\\,(2, 1)\\,]$。\n  - 过程从 $(1, 0)$ 的新位置（即索引 1）继续。\n  - 现在在索引 1 处，节点是 $(1, 0)$。其左子节点位于索引 $2(1) + 1 = 3$ 处，即 $(2, 1)$。\n  - 子节点的键值 $2$ 严格大于节点的键值 $1$。执行交换。\n  - 数组变为 $A = [\\,(4, 3),\\,(2, 1),\\,(3, 2),\\,(1, 0)\\,]$。\n  - 过程从索引 3 继续，这是一个叶子节点。过程终止。\n\n- **最终状态：** 堆构造完成。最终数组为 $A = [\\,(4, 3),\\,(2, 1),\\,(3, 2),\\,(1, 0)\\,]$。\n- 我们搜索原始索引为 0 的元素，即元组 $(1, 0)$。它位于索引 3 处。\n- 因此，案例 3 的最终位置是 3。\n\n将此确定性过程实现并应用于所有测试案例，以获得最终结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef sift_down(arr, root_idx, heap_size):\n    \"\"\"\n    Performs the downward adjustment for a max-heap.\n\n    This function takes an array of (key, original_index) tuples and ensures\n    the subtree rooted at root_idx satisfies the max-heap property.\n    This implementation follows the specific deterministic rules from the problem.\n    \"\"\"\n    root = root_idx\n    while True:\n        # Determine the index of the child to potentially swap with.\n        largest_child_idx = -1\n        left_child_idx = 2 * root + 1\n        right_child_idx = 2 * root + 2\n\n        # Start by assuming the left child is the largest, if it exists.\n        if left_child_idx  heap_size:\n            largest_child_idx = left_child_idx\n\n        # If the right child exists and is greater than the current largest, update.\n        # This handles the tie-breaking rule: if keys are equal, left child is preferred.\n        if right_child_idx  heap_size and arr[right_child_idx][0] > arr[largest_child_idx][0]:\n            largest_child_idx = right_child_idx\n        \n        # If there are no children, the process stops.\n        if largest_child_idx == -1:\n            break\n\n        # Perform swap only if the selected child's key is strictly greater.\n        if arr[largest_child_idx][0] > arr[root][0]:\n            arr[root], arr[largest_child_idx] = arr[largest_child_idx], arr[root]\n            # Continue sifting down from the new position.\n            root = largest_child_idx\n        else:\n            # The heap property holds for this subtree, so stop.\n            break\n\ndef build_heap(arr):\n    \"\"\"\n    Constructs a max-heap in-place from an array of (key, original_index) tuples.\n    \"\"\"\n    n = len(arr)\n    # The last parent node is at index floor((n - 2) / 2). Integer division // performs floor.\n    start_idx = (n - 2) // 2\n    for i in range(start_idx, -1, -1):\n        sift_down(arr, i, n)\n\ndef find_final_position(initial_array, tracked_original_index):\n    \"\"\"\n    Simulates the heap build and finds the final position of a tracked element.\n    \"\"\"\n    n = len(initial_array)\n    if n == 0:\n        return -1 # Should not happen with given test cases\n\n    # Create an augmented array to track elements by original index.\n    # Each element is a tuple: (key, original_index).\n    augmented_arr = [(initial_array[i], i) for i in range(n)]\n\n    # Build the max-heap in-place.\n    build_heap(augmented_arr)\n\n    # Find the final index of the element we are tracking.\n    for i in range(n):\n        if augmented_arr[i][1] == tracked_original_index:\n            return i\n            \n    return -1 # Should not be reached if tracked_original_index is valid.\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    test_cases = [\n        ([3, 1, 6, 5, 2, 4], 1),\n        ([9, 7, 8, 3, 2, 1, 5], 6),\n        ([1, 2, 3, 4], 0),\n        ([1, 2, 2], 0),\n        ([10, 9, 8, 7, 6, 5], 4),\n        ([2, 2, 2, 2], 2),\n        ([1, 2], 1),\n        ([-3, -1, -2], 0),\n        ([0, 1, 2, 3, 4, 5, 6], 6),\n        ([7], 0),\n    ]\n\n    results = []\n    for case in test_cases:\n        arr, tracked_idx = case\n        result = find_final_position(arr, tracked_idx)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3219649"}, {"introduction": "作为最后的挑战，我们将理论分析与编程实践相结合，来探索`buildHeap`算法的性能极限。你将扮演一个“对手”的角色，设计一个能使建堆过程中的交换次数达到理论最大值的输入数组。这个练习 [@problem_id:3219678] 不仅能让你理解算法的最坏情况行为，还能让你体会到理论界限与实际构造之间的优美联系。", "problem": "给定一个包含 $n$ 个不同键的二叉最大堆的数组表示，其中索引从 $1$ 开始，索引为 $i$ 的节点的子节点位于索引 $2i$ 和 $2i+1$ 处（只要这些索引不超过 $n$）。考虑 Floyd 自底向上建堆算法（也称为“build-heap”），该算法从 $i=\\left\\lfloor n/2 \\right\\rfloor$ 到 $i=1$ 对每个内部节点 $i$ 调用下滤（sift-down）操作。将一次下滤操作的代价定义为元素在恢复该位置的堆属性之前所遍历路径上执行的父子节点交换次数。建堆的总代价是所有内部节点上这些交换次数的总和。\n\n从堆、数组索引算术和 Floyd 建堆过程的核心定义出发，推导出一个有原则的对抗性输入生成器。对于任意给定的 $n$，该生成器能产生一个 $\\{1,2,\\dots,n\\}$ 的排列，该排列会使 build-heap 算法执行的父子节点交换总次数最大化。证明描述该生成器实现的代价与最坏情况代价接近程度的理论界，并用堆的形状参数来表示。\n\n您必须从以下基本点出发：\n- 二叉堆形状不变性：底层树是包含 $n$ 个节点的唯一完全二叉树；数组索引映射 $(i \\mapsto 2i, 2i+1)$ 在索引存在时表示左、右子节点。\n- Floyd 建堆算法处理索引 $i=\\left\\lfloor n/2 \\right\\rfloor, \\left\\lfloor n/2 \\right\\rfloor - 1, \\dots, 1$，使用下滤操作在每个位置 $i$ 恢复堆属性。\n- 每次下滤操作中，如果某个子节点的键值大于当前节点的键值，则将当前节点的键值与其较大的子节点的键值交换，重复此过程，直到两个子节点都不存在或两个子节点的键值都不大于当前节点的键值。\n\n您的程序必须：\n- 实现一个生成器，该生成器为索引分配值，使得键值随深度严格递增：对于每个可行的深度 $d$，深度为 $d$ 的所有节点都接收比深度为 $d+1$ 的所有节点严格更小的键。该生成器必须旨在最大化建堆过程中的父子节点交换总次数。\n- 实现 Floyd 建堆算法并计算父子节点交换的总次数。\n- 实现最坏情况下总交换次数的公式 $$S_{\\max}(n) = \\sum_{i=1}^{\\left\\lfloor n/2 \\right\\rfloor} \\left\\lfloor \\log_2\\left(\\frac{n}{i}\\right) \\right\\rfloor,$$ 该公式等于包含 $n$ 个节点的完全二叉树中每个内部节点的高度（最长向下路径上的边数）之和。用此公式来评估最优性。\n\n您必须证明该生成器达到了最坏情况，因此比率 $$\\rho(n) = \\frac{S_{\\text{gen}}(n)}{S_{\\max}(n)} = 1,$$ 并根据 $n$ 和 $H=\\left\\lfloor \\log_2 n \\right\\rfloor$ 推导出 $S_{\\max}(n)$ 基于形状的界，包括 $n=2^H$ 和 $n=2^{H+1}-1$ 的特殊情况。\n\n测试套件和最终输出：\n- 使用以下 $n$ 的测试值：$[1,2,3,4,7,8,10,15]$。\n- 对于测试套件中的每个 $n$，计算比率 $\\rho(n)$ 的小数值。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，每个比率格式化为恰好三位小数（例如，$[1.000,1.000,1.000]$）。如果 $S_{\\max}(n)=0$，则按照惯例定义 $\\rho(n)=1.000$，因为生成器达到了最大代价 $0$。", "solution": "所述问题是有效的。它在数据结构和算法领域有科学依据，提法明确，目标清晰，约束充分，并以精确、客观的语言表达。它提出了一个涉及形式化证明和算法实现的非凡挑战。因此，我们可以着手提供完整解答。\n\n该问题要求为 Floyd 建堆算法推导一个对抗性输入生成器，以最大化父子节点交换的总次数。然后，我们必须证明此生成器达到的代价 $S_{\\text{gen}}(n)$ 等于理论上的最大最坏情况代价 $S_{\\max}(n)$，并针对特定情况，根据堆的形状参数推导出此代价的表达式。\n\n让我们首先分析 `sift-down` 操作的代价，这是建堆过程的基本组成部分。对最大堆中索引为 $i$ 的节点执行 `sift-down` 操作，旨在恢复堆属性，即对于任意节点 $j$，其键值必须大于或等于其子节点的键值。该操作通过重复地将当前节点的键与其较大子节点的键交换（如果该子节点的键更大）来进行。此过程一直持续到该键到达一个位置，其值大于或等于其两个子节点的键，或者它成为一个叶节点。\n\n对节点 $i$ 调用一次 `sift-down` 的代价定义为执行的交换次数。当最初位于节点 $i$ 的键被迫在树中尽可能地向下移动时，此交换次数达到最大值。从节点 $i$ 到其后代叶节点的最长可能路径定义了节点 $i$ 的*高度*。要让一个键遍历整条路径，它的值必须小于沿途与之比较的所有节点的键值。在一个大小为 $n$ 的完全二叉树中，索引为 $i$ 的节点的高度 $h(i)$ 由 $h(i) = \\lfloor \\log_2(n/i) \\rfloor$ 给出，其中高度是指到叶节点的最长向下路径上的边数。\n\nFloyd 建堆算法从 $i = \\lfloor n/2 \\rfloor$ 到 $1$ 遍历所有内部节点，并对每个节点应用 `sift-down` 操作。总代价 $S(n)$ 是这些单独调用代价的总和：\n$$S(n) = \\sum_{i=1}^{\\lfloor n/2 \\rfloor} C_i$$\n其中 $C_i$ 是 `sift-down(i)` 的交换次数。单次 `sift-down(i)` 的最大可能代价是 $h(i)$。因此，建堆的最大可能总代价是所有内部节点的高度之和：\n$$S_{\\max}(n) = \\sum_{i=1}^{\\lfloor n/2 \\rfloor} h(i) = \\sum_{i=1}^{\\lfloor n/2 \\rfloor} \\left\\lfloor \\log_2\\left(\\frac{n}{i}\\right) \\right\\rfloor$$\n这与问题描述中提供的公式一致。\n\n我们的任务是设计一个对抗性输入生成器。目标是构造一个键集 $\\{1, 2, \\dots, n\\}$ 的排列，迫使每次 `sift-down` 调用都达到其最大可能代价。要使任意内部节点 $i$ 处的键下移至叶节点，其值必须小于它将要与之比较的任何键的值。这提出了一个通用原则：将较小的键放在较浅的深度，将较大的键放在较深的深度。问题明确提出了这样一种生成器：为索引分配值，使得键值随深度严格递增。\n\n让我们将此生成器形式化。索引为 $i$ 的节点深度（根节点深度为 0）为 $d(i) = \\lfloor \\log_2 i \\rfloor$。生成器创建一个 $\\{1, 2, \\dots, n\\}$ 的排列 `A`，使得对于任意两个索引 $j$ 和 $k$，如果 $d(j)  d(k)$，则 $A[j]  A[k]$。这可以通过将所有节点索引 $i \\in \\{1, \\dots, n\\}$ 按其深度 $d(i)$ 排序，然后将键 $1, 2, \\dots, n$ 按升序分配给这个排序序列中的节点来实现。\n\n现在，我们必须证明这个生成器达到了最大代价 $S_{\\max}(n)$。考虑对任意内部节点 $i$ 的 `sift-down` 操作。根据构造，键 $A[i]$ 小于其子节点 $A[2i]$ 和（如果存在）$A[2i+1]$ 的键，因为子节点处于更深的深度。`sift-down` 过程会将 $A[i]$ 与其子节点中键值较大的那个进行交换。因此，键 $A[i]$ 移动到深度为 $d(i)+1$ 的新节点。下一层的键，即原来 $i$ 的孙代节点，处于深度 $d(i)+2$。我们的构造保证了键 $A[i]$ 也小于这些键。这个过程会重复进行，键 $A[i]$ 在每一层都会被向下交换，直到它到达一个叶节点。因此，交换的次数将恰好等于它下降的层数，也就是节点 $i$ 的高度 $h(i)$。\n\n由于这对每个内部节点 $i \\in \\{1, \\dots, \\lfloor n/2 \\rfloor\\}$ 都成立，所以生成输入的总代价为：\n$$S_{\\text{gen}}(n) = \\sum_{i=1}^{\\lfloor n/2 \\rfloor} h(i) = \\sum_{i=1}^{\\lfloor n/2 \\rfloor} \\left\\lfloor \\log_2\\left(\\frac{n}{i}\\right) \\right\\rfloor$$\n这与 $S_{\\max}(n)$ 的表达式完全相同。因此，我们证明了 $S_{\\text{gen}}(n) = S_{\\max}(n)$。所以，对于所有 $n  1$，比率 $\\rho(n) = S_{\\text{gen}}(n) / S_{\\max}(n)$ 等于 $1$。对于 $n=1$，没有内部节点，所以 $S_{\\max}(1)=0$ 且 $S_{\\text{gen}}(1)=0$。根据问题的约定，$\\rho(1)=1$。\n\n最后，我们为两种特殊情况推导 $S_{\\max}(n)$ 基于形状的界。一个已知且强大的恒等式（可通过归纳法证明）指出，一个包含 $n$ 个节点的完全二叉树中所有节点的高度之和为 $n - d(n)$，其中 $d(n)$ 是 $n$ 的二进制表示中置位（为1的位）的数量。由于任何叶节点的高度都为 $0$，这个和等于内部节点的高度之和：\n$$S_{\\max}(n) = \\sum_{i=1}^{\\lfloor n/2 \\rfloor} h(i) = n - d(n)$$\n\n使用这个恒等式，我们可以为指定的特殊情况找到精确的表达式。堆的总高度为 $H = \\lfloor \\log_2 n \\rfloor$。\n\n1.  **情况 $n=2^{H+1}-1$（完美二叉树）：** 该树的高度为 $H$。其二进制表示由 $H+1$ 个连续的1组成。因此，$d(n) = H+1$。最坏情况代价为：\n    $$S_{\\max}(n) = n - d(n) = n - (H+1)$$\n2.  **情况 $n=2^H$（最后一层只有一个节点的完全二叉树）：** 在这种情况下，问题陈述中对 $H$ 的定义存在轻微的歧义。对于 $n=2^k$，树的高度是 $k$，$\\lfloor \\log_2 n \\rfloor$ 的值也是 $k$。我们假设问题意指对于某个整数 $k \\geq 1$ 有 $n=2^k$，此时树高为 $k$。那么 $H = \\lfloor\\log_2 n\\rfloor$ 就等于 $k$。$n=2^k$ 的二进制表示是一个 $1$ 后面跟着 $k$ 个零。因此，$d(n) = 1$。最坏情况代价为：\n    $$S_{\\max}(n) = n - d(n) = n - 1$$\n\n这些公式为这些特定堆形状提供了精确的最坏情况代价，并用 $n$ 及其相关的高度参数 $H$ 表示。两种推导都证实了交换次数的数量级为 $O(n)$，具体来说，其上界为 $n - O(\\log n)$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    It calculates the ratio rho(n) for each n and prints the results.\n    \"\"\"\n\n    def generate_adversarial_input(n):\n        \"\"\"\n        Generates a permutation of {1, ..., n} that maximizes build-heap cost.\n        Keys are assigned such that they strictly increase with node depth.\n        1-based indexing is used for the heap array.\n        \"\"\"\n        if n == 0:\n            return np.array([], dtype=int)\n        \n        # Create a list of (depth, index) tuples for each node\n        nodes = []\n        for i in range(1, n + 1):\n            depth = int(np.log2(i))\n            nodes.append((depth, i))\n        \n        # Sort nodes primarily by depth, secondarily by index\n        nodes.sort()\n        \n        # Create the array and assign keys {1, 2, ..., n} based on sorted order\n        # The array is of size n+1 to accommodate 1-based indexing.\n        A = np.zeros(n + 1, dtype=int)\n        for key, (_, index) in enumerate(nodes, 1):\n            A[index] = key\n            \n        return A\n\n    def sift_down(A, i, n):\n        \"\"\"\n        Performs the sift-down operation on a max-heap.\n        Starts at index i and restores the heap property downwards.\n        Returns the number of parent-child exchanges.\n        \"\"\"\n        exchanges = 0\n        k = i\n        while True:\n            largest = k\n            left = 2 * k\n            right = 2 * k + 1\n            \n            # Find the largest among the node and its children\n            if left = n and A[left] > A[largest]:\n                largest = left\n            if right = n and A[right] > A[largest]:\n                largest = right\n            \n            # If the current node is already the largest, the sub-heap is valid\n            if largest == k:\n                break\n            \n            # Swap with the largest child and continue sifting down\n            A[k], A[largest] = A[largest], A[k]\n            exchanges += 1\n            k = largest\n            \n        return exchanges\n\n    def get_generated_cost(n):\n        \"\"\"\n        Calculates the total exchanges for build-heap on the adversarial input.\n        \"\"\"\n        if n = 1:\n            return 0\n        \n        A = generate_adversarial_input(n)\n        total_exchanges = 0\n        \n        # Floyd's build-heap algorithm\n        for i in range(n // 2, 0, -1):\n            total_exchanges += sift_down(A, i, n)\n            \n        return total_exchanges\n\n    def get_max_cost(n):\n        \"\"\"\n        Calculates the theoretical maximum cost using the formula\n        S_max(n) = sum of heights of all internal nodes.\n        \"\"\"\n        if n = 1:\n            return 0\n            \n        total_height = 0\n        for i in range(1, n // 2 + 1):\n            height = int(np.log2(n / i))\n            total_height += height\n            \n        return total_height\n    \n    # Define the test cases from the problem statement.\n    test_cases = [1, 2, 3, 4, 7, 8, 10, 15]\n\n    results = []\n    for n in test_cases:\n        s_gen = get_generated_cost(n)\n        s_max = get_max_cost(n)\n        \n        # The ratio rho(n) = S_gen(n) / S_max(n).\n        # By convention, if S_max(n) is 0, the ratio is 1.000.\n        if s_max == 0:\n            rho = 1.0\n        else:\n            rho = s_gen / s_max\n            \n        results.append(f\"{rho:.3f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3219678"}]}