{"hands_on_practices": [{"introduction": "理论的掌握始于对最基本情景的深刻理解。这个练习将我们带回到AVL树的起点：仅用三个元素构建一棵树。通过分析这个最简单的非平凡案例，我们可以直观地揭示哪些插入顺序能够自然保持平衡，而哪些会不可避免地触发旋转，从而为理解更复杂的场景奠定坚实的基础。[@problem_id:3210827]", "problem": "设有三个不同的键，它们是满足 $a < b < c$ 的关系。如果我们将这三个键按随机顺序（所有 $3! = 6$ 种排列等概率）插入一棵空的 AVL 树中，那么插入过程**不**需要任何旋转操作的概率是多少？", "solution": "问题要求我们计算在将三个不同的、已排序的键（$a < b < c$）以随机顺序插入空的 AVL 树时，不需要进行旋转的概率。总共有 $3! = 6$ 种可能的插入顺序（排列）：\n\n1.  $a, b, c$：插入 $c$ 后，节点 $a$ 的平衡因子变为 -2，触发右-右（RR）情况下的左旋。**需要旋转**。\n2.  $a, c, b$：插入 $b$ 后，节点 $a$ 的平衡因子变为 -2，其右孩子 $c$ 的平衡因子为 +1，触发右-左（RL）情况下的双旋。**需要旋转**。\n3.  $b, a, c$：插入 $b$，然后是 $a$（左孩子）和 $c$（右孩子）。树保持完美平衡，所有节点的平衡因子都是 0。**不需要旋转**。\n4.  $b, c, a$：与上一种情况类似，先插入中位数 $b$。树保持完美平衡。**不需要旋转**。\n5.  $c, a, b$：插入 $b$ 后，节点 $c$ 的平衡因子变为 +2，其左孩子 $a$ 的平衡因子为 -1，触发左-右（LR）情况下的双旋。**需要旋转**。\n6.  $c, b, a$：插入 $a$ 后，节点 $c$ 的平衡因子变为 +2，触发左-左（LL）情况下的右旋。**需要旋转**。\n\n在 6 种等可能的排列中，只有 2 种（当第一个插入的键是中位数 $b$ 时）不会导致任何旋转。因此，不需要旋转的概率是 $\\frac{2}{6} = \\frac{1}{3}$。", "answer": "$$\\boxed{\\frac{1}{3}}$$", "id": "3210827"}, {"introduction": "在掌握了旋转的基本触发条件后，下一步是亲手实践整个平衡过程。本练习提供了一个精心设计的插入序列，它将引导你逐步跟踪每个节点的平衡因子变化，并见证一次右-左（RL）双旋转的完整发生过程。完成这个练习将极大提升你对AVL树动态调整机制的细节把控能力。[@problem_id:3210713]", "problem": "您将使用 Adelson–Velsky and Landis (AVL) 树的核心定义来分析在二叉搜索树插入过程中旋转是如何被触发的，以及平衡因子是如何演变的。设空子节点的高度定义为 $-1$，节点的高度为 $1 + \\max\\{\\text{height of left child}, \\text{height of right child}\\}$，节点 $v$ 的平衡因子为 $\\operatorname{bf}(v) = \\text{height(left}(v)) - \\text{height(right}(v))$。如果每个节点的平衡因子都在 $\\{-1, 0, 1\\}$ 集合中，则该 AVL 树是平衡的。插入时，节点 $z$ 会触发：\n- 一次左-左 ($LL$) 旋转，如果 $\\operatorname{bf}(z) = +2$ 且插入发生在 $z$ 的左子节点的左子树中，\n- 一次右-右 ($RR$) 旋转，如果 $\\operatorname{bf}(z) = -2$ 且插入发生在 $z$ 的右子节点的右子树中，\n- 一次左-右 ($LR$) 旋转，如果 $\\operatorname{bf}(z) = +2$ 且 $z$ 的左子节点的 $\\operatorname{bf} = -1$ (修复方法是先对左子节点进行一次左旋，然后对 $z$ 进行一次右旋)，\n- 一次右-左 ($RL$) 旋转，如果 $\\operatorname{bf}(z) = -2$ 且 $z$ 的右子节点的 $\\operatorname{bf} = +1$ (修复方法是先对右子节点进行一次右旋，然后对 $z$ 进行一次左旋)。\n\n考虑将关键字 $\\{1,2,3,4,5,6,7\\}$ 按特定顺序 $\\langle 4, 6, 5, 2, 1, 3, 7 \\rangle$ 插入到一个初始为空的二叉搜索树中。这个顺序会在插入关键字 $5$ 之后、且在该步骤执行任何再平衡操作之前的时刻，在节点 $4$ 上强制进行一次右-左 ($RL$) 旋转。\n\n对于步骤 $t \\in \\{1,2,\\dots,7\\}$，令 $V_t$ 表示在第 $t$ 次插入之后、且在该步骤执行任何再平衡操作之前存在的节点集合，并令 $\\operatorname{bf}_t^{-}(v)$ 表示在该再平衡前的树中节点 $v \\in V_t$ 的平衡因子。定义累积不平衡量\n$$\nS \\;=\\; \\sum_{t=1}^{7} \\;\\sum_{v \\in V_t} \\left|\\operatorname{bf}_t^{-}(v)\\right|.\n$$\n\n任务：\n- 仅使用上述基本定义，论证为什么给定的插入顺序会在插入关键字 $5$ 之后的时刻，在节点 $4$ 上强制进行一次 $RL$ 旋转。\n- 在每个步骤 $t$ 计算每个 $v \\in V_t$ 的 $\\operatorname{bf}_t^{-}(v)$，并识别在其第一个不平衡祖先节点上的所有旋转触发。\n- 计算 $S$ 的精确值。\n\n您的最终答案必须是 $S$ 的精确值（一个整数）。无需四舍五入。", "solution": "该问题是有效的，因为它是自成体系的，科学上基于 AVL 树理论，并且是适定的。定义、插入序列以及要计算的量都被明确地指定，确保了存在唯一且有意义的解。\n\n解题过程分为两部分。首先，我们将论证为什么在插入关键字 $5$ 后，节点 $4$ 会被强制进行一次 RL 旋转。其次，我们将追踪 7 个关键字中每一个的插入过程，在每个步骤 $t$ 计算再平衡前的平衡因子集合 $\\operatorname{bf}_t^{-}(v)$，并将其绝对值相加，以求得总的累积不平衡量 $S$。\n\n### 右-左 (RL) 旋转的论证\n\n我们从一棵空树开始。\n1.  插入 $4$：树是一个单节点 $4$。$h(4)=0$，$\\operatorname{bf}(4)=0$。\n2.  插入 $6$：由于 $6 > 4$，$6$ 成为 $4$ 的右子节点。树的结构为 $4 \\rightarrow (\\text{右}) \\ 6$。\n    - $h(6) = 1 + \\max(-1, -1) = 0$。\n    - $h(4) = 1 + \\max(h(\\text{left}), h(6)) = 1 + \\max(-1, 0) = 1$。\n    - $\\operatorname{bf}(4) = h(\\text{left}) - h(6) = -1 - 0 = -1$。树是平衡的。\n\n3.  插入 $5$：由于 $5 > 4$，我们向右到节点 $6$。由于 $5 < 6$，我们向左。$5$ 作为 $6$ 的左子节点被插入。在任何再平衡操作之前，结构为 $4 \\rightarrow (\\text{右}) \\ 6 \\rightarrow (\\text{左}) \\ 5$。让我们分析这次插入之后的状态，记为 $t=3$。\n    - 令 $v_4, v_5, v_6$ 为关键字是 $4, 5, 6$ 的节点。\n    - 新叶子节点的高度是 $h(v_5) = 0$。其平衡因子为 $\\operatorname{bf}_3^{-}(v_5) = 0 - 0 = 0$。\n    - 其父节点的高度是 $h(v_6) = 1 + \\max(h(v_5), h(\\text{empty})) = 1+\\max(0, -1) = 1$。\n    - $v_6$ 的平衡因子为 $\\operatorname{bf}_3^{-}(v_6) = h(v_5) - h(\\text{empty}) = 0 - (-1) = +1$。\n    - 根节点的高度是 $h(v_4) = 1 + \\max(h(\\text{empty}), h(v_6)) = 1+\\max(-1, 1) = 2$。\n    - $v_4$ 的平衡因子为 $\\operatorname{bf}_3^{-}(v_4) = h(\\text{empty}) - h(v_6) = -1 - 1 = -2$。\n\n从插入点 ($v_5$) 向上回溯，第一个平衡因子在集合 $\\{-1, 0, 1\\}$ 之外的节点是 $z=v_4$。它的平衡因子是 $\\operatorname{bf}_3^{-}(v_4) = -2$。问题将节点 $z$ 的 RL 旋转触发条件定义为：“$\\operatorname{bf}(z) = -2$ 且 $z$ 的右子节点的 $\\operatorname{bf} = +1$”。在这里，$z=v_4$，其右子节点是 $v_6$，并且我们已经计算出 $\\operatorname{bf}_3^{-}(v_6) = +1$。\n两个条件都满足。因此，插入关键字 $5$ 会在节点 $4$ 上强制进行一次 RL 旋转。\n\n### $S$ 的分步计算\n\n我们现在计算 $S = \\sum_{t=1}^{7} \\sum_{v \\in V_t} |\\operatorname{bf}_t^{-}(v)|$。对于每个步骤 $t$，我们展示再平衡前的树的状态，计算平衡因子，求其绝对值的和，并描述再平衡操作。\n\n**步骤 $t=1$：插入 $4$**\n-   再平衡前的树：一个单节点 $4$。\n-   $V_1 = \\{4\\}$。\n-   $\\operatorname{bf}_1^{-}(4) = 0$。\n-   $\\sum_{v \\in V_1} |\\operatorname{bf}_1^{-}(v)| = |0| = 0$。\n-   树是平衡的。\n\n**步骤 $t=2$：插入 $6$**\n-   再平衡前的树：$4 \\rightarrow (\\text{右}) \\ 6$。\n-   $V_2 = \\{4, 6\\}$。\n-   $\\operatorname{bf}_2^{-}(6) = 0$。\n-   $\\operatorname{bf}_2^{-}(4) = h(\\text{left}) - h(\\text{right}) = -1 - 0 = -1$。\n-   $\\sum_{v \\in V_2} |\\operatorname{bf}_2^{-}(v)| = |-1| + |0| = 1$。\n-   树是平衡的。\n\n**步骤 $t=3$：插入 $5$**\n-   再平衡前的树：$4 \\rightarrow (\\text{右}) \\ 6 \\rightarrow (\\text{左}) \\ 5$。\n-   $V_3 = \\{4, 5, 6\\}$。\n-   $\\operatorname{bf}_3^{-}(5) = 0$。\n-   $\\operatorname{bf}_3^{-}(6) = h(5) - h(\\text{empty}) = 0 - (-1) = 1$。\n-   $\\operatorname{bf}_3^{-}(4) = h(\\text{empty}) - h(6) = -1 - 1 = -2$。\n-   $\\sum_{v \\in V_3} |\\operatorname{bf}_3^{-}(v)| = |-2| + |0| + |1| = 3$。\n-   旋转：节点 $4$ 不平衡 ($\\operatorname{bf}=-2$)，其右子节点的 $\\operatorname{bf}=+1$。在节点 $4$ 上执行一次 **RL 旋转**。树变为以 $5$ 为根，左子节点为 $4$，右子节点为 $6$。\n\n**步骤 $t=4$：插入 $2$**\n-   $t=3$ 再平衡后的树：$5 \\rightarrow (\\text{左}) \\ 4, (\\text{右}) \\ 6$。\n-   $t=4$ 再平衡前的树：$5 \\rightarrow (\\text{左}) \\ (4 \\rightarrow (\\text{左}) \\ 2), (\\text{右}) \\ 6$。\n-   $V_4 = \\{2, 4, 5, 6\\}$。\n-   $\\operatorname{bf}_4^{-}(2)=0$, $\\operatorname{bf}_4^{-}(6)=0$。\n-   $\\operatorname{bf}_4^{-}(4) = h(2) - h(\\text{empty}) = 0 - (-1) = 1$。\n-   $\\operatorname{bf}_4^{-}(5) = h(4) - h(6) = 1 - 0 = 1$。\n-   $\\sum_{v \\in V_4} |\\operatorname{bf}_4^{-}(v)| = |0| + |1| + |1| + |0| = 2$。\n-   树是平衡的。\n\n**步骤 $t=5$：插入 $1$**\n-   $t=4$ 的树：$5 \\rightarrow \\big( (\\text{左}) \\ 4 \\rightarrow(\\text{左}) \\ 2 \\big), (\\text{右}) \\ 6$。\n-   $t=5$ 再平衡前的树：$5 \\rightarrow \\big( (\\text{左}) \\ 4 \\rightarrow(\\text{左}) \\ (2 \\rightarrow \\text{左} \\ 1) \\big), (\\text{右}) \\ 6$。\n-   $V_5 = \\{1, 2, 4, 5, 6\\}$。\n-   $\\operatorname{bf}_5^{-}(1)=0$, $\\operatorname{bf}_5^{-}(6)=0$。\n-   $\\operatorname{bf}_5^{-}(2) = h(1) - h(\\text{empty}) = 0 - (-1) = 1$。\n-   $h(2)=1$，所以 $\\operatorname{bf}_5^{-}(4) = h(2) - h(\\text{empty}) = 1 - (-1) = 2$。\n-   $h(4)=2$，所以 $\\operatorname{bf}_5^{-}(5) = h(4) - h(6) = 2 - 0 = 2$。\n-   $\\sum_{v \\in V_5} |\\operatorname{bf}_5^{-}(v)| = |0| + |1| + |2| + |2| + |0| = 5$。\n-   旋转：节点 $4$ 是第一个不平衡的节点 ($\\operatorname{bf}=+2$)。插入发生在其左子节点的左子树中。在节点 $4$ 上执行一次 **LL 旋转** (一次右单旋)。以 $4$ 为根的子树变为以 $2$ 为根，左子节点为 $1$，右子节点为 $4$。这修复了所有祖先节点的平衡，包括节点 $5$。\n\n**步骤 $t=6$：插入 $3$**\n-   $t=5$ 再平衡后的树：$5 \\rightarrow \\big( (\\text{左}) \\ (2 \\rightarrow (\\text{左}) \\ 1, (\\text{右}) \\ 4) \\big), (\\text{右}) \\ 6$。\n-   $t=6$ 再平衡前的树：插入 $3$ ($3<5, 3>2, 3<4$) 作为 $4$ 的左子节点。\n-   $V_6 = \\{1, 2, 3, 4, 5, 6\\}$。\n-   $\\operatorname{bf}_6^{-}(1)=0, \\operatorname{bf}_6^{-}(3)=0, \\operatorname{bf}_6^{-}(6)=0$。\n-   $\\operatorname{bf}_6^{-}(4) = h(3) - h(\\text{empty}) = 0 - (-1) = 1$。\n-   $h(4)=1, h(1)=0$，所以 $\\operatorname{bf}_6^{-}(2) = h(1) - h(4) = 0 - 1 = -1$。\n-   $h(2)=2, h(6)=0$，所以 $\\operatorname{bf}_6^{-}(5) = h(2) - h(6) = 2 - 0 = 2$。\n-   $\\sum_{v \\in V_6} |\\operatorname{bf}_6^{-}(v)| = |0| + |-1| + |0| + |1| + |2| + |0| = 4$。\n-   旋转：节点 $5$ 不平衡 ($\\operatorname{bf}=+2$) 且其左子节点 ($2$) 的 $\\operatorname{bf}=-1$。在节点 $5$ 上执行一次 **LR 旋转**。最终的树以 $4$ 为根。\n\n**步骤 $t=7$：插入 $7$**\n-   $t=6$ 再平衡后的树：以 $4$ 为根，左子节点为 $2$ (其子节点为 $1,3$)，右子节点为 $5$ (其右子节点为 $6$)。\n-   $t=7$ 再平衡前的树：$7$ 作为 $6$ 的右子节点被插入。\n-   $V_7 = \\{1, 2, 3, 4, 5, 6, 7\\}$。\n-   $\\operatorname{bf}_7^{-}(1)=0, \\operatorname{bf}_7^{-}(3)=0, \\operatorname{bf}_7^{-}(7)=0$。\n-   $\\operatorname{bf}_7^{-}(2) = h(1) - h(3) = 0 - 0 = 0$。\n-   $\\operatorname{bf}_7^{-}(6) = h(\\text{empty}) - h(7) = -1 - 0 = -1$。\n-   $h(2)=1$，$h(6)=1$，所以 $\\operatorname{bf}_7^{-}(5) = h(\\text{empty}) - h(6) = -1 - 1 = -2$。\n-   $h(5)=2$，所以 $\\operatorname{bf}_7^{-}(4) = h(2) - h(5) = 1 - 2 = -1$。\n-   $\\sum_{v \\in V_7} |\\operatorname{bf}_7^{-}(v)| = |0| + |0| + |0| + |-1| + |-2| + |-1| + |0| = 4$。\n-   旋转：节点 $5$ 不平衡 ($\\operatorname{bf}=-2$)。插入发生在右子节点的右子树中。在节点 $5$ 上执行一次 **RR 旋转** (一次左单旋)。\n\n**$S$ 的最终计算**\n总的累积不平衡量 $S$ 是每一步总和的累加：\n$$\nS = \\sum_{t=1}^{7} \\sum_{v \\in V_t} |\\operatorname{bf}_t^{-}(v)| = 0 + 1 + 3 + 2 + 5 + 4 + 4\n$$\n$$\nS = 19\n$$", "answer": "$$\\boxed{19}$$", "id": "3210713"}, {"introduction": "真正的精通不仅在于遵循规则，更在于理解规则背后的统一原理。这个编程挑战要求你超越对四种旋转（LL, RR, LR, RL）的个案处理，实现一种更为优雅和通用的“三节点重构”逻辑。这种抽象方法不仅能简化代码，更能体现对AVL旋转本质——即保持二叉搜索树有序性的局部变换——的深刻洞见。[@problem_id:3210793]", "problem": "实现一个自平衡二叉搜索树，使用 Adelson-Velsky 和 Landis (AVL) 旋转，并采用单一、统一的三节点重构逻辑，该逻辑在一个代码块中处理所有四种不平衡配置，而不区分单旋转和双旋转。从以下基础开始。二叉搜索树是一种二叉树，其中对于每个键为 $k_v$ 的节点 $v$，其左子树中的所有键都严格小于 $k_v$，其右子树中的所有键都严格大于 $k_v$。节点 $v$ 的高度函数 $h(v)$ 递归定义为：如果 $v$ 为空，则 $h(v) = 0$；否则 $h(v) = 1 + \\max(h(v_{\\text{left}}), h(v_{\\text{right}}))$。平衡因子 $bf(v)$ 定义为 $bf(v) = h(v_{\\text{left}}) - h(v_{\\text{right}})$。AVL 树为每个节点 $v$ 维持 $|bf(v)| \\leq 1$ 的性质；插入时，如果某个节点 $a$ 变得不平衡，即 $|bf(a)| \\geq 2$（这是单个局部重构能够恢复平衡的最小阈值），则必须执行再平衡操作。你的程序必须实现 AVL 插入，遵循二叉搜索树的插入规则，之后更新高度，并在需要时执行单一的统一重构步骤，具体如下：设 $a$ 是插入路径上第一个满足 $|bf(a)| \\geq 2$ 的祖先节点，设 $b$ 是 $a$ 的较高子节点，并设 $c$ 为 $b$ 的较高子节点（当 $b$ 的子节点等高时，选择左子节点）。通过三节点重构来恢复平衡，该重构将 $\\{a, b, c\\}$ 中键值的中位数节点提升为局部根节点，并重新连接四个子树，以保持二叉搜索树的顺序和 AVL 的高度不变性。旋转逻辑必须表示为单个统一的代码块，覆盖所有四种配置（$LL$, $RR$, $LR$, $RL$），而无需显式区分单旋转和双旋转。重复的键应被忽略（树存储唯一的键）。\n\n你的程序必须将插入操作应用于下面的每个测试用例，并为每个用例生成最终树的前序遍历，结果为一个整数列表。测试套件如下：\n1. 空序列: $[]$ (边界条件)\n2. 左-左不平衡: $[30, 20, 10]$\n3. 右-右不平衡: $[10, 20, 30]$\n4. 左-右不平衡: $[30, 10, 20]$\n5. 右-左不平衡: $[10, 30, 20]$\n6. 多次再平衡: $[10, 20, 30, 40, 50, 25]$\n7. 仅重复值: $[10, 10, 10]$ (边界条件)\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个元素对应一个测试用例的前序遍历列表，整行中不得有任何空格。例如，如果有三个测试用例分别产生列表 $[a_1, a_2]$、$[b_1]$ 和 $[]$，程序应打印单行 $[[a_1,a_2],[b_1],[]]$。", "solution": "该问题要求实现 Adelson-Velsky and Landis (AVL) 树，它是一种自平衡二叉搜索树。关键约束是，对于插入过程中出现的所有四种不平衡情况（$LL$、$RR$、$LR$、$RL$），都使用单一、统一的三节点重构逻辑。\n\n首先，我们定义树节点的结构。每个 `Node` 对象必须存储一个键、对其左右子节点的引用以及它在树中的高度。节点的高度对于确定平衡因子至关重要。节点 $v$ 的高度 $h(v)$ 定义为：如果 $v$ 是一个空引用（叶节点的子节点），则为 $0$；否则为 $1 + \\max(h(v_{\\text{left}}), h(v_{\\text{right}}))$。\n\n插入过程以标准的二叉搜索树插入开始。一个新键被放置在一个新的叶节点中，同时维持 BST 属性：对于任何键为 $k_v$ 的节点，其左子树中的所有键都严格小于 $k_v$，其右子树中的所有键都严格大于 $k_v$。问题规定重复的键将被忽略。\n\n插入后，我们从新的叶节点沿路径向上返回至根节点。在此路径上的每个节点，我们执行两个操作：\n$1$. 更新节点的高度。由于一个新节点被添加到了其某个子树中，其高度可能会增加。\n$2$. 检查不平衡。计算平衡因子 $bf(v) = h(v_{\\text{left}}) - h(v_{\\text{right}})$。AVL 属性要求对于每个节点 $v$，必须满足 $|bf(v)| \\le 1$。插入操作可能会违反此属性。\n\n如果我们发现一个节点 $a$ 满足 $|bf(a)| \\ge 2$，则需要进行重构。问题指出，这必须在插入路径上遇到的第一个此类祖先节点 $a$ 处完成。这是变得不平衡的最深节点。插入操作的递归实现很自然地处理了这一点，因为检查和重构是在递归返回的路径上执行的。\n\n解决方案的核心是统一的三节点重构逻辑。这个过程在不平衡节点 $a$ 处触发，并涉及其子节点 $b$ 和孙节点 $c$，它们的确定方式如下：\n- $a$：插入路径上第一个满足 $|bf(a)| \\ge 2$ 的祖先节点。\n- $b$：$a$ 的较高子节点。由于 $|bf(a)| \\ge 2$，一个子节点必然严格高于另一个。如果 $bf(a) > 1$，则 $b = a_{\\text{left}}$；如果 $bf(a) < -1$，则 $b = a_{\\text{right}}$。\n- $c$：$b$ 的较高子节点。问题指定了一个打破平局的规则：如果 $h(b_{\\text{left}}) \\ge h(b_{\\text{right}})$，则 $c = b_{\\text{left}}$；否则 $c = b_{\\text{right}}$。\n\n这三个节点 $\\{a, b, c\\}$，连同它们不属于 $\\{a, b, c\\}$ 本身的四个子树，构成了需要重新配置的局部子结构。统一的重构不依赖于具体情况（$LL, RR, LR, RL$），而是取决于 $a$、$b$ 和 $c$ 的键的排序顺序。\n\n设按键排序后的节点 $\\{a, b, c\\}$ 为 $\\{z, y, x\\}$，其中 $k_z < k_y < k_x$。三节点重构将键为中位数的节点 $y$ 提升为新的局部根节点。节点 $z$ 成为 $y$ 的左子节点，节点 $x$ 成为 $y$ 的右子节点。这种配置内在地保持了这三个节点的二叉搜索树属性。\n\n最后一步是重新连接四个原始子树，我们可以表示为 $T_0, T_1, T_2, T_3$。这些子树对应四个键范围：键小于 $k_z$、键在 $k_z$ 和 $k_y$ 之间、键在 $k_y$ 和 $k_x$ 之间，以及键大于 $k_x$。我们可以通过检查其根节点的键相对于 $k_z, k_y, k_x$ 的值，来确定四个原始子树中哪一个对应于每个范围。然后根据 BST 属性执行重新连接：\n- $z_{\\text{left}} \\leftarrow T_0$ (键 < $k_z$)\n- $z_{\\text{right}} \\leftarrow T_1$ (键 > $k_z$ 且 < $k_y$)\n- $x_{\\text{left}} \\leftarrow T_2$ (键 > $k_y$ 且 < $k_x$)\n- $x_{\\text{right}} \\leftarrow T_3$ (键 > $k_x$)\n\n在重新链接节点和子树之后，必须按 $z$、$x$、最后是 $y$ 的顺序重新计算它们的高度，以反映新的结构。节点 $y$ 作为重构后子树的新根，在递归插入调用中返回给父节点，从而完成再平衡。\n\n这整个重构过程构成了一个单一的逻辑块。它通过将旋转抽象为对三个节点及其四个相关子树进行重新排序的通用操作，正确处理了所有四种不平衡配置，从而满足了问题的主要约束。\n\n最后，为了生成所需的输出，实现了一个前序遍历。此遍历访问当前节点，然后是其左子树，然后是其右子树，将键收集到一个列表中。对提供的每个测试用例都执行此操作。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport sys\n\n# It's good practice to increase recursion limit for recursive data structures.\nsys.setrecursionlimit(2000)\n\nclass Node:\n    \"\"\"Node class for the AVL tree.\"\"\"\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n        self.height = 1\n\nclass AVLTree:\n    \"\"\"AVL tree implementation with a unified tri-node restructuring logic.\"\"\"\n\n    def __init__(self):\n        self.root = None\n\n    def get_height(self, node):\n        \"\"\"Returns the height of a node, 0 for None.\"\"\"\n        if not node:\n            return 0\n        return node.height\n\n    def get_balance(self, node):\n        \"\"\"Returns the balance factor of a node.\"\"\"\n        if not node:\n            return 0\n        return self.get_height(node.left) - self.get_height(node.right)\n\n    def insert(self, key):\n        \"\"\"Public method to insert a key into the tree.\"\"\"\n        self.root = self._insert(self.root, key)\n\n    def _insert(self, node, key):\n        \"\"\"Recursive helper function for insertion.\"\"\"\n        # 1. Standard BST insertion\n        if not node:\n            return Node(key)\n        elif key < node.key:\n            node.left = self._insert(node.left, key)\n        elif key > node.key:\n            node.right = self._insert(node.right, key)\n        else:\n            return node  # Duplicates are ignored\n\n        # 2. Update height of the ancestor node\n        node.height = 1 + max(self.get_height(node.left), self.get_height(node.right))\n\n        # 3. Get the balance factor\n        balance = self.get_balance(node)\n\n        # 4. If the node becomes unbalanced, then trigger restructuring\n        if abs(balance) > 1:\n            return self._restructure(node)\n\n        return node\n\n    def _restructure(self, a):\n        \"\"\"Performs a unified tri-node restructuring.\"\"\"\n        # Identify nodes b and c as per the problem description\n        if self.get_balance(a) > 1:\n            b = a.left\n        else: # balance < -1\n            b = a.right\n\n        if self.get_height(b.left) >= self.get_height(b.right):\n            c = b.left\n        else:\n            c = b.right\n\n        # Sort nodes a, b, c by key to find the median\n        nodes_p = [a, b, c]\n        z, y, x = sorted(nodes_p, key=lambda n: n.key)\n\n        # Identify the four subtrees T0, T1, T2, T3\n        T0, T1, T2, T3 = None, None, None, None\n        \n        # Collect all children of a, b, c\n        all_children = []\n        for v in nodes_p:\n            all_children.append(v.left)\n            all_children.append(v.right)\n            \n        # The four subtrees are the children that are not a, b, or c themselves\n        for t in all_children:\n            if t not in nodes_p:\n                if t is None:\n                    continue\n                # Assign subtrees to T0-T3 based on their key range\n                if t.key < z.key:\n                    T0 = t\n                elif z.key < t.key < y.key:\n                    T1 = t\n                elif y.key < t.key < x.key:\n                    T2 = t\n                else: # t.key > x.key\n                    T3 = t\n\n        # Perform the restructuring\n        # The median node y becomes the new root of this local subtree\n        y.left = z\n        y.right = x\n        \n        # Re-attach the four subtrees\n        z.left = T0\n        z.right = T1\n        x.left = T2\n        x.right = T3\n\n        # Update heights of the modified nodes, from bottom-up\n        z.height = 1 + max(self.get_height(z.left), self.get_height(z.right))\n        x.height = 1 + max(self.get_height(x.left), self.get_height(x.right))\n        y.height = 1 + max(self.get_height(y.left), self.get_height(y.right))\n        \n        # Return the new root of the balanced subtree\n        return y\n\n    def preorder(self):\n        \"\"\"Returns the pre-order traversal of the tree.\"\"\"\n        result = []\n        self._preorder_recursive(self.root, result)\n        return result\n\n    def _preorder_recursive(self, node, result):\n        if node:\n            result.append(node.key)\n            self._preorder_recursive(node.left, result)\n            self._preorder_recursive(node.right, result)\n\ndef solve():\n    test_cases = [\n        [],\n        [30, 20, 10],\n        [10, 20, 30],\n        [30, 10, 20],\n        [10, 30, 20],\n        [10, 20, 30, 40, 50, 25],\n        [10, 10, 10],\n    ]\n\n    results = []\n    for keys in test_cases:\n        tree = AVLTree()\n        for key in keys:\n            tree.insert(key)\n        results.append(tree.preorder())\n\n    # Format the final output string exactly as required\n    output_str = f\"[{','.join(str(r).replace(' ', '') for r in results)}]\"\n    print(output_str)\n\nsolve()\n```", "id": "3210793"}]}