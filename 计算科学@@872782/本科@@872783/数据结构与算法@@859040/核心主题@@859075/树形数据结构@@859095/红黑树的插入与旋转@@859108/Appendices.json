{"hands_on_practices": [{"introduction": "红黑树的平衡之美在于其精巧的旋转和重新着色规则。为了深入理解这些机制，我们将从一个核心场景开始：单次插入如何触发两次旋转。这个练习 [@problem_id:3266096] 将帮助你识别并构建一个最小化的例子，从而精确掌握导致双旋转（左-右或右-左旋转）的“内侧子节点”情形。", "problem": "红黑树（RBT）是一种二叉搜索树（BST），并附加了以下不变量：(i) 每个节点要么是红色，要么是黑色，(ii) 根节点是黑色的，(iii) 所有外部空叶子节点都是黑色的，(iv) 没有红色节点有红色的子节点，以及 (v) 从一个节点到其任何外部叶子节点的每条简单路径都包含相同数量的黑色节点（黑高）。插入操作首先像在二叉搜索树中一样插入新键并将其着色为红色，然后通过一系列有限的局部重新着色和旋转来恢复不变量。在标准的教科书修复方法中，设新插入的节点为 $z$，其父节点为 $P$，其祖父节点为 $G$，其叔叔节点为 $U$。当 $P$ 为红色时：\n- 情况1：$U$ 是红色的。将 $P$ 和 $U$ 重新着色为黑色，$G$ 重新着色为红色，并令 $z \\leftarrow G$ 继续处理。\n- 情况2：$U$ 是黑色的，且 $z$ 是一个内部子节点（相对于 $G$ 是“左-右”或“右-左”）。围绕 $P$ 旋转一次，以转换为情况3。\n- 情况3：$U$ 是黑色的，且 $z$ 是一个外部子节点（相对于 $G$ 是“左-左”或“右-右”）。围绕 $G$ 旋转一次，并进行适当的重新着色。最后，将根节点重新着色为黑色。\n\n在此算法中，单次插入最多可以触发2次旋转。您的任务是确定一个最小的示例（插入的总键数最少），其中单次插入在其修复过程中需要恰好2次旋转，并正确说明是哪种情况转换导致了该次插入的2次旋转。\n\n选择所有同时满足以下条件的选项：\n- 提供一个将不同整数键插入初始空树的最小插入序列，其最后一次插入在该插入的修复过程中恰好触发2次旋转，并且\n- 使用上面的情况编号，正确地指出导致这2次旋转的情况转换解释。\n\nA. 按顺序插入 $[10, 5, 7]$。解释：最后一次插入的修复操作在同一个祖父节点处执行了$\\text{情况 }2$后接着执行$\\text{情况 }3$，恰好产生2次旋转。\n\nB. 按顺序插入 $[10, 5, 1, 7]$。解释：最后一次插入的修复操作执行了$\\text{情况 }1$后接着执行$\\text{情况 }3$，恰好产生2次旋转。\n\nC. 按顺序插入 $[10, 15, 12]$。解释：最后一次插入的修复操作执行了$\\text{情况 }2$后接着执行$\\text{情况 }3$（“左-右”的镜像情况），恰好产生2次旋转。\n\nD. 按顺序插入 $[10, 5, 7]$。解释：最后一次插入的修复操作执行了$\\text{情况 }1$后接着执行$\\text{情况 }3$，恰好产生2次旋转。\n\nE. 按顺序插入 $[10, 5, 3]$。解释：最后一次插入的修复操作仅为$\\text{情况 }3$，恰好产生2次旋转。", "solution": "该问题要求找出向红黑树中插入的最小序列，使得最后一次插入的修复过程恰好引起2次旋转，并根据所提供的情况定义，给出对这些旋转的正确解释。\n\n首先，我们来验证一下问题陈述。\n该问题定义了红黑树及其标准不变量，以及一种常见的插入修复算法变体。关于节点（$z$、$P$、$G$、$U$）、不变量以及修复过程的各种情况的定义，与该主题的既有文献（例如 Cormen、Leiserson、Rivest 和 Stein 的《算法导论》）是一致的。该问题提法得当，在计算机科学领域有科学依据，并且陈述客观。所有必要的信息都已提供。因此，该问题是有效的，我们可以着手求解。\n\n问题的核心是理解修复算法是如何产生旋转的。我们来分析每种情况产生的旋转次数：\n- **情况1**：叔叔节点 $U$ 是红色的。这种情况只涉及节点重新着色，并通过设置 $z \\leftarrow G$ 将问题向上传播到树的更高层。它执行**零次**旋转。\n- **情况2**：叔叔节点 $U$ 是黑色的，且 $z$ 是一个内部子节点。这种情况会围绕父节点 $P$ 执行**一次**旋转。这种情况的明确目的是将结构转换为情况3的配置。\n- **情况3**：叔叔节点 $U$ 是黑色的，且 $z$ 是一个外部子节点。这种情况会围绕祖父节点 $G$ 执行**一次**旋转，然后终止循环。\n\n单次插入最多可以触发2次旋转。要恰好实现2次旋转，修复过程必须执行一系列情况处理器，其旋转次数总和为2。\n根据定义：\n- 一个`情况1 - 情况3`的序列将包含来自情况1的零次旋转，随后是在树的更高层级上由情况3产生的一次旋转，总计1次旋转。\n- 仅有`情况3`的情况会产生1次旋转。\n- 实现恰好2次旋转的唯一方法是首先遇到**情况2**，它执行1次旋转，并根据定义将子树转换为**情况3**的配置。然后立即处理这个情况3，执行第二次旋转并终止修复过程。\n\n因此，唯一能产生恰好2次旋转的机制是**情况2 → 情况3**的序列。这种情况发生在修复涉及“内部子节点”（相对于祖父节点的“左-右”或“右-左”Z字形配置）的双红冲突时。现在，我们根据这个原则评估每个选项。\n\n一个最小的例子需要一个祖父-父-子结构，这意味着至少需要3个节点。选项A和C都提出了3个键的序列。\n\n**选项A：按顺序插入 $[10, 5, 7]$。解释：最后一次插入的修复操作在同一个祖父节点处执行了$\\text{情况 }2$后接着执行$\\text{情况 }3$，恰好产生2次旋转。**\n\n1.  插入 $10$：树是一个单独的黑色节点，$10(\\text{B})$。\n2.  插入 $5$：树是 $10(\\text{B}) \\leftarrow 5(\\text{R})$。这是一个有效的红黑树。\n3.  插入 $7$：\n    -   标准的BST插入将7作为5的右子节点。树的结构是 $10(\\text{B}) \\leftarrow 5(\\text{R}) \\rightarrow 7(\\text{R})$。\n    -   这产生了一个冲突：$7(\\text{R})$的父节点$5(\\text{R})$也是红色的。\n    -   在对 $z=7$ 的修复中：父节点 $P=5$，祖父节点 $G=10$。叔叔节点 $U$（10的右子节点）是一个空叶子节点，是黑色的。\n    -   $P$ 是 $G$ 的左子节点，$z$ 是 $P$ 的右子节点。这是一个“左-右”配置，属于内部子节点。这是**情况2**。\n    -   情况2的操作：对 $P=5$ 执行一次左旋。这是**第一次旋转**。在 $G=10$ 下的子树现在以 $7(\\text{R})$ 作为其左子节点，而 $7(\\text{R})$ 又以 $5(\\text{R})$ 作为其左子节点。\n    -   这将结构转换为“左-左”的外部子节点配置。这现在是**情况3**。\n    -   情况3的操作：对 $G=10$ 执行一次右旋，并重新着色。这是**第二次旋转**。\n    -   修复过程终止。总旋转次数恰好是2次。解释是正确的。\n    -   **结论：正确。**\n\n**选项B：按顺序插入 $[10, 5, 1, 7]$。解释：最后一次插入的修复操作执行了$\\text{情况 }1$后接着执行$\\text{情况 }3$，恰好产生2次旋转。**\n\n1.  插入 $10, 5, 1$：在这些插入之后，树变为 $5(\\text{B})$，其子节点为 $1(\\text{R})$ 和 $10(\\text{R})$。\n2.  插入 $7$：\n    -   BST插入将7作为10的左子节点。树的结构为：$5(\\text{B}) \\rightarrow 10(\\text{R}) \\leftarrow 7(\\text{R})$。\n    -   冲突：$7(\\text{R})$的父节点 $P=10(\\text{R})$ 是红色的。\n    -   在对 $z=7$ 的修复中：$P=10$，$G=5$。叔叔节点 $U$ 是 $G=5$ 的另一个子节点，即 $1(\\text{R})$。\n    -   由于叔叔节点 $U=1$ 是红色的，这是**情况1**。\n    -   情况1的操作：将 $P(10)$ 和 $U(1)$ 重新着色为黑色，并将 $G(5)$ 重新着色为红色。$z$ 更新为 $G=5$。节点5是根节点，所以它的父节点是黑色的（空）。循环 `while P is red` 终止。最后一步是将根节点着色为黑色。情况1执行**零次**旋转。\n    -   插入7导致了零次旋转。该解释在事实上是错误的，因为它声称发生了2次旋转，而且 `情况1 - 情况3` 的序列无论如何也只会产生1次旋转。\n    -   **结论：不正确。**\n\n**选项C：按顺序插入 $[10, 15, 12]$。解释：最后一次插入的修复操作执行了$\\text{情况 }2$后接着执行$\\text{情况 }3$（“左-右”的镜像情况），恰好产生2次旋转。**\n\n1.  插入 $10$：树是一个单独的黑色节点，$10(\\text{B})$。\n2.  插入 $15$：树是 $10(\\text{B}) \\rightarrow 15(\\text{R})$。\n3.  插入 $12$：\n    -   BST插入将12作为15的左子节点。树的结构为：$10(\\text{B}) \\rightarrow 15(\\text{R}) \\leftarrow 12(\\text{R})$。\n    -   冲突：$12(\\text{R})$的父节点 $P=15(\\text{R})$ 是红色的。\n    -   在对 $z=12$ 的修复中：$P=15$，$G=10$。叔叔节点 $U$（10的左子节点）是一个空叶子节点，是黑色的。\n    -   $P$ 是 $G$ 的右子节点，$z$ 是 $P$ 的左子节点。这是一个“右-左”配置，是选项A的镜像情况。这是一个内部子节点的情况。这是**情况2**。\n    -   情况2的操作：对 $P=15$ 执行一次右旋。这是**第一次旋转**。\n    -   这将结构转换为“右-右”的外部子节点配置。这现在是**情况3**。\n    -   情况3的操作：对 $G=10$ 执行一次左旋。这是**第二次旋转**。\n    -   修复过程终止，恰好执行了2次旋转。解释是正确的。\n    -   **结论：正确。**\n\n**选项D：按顺序插入 $[10, 5, 7]$。解释：最后一次插入的修复操作执行了$\\text{情况 }1$后接着执行$\\text{情况 }3$，恰好产生2次旋转。**\n\n-   插入序列与选项A中的相同。如前所述，修复操作执行的是`情况2 - 情况3`序列。此选项提供了错误的解释，即`情况1 - 情况3`。情况1根本没有发生。此外，`情况1 - 情况3`的序列只会导致1次旋转，而不是2次。因此，该解释是不正确的。\n-   **结论：不正确。**\n\n**选项E：按顺序插入 $[10, 5, 3]$。解释：最后一次插入的修复操作仅为$\\text{情况 }3$，恰好产生2次旋转。**\n\n1.  插入 $10$：$10(\\text{B})$。\n2.  插入 $5$：$10(\\text{B}) \\leftarrow 5(\\text{R})$。\n3.  插入 $3$：\n    -   BST插入将3作为5的左子节点。树的结构为：$10(\\text{B}) \\leftarrow 5(\\text{R}) \\leftarrow 3(\\text{R})$。\n    -   冲突：$3(\\text{R})$的父节点 $P=5(\\text{R})$ 是红色的。\n    -   在对 $z=3$ 的修复中：$P=5$，$G=10$。叔叔节点 $U$ 是黑色的（空叶子节点）。\n    -   $P$ 是 $G$ 的左子节点，$z$ 是 $P$ 的左子节点。这是一个“左-左”配置，是一个外部子节点。这直接是**情况3**。\n    -   情况3的操作：执行一次旋转（对 $G=10$ 进行右旋）并重新着色。修复过程终止。\n    -   这次插入恰好产生**一次**旋转。该解释错误地声称产生了2次。\n    -   **结论：不正确。**\n\n总而言之，选项A和C都提供了最小的3键插入序列，其中最后一次插入恰好触发2次旋转，并且都为这一现象提供了正确的`情况2 - 情况3`的解释。", "answer": "$$\\boxed{AC}$$", "id": "3266096"}, {"introduction": "掌握了单个修复情况后，下一步是预测在一棵更复杂的树中插入操作所引发的完整连锁反应。这个练习 [@problem_id:3266139] 要求你在不实际绘图或模拟的情况下，仅通过分析红黑树的属性和插入规则，来推断出一系列精确的平衡操作。这能极大地锻炼你的逻辑推理和算法追踪能力。", "problem": "考虑一棵增加了红黑属性的二叉搜索树（BST）（通常称为红黑树），其中以下核心定义成立：根节点是黑色的，每个节点要么是红色要么是黑色，每个红色节点的孩子都是黑色的，并且从根节点到任意叶子节点的每条路径都包含相同数量的黑色节点（称为黑高）。插入操作首先像在 BST 中一样放置新键值，初始时将新节点染成红色，然后使用局部重新着色（仅当新插入节点的父节点和叔叔节点都为红色时）和由父子关系的方向决定的旋转（左旋、右旋、左右旋、右左旋）来恢复红黑属性。\n\n假设 $T$ 是一棵有效的红黑树，其键值和颜色如下。根节点是键值为 $50$ 的黑色节点。其左孩子是键值为 $30$ 的红色节点，右孩子是键值为 $70$ 的黑色节点。节点 $30$ 有两个孩子：左孩子是键值为 $20$ 的黑色节点，右孩子是键值为 $40$ 的黑色节点。节点 $20$ 有两个孩子：左孩子是键值为 $15$ 的红色节点，右孩子是键值为 $25$ 的红色节点。所有其他未明确提及的孩子都是叶子节点且为黑色。\n\n在不绘制或模拟对 $T$ 的操作的情况下，利用红黑属性和插入修复规则，预测插入键值 $k=23$ 时触发的平衡操作的确切序列。为了得到最终的数值答案，请按时间顺序对该序列进行编码，使用以下映射：$L \\mapsto 1$，$R \\mapsto 2$，$\\text{LR} \\mapsto 3$，$\\text{RL} \\mapsto 4$，以及当父节点和叔叔节点都为红色时的重新着色步骤（称之为颜色翻转）$C \\mapsto 5$。如果序列包含 $m$ 个步骤，其代码为 $c_{1},c_{2},\\ldots,c_{m}$，则编码整数定义为\n$$\nE \\;=\\; \\sum_{i=1}^{m} c_{i}\\,10^{\\,m-i}.\n$$\n将单个数字 $E$ 作为您的最终答案返回。无需四舍五入。", "solution": "我们从红黑树的不变性和二叉搜索树（BST）的插入机制开始。插入一个键值的过程是：首先将新键值放置在其 BST 位置上，并初始将新节点染成红色。随后的任何违规都通过局部重新着色和旋转来修复，这些修复操作遵循以下既定规则：\n\n1. 如果新插入的节点的父节点和叔叔节点都是红色的，则在祖父节点处执行一次颜色翻转：父节点和叔叔节点被重新染成黑色，祖父节点被重新染成红色，之后从祖父节点开始继续修复过程。\n2. 如果新插入的节点的父节点是红色而叔叔节点是黑色的，则需要进行旋转。具体的旋转类型取决于相对于祖父节点的局部配置是左-左、左-右、右-右还是右-左。在左-左情况下，在祖父节点处执行右旋；在右-右情况下，在祖父节点处执行左旋；在左-右情况下，首先在父节点处执行左旋，然后在祖父节点处执行右旋；在右-左情况下，首先在父节点处执行右旋，然后在祖父节点处执行左旋。旋转后，进行局部重新着色以恢复红黑属性，一旦当前节点的父节点变为黑色，循环即终止。\n\n现在我们确定键值 $k=23$ 在树 $T$ 中的 BST 位置：\n- 将 $23$ 与 $50$ 比较：由于 $2350$，转到左孩子 $30$。\n- 将 $23$ 与 $30$ 比较：由于 $2330$，转到左孩子 $20$。\n- 将 $23$ 与 $20$ 比较：由于 $23>20$，转到右孩子 $25$。\n- 将 $23$ 与 $25$ 比较：由于 $2325$，插入位置是 $25$ 的左孩子。\n\n因此，键值为 $23$ 的新节点作为节点 $25$ 的左孩子插入，并初始染成红色。\n\n插入后，立即检查新插入的红色节点周围的局部配置：\n- 父节点是节点 $25$，它是红色的。\n- 叔叔节点是父节点的兄弟节点，即节点 $15$，该节点也是红色的。\n- 祖父节点是节点 $20$，它是黑色的。\n\n因为父节点和叔叔节点都是红色的，我们在祖父节点 $20$ 处执行一次颜色翻转。根据重新着色规则，$25$ 变为黑色，$15$ 变为黑色，$20$ 变为红色。这次重新着色后，需要继续进行修复的当前节点是祖父节点，即节点 $20$（现在是红色）。这构成了一个颜色翻转步骤，编码为 $C \\mapsto 5$。\n\n接下来，我们检查当前节点 $20$ 及其父节点是否存在违规：\n- $20$ 的父节点是 $30$，它是红色的。\n- 在这一层，$20$ 的叔叔节点是节点 $40$，它是黑色的。\n- 在这一层，祖父节点是 $50$，它是黑色的。\n- 其方向如下：$20$ 是 $30$ 的左孩子，$30$ 是 $50$ 的左孩子，这是相对于 $50$ 的左-左情况。\n\n在父节点为红色、叔叔节点为黑色的左-左配置下，解决方法是在祖父节点 $50$ 处进行一次右旋，然后进行局部重新着色。在 $50$ 处执行右旋后，$30$ 成为子树的根，$50$ 成为其右孩子，$20$ 成为其左孩子。此情况下的标准重新着色操作是将 $30$ 变为黑色，$50$ 变为红色，从而局部恢复红黑属性并打破了红-红链。这构成了一个右旋步骤，编码为 $R \\mapsto 2$。\n\n这次旋转之后，当前节点的父节点变为黑色，因此修复过程终止。因此，按时间顺序排列的平衡操作的确切序列是：\n- 首先，一次颜色翻转 ($C$)。\n- 其次，一次右旋 ($R$)。\n\n使用规定的编码 $L \\mapsto 1$, $R \\mapsto 2$, $\\text{LR} \\mapsto 3$, $\\text{RL} \\mapsto 4$, $C \\mapsto 5$，序列 $(C, R)$ 对应于代码序列 $(5, 2)$。编码整数的计算方式如下\n$$\nE \\;=\\; \\sum_{i=1}^{m} c_{i}\\,10^{\\,m-i} \\;=\\; 5\\cdot 10^{\\,2-1} \\;+\\; 2\\cdot 10^{\\,2-2} \\;=\\; 5\\cdot 10 \\;+\\; 2\\cdot 1 \\;=\\; 50 \\;+\\; 2 \\;=\\; 52.\n$$\n因此，所要求的最终数字是 $52$。", "answer": "$$\\boxed{52}$$", "id": "3266139"}, {"introduction": "算法的每一步都至关重要，一个微小的错误可能导致整个数据结构的崩溃。在这个思想实验 [@problem_id:3266135] 中，你将面对一个有缺陷的旋转实现——它忘记了更新父指针。你的任务是构建一个反例，揭示这个“小”错误如何破坏红黑树的不变性，从而深刻理解算法设计的严谨性。", "problem": "考虑一个维护了以下不变量的红黑树（RBT）：(i) 根节点是黑色的，(ii) 每个叶子节点（哨兵 $\\mathsf{nil}$）是黑色的，(iii) 没有红色节点有红色的子节点，以及 (iv) 对于每个节点，从该节点到其所有后代叶子节点的简单路径都包含相同数量的黑色节点（即相等的黑高）。标准的插入过程首先像在二叉搜索树（BST）中一样插入一个新键，并将新节点着色为红色，然后应用 Thomas H. Cormen、Charles E. Leiserson、Ronald L. Rivest 和 Clifford Stein (CLRS) 的《算法导论》（第三版）中广泛使用的修复程序来恢复 RBT 不变量。修复程序根据需要执行旋转；哨兵 $\\mathsf{nil}$ 被用作共享的黑色叶子节点，并且像 CLRS 实现中一样使用父指针。\n\n假设 LeftRotate 操作的实现存在以下错误：当对一个节点 $x$（其右子节点为 $y$）执行左旋时，该实现省略了赋值操作 $x.\\mathrm{p} \\leftarrow y$（即 $x$ 的父指针未被更新以指向 $y$）。所有其他赋值操作均遵循标准的 CLRS LeftRotate 规范，包括 $y.\\mathrm{p}$ 被正确更新以及子指针被正确调整。RightRotate 操作的实现是正确的。每次插入后，CLRS 插入修复程序都会运行至完成。\n\n从一棵空的 RBT 开始，下列哪个插入序列提供了一个最小反例，即在该序列中的所有键都已插入并且（有错误的）修复程序已应用之后，该树违反了至少一个 RBT 不变量，而其左/右子指针仍然表示一个有效的 BST？\n\nA. 依次插入 $10, 20, 30, 5$。\n\nB. 依次插入 $10, 20, 30, 25$。\n\nC. 依次插入 $10, 5, 1, 0$。\n\nD. 依次插入 $10, 2, 3, 4$。\n\n仅选择一个能明确展示由所述 LeftRotate 父指针错误导致的 RBT 不变量违规的选项，而不是由于不正确的 BST 排序或其他未指明的故障。基于第一性原理证明你的选择：红黑树不变量、CLRS 插入修复逻辑以及旋转的指针语义。[@problem_id:1502]", "solution": "用户要求我找出一个最小插入序列，在 `LeftRotate` 操作存在特定错误的情况下，该序列会导致红黑树（RBT）的不变量被违反。\n\n### 问题陈述验证\n\n**步骤 1：提取给定条件**\n- **数据结构**：红黑树（RBT），具有标准的 CLRS 不变量：\n    1. 根节点是黑色的。\n    2. 所有叶子节点（$\\mathsf{nil}$）都是黑色的。\n    3. 如果一个节点是红色的，那么它的两个子节点都是黑色的（无红-红冲突）。\n    4. 对每个节点，从该节点到其所有后代叶子节点的简单路径都具有相同的黑高。\n- **插入规则**：标准的二叉搜索树（BST）插入，将新节点着色为红色，然后执行 CLRS 的 `RB-INSERT-FIXUP` 程序。\n- **实现细节**：树使用一个共享的哨兵黑色叶子节点（$\\mathsf{nil}$）和父指针。`RightRotate` 操作是正确的。\n- **错误**：`LeftRotate(x)` 操作（其中 `y` 是 `x` 的右子节点）省略了最后的指针赋值 `x.p \\leftarrow y`。`LeftRotate` 中的所有其他指针赋值都正确执行。\n- **目标**：从给定选项中找出最小的插入序列，该序列导致树违反至少一个 RBT 不变量，但其子指针仍保持 BST 属性。该违规必须是由于有错误的 `LeftRotate` 直接导致的。\n\n**步骤 2：使用提取的给定条件进行验证**\n- **科学依据**：该问题基于经典的红黑树数据结构及其标准插入算法，该算法在计算机科学的基石教科书《算法导论》（CLRS）中有详细描述。所描述的错误是对该算法的一个具体、可形式化的修改。该问题在科学上是合理的。\n- **定义明确**：该问题定义明确。它指定了数据结构、不变量、插入算法和一个精确的错误。它要求从一组给定选项中识别出一个序列，该序列会导致一个具体、可验证的结果（RBT 不变量违规）。“最小反例”在这里是明确的，因为所有提供的序列长度相同（$4$），我们正在寻找一个能证明失败的序列。\n- **客观性**：问题以精确、技术性的语言陈述，没有主观性或歧义。\n\n**步骤 3：结论与行动**\n问题陈述是有效的。这是一个数据结构和算法领域中定义明确的问题，需要对指定算法在错误条件下的行为进行严格的逐步分析。我将继续进行推导。\n\n### 推导与解答\n\n问题的核心在于理解有错误的 `LeftRotate(x)` 操作所带来的后果。在一个标准的 `LeftRotate(x)` 操作中，当 `y` 是 `x` 的右子节点时，`y` 会取代 `x` 在树中的位置，而 `x` 成为 `y` 的左子节点。最后一步 `x.p \\leftarrow y` 对于反映这种新关系至关重要。题目中的错误指出这一步被省略了。因此，在一个有错误的 `LeftRotate(x)` 操作之后，`x` 的父指针 `x.p` 将保留其旧值（指向 `x` 的原始父节点），而不是指向 `y`。这在子/父指针之间造成了不一致。如果 `RB-INSERT-FIXUP` 过程中的后续操作依赖于这个被破坏的父指针，就会发生 RBT 不变量违规。\n\nCLRS 中的 `RB-INSERT-FIXUP` 程序在修复节点 `z` 与其父节点 `p` 之间的红-红冲突时，会在两种情况下调用 `LeftRotate`：\n1.  **对称情况 2**：如果 `p` 是其父节点 `g`（`z` 的祖父节点）的左子节点，而 `z` 是 `p` 的右子节点。此时执行 `LeftRotate(p)`。\n2.  **情况 3**：如果 `p` 是 `g` 的右子节点，而 `z` 是 `p` 的右子节点。此时执行 `LeftRotate(g)`。\n\n我们现在将追踪每个给定的插入序列，以确定哪一个会触发 `LeftRotate`，并随后因被破坏的父指针而导致 RBT 不变量违规。\n\n**A. 依次插入 $10, 20, 30, 5$。**\n\n1.  **插入 $10$**：树为 `$10(B)$`。\n2.  **插入 $20$**：`$20(R)$` 是 `$10(B)$` 的右子节点。没有违规。树为 `$10(B) \\rightarrow 20(R)$`。\n3.  **插入 $30$**：`$30(R)$` 作为 `$20(R)$` 的右子节点插入。这造成了一个红-红冲突。\n    -   `z=30(R)`，`p=z.p=20(R)`，`g=p.p=10(B)`。\n    -   父节点 `p` 是 `g` 的右子节点，`z` 是 `p` 的右子节点。这是**情况 3**。\n    -   修复程序执行：\n        a. 将 `p` 重新着色为黑色：`$20(B)$`。\n        b. 将 `g` 重新着色为红色：`$10(R)$`。\n        c. 执行 `LeftRotate(g)`，即 `LeftRotate(10)`。\n    -   在有错误的 `LeftRotate(10)` 中，设 `x=10` 和 `y=20`。该操作正确地将 `$20$` 设为子树的新根，`$10$` 成为其左子节点。然而，步骤 `$x.p \\leftarrow y$`（即 `$10.p \\leftarrow 20$`) 被**省略**了。由于 `$10$` 原本是根节点，其父指针为 `nil`。因此，`$10.p` 仍然是 `nil`。\n    -   修复后，树的子指针表示 `$20(B)$` 为根，左子节点为 `$10(R)$`，右子节点为 `$30(R)$`。\n    -   父指针：`$20.p` 是 `nil`，`$30.p` 是 `$20$`。关键是，`$10.p` 是 `nil`（这是错误导致的）。\n    -   在此阶段，所有 RBT 不变量都成立。\n4.  **插入 $5$**：`$5(R)$` 作为 `$10(R)$` 的左子节点插入。这造成了一个红-红冲突。\n    -   `z=5(R)`，`p=z.p=10(R)`。`RB-INSERT-FIXUP` 中的 `while (z.p.color == RED)` 循环开始。\n    -   在循环内部，算法计算祖父节点 `g = p.p = 10.p`。由于前一步的错误，`$10.p` 是 `nil`。\n    -   CLRS 算法假设，如果一个节点的父节点 `p` 是红色的，那么 `p` 不可能是根节点，因此祖父节点 `g` 必须存在（即不为 `nil`）。这个错误违反了这一前提条件。\n    -   任何访问 `g` 的子节点（例如，寻找叔叔节点 `y = g.right`）的尝试都会导致空指针解引用。一个健壮的实现可能会提前终止修复程序。假设程序中止，`$5(R)$` 和 `$10(R)$` 之间的红-红冲突将永远不会被解决。\n    -   最终的树状态（基于子指针）是：\n        $$\n        \\begin{array}{c}\n        20(B) \\\\\n        /   \\quad \\\\\n        10(R) \\quad 30(R) \\\\\n        / \\\\\n        5(R)\n        \\end{array}\n        $$\n    -   **验证**：\n        -   子指针表示一个有效的 BST（$5  10  20  30$）。\n        -   RBT 不变量 (iii) 被**违反**：节点 `$5(R)$` 有一个红色的父节点 `$10(R)$`。\n        -   这个违规是错误的直接结果，该错误导致了修复失败。\n\n因此，这个序列是一个有效的反例。\n\n**B. 依次插入 $10, 20, 30, 25$。**\n\n1.  **插入 $10, 20, 30$**：与选项 A 相同。树的根为 `$20(B)$`，子节点为 `$10(R)$` 和 `$30(R)$`，且存在错误的指针 `$10.p = \\text{nil}`。\n2.  **插入 $25$**：`$25(R)$` 作为 `$30(R)$` 的左子节点插入。这造成了一个红-红冲突。\n    -   `z=25(R)`，`p=z.p=30(R)`，`g=p.p=20(B)`。叔叔节点 `u = g.left = 10(R)`。\n    -   这是**情况 1**（红色叔叔节点）。修复程序将 `p`（`$30$`）重新着色为黑色，将 `u`（`$10$`）重新着色为黑色，并将 `g`（`$20$`）重新着色为红色。然后，`z` 更新为 `g`（`$20$`）并继续循环。\n    -   新的 `z` 是 `$20(R)$`。它的父节点 `z.p` 是 `nil`，是黑色的。循环终止。\n    -   插入的最后一步将根节点着色为黑色，所以 `$20$` 再次变为黑色。\n    -   最终的树是有效的，并满足所有 RBT 不变量。在修复 `$25$` 的过程中，从未访问过错误的指针 `$10.p`。\n\n因此，这个序列不是一个反例。\n\n**C. 依次插入 $10, 5, 1, 0$。**\n\n这个序列只包含左侧插入。\n1.  **插入 $10, 5, 1$**：插入 `$1$` 会造成红-红冲突（`$1(R), 5(R)$`）。`p = 5` 是 `g = 10` 的左子节点，`z = 1` 是 `p` 的左子节点。这是一个对称情况 3，会触发 `RightRotate(10)`。\n2.  **插入 $0$**：插入 `$0$` 会造成红-红冲突（`$0(R), 1(R)$`）。这会触发一个情况 1 的修复（红色叔叔节点）。\n整个序列只涉及 `RightRotate` 操作，而该操作被指定为正确的。有错误的 `LeftRotate` 从未被调用。因此，最终得到的树将是一个有效的 RBT。\n\n因此，这个序列不是一个反例。\n\n**D. 依次插入 $10, 2, 3, 4$。**\n\n1.  **插入 $10, 2$**：树为 `$10(B) \\leftarrow 2(R)$`。\n2.  **插入 $3$**：`$3(R)$` 作为 `$2(R)$` 的右子节点插入。红-红冲突。\n    -   `z=3(R)`，`p=2(R)`，`g=10(B)`。`p` 是 `g` 的左子节点，`z` 是 `p` 的右子节点。这是**对称情况 2**。\n    -   修复程序将 `z \\leftarrow p`（所以 `z` 变成 `$2$`）并执行 `LeftRotate(z)`（即 `LeftRotate(2)`）。\n    -   有错误的 `LeftRotate(2)` 被调用。设 `x=2, y=3`。`$2$` 的父节点是 `$10$`。操作省略了 `$x.p \\leftarrow y`（`$2.p \\leftarrow 3$`），所以 `$2.p` 仍然指向 `$10$`。\n    -   修复继续进行，转变为对称情况 3，并执行一个正确的 `RightRotate(10)`。所有操作完成后，树是一个有效的 RBT，但内部状态不一致：`$3$` 的子节点是 `$2$`，但 `$2.p$` 指向 `$10$`。\n3.  **插入 $4$**：插入 `$4(R)`，造成红-红冲突。修复是情况 1（红色叔叔节点）。修复操作读取了叔叔节点 `$2$` 的颜色，但没有使用 `$2$` 的父指针进行导航。错误的指针 `$2.p` 从未被访问。最终的树满足所有 RBT 不变量。\n\n因此，这个序列不是一个反例，因为尽管错误被触发，但它没有导致在最终树中违反四个外部 RBT 不变量。\n\n### 结论\n\n只有选项 A 中的插入序列会导致这样一种状态：有错误的 `LeftRotate` 导致父指针损坏，这反过来又导致后续的 `RB-INSERT-FIXUP` 失败，使树处于违反红-红属性（RBT 不变量 iii）的状态。\n\n**选项最终分析：**\n-   **A**：造成了一个红-红冲突，由于修复程序因错误而失败，该冲突未被修复。**正确**。\n-   **B**：错误被触发，但后续插入的修复不依赖于被破坏的指针。最终的树是一个有效的 RBT。**错误**。\n-   **C**：有错误的 `LeftRotate` 从未被调用。最终的树是一个有效的 RBT。**错误**。\n-   **D**：错误被触发，造成了一个不一致的父指针，但后续的修复没有以违反 RBT 不变量的方式暴露这种不一致性。最终的树是一个有效的 RBT。**错误**。", "answer": "$$\\boxed{A}$$", "id": "3266135"}]}