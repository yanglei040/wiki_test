{"hands_on_practices": [{"introduction": "二叉搜索树（BST）的中序遍历会产生一个有序序列，这是其最核心的性质之一。本练习将挑战你运用这一基本性质，不仅用于排序，更将其作为一种诊断工具。通过在中序遍历中识别顺序被破坏的位置，你可以精确定位树中的两个被交换的节点，这是调试复杂数据结构时一项至关重要的技能。[@problem_id:3233436]", "problem": "给定一个二叉搜索树（BST）的形式化设定。二叉搜索树（BST）是一种有根二叉树，其中每个节点存储一个唯一的键 $k \\in \\mathbb{Z}$，使得对于任何键为 $k$ 的节点，其左子树中的所有键都严格小于 $k$，其右子树中的所有键都严格大于 $k$。对一个有效的二叉搜索树（BST）进行中序遍历会按严格递增的顺序访问其键。考虑一棵树，它是一个有效的二叉搜索树（BST），但其中恰好有两个节点的键被交换了。您的任务是仅使用 $O(h)$ 的额外空间（其中 $h$ 是树的高度）来定位这两个被交换的键，并且不能修改树的结构。\n\n您可以假设的基本依据和事实：\n- 二叉搜索树（BST）的顺序定义：对于每个键为 $k$ 的节点，其左子树中的键都 $ k$，右子树中的键都 $> k$。\n- 对具有唯一键的有效二叉搜索树（BST）进行中序遍历，会产生一个严格递增的键序列。\n\n您的程序必须：\n- 使用标准的二叉搜索树（BST）插入规则，按指定顺序将给定的键插入一个初始为空的树中，从而构建一棵二叉搜索树（BST）。\n- 交换两个指定节点（通过它们在任何交换前的原始键来识别）的键。\n- 使用至多 $O(h)$ 的额外空间，检测并返回这两个被交换的键，形式为一个包含两个按升序排列的整数的列表。\n- 对所有提供的测试用例重复此过程，并在单行上以指定的输出格式打印所有结果。\n\n约束和要求：\n- 所有键都是唯一的整数。\n- 恰好有一对节点的键被交换了。\n- 额外空间使用必须为 $O(h)$，其中 $h$ 是树的高度。对于 $n$ 个节点，时间复杂度应为 $O(n)$，通过使用一个大小为 $O(h)$ 的显式栈进行单次中序遍历实现。\n\n用于覆盖一般情况和边界情况的测试套件。每个测试用例由一个插入序列和一对要交换的键指定：\n- 测试用例 $1$：插入序列 $[4,2,6,1,3,5,7]$，交换对 $(3,6)$。\n- 测试用例 $2$：插入序列 $[4,2,6,1,3,5,7]$，交换对 $(3,4)$。\n- 测试用例 $3$：插入序列 $[1,2,3,4,5,6]$，交换对 $(1,6)$。\n- 测试用例 $4$：插入序列 $[1,2]$，交换对 $(1,2)$。\n- 测试用例 $5$：插入序列 $[10,5,15,2,7,12,20,1,3,6,8,11,13,18,25]$，交换对 $(1,25)$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如 $[result_1,result_2,\\dots]$），其中每个 $result_i$ 本身是针对测试用例 $i$ 检测到的、按升序排列的两个交换键的列表 $[a,b]$。\n- 对于上述测试套件，您的程序必须以 $[[a_1,b_1],[a_2,b_2],[a_3,b_3],[a_4,b_4],[a_5,b_5]]$ 的格式精确打印一行，不含空格。", "solution": "### 问题验证\n\n**步骤 1：提取已知条件**\n- 二叉搜索树（BST）是一种有根二叉树，其中每个节点都有一个唯一的键 $k \\in \\mathbb{Z}$。\n- 对于任何键为 $k$ 的节点，其左子树中的所有键都严格小于 $k$，其右子树中的所有键都严格大于 $k$。\n- 对一个有效的BST进行中序遍历会按严格递增的顺序访问其键。\n- 输入是一棵有效的BST，但其中恰好有两个节点的键被交换。\n- 任务是定位这两个被交换的键。\n- 约束：解决方案必须仅使用 $O(h)$ 的额外空间，其中 $h$ 是树的高度，并且不得修改树的结构。对于有 $n$ 个节点的树，时间复杂度应为 $O(n)$。\n- 算法必须通过从给定的插入序列构建BST，交换两个指定节点的键，然后检测被交换的键来进行。\n- 测试用例：\n    1. 插入序列: $[4,2,6,1,3,5,7]$, 交换对: $(3,6)$\n    2. 插入序列: $[4,2,6,1,3,5,7]$, 交换对: $(3,4)$\n    3. 插入序列: $[1,2,3,4,5,6]$, 交换对: $(1,6)$\n    4. 插入序列: $[1,2]$, 交换对: $(1,2)$\n    5. 插入序列: $[10,5,15,2,7,12,20,1,3,6,8,11,13,18,25]$, 交换对: $(1,25)$\n- 输出必须是单行：`[[a_1,b_1],[a_2,b_2],...]`，不含空格。\n\n**步骤 2：使用提取的已知条件进行验证**\n根据验证标准评估问题陈述。\n- **科学性**：该问题基于计算机科学的基本、明确定义的概念，特别是数据结构理论（二叉搜索树）和算法（遍历、复杂度分析）。所有定义和属性都是标准的。该问题在科学上和数学上是合理的。\n- **适定性**：该问题是适定的。对于一个恰好有两个键被交换的BST，结构上的缺陷会在中序遍历产生的本应排序的序列中造成一个可预测和可识别的模式。这使得设计一个确定性算法来找到唯一的被交换键对成为可能。\n- **客观性**：问题陈述使用精确、正式的语言，没有歧义或主观性。\n- **完整性和一致性**：问题提供了所有必要信息：数据结构的定义、缺陷的性质、操作约束（$O(h)$ 空间、$O(n)$ 时间），以及一组清晰的用于验证的测试用例。这些约束相互一致，并且是此类问题的标准约束。\n\n**步骤 3：结论与行动**\n该问题被判定为**有效**。这是计算机科学中一个标准的、定义明确的算法挑战。将提供一个解决方案。\n\n### 基于原则的解决方案\n\n这个问题的解决依赖于二叉搜索树（BST）的一个基本属性：对一个有效的BST进行中序遍历会产生一个严格递增的键序列。设对一个有 $n$ 个节点的BST进行中序遍历得到的键序列为 $S = (k_1, k_2, \\dots, k_n)$。对于一个有效的BST，必须满足对于所有 $i \\in \\{1, 2, \\dots, n-1\\}$ 都有 $k_i  k_{i+1}$。\n\n当恰好有两个节点的键被交换时，这个严格递增的属性就被破坏了。我们的目标是在单次中序遍历中检测到这些违规情况，从而识别出参与交换的两个节点，同时遵守空间复杂度为 $O(h)$ 的约束，其中 $h$ 是树的高度。\n\n使用一个显式节点栈的迭代中序遍历满足此空间约束，因为栈的最大深度等于树的高度 $h$。在此遍历期间，我们可以将每个访问节点的键与前一个访问节点的键进行比较，以找到任何逆序对。\n\n设原始的、正确的、已排序的键序列为 $(x_1, x_2, \\dots, x_n)$。假设键 $x_i$ 和 $x_j$ 被交换，其中 $i  j$，因此 $x_i  x_j$。产生的中序序列将被扰乱。我们分析两种不同情况下的违规位置。\n\n**情况 1：交换了不相邻的键。**\n原始序列是 $(\\dots, x_{i-1}, x_i, x_{i+1}, \\dots, x_{j-1}, x_j, x_{j+1}, \\dots)$。\n交换 $x_i$ 和 $x_j$ 后，序列变为 $(\\dots, x_{i-1}, x_j, x_{i+1}, \\dots, x_{j-1}, x_i, x_{j+1}, \\dots)$。\n让我们检查非单调性的点：\n1.  在原来 $x_i$ 的位置上，我们现在有了 $x_j$。下一个键是 $x_{i+1}$。由于 $i+1 \\le j$，我们有 $x_{i+1} \\le x_j$。因为所有键都是唯一的，如果 $i+1  j$，那么 $x_{i+1}  x_j$。这造成了第一个违规：$x_j > x_{i+1}$。第一个错位的元素是 $x_j$。\n2.  在原来 $x_j$ 的位置上，我们现在有了 $x_i$。它前面的键是 $x_{j-1}$。键对是 $(x_{j-1}, x_i)$。由于 $i  j-1$，我们有 $x_i  x_{j-1}$。这造成了第二个违规：$x_{j-1} > x_i$。第二个错位的元素是 $x_i$。\n\n在这种情况下，我们会在遍历的序列中找到两对相邻的键 $(k_p, k_{p+1})$，满足 $k_p > k_{p+1}$。第一对中的第一个键 ($k_p$) 和第二对中的第二个键 ($k_{p+1}$) 构成了被交换的键对。\n\n**情况 2：交换了相邻的键。**\n原始序列是 $(\\dots, x_{i-1}, x_i, x_{i+1}, x_{i+2}, \\dots)$，我们交换 $x_i$ 和 $x_{i+1}$。\n序列变为 $(\\dots, x_{i-1}, x_{i+1}, x_i, x_{i+2}, \\dots)$。\n这里只有一个非单调点：键对 $(x_{i+1}, x_i)$，其中 $x_{i+1} > x_i$。在这种情况下，我们会找到恰好一对相邻的键 $(k_p, k_{p+1})$ 满足 $k_p > k_{p+1}$。这两个键，$k_p$ 和 $k_{p+1}$，正是被交换的键。\n\n**算法策略**\n一个统一的算法可以处理这两种情况。我们执行一次迭代式中序遍历，并跟踪前一个访问过的节点。我们维护三个指向节点的指针（或其键的变量）：`first`、`middle` 和 `last`。\n\n1.  将 `prev`（遍历中的前一个节点）、`first`、`middle`、`last` 初始化为空状态。\n2.  使用栈执行迭代式中序遍历。对于每个访问的节点 `curr`：\n3.  如果 `prev` 不为空且 `prev.key > curr.key`，则发现一个违规。\n    a. 如果 `first` 为空，这是遇到的第一个违规。我们记录 `first = prev` 和 `middle = curr`。`first` 持有错位对中的第一个元素，`middle` 持有第二个元素（以防这是唯一的违规，如相邻交换的情况）。\n    b. 如果 `first` 不为空，这是第二个违规。我们记录 `last = curr`。这个 `curr` 节点是非相邻情况下错位对的第二个元素。\n4.  更新 `prev = curr` 并继续遍历。\n5.  遍历完成后：\n    a. 如果 `last` 不为空（即我们找到了两个违规），被交换的键是 `first.key` 和 `last.key`。\n    b. 如果 `last` 为空（即我们只找到了一个违规），被交换的键是 `first.key` 和 `middle.key`。\n6.  最终结果是检测到的键对，按升序排序。\n\n该算法由于对树进行了一次完整的遍历，因此能在 $O(n)$ 时间内正确识别出被交换的键，并且需要 $O(h)$ 的辅助空间用于遍历栈，满足了所有问题约束。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass Node:\n    \"\"\"A node in a Binary Search Tree.\"\"\"\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\ndef insert_node(root, key):\n    \"\"\"Inserts a key into the BST and returns the root.\"\"\"\n    if root is None:\n        return Node(key)\n    \n    current = root\n    while True:\n        if key  current.key:\n            if current.left is None:\n                current.left = Node(key)\n                return root\n            current = current.left\n        else: # key > current.key, as keys are distinct\n            if current.right is None:\n                current.right = Node(key)\n                return root\n            current = current.right\n\ndef find_node(root, key):\n    \"\"\"Finds and returns the node with the given key.\"\"\"\n    current = root\n    while current is not None:\n        if key == current.key:\n            return current\n        elif key  current.key:\n            current = current.left\n        else:\n            current = current.right\n    return None\n\ndef find_swapped_keys(root):\n    \"\"\"\n    Finds the two swapped keys in a BST using an iterative in-order traversal.\n    Space complexity: O(h), where h is the tree height.\n    Time complexity: O(n), where n is the number of nodes.\n    \"\"\"\n    stack = []\n    current = root\n    \n    prev_node = None\n    first_violator = None\n    middle_violator = None\n    last_violator = None\n\n    while current is not None or stack:\n        while current is not None:\n            stack.append(current)\n            current = current.left\n            \n        current = stack.pop()\n        \n        # In-order processing logic\n        if prev_node is not None and prev_node.key > current.key:\n            # A violation is found\n            if first_violator is None:\n                # First violation\n                first_violator = prev_node\n                middle_violator = current\n            else:\n                # Second violation\n                last_violator = current\n\n        prev_node = current\n        current = current.right\n\n    if last_violator:\n        # Non-adjacent swap\n        key1 = first_violator.key\n        key2 = last_violator.key\n    else:\n        # Adjacent swap\n        key1 = first_violator.key\n        key2 = middle_violator.key\n        \n    return sorted([key1, key2])\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and produce the final output.\n    \"\"\"\n    test_cases = [\n        {'insert': [4, 2, 6, 1, 3, 5, 7], 'swap': (3, 6)},\n        {'insert': [4, 2, 6, 1, 3, 5, 7], 'swap': (3, 4)},\n        {'insert': [1, 2, 3, 4, 5, 6], 'swap': (1, 6)},\n        {'insert': [1, 2], 'swap': (1, 2)},\n        {'insert': [10, 5, 15, 2, 7, 12, 20, 1, 3, 6, 8, 11, 13, 18, 25], 'swap': (1, 25)},\n    ]\n\n    results_str = []\n    for case in test_cases:\n        # 1. Construct the BST\n        root = None\n        for key in case['insert']:\n            root = insert_node(root, key)\n            \n        # 2. Find and swap the specified nodes' keys\n        key_to_swap1, key_to_swap2 = case['swap']\n        node1 = find_node(root, key_to_swap1)\n        node2 = find_node(root, key_to_swap2)\n        if node1 and node2:\n            node1.key, node2.key = node2.key, node1.key\n\n        # 3. Detect the swapped keys\n        swapped_pair = find_swapped_keys(root)\n        \n        # 4. Format the result string\n        results_str.append(f\"[{swapped_pair[0]},{swapped_pair[1]}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```", "id": "3233436"}, {"introduction": "在掌握了如何利用BST性质进行观察后，我们将更进一步，学习如何改造它。本练习将引入“增强数据结构”这一强大概念，即在节点中存储额外信息以加速查询。你将通过增强一个BST，使其能高效地找出树中最小的奇数值键，并学习在插入和删除操作中如何维护这些额外信息，这是设计高级数据结构的关键一步。[@problem_id:3233444]", "problem": "您的任务是修改一个二叉搜索树 (BST)，使其支持查找奇数值键中的最小值。该二叉搜索树 (BST) 存储整数键，并满足不变量：对于每个键为 $x$ 的节点，其左子树中的所有键都严格小于 $x$，其右子树中的所有键都大于或等于 $x$。相等键通过插入到右子树来解决。形式上，当将键 $k$ 插入到键为 $x$ 的节点时，如果 $k  x$，则插入到左子节点；否则，插入到右子节点。删除操作会移除单个出现的键，并遵循标准的三种情况删除规则：如果要删除的节点有两个子节点，则用其中序后继替换它。\n\n请在此二叉搜索树 (BST) 的基础上设计一个增强数据结构，以支持如下定义的“最小奇数值键”操作。令 $S(T)$ 为树 $T$ 中存储的键集合。定义奇数键集合为 $O(T) = \\{ k \\in S(T) \\mid k \\equiv 1 \\pmod{2} \\}$。如果 $O(T) \\neq \\varnothing$，查询返回整数常规全序下的 $\\min O(T)$；如果 $O(T) = \\varnothing$，则返回一个哨兵值 $-1$。您必须实现插入和删除操作，以维护增强信息并确保查询的正确性。所有操作的运行时间必须为 $O(h)$，其中 $h$ 是二叉搜索树 (BST) 的高度。\n\n您可以假设的基本前提：\n- 二叉搜索树 (BST) 不变量的定义：对于每个键为 $x$ 的节点，其左子树中的所有键都 $ x$，其右子树中的所有键都 $\\ge x$。\n- 全序集上集合最小值的标准定义。\n- 使用中序后继的标准二叉搜索树 (BST) 删除操作。\n\n您的程序必须：\n- 根据上述规则，实现将一个整数键序列插入到初始为空的二叉搜索树 (BST) 中。\n- 实现删除一个给定的整数键序列，每次删除移除一个存在的键（如果存在）。\n- 维护回答所定义的“最小奇数值键”查询所需的任何增强信息。\n- 对于每个测试用例，在按顺序执行所有插入和删除操作后，输出“最小奇数值键”查询的结果，该结果为一个整数。如果奇数键集合为空，则使用 $-1$。\n\n测试套件：\n- 案例 1：插入 $[8,3,10,1,6,14,4,7,13]$，然后查询。预期覆盖包含奇数和偶数键的典型树。删除：无。\n- 案例 2：插入 $[2,4,6,8]$，然后查询。不含奇数键的边界情况。删除：无。\n- 案例 3：插入 $[5,3,7,3,5,9]$，删除 $[3,3]$，然后查询。覆盖重复键和对同一键的重复删除。\n- 案例 4：插入 $[0,-1,-2,-3,-4]$，然后查询。覆盖负整数和零。\n- 案例 5：插入 $[10,5,15,3,7,12,18]$，删除 $[5,3,7]$，然后查询。覆盖删除具有两个子节点的节点以及移除所有较小的奇数键的情况。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含按上述案例顺序排列的结果，格式为用方括号括起来的逗号分隔列表。例如，输出必须类似于 $[r_1,r_2,r_3,r_4,r_5]$，其中每个 $r_i$ 是案例 $i$ 的整数结果。\n\n此问题不涉及物理单位。所有角度、百分比和单位均不适用。唯一的输出是指定的整数。实现语言在概念层面上不受限制；但是，您最终提供的答案必须是其他地方指定的完整、可运行的程序。", "solution": "该问题要求设计一个增强二叉搜索树 (BST)，以高效地回答关于最小奇数值键的查询。该 BST 有一个特定的不变量：对于任何键为 $x$ 的节点，其左子树中的键严格小于 $x$ ($k  x$)，而其右子树中的键大于或等于 $x$ ($k \\ge x$)。所有操作——插入、删除和最小奇数值键查询——的时间复杂度都必须为 $O(h)$，其中 $h$ 是树的高度。\n\n**1. 问题验证**\n\n首先，对问题陈述进行验证。\n\n*   **提取已知条件**：\n    *   数据结构：存储整数键的二叉搜索树 (BST)。\n    *   BST 不变量：对于键为 $x$ 的节点，左子树的键 $k$ 满足 $k  x$；右子树的键 $k$ 满足 $k \\ge x$。\n    *   插入：若在键为 $x$ 的节点处插入键 $k$，如果 $k  x$ 则进入左子节点，否则进入右子节点。\n    *   删除：标准的三种情况删除法。具有两个子节点的节点被其中序后继替换。移除一个键的出现。\n    *   查询：在树中找到满足 $k \\equiv 1 \\pmod{2}$ 的最小键 $k$。如果不存在这样的键，返回 $-1$。\n    *   性能：所有操作（插入、删除、查询）的运行时间必须为 $O(h)$，其中 $h$ 是树的高度。\n    *   测试用例：提供了五个涉及插入和删除的特定测试用例以验证实现。\n\n*   **验证结论**：\n    *   该问题在科学上基于数据结构和算法的既定原则，特别是关于增强 BST 的主题。\n    *   问题陈述清晰，所有规则、约束和定义都明确无误。BST 操作是标准的，查询也经过了形式化定义。\n    *   问题是客观的，不含任何主观或非形式化元素。\n    *   约束条件是一致的，对于此类问题，$O(h)$ 的性能要求是标准的，并且已知是可实现的。\n\n该问题被认定为有效，可以制定解决方案。\n\n**2. 算法设计与原则**\n\n一个朴素的遍历树来查找最小奇数键的方法将耗时 $O(n)$，其中 $n$ 是节点数，这违反了 $O(h)$ 的约束。为了满足此要求，我们必须对 BST 进行增强。每个节点将存储有关以该节点为根的子树的摘要信息。\n\n**2.1. 增强方法**\n\n我们为 BST 中的每个节点 $p$ 增加一个额外字段，记为 $p.min\\_odd$。该字段存储以 $p$ 为根的子树内的最小奇数值键。如果子树中不存在奇数值键，该字段将持有一个特殊的哨兵值，我们可以表示为 $\\infty$。\n\n对于任何节点 $p$，其增强字段的不变量为：\n$$\np.min\\_odd = \\min \\left( \\{p.key \\mid p.key \\equiv 1 \\pmod{2} \\} \\cup \\{p.left.min\\_odd \\mid p.left \\neq \\text{null}\\} \\cup \\{p.right.min\\_odd \\mid p.right \\neq \\text{null}\\} \\right)\n$$\n其中，空集的最小值定义为 $\\infty$。\n\n**2.2. 查询操作**\n\n通过这种增强，对整个树 $T$ 中最小奇数键的查询变得微不足道。答案就是 $T.root.min\\_odd$ 的值。如果 $T.root$ 为空或 $T.root.min\\_odd = \\infty$，则意味着树中没有奇数键，我们返回指定的哨兵值 $-1$。此查询操作耗时 $O(1)$，满足 $O(h)$ 的要求。\n\n**2.3. 维护增强信息**\n\n问题的核心是在插入和删除过程中维护 $p.min\\_odd$ 不变量。这通过在修改路径上更新增强值来实现。我们定义一个函数 $\\text{UpdateMinOdd}(p)$，它根据节点自身的键及其子节点的增强值（假设它们是正确的）来重新计算 $p.min\\_odd$。\n\n我们定义一个辅助函数 $\\text{IsOdd}(k)$，如果 $k \\equiv 1 \\pmod{2}$ 则返回 true，否则返回 false。\n\n$\\text{UpdateMinOdd}(p)$:\n1.  初始化一个候选最小值 $m$。如果 $\\text{IsOdd}(p.key)$ 为真，则 $m = p.key$，否则 $m = \\infty$。\n2.  如果 $p.left \\neq \\text{null}$，则设置 $m = \\min(m, p.left.min\\_odd)$。\n3.  如果 $p.right \\neq \\text{null}$，则设置 $m = \\min(m, p.right.min\\_odd)$。\n4.  设置 $p.min\\_odd = m$。\n\n每次更新一个节点耗时 $O(1)$。\n\n**插入**\n\n要插入一个键 $k$，我们遵循标准的递归 BST 插入过程。\n1.  从根开始遍历树，找到新键 $k$ 的适当叶子位置。此路径的长度最多为 $h$。\n2.  为 $k$ 创建一个新节点。对于这个新的叶子节点 $p_{new}$，其增强值初始化为：如果 $\\text{IsOdd}(k)$ 为真，则 $p_{new}.min\\_odd = k$，否则 $p_{new}.min\\_odd = \\infty$。\n3.  随着递归的回溯（或我们沿插入路径向上回溯），我们对从新叶子到根的路径上的每个祖先 $p$ 调用 $\\text{UpdateMinOdd}(p)$。\n\n由于插入路径的长度为 $O(h)$，每次更新耗时 $O(1)$，因此一次插入（包括维护增强信息）的总时间为 $O(h)$。\n\n**删除**\n\n删除操作也以递归方式执行。我们找到要删除的节点并处理三种情况。增强信息在从修改点回溯的路径上进行更新。\n\n我们考虑从以节点 $p$ 为根的子树中删除键 $k$。\n1.  如果 $p$ 为空，我们不执行任何操作。\n2.  如果 $k  p.key$，我们在左子节点上递归调用删除：$p.left = \\text{Delete}(p.left, k)$。\n3.  如果 $k > p.key$，我们在右子节点上递归调用删除：$p.right = \\text{Delete}(p.right, k)$。\n4.  如果 $k = p.key$，我们找到了要删除的节点。\n    *   **情况 A（叶子节点）：** 如果 $p$ 没有子节点，我们只需向其父节点返回 null 来移除它。\n    *   **情况 B（一个子节点）：** 如果 $p$ 有一个子节点，我们向父节点返回该子节点，从而有效地将 $p$ 从树中剪接出去。\n    *   **情况 C（两个子节点）：** 如果 $p$ 有两个子节点，我们找到它的中序后继 $s$。中序后继是 $p$ 右子树中键最小的节点。我们将 $s$ 的键复制到 $p$（$p.key = s.key$）。然后，我们在右子树上递归调用删除，以移除原始的后继节点：$p.right = \\text{Delete}(p.right, s.key)$。注意，后继 $s$ 最多只能有一个（右）子节点，因此它的删除属于情况 A 或 B。\n5.  在步骤 2、3 或 4 中的递归调用返回后，如果当前节点 $p$ 未被删除，我们在返回 $p$ 之前调用 $\\text{UpdateMinOdd}(p)$。这确保了增强信息沿修改路径自底向上得到修正。\n\n在所有情况下，修改都发生在长度最多为 $O(h)$ 的路径上。在情况 C 中，受影响的总路径长度是到节点 $p$ 的路径加上从 $p$ 到其后继 $s$ 的路径。两条路径的长度都受限于树的高度 $h$。因此，删除的总时间仍为 $O(h)$。\n\n此设计满足了问题陈述的所有要求。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# According to the prompt, numpy is a permitted library.\n# It is imported but not strictly necessary for this specific solution.\n\nclass Node:\n    \"\"\"\n    A node in the augmented Binary Search Tree.\n    Each node stores its key, left/right children, and the minimum odd-valued key\n    in the subtree rooted at this node.\n    \"\"\"\n    def __init__(self, key, odd_sentinel):\n        self.key = key\n        self.left = None\n        self.right = None\n        # Augmented data: minimum odd key in the subtree rooted here.\n        self.min_odd = key if key % 2 == 1 else odd_sentinel\n\nclass AugmentedBST:\n    \"\"\"\n    An augmented Binary Search Tree that supports efficient finding of the\n    minimum odd-valued key.\n    \"\"\"\n    def __init__(self):\n        self.root = None\n        # Sentinel value for when no odd keys are in a subtree.\n        self.ODD_SENTINEL = float('inf')\n\n    def _is_odd(self, key):\n        \"\"\"\n        Checks if a key is odd according to the definition k === 1 (mod 2).\n        The python '%' operator behavior for negative numbers matches this.\n        e.g., -1 % 2 -> 1, -3 % 2 -> 1.\n        \"\"\"\n        return key % 2 == 1\n\n    def _update_min_odd(self, node):\n        \"\"\"\n        Recalculates the min_odd augmented value for a given node based on its\n        own key and the min_odd values of its children.\n        \"\"\"\n        if node is None:\n            return\n\n        min_val = node.key if self._is_odd(node.key) else self.ODD_SENTINEL\n\n        if node.left:\n            min_val = min(min_val, node.left.min_odd)\n\n        if node.right:\n            min_val = min(min_val, node.right.min_odd)\n\n        node.min_odd = min_val\n\n    def insert(self, key):\n        \"\"\"Public method to insert a key.\"\"\"\n        self.root = self._insert(self.root, key)\n\n    def _insert(self, node, key):\n        \"\"\"\n        Recursive helper for insertion. After insertion, it updates the\n        min_odd augmentation on the path back to the root.\n        \"\"\"\n        if node is None:\n            return Node(key, self.ODD_SENTINEL)\n\n        if key  node.key:\n            node.left = self._insert(node.left, key)\n        else: # key >= node.key, duplicates go to the right\n            node.right = self._insert(node.right, key)\n\n        # Update the augmented value on the way up the recursion\n        self._update_min_odd(node)\n        return node\n\n    def delete(self, key):\n        \"\"\"Public method to delete a key.\"\"\"\n        self.root = self._delete(self.root, key)\n\n    def _get_min_node(self, node):\n        \"\"\"Helper to find the node with the minimum key in a subtree (in-order successor).\"\"\"\n        current = node\n        while current and current.left is not None:\n            current = current.left\n        return current\n\n    def _delete(self, node, key):\n        \"\"\"\n        Recursive helper for deletion. After deletion, it updates the\n        min_odd augmentation on all affected nodes.\n        \"\"\"\n        if node is None:\n            return None\n\n        # Find the node to delete\n        if key  node.key:\n            node.left = self._delete(node.left, key)\n        elif key > node.key:\n            node.right = self._delete(node.right, key)\n        else: # key == node.key, node found\n            # Case 1: Node is a leaf or has one child\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n\n            # Case 2: Node has two children\n            # Replace with in-order successor\n            successor = self._get_min_node(node.right)\n            node.key = successor.key\n            # Delete the successor from the right subtree\n            node.right = self._delete(node.right, successor.key)\n\n        # Update the augmented value on the way up, if the node still exists\n        self._update_min_odd(node)\n        return node\n\n    def get_min_odd(self):\n        \"\"\"\n        Returns the minimum odd key in the tree.\n        This is an O(1) operation due to the augmentation.\n        \"\"\"\n        if self.root is None or self.root.min_odd == self.ODD_SENTINEL:\n            return -1\n        return int(self.root.min_odd)\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and produce the final output.\n    \"\"\"\n    test_cases = [\n        # Case 1: Typical tree with both odd and even keys\n        {'insert': [8, 3, 10, 1, 6, 14, 4, 7, 13], 'delete': []},\n        # Case 2: Edge case with no odd keys\n        {'insert': [2, 4, 6, 8], 'delete': []},\n        # Case 3: Duplicates and repeated deletions\n        {'insert': [5, 3, 7, 3, 5, 9], 'delete': [3, 3]},\n        # Case 4: Negative integers and zero\n        {'insert': [0, -1, -2, -3, -4], 'delete': []},\n        # Case 5: Deletion of a node with two children and removal of smaller odd keys\n        {'insert': [10, 5, 15, 3, 7, 12, 18], 'delete': [5, 3, 7]},\n    ]\n    \n    results = []\n    \n    for case in test_cases:\n        bst = AugmentedBST()\n        for key in case['insert']:\n            bst.insert(key)\n        \n        for key in case['delete']:\n            bst.delete(key)\n            \n        results.append(bst.get_min_odd())\n        \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3233444"}, {"introduction": "最后，我们将把增强技术推广，构建一个功能强大的“顺序统计树”（order-statistic tree）。通过在每个节点中存储其子树的大小，你将能够高效地回答各种基于排名的查询，例如找到第 $k$ 小的元素或确定一个给定元素的排名。这个练习展示了如何通过一个简单的增强，为BST解锁一整类强大的新操作，将数据检索能力提升到新的水平。[@problem_id:3233472]", "problem": "你需要设计并实现一个增强的二叉搜索树（BST）数据结构，以支持基于顺序的查询。从二叉搜索树（BST）的核心定义开始：对于任何键为 $x$ 的节点，其左子树中的所有键都严格小于 $x$，其右子树中的所有键都严格大于 $x$。BST 的中序遍历会以严格递增的顺序访问所有键。你的任务是用其子树的大小来增强每个节点，并利用这个信息来高效地计算极值和基于顺序的查询。\n\n在存储于 BST 中的一组不同整数键中，实值查询键 $k$ 的广义第 $m$ 个后继定义如下。设 $r(k)$ 为树中小于或等于 $k$ 的键的数量。设 $n$ 为树中键的总数。当排名从 1 开始计数时，$k$ 的广义第 $m$ 个后继是中序排名为 $r(k)+m$ 的键。如果 $r(k)+m$ 不在区间 $[1,n]$ 内，则广义第 $m$ 个后继不存在。此定义允许 $k$ 不在树中，也允许 $m$ 为零。特别地，当 $m=1$ 且 $k$ 存在于树中时，这与常规的后继一致；当 $m=0$ 时，如果存在，它返回小于或等于 $k$ 的最大键。\n\n实现一个程序，该程序：\n- 从一个给定的、包含不同整数键的有限列表中构建一个 BST。根据假设，键是唯一的；如果插入操作试图添加重复的键，必须忽略该操作，且不改变树的结构。\n- 用其子树的大小来增强每个节点，其大小定义为 $1+\\text{size(left)}+\\text{size(right)}$，其中空子树的大小为 $0$。\n- 支持两种时间复杂度与树高成正比的操作：\n  - $r(k)$：返回小于或等于 $k$ 的键的数量。\n  - $\\text{select}(t)$：返回中序排名为 $t$ 的键（$t$ 从 1 开始）。\n- 当目标排名在 $[1,n]$ 内时，将 $k$ 的广义第 $m$ 个后继计算为 $\\text{select}(r(k)+m)$，否则报告一个哨兵值。\n\n顺序关系和域假设：\n- 所有键都是在半开区间 $[0,10^9)$ 内的整数。\n- 严格全序是标准的整数小于关系 ``。\n- 查询可以使用任何整数 $k$（不一定在 $[0,10^9)$ 内）；$m$ 是一个非负整数。\n- 如果广义第 $m$ 个后继不存在，则输出哨兵整数 $-1$。\n\n测试套件和要求的输出格式：\n- 对于以下每个参数集，从提供的键列表中构建 BST（如果存在重复则忽略），然后使用上述定义计算给定 $(k,m)$ 的广义第 $m$ 个后继。程序必须汇总所有测试用例的结果，并打印一个单行，该行是一个用方括号括起来的逗号分隔列表，例如 $[x_1,x_2,\\dots,x_T]$，其中每个 $x_i$ 是测试用例 $i$ 的整数答案。\n\n使用以下测试套件：\n- 情况 1：键 $[20,10,30,5,15,25,35]$，查询 $(k=10,m=1)$。\n- 情况 2：键 $[20,10,30,5,15,25,35]$，查询 $(k=10,m=0)$。\n- 情况 3：键 $[20,10,30,5,15,25,35]$，查询 $(k=10,m=3)$。\n- 情况 4：键 $[20,10,30,5,15,25,35]$，查询 $(k=34,m=1)$。\n- 情况 5：键 $[20,10,30,5,15,25,35]$，查询 $(k=35,m=1)$。\n- 情况 6：键 $[20,10,30,5,15,25,35]$，查询 $(k=-100,m=1)$。\n- 情况 7：键 $[1,2,3,4]$，查询 $(k=2,m=2)$。\n- 情况 8：键 $[1,2,3,4]$，查询 $(k=2,m=10)$。\n- 情况 9：键 $[1,2,3,4]$，查询 $(k=100,m=0)$。\n- 情况 10：键 $[]$（空树），查询 $(k=5,m=1)$。\n\n你的程序应该生成一个单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，例如 $[x_1,x_2,\\dots,x_{10}]$，其中每个 $x_i$ 是情况 $i$ 的整数结果。", "solution": "该问题要求设计并实现一个增强的二叉搜索树（BST），以高效地回答基于顺序的查询。核心任务是计算键 $k$ 的广义第 $m$ 个后继，它被定义为中序排名为 $r(k)+m$ 的键，其中 $r(k)$ 是树中小于或等于 $k$ 的键的数量。\n\n该解决方案基于顺序统计树，这是一种 BST，其中每个节点都用以其为根的子树的大小进行了增强。这种增强使得可以高效地计算基于排名的查询。\n\n**1. 数据结构：增强的 BST 节点**\n\n我们为 BST 定义一个 `Node`。除了标准的 `key`、`left` 子指针和 `right` 子指针外，每个节点还将存储一个 `size` 属性。一个节点的 `size` 被定义为以该节点为根的子树中节点的总数（包括该节点本身）。\n$$\n\\text{node.size} = 1 + \\text{size}(\\text{node.left}) + \\text{size}(\\text{node.right})\n$$\n其中 `size(null node)` 定义为 $0$。一个新插入的叶节点的大小为 $1$。\n\n**2. 核心操作**\n\n该功能建立在三个主要操作之上：`insert`、`r`（排名）和 `select`。所有这些操作都被设计为具有与树的高度成正比的时间复杂度，即 $O(h)$。对于平衡树，这是 $O(\\log n)$；对于退化的树，这是 $O(n)$，其中 $n$ 是键的数量。\n\n**2.1. 插入 (`insert(key)`)**\n\n`insert` 操作遵循标准的 BST 插入逻辑，为新键找到正确的位置。\n- 如果树为空，新键成为根节点，其 `size` 初始化为 $1$。\n- 我们从根节点开始遍历树，将要插入的键与当前节点的键进行比较。如果新键较小，我们向左走；如果较大，我们向右走。\n- 如果找到具有相同键的节点，则根据问题规范，中止插入以避免重复。\n- 在遍历树以寻找插入点时，我们必须更新路径上每个节点的 `size` 属性。在插入新节点的递归调用返回后，父节点的 `size` 会被重新计算。这确保了从新叶节点到根节点的每个节点的 `size` 都被正确地增加了 1。\n\n**2.2. 排名查询 (`r(k)`)**\n\n函数 $r(k)$ 计算树中小于或等于 $k$ 的键的数量。这等同于找到小于或等于 $k$ 的最大键的中序排名。\n该算法从根节点开始遍历树：\n- 设当前节点为 $x$。\n- 如果 $k  x.\\text{key}$：所有小于或等于 $k$ 的键必定在 $x$ 的左子树中。我们在 $x.\\text{left}$ 中递归搜索。\n- 如果 $k > x.\\text{key}$：$x$ 的左子树中的所有键，加上 $x$ 本身，都小于或等于 $k$。树的这一部分的计数是 $\\text{size}(x.\\text{left}) + 1$。我们将此值加到在右子树 $x.\\text{right}$ 中递归搜索的结果上。\n- 如果 $k = x.\\text{key}$：$x$ 的左子树中的所有键，加上 $x$ 本身，都小于或等于 $k$。计数为 $\\text{size}(x.\\text{left}) + 1$。搜索终止。\n- 如果我们到达一个空指针，计数为 $0$。\n\n**2.3. 选择查询 (`select(t)`)**\n\n函数 $\\text{select}(t)$ 找到给定中序排名为 $t$ 的键，其中排名是从 1 开始索引的。\n该算法利用 `size` 属性来导航树：\n- 设当前节点为 $x$。设其左子树的大小为 $s_L = \\text{size}(x.\\text{left})$。\n- 键 $x.\\text{key}$ 本身的排名是 $s_L + 1$。\n- 如果 $t = s_L + 1$：当前节点 $x$ 就是目标。我们返回 $x.\\text{key}$。\n- 如果 $t  s_L + 1$：目标键在左子树中。我们在 $x.\\text{left}$ 中递归搜索排名为 $t$ 的键。\n- 如果 $t > s_L + 1$：目标键在右子树中。我们已经跳过了左子树和根节点中的 $s_L + 1$ 个键。因此，我们必须在右子树 $x.\\text{right}$ 中寻找排名为 $t - (s_L + 1)$ 的键。\n\n**3. 计算广义第 m 个后继**\n\n有了 `r` 和 `select` 函数，计算查询键 $k$ 的广义第 $m$ 个后继就变得很简单了。设 $n$ 为树中键的总数，这正是根节点的大小。\n1. 计算 $k$ 的排名：$\\text{rank}_k = r(k)$。\n2. 计算目标排名：$\\text{target\\_rank} = \\text{rank}_k + m$。\n3. 检查目标排名是否有效。一个排名 $t$ 是有效的，当且仅当 $1 \\le t \\le n$。\n4. 如果 $1 \\le \\text{target\\_rank} \\le n$，结果是 $\\text{select}(\\text{target\\_rank})$。\n5. 否则，广义后继不存在，我们返回哨兵值 $-1$。这处理了树为空（$n=0$）或目标排名超出有效范围的情况。\n\n此设计满足了问题的所有要求，以所需的时间复杂度为每个操作提供了指定的功能。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass Node:\n    \"\"\"\n    A node in an augmented Binary Search Tree.\n    Each node stores its key, pointers to left and right children,\n    and the size of the subtree rooted at this node.\n    \"\"\"\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n        self.size = 1\n\nclass AugmentedBST:\n    \"\"\"\n    An augmented Binary Search Tree that supports order-statistic queries.\n    \"\"\"\n    def __init__(self):\n        self.root = None\n\n    def _get_size(self, node):\n        \"\"\"Helper to get size of a node's subtree, returns 0 if node is None.\"\"\"\n        return node.size if node else 0\n\n    def insert(self, key):\n        \"\"\"Inserts a key into the BST, ignoring duplicates.\"\"\"\n        self.root = self._insert_recursive(self.root, key)\n\n    def _insert_recursive(self, node, key):\n        \"\"\"Recursively inserts a key and updates subtree sizes.\"\"\"\n        if not node:\n            return Node(key)\n        \n        if key  node.key:\n            node.left = self._insert_recursive(node.left, key)\n        elif key > node.key:\n            node.right = self._insert_recursive(node.right, key)\n        else: # Key already exists, do nothing.\n            return node\n            \n        # Update the size of the current node\n        node.size = 1 + self._get_size(node.left) + self._get_size(node.right)\n        return node\n\n    def r(self, k):\n        \"\"\"Returns the number of keys in the tree less than or equal to k.\"\"\"\n        return self._r_recursive(self.root, k)\n\n    def _r_recursive(self, node, k):\n        \"\"\"Recursive helper for rank query.\"\"\"\n        if not node:\n            return 0\n        \n        if k  node.key:\n            return self._r_recursive(node.left, k)\n        elif k > node.key:\n            return self._get_size(node.left) + 1 + self._r_recursive(node.right, k)\n        else: # k == node.key\n            return self._get_size(node.left) + 1\n\n    def select(self, t):\n        \"\"\"Returns the key with the t-th in-order rank (1-indexed).\"\"\"\n        if not self.root or not (1 = t = self.root.size):\n            return None # Or raise an error, indicates invalid rank\n        return self._select_recursive(self.root, t)\n\n    def _select_recursive(self, node, t):\n        \"\"\"Recursive helper for select query.\"\"\"\n        if not node:\n            # This case should not be reached if initial rank is valid.\n            return None\n\n        left_size = self._get_size(node.left)\n        current_rank = left_size + 1\n        \n        if t == current_rank:\n            return node.key\n        elif t  current_rank:\n            return self._select_recursive(node.left, t)\n        else: # t > current_rank\n            return self._select_recursive(node.right, t - current_rank)\n\n    def generalized_successor(self, k, m):\n        \"\"\"\n        Computes the generalized m-th successor of k.\n        \"\"\"\n        n = self._get_size(self.root)\n        if n == 0:\n            return -1\n            \n        rank_k = self.r(k)\n        target_rank = rank_k + m\n        \n        if 1 = target_rank = n:\n            return self.select(target_rank)\n        else:\n            return -1\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and print the results.\n    \"\"\"\n    test_cases = [\n        ({'keys': [20, 10, 30, 5, 15, 25, 35], 'query': (10, 1)}),\n        ({'keys': [20, 10, 30, 5, 15, 25, 35], 'query': (10, 0)}),\n        ({'keys': [20, 10, 30, 5, 15, 25, 35], 'query': (10, 3)}),\n        ({'keys': [20, 10, 30, 5, 15, 25, 35], 'query': (34, 1)}),\n        ({'keys': [20, 10, 30, 5, 15, 25, 35], 'query': (35, 1)}),\n        ({'keys': [20, 10, 30, 5, 15, 25, 35], 'query': (-100, 1)}),\n        ({'keys': [1, 2, 3, 4], 'query': (2, 2)}),\n        ({'keys': [1, 2, 3, 4], 'query': (2, 10)}),\n        ({'keys': [1, 2, 3, 4], 'query': (100, 0)}),\n        ({'keys': [], 'query': (5, 1)}),\n    ]\n\n    results = []\n    for case in test_cases:\n        keys = case['keys']\n        k, m = case['query']\n        \n        bst = AugmentedBST()\n        for key in keys:\n            bst.insert(key)\n        \n        result = bst.generalized_successor(k, m)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3233472"}]}