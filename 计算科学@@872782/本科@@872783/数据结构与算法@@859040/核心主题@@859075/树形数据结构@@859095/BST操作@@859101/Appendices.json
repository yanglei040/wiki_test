{"hands_on_practices": [{"introduction": "标准的二叉搜索树（BST）要求键值是唯一的，但这在现实世界的数据中并不总是成立。本练习将引导你解决一个常见的实际问题：如何存储具有重复键值的项。你将学习通过构建一个复合键来维护BST严格的排序不变性，这是一项扩展数据结构基本功能的关键技术。[@problem_id:3219123]", "problem": "你需要实现一个二叉搜索树（BST），用于存储由一个整数键和一个卫星数据引用（一个对象）组成的记录。二叉搜索树（BST）由以下不变量定义：对于每个键为 $k$ 的节点，其左子树中的所有键在严格全序下都严格小于 $k$，其右子树中的所有键都严格大于 $k$。由于此任务需要处理重复的整数键，你必须将比较提升为对复合键 $(k,i)$ 的严格全序，其中 $k$ 是整数键，$i$ 是与有效载荷对象关联的唯一身份标签。在 $(k,i)$ 上的严格全序是字典序：$(k_1,i_1)  (k_2,i_2)$ 当且仅当 $k_1  k_2$ 或者 ($k_1 = k_2$ 且 $i_1  i_2$)。这确保了相等的整数键通过其有效载荷的身份标签进行确定性排序。\n\n你的设计基础必须是上述核心BST不变量、键上存在严格全序，以及中序遍历的正确性，即中序遍历在该严格全序下以非递减顺序产生键。使用这些基础来推导维护该不变量的插入、搜索和删除操作。特别地，删除操作必须能够移除整数键相等的多个实例中的特定一个。目标由整数键 $k$ 和卫星数据引用 $p$ 共同指定；引用相等必须是基于指针身份（即，是同一个对象，而不仅仅是内容相等）。你的实现必须保证，在删除 $(k,p)$ 时，其有效载荷为同一对象 $p$ 的那个精确节点被移除，并且结果树继续遵守基于 $(k,i)$ 字典序的BST不变量。\n\n你必须实现：\n- 一个插入操作，通过比较复合键 $(k,i)$ 来放置节点，其中 $i$ 是有效载荷对象的身份标签。\n- 一个按键搜索操作，返回所有整数键等于查询值 $k$ 的有效载荷身份标签 $i$，通过中序遍历排序，使其 $i$ 值按升序排列。\n- 一个按键和引用删除操作，精确移除整数键等于 $k$ 且其有效载荷对象与提供的对象 $p$ 指针相同的节点。对于有两个子节点的节点，使用从BST不变量推导出的标准中序后继替换方法：用其右子树在严格全序下的最小值替换该节点的内容，然后在其原始位置删除该后继节点。对于只有一个子节点或叶节点的节点，进行适当的拼接。\n\n你的程序必须运行以下测试套件。在所有情况下，有效载荷身份标签 $i$ 是你为每个创建的有效载荷对象确定性分配并随对象保留的整数。对于每个测试用例，按顺序执行插入，然后执行删除 $(k,p)$，接着搜索给定的键 $s$。输出必须在删除完成后计算。\n\n测试套件：\n- 测试 1：插入 $(5,10)$、$(3,20)$、$(7,30)$、$(3,21)$、$(5,11)$、$(7,31)$。删除实例 $(5,p)$，其中 $p$ 是身份标签为 $11$ 的有效载荷对象。然后搜索 $s=5$。\n- 测试 2：插入 $(4,40)$、$(2,50)$、$(6,60)$、$(6,61)$。删除实例 $(6,p)$，其中 $p$ 的身份标签为 $61$。然后搜索 $s=6$。\n- 测试 3：插入 $(8,80)$、$(8,81)$、$(9,90)$。删除实例 $(8,p)$，其中 $p$ 的身份标签为 $80$。然后搜索 $s=8$。\n- 测试 4：插入 $(6,100)$、$(4,101)$、$(7,102)$、$(5,103)$、$(3,104)$、$(6,105)$。删除实例 $(6,p)$，其中 $p$ 的身份标签为 $100$。然后搜索 $s=6$。\n- 测试 5：不插入任何内容。尝试删除 $(1,p)$，其中 $p$ 的身份标签为 $200$。然后搜索 $s=1$。\n- 测试 6：插入 $(10,300)$、$(10,301)$。尝试删除 $(10,p)$，其中 $p$ 的身份标签为 $302$（该标签在树中不存在）。然后搜索 $s=10$。\n\n对于每个测试用例，你的程序必须输出一个四元素列表：\n- 删除后的整数键的中序列表（每个元素是 $k$）。\n- 删除后的有效载荷身份标签的中序列表（每个元素是 $i$）。\n- 给定 $s$ 的搜索结果的整数计数。\n- 一个布尔值，指示删除是否成功。\n\n最终输出格式要求：\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例贡献一个如上所述的四元素列表，例如 $[[\\dots],[\\dots],\\dots,\\text{True}]$。打印的行中不能有空格。输出必须仅为基本类型：布尔值、整数或这些类型的列表。不涉及物理单位或角度，因此无需指定。", "solution": "该问题要求实现一个能够存储可能具有重复整数键的记录的二叉搜索树（BST）。BST数据结构的正确性建立在其键上存在严格全序的基础之上。为满足这一点，引入了复合键和相应的字典序。任务是推导并实现 `insert`、`search` 和 `delete` 操作，以在此排序规则下维护BST不变量，并根据指定的测试套件验证实现。\n\n### 严格全序原则\n\n二叉搜索树由以下不变量定义：对于任何键为 $k_n$ 的节点 $n$，其左子树中的所有键都严格小于 $k_n$，其右子树中的所有键都严格大于 $k_n$。这要求在键集上存在一个严格全序关系，用 $$ 表示。如果键不是唯一的（例如，允许重复的整数键），则整数上的标准比较不构成严格全序，因为对于两个具有相同键 $k$ 的不同项，两者都不是严格小于对方。\n\n为了解决这个问题，题目指定了一个复合键 $(k, i)$，其中 $k$ 是整数键，$i$ 是与有效载荷关联的唯一身份标签。通过字典序比较建立严格全序：\n$$(k_1, i_1)  (k_2, i_2) \\iff (k_1  k_2) \\lor (k_1 = k_2 \\land i_1  i_2)$$\n鉴于每个有效载荷对象的身份标签 $i$ 是唯一的，这个复合键 $(k, i)$ 保证在树中的每个节点都是唯一的。这种构造使得BST不变量能够明确地得到维护。\n\n### 数据结构设计\n\n为了高效地实现所需的操作，特别是删除操作，我们定义了一个包含指向其父节点指针的 `Node` 结构。\n\n- **`Payload` 类**：一个用于持有唯一身份标签的简单对象。\n- **`Node` 类**：包含整数键 $k$、对 `Payload` 对象 $p$ 的引用，以及指向其 `left`、`right` 和 `parent` 节点的指针。用于比较的复合键是 `(node.key, node.payload.identity_tag)`。\n\n### 核心操作\n\n#### 插入操作\n\n`insert(k, p)` 操作添加一个带有整数键 $k$ 和有效载荷 $p$ 的新节点。该算法遵循BST不变量：\n1.  创建一个包含 $(k, p)$ 及其关联复合键 $(k, i)$ 的新 `Node`，其中 $i=p.\\text{identity\\_tag}$。\n2.  从树的根节点开始，向下遍历以找到插入点。在每个节点 `current` 处，将新节点的复合键 $(k, i)$ 与 `current` 的复合键进行比较。\n3.  如果 $(k, i)$ 小于 `current` 的键，则前进到左子节点。\n4.  如果 $(k, i)$ 大于 `current` 的键，则前进到右子节点。\n5.  此过程一直持续到遇到一个 `None`（空）子指针。新节点在此位置插入，其父指针设置为遍历的最后一个节点。\n\n#### 搜索操作\n\n`search(s)` 操作必须返回所有整数键为 $s$ 的有效载荷的身份标签。这些标签必须按升序排列。\n1.  对于给定的键 $k$，其标签的排序是字典序比较和树的中序遍历的自然结果。\n2.  可以通过递归、剪枝的中序遍历来实现高效搜索。设函数为 `_in_order_search(node, s)`。\n3.  如果 `node` 是 `None`，则终止递归。\n4.  如果搜索键 $s$ 小于 `node.key`，根据BST不变量，任何匹配的节点只能存在于左子树中。在 `node.left` 上递归。\n5.  如果 $s$ 大于 `node.key`，任何匹配的节点只能存在于右子树中。在 `node.right` 上递归。\n6.  如果 $s$ 等于 `node.key`，则匹配项可能存在于左右子树中（具有不同的身份标签）。因此，我们必须：\n    a. 在 `node.left` 上递归。\n    b. 记录当前节点的有效载荷身份标签。\n    c. 在 `node.right` 上递归。\n此过程仅探索树的相关部分，并以正确的排序顺序收集标签。\n\n#### 删除操作\n\n`delete(k, p)` 操作必须移除与整数键 $k$ 和指针相同的有效载荷对象 $p$ 都匹配的特定节点。\n\n1.  **查找节点**：首先，必须定位目标节点。这通过从根节点遍历树来实现，使用复合键 $(k, i)$（其中 $i=p.\\text{identity\\_tag}$）来引导搜索。如果找到节点，我们还需验证指针身份（`node.payload is p`）以确保正确性，尽管如果实现正确，唯一的复合键使得此步骤是多余的。如果搜索路径在 `None` 处结束，则节点不存在，删除失败。\n\n2.  **节点移除**：一旦找到目标节点（我们称之为 $z$），其移除方式取决于其子节点的数量。一个辅助函数 `_transplant(u, v)`，用节点 $v$ 处的子树替换节点 $u$ 处的子树，可以简化逻辑。\n\n    -   **情况 1：$z$ 没有左子节点。** 节点 $z$ 被其右子节点替换。这涵盖了叶节点（右子节点为 `None`）和只有右子节点的节点。我们调用 `_transplant(z, z.right)`。\n\n    -   **情况 2：$z$ 有左子节点但没有右子节点。** 节点 $z$ 被其左子节点替换。我们调用 `_transplant(z, z.left)`。\n\n    -   **情况 3：$z$ 有两个子节点。** 这是最复杂的情况。BST不变量要求用一个能保持顺序的键的节点来替换 $z$。标准算法使用 $z$ 的中序后继，即 $z$ 右子树中键最小的节点。设该后继为 $y$。\n        a.  将 $y$ 的内容（键和有效载荷）复制到 $z$ 中。\n        b.  问题现在简化为删除原始节点 $y$。根据子树中最小值的定义，$y$ 没有左子节点。因此，其删除属于情况1或2，这是一个可以通过递归或迭代解决的更简单的问题。\n        c.  一种更直接的实现（我们遵循的源自CLRS的实现）不复制数据，而是重新链接指针：\n            i.  如果后继 $y$ 不是 $z$ 的右子节点，首先用 $y$ 自己的右子节点替换 $y$，然后让 $y$ 接管 $z$ 的右子树。\n            ii. 用 $y$ 替换 $z$。\n            iii. 让 $y$ 接管 $z$ 的左子树。\n\n这种系统的、基于原则的方法确保了所有操作都维护BST不变量，从而保证了数据结构的正确性。", "answer": "```python\nimport numpy as np\n\nclass Payload:\n    \"\"\"A simple payload class to hold a unique identity tag.\"\"\"\n    def __init__(self, identity_tag):\n        self.identity_tag = identity_tag\n    \n    def __repr__(self):\n        return f\"Payload({self.identity_tag})\"\n\nclass Node:\n    \"\"\"A node in the Binary Search Tree.\"\"\"\n    def __init__(self, key, payload):\n        self.key = key\n        self.payload = payload\n        self.left = None\n        self.right = None\n        self.parent = None\n    \n    @property\n    def composite_key(self):\n        return (self.key, self.payload.identity_tag)\n\n    def __repr__(self):\n        return f\"Node(k={self.key}, i={self.payload.identity_tag})\"\n\nclass BST:\n    \"\"\"\n    Binary Search Tree implementation handling duplicate integer keys\n    via a composite key (k, i) and lexicographic ordering.\n    \"\"\"\n    def __init__(self):\n        self.root = None\n\n    def insert(self, key, payload):\n        \"\"\"Inserts a new node with the given key and payload.\"\"\"\n        new_node = Node(key, payload)\n        y = None\n        x = self.root\n        \n        while x is not None:\n            y = x\n            if new_node.composite_key  x.composite_key:\n                x = x.left\n            else:\n                x = x.right\n        \n        new_node.parent = y\n        if y is None:\n            self.root = new_node\n        elif new_node.composite_key  y.composite_key:\n            y.left = new_node\n        else:\n            y.right = new_node\n\n    def search(self, key_to_find):\n        \"\"\"\n        Returns a list of identity tags for all nodes with the given integer key.\n        The results are sorted by identity tag due to in-order traversal.\n        \"\"\"\n        results = []\n        self._in_order_search(self.root, key_to_find, results)\n        return results\n\n    def _in_order_search(self, node, key_to_find, results):\n        if node is None:\n            return\n        \n        if key_to_find  node.key:\n            self._in_order_search(node.left, key_to_find, results)\n        elif key_to_find > node.key:\n            self._in_order_search(node.right, key_to_find, results)\n        else: # key_to_find == node.key\n            self._in_order_search(node.left, key_to_find, results)\n            results.append(node.payload.identity_tag)\n            self._in_order_search(node.right, key_to_find, results)\n\n    def _find_node(self, key, payload):\n        \"\"\"Finds a specific node by its composite key and payload identity.\"\"\"\n        node = self.root\n        target_composite_key = (key, payload.identity_tag)\n        while node is not None and target_composite_key != node.composite_key:\n            if target_composite_key  node.composite_key:\n                node = node.left\n            else:\n                node = node.right\n        \n        # Additionally verify pointer identity\n        if node and node.payload is payload:\n            return node\n        return None\n\n    def delete(self, key, payload):\n        \"\"\"Deletes the specific node identified by key and payload object.\"\"\"\n        node_to_delete = self._find_node(key, payload)\n        if node_to_delete is None:\n            return False\n        \n        self._delete_node(node_to_delete)\n        return True\n\n    def _transplant(self, u, v):\n        \"\"\"Replaces subtree rooted at u with subtree rooted at v.\"\"\"\n        if u.parent is None:\n            self.root = v\n        elif u == u.parent.left:\n            u.parent.left = v\n        else:\n            u.parent.right = v\n        if v is not None:\n            v.parent = u.parent\n\n    def _find_min(self, node):\n        \"\"\"Finds the node with the minimum key in a subtree.\"\"\"\n        while node.left is not None:\n            node = node.left\n        return node\n\n    def _delete_node(self, z):\n        \"\"\"Helper function to perform the deletion of node z.\"\"\"\n        if z.left is None:\n            self._transplant(z, z.right)\n        elif z.right is None:\n            self._transplant(z, z.left)\n        else:\n            y = self._find_min(z.right)\n            if y.parent != z:\n                self._transplant(y, y.right)\n                y.right = z.right\n                y.right.parent = y\n            \n            self._transplant(z, y)\n            y.left = z.left\n            y.left.parent = y\n\n    def get_in_order_traversal(self):\n        \"\"\"Returns two lists: keys and tags from an in-order traversal.\"\"\"\n        keys = []\n        tags = []\n        self._in_order_collect(self.root, keys, tags)\n        return keys, tags\n    \n    def _in_order_collect(self, node, keys, tags):\n        if node is not None:\n            self._in_order_collect(node.left, keys, tags)\n            keys.append(node.key)\n            tags.append(node.payload.identity_tag)\n            self._in_order_collect(node.right, keys, tags)\n\ndef solve():\n    test_cases = [\n        {\n            \"inserts\": [(5, 10), (3, 20), (7, 30), (3, 21), (5, 11), (7, 31)],\n            \"delete\": (5, 11),\n            \"search\": 5\n        },\n        {\n            \"inserts\": [(4, 40), (2, 50), (6, 60), (6, 61)],\n            \"delete\": (6, 61),\n            \"search\": 6\n        },\n        {\n            \"inserts\": [(8, 80), (8, 81), (9, 90)],\n            \"delete\": (8, 80),\n            \"search\": 8\n        },\n        {\n            \"inserts\": [(6, 100), (4, 101), (7, 102), (5, 103), (3, 104), (6, 105)],\n            \"delete\": (6, 100),\n            \"search\": 6\n        },\n        {\n            \"inserts\": [],\n            \"delete\": (1, 200),\n            \"search\": 1\n        },\n        {\n            \"inserts\": [(10, 300), (10, 301)],\n            \"delete\": (10, 302),\n            \"search\": 10\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        bst = BST()\n        payload_map = {}\n\n        # Perform insertions\n        for k, i in case[\"inserts\"]:\n            p = Payload(i)\n            payload_map[i] = p\n            bst.insert(k, p)\n        \n        # Perform deletion\n        del_key, del_tag = case[\"delete\"]\n        payload_to_delete = payload_map.get(del_tag)\n        # If the payload wasn't inserted, we create a dummy for the delete attempt\n        if payload_to_delete is None:\n            payload_to_delete = Payload(del_tag)\n        \n        deletion_succeeded = bst.delete(del_key, payload_to_delete)\n        \n        # Get post-deletion state\n        in_order_keys, in_order_tags = bst.get_in_order_traversal()\n        \n        # Perform search\n        search_results = bst.search(case[\"search\"])\n        search_count = len(search_results)\n        \n        results.append([\n            in_order_keys,\n            in_order_tags,\n            search_count,\n            deletion_succeeded\n        ])\n\n    # Format the output as a single line JSON-like string with no spaces\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "3219123"}, {"introduction": "尽管递归为树形算法提供了简洁的表达方式，但它有一个实际的限制：调用栈深度。本练习将探讨一棵不平衡的BST如何导致栈溢出，并挑战你构建一个更健壮的混合实现。当树变得过深时，该实现会利用父指针回退到迭代方法，从而避免程序崩溃。[@problem_id:3219097]", "problem": "您必须编写一个完整、可运行的程序，该程序为一组给定的测试用例构建和操作一个二叉搜索树 (BST)，同时分析递归深度并使用迭代式回退方案。二叉搜索树 (BST) 是一种有根二叉树，其中对于任何键为 $k$ 的节点，其左子树中的每个键都严格小于 $k$，而其右子树中的每个键都严格大于 $k$。目标是实现 BST 上的搜索、插入和删除操作，分析递归深度在深层树中的影响，并使用父指针实现一个迭代式回退方案，以避免超出递归深度限制。\n\n基本基础：\n- 每次操作后，BST 的排序属性必须保持不变。\n- 递归算法在 BST 路径上的递归深度受其所遵循路径的长度限制。在最坏的情况下，如果 BST 退化成一条链，该路径长度将接近节点数 $n$。\n- 父指针允许进行迭代式遍历和更新，这些操作遵循与递归算法相同的路径，但不会消耗调用栈帧。\n\n程序要求：\n- 实现一个 BST，其中每个节点存储一个键以及指向其左子节点、右子节点和父节点的指针。\n- 为三个核心操作实现递归和迭代两种变体：搜索、插入和删除。\n- 将树 $T$ 的高度 $h(T)$ 定义为从根到叶的最长简单路径上的节点数。空树的高度为 $0$。\n- 使用以下决策规则以避免递归深度溢出：给定递归深度限制 $L$，如果估计的递归深度将为 $\\leq L$，则选择递归变体；否则选择迭代变体。使用 BST 的当前高度 $h$ 按如下方式估计递归深度：\n  - 对于搜索键 $x$：估计 $d \\leq h$。\n  - 对于删除键 $x$：估计 $d \\leq h$。\n  - 对于插入键 $x$：估计 $d \\leq h + 1$。\n- 在决策规则内部计算 $h$ 时，使用不依赖递归的迭代方法（例如，广度优先遍历）。\n- 插入操作忽略重复项。\n- 对于删除操作，实现标准的三种情况删除：\n  - 节点没有子节点：移除它。\n  - 节点有一个子节点：通过将其子节点连接到其父节点来将其拼接掉。\n  - 节点有两个子节点：将其键替换为其​​中序后继（右子树中的最小值）的键，然后删除该后继节点。当选择迭代变体时，使用父指针执行结构更新，无需使用递归堆栈。\n\n每个测试用例需要产生什么：\n- 使用上面带有给定 $L$ 的决策规则，通过插入给定初始序列中的所有键来构建初始 BST。\n- 按顺序应用列出的操作，同样根据每个操作的决策规则。\n- 对于每个测试用例，输出一个形式为 $[H, F, S, I]$ 的结果列表，其中：\n  - $H$ 是所有操作后 BST 的最终高度（如上定义），表示为一个整数。\n  - $F$ 是一个布尔值，指示在初始构建或操作期间是否至少使用过一次迭代回退方案（如果至少使用过一次则为 true，否则为 false）。\n  - $S$ 是一个布尔值，等于测试用例中执行的最后一次搜索操作的结果（如果找到搜索的键则为 true，否则为 false）。如果测试用例中没有发生搜索操作，则取 $S = \\text{false}$。\n  - $I$ 是 BST 的最终中序遍历，表示为一个整数列表。\n- 程序必须将所有测试用例的结果聚合成单行输出，格式为方括号括起来的逗号分隔列表，例如 $[r_1,r_2,r_3]$，其中每个 $r_i$ 本身就是一个列表 $[H,F,S,I]$。\n\n测试套件：\n- 测试用例 $1$（平衡插入，预计无回退）：\n  - $L = 100$\n  - 初始插入序列：$[8,4,12,2,6,10,14,1,3,5,7,9,11,13,15]$\n  - 操作：search $7$；delete $8$；insert $16$；delete $2$；search $100$\n- 测试用例 $2$（退化链，深度接近 $n$，预计有回退）：\n  - $L = 40$\n  - 初始插入序列：$[1,2,\\dots,60]$\n  - 操作：search $60$；insert $61$；delete $1$；delete $61$；search $30$\n- 测试用例 $3$（空树边界条件）：\n  - $L = 5$\n  - 初始插入序列：$[]$\n  - 操作：search $10$；delete $10$；insert $10$；search $10$；delete $10$\n- 测试用例 $4$（深度等于限制的边界情况，搜索预计无回退）：\n  - $L = 20$\n  - 初始插入序列：$[1,2,\\dots,20]$\n  - 操作：search $20$\n\n最终输出格式：\n- 您的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例的结果格式如上所述。例如：$[[H_1,F_1,S_1,I_1],[H_2,F_2,S_2,I_2],[H_3,F_3,S_3,I_3],[H_4,F_4,S_4,I_4]]$。", "solution": "用户希望我验证问题陈述，如果有效，则提供解决方案。\n\n### 问题验证\n\n**步骤 1：提取给定信息**\n\n- **数据结构：** 二叉搜索树 (BST)，其中每个节点存储一个键以及指向其左子节点、右子节点和父节点的指针。\n- **BST 属性：** 对于任何键为 $k$ 的节点，其左子树中的所有键都小于 $k$，右子树中的所有键都大于 $k$。\n- **操作：** 实现 `search`、`insert` 和 `delete` 操作。\n- **重复项处理：** 插入时忽略重复项。\n- **删除逻辑：**\n    1.  **无子节点：** 移除该节点。\n    2.  **一个子节点：** 通过将其子节点连接到其父节点来拼接掉该节点。\n    3.  **两个子节点：** 将其键替换为其​​中序后继的键，然后删除该后继节点。\n- **高度定义：** 树 $T$ 的高度 $h(T)$ 是从根到叶的最长简单路径上的节点数。空树的高度为 $0$。\n- **决策规则：** 给定一个递归深度限制 $L$。选择递归还是迭代变体取决于估计的递归深度 $d$，该深度使用当前树高 $h$ 计算。\n    - `search` 键 $x$：估计 $d \\leq h$。如果 $h \\leq L$ 则选择递归。\n    - `delete` 键 $x$：估计 $d \\leq h$。如果 $h \\leq L$ 则选择递归。\n    - `insert` 键 $x$：估计 $d \\leq h + 1$。如果 $h + 1 \\leq L$ 则选择递归。\n- **高度计算：** 决策规则中使用的高度 $h$ 必须迭代计算（例如，使用广度优先遍历）。\n- **父指针：** 必须用于实现迭代更新，特别是删除操作，以避免递归。\n- **输出格式：** 对于每个测试用例，生成一个列表 $[H, F, S, I]$，其中：\n    - $H$：BST 的最终高度。\n    - $F$：布尔值，如果迭代回退方案至少被使用过一次，则为 `true`。\n    - $S$：布尔值，最后一次搜索操作的结果（如果没有搜索，则为 `false`）。\n    - $I$：最终中序遍历的整数列表。\n- **测试用例：** 提供了四个特定的测试用例，包含 $L$ 的值、初始插入序列和后续操作。\n\n**步骤 2：使用提取的给定信息进行验证**\n\n1.  **科学依据：** 该问题牢固地植根于基本的计算机科学原理。二叉搜索树、其核心操作（搜索、插入、删除）、递归深度的概念、树的高度以及使用父指针进行迭代算法，都是数据结构和算法中的标准主题。指定的删除算法是规范的。该问题在科学和算法上是合理的。\n2.  **良构性 (Well-Posed)：** 该问题提供了一套清晰、确定性的指令。输入（测试用例）已完全指定，所需的输出格式明确无误。对于任何给定的输入，都可以推导出一系列唯一的操作和一个明确定义的最终状态。\n3.  **客观性：** 该问题以精确、技术性的语言陈述，没有主观性或歧义。“高度”、“中序后继”和决策规则等术语都得到了明确定义。\n4.  **完整性和一致性：** 该问题是自包含的。它提供了解决问题所需的所有定义、约束和数据。要求中没有明显的矛盾。\n5.  **非平凡性：** 该问题并非微不足道。它要求仔细实现一个具有状态节点（父指针）的复杂数据结构、多个操作的双重实现（递归和迭代），以及一个主导决策逻辑。特别是使用父指针的迭代删除，在概念上是一项具有挑战性的任务。\n\n**步骤 3：结论与行动**\n\n此问题是 **有效** 的。这是一个在数据结构和算法领域中定义明确、非平凡的问题，考验了基本概念和实现技巧。我将继续提供解决方案。\n\n### 解决方案设计\n\n该解决方案围绕一个 `BST` 类构建，该类封装了管理由 `Node` 对象组成的二叉搜索树的逻辑。每个操作（`search`、`insert`、`delete`）都通过一个公共方法实现，该方法应用指定的决策规则来在递归或迭代的私有辅助方法之间进行选择。\n\n**1. 节点结构**\n\n基本构建块是 `Node` 类。每个 `Node` 实例存储一个整数 `key` 和三个指针：`left`、`right` 和 `parent`。`parent` 指针对于树修改的迭代实现至关重要，因为它允许从一个节点向上遍历并修改其父节点的子指针，而无需递归堆栈。\n\n$$\n\\text{Node} = \\{ \\text{key} \\in \\mathbb{Z}, \\text{left} \\in \\{\\text{Node}, \\text{None}\\}, \\text{right} \\in \\{\\text{Node}, \\text{None}\\}, \\text{parent} \\in \\{\\text{Node}, \\text{None}\\} \\}\n$$\n\n**2. 迭代式高度计算**\n\n选择递归还是迭代方法的决策规则取决于当前的树高 $h$。为了防止高度计算本身在深层树中可能导致堆栈溢出，我们必须以迭代方式实现它。广度优先搜索（BFS）或层序遍历是自然的选择。该算法用根节点初始化一个队列。然后，它逐层处理树，每遍历一层就增加一个高度计数器。总层数对应于树的高度，定义为从根到叶的最长路径上的节点数。空树正确地得到高度 $0$。\n\n**3. 决策规则和回退机制**\n\n一个中心的 `BST` 类管理树的 `root`、递归限制 $L$ 和一个布尔标志 `fallback_used`。在执行 `search`、`insert` 或 `delete` 之前，计算当前高度 $h$。\n- 对于 `search` 和 `delete`，如果 $h \\le L$，则调用递归变体。否则，将 `fallback_used` 设置为 `true` 并执行迭代变体。\n- 对于 `insert`，估计深度为 $h+1$，因为新节点可能会增加树的高度。因此，如果 $h+1 \\le L$，则使用递归变体；否则，触发迭代回退。\n\n**4. 核心操作：双重实现**\n\n- **搜索 (Search)：** 递归和迭代搜索都是标准的。递归版本通过函数调用向下遍历树，而迭代版本使用 `while` 循环，更新一个指向当前节点的指针，直到找到键或到达 `None` 指针。\n\n- **插入 (Insert)：** 递归插入会遍历到正确的位置，并沿调用栈向上传递新创建的节点，允许父节点链接它。在递归下降过程中设置父指针。迭代插入首先向下遍历以找到合适的父节点，然后创建新节点并手动将其链接到父节点。\n\n- **删除 (Delete)：** 删除是最复杂的操作，尤其是迭代版本。\n    - **递归删除：** 此实现遵循标准的三种情况逻辑。当删除具有两个子节点的节点时，其键被其​​中序后继的键替换，然后进行递归调用以从右子树中删除后继节点。随着递归的回溯，父指针被仔细更新。\n    - **迭代删除：** 此实现对于深层树更为健壮，并且严重依赖父指针。一个辅助函数 `_transplant` 用于通过正确地重新连接父节点的子指针和子节点的父指针来替换一个子树。\n        - **0/1 个子节点的情况：** 要删除的节点简单地用其唯一的子节点（或 `None`）进行移植。\n        - **2 个子节点的情况：** 找到该节点的中序后继 $y$。如果 $y$ 不是要删除节点的直接右子节点，首先用 $y$ 自己的右子节点移植 $y$，以将其移出原始位置。然后，通过接管其子节点来准备用 $y$ 替换目标节点。最后，用准备好的后继 $y$ 移植目标节点。此过程无需递归即可精细地更新所有 `parent`、`left` 和 `right` 指针。\n\n通过遵循此设计，最终的程序正确地实现了指定的 BST 逻辑，遵守了递归深度约束，并为每个测试用例生成了所需的分析。", "answer": "```python\nimport numpy as np\n\nclass Node:\n    \"\"\"\n    Represents a node in the Binary Search Tree.\n    Each node stores a key, and pointers to its left, right, and parent nodes.\n    \"\"\"\n    def __init__(self, key, parent=None):\n        self.key = key\n        self.left = None\n        self.right = None\n        self.parent = parent\n\n    def __repr__(self):\n        return f\"Node({self.key})\"\n\nclass BST:\n    \"\"\"\n    Implements a Binary Search Tree with both recursive and iterative operations,\n    governed by a recursion depth limit.\n    \"\"\"\n    def __init__(self, L):\n        self.root = None\n        self.L = L\n        self.fallback_used = False\n\n    def get_height_iterative(self):\n        \"\"\"\n        Calculates the height of the tree iteratively using BFS.\n        Height is defined as the number of nodes on the longest root-to-leaf path.\n        An empty tree has height 0.\n        \"\"\"\n        if not self.root:\n            return 0\n        height = 0\n        q = [self.root]\n        while q:\n            height += 1\n            level_size = len(q)\n            for _ in range(level_size):\n                node = q.pop(0)\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n        return height\n\n    def search(self, key):\n        \"\"\"Public search method with decision logic.\"\"\"\n        h = self.get_height_iterative()\n        if h = self.L:\n            node = self._search_recursive(self.root, key)\n        else:\n            self.fallback_used = True\n            node = self._search_iterative(key)\n        return node is not None\n\n    def _search_recursive(self, node, key):\n        if not node or node.key == key:\n            return node\n        if key  node.key:\n            return self._search_recursive(node.left, key)\n        else:\n            return self._search_recursive(node.right, key)\n\n    def _search_iterative(self, key):\n        current = self.root\n        while current and current.key != key:\n            if key  current.key:\n                current = current.left\n            else:\n                current = current.right\n        return current\n\n    def insert(self, key):\n        \"\"\"Public insert method with decision logic.\"\"\"\n        h = self.get_height_iterative()\n        # Optimization: check for duplicate before calling recursive to avoid side effects\n        if self._search_iterative(key):\n            return\n\n        if h + 1 = self.L:\n            self.root = self._insert_recursive(self.root, key)\n        else:\n            self.fallback_used = True\n            self._insert_iterative(key)\n\n    def _insert_recursive(self, node, key, parent=None):\n        if not node:\n            return Node(key, parent)\n        \n        if key  node.key:\n            node.left = self._insert_recursive(node.left, key, node)\n        elif key > node.key:\n            node.right = self._insert_recursive(node.right, key, node)\n        \n        return node\n\n    def _insert_iterative(self, key):\n        if not self.root:\n            self.root = Node(key)\n            return\n\n        current = self.root\n        parent = None\n        while current:\n            parent = current\n            if key  current.key:\n                current = current.left\n            elif key > current.key:\n                current = current.right\n            else:\n                return # Duplicate found, do nothing\n\n        new_node = Node(key, parent)\n        if key  parent.key:\n            parent.left = new_node\n        else:\n            parent.right = new_node\n\n    def delete(self, key):\n        \"\"\"Public delete method with decision logic.\"\"\"\n        h = self.get_height_iterative()\n        \n        if h = self.L:\n            self.root = self._delete_recursive(self.root, key)\n        else:\n            self.fallback_used = True\n            self._delete_iterative(key)\n\n    def _delete_recursive(self, node, key):\n        if not node:\n            return None\n\n        if key  node.key:\n            node.left = self._delete_recursive(node.left, key)\n        elif key > node.key:\n            node.right = self._delete_recursive(node.right, key)\n        else: # Node to be deleted is found\n            if not node.left:\n                temp = node.right\n                if temp:\n                    temp.parent = node.parent\n                return temp\n            elif not node.right:\n                temp = node.left\n                if temp:\n                    temp.parent = node.parent\n                return temp\n            \n            successor = self._find_min_iterative(node.right)\n            node.key = successor.key\n            node.right = self._delete_recursive(node.right, successor.key)\n        \n        # After any recursive change, fix parent pointers of children\n        if node.left:\n            node.left.parent = node\n        if node.right:\n            node.right.parent = node\n        \n        return node\n    \n    def _transplant(self, u, v):\n        \"\"\"Replaces subtree rooted at u with subtree at v.\"\"\"\n        if not u.parent:\n            self.root = v\n        elif u == u.parent.left:\n            u.parent.left = v\n        else:\n            u.parent.right = v\n        if v:\n            v.parent = u.parent\n\n    def _delete_iterative(self, key):\n        node_to_delete = self._search_iterative(key)\n        if not node_to_delete:\n            return\n\n        if not node_to_delete.left:\n            self._transplant(node_to_delete, node_to_delete.right)\n        elif not node_to_delete.right:\n            self._transplant(node_to_delete, node_to_delete.left)\n        else:\n            successor = self._find_min_iterative(node_to_delete.right)\n            if successor.parent != node_to_delete:\n                self._transplant(successor, successor.right)\n                successor.right = node_to_delete.right\n                successor.right.parent = successor\n            \n            self._transplant(node_to_delete, successor)\n            successor.left = node_to_delete.left\n            successor.left.parent = successor\n            \n    def _find_min_iterative(self, node):\n        while node.left:\n            node = node.left\n        return node\n    \n    def in_order_traversal(self):\n        \"\"\"Returns a list of keys in in-order.\"\"\"\n        result = []\n        self._in_order_recursive(self.root, result)\n        return result\n\n    def _in_order_recursive(self, node, result):\n        if node:\n            self._in_order_recursive(node.left, result)\n            result.append(node.key)\n            self._in_order_recursive(node.right, result)\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and produce the final output.\n    \"\"\"\n    test_cases = [\n        {\n            \"L\": 100,\n            \"initial\": [8, 4, 12, 2, 6, 10, 14, 1, 3, 5, 7, 9, 11, 13, 15],\n            \"ops\": [('search', 7), ('delete', 8), ('insert', 16), ('delete', 2), ('search', 100)]\n        },\n        {\n            \"L\": 40,\n            \"initial\": list(range(1, 61)),\n            \"ops\": [('search', 60), ('insert', 61), ('delete', 1), ('delete', 61), ('search', 30)]\n        },\n        {\n            \"L\": 5,\n            \"initial\": [],\n            \"ops\": [('search', 10), ('delete', 10), ('insert', 10), ('search', 10), ('delete', 10)]\n        },\n        {\n            \"L\": 20,\n            \"initial\": list(range(1, 21)),\n            \"ops\": [('search', 20)]\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        bst = BST(case[\"L\"])\n        last_search_result = False\n\n        # Build initial tree\n        for key in case[\"initial\"]:\n            bst.insert(key)\n\n        # Apply operations\n        for op_type, key in case[\"ops\"]:\n            if op_type == 'search':\n                last_search_result = bst.search(key)\n            elif op_type == 'insert':\n                bst.insert(key)\n            elif op_type == 'delete':\n                bst.delete(key)\n        \n        H = bst.get_height_iterative()\n        F = bst.fallback_used\n        S = last_search_result\n        I = bst.in_order_traversal()\n        \n        all_results.append([H, F, S, I])\n\n    # Format the final output string\n    # Python's str() on a list gives a representation like '[item1, item2]', which matches the required format.\n    result_strings = [str(res).replace(\" \", \"\") for res in all_results]\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```", "id": "3219097"}, {"introduction": "算法的正确性是其根本，但其效率决定了实用性。本练习将超越大O表示法，对一个基本操作进行精确分析：删除节点时的指针写操作。通过比较带与不带父指针的BST，你将对操作成本和设计权衡有一个细致入微的理解。[@problem_id:3219142]", "problem": "考虑一个标准的二叉搜索树 (BST)，其节点存储一个键和两个分别表示为 $left$ 和 $right$ 的子指针。BST 的不变量性质是：对于任意节点 $x$，其左子树 $x.left$ 中的所有键都严格小于 $x.key$，其右子树 $x.right$ 中的所有键都严格大于 $x.key$。删除操作必须转换树的结构，以使 BST 的不变量性质继续成立，并且它最多只能修改常数个指针。\n\n我们将一次指针更改定义为对以下任一字段的单次写入：指向树的全局 $root$ 指针，或节点的 $left$、$right$ 或（如果存在）$parent$ 指针。对一个正在被销毁且已与树断开连接的节点的内部字段的写入不计入在内。删除操作可以读取任意数量的指针，但我们不计算读取次数；只有写入才算作指针更改。\n\n假设删除算法是广泛使用的后继复制法：要删除一个节点 $z$，\n1. 如果 $z$ 最多只有一个子节点，则将 $z$ 拼接移除，方法是将其（可能为 null 的）子节点直接连接到 $z$ 的父节点（或者如果 $z$ 是根节点，则连接到 $root$）。\n2. 如果 $z$ 有两个子节点，找到 $z$ 的中序后继 $y$（即 $z$ 的右子树中的最小值），将 $y.key$ 复制到 $z.key$ 中，然后删除 $y$。根据构造，$y$ 没有左子节点；其右子节点可能为 null 或非 null。不执行其他键的复制操作。\n\n分析此删除算法在两种模型下执行的指针更改的确切数量：\n- 模型 A：节点不存储 $parent$ 指针。\n- 模型 B：节点存储一个必须始终保持正确的 $parent$ 指针。\n\n对于每种模型，推导出最佳情况和最坏情况的紧确界（涵盖所有可能的 BST 形状和删除目标），并证明达到这些界的场景。将你的最终答案表示为一个单行矩阵，顺序为（模型 A 中的最佳情况，模型 A 中的最坏情况，模型 B 中的最佳情况，模型 B 中的最坏情况）。你的答案必须是一个精确值；无需四舍五入。", "solution": "问题陈述是数据结构与算法领域中一个明确定义的问题。它清晰地定义了二叉搜索树 (BST)、待分析的特定删除算法（后继复制法）以及“指针更改”的精确定义。该问题是自包含的，科学上基于计算机科学原理，且没有歧义或矛盾。因此，该问题是有效的，可以进行严谨的分析。\n\n设 $z$ 为要删除的节点。分析分为两部分，对应于问题中定义的两种模型。一次指针更改是对 `root`、`left`、`right` 或 `parent` 指针字段的单次写操作。\n\n指定的删除算法如下：\n1.  如果节点 $z$ 最多有一个子节点（即 $z.left$ 为 `null` 或 $z.right$ 为 `null`），则将 $z$ 拼接移除。其父节点的相应子指针被更新为指向 $z$ 的单个子节点（也可能为 `null`）。如果 $z$ 是根节点，则更新全局 `root` 指针。\n2.  如果节点 $z$ 有两个子节点，则找到它的中序后继节点 $y$。根据定义，$y$ 是 $z$ 右子树中键最小的节点。将 $y$ 的键复制到 $z$ 中（即 $z.key \\leftarrow y.key$）。然后，问题简化为从其原始位置删除节点 $y$。由于 $y$ 是子树中的最小元素，它保证没有左子节点（$y.left$ 为 `null`），因此删除它属于第一种情况（最多一个子节点）。\n\n我们现在分析每种模型下的指针更改次数。\n\n### 模型 A：节点不带 `parent` 指针\n\n在此模型中，仅有的指针是 `root`、`left` 和 `right`。\n\n**情况 1：删除最多有一个子节点的节点 $z$。**\n设 `p` 为 $z$ 的父节点，`c` 为 $z$ 的单个子节点（如果 $z$ 是叶子节点，则为 `null`）。\n- 如果 $z$ 是树的根节点，则 `p` 为 `null`。全局 `root` 指针被更新为指向 `c`。这恰好是 **一次** 指针更改：`root \\leftarrow c`。\n- 如果 $z$ 不是根节点，其父节点 `p` 必须更新其一个子指针。如果 $z$ 是 `p` 的左子节点，指针更改为 `p.left \\leftarrow c`。如果 $z$ 是右子节点，则更改为 `p.right \\leftarrow c`。在任何一种情况下，这都恰好构成 **一次** 指針更改。\n因此，在模型 A 中，删除一个最多只有一个子节点的节点总是导致恰好 1 次指针更改。\n\n**情况 2：删除有两个子节点的节点 $z$。**\n该算法将后继节点 $y$ 的键复制到 $z$ 中，然后删除 $y$。指针的更改仅与删除 $y$ 相关。如前所述，$y$ 没有左子节点，因此删除它属于情况 1 的一个实例。节点 $y$ 始终在 $z$ 的右子树中，因此它永远不可能是整棵树的根。因此，$y$ 总是有一个父节点，我们称之为 $y_p$。\n要删除 $y$，$y_p$ 的相应子指针被更新为指向 $y$ 唯一可能的子节点 $y.right$。这涉及单次写入：要么是 $y_p.left \\leftarrow y.right$（如果 $y$ 是一个左子节点），要么是 $y_p.right \\leftarrow y.right$（如果 $y$ 是其父节点的直接右子节点）。这总是恰好 **一次** 指针更改。\n\n**模型 A 的结论：**\n在所有可能的情况下——删除叶子节点、带一个子节点的节点或带两个子节点的节点——指定的算法都恰好执行 1 次指针更改。\n- **模型 A 中指针更改的最佳情况次数为 1。** 这在每次删除中都能达到。\n- **模型 A 中指针更改的最坏情况次数为 1。** 这是任何删除操作的最多更改次数。\n\n### 模型 B：节点带 `parent` 指针\n\n在此模型中，我们还必须维护 `parent` 指针的正确性。\n\n**情况 1：删除最多有一个子节点的节点 $z$。**\n设 `p` 为 $z$ 的父节点，`c` 为 $z$ 的单个子节点。\n与模型 A 中一样，`p` 的一个指针（或 `root` 指针）被更新以绕过 $z$ 指向 `c`。这是 **一次** 指针更改。\n此外，如果子节点 `c` 不为 `null`，其 `parent` 指针必须从 $z$ 更新为 `p`。此操作 `c.parent \\leftarrow p` 是 **第二次** 指针更改。\n- 如果 $z$ 是一个叶子节点，则 `c` 为 `null`。没有 `parent` 指针需要更新。总共是 **一次** 指针更改。\n- 如果 $z$ 有一个子节点 `c`，则更改两个指针：`p` 的子指针（或 `root`）和 `c` 的 `parent` 指针。总共是 **两次** 指针更改。\n\n**情况 2：删除有两个子节点的节点 $z$。**\n同样，该操作简化为删除后继节点 $y$，它最多只有一个子节点（其右子节点 $y.right$）。设 `y_p` 为 $y$ 的父节点，`y_c` 为 $y$ 的右子节点。指针更改的次数通过将情况 1 的逻辑应用于节点 $y$ 来确定。\n- `y_p` 的子指针被更新为指向 `y_c`。这是 **一次** 指针更改。\n- 如果 `y_c` 不为 `null`，其 `parent` 指针必须更新为 `y_p`。这是 **第二次** 指针更改。\n如果 $y$ 是一个叶子节点（`y_c` 为 `null`），则总更改次数为 1；如果 $y$ 有一个右子节点，则为 2。\n\n**模型 B 的结论：**\n指针更改的次数可以是 1 或 2。\n- **模型 B 中指针更改的最佳情况次数为 1。**\n  当被有效拼接移除的节点是叶子节点时，达到这个最小值。\n  - 场景 1：删除一个叶子节点 $z$。只需要一次指针更改，将父节点的子指针设置为 `null`。\n  - 场景 2：删除一个有两个子节点的节点 $z$，其中序后继 $y$ 是一个叶子节点。删除 $y$ 只需要一次指针更改。\n- **模型 B 中指针更改的最坏情况次数为 2。**\n  当被有效拼接移除的节点有一个子节点时，达到这个最大值。\n  - 场景 1：删除一个恰好有一个子节点 `c` 的节点 $z$。需要两次更改：一次用于父节点的子指针，一次用于 `c` 的 `parent` 指针。\n  - 场景 2：删除一个有两个子节点的节点 $z$，其中序后继 $y$ 有一个右子节点 $y_c$。删除 $y$ 需要两次更改：一次用于其父节点的子指针，一次用于 $y_c$ 的 `parent` 指针。\n\n### 最终总结\n每种模型的指针更改次数为：\n- 模型 A（无 `parent`）：最佳情况 = 1，最坏情况 = 1。\n- 模型 B（有 `parent`）：最佳情况 = 1，最坏情况 = 2。\n\n最终答案以行矩阵的形式呈现，顺序为（模型 A 中的最佳情况，模型 A 中的最坏情况，模型 B 中的最佳情况，模型 B 中的最坏情况）。", "answer": "$$\n\\boxed{\n\\begin{pmatrix} 1  1  1  2 \\end{pmatrix}\n}\n$$", "id": "3219142"}]}