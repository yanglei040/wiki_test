{"hands_on_practices": [{"introduction": "理论的优雅在于其简洁性，但数据结构在现实世界中的性能表现最终取决于其物理实现。这个练习将引导我们剖析B+树的内部节点，量化其中索引键的存储开销。通过推导一个简单的公式，你将亲身体会到树的阶数 $m$、键大小 $s_k$ 和指针大小 $s_p$ 是如何共同决定存储效率的，这是理解和设计高效数据库索引的关键第一步。[@problem_id:3212035]", "problem": "考虑一个阶为 $m$ 的B+树，其中每个具有 $m$ 个子节点的内部节点恰好存储 $m-1$ 个分隔键，这些分隔键是已存储在叶节点中的用户键的副本。设每个键的大小为 $s_k$ 字节，每个子节点指针的大小为 $s_p$ 字节。假设以下条件成立：\n- 所考虑的内部节点是满的，恰好包含 $m$ 个子节点指针和 $m-1$ 个分隔键。\n- 忽略任何每节点的头部、对齐填充或辅助元数据；只计算键和子节点指针所占用的字节。\n- 将“冗余键存储”一词解释为内部节点中的键复制了已存在于叶节点中的信息，是相对于一个仅需子节点指针进行导航的假设性基线而言的开销。\n\n将内部节点中冗余键存储的空间开销定义为以下比率\n$$\\text{开销} \\equiv \\frac{\\text{内部节点键所用字节数}}{\\text{内部节点子节点指针所用字节数}}。$$\n仅使用 B+ 树内部节点的结构定义以及大小 $s_k$、$s_p$ 和阶数 $m$，推导出一个关于 $m$、$s_k$ 和 $s_p$ 的开销的闭式解析表达式。将最终答案表示为一个无单位的单一简化表达式。", "solution": "在尝试求解之前，对问题陈述进行验证。\n\n### 步骤1：提取已知条件\n- **数据结构**：B+树。\n- **阶**：$m$。\n- **内部节点内容**：对于一个满节点，恰好有 $m$ 个子节点和 $m-1$ 个分隔键。\n- **键的属性**：内部节点的键是叶节点中已存在键的副本。\n- **键的大小**：$s_k$ 字节。\n- **子节点指针的大小**：$s_p$ 字节。\n- **简化假设**：\n    - 所有考虑的内部节点都是满的。\n    - 每节点的头部、对齐填充和辅助元数据均被忽略。\n- **开销的定义**：内部节点键所用字节数与内部节点子节点指针所用字节数的比率。\n    $$ \\text{开销} \\equiv \\frac{\\text{内部节点键所用字节数}}{\\text{内部节点子节点指针所用字节数}} $$\n- **目标**：推导开销作为 $m$、$s_k$ 和 $s_p$ 函数的闭式解析表达式。\n\n### 步骤2：使用提取的已知条件进行验证\n根据验证标准对问题进行评估。\n\n- **科学依据**：该问题基于 B+ 树的标准且成熟的定义，B+ 树是计算机科学中的一种基本数据结构。对于一个阶为 $m$ 的树，其内部节点有 $m$ 个子节点指针和 $m-1$ 个键的描述是正确的。内部节点中的分隔键是叶节点中键的副本这一概念，是 B+ 树区别于 B- 树的决定性特征。该问题在科学上是合理的。\n- **定义良好**：该问题提供了所有必要的变量（$m$、$s_k$、$s_p$），以及对要计算的量（开销）的精确、无歧义的定义。简化条件（满节点、无元数据）在理论分析中是标准的，并确保可以推导出唯一的解。\n- **客观性**：语言是正式的，不含主观或基于观点的陈述。\n\n该问题没有表现出任何诸如科学上不合理、不完整、矛盾、模棱两可或定义不当之类的缺陷。\n\n### 步骤3：结论与行动\n该问题是**有效的**。将推导解答。\n\n### 解题推导\n目标是推导空间开销的表达式，其定义如下：\n$$ \\text{开销} = \\frac{\\text{内部节点键所用字节数}}{\\text{内部节点子节点指针所用字节数}} $$\n\n我们将根据单个满内部节点的给定参数，分别计算分子和分母。\n\n首先，我们计算一个满内部节点中键所消耗的总字节数。根据问题陈述，一个阶为 $m$ 的满内部节点恰好包含 $m-1$ 个分隔键。每个键的大小给定为 $s_k$ 字节。因此，键所占用的总空间是键的数量与每个键大小的乘积。\n\n$$ \\text{键的字节数} = (m-1) \\times s_k $$\n\n接下来，我们计算同一个满内部节点中子节点指针所消耗的总字节数。一个阶为 $m$ 的满内部节点恰好指向 $m$ 个子节点。每个子节点指针的大小给定为 $s_p$ 字节。因此，子节点指针所占用的总空间是指针的数量与每个指针大小的乘积。\n\n$$ \\text{子节点指针的字节数} = m \\times s_p $$\n\n现在，我们将这两个表达式代入问题陈述中提供的开销定义。\n\n$$ \\text{开销} = \\frac{(m-1)s_k}{m s_p} $$\n\n该表达式是关于给定参数 $m$、$s_k$ 和 $s_p$ 的闭式解。该表达式可以写成另一种形式，以突出其对 $m-1$ 与 $m$ 之比的依赖性：\n$$ \\text{开销} = \\left(\\frac{m-1}{m}\\right) \\frac{s_k}{s_p} = \\left(1 - \\frac{1}{m}\\right) \\frac{s_k}{s_p} $$\n然而，$\\frac{(m-1)s_k}{m s_p}$ 的形式已经完全简化，并直接表示了从问题定义中推导出的关系。这就是所求开销的最终表达式。", "answer": "$$\\boxed{\\frac{(m-1)s_k}{m s_p}}$$", "id": "3212035"}, {"introduction": "一个系统或算法的真正稳健性，体现在其面对不完美和损坏情况时的表现。这个挑战性的练习将B树的一个关键属性——父节点键的分割作用——设定为不可靠，迫使你重新思考搜索的本质。为了在损坏的树中找到正确的路径，你必须区分哪些是B树不可动摇的“基石”属性，哪些只是为了提高效率的“脚手架”，这对于设计任何可靠系统都是一种宝贵的思维训练。[@problem_id:3212077]", "problem": "给定一个 B 树（一种平衡多路搜索树）的数学定义，对于一个最小度参数 $t$，它满足以下核心属性：\n- 除根节点外，每个节点包含 $t-1$ 到 $2t-1$ 个已排序的键。\n- 每个具有 $m$ 个键的内部节点恰好包含 $m+1$ 个子节点。\n- 每个节点中的键都按非降序排列。\n- 在一个正确的树中，对于一个具有键 $k_0,k_1,\\dots,k_{m-1}$ 和子节点 $c_0,c_1,\\dots,c_m$ 的内部节点，子树 $c_i$ 中的所有键都位于由排序顺序中的 $k_{i-1}$ 和 $k_i$ 界定的区间内。\n\n考虑一棵已损坏的 B 树，其中一些父节点的分隔键不再能正确地划分其子树的值集。也就是说，存在一些内部节点，其子树包含的值超出了父节点键所隐含的标称区间。你可以假定的唯一保证是：\n- 每个节点（包括内部节点和叶节点）内部存储的键都按非降序排列。\n- 存储在叶节点中的所有键都是该树所表示的集合的真实数据元素。\n- 结构性分支约束（每个节点的键和子节点数量）对于某个最小度 $t$ 仍在有效范围内，但你未被提供 $t$ 的值，也不得依赖它。\n- 父节点的分隔键可能是错误的，因此不能信赖它们来唯一确定用于搜索的单个子节点。\n\n任务：设计并实现一个鲁棒的搜索算法，给定一个键 $x$，该算法返回 $x$ 是否存在于已损坏的 B 树中。你的算法必须在分隔边界任意损坏的情况下保持正确，只要节点本地的键顺序得以保留且叶节点的键是准确的。你的推导和设计应基于第一性原理和树的可观察属性。该算法必须：\n- 检查当前节点的存储键中是否存在 $x$。\n- 仅使用关于子树的可验证信息（可从当前树实例中推导）来选择要遍历的子树。\n- 避免排除任何可能包含 $x$ 的子树。\n- 以一个布尔值答案终止，指示 $x$ 是否存在。\n\n在你推导和设计中使用的基本依据：\n- B 树的节点不变量定义（已排序的节点本地键、分支界限）。\n- 搜索原则：树中存在的任何值都必须出现在某个叶节点中，并且任何叶节点值都受其所在子树的最小值和最大值所限制。\n\n你必须生成一个完整的、可运行的程序，该程序构建三个小型 B 树（在内存中表示）并对指定的查询执行鲁棒搜索。这些树和查询构成了测试套件，具体如下。\n\n定义以下树：\n\n- 树 $\\mathrm{T}_1$（正确分隔）：根节点有键 $\\{10,20\\}$ 和子节点：\n    - 子节点 $c_0$ 是一个叶节点，键为 $\\{2,5,9\\}$。\n    - 子节点 $c_1$ 是一个叶节点，键为 $\\{12,15,19\\}$。\n    - 子节点 $c_2$ 是一个叶节点，键为 $\\{21,25,28\\}$。\n\n- 树 $\\mathrm{T}_2$（根节点处分隔损坏）：与 $\\mathrm{T}_1$ 相同，只是根节点的键更改为 $\\{14,20\\}$，而子节点保持不变：\n    - 子节点 $c_0$ 的叶节点键为 $\\{2,5,9\\}$。\n    - 子节点 $c_1$ 的叶节点键为 $\\{12,15,19\\}$。\n    - 子节点 $c_2$ 的叶节点键为 $\\{21,25,28\\}$。\n\n- 树 $\\mathrm{T}_3$（因损坏导致范围重叠）：根节点有键 $\\{15,30\\}$ 和子节点：\n    - 子节点 $c_0$ 是一个叶节点，键为 $\\{5,10,25\\}$。\n    - 子节点 $c_1$ 是一个叶节点，键为 $\\{16,18\\}$。\n    - 子节点 $c_2$ 是一个叶节点，键为 $\\{31,34\\}$。\n\n对以下查询执行鲁棒搜索：\n- 在 $\\mathrm{T}_1$ 上，搜索 $x=25$。\n- 在 $\\mathrm{T}_2$ 上，搜索 $x=12$。\n- 在 $\\mathrm{T}_2$ 上，搜索 $x=13$。\n- 在 $\\mathrm{T}_2$ 上，搜索 $x=2$。\n- 在 $\\mathrm{T}_3$ 上，搜索 $x=25$。\n- 在 $\\mathrm{T}_3$ 上，搜索 $x=18$。\n- 在 $\\mathrm{T}_3$ 上，搜索 $x=29$。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果顺序与测试用例相同（例如，$[\\mathrm{result}_1,\\mathrm{result}_2,\\dots]$）。每个结果必须是一个布尔值，指示查询的值是否存在于相应的树中。输出不涉及任何物理单位、角度或百分比；所有结果均为纯布尔值。", "solution": "该问题要求为一种 B 树结构设计并实现一个鲁棒的搜索算法，在这种结构中，子树之间基于键分隔的定义性属性已损坏。该算法必须仅使用保证有效的信息来正确确定所查询键 $x$ 的存在性。\n\n### 问题验证\n\n首先，我们对问题陈述进行验证。\n\n**第 1 步：提取的已知条件**\n- **标准 B 树定义：** 一种最小度为 $t$ 的平衡多路搜索树，其中节点包含 $t-1$到 $2t-1$ 个键，一个有 $m$ 个键的内部节点有 $m+1$ 个子节点，且键已排序。正确的分隔意味着子树 $c_i$ 中的键受父节点键 $k_{i-1}$ 和 $k_i$ 的限制。\n- **已损坏 B 树的保证：**\n    1. 父节点的分隔键不可靠，不得用于选择用于搜索的子树。\n    2. 任何单个节点内的键都按非降序排列。\n    3. 存储在所有叶节点中的所有键集合构成了完整且正确的数据元素集。\n    4. 结构性分支约束（每个节点的键和子节点数量）对于某个未知的最小度 $t$ 是有效的。\n- **任务：** 为键 $x$ 设计一个鲁棒的搜索算法，返回一个指示其存在性的布尔值。该算法必须：\n    - 检查当前节点中是否存在 $x$。\n    - 仅使用可验证的信息来决定遍历哪些子节点。\n    - 避免排除任何可能包含 $x$ 的子树。\n- **测试用例：** 提供了三个特定的树结构（$T_1$、$T_2$、$T_3$）和七个特定的搜索查询，用于实现和验证。\n\n**第 2 步：使用提取的已知条件进行验证**\n该问题在科学上和算法上都是合理的。它提出了一个标准数据结构问题的变体，重点关注在面对数据损坏时的鲁棒性。这是计算机科学中的一个有效主题，特别是在容错系统和数据恢复的研究中。\n- **科学依据：** 该问题基于 B 树的正式定义，这是数据结构中的一个基本概念。“损坏”是对标准不变量的明确定义的修改，从而导致一个全新的、但可形式化的问题。\n- **适定性：** 该问题提供了一个明确的目标（找到键 $x$）和一套完整的约束（什么是可靠的 vs. 不可靠的）。解决方案是存在的（例如，对所有叶节点进行暴力搜索是一个有效但效率低下的解决方案），其挑战在于设计一个更有原则且更高效的算法。提供的测试用例使成功标准明确无误。\n- **客观性：** 语言精确，没有主观性。\n\n**第 3 步：结论与行动**\n该问题被判定为 **有效**。我们可以着手推导解决方案。\n\n### 鲁棒搜索算法的推导\n\n根本的挑战在于，标准的 B 树搜索依赖于这样一个属性：如果在父节点中有 $k_{i-1}  x  k_i$，那么 $x$ 只能存在于子树 $c_i$ 中。由于这个属性被破坏，将搜索键 $x$ 与父节点的键进行比较，无法为将搜索范围剪枝到单个子节点提供可靠的指导。\n\n**1. 识别可验证信息**\n\n我们必须完全基于所述的保证来制定搜索策略。最关键的保证是：\n- 任何给定节点内的键都是有序的。\n- 完整的值集合位于叶节点中。\n\n从这些原则出发，我们可以推断出一个键 $x$ 存在于以节点 $N$ 为根的任何子树中的必要条件。如果 $x$ 在该子树中，它必须大于或等于该子树中的真实最小值，并小于或等于真实最大值。我们分别用 $\\min_{true}(N)$ 和 $\\max_{true}(N)$ 表示以 $N$ 为根的子树中的真实最小值和最大值。\n\n搜索键 $x$ 只有在 $x \\in [\\min_{true}(N), \\max_{true}(N)]$ 的情况下，才可能存在于 $N$ 的子树中。\n\n**2. 计算子树的真实值范围**\n\n由于所有数据元素都驻留在叶节点中，任何子树的真实值范围都由其后代叶节点中的键决定。我们可以为树中的每个节点计算这个范围。这个计算可以作为预处理步骤执行一次，并将结果缓存在每个节点上。后序遍历是实现这一目标的自然方式。\n\n为节点 $N$ 计算并缓存这些真实边界的算法如下：\n- **基本情况：** 如果 $N$ 是一个叶节点，其键保证是有序的。因此，$\\min_{true}(N)$ 是节点中的第一个键，而 $\\max_{true}(N)$ 是最后一个键。如果叶节点为空，其范围是空泛的；我们可以使用 $[\\infty, -\\infty]$。\n- **递归步骤：** 如果 $N$ 是一个具有子节点 $\\{C_0, C_1, \\dots, C_m\\}$ 的内部节点，我们首先为其所有子节点递归地计算真实范围。问题陈述不保证子树之间的键范围有任何排序（例如，不保证 $\\max_{true}(C_i)  \\min_{true}(C_{i+1})$）。因此，为了保证鲁棒性，我们必须找到其所有子节点中的最小值和最大值。\n$$ \\min_{true}(N) = \\min_{i=0}^{m} \\{\\min_{true}(C_i)\\} $$\n$$ \\max_{true}(N) = \\max_{i=0}^{m} \\{\\max_{true}(C_i)\\} $$\n这个预计算为每个节点增加了可验证的 `min_val` 和 `max_val` 属性，代表其整个子树中包含的所有键的真实边界。\n\n**3. 鲁棒搜索算法**\n\n在预先计算好真实值范围后，从节点 $N$ 开始对键 $x$ 进行的鲁棒搜索按以下步骤进行：\n\n1.  **检查当前节点：** 在当前节点 $N$ 的已排序键中搜索 $x$。鉴于键的有序性，二分搜索是高效的。如果找到 $x$，算法终止，返回 `true`。\n2.  **叶节点终止：** 如果 $N$ 是一个叶节点，并且在其键中未找到 $x$（步骤 1），那么 $x$ 不可能在该子树中。对于此路径，算法返回 `false`。\n3.  **内部节点递归：** 如果 $N$ 是一个内部节点，算法必须探索所有其真实值范围可能包含 $x$ 的子节点。它遍历 $N$ 的每个子节点 $C_i$。\n4.  **可能性检查：** 对于每个子节点 $C_i$，检查 $x$ 是否落在其预先计算的真实范围之内：$\\min_{true}(C_i) \\le x \\le \\max_{true}(C_i)$。\n5.  **递归搜索：** 如果满足上一步的条件，子树 $C_i$ 是 $x$ 的一个可能位置。算法在 $C_i$ 上递归调用自身。如果这个递归调用返回 `true`，意味着已经找到了 $x$，主搜索可以终止并返回 `true`。\n6.  **穷尽搜索：** 如果算法遍历了所有可能的子节点，但没有一个递归调用找到 $x$，则可以断定 $x$ 不在 $N$ 的任何子树中。函数返回 `false`。\n\n这个算法是正确的，因为它从不依赖损坏的父节点分隔键进行导航。相反，它基于哪些子树包含哪些值范围的可验证事实动态构建其搜索路径，确保没有可能的路径被过早地剪枝。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass Node:\n    \"\"\"\n    Represents a node in the B-tree.\n    Each node stores its keys, children, and pre-computed true min/max values\n    of the subtree rooted at this node.\n    \"\"\"\n    def __init__(self, keys, children=None):\n        \"\"\"\n        Initializes a Node.\n        \n        Args:\n            keys (list[int]): A list of keys stored in the node.\n            children (list[Node], optional): A list of child nodes. Defaults to None.\n        \"\"\"\n        # Ensure keys are stored in a sorted NumPy array for efficient search.\n        self.keys = np.array(keys, dtype=np.int64)\n        self.children = children if children else []\n        self.is_leaf = not bool(self.children)\n        \n        # These will be populated by compute_bounds.\n        self.min_val = None\n        self.max_val = None\n\ndef compute_bounds(node):\n    \"\"\"\n    Performs a post-order traversal to compute and cache the true minimum and\n    maximum key values for the subtree rooted at each node.\n    \n    Args:\n        node (Node): The root of the subtree to process.\n    \"\"\"\n    if node.is_leaf:\n        if node.keys.size > 0:\n            node.min_val = node.keys[0]\n            node.max_val = node.keys[-1]\n        else:\n            # An empty leaf has an invalid range.\n            node.min_val = float('inf')\n            node.max_val = float('-inf')\n        return\n\n    # Post-order: process children first.\n    child_min_vals = []\n    child_max_vals = []\n    for child in node.children:\n        compute_bounds(child)\n        child_min_vals.append(child.min_val)\n        child_max_vals.append(child.max_val)\n    \n    # The true range of an internal node is the union of the ranges of all its children.\n    # This robustly handles any child ordering.\n    if child_min_vals:\n        node.min_val = min(child_min_vals)\n    if child_max_vals:\n        node.max_val = max(child_max_vals)\n\ndef robust_search(node, x):\n    \"\"\"\n    Searches for a key 'x' in a potentially corrupted B-tree.\n    \n    Args:\n        node (Node): The current node to search in.\n        x (int): The key to search for.\n    \n    Returns:\n        bool: True if the key is found, False otherwise.\n    \"\"\"\n    # 1. Check if x is in the current node's keys.\n    # np.searchsorted gives the index where x would be inserted to maintain order.\n    # If the element at that index is x, we have found the key.\n    idx = np.searchsorted(node.keys, x)\n    if idx  len(node.keys) and node.keys[idx] == x:\n        return True\n\n    # 2. If this is a leaf node and x was not found, the search path ends here.\n    if node.is_leaf:\n        return False\n\n    # 3. For an internal node, recurse on all plausible children.\n    # A child is plausible if x is within its pre-computed true value range.\n    for child in node.children:\n        # The node must have a valid range to be considered.\n        if child.min_val is not None and child.max_val is not None:\n            if child.min_val = x = child.max_val:\n                # If found in any plausible subtree, the overall result is True.\n                if robust_search(child, x):\n                    return True\n    \n    # 4. If x was not found in the node or any plausible child subtree.\n    return False\n\ndef solve():\n    \"\"\"\n    Main function to define trees, run queries, and print results.\n    \"\"\"\n    # --- Define Tree T1 (correctly separated) ---\n    t1_c0 = Node(keys=[2, 5, 9])\n    t1_c1 = Node(keys=[12, 15, 19])\n    t1_c2 = Node(keys=[21, 25, 28])\n    t1_root = Node(keys=[10, 20], children=[t1_c0, t1_c1, t1_c2])\n    compute_bounds(t1_root)\n\n    # --- Define Tree T2 (corrupted separation) ---\n    # Children are identical to T1, but root keys are different.\n    t2_c0 = Node(keys=[2, 5, 9])\n    t2_c1 = Node(keys=[12, 15, 19])\n    t2_c2 = Node(keys=[21, 25, 28])\n    t2_root = Node(keys=[14, 20], children=[t2_c0, t2_c1, t2_c2])\n    compute_bounds(t2_root)\n\n    # --- Define Tree T3 (overlapping ranges) ---\n    t3_c0 = Node(keys=[5, 10, 25])\n    t3_c1 = Node(keys=[16, 18])\n    t3_c2 = Node(keys=[31, 34])\n    t3_root = Node(keys=[15, 30], children=[t3_c0, t3_c1, t3_c2])\n    compute_bounds(t3_root)\n\n    # Define the test cases from the problem statement.\n    queries = [\n        (t1_root, 25),\n        (t2_root, 12),\n        (t2_root, 13),\n        (t2_root, 2),\n        (t3_root, 25),\n        (t3_root, 18),\n        (t3_root, 29),\n    ]\n\n    results = []\n    for tree_root, key_to_find in queries:\n        result = robust_search(tree_root, key_to_find)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # Python's str() of a boolean is 'True' or 'False', which must be lowercased.\n    print(f\"[{','.join(map(str, results)).lower()}]\")\n\nsolve()\n\n```", "id": "3212077"}]}