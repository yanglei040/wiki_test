{"hands_on_practices": [{"introduction": "这项练习侧重于处理任何树形结构的一项基本技能：递归思维。我们将探讨树的对称性概念，它取决于一棵树的左子树和右子树是否互为镜像。通过实现对称性检查，你将在将一个问题分解为更小的、自相似的子问题方面获得实践经验，这是掌握树形算法至关重要的递归核心原则。[@problem_id:3216104]", "problem": "你的任务是使用数据结构的基本定义和第一原理，设计并实现一个程序，判断一个给定的二叉树是否围绕其根对称。请从二叉树的递归定义开始：二叉树要么是空的，要么由一个节点组成，该节点有一个左孩子和一个右孩子，它们各自也是一棵二叉树。设一棵树表示为 $T$，其根为 $r$，其左右子树分别为 $T_{\\text{L}}$ 和 $T_{\\text{R}}$。\n\n将从根到任意节点的路径定义为字母表 $\\{\\text{L}, \\text{R}\\}$ 上的一个有限序列，分别表示向左或向右遍历。对于任意路径 $p \\in \\{\\text{L}, \\text{R}\\}^{\\ast}$，通过函数 $\\phi$ 定义路径的镜像，使得 $\\phi(\\text{L}) = \\text{R}$ 且 $\\phi(\\text{R}) = \\text{L}$，并同态地扩展到字符串，以便对于任意 $k \\in \\mathbb{N}$，都有 $\\phi(p_{1}p_{2}\\cdots p_{k}) = \\phi(p_{1})\\phi(p_{2})\\cdots\\phi(p_{k})$。一棵根为 $r$ 的二叉树 $T$ 是围绕其根对称的，当且仅当对于通往 $T_{\\text{L}}$ 中节点 $u$ 的每一条路径 $p$，在 $T_{\\text{R}}$ 中路径 $\\phi(p)$ 处都存在一个节点 $v$，使得存储在 $u$ 处的值等于存储在 $v$ 处的值，反之亦然，并且所有这些对应关系在每个深度都成立。如果一侧缺少节点而另一侧存在节点，则该树不对称。\n\n算法的输入是一个序列，该序列以层序（广度优先）的方式将树编码为一个列表。对于索引 $i$，其左孩子位于索引 $2i+1$ 处，右孩子位于索引 $2i+2$ 处，前提是这些索引存在且父节点不缺失。使用 $\\texttt{None}$ 表示节点的缺失。例如，列表 $\\left[\\,1,2,2,3,4,4,3\\,\\right]$ 编码了一个高度为 $3$ 的完美对称树。列表 $\\left[\\,1,2,2,\\texttt{None},3,\\texttt{None},3\\,\\right]$ 编码了一棵不对称的树，因为镜像位置不都存在或值不匹配。\n\n你的任务是：\n- 实现一个过程，该过程给定这样一个层序列表，根据列表构建相应的二叉树，并尊重缺失标记 $\\texttt{None}$，然后根据上述定义判断该树是否围绕其根对称。\n- 该判断必须基于二叉树的递归结构和镜像路径映射 $\\phi$；不允许使用任何捷径或预打包的对称性检查。\n\n你的程序应该评估以下测试套件。每个测试用例都是一个使用 $\\texttt{None}$ 表示缺失节点的层序列表：\n- 测试 $1$：$\\left[\\,\\,\\right]$ (空树)。\n- 测试 $2$：$\\left[\\,1\\,\\right]$。\n- 测试 $3$：$\\left[\\,1,2,2,3,4,4,3\\,\\right]$。\n- 测试 $4$：$\\left[\\,1,2,2,\\texttt{None},3,\\texttt{None},3\\,\\right]$。\n- 测试 $5$：$\\left[\\,1,2,2,3,\\texttt{None},\\texttt{None},4\\,\\right]$。\n- 测试 $6$：$\\left[\\,1,2,2,3,4,4,3,\\texttt{None},\\texttt{None},5,6,6,5,\\texttt{None},\\texttt{None}\\,\\right]$。\n- 测试 $7$：$\\left[\\,1,\\texttt{None},2\\,\\right]$。\n\n对于每个测试用例，要求的输出是一个布尔值，表示该树是否围绕其根对称。你的程序应该生成单行输出，其中包含所有测试用例的结果，格式为方括号括起来的逗号分隔列表，例如 $\\left[\\,\\texttt{True},\\texttt{False}\\,\\right]$。最终输出不得有空格，格式必须严格为：\"[result1,result2,...]\"。", "solution": "问题陈述经评估有效。这是一个在数据结构与算法领域内定义明确、有科学依据的问题，包含了获得唯一解所需的所有必要信息和定义。\n\n任务是判断一个以层序列表格式提供的二叉树是否围绕其根对称。该解法在逻辑上分解为两个主要阶段：首先，从列表表示中重建树数据结构；其次，根据所提供的递归和基于路径的定义来验证其对称性。\n\n首先，我们处理从层序列表构建二叉树的问题。二叉树节点是一个基本结构，包含一个值以及指向其左右孩子的指针，而左右孩子本身也是二叉树。我们可以为此定义一个 `TreeNode` 类。输入列表以广度优先的方式表示树，其中对于索引 $i$ 处的父节点，其左孩子位于索引 $2i+1$ 处，右孩子位于索引 $2i+2$ 处。值 $\\texttt{None}$ 表示节点缺失。\n\n构建算法如下：\n$1$. 如果输入列表为空，则树为空，返回 $\\texttt{None}$。\n$2$. 否则，索引 $0$ 处的元素是树的根。为其创建一个 `TreeNode`。\n$3$. 初始化一个队列，并将根节点加入队列。该队列将用于存放需要分配子节点的父节点。\n$4$. 初始化一个计数器（例如 $j$）为 $1$，用于遍历输入列表以获取子节点的值。\n$5$. 当队列不为空且索引 $j$ 在列表范围内时，我们从队列中取出一个父节点。\n$6$. 索引 $j$ 处的值对应于左孩子。如果该值不为 $\\texttt{None}$，则创建一个新的 `TreeNode` 并将其赋为父节点的左孩子，然后将这个新节点入队。索引 $j$ 递增。\n$7$. 新索引 $j$ 处的值对应于右孩子。如果该值不为 $\\texttt{None}$，则创建一个新的 `TreeNode` 并将其赋为父节点的右孩子，然后入队。索引 $j$ 再次递增。\n$8$. 这个过程持续进行，直到列表中的所有节点都被处理完毕，从而正确地重建树结构。\n\n其次，我们处理对称性的验证问题。问题定义了根为 $r$ 的树 $T$ 是对称的，如果对于其左子树 $T_{\\text{L}}$ 中的每一条路径 $p$，在右子树 $T_{\\text{R}}$ 中的镜像路径 $\\phi(p)$ 处都存在一个值相等的节点，反之亦然。镜像函数 $\\phi$ 会交换路径序列中的 $\\text{L}$ 和 $\\text{R}$。\n\n这个形式化定义很自然地导出一个优雅的递归解法。一棵树是对称的，当且仅当其左右子树互为镜像。我们可以定义一个递归辅助函数，称之为 `areMirrors(node1, node2)`，它用来判断以 `node1` 和 `node2` 为根的两棵树是否互为镜像。该函数由以下条件定义：\n\n$1$. **基本情况 1**：如果 `node1` 和 `node2` 都为空 (即 $\\texttt{None}$)，它们平凡地互为镜像。函数返回 `True`。这对应于路径在两个子树中同时终止的情况。\n$2$. **基本情况 2**：如果 `node1` 和 `node2` 中只有一个为空而另一个不为空，则它们不可能是镜像。函数返回 `False`。这对应于这样的条件：如果一侧的给定路径上存在节点，则其对应部分必须存在于另一侧的镜像路径上。\n$3$. **递归步骤**：如果两个节点都不为空，那么它们互为镜像当且仅当满足三个条件：\n    a. 它们的根节点值必须相等：`node1.value == node2.value`。\n    b. `node1` 的左子树必须是 `node2` 的右子树的镜像。这通过递归调用 `areMirrors(node1.left, node2.right)` 来检查。\n    c. `node1` 的右子树必须是 `node2` 的左子树的镜像。这通过递归调用 `areMirrors(node1.right, node2.left)` 来检查。\n\n这种递归结构直接实现了路径映射的要求。初始调用 `areMirrors(root.left, root.right)` 比较了从根出发的路径 $\\text{L}$ 和路径 $\\phi(\\text{L}) = \\text{R}$。随后的递归调用，例如 `areMirrors(node1.left, node2.right)`，实际上是将原始树左子树中类似 $\\text{L}p$ 的路径（以 $\\text{L}$ 开头的路径）与原始树右子树中类似 $\\text{R}\\phi(p)$ 的路径（以 $\\text{R}$ 开頭，后跟 $p$ 的镜像）进行比较，从而确保在每个层级上的结构和值都对应。主函数 `isSymmetric(root)` 只需处理空树（它是对称的）的情况，否则通过 `areMirrors(root.left, root.right)` 对其两个主子树启动递归检查。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass TreeNode:\n    \"\"\"\n    Represents a node in a binary tree.\n    \"\"\"\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef build_tree(level_order_list):\n    \"\"\"\n    Constructs a binary tree from a level-order list representation.\n    None indicates an absent node.\n    \"\"\"\n    if not level_order_list:\n        return None\n\n    root = TreeNode(level_order_list[0])\n    queue = [root]\n    i = 1\n    while queue and i  len(level_order_list):\n        current_node = queue.pop(0)\n\n        if i  len(level_order_list) and level_order_list[i] is not None:\n            current_node.left = TreeNode(level_order_list[i])\n            queue.append(current_node.left)\n        i += 1\n\n        if i  len(level_order_list) and level_order_list[i] is not None:\n            current_node.right = TreeNode(level_order_list[i])\n            queue.append(current_node.right)\n        i += 1\n\n    return root\n\ndef are_mirrors(node1, node2):\n    \"\"\"\n    Recursively checks if two trees are mirror images of each other.\n    \"\"\"\n    # Base case: both are null, they are mirrors.\n    if not node1 and not node2:\n        return True\n    \n    # Base case: one is null but the other isn't, not mirrors.\n    if not node1 or not node2:\n        return False\n    \n    # Recursive step: check values and mirrored subtrees.\n    return (node1.val == node2.val and\n            are_mirrors(node1.left, node2.right) and\n            are_mirrors(node1.right, node2.left))\n\ndef is_symmetric(root):\n    \"\"\"\n    Determines if a binary tree is symmetric around its root.\n    \"\"\"\n    # An empty tree is symmetric.\n    if not root:\n        return True\n    # A tree is symmetric if its left and right subtrees are mirror images.\n    return are_mirrors(root.left, root.right)\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        [],\n        [1],\n        [1, 2, 2, 3, 4, 4, 3],\n        [1, 2, 2, None, 3, None, 3],\n        [1, 2, 2, 3, None, None, 4],\n        [1, 2, 2, 3, 4, 4, 3, None, None, 5, 6, 6, 5, None, None],\n        [1, None, 2]\n    ]\n\n    results = []\n    for case in test_cases:\n        # Build the tree from the list representation.\n        root = build_tree(case)\n        # Check for symmetry and store the boolean result.\n        result = is_symmetric(root)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3216104"}, {"introduction": "现在，我们将注意力转向一种特殊的变体——二叉搜索树（BST）。二叉搜索树严格的排序属性是其关键优势，这使得其上的算法比通用树上的对应算法效率高得多。本练习要求你找到两个节点的最低公共祖先（LCA），这是一个经典问题，完美地展示了二叉搜索树属性的威力。你将开发一个迭代解法，通过一次遍历就找到LCA，从而展示有序结构如何直接引导搜索找到答案。[@problem_id:3216153]", "problem": "你的任务是在严格的额外空间限制下，计算二叉搜索树 (BST) 中两个节点的最近公共祖先 (LCA)。首先从基本定义开始：二叉搜索树 (BST) 是一种有根二叉树，其中对于每个键为 $k$ 的节点，其左子树中的所有键都严格小于 $k$，其右子树中的所有键都严格大于 $k$。对于有根树中的节点 $u$ 和 $v$，如果节点 $w$ 位于从根到 $u$ 的唯一简单路径上，则 $w$ 是 $u$ 的一个祖先。$u$ 和 $v$ 的最近公共祖先 (LCA) 是唯一的节点 $w$，该节点既是 $u$ 的祖先也是 $v$ 的祖先，并且没有后代同时是 $u$ 和 $v$ 的公共祖先。\n\n你的任务是实现一个算法，给定一个 BST 和两个目标键 $p$ 和 $q$，如果这两个键都存在于 BST 中，则返回它们 LCA 的键；否则，返回 $-1$。用于确定 LCA 的算法必须只使用 $O(1)$ 的额外空间运行，这意味着它不能使用递归或任何随输入规模扩展的辅助数据结构。存储树本身所需的内存不计入此额外空间限制。\n\nBST 的构建：对于每个测试用例，必须按照给定的顺序，使用标准的 BST 插入规则来构建 BST：小于节点键的键 $x$ 插入到左孩子，大于节点键的键 $x$ 插入到右孩子。\n\n存在性要求：如果键 $p$ 或 $q$ 中有任何一个不存在于 BST 中，你必须为该测试用例返回 $-1$。\n\n返回值：对于每个测试用例，返回一个整数：如果两个键都存在，则返回 LCA 的键，否则返回 $-1$。\n\n你必须实现一个完整、可运行的程序，该程序硬编码以下测试套件，按所述构建每个 BST，并为每个测试用例计算所需的结果：\n- 测试用例 $1$：插入顺序 $[20,10,30,5,15,25,35]$，查询 $(p,q)=(5,15)$。\n- 测试用例 $2$：插入顺序 $[20,10,30,5,15,25,35]$，查询 $(p,q)=(5,35)$。\n- 测试用例 $3$：插入顺序 $[20,10,30,5,15,25,35]$，查询 $(p,q)=(30,35)$。\n- 测试用例 $4$：插入顺序 $[8,3,10,1,6,14,4,7,13]$，查询 $(p,q)=(2,7)$。\n- 测试用例 $5$：插入顺序 $[1,2,3,4,5]$，查询 $(p,q)=(2,5)$。\n- 测试用例 $6$：插入顺序 $[5,4,3,2,1]$，查询 $(p,q)=(1,3)$。\n- 测试用例 $7$：插入顺序 $[42]$，查询 $(p,q)=(42,42)$。\n- 测试用例 $8$：插入顺序 $[42]$，查询 $(p,q)=(42,7)$。\n- 测试用例 $9$：插入顺序 $[10,5,15]$，查询 $(p,q)=(100,200)$。\n\n复杂度目标：对于高度为 $h$ 的树，LCA 计算应花费 $O(h)$ 的时间和 $O(1)$ 的额外空间。\n\n最终输出格式：你的程序应生成单行输出，其中包含九个测试用例的结果，格式为一个用方括号括起来且不含空格的逗号分隔列表，例如 $[r_1,r_2,\\dots,r_9]$，其中每个 $r_i$ 是如上所述的整数。\n\n无需读取任何输入。你的程序必须构建上述确切的测试套件，并以指定格式生成相应的输出。", "solution": "该问题要求我们在二叉搜索树 (BST) 中找到由其键 $p$ 和 $q$ 标识的两个节点的最近公共祖先 (LCA)。该解决方案的 LCA 查找部分受到 $O(1)$ 的严格空间复杂度限制。此外，算法必须首先验证键 $p$ 和 $q$ 是否都存在于树中；如果任何一个缺失，指定的返回值为 $-1$。\n\n该解决方案基于 BST 的基本属性开发，并针对每个测试用例分为三个逻辑阶段：BST 构建、节点存在性验证和 LCA 计算。\n\n**1. 二叉搜索树 (BST) 构建**\n\n根据问题描述，对于每个测试用例，通过插入给定的不同整数键序列来构建一个 BST。BST 是一种有根二叉树，对于任何键为 $k$ 的节点，其左子树中的所有键都严格小于 $k$，其右子树中的所有键都严格大于 $k$。使用迭代插入算法来构建树。对于要插入的每个键，我们从根节点开始遍历树，如果键小于当前节点的键则向左移动，如果大于则向右移动，直到找到一个可以连接新节点的空位（一个 `None` 子指针）。\n\n**2. 节点存在性验证**\n\n一个关键的预备步骤是确认指定的两个键 $p$ 和 $q$ 确实存在于构建的 BST 中。如果没有此检查，LCA 算法可能会为两个甚至不在树中的键返回一个“分裂点”节点，从而导致错误的结果。为了遵守空间复杂度约束并保持一致性，我们采用迭代搜索算法。从根节点开始，我们遵循 BST 属性遍历树。如果找到目标键，则搜索成功。如果到达一个 `None` 指针，则该键不在树中。对 $p$ 和 $q$ 都执行此搜索。如果任一搜索失败，则该测试用例的过程终止，并按要求返回数值 $-1$。对于每个键，此检查需要 $O(h)$ 的时间和 $O(1)$ 的额外空间，其中 $h$ 是树的高度。\n\n**3. 最近公共祖先 (LCA) 计算**\n\n如果确认键 $p$ 和 $q$ 都存在，我们就开始寻找它们的 LCA。BST 的有序性使得一个高效的、满足 $O(1)$ 额外空间约束的迭代算法成为可能。其逻辑的关键在于识别从根到 $p$ 和 $q$ 的路径发生分叉的节点。根据定义，这个分叉点就是 LCA。\n\n设当前正在检查的节点为 `current`，初始时设置为树的根节点。设其键为 $c$。迭代过程如下：\n\n- **情况 1：两个键都大于当前节点的键。**如果 $p  c$ 且 $q  c$，这意味着两个目标节点都必须位于 `current` 节点的右子树中。因此，它们的 LCA 也必定在右子树中。通过将 `current` 指针更新为其右孩子来缩小搜索范围：`current = current.right`。\n\n- **情况 2：两个键都小于当前节点的键。**如果 $p  c$ 且 $q  c$，则两个目标节点都在左子树中。它们的 LCA 也必定在左子树中。搜索从左孩子继续：`current = current.left`。\n\n- **情况 3：键在当前节点处分裂。**如果以上两个条件都不满足，这意味着 `current` 节点是从根开始的路径上第一个位于 $p$ 和 $q$ 之间（含 $p$ 和 $q$）的节点。这可能通过三种方式发生：\n    - $p  c$ 且 $q  c$（反之亦然），意味着到 $p$ 和 $q$ 的路径在 `current` 处分叉。\n    - $c = p$，意味着 `current` 节点是目标节点之一。由于 $q$ 存在于树中，它必然在 `current` 的一个子树中（或 $q=p$），这使得 `current` 成为 LCA。\n    - $c = q$，这与前一个子情况类似。\n\n在情况 3 的所有变体中，`current` 节点都是 LCA。循环终止，并返回 `current` 节点的键 $c$。\n\n该算法从根节点向下遍历一条单一路径。此路径的长度受树的高度 $h$ 限制，因此时间复杂度为 $O(h)$。由于该算法只需要一个指针 (`current`) 来遍历树，其额外空间复杂度为 $O(1)$，完全满足问题的约束。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the LCA in a BST problem for a hardcoded suite of test cases.\n    The solution follows these steps for each case:\n    1. Constructs the BST from a list of keys.\n    2. Verifies that both query keys, p and q, exist in the tree.\n    3. If they exist, it computes their LCA using an O(1) space iterative algorithm.\n    4. If either key is missing, it returns -1.\n    5. Collects all results and prints them in the specified format.\n    \"\"\"\n\n    class Node:\n        \"\"\"Represents a node in a Binary Search Tree.\"\"\"\n        def __init__(self, key):\n            self.key = int(key)\n            self.left = None\n            self.right = None\n\n    def build_bst(keys):\n        \"\"\"Constructs a BST by iteratively inserting keys.\"\"\"\n        if not keys:\n            return None\n        \n        root = Node(keys[0])\n        for key in keys[1:]:\n            current = root\n            while True:\n                if key  current.key:\n                    if current.left is None:\n                        current.left = Node(key)\n                        break\n                    else:\n                        current = current.left\n                elif key > current.key:\n                    if current.right is None:\n                        current.right = Node(key)\n                        break\n                    else:\n                        current = current.right\n        return root\n\n    def search_bst(root, key):\n        \"\"\"Iteratively searches for a key in the BST. O(1) space.\"\"\"\n        current = root\n        while current is not None:\n            if key == current.key:\n                return True\n            elif key  current.key:\n                current = current.left\n            else:\n                current = current.right\n        return False\n\n    def find_lca(root, p, q):\n        \"\"\"\n        Iteratively finds the LCA of two keys p and q in a BST. O(1) space.\n        This function assumes both p and q are present in the BST.\n        \"\"\"\n        current = root\n        while current is not None:\n            # If both p and q are greater than current node's key, LCA is in the right subtree\n            if p > current.key and q > current.key:\n                current = current.right\n            # If both p and q are smaller than current node's key, LCA is in the left subtree\n            elif p  current.key and q  current.key:\n                current = current.left\n            # Otherwise, this is the split point, so this node is the LCA.\n            # This covers cases where one key is on one side and the other is on the other,\n            # or when one of the keys is the current node.\n            else:\n                return current.key\n        return -1 # Should not be reached given presence check\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'keys': [20, 10, 30, 5, 15, 25, 35], 'pq': (5, 15)},\n        {'keys': [20, 10, 30, 5, 15, 25, 35], 'pq': (5, 35)},\n        {'keys': [20, 10, 30, 5, 15, 25, 35], 'pq': (30, 35)},\n        {'keys': [8, 3, 10, 1, 6, 14, 4, 7, 13], 'pq': (2, 7)},\n        {'keys': [1, 2, 3, 4, 5], 'pq': (2, 5)},\n        {'keys': [5, 4, 3, 2, 1], 'pq': (1, 3)},\n        {'keys': [42], 'pq': (42, 42)},\n        {'keys': [42], 'pq': (42, 7)},\n        {'keys': [10, 5, 15], 'pq': (100, 200)},\n    ]\n\n    results = []\n    for case in test_cases:\n        keys = case['keys']\n        p, q = case['pq']\n        \n        # 1. Construct the BST\n        root = build_bst(keys)\n        \n        # 2. Verify presence of both p and q\n        p_found = search_bst(root, p)\n        q_found = search_bst(root, q)\n        \n        if p_found and q_found:\n            # 3. If present, find the LCA\n            lca_key = find_lca(root, p, q)\n            results.append(lca_key)\n        else:\n            # 4. If either is not present, return -1\n            results.append(-1)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3216153"}, {"introduction": "在我们对二叉搜索树属性的理解基础上，这最后一个练习提出了一个更复杂的挑战，需要将数据结构知识与经典算法技巧相结合。你将在二叉搜索树中解决“两数之和”问题，但有一个关键的内存使用限制。这将引导你直接在树结构上模拟著名的双指针算法（通常用于已排序的数组），这为我们提供了一个如何调整算法以适应新数据结构并实现最优性能的绝佳范例。[@problem_id:3216226]", "problem": "给定一个存储整数键的有限有根二叉搜索树（BST），其中二叉搜索树（BST）的定义为：对于每个键为 $k$ 的节点，其左子树中的键严格小于 $k$，其右子树中的键大于或等于 $k$。键可能包含重复值。设 $X$ 为一个目标整数。任务是设计并实现一个程序，判断是否存在两个不同节点，其键之和等于 $X$。如果存在，则返回其中一对这样的键。如果存在多个有效的键对，任何一对都可以接受。如果不存在这样的键对，则返回一个空列表。\n\n您的推导和设计必须从以下基本原理出发：\n- 上文定义的二叉搜索树（BST）的排序属性。\n- 一个经过充分验证的事实是：对二叉搜索树（BST）进行中序遍历会得到一个非递减的键序列，而进行反向中序遍历会得到一个非递增的键序列。\n\n算法约束条件：\n- 对于一个有 $n$ 个节点的树，算法必须在 $\\mathcal{O}(n)$ 时间内运行。\n- 算法最多只能使用 $\\mathcal{O}(h)$ 的额外内存，其中 $h$ 是树的高度，并且不得将整棵树或其遍历结果物化为数组或列表。\n- 用于求和的两个节点必须是不同的；同一个节点不能被使用两次来求和得到 $X$（即使对于某个键 $k$ 有 $2 \\cdot k = X$）。\n\n您的程序应按照给定顺序插入键来构建二叉搜索树（BST），插入规则是：与节点键相等的键被插入到右子树中。对于每个测试用例，返回结果为以下两种形式之一：\n- 一个包含两个整数的列表 $[a,b]$，表示一个有效键对的键，满足 $a + b = X$ 且对应树中的两个不同节点，或者\n- 一个空列表 $[]$，如果不存在这样的键对。\n\n测试套件（每个测试用例是一个由插入序列和目标 $X$ 组成的对）：\n- 用例 $1$：插入序列 $\\langle 8,3,10,1,6,14,4,7,13\\rangle$，目标 $X = 17$。\n- 用例 $2$：插入序列 $\\langle -10,-3,0,5,9\\rangle$，目标 $X = -13$。\n- 用例 $3$：插入序列 $\\langle 5,5,3,7\\rangle$（存在重复值），目标 $X = 10$。\n- 用例 $4$：插入序列 $\\langle 2,1,4\\rangle$，目标 $X = 8$。\n- 用例 $5$：插入序列 $\\langle 42\\rangle$，目标 $X = 84$。\n- 用例 $6$：插入序列 $\\langle 1,2,3,4,5\\rangle$（退化的右偏树），目标 $X = 6$。\n- 用例 $7$：插入序列 $\\langle 5,3,7\\rangle$，目标 $X = 10$（测试当键只有一个实例时，禁止使用同一节点两次）。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含所有测试用例的结果，结果形式为一个由方括号括起来的逗号分隔列表。每个结果本身也必须是一个不带空格的方括号列表。例如，三个测试用例的有效输出应如下所示：$[[a,b],[],[c,d]]$。您的程序不得读取任何输入，并且必须按所列顺序使用上述测试套件。所有数值必须以十进制数字打印，不带额外空格。", "solution": "所述问题是有效的。这是一个在数据结构领域内定义明确的算法挑战，基于既有的计算机科学原理。它自成体系、无歧义，并且其约束条件虽然严格但可以解决。因此，我们可以着手进行解决方案的正式推导。\n\n**1. 基本原理：BST 遍历与有序序列**\n\n解决方案所基于的基本属性是 BST 与有序数据之间的关系。问题陈述正确地提供了这一基础：\n- 对 BST 进行中序遍历（左子树、根节点、右子树）会得到一个非递减排序的键序列。\n- 对 BST 进行反向中序遍历（右子树、根节点、左子树）会得到一个非递增排序的键序列。\n\n设中序遍历得到的键序列为 $S_{asc} = \\langle k_1, k_2, \\dots, k_n \\rangle$，其中 $k_i \\leq k_{i+1}$。我们的任务等价于找到两个对应不同节点的索引 $i$ 和 $j$，使得 $k_i + k_j = X$。\n\n**2. 对已排序数组使用双指针法**\n\n如果我们被允许使用 $\\mathcal{O}(n)$ 的空间，一个直接的解决方案是：\n1. 对 BST 进行中序遍历，并将所有 $n$ 个节点的键存储在一个数组中。这个数组将是非递减排序的。\n2. 使用“双指针”技术。初始化一个指针 `low` 指向数组的开头，一个指针 `high` 指向数组的末尾。\n3. 当 `low` 小于 `high` 时：\n    - 令当前和为 $S = \\text{array}[\\text{low}] + \\text{array}[\\text{high}]$。\n    - 如果 $S = X$，则找到了一个键对。\n    - 如果 $S  X$，和太小。为了增大它，我们必须选择一个更大的值，因此我们递增 `low`。\n    - 如果 $S  X$，和太大。为了减小它，我们必须选择一个更小的值，因此我们递减 `high`。\n\n该方法的时间复杂度为：遍历需要 $\\mathcal{O}(n)$，双指针扫描需要 $\\mathcal{O}(n)$，总共为 $\\mathcal{O}(n)$。然而，它需要 $\\mathcal{O}(n)$ 的空间来存储数组，这违反了 $\\mathcal{O}(h)$ 的空间约束。\n\n**3. 推导一个 $\\mathcal{O}(h)$ 空间复杂度的算法**\n\n为了满足 $\\mathcal{O}(h)$ 的空间约束，我们必须避免物化整个键序列。核心思想是在 BST 结构上直接模拟双指针方法。我们需要一种机制，能够按需获取“下一个”最小键和“下一个”最大键，而无需一次性处理整棵树。\n\n这一要求引出了两种有状态迭代器的设计：\n- 一个**中序迭代器**，每次请求时，它会产生非递减键序列中的下一个节点。\n- 一个**反向中序迭代器**，每次请求时，它会产生非递增键序列中的下一个节点。\n\nBST 的迭代遍历可以使用栈来实现。对于中序遍历，我们重复地将左子节点压入栈。当我们需要下一个项时，我们弹出一个节点，访问它，然后通过将其右子树的左侧链压入栈来处理其右子树。这个栈的最大深度对应于从根到叶子的最长路径，即树的高度 $h$。因此，一个基于栈的迭代器使用 $\\mathcal{O}(h)$ 的空间。同样的原理也适用于反向中序迭代器，它会优先压入右子节点。\n\n通过同时使用这两个迭代器，一个用于升序序列，一个用于降序序列，我们可以在遵守 $\\mathcal{O}(h)$ 空间限制的同时，完美地模拟双指针方法。\n\n**4. 算法设计与实现**\n\n算法流程如下：\n\n1.  **节点表示**：定义一个 `TreeNode` 类，包含一个整数键以及对左右子节点的引用。`TreeNode` 对象的身份将用于满足“不同节点”的约束。\n\n2.  **迭代器实现**：\n    - `InOrderIterator`：维护一个栈。在用根节点初始化时，它沿着树的左侧链向下遍历，将每个节点压入栈中。这使得迭代器准备好返回具有最小键的节点。`next()` 方法从栈中弹出一个节点（下一个中序节点），然后通过遍历弹出节点的右子树的左侧链为下一次调用做准备。\n    - `ReverseInOrderIterator`：其操作与 `InOrderIterator` 对称。在初始化时，它沿着右侧链向下遍历，压入节点，为产生最大键做准备。其 `next()` 方法弹出一个节点，然后通过遍历弹出节点的左子树的右侧链做准备。\n\n3.  **主控制循环**：\n    - 用 BST 的根节点初始化一个 `InOrderIterator` 实例和一个 `ReverseInOrderIterator` 实例。\n    - 从每个迭代器中获取第一个节点：`node_asc`（最小的）和 `node_desc`（最大的）。\n    - 进入一个循环，只要两个迭代器都能提供节点，并且它们指向的节点不是同一个对象（`node_asc is not node_desc`），循环就继续。这个条件对正确性至关重要，确保我们只考虑不同节点的对。\n    - 在循环内部：\n        a. 计算键的和：$S = \\text{node\\_asc.key} + \\text{node\\_desc.key}$。\n        b. 如果 $S = X$，我们找到了一个有效的键对。返回它们的键，例如 $[\\text{node\\_asc.key}, \\text{node\\_desc.key}]$。\n        c. 如果 $S  X$，我们需要一个更大的和。我们推进中序迭代器以获取下一个最小的键：`node_asc = iter_asc.next()`。\n        d. 如果 $S  X$，我们需要一个更小的和。我们推进反向中序迭代器以获取下一个最大的键：`node_desc = iter_desc.next()`。\n    - 如果循环终止时没有找到键对（原因可能是迭代器已经交错或在同一节点相遇），则不存在这样的键对。返回一个空列表。\n\n**5. 复杂度分析**\n\n- **时间复杂度**：每个迭代器都会遍历 BST 的边。在主循环中，每一步都恰好推进两个迭代器中的一个。由于迭代器从有序序列的两端开始并相互移动，树中的每个节点最多被一个前进的迭代器访问一次。在整个遍历过程中，`next()` 方法内部所做的工作，在摊销后，每个节点是常数时间。因此，总时间复杂度为 $\\mathcal{O}(n)$。\n\n- **空间复杂度**：该算法使用两个栈，每个迭代器一个。每个栈的最大大小受限于树的高度 $h$。因此，所需的总辅助空间为 $\\mathcal{O}(h) + \\mathcal{O}(h) = \\mathcal{O}(h)$。在一个平衡的 BST 中，$h = \\mathcal{O}(\\log n)$，而在一个退化（倾斜）的树中，$h = \\mathcal{O}(n)$。空间复杂度正确地遵守了指定的约束。\n\n此设计满足所有问题要求，在给定约束下提供了一个既正确又高效的解决方案。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass TreeNode:\n    \"\"\"\n    A node in a Binary Search Tree.\n    \"\"\"\n    def __init__(self, key):\n        self.key = int(key)\n        self.left = None\n        self.right = None\n\n    def __repr__(self):\n        return f\"TreeNode({self.key})\"\n\nclass BST:\n    \"\"\"\n    Binary Search Tree implementation with a specific insertion rule for duplicates.\n    \"\"\"\n    def __init__(self):\n        self.root = None\n\n    def insert(self, key):\n        \"\"\"\n        Inserts a key into the BST. If the key is = a node's key, it goes to the right.\n        \"\"\"\n        if self.root is None:\n            self.root = TreeNode(key)\n        else:\n            self._insert_recursive(self.root, key)\n    \n    def _insert_recursive(self, node, key):\n        if key  node.key:\n            if node.left is None:\n                node.left = TreeNode(key)\n            else:\n                self._insert_recursive(node.left, key)\n        else:  # key = node.key\n            if node.right is None:\n                node.right = TreeNode(key)\n            else:\n                self._insert_recursive(node.right, key)\n\n    @staticmethod\n    def from_sequence(sequence):\n        \"\"\"\n        Builds a BST from a sequence of keys.\n        \"\"\"\n        tree = BST()\n        for key in sequence:\n            tree.insert(key)\n        return tree.root\n\nclass InOrderIterator:\n    \"\"\"\n    An iterator that yields BST nodes in non-decreasing order of keys (in-order).\n    Uses O(h) space, where h is the tree height.\n    \"\"\"\n    def __init__(self, root):\n        self.stack = []\n        self._push_left_path(root)\n\n    def _push_left_path(self, node):\n        while node:\n            self.stack.append(node)\n            node = node.left\n\n    def next(self):\n        if not self.stack:\n            return None\n        node = self.stack.pop()\n        if node.right:\n            self._push_left_path(node.right)\n        return node\n\nclass ReverseInOrderIterator:\n    \"\"\"\n    An iterator that yields BST nodes in non-increasing order of keys (reverse in-order).\n    Uses O(h) space, where h is the tree height.\n    \"\"\"\n    def __init__(self, root):\n        self.stack = []\n        self._push_right_path(root)\n\n    def _push_right_path(self, node):\n        while node:\n            self.stack.append(node)\n            node = node.right\n\n    def next(self):\n        if not self.stack:\n            return None\n        node = self.stack.pop()\n        if node.left:\n            self._push_right_path(node.left)\n        return node\n\ndef find_two_sum_pair(root, target):\n    \"\"\"\n    Finds a pair of distinct nodes in a BST that sum to a target value.\n    \n    Args:\n        root: The root of the BST.\n        target: The target integer sum.\n\n    Returns:\n        A list [a, b] with the keys of the two nodes if found, otherwise an empty list.\n    \"\"\"\n    if not root:\n        return []\n\n    iter_asc = InOrderIterator(root)\n    iter_desc = ReverseInOrderIterator(root)\n\n    node_asc = iter_asc.next()\n    node_desc = iter_desc.next()\n\n    while node_asc and node_desc and node_asc is not node_desc:\n        current_sum = node_asc.key + node_desc.key\n        \n        if current_sum == target:\n            return [node_asc.key, node_desc.key]\n        elif current_sum  target:\n            node_asc = iter_asc.next()\n        else: # current_sum  target\n            node_desc = iter_desc.next()\n            \n    return []\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        ( (8, 3, 10, 1, 6, 14, 4, 7, 13), 17 ),\n        # Case 2\n        ( (-10, -3, 0, 5, 9), -13 ),\n        # Case 3\n        ( (5, 5, 3, 7), 10 ),\n        # Case 4\n        ( (2, 1, 4), 8 ),\n        # Case 5\n        ( (42,), 84 ),\n        # Case 6\n        ( (1, 2, 3, 4, 5), 6 ),\n        # Case 7\n        ( (5, 3, 7), 10 ),\n    ]\n\n    results = []\n    for sequence, target in test_cases:\n        root = BST.from_sequence(sequence)\n        result = find_two_sum_pair(root, target)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # e.g., [[3,14],[-10,-3],[3,7],[],[],[1,5],[3,7]]\n    # str(list) adds spaces, so we remove them.\n    formatted_results = [str(r).replace(\" \", \"\") for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3216226"}]}