{"hands_on_practices": [{"introduction": "理论是重要的，但通过实践来巩固理解更为关键。本节的第一个练习直面平衡二叉搜索树（BST）与非平衡二叉搜索树的核心差异。我们将通过一个具体的编程任务，将一个有序序列转化为两种截然不同的树结构：一个是因顺序插入而形成的“退化”的非平衡树，另一个则是结构最优的完美平衡树。这个练习不仅能够让你直观地看到树高对性能的巨大影响，还会引导你实现一个高效的 $O(N)$ 算法来构建平衡树，这本身就是对BST中序遍历特性的一次深刻应用([@problem_id:3213153])。", "problem": "给定一个已排序的双向链表（DLL），设计一个算法，在 $O(N)$ 时间和 $O(\\log N)$ 空间内将其转换为一个完全平衡的二叉搜索树（BST），其中 $N$ 是 DLL 中的节点数。仅使用二叉搜索树（BST）的结构特性和双向链表（DLL）的顺序排序。从以下基本原则出发：BST 的属性定义为，对于每个键为 $k$ 的节点，其左子树中的所有键都严格小于 $k$，其右子树中的所有键都严格大于 $k$；以及观察到 BST 的中序遍历会以严格递增的顺序访问键。\n\n定义和约束：\n- 输入序列是严格递增的整数序列，必须物化为已排序的 DLL，其中每个节点包含一个整数键以及指向前一个和后一个节点的指针。\n- 一个完全平衡的 BST 是指，对于每个节点，其左右子树的大小相差最多为 $1$。此属性意味着其高度在给定 $N$ 下可达到的最小高度范围内。\n- BST 的高度定义为从根到叶的最长路径上的边数。根据此定义，空树的高度为 $-1$，单节点树的高度为 $0$。\n\n您必须实现一个算法，在 $O(N)$ 时间和 $O(\\log N)$ 空间（以递归产生的辅助栈空间计算，忽略存储输出树本身所需的空间）内构建平衡 BST。此外，通过将相同的排序键逐个插入到初始为空的 BST 中，使用标准的 BST 插入方法构建一个非平衡 BST，这将产生一个退化（右偏）树。\n\n对于每个测试用例，计算并返回：\n- 平衡 BST 的整数高度。\n- 通过朴素的有序插入得到的非平衡 BST 的整数高度。\n- 一个布尔值，指示平衡 BST 是否同时满足两个条件：其中序遍历再现了原始排序序列，且其高度等于理论最小高度 $h_{\\min}(N) = \\lceil \\log_2(N+1) \\rceil - 1$。\n\n待使用的测试套件（每个描述的序列都是严格递增的）：\n- 案例 1：整数 -3,-2,-1,0,1,2,3。\n- 案例 2：空序列（即 $N = 0$）。\n- 案例 3：单个元素 42。\n- 案例 4：两个元素 5,10。\n- 案例 5：十个元素 -10,-5,0,5,9,12,13,14,15,20。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个元素对应一个测试用例，并且本身是一个形如 $[h_{\\text{balanced}}, h_{\\text{unbalanced}}, \\text{boolean}]$ 的列表。例如，两个测试用例的有效输出可能看起来像 $[[1,4,\\text{True}],[0,-1,\\text{False}]]$.", "solution": "解决此问题的关键在于利用二叉搜索树（BST）的中序遍历与其节点键值的有序性之间的内在联系。我们将对比几种方法，最终推导出满足 $O(N)$ 时间和 $O(\\log N)$ 空间复杂度的最优算法。\n\n#### 方法1：朴素的顺序插入\n\n最直接的方法是遍历已排序的链表，并将每个元素逐一插入到一个空的BST中。\n*   **过程**：从空树开始，插入第一个元素作为根。然后插入第二个元素，它将成为根的右子节点。第三个元素将成为第二个节点的右子节点，以此类推。\n*   **结果**：这将产生一个完全退化的、形如链表的“右偏”树。树的高度为 $N-1$。\n*   **复杂度**：第 $k$ 次插入操作需要 $O(k)$ 的时间。总时间复杂度为 $\\sum_{k=1}^{N} O(k) = O(N^2)$。这显然不满足效率要求。\n\n#### 方法2：递归分治（基于中位数）\n\n一个更优的方法是采用分治策略，这类似于将有序数组转换为平衡BST。\n*   **过程**：\n    1.  找到链表的中间节点。\n    2.  将该中间节点作为当前子树的根。\n    3.  递归地对根节点左侧的链表部分构建左子树。\n    4.  递归地对根节点右侧的链表部分构建右子树。\n*   **结果**：该方法能构建出高度平衡的BST。\n*   **复杂度**：对于数组，找到中位数是 $O(1)$ 操作，总时间是 $O(N)$。但对于链表，每次递归调用都需要 $O(N)$ 时间来遍历以找到中点。这导致总时间复杂度为 $O(N \\log N)$，仍然不满足 $O(N)$ 的要求。\n\n#### 方法3：中序遍历构建法（最优解）\n\n该方法巧妙地逆转了“BST的中序遍历产生有序序列”这一事实。我们不从中间向两边构建，而是按照中序遍历的顺序（左-根-右）来填充树。\n*   **核心思想**：如果我们知道一个子树需要多少个节点，我们就可以递归地为左子树分配节点，然后从链表中取出一个节点作为根，最后为右子树分配剩余的节点。\n*   **过程**：\n    1.  定义一个递归函数，它接收需要构建的节点数 $n$ 作为参数。\n    2.  递归调用该函数为左子树分配 $n_{\\text{left}} = \\lfloor n/2 \\rfloor$ 个节点。这将使链表指针前进 $n_{\\text{left}}$ 步。\n    3.  在左子树构建完成后，链表指针正好指向当前子树的根节点。创建根节点，并将链表指针前进一位。\n    4.  递归调用该函数为右子树分配 $n_{\\text{right}} = n - 1 - n_{\\text{left}}$ 个节点。\n*   **结果**：此方法构建的树是完全平衡的。\n*   **复杂度分析**：\n    *   **时间复杂度**：每个节点在链表中只被访问一次，在树中也只被创建一次。因此，总时间复杂度为 $O(N)$。\n    *   **空间复杂度**：递归栈的深度等于树的高度。对于一个平衡树，高度为 $O(\\log N)$。因此，空间复杂度为 $O(\\log N)$。\n\n这种中序构建法优雅地满足了所有约束条件，体现了对数据结构特性深刻理解的重要性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Define data structures for Doubly Linked List and Binary Search Tree nodes.\nclass DLLNode:\n    \"\"\"Node for a Doubly Linked List.\"\"\"\n    def __init__(self, data):\n        self.data = data\n        self.prev = None\n        self.next = None\n\nclass BSTNode:\n    \"\"\"Node for a Binary Search Tree.\"\"\"\n    def __init__(self, data):\n        self.data = data\n        self.left = None\n        self.right = None\n\n# ---- Helper Functions ----\n\ndef get_height(node):\n    \"\"\"\n    Computes the height of a tree based on the number of edges.\n    An empty tree has height -1, a single-node tree has height 0.\n    \"\"\"\n    if node is None:\n        return -1\n    return 1 + max(get_height(node.left), get_height(node.right))\n\ndef get_in_order(root):\n    \"\"\"Performs an in-order traversal of a BST and returns a list of keys.\"\"\"\n    result = []\n    if root:\n        result.extend(get_in_order(root.left))\n        result.append(root.data)\n        result.extend(get_in_order(root.right))\n    return result\n\n# ---- Core Algorithm for Balanced BST ----\n\ndef _sorted_list_to_bst(head_ref, n):\n    \"\"\"\n    Recursively constructs a perfectly balanced BST from a sorted DLL.\n    This function simulates an in-order traversal for construction.\n    `head_ref` is a list [node] acting as a mutable pointer to the DLL head.\n    `n` is the number of nodes to include in the current subtree.\n    \"\"\"\n    if n == 0:\n        return None\n\n    # 1. Recursively construct the left subtree. It will contain n // 2 nodes.\n    left_subtree = _sorted_list_to_bst(head_ref, n // 2)\n\n    # 2. After the left subtree is built, the current head_ref[0]\n    #    points to the element that should be the root of this subtree.\n    dll_node_for_root = head_ref[0]\n    root = BSTNode(dll_node_for_root.data)\n    root.left = left_subtree\n\n    # 3. Advance the DLL pointer for the next recursive calls.\n    head_ref[0] = dll_node_for_root.next\n\n    # 4. Recursively construct the right subtree. It contains the remaining nodes.\n    #    Size is n - (size of left subtree) - 1 (for the root).\n    right_subtree_size = n - (n // 2) - 1\n    root.right = _sorted_list_to_bst(head_ref, right_subtree_size)\n\n    return root\n\n# ---- Algorithm for Unbalanced BST ----\n\ndef insert_unbalanced(root, key):\n    \"\"\"\n    Standard BST insertion. If keys are inserted in sorted order,\n    this produces a degenerate (right-skewed) tree.\n    \"\"\"\n    if root is None:\n        return BSTNode(key)\n    if key  root.data:\n        root.left = insert_unbalanced(root.left, key)\n    elif key > root.data:\n        root.right = insert_unbalanced(root.right, key)\n    return root\n\n# ---- Main Solver ----\n\ndef solve():\n    \"\"\"\n    Main function to execute the problem logic for all test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: integers -3,-2,-1,0,1,2,3.\n        list(range(-3, 4)),\n        # Case 2: empty sequence.\n        [],\n        # Case 3: single element 42.\n        [42],\n        # Case 4: two elements 5,10.\n        [5, 10],\n        # Case 5: ten elements -10,-5,0,5,9,12,13,14,15,20.\n        [-10, -5, 0, 5, 9, 12, 13, 14, 15, 20],\n    ]\n\n    results = []\n    for sequence in test_cases:\n        n = len(sequence)\n\n        # 1. Materialize the sorted DLL from the input sequence\n        dll_head = None\n        if n > 0:\n            head_node = DLLNode(sequence[0])\n            current = head_node\n            for i in range(1, n):\n                new_node = DLLNode(sequence[i])\n                current.next = new_node\n                new_node.prev = current\n                current = new_node\n            dll_head = head_node\n\n        # 2. Construct the perfectly balanced BST\n        # Use a list to pass the head by reference, allowing modification\n        head_ref = [dll_head]\n        balanced_root = _sorted_list_to_bst(head_ref, n)\n        h_balanced = get_height(balanced_root)\n\n        # 3. Construct the unbalanced (degenerate) BST by sorted insertion\n        unbalanced_root = None\n        for key in sequence:\n            unbalanced_root = insert_unbalanced(unbalanced_root, key)\n        h_unbalanced = get_height(unbalanced_root)\n\n        # 4. Perform validation checks\n        if n == 0:\n            # For N=0, h_min is -1.\n            h_min = -1\n            # In-order of empty tree is empty list, matching empty sequence.\n            is_valid_construct = (h_balanced == h_min)\n        else:\n            # Theoretical minimal height for a BST with N nodes.\n            h_min = int(np.ceil(np.log2(n + 1)) - 1)\n            # Check 1: In-order traversal must reproduce the original sequence.\n            in_order_list = get_in_order(balanced_root)\n            in_order_matches = (in_order_list == sequence)\n            # Check 2: The height must be the theoretical minimum.\n            height_matches = (h_balanced == h_min)\n            is_valid_construct = in_order_matches and height_matches\n\n        results.append([h_balanced, h_unbalanced, is_valid_construct])\n\n    # Final print statement in the exact required format.\n    # The default str() for a list produces spaces, which is fine.\n    # The example [1,4,True] is just a textual representation.\n    # str([1, 4, True]) -> \"[1, 4, True]\"\n    print(f\"[{','.join(map(str, results))}]\".replace(\" \", \"\"))\n\n\nsolve()\n```", "id": "3213153"}, {"introduction": "在理解了“为什么”需要平衡之后，下一个自然的问题是“如何”维持平衡。AVL树通过旋转操作来自动维护其高度平衡的特性。这个练习是一个思想实验，旨在让你深入探索AVL树再平衡机制中最精妙的部分——双旋转。通过推导触发一次双旋转所需的最少节点数，你将不得不从平衡因子和子树高度等基本定义出发，精确地重现导致“左-右”或“右-左”失衡的临界状态。这项练习将极大地增强你对AVL树动态调整过程的直观理解([@problem_id:3213257])。", "problem": "考虑一个作为 Adelson-Velsky and Landis (AVL) 树维护的二叉搜索树 (BST)，其中空子树的高度定义为 $-1$，叶节点的高度为 $0$，对于任何节点 $v$，高度平衡因子定义为 $\\operatorname{bf}(v) = h(\\text{left}(v)) - h(\\text{right}(v))$。当 $|\\operatorname{bf}(v)| \\ge 2$ 时，发生 AVL 违规，而当第一个违反 AVL 平衡的节点 $z$ 满足 $\\operatorname{bf}(z) = 2$ 且其左子节点 $y$ 满足 $\\operatorname{bf}(y) = -1$（左-右情况）时，或当 $z$ 满足 $\\operatorname{bf}(z) = -2$ 且其右子节点 $y$ 满足 $\\operatorname{bf}(y) = +1$（右-左情况）时，恰好需要进行双旋转。\n\n从这些定义以及 BST 的插入机制（将新键作为叶子节点附加，同时保持中序顺序）出发，确定在一次插入操作强制引发 AVL 双旋转（左-右或右-左）之后，树中存在的不同节点的最小数量。选择最佳答案。\n\nA. $2$ 个节点\n\nB. $3$ 个节点\n\nC. $4$ 个节点\n\nD. $5$ 个节点", "solution": "用户希望我确定在一次需要进行双旋转的插入操作之后，AVL 树中的最小节点数。\n\n### 第一步：问题验证\n\n首先，我将验证问题陈述。\n\n**1. 提取已知条件：**\n- 数据结构：作为 Adelson-Velsky and Landis (AVL) 树维护的二叉搜索树 (BST)。\n- 高度定义：\n    - 空子树的高度为 $-1$。\n    - 叶节点的高度为 $0$。\n- 平衡因子：对于节点 $v$，平衡因子为 $\\operatorname{bf}(v) = h(\\text{left}(v)) - h(\\text{right}(v))$。\n- AVL 违规：如果 $|\\operatorname{bf}(v)| \\ge 2$，则节点 $v$ 处发生 AVL 违规。违规点被确定为插入节点的第一个（最接近插入点的）变得不平衡的祖先节点。\n- 双旋转条件：\n    - 左-右 (LR) 情况：当违规节点 $z$ 的平衡因子为 $\\operatorname{bf}(z) = 2$ 且其左子节点 $y$ 的平衡因子为 $\\operatorname{bf}(y) = -1$ 时发生。\n    - 右-左 (RL) 情况：当违规节点 $z$ 的平衡因子为 $\\operatorname{bf}(z) = -2$ 且其右子节点 $y$ 的平衡因子为 $\\operatorname{bf}(y) = +1$ 时发生。\n- 插入机制：新键作为新叶节点附加，保持 BST 的中序属性。\n- 问题：在一次强制引发双旋转的插入操作之后，整个树中不同节点的最小数量是多少？\n\n**2. 使用提取的已知条件进行验证：**\n问题陈述在科学上是合理的、定义明确且客观的。\n- **科学正确性：** AVL 树、高度、平衡因子以及双旋转的具体条件的定义是数据结构研究中的标准。将空子树的高度定义为 $-1$ 是一种常见的约定，它简化了叶节点高度的计算 ($h(\\text{leaf}) = \\max(-1, -1) + 1 = 0$)。\n- **完整性和一致性：** 问题提供了唯一确定双旋转条件所需的所有必要定义。整个设定是自洽的，没有歧义。\n- **适定性：** 问题要求在特定约束集下的最小值，这是 AVL 树形式系统内一个定义明确的优化问题。预期存在一个唯一的、最小的整数解。\n\n**3. 结论和行动：**\n问题是有效的。我将继续推导解决方案。\n\n### 第二步：解决方案的推导\n\n我们需要找到最小的 AVL 树，在插入单个节点后，它能满足双旋转的条件。我们来分析其中一种情况，即左-右 (LR) 双旋转。右-左 (RL) 情况是对称的，将得出相同的最小节点数。\n\n当一次插入导致节点 $z$ 的平衡因子变为 $\\operatorname{bf}(z) = 2$，并且其左子节点 $y$ 的平衡因子为 $\\operatorname{bf}(y) = -1$ 时，需要在节点 $z$ 处进行 LR 旋转。\n\n我们用撇号（例如 $h', \\operatorname{bf}'$）表示插入*前*树的状态，用不带撇号的符号表示插入*后*的状态。\n\n1.  **对节点 $z$ 的分析：** 一次插入最多使插入路径上的子树高度增加 $1$。要使 $\\operatorname{bf}(z)$ 变为 $2$，插入必须发生在 $z$ 的左子树中。在插入之前，该树是一个有效的 AVL 树，意味着对所有节点 $v$ 都有 $|\\operatorname{bf}'(v)| \\le 1$。因此，$z$ 的平衡因子必须是 $\\operatorname{bf}'(z) = 1$。插入操作使 $z$ 的左子树高度增加了 $1$，从而导致了违规。\n    - $\\operatorname{bf}'(z) = h'(\\text{left}(z)) - h'(\\text{right}(z)) = 1$。\n    - 插入后：$h(\\text{left}(z)) = h'(\\text{left}(z)) + 1$。右子树的高度不变，$h(\\text{right}(z)) = h'(\\text{right}(z))$。\n    - $\\operatorname{bf}(z) = h(\\text{left}(z)) - h(\\text{right}(z)) = (h'(\\text{left}(z)) + 1) - h'(\\text{right}(z)) = \\operatorname{bf}'(z) + 1 = 1 + 1 = 2$。\n\n2.  **对节点 $y$ 的分析：** 节点 $y$ 是 $z$ 的左子节点。LR 旋转的条件是插入后 $\\operatorname{bf}(y) = -1$。插入发生在 $y$ 的子树中。\n    - 要使 $\\operatorname{bf}(y) = h(\\text{left}(y)) - h(\\text{right}(y)) = -1$，插入必须增加了 $y$ 的右子树的高度。如果插入发生在左子树，$\\operatorname{bf}(y)$ 会变为正数（或者如果之前是 $-1$ 则保持为 $0$，但这将意味着 $y$ 已经不平衡了）。\n    - 所以，新节点被插入到 $y$ 的右子树中。在插入前，$h'(\\text{left}(y)) = h'(\\text{right}(y))$，这意味着 $\\operatorname{bf}'(y) = 0$。插入操作使 $h(\\text{right}(y))$ 增加了 $1$，导致 $\\operatorname{bf}(y) = -1$。\n\n3.  **构建最小树：** 我们需要找到在插入前最小的有效 AVL 树，该树中存在一个节点 $z$ 满足 $\\operatorname{bf}'(z)=1$，其左子节点 $y$ 满足 $\\operatorname{bf}'(y)=0$。为了最小化总节点数，我们必须最小化所有组成子树的高度。\n\n    - **插入前状态：**\n        - 为了用最少的节点满足 $\\operatorname{bf}'(y) = 0$，我们可以假设 $y$ 没有子节点。在这种情况下，它的左右子树都是空的，高度均为 $-1$。\n        - $h'(\\text{left}(y)) = -1$ 且 $h'(\\text{right}(y)) = -1$。\n        - 这使得 $y$ 成为一个叶节点，高度为 $h'(y) = \\max(-1, -1) + 1 = 0$。\n        - 其平衡因子为 $\\operatorname{bf}'(y) = -1 - (-1) = 0$。此条件得到满足。\n        - 现在来看节点 $z$。我们需要 $\\operatorname{bf}'(z) = 1$。由于 $y$ 是 $z$ 的左子节点，我们有 $h'(\\text{left}(z)) = h'(y) = 0$。\n        - 平衡因子方程为 $\\operatorname{bf}'(z) = h'(\\text{left}(z)) - h'(\\text{right}(z)) = 0 - h'(\\text{right}(z)) = 1$。\n        - 这意味着 $h'(\\text{right}(z)) = -1$，即 $z$ 没有右子节点。\n        - 因此，最小的插入前树由节点 $z$ 和其唯一的左子节点 $y$ 组成。这棵树有 $2$ 个节点。它是一个有效的 AVL 树，因为 $\\operatorname{bf}'(y)=0$ 且 $\\operatorname{bf}'(z)=1$。\n\n    - **插入操作：**\n        - 为了触发 LR 双旋转，我们必须将一个新节点（称之为 $x$）插入到 $y$ 的右子树中。\n        - 由于 $y$ 最初没有右子节点，$x$ 成为 $y$ 的右子节点。\n\n    - **插入后状态：**\n        - 最终的树由三个节点组成：$z$ 是根节点，$y$ 是 $z$ 的左子节点，$x$ 是 $y$ 的右子节点。\n        - 树中的总节点数为 $3$。\n        - 让我们验证最终状态下的平衡因子，以确认它会触发双旋转：\n            - 节点 $x$ 是一个叶节点：$h(x) = 0$。其平衡因子是 $\\operatorname{bf}(x) = -1 - (-1) = 0$。\n            - 节点 $y$：$h(\\text{left}(y)) = -1$，$h(\\text{right}(y)) = h(x) = 0$。\n              $\\operatorname{bf}(y) = h(\\text{left}(y)) - h(\\text{right}(y)) = -1 - 0 = -1$。这符合 LR 旋转的条件。\n            - 节点 $z$：$h(\\text{left}(z)) = h(y) = \\max(-1, 0)+1=1$。$h(\\text{right}(z)) = -1$。\n              $\\operatorname{bf}(z) = h(\\text{left}(z)) - h(\\text{right}(z)) = 1 - (-1) = 2$。这是 AVL 违规。\n\n由于我们有一个不平衡的节点 $z$（其 $\\operatorname{bf}(z)=2$）和它的左子节点 $y$（其 $\\operatorname{bf}(y)=-1$），因此需要进行 LR 双旋转。该树的结构恰好包含 $3$ 个节点。任何更少的节点数都无法产生高度为 $2$ 的树，而高度为 $2$ 是在根节点处产生高度差为 $2$ 的必要条件。因此，$3$ 是最小的节点数。\n\n### 第三步：逐项分析\n\n- **A. $2$ 个节点：** 错误。一次插入后，树至少有 $2$ 个节点。一个 $2$ 节点的树由一个根和一个子节点组成，形成一条长度为 $1$ 的路径。其高度为 $1$。根节点的平衡因子为 $1$ 或 $-1$。不可能发生 AVL 违规。要达到 $\\pm 2$ 的平衡因子，树的高度必须至少为 $2$，这至少需要 $3$ 个节点。\n\n- **B. $3$ 个节点：** 正确。如上所述，一个具有 $3$ 个节点并排列成“之”字形路径的树，是在插入第三个节点后触发双旋转的最小配置。具体来说，从一个 2 节点树（根节点 $z$ 和左子节点 $y$）开始，将第三个节点 $x$ 作为 $y$ 的右子节点插入，会得到一个需要左-右双旋转的 3 节点树。\n\n- **C. $4$ 个节点：** 错误。虽然可以构建需要双旋转的更大的树，但问题要求的是最小节点数。既然存在一个有 $3$ 个节点的配置，$4$ 不可能是最小值。\n\n- **D. $5$ 个节点：** 错误。与选项 C 类似，这不可能是最小节点数，因为一个更小的有 $3$ 个节点的配置满足了问题的条件。", "answer": "$$\\boxed{B}$$", "id": "3213257"}, {"introduction": "最后一个练习将挑战你综合运用所学知识解决一个更实际的优化问题。想象一下，你面对一个已存在的、任意形状的非平衡BST，并希望通过一次局部调整来最大程度地改善其整体性能。这个任务要求你设计一个高效算法，在树中找到能够最大程度降低树高的那一次“最佳”单旋转([@problem_id:3213120])。要满足 $O(n)$ 的时间复杂度要求，你需要超越简单的暴力模拟，通过精巧的多趟树遍历来预计算必要信息，从而在常数时间内评估每次旋转的全局影响。这个练习是连接非平衡BST和自平衡BST概念的桥梁，也是对树算法和动态规划思想的一次绝佳实践。", "problem": "给定一种抽象数据类型——二叉搜索树（BST），它是一种有根的、有序的二叉树，每个节点上都有一个唯一的键，并满足二叉搜索树属性：对于任意一个键为 $k$ 的节点，其左子树中的每个键都严格小于 $k$，其右子树中的每个键都严格大于 $k$。树的高度定义为从根到任意叶子的最长向下路径上的边数。单次旋转是在一个节点上进行的局部变换，它保持BST属性并按如下方式重构树：在具有非空左子节点的节点上进行右旋，会将其左子节点向上移动，并将该节点向下移动到右侧；在具有非空右子节点的节点上进行左旋，会将其右子节点向上移动，并将该节点向下移动到左侧。\n\n从二叉搜索树、树高和单次旋转的核心定义出发，设计一个算法，给定一个不平衡的BST，找到在任意节点上进行的单次旋转（左旋或右旋），该旋转能产生最大的树整体高度的即时减少量。如果多个旋转产生相同的最大减少量，则通过选择最小节点键处的旋转来打破平局；如果仍在同一节点上平局，则优先选择右旋而非左旋。如果没有旋转能严格减小高度，则返回不存在可改进的旋转。\n\n您的程序必须实现这个推导过程，并为每个提供的测试树计算以下内容：\n- 树的原始高度 $H$。\n- 对于节点 $v$ 上的每个候选旋转，在 $v$ 处执行且仅执行该单次旋转后的新高度 $H_{\\text{new}}$。\n- 根据指定的平局打破规则，最佳旋转的即时高度改进量 $\\Delta = H - H_{\\text{new}}$。\n\n为了报告，使用以下整数方向代码对所选的旋转进行编码：\n- $0$ 代表右旋，\n- $1$ 代表左旋，\n- $-1$ 代表没有旋转能带来严格改进（在这种情况下，也将节点键报告为 $-1$，改进量报告为 $0$）。\n\n您的程序必须是自包含的，并且不能读取任何输入。它应该为以下BST测试套件计算结果，每个测试套件都以三元组 $(k,\\ell,r)$ 的列表形式给出，其中 $k$ 是节点键，$\\ell$ 是左子节点键（如果缺失则为 $None$），$r$ 是右子节点键（如果缺失则为 $None$）。所有键都是不同的整数。\n\n测试套件：\n- 案例 $1$ (平衡): $\\{(30,20,40),(20,10,25),(10,None,None),(25,None,None),(40,35,50),(35,None,None),(50,None,None)\\}$。\n- 案例 $2$ (单节点): $\\{(10,None,None)\\}$。\n- 案例 $3$ (右偏链): $\\{(1,None,2),(2,None,3),(3,None,4),(4,None,5),(5,None,None)\\}$。\n- 案例 $4$ (左偏链): $\\{(6,5,None),(5,4,None),(4,3,None),(3,2,None),(2,1,None),(1,None,None)\\}$。\n- 案例 $5$ (混合不平衡): $\\{(50,30,70),(30,20,None),(20,10,None),(10,None,None),(70,60,None),(60,None,None)\\}$。\n\n要求的最终输出格式：\n- 您的程序应生成一行输出，其中包含测试套件的结果，形式为一个用方括号括起来的逗号分隔列表。每个测试用例的结果本身必须是 $[\\Delta, k^\\ast, d]$ 形式的三个整数的列表，其中 $\\Delta$ 是最大的即时高度减少量，$k^\\ast$ 是旋转节点的键（如果没有则为 $-1$），$d$ 是方向代码（$0$ 代表右旋，$1$ 代表左旋，$-1$ 代表没有）。例如，一个有效的整体输出可能看起来像 $[[1,10,0],[0,-1,-1],\\dots]$。\n\n约束和期望：\n- 从BST、树高和单次旋转的基本定义推导您的算法，而不是将快捷公式作为已知事实来使用。\n- 对于一个有 $n$ 个节点的树，您的算法必须在 $O(n)$ 时间内运行，并使用 $O(n)$ 的辅助空间。\n- 高度必须以边数而非节点数来衡量；确保全程保持一致。", "solution": "问题要求我们在给定的二叉搜索树（BST）中找到一次单独的旋转（左旋或右旋），以实现树高度的最大可能即时减少。我们必须遵守特定的平局打破规则，并在一个有 $n$ 个节点的树上，以 $O(n)$ 的时间复杂度和 $O(n)$ 的空间复杂度运行。\n\n首先，我们形式化基本定义。BST是一个有根二叉树，对于任何键为 $k$ 的节点，其左子树中的所有键都小于 $k$，右子树中的所有键都大于 $k$。树的高度，记为 $H$，是从根到任意叶节点的最长路径上的边数。这等同于树中任意叶节点的最大深度，其中根的深度为 $0$。单次旋转是一种局部变换，它在保持BST性质的同时重构树的结构。在节点 $v$（其左子节点 $L$ 非空）处进行右旋，会使 $L$ 成为局部子树的新根，而 $v$ 成为 $L$ 的右子节点。对称地，在 $v$（其右子节点 $R$ 非空）处进行左旋，会使 $R$ 成为新根，而 $v$ 成为 $R$ 的左子节点。\n\n一个直接但效率低下的方法是遍历每一种可能的旋转，执行它，从头重新计算整个树的高度，并记录改进量。计算一个有 $n$ 个节点的树的高度需要 $O(n)$ 的时间。由于有 $O(n)$ 种可能的旋转（每个节点最多两种），这种朴素方法的时间复杂度为 $O(n^2)$，这违反了所述的约束，特别是对于倾斜树。\n\n为了实现 $O(n)$ 的解决方案，我们必须能够在 $O(n)$ 的预处理阶段之后，在 $O(1)$ 时间内计算出假设旋转后树的新高度。关键的洞见在于分析一次旋转如何影响所有叶节点的深度，因为树的高度是所有叶子中的最大深度。\n\n节点 $v$ 处的旋转是一个局部变化，但它会系统地改变特定子树内所有节点的深度。考虑在节点 $v$（其左子节点为 $L$）处进行右旋。节点 $L$ 向上移动到 $v$ 的位置，而 $v$ 向下移动成为 $L$ 的右子节点。这对节点深度有以下影响：\n1.  $L$ 的左子树（$LL$）中的所有节点都向上移动一层，因此它们的深度减少 $1$。\n2.  $L$ 的右子树（$LR$）和 $v$ 的右子树（$vR$）中的所有节点都向下移动一层，因此它们的深度增加 $1$。\n3.  所有在 $v$ 原始子树之外的节点的深度保持不变。\n\n树的新高度 $H_{\\text{new}}$ 将是这些变化后任意叶子的最大深度。这可以表示为：\n$$H_{\\text{new}} = \\max(\\text{未受影响叶子的最大深度, 变化后受影响叶子的最大深度})$$\n\n这表明可以基于一种算法，该算法预先计算所有必要信息，以便为每个潜在的旋转在 $O(1)$ 时间内应用此公式。\n\n**$O(n)$ 算法：**\n\n**1. 预处理（$O(n)$ 时间，$O(n)$ 空间）：**\n我们对树进行三次遍历，以收集每个节点 $v$ 的数据。我们构建带有父指针的树，以方便遍历。\n- **第一次遍历：后序遍历。** 对每个节点 $v$，我们计算以 $v$ 为根的子树的高度，记为 $h(v)$。这可以递归地定义为 $h(v) = 1 + \\max(h(v.\\text{left}), h(v.\\text{right}))$，其中空子节点的高度为 $-1$。\n- **第二次遍历：前序遍历。** 对每个节点 $v$，我们计算它的深度 $d(v)$，其中 $d(\\text{root}) = 0$，且 $d(\\text{child}) = d(\\text{parent}) + 1$。\n- **第三次遍历：前序遍历。** 对每个节点 $v$，我们计算位于 $v$ 子树*之外*的任意叶节点的最大深度。我们称之为 `max_depth_outside(v)`。这可以通过从父节点向下传递信息来计算。对于一个节点 $v$，一个外部叶子要么在其父节点 $p$ 的子树之外，要么在 $v$ 的兄弟节点的子树中。因此，`max_depth_outside(v)` 是 `max_depth_outside(p)` 和兄弟子树中最大叶子深度的最大值。以节点 $u$ 为根的子树中叶子的最大深度是 $d(u) + h(u)$。\n\n**2. 分析（$O(n)$ 时间）：**\n有了这些预先计算好的值，我们遍历所有节点 $v$（按键排序以处理平局），并评估每个可能的旋转。原始高度为 $H_{\\text{orig}} = h(\\text{root})$。\n\n对于一个候选旋转，我们在 $O(1)$ 时间内计算新的树高 $H_{\\text{new}}$：\n- 未受影响叶子的最大深度恰好是 `max_depth_outside(v)`。\n- 受影响子树（例如，右旋时的 $LL$）内叶子的新最大深度是其原始最大深度加上深度变化（即 $(d(LL) + h(LL)) - 1$）。\n- 如果被旋转的节点 $v$ 本身成为一个叶子，会出现一种特殊情况。例如，在 $v$ 处进行左旋，如果 $v$ 没有左子节点，且其右子节点 $R$ 没有左子节点，就会发生这种情况。$v$ 的新深度将是 $d(v) + 1$。\n\n在 $v$（其右子节点为 $R$）处进行**左旋**后，$H_{\\text{new}}$ 的完整公式是：\n$H_{\\text{new}} = \\max(\\text{max\\_depth\\_outside}(v), \\text{term}_{vL}, \\text{term}_{RL}, \\text{term}_{RR}, \\text{term}_{\\text{new\\_leaf}})$\n其中：\n- 如果 $v$ 的左子节点 $vL$ 存在，则 $\\text{term}_{vL} = (d(vL) + h(vL)) + 1$。\n- 如果 $R$ 的左子节点 $RL$ 存在，则 $\\text{term}_{RL} = (d(RL) + h(RL)) + 1$。\n- 如果 $R$ 的右子节点 $RR$ 存在，则 $\\text{term}_{RR} = (d(RR) + h(RR)) - 1$。\n- 如果 $v$ 成为叶子，则 $\\text{term}_{\\text{new_leaf}} = d(v) + 1$，否则为 $-1$。\n\n一个对称的公式适用于右旋。我们计算高度改进量 $\\Delta = H_{\\text{orig}} - H_{\\text{new}}$。我们跟踪产生最大 $\\Delta > 0$ 的旋转，使用指定的平局打破规则（最小节点键，然后优先右旋），这通过按键递增顺序迭代节点并在检查左旋候选之前检查右旋候选来自然处理。如果没有旋转产生 $\\Delta > 0$，我们报告不存在改进。这种全面的方法满足所有问题约束。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport sys\n\n# The default recursion limit may be too low for skewed trees.\nsys.setrecursionlimit(2000)\n\nclass Node:\n    \"\"\"Represents a node in the BST.\"\"\"\n    def __init__(self, key):\n        self.key = int(key)\n        self.left = None\n        self.right = None\n        self.parent = None\n        self.h = -1  # Height of the subtree rooted at this node\n        self.d = -1  # Depth of this node\n        self.max_depth_outside = -1  # Max depth of a leaf outside this node's subtree\n\ndef build_tree(tree_data):\n    \"\"\"Builds the tree from a list of triples and returns the root and a node map.\"\"\"\n    if not tree_data:\n        return None, {}\n    \n    nodes = {int(k): Node(k) for k, _, _ in tree_data}\n    \n    # Identify the root by finding the only node that is never a child.\n    child_keys = set()\n    for _, left_key, right_key in tree_data:\n        if left_key is not None:\n            child_keys.add(int(left_key))\n        if right_key is not None:\n            child_keys.add(int(right_key))\n            \n    root_key = (set(nodes.keys()) - child_keys).pop()\n    root = nodes[root_key]\n\n    for key, left_key, right_key in tree_data:\n        node = nodes[int(key)]\n        if left_key is not None:\n            node.left = nodes[int(left_key)]\n            node.left.parent = node\n        if right_key is not None:\n            node.right = nodes[int(right_key)]\n            node.right.parent = node\n            \n    return root, nodes\n\ndef compute_heights(node):\n    \"\"\"Pass 1 (Post-order): Computes subtree height for each node.\"\"\"\n    if node is None:\n        return -1\n    h_left = compute_heights(node.left)\n    h_right = compute_heights(node.right)\n    node.h = 1 + max(h_left, h_right)\n    return node.h\n\ndef compute_depths(node, current_depth):\n    \"\"\"Pass 2 (Pre-order): Computes depth for each node.\"\"\"\n    if node is None:\n        return\n    node.d = current_depth\n    compute_depths(node.left, current_depth + 1)\n    compute_depths(node.right, current_depth + 1)\n\ndef get_max_depth_in_subtree(node):\n    \"\"\"Helper to get max leaf depth within a subtree, using pre-calculated values.\"\"\"\n    if node is None:\n        return -1\n    return node.d + node.h\n\ndef compute_max_depth_outside(node, parent_max_depth):\n    \"\"\"Pass 3 (Pre-order): Computes max leaf depth outside each node's subtree.\"\"\"\n    if node is None:\n        return\n    \n    node.max_depth_outside = parent_max_depth\n    \n    max_d_in_left_sibling = get_max_depth_in_subtree(node.left)\n    max_d_in_right_sibling = get_max_depth_in_subtree(node.right)\n    \n    compute_max_depth_outside(node.left, max(parent_max_depth, max_d_in_right_sibling))\n    compute_max_depth_outside(node.right, max(parent_max_depth, max_d_in_left_sibling))\n\ndef analyze_tree(tree_data):\n    \"\"\"Main logic for a single test case.\"\"\"\n    if not tree_data:\n        return [0, -1, -1]\n\n    root, nodes_map = build_tree(tree_data)\n    if not root:\n         return [0, -1, -1]\n         \n    # Preprocessing passes\n    compute_heights(root)\n    compute_depths(root, 0)\n    compute_max_depth_outside(root, -1)\n\n    original_height = root.h\n    best_delta = 0\n    best_key = -1\n    best_dir = -1\n\n    # Analysis pass: Iterate through nodes sorted by key for tie-breaking\n    sorted_nodes = sorted(nodes_map.values(), key=lambda n: n.key)\n\n    for v in sorted_nodes:\n        # Candidate 1: Right Rotation (direction code 0)\n        if v.left is not None:\n            L = v.left\n            \n            # Max depths in affected subtrees (original values)\n            md_LL = get_max_depth_in_subtree(L.left)\n            md_LR = get_max_depth_in_subtree(L.right)\n            md_vR = get_max_depth_in_subtree(v.right)\n            \n            # New max depths after depth changes (+/- 1)\n            new_md_LL = md_LL - 1 if md_LL != -1 else -1\n            new_md_LR = md_LR + 1 if md_LR != -1 else -1\n            new_md_vR = md_vR + 1 if md_vR != -1 else -1\n\n            # Check if v becomes a new leaf\n            new_leaf_term = -1\n            if v.right is None and L.right is None:\n                new_leaf_term = v.d + 1\n            \n            new_height = max(v.max_depth_outside, new_md_LL, new_md_LR, new_md_vR, new_leaf_term)\n            delta = original_height - new_height\n\n            if delta > best_delta:\n                best_delta = delta\n                best_key = v.key\n                best_dir = 0\n\n        # Candidate 2: Left Rotation (direction code 1)\n        if v.right is not None:\n            R = v.right\n\n            md_vL = get_max_depth_in_subtree(v.left)\n            md_RL = get_max_depth_in_subtree(R.left)\n            md_RR = get_max_depth_in_subtree(R.right)\n            \n            new_md_vL = md_vL + 1 if md_vL != -1 else -1\n            new_md_RL = md_RL + 1 if md_RL != -1 else -1\n            new_md_RR = md_RR - 1 if md_RR != -1 else -1\n\n            new_leaf_term = -1\n            if v.left is None and R.left is None:\n                new_leaf_term = v.d + 1\n\n            new_height = max(v.max_depth_outside, new_md_vL, new_md_RL, new_md_RR, new_leaf_term)\n            delta = original_height - new_height\n            \n            if delta > best_delta:\n                best_delta = delta\n                best_key = v.key\n                best_dir = 1\n\n    return [best_delta, best_key, best_dir]\n\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: balanced\n        [(30, 20, 40), (20, 10, 25), (10, None, None), (25, None, None), (40, 35, 50), (35, None, None), (50, None, None)],\n        # Case 2: single node\n        [(10, None, None)],\n        # Case 3: right-skewed chain\n        [(1, None, 2), (2, None, 3), (3, None, 4), (4, None, 5), (5, None, None)],\n        # Case 4: left-skewed chain\n        [(6, 5, None), (5, 4, None), (4, 3, None), (3, 2, None), (2, 1, None), (1, None, None)],\n        # Case 5: mixed unbalanced\n        [(50, 30, 70), (30, 20, None), (20, 10, None), (10, None, None), (70, 60, None), (60, None, None)]\n    ]\n\n    results = []\n    for case in test_cases:\n        result = analyze_tree(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # Convert each inner list to a string representation without spaces.\n    result_strings = [f\"[{','.join(map(str, res))}]\" for res in results]\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```", "id": "3213120"}]}