## 引言
“换零钱”与“完全背包”问题是算法设计领域，尤其是动态规划[范式](@entry_id:161181)中的两大基石。它们表面上描述着不同的场景——从日常的货币兑换到抽象的资源分配——但其底层共享着一个深刻的数学结构：如何在拥有无限资源的物品中进行选择，以实现某个最优目标或计算所有可能的方案。许多初学者在面对这类问题时，往往难以识别其共性，或在不同的问题变体（如求最优解、求组[合数](@entry_id:263553)）之间建立联系，这正是本文旨在解决的知识鸿沟。

通过本文的学习，你将系统地掌握解决这类问题的通用框架。我们将从第一章“原理与机制”出发，深入剖析动态规划如何应用于最优化（如最小化硬币数、最大化价值）和计数（区分[排列与组合](@entry_id:167538)）问题，并揭示状态[转移方程](@entry_id:160254)背后的逻辑。接着，在第二章“应用与跨学科联系”中，我们将视野拓宽到计算机科学、[计算生物学](@entry_id:146988)、经济学等多个领域，展示这些抽象模型如何解决现实世界中的复杂挑战。最后，在第三章“动手实践”部分，你将通过一系列精心设计的编程练习，将理论知识转化为解决实际问题的能力。本文将引导你从基础原理走向高级应用，最终建立起对[组合优化](@entry_id:264983)问题的深刻洞察力。

## 原理与机制

动态规划（Dynamic Programming, DP）是解决一类具有**[最优子结构](@entry_id:637077) (optimal substructure)** 和**[重叠子问题](@entry_id:637085) (overlapping subproblems)** 特性的[优化问题](@entry_id:266749)和计数问题的强大[范式](@entry_id:161181)。本章将深入探讨动态规划在“换零钱”与“完全背包”这两类典型问题中的应用。这些问题虽然表述各异——从金融决策到游戏得分——但其核心都围绕着在无限供应的物品中进行选择，以达成某个目标。我们将从基本原理出发，系统地构建解决这些问题的算法框架，并探讨其在各种约束下的扩展与变形。

### 完全背包问题的核心思想

与每个物品只能选择一次的 0/1 背包问题不同，**完全背包问题 (Unbounded Knapsack Problem)** 的核心特征是每种物品都有无限的供应量。这意味着我们可以任意多次地选取同一种物品。这一特性改变了问题的结构，也相应地调整了动态规划的求解策略。

根据目标的不同，完全[背包问题](@entry_id:272416)可以分为三大基本类型：

1.  **最[优化问题](@entry_id:266749)**：在满足约束（例如，总重量不超过背包容量）的前提下，最大化或最小化某个目标函数（例如，总价值或物品总数）。
2.  **计数问题**：计算满足特定约束的组合或[排列](@entry_id:136432)总数。
3.  **存在性问题**：判断是否存在一种合法的选择方案。

我们将通过动态规划来逐一解决这些问题。动态规划的精髓在于将一个大[问题分解](@entry_id:272624)为若干个相互关联的子问题，并通过存储子问题的解来避免重复计算。这个存储解的表格，我们通常称之为 DP 表。

### 最[优化问题](@entry_id:266749)：最大化价值与最小化成本

最优化是完全背包问题最常见的应用场景。我们将探讨两种经典的最优化目标：最大化总价值和最小化物品数量。

#### 最大化价值：经典完全背包问题

考虑一个典型的场景：一位策略投资者（或赌徒）拥有一笔总资金 $W$，并有多种投资选项。每种选项 $i$ 需要 $w_i$ 的成本，并能产生 $v_i$ 的回报。投资者可以无限次地投资任何一个选项。目标是在总成本不超过 $W$ 的前提下，最大化总回报。[@problem_id:3221735]

这个问题可以被精确地建模为完全背包问题。在这里，资金 $W$ 是背包的**容量**，每个投资选项的成本 $w_i$ 是物品的**重量**，回报 $v_i$ 则是物品的**价值**。由于每个选项可以被多次选择，这是一个典型的无限供应场景。

为了解决这个问题，我们定义一个状态 $dp[c]$，表示当背包容量为 $c$ 时，可以获得的最大总价值。我们的最终目标是求解 $dp[W]$。

状态的**基本情况 (base case)** 是显而易见的：当容量为 0 时，我们什么也装不下，所以最大价值为 0。即 $dp[0] = 0$。

接下来，我们构建**状态[转移方程](@entry_id:160254) (recurrence relation)**。为了计算 $dp[c]$，我们考虑所有可能放入背包的物品。假设我们决定放入一个物品 $i$（重量为 $w_i$，价值为 $v_i$），前提是 $c \ge w_i$。如果这么做，背包的剩余容量就变成了 $c - w_i$，而我们已经获得了 $v_i$ 的价值。根据[最优子结构](@entry_id:637077)原理，此时我们应该已经在容量为 $c - w_i$ 的背包里实现了最大价值，即 $dp[c - w_i]$。因此，通过放入物品 $i$，我们能达到的总价值是 $v_i + dp[c - w_i]$。

由于我们可以选择放入任何一个满足 $w_i \le c$ 的物品 $i$，我们应该遍历所有这些可能性，并选择能使总价值最大的那一个。因此，状态[转移方程](@entry_id:160254)为：
$$
dp[c] = \max_{i: w_i \le c} \{ v_i + dp[c - w_i] \}
$$
这个方程精确地描述了如何从子问题的解构建出当前问题的解。在实现时，我们通常采用**自底向上 (bottom-up)** 的方法，从 $c=1$ 开始，依次计算到 $c=W$。

算法流程如下：
1.  创建一个大小为 $W+1$ 的一维数组 $dp$，并初始化所有元素为 0。$dp[0]$ 自然为 0。
2.  遍历所有容量 $c$ 从 1 到 $W$。
3.  对于每个容量 $c$，再次遍历所有物品种类 $i$。
4.  如果物品 $i$ 的重量 $w_i$ 不超过当前容量 $c$ (即 $w_i \le c$)，则我们考虑选择该物品。更新 $dp[c]$：
    $$
    dp[c] = \max(dp[c], v_i + dp[c - w_i])
    $$
    这里的 $dp[c]$ 在更新前的值，代表了不选择物品 $i$ 来作为“最后一个物品”时的最大价值。通过这个比较，我们确保了 $dp[c]$ 始终存储着当前容量下的最优解。

完成所有迭代后，$dp[W]$ 就是我们寻求的最大总价值。这种实现方式的[时间复杂度](@entry_id:145062)为 $O(n \cdot W)$，[空间复杂度](@entry_id:136795)为 $O(W)$，其中 $n$ 是物品的种类数。

#### 最小化数量：经典换零钱问题

另一个常见的优化目标是最小化组成某个总额所需的物品数量。这通常被称为**换零钱问题 (Coin Change Problem)**。给定一组面额 $S = \{s_1, s_2, \ldots, s_k\}$ 的硬币和目标总额 $N$，我们需要找到凑成 $N$ 所需的最少硬币数量。[@problem_id:3221780]

这个问题同样可以用动态规划解决。我们定义状态 $dp[a]$ 为凑成总额 $a$ 所需的**最少硬币数**。我们的目标是 $dp[N]$。

基本情况是 $dp[0] = 0$，因为凑成 0 元需要 0 个硬币。对于所有其他总额 $a > 0$，我们可以将它们的初始值设为一个象征无穷大的数（例如 $\infty$），表示在没有进行任何操作前，这些总额是无法凑成的。

状态[转移方程](@entry_id:160254)的推导与最大化价值问题类似。为了凑成总额 $a$，我们必然使用了某一枚硬币作为“最后一枚硬币”。假设这枚硬币的面额是 $s_i$ (其中 $s_i \le a$)。那么，在放入这枚硬币之前，我们必须已经用最少的硬币凑成了总额 $a - s_i$。因此，通过使用硬币 $s_i$，总硬币数将是 $1 + dp[a - s_i]$。

为了找到凑成 $a$ 的全局最优解，我们必须遍历所有可能的“最后一枚硬币” $s_i$，并选择总数最小的那个。由此，我们得到状态[转移方程](@entry_id:160254)：
$$
dp[a] = \min_{s_i \in S, a \ge s_i} \{ 1 + dp[a - s_i] \}
$$
如果对于某个总额 $a$，没有任何一个 $s_i$ 能够从一个[可达状态](@entry_id:265999) $dp[a - s_i] \ne \infty$ 转移过来，那么 $dp[a]$ 将保持为 $\infty$，意味着总额 $a$ 本身是无法凑成的。在最终输出时，如果 $dp[N] = \infty$，我们通常返回 -1 来表示无解。

### 计数问题：组合与[排列](@entry_id:136432)的奥秘

除了最优化，动态规划也是解决复杂计数问题的利器。在完全背包的背景下，一个核心的区别在于我们是计算**组合 (combinations)** 还是**[排列](@entry_id:136432) (permutations)**。

-   **组合**：不考虑物品（或硬币）的选取顺序。例如，用面额为 $\{1, 2\}$ 的硬币凑成 3 元，$\{1, 2\}$ 和 $\{2, 1\}$ 被视为同一种方案。
-   **[排列](@entry_id:136432)**：考虑物品的选取顺序。此时，$\{1, 2\}$ 和 $\{2, 1\}$ 是两种不同的方案。

这个看似微小的差别，在动态规划的实现上会导致显著的不同，主要体现在内外循环的顺序上。

#### 计数[排列](@entry_id:136432)：顺序至关重要

我们先来解决计数[排列](@entry_id:136432)的问题，因为它在概念上更直接。假设我们要计算用面额集合 $S$ 凑成总额 $N$ 的有序序列总数。[@problem_id:3221794]

我们定义 $dp[a]$ 为凑成总额 $a$ 的不同[排列](@entry_id:136432)（有序序列）的数量。基本情况是 $dp[0] = 1$，代表凑成 0 的唯一方法是空序列。

为了得到凑成总额 $a$ 的一个序列，我们可以考虑这个序列的最后一个元素。如果最后一个元素是 $s_i$，那么序列的前半部分必须构成一个总额为 $a-s_i$ 的序列。根据加法原理，凑成 $a$ 的总[排列](@entry_id:136432)数，等于所有以 $s_i$ 结尾的[排列](@entry_id:136432)数之和。因此，状态[转移方程](@entry_id:160254)为：
$$
dp[a] = \sum_{s_i \in S, a \ge s_i} dp[a - s_i]
$$
在代码实现中，我们通常这样组织循环：
1.  创建一个大小为 $N+1$ 的数组 $dp$，初始化 $dp[0] = 1$，其余为 0。
2.  **外层循环**遍历所有总额 $a$ 从 1 到 $N$。
3.  **内层循环**遍历所有硬币面额 $s_i$。
4.  如果 $a \ge s_i$，则执行更新：$dp[a] = dp[a] + dp[a - s_i]$。

这种[循环结构](@entry_id:147026)确保了在计算 $dp[a]$ 时，我们会考虑所有可能的“最后一枚硬币”，从而正确地统计了所有[排列](@entry_id:136432)。例如，对于总额 3 和面额 $\{1, 2\}$，当计算 $dp[3]$ 时，我们会加上 $dp[2]$（代表在序列 `...` 后面加上 `1`）和 $dp[1]$（代表在序列 `...` 后面加上 `2`）。因为 $dp[2]$ 已经包含了序列 (1,1) 和 (2)，所以我们得到了 (1,1,1) 和 (2,1)。而 $dp[1]$ 包含了序列 (1)，所以我们得到了 (1,2)。这样，(1,2) 和 (2,1) 就被分别统计了。

#### 计数组合：顺序无关紧要

现在我们转向更微妙的[组合计数](@entry_id:141086)问题。目标是计算凑成总额 $N$ 的**无序**集合的数量。[@problem_id:3221780] [@problem_id:3221767]

如果我们沿用[排列](@entry_id:136432)计数的[循环结构](@entry_id:147026)，就会导致重复计数。例如，当外层循环是总额，内层循环是硬币时，组合 $\{1, 2\}$ 会在处理 `1` 之后处理 `2` 时被计入一次（从 $\{1\}$ 添加 `2`），也会在处理 `2` 之后处理 `1` 时被计入一次（从 $\{2\}$ 添加 `1`）。

为了避免这种情况，我们必须以一种规范的顺序来构建组合，从而确保每种组合只被统计一次。最常见的方法是**固定物品的考虑顺序**。我们可以通过交换内外循环的顺序来实现这一点。

算法流程如下：
1.  创建一个大小为 $N+1$ 的数组 $dp$，初始化 $dp[0] = 1$，其余为 0。
2.  **外层循环**遍历所有硬币面额 $s_i$。
3.  **内层循环**遍历所有总额 $a$ 从 $s_i$ 到 $N$。
4.  执行更新：$dp[a] = dp[a] + dp[a - s_i]$。

让我们分析一下为什么这样是正确的。当外层循环固定在某个硬币 $s_i$ 时，内层循环的更新 `dp[a] += dp[a - s_i]` 的含义是：“对于总额 $a$，我们可以在已经只使用过前 $i-1$ 种硬币的方案基础上，添加一枚硬币 $s_i$”。由于 $dp[a - s_i]$ 的值在 $s_i$ 这个外层循环中已经被更新过，它代表了使用前 $i$ 种硬币（包括 $s_i$）凑成 $a-s_i$ 的方案数。因此，这个更新实际上是在计算允许使用 $s_i$ 后，凑成总额 $a$ 的新方案数。

通过将硬币循环放在最外层，我们保证了硬币是按照一个固定的顺序被“加入”到组合中的（例如，按面额从小到大）。任何一个组合，例如 $\{1, 1, 2, 5\}$，只会在处理面额 5 时，通过在 $\{1, 1, 2\}$ 的基础上添加 5 而被唯一地生成和计数。这种方法巧妙地将一个无序的组合问题，映射到了一个按规范顺序构建的过程，从而避免了重复。

### 高级技巧与问题变体

动态规划的强大之处在于其框架的灵活性。通过对状态定义或转移过程进行巧妙的修改，我们可以解决许多带有额外约束的复杂变体。

#### 状态增强：处理附加约束

有时，问题的约束不仅仅是总额。例如，我们可能需要计算凑成总额 $N$ 且所用**硬币总数为偶数**的方案数。[@problem_id:3221725]

在这种情况下，原有的状态 $dp[a]$ 不足以区分硬币总数的奇偶性。我们需要**增强状态 (state augmentation)**。我们可以定义一个二维 DP 表：$dp[a][p]$，其中 $a$ 仍然是总额，而 $p$ 是一个表示奇偶性的维度（例如，$p=0$ 代表偶数，$p=1$ 代表奇数）。

$dp[a][0]$：凑成总额 $a$ 且硬币总数为偶数的方案数。
$dp[a][1]$：凑成总额 $a$ 且硬币总数为奇数的方案数。

基本情况是 $dp[0][0] = 1$ (0 个硬币是偶数)，$dp[0][1] = 0$。

状态[转移方程](@entry_id:160254)也需要相应调整。当我们考虑添加一枚硬币 $s_i$ 来凑成总额 $a$ 时，我们是从总额 $a-s_i$ 的状态转移而来。添加一枚硬币会使总数的奇偶性翻转。
-   要得到偶数个硬币凑成 $a$，必须从奇数个硬币凑成 $a-s_i$ 的状态转移：$dp[a][0]$ 增加 $dp[a-s_i][1]$。
-   要得到奇数个硬币凑成 $a$，必须从偶数个硬币凑成 $a-s_i$ 的状态转移：$dp[a][1]$ 增加 $dp[a-s_i][0]$。

这导致了如下的耦合[转移方程](@entry_id:160254)：
$$
dp[a][0] \leftarrow dp[a][0] + dp[a - s_i][1]
$$
$$
dp[a][1] \leftarrow dp[a][1] + dp[a - s_i][0]
$$
通过这种方式，我们成功地将附加[约束编码](@entry_id:197822)到了 DP 状态中。

#### 混合约束：分解与组合

设想一个更复杂的场景：大部分硬币供应无限，但某一种特殊面额 $d_k$ 最多只能使用 $L$ 次。[@problem_id:3221776] 这是一个混合了完全背包和 0/1 背包（或多重背包）特征的问题。

一个强大的解决策略是**按约束分解问题 (decomposition by constraint)**。我们可以遍历这个受限硬币 $d_k$ 的所有可能使用次数，即 $j$ 从 0到 $L$。

对于每一个固定的使用次数 $j$：
1.  我们已经使用了 $j$ 枚硬币 $d_k$，总价值为 $j \cdot d_k$，硬币数量为 $j$。
2.  剩下的目标总额为 $N' = N - j \cdot d_k$。
3.  这个剩余的总额 $N'$ 必须用其他所有不受限制的硬币来凑成。

这个子问题——用无限供应的其余硬币凑成 $N'$——是一个标准的完全[背包问题](@entry_id:272416)（最小化硬币数量）。我们可以先对所有不受限的硬币预计算一个标准的“最少硬币数”DP 表，我们称之为 $dp_{unlimited}$。

然后，我们遍历 $j=0, 1, \ldots, L$：
-   计算剩余总额 $N' = N - j \cdot d_k$。
-   如果 $N' \ge 0$ 且 $dp_{unlimited}[N']$ 是可达的（不是 $\infty$），那么对于这个特定的 $j$，总硬币数就是 $j + dp_{unlimited}[N']$。
-   我们在所有可能的 $j$ 中，取这个总硬币数的最小值作为最终答案。

这个方法将一个复杂的[混合问题](@entry_id:634383)，分解成了一系列我们已经知道如何解决的标准问题。

#### 复杂[目标函数](@entry_id:267263)：处理固定成本

当目标函数变得[非线性](@entry_id:637147)时，例如，每使用一种类型的硬币，就需要支付一次性的**生产成本 (production cost)**，DP 的设计需要更加精巧。[@problem_id:3221718]

目标是最小化 (总硬币数 + 总生产成本)。这里的生产成本是一个固定成本，只在第一次使用某种硬币时产生。

一个简单的 $dp[a]$ 状态无法记录哪些硬币类型已经被使用过。一个有效的解决方法是，像处理[组合计数](@entry_id:141086)问题一样，逐一考虑每种硬币。当我们引入一种新的硬币 $(d_i, p_i)$（面额 $d_i$，生产成本 $p_i$）时，我们更新主 DP 表 $dp[a]$（表示使用已考虑过的硬币凑成 $a$ 的最小总成本）。

为了正确处理生产成本，我们可以为当前硬币 $d_i$ 创建一个**临时 DP 表 (temporary DP table)**，我们称之为 $temp\_dp[a]$，它表示**使用了至少一枚硬币 $d_i$** 来凑成总额 $a$ 的最小成本。

$temp\_dp[a]$ 的值可以通过两种方式得到：
1.  **首次使用 $d_i$**：我们从一个未使用过 $d_i$ 的状态 $dp[a-d_i]$ 转移而来。成本是 $dp[a-d_i]$（来自旧硬币）+ $p_i$（生产成本）+ 1（一枚 $d_i$ 硬币）。
2.  **再次使用 $d_i$**：我们从一个已经使用过 $d_i$ 的状态 $temp\_dp[a-d_i]$ 转移而来。此时生产成本已被支付。成本是 $temp\_dp[a-d_i]$ + 1（又一枚 $d_i$ 硬币）。

因此，$temp\_dp[a] = \min(dp[a-d_i] + p_i + 1, \quad temp\_dp[a-d_i] + 1)$。

在计算完整个 $temp\_dp$ 表后，我们用它来更新主 $dp$ 表。对于每个总额 $a$，新的最小成本是“不使用 $d_i$”（即旧的 $dp[a]$）和“使用 $d_i$”（即 $temp\_dp[a]$）之间的较小者：$dp[a] = \min(dp[a], temp\_dp[a])$。

通过为每种硬币重复此过程，我们就能正确地处理这种复杂的固定成本结构。

### [贪心算法](@entry_id:260925)及其局限性

动态规划虽然总能找到最优解，但其 $O(n \cdot W)$ 的时间复杂度在 $W$ 很大时可能无法接受。一个自然的问题是：我们是否可以用更快的**贪心算法 (Greedy Algorithm)**？

对于换零钱问题，一个经典的贪心策略是：在每一步，总是选择不超过剩余总额的最大面额硬币。

然而，这个简单的策略只有在特定的硬币系统下才是最优的。这样的系统被称为**规范币制 (Canonical Coin System)**。例如，美元币制 $\{1, 5, 10, 25, 50, 100\}$ 就是规范的。但对于一个非规范币制，如 $\{1, 3, 4\}$，要凑出 6，[贪心算法](@entry_id:260925)会给出 $4+1+1$（3枚），而最优解是 $3+3$（2枚）。

一个有趣的例子是使用[斐波那契数](@entry_id:267966)作为面额的系统，例如 $\{1, 2, 3, 5, 8, \dots\}$。可以证明，对于这样的系统，[贪心算法](@entry_id:260925)总是能给出最少的硬币数。[@problem_id:3221783] 这与**齐肯多夫定理 (Zeckendorf's theorem)** 有关，该定理指出任何正整数都可以唯一地表示为不相邻[斐波那契数](@entry_id:267966)的和，而贪心选择正是找到这种表示的方法。在这种特殊情况下，贪心算法的复杂度仅为 $O(\log N)$，远优于动态规划。

然而，我们必须对[贪心算法](@entry_id:260925)保持警惕。考虑一个权重为 2 的幂次 $\{1, 2, 4, 8, \dots\}$ 的完全背包问题，但物品的价值是任意的。一个看似自然的贪心策略是“优先选择重量最大的物品”（类似于二进制分解）。但这种策略可能表现得非常糟糕。例如，若容量为 4，物品为 $\{w=4, v=5\}$ 和 $\{w=2, v=4\}$。贪心会选择重量为 4 的物品，得到价值 5。而最优解是选择两个重量为 2 的物品，得到价值 $4+4=8$。事实上，可以构造出例子，使得贪心解与最优解的比例任意小。[@problem_id:3221736]

仅当价值与重量成正比（即 $v_i = \alpha \cdot w_i$）时，这个问题上的贪心策略才是最优的，因为此时最大化总价值等价于最大化总重量，而贪心策略恰好能填满所有容量。

### 更深层次的联系：DP、线性代数与数论

动态规划的应用不仅限于优化和计数，它还能揭示问题背后更深的数学结构。考虑这样一个存在性问题：给定一个面额集合，是否存在两个**不同**的硬币**多重集 (multisets)**，它们具有**完全相同的总价值**和**完全相同的硬币总数**？[@problem_id:3221701]

这个问题看似需要复杂的搜索，但可以转化为一个线性代数问题。假设有两个不同的多重集，由向量 $\mathbf{x} = (x_1, \dots, x_m)$ 和 $\mathbf{y} = (y_1, \dots, y_m)$ 表示，其中 $x_i, y_i$ 是面额为 $a_i$ 的硬币数量。
条件是：
1.  总硬币数相同: $\sum x_i = \sum y_i$
2.  总价值相同: $\sum a_i x_i = \sum a_i y_i$

定义一个差分向量 $\mathbf{z} = \mathbf{x} - \mathbf{y}$。由于 $\mathbf{x} \ne \mathbf{y}$，$\mathbf{z}$ 是一个非零整数向量。上述两个方程可以写成一个[齐次线性方程组](@entry_id:153432)：
$$
\begin{cases}
\sum z_i = 0 \\
\sum a_i z_i = 0
\end{cases}
$$
问题转化为：是否存在一个非零整数向量 $\mathbf{z}$ 满足这个[方程组](@entry_id:193238)？

从线性代数的角度看，这是一个有 $m$ 个变量和 2 个方程的[方程组](@entry_id:193238)。
-   如果 $m=1$ 或 $m=2$，变量数不大于方程数，唯一的整数解就是 $\mathbf{z} = \mathbf{0}$（平凡解）。因此，不存在这样两个不同的多重集。
-   如果 $m \ge 3$，变量数大于方程数，该[方程组](@entry_id:193238)是欠定的，必然存在非零的实数解。通过一些数论技巧，可以证明也必然存在非零的**整数解**。

例如，对于 $\{a_1, a_2, a_3\}$，我们可以构造一个解：$z_1 = a_3 - a_2$, $z_2 = a_1 - a_3$, $z_3 = a_2 - a_1$。可以验证 $\sum z_i = 0$ 和 $\sum a_i z_i = 0$。

因此，这个深刻的问题有了一个惊人地简单的答案：这样的多重集存在，当且仅当唯一的面额数量大于等于 3。这个例子完美地展示了算法问题如何与更抽象的数学分支（如线性代数和[丢番图方程](@entry_id:148433)）紧密相连。

本章通过一系列从基础到高级的例子，展示了动态规划在解决完全背包及其变体问题时的原理、机制和巨大威力。掌握这些思想，将为你解决更广泛的组合优化和计数问题打下坚实的基础。