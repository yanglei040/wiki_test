{"hands_on_practices": [{"introduction": "要真正掌握一个算法，不仅要会应用它，更要能洞察其内在机制。这个练习将颠覆常规的分数背包问题：你不再是去求解最优价值，而是要构造一个特定的问题实例，使其在贪心策略下恰好达到预设的目标。通过这项逆向工程的挑战[@problem_id:3236024]，你将深刻理解贪心算法是如何构建解决方案的，以及最终总价值是如何由物品的价值密度和重量共同决定的。", "problem": "在分数背包问题中，每个物品 $i$ 有一个重量 $w_i > 0$、一个价值 $v_i > 0$ 和一个价值密度 $\\rho_i \\equiv v_i / w_i$。分数背包问题的贪心算法按照 $\\rho_i$ 的严格递减顺序选择物品，并尽可能多地拿取每个物品，直到满足容量限制。\n\n给你一个目标总价值 $V^\\star$ 和一个背包容量 $W$，以及一个整数 $k \\geq 1$。你需要构建一个至少包含 $k+1$ 个物品的实例，使得贪心算法恰好完整地选取前 $k$ 个物品，然后选取物品 $k+1$ 的一个正分数部分。考虑前 $k+1$ 个物品的以下参数族：\n\n- 密度构成一个几何级数：对于 $i = 1,2,\\dots,k+1$，$\\rho_i = R \\beta^{i-1}$，其中 $R > 0$ 且 $\\beta \\in (0,1)$。\n- 重量为 $w_1 = \\cdots = w_k = s$ 和 $w_{k+1} = t$，其中 $s > 0$ 且 $t > 0$。\n\n任务：\n1. 仅从上述定义出发，推导关于 $R$、$ \\beta$、$s$、$t$ 和 $W$ 的充要约束条件，以保证贪心算法恰好完整地选取前 $k$ 个物品，然后选取物品 $k+1$ 的一个正分数部分。\n2. 在这些约束条件下，用 $R$、$ \\beta$、$k$、$s$ 和 $W$ 表示贪心算法获得的总价值。然后，求解能达到目标价值 $V^\\star$ 的 $s$。\n3. 现在用 $k = 3$、$W = 20$、$R = 10$、$ \\beta = \\tfrac{1}{2}$ 和 $V^\\star = 80$ 对参数进行数值实例化。使用你的公式精确计算 $s$。你可以选择任何与第1部分约束条件一致的 $t$；不需要四舍五入。\n\n你的最终答案必须是 $s$ 的精确值，以单个实数形式表示。不要在最终答案中包含单位或任何附加文本。", "solution": "首先验证问题陈述的正确性和完整性。\n\n**问题验证**\n已知条件如下：\n- 一个容量为 $W$ 的背包。\n- 一组物品 $i$，其重量 $w_i > 0$，价值 $v_i > 0$，密度 $\\rho_i = v_i / w_i$。\n- 分数背包问题的贪心算法按 $\\rho_i$ 的严格递减顺序对物品进行排序。\n- 一个目标总价值 $V^\\star$ 和一个整数 $k \\geq 1$。\n- 前 $k+1$ 个物品的参数族：\n  - 密度：对于 $i=1, \\dots, k+1$，$\\rho_i = R \\beta^{i-1}$，其中 $R>0$ 且 $\\beta \\in (0,1)$。\n  - 重量：对于 $i=1, \\dots, k$，$w_i = s$；以及 $w_{k+1} = t$，其中 $s>0, t>0$。\n- 要求的结果是贪心算法恰好完整地选取前 $k$ 个物品，外加物品 $k+1$ 的一个正分数部分。\n- 用于实例化的数值：$k=3, W=20, R=10, \\beta=\\frac{1}{2}, V^\\star=80$。\n\n**结论**\n该问题具有科学依据，提法得当且客观。这是算法分析中的一个标准问题，没有矛盾、歧义或事实错误。参数定义清晰，前提条件在逻辑上支持各项任务。条件 $\\beta \\in (0,1)$ 确保了密度序列的严格递减，这是贪心算法排序的一个关键要求。该问题是有效的。\n\n**求解推导**\n\n我们按顺序解决指定的三个任务。\n\n**1. 约束条件的推导**\n\n贪心算法按价值密度 $\\rho_i$ 的递减顺序选择物品。给定的密度函数是 $\\rho_i = R \\beta^{i-1}$。因为 $R > 0$ 且 $\\beta \\in (0,1)$，所以我们有 $\\rho_1 > \\rho_2 > \\dots > \\rho_{k+1}$，因此算法将按照其下标的自然顺序来考虑物品：$1, 2, \\dots, k, k+1, \\dots$。\n\n问题陈述前 $k$ 个物品被完整选取。这些物品的总重量是 $\\sum_{i=1}^{k} w_i = \\sum_{i=1}^{k} s = ks$。\n\n问题还指出，物品 $k+1$ 的一个 *正分数* 部分被选取。这意味着两个条件：\n   a) 装入前 $k$ 个物品后，必须还有剩余容量。这意味着总容量 $W$ 必须严格大于前 $k$ 个物品的重量。因此，$W > ks$。\n   b) 剩余容量必须不足以装下全部物品 $k+1$。剩余容量是 $W - ks$，而物品 $k+1$ 的重量是 $w_{k+1}=t$。因此，我们必须有 $W - ks  t$。\n\n结合这些条件，我们得到 $ks  W$ 和 $W  ks + t$。这些是为达到指定结果而对 $W, k, s, t$ 施加的充要约束。问题还说明了 $s>0$ 和 $t>0$。条件 $W > ks$ 可以写成 $s  W/k$，而条件 $W  ks+t$ 意味着 $t > W-ks$。\n\n所以，完整的约束条件集是 $s>0$，$t>0$ 和 $ks  W  ks + t$。\n\n**2. 总价值表达式及求解 $s$**\n\n贪心算法获得的总价值 $V$ 是所取物品价值的总和。\n\n完整选取的前 $k$ 个物品的价值是：\n$$V_{1..k} = \\sum_{i=1}^{k} v_i = \\sum_{i=1}^{k} w_i \\rho_i = \\sum_{i=1}^{k} s (R \\beta^{i-1})$$\n这是一个几何级数：\n$$V_{1..k} = sR \\sum_{i=1}^{k} \\beta^{i-1} = sR \\sum_{j=0}^{k-1} \\beta^{j} = sR \\frac{1 - \\beta^k}{1 - \\beta}$$\n拿走前 $k$ 个物品后，已用重量为 $ks$，背包中的剩余容量为 $W_{\\text{rem}} = W - ks$。\n\n接着，算法拿取物品 $k+1$ 的一部分。可以拿取的物品 $k+1$ 的重量等于剩余容量 $W_{\\text{rem}}$。拿取的比例是 $x_{k+1} = \\frac{W-ks}{w_{k+1}} = \\frac{W-ks}{t}$。我们的约束条件保证了 $0  x_{k+1}  1$。\n\n物品 $k+1$ 的这一部分所贡献的价值是：\n$$V_{k+1} = x_{k+1} v_{k+1} = \\left(\\frac{W-ks}{t}\\right) (t \\rho_{k+1}) = (W-ks) \\rho_{k+1}$$\n代入 $\\rho_{k+1} = R \\beta^k$，我们得到：\n$$V_{k+1} = (W - ks) R \\beta^k$$\n总价值为 $V = V_{1..k} + V_{k+1}$：\n$$V = sR \\frac{1 - \\beta^k}{1 - \\beta} + (W - ks) R \\beta^k$$\n这就是总价值的表达式。注意它不依赖于 $t$。\n\n现在，我们将此总价值设为等于目标价值 $V^\\star$ 并求解 $s$：\n$$V^\\star = sR \\frac{1 - \\beta^k}{1 - \\beta} + WR\\beta^k - ksR\\beta^k$$\n我们将所有含 $s$ 的项归到一边：\n$$V^\\star - WR\\beta^k = s \\left( R\\frac{1 - \\beta^k}{1 - \\beta} - kR\\beta^k \\right)$$\n$$s = \\frac{V^\\star - WR\\beta^k}{R\\left(\\frac{1 - \\beta^k}{1 - \\beta} - k\\beta^k\\right)}$$\n分母可以通过通分 $1-\\beta$ 来简化：\n$$R\\left(\\frac{1 - \\beta^k - k\\beta^k(1-\\beta)}{1 - \\beta}\\right) = R\\left(\\frac{1 - \\beta^k - k\\beta^k + k\\beta^{k+1}}{1 - \\beta}\\right) = R\\frac{1 - (k+1)\\beta^k + k\\beta^{k+1}}{1 - \\beta}$$\n因此，$s$ 的最终公式是：\n$$s = \\frac{V^\\star - WR\\beta^k}{R \\frac{1 - (k+1)\\beta^k + k\\beta^{k+1}}{1 - \\beta}}$$\n\n**3. $s$ 的数值计算**\n\n给定参数 $k=3$, $W=20$, $R=10$, $\\beta=\\frac{1}{2}$ 和 $V^\\star=80$。我们将这些值代入推导出的 $s$ 的公式中。\n\n首先，我们计算分子：\n$$V^\\star - WR\\beta^k = 80 - (20)(10)\\left(\\frac{1}{2}\\right)^3 = 80 - 200\\left(\\frac{1}{8}\\right) = 80 - 25 = 55$$\n接下来，我们计算分母：\n$$R \\frac{1 - (k+1)\\beta^k + k\\beta^{k+1}}{1 - \\frac{1}{2}} = 10 \\frac{1 - (3+1)\\left(\\frac{1}{2}\\right)^3 + 3\\left(\\frac{1}{2}\\right)^{3+1}}{1 - \\frac{1}{2}}$$\n$$= 10 \\frac{1 - 4\\left(\\frac{1}{8}\\right) + 3\\left(\\frac{1}{16}\\right)}{\\frac{1}{2}}$$\n$$= 20 \\left(1 - \\frac{1}{2} + \\frac{3}{16}\\right)$$\n$$= 20 \\left(\\frac{1}{2} + \\frac{3}{16}\\right)$$\n$$= 20 \\left(\\frac{8}{16} + \\frac{3}{16}\\right) = 20 \\left(\\frac{11}{16}\\right) = \\frac{220}{16} = \\frac{55}{4}$$\n现在，我们可以计算 $s$：\n$$s = \\frac{\\text{分子}}{\\text{分母}} = \\frac{55}{\\frac{55}{4}} = 4$$\n$s$ 的值为 $4$。\n\n最后，我们检查此解是否与第1部分推导出的约束条件一致。我们需要满足 $ks  W  ks+t$。\n当 $k=3, s=4, W=20$时，条件 $ks  W$ 变为 $3 \\times 4  20$，即 $12  20$。这是成立的。\n条件 $W  ks+t$ 变为 $20  12+t$，这意味着 $t>8$。问题允许我们选择任何一致的 $t$，因此我们可以选择任何 $t>8$（例如 $t=10$）来完成问题实例。由于存在一个一致的 $t$，我们对 $s$ 的解是有效的。", "answer": "$$\\boxed{4}$$", "id": "3236024"}, {"introduction": "分数背包贪心策略的正确性，关键在于能否按价值密度对物品进行精确排序。这看似简单，但在计算机实现中，使用标准的浮点数进行除法比較，可能会因精度损失而导致排序错误。本练习[@problem_id:3235975]将带你直面这一真实的编程挑战，通过对比浮点数除法与更稳健的整数交叉相乘法，你将学会如何确保算法在面对极端数据时依然保持正确性。", "problem": "给定一组物品，每个物品都有一个非负整数价值 $v_i$ 和一个正整数重量 $w_i$，以及一个容量为 $C \\ge 0$ 的背包。在分数背包问题中，你可以取走物品的任意实数部分，对于取走的分数 $x_i \\in [0,1]$，物品 $i$ 贡献的总价值为 $x_i \\cdot v_i$，而消耗的总重量为 $x_i \\cdot w_i$。要最大化的总价值是 $\\sum_{i=1}^n x_i v_i$，受限于约束条件 $\\sum_{i=1}^n x_i w_i \\le C$以及对所有 $i$ 的界限 $0 \\le x_i \\le 1$。一个基本的方法是按价值密度非递增的顺序进行贪心选择，其中物品 $i$ 的价值密度为 $v_i / w_i$。\n\n本问题旨在考察当 $v_i, w_i$ 高达 $10^{12}$ 时，按 $v_i / w_i$ 对物品进行排序的数值稳定性，并要求你比较两种排序方法：\n- 朴素浮点数比较：将 $v_i / w_i$ 计算为 IEEE $754$ 双精度浮点数，并按这些浮点数值以非递增顺序排序。\n- 整数交叉乘法比较：使用精确整数算术，通过测试 $v_i w_j > v_j w_i$ 来比较物品 $i$ 和 $j$；如果 $v_i w_j > v_j w_i$，则 $i$ 在 $j$ 之前；如果 $v_i w_j  v_j w_i$，则 $j$ 在 $i$ 之前；如果 $v_i w_j = v_j w_i$，则确定性地打破平局，规则为先按较小的 $w$，然后按较大的 $v$，最后按较小的原始索引。\n\n构建并使用一个小型测试套件，以展示朴素浮点数比较在何处无法复现精确的有理数排序。特别地，包括一些对抗性输入，这些输入产生的密度差异小于末位一个单位（unit in the last place，通常缩写为 ULP，对于接近 $1$ 的双精度浮点数，ULP 约等于 $2^{-52} \\approx 2.22 \\cdot 10^{-16}$），从而导致舍入产生错误的相等或排序错误。你的实现不应依赖随机性，并且必须是确定性的。\n\n为每个测试用例实现两种排序：\n- 使用双精度浮点数算术，按键 $v_i / w_i$ 对 $S_{\\text{float}}$ 进行排序。\n- 使用整数交叉乘法 $v_i w_j$ 与 $v_j w_i$ 的精确比较器对 $S_{\\text{int}}$ 进行排序。\n\n对于每个测试用例，生成一个布尔值，指示 $S_{\\text{float}}$ 是否产生与 $S_{\\text{int}}$ 完全相同的物品索引顺序。\n\n使用以下测试套件。所有价值和重量都是整数，所有容量也都是整数。\n\n- 测试用例 1（正常路径）：\n  - 物品： $\\{(v,w)\\} = \\{(60,10),(100,20),(120,30)\\}$。\n  - 容量： $C = 50$。\n  - 理由：典型的较小数值；浮点数排序应与精确排序一致。\n\n- 测试用例 2（$b = 10^{12}$ 的对抗性准平局）：\n  - 令 $b = 10^{12}$。\n  - 物品： $\\{(v,w)\\} = \\{(b-1, b), (b, b+1), (\\lfloor b/2 \\rfloor, b)\\}$。\n  - 容量： $C = b$。\n  - 理由：$\\frac{b-1}{b} = 1 - \\frac{1}{b}$ 和 $\\frac{b}{b+1} = 1 - \\frac{1}{b+1}$ 相差 $\\frac{1}{b(b+1)} \\approx 10^{-24}$，该值小于接近 $1$ 的双精度 ULP；朴素浮点除法很可能会将这些密度视为相等，从而产生依赖于输入顺序的排序结果，而整数交叉乘法会产生严格的顺序。\n\n- 测试用例 3（边界容量 $0$）：\n  - 物品： $\\{(v,w)\\} = \\{(10^{12}, 10^{12}), (10^{12}, 1)\\}$。\n  - 容量： $C = 0$。\n  - 理由：容量为 $0$ 确保不能取走任何物品；排序一致性是预期的，但此用例测试了对极端数量级的处理。\n\n- 测试用例 4（容量超过总重量）：\n  - 物品： $\\{(v,w)\\} = \\{(10^{12}, 10^{12}), (10^{12}, 10^{12})\\}$。\n  - 容量： $C = 2 \\cdot 10^{12}$。\n  - 理由：容量足够大，可以完全取走所有物品；排序一致性是预期的。\n\n- 测试用例 5（$b = 10^{12}$ 的准平局链）：\n  - 令 $b = 10^{12}$。\n  - 物品： $\\{(v,w)\\} = \\{(b-2, b), (b-1, b+1), (b, b+2)\\}$。\n  - 容量： $C = b+1$。\n  - 理由：所有密度都与 $1$ 相差约 $10^{-12}$ 之内，严格的有理数排序为 $\\frac{b-2}{b}  \\frac{b-1}{b+1}  \\frac{b}{b+2}$；朴素浮点除法通常会将它们映射到非常接近或相等的、接近 $1$ 的双精度浮点数，稳定排序可能会保留输入顺序，从而与精确比较器的结果不同。\n\n你的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，\"[result1,result2,result3,result4,result5]\"），其中每个结果是一个布尔值，指示对于该测试用例，朴素浮点数排序的顺序是否与精确整数交叉乘法排序的顺序完全相同。不涉及单位，所有输出均为布尔值。", "solution": "用户想要比较在分数背包问题背景下，按价值密度 ($v/w$) 对物品进行排序的两种方法。这项任务突显了当精度至关重要时，浮点数算术的潜在陷阱。\n\n### 问题验证\n\n我将首先按照要求的协议验证问题陈述。\n\n#### 步骤 1：提取已知条件\n\n- **问题领域**：分数背包算法，重点是初始排序步骤。\n- **物品定义**：每个物品 $i$ 由一个非负整数价值 $v_i$ 和一个正整数重量 $w_i$ 定义。$v_i$ 和 $w_i$ 的值都可以大到 $10^{12}$。\n- **要比较的排序方法**：\n    1.  **$S_{\\text{float}}$ (朴素浮点数排序)**：使用 IEEE $754$ 双精度浮点数算术执行除法，按物品价值密度 $v_i / w_i$ 的非递增顺序排序。\n    2.  **$S_{\\text{int}}$ (精确整数排序)**：通过自定义比较函数对物品进行排序。为比较物品 $i$ 和 $j$，通过评估等价的整数不等式 $v_i w_j > v_j w_i$ 来测试不等式 $v_i / w_i > v_j / w_i$。\n- **$S_{\\text{int}}$ 的平局打破规则**：如果 $v_i w_j = v_j w_i$，则按以下有序标准打破平局：\n    1.  先按较小的重量 $w$。\n    2.  再按较大的价值 $v$。\n    3.  最后按较小的原始索引。\n- **任务**：对于给定的一组测试用例，为每个用例确定由 $S_{\\text{float}}$ 产生的物品索引序列是否与由 $S_{\\text{int}}$ 产生的序列完全相同。\n- **测试套件**：\n    - **用例 1**：物品 $\\{(60,10),(100,20),(120,30)\\}$，$C = 50$。\n    - **用例 2**：$b = 10^{12}$。物品 $\\{(b-1, b), (b, b+1), (\\lfloor b/2 \\rfloor, b)\\}$，$C = b$。\n    - **用例 3**：物品 $\\{(10^{12}, 10^{12}), (10^{12}, 1)\\}$，$C = 0$。\n    - **用例 4**：物品 $\\{(10^{12}, 10^{12}), (10^{12}, 10^{12})\\}$，$C = 2 \\cdot 10^{12}$。\n    - **用例 5**：$b = 10^{12}$。物品 $\\{(b-2, b), (b-1, b+1), (b, b+2)\\}$，$C = b+1$。\n\n#### 步骤 2：使用提取的已知条件进行验证\n\n- **科学依据**：该问题在计算数学和计算机科学领域有坚实的基础。它解决了浮点数表示中数值精度损失这一基本而实际的问题，这是数值分析的核心主题。使用交叉乘法进行精确分数比较是一种标准的、数学上合理的技术。问题要求处理高达 $10^{12}$ 的整数及其乘积，乘积可能达到约 $10^{24}$。这超出了标准 64 位整数（最大值约 $1.8 \\times 10^{19}$）的容量，但 Python 的任意精度整数可以正确处理，使得该问题在计算上是可行的。\n- **适定性**：问题是适定的。输入被明确定义。两种方法的排序标准都是明确的。基于整数的排序的平局打破规则是全面且能确保唯一、确定性排序的。输出格式被精确指定。\n- **客观性**：问题以客观、正式的语言陈述，没有偏见或主观断言。\n\n一个需要仔细审查的点是测试用例 5 的理由，该理由陈述密度的排序是 $\\frac{b-2}{b}  \\frac{b-1}{b+1}  \\frac{b}{b+2}$。直接的数学分析表明这是正确的。理由中的错误已被修正。\n\n#### 步骤 3：结论与行动\n\n该问题是**有效的**。其核心逻辑是合理的，前提具有科学依据，任务定义清晰。我将继续提供解决方案。\n\n### 基于原则的解决方案设计\n\n解决方案将涉及为一系列物品实现两种不同的排序程序，然后比较它们的结果。一个物品将被表示为元组 $(v, w, \\text{original\\_index})$，以保留其原始位置用于最终比较和打破平局。\n\n1.  **数据表示**：来自输入集的每个物品，例如 $(v,w)$，将被增补其原始索引 $i$，形成一个结构 $(v, w, i)$。这对于比较最终的排序顺序和在整数排序中进行确定性平局打破至关重要。\n\n2.  **浮点数排序 ($S_{\\text{float}}$)**：\n    - 此排序将使用 Python 的内置 `sorted()` 函数，这是一个稳定排序（Timsort）。\n    - 物品 $(v, w, i)$ 的排序键将是浮点值 $v/w$。\n    - 排序将按降序进行 (`reverse=True`)，以满足贪心背包策略的要求。\n    - Python 的标准 `float` 类型是 IEEE $754$ 双精度数，符合问题规范。\n    - 因为排序是稳定的，如果两个物品的密度被舍入为相同的浮点值，它们原始的相对顺序将被保留。这是对抗性测试用例旨在揭示的关键行为。\n\n3.  **整数交叉乘法排序 ($S_{\\text{int}}$)**：\n    - 此排序也使用 `sorted()`，但通过 `functools.cmp_to_key` 提供一个自定义比较函数。这允许按规定直接对物品进行成对比较。\n    - 比较函数 `compare(item1, item2)`，其中 `item1` = $(v_1, w_1, i_1)$ 和 `item2` = $(v_2, w_2, i_2)$，将实现精确的有理数比较逻辑。\n    - **主要比较**：它将计算差值 $v_1 w_2 - v_2 w_1$ 的符号。由于价值和重量的量级很大（高达 $10^{12}$），它们的乘积可以达到 $10^{24}$，需要 Python 原生提供的任意精度整数。\n        - 如果 $v_1 w_2 > v_2 w_1$，`item1` 的密度更高。对于降序排序，`item1` 应在 `item2` 之前。比较器返回一个负值（例如，$-1$）。\n        - 如果 $v_1 w_2  v_2 w_1$，`item2` 的密度更高。比较器返回一个正值（例如，$1$）。\n    - **平局打破逻辑**：如果 $v_1 w_2 = v_2 w_1$，则按顺序应用明确的平局打破规则：\n        1. 比较重量：如果 $w_1  w_2$，`item1` 在前（返回 $-1$）。\n        2. 比较价值：如果 $v_1 > v_2$，`item1` 在前（返回 $-1$）。\n        3. 比较索引：如果 $i_1  i_2$，`item1` 在前（返回 $-1$）。\n\n4.  **比较与输出**：\n    - 在两个排序过程完成后，将从 $S_{\\text{float}}$ 和 $S_{\\text{int}}$ 生成两个索引列表。\n    - 这两个索引列表将进行相等性比较。每个测试用例的结果（`True` 表示相同，`False` 表示不同）将被存储。\n    - 最终输出是这些布尔结果的列表，格式化为字符串。\n\n这种设计直接实现了问题中描述的两种方法，并使用适当的 Python 特性（`functools.cmp_to_key`、任意精度整数、稳定排序）来正确处理逻辑和潜在的数值挑战。\n\n让我们追踪一个对抗性用例，例如测试用例 2，物品为 $(b-1, b, 0)$ 和 $(b, b+1, 1)$，其中 $b=10^{12}$。\n- **$S_{\\text{int}}$**：比较 $v_0/w_0$ 和 $v_1/w_1$。交叉相乘：$v_0 w_1 = (b-1)(b+1) = b^2-1$。$v_1 w_0 = b \\cdot b = b^2$。由于 $b^2-1  b^2$，我们有 $v_0/w_0  v_1/w_1$。正确的降序排序将物品 $1$ 置于物品 $0$ 之前。\n- **$S_{\\text{float}}$**：密度为 $d_0 = \\frac{b-1}{b}$ 和 $d_1 = \\frac{b}{b+1}$。这两个值极其接近：$d_1 - d_0 \\approx 1/b^2 = 10^{-24}$。这个差值小于相对于 $1$ 的双精度浮点数的机器精度（约 $2.22 \\times 10^{-16}$）。因此，`(b-1)/b` 和 `b/(b+1)` 很可能计算出相同的双精度浮点值。因为 Python 的排序是稳定的，并且排序键相等，物品 $0$ 和物品 $1$ 的原始顺序将被保留。这将导致物品 $0$ 在物品 $1$ 之前排序，这与 $S_{\\text{int}}$ 的精确结果相矛盾。此用例的比较将产生 `False`。\n\n这种详细的方法确保解决方案将是正确和稳健的。", "answer": "```python\n# 完整的、可运行的 Python 3 代码如下。\n# 导入必须遵守指定的执行环境。\nimport numpy as np\nimport functools\n\ndef solve():\n    \"\"\"\n    实现并比较两种分数背包物品的排序方法，\n    以展示浮点数算术的数值不稳定性。\n    \"\"\"\n    \n    # 为对抗性测试用例定义基准值\n    b = 10**12\n\n    # 根据问题陈述定义测试套件。\n    # 每个测试用例包含一个 (价值, 重量) 元组的列表和一个容量。\n    # 容量 C 在排序逻辑中未使用，但属于问题定义的一部分。\n    test_cases = [\n        {\n            \"items\": [(60, 10), (100, 20), (120, 30)],\n            \"C\": 50\n        },\n        {\n            \"items\": [(b - 1, b), (b, b + 1), (b // 2, b)],\n            \"C\": b\n        },\n        {\n            \"items\": [(10**12, 10**12), (10**12, 1)],\n            \"C\": 0\n        },\n        {\n            \"items\": [(10**12, 10**12), (10**12, 10**12)],\n            \"C\": 2 * 10**12\n        },\n        {\n            \"items\": [(b - 2, b), (b - 1, b + 1), (b, b + 2)],\n            \"C\": b + 1\n        },\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        # 为物品增加原始索引以追踪顺序\n        # 物品格式: (价值, 重量, 原始索引)\n        items_with_indices = [(v, w, i) for i, (v, w) in enumerate(case['items'])]\n\n        # 方法 1: S_float - 使用浮点数除法的朴素排序\n        # Python 的 sort 是稳定的。如果密度被舍入为相同的浮点数，\n        # 它们的原始相对顺序将被保留。\n        # 按价值密度非递增（降序）排序。\n        s_float_sorted = sorted(items_with_indices, key=lambda item: item[0] / item[1], reverse=True)\n        s_float_indices = [item[2] for item in s_float_sorted]\n\n        # 方法 2: S_int - 使用整数交叉乘法的精确排序\n        # 这需要一个自定义比较函数。\n        def compare_items(item1, item2):\n            \"\"\"\n            使用精确整数算术按价值密度对物品进行排序的比较器。\n            如果 item1  item2 返回 -1，如果 item1  item2 返回 1，如果相等返回 0。\n            \"\"\"\n            v1, w1, idx1 = item1\n            v2, w2, idx2 = item2\n            \n            # 要比较 v1/w1 和 v2/w2，我们比较 v1*w2 和 v2*w1。\n            # Python 的整数支持任意精度，避免溢出。\n            cross_product_diff = v1 * w2 - v2 * w1\n            \n            if cross_product_diff  0: # v1/w1  v2/w2\n                return -1 # 在降序排序中，item1 在前\n            if cross_product_diff  0: # v1/w1  v2/w2\n                return 1  # 在降序排序中，item2 在前\n            \n            # 密度相等，应用指定的平局打破规则。\n            # 1. 先按较小的重量\n            if w1  w2:\n                return -1\n            if w1  w2:\n                return 1\n            \n            # 2. 再按较大的价值\n            if v1  v2:\n                return -1\n            if v1  v2:\n                return 1\n\n            # 3. 最后按较小的原始索引\n            if idx1  idx2:\n                return -1\n            if idx1  idx2:\n                return 1\n            \n            # 如果原始索引是唯一的，则不应到达此情况\n            return 0 \n\n        s_int_sorted = sorted(items_with_indices, key=functools.cmp_to_key(compare_items))\n        s_int_indices = [item[2] for item in s_int_sorted]\n        \n        # 比较两种排序方法得到的索引顺序\n        results.append(s_float_indices == s_int_indices)\n\n    # 以指定的单行格式打印结果\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3235975"}, {"introduction": "经典背包问题通常假设背包容量是固定的，但如果容量是动态增加的呢？在每个容量点都从头重新计算最优解，显然效率低下。本练习[@problem_id:3235965]旨在挑战你设计一个高效的增量式算法，它巧妙地利用了贪心策略的一个核心性质：物品的最优填充顺序与总容量无关，从而避免了重复计算，实现了对动态问题的快速响应。", "problem": "考虑分数背包优化问题，其中有一组固定的物品，每个物品 $i$ 都有一个正重量 $w_i \\in \\mathbb{R}_{0}$ 和一个正价值 $v_i \\in \\mathbb{R}_{0}$。目标是寻找一个分数向量 $\\mathbf{x} = (x_1, x_2, \\dots, x_n)$，其中 $x_i \\in [0,1]$，使得在满足容量约束的条件下，总价值最大化：\n$$\n\\max_{\\mathbf{x}} \\sum_{i=1}^{n} v_i x_i \\quad \\text{such that} \\quad \\sum_{i=1}^{n} w_i x_i \\leq W, \\quad x_i \\in [0,1] \\ \\forall i.\n$$\n定义物品 $i$ 的价值密度为 $\\rho_i = \\frac{v_i}{w_i}$。贪心算法理论中一个经过充分验证的事实指出，对于固定的容量 $W$，最优解可以通过按 $\\rho_i$ 的非递增顺序选取物品来获得，即尽可能多地完全放入物品，并可能部分放入最后一个物品，以恰好填满容量约束。\n\n现在考虑一个增量打包场景，其中背包容量 $W$ 在一系列步骤中增加，$W^{(1)} \\leq W^{(2)} \\leq \\cdots \\leq W^{(T)}$。在所有步骤中，物品集合是固定的。您的任务是基于第一性原理设计并实现一个惰性增量算法。该算法需要维持一个不变量：在任何容量 $W^{(t)}$下，都存在一个索引 $k^{(t)}$，使得按 $\\rho_i$ 非递增顺序排列的前 $k^{(t)}$ 个物品被完全放入，第 $(k^{(t)}+1)$ 个物品被部分放入（如果还有剩余容量），而所有后续物品都不放入。该算法必须：\n- 在一个按 $\\rho_i$ 非递增顺序排序的优先队列（PQ）或等效结构中维护物品。\n- 当容量从 $W^{(t)}$ 增加到 $W^{(t+1)}$ 时，从优先队列中将完整的物品放入背包，直到达到截止索引，并仅在必要时调整唯一的边界物品的份数，以精确匹配 $W^{(t+1)}$。\n- 绝不为每个步骤从头重新计算；相反，应重用前一个状态，并仅执行将解扩展到新容量所需的最小工作。\n\n您的程序的最终输出必须是针对所提供的测试套件，在每个容量步骤下的背包总价值列表。所有结果都表示为实数（浮点数）。如果一个容量步骤超过了所有物品的总重量，总价值应保持为所有物品可能的最大总价值。\n\n测试套件规范：\n- 测试用例 $1$：\n  - 物品：$(w_1, v_1) = (4, 20)$, $(w_2, v_2) = (2, 14)$, $(w_3, v_3) = (6, 24)$, $(w_4, v_4) = (3, 15)$。\n  - 容量步骤：$W^{(1)} = 0$, $W^{(2)} = 2$, $W^{(3)} = 5$, $W^{(4)} = 9$, $W^{(5)} = 15$。\n- 测试用例 $2$：\n  - 物品：$(w_1, v_1) = (5, 25)$, $(w_2, v_2) = (10, 60)$, $(w_3, v_3) = (4, 20)$。\n  - 容量步骤：$W^{(1)} = 6$, $W^{(2)} = 11$, $W^{(3)} = 15$, $W^{(4)} = 19$。\n- 测试用例 $3$：\n  - 物品：$(w_1, v_1) = (3, 9)$, $(w_2, v_2) = (7, 28)$, $(w_3, v_3) = (3, 12)$。\n  - 容量步骤：$W^{(1)} = 5$, $W^{(2)} = 13$, $W^{(3)} = 20$。\n- 测试用例 $4$：\n  - 物品：$(w_1, v_1) = (5, 15)$, $(w_2, v_2) = (4, 12)$, $(w_3, v_3) = (10, 30)$。\n  - 容量步骤：$W^{(1)} = 3$, $W^{(2)} = 9$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。外层列表每个测试用例包含一个元素，每个元素是对应容量步骤下的总价值的内层列表，所有内容打印时无空格。例如，所需格式形如 $[[a_1,a_2,\\dots],[b_1,b_2,\\dots],\\dots]$，其中每个 $a_j$、$b_j$ 等都是实数。您的程序必须计算并打印上述四个指定测试用例的精确列表。", "solution": "在尝试任何解决方案之前，需对问题陈述进行验证。\n\n### 步骤 1：提取已知信息\n- **问题类型**：分数背包优化。\n- **物品**：一组固定的 $n$ 个物品，其中物品 $i$ 有正重量 $w_i \\in \\mathbb{R}_{0}$ 和正价值 $v_i \\in \\mathbb{R}_{0}$。\n- **目标函数**：最大化总价值 $\\sum_{i=1}^{n} v_i x_i$。\n- **变量**：一个分数向量 $\\mathbf{x} = (x_1, x_2, \\dots, x_n)$，其中对于所有 $i=1, \\dots, n$，$x_i \\in [0,1]$。\n- **约束**：总重量不得超过容量 $W$，即 $\\sum_{i=1}^{n} w_i x_i \\leq W$。\n- **价值密度**：定义为 $\\rho_i = \\frac{v_i}{w_i}$。\n- **贪心策略**：通过按 $\\rho_i$ 的非递增顺序选取物品来获得最优解。\n- **场景**：一个增量打包过程，容量序列非递减 $W^{(1)} \\leq W^{(2)} \\leq \\cdots \\leq W^{(T)}$。\n- **算法要求**：\n    1.  设计一个惰性增量算法。\n    2.  在一个按 $\\rho_i$ 非递增顺序排序的优先队列（或等效结构）中维护物品。\n    3.  通过增加更多物品来更新从 $W^{(t)}$到 $W^{(t+1)}$ 的解，而不是从头重新计算。\n    4.  输出必须是每个容量步骤下的背包总价值列表。\n- **测试用例**：\n    - **测试用例 1**：物品 $(w, v)$: $(4, 20), (2, 14), (6, 24), (3, 15)$。容量 $W$: $0, 2, 5, 9, 15$。\n    - **测试用例 2**：物品 $(w, v)$: $(5, 25), (10, 60), (4, 20)$。容量 $W$: $6, 11, 15, 19$。\n    - **测试用例 3**：物品 $(w, v)$: $(3, 9), (7, 28), (3, 12)$。容量 $W$: $5, 13, 20$。\n    - **测试用例 4**：物品 $(w, v)$: $(5, 15), (4, 12), (10, 30)$。容量 $W$: $3, 9$。\n- **输出格式**：表示浮点数列表的列表的单行字符串，不含空格，例如 `[[val1_1,val1_2],[val2_1,val2_2]]`。\n\n### 步骤 2：使用提取的已知信息进行验证\n1.  **科学依据**：该问题是组合优化和算法理论中的一个经典问题。分数背包问题及其基于价值密度的贪心解是基础且成熟的概念。其表述在数学上是严谨的。该问题在科学上是合理的。\n2.  **适定性**：该问题是适定的。对于任何给定的容量 $W$，分数背包问题都有一个唯一的最大值。任务是为一系列容量计算这个值，这是一个确定性的、定义明确的计算问题。\n3.  **客观性**：该问题使用精确的数学语言（例如，$\\max, \\sum, \\in, \\mathbb{R}_{0}$）和清晰的定义来陈述。它是完全客观的。\n4.  **不完整或矛盾的设置**：该问题为每个测试用例提供了所有必要的数据（物品重量和价值、容量步骤）。没有矛盾之处。约束条件是自洽的。\n5.  **不切实际或不可行**：这是一个形式化的数学问题。数据由指定的正实数组成，这与设定一致。没有需要违反的物理约束。\n6.  **病态或结构不良**：问题结构清晰。目标明确：为一个定义好的问题实现一种特定类型的算法（增量式），并按指定格式生成结果。\n7.  **伪深刻、琐碎或同义反复**：该问题并非琐碎。它要求理解标准的分数背包贪心算法，并将其扩展为一个高效的增量版本，这是一个有意义的算法设计任务。\n8.  **超出科学可验证性**：解的正确性可以通过直接计算并与已知的最优值进行比较来验证。\n\n### 步骤 3：结论与行动\n问题是有效的。将提供一个解决方案。\n\n分数背包问题的基本原理是，最优解可以通过贪心方法获得。具体来说，应优先选择具有最高价值重量比（即价值密度 $\\rho_i = v_i/w_i$）的物品。这是因为背包的每一单位容量都应该用能提供最大价值的材料来填充，而密度 $\\rho_i$ 正是衡量这一点的指标。\n\n问题指定了一个增量场景，其中背包容量 $W$ 通过一系列步骤 $W^{(1)} \\leq W^{(2)} \\leq \\cdots \\leq W^{(T)}$ 单调增加。这种结构允许使用一种高效的增量算法，避免重新计算。随着容量从 $W^{(t)}$ 增加到 $W^{(t+1)}$，最优解中包含的物品集合只会扩大；对于 $W^{(t)}$ 的最优解中的某个物品，它仍将是 $W^{(t+1)}$ 最优解的一部分。这种单调性是增量设计的基石。\n\n我们的算法将按以下步骤进行：\n\n1.  **预处理**：对于给定的 $n$ 个物品集合，我们首先为每个物品 $i$ 计算价值密度 $\\rho_i = v_i/w_i$。然后，我们按照物品密度的非递增顺序对它们进行排序。这个排序后的列表，我们称之为 $I$，为任何容量 $W$ 建立了固定的、最优的物品考虑顺序。此步骤每个测试用例执行一次。\n\n2.  **增量计算**：我们按给定顺序处理容量步骤 $W^{(1)}, W^{(2)}, \\dots, W^{(T)}$。我们维护一个状态，该状态代表完全放入背包的物品集合。此状态可由三个变量定义：\n    - $total\\_weight\\_full$：所有已完全放入物品的重量总和。\n    - $total\\_value\\_full$：所有已完全放入物品的价值总和。\n    - $item\\_idx$：一个索引，指向排序列表 $I$ 中下一个要考虑的物品。\n\n    对于序列中的每个容量步骤 $W^{(t)}$：\n    a. 我们从上一步结束时的状态 $(total\\_weight\\_full, total\\_value\\_full, item\\_idx)$ 开始（对于 $W^{(1)}$，则从初始状态 $(0, 0, 0)$ 开始）。\n\n    b. 只要有足够容量，我们就贪心地从排序列表 $I$ 中添加整个物品。我们从当前的 $item\\_idx$ 向前迭代，对于每个物品 $I_{item\\_idx}$，如果 $total\\_weight\\_full + I_{item\\_idx}.weight \\leq W^{(t)}$，我们就完全添加它。这意味着更新 $total\\_weight\\_full \\mathrel{+}= I_{item\\_idx}.weight$，$total\\_value\\_full \\mathrel{+}= I_{item\\_idx}.value$，并递增 $item\\_idx$。我们重复此过程，直到下一个完整物品无法放入。\n\n    c. 在尽可能多地添加完整物品后，任何剩余容量 $W_{rem} = W^{(t)} - total\\_weight\\_full$ 都将用下一个物品 $I_{item\\_idx}$ 的一部分来填充（如果存在这样的物品）。所取的分数为 $x = W_{rem} / I_{item\\_idx}.weight$。这个分数部分贡献的价值是 $x \\times I_{item\\_idx}.value$。\n\n    d. 因此，容量 $W^{(t)}$ 的总价值为 $V^{(t)} = total\\_value\\_full + (W_{rem} / I_{item\\_idx}.weight) \\times I_{item\\_idx}.value$。如果没有剩余物品（$item\\_idx \\geq n$）或者 $W_{rem}=0$，则分数部分的价值为 $0$。\n\n    e. 状态 $(total\\_weight\\_full, total\\_value\\_full, item\\_idx)$ 现在已为下一个容量步骤 $W^{(t+1)}$ 正确更新。每个步骤的价值 $V^{(t)}$ 被收集起来。\n\n这种惰性增量方法是正确的，因为按密度排序的物品顺序对所有容量都是最优的。通过维护已完全打包物品的状态，我们只执行为适应每一步容量增加所需的最小额外工作，从而遵守了问题的要求。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef incremental_knapsack(items, capacities):\n    \"\"\"\n    Solves the fractional knapsack problem for a sequence of increasing capacities.\n\n    Args:\n        items (list of tuples): A list of (weight, value) tuples for each item.\n        capacities (list of floats): A sorted list of knapsack capacities.\n\n    Returns:\n        list of floats: The maximum total value for each capacity.\n    \"\"\"\n    # Step 1: Preprocessing - Sort items by value density in descending order.\n    extended_items = []\n    for w, v in items:\n        # As per problem spec, w > 0, so no division by zero.\n        density = v / w\n        extended_items.append({'weight': w, 'value': v, 'density': density})\n\n    sorted_items = sorted(extended_items, key=lambda x: x['density'], reverse=True)\n    num_items = len(sorted_items)\n\n    # Step 2: Incremental Calculation\n    step_results = []\n    \n    # State variables for the incremental algorithm\n    total_weight_full = 0.0 # Weight of fully included items\n    total_value_full = 0.0  # Value of fully included items\n    item_idx = 0           # Index of the next item to consider in sorted_items\n\n    # Iterate through each capacity step\n    for capacity in capacities:\n        # Add whole items that now fit due to increased capacity.\n        # This loop continues from where the last capacity step left off.\n        while item_idx  num_items and total_weight_full + sorted_items[item_idx]['weight'] = capacity:\n            item = sorted_items[item_idx]\n            total_weight_full += item['weight']\n            total_value_full += item['value']\n            item_idx += 1\n\n        # Calculate the total value for the current capacity\n        current_total_value = total_value_full\n\n        # Add a fraction of the next item if there's remaining capacity\n        remaining_capacity = capacity - total_weight_full\n        if item_idx  num_items and remaining_capacity  0:\n            fractional_item = sorted_items[item_idx]\n            fraction = remaining_capacity / fractional_item['weight']\n            current_total_value += fraction * fractional_item['value']\n        \n        step_results.append(current_total_value)\n\n    return step_results\n\ndef solve():\n    \"\"\"\n    Defines test cases and runs the incremental knapsack algorithm,\n    printing the results in the specified format.\n    \"\"\"\n    test_cases = [\n        {\n            \"items\": [(4, 20), (2, 14), (6, 24), (3, 15)],\n            \"capacities\": [0, 2, 5, 9, 15]\n        },\n        {\n            \"items\": [(5, 25), (10, 60), (4, 20)],\n            \"capacities\": [6, 11, 15, 19]\n        },\n        {\n            \"items\": [(3, 9), (7, 28), (3, 12)],\n            \"capacities\": [5, 13, 20]\n        },\n        {\n            \"items\": [(5, 15), (4, 12), (10, 30)],\n            \"capacities\": [3, 9]\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        result = incremental_knapsack(case[\"items\"], case[\"capacities\"])\n        all_results.append([round(val, 4) for val in result])\n\n    # Format the final output string as specified: [[a,b,...],[c,d,...]]\n    output_string = str(all_results).replace(\" \", \"\")\n    print(output_string)\n\nsolve()\n```", "id": "3235965"}]}