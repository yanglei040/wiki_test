{"hands_on_practices": [{"introduction": "我们从一个经典的组合布局问题开始，在棋盘上放置互不攻击的车。这个问题是练习回溯框架的理想起点，因为它的规则简单，状态转换清晰。通过这个练习 [@problem_id:3212770]，你将构建对“选择-探索-撤销”递归模式的核心理解，并实现一种基础而有效的剪枝策略，为你掌握更复杂的问题打下坚实基础。", "problem": "给定一个矩形网格（棋盘），其中一些方格缺失。放置在某个方格上的一个“车”（rook）可以攻击同一行和同一列的所有其他方格。当且仅当任意两个“车”都不共享同一行或同一列时，这组“车”是互不攻击的。你的任务是，对于每个给定的棋盘，计算最多可以放置在非缺失方格上的互不攻击的“车”的数量。\n\n基本原理：使用离散数学和算法设计中的标准定义。具体来说，一个有效的放置是行和列索引对的子集，具有以下性质：(i) 每个选定的对都对应一个存在的（非缺失的）方格，以及 (ii) 所有选定的对具有不同的行索引和不同的列索引。一个部分放置是满足这些约束的这样一组对。搜索空间是按扩展排序的所有部分放置的集合。如果一个剪枝规则可以被证明不会排除任何最优的完整放置，那么该规则是有效的。\n\n问题要求：\n- 设计并实现一个对部分放置进行系统性搜索的算法，该算法在每一步都遵循上述约束，并通过使用从仍可接受“车”的剩余行数和列数中得出的可靠上界来剪枝那些不可能导出最优解的分支。\n- 输入作为一组测试棋盘嵌入在程序中（没有外部输入）。\n- 方格使用字符编码：句点'.'表示可用方格，井号'#'表示缺失方格。\n- 对于一个有 $R$ 行和 $C$ 列的棋盘，该棋盘的输出必须是互不攻击的“车”集合的最大基数，以整数形式表示。\n\n测试套件：\n对于以下每种情况，计算互不攻击的“车”的最大数量。每种情况是一个包含 $R$ 个长度为 $C$ 的字符串的列表。\n\n- 情况 $1$（正常情况，可用性混合，矩形 $4 \\times 5$）：\n  - $R = 4$, $C = 5$\n  - 网格：\n    - \".#...\"\n    - \"..#.#\"\n    - \"#..#.\"\n    - \".....\"\n- 情况 $2$（边界情况，无法放置，$1 \\times 1$ 全缺失）：\n  - $R = 1$, $C = 1$\n  - 网格：\n    - \"#\"\n- 情况 $3$（边界情况，最小的非平凡情况，$1 \\times 1$ 可用）：\n  - $R = 1$, $C = 1$\n  - 网格：\n    - \".\"\n- 情况 $4$（完整棋盘，正方形 $5 \\times 5$）：\n  - $R = 5$, $C = 5$\n  - 网格：\n    - \".....\"\n    - \".....\"\n    - \".....\"\n    - \".....\"\n    - \".....\"\n- 情况 $5$（整列实际不可用，正方形 $4 \\times 4$）：\n  - $R = 4$, $C = 4$\n  - 网格：\n    - \"..#.\"\n    - \"###.\"\n    - \".##.\"\n    - \".##.\"\n- 情况 $6$（非正方形，有一整行被阻塞，$3 \\times 5$）：\n  - $R = 3$, $C = 5$\n  - 网格：\n    - \"..#..\"\n    - \"#####\"\n    - \".#.#.\"\n\n最终输出格式：\n你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，\"[result1,result2,result3]\"）。具体来说，对于上述六种情况，程序必须打印形如\"[x1,x2,x3,x4,x5,x6]\"的单行，其中每个 $x_i$ 是情况 $i$ 的整数答案。", "solution": "该问题被评估为有效。验证步骤如下。\n\n### 步骤1：提取已知信息\n- **问题领域**：在有缺失方格的矩形网格上放置互不攻击的“车”。\n- **任务**：为多个给定的棋盘计算可以放置在非缺失方格上的互不攻击的“车”的最大数量。\n- **定义**：\n    - 位于某个方格上的“车”可以攻击同一行和同一列的所有其他方格。\n    - 一组“车”是互不攻击的，当且仅当没有两个“车”共享同一行或同一列。\n    - 一个有效放置是行和列索引对的子集，例如 $(r, c)$，满足：(i) 方格 $(r, c)$ 不是缺失方格，以及 (ii) 对于任意两个选择的对 $(r_1, c_1)$ 和 $(r_2, c_2)$，$r_1 \\neq r_2$ 且 $c_1 \\neq c_2$。\n    - 一个部分放置是满足这些约束的一组这样的对。\n    - 搜索空间是所有部分放置的集合。\n- **算法要求**：\n    - 采用系统性搜索（回溯法）遍历部分放置。\n    - 搜索必须在每一步都遵循放置约束。\n    - 必须使用剪枝来消除不能导出最优解的分支。剪枝必须基于从剩余行数和列数得出的可靠上界。\n- **输入规范**：\n    - 输入是嵌入在程序中的一组测试棋盘。\n    - 方格编码：`.` 表示可用，`#` 表示缺失。\n    - 令 $R$ 为行数，$C$ 为列数。\n- **输出规范**：\n    - 对每个棋盘，输出是一个单一整数，代表互不攻击的“车”集合的最大基数。\n    - 最终程序输出必须是单行，包含用方括号括起来的逗号分隔的结果列表。\n- **测试套件**：提供了六个特定的棋盘配置。\n\n### 步骤2：使用提取的已知信息进行验证\n- **科学依据**：该问题是离散数学和计算机科学中一个经典的组合优化问题。它等价于在二分图中寻找最大匹配。这是一个已有定论、科学上合理的问题。\n- **良构性**：该问题是良构的。它要求一个有限整数集合（可能存在的互不攻击“车”的数量）的最大值，因此保证存在唯一的最大值。\n- **客观性**：问题陈述使用了精确、客观、形式化的数学语言。“互不攻击”、“有效放置”和“最大基数”等术语是明确的。\n- **完整性和一致性**：问题是自包含的。所有必要的定义、约束和测试数据都已提供。没有矛盾之处。\n- **其他缺陷**：该问题并非不切实际、病态、微不足道或无法验证。这是一个标准的算法挑战，非常适合所要求的回溯框架。\n\n### 步骤3：结论与行动\n问题陈述是**有效**的。将提供一个解决方案。\n\n### 基于原则的解决方案设计\n\n该问题要求在有阻塞方格的网格上找到互不攻击的“车”的最大数量。此问题是**二分图最大匹配**问题的直接应用。\n\n**1. 二分图表示法**\n\n我们可以将网格建模为一个二分图 $G = (U \\cup V, E)$，其中：\n- 顶点集 $U$ 代表棋盘的行，因此 $|U| = R$。\n- 顶点集 $V$ 代表棋盘的列，因此 $|V| = C$。\n- 当且仅当位于第 $i$ 行和第 $j$ 列的方格可用（即非缺失）时，存在一条边 $(u_i, v_j) \\in E$。\n\n放置互不攻击的“车”对应于此图中的一个**匹配**。匹配是边的子集 $M \\subseteq E$，其中 $M$ 中没有两条边共享一个共同的顶点。由于在 $(i, j)$ 处放置一个“车”会占用第 $i$ 行和第 $j$ 列，互不攻击的约束意味着每行和每列最多只能使用一次。这正是匹配的定义，其中每个顶点的度数最多为 $1$。\n\n因此，寻找互不攻击的“车”的最大数量的问题等价于寻找二分图 $G$ 中**最大匹配**的基数。\n\n**2. 算法策略：带剪枝的回溯法**\n\n根据问题陈述的要求，我们将使用回溯算法，该算法对部分放置的状态空间树执行深度优先搜索。\n\n- **状态表示**：我们递归搜索的状态可以由我们当前正在考虑的行 `row_index` 和已被“车”占据的列的集合来定义。我们可以为此使用一个大小为 $C$ 的布尔数组 `cols_used`。\n\n- **递归搜索函数**：我们定义一个函数，例如 `backtrack(row_index, num_placed_rooks)`，它试图通过考虑从 `row_index` 开始的放置来扩展大小为 `num_placed_rooks` 的部分解。\n\n- **基本情况**：当所有行都已被考虑时，即当 `row_index` 等于 $R$ 时，递归终止。此时，`num_placed_rooks` 代表一个完整有效放置的大小。如果这个值大于迄今为止找到的最佳值，我们用它来更新我们的全局最大值。\n\n- **递归步骤**：对于当前的 `row_index`，我们有两个主要选择：\n    1.  **不在该行放置“车”**：我们只需通过调用 `backtrack(row_index + 1, num_placed_rooks)` 移动到下一行。\n    2.  **在该行放置“车”**：我们遍历所有列 $j \\in \\{0, 1, ..., C-1\\}$。如果列 $j$ 尚未使用（`cols_used[j]` 为 false）且 `(row_index, j)` 处的方格可用，我们可以在那里放置一个“车”。这包括：\n        a. 将列 $j$ 标记为已使用。\n        b. 递归调用 `backtrack(row_index + 1, num_placed_rooks + 1)`。\n        c. 从递归返回后（即在探索完整个分支后），我们必须取消标记列 $j$ 为已使用。这是“回溯”步骤，它允许列 $j$ 在搜索树的其他分支中使用。\n\n- **使用上界进行剪枝**：为了使搜索高效，我们必须剪掉那些不可能导出更好解决方案的分支。设 `max_rooks_found` 是迄今为止在任何完整放置中找到的“车”的最大数量。在探索状态 `(row_index, num_placed_rooks)` 之前，我们可以计算一个从该状态可以达到的“车”总数的乐观上界。\n\n一个简单而可靠的上界是 `num_placed_rooks` 加上剩余的行数，即 $R - \\text{row\\_index}$。这是因为我们在每个剩余行中最多只能放置一个“车”。\n\n因此，剪枝条件是：\n如果 `num_placed_rooks + (R - row_index) = max_rooks_found`，我们可以安全地剪掉当前分支，因为它不可能产生比我们已经找到的更好的解决方案。\n\n这种带剪枝的系统性搜索保证了我们能探索整个有效的搜索空间并找到最优解，从而满足问题的所有要求。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the non-attacking rooks problem for a suite of test cases\n    using a backtracking algorithm with pruning.\n    \"\"\"\n\n    # Test suite provided in the problem description.\n    test_cases = [\n        # Case 1 (happy path, mixed availability, rectangular 4x5)\n        [\n            \".#...\",\n            \"..#.#\",\n            \"#..#.\",\n            \".....\"\n        ],\n        # Case 2 (boundary, no placement possible, 1x1 all missing)\n        [\n            \"#\"\n        ],\n        # Case 3 (boundary, smallest nontrivial, 1x1 available)\n        [\n            \".\"\n        ],\n        # Case 4 (full board, square 5x5)\n        [\n            \".....\",\n            \".....\",\n            \".....\",\n            \".....\",\n            \".....\"\n        ],\n        # Case 5 (a whole column effectively unusable, square 4x4)\n        [\n            \"..#.\",\n            \"###.\",\n            \".##.\",\n            \".##.\"\n        ],\n        # Case 6 (non-square with a fully blocked row, 3x5)\n        [\n            \"..#..\",\n            \"#####\",\n            \".#.#.\"\n        ]\n    ]\n\n    results = []\n    for board in test_cases:\n        if not board or not board[0]:\n            results.append(0)\n            continue\n        \n        R = len(board)\n        C = len(board[0])\n        \n        # Use a dictionary to store the mutable max_rooks value,\n        # which is a common pattern to handle nonlocal-like behavior.\n        # Python's nonlocal keyword works only for nested function scopes,\n        # and this structure provides more clarity.\n        state = {'max_rooks': 0}\n        \n        # Boolean array to track used columns. Using numpy as required.\n        cols_used = np.zeros(C, dtype=bool)\n\n        def backtrack(row_index, current_rooks):\n            \"\"\"\n            Recursive backtracking function to find the maximum number of non-attacking rooks.\n            \"\"\"\n            # Pruning step: If the current number of rooks plus the maximum possible\n            # future rooks (one per remaining row) is not better than the best\n            # we've found so far, then there is no need to continue this path.\n            if current_rooks + (R - row_index) = state['max_rooks']:\n                return\n\n            # Base case: if we have considered all rows\n            if row_index == R:\n                if current_rooks > state['max_rooks']:\n                    state['max_rooks'] = current_rooks\n                return\n            \n            # Recursive step:\n\n            # Option 1: Don't place a rook in the current row.\n            # Continue to the next row with the same number of rooks.\n            backtrack(row_index + 1, current_rooks)\n\n            # Option 2: Try to place a rook in the current row.\n            # Iterate through all columns for the current row.\n            for col_index in range(C):\n                # Check if the square is available and the column is not already used.\n                if board[row_index][col_index] == '.' and not cols_used[col_index]:\n                    # Place a rook\n                    cols_used[col_index] = True\n                    \n                    # Recurse to the next row with one more rook placed.\n                    backtrack(row_index + 1, current_rooks + 1)\n                    \n                    # Backtrack: un-place the rook to explore other possibilities.\n                    cols_used[col_index] = False\n\n        # Initial call to start the search from the first row with zero rooks placed.\n        backtrack(0, 0)\n        results.append(state['max_rooks'])\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3212770"}, {"introduction": "在掌握了基础的回溯模式后，我们将挑战一个更抽象的决策问题：约束子集和。这个问题 [@problem_id:3212780] 的难度有所提升，它要求你在单个回溯搜索中处理多种不同类型的约束（一个目标和值，以及每种“颜色”的物品数量限制）。此外，这个练习还将引导你学习如何通过精心设计搜索顺序，来找到满足条件且字典序最小的最优解，从而展示回溯算法的灵活性。", "problem": "您需要设计并实现一个回溯框架，以解决子集和决策问题的一个约束变体。该问题的基础如下。子集和的表述定义在一个具有非负权重的有限物品集合上，其中物品集由索引集 $\\{0,1,\\dots,n-1\\}$ 表示。每个物品 $i$ 都有一个关联的非负整数权重 $w_i \\in \\mathbb{Z}_{\\ge 0}$，并属于一个由映射 $col(i)$ 到有限颜色标签集 $\\mathcal{C}$ 所给定的颜色类别。指定了一个目标和 $T \\in \\mathbb{Z}_{\\ge 0}$。任务是确定一个子集 $S \\subseteq \\{0,\\dots,n-1\\}$，使得 $\\sum_{i \\in S} w_i = T$，并满足约束条件：对于每个颜色类别 $c \\in \\mathcal{C}$，子集 $S$ 最多包含 $k$ 个颜色为 $c$ 的物品，其中 $k \\in \\mathbb{Z}_{\\ge 0}$ 是一个统一的界限。\n\n您的程序必须实现一个有原则的回溯搜索，该搜索按索引升序探索物品索引上的二叉决策树，并应用基于以下组合搜索中经过充分检验的事实的可行性剪枝规则。首先，可行性剪枝：任何当前和超过 $T$ 的部分分配都无法扩展为有效解，因为所有权重都是非负的。其次，充分性剪枝：如果当前部分和与尚未考虑的物品所能达到的剩余和的上界之和严格小于 $T$，则任何扩展都无法达到目标。您必须确保算法遵守颜色基数约束，即对于每种颜色 $c$，来自 $S$ 且 $col(i)=c$ 的索引数量不超过 $k$。如果存在有效子集，程序必须在所有有效子集中返回按升序排列的字典序最小的索引列表。如果不存在有效子集，则返回空列表。索引是从零开始的，所以第一个物品的索引为 0。\n\n对于每个测试用例，您的输出必须是构成所选子集的按升序排列的整数索引列表，如果不存在解，则输出空列表。最终输出格式必须将所有测试用例的结果聚合到单行输出中，该输出包含一个用方括号括起来的逗号分隔列表（例如 $[result_1,result_2,result_3]$），其中每个 $result_j$ 本身是一个整数列表（可能为空）。\n\n提供的测试套件包含 $6$ 个测试用例，涵盖一般情况、边界条件和边缘情况。对于每个测试用例，物品由权重和颜色的数组定义，并指定了参数 $T$ 和 $k$。每个测试用例要求的输出是一个索引列表：\n\n- 测试用例 $1$ (一般成功路径):\n  - 权重: $[3,7,2,5,8]$\n  - 颜色: `['red', 'blue', 'red', 'green', 'blue']`\n  - 目标: $T=10$\n  - 颜色界限: $k=2$\n  - 要求输出类型: 表示索引的整数列表，按升序排列，其和为 10，且每种颜色的物品不超过 2 个；返回字典序最小的有效列表。\n\n- 测试用例 $2$ (颜色使用边界情况，$k=1$):\n  - 权重: $[4,4,4,4]$\n  - 颜色: `['red', 'red', 'blue', 'blue']`\n  - 目标: $T=8$\n  - 颜色界限: $k=1$\n  - 要求输出类型: 构成有效子集的整数列表。\n\n- 测试用例 $3$ (颜色约束严重限制可行性):\n  - 权重: $[6,6,6]$\n  - 颜色: `['green', 'green', 'green']`\n  - 目标: $T=18$\n  - 颜色界限: $k=2$\n  - 要求输出类型: 空列表，因为任何和为 18 的子集都违反了颜色界限。\n\n- 测试用例 $4$ (因权重导致目标不可达):\n  - 权重: $[2,4,6]$\n  - 颜色: `['r', 'g', 'b']`\n  - 目标: $T=5$\n  - 颜色界限: $k=2$\n  - 要求输出类型: 空列表。\n\n- 测试用例 $5$ (多个解；选择字典序最小的):\n  - 权重: $[1,1,2,2,3,3]$\n  - 颜色: `['A', 'A', 'B', 'B', 'A', 'B']`\n  - 目标: $T=6$\n  - 颜色界限: $k=2$\n  - 要求输出类型: 字典序最小的有效索引列表。\n\n- 测试用例 $6$ (边缘情况，$k=0$ 且目标为平凡值):\n  - 权重: $[5,3]$\n  - 颜色: `['x', 'y']`\n  - 目标: $T=0$\n  - 颜色界限: $k=0$\n  - 要求输出类型: 空列表，代表空子集，它有效且和为 0。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，例如 $[[i\\_0,i\\_1],[j\\_0,j\\_1,j\\_2],[]]$，其中包含按 1 到 6 的顺序为 6 个用例计算出的精确列表。", "solution": "所提出的问题是子集和问题的一个约束变体，这是组合优化和算法学中的一个经典课题。一个严谨的解决方案必须建立在一个健全的回溯框架之上，该框架系统地探索解空间，同时积极地剪除不可行的搜索路径。\n\n### 基于原则的设计\n\n**1. 形式化问题定义**\n\n设物品集合由 $I = \\{0, 1, \\dots, n-1\\}$ 索引。每个物品 $i \\in I$ 由一个非负整数权重 $w_i \\in \\mathbb{Z}_{\\ge 0}$ 和一个来自有限颜色集 $\\mathcal{C}$ 的颜色 $c_i$ 来表征。给定一个非负整数目标和 $T \\in \\mathbb{Z}_{\\ge 0}$ 以及一个用于颜色基数的统一非负整数界限 $k \\in \\mathbb{Z}_{\\ge 0}$，目标是找到一个索引子集 $S \\subseteq I$，该子集在所有满足以下两个主要条件的子集中是字典序最小的：\n\n1.  **和约束**：子集中物品的权重之和必须等于目标和：$\\sum_{i \\in S} w_i = T$。\n2.  **颜色约束**：对于任意给定的颜色 $c \\in \\mathcal{C}$，子集 $S$ 中具有该颜色的物品数量不得超过界限 $k$。形式上，对每个 $c \\in \\mathcal{C}$，都有 $|\\{i \\in S \\mid c_i = c\\}| \\le k$。\n\n如果没有子集 $S$ 满足这些条件，问题要求返回一个空列表。\n\n**2. 回溯框架**\n\n该问题的搜索空间包含物品集 $I$ 的所有 $2^n$ 个可能的子集。穷举搜索在计算上是不可行的。回溯提供了一种系统化的方法来遍历此空间，该空间可以建模为一个深度为 $n$ 的二叉决策树。在树的每一层 $i$（从 $0$ 到 $n-1$），都会对物品 $i$ 作出决策：要么将其包含在候选解集中，要么将其排除。算法对此树执行深度优先遍历。\n\n为实现这一点，我们定义一个递归函数 `backtrack`，其状态捕获搜索的进度。每次递归调用时状态的基本参数是：\n- $i$：当前正在考虑包含或排除的物品的索引。\n- $W_{curr}$：在搜索树当前路径中已选择物品的权重之和。\n- $S_{curr}$：表示部分解的列表，包含到目前为止已选择物品的索引。\n- $C_{counts}$：一个数据结构（如哈希映射），用于存储 $S_{curr}$ 中每种颜色的物品数量。\n\n**3. 递归逻辑与剪枝**\n\n`backtrack` 函数的核心由基本情况、剪枝规则和递归步骤组成。\n\n**基本情况：**\n- **找到解**：如果在任何时刻 $W_{curr}$ 变得等于 $T$，则已找到一个包含 $S_{curr}$ 中物品的有效解。由于搜索的结构是首先找到字典序最小的解，算法可以立即终止并采纳 $S_{curr}$ 作为最终答案。\n- **搜索耗尽**：如果索引 $i$ 达到 $n$，则所有物品都已考虑完毕。如果 $W_{curr} \\neq T$，这条特定的搜索路径是一个死胡同，递归必须回退（即回溯）。\n\n**剪枝策略：**\n为避免探索搜索树的无效分支，应用了两个剪枝规则：\n1.  **可行性剪枝**：由于所有权重都是非负的（$w_i \\ge 0$），如果 $W_{curr}$ 在任何时候超过 $T$，其和就不可能再减少。因此，任何 $W_{curr}  T$ 的路径都会被立即放弃。\n2.  **充分性剪枝**：可以使用一个乐观界来剪除不可能达到目标 $T$ 的路径。设 $W_{rem}(i) = \\sum_{j=i}^{n-1} w_j$ 为从索引 $i$ 开始的所有剩余物品的权重之和。如果当前和加上这个剩余可能和小于目标（即 $W_{curr} + W_{rem}(i)  T$），则此路径无法扩展为有效解。为高效应用此规则，需要预先计算所有 $i$ 的后缀和 $W_{rem}(i)$。\n\n**4. 字典序最小性与递归步骤**\n\n对字典序最小解的要求决定了搜索顺序。算法按索引升序（$i=0, 1, \\dots, n-1$）考虑物品。在每一步 $i$，它必须优先考虑**包含**物品 $i$ 的决策，而不是**排除**它的决策。这确保了如果存在解，第一个找到的解将由尽可能小的索引组成，从而使其在字典序上是最小的。\n\n递归步骤如下：\n\n1.  **尝试包含物品 $i$**：\n    a. 检查包含物品 $i$ 是否满足颜色约束。当前解中颜色为 $c_i$ 的物品数量 $C_{counts}[c_i]$ 必须严格小于 $k$。\n    b. 如果有效，则更新状态：将 $W_{curr}$ 增加 $w_i$，将 $i$ 附加到 $S_{curr}$，并增加 $C_{counts}[c_i]$。\n    c. 进行递归调用：`backtrack`(i+1, ...)。\n    d. 调用返回后，恢复状态更改（即回溯），为探索“排除”分支做准备。\n    e. 如果递归调用找到了解，则设置一个标志以终止所有其他正在进行和未来的递归调用。\n\n2.  **尝试排除物品 $i$**：\n    a. 当且仅当“包含”分支未导致解时，算法才继续探索“排除”的可能性。\n    b. 除索引外，状态保持不变。\n    c. 进行递归调用：`backtrack`(i+1, ...)。\n\n这种有纪律的探索与剪枝相结合，构成了一个正确且高效的算法来解决所述问题。对于 $T=0$ 的基本情况需要单独处理：空集是一个有效解，因为它的和为 $0$，并且对于每种颜色都包含 $0$ 个物品，从而满足任何 $k \\ge 0$ 的颜色约束。它也显然是字典序最小的解。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n\n    class ConstrainedSubsetSumSolver:\n        \"\"\"\n        A solver for the constrained subset sum problem using a backtracking framework.\n        \"\"\"\n        def __init__(self, weights, colors, target, k_bound):\n            self.weights = weights\n            self.colors = colors\n            self.target = target\n            self.k_bound = k_bound\n            self.n = len(weights)\n            \n            self.solution = []\n            self.found_solution = False\n            \n            # Pre-compute suffix sums for sufficiency pruning.\n            # self.suffix_sums[i] stores the sum of weights from index i to n-1.\n            self.suffix_sums = [0] * (self.n + 1)\n            for i in range(self.n - 1, -1, -1):\n                self.suffix_sums[i] = self.suffix_sums[i + 1] + self.weights[i]\n\n        def solve(self):\n            \"\"\"\n            Initializes and starts the backtracking search.\n            Returns the lexicographically smallest solution or an empty list.\n            \"\"\"\n            # The empty set is the valid, lexicographically smallest solution for T=0.\n            if self.target == 0:\n                return []\n\n            unique_colors = set(self.colors)\n            color_counts = {c: 0 for c in unique_colors}\n            \n            self._backtrack(0, 0, [], color_counts)\n            \n            return self.solution\n\n        def _backtrack(self, index, current_sum, current_path, color_counts):\n            \"\"\"\n            The core recursive backtracking function.\n            \"\"\"\n            # If a solution has been found, terminate this branch.\n            if self.found_solution:\n                return\n\n            # --- Base cases ---\n            # 1. Success: A valid solution is found.\n            if current_sum == self.target:\n                self.solution = list(current_path)\n                self.found_solution = True\n                return\n\n            # 2. Failure: All items considered but target not met.\n            if index == self.n:\n                return\n\n            # --- Pruning rules ---\n            # 1. Feasibility pruning: Current sum exceeds target.\n            if current_sum > self.target:\n                return\n            \n            # 2. Sufficiency pruning: Not enough remaining weight to reach target.\n            if current_sum + self.suffix_sums[index]  self.target:\n                return\n\n            # --- Recursive step ---\n            # To find the lexicographically smallest solution, we explore the \"include\"\n            # branch before the \"exclude\" branch.\n\n            # Choice 1: Include item `index`\n            item_weight = self.weights[index]\n            item_color = self.colors[index]\n            \n            if color_counts[item_color]  self.k_bound:\n                # Add item to the current path\n                current_path.append(index)\n                color_counts[item_color] += 1\n                \n                # Recurse\n                self._backtrack(index + 1, current_sum + item_weight, current_path, color_counts)\n                \n                # Backtrack: remove item from the current path\n                color_counts[item_color] -= 1\n                current_path.pop()\n\n                # If the \"include\" branch found a solution, we are done.\n                if self.found_solution:\n                    return\n\n            # Choice 2: Exclude item `index`\n            # This is explored only if the \"include\" branch did not find a solution.\n            self._backtrack(index + 1, current_sum, current_path, color_counts)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case 1: General happy path\n        {'weights': [3, 7, 2, 5, 8], 'colors': ['red', 'blue', 'red', 'green', 'blue'], 'T': 10, 'k': 2},\n        # Test Case 2: Boundary on color usage with k=1\n        {'weights': [4, 4, 4, 4], 'colors': ['red', 'red', 'blue', 'blue'], 'T': 8, 'k': 1},\n        # Test Case 3: Color constraint critically limits feasibility\n        {'weights': [6, 6, 6], 'colors': ['green', 'green', 'green'], 'T': 18, 'k': 2},\n        # Test Case 4: Unreachable target due to weights\n        {'weights': [2, 4, 6], 'colors': ['r', 'g', 'b'], 'T': 5, 'k': 2},\n        # Test Case 5: Multiple solutions, choose lexicographically smallest\n        {'weights': [1, 1, 2, 2, 3, 3], 'colors': ['A', 'A', 'B', 'B', 'A', 'B'], 'T': 6, 'k': 2},\n        # Test Case 6: Edge case with k=0 and trivial target\n        {'weights': [5, 3], 'colors': ['x', 'y'], 'T': 0, 'k': 0},\n    ]\n\n    results = []\n    for case in test_cases:\n        solver = ConstrainedSubsetSumSolver(case['weights'], case['colors'], case['T'], case['k'])\n        result = solver.solve()\n        results.append(result)\n\n    # Format the final output string exactly as specified.\n    # e.g., [[0,1],[0,2],[]]\n    formatted_results = []\n    for res in results:\n        res_str = f\"[{','.join(map(str, res))}]\"\n        formatted_results.append(res_str)\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3212780"}, {"introduction": "最后，我们将通过一个组合优化问题来探索回溯框架的高级技巧。这个练习 [@problem_id:3212818] 的核心教学价值在于展示两种能显著提升回溯效率的强大技术：基于动态更新的全局最优界进行剪枝，以及通过“对称性破除”来避免重复计算。掌握这些概念是应用回溯法解决更复杂的现实世界优化挑战的关键。", "problem": "给定一个由非负整数组成的有限多重集，表示为序列 $\\{a_1,a_2,\\dots,a_n\\}$，以及一个整数 $k$，满足 $1 \\le k \\le n$。一个有效的解是将所有元素划分为恰好 $k$ 个非空、两两不相交的子集，这些子集的并集是整个多重集。设子集和为 $s_1,s_2,\\dots,s_k$。目标是最小化极差 $R = \\max_{1 \\le j \\le k} s_j - \\min_{1 \\le j \\le k} s_j$。任务是设计并实现一个程序，该程序使用带有原则性剪枝和对称性约减的回溯框架，从状态空间树搜索的基本定义和可行分配的约束出发，计算 $R$ 的最小可能值。你的程序不能读取任何输入；相反，它必须解决以下测试套件并产生一个单一的聚合输出。\n\n定义和约束：\n- 多重集元素 $\\{a_1,\\dots,a_n\\}$ 是非负整数，且 $1 \\le k \\le n$。\n- 一个划分为 $k$ 个子集的划分是有效的，当且仅当每个子集都非空，且子集之间两两不相交，其并集等于原始多重集。\n- 对于前 $i$ 个元素的任何部分分配，设当前的子集和向量为 $(t_1,\\dots,t_k)$；设待分配的剩余总和为 $T_{\\mathrm{rem}} = \\sum_{j=i+1}^n a_j$。只有当你可以从某个回溯节点推导出一个严格的下界，表明从该节点出发能够达到的最优目标值不会优于已找到的最佳解时，才可以对该节点进行剪枝。\n\n测试套件：\n- 测试用例 1：$S = \\{3,1,4,2,2\\}$，$k = 2$。\n- 测试用例 2：$S = \\{5,7,9\\}$，$k = 1$。\n- 测试用例 3：$S = \\{10,10,9,1\\}$，$k = 3$。\n- 测试用例 4：$S = \\{8,1,2,3\\}$，$k = 3$。\n- 测试用例 5：$S = \\{1,2,3,4\\}$，$k = 4$。\n\n你的程序必须为每个测试用例计算可达到的最小极差 $R$（整数形式）。最终输出必须是单行，包含一个用方括号括起来的、由逗号分隔的5个结果列表，顺序与上述测试用例一致。例如，如果结果是 $v_1,v_2,v_3,v_4,v_5$，程序必须以 '[v1,v2,v3,v4,v5]' 的确切格式打印单行。", "solution": "所呈现的问题是一个有效的组合优化问题，其正式名称为多路数字划分问题 (multiway number partitioning problem)，旨在将一个数字多重集划分为固定数量的子集，以最小化一个特定的目标函数，在本例中即为子集和的极差。该问题定义明确，在计算机科学和离散数学中有科学依据，并且所有提供的定义和约束都是自洽和一致的。\n\n任务是找到一个将包含 $n$ 个非负整数的多重集 $S = \\{a_1, a_2, \\dots, a_n\\}$ 划分为恰好 $k$ 个非空子集的方案，使得这些子集和的极差最小化。设这些子集为 $S_1, S_2, \\dots, S_k$。它们的和为 $s_j = \\sum_{a \\in S_j} a$。目标是最小化 $R = \\max_{j} s_j - \\min_{j} s_j$。这个问题是 NP-hard 问题，意味着对于一般情况，没有已知的算法可以在多项式时间内解决它。回溯算法提供了一种系统性地探索所有可能划分的搜索空间的方法，并保证能找到最优解。为了使这种方法对于给定的测试用例在计算上可行，我们必须结合原则性的剪枝和对称性约减技术。\n\n该解决方案的核心是一个递归回溯函数，它探索部分分配的状态空间树。此搜索中的一个状态由 $(i, \\vec{t})$ 定义，其中 $i$ 是多重集 $S$ 中下一个要分配的元素的索引，而 $\\vec{t} = (t_1, t_2, \\dots, t_k)$ 是一个表示 $k$ 个子集当前和的向量。\n\n算法流程如下：\n\n1.  **初始化与启发式策略**：首先将多重集 $S$ 按降序排序。这是一种强大的启发式策略。首先放置较大的元素往往会较早地在子集和中产生较大的不平衡，这使得算法能够快速建立一个关于最小极差的、相当好的上界。一个更紧的上界能够实现更激进的搜索空间剪枝。到目前为止找到的最小极差 $R_{\\text{best}}$ 被初始化为一个较大的值，例如所有元素的总和 $\\sum_{i=1}^n a_i$。\n\n2.  **递归状态探索**：回溯函数，例如 `backtrack(i, t)`，工作方式如下：\n    *   **基准情形**：当索引 $i$ 达到 $n$ 时，所有元素都已被分配到一个子集中。这对应于搜索树中的一个叶节点，代表一个完整的划分。计算此划分的极差 $R = \\max(\\vec{t}) - \\min(\\vec{t})$。如果该极差优于目前找到的最佳极差（$R  R_{\\text{best}}$），则将 $R_{\\text{best}}$ 更新为 $R$。\n    *   **递归步骤**：对于当前索引 $i$ 处的元素 $a_i$，函数遍历 $k$ 个子集中的每一个。对于每个子集 $j \\in \\{1, \\dots, k\\}$，它通过更新其和 $t'_j = t_j + a_i$ 来试探性地将 $a_i$ 放入子集 $j$ 中。然后它进行递归调用 `backtrack(i+1, t')` 来分配下一个元素。在递归调用返回后，它必须通过恢复和 $t_j = t'_j - a_i$ 来“撤销”此次放置，以探索元素 $a_i$ 的其他可能性。\n\n3.  **剪枝（限界）**：回溯算法的效率取决于其“剪除”那些不可能产生比当前最优解更好的解的子树的能力。在任何节点 $(i, \\vec{t})$，我们可以计算部分和的当前极差 $R_{\\text{current}} = \\max(\\vec{t}) - \\min(\\vec{t})$。由于所有元素 $a_i$ 都是非负的，随着更多元素的加入，子集的和只能增加或保持不变。因此，当我们沿搜索树向下探索时，和的极差是一个非递减函数。这给了我们一个严格的下界：从当前节点派生出的任何完整划分的最终极差将至少为 $R_{\\text{current}}$。因此，如果在任何时刻 $R_{\\text{current}} \\ge R_{\\text{best}}$，我们可以立即剪掉当前分支，因为它不可能产生更好的解。\n\n4.  **对称性约减**：$k$ 个子集是不可区分的。例如，对于元素 $\\{a, b\\}$ 和 $k=2$，划分 $\\{\\{a\\}, \\{b\\}\\}$ 与 $\\{\\{b\\}, \\{a\\}\\}$ 是相同的。探索这两种情况是多余的。为了消除这种对称状态，我们可以对子集的形成方式强制施加一个任意的排序约束。一个标准的方法是规定一个新元素只能被放入*第一个*空的子集中。在我们的状态表示中，子集的索引为 $j=1, \\dots, k$。如果子集 $1, \\dots, m$ 非空（其和 $t_j  0$），而子集 $m+1$ 为空（$t_{m+1} = 0$），我们只考虑将当前元素 $a_i$ 放入子集 $1, \\dots, m, m+1$ 中的一个。这通过在从一个先前为空的子集中放置元素并回溯后，立即中断对子集的循环来实现。也就是说，如果在将 $a_i$ 放入子集 $j$（其中 $t_j$ 先前为 0）后调用 `backtrack`，我们就不再尝试将 $a_i$ 放入子集 $j+1, \\dots, k$。这确保了只有在子集 $1, \\dots, j-1$ 已经被填充的情况下，子集 $j$ 才会被填充，从而有效地打破了对称性。在 $k \\le n$ 的条件下，该策略也隐含地满足了问题约束，即在叶节点找到的任何有效最终划分中，所有 $k$ 个子集都必须非空。\n\n通过结合这些原则——由回溯构成的递归搜索、降序排序启发式策略、下界剪枝和对称性约减——我们构建了一个能够正确且高效地为给定的划分问题找到最小极差的算法。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass PartitionSolver:\n    \"\"\"\n    Solves the k-partition problem to minimize the range of subset sums\n    using a backtracking algorithm with pruning and symmetry reduction.\n    \"\"\"\n    def __init__(self, s, k):\n        # Sort the multiset in descending order as a heuristic to find good\n        # solutions early and improve pruning effectiveness.\n        self.s = sorted(s, reverse=True)\n        self.k = k\n        self.n = len(self.s)\n        # Initialize the best-found range to a loose upper bound (the total sum).\n        self.min_range = sum(self.s)\n\n    def find_min_range(self):\n        \"\"\"\n        Public method to initiate the search for the minimal range.\n        Handles trivial cases and starts the backtracking search.\n        \"\"\"\n        # If there's only one subset, the range is always 0.\n        if self.k == 1:\n            return 0\n        \n        # This condition is guaranteed not to occur by the problem statement,\n        # but is good practice for a general solver.\n        if self.k > self.n:\n            # It's impossible to have k non-empty subsets.\n            return -1  # Or raise an error\n\n        # subset_sums[j] will store the sum of elements in the j-th subset.\n        subset_sums = np.zeros(self.k, dtype=int)\n        \n        # Start the recursive search from the first element (index 0).\n        self.backtrack(0, subset_sums)\n        \n        return self.min_range\n\n    def backtrack(self, element_index, subset_sums):\n        \"\"\"\n        The recursive backtracking function.\n        \n        Args:\n            element_index: The index of the current element in self.s to be placed.\n            subset_sums: A numpy array of the current sums of the k subsets.\n        \"\"\"\n        # --- Pruning Step ---\n        # Calculate the current range of sums.\n        current_range = np.max(subset_sums) - np.min(subset_sums)\n        \n        # If the current range is already worse than or equal to the best one found so\n        # far, this path cannot lead to a better solution. Prune the search here.\n        if current_range >= self.min_range:\n            return\n\n        # --- Base Case ---\n        # If all elements have been placed, we have a complete partition.\n        if element_index == self.n:\n            # The current_range is the final range for this partition.\n            # Update the global minimum if this partition is better.\n            self.min_range = min(self.min_range, current_range)\n            return\n\n        # --- Recursive Step ---\n        current_element = self.s[element_index]\n        \n        # Try placing the current element in each of the k subsets.\n        for i in range(self.k):\n            # Place the element.\n            subset_sums[i] += current_element\n            \n            # Recur for the next element.\n            self.backtrack(element_index + 1, subset_sums)\n            \n            # Backtrack: remove the element to explore other possibilities.\n            subset_sums[i] -= current_element\n            \n            # --- Symmetry Reduction ---\n            # If the subset was empty before we added the element, it means we have\n            # just explored the branch where we start a new subset. To avoid\n            # symmetric solutions, we do not need to try starting another new\n            # subset with this same element. We enforce an implicit order on filling\n            # empty subsets.\n            if subset_sums[i] == 0:\n                break\n\ndef solve():\n    \"\"\"\n    Defines the test suite, runs the solver for each case,\n    and prints the aggregated results in the specified format.\n    \"\"\"\n    test_cases = [\n        {'S': [3, 1, 4, 2, 2], 'k': 2},\n        {'S': [5, 7, 9], 'k': 1},\n        {'S': [10, 10, 9, 1], 'k': 3},\n        {'S': [8, 1, 2, 3], 'k': 3},\n        {'S': [1, 2, 3, 4], 'k': 4},\n    ]\n\n    results = []\n    for case in test_cases:\n        s_list = case['S']\n        k_val = case['k']\n        solver = PartitionSolver(s_list, k_val)\n        result = solver.find_min_range()\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3212818"}]}