{"hands_on_practices": [{"introduction": "要真正理解一个算法，最好的方法是亲手实现它。这个练习将指导你将 Karatsuba 乘法的理论转化为可执行的代码，这是我们动手实践的第一步。你将需要实现其核心的递归结构，为小规模输入定义基准情形（base case），并运用三个规模更小的乘法来解决原问题的递归步骤。完成这项任务 ([@problem_id:3213594]) 将让你对分治思想有一个具体而深刻的认识。", "problem": "要求您设计并实现一个递归整数乘法过程，该过程需明确展示分治算法的基准情形和递归步骤。该方法必须作用于以任意位置基数表示的非负整数，并且必须通过代数组合将递归乘法的次数减少到低于朴素方法的水平。\n\n基本原理。仅使用以下基本事实作为起点：\n- 任何非负整数 $n$ 都可以表示为基数 $B$（其中 $B \\in \\mathbb{Z}$，$B \\ge 2$）的形式 $n = \\sum_{i=0}^{k-1} d_i B^i$，其中每个数字 $d_i$ 是一个满足 $0 \\le d_i \\le B-1$ 的整数。\n- 对于两个整数 $x$ 和 $y$以及任意基数 $B$，如果 $m \\in \\mathbb{Z}$ 且 $m \\ge 1$，那么这两个数可以被拆分为 $x = x_1 B^m + x_0$ 和 $y = y_1 B^m + y_0$，其中 $0 \\le x_0  B^m$ 且 $0 \\le y_0  B^m$。\n- 整数上的代数恒等式在常规环运算下成立。\n\n定义递归算法 Multiply$(x,y,B,t)$，并满足以下要求：\n1. 输入：整数 $x \\ge 0$，$y \\ge 0$，基数 $B \\ge 2$，以及一个截止阈值 $t \\ge 1$，表示以 $B$ 为基数的位数。\n2. 基准情形：如果 $\\min(\\text{digits}_B(x), \\text{digits}_B(y)) \\le t$ 或者 $x = 0$ 或 $y = 0$，则使用直接方法返回精确乘积 $xy$。这里，$\\text{digits}_B(n)$ 表示 $n$ 在基数 $B$下的位数（根据定义，$\\text{digits}_B(0) = 1$）。\n3. 递归步骤：否则，选择 $m = \\lceil \\max(\\text{digits}_B(x), \\text{digits}_B(y)) / 2 \\rceil$，将 $x$ 拆分为 $x = x_1 B^m + x_0$，将 $y$ 拆分为 $y = y_1 B^m + y_0$（其中 $0 \\le x_0, y_0  B^m$），并通过对 $(x_0,x_1)$ 和 $(y_0,y_1)$ 的组合进行恰好三次递归乘法，加上常数次加法、减法和乘以 $B$ 的幂次来计算结果。该组合必须能产生精确的乘积 $xy$。\n\n您的任务：\n- 递归地实现 Multiply$(x,y,B,t)$，遵守上述基准情形和递归步骤的约束。\n- 使用此程序计算以下参数值测试套件的乘积：\n  - 案例 A: $x = 123456789012345$, $y = 987654321098765$, $B = 10$, $t = 3$.\n  - 案例 B: $x = 99$, $y = 99$, $B = 10$, $t = 2$.\n  - 案例 C: $x = 0$, $y = 987654321$, $B = 10$, $t = 3$.\n  - 案例 D: $x = 123456$, $y = 789012$, $B = 2$, $t = 16$.\n  - 案例 E: $x = 10^{20} + 12345$, $y = 10^{10} + 678$, $B = 10$, $t = 3$.\n- 答案是无单位的精确整数。不涉及物理单位。\n\n最终输出格式：\n- 您的程序必须生成单行输出，其中包含案例 A 到 E 的结果，按顺序排列，形式为用方括号括起来的逗号分隔列表。例如，格式必须为 [$r_A,r_B,r_C,r_D,r_E$]，其中每个 $r_\\cdot$ 是相应案例的整数乘积，以十进制书写，不含任何额外的空格或文本。", "solution": "问题陈述已经过验证，被认为是有效的。它具有科学依据，问题提出得当，客观，并包含推导唯一、可验证解所需的所有必要信息。该问题描述了用于快速乘法的 Karatsuba 算法，这是计算机科学算法中的一个标准课题。\n\n任务是设计并实现一个递归整数乘法算法，记为 $\\text{Multiply}(x, y, B, t)$，与朴素方法相比，它减少了递归调用的次数。这是分治范式的经典应用。其核心原理在于一种代数操作，它允许使用三次较小整数的乘法来计算两个大整数的乘积，而不是直接展开所需的四次。\n\n设要相乘的两个非负整数为 $x$ 和 $y$。它们的乘积是 $x \\cdot y$。\n这些整数以位置基数 $B \\ge 2$ 表示。根据问题描述，我们可以将它们拆分为高位和低位部分。设 $n_x = \\text{digits}_B(x)$ 和 $n_y = \\text{digits}_B(y)$ 分别为 $x$ 和 $y$ 在基数 $B$ 下的位数。设 $n = \\max(n_x, n_y)$。我们选择一个分割点 $m = \\lceil n / 2 \\rceil$。\n\n使用这个 $m$，我们可以将 $x$ 和 $y$ 写成：\n$$x = x_1 B^m + x_0$$\n$$y = y_1 B^m + y_0$$\n其中 $x_1 = \\lfloor x / B^m \\rfloor$，$x_0 = x \\pmod{B^m}$，$y_1$ 和 $y_0$ 也类似。根据构造，$x_0$ 和 $y_0$ 是在基数 $B$ 下最多有 $m$ 位的整数。\n\n乘积 $x \\cdot y$ 可以展开为：\n$$x \\cdot y = (x_1 B^m + x_0) (y_1 B^m + y_0)$$\n$$x \\cdot y = x_1 y_1 B^{2m} + x_1 y_0 B^m + x_0 y_1 B^m + x_0 y_0$$\n$$x \\cdot y = (x_1 y_1) B^{2m} + (x_1 y_0 + x_0 y_1) B^m + (x_0 y_0)$$\n\n一个朴素的递归实现会递归地计算 $x_1 y_1$、$x_1 y_0$、$x_0 y_1$ 和 $x_0 y_0$ 这四个乘积。问题要求使用一种仅需三次递归乘法的方法。这可以通过 Anatoly Karatsuba 发现的代数恒等式来实现。\n\n让我们定义三个中间乘积：\n$z_2 = x_1 y_1$\n$z_0 = x_0 y_0$\n$z_1 = (x_1 + x_0)(y_1 + y_0)$\n\n关键的洞见在于使用这三个乘积来表示中间项 $(x_1 y_0 + x_0 y_1)$。展开 $z_1$：\n$z_1 = x_1 y_1 + x_1 y_0 + x_0 y_1 + x_0 y_0$\n$z_1 = z_2 + (x_1 y_0 + x_0 y_1) + z_0$\n\n由此，我们可以分离出中间项：\n$x_1 y_0 + x_0 y_1 = z_1 - z_2 - z_0$\n\n将此代入 $x \\cdot y$ 的表达式中：\n$$x \\cdot y = z_2 B^{2m} + (z_1 - z_2 - z_0) B^m + z_0$$\n\n这个最终的乘积表达式只需要三次乘法来求得 $z_0$、$z_1$ 和 $z_2$，以及几次加法、减法和乘以基数 $B$ 的幂（这些是计算成本较低的移位操作）。这三个乘积是通过对乘法算法本身的递归调用来计算的。\n\n$\\text{Multiply}(x, y, B, t)$ 的实现将遵循以下结构：\n\n1.  **辅助函数 $\\text{digits}_B(n, B)$**：需要一个函数来计算整数 $n$ 在基数 $B$ 下的位数。根据规定，$\\text{digits}_B(0) = 1$。对于 $n  0$，可以通过在循环中使用整数除法来稳健地计算，以避免处理大数时可能出现的浮点精度问题，其中 $\\text{digits}_B(n) = \\lfloor \\log_B n \\rfloor + 1$。\n\n2.  **基准情形**：递归必须终止。问题为基准情形指定了两个条件：\n    -   如果 $x=0$ 或 $y=0$，乘积为 $0$。\n    -   如果任一操作数的位数足够小，即 $\\min(\\text{digits}_B(x), \\text{digits}_B(y)) \\le t$，我们停止递归并直接计算乘积 $x \\cdot y$。这避免了对小数进行过度递归，因为在小数情况下，递归调用的开销超过了其带来的好处。\n\n3.  **递归步骤**：如果未满足基准情形：\n    -   计算 $n = \\max(\\text{digits}_B(x), \\text{digits}_B(y))$。\n    -   计算分割点 $m = \\lceil n / 2 \\rceil$。在整数算术中，这相当于 $(n + 1) // 2$。\n    -   计算 $B_m = B^m$。\n    -   将 $x$ 分割为 $x_1 = x // B_m$ 和 $x_0 = x \\% B_m$。\n    -   将 $y$ 分割为 $y_1 = y // B_m$ 和 $y_0 = y \\% B_m$。\n    -   进行三次递归调用：\n        -   $z_2 = \\text{Multiply}(x_1, y_1, B, t)$\n        -   $z_0 = \\text{Multiply}(x_0, y_0, B, t)$\n        -   $z_1 = \\text{Multiply}(x_1 + x_0, y_1 + y_0, B, t)$\n    -   使用推导出的公式重组结果：\n        $xy = z_2 \\cdot B^{2m} + (z_1 - z_2 - z_0) \\cdot B^m + z_0$。项 $B^{2m}$ 可以通过 $B_m \\cdot B_m$ 高效计算。\n\n此设计满足问题陈述的所有要求。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef digits_B(n, B):\n    \"\"\"\n    Calculates the number of digits of a non-negative integer n in a given base B.\n    As per the problem, digits_B(0) is defined as 1.\n    For n > 0, this is equivalent to floor(log_B(n)) + 1.\n    This implementation uses integer arithmetic to avoid floating point precision issues.\n    \"\"\"\n    if n == 0:\n        return 1\n    \n    count = 0\n    temp_n = n\n    while temp_n > 0:\n        temp_n //= B\n        count += 1\n    return count\n\ndef Multiply(x, y, B, t):\n    \"\"\"\n    Recursively computes the product of two non-negative integers x and y using\n    the Karatsuba algorithm, as specified in the problem statement.\n\n    Args:\n        x (int): A non-negative integer.\n        y (int): A non-negative integer.\n        B (int): The base for number representation (B >= 2).\n        t (int): The digit count threshold for the base case (t >= 1).\n\n    Returns:\n        int: The exact product x * y.\n    \"\"\"\n    # Base case: if one of the numbers is zero.\n    if x == 0 or y == 0:\n        return 0\n\n    # Determine the number of digits for x and y in base B.\n    num_digits_x = digits_B(x, B)\n    num_digits_y = digits_B(y, B)\n    \n    # Base case: if the number of digits in the smaller number is below the threshold.\n    if min(num_digits_x, num_digits_y) = t:\n        return x * y\n\n    # Recursive step:\n    # 1. Determine the split point m.\n    n_digits = max(num_digits_x, num_digits_y)\n    m = (n_digits + 1) // 2  # This is equivalent to ceil(n_digits / 2)\n\n    # 2. Split the numbers x and y into higher and lower parts.\n    Bm = B**m\n    x1 = x // Bm\n    x0 = x % Bm\n    y1 = y // Bm\n    y0 = y % Bm\n\n    # 3. Make three recursive calls as per the Karatsuba algorithm.\n    z2 = Multiply(x1, y1, B, t)\n    z0 = Multiply(x0, y0, B, t)\n    z1 = Multiply(x1 + x0, y1 + y0, B, t)\n\n    # 4. Recombine the results to get the final product.\n    # The formula is: z2 * B^(2m) + (z1 - z2 - z0) * B^m + z0\n    # To avoid re-calculating powers of B, we can reuse Bm.\n    B2m = Bm * Bm\n    result = z2 * B2m + (z1 - z2 - z0) * Bm + z0\n    \n    return result\n\ndef solve():\n    \"\"\"\n    Solves the problem by running the specified test cases through the\n    recursive multiplication algorithm and printing the results in the\n    required format.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: x = 123456789012345, y = 987654321098765, B = 10, t = 3\n        (123456789012345, 987654321098765, 10, 3),\n        # Case B: x = 99, y = 99, B = 10, t = 2\n        (99, 99, 10, 2),\n        # Case C: x = 0, y = 987654321, B = 10, t = 3\n        (0, 987654321, 10, 3),\n        # Case D: x = 123456, y = 789012, B = 2, t = 16\n        (123456, 789012, 2, 16),\n        # Case E: x = 10**20 + 12345, y = 10**10 + 678, B = 10, t = 3\n        (10**20 + 12345, 10**10 + 678, 10, 3)\n    ]\n\n    results = []\n    for case in test_cases:\n        x, y, B, t = case\n        result = Multiply(x, y, B, t)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3213594"}, {"introduction": "一个能在最终给出正确答案的算法固然不错，但一个在每一步都被证明是正确的算法则更具说服力。在实现了基本算法之后，我们如何能确信其在递归的每一层都正确无误呢？这项练习 ([@problem_id:3243186]) 引入了一种强大的调试技术，即在递归中嵌入“不变量检查”，你将在递归的每一层将 Karatsuba 的重组结果与标准乘法的结果进行比较，从而验证算法的正确性，并增强对代码逻辑的信心。", "problem": "您的任务是实现并验证一种基于 Karatsuba 乘法和基数分解的递归整数乘法算法，并嵌入一种调试策略，在每个递归层级检查一个重组不变量。该调试不变量指出，三个子乘积的重组结果必须等于在该层级上以相同基数计算的小学乘法（grade-school）乘积。您的任务必须从第一性原理推导，并在一个混合的确定性输入套件上进行测试。\n\n请从以下基本概念开始。\n\n- 一个非负整数 $x$ 的 $B$ 进制表示是唯一的展开式 $x = \\sum_{i=0}^{n-1} d_i B^i$，其中数字 $d_i \\in \\{0, 1, \\ldots, B-1\\}$。\n- 多项式乘法对加法的分配律意味着，如果 $x = x_1 B^m + x_0$ 和 $y = y_1 B^m + y_0$（其中 $x_0, x_1, y_0, y_1$ 为非负整数），那么 $xy$ 等于这两个二项式使用标准代数规则展开和重组后的乘积。\n- 在 $B$ 进制下，小学乘法算法通过带进位的按位卷积来乘以两个数，这等价于将以 $B$ 为变量、各位数字为系数的相关多项式相乘，然后进行进位归一化。\n\n您的程序必须实现以下组件。\n\n- 一个函数，通过对 $B$ 进制数字进行操作，计算两个（可能带符号的）整数 $x$ 和 $y$ 的小学乘法乘积。该函数必须返回一个等于 $xy$ 的精确整数结果。这将作为正确的基准和不变量的参考。\n- 一个用于非负整数的 Karatsuba 乘法例程，基于在中间点 $m = \\lceil n/2 \\rceil$ 处递归地分割每个操作数 $x$ 和 $y$，$n$ 是当前操作数对的 $B$ 进制数字长度的最大值。在每个非基本情况的递归层级，计算：\n  - $z_0$ 作为低位部分的乘积，\n  - $z_2$ 作为高位部分的乘积，\n  - $z_1$ 作为低位部分和高位部分之和的乘积，\n  然后形成重组\n  $$z_2 B^{2m} + \\left(z_1 - z_2 - z_0\\right) B^m + z_0.$$\n  对基本情况使用一个小的数字位数作为截断值，当位数小于或等于该截断值时，委托给小学乘法算法处理。\n- 一个调试不变量检查，在每个递归层级，将重组后的值\n  $$z_2 B^{2m} + \\left(z_1 - z_2 - z_0\\right) B^m + z_0$$\n  与该层级相同操作数的小学乘法乘积进行比较。此不变量必须在递归树的所有内部节点上进行检查。该检查必须应用于递归内部操作数的绝对值；总体符号可以在最外层应用。该例程必须汇总一个布尔值，该值为 `True` 当且仅当所有层级的所有不变量检查都通过，并且最终乘积等于原始数对的小学乘法乘积。\n\n设计约束和说明。\n\n- 计算中的所有整数必须是精确的；不允许使用浮点运算。\n- 基数 $B$ 必须是一个整数且 $B \\ge 2$。\n- 算法必须正确处理零和不等长的操作数。如果提供了负数输入，则通过分解出符号在递归之外处理，并对绝对值运行递归。\n- 不变量检查是为小操作数设计的，因此不要试图对其进行优化；它们应按照所提供的测试套件的规定运行。\n\n测试套件。\n\n您的程序必须运行以下测试用例，每个用例指定为一个四元组 $(B, x, y, c)$，其中 $c$ 是以 $B$ 进制数字表示的基本情况截断值。\n\n- $T_1$: $(10, 12345678, 87654321, 2)$，一个以 10 为基数的多位操作数的一般情况。\n- $T_2$: $(10, 0, 987654321, 1)$，一个以 10 为基数的涉及零的边界情况。\n- $T_3$: $(10, 9, 7, 1)$，一个以 10 为基数的单位数情况。\n- $T_4$: $(10, 9999, 9999, 1)$，一个以 10 为基数的接近基数幂次分割点的边界情况。\n- $T_5$: $(10, 10^{12} + 345678, 10^{5} + 90123, 2)$，以 10 为基数的不等长情况。\n- $T_6$: $(2, \\text{二进制 } `10110100101101001010`, \\text{二进制 } `11100101000101101`, 2)$，不同基数与位级操作数；将二进制字面量解释为整数。\n- $T_7$: $(16, \\text{十六进制 } `1234abcd`, \\text{十六进制 } `00ff00ff`, 2)$，一个以 16 为基数的情况；将十六进制字面量解释为整数。\n- $T_8$: $(10, 123456789012, 34567, 2)$，以 10 为基数、操作数长度差异较大的不等长情况。\n\n为清晰起见，$T_6$ 和 $T_7$ 中的字面量值必须分别视为给定的二进制和十六进制字符串所表示的整数。\n\n要求的输出格式。\n\n- 对于每个测试用例，在启用不变量检查的情况下计算 Karatsuba 乘积，并汇总一个布尔值，该值为 `True` 当且仅当每个递归层级的所有不变量检查都通过，并且最终乘积等于该测试用例参数的小学乘法乘积。生成单行输出，包含 8 个布尔结果，形式为方括号括起来的逗号分隔列表，例如 $[True,False,\\ldots]$。对输出列表中的每个元素使用 Python 的规范布尔字符串形式 `True` 和 `False`。", "solution": "该问题要求在指定的基数 $B$下，为任意大整数实现并验证 Karatsuba 乘法算法。实现必须包含一个带有基本情况截断值的递归结构、对符号和零的正确处理，以及一个内置的调试不变量。此不变量检查必须在每个递归层级验证 Karatsuba 重组公式的结果是否与使用标准“小学乘法”（grade-school）算法对该层级相同输入计算出的乘积相匹配。\n\n该解决方案从第一性原理出发进行开发，从整数的表示法开始，最终形成完整且经过验证的算法。\n\n### 原理 1：$B$ 进制表示法与小学乘法\n\n一个整数 $x$ 可以唯一地在基数 $B$ 中表示为 $B$ 的幂次之和，由数字 $d_i \\in \\{0, 1, \\ldots, B-1\\}$ 加权：\n$$x = \\sum_{i=0}^{n-1} d_i B^i$$\n两个整数 $x = \\sum_{i=0}^{n-1} a_i B^i$ 和 $y = \\sum_{j=0}^{m-1} b_j B^j$ 的乘积可以看作是变量 $B$ 的两个多项式的乘积。使用分配律，乘积 $z = xy$ 为：\n$$z = \\left(\\sum_{i=0}^{n-1} a_i B^i\\right) \\left(\\sum_{j=0}^{m-1} b_j B^j\\right) = \\sum_{k=0}^{n+m-2} c_k B^k$$\n其中 $c_k = \\sum_{i+j=k} a_i b_j$。小学乘法算法是该多项式乘积的过程化实现，随后通过将超过基数 $B-1$ 的值进位来对系数 $c_k$ 进行归一化。\n\n对于这个问题，它要求精确的整数运算，实现“小学乘法”乘积的最稳健且正确的方法是使用宿主语言（Python）提供的本机任意精度整数乘法。这个操作本身就是对这些原理的高度优化和正确的实现，提供了一个等于 $xy$ 的精确整数结果。它将作为我们不变量检查的基准真相参考。\n\n### 原理 2：Karatsuba 的递归分解\n\n标准的多项式乘法需要 $n \\times m$ 次基本乘法。Karatsuba 的算法降低了这种复杂性。设两个 $n$ 位数 $x$ 和 $y$ 被分割成高位和低位部分。我们选择一个分割点 $m = \\lceil n/2 \\rceil$。\n$$x = x_1 B^m + x_0$$\n$$y = y_1 B^m + y_0$$\n其中 $x_0, y_0  B^m$。乘积 $xy$ 是：\n$$xy = (x_1 B^m + x_0)(y_1 B^m + y_0) = (x_1 y_1) B^{2m} + (x_1 y_0 + x_0 y_1) B^m + (x_0 y_0)$$\n这个展开式似乎需要四次乘法：$x_1 y_1$、$x_1 y_0$、$x_0 y_1$ 和 $x_0 y_0$。Karatsuba 的关键洞见是仅使用一次额外的乘法来计算中间项 $(x_1 y_0 + x_0 y_1)$。设：\n- $z_2 = x_1 y_1$\n- $z_0 = x_0 y_0$\n- $z_1 = (x_0 + x_1)(y_0 + y_1) = x_0 y_0 + x_1 y_0 + x_0 y_1 + x_1 y_1 = z_0 + (x_1 y_0 + x_0 y_1) + z_2$\n\n由此，我们可以分离出中间项的系数：\n$$(x_1 y_0 + x_0 y_1) = z_1 - z_2 - z_0$$\n将其代入回乘积展开式，得到 Karatsuba 的重组公式，该公式仅使用三次规模更小的乘法（$z_0$、$z_1$、$z_2$）：\n$$xy = z_2 B^{2m} + (z_1 - z_2 - z_0) B^m + z_0$$\n这种分解构成了递归算法的基础。递归持续进行，直到操作数的位数小到可以用一个更简单的非递归方法处理（基本情况）。\n\n### 算法实现与不变量检查\n\n该算法实现为一个递归函数，它接受两个非负整数 $x$ 和 $y$、一个基数 $B$、一个截断位数 $c$ 以及一个用于汇总不变量检查结果的列表。\n\n1.  **符号处理**：一个顶层包装函数处理输入的符号。它确定最终乘积的符号，对输入的绝对值执行 Karatsuba 乘法，并将正确的符号应用于最终结果。\n\n2.  **位数计算**：需要一个辅助函数来计算整数 $n$ 在给定基数 $B$ 中的位数。对于 $n0$，位数为 $\\lfloor \\log_B n \\rfloor + 1$。对于 $n=0$，位数为 $1$。为处理大整数时保证稳健性，使用简单的迭代除法。\n\n3.  **递归函数 `karatsuba_multiply_recursive(x, y, B, c, checks)`**：\n    -   **基本情况**：如果 $x$ 或 $y$ 在基数 $B$ 中的最大位数小于或等于截断值 $c$，递归终止。在这种情况下，直接使用小学乘法参考（即本机乘法 $x \\times y$）计算乘积并返回。\n    -   **递归步骤**：\n        a. 计算 $n = \\max(\\text{digits}_B(x), \\text{digits}_B(y))$。\n        b. 定义分割点 $m = \\lceil n/2 \\rceil$。\n        c. 分割数字：$x_1 = x // B^m$，$x_0 = x \\pmod{B^m}$。对 $y$ 做类似处理。\n        d. 递归计算三个子乘积：\n           - $z_0 = \\text{karatsuba\\_multiply\\_recursive}(x_0, y_0, B, c, \\text{checks})$\n           - $z_2 = \\text{karatsuba\\_multiply\\_recursive}(x_1, y_1, B, c, \\text{checks})$\n           - $z_1 = \\text{karatsuba\\_multiply\\_recursive}(x_0 + x_1, y_0 + y_1, B, c, \\text{checks})$\n        e. **不变量检查**：这是关键的调试步骤。\n           i. 重组子乘积：`recombined_product` $= z_2 B^{2m} + (z_1 - z_2 - z_0) B^m + z_0$。\n           ii. 计算当前层级输入的基准真相乘积：`ground_truth` $= x \\times y$。\n           iii. 比较它们并将布尔结果追加到 `checks` 列表中：`checks.append(recombined_product == ground_truth)`。\n        f. 返回 `recombined_product`。\n\n4.  **最终验证**：对于一个给定的测试用例，其总体结果为 `True` 当且仅当满足两个条件：\n    a. 递归树的每个层级的所有不变量检查都为 `True`。\n    b. 顶层输入的最终 Karatsuba 乘积与这些相同输入的小学乘法乘积相匹配。\n\n这种结构化方法通过在整个计算过程中进行持续的自我验证来确保正确性，从而为最终结果提供了高度的置信度。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef get_num_digits_in_base(n, base):\n    \"\"\"\n    Calculates the number of digits of a non-negative integer n in a given base.\n    \"\"\"\n    if n == 0:\n        return 1\n    \n    if base = 1:\n        raise ValueError(\"Base must be >= 2\")\n\n    num_digits = 0\n    temp_n = n\n    while temp_n > 0:\n        temp_n //= base\n        num_digits += 1\n    return num_digits\n\ndef karatsuba_multiply_recursive(x, y, base, cutoff, invariant_checks):\n    \"\"\"\n    Performs recursive Karatsuba multiplication on non-negative integers\n    and runs an invariant check at each recursive step.\n    \"\"\"\n    # Base case for zero inputs.\n    if x == 0 or y == 0:\n        return 0\n\n    # Determine the number of digits for the current operands.\n    n_x = get_num_digits_in_base(x, base)\n    n_y = get_num_digits_in_base(y, base)\n    n = max(n_x, n_y)\n\n    # Base case: if the number of digits is below or at the cutoff,\n    # use standard multiplication.\n    if n = cutoff:\n        return x * y\n\n    # Recursive step\n    # m is the split point, ceiling of n/2\n    m = (n + 1) // 2\n    \n    # B^m\n    b_m = base ** m\n\n    # Split numbers into high and low parts.\n    x1, x0 = divmod(x, b_m)\n    y1, y0 = divmod(y, b_m)\n\n    # Three recursive calls.\n    z0 = karatsuba_multiply_recursive(x0, y0, base, cutoff, invariant_checks)\n    z2 = karatsuba_multiply_recursive(x1, y1, base, cutoff, invariant_checks)\n    z1 = karatsuba_multiply_recursive(x0 + x1, y0 + y1, base, cutoff, invariant_checks)\n\n    # Karatsuba recombination formula.\n    recombined_product = z2 * (base ** (2 * m)) + (z1 - z2 - z0) * b_m + z0\n\n    # The invariant check: compare recombination vs grade-school at this level.\n    # The grade-school product is simulated by Python's exact integer multiplication.\n    ground_truth = x * y\n    invariant_checks.append(recombined_product == ground_truth)\n    \n    return recombined_product\n\ndef run_karatsuba_test(B, x, y, c):\n    \"\"\"\n    A wrapper to handle signs and perform the final validation check.\n    \"\"\"\n    if B  2:\n        raise ValueError(\"Base must be >= 2\")\n\n    invariant_checks = []\n    \n    original_x, original_y = x, y\n    \n    # Handle signs outside the recursion.\n    sign = 1\n    if x  0:\n        sign *= -1\n        x = -x\n    if y  0:\n        sign *= -1\n        y = -y\n\n    # Run the recursive algorithm on absolute values.\n    # Note: x and y are now guaranteed to be non-negative.\n    karatsuba_result = karatsuba_multiply_recursive(x, y, B, c, invariant_checks)\n    \n    # Apply the sign to the final result.\n    final_karatsuba_product = karatsuba_result * sign\n    \n    # Final validation: check if the top-level result is correct.\n    final_ground_truth = original_x * original_y\n    final_check_passed = (final_karatsuba_product == final_ground_truth)\n    \n    # The test passes if ALL invariant checks passed AND the final result is correct.\n    return all(invariant_checks) and final_check_passed\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and run the validation.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # T1: (B, x, y, c)\n        (10, 12345678, 87654321, 2),\n        # T2:\n        (10, 0, 987654321, 1),\n        # T3:\n        (10, 9, 7, 1),\n        # T4:\n        (10, 9999, 9999, 1),\n        # T5:\n        (10, 10**12 + 345678, 10**5 + 90123, 2),\n        # T6: (binary literals interpreted as integers)\n        (2, 0b10110100101101001010, 0b11100101000101101, 2),\n        # T7: (hex literals interpreted as integers)\n        (16, 0x1234abcd, 0x00ff00ff, 2),\n        # T8:\n        (10, 123456789012, 34567, 2),\n    ]\n\n    results = []\n    for case in test_cases:\n        B, x, y, c = case\n        is_valid = run_karatsuba_test(B, x, y, c)\n        results.append(is_valid)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3243186"}, {"introduction": "Karatsuba 算法的理论优势在于其低于平方级别的时间复杂度，即 $O(n^{\\log_2 3})$。最后一项练习 ([@problem_id:3243158]) 将让你化身为一名实验计算机科学家，亲手验证这一著名结论。通过设计一个计算实验来统计基本运算的次数，并利用数据分析来拟合性能模型，你将能够凭经验估算出该算法的复杂度指数，并观察它与理论值 $\\log_2 3$ 的吻合程度。", "problem": "您的任务是设计并执行一个独立的计算实验，仅使用分治分析和基本统计拟合的第一性原理，以经验方式复现 Karatsuba 乘法算法的渐近时间复杂度中的指数。该实验必须实现为一个完整的、可运行的程序，除了打印下面描述的一行聚合数据外，不执行任何输入或输出。\n\n从以下基本要素开始：\n- 一个算法在“大小”为 $n$ 的输入上的渐近时间被建模为一个函数 $t(n)$，用于计算所执行工作量的固定代理指标。在单位成本随机存取机 (RAM) 模型中，可以通过计算基本运算（如单位数乘法）的次数来代表“运行时间”。Karatsuba 算法将两个 $n$ 位数的乘法简化为固定数量的对大约一半大小输入的乘法，此外还有用于加法和移位的线性时间开销。小学乘法算法执行两个 $n$ 位数的乘法，需要二次数量级的单位数乘法。\n- 为了经验性地估计假设定律 $t(n) = c\\,n^{\\alpha}$（其中常数 $c0$）中的指数 $\\alpha$，只需应用对数并拟合一条直线 $y = \\alpha x + b$，其中 $x = \\ln n$， $y = \\ln t(n)$，且 $b = \\ln c$。斜率 $\\alpha$ 可以通过普通最小二乘法 (OLS) 估计。\n\n您的程序必须：\n1) 为两种针对长度为 $n$ 的数字字符串（在任何固定基数下）的乘法策略实现一个计数模型，该模型返回一个代理“时间”$t(n)$，等于算法在长度为 $n$ 的最坏情况输入上执行的单位数乘法次数。\n   - 对于小学乘法算法，利用它执行 $n^2$ 次单位数乘法这一基本事实；设置 $t_{\\text{grade}}(n) = n^2$。\n   - 对于 Karatsuba 算法，实现一个递推关系，用于在分治法下计算单位数乘法次数，并带有一个可调的基础情形阈值 $b$。具体来说，对于 $n \\le b$，使用小学乘法成本 $n^2$ 作为基础情形；对于 $n  b$，将 $n$ 分为两部分 $n_{\\text{high}} = \\lceil n/2 \\rceil$ 和 $n_{\\text{low}} = \\lfloor n/2 \\rfloor$，并计算对子问题规模 $n_{\\text{high}}$、$n_{\\text{low}}$ 和 $\\max(n_{\\text{high}}, n_{\\text{low}})$ 的三次递归乘法。这模拟了分治重组后执行的三次子乘法，而加法和移位不计入 $t(n)$（在使用足够大的 $n$ 时，它们不会改变拟合的指数）。递推关系式为\n   $$\n   t_{\\text{kara}}(n) = \n   \\begin{cases}\n   n^2,  \\text{if } n \\le b \\\\\n   t_{\\text{kara}}(n_{\\text{high}}) + t_{\\text{kara}}(n_{\\text{low}}) + t_{\\text{kara}}(\\max\\{n_{\\text{high}}, n_{\\text{low}}\\}),  \\text{if } n  b\n   \\end{cases}\n   $$\n   其中 $n_{\\text{high}} = \\lceil n/2 \\rceil$ 且 $n_{\\text{low}} = \\lfloor n/2 \\rfloor$。\n\n2) 对于每个提供的测试用例，生成一个输入大小序列 $\\{n_i\\}$，计算指定算法对应的计数值 $\\{t(n_i)\\}$，然后通过对数据对 $(\\ln n_i, \\ln t(n_i))$ 进行 OLS 来估计 $\\alpha$。使用自然对数。拟合的斜率即为估计值 $\\widehat{\\alpha}$。\n\n3) 为了与理论进行比较，计算估计值相对于理论指数的绝对误差，该理论指数通过主定理框架求解标准分治递推关系得到。对于 Karatsuba 方法，理论指数是满足三个规模减半子问题和低阶工作量情况的齐次递推解的唯一 $\\alpha$；对于小学乘法方法，理论指数是二次工作量定律的指数。\n\n您的程序需要执行的测试套件如下。每个测试用例指定了算法、基础情形阈值 $b$（仅用于 Karatsuba）以及用于拟合模型的尺寸列表 $\\{n_i\\}$：\n- 测试 1（理想路径，2的幂次大小，中等阈值）：Karatsuba 算法，$b = 16$，尺寸为 $[16, 32, 64, 128, 256]$。\n- 测试 2（理想路径，较大阈值）：Karatsuba 算法，$b = 32$，尺寸为 $[32, 64, 128, 256, 512]$。\n- 测试 3（边界情况，激进递归）：Karatsuba 算法，$b = 1$，尺寸为 $[8, 16, 32, 64, 128]$。\n- 测试 4（对照组，二次基线）：小学乘法算法，尺寸为 $[16, 32, 64, 128, 256]$。\n- 测试 5（非2的幂次大小，用于测试不均匀划分）：Karatsuba 算法，$b = 8$，尺寸为 $[30, 60, 120, 240, 480]$。\n\n对于每个测试用例，您的程序必须输出两个浮点数：\n- 拟合的指数 $\\widehat{\\alpha}$。\n- 绝对误差 $|\\widehat{\\alpha} - \\alpha_{\\text{theory}}|$，其中对于 Karatsuba 算法，$\\alpha_{\\text{theory}}$ 是求解三路减半递推的理论指数；对于小学乘法算法，$\\alpha_{\\text{theory}}$ 是二次指数。\n\n最终输出格式：您的程序应生成一行输出，其中包含一个用逗号分隔并用方括号括起来的结果列表。该列表必须按顺序包含测试 1 的数据对，然后是测试 2、测试 3、测试 4 和测试 5 的数据对。例如，输出应具有以下形式\n$[\\widehat{\\alpha}_1,\\text{err}_1,\\widehat{\\alpha}_2,\\text{err}_2,\\widehat{\\alpha}_3,\\text{err}_3,\\widehat{\\alpha}_4,\\text{err}_4,\\widehat{\\alpha}_5,\\text{err}_5]$。\n所有数字都必须打印为十进制浮点值。本问题不涉及物理单位。", "solution": "本问题的目标是进行一个计算实验，以经验性地验证 Karatsuba 乘法算法的理论时间复杂度。这包括实现一个计算基本乘法次数的计数模型，对生成的数据进行统计分析，并将经验结果与从分治分析中得出的既定理论指数进行比较。\n\n### 1. 理论框架与估计方法\n\n许多算法（特别是基于分治的算法）的时间复杂度可以对大小为 $n$ 的输入用以下形式的幂律进行建模：\n$$\nt(n) \\approx c \\cdot n^{\\alpha}\n$$\n其中 $t(n)$ 代表基本操作的数量（运行时间的代理指标），$c$ 是一个与实现细节和开销相关的常数，$\\alpha$ 是表征算法效率的渐近标度指数。\n\n为了经验性地估计指数 $\\alpha$，我们可以通过对两边取自然对数，将这个幂律关系转化为线性关系：\n$$\n\\ln(t(n)) = \\ln(c \\cdot n^{\\alpha}) = \\ln(c) + \\alpha \\ln(n)\n$$\n这个方程是一条直线的形式，$y = b + \\alpha x$，其中 $y = \\ln(t(n))$，$x = \\ln(n)$，y轴截距为 $b = \\ln(c)$。给定来自计算实验的一组数据点 $(n_i, t(n_i))$，我们可以生成一组变换后的点 $(x_i, y_i) = (\\ln(n_i), \\ln(t(n_i)))$。然后，指数 $\\alpha$ 可以通过普通最小二乘法 (OLS) 估计为通过这些点的最佳拟合直线的斜率。\n\n对于一组 $N$ 个数据点 $\\{(x_i, y_i)\\}_{i=1}^N$，斜率的 OLS 估计值（表示为 $\\widehat{\\alpha}$）由以下公式给出：\n$$\n\\widehat{\\alpha} = \\frac{\\sum_{i=1}^{N} (x_i - \\bar{x})(y_i - \\bar{y})}{\\sum_{i=1}^{N} (x_i - \\bar{x})^2}\n$$\n其中 $\\bar{x}$ 和 $\\bar{y}$ 分别是 $x_i$ 和 $y_i$ 值的样本均值。\n\n### 2. 算法模型与理论指数\n\n该实验考虑两种乘法算法：\n\n**小学乘法：**\n用于乘以两个 $n$ 位数的标准小学乘法方法执行 $n \\times n = n^2$ 次单位数乘法。因此，计数函数为：\n$$\nt_{\\text{grade}}(n) = n^2\n$$\n从这个二次关系中，理论指数恰好是 $\\alpha_{\\text{grade}} = 2$。\n\n**Karatsuba 乘法：**\nKaratsuba 算法是一种分治策略。问题为计算单位数乘法次数指定了一个精确的递推关系，其中包括一个基础情形阈值 $b$。对于大小为 $n$ 的输入：\n$$\nt_{\\text{kara}}(n, b) = \n\\begin{cases}\nn^2,  \\text{if } n \\le b \\\\\nt_{\\text{kara}}(n_{\\text{high}}, b) + t_{\\text{kara}}(n_{\\text{low}}, b) + t_{\\text{kara}}(\\max\\{n_{\\text{high}}, n_{\\text{low}}\\}, b),  \\text{if } n  b\n\\end{cases}\n$$\n其中 $n_{\\text{high}} = \\lceil n/2 \\rceil$ 且 $n_{\\text{low}} = \\lfloor n/2 \\rfloor$。根据定义，$n_{\\text{high}} \\ge n_{\\text{low}}$，因此 $\\max\\{n_{\\text{high}}, n_{\\text{low}}\\}$ 项简化为 $n_{\\text{high}}$。递推关系变为：\n$$\nt_{\\text{kara}}(n, b) = 2 \\cdot t_{\\text{kara}}(\\lceil n/2 \\rceil, b) + t_{\\text{kara}}(\\lfloor n/2 \\rfloor, b)\n$$\nKaratsuba 算法的标准渐近分析考虑简化的递推式 $T(n) = 3T(n/2) + O(n)$，它忽略了向上/向下取整函数和附加的低阶项。对该递推式应用主定理（其中 $a=3, b=2$），其复杂度由递归调用主导，得到 $T(n) = \\Theta(n^{\\log_b a}) = \\Theta(n^{\\log_2 3})$。因此，理论指数是：\n$$\n\\alpha_{\\text{kara}} = \\log_2 3 \\approx 1.58496\n$$\n这个理论值将作为基准，与我们的经验估计值 $\\widehat{\\alpha}$ 进行比较。\n\n### 3. 实验设计与流程\n\n程序将执行问题陈述中定义的一系列测试。对于每个测试，执行以下步骤：\n1. 使用适当的计数函数（$t_{\\text{grade}}$ 或 $t_{\\text{kara}}$）为给定的输入大小列表 $\\{n_i\\}$ 生成操作计数值 $\\{t(n_i)\\}$。对于递归函数 $t_{\\text{kara}}$，采用记忆化（缓存）来避免重复计算并确保效率。\n2. 将数据转换为对数-对数尺度，生成点 $(x_i, y_i) = (\\ln(n_i), \\ln(t(n_i)))$。\n3. 将 OLS 公式应用于变换后的点，以计算估计的指数 $\\widehat{\\alpha}$。\n4. 计算绝对误差 $|\\widehat{\\alpha} - \\alpha_{\\text{theory}}|$，其中对于小学乘法算法 $\\alpha_{\\text{theory}}$ 是 $2$，对于 Karatsuba 算法 $\\alpha_{\\text{theory}}$ 是 $\\log_2 3$。\n5. 存储得到的数据对 $(\\widehat{\\alpha}, |\\widehat{\\alpha} - \\alpha_{\\text{theory}}|)$。\n\n最终输出将所有测试用例的这些数据对聚合到一个单一的、格式化的列表中。这些测试用例旨在探索算法在不同条件下的行为，例如不同的基础情形阈值、2的幂次的输入大小，以及非2的幂次的输入大小（用于测试递推中的不均匀划分）。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the computational experiment and print the results.\n    \"\"\"\n\n    def get_kara_counter(b):\n        \"\"\"\n        Creates a memoized recursive function to count multiplications for Karatsuba.\n        A closure is used to maintain a private cache for a given base-case threshold b.\n        \"\"\"\n        memo = {}\n\n        def t_kara(n):\n            if n in memo:\n                return memo[n]\n            \n            if n = b:\n                result = n * n\n                memo[n] = result\n                return result\n\n            n_high = (n + 1) // 2  # Integer equivalent of math.ceil(n / 2)\n            n_low = n // 2         # Integer equivalent of math.floor(n / 2)\n            \n            # The recurrence given is t(n) = t(n_high) + t(n_low) + t(max(n_high, n_low)).\n            # Since n_high >= n_low, this simplifies to 2 * t(n_high) + t(n_low).\n            result = 2 * t_kara(n_high) + t_kara(n_low)\n            memo[n] = result\n            return result\n\n        return t_kara\n\n    def t_grade(n):\n        \"\"\"\n        Counts multiplications for the grade-school algorithm.\n        \"\"\"\n        return n * n\n\n    def estimate_exponent_ols(n_values, t_values):\n        \"\"\"\n        Estimates the exponent alpha from (n, t) data using OLS on log-log data.\n        \"\"\"\n        if len(n_values)  2:\n            return np.nan # Cannot fit a line to fewer than 2 points\n\n        x = np.log(n_values)\n        y = np.log(t_values)\n        \n        x_mean = np.mean(x)\n        y_mean = np.mean(y)\n        \n        numerator = np.sum((x - x_mean) * (y - y_mean))\n        denominator = np.sum((x - x_mean)**2)\n        \n        if denominator == 0:\n            return np.nan # all n_values were the same\n            \n        alpha_hat = numerator / denominator\n        return alpha_hat\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'id': 1, 'algo': 'karatsuba', 'b': 16, 'n': [16, 32, 64, 128, 256]},\n        {'id': 2, 'algo': 'karatsuba', 'b': 32, 'n': [32, 64, 128, 256, 512]},\n        {'id': 3, 'algo': 'karatsuba', 'b': 1,  'n': [8, 16, 32, 64, 128]},\n        {'id': 4, 'algo': 'grade-school', 'n': [16, 32, 64, 128, 256]},\n        {'id': 5, 'algo': 'karatsuba', 'b': 8,  'n': [30, 60, 120, 240, 480]},\n    ]\n    \n    # Theoretical exponents\n    alpha_theory_kara = np.log(3) / np.log(2)\n    alpha_theory_grade = 2.0\n    \n    all_results = []\n\n    for case in test_cases:\n        n_values = np.array(case['n'])\n        \n        if case['algo'] == 'karatsuba':\n            b = case['b']\n            counter_func = get_kara_counter(b)\n            t_values = np.array([counter_func(n) for n in n_values])\n            alpha_theory = alpha_theory_kara\n        else: # grade-school\n            t_values = np.array([t_grade(n) for n in n_values])\n            alpha_theory = alpha_theory_grade\n\n        # Estimate exponent and calculate error\n        alpha_hat = estimate_exponent_ols(n_values, t_values)\n        error = np.abs(alpha_hat - alpha_theory)\n        \n        all_results.extend([alpha_hat, error])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "3243158"}]}