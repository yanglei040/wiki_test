{"hands_on_practices": [{"introduction": "理论学习之后，我们首先通过一个核心的编程实践来巩固基础。这个练习要求我们实现一个“惰性”迭代器，它能够按需生成幂集的每一个子集，而不是一次性将所有 $2^n$ 个子集全部加载到内存中。这种方法不仅是内存高效的，也是许多现实世界应用中的标准做法，它能让我们深刻理解整数与子集之间的一一对应关系是如何在代码中实现的 [@problem_id:3259468]。", "problem": "要求您实现一个完整的、可运行的程序，为有限的不同整数序列构建一个“惰性”幂集迭代器。该迭代器必须仅在显式请求时计算下一个子集，而不在内存中预计算或物化整个幂集。此任务的基本依据是幂集的数学定义以及子集与二进制指示向量之间已明确建立的双射关系。对于一个包含 $n$ 个不同元素的有限集 $S$，其幂集 $\\mathcal{P}(S)$ 是 $S$ 的所有子集的集合，其基数为 $2^n$。通过将二进制字符串中的每个位置 $i$ 映射到 $S$ 的第 $i$ 个元素是否存在，$\\mathcal{P}(S)$ 与所有长度为 $n$ 的二进制字符串集合 $\\{0,1\\}^n$ 之间存在一个双射。将指示向量的整数解释视为一个无符号数，其中最低有效位（定义为 Least Significant Bit (LSB)）对应输入序列的第一个元素，下一个位对应第二个元素，依此类推。所要求的子集枚举顺序是按照相应指示向量的整数值升序排列，从整数 $0$（映射到空子集）开始，到整数 $2^n - 1$ 结束。\n\n程序要求：\n- 实现一个 $\\mathcal{P}(S)$ 的“惰性”迭代器，该迭代器仅在显式推进时才生成下一个子集，任何时候物化的子集不超过当前这一个。除存储输入序列外，空间开销必须为 $\\mathcal{O}(n)$，其中 $n$ 是输入序列的长度。\n- 枚举顺序必须严格按照指示向量的整数值升序排列，且 LSB 与输入序列的第一个元素对齐。\n- 程序必须包含一个带有多个参数集的内部测试套件，并生成单行输出，其中包含所有测试用例的聚合结果，格式为一个由方括号括起来、不含空格的逗号分隔列表。每个测试用例的结果必须是一个子集列表，其中每个子集表示为一个整数列表。\n\n测试套件规范：\n- 每个测试用例由一对 $(A, k)$ 组成，其中 $A$ 是一个有限的不同整数序列，$k$ 是一个非负整数，指定从迭代器请求多少个连续子集（从空子集开始）。如果 $k$ 超过 $2^{|A|}$，迭代器应在生成 $2^{|A|}$ 个子集后自然停止。\n- 使用以下用例：\n  - 用例 1：$A = [\\,]$, $k = 1$。\n  - 用例 2：$A = [\\,7\\,]$, $k = 2$。\n  - 用例 3：$A = [\\,1,2,3\\,]$, $k = 4$。\n  - 用例 4：$A = [\\,2,4,6,8\\,]$, $k = 9$。\n  - 用例 5：$A = [\\,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20\\,]$, $k = 5$。\n\n答案规范：\n- 对于每个用例，答案是由惰性迭代器按指定顺序生成的前 $k$ 个子集的列表。每个子集本身是从输入序列中提取的整数列表。\n- 最终程序输出必须是单行文本，包含所有测试用例的聚合结果，格式为一个由方括号括起来、不含空格的逗号分隔列表。例如，如果有三个测试用例，其结果分别为 $R_1$、$R_2$ 和 $R_3$，则确切的输出格式应为 $[R_1,R_2,R_3]$，其中每个 $R_i$ 是一个整数列表的列表（用方括号打印）。\n\n不允许用户输入。此问题不涉及物理量，因此无需指定单位。不出现角度和百分比。程序必须遵守指定的执行环境，并严格按照上述格式生成最终输出。", "solution": "为给定的不同整数序列生成幂集的问题是一个源于集合论的经典组合任务，也是算法设计的基础。基于双射的数学原理，可以构建一个直接且高效的解决方案。\n\n对于一个基数为 $|S| = n$ 的有限集 $S$，其幂集（记为 $\\mathcal{P}(S)$）是 $S$ 的所有可能子集的集合。幂集的基数为 $|\\mathcal{P}(S)| = 2^n$。在 $\\mathcal{P}(S)$ 中的子集与所有长度为 $n$ 的二进制字符串集合之间，存在一种一一对应关系（即双射）。\n\n这种双射可以通过考虑一个来自 $S$ 的有序元素序列，例如 $s_0, s_1, \\dots, s_{n-1}$ 来建立。$S$ 的任何子集都可以由一个 $n$ 位二进制指示向量 $b = (b_{n-1}, \\dots, b_1, b_0)$ 唯一表示，其中如果元素 $s_j$ 存在于子集中，则位 $b_j$ 为 $1$，否则为 $0$。\n\n问题规定了精确的映射和枚举顺序。所有 $n$ 位二进制向量的集合对应于从 $0$ 到 $2^n - 1$ 的整数。子集的枚举必须遵循这些整数的升序。位与元素之间的映射定义为：最低有效位（LSB）或位 $0$ 对应输入序列的第一个元素（索引为 $0$），位 $1$ 对应第二个元素（索引为 $1$），依此类推，直到位 $n-1$ 对应第 $n$ 个元素。\n\n任务是创建一个“惰性”迭代器，它仅在被请求时才生成每个子集，而不是在内存中物化整个幂集。这对于效率至关重要，因为幂集的大小随输入序列的大小呈指数级增长。所要求的 $\\mathcal{O}(n)$ 的空间复杂度开销排除了存储所有 $2^n$ 个子集的可能性。\n\n一个满足这些要求的算法可以设计如下：\n1.  设输入序列为 $A$，长度为 $n$。\n2.  子集的总数为 $N = 2^n$。这在代码中通常用 `1  n` 实现。\n3.  我们使用一个计数器，称之为 `i`，它从 $0$ 迭代到 $N-1$。`i` 的每个值唯一地标识一个子集。\n4.  对于每个整数 `i`，我们动态地构建相应的子集。为此，我们从 $j = 0$ 迭代到 $n-1$。在每一步 $j$，我们检查 `i` 的第 $j$ 位是否设置为 $1$。\n5.  检查 `i` 的第 $j$ 位可以使用位运算高效地执行。表达式 `(i >> j)  1` 的值为 $1$ 当且仅当 `i` 的第 $j$ 位被设置。`>>` 运算符是右移位操作，`` 是按位与操作。\n6.  如果第 $j$ 位是 $1$，我们将输入序列中索引为 $j$ 的元素 $A[j]$ 包含在当前子集中。\n7.  对每个请求的子集重复此过程，迭代器在每次后续调用时将计数器 `i` 加一。\n\n在 Python 中，实现这种惰性迭代最地道的方式是使用生成器函数。生成器函数使用 `yield` 关键字返回一个值并暂停其执行，同时保留其内部状态（在此例中是计数器 `i`）。当请求下一个值时，函数从其暂停处恢复执行。这种方法自然地满足了惰性求值和 $\\mathcal{O}(n)$ 空间复杂度的要求，因为它只存储输入序列、计数器的当前状态以及正在构建的单个子集所需的内存。\n\n最终的程序将实现这个生成器。然后，它将遍历指定的测试用例。对于每个用例 $(A, k)$，它将创建一个新的生成器实例，并检索前 $k$ 个子集，如果子集总数小于 $k$，则检索更少的子集。所有测试用例的结果被聚合到一个列表中，然后根据特定的输出要求，格式化为一个不含空格的字符串表示形式。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef lazy_power_set(sequence):\n    \"\"\"\n    A lazy iterator (generator) for the power set of a sequence.\n\n    The enumeration order follows the ascending integer value of the\n    binary indicator vector, where the LSB corresponds to the first\n    element of the sequence.\n\n    Args:\n        sequence (list): A list of distinct elements.\n\n    Yields:\n        list: The next subset in the enumeration.\n    \"\"\"\n    n = len(sequence)\n    num_subsets = 1  n  # This is equivalent to 2**n\n\n    for i in range(num_subsets):\n        subset = []\n        for j in range(n):\n            # Check if the j-th bit of i is set.\n            # (i >> j) shifts the j-th bit to the LSB position.\n            #  1 isolates this bit.\n            if (i >> j)  1:\n                subset.append(sequence[j])\n        yield subset\n\ndef format_list_no_spaces(obj):\n    \"\"\"\n    Recursively formats a list or other object into a string\n    representation without spaces after commas, as required by the spec.\n    \"\"\"\n    if isinstance(obj, list):\n        # Recursively format each item and join with commas.\n        return f\"[{','.join(format_list_no_spaces(item) for item in obj)}]\"\n    else:\n        # For non-list items, use their standard string representation.\n        return str(obj)\n\ndef solve():\n    \"\"\"\n    Defines and runs the test suite, then prints the formatted results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        ([], 1),\n        ([7], 2),\n        ([1, 2, 3], 4),\n        ([2, 4, 6, 8], 9),\n        ([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20], 5),\n    ]\n\n    all_results = []\n    for A, k in test_cases:\n        case_result = []\n        iterator = lazy_power_set(A)\n        \n        try:\n            for _ in range(k):\n                case_result.append(next(iterator))\n        except StopIteration:\n            # This handles cases where k > 2**|A|. The loop will\n            # naturally terminate when the iterator is exhausted.\n            pass\n            \n        all_results.append(case_result)\n\n    # Final print statement in the exact required format.\n    # The custom formatter ensures no spaces are included in the list representations.\n    print(format_list_no_spaces(all_results))\n\nsolve()\n```", "id": "3259468"}, {"introduction": "掌握了如何遍历所有子集后，下一个挑战是展示我们对位掩码（bitmask）表示法的深刻理解。这个练习不再需要我们生成整个序列，而是要求我们直接定位并构造出幂集有序排列中的第 $k$ 个子集 [@problem_id:3259420]。通过直接利用索引 $k-1$ 的二进制表示，我们可以一步到位地确定子集的构成，这完美地体现了数学模型在解决组合问题时的精妙与高效。", "problem": "考虑一个基础集合 $S = \\{a_{0}, a_{1}, \\dots, a_{n-1}\\}$ 以及 $S$ 的子集的规范位掩码编码：一个子集对应一个 $n$ 位向量 $\\langle b_{n-1}, \\dots, b_{1}, b_{0}\\rangle$，其中 $b_{i} \\in \\{0,1\\}$，并且当且仅当 $b_{i} = 1$ 时，元素 $a_{i}$ 被包含在子集中。定义子集上的位掩码顺序为全序，该全序通过将每个位向量解释为以2为基数的非负整数（最低有效位 $b_{0}$ 对应于 $a_{0}$）而导出，并按此整数值的升序对子集进行排序。在此顺序中，对子集使用从1开始的索引，因此第一个子集是空集，其位掩码值为 $0$。\n\n设 $n = 64$，并定义元素的权重为 $w_{i} = i^{2} + i + 1$，对所有 $i \\in \\{0,1,\\dots,63\\}$ 成立。设 $k$ 由下式给出\n$$\nk = 1 + 2^{0} + 2^{1} + 2^{4} + 2^{5} + 2^{7} + 2^{12} + 2^{20} + 2^{31} + 2^{45} + 2^{63}.\n$$\n在不生成前面的 $k-1$ 个子集的情况下，确定按位掩码顺序排列的第 $k$ 个子集的总权重，其定义为 $\\sum_{a_{i} \\in T} w_{i}$，其中 $T$ 是第 $k$ 个子集。将你的最终结果表示为一个精确整数。不需要四舍五入。", "solution": "问题要求我们确定给定集合 $S = \\{a_{0}, a_{1}, \\dots, a_{n-1}\\}$ 的一个特定子集的总权重。子集的选择基于一个明确定义的排序。我将首先验证问题陈述，然后进行严谨的求解。\n\n### 问题验证\n该问题在离散数学和计算机科学领域是适定的，并有科学依据。\n- **已知条件**:\n    - 一个基础集合 $S = \\{a_{0}, a_{1}, \\dots, a_{n-1}\\}$，其中 $n=64$。\n    - 一种位掩码编码，其中一个子集对应一个位向量 $\\langle b_{n-1}, \\dots, b_{0}\\rangle$，当 $b_{i}=1$ 时，元素 $a_{i}$ 被包含在内。\n    - 一个“位掩码顺序”，基于位向量的升序整数值，该整数为 $M = \\sum_{i=0}^{n-1} b_i 2^i$。\n    - 在此顺序中对子集使用从1开始的索引。\n    - 元素的权重由函数 $w_{i} = i^{2} + i + 1$ 给出，其中 $i \\in \\{0, 1, \\dots, 63\\}$。\n    - 目标子集的索引为 $k = 1 + 2^{0} + 2^{1} + 2^{4} + 2^{5} + 2^{7} + 2^{12} + 2^{20} + 2^{31} + 2^{45} + 2^{63}$。\n- **验证检查**:\n    - 问题陈述是内部一致的。位掩码表示、按整数值排序和从1开始的索引等概念是标准的且定义清晰。\n    - 它在科学上和数学上是合理的。没有违反任何原则。\n    - 问题是完整的；为得到唯一解提供了所有必要的数据和定义。\n    - 问题是客观和形式化的。\n因此，该问题被认为是**有效的**。\n\n### 求解推导\n\n“位掩码顺序”根据子集对应的位掩码向量的整数值对 $S$ 的子集进行排序。问题指定了对这个有序子集列表使用从1开始的索引。第一个子集（索引为1）是空集，其位掩码全为零，对应整数值 $0$。第二个子集（索引为2）对应整数值 $1$，以此类推。一般而言，此顺序中索引为 $j$ 的子集对应于表示整数值 $j-1$ 的位掩码。\n\n我们的目标是求出给定的第 $k$ 个子集的总权重。根据索引规则，第 $k$ 个子集对应的整数值为 $M = k-1$。我们来计算这个整数值：\n$$\nk = 1 + 2^{0} + 2^{1} + 2^{4} + 2^{5} + 2^{7} + 2^{12} + 2^{20} + 2^{31} + 2^{45} + 2^{63}\n$$\n第 $k$ 个子集的位掩码的整数值为 $M = k-1$。代入 $k$ 的表达式：\n$$\nM = \\left(1 + 2^{0} + 2^{1} + 2^{4} + 2^{5} + 2^{7} + 2^{12} + 2^{20} + 2^{31} + 2^{45} + 2^{63}\\right) - 1\n$$\n由于 $2^{0} = 1$，我们可以简化这个表达式：\n$$\nM = 2^{0} + 2^{1} + 2^{4} + 2^{5} + 2^{7} + 2^{12} + 2^{20} + 2^{31} + 2^{45} + 2^{63}\n$$\n这个表达式是整数 $M$ 的二进制（以2为基数）表示。这个和中的一项 $2^i$ 表示位向量 $\\langle b_{63}, \\dots, b_0 \\rangle$ 中的位 $b_i$ 等于 $1$。根据定义，当且仅当 $b_i=1$ 时，元素 $a_i$ 被包含在子集中。\n\n从 $M$ 的表达式可知，使得 $b_i=1$ 的索引 $i$ 的集合是：\n$$\nI = \\{0, 1, 4, 5, 7, 12, 20, 31, 45, 63\\}\n$$\n因此，第 $k$ 个子集，我们称之为 $T_k$，由元素 $\\{a_i \\mid i \\in I\\}$ 组成。\n\n该子集的总权重是其元素的权重之和。元素 $a_i$ 的权重由 $w_i = i^2 + i + 1$ 给出。总权重 $W$ 为：\n$$\nW = \\sum_{i \\in I} w_i = \\sum_{i \\in \\{0, 1, 4, 5, 7, 12, 20, 31, 45, 63\\}} (i^2 + i + 1)\n$$\n我们计算和的每一项：\n- 对于 $i=0$：$w_0 = 0^2 + 0 + 1 = 1$。\n- 对于 $i=1$：$w_1 = 1^2 + 1 + 1 = 3$。\n- 对于 $i=4$：$w_4 = 4^2 + 4 + 1 = 16 + 4 + 1 = 21$。\n- 对于 $i=5$：$w_5 = 5^2 + 5 + 1 = 25 + 5 + 1 = 31$。\n- 对于 $i=7$：$w_7 = 7^2 + 7 + 1 = 49 + 7 + 1 = 57$。\n- 对于 $i=12$：$w_{12} = 12^2 + 12 + 1 = 144 + 12 + 1 = 157$。\n- 对于 $i=20$：$w_{20} = 20^2 + 20 + 1 = 400 + 20 + 1 = 421$。\n- 对于 $i=31$：$w_{31} = 31^2 + 31 + 1 = 961 + 31 + 1 = 993$。\n- 对于 $i=45$：$w_{45} = 45^2 + 45 + 1 = 2025 + 45 + 1 = 2071$。\n- 对于 $i=63$：$w_{63} = 63^2 + 63 + 1 = 3969 + 63 + 1 = 4033$。\n\n现在，我们将这些单独的权重相加，求得总权重 $W$：\n$$\nW = 1 + 3 + 21 + 31 + 57 + 157 + 421 + 993 + 2071 + 4033\n$$\n我们来进行求和：\n$1 + 3 = 4$\n$4 + 21 = 25$\n$25 + 31 = 56$\n$56 + 57 = 113$\n$113 + 157 = 270$\n$270 + 421 = 691$\n$691 + 993 = 1684$\n$1684 + 2071 = 3755$\n$3755 + 4033 = 7788$\n\n第 $k$ 个子集的总权重是 $7788$。这个结果是按照要求，通过直接确定特定子集的构成元素而得到的，没有生成任何其他子集。计算是精确的，不需要四舍五入。", "answer": "$$\\boxed{7788}$$", "id": "3259420"}, {"introduction": "在许多实际问题中，我们通常只对满足特定条件的子集感兴趣，而非全部子集。直接生成整个幂集再进行筛选（“先生成后测试”）的策略往往效率低下。这个高级实践将引导我们学习一种更智能的算法：利用属性的单调性进行剪枝的回溯搜索 [@problem_id:3259478]。通过在搜索过程中提前排除不符合条件的分支，我们可以极大地优化计算过程，这正是从基础算法迈向高级组合优化技术的关键一步。", "problem": "给定一个长度为 $n$ 的有限整数序列 $A$，以及一个定义在幂集 $\\mathcal{P}(A)$ 上的谓词 $Q$。谓词 $Q$ 在子集格 $(\\mathcal{P}(A), \\subseteq)$ 上是单调的，其单调性表现为两种情况之一：向下封闭（遗传单调）或向上封闭（扩展单调）。如果对于一个谓词 $Q$，当 $Q(S)$ 为真且 $T \\subseteq S$ 时，$Q(T)$ 也为真，则称该谓词是向下封闭的。如果对于一个谓词 $Q$，当 $Q(S)$ 为真且 $S \\subseteq T$ 时，$Q(T)$ 也为真，则称该谓词是向上封闭的。任务是实现一个回溯算法，该算法利用 $Q$ 的单调性来剪枝搜索空间，从而只生成那些满足 $Q(S)$ 为真的子集 $S \\subseteq A$。\n\n从子集格和单调性的基本定义出发，并基于第一性原理设计算法：对一个二元决策树进行深度优先遍历，在每个位置 $i$ 决定是包含 $A[i]$ 还是排除 $A[i]$。从单调性推导出剪枝规则，不使用任何捷径公式。对于向下封闭的 $Q$，如果一个部分选择 $S$ 不满足 $Q$，那么 $S$ 的任何超集也都不满足 $Q$，因此可以对该分支进行剪枝。对于向上封闭的 $Q$，如果一个部分选择 $S$ 已经满足 $Q$，那么 $S$ 的任何超集也都将满足 $Q$，此时可以生成剩余元素的所有组合补全，而无需进一步检查。此外，对于向上封闭的 $Q$，如果即使加上所有剩余元素也无法满足该性质，则应剪枝该分支。\n\n$A$ 的元素是无物理单位的整数。此任务不涉及角度或百分比。\n\n实现该算法以处理以下测试套件。对于每个测试用例，都指定了 $A$、一个单调谓词 $Q$ 以及任何所需参数。对于每个测试用例，按照从左到右扫描 $A$ 并以“先排除后包含”的固定顺序进行分支所获得的确定性顺序列出所有满足条件的子集。将每个子集表示为按 $A$ 中原始顺序排列的整数列表。\n\n测试套件：\n- 案例 1 (向下封闭)：$A = [1,2,3]$，$Q$ 为 “$\\sum_{x \\in S} x \\le T$”，其中 $T = 3$。\n- 案例 2 (向上封闭)：$A = [2,3,5]$，$Q$ 为 “$\\sum_{x \\in S} x \\ge L$”，其中 $L = 7$。\n- 案例 3 (向下封闭)：$A = [1,4,6,7]$，$Q$ 为 “$|S| \\le k$”，其中 $k = 2$。\n- 案例 4 (向上封闭)：$A = [3,5,8,10]$，$Q$ 为 “集合 $S$ 至少包含一个偶数元素”。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个结果是对应测试用例的满足条件的子集列表。例如，总体格式为 $[r_1,r_2,r_3,r_4]$，其中 $r_i$ 是一个整数列表的列表。程序必须是自包含的，不需要任何输入，并且仅计算指定测试套件的输出。", "solution": "我们将搜索空间形式化为定义在长度为 $n$ 的有限序列 $A$ 上的子集格 $(\\mathcal{P}(A), \\subseteq)$。深度优先搜索（DFS）回溯遍历访问由位置 $i \\in \\{0,1,\\dots,n\\}$ 和一个部分选择 $S \\subseteq \\{A[0],A[1],\\dots,A[i-1]\\}$ 索引的节点。在每一步，算法选择排除 $A[i]$ 或包含 $A[i]$，然后前进到 $i+1$。\n\n剪枝设计源于单调性的定义：\n\n- 向下封闭谓词 $Q$：如果一个部分集 $S$ 不满足 $Q$（例如，对于 $Q_{\\le\\mathrm{sum}}$，其和已超过 $T$），根据向下封闭的定义，任何超集 $T' \\supseteq S$ 也必定不满足 $Q$。因此，一旦某个节点不满足 $Q$，其下的整个子树都可以被剪枝。这避免了对不可能产生满足条件集合的分支的探索。\n\n- 向上封闭谓词 $Q$：如果一个部分集 $S$ 满足 $Q$，根据向上封闭的定义，任何超集 $T' \\supseteq S$ 也满足 $Q$。因此，一旦某个节点满足 $Q$，算法就可以枚举剩余位置 $i,i+1,\\dots,n-1$ 上的所有补全组合，并输出所有 $S \\cup R$（其中 $R \\subseteq \\{A[i],\\dots,A[n-1]\\}$）的组合，而无需进一步进行性质检查。此外，我们引入一个不可能界限：如果即使将所有剩余元素以最有利的方式添加也无法使 $S$ 满足 $Q$，则该分支被剪枝。\n\n我们使用经过充分检验的事实和直接界限为测试套件实例化 $Q$：\n\n- 对于 $Q_{\\le\\mathrm{sum}}$：维护运行总和 $s(S) = \\sum_{x \\in S} x$。如果在任何节点 $s(S) > T$，则剪掉该分支，因为任何非负元素的添加都会使得超集 $T'$ 的和 $s(T') \\ge s(S)$，从而保持 $s(T') > T$，因此违反向下封闭性质。\n\n- 对于 $Q_{\\ge\\mathrm{sum}}$：维护运行总和 $s(S)$。设 $M_i = \\sum_{j=i}^{n-1} A[j]$ 为从后缀可实现的最大额外总和。如果 $s(S) + M_i  L$，则没有超集能达到阈值，该分支被剪枝。如果 $s(S) \\ge L$，该分支已满足 $Q$，我们枚举所有后缀补全。这些界限源于和是可加的，且元素为非负。\n\n- 对于 $Q_{\\le\\mathrm{card}}$：维护 $c(S) = |S|$。如果在任何节点 $c(S) > k$，则由于基数约束的向下封闭性而剪枝。\n\n- 对于 $Q_{\\exists\\mathrm{even}}$：维护一个布尔值 $e(S)$，指示 $S$ 是否已包含偶数元素。如果 $e(S)$ 为真，则枚举所有后缀补全。如果 $e(S)$ 为假且剩余后缀中不含偶数元素，则任何超集都永远无法满足 $Q$，因此剪枝。不可能界限来自于一个观察：该性质仅取决于是否存在至少一个偶数元素。\n\n遍历顺序是固定的：在每个位置 $i$，我们按照“先排除后包含”的方式分支，确保输出的确定性排序。将每个子集 $S$ 表示为其元素按 $A$ 中原始顺序排列的列表。\n\n从复杂度角度看：在没有剪枝的最坏情况下，生成幂集需要 $O(2^n)$ 的时间。通过单调性剪枝，算法只探索可能产生满足条件集合的分支。对于向上封闭的性质，一旦谓词被满足，它会用后缀组合的直接枚举替换整个子树的遍历。因此，运行时间与满足条件的子集数量和探索的节点数成比例。通过预计算后缀摘要（如后缀和或后缀属性），每个节点的检查和状态更新开销可以达到 $O(1)$（对于后缀补全的生成，则是摊销的）。\n\n应用这些基于原理的规则，可以为给定的测试套件生成一个正确且高效的生成器。输出被聚合成单行 $[r_1,r_2,r_3,r_4]$，其中 $r_i$ 是案例 $i$ 的满足条件的子集列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef format_list_no_spaces(obj):\n    \"\"\"\n    Recursively formats a list or other object into a string\n    representation without spaces after commas.\n    \"\"\"\n    if isinstance(obj, list):\n        return f\"[{','.join(format_list_no_spaces(item) for item in obj)}]\"\n    else:\n        return str(obj)\n\ndef emit_all_completions(prefix, suffix):\n    \"\"\"\n    Emit all supersets formed by taking prefix union any subset of suffix,\n    in a deterministic exclude-first order.\n    \"\"\"\n    results = []\n    def rec(j, acc):\n        if j == len(suffix):\n            results.append(prefix + acc)\n            return\n        # Exclude suffix[j]\n        rec(j + 1, acc)\n        # Include suffix[j]\n        rec(j + 1, acc + [suffix[j]])\n    rec(0, [])\n    return results\n\ndef generate_subsets_with_pruning_sum_at_most(A, T):\n    \"\"\"\n    Downward-closed property: sum(S) = T.\n    Prune when running sum exceeds T.\n    \"\"\"\n    n = len(A)\n    results = []\n\n    def backtrack(i, current, current_sum):\n        # Prune if current sum already violates the constraint\n        if current_sum > T:\n            return\n        if i == n:\n            # current_sum = T guaranteed here\n            results.append(current.copy())\n            return\n        # Exclude A[i]\n        backtrack(i + 1, current, current_sum)\n        # Include A[i]\n        current.append(A[i])\n        backtrack(i + 1, current, current_sum + A[i])\n        current.pop()\n\n    backtrack(0, [], 0)\n    return results\n\ndef generate_subsets_with_pruning_sum_at_least(A, L):\n    \"\"\"\n    Upward-closed property: sum(S) >= L.\n    Positive prune: if current_sum >= L, emit all completions.\n    Impossibility prune: if current_sum + sum(remaining)  L, prune.\n    \"\"\"\n    n = len(A)\n    # Precompute suffix maximum sums M_i = sum(A[i:])\n    suffix_sum = [0] * (n + 1)\n    for i in range(n - 1, -1, -1):\n        suffix_sum[i] = suffix_sum[i + 1] + A[i]\n\n    results = []\n\n    def backtrack(i, current, current_sum):\n        # Positive prune: already satisfies\n        if current_sum >= L:\n            results.extend(emit_all_completions(current.copy(), A[i:]))\n            return\n        # Impossibility prune: cannot reach L even if we add all remaining\n        if current_sum + suffix_sum[i]  L:\n            return\n        if i == n:\n            # current_sum  L here due to above conditions, so no output\n            return\n        # Exclude A[i]\n        backtrack(i + 1, current, current_sum)\n        # Include A[i]\n        current.append(A[i])\n        backtrack(i + 1, current, current_sum + A[i])\n        current.pop()\n\n    backtrack(0, [], 0)\n    return results\n\ndef generate_subsets_with_pruning_card_at_most(A, k):\n    \"\"\"\n    Downward-closed property: |S| = k.\n    Prune when cardinality exceeds k.\n    \"\"\"\n    n = len(A)\n    results = []\n\n    def backtrack(i, current, size):\n        if size > k:\n            return\n        if i == n:\n            results.append(current.copy())\n            return\n        # Exclude A[i]\n        backtrack(i + 1, current, size)\n        # Include A[i]\n        current.append(A[i])\n        backtrack(i + 1, current, size + 1)\n        current.pop()\n\n    backtrack(0, [], 0)\n    return results\n\ndef generate_subsets_with_pruning_exists_even(A):\n    \"\"\"\n    Upward-closed property: there exists at least one even element in S.\n    Positive prune: if S already has an even, emit all completions.\n    Impossibility prune: if S has no even and no even remains in suffix, prune.\n    \"\"\"\n    n = len(A)\n    # Precompute suffix availability of even numbers\n    suffix_has_even = [False] * (n + 1)\n    for i in range(n - 1, -1, -1):\n        suffix_has_even[i] = suffix_has_even[i + 1] or (A[i] % 2 == 0)\n\n    results = []\n\n    def backtrack(i, current, has_even):\n        # Positive prune: already satisfies\n        if has_even:\n            results.extend(emit_all_completions(current.copy(), A[i:]))\n            return\n        # Impossibility prune: cannot ever get an even\n        if not suffix_has_even[i]:\n            return\n        if i == n:\n            # has_even is False here, so no output\n            return\n        # Exclude A[i]\n        backtrack(i + 1, current, has_even)\n        # Include A[i]\n        current.append(A[i])\n        backtrack(i + 1, current, has_even or (A[i] % 2 == 0))\n        current.pop()\n\n    backtrack(0, [], False)\n    return results\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (\"sum_at_most\", [1, 2, 3], {\"T\": 3}),\n        (\"sum_at_least\", [2, 3, 5], {\"L\": 7}),\n        (\"card_at_most\", [1, 4, 6, 7], {\"k\": 2}),\n        (\"exists_even\", [3, 5, 8, 10], {}),\n    ]\n\n    results = []\n    for qtype, A, params in test_cases:\n        if qtype == \"sum_at_most\":\n            result = generate_subsets_with_pruning_sum_at_most(A, params[\"T\"])\n        elif qtype == \"sum_at_least\":\n            result = generate_subsets_with_pruning_sum_at_least(A, params[\"L\"])\n        elif qtype == \"card_at_most\":\n            result = generate_subsets_with_pruning_card_at_most(A, params[\"k\"])\n        elif qtype == \"exists_even\":\n            result = generate_subsets_with_pruning_exists_even(A)\n        else:\n            result = []\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(format_list_no_spaces(results))\n\nsolve()\n```", "id": "3259478"}]}