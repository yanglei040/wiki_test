{"hands_on_practices": [{"introduction": "这个问题通过一个直观的图书馆借书场景，为你呈现了经典的区间划分问题。你的目标是确定满足所有请求所需的最少资源（书的副本）数量。这项练习 [@problem_id:3241727] 是一个基础性的挑战，它要求你从第一性原理出发推导出解决方案，从而巩固一个核心见解：所需的最小资源数由任意单一时间点上重叠区间的最大数量（即最大深度）决定。", "problem": "一家公共图书馆通过随时间向读者分配副本，来管理一种图书的借阅请求。每个请求在离散时间轴上表示为一个半开区间 $[s_i, e_i)$，其中 $s_i$ 是开始时间，$e_i$ 是归还时间，该区间包含时间 $s_i$ 但不包含时间 $e_i$。在任何时刻，一个副本最多只能满足一个请求，并且一个请求在其整个持续时间内必须被分配给唯一一个副本。图书馆希望知道需要多少个副本，才能无延迟、无中断地满足所有请求。\n\n考虑以下 $12$ 个请求的集合：\n- $I_1 = [1, 7)$\n- $I_2 = [3, 9)$\n- $I_3 = [6, 10)$\n- $I_4 = [8, 12)$\n- $I_5 = [11, 15)$\n- $I_6 = [14, 18)$\n- $I_7 = [16, 22)$\n- $I_8 = [20, 25)$\n- $I_9 = [4, 5)$\n- $I_{10} = [5, 6)$\n- $I_{11} = [9, 14)$\n- $I_{12} = [2, 3)$\n\n仅从区间重叠和资源分配的核心定义出发，并且不引用任何已有结论，确定最小整数 $k^{*}$，使得图书馆可以使用 $k^{*}$ 个副本满足所有这 $12$ 个请求。你的推理必须证明为什么 $k^{*}$ 个副本是足够的，以及为什么更少的副本是不够的。最终答案必须是一个整数。不需要四舍五入。", "solution": "问题要求解出满足给定的 $12$ 个借阅请求所需的最少副本数，记为 $k^*$。每个请求是一个时间区间，两个在时间上重叠的请求不能由同一个副本服务。这是一个经典的区间划分问题。最少的划分数对应于所需的最少副本数。\n\n设请求集合为 $\\mathcal{I} = \\{I_1, I_2, \\dots, I_{12}\\}$，其中每个 $I_i = [s_i, e_i)$ 是时间轴上的一个半开区间。如果两个区间 $I_i = [s_i, e_i)$ 和 $I_j = [s_j, e_j)$ 的交集非空，即 $I_i \\cap I_j \\neq \\emptyset$，则称它们重叠。这种情况当且仅当 $s_i  e_j$ 且 $s_j  e_i$ 时发生。如果两个区间重叠，它们必须被分配到不同的副本。\n\n首先，我们为 $k^*$ 建立一个下界。在任何给定的时间点 $t$，设 $D(t)$ 是在该时刻处于活跃状态的请求数量。如果 $s_i \\le t  e_i$，则区间 $I_i=[s_i, e_i)$ 在时间 $t$ 是活跃的。在时间 $t$ 同时活跃的所有请求都必须被分配到不同的副本。因此，对于任何时间 $t$，所需的副本数必须至少为 $D(t)$。因此，最小副本数 $k^*$ 必须至少是 $D(t)$ 在所有时间上的最大值。设这个最大值为 $\\omega$，即区间集合的最大深度。\n$$k^* \\ge \\max_{t} D(t) = \\omega$$\n为了找到 $\\omega$，我们可以分析活跃区间数随时间的变化。活跃区间的数量只在区间的开始或结束时间点发生变化。我们可以从所有开始和结束时间构建一个事件点集合，对它们进行排序，并沿着时间轴“扫描”，跟踪活跃区间的计数。\n\n给定的区间是：\n$I_1 = [1, 7)$, $I_2 = [3, 9)$, $I_3 = [6, 10)$, $I_4 = [8, 12)$, $I_5 = [11, 15)$, $I_6 = [14, 18)$, $I_7 = [16, 22)$, $I_8 = [20, 25)$, $I_9 = [4, 5)$, $I_{10} = [5, 6)$, $I_{11} = [9, 14)$, $I_{12} = [2, 3)$.\n\n让我们检查在不同时间点的活跃区间数量：\n- 对于 $t \\in [1, 2)$：只有 $I_1$ 是活跃的。$D(t)=1$。\n- 对于 $t \\in [2, 3)$：$I_1, I_{12}$ 是活跃的。$D(t)=2$。\n- 对于 $t \\in [3, 4)$：$I_1, I_2$ 是活跃的。$D(t)=2$。\n- 对于 $t \\in [4, 5)$：$I_1, I_2, I_9$ 是活跃的。$D(t)=3$。\n- 对于 $t \\in [5, 6)$：$I_1, I_2, I_{10}$ 是活跃的。$D(t)=3$。\n- 对于 $t \\in [6, 7)$：$I_1, I_2, I_3$ 是活跃的。$D(t)=3$。\n- 对于 $t \\in [7, 8)$：$I_2, I_3$ 是活跃的。$D(t)=2$。\n- 对于 $t \\in [8, 9)$：$I_2, I_3, I_4$ 是活跃的。$D(t)=3$。\n- 对于 $t \\in [9, 10)$：$I_3, I_4, I_{11}$ 是活跃的。$D(t)=3$。\n- 对于 $t \\in [10, 11)$：$I_4, I_{11}$ 是活跃的。$D(t)=2$。\n- 对于 $t \\in [11, 12)$：$I_4, I_{11}, I_5$ 是活跃的。$D(t)=3$。\n\n观察到的同时活跃区间的最大数量是 $3$。例如，在时间 $t=6.5$，区间 $I_1=[1, 7)$, $I_2=[3, 9)$, 和 $I_3=[6, 10)$ 都处于活跃状态。由于这三个请求必须由三个不同的副本服务，我们为所需副本数建立了一个下界：\n$$k^* \\ge 3$$\n这证明了少于 $3$ 个副本是不够的。\n\n接下来，我们必须证明 $3$ 个副本是足够的。为此，我们提供一个将区间分配给 $3$ 个副本的构造性方案。可以使用一个标准的贪心算法来达到这个目的。该算法的步骤如下：\n1. 按开始时间的升序对区间进行排序。\n2. 遍历排序后的区间。对于每个区间，将其分配给第一个可用的副本（即，当前未分配给重叠区间的、索引最小的副本）。\n\n设副本为 $C_1, C_2, C_3$。按开始时间排序的区间列表是：\n$I_1=[1, 7)$, $I_{12}=[2, 3)$, $I_2=[3, 9)$, $I_9=[4, 5)$, $I_{10}=[5, 6)$, $I_3=[6, 10)$, $I_4=[8, 12)$, $I_{11}=[9, 14)$, $I_5=[11, 15)$, $I_6=[14, 18)$, $I_7=[16, 22)$, $I_8=[20, 25)$.\n\n让我们来分配它们：\n- $I_1 = [1, 7)$: $C_1$ 空闲。分配给 $C_1$。（$C_1$ 忙碌至时间 $7$）\n- $I_{12} = [2, 3)$: $C_1$ 忙碌。$C_2$ 空闲。分配给 $C_2$。（$C_2$ 忙碌至时间 $3$）\n- $I_2 = [3, 9)$: $C_1$ 忙碌。$C_2$ 在时间 $3$ 空闲。分配给 $C_2$。（$C_2$ 忙碌至时间 $9$）\n- $I_9 = [4, 5)$: $C_1$ 忙碌。$C_2$ 忙碌。$C_3$ 空闲。分配给 $C_3$。（$C_3$ 忙碌至时间 $5$）\n- $I_{10} = [5, 6)$: $C_1$ 忙碌。$C_2$ 忙碌。$C_3$ 在时间 $5$ 空闲。分配给 $C_3$。（$C_3$ 忙碌至时间 $6$）\n- $I_3 = [6, 10)$: $C_1$ 忙碌。$C_2$ 忙碌。$C_3$ 在时间 $6$ 空闲。分配给 $C_3$。（$C_3$ 忙碌至时间 $10$）\n- $I_4 = [8, 12)$: $C_1$ 在时间 $7$ 空闲。分配给 $C_1$。（$C_1$ 忙碌至时间 $12$）\n- $I_{11} = [9, 14)$: $C_1$ 忙碌。$C_2$ 在时间 $9$ 空闲。分配给 $C_2$。（$C_2$ 忙碌至时间 $14$）\n- $I_5 = [11, 15)$: $C_1$ 忙碌。$C_2$ 忙碌。$C_3$ 在时间 $10$ 空闲。分配给 $C_3$。（$C_3$ 忙碌至时间 $15$）\n- $I_6 = [14, 18)$: $C_1$ 在时间 $12$ 空闲。分配给 $C_1$。（$C_1$ 忙碌至时间 $18$）\n- $I_7 = [16, 22)$: $C_1$ 忙碌。$C_2$ 在时间 $14$ 空闲。分配给 $C_2$。（$C_2$ 忙碌至时间 $22$）\n- $I_8 = [20, 25)$: $C_1$ 在时间 $18$ 空闲。分配给 $C_1$。（$C_1$ 忙碌至时间 $25$）\n\n所有 $12$ 个区间都已成功分配，最多使用了 $3$ 个副本。这证明了 $3$ 个副本是足够的。\n$$k^* \\le 3$$\n\n为了从核心定义来证明这个程序的正确性，考虑为什么贪心算法是最优的。设该算法使用了 $M$ 个副本。这意味着存在一个区间，比如 $I_j = [s_j, e_j)$，它被分配给了第 $M$ 个副本 $C_M$。根据算法的逻辑，这只可能在分配时副本 $C_1, C_2, \\dots, C_{M-1}$ 都处于忙碌状态时发生。这意味着对于每个副本 $C_k$ (其中 $k \\in \\{1, \\dots, M-1\\}$)，都有一个已分配给它且与 $I_j$ 重叠的区间 $I_{p_k} = [s_{p_k}, e_{p_k})$。由于区间是按其开始时间顺序处理的，我们有对于所有的 $k$，都有 $s_{p_k} \\le s_j$。要使 $I_{p_k}$ 和 $I_j$ 重叠，必须有 $s_j  e_{p_k}$。这意味着在特定时间 $s_j$，所有 $M-1$ 个区间 $I_{p_1}, \\dots, I_{p_{M-1}}$ 都是活跃的。区间 $I_j$ 本身在时间 $s_j$ 也是活跃的。因此，在时间 $s_j$，至少有 $M$ 个同时活跃的区间。这意味着最大深度 $\\omega$ 必须至少为 $M$。所以，$M \\le \\omega$。由于我们已知 $M \\ge \\omega$，可得 $M=\\omega$。因此，贪心算法使用的恰好是可能的最少副本数。\n\n综合我们的发现，我们有 $k^* \\ge 3$ 和 $k^* \\le 3$。满足这两个条件的唯一整数是 $3$。因此，所需的最少副本数是 $3$。", "answer": "$$\\boxed{3}$$", "id": "3241727"}, {"introduction": "现实世界中的任务往往在开始前需要准备，结束后需要清理。这项练习 [@problem_id:3241746] 将基本的区间模型扩展，加入了准备时间 $S$ 和清理时间 $T$，使其更贴近实际。这里的关键是掌握问题规约的技巧：通过为每个任务定义一个包含准备和清理时间的“有效区间” $[s_i - S, f_i + T)$，你可以将这个看似复杂的问题转化回标准的区间划分问题，并用相同的核心逻辑来解决。", "problem": "考虑一个有限的任务集合，其中每个任务由一个带有开始时间 $s_i$ 和结束时间 $f_i$ 的区间表示，其中 $f_i > s_i$，对于 $i \\in \\{1,2,\\dots,n\\}$。一个资源在执行每个任务之前必须进行准备，在每个任务之后必须进行清理。具体来说，每当一个资源被分配给任务 $i$ 时，它在区间 $[s_i - S, f_i + T]$ 期间是不可用的，其中 $S \\ge 0$ 是准备时间，$T \\ge 0$ 是清理时间。分配给同一资源的两个任务，其资源不可用区间必须不重叠，即如果任务 $j$ 在同一资源上安排在任务 $i$ 之后，则必须满足 $s_j - S \\ge f_i + T$。目标是将所有任务分配给最少数量的资源，以确保没有任何资源的不可用区间发生重叠。\n\n从区间、偏序的基本定义以及由准备和清理引起的资源不可用性概念出发，推导一种方法来计算在上述约束条件下调度所有任务所需的最少资源数。您的推导不得依赖未经证明的捷径；它应从第一性原理和关于区间与排序的已充分验证的事实出发。然后，您必须将此方法实现为一个完整的、可运行的程序，为下面的每个测试用例计算最少的资源数。\n\n使用以下参数值测试套件，其中每个测试用例由常量 $S$、$T$ 和一个区间列表 $\\{(s_i,f_i)\\}$ 指定：\n\n- 测试用例 1：$S=0$, $T=0$, 区间 $\\{(1,3),(2,4),(3,5),(7,8)\\}$。\n- 测试用例 2：$S=1$, $T=1$, 区间 $\\{(1,2),(2,3),(3,4)\\}$。\n- 测试用例 3：$S=1$, $T=2$, 区间 $\\{(4,6),(9,10)\\}$。\n- 测试用例 4：$S=0$, $T=2$, 区间 $\\{(1,3),(3,4),(5,6),(6,7)\\}$。\n- 测试用例 5：$S=2$, $T=0$, 区间 $\\{(5,8),(10,12),(12,13),(13,15)\\}$。\n- 测试用例 6：$S=2$, $T=2$, 区间 $\\{(0,1),(5,6),(8,9)\\}$。\n\n对于每个测试用例，所需的答案是最少资源数，一个整数。您的程序应生成单行输出，其中包含按上述测试用例顺序排列的结果，形式为方括号括起来的逗号分隔列表，例如 $[r_1,r_2,r_3,r_4,r_5,r_6]$，其中每个 $r_k$ 是测试用例 $k$ 的整数结果。本问题不涉及物理单位或角度单位，所有输出均为整数。", "solution": "该问题要求找到调度一组任务所需的最少资源数，每个任务都有指定的开始时间、结束时间、准备时间和清理时间。我们将首先对约束条件进行形式化，然后证明该问题等价于经典的区间划分问题。后者的解将从第一性原理推导得出。\n\n设任务集合由 $i \\in \\{1, 2, \\dots, n\\}$ 索引。每个任务 $i$ 由一个时间区间 $(s_i, f_i)$ 定义，其中 $s_i$ 是开始时间，$f_i$ 是结束时间，且 $f_i > s_i$。任何任务开始前都需要一个恒定的准备时间 $S \\ge 0$，任何任务结束后都需要一个恒定的清理时间 $T \\ge 0$。这意味着分配给任务 $i$ 的资源在闭区间 $[s_i - S, f_i + T]$ 内被占用且不可用。\n\n在同一资源上调度两个任务 $i$ 和 $j$ 的核心约束是，它们的资源不可用时段不得冲突。问题将其表述为：如果任务 $j$ 被安排在任务 $i$ 之后，则必须满足 $s_j - S \\ge f_i + T$。更一般地说，如果要将任意两个不同的任务 $i$ 和 $j$ 分配给同一资源，其中一个必须在另一个开始之前完成。这意味着要么任务 $i$ 在任务 $j$ 开始前完成，要么任务 $j$ 在任务 $i$ 开始前完成。\n- 如果任务 $i$ 在前，资源在时间 $f_i + T$ 变为可用。然后任务 $j$ 可以开始，其准备工作于时间 $s_j - S$ 开始。条件是 $s_j - S \\ge f_i + T$。\n- 如果任务 $j$ 在前，条件对称地为 $s_i - S \\ge f_j + T$。\n\n因此，两个任务 $i$ 和 $j$ 是**兼容的**（可以放在同一资源上）当且仅当 $(s_j - S \\ge f_i + T) \\lor (s_i - S \\ge f_j + T)$。\n\n相反，任务 $i$ 和 $j$ 是**不兼容的**（它们冲突并需要不同资源），如果它们不兼容。这发生在兼容条件的否定为真时：\n$ \\neg((s_j - S \\ge f_i + T) \\lor (s_i - S \\ge f_j + T)) $\n根据德摩根定律，这等价于：\n$ (\\neg(s_j - S \\ge f_i + T)) \\land (\\neg(s_i - S \\ge f_j + T)) $\n化简后得到：\n$ (s_j - S  f_i + T) \\land (s_i - S  f_j + T) $\n\n为了简化此表达式，我们为每个任务 $i$ 定义一个**有效区间**为 $I'_i = [s'_i, f'_i) = [s_i - S, f_i + T)$。注意我们使用半开区间，这与非重叠条件 $s_j' \\ge f_i'$ 相对应。任务 $i$ 和 $j$ 之间的冲突条件现在可以用它们的有效区间端点 $s'_i, f'_i, s'_j, f'_j$ 重写：\n$ (s'_j  f'_i) \\land (s'_i  f'_j) $\n这正是两个半开区间 $I'_i$ 和 $I'_j$ 具有非空交集（即它们重叠）的精确数学定义。\n\n现在，问题已转化为以下形式：给定一组半开区间 $\\{I'_1, I'_2, \\dots, I'_n\\}$，将其划分为最少数量的子集，使得任何给定子集中的任意两个区间都不重叠。这就是**区间划分问题**。\n\n区间划分问题的解是该区间集的**深度**。深度，用 $d$ 表示，是在任何单一时间点上相互重叠的最大区间数。形式上，\n$$d = \\max_{t \\in \\mathbb{R}} |\\{i \\mid t \\in I'_i\\}| = \\max_{t \\in \\mathbb{R}} |\\{i \\mid s'_i \\le t  f'_i \\}|$$\n我们必须从第一性原理出发，证明所需的最少资源数 $k_{min}$ 等于 $d$。\n\n**下界：** $k_{min} \\ge d$。\n根据深度的定义，存在一个时间点 $t_0$，在该时间点上，$d$ 个不同的有效区间 $I'_{i_1}, I'_{i_2}, \\dots, I'_{i_d}$ 全部重叠。这意味着对于任务对 $j, l \\in \\{i_1, \\dots, i_d\\}$ 中的任意一对，它们的有效区间 $I'_j$ 和 $I'_l$ 都有非空交集。因此，这 $d$ 个任务都是相互不兼容的。所以，这 $d$ 个任务中的每一个都必须分配到不同的资源上。这直接意味着至少需要 $d$ 个资源。因此，$k_{min} \\ge d$。\n\n**上界（构造性证明）：** $k_{min} \\le d$。\n我们可以通过提供一个贪心算法来证明 $d$ 个资源总是足够的，该算法使用至多 $d$ 个资源来调度所有任务。计算 $d$ 以及隐式分配资源的最直接方法是**扫描线算法**。\n\n1.  对于每个有效区间 $I'_i = [s'_i, f'_i)$，创建两个事件：一个开始事件 $(s'_i, +1)$ 和一个结束事件 $(f'_i, -1)$。\n2.  将所有 $2n$ 个事件收集到一个列表中。\n3.  主要按时间坐标对事件列表进行排序。对于同时发生的事件，一个打破平局的规则至关重要。如果一个区间结束的时间恰好是另一个区间开始的时间（例如 $[1,3)$ 和 $[3,5)$），它们不被视为重叠。一个资源可以从第一个任务中释放出来，并立即用于第二个任务。为了正确地对此建模，在同一时间坐标上，结束事件 (`-1`) 必须在开始事件 (`+1`) 之前处理。因此，事件 $(t, \\text{type})$ 的次要排序键应为 `type`。\n4.  初始化一个计数器用于记录当前重叠的区间数，`current_overlap = 0`，以及一个变量用于追踪至今为止发现的最大重叠数，`max_overlap = 0`。\n5.  遍历排序后的事件列表。对于每个事件 $(t, \\text{type})$：\n    a. 更新当前重叠数：`current_overlap = current_overlap + type`。\n    b. 更新最大重叠数：`max_overlap = max(max_overlap, current_overlap)`。\n\n处理完所有事件后，`max_overlap` 将持有值 $d$。这个扫描线过程模拟了将一个时间点从 $-\\infty$ 移动到 $+\\infty$，并计算在每个时刻有多少个区间是“活跃”的。`current_overlap` 在一个区间开始时增加 $1$，在结束时减少 $1$。它所达到的最大值，根据定义，就是深度 $d$。\n\n该算法不仅计算了 $d$，还为充分性提供了构造性论证。想象一个贪心分配策略，它按有效开始时间的顺序处理任务。当考虑一个任务时，它会将其分配给任何已变为可用的资源（即，该资源上的前一个任务的有效结束时间小于或等于当前任务的有效开始时间）。如果没有可用的资源，它会分配一个新的。这个贪心算法分配的资源数量绝不会超过 $d$。如果它要为一个任务 $T_i$ 分配第 $(d+1)$ 个资源，那将意味着在开始时间 $s'_i$，有 $d$ 个其他任务是活跃的，并占用了前 $d$ 个资源。这将意味着有 $d+1$ 个区间（任务 $T_i$ 和其他 $d$ 个任务）同时活跃，这与深度为 $d$ 的事实相矛盾。\n\n因此，$d$ 个资源是足够的。既然我们已经证明了 $k_{min} \\ge d$ 和 $k_{min} \\le d$，那么必然有 $k_{min} = d$。所需的最少资源数就是有效区间集的深度，这可以使用所描述的扫描线算法高效地计算出来。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, run the solver for each,\n    and print the results in the specified format.\n    \"\"\"\n    # Each test case is a tuple: (S, T, list_of_intervals)\n    # Each interval is a tuple: (start_time, finish_time)\n    test_cases = [\n        (0, 0, [(1, 3), (2, 4), (3, 5), (7, 8)]),\n        (1, 1, [(1, 2), (2, 3), (3, 4)]),\n        (1, 2, [(4, 6), (9, 10)]),\n        (0, 2, [(1, 3), (3, 4), (5, 6), (6, 7)]),\n        (2, 0, [(5, 8), (10, 12), (12, 13), (13, 15)]),\n        (2, 2, [(0, 1), (5, 6), (8, 9)]),\n    ]\n\n    results = []\n    for S, T, intervals in test_cases:\n        result = compute_min_resources(S, T, intervals)\n        results.append(result)\n\n    # Format the output as a comma-separated list in square brackets\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef compute_min_resources(S, T, intervals):\n    \"\"\"\n    Computes the minimum number of resources required for a given set of tasks.\n    This is equivalent to finding the depth of the set of effective intervals.\n\n    The method used is the sweep-line algorithm.\n\n    Args:\n        S (int): The setup time, S = 0.\n        T (int): The teardown time, T = 0.\n        intervals (list of tuples): A list of (start_time, finish_time) for each task.\n\n    Returns:\n        int: The minimum number of resources required.\n    \"\"\"\n    if not intervals:\n        return 0\n\n    events = []\n    # Define constants for event types to aid sorting and readability\n    START_EVENT = 1\n    FINISH_EVENT = -1\n\n    for s_i, f_i in intervals:\n        # Calculate the effective interval [s_i - S, f_i + T).\n        # The conflict condition s'_j  f'_i and s'_i  f'_j corresponds to\n        # overlapping semi-open intervals [s'_i, f'_i).\n        s_prime = s_i - S\n        f_prime = f_i + T\n        \n        # Add a start event\n        events.append((s_prime, START_EVENT))\n        # Add a finish event\n        events.append((f_prime, FINISH_EVENT))\n\n    # Sort events:\n    # 1. Primarily by time.\n    # 2. Secondarily by event type. A finish event (-1) must come before a\n    #    start event (1) at the same time to correctly handle intervals that\n    #    touch at endpoints, like [1,3) and [3,5). The natural sort order of\n    #    the types (-1  1) achieves this.\n    events.sort()\n\n    max_resources = 0\n    current_resources = 0\n    for time, event_type in events:\n        current_resources += event_type\n        if current_resources > max_resources:\n            max_resources = current_resources\n            \n    return max_resources\n\n# Execute the main function\nsolve()\n```", "id": "3241746"}, {"introduction": "在项目管理和复杂系统中，任务之间很少是完全独立的，它们通常存在依赖关系。这项练习 [@problem_id:3241721] 引入了以有向无环图（DAG）形式建模的优先级约束，增加了一层新的真实性。它展示了区间划分如何作为一个关键组件，嵌入到更宏大的算法流程中：你首先需要通过拓扑排序来解决依赖关系，确定每个任务的实际执行区间，然后再应用区间划分算法。", "problem": "考虑一个有限的任务集合，每个任务由一个带有计划开始时间和计划结束时间的区间表示。设任务由整数索引，任务 $i$ 的计划区间表示为 $[s_i, e_i)$，其中 $s_i$ 是计划开始时间，$e_i$ 是计划结束时间。任务 $i$ 的持续时间为 $d_i = e_i - s_i$，且所有持续时间都满足 $d_i > 0$。区间被视为半开区间，即 $[s_i, e_i)$ 包含 $s_i$ 但不包含 $e_i$，因此在一个时间点 $t$ 结束的任务不会与在同一时间点 $t$ 开始的任务重叠。\n\n任务之间存在有向的先后关系，形成一个有向无环图（DAG），由一组有向边 $p \\rightarrow i$ 定义，这表示任务 $i$ 必须在任务 $p$ 完成后才能开始。设 $\\mathrm{pred}(i)$ 为任务 $i$ 的前驱任务集合。\n\n一个调度按照以下规则构建：每个任务 $i$ 必须在满足其计划开始时间和其先后约束条件的前提下尽早开始。实际开始时间 $a_i$ 和实际完成时间 $f_i$ 定义如下：\n$$\na_i = \\max\\left(s_i,\\ \\max_{p \\in \\mathrm{pred}(i)} f_p\\right)\\quad\\text{约定空集上的内部最大值等于 } -\\infty\\text{，因此如果 }\\mathrm{pred}(i)=\\varnothing\\text{，则 }a_i = s_i\\text{，}\n$$\n以及\n$$\nf_i = a_i + d_i.\n$$\n当先后关系图是无环图时，此规则产生唯一的、最早可行的调度。\n\n一旦确定了实际区间 $[a_i, f_i)$，区间划分问题要求计算所需的最小不相交轨道（资源）数量，以便为所有任务分配轨道，且分配到同一轨道上的任意两个任务在时间上不重叠。对于一个固定的区间集合，这个最小值等于在任何时刻重叠区间的最大数量。\n\n您的任务是编写一个完整且可运行的程序，对每个提供的测试用例执行以下步骤：\n- 验证先后关系是否构成一个有向无环图（DAG）。如果不构成，则为该测试用例输出整数 $-1$。\n- 否则，使用上述规则计算最早可行的实际区间 $[a_i, f_i)$。\n- 计算划分这些实际区间所需的最小轨道数，以使同一轨道上的任意两个区间不重叠。\n\n程序必须生成单行输出，其中包含所有测试用例的结果，格式为用方括号括起来的逗号分隔列表。每个结果都必须是整数。\n\n基本假设和定义：\n- 先后约束定义了一个偏序关系；在有向无环图（DAG）中，存在拓扑排序。\n- 对于一个固定的区间族，所需的最小轨道数等于任何时刻重叠区间的最大数量。\n\n测试套件和参数说明：\n使用以下测试用例，其索引、计划开始时间、计划结束时间和前驱任务列表均已指定。所有时间都是实数，但在以下测试中它们是整数。\n\n- 测试用例 1（具有先后关系引起的延迟的通用DAG）：\n  - 索引：$0, 1, 2, 3, 4$。\n  - 计划开始时间：$[0, 1, 2, 3, 0]$。\n  - 计划结束时间：$[3, 4, 5, 7, 2]$。\n  - 前驱任务：$[\\varnothing, [0], [0], [1, 2], \\varnothing]$。\n  - 输出：最小轨道数（整数）。\n\n- 测试用例 2（无依赖关系，区间重叠）：\n  - 索引：$0, 1, 2$。\n  - 计划开始时间：$[0, 1, 2]$。\n  - 计划结束时间：$[2, 3, 4]$。\n  - 前驱任务：$[\\varnothing, \\varnothing, \\varnothing]$。\n  - 输出：最小轨道数（整数）。\n\n- 测试用例 3（依赖链，强制顺序执行）：\n  - 索引：$0, 1, 2$。\n  - 计划开始时间：$[0, 0, 0]$。\n  - 计划结束时间：$[3, 3, 3]$。\n  - 前驱任务：$[\\varnothing, [0], [1]]$。\n  - 输出：最小轨道数（整数）。\n\n- 测试用例 4（分支依赖关系产生高重叠窗口）：\n  - 索引：$0, 1, 2, 3, 4$。\n  - 计划开始时间：$[0, 0, 0, 0, 1]$。\n  - 计划结束时间：$[1, 2, 2, 2, 2]$。\n  - 前驱任务：$[\\varnothing, [0], [0], [0], \\varnothing]$。\n  - 输出：最小轨道数（整数）。\n\n- 测试用例 5（因循环而无效；必须检测出来）：\n  - 索引：$0, 1$。\n  - 计划开始时间：$[0, 0]$。\n  - 计划结束时间：$[1, 1]$。\n  - 前驱任务：$[[1], [0]]$。\n  - 输出：整数 $-1$。\n\n最终输出格式要求：\n您的程序应生成单行输出，其中包含所有结果，格式为用方括号括起来的逗号分隔列表（例如，“[r_1,r_2,r_3,r_4,r_5]”），其中每个 $r_i$ 是按上述顺序列出的测试用例 $i$ 的整数结果。", "solution": "所提出的问题是一个复合任务，需要综合图论、调度算法和计算几何的原理。它可以系统地分解为三个不同且连续的阶段：1) 验证先后约束是否构成有向无环图（DAG），2) 基于这些约束计算最早可行的调度，以及 3) 确定无重叠地执行该调度所需的最小资源（轨道）数量。\n\n一个有效的解决方案必须正确实现每个阶段。我们现在将详细阐述每个阶段的形式化方法。\n\n**阶段 1：先后关系图验证与拓扑排序**\n\n任务集合及其先后约束 $p \\rightarrow i$ 构成一个有向图 $G = (V, E)$，其中 $V$ 是任务集合，$E$ 是先后关系边的集合。计算实际开始时间的规则，\n$$a_i = \\max\\left(s_i,\\ \\max_{p \\in \\mathrm{pred}(i)} f_p\\right),$$\n仅当图 $G$ 是无环图时才是良定义的。例如，一个循环 $i_1 \\rightarrow i_2 \\rightarrow \\dots \\rightarrow i_k \\rightarrow i_1$ 意味着任务 $i_1$ 的开始时间依赖于其自身的完成，这是一个逻辑上的不可能，会导致未定义的调度。因此，第一步是验证 $G$ 是否为 DAG。\n\n此验证通过深度优先搜索（DFS）遍历来执行。我们使用三个集合来维护每个节点的状态：\n1.  `white` 集合，包含所有未访问的节点。\n2.  `gray` 集合，包含当前正在访问的节点（即，在 DFS 的当前递归堆栈中的节点）。\n3.  `black` 集合，包含已完全探索的节点（即，DFS 已访问该节点及其所有后代节点）。\n\n算法从 `white` 集合中的每个节点开始发起 DFS。当访问一个节点 $u$ 时，它会从 `white` 集合移至 `gray` 集合。对于 $u$ 的每个邻居 $v$，我们检查其状态。如果 $v$ 在 `gray` 集合中，则检测到一条后向边，这意味着存在一个循环。在这种情况下，该图不是 DAG，问题实例无效，应返回结果 $-1$。如果对所有节点的 DFS 完成而没有检测到后向边，则该图是 DAG。\n\n这次 DFS 遍历的一个有价值的副产品是图节点的拓扑排序。拓扑排序是节点的一种线性排序，对于从节点 $u$ 到节点 $v$ 的每条有向边， $u$ 都在排序中位于 $v$ 之前。这种排序存在当且仅当图是 DAG。通过记录节点从 `gray` 集合移至 `black` 集合的顺序，然后反转此列表，我们便能获得一个有效的拓扑排序。这个排序对于下一阶段至关重要。\n\n**阶段 2：最早可行调度的计算**\n\n鉴于先后关系图是一个 DAG，我们可以为每个任务 $i$ 计算实际开始时间 $a_i$ 和完成时间 $f_i$。计算依赖于阶段 1 中获得的拓扑排序。通过按拓扑顺序处理任务，我们保证在计算任务 $i$ 的开始时间 $a_i$ 时，其所有前驱任务 $p \\in \\mathrm{pred}(i)$ 的实际完成时间 $f_p$ 都已经确定。\n\n过程如下：\n为所有任务的实际完成时间 $f$ 初始化一个数组（例如，初始化为 $-\\infty$）。\n根据拓扑排序遍历每个任务 $i$：\n1.  确定最晚完成的前驱任务的完成时间：$f_{\\max\\_pred} = \\max_{p \\in \\mathrm{pred}(i)} f_p$。按照约定，如果前驱任务集合 $\\mathrm{pred}(i)$ 为空，则该最大值为 $-\\infty$。\n2.  通过取任务的计划开始时间 $s_i$ 和最晚前驱任务完成时间 $f_{\\max\\_pred}$ 的最大值来计算实际开始时间 $a_i$：$$a_i = \\max(s_i, f_{\\max\\_pred})$$\n3.  通过将任务的持续时间 $d_i = e_i - s_i$ 加到其实际开始时间上，来计算实际完成时间 $f_i$：$$f_i = a_i + d_i$$\n\n遍历所有任务后，我们就确定了实际执行区间集合 $\\{[a_i, f_i) | i \\in V\\}$。\n\n**阶段 3：通过最大重叠计算实现最小轨道分配**\n\n最后阶段是为计算出的实际区间集合 $\\{[a_i, f_i)\\}$ 解决区间划分问题。目标是为每个任务（区间）分配一个资源轨道，使得同一轨道上的任意两个任务在时间上不重叠，并最小化所用轨道的总数。该领域的一个基本结论是，最小轨道数等于区间集合的最大深度，也就是在任何单个时间点上重叠区间的最大数量。\n\n我们可以使用扫描线算法高效地计算这个最大重叠数。该算法将区间的起点和终点视为沿时间轴发生的“事件”。\n1.  对于每个区间 $[a_i, f_i)$，创建两个事件点：一个开始事件 $(a_i, +1)$ 和一个结束事件 $(f_i, -1)$。值 $+1$ 表示一个区间的开始，使重叠计数增加；而 $-1$ 表示结束，使重叠计数减少。\n2.  将所有事件点收集到一个列表中。\n3.  对此事件列表进行排序。主排序键是事件的时间。次排序键是事件类型。因为区间是半开的 $[a_i, f_i)$，一个在时间 $t$ 结束的任务不与一个在时间 $t$ 开始的任务重叠。为了正确地建模这一点，时间 $t$ 的结束事件（-1）必须在同一时间 $t$ 的开始事件（+1）之前处理。因此，我们按时间的升序对事件进行排序，对于时间相同的事件，按事件类型的升序排序（即 -1 在 +1 之前）。\n4.  初始化一个用于记录当前重叠区间数的计数器 `current_overlap` 为 $0$，以及一个用于记录到目前为止发现的最大重叠数的变量 `max_overlap` 为 $0$。\n5.  遍历排序后的事件列表。对于每个事件 $(t, \\text{type})$：\n    a. 更新重叠计数器：`current_overlap` = `current_overlap` + `type`。\n    b. 更新最大重叠数：`max_overlap` = $\\max(\\text{`max_overlap`}, \\text{`current_overlap`})$。\n\n处理完所有事件后，`max_overlap` 将持有任何时间点上重叠区间的最大数量，这即是所需的最小轨道数。这个整数值就是给定测试用例的结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to process all test cases and print results.\n    \"\"\"\n    # Test cases defined in the problem statement.\n    # Each case is a tuple: (starts, ends, predecessors)\n    # The number of tasks is inferred from the length of the starts list.\n    test_cases = [\n        # Test case 1\n        (\n            np.array([0, 1, 2, 3, 0]),\n            np.array([3, 4, 5, 7, 2]),\n            {0: [], 1: [0], 2: [0], 3: [1, 2], 4: []}\n        ),\n        # Test case 2\n        (\n            np.array([0, 1, 2]),\n            np.array([2, 3, 4]),\n            {0: [], 1: [], 2: []}\n        ),\n        # Test case 3\n        (\n            np.array([0, 0, 0]),\n            np.array([3, 3, 3]),\n            {0: [], 1: [0], 2: [1]}\n        ),\n        # Test case 4\n        (\n            np.array([0, 0, 0, 0, 1]),\n            np.array([1, 2, 2, 2, 2]),\n            {0: [], 1: [0], 2: [0], 3: [0], 4: []}\n        ),\n        # Test case 5\n        (\n            np.array([0, 0]),\n            np.array([1, 1]),\n            {0: [1], 1: [0]}\n        ),\n    ]\n\n    results = []\n    for s, e, preds in test_cases:\n        result = compute_tracks(s, e, preds)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef compute_tracks(s_planned, e_planned, predecessors):\n    \"\"\"\n    Computes the minimum number of tracks for a single test case.\n    \n    This function implements the three-stage process:\n    1. DAG validation and topological sorting.\n    2. Earliest-feasible schedule calculation.\n    3. Maximum overlap calculation using a sweep-line algorithm.\n    \n    Returns -1 if the precedence graph contains a cycle.\n    \"\"\"\n    num_tasks = len(s_planned)\n    \n    # --- Stage 1: DAG Validation and Topological Sort ---\n    \n    # Build a forward adjacency list from the predecessor list\n    adj = {i: [] for i in range(num_tasks)}\n    for i, preds in predecessors.items():\n        for p in preds:\n            adj[p].append(i)\n\n    # Sets for DFS-based cycle detection\n    # white_set (unvisited): nodes not in visiting_set or visited_set\n    # gray_set (visiting): nodes in the current recursion stack\n    # black_set (visited): nodes fully explored\n    visiting_set = set()\n    visited_set = set()\n    topo_order = []\n    \n    has_cycle = [False] # Use a list to make it mutable inside the nested function\n\n    def dfs(u):\n        if has_cycle[0]:\n            return\n\n        visiting_set.add(u)\n\n        for v in adj.get(u, []):\n            if v in visiting_set:\n                has_cycle[0] = True\n                return\n            if v not in visited_set:\n                dfs(v)\n        \n        visiting_set.remove(u)\n        visited_set.add(u)\n        topo_order.append(u)\n\n    for i in range(num_tasks):\n        if i not in visited_set:\n            dfs(i)\n\n    if has_cycle[0]:\n        return -1\n    \n    topo_order.reverse() # The reverse of post-order traversal is a topological sort\n\n    # --- Stage 2: Earliest-Feasible Schedule Calculation ---\n    \n    durations = e_planned - s_planned\n    f_actual = np.full(num_tasks, -np.inf, dtype=float)\n    a_actual = np.zeros(num_tasks, dtype=float)\n\n    for i in topo_order:\n        max_pred_finish_time = -np.inf\n        if predecessors[i]:\n            pred_finish_times = [f_actual[p] for p in predecessors[i]]\n            max_pred_finish_time = max(pred_finish_times)\n        \n        a_actual[i] = max(s_planned[i], max_pred_finish_time)\n        f_actual[i] = a_actual[i] + durations[i]\n\n    # --- Stage 3: Minimal Track Allocation (Max Overlap) ---\n    \n    events = []\n    for i in range(num_tasks):\n        events.append((a_actual[i], 1))  # Start of an interval\n        events.append((f_actual[i], -1)) # End of an interval\n\n    # Sort events: primary key is time, secondary key is type (-1 before 1).\n    # This correctly handles intervals [s, e) where an interval ending at t\n    # does not overlap with one starting at t.\n    events.sort(key=lambda x: (x[0], x[1]))\n\n    max_overlap = 0\n    current_overlap = 0\n    for time, type in events:\n        current_overlap += type\n        if current_overlap > max_overlap:\n            max_overlap = current_overlap\n            \n    return max_overlap\n\nsolve()\n\n```", "id": "3241721"}]}