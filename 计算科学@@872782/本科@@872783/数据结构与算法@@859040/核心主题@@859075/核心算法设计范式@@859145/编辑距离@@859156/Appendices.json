{"hands_on_practices": [{"introduction": "在深入研究完整的编辑距离算法之前，让我们从一个简化版本开始热身。这个练习将编辑操作限制为仅替换，这有助于我们建立逐位比较字符串并累积成本的基本直觉，此概念是更复杂的动态规划方法的基础。[@problem_id:3230949]", "problem": "考虑有限字母表上的两个字符串 $S$ 和 $T$。经典的编辑距离（Levenshtein 距离）定义为使用替换、插入和删除操作将一个字符串转换为另一个字符串的最小总成本，每个操作都分配一个非负成本。在这个问题中，假设不允许插入和删除，替换是唯一允许的操作。每个精确的字符匹配成本为 $0$，每次替换成本为 $1$。在这些限制下，两个输入字符串必须具有相等的长度。\n\n设 $S$ 是将模式 $\\text{\"abcd\"}$ 重复 $6$ 次得到的 $24$ 字符字符串，设 $T$ 是将模式 $\\text{\"abce\"}$ 重复 $6$ 次得到的 $24$ 字符字符串。具体来说，\n$S = \\text{\"abcdabcdabcdabcdabcdabcd\"}$ 和 $T = \\text{\"abceabceabceabceabceabce\"}$。\n计算在上述操作模型下，$S$ 和 $T$ 之间的受限编辑距离。你的最终答案必须是一个整数，不需要四舍五入。", "solution": "问题要求计算两个字符串 $S$ 和 $T$ 之间的受限编辑距离。我将首先验证问题陈述。\n\n### 步骤 1：提取已知条件\n- 唯一允许的操作是替换。不允许插入和删除。\n- 精确字符匹配的成本为 $0$。\n- 替换（不匹配）的成本为 $1$。\n- 一个约束是输入字符串必须具有相等的长度。\n- 字符串 $S$ 的长度为 $24$，由模式 $\\text{\"abcd\"}$ 重复 $6$ 次形成。因此，$S = \\text{\"abcdabcdabcdabcdabcdabcd\"}$。\n- 字符串 $T$ 的长度为 $24$，由模式 $\\text{\"abce\"}$ 重复 $6$ 次形成。因此，$T = \\text{\"abceabceabceabceabceabce\"}$。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题具有科学依据，是计算机科学和离散数学中常见的字符串度量问题的一个具体实例。所定义的“受限编辑距离”就是众所周知的第一类汉明距离（Hamming distance），它定义于等长字符串上。该问题是适定(well-posed)的：字符串被明确定义，它们的长度相等（$24$），满足所述约束，并且成本函数是明确的。所有必要的信息都已提供并且内部一致。该问题是客观且可形式化的。因此，该问题被认为是有效的。\n\n### 解答\n设两个字符串为 $S$ 和 $T$，长度均为 $N$。设 $S = s_1s_2...s_N$ 和 $T = t_1t_2...t_N$，其中 $s_i$ 和 $t_i$ 分别是 $S$ 和 $T$ 在第 $i$ 个位置上的字符。\n\n问题定义了一种受限编辑距离，其中只有替换是允许的操作。将 $S$ 转换为 $T$ 的成本是每个位置上操作成本的总和。由于只允许替换，我们比较从 $1$ 到 $N$ 的每个位置 $i$ 上的字符。单个位置 $i$ 的成本函数，我们称之为 $c_i$，给出如下：\n$c_i = 0$ 如果 $s_i = t_i$ (匹配)\n$c_i = 1$ 如果 $s_i \\neq t_i$ (替换)\n\n总的受限编辑距离，我们记为 $D(S, T)$，是所有位置上这些成本的总和。这在形式上等同于汉明距离。\n$$D(S, T) = \\sum_{i=1}^{N} c_i$$\n\n在这个问题中，字符串是 $S = \\text{\"abcdabcdabcdabcdabcdabcd\"}$ 和 $T = \\text{\"abceabceabceabceabceabce\"}$。\n两个字符串的长度都是 $N=24$。\n\n字符串 $S$ 是由基本模式 $P_S = \\text{\"abcd\"}$ 重复 $6$ 次构成的。\n字符串 $T$ 是由基本模式 $P_T = \\text{\"abce\"}$ 重复 $6$ 次构成的。\n\n每个模式的长度是 $ L=4$。总长度是 $N = 6 \\times L = 6 \\times 4 = 24$。\n\n由于字符串的重复结构，总距离 $D(S, T)$ 可以通过先计算基本模式之间的距离 $D(P_S, P_T)$，然后乘以重复次数 $6$ 来得到。\n\n让我们计算模式 $P_S = \\text{\"abcd\"}$ 和 $P_T = \\text{\"abce\"}$ 之间的距离 $D(P_S, P_T)$。我们逐个字符进行比较：\n- 位置 $1$：'a' 对 'a'。字符匹配，所以成本为 $0$。\n- 位置 $2$：'b' 对 'b'。字符匹配，所以成本为 $0$。\n- 位置 $3$：'c' 对 'c'。字符匹配，所以成本为 $0$。\n- 位置 $4$：'d' 对 'e'。字符不匹配，所以成本为 $1$。\n\n一个模式块的距离是这些成本的总和：\n$$D(P_S, P_T) = 0 + 0 + 0 + 1 = 1$$\n\n总距离 $D(S, T)$ 是 $6$ 个相应块的距离之和。由于每个块都相同，总距离是单个块距离的 $6$ 倍。\n$$D(S, T) = 6 \\times D(P_S, P_T)$$\n$$D(S, T) = 6 \\times 1 = 6$$\n\n或者，我们可以写出完整的求和。设 $S_k$ 和 $T_k$ 为字符串的第 $k$ 个块，其中 $k \\in \\{1, 2, 3, 4, 5, 6\\}$。那么 $S = S_1 S_2 S_3 S_4 S_5 S_6$ 且 $T = T_1 T_2 T_3 T_4 T_5 T_6$。\n由于对所有的 $k$ 都有 $S_k = P_S$ 和 $T_k = P_T$，总距离是：\n$$D(S, T) = \\sum_{k=1}^{6} D(S_k, T_k) = \\sum_{k=1}^{6} D(P_S, P_T) = \\sum_{k=1}^{6} 1 = 6$$\n\n$S$ 和 $T$ 之间的受限编辑距离是字符不同的位置总数。在每个长度为 $4$ 的 $6$ 个块中，只有最后一个字符是不同的。因此，总共有 $6$ 个不匹配。由于每个不匹配的成本为 $1$，所以总成本是 $6$。", "answer": "$$\n\\boxed{6}\n$$", "id": "3230949"}, {"introduction": "现在我们已经掌握了基本的字符串比较，让我们来解决一个更具创造性的挑战。这个问题要求我们找到将一个给定字符串转换为回文串所需的最小编辑次数，解决这个问题的关键在于一个巧妙的洞察：这个问题可以重新表述为计算原始字符串与其反转字符串之间的编辑距离。[@problem_id:3230960]", "problem": "令 $S$ 为字符串 $S=\\text{\"abracad\"}$，其长度为 $n=7$。回文串是指一个字符串 $P$ 与其反转后的字符串相同，即 $P=P^{\\text{rev}}$。考虑标准的 Levenshtein 编辑操作，每次操作的单位成本为 $1$：单个字符的插入、单个字符的删除和单个字符的替换。从这些编辑操作的基本定义和回文串的结构特性出发，根据第一性原理推导出一个方法，以确定将字符串 $S$ 转换为任意回文串所需的最少编辑次数。精确计算这个最少的编辑次数。最终答案必须是一个实数值。不需要四舍五入。", "solution": "用户希望我找到将给定字符串转换成回文串所需的最少编辑操作（插入、删除、替换，单位成本均为1）次数。\n\n### 第1步：提取已知条件\n- 字符串为 $S = \\text{\"abracad\"}$。\n- 字符串长度为 $n=7$。\n- 回文串是一个与其反转字符串相同的字符串 $P$，即 $P = P^{\\text{rev}}$。\n- 允许的编辑操作是单个字符的插入、删除和替换。\n- 每次操作的成本为 $1$。\n- 目标是找到将 $S$ 转换为任意回文串的最小总成本。\n\n### 第2步：使用提取的已知条件进行验证\n所提出的问题是算法和数据结构领域的经典问题，特别涉及字符串操作和动态规划。\n- **科学依据（关键）**：该问题基于明确定义的数学和计算机科学概念：字符串、回文串和 Levenshtein 编辑距离。这些概念是合理且严格定义的。\n- **适定性**：该问题是适定的。它要求在一组定义好的操作上求最小值，这保证了存在一个唯一、稳定且有意义的数值解。\n- **客观性（关键）**：该问题以精确、客观的语言陈述，没有歧义或主观断言。\n\n该问题不存在任何无效性缺陷：\n1.  它不违反任何科学或数学原理。\n2.  这是一个与编辑距离直接相关的可形式化问题。\n3.  问题设定是完整且一致的。\n4.  条件是纯粹计算性的，而非物理性的，因此是可行的。\n5.  它结构良好，并允许一个唯一解。\n6.  这是一个需要特定算法方法的标准、非平凡问题。\n7.  结果是可验证的。\n\n### 第3步：结论与行动\n问题有效。我将进行完整的推导和解答。\n\n### 方法推导\n令给定字符串为 $S$，长度为 $n$。我们希望找到将 $S$ 转换为回文串所需的最少编辑次数（插入、删除或替换）。设对于一个通用子串 $S[i \\dots j]$，这个最少编辑次数由函数 $D(i, j)$ 表示。我们的目标是计算 $D(0, n-1)$。\n\n我们可以通过考虑子串两端的字符 $S[i]$ 和 $S[j]$ 来建立 $D(i, j)$ 的递推关系。\n\n**基本情况：**\n- 对于长度为 $1$ 的子串 $S[i \\dots i]$，它本身已经是回文串。因此，不需要编辑。$D(i, i) = 0$。\n- 对于长度为 $0$ 的子串（例如，当 $j  i$ 时），它也自然是回文串。成本为 $0$。\n\n**递推步骤：**\n考虑子串 $S[i \\dots j]$，其中 $i  j$。\n1.  **情况1：最外层字符匹配，$S[i] = S[j]$。**\n    如果子串两端的字符匹配，它们已经相互满足了回文串的属性。我们不需要编辑它们。问题简化为将内部子串 $S[i+1 \\dots j-1]$ 变为回文串。因此，最少编辑次数与内部子串所需编辑次数相同。\n    $$D(i, j) = D(i+1, j-1) \\quad \\text{if } S[i] = S[j]$$\n\n2.  **情况2：最外层字符不匹配，$S[i] \\neq S[j]$。**\n    由于 $S[i]$ 和 $S[j]$ 不匹配，我们必须执行至少一次编辑操作来解决这种不匹配。我们有三个基本选择，类似于 Levenshtein 距离操作：\n    a. **替换：** 我们可以更改其中一个字符以匹配另一个。例如，我们可以将 $S[i]$ 替换为与 $S[j]$ 相等的字符，或将 $S[j]$ 替换为与 $S[i]$ 相等的字符。无论哪种情况，成本都是 $1$ 次编辑。此操作后，两端匹配，我们剩下将内部字符串 $S[i+1 \\dots j-1]$ 变为回文串的子问题。此选择的总成本是 $1 + D(i+1, j-1)$。\n    b. **删除/插入（在左侧）：** 我们可以删除字符 $S[i]$。这需要 $1$ 次编辑。然后我们剩下将剩余子串 $S[i+1 \\dots j]$ 变为回文串的子问题。总成本是 $1 + D(i+1, j)$。这个操作在结果上等同于将 $S[i \\dots j-1]$ 转换为回文串，然后在开头插入一个字符以匹配 $S[j]$。\n    c. **删除/插入（在右侧）：** 对称地，我们可以删除字符 $S[j]$。这需要 $1$ 次编辑。我们剩下将 $S[i \\dots j-1]$ 变为回文串的子问题。总成本是 $1 + D(i, j-1)$。\n\n    因为我们想要最少的编辑次数，我们必须选择导致最小总成本的操作。\n    $$D(i, j) = 1 + \\min \\left( D(i+1, j), D(i, j-1), D(i+1, j-1) \\right) \\quad \\text{if } S[i] \\neq S[j]$$\n\n这个递推关系可以使用动态规划高效地解决。我们构建一个二维表，比如说 `dp[i][j]`，来存储 $D(i, j)$ 的值。我们按子串长度递增的顺序（从 $1$ 到 $n$）填充这个表。\n\n### 计算\n我们将此方法应用于字符串 $S = \\text{\"abracad\"}$（$n=7$，索引从 $0$ 到 $6$）。令 `dp[i][j]` 为存储 $D(i, j)$ 的表。\n\n**长度 $L=1$：**\n对于所有 $i \\in \\{0, \\dots, 6\\}$，`dp[i][i] = 0`。\n\n**长度 $L=2$：**\n- `dp[0][1]` (\"ab\"): $S[0] \\neq S[1] \\implies 1 + \\min(dp[1][1], dp[0][0], dp[1][0]) = 1 + \\min(0, 0, 0) = 1$。\n- 根据相同逻辑，对于所有长度为 $2$ 且字符不匹配的子串：\n  `dp[1][2]`(\"br\") $= 1$，`dp[2][3]`(\"ra\") $= 1$，`dp[3][4]`(\"ac\") $= 1$，`dp[4][5]`(\"ca\") $= 1$，`dp[5][6]`(\"ad\") $= 1$。\n\n**长度 $L=3$：**\n- `dp[0][2]` (\"abr\"): $S[0] \\neq S[2] \\implies 1 + \\min(dp[1][2], dp[0][1], dp[1][1]) = 1 + \\min(1, 1, 0) = 1$。\n- `dp[1][3]` (\"bra\"): $S[1] \\neq S[3] \\implies 1 + \\min(dp[2][3], dp[1][2], dp[2][2]) = 1 + \\min(1, 1, 0) = 1$。\n- `dp[2][4]` (\"rac\"): $S[2] \\neq S[4] \\implies 1 + \\min(dp[3][4], dp[2][3], dp[3][3]) = 1 + \\min(1, 1, 0) = 1$。\n- `dp[3][5]` (\"aca\"): $S[3] = S[5] \\implies dp[4][4] = 0$。\n- `dp[4][6]` (\"cad\"): $S[4] \\neq S[6] \\implies 1 + \\min(dp[5][6], dp[4][5], dp[5][5]) = 1 + \\min(1, 1, 0) = 1$。\n\n**长度 $L=4$：**\n- `dp[0][3]` (\"abra\"): $S[0] = S[3] \\implies dp[1][2] = 1$。\n- `dp[1][4]` (\"brac\"): $S[1] \\neq S[4] \\implies 1 + \\min(dp[2][4], dp[1][3], dp[2][3]) = 1 + \\min(1, 1, 1) = 2$。\n- `dp[2][5]` (\"raca\"): $S[2] \\neq S[5] \\implies 1 + \\min(dp[3][5], dp[2][4], dp[3][4]) = 1 + \\min(0, 1, 1) = 1$。\n- `dp[3][6]` (\"acad\"): $S[3] \\neq S[6] \\implies 1 + \\min(dp[4][6], dp[3][5], dp[4][5]) = 1 + \\min(1, 0, 1) = 1$。\n\n**长度 $L=5$：**\n- `dp[0][4]` (\"abrac\"): $S[0] \\neq S[4] \\implies 1 + \\min(dp[1][4], dp[0][3], dp[1][3]) = 1 + \\min(2, 1, 1) = 2$。\n- `dp[1][5]` (\"braca\"): $S[1] \\neq S[5] \\implies 1 + \\min(dp[2][5], dp[1][4], dp[2][4]) = 1 + \\min(1, 2, 1) = 2$。\n- `dp[2][6]` (\"racad\"): $S[2] \\neq S[6] \\implies 1 + \\min(dp[3][6], dp[2][5], dp[3][5]) = 1 + \\min(1, 1, 0) = 1$。\n\n**长度 $L=6$：**\n- `dp[0][5]` (\"abraca\"): $S[0] = S[5] \\implies dp[1][4] = 2$。\n- `dp[1][6]` (\"bracad\"): $S[1] \\neq S[6] \\implies 1 + \\min(dp[2][6], dp[1][5], dp[2][5]) = 1 + \\min(1, 2, 1) = 2$。\n\n**长度 $L=7$：**\n- `dp[0][6]` (\"abracad\"): $S[0] \\neq S[6] \\implies 1 + \\min(dp[1][6], dp[0][5], dp[1][5]) = 1 + \\min(2, 2, 2) = 3$。\n\n将字符串 $S=\\text{\"abracad\"}$ 转换为回文串所需的最少编辑次数由 `dp[0][6]` 给出，即 $3$。\n\n举一个包含3次编辑的例子：\n1.  将 $S[1]$（'b'）更改为 'a'。\n2.  将 $S[2]$（'r'）更改为 'c'。\n3.  将 $S[6]$（'d'）更改为 'a'。\n原始字符串 \"abracad\" 变为 \"aacacaa\"，这是一个回文串。总成本为 $3$。", "answer": "$$\\boxed{3}$$", "id": "3230960"}, {"introduction": "理论知识最终要服务于实际应用。这个综合练习将编辑距离的概念应用到一个真实世界的场景：拼写检查。你将构建一个 BK-树，这是一种利用编辑距离的度量特性（特别是三角不等式）来高效搜索相似字符串的复杂数据结构。[@problem_id:3216177]", "problem": "你的任务是设计并实现一个完整的程序，该程序构建并查询一个 Burkhard–Keller 树（BK-Tree），以使用 Levenshtein 距离进行近似字符串匹配。BK-树是一种有根树，其中每条边都由一个非负整数距离标记，每个节点存储域中的单个元素；它支持在度量空间下进行高效的范围查询。在这个问题中，域是固定字母表上的有限字符串集合，度量是 Levenshtein 距离。目标是从第一性原理推导出剪枝规则，并实现由此产生的搜索算法。\n\n基本基础和定义：\n- 度量空间是一个偶对 $(X, d)$，其中 $X$ 是一个集合，$d: X \\times X \\to \\mathbb{R}_{\\ge 0}$ 满足非负性、不可区分者同一性、对称性和三角不等式。三角不等式规定：对于所有 $x, y, z \\in X$，$d(x, z) \\le d(x, y) + d(y, z)$。\n- 字符串 $s$ 和 $t$ 之间的 Levenshtein 距离 $D(s, t)$ 是将 $s$ 转换为 $t$ 所需的单字符插入、删除和替换操作的最小次数。众所周知，$D$ 是一个度量，即 $D$ 满足上述度量公理。\n- Burkhard–Keller 树（BK-Tree）通过以下方式组织元素：对于每个存储元素 $u$ 的节点，如果存在一个元素 $v$ 使得 $D(u, v) = \\ell$，则在边标签为 $\\ell \\in \\mathbb{Z}_{\\ge 0}$ 的位置放置一个子节点。在插入过程中，从根节点开始，一个元素 $v$ 被路由到一个其边标签等于 $D(u, v)$ 的子节点；如果该子节点不存在，则在该边上创建一个新节点。\n\n任务：\n- 从三角不等式和范围查询的定义出发，推导在查询所有满足 $D(q, v) \\le k$（给定查询字符串 $q$ 和半径 $k \\in \\mathbb{Z}_{\\ge 0}$）的元素 $v$ 时，允许对搜索空间进行剪枝的子节点边标签的必要条件。问题描述没有提供明确的不等式；推导必须从度量公理开始，并得出一个可用于 BK-树搜索的剪枝准则。\n- 使用动态规划实现一个 Levenshtein 距离函数 $D(s, t)$。\n- 从一个有序的单词字典构建一个 BK-树，为每个单词分配一个等于其在给定列表中位置的索引（从 $0$ 开始）。每个 BK-树节点应存储单词及其索引。插入操作应遵循使用 $D$ 的 BK-树规则。\n- 实现一个范围查询，对于给定的 $(q, k)$，返回满足 $D(q, W[i]) \\le k$ 的索引 $i$ 的排序列表，其中 $W$ 是字典列表。\n\n测试套件和参数：\n- 使用以下字典 $W$（每个单词被赋予等于其在列表中位置的索引）：索引 $0$：“book”；索引 $1$：“books”；索引 $2$：“boo”；索引 $3$：“boon”；索引 $4$：“boom”；索引 $5$：“bone”；索引 $6$：“cook”；索引 $7$：“cool”；索引 $8$：“school”；索引 $9$：“fool”；索引 $10$：“boar”；索引 $11$：“board”；索引 $12$：“bored”；索引 $13$：“bond”；索引 $14$：“band”；索引 $15$：“ban”；索引 $16$：“an”；索引 $17$：“a”；索引 $18$：“bo”；索引 $19$：“hook”；索引 $20$：“brook”。\n- 对以下 $(q, k)$ 对运行范围查询：\n  - $(\\text{\"boon\"}, k = 1)$\n  - $(\\text{\"book\"}, k = 0)$\n  - $(\\text{\"\"}, k = 2)$ 其中允许空字符串\n  - $(\\text{\"scholl\"}, k = 1)$\n  - $(\\text{\"xyz\"}, k = 10)$\n- 对于每个测试用例，要求的答案是匹配的字典条目的索引的排序列表。每个单独的测试用例结果必须是一个整数列表。\n\n最终输出格式：\n- 你的程序应生成单行输出，包含一个由方括号括起来的逗号分隔列表，其中每个测试用例的结果本身也是一个由方括号括起来的逗号分隔的整数列表。例如，一个有效的输出格式是 $[[i_1,i_2],[j_1,j_2,j_3],\\dots]$，不含空格。", "solution": "该问题要求从第一性原理推导 Burkhard–Keller 树（BK-Tree）的搜索剪枝规则，并实现一个完整的程序来构建和查询这样一棵用于近似字符串匹配的树。匹配基于 Levenshtein 距离 $D$，查询旨在寻找字典 $W$ 中所有与查询字符串 $q$ 的距离在给定半径 $k$ 内的字符串 $v$，即 $D(q, v) \\le k$。\n\nBK-树效率的基础在于其存储的元素属于一个度量空间 $(X, d)$。度量空间是一个集合 $X$ 配备一个距离函数 $d: X \\times X \\to \\mathbb{R}_{\\ge 0}$，该函数满足四个公理：\n$1$. 非负性: $d(x, y) \\ge 0$\n$2$. 不可区分者同一性: $d(x, y) = 0 \\iff x = y$\n$3$. 对称性: $d(x, y) = d(y, x)$\n$4$. 三角不等式: $d(x, z) \\le d(x, y) + d(y, z)$\n\n在这个问题中，集合 $X$ 是有限字符串的集合，距离函数 $d$ 是 Levenshtein 距离 $D$。已知 $(X, D)$ 是一个度量空间。搜索算法的剪枝规则是三角不等式的直接推论。\n\n剪枝规则的推导：\n设 $q$ 为查询字符串，$k$ 为搜索半径。目标是找到树中所有满足 $D(q, v) \\le k$ 的字符串 $v$。搜索算法遍历树，在每个节点处，它必须决定其哪些子树（若有）可能包含匹配项。\n\n考虑在树中任意节点的搜索状态。设该节点包含字符串 $u$。算法已经计算了查询字符串 $q$ 与节点字符串 $u$ 之间的距离 $d_u = D(q, u)$。现在，考虑 $u$ 的一个子节点。通向此子节点的边标记有一个整数距离 $\\ell$。根据 BK-树的构造，位于以此子节点为根的子树中的任何字符串 $v$ 都必须满足条件 $D(u, v) = \\ell$。\n\n为了确定是否需要探索此子树，我们将三角不等式应用于三个字符串：查询 $q$、当前节点的字符串 $u$ 和子树中的潜在匹配 $v$。\n\n根据三角不等式，我们得到两个关键关系：\n$1$. $D(q, u) \\le D(q, v) + D(v, u)$。根据对称性，$D(v, u) = D(u, v)$，因此我们可以写成 $D(q, u) \\le D(q, v) + D(u, v)$。重新整理可得：\n$$D(q, u) - D(u, v) \\le D(q, v)$$\n\n$2$. $D(u, v) \\le D(u, q) + D(q, v)$。根据对称性，$D(u, q) = D(q, u)$，所以 $D(u, v) \\le D(q, u) + D(q, v)$。重新整理可得：\n$$D(u, v) - D(q, u) \\le D(q, v)$$\n\n这两个不等式可以合并为一个更紧凑的形式，通常称为反向三角不等式：\n$$|D(q, u) - D(u, v)| \\le D(q, v)$$\n\n我们正在搜索满足主要查询条件 $D(q, v) \\le k$ 的字符串 $v$。如果子树中的字符串 $v$ 是一个有效的匹配项，那么将反向三角不等式与查询条件结合可得：\n$$|D(q, u) - D(u, v)| \\le D(q, v) \\le k$$\n\n这意味着，要使任何潜在匹配 $v$ 存在于子树中，必须满足一个必要条件：\n$$|D(q, u) - D(u, v)| \\le k$$\n\n让我们代入已知值：$d_u = D(q, u)$ 是在当前节点计算出的距离，而 $\\ell = D(u, v)$ 是通往子树的边的标签。探索子树的必要条件变为：\n$$|d_u - \\ell| \\le k$$\n\n这个不等式就是剪枝规则。它表明我们只需要沿着边标签 $\\ell$ 与查询到当前节点的距离 $d_u$ “接近”的边遍历子节点。展开绝对值，得到需要检查的边标签范围：\n$$-k \\le d_u - \\ell \\le k$$\n这等价于：\n$$d_u - k \\le \\ell \\le d_u + k$$\n\n因此，搜索算法的执行步骤如下：\n$1$. 从 BK-树的根节点开始。\n$2$. 在包含字符串 $u$ 的给定节点：\n   a. 计算距离 $d_u = D(q, u)$。\n   b. 如果 $d_u \\le k$，则字符串 $u$ 是一个匹配项。将其索引添加到结果集中。\n   c. 遍历 $u$ 的所有子节点。对于每个通过标签为 $\\ell$ 的边连接的子节点，检查是否满足 $d_u - k \\le \\ell \\le d_u + k$。\n   d. 如果满足条件，则对该子节点递归应用搜索过程。否则，从搜索中剪掉该树的整个分支。\n\n这个推导出的规则使得算法可以避免为字典中大部分字符串计算 Levenshtein 距离，从而比线性扫描效率高得多。\n\n实现将包括三个主要部分：\n$1$. 一个使用标准动态规划方法和成本矩阵来计算 Levenshtein 距离 $D(s, t)$ 的函数。\n$2$. 一个基于类的 BK-树表示，其中包含一个 `Node` 结构来存储单词、其索引和子节点的字典，以及一个 `BKTree` 类来管理插入和查询。\n$3$. 一个查询方法，该方法使用推导出的剪枝规则 $|d_u - \\ell| \\le k$ 实现递归搜索。\n\n最终程序将从提供的字典构建树，然后执行指定的查询，并按要求收集和格式化结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef levenshtein_distance(s1: str, s2: str) - int:\n    \"\"\"\n    Calculates the Levenshtein distance between two strings using dynamic programming.\n    \"\"\"\n    m, n = len(s1), len(s2)\n    \n    # Initialize DP table. dp[i][j] will be the distance between the first\n    # i chars of s1 and the first j chars of s2.\n    dp = np.zeros((m + 1, n + 1), dtype=int)\n    \n    # Base cases: distance from an empty string to a non-empty one is the\n    # length of the non-empty string (all insertions).\n    for i in range(m + 1):\n        dp[i][0] = i\n    for j in range(n + 1):\n        dp[0][j] = j\n        \n    # Fill the rest of the table\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            cost = 0 if s1[i - 1] == s2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1,        # Deletion\n                           dp[i][j - 1] + 1,        # Insertion\n                           dp[i - 1][j - 1] + cost) # Substitution/Match\n                           \n    return dp[m][n]\n\nclass BKNode:\n    \"\"\"A node in the Burkhard-Keller Tree.\"\"\"\n    def __init__(self, word: str, index: int):\n        self.word = word\n        self.index = index\n        self.children = {}  # dict mapping distance to child BKNode\n\nclass BKTree:\n    \"\"\"A Burkhard-Keller Tree for approximate string matching.\"\"\"\n    def __init__(self):\n        self.root = None\n\n    def add(self, word: str, index: int):\n        \"\"\"Adds a word with its index to the tree.\"\"\"\n        if self.root is None:\n            self.root = BKNode(word, index)\n            return\n\n        current_node = self.root\n        while True:\n            dist = levenshtein_distance(current_node.word, word)\n            if dist in current_node.children:\n                current_node = current_node.children[dist]\n            else:\n                current_node.children[dist] = BKNode(word, index)\n                break\n\n    def query(self, query_word: str, k: int) - list[int]:\n        \"\"\"\n        Finds all words in the tree within Levenshtein distance k of the query_word.\n        Returns a sorted list of indices.\n        \"\"\"\n        if self.root is None:\n            return []\n            \n        matches = []\n        # A stack for iterative traversal to avoid deep recursion\n        stack = [self.root]\n\n        while stack:\n            node = stack.pop()\n            # Calculate distance from query word to the current node's word\n            dist_to_node = levenshtein_distance(query_word, node.word)\n\n            # If the current node is a match, add its index\n            if dist_to_node = k:\n                matches.append(node.index)\n\n            # Use the triangle inequality to prune branches\n            # We only need to visit children in the range [d-k, d+k]\n            low = dist_to_node - k\n            high = dist_to_node + k\n\n            for dist, child in node.children.items():\n                if low = dist = high:\n                    stack.append(child)\n        \n        matches.sort()\n        return matches\n\ndef solve():\n    # Define the dictionary and test cases from the problem statement.\n    dictionary = [\n        \"book\", \"books\", \"boo\", \"boon\", \"boom\", \"bone\", \"cook\", \"cool\",\n        \"school\", \"fool\", \"boar\", \"board\", \"bored\", \"bond\", \"band\", \"ban\",\n        \"an\", \"a\", \"bo\", \"hook\", \"brook\"\n    ]\n    \n    test_cases = [\n        (\"boon\", 1),\n        (\"book\", 0),\n        (\"\", 2),\n        (\"scholl\", 1),\n        (\"xyz\", 10)\n    ]\n\n    # Build the BK-Tree\n    bktree = BKTree()\n    for i, word in enumerate(dictionary):\n        bktree.add(word, i)\n        \n    all_results = []\n    for q, k in test_cases:\n        result = bktree.query(q, k)\n        all_results.append(result)\n\n    # Format the output exactly as specified: [[i1,i2],[j1],...] with no spaces\n    case_strings = []\n    for res_list in all_results:\n        case_strings.append(f\"[{','.join(map(str, res_list))}]\")\n    final_output_string = f\"[{','.join(case_strings)}]\"\n    \n    print(final_output_string)\n\nsolve()\n```", "id": "3216177"}]}