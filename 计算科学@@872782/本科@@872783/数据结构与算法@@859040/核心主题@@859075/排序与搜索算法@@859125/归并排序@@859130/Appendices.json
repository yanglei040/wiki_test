{"hands_on_practices": [{"introduction": "归并排序的效率核心在于其线性的“合并”步骤。本练习将挑战你调整这一核心逻辑，以应对一个特殊场景：合并两个排序方向相反的列表。这个练习将加深你对指针操作以及合并有序序列基本原理的理解 ([@problem_id:3252316])。", "problem": "给定两个有限整数序列，记为 $A$ 和 $B$，其中 $A$ 按非递减顺序排序，而 $B$ 按非递增顺序排序。设 $n = |A|$ 且 $m = |B|$。你的任务是设计并实现一个程序，使用基于比较的方法将这两个序列合并成一个单一的非递减序列，同时优化元素间的比较次数。程序不得物理上反转 $B$ 或创建 $B$ 的辅助副本；除了输出数组外，它必须只使用常数级别的额外内存。\n\n使用的基本原理：基于比较的计算模型、全序的定义，以及分治排序中成熟的合并操作。你可以假设采用标准的代数决策树模型，其中比较键值的唯一方法是成对比较，我们衡量的成本是此类比较的次数。你的推导过程必须从这些基本原理出发。\n\n定义以下确定性的平局打破规则，以确保结果唯一：\n- 当比较 $A$ 和 $B$ 中相等的键值时（即，在当前考虑的任何索引下，当 $A[i] = B[j]$ 时），优先放置来自 $A$ 的键值。\n- 当 $B$ 中剩下多个相等的键值时，保持这些键值如果从右到左读取 $B$ 时（即按非递减顺序）出现的顺序。此规则对应于通过逻辑上的升序视图来处理 $B$，而无需物理上反转它。\n\n要求：\n- 正确性：输出序列必须是 $A$ 和 $B$ 按非递减顺序合并后的排序结果，并且遵守上述平局打破规则。\n- 最优性目标：在最坏情况下，最小化基于比较计数成本模型的键值比较次数，并证明在所有除了给定的 $A$ 和 $B$ 的单调性之外不作更多结构假设的算法中，你的算法为何达到了最优的最坏情况比较次数。\n- 空间：在用于存储输出的空间之外，使用 $\\mathcal{O}(1)$ 的辅助空间。\n- 时间：实现 $\\mathcal{O}(n + m)$ 的时间复杂度。\n\n你的程序必须对下面指定的每个测试用例产生两个输出：\n- 合并后的非递减整数列表。\n- 为生成该合并列表所执行的元素间比较的总次数。\n\n需要实现和评估的测试套件：\n- 用例 1：$A = [\\,1,4,6,9\\,]$, $B = [\\,10,7,5,2\\,]$。\n- 用例 2：$A = [\\,]$, $B = [\\,5,3,1\\,]$。\n- 用例 3：$A = [\\,-2,0,3\\,]$, $B = [\\,]$。\n- 用例 4：$A = [\\,1,2,2,3\\,]$, $B = [\\,4,3,2,2,1\\,]$。\n- 用例 5：$A = [\\,-10,-5,0,5\\,]$, $B = [\\,8,4,-1,-6,-9\\,]$。\n- 用例 6：$A = [\\,2\\,]$, $B = [\\,3\\,]$。\n\n最终输出格式：\n- 你的程序应产生单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。每个结果本身必须是一个列表，其第一个元素是合并后的整数列表，第二个元素是比较次数的整数值，例如 $[\\, [\\text{merged}_{1}, \\text{comparisons}_{1}], [\\text{merged}_{2}, \\text{comparisons}_{2}], \\ldots \\,]$。\n- 具体来说，你的程序必须向标准输出打印恰好一行，格式为 $[r_1,r_2,r_3,r_4,r_5,r_6]$，其中每个 $r_k$ 是如上所述的一个双元素列表。", "solution": "问题陈述经分析被确定为有效。这是一个在算法和数据结构领域内适定 (well-posed) 且有科学依据的问题，没有矛盾或含糊之处。\n\n### 基于原则的设计与论证\n\n问题的核心是将长度分别为 $n = |A|$ 和 $m = |B|$ 的两个序列 $A$ 和 $B$ 合并成一个单一的非递减序列。序列 $A$ 按非递减顺序排序（$A[0] \\le A[1] \\le \\dots \\le A[n-1]$），而序列 $B$ 按非递增顺序排序（$B[0] \\ge B[1] \\ge \\dots \\ge B[m-1]$）。约束条件是：使用 $\\mathcal{O}(1)$ 的辅助空间（输出数组除外），实现 $\\mathcal{O}(n + m)$ 的时间复杂度，并最小化最坏情况下的元素间比较次数。\n\n基本原理是归并排序中使用的标准合并算法的原理。标准的合并操作作用于两个同向排序的序列。给定问题提出了一个变种，其中序列是反向排序的。\n\n关键的洞察在于，一个按非递增顺序排序的序列如果反向读取，就等价于一个按非递减顺序排序的序列。问题明确禁止物理上反转或创建序列 $B$ 的副本。然而，我们可以通过使用一个从 $B$ 的最后一个元素移动到第一个元素（即从索引 $m-1$ 向下到 $0$）的指针来遍历它，从而达到相同的逻辑效果。这种方法遵守了空间约束。\n\n因此，我们可以使用双指针技术设计一个算法：\n1.  初始化一个指向序列 $A$ 的指针 $i$ 为 $0$。该指针将从左到右遍历 $A$。\n2.  初始化一个指向序列 $B$ 的指针 $j$ 为 $m-1$。该指针将从右到左遍历 $B$。\n3.  初始化一个指向大小为 $n+m$ 的输出数组（我们称之为 $C$）的指针 $k$ 为 $0$。\n4.  初始化比较计数器 `comparisons` 为 $0$。\n\n主要的合并过程在一个循环中进行，只要两个序列中都还有待考虑的元素（即，当 $i  n$ 且 $j \\ge 0$ 时），循环就继续：\n- 增加 `comparisons` 计数器，因为我们即将执行一次元素间的比较。\n- 比较元素 $A[i]$ 和 $B[j]$。\n- 为了构建一个非递减的输出序列，我们必须总是选择两个候选元素中较小的一个。\n- 问题指定了平局打破规则：如果 $A[i] = B[j]$，必须先放置来自 $A$ 的元素。这可以通过条件 $A[i] \\le B[j]$ 正确实现。\n- 如果 $A[i] \\le B[j]$，元素 $A[i]$ 是较小或相等的元素（遵守了平局打破规则）。我们将 $A[i]$ 复制到 $C[k]$，然后推进指针 $i$ 和 $k$。\n- 否则（$A[i] > B[j]$），元素 $B[j]$ 严格更小。我们将 $B[j]$ 复制到 $C[k]$，然后递减指针 $j$（以移动到 $B$ 中的下一个最小元素）并递增 $k$。\n\n一旦主循环终止，其中一个序列已被完全消耗。另一个序列中剩余的元素都大于或等于已放入 $C$ 中的任何元素。它们可以直接复制到 $C$ 的末尾，无需任何进一步的比较。\n- 如果指针 $i$ 尚未到达 $A$ 的末尾（$i  n$），则将剩余的元素 $A[i \\dots n-1]$ 复制到 $C$。\n- 如果指针 $j$ 尚未到达 $B$ 的开头（$j \\ge 0$），则将剩余的元素 $B[j \\dots 0]$ 复制到 $C$。\n\n该算法正确地合并了两个序列，同时遵守了指定的约束。\n- **时间复杂度**：每次比较都会导致一个元素被放入输出数组 $C$。后续的复制操作也每步放置一个元素。总的来说，$A$ 和 $B$ 中的每个元素都被处理一次，从而得到 $\\mathcal{O}(n+m)$ 的时间复杂度。\n- **空间复杂度**：该算法使用了几个指针（$i, j, k$）和一个计数器。这构成了常数级别，即 $\\mathcal{O}(1)$ 的辅助空间，因为输出数组 $C$ 的空间不计入此限制。满足了不反转或复制 $B$ 的约束。\n\n### 比较次数的最优性\n\n问题要求最小化最坏情况下的比较次数。对于合并两个长度为 $n$ 和 $m$ 的已排序列表（其中 $n, m \\ge 1$），在基于比较的算法研究中，一个公认的结论是，任何算法在最坏情况下都必须执行至少 $n+m-1$ 次比较。这可以通过对抗论证（adversary argument）来证明。对手可以构造输入，迫使算法做出只揭示最少量信息的选择，从而最大化完全确定排序顺序所需的总比较次数。这种最坏情况发生在两个列表的元素完美交错时，迫使算法为前 $n+m-1$ 个元素中的每一个都进行一次比较来决定其位置。最后一个、也是最大的元素的位置随后无需比较即可知晓。\n\n我们提出的算法的比较次数由主循环决定。在该循环的每次迭代中，都执行恰好一次比较，并将一个元素放入输出数组。循环一直持续到其中一个列表耗尽。在最坏情况下，循环会运行直到 $n+m-1$ 个元素被放置，此时一个列表将剩下一个元素而另一个将为空。这需要恰好 $n+m-1$ 次比较。最后一个元素随后无需比较即可复制。\n\n因此，该算法最多执行 $n+m-1$ 次比较（对于 $n,m \\ge 1$）。由于这与理论下界相匹配，该算法在最坏情况比较次数方面是最优的。对于 $n=0$ 或 $m=0$ 的情况，合并是平凡的，需要 0 次比较，我们的算法能够正确处理。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the merge problem for a suite of test cases and prints the results.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        {'A': [1, 4, 6, 9], 'B': [10, 7, 5, 2]},\n        # Case 2\n        {'A': [], 'B': [5, 3, 1]},\n        # Case 3\n        {'A': [-2, 0, 3], 'B': []},\n        # Case 4\n        {'A': [1, 2, 2, 3], 'B': [4, 3, 2, 2, 1]},\n        # Case 5\n        {'A': [-10, -5, 0, 5], 'B': [8, 4, -1, -6, -9]},\n        # Case 6\n        {'A': [2], 'B': [3]},\n    ]\n\n    results = []\n    for case in test_cases:\n        A = case['A']\n        B = case['B']\n        merged_list, comparisons = merge_with_optimal_comparisons(A, B)\n        results.append([merged_list, comparisons])\n\n    # Final print statement in the exact required format.\n    # The default str() representation of lists is used, which includes spaces.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef merge_with_optimal_comparisons(A, B):\n    \"\"\"\n    Merges a non-decreasing sequence A and a non-increasing sequence B\n    into a single non-decreasing sequence.\n\n    Args:\n        A (list[int]): A sequence of integers sorted in nondecreasing order.\n        B (list[int]): A sequence of integers sorted in nonincreasing order.\n\n    Returns:\n        tuple[list[int], int]: A tuple containing the merged nondecreasing list\n                               and the total number of element-to-element\n                               comparisons performed.\n    \"\"\"\n    n = len(A)\n    m = len(B)\n    \n    # The output array is permitted per the problem statement.\n    merged_list = [0] * (n + m)\n    comparisons = 0\n    \n    i = 0      # Pointer for A, traversing from left to right (0 to n-1)\n    j = m - 1  # Pointer for B, traversing from right to left (m-1 to 0)\n    k = 0      # Pointer for the output merged_list\n    \n    # Main merge loop, continues as long as both lists have elements.\n    while i  n and j = 0:\n        comparisons += 1\n        # The core comparison. A is non-decreasing, and B viewed backwards\n        # is also non-decreasing. We take the smaller of the two candidates.\n        # Tie-breaking rule: if A[i] == B[j], the element from A is placed first.\n        # This is correctly handled by the condition A[i] = B[j].\n        if A[i] = B[j]:\n            merged_list[k] = A[i]\n            i += 1\n        else:\n            merged_list[k] = B[j]\n            j -= 1\n        k += 1\n        \n    # After the main loop, one of the lists is exhausted.\n    # Copy the remaining elements from the other list. No more comparisons are needed.\n    \n    # If any elements remain in A, copy them.\n    while i  n:\n        merged_list[k] = A[i]\n        i += 1\n        k += 1\n        \n    # If any elements remain in B, copy them.\n    # The pointer j is decremented, correctly copying B's elements\n    # in their logical nondecreasing order (right-to-left).\n    while j = 0:\n        merged_list[k] = B[j]\n        j -= 1\n        k += 1\n        \n    return merged_list, int(comparisons)\n\n# Entry point for execution.\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3252316"}, {"introduction": "归并排序的威力远不止于排序元素。本练习将展示如何利用其“分而治之”的框架来高效解决复杂的计数问题。通过在合并步骤中嵌入一个巧妙的计数机制，你将学会利用“子数组有序”这一不变性，来完成那些在其他情况下可能非常耗时的计算 ([@problem_id:3252453])。", "problem": "给定一个在整数全序域上的长度为 $n$ 的数组 $A$，其中全序关系 $\\le$ 满足传递性、反对称性和完全性。其基本思想是分治（DC）的定义：将一个大小为 $n$ 的集合上的问题分解为更小子集上的子问题，独立解决这些子问题，然后利用问题的既定不变量（此处的不变量是合并步骤后数组是有序的）来合并解。您的任务是实现一个分治归并排序的变体，在归并步骤中，计算满足 $0 \\le i  j  n$ 且 $A[i] > 2 \\cdot A[j]$ 的跨子数组索引对 $(i,j)$ 的数量。对于每个输入数组，最终算法必须返回两个输出：数组的排序版本和整个数组中此类数对的总数。期望的计算复杂度为 $\\mathcal{O}(n \\log n)$ 的时间和 $\\mathcal{O}(n)$ 的辅助空间，这源于归并排序的标准特性。\n\n要求：\n- 以数组、全序和分治归并排序结构的定义为基础。在合并步骤中，只对来自左子数组和右子数组的元素进行比较或合并。\n- 只计算满足数组索引顺序 $i  j$ 的数对 $(i,j)$，并且在归并步骤中，$i$ 属于左子数组，$j$ 属于右子数组；将所有递归层级上的这些计数汇总，即可得到原始数组中满足 $A[i] > 2 \\cdot A[j]$ 的总数对数量。\n- 对每个测试用例，生成一个包含两个元素的列表：排序后的数组和数对的整数计数。\n\n测试套件：\n- 情况 1：$A = []$。\n- 情况 2：$A = [5]$。\n- 情况 3：$A = [1,3,2,3,1]$。\n- 情况 4：$A = [10,9,8,7,6,5,4,3,2,1]$。\n- 情况 5：$A = [-5,-4,-2,-1]$。\n- 情况 6：$A = [0,0,0,0]$。\n- 情况 7：$A = [2,4,3,5,1,-2,8,16]$。\n- 情况 8：$A = [2147483647,-2147483648]$。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表。每个列表项本身必须是一个 $[\\text{sorted\\_array}, \\text{count}]$ 形式的双元素列表。例如，一个包含两个测试用例的有效输出应如下所示：$[[[1,2,3],2],[[1],0]]$。您的程序不得读取任何输入，并且必须使用上述数组作为内置测试套件。", "solution": "该问题要求实现一个分治算法，具体来说是归并排序的一个变体，用以计算一个长度为 $n$ 的数组 $A$ 中满足 $i  j$ 和 $A[i] > 2 \\cdot A[j]$ 的索引对 $(i, j)$ 的数量。该算法还必须返回数组的排序版本。规定的计算复杂度为 $\\mathcal{O}(n \\log n)$ 的时间复杂度和 $\\mathcal{O}(n)$ 的辅助空间复杂度。\n\n该解决方案的基础是分治（Divide and Conquer）范式，其中一个大小为 $n$ 的集合上的问题被递归地分解为更小的、独立的子问题。然后，这些子问题的解被合并以形成原始问题的解。对于计数数对的任务，此原则可形式化如下：\n\n设 $C(A)$ 为数组 $A$ 中满足给定条件的数对计数。当我们在中点 $m = \\lfloor n/2 \\rfloor$ 将 $A$ 分割为左子数组 $A_{left} = A[0 \\dots m-1]$ 和右子数组 $A_{right} = A[m \\dots n-1]$ 时，任何满足 $i  j$ 的数对 $(i,j)$ 必须属于以下三个不相交的类别之一：\n1. 索引 $i$ 和 $j$ 都在左子数组中。\n2. 索引 $i$ 和 $j$ 都在右子数组中。\n3. 索引 $i$ 在左子数组中，索引 $j$ 在右子数组中。\n\n这种分解给出了总计数的递推关系：\n$$ C(A) = C(A_{left}) + C(A_{right}) + C_{cross}(A_{left}, A_{right}) $$\n其中 $C_{cross}$ 表示一个元素来自左子数组、另一个元素来自右子数组的数对数量。这种结构天然适合基于归并排序的算法。对子数组的递归调用处理前两项，而 $C_{cross}$ 项则在归并步骤中计算。\n\n该算法是一个递归函数，我们称之为 `Solve(A)`，它返回一个元组，包含 $A$ 的排序版本和所求的数对数量。\n\n**基本情况：**\n如果数组 $A$ 的长度 $n \\le 1$，那么它根据定义已经是有序的，并且不可能存在满足 $i  j$ 的数对 $(i,j)$。因此，函数返回 $(A, 0)$。\n\n**递归步骤：**\n对于长度 $n > 1$ 的数组 $A$，函数执行以下步骤：\n1.  **分解：** 数组 $A$ 被分成两半：$A_{left} = A[0 \\dots m-1]$ 和 $A_{right} = A[m \\dots n-1]$，其中 $m = \\lfloor n/2 \\rfloor$。\n2.  **解决：** 对每一半递归调用该函数：\n    - $(S_{left}, count_{left}) = \\text{Solve}(A_{left})$\n    - $(S_{right}, count_{right}) = \\text{Solve}(A_{right})$\n    这里，$S_{left}$ 和 $S_{right}$ 分别是对应子数组的排序版本，$count_{left}$ 和 $count_{right}$ 是完全包含在它们内部的数对计数。\n3.  **合并：** 此步骤涉及两个子任务：将已排序的子数组 $S_{left}$ 和 $S_{right}$ 合并成一个单一的排序数组 $S_{merged}$，并计算跨子数组的数对 $count_{cross}$。当前层级的总计数为 $count_{left} + count_{right} + count_{cross}$。\n\n**核心：归并与计算跨区数对**\n该算法的关键部分是合并步骤，该步骤必须在线性时间，即 $\\mathcal{O}(|S_{left}| + |S_{right}|)$ 内运行，以保持整体 $\\mathcal{O}(n \\log n)$ 的时间复杂度。\n\n**计算跨区数对：**\n给定两个已排序的数组 $S_{left}$ 和 $S_{right}$。我们需要计算元素对 $(u,v)$ 的数量，其中 $u \\in S_{left}$ 且 $v \\in S_{right}$，并且满足 $u > 2v$。元素 $u$ 和 $v$ 对应于原始数组中的值 $A[i]$ 和 $A[j]$，其中 $i$ 在左分区，$j$ 在右分区，因此 $i  j$ 天然成立。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem for a predefined test suite and prints the-\n    results in the specified format.\n    \"\"\"\n    \n    test_cases = [\n        [],\n        [5],\n        [1, 3, 2, 3, 1],\n        [10, 9, 8, 7, 6, 5, 4, 3, 2, 1],\n        [-5, -4, -2, -1],\n        [0, 0, 0, 0],\n        [2, 4, 3, 5, 1, -2, 8, 16],\n        [2147483647, -2147483648],\n    ]\n\n    def _merge_sort_and_count(arr):\n        \"\"\"\n        Recursively sorts an array and counts pairs (i, j) with i  j\n        and arr[i] > 2 * arr[j].\n\n        Args:\n            arr (list): The input list of integers.\n\n        Returns:\n            tuple: A tuple containing the sorted list and the integer count.\n        \"\"\"\n        n = len(arr)\n        if n = 1:\n            return list(arr), 0\n\n        mid = n // 2\n        \n        # Conquer: Recursively solve for subarrays\n        sorted_left, count_left = _merge_sort_and_count(arr[:mid])\n        sorted_right, count_right = _merge_sort_and_count(arr[mid:])\n        \n        # Combine Step Part 1: Count cross-subarray pairs\n        # This must be done on the sorted subarrays to achieve O(n) complexity for this step.\n        count_cross = 0\n        j = 0\n        for i in range(len(sorted_left)):\n            while j  len(sorted_right) and sorted_left[i]  2 * sorted_right[j]:\n                j += 1\n            count_cross += j\n            \n        # Combine Step Part 2: Merge the sorted subarrays\n        merged_array = []\n        i, j = 0, 0\n        while i  len(sorted_left) and j  len(sorted_right):\n            if sorted_left[i] = sorted_right[j]:\n                merged_array.append(sorted_left[i])\n                i += 1\n            else:\n                merged_array.append(sorted_right[j])\n                j += 1\n        \n        # Append any remaining elements\n        merged_array.extend(sorted_left[i:])\n        merged_array.extend(sorted_right[j:])\n        \n        total_count = count_left + count_right + count_cross\n        \n        return merged_array, total_count\n\n    results = []\n    for case in test_cases:\n        result_array, result_count = _merge_sort_and_count(case)\n        results.append([result_array, result_count])\n\n    # Format the final output string precisely as required, without extra spaces.\n    result_strings = []\n    for res_arr, res_count in results:\n        arr_str = f\"[{','.join(map(str, res_arr))}]\"\n        result_strings.append(f\"[{arr_str},{res_count}]\")\n    \n    final_output = f\"[{','.join(result_strings)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "3252453"}, {"introduction": "当底层数据结构不是数组时，算法的实现会如何改变？本练习要求你在单向链表上实现归并排序，并附加了节点不可变的约束。这个经典问题将加深你对数据结构、递归以及算法设计中各种权衡的理解 ([@problem_id:3252314])。", "problem": "您的任务是设计并实现一个对单链表进行操作的、稳定的、基于比较的排序算法，该算法受制于原始节点的不可变性约束。您的推理必须从单链表和分治范式的定义出发：单链表是一个节点序列，每个节点包含一个值和一个指向下一个节点的指针；分治法将输入划分为子问题，递归地解决每个子问题，并合并结果。您不得依赖任何预先提供的算法捷径；必须从这些基础出发推导出方法。具体约束是原始节点的 `next` 指针不能被修改；排序后的输出必须构建为一个新的单链表，其节点是新分配的。该算法必须是稳定的，即如果两个元素的键相等，它们在输出中的相对顺序必须与它们在输入中的相对顺序相匹配。您的程序必须为一个测试套件生成可量化的输出，该测试套件应覆盖一般情况、边界条件和边缘情况。\n\n要求：\n1. 数据模型和约束：\n   - 输入是一个单链表，每个节点包含一个整数键和一个可选的符号标签。\n   - 原始列表的 `next` 指针必须被视为不可变的。您只能创建新节点；您可以读取原始节点，但不得修改任何原始的 `next` 指针。\n   - 输出必须是一个新的单链表，包含相同的键，按非递减顺序排序，并保持稳定性。\n2. 算法设计任务：\n   - 实现一个对单链表进行操作的稳定归并排序，它构建一个排序后的副本而不修改原始节点。合并操作的设计必须通过根据原始的从左到右的优先级来解决键相等的情况，从而保持稳定性。\n   - 建立一种在不改变原始指针的情况下将列表分成两半的方法（例如，通过将指针前移一个计算出的中点），并从第一性原理出发论证其正确性和复杂性。\n3. 复杂度和正确性期望：\n   - 算法的运行时间应为 $\\mathcal{O}(n \\log n)$，其中 $n$ 是输入列表中的节点数，并使用 $\\mathcal{O}(n)$ 的额外内存用于新分配的节点，外加因递归产生的 $\\mathcal{O}(\\log n)$ 的栈帧。请从分治结构和单链表的性质出发推导这些界限，不要依赖于记忆的公式。\n4. 测试套件和输出：\n   - 将您的实现应用于以下输入测试套件。每个测试用例指定一个键序列；在有标签的情况下，它们是不用于比较的次要标签，旨在验证稳定性。\n     - 测试用例 $1$ (一般情况): 键 $\\left[4,1,3,9,7,0,2,5,8,6\\right]$。\n     - 测试用例 $2$ (边界: 空列表): 键 $\\left[\\,\\right]$。\n     - 测试用例 $3$ (边界: 单个元素): 键 $\\left[42\\right]$。\n     - 测试用例 $4$ (重复项): 键 $\\left[5,3,3,5,2,2,1,1\\right]$。\n     - 测试用例 $5$ (已排序): 键 $\\left[1,2,3,4,5\\right]$。\n     - 测试用例 $6$ (负数和混合): 键 $\\left[-3,-1,-7,0,2\\right]$。\n     - 测试用例 $7$ (带标签的稳定性验证): 对 $\\left[(2,a),(1,x),(2,b),(1,y),(2,c)\\right]$，其中键是第一个分量，标签 $a,x,b,y,c$ 是符号标签。仅按键排序，并通过检查在每个相等的键组内，标签是否以与原始输入中相同的顺序出现来验证输出的稳定性。\n   - 对于测试用例 $1$ 到 $6$，以整数列表的形式输出排序后的键。对于测试用例 $7$，输出一个布尔值，断言稳定性是否成立（当且仅当相等键组内的标签顺序被保留时为真）。\n5. 最终输出格式：\n   - 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔的结果列表，例如 $\\left[\\text{result}_1,\\text{result}_2,\\dots,\\text{result}_7\\right]$。每个 $\\text{result}_i$ 必须是整数列表或布尔值，并严格按照上述测试用例的顺序。不应打印任何额外的文本或行。\n\n此问题不涉及物理单位、角度单位或百分比；只需要纯整数键和布尔值输出。", "solution": "问题陈述要求设计并实现一个用于单链表的、稳定的、基于比较的排序算法。核心约束是原始列表的节点是不可变的（它们的 `next` 指针不能被更改），并且排序后的输出必须是一个新构建的链表。解决方案必须从分治范式的第一性原理推导出来。\n\n### **问题验证**\n\n**第 1 步：提取已知条件**\n\n*   **输入数据结构**：一个单链表，其中每个节点包含一个整数 `key` 和一个可选的符号 `tag`。\n*   **不可变性约束**：原始输入列表中节点的 `next` 指针不得被修改。\n*   **输出数据结构**：一个新分配节点构成的新单链表，包含与输入相同的数据，按键的非递减顺序排序。\n*   **算法要求**：一个从分治范式推导出的稳定归并排序。\n*   **稳定性要求**：如果两个元素的键相等，它们在排序后输出中的相对顺序必须与它们在输入中的相对顺序完全相同。\n*   **复杂度要求**：\n    *   时间：$\\mathcal{O}(n \\log n)$。\n    *   空间：$\\mathcal{O}(n)$ 用于新节点，以及 $\\mathcal{O}(\\log n)$ 用于递归栈。这些界限必须被推导出来。\n*   **测试用例**：\n    1.  键: $\\left[4,1,3,9,7,0,2,5,8,6\\right]$\n    2.  键: $\\left[\\,\\right]$\n    3.  键: $\\left[42\\right]$\n    4.  键: $\\left[5,3,3,5,2,2,1,1\\right]$\n    5.  键: $\\left[1,2,3,4,5\\right]$\n    6.  键: $\\left[-3,-1,-7,0,2\\right]$\n    7.  键-标签对: $\\left[(2,a),(1,x),(2,b),(1,y),(2,c)\\right]$\n*   **输出格式**：单行输出，包含一个用方括号括起来的逗号分隔的结果列表（对于用例 1-6 是排序后的整数列表，对于用例 7 是一个布尔值）。\n\n**第 2 步：使用提取的已知条件进行验证**\n\n该问题是有效的。\n*   **科学上成立**：该问题是计算机科学中的一个经典练习，专注于链表、排序算法（特别是归并排序）和算法复杂性等成熟主题。\n*   **定义良好**：目标、约束和所需输出都已精确指定。单链表、不可变性约束和稳定性要求的组合定义了一个非平凡但可解的问题，对于任何给定的输入都有唯一正确的输出。\n*   **客观的**：问题使用正式、明确的语言陈述。\n\n该问题没有违反任何无效性标准。它是算法领域内一个完整、一致且可形式化的问题。\n\n**第 3 步：结论与行动**\n\n该问题是**有效的**。将提供一个解决方案。\n\n### **基于原理的解决方案**\n\n#### **1. 基本原理**\n\n**单链表**是一种线性数据结构，由一系列节点组成。每个节点存储一个有效载荷（本例中为一个键和一个可选标签）以及一个指向后续节点的单一引用或指针。通过对列表第一个节点（即 `head`）的引用来访问列表。最后一个节点的指针为 `null`，表示列表的结束。\n\n**分治**范式是一种包含三个阶段的算法策略：\n1.  **分割**：将问题划分为相同类型的、更小的、独立的子问题。\n2.  **征服**：解决这些子问题，通常通过递归应用相同算法。如果子问题足够小（基本情况），则直接解决。\n3.  **合并**：将子问题的解合并，以构建原始问题的解。\n\n我们将应用此范式来排序一个长度为 $n$ 的单链表。\n\n#### **2. 算法设计：用于链表的不可变归并排序**\n\n**基本情况（征服）**\n最简单的排序情况是空列表或只有一个元素的列表。根据定义，这两种情况都已排序。\n- 如果列表长度 $n=0$（为空），其排序版本也是一个空列表。\n- 如果列表长度 $n=1$，其排序版本是一个新列表，包含一个新分配的、具有相同值的单个节点。\n\n**分割步骤**\n分割步骤的核心是将长度为 $n$ 的列表分成两个大小近似相等的子列表，长度分别为 $\\lfloor n/2 \\rfloor$ 和 $\\lceil n/2 \\rceil$。在数组中，这是一个通过索引计算实现的 $\\mathcal{O}(1)$ 操作。对于单链表，我们必须遍历列表来找到中点。为了在不修改原始列表指针的情况下做到这一点，我们首先找到列表的总长度 $n$。中点位于索引 $m = \\lfloor n/2 \\rfloor$ 处。第一个子列表是从 `head` 开始到长度为 $m$ 的节点序列。第二个子列表从索引 $m$ 处的节点开始，一直到原始列表的末尾，长度为 $n - m$。\n\n为实现这一点，我们的递归排序函数将接受一个起始节点和待排序列表段的长度。\n1.  计算中点索引：$m = \\lfloor \\text{length}/2 \\rfloor$。\n2.  通过从当前头节点开始并将其指针前移 $m$ 次，找到右子列表的头节点。\n3.  左子列表由原始头节点和长度 $m$ 定义。\n4.  右子列表由步骤 2 中找到的新头节点和长度 $\\text{length} - m$ 定义。\n\n这个分割过程需要 $\\mathcal{O}(m) = \\mathcal{O}(n)$ 步的遍历来找到第二个子列表的头节点。\n\n**递归调用（征服）**\n在概念上分割列表后，我们对两个子列表递归调用排序函数：\n- `sorted_left = mergesort(head_left, m)`\n- `sorted_right = mergesort(head_right, \\text{length} - m)`\n\n每个递归调用返回一个新的、已排序的链表。\n\n**合并步骤（Merge）**\n此步骤接收两个已排序的链表 `sorted_left` 和 `sorted_right`，并将它们合并成一个单一的、新构建的、已排序的链表。这个合并操作是该算法稳定性及其名称的来源。\n\n1.  为新列表创建一个 `dummy_head`。这通过提供一个固定的入口点来简化逻辑，避免了对第一个节点插入的特殊处理。一个 `tail` 指针将跟踪新列表的最后一个节点，初始指向 `dummy_head`。\n2.  当 `sorted_left` 和 `sorted_right` 都非空时进行迭代。在每次迭代中，比较两个列表当前头节点的键。\n3.  **稳定性**：为确保稳定性，如果 `sorted_left.key \\le sorted_right.key`，我们必须从 `sorted_left` 中选择节点。这条规则保证了对于键相等的元素，原始输入中先出现的那个（因此在左子列表中）会被先放入输出中。\n    - 如果 `sorted_left.key \\le sorted_right.key`：用 `sorted_left` 的数据创建一个新节点，将其附加到 `tail.next`，并前移 `sorted_left` 指针。\n    - 否则：用 `sorted_right` 的数据创建一个新节点，将其附加到 `tail.next`，并前移 `sorted_right` 指针。\n4.  更新 `tail` 指向新创建的节点。\n5.  循环终止后，其中一个列表将被耗尽。另一个可能仍包含元素。剩余的（已排序的）部分必须附加到新列表中。这通过遍历剩余节点并为每个节点创建一个新副本附加到 `tail` 来完成。\n6.  最终排序的列表是 `dummy_head.next`。\n\n这个合并过程对 $n$ 个元素中的每一个都检查一次，并为每一个创建一个新节点，因此合并步骤的时间和空间复杂度均为 $\\mathcal{O}(n)$。\n\n#### **3. 复杂度和正确性分析**\n\n**时间复杂度**\n设 $T(n)$ 表示排序一个长度为 $n$ 的列表所需的时间。\n- **分割**：找到中点需要 $\\mathcal{O}(n)$ 时间。\n- **征服**：对大小近似为 $n/2$ 的子问题进行两次递归调用，成本为 $2T(n/2)$。\n- **合并**：合并两个已排序的子列表需要 $\\mathcal{O}(n)$ 时间。\n\n递推关系为：$T(n) = 2T(n/2) + \\mathcal{O}(n)$。基本情况是 $T(1) = \\mathcal{O}(1)$。\n这是经典的归并排序递推关系。我们可以通过递归树来分析它：\n- **第 0 层**：一个大小为 $n$ 的问题。分割/合并成本：$c \\cdot n$。\n- **第 1 层**：两个子问题，每个大小为 $n/2$。总成本：$2 \\cdot c \\cdot (n/2) = c \\cdot n$。\n- **第 k 层**：$2^k$ 个子问题，每个大小为 $n/2^k$。总成本：$2^k \\cdot c \\cdot (n/2^k) = c \\cdot n$。\n当问题大小为 1 时，递归停止，这发生在第 $k$ 层，其中 $n/2^k = 1$，即 $k = \\log_2 n$。\n总时间是所有层的成本之和：$(\\text{层数}) \\times (\\text{每层成本}) = (\\log_2 n) \\times (c \\cdot n)$。\n因此，时间复杂度为 $\\mathcal{O}(n \\log n)$。\n\n**空间复杂度**\n- **输出列表**：问题规范要求创建一个新的排序列表。这需要分配 $n$ 个新节点，导致 $\\mathcal{O}(n)$ 的空间复杂度。这是问题的内在要求，而不是辅助成本。\n- **递归栈**：递归树的最大深度为 $\\log_2 n$。每次递归调用在调用栈上为其参数和局部变量消耗恒定的空间。因此，递归栈使用的辅助空间为 $\\mathcal{O}(\\log n)$。\n\n总空间复杂度为 $\\mathcal{O}(n)$（用于输出）+ $\\mathcal{O}(\\log n)$（用于栈），主要由线性项决定，因此为 $\\mathcal{O}(n)$。问题陈述正确地要求将这两个部分分开识别。\n\n**稳定性分析**\n稳定性由 `merge` 函数保证。在合并两个列表时，如果两个键相等，即 `key1 == key2`，我们的规则 `key1 = key2` 确保选择来自左子列表（`list1`）的元素。由于分割阶段保留了子列表中元素的相对顺序，这种选择始终将原始位置靠左的元素放在原始位置靠右的元素之前，从而在整个排序过程中保持它们最初的相对顺序。此属性在每个合并步骤中都成立，从而确保最终的排序列表是稳定的。带有标签的测试用例专门设计用于验证此属性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Data model for the singly linked list\nclass Node:\n    \"\"\"A node in a singly linked list.\"\"\"\n    def __init__(self, key, tag=None, next_node=None):\n        self.key = key\n        self.tag = tag\n        self.next = next_node\n\n    def __repr__(self):\n        if self.tag is not None:\n            return f\"Node(key={self.key}, tag={self.tag})\"\n        return f\"Node(key={self.key})\"\n\n# Helper functions for list manipulation\ndef create_linked_list(data):\n    \"\"\"Creates a singly linked list from an iterable of keys or (key, tag) tuples.\"\"\"\n    dummy = Node(0)\n    current = dummy\n    for item in data:\n        if isinstance(item, tuple):\n            key, tag = item\n            current.next = Node(key, tag)\n        else:\n            current.next = Node(item)\n        current = current.next\n    return dummy.next\n\ndef linked_list_to_list(head):\n    \"\"\"Converts a singly linked list back to a Python list of keys.\"\"\"\n    result = []\n    current = head\n    while current:\n        result.append(current.key)\n        current = current.next\n    return result\n\ndef check_stability(original_data, sorted_head):\n    \"\"\"\n    Verifies the stability of the sort.\n    - True if for every key, the tags in the sorted output appear in the\n      same relative order as in the original input.\n    - False otherwise.\n    \"\"\"\n    if not original_data:\n        return True\n\n    original_tags_by_key = {}\n    for key, tag in original_data:\n        if key not in original_tags_by_key:\n            original_tags_by_key[key] = []\n        original_tags_by_key[key].append(tag)\n    \n    sorted_tags_by_key = {}\n    current = sorted_head\n    while current:\n        key, tag = current.key, current.tag\n        if key not in sorted_tags_by_key:\n            sorted_tags_by_key[key] = []\n        sorted_tags_by_key[key].append(tag)\n        current = current.next\n\n    for key in original_tags_by_key:\n        if key not in sorted_tags_by_key:\n            # This case shouldn't happen in a correct sort\n            return False \n        if original_tags_by_key[key] != sorted_tags_by_key[key]:\n            return False\n            \n    return True\n\n# Core Mergesort Algorithm\ndef _merge(left, right):\n    \"\"\"\n    Merges two sorted linked lists into a new sorted list, maintaining stability.\n    \"\"\"\n    dummy_head = Node(None)\n    tail = dummy_head\n    \n    p1, p2 = left, right\n    \n    while p1 is not None and p2 is not None:\n        # The = condition is crucial for stability\n        if p1.key = p2.key:\n            tail.next = Node(p1.key, p1.tag)\n            p1 = p1.next\n        else:\n            tail.next = Node(p2.key, p2.tag)\n            p2 = p2.next\n        tail = tail.next\n        \n    # Append remaining nodes from either list (one of them must be exhausted)\n    # New nodes must be created to respect the immutability of the sub-lists.\n    remaining = p1 if p1 is not None else p2\n    while remaining is not None:\n        tail.next = Node(remaining.key, remaining.tag)\n        tail = tail.next\n        remaining = remaining.next\n\n    return dummy_head.next\n\ndef _mergesort_recursive(head, length):\n    \"\"\"\n    Recursively divides the list and merges the sorted halves.\n    \"\"\"\n    # Base case: A list of length 0 or 1 is already sorted.\n    if length = 1:\n        if head is None:\n            return None\n        # Return a new list of one element\n        return Node(head.key, head.tag)\n\n    # Divide: Find the midpoint and split the list conceptually.\n    mid = length // 2\n    \n    # Traverse to the head of the right sublist\n    mid_node = head\n    for _ in range(mid):\n        mid_node = mid_node.next\n\n    # Conquer: Recursively sort both halves.\n    # The first half is from `head` with length `mid`.\n    # The second half is from `mid_node` with length `length - mid`.\n    left_sorted_head = _mergesort_recursive(head, mid)\n    right_sorted_head = _mergesort_recursive(mid_node, length - mid)\n    \n    # Combine: Merge the two sorted halves.\n    return _merge(left_sorted_head, right_sorted_head)\n\ndef mergesort(head):\n    \"\"\"\n    Public entry point for the mergesort algorithm.\n    \"\"\"\n    # First, determine the length of the list.\n    length = 0\n    current = head\n    while current:\n        length += 1\n        current = current.next\n    \n    return _mergesort_recursive(head, length)\n\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'keys': [4,1,3,9,7,0,2,5,8,6], 'type': 'sort'},\n        {'keys': [], 'type': 'sort'},\n        {'keys': [42], 'type': 'sort'},\n        {'keys': [5,3,3,5,2,2,1,1], 'type': 'sort'},\n        {'keys': [1,2,3,4,5], 'type': 'sort'},\n        {'keys': [-3,-1,-7,0,2], 'type': 'sort'},\n        {'keys': [(2,'a'),(1,'x'),(2,'b'),(1,'y'),(2,'c')], 'type': 'stability'},\n    ]\n\n    results = []\n    for case in test_cases:\n        input_data = case['keys']\n        head = create_linked_list(input_data)\n        \n        sorted_head = mergesort(head)\n        \n        if case['type'] == 'sort':\n            result = linked_list_to_list(sorted_head)\n            # Use repr to get the list format with brackets\n            results.append(repr(result))\n        elif case['type'] == 'stability':\n            is_stable = check_stability(input_data, sorted_head)\n            # Python booleans 'True'/'False' need to be lowercase 'true'/'false'\n            # as per problem's implied JSON-like format\n            results.append(str(is_stable).lower())\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3252314"}]}