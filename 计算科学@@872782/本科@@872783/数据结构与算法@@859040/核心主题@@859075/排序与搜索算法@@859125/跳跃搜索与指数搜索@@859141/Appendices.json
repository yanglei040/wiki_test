{"hands_on_practices": [{"introduction": "标准的跳跃搜索能高效地找到目标值的*任意*一个出现位置，但在处理包含重复数据的情况下，我们往往需要更精确的结果，例如找到它的第一次和最后一次出现。这项实践要求你扩展基础的跳跃搜索算法，设计一个“双向”策略来精确地定位重复元素区间的边界[@problem_id:3242935]。通过这个练习，你将深化对跳跃搜索中步长选择与最坏情况分析的理解，并掌握处理非唯一数据的实用技巧。", "problem": "给定一个可能包含重复值的非递减有序数组。请设计并实现一个完整的、可运行的程序，为每个给定的测试用例，使用双向跳跃搜索策略计算查询值的首次出现和最后一次出现的索引。该双向策略必须仅依赖于有序数组的单调性以及对跳跃步长的原则性选择，不得采用二分搜索。您的设计必须从最坏情况比较次数的角度明确论证跳跃步长的选择，然后使用对称的向左和向右跳跃扩展来确定重复值的范围。\n\n基本原理与约束：设数组为 $A = [A_0, A_1, \\dots, A_{n-1}]$，其中 $n \\in \\mathbb{N}$ 且 $n \\ge 0$。设查询值为 $v \\in \\mathbb{Z}$。该数组满足对于所有索引 $i,j \\in \\{0,1,\\dots,n-1\\}$ 且 $i \\le j$，$A_i \\le A_j$。搜索成本以元素比较的次数来量化。您必须从数组的有序性属性和比较计数模型出发进行推理；不得在没有论证的情况下依赖或引用预先推导的最优参数。您必须根据最小化跳跃式区间定位的最坏情况比较次数，选择一个关于 $n$ 的函数作为跳跃步长，并在您的解决方案中论证此选择。\n\n要求的算法行为：\n- 使用向前跳跃定位一个可能包含 $v$ 的区块，然后在此区块内进行线性扫描，以找到某个索引 $i$ 使得 $A_i = v$（如果存在）。\n- 如果找到这样的索引 $i$，则使用固定大小的反向跳跃向左扩展，以包围首次出现的位置，然后执行局部线性扫描，以确定确切的首次出现索引 $i_{\\text{first}}$。\n- 使用固定大小的向前跳跃向右扩展，以包围最后一次出现的位置，然后执行局部线性扫描，以确定确切的最后一次出现索引 $i_{\\text{last}}$。\n- 如果 $v$ 不存在，返回列表 $[-1,-1]$。\n\n测试套件：您的程序必须在无需任何外部输入、文件或网络调用的情况下，运行以下测试用例集。每个测试用例是一个序对 $(A, v)$。\n\n- 用例 1：$A = [1,2,2,2,3,4,5]$, $v = 2$。\n- 用例 2：$A = [5,5,5,6,7]$, $v = 5$。\n- 用例 3：$A = [1,2,3,9,9,9]$, $v = 9$。\n- 用例 4：$A = [1,2,3,4]$, $v = 6$。\n- 用例 5：$A = [8]$, $v = 8$。\n- 用例 6：$A = [8]$, $v = 9$。\n- 用例 7：$A = [7,7,7,7,7,7,7,7]$, $v = 7$。\n- 用例 8：$A = [0,1,1,1,2,2,4,4,4,4,5,9,9,11]$, $v = 4$。\n- 用例 9：$A = []$ (空数组), $v = 3$。\n\n答案规格：\n- 对每个测试用例，程序必须输出一个包含恰好两个整数的列表 $[i_{\\text{first}}, i_{\\text{last}}]$，其中 $i_{\\text{first}}$ 是 $v$ 在 $A$ 中首次出现的索引，$i_{\\text{last}}$ 是 $v$ 在 $A$ 中最后一次出现的索引。如果 $v$ 不存在，则输出 $[-1,-1]$。\n- 程序的最终输出必须是单行字符串，其中包含一个由方括号括起来的、以逗号分隔的各用例结果列表，内层结果列表中不含空格。例如，如果有三个用例的输出分别为 $[1,3]$、$[0,2]$ 和 $[4,4]$，程序必须打印字符串 \"[[1,3],[0,2],[4,4]]\"。\n\n您的程序必须是完全自包含的、可直接执行的，并以通用编程语言表达。在数值上，所有输出都是纯索引（即整数），不涉及任何物理单位、角度或百分比。除了数组按非递减顺序排序外，该算法不得做任何其他分布假设。", "solution": "所提出的问题是有效的，因为它在科学上基于算法设计的原则，是一个具有唯一且可验证解的良构问题，并以客观、形式化的语言表述。它没有任何科学、逻辑或事实上的不健全之处。\n\n该问题要求设计一种算法，在一个大小为 $n$ 的有序数组 $A$ 中，查找查询值 $v$ 的首次出现和最后一次出现的位置。该数组按非递减顺序排序，即对于所有索引 $i, j$ 满足 $0 \\le i \\le j  n$，$A_i \\le A_j$。解决方案必须采用基于跳跃的搜索策略，并明确避免使用二分搜索。一项核心要求是，必须基于最小化最坏情况下的比较次数来论证跳跃步长 $k$ 的选择。\n\n整体算法分为三个阶段：\n1.  初始跳跃搜索，找到任意一个满足 $A_i=v$ 的索引 $i$。\n2.  从该索引开始向左扩展的跳跃搜索，以定位首次出现的位置 $i_{\\text{first}}$。\n3.  对稱的、向右扩展的跳跃搜索，以精确定位最后一次出现的位置 $i_{\\text{last}}$。\n\n**跳跃步长的论证**\n\n跳跃搜索通过检查固定间隔（步长为 $k$）的元素来快速缩小目标值可能存在的区域。总搜索成本主要由两个操作决定：跳跃本身以及随后在缩小的区块内进行的线性扫描。\n\n1.  **跳跃阶段**：我们探测索引 $k, 2k, 3k, \\dots, m \\cdot k$，直到搜索越过 $v$ 的潜在位置。在最坏情况下（例如，$v$ 是最后一个元素），跳跃次数 $m$ 约为 $\\frac{n}{k}$。这为总成本贡献了 $\\frac{n}{k}$ 次比较。\n\n2.  **线性扫描阶段**：跳跃阶段之后，我们确定了一个大小最多为 $k$ 的区块，如果 $v$ 存在，它必定包含在该区块内。然后在此区块内执行线性搜索。在最坏情况下，这需要额外的 $k-1$ 次比较。\n\n最坏情况下的总比较次数 $C(k)$ 是这两个阶段成本的总和：\n$$C(k) = \\frac{n}{k} + (k-1)$$\n为了找到最小化此成本的最优跳跃步长 $k$，我们可以将 $k$ 视为一个连续变量，并使用微积分来求函数 $C(k)$ 的最小值。$C(k)$ 对 $k$ 的一阶导数是：\n$$\\frac{dC}{dk} = -\\frac{n}{k^2} + 1$$\n将此导数设为 $0$ 以找到临界点，可得：\n$$-\\frac{n}{k^2} + 1 = 0 \\implies k^2 = n \\implies k = \\sqrt{n}$$\n此推导确定了最小化最坏情况比较次数的最优跳跃步长为 $k = \\sqrt{n}$。对于离散元素的数组，我们使用其整数部分 $k = \\lfloor \\sqrt{n} \\rfloor$。如果 $n=0$，此计算不适用；如果 $n>0$ 且 $\\lfloor \\sqrt{n} \\rfloor = 0$，则必须强制使用最小步长 $1$ 以确保搜索能够推进。使用此最优跳跃步长的搜索算法，其总体时间复杂度为 $O(\\sqrt{n})$。这个跳跃步长 $k$ 将在算法的所有阶段中保持一致使用。\n\n**算法实现**\n\n查找 $[i_{\\text{first}}, i_{\\text{last}}]$ 的过程如下。\n\n**阶段 1：初始搜索 $v$ 的任意一次出现**\n首先，处理边界情况：如果数组为空 ($n=0$)，$v$ 不可能存在，因此返回 $[-1, -1]$。否则，我们计算跳跃步长 $k = \\max(1, \\lfloor \\sqrt{n} \\rfloor)$。\n\n1.  **区块定位**：我们使用步长为 $k$ 的向前跳跃来找到一个可能包含 $v$ 的区块。初始化两个指针 `prev` 和 `curr` 为 $0$。只要 $A_{\\text{curr}}  v$，我们就将 `curr` 增加 $k$，并在每次跳跃前将 `prev` 设置为 `curr` 的旧值。当 $A_{\\text{curr}} \\ge v$ 或 `curr` 超出数组边界时，此过程停止。\n2.  **线性扫描**：元素 $v$（如果存在）必定位于索引区块 $[\\text{prev}, \\min(\\text{curr}, n-1)]$ 内。我们在此区块内执行线性扫描，以查找一个索引（称之为 `found_idx`），使得 $A_{\\text{found\\_idx}} = v$。如果扫描完成仍未找到 $v$，则该元素不在数组中，我们返回 $[-1, -1]$。\n\n**阶段 2：查找首次出现的位置 ($i_{\\text{first}}$)**\n如果阶段 1 成功，我们得到了一个索引 `found_idx`，其中 $A_{\\text{found\\_idx}} = v$。现在我们搜索第一次出现的位置。\n\n1.  **向左包围**：从 `found_idx` 开始，我们使用步长为 $k$ 的跳跃向左扩展。定义一个搜索范围 `[start_rng, end_rng]`。初始时，`end_rng` 设置为 `found_idx`。我们重复更新 `end_rng` 为当前位置，并将 `start_rng`向左跳跃 $k$，只要 `start_rng` 是有效的正索引且 $A_{\\text{start\\_rng}} = v$。这将快速建立一个保证包含 $i_{\\text{first}}$ 的区间 `[start_rng, end_rng]`。\n2.  **局部线性扫描**：然后我们从 `start_rng` 到 `end_rng` 执行一次精细的向前线性扫描。在此范围内，第一个满足 $A_j = v$ 的索引 $j$ 就是所求的首次出现位置 $i_{\\text{first}}$。\n\n**阶段 3：查找最后一次出现的位置 ($i_{\\text{last}}$)**\n此阶段与阶段 2 类似，但从 `found_idx` 向右扩展。\n\n1.  **向右包围**：从 `found_idx` 开始，我们向右扩展。初始时，`start_rng` 设置为 `found_idx`。我们重复更新 `start_rng` 为当前位置，并将 `end_rng` 向右跳跃 $k$，只要 `end_rng` 在数组边界内且 $A_{\\text{end\\_rng}} = v$。此过程将确定一个保证包含 $i_{\\text{last}}$ 的区间 `[start_rng, end_rng]`。\n2.  **局部线性扫描**：为了精确定位索引，我们从 `end_rng` 到 `start_rng` 执行一次向后线性扫描。从右侧遇到的第一个满足 $A_j = v$ 的索引 $j$ 就是最后一次出现的位置 $i_{\\text{last}}$。\n\n最后，算法返回列表 $[i_{\\text{first}}, i_{\\text{last}}]$，其中包含 $v$ 的首次和最后一次出现的索引。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef dual_jump_search(A, v):\n    \"\"\"\n    Computes the first and last occurrences of a value v in a sorted array A\n    using a dual jump-based search strategy.\n    \n    Args:\n        A (list): A sorted list of numbers in non-decreasing order.\n        v (int or float): The value to search for.\n        \n    Returns:\n        list: A list [i_first, i_last] of the first and last indices of v.\n              Returns [-1, -1] if v is not found.\n    \"\"\"\n    n = len(A)\n    if n == 0:\n        return [-1, -1]\n\n    # k is chosen to minimize worst-case comparisons, derived from d/dk(n/k + k-1) = 0.\n    k = int(n**0.5)\n    if k == 0:\n        k = 1\n\n    # Phase 1: Initial Jump Search to find any occurrence of v.\n    found_idx = -1\n    \n    # 1.a: Find a block where v might be located.\n    prev = 0\n    curr = 0\n    while curr  n and A[curr]  v:\n        prev = curr\n        curr += k\n\n    # 1.b: Linear scan within the identified block.\n    block_end = min(curr, n - 1)\n    for i in range(prev, block_end + 1):\n        if A[i] == v:\n            found_idx = i\n            break\n    \n    if found_idx == -1:\n        return [-1, -1]\n\n    # Phase 2: Find the first occurrence (i_first) by expanding leftward.\n    i_first = -1\n    \n    # 2.a: Bracket the first occurrence with reverse jumps.\n    end_rng_first = found_idx\n    start_rng_first = max(0, found_idx - k)\n    \n    while start_rng_first > 0 and A[start_rng_first] == v:\n        end_rng_first = start_rng_first\n        start_rng_first = max(0, start_rng_first - k)\n\n    # 2.b: Linear scan within the bracket to find the exact first index.\n    for j in range(start_rng_first, end_rng_first + 1):\n        if A[j] == v:\n            i_first = j\n            break\n\n    # Phase 3: Find the last occurrence (i_last) by expanding rightward.\n    i_last = -1\n    \n    # 3.a: Bracket the last occurrence with forward jumps.\n    start_rng_last = found_idx\n    end_rng_last = min(n - 1, found_idx + k)\n\n    while end_rng_last  n - 1 and A[end_rng_last] == v:\n        start_rng_last = end_rng_last\n        end_rng_last = min(n - 1, end_rng_last + k)\n\n    # 3.b: Linear scan (backwards) within the bracket for the exact last index.\n    for j in range(end_rng_last, start_rng_last - 1, -1):\n        if A[j] == v:\n            i_last = j\n            break\n            \n    return [i_first, i_last]\n\ndef solve():\n    \"\"\"\n    Defines and runs the test cases, printing the results in the specified format.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        ([1, 2, 2, 2, 3, 4, 5], 2),\n        ([5, 5, 5, 6, 7], 5),\n        ([1, 2, 3, 9, 9, 9], 9),\n        ([1, 2, 3, 4], 6),\n        ([8], 8),\n        ([8], 9),\n        ([7, 7, 7, 7, 7, 7, 7, 7], 7),\n        ([0, 1, 1, 1, 2, 2, 4, 4, 4, 4, 5, 9, 9, 11], 4),\n        ([], 3)\n    ]\n\n    results = []\n    for A, v in test_cases:\n        result = dual_jump_search(A, v)\n        results.append(result)\n\n    # Format the final output string as per the specification.\n    # e.g., [[1,3],[0,2],[-1,-1]]\n    output_str = \"[\" + \",\".join([f\"[{r[0]},{r[1]}]\" for r in results]) + \"]\"\n    \n    # Final print statement in the exact required format.\n    print(output_str)\n\nsolve()\n```", "id": "3242935"}, {"introduction": "优秀的算法设计者能够洞察算法背后的核心原理，并将其应用于抽象问题。这个思想实验将指数搜索从具体的数组结构中剥离出来，让你在一个单调变化的无限序列中，从一个已知的“假”点出发反向寻找“真”与“假”的边界[@problem_id:3242857]。这项练习将挑战你对指数搜索如何高效建立搜索范围的根本逻辑的理解，并让你领会其时间复杂度为何与搜索距离$D$相关，而非目标位置$t$本身。", "problem": "考虑一个概念上无限、可索引的序列，其索引为 $0, 1, 2, \\dots$。你只能对该序列中的索引 $i \\in \\mathbb{N}$ 查询一个单调布尔谓词 $P(i)$。假设存在一个未知的阈值索引 $t \\in \\mathbb{N}$，使得对于所有 $i \\le t$，$P(i)$ 为 $\\text{true}$，而对于所有 $i > t$，$P(i)$ 为 $\\text{false}$。给定一个索引 $S \\in \\mathbb{N}$ 且 $P(S) = \\text{false}$，但你不知道 $t$。目标是使用尽可能少的谓词求值次数，找到使 $P(t) = \\text{true}$ 成立的最后一个索引 $t$。\n\n从单调性和基于比较的搜索的基本定义出发，选择一个正确描述如何从 $S$ 开始反向使用指数搜索来框定 $t$ 的范围，并最终通过一个正确的、渐近时间最优的搜索找到 $t$ 的选项。令 $D = S - t$ 表示从起始的 false 索引 $S$ 到目标 $t$ 的（未知）距离。\n\nA. 从 $S$ 开始，探测 $P(S-1)$、$P(S-2)$、$P(S-4)$、$P(S-8)$、$\\dots$（反向偏移量加倍），直到找到第一个满足 $P(j) = \\text{true}$ 的索引 $j = S - 2^{m}$，其中 $m \\ge 0$ 是最小的。令前一个探测点为 $j' = S - 2^{m-1}$（约定当 $m = 0$ 时，$j' = S$）。根据单调性，$P(j) = \\text{true}$ 且 $P(j') = \\text{false}$，这将 $t$ 框定在 $[j, j'-1]$ 范围内。在 $[j, j'-1]$ 上执行标准二分搜索以找到 $t$。谓词求值总次数为 $\\mathcal{O}(\\log D)$。\n\nB. 从 $S$ 开始，以单位反向步长探测 $P(S-1)$、$P(S-2)$、$P(S-3)$、$\\dots$，直到到达第一个满足 $P(k) = \\text{true}$ 的索引 $k$，然后在 $[k, S-1]$ 上执行二分搜索以找到 $t$。谓词求值总次数是线性阶段的 $\\mathcal{O}(D)$ 加上二分搜索阶段的 $\\mathcal{O}(\\log D)$。\n\nC. 忽略给定的 $S$，而是从索引 $0$ 开始执行前向指数搜索：探测 $P(1)$、$P(2)$、$P(4)$、$P(8)$、$\\dots$，直到找到第一个满足 $P(u) = \\text{false}$ 的 false 索引 $u = 2^{q}$（其中 $q$ 最小），这将 $t$ 框定在 $[2^{q-1}, 2^{q}-1]$ 范围内。然后在该区间上执行二分搜索以找到 $t$。谓词求值总次数为 $\\mathcal{O}(\\log t)$。\n\nD. 从 $S$ 开始，以偏移量 $1, 2, 4, 8, \\dots$ 反向探测，直到遇到第一个严格小于 $S$ 的 false 索引（即，找到满足 $P(j) = \\text{false}$ 的 $j = S - 2^{m}$，其中 $m \\ge 1$ 最小），然后在 $[j, S]$ 上执行二分搜索以找到 $t$。谓词求值总次数为 $\\mathcal{O}(\\log D)$。", "solution": "*   **问题分析：**\n    *   我们位于一个索引 $S$ 处，其中 $P(S) = \\text{false}$。\n    *   我们知道 $t  S$。\n    *   我们需要找到 $t$，它是 `true` 和 `false` 之间的边界。模式是 `...true, true, true (在 t 处), false (在 t+1 处), false, ...`。\n    *   题目要求我们从 $S$ 开始使用*反向指数搜索*。\n    *   要查找的距离是 $D = S - t$。复杂度应该用 $D$ 来表示。\n\n*   **反向指数搜索：**\n    1.  指数搜索的思想是为目标找到一个范围，然后在该范围内使用二分搜索。当从 $0$ 开始前向搜索位于位置 $t$ 的目标时，我们检查索引 $1, 2, 4, 8, \\dots, 2^k$，直到找到 $2^k > t$。这需要 $\\mathcal{O}(\\log t)$ 步。目标 $t$ 随后位于范围 $[2^{k-1}, 2^k - 1]$ 内。\n    2.  在这里，我们应用相同的逻辑，但从 $S$ 开始反向进行。我们想要找到一个索引 $j  S$，使得 $P(j) = \\text{true}$。这将为我们的搜索空间建立一个下界。\n    3.  让我们从 $S$ 开始反向探测索引。探测的索引是 $S-1, S-2, S-4, S-8, \\dots, S-2^m$。\n    4.  我们继续探测，直到找到一个索引 $j_m = S - 2^m$ 使得 $P(j_m) = \\text{true}$。设这是对于最小的 $m$ 第一次发生这种情况。\n    5.  这是什么意思？这意味着对于前一步 $m-1$，谓词为 false（或者我们处于 $m=0$ 的情况）。令 $j_{m-1} = S - 2^{m-1}$。\n    6.  所以，我们有：\n        *   $P(S - 2^m) = \\text{true}$。\n        *   $P(S - 2^{m-1}) = \\text{false}$ （对于 $m>0$）。\n        *   此外，根据问题定义，$P(S) = \\text{false}$。\n    7.  由于单调性（对于 $i \\le t$，$P(i)$ 为 true；对于 $i > t$，$P(i)$ 为 false），我们知道转换点 $t$ 必须位于我们找到的第一个 `true` 和最后一个 `false` 之间。\n    8.  我们遇到的最后一个 `false` 是在索引 $S - 2^{m-1}$ 处，而我们遇到的第一个 `true` 是在索引 $S - 2^m$ 处。\n    9.  因此，我们已经定位了发生转换的区间：$t \\in [S - 2^m, S - 2^{m-1} - 1]$。设下界为 $L = S - 2^m$，上界为 $R = S - 2^{m-1} - 1$。\n    10. 注意：问题将 $t$ 定义为 $P(t)$ 为 true 的*最后*一个索引。这意味着 $P(t) = \\text{true}$ 且 $P(t+1) = \\text{false}$。我们的搜索就是要找到这个 $t$。条件是 $P(L)=\\text{true}$ 和 $P(R+1) = P(S - 2^{m-1}) = \\text{false}$。所以 $t$ 在 $[L, R]$ 内。\n\n*   **指数搜索阶段的复杂度：**\n    *   我们在 $S-2^0, S-2^1, \\dots, S-2^m$ 进行探测。\n    *   这个过程持续到 $S - 2^m \\le t$。这等价于 $2^m \\ge S - t = D$。\n    *   探测次数为 $m+1$。由于 $m$ 是满足 $2^m \\ge D$ 的最小整数，我们有 $m \\approx \\log_2 D$。\n    *   所以，指数搜索阶段需要 $\\mathcal{O}(\\log D)$ 次探测。\n\n*   **二分搜索阶段：**\n    1.  一旦我们有了区间 $[L, R] = [S - 2^m, S - 2^{m-1} - 1]$，我们就可以使用二分搜索来找到 $t$ 的精确值。\n    2.  这个区间的大小是 $(S - 2^{m-1} - 1) - (S - 2^m) + 1 = -2^{m-1} + 2^m = 2^m - 2^{m-1} = 2^{m-1}$。\n    3.  在大小为 $N$ 的区间上进行二分搜索需要 $\\mathcal{O}(\\log N)$ 次探测。\n    4.  在这里，大小是 $2^{m-1}$。探测次数为 $\\mathcal{O}(\\log(2^{m-1})) = \\mathcal{O}(m-1) = \\mathcal{O}(m)$。\n    5.  因为 $m \\approx \\log_2 D$，所以二分搜索阶段也需要 $\\mathcal{O}(\\log D)$ 次探测。\n\n*   **总复杂度：**\n    *   谓词求值总次数是两个阶段的总和：$\\mathcal{O}(\\log D) + \\mathcal{O}(\\log D) = \\mathcal{O}(\\log D)$。\n    *   这是渐近最优的，因为任何基于比较的搜索都必须至少花费 $\\Omega(\\log D)$ 步才能在 $t+1$ 和 $S$ 之间的 $D$ 个可能位置中定位目标 $t$。\n\n*   **现在，让我们评估各个选项。**\n\n*   **选项 A：**\n    *   “从 $S$ 开始，探测 $P(S-1)$, $P(S-2)$, $P(S-4)$, $\\dots$，直到找到第一个满足 $P(j)=\\text{true}$ 的索引 $j=S-2^m$。” 这是正确的初始阶段。我们处于一个 `false` 点，所以我们必须搜索一个 `true` 点。\n    *   “令前一个探测点为 $j' = S - 2^{m-1}$... 根据单调性，$P(j) = \\text{true}$ 且 $P(j') = \\text{false}$”。这正确地指出了成功之前的最后一次探测必定为 false，从而建立了范围。\n    *   “这将 $t$ 框定在 $[j, j'-1]$ 范围内。” 这个范围是正确的：$[S-2^m, S-2^{m-1}-1]$。\n    *   “在 $[j, j'-1]$ 上执行标准二分搜索以找到 $t$。” 正确。\n    *   “谓词求值总次数为 $\\mathcal{O}(\\log D)$。” 正确。\n    *   选项 A 中的所有内容都符合为从已知“false”点进行反向搜索而调整的指数搜索原理。它正确地确定了后续二分搜索的边界，并陈述了正确的渐近复杂度。\n\n*   **选项 B：**\n    *   “从 $S$ 开始，以单位反向步长探测 $P(S-1)$, $P(S-2)$, $P(S-3)$, $\\dots$，直到到达第一个满足 $P(k) = \\text{true}$ 的索引 $k$”。\n        *   这是线性搜索，不是指数搜索。\n        *   这个搜索将找到 $k=t$。步数是 $S - t = D$。成本是 $\\mathcal{O}(D)$。\n    *   “...然后在 $[k, S-1]$ 上执行二分搜索以找到 $t$”。\n        *   这是无稽之谈。线性搜索*已经找到*了 $t$。第一个满足 $P(k)=\\text{true}$ 的索引 $k$ 正是 $t$，因为所有索引 $k+1, \\dots, S$ 的 $P$ 值都为 false。所以 $k=t$。不需要后续的二分搜索。该陈述提出了一个不必要的步骤。\n    *   “谓词求值总次数是线性阶段的 $\\mathcal{O}(D)$ 加上二分搜索阶段的 $\\mathcal{O}(\\log D)$。”\n        *   线性阶段的复杂度确实是 $\\mathcal{O}(D)$。二分搜索部分是多余的。总复杂度由线性搜索主导，因此是 $\\mathcal{O}(D)$，而不是 $\\mathcal{O}(\\log D)$。\n    *   **对 B 的判决：** 不正确。它描述的是线性搜索，而不是指数搜索，并且所提出的算法既效率低下又包含多余的步骤。\n\n*   **选项 C：**\n    *   “忽略给定的 $S$，而是从索引 $0$ 开始执行前向指数搜索：探测 $P(1)$, $P(2)$, $P(4)$, $P(8)$, $\\dots$，直到找到第一个满足 $P(u) = \\text{false}$ 的 false 索引 $u = 2^{q}$（其中 $q$ 最小），这将 $t$ 框定在 $[2^{q-1}, 2^{q}-1]$ 范围内。”\n        *   这描述了一个标准（前向）指数搜索。该过程是正确的。\n    *   “然后在该区间上执行二分搜索以找到 $t$。”\n        *   这是前向指数搜索正确的第二步。\n    *   “谓词求值总次数为 $\\mathcal{O}(\\log t)$。”\n        *   是的，前向指数搜索的复杂度是 $\\mathcal{O}(\\log t)$。\n    *   **然而**，问题陈述明确给出了一个起始点 $S$ 且 $P(S)=\\text{false}$，并要求从 $S$ 开始使用*反向*搜索。忽略 $S$ 违反了问题的约束和指导。此外，目标是根据距离 $D=S-t$ 进行优化。如果 $S$ 非常大但接近 $t$（即 $D$ 很小），那么复杂度为 $\\mathcal{O}(\\log D)$ 的反向搜索远优于复杂度为 $\\mathcal{O}(\\log t)$ 的前向搜索。例如，如果 $t=10^9$ 且 $S=10^9+5$，那么 $D=5$。$\\mathcal{O}(\\log D)$ 远远小于 $\\mathcal{O}(\\log t)$。当 $D$ 相对于 $t$ 很小时，提供的信息 $S$ 是获得更高效解决方案的关键。\n    *   **对 C 的判决：** 不正确。这个算法在一般意义上是有效的，但它忽略了问题的具体信息和约束（起始点 $S$ 和进行*反向*搜索的要求）。考虑到先验信息，它不是最优解。\n\n*   **选项 D：**\n    *   “从 $S$ 开始，以偏移量 $1, 2, 4, 8, \\dots$ 反向探测，直到遇到第一个严格小于 $S$ 的 false 索引（即，找到满足 $P(j) = \\text{false}$ 的 $j = S - 2^{m}$，其中 $m \\ge 1$ 最小）”。\n        *   让我们分析一下。我们从 $P(S)=\\text{false}$ 的 $S$ 开始。我们正在寻找 $t  S$ 且 $P(t)=\\text{true}$。为什么我们要寻找*另一个* false 索引？\n        *   搜索的指数部分的目的是越过未知区域，以找到目标*另一侧*的边界。我们处于一个 `false` 点（$S$）。我们需要找到一个 `true` 点。这个选项建议我们继续寻找 `false` 点。\n    *   让我们仔细重读：“直到遇到第一个严格小于 $S$ 的 false 索引（即，找到满足 $P(j) = \\text{false}$ 的 $j = S - 2^{m}$，其中 $m \\ge 1$ 最小）”\n    *   这是一个根本上有缺陷的策略。我们已经有一个 `false` 索引 $S$。为了框定 $t$，我们需要找到一个索引 $i  S$ 使得 $P(i)$ 为 `true`。搜索更多的 `false` 索引无助于框定目标 $t$。事实上，我们可以保证从 $t+1$ 到 $S$ 的所有索引的谓词值都是 `false`。探测另一个 `false` 索引并不能告诉我们任何新信息，除非我们越过了 $t$ 并落在一个索引 $i \\le t$ 上，此时其值为 `true`。但指令是在遇到第一个 `false` 索引时停止。这是不合逻辑的。\n    *   例如，设 $t=100$，$S=120$。所以 $D=20$。对于 $i \\le 100$，$P(i)$ 为 true；对于 $i > 100$，$P(i)$ 为 false。\n        *   从 $S=120$ 开始。$P(120)$ 为 false。\n        *   以偏移量 $2^0, 2^1, ...$ 反向探测。\n        *   $m=1$: $j = 120 - 2^1 = 118$。$P(118)$ 为 false。这是第一个严格小于 $S$ 的 false 索引吗？$P(119)$ 也为 false。该指令是模棱两可的。它是否指探测序列 $S-2^m$ 中第一个为 false 的索引？我们假设是这样。\n        *   $m=0$: 偏移量 1. $j = 120-1=119$。$P(119)$ 为 false。$m \\ge 1$ 的要求排除了此步。\n        *   $m=1$: 偏移量 2. $j = 120-2=118$。$P(118)$ 为 false。\n        *   $m=2$: 偏移量 4. $j = 120-4=116$。$P(116)$ 为 false。\n        *   $m=3$: 偏移量 8. $j = 120-8=112$。$P(112)$ 为 false。\n        *   $m=4$: 偏移量 16. $j = 120-16=104$。$P(104)$ 为 false。\n        *   $m=5$: 偏移量 32. $j = 120-32=88$。$P(88)$ 为 true。\n    *   指令说“直到遇到第一个 false 索引 ... $j = S - 2^m$”。这意味着我们将在 $j=118$ ($m=1$) 处停止。然后呢？该选项说“在 $[j, S]$ 上执行二分搜索”。这是区间 $[118, 120]$。此区间中的所有谓词都为 false。在这里进行二分搜索不可能找到 $t=100$。\n    *   **对 D 的判决：** 不正确。所提出的搜索策略在逻辑上是有缺陷的，并且不会找到目标 $t$。\n\n*   **重新审视选项 A：**\n    *   “从 $S$ 开始，探测 $P(S-1)$, $P(S-2)$, $P(S-4)$, $\\dots$，直到找到第一个满足 $P(j)=\\text{true}$ 的索引 $j=S-2^m$。” 这是正确的初始阶段。我们处于一个 `false` 点，所以我们必须搜索一个 `true` 点。\n    *   “令前一个探测点为 $j' = S - 2^{m-1}$... 根据单调性，$P(j) = \\text{true}$ 且 $P(j') = \\text{false}$”。这正确地指出了成功之前的最后一次探测必定为 false，从而建立了范围。\n    *   “这将 $t$ 框定在 $[j, j'-1]$ 范围内。” 这个范围是正确的：$[S-2^m, S-2^{m-1}-1]$。\n    *   “在 $[j, j'-1]$ 上执行标准二分搜索以找到 $t$。” 正确。\n    *   “谓词求值总次数为 $\\mathcal{O}(\\log D)$。” 正确。\n    *   选项 A 中的所有内容都符合为从已知“false”点进行反向搜索而调整的指数搜索原理。它正确地确定了后续二分搜索的边界，并陈述了正确的渐近复杂度。", "answer": "$$\\boxed{A}$$", "id": "3242857"}, {"introduction": "现实世界中的海量数据通常被组织成分层结构以提升访问效率，例如数据库索引。本练习模拟了在这样一个二级索引结构中的搜索过程，要求你在一个“由已排序列表组成的已排序列表”中应用跳跃搜索[@problem_id:3242865]。你将学习如何分阶段地应用搜索策略——首先在顶层索引上进行宏观的区块定位，然后在目标区块内进行精细的内部查找，这是将理论算法应用于复杂系统的关键一步。", "problem": "考虑一个两级索引数据结构 $X$，它被定义为一个由内部序列组成的有限序列 $X[0], X[1], \\dots, X[B-1]$，其中每个 $X[b]$ 是一个按非递减顺序排列的可比较键的有限序列，一个内部序列中允许存在重复项，也允许存在空的内部序列。该数据结构满足全局排序约束，即对于所有块索引 $b$ 和 $b+1$，如果 $X[b]$ 和 $X[b+1]$ 均非空，则 $\\max(X[b])  \\min(X[b+1])$。这使得所有内部序列的串联是全局有序的。你需要为此两级索引设计并实现一种跳跃搜索的改编算法，该算法需遵循以下原则：\n\n- 只允许进行键的比较；不得使用哈希或辅助平衡树。\n- 外部搜索必须对每个非空块使用一个单调代表函数（例如，一个边界值）来决定哪个块可能包含查询键。\n- 在候选块内的内部搜索必须使用一种不假设目标位置先验知识的方法，并且该方法在已排序的数组上必须是渐近高效的。\n- 步长和边界必须从第一性原理推导得出，而非通过猜测，并且必须通过在有序结构的约束下最小化最坏情况下的比较次数来证明其合理性。\n\n形式上，给定一个查询键 $x$，你的算法必须：\n- 通过对非空块序列使用每个块的单调代表值执行跳跃式搜索，来识别一个候选块索引 $b^\\*$。如果没有候选块可以包含 $x$，则报告未找到 $x$。\n- 在 $X[b^\\*]$ 内搜索，找到最左边的位置 $j$ 使得 $X[b^\\*][j] = x$。如果存在这样的位置，则返回序对 $[b^\\*, j]$；否则，报告未找到 $x$。\n\n你的程序必须实现此算法，并在以下测试套件上运行。每个测试用例包含一个特定的两级索引和一个查询键 $x$。\n\n定义三个数据集：\n- $\\mathcal{D}_A = [[1, 3, 5, 5], [8, 9, 10], [14, 14, 15, 16], [20, 21]]$。\n- $\\mathcal{D}_B = [[-10, -5], [0], [2, 4, 6, 8, 10], [13, 17, 19], [23]]$。\n- $\\mathcal{D}_C = [[], [1, 2, 3], [5], [7, 7, 7, 7], [9, 12]]$。\n\n在以下有序的测试用例列表上运行该算法：\n- $(\\mathcal{D}_A, 14)$。\n- $(\\mathcal{D}_A, 1)$。\n- $(\\mathcal{D}_A, 21)$。\n- $(\\mathcal{D}_A, 7)$。\n- $(\\mathcal{D}_A, 0)$。\n- $(\\mathcal{D}_A, 100)$。\n- $(\\mathcal{D}_B, 17)$。\n- $(\\mathcal{D}_C, 7)$。\n- $(\\mathcal{D}_C, 4)$。\n- $(\\mathcal{D}_B, -10)$。\n\n对于每个测试用例，如果找到键，输出必须是序对 $[b^\\*, j]$（两个条目均为整数）；如果未找到键，则输出整数 $-1$。你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如 $[r_1, r_2, r_3]$），结果顺序与上述测试用例的顺序相同。不涉及物理单位、角度或百分比；所有输出均为整数或整数列表。", "solution": "该问题要求为一种表示为 $X$ 的两级索引数据结构设计并实现一个特定的搜索算法。该结构由 $B$ 个内部序列 $X[0], \\dots, X[B-1]$ 组成。每个内部序列都按非递减顺序排序，并且全局排序约束 $\\max(X[b])  \\min(X[b+1])$（对于任意相邻的非空块 $X[b]$ 和 $X[b+1]$）确保所有元素的串联是全局有序的。任务是通过改编跳跃搜索的原理来找到查询键 $x$ 的最左边出现的位置。\n\n解决方案是一个两阶段的搜索过程。第一阶段是外部搜索，它识别出唯一可能包含键 $x$ 的候选块。第二阶段是内部搜索，它探查这个特定的块以定位该键。\n\n**外部搜索：块识别**\n\n外部搜索作用于非空块的有序序列。假设有 $N$ 个这样的块。问题要求使用每个块的单调代表值进行跳跃式搜索。一个有效且自然的选择是使用每个非空块的第一个元素作为代表值，即 $R_i = \\min(X[b_i])$，其中 $b_i$ 是第 $i$ 个非空块的原始索引。全局排序约束保证了该代表值序列是严格递增的，即对于所有 $i \\in [0, N-2]$ 都有 $R_i  R_{i+1}$。\n\n核心原则是找到最优的跳跃步长 $k$，以最小化最坏情况下的比较次数。搜索包括两个阶段：跳跃和线性扫描。\n1.  **跳跃阶段：** 我们以步长 $k$ 跳跃遍历代表值。找到包含目标的区间所需的最大跳跃次数为 $\\lceil N/k \\rceil - 1$。\n2.  **线性扫描阶段：** 一旦跳跃越过了目标的潜在位置（即，我们找到了一个索引 $j$ 使得 $R_j > x$），我们必须在大小为 $k-1$ 的前一个区间内执行线性扫描，以精确定位正确的块。\n\n因此，外部搜索的总比较次数是步长 $k$ 的函数，由 $C(k) \\approx N/k + k - 1$ 给出。为了最小化此成本，我们将 $k$ 视为一个连续变量，并通过将导数设为零来找到最小值：\n$$\n\\frac{dC}{dk} = -\\frac{N}{k^2} + 1 = 0\n$$\n这得出 $k^2 = N$，因此最佳步长为 $k = \\sqrt{N}$。对于离散数量的块，我们使用其整数部分，即 $k = \\lfloor \\sqrt{N} \\rfloor$。\n\n外部搜索算法如下：\n1.  构建一个非空块及其原始索引的列表。设其大小为 $N$。如果 $N=0$，则无法找到该键。\n2.  处理查询键 $x$ 小于第一个非空块的第一个元素的边界情况；在这种情况下，$x$ 不存在。\n3.  使用步长 $k = \\lfloor \\sqrt{N} \\rfloor$，跳跃遍历非空块列表，直到找到一个索引 `curr`，使得 `curr` 处的代表值大于 $x$。先前访问的索引是 `prev`。候选块必定位于索引范围 `[prev, curr - 1]` 内。\n4.  从 `curr - 1` 向下到 `prev` 执行反向线性扫描，以找到其代表值小于或等于 $x$ 的最后一个块。这个块 $X[b^\\*]$ 是唯一可能包含 $x$ 的候选块。\n\n**内部搜索：键定位**\n\n一旦确定了候选块 $X[b^\\*]$，我们必须在其内部进行搜索。问题规定此搜索在已排序数据上必须是渐近高效的，并且不依赖于键位置的先验知识。二分搜索完美地满足了这些标准。\n\n为了满足找到使 $X[b^\\*][j] = x$ 成立的*最左边*位置 $j$ 的要求，需要对标准二分搜索进行修改。当在索引 `mid` 处找到一个等于 $x$ 的元素时，该索引被存储为潜在答案，并且搜索范围随后缩小到当前范围的左半部分（即从头到 `mid - 1`）。这确保了如果 $x$ 存在多个，搜索将继续进行直到找到第一个。\n\n**算法综合**\n\n完整的算法集成了这两个阶段：\n1.  提取非空块序列及其原始索引。设此序列的大小为 $N$。如果 $N=0$，则终止并报告“未找到”。\n2.  如果查询键 $x$ 小于整个数据结构中的最小元素，则报告“未找到”。\n3.  对 $N$ 个块的代表值以步长 $k = \\lfloor\\sqrt{N}\\rfloor$ 执行跳跃搜索，以识别候选块 $X[b^\\*]$。如果没有块能包含该键（如果 $x$ 落在块之间的间隙中，就会发生这种情况），后续的内部搜索将正确地失败。\n4.  在 $X[b^\\*]$ 中执行寻找最左侧元素的二分搜索来查找 $x$。\n5.  如果内部搜索在局部索引 $j$ 处找到键，则返回序对 $[b^\\*, j]$。\n6.  如果内部搜索未找到键，则报告“未找到”。这个结果是确定性的，因为 $X[b^\\*]$ 是 $x$ 唯一可能的位置。", "answer": "```python\nimport numpy as np\n\ndef search_in_two_level_index(data_structure, query_key):\n    \"\"\"\n    Performs a two-level search on the described data structure.\n\n    Args:\n        data_structure (list of lists): The two-level index X.\n        query_key (int or float): The key to search for.\n\n    Returns:\n        list or int: [block_index, inner_index] if found, otherwise -1.\n    \"\"\"\n    # Step 1: Filter to get non-empty blocks and their original indices.\n    non_empty_info = []\n    for i, block in enumerate(data_structure):\n        if block:\n            non_empty_info.append((i, block))\n\n    if not non_empty_info:\n        return -1\n\n    num_non_empty = len(non_empty_info)\n\n    # Step 2: Outer search (Jump Search) to find the candidate block.\n    # Check if the key is smaller than the very first element.\n    if query_key  non_empty_info[0][1][0]:\n        return -1\n\n    # Derive step size from first principles.\n    step_size = int(np.sqrt(num_non_empty))\n    if step_size == 0: # Handle case where num_non_empty is 1\n        step_size = 1\n\n    prev_idx = 0\n    curr_idx = 0\n    # Jumping phase.\n    while curr_idx  num_non_empty and non_empty_info[curr_idx][1][0] = query_key:\n        prev_idx = curr_idx\n        curr_idx += step_size\n\n    # Linear scanning phase within the identified interval.\n    candidate_block_info = None\n    # The range to scan in `non_empty_info` is [prev_idx, min(curr_idx, num_non_empty) - 1].\n    # We scan backwards to find the last block whose first element is = query_key.\n    for i in range(min(curr_idx, num_non_empty) - 1, prev_idx - 1, -1):\n        if non_empty_info[i][1][0] = query_key:\n            candidate_block_info = non_empty_info[i]\n            break\n    \n    if candidate_block_info is None:\n        return -1\n\n    original_block_idx, block_data = candidate_block_info\n\n    # Step 3: Inner search (Leftmost-finding Binary Search).\n    low = 0\n    high = len(block_data) - 1\n    found_idx = -1\n\n    while low = high:\n        mid = low + (high - low) // 2\n        \n        if block_data[mid] == query_key:\n            found_idx = mid\n            high = mid - 1  # Continue searching left for the first occurrence.\n        elif block_data[mid]  query_key:\n            low = mid + 1\n        else: # block_data[mid] > query_key\n            high = mid - 1\n            \n    if found_idx != -1:\n        return [original_block_idx, found_idx]\n    else:\n        return -1\n\ndef solve():\n    \"\"\"\n    Defines test cases and runs the search algorithm on them, producing\n    the final formatted output.\n    \"\"\"\n    d_a = [[1, 3, 5, 5], [8, 9, 10], [14, 14, 15, 16], [20, 21]]\n    d_b = [[-10, -5], [0], [2, 4, 6, 8, 10], [13, 17, 19], [23]]\n    d_c = [[], [1, 2, 3], [5], [7, 7, 7, 7], [9, 12]]\n\n    test_cases = [\n        (d_a, 14),\n        (d_a, 1),\n        (d_a, 21),\n        (d_a, 7),\n        (d_a, 0),\n        (d_a, 100),\n        (d_b, 17),\n        (d_c, 7),\n        (d_c, 4),\n        (d_b, -10),\n    ]\n\n    results = []\n    for data_structure, query_key in test_cases:\n        result = search_in_two_level_index(data_structure, query_key)\n        if isinstance(result, list):\n            # Format list [b, j] as a string \"[b,j]\" without spaces.\n            results.append(f\"[{result[0]},{result[1]}]\")\n        else:\n            results.append(str(result))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3242865"}]}