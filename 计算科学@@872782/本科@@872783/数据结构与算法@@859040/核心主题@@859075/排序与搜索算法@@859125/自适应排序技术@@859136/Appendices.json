{"hands_on_practices": [{"introduction": "我们实践的第一步是构建一个自适应排序算法。一个直观的“几乎有序”的情形是，数组中的每个元素离它在排序后的最终位置不远。这个练习 ([@problem_id:3203352]) 旨在利用这一特性：如果每个元素距离其最终位置最多为 $k$ 个索引，我们就可以将寻找下一个最小元素的工作范围限制在一个大小为 $k+1$ 的“窗口”内。通过使用最小堆来高效地管理这个窗口，你可以设计并实现一个时间复杂度为 $O(n \\log k)$ 的算法，这比通用的 $O(n \\log n)$ 排序算法在 $k$ 较小时要快得多。", "problem": "给定在全序域上的数组，并保证对于每个元素，其与在排序后最终位置的位移最多为 $k$ 个索引。形式上，设输入为一个长度为 $n$ 的数组 $A$，其元素属于一个具有全序关系 $\\leq$ 的集合。对于每个元素 $A[i]$，令 $pos(A[i])$ 表示在将 $A$ 按非递减顺序排序后（任何平局情况通过确定性规则解决）得到的数组中 $A[i]$ 的索引。保证对于所有 $i \\in \\{0,1,\\dots,n-1\\}$，位移满足 $\\lvert pos(A[i]) - i \\rvert \\leq k$，其中 $k$ 是一个非负整数。你的任务是设计并实现一种自适应排序技术，利用此位移界限，以实现最坏情况时间复杂度 $O(n \\log k)$ 和空间复杂度 $O(k)$，同时返回按非递减顺序排序的数组。\n\n你可以使用的基本定义：\n- 全序是在集合 $S$ 上的二元关系 $\\leq$，使得对于所有 $x,y \\in S$，以下三者之一必成立：$x  y$、$x = y$ 或 $x > y$；且该关系具有传递性和反对称性。\n- 优先队列 (PQ) 是一种抽象数据类型，支持插入元素和提取最小元素（根据 $\\leq$），两种操作的时间复杂度都与其当前存储的元素数量的对数成正比。\n- 二叉堆是一种实现优先队列的数据结构，其插入和提取最小值的操作时间复杂度为 $O(\\log m)$，其中 $m$ 是堆中当前的元素数量。\n\n你的程序必须实现所述的自适应排序算法，将其应用于以下测试套件，并按规定格式生成结果。\n\n测试套件（每个测试用例为一对 $(A,k)$）：\n1. $A = [12,3,5,9,24,15,18,21,30,27]$, $k = 3$。\n2. $A = [1,2,2,3]$, $k = 0$。\n3. $A = [2,1,4,3,6,5]$, $k = 1$。\n4. $A = []$, $k = 2$。\n5. $A = [42]$, $k = 10$。\n6. $A = [-2,-5,-2,3,0,3,7]$, $k = 2$。\n7. $A = [23,42,4,8,15,16]$, $k = 5$。\n8. $A = [30,40,50,10,20]$, $k = 100$。\n9. $A = [3,1,2,6,4,5,9,7,8,10]$, $k = 2$。\n\n输出规范：\n- 对于每个测试用例，程序必须输出排序后的数组（一个整数列表），对应于将 $A$ 按非递减顺序排序的结果。\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表内容为各测试用例的结果，顺序与上述测试套件一致。例如，输出格式必须为 $[result_1,result_2,\\dots,result_9]$，其中每个 $result_i$ 是测试用例 $i$ 的排序后列表。\n- 数组中的所有数值均为纯整数；不涉及物理单位或角度。\n\n约束条件：\n- $n$ 是任意非负整数。\n- $k$ 是任意非负整数（当 $k \\geq n-1$ 时，该保证无实际意义，但算法仍必须运行并返回正确的排序顺序）。", "solution": "该问题要求为“近似排序”的数组设计一种自适应排序算法。近似排序的具体性质是：输入数组 $A$ 中任意索引 $i$ 处的元素，在其最终排好序的数组中，索引为 $j$，其位移 $\\lvert i - j \\rvert \\leq k$，其中 $k$ 是一个给定的非负整数。该算法必须达到 $O(n \\log k)$ 的最坏情况时间复杂度和 $O(k)$ 的辅助空间复杂度，其中 $n$ 是数组中的元素数量。\n\n### 基本原理\n该自适应方法的核心在于从给定性质 $\\lvert pos(A[i]) - i \\rvert \\leq k$ 中得出的一个关键推论，其中 $pos(A[i])$ 是元素 $A[i]$ 最终排好序的索引。这个不等式可以重新整理，用于分析排序后序列中元素的来源。设 $S$ 是数组 $A$ 按非递减顺序排序后的数组。对于排序后数组中索引为 $j$ 的元素 $S[j]$，它在 $A$ 中的原始索引 $i$ 必须满足 $\\lvert j - i \\rvert \\leq k$。这意味着 $j-k \\leq i \\leq j+k$。\n\n这是一个非常强的约束。它告诉我们，排序后输出中位置 $j$ 处的元素 $S[j]$，必定位于输入数组 $A$ 的索引范围 $[\\max(0, j-k), \\min(n-1, j+k)]$ 之内。对于一个构造性算法而言，更重要的是，它保证了全局最小元素 $S[0]$ 必然来自 $A$ 中索引 $i \\in [0, k]$ 的范围。第二小的元素 $S[1]$ 必然来自 $A$ 中索引 $i \\in [0, 1+k]$ 的范围。通常来说，排序后数组的第 $j$ 个元素 $S[j]$ 必定存在于输入数组的前缀 $A[0 \\dots j+k]$ 中。\n\n这种局部性表明，我们无需考虑整个数组来寻找下一个最小元素。相反，我们可以维护一个候选元素的“窗口”，并反复从此窗口中提取最小值。一个通过最小堆实现的最小优先队列是完成此任务的理想数据结构，因为它支持高效地提取最小值和插入新元素。\n\n### 算法设计\n算法流程如下，使用一个最小堆来管理一个滑动的候选窗口：\n1.  初始化一个空列表 `result`，用于存储排序后的元素。\n2.  初始化一个最小优先队列 `pq`。\n3.  用输入数组 $A$ 的前 `min(n, k+1)` 个元素填充 `pq`。这构成了初始的候选窗口。如果 $n \\le k$，则 $A$ 的所有元素都被加入。使用线性时间复杂度的建堆算法，此步骤耗时 $O(k)$。\n4.  迭代 $n$ 次以构建排序后的 `result` 数组。在每次迭代中：\n    a. 从 `pq` 中提取最小元素。根据上述原理，此元素保证是排序序列中的下一个最小元素。将其追加到 `result`。\n    b. 为了维持滑动窗口，如果输入数组 $A$ 中还有下一个未检查的元素，则将其插入 `pq`。处理完初始的 `min(n, k+1)` 个元素并提取一个后，要考虑的下一个元素位于索引 `min(n, k+1)` 处，以此类推。\n\n优先队列 `pq` 的大小对算法性能至关重要。它最多用 $k+1$ 个元素初始化。在主循环的每一步中，一个元素被移除，一个元素被添加（直到输入数组耗尽）。因此，`pq` 中的元素数量永远不会超过 $k+1$。\n\n### 正确性论证\n该算法的正确性取决于一个循环不变量：在每次提取之前，`pq` 中包含了所有尚未排序的元素中的最小者。\n让我们将其形式化。假设我们即将确定排序后数组的第 $j$ 个元素 $S[j]$。此时，算法已经将 $S[0], \\dots, S[j-1]$ 放入 `result` 数组。已插入 `pq` 的输入数组 $A$ 中的元素来自索引 $0$ 直到至少 $j+k-1$（如果 $n$ 较小则更少）。\n元素 $S[j]$ 必须来自一个原始索引 $i \\le j+k$。因为所有来自 $A[0 \\dots j+k-1]$ 的元素都已被考虑（要么已放入 `result`，要么仍在 `pq` 中），并且如果存在 $A[j+k]$，我们即将添加它，所以真正的 $S[j]$ 保证在 `pq` 中。由于 `pq` 是一个最小优先队列，`extract-min` 操作将正确返回 $S[j]$。这对所有从 $0$ 到 $n-1$ 的 $j$ 都成立。\n\n### 复杂度分析\n-   **时间复杂度**：用 $\\min(n, k+1)$ 个元素初始化 `pq` 耗时 $O(\\min(n, k)) = O(k)$（因为如果 $n \\le k$，则为 $O(n)$；如果我们假设 $k  n$ 对于自适应排序有意义，则为 $O(k)$）。主循环运行 $n$ 次。在循环内部，我们执行一次 `extract-min` 和最多一次 `insert` 操作。`pq` 的大小以 $k+1$为界。因此，每次堆操作耗时 $O(\\log k)$。总时间复杂度为 $O(k) + n \\times O(\\log k) = O(n \\log k)$。这满足了指定的要求。如果 $k=0$，复杂度为 $O(n)$；如果 $k \\geq n-1$，则变为 $O(n \\log n)$，行为如同标准的堆排序。\n-   **空间复杂度**：辅助空间主要由优先队列占用。由于其大小以 $k+1$ 为界，空间复杂度为 $O(k)$。输出数组 `result` 需要 $O(n)$ 空间，这通常被归类为输出空间而非辅助空间。该算法满足了对辅助存储 $O(k)$ 的空间复杂度要求。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport heapq\n\ndef adaptive_sort(A, k):\n    \"\"\"\n    Sorts a k-nearly-sorted array in O(n log k) time and O(k) auxiliary space.\n\n    An array is k-nearly-sorted if for every element, its final sorted position\n    is at most k indices away from its current position.\n\n    Args:\n        A (list): The input array of numbers.\n        k (int): The maximum displacement of any element.\n\n    Returns:\n        list: The sorted array.\n    \"\"\"\n    n = len(A)\n    if n == 0:\n        return []\n\n    # The size of the initial heap and the sliding window.\n    # If k >= n-1, this will be n, correctly turning the algorithm into a heapsort.\n    window_size = min(n, k + 1)\n    \n    # Python's heapq implements a min-heap.\n    # Initialize the heap with the first `window_size` elements.\n    pq = A[:window_size]\n    heapq.heapify(pq)  # This operation takes O(window_size) time.\n\n    result = []\n    # Index of the next element from A to be added to the heap.\n    next_elem_idx = window_size\n\n    # The loop runs n times, once for each element to be placed in the result.\n    for _ in range(n):\n        # The smallest element in the heap is the next element in the sorted sequence.\n        # We can extract it.\n        min_val = heapq.heappop(pq)\n        result.append(min_val)\n\n        # If there are more elements in the input array, add the next one to the heap\n        # to maintain the sliding window of candidates.\n        if next_elem_idx  n:\n            heapq.heappush(pq, A[next_elem_idx])\n            next_elem_idx += 1\n            \n    return result\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        ([12, 3, 5, 9, 24, 15, 18, 21, 30, 27], 3),\n        ([1, 2, 2, 3], 0),\n        ([2, 1, 4, 3, 6, 5], 1),\n        ([], 2),\n        ([42], 10),\n        ([-2, -5, -2, 3, 0, 3, 7], 2),\n        ([23, 42, 4, 8, 15, 16], 5),\n        ([30, 40, 50, 10, 20], 100),\n        ([3, 1, 2, 6, 4, 5, 9, 7, 8, 10], 2)\n    ]\n\n    results = []\n    for A, k in test_cases:\n        sorted_A = adaptive_sort(list(A), k) # Use a copy to not modify original\n        results.append(sorted_A)\n\n    # Format the final list of results into the specified string format.\n    # e.g., [[1, 2], [3, 4]] -> \"[[1, 2], [3, 4]]\"\n    # Using str() on a list automatically includes spaces, e.g., '[1, 2, 3]'.\n    # To match a compact format, we might need custom string formatting.\n    # However, the prompt's example code `','.join(map(str, results))` suggests `str()` is fine.\n    # Let's verify: `str([1,2])` is `[1, 2]`. This is list-like. Let's make it compact.\n    formatted_results = [f\"[{','.join(map(str, res))}]\" for res in results]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3203352"}, {"introduction": "在亲手构建了一个自适应算法之后，下一步是学习如何精确分析现有算法的性能。自然归并排序是一种经典的自适应技术，它通过识别和合并输入数据中已存在的有序子序列（称为“顺串”）来工作。这个练习 ([@problem_id:3203381]) 要求你分析在一个特定的、非平凡的输入（一个双调数组）上自然归并排序的精确比较次数。通过分解算法的步骤——顺串检测和多路合并——你将深入理解自适应排序的效率如何直接取决于输入的内在结构，而不是仅仅取决于其大小。", "problem": "考虑一个长度为 $n$ 的数组 $A$，其中 $n \\geq 3$ 是一个奇数，其内容构成一个双调模式，明确表示为 $A = \\langle 1, 3, 5, \\dots, n, n-1, \\dots, 2 \\rangle$。自适应排序算法是指其运行时间取决于输入的预排序度的形式化度量，而不仅仅取决于 $n$。自然归并排序是一种自适应排序技术，其操作遵循以下规则：\n- 它从左到右扫描数组，将其划分为多个最大单调行程，其中行程是一个严格非递减或严格非递增的连续子序列。\n- 任何严格非递增的行程在合并前都会被原地反转，使其变为严格非递减。\n- 然后，它重复地对相邻行程进行稳定的双路合并，直到只剩下一个覆盖整个数组的已排序行程。\n假设在标准比较模型下，算法的成本仅通过计算键与键之间的比较次数来衡量。具体来说，测试相邻元素单调性的扫描对每对相邻元素恰好使用一次比较，反转操作不使用任何比较，并且当所有键都不同时，合并两个长度分别为 $a$ 和 $b$ 的严格递增行程恰好使用 $a + b - 1$ 次比较。\n\n在这些假设下，推导自然归并排序对上述数组 $A$ 执行的总键值比较次数的精确闭式表达式（作为 $n$ 的函数），包括初始行程检测阶段和所有合并阶段。将你的最终答案表示为单个符号表达式。无需四舍五入。", "solution": "总键值比较次数 $C_T$ 是初始行程检测阶段的比较次数 $C_{scan}$ 与所有后续合并阶段的比较次数 $C_{merge}$ 之和：$C_T = C_{scan} + C_{merge}$。\n\n首先，我们分析行程检测阶段。为了找到数组中的所有最大单调行程，算法需要比较 $n-1$ 对相邻元素。因此，扫描成本为 $C_{scan} = n-1$。\n\n对于给定的双调数组 $A = \\langle 1, 3, \\dots, n, n-1, \\dots, 2 \\rangle$，在元素 $n$ 和 $n-1$ 之间存在一个单调性转折点。因此，扫描过程会识别出两个行程：\n1.  $R_1 = \\langle 1, 3, \\dots, n \\rangle$：一个长度为 $a = \\frac{n-1}{2} + 1 = \\frac{n+1}{2}$ 的严格递增行程。\n2.  $R_2 = \\langle n-1, n-3, \\dots, 2 \\rangle$：一个长度为 $b = n - a = \\frac{n-1}{2}$ 的严格递减行程。\n\n接下来，在合并之前，严格递减的行程 $R_2$ 会被原地反转，这不产生任何比较成本。现在我们有两个严格递增的行程需要合并。\n\n合并阶段只涉及一次双路合并。根据问题描述，合并两个长度为 $a$ 和 $b$ 的严格递增行程需要 $a+b-1$ 次比较。因此，合并成本为：\n$$ C_{merge} = a + b - 1 = \\left(\\frac{n+1}{2}\\right) + \\left(\\frac{n-1}{2}\\right) - 1 = n - 1 $$\n\n最后，总比较次数是扫描成本和合并成本之和：\n$$ C_T = C_{scan} + C_{merge} = (n-1) + (n-1) = 2n-2 $$\n这就是总比较次数的精确闭式表达式。", "answer": "$$\n\\boxed{2n - 2}\n$$", "id": "3203381"}, {"introduction": "现在，让我们将视野拓宽，从更抽象的层面理解“几乎有序”的含义。这个概念并非铁板一块，而是可以通过多种不同的“有序度”指标来量化。本练习 ([@problem_id:3203325]) 将引导你进行一个思想实验，对比两个核心指标：逆序数（inversions）和顺串数（runs）。你将构造一个特殊的排列，它按照顺串数衡量是“几乎有序”的，但按照逆序数衡量却是“高度无序”的。这个练习揭示了为特定类型的输入选择合适自适应算法的重要性，并锻炼了你根据数据特性进行算法设计和评估的深刻洞察力。", "problem": "考虑一个包含 $n$ 个不同关键字的集合，其目标排序顺序为 $1,2,\\dots,n$，其中 $n$ 是一个偶数且 $n \\geq 4$。两种自适应的、基于比较的排序算法 $A_1$ 和 $A_2$ 利用了不同的预排序性度量。定义一个排列 $\\pi$ 的逆序数 $I(\\pi)$ 为满足 $i  j$ 且 $\\pi(i) > \\pi(j)$ 的对 $(i,j)$ 的数量。定义升序顺串数 $R(\\pi)$ 为排列 $\\pi$ 中最大连续非递减子序列的数量。\n算法 $A_1$ 是一种基于顺串合并的排序算法，其比较次数由 $C_1(n, R) = n \\ln R$ 给出。\n算法 $A_2$ 是一种基于插入的排序算法，其比较次数由 $C_2(n, I) = n + I$ 给出。\n\n你的任务是推导一个闭式表达式，表示速度比因子 $\\rho(n) = \\frac{C_2(n,I(\\pi))}{C_1(n,R(\\pi))}$，该表达式适用于一个特定的、构造的排列 $\\pi$。这个排列 $\\pi$ 是通过连接两个长度各为 $n/2$ 的严格递增的连续块来形成的，并附加一个关键约束：第一个块中的每个关键字都大于第二个块中的每个关键字。\n\n你的推导应：\n1.  明确构造排列 $\\pi$。\n2.  计算 $\\pi$ 的升序顺串数 $R(\\pi)$。\n3.  计算 $\\pi$ 的逆序数 $I(\\pi)$。\n4.  代入成本函数 $C_1$ 和 $C_2$。\n5.  将比率 $\\rho(n)$ 简化为 $n$ 的函数。\n\n将你的最终答案以单个符号表达式的形式呈现。", "solution": "问题要求构造一个关键字集合 $\\{1, 2, \\dots, n\\}$ 的特定排列 $\\pi$，其中 $n$ 是一个偶数且 $n \\ge 4$。该排列由两个长度各为 $n/2$ 的严格递增的连续块连接而成，并附加约束条件：第一个块中的每个关键字都大于第二个块中的每个关键字。\n\n为了满足这些约束，关键字集合 $\\{1, 2, \\dots, n\\}$ 必须被划分为两个集合：较小的关键字 $\\{1, 2, \\dots, n/2\\}$ 和较大的关键字 $\\{n/2+1, \\dots, n\\}$。为了使第一个块中的所有关键字都大于第二个块中的所有关键字，第一个块必须由较大的关键字组成，第二个块必须由较小的关键字组成。由于每个块也是严格递增的，它们必须内部有序。\n因此，长度为 $n/2$ 的第一个块是序列 $(\\frac{n}{2}+1, \\frac{n}{2}+2, \\dots, n)$。\n长度为 $n/2$ 的第二个块是序列 $(1, 2, \\dots, \\frac{n}{2})$。\n\n将这两个块连接起来得到排列 $\\pi$：\n$$\n\\pi = \\left(\\frac{n}{2}+1, \\frac{n}{2}+2, \\dots, n, 1, 2, \\dots, \\frac{n}{2}\\right)\n$$\n\n接下来，我们必须确定这个特定排列的升序顺串数 $R(\\pi)$ 和逆序数 $I(\\pi)$。\n\n1.  **计算升序顺串数 $R(\\pi)$**：\n    升序顺串是一个最大连续非递减子序列。\n    序列的第一部分 $(\\frac{n}{2}+1, \\frac{n}{2}+2, \\dots, n)$ 是严格递增的，因此构成一个单独的升序顺串。\n    由于 $n > 1$，序列在元素 $n$ 和元素 $1$ 的连接处断开。\n    序列的第二部分 $(1, 2, \\dots, \\frac{n}{2})$ 也是严格递增的，构成第二个升序顺串。\n    因此，排列 $\\pi$ 恰好包含两个升序顺串。\n    $$\n    R(\\pi) = 2\n    $$\n    就顺串度量而言，这个排列是近似排序的，因为 $R(\\pi)$ 是一个很小的常数。\n\n2.  **计算逆序数 $I(\\pi)$**：\n    逆序是一个索引对 $(i, j)$，满足 $i  j$ 且 $\\pi(i) > \\pi(j)$。让我们分析可能的索引对。\n    - 如果索引 $i$ 和 $j$ 都在第一个块内（即 $1 \\le i  j \\le n/2$），那么 $\\pi(i)  \\pi(j)$，因为第一个块是严格递增的。这贡献了 $0$ 个逆序。\n    - 如果索引 $i$ 和 $j$ 都在第二个块内（即 $n/2+1 \\le i  j \\le n$），那么 $\\pi(i)  \\pi(j)$，因为第二个块是严格递增的。这贡献了 $0$ 个逆序。\n    - 如果索引 $i$ 在第一个块中（$1 \\le i \\le n/2$）而索引 $j$ 在第二个块中（$n/2+1 \\le j \\le n$），那么 $\\pi(i)$ 是来自集合 $\\{\\frac{n}{2}+1, \\dots, n\\}$ 的一个关键字，而 $\\pi(j)$ 是来自集合 $\\{1, \\dots, \\frac{n}{2}\\}$ 的一个关键字。根据构造，第一个块中的每个关键字都大于第二个块中的每个关键字。因此，对于每个这样的对 $(i, j)$，都有 $\\pi(i) > \\pi(j)$ 成立，从而产生一个逆序。\n\n    要找到此类逆序的总数，我们将 $i$ 的可能选择数乘以 $j$ 的可能选择数。第一个块中的元素数量是 $n/2$，第二个块中的元素数量也是 $n/2$。\n    逆序的总数是：\n    $$\n    I(\\pi) = \\left(\\frac{n}{2}\\right) \\times \\left(\\frac{n}{2}\\right) = \\frac{n^2}{4}\n    $$\n    就逆序数度量而言，这个排列远非有序，因为 $I(\\pi)$ 随 $n$呈二次方增长。\n\n现在，我们使用给定的成本模型来计算每种算法的比较次数。\n对于基于顺串合并的算法 $A_1$，其成本为：\n$$\nC_1(n, R(\\pi)) = n \\ln(R(\\pi)) = n \\ln(2)\n$$\n对于基于插入的算法 $A_2$，其成本为：\n$$\nC_2(n, I(\\pi)) = n + I(\\pi) = n + \\frac{n^2}{4}\n$$\n\n最后，我们计算加速比因子 $\\rho(n)$，定义为 $C_2$ 与 $C_1$ 之比：\n$$\n\\rho(n) = \\frac{C_2(n, I(\\pi))}{C_1(n, R(\\pi))} = \\frac{n + \\frac{n^2}{4}}{n \\ln(2)}\n$$\n我们可以简化这个表达式。从分子中提出因子 $n$（由于 $n \\ge 4$，这是允许的）：\n$$\n\\rho(n) = \\frac{n \\left(1 + \\frac{n}{4}\\right)}{n \\ln(2)} = \\frac{1 + \\frac{n}{4}}{\\ln(2)}\n$$\n为了以更标准的形式（分子中没有分数）呈现表达式，我们可以写成：\n$$\n\\rho(n) = \\frac{\\frac{4+n}{4}}{\\ln(2)} = \\frac{n+4}{4\\ln(2)}\n$$\n这就是加速比因子 $\\rho(n)$ 的最终、简化的封闭形式表达式。", "answer": "$$\n\\boxed{\\frac{n+4}{4\\ln(2)}}\n$$", "id": "3203325"}]}