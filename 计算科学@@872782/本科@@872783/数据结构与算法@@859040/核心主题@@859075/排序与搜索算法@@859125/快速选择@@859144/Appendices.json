{"hands_on_practices": [{"introduction": "掌握一种算法需要深入理解其实现细节。本练习提出了快速选择算法中一个常见的陷阱：因混淆数组索引和元素排名而导致的“差一”错误。通过调试这段伪代码，你将巩固对快速选择算法赖以正常工作的递归逻辑的理解。[@problem_id:3205756]", "problem": "给定以下伪代码，它旨在使用类似快速选择的方法返回数组中第 $k$小的元素。数组使用 0-based 索引，输入 $k$ 是 1-based 的（也就是说，$k = 1$ 返回最小值，$k = n$ 返回最大值）。数组元素是唯一的。划分例程是 Lomuto 方案，选择 $A[hi]$ 作为主元，它返回一个索引 $p$，使得 $A[lo \\ldots p-1]$ 中的所有元素都小于或等于 $A[p]$，而 $A[p+1 \\ldots hi]$ 中的所有元素都严格大于 $A[p]$。\n\n伪代码：\n\nfunction quickselect(A, k):\n    return select(A, 0, n-1, k)\n\nfunction select(A, lo, hi, k):\n    if lo = hi: return A[lo]\n    p = partition(A, lo, hi)\n    if p = k: return A[p]\n    else if p > k: return select(A, lo, p-1, k)\n    else: return select(A, p+1, hi, k - p)\n\n上述算法在比较主元位置和调整递归参数 $k$ 时存在一个差一错误（off-by-one error）。为了推断正确的行为，回顾以下基本定义和事实：\n\n- 一个集合的第 $k$ 顺序统计量是当该集合按非递减顺序排序时，秩为 $k$ 的元素；秩是这个排序顺序中的位置。\n- 根据 Lomuto 划分的不变性，在 $\\mathrm{partition}(A, lo, hi)$ 返回索引 $p$ 后，$A[lo \\ldots hi]$ 中严格小于 $A[p]$ 的元素数量恰好是 $p - lo$ 个，因此在子数组 $A[lo \\ldots hi]$ 中，$A[p]$ 的秩在秩是 1-based 时为 $p - lo + 1$，在秩是 0-based 时为 $p - lo$。\n\n在保留 0-based 数组索引和 1-based 的 $k$ 的前提下，哪个选项给出了修复这个差一错误的正确的最小修改？\n\nA. 计算主元在当前子数组中的秩为 $t \\leftarrow p - lo + 1$（1-based）。将 select 中的条件和递归替换为：\n- if t = k: return A[p]\n- else if t > k: return select(A, lo, p-1, k)\n- else: return select(A, p+1, hi, k - t)\n保持初始调用为 select(A, 0, n-1, k)。\n\nB. 在入口处通过调用 select(A, 0, n-1, k - 1) 将 $k$ 转换为 0-based，然后保持函数体不变，在右分支中调用 select(A, p+1, hi, k - p)，不做进一步调整。\n\nC. 将 $k$ 解释为子数组内的 0-based 秩，并计算 $r \\leftarrow p - lo$。将条件判断替换为：\n- if r = k: return A[p]\n- else if r > k: return select(A, lo, p-1, k)\n- else: return select(A, p+1, hi, k - r)\n并保持初始调用为 select(A, 0, n-1, k)。\n\nD. 将 Lomuto 划分替换为 Hoare 划分，它返回的索引 $p$ 可能不会将主元放在其最终排序位置上，并保持 select 逻辑不变，寄希望于不同的 $p$ 语义能够修复这个差一错误。\n\n选择所有适用的选项。", "solution": "### 正确算法的推导\n\n快速选择算法的核心是递归地划分数组并在正确的子数组中进行搜索。关键是正确地跟踪所寻找元素的秩。参数 $k$ 表示在当前子数组 $A[lo \\ldots hi]$ 定义的搜索空间内所期望的秩（1-based）。\n\n原始代码有几个缺陷，其根源在于混淆了数组索引（0-based）、秩（1-based）以及全局位置与局部位置。\n\n1.  **比较 `p = k`**：变量 $p$ 是主元在*整个*数组 $A$ 中的 0-based 索引。变量 $k$ 是期望的 1-based 秩。直接比较它们是一个类型错误。例如，要找到最小的元素（$k=1$），我们寻找的是最终会位于索引 $0$ 的元素。检查应该是类似 `p = k-1` 这样的形式。\n\n2.  **递归更新 `k - p`**：在“else”分支中（当目标在右子数组时），代码将秩更新为 `$k - p$`。这试图解释从左边丢弃的元素。被丢弃的元素数量是左边分区的大小*加上*主元。当 `lo=0` 时，位于索引 `p` 的主元将数组划分为 `A[0...p-1]`、`A[p]` 和 `A[p+1...n-1]`。小于或等于主元的元素数量是 `p+1`。新的秩应该是 `$k - (p+1)$`。代码中的 `$k-p$` 是不正确的。更一般地，对于子数组 $A[lo...hi]$，包括主元及其左侧所有元素在内的分区中的元素数量不仅仅与 $p$ 相关，而是与 `$p-lo+1$` 相关。\n\n让我们使用关于主元秩的既定事实来推导正确的逻辑。设搜索空间为子数组 $A[lo \\ldots hi]$，并设 $k$ 为我们正在寻找的元素*在此子数组中*的 1-based 秩。\n\n1.  划分 $A[lo \\ldots hi]$ 以获得主元的最终索引 $p$。\n2.  计算主元在*当前子数组* $A[lo \\ldots hi]$ 中的 1-based 秩。根据问题陈述，这个秩是 $t = p - lo + 1$。\n3.  将主元的局部秩 $t$ 与期望的局部秩 $k$ 进行比较：\n    -   如果 $t = k$，那么主元 $A[p]$ 就是当前子数组中的第 $k$ 个元素。我们找到了该元素。返回 $A[p]$。\n    -   如果 $t > k$，期望的元素小于主元，并且必定位于左子数组 $A[lo \\ldots p-1]$ 中。我们仍然在寻找第 $k$ 小的元素，但现在是在这个新的、更小的搜索空间中。秩 $k$ 不变。递归调用是 `select(A, lo, p-1, k)`。\n    -   如果 $t  k$，期望的元素大于主元，并且必定位于右子数组 $A[p+1 \\ldots hi]$ 中。我们已经丢弃了主元及其左侧的 $t-1$ 个元素，总共是 $t$ 个元素。我们寻找的元素是第 $k$ 小的，因此它将是剩余子数组中的第 $(k-t)$ 小的元素。递归调用是 `select(A, p+1, hi, k-t)`。\n\n初始调用仍然是 `select(A, 0, n-1, k)`，其中 $k$ 是在整个数组中期望的秩。\n\n### 逐项分析选项\n\n**A. 计算主元在当前子数组中的秩为 $t \\leftarrow p - lo + 1$（1-based）。将 select 中的条件和递归替换为：**\n- **if t = k: return A[p]**\n- **else if t > k: return select(A, lo, p-1, k)**\n- **else: return select(A, p+1, hi, k - t)**\n**保持初始调用为 select(A, 0, n-1, k)。**\n\n该选项的逻辑与我们推导出的正确算法完全一致。它正确地计算了主元的局部秩 $t$，并将其与期望的秩 $k$ 进行比较。递归调用正确地调整了搜索空间（`lo`, `hi`）和目标秩（在右侧情况下为 `$k-t$`）。\n\n结论：**正确**。\n\n**B. 在入口处通过调用 select(A, 0, n-1, k - 1) 将 $k$ 转换为 0-based，然后保持函数体不变，在右分支中调用 select(A, p+1, hi, k - p)，不做进一步调整。**\n\n这个选项的表述令人困惑。我们假设“保持函数体不变”指的是使用原始错误代码的结构，但参数现在是 0-based 的。让我们称 0-based 的秩参数为 $k_0$。\n初始调用：`select(A, 0, n-1, k-1)`。\n`function select(A, lo, hi, k_0)`:\n- `p = partition(A, lo, hi)`\n- `if p = k_0`: 这个比较现在在概念上是正确的，因为比较的是两个 0-based 的索引。\n- `else if p > k_0`: `select(A, lo, p-1, k_0)`。这是正确的；目标索引仍然是 $k_0$。\n- `else`: `select(A, p+1, hi, k_0 - p)`。这是关键的更新规则。左侧分区（包括主元）中的元素数量是 `$p-lo+1$`。秩的更新应该基于这个数量。然而，更新却是 `$k_0 - p$`。这个逻辑是有缺陷的，因为它使用全局索引 $p$ 来调整秩，而没有考虑子数组的起始位置 `lo`。对于任何 `lo > 0` 的递归，这都会失败。例如，如果我们在右子数组 $A[lo', hi']$ 上递归，丢弃的元素数量与新主元的全局索引 $p'$ 无关，而与局部计数 `$p' - lo' + 1$` 有关。公式 `$k_0 - p$` 在一般情况下是根本错误的。\n\n结论：**不正确**。\n\n**C. 将 $k$ 解释为子数组内的 0-based 秩，并计算 $r \\leftarrow p - lo$。将条件判断替换为：**\n- **if r = k: return A[p]**\n- **else if r > k: return select(A, lo, p-1, k)**\n- **else: return select(A, p+1, hi, k - r)**\n**并保持初始调用为 select(A, 0, n-1, k)。**\n\n这个选项引入了多个错误。\n1.  它将 $r = p-lo$ 与 $k$ 进行比较。$r$ 是子数组中比主元小的元素数量，这是一个 0-based 的秩。$k$ 是原始的 1-based 秩。这是一个类型不匹配。\n2.  即使我们假设 $k$ 应该被解释为 0-based 的秩 `$k-1$`，右子数组的递归更新 `$k-r$` 也是有缺陷的。如果我们丢弃了比主元小的 $r$ 个元素，再加上主元本身，我们总共丢弃了 $r+1$ 个元素。新的 0-based 秩应该是 `$(k-1) - (r+1) = k-r-2$`。选项的更新 `$k-r$` 是不正确的。\n\n结论：**不正确**。\n\n**D. 将 Lomuto 划分替换为 Hoare 划分，它返回的索引 $p$ 可能不会将主元放在其最终排序位置上，并保持 select 逻辑不变，寄希望于不同的 $p$ 语义能够修复这个差一错误。**\n\n这从根本上是错误的。`select` 的控制逻辑与其使用的划分方案的不变性紧密耦合。Lomuto 方案保证主元位于其最终排序位置 `p`。逻辑 `if p = k-1`（修正后版本）依赖于此。Hoare 划分方案返回一个分割索引 `j`，使得 `A[lo...j]` 中的元素小于或等于 `A[j+1...hi]` 中的元素，但 `A[j]` 不一定是主元，也不一定在其最终排序位置上。将为 Lomuto 的 `p` 设计的逻辑应用于 Hoare 的 `j` 是毫无意义的，并且不会起作用。它不会修复差一错误；它会用一个灾难性的逻辑错误来取代这个差一错误。\n\n结论：**不正确**。", "answer": "$$\\boxed{A}$$", "id": "3205756"}, {"introduction": "算法的效率并非一个抽象属性，它与底层的数据结构紧密相连。本练习将挑战你分析和比较快速选择算法在数组和单向链表上实现时的性能。这次探索将加深你对复杂度分析以及不同数据表示方式之间实际权衡的理解。[@problem_id:3262375]", "problem": "给定一个未排序的、由不同键组成的集合，存储在连续数组或单向链表中。您希望使用快速选择 (Quickselect) 算法找到秩为 $k$ 的元素（第 $k$ 小的元素）。该算法包括重复选择一个基准 (pivot)，围绕该基准对当前子问题进行划分，并仅对包含目标秩的一侧进行递归。假设以下基本事实和成本模型：\n- 在数组中，随机访问索引 $i$ 的时间成本为 $\\Theta(1)$，交换两个元素的成本为 $\\Theta(1)$，扫描 $m$ 个连续元素的成本为 $\\Theta(m)$。\n- 在单向链表中，从一个节点移动到其后继节点的成本为 $\\Theta(1)$，维护或更新常数个指针的成本为 $\\Theta(1)$，扫描 $m$ 个节点的成本为 $\\Theta(m)$。不存在对第 $i$ 个节点的亚线性时间随机访问。\n- 在数组中，围绕选定的基准进行原地 (in-place) 划分，可以通过一次从左到右的扫描和使用常数个索引来完成。在单向链表中，围绕选定的基准进行划分，可以通过一次扫描将节点重新链接到最多三个子链表（小于、等于、大于基准）中来完成，而无需分配新节点。\n- 在数组中，通过采样一个均匀随机索引，可以在 $\\Theta(1)$ 时间内从 $m$ 个元素中获得一个均匀随机的基准；在单向链表中，获得一个均匀随机的基准需要对 $m$ 个节点进行一次完整的扫描（例如，通过蓄水池抽样），然后需要另一次扫描来根据该基准进行划分。\n- 除非另有说明，否则忽略由底层实现引起的常数因子差异，但在渐近推理中，如果这些差异改变了对数据的完整扫描次数，则不应忽略它们。\n\n在这些假设下，分析快速选择 (Quickselect) 算法在这两种数据结构上的性能。下列哪些陈述是正确的？\n\nA. 在数组上，如果可以在 $\\Theta(1)$ 时间内获得均匀随机基准并进行原地划分，那么快速选择算法的期望运行时间为 $\\Theta(n)$，最坏情况运行时间为 $\\Theta(n^2)$；它在数组本身之外使用 $\\Theta(1)$ 的额外空间（尾递归可以被消除）。\n\nB. 在单向链表上，如果坚持选择在当前 $m$ 个节点中均匀随机的基准，则每次迭代需要执行 $\\Theta(m)$ 的工作来选择基准，以及另外 $\\Theta(m)$ 的工作来进行划分，然而整个算法的期望运行时间仍为 $\\Theta(n)$；在这种基准规则下，最坏情况时间仍为 $\\Theta(n^2)$。\n\nC. 在单向链表上，如果不分配 $\\Theta(n)$ 的额外内存用于辅助数组，就无法在线性时间内进行划分，因此快速选择算法在链表上必然使用 $\\Theta(n)$ 的额外空间。\n\nD. 在单向链表上，确定性地选择头节点作为基准，即使对于对抗性的输入顺序，也能得到 $\\Theta(n)$ 的期望时间，因为头节点对于选择来说与均匀随机的基准一样具有信息量。\n\nE. 使用确定性的“中位数的中位数” (median-of-medians) 基准选择过程，快速选择算法在数组和单向链表上的最坏情况运行时间均为 $\\Theta(n)$；在该策略下，两种表示之间的渐近差异仅在于源于顺序扫描和内存局部性的常数因子。", "solution": "用户要求基于一组给定的假设，对快速选择 (Quickselect) 算法在数组和单向链表上的性能进行批判性分析。必须首先验证问题陈述的正确性和连贯性。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n- **算法**：用于查找第 $k$ 小元素的快速选择 (Quickselect) 算法。\n- **键**：互不相同。\n- **数据结构**：连续数组，单向链表。\n- **成本模型（数组）**：\n    - 随机访问索引 $i$：$\\Theta(1)$。\n    - 交换两个元素：$\\Theta(1)$。\n    - 扫描 $m$ 个连续元素：$\\Theta(m)$。\n- **成本模型（单向链表 - SLL）**：\n    - 访问后继节点：$\\Theta(1)$。\n    - 更新常数个指针：$\\Theta(1)$。\n    - 扫描 $m$ 个节点：$\\Theta(m)$。\n    - 无亚线性时间随机访问。\n- **划分成本**：\n    - **数组**：原地，单次扫描。对于大小为 $m$ 的子问题，成本为 $\\Theta(m)$。\n    - **SLL**：通过将节点重新链接到子链表（小于/等于/大于基准）的方式进行单次扫描，无需分配新节点。对于大小为 $m$ 的子问题，成本也为 $\\Theta(m)$。\n- **基准选择成本**：\n    - **数组**：在 $\\Theta(1)$ 时间内获得均匀随机基准。\n    - **SLL**：均匀随机基准需要一次完整扫描（$\\Theta(m)$）来进行选择（例如，蓄水池抽样），再加上另一次扫描（$\\Theta(m)$）来进行划分。\n- **中位数的中位数**：提到了一种确定性的基准选择过程。\n\n**步骤 2：使用提取的已知条件进行验证**\n问题陈述描述了一个经典的算法分析场景。\n- **科学依据**：该问题植根于计算机科学的基本原理，涉及算法分析（快速选择）、数据结构（数组、链表）和复杂度理论（$\\Theta$ 符号）。所有关于操作成本和算法过程（划分、基准选择）的假设都是标准的且符合事实。\n- **问题定义良好**：问题是具体的，要求对几个陈述进行评估。所提供的成本模型和假设足以对每个陈述得出一个唯一的、可验证的答案。\n- **客观性**：语言精确、专业，没有歧义或主观看法。\n\n问题陈述没有违反任何无效标准。它是科学合理的、定义良好的、客观的、完整的且并非无足轻重。\n\n**步骤 3：结论与行动**\n问题是有效的。接下来将通过评估每个陈述来进行分析。\n\n### 解答推导\n\n分析基于快速选择算法对大小为 $n$ 的问题的时间复杂度递推关系 $T(n)$。该算法对数据进行划分，并对产生的一个子问题进行递归。\n$T(n) = (\\text{基准选择成本}) + (\\text{划分成本}) + T(\\text{子问题大小})$\n\n#### 选项 A 分析\n\n**陈述**：“在数组上，如果可以在 $\\Theta(1)$ 时间内获得均匀随机基准并进行原地划分，那么快速选择算法的期望运行时间为 $\\Theta(n)$，最坏情况运行时间为 $\\Theta(n^2)$；它在数组本身之外使用 $\\Theta(1)$ 的额外空间（尾递归可以被消除）。”\n\n1.  **期望时间**：\n    - 基准选择的成本是 $\\Theta(1)$，划分 $m$ 个元素的成本是 $\\Theta(m)$。在大小为 $m$ 的子问题上，每一步的工作量主要由划分决定，因此为 $\\Theta(m)$。\n    - 使用均匀随机基准时，有恒定的概率（例如 $1/2$）使基准落在已排序元素的中间一半（第 $25$ 百分位和第 $75$ 百分位之间）。这样一个“好的”基准保证了下一个子问题的大小最多为 $\\frac{3}{4}m$。\n    - 总工作量的期望递推关系可以看作是递归每一层划分成本的总和：$c n + c E[S_1] + c E[S_2] + \\dots$，其中 $S_i$ 是深度为 $i$ 的子问题的大小。\n    - 我们递归进入的子问题的期望大小是当前问题大小的一个常数比例。我们用 $\\alpha  1$ 表示这个比例。因此，总的期望工作量与 $\\sum_{i=0}^{\\infty} \\alpha^i n = n \\frac{1}{1-\\alpha} = \\Theta(n)$成正比。\n    - 更严谨的证明表明，期望时间确实是 $\\Theta(n)$。\n\n2.  **最坏情况时间**：\n    - 最坏情况发生在基准选择持续不佳时，例如，总是选到最小或最大的元素。这可能发生在对已排序数组使用确定性基准策略时，或者随机选择基准时运气极差的情况下。\n    - 在这种情况下，划分是最大程度不平衡的，每一步只将问题规模减一。递推关系变为 $T(n) = T(n-1) + \\Theta(n)$。\n    - 这个递推关系展开为 $T(n) = \\sum_{i=1}^{n} \\Theta(i) = \\Theta(n^2)$。\n\n3.  **空间复杂度**：\n    - 快速选择算法的标准递归实现的递归深度平均为 $\\Theta(\\log n)$，最坏情况下为 $\\Theta(n)$，这导致了调用栈上相应的空间使用。\n    - 然而，快速选择算法中的递归调用是尾调用。`quickselect(A, k, low, high)` 将调用 `quickselect(A, k, new_low, new_high)`。这种尾递归可以通过将算法转换为一个更新 `low` 和 `high` 边界的迭代循环来优化掉。这个迭代版本只需要常数个变量，因此其额外空间复杂度为 $\\Theta(1)$。\n\n**结论**：该陈述的所有部分都是正确的。\n**对 A 的判断**：**正确**。\n\n#### 选项 B 分析\n\n**陈述**：“在单向链表上，如果坚持选择在当前 $m$ 个节点中均匀随机的基准，则每次迭代需要执行 $\\Theta(m)$ 的工作来选择基准，以及另外 $\\Theta(m)$ 的工作来进行划分，然而整个算法的期望运行时间仍为 $\\Theta(n)$；在这种基准规则下，最坏情况时间仍为 $\\Theta(n^2)$。”\n\n1.  **每次迭代的工作量**：\n    - 问题陈述指明，从大小为 $m$ 的链表中获取一个均匀随机基准需要一次完整扫描，成本为 $\\Theta(m)$。划分大小为 $m$ 的链表需要另一次扫描，成本也为 $\\Theta(m)$。\n    - 因此，在大小为 $m$ 的子链表上进行一次迭代的总工作量是 $\\Theta(m) + \\Theta(m) = \\Theta(m)$。\n\n2.  **期望运行时间**：\n    - 其逻辑与数组的情况相同。每一步的成本为 $C(m) = c'm$，其中 $c'$ 是某个常数。由于基准是均匀随机的，下一个子问题的期望大小仍然是当前大小 $m$ 的一个常数比例 $\\alpha  1$。\n    - 总的期望工作量是一个几何级数的和：$\\sum_{i=0}^{\\infty} C(\\alpha^i n) = \\sum_{i=0}^{\\infty} c' \\alpha^i n = c'n \\sum_{i=0}^{\\infty} \\alpha^i = \\Theta(n)$。\n    - 陈述中的“然而 (yet)”强调了尽管每一步的工作量更高（两次扫描对一次扫描），但整个算法的渐近期望时间复杂度并没有从线性改变。\n\n3.  **最坏情况运行时间**：\n    - 最坏情况仍然对应于一系列最大程度不平衡的划分。递推关系仍为 $T(n) = T(n-1) + \\Theta(n)$，得出 $T(n) = \\Theta(n^2)$。\n\n**结论**：该陈述的所有部分都是正确的。每次迭代工作量的常数因子增加不会改变渐近期望时间复杂度或最坏情况时间复杂度。\n**对 B 的判断**：**正确**。\n\n#### 选项 C 分析\n\n**陈述**：“在单向链表上，如果不分配 $\\Theta(n)$ 的额外内存用于辅助数组，就无法在线性时间内进行划分，因此快速选择算法在链表上必然使用 $\\Theta(n)$ 的额外空间。”\n\n- 该陈述声称对链表进行原地、线性的划分是不可能的。这个前提是错误的，并且与问题自身的已知条件直接矛盾：“在单向链表中，围绕选定的基准进行划分，可以通过一次扫描将节点重新链接到最多三个子链表……而无需分配新节点。”\n- 这种原地划分技术的工作原理是遍历列表，并使用常数个额外指针来管理新子链表（`less`、`equal`、`greater`）的头和尾。原始列表中的每个节点都被分离并附加到相应的子链表中。这需要一次扫描，因此对于大小为 $m$ 的列表，其时间复杂度为 $\\Theta(m)$，并且它使用 $\\Theta(1)$ 的额外空间来存放指针。\n- 由于划分可以用 $\\Theta(1)$ 的额外空间完成，并且整个快速选择算法可以做成迭代式的（如选项 A 中所讨论），所以所需的总额外空间是 $\\Theta(1)$。\n- 因此，快速选择算法“必然使用 $\\Theta(n)$ 额外空间”的结论是不正确的。\n\n**结论**：该陈述基于一个错误的前提。\n**对 C 的判断**：**不正确**。\n\n#### 选项 D 分析\n\n**陈述**：“在单向链表上，确定性地选择头节点作为基准，即使对于对抗性的输入顺序，也能得到 $\\Theta(n)$ 的期望时间，因为头节点对于选择来说与均匀随机的基准一样具有信息量。”\n\n- 一种确定性的基准选择策略，例如“总是选择头节点”，很容易受到对抗性输入的影响。知道该策略的对手可以提供一个导致最坏情况行为的输入。\n- 例如，如果输入列表已经排序（例如，$1, 2, 3, \\ldots, n$），头节点总是最小的元素。围绕头节点进行划分将总是产生一个空子链表和一个大小为 $n-1$ 的子链表。如果我们总是需要递归到较大的子链表中（例如，查找第 $n$ 个元素），那么问题规模在每一步只减少一。这会导致最坏情况下的 $\\Theta(n^2)$ 运行时间。\n- “即使对于对抗性的输入顺序，期望时间也为 $\\Theta(n)$”这个短语是令人困惑的。对于一个固定的确定性算法和一个固定的对抗性输入，运行时间是确定性的，因此没有“期望时间”可计算。运行时间是 $\\Theta(n^2)$。\n- “因为头节点与均匀随机基准一样具有信息量”这个理由在对抗性设置下是不成立的。只有在对所有可能的输入排列求平均时才成立，在这种情况下，头节点确实是集合中的一个随机元素。然而，对手不会提供一个随机的排列。\n\n**结论**：确定性策略对于对抗性输入不具有鲁棒性，其性能可能是 $\\Theta(n^2)$，而不是 $\\Theta(n)$。\n**对 D 的判断**：**不正确**。\n\n#### 选项 E 分析\n\n**陈述**：“使用确定性的“中位数的中位数” (median-of-medians) 基准选择过程，快速选择算法在数组和单向链表上的最坏情况运行时间均为 $\\Theta(n)$；在该策略下，两种表示之间的渐近差异仅在于源于顺序扫描和内存局部性的常数因子。”\n\n1.  **使用“中位数的中位数”的最坏情况时间**：\n    - “中位数的中位数”算法是一种确定性的基准选择方法，它能保证选出一个“好的”基准。它确保基准既不在最小的约 $\\approx 3/10$ 的元素中，也不在最大的约 $\\approx 3/10$ 的元素中。\n    - 这保证了递归子问题的大小最多为 $\\approx \\frac{7}{10}n$。\n    - 时间复杂度的递推关系为 $T(n) \\le T(n/5) + T(7n/10) + \\Theta(n)$，其中 $T(n/5)$ 用于递归地寻找中位数的中位数，$T(7n/10)$ 用于主递归调用，$\\Theta(n)$ 用于划分和寻找小组的中位数。由于 $1/5 + 7/10 = 9/10  1$，该递推关系的解为 $T(n) = \\Theta(n)$。这提供了一个最坏情况线性时间的保证。\n\n2.  **在数组与链表上的实现**：\n    - “中位数的中位数”算法可以在两种数据结构上实现。\n    - **数组**：通过索引算术在概念上进行 5 个元素的分组。寻找中位数和划分都是线性时间的操作。实现很直接。\n    - **单向链表**：这些步骤必须通过顺序遍历来执行。为了找到 5 个元素组的中位数，必须遍历列表。得到的中位数可以收集到一个新的（临时）列表或数组中。然后对这个中位数的集合递归调用该算法。最后，使用选定的基准对原始列表进行划分。所有这些操作（遍历、列表创建、划分）所需的时间都与被处理的元素数量成正比。\n    - 递推关系 $T(n) = T(n/5) + T(7n/10) + \\Theta(n)$ 对链表实现同样成立。因此，在链表上的最坏情况时间也是 $\\Theta(n)$。\n\n3.  **渐近差异**：\n    - 该陈述声称渐近差异仅在于常数因子。这是正确的。虽然链表实现由于指针追踪（内存局部性差）以及可能比优化的数组实现需要更多次的数据扫描而在实践中可能更慢，但这些影响被包含在 $\\Theta(n)$ 符号的常数中。它们不会改变运行时间的渐近增长率。\n\n**结论**：该陈述是正确的。“中位数的中位数”算法在两种数据结构上都实现了最坏情况 $\\Theta(n)$ 的时间，并且性能差异仅限于常数因子。\n**对 E 的判断**：**正确**。\n\n### 正确陈述总结\n\n根据分析，陈述 A、B 和 E 是正确的。", "answer": "$$\\boxed{ABE}$$", "id": "3262375"}, {"introduction": "快速选择算法不仅能找到单个第$k$小的元素，它还是解决更复杂选择任务的强大基础。这个动手编码挑战要求你根据元素的绝对值找出前$k$大的元素，并遵循特定的平局规则。本练习展示了如何利用快速选择算法找到一个关键阈值，然后构建最终解，这是数据分析中的一种常见模式。[@problem_id:3262345]", "problem": "给定一个长度为 $n$ 的有限实数数组 $A$ 和一个整数 $k$，$0 \\leq k \\leq n$。将绝对值函数定义为 $|x|$。目标是使用基于比较的选择过程，找出 $A$ 中绝对值最大的 $k$ 个元素。形式上，任务是计算一个长度为 $k$ 的列表 $L$，其元素来自 $A$，满足以下条件：\n- 对于 $L$ 中的每个元素 $x$ 和 $A \\setminus L$ 中的每个元素 $y$，要么 $|x|  |y|$，要么 $|x| = |y|$ 且根据下述确定性平局打破规则选择 $x$ 而不是 $y$。\n\n为确保多个元素具有相同绝对值时的确定性和可复现性，请应用以下平局打破规则：\n- 主键：按绝对值 $|x|$ 非递增排序。\n- 次键：按实际值 $x$ 非递增排序（因此较大的 $x$ 排在较小的 $x$ 前面；例如，当绝对值相等时，$2$ 排在 $-2$ 前面）。\n- 第三键：按在输入数组 $A$ 中的原始索引 $i$ 递增排序（因此如果绝对值和实际值都相同，则 $A$ 中较早的元素排在较晚的元素前面）。\n\n您必须使用 Quickselect 算法的基本思想来实现选择：围绕一个基准点进行分区，并对其中一侧进行递归。程序不得通过排序整个数组来实现选择；相反，应使用 Quickselect 来确定一个绝对值阈值 $T$，该阈值是多重集 $\\{|A[i]|\\mid 0 \\leq i  n\\}$ 中第 $(n-k)$ 小的元素（顺序统计量使用从 $0$ 开始的索引）。然后，构建前 $k$ 个元素的集合，方法是包含所有 $|x|  T$ 的元素，如果 $|x|  T$ 的元素少于 $k$ 个，则根据平局打破规则额外包含 $|x| = T$ 的元素，直到选出恰好 $k$ 个元素为止。最后，按照上述三级键对所选元素进行排序并输出。\n\n使用的基础理论：\n- 顺序统计量：一个多重集的第 $r$ 个顺序统计量是指如果该多重集被排序，将出现在位置 $r$ 的元素。\n- 基于分区的选择：给定一个基准点，将数组划分为小于、等于和大于该基准点的元素，然后在适当的分区上递归以定位顺序统计量。\n- Quickselect 的期望线性时间：当基准点平均选择得比较均衡时，找到一个顺序统计量的期望比较和交换次数为 $O(n)$。\n\n程序的输入通过内置测试套件隐式提供。请实现该算法并为以下测试用例生成结果：\n- 测试用例 1：$A_1 = [\\,7,-3,2,-9,0,5\\,]$, $k_1 = 3$。\n- 测试用例 2：$A_2 = [\\,1,-1,1,-1,2,-2\\,]$, $k_2 = 4$。\n- 测试用例 3：$A_3 = [\\,\\,]$（空数组），$k_3 = 0$。\n- 测试用例 4：$A_4 = [\\,0,0,0,0\\,]$, $k_4 = 2$。\n- 测试用例 5：$A_5 = [\\,-4,3,-2,1\\,]$, $k_5 = 4$。\n- 测试用例 6：$A_6 = [\\,2.5,-2.5,3.1,-3.1,0.0,3.1\\,]$, $k_6 = 5$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个结果本身就是对应测试用例的列表 $L$，并根据平局打破规则排序。例如，输出格式为 $[L_1,L_2,L_3,L_4,L_5,L_6]$，不含空格，其中每个 $L_i$ 是一个数字列表，如 $[\\,x_1,x_2,\\dots,x_k\\,]$。", "solution": "该问题被评估为有效。它在科学上基于算法领域，特别是基于比较的选择。问题定义明确，目标完全指定，包括保证唯一解的确定性平局打破规则。所有术语都清晰定义，约束条件一致。\n\n解决方案按照问题陈述中指定的过程实现。该方法的核心是在不进行完全排序的情况下，从长度为 $n$ 的数组 $A$ 中找到绝对值最大的 $k$ 个元素。这是通过使用 Quickselect 算法确定一个阈值，然后将元素分为三组：绝对值大于、等于或小于该阈值的元素。最终的 $k$ 个元素列表由这些组构建，并根据一个三级键进行排序。\n\n算法流程如下：\n\n1.  **初始设置和边界情况**：给定一个包含 $n$ 个数字的输入数组 $A$ 和一个整数 $k$，其中 $0 \\leq k \\leq n$。\n    - 如果 $k = 0$ 或 $n = 0$，所需列表为空，因此我们返回一个空列表。\n    - 如果 $k = n$，则选择 $A$ 的所有元素。解决方案是整个数组 $A$，根据指定的三级键进行排序。\n    - 三级排序键定义如下：\n        1.  主键：按绝对值 $|x|$ 非递增排序。\n        2.  次键：按实际值 $x$ 非递增排序。\n        3.  第三键：按原始索引 $i$ 递增排序。\n\n2.  **通过 Quickselect 确定阈值**：对于 $0  k  n$ 的一般情况，我们必须确定一个阈值 $T$。问题规定 $T$ 应该是绝对值多重集 $S = \\{|A[i]| \\mid 0 \\leq i  n\\}$ 中第 $(n-k)$ 小的元素（使用从 $0$ 开始的索引）。\n    - 创建一个辅助数组 `abs_values`，包含 $A$ 中元素的绝对值。\n    - 对该数组应用 Quickselect 算法，以找到如果数组已排序，将位于索引 $n-k$ 处的元素。该算法提供了 $O(n)$ 的期望线性时间复杂度。\n    \n    Quickselect 算法是一种选择算法，用于在未排序的列表中查找第 $i$ 个顺序统计量。其工作原理与 Quicksort 相同：\n    - 选择一个基准元素（此处使用随机基准点以确保良好的平均情况性能）。\n    - 数组被划分为三部分：小于基准点的元素、等于基准点的元素和大于基准点的元素。\n    - 通过将所需索引 $i$ 与分区的大小进行比较，算法会递归到必须包含第 $i$ 个元素的那个分区中，并丢弃其他分区。每一步中问题规模的这种减小导致了 $O(n)$ 的期望时间。我们的实现使用了 Lomuto 分区方案。\n\n3.  **元素收集**：一旦阈值 $T$ 被确定，就遍历原始数组 $A$ 来构建前 $k$ 个元素的列表。创建两个临时列表：`greater_elements` 和 `equal_elements`。\n    - 对于每个具有原始索引 $i$ 的元素 $A[i]$：\n        - 如果 $|A[i]| > T$，则将该元素（连同其索引）添加到 `greater_elements`。\n        - 如果 $|A[i]| = T$，则将该元素（及其索引）添加到 `equal_elements`。\n        - $|A[i]|  T$ 的元素被忽略。\n\n4.  **最终列表组装与排序**：构建最终结果列表 $L$。\n    - 列表 `L` 最初包含 `greater_elements` 中的所有元素。\n    - 计算还需要选取的元素数量为 $m = k - \\text{length}(\\text{greater\\_elements})$。\n    - 如果 $m > 0$，我们必须从 `equal_elements` 中选择 $m$ 个元素。为确定性地执行此操作，`equal_elements` 根据次键和第三键进行排序：即实际值 $x$ 非递增和原始索引 $i$ 递增。然后将此排序列表中的前 $m$ 个元素附加到 $L$ 中。\n    - 最后，根据完整的三级平局打破规则（$|x|$ 非递增，$x$ 非递增，$i$ 递增）对包含恰好 $k$ 个元素的完整列表 $L$ 进行排序。然后提取数值以形成给定测试用例的最终输出列表。\n\n这个多阶段过程正确地实现了问题陈述的所有要求，确保了正确性、确定性以及对指定算法方法的遵守。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport random\n\ndef _partition(arr, l, r):\n    \"\"\"\n    Lomuto partition scheme for Quickselect.\n    A random pivot is chosen to ensure average-case O(n) performance.\n    \"\"\"\n    pivot_idx = random.randint(l, r)\n    arr[pivot_idx], arr[r] = arr[r], arr[pivot_idx]\n    pivot = arr[r]\n    i = l - 1\n    for j in range(l, r):\n        if arr[j] = pivot:\n            i += 1\n            arr[i], arr[j] = arr[j], arr[i]\n    arr[i + 1], arr[r] = arr[r], arr[i + 1]\n    return i + 1\n\ndef _quickselect(arr, l, r, k):\n    \"\"\"\n    Recursively finds the k-th smallest element in arr[l..r] (0-indexed).\n    \"\"\"\n    if l = r:\n        pivot_index = _partition(arr, l, r)\n        if pivot_index == k:\n            return arr[k]\n        elif k  pivot_index:\n            return _quickselect(arr, l, pivot_index - 1, k)\n        else:\n            return _quickselect(arr, pivot_index + 1, r, k)\n\ndef find_top_k(A, k):\n    \"\"\"\n    Finds the k elements of A with the largest absolute values.\n    \"\"\"\n    n = len(A)\n    # Handle edge cases where k=0 or the array is empty.\n    if k == 0 or n == 0:\n        return []\n\n    # Handle the edge case where k=n. All elements are selected and sorted.\n    if k == n:\n        # Create tuples of (value, index) for sorting\n        indexed_A = list(zip(A, range(n)))\n        # Sort using the three-level key by providing a tuple for comparison.\n        # Python's tuple sort works element by element, achieving the desired key hierarchy.\n        # Key: (-abs(value), -value, index)\n        indexed_A.sort(key=lambda item: (-abs(item[0]), -item[0], item[1]))\n        return [item[0] for item in indexed_A]\n\n    # General case: 0  k  n\n    # As per the problem, find the (n-k)-th smallest absolute value threshold.\n    abs_values = np.abs(np.array(A, dtype=float)).tolist()\n    threshold_index = n - k\n    T = _quickselect(abs_values, 0, n - 1, threshold_index)\n\n    # Collect elements into 'greater' and 'equal' lists based on the threshold T.\n    greater_elements = []\n    equal_elements = []\n    for i, val in enumerate(A):\n        abs_val = abs(val)\n        if abs_val  T:\n            greater_elements.append((val, i))\n        elif abs_val == T:\n            equal_elements.append((val, i))\n\n    # Determine how many elements are needed from the 'equal' group.\n    num_needed_from_equal = k - len(greater_elements)\n    \n    # Sort 'equal_elements' by the secondary and tertiary keys to break ties.\n    # Key: (-value, index)\n    equal_elements.sort(key=lambda item: (-item[0], item[1]))\n    \n    # Construct the result set of (value, index) tuples.\n    result_tuples = greater_elements + equal_elements[:num_needed_from_equal]\n    \n    # Sort the final result set using the full three-level key.\n    # Key: (-abs(value), -value, index)\n    result_tuples.sort(key=lambda item: (-abs(item[0]), -item[0], item[1]))\n    \n    return [item[0] for item in result_tuples]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        ([7, -3, 2, -9, 0, 5], 3),\n        ([1, -1, 1, -1, 2, -2], 4),\n        ([], 0),\n        ([0, 0, 0, 0], 2),\n        ([-4, 3, -2, 1], 4),\n        ([2.5, -2.5, 3.1, -3.1, 0.0, 3.1], 5)\n    ]\n\n    results = []\n    for A, k in test_cases:\n        result = find_top_k(A, k)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # Example format: [[-9,7,5],[2,-2,1,1]]\n    formatted_results = [repr(res).replace(\" \", \"\") for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3262345"}]}