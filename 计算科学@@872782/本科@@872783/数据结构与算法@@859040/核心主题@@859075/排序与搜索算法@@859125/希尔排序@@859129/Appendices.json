{"hands_on_practices": [{"introduction": "希尔排序的效率在很大程度上取决于其间隙序列的选择。不同的间隙序列会导致截然不同的性能表现。这项实践练习旨在通过亲手实现和测量，让你直观地感受到两种著名的间隙序列——Ciura 序列和 Donald Knuth 序列——在处理特定类型数据（逆序数组）时的性能差异，从而加深对间隙序列重要性的理解 [@problem_id:3270119]。", "problem": "您需要实现一个完整的程序，使用两种不同的间隙序列来测量希尔排序在逆序数组上的操作计数。目标是比较 Ciura 间隙序列和 Donald Knuth 间隙序列在元素比较次数与数据移动次数上的差异，并汇总不同数组大小下的结果。\n\n从数据结构和算法的以下基本概念开始：希尔排序是插入排序的一种泛化，它通过使用一个间隙序列，先对相距较远的元素进行排序，然后逐步将间隙减小到 $1$，从而提高性能。对于任何固定的间隙 $h$，该算法对由相隔 $h$ 的索引处的元素组成的子序列执行插入排序。插入排序的正确性依赖于其循环不变量：在将一个选定的元素（“键”）插入到左侧部分之前，该部分已经是有序的，并且插入操作会保持有序性。通过将插入排序应用于 $h$ 间距的子序列，这一观察结果可以推广到希尔排序。\n\n所使用的定义如下：\n- 长度为 $n$ 的逆序数组是指当 $n \\ge 1$ 时的数组 $[n,n-1,\\dots,2,1]$，以及当 $n=0$ 时的空数组。\n- 键值比较是指每次对两个数组元素进行比较时计数，特指在 $h$-插入过程中计算谓词 $A[j-h]  \\text{temp}$ 的次数。只计算元素与元素之间的比较；不计算索引边界检查，如 $j \\ge h$。\n- 数据移动是指对数组索引的一次写入操作。这包括每次移位 $A[j] \\leftarrow A[j-h]$ 以及每次插入时的最终放置 $A[j] \\leftarrow \\text{temp}$。即使没有发生移位，元素被写回其原始位置，该写入操作也计为一次数据移动。\n- Ciura 的间隙序列由基础列表 $\\{1,4,10,23,57,132,301,701\\}$ 定义，对于更大的 $n$，通过 $h_{\\text{next}}=\\left\\lfloor 2.25 \\cdot h \\right\\rfloor$ 进行乘法扩展，直到超过 $n$ 为止，然后按降序使用所有 $h \\le n$ 的间隙。\n- Donald Knuth 的间隙序列由 $h_0=1$ 和 $h_{k+1}=3h_k+1$ 定义，枚举直到超过 $n$，然后按降序使用所有 $h \\le n$ 的间隙。\n\n实现带有计数功能的希尔排序，用于统计上述定义的比较次数和数据移动次数。将其应用于以下大小的逆序数组：\n- $n \\in \\{0,1,8,23,100,1000\\}$。\n\n对于每个数组大小 $n$，计算以下七个整数：\n- $n$，\n- $C_{\\text{Ciura}}$，使用 Ciura 序列的比较次数，\n- $M_{\\text{Ciura}}$，使用 Ciura 序列的数据移动次数，\n- $C_{\\text{Knuth}}$，使用 Knuth 序列的比较次数，\n- $M_{\\text{Knuth}}$，使用 Knuth 序列的数据移动次数，\n- $\\Delta C = C_{\\text{Ciura}} - C_{\\text{Knuth}}$，\n- $\\Delta M = M_{\\text{Ciura}} - M_{\\text{Knuth}}$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表。此顶层列表中的每个条目对应一个测试用例，并且其本身必须是按上述确切顺序排列的七个整数的列表。例如，输出格式为\n$[[n_1,C_{\\text{Ciura},1},M_{\\text{Ciura},1},C_{\\text{Knuth},1},M_{\\text{Knuth},1},\\Delta C_1,\\Delta M_1],\\dots,[n_k,C_{\\text{Ciura},k},M_{\\text{Ciura},k},C_{\\text{Knuth},k},M_{\\text{Knuth},k},\\Delta C_k,\\Delta M_k]]$，\n整行中任何位置都不能有空格。", "solution": "用户提供的问题经评估有效。这是一个在算法分析领域内定义明确、有科学依据且客观的任务。其定义、约束和目标清晰明确，足以产生一个唯一的、可计算的解决方案。\n\n该问题要求实现带有计数功能的希尔排序算法，以统计键值比较和数据移动的次数。然后，将此实现应用于指定大小的逆序数组，并使用两种不同的间隙序列：一种由 Ciura 提出，另一种由 Donald Knuth 提出。最后对结果进行汇总和格式化。\n\n解决方案的结构如下：\n$1$. 实现带有计数功能的希尔排序算法。\n$2$. 实现指定间隙序列的生成逻辑。\n$3$. 对每个测试用例执行算法并整理结果。\n\n**$1$. 带有计数功能的希尔排序算法**\n\n希尔排序算法通过执行一系列带间隙的插入排序来对大小为 $n$ 的数组 $A$ 进行排序。对于一个按降序使用的给定间隙序列 $h_k, h_{k-1}, \\dots, h_1=1$，该算法会遍历每个间隙 $h$。对于每个 $h$，它实际上对 $h$ 个独立的子序列执行插入排序。这些子序列的元素位于索引 $(i, i+h, i+2h, \\dots)$ 处，起始位置为 $i \\in \\{0, 1, \\dots, h-1\\}$。\n\n算法的核心是 $h$-排序遍。对于每个 $i \\ge h$ 的元素 $A[i]$，我们将其视为一个键，插入到其前面以 $h$ 为间隔的已排序子序列中。\n\n设 $A$ 为大小为 $n$ 的数组。设 `gaps` 为按降序排列的间隙列表。过程如下：\n对于 `gaps` 中的每个间隙 $h$：\n  对于从 $h$ 到 $n-1$ 的每个索引 $i$：\n    $1$. 存储待插入的元素：$\\text{temp} \\leftarrow A[i]$。\n    $2$. 初始化插入索引：$j \\leftarrow i$。\n    $3$. 将比 `temp` 大的元素向右移动 $h$ 个位置。当 $j \\ge h$ 且 $A[j-h]  \\text{temp}$ 时：\n       - 比较 $A[j-h]  \\text{temp}$ 被计数。设总比较次数为 $C$。每次评估此谓词时，我们递增 $C$。\n       - 移位操作 $A[j] \\leftarrow A[j-h]$ 是一次数据移动。设总移动次数为 $M$。每次这样的赋值都会递增 $M$。\n       - 移动到下一个插入位置：$j \\leftarrow j - h$。\n    $4$. 循环结束后，如果发生了另一次比较导致循环终止（即 $A[j-h] \\le \\text{temp}$），该比较也应被计数。\n    $5$. 将 `temp` 元素放置在其正确的排序位置：$A[j] \\leftarrow \\text{temp}$。这是当前插入的最后一次数据移动，因此 $M$ 递增。\n\n计数过程如下：\n- **比较次数 ($C$)**：每次评估谓词 $A[j-h]  \\text{temp}$ 时递增。\n- **数据移动次数 ($M$)**：每次对数组进行写入时递增，包括每次移位 $A[j] \\leftarrow A[j-h]$ 和最终放置 $A[j] \\leftarrow \\text{temp}$。\n\n为两种间隙序列中的每一种都创建一个初始逆序数组的副本，以确保两种排序过程都在相同的初始数据上操作。\n\n**$2$. 间隙序列的生成**\n\n指定了两种间隙序列：\n\n**Ciura 的间隙序列**：\n该序列基于实验数据。基础序列为 $\\{1, 4, 10, 23, 57, 132, 301, 701\\}$。对于大小为 $n$ 的数组，该序列进行乘法扩展。生成过程是取最后一个生成的间隙 $h_k$，并计算下一个间隙为 $h_{k+1} = \\lfloor 2.25 \\cdot h_k \\rfloor$。此扩展一直持续到生成的间隙超过 $n$。最终使用的序列由所有小于或等于 $n$ 的已生成间隙组成，并按降序排列。\n\n对于给定的 $n$，过程如下：\n$1$. 用基础值初始化一个间隙列表：`gaps` $\\leftarrow \\{1, 4, 10, 23, 57, 132, 301, 701\\}$。\n$2$. 设 $h$ 为 `gaps` 中的最大值。\n$3$. 当 $h \\le n$ 时，计算 $\\text{next\\_h} \\leftarrow \\lfloor 2.25 \\cdot h \\rfloor$。如果 $\\text{next\\_h}  h$，则将其附加到 `gaps` 中并更新 $h \\leftarrow \\text{next\\_h}$。否则，停止扩展。\n$4$. 筛选生成的列表，只保留 $g \\le n$ 的间隙。\n$5$. 返回按降序排序的筛选后列表。\n\n**Donald Knuth 的间隙序列**：\n该序列由递推关系 $h_{k+1} = 3h_k + 1$ 定义，其中 $h_0 = 1$。序列生成至第一个超过数组大小 $n$ 的值（但不包括该值）。该序列为 $\\{1, 4, 13, 40, 121, 364, \\dots\\}$。\n\n对于给定的 $n$，过程如下：\n$1$. 初始化 `gaps` $\\leftarrow []$ 和 $h \\leftarrow 1$。\n$2$. 当 $h \\le n$ 时，将 $h$ 附加到 `gaps` 中并更新 $h \\leftarrow 3h+1$。\n$3$. 返回按降序排序的 `gaps`。\n\n**$3$. 实验执行与输出**\n\n程序对每个数组大小 $n \\in \\{0, 1, 8, 23, 100, 1000\\}$ 执行带有计数功能的希尔排序。对于每个 $n$：\n$1$. 创建一个逆序数组 $A = [n, n-1, \\dots, 1]$。对于 $n=0$，$A$ 为空。\n$2$. 为大小 $n$ 生成 Ciura 和 Knuth 的间隙序列。\n$3$. 对 $A$ 的一个副本运行两次带有计数功能的排序：一次使用 Ciura 间隙以获得 $C_{\\text{Ciura}}$ 和 $M_{\\text{Ciura}}$，另一次使用 Knuth 间隙以获得 $C_{\\text{Knuth}}$ 和 $M_{\\text{Knuth}}$。\n$4$. 计算差值 $\\Delta C = C_{\\text{Ciura}} - C_{\\text{Knuth}}$ 和 $\\Delta M = M_{\\text{Ciura}} - M_{\\text{Knuth}}$。\n$5$. 存储七个结果整数（$n, C_{\\text{Ciura}}, M_{\\text{Ciura}}, C_{\\text{Knuth}}, M_{\\text{Knuth}}, \\Delta C, \\Delta M$）。\n\n最后，按照问题陈述的要求，将所有结果格式化为表示列表的列表的单个字符串。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef generate_ciura_gaps(n: int) -> list[int]:\n    \"\"\"\n    Generates Ciura's gap sequence for a given array size n.\n    The sequence is based on {1, 4, 10, 23, 57, 132, 301, 701} and is\n    extended by h_next = floor(2.25 * h) until exceeding n.\n    Gaps used are = n, in descending order.\n    \"\"\"\n    if n == 0:\n        return []\n        \n    gaps = [1, 4, 10, 23, 57, 132, 301, 701]\n    \n    # Extend the sequence if n is larger than the largest base gap\n    if n > gaps[-1]:\n        h = gaps[-1]\n        while True:\n            # According to the rule \"extended ... until exceeding n\", a gap > n stops generation.\n            next_h = int(h * 2.25)\n            if next_h > n:\n                break\n            # Ensure progress and avoid duplicates\n            if next_h > h:\n                gaps.append(next_h)\n                h = next_h\n            else:\n                break\n    \n    # Per rule \"used in descending order with all h = n\"\n    usable_gaps = [g for g in gaps if g = n]\n    return sorted(usable_gaps, reverse=True)\n\ndef generate_knuth_gaps(n: int) -> list[int]:\n    \"\"\"\n    Generates Donald Knuth's gap sequence (3h+1) for a given array size n.\n    The sequence is enumerated until exceeding n and used in descending order.\n    \"\"\"\n    if n == 0:\n        return []\n\n    gaps = []\n    h = 1\n    while h = n:\n        gaps.append(h)\n        h = 3 * h + 1\n    return sorted(gaps, reverse=True)\n\ndef shell_sort_instrumented(arr: np.ndarray, gaps: list[int]) -> tuple[int, int]:\n    \"\"\"\n    Performs Shell sort on a copy of the array with the given gap sequence.\n    Returns the count of key comparisons and data movements.\n    \"\"\"\n    A = arr.copy()\n    n = len(A)\n    comparisons = 0\n    movements = 0\n\n    if n  2:\n        return 0, 0\n\n    for h in gaps:\n        for i in range(h, n):\n            temp = A[i]\n            j = i\n            # The following loop performs the gapped insertion\n            while j >= h:\n                comparisons += 1\n                if A[j - h] > temp:\n                    A[j] = A[j - h]\n                    movements += 1\n                    j -= h\n                else:\n                    break\n            \n            # Final placement of the temp element. Per the problem, this is always\n            # counted as one data movement (a write operation).\n            A[j] = temp\n            movements += 1\n\n    return comparisons, movements\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation and print the results in the required format.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases_n = [0, 1, 8, 23, 100, 1000]\n\n    all_results = []\n    \n    for n in test_cases_n:\n        if n == 0:\n            all_results.append([0, 0, 0, 0, 0, 0, 0])\n            continue\n\n        # Create the reverse-sorted array\n        array = np.arange(n, 0, -1, dtype=int)\n\n        # Generate gap sequences\n        gaps_ciura = generate_ciura_gaps(n)\n        gaps_knuth = generate_knuth_gaps(n)\n\n        # Run with Ciura's sequence\n        C_ciura, M_ciura = shell_sort_instrumented(array, gaps_ciura)\n\n        # Run with Knuth's sequence\n        C_knuth, M_knuth = shell_sort_instrumented(array, gaps_knuth)\n\n        # Calculate deltas\n        delta_C = C_ciura - C_knuth\n        delta_M = M_ciura - M_knuth\n\n        result_case = [n, C_ciura, M_ciura, C_knuth, M_knuth, delta_C, delta_M]\n        all_results.append(result_case)\n\n    # Format the final output string exactly as required\n    string_cases = [f\"[{','.join(map(str, case))}]\" for case in all_results]\n    final_output = f\"[{','.join(string_cases)}]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n```", "id": "3270119"}, {"introduction": "标准的希尔排序依赖于预先定义好的固定间隙序列。然而，我们能否设计一种更“智能”的排序，使其能够根据数组当前的有序程度动态调整其策略？这个练习将引导你实现一个自适应希尔排序，其中下一个间隙的选择取决于当前一轮排序的“工作量”（即元素交换次数），这不仅能锻炼你的编程能力，还能让你深入探索算法行为与输入数据之间的动态关系 [@problem_id:3270048]。", "problem": "给定一个输入的整数列表，设计并实现一种基于希尔排序的、基于比较的排序算法，该算法根据每轮测量的工作量来调整其间隙序列。仅使用公认的原则作为基础：基于比较的排序的定义、插入排序的定义和不变量，以及希尔排序作为在一系列递减间隙下对交错子序列进行插入排序的定义。根据下述规则，该算法必须是完全确定性的。\n\n基础原理：\n- 基于比较的排序算法通过成对比较和重新排列来确定顺序。特别地，间隙为 $g$ 的插入排序维护这样一个不变量：在处理完索引 $i$ 后，所有满足 $k \\le i$ 且与 $i \\mod g$ 同余的位置 $k$ 之间是已排序的。\n- 希尔排序通过使用间隙 $g_0, g_1, \\ldots, g_T$（其中 $g_T = 1$）进行多轮排序来推广插入排序，使得在最后一轮排序后，列表按升序排列。\n\n自适应间隙规则规范：\n- 设 $n$ 为列表长度，定义初始间隙为 $g_0 = \\lfloor n / 2 \\rfloor$。\n- 在间隙为 $g_t$ 的第 $t$ 轮中，将 $s_t$ 定义为带间隙的插入排序在整个列表上对索引为 $j$ 和 $j - g_t$ 的元素执行的成对交换总次数。通过在将一个键向左移动时重复交换距离为 $g_t$ 的相邻元素，直到局部不变量成立，来实现插入过程，并将每次这样的相邻交换计为一次交换。\n- 定义每个插入位置的平均交换次数 $$a_t = \\begin{cases} \\dfrac{s_t}{n - g_t}  \\text{if } n - g_t  0, \\\\ 0  \\text{if } n - g_t = 0. \\end{cases}$$\n- 通过以下自适应规则选择下一个间隙 $g_{t+1}$：\n$$\ng_{t+1} = \\begin{cases}\n0  \\text{if } g_t = 1 \\text{ (此轮后终止)}, \\\\\n\\max\\!\\left(1, \\left\\lfloor \\dfrac{g_t}{4} \\right\\rfloor\\right)  \\text{if } s_t = 0, \\\\\n\\max\\!\\left(1, \\left\\lfloor \\dfrac{g_t}{3} \\right\\rfloor\\right)  \\text{if } 0  a_t  1, \\\\\n\\max\\!\\left(1, \\left\\lfloor \\dfrac{g_t}{2} \\right\\rfloor\\right)  \\text{if } a_t \\ge 1.\n\\end{cases}\n$$\n当所需工作量较少（交换次数少）时，此规则更积极地缩减间隙；当所需工作量较多（交换次数多）时，则更保守地缩减间隙，从而确保间隙单调递减至 $g=1$ 并最终终止。\n\n任务：\n- 实现上述自适应希尔排序，按升序对列表进行排序。\n- 对于每个输入列表，输出一个列表，其中包含已排序的列表、所有轮次的总交换次数以及执行的总轮次数（即所使用的不同间隙值的数量，适用时包括间隙 $g=1$ 的最后一轮）。\n- 该算法不得依赖任何外部随机性，并且相对于指定的通过相邻交换进行带间隙插入的机制，该算法必须是确定的。\n\n测试套件：\n使用以下列表作为输入测试用例。每个列表都是一个有序的整数列表，应完全按原样处理。\n- 用例 $1$：$[9,8,3,7,5,6,4,1,2]$。\n- 用例 $2$：$[1,2,3,4,5,6,7,8,9]$。\n- 用例 $3$：$[9,8,7,6,5,4,3,2,1]$。\n- 用例 $4$：$[5,3,5,2,5,1,5]$。\n- 用例 $5$：$[42]$。\n- 用例 $6$：$[]$。\n- 用例 $7$：$[-3,1,-2,4,0]$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。每个结果都必须是 $[\\text{sorted\\_list}, \\text{total\\_swaps}, \\text{total\\_passes}]$ 形式的列表。例如，整个输出看起来应像 $[[\\cdots], [\\cdots], \\ldots]$，位于单行上，无附加文本。", "solution": "用户希望实现一种基于希尔排序的、基于比较的排序算法，该算法根据每轮测量的工作量来调整其间隙序列。仅使用公认的原则作为基础：基于比较的排序的定义、插入排序的定义和不变量，以及希尔排序作为在一系列递减间隙下对交错子序列进行插入排序的定义。根据下述规则，该算法必须是完全确定性的。\n\n### 步骤 1：提取已知信息\n- **算法**：自适应希尔排序。\n- **基础**：基于比较的排序、插入排序、希尔排序。\n- **排序顺序**：升序。\n- **初始间隙**：$g_0 = \\lfloor n / 2 \\rfloor$，其中 $n$ 是列表长度。\n- **工作量度量**：$s_t$ 是第 $t$ 轮中间隙为 $g_t$ 的成对交换（交换）总次数。\n- **平均交换次数**：如果 $n - g_t  0$，则 $a_t = \\frac{s_t}{n - g_t}$，否则 $a_t = 0$。\n- **间隙更新规则**：\n$$\ng_{t+1} = \\begin{cases}\n0  \\text{if } g_t = 1 \\text{ (终止)}, \\\\\n\\max\\!\\left(1, \\left\\lfloor \\frac{g_t}{4} \\right\\rfloor\\right)  \\text{if } s_t = 0, \\\\\n\\max\\!\\left(1, \\left\\lfloor \\frac{g_t}{3} \\right\\rfloor\\right)  \\text{if } 0  a_t  1, \\\\\n\\max\\!\\left(1, \\left\\lfloor \\frac{g_t}{2} \\right\\rfloor\\right)  \\text{if } a_t \\ge 1.\n\\end{cases}\n$$\n- **输出**：对于每个输入列表，输出一个结果列表 `[sorted_list, total_swaps, total_passes]`。\n- **测试用例**：`[9,8,3,7,5,6,4,1,2]`、`[1,2,3,4,5,6,7,8,9]`、`[9,8,7,6,5,4,3,2,1]`、`[5,3,5,2,5,1,5]`、`[42]`、`[]`、`[-3,1,-2,4,0]`。\n\n### 步骤 2：使用提取的已知信息进行验证\n- **科学依据**：该问题基于计算机科学中标准的、定义明确的算法（希尔排序、插入排序）。自适应规则是一项新颖的修改，但在数学和逻辑上是合理的。该问题有效。\n- **适定性**：该问题是适定的。初始状态是输入列表。操作是确定性的，并且间隙序列保证（对于 $g_t  1$）单调递减并达到 $1$，从而确保终止。对于任何输入都存在唯一解。\n- **客观性**：该问题使用精确、无歧义的术语和形式化定义进行陈述。不存在主观因素。\n\n### 步骤 3：结论与行动\n问题有效。将提供完整的解决方案。\n\n自适应希尔排序算法的设计基于比较排序的基本原理。该算法推广了插入排序，后者通过迭代构建列表的已排序前缀来工作。插入排序的核心不变量是，在每一步 $i$ 中，从索引 $0$ 到 $i$ 的子列表都是已排序的。希尔排序对此进行了改进，首先对相距较远的元素进行排序，然后逐渐减小被比较和交换的元素之间的间隙。这等同于对多个交错的子列表执行插入排序。一个间隙为 $g$ 的轮次涉及对由索引为 $k, k+g, k+2g, \\ldots$（其中 $k \\in \\{0, 1, \\ldots, g-1\\}$）的元素形成的 $g$ 个子列表中的每一个执行独立的插入排序。\n\n该算法的结构分为一个主函数 `adaptive_shell_sort`，用于协调排序过程，以及一个辅助函数 `gapped_insertion_sort`，用于执行给定间隙的单轮排序。\n\n主函数 `adaptive_shell_sort` 将总交换次数 $s_{total}$ 和总轮次数 $p_{total}$ 初始化为 $0$。它处理列表长度 $n$ 小于或等于 $1$ 的平凡边界情况，此时列表已经排序，返回 $0$ 次交换和 $0$ 轮。对于非平凡情况，它计算初始间隙 $g_0 = \\lfloor n/2 \\rfloor$。排序在一个循环中进行，只要当前间隙 $g_t  0$ 就继续。\n\n在循环内部，执行单轮排序：\n$1$. 轮次计数器 $p_{total}$ 递增。\n$2$. 使用当前列表和间隙 $g_t$ 调用辅助函数 `gapped_insertion_sort`。此函数对交错的子列表进行原地排序，并返回执行的交换次数 $s_t$。\n$3$. 将该轮的交换次数 $s_t$ 加到总交换次数 $s_{total}$ 中。\n$4$. 根据指定的自适应规则计算下一个间隙 $g_{t+1}$。首先，检查终止条件：如果 $g_t = 1$，则列表现已完全排序，因此将下一个间隙设置为 $0$ 以退出循环。否则，根据当前轮次完成的工作量（由 $s_t$ 衡量）来确定 $g_{t+1}$。\n    - 如果 $s_t = 0$，则列表已经是 $g_t$-有序的，表明有序度很高。间隙被积极地减小：$g_{t+1} = \\max(1, \\lfloor g_t/4 \\rfloor)$。\n    - 如果 $s_t  0$，则计算每个插入元素的平均交换次数 $a_t = s_t / (n - g_t)$。分母 $n - g_t$ 表示在带间隙插入排序期间可能被移动的元素数量（索引为 $g_t, \\ldots, n-1$ 的元素）。\n    - 如果 $0  a_t  1$，则表示完成了中等量的工作。间隙按 $g_{t+1} = \\max(1, \\lfloor g_t/3 \\rfloor)$ 减小。\n    - 如果 $a_t \\ge 1$，则表示完成了大量工作，表明列表相对于该间隙是高度无序的。间隙被保守地减小，以便在下一轮中进行更多比较：$g_{t+1} = \\max(1, \\lfloor g_t/2 \\rfloor)$。\n使用 $\\max(1, \\ldots)$ 确保间隙不会过早变为 $0$，并且最后一轮总是在 $g=1$ 时进行。\n\n辅助函数 `gapped_insertion_sort(arr, gap)` 实现一轮排序。它从索引 $i = \\text{gap}$ 到 $n-1$ 遍历列表。对于每个元素 `arr[i]`，它被插入到其交错子列表中的正确位置。问题指定此插入必须通过“重复交换距离为 $g_t$ 的相邻元素”来执行。这是通过一个内部循环实现的，该循环比较 `arr[j]` 和 `arr[j - gap]`，如果它们顺序不正确就交换它们，并将 $j$ 减去 `gap`，直到元素处于其排序位置。每次这样的交换都被计数，并返回总数。\n\n整个过程是确定性的并且会终止，因为对于 $g_t  1$，间隙序列是严格递减的，并以下界 $1$ 为界，最终达到 $1$，然后是 $0$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef gapped_insertion_sort(arr, gap):\n    \"\"\"\n    Performs a gapped insertion sort on the list `arr` for a given `gap`.\n    The list is modified in-place.\n    Returns the total number of swaps performed.\n    \"\"\"\n    n = len(arr)\n    swaps = 0\n    # Iterate through the elements starting from the first element of the second sub-sequence\n    for i in range(gap, n):\n        # Perform insertion sort for the element at index i into its sub-array.\n        # This is done by repeatedly swapping with the element `gap` positions before it.\n        j = i\n        while j >= gap and arr[j - gap] > arr[j]:\n            arr[j], arr[j - gap] = arr[j - gap], arr[j]\n            swaps += 1\n            j -= gap\n    return swaps\n\ndef adaptive_shell_sort(arr):\n    \"\"\"\n    Sorts a list of integers using an adaptive Shell Sort algorithm.\n    Returns the sorted list, total swaps, and total passes.\n    \"\"\"\n    n = len(arr)\n    if n = 1:\n        return arr, 0, 0\n\n    total_swaps = 0\n    total_passes = 0\n    current_gap = n // 2\n\n    while current_gap > 0:\n        total_passes += 1\n        \n        pass_swaps = gapped_insertion_sort(arr, current_gap)\n        total_swaps += pass_swaps\n\n        if current_gap == 1:\n            current_gap = 0  # Terminate after this pass\n        else:\n            s_t = pass_swaps\n            if s_t == 0:\n                current_gap = max(1, current_gap // 4)\n            else:\n                # The problem asks to calculate a_t if n - current_gap > 0\n                # In this loop, since n > 1 and current_gap starts at n // 2 and decreases,\n                # n - current_gap will always be > 0.\n                a_t = s_t / (n - current_gap)\n                if 0  a_t  1:\n                    current_gap = max(1, current_gap // 3)\n                else:  # a_t >= 1\n                    current_gap = max(1, current_gap // 2)\n    \n    return arr, total_swaps, total_passes\n\ndef solve():\n    \"\"\"\n    Main function to run the algorithm on test cases and print the output.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        [9, 8, 3, 7, 5, 6, 4, 1, 2],\n        [1, 2, 3, 4, 5, 6, 7, 8, 9],\n        [9, 8, 7, 6, 5, 4, 3, 2, 1],\n        [5, 3, 5, 2, 5, 1, 5],\n        [42],\n        [],\n        [-3, 1, -2, 4, 0],\n    ]\n\n    results = []\n    for case in test_cases:\n        # Pass a copy of the list to the sorting function to avoid mutation\n        arr_copy = list(case)\n        sorted_list, total_swaps, total_passes = adaptive_shell_sort(arr_copy)\n        results.append([sorted_list, total_swaps, total_passes])\n\n    # Format the final output string to match the required format exactly\n    # e.g., [[sorted_list, swaps, passes], ...]\n    formatted_results = []\n    for res in results:\n        sorted_list, total_swaps, total_passes = res\n        list_str = f\"[{','.join(map(str, sorted_list))}]\"\n        res_str = f\"[{list_str},{total_swaps},{total_passes}]\"\n        formatted_results.append(res_str)\n    \n    final_output_string = f\"[{','.join(formatted_results)}]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output_string)\n\nsolve()\n```", "id": "3270048"}, {"introduction": "在评估算法时，我们通常关注其时间复杂度，但空间复杂度同样是衡量其效率的关键维度。这项练习将挑战你分析一个非标准的、递归版本的希尔排序算法所占用的辅助空间。通过精确推导其在最坏情况下的内存使用量，包括临时数组开销和递归调用栈的深度影响，你将对算法的资源消耗有更深刻的认识 [@problem_id:3270034]。", "problem": "给定一个非原地（non-in-place）、递归版本的希尔排序（Shell Sort），其定义如下。设输入为一个长度为 $n$ 的数组，其中 $n$ 是 $2$ 的幂，即 $n = 2^{m}$，对于某个整数 $m \\geq 0$。步长序列固定为 $g_{0} = g_{1} = \\dots = g_{m-1} = 2$ 和 $g_{m} = 1$。算法 RecShell 对长度为 $\\ell$ 的子数组进行如下操作：\n\n1. 如果 $\\ell = 1$，立即返回（基本情况）。\n2. 否则，通过将当前子数组划分为模 $2$ 的两个剩余类，来分配 $g=2$ 个总长度等于 $\\ell$ 的临时数组 $T_{0}$ 和 $T_{1}$（即，$T_{0}$ 接收当前子数组中所有位于偶数索引的元素，$T_{1}$ 接收所有位于奇数索引的元素）。在处理此层级期间，所有 $T_{r}$ 都保持已分配状态。\n3. 对其中一个 $T_{r}$（例如 $T_{0}$）递归调用 RecShell，然后对另一个 $T_{r}$（例如 $T_{1}$）递归调用 RecShell，每次都使用相同的步长策略，但此时使用当前 $T_{r}$ 的长度作为新的 $\\ell$。\n4. 两次递归调用都返回后，将 $T_{0}$ 和 $T_{1}$ 中的元素写回到父子数组中的相应位置，并释放 $T_{0}$ 和 $T_{1}$。\n\n假设递归调用的遍历顺序为深度优先，因此在任何时候都只有一个活动的递归分支，并且在祖先层级分配的所有临时数组都会保持已分配状态，直到递归回溯经过该层级。以“数组元素等效单位”来衡量辅助空间：每个已分配的临时数组单元计为 $1$ 个单位。为了考虑调用堆栈的影响，假设每个激活记录（栈帧）消耗 $\\sigma$ 个数组元素等效单位；也就是说，如果最大并发调用堆栈深度为 $d$，则堆栈消耗 $d \\sigma$ 个数组元素等效单位。\n\n仅使用上述定义和以下事实：(i) 递归消耗一个后进先出（LIFO）的调用堆栈，其最大并发深度等于递归调用的最大嵌套深度，以及 (ii) 在每个非基本情况的层级，两个临时数组 $T_{0}$ 和 $T_{1}$ 合起来正好包含当前子数组的所有 $\\ell$ 个元素，推导出一个关于 $n$ 和 $\\sigma$ 的精确、封闭形式的表达式，用于表示在对长度为 $n$ 的输入执行 RecShell 期间任意时刻所使用的最大并发辅助空间（以数组元素等效单位计）。\n\n你的最终答案必须是关于 $n$ 和 $\\sigma$ 的单个封闭形式解析表达式（没有不等式，没有大O表示法，没有额外的文字说明）。不要四舍五-入。明确写出任何对数的底数。", "solution": "用户希望找到递归算法 `RecShell` 在大小为 $n$ 的输入上使用的最大并发辅助空间，其中 $n = 2^m$，对于某个整数 $m \\ge 0$。辅助空间是临时数组和调用堆栈所用空间的总和。\n\n设 $S(t)$ 为执行过程中给定时间 $t$ 的总辅助空间。$S(t)$ 由两部分组成：临时数组的空间 $S_{\\text{arrays}}(t)$ 和调用堆栈的空间 $S_{\\text{stack}}(t)$。\n$$S(t) = S_{\\text{arrays}}(t) + S_{\\text{stack}}(t)$$\n目标是找到 $\\max_{t} S(t)$。\n\n算法 `RecShell` 在长度为 $\\ell$ 的子数组上被调用。\n- 如果 $\\ell=1$，这是一个基本情况，函数返回。\n- 如果 $\\ell  1$，它会分配两个总大小为 $\\ell$ 的临时数组 $T_0$ 和 $T_1$，然后先在 $T_0$ 上递归调用自身，再在 $T_1$ 上递归调用。由于输入长度 $n$ 是 $2$ 的幂，递归调用中遇到的任何子数组长度 $\\ell$ 也将是 $2$ 的幂（具体来说，$\\ell=n, \\frac{n}{2}, \\frac{n}{4}, \\dots, 2$）。因此，两个临时数组 $T_0$ 和 $T_1$ 的长度都将是 $\\frac{\\ell}{2}$。\n\n让我们将空间使用情况分析为递归深度的函数。初始调用 `RecShell(n)` 位于深度 $d=1$。它会调用位于深度 $d=2$ 的 `RecShell(\\frac{n}{2})$，以此类推，直到调用 `RecShell(1)$`。\n\n深度为 $d$ 时的调用堆栈空间由 $S_{\\text{stack}} = d \\cdot \\sigma$ 给出。这部分空间使用量随递归深度的增加而单调递增。\n\n临时数组空间 $S_{\\text{arrays}}$ 是所有并发分配的临时数组大小的总和。问题陈述，父调用的临时数组在其子调用执行期间保持分配状态。\n考虑达到最大深度的执行路径。这是“深度优先”路径，我们总是对第一个临时数组 $T_0$ 进行递归。\n堆栈上的调用序列将是：\n`RecShell(n)` $\\to$ `RecShell(\\frac{n}{2})$ $\\to$ `RecShell(\\frac{n}{4})$ $\\to \\dots \\to$ `RecShell(2)` $\\to$ `RecShell(1)`。\n\n输入长度 $n$ 给出为 $n = 2^m$。当长度为 $1 = 2^0$ 时递归停止。递归调用中子数组的长度为 $2^m, 2^{m-1}, 2^{m-2}, \\dots, 2^1, 2^0$。\n对长度为 $2^k$（$k \\ge 1$）的子数组的调用将递归地调用处理长度为 $2^{k-1}$ 的子数组。\n调用 `RecShell(n)` 对应于 $k=m$。调用 `RecShell(2)` 对应于 $k=1$。基本情况是 `RecShell(1)`，对应于 $k=0$。\n\n当 `RecShell(1)` 处于活动状态时，达到最大递归深度。让我们追踪此时的状态。\n调用堆栈包含 $m+1$ 个激活记录：从 `RecShell(n)` 到 `RecShell(1)` 的每次调用都有一个。\n- 调用堆栈深度为 $d_{\\text{max}} = m+1$。\n- 调用堆栈消耗的空间为 $S_{\\text{stack}} = (m+1)\\sigma$。\n\n在这一点上，我们需要确定所有已分配临时数组的总大小。对 `RecShell(\\ell)` 的调用会分配总大小为 $\\ell$ 的临时数组，前提是 $\\ell  1$。基本情况 `RecShell(1)` 不分配任何数组。\n堆栈上已分配数组的调用是：\n`RecShell(n)` (分配大小 $n$)\n`RecShell(\\frac{n}{2})$ (分配大小 $\\frac{n}{2}$)\n`RecShell(\\frac{n}{4})$ (分配大小 $\\frac{n}{4}$)\n...\n`RecShell(2)` (分配大小 $2$)\n\n临时数组的总空间是这些大小的总和：\n$$S_{\\text{arrays}} = n + \\frac{n}{2} + \\frac{n}{4} + \\dots + 2$$\n这是一个等比数列（geometric series）。使用 $n=2^m$，该数列是：\n$$S_{\\text{arrays}} = 2^m + 2^{m-1} + 2^{m-2} + \\dots + 2^1$$\n这是总和 $\\sum_{i=1}^{m} 2^i$。对于首项为 $a$，公比为 $r$，项数为 $k$ 的等比数列，其求和公式为 $a\\frac{r^k-1}{r-1}$。这里，$a=2$，$r=2$，有 $m$ 项。\n$$S_{\\text{arrays}} = 2 \\cdot \\frac{2^m - 1}{2-1} = 2(2^m - 1) = 2(n-1) = 2n-2$$\n\n在最大递归深度点，总辅助空间是堆栈空间和数组空间的总和：\n$$S_{\\text{max}} = S_{\\text{arrays}} + S_{\\text{stack}} = (2n-2) + (m+1)\\sigma$$\n\n随着递归的深入，堆栈空间和累积的数组空间都会增加。因此，最大空间使用量出现在递归最深的点。当递归回溯时，堆栈深度和已分配数组集的数量都会减少，因此总空间将小于此最大值。后续的递归分支（例如，对 $T_1$ 子数组的递归）将遵循相同的模式并达到相同的最大值，但不会超过它。\n\n问题要求最终答案用 $n$ 和 $\\sigma$ 表示。我们必须用 $n$ 来表示 $m$。\n给定 $n = 2^m$，我们可以对两边取以 $2$ 为底的对数：\n$$\\log_2(n) = \\log_2(2^m)$$\n$$m = \\log_2(n)$$\n这对于 $n=2^m$（其中 $m \\ge 0$）是有效的。注意，如果 $m=0$，则 $n=1$。算法进行一次对 `RecShell(1)` 的调用，这是一个基本情况。没有分配数组（$S_{\\text{arrays}}=0$）。最大堆栈深度为 $d=1$。空间是 $1 \\cdot \\sigma = \\sigma$。\n我们的公式给出：$2(1)-2 + (\\log_2(1)+1)\\sigma = 0 + (0+1)\\sigma = \\sigma$。该公式对 $m=0, n=1$ 成立。\n\n将 $m = \\log_2(n)$ 代入 $S_{\\text{max}}$ 的表达式中：\n$$S_{\\text{max}} = 2n - 2 + (\\log_2(n) + 1)\\sigma$$\n\n这就是在 `RecShell` 执行期间所使用的最大并发辅助空间的精确、封闭形式表达式。", "answer": "$$\n\\boxed{2n - 2 + \\sigma(\\log_{2}(n) + 1)}\n$$", "id": "3270034"}]}