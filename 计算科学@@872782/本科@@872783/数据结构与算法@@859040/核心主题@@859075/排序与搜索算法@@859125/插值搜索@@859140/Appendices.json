{"hands_on_practices": [{"introduction": "我们通过一个具体的计算练习来开始动手实践。在这个练习中，你将追踪插值搜索在一个非均匀分布但具有可预测性的数据集上的执行过程，其中数组元素按二次方增长（$A[i]=i^2$）。[@problem_id:3241452] 这个练习将帮助你建立对插值公式如何工作的直观理解，并观察算法如何适应非线性的数据分布，这是理解其在理想情况之外性能的基础。", "problem": "考虑一个长度为 $n$ 的排序数组 $A$，其元素定义为 $A[i] = i^{2}$，适用于所有整数索引 $i \\in \\{0, 1, \\dots, n-1\\}$。设 $n = 1001$。你将使用以下算法规范，对键值 $x = 900^{2}$ 执行插值搜索。\n\n初始化 $low = 0$ 和 $high = n - 1$。当 $low \\leq high$ 时，计算探测索引\n$$\np = low + \\left\\lfloor \\frac{x - A[low]}{A[high] - A[low]} \\cdot (high - low) \\right\\rfloor,\n$$\n约定如果 $A[low] = A[high]$，则 $p = low$。计算出 $p$ 后，访问 $A[p]$ 并与 $x$ 进行比较：\n- 如果 $A[p] = x$，搜索成功并终止。\n- 如果 $A[p]  x$，设置 $low = p + 1$ 并继续。\n- 如果 $A[p] > x$，设置 $high = p - 1$ 并继续。\n\n定义单次“探测”为一次循环迭代，其中索引 $p$ 被计算且数组值 $A[p]$ 被精确访问一次。不要将任何其他操作计为探测。从指定的初始条件开始，确定此插值搜索在成功找到 $A$ 中的 $x$ 之前执行的探测确切次数。最终答案必须是一个整数值。无需四舍五入。", "solution": "基本原理是在排序数组上进行插值搜索的定义，它利用端点之间的线性插值来估计目标键值的可能位置。具体来说，在任何具有当前边界 $low$ 和 $high$ 的迭代中，探测索引 $p$ 由以下公式定义\n$$\np = low + \\left\\lfloor \\frac{x - A[low]}{A[high] - A[low]} \\cdot (high - low) \\right\\rfloor,\n$$\n更新规则取决于 $A[p]$ 与 $x$ 的比较结果。\n\n在我们的实例中，数组满足 $A[i] = i^{2}$，因此在任何边界为 $low = L$ 和 $high = H$ 的迭代中，该公式可以在代数上进行简化。记 $x = k^{2}$，其中 $k = 900$。那么\n$$\n\\frac{x - A[L]}{A[H] - A[L]} \\cdot (H - L)\n= \\frac{k^{2} - L^{2}}{H^{2} - L^{2}} \\cdot (H - L)\n= \\frac{(k - L)(k + L)}{(H - L)(H + L)} \\cdot (H - L)\n= \\frac{(k - L)(k + L)}{H + L}.\n$$\n因此，\n$$\np = L + \\left\\lfloor \\frac{(k - L)(k + L)}{H + L} \\right\\rfloor.\n$$\n\n我们现在逐步执行搜索，将每次计算 $p$ 和对 $A[p]$ 的单次访问计为一次探测。\n\n初始条件为 $n = 1001$，因此 $low = 0$，$high = 1000$，且 $x = 900^{2} = 810000$。\n\n- 探测 1：$L = 0$，$H = 1000$，$k = 900$。\n  计算\n  $$\n  p = 0 + \\left\\lfloor \\frac{(900 - 0)(900 + 0)}{1000 + 0} \\right\\rfloor\n    = \\left\\lfloor \\frac{810000}{1000} \\right\\rfloor\n    = 810.\n  $$\n  访问 $A[810] = 810^{2} = 656100$。因为 $656100  810000$，设置 $low = p + 1 = 811$ 并保持 $high = 1000$。\n\n- 探测 2：$L = 811$，$H = 1000$，$k = 900$。\n  计算\n  $$\n  p = 811 + \\left\\lfloor \\frac{(900 - 811)(900 + 811)}{1000 + 811} \\right\\rfloor\n    = 811 + \\left\\lfloor \\frac{89 \\cdot 1711}{1811} \\right\\rfloor.\n  $$\n  计算 $89 \\cdot 1711 = 152279$。接着 $\\left\\lfloor \\frac{152279}{1811} \\right\\rfloor = 84$，因为 $1811 \\cdot 84 = 152124$ 并且 $1811 \\cdot 85 = 153935 > 152279$。因此 $p = 811 + 84 = 895$。\n  访问 $A[895] = 895^{2} = 801025$。因为 $801025  810000$，设置 $low = p + 1 = 896$ 并保持 $high = 1000$。\n\n- 探测 3：$L = 896$，$H = 1000$，$k = 900$。\n  计算\n  $$\n  p = 896 + \\left\\lfloor \\frac{(900 - 896)(900 + 896)}{1000 + 896} \\right\\rfloor\n    = 896 + \\left\\lfloor \\frac{4 \\cdot 1796}{1896} \\right\\rfloor\n    = 896 + \\left\\lfloor \\frac{7184}{1896} \\right\\rfloor.\n  $$\n  因为 $1896 \\cdot 3 = 5688$ 并且 $1896 \\cdot 4 = 7584 > 7184$，我们得到 $\\left\\lfloor \\frac{7184}{1896} \\right\\rfloor = 3$，所以 $p = 896 + 3 = 899$。\n  访问 $A[899] = 899^{2} = 808201$。因为 $808201  810000$，设置 $low = p + 1 = 900$ 并保持 $high = 1000$。\n\n- 探测 4：$L = 900$，$H = 1000$，$k = 900$。\n  计算\n  $$\n  p = 900 + \\left\\lfloor \\frac{(900 - 900)(900 + 900)}{1000 + 900} \\right\\rfloor\n    = 900 + \\left\\lfloor \\frac{0 \\cdot 1800}{1900} \\right\\rfloor\n    = 900.\n  $$\n  访问 $A[900] = 900^{2} = 810000$。因为 $A[900] = x$，搜索成功并终止。\n\n我们在找到键值前，总共执行了 $4$ 次探测。根据问题的定义，没有其他操作被计为探测。因此，探测的确切次数是 $4$。", "answer": "$$\\boxed{4}$$", "id": "3241452"}, {"introduction": "接下来，我们将深入探讨插值搜索的脆弱性。与分析给定数组不同，你需要反向思考，设计一个特定的数组并选择一个搜索键，以故意误导算法，使其第一次猜测尽可能偏离目标。[@problem_id:3241327] 这种“对抗性思维”练习深刻地揭示了该算法背后的核心假设，以及当这些假设被违背时可能产生的严重后果。", "problem": "考虑一个由 $n$ 个不同实数组成的严格递增有序数组 $A[1], A[2], \\ldots, A[n]$，其中 $n \\geq 3$。插值查找通过在端点 $A[1]$ 和 $A[n]$ 之间对查询键 $x$ 的位置进行线性插值来估计其位置，然后取整到整数索引。仅使用在有序表上两个端点之间进行线性插值的原理，推导当搜索区间为整个数组 $[1, n]$ 时，插值查找的第一个探测索引 $p$ 的表达式。\n\n然后，设计一个具体的数组族 $A$（如有必要，可参数化），并指定一个特定的 $x$ 值，使得第一个探测索引 $p$ 可被证明是下一个最差的选择，即它落在离真实索引 $k$ (其中 $A[k] = x$) 最远的索引上。您的构造必须满足 $A[1] = 0$，$A[n] = 1$，并且对于所有 $i \\in \\{2, \\ldots, n-1\\}$，都有 $A[i] \\in (0, 1)$，同时满足 $A[1]  A[2]  \\cdots  A[n]$。请严格证明，在这些约束条件下，由端点插值产生的第一个探测索引 $p$ 是离 $k$ 最远的可能索引。\n\n最后，计算在此场景下可实现的最大可能绝对索引误差 $|p - k|$，并将其表示为 $n$ 的函数。请将最终答案表示为一个封闭形式的解析表达式。无需进行取整。", "solution": "### 第一部分：第一次探测索引的推导\n插值查找的原理是将数据建模为位于一条直线上。给定一个有序数组 `A`，我们在（索引，值）平面上考虑点 `(1, A[1])` 和 `(n, A[n])`。通过这两点的直线方程为：\n$$ V(i) = A[1] + \\frac{A[n] - A[1]}{n - 1}(i - 1) $$\n为了找到给定值 `x` 的估计索引，我们令 `V(i) = x` 并求解 `i`。设索引的连续（实值）估计值为 `pos`。\n$$ x = A[1] + \\frac{A[n] - A[1]}{n - 1}(\\text{pos} - 1) $$\n重新整理以求解 `pos`：\n$$ x - A[1] = \\frac{A[n] - A[1]}{n - 1}(\\text{pos} - 1) $$\n$$ \\text{pos} - 1 = (x - A[1]) \\frac{n - 1}{A[n] - A[1]} $$\n$$ \\text{pos} = 1 + (n - 1) \\frac{x - A[1]}{A[n] - A[1]} $$\n整数探测索引 `p` 是通过对此连续估计值取下整得到的，这在许多编程语言中对应于标准的整数算术。\n$$ p = \\left\\lfloor 1 + (n - 1) \\frac{x - A[1]}{A[n] - A[1]} \\right\\rfloor $$\n由于 `1` 是一个整数，我们可以将其写为：\n$$ p = 1 + \\left\\lfloor (n - 1) \\frac{x - A[1]}{A[n] - A[1]} \\right\\rfloor $$\n这是第一次探测索引的通用表达式。\n\n### 第二部分：最坏情况场景的构建\n给定约束条件 `A[1] = 0` 和 `A[n] = 1`。将它们代入 `p` 的公式中：\n$$ p = 1 + \\left\\lfloor (n - 1) \\frac{x - 0}{1 - 0} \\right\\rfloor = 1 + \\lfloor (n - 1)x \\rfloor $$\n我们正在搜索数组中存在的一个值 `x`，因此对于某个索引 `k \\in \\{1, 2, \\ldots, n\\}` 有 `x = A[k]`。因此，探测索引为：\n$$ p = 1 + \\lfloor (n - 1)A[k] \\rfloor $$\n我们的目标是构造一个数组 `A` 并选择一个 `k`，以最大化绝对索引误差 `|p - k| = |(1 + \\lfloor (n - 1)A[k] \\rfloor) - k|`。\n\n`p` 的值取决于 `n` 和 `A[k]`，但值得注意的是，它不依赖于 `A` 的其他元素。`A` 的约束条件是它必须严格递增，且 `A[1]=0` 和 `A[n]=1`。对于 `k \\in \\{2, \\ldots, n-1\\}` 的任何选择和 `v \\in (0,1)` 的任何值，都可以构造一个有效的数组 `A` 使得 `A[k] = v`。这是因为我们总可以在区间 `(0, v)` 中放入所需的 `k-2` 个点，在 `(v, 1)` 中放入 `n-k-1` 个点。\n\n我们通过考虑 `k \\in \\{2, \\ldots, n-1\\}`（因为 `k=1` 给出 `x=0`, `p=1`, 误差为 `0`）和 `A[k]` 的可用选择来分析误差 `|p - k|`。\n\n为了最大化 `|p - k|`，我们必须使 `p` 和 `k` 尽可能地相距遥远。这建议将其中一个选择在其最小值附近，另一个选择在其最大值附近。索引 `k` 的范围可以从 `2`到 `n-1`。探测索引 `p = 1 + \\lfloor (n-1)A[k] \\rfloor` 的范围可以从 `1` 到 `n-1`，因为对于 `k \\in \\{2, \\ldots, n-1\\}` 有 `0  A[k]  1`，这意味着 `0  (n-1)A[k]  n-1`，所以 `0 \\le \\lfloor(n-1)A[k]\\rfloor \\le n-2`。\n\n**情况1：`k` 很大，`p` 很小。**\n让我们选择 `k` 为其在搜索范围内的最大可能值，即 `k = n-1`。为了最大化误差 `|p - (n-1)|`，我们应该使 `p` 尽可能小。`p` 的最小可能值为 `1`。\n为了使 `p = 1`，我们需要 `\\lfloor (n-1)A[n-1] \\rfloor = 0`。\n这个不等式在 `0 \\le (n-1)A[n-1]  1` 时成立，可以简化为 `0 \\le A[n-1]  \\frac{1}{n-1}`。由于 `A` 必须是严格递增的且 `A[1]=0`，我们必须有 `A[n-1] > 0`。\n因此，如果我们选择 `A[n-1]` 为 `(0, \\frac{1}{n-1})` 中的任意值，探测索引将为 `p=1`。\n我们来搜索 `x = A[n-1]`。真实索引是 `k=n-1`。探测索引是 `p=1`。\n绝对误差是 `|p - k| = |1 - (n-1)| = n-2`。\n\n**情况2：`k` 很小，`p` 很大。**\n让我们选择 `k` 为其最小可能值，即 `k = 2`。为了最大化误差 `|p - 2|`，我们应该使 `p` 尽可能大。`\\lfloor (n-1)A[2] \\rfloor` 的最大可能值是 `n-2`，因为 `A[2]  A[n] = 1`。\n为了使 `\\lfloor (n-1)A[2] \\rfloor = n-2`，我们需要 `n-2 \\le (n-1)A[2]  n-1`，这意味着 `\\frac{n-2}{n-1} \\le A[2]  1`。\n这是 `A[2]` 的一个有效范围。如果我们在该范围内选择 `A[2]`，探测索引将是 `p = 1 + (n-2) = n-1`。我们来搜索 `x = A[2]`。真实索引是 `k=2`。探测索引是 `p=n-1`。\n绝对误差是 `|p - k| = |(n-1) - 2| = n-3`。\n\n比较这两种情况，最大误差是 `n-2`，因为 `n \\geq 3` 意味着 `n-2 \\ge n-3`。\n\n为了严格证明这是最坏情况，我们构造一个特定的数组族。\n设 `n \\ge 3`。数组 `A` 定义如下：\n- `A[1] = 0`\n- `A[n] = 1`\n- `A[n-1] = \\frac{1}{2(n-1)}`。这满足 `0  A[n-1]  \\frac{1}{n-1}`。\n- 对于 `i \\in \\{2, \\ldots, n-2\\}`，通过线性间距定义 `A[i]`：`A[i] = \\frac{i-1}{n-2} A[n-1] = \\frac{i-1}{n-2} \\cdot \\frac{1}{2(n-1)}`。\n\n这个构造是有效的，因为 `0 = A[1]  A[2]  \\cdots  A[n-1]  A[n]=1`。\n具体来说，`A[2] = \\frac{1}{(n-2)2(n-1)} > 0 = A[1]`。序列 `A[2], \\ldots, A[n-1]` 是严格递增的。并且 `A[n-1] = \\frac{1}{2(n-1)}  1 = A[n]`。\n\n现在，设搜索键为 `x = A[n-1] = \\frac{1}{2(n-1)}`。\n真实索引是 `k = n-1`。\n探测索引计算如下：\n$$ p = 1 + \\left\\lfloor (n-1)x \\right\\rfloor = 1 + \\left\\lfloor (n-1) \\cdot \\frac{1}{2(n-1)} \\right\\rfloor = 1 + \\left\\lfloor \\frac{1}{2} \\right\\rfloor = 1 + 0 = 1 $$\n探测落在索引 `1` 上。\n绝对索引误差为 `|p - k| = |1 - (n-1)| = n-2`。\n这个构造表明 `n-2` 的误差是可以实现的。我们的分析表明，在问题的约束下，这是可能的最大误差。\n\n### 第三部分：最大可能绝对索引误差\n如上文推导和证明，当真实键位于索引 `k=n-1` 处且其值很小，导致探测落在索引 `p=1` 处时，可以实现最大可能绝对索引误差 `|p - k|`。这个最大误差是 `n` 的函数。\n$$ \\text{最大误差} = n-2 $$", "answer": "$$\\boxed{n-2}$$", "id": "3241327"}, {"introduction": "在理解了插值搜索的优点和局限性之后，最后的这个实践将引导你进入一个真实的工程设计挑战。你将设计一个“混合”搜索算法，它以插值搜索开始，但会监控自身的执行效率，并在性能不佳时动态切换到更可靠的二分搜索。[@problem_id:3241345] 这项任务综合了分析与设计，旨在创建一个适用于数据分布未知的实际应用的稳健算法。", "problem": "您需要设计并实现一种针对排序数组的自调整搜索算法，该算法以基于插值的探测开始，并在观察到其进展持续不佳时动态切换到二分搜索。该算法必须作用于一个按非递减顺序排序的实数或整数值数组，并且必须返回给定目标值出现的索引，如果目标不存在则返回 $-1$。程序必须是自包含的，并且无需任何输入即可运行。\n\n设计必须基于基本定义和经过充分检验的事实：\n\n1. 一个长度为 $n$ 的排序数组 $A$ 满足对于所有 $0 \\le i \\le j \\le n-1$，都有 $A[i] \\le A[j]$。\n2. 二分搜索维护一个不变的子范围 $[l,r]$，并且在每次探测时，将剩余的范围长度 $L_t = r - l + 1$ 减少最多约 $1/2$ 的因子。\n3. 基于插值的探测依赖于关于索引上的单调映射 $x \\mapsto A[x]$ 的线性模型假设，当值在索引范围内近似均匀分布时，这个假设是合理的。它维护不变量 $A[l] \\le \\text{key} \\le A[r]$，并通过估计键值相对于 $A[l]$ 和 $A[r]$ 的位置来选择 $[l,r]$ 内的探测位置。\n\n该算法必须量化地监控其自身的进展。将时间 $t$ 的范围长度定义为 $L_t = r_t - l_t + 1$。每次插值探测并相应更新到 $[l_{t+1}, r_{t+1}]$ 后，定义分数范围缩减\n$$\n\\rho_t = \\frac{L_t - L_{t+1}}{L_t}.\n$$\n使用一个固定的窗口大小 $w$ 和一个阈值 $\\tau$，并计算最后 $w$ 个观测到的 $\\rho_t$ 值的移动平均值。如果移动平均值低于 $\\tau$（表示每次探测的缩减持续不佳），则立即对剩余的搜索范围切换到二分搜索。\n\n算法要求和边缘情况处理：\n\n- 该算法必须维护不变子范围 $[l,r]$，并在每次读取和比较所选索引 $i$ 处的 $A[i]$ 以指导搜索时，计为一次探测。访问 $A[l]$ 和 $A[r]$ 以计算估计值本身不计为一次探测，除非在这些索引处执行了与目标的比较。\n- 如果在任何时候，在不变子范围内分母 $A[r] - A[l]$ 变为 $0$，则数组值在 $[l,r]$ 上是恒定的。在这种情况下，直接在 $[l,r]$ 中切换到二分搜索以避免未定义的插值，并继续探测直到终止。\n- 如果目标键值超出了当前的不变边界（即 $\\text{key}  A[l]$ 或 $\\text{key} > A[r]$），则终止并返回 $-1$，该情况下增加的探测次数为零。\n- 当目标出现多次时，返回其出现范围内的任何有效索引都是可接受的。\n- 程序必须为每个测试用例报告三个输出：找到的索引 $i$（如果未找到则为 $-1$），探测总数 $p$，以及一个布尔值 $b$ 指示是否在任何时候使用了二分搜索（如果切换或直接使用则为 $\\text{True}$，否则为 $\\text{False}$）。\n\n测试套件和参数：\n\n在所有案例中均使用相同的阈值和窗口：$\\tau = 0.3$ 和 $w = 4$。对于每个案例，按如下方式定义排序数组 $A$ 和目标键值。\n\n- 案例 1（均匀分布，理想情况）：$A = \\{0,1,2,\\dots,999\\}$ 且 $\\text{key} = 750$。\n- 案例 2（非线性间距，偏斜映射）：$A = \\{i^3 : i \\in \\{0,1,2,\\dots,199\\}\\}$ 且 $\\text{key} = 729$。\n- 案例 3（大量重复导致局部平坦区域）：$A$ 包含 $1000$ 个 $5$，后跟序列 $\\{6,7,\\dots,105\\}$，且 $\\text{key} = 5$。\n- 案例 4（目标缺失的边界条件）：$A = \\{0,1,2,\\dots,9999\\}$ 且 $\\text{key} = 10001$。\n- 案例 5（极度偏斜增长，近似指数）：$A = \\{\\lfloor 10^{i/100} \\rfloor : i \\in \\{0,1,2,\\dots,1000\\}\\}$ 且 $\\text{key}$ 等于 $A$ 中索引为 $800$ 的元素。\n\n最终输出格式：\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。此顶层列表的每个元素对应一个测试用例，并且其本身必须是按 $[i,p,b]$ 顺序排列的三项列表，其中 $i$ 是整数索引或 $-1$，$p$ 是按上述定义计数的整数探测次数，$b$ 是一个布尔值，指示是否使用了二分搜索。例如，打印的行必须如下所示\n$[[i_1,p_1,b_1],[i_2,p_2,b_2],[i_3,p_3,b_3],[i_4,p_4,b_4],[i_5,p_5,b_5]]$。", "solution": "该问题要求设计并实现一种用于排序数组的混合搜索算法。该算法使用基于插值的探测来启动搜索，并在观察到其性能不佳时自动切换到二分搜索。解决方案必须基于这些搜索算法的基本原理，并遵守特定的实现要求。\n\n### 原理与算法设计\n\n一个长度为 $n$ 的排序数组 $A$ 在索引和值之间表现出单调非递减关系，即对于所有 $0 \\le i \\le j \\le n-1$，都有 $A[i] \\le A[j]$。这一属性是比线性扫描更高效的搜索算法的基础。\n\n#### 二分搜索\n二分搜索是一种稳健的算法，保证对数时间复杂度，即 $O(\\log n)$。它在搜索子范围 $[l, r]$ 上操作，并探测中间元素 $A[\\text{mid}]$，其中 $\\text{mid} = l + \\lfloor(r-l)/2\\rfloor$。根据 $A[\\text{mid}]$ 与目标键值的比较，它在每一步中将搜索空间减半。范围长度 $L_t = r_t - l_t + 1$ 被缩减，使得 $L_{t+1} \\approx L_t/2$。其性能与数组内的值分布无关。\n\n#### 插值搜索\n插值搜索利用搜索范围 $[l, r]$ 边界上元素的值来估计目标键值的位置。它假设从索引到值存在近似线性的映射。探测位置 `pos` 通过线性插值计算得出：\n$$\n\\text{pos} = l + \\left\\lfloor \\frac{(r-l)(key - A[l])}{A[r] - A[l]} \\right\\rfloor\n$$\n对于均匀分布的数据，插值搜索的平均时间复杂度为 $O(\\log \\log n)$，这在渐近意义上比二分搜索更快。然而，对于非均匀分布的数据（例如，指数或聚集的值），其性能会显著下降，最坏情况下的复杂度为 $O(n)$。\n\n#### 带自调整功能的混合算法\n所提出的算法旨在结合两种方法的优点：插值搜索潜在的高速度和二分搜索有保证的性能。它通过量化地监控自身进展，并在插值证明无效时切换策略来实现这一点。\n\n**性能监控：**\n搜索的进展通过在步骤 $t$ 的每次探测后的分数范围缩减 $\\rho_t$ 来衡量。给定探测前的范围长度 $L_t = r_t - l_t + 1$ 和探测后的 $L_{t+1}$，缩减量为：\n$$\n\\rho_t = \\frac{L_t - L_{t+1}}{L_t} = 1 - \\frac{L_{t+1}}{L_t}\n$$\n一个接近 $1$ 的 $\\rho_t$ 值表示一次非常有效的探测，而一个接近 $0$ 的值则表示进展甚微。对于二分搜索，$\\rho_t \\approx 0.5$。\n\n**切换逻辑：**\n为避免因单次不成功的探测而过早切换，该算法计算最后 $w$ 个观测到的 $\\rho_t$ 值的简单移动平均值。如果该平均值低于预定义的阈值 $\\tau$，则表明存在持续的性能不佳模式。此时，算法断定插值搜索所假设的线性模型对于给定的数据分布是无效的，并在当前的子范围 $[l, r]$ 中为剩余的搜索切换到更稳健的二分搜索。\n\n### 实现细节与边缘情况处理\n\n该算法实现为一个具有两种模式的状态机：`'interpolation'`（插值）和 `'binary'`（二分）。\n\n1.  **初始化**：搜索范围初始化为整个数组 $[0, n-1]$。执行初始检查，看目标 `key` 是否在数组的值范围之外，即 `key  A[0]` 或 `key > A[n-1]`。如果是，则搜索立即终止，返回索引 $-1$ 和零次探测，因为键值不可能存在。\n\n2.  **主循环**：只要范围有效（$l \\le r$），搜索就继续进行。\n\n3.  **插值模式**：\n    *   **分母检查**：插值公式的一个关键边缘情况是当 $A[r] = A[l]$ 时。这表明当前子范围 $[l, r]$ 中的所有元素都相同。尝试进行插值将导致除以零。根据问题规范，如果发生这种情况，算法将切换到二分搜索。这是因为如果 `key` 等于这个常数值，二分搜索可以高效地找到一个索引；如果不等，它将正确地确定其不存在。\n    *   **探测计算**：计算 `pos` 索引。必须注意确保使用整数算术执行计算，或正确地将其转换为整数索引。\n    *   **探测与更新**：将元素 $A[\\text{pos}]$ 与 `key` 进行比较，计为一次探测，并缩小范围 $[l, r]$。\n    *   **性能更新**：更新 `l` 或 `r` 后，计算新的 $\\rho_t$ 并将其添加到最近缩减量的列表（或双端队列）中。\n    *   **切换条件检查**：如果缩减量列表至少有 $w$ 个元素，则计算它们的平均值。如果平均值小于 $\\tau$，则将模式切换到 `'binary'`，并将布尔标志 `used_binary` 设置为 `True`。\n\n4.  **二分搜索模式**：\n    *   一旦算法进入此模式，它将保持在该模式直到终止。\n    *   遵循标准的二分搜索过程：计算 `mid`，探测 $A[\\text{mid}]$，并缩小范围 $[l, r]$。每次探测都会被计数。\n\n5.  **终止**：如果循环结束时未找到键值（$l > r$），则键值不在数组中，返回索引 $-1$。如果在任何时候找到键值，则立即返回其索引。最终的返回值聚合了找到的索引、探测总数以及指示是否曾使用过二分搜索的布尔标志。\n\n这种设计提供了一种稳健且自适应的搜索机制，它在各种数据分布上都表现良好，满足了问题陈述的所有要求。以下代码为指定的测试套件实现了这一逻辑。", "answer": "```python\nimport numpy as np\nfrom collections import deque\n\ndef solve():\n    \"\"\"\n    Designs and executes the self-tuning hybrid search algorithm\n    on a predefined test suite.\n    \"\"\"\n\n    def hybrid_search(A: np.ndarray, key: int, tau: float, w: int):\n        \"\"\"\n        Performs a hybrid interpolation-binary search.\n\n        Args:\n            A: Sorted numpy array of numbers.\n            key: The target value to search for.\n            tau: The performance threshold for switching to binary search.\n            w: The window size for the moving average of range reduction.\n\n        Returns:\n            A list containing [found_index, num_probes, used_binary_search].\n        \"\"\"\n        n = A.size\n        l, r = 0, n - 1\n\n        probes = 0\n        used_binary = False\n        mode = 'interpolation'\n        reductions = deque(maxlen=w)\n\n        # Initial bounds check as per problem statement\n        if n == 0 or key  A[l] or key > A[r]:\n            # 'probes' remains 0 as specified\n            return [-1, 0, False]\n\n        while l = r:\n            if mode == 'binary':\n                if not used_binary:\n                    used_binary = True\n                \n                mid = l + (r - l) // 2\n                probes += 1\n                \n                if A[mid] == key:\n                    return [mid, probes, used_binary]\n                elif A[mid]  key:\n                    l = mid + 1\n                else:\n                    r = mid - 1\n            else:  # mode == 'interpolation'\n                # Invariant check: key must be within A[l] and A[r]\n                # This should hold but is a good safeguard.\n                if key  A[l] or key > A[r]:\n                    break\n\n                # Handle flat region to avoid division by zero and switch to binary search.\n                if A[r] == A[l]:\n                    if A[l] == key:\n                        # The key is in this flat region.\n                        # As specified, switch to binary search to find an index.\n                        mode = 'binary'\n                        continue\n                    else:\n                        # Key is not in this flat region, so it's not in the array.\n                        break\n                \n                old_l, old_r = l, r\n                \n                # Interpolation formula\n                # Pos must be clamped within [l, r] to handle potential floating point inaccuracies\n                # or extreme key values, though theory suggests it's not needed if key is in range.\n                pos_float = l + ((r - l) / (A[r] - A[l])) * (key - A[l])\n                pos = int(pos_float)\n                pos = max(l, min(pos, r))\n\n                probes += 1\n                \n                if A[pos] == key:\n                    return [pos, probes, used_binary]\n                elif A[pos]  key:\n                    l = pos + 1\n                else:\n                    r = pos - 1\n                \n                # Calculate performance metric\n                L_t = old_r - old_l + 1\n                L_t1 = r - l + 1\n                \n                if L_t > 0: # Avoid division by zero if range somehow becomes empty/invalid\n                    rho_t = (L_t - L_t1) / L_t\n                    reductions.append(rho_t)\n                \n                # Check switch condition\n                if len(reductions) == w:\n                    avg_rho = sum(reductions) / w\n                    if avg_rho  tau:\n                        mode = 'binary'\n                        used_binary = True\n\n        return [-1, probes, used_binary]\n\n    # --- Test Suite Definition ---\n    tau = 0.3\n    w = 4\n\n    test_cases = []\n\n    # Case 1: Uniform distribution\n    A1 = np.arange(1000)\n    key1 = 750\n    test_cases.append((A1, key1))\n\n    # Case 2: Nonlinear spacing (cubic)\n    A2 = np.array([i**3 for i in range(200)])\n    key2 = 729  # which is 9^3\n    test_cases.append((A2, key2))\n\n    # Case 3: Heavy duplicates\n    A3 = np.array([5] * 1000 + list(range(6, 106)))\n    key3 = 5\n    test_cases.append((A3, key3))\n\n    # Case 4: Target absent boundary condition\n    A4 = np.arange(10000)\n    key4 = 10001\n    test_cases.append((A4, key4))\n    \n    # Case 5: Extremely skewed growth (exponential-like)\n    A5 = np.array([int(10**(i/100)) for i in range(1001)])\n    key5 = A5[800]\n    test_cases.append((A5, key5))\n    \n    results = []\n    for A, key in test_cases:\n        result = hybrid_search(A, key, tau, w)\n        results.append(result)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3241345"}]}