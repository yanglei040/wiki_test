{"hands_on_practices": [{"introduction": "虽然随机化快速排序在平均情况下非常高效，但当数组包含大量重复键时，标准的双路分区策略可能会导致性能下降。一个更优的解决方案是三路分区（“荷兰国旗问题”）。这项练习 [@problem_id:3263576] 旨在通过对一个仅包含两种值的数组进行定量分析，来对比这两种分区策略的期望性能，从而加深你对分区设计重要性的理解。", "problem": "给定一个包含 $n$ 个布尔键值的数组，其中恰好包含 $k$ 个键值 $1$ 和 $n-k$ 个键值 $0$，且 $1 \\le k \\le n-1$。该数组的顺序是任意的。考虑将两种随机化快速排序的变体应用于此数组：\n\n- 变体 A（标准双路划分）：每次递归调用都从子数组中均匀随机地选择一个主元，并将子数组划分为“小于主元”和“大于等于主元”两组，然后对这两组进行递归。\n- 变体 B（荷兰国旗式三路划分）：每次递归调用都从子数组中均匀随机地选择一个主元，并将子数组划分为“小于主元”、“等于主元”和“大于主元”三组，然后仅对“小于”和“大于”两组进行递归。\n\n在两种变体中，成本均度量为整个执行过程中与主元进行键值比较的总次数。使用一个三向比较器，在一次元素与主元的比较中，即可确定该元素是小于、等于还是大于主元；因此，划分一个大小为 $m$ 的子数组恰好需要执行 $m-1$ 次键值比较。唯一的随机性来源是每次递归调用中均匀随机地选择主元。\n\n请从第一性原理推导在此输入模型上，由变体 A 和变体 B 执行的期望总比较次数的闭式表达式，作为 $n$ 和 $k$ 的函数。请用 $n$ 和 $k$ 表示你的最终答案，形式为两个明确的公式。无需四舍五入。以行向量的形式提供你的两个公式，顺序为 [变体 A, 变体 B]。", "solution": "该问题要求计算在包含 $n-k$ 个零和 $k$ 个一（其中 $1 \\le k \\le n-1$）的 $n$ 个布尔键值数组上，两种随机化快速排序变体的期望总键值比较次数。划分一个大小为 $m$ 的子数组的成本为 $m-1$ 次比较。\n\n### 变体 A：标准双路划分 (“小于主元” 和 “大于等于主元”)\n\n在这种方案下，当数组包含大量重复元素时，性能会显著下降。\n1.  **选择主元为 0**（概率为 $(n-k)/n$）：划分操作会将数组分为“小于0”（空集）和“大于等于0”（所有 $n$ 个元素）。这导致一个极不平衡的划分。算法将对包含所有 $n-1$ 个其他元素（$n-k-1$ 个零和 $k$ 个一）的子数组进行递归。问题规模仅减小了1。\n2.  **选择主元为 1**（概率为 $k/n$）：划分操作会将数组分为“小于1”（所有 $n-k$ 个零）和“大于等于1”（所有 $k$ 个一）。这样，两种值的元素被完美分开了。之后，递归调用将分别处理只包含零的子数组和只包含一的子数组。\n\n对于一个只包含 $m$ 个相同元素的子数组，此划分方案每次递归只会将问题规模减小1，导致总共需要 $m-1 + m-2 + \\dots + 1 = \\binom{m}{2}$ 次比较。\n\n因此，如果选择主元为 1，总比较次数为初始的 $n-1$ 次，加上处理全零子数组的 $\\binom{n-k}{2}$ 次，再加上处理全一子数组的 $\\binom{k-1}{2}$ 次（因为主元本身不参与递归）。\n\n只有在第一次选择主元为 1 之后，算法才会高效。在此之前，每次选择主元 0 都会导致对几乎同样大小的子数组进行昂贵的递归调用。可以证明，在这种情况下，任何两个元素（无论值是否相同）最终都将被比较。因此，期望比较总次数等于任意两个元素都被比较的次数，即从 $n$ 个元素中选取两两配对的总数。\n\n期望总比较次数 $E_A = \\binom{n}{2} = \\frac{n(n-1)}{2}$。\n\n### 变体 B：荷兰国旗式三路划分\n\n这种方案能有效处理重复键。\n1.  **选择主元为 0**（概率为 $(n-k)/n$）：第一次划分（$n-1$ 次比较）会将数组分为“小于0”（空集）、“等于0”（$n-k$ 个零）和“大于0”（$k$ 个一）。算法仅对“大于0”的子数组（即 $k$ 个一）进行递归。对一个包含 $k$ 个相同元素的子数组进行一次划分需要 $k-1$ 次比较，之后子问题为空，递归终止。因此，这种情况下的总比较次数为 $(n-1) + (k-1)$。\n2.  **选择主元为 1**（概率为 $k/n$）：第一次划分（$n-1$ 次比较）会将数组分为“小于1”（$n-k$ 个零）、“等于1”（$k$ 个一）和“大于1”（空集）。算法仅对“小于1”的子数组（即 $n-k$ 个零）进行递归。这需要 $n-k-1$ 次比较。因此，这种情况下的总比较次数为 $(n-1) + (n-k-1)$。\n\n根据全期望公式，总期望比较次数为：\n$$\nE_B = \\frac{n-k}{n} \\left( (n-1) + (k-1) \\right) + \\frac{k}{n} \\left( (n-1) + (n-k-1) \\right)\n$$\n$$\nE_B = (n-1) + \\frac{n-k}{n}(k-1) + \\frac{k}{n}(n-k-1)\n$$\n$$\nE_B = (n-1) + \\frac{(nk - n - k^2 + k) + (nk - k^2 - k)}{n}\n$$\n$$\nE_B = (n-1) + \\frac{2nk - n - 2k^2}{n}\n$$\n$$\nE_B = n-1 + 2k - 1 - \\frac{2k^2}{n} = n + 2k - 2 - \\frac{2k^2}{n}\n$$\n\n因此，我们得到了两种变体的期望总比较次数的闭式表达式。", "answer": "$$ \\boxed{ \\begin{pmatrix} \\frac{n(n-1)}{2},  n + 2k - 2 - \\frac{2k^2}{n} \\end{pmatrix} } $$", "id": "3263576"}, {"introduction": "在掌握了正确的分区实现后，我们来探讨当代码出现错误时会发生什么。分区方案中的微小错误可能对算法的整体行为和性能产生灾难性的影响。这项练习 [@problem_id:3263703] 是一个关于算法调试的实践课程，通过追踪一个有缺陷的 Lomuto 分区实现，你将学会预测算法的意外行为（从排序器变为洗牌器）并分析其导致的性能退化。", "problem": "你的任务是严格分析一个随机化快速排序实现的表现，该实现使用了带有错误指针移动规则的 Lomuto 分区方案。此分析的基本依据是随机化快速排序的标准定义，以及将关键字比较次数作为运行时间代理的概念：\n- 对大小为 $n$ 的数组 $A$ 进行随机化快速排序时，会从当前子数组中均匀随机地选择一个主元索引，将 $A$ 分为小于主元的元素和大于或等于主元的元素，然后递归地对左右子数组进行排序，当子数组大小小于或等于 $1$ 时终止。\n- 运行时间通过数组元素与主元之间的关键字比较总数来衡量，该总数是递归树中所有分区调用中比较次数的累加。\n- 期望是针对主元选择的随机性计算的。\n\n在标准的 Lomuto 分区中，对于子数组 $A[\\ell..r]$，会从 $\\{\\ell, \\ell+1, \\dots, r\\}$ 中均匀随机选择一个主元，将其交换到位置 $r$，初始化索引 $i \\leftarrow \\ell-1$，扫描索引 $j$ 从 $\\ell$ 到 $r-1$，每当 $A[j]$ 小于等于主元时递增 $i$ 并交换 $A[i]$ 和 $A[j]$，最后将 $A[i+1]$ 与位于 $A[r]$ 的主元交换，以将主元放置到其最终位置。\n\n在本问题中，你必须分析 Lomuto 分区的一个错误变体，其中索引 $i$ 在扫描的每次迭代中都被错误地递增，而不管 $A[j]$ 是否小于主元。具体来说，对子数组 $A[\\ell..r]$ 的错误分区执行以下操作：\n- 从 $\\{\\ell, \\ell+1, \\dots, r\\}$ 中均匀随机地选择一个主元索引，并将主元交换到位置 $r$。\n- 初始化 $i \\leftarrow \\ell$。\n- 对于从 $\\ell$ 到 $r-1$ 的每个 $j$：\n  - 执行一次 $A[j]$ 与主元值的比较。\n  - 如果 $A[j]$ 小于主元，则交换 $A[i]$ 和 $A[j]$。\n  - **设置 $i \\leftarrow i+1$（这是错误的步骤，无条件执行）。**\n- 循环结束后，将 $A[i]$ 与 $A[r]$ 交换，并返回 $i$ 作为分区索引。\n\n你的任务是：\n- 实现使用上述错误分区过程的随机化快速排序，并在每次调用时均匀随机地选择主元。\n- 对算法进行插桩，以便在对输入数组 $A$ 的每次完整快速排序调用中测量两个量：\n  1. 关键字比较总数 $C(A)$，定义为在所有分区调用中，$A[j]$ 与主元值在该次调用期间的比较次数之和。\n  2. 最大递归深度 $D(A)$，定义为在执行期间观察到的调用栈上同时存在的函数活动的最大数量，即使是大小为 $1$ 的子数组上的基本情况活动也计为深度 $1$。\n- 同时确定输出数组是否按非递减顺序排序。\n\n由此，仅从上述定义以及求和与递归的标准属性出发，推断并论证使用错误分区时随机化快速排序的预期结果和渐进复杂度。不要假设任何直接简化推导过程的专用公式。\n\n你的程序必须为每个提供的测试用例计算以下内容：\n- 一个布尔值，指示返回的数组是否按非递减顺序排序。\n- 整数 $C(A)$。\n- 整数 $D(A)$。\n\n使用以下测试套件。每个测试用例被指定为一个包含初始数组和用于选择随机主元的伪随机数生成器种子的配对：\n- 测试用例 1：数组 $[\\,3,1,4,1,5,9,2,6\\,]$，种子 $42$。\n- 测试用例 2：数组 $[\\,1,2,3,4,5,6,7,8\\,]$，种子 $0$。\n- 测试用例 3：数组 $[\\,8,7,6,5,4,3,2,1\\,]$，种子 $123$。\n- 测试用例 4：数组 $[\\,5,5,5,5,5\\,]$，种子 $2024$。\n- 测试用例 5：数组 $[\\,2\\,]$，种子 $8$。\n\n输出格式：\n- 你的程序应生成单行输出，其中包含一个结果列表，每个测试用例一个结果，顺序与上面相同。\n- 每个结果必须是 $[\\,\\text{is\\_sorted}, C(A), D(A)\\,]$ 形式的列表，其中 $\\text{is\\_sorted}$ 为 True 或 False，而 $C(A)$ 和 $D(A)$ 为整数。\n- 整体输出必须是单行：一个由这些按测试用例排列的列表组成的、以逗号分隔的列表，并用方括号括起来。例如：$[\\,[\\text{True},10,4],[\\text{False},6,3]\\,]$。\n\n不得读取任何外部输入；所有数据必须嵌入程序中。此任务不涉及物理单位、角度或百分比；所有输出均为布尔值和整数。", "solution": "问题陈述已经过验证，被认为是合理的。它在计算机科学领域内提出了一个定义明确的算法分析任务，该任务基于正式定义和客观标准。问题是自包含的、一致的，并具有科学依据。我们可以开始求解。\n\n任务是分析一个采用 Lomuto 分区方案错误变体的随机化快速排序算法。分析要求推导出关键字比较总数 $C(A)$、最大递归深度 $D(A)$，以及该算法是否能正确排序数组。\n\n让我们从对大小为 $n = r - \\ell + 1$ 的子数组 $A[\\ell..r]$ 的错误分区过程进行正式分析开始。\n\n1.  **错误分区逻辑分析**\n\n错误分区过程定义如下：\n- 从 $A[\\ell..r]$ 中均匀随机选择一个主元，并将其交换到 $A[r]$。\n- 一个索引 $i$ 被初始化为 $\\ell$。\n- 一个循环以索引 $j$ 从 $\\ell$ 到 $r-1$ 迭代。迭代次数为 $(r-1) - \\ell + 1 = r-\\ell = n-1$。\n- 在循环内部，执行一次 $A[j]$ 与主元的比较。\n- 关键的是，索引 $i$ 在*每次*迭代中都会递增，无论比较结果如何。\n- 循环完成后，将 $A[i]$ 与位于 $A[r]$ 的主元交换，并返回 $i$。\n\n让我们追踪索引 $i$ 的值。它从 $i \\leftarrow \\ell$ 开始，并被递增 $n-1$ 次。因此，在循环终止时，$i$ 的最终值为 $\\ell + (n-1) = \\ell + (r-\\ell) = r$。\n\n让我们仔细检查交换操作：\n- 循环内部的条件交换是 `swap(A[i], A[j])`。在第 $k$ 次迭代开始时（对于 $k = 0, \\dots, n-2$），$j$ 的值是 $\\ell+k$。由于 $i$ 每次迭代都递增，在第 $k$ 次迭代时，$i$ 的值也是 $\\ell+k$。因此，交换操作是 `swap(A[\\ell+k], A[\\ell+k])`，这是一个空操作。这意味着，尽管有 `if` 条件和 `swap` 调用，$A[\\ell..r-1]$ 中元素的相对顺序永远不会改变。\n- 最后的交换是 `swap(A[i], A[r])`。由于 $i$ 的最终值是 $r$，这变成了 `swap(A[r], A[r])`，这也是一个空操作。\n\n对 $A[\\ell..r]$ 调用一次这个错误分区操作的净效果是：\n- 从 $A[\\ell..r]$ 中随机选择的一个元素被移动到位置 $A[r]$。\n- 其他 $n-1$ 个元素的相对顺序保持不变。\n- 函数返回分区索引 $q=r$。\n\n2.  **递归结构和复杂度分析**\n\n快速排序的一般递归步骤是将 $A[\\ell..r]$ 分为 $A[\\ell..q-1]$ 和 $A[q+1..r]$。由于错误的分区总是返回 $q=r$，递归调用变成：\n- `quicksort(A, \\ell, r-1)`\n- `quicksort(A, r+1, r)`\n\n第二个调用 `quicksort(A, r+1, r)` 是在一个空的索引范围上进行的，因为它的起始边界大于结束边界。它会立即终止。因此，递归是线性的：对一个大小为 $n$ 的子数组的调用导致对一个大小为 $n-1$ 的子数组的单个递归调用。这是可能的最不平衡的分区，是快速排序最坏情况性能的特征。\n\n- **总比较次数 $C(A)$**：对大小为 $k > 1$ 的子数组进行一次分区调用会执行恰好 $k-1$ 次比较（从 $\\ell$ 到 $r-1$ 的每个 $j$ 一次）。对于一个大小为 $n$ 的初始数组，该算法会生成一系列对大小为 $n, n-1, n-2, \\dots, 2$ 的子数组的分区调用。对大小为 $1$ 的子数组的调用是基本情况，执行 $0$ 次比较。总比较次数是处理过的所有子数组大小的求和：\n$$ C(A) = \\sum_{k=2}^{n} (k-1) = \\sum_{j=1}^{n-1} j = \\frac{(n-1)n}{2} $$\n这是一个等差数列求和。因此，比较次数为 $\\Theta(n^2)$，并且仅由初始数组大小 $n$ 决定，与主元的选择或初始数据顺序无关。\n\n- **最大递归深度 $D(A)$**：递归过程为 `Q(n) -> Q(n-1) -> ... -> Q(2) -> Q(1)`。这形成了一个线性的递归调用链。如果初始调用 `Q(n)` 在深度 $1$，下一个调用 `Q(n-1)` 就在深度 $2$，依此类推。对大小为 $1$ 的子数组的最终基本情况调用 `Q(1)` 发生在深度 $n$。因此，最大递归深度为：\n$$ D(A) = n $$\n\n- **正确性 (`is_sorted`)**：该算法在大小为 $n$ 的数组 $A$ 上的行为可以描述如下：\n  1. 调用 `quicksort(A, 0, n-1)` 从 $A[0..n-1]$ 中随机选择一个元素，并将其交换到位置 $A[n-1]$。然后它在 `quicksort(A, 0, n-2)` 上递归。\n  2. 调用 `quicksort(A, 0, n-2)` 从当前的 $A[0..n-2]$ 中随机选择一个元素，并将其交换到位置 $A[n-2]$，然后递归。\n  3. 这个过程一直持续到子数组大小为 $1$。\n\n这个过程，即从 $k=n-1$ 向下迭代到 $1$，每次从前缀 $A[0..k]$ 中随机选择一个元素交换到位置 $A[k]$，是一个著名的算法：Fisher-Yates 洗牌算法（的向内变体）。该算法不排序数组；它会生成初始数组的一个随机排列。\n因此，最终的数组不会按非递减顺序排序，除非在两种特定情况下：a) 输入数组由相同的元素组成（例如 $[5,5,5]$），此时任何排列都是有序的。b) 生成的随机排列恰好是有序的，对于一个有 $k$ 个不同元素的数组，这种情况发生的概率极小（如 $1/k!$），对于非平凡的输入来说可以忽略不计。\n\n总之，这个错误的快速排序不是一个排序算法，而是一个洗牌算法，其在比较次数方面的运行时间是确定的平方级，在递归深度方面的空间复杂度是线性的。下面的程序实现了这个算法及其插桩，以根据提供的测试用例验证这些发现。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef _faulty_partition(arr, l, r, state, rng):\n    \"\"\"\n    Implements the faulty Lomuto partition scheme.\n    - Increments index `i` on every iteration.\n    - Returns the partition index.\n    \"\"\"\n    # Select a pivot index uniformly at random and swap the pivot to the end.\n    pivot_idx = rng.integers(low=l, high=r, endpoint=True)\n    arr[pivot_idx], arr[r] = arr[r], arr[pivot_idx]\n    pivot_value = arr[r]\n    \n    i = l\n    # Loop from l to r-1.\n    for j in range(l, r):\n        # Perform one comparison between an element and the pivot.\n        state['comparisons'] += 1\n        \n        # If A[j] is less than the pivot, swap A[i] and A[j].\n        if arr[j]  pivot_value:\n            arr[i], arr[j] = arr[j], arr[i]\n        \n        # The incorrect step: increment i on every iteration.\n        i += 1\n        \n    # After the loop, swap the pivot (at A[r]) into its final position A[i].\n    arr[i], arr[r] = arr[r], arr[i]\n    \n    return i\n\ndef _quicksort_recursive(arr, l, r, state, depth, rng):\n    \"\"\"\n    The recursive helper for the faulty randomized quicksort.\n    - Tracks comparisons and recursion depth.\n    \"\"\"\n    # Update the maximum observed depth.\n    state['max_depth'] = max(state['max_depth'], depth)\n    \n    # Base case: if the subarray has 0 or 1 elements, terminate.\n    if l >= r:\n        return\n        \n    # Partition the array and get the pivot's final index.\n    q = _faulty_partition(arr, l, r, state, rng)\n    \n    # Recursively sort the two subarrays.\n    _quicksort_recursive(arr, l, q - 1, state, depth + 1, rng)\n    _quicksort_recursive(arr, q + 1, r, state, depth + 1, rng)\n\n\ndef run_faulty_quicksort(arr_initial, seed):\n    \"\"\"\n    This function orchestrates the execution of the faulty quicksort for a single test case.\n    It initializes state, runs the algorithm, and returns the measured results.\n    \"\"\"\n    arr = list(arr_initial) # Create a mutable copy.\n    rng = np.random.default_rng(seed)\n    n = len(arr)\n    \n    # State dictionary to hold metrics. Passed by reference to recursive calls.\n    state = {'comparisons': 0, 'max_depth': 0 if n == 0 else 1}\n    \n    if n > 0:\n        # Initial call to the recursive quicksort function. Depth starts at 1.\n        _quicksort_recursive(arr, 0, n - 1, state, 1, rng)\n    \n    # Check if the resulting array is sorted in nondecreasing order.\n    is_sorted = all(arr[i] = arr[i+1] for i in range(n - 1))\n    \n    return [is_sorted, state['comparisons'], state['max_depth']]\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final output.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        ([3, 1, 4, 1, 5, 9, 2, 6], 42),\n        ([1, 2, 3, 4, 5, 6, 7, 8], 0),\n        ([8, 7, 6, 5, 4, 3, 2, 1], 123),\n        ([5, 5, 5, 5, 5], 2024),\n        ([2], 8),\n    ]\n\n    results = []\n    for arr, seed in test_cases:\n        result = run_faulty_quicksort(arr, seed)\n        results.append(result)\n\n    # Format the results into the exact string required by the problem statement.\n    # e.g., [[True,10,5],[False,28,8]]\n    # str(list) adds spaces, so we format it manually.\n    result_strings = []\n    for r in results:\n        # str(True) -> \"True\", str(False) -> \"False\"\n        result_strings.append(f\"[{str(r[0])},{r[1]},{r[2]}]\")\n        \n    final_output = f\"[{','.join(result_strings)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "3263703"}, {"introduction": "我们已经掌握了排序和调试，现在让我们看看快速排序的核心思想——分区——如何被用于解决排序以外的问题。一个经典例子就是计算数组中的“逆序对”数量。这项练习 [@problem_id:3263559] 展示了分治思想的强大威力与灵活性，你将学习如何修改分区步骤，使其不仅能分组元素，还能在过程中计算关于元素相对顺序的信息，从而证明快速排序的结构是一个通用的问题解决模板。", "problem": "您的任务是设计并实现一个随机分治过程，该过程修改经典的随机化快速排序算法，以计算整数输入数组的精确逆序对数量。一个逆序对被定义为一对索引 $(i,j)$，满足 $0 \\le i  j  n$ 且 $A[i] > A[j]$。随机化快速排序的基础是从当前子数组中均匀随机地选择一个主元，在线性时间内执行一次划分，并对严格的子问题进行递归。您的修改必须仅使用随机化快速排序的划分和递归结构来计算原始数组的逆序对数量，不得引入任何平衡树、芬威克树（Fenwick tree）、基于归并的计数方法，或超出划分所必需的多次独立遍历。该方法必须是精确的。\n\n从以下基本原理开始：\n- 逆序对的定义为满足 $i  j$ 且 $A[i] > A[j]$ 的一对索引 $(i, j)$。\n- 分治策略涉及选择一个主元 $p$，将数组划分为三个子集：$S_L = \\{x \\in A \\mid x  p\\}$、$S_E = \\{x \\in A \\mid x = p\\}$ 和 $S_G = \\{x \\in A \\mid x > p\\}$。\n- 逆序对总数是子集内部逆序对与跨子集逆序对的和。子集内部的逆序对可以通过递归调用计算。\n- 您的任务是在单次遍历中有效地计算跨子集的逆序对，同时构建用于递归的子数组。\n\n实现一个函数 `count_inversions_quicksort(arr)`，它接收一个整数列表并返回逆序对的总数。该算法的随机性应来自均匀随机地选择主元。\n\n为以下测试用例计算逆序对的数量。为保证可复现性，请在程序开始时使用固定的随机种子（例如 42）。由于算法是精确的，主元的随机选择不应影响最终的逆序对计数。\n- 测试用例 1: `[]`\n- 测试用例 2: `[1]`\n- 测试用例 3: `[1, 2, 3, 4, 5]`\n- 测试用例 4: `[5, 4, 3, 2, 1]`\n- 测试用例 5: `[2, 3, 2, 3, 2]`\n- 测试用例 6: `[3, -1, 2, 2, -1, 3]`\n- 测试用例 7: `[7, 1, 5, 3, 6, 4, 2]`\n- 测试用例 8: `[5, 5, 5, 5]`\n\n您的程序必须生成一个单行输出，该输出是一个包含所有测试用例结果的整数列表，用逗号分隔，并用方括号括起来。例如：`[0,0,0,10,4,8,16,0]`。", "solution": "该问题要求设计一种算法来计算整数数组中的逆序对数量，并遵循随机化快速排序算法的结构框架。逆序对是指一对索引 $(i, j)$，满足 $i  j$ 且 $A[i] > A[j]$，其中 $A$ 是输入数组。解决方案必须是精确的，且不得使用基于归并排序的计数方法或如芬威克树（Fenwick tree）之类的辅助数据结构。\n\n分治算法的基本原理是将一个问题分解为更小的、独立的子问题，递归地解决它们，然后合并它们的结果以获得原始问题的解。对于逆序对计数，设 $I(A)$ 为数组 $A$ 中的逆序对总数。如果我们从 $A$ 中选择一个主元 $p$，我们可以将 $A$ 的元素划分为三个子集：$S_L = \\{x \\in A \\mid x  p\\}$、$S_E = \\{x \\in A \\mid x = p\\}$ 和 $S_G = \\{x \\in A \\mid x > p\\}$。\n\n逆序对总数可以表示为这些子集内部的逆序对数量与来自不同子集的元素之间的逆序对数量之和：\n$$I(A) = I(S_L) + I(S_E) + I(S_G) + I_{\\text{cross}}$$\n其中 $I(S_L)$、$I(S_E)$ 和 $I(S_G)$ 代表数对中的两个元素都属于同一子集的逆序对，而 $I_{\\text{cross}}$ 代表两个元素属于不同子集的逆序对。\n\n- 快速排序的递归结构自然地处理了子集内部的逆序对。如果我们构建数组 $A_L$ 和 $A_G$，使其包含 $S_L$ 和 $S_G$ 的元素，同时保持它们在原始数组 $A$ 中的相对顺序，那么它们的逆序对数量可以通过递归调用找到：$I(S_L) = \\text{CountInversions}(A_L)$ 和 $I(S_G) = \\text{CountInversions}(A_G)$。\n- $S_E$ 内部的逆序对数量 $I(S_E)$ 必须为 $0$，因为所有元素都相等。\n\n问题的核心是在划分步骤中高效地计算 $I_{\\text{cross}}$。一个跨子集逆序对 $(u, v)$ 意味着 $u > v$，且 $u$ 和 $v$ 属于不同的划分组。这可能发生在以下情况：\n1. $u \\in S_G, v \\in S_L$ (因为 $u > p > v$)\n2. $u \\in S_E, v \\in S_L$ (因为 $u = p > v$)\n3. $u \\in S_G, v \\in S_E$ (因为 $u > p = v$)\n\n简单地将集合大小相乘（例如 $|S_G| \\times |S_L|$）是不正确的，因为它没有考虑元素的原始位置 $(i  j)$。\n\n为了在单次遍历中正确计算 $I_{\\text{cross}}$，我们可以维护到目前为止所见过的等于主元 ($c_E$) 和大于主元 ($c_G$) 的元素计数。当我们从左到右以索引 $i=0, 1, \\dots, n-1$ 遍历数组 $A$ 时：\n- 如果 $A[i]  p$：元素 $A[i]$ 小于任何先前见过的等于或大于 $p$ 的元素。由于 $A[i]$ 出现在它们之后，它与这些元素中的每一个都形成一个逆序对。这样的逆序对数量为 $c_E + c_G$。\n- 如果 $A[i] = p$：元素 $A[i]$ 小于任何先前见过的大于 $p$ 的元素。它与这些元素中的每一个都形成一个逆序对。这样的逆序对数量为 $c_G$。然后我们增加 $c_E$。\n- 如果 $A[i] > p$：$A[i]$ 大于任何先前见过的小于或等于 $p$ 的元素，所以它不能作为逆序对的第二个元素 $(u, A[i])$ 与这些元素构成跨子集的逆序对。我们只需增加 $c_G$。\n\n通过在一次线性扫描中累加这些计数，我们可以计算出 $I_{\\text{cross}}$ 的总和。在同一次扫描中，我们可以将元素分配到 $S_L$ 和 $S_G$ 对应的子数组中，以供递归调用。\n\n算法流程如下：\n1. 基本情况：如果数组大小为 0 或 1，返回 0 个逆序对。\n2. 随机选择一个主元 $p$。\n3. 初始化 `cross_inversions = 0`, `count_equal = 0`, `count_greater = 0`，以及两个空列表 `less_arr`, `greater_arr`。\n4. 遍历输入数组中的每个元素 `x`：\n   - 若 `x  p`，则 `cross_inversions += count_equal + count_greater`，并将 `x` 添加到 `less_arr`。\n   - 若 `x == p`，则 `cross_inversions += count_greater`，并递增 `count_equal`。\n   - 若 `x > p`，则递增 `count_greater`，并将 `x` 添加到 `greater_arr`。\n5. 递归计算 `inversions_less = count_inversions_quicksort(less_arr)` 和 `inversions_greater = count_inversions_quicksort(greater_arr)`。\n6. 返回 `cross_inversions + inversions_less + inversions_greater`。\n\n该算法的期望时间复杂度与随机化快速排序相同，为 $O(n \\log n)$，并且它精确地计算了逆序对的数量，同时严格遵循了所要求的基于划分的结构。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef count_inversions_quicksort(arr: list[int]) -> int:\n    \"\"\"\n    Computes the inversion count of an array using a randomized quicksort-based\n    divide-and-conquer approach.\n\n    An inversion is a pair of indices (i, j) such that i  j and arr[i] > arr[j].\n\n    The algorithm works by:\n    1. Handling the base case for recursion (arrays with 0 or 1 element).\n    2. Selecting a random pivot from the array.\n    3. Initializing counters for cross-inversions and elements in partition groups.\n    4. Performing a single linear scan over the array to:\n       a. Count cross-inversions formed by elements being separated by the pivot.\n       b. Build the subarrays for the recursive calls ('less than pivot' and 'greater than pivot').\n    5. Recursively calling the function on the subarrays.\n    6. Summing the counts from the recursive calls and the cross-inversions.\n\n    Args:\n        arr: A list of integers.\n\n    Returns:\n        The total number of inversions in the array.\n    \"\"\"\n    n = len(arr)\n    if n = 1:\n        return 0\n\n    # Step 2: Select a random pivot.\n    # Using np.random.choice as per the execution environment.\n    # The choice of pivot does not affect the correctness of the final count.\n    pivot_idx = np.random.randint(0, n)\n    pivot = arr[pivot_idx]\n\n    # Step 3, 4: Initialize counters and lists for subproblems.\n    cross_inversions = 0\n    count_equal = 0\n    count_greater = 0\n    \n    less_arr = []\n    greater_arr = []\n\n    # Step 5: Perform a single pass to count cross-inversions and create sub-arrays.\n    for x in arr:\n        if x  pivot:\n            # This element x forms an inversion with any preceding element u > x\n            # that is separated by the pivot. These are precisely the elements previously\n            # seen that are equal to or greater than the pivot.\n            cross_inversions += count_equal + count_greater\n            less_arr.append(x)\n        elif x == pivot:\n            # This element x forms an inversion with any preceding element u > x\n            # that is separated by the pivot. These are the elements greater than the pivot.\n            cross_inversions += count_greater\n            count_equal += 1\n        else:  # x > pivot\n            # This element cannot form a cross-inversion (u, x) with u preceding x,\n            # as any preceding element u would only be in a different partition group\n            # if u = pivot  x, which does not satisfy u > x.\n            count_greater += 1\n            greater_arr.append(x)\n\n    # Step 6: Recursive calls on strict subproblems.\n    inversions_less = count_inversions_quicksort(less_arr)\n    inversions_greater = count_inversions_quicksort(greater_arr)\n\n    # Step 7: Combine results.\n    return cross_inversions + inversions_less + inversions_greater\n\ndef solve():\n    \"\"\"\n    Runs the inversion counting algorithm on the specified test suite\n    and prints the results in the required format.\n    \"\"\"\n    # Seed for reproducibility, though the algorithm is exact regardless of pivot choices.\n    np.random.seed(42)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        [],\n        [1],\n        [1, 2, 3, 4, 5],\n        [5, 4, 3, 2, 1],\n        [2, 3, 2, 3, 2],\n        [3, -1, 2, 2, -1, 3],\n        [7, 1, 5, 3, 6, 4, 2],\n        [5, 5, 5, 5],\n    ]\n\n    results = []\n    for case in test_cases:\n        arr_list = list(case)\n        result = count_inversions_quicksort(arr_list)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3263559"}]}