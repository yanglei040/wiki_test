{"hands_on_practices": [{"introduction": "我们将从一个基本任务开始：从数组中移除特定元素。这项常见的操作为我们提供了一个清晰的平台，可以并排比较节约空间的“原地”压缩算法和简单直接的“非原地”过滤算法。这个练习旨在帮助你量化内存使用和操作复杂度（在此例中为写操作次数）之间的直接权衡。[@problem_id:3241063]", "problem": "设计并分析两种算法，用于从一个数组中移除所有等于给定值 $x$ 的元素，同时保留剩余元素的原始相对顺序。请使用以下基础概念：原地算法的定义是其在输入数据结构之外使用 $O(1)$ 额外空间的算法；算法稳定性的概念是保持相等元素的原始顺序；以及一个简单的操作模型，其中“写”操作是任何将值存入数组单元的赋值。目标是定义一个精确的写操作计数度量，并比较一个原地稳定紧凑算法与一个非原地稳定过滤算法。\n\n要求：\n- 实现一个原地稳定紧凑算法，该算法使用两个索引将保留的元素向左移动。该算法必须在 $O(1)$ 的额外内存下运行，并且不得分配与输入长度成正比的辅助数组。当且仅当它将值存储到目标数组单元格中，且目标索引与源索引不同时，才应计算一次写操作，从而排除冗余的自我赋值。不要计算任何对紧凑后前缀之外的单元格的写操作，也不要计算任何内存释放或大小调整。\n- 实现一个非原地稳定过滤算法，该算法通过追加每个不等于 $x$ 的元素来构建一个新数组。每次向新数组中追加操作计为一次写操作。忽略对原始数组的任何写操作。\n\n设 $n$ 表示数组长度，设 $m$ 表示等于 $x$ 的元素数量，设 $f$ 表示匹配项的比例，使得 $f = m/n$。设 $k = n - m$ 表示保留的元素数量。原地算法必须保持稳定性。非原地算法必须保持稳定性。两种算法都必须根据定义的规则通过写操作次数进行评估。\n\n测试套件：\n- 案例 A：$n = 10$，$f = 0.3$，数组 $A = \\{\\,$ $1$, $2$, $0$, $3$, $4$, $0$, $5$, $0$, $6$, $7$ $\\}$，其中 $x = 0$。\n- 案例 B：$n = 10$，$f = 0.0$，数组 $B = \\{\\,$ $1$, $2$, $3$, $4$, $5$, $6$, $7$, $8$, $9$, $10$ $\\}$，其中 $x = 0$。\n- 案例 C：$n = 8$，$f = 1.0$，数组 $C = \\{\\,$ $0$, $0$, $0$, $0$, $0$, $0$, $0$, $0$ $\\}$，其中 $x = 0$。\n- 案例 D：$n = 12$，$f = 0.5$，数组 $D = \\{\\,$ $0$, $0$, $0$, $0$, $0$, $0$, $1$, $2$, $3$, $4$, $5$, $6$ $\\}$，其中 $x = 0$。\n- 案例 E：$n = 12$，$f = 0.25$，数组 $E = \\{\\,$ $1$, $2$, $3$, $4$, $5$, $6$, $7$, $8$, $9$, $0$, $0$, $0$ $\\}$，其中 $x = 0$。\n\n您的程序必须为每个案例计算一个包含两个元素的列表，其中包含写操作次数 $[W_{\\text{in}}, W_{\\text{out}}]$，$W_{\\text{in}}$ 是原地算法的写操作次数，$W_{\\text{out}}$ 是非原地算法的写操作次数。最终输出格式必须是单行，包含一个由这些双元素列表组成的逗号分隔列表，并用方括号括起来。例如，格式为 $[\\,[a_1, b_1], [a_2, b_2]\\,]$，其中 $a_i$ 和 $b_i$ 是整数。\n\n您的程序应生成单行输出，其中包含结果，格式为一个逗号分隔的列表，并用方括号括起来，每个案例的结果格式化为一个双元素列表 $[W_{\\text{in}},W_{\\text{out}}]$（例如，`[[5,7],[0,10],[0,0]]`）。", "solution": "该问题要求对两种用于从数组中移除所有出现的 `$x$` 值的稳定算法进行比较分析。比较基于一个为原地紧凑算法和非原地过滤算法精确定义的写操作计数度量。\n\n设 `$n$` 为输入数组的长度，`$m$` 为等于 `$x$` 的元素数量，`$k = n - m$` 为要保留的元素数量。\n\n### 算法1：非原地稳定过滤算法\n\n该算法构建一个新数组来存储结果。它遍历输入数组，对于每个不等于 `$x$` 的元素，将其追加到新数组中。\n\n**稳定性：** 这种方法本质上是稳定的。元素按其原始顺序从源数组中读取，被保留的元素以相同的序列写入目标数组，从而保留它们初始的相对顺序。\n\n**空间复杂度：** 该算法需要一个新数组来存储 `$k$` 个保留的元素。因此，其辅助空间复杂度为 `$O(k)`$，在 `$m=0$` 的情况下，最高可达 `$O(n)`$。根据定义，这是一个非原地算法。\n\n**写操作计数 ($W_{\\text{out}}$)：** 问题将此算法的写操作计数定义为每次向新数组追加操作计为一次写操作。由于恰好有 `$k = n - m$` 个元素被保留和追加，所以总写操作次数精确为 `$k$`。\n$$W_{\\text{out}} = k = n - m$$\n\n### 算法2：原地稳定紧凑算法\n\n此算法在原地修改数组，使用 `$O(1)$` 的额外空间。它采用双索引策略。一个“读”索引，我们称之为 `$i$`，从索引 `$0$` 到 `$n-1$` 扫描整个数组。一个“写”索引，我们称之为 `$j$`，跟踪下一个可用于保留元素的位置。\n\n过程如下：\n1. 初始化写索引 `$j = 0$`。\n2. 使用读索引 `$i$` 从 `$0$` 迭代到 `$n-1$`。\n3. 如果 `$A[i]`$ 处的元素不等于 `$x$`，则必须保留它。\n4. 此元素被放置在位置 `$A[j]`$。根据问题的规则，仅当源索引和目标索引不同时（即 `$i \\neq j$`）才计算一次写操作。\n5. 在 `$A[j]`$ 处放置一个保留元素后，写索引 `$j$` 递增。\n\n**稳定性：** 此算法是稳定的。假设 `$A[p]`$ 和 `$A[q]`$ 是两个要保留的元素，原始索引为 `$p  q$`。读索引 `$i$` 会在遇到 `$A[q]`$ 之前遇到 `$A[p]`$。假设 `$A[p]`$ 被写入 `$A[j_1]`$。然后写索引递增。当读索引稍后遇到 `$A[q]`$ 时，它将被写入 `$A[j_2]`$，其中 `$j_2 > j_1$`。因此，原始的相对顺序得以保留。\n\n**写操作计数 ($W_{\\text{in}}$)：** 仅当 `$i \\neq j$` 时，才会为索引 `$i$` 处的保留元素计算一次写操作。索引 `$i$` 和 `$j$` 从 `$0$` 开始，只要遇到的每个元素都被保留，它们就会一起递增。当第一次在索引 `$i_{rem}$` 处找到要移除的元素（值为 `$x$`）时，读索引 `$i$` 增加，而写索引 `$j$` 不增加。从这一点开始，对于任何后续索引 `$i > i_{rem}$` 的元素，都将满足 `$i > j$`。因此，每个出现在*第一次出现 x 之后*的保留元素都将从位置 `$i$` 移动到一个新的位置 `$j  i$`，这需要一次写操作。任何出现在第一个 `$x$` 之前的保留元素都将有 `$i=j$`，从而不产生写操作。\n\n因此，`$W_{\\text{in}}$` 是位于数组中第一次出现 `$x$` 的索引处或之后的保留元素的数量。如果没有等于 `$x$` 的元素，则 `$W_{\\text{in}} = 0$`。\n\n### 应用于测试案例\n\n我们将这些推导出的计数规则应用于每个测试案例。\n\n**案例 A：** `$A = \\{1, 2, 0, 3, 4, 0, 5, 0, 6, 7\\}, x = 0$。\n- `$n = 10$, $m = 3$，所以 $k = n - m = 7$。\n- `$W_{\\text{out}} = k = 7$`。\n- `$x=0$` 首次出现在索引 `$2$` 处。在索引 `$2$` 或之后出现的保留元素是 `$3, 4, 5, 6, 7$`。共有 `$5$` 个这样的元素。\n- `$W_{\\text{in}} = 5$`。\n- 结果：`[$5$, $7$]`\n\n**案例 B：** `$B = \\{1, 2, 3, 4, 5, 6, 7, 8, 9, 10\\}, x = 0$。\n- `$n = 10$, $m = 0$，所以 $k = n - m = 10$。\n- `$W_{\\text{out}} = k = 10$`。\n- 值 `$x=0$` 未出现在数组中。对于原地算法，条件 `$i \\neq j$` 永远不会为真。\n- `$W_{\\text{in}} = 0$`。\n- 结果：`[$0$, $10$]`\n\n**案例 C：** `$C = \\{0, 0, 0, 0, 0, 0, 0, 0\\}, x = 0$。\n- `$n = 8$, $m = 8$，所以 $k = n - m = 0$。\n- `$W_{\\text{out}} = k = 0$`。\n- 没有要保留的元素。原地算法的内部循环条件永远不会满足。\n- `$W_{\\text{in}} = 0$`。\n- 结果：`[$0$, $0$]`\n\n**案例 D：** `$D = \\{0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6\\}, x = 0$。\n- `$n = 12$, $m = 6$，所以 $k = n - m = 6$。\n- `$W_{\\text{out}} = k = 6$`。\n- `$x=0$` 首次出现在索引 `$0$` 处。所有 `$6$` 个保留元素（`$1, 2, 3, 4, 5, 6$`）都出现在此索引之后。\n- `$W_{\\text{in}} = 6$`。\n- 结果：`[$6$, $6$]`\n\n**案例 E：** `$E = \\{1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 0, 0\\}, x = 0$。\n- `$n = 12$, $m = 3$，所以 $k = n - m = 9$。\n- `$W_{\\text{out}} = k = 9$`。\n- `$x=0$` 首次出现在索引 `$9$` 处。在此索引或之后没有保留的元素。\n- `$W_{\\text{in}} = 0$`。\n- 结果：`[$0$, $9$]`", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_inplace_writes(arr: np.ndarray, x: int) - int:\n    \"\"\"\n    Calculates the number of writes for the in-place stable compaction algorithm.\n\n    A write is counted if a kept element is moved to a new position,\n    i.e., its source index `i` is not equal to its destination index `j`.\n    This happens for every kept element that appears after the first\n    occurrence of the value `x`.\n    \"\"\"\n    writes = 0\n    write_idx = 0\n    for read_idx in range(len(arr)):\n        if arr[read_idx] != x:\n            if read_idx != write_idx:\n                writes += 1\n            write_idx += 1\n    return writes\n\ndef calculate_outofplace_writes(arr: np.ndarray, x: int) - int:\n    \"\"\"\n    Calculates the number of writes for the out-of-place stable filter.\n\n    A write is counted for each element appended to the new array.\n    This is equal to the number of elements that are not equal to `x`.\n    \"\"\"\n    # Number of elements to keep is n - m, where m is count of x.\n    n = len(arr)\n    m = np.count_nonzero(arr == x)\n    k = n - m\n    return k\n\ndef solve():\n    \"\"\"\n    Executes the analysis for all test cases and prints the final result.\n    \"\"\"\n    test_cases = [\n        (np.array([1, 2, 0, 3, 4, 0, 5, 0, 6, 7]), 0),  # Case A\n        (np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]), 0), # Case B\n        (np.array([0, 0, 0, 0, 0, 0, 0, 0]), 0),       # Case C\n        (np.array([0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6]), 0), # Case D\n        (np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 0, 0]), 0)  # Case E\n    ]\n\n    results = []\n    for arr, x in test_cases:\n        w_in = calculate_inplace_writes(arr, x)\n        w_out = calculate_outofplace_writes(arr, x)\n        results.append(f\"[{w_in},{w_out}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3241063"}, {"introduction": "接下来，我们处理一个更复杂的问题：列表去重。这个问题将引导我们探索算法设计选择如何不仅影响空间和时间，还影响元素的原始顺序等其他属性。通过对比使用辅助哈希集的直观“非原地”方法与利用排序的巧妙“原地”策略，本练习突出了在保留顺序和节省空间之间的权衡。[@problem_id:3241056]", "problem": "要求您形式化并量化一种使用辅助集合的非原地列表去重算法与一种先排序再用双指针扫描的原地算法之间的权衡。工作在一个模型中，该模型将整数列表表示在随机存取存储器中，并且您可以对整数应用全序关系和相等关系。\n\n从核心定义开始：\n- 如果一个算法除了输入之外，最多使用常数个与输入大小无关的额外元素大小的内存位置，则称该算法为原地算法。如果一个算法的额外内存使用量随输入大小的增长而增长，则称其为非原地算法。\n- 去重算法是一个将列表进行转换的过程，使得结果中每个不同的值只出现一次。\n\n您的任务是在相同的输入上实现并分析两种去重策略：\n\n1. 非原地策略。该策略从左到右迭代，使用一个辅助集合跟踪已见过的值，并将每个首次出现的值写入一个新列表。此方法保留了首次出现的顺序。\n\n2. 原地策略。该策略首先使用一种仅依赖整数全序关系、且最多使用常数个额外元素大小内存位置的原地比较排序算法对数组进行排序。然后，它执行一次线性的双指针扫描，以原地方式紧凑化已排序的数组，使得每个不同的值仅在数组的前端部分出现一次。\n\n您必须根据基本操作和内存模型的精确定义，量化以下指标：\n\n- 比较是指对两个最初来自输入列表的元素调用整数全序关系或相等关系的任何操作。每次这样的使用计为一次比较。对于使用哈希集合的非原地策略，不要将哈希计算或哈希表探测计为比较；在此定义下，其比较次数计为零。\n\n- 写入是指将输入元素的值赋给原始列表或算法新分配的辅助列表中某个位置的任何操作。交换两个元素计为两次写入，因为它对两个位置进行了赋值。向新分配的列表追加一个值计为一次写入。\n\n- 额外空间是指算法执行期间，在输入数组之外分配的元素大小槽位的最大数量，以元素为单位进行度量，并忽略常数因子（如固定数量的标量变量）。对于非原地算法，将辅助集合建模为每个不同输入值存储一个元素槽位，生成的唯一值列表也为每个不同输入值存储一个元素槽位，总共为 $2u$ 个，其中 $u$ 是输入中不同元素的数量。对于原地算法，将额外空间视为 $0$，因为排序是原地的，且双指针扫描仅使用常数个索引变量。\n\n正确性要求：\n- 设 $n$ 为输入大小，$u$ 为输入中不同值的数量。非原地算法必须返回一个长度为 $u$ 的列表，并保留首次出现的顺序。原地算法必须转换输入，使得前 $u$ 个位置恰好包含所有不同的值，其顺序可能因排序而与原始顺序不同。为了验证，只需确保非原地算法结果中的值集合与原地算法结果中前 $u$ 个位置的值集合相等，并且两者的长度都为 $u$。\n\n设计约束：\n- 原地排序子程序必须是真正的原地比较排序。除了常数个元素大小的临时变量外，您不能使用任何外部内存；例如，原地堆排序 (heapsort) 是可接受的。然后，双指针扫描以线性时间运行。\n\n待执行的测试套件：\n- 使用以下整数输入列表：\n  - 用例 A：$[3,1,2,3,2,4,5,1,3]$\n  - 用例 B：$[]$\n  - 用例 C：$[5,4,3,2,1]$\n  - 用例 D：$[7,7,7,7]$\n  - 用例 E：$[0,-1,-1,2,-3,2,0,0,-3,5]$\n  - 用例 F：$[1,1,2,2,3,3,3,4]$\n  - 用例 G：$[9,8,8,7,6,6,6,5,5,4,3,3,2,1,1]$\n\n每个测试用例的必需输出：\n- 对于每个用例，生成一个包含八个值的列表：\n  - $L_{\\mathrm{out}}$：非原地唯一值列表的长度（一个整数）。\n  - $L_{\\mathrm{in}}$：排序和扫描后原地唯一值前缀的长度（一个整数）。\n  - $E$：一个布尔值，当且仅当两个结果中的值集合相等且 $L_{\\mathrm{out}} = L_{\\mathrm{in}}$ 时为真。\n  - $S_{\\mathrm{out}}$：非原地算法的额外空间（以元素为单位），建模为 $2L_{\\mathrm{out}}$（一个整数）。\n  - $S_{\\mathrm{in}}$：原地算法的额外空间（以元素为单位），建模为 $0$（一个整数）。\n  - $W_{\\mathrm{out}}$：非原地算法的总写入次数（一个整数）。\n  - $W_{\\mathrm{in}}$：原地算法的总写入次数，包括排序交换和原地紧凑化写入（一个整数）。\n  - $C_{\\mathrm{in}}$：原地算法的总比较次数，包括排序比较和扫描中的相等性检查（一个整数）。对于非原地算法，在所述模型下，比较次数视为 $0$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个逗号分隔的列表，该列表用方括号括起来，每个元素是对应一个测试用例（按 A 到 G 的顺序）的八值列表。例如，最外层结构必须类似于 `[[\\dots],[\\dots],\\dots]`，程序不应插入任何空格。内部的值必须是指定的布尔值和整数。不应打印任何其他文本。", "solution": "我们从基本原理出发，将正确性和资源使用建立在原地算法、非原地算法、全序关系和元素大小内存槽位的核心定义之上。\n\n使用辅助集合的非原地去重算法的正确性源于集合的基本属性：集合不包含重复项并支持插入测试。从左到右迭代长度为 $n$ 的输入，并维护一个已见值的集合，可以确保每个不同的值只在其首次遇到时被追加一次。因此，输出长度等于不同输入值的数量 $u$，并且输出保留了首次出现的顺序。在我们的操作模型下，我们将哈希计算和哈希表探测视为“比较”之外的操作，因为它们不调用两个输入元素上的整数全序或相等关系；因此，非原地算法的比较次数为 $0$。每次追加一个新的唯一项时，我们对辅助列表执行一次写入，所以 $W_{\\mathrm{out}} = u$。根据指定的额外空间模型，集合为每个不同元素存储一个槽位，唯一值列表也为每个不同元素存储一个元素槽位，因此额外空间为 $S_{\\mathrm{out}} = 2u$ 个元素槽位。\n\n对于原地策略，我们依赖两个组成部分。\n\n首先，像 `heapsort` 这样的原地比较排序只使用输入数组和常数个临时变量。`Heapsort` 会原地构建一个二叉堆，然后重复地将第一个元素交换到其最终位置并恢复堆属性。该算法调用输入元素的全序关系来进行堆比较，并使用交换操作，每次交换会写入两个数组位置。这满足了原地定义，因为没有分配与 $n$ 成比例的额外数组，所以额外空间 $S_{\\mathrm{in}} = 0$。其时间开销是超线性的，但我们这里的重点是量化具体的操作计数 $C_{\\mathrm{in}}$（两个输入元素之间的比较次数）和 $W_{\\mathrm{in}}$（将输入元素写入数组位置的次数），我们的实现会为提供的输入精确地统计这些数值。从数组构建堆以及后续的向下调整堆操作是一系列的两两比较和交换；每次交换写入两个数组槽位，每次堆顺序检查使用两个输入元素的全序比较，这都会计入 $C_{\\mathrm{in}}$。\n\n其次，排序后，一次双指针扫描会将相等的连续段紧凑化为一个唯一值前缀。因为数组已排序，所有重复项都位于连续的段中。我们维护一个指向最后一个唯一值位置的写入索引和一个向前扫描的读取索引。对于每个不等于上一个写入的唯一值的新值，我们推进写入索引并将当前读取的元素赋给新的写入位置。每一步都恰好使用一次两个输入元素之间的相等比较。这使得前 $u$ 个位置恰好包含每个不同值的一个副本，并且不保留任何特定的原始顺序，这在这里是可接受的。该扫描过程会贡献其自身的 $C_{\\mathrm{in}}$ 和 $W_{\\mathrm{in}}$ 计数，但只使用常数个标量，因此在我们的模型下不会产生额外的元素大小的额外空间。\n\n结果的等价性建立如下。非原地方法精确地产生输入中存在的不同值的集合。原地方法先排序，然后在数组前缀为每个相等值的连续段写入一个代表，这也精确地产生了相同的不同值集合。设 $L_{\\mathrm{out}}$ 表示非原地方法返回的长度，$L_{\\mathrm{in}}$ 表示原地方法返回的前缀长度。根据上述推理，两者都等于 $u$。因此，$E$ 为真当且仅当这些长度匹配且它们的值集合相等。我们的程序通过比较集合和长度来检查此条件。\n\n权衡直接源于这些定义。在典型的哈希表模型中，非原地方法使用期望为线性的时间（与 $n$ 相关），并使用 $S_{\\mathrm{out}} = 2u$ 个额外元素槽位，其写入次数等于 $u$。原地方法使用 $S_{\\mathrm{in}} = 0$ 个额外元素槽位，但代价是超线性的排序工作，其具体的 $C_{\\mathrm{in}}$ 和 $W_{\\mathrm{in}}$ 计数反映了堆维护和紧凑化两部分。双指针扫描本身是线性的，每个扫描位置有一次比较，在新运行段开始时最多有 $u-1$ 次紧凑化写入。\n\n为确保得到一个可度量和可测试的结果，程序实例化了指定的测试套件，并为每个用例报告元组 $[L_{\\mathrm{out}}, L_{\\mathrm{in}}, E, S_{\\mathrm{out}}, S_{\\mathrm{in}}, W_{\\mathrm{out}}, W_{\\mathrm{in}}, C_{\\mathrm{in}}]$，形式为一个布尔值和整数的列表，并按要求聚合成一个单行打印的外部列表。这个输出使得我们可以直接观察到核心的权衡：通过付出因排序而增加的比较和写入次数，将额外空间从 $2u$ 减少到 $0$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np  # Allowed library; not strictly needed but permitted.\n\nfrom typing import List, Tuple\n\nclass Counters:\n    def __init__(self):\n        self.comparisons = 0  # Count of element-to-element comparisons (order or equality)\n        self.writes = 0       # Count of element writes (assignments into array slots)\n\ndef heapsort_in_place(arr: List[int], ctr: Counters) - None:\n    \"\"\"\n    In-place heapsort on arr, updating counters:\n    - comparisons: number of element-to-element comparisons\n    - writes: number of element assignments into array slots\n    Each swap counts as two writes.\n    \"\"\"\n    n = len(arr)\n\n    def sift_down(start: int, end: int):\n        i = start\n        while True:\n            left = 2 * i + 1\n            right = left + 1\n            largest = i\n            if left  end:\n                ctr.comparisons += 1\n                if arr[left] > arr[largest]:\n                    largest = left\n            if right  end:\n                ctr.comparisons += 1\n                if arr[right] > arr[largest]:\n                    largest = right\n            if largest != i:\n                # swap arr[i] and arr[largest]\n                arr[i], arr[largest] = arr[largest], arr[i]\n                ctr.writes += 2\n                i = largest\n            else:\n                break\n\n    # Build max heap\n    # Start from the last parent node and sift down\n    for i in range(n // 2 - 1, -1, -1):\n        sift_down(i, n)\n\n    # Extract elements from heap one by one\n    for end in range(n - 1, 0, -1):\n        # Move current max to the end (swap root with end)\n        arr[0], arr[end] = arr[end], arr[0]\n        ctr.writes += 2\n        sift_down(0, end)\n\ndef dedup_out_of_place_preserve_order(arr: List[int]) - Tuple[List[int], int]:\n    \"\"\"\n    Out-of-place deduplication using an auxiliary set to preserve first occurrence order.\n    Returns (unique_list, writes), where writes is the number of appends performed.\n    By problem's comparison model, comparisons are treated as 0 for this algorithm.\n    \"\"\"\n    seen = set()\n    unique = []\n    writes = 0\n    for x in arr:\n        if x not in seen:\n            seen.add(x)\n            unique.append(x)\n            writes += 1\n    return unique, writes\n\ndef dedup_sorted_two_pointer_in_place(arr: List[int], ctr: Counters) - int:\n    \"\"\"\n    Given arr already sorted in-place, perform two-pointer sweep to compact unique values\n    into the prefix of the array. Updates counters:\n    - comparisons: equality checks between adjacent run endpoints\n    - writes: assignments when moving a newly found unique to the next write position\n    Returns the length of the unique prefix.\n    \"\"\"\n    n = len(arr)\n    if n == 0:\n        return 0\n    write_idx = 0\n    for read_idx in range(1, n):\n        ctr.comparisons += 1  # equality check\n        if arr[read_idx] != arr[write_idx]:\n            write_idx += 1\n            if write_idx != read_idx:\n                arr[write_idx] = arr[read_idx]\n                ctr.writes += 1\n    return write_idx + 1\n\ndef analyze_case(arr: List[int]) - List:\n    # Out-of-place analysis\n    out_unique, out_writes = dedup_out_of_place_preserve_order(arr)\n    L_out = len(out_unique)\n    S_out = 2 * L_out  # per model: set + unique list, one slot each per distinct element\n\n    # In-place analysis (we operate on a copy to avoid mutating the original test case)\n    in_arr = list(arr)\n    in_ctr = Counters()\n    heapsort_in_place(in_arr, in_ctr)\n    L_in = dedup_sorted_two_pointer_in_place(in_arr, in_ctr)\n    # In-place extra space per model: 0\n    S_in = 0\n\n    # Equivalence: same length and same set of distinct values\n    unique_in_place_set = set(in_arr[:L_in])\n    out_unique_set = set(out_unique)\n    equivalent = (L_out == L_in) and (unique_in_place_set == out_unique_set)\n\n    result = [\n        L_out,\n        L_in,\n        equivalent,\n        S_out,\n        S_in,\n        out_writes,\n        in_ctr.writes,\n        in_ctr.comparisons,\n    ]\n    return result\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        [3,1,2,3,2,4,5,1,3],                   # Case A\n        [],                                     # Case B\n        [5,4,3,2,1],                            # Case C\n        [7,7,7,7],                              # Case D\n        [0,-1,-1,2,-3,2,0,0,-3,5],              # Case E\n        [1,1,2,2,3,3,3,4],                      # Case F\n        [9,8,8,7,6,6,6,5,5,4,3,3,2,1,1],        # Case G\n    ]\n\n    results = []\n    for case in test_cases:\n        result = analyze_case(case)\n        results.append(result)\n\n    # Final print statement in the exact required format: single line, no spaces.\n    # Convert booleans to lowercase 'true'/'false' or keep Python's True/False?\n    # The problem statement allows booleans; Python prints True/False without quotes.\n    # We must ensure no spaces: we'll build the string manually.\n    def format_value(v):\n        if isinstance(v, bool):\n            return \"True\" if v else \"False\"\n        else:\n            return str(v)\n\n    def format_list(lst):\n        return \"[\" + \",\".join(format_value(x) for x in lst) + \"]\"\n\n    output = \"[\" + \",\".join(format_list(r) for r in results) + \"]\"\n    print(output)\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3241056"}, {"introduction": "最后，我们将通过一个高级挑战，将原地算法的概念从简单的数组扩展到链式数据结构。这个问题要求我们重用树节点的内部指针来创建一个全新的结构，这是复杂原地操作的一个标志性特征。这个练习展示了原地算法如何通过巧妙地重新利用现有内存来完成复杂的转换，挑战了我们对 $O(1)$ 额外空间能实现什么功能的认知。[@problem_id:3241084]", "problem": "你必须编写一个完整的程序，该程序针对一个固定的二叉搜索树测试套件，将每棵树转换为一个有序的双向链表，此过程只重用树节点的指针（不分配新节点），并报告可量化的检查结果。目标是展示一种原地算法，并通过可验证的标准将其与非原地方法区分开来。\n\n定义和基本基础：\n- 二叉搜索树（BST）是一种二叉树，它满足对于每个键为 $x$ 的节点，其左子树中的所有键都严格小于 $x$，其右子树中的所有键都严格大于 $x$。\n- 双向链表（DLL）是一种链式结构，其中每个节点都有一个指向其前驱和一个指向其后继的指针。在此任务中，最终链表将重用节点的左指针作为前驱指针，右指针作为后继指针。\n- 如果一个算法在转换数据结构时，除了常数个指针变量外，只使用 $O(1)$ 的额外空间，并且不分配新节点，则该算法是原地的。非原地转换会分配新节点来构建目标结构，因此不会重用原始节点。\n\n你必须从第一性原理出发进行推导：\n- 利用BST的性质以及一个经过充分检验的事实：对BST进行中序遍历会以非递减的键顺序访问节点（由于键是唯一的，这里是严格递增）。将此与原地操作的逻辑约束相结合，即重用现有节点指针来形成DLL，而不分配新节点。\n- 设计一个算法，按排序顺序访问节点，并在访问期间重写指针，使访问过的节点按该排序顺序成为DLL的一部分。该算法必须遵守 $O(1)$ 的辅助空间使用量（不包括输入本身），并且不得分配任何新的链表节点。\n- 提供论证，说明生成的DLL是正确的（从头到尾有序）、双向一致的（每个后继节点的前驱是当前节点，反之亦然）和原地的（转换前后的节点身份集合相同）。\n\n程序要求：\n1. 使用整数键表示树节点。通过将给定序列的键使用标准的BST插入规则（如上所述的严格不等式）插入到一个初始为空的BST中来构建每棵BST，因此树的形状由插入顺序决定。所有键都是唯一的。\n2. 通过重写节点现有的左、右指针，使其分别作为前驱和后继指针，将每棵BST原地转换为DLL。\n3. 对每个测试用例，计算：\n   - 从头到尾遍历生成的DLL所获得的键列表。\n   - 一个断言双向完整性的布尔值：从尾到头的反向遍历得到的序列与正向遍历序列完全相反，头节点的前驱指针为空，尾节点的后继指针为空。\n   - 一个断言原地性的布尔值：如果 $S_{\\text{before}}$ 是转换前树中可达节点身份（内存地址）的集合，而 $S_{\\text{after}}$ 是转换后通过DLL（从头到尾）可达节点身份的集合，则 $S_{\\text{before}} = S_{\\text{after}}$。\n4. 在转换期间不得分配新节点；只允许重写指针。允许使用辅助变量，但总辅助空间必须保持在 $O(1)$。\n\n测试套件：\n- 用例 1：从插入序列 $\\langle \\rangle$ 构建的空树。\n- 用例 2：从 $\\langle 7 \\rangle$ 构建的单节点树。\n- 用例 3：平衡形状的插入顺序 $\\langle 4,2,6,1,3,5,7 \\rangle$。\n- 用例 4：右倾斜的插入顺序 $\\langle 1,2,3,4,5 \\rangle$。\n- 用例 5：左倾斜的插入顺序 $\\langle 5,4,3,2,1 \\rangle$。\n- 用例 6：混合插入顺序 $\\langle 10,5,1,7,40,30,50 \\rangle$。\n\n输出格式：\n- 你的程序应该生成单行输出，其中包含一个结果列表，每个测试用例一个结果，格式完全如下。对每个用例，输出一个三元组，包括：\n  1. 正向DLL键的整数列表。\n  2. 如上定义的双向完整性布尔值。\n  3. 如上定义的原地性布尔值。\n- 具体来说，你的程序必须打印单行：\n  \"[[forward1,bidir1,inplace1],[forward2,bidir2,inplace2],...,[forward6,bidir6,inplace6]]\"\n其中，$forwardi$ 是用例 $i$ 的整数列表，而 $bidiri$、$inplacei$ 是布尔值。\n\n约束和说明：\n- 令 $n$ 表示节点数。目标原地转换算法必须在 $O(n)$ 时间和 $O(1)$ 辅助空间内运行。不要为DLL分配任何新节点；重用原始节点及其指针。\n- 测试套件涵盖了空结构、平凡的单一节点、平衡树和倾斜树，以及一个混合形状的树，用以探查正确性和原地属性。", "solution": "该问题要求将一个二叉搜索树（BST）原地转换为一个有序的双向链表（DLL）。此问题的有效性已得到确认，因为它具有科学依据、问题表述清晰、目标明确，并且其所有组成部分都经过了形式化定义且相互一致。核心挑战在于满足原地约束，该约束被严格定义为使用 $O(1)$ 的辅助空间。这一约束使得朴素的递归解法无效，因为递归会消耗调用栈上 $O(h)$ 的空间，其中 $h$ 是树的高度。对于倾斜树，这将变为 $O(n)$（$n$ 是节点数），违反了规定的约束。\n\n### 基于原理的 $O(1)$ 空间算法设计\n\nBST的一个基本性质是，中序遍历会以键的非递减顺序访问其节点。由于问题指定了唯一的键，该顺序是严格递增的。我们的目标是将树转换为一个能反映此排序顺序的DLL。因此，算法必须执行中序遍历，并在此遍历过程中，重新连接树节点的`left`和`right`指针，使其在DLL中充当`predecessor`（前驱）和`successor`（后继）指针。\n\n为了在 $O(1)$ 辅助空间内实现中序遍历，我们必须避免使用显式栈和递归。实现这一目标的经典算法是 **Morris中序遍历**。该算法利用树自身的指针创建临时的“线索”，从而允许遍历在没有栈的情况下返回到树的上层。我们将调整这种遍历机制，以执行DLL转换所需的指针重写。\n\n算法维护一个指向当前正在处理的节点的指针，我们称之为 `$current$`，它被初始化为树的根节点 `$root$`。算法还使用一个指针 `$prev$` 来跟踪添加到DLL的最后一个节点，该节点代表正在构建的链表的尾部。最终链表的头部在访问第一个节点时由 `$head$` 指针捕获。\n\n遍历过程如下：\n\n1.  初始化 `$head = \\text{None}`，`$prev = \\text{None}`，以及 `$current = root$`。\n\n2.  循环，只要 `$current$` 不为 `None`：\n    a.  **如果 `$current$` 没有左孩子：** 这意味着 `$current$` 是中序序列中的下一个节点。我们“访问”它。\n        i.  如果 `$prev$` 存在，我们建立双向连接：`$prev.right = current$` 和 `$current.left = prev$`。\n        ii. 如果 `$prev$` 为 `None`，这意味着 `$current$` 是遍历中的第一个节点（最小的元素），所以我们设置 `$head = current$`。\n        iii. 我们更新 `$prev = current$`，将其标记为我们链表的新尾部。\n        iv. 我们移动到中序序列的下一个节点，即 `$current$` 的原始右孩子：`$current = current.right$`。\n\n    b.  **如果 `$current$` 有左孩子：** 我们还不能访问 `$current$`。我们必须先遍历其整个左子树。为了在处理完左子树后返回到 `$current$`，我们建立一个临时线索。\n        i.  找到 `$current$` 的中序前驱。这是其左子树中最右边的节点。我们称之为 `$predecessor$`。我们通过从 `$current.left$` 开始，并不断向右孩子移动，直到不能再移动为止来找到它。\n        ii. **如果线索不存在**（即 `$predecessor.right$` 为 `None`）：\n            - 我们创建线索：`$predecessor.right = current$`。\n            - 然后我们继续遍历左子树：`$current = current.left$`。\n        iii. **如果线索已经存在**（即 `$predecessor.right == current$`）：这表明我们已经完成了左子树的遍历，并通过线索返回到了 `$current$`。\n            - 首先，我们必须移除临时线索，以在重用前驱节点的右指针之前恢复其完整性。由于前驱是子树中最右边的节点，其原始右孩子总是 `None`，所以我们设置 `$predecessor.right = \\text{None}`。\n            - 现在，我们可以“访问”`$current$`。此时，节点 `$prev$`（DLL的尾部）恰好是我们刚来自的 `$predecessor$`。我们连接它们：`$prev.right = current$` 和 `$current.left = prev$`。\n            - 我们更新 `$prev = current$`。\n            - 最后，我们继续遍历 `$current$` 的原始右子树：`$current = current.right$`。\n\n这个过程会一直持续到所有节点都被访问和连接。`$head$` 指针将指向有序DLL的开头。\n\n### 属性验证\n\n-   **正确性（有序性）：** 算法是 Morris中序遍历 的直接改编，该遍历被证明能按排序顺序访问节点。由于我们按访问顺序连接节点，因此生成的DLL保证是按键排序的。\n\n-   **双向完整性：** 对于访问的每个节点 `$current$`，它都与 `$prev$` 节点相连，`$prev$` 是排序序列中紧邻的前一个节点。链接 `$prev.right = current$` 和 `$current.left = prev$` 是显式设置的，确保了双向一致性。链表的头节点（第一个被访问的节点）将没有前驱，因此其`left`指针保持为`None`。链表的尾节点（最后一个被访问的节点）将没有后继，其`right`指针在其处理步骤后保持为`None`。\n\n-   **原地性（$O(1)$ 空间）：** 该算法使用固定数量的常数个辅助指针变量（`$head$`, `$prev$`, `$current$`, `$predecessor$`）。它不使用递归栈或任何其他大小依赖于输入树大小或形状的数据结构。所有的指针操作都重用了原始树节点的 `$left$` 和 `$right$` 字段。没有分配新节点。因此，该算法严格遵守 $O(1)$ 辅助空间复杂度的要求。\n\n-   **时间复杂度（$O(n)$）：** 虽然寻找前驱的内部循环似乎增加了复杂性，但对 Morris 遍历的仔细分析表明，树中的每条边被遍历的次数是常数（在每个方向上最多两次）。因此，总时间复杂度是线性的，$O(n)$，这是最优的，因为每个节点都必须被访问。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that defines the test suite, runs the conversion and validation,\n    and prints the formatted output.\n    \"\"\"\n\n    class Node:\n        \"\"\"\n        Represents a node in the Binary Search Tree.\n        The left and right pointers will be reused for the Doubly Linked List.\n        \"\"\"\n        def __init__(self, key):\n            self.key = key\n            self.left = None\n            self.right = None\n\n        def __repr__(self):\n            # For debugging purposes\n            return f\"Node({self.key})\"\n\n    def build_bst(keys):\n        \"\"\"Builds a BST from a sequence of keys using standard insertion.\"\"\"\n        def insert(root, key):\n            if not root:\n                return Node(key)\n            if key  root.key:\n                root.left = insert(root.left, key)\n            else:  # key  root.key, as keys are distinct\n                root.right = insert(root.right, key)\n            return root\n\n        root = None\n        for key in keys:\n            root = insert(root, key)\n        return root\n\n    def get_node_identities(root):\n        \"\"\"Returns the set of memory addresses of all nodes in the tree.\"\"\"\n        if not root:\n            return set()\n        \n        identities = set()\n        queue = [root]\n        visited = {root}\n        \n        while queue:\n            node = queue.pop(0)\n            identities.add(id(node))\n            if node.left and node.left not in visited:\n                visited.add(node.left)\n                queue.append(node.left)\n            if node.right and node.right not in visited:\n                visited.add(node.right)\n                queue.append(node.right)\n        return identities\n\n    def bst_to_dll_inplace(root):\n        \"\"\"\n        Converts a BST to a sorted DLL in-place using an O(1) space algorithm\n        based on Morris In-order Traversal.\n        Returns the head of the DLL.\n        \"\"\"\n        head = None\n        prev = None\n        current = root\n\n        while current:\n            if not current.left:\n                # Visit current node\n                if not head:\n                    head = current\n                if prev:\n                    prev.right = current\n                    current.left = prev\n                prev = current\n                \n                # Move to the next node in the in-order traversal\n                current = current.right\n            else:\n                # Find in-order predecessor\n                predecessor = current.left\n                while predecessor.right and predecessor.right != current:\n                    predecessor = predecessor.right\n\n                if not predecessor.right:\n                    # Create temporary thread\n                    predecessor.right = current\n                    current = current.left\n                else: # predecessor.right == current (thread exists)\n                    # Break the thread\n                    predecessor.right = None\n                    \n                    # Visit current node (it comes after its predecessor)\n                    if prev: # prev is the predecessor\n                        prev.right = current\n                        current.left = prev\n                    \n                    prev = current\n                    \n                    # Move to the original right subtree\n                    current = current.right\n        return head\n\n    def run_test_case(insertion_sequence):\n        \"\"\"\n        Runs one full test case: builds BST, gets identities, converts, and verifies.\n        \"\"\"\n        # 1. Build BST and get pre-conversion state\n        root = build_bst(insertion_sequence)\n        s_before = get_node_identities(root)\n\n        # 2. Perform in-place conversion\n        head = bst_to_dll_inplace(root)\n\n        # 3. Perform verification checks on the resulting DLL\n        \n        # 3a. In-placeness check\n        s_after = set()\n        curr = head\n        while curr:\n            s_after.add(id(curr))\n            curr = curr.right\n        is_inplace = (s_before == s_after)\n        \n        # 3b. Forward traversal and find tail\n        forward_keys = []\n        tail = None\n        curr = head\n        while curr:\n            forward_keys.append(curr.key)\n            if not curr.right:\n                tail = curr\n            curr = curr.right\n            \n        # 3c. Bidirectional integrity check\n        is_bidir_correct = True\n        \n        # Check null termination\n        if (head and head.left is not None) or (tail and tail.right is not None):\n            is_bidir_correct = False\n        \n        # Check reverse traversal\n        if is_bidir_correct:\n            backward_keys = []\n            curr = tail\n            while curr:\n                backward_keys.append(curr.key)\n                curr = curr.left\n            \n            # For empty list, backward_keys[::-1] is still []\n            if forward_keys != backward_keys[::-1]:\n                is_bidir_correct = False\n        \n        return [forward_keys, is_bidir_correct, is_inplace]\n\n    # Fixed test suite as per the problem statement\n    test_cases = [\n        [],                            # Case 1: empty tree\n        [7],                           # Case 2: single-node tree\n        [4, 2, 6, 1, 3, 5, 7],         # Case 3: balanced-shape\n        [1, 2, 3, 4, 5],               # Case 4: right-skewed\n        [5, 4, 3, 2, 1],               # Case 5: left-skewed\n        [10, 5, 1, 7, 40, 30, 50],     # Case 6: mixed\n    ]\n\n    results = []\n    for case_keys in test_cases:\n        results.append(run_test_case(case_keys))\n\n    # Format the final output string manually to match the exact requirement\n    # \"[[forward1,bidir1,inplace1],[forward2,bidir2,inplace2],...]\"\n    # This avoids ambiguity with spaces from standard str() or repr()\n    result_strings = []\n    for fwd_keys, bidir, inplace in results:\n        fwd_str = '[' + ','.join(map(str, fwd_keys)) + ']'\n        result_strings.append(f\"[{fwd_str},{str(bidir).lower()},{str(inplace).lower()}]\")\n    \n    final_output = '[' + ','.join(result_strings) + ']'\n    # The expected output format from the problem description does not specify\n    # boolean case, but standard JSON uses lowercase. Using python's default str()\n    # would produce \"True/False\". I will stick to the problem description format.\n    # Re-reading the problem format example: `[forward1,bidir1,inplace1]`. Python's\n    # `str()` on a list will use True/False. I will adjust the code to produce lowercase.\n    \n    # After re-reading the problem description again, it does not specify lowercase booleans.\n    # The example given is abstract. Python's default string representation of booleans\n    # is `True` and `False`. Let's assume that is acceptable. My previous implementation\n    # was fine. Reverting the change to lowercase.\n\n    result_strings = []\n    for fwd_keys, bidir, inplace in results:\n        fwd_str = '[' + ','.join(map(str, fwd_keys)) + ']'\n        # Use Python's default bool representation: True / False\n        result_strings.append(f\"[{fwd_str},{str(bidir)},{str(inplace)}]\")\n    \n    final_output = '[' + ','.join(result_strings) + ']'\n    print(final_output)\n\nsolve()\n```", "id": "3241084"}]}