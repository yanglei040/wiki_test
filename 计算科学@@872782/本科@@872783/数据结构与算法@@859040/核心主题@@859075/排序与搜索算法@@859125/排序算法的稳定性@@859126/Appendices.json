{"hands_on_practices": [{"introduction": "归并排序是一种经典的“分而治之”算法，其稳定性完全取决于合并（merge）两个有序子数组时的关键细节。当来自左右两个子数组的元素键值相等时，一个看似微小的比较操作（是使用 $\\lt$ 还是 $\\le$）将决定哪个元素被优先放入结果数组，从而直接决定了算法的稳定性。这个练习将通过实现一个有缺陷版本和一个正确版本，让你亲眼见证一个字符的差异如何影响排序结果，从而将抽象的稳定性概念变得具体而深刻。[@problem_id:3273649]", "problem": "给定一个记录数组，每个记录是一个由整数键和标识符组成的对。数组长度为 $n$。目标是按键的升序对数组进行排序，同时保持键相等的记录的相对顺序，这就是稳定性的定义：对于任意索引 $i$ 和 $j$（满足 $0 \\le i  j  n$），如果键满足 $k_i = k_j$，那么在输出中，源自索引 $i$ 的记录必须在源自索引 $j$ 的记录之前。形式上，设输入序列为 $A = \\langle a_0, a_1, \\dots, a_{n-1} \\rangle$，其中每个 $a_t = (k_t, \\mathrm{id}_t)$。如果对于所有满足 $0 \\le i  j  n$ 和 $k_i = k_j$ 的 $i, j$，输出序列 $B$ 都将 $a_i$ 放在 $a_j$ 之前，则该排序算法是稳定的。\n\n考虑一个递归的分治排序过程，它使用合并操作来组合两个已排序的半区。合并操作会比较两个半区头部的键，并一次将一个记录移入输出。如果合并操作在键相等时总是从右半区选择，一个微小的错误就会破坏稳定性，这种情况可能发生在选择规则不当地使用了严格小于号时。具体来说，如果合并操作仅在左键严格小于右键时才取左侧元素，否则取右侧元素，那么当键相等时，右侧元素会被先取走，这在相等键被分割到两个半区时会破坏稳定性。\n\n任务：\n- 实现两种对 $(k, \\mathrm{id})$ 对数组的排序过程：\n  1. 一种有问题的归并排序，由于其合并操作使用严格小于号 $$ 来决定从左半区取哪个元素而导致不稳定。具体来说，在合并期间，如果左键 $k_L$ 和右键 $k_R$ 满足 $k_L  k_R$，则从左侧取；否则从右侧取。\n  2. 一种修正后的稳定归并排序，其合并操作确保当 $k_L \\le k_R$ 时从左侧取，从而在合并过程中保持键相等的记录的相对顺序。\n- 对每个测试用例，输出三项内容：\n  1. 应用有问题的归并排序后得到的标识符序列 $\\langle \\mathrm{id} \\rangle$。\n  2. 应用修正后的稳定归并排序后得到的标识符序列 $\\langle \\mathrm{id} \\rangle$。\n  3. 一个布尔值，指示修正后的稳定归并排序是否保持了键相等记录的原始相对顺序。该布尔值必须通过对每个键值 $v$，比较输入中键为 $v$ 的标识符序列与输出中键为 $v$ 的序列来计算。\n\n基础和约束：\n- 使用上面陈述的稳定性核心定义：对于所有满足 $0 \\le i  j  n$ 和 $k_i = k_j$ 的 $i, j$，输出必须将来自索引 $i$ 的元素置于来自索引 $j$ 的元素之前。\n- 目标是修正合并决策，使稳定性对所有输入都成立，并在精心选择的测试用例上展示其差异。\n\n测试套件：\n使用以下六个测试用例，每个都是一个 $(k, \\mathrm{id})$ 对的列表，其中标识符 $\\mathrm{id}$ 是其在列表中的原始位置：\n- 测试用例 1 （一般混合情况，相等键跨越两个半区）：$[(3,0),(1,1),(2,2),(1,3),(2,4),(3,5),(1,6)]$。\n- 测试用例 2 （所有键都不同）：$[(5,0),(1,1),(3,2),(4,3),(2,4)]$。\n- 测试用例 3 （所有键都相等）：$[(1,0),(1,1),(1,2),(1,3),(1,4)]$。\n- 测试用例 4 （重复块被分割到两个半区）：$[(1,0),(1,1),(2,2),(2,3),(1,4),(1,5),(2,6),(2,7)]$。\n- 测试用例 5 （空输入）：$[]$。\n- 测试用例 6 （单个元素）：$[(42,0)]$。\n\n最终输出格式：\n你的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表，其中不含空格。每个元素对应一个测试用例，其本身是一个三元组，形式为 $[L_b,L_f,S]$，其中 $L_b$ 是有问题的排序后的标识符列表，$L_f$ 是修正后的稳定排序后的标识符列表，$S$ 是对修正后排序的稳定性检查布尔值。例如，最外层的列表应形如 $[[\\dots],[\\dots],\\dots]$，且任何地方都没有空格。", "solution": "该问题要求对稳定排序和不稳定排序进行分析和实现，特别关注归并排序算法。排序的稳定性规定，具有相等键的元素在排序后的输出中必须保持其原始的相对顺序。我们将实现归并排序的两种变体：一种是故意破坏使其不稳定的，另一种是正确实现以保证其稳定性的。差异在于合并子程序中的一个比较运算符。\n\n一个排序算法被定义为稳定的，如果对于输入序列 $A = \\langle a_0, a_1, \\dots, a_{n-1} \\rangle$ 中的任意两个记录，例如 $a_i = (k_i, \\mathrm{id}_i)$ 和 $a_j = (k_j, \\mathrm{id}_j)$（其中 $0 \\le i  j  n$），条件 $k_i = k_j$ 意味着在排序后的输出序列中 $a_i$ 必须出现在 $a_j$ 之前。\n\n归并排序算法遵循分治范式：\n1.  **分解**：将大小为 $n$ 的输入数组分成两个大小约为 $n/2$ 的子数组。\n2.  **解决**：通过对两个子数组递归调用归并排序来对其进行排序。\n3.  **合并**：将两个已排序的子数组合并成一个单一的已排序数组。\n\n归并排序的稳定性完全由“合并”步骤决定，即合并操作。设要合并的两个已排序子数组为 $L$（左）和 $R$（右）。在正在处理的数组段中，$L$ 中的每个元素最初都出现在 $R$ 中每个元素之前。为了保持稳定性，如果我们遇到一个元素 $l \\in L$ 和一个元素 $r \\in R$，它们的键相等，即 $key(l) = key(r)$，那么必须将来自左子数组的元素 $l$ 放入输出中，并置于 $r$ 之前。\n\n**修正后的稳定合并逻辑**\n\n合并操作遍历 $L$ 和 $R$，重复比较两个子数组当前头部的元素，并将较小的一个移动到输出中。为确保稳定性，比较必须是非严格的。设来自 $L$ 的当前元素为 $l$，其键为 $k_L$，来自 $R$ 的当前元素为 $r$，其键为 $k_R$。稳定合并的规则是：\n\n如果 $k_L \\le k_R$，则从 $L$ 中取元素 $l$。否则，从 $R$ 中取元素 $r$。\n\n当 $k_L = k_R$ 时，此规则正确地选择了来自左子数组的元素 $l$，从而保留了原始相对顺序并保证了稳定性。\n\n**有问题的非稳定合并逻辑**\n\n问题描述了一个有错误的实现，其中比较是严格的：\n\n如果 $k_L  k_R$，则从 $L$ 中取元素 $l$。否则，从 $R$ 中取元素 $r$。\n\n我们来分析键相等的情况，即 $k_L = k_R$。条件 $k_L  k_R$ 为假。于是执行 `else` 分支，导致从右子数组中选择元素 $r$ 并将其放置在输出中 $l$ 之前。由于 $l$ 最初在 $r$ 之前，此操作颠倒了它们的相对顺序，违反了稳定性的定义。这个错误很微小，但对于那些保持原始顺序至关重要的应用来说，会产生严重后果。\n\n**稳定性验证过程**\n\n要以编程方式验证修正后算法对给定测试用例的稳定性，我们必须确认键相等的项目的相对顺序没有改变。过程如下：\n1.  对输入数组中存在的每个唯一键值 $v$，按其出现顺序构建一个包含所有具有该键的记录的标识符列表。设其为 $\\mathrm{IDs}_{\\text{input}}(v)$。\n2.  类似地，对每个唯一键值 $v$，从排序算法的输出中构建一个标识符列表。设其为 $\\mathrm{IDs}_{\\text{output}}(v)$。\n3.  当且仅当对于每个键 $v$，标识符序列都相同时，即 $\\mathrm{IDs}_{\\text{input}}(v) = \\mathrm{IDs}_{\\text{output}}(v)$，该算法才是稳定的。如果此条件对所有键都成立，则最终的布尔结果 $S$ 为真，否则为假。\n\n我们将应用这整个过程——实现两种合并变体、对测试用例进行排序以及执行稳定性检查——来展示稳定方法和不稳定方法之间的实际差异。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import defaultdict\n\ndef broken_merge(left, right):\n    \"\"\"\n    Merges two sorted numpy arrays unstably.\n    Takes the right element if keys are equal.\n    \"\"\"\n    if len(left) == 0:\n        return right\n    if len(right) == 0:\n        return left\n\n    dtype = left.dtype\n    result = np.empty(len(left) + len(right), dtype=dtype)\n    i, j, k = 0, 0, 0\n\n    while i  len(left) and j  len(right):\n        # Unstable condition: left key must be strictly less than right key\n        if left[i]['key']  right[j]['key']:\n            result[k] = left[i]\n            i += 1\n        else: # This includes the case left['key'] >= right['key']\n            result[k] = right[j]\n            j += 1\n        k += 1\n\n    while i  len(left):\n        result[k] = left[i]\n        i += 1\n        k += 1\n\n    while j  len(right):\n        result[k] = right[j]\n        j += 1\n        k += 1\n\n    return result\n\ndef stable_merge(left, right):\n    \"\"\"\n    Merges two sorted numpy arrays stably.\n    Takes the left element if keys are equal or less.\n    \"\"\"\n    if len(left) == 0:\n        return right\n    if len(right) == 0:\n        return left\n\n    dtype = left.dtype\n    result = np.empty(len(left) + len(right), dtype=dtype)\n    i, j, k = 0, 0, 0\n\n    while i  len(left) and j  len(right):\n        # Stable condition: left key is less than or equal to right key\n        if left[i]['key'] = right[j]['key']:\n            result[k] = left[i]\n            i += 1\n        else:\n            result[k] = right[j]\n            j += 1\n        k += 1\n\n    while i  len(left):\n        result[k] = left[i]\n        i += 1\n        k += 1\n\n    while j  len(right):\n        result[k] = right[j]\n        j += 1\n        k += 1\n\n    return result\n\ndef mergesort(arr, merge_func):\n    \"\"\"\n    Recursive mergesort implementation using a provided merge function.\n    \"\"\"\n    if len(arr) = 1:\n        return arr\n\n    mid = len(arr) // 2\n    left = mergesort(arr[:mid], merge_func)\n    right = mergesort(arr[mid:], merge_func)\n\n    return merge_func(left, right)\n\ndef check_stability(original_arr, sorted_arr):\n    \"\"\"\n    Verifies if the sort was stable by comparing relative order of equal-keyed items.\n    \"\"\"\n    if len(original_arr) == 0:\n        return True\n        \n    original_groups = defaultdict(list)\n    for record in original_arr:\n        original_groups[record['key']].append(record['id'])\n\n    sorted_groups = defaultdict(list)\n    for record in sorted_arr:\n        sorted_groups[record['key']].append(record['id'])\n\n    for key in original_groups:\n        if original_groups[key] != sorted_groups[key]:\n            return False\n            \n    return True\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        [(3,0),(1,1),(2,2),(1,3),(2,4),(3,5),(1,6)],\n        [(5,0),(1,1),(3,2),(4,3),(2,4)],\n        [(1,0),(1,1),(1,2),(1,3),(1,4)],\n        [(1,0),(1,1),(2,2),(2,3),(1,4),(1,5),(2,6),(2,7)],\n        [],\n        [(42,0)],\n    ]\n\n    dtype = [('key', int), ('id', int)]\n    results = []\n    \n    for case in test_cases:\n        if not case:\n            # Handle empty list case\n            results.append([[], [], True])\n            continue\n\n        arr = np.array(case, dtype=dtype)\n        \n        # 1. Broken mergesort\n        broken_sorted_arr = mergesort(arr.copy(), broken_merge)\n        L_b = broken_sorted_arr['id'].tolist()\n\n        # 2. Corrected stable mergesort\n        stable_sorted_arr = mergesort(arr.copy(), stable_merge)\n        L_f = stable_sorted_arr['id'].tolist()\n        \n        # 3. Stability check\n        S = check_stability(arr, stable_sorted_arr)\n        \n        results.append([L_b, L_f, S])\n\n    # Final print statement in the exact required format (no spaces).\n    results_str_parts = []\n    for L_b, L_f, S in results:\n        lb_str = f\"[{','.join(map(str, L_b))}]\"\n        lf_str = f\"[{','.join(map(str, L_f))}]\"\n        s_str = 'True' if S else 'False'\n        results_str_parts.append(f\"[{lb_str},{lf_str},{s_str}]\")\n    \n    final_output = f\"[{','.join(results_str_parts)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "3273649"}, {"introduction": "在探索了基于比较的排序后，我们转向一种完全不同的思路：计数排序。该算法不通过比较元素，而是利用键的频率来直接计算每个元素在输出数组中的最终位置。本练习的挑战在于，如何将基础的计数排序改造为一个能处理通用数据记录（而不仅仅是整数）的稳定版本。你将通过实践发现，确保稳定性的关键在于放置元素阶段的一个精妙技巧：从后向前遍历输入数组。[@problem_id:3273671]", "problem": "您的任务是设计并实现一个基于整数键频率计数的稳定排序算法，用于对通用记录（对象）序列进行排序。目标是根据提取的整数键进行排序，同时保持具有相同键的记录之间的相对顺序。您必须实现一个完整的、可运行的程序，该程序构建指定的测试套件，应用您的排序过程，验证每个测试用例的正确性和稳定性，并以所需的聚合输出格式打印结果。\n\n用作推理和验证基础的定义：\n- 一个排序算法接收一个长度为 $n$ 的序列 $S$，并生成一个排列 $S'$，使得所选的键函数 $K$ 在 $S'$ 上是非递减的。形式上，对于所有索引 $i$（$0 \\le i  n-1$），都有 $K(S'[i]) \\le K(S'[i+1])$。\n- 一个排序算法是稳定的，如果对于任意两个记录 $x$ 和 $y$，当 $K(x) = K(y)$ 且 $x$ 在原始序列 $S$ 中出现在 $y$ 之前时，$x$ 在输出序列 $S'$ 中也出现在 $y$ 之前。\n\n要求的行为和约束：\n- 您的算法必须能对任意记录进行排序，每个记录至少包含一个标识符字段、一个键字段和一个任意的有效载荷字段。键字段是由一个提取函数 $K$ 生成的整数。\n- 假设键是指定闭区间 $[k_{\\min}, k_{\\max}]$ 内的整数。如果任何记录的键超出了 $[k_{\\min}, k_{\\max}]$，则将该情况视为无效，并报告该测试用例失败。\n- 该算法必须是稳定的，并且必须基于对键的频率计数（即，使用键域上的计数来确定位置）。它必须通过适当地处理键范围 $[k_{\\min}, k_{\\max}]$ 来支持负数键。\n\n每个测试用例的验证标准：\n- 有序性：输出序列 $S'$ 必须对所有有效索引 $i$ 满足 $K(S'[i]) \\le K(S'[i+1])$。\n- 稳定性：对于键域中的每个值 $v$，考虑 $S$ 中键等于 $v$ 的标识符子序列。在输出 $S'$ 中，与键 $v$ 相关联的标识符必须以与 $S$ 中完全相同的相对顺序出现。\n\n需要实现的测试套件：\n使用以下六个测试用例。每个记录被描述为一个三元组 $(\\text{id}, \\text{key}, \\text{payload})$，其中 $\\text{id}$ 是唯一标识符，$\\text{key}$ 是整数键，$\\text{payload}$ 是任意字符串。\n\n- 测试用例 1（一般情况，包含重复和多个键，正常路径）：\n  - 序列 $S_1$：$(\\text{id}=0,\\text{key}=3,\\text{payload}='a')$, $(\\text{id}=1,\\text{key}=1,\\text{payload}='b')$, $(\\text{id}=2,\\text{key}=2,\\text{payload}='c')$, $(\\text{id}=3,\\text{key}=1,\\text{payload}='d')$, $(\\text{id}=4,\\text{key}=3,\\text{payload}='e')$, $(\\text{id}=5,\\text{key}=0,\\text{payload}='f')$, $(\\text{id}=6,\\text{key}=2,\\text{payload}='g')$, $(\\text{id}=7,\\text{key}=0,\\text{payload}='h')$, $(\\text{id}=8,\\text{key}=3,\\text{payload}='i')$.\n  - 范围：$[k_{\\min}, k_{\\max}] = [0, 3]$.\n\n- 测试用例 2（所有键相等，测试纯粹的稳定性）：\n  - 序列 $S_2$：$(\\text{id}=0,\\text{key}=5,\\text{payload}='x')$, $(\\text{id}=1,\\text{key}=5,\\text{payload}='y')$, $(\\text{id}=2,\\text{key}=5,\\text{payload}='z')$.\n  - 范围：$[k_{\\min}, k_{\\max}] = [5, 5]$.\n\n- 测试用例 3（负数到正数键，边界覆盖）：\n  - 序列 $S_3$：$(\\text{id}=0,\\text{key}=-3,\\text{payload}='a')$, $(\\text{id}=1,\\text{key}=-1,\\text{payload}='b')$, $(\\text{id}=2,\\text{key}=-3,\\text{payload}='c')$, $(\\text{id}=3,\\text{key}=0,\\text{payload}='d')$, $(\\text{id}=4,\\text{key}=2,\\text{payload}='e')$, $(\\text{id}=5,\\text{key}=-1,\\text{payload}='f')$.\n  - 范围：$[k_{\\min}, k_{\\max}] = [-3, 2]$.\n\n- 测试用例 4（空序列，边缘情况）：\n  - 序列 $S_4$：空序列。\n  - 范围：$[k_{\\min}, k_{\\max}] = [0, 0]$.\n\n- 测试用例 5（因键超出范围而无效，错误检测）：\n  - 序列 $S_5$：$(\\text{id}=0,\\text{key}=0,\\text{payload}='a')$, $(\\text{id}=1,\\text{key}=10,\\text{payload}='b')$, $(\\text{id}=2,\\text{key}=5,\\text{payload}='c')$.\n  - 范围：$[k_{\\min}, k_{\\max}] = [0, 5]$.\n  - 一个记录的 $\\text{key} = 10$，超出了 $[0, 5]$。此测试用例的预期布尔值为失败。\n\n- 测试用例 6（键域中有间隙的非连续键）：\n  - 序列 $S_6$：$(\\text{id}=0,\\text{key}=4,\\text{payload}='a')$, $(\\text{id}=1,\\text{key}=0,\\text{payload}='b')$, $(\\text{id}=2,\\text{key}=4,\\text{payload}='c')$, $(\\text{id}=3,\\text{key}=2,\\text{payload}='d')$, $(\\text{id}=4,\\text{key}=2,\\text{payload}='e')$, $(\\text{id}=5,\\text{key}=0,\\text{payload}='f')$.\n  - 范围：$[k_{\\min}, k_{\\max}] = [0, 4]$.\n\n程序输出规范：\n- 对于每个测试用例 $i \\in \\{1, 2, 3, 4, 5, 6\\}$，计算一个布尔值，该值为 true 当且仅当：\n  - 排序结果按键非递减，并且\n  - 排序结果保持了键相等记录的相对顺序（稳定性），并且\n  - 所有键都在指定的范围 $[k_{\\min}, k_{\\max}]$ 内。\n  否则，该布尔值必须为 false。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，“[true,false,true,...]”）。对列表中的每个条目使用编程语言的原生布尔格式。不应打印任何额外的文本。", "solution": "该问题要求设计并实现一个基于键频率计数的稳定排序算法，适用于带有整数键的记录序列。实现必须根据有序性、稳定性以及对指定键范围 $[k_{\\min}, k_{\\max}]$ 的遵守情况进行验证。\n\n指定的要求直接导向了对**计数排序**（Counting Sort）算法的改编。标准的计数排序是为已知有界范围内的整数设计的。为满足问题的约束，我们必须将其推广以处理任意记录类型，确保稳定性，并管理可能包含负数的键范围 $[k_{\\min}, k_{\\max}]$。\n\n对于给定的长度为 $n$ 的输入序列 $S$ 和键范围 $[k_{\\min}, k_{\\max}]$，验证和排序过程按以下步骤进行。\n\n**步骤 1：输入验证（键范围检查）**\n这是排序的先决条件。算法必须首先遍历输入序列 $S$，以确保所有记录的键都在指定的闭区间 $[k_{\\min}, k_{\\max}]$ 内。\n令 $x$ 为 $S$ 中的一个记录，令 $K(x)$ 为其整数键。我们必须验证对于所有 $x \\in S$，条件 $k_{\\min} \\le K(x) \\le k_{\\max}$ 均成立。如果任何记录违反了此条件，则该测试用例被视为无效，并且该用例的处理以 `false` 结果终止。\n\n**步骤 2：算法设计 - 稳定计数排序**\n\n如果输入有效，我们继续使用计数排序的稳定变体。核心思想是使用一个辅助数组来存储每个键的计数，然后利用这些计数来确定每个记录在最终排序序列中的正确位置。为了处理任意整数范围 $[k_{\\min}, k_{\\max}]$，我们将键映射到从零开始的索引。\n\n设键域的大小为 $L = k_{\\max} - k_{\\min} + 1$。我们将使用一个大小为 $L$ 的辅助数组 `counts`。输入中的键 $k$ 将映射到此数组中的索引 $i = k - k_{\\min}$。\n\n**2a. 频率计数**\n我们创建一个大小为 $L$ 的 `counts` 数组，并用全零初始化。然后我们遍历输入序列 $S$。对于每个记录 $x$，我们增加其键 $K(x)$ 对应的计数。\n`counts[K(x) - k_{min}] \\leftarrow counts[K(x) - k_{min}] + 1`\n\n在此阶段之后，`counts[i]` 存储了键为 $k = i + k_{\\min}$ 的记录数量。\n\n**2b. 累积位置计算（前缀和）**\n为了确定最终位置，我们将 `counts` 数组转换为一个存储每个键组*结束*位置的结构。这通过计算前缀和来实现。\n`for i from 1 to L-1:`\n  `counts[i] \\leftarrow counts[i] + counts[i-1]`\n\n经过此转换后，`counts[i]` 持有键小于或等于 $k = i + k_{\\min}$ 的记录总数。这个值对应于排序输出中键为 $k$ 的记录的最后一个位置的索引*再加一*。例如，如果 `counts[i] = 5`，这意味着键为 $k=i+k_{\\min}$ 的记录应占据直到索引 $4$ 的位置。\n\n**2c. 输出放置与稳定性**\n我们创建一个与输入 $S$ 大小相同（为 $n$）的新输出序列 $S'$。为确保稳定性，我们必须通过**逆序**遍历原始输入序列 $S$（从索引 $n-1$ 向下到 $0$）来将记录放入 $S'$。\n\n对于逆序处理的每个记录 $x_j$（在 $S$ 中的索引为 $j$）：\n1. 提取其键 $k = K(x_j)$。\n2. 计算 `counts` 数组中对应的索引：$i = k - k_{\\min}$。\n3. 该记录在输出序列中的起始位置由 `counts[i] - 1` 给出。\n4. 将记录 $x_j$ 放入输出序列中：$S'[counts[i] - 1] \\leftarrow x_j$。\n5. 将该键的计数减一：`counts[i] \\leftarrow counts[i] - 1`。这确保了遇到的下一个具有相同键的记录（它在原始序列 $S$ 中必须出现得更早）将被放置在紧邻的前一个位置，从而保持它们的相对顺序。\n\n这种逆序放置是保证稳定性的关键机制。\n\n**步骤 3：验证**\n在生成排序后的序列 $S'$ 后，我们必须根据问题的标准验证其正确性。\n\n**3a. 有序性验证**\n从索引 $j = 0$ 到 $n-2$ 遍历 $S'$，并确认对于所有 $j$ 都满足 $K(S'[j]) \\le K(S'[j+1])$。任何一个违反都将使结果无效。\n\n**3b. 稳定性验证**\n要验证稳定性，我们必须确认具有相同键的记录的相对顺序得以保留。这可以通过以下方式完成：\n1. 对于输入中存在的每个不同的键值 $k$，从 $S$ 中提取具有该键的记录的标识符子序列。令其为 $ID_{orig}(k)$。\n2. 同样地，对于每个键值 $k$，从排序后的输出 $S'$ 中提取具有该键的标识符子序列。令其为 $ID_{sorted}(k)$。\n3. 当且仅当对于所有的键值 $k$ 都有 $ID_{orig}(k) = ID_{sorted}(k)$ 时，排序是稳定的。\n\n如果初始范围检查、有序性检查和稳定性检查都通过，则该测试用例的结果为 `true`。否则，为 `false`。对于空输入序列，所有检查都无条件通过，结果为 `true`。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import defaultdict\n\ndef solve():\n    \"\"\"\n    Main function to define, run, and verify test cases for the stable counting sort.\n    \"\"\"\n\n    # Record is represented as a dictionary: {'id': int, 'key': int, 'payload': str}\n    \n    # Test case 1 (general case with duplicates and multiple keys, happy path)\n    s1 = [\n        {'id': 0, 'key': 3, 'payload': 'a'}, {'id': 1, 'key': 1, 'payload': 'b'},\n        {'id': 2, 'key': 2, 'payload': 'c'}, {'id': 3, 'key': 1, 'payload': 'd'},\n        {'id': 4, 'key': 3, 'payload': 'e'}, {'id': 5, 'key': 0, 'payload': 'f'},\n        {'id': 6, 'key': 2, 'payload': 'g'}, {'id': 7, 'key': 0, 'payload': 'h'},\n        {'id': 8, 'key': 3, 'payload': 'i'}\n    ]\n    r1 = (0, 3)\n\n    # Test case 2 (all keys equal, tests pure stability)\n    s2 = [\n        {'id': 0, 'key': 5, 'payload': 'x'}, {'id': 1, 'key': 5, 'payload': 'y'},\n        {'id': 2, 'key': 5, 'payload': 'z'}\n    ]\n    r2 = (5, 5)\n\n    # Test case 3 (negative to positive keys, boundary coverage)\n    s3 = [\n        {'id': 0, 'key': -3, 'payload': 'a'}, {'id': 1, 'key': -1, 'payload': 'b'},\n        {'id': 2, 'key': -3, 'payload': 'c'}, {'id': 3, 'key': 0, 'payload': 'd'},\n        {'id': 4, 'key': 2, 'payload': 'e'}, {'id': 5, 'key': -1, 'payload': 'f'}\n    ]\n    r3 = (-3, 2)\n\n    # Test case 4 (empty sequence, edge case)\n    s4 = []\n    r4 = (0, 0)\n    \n    # Test case 5 (invalid due to out-of-range key, error detection)\n    s5 = [\n        {'id': 0, 'key': 0, 'payload': 'a'}, {'id': 1, 'key': 10, 'payload': 'b'},\n        {'id': 2, 'key': 5, 'payload': 'c'}\n    ]\n    r5 = (0, 5)\n\n    # Test case 6 (non-contiguous keys with gaps in the key domain)\n    s6 = [\n        {'id': 0, 'key': 4, 'payload': 'a'}, {'id': 1, 'key': 0, 'payload': 'b'},\n        {'id': 2, 'key': 4, 'payload': 'c'}, {'id': 3, 'key': 2, 'payload': 'd'},\n        {'id': 4, 'key': 2, 'payload': 'e'}, {'id': 5, 'key': 0, 'payload': 'f'}\n    ]\n    r6 = (0, 4)\n\n    test_cases = [\n        (s1, r1), (s2, r2), (s3, r3), (s4, r4), (s5, r5), (s6, r6)\n    ]\n\n    results = []\n    for sequence, key_range in test_cases:\n        result = run_and_verify(sequence, key_range)\n        results.append(str(result).lower()) # Python bools are Capitalized\n\n    print(f\"[{','.join(results)}]\")\n\ndef stable_counting_sort(sequence, k_min, k_max):\n    \"\"\"\n    Implements a stable counting sort for a sequence of records.\n    Assumes keys have already been validated to be within the range [k_min, k_max].\n    \"\"\"\n    n = len(sequence)\n    if n == 0:\n        return []\n\n    range_size = k_max - k_min + 1\n    counts = np.zeros(range_size, dtype=int)\n    \n    # 1. Frequency Counting\n    for record in sequence:\n        key = record['key']\n        counts[key - k_min] += 1\n\n    # 2. Cumulative Position Calculation\n    for i in range(1, range_size):\n        counts[i] += counts[i-1]\n\n    # 3. Output Placement\n    output = [None] * n\n    for i in range(n - 1, -1, -1):\n        record = sequence[i]\n        key = record['key']\n        \n        pos_index = key - k_min\n        output_pos = counts[pos_index] - 1\n        \n        output[output_pos] = record\n        counts[pos_index] -= 1\n        \n    return output\n\ndef run_and_verify(sequence, key_range):\n    \"\"\"\n    Runs the sorting and verifies sortedness, stability, and key range constraints.\n    Returns a single boolean indicating if all criteria are met.\n    \"\"\"\n    k_min, k_max = key_range\n    \n    # 1. Key Range Validation\n    for record in sequence:\n        if not (k_min = record['key'] = k_max):\n            return False\n\n    # Handle empty sequence edge case\n    if not sequence:\n        return True\n\n    # Get sorted sequence\n    sorted_sequence = stable_counting_sort(list(sequence), k_min, k_max)\n    \n    # 2. Sortedness Verification\n    for i in range(len(sorted_sequence) - 1):\n        if sorted_sequence[i]['key'] > sorted_sequence[i+1]['key']:\n            return False\n            \n    # 3. Stability Verification\n    original_order = defaultdict(list)\n    for record in sequence:\n        original_order[record['key']].append(record['id'])\n        \n    sorted_order = defaultdict(list)\n    for record in sorted_sequence:\n        sorted_order[record['key']].append(record['id'])\n        \n    for key in original_order:\n        if original_order[key] != sorted_order[key]:\n            return False\n            \n    # All checks passed\n    return True\n\nsolve()\n```", "id": "3273671"}, {"introduction": "我们已经亲手实现了稳定的排序算法，现在让我们换一个角度，从“实现者”变为“审查员”。本练习不再要求你编写排序算法，而是给你一个初始数组和一系列交换操作，让你判断这个过程是否符合一个稳定排序算法的行为准则。要完成这个任务，你必须深入理解稳定性的形式化定义，即基于（键，原始位置）的字典序比较。通过在每一步都应用这个核心准则，你将能从最基本的操作层面，彻底掌握稳定性的本质。[@problem_id:3273737]", "problem": "给定一个初始记录数组和一个有限的交换操作序列。每个记录都有一个键和一个隐式的初始位置，即它在初始数组中的索引。如果对于任意两个键值相等的记录，它们在输出中的相对顺序与输入中相同，则该排序算法称为稳定算法。用形式化的术语来说，设每个记录用 $x$ 表示，其键为 $\\kappa(x)$，初始位置为 $\\tau(x)$。通过字典序规则定义稳定比较器顺序 $\\prec_{\\text{stab}}$：对于任意两个记录 $x$ 和 $y$，$x \\prec_{\\text{stab}} y$ 当且仅当 $\\left(\\kappa(x),\\tau(x)\\right)$ 在字典序上小于 $\\left(\\kappa(y),\\tau(y)\\right)$。一系列只交换相对于 $\\prec_{\\text{stab}}$ 乱序的相邻记录的相邻交换操作，构成了一个稳定的相邻交换排序过程的规范模型。这是因为这样的过程从不违背键值相等记录的初始位置来重新排序它们，并且会严格减少 $\\prec_{\\text{stab}}$ 下的逆序数，直到数组按 $\\prec_{\\text{stab}}$ 排序为止。\n\n你将收到几个测试用例。对于每个测试用例，你必须判断所提供的交换序列是否可能由某个在给定输入上运行的稳定相邻交换排序算法生成。一个交换序列是可行的，当且仅当它满足以下三个条件：\n1.  **邻接性**：序列中的每次交换 $(i_t,j_t)$ 都必须在相邻位置之间进行，即 $|i_t - j_t| = 1$。\n2.  **局部乱序**：对于每次交换，设 $p = \\min(i_t,j_t)$ 和 $q = \\max(i_t,j_t)$。令 $a$ 和 $b$ 分别为交换前位于位置 $p$ 和 $q$ 的记录。必须满足 $b \\prec_{\\text{stab}} a$。\n3.  **最终有序性**：在应用所有交换后，最终的记录数组必须相对于 $\\prec_{\\text{stab}}$ 非递减排序。\n\n你的程序应该在输入上模拟这些交换并检查这些条件。\n\n测试套件：\n- 测试用例 1：键 $K = [3,1,1,2]$，交换序列 $S = [(0,1),(1,2),(2,3)]$。\n- 测试用例 2：键 $K = [2,2,1]$，交换序列 $S = [(0,1),(1,2)]$。\n- 测试用例 3：键 $K = [2,1,3]$，交换序列 $S = [(0,2)]$。\n- 测试用例 4：键 $K = [3,2,1]$，交换序列 $S = [(0,1)]$。\n- 测试用例 5：键 $K = [1,1,2,3]$，交换序列 $S = []$。\n\n输出规范：\n- 对每个测试用例，计算一个布尔值，如果交换序列是可行的则为 `true`，否则为 `false`。\n- 生成单行输出，包含一个用方括号括起来的逗号分隔的结果（例如 `[true,false,true,true,true]`）。", "solution": "我们从定义开始。一个稳定的排序算法会保留键值相等记录的相对顺序。形式上，设每个记录 $x$ 有一个键 $\\kappa(x)$ 和一个初始位置 $\\tau(x)$，并定义记录 $x$ 和 $y$ 之间的顺序 $\\prec_{\\text{stab}}$ 为：$x \\prec_{\\text{stab}} y$ 当且仅当 $\\left(\\kappa(x),\\tau(x)\\right)$ 在字典序上小于 $\\left(\\kappa(y),\\tau(y)\\right)$。这将稳定性要求转化为了输出序列相对于 $\\prec_{\\text{stab}}$ 非递减的性质。特别地，如果 $\\kappa(x)=\\kappa(y)$ 且 $\\tau(x)  \\tau(y)$，则有 $x \\prec_{\\text{stab}} y$，这确保了键值相等的记录在排序后的输出中必须以其原始顺序出现。\n\n考虑在 $\\prec_{\\text{stab}}$ 下运行的相邻交换排序过程；这样的过程在每一步检查相邻位置，并且仅当右邻居 $b$ 根据 $\\prec_{\\text{stab}}$ 严格小于左邻居 $a$ 时（即 $b \\prec_{\\text{stab}} a$），才交换它们。这是诸如冒泡排序等方法的局部规则，已知当比较操作将键值相等的元素视为非乱序时，冒泡排序是稳定的。两个关键观察确立了我们可行性标准的原则性正确性：\n\n1. 通过字典序比较器实现的局部合法性可防止以不稳定的方式重排键值相等的记录。如果两个相邻记录的键值相等，比如说 $\\kappa(a)=\\kappa(b)$，那么比较器就简化为比较 $\\tau(a)$ 和 $\\tau(b)$。因为初始的 $\\tau$ 值反映了原始顺序且永不改变，如果 $a$ 在数组中位于 $b$ 之前，则 $\\tau(a)  \\tau(b)$，因此 $a \\prec_{\\text{stab}} b$。所以 $b \\prec_{\\text{stab}} a$ 为假，一个稳定的相邻交换算法不会交换顺序正确的键值相等的邻居。因此，任何在已经按原始顺序排列的键值相等的邻居之间进行的交换都违反了局部乱序条件，我们的可行性检查会拒绝这种情况。\n\n2. 每次有效的相邻交换都会严格减少在 $\\prec_{\\text{stab}}$ 下的逆序数。定义序列 $\\left(z_0,\\dots,z_{n-1}\\right)$ 在 $\\prec_{\\text{stab}}$ 下的逆序数 $I$ 为索引对 $\\left(i,j\\right)$ 的数量，其中 $0 \\le i  j \\le n-1$ 且 $z_j \\prec_{\\text{stab}} z_i$。如果我们交换相邻元素 $a$ 和 $b$ 且 $b \\prec_{\\text{stab}} a$，那么这对元素之间的一个逆序恰好被移除，且不会在非相邻元素之间引入新的逆序，因为 $a$ 向右移动一个位置，$b$ 向左移动一个位置；关于冒泡排序正确性的标准论证形式化了这一观点：这样的相邻交换会单调递减 $I$ 直到 $I=0$，这等价于序列在 $\\prec_{\\text{stab}}$ 下被排序。\n\n基于这些原则，该可行性标准是交换序列能由一个稳定相邻交换排序算法生成的必要条件：\n\n- 邻接性 $|i_t-j_t|=1$ 确保了交换是局部邻居交换，如同在冒泡排序和类似的稳定方法中一样。\n- 局部乱序条件，交换前的 $b \\prec_{\\text{stab}} a$，确保每次交换在编码了稳定性的比较器下是合法的，从而防止交换原始顺序中键值相等的项，并保证逆序数减少。\n- 最终有序性确保了交换序列确实完成了在 $\\prec_{\\text{stab}}$ 下的排序过程。\n\n在以下意义上，它们也是充分的：如果序列中的每次交换都满足邻接性和局部合法性，并且最终数组是按 $\\prec_{\\text{stab}}$ 排序的，那么就存在一个稳定的相邻交换排序例程（例如，一个冒泡排序的变体，它只扫描并交换乱序的邻居），可以在给定的输入上精确地产生这个序列。这是因为任何以有序状态结束的合法相邻交换序列，都可以通过按照给定序列指示的顺序选择要检查的位置来实现。\n\n检查可行性的算法设计遵循这些原则：\n\n- 用数对 $\\left(\\kappa,\\tau\\right)$ 表示每个记录，其中 $\\tau$ 是初始索引。定义一个比较器，当 $\\left(\\kappa(x),\\tau(x)\\right)$ 在字典序上小于 $\\left(\\kappa(y),\\tau(y)\\right)$ 时，对于 $x \\prec_{\\text{stab}} y$ 返回真。\n- 模拟交换序列：\n  - 对于每次交换 $(i_t,j_t)$，通过检查 $|i_t-j_t|=1$ 来验证邻接性。\n  - 令 $p=\\min(i_t,j_t)$ 和 $q=\\max(i_t,j_t)$，并检查位置 $p$ 上的邻居 $a$ 和位置 $q$ 上的邻居 $b$。通过测试 $b \\prec_{\\text{stab}} a$ 来检查局部合法性；如果为假，则拒绝该序列。\n  - 执行位置 $p$ 和 $q$ 的交换。\n- 处理完所有交换后，检查最终有序性：对于每对连续位置 $(r,r+1)$，确保位置 $r$ 的记录在 $\\prec_{\\text{stab}}$ 下不大于位置 $r+1$ 的记录，等价于检查对于所有 $r$ 都有 $\\neg\\left(z_{r+1} \\prec_{\\text{stab}} z_r\\right)$。\n\n将此应用于给定的测试套件：\n\n- 测试用例 1：$K=[3,1,1,2]$, $S=[(0,1),(1,2),(2,3)]$。每次交换都是相邻且局部合法的：$3$ 与 $1$ 交换，然后 $3$ 与下一个 $1$ 交换，然后 $3$ 与 $2$ 交换。最终数组在 $\\prec_{\\text{stab}}$ 下有序，且键值相等的记录 $1$ 保持了原始顺序。结果 $\\text{True}$。\n- 测试用例 2：$K=[2,2,1]$, $S=[(0,1),(1,2)]$。第一次交换试图交换初始位置为 $\\tau=0$ 和 $\\tau=1$ 的键值相等的邻居 $2$，它们在 $\\prec_{\\text{stab}}$ 下并非乱序。局部合法性不满足。结果 $\\text{False}$。\n- 测试用例 3：$K=[2,1,3]$, $S=[(0,2)]$。由于 $|0-2|=2$，该交换不是相邻的。邻接性不满足。结果 $\\text{False}$。\n- 测试用例 4：$K=[3,2,1]$, $S=[(0,1)]$。单次交换是相邻且局部合法的（$2 \\prec_{\\text{stab}} 3$），但最终数组 $[2,3,1]$ 在 $\\prec_{\\text{stab}}$ 下并非有序。最终有序性不满足。结果 $\\text{False}$。\n- 测试用例 5：$K=[1,1,2,3]$, $S=[]$。没有执行任何交换；初始数组在 $\\prec_{\\text{stab}}$ 下已经有序。所有标准均通过。结果 $\\text{True}$。\n\n因此，程序按顺序输出每个测试用例对应的布尔值列表，用方括号括起来并以逗号分隔。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nfrom typing import List, Tuple\n\ndef stable_less(a: Tuple[int, int], b: Tuple[int, int]) -> bool:\n    \"\"\"\n    Return True iff record a is less than record b under the stable comparator.\n    Records are tuples (key, original_index).\n    Lexicographic comparison on (key, original_index).\n    \"\"\"\n    # Compare keys first, then original indices for tie-breaking.\n    if a[0] != b[0]:\n        return a[0]  b[0]\n    return a[1]  b[1]\n\ndef is_stable_adjacent_swap_sequence(keys: List[int], swaps: List[Tuple[int, int]]) -> bool:\n    \"\"\"\n    Check whether the given swap sequence could have been generated by\n    a stable adjacent-swap sorting algorithm on the given keys.\n\n    Conditions:\n    - Each swap is between adjacent positions.\n    - Each swap exchanges a locally out-of-order adjacent pair under the stable comparator.\n    - After all swaps, the array is sorted under the stable comparator.\n    \"\"\"\n    # Build records (key, original_index)\n    arr = [(k, i) for i, k in enumerate(keys)]\n\n    n = len(arr)\n\n    # Simulate swaps\n    for (i, j) in swaps:\n        # Bounds check\n        if not (0 = i  n and 0 = j  n):\n            return False\n        # Adjacency check\n        if abs(i - j) != 1:\n            return False\n\n        p = min(i, j)\n        q = max(i, j)\n        a = arr[p]\n        b = arr[q]\n\n        # Local out-of-order check: swap only if b  a under stable comparator\n        if not stable_less(b, a):\n            return False\n\n        # Perform swap\n        arr[p], arr[q] = arr[q], arr[p]\n\n    # Final sortedness check: ensure the array is nondecreasing under stable comparator\n    for r in range(n - 1):\n        if stable_less(arr[r + 1], arr[r]):\n            return False\n\n    return True\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1: Happy path, valid stable adjacent swaps (bubble-like).\n        ([3, 1, 1, 2], [(0, 1), (1, 2), (2, 3)]),\n        # Test case 2: Invalid because swapping equal-key neighbors in original order.\n        ([2, 2, 1], [(0, 1), (1, 2)]),\n        # Test case 3: Invalid due to non-adjacent swap.\n        ([2, 1, 3], [(0, 2)]),\n        # Test case 4: Valid local swap but incomplete sorting; final array not sorted.\n        ([3, 2, 1], [(0, 1)]),\n        # Test case 5: Already sorted, no swaps; valid.\n        ([1, 1, 2, 3], []),\n    ]\n\n    results = []\n    for keys, swaps in test_cases:\n        result = is_stable_adjacent_swap_sequence(keys, swaps)\n        # Python's bool `True` stringifies to \"True\", problem wants \"true\"\n        results.append(str(result).lower())\n\n    # Final print statement in the exact required format (no spaces).\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3273737"}]}