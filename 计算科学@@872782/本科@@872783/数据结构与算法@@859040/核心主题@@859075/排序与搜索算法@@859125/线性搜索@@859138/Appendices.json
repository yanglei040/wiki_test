{"hands_on_practices": [{"introduction": "线性扫描是直观的，但当数据结构变得不那么“线性”时会发生什么？这个练习将挑战我们对标准数组遍历的假设。我们将探讨如何在环形数组中执行线性搜索——数组的末尾会回绕到开头——这迫使我们仔细思考如何使用模运算来优雅地处理索引，并确保我们的算法能正确终止。[@problem_id:3244873]", "problem": "考虑一个大小为 $n$（其中 $n \\ge 1$）的整数循环数组，表示为序列 $A[0],A[1],\\dots,A[n-1]$。循环数组意味着有效位置是整数 $0,1,\\dots,n-1$，并且移动“超过”$n-1$ 后会从位置 $0$ 继续。给定一个起始位置 $s$（其中 $0 \\le s \\le n-1$）和一个目标值 $x$。设计并实现一个线性搜索的变体，该变体在循环数组中按照明确定义的遍历顺序逐个检查元素，并满足以下所有约束：它必须总是终止，它从不重复检查任何位置，如果存在索引 $i$ 使得 $A[i]=x$，则返回该索引 $i$，否则返回 $-1$。您的算法不得修改 $A$，不得重排 $A$，且只能执行顺序扫描；不准使用任何辅助搜索结构。主要效率目标是最小化元素检查次数，其中最坏情况下的检查次数恰好为 $n$，而当在检查所有位置之前找到目标时，最好情况下的检查次数严格小于 $n$。您的设计必须基于线性搜索作为顺序检查的定义以及用于循环结构索引计算的模运算性质。遍历顺序必须是 $s$ 和 $n$ 的函数，并且必须仅使用沿圆环的向前移动来明确定义。\n\n您的程序必须是自包含的，并且不使用任何外部输入。对于下面的每个测试用例，程序应将搜索结果作为一个整数输出，最终输出为单行，其中包含所有测试用例的结果，形式为逗号分隔的列表并用方括号括起来（例如，“[1,-1,4]”）。\n\n使用以下测试套件，它涵盖了典型场景、环绕行为、目标不存在、边界条件和重复值。每个测试用例是一个三元组 $(A,x,s)$，其中 $A$ 是数组，$x$ 是目标值，$s$ 是起始位置：\n- 测试用例 1：$A=[4,7,1,9,3]$，$x=9$，$s=1$。\n- 测试用例 2：$A=[5,2,8,6]$，$x=2$，$s=3$。\n- 测试用例 3：$A=[10,20,30]$，$x=15$，$s=2$。\n- 测试用例 4：$A=[42]$，$x=42$，$s=0$。\n- 测试用例 5：$A=[7,7,7,7]$，$x=7$，$s=2$。\n- 测试用例 6：$A=[3,1,4,1,5]$，$x=1$，$s=0$。\n- 测试用例 7：$A=[2,3,5,7,11]$，$x=2$，$s=4$。\n\n您的程序应生成单行输出，其中包含格式完全符合 `[r1,r2,r3,r4,r5,r6,r7]` 的结果，其中每个 $r_k$ 是根据上述规则得出的测试用例 $k$ 的整数结果。此问题不涉及物理单位、角度或百分比；所有值都是整数，并且必须纯粹作为数学和逻辑实体来处理。", "solution": "该问题要求为循环数组设计一个线性搜索算法。搜索必须从指定的起始索引 $s$ 开始，并按顺序进行，在最坏情况下每个元素恰好被检查一次。解决方案必须基于线性搜索和模运算的原理。\n\n首先，对问题陈述进行验证。\n\n**步骤 1：提取已知条件**\n-   一个大小为 $n$（其中 $n \\ge 1$）的整数数组 $A$。\n-   该数组是循环的，意味着索引在集合 $\\{0, 1, \\dots, n-1\\}$ 中，并且移动超过 $n-1$ 后会环绕到 $0$。\n-   一个起始位置 $s$，其中 $0 \\le s \\le n-1$。\n-   一个目标整数值 $x$。\n-   该算法必须是一个线性搜索的变体，逐个检查元素。\n-   遍历顺序必须明确定义，从 $s$ 开始，并且只使用向前移动。\n-   算法必须总是终止。\n-   任何位置都不能被检查超过一次。\n-   如果存在满足 $A[i]=x$ 的索引 $i$，算法必须返回该索引；否则返回 $-1$。\n-   算法不得修改或重排数组 $A$。\n-   不准使用任何辅助搜索结构。\n-   最坏情况下的元素检查次数必须恰好为 $n$。\n-   如果在检查所有位置之前找到目标，最好情况下的检查次数必须严格小于 $n$。\n-   设计必须基于线性搜索原理和模运算。\n-   提供的测试用例：\n    1.  $A=[4,7,1,9,3]$，$x=9$，$s=1$。\n    2.  $A=[5,2,8,6]$，$x=2$，$s=3$。\n    3.  $A=[10,20,30]$，$x=15$，$s=2$。\n    4.  $A=[42]$，$x=42$，$s=0$。\n    5.  $A=[7,7,7,7]$，$x=7$，$s=2$。\n    6.  $A=[3,1,4,1,5]$，$x=1$，$s=0$。\n    7.  $A=[2,3,5,7,11]$，$x=2$，$s=4$。\n\n**步骤 2：使用提取的已知条件进行验证**\n根据指定标准对问题进行评估：\n-   **科学基础**：该问题在计算机科学和数学方面有充分的依据，特别是在数据结构（数组）上的算法和数论（模运算）方面。这是一个标准的、可形式化的问题。\n-   **问题适定**：问题定义清晰，约束明确。目标（找到元素或确定其不存在）是精确的，关于搜索过程的条件（起点、遍历顺序、终止）足以定义唯一的算法策略。\n-   **客观性**：问题以精确、正式的语言陈述，没有主观性或歧义。\n-   **无缺陷**：问题没有违反任何无效性标准。它是一致的、完整的且可解的。各项约束相互兼容，并导向一个合乎逻辑的解决方案。\n\n**步骤 3：结论与行动**\n问题是**有效的**。将开发一个解决方案。\n\n**基于原理的解决方案**\n问题的核心是定义一个遍历序列，该序列从索引 $s$ 开始，并精确地访问一次大小为 $n$ 的循环数组中的每个索引。“沿圆环向前移动”的要求与线性搜索的约束相结合，自然而然地导向一个基于模运算的解决方案。\n\n设数组为 $A$，大小为 $n$。索引为 $\\{0, 1, \\dots, n-1\\}$。给定一个起始索引 $s$。搜索将通过检查索引 $s, s+1, s+2$ 等位置的元素来进行。为了处理循环的“环绕”行为，我们采用模运算符。\n\n该算法可以构建为一个迭代 $n$ 次的循环。一个循环计数器，我们称之为 $i$，将从 $0$ 运行到 $n-1$。这个计数器代表到目前为止已检查的元素数量，或者等效地，代表从起始位置 $s$ 的偏移量。\n\n对于偏移量 $i \\in \\{0, 1, \\dots, n-1\\}$ 的每个值，要检查的数组 $A$ 中的实际索引（我们称之为 $j$）计算如下：\n$$\nj = (s + i) \\pmod n\n$$\n这个公式确保了从 $s$ 开始的顺序向前扫描：\n-   当 $i=0$ 时，索引为 $j = (s+0) \\pmod n = s$。第一个检查的元素是 $A[s]$。\n-   当 $i=1$ 时，索引为 $j = (s+1) \\pmod n$。\n-   如此继续，直到 $i=n-1$，对应索引 $j = (s+n-1) \\pmod n$。\n\n索引集合 $\\{ (s+i) \\pmod n \\mid i \\in \\{0, 1, \\dots, n-1\\} \\}$ 恰好是集合 $\\{0, 1, \\dots, n-1\\}$。这是模运算的一个基本性质：将一个完全剩余系（在这里是 $\\{0, 1, \\dots, n-1\\}$）与一个常数 $s$ 相加，然后对结果取模 $n$，会产生另一个完全剩余系。因此，这种遍历保证了数组的每个元素都被精确访问一次。\n\n算法流程如下：\n1.  初始化一个迭代 $n$ 次的循环，迭代变量 $i$ 从 $0$ 到 $n-1$。\n2.  在循环内部，计算当前要检查的索引：$j = (s + i) \\pmod n$。\n3.  将此索引处的元素 $A[j]$ 与目标值 $x$ 进行比较。\n4.  如果 $A[j] = x$，则目标已找到。算法必须立即终止并返回索引 $j$。这满足了提前终止和最好情况下比较次数少于 $n$ 次的要求。\n5.  如果在检查完所有 $n$ 个位置后循环完成仍未找到目标值 $x$，则意味着 $x$ 不在数组中。在这种情况下，算法返回 $-1$。这满足了最坏情况下恰好进行 $n$ 次比较的要求。\n\n此设计满足所有问题约束：它是一个顺序扫描，使用模运算，从 $s$ 开始，每个元素访问一次，能够终止，并且在不修改数组或使用辅助搜索数据结构的情况下返回正确的结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the circular array linear search problem for a predefined suite of test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (numpy array A, target x, start_index s)\n    test_cases = [\n        (np.array([4, 7, 1, 9, 3]), 9, 1),\n        (np.array([5, 2, 8, 6]), 2, 3),\n        (np.array([10, 20, 30]), 15, 2),\n        (np.array([42]), 42, 0),\n        (np.array([7, 7, 7, 7]), 7, 2),\n        (np.array([3, 1, 4, 1, 5]), 1, 0),\n        (np.array([2, 3, 5, 7, 11]), 2, 4),\n    ]\n\n    results = []\n\n    def circular_linear_search(arr, target, start_pos):\n        \"\"\"\n        Performs a linear search on a circular array.\n\n        Args:\n            arr (np.ndarray): The circular array of integers.\n            target (int): The value to search for.\n            start_pos (int): The starting index for the search.\n\n        Returns:\n            int: The index of the first occurrence of the target found during the traversal,\n                 or -1 if the target is not in the array.\n        \"\"\"\n        n = len(arr)\n        if n == 0:\n            return -1\n\n        # The loop iterates n times to ensure every element is checked once in the worst case.\n        # The variable 'i' represents the number of steps taken from the starting position.\n        for i in range(n):\n            # Calculate the current index to check using modular arithmetic.\n            # This handles the \"wrap-around\" behavior of the circular array.\n            current_index = (start_pos + i) % n\n            \n            if arr[current_index] == target:\n                # If the target is found, return its index immediately.\n                return current_index\n        \n        # If the loop completes, the target was not found in the array.\n        return -1\n\n    for A, x, s in test_cases:\n        result = circular_linear_search(A, x, s)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3244873"}, {"introduction": "线性搜索的概念不仅限于数组。本练习将其应用到一种根本不同的数据结构——链表上，并从命令式循环转向函数式、尾递归的实现方式。这不仅是代码风格的转变，更是一次深入理解递归、算法终止性证明和尾调用优化 (TCO) 对空间复杂度影响的绝佳机会。[@problem_id:3244874]", "problem": "设计并实现一个纯函数式风格的单链表尾递归线性搜索算法，并从基本原理出发证明其终止性。该数据结构和算法的表达方式不得依赖于可变操作、副作用或迭代控制流。你需要输出目标值在列表中首次出现的索引，如果该值不存在，则输出 $-1$。你的实现应模拟在函数式语言（例如 Lisp 或 Haskell）中会采用的方法，但必须以一个完整的、可运行的程序形式提供。该函数必须是尾递归的，这意味着递归调用发生在函数体的尾部位置。\n\n推理的基本依据：\n- 单链表是归纳定义的：它要么是空的（表示为 $\\varnothing$），要么是一个包含值 $v$ 和指向另一个单链表 $L$（列表的其余部分）的指针的节点。形式上，其语法为 $L ::= \\varnothing \\mid \\mathrm{Node}(v, L)$。\n- 递归函数根据其输入的归纳结构按情况定义。尾递归是递归的一种特殊情况，其中递归调用是函数执行的最后一个操作。\n- 终止性是通过展示一个良基度量 $m$ 来建立的，该度量在每次递归调用时都严格递减，其中 $m$ 将输入映射到一个没有无限下降链的集合（例如，具有常规 $$ 关系的自然数集）。\n- 正确性是通过对输入数据结构和所需计算的定义进行结构归纳来建立的。\n\n规格说明：\n- 定义一个函数 $f(L, x)$，它返回满足 $L$ 中位置 $i$ 的值等于目标 $x$ 的最小索引 $i \\in \\mathbb{N}$（如果存在这样的位置）；否则返回 $-1$。索引从 $0$ 开始。\n- 使用一个辅助函数 $g(L, x, i)$ 来实现 $f$，该辅助函数维护一个当前索引 $i$ 并且是尾递归的：对 $g$ 的递归调用必须处于尾部位置。函数 $g$ 必须满足 $f(L, x) = g(L, x, 0)$。\n- 该算法在精神上必须是纯函数式的：没有对列表节点的修改，也没有循环。单链表应从输入序列中不可变地构建。\n- 通过确定一个良基度量 $m(L)$ 并证明每个递归步骤都使 $m$ 减小来证明终止性。\n- 证明部分正确性，表明当找到 $x$ 时返回的索引是正确的，并且当 $x$ 不在 $L$ 中时，恰好返回 $-1$。\n- 在两种执行模型下分析时间和空间复杂度：一种带有尾调用优化（Tail Call Optimization, TCO），另一种不带 TCO。\n\n测试套件：\n你必须在以下链表和目标上运行你的函数。对于每对 $(L, x)$，按规定生成索引结果。列表以有限序列的形式给出；你必须在内部将它们转换为单链表。\n1. $L = [3, 5, 7, 11]$, $x = 7$.\n2. $L = [3, 5, 7, 11]$, $x = 4$.\n3. $L = []$, $x = 10$.\n4. $L = [42]$, $x = 42$.\n5. $L = [9, 9, 9]$, $x = 9$.\n6. $L = [1, 2, 3, 4, 5]$, $x = 5$.\n7. $L = [0, -1, -2, -3]$, $x = -2$.\n8. $L = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]$, $x = 13$.\n9. $L = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24]$, $x = 30$.\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔的结果列表。对于上述九个测试用例，输出必须是 $[r_1, r_2, \\dots, r_9]$ 的形式，其中每个 $r_i$ 是测试用例 $i$ 的整数结果，打印时不带空格，例如，对于三个用例，输出为 $[0,-1,2]$。", "solution": "所述问题是有效的。它在计算机科学领域内，特别是在数据结构、算法和正确性证明方面，提出了一个明确定义的任务。该问题具有科学依据、客观、自洽且可形式化，没有矛盾或歧义。\n\n**1. 单链表的归纳定义**\n\n单链表 $L$ 由以下归纳语法定义，其中 $\\varnothing$ 代表一个空列表：\n$$L ::= \\varnothing \\mid \\mathrm{Node}(v, L)$$\n一个非空列表是一个 $\\mathrm{Node}$，它包含一个值 $v$（头节点）和一个指向另一个单链表 $L'$（尾部）的引用。空列表由一个空引用表示。\n\n**2. 算法设计：尾递归线性搜索**\n\n目标是实现一个函数 $f(L, x)$，用于查找目标值 $x$ 在列表 $L$ 中首次出现的从零开始的索引。如果未找到 $x$，则函数返回 $-1$。设计必须是尾递归的，并遵循纯函数式范式，避免可变操作和副作用。\n\n为了实现尾递归，我们定义一个辅助函数 $g(L, x, i)$ 来累积当前索引 $i$。主函数 $f(L, x)$ 通过使用初始索引 $0$ 调用此辅助函数来启动该过程：\n$$f(L, x) = g(L, x, 0)$$\n\n辅助函数 $g(L, x, i)$ 根据输入列表 $L$ 的结构按情况定义：\n\n*   **基本情况（空列表）**：如果列表为空，$L = \\varnothing$，则目标 $x$ 不存在。搜索结束，返回 $-1$。\n    $$g(\\varnothing, x, i) = -1$$\n\n*   **递归步骤（非空列表）**：如果列表非空，$L = \\mathrm{Node}(v, L')$，我们检查列表头部的值 $v$。\n    *   如果 $v=x$，则在当前索引 $i$ 处找到目标。函数返回 $i$。\n        $$g(\\mathrm{Node}(v, L'), x, i) = i \\quad \\text{if } v = x$$\n    *   如果 $v \\neq x$，则搜索必须继续到列表的其余部分 $L'$。函数对列表的尾部进行递归调用，传递相同的目标 $x$ 和递增后的索引 $i+1$。\n        $$g(\\mathrm{Node}(v, L'), x, i) = g(L', x, i+1) \\quad \\text{if } v \\neq x$$\n\n递归调用 $g(L', x, i+1)$ 是其执行路径中的最后一个操作，满足尾递归的条件。\n\n**3. 终止性证明**\n\n为了证明该算法对所有有限列表都能终止，我们必须展示一个在每次递归调用时都严格递减的良基度量。\n\n设度量 $m(L)$ 为列表 $L$ 的长度，定义如下：\n$$\n\\mathrm{len}(L) =\n\\begin{cases}\n0   \\text{if } L = \\varnothing \\\\\n1 + \\mathrm{len}(L')  \\text{if } L = \\mathrm{Node}(v, L')\n\\end{cases}\n$$\n该函数的范围是包含零的自然数集 $\\mathbb{N}_0$，它在标准“小于”关系（$$）下是良基的。\n\n在 $g$ 的定义中，唯一的递归路径发生在 $L = \\mathrm{Node}(v, L')$ 且 $v \\neq x$ 时。在这种情况下，函数以列表 $L'$ 被调用。这个新列表的长度是 $\\mathrm{len}(L') = \\mathrm{len}(L) - 1$。\n由于 $\\mathrm{len}(L')  \\mathrm{len}(L)$，该度量在每次递归调用时严格递减。由于该度量是一个非负整数，它不能无限递减。当长度变为 $0$ 时（对应于空列表的基本情况），递归保证终止。\n\n**4. 部分正确性证明**\n\n我们通过对列表 $L$ 进行结构归纳来证明，如果算法终止，它将返回正确的结果。设归纳假设 $P(L)$ 为命题：“如果 $x$ 在 $L$ 中首次出现的位置是索引 $j \\geq 0$，则 $g(L, x, i)$ 返回 $j+i$；如果 $x$ 不在 $L$ 中，则返回 $-1$。”\n\n*   **基本情况**：设 $L = \\varnothing$。函数 $g(\\varnothing, x, i)$ 返回 $-1$。这是正确的，因为空列表不包含 $x$。因此，$P(\\varnothing)$ 成立。\n\n*   **归纳步骤**：假设 $P(L')$ 对某个列表 $L'$ 成立。我们必须证明 $P(L)$ 对列表 $L = \\mathrm{Node}(v, L')$ 成立。\n    *   **情况 1：$v = x$**。这是 $L$ 的第一个元素，所以其索引为 $j=0$。函数 $g(L, x, i)$ 返回 $i$。根据我们的命题，正确的结果是 $j+i = 0+i = i$。返回值与期望值匹配，因此在这种情况下 $P(L)$ 成立。\n    *   **情况 2：$v \\neq x$**。函数返回 $g(L', x, i+1)$ 的结果。\n        *   如果 $x$ 不在 $L'$ 中出现，那么它也不在 $L$ 中出现。根据归纳假设 $P(L')$，$g(L', x, i+1)$ 返回 $-1$，这对于 $L$ 是正确的结果。\n        *   如果 $x$ 在 $L'$ 中首次出现的索引是 $j'$，那么它在原始列表 $L$ 中的索引是 $j = j' + 1$。根据归纳假设 $P(L')$，调用 $g(L', x, i+1)$ 返回 $j' + (i+1)$。代入 $j' = j - 1$，返回值是 $(j - 1) + (i + 1) = j + i$。这对于 $L$ 是正确的结果。\n\n在所有情况下，函数的行为都如命题所述。根据结构归纳原理，$P(L)$ 对所有有限列表 $L$ 都为真。鉴于主函数是 $f(L,x) = g(L,x,0)$，初始调用正确地设置了 $i=0$，因此函数返回绝对索引 $j$ 或 $-1$。\n\n**5. 复杂度分析**\n\n设 $n$ 为列表 $L$ 的长度。\n*   **时间复杂度**：算法对列表中的每个节点执行一次递归调用，直到找到目标或列表耗尽。每次调用执行常数次操作（比较、字段访问）。在最坏情况下（目标是最后一个元素或不存在），算法进行 $n+1$ 次调用。因此，时间复杂度与列表长度成线性关系，即 $O(n)$。\n\n*   **空间复杂度**：空间复杂度关键取决于编译器或解释器对尾调用优化（TCO）的支持。\n    *   **不带 TCO**：在诸如标准 Python 等环境中，未实现 TCO。每次递归调用都会在调用栈上分配一个新的栈帧。对于长度为 $n$ 的列表，在最坏情况下，最大递归深度为 $n+1$。因此，空间复杂度为 $O(n)$。\n    *   **带 TCO**：在支持 TCO 的环境（例如 Scheme、Haskell 编译器）中，尾递归调用不会消耗额外的栈空间；当前的栈帧会被重用。在空间方面，该计算等效于一个迭代循环。在此模型中，空间复杂度是常数，即 $O(1)$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# A simple class to represent a node in a singly linked list.\n# In the context of the functional algorithm, instances of this class\n# are treated as immutable (i.e., their state is not modified after creation).\nclass Node:\n    \"\"\"Represents a node in a singly linked list.\"\"\"\n    def __init__(self, value, next_node=None):\n        self.value = value\n        self.next = next_node\n\ndef from_sequence(seq):\n    \"\"\"\n    Constructs a singly linked list from a Python sequence (e.g., a list).\n    An empty sequence results in None, representing the empty list.\n    \"\"\"\n    head = None\n    # Iterate backwards to build the list from tail to head\n    for item in reversed(seq):\n        head = Node(item, head)\n    return head\n\ndef linear_search(head, target):\n    \"\"\"\n    Main function to find the index of a target in a linked list.\n    This function sets up the initial call to the tail-recursive helper.\n    Corresponds to the function f(L, x) in the formal proof.\n    \"\"\"\n    \n    def search_helper(node, current_target, index):\n        \"\"\"\n        Tail-recursive helper function that performs the search.\n        Corresponds to the function g(L, x, i) in the formal proof.\n\n        Args:\n            node: The current node in the list to examine (L).\n            current_target: The value being searched for (x).\n            index: The current index in the list (i).\n\n        Returns:\n            The index of the target if found, otherwise -1.\n        \"\"\"\n        # Base case: The list is exhausted (node is None). Target not found.\n        if node is None:\n            return -1\n        \n        # Base case: The target is found at the current node.\n        if node.value == current_target:\n            return index\n            \n        # Recursive step: The call to search_helper is the last operation.\n        # This is a tail call.\n        return search_helper(node.next, current_target, index + 1)\n\n    # Initial call to the helper with the head of the list and starting index 0.\n    return search_helper(head, target, 0)\n\ndef solve():\n    \"\"\"\n    Defines the test suite, runs the algorithm on each case,\n    and prints the results in the specified format.\n    \"\"\"\n    # The test suite provided in the problem description.\n    test_cases = [\n        # (List as a Python sequence, Target value)\n        ([3, 5, 7, 11], 7),\n        ([3, 5, 7, 11], 4),\n        ([], 10),\n        ([42], 42),\n        ([9, 9, 9], 9),\n        ([1, 2, 3, 4, 5], 5),\n        ([0, -1, -2, -3], -2),\n        ([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19], 13),\n        ([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24], 30),\n    ]\n\n    results = []\n    for py_list, target in test_cases:\n        # 1. Convert the Python list into a singly linked list data structure.\n        linked_list_head = from_sequence(py_list)\n        # 2. Run the tail-recursive linear search function.\n        result = linear_search(linked_list_head, target)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3244874"}, {"introduction": "单个线性搜索是高效的，但如果将它嵌套在另一个循环中，性能会如何变化？这个最终练习揭示了一个常见的算法性能陷阱，即 $O(n \\cdot m)$ 的复杂度。我们将通过一个实际问题——寻找两个数组的第一个公共元素——来学习一种至关重要的优化思想：使用哈希表以空间换时间，将复杂度显著降低到 $O(n+m)$。[@problem_id:3245002]", "problem": "给你两个有限的整数数组，记为 $A$ 和 $B$。令 $|A| = n$ 且 $|B| = m$，其中 $n$ 和 $m$ 为非负整数。数据结构与算法中的一个基本操作是顺序或线性搜索。给定一个目标值 $x$ 和一个数组，该操作按顺序检查数组元素，执行相等性比较，直到找到 $x$ 或断定 $x$ 不存在。另一个基本操作是基于哈希的集合中的成员资格测试，在均匀哈希假设下，该操作的每次查询预期运行时间被广泛认为是常数时间。你的任务是设计一个程序，找出 $A$ 和 $B$ 之间的第一个公共元素，其中“第一个”是根据 $A$ 中从左到右的顺序定义的。\n\n形式上，令 $A = [a_0,a_1,\\dots,a_{n-1}]$ 且 $B = [b_0,b_1,\\dots,b_{m-1}]$。定义输出三元组为 $[v,i,j]$，其中 $v$ 是 $A$ 中最早出现的（即最小的 $i$ 使得 $a_i$ 也出现在 $B$ 中）且也存在于 $B$ 中的值，$i$ 是 $v$ 在 $A$ 中的索引，$j$ 是 $v$ 在 $B$ 中最左侧出现的索引。如果不存在这样的值，程序应输出哨兵值 $[-1,-1,-1]$。朴素方法执行嵌套线性搜索：对 $A$ 中的每个 $a_i$，在线性搜索 $B$ 中查找 $a_i$；如果找到，则报告 $a_i$ 及索引 $i$ 和 $j$，否则继续。一个更好的方法是构建一个用 $B$ 的元素填充的哈希集，并为每个值单独记录其在 $B$ 中首次出现的索引，然后线性扫描 $A$ 一次，测试其在集合中的成员资格。\n\n从线性搜索的核心定义和广为接受的哈希集均匀哈希假设出发，提出、论证并实现基于哈希集的方法。你的程序必须是自包含的（无输入），使用下面的测试套件，并生成一行输出，其中包含所有测试用例的汇总结果。\n\n测试套件（数组明确显示）：\n- 案例1（正常路径）：$A = [3,5,7,9]$，$B = [10,11,5,12]$。\n- 案例2（无公共元素）：$A = [1,2,3]$，$B = [4,5]$。\n- 案例3（首个元素为公共元素）：$A = [8,1]$，$B = [8]$。\n- 案例4（两个数组中都有重复元素）：$A = [4,4,4]$，$B = [0,4,4]$。\n- 案例5（第一个数组为空）：$A = []$，$B = [1,2]$。\n- 案例6（第二个数组为空）：$A = [1,2]$，$B = []$。\n- 案例7（负数和零）：$A = [-5,-1,0,2]$，$B = [3,-1,4]$。\n\n要求的最终输出格式：\n你的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表。每个案例的结果必须是一个包含三个整数的列表 $[v,i,j]$。例如，如果只有两个案例，一个可接受的输出是 $[[5,1,2],[-1,-1,-1]]$。对于此问题，输出必须按顺序将所有七个案例的结果聚合为单个列表，例如 $[[\\dots],[\\dots],\\dots]$。\n\n约束和假设：\n- 使用随机存取机（RAM）模型，其中算术和比较操作的成本为单位成本。\n- 如果没有公共元素，按规定输出 $[-1,-1,-1]$；哨兵值 $-1$ 必须是整数。\n- 元素是标准的机器整数，可容纳于 Python 的整数类型中；不涉及物理单位。", "solution": "问题陈述在形式上是有效的。它科学地基于算法设计和复杂度分析的原则，定义和约束明确，表述清晰，并且以客观、正式的语言表达。没有矛盾、信息缺失或违反科学或数学原则的地方。因此，我们可以着手解决。\n\n目标是找到两个整数数组之间的第一个公共元素，这两个数组分别是长度为 $n$ 的 $A = [a_0, a_1, \\dots, a_{n-1}]$ 和长度为 $m$ 的 $B = [b_0, b_1, \\dots, b_{m-1}]$。术语“第一个”是根据数组 $A$ 的顺序定义的；也就是说，我们寻求具有最小索引 $i$ 的元素 $a_i$，该元素也存在于数组 $B$ 中。要求的输出是一个三元组 $[v, i, j]$，其中 $v = a_i$，$i$ 是 $v$ 在 $A$ 中的索引，$j$ 是 $v$ 在 $B$ 中*首次*出现的索引（即，满足 $b_j = v$ 的最小 $j$）。如果不存在公共元素，指定的哨兵输出为 $[-1, -1, -1]$。\n\n如问题描述中所暗示的，一种朴素的方法涉及嵌套循环。我们将遍历 $A$ 中的每个元素 $a_i$（从 $i=0$ 到 $n-1$），并对每个 $a_i$，在 $B$ 的所有元素中（从 $j=0$ 到 $m-1$）执行第二次内部线性搜索以检查相等性。当我们第一次找到匹配项，即 $a_i = b_j$，我们就找到了解决方案。外层循环最多运行 $n$ 次，内层循环在每次外层迭代中最多运行 $m$ 次。在单位成本比较的随机存取机（RAM）模型下，这导致最坏情况下的时间复杂度为 $O(n \\cdot m)$。这种二次方复杂度对于大型数组是低效的。\n\n通过利用基于哈希的数据结构来优化搜索过程，可以设计出一种更高效的算法，即以空间换时间。问题建议使用哈希集，但为了满足返回数组 $B$ 中*最左侧*索引 $j$ 的要求，哈希映射（或字典）是更合适的工具。该策略分为两个阶段：对数组 $B$ 的预处理阶段和对数组 $A$ 的搜索阶段。\n\n**阶段 1：预处理数组 $B$**\n\n此阶段的目标是构建一个数据结构，该结构允许近乎即时地查找来自 $B$ 的任何值及其首次出现的索引。哈希映射是实现这一目标的理想选择。我们可以将 $B$ 中存在的每个唯一值映射到其首次出现的对应索引。\n\n过程如下：\n1.  初始化一个空的哈希映射，我们称之为 $\\text{value\\_to\\_index\\_map}$。\n2.  从索引 $j = 0$ 到 $m-1$ 遍历数组 $B$。\n3.  对于每个元素 $b_j$，检查值 $b_j$ 是否已经是 $\\text{value\\_to\\_index\\_map}$ 中的一个键。\n4.  如果 $b_j$ *不*在映射中，这表示我们是第一次遇到这个值。我们将 $b_j$ 作为键添加到映射中，并将其当前索引 $j$ 作为关联值。\n5.  如果 $b_j$ 已经在映射中，我们什么也不做，从而保留其首次出现的索引。\n\n在对 $B$ 进行单次遍历后，$\\text{value\\_to\\_index\\_map}$ 将包含 $B$ 的所有唯一元素作为键，其对应的值是它们在 $B$ 中的最左侧索引。在均匀哈希假设下，每次向哈希映射中插入操作的预期时间为常数时间，即 $O(1)$。因此，此阶段的总时间复杂度为 $O(m)$。所需空间与 $B$ 中唯一元素的数量成正比，最多为 $m$，因此空间复杂度为 $O(\\min(m, U))$，其中 $U$ 是 $B$ 中唯一元素的数量。\n\n**阶段 2：在数组 $A$ 中搜索**\n\n预处理完成后，我们现在可以高效地找到第一个公共元素。\n\n过程如下：\n1.  从索引 $i = 0$ 到 $n-1$ 遍历数组 $A$。\n2.  对于每个元素 $a_i$，在 $\\text{value\\_to\\_index\\_map}$ 中查找键 $a_i$。\n3.  因为我们是按顺序遍历 $A$ 的，所以我们找到的第一个在映射中作为键存在的 $a_i$ 根据定义就是第一个公共元素。\n4.  一旦找到这样的 $a_i$，我们就得到了解决方案：值为 $v = a_i$，它在 $A$ 中的索引是 $i$，它在 $B$ 中的最左侧索引可以从映射中检索得到，即 $j = \\text{value\\_to\\_index\\_map}[a_i]$。然后我们返回三元组 $[v, i, j]$ 并终止算法。\n\n如果循环完成而没有在映射中找到任何 $A$ 的元素，这意味着两个数组之间没有公共元素。在这种情况下，我们按要求返回哨兵值 $[-1, -1, -1]$。\n\n**总体复杂度和论证**\n\n基于哈希映射的方法的总时间复杂度是两个阶段的复杂度之和：$O(m) + O(n) = O(n+m)$。这种线性时间复杂度是渐近最优的，因为任何算法在最坏情况下都必须检查两个数组的每个元素才能保证结果正确。哈希映射的空间复杂度为 $O(\\min(m, U))$。这种方法明显优于朴素的 $O(n \\cdot m)$ 方法，尤其是在处理大规模输入时。该实现正确处理了诸如空数组（$n=0$ 或 $m=0$）和数组内重复元素等边缘情况，并严格遵守问题定义。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem for a predefined test suite and prints the aggregated result.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (happy path)\n        ([3, 5, 7, 9], [10, 11, 5, 12]),\n        # Case 2 (no common element)\n        ([1, 2, 3], [4, 5]),\n        # Case 3 (first element common)\n        ([8, 1], [8]),\n        # Case 4 (duplicates in both arrays)\n        ([4, 4, 4], [0, 4, 4]),\n        # Case 5 (empty first array)\n        ([], [1, 2]),\n        # Case 6 (empty second array)\n        ([1, 2], []),\n        # Case 7 (negative numbers and zero)\n        ([-5, -1, 0, 2], [3, -1, 4]),\n    ]\n\n    all_results_str = []\n    for a, b in test_cases:\n        result = find_first_common_element(a, b)\n        # Format the result list as a string \"[v,i,j]\" without spaces\n        v, i, j = result\n        all_results_str.append(f\"[{v},{i},{j}]\")\n\n    # Final print statement in the exact required format: [[...],[...],...]\n    print(f\"[{','.join(all_results_str)}]\")\n\ndef find_first_common_element(A, B):\n    \"\"\"\n    Finds the first common element between arrays A and B.\n\n    The function finds the element `v` that appears earliest in `A` and is also\n    present in `B`. It returns a list `[v, i, j]`, where `i` is the index of `v`\n    in `A` and `j` is the index of the first occurrence of `v` in `B`.\n\n    If no common element exists, it returns [-1, -1, -1].\n\n    Args:\n        A (list[int]): The first array.\n        B (list[int]): The second array.\n\n    Returns:\n        list[int]: A list containing the value, index in A, and index in B,\n                   or [-1, -1, -1] if no common element is found.\n    \"\"\"\n    # Phase 1: Pre-process array B to create a hash map of values\n    # to their first-seen (leftmost) index.\n    b_value_to_index_map = {}\n    for j, val in enumerate(B):\n        if val not in b_value_to_index_map:\n            b_value_to_index_map[val] = j\n\n    # Phase 2: Iterate through array A and check for membership in the map.\n    # The first element found is the answer due to the left-to-right scan of A.\n    for i, val in enumerate(A):\n        if val in b_value_to_index_map:\n            j_in_b = b_value_to_index_map[val]\n            return [val, i, j_in_b]\n\n    # If the loop completes, no common element was found.\n    return [-1, -1, -1]\n\n# Execute the solution.\nsolve()\n```", "id": "3245002"}]}