{"hands_on_practices": [{"introduction": "理解二分图最根本的方法是检查其是否包含奇数长度的环路。这个练习 [@problem_id:3216784] 提供了一个完美的受限环境——一个只有一个环的图——来直接应用这一原理。它将抽象的定理与具体的算法任务联系起来，即找到这个唯一的环并检查其长度，从而判断图的二分性。", "problem": "设一个无向、简单、连通图 $G=(V,E)$ 是通过以下方式构建的：取一个有 $|V|=n$ 个顶点的树 $T$（因此 $|E(T)|=n-1$），并在 $T$ 的两个不同的、不相邻的顶点之间添加恰好 $1$ 条额外的边。这样的图恰好有 $1$ 个简单环。如果一个图的顶点集可以被划分为两个不相交的部分 $A$ 和 $B$，使得每条边的两个端点分别位于 $A$ 和 $B$ 中，则称该图为二分图。你需要从第一性原理出发，设计并实现一个线性时间算法，来判断图 $G$ 是否是二分图，并对算法进行阐述和证明。该算法不能依赖于本问题陈述中给出的任何快捷公式，必须从基本定义和经过充分验证的事实推导得出。\n\n基本要求：\n- 仅使用图、树、路径和环的核心定义，以及“一个图是二分图当且仅当它不包含奇数长度的环”这一经过充分验证的事实。\n- 设计必须从这些基础出发，解释为什么它们能推导出针对图 $G$（一棵树加 $1$ 条额外的边）的所需测试方法，并展示如何在 $O(n)$ 时间内实现该判定。\n\n程序规范：\n- 顶点由整数 $0,1,2,\\dots,n-1$ 标记。\n- 每个测试用例由以下内容指定：\n  - 一个整数 $n$（顶点数）。\n  - 一个包含 $n-1$ 条构成树 $T$ 的无向树边的列表。\n  - 一条额外的无向边 $(u,v)$，其端点在 $T$ 中是不同的且不相邻。\n- 你的程序必须实现一个线性时间算法，对于每个测试用例，返回一个布尔值，表示结果图 $G$ 是否是二分图。\n\n测试套件：\n提供以下测试用例的结果（所有边都是无向的）：\n- 测试用例 1：$n=3$，树边 $\\{(0,1),(1,2)\\}$，额外边 $(0,2)$。\n- 测试用例 2：$n=4$，树边 $\\{(0,1),(1,2),(2,3)\\}$，额外边 $(0,3)$。\n- 测试用例 3：$n=5$，树边 $\\{(0,1),(0,2),(0,3),(0,4)\\}$，额外边 $(1,2)$。\n- 测试用例 4：$n=6$，树边 $\\{(0,1),(1,2),(2,3),(3,4),(4,5)\\}$，额外边 $(1,4)$。\n- 测试用例 5：$n=7$，树边 $\\{(0,1),(0,2),(1,3),(1,4),(2,5),(2,6)\\}$，额外边 $(3,2)$。\n- 测试用例 6：$n=8$，树边 $\\{(0,1),(1,2),(2,3),(3,4),(4,5),(5,6),(6,7)\\}$，额外边 $(2,6)$。\n\n输出格式：\n- 你的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[r_1,r_2,r_3]$），其中每个 $r_i$ 是按上述顺序给出的第 $i$ 个测试用例的布尔结果。\n\n不涉及物理量，因此不需要单位。不出现角度，因此不需要角度单位。不出现百分比，因此没有关于百分比格式的特殊说明。", "solution": "问题陈述的有效性已确立。这是一个算法图论中的良构问题，基于标准的定义和定理，没有任何科学或逻辑上的缺陷。\n\n解决方案是从第一性原理推导出来的，始于二分图的基本特征。\n\n**1. 二分图的基本原理**\n\n图论中的一个基石定理指出，一个无向图是二分图，当且仅当它不包含奇数长度的简单环。如果一个图的顶点可以被划分为两个不相交的集合（例如 $A$ 和 $B$），使得每条边都连接一个在 $A$ 中的顶点和一个在 $B$ 中的顶点，那么这个图就是二分图。如果一个环有奇数个顶点，例如 $v_1, v_2, \\dots, v_k, v_1$（其中 $k$ 为奇数），那么任何对其进行 2-着色的尝试都会失败。如果 $v_1$ 在集合 $A$ 中，那么 $v_2$ 必须在 $B$ 中，$v_3$ 在 $A$ 中，以此类推。对于任何顶点 $v_i$，其颜色将由其索引 $i$ 的奇偶性决定。如果 $k-1$ 是偶数（当 $k$ 是奇数时成立），顶点 $v_k$ 将与 $v_1$ 具有相同的颜色。然而，边 $(v_k, v_1)$ 连接着它们，这就产生了冲突。反之，如果一个图没有奇数环，总能找到一种 2-着色方案。\n\n**2. 图 $G$ 的结构分析**\n\n问题规定，图 $G=(V,E)$ 是通过在一棵有 $n$ 个顶点的树 $T$ 上，在两个不同的、不相邻的顶点之间添加一条额外的边 $(u,v)$ 来构建的。我们分析这种构造所产生的环结构。\n\n- 根据定义，树是一个不含环的连通图。\n- 树的一个基本性质是，对于任意两个顶点（例如 $u$ 和 $v$），它们之间存在唯一的简单路径。我们将这条在 $T$ 中的路径表示为 $P_{uv}$。\n- 图 $G$ 由树 $T$ 和边 $(u,v)$ 的并集构成。$G$ 的边集是 $E(G) = E(T) \\cup \\{(u,v)\\}$。\n- 添加边 $(u,v)$ 会形成一个环 $C$，该环由路径 $P_{uv}$ 和边 $(u,v)$ 本身组成。\n- 这个环 $C$ 是 $G$ 中*唯一*的简单环。要理解原因，假设存在另一个简单环 $C'$。如果 $C'$ 不使用边 $(u,v)$，那么它的所有边都必须属于树 $T$。这将意味着 $T$ 包含一个环，这与树的定义相矛盾。因此，$G$ 中的任何环都必须包含边 $(u,v)$。由于 $P_{uv}$ 是 $T$ 中 $u$ 和 $v$ 之间的唯一路径，任何包含 $(u,v)$ 的环都必须通过遍历 $P_{uv}$ 然后通过边 $(u,v)$ 返回来形成。因此，$C$ 是 $G$ 中唯一的简单环。\n\n**3. 二分性特定测试的推导**\n\n将基本原理与对 $G$ 的结构分析相结合，我们可以制定一个直接的二分性测试方法。\n\n- 根据原理，$G$ 是二分图当且仅当它没有奇数长度的环。\n- 既然我们已经确定 $G$ 恰好有一个简单环 $C$，二分性的条件可以简化为：$G$ 是二分图当且仅当这个唯一的环 $C$ 的长度是偶数。\n\n**4. 环长度的计算**\n\n一个环的长度，记为 $|C|$，是它包含的边的数量。环 $C$ 由路径 $P_{uv}$ 的边和单条边 $(u,v)$ 组成。因此，其长度为：\n$$|C| = |P_{uv}| + 1$$\n这里， $|P_{uv}|$ 是树 $T$ 中 $u$ 和 $v$ 之间唯一路径上的边数。根据定义，这就是 $u$ 和 $v$ 在 $T$ 中的距离，记为 $\\text{dist}_T(u,v)$。\n所以，环的长度是：\n$$|C| = \\text{dist}_T(u,v) + 1$$\n$G$ 是二分图的条件是 $|C|$ 必须是偶数。这意味着 $\\text{dist}_T(u,v) + 1$ 必须是偶数，这当且仅当 $\\text{dist}_T(u,v)$ 是奇数时成立。\n\n**5. 线性时间算法**\n\n问题现在简化为计算树 $T$ 中顶点 $u$ 和 $v$ 之间的距离，并检查该距离是否为奇数。这可以在线性时间内高效完成。\n\n- **算法**：\n    1.  根据给定的 $n-1$ 条边，构建树 $T$ 的邻接表表示。这需要遍历一次所有边，耗时 $O(n)$。\n    2.  从顶点 $u$ 开始执行广度优先搜索（BFS），以找到到树中所有其他顶点的距离。我们使用一个队列和一个大小为 $n$ 的距离数组 `distances`，该数组用一个值（例如 $-1$）初始化，表示顶点尚未被访问。\n    3.  用 $u$ 初始化队列，并设置 `distances[u] = 0`。\n    4.  当队列不为空时，出队一个顶点，记为 `curr`。对于 `curr` 的每个邻居 `next`，如果 `distances[next]` 是 $-1$，则将其更新为 `distances[curr] + 1` 并将 `next` 入队。\n    5.  BFS 会精确地遍历树的每个顶点和每条边一次。当算法完成时（或者，作为一种优化，一旦到达 `v`），`distances[v]` 的值将保存 $\\text{dist}_T(u,v)$。\n    6.  最后一步是检查 `distances[v]` 是否为奇数。如果是，图 $G$ 是二分图；否则，不是。\n\n- **复杂度分析**：\n    - 构建邻接表的复杂度是 $O(n)$。\n    - 在树（一个有 $n$ 个顶点和 $n-1$ 条边的连通图）上进行 BFS 的时间复杂度为 $O(|V|+|E(T)|) = O(n + (n-1)) = O(n)$。\n    - 最后的检查是 $O(1)$ 操作。\n    - 因此，整个算法在 $O(n)$ 时间内运行，满足了问题的线性时间要求。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport collections\n\ndef is_bipartite_for_tree_plus_one_edge(n, tree_edges, extra_edge):\n    \"\"\"\n    Determines if a graph formed by a tree plus one edge is bipartite.\n\n    The method is based on the principle that a graph is bipartite if and only if\n    it contains no odd-length cycles. The given graph structure has exactly one\n    cycle, formed by the extra edge (u, v) and the unique path between u and v\n    in the tree. The graph is bipartite if and only if this cycle has an even\n    length.\n\n    Cycle length = dist_T(u, v) + 1.\n    For the cycle length to be even, dist_T(u, v) must be odd.\n\n    This function calculates the distance between u and v in the tree using BFS\n    and checks if it is odd.\n\n    Args:\n        n (int): The number of vertices.\n        tree_edges (list of tuple): A list of n-1 edges forming the tree.\n        extra_edge (tuple): The single edge added to the tree.\n\n    Returns:\n        bool: True if the graph is bipartite, False otherwise.\n    \"\"\"\n    u, v = extra_edge\n\n    # Step 1: Build the adjacency list for the tree T.\n    # Complexity: O(n) as there are n-1 edges.\n    adj = [[] for _ in range(n)]\n    for a, b in tree_edges:\n        adj[a].append(b)\n        adj[b].append(a)\n\n    # Step 2: Use Breadth-First Search (BFS) to find the distance from u to v.\n    # Complexity: O(n) for a tree with n vertices.\n    queue = collections.deque([u])\n    # distances array tracks distance from u and also serves as a visited set.\n    distances = [-1] * n\n    distances[u] = 0\n\n    while queue:\n        current_node = queue.popleft()\n\n        # If we have reached the target vertex v, we have found the distance.\n        if current_node == v:\n            break\n\n        for neighbor in adj[current_node]:\n            # If the neighbor has not been visited yet\n            if distances[neighbor] == -1:\n                distances[neighbor] = distances[current_node] + 1\n                queue.append(neighbor)\n    \n    # Step 3: Check the parity of the distance.\n    # The graph is bipartite iff the unique cycle is of even length.\n    # Cycle length = dist(u,v) + 1.\n    # Length is even iff dist(u,v) is odd.\n    distance_uv = distances[v]\n    \n    # This case should not be reached for a valid connected tree input.\n    if distance_uv == -1:\n        return False\n\n    return distance_uv % 2 == 1\n\ndef solve():\n    \"\"\"\n    Runs the algorithm on the predefined test cases and prints the results.\n    \"\"\"\n    test_cases = [\n        # Test case 1: n=3, tree edges {(0,1),(1,2)}, extra edge (0,2).\n        # Path 0-1-2. dist(0,2) = 2. Cycle length = 3 (odd). Not bipartite.\n        (3, [(0, 1), (1, 2)], (0, 2)),\n        # Test case 2: n=4, tree edges {(0,1),(1,2),(2,3)}, extra edge (0,3).\n        # Path 0-1-2-3. dist(0,3) = 3. Cycle length = 4 (even). Bipartite.\n        (4, [(0, 1), (1, 2), (2, 3)], (0, 3)),\n        # Test case 3: n=5, tree edges {(0,1),(0,2),(0,3),(0,4)}, extra edge (1,2).\n        # Path 1-0-2. dist(1,2) = 2. Cycle length = 3 (odd). Not bipartite.\n        (5, [(0, 1), (0, 2), (0, 3), (0, 4)], (1, 2)),\n        # Test case 4: n=6, tree edges {(0,1),(1,2),(2,3),(3,4),(4,5)}, extra edge (1,4).\n        # Path 1-2-3-4. dist(1,4) = 3. Cycle length = 4 (even). Bipartite.\n        (6, [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5)], (1, 4)),\n        # Test case 5: n=7, tree edges {(0,1),(0,2),(1,3),(1,4),(2,5),(2,6)}, extra edge (3,2).\n        # Path 3-1-0-2. dist(3,2) = 3. Cycle length = 4 (even). Bipartite.\n        (7, [(0, 1), (0, 2), (1, 3), (1, 4), (2, 5), (2, 6)], (3, 2)),\n        # Test case 6: n=8, tree edges {(0,1),..,(6,7)}, extra edge (2,6).\n        # Path 2-3-4-5-6. dist(2,6) = 4. Cycle length = 5 (odd). Not bipartite.\n        (8, [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7)], (2, 6)),\n    ]\n\n    results = []\n    for n, tree_edges, extra_edge in test_cases:\n        result = is_bipartite_for_tree_plus_one_edge(n, tree_edges, extra_edge)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3216784"}, {"introduction": "在学会了如何检测奇数环之后，一个自然的进阶是对其进行更深入的分析。这个练习 [@problem_id:3216863] 不再仅仅满足于“是”或“否”的答案，而是挑战你在图中找出*最短*的奇数环。这要求你更深入地应用广度优先搜索 (BFS)，利用其寻找最短路径的特性，来系统地定位并度量对二分性的最小“违例”。", "problem": "您的任务是设计并实现一个程序，对于每个顶点标签在 $\\{0,1,2,\\dots,n-1\\}$ 中的有限、无向、简单图 $G = (V,E)$，计算其最短奇数长度的环（如果存在），否则报告不存在这样的环。解决方案必须完全从第一性原理出发，从定义开始推导，并且必须实现为一个无需任何外部输入即可运行的完整程序。您的推导必须使用以下基本依据：二分图的定义、图距离的定义以及广度优先搜索（BFS）的性质（BFS是Breadth-First Search的缩写）。不得使用或引用任何其他快捷公式。\n\n推导所需的定义：\n- 当且仅当图 $G$ 的顶点集 $V$ 可以被划分为两个不相交的集合 $X$ 和 $Y$，使得每条边都连接 $X$ 中的一个顶点和 $Y$ 中的一个顶点时，图 $G$ 是二分图。等价地，当且仅当图 $G$ 不包含任何奇数长度的环时，它是二分图。\n- 顶点 $u$ 和 $v$ 之间的图距离 $\\operatorname{dist}_G(u,v)$ 是 $u$ 和 $v$ 之间最短路径的长度（边的数量）。\n- 在无向、无权图中，从源点 $s$ 开始的广度优先搜索（BFS）会按照与 $s$ 的距离 $\\operatorname{dist}_G(s,\\cdot)$ 的非递减顺序发现顶点，为每个发现的顶点 $v$ 在某条最短路径上分配一个父节点 $\\operatorname{parent}(v)$，并根据距离级别形成分层结构。在这种BFS分层中，任何边都只连接同一层或相邻层上的顶点。\n\n您的程序必须实现一个基于这些原理的算法，通过检查BFS结构并在适当时使用它来重构环，从而找到图 $G$ 中最短的奇数长度环（如果存在）。该算法还必须通过将每个顶点都视为一个潜在的BFS源点来保证对非连通图的正确性。\n\n环的输出规范化要求：\n- 一个环由一个不重复顶点的序列 $[c_0,c_1,\\dots,c_{k-1}]$ 表示，其中隐含了边集 $\\{(c_i,c_{(i+1) \\bmod k}) \\mid i \\in \\{0,1,\\dots,k-1\\}\\}$。列表中的第一个和最后一个顶点不能重复。\n- 按如下方式规范化任何环：旋转序列，使最小的顶点标签出现在最前面；然后选择（顺时针或逆时针）方向，以产生字典序较小的序列。在多个最小奇数长度的环中，选择字典序最小的规范化环。\n\n如果不存在奇数长度的环，则为该图输出空列表 $[\\ ]$。\n\n您的程序必须使用以下图的测试套件，每个图由一个整数 $n$ 和一组无向边 $E$ 指定，边以点对 $(u,v)$ 的形式给出，其中 $0 \\le u,v  n$：\n\n- 测试用例 1（一个三角形）：\n  - $n = 3$\n  - $E = \\{(0,1),(1,2),(2,0)\\}$\n\n- 测试用例 2（一个4-环，二分图）：\n  - $n = 4$\n  - $E = \\{(0,1),(1,2),(2,3),(3,0)\\}$\n\n- 测试用例 3（两个共享一个顶点的三角形）：\n  - $n = 5$\n  - $E = \\{(0,1),(1,2),(2,0),(0,3),(3,4),(4,0)\\}$\n\n- 测试用例 4（非连通图：一个4-环和一个5-环）：\n  - $n = 9$\n  - $E = \\{(0,1),(1,2),(2,3),(3,0),(4,5),(5,6),(6,7),(7,8),(8,4)\\}$\n\n- 测试用例 5（没有边）：\n  - $n = 3$\n  - $E = \\{\\}$\n\n- 测试用例 6（一个带额外树状附加结构的5-环）：\n  - $n = 7$\n  - $E = \\{(0,1),(1,2),(2,3),(3,4),(4,0),(2,5),(5,6)\\}$\n\n输出规范：\n- 对于以上述顺序列出的每个测试用例，如果图没有奇数长度的环，则输出空列表 $[\\ ]$；否则，输出如上定义的最短奇数长度环的规范化顶点列表 $[c_0,c_1,\\dots,c_{k-1}]$。\n- 您的程序应生成单行输出，其中包含以逗号分隔的列表形式的结果，并用方括号括起来，中间没有任何空格；例如，包含三个结果的输出可能看起来像 $[[0,1,2],[],[4,5,6,7,8]]$。\n\n此问题不涉及任何物理单位或角度。所有数值和索引都必须视为纯整数。每个测试用例的最终答案必须是一个整数列表或一个空列表，并且总输出必须是如上所述聚合这些结果的单个列表。程序不得从标准输入读取，并且必须按原样运行。", "solution": "用户提供的问题陈述已经过验证，被确定为图算法领域一个有效的、适定的问题。它科学地基于图论的既定原则，提供了所有必要的定义和数据，并且没有矛盾或含糊之处。\n\n### 从第一性原理推导\n\n问题要求在给定的简单、无向图 $G=(V, E)$ 中找到最短的奇数长度环。算法的推导将基于所提供的基本原理：二分图的定义、图距离的性质以及广度优先搜索（BFS）的行为。\n\n1.  **奇数环与二分图**：一个关键原则是，一个图是二分图当且仅当它不包含奇数长度的环。这意味着存在奇数长度的环与图（或其某个连通分量）是非二分图是同义的。因此，一个测试二分性的算法可以被调整用于寻找奇数长度的环。\n\n2.  **使用BFS进行二分性测试**：在连通分量中测试二分性的标准方法是使用BFS对其顶点进行二着色。从一个源顶点 $s$ 开始，我们可以将其分配给集合 $X$（或颜色0）。其所有邻居都被分配给集合 $Y$（颜色1）。这些顶点的邻居又被分配回集合 $X$（颜色0），以此类推。在从 $s$ 开始的BFS遍历中，顶点 $v$ 与 $s$ 的距离为 $\\operatorname{dist}_G(s,v)$。这个着色规则等价于为每个顶点 $v$ 分配颜色 $\\operatorname{dist}_G(s,v) \\bmod 2$。\n\n3.  **检测奇数环**：如果我们发现一条边 $(u,v)$ 连接了两个被分配了相同颜色的顶点，那么二着色就失败了，从而检测到了一个奇数环。在从源点 $s$ 开始的BFS的上下文中，这意味着 $\\operatorname{dist}_G(s,u) \\bmod 2 = \\operatorname{dist}_G(s,v) \\bmod 2$。\n\n4.  **BFS分层与环的形成**：问题陈述指出了BFS在无权图上的一个关键性质：任何边都连接同一层或相邻层上的顶点。也就是说，对于任何边 $(u,v)$，从BFS源点 $s$ 出发的距离必须满足 $|\\operatorname{dist}_G(s,u) - \\operatorname{dist}_G(s,v)| \\le 1$。\n    -   如果 $\\operatorname{dist}_G(s,u)$ 和 $\\operatorname{dist}_G(s,v)$ 的奇偶性不同，它们的差必须是 $1$。这对应于相邻层之间的边（例如，$\\operatorname{dist}_G(s,u) = d$ 和 $\\operatorname{dist}_G(s,v) = d-1$），这与二分图结构是一致的。\n    -   如果 $\\operatorname{dist}_G(s,u)$ 和 $\\operatorname{dist}_G(s,v)$ 的奇偶性相同，它们的差必须是 $0$。这意味着 $\\operatorname{dist}_G(s,u) = \\operatorname{dist}_G(s,v) = d$。边 $(u,v)$ 连接了两个与 $s$ 距离均为 $d$ 的同一层顶点。这种配置必然形成一个奇数长度的环。\n\n5.  **寻找最短奇数环**：由边 $(u,v)$ 以及BFS树中从 $s$ 到 $u$ 和从 $s$ 到 $v$ 的最短路径所形成的环，其长度为 $\\operatorname{dist}_G(s,u) + \\operatorname{dist}_G(s,v) + 1$。由于 $\\operatorname{dist}_G(s,u) = \\operatorname{dist}_G(s,v) = d$，环的长度为 $2d+1$，这是一个奇数。一个已知的结论是，图中最短的奇数环可以通过计算 $\\min_s \\min_{(u,v)} (\\operatorname{dist}_G(s,u) + \\operatorname{dist}_G(s,v) + 1)$ 来找到，其中遍历所有顶点 $s$ 和满足 $\\operatorname{dist}_G(s,u) = \\operatorname{dist}_G(s,v)$ 的边 $(u,v)$。通过从每个顶点 $s \\in V$ 运行BFS，我们保证能找到产生可能的最短奇数环的源点和边。对于非连通图，这确保了每个连通分量都得到检查。\n\n6.  **算法步骤**：\n    a. 将目前找到的最小奇数环长度初始化为无穷大，并将找到的最佳环初始化为空列表。\n    b. 遍历每个顶点 $s \\in \\{0, 1, \\dots, n-1\\}$，将其用作BFS的源点。这确保了所有连通分量都被探索，并且找到了全局最小值。\n    c. 对每个源点 $s$，执行一次BFS。维护一个数组 `dist` 来存储与 $s$ 的距离，以及一个 `parent` 数组来重构路径。\n    d. 在BFS期间，当从顶点 $u$ 探索其邻居 $v$ 时：\n        i. 如果 $v$ 尚未被访问（`dist[v]` 未初始化），则这是一条树边。设置 `dist[v] = dist[u] + 1` 和 `parent[v] = u`，并将 $v$ 添加到队列中。\n        ii. 如果 $v$ 已被访问且不是 $u$ 在BFS树中的直接父节点，则发现了一个环。如果 `dist[v] == dist[u]`，这是一个长度为 $k = \\operatorname{dist}[u] + \\operatorname{dist}[v] + 1$ 的奇数环。\n    e. 每当找到一个奇数环时，将其长度 $k$ 与目前找到的最小长度进行比较。如果 $k$ 更小，或者 $k$ 相等但新环在规范化后字典序更小，则更新最佳环。\n\n7.  **环的重构与规范化**：当找到一个端点为 $u$ 和 $v$（源点为 $s$）的候选奇数环时，可以通过从 $u$ 和 $v$ 回溯 `parent` 指针到它们在BFS树中的最低公共祖先（LCA）来重构环的顶点。该环由从LCA到 $u$ 的路径、从LCA到 $v$ 的路径以及边 $(u,v)$ 组成。然后必须按照问题规则对得到的顶点列表进行规范化：旋转以使最小的顶点标签开头，然后定向以产生字典序较小的序列。\n\n这种系统性的方法，基于BFS的性质及其与二分性的关系，能够按要求正确地识别并计算出最短的奇数长度环。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport collections\n\ndef get_normalized_cycle(u, v, parent):\n    \"\"\"\n    Reconstructs and normalizes a cycle given its closing edge (u, v) and\n    the parent pointers from a BFS.\n    \"\"\"\n    # Trace back from u and v to find the path to the source\n    path_u, path_v = [], []\n    curr = u\n    while curr != -1:\n        path_u.append(curr)\n        curr = parent[curr]\n    curr = v\n    while curr != -1:\n        path_v.append(curr)\n        curr = parent[curr]\n\n    # Reverse paths to go from source to node\n    path_u.reverse()\n    path_v.reverse()\n\n    # Find the lowest common ancestor (LCA) by finding the last common vertex\n    # in the paths from the source.\n    lca_idx = 0\n    while (lca_idx  len(path_u) and lca_idx  len(path_v) and \n           path_u[lca_idx] == path_v[lca_idx]):\n        lca_idx += 1\n    lca_idx -= 1\n\n    # The cycle is the path from LCA to u, plus the path from v to LCA.\n    cycle = path_u[lca_idx:] + path_v[lca_idx+1:][::-1]\n\n    # Normalize the cycle\n    if not cycle:\n        return []\n    \n    # 1. Rotate so the minimum element is first.\n    min_val = min(cycle)\n    min_idx = cycle.index(min_val)\n    rotated = cycle[min_idx:] + cycle[:min_idx]\n    \n    # 2. Choose the lexicographically smaller of the two possible orientations.\n    # The second element of the reversed sequence (excluding the first element)\n    # is the last element of the original rotated sequence.\n    if len(rotated) > 1 and rotated[-1]  rotated[1]:\n        return [rotated[0]] + rotated[1:][::-1]\n    else:\n        return rotated\n\n\ndef solve():\n    \"\"\"\n    Main function to solve for all test cases.\n    \"\"\"\n    test_cases = [\n        (3, {(0, 1), (1, 2), (2, 0)}),\n        (4, {(0, 1), (1, 2), (2, 3), (3, 0)}),\n        (5, {(0, 1), (1, 2), (2, 0), (0, 3), (3, 4), (4, 0)}),\n        (9, {(0, 1), (1, 2), (2, 3), (3, 0), (4, 5), (5, 6), (6, 7), (7, 8), (8, 4)}),\n        (3, set()),\n        (7, {(0, 1), (1, 2), (2, 3), (3, 4), (4, 0), (2, 5), (5, 6)}),\n    ]\n\n    all_results = []\n\n    for n, edges in test_cases:\n        if n == 0:\n            all_results.append([])\n            continue\n        \n        adj = collections.defaultdict(list)\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n\n        min_k = float('inf')\n        best_cycle = []\n\n        # Iterate through each vertex as a potential BFS source\n        for s in range(n):\n            dist = [-1] * n\n            parent = [-1] * n\n            q = collections.deque([s])\n            \n            dist[s] = 0\n            \n            while q:\n                u = q.popleft()\n                \n                for v in adj[u]:\n                    if v == parent[u]:\n                        continue\n                        \n                    if dist[v] == -1:  # v is unvisited (tree edge)\n                        dist[v] = dist[u] + 1\n                        parent[v] = u\n                        q.append(v)\n                    else:  # v is visited (non-tree edge), a cycle is detected\n                        # An odd cycle is found if the edge connects two vertices\n                        # at the same level in the BFS tree.\n                        if dist[v] == dist[u]:\n                            k = dist[u] + dist[v] + 1\n                            \n                            if k  min_k:\n                                min_k = k\n                                best_cycle = get_normalized_cycle(u, v, parent)\n                            elif k == min_k:\n                                current_cycle = get_normalized_cycle(u, v, parent)\n                                # Lexicographical comparison for tie-breaking\n                                if tuple(current_cycle)  tuple(best_cycle):\n                                    best_cycle = current_cycle\n        \n        all_results.append(best_cycle)\n\n    # Format the final output string according to specifications\n    result_strings = [str(res).replace(\" \", \"\") for res in all_results]\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```", "id": "3216863"}, {"introduction": "静态图的分析是一回事，但许多现实世界系统是随时间演化的。这个练习 [@problem_id:3216756] 将你引入二分性问题的动态版本，其中图的边是逐一添加的。你将超越基于BFS的方法，学习并实现一种更精妙的、使用并查集 (DSU) 数据结构的方法，从而掌握在图增长时如何高效地追踪连通性和颜色约束。", "problem": "考虑一个无向简单图 $G = (V,E)$，其顶点集为 $V$，边集为 $E$。边按固定顺序逐一添加，产生一个嵌套的图族 $G_1, G_2, \\ldots, G_m$，其中 $G_t$ 表示添加了前 $t$ 条边后的图。如果存在一个顶点集划分 $V = X \\cup Y$ 且 $X \\cap Y = \\varnothing$，使得每条边的两个端点一个在 $X$ 中，另一个在 $Y$ 中，则称该图为二分图。一个久经检验的事实是：一个无向图是二分图，当且仅当它不包含奇数长度的环。\n\n仅从上述核心定义出发，设计一个程序，对每个指定的测试用例，报告使得 $G_t$ 不是二分图的最早索引 $t$（其中 $t \\in \\{1,2,\\ldots,m\\}$）。如果在添加所有 $m$ 条边后图仍然是二分图，则报告 $0$。一个自环，即形如 $(u,u)$（其中 $u \\in V$）的边，会立即使图变为非二分图，因为单个顶点不能同时被置于划分的两个部分中。\n\n测试套件中的所有图都是无向的，边可能重复，顶点由从 $1$ 开始的连续整数标记。添加一条边 $(u,v)$ 被解释为施加一个约束，即在包含 $u$ 和 $v$ 的连通分量的任何有效二染色中，$u$ 和 $v$ 的标签必须被赋予相反的颜色。\n\n测试套件由以下参数集组成。每个测试用例由一个顶点数 $n$ 和一个长度为 $m$ 的边序列给出，边序列以有序对 $(u,v)$ 的形式编写（其中 $u,v \\in \\{1,2,\\ldots,n\\}$），并按所列顺序处理。\n\n- 测试用例 1：$n = 6$，边序列 $\\big((1,2),(2,3),(3,4),(4,5),(5,6),(6,1),(1,3)\\big)$。\n- 测试用例 2：$n = 5$，边序列 $\\big((1,2),(2,3),(3,4),(4,5)\\big)$。\n- 测试用例 3：$n = 3$，边序列 $\\big((1,2),(2,2),(2,3)\\big)$。\n- 测试用例 4：$n = 4$，边序列 $\\big((1,2),(2,3),(3,1),(4,1)\\big)$。\n- 测试用例 5：$n = 4$，边序列 $\\big((1,2),(2,3),(1,2),(3,4),(4,1),(2,4)\\big)$。\n- 测试用例 6：$n = 3$，边序列 $\\big(\\ \\big)$（即没有边）。\n\n您的程序应生成单行输出，其中包含结果，结果形式为方括号括起来的逗号分隔列表，没有空格，且顺序与测试套件相同（例如，$[r_1,r_2,\\ldots,r_6]$，其中每个 $r_i$ 是如上指定的整数）。", "solution": "该问题要求设计一种算法，以确定在添加边的序列中，图在哪个最早的时间点不再是二分图。图 $G=(V,E)$ 被定义为二分图，如果其顶点集 $V$ 可以划分为两个不相交的集合 $X$ 和 $Y$，使得 $E$ 中的每条边都连接 $X$ 中的一个顶点和 $Y$ 中的一个顶点。问题陈述正确地给出了基本定理：一个图是二分图，当且仅当它不包含奇数长度的环。我们处理一个包含 $m$ 条边的序列，生成一系列图 $G_1, G_2, \\ldots, G_m$，其中 $G_t$ 是包含前 $t$ 条边的图。我们寻求最小的 $t \\in \\{1, 2, \\ldots, m\\}$，使得 $G_t$ 不是二分图。如果序列中所有的图都是二分图，则结果为 $0$。\n\n问题的核心是高效地检测第一个奇数长度环的形成。向一个已经是二分图的图 $G$ 中添加一条边 $(u,v)$ 会使新图变为非二分图，当且仅当这条新边闭合了一个奇数长度的环。这种情况发生当且仅当顶点 $u$ 和 $v$ 已经位于同一个连通分量中，并且它们在图 $G$ 中的路径长度为偶数。添加边 $(u,v)$ 会创建一个环，其长度为偶数路径长度加 $1$，结果为奇数。\n\n从二染色的角度来看，这意味着在添加边 $(u,v)$ *之前*，顶点 $u$ 和 $v$ 在其所在连通分量的任何有效二染色中都必须具有相同的颜色。新边施加了它们必须具有不同颜色的约束，从而产生矛盾。\n\n这个动态连通性和相对染色问题可以通过一个带扩展信息的不相交集并查集（Disjoint Set Union, DSU）数据结构来优雅地解决。一个标准的 DSU 用于跟踪图的连通分量。我们对其进行扩展，以额外跟踪一个分量内节点之间“距离”（路径长度）的奇偶性，这对应于它们在二染色中的颜色关系。\n\n我们的 DSU 结构将包含两个主要数组，用于一个有 $n$ 个顶点（标记为 $1$ 到 $n$）的图：\n$1$. `parent`：一个大小为 $n+1$ 的数组，其中 `parent[i]` 存储节点 $i$ 在其分量树表示中的父节点。\n$2$. `parity`：一个大小为 $n+1$ 的数组，其中 `parity[i]` 存储节点 $i$ 与其父节点 `parent[i]` 之间路径长度的奇偶性（$0$ 或 $1$）。`parity[i] = 1$ 表示 $i$ 和 `parent[i]` 必须具有不同的颜色，而 `parity[i] = 0$ 表示它们必须具有相同的颜色。一条边天然对应于长度为 $1$ 的路径，因此其端点颜色不同。\n\nDSU 操作修改如下：\n\n**`find(i)` 操作**：此操作查找包含顶点 $i$ 的分量的代表（根节点）。它实现路径压缩以保持效率。在路径被压缩时（即 `parent[i]` 被设置为分量的根节点），`parity[i]` 的值必须更新，以存储从 $i$到根节点的路径长度的奇偶性。如果从 $i$ 到根节点的原始路径是 $i \\to p_1 \\to p_2 \\to \\dots \\to \\text{root}$，则新的 `parity[i]` 变为异或和 $(\\text{parity}_{\\text{old}}[i] \\oplus \\text{parity}_{\\text{old}}[p_1] \\oplus \\dots) \\pmod 2$。递归实现可以很自然地处理这个问题。`find(i)` 操作返回一个元组，包含分量的根节点以及计算出的从 $i$ 到该根节点的路径奇偶性。\n\n**`union(u, v)` 操作**：此操作处理新边 $(u,v)$ 的添加，并确定它是否违反了二分图的性质。\n$1$. 首先，我们调用 `find(u)` 和 `find(v)` 来获取它们各自的根节点以及相对于这些根节点的奇偶性：$(\\text{root}_u, \\text{parity}_u)$ 和 $(\\text{root}_v, \\text{parity}_v)$。\n$2$. **情况 A：不同分量 ($\\text{root}_u \\neq \\text{root}_v$)**。该边连接了两个先前分离的分量。这不会产生环，因此图仍然是二分图。我们合并这两个分量，例如，通过设置 `parent[root_v] = root_u`。然后我们必须为这个新连接建立奇偶性关系。从 $\\text{root}_v$ 到 $\\text{root}_u$ 的路径现在实际上遍历了 $\\text{root}_v \\leftarrow \\dots \\leftarrow v - u \\rightarrow \\dots \\rightarrow \\text{root}_u$。从 $\\text{root}_v$ 到 $\\text{root}_u$ 的路径长度的奇偶性是三个部分奇偶性的异或和：从 $v$ 到 $\\text{root}_v$ 的路径（奇偶性为 $\\text{parity}_v$），边 $(u,v)$（奇偶性为 $1$），以及从 $u$ 到 $\\text{root}_u$ 的路径（奇偶性为 $\\text{parity}_u$）。因此，我们设置 `parity[root_v] = parity_u \\oplus parity_v \\oplus 1$。\n$3$. **情况 B：相同分量 ($\\text{root}_u = \\text{root}_v$)**。该边被添加到一个已有的分量内部。这将创建一个环。在 DSU 树结构中，$u$ 和 $v$ 之间的路径长度奇偶性为 $\\text{parity}_u \\oplus \\text{parity}_v$。添加边 $(u,v)$（长度为 $1$）会创建一个长度奇偶性为 $(\\text{parity}_u \\oplus \\text{parity}_v \\oplus 1) \\pmod 2$ 的环。该环是奇数环当且仅当 $\\text{parity}_u \\oplus \\text{parity}_v = 0$，这可以简化为 $\\text{parity}_u = \\text{parity}_v$。这个条件意味着，在现有分量的二染色中，$u$ 和 $v$ 被强制要求具有相同的颜色。在它们之间添加一条边会产生一个无法解决的冲突。图不再是二分图。\n\n一个特殊情况是自环 $(u,u)$，它是一个长度为 $1$ 的环。这是一个奇数环，所以任何包含自环的图都不是二分图。\n\n最终的算法流程如下：对于每个具有 $n$ 个顶点和 $m$ 条边的序列的测试用例，我们为 $n$ 个顶点初始化 DSU 结构。然后我们从 $t=1$ 到 $m$ 遍历这些边。对于索引为 $t$ 的每条边 $(u,v)$：\n- 如果 $u=v$，我们遇到了一个自环。图变为非二分图。我们报告 $t$ 并终止处理此测试用例。\n- 否则，我们执行 `union(u, v)` 操作。如果它返回 `False`（表示存在冲突），我们报告 $t$ 并终止。\n- 如果循环完成而没有任何冲突，则所有图 $G_1, \\dots, G_m$ 都是二分图。我们报告 $0$。", "answer": "```python\nimport numpy as np\n\n# Although numpy is available, it is not used in this solution.\n# The solution uses only standard Python libraries.\n\nclass BipartiteDSU:\n    \"\"\"\n    An augmented Disjoint Set Union (DSU) data structure to track graph\n    bipartiteness. It checks for odd cycles as edges are added.\n    \"\"\"\n    def __init__(self, n):\n        \"\"\"\n        Initializes the DSU for n vertices (labeled 1 to n).\n        \n        Args:\n            n (int): The number of vertices.\n        \"\"\"\n        # Vertices are 1-indexed, so arrays are of size n+1.\n        self.parent = list(range(n + 1))\n        # self.parity[i] stores the parity of path length from node i to its parent.\n        # This is equivalent to color difference: 0 for same color, 1 for different.\n        self.parity = [0] * (n + 1)\n\n    def find(self, i):\n        \"\"\"\n        Finds the root of the set containing i and computes the parity of the\n        path from i to the root. Implements path compression.\n\n        Args:\n            i (int): The vertex to find.\n\n        Returns:\n            tuple[int, int]: A tuple (root, parity) where root is the\n                             representative of the set and parity is the path\n                             parity from i to the root.\n        \"\"\"\n        if self.parent[i] == i:\n            return i, 0\n        \n        # Recurse to find the root and the parity from parent[i] to the root.\n        root, parent_parity = self.find(self.parent[i])\n        \n        # Path Compression: Set the parent of i directly to the root.\n        self.parent[i] = root\n        \n        # Update Parity: The new parity of i is the XOR sum of its old\n        # parity (relative to its old parent) and its old parent's parity\n        # (relative to the root).\n        self.parity[i] ^= parent_parity\n        \n        return self.parent[i], self.parity[i]\n\n    def union(self, u, v):\n        \"\"\"\n        Processes the addition of an edge (u, v) and checks for conflicts\n        with the bipartite property.\n\n        Args:\n            u (int): The first vertex of the edge.\n            v (int): The second vertex of the edge.\n\n        Returns:\n            bool: True if the graph remains bipartite after adding the edge,\n                  False if an odd cycle is created.\n        \"\"\"\n        root_u, parity_u = self.find(u)\n        root_v, parity_v = self.find(v)\n\n        if root_u != root_v:\n            # The vertices are in different components. Merging them will not\n            # create a cycle, so the graph remains bipartite.\n            self.parent[root_v] = root_u\n            \n            # The new parity for root_v is determined by the path from root_v to\n            # root_u, which goes through v and u.\n            # Path: root_v -- v -- u --> root_u\n            # Parity(root_v -> root_u) = Parity(v->root_v) ^ Parity(u->v) ^ Parity(u->root_u)\n            self.parity[root_v] = parity_u ^ parity_v ^ 1\n            return True\n        else:\n            # The vertices are already in the same component. Adding an edge\n            # will create a cycle. The graph becomes non-bipartite if this\n            # cycle is of odd length. This occurs if u and v have the same\n            # parity relative to their common root.\n            if parity_u == parity_v:\n                return False  # Conflict: odd cycle detected.\n            return True # Consistent edge, no new information.\n\ndef solve():\n    \"\"\"\n    Main function to run the bipartite test on all specified test cases.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        (6, [(1,2),(2,3),(3,4),(4,5),(5,6),(6,1),(1,3)]),\n        # Test case 2\n        (5, [(1,2),(2,3),(3,4),(4,5)]),\n        # Test case 3\n        (3, [(1,2),(2,2),(2,3)]),\n        # Test case 4\n        (4, [(1,2),(2,3),(3,1),(4,1)]),\n        # Test case 5\n        (4, [(1,2),(2,3),(1,2),(3,4),(4,1),(2,4)]),\n        # Test case 6\n        (3, []),\n    ]\n\n    results = []\n    for n, edges in test_cases:\n        dsu = BipartiteDSU(n)\n        result_t = 0\n        for i, edge in enumerate(edges):\n            t = i + 1\n            u, v = edge\n\n            # A self-loop is an odd cycle of length 1.\n            if u == v:\n                result_t = t\n                break\n\n            if not dsu.union(u, v):\n                # union returns False if a conflict (odd cycle) is found.\n                result_t = t\n                break\n        \n        results.append(result_t)\n\n    # Format the final output string as specified.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3216756"}]}