{"hands_on_practices": [{"introduction": "许多现实世界的问题，例如分析迷宫、数字图像中的区域或地图上的岛屿，都可以被抽象为网格模型。这个练习提供了一个将网格结构转化为图论问题的具体实践，你将应用如图搜索（BFS）或深度优先搜索（DFS）等基本遍历算法来识别和计数不相连的区域。通过解决这个问题 [@problem_id:3223893]，你将掌握将几何问题转化为图问题并解决它的基本技能，这是许多计算机科学应用的核心。", "problem": "考虑一个有限二维网格，该网格建模为笛卡尔积 $\\{0,1,\\dots,m-1\\} \\times \\{0,1,\\dots,n-1\\}$，其中 $m$ 和 $n$ 为非负整数。一个子集 $B \\subseteq \\{0,1,\\dots,m-1\\} \\times \\{0,1,\\dots,n-1\\}$ 指定了被阻塞的单元格。定义一个无向图 $G=(V,E)$，其顶点集 $V$ 为所有未被阻塞的单元格，即 $V = \\left(\\{0,1,\\dots,m-1\\} \\times \\{0,1,\\dots,n-1\\}\\right) \\setminus B$。其边集 $E$ 恰好包含所有无序对 $\\{(i,j),(i',j')\\}$，满足两个端点都在 $V$ 中，且单元格在正交方向上相邻，即 $|i-i'|+|j-j'|=1$。如果存在一个顶点序列（一条路径）$u=v_0,v_1,\\dots,v_k=v$，其中每对连续的顶点都在 $E$ 中构成一条边，则称两个顶点 $u,v \\in V$ 是连通的。连通分量是 $V$ 的一个最大子集，其中任意一对顶点都是连通的。\n\n仅根据上述定义，推导出一个正确且高效的算法，用于计算未阻塞单元格的连通分量数量，该算法是关于 $m$、$n$ 和 $B$ 的函数。你的算法必须在上述正交邻接规则下运行，并且必须能够使用标准数据结构以确定性的方式实现。\n\n你的程序应当是自包含的（无输入），并评估以下测试套件。每个测试用例由一个三元组 $(m,n,B)$ 给出，其中集合 $B$ 被明确指定。在所有情况下，邻接关系均为正交邻接（4-邻域）。\n\n测试用例 1：$(m,n)=(5,7)$ 且 $B_1=\\{(0,1),(0,5),(1,1),(1,5),(2,3),(2,5),(3,0),(3,1),(3,2),(3,3),(3,5),(4,5)\\}$。\n\n测试用例 2：$(m,n)=(0,5)$ 且 $B_2=\\emptyset$。\n\n测试用例 3：$(m,n)=(3,3)$ 且 $B_3=\\{(0,0),(0,1),(0,2),(1,0),(1,1),(1,2),(2,0),(2,1),(2,2)\\}$。\n\n测试用例 4：$(m,n)=(1,6)$ 且 $B_4=\\{(0,1),(0,3),(0,4)\\}$。\n\n测试用例 5：$(m,n)=(3,4)$ 且 $B_5=\\emptyset$。\n\n你的程序应生成单行输出，其中包含五个测试用例的整数结果，按顺序排列，形式为用方括号括起来的逗号分隔列表（例如 $[r_1,r_2,r_3,r_4,r_5]$）。本问题不涉及任何物理单位、角度或百分比；所有输出均为无单位的整数。", "solution": "该问题要求计算一个无向图 $G=(V,E)$ 中连通分量的数量。该图的结构源于一个二维网格和一组被阻塞的单元格。这是图论和计算几何中的一个经典问题，可以使用标准的图遍历算法来解决。\n\n### 问题形式化\n\n网格被定义为点集 $\\{0,1,\\dots,m-1\\} \\times \\{0,1,\\dots,n-1\\}$，其中 $m$ 和 $n$ 是给定的非负整数。这些点的一个子集 $B$ 代表被阻塞的单元格。\n\n图 $G$ 的顶点集 $V$ 由所有未被阻塞的单元格组成：\n$$V = \\left(\\{0,1,\\dots,m-1\\} \\times \\{0,1,\\dots,n-1\\}\\right) \\setminus B$$\n如果两个顶点 $(i,j) \\in V$ 和 $(i',j') \\in V$ 在正交方向上相邻，则边集 $E$ 将它们连接起来。正交邻接的条件由单元格坐标之间的曼哈顿距离给出：\n$$|i-i'|+|j-j'|=1$$\n这种邻接规则也称为 4-邻域连通性。\n\n连通分量是一个最大子图，其中任意两个顶点都通过路径相互连接。任务是确定此类连通分量的总数。\n\n### 算法方法\n\n连通分量的数量可以通过系统地探索网格来确定。核心思想是遍历网格的每个单元格。如果发现一个未访问、未阻塞的单元格，它必定属于一个新的、尚未发现的连通分量。然后我们从该单元格开始进行图遍历，例如广度优先搜索 (BFS) 或深度优先搜索 (DFS)。该遍历将访问并标记属于同一分量的每个单元格。通过每次发现新分量时递增一个计数器，我们可以找到总数。\n\n一个维度为 $m \\times n$ 的二维数组将用作网格的表示。我们可以使用此数组中的整数值来编码每个单元格的状态：\n-  值 $-1$ 可以代表一个被阻塞的单元格。\n-  值 $0$ 可以代表一个未阻塞且未访问的单元格。\n-  一个正整数 $k > 0$ 可以表示该单元格已被访问并属于找到的第 $k$ 个分量。\n\n算法流程如下：\n\n1.  初始化一个用于记录分量数量的计数器 `count` 为 $0$。\n2.  创建一个 $m \\times n$ 的网格数据结构 `grid`。将所有单元格初始化为表示“未阻塞、未访问”的状态（例如，值 $0$）。\n3.  对于输入集 $B$ 中的每个单元格坐标 $(i,j)$，将 `grid` 中位置 $(i,j)$ 处的值更新为“阻塞”状态（例如，值 $-1$）。\n4.  处理网格为空的边缘情况：如果 $m=0$ 或 $n=0$，则顶点数为 $0$，因此连通分量数也为 $0$。\n5.  遍历网格的每个单元格 $(r,c)$，其中 $r$ 从 $0$ 到 $m-1$，$c$ 从 $0$ 到 $n-1$。\n6.  在每个单元格 $(r,c)$ 处：\n    - 如果 `grid[r,c]` 表示该单元格已被访问（值 $>0$）或被阻塞（值 $-1$），则不执行任何操作，继续处理下一个单元格。\n    - 如果 `grid[r,c]` 表示一个未访问、未阻塞的单元格（值 $0$），我们就找到了一个新的分量。\n        - 递增分量计数器：`count` $\\leftarrow$ `count` $+ 1$。\n        - 从 $(r,c)$ 开始进行广度优先搜索 (BFS)，以找到此新分量中的所有单元格。\n            - 创建一个队列，并将起始单元格 $(r,c)$ 加入队列。\n            - 通过设置 `grid[r,c]` $\\leftarrow$ `count` 将起始单元格标记为已访问。\n            - 当队列不为空时：\n                - 从队列中取出一个单元格，记为 $(r_{curr}, c_{curr})$。\n                - 对于其四个正交邻居 $(r_{neigh}, c_{neigh})$ 中的每一个：\n                    - 检查邻居是否在网格边界内（$0 \\le r_{neigh}  m$ 且 $0 \\le c_{neigh}  n$）。\n                    - 检查邻居是否未访问且未阻塞 (`grid[r_{neigh}, c_{neigh}] == 0`)。\n                    - 如果两个条件都满足，则将邻居标记为已访问 (`grid[r_{neigh}, c_{neigh}]` $\\leftarrow$ `count`) 并将其加入队列。\n7. 嵌套循环完成后，`count` 的最终值即为连通分量的总数。\n\n这个过程保证是正确的。它检查了每个单元格。每次启动遍历时，都是在一个尚未被分配给任何先前分量的单元格上进行的。遍历算法 (BFS/DFS) 确保所有可达的单元格——并且仅有这些单元格——被详尽地识别并标记为当前分量的一部分。因此，每个分量都只被计数一次。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport collections\n\ndef count_components(m: int, n: int, B: set) -> int:\n    \"\"\"\n    Computes the number of connected components in a 2D grid with blocked cells.\n\n    Args:\n        m: The number of rows in the grid.\n        n: The number of columns in the grid.\n        B: A set of tuples, where each tuple (r, c) is a blocked cell.\n\n    Returns:\n        The integer number of connected components of unblocked cells.\n    \"\"\"\n    if m == 0 or n == 0:\n        return 0\n\n    # grid[r, c] = 0: unblocked, unvisited\n    # grid[r, c] = -1: blocked\n    # grid[r, c] > 0: part of component with that ID\n    grid = np.zeros((m, n), dtype=np.int32)\n    for r, c in B:\n        if 0 = r  m and 0 = c  n:\n            grid[r, c] = -1\n\n    num_components = 0\n    for r in range(m):\n        for c in range(n):\n            if grid[r, c] == 0:\n                # Found a new component\n                num_components += 1\n                \n                # Start a Breadth-First Search (BFS) to find all cells in this component\n                q = collections.deque([(r, c)])\n                grid[r, c] = num_components # Mark as visited\n\n                while q:\n                    curr_r, curr_c = q.popleft()\n                    \n                    # Explore 4-directional neighbors\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        next_r, next_c = curr_r + dr, curr_c + dc\n                        \n                        # Check boundaries and if the neighbor is unvisited\n                        if 0 = next_r  m and 0 = next_c  n and grid[next_r, next_c] == 0:\n                            grid[next_r, next_c] = num_components\n                            q.append((next_r, next_c))\n                            \n    return num_components\n\ndef solve():\n    \"\"\"\n    Solves the pre-defined test cases for the connected components problem.\n    \"\"\"\n    test_cases = [\n        (5, 7, {(0, 1), (0, 5), (1, 1), (1, 5), (2, 3), (2, 5), (3, 0), (3, 1), (3, 2), (3, 3), (3, 5), (4, 5)}),\n        (0, 5, set()),\n        (3, 3, {(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2)}),\n        (1, 6, {(0, 1), (0, 3), (0, 4)}),\n        (3, 4, set())\n    ]\n\n    results = []\n    for m, n, B in test_cases:\n        result = count_components(m, n, B)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3223893"}, {"introduction": "在学会分析静态图的连通性之后，一个至关重要的进阶是理解当图的结构发生改变时，其连通性会受到怎样的影响。本练习探讨了移除顶点对图连通性的作用，这个概念是网络可靠性、鲁棒性分析以及识别关键网络节点（例如关节点）的核心。通过解决这个问题 [@problem_id:3223832]，你将学会如何处理和分析由原图生成的诱导子图，并加深对图结构动态变化的理解。", "problem": "考虑一个无向简单图 $G = (V, E)$，其中 $V = \\{0, 1, \\dots, n-1\\}$ 且 $E \\subseteq \\{\\{u, v\\} \\mid u \\in V, v \\in V, u \\neq v\\}$。对于一个顶点子集 $S \\subseteq V$，定义其导出子图 $G[V \\setminus S]$ 的顶点集为 $V \\setminus S$，边集为 $\\{\\{u, v\\} \\in E \\mid u \\notin S, v \\notin S\\}$。如果存在一条完全位于 $V \\setminus S$ 内、以 $u$ 为起点、以 $v$ 为终点的路径（一个顶点序列，其中相邻顶点对之间有边相连），则称两个顶点 $u, v \\in V \\setminus S$ 在 $G[V \\setminus S]$ 中是连通的。$G[V \\setminus S]$ 的一个连通分量是一个最大子集 $C \\subseteq V \\setminus S$，使得 $C$ 中的每对顶点在 $G[V \\setminus S]$ 中都是连通的。一个孤立顶点（在 $G[V \\setminus S]$ 中没有邻接边）也算作一个连通分量。\n\n仅根据这些定义，编写一个程序，为下面指定的每个测试案例，计算移除给定集合 $S$ 后导出子图中的连通分量数量。\n\n该图始终是有限的、无向的、简单的（没有自环或平行边）。顶点用从 $0$ 到 $n-1$ 的整数标记。边以无序对 $(u, v)$ 的形式给出，其中 $u \\neq v$。\n\n测试套件（每个案例由元组 $(n, E, S)$ 给出）：\n- 案例 1：$n = 9$, $E = \\{(0, 1), (1, 2), (2, 3), (2, 4), (4, 5), (5, 6), (6, 4), (7, 8)\\}$, $S = \\{2, 5\\}$。\n- 案例 2：$n = 5$, $E = \\{(0, 1), (1, 2)\\}$, $S = \\varnothing$。\n- 案例 3：$n = 4$, $E = \\{(0, 1), (2, 3)\\}$, $S = \\{0, 1, 2, 3\\}$。\n- 案例 4：$n = 6$, $E = \\varnothing$, $S = \\{1, 3\\}$。\n- 案例 5：$n = 7$, $E = \\{(0, 1), (1, 2), (2, 3), (3, 0), (3, 4), (4, 5)\\}$, $S = \\{1\\}$。\n- 案例 6：$n = 7$, $E = \\{(0, 1), (0, 2), (0, 3), (3, 4), (3, 5), (5, 6)\\}$, $S = \\{0, 3\\}$。\n\n你的程序应生成单行输出，其中包含六个案例的结果，形式为一个用方括号括起来的逗号分隔列表（例如，$[r_1, r_2, \\dots, r_6]$），其中每个 $r_i$ 是按上述顺序列出的案例 $i$ 的连通分量数量（整数）。", "solution": "该问题要求我们对于给定的几个图 $G=(V, E)$ 和顶点子集 $S$，确定导出子图 $G[V \\setminus S]$ 中的连通分量数量。\n\n### 问题验证\n\n**第1步：提取已知条件**\n- 图类型：无向简单图 $G = (V, E)$。\n- 顶点集：$V = \\{0, 1, \\dots, n-1\\}$。\n- 边集：$E \\subseteq \\{\\{u, v\\} \\mid u \\in V, v \\in V, u \\neq v\\}$。\n- 移除的顶点：一个子集 $S \\subseteq V$。\n- 导出子图：$G[V \\setminus S]$ 的顶点集为 $V' = V \\setminus S$，边集为 $E' = \\{\\{u, v\\} \\in E \\mid u \\notin S, v \\notin S\\}$。\n- 连通性：如果两个顶点 $u, v \\in V'$ 之间存在一条仅使用 $V'$ 中的顶点和 $E'$ 中的边的路径，则称它们在 $G[V \\setminus S]$ 中是连通的。\n- 连通分量：$V'$ 中互为连通的最大顶点子集。在 $G[V \\setminus S]$ 中的一个孤立顶点构成一个大小为 1 的分量。\n- 目标：为提供的六个测试案例，计算 $G[V \\setminus S]$ 中的连通分量数量。\n- 测试案例：\n    1. $n=9$, $E = \\{(0, 1), (1, 2), (2, 3), (2, 4), (4, 5), (5, 6), (6, 4), (7, 8)\\}$, $S = \\{2, 5\\}$。\n    2. $n=5$, $E = \\{(0, 1), (1, 2)\\}$, $S = \\varnothing$。\n    3. $n=4$, $E = \\{(0, 1), (2, 3)\\}$, $S = \\{0, 1, 2, 3\\}$。\n    4. $n=6$, $E = \\varnothing$, $S = \\{1, 3\\}$。\n    5. $n=7$, $E = \\{(0, 1), (1, 2), (2, 3), (3, 0), (3, 4), (4, 5)\\}$, $S = \\{1\\}$。\n    6. $n=7$, $E = \\{(0, 1), (0, 2), (0, 3), (3, 4), (3, 5), (5, 6)\\}$, $S = \\{0, 3\\}$。\n\n**第2步：使用提取的已知条件进行验证**\n该问题在图论这一明确定义的数学领域中具有科学依据。无向图、导出子图和连通分量的定义是标准且无歧义的。每个案例所需的所有数据（$n$、$E$、$S$）均已提供，使问题自成体系且完整。该问题是适定 (well-posed) 的，因为对于任何有限图，连通分量的数量都是一个唯一、可确定的整数。问题陈述是客观的，没有任何事实错误、逻辑矛盾或结构不当之处。\n\n**第3步：结论与行动**\n该问题是**有效**的。将着手制定解决方案。\n\n### 基于原理的解决方案\n\n计算图中连通分量数量的基本原理是系统地遍历其所有顶点。每当必须从一个之前未访问过的顶点开始遍历时，就意味着发现了一个新的连通分量。可以采用图遍历算法，如深度优先搜索（DFS）或广度优先搜索（BFS）来完成此任务。\n\n设导出子图为 $G' = G[V \\setminus S]$，其顶点集为 $V' = V \\setminus S$，边集为 $E' = \\{\\{u, v\\} \\in E \\mid u, v \\in V'\\}$。算法流程如下：\n\n1.  **构建导出子图 $G'$**：\n    首先，我们必须明确表示我们将要操作的图。顶点集 $V'$ 通过集合求差 $V \\setminus S = \\{v \\in V \\mid v \\notin S\\}$ 获得。边集 $E'$ 通过筛选原始边集 $E$ 构建，只保留那些两个端点都在 $V'$ 中的边。邻接表是用于此表示的一种高效数据结构，其中每个顶点 $v \\in V'$ 映射到其在 $G'$ 中的邻接顶点列表。\n\n2.  **初始化状态**：\n    我们需要一个用于计算分量数量的计数器，我们称之为 $c_{count}$，初始化为 $0$。我们还需要一种机制来跟踪已访问的顶点，以确保每个顶点只被处理一次。一个集合数据结构，我们称之为 $V_{visited}$，适合此目的，初始化为空集。\n\n3.  **迭代与遍历**：\n    该算法的核心是遍历导出子图顶点集 $V'$ 中的所有顶点。对于每个顶点 $v \\in V'$：\n    - 如果 $v$ 已经被访问过（即 $v \\in V_{visited}$），我们不做任何操作，继续处理下一个顶点。\n    - 如果 $v$ 尚未被访问（即 $v \\notin V_{visited}$），这标志着发现了一个新的、未探索的连通分量。我们接着：\n        a. 增加分量计数器：$c_{count} \\leftarrow c_{count} + 1$。\n        b. 从 $v$ 开始进行图遍历（例如 DFS）。此遍历将探索 $G'$ 中从 $v$ 可达的所有顶点。\n        c. 在遍历过程中，将遇到的每个顶点添加到 $V_{visited}$ 集合中，标记为已访问。\n\n4.  **图遍历（深度优先搜索）**：\n    可以使用一个栈来实现标准的迭代式深度优先搜索。\n    - 要从顶点 $v_{start}$ 开始遍历一个分量：\n        a. 初始化一个栈并将 $v_{start}$ 推入其中。\n        b. 当栈不为空时：\n            i. 从栈中弹出一个顶点，记为 $u$。\n            ii. 如果 $u$ 不在 $V_{visited}$ 中，则将其标记为已访问（$V_{visited} \\leftarrow V_{visited} \\cup \\{u\\}$）。\n            iii. 对于 $G'$ 邻接表中 $u$ 的每个邻居 $w$，如果 $w$ 不在 $V_{visited}$ 中，则将 $w$ 推入栈中。\n\n在遍历完 $V'$ 中的所有顶点后，$c_{count}$ 的最终值就是 $G'$ 中连通分量的总数。\n\n让我们将此过程应用于案例 1：\n- $n=9$, $V=\\{0, ..., 8\\}$, $S=\\{2, 5\\}$。\n- $V' = V \\setminus S = \\{0, 1, 3, 4, 6, 7, 8\\}$。\n- $E$ 中满足 $u,v \\in V'$ 的边有：$(0,1)$, $(4,6)$, $(7,8)$。\n- $G'$ 的邻接表：$\\{0:[1], 1:[0], 3:[], 4:[6], 6:[4], 7:[8], 8:[7]\\}$。\n- 算法执行：\n    - 初始化 $c_{count} = 0$， $V_{visited} = \\varnothing$。\n    - 选取顶点 $0 \\in V'$。它未被访问。\n        - $c_{count} \\leftarrow 1$。\n        - 从 $0$ 开始遍历。将访问顶点 $\\{0, 1\\}$。现在 $V_{visited} = \\{0, 1\\}$。\n    - 选取顶点 $3 \\in V'$。它未被访问。\n        - $c_{count} \\leftarrow 2$。\n        - 从 $3$ 开始遍历。将只访问 $\\{3\\}$。现在 $V_{visited} = \\{0, 1, 3\\}$。\n    - 选取顶点 $4 \\in V'$。它未被访问。\n        - $c_{count} \\leftarrow 3$。\n        - 从 $4$ 开始遍历。将访问顶点 $\\{4, 6\\}$。现在 $V_{visited} = \\{0, 1, 3, 4, 6\\}$。\n    - 选取顶点 $7 \\in V'$。它未被访问。\n        - $c_{count} \\leftarrow 4$。\n        - 从 $7$ 开始遍历。将访问顶点 $\\{7, 8\\}$。现在 $V_{visited} = \\{0, 1, 3, 4, 6, 7, 8\\}$。\n    - $V'$ 中所有顶点现已都在 $V_{visited}$ 中。循环终止。\n- 案例 1 的结果是 4。此逻辑将应用于所有测试案例。对于案例 3，$V'$ 是空的，因此连通分量的数量被正确地识别为 0。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the number of connected components for a series of graph test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (n, E, S)\n    # n: number of vertices\n    # E: set of edges as tuples\n    # S: set of vertices to remove\n    test_cases = [\n        (9, {(0, 1), (1, 2), (2, 3), (2, 4), (4, 5), (5, 6), (6, 4), (7, 8)}, {2, 5}),\n        (5, {(0, 1), (1, 2)}, set()),\n        (4, {(0, 1), (2, 3)}, {0, 1, 2, 3}),\n        (6, set(), {1, 3}),\n        (7, {(0, 1), (1, 2), (2, 3), (3, 0), (3, 4), (4, 5)}, {1}),\n        (7, {(0, 1), (0, 2), (0, 3), (3, 4), (3, 5), (5, 6)}, {0, 3}),\n    ]\n\n    results = []\n    for n, E, S in test_cases:\n        # Step 1: Determine the set of vertices in the induced subgraph G[V \\ S].\n        active_vertices = {i for i in range(n)} - S\n\n        # If there are no vertices in the induced subgraph, there are 0 components.\n        if not active_vertices:\n            results.append(0)\n            continue\n\n        # Step 2: Build the adjacency list for the induced subgraph.\n        # An adjacency list is a dictionary mapping each vertex to a list of its neighbors.\n        adj = {v: [] for v in active_vertices}\n        for u, v in E:\n            # An edge is part of the induced subgraph only if both its endpoints are.\n            if u in active_vertices and v in active_vertices:\n                adj[u].append(v)\n                adj[v].append(u)\n\n        # Step 3: Count connected components using a graph traversal algorithm.\n        visited = set()\n        num_components = 0\n\n        # Iterate through each vertex of the induced subgraph.\n        for vertex in active_vertices:\n            # If a vertex hasn't been visited, it belongs to a new component.\n            if vertex not in visited:\n                num_components += 1\n                # Start a traversal (iterative DFS) to find all vertices in this component.\n                stack = [vertex]\n                while stack:\n                    current_node = stack.pop()\n                    if current_node not in visited:\n                        visited.add(current_node)\n                        for neighbor in adj[current_node]:\n                            if neighbor not in visited:\n                                stack.append(neighbor)\n        \n        results.append(num_components)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3223832"}, {"introduction": "这个最终的练习将我们从单纯的图结构分析带入了网络设计和优化的领域。这个问题不仅要求你识别出图中所有不相连的组件，还挑战你设计一种成本最低的策略来将它们全部连接起来，这其中蕴含了贪心算法的思想。这个练习 [@problem_id:3223947] 极好地展示了连通分量分析如何常常作为解决更复杂优化问题的第一步，为你将来处理网络设计、基础设施规划等实际问题打下基础。", "problem": "给定一个有限、无向、带权图，其顶点集为 $V=\\{0,1,\\dots,n-1\\}$，边集为 $E\\subseteq \\{\\{u,v\\}\\mid u\\neq v,\\,u,v\\in V\\}$，以及一个定义在边上的非负权重函数 $w_E:\\,E\\to \\mathbb{R}_{\\ge 0}$。边权重 $w_E$ 仅用于定义一个真实的带权图实例；它们不计入您需要计算的成本。该图可能是不连通的，形成若干个连通分量。同时，给定一个非负的节点价格函数 $p:\\,V\\to \\mathbb{R}_{\\ge 0}$。您可以在不同的顶点 $u$ 和 $v$ 之间添加任何不在 $E$ 中的新无向边 $\\{u,v\\}$，添加这样一条边的成本为 $p(u)+p(v)$。$E$ 中已有的边是现成的，无需额外成本。\n\n任务。仅从无向图中连通分量的基本定义出发，并根据为使整个图连通，任何两个不同的分量必须至少由一条新边连接的要求，推导出一个算法，计算使整个图成为单个连通分量所需添加边的最小总成本。如果图已经是连通的，则成本为 $0$。所有量都必须视为精确的实数；无需报告物理单位。您必须从基本原理出发进行推理：精确定义连通分量，描述一条新边如何合并两个分量，并确定如何组合这些合并以最小的总成本实现全局连通。避免使用任何未经证明的快捷公式。\n\n每个测试用例的精确输入模型。一个测试用例是一个三元组 $(n,E,p)$，其中：\n1) $n$ 是一个整数，$n\\ge 1$，表示标记为 $0$ 到 $n-1$ 的顶点数量；\n2) $E$ 是一个三元组 $(u,v,w)$ 的列表，其中 $u$ 和 $v$ 是整数，满足 $0\\le u,v  n$，$u\\ne v$，且 $w\\in \\mathbb{R}_{\\ge 0}$；每个三元组表示 $u$ 和 $v$ 之间的一条无向边，其现有权重为 $w$（这个权重不直接影响您需要计算的成本）；\n3) $p$ 是一个长度为 $n$ 的列表，其第 $i$ 个条目 $p[i]$ 等于 $p(i)\\in \\mathbb{R}_{\\ge 0}$。\n\n您的程序必须为每个测试用例计算一个单一的数字，该数字等于在添加新边 $\\{u,v\\}$ 的成本为 $p(u)+p(v)$ 的规则下，使整个图变为连通所需的最小额外成本。如果图已经是连通的，成本必须为 $0$。\n\n测试套件。请严格按照以下顺序使用这五个测试用例：\n1) $n=6$, $E=\\{(0,1,4),(1,2,3),(3,4,2)\\}$, $p=[4,2,7,1,3,5]$。\n2) $n=4$, $E=\\{(0,1,5),(1,2,2),(2,3,1)\\}$, $p=[10,10,10,10]$。\n3) $n=2$, $E=\\{\\}$, $p=[7,3]$。\n4) $n=7$, $E=\\{(0,1,5),(3,4,1),(5,6,8)\\}$, $p=[8,6,5,9,2,4,7]$。\n5) $n=1$, $E=\\{\\}$, $p=[5]$。\n\n输出规范。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。例如，如果五个测试用例的结果是 $a_1,a_2,a_3,a_4,a_5$，那么您必须在一行上准确打印字符串“[a_1,a_2,a_3,a_4,a_5]”，不含空格。\n\n注意。\n1) 您必须将边视为无向边。如果 $(u,v,w)\\in E$，则 $(v,u,w)$ 也被隐式地视为在 $E$ 中。\n2) 您的算法不应假设除指定内容外的任何特殊结构。它必须对任何非负节点价格和任何无向图结构都正确。\n3) 在这些特定实例中，每个测试用例的答案都是一个整数，但通用算法必须能处理其他输入中可能出现的实数值 $p(i)$。", "solution": "对用户提供的问题评估如下。\n\n### 第1步：提取已知条件\n- **图结构**：一个有限、无向、带权图，其顶点集为 $V=\\{0,1,\\dots,n-1\\}$，边集为 $E\\subseteq \\{\\{u,v\\}\\mid u\\neq v,\\,u,v\\in V\\}$。\n- **边权重**：一个定义在现有边上的非负权重函数 $w_E:\\,E\\to \\mathbb{R}_{\\ge 0}$，该权重不计入待计算的成本。\n- **节点价格**：一个非负的节点价格函数 $p:\\,V\\to \\mathbb{R}_{\\ge 0}$。\n- **操作**：可以添加不在 $E$ 中的新无向边 $\\{u,v\\}$。\n- **成本函数**：添加一条新边 $\\{u,v\\}$ 的成本是 $p(u)+p(v)$。\n- **目标**：计算使整个图成为单个连通分量所需添加边的最小总成本。\n- **基本情况**：如果图已经是连通的，则成本为 $0$。\n- **输入模型**：一个测试用例是一个三元组 $(n, E, p)$，其中 $n$ 是顶点数， $E$ 是现有边的列表，形式为三元组 $(u,v,w)$， $p$ 是节点价格列表。\n- **测试套件**：\n    1. $n=6$, $E=\\{(0,1,4),(1,2,3),(3,4,2)\\}$, $p=[4,2,7,1,3,5]$。\n    2. $n=4$, $E=\\{(0,1,5),(1,2,2),(2,3,1)\\}$, $p=[10,10,10,10]$。\n    3. $n=2$, $E=\\{\\}$, $p=[7,3]$。\n    4. $n=7$, $E=\\{(0,1,5),(3,4,1),(5,6,8)\\}$, $p=[8,6,5,9,2,4,7]$。\n    5. $n=1$, $E=\\{\\}$, $p=[5]$。\n\n### 第2步：使用提取的已知条件进行验证\n- **科学基础**：该问题牢固地植根于图论，这是离散数学和计算机科学的一个标准领域。所有使用的概念——图、连通分量、最小生成树和成本优化——都定义明确且在数学上是严谨的。\n- **适定性**：该问题是适定的。给定一个有限图，添加边的方式有有限（尽管可能很大）种。由于成本是非负的，保证存在最小成本解。目标明确，可以找到唯一的最小成本值。\n- **客观性**：该问题使用形式化的数学语言和符号客观地陈述。没有主观或含糊不清的术语。\n- **缺陷分析**：\n    1. **科学性不健全**：该问题遵循图论原理。未发现缺陷。\n    2. **无法形式化/不相关**：该问题是形式化的，并直接与图中连通分量的主题相关。未发现缺陷。\n    3. **不完整/矛盾**：问题陈述是自洽的。它提供了构建图和成本结构所需的所有信息（$n, E, p$）。提到现有边权重 $w_E$ 不用于成本计算是一种澄清，而非矛盾。未发现缺陷。\n    4. **不现实/不可行**：作为一个抽象数学问题，物理现实性不是一个相关的标准。数学设置是一致的。未发现缺陷。\n    5. **不适定/结构不良**：该问题结构清晰，并导向唯一的最小成本。未发现缺陷。\n    6. **伪深刻/琐碎**：该问题需要一个从基本原理推导出的非平凡算法解，正如所要求的那样。这是一个标准但有实质内容的问题。未发现缺陷。\n    7. **无法科学验证**：该解可以通过数学证明其正确性。未发现缺陷。\n\n### 第3步：结论与行动\n该问题是 **有效的**。将提供一个合理的解决方案。\n\n### 解决方案\n目标是通过添加新边，以最小成本使给定图 $G=(V, E)$ 连通。添加一条边 $\\{u, v\\}$ 的成本定义为 $p(u) + p(v)$。我们被要求从基本原理出发推导解决方案。\n\n**1. 连通分量与目标**\n\n如果一个无向图的任意两个顶点之间都存在路径，则称该图是*连通的*。关系“是连通的”是顶点集 $V$ 上的一个等价关系。这个关系的等价类被称为图的*连通分量*。设初始图有 $k$ 个连通分量，记为 $C_1, C_2, \\dots, C_k$。要使整个图连通，我们必须添加边，以使所有顶点都属于同一个分量。\n\n如果 $k \\le 1$，图已经是连通的或平凡的，根据定义，成本为 $0$。\n\n如果 $k > 1$，我们必须添加边来将这 $k$ 个分量合并成一个。添加一条边 $\\{u, v\\}$，其中 $u \\in C_i$ 且 $v \\in C_j$，$i \\neq j$，会将分量 $C_i$ 和 $C_j$ 合并成一个更大的分量。在同一个分量内添加边不会减少分量的数量。要连接一个有 $k$ 个分量的图，我们必须至少添加 $k-1$ 条边，在这些分量自身上形成一个生成树结构。我们的目标是选择这 $k-1$ 条边以最小化总成本。\n\n**2. 最优连接策略**\n\n让我们在分量上对问题建模。考虑一个“超图”，其中每个顶点代表一个连通分量 $C_i$。我们希望在这个超图中找到一个最小生成树 (MST)。两个超顶点 $C_i$ 和 $C_j$ 之间的边权重是单条新边连接它们所需的最小可能成本。\n\n连接分量 $C_i$ 到分量 $C_j$ 的成本由下式给出：\n$$ \\min_{u \\in C_i, v \\in C_j} \\{p(u) + p(v)\\} $$\n由于 $p(u)$ 和 $p(v)$ 两项是独立的，这个最小值可以通过在每个分量中选择价格最低的顶点来达到。\n$$ (\\min_{u \\in C_i} p(u)) + (\\min_{v \\in C_j} p(v)) $$\n让我们定义 $w_i = \\min_{u \\in C_i} p(u)$ 作为分量 $C_i$ 内的最小节点价格。因此，连接 $C_i$ 和 $C_j$ 的成本是 $w_i + w_j$。\n\n我们现在需要在一个有 $k$ 个顶点（代表分量）的完全图上找到一个最小生成树，其中顶点 $i$ 和顶点 $j$ 之间的边权重是 $w_i + w_j$。设所选的生成树边集为 $T_{comp}$。总成本为：\n$$ \\text{Cost} = \\sum_{\\{i, j\\} \\in T_{comp}} (w_i + w_j) $$\n这个和可以根据分量生成树中顶点的度数来重写。如果 $d(i)$ 是分量 $C_i$ 在树 $T_{comp}$ 中的度数，那么它的最小价格 $w_i$ 在和中被包含了 $d(i)$ 次。\n$$ \\text{Cost} = \\sum_{i=1}^{k} d(i) w_i $$\n对于任何有 $k$ 个顶点的树，我们知道 $d(i) \\ge 1$ 且 $\\sum_{i=1}^{k} d(i) = 2(k-1)$。为了最小化总成本（这是一个度的加权和），我们应该将最大的度分配给权重（价格）$w_i$ 最小的顶点。这是重排不等式的直接应用。\n\n在一个有 $k$ 个顶点的树中，可能的最大度数是 $k-1$，这出现在星形图中。一个星形图有一个度为 $k-1$ 的中心顶点和 $k-1$ 个度为 $1$ 的叶顶点。为了最小化成本，我们应该选择具有全局最小价格的分量作为中心的“锚点”分量。假设分量价格排序为 $w_{(1)} \\le w_{(2)} \\le \\dots \\le w_{(k)}$。我们选择对应于 $w_{(1)}$ 的分量作为中心。它在生成树中的度将是 $d((1)) = k-1$。所有其他分量 $C_{(j)}$（对于 $j \\in \\{2, \\dots, k\\}$）的度将是 $d((j)) = 1$。这个策略将每个其他分量直接连接到唯一的“最便宜的”锚点分量。\n\n**3. 成本公式推导**\n\n这种最优星形图策略的总成本是连接每个非锚点分量到锚点分量的 $k-1$ 条边的成本之和：\n$$ \\text{Cost} = \\sum_{j=2}^{k} (w_{(1)} + w_{(j)}) $$\n这可以展开并简化：\n$$ \\text{Cost} = (k-1) w_{(1)} + \\sum_{j=2}^{k} w_{(j)} $$\n令 $S = \\sum_{j=1}^{k} w_{(j)}$ 为所有分量最小价格的总和。我们可以写出 $\\sum_{j=2}^{k} w_{(j)} = S - w_{(1)}$。将其代入成本表达式中：\n$$ \\text{Cost} = (k-1) w_{(1)} + (S - w_{(1)}) = k w_{(1)} - w_{(1)} + S - w_{(1)} = S + (k-2) w_{(1)} $$\n所以，最小成本是所有分量最小价格的总和，加上全局最小价格的 $(k-2)$ 倍。此公式适用于 $k \\ge 2$。对于 $k=2$，成本是 $S + (0)w_{(1)} = S = w_{(1)} + w_{(2)}$，这是正确的。对于 $k=1$，成本是 $0$。\n\n**4. 最终算法**\n\n完整的算法如下：\n1.  给定图参数 $(n, E, p)$，构建图的邻接表表示。\n2.  识别图的连通分量。这可以通过图遍历算法（如广度优先搜索 (BFS) 或深度优先搜索 (DFS)）来完成。维护一个 `visited` 数组来跟踪已发现的顶点。\n3.  在遍历每个分量时，找到该分量中所有顶点的最小节点价格。将这些最小价格存储在一个列表 `component_min_prices` 中。\n4.  令 $k$ 为找到的连通分量的数量（即 `component_min_prices` 的长度）。\n5.  如果 $k \\le 1$，图已经是连通的或平凡的。成本为 $0$。\n6.  如果 $k > 1$，使用推导出的公式计算最小总成本：\n    a. 计算 $S$，即 `component_min_prices` 中所有值的总和。\n    b. 找到 $w_{\\min\\_global}$，即 `component_min_prices` 中的最小值。\n    c. 总成本为 $S + (k-2) \\times w_{\\min\\_global}$。\n7.  返回计算出的成本。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem for a predefined suite of test cases.\n    \"\"\"\n    # Test cases as defined in the problem statement.\n    test_cases = [\n        (6, [(0, 1, 4), (1, 2, 3), (3, 4, 2)], [4, 2, 7, 1, 3, 5]),\n        (4, [(0, 1, 5), (1, 2, 2), (2, 3, 1)], [10, 10, 10, 10]),\n        (2, [], [7, 3]),\n        (7, [(0, 1, 5), (3, 4, 1), (5, 6, 8)], [8, 6, 5, 9, 2, 4, 7]),\n        (1, [], [5])\n    ]\n\n    results = []\n    for n, E, p in test_cases:\n        cost = compute_min_cost(n, E, p)\n        # The problem statement implies integer results for these specific test cases.\n        results.append(int(cost))\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef compute_min_cost(n, edges, prices):\n    \"\"\"\n    Computes the minimum cost to make a graph connected.\n\n    The algorithm proceeds as follows:\n    1. Identify all connected components of the graph.\n    2. For each component, find the minimum node price among its vertices.\n    3. If there is only one component (or fewer), the graph is already connected; cost is 0.\n    4. If there are k > 1 components, the minimum cost is achieved by connecting all other\n       k-1 components to the one \"anchor\" component that contains the node with the\n       globally minimum price.\n    5. The total cost is derived as S + (k-2)*w_min_global, where S is the sum of\n       all component-minimum prices and w_min_global is the smallest of these prices.\n    \"\"\"\n    if n = 1:\n        return 0\n\n    # Adjacency list representation of the graph\n    adj = [[] for _ in range(n)]\n    for u, v, _ in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    visited = [False] * n\n    component_min_prices = []\n\n    for i in range(n):\n        if not visited[i]:\n            # A new component is found, start a traversal (DFS)\n            min_price_in_component = float('inf')\n            \n            stack = [i]\n            visited[i] = True\n            \n            while stack:\n                u = stack.pop()\n                min_price_in_component = min(min_price_in_component, prices[u])\n                \n                for v in adj[u]:\n                    if not visited[v]:\n                        visited[v] = True\n                        stack.append(v)\n            \n            component_min_prices.append(min_price_in_component)\n\n    k = len(component_min_prices)\n    \n    if k = 1:\n        return 0\n    else:\n        # Sum of the minimum node prices from each component\n        sum_of_min_prices = sum(component_min_prices)\n        \n        # Globally minimum price among all component minimums\n        global_min_price = min(component_min_prices)\n        \n        # Derived formula for the total minimum cost\n        total_cost = sum_of_min_prices + (k - 2) * global_min_price\n        return total_cost\n\n# Execute the solution\nsolve()\n\n```", "id": "3223947"}]}