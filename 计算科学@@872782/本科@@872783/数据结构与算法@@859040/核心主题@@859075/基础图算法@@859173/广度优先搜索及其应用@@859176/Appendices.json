{"hands_on_practices": [{"introduction": "在许多现实世界的寻路问题中，我们不仅要找到最短路径，还需要遵守特定的限制，例如避开某些危险或禁止通行的区域。这个练习将引导你处理这类约束。通过对标准的广度优先搜索（BFS）算法进行微小的修改，即在搜索过程中简单地忽略“禁区”节点，你将学会如何在一个受限的环境中有效地规划路径。[@problem_id:3218360]", "problem": "考虑一个有限、简单、无权的图 $G=(V,E)$，其中 $V$ 是一个由不同整数标记的有限节点集，而 $E \\subseteq \\{\\,(u,v)\\mid u,v \\in V,\\, u \\neq v\\,\\}$ 是一个无向边集。路径是一个节点序列 $(v_0,v_1,\\ldots,v_k)$，满足对所有 $i \\in \\{0,1,\\ldots,k-1\\}$ 都有 $(v_i,v_{i+1}) \\in E$。路径的长度是序列中的边数，即 $k$。给定两个不同的节点 $s,t \\in V$ 和一个禁止节点集 $F \\subseteq V$，一条从 $s$ 到 $t$ 的可接受路径是一条始于 $s$、终于 $t$ 且不包含任何来自 $F$ 中节点的路径。根据定义，如果 $s \\in F$ 或 $t \\in F$，则不存在可接受路径。\n\n你必须计算从 $s$ 到 $t$ 的最短可接受路径（如果存在），并遵循以下确定性决胜规则：在所有长度最小的可接受路径中，返回节点序列字典序最小的那条。为确保确定性，在探索邻居时，始终按数值升序考虑邻居。如果不存在可接受路径，则返回空列表。\n\n你可以假定的基本原理如下：在无权图中，广度优先搜索的扩展层对应于距源节点的最短路径距离，且限制在导出子图上会保留相对于该子图的路径长度。\n\n你的程序必须实现此计算，并为以下测试套件生成输出。在每种情况下，将 $E$ 解释为无向集：对于每个 $(u,v) \\in E$，$(u,v)$ 和 $(v,u)$ 都是允许的移动。\n\n- 测试用例1（常规路径，因禁止节点而被迫绕路）：\n  - $V = \\{0,1,2,3,4,5,6\\}$。\n  - $E = \\{(0,1),(0,3),(1,2),(2,3),(2,5),(5,6),(3,4),(4,6)\\}$。\n  - $s = 0$, $t = 6$, $F = \\{3\\}$。\n  - 预期行为：经过节点3的直接路线被禁止；找到最短的可接受路径。\n\n- 测试用例2（边界条件，其中 $s=t$）：\n  - $V = \\{0,1,2\\}$。\n  - $E = \\{(0,1),(1,2)\\}$。\n  - $s = 2$, $t = 2$, $F = \\varnothing$。\n  - 预期行为：最短可接受路径长度为0，是单节点序列。\n\n- 测试用例3（目标节点被禁止）：\n  - $V = \\{0,1,2,3,4\\}$。\n  - $E = \\{(0,1),(1,4),(0,2),(2,3),(3,4)\\}$。\n  - $s = 0$, $t = 4$, $F = \\{4\\}$。\n  - 预期行为：不存在可接受路径。\n\n- 测试用例4（源节点被禁止）：\n  - $V = \\{0,1,2,3\\}$。\n  - $E = \\{(0,1),(1,2),(2,3)\\}$。\n  - $s = 1$, $t = 3$, $F = \\{1\\}$。\n  - 预期行为：不存在可接受路径。\n\n- 测试用例5（存在多条最短可接受路径，需要字典序决胜）：\n  - $V = \\{0,1,2,3,4\\}$。\n  - $E = \\{(0,1),(1,4),(0,2),(2,4),(0,3),(3,4)\\}$。\n  - $s = 0$, $t = 4$, $F = \\varnothing$。\n  - 预期行为：存在多条长度最小的可接受路径；返回字典序最小的那条。\n\n输出规范：你的程序应生成单行输出，其中包含上述五个测试用例的结果，结果为一个逗号分隔的列表，并用方括号括起来。每个测试用例的结果必须是一个整数列表，表示返回的从 $s$ 到 $t$ 的路径上的节点序列（含 $s$ 和 $t$），如果不存在可接受路径，则为空列表 $[]$。例如，输出可能看起来像 $[[0,1,2,5,6],[2],[],[],[0,1,4]]$。此问题中没有物理量；因此，不需要物理单位。最终输出中唯一可接受的数据类型是整数列表，聚合为指定的单个顶层列表。", "solution": "本任务是在一个有限、简单、无权的图 $G=(V,E)$ 中找到从源节点 $s$ 到目标节点 $t$ 的一条最短路径。该路径必须是“可接受的”，意味着它不能通过给定禁止集 $F$ 中的任何节点。此外，在所有最短可接受路径中，必须选择字典序最小的那一条。值得注意的是，虽然一般性问题描述指定“两个不同的节点 $s,t \\in V$”，但测试用例2提供了一个 $s=t$ 的实例，这被视为一个明确的边界条件。\n\n在无权图中寻找最短路径的基本原理是广度优先搜索（BFS）算法。BFS从源节点 $s$ 开始逐层探索图。这保证了首次到达目标节点 $t$ 时所走的路径是长度最小的（即边数最少）路径之一。\n\n解决方案必须在标准BFS框架中整合三个主要特性：\n1.  **处理禁止节点**：通过将集合 $F$ 中的节点视为图中不存在的节点，来满足路径必须是可接受的这一约束。问题定义如果 $s \\in F$ 或 $t \\in F$，则不存在可接受路径。这构成了一个必须在启动搜索前检查的基本情况。在搜索过程中，任何属于 $F$ 的邻居节点 $v$ 都将被忽略，不会被添加到探索队列中。\n2.  **字典序决胜**：问题要求在所有最短路径中找到字典序最小的路径。这通过强制执行确定性的探索顺序来实现。规则“在探索邻居时，始终按数值升序考虑邻居”确保了这一属性。当BFS从节点 $u$ 扩展时，它会将其邻居按升序排序后入队。让我们考虑两条长度相同且最小的路径 $P_1 = (s, \\dots, u, v_1, \\dots, t)$ 和 $P_2 = (s, \\dots, u, v_2, \\dots, t)$，它们在共同前缀 $(s, \\dots, u)$ 后的第一个节点处不同。如果 $v_1  v_2$，那么BFS将先从 $v_1$ 探索，再从 $v_2$ 探索。因此，从 $v_1$ 出发的子路径将被探索，并通过这条路线找到目标 $t$，之后搜索才会从同一深度的 $v_2$ 继续。算法在首次找到 $t$ 时终止，从而保证发现的路径不仅长度最小，而且是字典序最小的。\n3.  **路径重建**：标准的BFS能找到最短路径的*长度*，但本身不存储路径。为了重建路径，我们使用一个父节点映射，这是一种数据结构（例如，字典），用于存储搜索路径上每个已访问节点的前驱节点。对于从节点 $u$ 访问到的节点 $v$，我们设置 `parent[v] = u`。一旦找到目标 $t$，就可以通过这个父节点映射从 $t$ 回溯到 $s$，然后反转得到的序列来重建路径。\n\n完整的算法如下：\n\n1.  **预处理和初始检查**：\n    - 给定节点集 $V$、边集 $E$、源节点 $s$、目标节点 $t$ 和禁止节点集 $F$。\n    - 检查 $s \\in F$ 或 $t \\in F$ 是否成立。如果成立，则不存在可接受路径；返回一个空列表。\n    - 如果 $s = t$，最短路径长度为0，由该节点本身构成。返回列表 $[s]$。\n    - 构建图 $G$ 的邻接表表示，其中对每个节点 $u \\in V$，其邻居列表按升序排序。这对字典序决胜规则至关重要。\n\n2.  **BFS执行**：\n    - 初始化一个用于BFS的队列，并加入源节点 $s$：`queue = [s]`。\n    - 初始化一个已访问节点的集合，以防止循环和冗余探索，其中仅包含源节点：`visited = {s}`。\n    - 初始化一个父节点映射以重建路径：`parents = {s: None}`。\n\n3.  **图遍历**：\n    - 当队列不为空时：\n        - 将当前节点 $u$ 出队。\n        - 如果 $u = t$，则已找到最短的、字典序最小的路径。进入路径重建步骤。\n        - 对于 $u$ 的每个邻居 $v$（按预先排序的升序）：\n            - 如果 $v$ 未被访问过且 $v \\notin F$：\n                - 将 $v$ 标记为已访问：将 $v$ 添加到 `visited`。\n                - 记录父节点：`parents[v] = u`。\n                - 将 $v$ 入队：`queue.append(v)`。\n\n4.  **路径重建或失败**：\n    - 如果循环结束（队列为空）而目标 $t$ 未被达到（即 `t` 不在 `parents` 映射中），则不存在可接受路径。返回一个空列表。\n    - 如果 $t$ 被达到，则使用 `parents` 映射从 $t$ 回溯到 $s$。初始化一个路径列表 `path = [t]`。当路径中的最后一个节点不是 $s$ 时，将其父节点前插到路径中：`path.insert(0, parents[path[0]])`。返回重建的 `path`。\n\n该算法正确且高效地计算了所需的路径，满足了问题的所有约束。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport collections\n\ndef find_shortest_admissible_path(V, E, s, t, F):\n    \"\"\"\n    Computes the shortest admissible path from s to t with lexicographical tie-breaking.\n\n    Args:\n        V (set): The set of nodes.\n        E (set): The set of undirected edges as tuples.\n        s (int): The source node.\n        t (int): The target node.\n        F (set): The set of forbidden nodes.\n\n    Returns:\n        list: The sequence of nodes in the path, or an empty list if no path exists.\n    \"\"\"\n    # Step 1: Initial checks for admissibility.\n    if s in F or t in F:\n        return []\n\n    # Handle the boundary condition where s and t are the same.\n    if s == t:\n        return [s]\n\n    # Build the adjacency list with sorted neighbors for deterministic exploration.\n    adj = {node: [] for node in V}\n    for u, v in E:\n        adj[u].append(v)\n        adj[v].append(u)\n    for node in adj:\n        adj[node].sort()\n    \n    # Step 2: BFS Initialization\n    # A standard Python list used as a queue with pop(0) is slow.\n    # collections.deque is a double-ended queue optimized for appends and pops from either end.\n    queue = collections.deque([s])\n    visited = {s}\n    # Parent map for path reconstruction.\n    parents = {s: None}\n\n    # Step 3: BFS Traversal\n    path_found = False\n    while queue:\n        u = queue.popleft()\n\n        if u == t:\n            path_found = True\n            break\n\n        for v in adj.get(u, []):\n            if v not in visited and v not in F:\n                visited.add(v)\n                parents[v] = u\n                queue.append(v)\n\n    # Step 4: Path Reconstruction\n    if not path_found:\n        return []\n\n    path = []\n    curr = t\n    while curr is not None:\n        path.append(curr)\n        curr = parents[curr]\n    \n    return path[::-1] # Reverse the path to get s to t order.\n\ndef solve():\n    \"\"\"\n    Defines and runs the test cases specified in the problem statement.\n    \"\"\"\n    test_cases = [\n        {\n            \"V\": {0, 1, 2, 3, 4, 5, 6},\n            \"E\": {(0, 1), (0, 3), (1, 2), (2, 3), (2, 5), (5, 6), (3, 4), (4, 6)},\n            \"s\": 0, \"t\": 6, \"F\": {3}\n        },\n        {\n            \"V\": {0, 1, 2},\n            \"E\": {(0, 1), (1, 2)},\n            \"s\": 2, \"t\": 2, \"F\": set()\n        },\n        {\n            \"V\": {0, 1, 2, 3, 4},\n            \"E\": {(0, 1), (1, 4), (0, 2), (2, 3), (3, 4)},\n            \"s\": 0, \"t\": 4, \"F\": {4}\n        },\n        {\n            \"V\": {0, 1, 2, 3},\n            \"E\": {(0, 1), (1, 2), (2, 3)},\n            \"s\": 1, \"t\": 3, \"F\": {1}\n        },\n        {\n            \"V\": {0, 1, 2, 3, 4},\n            \"E\": {(0, 1), (1, 4), (0, 2), (2, 4), (0, 3), (3, 4)},\n            \"s\": 0, \"t\": 4, \"F\": set()\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = find_shortest_admissible_path(\n            case[\"V\"], case[\"E\"], case[\"s\"], case[\"t\"], case[\"F\"]\n        )\n        results.append(result)\n\n    # Custom formatter to match the output specification (no spaces).\n    def format_list(lst):\n        return f\"[{','.join(map(str, lst))}]\"\n    \n    formatted_results = [format_list(res) for res in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\n\nsolve()\n```", "id": "3218360"}, {"introduction": "当路径的约束条件取决于路径本身的属性（例如长度的奇偶性）时，简单的广度优先搜索（BFS）就不再适用。这个练习将向你展示一种更强大、更抽象的技巧：扩展状态空间。通过重新定义搜索状态，将其从单一的“顶点”扩展为“（顶点，路径属性）”的元组，我们可以将原问题巧妙地转化为在一个新的、隐含的状态图上的标准最短路问题。这个思想是解决各类复杂搜索问题的关键。[@problem_id:3218441]", "problem": "你的任务是设计并实现一个算法解决方案，该方案基于图的基本定义和广度优先搜索（BFS）算法经过充分检验的特性，用于确定有向图中的受约束最短路径。考虑一个有限、有向、无权的图 $G = (V, E)$，其中 $|V| = n$ 且 $|E| = m$，$V$ 是一个有限的顶点集合，$E \\subseteq V \\times V$ 是一个有限的有向边集合。从顶点 $s \\in V$到顶点 $t \\in V$ 的一条路径是一个顶点序列 $(v_0, v_1, \\dots, v_k)$，满足 $v_0 = s$，$v_k = t$，并且对于所有整数 $i$（$1 \\le i \\le k$），都有 $(v_{i-1}, v_i) \\in E$。路径的长度是它包含的边的数量，即 $k$。如果路径的长度 $k$ 是一个偶数（包括 $k = 0$），则称其为偶数长度路径。\n\n你的程序必须为下面的测试套件中的每个测试用例，计算从指定的源顶点 $s$ 到指定的目标顶点 $t$ 的最短偶数长度路径的长度。如果不存在偶数长度的路径，则对该测试用例返回 $-1$。答案应以整数形式报告。\n\n解决方案必须基于以下基础推导得出：\n- 图、路径和路径长度的基本定义。\n- 广度优先搜索（BFS）在有限无权图上会按距离的非递减顺序发现顶点，并能以边的数量计算最短路径长度这一经过充分检验的事实。\n\n测试套件。对于每个测试用例，图都是有向且无权的。每个用例都指定了顶点数 $n$、以有序对表示的边集 $E$ 以及查询 $(s, t)$。\n\n- 用例 $1$：\n  $$n = 6,\\quad E = \\{(0,1),(1,2),(2,3),(3,4),(4,5),(0,2),(2,4)\\},\\quad s = 0,\\ t = 4.$$\n- 用例 $2$：\n  $$n = 3,\\quad E = \\{(0,1),(1,2),(2,0),(2,1)\\},\\quad s = 0,\\ t = 1.$$\n- 用例 $3$：\n  $$n = 2,\\quad E = \\{(0,1)\\},\\quad s = 0,\\ t = 1.$$\n- 用例 $4$：\n  $$n = 4,\\quad E = \\{(0,1),(1,2),(2,3),(3,0)\\},\\quad s = 0,\\ t = 0.$$\n- 用例 $5$：\n  $$n = 6,\\quad E = \\{(0,1),(1,3),(3,5),(0,2),(2,4),(4,5),(1,2)\\},\\quad s = 0,\\ t = 5.$$\n- 用例 $6$：\n  $$n = 2,\\quad E = \\{(0,1),(1,1)\\},\\quad s = 0,\\ t = 1.$$\n\n要求的最终输出格式。你的程序应生成单行输出，其中包含所有用例的结果，按顺序排列，作为一个用方括号括起来的逗号分隔列表，不含空格，例如 $[r_1,r_2,\\dots,r_k]$，其中每个 $r_i$ 是用例 $i$ 的整数答案。", "solution": "本问题要求在有向无权图中找到两个顶点之间最短的偶数长度路径的长度。该解决方案必须基于图论原理和广度优先搜索（BFS）算法推导得出。\n\n### 解法推导\n\n该问题要求找到带有附加路径长度奇偶性约束的最短路径的长度。标准的广度优先搜索（BFS）算法保证能在无权图中找到最短路径，其中“最短”定义为最少的边数。然而，标准的BFS本身不区分不同奇偶性长度的路径。BFS找到的最短路径可能是奇数长度的，这不符合我们问题的有效解。\n\n为了整合奇偶性约束，我们必须扩展搜索中使用的状态表示。标准BFS中的一个状态对应于一个顶点 $v \\in V$。我们需要一个状态表示，它不仅编码当前位置（顶点），还编码到达该位置的路径的奇偶性。\n\n让我们定义一个新的状态空间。一个状态可以由一个对 $(v, p)$ 表示，其中 $v \\in V$ 是一个顶点，$p \\in \\{0, 1\\}$ 是从源顶点 $s$ 到 $v$ 的路径长度的奇偶性。这里，$p=0$ 表示偶数长度路径，$p=1$ 表示奇数长度路径。\n\n这种概念上的扩展可以通过构建一个新图 $G' = (V', E')$ 来形式化。\n- 新图中的顶点集合是 $V' = V \\times \\{0, 1\\}$。该集合的大小为 $|V'| = 2n$。$G'$ 中的一个顶点 $(v, p)$ 表示我们通过一条奇偶性为 $p$ 的路径到达了 $G$ 中的顶点 $v$。\n- $G'$ 中的边集 $E'$ 源自 $G$ 中的边。对于 $E$ 中的每条边 $(u, v)$，遍历它会使路径长度增加 $1$，从而翻转路径长度的奇偶性。这对应于 $G'$ 中的两条有向边：\n  1. 从 $(u, 0)$ 到 $(v, 1)$ 的边：一条到 $u$ 的偶数长度路径，后跟边 $(u,v)$，得到一条到 $v$ 的奇数长度路径。\n  2. 从 $(u, 1)$ 到 $(v, 0)$ 的边：一条到 $u$ 的奇数长度路径，后跟边 $(u,v)$，得到一条到 $v$ 的偶数长度路径。\n\n在原始图 $G$ 中寻找从 $s$ 到 $t$ 的最短偶数长度路径的问题，现在转化为在新图 $G'$ 中寻找从一个起始顶点到一个目标顶点的最短路径问题。起点是从 $s$ 到其自身的一条长度为 $0$ 的路径。由于 $0$ 是偶数，因此 $G'$ 中的起始状态是 $(s, 0)$。我们寻找一条到 $t$ 的偶数长度路径，所以 $G'$ 中的目标状态是 $(t, 0)$。\n\n由于原始图 $G$ 是无权的，转换后的图 $G'$ 也是无权的。因此，我们可以在 $G'$ 上应用标准的BFS算法来找到从 $(s, 0)$ 到 $(t, 0)$ 的最短路径。这条在 $G'$ 中的路径长度等于其在 $G$ 中对应路径的长度。\n\n算法流程如下：\n1. 我们不需要显式地构建 $G'$。我们可以在隐式的状态空间上执行BFS。\n2. 我们使用一个队列来存储待访问的状态。队列中的每个元素将是一个元组 `(vertex, length)`，例如 $(u, d)$。\n3. 我们使用一个二维数组 `distances[v][p]` 来存储到目前为止找到的、到达顶点 $v$ 且路径奇偶性为 $p$ 的最短路径长度。该数组大小为 $n \\times 2$，并用一个表示不可达的值（如 $-1$）进行初始化。此数组也用于跟踪已访问的状态，以防止循环和冗余计算。\n4. 搜索从源点 $s$ 开始，路径长度为 $0$。我们初始化 `distances[s][0] = 0` 并将 $(s, 0)$ 添加到队列中。\n5. BFS主循环：\n    a. 从队列中取出一个状态 $(u, d)$。\n    b. 对于原始图 $G$ 中 $u$ 的每个邻居 $v$：\n        i. 到 $v$ 的新路径长度为 $d_{\\text{new}} = d + 1$。\n        ii. 这条新路径的奇偶性为 $p_{\\text{new}} = d_{\\text{new}} \\pmod 2$。\n        iii. 如果状态 $(v, p_{\\text{new}})$ 尚未被访问（即 `distances[v][p_{new}] == -1`），我们便找到了到达此状态的最短路径。我们记录其长度 `distances[v][p_{new}] = d_{new}`，并将新状态 $(v, d_{\\text{new}})$ 入队。\n6. BFS持续进行直到队列为空。\n7. 最终答案是到 $t$ 的最短偶数长度路径的长度，存储在 `distances[t][0]` 中。如果 `distances[t][0]` 仍为其初始值 $-1$，则意味着状态 $(t, 0)$ 从未被到达，因此不存在从 $s$ 到 $t$ 的偶数长度路径。\n\n一个特殊情况是当 $s = t$ 时。从 $s$ 到其自身的长度为 $0$ 的路径是一条偶数长度路径。因此，答案是 $0$。所描述的算法能正确处理这种情况，因为 `distances[s][0]` 被初始化为 $0$。\n\n这种基于原则的方法通过扩展状态空间以包含约束本身，正确地调整了BFS算法来解决受约束的最短路径问题。", "answer": "```python\nimport collections\nimport numpy as np\n\ndef solve_case(n, E, s, t):\n    \"\"\"\n    Computes the length of the shortest even-length path from s to t.\n\n    The problem is solved by running a Breadth-First Search (BFS) on an\n    expanded state space. A state is defined by a pair (vertex, parity),\n    where parity is 0 for even-length paths and 1 for odd-length paths.\n\n    This is equivalent to finding the shortest path in a new graph G' where\n    each vertex v in the original graph G is split into two vertices, (v, 0)\n    and (v, 1). An edge (u, v) in G corresponds to edges ((u, 0), (v, 1))\n    and ((u, 1), (v, 0)) in G'.\n\n    We seek the shortest path from state (s, 0) to (t, 0).\n\n    Args:\n        n (int): The number of vertices.\n        E (list of tuples): The set of directed edges.\n        s (int): The source vertex.\n        t (int): The target vertex.\n\n    Returns:\n        int: The length of the shortest even-length path, or -1 if none exists.\n    \"\"\"\n    if n == 0:\n        return -1\n\n    adj = collections.defaultdict(list)\n    for u, v in E:\n        adj[u].append(v)\n    \n    # A path of length 0 from s to s is an even-length path.\n    if s == t:\n        return 0\n\n    # distances[v][p] stores the shortest distance to vertex v\n    # with a path of parity p (0 for even, 1 for odd).\n    # Initialize with -1 to indicate unreachability.\n    distances = np.full((n, 2), -1, dtype=int)\n    \n    # The queue stores tuples of (vertex, current_path_length).\n    queue = collections.deque()\n\n    # Start BFS from source s with a path of length 0.\n    # The path is even, so update distances for parity 0.\n    distances[s][0] = 0\n    queue.append((s, 0))\n\n    while queue:\n        u, path_len = queue.popleft()\n        \n        new_path_len = path_len + 1\n        new_parity = new_path_len % 2\n\n        for v in adj[u]:\n            # If we haven't found a path to vertex v with this new_parity,\n            # this must be the shortest one.\n            if distances[v][new_parity] == -1:\n                distances[v][new_parity] = new_path_len\n                queue.append((v, new_path_len))\n                \n                # If we've just reached the target with an even path, we are done\n                # because BFS guarantees this is the shortest such path.\n                if v == t and new_parity == 0:\n                    return new_path_len\n\n    # If the BFS completes and distances[t][0] is still -1, no even path exists.\n    return distances[t][0]\n\n\ndef solve():\n    \"\"\"\n    Defines and runs the test suite for the shortest even-length path problem.\n    \"\"\"\n    test_cases = [\n        {\"n\": 6, \"E\": [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (0, 2), (2, 4)], \"s\": 0, \"t\": 4},\n        {\"n\": 3, \"E\": [(0, 1), (1, 2), (2, 0), (2, 1)], \"s\": 0, \"t\": 1},\n        {\"n\": 2, \"E\": [(0, 1)], \"s\": 0, \"t\": 1},\n        {\"n\": 4, \"E\": [(0, 1), (1, 2), (2, 3), (3, 0)], \"s\": 0, \"t\": 0},\n        {\"n\": 6, \"E\": [(0, 1), (1, 3), (3, 5), (0, 2), (2, 4), (4, 5), (1, 2)], \"s\": 0, \"t\": 5},\n        {\"n\": 2, \"E\": [(0, 1), (1, 1)], \"s\": 0, \"t\": 1},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_case(case[\"n\"], case[\"E\"], case[\"s\"], case[\"t\"])\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3218441"}]}