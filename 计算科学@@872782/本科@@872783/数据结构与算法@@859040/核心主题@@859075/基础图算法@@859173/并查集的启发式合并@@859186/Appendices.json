{"hands_on_practices": [{"introduction": "该练习提供了一个亲手实现带有核心启发式策略——路径压缩和按大小合并——的并查集（DSU）的机会。通过模拟网格上岛屿的形成过程，你将具体地理解并查集如何高效地管理动态连通性问题。这是计算机图形学、网络分析等领域中的一个基础应用。[@problem_id:3228210]", "problem": "你需要实现一个程序，使用带有按大小合并和路径压缩启发式策略的不相交集并查集（DSU）数据结构，来模拟网格中陆地连通分量的增量形成过程。目标是在每次添加陆地后，计算在 $4$-邻域邻接条件下当前连通分量（即“岛屿”）的数量。\n\n基本原理和定义：\n- 一个不相交集并查集（DSU）维护一个有限全集到不相交集的划分，并支持两种操作：$find(x)$，返回包含元素 $x$ 的集合的规范代表元；以及 $union(x,y)$，如果包含 $x$ 和 $y$ 的集合不同，则合并它们。\n- 在按大小合并中，合并两个集合时，将较小集合的根节点附加到较大集合的根节点上，以确保树的高度增长缓慢。在路径压缩中，执行 $find(x)$ 期间，路径上访问的每个节点都会直接链接到根节点，从而为未来的查询扁平化结构。\n- 对于坐标为 $(i,j)$ 的单元格，其 $4$-邻域由 $(i-1,j)$、$(i+1,j)$、$(i,j-1)$ 和 $(i,j+1)$ 组成，且必须是有效的网格索引。如果两个陆地单元格之间存在一条通过 $4$-邻域步骤的陆地单元格路径，则它们是连通的。这在陆地单元格集合上导出了一个等价关系，每个等价类对应一个岛屿。\n\n任务：\n- 考虑一个 $r \\times c$ 的网格，其中 $r \\in \\mathbb{Z}_{\\ge 0}$ 且 $c \\in \\mathbb{Z}_{\\ge 0}$，单元格通过从零开始的坐标 $(i,j)$ 索引，$i \\in \\{0,\\dots,r-1\\}$，$j \\in \\{0,\\dots,c-1\\}$。初始时，所有单元格都是水域。\n- 给定一个包含 $k$ 个添加操作的有序列表 $(p_1, p_2, \\dots, p_k)$，其中每个 $p_t = (i_t, j_t)$ 指定在步骤 $t$ 将位于第 $i_t$ 行和第 $j_t$ 列的单元格变为陆地。如果指定的单元格已经是陆地，则该步骤网格状态不发生改变。\n- 在每个步骤 $t \\in \\{1,\\dots,k\\}$ 后，计算在 $4$-邻域连通性下存在的岛屿数量。\n\n要求：\n- 你必须实现带有按大小合并和路径压缩两种启发式策略的不相交集并查集（DSU）。\n- 你的算法除了上述基本 DSU 定义和连通性定义外，不得假定任何先验知识。\n- 程序不应读取输入。相反，它必须在内部运行以下参数值的测试套件（每个都指定为一个元组 $(r,c,\\text{additions})$）：\n  - 测试用例 1：$(r,c) = (3,3)$，additions $\\left[(0,0),(0,1),(1,2),(2,1),(1,1)\\right]$。\n  - 测试用例 2：$(r,c) = (1,1)$，additions $\\left[(0,0),(0,0),(0,0)\\right]$。\n  - 测试用例 3：$(r,c) = (2,2)$，additions $\\left[(0,0),(1,1),(0,1),(1,0)\\right]$。\n  - 测试用例 4：$(r,c) = (2,3)$，additions $\\left[(0,0),(1,1),(0,2),(1,2)\\right]$。\n  - 测试用例 5：$(r,c) = (5,5)$，additions $\\left[\\right]$（空列表）。\n- 对于每个测试用例，你的程序必须生成一个长度为 $k$ 的整数列表（对于空列表，长度可能为 $0$），其中第 $t$ 个整数是处理第 $t$ 次添加操作后的岛屿数量。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个元素对应一个测试用例，其本身也是该测试用例的整数列表。例如，输出形式必须为 $\\left[\\text{case}_1,\\text{case}_2,\\dots,\\text{case}_m\\right]$，其中每个 $\\text{case}_i$ 是一个类似 $\\left[a_1,a_2,\\dots,a_k\\right]$ 的列表。\n- 此问题不涉及物理单位。所有角度（如有）均与此问题无关。", "solution": "该问题要求模拟网格中连通分量的动态形成过程。这是不相交集并查集（Disjoint-Set Union, DSU）数据结构（也称为 Union-Find 数据结构）的一个经典应用。问题的核心是在添加元素（网格单元格）时维护和查询连通性信息。\n\n**1. 理论基础：动态连通性与等价关系**\n\n“岛屿”或陆地单元格连通分量的概念基于一个等价关系。如果两个陆地单元格之间存在一条通过相邻陆地单元格（在 $4$-邻域邻接条件下）连接的路径，那么它们就属于同一个分量。DSU 数据结构就是为管理由这种等价关系导出的集合划分而明确设计的。\n\n一个作用于包含 $N$ 个元素的全集上的 DSU 结构维护着一组不相交的集合。它主要支持两种操作：\n-   `find(x)`：确定包含元素 $x$ 的集合的规范代表元（或“根”）。\n-   `union(x,y)`：合并包含元素 $x$ 和 $y$ 的两个集合。\n\n为了在均摊基础上达到近乎常数的时间复杂度，两种启发式策略至关重要：\n-   **按大小合并**：合并两个集合时，将较小集合（按元素数量计）的根节点作为较大集合根节点的子节点。这可以防止表示集合的树变得过深。\n-   **路径压缩**：在执行 `find(x)` 操作期间，从 $x$到其根节点的路径上的每个节点都成为根节点的直接子节点。这会扁平化树形结构，极大地加速未来对该路径上元素的 `find` 操作。\n\n当同时使用这两种启发式策略时，对包含 $N$ 个元素的集合执行 $m$ 次操作的时间复杂度为 $O(m \\cdot \\alpha(N))$，其中 $\\alpha(N)$ 是增长极其缓慢的反阿克曼函数。对于所有实际应用场景，$\\alpha(N)$ 都是一个很小的常数（小于 $5$）。\n\n**2. 算法模型**\n\n要将 DSU 数据结构应用于网格问题，我们必须将网格单元格映射到 DSU 全集中的元素。\n\n-   **全集映射**：一个维度为 $r \\times c$ 的网格包含 $r \\cdot c$ 个单元格。我们可以将坐标为 $(i,j)$（其中 $i \\in \\{0, \\dots, r-1\\}$，$j \\in \\{0, \\dots, c-1\\}$）的每个单元格映射到一个唯一的整数索引。一种标准的行主序映射由公式给出：$\\text{index} = i \\cdot c + j$。这创建了一个包含元素 $\\{0, 1, \\dots, r \\cdot c - 1\\}$ 的全集。\n\n-   **状态表示**：我们需要管理每个单元格的状态（水域或陆地）以及 DSU 数据。一个大小为 $r \\cdot c$ 的 `parent` 数组用于 DSU。我们可以使用一个哨兵值（如 $-1$）来表示单元格是水域。当索引为 `idx` 的单元格变为陆地时，我们初始化其 DSU 条目，例如，通过设置 `parent[idx] = idx`。一个同样大小的 `size` 数组存储每个集合的大小，该值仅在集合的根节点处有意义。\n\n-   **分量计数**：岛屿的数量恰好是陆地单元格不相交集的数量。我们维护一个计数器 `num_components`。\n    -   当一个水域单元格变为陆地时，它最初形成一个大小为 $1$ 的新岛屿。因此，我们递增 `num_components`。\n    -   当我们对属于不同集合的两个单元格执行 `union` 操作时，它们各自的岛屿会合并。这会使岛屿总数减少一。因此，每次成功合并时，我们递减 `num_components`。\n\n**3. 步骤化算法**\n\n对于每个具有参数 $(r, c, \\text{additions})$ 的测试用例：\n\n1.  **初始化**：\n    -   如果 $r=0$ 或 $c=0$，网格没有单元格。结果为空列表。\n    -   创建一个大小为 $r \\cdot c$ 的 `parent` 数组，并将其所有元素初始化为 $-1$ 以表示水域。\n    -   创建一个大小为 $r \\cdot c$ 的 `size` 数组，初始化为 $1$。\n    -   将 `num_components` 初始化为 $0$。\n    -   初始化一个空列表 `results` 以存储每一步后的岛屿数量。\n\n2.  **处理添加操作**：对于 $t=1, \\dots, k$，遍历 `additions` 列表中的每个坐标对 $(i_t, j_t)$。\n    a.  计算一维索引：$\\text{idx}_t = i_t \\cdot c + j_t$。\n    b.  **检查是否已为陆地**：如果 `parent[idx_t]` 不为 $-1$，则该单元格已是陆地。岛屿数量不变。将当前的 `num_components` 追加到 `results` 列表中，并继续处理下一个添加操作。\n    c.  **添加新陆地**：如果 `parent[idx_t]` 为 $-1$：\n        i.  将该单元格初始化为一个新分量：设置 `parent[idx_t] = idx_t`。\n        ii. 将 `num_components` 增加 $1$。\n        iii. **检查邻居**：对于 $(i_t, j_t)$ 的 $4$ 个邻居 $(n_i, n_j)$ 中的每一个：\n            -   验证邻居的坐标是否在网格边界内（$0 \\le n_i  r$ 且 $0 \\le n_j  c$）。\n            -   计算邻居的索引：$\\text{n_idx} = n_i \\cdot c + n_j$。\n            -   如果邻居是陆地（即 `parent[n_idx] != -1`），则对 $\\text{idx}_t$ 和 $\\text{n_idx}$ 执行 `union` 操作。\n            -   `union` 操作涉及使用带路径压缩的 `find` 来查找两个元素的根。设根为 `root1` 和 `root2`。\n            -   如果 `root1 \\neq root2`，则发生合并。实现按大小合并：将较小的树附加到较大树的根上，并更新较大树根的大小。关键地，将 `num_components` 减少 $1$。\n    d.  检查完所有邻居后，将当前步骤 $t$ 的最终 `num_components` 值追加到 `results` 列表中。\n\n3.  **最终结果**：处理完所有添加操作后，`results` 列表包含了所需的岛屿数量序列。\n\n**4. 复杂度分析**\n\n-   **时间复杂度**：$O(k \\cdot \\alpha(r \\cdot c))$，其中 $k$ 是添加操作的数量。每次添加涉及常数次 DSU 操作（一次初始化和最多四次 `union` 操作，每次 `union` 操作包含两次 `find` 调用）。\n-   **空间复杂度**：$O(r \\cdot c)$，用于存储 DSU 结构的 `parent` 和 `size` 数组。\n\n这种方法效率很高，并且正确地模拟了岛屿形成的动态过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation on the provided test suite.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (3, 3, [(0, 0), (0, 1), (1, 2), (2, 1), (1, 1)]),\n        (1, 1, [(0, 0), (0, 0), (0, 0)]),\n        (2, 2, [(0, 0), (1, 1), (0, 1), (1, 0)]),\n        (2, 3, [(0, 0), (1, 1), (0, 2), (1, 2)]),\n        (5, 5, []),\n    ]\n\n    all_results = []\n    for r, c, additions in test_cases:\n        result = _calculate_islands(r, c, additions)\n        all_results.append(result)\n\n    # Format the final output string as specified.\n    # Each case result, being a list, is converted to a string representation\n    # without spaces, e.g., \"[1,2,3]\".\n    # These strings are then joined by commas and enclosed in an outer bracket.\n    formatted_case_results = [f\"[{','.join(map(str, res))}]\" for res in all_results]\n    final_output_string = f\"[{','.join(formatted_case_results)}]\"\n    \n    print(final_output_string)\n\n\ndef _calculate_islands(r, c, additions):\n    \"\"\"\n    Calculates the number of islands after each addition for a single test case.\n    \n    This function implements the Disjoint-Set Union (DSU) data structure with\n    path compression and union-by-size heuristics to solve the dynamic\n    connectivity problem.\n    \"\"\"\n    if r == 0 or c == 0:\n        return []\n\n    num_cells = r * c\n    # The `parent` array serves dual purposes:\n    # 1. For the DSU structure, parent[i] stores the parent of element i.\n    # 2. A value of -1 indicates the cell is water.\n    parent = np.full(num_cells, -1, dtype=int)\n    \n    # The `size` array stores the size of the set for each root element.\n    # It is initialized to 1s, as each new land cell starts as a set of size 1.\n    size = np.ones(num_cells, dtype=int)\n    \n    num_components = 0\n    results_for_case = []\n\n    # The `find` operation with path compression.\n    # It is defined as a nested function to have access to the `parent` array.\n    def find(i):\n        if parent[i] == i:\n            return i\n        # Path compression: set the parent of i directly to the root.\n        parent[i] = find(parent[i])\n        return parent[i]\n\n    for row, col in additions:\n        idx = row * c + col\n\n        # If the cell is already land, the number of components does not change.\n        if parent[idx] != -1:\n            results_for_case.append(num_components)\n            continue\n\n        # A new land cell is added, so it initially forms a new island.\n        parent[idx] = idx\n        num_components += 1\n        \n        # Check the 4-directional neighbors.\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            n_row, n_col = row + dr, col + dc\n\n            # Check if the neighbor is within a valid grid range.\n            if 0 = n_row  r and 0 = n_col  c:\n                n_idx = n_row * c + n_col\n                \n                # If the neighbor is also land, attempt to union the two components.\n                if parent[n_idx] != -1:\n                    root1 = find(idx)\n                    root2 = find(n_idx)\n                    \n                    if root1 != root2:\n                        # Union-by-size: attach the smaller tree to the root of the larger tree.\n                        if size[root1]  size[root2]:\n                            root1, root2 = root2, root1\n                        \n                        parent[root2] = root1\n                        size[root1] += size[root2]\n                        \n                        # Merging two components reduces the island count by one.\n                        num_components -= 1\n        \n        results_for_case.append(num_components)\n        \n    return results_for_case\n\nsolve()\n```", "id": "3228210"}, {"introduction": "除了简单的连通性判断，并查集还可以被扩展以解决更复杂的图论问题。本练习挑战你通过为并查集增加奇偶性信息，来动态地检查图的二分性——这是图论中的一个关键属性，在调度和资源分配等领域有广泛应用。该实践展示了如何在并查集操作中嵌入额外逻辑，以追踪超越简单集合成员关系的属性。[@problem_id:3228343]", "problem": "您的任务是设计并实现一个带扩展信息的不相交集并查集（Disjoint-Set Union, DSU）数据结构，用于在插入边的过程中动态地强制执行二着色约束，从而检测图在添加边的过程中是否保持为二分图。\n\n不相交集并查集（DSU），也称为 Union-Find，维护了将一个集合划分为多个不相交子集的操作，支持两种操作：find 和 union。find 操作用于定位包含给定元素的子集的代表（根节点），而 union 操作用于合并两个子集。当通过两种启发式方法——路径压缩和按大小或按秩合并——进行优化后，每次操作的摊还复杂度接近常数。\n\n基本原理：\n- 一个图是二分图，当且仅当它的顶点可以被染成两种颜色，使得每条边的两个顶点颜色都不同。等价地，一个图是二分图，当且仅当它不包含奇数长度的环。\n- 在加边操作下，DSU 维护了不相交的连通分量。为了在仅包含加边操作的动态环境下使用 DSU 判断二分性，需要为每个节点扩展一个奇偶校验位，用于存储该节点到其当前 DSU 树根节点路径长度的奇偶性（模 $2$）。这个奇偶性可以解释为该节点相对于根节点的颜色。\n- 两种 DSU 启发式方法是：\n  - 路径压缩：更新从节点到根节点路径上的所有父节点指针，使其直接指向根节点，从而扁平化 DSU 树。\n  - 按大小（或按秩）合并：将较小的树附加到较大树的根节点下，以保持树的浅度。\n\n您的任务：\n- 对于每个测试用例，您将得到一个顶点数 $n$ 和一个无向边列表 $(u, v)$。这些边将逐一添加到一个初始无边、顶点集为 $\\{1,2,\\dots,n\\}$ 的图中。\n- 您必须确定使得图变为非二分图的最早的边索引 $i$（边序列使用从 1 开始的索引）。这里假设在插入第 $i$ 条边之前，图是二分图。如果所有边插入后图仍然是二分图，则返回 $0$。\n\n精确定义和约束：\n- 设 $G = (V, E)$ 是一个简单的无向图，但出于测试目的，输入中允许自环。自环 $(u, u)$ 会立即使图变为非二分图。\n- 维护一个 DSU，其中包含为每个节点 $x$ 存储以下信息的数组：一个父节点指针和一个奇偶校验位 $p[x]$，该值等于在当前 DSU 森林中从 $x$ 到 $\\operatorname{root}(x)$ 的唯一路径长度的奇偶性（模 $2$）。在路径压缩下，更新 $p[x]$，使其在压缩后仍然表示从 $x$ 到其新父节点的路径奇偶性。\n- 当插入一条边 $(u, v)$ 时：\n  - 如果 $\\operatorname{root}(u) \\ne \\operatorname{root}(v)$，则使用按大小合并来合并这两个集合，并设置被附加的根节点的奇偶性，以保持 $u$ 和 $v$ 颜色相反的奇偶性约束。\n  - 如果 $\\operatorname{root}(u) = \\operatorname{root}(v)$，检查当前的奇偶性是否意味着 $u$ 和 $v$ 的颜色相反。如果不是，则检测到一个奇数环，图在这次插入后变为非二分图。\n\n每个测试用例的所需输出：\n- 一个整数，等于最早违反条件的边的索引 $i$（从 1 开始计数），如果未发生违反，则为 $0$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含按测试用例顺序排列的结果，格式为方括号内用逗号分隔的列表，无空格，例如：“[x,y,z]”。\n\n测试套件：\n- 对于下面的每一项，$n$ 是顶点数，后面是按顺序添加的边序列。您必须为每一项输出一个整数，如上所述。\n  - 测试用例 1：$n = 5$，边为 $[(1,2),(3,4),(2,3),(4,5)]$。\n  - 测试用例 2：$n = 4$，边为 $[(1,2),(2,3),(3,4),(4,1)]$。\n  - 测试用例 3：$n = 3$，边为 $[(1,2),(2,3),(1,3)]$。\n  - 测试用例 4：$n = 3$，边为 $[(1,1)]$。\n  - 测试用例 5：$n = 6$，边为 $[(1,2),(2,3),(3,1),(4,5),(5,6)]$。\n  - 测试用例 6：$n = 7$，边为 $[(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(1,7)]$。\n  - 测试用例 7：$n = 5$，边为 $[]$。\n\n您的程序必须是一个完整、可运行的实现，它需要构建所述的、带有按大小合并和路径压缩的 DSU，处理每个测试用例，并按上述格式打印单行结果。程序不应读取用户输入；所有数据都应嵌入在程序中。", "solution": "该问题要求设计一个带扩展信息的不相交集并查集 (DSU) 数据结构，以确定在一系列向初始无边图插入边的操作中，哪一条边最先使图变为非二分图。\n\n一个图是二分图当且仅当它不包含奇数长度的环。任务是在添加边的过程中检测到第一个奇数长度环的形成。DSU 非常适合跟踪连通分量。扩展部分涉及存储额外信息以检查奇数环条件。\n\n核心思想是维护图的各个连通分量的二着色。对于每个分量，我们可以为每个顶点分配一种颜色（例如 $0$ 或 $1$），使得相邻顶点的颜色不同。这等价于维护一个分量中任意两个节点之间路径长度的奇偶性。我们在 DSU 结构中为每个节点 $x$ 扩展一个值，我们称之为奇偶校验位，表示其相对于其所在分量根节点的颜色。\n\n设 $c(x)$ 为顶点 $x$ 的颜色，其中 $c(x) \\in \\{0, 1\\}$。对于任意边 $(u,v)$，必须满足 $c(u) \\neq c(v)$。这等价于 $(c(u) + c(v)) \\pmod 2 = 1$。在我们的 DSU 中，我们不存储绝对颜色，而是存储从一个节点到其在 DSU 树中父节点距离的奇偶性。设其为 $p[x]$。该值表示 $c(x) \\oplus c(\\text{parent}[x])$，其中 $\\oplus$ 是异或运算，等价于模 2 加法。\n\n为了提高效率，DSU 将通过路径压缩和按大小合并来实现。带扩展信息的操作逻辑如下：\n\n**状态表示：**\n对于一个有 $n$ 个顶点的图，我们使用三个大小为 $n+1$ 的数组，以支持从 1 开始的顶点索引：\n- $\\text{parent}[i]$：存储节点 $i$ 的父节点。集合的根是一个满足 $\\text{parent}[r] = r$ 的节点 $r$。\n- $\\text{size}[i]$：如果 $i$ 是根节点，则存储该集合中的元素数量。\n- $\\text{parity}[i]$：存储从节点 $i$ 到其父节点路径长度的奇偶性，即 $c(i) \\oplus c(\\text{parent}[i])$。\n\n**初始化：**\n对于每个顶点 $i \\in \\{1, \\dots, n\\}$：\n- $\\text{parent}[i] = i$。\n- $\\text{size}[i] = 1$。\n- $\\text{parity}[i] = 0$，因为一个节点到自身的距离为 0。\n\n**带路径压缩的 Find 操作：**\n`find(i)` 操作返回包含 $i$ 的分量的根节点，以及从 $i$ 到该根节点路径长度的奇偶性。此路径奇偶性为 $c(i) \\oplus c(\\text{root}(i))$。\n\n我们将 `find(i)` 定义为返回一个数对 $(\\text{root}, d)$，其中 $d = c(i) \\oplus c(\\text{root})$。\n如果 $i$ 是一个根节点（$\\text{parent}[i] = i$），那么路径长度为 $0$，因此我们返回 $(i, 0)$。\n否则，我们对其父节点递归调用 `find`：$(\\text{root}, d_{\\text{parent}}) = \\text{find}(\\text{parent}[i])$。\n这里，$d_{\\text{parent}} = c(\\text{parent}[i]) \\oplus c(\\text{root})$。\n从 $i$ 到根节点的总奇偶性为：\n$$d = (c(i) \\oplus c(\\text{parent}[i])) \\oplus (c(\\text{parent}[i]) \\oplus c(\\text{root})) = \\text{parity}[i] \\oplus d_{\\text{parent}}$$\n在路径压缩期间，我们设置 $\\text{parent}[i] = \\text{root}$。值 $\\text{parity}[i]$ 必须被更新以反映这种新的父子关系。新的 $\\text{parity}[i]$ 变为我们刚刚计算出的总路径奇偶性 $d$。\n\n**Union 操作与二分性检查：**\n当考虑添加一条边 $(u, v)$ 时：\n1. 首先，我们为 $u$ 和 $v$ 找到根节点和路径奇偶性：\n   - $(\\text{root}_u, d_u) = \\text{find}(u)$\n   - $(\\text{root}_v, d_v) = \\text{find}(v)$\n   其中 $d_u = c(u) \\oplus c(\\text{root}_u)$ 且 $d_v = c(v) \\oplus c(\\text{root}_v)$。\n\n2. 如果 $\\text{root}_u = \\text{root}_v$，则顶点 $u$ 和 $v$ 已经处于同一个连通分量中。添加边 $(u, v)$ 会创建一个环。当且仅当这个新环的长度为偶数时，图才保持二分性。这意味着分量内 $u$ 和 $v$ 之间的路径长度必须为奇数。\n   $u$ 和 $v$ 相对于它们共同根节点的颜色由它们的路径奇偶性给出。\n   $c(u) = c(\\text{root}_u) \\oplus d_u$\n   $c(v) = c(\\text{root}_u) \\oplus d_v$\n   二分性的条件是 $c(u) \\neq c(v)$，这意味着 $c(\\text{root}_u) \\oplus d_u \\neq c(\\text{root}_u) \\oplus d_v$，简化为 $d_u \\neq d_v$。如果我们发现 $d_u = d_v$，则形成了一个奇数环，图变为非二分图。这是一个冲突。\n\n3. 如果 $\\text{root}_u \\neq \\text{root}_v$，则顶点位于不同的分量中。添加边 $(u, v)$ 会合并这些分量。图保持二分性。我们执行一次（按大小）合并操作，并更新奇偶性信息。\n   假设我们将 $\\text{root}_v$ 的树附加到 $\\text{root}_u$ 的树上，使 $\\text{parent}[\\text{root}_v] = \\text{root}_u$。我们必须定义新的 $\\text{parity}[\\text{root}_v]$，即 $c(\\text{root}_v) \\oplus c(\\text{root}_u)$。\n   必须满足边的约束条件 $c(u) \\neq c(v)$。代入 `find` 操作中的关系：\n   $c(\\text{root}_u) \\oplus d_u \\neq c(\\text{root}_v) \\oplus d_v$\n   利用异或的性质重新排列得到：\n   $c(\\text{root}_u) \\oplus c(\\text{root}_v) \\neq d_u \\oplus d_v$\n   左侧正是我们需要为 $\\text{parity}[\\text{root}_v]$ 设置的量。为了使不等式成立，我们必须设置 $\\text{parity}[\\text{root}_v] = d_u \\oplus d_v \\oplus 1$。在模 2 算术中，这等于 $(p_u + p_v + 1) \\pmod 2$。\n\n通过对序列中的每条边依次应用此逻辑，我们可以找到引入冲突的第一条边的索引。如果在处理完所有边后没有出现冲突，则图保持二分性，答案为 $0$。自环 $(u, u)$ 会被此逻辑正确处理：`find(u)` 被调用两次，返回相同的根和奇偶性，由于 $d_u=d_u$，立即导致冲突。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass DSU:\n    \"\"\"\n    An augmented Disjoint-Set Union (DSU) data structure.\n    It supports union by size, path compression, and tracks parity\n    to check for bipartiteness in a dynamic graph.\n    \"\"\"\n    def __init__(self, n):\n        # Vertices are 1-indexed, so we use size n+1\n        self.parent = list(range(n + 1))\n        # self.parity[i] stores the parity of the distance from i to its parent.\n        # This represents color(i) XOR color(parent(i)).\n        self.parity = [0] * (n + 1)\n        self.size = [1] * (n + 1)\n\n    def find(self, i):\n        \"\"\"\n        Finds the root of the set containing i, with path compression and parity update.\n        Returns a tuple (root, parity), where parity is the parity of the path from i to the root.\n        \"\"\"\n        if self.parent[i] == i:\n            return i, 0\n\n        # Recursively find the root of the parent\n        root, parent_parity = self.find(self.parent[i])\n\n        # Path compression: point i's parent directly to the root\n        self.parent[i] = root\n        \n        # Update parity: The new parity from i to the root is the XOR sum\n        # of parities along the old path: parity(i-parent) ^ parity(parent-root).\n        self.parity[i] = (self.parity[i] + parent_parity) % 2\n        \n        return self.parent[i], self.parity[i]\n\n    def union(self, i, j):\n        \"\"\"\n        Merges the sets containing i and j.\n        Returns True if the merge is consistent with bipartiteness, False otherwise.\n        A return value of False indicates that adding the edge (i,j) creates an odd cycle.\n        \"\"\"\n        root_i, parity_i = self.find(i)\n        root_j, parity_j = self.find(j)\n\n        if root_i != root_j:\n            # Union by size: attach smaller tree to the root of the larger tree\n            if self.size[root_i]  self.size[root_j]:\n                root_i, root_j = root_j, root_i # Ensure root_i is the larger set's root\n\n            self.parent[root_j] = root_i\n            self.size[root_i] += self.size[root_j]\n            \n            # Update parity of the attached root (root_j).\n            # The edge (i, j) requires color(i) != color(j).\n            # path_parity(i-root_i) = parity_i, path_parity(j-root_j) = parity_j.\n            # color(i) and color(j) must differ. Relative to root_i after merge:\n            # color_rel(i) = parity_i\n            # color_rel(j) = path_parity(j-root_j-root_i) = parity_j ^ parity(root_j-root_i)\n            # So, parity_i != parity_j ^ parity(root_j-root_i)\n            # which implies parity(root_j-root_i) = parity_i ^ parity_j ^ 1.\n            self.parity[root_j] = (parity_i + parity_j + 1) % 2\n            \n            return True\n        else:\n            # i and j are already in the same component.\n            # A conflict (odd cycle) occurs if they have the same relative color.\n            # This happens if their path parities to the common root are the same.\n            if parity_i == parity_j:\n                return False # Conflict detected\n            else:\n                return True # Consistent with existing coloring\n\ndef solve_case(n, edges):\n    \"\"\"\n    Processes a single test case to find the first edge that makes the graph non-bipartite.\n    \"\"\"\n    dsu = DSU(n)\n    for i, edge in enumerate(edges):\n        u, v = edge\n        if not dsu.union(u, v):\n            return i + 1  # Return 1-based index of the violating edge\n    return 0 # No violations found\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final output.\n    \"\"\"\n    test_cases = [\n        (5, [(1, 2), (3, 4), (2, 3), (4, 5)]),\n        (4, [(1, 2), (2, 3), (3, 4), (4, 1)]),\n        (3, [(1, 2), (2, 3), (1, 3)]),\n        (3, [(1, 1)]),\n        (6, [(1, 2), (2, 3), (3, 1), (4, 5), (5, 6)]),\n        (7, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7), (1, 7)]),\n        (5, []),\n    ]\n\n    results = []\n    for n, edges in test_cases:\n        result = solve_case(n, edges)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3228343"}, {"introduction": "路径压缩是一种强大的启发式策略，但如果我们需要撤销操作该怎么办？这个高级练习通过引入回滚机制来替代路径压缩，探索了一种“持久化”或“可撤销”并查集的设计。将这种技术应用于离线动态连通性问题，不仅展示了数据结构设计中的精妙权衡，也让你接触到在算法竞赛和分析中常见的强大离线处理方法。[@problem_id:3228309]", "problem": "考虑一个表示电力传输网络的有限、无向、简单图，其中顶点代表变电站，边代表输电线路。目标是在离散时间点上分析故障事件，并通过设计一种使用栈维护操作日志、具备回滚能力的不相交集并查集（DSU），并将其与基于时间的离线分治算法相结合，来高效地回答连通性查询。该 DSU 必须采用按大小合并（union-by-size）启发式策略，并避免路径压缩（path compression），以便能够以均摊常数时间撤销操作，恢复到先前的快照。\n\n从以下基础出发：不相交集数据结构的定义，该结构维护有限元素集的一个划分，将其分为互不相交的子集，并支持查找元素代表元和合并两个代表元的操作；图论中的概念，即无向图中的连通性在顶点上导出一种等价关系，其中两个顶点若位于同一连通分量中，则它们是等价的；以及一个经过充分检验的事实，即按大小合并（或按秩合并）会降低表示集合的有根树森林的高度，确保每次合并都将较小的树附加到较大的树下。\n\n您必须基于这些基础，推导出一个设计，该设计：\n- 使用操作栈来维护一个可回滚的 DSU。每次合并操作必须将足够的信息推入栈中，以便撤销自身。不允许使用路径压缩，因为它会使精确回滚变得复杂。\n- 使用基于时间的离线线段树处理带时间索引的边活动区间：对于每个时间点，活动边的集合由初始边和一系列故障或恢复事件定义。每条边在一个或多个形如 $[L,R)$ 的时间半开区间的并集上是活动的；这些边被映射到覆盖其活动区间的线段树节点上。对线段树进行深度优先遍历时，必须在进入节点时对存储在该节点上的边执行合并操作，在叶节点处回答查询，并在离开节点时回滚所有已应用的合并操作。\n- 回答形式如下的连通性查询：在时间 $t$，给定一个源变电站 $s$ 和一个有限的关键变电站集合 $C$，判断在由时间 $t$ 的活动边构成的导出图中，集合 $C$ 中的所有顶点是否都与 $s$ 连通。\n\n所有量均为纯数学量，没有物理单位；无需报告任何物理单位。不涉及角度。不涉及百分比。\n\n为以下测试套件实现一个程序来执行此分析。顶点由从 $0$ 到 $n-1$ 的整数标记。时间点是离散的，由整数 $t \\in \\{0,1,\\dots,T-1\\}$ 索引。每个事件是故障（边停用）或恢复（边启用）。如果一条边 $(u,v)$ 在每个满足 $L \\le t  R$ 的时间 $t$ 都参与连通性计算，则认为它在半开区间 $[L,R)$ 上是活动的。\n\n测试套件：\n- 测试用例 1 (具有冗余的正常路径):\n  - 变电站数量 $n = 7$。\n  - 时间 $t = 0$ 时的初始活动边: $(0,1)$, $(1,2)$, $(2,3)$, $(3,4)$, $(4,5)$, $(5,6)$, $(0,6)$。\n  - 时间范围 $T = 6$，即 $t \\in \\{0,1,2,3,4,5\\}$。\n  - 事件:\n    - 时间 $t = 1$：边 $(0,6)$ 发生故障。\n    - 时间 $t = 2$：边 $(3,4)$ 发生故障。\n    - 时间 $t = 3$：边 $(0,6)$ 恢复。\n    - 时间 $t = 4$：边 $(2,3)$ 发生故障。\n    - 时间 $t = 5$：边 $(3,4)$ 恢复。\n  - 查询 (每个时间点 $t$ 一次)：对于每个 $t \\in \\{0,1,2,3,4,5\\}$，给定源 $s = 0$ 和关键集合 $C = \\{3,6\\}$，报告在时间 $t$ 的活动边下，$C$ 中的所有顶点是否都与 $s$ 连通。\n- 测试用例 2 (边界情况：单个顶点):\n  - 变电站数量 $n = 1$。\n  - 时间 $t=0$ 时的初始活动边：无。\n  - 时间范围 $T = 3$，即 $t \\in \\{0,1,2\\}$。\n  - 事件：无。\n  - 查询：对于每个 $t \\in \\{0,1,2\\}$，给定源 $s = 0$ 和关键集合 $C = \\{0\\}$，报告 $C$ 中的所有顶点是否都与 $s$ 连通。\n- 测试用例 3 (线性图上的桥故障):\n  - 变电站数量 $n = 5$。\n  - 时间 $t=0$ 时的初始活动边: $(0,1)$, $(1,2)$, $(2,3)$, $(3,4)$。\n  - 时间范围 $T = 5$，即 $t \\in \\{0,1,2,3,4\\}$。\n  - 事件:\n    - 时间 $t = 1$：边 $(1,2)$ 发生故障。\n    - 时间 $t = 2$：边 $(2,3)$ 发生故障。\n    - 时间 $t = 3$：边 $(1,2)$ 恢复。\n    - 时间 $t = 4$：边 $(2,3)$ 恢复。\n  - 查询：对于每个 $t \\in \\{0,1,2,3,4\\}$，给定源 $s = 0$ 和关键集合 $C = \\{4\\}$，报告 $C$ 中的所有顶点是否都与 $s$ 连通。\n- 测试用例 4 (桥的反复切换):\n  - 变电站数量 $n = 6$。\n  - 时间 $t=0$ 时的初始活动边: $(0,1)$, $(1,2)$, $(3,4)$, $(4,5)$, $(2,3)$。\n  - 时间范围 $T = 4$，即 $t \\in \\{0,1,2,3\\}$。\n  - 事件:\n    - 时间 $t = 1$：边 $(2,3)$ 发生故障。\n    - 时间 $t = 2$：边 $(2,3)$ 恢复。\n    - 时间 $t = 3$：边 $(0,1)$ 发生故障。\n  - 查询：对于每个 $t \\in \\{0,1,2,3\\}$，给定源 $s = 0$ 和关键集合 $C = \\{5\\}$，报告 $C$ 中的所有顶点是否都与 $s$ 连通。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表应按顺序包含所有查询的布尔值答案，顺序为测试用例 1 (按 $t$ 递增)，然后是测试用例 2，测试用例 3，最后是测试用例 4。例如，输出可能看起来像 $[\\text{True}, \\text{False}, \\dots]$，但在实际打印的字符串中不含空格，即严格遵循 $[\\text{True},\\text{False},\\dots]$ 的格式。", "solution": "所提出的问题是离线动态图连通性问题的一个明确实例。它要求在给定一系列边的增加和移除（故障和恢复）的情况下，在不同的离散时间点确定指定顶点集之间的连通性。术语“离线”表示整个事件和查询序列是预先已知的，这允许在时间域上采用分治方法。\n\n该解决方案依赖于三个核心组成部分：\n1.  将边的生命周期预处理成时间区间。\n2.  在时间轴上构建线段树，以根据边的活动区间来组织它们。\n3.  一个带有回滚机制的不相交集并查集（DSU）数据结构，这对于在线段树遍历期间高效管理连通性变化至关重要。\n\n我们将从基本原则出发推导此设计。\n\n**1. 形式化边的生命周期和离线时序框架**\n\n图的状态仅在事件发生的离散时间点 $t$ 改变。一条边 $(u,v)$ 在一组半开区间 $[L, R) = \\{ t \\in \\mathbb{Z} \\mid L \\le t  R \\}$ 上是活动的。我们的首要任务是将初始边集和带时间戳的事件序列转换为每条边的这些生命周期区间。\n\n设总时间范围为 $T$，时间由 $t \\in \\{0, 1, \\dots, T-1\\}$ 索引。\n- 对于在 $t=0$ 初始配置中存在的每条边 $(u,v)$，其活动时间从 $L=0$ 开始。\n- 在时间 $t_{\\text{event}}$ 发生一个关于边 $(u,v)$ 的事件，标志着其前一个状态的结束和新状态的开始。\n  - 如果在 $t_{\\text{fault}}$ 时，一条先前活动的边发生故障，其当前的活动区间在 $t_{\\text{fault}}$ 结束。该区间为 $[L, t_{\\text{fault}})$。\n  - 如果在 $t_{\\text{restore}}$ 时，一条先前非活动的边被恢复，则一个新的活动区间从 $L = t_{\\text{restore}}$ 开始。\n- 在最后一个事件发生时间 $t_{\\text{last\\_event}}$ 之后仍然活动的任何边，将一直活动到时间范围结束，因此其最终活动区间为 $[L, T)$。\n\n通过按时间顺序处理每条边的所有事件，我们可以确定图中每条边的完整的不相交活动区间列表。\n\n**2. 用于基于时间的分治的线段树**\n\n一旦我们获得了所有边的生命周期区间，就需要一个结构来管理哪些边在哪些时段内是活动的。一个构建在时间域 $[0, T)$ 上的线段树非常适合此目的。\n\n- 线段树的叶节点对应于基本时间区间 $[t, t+1)$，其中 $t \\in \\{0, 1, \\dots, T-1\\}$。\n- 每个内部节点对应其子节点区间的并集。根节点代表整个时间范围 $[0, T)$。\n- 每条边的活动区间 $[L, R)$ 被映射到线段树中的一组规范节点上。如果一个节点的区间完全包含在 $[L, R)$ 内，但其父节点的区间没有，则边 $(u,v)$ 就存储在该节点上。这确保每个边的区间 $[L, R)$ 最多存储在 $O(\\log T)$ 个节点上。\n\n这种结构使我们能够推断出在给定节点的整个时间区间内所有“永久”活动的边。\n\n**3. 带有回滚功能的可持久化不相交集并查集 (DSU)**\n\n为了跟踪连通性，我们使用 DSU 数据结构。顶点集被划分为不相交的集合，每个集合代表一个连通分量。问题指定了使用按大小合并启发式策略但明确禁止路径压缩的 DSU 实现。这个选择对于实现高效的回滚机制至关重要。\n\n- **数据表示**：DSU 使用两个数组来维护：$\\text{parent}[\\cdot]$ 和 $\\text{size}[\\cdot]$。\n  - $\\text{parent}[i]$ 存储元素 $i$ 的父节点。对于一个分量的根 $r$，$\\text{parent}[r] = r$。\n  - $\\text{size}[i]$ 存储分量中的元素数量，但仅当 $i$ 是根节点时才有意义。\n\n- **`find(i)` 操作**：在没有路径压缩的情况下，此操作从 $i$ 开始遍历父指针，直到到达一个根 $r$（其中 $\\text{parent}[r] = r$）。由于采用了按大小合并启发式策略，树的高度被限制在 $O(\\log n)$，因此每次 `find` 操作耗时 $O(\\log n)$。\n\n- **`union(u, v)` 操作**：为了合并包含顶点 $u$ 和 $v$ 的分量，我们首先找到它们各自的根 $r_u = \\text{find}(u)$ 和 $r_v = \\text{find}(v)$。如果 $r_u \\neq r_v$：\n  1.  我们遵循按大小合并的启发式策略：将较小树的根附加到较大树的根上。假设 $\\text{size}[r_u] \\ge \\text{size}[r_v]$。\n  2.  **记录更改**：在修改 DSU 状态之前，我们记录将被覆盖的当前状态。我们将 $r_v$ 的旧父节点和 $r_u$ 的旧大小推入一个全局历史栈中。例如，我们记录 $(\\text{'parent'}, r_v, \\text{parent}[r_v])$ 和 $(\\text{'size'}, r_u, \\text{size}[r_u])$。\n  3.  **应用更改**：我们更新 parent 和 size 数组：$\\text{parent}[r_v] \\leftarrow r_u$ 和 $\\text{size}[r_u] \\leftarrow \\text{size}[r_u] + \\text{size}[r_v]$。\n\n- **回滚机制**：历史栈使 DSU 在时间顺序上具有“可持久化”的特性。要将 DSU 恢复到先前的状态，我们只需从栈中弹出记录的更改并反向应用它们。例如，弹出 $(\\text{'parent'}, r_v, \\text{old\\_parent})$ 意味着我们恢复 $\\text{parent}[r_v] \\leftarrow \\text{old\\_parent}$。这里，不使用路径压缩至关重要，因为路径压缩可能修改任意数量的父指针，使得简单的基于栈的回滚变得难以处理。\n\n**4. 完整算法：线段树的深度优先搜索（DFS）遍历**\n\n最终算法在线段树的深度优先搜索（DFS）遍历中结合了这些组件。\n\n设 $\\text{DFS-Solve}(\\text{node}, [L, R))$ 是处理对应于时间区间 $[L, R)$ 的线段树节点的递归函数。\n\n1.  **应用局部合并**：进入给定 `node` 的函数时，我们遍历存储在此 `node` 上的所有边 $(u,v)$。对每条边，我们执行一个 $\\text{union}(u, v)$ 操作。DSU 会在历史栈上记录这些更改。我们记下执行这些操作前历史栈的大小。\n\n2.  **处理子节点或查询**：\n    - 如果 `node` 是一个内部节点，我们对其子节点递归调用该函数：$\\text{DFS-Solve}(\\text{left\\_child}, [L, M))$ 和 $\\text{DFS-Solve}(\\text{right\\_child}, [M, R))$，其中 $M = (L+R)/2$。\n    - 如果 `node` 是一个叶节点，它代表一个单一的时间点 $t=L$。此时，DSU 正确地表示了图在时间 $t$ 的连通性。我们回答所有安排在此时间的查询。一个询问集合 $C$ 中的所有顶点是否都与源点 $s$ 连通的查询，可以通过验证对所有 $c \\in C$ 是否都有 $\\text{find}(s) = \\text{find}(c)$ 来回答。\n\n3.  **回滚合并操作**：在递归调用返回后（或在叶节点回答查询后），我们必须撤销在步骤 1 中所做的更改，以将 DSU 恢复到进入此 `node` 之前的状态。我们通过将历史栈回滚到应用局部合并操作前记录的大小来实现这一点。\n\n该过程以调用 $\\text{DFS-Solve}(\\text{root}, [0, T))$ 开始。这种分治方法确保对于任何时间点 $t$，DSU 的状态都精确反映了所有活动区间包含 $t$ 的边的合并结果。构建边的时间线的复杂度与事件数量成正比。填充线段树需要 $O(E_{\\text{intervals}} \\log T)$ 的时间，其中 $E_{\\text{intervals}}$ 是所有边上不相交活动区间的总数。DFS 遍历涉及 DSU 操作；总成本大约为 $O((E_{\\text{intervals}} + Q) \\log T \\log n)$，其中 $Q$ 是查询总数。\n\n此设计为指定的离线动态连通性问题提供了一个完整、正确且高效的解决方案。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass RollbackDSU:\n    \"\"\"A Disjoint-Set Union data structure with rollback capability.\"\"\"\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.size = [1] * n\n\n    def find(self, i):\n        \"\"\"Finds the representative of the set containing element i.\"\"\"\n        while self.parent[i] != i:\n            i = self.parent[i]\n        return i\n\n    def union(self, i, j, history):\n        \"\"\"\n        Unites the sets containing i and j, using union-by-size.\n        Logs changes to the history stack for rollback.\n        \"\"\"\n        root_i = self.find(i)\n        root_j = self.find(j)\n        if root_i != root_j:\n            # Union by size\n            if self.size[root_i]  self.size[root_j]:\n                root_i, root_j = root_j, root_i\n            \n            # Log changes before applying them\n            history.append(('parent', root_j, self.parent[root_j]))\n            history.append(('size', root_i, self.size[root_i]))\n            \n            # Apply changes\n            self.parent[root_j] = root_i\n            self.size[root_i] += self.size[root_j]\n            return True\n        return False\n\n    def rollback(self, history, checkpoint):\n        \"\"\"Rolls back changes from the history stack to a given checkpoint.\"\"\"\n        while len(history) > checkpoint:\n            op_type, index, value = history.pop()\n            if op_type == 'parent':\n                self.parent[index] = value\n            elif op_type == 'size':\n                self.size[index] = value\n\ndef solve():\n    \"\"\"Main solver function to process all test cases.\"\"\"\n    \n    test_cases = [\n        {\n            \"n\": 7, \"T\": 6,\n            \"initial_edges\": [(0,1), (1,2), (2,3), (3,4), (4,5), (5,6), (0,6)],\n            \"events\": [\n                (1, \"fault\", (0,6)), (2, \"fault\", (3,4)), (3, \"restoration\", (0,6)),\n                (4, \"fault\", (2,3)), (5, \"restoration\", (3,4))\n            ],\n            \"queries\": [{\"t\": t, \"s\": 0, \"C\": {3,6}} for t in range(6)]\n        },\n        {\n            \"n\": 1, \"T\": 3,\n            \"initial_edges\": [],\n            \"events\": [],\n            \"queries\": [{\"t\": t, \"s\": 0, \"C\": {0}} for t in range(3)]\n        },\n        {\n            \"n\": 5, \"T\": 5,\n            \"initial_edges\": [(0,1), (1,2), (2,3), (3,4)],\n            \"events\": [\n                (1, \"fault\", (1,2)), (2, \"fault\", (2,3)),\n                (3, \"restoration\", (1,2)), (4, \"restoration\", (2,3))\n            ],\n            \"queries\": [{\"t\": t, \"s\": 0, \"C\": {4}} for t in range(5)]\n        },\n        {\n            \"n\": 6, \"T\": 4,\n            \"initial_edges\": [(0,1), (1,2), (3,4), (4,5), (2,3)],\n            \"events\": [\n                (1, \"fault\", (2,3)), (2, \"restoration\", (2,3)), (3, \"fault\", (0,1))\n            ],\n            \"queries\": [{\"t\": t, \"s\": 0, \"C\": {5}} for t in range(4)]\n        }\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        n, T = case[\"n\"], case[\"T\"]\n        initial_edges = case[\"initial_edges\"]\n        events = case[\"events\"]\n        queries_list = case[\"queries\"]\n\n        # Canonical edge representation\n        def canonical(u, v):\n            return tuple(sorted((u, v)))\n\n        # 1. Calculate edge lifetimes\n        edge_lifetimes = {}\n        edge_status = {}  # (is_active, last_change_time)\n        \n        all_graph_edges = set(canonical(u, v) for u, v in initial_edges)\n        for _, _, edge in events:\n            all_graph_edges.add(canonical(edge[0], edge[1]))\n\n        for edge in all_graph_edges:\n            is_initially_active = edge in [canonical(u,v) for u,v in initial_edges]\n            edge_status[edge] = (is_initially_active, 0)\n        \n        sorted_events = sorted(events, key=lambda x: x[0])\n        \n        event_times = sorted(list({e[0] for e in events}))\n        \n        # Process events to create intervals\n        last_processed_t = 0\n        for t_event in event_times:\n            # For all edges, if active, close interval at t_event\n            for edge, (is_active, last_change) in edge_status.items():\n                if is_active and last_change  t_event:\n                    if edge not in edge_lifetimes: edge_lifetimes[edge] = []\n                    edge_lifetimes[edge].append((last_change, t_event))\n            \n            # Apply events at t_event and update status\n            events_at_t = [e for e in sorted_events if e[0] == t_event]\n            for _, event_type, edge_tuple in events_at_t:\n                edge = canonical(edge_tuple[0], edge_tuple[1])\n                is_active, _ = edge_status[edge]\n                new_active = (event_type == 'restoration')\n                edge_status[edge] = (new_active, t_event)\n            \n            last_processed_t = t_event\n\n        # Final intervals for edges still active after last event\n        for edge, (is_active, last_change) in edge_status.items():\n            if is_active and last_change  T:\n                if edge not in edge_lifetimes: edge_lifetimes[edge] = []\n                edge_lifetimes[edge].append((last_change, T))\n\n        # 2. Build segment tree\n        seg_tree = [[] for _ in range(4 * T)] if T > 0 else []\n        queries_at_time = [[] for _ in range(T)]\n        for q in queries_list:\n            queries_at_time[q[\"t\"]].append(q)\n\n        def add_to_segtree(edge, start, end, l=0, r=T, node=0):\n            if start = l and r = end:\n                seg_tree[node].append(edge)\n                return\n            if r = start or end = l:\n                return\n            \n            mid = (l + r) // 2\n            add_to_segtree(edge, start, end, l, mid, 2 * node + 1)\n            add_to_segtree(edge, start, end, mid, r, 2 * node + 2)\n\n        for edge, intervals in edge_lifetimes.items():\n            for start, end in intervals:\n                if start  end:\n                    add_to_segtree(edge, start, end)\n\n        # 3. DFS traversal\n        dsu = RollbackDSU(n)\n        history = []\n        case_results = [None] * T\n\n        def dfs_solve(l=0, r=T, node=0):\n            checkpoint = len(history)\n\n            # Apply unions for edges in this segment\n            for u, v in seg_tree[node]:\n                dsu.union(u, v, history)\n\n            if l + 1 == r: # Leaf node (time t=l)\n                t = l\n                for q in queries_at_time[t]:\n                    s, C = q[\"s\"], q[\"C\"]\n                    is_connected = True\n                    if n > 0:\n                        root_s = dsu.find(s)\n                        for c in C:\n                            if dsu.find(c) != root_s:\n                                is_connected = False\n                                break\n                    else: # No vertices\n                        is_connected = not C\n                        \n                    case_results[t] = is_connected\n            else: # Internal node\n                mid = (l + r) // 2\n                dfs_solve(l, mid, 2 * node + 1)\n                dfs_solve(mid, r, 2 * node + 2)\n\n            # Rollback changes\n            dsu.rollback(history, checkpoint)\n\n        if T > 0:\n            dfs_solve()\n        \n        all_results.extend(case_results)\n\n    # Final print statement\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "3228309"}]}