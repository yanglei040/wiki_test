{"hands_on_practices": [{"introduction": "图论的一个核心任务是根据图的内在属性对其进行分类。一个经典的分类依据是图中是否存在特殊的路径或回路，例如欧拉回路。本练习旨在通过将一个著名的定理（欧拉回路存在性定理）应用于一类基本图（完全二部图），来巩固您的基础知识。通过解决这个问题，您将亲身体会到图的结构参数（例如完全二部图 $K_{n,m}$ 中两个集合的大小 $n$ 和 $m$）如何直接决定其全局性质，比如是否存在一条遍历每条边一次且仅一次的闭合路径 [@problem_id:3237299]。", "problem": "您正在处理有限、简单、无向图。设 $K_{n,m}$ 表示完全二分图，其二分部的大小分别为 $n$ 和 $m$，其中 $n,m \\in \\mathbb{Z}_{\\ge 1}$。仅使用关于二分图、顶点度数、图的连通性以及有限无向图中欧拉回路存在性的特征的标准定义，确定哪个陈述精确地刻画了所有使 $K_{n,m}$ 具有欧拉回路的 $(n,m)$。\n\n选择唯一的最佳选项。\n\nA. $K_{n,m}$ 具有欧拉回路当且仅当 $n$ 和 $m$ 都是偶数（其中 $n,m \\ge 1$）。\n\nB. $K_{n,m}$ 具有欧拉回路当且仅当 $n$ 和 $m$ 都是奇数且 $n=m$。\n\nC. $K_{n,m}$ 具有欧拉回路当且仅当 $n$ 和 $m$ 中一奇一偶。\n\nD. $K_{n,m}$ 具有欧拉回路当且仅当 $n+m$ 是偶数（其中 $n,m \\ge 1$）。\n\nE. $K_{n,m}$ 具有欧拉回路当且仅当 $n=m$ 且 $n \\ge 2$。", "solution": "问题陈述是确定整数 $n$ 和 $m$ 需满足何种精确条件，才能使完全二分图 $K_{n,m}$ 具有欧拉回路。\n\n### 第一步：提取已知条件\n- 所考虑的图是有限、简单、无向的。\n- $K_{n,m}$ 表示完全二分图，其二分部的大小分别为 $n$ 和 $m$。\n- 划分集的大小为 $n,m \\in \\mathbb{Z}_{\\ge 1}$，这意味着 $n \\ge 1$ 且 $m \\ge 1$。\n- 任务是找到 $K_{n,m}$ 中存在欧拉回路的特征。\n- 推导必须基于二分图、顶点度数、图的连通性以及欧拉回路的特征的标准定义。\n\n### 第二步：使用提取的已知条件进行验证\n该问题陈述是图论入门中的一个标准练习。\n- **科学依据：** 完全二分图 ($K_{n,m}$) 和欧拉回路的概念是图论这一数学领域中的基本概念，并有严格定义。该问题基于已建立的数学原理。\n- **适定性：** 问题要求一个精确的特征，即一个充分必要条件。所有术语都是标准的且定义清晰，约束条件 ($n, m \\ge 1$) 也是明确的。存在一个唯一的、有意义的解，并且可以从给定的原理中推导出来。\n- **客观性：** 语言是形式化的、数学化的，没有歧义或主观论断。\n\n该问题陈述是有效的，因为它是自洽的、一致的，并且基于已建立的数学理论。\n\n### 第三步：求解推导\n\n根据图论中的一个基本定理，一个有限无向图 $G$ 具有欧拉回路当且仅当它满足两个条件：\n1.  $G$ 是连通的（可能除了孤立顶点，不过一个有遍历所有边的回路的图不可能有与主分量不连通的孤立顶点）。\n2.  $G$ 中的每个顶点都有偶数度。\n\n我们现在将这两个条件应用于完全二分图 $K_{n,m}$。\n\n**1. $K_{n,m}$ 的连通性**\n\n设 $K_{n,m}$ 的顶点集为 $V = U \\cup W$，其中 $U$ 和 $W$ 是不相交的划分集，且 $|U| = n$ 和 $|W| = m$。题目规定 $n \\ge 1$ 且 $m \\ge 1$。\n\n-   设 $v_1, v_2$ 是 $V$ 中的任意两个顶点。\n    -   如果 $v_1 \\in U$ 且 $v_2 \\in W$，那么根据完全二分图的定义，边 $\\{v_1, v_2\\}$ 存在。因此，它们通过一条长度为 $1$ 的路径相连。\n    -   如果 $v_1, v_2$ 都在 $U$ 中（这要求 $n \\ge 2$），由于 $m \\ge 1$，存在至少一个顶点 $w \\in W$。路径 $v_1 - w - v_2$ 连接了 $v_1$ 和 $v_2$。\n    -   如果 $v_1, v_2$ 都在 $W$ 中（这要求 $m \\ge 2$），由于 $n \\ge 1$，存在至少一个顶点 $u \\in U$。路径 $v_1 - u - v_2$ 连接了 $v_1$ 和 $v_2$。\n\n由于任意一对顶点都由一条路径连接，所以对于所有 $n, m \\ge 1$，$K_{n,m}$ 图都是连通的。因此，欧拉回路的第一个条件总是满足的。\n\n**2. $K_{n,m}$ 中的顶点度数**\n\n现在我们来考察顶点的度数。\n-   考虑 $U$ 中的任意顶点 $u$。根据 $K_{n,m}$ 的定义，该顶点与 $W$ 中的每个顶点相连，而与 $U$ 中的任何顶点都不相连。由于 $|W| = m$，所以 $U$ 中任意顶点 $u$ 的度为 $\\text{deg}(u) = m$。\n-   类似地，考虑 $W$ 中的任意顶点 $w$。该顶点与 $U$ 中的每个顶点相连，而与 $W$ 中的任何顶点都不相连。由于 $|U| = n$，所以 $W$ 中任意顶点 $w$ 的度为 $\\text{deg}(w) = n$。\n\n要使 $K_{n,m}$ 具有欧拉回路，每个顶点的度数都必须是偶数。这意味着：\n-   $U$ 中所有顶点的度数必须是偶数。因此，$m$ 必须是偶数。\n-   $W$ 中所有顶点的度数必须是偶数。因此，$n$ 必须是偶数。\n\n综合以上两点，一个完全二分图 $K_{n,m}$（其中 $n, m \\ge 1$）具有欧拉回路，当且仅当 $n$ 和 $m$ 都是偶数。\n\n### 选项评估\n\n现在，我们根据我们推导出的条件来评估每个选项。\n\n**A. $K_{n,m}$ 具有欧拉回路当且仅当 $n$ 和 $m$ 都是偶数（其中 $n,m \\ge 1$）。**\n这个陈述与我们推导出的充分必要条件完全匹配。括号中的备注“其中 $n,m \\ge 1$”与问题的设定一致。\n**结论：正确。**\n\n**B. $K_{n,m}$ 具有欧拉回路当且仅当 $n$ 和 $m$ 都是奇数且 $n=m$。**\n如果 $n$ 和 $m$ 都是奇数，那么大小为 $n$ 的划分集中的每个顶点的度都是 $m$（奇数），大小为 $m$ 的划分集中的每个顶点的度都是 $n$（奇数）。由于所有顶点都具有奇数度，这违反了所有顶点度数必须为偶数的条件。因此，不存在欧拉回路。\n**结论：错误。**\n\n**C. $K_{n,m}$ 具有欧拉回路当且仅当 $n$ 和 $m$ 中一奇一偶。**\n不失一般性，假设 $n$ 是偶数，$m$ 是奇数。大小为 $n$ 的划分集中的 $n$ 个顶点，每个的度都是 $m$（奇数）。大小为 $m$ 的划分集中的 $m$ 个顶点，每个的度都是 $n$（偶数）。因为存在奇数度的顶点（具体来说，是一个划分集中的所有 $n$ 个顶点），所以该图没有欧拉回路。（当且仅当恰好有两个奇数度顶点时，它会有一条欧拉路径，这将要求 $n=2$。）\n**结论：错误。**\n\n**D. $K_{n,m}$ 具有欧拉回路当且仅当 $n+m$ 是偶数（其中 $n,m \\ge 1$）。**\n和 $n+m$ 是偶数当且仅当 $n$ 和 $m$ 的奇偶性相同。这意味着它们要么都是偶数，要么都是奇数。\n-   如果 $n$ 和 $m$ 都是偶数，则存在欧拉回路。\n-   如果 $n$ 和 $m$ 都是奇数，如选项 B 的分析所示，不存在欧拉回路。\n由于这个条件包含了一个不存在欧拉回路的情况，所以它不是一个充分条件。因此，它不是一个精确的特征描述。\n**结论：错误。**\n\n**E. $K_{n,m}$ 具有欧拉回路当且仅当 $n=m$ 且 $n \\ge 2$。**\n这个条件既不充分也不必要。\n-   不充分：考虑 $n=m=3$。这里 $n$ 和 $m$ 都是奇数，所以所有顶点的度都是 $3$。不存在欧拉回路。这是一个反例。\n-   不必要：考虑 $K_{2,4}$。这里 $n=2$ 且 $m=4$。两者都是偶数，所以存在欧拉回路。然而，$n \\ne m$。这是一个反例。\n**结论：错误。**\n\n根据分析，只有选项 A 提供了正确的特征描述。", "answer": "$$\\boxed{A}$$", "id": "3237299"}, {"introduction": "在对图的属性进行分类之后，一个自然而然的问题是：这些属性对图的结构施加了多大的限制？例如，一个图在避免包含特定子结构（如三角形）的前提下，最多可以有多稠密？这个问题将引导您进入极值图论的引人入胜的领域。您需要从第一性原理出发，推导出不含三角形的图所能拥有的最大边数，这将揭示局部结构约束（没有长度为3的圈）与全局属性（边的总数）之间的深刻联系 [@problem_id:3237303]。", "problem": "在有限、简单、无向图的研究中，围长是图中最短圈的长度；一个图的围长至少为$4$当且仅当它不包含长度为$3$的圈，等价地说，它是无三角形的。设$G$为任意一个有$n$个顶点的无三角形图。仅使用邻接、度、三角形等核心定义，通过一个完整的推导来确定边的最大可能数量作为$n$的函数，该推导需要识别出一个极值结构并证明其最优性，且无需借助任何已有的极值图论定理。你的最终答案必须是关于$n$的单一闭式表达式。无需四舍五入，也不涉及单位。", "solution": "问题要求在一个有$n$个顶点的有限、简单、无向、无三角形图$G$中，边的最大可能数量。如果一个图不包含长度为$3$的圈（记为$K_3$），则称其为无三角形图。设$G=(V, E)$是这样一个图，其中$|V|=n$，$|E|=m$。我们将通过推导一个紧上界来确定$m$的最大值。\n\n首先，我们为$m$建立一个上界。设$\\{u, v\\}$是$E$中的一条任意边。设$N(x)$表示顶点$x$的开邻域，即与$x$相邻的所有顶点的集合。$x$的度为$\\deg(x) = |N(x)|$。\n\n由于图$G$是无三角形的，所以不可能存在一个顶点$w$同时与$u$和$v$相邻。如果存在这样的$w$，顶点$\\{u, v, w\\}$就会形成一个三角形。这直接意味着$u$的邻居集合和$v$的邻居集合是不相交的。一个更精确的表述是，$u$的邻居集合（不包括$v$）和$v$的邻居集合（不包括$u$）是不相交的。\n\n让我们将其形式化。考虑集合$N(u) \\setminus \\{v\\}$和$N(v) \\setminus \\{u\\}$。$G$的无三角形性质意味着$(N(u) \\setminus \\{v\\}) \\cap (N(v) \\setminus \\{u\\}) = \\emptyset$。\n\n现在，考虑顶点集$S = \\{u\\} \\cup \\{v\\} \\cup (N(u) \\setminus \\{v\\}) \\cup (N(v) \\setminus \\{u\\})$。\n顶点$u$和$v$是不同的。$N(u) \\setminus \\{v\\}$中的顶点不是$u$或$v$。$N(v) \\setminus \\{u\\}$中的顶点不是$u$或$v$。如前所述，集合$N(u) \\setminus \\{v\\}$和$N(v) \\setminus \\{u\\}$是不相交的。因此，$S$定义中的四个组成集合是两两不交的。\n$S$中不同顶点的总数是这些集合大小的总和：\n$$|S| = |\\{u\\}| + |\\{v\\}| + |N(u) \\setminus \\{v\\}| + |N(v) \\setminus \\{u\\}|$$\n其基数分别为$|N(u) \\setminus \\{v\\}| = \\deg(u) - 1$和$|N(v) \\setminus \\{u\\}| = \\deg(v) - 1$。\n$$|S| = 1 + 1 + (\\deg(u) - 1) + (\\deg(v) - 1) = \\deg(u) + \\deg(v)$$\n由于$S$是$G$的一个顶点集，其大小不能超过总顶点数$n$。\n$$\\deg(u) + \\deg(v) \\le n$$\n这个不等式对于无三角形图$G$中任意一对相邻顶点$\\{u, v\\}$都成立。\n\n现在我们可以对图中所有的边将此不等式求和：\n$$\\sum_{\\{u,v\\} \\in E} (\\deg(u) + \\deg(v)) \\le \\sum_{\\{u,v\\} \\in E} n = m \\cdot n$$\n左边的项$\\sum_{\\{u,v\\} \\in E} (\\deg(u) + \\deg(v))$可以通过考虑每个顶点的贡献来重写。一个顶点$w \\in V$是$\\deg(w)$条边的端点。对于每一条这样的边，它的度$\\deg(w)$被包含在和中。因此，项$\\deg(w)$在总和中出现了$\\deg(w)$次。这意味着：\n$$\\sum_{\\{u,v\\} \\in E} (\\deg(u) + \\deg(v)) = \\sum_{w \\in V} \\deg(w)^2$$\n结合这些结果，我们得到不等式：\n$$\\sum_{w \\in V} \\deg(w)^2 \\le mn$$\n现在，我们使用柯西-施瓦茨不等式将其与总边数$m$联系起来。设$\\mathbf{d} = (\\deg(v_1), \\deg(v_2), \\dots, \\deg(v_n))$和$\\mathbf{1} = (1, 1, \\dots, 1)$是$\\mathbb{R}^n$中的两个向量。柯西-施瓦茨不等式表述为$(\\mathbf{d} \\cdot \\mathbf{1})^2 \\le (\\mathbf{d} \\cdot \\mathbf{d}) (\\mathbf{1} \\cdot \\mathbf{1})$。\n$$ \\left(\\sum_{w \\in V} \\deg(w)\\right)^2 \\le \\left(\\sum_{w \\in V} \\deg(w)^2\\right) \\left(\\sum_{w \\in V} 1^2\\right) $$\n根据握手引理，度数之和是边数的两倍：$\\sum_{w \\in V} \\deg(w) = 2m$。1的平方和就是$n$。代入这些可得：\n$$(2m)^2 \\le \\left(\\sum_{w \\in V} \\deg(w)^2\\right) \\cdot n$$\n$$4m^2 \\le n \\sum_{w \\in V} \\deg(w)^2$$\n我们现在有两个不等式：\n1. $\\sum_{w \\in V} \\deg(w)^2 \\le mn$\n2. $4m^2 \\le n \\sum_{w \\in V} \\deg(w)^2$\n\n将第一个不等式代入第二个可得：\n$$4m^2 \\le n(mn) = mn^2$$\n如果$m > 0$，我们可以两边同除以$m$得到$4m \\le n^2$，这意味着$m \\le \\frac{n^2}{4}$。如果$m = 0$，不等式不言自明地成立。由于$m$必须是整数，我们有$m \\le \\lfloor \\frac{n^2}{4} \\rfloor$。这就为任意一个有$n$个顶点的无三角形图的边数建立了一个上界。\n\n为了证明这个界是可能达到的最好结果，我们必须证明存在一个有$n$个顶点且恰好有$\\lfloor \\frac{n^2}{4} \\rfloor$条边的无三角形图。这个极值结构是完全二分图$K_{\\lfloor n/2 \\rfloor, \\lceil n/2 \\rceil}$。\n\n我们来构造这个图。将$n$个顶点的集合$V$划分为两个不相交的子集$A$和$B$，使得$|A| = \\lfloor \\frac{n}{2} \\rfloor$且$|B| = \\lceil \\frac{n}{2} \\rceil$。定义边集$E$包含所有连接$A$中顶点和$B$中顶点的边。同一划分内部的顶点之间没有边。\n\n根据构造，这个图是二分的。二分图中的圈必须在两个顶点划分之间交替。一个圈要从同一个顶点出发并返回，必须经过偶数条边。因此，二分图中的所有圈都具有偶数长度。所以，该图不包含奇数长度的圈，特别是长度为$3$的圈（三角形）。因此，$K_{\\lfloor n/2 \\rfloor, \\lceil n/2 \\rceil}$是无三角形的。\n\n这个图中的边数是两个划分大小的乘积：\n$$m = |A| \\cdot |B| = \\left\\lfloor \\frac{n}{2} \\right\\rfloor \\left\\lceil \\frac{n}{2} \\right\\rceil$$\n我们根据$n$的奇偶性分两种情况来分析。\n\n情况1：$n$为偶数。设$n = 2k$，其中$k$为某个整数。\n则$|A| = \\lfloor \\frac{2k}{2} \\rfloor = k$，$|B| = \\lceil \\frac{2k}{2} \\rceil = k$。\n边数为$m = k \\cdot k = k^2 = \\left(\\frac{n}{2}\\right)^2 = \\frac{n^2}{4}$。\n由于$\\frac{n^2}{4}$是一个整数，这个值等于$\\lfloor \\frac{n^2}{4} \\rfloor$。\n\n情况2：$n$为奇数。设$n = 2k+1$，其中$k$为某个整数。\n则$|A| = \\lfloor \\frac{2k+1}{2} \\rfloor = k$，$|B| = \\lceil \\frac{2k+1}{2} \\rceil = k+1$。\n边数为$m = k(k+1)$。\n代入$k = \\frac{n-1}{2}$，我们得到$m = \\left(\\frac{n-1}{2}\\right)\\left(\\frac{n-1}{2}+1\\right) = \\left(\\frac{n-1}{2}\\right)\\left(\\frac{n+1}{2}\\right) = \\frac{n^2-1}{4}$。\n这恰好是当$n$为奇数时$\\lfloor \\frac{n^2}{4} \\rfloor$的值。\n\n在这两种情况下，我们都构造了一个有$n$个顶点且恰好有$\\lfloor \\frac{n^2}{4} \\rfloor$条边的无三角形图。既然我们已经证明了任何这样的图的边数都不能超过这个数，并且我们找到了一个恰好有这个边数的图，那么可以得出结论，最大可能边数是$\\lfloor \\frac{n^2}{4} \\rfloor$。", "answer": "$$\\boxed{\\left\\lfloor \\frac{n^2}{4} \\right\\rfloor}$$", "id": "3237303"}, {"introduction": "理论知识的最终目的是应用于实践。前面的练习侧重于静态图的分析，而本练习将我们带入动态图的场景中，即图的结构会随时间演变。这个挑战要求您设计一个数据结构，以高效地处理一个在网络管理、数据聚类和许多其他领域都至关重要的问题：在图中动态添加边时，如何快速判断新加入的边是否会形成一个环？通过这个编程实践，您将学会如何将图的抽象概念（特别是连通分量）转化为一种高效的算法——并查集（Union-Find），这是算法问题解决中的一个基石 [@problem_id:3237184]。", "problem": "给定一个无向图 $G = (V, E)$，其顶点集合 $V$ 是一个有限集，标记为整数范围 $\\{0, 1, \\dots, n-1\\}$，以及一个初始指定的边集合 $E$（可能为空）。该图通过提议增加形如 $(u, v)$ 的边来演化，其中 $u, v \\in V$。您的任务是设计并实现一个完整的程序，该程序维护一个基于图属性的数据结构，以便在每次提议增加边时，都能高效地报告增加边 $(u, v)$ 是否会在当前无向图中形成一个环。\n\n您必须依赖的基础是以下定义和事实的集合：\n- 在无向图中，一条简单路径是一个由不同顶点组成的序列 $(x_0, x_1, \\dots, x_k)$，对于每个索引 $i$（$0 \\le i  k$），顶点对 $(x_i, x_{i+1})$ 都是图中的一条边。\n- 在无向图中，一个环是一条路径 $(x_0, x_1, \\dots, x_{k-1}, x_0)$，其中 $k \\ge 3$，且其顶点 $x_0, x_1, \\dots, x_{k-1}$ 互不相同，但首尾顶点重合；按照惯例，增加一个自环 $(u, u)$ 会立即被视为形成一个环。\n- 一个连通分量是一个极大的顶点集合，其中集合内的任意一对顶点都通过某条路径相连。\n- 树是一个连通的无向无环图，而森林是树的不相交并集。\n\n您的程序必须实现一个数据结构，该结构能对每条提议的边 $(u, v)$ 判断增加它是否会形成一个环。该判断必须严格基于图的连通性理论属性，并随着接受的边被加入图中而演化。程序必须假定每条提议的边都是无向的。如果增加 $(u, v)$ 会形成环，程序必须为该提议输出布尔值 $\\texttt{True}$；否则，程序必须输出 $\\texttt{False}$，并将 $(u, v)$ 合并到数据结构中以供后续使用。自环 $(u, u)$ 总是产生 $\\texttt{True}$。\n\n您的程序必须使用以下测试套件，其中每个测试用例由 $(n, E_{\\text{init}}, E_{\\text{add}})$ 组成：\n- 测试用例 A (一般情况):\n  - $n = 5$\n  - $E_{\\text{init}} = \\emptyset$\n  - $E_{\\text{add}} = [(0, 1), (1, 2), (2, 3), (3, 4), (4, 0)]$\n- 测试用例 B (合并连通分量后闭合成环):\n  - $n = 4$\n  - $E_{\\text{init}} = [(0, 1), (2, 3)]$\n  - $E_{\\text{add}} = [(1, 2), (0, 2), (1, 3)]$\n- 测试用例 C (自环和重复连接):\n  - $n = 3$\n  - $E_{\\text{init}} = \\emptyset$\n  - $E_{\\text{add}} = [(0, 0), (1, 2), (2, 1)]$\n- 测试用例 D (单个顶点的边界情况):\n  - $n = 1$\n  - $E_{\\text{init}} = \\emptyset$\n  - $E_{\\text{add}} = [(0, 0), (0, 0)]$\n\n对于每个测试用例，您的程序必须按照 $E_{\\text{add}}$ 的顺序输出一个布尔值列表，其中每个布尔值指示相应的提议边在提议时是否会形成环。您的程序应生成单行输出，其中包含所有测试用例的结果。这些结果被汇总到一个由方括号括起的逗号分隔列表中，每个测试用例的列表也由其自己的方括号括起，且不含空格。例如，两个测试用例的结果 $\\texttt{[True,False]}$ 和 $\\texttt{[False]}$ 的汇总必须精确地打印为 $\\texttt{[[True,False],[False]]}$。\n\n所有答案都是纯布尔值，不涉及物理单位。本问题不出现角度和百分比。该程序必须是一个完整、可运行的程序，并且不得从标准输入或文件中读取输入；它必须能直接运行并打印指定的单行输出。", "solution": "解决此问题的核心思想是利用图的连通性属性。当向图中添加一条新边 $(u, v)$ 时，会形成一个环，当且仅当在添加这条边之前，顶点 $u$ 和 $v$ 已经属于同一个连通分量。如果它们已经在同一个连通分量中，那么在它们之间已经存在一条路径；新边 $(u, v)$ 会与这条现有路径一起构成一个环。如果它们属于不同的连通分量，新边只会将这两个分量合并成一个，而不会形成环。\n\n并查集（Disjoint Set Union, DSU）数据结构是动态跟踪和维护一组不相交集合（在这里即连通分量）的理想工具。\n\n算法步骤如下：\n1.  **初始化**：为 $n$ 个顶点创建一个并查集结构，其中每个顶点最初都构成其自己的独立分量（集合）。\n2.  **处理初始边**：对于初始边集 $E_{\\text{init}}$ 中的每条边 $(u, v)$，执行 `union(u, v)` 操作，将它们的连通分量合并。\n3.  **处理提议边**：对于要添加的边列表 $E_{\\text{add}}$ 中的每条边 $(u, v)$：\n    a. 首先，检查自环。如果 $u = v$，根据定义，这会形成一个环。\n    b. 接着，使用 `find(u)` 和 `find(v)` 操作来确定 $u$ 和 $v$ 的代表元素（即它们所属连通分量的“根”）。\n    c. 如果 `find(u) == find(v)`，说明 $u$ 和 $v$ 已经在同一个连通分量中。添加边 $(u, v)$ 将会形成一个环。记录结果为 `True`，并且不修改并查集结构（因为这条边被“拒绝”了）。\n    d. 如果 `find(u) != find(v)`，说明它们在不同的分量中。添加这条边不会形成环。记录结果为 `False`，然后执行 `union(u, v)` 操作将这两个分量合并，以反映新边已加入图中。\n\n该程序实现了带有路径压缩和按秩合并优化的并查集，确保了 `find` 和 `union` 操作的摊还时间复杂度接近常数，从而为动态环检测问题提供了高效的解决方案。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass UnionFind:\n    \"\"\"\n    An implementation of the Union-Find (Disjoint Set Union) data structure.\n\n    This data structure keeps track of a set of elements partitioned into a\n    number of disjoint (non-overlapping) subsets. It provides two main\n    operations: find, which determines which subset an element is in, and\n    union, which joins two subsets into a single subset.\n\n    This implementation uses two standard optimizations for near-constant time\n    amortized performance:\n    1. Union by Rank: When merging two sets, the root of the shorter tree\n       is made a child of the root of the taller tree. This keeps the trees\n       from becoming too deep.\n    2. Path Compression: During a find operation, the path from the element\n       to the root is flattened, making future finds faster.\n    \"\"\"\n    def __init__(self, n):\n        \"\"\"\n        Initializes the Union-Find structure for n elements.\n        Each element from 0 to n-1 starts in its own set.\n        \n        Args:\n            n (int): The number of elements.\n        \"\"\"\n        # parent[i] stores the parent of element i.\n        self.parent = np.arange(n)\n        # rank[i] stores the height of the tree rooted at i.\n        self.rank = np.zeros(n, dtype=int)\n\n    def find(self, i):\n        \"\"\"\n        Finds the representative (root) of the set containing element i.\n        Implements path compression.\n        \n        Args:\n            i (int): The element to find.\n        \n        Returns:\n            int: The representative of the set.\n        \"\"\"\n        if self.parent[i] == i:\n            return i\n        # Path compression: set the parent of i directly to the root.\n        self.parent[i] = self.find(self.parent[i])\n        return self.parent[i]\n\n    def union(self, i, j):\n        \"\"\"\n        Merges the sets containing elements i and j.\n        Implements union by rank.\n        \n        Args:\n            i (int): The first element.\n            j (int): The second element.\n        \"\"\"\n        root_i = self.find(i)\n        root_j = self.find(j)\n        \n        if root_i != root_j:\n            # Union by rank\n            if self.rank[root_i]  self.rank[root_j]:\n                self.parent[root_i] = root_j\n            elif self.rank[root_i] > self.rank[root_j]:\n                self.parent[root_j] = root_i\n            else:\n                self.parent[root_j] = root_i\n                self.rank[root_i] += 1\n\n\ndef solve():\n    \"\"\"\n    Solves the cycle detection problem for a series of test cases.\n    For each test case, it processes initial and proposed edge additions,\n    reporting for each proposed edge whether its addition would create a cycle.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case A (general case)\n        (5, [], [(0, 1), (1, 2), (2, 3), (3, 4), (4, 0)]),\n        # Test case B (merging components then closing a cycle)\n        (4, [(0, 1), (2, 3)], [(1, 2), (0, 2), (1, 3)]),\n        # Test case C (self-loop and repeated connection)\n        (3, [], [(0, 0), (1, 2), (2, 1)]),\n        # Test case D (single vertex boundary)\n        (1, [], [(0, 0), (0, 0)]),\n    ]\n\n    all_results = []\n    \n    for n, E_init, E_add in test_cases:\n        # Initialize Union-Find data structure for n vertices.\n        uf = UnionFind(n)\n        \n        # Process the initial set of edges to establish the starting graph state.\n        for u, v in E_init:\n            uf.union(u, v)\n        \n        case_results = []\n        # Process each proposed edge addition.\n        for u, v in E_add:\n            # According to the problem, a self-loop (u, u) always creates a cycle.\n            if u == v:\n                case_results.append(True)\n                # The state of the graph does not change for a rejected edge.\n                continue\n\n            # Check if u and v are already in the same connected component.\n            # If find(u) == find(v), they are, and adding edge (u, v) creates a cycle.\n            if uf.find(u) == uf.find(v):\n                case_results.append(True)\n            else:\n                # If they are in different components, adding the edge does not create a cycle.\n                case_results.append(False)\n                # The edge is added to the graph, so we merge the components.\n                uf.union(u, v)\n        \n        all_results.append(case_results)\n\n    # Format the final output string as specified.\n    # e.g., [[False,False,True],[False,True]]\n    output_str = f\"[{','.join([str(res).replace(' ', '') for res in all_results])}]\"\n    print(output_str)\n\nsolve()\n```", "id": "3237184"}]}