{"hands_on_practices": [{"introduction": "理论知识通过实践才能真正内化。本章提供了一系列动手练习，旨在巩固你对 Bellman-Ford 算法及其核心应用的理解，特别是如何检测和处理负权重环。这些练习经过精心设计，将引导你从创造性地应用算法，到处理更复杂的逻辑，再到编写稳健的实现，从而逐步提升你的问题解决能力。\n\n我们将超越泛泛的负环检测，从一个更具针对性的问题开始。本练习 [@problem_id:3213972] 挑战你寻找一个通过*特定*边的负环。这需要你将问题重新构建为一个标准的最短路径查询，这是算法设计中的一项关键技能，能很好地检验你对路径权重和环权重之间关系的理解。", "problem": "给定一个由有限顶点集和有限边集指定的有向加权图。每条边都有一个整数权重。环是一个起点和终点为同一顶点的闭合路径。环的总权重是其构成边的权重之和。如果一个环的总权重严格小于 $0$，则称其为负权环。图中还给定了一条指定的有向边 $(u,v)$。你的任务是设计并实现一个程序，该程序使用最短路径定义的第一性原理和贝尔曼-福特算法，来确定是否存在一个通过指定边 $(u,v)$ 的负权环。如果存在这样的环，程序必须返回它的一个显式实例，形式为一个有序的顶点索引列表，从 $u$ 开始，立即遍历指定的边到 $v$，然后继续直到返回 $u$。如果不存在这样的环，则对该测试用例返回空列表。\n\n使用的基本原理和定义：\n- 有向加权图是一个元组 $(V,E,w)$，其中 $V$ 是由整数索引的有限顶点集，$E \\subseteq V \\times V$ 是有向边集，而 $w: E \\to \\mathbb{Z}$ 为每条边赋予一个整数权重。\n- 对于一条路径 $P = (x_0, x_1, \\ldots, x_k)$，其中对所有 $i \\in \\{0,\\ldots,k-1\\}$ 都有 $(x_i, x_{i+1}) \\in E$，路径权重为 $\\sum_{i=0}^{k-1} w(x_i, x_{i+1})$。\n- 对于一条边 $(u,v) \\in E$ 以及从 $v$ 到 $u$ 的任意路径 $Q$，先遍历 $(u,v)$ 再沿着 $Q$ 行进的闭合路径构成一个环。如果没有负权环使得通向 $u$ 的路径上的最短路径值无法确定，那么存在一个通过 $(u,v)$ 的负权环的充要条件是，存在一条从 $v$到 $u$ 的路径 $Q$，其权重严格小于 $-w(u,v)$，因为该环的总权重是 $w(u,v) + W(Q)$。\n\n你的程序必须：\n- 纯粹在数学和算法逻辑层面运行。不涉及物理单位。\n- 对于每个测试用例，根据图的结构确定是否存在一个包含指定边 $(u,v)$ 的负权环。如果存在，则返回一个环，形式为表示顶点索引的有序整数列表，从 $u$ 开始，然后到 $v$，最后回到 $u$ 以闭合环路。如果不存在，则返回空列表。\n- 从 $v$ 应用贝尔曼-福特算法计算到 $u$ 的最短路径估计值，并在适用时使用前驱信息重构从 $v$ 回到 $u$ 的路径。将此路径与指定边 $(u,v)$ 结合以生成环，并根据基本定义验证其负权性。避免依赖基本定义和广泛接受的算法事实之外的任何捷径公式。\n\n测试套件：\n对于下面的每个测试用例，顶点由非负整数索引，边以三元组 $(a,b,w)$ 的形式给出，其中 $a,b \\in V$ 且权重 $w \\in \\mathbb{Z}$，指定的边是 $(u,v)$。这些图规模很小，选择它们是为了覆盖不同方面：存在通过指定边的明确负权环、不存在此类环、零权重环边界情况、边不存在、图中不相关的负权环导致的多组件图以及缺少返回路径。\n\n- 测试用例 1 (成功路径，存在通过指定边的负权环)：\n  - 顶点数：$4$。\n  - 边：$(1,2,-1)$, $(2,3,1)$, $(3,1,-1)$, $(0,1,4)$, $(0,2,2)$。\n  - 指定的边：$(1,2)$。\n  - 存在一个环 $1 \\to 2 \\to 3 \\to 1$，总权重为 $-1 + 1 + (-1) = -1$。\n\n- 测试用例 2 (路径存在但生成的环不是负权环)：\n  - 顶点数：$3$。\n  - 边：$(0,1,2)$, $(1,2,1)$, $(2,0,0)$。\n  - 指定的边：$(0,1)$。\n  - 从 $1$ 到 $0$ 的路径权重为 $1 + 0 = 1$，因此环的权重是 $2 + 1 = 3$，不是负值。\n\n- 测试用例 3 (指定的边不存在)：\n  - 顶点数：$4$。\n  - 边：$(0,1,1)$, $(1,2,1)$, $(2,0,1)$。\n  - 指定的边：$(3,2)$。\n  - 由于 $(3,2)$ 不在 $E$ 中，没有环可以穿过它。\n\n- 测试用例 4 (零权重环边界情况)：\n  - 顶点数：$6$。\n  - 边：$(4,5,-2)$, $(5,4,2)$, $(0,1,3)$, $(1,2,3)$, $(2,3,3)$, $(3,0,-1)$。\n  - 指定的边：$(4,5)$。\n  - 环 $4 \\to 5 \\to 4$ 的总权重为 $-2 + 2 = 0$，不是负值。\n\n- 测试用例 5 (负权环存在于别处，但未通过指定的边)：\n  - 顶点数：$6$。\n  - 边：$(0,3,0)$, $(3,4,1)$, $(4,0,0)$, $(1,2,-3)$, $(2,1,-3)$。\n  - 指定的边：$(0,3)$。\n  - $1$ 和 $2$ 之间存在一个负权环，但它在不同的组件中，并不意味着存在一个通过 $(0,3)$ 的负权环。\n\n- 测试用例 6 (指定的边存在但没有返回路径以闭合环路)：\n  - 顶点数：$2$。\n  - 边：$(0,1,-1)$。\n  - 指定的边：$(0,1)$。\n  - 没有从 $1$ 回到 $0$ 的路径，所以不存在环。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果，每个元素对应一个测试用例，并且要么是空列表（写作 $[]$），要么是表示一个通过 $(u,v)$ 的已找到的负权环的顶点序列的整数列表。打印的输出中不得有空格。例如，格式必须类似于 $[[1,2,3,1],[],\\ldots]$，测试用例结果之间用逗号分隔，且字符串中任何地方都没有空格。", "solution": "问题要求我们确定一个有向加权图 $(V,E,w)$ 是否包含一个通过指定边 $(u,v) \\in E$ 的负权重环。如果存在这样的环，我们必须提供它的一个实例。\n\n识别此类环的基本原理植根于环权重的定义。一个通过边 $(u,v)$ 的环由遍历 $(u,v)$ 后跟随一条从顶点 $v$ 回到顶点 $u$ 的路径 $P$ 构成。这个环的总权重 $W_{cycle}$ 是边 $(u,v)$ 的权重（记为 $w(u,v)$）与路径 $P$ 的权重（记为 $W(P_{v \\to u})$）之和。\n$$W_{cycle} = w(u,v) + W(P_{v \\to u})$$\n该环为负权环的充要条件是其总权重严格小于零。\n$$w(u,v) + W(P_{v \\to u})  0$$\n这个不等式可以重排，从而得到对路径权重的一个条件：\n$$W(P_{v \\to u})  -w(u,v)$$\n要确定是否存在这样的路径，我们必须找到从 $v$ 到 $u$ 的权重尽可能小的路径。根据定义，这就是从 $v$ 到 $u$ 的最短路径。设此最短路径的权重为 $\\delta(v,u)$。如果 $\\delta(v,u)  -w(u,v)$，那么就保证存在一个通过 $(u,v)$ 的负权环，该环由边 $(u,v)$ 和这条最短路径构成。如果连最短路径都不满足此条件，那么其他任何路径也不会满足，因此不存在这样的负权环。\n\n问题描述包含一个关键的规定：“如果没有负权环使得通向 $u$ 的路径上的最短路径值无法确定”。这意味着我们可以假设最短路径权重 $\\delta(v,u)$ 是一个有限值，而不是 $-\\infty$，如果从 $v$ 到 $u$ 的最短路径上包含负权重环，则其权重会是 $-\\infty$。这一简化允许直接应用标准的单源最短路径算法。\n\n贝尔曼-福特算法是完成此项任务的合适工具，因为它能在可能包含负权重边的图中正确计算单源最短路径。我们将以顶点 $v$ 为源点执行贝尔曼-福特算法，以找到到包括 $u$ 在内的所有其他顶点的最短路径。\n\n算法流程如下：\n\n1.  **初始验证**：首先，我们验证指定的边 $(u,v)$ 是否存在于图的边集 $E$ 中。如果不存在，则没有环可以穿过它，该测试用例的处理终止。设其权重为 $w_{uv}$。\n\n2.  **执行贝尔曼-福特算法**：我们初始化一个大小为 $|V|$ 的距离数组 $d$，其中 $d[v] = 0$，对于所有其他顶点 $i \\in V$，$d[i] = \\infty$。同时初始化一个前驱数组 $p$ 以跟踪路径。贝尔曼-福特算法的核心是松弛图中的每一条边。这个松弛步骤重复 $|V|-1$ 次。对于每条权重为 $w_{xy}$ 的边 $(x,y)$，松弛操作为：如果 $d[x] + w_{xy}  d[y]$，则将 $d[y]$ 更新为 $d[x] + w_{xy}$ 并设置 $p[y] = x$。在 $|V|-1$ 次迭代后，根据问题的简化假设，$d[u]$ 将持有从 $v$ 到 $u$ 的最短路径的权重 $\\delta(v,u)$。\n\n3.  **路径与环存在性检查**：\n    - 如果算法完成后，$d[u]$ 仍然是 $\\infty$，这表示从 $v$ 到 $u$ 没有路径。因此，无法形成环，我们断定不存在这样的负权环。\n    - 如果路径存在（即 $d[u]$ 是有限的），我们检查负权条件：$d[u] + w_{uv}  0$。如果不满足此条件，则由最短路径形成的环不是负权环，并且从 $v$ 到 $u$ 的其他任何路径都无法形成权重更小的环。\n\n4.  **环的重构**：如果满足负权条件 $d[u] + w_{uv}  0$，则找到了一个负权环。我们必须重构其顶点序列。这通过使用前驱数组 $p$ 从 $u$ 开始回溯来完成。我们从一个包含 $u$ 的列表开始，然后迭代地在其前端插入其前驅 $p[u]$，接着是 $p[p[u]]$，依此类推，直到到达 $v$。这个过程产生从 $v$ 到 $u$ 的最短路径的顶点列表，我们称之为 `path_v_to_u`。最终输出是构成环的有序顶点列表，该环从 $u$ 开始，遍历到 $v$ 的边，然后沿着重构的路径返回到 $u$。这对应于将仅包含 $u$ 的列表与 `path_v_to_u` 连接起来，即 `[u] + path_v_to_u`。对于路径 $v \\to x_1 \\to \\dots \\to u$，重构的路径列表是 $[v, x_1, \\dots, u]$，而最终的环列表是 $[u, v, x_1, \\dots, u]$。\n\n这种系统性的方法，建立在最短路径的第一性原理之上，并通过贝尔曼-福特算法实现，能够正确解决指定的问题。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef find_negative_cycle_through_edge(num_vertices, edges, u, v):\n    \"\"\"\n    Determines if a negative cycle exists through a designated edge (u, v)\n    using the Bellman-Ford algorithm.\n\n    Args:\n        num_vertices (int): The number of vertices in the graph.\n        edges (list of tuples): The list of edges, each as (source, dest, weight).\n        u (int): The starting vertex of the designated edge.\n        v (int): The ending vertex of the designated edge.\n\n    Returns:\n        list: A list of vertex indices representing the negative cycle, starting and\n              ending at u. Returns an empty list if no such cycle exists.\n    \"\"\"\n    w_uv = None\n    edge_map = {(src, dst): weight for src, dst, weight in edges}\n    \n    if (u, v) not in edge_map:\n        return []\n    w_uv = edge_map[(u, v)]\n\n    # Step 2: Bellman-Ford from source v\n    dist = [np.inf] * num_vertices\n    pred = [None] * num_vertices\n    dist[v] = 0\n\n    for _ in range(num_vertices - 1):\n        for x, y, weight in edges:\n            if dist[x] != np.inf and dist[x] + weight  dist[y]:\n                dist[y] = dist[x] + weight\n                pred[y] = x\n\n    # Step 3: Path and Cycle Existence Check\n    if dist[u] == np.inf:\n        return []\n\n    if dist[u] + w_uv >= 0:\n        return []\n\n    # Step 4: Cycle Reconstruction\n    path_vu = []\n    curr = u\n    while True:\n        path_vu.insert(0, curr)\n        if curr == v:\n            break\n        curr = pred[curr]\n        # This safeguard is for unexpected graph structures, though not expected\n        # in this problem's context. If pred[curr] is None before reaching v,\n        # it means there's no path, which contradicts dist[u] being finite.\n        if curr is None and path_vu[0] != v:\n            return [] # Should not happen under normal BF operation\n\n    # The problem asks for the cycle starting at u, traversing (u,v), and returning to u.\n    # The sequence is u, followed by the path from v to u.\n    # Our reconstructed `path_vu` is the sequence of vertices from v to u.\n    # For example, for a path v -> x -> u, path_vu is [v, x, u].\n    # Cycle sequence u -> v -> x -> u is represented as [u, v, x, u].\n    # This is [u] + path_vu.\n    cycle = [u] + path_vu\n    \n    return cycle\n    \ndef solve():\n    \"\"\"\n    Defines the test cases from the problem statement and runs the solver.\n    \"\"\"\n    test_cases = [\n        {\n            \"num_vertices\": 4,\n            \"edges\": [(1, 2, -1), (2, 3, 1), (3, 1, -1), (0, 1, 4), (0, 2, 2)],\n            \"u\": 1, \"v\": 2,\n        },\n        {\n            \"num_vertices\": 3,\n            \"edges\": [(0, 1, 2), (1, 2, 1), (2, 0, 0)],\n            \"u\": 0, \"v\": 1,\n        },\n        {\n            \"num_vertices\": 4,\n            \"edges\": [(0, 1, 1), (1, 2, 1), (2, 0, 1)],\n            \"u\": 3, \"v\": 2,\n        },\n        {\n            \"num_vertices\": 6,\n            \"edges\": [(4, 5, -2), (5, 4, 2), (0, 1, 3), (1, 2, 3), (2, 3, 3), (3, 0, -1)],\n            \"u\": 4, \"v\": 5,\n        },\n        {\n            \"num_vertices\": 6,\n            \"edges\": [(0, 3, 0), (3, 4, 1), (4, 0, 0), (1, 2, -3), (2, 1, -3)],\n            \"u\": 0, \"v\": 3,\n        },\n        {\n            \"num_vertices\": 2,\n            \"edges\": [(0, 1, -1)],\n            \"u\": 0, \"v\": 1,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        result = find_negative_cycle_through_edge(\n            case[\"num_vertices\"], case[\"edges\"], case[\"u\"], case[\"v\"]\n        )\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    result_strs = []\n    for r in results:\n        if r:\n            result_strs.append(f\"[{','.join(map(str, r))}]\")\n        else:\n            result_strs.append(\"[]\")\n    \n    print(f\"[{','.join(result_strs)}]\")\n\nsolve()\n```", "id": "3213972"}, {"introduction": "接下来，我们将探讨负环如何“污染”最短路径。一旦一个负环可以从源点到达，那么任何从该环出发可以到达的节点，其最短路径都变得没有意义（可以无限小）。本练习 [@problem_id:3214050] 将教你如何实现一个“安全”的最短路径算法，该算法能正确识别这些受影响的区域，并找出能够避开它们的有效路径，这在许多现实应用中至关重要。", "problem": "给定一个有限有向加权图 $G=(V,E)$，其边权重为实值函数 $w:E\\to\\mathbb{R}$。从源顶点 $s\\in V$ 到目标顶点 $t\\in V$ 的一条路径是一个顶点序列 $\\left[v_0,v_1,\\dots,v_k\\right]$，其中 $v_0=s$，$v_k=t$，并且对于所有 $i\\in\\{0,1,\\dots,k-1\\}$，都有 $\\left(v_i,v_{i+1}\\right)\\in E$。路径的权重是其边权重之和，即 $\\sum_{i=0}^{k-1} w\\!\\left(v_i,v_{i+1}\\right)$。环（或回路）是满足 $v_0=v_k$ 且 $k\\geq 1$ 的路径。负环（或负权环）是总权重严格小于 $0$ 的环。在单源最短路径（SSSP）问题中，目标是在所有从 $s$到 $t$ 的路径中，找到一条总权重最小的路径。\n\n您的任务是编写一个完整的程序，为每个给定的测试用例计算一条从 $s$到 $t$ 的最短路径，并保证该路径不属于任何负环，即使图中其他地方存在这样的环。程序必须实现相应的逻辑，以确保返回的路径仅使用那些不受任何从 $s$ 可达的负环影响的顶点。如果目标顶点 $t$ 从 $s$ 不可达，或者 $t$ 可以从任何位于从 $s$ 可達的负环上或可从该负环到达的顶点到达，那么就不存在明确定义的有限最短路径，此时您必须返回一个空列表。\n\n您必须遵守的基本原则和定义：\n- 有向加权图 $G=(V,E)$ 拥有顶点集 $V$ 和边集 $E\\subseteq V\\times V$，每条边 $\\left(u,v\\right)\\in E$ 都被赋予一个权重 $w\\!\\left(u,v\\right)\\in\\mathbb{R}$。\n- 任何路径 $\\left[v_0,\\dots,v_k\\right]$ 的权重为 $\\sum_{i=0}^{k-1} w\\!\\left(v_i,v_{i+1}\\right)$。\n- 负环是任何满足 $v_0=v_k$ 且 $\\sum_{i=0}^{k-1} w\\!\\left(v_i,v_{i+1}\\right)  0$ 的环。\n- 一个经过充分验证的事实是，如果存在一个从 $s$ 可达且能到达 $t$ 的负环，那么 $s$ 到 $t$ 的路径权重就不存在有限最小值；此外，在 Bellman-Ford 算法中执行 $|V|-1$ 轮松弛后，如果仍然存在任何边 $\\left(u,v\\right)\\in E$ 满足距离估计值 $d[u]+w\\!\\left(u,v\\right)$ 仍小于 $d[v]$，则意味着存在一个从 $s$ 可达的负环，并且任何从这种进一步松弛的证据点可达的顶点都会受到该负环的影响。\n\n输出要求：\n- 对于每个测试用例，将路径作为表示从 $s$到 $t$ 的顶点序列的整数列表返回。如果不存在明确定义的有限最短路径（因为 $t$ 从 $s$ 不可达，或 $t$ 受到从 $s$ 可达的负环的影响），则返回一个空列表 $\\left[\\right]$。\n- 您的程序应生成一行输出，其中包含一个方括号括起来的逗号分隔列表（例如，$\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3\\right]$），其中每个 $\\text{result}_i$ 本身是一个列表（例如，$\\left[0,1,2\\right]$）或一个空列表 $\\left[\\right]$。\n\n测试套件：\n请严格使用以下测试用例，每个用例由一个元组 $\\left(n,E,s,t\\right)$ 指定，其中 $n=|V|$ 是顶点数量（标记为整数 $\\{0,1,\\dots,n-1\\}$），$E$ 是一个有向边列表，其权重以三元组 $\\left(u,v,w\\right)$ 的形式给出，$s,t$ 分别是源顶点和目标顶点。\n\n- 测试用例 1 (正常情况，图中存在从源点不可达的负环):\n  - $n=5$\n  - $E=\\left[\\left(0,1,3\\right),\\left(1,2,-2\\right),\\left(0,2,5\\right),\\left(3,4,-1\\right),\\left(4,3,-1\\right)\\right]$\n  - $s=0$\n  - $t=2$\n  - 预期行为：顶点 $\\left\\{3,4\\right\\}$ 上的负环从 $s$ 不可达，因此最短路径是明确定义的。\n\n- 测试用例 2 (从 $s$ 可达的负环可以到达 $t$):\n  - $n=4$\n  - $E=\\left[\\left(0,1,1\\right),\\left(1,2,1\\right),\\left(2,1,-3\\right),\\left(2,3,2\\right)\\right]$\n  - $s=0$\n  - $t=3$\n  - 预期行为：存在一个从 $s$ 可达且能到达 $t$ 的负环，因此不存在有限最短路径；返回 $\\left[\\right]$。\n\n- 测试用例 3 (从 $s$ 可达的负环无法到达 $t$，存在一条不受影响的路径到达 $t$):\n  - $n=6$\n  - $E=\\left[\\left(0,1,2\\right),\\left(1,2,2\\right),\\left(2,1,-5\\right),\\left(0,3,1\\right),\\left(3,4,1\\right),\\left(4,5,1\\right)\\right]$\n  - $s=0$\n  - $t=5$\n  - 预期行为：顶点 $\\left\\{1,2\\right\\}$ 上的负环从 $s$ 可达但无法到达 $t$，因此到 $t$ 的最短路径是明确定义的，并且必须避开受影响的顶点。\n\n- 测试用例 4 (目标不可达):\n  - $n=3$\n  - $E=\\left[\\left(0,1,1\\right)\\right]$\n  - $s=0$\n  - $t=2$\n  - 预期行为：顶点 $t$ 从 $s$ 不可达；返回 $\\left[\\right]$。\n\n- 测试用例 5 (边界情况 $s=t$，且 $s$ 不受负环影响):\n  - $n=3$\n  - $E=\\left[\\left(0,2,4\\right)\\right]$\n  - $s=1$\n  - $t=1$\n  - 预期行为：从 $s$ 到其自身的最短路径是平凡路径 $\\left[1\\right]$，因为 $s$ 不受任何负环的影响。\n\n您的程序必须使用这些测试用例，并输出一行包含结果列表的内容，格式与上述描述完全一致。", "solution": "给定的问题要求在一个边权重可以为负的有向加权图 $G=(V,E)$ 中，计算从源顶点 $s$ 到目标顶点 $t$ 的最短路径。关键的约束是路径必须是明确定义的，这意味着不能通过遍历负环来无限地减小其权重。具体来说，如果目标 $t$ 不可达，或者其最短路径受到从 $s$ 可达的负环的影响，那么这样的路径就不存在。\n\n负边权的存在表明应使用 Bellman-Ford 算法，该算法专为此类图中的单源最短路径（SSSP）问题而设计。标准的 Bellman-Ford 算法还可以检测是否存在从源点 $s$ 可达的负环。我们的任务要求扩展此功能，以识别所有其最短路径计算被此类环“破坏”的顶点，并确保我们到 $t$ 的路径避开它们。\n\nBellman-Ford 算法的核心原理是迭代松弛。它将到源点的距离 $d[s]$ 初始化为 $0$，并将所有其他距离 $d[v]$ 初始化为无穷大。然后，它会重复地对图中的所有边进行松弛操作。对于权重为 $w(u,v)$ 的边 $(u,v)$，松弛操作是检查通过 $u$ 是否可以缩短到 $v$ 的路径，即判断是否满足 $d[u] + w(u,v)  d[v]$。如果满足，则将 $d[v]$ 更新为 $d[u] + w(u,v)$，并将这条路径上 $v$ 的前驱节点 $p[v]$ 设置为 $u$。\n\n在一个有 $|V|$ 个顶点的图中，任何简单路径（没有重复顶点的路径）最多只能有 $|V|-1$ 条边。Bellman-Ford 算法保证，在对所有边进行 $|V|-1$ 轮松弛迭代后，只要不存在从 $s$ 可达的负环，计算出的距离 $d[v]$ 就是从 $s$ 到所有其他顶点 $v$ 的最短路径权重。\n\n问题的关键在于正确处理负环。如问题描述所述，Bellman-Ford 算法的一个关键特性是，如果在 $|V|-1$ 轮迭代后，对于任何边 $(u,v)$ 仍可能进行进一步的松弛，这就标志着存在一个从 $s$ 可达的负权环。任何在概念上的第 $|V|$ 轮迭代中其距离估计值 $d[v]$ 被减小的顶点 $v$，都位于一条从 $s$ 出发且包含负环的路径上。到这类顶点的最短路径是未定义的（可以通过重复遍历该环使其变得任意小）。\n\n此外，任何从受负环影响的顶点可达的顶点也被视为受影响，因为到它的路径可能经过被破坏的顶点，使其最短路径权重也变为未定义。\n\n这引出了以下综合算法：\n\n1.  **初始化**：对于一个有 $n=|V|$ 个顶点的图，创建一个大小为 $n$ 的距离数组 $d$，并将 $d[s] = 0$ 和所有 $v \\neq s$ 的 $d[v] = \\infty$ 初始化。创建一个大小为 $n$ 的前驱节点数组 $p$，初始化为一个哨兵值（例如 $-1$），表示没有前驱节点。\n\n2.  **Bellman-Ford 松弛**：执行 $n-1$ 轮迭代。在每一轮迭代中，遍历每条权重为 $w(u,v)$ 的边 $(u,v) \\in E$，并执行松弛步骤：如果 $d[u] \\neq \\infty$ 且 $d[u] + w(u,v)  d[v]$，则更新 $d[v] = d[u] + w(u,v)$ 和 $p[v] = u$。\n\n3.  **识别受影响的顶点**：\n    a.  识别直接受负环影响的顶点。我们可以通过执行额外一轮松弛检查（第 $n$ 輪）来做到这一点。创建一个队列 `affected_queue`，对于每条边 $(u,v) \\in E$，如果 $d[u] + w(u,v)  d[v]$，这意味着 $v$ 位于一条从 $s$ 出发并涉及负环的路径上。将 $v$ 添加到 `affected_queue`。为了避免重复并进行高效查找，也使用一个集合 `all_affected` 来填充这些初始顶点。\n    b.  传播“受影响”状态。任何从一个受影响顶点可达的顶点也同样受到影响。从 `affected_queue` 中的所有顶点开始，执行图遍历（例如广度优先搜索或深度优先搜索）。为此，使用图的邻接表表示会很有用。在遍历过程中，将所有新发现的可达顶点添加到 `all_affected` 集合中。\n\n4.  **路径确定与重构**：\n    a.  首先，检查目标顶点 $t$ 是否可达。如果在 Bellman-Ford 阶段后 $d[t] = \\infty$，则不存在从 $s$到 $t$ 的路径。结果为空列表。\n    b.  其次，检查 $t$ 是否受负环影响。如果 $t$ 在 `all_affected` 集合中，则不存在明确定义的有限最短路径。结果为空列表。\n    c.  如果 $t$ 可达且未受影响，则存在一条有效的最短路径。可以从 $t$ 开始，使用数组 $p$ 迭代地移至其前驱节点，直到到达 $s$，从而重构该路径。将访问过的顶点序列反转，即可得到从 $s$到 $t$ 的最短路径。如果 $s=t$，路径就是简单的 $[s]$。\n\n该算法首先运行 Bellman-Ford 算法计算路径权重和前驱节点，然后系统地识别并隔离所有最短路径距离因负环而受损的顶点，最后在重构路径之前根据这些条件检查目标顶点，从而正确地找到一条安全的最短路径。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the provided test cases for the secure shortest path problem.\n    \"\"\"\n    test_cases = [\n        # Test case 1: Happy path with an unreachable negative cycle\n        {\n            \"n\": 5,\n            \"E\": [(0, 1, 3), (1, 2, -2), (0, 2, 5), (3, 4, -1), (4, 3, -1)],\n            \"s\": 0,\n            \"t\": 2,\n        },\n        # Test case 2: Negative cycle reachable from s that can reach t\n        {\n            \"n\": 4,\n            \"E\": [(0, 1, 1), (1, 2, 1), (2, 1, -3), (2, 3, 2)],\n            \"s\": 0,\n            \"t\": 3,\n        },\n        # Test case 3: Negative cycle reachable from s but cannot reach t\n        {\n            \"n\": 6,\n            \"E\": [(0, 1, 2), (1, 2, 2), (2, 1, -5), (0, 3, 1), (3, 4, 1), (4, 5, 1)],\n            \"s\": 0,\n            \"t\": 5,\n        },\n        # Test case 4: Target unreachable\n        {\n            \"n\": 3,\n            \"E\": [(0, 1, 1)],\n            \"s\": 0,\n            \"t\": 2,\n        },\n        # Test case 5: Boundary case s=t\n        {\n            \"n\": 3,\n            \"E\": [(0, 2, 4)],\n            \"s\": 1,\n            \"t\": 1,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        result = find_shortest_safe_path(case[\"n\"], case[\"E\"], case[\"s\"], case[\"t\"])\n        results.append(result)\n\n    # Format the final output string to be space-free as per the implicit format.\n    formatted_results = [f\"[{','.join(map(str, r))}]\" for r in results]\n    print(f'[{\",\".join(formatted_results)}]')\n\n\ndef find_shortest_safe_path(n, E, s, t):\n    \"\"\"\n    Finds a shortest path from s to t that is not affected by any negative cycle.\n\n    Args:\n        n (int): The number of vertices, labeled 0 to n-1.\n        E (list): A list of edges, where each edge is a tuple (u, v, w).\n        s (int): The source vertex.\n        t (int): The target vertex.\n\n    Returns:\n        list: A list of integers representing the path from s to t, or an empty list\n              if no such path exists.\n    \"\"\"\n    # Step 1: Initialization\n    distances = np.full(n, np.inf)\n    predecessors = np.full(n, -1, dtype=int)\n    distances[s] = 0\n\n    # Step 2: Bellman-Ford relaxations for n-1 iterations\n    for _ in range(n - 1):\n        for u, v, w in E:\n            if distances[u] != np.inf and distances[u] + w  distances[v]:\n                distances[v] = distances[u] + w\n                predecessors[v] = u\n\n    # Step 3: Identification of affected vertices\n    # a. Identify vertices directly updated in the n-th relaxation round\n    initially_affected = set()\n    for u, v, w in E:\n        if distances[u] != np.inf and distances[u] + w  distances[v]:\n            initially_affected.add(v)\n\n    # b. Propagate the \"affected\" status via BFS\n    if not initially_affected:\n        all_affected = set()\n    else:\n        # Build adjacency list for traversal\n        adj = [[] for _ in range(n)]\n        for u, v, _ in E:\n            adj[u].append(v)\n            \n        all_affected = set(initially_affected)\n        queue = list(initially_affected)\n        \n        while queue:\n            curr = queue.pop(0)\n            for neighbor in adj[curr]:\n                if neighbor not in all_affected:\n                    all_affected.add(neighbor)\n                    queue.append(neighbor)\n\n    # Step 4: Path Determination and Reconstruction\n    # Case a: Target is unreachable\n    if distances[t] == np.inf:\n        return []\n\n    # Case b: Target is affected by a negative cycle\n    if t in all_affected:\n        return []\n\n    # Case c: A valid, safe shortest path exists\n    path = []\n    curr = t\n    while curr != -1:\n        path.append(curr)\n        if curr == s:\n            break\n        curr = predecessors[curr]\n    \n    path.reverse()\n    \n    if path and path[0] == s:\n        return path\n    else:\n        # This case should not be reached if distances[t] is finite\n        # and predecessors are correctly maintained, but serves as a safeguard.\n        return []\n\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3214050"}, {"introduction": "最后，我们将注意力从算法逻辑转向实现的现实问题。理论算法常常假设数字的精度是无限的，但实际计算机使用有限位数的整数（例如 $64$ 位整数）。本练习 [@problem_id:3213991] 解决了算术溢出这一实际挑战，它可能导致灾难性的错误结果。它将指导你构建一个能够避免这些底层陷阱的 Bellman-Ford 实现，这是编写生产级代码的一项至关重要的技能。", "problem": "你的任务是设计并实现一个程序，该程序使用 Bellman-Ford 算法计算有向加权图中的最短路径估计值。重点是根据路径和环路的核心定义进行推理，并确保实现仅使用带符号的 $64$ 位整数运算，包括一个在松弛操作期间检测和处理潜在溢出的稳健策略。\n\n使用的基本依据是以下这组定义和属性：\n- 一个有向图 $G = (V, E)$ 由一个有限的顶点集合 $V$ 和带权重的有向边集合 $E \\subseteq V \\times V$ 组成。\n- 每条边 $(u, v) \\in E$ 都有一个整数权重 $w(u, v)$。一条路径 $P = (v_0, v_1, \\dots, v_k)$ 的总权重等于其边权重之和，即 $W(P) = \\sum_{i=0}^{k-1} w(v_i, v_{i+1})$。\n- 环路是一条起点和终点相同的路径。如果一个环路的边权重之和严格小于 $0$，则该环路是负环。\n- Bellman-Ford 算法根据路径定义迭代地对边进行松弛操作，如果在 $|V|-1$ 次迭代之后，一次额外的松弛操作仍然可以减少某个距离估计值，它就能检测到从源点可达的负环的存在。\n- 所有整数计算必须符合带符号的 $64$ 位二进制补码边界。将可表示的最小带符号 $64$ 位整数定义为 $\\text{MIN} = -2^{63}$，最大值定义为 $\\text{MAX} = 2^{63}-1$。\n\n实现要求：\n- 所有路径权重计算和比较仅使用带符号的 $64$ 位整数运算。你必须设计一个松弛步骤，在尝试将两个带符号的 $64$ 位整数 $a$ 和 $b$ 相加之前检查潜在的溢出。如果 $a+b$ 的计算会超出可表示范围，必须通过关于 $\\text{MIN}$ 和 $\\text{MAX}$ 的不等式来检测溢出，而不实际执行加法。如果在尝试松弛时会发生溢出，则必须跳过该松弛操作（即，视为没有改进）。\n- 使用约定，初始不可达的顶点距离为 $\\text{INF} = \\text{MAX}$。使用约定，受从源点可达的负环影响的顶点距离为 $\\text{NEG\\_INF} = \\text{MIN}$。为保证科学上的真实性并防止模糊的哨兵值冲突，假设所有边的权重都严格位于开区间 $(\\text{MIN}, \\text{MAX})$ 内，并且除了标记受负环影响的顶点外，程序不会通过有限的松弛操作赋值 $\\text{MIN}$。\n- 算法必须在第 $|V|$ 轮中检测出其估计值仍可减小的顶点，然后将从任何此类顶点可达的所有顶点标记为受从源点可达的负环影响。这些顶点的输出距离必须设置为 $\\text{NEG\\_INF}$。\n\n你的程序必须是自包含的，并在其中编码以下固定的测试套件。将每个测试用例解释为一个具有指定源点的有向图，并为该用例生成计算结果。\n\n测试套件：\n- 案例 1（无负环的顺利路径）：\n  - 顶点数：$5$\n  - 边：$(0,1,5)$, $(0,2,10)$, $(1,3,3)$, $(2,3,1)$, $(3,4,2)$\n  - 源点：$0$\n  - 预期行为：正常计算最短路径估计值。\n- 案例 2（从源点可达的负环）：\n  - 顶点数：$4$\n  - 边：$(0,1,1)$, $(1,2,-1)$, $(2,1,-1)$, $(2,3,2)$\n  - 源点：$0$\n  - 预期行为：检测负环可达性并将其传播到受影响的顶点。\n- 案例 3（在松弛期间引发潜在溢出处理的边界权重）：\n  - 顶点数：$4$\n  - 边：$(0,1, \\text{MAX}-1)$, $(1,2, 10)$, $(1,3, \\text{MIN}+10)$\n  - 源点：$0$\n  - 预期行为：会导致溢出的松弛操作被跳过；其他在界限内的松弛操作正常进行。\n- 案例 4（带有不可达负环的非连通图）：\n  - 顶点数：$5$\n  - 边：$(1,2,4)$, $(2,3,5)$, $(3,1,-12)$\n  - 源点：$0$\n  - 预期行为：不可达顶点保持 $\\text{INF}$；负环从源点不可达，因此不影响输出。\n\n最终输出格式：\n- 对于每个测试用例，生成一个包含两个元素的列表：一个布尔值，指示是否有顶点受到从源点可达的负环的影响；以及一个带符号的 $64$ 位整数列表，表示到每个顶点的距离，其中 $\\text{INF} = 2^{63}-1$ 表示不可达，$\\text{NEG\\_INF} = -2^{63}$ 表示受到可达负环的影响。\n- 你的程序应生成单行输出，其中包含所有测试用例的结果，格式为用方括号括起来的逗号分隔列表。例如，整体输出应类似于打印行中的字面 Python 语法 $[ [\\text{boolean}, [\\text{d}_0,\\dots,\\text{d}_{n-1}] ], \\dots ]$。", "solution": "所提供的问题是有效的。这是图算法领域一个明确定义的任务，基于标准的计算机科学原理。关于算术和溢出处理的约束是具体且可形式化的。\n\n目标是实现 Bellman-Ford 算法，用于在有向加权图 $G=(V, E)$ 中从给定的源顶点 $s \\in V$ 寻找最短路径。实现必须严格遵守带符号的 $64$ 位整数运算，包括稳健的溢出检测，并正确处理负权重环路。\n\nBellman-Ford 算法的核心原理是迭代松弛，其依据是在没有负权重环路的图中，一条最短路径最多只能包含 $|V|-1$ 条边。设 $d[v]$ 为从源点 $s$ 到任意顶点 $v \\in V$ 的最短路径的估计权重。\n\n**1. 初始化**\n首先，我们初始化距离估计值。到源点 $s$ 的距离为 $0$，到所有其他顶点的距离为 $\\infty$。对于此问题，我们必须使用带符号的 $64$ 位整数的极限值。我们将 $\\text{INF}$ 定义为可表示的最大值 $\\text{MAX} = 2^{63}-1$，并将 $\\text{NEG\\_INF}$ 定义为可表示的最小值 $\\text{MIN} = -2^{63}$。\n距离数组 $d$ 初始化如下：\n$d[s] = 0$\n$d[v] = \\text{INF}$ 对所有 $v \\in V, v \\neq s$。\n\n**2. 带溢出安全的迭代松弛**\n算法通过重复松弛边来进行。对于每条权重为 $w(u,v)$ 的边 $(u, v) \\in E$，松弛操作是检查通过 $u$ 的路径是否能为到达 $v$ 提供一条更短的路径。标准的松弛操作是：如果 $d[u] + w(u,v)  d[v]$，则更新 $d[v] = d[u] + w(u,v)$。\n\n这个循环执行 $|V|-1$ 次。经过 $i$ 次迭代后，算法找到所有最多包含 $i$ 条边的最短路径。在 $|V|-1$ 次迭代后，只要不存在负权重环路，算法就找到了所有最短路径。\n\n一个关键要求是在带符号的 $64$ 位整数边界内安全地执行此加法以防止溢出。在计算 $a+b$（其中 $a=d[u]$ 且 $b=w(u,v)$）之前，我们必须检查结果是否会超出 $[\\text{MIN}, \\text{MAX}]$。如果出现以下情况，则发生溢出：\n- **正溢出**：$a > 0$，$b > 0$，并且 $b > \\text{MAX} - a$。\n- **负溢出**：$a  0$，$b  0$，并且 $b  \\text{MIN} - a$。\n如果检测到溢出，则跳过松弛操作，就像没有找到更短的路径一样。如果 $d[u] = \\text{INF}$，我们也不从顶点 $u$ 进行松弛。\n\n**3. 负权重环路检测**\n在 $|V|-1$ 次迭代之后，会执行最后一次，即第 $|V|$ 次，对所有边的迭代。如果任何距离 $d[v]$ 仍然可以被改进，这表明顶点 $v$ 位于一个负权重环路中或可从其到达，而该环路本身可从源点 $s$ 到达。具体来说，我们识别一组“受感染”的顶点：$$I = \\{ v \\in V \\mid \\exists (u, v) \\in E \\text{ such that } d[u] + w(u,v)  d[v] \\text{ after } |V|-1 \\text{ passes} \\}$$ 在此检查中必须使用相同的防溢出加法。如果这个集合 $I$ 非空，则表示检测到了一个可达的负权重环路。\n\n**4. 负权重环路传播**\n负权重环路的存在意味着到受其影响的顶点的最短路径是未定义的（或可被视为 $-\\infty$）。问题要求我们识别所有这些顶点，并将其距离设置为 $\\text{NEG\\_INF}$。如果一个顶点可以从属于负权重环路的任何顶点到达，那么它就受到了影响。我们的集合 $I$ 包含在第 $|V|$ 轮中距离被缩短的顶点。这些顶点保证可以从一个负环到达。因此，任何从集合 $I$ 中的顶点可达的顶点也受到影响。\n\n为实现这一点，我们从集合 $I$ 中的所有顶点开始执行图遍历（例如广度优先搜索或深度优先搜索）。在此遍历期间访问的所有顶点，其最终距离都被设置为 $\\text{NEG\\_INF}$。\n\n**5. 最终结果构建**\n每个测试用例的输出是一个序对：一个布尔值，指示是否检测到可达的负权重环路（即集合 $I$ 是否非空），以及一个包含到每个顶点的最终距离的列表。到不可达顶点的距离保持为 $\\text{INF}$，而受负环影响的顶点的距离设置为 $\\text{NEG\\_INF}$。实现将处理提供的测试套件，对每个案例应用此逻辑，并按规定将收集到的结果格式化为单个输出字符串。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Bellman-Ford problem for a fixed test suite,\n    adhering to strict 64-bit signed integer arithmetic and overflow handling.\n    \"\"\"\n\n    # Define 64-bit signed integer constants.\n    MIN = np.iinfo(np.int64).min\n    MAX = np.iinfo(np.int64).max\n\n    # Define the fixed test suite.\n    test_cases = [\n        {\n            \"num_vertices\": 5,\n            \"edges\": [(0, 1, 5), (0, 2, 10), (1, 3, 3), (2, 3, 1), (3, 4, 2)],\n            \"source\": 0,\n        },\n        {\n            \"num_vertices\": 4,\n            \"edges\": [(0, 1, 1), (1, 2, -1), (2, 1, -1), (2, 3, 2)],\n            \"source\": 0,\n        },\n        {\n            \"num_vertices\": 4,\n            \"edges\": [\n                (0, 1, int(MAX) - 1),\n                (1, 2, 10),\n                (1, 3, int(MIN) + 10),\n            ],\n            \"source\": 0,\n        },\n        {\n            \"num_vertices\": 5,\n            \"edges\": [(1, 2, 4), (2, 3, 5), (3, 1, -12)],\n            \"source\": 0,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        num_vertices = case[\"num_vertices\"]\n        edges = case[\"edges\"]\n        source = case[\"source\"]\n\n        # Initialize distances using 64-bit integers.\n        # INF is represented by MAX.\n        dist = np.full(num_vertices, MAX, dtype=np.int64)\n        dist[source] = np.int64(0)\n\n        # Main Bellman-Ford relaxation loop for |V| - 1 iterations.\n        for _ in range(num_vertices - 1):\n            for u, v, w in edges:\n                # Use Python's arbitrary-precision integers for checks to avoid overflow.\n                d_u = int(dist[u])\n                \n                # Skip relaxation if source vertex is unreachable.\n                if d_u == int(MAX):\n                    continue\n                \n                # Overflow-safe addition check.\n                if w > 0 and d_u > int(MAX) - w:  # Positive overflow\n                    continue\n                if w  0 and d_u  int(MIN) - w:  # Negative overflow\n                    continue\n                \n                new_dist = d_u + w\n                if new_dist  int(dist[v]):\n                    dist[v] = np.int64(new_dist)\n\n        # Detect vertices affected by negative cycles in the |V|-th iteration.\n        infected_nodes = set()\n        for u, v, w in edges:\n            d_u = int(dist[u])\n            if d_u == int(MAX):\n                continue\n            \n            if w > 0 and d_u > int(MAX) - w:\n                continue\n            if w  0 and d_u  int(MIN) - w:\n                continue\n\n            new_dist = d_u + w\n            if new_dist  int(dist[v]):\n                infected_nodes.add(v)\n        \n        has_neg_cycle = bool(infected_nodes)\n\n        # Propagate negative cycle effect to all reachable vertices.\n        # NEG_INF is represented by MIN.\n        if has_neg_cycle:\n            adj = [[] for _ in range(num_vertices)]\n            for u, v, _ in edges:\n                adj[u].append(v)\n            \n            # Multi-source BFS/DFS from all initially infected nodes.\n            q = list(infected_nodes)\n            visited = set(q)\n            head = 0\n            while head  len(q):\n                u = q[head]\n                head += 1\n                dist[u] = MIN\n                for v_neighbor in adj[u]:\n                    if v_neighbor not in visited:\n                        visited.add(v_neighbor)\n                        q.append(v_neighbor)\n\n        # Convert numpy array to list of Python integers for final output.\n        final_dists = [int(d) for d in dist]\n        results.append([has_neg_cycle, final_dists])\n\n    # Print the results in the specified single-line format.\n    # The string representation of a list includes spaces, which is fine.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3213991"}]}