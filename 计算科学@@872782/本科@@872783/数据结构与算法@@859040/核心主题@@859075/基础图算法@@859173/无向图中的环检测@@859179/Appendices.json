{"hands_on_practices": [{"introduction": "在许多应用中，如图形数据库或游戏地图设计中，我们需要确保网络结构是简单的、无回路的。这个练习将指导你解决一个基本问题：判断一个给定的图是否为无圈图（即森林）。通过这个实践，你将掌握使用深度优先搜索（DFS）等图遍历算法来识别“后向边”的核心技巧，这是无向图环路检测的理论基石 [@problem_id:3225348]。", "problem": "视频游戏的地牢布局可以建模为一个有限、简单、无向图，其顶点集为 $V$，边集为 $E$。其中，每个顶点是一个房间，每条边是连接两个不同房间的双向走廊。一个环是一系列不同的顶点 $v_{0}, v_{1}, \\dots, v_{k-1}$（其中 $k \\geq 3$），对于每个 $i \\in \\{0, 1, \\dots, k-1\\}$，顶点对 $\\{v_{i}, v_{(i+1) \\bmod k}\\}$ 都是一条边。如果一个图不包含任何环，则称其为无环图。森林是一个无环的无向图，可能包含多个连通分量。为确保地牢是一个简单的分支路径系统而非迷宫，它的每个连通分量都必须是无环的，也就是说，它必须是一个森林。\n\n基本基础和约束：\n- 图是有限、简单、无向的：边是不同顶点的无序对，不存在多重边，也不存在自环。\n- 顶点由从 $0$ 到 $n-1$ 的连续整数标记，其中 $n = |V|$。\n- 任务是根据上述定义判断无环性，而不是假设任何特定的算法捷径。\n\n任务：\n- 编写一个完整的程序，对下面的每个测试用例，判断给定的无向图是否在每个连通分量中都是无环的（即，判断它是否为森林），并为每个用例输出一个布尔值。\n\n程序输入模型：\n- 没有外部输入。请使用下面嵌入的测试套件作为内部数据源。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表，列表内无空格，结果顺序与下面列出的测试用例顺序一致。每个元素必须是 `True` 或 `False`，且大小写必须完全匹配。例如，一个有效的输出格式是 $[True,False]$。\n\n测试套件（每个测试用例都是一个数对 $(n, E)$，其中 $n$ 是顶点数，$E$ 是无向边列表，表示为顶点标签的无序对）：\n- 用例 $1$：$n = 5$，$E = \\{(0,1),(1,2),(1,3),(3,4)\\}$。这个连通图有分支但没有环；它应该是无环的。\n- 用例 $2$：$n = 5$，$E = \\{(0,1),(1,2),(2,3),(3,0)\\}$。这个连通图包含一个环；它应该是有环的。\n- 用例 $3$：$n = 7$，$E = \\{(0,1),(0,2),(2,3),(4,5)\\}$，顶点 $6$ 是孤立的。这个非连通图只包含树组件和一个孤立顶点；它应该是无环的。\n- 用例 $4$：$n = 6$，$E = \\{(0,1),(1,2),(2,0),(3,4),(4,5)\\}$。这个非连通图有一个有环组件和一个无环组件；整体上它应该是有环的。\n- 用例 $5$：$n = 1$，$E = \\{\\}$。一个孤立顶点；它应该是无环的。\n- 用例 $6$：$n = 2$，$E = \\{(0,1)\\}$。连接两个顶点的一条边；它应该是无环的。\n\n您的程序必须为每个用例计算一个布尔值，以指示图是否为无环的（当且仅当它是森林时为True），然后按上述确切格式打印单行文本，汇总用例 1 到 6 的结果。此问题不涉及物理单位或角度单位，输出中不允许也不需要百分比表达式。预期的答案类型是布尔值。", "solution": "该问题要求判断一个给定的简单无向图是否为森林。森林被定义为一个无环的无向图，它可能由一个或多个连通分量组成，其中每个分量都是一棵树（一个无环连通图）或一个孤立顶点。问题的核心是检测图的任何分量中是否存在环。一个图是无环的当且仅当它不包含任何环。\n\n在无向图中检测环最基本和最严谨的方法是使用图遍历算法，如深度优先搜索（DFS）。使用DFS进行环检测的原理基于DFS遍历本身的结构，它将图的边分为树边和返祖边。\n\n无向图中存在环的充要条件是DFS遍历遇到一条“返祖边”。返祖边是一条从当前访问的顶点 $u$ 连接到顶点 $v$ 的边 $(u, v)$，其中 $v$ 已经被访问过，并且不是 $u$ 在DFS树中的直接父节点。如果 $v$ 是 $u$ 的父节点，那么边 $(u, v)$ 只是用于发现 $u$ 的树边，追溯它不会形成环。然而，如果 $v$ 已被访问且不是 $u$ 的父节点，这意味着 $v$ 是 $u$ 在DFS树中的一个祖先节点，而边 $(u, v)$ 闭合了一条路径，从而形成一个环。\n\n对于每个测试用例，即一个图 $G = (V, E)$，其中有 $n = |V|$ 个顶点，标记为 $0, 1, \\dots, n-1$，算法按以下步骤进行：\n\n1.  **图的表示**：首先将以边列表 $E$ 形式给出的图转换为邻接表表示。邻接表（记为 `adj`）是一个数组或映射，其中 `adj[u]` 存储了所有满足 $\\{u, v\\} \\in E$ 的顶点 $v$ 的列表。这种结构可以高效地遍历任何给定顶点的邻居。\n\n2.  **状态跟踪**：初始化一个大小为 $n$ 的布尔数组 `visited`，所有条目均设为 `False`。该数组用于在遍历过程中跟踪已被访问的顶点。`visited[v] = True` 表示顶点 $v$ 已被访问过。\n\n3.  **连通分量遍历**：为处理可能不连通的图（即有多个连通分量），算法会遍历每个顶点 $u \\in \\{0, 1, \\dots, n-1\\}$。如果一个顶点 $u$ 尚未被访问（`visited[u]` 为 `False`），则表示发现了一个新的、未探索的连通分量的起点。从该顶点 $u$ 开始进行DFS遍历。\n\n4.  **用于环检测的递归DFS**：定义一个递归函数，称之为 `dfs_check(u, p)`，用于执行遍历和环检测。\n    -   它接受两个参数：当前正在访问的顶点 $u$，以及在DFS树中发现 $u$ 的父节点 $p$。父节点 $p$ 对于区分有效的父子树边和形成环的返祖边至关重要。对于新分量的初始调用，父节点可以是一个哨兵值（例如 $-1$），因为DFS树的根节点没有父节点。\n    -   进入 `dfs_check(u, p)` 后：\n        a. 将当前顶点 $u$ 标记为已访问：`visited[u] = True`。\n        b. 算法遍历 $u$ 的邻接表中的每个邻居 $v$。\n        c. 对于每个邻居 $v$：\n            i.  如果 $v$ 尚未被访问（`visited[v]` 为 `False`），这意味着 $(u, v)$ 是一条树边。进行递归调用 `dfs_check(v, u)` 以继续向图的深处遍历。如果此递归调用返回 `True`（表示在以 $v$ 为根的子树中发现了环），则当前函数立即返回 `True`，将环检测结果向上传递到调用栈。\n            ii. 如果 $v$ 已经被访问（`visited[v]` 为 `True`）且 $v$ 不是 $u$ 的父节点（即 $v \\neq p$），此条件表示找到了一条返祖边。顶点 $v$ 在当前遍历中较早被访问，意味着在DFS树中存在一条从 $v$ 到 $u$ 的路径，而边 $(u, v)$ 闭合了这条路径，形成了一个环。在这种情况下，函数返回 `True`。\n    -   如果遍历完 $u$ 的所有邻居后都没有返回 `True`，则意味着在以 $u$ 为根的子树中没有检测到环。函数随后返回 `False`。\n\n5.  **最终判定**：在从顶点 $0$ 遍历到 $n-1$ 的主循环中，如果任何对 `dfs_check` 的调用返回 `True`，则意味着在图的某处找到了一个环。算法可以立即终止并断定该图不是森林。该测试用例的结果为 `False`。如果主循环完成而没有任何 `dfs_check` 调用返回 `True`，则确认图的所有分量中都不存在环。因此，该图是一个森林，该测试用例的结果为 `True`。\n\n对于任何有限、简单、无向图，此过程都是详尽且正确的。它能正确处理孤立顶点、单个连通分量（树）和多个不连通分量（森林）。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the cycle detection problem for a batch of test cases.\n    \"\"\"\n    \n    # Test suite as defined in the problem statement.\n    test_cases = [\n        # Case 1: n = 5, E = {(0,1),(1,2),(1,3),(3,4)} -> Acyclic (Tree)\n        (5, [(0, 1), (1, 2), (1, 3), (3, 4)]),\n        # Case 2: n = 5, E = {(0,1),(1,2),(2,3),(3,0)} -> Cyclic\n        (5, [(0, 1), (1, 2), (2, 3), (3, 0)]),\n        # Case 3: n = 7, E = {(0,1),(0,2),(2,3),(4,5)} -> Acyclic (Forest)\n        (7, [(0, 1), (0, 2), (2, 3), (4, 5)]),\n        # Case 4: n = 6, E = {(0,1),(1,2),(2,0),(3,4),(4,5)} -> Cyclic (one component)\n        (6, [(0, 1), (1, 2), (2, 0), (3, 4), (4, 5)]),\n        # Case 5: n = 1, E = {} -> Acyclic (Isolated vertex)\n        (1, []),\n        # Case 6: n = 2, E = {(0,1)} -> Acyclic (Single edge)\n        (2, [(0, 1)])\n    ]\n\n    def is_graph_acyclic(n, edges):\n        \"\"\"\n        Determines if a graph with n vertices and a given edge list is acyclic.\n        An empty graph or a graph with no vertices is considered acyclic.\n        \n        Args:\n            n (int): The number of vertices, labeled 0 to n-1.\n            edges (list of tuples): The list of edges in the graph.\n            \n        Returns:\n            bool: True if the graph is a forest (acyclic), False otherwise.\n        \"\"\"\n        if n == 0:\n            return True\n        \n        # 1. Build adjacency list representation of the graph\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n            \n        # 2. Keep track of visited vertices for all DFS traversals\n        visited = [False] * n\n\n        def has_cycle_dfs(u, parent):\n            \"\"\"\n            Recursive DFS function to detect a cycle in a connected component.\n            \n            Args:\n                u (int): The current vertex being visited.\n                parent (int): The parent vertex from which u was discovered.\n            \n            Returns:\n                bool: True if a cycle is detected, False otherwise.\n            \"\"\"\n            visited[u] = True\n            \n            for v in adj[u]:\n                # If neighbor v is not visited yet, recurse on it\n                if not visited[v]:\n                    if has_cycle_dfs(v, u):\n                        return True\n                # If v is visited and is not the parent of u, then there is a cycle\n                elif v != parent:\n                    return True\n            \n            return False\n\n        # 3. Iterate through all vertices to handle disconnected graphs (forests)\n        for i in range(n):\n            if not visited[i]:\n                # If a cycle is found in any component, the whole graph is considered cyclic.\n                # The parent of the starting node of a component's traversal is -1 (a sentinel value).\n                if has_cycle_dfs(i, -1):\n                    return False\n        \n        # 4. If no cycles are found after checking all components, the graph is acyclic.\n        return True\n\n    results = []\n    for n, edges in test_cases:\n        # Acyclic means it's a forest, so the function should return True.\n        # We want to output this boolean directly.\n        is_acyclic = is_graph_acyclic(n, edges)\n        results.append(str(is_acyclic))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3225348"}, {"introduction": "在我们能够检测环路之后，一个自然的进阶问题是衡量这些环路的尺寸。这个练习将向你介绍图的“围长”（girth）这一概念，它定义为图中最短环路的长度。计算围长在网络分析等领域至关重要，因为它能揭示网络中的冗余或效率瓶颈，而这个过程将让你实践如何利用广度优先搜索（BFS）的特性来找到最短环路 [@problem_id:3225402]。", "problem": "您的任务是设计并实现一个完整的、可运行的程序，用以计算一个无向、简单、无权图的围长。图的围长定义为其最短环的长度（边的数量）。如果一个图没有环，其围长定义为 $0$。所有顶点都用从 $0$ 开始的连续整数标记。图由顶点数和无向边列表指定。测试套件中的图都是简单的：它们不包含平行边，也没有自环。\n\n基本定义和事实构成了此任务的基础：\n- 一个无向图 $G$ 是一个对 $G = (V, E)$，其中 $V$ 是顶点集合， $E$ 是无向边集合，每条边是 $V$ 的一个 $2$ 元子集。\n- 路径是顶点的一个序列，其中连续的顶点对由边连接。\n- 环是一个起点和终点相同，且至少包含 $3$ 个不同顶点的路径。\n- 广度优先搜索（BFS）是一种算法，它在无权图中按与所选源顶点的距离（以边的数量计）非递减的顺序探索顶点。\n- 从源顶点 $s$ 到顶点 $u$ 的BFS距离，记作 $d_s(u)$，等于从 $s$ 到 $u$ 的最短路径长度。\n\n从这些核心定义和事实出发，推导出一个计算一般无向简单图围长的算法。程序不得接受输入；相反，它必须嵌入并执行一个预定义的图测试套件，为每个图计算围长，然后以指定的最终输出格式打印结果。\n\n模型和假设：\n- 每个图由顶点数 $n$ 和一个边列表指定，边为有序对 $(i,j)$，表示无向边 $\\{i,j\\}$，其中 $i \\in \\{0,1,\\dots,n-1\\}$ 且 $j \\in \\{0,1,\\dots,n-1\\}$，并且 $i \\neq j$。\n- 所有图都是简单且无向的：没有平行边，没有自环。\n- 围长是所有连通分量中最小的环长度；如果任何分量中都不存在环，则围长为 $0$。\n\n测试套件：\n为以下五个图计算围长。顶点标签是基于 $0$ 的。\n\n- 测试用例 1（多个环；最小的是一个三角形）：\n  - $n = 7$\n  - $E = \\{(0,1),(1,2),(2,0),(2,3),(3,4),(4,5),(5,2),(5,6)\\}$\n  - 预期围长为 $3$。\n- 测试用例 2（无环树）：\n  - $n = 5$\n  - $E = \\{(0,1),(1,2),(2,3),(3,4)\\}$\n  - 预期围长为 $0$。\n- 测试用例 3（单个长度为 $4$ 的环，带有分支）：\n  - $n = 6$\n  - $E = \\{(0,1),(1,2),(2,3),(3,0),(0,4),(2,5)\\}$\n  - 预期围长为 $4$。\n- 测试用例 4（不连通：一个路径分量和一个 $5$ 环分量）：\n  - $n = 8$\n  - $E = \\{(0,1),(1,2),(3,4),(4,5),(5,6),(6,7),(7,3)\\}$\n  - 预期围长为 $5$。\n- 测试用例 5（带有一条尾巴的六边形）：\n  - $n = 7$\n  - $E = \\{(0,1),(1,2),(2,3),(3,4),(4,5),(5,0),(0,6)\\}$\n  - 预期围长为 $6$。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含用方括号括起来的逗号分隔的结果列表，无空格。例如，如果计算出的五个围长是 $3$、$0$、$4$、$5$ 和 $6$，则输出必须是 $[3,0,4,5,6]$。", "solution": "该问题要求推导并实现一个算法，以计算一个简单、无向、无权图 $G=(V, E)$ 的围长，其中 $V$ 是顶点集， $E$ 是边集。围长被定义为图中最小环的长度。如果图不包含环（即，它是一个森林），则其围长定义为 $0$。\n\n在图中寻找环的基本原理是在遍历过程中检测到一条“返祖边”。返祖边是连接一个顶点到其遍历树中祖先（非其直接父节点）的边。用于寻找*最短*环的最合适的遍历算法是广度优先搜索（BFS），因为BFS逐层探索图，保证能找到从源顶点到所有其他顶点的最短路径（以边的数量计）。\n\n让我们将算法形式化。图的围长是其所有连通分量中最小的环长度。因此，我们的算法必须能正确处理连通图和非连通图。我们可以通过遍历图中的每个顶点并发起一次遍历来实现这一点，以确保所有分量都被探索到。总的围长将是在每个分量中找到的最短环长度的最小值。\n\n该算法的核心在于从每个顶点 $s \\in V$ 运行一次独立的BFS。对于从源 $s$ 开始的给定BFS，我们维护从 $s$ 到每个其他顶点 $u$ 的距离 $d_s(u)$，以及BFS树中每个顶点 $u$ 的父节点 $p_s(u)$。\n\n在从 $s$ 开始的BFS过程中，让我们考虑当我们处于顶点 $u$ 并正在探索其相邻顶点时的过程。对于 $u$ 的每个邻居 $v$：\n$1$. 如果 $v$ 在此次BFS中尚未被访问（即 $d_s(v) = \\infty$），我们找到了一个要添加到BFS树中的新顶点。我们设置其距离 $d_s(v) = d_s(u) + 1$ 和其父节点 $p_s(v) = u$。\n$2$. 如果 $v$ 已经被访问过，则检测到了一个环。边 $(u,v)$ 闭合了一个循环。这个循环由三部分组成：从源 $s$ 到 $u$ 的路径、边 $(u,v)$ 以及从 $v$ 回到源 $s$ 的路径。但是，我们必须排除 $v$ 是 $u$ 的直接父节点（即 $v = p_s(u)$）的平凡情况，因为在无向图中，这仅对应于遍历一条边及其反向，这不构成环。因此，当且仅当 $v$ 已被访问且 $v \\neq p_s(u)$ 时，才确认存在一个环。\n\n当找到这样的环时，其长度是 $u$ 和 $v$ 距离源 $s$ 的距离之和，再加上闭合环的边 $(u,v)$ 的长度1。该环的长度 $L$ 由 $L = d_s(u) + d_s(v) + 1$ 给出。\n\n通过从每个顶点 $s \\in V$ 执行一次独立的BFS，并记录在所有这些遍历中发现的最小环长度，我们确保能找到全局最短的环。其原因在于，图中的任何环（比如长度为 $k$）都由顶点组成。当我们从这 $k$ 个顶点中的任何一个开始运行BFS时，该环（或一个更短的环）最终将被检测到。遍历所有可能的起始顶点的过程保证了能找到最短的环。\n\n完整的算法如下：\n$1$. 设顶点数为 $n$，边集为 $E$。使用邻接表表示图。\n$2$. 初始化一个变量用于记录最小环长度，$girth \\leftarrow \\infty$。\n$3$. 对每个顶点 $s$（从 $0$ 到 $n-1$）：\n    a. 从 $s$ 开始发起一次BFS。\n    b. 创建一个大小为 $n$ 的距离数组 $d$，初始化为表示无穷大的哨兵值（例如 $-1$），以及一个大小为 $n$ 的父节点数组 $p$，同样初始化为 $-1$。\n    c. 设置 $d[s] \\leftarrow 0$ 并用 $s$ 初始化一个队列 $Q$。\n    d. 当 $Q$ 不为空时：\n        i. 从队列中取出一个顶点 $u$。\n        ii. 对 $u$ 的每个邻居 $v$：\n            - 如果 $d[v] = -1$（即 $v$ 未被访问）：\n                设置 $d[v] \\leftarrow d[u] + 1$。\n                设置 $p[v] \\leftarrow u$。\n                将 $v$ 入队。\n            - 否则，如果 $v \\neq p[u]$：\n                已找到一个环。计算其长度 $L = d[u] + d[v] + 1$。\n                更新 $girth \\leftarrow \\min(girth, L)$。\n$4$. 外层循环完成后，如果 $girth$ 仍然是 $\\infty$，则图没有环，因此围长为 $0$。否则，围长是 $girth$ 的最终值。\n\n此算法的时间复杂度由从 $n$ 个顶点中的每一个顶点运行一次BFS决定。在具有 $n$ 个顶点和 $m$ 条边的图上进行单次BFS需要 $O(n+m)$ 的时间。因此，总时间复杂度为 $O(n(n+m))$。空间复杂度主要由邻接表决定，为 $O(n+m)$，以及每次BFS运行所需的数据结构（距离和父节点数组、队列），为 $O(n)$，因此总空间复杂度为 $O(n+m)$。对于问题陈述中指定的图，这种方法是可靠且计算上可行的。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import deque\n\ndef solve():\n    \"\"\"\n    Solves the girth computation problem for a predefined test suite of graphs.\n    \"\"\"\n\n    # Test cases defined in the problem statement.\n    # Each case is a tuple: (number_of_vertices, list_of_edges)\n    test_cases = [\n        # Test case 1 (multiple cycles; smallest is a triangle):\n        (7, [(0, 1), (1, 2), (2, 0), (2, 3), (3, 4), (4, 5), (5, 2), (5, 6)]),\n        # Test case 2 (acyclic tree):\n        (5, [(0, 1), (1, 2), (2, 3), (3, 4)]),\n        # Test case 3 (single cycle of length 4 with branches):\n        (6, [(0, 1), (1, 2), (2, 3), (3, 0), (0, 4), (2, 5)]),\n        # Test case 4 (disconnected: one path and one 5-cycle):\n        (8, [(0, 1), (1, 2), (3, 4), (4, 5), (5, 6), (6, 7), (7, 3)]),\n        # Test case 5 (hexagon with a tail):\n        (7, [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (5, 0), (0, 6)]),\n    ]\n\n    results = []\n    for n, edges in test_cases:\n        girth = compute_girth(n, edges)\n        results.append(girth)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef compute_girth(n, edges):\n    \"\"\"\n    Computes the girth of an undirected, simple, unweighted graph.\n\n    The girth is the length of the shortest cycle. If the graph is acyclic,\n    the girth is defined as 0.\n\n    The algorithm iterates through each vertex, treating it as a source for a\n    Breadth-First Search (BFS). During the BFS, if we encounter an already\n    visited vertex that is not the immediate parent of the current vertex,\n    we have found a cycle. The length of this cycle is the sum of the\n    distances of the two adjacent vertices from the source plus one. We keep\n    track of the minimum such length found across all BFS runs.\n\n    Args:\n        n (int): The number of vertices in the graph, labeled 0 to n-1.\n        edges (list of tuples): A list of pairs (u, v) representing\n                               undirected edges.\n\n    Returns:\n        int: The girth of the graph.\n    \"\"\"\n    if n == 0:\n        return 0\n\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    min_cycle_length = float('inf')\n\n    # Run a BFS from each vertex to find the shortest cycle\n    for start_node in range(n):\n        # distance array: dist[i] stores the shortest distance from start_node to i\n        # parent array: parent[i] stores the parent of i in the BFS tree\n        # Using -1 as a sentinel for unvisited nodes\n        dist = np.full(n, -1, dtype=int)\n        parent = np.full(n, -1, dtype=int)\n        \n        q = deque()\n\n        dist[start_node] = 0\n        q.append(start_node)\n\n        while q:\n            current_node = q.popleft()\n\n            for neighbor in adj[current_node]:\n                if dist[neighbor] == -1:\n                    # Neighbor has not been visited\n                    dist[neighbor] = dist[current_node] + 1\n                    parent[neighbor] = current_node\n                    q.append(neighbor)\n                elif neighbor != parent[current_node]:\n                    # Cycle detected. The neighbor has been visited and is not\n                    # the direct parent of the current node in the BFS tree.\n                    cycle_len = dist[current_node] + dist[neighbor] + 1\n                    min_cycle_length = min(min_cycle_length, cycle_len)\n    \n    # If min_cycle_length remains infinity, the graph is acyclic.\n    if min_cycle_length == float('inf'):\n        return 0\n    else:\n        return int(min_cycle_length)\n\n# Execute the solution\nsolve()\n\n```", "id": "3225402"}, {"introduction": "除了识别和测量环路，我们常常需要主动地消除它们以简化网络结构。这个练习将引导你解决一个经典的优化问题：通过移除最少数量的边来打破图中所有的环路，即寻找“最小反馈边集”。这个实践揭示了环路与生成树之间的深刻联系，并要求你运用类似于 Kruskal 算法的逻辑，在构建最大生成森林的同时，识别出那些会形成环路的冗余边 [@problem_id:3225361]。", "problem": "给定一个在有限顶点集 $V$ 和边集 $E$ 上的无向简单图 $G = (V, E)$，环是任意一个由不同顶点组成的序列 $(v_0, v_1, \\dots, v_{k-1})$，其中 $k \\ge 3$，且对于所有 $i \\in \\{0,1,\\dots,k-2\\}$ 都有 $(v_i, v_{i+1}) \\in E$，以及 $(v_{k-1}, v_0) \\in E$。森林是一个无环无向图。反馈边集是一个集合 $F \\subseteq E$，使得从 $G$ 中移除 $F$ 中的边后，得到的图是一个森林。最小反馈边集问题要求找到一个基数最小的集合 $F$，移除该集合中的边后能使图变为无环图。\n\n你的任务是编写一个完整的程序，该程序对下面指定的测试套件中的每个图，根据以下打破平局规则返回一个规范的最小反馈边集。将每个无向边 $(u, v)$ 表示为有序对 $(\\min(u, v), \\max(u, v))$。考虑将所有边按这些有序对的升序字典序排序后得到的边序列。从 $V$ 上的空图开始，从左到右扫描这个已排序的边列表。如果一条边连接了当前部分图的两个不同连通分量，则保留该边；当且仅当它会连接两个已在同一连通分量中的顶点时，该边将被丢弃到反馈边集 $F$ 中。一个图的输出是所有被丢弃的边的列表，按其在扫描过程中遇到的顺序排列。此规则唯一地确定了输出，而无需规定任何特定的内部数据结构。\n\n所有测试图中的顶点都由范围 $\\{0,1,\\dots,n-1\\}$ 内的整数标记，其中 $n = |V|$。边被指定为对 $(u, v)$，其中 $0 \\le u, v  n$ 且 $u \\ne v$。这些图是简单的：没有自环，也没有平行边。\n\n测试套件：\n- 图 $\\mathrm{A}$：$n = 6$, $E = \\{(0,1),(1,2),(2,0),(2,3),(3,4),(4,2),(4,5)\\}$。该图是连通的，并包含共享顶点的多个环。\n- 图 $\\mathrm{B}$：$n = 7$, $E = \\{(0,1),(1,2),(2,0),(3,4),(4,5),(5,6),(3,5)\\}$。该图有两个连通分量，一个是环状的，另一个是路径增加一条边后形成的环。\n- 图 $\\mathrm{C}$：$n = 5$, $E = \\{(0,1),(1,2),(3,4)\\}$。该图已经是一个森林（无环）。\n- 图 $\\mathrm{D}$：$n = 1$, $E = \\varnothing$。该图只有一个顶点且没有边。\n- 图 $\\mathrm{E}$：$n = 4$, $E = \\{(0,1),(0,2),(0,3),(1,2),(1,3),(2,3)\\}$。该图是四顶点的完全图。\n\n要求的最终输出格式：你的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表。每个图的结果本身必须是一个边列表，其中每条边都写成一个双元素列表 $[u,v]$ 的形式，且 $u  v$。输出中不得有空格。例如，一个包含两条边的结果写作 $[[u_1,v_1],[u_2,v_2]]$。对于上述五个图，最终输出应为单行形式 $[R_A,R_B,R_C,R_D,R_E]$，其中 $R_X$ 是为图 $\\mathrm{X}$ 所描述的列表。\n\n答案仅涉及离散结构，不包含物理单位或角度。所有计算出的输出都是整数列表，这些是基本类型。", "solution": "该问题要求计算给定无向图 $G = (V, E)$ 的一个规范的最小反馈边集。反馈边集是边的一个子集 $F \\subseteq E$，从 $G$ 中移除该子集中的边会得到一个无环图（森林）。最小反馈边集是具有最小可能基数的此类集合。问题指定了一个确定性算法来找到这样一个集合，该算法也用于解决在选择具体边时可能出现的任何歧义。\n\n指定算法所依据的核心原则与用于寻找最大生成森林的 Kruskal 算法相同。一个图的生成森林是一个子图，它本身是森林，不被任何更大的无环子图所包含，并且跨越原图的所有顶点。最大生成森林是包含最大可能边数的生成森林。图中不属于给定最大生成森林的边集构成了一个最小反馈边集。对于一个有 $n = |V|$ 个顶点和 $c$ 个连通分量的图，任何生成森林的边数都固定为 $n - c$。因此，最小反馈边集的大小为 $|E| - (n - c)$。\n\n指定的算法通过迭代添加边来构建一个最大生成森林，并收集所有不属于该森林的边。这些被收集的边正是那些添加后会产生环的边。\n\n算法流程如下：\n$1$. **初始化**：从一个包含所有 $n$ 个顶点但没有边的图开始。这是一个每个顶点都构成其自身连通分量的森林。初始化一个不相交集并（DSU）或称并查集的数据结构来管理这些分量。最初，有 $n$ 个不相交集，每个顶点 $v \\in \\{0, 1, \\dots, n-1\\}$ 一个。创建一个空列表 $F$ 来存储反馈集中的边。\n\n$2$. **边的规范化与排序**：边集 $E$ 中的每个无向边 $\\{u, v\\}$ 都由一个唯一的、规范的有序对 $(\\min(u, v), \\max(u, v))$ 表示。然后将这些规范化边对的整个列表按升序字典序排序。此步骤确保过程是确定性的。\n\n$3$. **迭代构建**：算法遍历已排序的边列表。对于每条边 $(u, v)$：\n    - 检查顶点 $u$ 和 $v$ 是否已属于同一个连通分量。这个检查通过 DSU 数据结构的 `find` 操作高效执行，该操作为每个分量返回一个唯一的代表元。\n    - 如果 `find(u)` 不等于 `find(v)`，则顶点位于不同的分量中。边 $(u, v)$ 连接这两个分量而不会产生环。因此，它是最大生成森林的一条边。通过 DSU 的 `union(u, v)` 操作合并这两个分量，从而将该边添加到森林中。\n    - 如果 `find(u)` 等于 `find(v)`，则顶点已在同一个分量内连通。添加边 $(u, v)$ 会引入一个环。因此，这条边必须属于反馈集。该边的规范表示 $(\\min(u, v), \\max(u, v))$ 被附加到列表 $F$ 中。\n\n$4$. **终止**：处理完 $E$ 中的所有边后，列表 $F$ 包含了最小反馈边集。$F$ 中边的顺序由排序后的迭代顺序决定。最终构建的森林是原始图 $G$ 的一个最大生成森林。\n\n该方法的效率主要由边的排序步骤（耗时 $O(|E| \\log |E|)$）和 DSU 操作决定。通过使用路径压缩和按大小/秩合并进行优化的 DSU 实现，所有 DSU 操作的总时间在平均情况下接近常数，具体为 $O(|E| \\cdot \\alpha(|V|))$，其中 $\\alpha$ 是增长极其缓慢的反阿克曼函数。因此，总体时间复杂度由排序主导，为 $O(|E| \\log |E|)$。\n\n例如，考虑图 A，其中 $n=6$ 且 $E = \\{(0,1),(1,2),(2,0),(2,3),(3,4),(4,2),(4,5)\\}$。\n规范化的边为 $(0,1), (1,2), (0,2), (2,3), (3,4), (2,4), (4,5)$。\n排序后的边列表为 $S = [(0,1), (0,2), (1,2), (2,3), (2,4), (3,4), (4,5)]$。\nDSU 初始化为集合 $\\{0\\}, \\{1\\}, \\{2\\}, \\{3\\}, \\{4\\}, \\{5\\}$。反馈边集 $F$ 为空。\n- 处理 $(0,1)$: `find(0) \\neq find(1)`。合并 0 和 1 的分量。\n- 处理 $(0,2)$: `find(0) \\neq find(2)`。合并 0 和 2 的分量。{0,1,2} 的分量现已合并。\n- 处理 $(1,2)$: `find(1) = find(2)`。顶点 1 和 2 已连通。将 $[1,2]$ 添加到 $F$。\n- 处理 $(2,3)$: `find(2) \\neq find(3)`。合并分量。{0,1,2,3} 的分量现已合并。\n- 处理 $(2,4)$: `find(2) \\neq find(4)`。合并分量。{0,1,2,3,4} 的分量现已合并。\n- 处理 $(3,4)$: `find(3) = find(4)`。顶点 3 和 4 已连通。将 $[3,4]$ 添加到 $F$。\n- 处理 $(4,5)$: `find(4) \\neq find(5)`。合并分量。所有顶点现均在一个分量中。\n图 A 的最终反馈边集为 $F = [[1,2],[3,4]]$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the minimum feedback edge set problem for a suite of test graphs.\n    \"\"\"\n\n    class DSU:\n        \"\"\"\n        A Disjoint Set Union (DSU) data structure, also known as Union-Find,\n        optimized with path compression and union by size.\n        \"\"\"\n        def __init__(self, n):\n            \"\"\"\n            Initializes the DSU for n elements, where each element is in its\n            own set.\n            Args:\n                n (int): The number of elements.\n            \"\"\"\n            self.parent = list(range(n))\n            self.size = [1] * n\n\n        def find(self, i):\n            \"\"\"\n            Finds the representative of the set containing element i, with path\n            compression.\n            Args:\n                i (int): The element to find.\n            Returns:\n                int: The representative of the set.\n            \"\"\"\n            if self.parent[i] == i:\n                return i\n            self.parent[i] = self.find(self.parent[i])\n            return self.parent[i]\n\n        def union(self, i, j):\n            \"\"\"\n            Merges the sets containing elements i and j, using union by size.\n            Args:\n                i (int): An element in the first set.\n                j (int): An element in the second set.\n            Returns:\n                bool: True if the sets were merged, False if they were already\n                      in the same set.\n            \"\"\"\n            root_i = self.find(i)\n            root_j = self.find(j)\n            if root_i != root_j:\n                # Union by size: attach smaller tree under root of larger tree\n                if self.size[root_i]  self.size[root_j]:\n                    root_i, root_j = root_j, root_i\n                self.parent[root_j] = root_i\n                self.size[root_i] += self.size[root_j]\n                return True\n            return False\n\n    def find_minimum_feedback_edge_set(n, edges):\n        \"\"\"\n        Finds a canonical minimum feedback edge set for a graph using the\n        prescribed algorithm based on Kruskal's MST method.\n\n        Args:\n            n (int): The number of vertices in the graph.\n            edges (list of tuples): The list of edges in the graph.\n\n        Returns:\n            list of lists: The list of edges in the feedback set, ordered\n                           as they were identified.\n        \"\"\"\n        if n == 0 or not edges:\n            return []\n\n        # 1. Canonicalize edges to (min(u,v), max(u,v)) and sort them.\n        canonical_edges = sorted([(min(u, v), max(u, v)) for u, v in edges])\n        \n        dsu = DSU(n)\n        feedback_edges = []\n        \n        # 2. Iterate through sorted edges, building a maximum spanning forest.\n        for u, v in canonical_edges:\n            # 3. If an edge connects two vertices already in the same component,\n            # it forms a cycle and belongs to the feedback set.\n            if not dsu.union(u, v):\n                feedback_edges.append([u, v])\n                \n        return feedback_edges\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Graph A\n        (6, [(0,1),(1,2),(2,0),(2,3),(3,4),(4,2),(4,5)]),\n        # Graph B\n        (7, [(0,1),(1,2),(2,0),(3,4),(4,5),(5,6),(3,5)]),\n        # Graph C\n        (5, [(0,1),(1,2),(3,4)]),\n        # Graph D\n        (1, []),\n        # Graph E (K4)\n        (4, [(0,1),(0,2),(0,3),(1,2),(1,3),(2,3)]),\n    ]\n\n    results = []\n    for n, edges in test_cases:\n        result = find_minimum_feedback_edge_set(n, edges)\n        results.append(result)\n\n    # Format the final output string according to the exact problem specification.\n    # The str() conversion might add spaces, so we remove them.\n    results_as_strings = [str(r).replace(\" \", \"\") for r in results]\n    final_output = f\"[{','.join(results_as_strings)}]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "3225361"}]}