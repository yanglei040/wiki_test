{"hands_on_practices": [{"introduction": "本练习要求你计算网格中所有不重复的简单路径数量，这类似于寻找迷宫中所有可能的路线。这是对回溯法的一个绝佳介绍，该技术利用深度优先搜索（DFS）系统性地探索所有潜在解。通过实现这个算法，你将亲身体验如何使用递归和状态管理来驾驭一个复杂的搜索空间。[@problem_id:3227616]", "problem": "给定一个可能包含障碍物的有限矩形网格。将此网格建模为一个无向图 $G = (V, E)$，其中 $V$ 是所有非障碍物网格单元的集合，$E$ 包含连接两个单元的无向边，当且仅当这两个单元水平或垂直相邻且均非障碍物。设网格有 $m$ 行和 $n$ 列，行索引在 $\\{0, 1, \\dots, m-1\\}$ 中，列索引在 $\\{0, 1, \\dots, n-1\\}$ 中。起始顶点为 $s = (0, 0)$（左上角），目标顶点为 $t = (m-1, n-1)$（右下角）。路径是一个顶点序列 $(v_0, v_1, \\dots, v_k)$，其中 $v_0 = s$，$v_k = t$，并且每个连续顶点对 $(v_i, v_{i+1})$ 都是 $E$ 中的一条边。如果一条路径不重复访问任何顶点，则称其为简单路径。\n\n任务：运用图论和深度优先搜索的基本原理，设计并实现一个程序，计算在每个指定的测试网格中，从 $s$到 $t$ 的不同简单路径的总数。该算法必须在由网格定义的底层图上使用深度优先搜索（DFS）和回溯法；当且仅当两条路径的顶点序列在任何位置上不同时，它们才被视为不同的路径。\n\n您可以无需证明地假设以下基本知识：图 $G = (V, E)$ 的定义，图中路径和简单路径的定义，以及深度优先搜索程序的存在性——该程序通过沿边递归和在无法继续前进时回溯来系统地探索相邻顶点。\n\n边界约定：\n- 如果 $s \\notin V$ 或 $t \\notin V$（即起始点或目标点是障碍物），则简单路径的数量为 $0$。\n- 如果 $s = t \\in V$（即网格为 $m = 1$ 且 $n = 1$，且 $(0,0)$ 处没有障碍物），则简单路径的数量为 $1$（即从 $s$ 开始并结束于 $s$ 的长度为 $0$ 的空路径）。\n\n移动规则：在每一步中，您可以从一个单元格移动到其四个轴对齐的邻居（上、下、左、右）之一，前提是该邻居在边界内且不是障碍物。不允许对角线移动。\n\n您的程序不得读取任何输入。相反，它必须在以下固定的测试集上执行并产生所需的输出。\n\n参数值测试集：\n- 测试 $1$：$m = 2$，$n = 2$，障碍物集合 $\\mathcal{O} = \\varnothing$。\n- 测试 $2$：$m = 3$，$n = 3$，障碍物集合 $\\mathcal{O} = \\varnothing$。\n- 测试 $3$：$m = 3$，$n = 3$，障碍物集合 $\\mathcal{O} = \\{(1,1)\\}$。\n- 测试 $4$：$m = 1$，$n = 1$，障碍物集合 $\\mathcal{O} = \\varnothing$。\n- 测试 $5$：$m = 2$，$n = 3$，障碍物集合 $\\mathcal{O} = \\varnothing$。\n- 测试 $6$：$m = 2$，$n = 2$，障碍物集合 $\\mathcal{O} = \\{(1,1)\\}$。\n\n所需输出：您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，结果顺序与上述测试顺序相同。每个结果必须是一个整数，表示该测试的简单路径计数。例如，格式为 $[r_1,r_2,r_3,r_4,r_5,r_6]$，其中 $r_i$ 是测试 $i$ 的整数结果。此问题不涉及任何物理单位。所有角度单位均不相关。百分比不适用。最终输出必须是指定格式的唯一一行。", "solution": "该问题要求计算在一个可能包含障碍物的矩形网格上，从起始单元格 $s$ 到目标单元格 $t$ 的不同简单路径的数量。简单路径是指不重复访问任何单元格的路径。这个问题可以使用图论进行建模，并利用基于深度优先搜索（DFS）的递归回溯算法来解决。\n\n首先，我们将网格形式化为一个图。设网格有 $m$ 行和 $n$ 列。一个单元格由其坐标 $(r, c)$ 表示，其中 $r \\in \\{0, 1, \\dots, m-1\\}$ 且 $c \\in \\{0, 1, \\dots, n-1\\}$。我们构建一个无向图 $G = (V, E)$。顶点集合 $V$ 由所有非障碍物的单元格 $(r, c)$ 组成。两个顶点 $v_1 = (r_1, c_1)$ 和 $v_2 = (r_2, c_2)$ 之间存在无向边，当且仅当它们在网格上相邻且都属于 $V$。相邻定义为曼哈顿距离为 $1$，即 $|r_1 - r_2| + |c_1 - c_2| = 1$。起始顶点为 $s=(0,0)$，目标顶点为 $t=(m-1, n-1)$。\n\n目标是找到从 $s$ 到 $t$ 的简单路径的总数。路径是一个顶点序列 $(v_0, v_1, \\dots, v_k)$，其中 $v_0=s$，$v_k=t$，并且对于所有 $i \\in \\{0, \\dots, k-1\\}$，$(v_i, v_{i+1})$ 都是 $E$ 中的一条边。如果序列中所有的 $v_i$ 都不同，则该路径是简单的。\n\n计算简单路径的问题通常是 #P-完备的，但对于指定的这些小規模网格，穷举搜索是可行的。所需的算法是带回溯的深度优先搜索，这天然适合枚举所有此类路径。\n\n我们设计一个递归函数，称之为 $f(u)$，它计算从当前顶点 $u$到目标顶点 $t$ 的简单路径数量，其中假设当前路径上的一组顶点已经被访问过。搜索的状态需要跟踪当前位置和到目前为止所走的路径，以避免循环并确保路径的简单性。\n\n设 $P$ 是当前从 $s$ 到 $u$ 的前驱节点的路径上已访问的顶点集合。该函数可以定义为 $f(u, P)$。\n\n1.  **基本情况：** 如果当前顶点 $u$ 是目标顶点 $t$，我们已经找到一条完整的简单路径。因此，函数应返回 $1$。\n    $$ f(t, P) = 1 $$\n\n2.  **递归步骤：** 如果 $u \\neq t$，我们必须探索它的邻居。设 $\\mathcal{N}(u)$ 为图 $G$ 中 $u$ 的邻居集合。从 $u$ 出发的任何简单路径的下一个顶点必须是 $u$ 的一个尚未访问过的邻居。可用邻居的集合是 $\\mathcal{N}(u) \\setminus P$。从 $u$ 出发的简单路径总数是从每个可用邻居出发的简单路径数量之和。用于递归调用的新已访问顶点集合将是 $P \\cup \\{u\\}$。\n    $$ f(u, P) = \\sum_{v \\in \\mathcal{N}(u) \\setminus P} f(v, P \\cup \\{u\\}) $$\n\n在实现中，每次递归调用时按值传递已访问节点集合 $P$ 可能效率低下。一种更常见且高效的技术是使用一个单一的有状态的 `visited` 集合来跟踪当前正在构建的路径上的顶点。递归函数在遍历图时修改这个集合。这就是回溯的本质。\n\n算法流程如下：\n设 `count_paths(u)` 为递归函数。一个集合 `visited_nodes` 在递归外部维护或通过引用传递。\n\n-   **初始化：** 在开始搜索之前，处理边界条件。如果 $s$ 或 $t$ 是障碍物（即 $s \\notin V$ 或 $t \\notin V$），则不可能有路径，计数为 $0$。如果 $s=t$ 且 $s \\in V$（一个 $1 \\times 1$ 的无障碍物网格），计数为 $1$。主算法通过调用 `count_paths(s)` 来启动，此时 `visited_nodes` 初始为空。\n\n-   **递归函数 `count_paths(u)`：**\n    1.  如果 $u = t$，则找到了一条路径。返回 $1$。\n    2.  将 $u$ 添加到 `visited_nodes`。\n    3.  初始化局部变量 `path_count = 0`。\n    4.  对于 $u$ 的每个邻居 $v$：\n        a. 检查 $v$ 是否在网格边界内。\n        b. 检查 $v$ 是否是障碍物。\n        c. 检查 $v$ 是否在 `visited_nodes` 中。\n        d. 如果 $v$ 是一个有效的、未访问的、非障碍物的邻居，则将递归调用 `count_paths(v)` 的结果加到 `path_count` 上。\n    5.  从 `visited_nodes` 中移除 $u$。这是关键的回溯步骤。通过“取消访问” $u$，我们允许它成为后续搜索中找到的其他路径的一部分。例如，一条从 $s$ 出发的路径可能会经过某个顶点 $w$，然后探索一个通向 $u$ 的分支。\n    6.  返回 `path_count`。\n\n最终结果是初始调用 `count_paths(s)` 返回的值。该算法系统地探索了从 $s$ 到 $t$ 的每一条可能的简单路径，对它们进行计数，并返回总数。对于每个测试用例，我们都将此过程应用于指定的网格尺寸和障碍物集合。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\n\ndef solve():\n    \"\"\"\n    Solves the simple path counting problem for a fixed test suite.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Each tuple is (m, n, obstacles), where obstacles is a frozenset of (row, col) tuples.\n    test_cases = [\n        (2, 2, frozenset()),\n        (3, 3, frozenset()),\n        (3, 3, frozenset([(1, 1)])),\n        (1, 1, frozenset()),\n        (2, 3, frozenset()),\n        (2, 2, frozenset([(1, 1)]))\n    ]\n\n    results = []\n    for m, n, obstacles in test_cases:\n        start_node = (0, 0)\n        target_node = (m - 1, n - 1)\n\n        # Handle boundary conditions as per the problem statement.\n        if start_node in obstacles or target_node in obstacles:\n            results.append(0)\n            continue\n\n        # This set will store visited nodes for the current path being explored.\n        visited_nodes = set()\n\n        def dfs_count_paths(r, c):\n            \"\"\"\n            Recursively counts simple paths from (r, c) to target_node using DFS and backtracking.\n            - m, n, obstacles, target_node, and visited_nodes are available from the closure.\n            \"\"\"\n            # Base case: if the current node is the target, we have found one valid path.\n            if (r, c) == target_node:\n                return 1\n\n            # Mark the current node as visited for the current path.\n            visited_nodes.add((r, c))\n            \n            path_count = 0\n            \n            # Explore neighbors: down, right, up, left.\n            # Order does not matter for the total count.\n            for dr, dc in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n                nr, nc = r + dr, c + dc\n\n                # Check if the neighbor is valid.\n                # 1. Is it within the grid boundaries?\n                if not (0 = nr  m and 0 = nc  n):\n                    continue\n                \n                # 2. Has it been visited in the current path?\n                if (nr, nc) in visited_nodes:\n                    continue\n\n                # 3. Is it an obstacle?\n                if (nr, nc) in obstacles:\n                    continue\n\n                # If the neighbor is valid, recurse.\n                path_count += dfs_count_paths(nr, nc)\n\n            # Backtracking step: remove the current node from the visited set\n            # so it can be part of other paths.\n            visited_nodes.remove((r, c))\n            \n            return path_count\n\n        # Start the recursive search from the start node.\n        total_paths = dfs_count_paths(start_node[0], start_node[1])\n        results.append(total_paths)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3227616"}, {"introduction": "一个网络能否被划分为两个组，使得所有连接都发生在组与组之间，而从不发生在组内？这个被称为“二分性”的属性在许多现实应用中至关重要，本练习将向你展示如何检测它。你将修改深度优先搜索算法，对图进行“双色着色”，并发现着色冲突恰好揭示了奇数长度环的存在——这是图非二分性的明确标志。[@problem_id:3227650]", "problem": "考虑一个模拟电路布局的无向有限图，其中顶点表示连接点，边表示直接连接。如果可以为每个顶点分配两种颜色中的一种，使得没有边连接相同颜色的顶点，则称该电路布局是 $2$-可着色的。在图论术语中，这等价于该图是二分图。你的任务是推导、实现并应用一种基于深度优先搜索（DFS）的方法，来判断一组无向图的二分性。\n\n从以下基础出发：无向图的定义为顶点集 $V$ 和边集 $E$ 组成的对 $(V, E)$；路径是顶点的序列，其中连续的顶点对都在 $E$ 中；环是至少有三个顶点的闭合路径，且所有顶点（除了第一个和最后一个）都不同；路径或环的长度的奇偶性以边的数量来衡量。将图的 $2$-着色定义为一个函数 $c: V \\to \\{0,1\\}$，使得对于每条边 $\\{u,v\\} \\in E$，都有 $c(u) \\neq c(v)$。使用深度优先搜索（DFS）来探索图并尝试构建这样的着色，并判断是否出现冲突。在问题陈述中，不允许使用超出这些核心定义的中间算法。\n\n你的程序必须是自包含的，并且不能读取任何输入。它必须编码以下无向图测试套件，每个图用邻接表表示。邻接表是一个列表的有序列表；第 $i$ 个内部列表枚举了顶点 $i$ 的邻居。对于一个有 $n$ 个顶点的图，所有顶点都用从 $0$ 到 $n-1$ 的连续整数标记。将每个邻接表对称地解释为一个无向图。\n\n测试套件：\n- 案例 1（偶数环，二分图）：$n=6$，邻接表 $[[1,5],[0,2],[1,3],[2,4],[3,5],[4,0]]$。\n- 案例 2（奇数环，非二分图）：$n=3$，邻接表 $[[1,2],[0,2],[0,1]]$。\n- 案例 3（空图，空泛地为二分图）：$n=0$，邻接表 $[]$。\n- 案例 4（单个顶点，二分图）：$n=1$，邻接表 $[[]]$。\n- 案例 5（不连通，包含一个奇数环，非二分图）：$n=6$，邻接表 $[[1],[0,2],[1],[4,5],[3,5],[3,4]]$。\n- 案例 6（有平行边，但为二分图）：$n=2$，邻接表 $[[1,1],[0,0]]$。\n- 案例 7（有自环，非二分图）：$n=1$，邻接表 $[[0]]$。\n\n设计要求：\n- 使用深度优先搜索（DFS）尝试沿发现边为顶点分配颜色 $0$ 和 $1$，每一步交替颜色。如果一个邻居的颜色与当前顶点的颜色相同，则报告该图不是二分图；否则，继续。通过从每个未着色的顶点开始DFS来处理不连通图。\n- 自环是直接的违规，因为边 $\\{v,v\\}$ 强制要求 $c(v) \\neq c(v)$，这是不可能的。\n- 两个顶点之间的多条边不改变二分性；但是，你的DFS必须对邻接表中的此类重复具有鲁棒性。\n- 时间复杂度和空间复杂度必须与图的大小呈线性关系，即 $O(|V|+|E|)$ 的时间和 $O(|V|)$ 的空间。\n\n最终输出格式：\n你的程序应该生成一行输出，其中包含七个案例的结果，格式为方括号括起来的逗号分隔列表，每个结果是一个布尔值，表示相应的图是否是二分图（true表示是二分图，false表示不是二分图），例如 $[r_1,r_2,\\dots,r_7]$，其中每个 $r_i$ 是标准编程语言布尔表示法中的 $\\mathrm{True}$ 或 $\\mathrm{False}$。不应打印任何其他文本。", "solution": "该问题要求一种基于深度优先搜索（DFS）的算法方法，来判断给定的无向图是否为二分图。一个图是二分图，当且仅当它是 $2$-可着色的。\n\n**理论基础**\n\n一个无向图 $G = (V, E)$（其中 $V$ 是顶点集，$E$ 是边集）被定义为二分图，如果其顶点集 $V$ 可以被划分为两个不相交且独立的集合 $V_0$ 和 $V_1$，使得 $E$ 中的每条边都连接 $V_0$ 中的一个顶点和 $V_1$ 中的一个顶点。一个等价的表述是存在一个 $2$-着色函数 $c: V \\to \\{0, 1\\}$，使得对于每条边 $\\{u,v\\} \\in E$，条件 $c(u) \\neq c(v)$ 都成立。\n\n图论中的一个基本定理指出：一个图是二分图，当且仅当它不包含奇数长度的环。环是长度至少为一的路径，其起点和终点是同一个顶点。环的长度是它包含的边的数量。一个自环，即形如 $\\{v,v\\}$ 的边，构成一个长度为 $1$ 的环，这是奇数。因此，任何有自环的图都不是二分图。\n\n**算法策略：通过深度优先搜索进行 $2$-着色**\n\n我们可以通过使用深度优先搜索（DFS）尝试构建一个有效的 $2$-着色来判断一个图是否是二分图。该算法过程如下：\n\n1.  **初始化**：我们维护一个大小为 $|V|$ 的颜色数组 `colors`，其中 `colors[i]` 存储分配给顶点 $i$ 的颜色。我们用一个特殊值（例如 $-1$）初始化该数组，以表示还没有顶点被着色。\n\n2.  **处理不连通分量**：一个图可能由多个不相交的连通分量组成。整个图的二分性取决于每个独立分量的二分性。因此，我们遍历从 $v=0$ 到 $|V|-1$ 的所有顶点。如果一个顶点 $v$ 尚未被着色（即 `colors[v]` 是 $-1$），它属于一个新的、未被探索的分量。我们从这个顶点 $v$ 开始进行DFS遍历，并为其分配一个初始颜色，比如 $0$。\n\n3.  **DFS遍历与着色**：DFS过程（可以递归实现）执行着色和冲突检测：\n    - 当访问一个已分配颜色 $c(u)$ 的顶点 $u$ 时，我们遍历其邻接表中的所有邻居 $w$。\n    - **情况A：邻居未着色**。如果一个邻居 $w$ 尚未被着色（即 `colors[w]` 是 $-1$），我们给它分配与 $u$ 相反的颜色，即 $c(w) = 1 - c(u)$。然后我们对 $w$ 递归调用DFS。如果这个递归调用在其子树中检测到冲突，该冲突将被传回，我们便得出结论：该图不是二分图。\n    - **情况B：邻居已着色**。如果一个邻居 $w$ 已经被着色，我们必须检查是否存在冲突。如果 $w$ 的颜色与 $u$ 相同，即 $c(w) = c(u)$，则产生冲突。这一发现意味着存在一条连接两个相同颜色顶点的边，这违反了 $2$-着色的条件。这种情况对应于在图中发现了一个奇数长度的环。从该连通分量的起始顶点到 $u$ 的路径，以及从同一起始顶点到 $w$ 的路径，再加上边 $\\{u,w\\}$，就形成了一个环。如果 $u$ 和 $w$ 的颜色相同，它们距离起始顶点（以边数计）的奇偶性也相同。环的长度是这两条路径长度之和再加一。`(偶数 + 偶数 + 1)` 或 `(奇数 + 奇数 + 1)` 的结果都是奇数。因此，颜色冲突标志着一个奇数环的存在。\n\n4.  **终止**：如果一个分量的DFS遍历完成而没有任何颜色冲突，则该分量是二分图。然后主循环继续寻找其他未着色的分量。如果处理完整个顶点集并且从未发现冲突，则整个图是二分图。如果在任何时候发现冲突，算法可以立即终止并报告该图不是二分图。\n\n**复杂度分析**\n-   **时间复杂度**：每个顶点作为DFS调用的根（对于每个分量）被访问和处理一次。在邻接表表示中，每条边 $\\{u, v\\}$ 被检查两次（一次在 $u$ 的列表中，一次在 $v$ 的列表中）。每个顶点和每条边所做的工作是常数级的。因此，总时间复杂度与图的大小呈线性关系，即 $O(|V| + |E|)$。\n-   **空间复杂度**：主要的空间需求是 `colors` 数组，其大小为 $|V|$。此外，在最坏情况（路径图）下，DFS的递归堆栈深度最多可达 $|V|$。因此，空间复杂度为 $O(|V|)$。\n\n这种基于DFS的方法正确地满足了问题要求，包括对不连通图、自环（会立即产生冲突：$c(v)=c(v)$ 为假）以及平行边（它们是冗余检查，不会改变结果）的鲁棒性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\n\ndef solve():\n    \"\"\"\n    Solves the bipartite checking problem for a suite of test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case 1: n=6, even cycle, bipartite\n        (6, [[1, 5], [0, 2], [1, 3], [2, 4], [3, 5], [4, 0]]),\n        # Case 2: n=3, odd cycle, not bipartite\n        (3, [[1, 2], [0, 2], [0, 1]]),\n        # Case 3: n=0, empty graph, vacuously bipartite\n        (0, []),\n        # Case 4: n=1, single vertex, bipartite\n        (1, [[]]),\n        # Case 5: n=6, disconnected with odd cycle, not bipartite\n        (6, [[1], [0, 2], [1], [4, 5], [3, 5], [3, 4]]),\n        # Case 6: n=2, parallel edges, bipartite\n        (2, [[1, 1], [0, 0]]),\n        # Case 7: n=1, self-loop, not bipartite\n        (1, [[0]]),\n    ]\n\n    results = []\n    for n, adj in test_cases:\n        results.append(is_bipartite(n, adj))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef is_bipartite(n, adj):\n    \"\"\"\n    Checks if a graph is bipartite using DFS-based 2-coloring.\n\n    Args:\n        n (int): The number of vertices, |V|.\n        adj (list of list of int): The adjacency list of the graph.\n\n    Returns:\n        bool: True if the graph is bipartite, False otherwise.\n    \"\"\"\n    if n == 0:\n        return True\n\n    # colors[i] = -1: uncolored, 0: color 0, 1: color 1\n    colors = [-1] * n\n\n    def dfs(u, color):\n        \"\"\"\n        Recursive DFS to perform 2-coloring.\n\n        Args:\n            u (int): The current vertex.\n            color (int): The color to assign to the current vertex (0 or 1).\n\n        Returns:\n            bool: True if the component is bipartite, False if a conflict is found.\n        \"\"\"\n        colors[u] = color\n        for v in adj[u]:\n            if colors[v] == -1:\n                # If neighbor is uncolored, color with the opposite color\n                # and recurse. If recursion finds a conflict, propagate False.\n                if not dfs(v, 1 - color):\n                    return False\n            elif colors[v] == colors[u]:\n                # If neighbor has the same color, an odd cycle is found.\n                return False\n        return True\n\n    # Iterate through all vertices to handle disconnected graphs\n    for i in range(n):\n        if colors[i] == -1:\n            # If a component is not bipartite, the whole graph is not.\n            if not dfs(i, 0):\n                return False\n\n    return True\n\nsolve()\n```", "id": "3227650"}, {"introduction": "在网络中寻找最长路径对于项目管理中的关键路径分析等任务至关重要。虽然这个问题在一般图中很难解决，但在有向无环图（DAG）中却有优雅的解法。本练习将展示深度优先搜索与动态规划的强大结合，其中 DFS 的后序遍历特性使你能够以完美的顺序解决子问题，从而构建出最终的解。[@problem_id:3227722]", "problem": "给定一个带有非负整数边权的有向无环图（DAG）。你的任务有两部分：首先，仅从深度优先搜索（DFS）和有向无环图（DAG）的核心定义出发，推导出一个正确的 DFS 修改算法，该算法用于计算任意 DAG 中最长路径的长度。你的推导必须基于图论的基本定义，确定一个递归或循环不变量，并利用 DAG 的结构特性和 DFS 导出的顺序来证明其终止性和正确性。其次，将你推导出的方法应用于下面的具体 DAG，并计算最长路径的长度。最终答案必须是一个实数值，等于图中任意有向路径的最大总权重。\n\n顶点集是 $\\{1,2,3,4,5,6,7,8,9\\}$，并且每条边的方向都是从标签较小的顶点指向标签较大的顶点。每条有向边都标有一个非负整数权重。这些边是：\n- $(1 \\to 2,\\, 3)$, $(1 \\to 3,\\, 2)$, $(1 \\to 4,\\, 5)$\n- $(2 \\to 5,\\, 4)$, $(2 \\to 6,\\, 6)$\n- $(3 \\to 4,\\, 1)$, $(3 \\to 6,\\, 2)$, $(3 \\to 7,\\, 7)$\n- $(4 \\to 6,\\, 1)$, $(4 \\to 7,\\, 4)$, $(4 \\to 8,\\, 2)$\n- $(5 \\to 7,\\, 3)$, $(5 \\to 8,\\, 5)$\n- $(6 \\to 8,\\, 4)$, $(6 \\to 9,\\, 3)$\n- $(7 \\to 8,\\, 1)$, $(7 \\to 9,\\, 8)$\n- $(8 \\to 9,\\, 2)$\n\n假设路径的长度是其有向边权重之和。如果一个顶点没有出边，那么从该顶点开始的最长路径长度为 $0$。请用一个数字表示你的最终答案。无需四舍五入。", "solution": "该问题要求推导一个算法来寻找有向无环图（DAG）中最长路径的长度，该算法基于深度优先搜索（DFS），然后将此算法应用于一个具体的图。\n\n**第一部分：算法推导**\n\n设 $G = (V, E)$ 是一个有向无环图（DAG），其中 $V$ 是顶点集， $E$ 是有向边集。设 $w(u, v)$ 是边 $(u, v) \\in E$ 的非负整数权重。路径的长度是其边权重之和。只有一个顶点的路径长度为 $0$。\n\n我们的目标是找到 $G$ 中最长路径的长度。我们定义 $L(u)$ 为从顶点 $u \\in V$ 开始的最长路径的长度。那么整个图中最长路径的长度就是 $\\max_{u \\in V} L(u)$。\n\n从 $u$ 开始的路径的一个基本属性是，它必须以一条边 $(u, v)$ 开始，通向它的一个邻居 $v$，然后是一条从 $v$ 开始的路径。为了最大化从 $u$ 开始的路径长度，我们必须选择一个邻居 $v$，使得边权 $w(u, v)$ 与从 $v$ 开始的最长路径长度 $L(v)$ 之和最大。这为 $L(u)$ 导出了一个递归定义：\n\n1.  如果一个顶点 $u$ 没有出边（即它是一个终端顶点或汇点），任何从 $u$ 开始的路径仅包含顶点 $u$ 本身。这种路径的长度定义为 $0$。因此，对于终端顶点 $u$，$L(u) = 0$。这构成了我们递归的基础情况。\n2.  如果一个顶点 $u$ 有出边，那么从 $u$ 开始的最长路径可以通过考虑其所有邻居来找到。对于每个邻居 $v$，以边 $(u,v)$ 开始的路径的最大长度为 $w(u,v) + L(v)$。我们必须选择使这个值最大化的邻居 $v$。因此，\n    $$L(u) = \\max_{(u,v) \\in E} \\{ w(u,v) + L(v) \\}$$\n\n这个递推关系表明，要计算 $L(u)$，我们需要 $u$ 的所有后继节点 $v$ 的 $L(v)$ 值。DAG 的无环性质在此至关重要。因为没有环，所以 $L(u)$ 的计算永远不会直接或间接地通过一串后继节点依赖于其自身。\n\n我们可以使用深度优先搜索（DFS）的修改版来解决这个递推系统。标准的递归 DFS 通过访问一个顶点，然后对其所有未访问的邻居进行递归调用来探索图。当一个递归调用 `DFS(v)` 返回到其调用者 `DFS(u)` 时，意味着对从 $v$ 可达的整个子图的遍历已经完成。在执行过程中，当一个顶点的所有子节点的递归调用都结束后，这个时间点被称为后序处理步骤。\n\n在 DAG 的 DFS 遍历中，按完成时间对顶点进行排序会得到一个逆拓扑排序。这意味着对于任何边 $(u,v) \\in E$，$v$ 的完成时间都小于 $u$ 的完成时间。因此，如果我们在对 $u$ 的 DFS 遍历的后序处理步骤中计算 $L(u)$，我们可以保证它的所有后继节点 $v$ 的 $L(v)$ 值都已经被计算出来了。\n\n这就得到了以下算法，它使用记忆化（一种动态规划的形式）来存储 $L(u)$ 的结果，以避免重复计算。设 `dist[u]` 是一个数组，用于存储已计算的 $L(u)$ 值，初始化为一个哨兵值（例如，$-\\infty$ 或 $-1$），表示该值尚未计算。\n\n**算法: `LongestPathDFS(u)`**\n1.  如果 `dist[u]` 不是哨兵值，则返回 `dist[u]`。\n2.  初始化 `max_len = 0`。这处理了终端顶点的基础情况。\n3.  对于每个满足 $(u, v) \\in E$ 的顶点 $v$：\n    a. 计算 `path_len = w(u, v) + LongestPathDFS(v)`。\n    b. 更新 `max_len = max(max_len, path_len)`。\n4.  存储结果：`dist[u] = max_len`。\n5.  返回 `dist[u]`。\n\n为了找到整个图中的最长路径，我们对每个顶点 $u \\in V$ 调用此函数，并取结果的最大值。如果图有已知的源顶点（入度为 $0$），则从这些顶点开始搜索就足够了。\n\n**证明：**\n- **递归不变量：** 函数 `LongestPathDFS(u)` 正确地计算了 $L(u)$。基础情况（终端顶点）正确地返回 $0$。在递归调用 `LongestPathDFS(v)` 是正确的假设下，递归步骤正确地实现了递推关系 $L(u) = \\max_{(u,v) \\in E} \\{w(u,v) + L(v)\\}$。\n- **终止性：** 在 DAG 中，递归调用的序列遵循图中的一条简单路径。由于没有环，递归深度受限于顶点数量，并且由于记忆化，每个顶点的 $L(u)$ 值只被计算一次。该算法处理每个顶点和每条边一次，因此时间复杂度为 $O(|V| + |E|)$。\n- **正确性：** 正确性源于递推关系中固有的最优性原理，以及 DFS 后序遍历所导出的逆拓扑排序确保了所有子问题 $L(v)$ 在计算 $L(u)$ 需要它们之前都已解决。\n\n**第二部分：应用于给定的 DAG**\n\n给定图的顶点集为 $V = \\{1, 2, 3, 4, 5, 6, 7, 8, 9\\}$。一个关键特性是，对于每条边 $(u \\to v)$，都有 $u  v$。此特性保证了该图是一个 DAG，并且顶点标签 $(1, 2, \\dots, 9)$ 构成了一个拓扑排序。因此，我们可以通过按逆拓扑顺序（从 $u=9$ 到 $u=1$）遍历顶点来计算 $L(u)$ 的值。这等价于使用记忆化的递归 DFS 算法的结果。\n\n设 $L(u)$ 表示从顶点 $u$ 开始的最长路径的长度。\n\n-   **顶点 9：** $L(9) = 0$，因为它是一个终端顶点。\n\n-   **顶点 8：** 唯一的出边是 $(8 \\to 9, 2)$。\n    $L(8) = w(8, 9) + L(9) = 2 + 0 = 2$。\n\n-   **顶点 7：** 出边是 $(7 \\to 8, 1)$ 和 $(7 \\to 9, 8)$。\n    $L(7) = \\max \\{ w(7, 8) + L(8), w(7, 9) + L(9) \\} = \\max \\{ 1 + 2, 8 + 0 \\} = \\max \\{ 3, 8 \\} = 8$。\n\n-   **顶点 6：** 出边是 $(6 \\to 8, 4)$ 和 $(6 \\to 9, 3)$。\n    $L(6) = \\max \\{ w(6, 8) + L(8), w(6, 9) + L(9) \\} = \\max \\{ 4 + 2, 3 + 0 \\} = \\max \\{ 6, 3 \\} = 6$。\n\n-   **顶点 5：** 出边是 $(5 \\to 7, 3)$ 和 $(5 \\to 8, 5)$。\n    $L(5) = \\max \\{ w(5, 7) + L(7), w(5, 8) + L(8) \\} = \\max \\{ 3 + 8, 5 + 2 \\} = \\max \\{ 11, 7 \\} = 11$。\n\n-   **顶点 4：** 出边是 $(4 \\to 6, 1)$、$(4 \\to 7, 4)$ 和 $(4 \\to 8, 2)$。\n    $L(4) = \\max \\{ w(4, 6) + L(6), w(4, 7) + L(7), w(4, 8) + L(8) \\} = \\max \\{ 1 + 6, 4 + 8, 2 + 2 \\} = \\max \\{ 7, 12, 4 \\} = 12$。\n\n-   **顶点 3：** 出边是 $(3 \\to 4, 1)$、$(3 \\to 6, 2)$ 和 $(3 \\to 7, 7)$。\n    $L(3) = \\max \\{ w(3, 4) + L(4), w(3, 6) + L(6), w(3, 7) + L(7) \\} = \\max \\{ 1 + 12, 2 + 6, 7 + 8 \\} = \\max \\{ 13, 8, 15 \\} = 15$。\n\n-   **顶点 2：** 出边是 $(2 \\to 5, 4)$ 和 $(2 \\to 6, 6)$。\n    $L(2) = \\max \\{ w(2, 5) + L(5), w(2, 6) + L(6) \\} = \\max \\{ 4 + 11, 6 + 6 \\} = \\max \\{ 15, 12 \\} = 15$。\n\n-   **顶点 1：** 出边是 $(1 \\to 2, 3)$、$(1 \\to 3, 2)$ 和 $(1 \\to 4, 5)$。\n    $L(1) = \\max \\{ w(1, 2) + L(2), w(1, 3) + L(3), w(1, 4) + L(4) \\} = \\max \\{ 3 + 15, 2 + 15, 5 + 12 \\} = \\max \\{ 18, 17, 17 \\} = 18$。\n\n从每个顶点开始的最长路径长度为：\n$L(1)=18$，$L(2)=15$，$L(3)=15$，$L(4)=12$，$L(5)=11$，$L(6)=6$，$L(7)=8$，$L(8)=2$，$L(9)=0$。\n\n整个图中最长路径的长度是这些值的最大值：$\\max \\{18, 15, 15, 12, 11, 6, 8, 2, 0\\} = 18$。这个值对应于从唯一的源顶点（顶点 1）开始的最长路径。\n该路径是 $1 \\to 2 \\to 5 \\to 7 \\to 9$，总权重为 $w(1,2)+w(2,5)+w(5,7)+w(7,9) = 3+4+3+8 = 18$。", "answer": "$$\\boxed{18}$$", "id": "3227722"}]}