{"hands_on_practices": [{"introduction": "在学习了最小生成树 (MST) 的理论之后，一个自然的问题是：我们如何判断图中的某条特定边是否可以成为至少一个最小生成树的一部分？这个问题在图中存在多条权重相同的边，从而可能产生多个不同但总权重相同的最小生成树时，显得尤为重要。[@problem_id:3253204] 这个练习将引导你将 Kruskal 算法背后的贪心选择逻辑形式化，从而得出一个优雅的判别准则，该准则基于环路性质，仅需考察权重严格小于目标边的子图。", "problem": "给定一个有限、简单、无向、连通的带权图 $G=(V,E)$，其权重函数 $w:E\\to\\mathbb{R}_{0}$ 为正值。生成树是一个包含所有顶点 $|V|$ 的连通无环子图，恰好包含 $|V|-1$ 条边。最小生成树（MST）是在所有生成树中总权重最小的生成树。MST 分析所依据的基本性质是切割性质（对于 $V$ 的任意一个划分为两个非空集合的划分，任何横跨该划分的权重最小的边都属于每一棵 MST）和环路性质（在任何环路中，任何权重严格大于环路中所有其他边的边都不属于任何 MST）。\n\n设计一个算法，在给定图 $G$ 和一条指定边 $e\\in E$ 的情况下，判断 $e$ 是否属于 $G$ 的至少一棵 MST。您的算法必须用纯粹的数学和逻辑术语表达，这些术语源于上述基本性质，并且必须实现为一个完整的程序。\n\n您的程序不能读取输入；相反，它必须在内部评估以下测试套件。在每个测试用例中，顶点标记为 $\\{0,1,\\dots,n-1\\}$，边集以三元组 $(u,v,w)$ 的形式给出，表示 $u$ 和 $v$ 之间的一条权重为 $w$ 的无向边。指定边由其在给定边列表中的从零开始的索引 $k$ 指定。\n\n测试套件：\n- 测试用例 1：$n=5$，边 $(0,1,1)$, $(1,2,2)$, $(2,3,3)$, $(3,4,4)$, $(0,4,5)$, $(1,4,6)$，指定边索引 $k=3$。\n- 测试用例 2：$n=4$，边 $(0,1,1)$, $(1,2,1)$, $(2,3,1)$, $(0,3,5)$，指定边索引 $k=3$。\n- 测试用例 3：$n=4$，边 $(0,1,2)$, $(1,2,2)$, $(2,3,2)$, $(0,3,2)$，指定边索引 $k=3$。\n- 测试用例 4：$n=4$，边 $(0,1,2)$, $(1,3,2)$, $(0,3,3)$, $(1,2,4)$，指定边索引 $k=2$。\n- 测试用例 5：$n=2$，边 $(0,1,10)$，指定边索引 $k=0$。\n- 测试用例 6：$n=6$，边 $(0,1,1)$, $(1,2,2)$, $(2,3,2)$, $(3,4,3)$, $(4,5,4)$, $(0,5,4)$, $(1,5,3)$, $(2,5,3)$，指定边索引 $k=5$。\n\n您的程序应输出一行，其中包含一个用方括号括起来的、以逗号分隔的布尔结果列表，按顺序对应上述测试用例。例如，格式必须严格为 $[\\mathrm{result}_1,\\mathrm{result}_2,\\dots,\\mathrm{result}_6]$，其中每个 $\\mathrm{result}_i$ 为 $\\mathrm{True}$ 或 $\\mathrm{False}$，取决于测试用例 $i$ 中的指定边是否属于相应图的至少一棵 MST。", "solution": "我们从最小生成树（MST）的基本定义和经过充分验证的性质开始。设 $G=(V,E)$ 是一个有限、简单、无向、连通的带权图，其权重为正值 $w:E\\to\\mathbb{R}_{0}$。$G$ 的生成树是一个包含所有顶点的连通无环子图，因此恰好包含 $|V|-1$ 条边。最小生成树（MST）是在所有生成树中边权重之和最小的生成树。\n\n有两个基本原则支配着 MST 的结构：\n1. 切割性质：对于 $V$ 的任意一个划分为两个非空集合的划分（cut），任何横跨该划分的权重最小的边都包含在每一棵 MST 中。\n2. 环路性质：对于 $G$ 中的任意环路，任何权重严格大于环路中所有其他边的边都不能被包含在任何 MST 中。\n\n这些性质证明了 Kruskal 算法的正确性。该算法通过按权重的非递减顺序处理边来构建一棵 MST，并且当且仅当一条边连接了两个先前不连通的分量时（从而避免了环路）才添加该边。Kruskal 算法在处理等权重边时的行为取决于平局打破规则，这可能导致产生多个不同的 MST。\n\n我们现在推导一条边 $e=(u,v)\\in E$（权重为 $w_e$）属于至少一棵 MST 的充分必要条件。该条件是：在由所有权重严格小于 $w_e$ 的边构成的子图中，顶点 $u$ 和 $v$ 不连通。如果它们已经连通，那么根据 Kruskal 算法的逻辑，添加边 $e$ 将会形成一个环路，且 $e$ 在该环路中是权重最大（或之一）的边，因此不会被选入 MST。反之，如果它们不连通，Kruskal 算法在处理到权重为 $w_e$ 的边时，就可以（取决于平局规则）选择 $e$ 来连接它们所在的两个不同分量，从而使 $e$ 成为某个 MST 的一部分。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass DSU:\n    def __init__(self, n: int):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n\n    def find(self, x: int) - int:\n        # Path compression\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, a: int, b: int) - None:\n        # Union by rank\n        ra = self.find(a)\n        rb = self.find(b)\n        if ra == rb:\n            return\n        if self.rank[ra]  self.rank[rb]:\n            self.parent[ra] = rb\n        elif self.rank[ra]  self.rank[rb]:\n            self.parent[rb] = ra\n        else:\n            self.parent[rb] = ra\n            self.rank[ra] += 1\n\ndef edge_in_some_mst(n, edges, e_idx) - bool:\n    \"\"\"\n    Determine if distinguished edge edges[e_idx] belongs to at least one MST.\n    Criterion: Let e = (u, v, w). Consider subgraph formed by edges with weight  w.\n    e is in some MST iff u and v are in different connected components of that subgraph.\n    \"\"\"\n    u, v, w = edges[e_idx]\n    dsu = DSU(n)\n    for i, (a, b, w_ab) in enumerate(edges):\n        if w_ab  w:\n            dsu.union(a, b)\n    return dsu.find(u) != dsu.find(v)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case: (n, edges_list, distinguished_edge_index)\n    test_cases = [\n        # Test case 1\n        (5, [(0,1,1),(1,2,2),(2,3,3),(3,4,4),(0,4,5),(1,4,6)], 3),\n        # Test case 2\n        (4, [(0,1,1),(1,2,1),(2,3,1),(0,3,5)], 3),\n        # Test case 3\n        (4, [(0,1,2),(1,2,2),(2,3,2),(0,3,2)], 3),\n        # Test case 4\n        (4, [(0,1,2),(1,3,2),(0,3,3),(1,2,4)], 2),\n        # Test case 5\n        (2, [(0,1,10)], 0),\n        # Test case 6\n        (6, [(0,1,1),(1,2,2),(2,3,2),(3,4,3),(4,5,4),(0,5,4),(1,5,3),(2,5,3)], 5),\n    ]\n\n    results = []\n    for n, edges, e_idx in test_cases:\n        result = edge_in_some_mst(n, edges, e_idx)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3253204"}, {"introduction": "与上一个问题相对应，我们现在探讨一个更强的条件：如何确定一条边是否“不可或缺”，即它必须出现在图的每一个最小生成树中？这类边在网络设计中通常代表着关键连接。[@problem_id:3253138] 这个练习将让你应用切割性质来解决这个问题，其核心思想是判断这条边是否是连接图中两个顶点集合的、权重唯一的“最轻桥梁”。", "problem": "给定一个无向连通加权图 $G$，其顶点集为 $V(G)$，边集为 $E(G)$，其中每条边 $e=(u,v,w)$ 都有一个非负权重 $w \\in \\mathbb{R}_{\\ge 0}$。$G$ 的生成树是一个覆盖所有顶点的连通无环子图。最小生成树 (MST) 是 $G$ 的所有生成树中总权重最小的生成树。切割性质表明：对于 $V(G)$ 的任意划分（切割），即将其分为两个不相交的非空集合，所有横跨此切割的边中，权重严格最小的任意一条边都会出现在某个 MST 中。环路性质表明：在任意环路中，权重严格最大的边不会出现在任何 MST 中。\n\n设计一个算法，在给定图 $G$ 和一条特定边 $e^\\star=(x,y,w_{e^\\star})$ 的情况下，判断 $e^\\star$ 是否属于 $G$ 的每一个 MST。你的算法必须基于基本定义以及切割-环路性质，并实现为一个完整的程序。\n\n你的程序必须在以下测试套件上执行。每个测试用例由顶点数 $n$、一个以三元组 $(u,v,w)$ 表示的边列表（其中 $u,v \\in \\{1,\\dots,n\\}$ 且 $w \\in \\mathbb{R}_{\\ge 0}$）以及一条以三元组 $(x,y,w_{e^\\star})$ 表示的特定边 $e^\\star$ 指定。这些图是无向且连通的，权重为整数。\n\n- 测试用例 1：\n  - $n=3$\n  - $E=\\{(1,2,1),(2,3,2),(1,3,3)\\}$\n  - $e^\\star=(1,2,1)$\n- 测试用例 2：\n  - $n=4$\n  - $E=\\{(1,2,1),(2,3,1),(3,4,1),(4,1,1)\\}$\n  - $e^\\star=(1,2,1)$\n- 测试用例 3：\n  - $n=3$\n  - $E=\\{(1,2,1),(2,3,2),(1,3,3)\\}$\n  - $e^\\star=(1,3,3)$\n- 测试用例 4：\n  - $n=2$\n  - $E=\\{(1,2,5)\\}$\n  - $e^\\star=(1,2,5)$\n- 测试用例 5：\n  - $n=5$\n  - $E=\\{(1,2,1),(3,4,1),(4,5,1),(3,5,2),(2,3,4),(1,3,7),(2,4,8)\\}$\n  - $e^\\star=(2,3,4)$\n\n对于每个测试用例，你的程序必须输出一个布尔值，以表明 $e^\\star$ 是否属于 $G$ 的每一个 MST。\n\n最终输出格式：你的程序应生成单行输出，包含一个由方括号括起来的逗号分隔列表，例如 $[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5]$，其中每个 $\\text{result}_i$ 为 $\\text{True}$ 或 $\\text{False}$。\n\n不涉及物理单位或角度。所有答案都是无量纲的布尔值。", "solution": "问题要求设计一个算法来确定给定边 $e^\\star=(x,y,w_{e^\\star})$ 是否属于一个连通、无向、加权图 $G=(V, E)$ 的每个最小生成树 (MST)。该算法必须基于 MST 的基本性质，如切割性质和环路性质。\n\n图论中一个公认的定理为一条边被包含在每个 MST 中提供了充分必要条件。这个可以由切割和环路性质推导出的定理，构成了我们算法的基础。\n\n**核心原则**\n\n一条边 $e^\\star=(x, y, w_{e^\\star})$ 存在于图 $G$ 的每个 MST 中，其充分必要条件是：对于连接其端点 $x$ 和 $y$ 的任意一条不包含 $e^\\star$ 的路径，该路径上都至少存在一条权重严格大于 $w_{e^\\star}$ 的边。\n\n**原则的论证**\n\n我们可以用反证法来证明。让我们假设相反的条件允许我们构建一个不包含 $e^\\star$ 的 MST。\n\n假设在 $G \\setminus \\{e^\\star\\}$ 中（即一条不使用 $e^\\star$ 的路径）存在一条连接 $x$ 和 $y$ 的路径 $P_{xy}$，使得 $P_{xy}$ 上的所有边的权重都小于或等于 $w_{e^\\star}$。我们想证明这意味着 $e^\\star$ 并不存在于每个 MST 中。\n\n设 $T$ 是 $G$ 的一个 MST。如果 $T$ 不包含 $e^\\star$，我们就已经找到了一个不含它的 MST，因此 $e^\\star$ 不在每个 MST 中。\n\n现在，考虑 $T$ 确实包含 $e^\\star$ 的情况。将路径 $P_{xy}$ 添加到 $T$ 并不是我们想做的。相反，让我们考虑由 $e^\\star$ 和路径 $P_{xy}$ 的并集形成的环路 $C$，即 $C = \\{e^\\star\\} \\cup P_{xy}$。根据我们的假设，$P_{xy}$ 上的每条边的权重 $w \\le w_{e^\\star}$。路径 $P_{xy}$ 上必须至少有一条边 $e'$，移除它可以打破环路 $C$ 同时保持图的连通性。让我们从一个生成树 $T_{base}$ 开始，它由所有权重小于 $w_{e^\\star}$ 的边以及从 $P_{xy}$ 中选取的一部分权重为 $w_{e^\\star}$ 的边构成，用以连接 $x$ 和 $y$。这种构造保证是某个 MST 的一部分。由于这棵树在不使用 $e^\\star$ 的情况下连接了 $x$ 和 $y$，这表明可以存在不含 $e^\\star$ 的 MST。\n\n一个更正式的论证依赖于交换性质。假设 $e^\\star$ 存在于一个 MST $T_{mst}$ 中。将 $P_{xy}$ 中的任意边 $e' \\in P_{xy}$ 添加到 $T_{mst}$ 会形成一个环路。这条推理路线更为复杂。一个更直接的证明如下：\n\n让我们证明，如果在 $G \\setminus \\{e^\\star\\}$ 中连接 $x$ 和 $y$ 的每条路径都包含一条比 $e^\\star$ 更重的边，那么 $e^\\star$ 必须存在于每个 MST 中。\n为进行反证，假设存在一个不包含 $e^\\star$ 的 MST $T$。由于 $T$ 是一个生成树，在 $T$ 中必然存在一条连接 $x$ 和 $y$ 的唯一路径 $P$。根据我们的前提，这条路径 $P$ 必须包含至少一条边，我们称之为 $e'=(u,v)$，其权重 $w(e')  w_{e^\\star}$。现在，考虑一个新图 $T' = (T \\setminus \\{e'\\}) \\cup \\{e^\\star\\}$。从 $T$ 中移除 $e'$ 会将其分裂成两个不连通的分量。由于 $x$ 和 $y$ 在 $T$ 中由路径 $P$ 连接，且 $e'$ 在该路径上，添加连接 $x$ 和 $y$ 的 $e^\\star$ 会以某种方式将这两个分量连接起来。实际上，将 $e^\\star$ 添加到 $T$ 中会形成一个同时包含 $e^\\star$ 和 $e'$ 的环路，因此从这个环路中移除 $e'$ 会得到一个新的生成树 $T'$。$T'$ 的总权重为 $W(T') = W(T) - w(e') + w_{e^\\star}$。由于 $w(e') > w_{e^\\star}$，我们得到 $W(T')  W(T)$。这与 $T$ 是一个 MST 的假设相矛盾。因此，任何 MST 都必须包含 $e^\\star$。\n\n**算法的构建**\n\n核心原则可以改写为一个可测试的条件：$e^\\star$ 存在于每个 MST 中，当且仅当在 $G \\setminus \\{e^\\star\\}$ 中，不存在连接 $x$ 和 $y$ 的路径，其中所有边的权重都小于或等于 $w_{e^\\star}$。\n\n这引出了以下算法：\n1. 构建一个子图 $G_{alt} = (V, E_{alt})$。其顶点集与原图 $G$ 相同。\n2. 边集 $E_{alt}$ 由原边集 $E$ 中满足以下两个条件的所有边 $e=(u,v,w)$ 组成：\n   a. 权重 $w$ 小于或等于目标边的权重，即 $w \\le w_{e^\\star}$。\n   b. 该边 $e$ 不是目标边 $e^\\star$ 本身 ($e \\neq e^\\star$)。\n3. 检查顶点 $x$ 和 $y$ 是否在这个新子图 $G_{alt}$ 中连通。这可以使用广度优先搜索 (BFS)、深度优先搜索 (DFS) 或并查集 (DSU) 数据结构来高效完成。\n4. 如果 $x$ 和 $y$ 在 $G_{alt}$ 中是连通的，这意味着存在一条由“廉价”边构成的替代路径。因此，$e^\\star$ 不是必需的，不属于每个 MST。算法返回 $\\text{False}$。\n5. 如果 $x$ 和 $y$ 在 $G_{alt}$ 中是不连通的，这意味着它们之间的任何替代路径都必须使用至少一条权重严格大于 $w_{e^\\star}$ 的边。如上所证，这使得 $e^\\star$ 对每个 MST 都是必不可少的。算法返回 $\\text{True}$。\n\n这个算法能正确判断一条边是否是跨越一个关键权重阈值的“桥”，从而使其不可或缺。在第3步中使用并查集 (DSU) 数据结构检查连通性尤其高效，每次边的合并操作的时间复杂度接近常数时间。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef is_in_every_mst(n, edges, e_star):\n    \"\"\"\n    Determines if a given edge e_star is in every Minimum Spanning Tree (MST)\n    of the graph defined by n vertices and the edge list.\n    \n    Args:\n        n (int): The number of vertices, labeled 1 to n.\n        edges (list of tuples): The list of edges, each as a (u, v, w) tuple.\n        e_star (tuple): The distinguished edge (x, y, w_star) to be checked.\n        \n    Returns:\n        bool: True if e_star is in every MST, False otherwise.\n    \"\"\"\n    \n    # DSU (Disjoint Set Union) data structure implemented with nested functions\n    # for checking connectivity. Vertices are 1-based.\n    parent = list(range(n + 1))\n    \n    def find(i):\n        if parent[i] == i:\n            return i\n        parent[i] = find(parent[i])\n        return parent[i]\n\n    def union(i, j):\n        root_i = find(i)\n        root_j = find(j)\n        if root_i != root_j:\n            parent[root_i] = root_j\n\n    x, y, w_star = e_star\n    \n    # Normalize e_star's endpoints for consistent undirected edge comparison.\n    # This handles cases where the edge in the list is (v, u) instead of (u, v).\n    e_star_nodes = tuple(sorted((x, y)))\n\n    # Build the connected components for the subgraph containing alternative paths.\n    # An alternative path is one that connects x and y without using e_star,\n    # composed entirely of edges with weights less than or equal to w_star.\n    for u, v, w in edges:\n        # Normalize the current edge's endpoints for comparison.\n        current_edge_nodes = tuple(sorted((u, v)))\n        \n        if w  w_star:\n            # Edges strictly cheaper than e_star can always be part of an alternative path.\n            union(u, v)\n        elif w == w_star and current_edge_nodes != e_star_nodes:\n            # Edges with the same weight can also be part of an alternative path,\n            # as long as they are not e_star itself.\n            union(u, v)\n\n    # An alternative path exists if and only if x and y are in the same\n    # connected component in the subgraph we've just processed.\n    # If find(x) == find(y), they are connected, so e_star is NOT in every MST.\n    # If find(x) != find(y), they are disconnected, so e_star IS in every MST.\n    return find(x) != find(y)\n\n\ndef solve():\n    \"\"\"\n    Defines the test suite and runs the algorithm for each case,\n    then prints the results in the required format.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        (3, [(1, 2, 1), (2, 3, 2), (1, 3, 3)], (1, 2, 1)),\n        # Test case 2\n        (4, [(1, 2, 1), (2, 3, 1), (3, 4, 1), (4, 1, 1)], (1, 2, 1)),\n        # Test case 3\n        (3, [(1, 2, 1), (2, 3, 2), (1, 3, 3)], (1, 3, 3)),\n        # Test case 4\n        (2, [(1, 2, 5)], (1, 2, 5)),\n        # Test case 5\n        (5, [(1, 2, 1), (3, 4, 1), (4, 5, 1), (3, 5, 2), (2, 3, 4), (1, 3, 7), (2, 4, 8)], (2, 3, 4))\n    ]\n\n    results = []\n    for n, edges, e_star in test_cases:\n        result = is_in_every_mst(n, edges, e_star)\n        results.append(result)\n\n    # The final print statement must produce only the specified single-line format.\n    print(f\"[{','.join(map(str, results))}]\")\n\n\n# Execute the main solver function.\nsolve()\n```", "id": "3253138"}, {"introduction": "掌握了如何识别最小生成树的构成元素后，我们可以挑战一个更具综合性的问题：在找到最优的生成树（即最小生成树）之后，总权重“第二好”的生成树是什么？[@problem_id:3253223] 此练习要求我们综合运用所学知识，从一个已知的最小生成树出发，系统地探索所有可能的“一步之遥”的修改。通过将非树边换入并移除相应环路中最重的边，我们可以找到导致总权重增加最小的那个方案，这在灵敏度分析和网络冗余设计等领域是一个非常实用的技能。", "problem": "给定一个连通、无向、加权的图 $G = (V, E)$，其包含 $|V| = n$ 个从 $0$ 到 $n-1$ 标记的顶点和 $|E| = m$ 条边，请设计一个算法来计算“次小”最小生成树（MST）的权重。次小 MST 定义为所有总权重严格大于最小生成树权重的生成树中，总权重最小的那一个。如果不存在总权重严格大于最小生成树权重的生成树，则算法应返回 $-1$。所有边的权重都是非负整数。该算法必须从第一性原理出发，使用图论的基本定义和经过验证的性质，特别是生成树的切割性质和环路性质。\n\n您必须使用的基本原理包括：\n- 图中生成树、环路和切割的定义。\n- 最小生成树（MST）的定义：总边权最小的生成树。\n- 切割性质：对于图中的任意切割，横跨该切割的最轻边总是包含在某个 MST 中。\n- 环路性质：对于图中的任意环路，该环路上的最重边不包含在任何 MST 中。\n\n您的程序必须实现一个算法，该算法：\n- 计算 $G$ 的一个 MST（您可以不加证明地假设，像 Kruskal 算法这样的算法在正确应用时能产生一个有效的 MST）。\n- 通过逻辑推理，分析使用非树边替换 MST 中的边如何影响总权重，从而确定次小 MST 的权重。此过程依赖于切割和环路性质，而非快捷公式。\n\n输入作为一组图的测试套件嵌入在程序中。对于每个图，输出必须是一个整数：次小 MST 的权重；如果不存在总权重严格大于 MST 的生成树，则为 $-1$。不涉及物理单位或角度。\n\n测试套件：\n- 测试用例 $1$ (具有唯一 MST 的普通连通图):\n  - $n = 6$\n  - $E = \\{(0,1,4), (0,2,3), (1,2,1), (1,3,2), (2,3,4), (3,4,2), (4,5,6), (3,5,5), (2,5,7), (0,5,10)\\}$\n- 测试用例 $2$ (具有多个等权重 MST 的图，要求次小生成树的权重严格增加):\n  - $n = 4$\n  - $E = \\{(0,1,1), (1,2,1), (2,3,1), (3,0,1), (0,2,2), (1,3,2)\\}$\n- 测试用例 $3$ (次小 MST 与 MST 仅相差一次单边替换的小图):\n  - $n = 3$\n  - $E = \\{(0,1,1), (1,2,1), (0,2,2)\\}$\n- 测试用例 $4$ (所有生成树总权重相同的图，因此不存在权重严格更大的生成树):\n  - $n = 3$\n  - $E = \\{(0,1,5), (1,2,5), (0,2,5)\\}$\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含四个测试用例的结果，格式为方括号括起来的逗号分隔列表，例如 `[a,b,c,d]`，其中 $a$、$b$、$c$ 和 $d$ 是与上述测试用例按顺序对应的整数。\n\n您的实现必须是自包含的，并为给定的测试套件产生确定性的结果。所有测试用例的答案都是整数。不需要百分比或角度单位。", "solution": "该问题已经过验证，被认为是有效的。这是一个图算法领域中定义明确的问题，基于成熟的图论原理。问题陈述自洽、一致，没有任何科学或逻辑上的缺陷。我现在将提供一个正式的解决方案。\n\n问题要求计算给定连通、无向、加权图 $G = (V, E)$ 的次小最小生成树的权重。次小生成树定义为总权重严格大于最小生成树（MST）权重的所有生成树中，总权重最小的那一棵。设 MST 的权重为 $W_{MST}$。我们要寻找 $\\min \\{ W(T) \\mid T \\text{ 是 } G \\text{ 的生成树且 } W(T)  W_{MST} \\}$。如果不存在这样的树，则值为 $-1$。\n\n解决方案源于生成树的基本性质及其与环路和切割的关系。一个关键的见解是，任何生成树都可以通过一系列单边交换操作转换为任何其他生成树。单边交换操作包括添加一条非树边，并从形成的环路中移除一条树边。\n\n设 $T_{MST}$ 是 $G$ 的一个最小生成树。任何其他生成树 $T'$ 必须包含至少一条不在 $T_{MST}$ 中的边。考虑一个与 $T_{MST}$ 相差一次单边交换的生成树 $T'$。这样的树是通过选择一条不在 $T_{MST}$ 中的边 $e_{in} = (u,v)$ 并将其添加到 $T_{MST}$ 中而形成的。将 $e_{in}$ 添加到 $T_{MST}$ 会创建一个唯一的环路 $C$。该环路 $C$ 由 $e_{in}$ 以及 $T_{MST}$ 中连接顶点 $u$ 和 $v$ 的唯一路径 $P_{uv}$ 组成。为了恢复树的性质（即恰好有 $|V|-1 = n-1$ 条边且没有环路），必须从 $C$ 中移除一条边 $e_{out}$。由于 $e_{in}$ 必须在新树中，因此 $e_{out}$ 必须是路径 $P_{uv}$ 上的一条边。最终得到的边集 $T' = (T_{MST} \\setminus \\{e_{out}\\}) \\cup \\{e_{in}\\}$ 是一棵新的生成树。\n\n这棵新生成树 $T'$ 的权重由 $W(T') = W(T_{MST}) - w(e_{out}) + w(e_{in})$ 给出。我们正在寻找满足 $W(T')  W_{MST}$ 的最小 $W(T')$，这等价于寻找最小的正权重差 $\\Delta W = w(e_{in}) - w(e_{out})$。\n\nMST 的环路性质在此处至关重要。它指出，对于图中的任何环路，权重最大的边不可能是任何 MST 的一部分。对于我们的构造，一个直接的推论是，对于环路 $C = P_{uv} \\cup \\{e_{in}\\}$，非 MST 边 $e_{in}$ 的权重必须大于或等于路径 $P_{uv}$ 上任何边的权重。即，对于所有 $e \\in P_{uv}$，都有 $w(e_{in}) \\ge w(e)$。如果路径 $P_{uv}$ 上存在一条边 $e'$ 使得 $w(e')  w(e_{in})$，那么我们可以构造一棵树 $(T_{MST} \\setminus \\{e'\\}) \\cup \\{e_{in}\\}$，其权重小于 $W(T_{MST})$，这与 $T_{MST}$ 是 MST 的定义相矛盾。因此，权重差 $\\Delta W = w(e_{in}) - w(e_{out})$ 总是非负的。\n\n为了找到次小 MST，我们寻求在 $W_{MST}$ 基础上找到最小的可能权重增量。这表明我们应该考虑所有能够产生权重严格大于 $W_{MST}$ 的树的单边交换，并取其中的最小值。对于一个固定的引入边 $e_{in}$，当 $w(e_{out})$ 最大化时，权重增量 $w(e_{in}) - w(e_{out})$ 被最小化。因此，对于每条非 MST 边 $e_{in}$，我们应该选择移除 $T_{MST}$ 中路径 $P_{uv}$ 上的最重边 $e_{out}$。对于特定的 $e_{in}$ 选择，这给出了最佳的候选树。\n\n这导出了一个完整的算法：\n$1$. 计算图 $G$ 的一个 MST，记为 $T_{MST}$，及其总权重 $W_{MST}$。Kruskal 算法适用于此。此过程自然地将边集 $E$ 划分为 MST 边和非 MST 边。\n\n$2$. 初始化一个变量用于存储次小权重，$W_{2nd}$，将其设为一个代表无穷大的值（例如 $\\infty$）。\n\n$3$. 对于每条不在 $T_{MST}$ 中的边 $e_{in} = (u, v)$，其权重为 $w_{in}$：\n    a. 在 $T_{MST}$ 中找到连接顶点 $u$ 和 $v$ 的唯一路径 $P_{uv}$。\n    b. 在此路径 $P_{uv}$ 上找到权重最大的边 $e_{out}$，其权重为 $w_{out}$。这可以通过在树 $T_{MST}$ 上进行图遍历（如广度优先搜索 BFS 或深度优先搜索 DFS）来完成。\n    c. 计算通过这次交换形成的新生成树的权重：$W' = W_{MST} - w_{out} + w_{in}$。\n    d. 我们只对权重严格大于 $W_{MST}$ 的生成树感兴趣。因此，如果 $w_{in} > w_{out}$（这意味着 $W' > W_{MST}$），那么 $W'$ 是次小 MST 权重的一个有效候选值。我们更新目前找到的最小值：$W_{2nd} = \\min(W_{2nd}, W')$。$w_{in} = w_{out}$ 的情况对应于找到另一个相同权重的 MST，这不是我们所寻求的。\n\n$4$. 遍历完所有非 MST 边后，如果 $W_{2nd}$ 仍为 $\\infty$，则意味着无法形成权重严格更大的生成树。在这种情况下，答案是 $-1$。否则，答案是 $W_{2nd}$。\n\n该算法保证能找到次小 MST。虽然我们只考虑了与某个特定 MST 相差一次单边交换的树，但可以证明，真正的次小 MST 必然会在这些候选者中找到。任何生成树都可以通过一系列交换从任何其他生成树到达。从一个 MST 到次小 MST 的交换路径必须包含一个增加权重的初始步骤，而所有可能的初始步骤中最小的这种增量将确定次小 MST。\n\n在实现方面，Kruskal 算法可以使用并查集（DSU）数据结构来实现。对于每条非 MST 边，要在 MST 中找到其路径上的最重边，只需从一个端点到另一个端点进行简单的遍历（如广度优先搜索 BFS），并记录父指针以重建路径，这对于给定的问题约束是足够的。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the weight of the second-best MST for a series of test cases.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        (6, [(0,1,4), (0,2,3), (1,2,1), (1,3,2), (2,3,4), (3,4,2), (4,5,6), (3,5,5), (2,5,7), (0,5,10)]),\n        # Test case 2\n        (4, [(0,1,1), (1,2,1), (2,3,1), (3,0,1), (0,2,2), (1,3,2)]),\n        # Test case 3\n        (3, [(0,1,1), (1,2,1), (0,2,2)]),\n        # Test case 4\n        (3, [(0,1,5), (1,2,5), (0,2,5)]),\n    ]\n\n    results = []\n\n    for n, edges in test_cases:\n        # Step 1: Find an MST using Kruskal's algorithm\n        # A Disjoint Set Union (DSU) data structure for tracking connected components.\n        parent = list(range(n))\n        def find_set(v):\n            if v == parent[v]:\n                return v\n            parent[v] = find_set(parent[v])\n            return parent[v]\n\n        def union_sets(a, b):\n            a = find_set(a)\n            b = find_set(b)\n            if a != b:\n                parent[b] = a\n                return True\n            return False\n\n        # Sort edges by weight\n        edges.sort(key=lambda item: item[2])\n\n        mst_weight = 0\n        mst_edges = []\n        non_mst_edges = []\n\n        for u, v, w in edges:\n            if union_sets(u, v):\n                mst_weight += w\n                mst_edges.append((u, v, w))\n            else:\n                non_mst_edges.append((u, v, w))\n\n        # Check if graph was connected (MST should have n-1 edges)\n        # This is guaranteed by the problem statement, but good practice.\n        if len(mst_edges) != n - 1 and n > 0 :\n            # This case corresponds to a disconnected graph.\n            # The problem assumes connected graphs.\n            # Handle as per problem spec for no second-best MST.\n             results.append(-1)\n             continue\n\n        # Step 2: Build adjacency list for the MST for traversal\n        mst_adj = [[] for _ in range(n)]\n        for u, v, w in mst_edges:\n            mst_adj[u].append((v, w))\n            mst_adj[v].append((u, w))\n\n        # Step 3: Iterate through non-MST edges to find the second-best MST weight\n        second_best_weight = float('inf')\n\n        for u_in, v_in, w_in in non_mst_edges:\n            # Find the heaviest edge on the path between u_in and v_in in the MST\n            # We can use BFS to find the path and track max edge weight.\n            # Using parent tracking in BFS is efficient.\n            parent_map = {u_in: (None, 0)} # node - (parent, weight_to_parent)\n            queue = [u_in]\n            \n            head = 0\n            path_found = False\n            while head  len(queue):\n                curr = queue[head]\n                head += 1\n                if curr == v_in:\n                    path_found = True\n                    break\n                for neighbor, weight in mst_adj[curr]:\n                    if neighbor not in parent_map:\n                        parent_map[neighbor] = (curr, weight)\n                        queue.append(neighbor)\n            \n            if not path_found: continue\n\n            max_weight_on_path = 0\n            curr_node = v_in\n            while curr_node != u_in and curr_node is not None:\n                p_node, p_weight = parent_map[curr_node]\n                if p_weight  max_weight_on_path:\n                    max_weight_on_path = p_weight\n                curr_node = p_node\n            \n            w_out = max_weight_on_path\n            \n            # We must have a strictly greater weight for the new tree\n            if w_in  w_out:\n                candidate_weight = mst_weight - w_out + w_in\n                if candidate_weight  second_best_weight:\n                    second_best_weight = candidate_weight\n\n        if second_best_weight == float('inf'):\n            results.append(-1)\n        else:\n            results.append(int(second_best_weight))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3253223"}]}