{"hands_on_practices": [{"introduction": "掌握Dijkstra算法的最好方法之一就是亲手模拟它的执行过程。这个练习将引导你逐步跟踪算法的核心逻辑：在一张加权图中，从指定的起点开始，算法在每一步中如何选择下一个要“确认”的节点。通过这个过程，你将对算法的贪心策略和优先级队列的运作方式建立起一个直观而坚实的理解。[@problem_id:1496482]", "problem": "一个分布式网络由六个数据中心组成，分别标记为 A、B、C、D、E 和 F，用于处理大规模计算。为了优化数据路由，从主数据中心 A 启动一个协议。该协议的目标是建立从 A 到网络中其他所有中心的最低成本通信路径。中心之间的连接是双向的，每条链路都有一个相关的延迟成本。\n\n网络拓扑和成本如下：\n- A 与 B 连接，成本为 2。\n- A 与 C 连接，成本为 5。\n- A 与 D 连接，成本为 9。\n- B 与 C 连接，成本为 2。\n- B 与 E 连接，成本为 7。\n- C 与 D 连接，成本为 3。\n- C 与 E 连接，成本为 1。\n- D 与 F 连接，成本为 2。\n- E 与 F 连接，成本为 4。\n\n该协议的运行方式是维护一组“未确认”的中心及其当前已知的从 A 出发的最低延迟成本。最初，除 A 之外的所有中心都是未确认的，其成本设置为无穷大，而 A 的成本为 0。在每个步骤中，协议选择当前成本最小的未确认中心，将其标记为“已确认”，并通过新确认的中心更新其未确认邻居的成本（如果找到了更短的路径）。这个过程会重复进行，直到所有中心都被确认为止。\n\n数据中心按此协议确认的顺序是什么？\n\nA. A, B, C, D, E, F\n\nB. A, B, C, E, D, F\n\nC. A, C, B, D, E, F\n\nD. A, B, D, C, E, F\n\nE. A, C, E, D, B, F", "solution": "我们将该协议解释为在以节点 A 为起点的无向加权图上运行的 Dijkstra 算法。令 $d(X)$ 表示从 A 到节点 $X$ 的当前已知最低成本。最初，设置 $d(A)=0$，对于所有其他节点，$d(B)=d(C)=d(D)=d(E)=d(F)=\\infty$。在每一步中，选择具有最小 $d(\\cdot)$ 值的未确认节点，确认它，并对其边进行松弛操作。\n\n初始化：\n$$d(A)=0,\\quad d(B)=\\infty,\\quad d(C)=\\infty,\\quad d(D)=\\infty,\\quad d(E)=\\infty,\\quad d(F)=\\infty.$$\n\n第 1 步 (确认 A)：使用成本为 2 的边 $A\\!-\\!B$、成本为 5 的边 $A\\!-\\!C$ 和成本为 9 的边 $A\\!-\\!D$ 更新邻居：\n$$d(B)=\\min(\\infty,0+2)=2,\\quad d(C)=\\min(\\infty,0+5)=5,\\quad d(D)=\\min(\\infty,0+9)=9.$$\n现在未确认节点的成本为：$d(B)=2$, $d(C)=5$, $d(D)=9$, $d(E)=\\infty$, $d(F)=\\infty$。成本最小的是 $B$。\n\n第 2 步 (确认 B)：对成本为 2 的边 $B\\!-\\!C$ 和成本为 7 的边 $B\\!-\\!E$ 进行松弛操作：\n$$d(C)=\\min(5,2+2)=4,\\quad d(E)=\\min(\\infty,2+7)=9.$$\n现在未确认节点的成本为：$d(C)=4$, $d(D)=9$, $d(E)=9$, $d(F)=\\infty$。成本最小的是 $C$。\n\n第 3 步 (确认 C)：对成本为 3 的边 $C\\!-\\!D$ 和成本为 1 的边 $C\\!-\\!E$ 进行松弛操作：\n$$d(D)=\\min(9,4+3)=7,\\quad d(E)=\\min(9,4+1)=5.$$\n现在未确认节点的成本为：$d(D)=7$, $d(E)=5$, $d(F)=\\infty$。成本最小的是 $E$。\n\n第 4 步 (确认 E)：对成本为 4 的边 $E\\!-\\!F$ 进行松弛操作：\n$$d(F)=\\min(\\infty,5+4)=9.$$\n未确认节点的成本为：$d(D)=7$, $d(F)=9$。成本最小的是 $D$。\n\n第 5 步 (确认 D)：对成本为 2 的边 $D\\!-\\!F$ 进行松弛操作：\n$$d(F)=\\min(9,7+2)=9.$$\n剩余未确认节点：$F$。\n\n第 6 步 (确认 F)：确认最后一个节点。\n\n确认顺序是 A、B、C、E、D、F，对应于选项 B。", "answer": "$$\\boxed{B}$$", "id": "1496482"}, {"introduction": "Dijkstra算法的强大之处不仅在于计算单一的最短路径长度，它实际上构建了一个从源节点到所有其他可达节点的完整“最短路径树”（Shortest Path Tree, SPT）。这个练习将帮助你理解这个重要的概念。你需要运行算法并确定构成这棵树的边，从而加深对算法如何一次性解决单源所有目的地最短路径问题的理解。[@problem_id:1496488]", "problem": "一位网络架构师正在分析一个小型数据中心的通信延迟。该网络被建模为一个无向图，其中顶点是服务器，边的权重表示所连接服务器之间的延迟（以毫秒为单位）。\n\n服务器集合为 $V = \\{A, B, C, D, E, F\\}$。\n\n连接及其对应的延迟如下：\n- (A, B)，延迟为 4\n- (A, C)，延迟为 2\n- (B, C)，延迟为 5\n- (B, D)，延迟为 10\n- (C, E)，延迟为 3\n- (D, E)，延迟为 4\n- (D, F)，延迟为 11\n- (E, F)，延迟为 6\n\n为了优化数据路由，该架构师使用Dijkstra算法计算从源服务器 'A' 到网络中所有其他服务器的最短通信路径。这些路径构成了一个以 'A' 为根的最短路径树。\n\n计算构成该最短路径树的所有唯一连接（边）的延迟（权重）之和。答案以毫秒表示。", "solution": "我们将网络建模为一个无向加权图，其中边的权重表示以毫秒为单位的延迟。为了计算以 $A$ 为根的最短路径树（SPT），我们应用Dijkstra算法。该算法为每个顶点 $v$ 维护一个临时距离 $d(v)$，初始化 $d(A)=0$ 以及对于 $v \\neq A$ 的顶点有 $d(v)=\\infty$，并迭代地选择具有最小临时距离的未确定顶点来松弛其关联边。父指针 $p(v)$ 记录产生当前最短路径估计的前驱节点；算法终止后，SPT由所有 $v \\neq A$ 的边 $\\{(v,p(v))\\}$ 组成。\n\n初始化：\n设置 $d(A)=0$，对于 $v \\in \\{B,C,D,E,F\\}$，设置 $d(v)=\\infty$ 和 $p(v)=\\varnothing$。\n\n迭代 1（确定 $A$，因为 $d(A)=0$ 是最小的）：\n松弛 $(A,B)$：因为 $d(B) > d(A)+w(A,B)$，即 $\\infty > 0+4$，更新 $d(B)=4$ 和 $p(B)=A$。\n松弛 $(A,C)$：因为 $d(C) > d(A)+w(A,C)$，即 $\\infty > 0+2$，更新 $d(C)=2$ 和 $p(C)=A$。\n\n未确定的顶点现在有 $d(B)=4$, $d(C)=2$, $d(D)=\\infty$, $d(E)=\\infty$, $d(F)=\\infty$。\n\n迭代 2（确定 $C$，因为 $d(C)=2$ 是最小的）：\n松弛 $(C,B)$：候选距离 $d(C)+w(C,B)=2+5=7$，但 $d(B)=4$，因此不更新。\n松弛 $(C,E)$：因为 $d(E) > d(C)+w(C,E)$，即 $\\infty > 2+3$，更新 $d(E)=5$ 和 $p(E)=C$。\n\n未确定的顶点现在有 $d(B)=4$, $d(E)=5$, $d(D)=\\infty$, $d(F)=\\infty$。\n\n迭代 3（确定 $B$，因为 $d(B)=4$ 是最小的）：\n松弛 $(B,D)$：因为 $d(D) > d(B)+w(B,D)$，即 $\\infty > 4+10$，更新 $d(D)=14$ 和 $p(D)=B$。\n\n未确定的顶点现在有 $d(E)=5$, $d(D)=14$, $d(F)=\\infty$。\n\n迭代 4（确定 $E$，因为 $d(E)=5$ 是最小的）：\n松弛 $(E,D)$：候选距离 $d(E)+w(E,D)=5+4=9$，这比 $d(D)=14$ 更优，因此更新 $d(D)=9$ 和 $p(D)=E$。\n松弛 $(E,F)$：因为 $d(F) > d(E)+w(E,F)$，即 $\\infty > 5+6$，更新 $d(F)=11$ 和 $p(F)=E$。\n\n未确定的顶点现在有 $d(D)=9$, $d(F)=11$。\n\n迭代 5（确定 $D$，因为 $d(D)=9$ 是最小的）：\n松弛 $(D,F)$：候选距离 $d(D)+w(D,F)=9+11=20$，但 $d(F)=11$，因此不更新。\n\n未确定的顶点现在有 $d(F)=11$。\n\n迭代 6（确定 $F$，因为 $d(F)=11$ 是最小的）：\n没有松弛操作可以改善任何距离。\n\n算法终止时，父指针定义了 SPT 的边：\n$(A,B)$，权重为 $4$，来自 $p(B)=A$，\n$(A,C)$，权重为 $2$，来自 $p(C)=A$，\n$(C,E)$，权重为 $3$，来自 $p(E)=C$，\n$(E,D)$，权重为 $4$，来自 $p(D)=E$，\n$(E,F)$，权重为 $6$，来自 $p(F)=E$。\n\n这些唯一连接的延迟总和为\n$$S = w(A,B)+w(A,C)+w(C,E)+w(E,D)+w(E,F) = 4+2+3+4+6 = 19.$$\n因此，最短路径树的总延迟和为 $19$ 毫秒。", "answer": "$$\\boxed{19}$$", "id": "1496488"}, {"introduction": "在掌握了基本应用之后，让我们来挑战一个更高级的问题。在许多现实场景中，我们不仅关心最短路径的长度，还可能想知道存在多少条不同的最短路径，例如在评估网络冗余度时。这个练习要求你对标准Dijkstra算法进行扩展，使其能够统计最短路径的数量。这是一项宝贵的算法设计技能，它展示了如何通过增强数据结构来解决更复杂的问题。[@problem_id:3227957]", "problem": "考虑一个带权有向图，其顶点集为 $V = \\{s, a, b, c, d, e, f, g, t\\}$，非负权重函数为 $w : V \\times V \\to \\mathbb{R}_{\\ge 0}$，定义在以下有向边上：\n$$\n(s,b): w(s,b) = 2,\\quad (s,c): w(s,c) = 2,\\quad (s,d): w(s,d) = 3,\n$$\n$$\n(b,e): w(b,e) = 2,\\quad (c,e): w(c,e) = 2,\\quad (b,f): w(b,f) = 3,\\quad (c,f): w(c,f) = 3,\\quad (d,f): w(d,f) = 1,\n$$\n$$\n(e,g): w(e,g) = 2,\\quad (f,g): w(f,g) = 2,\n$$\n$$\n(e,t): w(e,t) = 5,\\quad (f,t): w(f,t) = 5,\\quad (g,t): w(g,t) = 3,\\quad (d,t): w(d,t) = 7.\n$$\n未列出的所有其他点对 $(u,v)$ 之间没有边。路径的长度定义为其边权重之和。从 $s$ 到顶点 $x$ 的最短路径是指所有从 $s$ 到 $x$ 的路径中长度最小的任意一条路径。\n\n仅从带权图中最短路径的基本定义出发，并利用 Dijkstra 算法（该算法使用一个以暂定距离为键的优先队列（PQ））的一个不变量，即当一个顶点从优先队列中取出时，其到该顶点的最短路径距离便已确定，推导出一个对 Dijkstra 算法的修改，使其能够计算从 $s$ 到 $t$ 的不同最短路径的总数。然后，将你推导出的修改应用于上述图，以确定从 $s$ 到 $t$ 的不同最短路径的总数。假设优先队列中的平局情况任意处理；计数结果必须与平局处理方式无关。将最终答案表示为一个无单位的实数值。无需四舍五入。", "solution": "我们从核心定义开始。一个带权有向图 $(V,E,w)$ 有一个顶点集 $V$，一个有向边集 $E \\subseteq V \\times V$，以及一个非负权重函数 $w : E \\to \\mathbb{R}_{\\ge 0}$。对于一条路径 $P = \\langle v_{0}, v_{1}, \\dots, v_{k} \\rangle$，其中对所有 $i$ 都有 $(v_{i}, v_{i+1}) \\in E$，其长度为 $\\sum_{i=0}^{k-1} w(v_{i}, v_{i+1})$。从 $s$ 到 $x$ 的最短路径距离，记为 $d^{\\ast}(x)$，是 $\\min\\{\\text{length}(P) : P \\text{ is an } s\\text{-}x \\text{ path}\\}$。\n\nDijkstra 算法维护一个暂定距离数组 $d[v]$，初始化为 $d[s] = 0$ 以及对所有 $v \\neq s$ 有 $d[v] = \\infty$，以及一个以 $d[v]$ 为键的优先队列(PQ)。一个基本的不变量是：当一个顶点 $u$ 从优先队列中被取出时，$d[u] = d^{\\ast}(u)$，并且未来的任何松弛操作都无法减小 $d[u]$，因为所有边的权重都是非负的。\n\n为了计算不同最短路径的数量，我们用一个路径计数数组 $c[v]$ 来增强 Dijkstra 算法，其中 $c[v]$ 表示与当前已知的最优距离 $d[v]$ 一致的不同 $s$-$v$ 最短路径的数量。初始化为 $c[s] = 1$（到自身存在一条长度为 0 的空路径），且对所有 $v \\neq s$ 有 $c[v] = 0$。当对权重为 $w(u,v)$ 的边 $(u,v)$ 进行松弛操作时，我们考虑候选距离 $d[u] + w(u,v)$：\n- 如果 $d[u] + w(u,v)  d[v]$，那么我们找到了一条严格更短的 $s$-$v$ 路径。设置 $d[v] \\leftarrow d[u] + w(u,v)$ 并重置 $c[v] \\leftarrow c[u]$，因为现在每条 $s$-$v$ 最短路径都必须以 $(u,v)$ 结尾，并且由一条 $s$-$u$ 最短路径加上这条边构成。\n- 如果 $d[u] + w(u,v) = d[v]$，那么我们找到了其他长度相等的 $s$-$v$ 最短路径。将 $c[u]$ 加到 $c[v]$ 上，即 $c[v] \\leftarrow c[v] + c[u]$，因为每条 $s$-$u$ 最短路径都可以通过边 $(u,v)$ 扩展，从而得到一条不同的 $s$-$v$ 最短路径。\n\n正确性可以通过对从优先队列中取出顶点的顺序进行归纳来证明。基本情况是 $s$，此时 $d[s] = 0 = d^{\\ast}(s)$ 且 $c[s] = 1$。假设对于所有先前取出的顶点 $u$，我们有 $d[u] = d^{\\ast}(u)$ 且 $c[u]$ 等于不同的 $s$-$u$ 最短路径的数量。对于一次松弛操作 $(u,v)$，如果找到了一个严格更优的距离，所有先前的 $s$-$v$ 最短路径都变得不再是最短的，因此将 $c[v]$ 重置为 $c[u]$ 是必要且充分的，因为任何一条 $s$-$v$ 最短路径都必须经过某个先前已取出且其 $d[u]$ 已被最终确定的前驱节点 $u$，然后经过最后一条边 $(u,v)$；非负权重保证了当距离被最终确定时，这个结构在最终的最短路径有向无环图(DAG)中是无环的。如果找到了一个等长的距离，通过 $u$ 的路径是新的 $s$-$v$ 最短路径，与之前为 $v$ 计数的路径不同，因此相加可以累积正确的总数。当 $t$ 被取出或所有松弛操作完成时，$d[t] = d^{\\ast}(t)$ 并且 $c[t]$ 等于不同的 $s$-$t$ 最短路径的数量。\n\n现在我们将此修改应用于给定的图。我们明确地表示出顶点：$V = \\{s, b, c, d, e, f, g, t\\}$，其有向边和权重如下：\n$$\n(s,b) = 2, \\ (s,c) = 2, \\ (s,d) = 3;\n$$\n$$\n(b,e) = 2, \\ (c,e) = 2, \\ (b,f) = 3, \\ (c,f) = 3, \\ (d,f) = 1;\n$$\n$$\n(e,g) = 2, \\ (f,g) = 2;\n$$\n$$\n(e,t) = 5, \\ (f,t) = 5, \\ (g,t) = 3, \\ (d,t) = 7.\n$$\n\n初始化：\n- $d[s] = 0$, $c[s] = 1$.\n- 对于 $v \\in \\{b, c, d, e, f, g, t\\}$: $d[v] = \\infty$, $c[v] = 0$.\n\n松弛从 $s$ 出发的边：\n- $(s,b)$: $d[b] \\leftarrow 2$, $c[b] \\leftarrow 1$.\n- $(s,c)$: $d[c] \\leftarrow 2$, $c[c] \\leftarrow 1$.\n- $(s,d)$: $d[d] \\leftarrow 3$, $c[d] \\leftarrow 1$.\n\n取出 $d$ 值最小的顶点；假设平局任意处理。取出 $b$ ($d[b] = 2$):\n- $(b,e)$: 候选距离 $2 + 2 = 4  \\infty$，所以 $d[e] \\leftarrow 4$, $c[e] \\leftarrow c[b] = 1$.\n- $(b,f)$: 候选距离 $2 + 3 = 5  \\infty$，所以 $d[f] \\leftarrow 5$, $c[f] \\leftarrow c[b] = 1$.\n\n取出 $c$ ($d[c] = 2$):\n- $(c,e)$: 候选距离 $2 + 2 = 4 = d[e]$，所以 $c[e] \\leftarrow c[e] + c[c] = 1 + 1 = 2$.\n- $(c,f)$: 候选距离 $2 + 3 = 5 = d[f]$，所以 $c[f] \\leftarrow c[f] + c[c] = 1 + 1 = 2$.\n\n取出 $d$ ($d[d] = 3$):\n- $(d,f)$: 候选距离 $3 + 1 = 4  d[f] = 5$，所以 $d[f] \\leftarrow 4$, $c[f] \\leftarrow c[d] = 1$ (因找到更短距离而重置).\n- $(d,t)$: 候选距离 $3 + 7 = 10  \\infty$，所以 $d[t] \\leftarrow 10$, $c[t] \\leftarrow c[d] = 1$.\n\n接下来，优先队列中包含 $e$ ($d[e] = 4$)，$f$ ($d[f] = 4$)，$g$ ($d[g] = \\infty$)，$t$ ($d[t] = 10$)。取出 $e$ ($d[e] = 4$):\n- $(e,g)$: 候选距离 $4 + 2 = 6  \\infty$，所以 $d[g] \\leftarrow 6$, $c[g] \\leftarrow c[e] = 2$.\n- $(e,t)$: 候选距离 $4 + 5 = 9  d[t] = 10$，所以 $d[t] \\leftarrow 9$, $c[t] \\leftarrow c[e] = 2$.\n\n取出 $f$ ($d[f] = 4$):\n- $(f,g)$: 候选距离 $4 + 2 = 6 = d[g]$，所以 $c[g] \\leftarrow c[g] + c[f] = 2 + 1 = 3$.\n- $(f,t)$: 候选距离 $4 + 5 = 9 = d[t]$，所以 $c[t] \\leftarrow c[t] + c[f] = 2 + 1 = 3$.\n\n取出 $g$ ($d[g] = 6$):\n- $(g,t)$: 候选距离 $6 + 3 = 9 = d[t]$，所以 $c[t] \\leftarrow c[t] + c[g] = 3 + 3 = 6$.\n\n最后，取出 $t$ ($d[t] = 9$)；没有相关的出边松弛操作。算法终止时，$d[t] = 9$，这是从 $s$ 到 $t$ 的最短路径距离，而 $c[t] = 6$，是不同的 $s$-$t$ 最短路径的总数。\n\n我们可以交叉检查路径结构以确保没有重复计数：\n- 直接经由 $e$ 到 $t$ 的路径：从 $s$ 到 $e$ 有 $2$ 条最短路线 ($s \\to b \\to e$ 和 $s \\to c \\to e$)，每条路线通过边 $(e,t)$ 扩展，产生 $2$ 条不同的最短路径，总长度为 $4 + 5 = 9$。\n- 直接经由 $f$ 到 $t$ 的路径：到 $f$ 的唯一最短路线是 $s \\to d \\to f$ (长度 $3 + 1 = 4$)；通过边 $(f,t)$ 扩展，产生 $1$ 条长度为 $9$ 的最短路径。\n- 经由 $g$ 到 $t$ 的路径：到 $g$ 有 $3$ 条最短路线 (两条经由 $e$，一条经由 $f$)，每条路线通过边 $(g,t)$ 扩展，产生 $3$ 条不同的最短路径，长度为 $6 + 3 = 9$。\n总和 $2 + 1 + 3 = 6$ 与算法得出的 $c[t] = 6$ 一致。\n\n因此，在给定图中从 $s$ 到 $t$ 的不同最短路径的总数为 $6$。", "answer": "$$\\boxed{6}$$", "id": "3227957"}]}