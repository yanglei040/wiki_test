{"hands_on_practices": [{"introduction": "Dijkstra算法是计算非负权重图中最短路径的基石。然而，当图中存在多条权重相等的最短路径时，算法会如何选择？本练习 [@problem_id:3271591] 探讨了Dijkstra算法中一个微妙但关键的方面：决胜策略（tie-breaking rules）。你将分析不同的策略如何生成结构上不同但同样有效的最短路径树（SPT），并理解这些差异对后续的树算法（如最低公共祖先LCA查询）产生的实际影响。", "problem": "给定一个无向带权图，其顶点集为 $V = \\{0,1,2,3,4,5,6\\}$，边集包含以下边，每条边的权重均为 $1$：$(0,1)$, $(0,2)$, $(1,3)$, $(2,3)$, $(1,4)$, $(2,4)$, $(3,5)$, $(4,5)$, $(3,6)$, $(4,6)$。所有权重均为非负。考虑从源点 $0$ 开始运行 Dijkstra 算法来计算最短路径树 (SPT)，其中，SPT 是一个以源点为根的有向生成树，树中从根到任意顶点的唯一路径实现了给定图中的最短路径距离。假设 Dijkstra 算法采用标准定义：顶点从一个以当前临时距离为键的最小优先队列中提取，当发现一个严格更小的值时，通过边的松弛操作来更新临时距离。\n\n为了在存在多条等长最短路径时完全确定父节点的选择，我们考虑 Dijkstra 算法的两种变体，它们仅在确定性的平局打破规则上有所不同：\n\n- 变体 $\\mathsf{M}$ (最小索引)：优先队列在临时距离相等时，按较小的顶点索引打破平局；当松弛边 $(u,v)$ 产生一个与 $v$ 当前临时距离相等的临时距离时，当且仅当 $u$ 的索引小于 $v$ 当前父节点的索引时，算法才将 $u$ 作为 $v$ 的父节点。\n- 变体 $\\mathsf{X}$ (最大索引)：优先队列在临时距离相等时，按较大的顶点索引打破平局；当松弛边 $(u,v)$ 产生一个与 $v$ 当前临时距离相等的临时距离时，当且仅当 $u$ 的索引大于 $v$ 当前父节点的索引时，算法才将 $u$ 作为 $v$ 的父节点。\n\n设变体 $\\mathsf{M}$ 和 $\\mathsf{X}$ 输出的树分别为 $T_{\\mathsf{M}}$ 和 $T_{\\mathsf{X}}$，两者均以 $0$ 为根。考虑构建树路径查询数据结构，例如最近公共祖先 (LCA)，其中 LCA 表示有根树中两个节点的最近公共祖先；以及欧拉序加范围最小值查询 (RMQ)，其中 RMQ 表示范围最小值查询。\n\n下列哪些陈述是正确的？选择所有适用的选项。\n\nA. 变体 $\\mathsf{M}$ 和 $\\mathsf{X}$ 计算出到所有顶点的最短路径距离是相同的，但是当使用这两棵树本身作为 LCA 的有根结构时，$T_{\\mathsf{M}}$ 和 $T_{\\mathsf{X}}$ 对同一对顶点可能会得出不同的 LCA 答案。\n\nB. 变体 $\\mathsf{X}$ 可能会生成一棵对于此图而言不是有效 SPT 的生成树，因为某些顶点的距离相对于变体 $\\mathsf{M}$ 发生了变化。\n\nC. 无论使用 $T_{\\mathsf{M}}$ 还是 $T_{\\mathsf{X}}$，任何预处理和查询时间仅取决于顶点数量的 LCA 数据结构（例如，欧拉序加 RMQ 的预处理时间为 $O(n)$、查询时间为 $O(1)$，或二进制提升的预处理时间为 $O(n \\log n)$、查询时间为 $O(\\log n)$）都具有相同的渐近性能；但是，常数因子和确切的 LCA 结果可能会有所不同。\n\nD. 对于给定的图和源点 $0$，在 $T_{\\mathsf{M}}$ 中顶点 $5$ 和 $6$ 的 LCA 是顶点 $3$，而在 $T_{\\mathsf{X}}$ 中顶点 $5$ 和 $6$ 的 LCA 是顶点 $4$。\n\nE. 与任何其他有效的平局打破规则相比，使用最小索引平局打破规则 $\\mathsf{M}$ 总能最小化所得到的 SPT 的高度。\n\n答案选项：A, B, C, D, E。", "solution": "我们从基本原理开始分析：在一个具有非负边权重的图中，从一个源点到某个顶点的最短路径是所有此类路径中总权重最小的任意一条路径。Dijkstra 算法维护一个已确定距离（等于其最短路径距离）的顶点集合，并使用一个以临时距离为键的最小优先队列来提取下一个具有最小临时距离的顶点。它通过将 $v$ 的临时距离设置为 $\\min\\{ \\text{current tentative}(v), \\text{tentative}(u) + w(u,v) \\}$ 来松弛边 $(u,v)$，其中 $w(u,v)$ 是边的权重。在权重为非负的情况下，当一个顶点首次从优先队列中被提取时，其临时距离就等于其真实的最短路径距离。最短路径树 (SPT) 是以源点为根的任意一棵生成树，满足树中从源点到每个顶点的唯一路径的长度等于其在原始图中的最短路径距离。\n\n因为到同一个顶点可能存在多条总权重相等的不同最短路径，所以需要一个确定性的平局打破策略来明确地定义父指针。变体 $\\mathsf{M}$ 和 $\\mathsf{X}$ 仅在距离相等时的平局打破规则上有所不同；它们永远不会选择一个会增加距离的父节点，因为它们只在临时距离相等或严格更小的情况下才接受新的父节点。\n\n我们来分析给定的图。由于所有边的权重都是 $1$，且边只连接指定的相邻层，因此可以根据顶点与 $0$ 之间的最短路径距离将顶点分层：\n\n- 距离为 $1$ 的层：顶点 $1$ 和 $2$，因为 $(0,1)$ 和 $(0,2)$ 的权重为 $1$。\n- 距离为 $2$ 的层：顶点 $3$ 和 $4$，每个顶点都可以通过 $1$ 或 $2$ 到达，需要两跳权重为 $1$ 的边。\n- 距离为 $3$ 的层：顶点 $5$ 和 $6$，每个顶点都可以通过 $3$ 或 $4$ 到达，需要三跳权重为 $1$ 的边。\n\n形式上，唯一的最短路径距离函数 $d$ 满足 $d(0)=0$, $d(1)=d(2)=1$, $d(3)=d(4)=2$, $d(5)=d(6)=3$。这个结论源于边集所产生的三角不等式，以及图是无向的且所列边的权重均为 $1$ 这一事实：不可能存在更短的路径，因为没有权重为 $0$ 的边或能将跳数减少到这些值以下的直接连接。\n\n现在我们证明两种变体计算出的这些距离是相同的。Dijkstra 算法的正确性依赖于非负权重；下一个被提取的顶点总是具有已确定的最短距离。在这里，第一步，$0$ 以 $d(0)=0$ 被确定。然后 $1$ 和 $2$ 的临时距离被设为 $1$。两种变体都会从 $\\{1,2\\}$ 中提取下一个顶点，但区别在于先选择哪个距离相等的顶点：$\\mathsf{M}$ 在 $2$ 之前提取 $1$，而 $\\mathsf{X}$ 在 $1$ 之前提取 $2$。无论如何， $1$ 和 $2$ 最终都以距离 $1$ 被确定。接下来，从 $1$ 和 $2$ 进行松弛操作会得到 $3$ 和 $4$ 的临时距离为 $2$。然后它们以某种顺序以距离 $2$ 被确定。最后，从 $3$ 和 $4$ 进行松弛操作会得到 $5$ 和 $6$ 的临时距离为 $3$，然后它们以距离 $3$ 被确定。在任何时候，平局打破规则都不会选择一个严格更大的临时距离；因此两种变体计算出的距离标签 $d$ 是相同的。\n\n我们现在来描述父指针以及由此产生的树 $T_{\\mathsf{M}}$ 和 $T_{\\mathsf{X}}$。因为每条边的权重都是 $1$，并且每层的距离恰好增加 $1$，所以距离为 $k$ 的顶点的任何父节点都必须是距离为 $k-1$ 的邻居。在距离相等的情况下存在多种选择；平局打破规则将在它们之间做出决定。\n\n- 变体 $\\mathsf{M}$ 的行为：\n  - 提取 $0$ 后，松弛操作将临时父节点设为 $\\text{parent}(1)=0$ 和 $\\text{parent}(2)=0$。\n  - 在 $1$ 和 $2$ 之间，$\\mathsf{M}$ 首先提取 $1$ (索引较小)。松弛 $(1,3)$ 和 $(1,4)$ 将 $\\text{parent}(3)=1$ 和 $\\text{parent}(4)=1$ 设为临时距离 $2$ 的父节点。当稍后提取 $2$ 并松弛 $(2,3)$ 和 $(2,4)$ 时，候选距离等于当前的临时距离 ($2$)。$\\mathsf{M}$ 中的等值平局打破规则偏好索引较小的父节点，而该父节点已经是 $1$ 了，所以父节点保持为 $\\text{parent}(3)=1$ 和 $\\text{parent}(4)=1$。\n  - 对于顶点 $5$ 和 $6$，在提取 $3$ (它的索引比相同距离的 $4$ 小) 之后，松弛操作将 $\\text{parent}(5)=3$ 和 $\\text{parent}(6)=3$ 设为距离为 $3$ 的父节点。当 $4$ 稍后松弛 $(4,5)$ 和 $(4,6)$ 时，等值平局打破规则再次偏好索引较小的父节点，所以父节点保持为 $3$。\n  - 因此，$T_{\\mathsf{M}}$ 的父指针为：$\\text{parent}(1)=0$, $\\text{parent}(2)=0$, $\\text{parent}(3)=1$, $\\text{parent}(4)=1$, $\\text{parent}(5)=3$, $\\text{parent}(6)=3$。\n\n- 变体 $\\mathsf{X}$ 的行为：\n  - 提取 $0$ 后，松弛操作将临时父节点设为 $\\text{parent}(1)=0$ 和 $\\text{parent}(2)=0$。\n  - 在 $1$ 和 $2$ 之间，$\\mathsf{X}$ 首先提取 $2$ (索引较大)。松弛 $(2,3)$ 和 $(2,4)$ 将 $\\text{parent}(3)=2$ 和 $\\text{parent}(4)=2$ 设为距离为 $2$ 的父节点。当稍后提取 $1$ 并松弛 $(1,3)$ 和 $(1,4)$ 时，候选距离等于当前的临时距离 ($2$)；$\\mathsf{X}$ 中的等值平局打破规则偏好索引较大的父节点，所以父节点保持为 $2$。\n  - 对于顶点 $5$ 和 $6$，在相同距离的 $3$ 和 $4$ 之间，$\\mathsf{X}$ 首先提取 $4$ (索引较大)，将 $\\text{parent}(5)=4$ 和 $\\text{parent}(6)=4$ 设为距离为 $3$ 的父节点。当 $3$ 稍后松弛这些边时，等值平局打破规则偏好索引较大的父节点，所以父节点保持为 $4$。\n  - 因此，$T_{\\mathsf{X}}$ 的父指针为：$\\text{parent}(1)=0$, $\\text{parent}(2)=0$, $\\text{parent}(3)=2$, $\\text{parent}(4)=2$, $\\text{parent}(5)=4$, $\\text{parent}(6)=4$。\n\n这两棵树都是有效的 SPT，因为根据构造，在 $T_{\\mathsf{M}}$ 或 $T_{\\mathsf{X}}$ 中从 $0$ 到每个顶点 $v$ 的路径恰好有 $d(v)$ 条权重为 $1$ 的边，因此总权重为 $d(v)$，这等于最短路径距离。\n\n我们现在来研究最近公共祖先 (LCA) 的影响。在一棵有根树中，两个顶点 $u$ 和 $v$ 的 LCA 是同时作为两者祖先的唯一的、最深的顶点。在 $T_{\\mathsf{M}}$ 中，根是 $0$，深度（从根出发的边数）为 $\\text{depth}(0)=0$, $\\text{depth}(1)=\\text{depth}(2)=1$, $\\text{depth}(3)=\\text{depth}(4)=2$, $\\text{depth}(5)=\\text{depth}(6)=3$。此外，在 $T_{\\mathsf{M}}$ 中 $\\text{parent}(5)=3$ 且 $\\text{parent}(6)=3$，所以 $5$ 和 $6$ 的唯一最深公共祖先是 $3$。在 $T_{\\mathsf{X}}$ 中，$\\text{parent}(5)=4$ 且 $\\text{parent}(6)=4$，所以 $5$ 和 $6$ 的 LCA 是 $4$。因此，尽管图的距离是不变的，LCA 的答案可能会不同，因为它们依赖于具体的树结构。\n\n关于 LCA 的预处理和查询复杂度，经典方法如欧拉序加 RMQ (范围最小值查询) 可以实现 $O(n)$ 的预处理时间和 $O(1)$ 的查询时间，而二进制提升可以实现 $O(n \\log n)$ 的预处理时间和 $O(\\log n)$ 的查询时间，两者都是关于顶点数 $n$ 的函数。这些界限不依赖于树的精确形状，因此对于 $T_{\\mathsf{M}}$ 和 $T_{\\mathsf{X}}$ 来说，它们的渐近性能是相同的。然而，由于树的结构不同，常数因子（例如，欧拉序排列中的缓存行为或填充的祖先指针的确切集合）以及给定点对的特定 LCA 顶点结果可能会有所不同。\n\n我们现在逐一分析每个选项：\n\n- 选项 A：正确。如前所述，两种变体计算出的最短路径距离是相同的，因为带有非负权重的 Dijkstra 算法会确定真实的距离，而平局打破只在等距离的父节点中进行选择。然而，父节点的选择导致了不同的 SPT 形状，这可能并且确实会对相同的顶点对产生不同的 LCA 答案，例如 $\\text{LCA}(5,6)$。\n- 选项 B：不正确。变体 $\\mathsf{X}$ 绝不会接受一个导致严格更大临时距离的父节点；它只在距离相等时更改父节点，因此保留了最短路径距离。因此，它仍然会产生一个有效的 SPT。\n- 选项 C：正确。标准 LCA 数据结构的渐近预处理和查询时间取决于 $n$ (可能还有 $\\log n$)，而不取决于树的具体形状。虽然常数因子和 LCA 结果可能会改变，但对于 $T_{\\mathsf{M}}$ 和 $T_{\\mathsf{X}}$ 来说，大-$O$ 记法的时间界限保持不变。\n- 选项 D：正确。如前所示，$\\text{LCA}_{T_{\\mathsf{M}}}(5,6)=3$ 且 $\\text{LCA}_{T_{\\mathsf{X}}}(5,6)=4$。\n- 选项 E：不正确。最小索引平局打破规则通常不会最小化树的高度；不同的图在多种平局打破规则下可能产生相同高度的 SPT，也存在一些图，其不同的有效 SPT 可以有不同的高度，而选择最小索引的父节点并不一定能最小化高度。此外，在这个特定的图中，$T_{\\mathsf{M}}$ 和 $T_{\\mathsf{X}}$ 的高度均为 $3$。\n\n因此，正确的选项是 A、C 和 D。", "answer": "$$\\boxed{ACD}$$", "id": "3271591"}, {"introduction": "与Dijkstra算法不同，Bellman-Ford算法能够处理带有负权重边的图，这使其在更广泛的场景中非常有用。本练习 [@problem_id:3271593] 旨在加深你对Bellman-Ford算法核心工作机制的理解。通过手动模拟算法的同步迭代过程，你将亲身体验距离估计值如何逐轮收敛，并揭示算法收敛所需的迭代次数与图中“最长”的最短路径（以边数衡量）之间的内在联系。", "problem": "考虑以下有向加权图，其源顶点为 $s$，顶点集为 $\\{s,a,b,c,d,e,t\\}$。有向边及其权重如下：\n- $s \\to a$ 权重为 $2$， $s \\to b$ 权重为 $7$， $s \\to d$ 权重为 $15$，\n- $a \\to b$ 权重为 $-1$， $a \\to c$ 权重为 $2$， $a \\to d$ 权重为 $10$，\n- $b \\to c$ 权重为 $-2$， $b \\to e$ 权重为 $10$， $b \\to t$ 权重为 $6$，\n- $c \\to d$ 权重为 $1$， $c \\to t$ 权重为 $4$，\n- $d \\to e$ 权重为 $3$， $d \\to t$ 权重为 $0$，\n- $e \\to t$ 权重为 $-1$。\n\n假设从 $s$ 出发不存在可达的负权重环。我们从 $s$ 开始按如下方式运行 Bellman–Ford 算法（同步轮次）：设 $d^{(0)}(s)=0$ 且对于所有 $v \\neq s$，有 $d^{(0)}(v)=+\\infty$。对于每个迭代索引 $k \\geq 1$，通过对每条边进行一次松弛操作来为每个顶点 $v$ 计算一个新的距离标签 $d^{(k)}(v)$，但在评估第 $k$ 次迭代中的所有松弛操作时，仅使用前一次迭代 $d^{(k-1)}(\\cdot)$ 的标签。也就是说，在给定的迭代中，对一个顶点的更新不会影响同一次迭代中的另一次更新；所有更新在迭代结束时同时生效。\n\n你的任务是：\n- 确定第一个迭代索引 $k$，在此次迭代之后，所有标签 $d^{(k)}(v)$ 都稳定在从 $s$ 出发的最终单源最短路径距离上，并且在任何后续迭代中都不会再改变。\n- 从第一性原理出发，证明为什么这个 $k$ 与所有从 $s$ 可达的顶点 $v$ 的最小权重 $s \\to v$ 路径中，边数最多的那条路径的长度（以边数计）相吻合。\n\n给出 $k$ 的精确整数值作为最终答案（无需四舍五入）。", "solution": "该问题要求我们模拟同步 Bellman-Ford 算法，并确定所有距离标签稳定到其最终值的迭代次数 $k$。我们将逐轮跟踪每个顶点的距离标签 $d^{(k)}(v)$。\n\n**初始化 (k=0):**\n$d^{(0)}(s) = 0$, 其余所有顶点的 $d^{(0)}(v) = \\infty$。\n\n**迭代 k=1:**\n根据 $d^{(0)}$ 的值更新距离。只有源点 $s$ 的直接邻居会被更新。\n- $d^{(1)}(a) = d^{(0)}(s) + w(s,a) = 0 + 2 = 2$\n- $d^{(1)}(b) = d^{(0)}(s) + w(s,b) = 0 + 7 = 7$\n- $d^{(1)}(d) = d^{(0)}(s) + w(s,d) = 0 + 15 = 15$\n- 其他顶点仍为 $\\infty$。\n结果: $d^{(1)} = (s:0, a:2, b:7, c:\\infty, d:15, e:\\infty, t:\\infty)$。\n\n**迭代 k=2:**\n根据 $d^{(1)}$ 的值更新距离。\n- $d^{(2)}(b) = \\min(d^{(1)}(b), d^{(1)}(a) + w(a,b)) = \\min(7, 2 - 1) = 1$\n- $d^{(2)}(c) = \\min(d^{(1)}(c), d^{(1)}(a) + w(a,c), d^{(1)}(b) + w(b,c)) = \\min(\\infty, 2+2, 7-2) = 4$\n- $d^{(2)}(d) = \\min(d^{(1)}(d), d^{(1)}(a) + w(a,d)) = \\min(15, 2+10) = 12$\n- $d^{(2)}(e) = \\min(d^{(1)}(e), d^{(1)}(b) + w(b,e)) = \\min(\\infty, 7+10) = 17$\n- $d^{(2)}(t) = \\min(d^{(1)}(t), d^{(1)}(b) + w(b,t), d^{(1)}(d) + w(d,t)) = \\min(\\infty, 7+6, 15+0) = 13$\n结果: $d^{(2)} = (s:0, a:2, b:1, c:4, d:12, e:17, t:13)$。\n\n**迭代 k=3:**\n根据 $d^{(2)}$ 的值更新距离。\n- $d^{(3)}(c) = \\min(d^{(2)}(c), d^{(2)}(b) + w(b,c)) = \\min(4, 1 - 2) = -1$\n- $d^{(3)}(d) = \\min(d^{(2)}(d), d^{(2)}(c) + w(c,d)) = \\min(12, 4 + 1) = 5$\n- $d^{(3)}(e) = \\min(d^{(2)}(e), d^{(2)}(b) + w(b,e), d^{(2)}(d) + w(d,e)) = \\min(17, 1+10, 12+3) = 11$\n- $d^{(3)}(t) = \\min(d^{(2)}(t), d^{(2)}(b) + w(b,t), d^{(2)}(c) + w(c,t), d^{(2)}(d) + w(d,t)) = \\min(13, 1+6, 4+4, 12+0) = 7$\n结果: $d^{(3)} = (s:0, a:2, b:1, c:-1, d:5, e:11, t:7)$。\n\n**迭代 k=4:**\n根据 $d^{(3)}$ 的值更新距离。\n- $d^{(4)}(d) = \\min(d^{(3)}(d), d^{(3)}(c) + w(c,d)) = \\min(5, -1 + 1) = 0$\n- $d^{(4)}(e) = \\min(d^{(3)}(e), d^{(3)}(d) + w(d,e)) = \\min(11, 5 + 3) = 8$\n- $d^{(4)}(t) = \\min(d^{(3)}(t), d^{(3)}(c) + w(c,t), d^{(3)}(d) + w(d,t)) = \\min(7, -1+4, 5+0) = 3$\n结果: $d^{(4)} = (s:0, a:2, b:1, c:-1, d:0, e:8, t:3)$。\n\n**迭代 k=5:**\n根据 $d^{(4)}$ 的值更新距离。\n- $d^{(5)}(e) = \\min(d^{(4)}(e), d^{(4)}(d) + w(d,e)) = \\min(8, 0 + 3) = 3$\n- $d^{(5)}(t) = \\min(d^{(4)}(t), d^{(4)}(d) + w(d,t), d^{(4)}(e) + w(e,t)) = \\min(3, 0+0, 8-1) = 0$\n结果: $d^{(5)} = (s:0, a:2, b:1, c:-1, d:0, e:3, t:0)$。\n\n**迭代 k=6:**\n根据 $d^{(5)}$ 的值更新距离。\n- $d^{(6)}(e) = \\min(d^{(5)}(e), d^{(5)}(d)+w(d,e)) = \\min(3, 0+3) = 3$ (无变化)\n- $d^{(6)}(t) = \\min(d^{(5)}(t), d^{(5)}(e)+w(e,t)) = \\min(0, 3-1) = 0$ (无变化)\n所有其他顶点的距离也都没有发生变化。因此，在第5次迭代之后，所有距离标签都已稳定。\n**稳定所需的迭代次数 k 为 5。**\n\n**证明：**\n同步 Bellman-Ford 算法的一个基本性质是，经过 $k$ 轮迭代后，对于每个顶点 $v$，计算出的距离 $d^{(k)}(v)$ 等于从源点 $s$ 到 $v$ 的所有路径中，边数不超过 $k$ 的路径的最小权重。这可以通过对 $k$ 进行归纳来证明。\n- **基本情况 (k=1):** 算法发现了所有由1条边构成的最短路径。\n- **归纳步骤:** 假设在 $k-1$ 轮后，算法找到了所有边数不超过 $k-1$ 的最短路径。在第 $k$ 轮，对于任意一条由 $k$ 条边构成的路径 $s \\to \\dots \\to u \\to v$，其权重为 $\\delta(s,u) + w(u,v)$。根据归纳假设，$\\delta(s,u)$ 在第 $k-1$ 轮时已被发现，因此在第 $k$ 轮松弛边 $(u,v)$ 时，就能发现这条长度为 $k$ 的路径。\n\n在一个没有负权重环的图中，任何最短路径都是简单路径，其包含的边数最多为 $|V|-1$。设 $L$ 是所有从 $s$ 到图中任意其他顶点的真实最短路径中，包含边数最多的那条路径的边数。\n1.  根据上述性质，任何真实最短路径的权重最晚会在其边数所对应的迭代轮次被发现。因此，所有顶点的最终最短路径距离最晚会在第 $L$ 轮迭代后全部被计算出来。\n2.  同时，对于那条恰好包含 $L$ 条边的最短路径 $s \\to v_1 \\to \\dots \\to v_L$，其终点 $v_L$ 的最终距离的发现，依赖于一条从 $s$ 开始逐边传播的更新链。$v_1$ 的距离在第1轮确定， $v_2$ 在第2轮，...，$v_L$ 的最终距离不可能在第 $L$ 轮之前被确定。这意味着在第 $L-1$ 轮迭代之后，至少有一个顶点的距离标签尚未收敛。\n\n因此，所有距离标签恰好在第 $L$ 轮迭代后稳定下来。\n在本题中，最短路径及其边数如下：\n- $s \\to a$: 1边\n- $s \\to a \\to b$: 2边 (权重 $2-1=1$)\n- $s \\to a \\to b \\to c$: 3边 (权重 $1-2=-1$)\n- $s \\to a \\to b \\to c \\to d$: 4边 (权重 $-1+1=0$)\n- $s \\to a \\to b \\to c \\to d \\to e$: 5边 (权重 $0+3=3$)\n- $s \\to a \\to b \\to c \\to d \\to t$: 5边 (权重 $0+0=0$)\n\n这些路径的权重与我们最终计算出的 $d^{(5)}$ 向量中的值相匹配。其中，边数最多的最短路径有5条边。因此，算法需要 $k=5$ 轮才能保证所有这些路径被发现并稳定下来。这与我们的模拟结果一致。", "answer": "$$\\boxed{5}$$", "id": "3271593"}, {"introduction": "理论算法的真正力量在于其解决实际问题的能力。在现实世界中，选择一条“最佳”路径往往需要平衡多个目标，例如时间、成本和风险。本练习 [@problem_id:3271663] 是一个编码挑战，它将带你实践如何将一个多目标优化问题转化为标准的单源最短路径问题。你将通过实现加权标量化（scalarization）方法，使用Dijkstra算法来探索不同优化偏好下（例如，更看重时间还是更看重风险）最短路径的变化，从而体会到核心算法的灵活性和强大应用价值。", "problem": "给定一个有向图，每条边都标注了两个非负属性：距离和风险。通过使用非负系数将这两个属性标量化为单个非负边权重函数，定义了一个单源最短路径问题。从图路径成本在边上是可加的这一基础出发，以及最优路径是最小化总可加成本的路径这一定义出发，实现一个程序，该程序在多个标量化方案下计算固定源点的单源最短路径，并报告到所有顶点的距离。\n\n用作基本依据的定义：\n- 一个有向图是一个对偶 $G=(V,E)$，其中 $V$ 是顶点集，$E\\subseteq V\\times V$ 是有向边集。\n- 每条有向边 $e\\in E$ 有两个给定的非负属性：$\\mathrm{dist}(e)\\ge 0$ 和 $\\mathrm{risk}(e)\\ge 0$。\n- 对于非负系数 $\\alpha\\ge 0$ 和 $\\beta\\ge 0$，定义标量化边权重函数 $w_{\\alpha,\\beta}(e)=\\alpha\\cdot \\mathrm{dist}(e)+\\beta\\cdot \\mathrm{risk}(e)$。\n- 对于一条路径 $P=(e_1,e_2,\\dots,e_k)$，其在 $(\\alpha,\\beta)$下的总成本为 $W_{\\alpha,\\beta}(P)=\\sum_{i=1}^k w_{\\alpha,\\beta}(e_i)$。\n- 单源最短路径问题要求计算 $d_{\\alpha,\\beta}(v)$，即从一个固定源顶点 $s$ 到顶点 $v$ 的所有路径中的最小总成本 $W_{\\alpha,\\beta}(P)$。\n\n任务：\n- 仅使用上述基本定义和“可加的、非负的路径成本允许使用优先规则进行贪心松弛”这一经过充分检验的事实，设计一个算法，为几个给定的 $(\\alpha,\\beta)$ 对计算所有 $v\\in V$ 的 $d_{\\alpha,\\beta}(v)$，并将其实现为一个无需输入即可运行的完整程序。\n- 除了可加性和非负性之外，你不得假设任何其他公式；从这些原则推导出算法步骤。\n\n图的规格：\n- 顶点集 $V=\\{0,1,2,3,4,5,6\\}$，源点 $s=0$。\n- 具有属性 $(\\mathrm{dist},\\mathrm{risk})$ 的有向边 $E$ 如下，记为“从 $u$ 到 $v$ 为 $(d,r)$”：\n  - 从 $0$ 到 $1$ 为 $(2,8)$。\n  - 从 $0$ 到 $2$ 为 $(5,1)$。\n  - 从 $0$ 到 $3$ 为 $(4,4)$。\n  - 从 $0$ 到 $4$ 为 $(9,1)$。\n  - 从 $1$ 到 $3$ 为 $(2,7)$。\n  - 从 $1$ 到 $4$ 为 $(2,8)$。\n  - 从 $1$ 到 $5$ 为 $(7,2)$。\n  - 从 $2$ 到 $3$ 为 $(1,2)$。\n  - 从 $2$ 到 $4$ 为 $(5,1)$。\n  - 从 $2$ 到 $5$ 为 $(4,1)$。\n  - 从 $3$ 到 $4$ 为 $(2,4)$。\n  - 从 $3$ 到 $5$ 为 $(2,3)$。\n  - 从 $4$ 到 $6$ 为 $(3,9)$。\n  - 从 $5$ 到 $6$ 为 $(3,1)$。\n\n标量化参数测试套件：\n- 情况 1：$(\\alpha,\\beta)=(1,0)$。\n- 情况 2：$(\\alpha,\\beta)=(0,1)$。\n- 情况 3：$(\\alpha,\\beta)=(1,1)$。\n- 情况 4：$(\\alpha,\\beta)=(2,1)$。\n- 情况 5：$(\\alpha,\\beta)=(1,2)$。\n- 情况 6：$(\\alpha,\\beta)=(0,0)$。\n- 情况 7：$(\\alpha,\\beta)=(10,10)$。\n- 情况 8：$(\\alpha,\\beta)=(3,0.1)$。\n\n要求：\n- 对于每种情况，按顶点索引升序计算单源最短路径距离向量 $[d_{\\alpha,\\beta}(0),d_{\\alpha,\\beta}(1),d_{\\alpha,\\beta}(2),d_{\\alpha,\\beta}(3),d_{\\alpha,\\beta}(4),d_{\\alpha_,\\beta}(5),d_{\\alpha,\\beta}(6)]$，根据定义 $d_{\\alpha,\\beta}(0)=0$。\n- 所有算术都是无单位实数；不要四舍五入。\n- 最终输出格式：你的程序应生成单行输出，其中包含八个情况向量的结果，这些向量以逗号分隔，并用方括号括起来。具体而言，打印一行等于\n  $[[\\text{case1}], [\\text{case2}], [\\text{case3}], [\\text{case4}], [\\text{case5}], [\\text{case6}], [\\textcase7}], [\\text{case8}]]$\n  其中每个内部列表是该情况下的七个距离，写成没有单位的数字。不要包含任何空格。", "solution": "我们从有向图 $G=(V,E)$ 的基本定义出发，该图具有非负的边属性和可加的路径成本。在任何固定的非负对偶 $(\\alpha,\\beta)$ 下，路径 $P=(e_1,\\dots,e_k)$ 的总成本是 $W_{\\alpha,\\beta}(P)=\\sum_{i=1}^k w_{\\alpha,\\beta}(e_i)$，其中 $w_{\\alpha,\\beta}(e)=\\alpha\\cdot \\mathrm{dist}(e)+\\beta\\cdot \\mathrm{risk}(e)$。因为 $\\alpha\\ge 0$、$\\beta\\ge 0$ 且边属性是非负的，所以在所有指定的情况下，对于每条边 $e$ 都有 $w_{\\alpha,\\beta}(e)\\ge 0$。这包括退化情况 $(\\alpha,\\beta)=(0,0)$，此时所有边的 $w_{\\alpha,\\beta}(e)=0$。\n\n根据最优性原理和路径成本的可加性，从源点 $s$到任何顶点 $v$ 的最小路径成本 $d_{\\alpha,\\beta}(v)$ 满足：存在一条最优路径，其到该路径上任何中间顶点的真前缀本身也是最优的。此外，根据一个经过充分检验的事实，即非负边权重意味着延长路径不会减少其成本（单调性），我们可以采用一种贪心松弛策略：重复选择具有最小暂定距离的尚未最终确定的顶点，并松弛其出边。该策略通过一个优先队列实现。每次松弛都是应用不等式\n$$\nd_{\\alpha,\\beta}(v)\\le d_{\\alpha,\\beta}(u)+w_{\\alpha,\\beta}(u,v)\n$$\n对于每条边 $(u,v)\\in E$，当右侧值小于当前暂定值时进行严格改进。其正确性源于：对于非负权重，一旦顶点 $u$ 在所有未确定顶点中获得最小的暂定距离，任何通过其他未确定顶点到达 $u$ 的替代路径都无法产生更小的成本，因为那将需要经过一个暂定距离至少一样大的顶点，然后再增加一个非负的边权重，这与最小性相矛盾。\n\n基于这些原则的算法设计：\n- 对于每种情况 $(\\alpha,\\beta)$，在松弛过程中通过 $w_{\\alpha,\\beta}(e)=\\alpha\\cdot \\mathrm{dist}(e)+\\beta\\cdot \\mathrm{risk}(e)$ 即时形成隐式边权重，而不修改图。\n- 初始化所有 $v\\in V$ 的距离为 $d_{\\alpha,\\beta}(v)=+\\infty$，除了 $d_{\\alpha,\\beta}(s)=0$。\n- 使用一个以当前暂定距离为键的最小优先队列。弹出最小的元素，将其最终确定，并使用 $d_{\\alpha,\\beta}(v)\\gets \\min\\{d_{\\alpha,\\beta}(v), d_{\\alpha,\\beta}(u)+w_{\\alpha,\\beta}(u,v)\\}$ 松弛所有出边。\n- 继续此过程直到队列为空。\n\n复杂度：使用二叉堆优先队列，每种情况的运行时间为 $O\\big((|V|+|E|)\\log |V|\\big)$，对于 $T$ 种情况，总时间为 $O\\big(T\\cdot (|V|+|E|)\\log |V|\\big)$。\n\n关于 $(\\alpha,\\beta)$ 的敏感性推理：\n- 改变 $(\\alpha,\\beta)$ 会线性地改变每个边权重。随着 $(\\alpha,\\beta)$ 的变化，当距离和风险之间的不同权衡翻转候选路径成本的顺序时，最短路径树可能会改变。\n- 正尺度不变性：如果 $(\\alpha,\\beta)$ 乘以任何 $\\lambda>0$，则对所有边 $e$ 都有 $w_{\\lambda\\alpha,\\lambda\\beta}(e)=\\lambda\\cdot w_{\\alpha,\\beta}(e)$，因此每条路径的成本都乘以 $\\lambda$，从而保留了最小化路径的集合。因此，对所有 $v$ 都有 $d_{\\lambda\\alpha,\\lambda\\beta}(v)=\\lambda\\cdot d_{\\alpha,\\beta}(v)$。\n\n应用于给定图：\n- 顶点为 $V=\\{0,1,2,3,4,5,6\\}$，源点 $s=0$。\n- 边的 $(\\mathrm{dist},\\mathrm{risk})$ 属性：\n  $(0\\to 1):(2,8)$, $(0\\to 2):(5,1)$, $(0\\to 3):(4,4)$, $(0\\to 4):(9,1)$,\n  $(1\\to 3):(2,7)$, $(1\\to 4):(2,8)$, $(1\\to 5):(7,2)$,\n  $(2\\to 3):(1,2)$, $(2\\to 4):(5,1)$, $(2\\to 5):(4,1)$,\n  $(3\\to 4):(2,4)$, $(3\\to 5):(2,3)$,\n  $(4\\to 6):(3,9)$, $(5\\to 6):(3,1)$。\n\n对于每种情况，运行所述算法得到按顶点索引顺序 $[0,1,2,3,4,5,6]$ 的完整距离向量如下：\n- 情况 1, $(\\alpha,\\beta)=(1,0)$ (纯距离): $[0,2,5,4,4,6,7]$。\n- 情况 2, $(\\alpha,\\beta)=(0,1)$ (纯风险): $[0,8,1,3,1,2,3]$。\n- 情况 3, $(\\alpha,\\beta)=(1,1)$ (同等权重): $[0,10,6,8,10,11,15]$。\n- 情况 4, $(\\alpha,\\beta)=(2,1)$ (强调距离): $[0,12,11,12,19,19,26]$。\n- 情况 5, $(\\alpha,\\beta)=(1,2)$ (强调风险): $[0,18,7,12,11,13,18]$。\n- 情况 6, $(\\alpha,\\beta)=(0,0)$ (退化的零权重): $[0,0,0,0,0,0,0]$。\n- 情况 7, $(\\alpha,\\beta)=(10,10)$ (情况 3 的正尺度缩放): 根据尺度不变性，这等于情况 3 的 10 倍，即 $[0,100,60,80,100,110,150]$。\n- 情况 8, $(\\alpha,\\beta)=(3,0.1)$ (距离主导，带轻微风险惩罚): $[0,6.8,15.1,12.4,13.6,18.7,23.5]$。\n\n显示敏感性的解释要点：\n- 对于顶点 6，在 $(1,0)$ 下的最优路径是 $0\\to 1\\to 4\\to 6$，总距离为 7；而在 $(0,1)$ 下，最优路径是 $0\\to 2\\to 5\\to 6$，总风险为 3。在 $(2,1)$ 下，最佳路径变为 $0\\to 3\\to 5\\to 6$，在 $2\\mathrm{dist}+\\mathrm{risk}$ 度量下的总成本为 26，而在 $(3,0.1)$ 下，路径 $0\\to 1\\to 4\\to 6$ 再次成为首选，成本为 23.5。\n- 情况 7 在数值上确认了相对于情况 3 的尺度不变性。\n\n下面生成的程序实现了这一计算，并打印一行包含八个情况向量的输出，数字未经四舍五入且无空格，按要求的外层列表顺序排列。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Execution environment: Python 3.12, numpy 1.23.5 allowed but not required.\n# This program computes single-source shortest path distances for multiple\n# scalarizations of edge attributes (distance, risk) and prints the results\n# as a single line in the required format.\n\nimport heapq\nimport math\nimport numpy as np  # Allowed; not strictly required but imported per environment spec.\n\ndef dijkstra_scalarized(graph, n_vertices, source, alpha, beta):\n    \"\"\"Compute single-source shortest paths with edge weights w = alpha*dist + beta*risk.\"\"\"\n    dist = [math.inf] * n_vertices\n    dist[source] = 0.0\n    pq = [(0.0, source)]\n    visited = [False] * n_vertices\n    while pq:\n        d_u, u = heapq.heappop(pq)\n        if visited[u]:\n            continue\n        visited[u] = True\n        # If the popped distance is greater than recorded, skip (heap invariant)\n        if d_u > dist[u]:\n            continue\n        for v, d_attr, r_attr in graph.get(u, []):\n            w = alpha * d_attr + beta * r_attr\n            new_d = d_u + w\n            if new_d  dist[v]:\n                dist[v] = new_d\n                heapq.heappush(pq, (new_d, v))\n    return dist\n\ndef format_number(x):\n    \"\"\"Format numbers: integers without decimal point; otherwise compact float.\"\"\"\n    # Treat very small negative zeros as zero\n    if abs(x)  1e-15:\n        x = 0.0\n    # If x is very close to an integer, format as integer\n    r = round(x)\n    if math.isfinite(x) and abs(x - r)  1e-9:\n        return str(int(r))\n    # Otherwise use a compact representation with up to 12 significant digits\n    return format(x, '.12g')\n\ndef solve():\n    # Graph definition: adjacency list with tuples (to, distance, risk)\n    graph = {\n        0: [(1, 2.0, 8.0), (2, 5.0, 1.0), (3, 4.0, 4.0), (4, 9.0, 1.0)],\n        1: [(3, 2.0, 7.0), (4, 2.0, 8.0), (5, 7.0, 2.0)],\n        2: [(3, 1.0, 2.0), (4, 5.0, 1.0), (5, 4.0, 1.0)],\n        3: [(4, 2.0, 4.0), (5, 2.0, 3.0)],\n        4: [(6, 3.0, 9.0)],\n        5: [(6, 3.0, 1.0)],\n        6: []\n    }\n    n_vertices = 7\n    source = 0\n\n    # Test cases: list of (alpha, beta) pairs in the specified order.\n    test_cases = [\n        (1.0, 0.0),     # Case 1\n        (0.0, 1.0),     # Case 2\n        (1.0, 1.0),     # Case 3\n        (2.0, 1.0),     # Case 4\n        (1.0, 2.0),     # Case 5\n        (0.0, 0.0),     # Case 6\n        (10.0, 10.0),   # Case 7\n        (3.0, 0.1)      # Case 8\n    ]\n\n    all_results = []\n    for alpha, beta in test_cases:\n        dist = dijkstra_scalarized(graph, n_vertices, source, alpha, beta)\n        all_results.append(dist)\n\n    # Build the exact required output: one line, outer list of 8 inner lists, no spaces.\n    inner_lists_strings = []\n    for row in all_results:\n        nums = ','.join(format_number(x) for x in row)\n        inner_lists_strings.append(f\"[{nums}]\")\n    output = f\"[{','.join(inner_lists_strings)}]\"\n    print(output)\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3271663"}]}