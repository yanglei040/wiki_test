{"hands_on_practices": [{"introduction": "高效的数据操作，尤其是在不开辟额外存储空间的情况下，是算法设计中的一项核心技能。本练习将挑战你原地旋转一个二维矩阵，这要求你深入理解索引映射和数据移动的本质。通过识别和交换构成旋转周期的元素，你将学会一种优雅且节省内存的数组变换方法。[@problem_id:3254560]", "problem": "给定一个方形二维（2D）数组，该数组被解释为一个 $n \\times n$ 的网格，其两个维度的索引范围均为 $0$ 到 $n-1$，请设计并实现一个原地算法，将该数组顺时针旋转 $90$ 度（以度为单位）。该算法必须逐层进行，执行四元素循环，且不分配另一个数组，在进行四向交换时可以使用单个临时变量来暂存元素。使用以下基本原理：索引、排列以及由原始坐标到旋转后坐标的映射所引起的循环分解。\n\n将任何向数组单元格 $A[i][j]$ 赋值的操作定义为一次“写入”操作。为进行分析，定义以下指标：\n- 您的原地算法执行的数组写入总次数。\n- 最终索引与初始索引不同的独立元素数量（“移动元素计数”）。\n- 总曼哈顿位移，定义为所有单元格的原始索引 $(i,j)$ 与其旋转后索引 $(j, n-1-i)$ 之间的曼哈顿距离之和，即 $\\sum_{i=0}^{n-1} \\sum_{j=0}^{n-1} \\left( |i - j| + |j - (n-1 - i)| \\right)$。\n\n您的程序必须：\n1. 构建每个大小为 $n \\times n$ 的测试矩阵 $A$，其元素为 $A[i][j] = i \\cdot n + j$，其中 $0 \\le i, j  n$。\n2. 通过逐层的四元素循环，原地顺时针旋转矩阵 $A$ $90$ 度，并计算如上定义的数组写入的确切次数。\n3. 计算逐层算法执行的四元素循环次数。\n4. 仅使用映射 $(i,j) \\mapsto (j, n-1 - i)$ 和索引逻辑，计算移动元素的数量。\n5. 计算总曼哈顿位移 $\\sum_{i=0}^{n-1} \\sum_{j=0}^{n-1} \\left( |i - j| + |j - (n-1 - i)| \\right)$。\n6. 推导、证明并实现一个关于写入次数的封闭形式表达式（作为 $n$ 的函数），并验证测量的写入次数与此表达式是否匹配。同样地，推导并验证一个关于总曼哈顿位移的封闭形式表达式（作为 $n$ 的函数）。\n7. 对于每个测试用例，按顺序输出以下列表：\n   - 旋转后的数组按行主序展平，作为整数列表。\n   - 写入总次数（一个整数）。\n   - 执行的四元素循环总次数（一个整数）。\n   - 移动元素计数（一个整数）。\n   - 一个布尔值，指示测量的写入次数是否与您推导的写入次数封闭形式表达式匹配。\n   - 总曼哈顿位移（一个整数）。\n   - 一个布尔值，指示测量的曼哈顿位移是否与您推导的位移封闭形式表达式匹配。\n\n角度单位说明：使用度。不涉及物理单位。除展平的数组是整数列表外，所有输出都必须是无单位的整数或布尔类型。\n\n测试套件规范：\n- 使用 $n$ 值 $n \\in \\{1,2,3,4,5\\}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个测试用例结果本身都是一个严格按照上述顺序排列的列表。例如，最终输出必须是 $[\\text{result}_1,\\text{result}_2,\\dots,\\text{result}_k]$ 的形式，其中每个 $\\text{result}_t$ 是对应一个测试用例的列表。", "solution": "用户的问题是设计、实现并分析一个将方形 $n \\times n$ 矩阵顺时针旋转 $90$ 度的原地算法。该问题定义明确，具有科学依据，并提供了足够详细的信息以获得唯一且可验证的解。\n\n### 1. 作为排列的旋转变换\n一个 $n \\times n$ 网格的 $90$ 度顺时针旋转将一个位于初始坐标 $(i, j)$ 的元素映射到最终坐标 $(i', j')$。变换规则如下：\n$$ T: (i, j) \\mapsto (i', j') = (j, n-1-i) $$\n其中索引 $i, j, i', j'$ 的范围是从 $0$ 到 $n-1$。这个变换 $T$ 是 $n^2$ 个索引对集合上的一个排列。为了理解这个排列的结构，我们分析它的循环分解。将变换应用四次可得：\n1.  $T(i, j) = (j, n-1-i)$\n2.  $T^2(i, j) = T(j, n-1-i) = (n-1-i, n-1-j)$\n3.  $T^3(i, j) = T(n-1-i, n-1-j) = (n-1-j, n-1-(n-1-i)) = (n-1-j, i)$\n4.  $T^4(i, j) = T(n-1-j, i) = (i, n-1-(n-1-j)) = (i, j)$\n\n由于 $T^4$ 是恒等变换，该排列中所有循环的长度都是 $4$ 的约数，即长度为 $1$、$2$ 或 $4$。\n- 长度为 $1$ 的循环是一个不动点，其中 $T(i, j) = (i, j)$。这要求 $(i, j) = (j, n-1-i)$，即 $i=j$ 且 $i = n-1-i$，或 $2i = n-1$。只有当 $n-1$ 是偶数时，即 $n$ 是奇数时，$i$ 才有整数解。如果 $n$ 是奇数，唯一的不动点是矩阵的中心，位于 $(\\frac{n-1}{2}, \\frac{n-1}{2})$。如果 $n$ 是偶数，则没有不动点。\n- 长度为 $2$ 的循环需要 $T^2(i, j) = (i, j)$ 但 $T(i, j) \\neq (i, j)$。这意味着 $(n-1-i, n-1-j) = (i, j)$，所以 $i = n-1-i$ 且 $j=n-1-j$，得出 $2i = n-1$ 和 $2j = n-1$。这意味着长度为 $2$ 的循环只可能在 $n$ 为奇数时存在，并且会涉及中心元素，而中心元素是一个不动点。因此，不存在长度为 2 的循环。\n\n因此，该排列完全由 4 元素循环组成，并且如果 $n$ 是奇数，则还包含一个 1 元素循环（一个不动点）。\n\n### 2. 原地算法：逐层循环交换\n问题要求一个逐层进行的原地算法。一个 $n \\times n$ 的矩阵包含 $\\lfloor n/2 \\rfloor$ 个同心方形“层”。设最外层为第 $k=0$ 层，下一层为 $k=1$，以此类推，直到 $k = \\lfloor n/2 \\rfloor - 1$。\n\n对于每一层 $k$，我们可以沿其上边缘迭代，以识别出不同的 4 元素循环。第 $k$ 层的上边缘元素位于坐标 $(k, j)$，其中 $j$ 的范围是从 $k$ 到 $n-1-k$。为避免每个循环被处理四次，我们只为上边缘的元素（不包括最后一个元素，因为它是由左边缘元素发起的循环的一部分）启动循环交换。我们迭代 $j$ 从 $k$ 到 $n-2-k$。这为第 $k$ 层提供了 $n-2k-1$ 个循环。\n\n对于每个起始元素 $(k, j)$，其循环中的四个元素是：\n- $p_1 = (k, j)$\n- $p_2 = (j, n-1-k)$\n- $p_3 = (n-1-k, n-1-j)$\n- $p_4 = (n-1-j, k)$\n\n为实现旋转 $v_1 \\to p_2, v_2 \\to p_3, v_3 \\to p_4, v_4 \\to p_1$ 的四向交换，可以通过一个临时变量和四次数组写入来实现：\n1.  `temp = A[p_1]`\n2.  `A[p_1] = A[p_4]` (写入 1)\n3.  `A[p_4] = A[p_3]` (写入 2)\n4.  `A[p_3] = A[p_2]` (写入 3)\n5.  `A[p_2] = temp` (写入 4)\n\n### 3. 封闭形式表达式的推导\n\n#### 循环次数和写入次数\n第 $k$ 层的 4 元素循环数量为 $n-2k-1$。总循环次数是所有层的总和：\n$$ \\text{Cycles} = \\sum_{k=0}^{\\lfloor n/2 \\rfloor - 1} (n - 2k - 1) $$\n令 $m = \\lfloor n/2 \\rfloor$。该和为 $\\sum_{k=0}^{m-1} (n-1) - 2\\sum_{k=0}^{m-1} k = m(n-1) - 2\\frac{(m-1)m}{2} = m(n-1 - (m-1)) = m(n-m)$。\n- 如果 $n$ 是偶数，$n=2p$，则 $m=p$。循环数 = $p(2p-p) = p^2 = (n/2)^2 = n^2/4$。\n- 如果 $n$ 是奇数，$n=2p+1$，则 $m=p$。循环数 = $p(2p+1-p) = p(p+1) = \\frac{n-1}{2}(\\frac{n+1}{2}) = \\frac{n^2-1}{4}$。\n一个表示循环次数的统一表达式是 $\\lfloor n^2/4 \\rfloor$。\n\n由于每个循环需要 $4$ 次写入，总写入次数为：\n$$ \\text{Writes} = 4 \\times \\lfloor n^2/4 \\rfloor $$\n- 如果 $n$ 是偶数，写入次数 = $4 \\times (n^2/4) = n^2$。\n- 如果 $n$ 是奇数，写入次数 = $4 \\times ((n^2-1)/4) = n^2-1$。\n\n#### 移动元素计数\n如果一个元素不是旋转的不动点，它就会移动。如前所述，当且仅当 $n$ 为奇数时，存在一个不动点。元素总数为 $n^2$。\n- 如果 $n$ 是偶数，有 $0$ 个不动点。所有 $n^2$ 个元素都移动。\n- 如果 $n$ 是奇数，有 $1$ 个不动点。其余 $n^2-1$ 个元素移动。\n因此，移动元素的计数为 $n^2$（对于偶数 $n$）或 $n^2-1$（对于奇数 $n$）。这与总写入次数相同。\n\n#### 总曼哈顿位移\n总曼哈顿位移定义为：\n$$ D(n) = \\sum_{i=0}^{n-1} \\sum_{j=0}^{n-1} \\left( |i - j| + |j - (n-1 - i)| \\right) $$\n这个和可以分解为：\n$$ D(n) = \\sum_{i=0}^{n-1} \\sum_{j=0}^{n-1} |i - j| + \\sum_{i=0}^{n-1} \\sum_{j=0}^{n-1} |j - (n-1 - i)| $$\n让我们分析第二项。通过设 $k = n-1-i$，当 $i$ 从 $0$ 到 $n-1$ 变化时，$k$ 从 $n-1$ 到 $0$ 变化。该和与求和顺序无关。\n$$ \\sum_{i=0}^{n-1} \\sum_{j=0}^{n-1} |j - (n-1 - i)| = \\sum_{k=0}^{n-1} \\sum_{j=0}^{n-1} |j - k| $$\n这与第一项相同。因此，$D(n) = 2 \\sum_{i=0}^{n-1} \\sum_{j=0}^{n-1} |i - j|$。\n对于固定的 $i$，内层和为 $\\sum_{j=0}^{n-1} |i-j| = \\sum_{j=0}^{i-1} (i-j) + \\sum_{j=i+1}^{n-1} (j-i) = \\frac{i(i+1)}{2} + \\frac{(n-1-i)(n-i)}{2}$。\n对所有 $i$ 求和：\n$$ \\sum_{i=0}^{n-1} \\sum_{j=0}^{n-1} |i - j| = \\sum_{i=0}^{n-1} \\left( \\frac{i(i+1)}{2} \\right) + \\sum_{i=0}^{n-1} \\left( \\frac{(n-1-i)(n-i)}{2} \\right) $$\n右边的两个和是等价的。所以总和是 $2 \\sum_{i=0}^{n-1} \\frac{i(i+1)}{2} = \\sum_{i=0}^{n-1} (i^2+i) = \\sum_{i=0}^{n-1} i^2 + \\sum_{i=0}^{n-1} i$。\n使用幂和公式，对于从 $0$ 到 $n-1$ 的求和：\n$$ \\sum_{i=0}^{n-1} i = \\frac{(n-1)n}{2} \\quad \\text{和} \\quad \\sum_{i=0}^{n-1} i^2 = \\frac{(n-1)n(2n-1)}{6} $$\n和 $\\sum_{i,j} |i-j|$ 变为：\n$$ \\frac{(n-1)n(2n-1)}{6} + \\frac{(n-1)n}{2} = \\frac{n(n-1)}{6} ( (2n-1) + 3) = \\frac{n(n-1)(2n+2)}{6} = \\frac{n(n-1)2(n+1)}{6} = \\frac{n(n^2-1)}{3} $$\n最后，总曼哈顿位移为：\n$$ D(n) = 2 \\times \\frac{n(n^2-1)}{3} = \\frac{2n(n^2-1)}{3} $$\n乘积 $n(n-1)(n+1)$ 是三个连续整数的乘积，它总能被 $3! = 6$ 整除。因此，$D(n)$ 总是一个整数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the matrix rotation problem for the specified test cases.\n    \"\"\"\n    test_cases_n = [1, 2, 3, 4, 5]\n    all_results = []\n\n    for n in test_cases_n:\n        # 1. Construct the matrix A\n        A = np.arange(n * n, dtype=np.int64).reshape((n, n))\n\n        # 6. Derive closed-form expressions\n        # Number of 4-element cycles\n        closed_form_cycles = n**2 // 4\n        \n        # Total number of writes\n        if n % 2 == 0:\n            closed_form_writes = n**2\n        else:\n            closed_form_writes = n**2 - 1\n            \n        # Total Manhattan displacement\n        closed_form_displacement = (2 * n * (n**2 - 1)) // 3\n\n        # 2. Rotate A in-place and count writes\n        measured_writes = 0\n        num_layers = n // 2\n        for k in range(num_layers):\n            # Iterate through elements on one side of the layer k to start cycles\n            for j in range(k, n - 1 - k):\n                # Cycle positions\n                p1 = (k, j)\n                p2 = (j, n - 1 - k)\n                p3 = (n - 1 - k, n - 1 - j)\n                p4 = (n - 1 - j, k)\n                \n                # Perform 4-way swap using a temporary variable\n                temp = A[p1]\n                A[p1] = A[p4]\n                A[p4] = A[p3]\n                A[p3] = A[p2]\n                A[p2] = temp\n                \n                # Each swap involves 4 write operations as defined\n                measured_writes += 4\n        \n        # 3. Compute the number of four-element cycles\n        # Since each cycle involves 4 writes, we can calculate this from the write count.\n        measured_cycles = measured_writes // 4\n\n        # 4. Compute the moved element count\n        moved_element_count = 0\n        for i in range(n):\n            for j in range(n):\n                # The mapping is (i, j) -> (j, n-1-i)\n                rot_i, rot_j = j, n - 1 - i\n                if i != rot_i or j != rot_j:\n                    moved_element_count += 1\n        \n        # 5. Compute the total Manhattan displacement\n        measured_displacement = 0\n        for i in range(n):\n            for j in range(n):\n                rot_i, rot_j = j, n - 1 - i\n                measured_displacement += abs(i - rot_i) + abs(j - rot_j)\n\n        # 7. Verification and final output assembly\n        writes_match = (measured_writes == closed_form_writes) and (measured_cycles == closed_form_cycles)\n        disp_match = (measured_displacement == closed_form_displacement)\n\n        result_for_n = [\n            A.flatten().tolist(),\n            measured_writes,\n            measured_cycles,\n            moved_element_count,\n            writes_match,\n            int(measured_displacement),\n            disp_match\n        ]\n        all_results.append(result_for_n)\n\n    # Final print statement must produce a single line with the specified format\n    # The default str() for a list produces a string '[...]' which matches the needed format when joined.\n    final_output_str = f\"[{','.join(map(str, all_results))}]\"\n    print(final_output_str)\n\nsolve()\n```", "id": "3254560"}, {"introduction": "在图像处理和数据分析等领域，计算数组中某个矩形区域内元素的总和是一项常见任务。如果对每个查询都天真地遍历求和，效率会非常低下。本练习将介绍一种强大的预计算技术——积分图（或称总和面积表），它允许你在常数时间 $O(1)$ 内响应任何矩形区域的求和查询，完美体现了预处理与查询效率之间的权衡。[@problem_id:3254618]", "problem": "考虑一个矩形二维数组 $A$，维度 $d=2$，其中 $A \\in \\mathbb{Z}^{n \\times m}$ 使用从0开始的包含性坐标进行索引。任务是设计、推导并实现一个方法，在经过一次性预处理步骤后，能够以常数时间回答关于 $A$ 的任意轴对齐矩形和查询。请从基本定义和容斥原理出发，不要假设任何预先推导出的公式。\n\n基本概念：\n- 定义 $A$ 的一个条目子集上的矩形和如下。对于索引 $r_1, r_2, c_1, c_2$ 满足 $0 \\le r_1 \\le r_2  n$ 和 $0 \\le c_1 \\le c_2  m$，矩形和为\n$$\nS(r_1, c_1, r_2, c_2) = \\sum_{i=r_1}^{r_2} \\sum_{j=c_1}^{c_2} A[i,j].\n$$\n- 定义一个由 $A$ 构建的二维前缀和数组（也称为积分图）$P \\in \\mathbb{Z}^{(n+1) \\times (m+1)}$，使得 $P$ 的每个条目编码了 $A$ 中一个左上角位于原点的连续子数组的和。为 $P$ 使用1-based填充以避免边界特殊情况，因此 $P$ 的行索引范围从 $0$ 到 $n$，列索引范围从 $0$ 到 $m$，并且 $P[0,\\cdot] = 0$ 和 $P[\\cdot,0] = 0$。\n\n你的任务：\n1. 仅使用上述定义和容斥原理，推导一个用 $P$ 表示 $S(r_1, c_1, r_2, c_2)$ 的公式，该公式每次查询的时间复杂度为 $O(1)$。你的推导必须逻辑严谨，并基于求和性质和容斥原理；不要引入或假设任何快捷公式。\n2. 从第一性原理出发，推导用 $A$ 构建 $P$ 的递推关系，以确保 $P$ 的所有条目都是正确的。清楚地解释为什么这个构建过程需要 $O(nm)$ 的时间。\n3. 实现一个程序，该程序：\n   - 从每个测试用例的 $A$ 构建 $P$。\n   - 使用你推导的基于 $P$ 的容斥公式，在 $O(1)$ 时间内计算指定的矩形和查询 $S(r_1, c_1, r_2, c_2)$。\n   - 对所有提供的测试用例，按其出现顺序，生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表。\n\n索引和正确性要求：\n- 对 $A$ 的矩形查询使用从0开始的包含性索引 $(r_1, c_1, r_2, c_2)$。\n- 按照规定为 $P$ 使用1-based填充，以避免模糊的边界情况。\n- 所有数组和索引的处理必须与所述约定保持一致。\n\n测试套件：\n- 测试用例 $1$：$n = 3$, $m = 4$，矩阵 $A^{(1)}$ 的值为 $[[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]$，查询 $(1, 1, 2, 3)$。\n- 测试用例 $2$：与 $A^{(1)}$ 相同，查询 $(0, 0, 2, 3)$。\n- 测试用例 $3$：与 $A^{(1)}$ 相同，查询 $(0, 0, 0, 0)$。\n- 测试用例 $4$：$n = 2$, $m = 2$，矩阵 $A^{(4)}$ 的值为 $[[-1, 2], [3, -4]]$，查询 $(0, 0, 1, 1)$。\n- 测试用例 $5$：$n = 3$, $m = 3$，矩阵 $A^{(5)}$ 的值为 $[[0, 0, 0], [0, 1, 0], [0, 0, 0]]$，查询 $(0, 0, 1, 2)$。\n\n预期输出格式：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[\\text{result}_1,\\text{result}_2,\\text{result}_3]$）。每个 $\\text{result}_k$ 必须是第 $k$ 个测试用例对应的矩形和 $S(r_1, c_1, r_2, c_2)$ 的整数值，并按上述顺序排列。", "solution": "该问题陈述经评估为**有效**。它在科学上基于计算机科学和数学的既定原则，特别是关于数据结构（多维数组）和算法（前缀和）。该问题提法得当，具有清晰、无歧义的定义、一致的约束和一组可验证的测试用例。它是自洽的，不需要外部信息或主观解释。因此，可以推导并实现一个形式化的解决方案。\n\n按要求，推导和实现分两个阶段进行：推导常数时间查询公式和线性时间构建递推式，然后进行实现。\n\n### 1. 常数时间查询公式的推导\n\n目标是使用一个预计算的前缀和数组 $P$ 在 $O(1)$ 时间内计算任意矩形子数组的和 $S(r_1, c_1, r_2, c_2)$。\n\n**前缀和数组（$P$）的定义**\n\n问题定义了一个带有1-based填充的前缀和数组 $P \\in \\mathbb{Z}^{(n+1) \\times (m+1)}$。$P[i,j]$ 处的值表示原数组 $A$ 中从原点 $(0,0)$ 到点 $(i-1, j-1)$（含边界）的矩形内所有元素的和。形式上，对于 $i  0$ 和 $j  0$：\n$$\nP[i, j] = \\sum_{k=0}^{i-1} \\sum_{l=0}^{j-1} A[k,l]\n$$\n填充确保了当 $i=0$ 或 $j=0$ 时 $P[i,j] = 0$。这个约定通过消除进行边界检查的需要，简化了查询公式。\n\n**使用容斥原理进行推导**\n\n查询要求计算和 $S(r_1, c_1, r_2, c_2) = \\sum_{i=r_1}^{r_2} \\sum_{j=c_1}^{c_2} A[i,j]$。这个和对应于由角点 $(r_1, c_1)$ 和 $(r_2, c_2)$ 定义的矩形区域的和。我们可以通过从一个始于 $(0,0)$ 的更大矩形开始，并系统地减去不在查询矩形内的部分来计算这个和。这是容斥原理的直接应用。\n\n我们定义一个辅助函数 $Sum(r, c) = \\sum_{k=0}^{r} \\sum_{l=0}^{c} A[k,l]$，它表示从 $(0,0)$ 到 $(r,c)$ 的矩形区域的和。用我们的前缀和数组 $P$ 来表示，即为 $Sum(r, c) = P[r+1, c+1]$。\n\n所求的和 $S(r_1, c_1, r_2, c_2)$ 可以被看作是一个大矩形的面积，减去其两个较小的相邻矩形的面积，再加上一个因被重复减去而需要加回来的小角矩形的面积。\n\n1.  **包含大矩形：** 从原点 $(0,0)$ 到查询矩形右下角 $(r_2, c_2)$ 的所有元素之和开始。这个和是 $Sum(r_2, c_2) = P[r_2+1, c_2+1]$。这个区域，我们称之为 $D$，包含了所求矩形以及其他三个区域。\n\n2.  **排除顶部矩形：** 查询矩形上方的区域从 $(0,0)$ 延伸到 $(r_1-1, c_2)$。其和为 $Sum(r_1-1, c_2) = P[(r_1-1)+1, c_2+1] = P[r_1, c_2+1]$。我们称这个区域为 $C$。减去此区域会移除目标矩形上方的元素。\n\n3.  **排除左侧矩形：** 查询矩形左侧的区域从 $(0,0)$ 延伸到 $(r_2, c_1-1)$。其和为 $Sum(r_2, c_1-1) = P[r_2+1, (c_1-1)+1] = P[r_2+1, c_1]$。我们称这个区域为 $B$。减去此区域会移除目标矩形左侧的元素。\n\n4.  **重新包含被双重排除的角：** 当我们减去顶部矩形 ($C$) 和左侧矩形 ($B$) 时，我们减去了它们的交集两次。这个交集是从 $(0,0)$ 到 $(r_1-1, c_1-1)$ 的小矩形。其和为 $Sum(r_1-1, c_1-1) = P[(r_1-1)+1, (c_1-1)+1] = P[r_1, c_1]$。我们称这个区域为 $A$。为了纠正双重减法，我们必须将这个和加回来一次。\n\n结合这些步骤，得到最终公式：\n$$\nS(r_1, c_1, r_2, c_2) = D - B - C + A\n$$\n$$\nS(r_1, c_1, r_2, c_2) = P[r_2+1, c_2+1] - P[r_2+1, c_1] - P[r_1, c_2+1] + P[r_1, c_1]\n$$\n该公式在预计算数组 $P$ 中需要恰好4次查找和3次算术运算（两次减法，一次加法）。由于这些操作耗时为常数时间，任何查询都可以在 $O(1)$ 时间内回答。使用带填充的数组 $P$ 优雅地处理了 $r_1=0$ 或 $c_1=0$ 的情况，因为像 $P[r_2+1, 0]$ 或 $P[0, c_2+1]$ 这样的相应项会正确地计算为 $0$。\n\n### 2. 前缀和数组构建递推式的推导\n\n第二个任务是推导一个递推关系，以便在 $O(nm)$ 时间内从输入数组 $A$ 构建前缀和数组 $P$。\n\n根据 $P$ 的定义，单个元素 $A[i-1, j-1]$ 的值可以用 $P$ 中的值来表示。这等价于将我们的查询公式应用于一个 $1 \\times 1$ 的矩形：\n$$\nA[i-1, j-1] = S(i-1, j-1, i-1, j-1)\n$$\n使用推导出的公式，其中 $r_1=r_2=i-1$ 且 $c_1=c_2=j-1$：\n$$\nA[i-1, j-1] = P[(i-1)+1, (j-1)+1] - P[(i-1)+1, (j-1)] - P[(i-1), (j-1)+1] + P[(i-1), (j-1)]\n$$\n$$\nA[i-1, j-1] = P[i, j] - P[i, j-1] - P[i-1, j] + P[i-1, j-1]\n$$\n我们的目标是找到 $P[i,j]$ 的递推式。我们可以重新整理上述方程来求解 $P[i,j]$：\n$$\nP[i,j] = A[i-1, j-1] + P[i-1, j] + P[i, j-1] - P[i-1, j-1]\n$$\n这就是所求的递推关系。它表明，到 $A$ 的单元格 $(i-1, j-1)$ 为止的前缀和可以由当前元素 $A[i-1, j-1]$ 以及 $P$ 中三个相邻的、先前已计算出的前缀和计算得出：上方的值 ($P[i-1,j]$)、左侧的值 ($P[i,j-1]$) 和左上对角的值 ($P[i-1, j-1]$)。\n\n要构建整个数组 $P$，我们可以遍历其索引，让 $i$ 从 $1$ 到 $n$，$j$ 从 $1$ 到 $m$，并在每一步应用这个递推式。基本情况是填充的行和列，它们被初始化为 $0$。\n一个嵌套循环结构计算 $P$ 中所有 $n \\times m$ 个非填充条目：\n```\nfor i from 1 to n:\n  for j from 1 to m:\n    P[i,j] = A[i-1, j-1] + P[i-1,j] + P[i,j-1] - P[i-1,j-1]\n```\n由于对每个 $P[i,j]$ 的计算都涉及常数数量的算术运算和数组查找 ($O(1)$)，并且此操作对所有 $n \\times m$ 个单元格都要执行，因此构建前缀和数组 $P$ 的总时间复杂度为 $O(nm)$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the rectangle sum query problem for a suite of test cases.\n    It follows a two-phase process:\n    1. Preprocessing: Builds a 2D prefix-sum array (integral image).\n    2. Querying: Uses the prefix-sum array to answer queries in O(1) time.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1\n        {\n            \"A\": np.array([\n                [1, 2, 3, 4],\n                [5, 6, 7, 8],\n                [9, 10, 11, 12]\n            ], dtype=np.int64),\n            \"query\": (1, 1, 2, 3)\n        },\n        # Test case 2\n        {\n            \"A\": np.array([\n                [1, 2, 3, 4],\n                [5, 6, 7, 8],\n                [9, 10, 11, 12]\n            ], dtype=np.int64),\n            \"query\": (0, 0, 2, 3)\n        },\n        # Test case 3\n        {\n            \"A\": np.array([\n                [1, 2, 3, 4],\n                [5, 6, 7, 8],\n                [9, 10, 11, 12]\n            ], dtype=np.int64),\n            \"query\": (0, 0, 0, 0)\n        },\n        # Test case 4\n        {\n            \"A\": np.array([\n                [-1, 2],\n                [3, -4]\n            ], dtype=np.int64),\n            \"query\": (0, 0, 1, 1)\n        },\n        # Test case 5\n        {\n            \"A\": np.array([\n                [0, 0, 0],\n                [0, 1, 0],\n                [0, 0, 0]\n            ], dtype=np.int64),\n            \"query\": (0, 0, 1, 2)\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        A = case[\"A\"]\n        query_coords = case[\"query\"]\n        \n        # Get dimensions of the original matrix A.\n        # A is 0-indexed, with dimensions n x m.\n        n, m = A.shape\n        \n        # 1. Preprocessing Step: Build the prefix-sum array P.\n        # P is (n+1) x (m+1) with 1-based padding for simplified calculations.\n        # P[0,:] and P[:,0] are all 0s by initialization.\n        P = np.zeros((n + 1, m + 1), dtype=np.int64)\n        \n        # Build P using the derived recurrence relation:\n        # P[i,j] = A[i-1,j-1] + P[i-1,j] + P[i,j-1] - P[i-1,j-1]\n        for i in range(1, n + 1):\n            for j in range(1, m + 1):\n                P[i, j] = A[i - 1, j - 1] + P[i - 1, j] + P[i, j - 1] - P[i - 1, j - 1]\n                \n        # 2. Query Step: Compute the sum in O(1) time.\n        # The query is for the rectangle with inclusive 0-based coordinates\n        # (r1, c1) to (r2, c2).\n        r1, c1, r2, c2 = query_coords\n        \n        # Use the derived inclusion-exclusion formula:\n        # S(r1, c1, r2, c2) = P[r2+1, c2+1] - P[r1, c2+1] - P[r2+1, c1] + P[r1, c1]\n        # The indices of P are offset by +1 relative to A's indices.\n        sum_val = P[r2 + 1, c2 + 1] - P[r1, c2 + 1] - P[r2 + 1, c1] + P[r1, c1]\n        \n        results.append(sum_val)\n\n    # Final print statement in the exact required format.\n    # np.int64 objects must be converted to standard Python ints for str()\n    # to format them without any type-specific annotations.\n    print(f\"[{','.join(map(str, [int(r) for r in results]))}]\")\n\nsolve()\n```", "id": "3254618"}, {"introduction": "如何在一个充满正负数值的网格中，找到价值最高（即元素和最大）的连续矩形区域？这个经典问题不仅是一个有趣的算法谜题，也展示了一种强大的问题解决策略：将高维度问题降维，转化为一系列更简单、更低维度的问题来求解。在本练习中，你将把著名的一维Kadane算法巧妙地应用于二维场景，从而解决这个问题。[@problem_id:3254593]", "problem": "开发者需要处理整数值的多维数组，并必须通过从关于数组中求和和连续性的第一性原理出发进行推理，来计算其中的最大和连续区域。从以下基本定义开始：一个二维数组的形状为 $n \\times m$，一个三维数组的形状为 $n \\times m \\times k$；一维中的连续子数组由索引区间 $[i,j]$ 指定，其中 $0 \\le i \\le j$；二维中的连续子矩阵由区间 $[r_1,r_2]$ 和 $[c_1,c_2]$ 指定；三维中的连续子长方体由区间 $[r_1,r_2]$、$[c_1,c_2]$ 和 $[z_1,z_2]$ 指定。任何此类区域的和定义为将指定范围内的所有索引对应的条目相加。一维最大连续子数组问题要求找到一个具有最大和的连续区间；已知该问题可以通过动态规划（Dynamic Programming, DP）得到一个仅使用常数额外空间的线性时间解法。基于这些基础，任务是推导并实现两种算法：首先，对于二维矩阵，推导一种方法，该方法迭代地选择成对的行边界，并将问题简化为针对一个适当构造的压缩数组，在列方向上求解一维最大连续子数组问题；其次，对于三维张量，通过固定两个维度（行和列）以在剩余的深度维度上形成一维数组，并计算最大连续深度区间，来推广这一思想。开发者必须将算法呈现为程序，为提供的测试套件计算所需的最大和，然后在附带的分析中，根据 $n$、$m$ 和 $k$ 对两种算法的时间复杂度进行量化，并阐明所使用的任何预计算的效果。\n\n程序必须完全自包含（无用户输入），并生成单行输出，该输出将所有提供的测试用例的整数结果聚合为一个逗号分隔的列表，并用方括号括起来，顺序与下文完全一致。此问题不涉及物理单位或角度，也没有舍入操作。\n\n实现上述两种算法，并将其应用于以下测试套件。\n\n二维（2D）矩阵：\n- 形状为 $4 \\times 5$ 的矩阵 $A_1$：\n  $[[1, -2, -1, 4, -1], [-8, 3, 4, -2, 2], [3, -1, 2, 1, -5], [-4, 2, -1, 3, 1]]$\n- 形状为 $2 \\times 2$ 的矩阵 $A_2$（全为负数，用于测试边界情况）：\n  $[[-5, -1], [-2, -3]]$\n\n三维（3D）张量：\n- 形状为 $3 \\times 3 \\times 4$ 的张量 $B_1$，以沿深度维度的四个层给出（每个层是一个 $3 \\times 3$ 的矩阵）：\n  层 $z=0$：$[[1, -2, 0], [-1, 3, -1], [2, -1, 1]]$\n  层 $z=1$：$[[-2, 1, 4], [3, -1, 2], [-1, 2, -3]]$\n  层 $z=2$：$[[0, 2, -1], [-3, 4, 1], [2, -2, 0]]$\n  层 $z=3$：$[[-1, -2, 3], [1, 0, -1], [2, 1, -2]]$\n- 形状为 $3 \\times 3 \\times 1$ 的张量 $B_2$（深度为 $1$，可简化为单个二维层）：\n  单层 $z=0$：$[[-1, 2, -3], [4, -5, 6], [-7, 8, -9]]$\n\n对于每个二维测试用例，计算所有连续子矩阵的最大和。对于每个三维测试用例，计算所有连续子长方体的最大和。你的程序应该生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 $[A_1, A_2, B_1, B_2]$，例如 $[r_1,r_2,r_3,r_4]$，其中 $r_i$ 是代表相应最大和的整数。\n\n覆盖性设计：\n- 用例 $A_1$ 是一个通用的正负混合二维实例，用于检验跨列累加降至一维的方法。\n- 用例 $A_2$ 是一个全为负数的二维边界实例，以确保算法在所有和都为负时能正确返回最大的单个条目。\n- 用例 $B_1$ 是一个正负混合的三维实例，需要固定两个维度，并使用高效的逐层矩形求和来为一维最大连续子数组算法构建一维深度序列。\n- 用例 $B_2$ 是一个 $k=1$ 的三维边界实例，该实例简化为二维最大和子矩阵问题。", "solution": "此问题经评估为有效。这是一个适定（well-posed）的算法挑战，其基础是数据结构与算法领域中动态规划和计算复杂度的既定原则。定义清晰，目标可形式化，测试用例具体，可用于验证所推导算法在各种条件下的正确性。\n\n问题的核心是通过推广已知的一维（$1$D）解法，在二维（$2$D）和三维（$3$D）整数值数组中找到最大和的连续区域。\n\n### 1. 一维基础案例：最大连续子数组和\n\n此问题的基础是一维最大连续子数组和问题。给定一个长度为 $N$ 的一维数组 $A$，目标是找到索引 $i$ 和 $j$（$0 \\le i \\le j  N$），使得和 $\\sum_{k=i}^{j} A[k]$ 最大化。\n\n此问题可以使用卡丹算法（Kadane's algorithm）在 $O(N)$ 时间和 $O(1)$ 额外空间内解决，这是一种经典的动态规划方法。其核心思想是遍历数组，同时维护以当前位置结尾的子数组的最大和。设 $c_i$ 为以索引 $i$ 结尾的连续子数组的最大和，$g$ 为到目前为止找到的全局最大和。递推关系为：\n$c_i = \\max(A[i], c_{i-1} + A[i])$\n$g_i = \\max(g_{i-1}, c_i)$\n\n该逻辑能正确处理全为负数的数组，此时结果是数组中最大的（负得最少的）单个元素。\n\n### 2. 二维算法的推导\n\n对于一个形状为 $n \\times m$ 的二维矩阵 $A$，我们需要找到具有最大和的连续子矩阵。问题要求采用一种将此二维问题简化为一系列一维问题的方法。\n\n算法流程如下：\n1.  初始化一个全局最大和 $S_{max}$ 为一个非常小的数（例如，$-\\infty$）。\n2.  遍历所有可能的顶部和底部行边界对，由索引 $r_1$ 和 $r_2$ 表示，其中 $0 \\le r_1 \\le r_2  n$。\n3.  对于每个固定的对 $(r_1, r_2)$，我们创建一个大小为 $m$ 的临时一维数组，称之为 `col_sums`。每个元素 `col_sums[c]` 将存储第 $c$ 列从第 $r_1$ 行到第 $r_2$ 行的元素之和。即，$\\text{col\\_sums}[c] = \\sum_{r=r_1}^{r_2} A[r][c]$。\n4.  这个 `col_sums` 数组代表了由行 $r_1$ 到 $r_2$ 定义的子矩阵的“压缩”视图。`col_sums` 中任何和为 $S$ 的连续子数组，都对应于原始矩阵 $A$ 中一个和同样为 $S$ 的连续子矩阵（跨越行 $r_1$ 到 $r_2$ 以及相应的列区间）。\n5.  对 `col_sums` 数组应用一维最大连续子数组算法（卡丹算法），以找到固定行 $r_1$ 和 $r_2$ 的最大和。\n6.  如果步骤 5 的结果更大，则用它更新全局最大和 $S_{max}$。\n\n在遍历完所有可能的 $(r_1, r_2)$ 对之后，$S_{max}$ 将持有最大子矩阵和。\n\n**复杂度分析（二维）：**\n- $r_1$ 的外层循环运行 $n$ 次。\n- $r_2$ 的内层循环平均运行 $n/2$ 次，即 $O(n)$。\n- 在循环内部，我们构建 `col_sums` 数组。这可以高效完成。对于一个固定的 $r_1$，随着 $r_2$ 的递增，我们可以通过加上新行 $r_2$ 的值来更新 `col_sums`。此更新需要 $O(m)$ 时间。\n- 对 `col_sums` 应用卡丹算法需要 $O(m)$ 时间。\n- 总时间复杂度是这些嵌套操作的乘积：$O(n \\cdot n \\cdot m) = O(n^2 m)$。\n- 空间复杂度为 $O(m)$，用于存储 `col_sums` 数组。此方法未指定也不需要预计算。\n\n### 3. 三维算法的推导\n\n对于形状为 $n \\times m \\times k$ 的三维张量 $B$，我们推广上述策略。问题要求我们固定两个维度（行和列）的边界，并将问题简化为沿第三个维度（深度）的一维搜索。\n\n算法如下：\n1.  初始化一个全局最大和 $S_{max}$ 为 $-\\infty$。\n2.  遍历 $n \\times m$ 平面中所有可能的矩形横截面。这由四个边界索引定义：$r_1, r_2, c_1, c_2$，其中 $0 \\le r_1 \\le r_2  n$ 且 $0 \\le c_1 \\le c_2  m$。\n3.  对于每个固定的矩形区域 $(r_1, c_1)$ 到 $(r_2, c_2)$，创建一个大小为 $k$ 的临时一维数组 `depth_sums`。\n4.  每个元素 `depth_sums[z]` 是在深度切片 $z$ 处固定矩形内的所有元素之和。即，$\\text{depth\\_sums}[z] = \\sum_{r=r_1}^{r_2} \\sum_{c=c_1}^{c_2} B[r][c][z]$。\n5.  对 `depth_sums` 应用一维最大连续子数组算法（卡丹算法）。结果给出其横截面为该固定矩形的连续子长方体的最大和。\n6.  用步骤 5 的结果更新全局最大和 $S_{max}$。\n\n**复杂度分析（三维）：**\n对每个矩形和每个深度切片朴素地计算步骤 4 中的和，效率会很低。直接实现的时间复杂度大约为 $O(n^2 \\cdot m^2 \\cdot k \\cdot n \\cdot m) = O(n^3 m^3 k)$。这在计算上是不可行的。\n\n为使此方法可行，我们引入一个预计算步骤。\n- **预计算：** 对于 $k$ 个深度切片中的每一个，我们计算一个二维和区域表（summed-area table, SAT）。对于一个矩阵 $M$，其 SAT $S$ 定义为 $S[i][j] = \\sum_{x=0}^{i} \\sum_{y=0}^{j} M[x][y]$。为一个 $n \\times m$ 矩阵构建 SAT 需要 $O(nm)$ 时间。由于有 $k$ 个切片，此预计算的总时间为 $O(nmk)$。\n- **主计算：** 有了 SAT，任何矩形区域的和（步骤4）都可以在 $O(1)$ 时间内计算出来。\n主算法包括四个用于 $r_1, r_2, c_1, c_2$ 的嵌套循环，给出 $O(n^2 m^2)$ 种矩形横截面的选择。对于每种选择：\n  - 构建大小为 $k$ 的 `depth_sums` 数组需要 $O(k)$ 时间，因为每次求和都是 $O(1)$ 的查找。\n  - 对 `depth_sums` 应用卡丹算法需要 $O(k)$ 时间。\n主计算的总时间为 $O(n^2 m^2 \\cdot k)$。\n- **总体复杂度：** 总复杂度是预计算和主计算之和：$O(nmk + n^2 m^2 k)$。由于第二项占主导地位，总体时间复杂度为 $O(n^2 m^2 k)$。空间复杂度为 $O(nmk)$，用于存储 SAT。通过选择这种优化算法，满足了题目中讨论预计算的要求。\n\n现在算法已完全指定，其复杂度也已分析完毕。我们将实现这些算法来解决给定的测试用例。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and applies algorithms for finding the maximum-sum contiguous sub-region\n    in 2D and 3D arrays, as per the problem specification.\n    \"\"\"\n\n    def kadane(arr: np.ndarray) - int:\n        \"\"\"\n        Computes the maximum contiguous subarray sum in O(N) time using Kadane's algorithm.\n        Handles the all-negative case correctly.\n        \"\"\"\n        if arr.size == 0:\n            return 0\n        \n        max_so_far = arr[0]\n        current_max = arr[0]\n        for i in range(1, arr.size):\n            x = arr[i]\n            current_max = max(x, current_max + x)\n            max_so_far = max(max_so_far, current_max)\n        return max_so_far\n\n    def max_sum_2d(matrix: np.ndarray) - int:\n        \"\"\"\n        Computes the maximum sum of a contiguous submatrix.\n        Complexity: O(n*n*m) where shape is (n, m).\n        \"\"\"\n        n, m = matrix.shape\n        if n == 0 or m == 0:\n            return 0\n\n        max_overall_sum = -float('inf')\n\n        for r1 in range(n):\n            col_sums = np.zeros(m, dtype=int)\n            for r2 in range(r1, n):\n                # Update column sums by adding the new row r2\n                col_sums += matrix[r2, :]\n                \n                # Apply Kadane's algorithm to find the max sum for the submatrix from r1 to r2\n                current_max = kadane(col_sums)\n                max_overall_sum = max(max_overall_sum, current_max)\n                \n        return int(max_overall_sum)\n\n    def get_sum_from_2d_sat(sat_2d: np.ndarray, r1: int, c1: int, r2: int, c2: int) - int:\n        \"\"\"\n        Calculates the sum of a rectangle from a 2D summed-area table in O(1).\n        \"\"\"\n        res = sat_2d[r2, c2]\n        if r1  0:\n            res -= sat_2d[r1 - 1, c2]\n        if c1  0:\n            res -= sat_2d[r2, c1 - 1]\n        if r1  0 and c1  0:\n            res += sat_2d[r1 - 1, c1 - 1]\n        return res\n\n    def max_sum_3d(tensor: np.ndarray) - int:\n        \"\"\"\n        Computes the maximum sum of a contiguous sub-cuboid.\n        Complexity: O(n*n*m*m*k) where shape is (n, m, k), using precomputation.\n        \"\"\"\n        n, m, k = tensor.shape\n        if n == 0 or m == 0 or k == 0:\n            return 0\n        \n        # Precomputation: Build a 2D summed-area table for each depth slice.\n        # Complexity: O(n*m*k)\n        sats = np.zeros_like(tensor, dtype=int)\n        for z in range(k):\n            sats[:, :, z] = np.cumsum(np.cumsum(tensor[:, :, z], axis=0), axis=1)\n\n        max_overall_sum = -float('inf')\n\n        # Main computation: Iterate over all possible (r,c) rectangles, then find max\n        # contiguous sum along depth.\n        # Complexity: O(n^2 * m^2 * k)\n        for r1 in range(n):\n            for r2 in range(r1, n):\n                for c1 in range(m):\n                    for c2 in range(c1, m):\n                        # Construct a 1D array of sums along the depth dimension\n                        # for the fixed rectangle (r1,c1)-(r2,c2).\n                        depth_sums = np.zeros(k, dtype=int)\n                        for z in range(k):\n                            depth_sums[z] = get_sum_from_2d_sat(sats[:, :, z], r1, c1, r2, c2)\n                        \n                        current_max = kadane(depth_sums)\n                        max_overall_sum = max(max_overall_sum, current_max)\n        \n        return int(max_overall_sum)\n\n    # Define the test cases from the problem statement.\n    A1 = np.array([\n        [1, -2, -1, 4, -1],\n        [-8, 3, 4, -2, 2],\n        [3, -1, 2, 1, -5],\n        [-4, 2, -1, 3, 1]\n    ], dtype=int)\n\n    A2 = np.array([\n        [-5, -1],\n        [-2, -3]\n    ], dtype=int)\n\n    B1_layers = [\n        np.array([[1, -2, 0], [-1, 3, -1], [2, -1, 1]], dtype=int),\n        np.array([[-2, 1, 4], [3, -1, 2], [-1, 2, -3]], dtype=int),\n        np.array([[0, 2, -1], [-3, 4, 1], [2, -2, 0]], dtype=int),\n        np.array([[-1, -2, 3], [1, 0, -1], [2, 1, -2]], dtype=int)\n    ]\n    B1 = np.stack(B1_layers, axis=2)\n\n    B2_layers = [\n        np.array([[-1, 2, -3], [4, -5, 6], [-7, 8, -9]], dtype=int)\n    ]\n    B2 = np.stack(B2_layers, axis=2)\n\n    # Calculate results for all test cases\n    results = [\n        max_sum_2d(A1),\n        max_sum_2d(A2),\n        max_sum_3d(B1),\n        max_sum_3d(B2)\n    ]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3254593"}]}