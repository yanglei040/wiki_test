{"hands_on_practices": [{"introduction": "这个练习挑战你在一个排序顺序（升序或降序）未知的有序链表中进行搜索。这是一个很好的自适应算法设计练习，你必须在遍历过程中推断链表的属性，并利用这些信息来实现提前终止，从而使你的搜索更加高效。通过这个练习，你将学会如何利用数据本身的内在属性（单调性）来优化算法。", "problem": "考虑一个单链表，其中每个节点包含一个整数值和一个指向下一个节点的指针。该链表保证按单调顺序排序，即它要么是非递减的，要么是非递增的，但其顺序（升序或降序）是事先未知的。允许存在重复值。你必须仅使用对链表的顺序访问来搜索给定的目标值。\n\n用作基础的基本定义和事实：\n- 单链表由节点组成，每个节点包含一个值和一个指向下一个节点的指针。不支持随机访问；通过逐个跟随next指针来进行遍历。\n- 在一个非递减序列中，一旦观察到大于目标的值，所有后续值都将大于或等于该值，因此严格大于目标；类似地，在一个非递增序列中，一旦观察到小于目标的值，所有后续值都将小于或等于该值，因此严格小于目标。\n- 顺序遍历的最坏情况时间复杂度为 $O(n)$，额外空间复杂度为常数 $O(1)$，其中 $n$ 是节点数。\n\n任务：\n设计并实现一个程序，对于多个测试用例，该程序从给定的整数数组构建一个单链表，然后搜索给定的目标整数。该程序必须：\n- 如果目标值存在，则返回其值等于目标的第一个节点的从零开始的索引 $i$；否则返回 $-1$。\n- 在对链表进行单次遍历的过程中完成搜索，仅当观察到的相邻值在逻辑上支持时才动态确定排序方向，并在单调性逻辑上保证可以提前终止时应用该策略。禁止将链表转换为数组或使用递归。\n- 每个测试用例的运行都必须在最坏情况时间 $O(n)$ 和额外空间 $O(1)$ 内完成。\n\n测试套件：\n使用以下测试用例，每个用例由一个用于构建链表的输入数组和一个目标值指定：\n- 案例 1：链表 $[1,3,4,7,9]$，目标 $7$。\n- 案例 2：链表 $[10,9,7,7,3]$，目标 $10$。\n- 案例 3：链表 $[2,5,8,12]$，目标 $6$。\n- 案例 4：链表 $[15,13,9,6]$，目标 $16$。\n- 案例 5：链表 $[5,5,5,5]$，目标 $5$。\n- 案例 6：链表 $[5,5,5,5]$，目标 $4$。\n- 案例 7：链表 $[42]$，目标 $42$。\n- 案例 8：链表 $[42]$，目标 $7$。\n- 案例 9：链表 $[-10,-5,-5,0,2]$，目标 $-5$。\n- 案例 10：链表 $[9,7,4,1,1]$，目标 $1$。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含测试用例的结果，格式为一个用方括号括起来的逗号分隔列表，例如 $[r_1,r_2,\\dots,r_{10}]$，其中每个 $r_k$ 是案例 $k$ 的整数索引，如果未找到目标，则为 $-1$。", "solution": "所述问题是有效的。它在科学上基于数据结构和算法的原理，提法恰当，具有唯一且稳定的解，并以客观、正式的语言表述。这是一个标准的算法挑战，没有科学上的矛盾、歧义或信息缺失。因此，我们可以进行正式的求解。\n\n目标是设计一种算法，在一个已知单调排序但具体顺序（非递减或非递增）事先未知的单链表中搜索一个整数 `target`。该算法必须在单次顺序遍历中完成，最坏情况时间复杂度为 $O(n)$，额外空间复杂度为 $O(1)$，其中 $n$ 是链表中的节点数。\n\n该解法的核心原理是从链表的 `head` 开始进行迭代遍历。在遍历过程中，算法维护当前索引 `index`、一个指向当前节点 `current` 的指针，以及一个状态变量（我们称之为 `order`），用于跟踪已确定的链表单调性。`order` 变量可以处于以下三种状态之一：\n- `0`：顺序当前未知。这是初始状态。\n- `1`：链表被确定为非递减（升序）。\n- `-1`：链表被确定为非递增（降序）。\n\n算法流程如下：\n\n1.  **初始化**：\n    - 指针 `current` 初始化为链表的 `head`。\n    - 整数 `index` 初始化为 `0`。\n    - 状态变量 `order` 初始化为 `0`（未知）。\n    - 如果链表为空（`head` 为空），则无法进行搜索。算法终止，返回 `-1`。\n\n2.  **迭代遍历**：\n    - 只要 `current` 不为空，循环就继续。在每次迭代中，执行以下检查：\n\n    a.  **目标匹配**：将 `current` 节点的值 `current.value` 与 `target` 进行比较。如果 `current.value == target`，则已找到第一次出现的目标。算法终止并返回当前的 `index`。\n\n    b.  **确定顺序**：如果 `order` 仍然未知（`order == 0`）并且存在后续节点（`current.next` 不为空），算法将尝试确定链表的单调性。\n        - 如果 `current.next.value > current.value`，则逻辑上必然得出链表是非递减的。将 `order` 设置为 `1`。\n        - 如果 `current.next.value  current.value`，则逻辑上必然得出链表是非递增的。将 `order` 设置为 `-1`。\n        - 如果 `current.next.value == current.value`，则无法从这对节点确定顺序，因此 `order` 保持为 `0`。\n\n    c.  **提前终止**：一旦确定了 `order`，就可以利用单调性的基本属性来提前终止。\n        - 如果链表是非递减的（`order == 1`），并且算法遇到一个节点其 `current.value > target`，那么可以保证所有后续节点的值都将大于或等于 `current.value`。因此，所有后续值也必须严格大于 `target`。匹配是不可能的，算法可以立即终止，返回 `-1`。\n        - 对称地，如果链表是非递增的（`order == -1`），并且算法遇到一个节点其 `current.value  target`，那么所有后续节点的值都将小于或等于 `current.value`。这些后续值也必须严格小于 `target`。匹配同样是不可能的，算法终止，返回 `-1`。\n\n    d.  **前进**：如果没有满足终止条件，则将 `current` 指针前移至 `current.next`，并将 `index` 增加 `1`。\n\n3.  **搜索失败**：如果循环完成，意味着已经访问了所有节点但未找到 `target`。算法返回 `-1`。\n\n**复杂度分析**：\n-   **时间复杂度**：该算法涉及一个遍历链表的单循环。在最坏情况下（例如，目标是最后一个元素，或者目标不存在且未触发提前终止），循环将执行 $n$ 次，其中 $n$ 是节点数。循环内的每个操作（比较、指针赋值）都花费常数时间。因此，最坏情况时间复杂度为 $O(n)$，满足题目要求。\n-   **空间复杂度**：该算法利用固定数量的变量（`current`、`index`、`order`）来存储其状态。这些变量所需的内存是恒定的，不随输入链表的大小 $n$ 而扩展。这遵守了禁止使用递归（可能会使用 $O(n)$ 的栈空间）和其他辅助数据结构的要求。因此，额外空间复杂度为 $O(1)$，符合要求。\n\n该算法正确且高效地解决了问题，同时遵守了所有指定的约束条件。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass Node:\n    \"\"\"Represents a node in a singly linked list.\"\"\"\n    def __init__(self, value: int = 0, next_node=None):\n        self.value = value\n        self.next = next_node\n\ndef build_list(arr: list[int]) - Node | None:\n    \"\"\"Builds a singly linked list from a Python list.\"\"\"\n    if not arr:\n        return None\n    head = Node(arr[0])\n    current = head\n    for val in arr[1:]:\n        current.next = Node(val)\n        current = current.next\n    return head\n\ndef search_monotonic_list(head: Node | None, target: int) - int:\n    \"\"\"\n    Searches for a target in a monotonically sorted linked list with unknown order.\n    \n    Args:\n        head: The head node of the singly linked list.\n        target: The integer value to search for.\n    \n    Returns:\n        The zero-based index of the first occurrence of the target, or -1 if not found.\n    \"\"\"\n    if not head:\n        return -1\n\n    current = head\n    index = 0\n    # order: 0 for unknown, 1 for non-decreasing, -1 for non-increasing\n    order = 0\n\n    while current:\n        # Check for a match\n        if current.value == target:\n            return index\n\n        # Determine the sorting order on the fly if it is currently unknown\n        if order == 0 and current.next:\n            if current.next.value  current.value:\n                order = 1  # Non-decreasing\n            elif current.next.value  current.value:\n                order = -1  # Non-increasing\n\n        # Apply early termination logic if the order has been determined\n        if order == 1 and current.value  target:\n            # In a non-decreasing list, if current  target, all subsequent values will also be  target.\n            return -1\n        if order == -1 and current.value  target:\n            # In a non-increasing list, if current  target, all subsequent values will also be  target.\n            return -1\n\n        # Advance to the next node\n        current = current.next\n        index += 1\n\n    # Target not found after traversing the entire list\n    return -1\n\ndef solve():\n    \"\"\"\n    Runs the defined test suite and prints the results in the required format.\n    \"\"\"\n    test_cases = [\n        ([1, 3, 4, 7, 9], 7),\n        ([10, 9, 7, 7, 3], 10),\n        ([2, 5, 8, 12], 6),\n        ([15, 13, 9, 6], 16),\n        ([5, 5, 5, 5], 5),\n        ([5, 5, 5, 5], 4),\n        ([42], 42),\n        ([42], 7),\n        ([-10, -5, -5, 0, 2], -5),\n        ([9, 7, 4, 1, 1], 1),\n    ]\n\n    results = []\n    for arr, target in test_cases:\n        linked_list_head = build_list(arr)\n        result = search_monotonic_list(linked_list_head, target)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3246368"}, {"introduction": "并非所有的链表问题都能通过单次遍历解决。这个练习展示了一个必须采用多遍遍历方法的场景：找到其值最接近链表算术平均值的节点。你将理解为什么必须首先遍历整个链表以计算一个全局属性（平均值），然后才能在第二次遍历中执行最终的搜索，这揭示了链表算法设计中的一个基本权衡。", "problem": "给定一个单链表，其节点存储整数值。设该链表长度为 $n \\geq 0$，节点值记为 $x_0, x_1, \\dots, x_{n-1}$，其中 $x_i \\in \\mathbb{Z}$ 且 $x_0$ 是链表的头节点。对于 $n  0$ 的情况，这些值的算术平均值 $\\mu$ 定义为 $\\mu = \\frac{1}{n}\\sum_{i=0}^{n-1} x_i$。索引为 $i$ 的节点的绝对偏差定义为 $d_i = \\lvert x_i - \\mu \\rvert$。你的任务是实现一个程序，遍历该链表并返回索引 $k$，使得 $d_k$ 最小化。如果出现平局，即多个索引达到相同的最小偏差，则选择其中最小的索引。如果列表为空（即 $n = 0$），则返回 $-1$。\n\n你必须构建一个单链表数据结构，并执行必要的遍历和搜索操作，而不能将该链表转换为随机访问结构。假设在计算平均值时，所有算术运算都使用标准的双精度浮点数进行。索引是从零开始的，所以头节点的索引为 $0$。\n\n使用的基本原理和约束：\n- 单链表由节点组成，每个节点存储一个值 $x \\in \\mathbb{Z}$ 和一个指向下一个节点的指针，通过从头节点开始跟随 next 指针来进行遍历。\n- 对于 $n  0$，算术平均值定义为 $\\mu = \\frac{1}{n}\\sum_{i=0}^{n-1} x_i$。\n- 绝对偏差定义为 $d_i = \\lvert x_i - \\mu \\rvert$。\n\n你的程序必须实现此逻辑，并将其应用于以下测试用例集，其中每个列表都以序列形式提供，需要转换成单链表：\n- 测试 $1$：$\\left[5, 2, 9, -3, 7\\right]$\n- 测试 $2$：$\\left[10\\right]$\n- 测试 $3$：$\\left[-1, 1\\right]$\n- 测试 $4$：$\\left[8, 8, 8, 8\\right]$\n- 测试 $5$：$\\left[-5, -4, -3, -2, -1\\right]$\n- 测试 $6$：$\\left[\\right]$ (空列表)\n- 测试 $7$：$\\left[3, 4, 5\\right]$\n- 测试 $8$：$\\left[1000000000, -1000000000\\right]$\n\n对于每个测试，输出一个整数：即其值最接近平均值 $\\mu$ 的节点的索引 $k$（如上定义），在偏差相等的情况下，根据选择最小索引的平局规则进行。对于空列表，输出 $-1$。\n\n最终输出格式：\n你的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的结果顺序与上述测试用例的顺序相同（例如，$\\left[\\text{result}_1, \\text{result}_2, \\dots\\right]$）。", "solution": "此问题是有效的。它在科学上基于数学和计算机科学的标准定义，问题表述清晰，平局规则保证了唯一解的存在，并且使用了客观、正式的语言。所有必要的条件和数据都已提供，并且没有内部矛盾。\n\n任务是找到单链表中一个节点的索引 $k$，该节点的值 $x_k$ 与列表中所有值的算术平均值 $\\mu$ 最接近。绝对偏差由 $d_i = \\lvert x_i - \\mu \\rvert$ 给出，我们要寻找最小化 $d_k$ 的索引 $k$。\n\n该问题设计的核心由两个基本原则决定：算术平均值的定义和单链表的遍历约束。\n\n1.  **计算平均值 $\\mu$**：对于长度为 $n  0$ 的列表，算术平均值定义为 $\\mu = \\frac{1}{n}\\sum_{i=0}^{n-1} x_i$。要计算 $\\mu$，我们需要两个聚合量：节点值的总和 $\\sum_{i=0}^{n-1} x_i$ 和节点的总数 $n$。\n\n2.  **单链表遍历**：单链表是一种顺序访问的数据结构。遍历只能朝一个方向进行，即从头节点到其后继节点，直到到达列表末尾。如果不遍历所有前面的节点，就无法通过索引访问任意节点。\n\n这两个原则使得两遍扫描算法成为必要。单次遍历是不够的，因为计算任何给定节点 $x_i$ 的偏差 $d_i$ 都需要 $\\mu$ 的值，但 $\\mu$ 本身只有在访问了所有节点以获得总和与总数之后才能计算出来。\n\n算法流程如下：\n\n**步骤 1：处理空列表情况**\n首先，我们检查列表是否为空（即其头节点为 `None`）。如果为空，则 $n=0$。根据问题规定，我们返回 $-1$。\n\n**步骤 2：第一次遍历 - 计算总和与数量**\n我们从头到尾遍历链表，以计算其值的总和和节点的数量。\n- 初始化一个总和变量 $S$ 为 $0$。\n- 初始化一个计数变量 $n$ 为 $0$。\n- 从一个指向列表头节点的指针 `current` 开始，我们进行迭代，直到 `current` 为 `None`：\n  - 将 `current` 节点的值加到 $S$ 上：$S \\leftarrow S + \\text{current.value}$。\n  - 增加节点计数：$n \\leftarrow n + 1$。\n  - 移动指针：`current` $\\leftarrow$ `current.next`。\n\n这次遍历之后，如果 $n  0$，我们就有了计算平均值所需的所有要素。\n\n**步骤 3：计算平均值**\n算术平均值 $\\mu$ 使用浮点运算计算得出，即 $\\mu = S / n$。\n\n**步骤 4：第二次遍历 - 寻找最小偏差的索引**\n我们必须第二次遍历列表，将每个节点的值与已知的平均值 $\\mu$ 进行比较。\n- 初始化一个变量 `min_deviation` 为正无穷大 $\\infty$。这确保第一个节点的偏差将会更小。\n- 初始化一个变量 `result_index` 为占位符值（例如 $-1$ 或 $0$）。\n- 初始化 `current_index` 为 $0$。\n- 将 `current` 指针重置回列表的头节点。\n- 我们再次遍历列表：\n  - 对于 `current_index` 处值为 $x_i$ 的节点，计算其绝对偏差：$d_i = \\lvert x_i - \\mu \\rvert$。\n  - 将此偏差与 `min_deviation` 进行比较。如果 $d_i  \\text{min\\_deviation}$：\n    - 找到了一个新的最小偏差。将 `min_deviation` 更新为 $d_i$。\n    - 将 `result_index` 更新为 `current_index`。\n  - 平局规则规定，如果多个索引具有相同的最小偏差，应选择最小的那个索引。我们在比较中使用的严格不等式（``）自然地处理了这一点。如果后面的节点偏差等于当前的 `min_deviation`，其索引将不会被选中，从而保留已存储在 `result_index` 中的较小索引。\n  - 增加 `current_index`。\n  - 移动 `current` 指针。\n\n**步骤 5：返回结果**\n第二次遍历完成后，`result_index` 持有最小化偏差 $d_k$ 的最小索引 $k$。返回该值。对于非空列表，这将是一个大于或等于 $0$ 的整数。\n\n该实现将需要一个 `Node` 类来表示链表的元素，以及一个主函数来为每个测试用例组织两遍扫描遍历和计算。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass Node:\n    \"\"\"\n    Represents a node in a singly linked list.\n    Each node stores an integer value and a reference to the next node.\n    \"\"\"\n    def __init__(self, value: int):\n        self.value = value\n        self.next = None\n\nclass SinglyLinkedList:\n    \"\"\"\n    Represents a singly linked list.\n    \"\"\"\n    def __init__(self):\n        self.head = None\n    \n    def append(self, value: int):\n        \"\"\"Appends a new node with the given value to the end of the list.\"\"\"\n        new_node = Node(value)\n        if not self.head:\n            self.head = new_node\n            return\n        \n        last_node = self.head\n        while last_node.next:\n            last_node = last_node.next\n        last_node.next = new_node\n\ndef find_closest_to_mean(linked_list: SinglyLinkedList) - int:\n    \"\"\"\n    Finds the index of the node whose value is closest to the arithmetic mean\n    of all values in a singly linked list.\n    \n    Args:\n        linked_list: The singly linked list to search.\n        \n    Returns:\n        The 0-based index of the node with the minimum absolute deviation from the mean.\n        If there's a tie, the smallest index is returned.\n        Returns -1 if the list is empty.\n    \"\"\"\n    # Step 1: Handle the empty list case\n    if not linked_list.head:\n        return -1\n\n    # Step 2: First pass - Calculate sum and count.\n    # Mathematical variables: S (total_sum), n (node_count)\n    total_sum = 0\n    node_count = 0\n    current = linked_list.head\n    while current:\n        total_sum += current.value\n        node_count += 1\n        current = current.next\n\n    # Step 3: Calculate the mean.\n    # Mathematical variable: mu (mean)\n    # The problem specifies using standard double-precision floating point.\n    # Python's default float is double-precision.\n    if node_count  0:\n        mean = total_sum / node_count\n    else: # This case is already handled by the initial check but included for completeness.\n        return -1\n\n    # Step 4: Second pass - Find the index of minimum deviation.\n    # Mathematical variables: d_i (deviation), min_deviation\n    min_deviation = float('inf')\n    result_index = -1\n    current_index = 0\n    current = linked_list.head\n    \n    while current:\n        deviation = abs(current.value - mean)\n        \n        if deviation  min_deviation:\n            min_deviation = deviation\n            result_index = current_index\n        \n        current_index += 1\n        current = current.next\n\n    # Step 5: Return the result.\n    return result_index\n\n\ndef solve():\n    \"\"\"\n    Main execution function to run the defined test suite.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        [5, 2, 9, -3, 7],\n        [10],\n        [-1, 1],\n        [8, 8, 8, 8],\n        [-5, -4, -3, -2, -1],\n        [],\n        [3, 4, 5],\n        [1000000000, -1000000000]\n    ]\n\n    results = []\n    for case in test_cases:\n        # Create and populate the singly linked list for the current test case.\n        ll = SinglyLinkedList()\n        for value in case:\n            ll.append(value)\n        \n        # Find the index of the node closest to the mean.\n        result = find_closest_to_mean(ll)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3246418"}, {"introduction": "这最后一个练习是对高级指针操作的深入探索。任务是完全“原地”反转一个由链表表示的句子中每隔一个的单词。成功完成这个练习表明你已掌握了重新链接节点和管理复杂结构变化的能力，这是进行更高级数据结构操作的一项关键技能。", "problem": "给定一个单链表，其节点各包含一个单个字符。该链表表示一个句子，其中单词被定义为非空格字符的最大连续序列，而空格是包含空格字符的单字符节点。您必须遍历该链表，并原地反转每隔一个单词的节点，同时保留空格字符的确切位置和数量。反转模式使用从零开始的单词索引：不反转索引为 $0$ 的单词，反转索引为 $1$ 的单词，不反转索引为 $2$ 的单词，反转索引为 $3$ 的单词，依此类推。该链表是单向链接的，意味着每个节点只有一个指向下一个节点的指针，如果是尾节点则没有指针。\n\n推理的基本依据：\n- 单链表是一个节点序列 $N_0, N_1, \\dots, N_{n-1}$，其中每个节点 $N_i$ 包含一个值和一个指向 $N_{i+1}$ 的指针（对于 $i \\in \\{0, \\dots, n-2\\}$），而 $N_{n-1}$ 的 next 指针为空。\n- 对单链表进行的原地操作是通过重新分配 next 指针来执行的，而不分配或复制新节点，并且必须维持结构不变量，即只有一个头节点没有指入指针，只有一个尾节点有空的 next 指针。\n- “单词”是一个连续的节点子序列 $N_a, N_{a+1}, \\dots, N_b$，其值中不含空格字符，且 $N_{a-1}$（如果存在）的值为空格或为 null，以及 $N_{b+1}$（如果存在）的值为空格或为 null。\n- 原地反转子链表 $N_a, \\dots, N_b$ 会改变指针，使得 $N_b$ 成为该子链表的第一个节点，$N_a$ 成为其最后一个节点，同时保留子链表之外的列表。必须更新列表头和连接节点，以使整个列表保持为有效的单链表。\n\n您的程序必须为每隔一个单词（索引 $1, 3, 5, \\dots$）实现这种原地反转。您不得分配任何新的字符节点；只允许进行指针重分配。空格必须精确地保留在原位，不得移除或重新定位；只有指定单词子链表内的节点顺序可以改变。\n\n执行转换后，对于每个测试用例，您必须输出结果链表，该链表被编码为一个整数代码列表，这些代码对应于列表中从头到尾的字符的美国信息交换标准代码 (ASCII) 值。\n\n复杂度要求：\n- 您的算法运行时间必须与节点数 $n$ 成正比，即 $O(n)$，并且除了常数数量的指针和计数器外，使用 $O(1)$ 的额外空间。\n\n测试套件：\n将您的算法应用于以下句子，每个句子都表示为一个字符的单链表：\n- Case $1$: \"we test linked lists now\"\n- Case $2$: \"abc\"\n- Case $3$: \"\" (空句子，表示为没有节点的空链表)\n- Case $4$: \" go  now \" (注意开头的空格、中间两个连续的空格以及结尾的空格)\n- Case $5$: \"a b c d e\"\n- Case $6$: \"   \" (三个空格，没有单词)\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个结果本身都是一个用方括号括起来的整数列表，代表一个测试用例的结果。例如，输出应如下所示：“[[x_1,x_2,\\dots],[y_1,y_2,\\dots],\\dots]”。每个内部列表必须是其对应测试用例转换后句子的 ASCII 码。", "solution": "## 问题验证\n\n### 步骤 1：提取给定信息\n\n- **数据结构**：一个单链表，其中每个节点包含一个单个字符。\n- **输入表示**：一个句子，其中单词是非空格字符的最大连续序列，空格是单字符节点。\n- **任务**：遍历链表并原地反转每隔一个单词的节点。\n- **反转规则**：反转模式使用从零开始的单词索引。索引为奇数（$1, 3, 5, \\dots$）的单词被反转。索引为偶数（$0, 2, 4, \\dots$）的单词不反转。\n- **约束（原地）**：操作必须通过重新分配 `next` 指针来执行，而不分配新的字符节点。\n- **约束（空格）**：空格字符的位置和数量必须精确保留。\n- **推理的基本依据**：\n    - 单链表的定义：一个节点序列 $N_0, N_1, \\dots, N_{n-1}$。\n    - 原地操作的定义。\n    - “单词”的定义：由空格或链表端点界定的连续非空格字符节点子序列。\n    - 子链表反转的定义。\n- **输出要求**：对于每个测试用例，将结果链表输出为 ASCII 整数代码列表。\n- **复杂度要求**：时间复杂度必须为 $O(n)$，其中 $n$ 是节点数。空间复杂度必须为 $O(1)$。\n- **测试套件**：\n    - Case $1$: \"we test linked lists now\"\n    - Case $2$: \"abc\"\n    - Case $3$: \"\" (空链表)\n    - Case $4$: \" go  now \"\n    - Case $5$: \"a b c d e\"\n    - Case $6$: \"   \"\n\n### 步骤 2：使用提取的给定信息进行验证\n\n对照验证标准评估问题陈述。\n\n- **科学依据**：该问题是数据结构和算法领域的标准练习，特别是关于链表操作。所有概念（单链表、原地反转、子链表操作）在计算机科学中都有明确的定义。该问题在科学上和逻辑上都是合理的。\n- **适定性**：问题定义清晰。输入结构、转换规则（反转每隔一个单词）和输出格式都已明确指定，没有歧义。诸如原地操作和 $O(n)$ 时间复杂度等约束是精确的。对于任何有效的输入链表，都存在一个唯一且稳定的解。\n- **客观性**：问题使用正式、客观的语言陈述。提供了“单词”和“空格”的定义，消除了任何主观解释的可能性。\n\n该问题不具有以下任何无效性缺陷：\n1.  它没有违反任何科学或逻辑原则。\n2.  它是一个可形式化的算法问题，与指定主题直接相关。\n3.  问题设置完整且内部一致。\n4.  所需操作是标准的且计算上是可行的。\n5.  问题结构是适定的，允许唯一解。\n6.  该问题并非微不足道；它需要仔细的指针操作才能在较大链表中实现子链表原地、常数空间的反转，这代表了一项实质性的算法挑战。\n7.  解可通过形式化证明和经验测试进行验证。\n\n### 步骤 3：结论与行动\n\n问题是 **有效的**。将提供一个解决方案。\n\n---\n\n## 解决方案\n\n问题要求在单链表中原地反转每隔一个单词，其中单词是由空格字符分隔的非空格字符序列。算法必须在 $O(n)$ 时间和 $O(1)$ 辅助空间内运行。\n\n### 基于原则的设计\n\n解决方案的核心在于遍历链表，同时识别单词边界，并有条件地应用子链表反转算法。为了高效管理指针，尤其是在列表头部，采用了一个哨兵节点或 `dummy` 节点。这种标准技术通过确保列表的每个部分（包括原始头节点）都有一个前驱节点，从而简化了边界情况的处理。\n\n整个算法流程如下：\n\n$1$. **初始化**：创建一个 `dummy` 节点，并将其 `next` 指针设置为输入列表的头节点。这使得对列表原始头部的修改处理变得无缝。一个指针（我们称之为 `prev_group_end`）被初始化为这个 `dummy` 节点。该指针将跟踪先前处理过的组（一个单词或一个空格序列）的最后一个节点。一个计数器 `word_index` 初始化为 `0`。\n\n$2$. **迭代与单词识别**：算法遍历列表。从 `prev_group_end` 开始，我们前进越过所有空格节点，以找到下一个单词的起始位置。\n   - 令 `word_start` 为一个单词的第一个节点。\n   - 然后我们从 `word_start` 开始遍历，找到单词的末尾 `word_end`，即最后一个连续的非空格字符节点。\n   - 我们还需要保留一个对紧跟在单词后面的节点的引用，`node_after_word = word_end.next`，它将是一个空格节点或 null。这个引用对于将处理后的子链表重新连接到列表的其余部分至关重要。\n\n$3$. **条件性子链表反转**：我们检查 `word_index` 的值。\n   - 如果 `word_index` 是偶数（例如，$0, 2, 4, \\dots$），则不应反转该单词。我们只需将主跟踪指针 `prev_group_end` 前进到 `word_end`。\n   - 如果 `word_index` 是奇数（例如，$1, 3, 5, \\dots$），则必须原地反转从 `word_start` 到 `word_end` 的单词子链表。\n\n$4$. **原地子链表反转与重新链接**：从 `word_start` 到 `word_end` 的子链表反转是一个经典的指针反转算法。它需要三个指针，通常命名为 `prev`、`curr` 和 `next_temp`。通过将 `word_end.next` 设置为 null（或者，更高效地，通过使用 `node_after_word` 作为循环终止符）来逻辑上分离子链表，然后进行反转。\n   - 反转后，原始的 `word_end` 成为子链表的新头节点，而原始的 `word_start` 成为其新尾节点。\n   - 为了将反转后的子链表重新整合回主链表，必须重新建立两个连接：\n     a. 单词前面的节点 `prev_group_end` 现在必须指向子链表的新头节点（即原始的 `word_end`）。\n     b. 子链表的新尾节点（即原始的 `word_start`）现在必须指向跟在单词后面的节点 `node_after_word`。\n   - 重新链接后，主跟踪指针 `prev_group_end` 必须更新为指向刚刚处理完的段的末尾，也就是原始的 `word_start`（现在是新子链表的尾部）。\n\n$5$. **前进**：处理完一个单词（无论是跳过还是反转）后，`word_index` 递增。重复此过程，从刚刚处理过的单词之后的节点开始搜索下一个单词。当到达列表末尾时，循环终止。\n\n$6$. **最终化**：该方法返回 `dummy` 节点的 `next` 指针，即完全转换后的列表的头节点。\n\n### 复杂度分析\n\n- **时间复杂度**：该算法涉及对链表的一次遍历。每个节点被访问常数次——在主遍历期间，以及如果它属于被反转的单词，在子链表反转期间。由于每个节点最多只能属于一个单词，因此总工作量与节点数 $n$ 成正比。因此，时间复杂度为 $O(n)$。\n- **空间复杂度**：无论列表大小如何，该算法都使用固定数量的指针（`dummy`、`prev_group_end`、`word_start`、`word_end` 等）。没有分配新节点。这构成了常数辅助空间，因此空间复杂度为 $O(1)$。\n\n这种方法正确而高效地解决了问题，同时遵守了所有指定的约束。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass Node:\n    \"\"\"A node in a singly linked list.\"\"\"\n    def __init__(self, val, next_node=None):\n        self.val = val\n        self.next = next_node\n\n    def __repr__(self):\n        # Helper for debugging, not used in final output\n        return f\"Node({self.val})\"\n\ndef build_list_from_string(s: str) - Node | None:\n    \"\"\"Builds a singly linked list from a string.\"\"\"\n    if not s:\n        return None\n    head = Node(s[0])\n    current = head\n    for char in s[1:]:\n        current.next = Node(char)\n        current = current.next\n    return head\n\ndef list_to_ascii_codes(head: Node | None) - list[int]:\n    \"\"\"Converts a linked list of characters to a list of ASCII codes.\"\"\"\n    codes = []\n    current = head\n    while current:\n        codes.append(ord(current.val))\n        current = current.next\n    return codes\n\ndef reverse_sublist(start: Node, end: Node) - tuple[Node, Node]:\n    \"\"\"\n    Reverses a sublist from start to end (inclusive) in-place.\n    The 'next' pointer of 'end' is assumed to point to the node after the sublist.\n    Returns a tuple (new_head, new_tail) of the reversed sublist.\n    The new_head is the original end node, and the new_tail is the original start node.\n    \"\"\"\n    prev = None\n    curr = start\n    node_after_sublist = end.next\n\n    while curr != node_after_sublist:\n        next_temp = curr.next\n        curr.next = prev\n        prev = curr\n        curr = next_temp\n    \n    # After the loop, `prev` is the new head of the sublist (the original `end`)\n    # `start` is the new tail of the sublist.\n    return end, start\n\ndef solve_case(head: Node | None) - Node | None:\n    \"\"\"\n    Reverses every other word in a singly linked list in-place.\n    \"\"\"\n    if not head:\n        return None\n\n    dummy = Node(' ', head)\n    # prev_group_end tracks the node right before the start of the next word/space block.\n    prev_group_end = dummy\n    word_index = 0\n\n    while True:\n        # Find the start of the next word.\n        # After this loop, prev_group_end is the node before the word (or end of list).\n        word_start = prev_group_end.next\n        while word_start and word_start.val == ' ':\n            prev_group_end = word_start\n            word_start = word_start.next\n        \n        # If no more words are found, we are done\n        if not word_start:\n            break\n\n        # Find the end of the current word\n        word_end = word_start\n        while word_end.next and word_end.next.val != ' ':\n            word_end = word_end.next\n        \n        # The node immediately following the word\n        node_after_word = word_end.next\n\n        # Reverse if it's an odd-indexed word (1, 3, 5, ...)\n        if word_index % 2 == 1:\n            # Reverse the sublist from word_start to word_end\n            new_head, new_tail = reverse_sublist(word_start, word_end)\n\n            # Re-link the reversed sublist into the main list\n            prev_group_end.next = new_head\n            new_tail.next = node_after_word\n            \n            # The new end of the processed group is the new tail of the sublist\n            prev_group_end = new_tail\n        else:\n            # If not reversing, the end of the group is just the word's end\n            prev_group_end = word_end\n        \n        word_index += 1\n        \n        # If we reached the end of the list after this word\n        if not prev_group_end.next:\n            break\n            \n    return dummy.next\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    test_cases = [\n        \"we test linked lists now\",\n        \"abc\",\n        \"\",\n        \" go  now \",\n        \"a b c d e\",\n        \"   \"\n    ]\n\n    results = []\n    for s in test_cases:\n        list_head = build_list_from_string(s)\n        transformed_head = solve_case(list_head)\n        ascii_codes = list_to_ascii_codes(transformed_head)\n        results.append(str(ascii_codes))\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3246332"}]}