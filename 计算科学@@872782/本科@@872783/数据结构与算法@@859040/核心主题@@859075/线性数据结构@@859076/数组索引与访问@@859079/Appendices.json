{"hands_on_practices": [{"introduction": "我们如何仅通过观察多维数组元素的内存地址，就能判断出它在内存中的组织方式？本练习将挑战你扮演一名“侦探”的角色。通过分析访问数组元素时产生的内存“足迹”（即地址序列），你将推断出数组的维度及其存储顺序（行主序或列主序）。这项实践将加深你对内存步长（stride）和数据布局基本原理的理解。[@problem_id:3208033]", "problem": "考虑一个三维数组 $A$，其索引为从零开始的 $(i,j,k)$，在内存中以行主序或列主序连续存储。其维度 $(D_1,D_2,D_3)$ 是未知的正整数。元素类型是固定宽度，大小为 $s$ 字节，其中 $s=8$。元素、行、平面或任何更高级别的切片之间没有填充。设 $A(0,0,0)$ 的基地址为 $B$，其中 $B=100000$。\n\n一个探针在保持另外两个索引固定的情况下，一次改变一个索引，记录了以下内存地址序列：\n\n1. 改变 $i$ 而 $(j,k)=(0,0)$ 固定时，观测到的 $A(0,0,0)$、$A(1,0,0)$、$A(2,0,0)$ 的地址分别为 $100000$、$100160$、$100320$。\n2. 改变 $j$ 而 $(i,k)=(0,0)$ 固定时，观测到的 $A(0,0,0)$、$A(0,1,0)$、$A(0,2,0)$ 的地址分别为 $100000$、$100032$、$100064$。\n3. 改变 $k$ 而 $(i,j)=(0,0)$ 固定时，观测到的 $A(0,0,0)$、$A(0,0,1)$、$A(0,0,2)$ 的地址分别为 $100000$、$100008$、$100016$。\n\n此外，对所有有效 $(i,j,k)$ 值的完整扫描报告称，遇到的最后一个元素的地址是 $100472$。\n\n仅使用连续数组布局的基本定义以及行主序和列主序存储顺序之间的区别，推导出维度 $(D_1,D_2,D_3)$ 并确定存储顺序。然后，计算单个代码值\n$$C \\;=\\; 10^{3}\\,O \\;+\\; 10^{2}\\,D_3 \\;+\\; 10^{1}\\,D_2 \\;+\\; D_1,$$\n其中如果数组是行主序，则 $O=0$，如果数组是列主序，则 $O=1$。提供 $C$ 作为你的最终答案。不需要四舍五入，答案没有单位。", "solution": "该问题要求推断三维数组 $A$ 的存储顺序（行主序或列主序）和维度 $(D_1, D_2, D_3)$，然后计算一个特定的代码值 $C$。\n\n**步骤 1：问题验证**\n\n逐字提取给定信息：\n- 一个三维数组 $A$，其索引为从零开始的 $(i,j,k)$。\n- 维度为 $(D_1, D_2, D_3)$，是未知的正整数。\n- 数组在内存中以行主序或列主序连续存储。\n- 元素大小为 $s=8$ 字节。\n- 没有填充。\n- 基地址为 $B = \\text{Address}(A(0,0,0)) = 100000$。\n- 探针 1 (改变 $i$ 而 $(j,k)=(0,0)$ 固定)：$A(0,0,0)$、$A(1,0,0)$、$A(2,0,0)$ 的地址分别为 $100000$、$100160$、$100320$。\n- 探针 2 (改变 $j$ 而 $(i,k)=(0,0)$ 固定)：$A(0,0,0)$、$A(0,1,0)$、$A(0,2,0)$ 的地址分别为 $100000$、$100032$、$100064$。\n- 探针 3 (改变 $k$ 而 $(i,j)=(0,0)$ 固定)：$A(0,0,0)$、$A(0,0,1)$、$A(0,0,2)$ 的地址分别为 $100000$、$100008$、$100016$。\n- 最后一个元素 $A(D_1-1, D_2-1, D_3-1)$ 的地址是 $100472$。\n- 目标表达式为 $C = 10^{3}O + 10^{2}D_3 + 10^{1}D_2 + D_1$，行主序时 $O=0$，列主序时 $O=1$。\n\n该问题在科学上基于数据结构和内存布局的原理。问题提法得当，提供了充分且一致的信息来确定唯一解。语言客观而精确。因此，该问题是有效的。\n\n**步骤 2：形式化地址计算**\n\n元素 $A(i,j,k)$ 的内存地址是根据其索引、数组维度、元素大小 $s$ 和基地址 $B$ 计算的。索引范围为 $0 \\le i  D_1$，$0 \\le j  D_2$ 和 $0 \\le k  D_3$。\n\n在**行主序**中，最后一个索引 $k$ 变化最快。地址公式为：\n$$ \\text{Address}(i,j,k)_{\\text{row}} = B + (i \\cdot D_2 \\cdot D_3 + j \\cdot D_3 + k) \\cdot s $$\n\n在**列主序**中，第一个索引 $i$ 变化最快。地址公式为：\n$$ \\text{Address}(i,j,k)_{\\text{col}} = B + (k \\cdot D_1 \\cdot D_2 + j \\cdot D_1 + i) \\cdot s $$\n\n**步骤 3：分析探针数据以确定步长**\n\n特定索引的步长是指当该索引增加一时，保持其他索引不变时的内存地址差。我们可以从提供的探针数据中计算出步长。\n\n- **索引 $i$ 的步长 ($S_i$):**\n这是 $A(i+1,j,k)$ 和 $A(i,j,k)$ 之间的地址差。\n根据第一个探针，我们有：\n$S_i = \\text{Address}(A(1,0,0)) - \\text{Address}(A(0,0,0)) = 100160 - 100000 = 160$ 字节。\n差值是一致的：$\\text{Address}(A(2,0,0)) - \\text{Address}(A(1,0,0)) = 100320 - 100160 = 160$。\n\n- **索引 $j$ 的步长 ($S_j$):**\n这是 $A(i,j+1,k)$ 和 $A(i,j,k)$ 之间的地址差。\n根据第二个探针：\n$S_j = \\text{Address}(A(0,1,0)) - \\text{Address}(A(0,0,0)) = 100032 - 100000 = 32$ 字节。\n差值是一致的：$\\text{Address}(A(0,2,0)) - \\text{Address}(A(0,1,0)) = 100064 - 100032 = 32$。\n\n- **索引 $k$ 的步长 ($S_k$):**\n这是 $A(i,j,k+1)$ 和 $A(i,j,k)$ 之间的地址差。\n根据第三个探针：\n$S_k = \\text{Address}(A(0,0,1)) - \\text{Address}(A(0,0,0)) = 100008 - 100000 = 8$ 字节。\n差值是一致的：$\\text{Address}(A(0,0,2)) - \\text{Address}(A(0,0,1)) = 100016 - 100008 = 8$。\n\n我们得到的经验步长为：$S_i = 160$，$S_j = 32$ 和 $S_k = 8$。给定的元素大小为 $s=8$。\n\n**步骤 4：推断存储顺序和维度**\n\n现在我们将经验步长与从地址公式推导出的理论步长进行比较。\n\n对于**行主序**：\n- $S_i = (\\text{Address}(i+1,j,k) - \\text{Address}(i,j,k)) = ((i+1)D_2 D_3 - i D_2 D_3)s = D_2 D_3 s$\n- $S_j = (\\text{Address}(i,j+1,k) - \\text{Address}(i,j,k)) = ((j+1)D_3 - j D_3)s = D_3 s$\n- $S_k = (\\text{Address}(i,j,k+1) - \\text{Address}(i,j,k)) = ((k+1) - k)s = s$\n\n对于**列主序**：\n- $S_i = (\\text{Address}(i+1,j,k) - \\text{Address}(i,j,k)) = ((i+1) - i)s = s$\n- $S_j = (\\text{Address}(i,j+1,k) - \\text{Address}(i,j,k)) = ((j+1)D_1 - j D_1)s = D_1 s$\n- $S_k = (\\text{Address}(i,j,k+1) - \\text{Address}(i,j,k)) = ((k+1)D_1 D_2 - k D_1 D_2)s = D_1 D_2 s$\n\n让我们测试两种可能性：\n\n- **假设 1：数组为行主序。**\n  - $S_k = s$。数据显示 $S_k = 8$ 且 $s=8$。这是一致的。\n  - $S_j = D_3 s \\implies 32 = D_3 \\cdot 8 \\implies D_3 = 4$。\n  - $S_i = D_2 D_3 s \\implies 160 = D_2 \\cdot 4 \\cdot 8 \\implies 160 = 32 \\cdot D_2 \\implies D_2 = 5$。\n  这个假设与步长数据完全一致。我们已经得出 $D_2=5$ 和 $D_3=4$。\n\n- **假设 2：数组为列主序。**\n  - $S_i = s$。数据显示 $S_i = 160$ 且 $s=8$。由于 $160 \\neq 8$，这是一个矛盾。\n  因此，列主序的假设是错误的。\n\n存储方案必须是**行主序**。这意味着用于最终计算的参数 $O$ 为 $O=0$。我们还确定了其中两个维度：$D_2 = 5$ 和 $D_3 = 4$。\n\n**步骤 5：确定维度 $D_1$**\n\n最后一条信息是数组中最后一个元素的地址，即 $A(D_1-1, D_2-1, D_3-1)$。其地址为 $100472$。\n使用行主序地址公式：\n$$ \\text{Address}(D_1-1, D_2-1, D_3-1) = B + ((D_1-1)D_2 D_3 + (D_2-1)D_3 + (D_3-1))s $$\n这个表达式可以简化。数组中的元素总数为 $N = D_1 D_2 D_3$。在一个从零开始的、连续的一维表示中，最后一个元素的索引是 $N-1$。\n最后一个元素的地址就是 $B + (N-1)s$。\n$$ \\text{Address}(D_1-1, D_2-1, D_3-1) = B + (D_1 D_2 D_3 - 1)s $$\n代入已知值：\n$$ 100472 = 100000 + (D_1 \\cdot 5 \\cdot 4 - 1) \\cdot 8 $$\n$$ 100472 - 100000 = (20 D_1 - 1) \\cdot 8 $$\n$$ 472 = (20 D_1 - 1) \\cdot 8 $$\n两边同时除以 $8$：\n$$ \\frac{472}{8} = 20 D_1 - 1 $$\n$$ 59 = 20 D_1 - 1 $$\n$$ 60 = 20 D_1 $$\n$$ D_1 = \\frac{60}{20} = 3 $$\n所以，第一个维度是 $D_1=3$。维度为 $(D_1, D_2, D_3) = (3, 5, 4)$。所有维度都是所要求的正整数。\n\n**步骤 6：计算最终代码值 $C$**\n\n问题要求计算 $C = 10^{3}O + 10^{2}D_3 + 10^{1}D_2 + D_1$ 的值。\n我们已经确定：\n- 存储顺序是行主序，所以 $O=0$。\n- $D_1 = 3$。\n- $D_2 = 5$。\n- $D_3 = 4$。\n\n将这些值代入 $C$ 的表达式中：\n$$ C = 10^3 \\cdot 0 + 10^2 \\cdot 4 + 10^1 \\cdot 5 + 3 $$\n$$ C = 0 + 100 \\cdot 4 + 10 \\cdot 5 + 3 $$\n$$ C = 400 + 50 + 3 $$\n$$ C = 453 $$\n最终的代码值为 $453$。", "answer": "$$\\boxed{453}$$", "id": "3208033"}, {"introduction": "对于像三角矩阵这样含有大量零元素的矩阵，使用标准的矩形数组会造成内存浪费。本练习将指导你设计一种节省空间的存储方案，将一个二维上三角矩阵映射到一个紧凑的一维数组中。你将从第一性原理出发推导出索引公式，这是实现自定义数据结构以及在科学计算等应用中优化内存使用的关键技能。[@problem_id:3208085]", "problem": "给定一个 $n \\times n$ 的上三角矩阵 $M$，使用从零开始的索引，其中只有当 $i \\leq j$ 时，条目 $M[i,j]$ 才可能非零。该矩阵使用行主序压缩方式紧凑地存储在一个一维数组 $A$ 中，具体如下：对于从 $r=0$ 到 $r=n-1$ 的每一行 $r$，元素 $M[r,c]$（其中 $c$ 的范围从 $c=r$ 到 $c=n-1$）按 $c$ 的递增顺序连续存储在 $A$ 中，而 $ij$ 的元素则完全不存储。函数 `get(i,j)`（对于满足 $0 \\leq i \\leq j \\leq n-1$ 的索引 $i,j$）通过读取由一个仅依赖于 $i$、$j$ 和 $n$ 的索引映射 $p(i,j)$ 确定的 $A$ 中的单个位置来检索 $M[i,j]$。\n\n仅从从零开始的数组索引和行主序压缩的基本定义出发，并利用关于有限等差级数求和的公认事实，推导出一个唯一的索引映射 $p(i,j)$ 的闭式解析表达式，使得对于所有 $0 \\leq i \\leq j \\leq n-1$，$A[p(i,j)]$ 正是 $M[i,j]$ 的存储位置。你的最终答案应该是 $p(i,j)$ 作为 $i$、$j$ 和 $n$ 的函数的表达式。不需要近似或四舍五入。", "solution": "在尝试求解之前，对问题陈述进行验证。\n\n### 步骤 1：提取已知条件\n- 一个 $n \\times n$ 的上三角矩阵 $M$。\n- 使用从零开始的索引，索引 $i, j$ 满足 $0 \\leq i, j \\leq n-1$。\n- 矩阵条目 $M[i,j]$ 仅在 $i \\leq j$ 时可能非零。\n- 矩阵存储在一个一维数组 $A$ 中。\n- 存储方案是行主序压缩。\n- 对于从 $r=0$ 到 $r=n-1$ 的每一行 $r$，元素 $M[r,c]$（其中 $c$ 从 $c=r$ 到 $c=n-1$）连续存储在 $A$ 中。\n- $i  j$ 的元素不被存储。\n- 一个函数 `get(i,j)`（对于 $0 \\leq i \\leq j \\leq n-1$）通过访问 $A[p(i,j)]$ 来检索 $M[i,j]$。\n- 索引映射 $p(i,j)$ 仅依赖于 $i$、$j$ 和 $n$。\n- 任务是推导 $p(i,j)$ 的闭式解析表达式。\n- 推导必须基于基本原理，并使用关于等差级数的事实。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学依据：** 该问题是计算机科学中的一个标准练习，涉及稀疏矩阵的内存布局。它基于离散数学和算法原理，是科学合理的。\n- **良构性：** 存储方案被明确定义。由于存储顺序是确定性的，因此存在一个唯一的映射函数 $p(i,j)$。问题是自包含的，并且有一个唯一的、稳定的解。\n- **客观性：** 问题使用精确、形式化的语言陈述。没有主观或含糊的术语。\n\n### 步骤 3：结论与行动\n问题有效。这是一个在数据结构和算法分析领域中良构的形式化问题。将推导解答。\n\n索引映射函数 $p(i,j)$ 的推导从第一性原理出发。数组 $A$ 使用从零开始的索引，这意味着其索引从 $0$ 开始，直到存储元素总数减 $1$。元素 $M[i,j]$ 的索引 $p(i,j)$ 是两个部分之和：\n$1$. 在第 $i$ 行之前的所有行中存储的元素总数。\n$2$. 在第 $i$ 行内，位于第 $j$ 列的元素的从零开始的偏移量。\n\n让我们形式化并计算每个部分。\n\n首先，我们确定任意一行 $r$（其中 $0 \\leq r \\leq n-1$）存储的元素数量。根据存储方案，对于行 $r$，存储的是列 $c$ 从 $r$ 到 $n-1$ 的元素 $M[r,c]$。这样的列数为 $(n-1) - r + 1 = n-r$。因此，行 $r$ 向数组 $A$ 贡献了 $n-r$ 个元素。\n\n接下来，我们计算在第 $i$ 行之前的所有行中存储的元素总数。这些行是 $r=0, 1, \\dots, i-1$。总数是这些行中每行元素数量的总和：\n$$ \\sum_{r=0}^{i-1} (n-r) $$\n这个和可以如下计算：\n$$ \\sum_{r=0}^{i-1} (n-r) = \\sum_{r=0}^{i-1} n - \\sum_{r=0}^{i-1} r $$\n第一项是常数 $n$ 在 $i$ 个项上的和，即 $ni$。第二项是前 $i-1$ 个非负整数的和。使用著名的等差级数求和公式 $\\sum_{k=0}^{m-1} k = \\frac{(m-1)m}{2}$，令 $m=i$，我们得到：\n$$ \\sum_{r=0}^{i-1} r = \\frac{(i-1)i}{2} $$\n因此，从第 $0$ 行到第 $i-1$ 行的元素总数为：\n$$ ni - \\frac{i(i-1)}{2} $$\n这个值表示在第 $i$ 行的第一个元素之前的元素数量。由于数组 $A$ 是从零开始索引的，第 $i$ 行的元素块从索引 $ni - \\frac{i(i-1)}{2}$ 开始。\n\n现在，我们确定在第 $i$ 行内的偏移量。第 $i$ 行的元素按其列索引的递增顺序存储，从列 $c=i$ 开始。存储的元素序列是 $M[i,i], M[i,i+1], M[i,i+2], \\dots, M[i,j], \\dots$。第一个元素 $M[i,i]$ 在其行块内的从零开始的偏移量为 $0$。元素 $M[i,i+1]$ 的偏移量为 $1$，依此类推。元素 $M[i,j]$ 对应于列索引 $j$。该元素相对于其行数据起点的从零开始的偏移量由列索引之差给出：\n$$ \\text{偏移量} = j - i $$\n\n最终索引 $p(i,j)$ 是第 $i$ 行块的起始索引加上该块内的偏移量。\n$$ p(i,j) = \\left( ni - \\frac{i(i-1)}{2} \\right) + (j-i) $$\n我们可以对这个表达式进行代数化简，以获得更紧凑的闭式形式。\n$$ p(i,j) = ni + j - i - \\frac{i(i-1)}{2} $$\n$$ p(i,j) = ni + j - \\left( i + \\frac{i^2-i}{2} \\right) $$\n$$ p(i,j) = ni + j - \\left( \\frac{2i + i^2 - i}{2} \\right) $$\n$$ p(i,j) = ni + j - \\left( \\frac{i^2 + i}{2} \\right) $$\n$$ p(i,j) = ni + j - \\frac{i(i+1)}{2} $$\n此表达式表示对于任何满足 $0 \\leq i \\leq j \\leq n-1$ 的有效索引对 $(i,j)$ 的唯一索引映射 $p(i,j)$。", "answer": "$$\n\\boxed{ni + j - \\frac{i(i+1)}{2}}\n$$", "id": "3208085"}, {"introduction": "如果我们需要频繁地交换一个大型矩阵的整行，直接移动所有数据会非常缓慢。本练习将介绍一种强大的设计模式：使用间接向量（一个指向各行的指针数组）来管理行。通过实现这一结构，你将看到一个简单的抽象层如何允许在常数时间 $O(1)$ 内完成整行交换，这展示了数据表示与操作效率之间的关键权衡。[@problem_id:3208065]", "problem": "考虑一种基于随机存取存储器 (RAM) 的二维数组抽象，其中通过索引访问任何条目的时间是常数时间，记为 $O(1)$。在传统的行主序表示法中，元素 $A[i][j]$ 的地址是通过基地址和使用步长（列数）计算出的线性偏移量得到的。具体来说，在行主序布局下，线性偏移量为 $i \\cdot m + j$，其中 $i$ 是行索引，$j$ 是列索引，$m$ 是列数。在具有显式指针的语言和系统中，可以将二维数组表示为指向行块的指针数组。在这种设计中，通过交换指针数组中相应的指针即可实现整行交换，而无需移动行数据，这在原则上是 $O(1)$ 的。\n\n您的任务是设计一个二维数组数据结构，通过操作内部的行引用数组来支持常数时间行交换，同时保持 $O(1)$ 的索引性能。然后，您需要将此设计实现为一个完整的、可运行的程序，该程序执行一个确定性的测试套件，并按指定格式输出结果。\n\n要求和约束：\n- 该数据结构必须维护：\n  - 一个包含 $n$ 个行块的存储区，每个行块长度为 $m$，用于存放实际值。\n  - 一个长度为 $n$ 的行间接向量 $R$，使得逻辑坐标 $\\langle i, j \\rangle$ 处的值是通过物理存储中由 $R[i]$ 索引的行和列 $j$ 处的值来检索的。\n- 需要支持的操作有：\n  - `get(i,j)`: 在 $O(1)$ 时间内返回逻辑行 $i$ 和列 $j$ 处的值。\n  - `set(i,j,v)`: 在 $O(1)$ 时间内将逻辑行 $i$ 和列 $j$ 处的值设置为 $v$。\n  - `row_swap(i,k)`: 通过更新间接向量 $R$ 在 $O(1)$ 时间内交换整个逻辑行 $i$ 和 $k$。\n  - `sum_row(i)`: 返回逻辑行 $i$ 中所有值的总和；此操作可能需要 $O(m)$ 时间。\n- 您必须在解决方案中证明，在单位成本 RAM 模型下，为什么 `get(i,j)`、`set(i,j,v)` 和 `row_swap(i,k)` 操作的时间复杂度都是 $O(1)$。\n\n测试套件的初始化规则：\n- 对于每个测试用例，初始化存储行，使得物理存储行 $i$ 和列 $j$ 处的值由每个用例给定的函数 $f(i,j)$ 定义。\n\n测试套件规范：\n- 实现以下四个测试用例，以探究正确性的不同方面：\n\n  案例 $1$ (一般情况):\n  - 参数: $n = 3$, $m = 4$, 以及 $f(i,j) = 10 \\cdot i + j$。\n  - 操作和记录的结果:\n    - $r_1$: 任何交换前的 `get(1,2)`。\n    - 执行 `row_swap(0,2)`。\n    - $r_2$: 交换后的 `get(0,3)`。\n    - 执行 `set(2,1,999)`。\n    - $r_3$: 设置值后的 `get(2,1)`。\n    - $r_4$: 所有操作后的 `sum_row(0)`。\n\n  案例 $2$ (单行边界):\n  - 参数: $n = 1$, $m = 5$, 以及 $f(i,j) = i + j$。\n  - 操作和记录的结果:\n    - $r_1$: 任何交换前的 `get(0,4)`。\n    - 执行 `row_swap(0,0)`。\n    - $r_2$: 交换后的 `get(0,4)`。\n    - 执行 `set(0,2,50)`。\n    - $r_3$: 设置值后的 `get(0,2)`。\n    - $r_4$: 所有操作后的 `sum_row(0)`。\n\n  案例 $3$ (单列边界):\n  - 参数: $n = 4$, $m = 1$, 以及 $f(i,j) = 100 \\cdot i + j$。\n  - 操作和记录的结果:\n    - $r_1$: 任何交换前的 `get(3,0)`。\n    - 执行 `row_swap(3,0)`。\n    - $r_2$: 交换后的 `get(3,0)`。\n    - 执行 `set(0,0,7)`。\n    - $r_3$: 设置值后的 `get(0,0)`。\n    - $r_4$: 所有操作后的 `sum_row(0)`。\n\n  案例 $4$ (多次交换的组合):\n  - 参数: $n = 5$, $m = 3$, 以及 $f(i,j) = i \\cdot m + j$。\n  - 操作和记录的结果:\n    - $r_1$: 任何交换前的 `get(2,1)`。\n    - 执行 `row_swap(0,4)`，然后 `row_swap(1,3)`，然后 `row_swap(0,1)`。\n    - $r_2$: 交换后的 `get(2,1)`。\n    - 执行 `set(4,2,12345)`。\n    - $r_3$: 设置值后的 `get(4,2)`。\n    - $r_4$: 所有操作后的 `sum_row(0)`。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含所有四个测试用例的结果，格式为一个由方括号括起来的、无空格的逗号分隔列表。每个用例的结果必须是一个由方括号括起来的、包含四个整数的逗号分隔列表。例如，输出必须类似于 $$[[a_1,a_2,a_3,a_4],[b_1,b_2,b_3,b_4],[c_1,c_2,c_3,c_4],[d_1,d_2,d_3,d_4]]$$ 其中每个符号表示其用例中由指定操作产生的整数。", "solution": "该问题要求设计并实现一个支持常数时间行交换的二维数组数据结构。这通过使用一个间接层来实现，其中逻辑行索引被映射到物理行索引。\n\n所提出的数据结构由两个主要部分组成：\n$1$. 一个物理存储数组，表示为 $S$，维度为 $n \\times m$。该数组存放实际的数据元素。在我们的实现中，这将是一个 `NumPy` 数组。\n$2$. 一个行间接向量，表示为 $R$，长度为 $n$。该向量存储从逻辑行索引到物理行索引的映射。初始时，对于从 $0$ 到 $n-1$ 的所有逻辑行索引 $i$，$R[i]$ 被设置为 $i$，表示直接的一对一映射。\n\n访问坐标 $\\langle i, j \\rangle$ 处的逻辑值，首先从间接向量中找到物理行索引 $p_i = R[i]$，然后访问 $S[p_i][j]$ 处的元素。\n\n这些操作的实现如下：\n\n- `get(i, j)`：为了检索逻辑行 $i$ 和逻辑列 $j$ 处的值，数据结构执行两次查找。首先，它访问间接向量 $R$ 的索引 $i$ 以找到物理行索引，我们称之为 $p_i = R[i]$。其次，它访问物理存储 $S$ 的行 $p_i$ 和列 $j$。值为 $S[p_i][j]$。\n  - **复杂度证明**：在单位成本随机存取存储器 (RAM) 模型下，通过索引访问数组元素是常数时间操作，记为 $O(1)$。`get` 操作包含两次这样的数组访问：一次在 $R$ 上，一次在 $S$ 上。常数次 $O(1)$ 操作的总时间复杂度为 $O(1)$。\n\n- `set(i, j, v)`：要将逻辑行 $i$ 和逻辑列 $j$ 处的值设置为新值 $v$，过程与 `get` 类似。它首先解析出物理行索引 $p_i = R[i]$，然后将新值赋给 $S[p_i][j]$ 处的元素。\n  - **复杂度证明**：此操作涉及一次在 $R$ 上的数组查找和一次对 $S$ 的数组写入。在 RAM 模型中，这两者都是 $O(1)$ 操作。因此，`set` 操作的时间复杂度为 $O(1)$。\n\n- `row_swap(i, k)`：为了交换逻辑行 $i$ 和 $k$，数据结构只操作间接向量 $R$。它交换存储在 $R$ 中索引 $i$ 和 $k$ 处的值。也就是说，交换 $R[i]$ 和 $R[k]$ 的值。包含大量数据的物理存储 $S$ 保持不变。\n  - **复杂度证明**：在数组中交换两个元素需要固定数量的操作（通常使用一个临时变量进行三次赋值）。由于操作数量与数组大小 ($n$) 或行大小 ($m$) 无关，`row_swap` 操作的时间复杂度为 $O(1)$。这是基于间接设计的主要优势。\n\n- `sum_row(i)`：要计算逻辑行 $i$ 中所有元素的总和，该结构首先以 $O(1)$ 时间找到相应的物理行索引 $p_i = R[i]$。然后，它需要遍历物理行 $S[p_i]$ 的所有 $m$ 个元素并累加它们的总和。\n  - **复杂度分析**：此操作涉及一次 $O(1)$ 的查找，然后是一个执行 $m-1$ 次加法的循环。总时间与列数 $m$ 成正比。因此，`sum_row` 操作的时间复杂度为 $O(m)$。\n\n让我们追踪案例 1 的执行过程来演示其机制。\n- 参数：$n = 3$, $m = 4$, 以及 $f(i,j) = 10 \\cdot i + j$。\n- 初始状态：\n  - 物理存储 $S$ 是一个 $3 \\times 4$ 矩阵，其中 $S_{i,j} = 10 \\cdot i + j$:\n  $$S = \\begin{pmatrix} 0  1  2  3 \\\\ 10  11  12  13 \\\\ 20  21  22  23 \\end{pmatrix}$$\n  - 间接向量 $R$ 初始化为 `[0, 1, 2]`。\n- 操作 $1$：$r_1 = \\text{get}(1,2)$。\n  - 逻辑行为 $i=1$。物理行为 $R[1]=1$。\n  - 值为 $S[1][2] = 12$。因此，$r_1=12$。\n- 操作 $2$：执行 `row_swap(0,2)`。\n  - 交换 $R[0]$ 和 $R[2]$。\n  - $R$ 原为 `[0, 1, 2]`。现在 $R = [2, 1, 0]$。\n- 操作 $3$：$r_2 = \\text{get}(0,3)$。\n  - 逻辑行为 $i=0$。物理行为 $R[0]=2$。\n  - 值为 $S[2][3] = 23$。因此，$r_2=23$。\n- 操作 $4$：执行 `set(2,1,999)`。\n  - 逻辑行为 $i=2$。物理行为 $R[2]=0$。\n  - 将 $S[0][1]$ 设置为 $999$。$S$ 的第一行变为 `[0, 999, 2, 3]`。\n- 操作 $5$：$r_3 = \\text{get}(2,1)$。\n  - 逻辑行为 $i=2$。物理行为 $R[2]=0$。\n  - 值为 $S[0][1] = 999$。因此，$r_3=999$。\n- 操作 $6$：$r_4 = \\text{sum_row}(0)$。\n  - 逻辑行为 $i=0$。物理行为 $R[0]=2$。\n  - 对 $S$ 中第 $2$ 行的元素求和：$20+21+22+23 = 86$。因此，$r_4=86$。\n- 案例 1 的结果是 `[12, 23, 999, 86]`。其他案例通过应用相同的逻辑来解决。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass IndirectionArray:\n    \"\"\"\n    A 2D array supporting O(1) row swaps via an indirection vector.\n    \"\"\"\n    def __init__(self, n, m, f):\n        \"\"\"\n        Initializes the data structure.\n\n        Args:\n            n (int): The number of rows.\n            m (int): The number of columns.\n            f (callable): A function f(i, j) to populate the initial storage.\n        \"\"\"\n        self.n = n\n        self.m = m\n        \n        # Physical storage for the array data.\n        self.storage = np.zeros((n, m), dtype=np.int64)\n        for i in range(n):\n            for j in range(m):\n                self.storage[i, j] = f(i, j)\n        \n        # Indirection vector mapping logical rows to physical rows.\n        # Initially, it's a direct mapping: logical row i - physical row i.\n        self.row_indices = np.arange(n)\n\n    def get(self, i, j):\n        \"\"\"\n        Returns the value at logical row i and column j in O(1).\n        \"\"\"\n        physical_row = self.row_indices[i]\n        return self.storage[physical_row, j]\n\n    def set(self, i, j, v):\n        \"\"\"\n        Sets the value at logical row i and column j to v in O(1).\n        \"\"\"\n        physical_row = self.row_indices[i]\n        self.storage[physical_row, j] = v\n\n    def row_swap(self, i, k):\n        \"\"\"\n        Swaps logical rows i and k in O(1).\n        \"\"\"\n        self.row_indices[i], self.row_indices[k] = self.row_indices[k], self.row_indices[i]\n\n    def sum_row(self, i):\n        \"\"\"\n        Returns the sum of values in logical row i in O(m).\n        \"\"\"\n        physical_row = self.row_indices[i]\n        return np.sum(self.storage[physical_row, :])\n\n\ndef solve():\n    \"\"\"\n    Executes the deterministic test suite and prints the final result.\n    \"\"\"\n    all_results = []\n\n    # Case 1 (general case)\n    case1_params = {'n': 3, 'm': 4, 'f': lambda i, j: 10 * i + j}\n    arr1 = IndirectionArray(**case1_params)\n    results1 = []\n    results1.append(arr1.get(1, 2))\n    arr1.row_swap(0, 2)\n    results1.append(arr1.get(0, 3))\n    arr1.set(2, 1, 999)\n    results1.append(arr1.get(2, 1))\n    results1.append(arr1.sum_row(0))\n    all_results.append(results1)\n\n    # Case 2 (single row boundary)\n    case2_params = {'n': 1, 'm': 5, 'f': lambda i, j: i + j}\n    arr2 = IndirectionArray(**case2_params)\n    results2 = []\n    results2.append(arr2.get(0, 4))\n    arr2.row_swap(0, 0)\n    results2.append(arr2.get(0, 4))\n    arr2.set(0, 2, 50)\n    results2.append(arr2.get(0, 2))\n    results2.append(arr2.sum_row(0))\n    all_results.append(results2)\n\n    # Case 3 (single column boundary)\n    case3_params = {'n': 4, 'm': 1, 'f': lambda i, j: 100 * i + j}\n    arr3 = IndirectionArray(**case3_params)\n    results3 = []\n    results3.append(arr3.get(3, 0))\n    arr3.row_swap(3, 0)\n    results3.append(arr3.get(3, 0))\n    arr3.set(0, 0, 7)\n    results3.append(arr3.get(0, 0))\n    results3.append(arr3.sum_row(0))\n    all_results.append(results3)\n\n    # Case 4 (composition of multiple swaps)\n    case4_params = {'n': 5, 'm': 3, 'f': lambda i, j: i * 3 + j}\n    arr4 = IndirectionArray(**case4_params)\n    results4 = []\n    results4.append(arr4.get(2, 1))\n    arr4.row_swap(0, 4)\n    arr4.row_swap(1, 3)\n    arr4.row_swap(0, 1)\n    results4.append(arr4.get(2, 1))\n    arr4.set(4, 2, 12345)\n    results4.append(arr4.get(4, 2))\n    results4.append(arr4.sum_row(0))\n    all_results.append(results4)\n\n    # Format the final output string as specified.\n    formatted_results = [f\"[{','.join(map(str, res))}]\" for res in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3208065"}]}