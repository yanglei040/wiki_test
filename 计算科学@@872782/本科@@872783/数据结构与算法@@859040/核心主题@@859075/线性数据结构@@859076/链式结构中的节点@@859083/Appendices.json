{"hands_on_practices": [{"introduction": "我们从一个挑战常规思维的问题开始。当无法访问一个节点的前驱节点时，你该如何以 $O(1)$ 的时间复杂度删除该节点？这个练习揭示了一种巧妙的变通方法，即通过复制后继节点的数据来“逻辑上”删除当前节点，从而加深了我们对节点本身与其所存储数据之间区别的理解。[@problem_id:3255580]", "problem": "给定一个单向链表结构，其节点由两个字段定义：一个整数值 $v$ 和一个指向下一个节点的引用 $next$。根据定义，单向链表维护一个不变性：每个节点存储一个后继引用，但没有前驱引用；也就是说，对于任何具有后继节点 $w$ 的节点 $u$，有 $u.next = w$，但 $u$ 中没有指向其前驱的字段。要使用的基本核心定义如下：单向链表是一个有限的节点序列 $\\langle u_0,u_1,\\dots,u_{n-1}\\rangle$，对于所有满足 $0 \\le i  n-1$ 的 $i$，$u_i.next = u_{i+1}$，且 $u_{n-1}.next = \\text{None}$；每个节点包含一个可观察的数据值 $v$，并且指针（引用）可以在常数时间内重新赋值。这些事实在链式结构的研究中经过了充分检验并被广泛接受。\n\n设计并实现一个程序，在仅给定单向链表中一个节点 $u$ 的直接指针的情况下，尝试在常数时间 $O(1)$ 内删除该节点，且不从链表头部开始遍历。该操作必须使用常数辅助空间 $O(1)$，并执行有界次数的字段读写。如果在此约束下操作不可能完成，你的程序必须能检测到这种情况并报告失败。你不能从头节点开始遍历，也不能使用任何外部索引来定位前驱节点。你只能使用通过给定节点指针 $u$ 及其可通过 $u.next$ 访问的后继节点所提供的局部信息，具体权限由单向链表定义所允许。程序在尝试操作后必须保持链表的结构有效。\n\n实现以下行为：\n- 给定一个指向节点 $u$ 的指针，尝试仅使用 $u$ 及其可访问的 $next$ 引用来删除 $u$，并遵守常数时间约束。如果删除成功，返回整数 $1$；如果删除不可能，返回整数 $0$。在任何一种情况下，都需同时生成操作尝试后从头到尾的节点值列表。\n- 对于本问题，唯一无法删除的情况是当 $u$ 为尾节点 $u_{n-1}$ 时，因为在单向链表的约束下，没有后继节点来支持常数时间的局部转换。在所有其他情况下，删除操作必须成功，并为除 $u$ 之外的所有节点保留其顺序。\n\n你的程序应为测试套件构建链表，通过位置索引获取指针 $u$（仅用于测试构建），然后对每个测试用例，仅使用提供的指针执行删除尝试。最终的聚合输出必须是单行，包含一个列表，其中每个元素是针对一个测试用例的两部分结果，格式为 $[s, L]$，其中 $s$ 是表示成功的整数指示符（$1$ 表示成功，$0$ 表示失败），$L$ 是表示操作尝试后从头到尾的链表值的整数列表。\n\n需实现的测试套件：\n- Case A：初始值为 $[1,2,3,4,5]$，指针指向索引 $2$（中间节点）。\n- Case B：初始值为 $[1,2,3,4,5]$，指针指向索引 $0$（长度大于 $1$ 的链表中的头节点）。\n- Case C：初始值为 $[1,2,3,4,5]$，指针指向索引 $4$（尾节点）。\n- Case D：初始值为 $[7]$，指针指向索引 $0$（单节点链表，即尾节点）。\n- Case E：初始值为 $[2,2,3,2]$，指针指向索引 $1$（存在重复值）。\n- Case F：初始值为 $[9,8]$，指针指向索引 $0$（双节点链表，头节点）。\n\n你的程序应生成单行输出，其中包含一个以逗号分隔的列表，列表被方括号包围，每个结果的格式如上所述。例如，输出的形状应为 $[[s_1,L_1],[s_2,L_2],\\dots]$，行内不含任何空格。所有输出都是无单位的纯逻辑值。每个 $s_i$ 必须是一个整数，每个 $L_i$ 必须是一个整数列表。", "solution": "该问题要求设计一个算法，在仅给定指向节点 $u$ 的指针的情况下，在常数时间 $O(1)$ 内从单向链表中删除该节点。该解决方案还必须在常数辅助空间 $O(1)$ 内运行，并且不允许从链表头部遍历。\n\n单向链表的基本结构，定义为一个节点序列 $\\langle u_0, u_1, \\dots, u_{n-1} \\rangle$，其中每个节点 $u_i$ 包含一个指向其后继节点 $u_{i+1}$ 的引用 $u_i.next$ 而非其前驱节点 $u_{i-1}$，这对删除操作施加了一个关键约束。标准删除节点 $u$ 的操作需要修改其前驱节点（设为 $p$）的 `next` 引用，使得 $p.next$ 重定向到 $u.next$。在仅给定指向 $u$ 的指针的情况下，没有直接的方法可以在 $O(1)$ 时间内访问 $p$。通过从头节点遍历来定位 $p$ 在最坏情况下将导致 $O(n)$ 的时间复杂度，这违反了问题的主要约束。\n\n这个问题可以通过一种逻辑转换来解决，该方法避免了删除节点 $u$ 本身，但达到了等效的结果。其关键在于认识到我们可以在常数时间内访问节点的后继节点 $v = u.next$。如果存在这样的后继节点，我们可以通过将 $u$ 转换为 $v$ 的一个逻辑副本，然后从链表中移除 $v$，从而有效地“删除”$u$。\n\n对于给定的非尾节点 $u$，算法流程如下：\n\n1.  **识别后继节点**：令 $v = u.next$。由于 $u$ 不是尾节点，可以保证 $v$ 是一个有效节点（即，不是 $\\text{None}$）。\n\n2.  **值覆盖**：将后继节点 $v$ 的数据复制到节点 $u$ 中。设节点的数值字段为 $v$。此操作表示为 $u.v \\leftarrow v.v$。此步骤之后，节点 $u$ 现在持有的值是其原后继节点的值。从遍历链表的观察者角度来看，最初与节点 $u$ 关联的值已从序列中移除。\n\n3.  **指针重链接**：为完成对逻辑后继节点的删除，节点 $u$ 的 `next` 指针被更新以绕过 $v$，直接指向 $v$ 的后继节点。此操作表示为 $u.next \\leftarrow v.next$，这等同于 $u.next \\leftarrow u.next.next$。此操作正确地将 $v$ 从链式结构中移除。\n\n经过这两个步骤后，节点对象 $u$ 仍然在链表中，但它现在包含了其原后继节点的数据，并且链表结构正确地跳过了那个后继节点。链表中值的逻辑序列现在与原始节点 $u$ 被移除后的情况完全相同。这两个步骤都涉及固定数量的赋值和指针解引用，因此整个过程在常数时间 $O(1)$ 内执行，并使用常数辅助空间 $O(1)$。\n\n此算法依赖于后继节点 $u.next$ 的存在。如果给定的节点 $u$ 是链表的尾节点，根据定义 $u.next$ 为 $\\text{None}$。在这种情况下，没有后继节点可以复制数据。在没有前驱节点引用的情况下，修改前驱节点的 `next` 指针为 $\\text{None}$ 仍然是不可能的。因此，对于尾节点，常数时间的删除是不可行的。\n\n实现时必须首先检查条件 $u.next = \\text{None}$。\n- 如果条件为真，则节点 $u$ 是尾节点。操作不可能完成，返回失败状态（$0$）。链表保持不变。\n- 如果条件为假，则节点 $u$ 不是尾节点。执行两步算法（值复制和指针重链接）。返回成功状态（$1$），链表处于正确修改后的状态。\n\n该方法能正确处理问题陈述中指定的所有情况，并遵守所有复杂度和操作约束。测试用例将通过构建链表、为每个测试获取目标节点指针、应用删除逻辑，然后将结果列表状态与成功指示符一起序列化来处理。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of constant-time node deletion in a singly linked list.\n    \"\"\"\n\n    class Node:\n        \"\"\"Node for a singly linked list as defined in the problem.\"\"\"\n        def __init__(self, value, next_node=None):\n            self.value = value\n            self.next = next_node\n\n        def __repr__(self):\n            return f\"Node({self.value})\"\n\n    def build_list_from_values(values):\n        \"\"\"Helper to construct a linked list from a list of integer values.\"\"\"\n        if not values:\n            return None\n        head = Node(values[0])\n        current = head\n        for val in values[1:]:\n            current.next = Node(val)\n            current = current.next\n        return head\n\n    def get_node_by_index(head, index):\n        \"\"\"Helper to get the node at a specific index, for test setup only.\"\"\"\n        current = head\n        for _ in range(index):\n            if current is None:\n                return None  # Index out of bounds\n            current = current.next\n        return current\n\n    def get_list_values(head):\n        \"\"\"Helper to convert the linked list back to a Python list of values.\"\"\"\n        values = []\n        current = head\n        while current:\n            values.append(current.value)\n            current = current.next\n        return values\n\n    def attempt_delete_node(node_to_delete):\n        \"\"\"\n        Attempts to delete the given node in O(1) time by value copying.\n        Returns 1 on success, 0 on failure.\n        Failure occurs if the node is the tail of the list.\n        \"\"\"\n        # A successor node is required for this O(1) deletion method.\n        # If node_to_delete.next is None, it is the tail node, and deletion is impossible.\n        if node_to_delete is None or node_to_delete.next is None:\n            return 0  # Failure\n\n        # The node is not the tail, so deletion is possible.\n        successor = node_to_delete.next\n        \n        # Step 1: Copy the value from the successor to the current node.\n        node_to_delete.value = successor.value\n        \n        # Step 2: Bypass the successor node.\n        node_to_delete.next = successor.next\n        \n        return 1  # Success\n\n    # Test suite as defined in the problem statement.\n    test_cases = [\n        {'values': [1, 2, 3, 4, 5], 'index': 2},  # Case A\n        {'values': [1, 2, 3, 4, 5], 'index': 0},  # Case B\n        {'values': [1, 2, 3, 4, 5], 'index': 4},  # Case C\n        {'values': [7], 'index': 0},              # Case D\n        {'values': [2, 2, 3, 2], 'index': 1},      # Case E\n        {'values': [9, 8], 'index': 0},            # Case F\n    ]\n\n    results_as_strings = []\n    for case in test_cases:\n        initial_values = case['values']\n        target_index = case['index']\n        \n        # Each test must run on a fresh instance of the list.\n        head = build_list_from_values(initial_values)\n        \n        # Get the pointer to the node to be deleted (for test setup only).\n        # The core algorithm itself does not use the index.\n        node_to_delete = get_node_by_index(head, target_index)\n        \n        # Perform the deletion attempt.\n        success_code = attempt_delete_node(node_to_delete)\n        \n        # Capture the state of the list after the attempt.\n        final_values = get_list_values(head)\n        \n        # Format the result for this case according to the specified format '[s,L]'.\n        final_values_str = f\"[{','.join(map(str, final_values))}]\"\n        case_result_str = f\"[{success_code},{final_values_str}]\"\n        results_as_strings.append(case_result_str)\n\n    # Final print statement in the exact required format '[[s1,L1],[s2,L2],...]'.\n    print(f\"[{','.join(results_as_strings)}]\")\n\nsolve()\n```", "id": "3255580"}, {"introduction": "现在，我们将问题从单个列表扩展到两个列表的交互。这个问题提出了一个寻找两条链表交汇点的经典场景，其解决方案是一种优雅的双指针技巧。该方法通过让两个指针在遍历完各自的链表后“交换跑道”，巧妙地抵消了路径长度的差异，从而保证它们最终能在交点相遇，而无需预先知道链表的具体长度。[@problem_id:3255668]", "problem": "给定两个单向链表，每个链表由包含一个值和一个指向下一个节点的指针的节点构成。一个单向链表由一个头节点定义，每个节点都有一个字段指向下一个节点或一个空哨兵。如果两个列表从某个节点开始，按标识（而不仅仅是值相等）共享完全相同的节点实例，直至其尾部，则称这两个列表相交。合并节点定义为两个列表按标识共有的第一个节点。本问题的基础是单向链表节点的定义（包含一个 next 指针）、通过跟随 next 指针遍历列表可按顺序访问节点的属性，以及基于标识的相交概念（意味着从合并节点开始有一个共享的后缀）。\n\n设计并实现一个程序，对每个提供的测试用例，如果存在合并节点，则返回其整数值；如果不存在交点，则返回整数 $-1$。该算法不得使用与列表长度成正比的任何外部存储空间；它必须使用 $O(1)$ 的额外空间，不得修改输入列表，并且能够在不预先知道列表长度的情况下运行。在讨论时间复杂度时，请使用两个列表中的节点数 $n$ 和 $m$ 来表示。\n\n程序必须实现基于单向链表和按标识相交的定义进行推理，并由此推导出一个在规定约束条件下正确找到合并节点的算法。\n\n测试套件：\n在你的程序中构建以下四个测试用例。在每种情况下，明确地构建列表，使得相交（或不相交）是基于节点标识，而不仅仅是值相等。\n\n$1$. 正常情况，长度不等且在中间相交：\n- 列表 $A$ 由值为 $[3,7]$ 的节点组成，后跟一个共享后缀 $[8,10]$。\n- 列表 $B$ 由值为 $[99,1]$ 的节点组成，后跟与列表 $A$ 相同的共享后缀 $[8,10]$。\n\n$2$. 边界情况，在头节点处相交：\n- 列表 $A$ 和列表 $B$ 从头节点开始是完全相同的列表，值为 $[1,2,3]$。\n\n$3$. 边缘情况，仅在最后一个节点处相交：\n- 列表 $A$ 的值为 $[5,6]$，后跟一个值为 $[7]$ 的共享尾节点。\n- 列表 $B$ 的值为 $[9]$，后跟同一个值为 $[7]$ 的共享尾节点。\n\n$4$. 边缘情况，无相交：\n- 列表 $A$ 的值为 $[1,2,3]$。\n- 列表 $B$ 的值为 $[4,5,6]$。\n- 这些列表之间不得有共享的节点实例。\n\n你的程序应该生成单行输出，包含四个测试用例的结果，格式为逗号分隔的列表，并用方括号括起来，例如 $[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4]$，其中每个 $\\text{result}_i$ 是测试用例 $i$ 的合并节点整数值，如果不存在交点则为 $-1$。输出必须仅为一行，不含任何额外文本。\n\n不涉及物理单位或角度，也不需要百分比。任何复杂度声明都必须使用大 $O$ 符号 $O(\\cdot)$，并且必须用 $n$ 和 $m$ 作为两个列表的长度来表示。", "solution": "问题陈述已经过验证，被认为是合理的。这是一个在数据结构和算法领域中定义明确的问题，基于单向链表和节点标识的形式化定义。其约束条件是自洽的，并要求一类特定的算法解决方案。\n\n该问题要求一种算法来找到两个单向链表按标识的第一个公共节点。这个公共节点是一个共享后缀的开始。关键约束是算法必须在 $O(1)$ 的辅助空间内运行，并且不得修改列表。列表的长度（表示为 $n$ 和 $m$）是事先不知道的。\n\n一种朴素的方法是遍历第一个列表中的每个节点，并对其中的每个节点，再遍历第二个列表中的所有节点，检查标识是否相等（例如，在 Python 中使用 `nodeA is nodeB`）。这种方法的时间复杂度为 $O(n \\cdot m)$，对于大型列表效率低下，但它满足 $O(1)$ 的空间约束。\n\n一种更高效的方法是将第一个列表的节点标识存储在哈希集合中，然后遍历第二个列表以检查成员资格。在哈希集合中找到的第二个列表的第一个节点就是交点。这种方法的时间复杂度为 $O(n+m)$，但需要 $O(n)$ 或 $O(m)$ 的空间来存储哈希集合，违反了空间约束。\n\n所要求的解决方案必须在满足常数空间限制的同时，实现线性时间复杂度。这可以通过一种双指针技术巧妙地实现，该技术避免了显式计算长度的需要。\n\n设两个列表为 $A$ 和 $B$。设两个指针为 $p_A$ 和 $p_B$，分别初始化为列表 $A$ 和 $B$ 的头节点。算法通过将两个指针在各自的列表中每次向前移动一步来进行。关键的洞察在于如何处理指针到达其列表末尾（一个 `null` 指针）的情况。当一个指针（例如 $p_A$）到达列表 $A$ 的末尾时，它将被重定向到列表 $B$ 的头节点。同样，当 $p_B$ 到达列表 $B$ 的末尾时，它将被重定向到列表 $A$ 的头节点。\n\n我们来分析为什么这种方法能保证在存在交点的情况下，两个指针一定会在交点处相遇。\n假设列表 $A$ 有一个长度为 $L_A$ 的非共享前缀，列表 $B$ 有一个长度为 $L_B$ 的非共享前缀。设共享后缀的长度为 $C$。列表 $A$ 的总长度为 $n = L_A + C$，列表 $B$ 的总长度为 $m = L_B + C$。\n\n指针 $p_A$ 将遍历列表 $A$ 的路径（长度 $n = L_A + C$），然后被重定向到列表 $B$ 的头节点。要从列表 $B$ 的头节点到达交点，它必须额外行进 $L_B$ 的距离。因此，$p_A$ 到达交点所走的总距离为 $(L_A + C) + L_B$。\n\n指针 $p_B$ 将遍历列表 $B$ 的路径（长度 $m = L_B + C$），然后被重定向到列表 $A$ 的头节点。要从列表 $A$ 的头节点到达交点，它必须额外行进 $L_A$ 的距离。因此，$p_B$ 到达交点所走的总距离为 $(L_B + C) + L_A$。\n\n由于 $(L_A + C) + L_B = (L_B + C) + L_A$，两个指针到达交点所走的总路径长度是相同的。因为它们以相同的速度移动（每步一个节点），所以可以保证它们在相同的步数后到达交点。当它们的标识第一次相同时（$p_A$ is $p_B$），它们必然位于合并节点。\n\n现在，考虑列表不相交的情况。在这种情况下，公共部分长度 $C=0$。列表 $A$ 的长度为 $n=L_A$，列表 $B$ 的长度为 $m=L_B$。\n指针 $p_A$ 将走完其整个列表（长度 $n$），然后被重定向以遍历整个列表 $B$（长度 $m$）。它的总行程在变为 `null` 之前覆盖了 $n+m$ 个节点。\n指针 $p_B$ 将走完其整个列表（长度 $m$），然后被重定向以遍历整个列表 $A$（长度 $n$）。它的总行程在变为 `null` 之前也覆盖了 $m+n$ 个节点。\n两个指针在总共遍历了 $n+m$ 个节点后，将同时变为 `null`。循环条件 `while p_A is not p_B` 将会终止，因为 `null` 与 `null` 是相同的。在这种情况下，最终的指针值为 `null`，表示没有找到交点，函数应返回 $-1$。\n\n因此，算法如下：\n$1$. 初始化两个指针，$p_A$ 指向 `headA`，$p_B$ 指向 `headB`。\n$2$. 只要 $p_A$ 与 $p_B$ 不相同，就继续循环。\n$3$. 在循环内部，将 $p_A$ 推进到其下一个节点。如果 $p_A$ 变为 `null`，则将其重置为 `headB`。\n$4$. 在循环内部，将 $p_B$ 推进到其下一个节点。如果 $p_B$ 变为 `null`，则将其重置为 `headA`。\n$5$. 当循环终止时，两个指针相等。如果此指针不为 `null`，则其值为结果。如果为 `null`，则没有交点，结果为 $-1$。\n\n该算法的时间复杂度为 $O(n+m)$，因为在最坏情况下，每个指针最多遍历两个列表的长度之和。空间复杂度为 $O(1)$，因为它只使用了两个额外的指针，与列表大小无关。这满足了所有问题约束。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass Node:\n    \"\"\"\n    A node in a singly linked list.\n    Each node contains a value and a pointer to the next node.\n    \"\"\"\n    def __init__(self, val, next_node=None):\n        self.val = val\n        self.next = next_node\n\ndef find_intersection_value(headA: 'Node', headB: 'Node') - int:\n    \"\"\"\n    Finds the intersection node of two singly linked lists and returns its value.\n\n    This implementation uses the two-pointer technique with constant space complexity O(1)\n    and linear time complexity O(n+m), where n and m are the lengths of the two lists.\n    It does not require prior knowledge of the list lengths.\n\n    Args:\n        headA: The head node of the first linked list.\n        headB: The head node of the second linked list.\n\n    Returns:\n        The integer value of the merging node if an intersection exists.\n        Returns -1 if there is no intersection.\n    \"\"\"\n    if not headA or not headB:\n        return -1\n\n    pA = headA\n    pB = headB\n\n    # Loop until the pointers meet.\n    # If the lists intersect, they will meet at the intersection node.\n    # If they don't intersect, they will both become None after traversing\n    # a total of (lengthA + lengthB) nodes, and the loop will terminate\n    # because (None is None) is True.\n    while pA is not pB:\n        # If pointer pA reaches the end of its list, switch it to the head of the other list.\n        pA = pA.next if pA is not None else headB\n        # If pointer pB reaches the end of its list, switch it to the head of the other list.\n        pB = pB.next if pB is not None else headA\n    \n    # If the loop terminated because pA and pB are both None, there is no intersection.\n    # Otherwise, they point to the intersection node.\n    return pA.val if pA is not None else -1\n\ndef solve():\n    \"\"\"\n    Constructs the test cases as described in the problem and finds the intersection\n    for each case, printing the results in the specified format.\n    \"\"\"\n    test_cases = []\n\n    # Test Case 1: Happy path with unequal lengths and intersection in the interior\n    # List A: [3, 7] - [8, 10]\n    # List B: [99, 1] - [8, 10]\n    shared_suffix_1 = Node(8, Node(10))\n    headA1 = Node(3, Node(7, shared_suffix_1))\n    headB1 = Node(99, Node(1, shared_suffix_1))\n    test_cases.append((headA1, headB1))\n\n    # Test Case 2: Boundary case with intersection at the head\n    # List A: [1, 2, 3]\n    # List B: [1, 2, 3] (same list instance)\n    headA2 = Node(1, Node(2, Node(3)))\n    headB2 = headA2\n    test_cases.append((headA2, headB2))\n\n    # Test Case 3: Edge case with intersection only at the last node\n    # List A: [5, 6] - [7]\n    # List B: [9] - [7]\n    shared_tail_3 = Node(7)\n    headA3 = Node(5, Node(6, shared_tail_3))\n    headB3 = Node(9, shared_tail_3)\n    test_cases.append((headA3, headB3))\n\n    # Test Case 4: Edge case with no intersection\n    # List A: [1, 2, 3]\n    # List B: [4, 5, 6]\n    headA4 = Node(1, Node(2, Node(3)))\n    headB4 = Node(4, Node(5, Node(6)))\n    test_cases.append((headA4, headB4))\n\n    results = []\n    for headA, headB in test_cases:\n        result = find_intersection_value(headA, headB)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3255668"}, {"introduction": "最后，我们将挑战从两个列表扩展到 $k$ 个。简单的两两合并方法效率低下 ($O(N \\cdot k)$)，而这个问题引入了一种更强大的策略：使用最小堆来高效地管理多个已排序的数据源。这个练习展示了如何将链表与其他数据结构（如此处的优先队列）结合使用，以构建时间复杂度为 $O(N \\log k)$ 的最优算法。[@problem_id:3255730]", "problem": "要求您设计、实现并分析一个算法，该算法使用链式结构上的基本节点和指针操作，将 $k$ 个已排序的单向链表合并成一个已排序的单向链表。您的解决方案必须从数据结构和算法的基本原理推导得出。\n\n使用的基础理论：\n- 单向链表节点的定义：一个记录，包含一个键 $x \\in \\mathbb{Z}$ 和一个指向下一个节点的指针，记为 $\\text{next}$，其中最后一个节点的 $\\text{next} = \\varnothing$。\n- 二叉最小堆（优先队列）不变量：对于二叉堆的数组表示中索引为 $i$ 的每个节点，其键值小于或等于其子节点（如果存在）的键值，并且插入和删除最小值的操作都可以在当前存储元素数量的对数时间内实现。\n- 在比较和指针赋值层面上，遵循单位成本随机存取机（RAM）模型：比较两个键的成本为 $1$，赋值一个指针的成本为 $1$，而恢复堆不变量的堆操作执行由这些基本步骤组成的有限序列。\n\n任务：\n1. 基于上述基础推导一个算法，该算法维护一个二叉最小堆，其中包含所有尚未耗尽的链表的当前头节点。算法重复地从堆中提取最小节点，并将其附加到输出链表中，同时将被提取节点的后继节点（如果存在）推回堆中。\n2. 为确保确定性，当两个键相等时，首先根据其来源的链表索引（索引小者优先）来打破平局；如果仍然相同，则根据其在链表内的位置（位置靠前者优先）来打破平局。您可以通过不改变逻辑键的辅助整数来表示这种平局打破规则。\n3. 在实际的链表节点上（而非数组上）实现该算法，使得所有合并操作都通过重新连接节点指针来完成。不要为合并结果分配新节点；通过更新给定节点的 $\\text{next}$ 指针来重用它们。\n4. 对实现进行插桩，为每个输入实例报告以下整数：\n   - 合并后链表的长度 $L$。\n   - 执行期间观察到的最大堆大小。\n   - 执行的堆弹出（pop）操作次数。\n   - 执行的堆推入（push）操作次数。\n   - 合并后链表的内容校验和 $H$，定义为 $H = \\sum_{i=1}^{L} i \\cdot v_i$，其中 $v_i$ 是合并后输出中第 $i$ 个节点（索引从1开始）的整数键。\n\n正确性和复杂度分析要求：\n- 您的算法设计应确保合并后的输出按非递减顺序排列，并且恰好包含输入列表中的所有节点。\n- 您的推导应能证明算法的渐近运行时间是 $N$ 和 $k$ 的函数，其中 $N$ 是所有链表的总节点数，$k$ 是链表的数量。\n\n测试套件：\n实现您的程序，使其能够在以下列表的列表（list-of-lists）输入上运行，其中每个内部列表描述一个已排序的整数单向链表。下面的每个整数都以常量的形式直接给出；所有列表都按要求的非递减顺序排序。\n\n- 测试用例 1：$\\big[[\\,1,\\,4,\\,5\\,],\\,[\\,1,\\,3,\\,4\\,],\\,[\\,2,\\,6\\,]\\big]$。\n- 测试用例 2：$\\big[\\, [\\,\\,],\\,[\\,\\,],\\,[\\,0,\\,2,\\,2\\,],\\,[\\,3\\,] \\,\\big]$。\n- 测试用例 3：$\\big[\\, [\\,-5,\\,-2,\\,0,\\,3\\,] \\,\\big]$。\n- 测试用例 4：$\\big[\\, [\\,7,\\,7\\,],\\,[\\,7\\,],\\,[\\,\\,],\\,[\\,7,\\,7,\\,7\\,],\\,[\\,7\\,] \\,\\big]$。\n- 测试用例 5：$\\big[\\, [\\,1\\,],\\,[\\,2\\,],\\,[\\,3\\,],\\,[\\,4\\,],\\,[\\,5\\,],\\,[\\,6\\,],\\,[\\,7\\,],\\,[\\,8\\,] \\,\\big]$。\n\n对于每个测试用例，您的程序必须按以下顺序计算并返回一个包含五个整数的列表：\n$\\big[\\,H,\\,L,\\,\\text{max\\_heap\\_size},\\,\\text{pops},\\,\\text{pushes}\\,\\big]$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含所有测试用例的结果，格式为一个由方括号括起来的逗号分隔列表；该外部列表的每个元素本身是对应测试用例的、包含五个整数的方括号列表，顺序与上文相同。例如，外部结构为 $[\\,[\\cdots],\\,[\\cdots],\\ldots\\,]$，不添加或删除空格。", "solution": "该问题要求设计并分析一个算法，用于将 $k$ 个已排序的单向链表合并为一个单一的已排序链表。该解决方案必须从基本原理推导得出，通过重新连接节点指针实现且不分配新节点，并进行插桩以报告特定的性能指标。\n\n### 算法推导\n\n问题的核心是在每一步中高效地确定要附加到合并链表的下一个节点。下一个节点的候选者是 $k$ 个输入链表的当前头节点。一种朴素的方法是在每一步扫描这 $k$ 个头节点以找到键值最小的那个，这将花费 $O(k)$ 的时间。由于最终列表中的每个节点都需要执行此操作（设 $N$ 为总节点数），这种方法将导致总时间复杂度为 $O(N \\cdot k)$。\n\n我们可以通过使用一个能够维护元素集合并高效检索最小元素的数据结构来显著改进这个过程。问题陈述提供了二叉最小堆（优先队列）这一基本工具，其插入和提取最小值的操作的时间复杂度为 $O(\\log m)$，其中 $m$ 是堆中元素的数量。\n\n这引出了以下算法：\n1. 维护一个最小堆，其中包含 $k$ 个尚未耗尽的链表的头节点。\n2. 在每一步，从堆中提取键值最小的节点。根据最小堆的定义，该节点是所有当前候选节点中键值最小的节点。\n3. 将此提取的节点附加到单一合并链表的尾部。\n4. 如果被提取的节点在其原始链表中有一个后继节点，则将该后继节点插入堆中。\n5. 重复此过程直到堆为空。此时，所有链表的所有节点都已转移到合并链表中。\n\n堆在任何时候最多包含 $k$ 个元素（每个输入链表一个）。因此，每个堆操作（插入和提取）的成本为 $O(\\log k)$。由于每个节点都必须被推入堆一次并从堆中弹出一次，因此合并过程的总时间复杂度将为 $O(N \\log k)$，这比朴素的 $O(N \\cdot k)$ 方法有了显著的改进。\n\n### 数据结构与不变量\n\n**节点定义**：一个节点是一个记录，包含一个整数键 $v$、一个指向后续节点的指针 $\\text{next}$，以及用于打破平局的辅助信息。问题定义了一个节点，其包含一个键 $x \\in \\mathbb{Z}$ 和一个指针 $\\text{next}$。为了处理指定的平局打破规则，我们为每个节点增加了其原始列表索引 $\\text{list\\_idx}$ 和其在该列表中的位置索引 $\\text{pos\\_idx}$。\n\n**堆元素**：最小堆不直接存储节点，而是存储有助于比较逻辑的元组。堆中的每个元素都是一个形式为 $(\\text{key}, \\text{list\\_idx}, \\text{pos\\_idx}, \\text{node\\_reference})$ 的元组。Python 的元组比较是按字典序进行的，即从左到右比较元素。这自然地实现了所需的平局打破规则：\n1. 主要比较基于 $\\text{key}$。\n2. 如果键相等，则回退到比较 $\\text{list\\_idx}$（索引小者优先）。\n3. 如果键和 $\\text{list\\_idx}$ 都相等，则使用 $\\text{pos\\_idx}$ 进行比较（位置靠前者优先）。\n\n**堆不变量**：二叉最小堆不变量确保对于任何父元素 $(\\text{key}_p, \\dots)$，其值小于或等于其子元素 $(\\text{key}_{c1}, \\dots)$ 和 $(\\text{key}_{c2}, \\dots)$ 的值。这保证了 `heap-pop` 总是返回根据指定的复合比较键确定的最小元素。\n\n### 分步算法\n\n设输入为 $k$ 个链表头节点的集合，$\\{h_0, h_1, \\dots, h_{k-1}\\}$。\n\n1.  **初始化**：\n    *   初始化一个空最小堆 $Q$。\n    *   初始化插桩计数器：$\\text{pushes} \\leftarrow 0$，$\\text{pops} \\leftarrow 0$，$\\text{max\\_heap\\_size} \\leftarrow 0$。\n    *   创建一个虚拟头节点 $\\text{dummy\\_head}$，作为合并链表的起始。这简化了附加第一个元素的逻辑。初始化一个指针 $\\text{tail} \\leftarrow \\text{dummy\\_head}$。\n\n2.  **堆填充**：\n    *   对于从 $0$ 到 $k-1$ 的每个列表索引 $i$：\n        *   如果头节点 $h_i$ 不为 null ($\\varnothing$)：\n            *   将元组 $(h_i.\\text{key}, h_i.\\text{list\\_idx}, h_i.\\text{pos\\_idx}, h_i)$ 推入堆 $Q$。\n            *   将 $\\text{pushes}$ 增加 $1$。\n    *   设置 $\\text{max\\_heap\\_size} \\leftarrow \\text{size}(Q)$。\n\n3.  **合并循环**：\n    *   当堆 $Q$ 不为空时：\n        *   更新 $\\text{max\\_heap\\_size} \\leftarrow \\max(\\text{max\\_heap\\_size}, \\text{size}(Q))$。\n        *   从 $Q$ 中提取最小元素：$(\\_, \\_, \\_, \\text{min\\_node}) \\leftarrow \\text{pop}(Q)$。\n        *   将 $\\text{pops}$ 增加 $1$。\n        *   将 $\\text{min\\_node}$ 附加到合并链表：$\\text{tail}.\\text{next} \\leftarrow \\text{min\\_node}$，然后更新 $\\text{tail} \\leftarrow \\text{min\\_node}$。\n        *   令 $\\text{successor} \\leftarrow \\text{min\\_node}.\\text{next}$。\n        *   如果 $\\text{successor}$ 不为 null ($\\varnothing$)：\n            *   将元组 $(\\text{successor}.\\text{key}, \\text{successor}.\\text{list\\_idx}, \\text{successor}.\\text{pos\\_idx}, \\text{successor})$ 推入 $Q$。\n            *   将 $\\text{pushes}$ 增加 $1$。\n\n4.  **收尾与报告**：\n    *   循环结束后，合并后的链表从 $\\text{dummy\\_head}.\\text{next}$ 开始。设置 $\\text{tail}.\\text{next} \\leftarrow \\varnothing$ 以终止最终链表。\n    *   遍历合并后的链表，计算其长度 $L$ 和校验和 $H = \\sum_{i=1}^{L} i \\cdot v_i$，其中 $v_i$ 是第 $i$ 个节点的键。\n    *   最终的指标是 $H$、$L$、$\\text{max\\_heap\\_size}$、$\\text{pops}$ 和 $\\text{pushes}$。\n\n\n### 正确性与复杂度分析\n\n**正确性**：\n*   **排序顺序**：最小堆不变量保证了在每一步中，`pop` 操作都会检索到在所有可用节点中具有全局最小键（遵循平局打破规则）的节点。通过相继附加这些最小节点，生成的合并链表保证是按非递减顺序排序的。\n*   **完整性**：输入链表中的每个节点都会被推入堆中恰好一次（如果它是头节点，则在初始时推入；否则在其前驱节点被弹出时推入）。每个被推入堆的节点最终都会被弹出并附加到结果链表中。这确保了最终链表包含输入链表中的所有节点，且没有其他节点。\n\n**复杂度分析**：\n设 $N$ 是所有 $k$ 个链表的总节点数。\n*   **时间复杂度**：\n    *   初始填充堆涉及最多 $k$ 次推入操作，耗时 $O(k \\log k)$。\n    *   主循环执行 $N$ 次，每个节点一次。\n    *   每次迭代涉及一次 `pop` 操作（$O(\\log k)$）和最多一次 `push` 操作（$O(\\log k)$）。指针赋值是常数时间，$O(1)$。\n    *   因此，循环的总时间为 $N \\cdot O(\\log k) = O(N \\log k)$。\n    *   计算 $L$ 和 $H$ 的最终遍历需要 $O(N)$ 时间。\n    *   总时间复杂度由堆操作主导，结果为 $O(k \\log k + N \\log k) = O(N \\log k)$，因为通常 $N \\geq k$。\n*   **空间复杂度**：\n    *   该算法重用现有节点，因此没有为输出链表本身分配 $O(N)$ 的空间。\n    *   主要的辅助数据结构是最小堆。在任何时候，堆最多存储来自 $k$ 个链表中的每个链表的一个节点。因此，堆的最大大小为 $k$。\n    *   堆所需的空间为 $O(k)$。\n    *   每个节点上的辅助属性 `list_idx` 和 `pos_idx` 总共需要 $O(N)$ 的空间，但这被视为问题输入表示的一部分，而不是算法本身的辅助空间。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport heapq\n\nclass Node:\n    \"\"\"\n    Definition of a singly linked list node as specified.\n    Includes auxiliary data for deterministic tie-breaking.\n    \"\"\"\n    def __init__(self, key, list_idx, pos_idx):\n        self.key = int(key)  # Ensure key is an integer, x in Z\n        self.next = None\n        \n        # Auxiliary integers for tie-breaking\n        self.list_idx = int(list_idx)\n        self.pos_idx = int(pos_idx)\n\n    def __repr__(self):\n        return f\"Node(key={self.key}, list_idx={self.list_idx}, pos_idx={self.pos_idx})\"\n\n\ndef build_linked_lists(list_of_lists):\n    \"\"\"\n    Constructs singly linked lists from a list of Python lists of integers.\n    Assigns list_idx and pos_idx to each node for tie-breaking.\n    \n    Returns:\n        A list of head nodes for the created linked lists.\n    \"\"\"\n    heads = []\n    for i, int_list in enumerate(list_of_lists):\n        if not int_list:\n            heads.append(None)\n            continue\n        \n        # Create the head of the current linked list\n        head_node = Node(int_list[0], list_idx=i, pos_idx=0)\n        heads.append(head_node)\n        current = head_node\n        \n        # Create and link subsequent nodes\n        for j, val in enumerate(int_list[1:], 1):\n            new_node = Node(val, list_idx=i, pos_idx=j)\n            current.next = new_node\n            current = new_node\n    return heads\n\ndef merge_k_sorted_lists(heads):\n    \"\"\"\n    Merges k sorted singly linked lists using a min-heap and reports metrics.\n    \n    Args:\n        heads: A list of head nodes of the k sorted linked lists.\n    \n    Returns:\n        A list of five integers: [H, L, max_heap_size, pops, pushes].\n    \"\"\"\n    min_heap = []\n    pushes = 0\n    pops = 0\n    max_heap_size = 0\n\n    # 1. Initialize heap with the head of each non-empty list\n    for node in heads:\n        if node:\n            heap_entry = (node.key, node.list_idx, node.pos_idx, node)\n            heapq.heappush(min_heap, heap_entry)\n            pushes += 1\n\n    if not min_heap:\n        return [0, 0, 0, 0, 0]\n\n    max_heap_size = len(min_heap)\n\n    dummy_head = Node(0, -1, -1)  # Dummy head for the merged list\n    tail = dummy_head\n\n    # 2. Main merging loop\n    while min_heap:\n        max_heap_size = max(max_heap_size, len(min_heap))\n        \n        # Pop the smallest element\n        _, _, _, current_node = heapq.heappop(min_heap)\n        pops += 1\n        \n        # Append it to the result list\n        tail.next = current_node\n        tail = current_node\n        \n        # Push the next element from the same list into the heap\n        if current_node.next:\n            next_node = current_node.next\n            heap_entry = (next_node.key, next_node.list_idx, next_node.pos_idx, next_node)\n            heapq.heappush(min_heap, heap_entry)\n            pushes += 1\n    \n    tail.next = None # Terminate the merged list\n\n    # 3. Calculate final metrics L (length) and H (checksum)\n    L = 0\n    H = 0\n    current = dummy_head.next\n    i = 1\n    while current:\n        L += 1\n        H += i * current.key\n        current = current.next\n        i += 1\n\n    return [H, L, max_heap_size, pops, pushes]\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    test_cases = [\n        [[1, 4, 5], [1, 3, 4], [2, 6]],\n        [[], [], [0, 2, 2], [3]],\n        [[-5, -2, 0, 3]],\n        [[7, 7], [7], [], [7, 7, 7], [7]],\n        [[1], [2], [3], [4], [5], [6], [7], [8]],\n    ]\n\n    results = []\n    for case in test_cases:\n        list_heads = build_linked_lists(case)\n        result_metrics = merge_k_sorted_lists(list_heads)\n        results.append(result_metrics)\n\n    # Final print statement in the exact required format: [[...],[...],...]\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "3255730"}]}