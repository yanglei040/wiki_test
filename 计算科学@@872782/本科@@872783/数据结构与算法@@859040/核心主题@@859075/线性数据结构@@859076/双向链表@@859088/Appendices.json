{"hands_on_practices": [{"introduction": "第一个实践是一个经典的练习，它完美地展示了双向链表的核心优势：高效的双向遍历。通过使用两个指针分别从链表的两端向中间移动，我们可以用最优的时间和空间复杂度解决回文判断问题。这个练习 [@problem_id:3229848] 将巩固你对 `next` 和 `prev` 指针如何协同工作以实现高效数据访问的理解。", "problem": "你的任务是编写一个完整的、可运行的程序，用于判断多个有限整数序列。程序需要根据每个序列构建一个双向链表，然后判断存储在链表中的数据是否构成回文。程序必须为每个给定的序列构建一个双向链表，然后确定从头到尾读取节点数据所得到的序列是否与从尾到头读取的序列相同。\n\n基本概念。双向链表是一个有限的节点序列，其中每个节点包含一个整数有效载荷和两个引用：一个指向其后继节点的正向引用 `next` 和一个指向其前驱节点的反向引用 `prev`。一个长度为 $n$ 的序列 $(a_0, a_1, \\dots, a_{n-1})$ 是回文，当且仅当对于所有满足 $0 \\le i  \\lfloor n/2 \\rfloor$ 的索引 $i$，都有 $a_i = a_{n-1-i}$ 成立。特别地，根据此定义，空序列（长度 $n = 0$）满足回文属性。\n\n要求和约束。你的算法必须源于这些核心定义，并遵守以下约束，这些约束需要在你的解决方案中用基本原理来证明：\n- 时间复杂度必须与节点数 $n$ 呈线性关系，即 $O(n)$。\n- 额外的空间使用必须相对于 $n$ 是常数，即 $O(1)$，这不包括存储输入双向链表本身所需的空间。特别地，不要分配大小随 $n$ 增长的辅助数组、栈或列表。\n- 不要改变节点的有效载荷或列表的 `next`/`prev` 拓扑结构。你可以通过跟随 `next` 和 `prev` 引用进行遍历，并比较有效载荷。\n\n测试套件。你的程序必须对以下序列评估回文谓词，每个序列都应被解释为双向链表中从头节点到尾节点的数据值：\n- 测试 $1$：$\\langle 1, 2, 3, 2, 1 \\rangle$\n- 测试 $2$：$\\langle 4, 5, 5, 4 \\rangle$\n- 测试 $3$：$\\langle 1, 2, 3, 4, 5 \\rangle$\n- 测试 $4$：$\\langle 7 \\rangle$\n- 测试 $5$：$\\langle \\rangle$ (空列表)\n- 测试 $6$：$\\langle 10, -1, -1, 10 \\rangle$\n- 测试 $7$：$\\langle 2, 2, 2, 2, 2, 2 \\rangle$\n- 测试 $8$：$\\langle 1, 2, 2, 3, 2, 2, 1 \\rangle$\n- 测试 $9$：$\\langle 1, 2 \\rangle$\n- 测试 $10$：$\\langle 0, 1, 0, 1 \\rangle$\n\n答案类型。对于每个测试，你的程序必须生成一个布尔值，指示相应的列表根据上述定义是否为回文。\n\n最终输出格式。你的程序应生成一行输出，其中包含测试 1 到 10 的结果，按顺序排列在一个用方括号括起来的逗号分隔列表中，每个布尔值写为字面标记 True 或 False，且没有空格。例如，一个有效的输出看起来像 [True,False,True]。你的程序必须是自包含的，且不得读取任何输入；它必须在内部为测试构建列表，并打印所需的单行输出。", "solution": "该问题要求创建并验证一个算法，以确定双向链表中的数据是否构成回文。该算法必须遵守严格的复杂度约束：时间复杂度为 $O(n)$，辅助空间复杂度为 $O(1)$，其中 $n$ 是链表中的节点数。\n\n### 问题验证\n\n首先，对问题陈述进行验证。\n- **已知条件**：\n    1.  双向链表节点具有一个整数有效载荷、一个 `next` 引用和一个 `prev` 引用。\n    2.  一个序列 $(a_0, a_1, \\dots, a_{n-1})$ 是回文，如果对于所有满足 $0 \\le i  \\lfloor n/2 \\rfloor$ 的 $i$，都有 $a_i = a_{n-1-i}$。\n    3.  空序列 ($n=0$) 是回文。\n    4.  算法的时间复杂度必须是 $O(n)$。\n    5.  算法的辅助空间复杂度必须是 $O(1)$。\n    6.  链表结构及其数据不得被修改。\n    7.  提供了一个包含十个测试用例的特定套件。\n- **分析**：\n    -   该问题在数据结构和算法的既定原则上具有**科学依据**。双向链表和回文的定义是标准的，并且在数学上是精确的。\n    -   该问题是**适定的**(well-posed)。它提供了清晰的定义、约束和测试用例，为每个测试导出一个唯一的、可验证的布尔结果。\n    -   该问题是**客观的**，没有歧义或主观论断。\n    -   约束条件是自洽的，并且存在一个已知的、满足这些条件的有效算法。\n- **结论**：该问题是有效的。\n\n### 基于原则的算法设计\n\n解决方案直接源于回文的定义和双向链表的结构特性。\n\n1.  **核心原则**：回文的定义 $a_i = a_{n-1-i}$ 要求比较序列中围绕中心对称定位的元素。第 $0$ 个元素必须与第 $(n-1)$ 个元素匹配，第 $1$ 个元素必须与第 $(n-2)$ 个元素匹配，依此类推，直到序列的中间。\n\n2.  **算法策略**：双向链表非常适合这种比较。它允许从两端同时遍历。我们可以采用双指针技术。让一个指针 $p_{\\text{head}}$ 从链表的头部开始，并使用 `next` 引用向前遍历。让第二个指针 $p_{\\text{tail}}$ 从链表的尾部开始，并使用 `prev` 引用向后遍历。在每一步，我们都比较 $p_{\\text{head}}$ 和 $p_{\\text{tail}}$ 指向的节点的数据有效载荷。\n\n3.  **算法形式化**：\n    *   **初始化**：开始时，我们需要访问链表的 `head` 和 `tail`。我们初始化两个指针：$p_{\\text{head}} \\leftarrow \\text{head}$ 和 $p_{\\text{tail}} \\leftarrow \\text{tail}$。\n    *   **边界情况**：\n        *   如果链表为空（`head` 为 null，对应 $n=0$），根据定义，它是一个回文。算法应返回 `True`。\n        *   如果链表只有一个元素（`head == tail`，对应 $n=1$），它也是一个回文。下面设计的主循环逻辑将正确处理这种情况。\n    *   **迭代比较**：算法在一个循环中进行。在每次迭代中：\n        1.  比较数据有效载荷：`if $p_{\\text{head}}.data \\ne p_{\\text{tail}}.data$`，则发现不匹配。该序列不是回文，算法可以立即终止并返回 `False`。\n        2.  将指针向中心推进：$p_{\\text{head}} \\leftarrow p_{\\text{head}}.\\text{next}$ 和 $p_{\\text{tail}} \\leftarrow p_{\\text{tail}}.\\text{prev}$。\n    *   **终止条件**：循环继续，直到指针相遇或交叉，这表示所有必要的配对都已检查完毕。这可以通过以下两个条件之一来检测：\n        1.  `$p_{\\text{head}} == p_{\\text{tail}}$`：当指针在具有奇数个元素的列表的中心节点相遇时，会发生这种情况。\n        2.  `$p_{\\text{head}}.\\text{prev} == p_{\\text{tail}}$`：这发生在指针在具有偶数个元素的列表中交叉之后。`while` 循环条件检查 `p_head != p_tail` 和 `p_head.prev != p_tail` 来优雅地处理这两种情况。一个更简单的方法是在推进指针*之前*检测两个指针是否相邻（`$p_{\\text{head}}.\\text{next} == p_{\\text{tail}}$`），这标志着对偶数长度列表的最后一次比较。\n    *   **最终结果**：如果循环完成而没有发现任何不匹配，则确认对于所有要求的 $i$，都有 $a_i = a_{n-1-i}$。算法返回 `True`。\n\n循环内一个健壮的检查序列是：\n```\nwhile True:\n    if $p_{head}.data \\ne p_{tail}.data$: return False\n    if $p_{head} == p_{tail}$: break  // 到达奇数长度列表的中间\n    if $p_{head}.next == p_{tail}$: break // 到达偶数长度列表的中间\n    $p_{head} \\leftarrow p_{head}.next$\n    $p_{tail} \\leftarrow p_{tail}.prev$\nreturn True\n```\n\n4.  **复杂度证明**：\n    *   **时间复杂度**：指针 $p_{\\text{head}}$ 和 $p_{\\text{tail}}$ 从两端开始，并向彼此移动。每个指针大约遍历 $n/2$ 个节点。由于每个节点所做的工作是常数的（一次比较和一次指针更新），所以总时间与 $n$ 成正比。这得出的时间复杂度为 $O(n)$，满足约束条件。\n    *   **空间复杂度**：该算法只使用固定数量的变量（两个指针：$p_{\\text{head}}$ 和 $p_{\\text{tail}}$）。使用的内存量不随列表大小 $n$ 扩展。因此，辅助空间复杂度为 $O(1)$，满足约束条件。\n    *   **不变性**：该算法只从节点读取数据（`.data`）并跟随现有引用（`.next`、`.prev`）。它不修改任何节点的有效载荷或列表的拓扑结构，遵守了不变性约束。\n\n因此，这种双指针方法是针对所述问题的正确、最优且有原则的解决方案。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to construct doubly linked lists from test cases,\n    check for the palindrome property, and print the results.\n    \"\"\"\n\n    class Node:\n        \"\"\"\n        Represents a node in a doubly linked list.\n        Each node contains an integer payload, a 'next' reference,\n        and a 'prev' reference.\n        \"\"\"\n        def __init__(self, data=0, prev=None, next=None):\n            self.data = data\n            self.prev = prev\n            self.next = next\n\n    def build_doubly_linked_list(data_list):\n        \"\"\"\n        Constructs a doubly linked list from a Python list of integers.\n\n        Args:\n            data_list: A list of integers.\n\n        Returns:\n            A tuple (head, tail) representing the head and tail nodes\n            of the newly created list. Returns (None, None) for an empty list.\n        \"\"\"\n        if not data_list:\n            return None, None\n\n        # Create the head node\n        head = Node(data=data_list[0])\n        previous_node = head\n\n        # Create subsequent nodes and link them\n        for i in range(1, len(data_list)):\n            new_node = Node(data=data_list[i], prev=previous_node)\n            previous_node.next = new_node\n            previous_node = new_node\n        \n        # The last node created is the tail\n        tail = previous_node\n        return head, tail\n\n    def is_palindrome(head, tail):\n        \"\"\"\n        Determines if a doubly linked list is a palindrome.\n\n        The algorithm uses a two-pointer approach, one starting from the head and\n        one from the tail, moving towards the center and comparing node data.\n        This respects the O(n) time and O(1) space constraints.\n\n        Args:\n            head: The head node of the list.\n            tail: The tail node of the list.\n\n        Returns:\n            True if the list is a palindrome, False otherwise.\n        \"\"\"\n        # An empty list (n=0) is a palindrome by definition.\n        if head is None:\n            return True\n\n        p_head = head\n        p_tail = tail\n\n        while True:\n            # Compare data from both ends. If they differ, it's not a palindrome.\n            if p_head.data != p_tail.data:\n                return False\n\n            # Termination condition for odd-length lists: pointers meet at the center.\n            if p_head == p_tail:\n                break\n\n            # Termination condition for even-length lists: pointers are adjacent.\n            if p_head.next == p_tail:\n                break\n\n            # Move pointers towards the center.\n            p_head = p_head.next\n            p_tail = p_tail.prev\n        \n        return True\n\n    # The test suite provided in the problem statement.\n    test_cases = [\n        [1, 2, 3, 2, 1],        # Test 1\n        [4, 5, 5, 4],           # Test 2\n        [1, 2, 3, 4, 5],        # Test 3\n        [7],                    # Test 4\n        [],                     # Test 5\n        [10, -1, -1, 10],       # Test 6\n        [2, 2, 2, 2, 2, 2],     # Test 7\n        [1, 2, 2, 3, 2, 2, 1],  # Test 8\n        [1, 2],                 # Test 9\n        [0, 1, 0, 1],           # Test 10\n    ]\n\n    results = []\n    for data_list in test_cases:\n        list_head, list_tail = build_doubly_linked_list(data_list)\n        result = is_palindrome(list_head, list_tail)\n        results.append(result)\n\n    # Format and print the final output as a single string.\n    output_str = f\"[{','.join(map(str, results))}]\"\n    print(output_str)\n\nsolve()\n```", "id": "3229848"}, {"introduction": "从遍历转向结构操作，这个练习 [@problem_id:3229730] 挑战你将一个双向链表在指定节点处分割成两个独立的、有效的链表。这个任务要求你精确地处理 `next` 和 `prev` 指针，以确保两个新链表的结构完整性不被破坏。掌握这种操作对于实现更复杂的基于链表的算法和数据结构至关重要。", "problem": "考虑一个双向链表，该链表由节点定义，每个节点 $u$ 包含三个字段：一个值 $u.\\text{val}$、一个后向指针 $u.\\text{prev}$ 和一个前向指针 $u.\\text{next}$。该结构必须满足以下不变性以确保有效性：对于任何相邻节点 $(u, v)$，若 $u.\\text{next} = v$，则必须有 $v.\\text{prev} = u$；头节点 $h$ 必须有 $h.\\text{prev} = \\text{`None`}$；尾节点 $t$ 必须有 $t.\\text{next} = \\text{`None`}$。给定一个头指针 $h$ 和一个指向节点的指针 $p$，您必须在 $p$ 处将链表分割成两个独立的有效链表，使得左侧链表由从 $h$ 到 $p$ 的前驱节点的连续段组成，而右侧链表由从 $p$ 开始到尾部 $t$ 的连续段组成。形式上，分割后，左侧链表包含从 $h$ 到 $p.\\text{prev}$ 的节点序列，右侧链表包含从 $p$ 到 $t$ 的节点序列，且两个链表都必须独立满足双向链表的不变性。如果 $p$ 等于 $h$，则左侧链表为空；如果 $p$ 等于 $t$，则右侧链表仅包含 $t$；如果输入链表为空，或者 $p$ 不属于以 $h$ 为根的链表，则必须报告分割无效，且不应应用任何结构性更改。唯一允许的遍历是验证 $p$ 是否属于以 $h$ 为根的链表；实现分割所需的所有结构性修改必须通过常数次局部指针赋值来完成，确保修改阶段的时间复杂度为 $O(1)$。除输入存储外，内存使用量应保持在 $O(1)$。您的任务是实现一个程序，该程序构建指定的链表，尝试执行所述的分割操作，验证结果链表，并输出结果。\n\n用作推理基础的定义和要求：\n- 双向链表是一个节点序列 $(u_0, u_1, \\dots, u_{n-1})$，其中对于所有索引 $i$ 且 $0 \\le i  n-1$，我们有 $u_i.\\text{next} = u_{i+1}$ 和 $u_{i+1}.\\text{prev} = u_i$，同时 $u_0.\\text{prev} = \\text{`None`}$ 且 $u_{n-1}.\\text{next} = \\text{`None`}$。\n- 双向链表的有效性意味着上述不变性在整个结构中都得到满足。\n- 在指针 $p$ 处的分割被定义为产生两个链表 $(L_{\\text{left}}, L_{\\text{right}})$，其中 $L_{\\text{left}}$ 包含从 $h$ 开始通过跟踪 `.`next` 直到节点 $p.\\text{prev}$（含）所能到达的节点，而 $L_{\\text{right}}$ 包含从 $p$ 开始通过跟踪 `.`next` 所能到达的节点。\n\n程序规范：\n- 对于每个测试用例，从给定的整数序列构建输入链表，并通过位置 $k$（其中 $k$ 是从头节点开始计数的索引，从0开始）或选择一个不属于所构建链表的节点来确定指针 $p$。按照上述定义在 $p$ 处尝试分割。\n- 尝试分割后，计算一个布尔值 $b$，该值指示是否发生了有效分割并且两个结果链表都满足不变性。当且仅当 $p$ 属于该链表且分割后的两个结果链表各自都有效时，$b$ 的值必须为 True；否则 $b$ 必须为 False。当 $b$ 为 False 时，左侧链表必须与原始链表相同，右侧链表必须为空。\n- 对于每个测试用例，输出一个列表 $[b, L_{\\text{left}}^{\\text{vals}}, L_{\\text{right}}^{\\text{vals}}]$，其中 $L_{\\text{left}}^{\\text{vals}}$ 和 $L_{\\text{right}}^{\\text{vals}}$ 分别是左右链表中从头到尾的整数值序列。\n\n要实现的测试套件：\n- 案例1：值为 $[2, 4, 6, 8, 10]$，在索引 $k = 2$ 处（值为 $6$ 的节点）分割。\n- 案例2：值为 $[1, 3, 5]$，在索引 $k = 0$ 处（头节点）分割。\n- 案例3：值为 $[7, 9, 11, 13]$，在索引 $k = 3$ 处（尾节点）分割。\n- 案例4：值为 $[42]$，在索引 $k = 0$ 处（单元素链表）分割。\n- 案例5：值为 $[5, 10, 15]$，使用一个指针 $p$ 进行分割，该指针引用自一个值为 $[99]$ 的独立链表中的节点（因此 $p$ 不属于第一个链表）。\n- 案例6：值为 $[]$（空链表），且 $p = \\text{`None`}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个元素按上述顺序对应一个测试用例。每个元素本身必须是 Python 列表字面量 $[b, L_{\\text{left}}^{\\text{vals}}, L_{\\text{right}}^{\\text{vals}}]$，最终输出形式为 $[[\\dots],[\\dots],\\dots]$。", "solution": "该问题要求在双向链表上实现分割操作，并对该过程进行全面验证。我将首先验证问题陈述本身，然后着手进行算法的原则性设计及实现。\n\n### 问题验证\n\n**步骤1：提取已知条件**\n\n- **数据结构**：双向链表由节点 $u$ 组成。每个节点都有字段 $u.\\text{val}$、$u.\\text{prev}$ 和 $u.\\text{next}$。\n- **不变性**：\n    1. 对于任何相邻节点 $(u, v)$，若 $u.\\text{next} = v$，则必须有 $v.\\text{prev} = u$。\n    2. 头节点 $h$ 必须有 $h.\\text{prev} = \\text{`None`}$。\n    3. 尾节点 $t$ 必须有 $t.\\text{next} = \\text{`None`}$。\n- **输入**：指向链表的头指针 $h$ 和指向节点的指针 $p$。\n- **分割操作**：\n    - 链表被分割成两个新链表 $L_{\\text{left}}$ 和 $L_{\\text{right}}$。\n    - $L_{\\text{left}}$ 包含从 $h$ 开始到 $p$ 的前驱节点（包含 $p$ 的前驱节点）的连续段。形式上，即从 $h$到 $p.\\text{prev}$ 的节点。\n    - $L_{\\text{right}}$ 包含从 $p$ 开始到尾节点 $t$ 的连续段。\n    - 如果 $p = h$，则 $L_{\\text{left}}$ 为空。\n- **无效分割条件**：\n    1. 输入链表为空。\n    2. 指针 $p$ 不在以 $h$ 为根的链表中。\n    - 在这些情况下，不应进行任何结构性更改。\n- **复杂度约束**：\n    - 结构性修改必须使用常数次局部指针赋值，从而在修改阶段实现 $O(1)$ 的时间复杂度。\n    - 允许将 $p$ 的成员资格验证作为独立的遍历步骤。\n    - 除输入存储外，内存使用量必须为 $O(1)$。\n- **程序规范**：\n    - 为每个测试用例构建链表。\n    - 尝试进行分割。\n    - 计算一个布尔值 `b`，当且仅当 `p` 在链表中且两个结果链表都有效时，该值为 `True`。\n    - 如果 `b` 为 `False`，$L_{\\text{left}}$ 必须是原始链表，$L_{\\text{right}}$ 必须为空。\n    - 每个测试用例的输出：一个列表 $[b, L_{\\text{left}}^{\\text{vals}}, L_{\\text{right}}^{\\text{vals}}]$，其中 `vals` 是整数值的序列。\n- **测试套件**：\n    1. 值为 $[2, 4, 6, 8, 10]$，在索引 $k=2$ 处分割。\n    2. 值为 $[1, 3, 5]$，在索引 $k=0$ 处分割。\n    3. 值为 $[7, 9, 11, 13]$，在索引 $k=3$ 处分割。\n    4. 值为 $[42]$，在索引 $k=0$ 处分割。\n    5. 值为 $[5, 10, 15]$，使用来自独立链表 $[99]$ 的 $p$ 进行分割。\n    6. 值为 $[]$，且 $p = \\text{`None`}$。\n\n**步骤2：使用提取的已知条件进行验证**\n\n根据验证标准对问题陈述进行评估。\n\n- **科学依据**：该问题植根于计算机科学领域，特别是数据结构与算法。双向链表、其不变性以及指针操作等概念都是标准且成熟的主题。该问题不含伪科学。\n- **定义明确**：该问题定义明确。有效双向链表的定义、分割操作以及无效分割的条件都非常精确。对于任何给定的输入 $(h, p)$，所期望的输出是唯一确定的。\n- **客观性**：语言正式且客观。要求被量化说明（例如，复杂度约束）并从行为上定义（例如，输出格式，无效情况的处理）。\n- **自洽与一致性**：该问题提供了所有必要的定义、约束和测试用例。这些定义在内部是一致的。例如，修改操作的 $O(1)$ 时间复杂度约束与查找节点 $p$ 的 $O(n)$ 搜索被正确区分开来。\n- **非不切实际或过于简单**：这项任务是数据结构操作中一个标准的、非平凡的练习，需要仔细处理指针和边界情况（例如，在头、尾或单元素链表中进行分割）。它并非物理上不可行，因为它存在于计算机科学的抽象领域中。\n- **非故作高深**：要求是具体且算法化的，而非隐喻或哲学上空洞的。\n\n该问题没有表现出验证清单中列出的任何缺陷。\n\n**步骤3：结论与行动**\n\n问题是有效的。我将继续提供解决方案。\n\n### 算法设计与原则\n\n该解决方案围绕一个 `Node` 类和一个执行分割的主函数构建。其设计直接实现了问题陈述中概述的原则。\n\n1.  **数据表示**：定义一个 `Node` 类来表示双向链表的每个元素。它封装了整数值 $v$、一个指向下一个节点的指针 `next` 和一个指向前一个节点的指针 `prev`。此结构直接对应于字段 $u.\\text{val}$、$u.\\text{next}$ 和 $u.\\text{prev}$。\n\n2.  **链表验证**：一个关键组件是验证函数 `validate_list(head)`。此函数从其 `head` 开始，根据已定义的不变性系统地检查一个链表。\n    - 它首先检查头节点不变性：`head.prev` 必须为 `None`。\n    - 然后它从头到尾遍历链表，并对每个节点 $u$ 验证核心不变性：如果 $v = u.\\text{next}$，则必须有 $v.\\text{prev} = u$。\n    - 遍历过程确认能够到达一个 `next` 为 `None` 的节点，从而隐式地满足了尾节点不变性。\n    - 空链表（`head = None`）被认为是有效的。\n    此函数对于计算最终的布尔状态 `b` 至关重要。\n\n3.  **分割逻辑**：核心函数 `split_list(h, p)` 实现指定的操作并遵循严格的协议。\n    - **初始检查**：它首先处理两种无效分割的基本情况。如果链表为空（$h = \\text{`None`}$) 或目标节点为空（$p = \\text{`None`}$) ，则操作无法继续。问题将此定义为无效分割。\n    - **成员资格验证**：按照规定，算法必须首先验证 `p` 是以 `h` 为根的链表的成员。这通过从 `h` 开始的线性遍历来完成，比较对象标识（Python 中的 `is` 运算符）来检查链表中是否有任何节点与 `p` 是同一个对象。如果未找到 `p`，则分割无效。根据问题规则，原始链表 `h` 作为“左”部分返回，空链表作为“右”部分返回。\n    - **指针操作（$O(1)$ 修改）**：如果找到 `p`，则通过常数次指针赋值执行结构性分割。设 `prev_p` 为节点 `p.prev`。\n        - `prev_p` 和 `p` 之间的连接被切断。`prev_p.next` 被设置为 `None`，使 `prev_p` 成为左侧链表的新尾节点。\n        - 来自 $p$ 的后向指针被切断。`p.prev` 被设置为 `None`，使 $p$ 成为右侧链表的新头节点。\n    - **边界情况：在头节点处分割**：如果 $p = h$，则会出现特殊情况。在这种情况下，`p.prev` 已经是 `None`，因此不存在 `prev_p` 节点。左侧链表变为空，右侧链表是原始链表，现在由 $p$ 正确地作为头节点，且 `p.prev = None`。\n    - **结果**：指针操作后，函数返回一个元组，其中包含一个表示成功的布尔值以及指向新的左右链表的头指针。仅当成员资格检查通过时，表示成功的布尔值才为 `True`。根据问题对 `b` 的定义，对*结果*链表进行更严格的验证由调用函数处理。\n\n4.  **测试用例执行**：主函数 `solve` 为给定的测试套件协调整个过程。\n    - 对于每种情况，它从值序列中构建初始的双向链表。\n    - 它根据测试用例的规范（通过索引或提供外部节点）来识别节点 $p$。\n    - 它调用 `split_list` 函数。\n    - 根据返回的标志和指针，它执行最终的验证步骤：它在两个结果子链表上都调用 `validate_list`。最终状态 `b` 是分割初始可能性与两个结果链表都有效的逻辑与。\n    - 最后，它将结果格式化为 $[b, L_{\\text{left}}^{\\text{vals}}, L_{\\text{right}}^{\\text{vals}}]$，并汇总所有测试用例的结果以供最终输出。这种关注点分离——分割逻辑与最终验证——确保了实现与问题对 `b` 的定义精确匹配。\n\n这种有原则的、循序渐进的方法确保了问题陈述中的所有约束和定义都以逻辑和算法的严谨性得到满足。", "answer": "```python\nimport numpy as np  # Environment specified, though not used in algorithm.\n\nclass Node:\n    \"\"\"\n    Represents a node in a doubly linked list.\n    Each node u contains u.val, u.next, and u.prev.\n    \"\"\"\n    def __init__(self, value, prev_node=None, next_node=None):\n        self.val = value\n        self.prev = prev_node\n        self.next = next_node\n\ndef build_list_from_sequence(seq):\n    \"\"\"Constructs a doubly linked list from a sequence of values.\"\"\"\n    if not seq:\n        return None\n    \n    head = Node(seq[0])\n    current = head\n    for val in seq[1:]:\n        new_node = Node(val, prev_node=current)\n        current.next = new_node\n        current = new_node\n    return head\n\ndef get_list_values(head):\n    \"\"\"Traverses a doubly linked list and returns its values.\"\"\"\n    if not head:\n        return []\n    \n    values = []\n    current = head\n    while current:\n        values.append(current.val)\n        current = current.next\n    return values\n\ndef get_node_at_index(head, k):\n    \"\"\"Retrieves the node at a specific index k from the head.\"\"\"\n    if k  0:\n        return None\n    current = head\n    i = 0\n    while current and i  k:\n        current = current.next\n        i += 1\n    return current\n\ndef validate_list(head):\n    \"\"\"\n    Validates a doubly linked list against its invariants.\n    1. h.prev must be None.\n    2. For u.next = v, it must be that v.prev = u.\n    3. The last node t must have t.next = None.\n    \"\"\"\n    if head is None:\n        return True  # An empty list is valid.\n\n    # Check head invariant\n    if head.prev is not None:\n        return False\n    \n    current = head\n    while current.next is not None:\n        next_node = current.next\n        # Check forward-backward consistency\n        if next_node.prev is not current:\n            return False\n        current = next_node\n\n    # The loop terminates when current.next is None, satisfying the tail invariant.\n    return True\n\ndef split_list(h, p):\n    \"\"\"\n    Attempts to split the list at node p.\n    Returns (split_possible, left_head, right_head).\n    \"\"\"\n    original_h = h\n    \n    if h is None or p is None:\n        # Invalid split if list is empty or p is None.\n        return (False, original_h, None)\n\n    # 1. Verify that p is in the list rooted at h.\n    current = h\n    found = False\n    while current:\n        if current is p:\n            found = True\n            break\n        current = current.next\n    \n    if not found:\n        # p is not in the list.\n        return (False, original_h, None)\n\n    # 2. Perform the O(1) split operation.\n    left_head = h\n    right_head = p\n    \n    prev_p = p.prev\n    \n    if prev_p is not None:\n        # p is not the head, so we sever the link.\n        prev_p.next = None\n    else:\n        # p is the head, so the left list becomes empty.\n        left_head = None\n        \n    p.prev = None\n    \n    return (True, left_head, right_head)\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and produce the final output.\n    \"\"\"\n    # Test Suite Definition\n    test_cases_spec = [\n        {\"vals\": [2, 4, 6, 8, 10], \"k\": 2},\n        {\"vals\": [1, 3, 5], \"k\": 0},\n        {\"vals\": [7, 9, 11, 13], \"k\": 3},\n        {\"vals\": [42], \"k\": 0},\n        {\"vals\": [5, 10, 15], \"p_external\": Node(99)},\n        {\"vals\": [], \"p_external\": None}\n    ]\n\n    results = []\n\n    for case in test_cases_spec:\n        vals = case[\"vals\"]\n        head = build_list_from_sequence(vals)\n        \n        # Determine the pointer p for the split\n        if \"k\" in case:\n            p = get_node_at_index(head, case[\"k\"])\n        else:\n            p = case.get(\"p_external\")\n            \n        # Attempt the split\n        split_possible, left_head, right_head = split_list(head, p)\n        \n        # Validate the resulting lists\n        left_list_valid = validate_list(left_head)\n        right_list_valid = validate_list(right_head)\n        \n        # Determine final boolean b as per problem statement\n        b = split_possible and left_list_valid and right_list_valid\n        \n        # Per problem specification for invalid splits (b=False)\n        if not b:\n            if split_possible:\n                # If split occurred but was invalid, we must revert.\n                # A robust solution would re-link, but the problem's output format\n                # for b=False is defined based on the original list.\n                # Re-constructing the original state for output is simpler.\n                final_left_head = build_list_from_sequence(vals)\n                final_right_head = None\n            else:\n                final_left_head = left_head # Unmodified original list head\n                final_right_head = right_head # Should be None\n        else:\n            final_left_head = left_head\n            final_right_head = right_head\n\n        left_vals = get_list_values(final_left_head)\n        right_vals = get_list_values(final_right_head)\n        \n        results.append(f\"[{b}, {left_vals}, {right_vals}]\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3229730"}, {"introduction": "这项高级实践引入了一种分层的双向链表，其中节点可以拥有一个指向另一个链表的 `child` 指针。你的任务是将这种多层结构“扁平化”为一个单一的、线性的双向链表，这是在解析嵌套数据时常见的问题 [@problem_id:3229789]。这个练习将考验你以系统性的、深度优先的方式执行复杂指针拼接的能力，要求你进行递归思考或设计出精巧的迭代解决方案。", "problem": "给定一个可能存在多级嵌套的双向链表的形式化定义。每个节点存储一个整数值和三个指针：一个前驱指针、一个后继指针和一个子节点指针。其基础是双向链表的核心定义和指针操作法则：对于同一层级的任意两个连续节点，如果节点 $u$ 紧邻节点 $v$ 之前，则不变量 $u.\\text{next} = v$ 和 $v.\\text{prev} = u$ 成立。在多级双向链表中，一个节点可能有一个额外的指针 $u.\\text{child}$，指向另一个双向链表的头部，从而形成一个层级结构。所有指针要么是有效引用，要么是空指针(null)。\n\n实现一个过程，通过将每个子链表拼接到节点及其原始后继节点之间，将这样的多级双向链表扁平化为一个单级双向链表。扁平化的顺序必须是子链表的深度优先前序遍历：对于任意节点 $u$，如果 $u.\\text{child}$ 非空，则该子链表中的所有节点（递归扁平化后）必须紧跟在 $u$ 之后，然后才是在 $u.\\text{next}$ 处继续。扁平化之后：\n- 最终结构必须是一个单级双向链表，对每一对连续节点都遵循不变量 $u.\\text{next} = v$ 和 $v.\\text{prev} = u$。\n- 每个节点的 $u.\\text{child}$ 指针都必须设置为空(`null`)。\n- 扁平化后链表中的节点值必须按指定的深度优先顺序出现。\n- 不得分配新节点，也不得引入环。\n\n您的程序必须在内部构建以下多级链表的测试套件，并对每一个进行扁平化，为每种情况生成扁平化后链表中的节点值序列。\n\n测试套件（值为整数，索引在每个层级内从零开始）：\n1. 包含多个子节点和嵌套子节点的正常路径：\n   - 主层级值：$[10,20,30,40]$。\n   - 子节点关系：\n     - 索引为 $1$ 的节点（值为 $20$）拥有值为 $[5,6]$ 的子链表，在该子链表中，索引为 $1$ 的节点（值为 $6$）拥有值为 $[99]$ 的子链表。\n     - 索引为 $2$ 的节点（值为 $30$）拥有值为 $[7]$ 的子链表。\n2. 空链表的边界情况：\n   - 主层级值：$[]$。\n3. 单个节点带有深度线性子链：\n   - 主层级值：$[1]$。\n   - 子节点关系：\n     - 索引为 $0$ 的节点（值为 $1$）拥有子链表 $[2]$，该子链表中索引为 $0$ 的节点（值为 $2$）拥有子链表 $[3]$，而后者中索引为 $0$ 的节点（值为 $3$）拥有子链表 $[4]$。\n4. 多个连续节点拥有子链表，且这些子链表内部还有嵌套子链表：\n   - 主层级值：$[3,14,15]$。\n   - 子节点关系：\n     - 索引为 $0$ 的节点（值为 $3$）拥有子链表 $[9,2]$，在该子链表中，索引为 $0$ 的节点（值为 $9$）拥有子链表 $[1]$。\n     - 索引为 $2$ 的节点（值为 $15$）拥有子链表 $[26,53]$，在该子链表中，索引为 $1$ 的节点（值为 $53$）拥有子链表 $[58]$。\n5. 头节点拥有子链表，且该子链表本身包含多个拥有各自子链表的节点：\n   - 主层级值：$[100]$。\n   - 子节点关系：\n     - 索引为 $0$ 的节点（值为 $100$）拥有子链表 $[200,300]$。\n     - 在该子链表中，索引为 $0$ 的节点（值为 $200$）拥有子链表 $[400]$，索引为 $1$ 的节点（值为 $300$）拥有子链表 $[500]$。\n\n您的算法设计必须从第一性原理出发：利用双向链表的核心不变量和指针拼接，并对深度优先搜索（DFS）中的遍历顺序和栈规则进行推理。不要提供捷径公式；通过在每次拼接时维持不变量来推导其正确性。目标时间复杂度必须为 $O(n)$（其中 $n$ 是节点数），如果使用显式栈，则辅助空间为 $O(d)$（其中 $d$ 是最大嵌套深度），或者如果使用不带显式栈和仔细指针穿针引线的原地遍历，则辅助空间为 $O(1)$。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表的每个元素是对应一个测试用例的扁平化值序列。例如，格式必须是 `[[1,2],[3],[]]`。\n\n每个测试用例的答案必须是一个整数列表。此问题不涉及物理单位或角度单位。您的程序不得读取输入；它必须在内部构建指定的测试套件，并以上述确切格式打印汇总结果。", "solution": "## 问题验证\n\n### 步骤 1：提取已知条件\n\n- **数据结构定义**：一个多级双向链表，其中每个节点包含一个整数值和三个指针：`prev`、`next` 和 `child`。\n- **基本不变量**：对于同一层级上的任意两个连续节点 `u` 和 `v`，`u.next = v` 且 `v.prev = u`。\n- **层级结构**：节点的 `child` 指针可以指向另一个双向链表的头部。所有指针要么是有效引用，要么是空(null)。\n- **任务**：将多级链表扁平化为单级双向链表。\n- **扁平化规则**：将每个子链表拼接到节点 `u` 及其原始后继节点 `u.next` 之间。\n- **扁平化顺序**：子链表的深度优先前序遍历。如果 `u.child` 非空，则递归扁平化的子链表必须紧跟在 `u` 之后。\n- **扁平化后条件**：\n    1. 结果是一个单级双向链表。\n    2. 不变量 `u.next = v` 和 `v.prev = u` 对所有连续节点对均成立。\n    3. 所有 `child` 指针必须设置为空(null)。\n    4. 扁平化后链表中的节点值必须按深度优先顺序出现。\n    5. 不得分配新节点。\n    6. 不得引入环。\n- **性能目标**：\n    - 时间复杂度：$O(n)$，其中 $n$ 是节点总数。\n    - 空间复杂度：对于显式栈方法为 $O(d)$（其中 $d$ 是最大深度），或对于原地迭代方法为 $O(1)$。\n- **测试套件**：\n    1. 主链表：`[10,20,30,40]`。子链表：`20` - `[5,6]`；`6` - `[99]`；`30` - `[7]`。\n    2. 主链表：`[]`。\n    3. 主链表：`[1]`。子链表：`1` - `[2]`；`2` - `[3]`；`3` - `[4]`。\n    4. 主链表：`[3,14,15]`。子链表：`3` - `[9,2]`；`9` - `[1]`；`15` - `[26,53]`；`53` - `[58]`。\n    5. 主链表：`[100]`。子链表：`100` - `[200,300]`；`200` - `[400]`；`300` - `[500]`。\n- **输出格式**：一个单行字符串，表示一个由整数列表组成的列表，例如 `[[1,2],[3],[]]`。\n\n### 步骤 2：使用提取的已知条件进行验证\n\n根据指定标准对问题进行验证。\n\n- **科学性基础（关键）**：该问题根植于计算机科学，特别是数据结构和算法领域。双向链表、指针和遍历算法（深度优先搜索）等概念是公认且数学上严谨的。该问题在事实上和逻辑上都是合理的。\n- **良构性**：问题定义清晰。输入结构已指定，转换规则明确（深度优先前序拼接），并且明确列出了输出的期望属性。对于任何有效输入，都存在一个唯一的扁平化列表。\n- **客观性（关键）**：问题以精确、形式化的语言陈述，不含主观性或个人观点。\n- **完整性**：问题提供了构建和验证解决方案所需的所有必要定义、约束和测试用例。它是自包含的。\n- **一致性**：约束条件之间不矛盾。深度优先顺序规则与原地拼接操作是一致的。\n- **现实性**：该问题是一个抽象的算法挑战，不涉及物理现象。其约束在计算上是可行的。\n- **其他缺陷**：该问题不是琐碎、比喻性或同义反复的。它代表了基于指针的数据结构操作中的一个标准的、实质性的挑战。其正确性是可验证的。\n\n### 步骤 3：结论与行动\n\n问题陈述是 **有效的**。它是数据结构和算法领域中一个良构、形式化且可验证的问题。我将继续提供完整的解决方案。\n\n## 算法设计与推导\n\n目标是原地将一个多级双向链表扁平化为单级链表，节点按深度优先前序遍历的顺序排列。我们必须在整个过程中保持双向链表的不变量。最高效的解决方案将以 $O(1)$ 的辅助空间实现这一目标。\n\n**核心原理：原地拼接**\n基本操作是将子链表拼接到主链表中。考虑一个节点 `u`，其后继节点为 `v = u.next`，子链表头节点为 `c_head = u.child`。设该子链表的尾节点为 `c_tail`。要将子链表插入到 `u` 和 `v` 之间，需要进行以下指针重新分配，以保持链表的完整性：\n1. 从 `u` 出发的链接现在必须指向 `c_head`：$u.\\text{next} \\leftarrow c_{\\text{head}}$。\n2. 从 `c_head` 出发的反向链接必须指向 `u`：$c_{\\text{head}}.\\text{prev} \\leftarrow u$。\n3. 从子链表尾部 `c_tail` 出发的链接必须指向 `u` 的原始后继节点 `v`：$c_{\\text{tail}}.\\text{next} \\leftarrow v$。\n4. 如果 `v` 存在（即不为 null），其反向链接必须指向 `c_tail`：$v.\\text{prev} \\leftarrow c_{\\text{tail}}$。\n5. 最后，问题要求将子指针置为 null：$u.\\text{child} \\leftarrow \\text{null}$。\n\n**算法推导：使用 $O(1)$ 空间的迭代遍历**\n使用单个主指针遍历链表的迭代方法提供了一种优雅且空间高效的解决方案。关键的洞见在于，通过在遍历时修改 `.next` 指针，遍历路径本身就可以遵循所期望的深度优先顺序。\n\n我们来定义算法：\n1. 初始化一个指针 `curr` 指向列表的 `head`。如果 `head` 为 null，则列表为空，过程终止。\n2. 当 `curr` 不为 null 时进行迭代。在每次迭代中，我们检查 `curr`：\n   a. **情况 1：`curr` 没有子节点（`curr.child` 为 null）。**列表在该节点处已经是局部扁平的。我们只需将指针前进到当前层级的下一个节点：`curr \\leftarrow curr.next`。\n   b. **情况 2：`curr` 有子节点（`curr.child` 非 null）。**我们必须执行拼接操作。\n      i. 首先，我们需要找到从 `curr.child` 开始的子链表的尾部。我们使用一个临时指针 `child_tail`，初始化为 `curr.child`，并遍历其 `.next` 指针直到到达最后一个节点：`while (child_tail.next is not null) child_tail \\leftarrow child_tail.next`。**至关重要的是要注意，这找到的是直接子链表的尾部；其中任何嵌套的子节点稍后会随着主指针 `curr` 自然地遍历到新拼接的段中而被处理。**\n      ii. 令 `original_next = curr.next` 为最终将跟随在拼接进来的子链表之后的节点。\n      iii. 现在我们根据核心原理执行拼接。我们将 `child_tail` 连接到 `original_next`：`child_tail.next \\leftarrow original_next`。如果 `original_next` 不为 null，我们更新其 `prev` 指针：`original_next.prev \\leftarrow child_tail`。\n      iv. 接下来，我们将 `curr` 连接到其子链表：`curr.next \\leftarrow curr.child` 和 `curr.child.prev \\leftarrow curr`。\n      v. 最后，我们按要求将子指针设置为 null：`curr.child \\leftarrow null`。\n   c. 处理完两种情况后，`while` 循环继续。如果我们执行了拼接操作，`curr.next` 现在指向子链表的头部。因此，当我们最终推进 `curr` 时，我们自然会下降到子问题中，从而产生所需的深度优先顺序。循环结构会自动处理这一点。为简单和正确起见，我们在每次循环迭代结束时都推进 `curr`。\n\n**复杂度分析**\n- **时间复杂度**：主指针 `curr` 对整个结构中的每个节点恰好访问一次。用于寻找 `child_tail` 的内部 `while` 循环遍历一个子链表的 `next` 指针。由于每个这样的列表都立即整合到主列表中，并且不会再被内部循环遍历，因此整个结构中的每条 `next` 边都被遍历了少量常数次。因此，总运行时间与节点数 $n$ 成线性关系，得出复杂度为 $O(n)$。\n- **空间复杂度**：该算法使用固定数量的指针变量（`curr`、`original_next`、`child_tail`），无论列表的大小或深度如何。没有使用递归栈或辅助数据结构。因此，辅助空间复杂度为 $O(1)$。\n\n该算法是正确的，满足所有问题约束，并且在空间方面是最高效的。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass Node:\n    \"\"\"\n    Represents a node in a multi-level doubly linked list.\n    \"\"\"\n    def __init__(self, val: int, prev: 'Node' = None, next: 'Node' = None, child: 'Node' = None):\n        self.val = val\n        self.prev = prev\n        self.next = next\n        self.child = child\n\ndef flatten(head: 'Node') - 'Node':\n    \"\"\"\n    Flattens a multi-level doubly linked list into a single level in-place.\n    The algorithm uses an iterative approach with O(1) auxiliary space.\n\n    Args:\n        head: The head node of the multi-level list.\n\n    Returns:\n        The head of the flattened list.\n    \"\"\"\n    if not head:\n        return None\n\n    curr = head\n    while curr:\n        # If there is no child, we just move on to the next node.\n        if not curr.child:\n            curr = curr.next\n            continue\n\n        # If a child exists, we need to splice it in.\n        child_node = curr.child\n\n        # 1. Find the tail of the child list.\n        child_tail = child_node\n        while child_tail.next:\n            child_tail = child_tail.next\n        \n        # 2. Store the original next node of curr.\n        original_next = curr.next\n\n        # 3. Connect the child_tail to the original_next.\n        child_tail.next = original_next\n        if original_next:\n            original_next.prev = child_tail\n\n        # 4. Connect curr to its child list.\n        curr.next = child_node\n        child_node.prev = curr\n\n        # 5. Nullify the child pointer.\n        curr.child = None\n\n        # 6. Advance the current pointer.\n        # This is handled by the loop's structure, but for clarity:\n        # curr will naturally advance to curr.next, which is now the child's head.\n        curr = curr.next\n    \n    return head\n\ndef build_list_from_spec(spec: tuple) - 'Node':\n    \"\"\"\n    Helper function to build a multi-level list from a specification tuple.\n    The spec is of the form (values: list, children: dict), where the children\n    dict maps parent index to another spec tuple.\n    \"\"\"\n    values, child_map = spec\n    if not values:\n        return None\n    \n    nodes = [Node(val) for val in values]\n    for i in range(len(nodes)):\n        if i > 0:\n            nodes[i].prev = nodes[i-1]\n        if i  len(nodes) - 1:\n            nodes[i].next = nodes[i+1]\n            \n    for parent_idx, child_spec in child_map.items():\n        child_head = build_list_from_spec(child_spec)\n        if child_head:\n            nodes[parent_idx].child = child_head\n            \n    return nodes[0] if nodes else None\n\ndef get_list_values(head: 'Node') - list[int]:\n    \"\"\"\n    Traverses a flattened list and returns a list of its node values.\n    \"\"\"\n    if not head:\n        return []\n    \n    values = []\n    curr = head\n    while curr:\n        values.append(curr.val)\n        curr = curr.next\n    return values\n\ndef solve():\n    \"\"\"\n    Defines test cases, runs the flatten algorithm on each, and prints results.\n    \"\"\"\n    # Define the test suite of multi-level lists as specifications.\n    test_specs = [\n        # 1. Happy path with multiple children and nested child\n        ([10, 20, 30, 40], {\n            1: ([5, 6], {1: ([99], {})}),\n            2: ([7], {})\n        }),\n        # 2. Boundary case of an empty list\n        ([], {}),\n        # 3. Single node with a deep linear child chain\n        ([1], {0: ([2], {0: ([3], {0: ([4], {})})})}),\n        # 4. Multiple consecutive nodes having children\n        ([3, 14, 15], {\n            0: ([9, 2], {0: ([1], {})}),\n            2: ([26, 53], {1: ([58], {})})\n        }),\n        # 5. Head has a child, child list has children\n        ([100], {\n            0: ([200, 300], {\n                0: ([400], {}),\n                1: ([500], {})\n            })\n        })\n    ]\n\n    results = []\n    for spec in test_specs:\n        head = build_list_from_spec(spec)\n        flattened_head = flatten(head)\n        result_values = get_list_values(flattened_head)\n        results.append(result_values)\n\n    # Format the final output string exactly as required.\n    # e.g., [[1,2],[3],[]]\n    output_str = \"[\" + \",\".join([str(res).replace(\" \", \"\") for res in results]) + \"]\"\n    print(output_str)\n\nsolve()\n```", "id": "3229789"}]}