{"hands_on_practices": [{"introduction": "理论知识需要通过实践来巩固。与凸函数不同，拟凸函数的集合在加法运算下是不封闭的。这个练习旨在通过一个具体的反例来加深你对拟凸函数性质的理解，并揭示为何简单的代数运算可能会破坏拟凸性。通过分析其水平集的结构，你将明白为何直接将凸函数的一些直观结论推广到拟凸函数是危险的。", "problem": "设 $f:\\mathbb{R}\\to\\mathbb{R}$ 和 $g:\\mathbb{R}\\to\\mathbb{R}$ 定义为\n$$\nf(x)=\\begin{cases}\n0,  x\\in[-3,-2],\\\\\n1,  \\text{其他},\n\\end{cases}\n\\qquad\ng(x)=\\begin{cases}\n0,  x\\in[2,3],\\\\\n1,  \\text{其他}.\n\\end{cases}\n$$\n回顾一下，一个函数 $h:\\mathbb{R}^{n}\\to\\mathbb{R}$ 是拟凸的，当且仅当它的每个下水平集 $S_{h}(\\alpha):=\\{x\\in\\mathbb{R}^{n}:\\ h(x)\\le \\alpha\\}$ 都是凸集。\n\n仅使用此定义和集合运算的基本原理，完成以下任务：\n- 证明 $f$ 和 $g$ 在 $\\mathbb{R}$ 上是拟凸的。\n- 定义 $h:=f+g$。给出一个值 $\\alpha\\in\\mathbb{R}$，使得其下水平集 $S_{h}(\\alpha)$ 不是凸集，从而证明 $h$ 不是拟凸的。\n- 推导恒等式\n$$\nS_{f+g}(t)\\;=\\;\\bigcup_{\\alpha+\\beta\\le t}\\Big(S_{f}(\\alpha)\\cap S_{g}(\\beta)\\Big),\n$$\n并解释为什么即使所有的 $S_{f}(\\alpha)$ 和 $S_{g}(\\beta)$ 都是凸集，等式右侧也可能不是凸集。在你的解释中，将这种交集的并集的结构与上镜图的闵可夫斯基和的水平切片所产生的集合的闵可夫斯基加法进行对比，以阐明为什么 $f+g$ 的非凸下水平集会出现。\n- 令\n$$\nt_{\\star}\\;:=\\;\\inf\\{\\,t\\in\\mathbb{R}:\\ S_{h}(t)\\ \\text{是凸集且非空}\\,\\}.\n$$\n计算 $t_{\\star}$ 的精确值。你的最终答案必须是一个实数；不需要四舍五入。", "solution": "该问题在凸分析领域内被验证为是自洽的、有科学依据的且是适定的。\n\n首先，我们证明函数 $f$ 和 $g$ 是拟凸的。\n一个函数是拟凸的，如果它的所有下水平集都是凸集。函数 $\\phi:\\mathbb{R}\\to\\mathbb{R}$ 的下水平集是 $S_{\\phi}(\\alpha) := \\{x \\in \\mathbb{R} : \\phi(x) \\le \\alpha\\}$。\n\n对于函数 $f(x)$，其值域是集合 $\\{0, 1\\}$。我们分析它对于任意 $\\alpha \\in \\mathbb{R}$ 的下水平集 $S_f(\\alpha)$：\n- 如果 $\\alpha  0$，条件 $f(x) \\le \\alpha$ 永远不满足，所以 $S_f(\\alpha) = \\emptyset$。空集是凸集。\n- 如果 $0 \\le \\alpha  1$，条件 $f(x) \\le \\alpha$ 等价于 $f(x) = 0$。这在 $x \\in [-3, -2]$ 时发生。因此，$S_f(\\alpha) = [-3, -2]$。在 $\\mathbb{R}$ 中，闭区间是一个凸集。\n- 如果 $\\alpha \\ge 1$，条件 $f(x) \\le \\alpha$ 总是满足，因为 $f(x)$ 的值是 $0$ 或 $1$。因此，$S_f(\\alpha) = \\mathbb{R}$。整个实数轴是一个凸集。\n由于对所有 $\\alpha \\in \\mathbb{R}$，$S_f(\\alpha)$ 都是凸集，所以函数 $f$ 是拟凸的。\n\n对于函数 $g(x)$，其值域也是 $\\{0, 1\\}$。我们分析它的下水平集 $S_g(\\beta)$：\n- 如果 $\\beta  0$，$S_g(\\beta) = \\emptyset$，是凸集。\n- 如果 $0 \\le \\beta  1$，条件 $g(x) \\le \\beta$ 等价于 $g(x) = 0$。这在 $x \\in [2, 3]$ 时发生。因此，$S_g(\\beta) = [2, 3]$，这是一个凸区间。\n- 如果 $\\beta \\ge 1$，条件 $g(x) \\le \\beta$ 总是满足。因此，$S_g(\\beta) = \\mathbb{R}$，是凸集。\n由于对所有 $\\beta \\in \\mathbb{R}$，$S_g(\\beta)$ 都是凸集，所以函数 $g$ 是拟凸的。\n\n接下来，我们定义 $h(x) := f(x) + g(x)$ 并证明它不是拟凸的。我们首先确定 $h(x)$ 的形式：\n- 如果 $x \\in [-3, -2]$，那么 $f(x)=0$ 且 $g(x)=1$，所以 $h(x) = 0+1=1$。\n- 如果 $x \\in [2, 3]$，那么 $f(x)=1$ 且 $g(x)=0$，所以 $h(x) = 1+0=1$。\n- 否则，$x \\notin [-3, -2]$ 且 $x \\notin [2, 3]$，所以 $f(x)=1$ 且 $g(x)=1$，得出 $h(x)=1+1=2$。\n因此，函数 $h$ 由下式给出\n$$\nh(x) = \\begin{cases}\n1,  x \\in [-3, -2] \\cup [2, 3] \\\\\n2,  \\text{其他}.\n\\end{cases}\n$$\n为了证明 $h$ 不是拟凸的，我们必须找到一个值 $\\alpha$，使得其下水平集 $S_h(\\alpha)$ 不是凸集。我们选择 $\\alpha=1$。对应的下水平集是\n$$\nS_h(1) = \\{x \\in \\mathbb{R} : h(x) \\le 1\\} = \\{x \\in \\mathbb{R} : h(x) = 1\\} = [-3, -2] \\cup [2, 3].\n$$\n这个集合是两个不相交区间的并集。为了证明它不是凸集，我们可以从每个区间中各取一点，比如 $x_1 = -2.5 \\in [-3, -2]$ 和 $x_2 = 2.5 \\in [2, 3]$。这些点的一个凸组合，例如取 $\\lambda = 0.5$，是 $x_{\\lambda} = 0.5(-2.5) + 0.5(2.5) = 0$。对于 $x=0$，我们有 $h(0)=2$。由于 $h(0) > 1$，点 $x=0$ 不在 $S_h(1)$ 中。下水平集 $S_h(1)$ 不包含其两点之间的线段，所以它不是一个凸集。因此，$h$ 不是一个拟凸函数。\n\n现在，我们来推导恒等式 $S_{f+g}(t)\\;=\\;\\bigcup_{\\alpha+\\beta\\le t}\\Big(S_{f}(\\alpha)\\cap S_{g}(\\beta)\\Big)$。令 $h=f+g$。\n我们通过双向包含来证明这一点。\n($\\subseteq$): 设 $x \\in S_h(t)$。根据定义，$f(x)+g(x) \\le t$。令 $\\alpha_0 = f(x)$ 和 $\\beta_0 = g(x)$。则 $\\alpha_0 + \\beta_0 \\le t$。此外，$f(x) \\le \\alpha_0$ 意味着 $x \\in S_f(\\alpha_0)$，而 $g(x) \\le \\beta_0$ 意味着 $x \\in S_g(\\beta_0)$。因此，$x \\in S_f(\\alpha_0) \\cap S_g(\\beta_0)$。因为存在一对 $(\\alpha_0, \\beta_0)$ 满足 $\\alpha_0 + \\beta_0 \\le t$ 使得 $x$ 在对应的交集中，所以 $x$ 必定在所有这些对的并集中。即，$x \\in \\bigcup_{\\alpha+\\beta\\le t}\\Big(S_{f}(\\alpha)\\cap S_{g}(\\beta)\\Big)$。\n($\\supseteq$): 设 $x \\in \\bigcup_{\\alpha+\\beta\\le t}\\Big(S_{f}(\\alpha)\\cap S_{g}(\\beta)\\Big)$。根据并集的定义，存在至少一对 $(\\alpha_1, \\beta_1)$ 使得 $\\alpha_1 + \\beta_1 \\le t$ 且 $x \\in S_f(\\alpha_1) \\cap S_g(\\beta_1)$。从 $x \\in S_f(\\alpha_1)$，我们有 $f(x) \\le \\alpha_1$。从 $x \\in S_g(\\beta_1)$，我们有 $g(x) \\le \\beta_1$。将这两个不等式相加得到 $f(x) + g(x) \\le \\alpha_1 + \\beta_1$。由于 $\\alpha_1 + \\beta_1 \\le t$，我们得出结论 $f(x)+g(x) \\le t$，这意味着 $x \\in S_{f+g}(t)$。\n因此该恒等式得证。\n\n这个恒等式解释了为什么两个拟凸函数之和不一定是拟凸的。虽然 $f$ 和 $g$ 是拟凸的保证了每个下水平集 $S_f(\\alpha)$ 和 $S_g(\\beta)$ 都是凸集，两个凸集的交集 $S_f(\\alpha) \\cap S_g(\\beta)$ 也总是凸集。然而，和函数的下水平集 $S_{f+g}(t)$ 是作为这些凸交集的*并集*来构造的。凸集的并集通常不是一个凸集。我们关于 $h$ 在 $t=1$ 时的例子说明了这一点：$S_h(1)$ 是集合 $[-3, -2]$（来自对 $(\\alpha,\\beta) = (0,1)$，满足 $\\alpha+\\beta=1\\le 1$）和 $[2, 3]$（来自对 $(\\alpha,\\beta)=(1,0)$，满足 $\\alpha+\\beta=1\\le 1$）的并集，结果为非凸集 $[-3, -2] \\cup [2, 3]$。这与凸函数的行为形成鲜明对比。对于*凸*函数 $\\phi_1, \\phi_2$，其和 $\\phi_1+\\phi_2$ 也是凸的。这个性质根植于这样一个事实：和函数的上镜图是各个上镜图的闵可夫斯基和，即 $\\operatorname{epi}(\\phi_1+\\phi_2) = \\operatorname{epi}(\\phi_1) + \\operatorname{epi}(\\phi_2)$，并且两个凸集的闵可夫斯基和总是凸的。拟凸性是一个定义在下水平集上的较弱条件，函数加法运算并不会像闵可夫斯基和那样在这些集合上转化为保持凸性的运算。相反，它导致了交集的并集结构，这可能会破坏凸性。\n\n最后，我们计算 $t_{\\star}\\;:=\\;\\inf\\{\\,t\\in\\mathbb{R}:\\ S_{h}(t)\\ \\text{是凸集且非空}\\,\\}$。我们分析 $h(x)$ 对于所有 $t \\in \\mathbb{R}$ 的下水平集：\n- 对于 $t  1$：$S_h(t) = \\{x \\in \\mathbb{R} : h(x) \\le t\\} = \\emptyset$。空集是凸集但不是非空的。所以，这些 $t$ 的值不在我们取下确界的集合中。\n- 对于 $1 \\le t  2$：$S_h(t) = \\{x \\in \\mathbb{R} : h(x) \\le t\\} = [-3, -2] \\cup [2, 3]$。这个集合是非空的，但正如我们已经证明的，它不是凸集。\n- 对于 $t \\ge 2$：$S_h(t) = \\{x \\in \\mathbb{R} : h(x) \\le t\\} = \\mathbb{R}$。这是因为 $h(x)$ 的最大值是 $2$。集合 $\\mathbb{R}$ 既是凸集也是非空的。\n\n因此，$S_h(t)$ 是凸集且非空的 $t$ 值集合是区间 $[2, \\infty)$。题目要求的是这个集合的下确界。\n$$\nt_{\\star} = \\inf [2, \\infty) = 2.\n$$\n下水平集 $S_h(t)$ 恰好在 $t=2$ 时从非凸集变为凸集。", "answer": "$$\n\\boxed{2}\n$$", "id": "3170821"}, {"introduction": "在了解了拟凸性的“脆弱”之处后，我们来学习如何正确地识别并应用拟凸函数。本练习将引导你使用水平集的基本定义，为一个在信号处理和统计学中常见的非凸函数证明其拟凸性。随后，你会将这一理论知识应用于一个简化的传感器布局优化问题，通过几何直观求解，从而将抽象的数学概念与实际应用联系起来。", "problem": "设 $f:\\mathbb{R}^{n}\\to\\mathbb{R}$ 定义为 $f(x)=\\|Ax-b\\|_{2}^{\\alpha}+c$，其中 $A\\in\\mathbb{R}^{m\\times n}$，$b\\in\\mathbb{R}^{m}$，$c\\in\\mathbb{R}$ 且 $\\alpha\\in(0,1)$。仅使用基于下水平集凸性的拟凸性定义以及关于范数和仿射映射的标准事实，严格证明 $f$ 在 $\\mathbb{R}^{n}$ 上是拟凸的。\n\n然后，考虑一个具有两个候选位置的传感器布局设计问题，该问题由决策向量 $x\\in\\mathbb{R}^{2}$ 建模，其中 $x_{1}$ 和 $x_{2}$ 分别表示分配给位置1和位置2的固定单位预算的非负部分。分配必须满足预算可行集\n$$\nX=\\{x\\in\\mathbb{R}^{2}:\\ x_{1}+x_{2}=1,\\ x_{1}\\ge 0,\\ x_{2}\\ge 0\\},\n$$\n该集合是凸的。假设残差失配向量是通过单位映射 $A=I_{2}$ 相对于目标 $b\\in\\mathbb{R}^{2}$ 来测量的，即 $f(x)=\\|x-b\\|_{2}^{\\alpha}+c$，其中 $b=\\begin{pmatrix}2\\\\-1\\end{pmatrix}$。在此背景下，建立问题 $\\min_{x\\in X}f(x)$，并确定确切的最优目标值，表示为关于 $\\alpha$ 和 $c$ 的封闭形式解析表达式。无需四舍五入。你的最终答案必须是表示最优目标值的单个解析表达式。", "solution": "该问题包含两部分。首先，我们必须证明函数 $f(x)=\\|Ax-b\\|_{2}^{\\alpha}+c$ 是拟凸的。其次，我们必须解决一个涉及该函数的具体优化问题。\n\n**第一部分：拟凸性的证明**\n\n如果一个函数的定义域是凸集，并且其所有下水平集都是凸集，则该函数被定义为拟凸函数。该函数为 $f:\\mathbb{R}^{n}\\to\\mathbb{R}$，定义为 $f(x)=\\|Ax-b\\|_{2}^{\\alpha}+c$，其中 $A\\in\\mathbb{R}^{m\\times n}$，$b\\in\\mathbb{R}^{m}$，$c\\in\\mathbb{R}$ 且 $\\alpha\\in(0,1)$。\n\n$f$ 的定义域是 $\\mathbb{R}^{n}$，这是一个凸集。要证明 $f$ 是拟凸的，我们必须证明对于任意实数 $\\gamma$，下水平集（或子水平集）$S_{\\gamma}$ 定义为\n$$S_{\\gamma} = \\{ x \\in \\mathbb{R}^{n} \\mid f(x) \\le \\gamma \\}$$\n是一个凸集。\n\n条件 $f(x) \\le \\gamma$ 可以写作：\n$$\\|Ax-b\\|_{2}^{\\alpha}+c \\le \\gamma$$\n$$\\|Ax-b\\|_{2}^{\\alpha} \\le \\gamma - c$$\n\n我们根据右侧值的不同，考虑两种情况。\n\n情况1：$\\gamma - c  0$。\n在这种情况下，不等式 $\\|Ax-b\\|_{2}^{\\alpha} \\le \\gamma - c$ 无解，因为范数项 $\\|Ax-b\\|_{2}^{\\alpha}$ 总是非负的。因此，下水平集 $S_{\\gamma}$ 是空集，$S_{\\gamma} = \\emptyset$。根据定义，空集是凸集。\n\n情况2：$\\gamma - c \\ge 0$。\n由于 $\\alpha \\in (0,1)$，我们有 $\\alpha > 0$。函数 $t \\mapsto t^{1/\\alpha}$ 对于 $t \\ge 0$ 是良定义且严格递增的。因此，我们可以将不等式两边同时取 $1/\\alpha$ 次幂，而不会改变不等式的方向：\n$$(\\|Ax-b\\|_{2}^{\\alpha})^{1/\\alpha} \\le (\\gamma - c)^{1/\\alpha}$$\n$$\\|Ax-b\\|_{2} \\le (\\gamma - c)^{1/\\alpha}$$\n我们定义一个非负常数 $R = (\\gamma - c)^{1/\\alpha}$。现在，下水平集可以被描述为：\n$$S_{\\gamma} = \\{ x \\in \\mathbb{R}^{n} \\mid \\|Ax-b\\|_{2} \\le R \\}$$\n我们定义一个映射 $T:\\mathbb{R}^{n}\\to\\mathbb{R}^{m}$ 为 $T(x) = Ax-b$。这个映射是一个仿射变换，因为它是线性变换（$x \\mapsto Ax$）和常向量（$-b$）的和。\n\n设 $C$ 是 $\\mathbb{R}^{m}$ 中的一个集合，定义为：\n$$C = \\{ y \\in \\mathbb{R}^{m} \\mid \\|y\\|_{2} \\le R \\}$$\n这个集合 $C$ 是 $\\mathbb{R}^{m}$ 中以原点为中心、半径为 $R$ 的闭球。闭球是凸集的一个众所周知的例子。\n\n下水平集 $S_{\\gamma}$ 可以用 $T$ 和 $C$ 表示：\n$$S_{\\gamma} = \\{ x \\in \\mathbb{R}^{n} \\mid T(x) \\in C \\}$$\n这表明 $S_{\\gamma}$ 是凸集 $C$ 在仿射映射 $T$ 下的原像。仿射映射的一个基本性质是凸集的原像仍然是凸集。\n\n为了正式验证这个性质，设 $x_1, x_2 \\in S_{\\gamma}$ 且 $\\theta \\in [0,1]$。我们需要证明凸组合 $x_{\\theta} = \\theta x_1 + (1-\\theta)x_2$ 也在 $S_{\\gamma}$ 中。\n因为 $x_1, x_2 \\in S_{\\gamma}$，所以我们有 $T(x_1) \\in C$ 和 $T(x_2) \\in C$。\n因为 $T$ 是一个仿射映射，它保持凸组合：\n$$T(x_{\\theta}) = T(\\theta x_1 + (1-\\theta)x_2) = \\theta T(x_1) + (1-\\theta)T(x_2)$$\n由于 $C$ 是一个凸集且 $T(x_1), T(x_2) \\in C$，它们的凸组合 $\\theta T(x_1) + (1-\\theta)T(x_2)$ 也必须在 $C$ 中。\n因此，$T(x_{\\theta}) \\in C$，这意味着 $x_{\\theta} \\in S_{\\gamma}$。\n这证明了对于任何 $\\gamma$，$S_{\\gamma}$ 都是一个凸集。\n\n由于 $f$ 的定义域是凸的，且其所有下水平集都是凸的，所以函数 $f$ 在 $\\mathbb{R}^{n}$ 上是拟凸的。\n\n**第二部分：优化问题**\n\n问题是在集合 $X=\\{x\\in\\mathbb{R}^{2}:\\ x_{1}+x_{2}=1,\\ x_{1}\\ge 0,\\ x_{2}\\ge 0\\}$ 上求函数 $f(x) = \\|x-b\\|_{2}^{\\alpha}+c$ 的最小值。\n给定参数为 $x=\\begin{pmatrix}x_1 \\\\ x_2\\end{pmatrix}$，$b=\\begin{pmatrix}2\\\\-1\\end{pmatrix}$，$\\alpha\\in(0,1)$ 和 $c\\in\\mathbb{R}$。\n\n优化问题是：\n$$\\min_{x \\in X} \\left( \\|x-b\\|_{2}^{\\alpha}+c \\right)$$\n项 $c$ 是一个常数，所以它会平移目标值，但不会影响最小值点的位置。由于 $\\alpha > 0$，函数 $t \\mapsto t^{\\alpha}$ 对于 $t \\ge 0$ 是严格递增的。因此，最小化 $f(x)$ 等价于最小化 $\\|x-b\\|_{2}$。这是一个几何问题：找到点 $x^* \\in X$，使得它到点 $b$ 的欧几里得距离最小。这个点 $x^*$ 是点 $b$ 在凸集 $X$ 上的投影。\n\n集合 $X$ 是 $\\mathbb{R}^{2}$ 中连接点 $v_1 = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix}$ 和 $v_2 = \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix}$ 的线段。$X$ 中的任意点 $x$ 都可以由 $\\lambda \\in [0,1]$ 参数化为：\n$$x(\\lambda) = (1-\\lambda)v_2 + \\lambda v_1 = (1-\\lambda)\\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix} + \\lambda\\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} \\lambda \\\\ 1-\\lambda \\end{pmatrix}$$\n我们想要求对于 $\\lambda \\in [0,1]$，从 $x(\\lambda)$ 到 $b=\\begin{pmatrix}2\\\\-1\\end{pmatrix}$ 的距离的最小值。这等价于最小化距离的平方，$D(\\lambda) = \\|x(\\lambda)-b\\|_{2}^{2}$。\n$$D(\\lambda) = \\left\\|\\begin{pmatrix} \\lambda \\\\ 1-\\lambda \\end{pmatrix} - \\begin{pmatrix} 2 \\\\ -1 \\end{pmatrix}\\right\\|_{2}^{2} = \\left\\|\\begin{pmatrix} \\lambda-2 \\\\ 2-\\lambda \\end{pmatrix}\\right\\|_{2}^{2}$$\n$$D(\\lambda) = (\\lambda-2)^{2} + (2-\\lambda)^{2} = 2(\\lambda-2)^{2}$$\n我们需要找到 $D(\\lambda)$ 在 $\\lambda \\in [0,1]$ 上的最小值。我们来考察 $D(\\lambda)$ 关于 $\\lambda$ 的导数：\n$$D'(\\lambda) = \\frac{d}{d\\lambda} (2(\\lambda-2)^{2}) = 4(\\lambda-2)$$\n对于区间 $[0,1]$ 中的任意 $\\lambda$，项 $(\\lambda-2)$ 是负的。因此，对于所有 $\\lambda \\in [0,1]$，$D'(\\lambda)  0$。这意味着 $D(\\lambda)$ 在区间 $[0,1]$ 上是一个严格递减函数。\n对于一个在闭区间上的严格递减函数，其最小值在区间的右端点达到。因此，最小值在 $\\lambda=1$ 处取得。\n\n最优参数是 $\\lambda^{*} = 1$。对应的最优点 $x^*$ 是：\n$$x^* = x(1) = \\begin{pmatrix} 1 \\\\ 1-1 \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix}$$\n最小平方距离是 $D(1) = 2(1-2)^2 = 2$。\n最小距离是 $\\min_{x\\in X}\\|x-b\\|_{2} = \\sqrt{D(1)} = \\sqrt{2}$。\n\n问题要求的是最优目标值，即 $\\min_{x\\in X}f(x) = f(x^*)$。\n$$f(x^*) = \\|x^*-b\\|_{2}^{\\alpha}+c = (\\sqrt{2})^{\\alpha} + c$$\n这可以写作 $2^{\\alpha/2} + c$。", "answer": "$$\\boxed{2^{\\frac{\\alpha}{2}}+c}$$", "id": "3170745"}, {"introduction": "掌握了理论，最终目标是解决实际的优化问题。适用于凸函数的梯度下降法对于仅具有拟凸性的函数可能失效，因此我们需要一种更通用的策略。本练习将指导你实现二分法，这是求解拟凸（或拟凹）优化问题的核心算法。你将学习如何将一个复杂的优化问题转化为一系列可以通过线性规划求解的凸可行性问题，这是连接拟凸理论和计算实践的关键桥梁。", "problem": "您需要通过对标量阈值进行二分搜索，实现用于拟凹最大化的水平集方法。目标函数定义为 $f(x)=\\min_{i\\in\\{1,\\dots,m\\}} a_i^\\top x$，其中每个 $a_i\\in\\mathbb{R}^n$，可行域 $X\\subset\\mathbb{R}^n$ 是一个由线性不等式和边界约束描述的多胞体。该方法依赖于测试水平集的可行性：对于给定的阈值 $\\alpha\\in\\mathbb{R}$，检查是否存在 $x\\in X$ 使得 $f(x)\\ge \\alpha$。利用这种单调可行性属性，对 $\\alpha$ 进行二分搜索，以近似求解 $f(x)$ 在 $X$ 上的最大值。\n\n需使用的基本定义：\n- 如果函数 $f:\\mathbb{R}^n\\to\\mathbb{R}$ 的每个上水平集 $\\{x\\in\\mathbb{R}^n:\\ f(x)\\ge \\alpha\\}$ 对所有 $\\alpha\\in\\mathbb{R}$ 都是凸集，则该函数是拟凹的。\n- 多胞体 $X$ 是有限多个线性不等式和边界约束的解集。\n- 线性规划 (LP) 是指具有线性目标和线性约束的一类优化问题。\n\n需使用的核心可行性等价关系：\n- 对于 $f(x)=\\min_i a_i^\\top x$，上水平集 $\\{x\\in X:\\ f(x)\\ge \\alpha\\}$ 等价于 $\\{x\\in X:\\ a_i^\\top x\\ge \\alpha\\ \\text{对所有}\\ i=1,\\dots,m\\}$，这是一个半空间的交集。该集合的可行性可以通过设置零目标和仅含约束的线性规划 (LP) 求解器来检查。\n\n实现要求：\n1. 在有界区间 $[\\alpha_\\text{low},\\alpha_\\text{high}]$ 内对 $\\alpha$ 进行二分搜索，其中：\n   - $\\alpha_\\text{low}$ 通过在某个可行点 $x_0\\in X$ 处评估 $f(x_0)$ 获得。您可以通过求解一个具有零目标且仅包含定义 $X$ 的约束的线性规划 (LP) 来获得 $x_0$。\n   - $\\alpha_\\text{high}$ 从界 $f(x)\\le \\min_{i} \\max_{x\\in X} a_i^\\top x$ 获得，您应通过求解 $m$ 个在 $X$ 上最大化 $a_i^\\top x$（等价于最小化 $-a_i^\\top x$）的线性规划 (LP) 问题来计算。\n2. 对于给定的 $\\alpha$，通过求解一个具有零目标、受限于定义 $X$ 的约束以及附加约束 $a_i^\\top x\\ge \\alpha$（对所有 $i$）的线性规划 (LP) 来测试可行性。这等价于对所有 $i$ 都有 $-a_i^\\top x\\le -\\alpha$，并且可以由不等式约束处理。\n3. 继续二分搜索，直到区间长度小于一个容差，并返回最终的 $\\alpha_\\text{low}$ 作为 $f(x)$ 在 $X$ 上的最大值的近似值。\n\n您的程序必须是一个单一、完整、可运行的 Python 程序，并使用指定的环境。它必须解决以下测试套件，并生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个值四舍五入到 $6$ 位小数：\n\n测试套件：\n- 案例 $1$ (正常路径): $n=2$, $X=\\{x\\in\\mathbb{R}^2:\\ 0\\le x_1\\le 1,\\ 0\\le x_2\\le 1\\}$，其中 $a_1^\\top=[1,0]$, $a_2^\\top=[0,1]$。预期的最大化点达到值 $\\alpha^\\star=1$。\n- 案例 $2$ (边界覆盖): $n=3$, $X=\\{x\\in\\mathbb{R}^3:\\ x_i\\ge 0\\ \\text{for}\\ i\\in\\{1,2,3\\},\\ x_1+x_2+x_3\\le 1\\}$，其中 $a_1^\\top=[1,0,0]$, $a_2^\\top=[0,1,0]$, $a_3^\\top=[0,0,1]$。预期的最大化点达到值 $\\alpha^\\star=1/3$。\n- 案例 $3$ (含负方向的边界情况): $n=2$, $X=\\{x\\in\\mathbb{R}^2:\\ 0\\le x_1\\le 1,\\ 0\\le x_2\\le 1\\}$，其中 $a_1^\\top=[-1,0]$, $a_2^\\top=[0,-1]$, $a_3^\\top=[1,-1]$。预期的最大化点达到值 $\\alpha^\\star=0$。\n\n容差和输出精度：\n- 对 $\\alpha$ 的区间使用 $10^{-7}$ 的二分搜索容差。\n- 将每个案例的 $f(x)$ 近似最大值输出为浮点数，四舍五入到 $6$ 位小数。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，$[0.123456,0.333333,1.000000]$）。", "solution": "用户希望实现一个二分算法，以找到一个拟凹函数在一个多胞体上的最大值。\n\n### 步骤 1：提取已知条件\n\n- **目标函数：** $f(x)=\\min_{i\\in\\{1,\\dots,m\\}} a_i^\\top x$，其中 $x \\in \\mathbb{R}^n$ 且 $a_i\\in\\mathbb{R}^n$。\n- **可行域：** 由有限个线性不等式和边界约束定义的多胞体 $X\\subset\\mathbb{R}^n$。\n- **算法：** 对标量阈值 $\\alpha$ 使用二分法（二分搜索）。\n- **可行性测试：** 对于给定的 $\\alpha$，检查集合 $\\{x\\in X:\\ f(x)\\ge \\alpha\\}$ 是否非空。这等价于检查线性系统的可行性：$x \\in X$ 且对所有 $i \\in \\{1, \\dots, m\\}$ 都有 $a_i^\\top x \\ge \\alpha$。此可行性检查使用一个零目标函数的线性规划 (LP) 求解器来执行。\n- **初始区间 $[\\alpha_\\text{low}, \\alpha_\\text{high}]$**：\n    - $\\alpha_\\text{low}$ 通过找到一个可行点 $x_0 \\in X$ 并计算 $f(x_0)$ 来确定。点 $x_0$ 通过求解一个在 $X$ 上的零目标 LP 来找到。\n    - $\\alpha_\\text{high}$ 由上界 $U = \\min_{i=1,\\dots,m} \\left( \\max_{x\\in X} a_i^\\top x \\right)$ 确定。这需要求解 $m$ 个独立的 LP 问题。\n- **终止条件：** 当区间长度 $(\\alpha_\\text{high} - \\alpha_\\text{low})$ 大于 $10^{-7}$ 的容差时，二分搜索继续。\n- **输出：** $\\alpha_\\text{low}$ 的最终值，四舍五入到 $6$ 位小数。\n- **测试案例：**\n    1.  $n=2$, $X=\\{x\\in\\mathbb{R}^2 : 0\\le x_1\\le 1, 0\\le x_2\\le 1\\}$, $a_1=[1,0]^\\top$, $a_2=[0,1]^\\top$。\n    2.  $n=3$, $X=\\{x\\in\\mathbb{R}^3 : x_i\\ge 0 \\text{ for } i\\in\\{1,2,3\\}, x_1+x_2+x_3\\le 1\\}$, $a_1=[1,0,0]^\\top$, $a_2=[0,1,0]^\\top$, $a_3=[0,0,1]^\\top$。\n    3.  $n=2$, $X=\\{x\\in\\mathbb{R}^2 : 0\\le x_1\\le 1, 0\\le x_2\\le 1\\}$, $a_1=[-1,0]^\\top$, $a_2=[0,-1]^\\top$, $a_3=[1,-1]^\\top$。\n\n### 步骤 2：使用提取的已知条件进行验证\n\n- **科学上合理：** 该问题是凸优化和拟凹优化领域的标准练习。函数 $f(x) = \\min_i a_i^\\top x$ 是一组线性（因此是凹）函数的逐点最小值。凹函数的逐点最小值是凹函数。由于每个凹函数也是拟凹函数，因此前提成立。基于检查水平集可行性的二分法是优化拟凹/拟凸函数的经典且正确的算法。用于建立搜索区间和使用 LP 执行可行性检查的方法也是标准且数学上合理的。\n- **良态的：** 问题是良态的（适定的）。目标函数是连续的，对于所有测试案例，可行集 $X$ 都是一个紧致多胞体。因此，保证存在最大值。二分算法保证收敛到这个最大值。\n- **客观的：** 问题以精确的数学术语陈述，没有歧义或主观语言。\n\n问题陈述内部一致，科学合理，且良态。所有需要的信息都已提供。\n\n### 步骤 3：结论与行动\n\n问题有效。将提供一个解决方案。\n\n### 基于原理的解决方案\n\n该问题要求我们找到函数 $f(x)$ 在集合 $X$ 上的最大值，可以正式表述为：\n$$\n\\text{最大化} \\quad f(x) = \\min_{i=1,\\dots,m} a_i^\\top x \\\\\n\\text{约束于} \\quad x \\in X\n$$\n其中 $X$ 是一个多胞体。这是一个拟凹最大化问题。\n\n**1. 拟凹性与二分法**\n\n如果一个函数 $f(x)$ 的上水平集 $S_\\alpha = \\{x \\mid f(x) \\ge \\alpha\\}$ 对于所有 $\\alpha \\in \\mathbb{R}$ 都是凸的，则该函数是拟凹的。对于我们的函数 $f(x) = \\min_{i} a_i^\\top x$，其上水平集为：\n$$\nS_\\alpha = \\{x \\mid \\min_{i=1,\\dots,m} a_i^\\top x \\ge \\alpha\\} = \\{x \\mid a_i^\\top x \\ge \\alpha \\text{ for all } i=1,\\dots,m\\}\n$$\n每个条件 $a_i^\\top x \\ge \\alpha$ 定义一个闭半空间，这是一个凸集。有限个凸集的交集也是一个凸集。因此，$S_\\alpha$ 是凸的，并且 $f(x)$ 是拟凹的。\n\n令 $\\alpha^\\star = \\max_{x \\in X} f(x)$ 为最优值。使二分法得以应用的关键属性是，找到一个点在水平集和可行域交集中的可行性，即集合 $S_\\alpha \\cap X$ 的非空性，是关于 $\\alpha$ 单调的。\n- 如果存在一个 $x \\in X$ 使得 $f(x) \\ge \\alpha$，那么最优值 $\\alpha^\\star$ 必须至少为 $\\alpha$。\n- 如果不存在 $x \\in X$ 使得 $f(x) \\ge \\alpha$，那么最优值 $\\alpha^\\star$ 必须小于 $\\alpha$。\n\n这种单调属性允许我们对 $\\alpha$ 的值使用二分搜索（二分法）来找到 $\\alpha^\\star$。\n\n**2. 通过线性规划进行可行性检查**\n\n二分算法的核心是可行性检查：对于给定的 $\\alpha$，集合 $\\{x \\in X \\mid f(x) \\ge \\alpha\\}$ 是否为空？这个集合由定义多胞体 $X$ 的原始约束加上新的约束 $a_i^\\top x \\ge \\alpha$（对所有 $i$）来描述。由于所有这些约束都是线性不等式，它们共同定义了另一个多胞体。确定一个多胞体是否为空是一个标准的线性可行性问题，可以使用线性规划 (LP) 求解器来解决。我们构建一个具有零目标函数 $c=0$ 和所有组合的线性约束的 LP。如果 LP 求解器找到了一个可行解，则该集合非空。否则，它为空。\n\n**3. 算法流程**\n\n二分算法按以下步骤进行：\n\n- **步骤 A：搜索区间 $[\\alpha_\\text{low}, \\alpha_\\text{high}]$ 的初始化**\n    需要一个保证包含最优值 $\\alpha^\\star$ 的初始区间。\n    1.  **下界 ($\\alpha_\\text{low}$):** 我们找到任意一个可行点 $x_0 \\in X$。这可以通过求解一个仅有定义 $X$ 约束的零目标函数 LP 来完成。如果找到了一个解 $x_0$，我们计算 $f(x_0)$。由于 $x_0 \\in X$，我们知道 $\\alpha^\\star \\ge f(x_0)$。因此，我们可以设置 $\\alpha_\\text{low} = f(x_0)$。\n    2.  **上界 ($\\alpha_\\text{high}$):** 对于任意 $x \\in X$，我们有 $f(x) = \\min_i a_i^\\top x \\le a_j^\\top x$ 对于任意 $j \\in \\{1,\\dots,m\\}$。这进一步意味着 $f(x) \\le \\max_{y \\in X} a_j^\\top y$。由于这对所有 $j$ 都成立，它也必须对关于 $j$ 的最小值成立：\n        $$\n        f(x) \\le \\min_{j=1,\\dots,m} \\left( \\max_{y \\in X} a_j^\\top y \\right)\n        $$\n        这给出了 $\\alpha^\\star$ 的一个有效上界。我们通过求解 $m$ 个 LP 来计算这个界，其中第 $j$ 个 LP 在 $X$ 上最大化 $a_j^\\top x$。然后我们将 $\\alpha_\\text{high}$ 设置为这 $m$ 个最大值中的最小值。\n\n- **步骤 B：二分迭代**\n    当区间宽度 $(\\alpha_\\text{high} - \\alpha_\\text{low})$ 大于指定的容差 $\\epsilon$ 时：\n    1.  计算中点：$\\alpha_\\text{mid} = (\\alpha_\\text{low} + \\alpha_\\text{high}) / 2$。\n    2.  为 $\\alpha_\\text{mid}$ 求解可行性 LP。约束是 $X$ 的约束加上 $a_i^\\top x \\ge \\alpha_\\text{mid}$（对所有 $i$）。\n    3.  如果存在可行解，意味着 $\\alpha^\\star \\ge \\alpha_\\text{mid}$。我们更新下界：$\\alpha_\\text{low} = \\alpha_\\text{mid}$。\n    4.  如果不存在可行解，意味着 $\\alpha^\\star  \\alpha_\\text{mid}$。我们更新上界：$\\alpha_\\text{high} = \\alpha_\\text{mid}$。\n\n- **步骤 C：终止**\n    当 $\\alpha_\\text{high} - \\alpha_\\text{low} \\le \\epsilon$ 时，循环终止。最终的 $\\alpha_\\text{low}$ 值是 $\\alpha^\\star$ 的一个经过验证的下界，并且与真实最优值的差距在 $\\epsilon$ 以内。该值作为解返回。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve_quasiconcave_max(a_vectors, A_ub, b_ub, bounds, tol=1e-7):\n    \"\"\"\n    Maximizes a quasiconcave function f(x) = min(a_i^T x) over a polytope X\n    using a bisection method on the function value alpha.\n\n    Args:\n        a_vectors (np.ndarray): Matrix where rows are the vectors a_i.\n        A_ub (np.ndarray or None): Matrix A for inequality constraints A @ x = b of the polytope X.\n        b_ub (np.ndarray or None): Vector b for inequality constraints A @ x = b of the polytope X.\n        bounds (list of tuples): Bounds for each variable x_i in X.\n        tol (float): Tolerance for the binary search interval width.\n\n    Returns:\n        float: The approximate maximum value of f(x).\n    \"\"\"\n    n = a_vectors.shape[1]\n    m = a_vectors.shape[0]\n    c_zero = np.zeros(n)\n    \n    # --- Step 1: Find initial search interval [alpha_low, alpha_high] ---\n\n    # Find an initial feasible point x0 to establish a lower bound.\n    res_x0 = linprog(c_zero, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs-ds')\n    if not res_x0.success:\n        # The feasible set X is empty.\n        # This case is not expected for the given problem.\n        raise ValueError(\"Feasible region X is empty.\")\n    x0 = res_x0.x\n    \n    # alpha_low is f(x0), a guaranteed achievable value.\n    alpha_low = np.min(a_vectors @ x0)\n\n    # Find the upper bound by solving m LPs: max_{x in X} (a_i^T x) for each i.\n    max_vals = []\n    for i in range(m):\n        # linprog minimizes, so to maximize a_i^T x, we minimize -a_i^T x.\n        c_i = -a_vectors[i]\n        res_max = linprog(c_i, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs-ds')\n        if not res_max.success:\n            # Should not happen for bounded polytopes.\n            # Could indicate an unbounded problem if bounds were not provided.\n             raise ValueError(f\"Could not solve LP to find upper bound for a_{i}.\")\n        # The maximum value is the negative of the minimum found by linprog.\n        max_val = -res_max.fun\n        max_vals.append(max_val)\n    \n    # alpha_high is the minimum of these maximums.\n    alpha_high = np.min(max_vals)\n    \n    # --- Step 2: Binary Search ---\n    \n    while alpha_high - alpha_low > tol:\n        alpha_mid = (alpha_low + alpha_high) / 2\n        \n        # Check feasibility of {x in X | f(x) >= alpha_mid}.\n        # This adds constraints a_i^T x >= alpha_mid for all i.\n        # In linprog format: -a_i^T x = -alpha_mid.\n        level_set_A = -a_vectors\n        level_set_b = -np.full(m, alpha_mid)\n\n        # Combine constraints of X and the level set.\n        if A_ub is not None and b_ub is not None:\n            feas_A_ub = np.vstack((A_ub, level_set_A))\n            feas_b_ub = np.concatenate((b_ub, level_set_b))\n        else:\n            feas_A_ub = level_set_A\n            feas_b_ub = level_set_b\n\n        # Solve the feasibility LP (zero objective function).\n        res_feas = linprog(c_zero, A_ub=feas_A_ub, b_ub=feas_b_ub, bounds=bounds, method='highs-ds')\n        \n        if res_feas.success:\n            # A feasible point exists for alpha_mid, so the true max is at least alpha_mid.\n            alpha_low = alpha_mid\n        else:\n            # No feasible point exists, the true max must be less than alpha_mid.\n            alpha_high = alpha_mid\n            \n    # --- Step 3: Return result ---\n    return alpha_low\n\ndef solve():\n    \"\"\"\n    Defines and runs the test suite for the quasiconcave maximization problem.\n    \"\"\"\n    \n    # Case 1: n=2, X=[0,1]^2, a1=[1,0], a2=[0,1]\n    case1_a = np.array([[1, 0], [0, 1]])\n    case1_A_ub = None\n    case1_b_ub = None\n    case1_bounds = [(0, 1), (0, 1)]\n\n    # Case 2: n=3, X={x>=0, sum(x)=1}, a_i are standard basis vectors\n    case2_a = np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]])\n    case2_A_ub = np.array([[1, 1, 1]])\n    case2_b_ub = np.array([1])\n    case2_bounds = [(0, None), (0, None), (0, None)]\n    \n    # Case 3: n=2, X=[0,1]^2, a1=[-1,0], a2=[0,-1], a3=[1,-1]\n    case3_a = np.array([[-1, 0], [0, -1], [1, -1]])\n    case3_A_ub = None\n    case3_b_ub = None\n    case3_bounds = [(0, 1), (0, 1)]\n\n    test_cases = [\n        (case1_a, case1_A_ub, case1_b_ub, case1_bounds),\n        (case2_a, case2_A_ub, case2_b_ub, case2_bounds),\n        (case3_a, case3_A_ub, case3_b_ub, case3_bounds),\n    ]\n\n    results = []\n    for case in test_cases:\n        a_vectors, A_ub, b_ub, bounds = case\n        result = solve_quasiconcave_max(a_vectors, A_ub, b_ub, bounds)\n        results.append(result)\n\n    # Format output to 6 decimal places as specified.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3170813"}]}