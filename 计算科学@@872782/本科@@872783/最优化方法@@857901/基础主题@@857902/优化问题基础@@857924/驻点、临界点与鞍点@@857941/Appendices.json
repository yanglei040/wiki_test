{"hands_on_practices": [{"introduction": "掌握优化的第一步是学习识别和分类驻点的基本方法。本练习将引导你完整地走过一个标准流程：首先利用梯度找到一个二次函数的驻点，然后使用 Hessian 矩阵对其进行分类。通过一个显式的坐标旋转来对角化 Hessian 矩阵，你将对不定的 Hessian 矩阵如何对应于鞍点的特征形状建立起更深刻的几何直觉。[@problem_id:3184889]", "problem": "考虑二次连续可微函数 $f:\\mathbb{R}^{2}\\to\\mathbb{R}$，其定义为 $f(x,y)=x^{2}+xy-y^{2}$。使用驻点是梯度为零的点的基本定义，并通过海森矩阵的定性来对驻点进行分类。然后，从任何实对称矩阵都可以正交对角化这一事实出发，确定一个旋转来对角化海森矩阵，并在旋转后的坐标中写出二次型，以揭示其鞍点性质。\n\n任务：\n- 推导并求解驻点条件 $\\nabla f(x,y)=\\mathbf{0}$。\n- 使用海森矩阵通过其定性来分类驻点。\n- 构造一个角度为 $\\varphi$（以弧度为单位）的正交旋转矩阵 $R(\\varphi)$，该矩阵可对角化海森矩阵，并证明在旋转后的坐标 $(u,v)=R(\\varphi)^{\\top}(x,y)$ 中，二次型没有交叉项。\n- 提供主曲率（海森矩阵的特征值）和旋转角 $\\varphi$ 的精确值。\n\n答案规格：\n- 将角度以弧度为单位表示为精确的符号表达式。\n- 精确表示主曲率（不要对平方根进行近似）。\n- 作为最终答案，给出一个单行矩阵，按顺序包含：旋转角 $\\varphi$、较大的主曲率和较小的主曲率。最终的行矩阵中不要包含单位。", "solution": "问题是找到并分类函数 $f:\\mathbb{R}^{2}\\to\\mathbb{R}$（定义为 $f(x,y)=x^{2}+xy-y^{2}$）的驻点，并找到一个坐标旋转来对角化相关的二次型。\n\n首先，我们验证问题陈述。\n**步骤 1：提取已知条件**\n- 函数：$f(x,y)=x^{2}+xy-y^{2}$，二次连续可微。\n- 驻点的定义：$\\nabla f(x,y)=\\mathbf{0}$。\n- 分类方法：海森矩阵的定性。\n- 任务：找到一个正交旋转矩阵 $R(\\varphi)$ 来对角化海森矩阵。\n- 任务：在旋转后的坐标 $(u,v)=R(\\varphi)^{\\top}(x,y)$ 中表示二次型。\n- 要求输出：驻点、其分类、主曲率（特征值）和旋转角 $\\varphi$。\n- 最终答案格式：一个包含旋转角、较大主曲率和较小主曲率的行矩阵。\n\n**步骤 2：使用提取的已知条件进行验证**\n- **科学依据：** 这是一个多元微积分的标准练习，涉及梯度、海森矩阵、特征值和矩阵对角化。这些都是核心数学概念。该问题具有科学合理性。\n- **适定性：** 函数有明确定义，任务清晰无歧义。寻找驻点和对角化对称矩阵的程序是标准的，可以得出一个唯一且有意义的解。该问题是适定的。\n- **客观性：** 问题使用形式化的数学语言陈述，没有任何主观性或歧义。\n\n**步骤 3：结论与行动**\n问题有效。我们将进行完整解答。\n\n函数由 $f(x,y) = x^{2}+xy-y^{2}$ 给出。\n\n**1. 寻找驻点**\n驻点 $(x_0, y_0)$ 是函数梯度为零向量的点，即 $\\nabla f(x_0, y_0) = \\mathbf{0}$。$f$ 的梯度是：\n$$\n\\nabla f(x,y) = \\begin{pmatrix} \\frac{\\partial f}{\\partial x} \\\\ \\frac{\\partial f}{\\partial y} \\end{pmatrix} = \\begin{pmatrix} 2x+y \\\\ x-2y \\end{pmatrix}\n$$\n将梯度设为零，得到以下线性方程组：\n$$\n\\begin{cases}\n2x+y = 0 \\\\\nx-2y = 0\n\\end{cases}\n$$\n从第二个方程，我们得到 $x=2y$。将此代入第一个方程：\n$$\n2(2y)+y=0 \\implies 4y+y=0 \\implies 5y=0 \\implies y=0\n$$\n将 $y=0$ 代回 $x=2y$ 得到 $x=0$。\n因此，唯一的驻点是 $(0,0)$。\n\n**2. 使用海森矩阵对驻点进行分类**\n海森矩阵 $H$ 是二阶偏导数矩阵：\n$$\nH(x,y) = \\begin{pmatrix} \\frac{\\partial^2 f}{\\partial x^2} & \\frac{\\partial^2 f}{\\partial x \\partial y} \\\\ \\frac{\\partial^2 f}{\\partial y \\partial x} & \\frac{\\partial^2 f}{\\partial y^2} \\end{pmatrix}\n$$\n二阶偏导数是：\n$$\n\\frac{\\partial^2 f}{\\partial x^2} = \\frac{\\partial}{\\partial x}(2x+y) = 2\n$$\n$$\n\\frac{\\partial^2 f}{\\partial x \\partial y} = \\frac{\\partial}{\\partial y}(2x+y) = 1\n$$\n$$\n\\frac{\\partial^2 f}{\\partial y^2} = \\frac{\\partial}{\\partial y}(x-2y) = -2\n$$\n由于 $f$ 是二次连续可微的，$\\frac{\\partial^2 f}{\\partial y \\partial x} = \\frac{\\partial^2 f}{\\partial x \\partial y} = 1$。海森矩阵对于所有的 $(x,y)$ 都是常数：\n$$\nH = \\begin{pmatrix} 2 & 1 \\\\ 1 & -2 \\end{pmatrix}\n$$\n为了对驻点 $(0,0)$ 进行分类，我们分析 $H$ 的定性。我们通过找到它的特征值来做到这一点，这些特征值就是主曲率。特征方程是 $\\det(H-\\lambda I)=0$：\n$$\n\\det\\begin{pmatrix} 2-\\lambda & 1 \\\\ 1 & -2-\\lambda \\end{pmatrix} = 0\n$$\n$$\n(2-\\lambda)(-2-\\lambda) - (1)(1) = 0\n$$\n$$\n-4-2\\lambda+2\\lambda+\\lambda^2 - 1 = 0\n$$\n$$\n\\lambda^2 - 5 = 0 \\implies \\lambda = \\pm\\sqrt{5}\n$$\n特征值（主曲率）是 $\\lambda_1 = \\sqrt{5}$ 和 $\\lambda_2 = -\\sqrt{5}$。由于一个特征值为正，另一个为负，海森矩阵是不定的。具有不定海森矩阵的驻点是鞍点。\n\n**3. 确定对角化海森矩阵的旋转**\n我们寻求一个正交旋转矩阵 $R(\\varphi) = \\begin{pmatrix} \\cos\\varphi & -\\sin\\varphi \\\\ \\sin\\varphi & \\cos\\varphi \\end{pmatrix}$ 来对角化 $H$。$R(\\varphi)$ 的列必须是 $H$ 的归一化特征向量。变换由 $D = R(\\varphi)^\\top H R(\\varphi)$ 给出，其中 $D$ 是特征值的对角矩阵。\n将坐标轴与二次型 $Ax^2+Bxy+Cy^2$ 的主轴对齐的旋转角 $\\varphi$ 由 $\\tan(2\\varphi) = \\frac{B}{A-C}$ 给出。与海森矩阵 $H = \\begin{pmatrix} a & b \\\\ b & c \\end{pmatrix}$ 相关的二次型是 $q(x,y) = ax^2 + 2bxy + cy^2$。对于我们的海森矩阵 $H = \\begin{pmatrix} 2 & 1 \\\\ 1 & -2 \\end{pmatrix}$，我们有 $a=2$，$b=1$，$c=-2$。用于对角化矩阵本身的旋转角公式是 $\\tan(2\\varphi)=\\frac{2b}{a-c}$。\n$$\n\\tan(2\\varphi) = \\frac{2(1)}{2 - (-2)} = \\frac{2}{4} = \\frac{1}{2}\n$$\n我们可以求解 $\\varphi$。我们选择 $2\\varphi$ 在第一象限，所以 $\\varphi$ 在 $(0, \\pi/4)$ 内。我们使用正切的半角恒等式：$\\tan(2\\varphi) = \\frac{2\\tan\\varphi}{1-\\tan^2\\varphi}$。\n$$\n\\frac{1}{2} = \\frac{2\\tan\\varphi}{1-\\tan^2\\varphi}\n$$\n$$\n1-\\tan^2\\varphi = 4\\tan\\varphi\n$$\n$$\n\\tan^2\\varphi + 4\\tan\\varphi - 1 = 0\n$$\n这是一个关于 $\\tan\\varphi$ 的二次方程。使用二次公式：\n$$\n\\tan\\varphi = \\frac{-4 \\pm \\sqrt{4^2 - 4(1)(-1)}}{2(1)} = \\frac{-4 \\pm \\sqrt{16+4}}{2} = \\frac{-4 \\pm \\sqrt{20}}{2} = \\frac{-4 \\pm 2\\sqrt{5}}{2} = -2 \\pm \\sqrt{5}\n$$\n因为我们选择了 $\\varphi \\in (0, \\pi/4)$，$\\tan\\varphi$ 必须为正且小于 $1$。\n值 $\\sqrt{5}-2 \\approx 2.236-2=0.236$ 满足 $0 < \\sqrt{5}-2 < 1$。\n另一个值，$-2-\\sqrt{5}$，是负数。\n因此，我们必须有 $\\tan\\varphi = \\sqrt{5}-2$。旋转角是 $\\varphi = \\arctan(\\sqrt{5}-2)$。\n\n**4. 在旋转坐标中表示二次型**\n坐标变换由 $\\begin{pmatrix} x \\\\ y \\end{pmatrix} = R(\\varphi)\\begin{pmatrix} u \\\\ v \\end{pmatrix}$ 给出。函数的二次部分就是函数本身，$f(x,y)=x^2+xy-y^2$。这对应于矩阵 $A = \\begin{pmatrix} 1 & 1/2 \\\\ 1/2 & -1 \\end{pmatrix}$。注意 $H=2A$。二次型是 $\\mathbf{x}^\\top A \\mathbf{x}$。\n在新的坐标 $(u,v)$ 中，二次型变为：\n$$\nf(u,v) = \\left(R(\\varphi)\\begin{pmatrix} u \\\\ v \\end{pmatrix}\\right)^\\top A \\left(R(\\varphi)\\begin{pmatrix} u \\\\ v \\end{pmatrix}\\right) = \\begin{pmatrix} u \\\\ v \\end{pmatrix}^\\top (R(\\varphi)^\\top A R(\\varphi)) \\begin{pmatrix} u \\\\ v \\end{pmatrix}\n$$\n矩阵 $R(\\varphi)^\\top A R(\\varphi)$ 是一个对角矩阵，其对角线元素是 $A$ 的特征值。$A = \\frac{1}{2}H$ 的特征值是 $H$ 特征值的一半，即 $\\frac{\\sqrt{5}}{2}$ 和 $-\\frac{\\sqrt{5}}{2}$。\n因此，在旋转坐标系中，函数是：\n$$\nf(u,v) = \\frac{\\sqrt{5}}{2}u^2 - \\frac{\\sqrt{5}}{2}v^2\n$$\n这种形式明确显示了函数在原点的鞍点性质，沿着 $u$ 轴向上抛物线曲率，沿着 $v$ 轴向下抛物线曲率。没有交叉项 $uv$。\n\n**结果总结**\n- 驻点是 $(0,0)$，它是一个鞍点。\n- 主曲率是海森矩阵的特征值，即 $\\lambda_{\\text{max}} = \\sqrt{5}$ 和 $\\lambda_{\\text{min}} = -\\sqrt{5}$。\n- 对角化海森矩阵所需的旋转角是 $\\varphi = \\arctan(\\sqrt{5}-2)$ 弧度。\n\n最终答案要求一个单行矩阵，按顺序包含旋转角 $\\varphi$、较大的主曲率和较小的主曲率。\n$$\n\\begin{pmatrix} \\varphi & \\lambda_{\\text{max}} & \\lambda_{\\text{min}} \\end{pmatrix} = \\begin{pmatrix} \\arctan(\\sqrt{5}-2) & \\sqrt{5} & -\\sqrt{5} \\end{pmatrix}\n$$", "answer": "$$\n\\boxed{\\begin{pmatrix} \\arctan(\\sqrt{5}-2) & \\sqrt{5} & -\\sqrt{5} \\end{pmatrix}}\n$$", "id": "3184889"}, {"introduction": "标准的 Hessian 检验是一个强大的工具，但它也有其局限性，尤其是在 Hessian 矩阵是奇异（或秩亏）的情况下。本练习将探讨这样一种“退化”情形，此时二阶导数检验无法得出结论，迫使我们必须进行更基本的分析。通过考察函数沿不同方向的行为，你将学会当二次近似无法提供足够信息时如何对临界点进行分类，这是解决更复杂优化问题时的一项关键技能。[@problem_id:3184903]", "problem": "设 $f:\\mathbb{R}^{2}\\to\\mathbb{R}$ 定义为 $f(x,y)=x^{2}y$。仅使用无约束优化的核心定义，按以下步骤进行：\n- 从第一性原理出发，通过求解 $\\nabla f(x,y)=\\mathbf{0}$ 来确定所有临界点的集合。\n- 对每个临界点，讨论海森矩阵的秩如何影响经典二阶检验的适用性，并解释为何当海森矩阵秩亏时，分类可能是不确定的。\n- 使用基于 $f$ 沿曲线限制的严格论证，将临界点分为局部最小值点、局部最大值点或鞍点。特别地，通过将 $f$ 限制在形如 $(x,y)=t\\mathbf{u}$（其中 $\\|\\mathbf{u}\\|=1$ 且 $t$ 较小）的射线上来对原点进行分类，并从第一性原理出发证明你的结论，不使用任何未经证明的快捷公式。\n- 通过最小的正整数 $k$ 定义前导阶方向剖面 $g(u_{x},u_{y})$，使得展开式 $f(tu_{x},tu_{y})=t^{k}\\,g(u_{x},u_{y})$ 对所有单位方向 $(u_{x},u_{y})$ 和足够小的 $t$ 成立，并使用此 $g$ 来支持你对原点的分类。\n\n将你的最终答案报告为 $g(u_{x},u_{y})$ 的单一闭式解析表达式。无需四舍五入。不要包含单位。", "solution": "我们从基本定义开始。一个点 $(x^{\\star},y^{\\star})$ 是 $f$ 的临界点，当且仅当梯度 $\\nabla f(x^{\\star},y^{\\star})=\\mathbf{0}$。海森矩阵确定了 $f$ 的二阶近似，并用于经典的二阶条件；当海森矩阵是奇异的（秩亏）时，二次型无法捕捉所有邻近的变化，检验可能是不确定的，此时需要进行高阶或方向性分析。\n\n步骤 $1$：计算梯度和临界集。偏导数是\n$$\n\\frac{\\partial f}{\\partial x}(x,y)=2xy,\\qquad \\frac{\\partial f}{\\partial y}(x,y)=x^{2}.\n$$\n令 $\\nabla f(x,y)=\\mathbf{0}$ 得到方程组\n$$\n2xy=0,\\qquad x^{2}=0.\n$$\n由 $x^{2}=0$ 我们得到 $x=0$。将其代入 $2xy=0$ 得到 $0=0$，这对 $y$ 没有施加进一步的限制。因此，整个纵轴都是临界点：\n$$\n\\mathcal{C}=\\{(0,y):y\\in\\mathbb{R}\\}.\n$$\n\n步骤 $2$：检查海森矩阵和二阶检验。$f$ 的海森矩阵是\n$$\n\\nabla^{2} f(x,y)=\\begin{pmatrix}\n\\frac{\\partial^{2}f}{\\partial x^{2}} & \\frac{\\partial^{2}f}{\\partial x\\partial y}\\\\\n\\frac{\\partial^{2}f}{\\partial y\\partial x} & \\frac{\\partial^{2}f}{\\partial y^{2}}\n\\end{pmatrix}\n=\\begin{pmatrix}\n2y & 2x\\\\\n2x & 0\n\\end{pmatrix}.\n$$\n在一个临界点 $(0,y_{0})$ 处，它简化为\n$$\n\\nabla^{2} f(0,y_{0})=\\begin{pmatrix}\n2y_{0} & 0\\\\\n0 & 0\n\\end{pmatrix}.\n$$\n对于 $y_{0}\\neq 0$，海森矩阵的秩为 $1$（一个非零特征值和一个零特征值），因此是奇异的。对于 $y_{0}=0$（原点），海森矩阵是零矩阵，秩为 $0$。在 $\\mathcal{C}$ 上的所有情况下，海森矩阵都是秩亏的，因此经典的二阶检验是不确定的：一个半正定海森矩阵不保证是局部最小值点，一个半负定海森矩阵不保证是局部最大值点，而一个奇异海森矩阵若无进一步分析则不能断定为鞍点。\n\n步骤 $3$：对临界点进行分类。\n\n**情形一：非零临界点 $(0,y_{0})$（其中 $y_{0}\\neq 0$）**\n我们直接根据定义在这些点的邻域内检查函数 $f(x,y)=x^2y$ 的行为。在任何临界点 $(0, y_0)$，函数值为 $f(0, y_0) = 0$。\n-   如果 $y_0 > 0$，我们可以考虑一个足够小的邻域，使得该邻域内所有的点的 $y$ 坐标都为正。对于该邻域内的任意点 $(x,y)$，我们有 $f(x,y) = x^2y \\ge 0$。由于函数值总是大于或等于其在临界点的值 $0$，因此点 $(0,y_0)$ 是一个**非严格局部最小值**。它是非严格的，因为在它的任意邻域内都存在其他值为 $0$ 的临界点（例如 $(0, y_0+\\epsilon)$）。\n-   如果 $y_0  0$，类似地，我们可以考虑一个 $y$ 坐标始终为负的邻域。对于该邻域内的任意点 $(x,y)$，我们有 $f(x,y) = x^2y \\le 0$。由于函数值总是小于或等于其在临界点的值 $0$，因此点 $(0,y_0)$ 是一个**非严格局部最大值**。\n\n**情形二：原点 $(0,0)$**\n在原点，海森矩阵是零矩阵，二阶测试完全失效。我们需要检查函数在原点附近的行为。考虑沿任意方向 $\\mathbf{u}=(u_x, u_y)$ 上的射线 $(x,y) = (tu_x, tu_y)$，其中 $t > 0$ 且 $\\|\\mathbf{u}\\|=1$。函数值变为 $f(tu_x, tu_y) = (tu_x)^2(tu_y) = t^3 u_x^2 u_y$。\n-   如果 $u_y > 0$（例如，方向 $(1/\\sqrt{2}, 1/\\sqrt{2})$），则 $f > 0$。\n-   如果 $u_y  0$（例如，方向 $(1/\\sqrt{2}, -1/\\sqrt{2})$），则 $f  0$。\n由于在原点的任意邻域内，我们总能找到函数值大于零和小于零的点，所以原点 $(0,0)$ 是一个**鞍点**。\n\n步骤 $4$：识别前导阶方向剖面。正如在步骤 $3$ 中对原点的分析所示，函数沿射线的行为是 $f(tu_{x},tu_{y})=t^{3}(u_{x}^{2}u_{y})$。\n因此，最小的正整数 $k$ 是 $3$，前导阶方向剖面是\n$$\ng(u_{x},u_{y})=u_{x}^{2}u_{y}.\n$$\n$g$ 的符号取决于 $u_y$ 的符号，这证实了我们的结论，即原点是一个鞍点，因为函数沿不同方向（例如，进入上半平面与下半平面）的行为不同。", "answer": "$$\\boxed{u_{x}^{2}u_{y}}$$", "id": "3184903"}, {"introduction": "理解驻点的理论性质至关重要，但它们真正的价值体现在其如何影响优化算法的行为。这个计算练习对比了两种基石性的方法——一阶的梯度下降法和二阶的牛顿法——在严格鞍点附近的表现。通过模拟它们的轨迹，你将发现为何鞍点对某些算法而言可能是个难题，并深入理解逃离鞍点的动力学过程，这在现代机器学习领域中是一个极其重要的话题。[@problem_id:3184951]", "problem": "您需要编写一个完整的、可运行的程序，用于比较梯度下降法和牛顿法在严格鞍点附近的局部逃逸动态。该动态是针对一个二元函数 $f:\\mathbb{R}^2 \\to \\mathbb{R}$ 的，其定义规则如下：给定一个标量参数 $\\epsilon \\in \\mathbb{R}$，定义 $f$ 为\n$$\nf(x,y) = x^2 - y^2 + \\epsilon\\,(x^3 + y^3).\n$$\n从优化方法的核心定义出发。驻点是梯度等于零向量的任意点，而严格鞍点是海森矩阵为不定的驻点。利用这些原理，通过第一性原理的解析微分，推导出梯度 $\\nabla f(x,y)$ 和海森矩阵 $\\nabla^2 f(x,y)$。仅基于这些导数以及从一阶和二阶泰勒展开推导出的标准更新规则，实现以下两种迭代方法：\n- 梯度下降法，采用固定步长 $\\alpha  0$：使用负梯度方向从 $(x_k,y_k)$ 迭代到 $(x_{k+1},y_{k+1})$。\n- 牛顿法，采用完整步长 $\\alpha_{\\text{Newton}} = 1$：通过求解由当前迭代点的海森矩阵和梯度定义的线性系统来计算步长。\n\n您的程序必须从相同的初始条件模拟这两种方法，并比较它们从原点小邻域（对于小的 $|\\epsilon|$ 而言，该原点是一个严格鞍点）的“逃逸”行为。对于给定的逃逸半径 $R  0$ 和最大迭代次数 $M \\in \\mathbb{N}$：\n- 将一种方法的逃逸时间定义为满足 $\\sqrt{x_k^2 + y_k^2} \\ge R$ 的最小整数 $k \\in \\{1,2,\\dots,M\\}$。如果在 $M$ 次迭代内不存在这样的 $k$，则报告逃逸时间为 $-1$。\n- 从初始点执行第一次更新后开始计数；即使起始点已经满足阈值，也不要将其计为已逃逸。\n\n科学真实性要求：确保您的实现直接使用解析推导出的 $\\nabla f$ 和 $\\nabla^2 f$ 进行更新。在计算牛顿步长时，只要海森矩阵可逆，就精确求解该 $2\\times 2$ 线性系统以获得步长方向；如果在数值上遇到奇异点，则将该轨迹视为在迭代预算内未逃逸，并在该测试中为该方法报告 $-1$。\n\n本问题不涉及角度单位。不涉及物理单位。\n\n测试套件。您的程序必须评估以下五个参数集，每个参数集指定为一个元组 $(\\epsilon,\\alpha,x_0,y_0,R,M)$，其中 $\\epsilon$ 是三次项系数，$\\alpha$ 是梯度下降步长，$(x_0,y_0)$ 是初始点，$R$ 是逃逸半径，$M$ 是迭代上限：\n- 情况 1：$(\\epsilon,\\alpha,x_0,y_0,R,M) = (0.01,\\,0.1,\\,0.05,\\,0.05,\\,1.0,\\,200)$。\n- 情况 2：$(\\epsilon,\\alpha,x_0,y_0,R,M) = (0.01,\\,0.1,\\,0.05,\\,0.0,\\,1.0,\\,200)$。\n- 情况 3：$(\\epsilon,\\alpha,x_0,y_0,R,M) = (-0.01,\\,0.1,\\,0.05,\\,0.05,\\,1.0,\\,200)$。\n- 情况 4：$(\\epsilon,\\alpha,x_0,y_0,R,M) = (0.2,\\,0.1,\\,0.05,\\,0.05,\\,1.0,\\,200)$。\n- 情况 5：$(\\epsilon,\\alpha,x_0,y_0,R,M) = (0.01,\\,0.02,\\,0.05,\\,0.05,\\,1.0,\\,200)$。\n\n对于每种情况，您的程序必须计算两个整数：梯度下降法的逃逸时间和牛顿法的逃逸时间。要求的最终输出格式是包含一个列表的列表的单行，其中每个内部列表的形式为 $[\\text{gd\\_steps},\\text{newton\\_steps}]$，对应相应的情况，不带任何附加文本。例如，您的程序必须打印形如\n$[[\\text{gd}_1,\\text{nt}_1],[\\text{gd}_2,\\text{nt}_2],\\dots,[\\text{gd}_5,\\text{nt}_5]]$\n的一行，其中每个 $\\text{gd}_i$ 和 $\\text{nt}_i$ 都是一个整数。这些数字不应包含任何单位，并应作为纯整数打印。", "solution": "用户提供的问题是有效的。它在数值优化的原理上有科学依据，问题设定良好，目标明确，数据充分，并以客观、正式的语言陈述。我们将提供一个完整的解决方案。\n\n问题的核心是比较两种基本优化算法——梯度下降法和牛顿法——在严格鞍点附近的局部动态。分析是针对由以下方式定义的二元函数 $f: \\mathbb{R}^2 \\to \\mathbb{R}$ 进行的\n$$\nf(x,y) = x^2 - y^2 + \\epsilon(x^3 + y^3)\n$$\n其中 $\\epsilon$ 是一个实值参数。严格鞍点是海森矩阵为不定（即同时具有正特征值和负特征值）的驻点。\n\n为了实现这些算法，我们必须首先从第一性原理推导出梯度向量 $\\nabla f(x,y)$ 和海森矩阵 $\\nabla^2 f(x,y)$。\n\n$f(x,y)$ 的偏导数是：\n$$\n\\frac{\\partial f}{\\partial x} = 2x + 3\\epsilon x^2\n$$\n$$\n\\frac{\\partial f}{\\partial y} = -2y + 3\\epsilon y^2\n$$\n因此，梯度向量 $\\nabla f(x,y)$ 是：\n$$\n\\nabla f(x,y) = \\begin{pmatrix} 2x + 3\\epsilon x^2 \\\\ -2y + 3\\epsilon y^2 \\end{pmatrix}\n$$\n驻点出现在 $\\nabla f(x,y) = \\mathbf{0}$ 的地方。通过观察可知，对于任何 $\\epsilon$ 值，原点 $(x,y) = (0,0)$ 都是一个驻点。\n\n接下来，我们计算二阶偏导数以构建海森矩阵：\n$$\n\\frac{\\partial^2 f}{\\partial x^2} = \\frac{\\partial}{\\partial x}(2x + 3\\epsilon x^2) = 2 + 6\\epsilon x\n$$\n$$\n\\frac{\\partial^2 f}{\\partial y^2} = \\frac{\\partial}{\\partial y}(-2y + 3\\epsilon y^2) = -2 + 6\\epsilon y\n$$\n$$\n\\frac{\\partial^2 f}{\\partial x \\partial y} = \\frac{\\partial}{\\partial x}(-2y + 3\\epsilon y^2) = 0\n$$\n由于 $f$ 是一个多项式，其混合偏导数是连续的，所以 $\\frac{\\partial^2 f}{\\partial y \\partial x} = \\frac{\\partial^2 f}{\\partial x \\partial y}$。海森矩阵 $\\nabla^2 f(x,y)$ 是：\n$$\n\\nabla^2 f(x,y) = \\begin{pmatrix} 2 + 6\\epsilon x  0 \\\\ 0  -2 + 6\\epsilon y \\end{pmatrix}\n$$\n为了验证原点是一个严格鞍点，我们在 $(0,0)$ 处计算海森矩阵：\n$$\n\\nabla^2 f(0,0) = \\begin{pmatrix} 2  0 \\\\ 0  -2 \\end{pmatrix}\n$$\n该矩阵的特征值为 $\\lambda_1 = 2$ 和 $\\lambda_2 = -2$。由于一个特征值为正，一个为负，因此海森矩阵在原点是不定的，这证实了对于任何 $\\epsilon$，$(0,0)$ 都是一个严格鞍点。函数的二次部分 $x^2 - y^2$ 创建了一个鞍形几何结构，其中函数沿 $x$ 轴（梯度下降的稳定流形方向）增加，并沿 $y$ 轴（不稳定流形方向）减少。\n\n有了这些导数，我们可以为迭代点 $\\mathbf{x}_k = (x_k, y_k)^T$ 指定迭代更新规则：\n\n**1. 梯度下降法 (GD)**\n采用固定步长 $\\alpha  0$ 的梯度下降法的更新规则是基于沿梯度反方向移动：\n$$\n\\mathbf{x}_{k+1} = \\mathbf{x}_k - \\alpha \\nabla f(\\mathbf{x}_k)\n$$\n以分量形式表示，更新如下：\n$$\nx_{k+1} = x_k - \\alpha (2x_k + 3\\epsilon x_k^2) = x_k(1 - 2\\alpha) - 3\\alpha\\epsilon x_k^2\n$$\n$$\ny_{k+1} = y_k - \\alpha (-2y_k + 3\\epsilon y_k^2) = y_k(1 + 2\\alpha) - 3\\alpha\\epsilon y_k^2\n$$\n在原点附近，线性项占主导地位。$x$ 分量乘以一个因子 $(1 - 2\\alpha)$。对于像 $\\alpha=0.1$ 这样的小步长，该因子为 $0.8$，导致 $x$ 分量衰减。$y$ 分量乘以一个因子 $(1 + 2\\alpha)$，即 $1.2$。该因子大于 $1$，导致 $y$ 分量指数增长。沿不稳定方向（与海森矩阵的负特征值相关）的这种指数增长，使得梯度下降的迭代点能够迅速“逃离”鞍点，前提是初始点在该方向上具有非零分量。如果初始点位于稳定流形上（此处为 $x$ 轴，其中 $y_0 = 0$），则迭代点将收敛到鞍点。\n\n**2. 牛顿法 (NT)**\n牛顿法使用函数的二阶泰勒近似。更新步长 $\\Delta \\mathbf{x}_k$ 通过求解以下线性系统得到：\n$$\n\\nabla^2 f(\\mathbf{x}_k) \\Delta \\mathbf{x}_k = - \\nabla f(\\mathbf{x}_k)\n$$\n那么下一个迭代点是 $\\mathbf{x}_{k+1} = \\mathbf{x}_k + \\Delta \\mathbf{x}_k$（使用指定的完整步长 $1$）。由于我们的海森矩阵是对角矩阵，只要对角元素非零，解就很容易求得：\n$$\n\\Delta x_k = -\\frac{2x_k + 3\\epsilon x_k^2}{2 + 6\\epsilon x_k} \\quad \\text{和} \\quad \\Delta y_k = -\\frac{-2y_k + 3\\epsilon y_k^2}{-2 + 6\\epsilon y_k}\n$$\n更新如下：\n$$\nx_{k+1} = x_k + \\Delta x_k = x_k - \\frac{2x_k + 3\\epsilon x_k^2}{2 + 6\\epsilon x_k} = \\frac{x_k(2+6\\epsilon x_k) - (2x_k + 3\\epsilon x_k^2)}{2 + 6\\epsilon x_k} = \\frac{3\\epsilon x_k^2}{2 + 6\\epsilon x_k}\n$$\n$$\ny_{k+1} = y_k + \\Delta y_k = y_k - \\frac{-2y_k + 3\\epsilon y_k^2}{-2 + 6\\epsilon y_k} = \\frac{y_k(-2+6\\epsilon y_k) - (-2y_k + 3\\epsilon y_k^2)}{-2 + 6\\epsilon y_k} = \\frac{3\\epsilon y_k^2}{-2 + 6\\epsilon y_k}\n$$\n在原点附近，$x_k$ 和 $y_k$ 很小，这些更新表明 $x_{k+1} \\approx \\frac{3\\epsilon}{2} x_k^2$ 且 $y_{k+1} \\approx -\\frac{3\\epsilon}{2} y_k^2$。两个分量都二次收敛到 $0$。这表明，当应用于严格鞍点附近时，纯粹形式的牛顿法不会自动逃逸。相反，它被强烈地吸引到鞍点本身。这种行为促使了修正牛顿法（例如，信赖域法或三次正则化法）的发展，这些方法旨在利用负曲率实现快速逃逸。如果分母项 $2+6\\epsilon x_k$ 或 $-2+6\\epsilon y_k$ 在数值上变为零，仿真必须处理这种潜在的奇异性。\n\n程序将实现两个函数，每种方法一个，用于从初始点 $(x_0, y_0)$ 模拟轨迹。每个函数将最多迭代 $M$ 次，在每一步 $k$ 检查与原点的距离 $\\sqrt{x_k^2 + y_k^2}$ 是否达到或超过逃逸半径 $R$。第一个满足此条件的 $k \\ge 1$ 即为逃逸时间。如果在 $M$ 次迭代内没有发生逃逸，则报告逃逸时间为 $-1$。此逻辑将应用于所提供的每个测试用例。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the optimization problem by simulating Gradient Descent and Newton's\n    method to compare their escape dynamics from a saddle point.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: (epsilon, alpha, x0, y0, R, M)\n        (0.01, 0.1, 0.05, 0.05, 1.0, 200),\n        # Case 2: Initial point on the stable manifold\n        (0.01, 0.1, 0.05, 0.0, 1.0, 200),\n        # Case 3: Negative epsilon\n        (-0.01, 0.1, 0.05, 0.05, 1.0, 200),\n        # Case 4: Larger epsilon\n        (0.2, 0.1, 0.05, 0.05, 1.0, 200),\n        # Case 5: Smaller GD step size\n        (0.01, 0.02, 0.05, 0.05, 1.0, 200),\n    ]\n\n    def simulate_gd(params):\n        \"\"\"\n        Simulates Gradient Descent for a given parameter set.\n        \n        Args:\n            params (tuple): A tuple containing (epsilon, alpha, x0, y0, R, M).\n\n        Returns:\n            int: The escape time, or -1 if not escaped.\n        \"\"\"\n        epsilon, alpha, x0, y0, r_escape, m_iter = params\n        x_k, y_k = float(x0), float(y0)\n        r_escape_sq = r_escape**2\n\n        for k in range(1, int(m_iter) + 1):\n            # Gradient components\n            grad_x = 2.0 * x_k + 3.0 * epsilon * x_k**2\n            grad_y = -2.0 * y_k + 3.0 * epsilon * y_k**2\n            \n            # Update step\n            x_k = x_k - alpha * grad_x\n            y_k = y_k - alpha * grad_y\n\n            # Check for escape\n            if x_k**2 + y_k**2 = r_escape_sq:\n                return k\n        \n        return -1\n\n    def simulate_newton(params):\n        \"\"\"\n        Simulates Newton's Method for a given parameter set.\n        \n        Args:\n            params (tuple): A tuple containing (epsilon, alpha, x0, y0, R, M).\n                          alpha is unused for Newton's method.\n\n        Returns:\n            int: The escape time, or -1 if not escaped or singular.\n        \"\"\"\n        epsilon, _, x0, y0, r_escape, m_iter = params\n        x_k, y_k = float(x0), float(y0)\n        r_escape_sq = r_escape**2\n        singularity_threshold = 1e-12\n\n        for k in range(1, int(m_iter) + 1):\n            # Hessian diagonal components\n            h11 = 2.0 + 6.0 * epsilon * x_k\n            h22 = -2.0 + 6.0 * epsilon * y_k\n\n            # Check for numerical singularity\n            if abs(h11)  singularity_threshold or abs(h22)  singularity_threshold:\n                return -1\n            \n            # Gradient components\n            grad_x = 2.0 * x_k + 3.0 * epsilon * x_k**2\n            grad_y = -2.0 * y_k + 3.0 * epsilon * y_k**2\n\n            # Newton step\n            delta_x = -grad_x / h11\n            delta_y = -grad_y / h22\n\n            # Update step\n            x_k = x_k + delta_x\n            y_k = y_k + delta_y\n\n            # Check for escape\n            if x_k**2 + y_k**2 = r_escape_sq:\n                return k\n\n        return -1\n        \n    results = []\n    for case in test_cases:\n        gd_steps = simulate_gd(case)\n        newton_steps = simulate_newton(case)\n        results.append([gd_steps, newton_steps])\n\n    # Final print statement in the exact required format.\n    # The format string converts the list of lists to a string without spaces.\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "3184951"}]}