{"hands_on_practices": [{"introduction": "理论是实践的向导，而实践是检验理论的唯一标准。本节的第一个练习旨在巩固仿射集与仿射包的基本定义，你将通过具体的代数运算，亲手检验一个点集是否满足给定的仿射约束 $Ax=b$，并从第一性原理出发确定其仿射包的维度。这个基础性训练将帮助你深刻理解仿射集的两种等价刻画方式：线性方程组的解集与平移的子空间。[@problem_id:3096335]", "problem": "考虑由线性方程组 $A x = b$ 定义的线性可行集，其中\n$$\nA = \\begin{pmatrix}\n1  -1  0  2 \\\\\n0  1  1  -1\n\\end{pmatrix}, \n\\quad\nb = \\begin{pmatrix}\n3 \\\\\n0\n\\end{pmatrix},\n$$\n以及包含 $\\mathbb{R}^{4}$ 中四个点的数据集，\n$$\nx^{(1)} = \\begin{pmatrix} 4 \\\\ 1 \\\\ -1 \\\\ 0 \\end{pmatrix},\\quad\nx^{(2)} = \\begin{pmatrix} 1 \\\\ 0 \\\\ 1 \\\\ 1 \\end{pmatrix},\\quad\nx^{(3)} = \\begin{pmatrix} -1 \\\\ 2 \\\\ 1 \\\\ 3 \\end{pmatrix},\\quad\nx^{(4)} = \\begin{pmatrix} -2 \\\\ -1 \\\\ 3 \\\\ 2 \\end{pmatrix}.\n$$\n从仿射集和仿射包的核心定义出发，并利用标准的线性代数知识，完成以下任务：\n\n1. 通过直接计算 $A x^{(i)}$ 并将其与 $b$ 比较，判断每个点 $x^{(i)}$ 是否位于仿射集 $\\{x \\in \\mathbb{R}^{4} : A x = b\\}$ 中。\n2. 从基本原理出发，推导包含 $\\{x^{(1)}, x^{(2)}, x^{(3)}, x^{(4)}\\}$ 的最小仿射集，并通过适当分析这些点之间的差向量来确定其维数。\n\n请提供一个基于定义和线性代数性质的清晰、有理有据的推导，而不是依赖于预先给定的目标公式。最后，仅报告 $\\{x^{(1)}, x^{(2)}, x^{(3)}, x^{(4)}\\}$ 的仿射包的维数，结果应为一个精确整数，无需四舍五入。", "solution": "按照要求，该问题分两部分进行分析。首先，我们验证给定的点是否位于指定的仿射集中。其次，我们从基本原理出发，确定这些点的仿射包及其维数。\n\n仿射集是向量空间的一个子集，它对仿射组合是封闭的。如果对于集合 $S$ 中的任意 $x, y$，点 $\\theta x + (1-\\theta)y$ 对于任意标量 $\\theta \\in \\mathbb{R}$ 也属于 $S$，则称 $S$ 是仿射的。线性方程组 $\\{x \\in \\mathbb{R}^n : Ax=b\\}$ 的解集构成一个仿射集。\n\n第一部分：验证点是否在仿射集 $\\{x \\in \\mathbb{R}^{4} : A x = b\\}$ 中。\n\n给定矩阵 $A = \\begin{pmatrix} 1  -1  0  2 \\\\ 0  1  1  -1 \\end{pmatrix}$ 和向量 $b = \\begin{pmatrix} 3 \\\\ 0 \\end{pmatrix}$。我们必须对每个点 $i \\in \\{1, 2, 3, 4\\}$ 验证是否有 $A x^{(i)} = b$。\n\n对于 $x^{(1)} = \\begin{pmatrix} 4 \\\\ 1 \\\\ -1 \\\\ 0 \\end{pmatrix}$：\n$$A x^{(1)} = \\begin{pmatrix} 1  -1  0  2 \\\\ 0  1  1  -1 \\end{pmatrix} \\begin{pmatrix} 4 \\\\ 1 \\\\ -1 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} (1)(4) + (-1)(1) + (0)(-1) + (2)(0) \\\\ (0)(4) + (1)(1) + (1)(-1) + (-1)(0) \\end{pmatrix} = \\begin{pmatrix} 4 - 1 \\\\ 1 - 1 \\end{pmatrix} = \\begin{pmatrix} 3 \\\\ 0 \\end{pmatrix}.$$\n由于 $A x^{(1)} = b$，点 $x^{(1)}$ 位于仿射集中。\n\n对于 $x^{(2)} = \\begin{pmatrix} 1 \\\\ 0 \\\\ 1 \\\\ 1 \\end{pmatrix}$：\n$$A x^{(2)} = \\begin{pmatrix} 1  -1  0  2 \\\\ 0  1  1  -1 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 0 \\\\ 1 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} (1)(1) + (-1)(0) + (0)(1) + (2)(1) \\\\ (0)(1) + (1)(0) + (1)(1) + (-1)(1) \\end{pmatrix} = \\begin{pmatrix} 1 + 2 \\\\ 1 - 1 \\end{pmatrix} = \\begin{pmatrix} 3 \\\\ 0 \\end{pmatrix}.$$\n由于 $A x^{(2)} = b$，点 $x^{(2)}$ 位于仿射集中。\n\n对于 $x^{(3)} = \\begin{pmatrix} -1 \\\\ 2 \\\\ 1 \\\\ 3 \\end{pmatrix}$：\n$$A x^{(3)} = \\begin{pmatrix} 1  -1  0  2 \\\\ 0  1  1  -1 \\end{pmatrix} \\begin{pmatrix} -1 \\\\ 2 \\\\ 1 \\\\ 3 \\end{pmatrix} = \\begin{pmatrix} (1)(-1) + (-1)(2) + (0)(1) + (2)(3) \\\\ (0)(-1) + (1)(2) + (1)(1) + (-1)(3) \\end{pmatrix} = \\begin{pmatrix} -1 - 2 + 6 \\\\ 2 + 1 - 3 \\end{pmatrix} = \\begin{pmatrix} 3 \\\\ 0 \\end{pmatrix}.$$\n由于 $A x^{(3)} = b$，点 $x^{(3)}$ 位于仿射集中。\n\n对于 $x^{(4)} = \\begin{pmatrix} -2 \\\\ -1 \\\\ 3 \\\\ 2 \\end{pmatrix}$：\n$$A x^{(4)} = \\begin{pmatrix} 1  -1  0  2 \\\\ 0  1  1  -1 \\end{pmatrix} \\begin{pmatrix} -2 \\\\ -1 \\\\ 3 \\\\ 2 \\end{pmatrix} = \\begin{pmatrix} (1)(-2) + (-1)(-1) + (0)(3) + (2)(2) \\\\ (0)(-2) + (1)(-1) + (1)(3) + (-1)(2) \\end{pmatrix} = \\begin{pmatrix} -2 + 1 + 4 \\\\ -1 + 3 - 2 \\end{pmatrix} = \\begin{pmatrix} 3 \\\\ 0 \\end{pmatrix}.$$\n由于 $A x^{(4)} = b$，点 $x^{(4)}$ 位于仿射集中。\n所有四个点 $x^{(1)}, x^{(2)}, x^{(3)}, x^{(4)}$ 都是给定仿射集的成员。\n\n第二部分：仿射包及其维数的推导。\n\n一组点 $C = \\{x^{(1)}, \\dots, x^{(k)}\\}$ 的仿射包，记作 $\\text{aff}(C)$，是这些点的所有仿射组合的集合：\n$$ \\text{aff}(C) = \\left\\{ \\sum_{i=1}^{k} \\theta_i x^{(i)} \\;\\middle|\\; \\theta_i \\in \\mathbb{R}, \\sum_{i=1}^{k} \\theta_i = 1 \\right\\}. $$\n这是包含 $C$ 中所有点的最小仿射集。\n一个仿射集可以描述为一个向量子空间的平移。也就是说，对于包含点 $x_0$ 的任何仿射集 $S$，集合 $V = \\{x - x_0 \\mid x \\in S\\}$ 是一个向量子空间。仿射集 $S$ 的维数定义为这个相关子空间 $V$ 的维数。\n\n为了找到 $\\{x^{(1)}, x^{(2)}, x^{(3)}, x^{(4)}\\}$ 的仿射包的维数，我们首先构造相关的向量子空间。我们可以选择其中任意一个点作为平移的原点，例如 $x^{(1)}$。子空间 $V$ 由 $x^{(1)}$ 与其他点之间的差向量张成：\n$$V = \\text{span}\\{x^{(2)} - x^{(1)}, x^{(3)} - x^{(1)}, x^{(4)} - x^{(1)}\\}.$$\n仿射包的维数是 $\\dim(V)$。让我们计算这些差向量：\n$$v^{(1)} = x^{(2)} - x^{(1)} = \\begin{pmatrix} 1 \\\\ 0 \\\\ 1 \\\\ 1 \\end{pmatrix} - \\begin{pmatrix} 4 \\\\ 1 \\\\ -1 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} -3 \\\\ -1 \\\\ 2 \\\\ 1 \\end{pmatrix}.$$\n$$v^{(2)} = x^{(3)} - x^{(1)} = \\begin{pmatrix} -1 \\\\ 2 \\\\ 1 \\\\ 3 \\end{pmatrix} - \\begin{pmatrix} 4 \\\\ 1 \\\\ -1 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} -5 \\\\ 1 \\\\ 2 \\\\ 3 \\end{pmatrix}.$$\n$$v^{(3)} = x^{(4)} - x^{(1)} = \\begin{pmatrix} -2 \\\\ -1 \\\\ 3 \\\\ 2 \\end{pmatrix} - \\begin{pmatrix} 4 \\\\ 1 \\\\ -1 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} -6 \\\\ -2 \\\\ 4 \\\\ 2 \\end{pmatrix}.$$\n仿射包的维数是由 $\\{v^{(1)}, v^{(2)}, v^{(3)}\\}$ 张成的子空间的维数，它等于这个集合中线性无关向量的个数。我们观察到 $v^{(1)}$ 和 $v^{(3)}$ 之间的关系：\n$$2 v^{(1)} = 2 \\begin{pmatrix} -3 \\\\ -1 \\\\ 2 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} -6 \\\\ -2 \\\\ 4 \\\\ 2 \\end{pmatrix} = v^{(3)}.$$\n由于 $v^{(3)}$ 是 $v^{(1)}$ 的标量倍，它线性依赖于 $v^{(1)}$。因此，张成向量集可以简化为 $\\{v^{(1)}, v^{(2)}\\}$：\n$$V = \\text{span}\\{v^{(1)}, v^{(2)}, v^{(3)}\\} = \\text{span}\\{v^{(1)}, v^{(2)}\\}.$$\n$V$ 的维数最多为 $2$。为了确定它是否恰好为 $2$，我们必须检查 $v^{(1)}$ 和 $v^{(2)}$ 是否线性无关。我们寻找标量 $c_1, c_2$ 使得 $c_1 v^{(1)} + c_2 v^{(2)} = 0$：\n$$c_1 \\begin{pmatrix} -3 \\\\ -1 \\\\ 2 \\\\ 1 \\end{pmatrix} + c_2 \\begin{pmatrix} -5 \\\\ 1 \\\\ 2 \\\\ 3 \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\\\ 0 \\end{pmatrix}.$$\n这个向量方程对应于一个线性方程组：\n\\begin{enumerate}\n    \\item $-3c_1 - 5c_2 = 0$\n    \\item $-c_1 + c_2 = 0$\n    \\item $2c_1 + 2c_2 = 0$\n    \\item $c_1 + 3c_2 = 0$\n\\end{enumerate}\n从方程(2)中，我们得到 $c_2 = c_1$。将此代入方程(3)得到 $2c_1 + 2c_1 = 4c_1 = 0$，这意味着 $c_1 = 0$。因为 $c_2 = c_1$，所以我们必然有 $c_2 = 0$。这个解 $(c_1, c_2)=(0,0)$ 满足所有四个方程。由于唯一的解是平凡解，向量 $v^{(1)}$ 和 $v^{(2)}$ 是线性无关的。\n\n集合 $\\{v^{(1)}, v^{(2)}\\}$ 构成了子空间 $V$ 的一个基。向量空间的维数是其基中向量的数量。因此，$\\dim(V) = 2$。\n包含 $\\{x^{(1)}, x^{(2)}, x^{(3)}, x^{(4)}\\}$ 的最小仿射集是仿射包，可以表示为：\n$$ \\text{aff}\\{x^{(1)}, x^{(2)}, x^{(3)}, x^{(4)}\\} = x^{(1)} + V = \\left\\{ x^{(1)} + c_1 v^{(1)} + c_2 v^{(2)} \\mid c_1, c_2 \\in \\mathbb{R} \\right\\}. $$\n这个仿射包的维数是 $\\dim(V)$。\n根据我们的分析，维数是 $2$。\n这与以下事实一致：这些点的仿射包是仿射集 $\\{x: Ax=b\\}$ 的一个子集。$\\{x: Ax=b\\}$ 的维数是 $A$ 的零空间的维数，即 $4 - \\text{rank}(A) = 4 - 2 = 2$。由于仿射包的维数是 $2$ 并且包含在一个维数为 $2$ 的仿射集内，这两个集合必然相同。\n\n$\\{x^{(1)}, x^{(2)}, x^{(3)}, x^{(4)}\\}$ 的仿射包的维数是 $2$。", "answer": "$$\\boxed{2}$$", "id": "3096335"}, {"introduction": "掌握了仿射包的几何性质后，其在优化领域的应用便成为我们关注的焦点。这个练习通过一个引人深思的对比，探讨了在线性规划中，将可行域从一个有界的凸包放宽到一个无界的仿射包会带来何种后果。通过这个例子，你将直观地理解为何仅包含等式约束的仿射可行问题与包含不等式约束的凸可行问题在解的性质（如有界性）上存在根本差异。[@problem_id:3096352]", "problem": "考虑一个有限点集 $\\{x_i\\}_{i=1}^m \\subset \\mathbb{R}^n$，其凸包 $\\operatorname{conv}\\{x_i\\}$，以及其仿射包 $\\operatorname{aff}\\{x_i\\}$。设 $f(x) = c^\\top x$ 是一个线性泛函，其中 $c \\in \\mathbb{R}^n$。在优化方法的背景下，人们常常关心可行域如何改变解的行为。特别是，仿射可行性（只有等式，没有不等式）可以将可行域从一个有界的凸多胞体扩大到一个无界的仿射子空间。\n\n考虑 $\\mathbb{R}^2$ 中的一个具体实例，由点 $x_1 = (0,0)$、$x_2 = (2,2)$ 和 $x_3 = (3,3)$ 给出。对于这些点，其凸包是连接 $x_1$ 和 $x_3$ 的线段，其仿射包是整条直线 $\\{(t,t) : t \\in \\mathbb{R}\\}$。考虑两个线性泛函：\n- $f_1(x) = c_1^\\top x$，其中 $c_1 = (1,-1)$，\n- $f_2(x) = c_2^\\top x$，其中 $c_2 = (1,0)$。\n\n选择所有关于在 $\\operatorname{conv}\\{x_i\\}$ 上与在 $\\operatorname{aff}\\{x_i\\}$ 上最大化 $f(x)$ 的比较，以及关于用其仿射包（仅有仿射可行性，无不等式）替换有界凸可行域会如何改变解的行为的正确陈述。\n\nA. 对于 $f_1$，在 $\\operatorname{aff}\\{x_i\\}$ 上最大化得到的最优值与在 $\\operatorname{conv}\\{x_i\\}$ 上最大化得到的最优值相同，并且 $\\operatorname{aff}\\{x_i\\}$ 中的每个点都是在 $\\operatorname{aff}\\{x_i\\}$ 上最大化 $f_1$ 时的最优点。\n\nB. 对于 $f_2$，在 $\\operatorname{aff}\\{x_i\\}$ 上最大化是上无界的，而在 $\\operatorname{conv}\\{x_i\\}$ 上最大化在 $x_3$ 处达到有限的最大值。\n\nC. 对于任何线性泛函 $f(x) = c^\\top x$，在 $\\operatorname{conv}\\{x_i\\}$ 上的最大值不能出现在极点上；它必须出现在 $\\operatorname{conv}\\{x_i\\}$ 的相对内部的一个点上。\n\nD. 如果 $c$ 与 $\\operatorname{aff}\\{x_i\\}$ 的方向子空间正交，那么在 $\\operatorname{aff}\\{x_i\\}$ 上最大化 $c^\\top x$ 有一个唯一的优化点，该点等于点集 $\\{x_i\\}$ 的质心（算术平均值）。", "solution": "首先验证问题陈述的合理性和完整性。\n\n**步骤1：提取已知条件**\n- 一个有限点集 $\\{x_i\\}_{i=1}^m \\subset \\mathbb{R}^n$。\n- 这些点的凸包 $\\operatorname{conv}\\{x_i\\}$。\n- 这些点的仿射包 $\\operatorname{aff}\\{x_i\\}$。\n- 一个线性泛函 $f(x) = c^\\top x$，其中 $c \\in \\mathbb{R}^n$。\n- $\\mathbb{R}^2$ 中的一个具体实例，点为 $x_1 = (0,0)$、$x_2 = (2,2)$ 和 $x_3 = (3,3)$。\n- 对于这些点，问题陈述其凸包是连接 $x_1$ 到 $x_3$ 的线段，仿射包是直线 $\\{(t,t) : t \\in \\mathbb{R}\\}$。\n- 提供了两个具体的线性泛函：\n    - $f_1(x) = c_1^\\top x$，其中 $c_1 = (1,-1)$。\n    - $f_2(x) = c_2^\\top x$，其中 $c_2 = (1,0)$。\n- 任务是评估关于在凸包和仿射包上最大化这些泛函的陈述。\n\n**步骤2：使用提取的已知条件进行验证**\n1.  **科学基础**：凸包、仿射包和线性泛函的概念是凸分析和优化的基础。它们是明确定义的数学对象。该问题具有科学基础。\n2.  **适定性**：该问题要求根据给定的设置评估四个不同数学陈述的真伪。每个陈述都是一个可证伪的断言，使得问题是适定的。\n3.  **客观性**：语言是精确和数学化的，没有主观内容。\n4.  **一致性和完整性**：给定的点 $x_1=(0,0)$、$x_2=(2,2)$ 和 $x_3=(3,3)$ 是共线的，位于直线 $y=x$ 上。\n    - 这些点的凸包是凸组合的集合。对于共线点，这是连接最外层点的线段。在这里，$x_1$ 和 $x_3$ 是最外层的点，因为 $x_2 = \\frac{1}{3}x_1 + \\frac{2}{3}x_3$。因此，$\\operatorname{conv}\\{x_1, x_2, x_3\\}$ 是从 $(0,0)$ 到 $(3,3)$ 的线段。问题陈述在这一点上是正确的。\n    - 仿射包是所有仿射组合的集合。对于共线点，这是穿过它们的整条直线。穿过 $(0,0)$ 和 $(3,3)$ 的直线确实是 $\\{(t,t) : t \\in \\mathbb{R}\\}$。问题陈述在这一点上也是正确的。\n    问题设置是自洽的，并提供了分析选项所需的所有信息。\n\n**步骤3：结论与行动**\n问题陈述有效。可以进行分析。\n\n**问题分析**\n\n设点集为 $S = \\{x_1, x_2, x_3\\}$，其中 $x_1 = (0,0)$，$x_2 = (2,2)$，$x_3 = (3,3)$。\n$S$ 的凸包是 $\\mathcal{C} = \\operatorname{conv}(S)$。如前所述，这是连接 $x_1$ 和 $x_3$ 的线段。任何点 $x \\in \\mathcal{C}$ 都可以写成 $x = (t,t)$ 的形式，其中 $t \\in [0,3]$。\n$S$ 的仿射包是 $\\mathcal{A} = \\operatorname{aff}(S)$。这是穿过这些点的直线。任何点 $x \\in \\mathcal{A}$ 都可以写成 $x = (t,t)$ 的形式，其中 $t \\in \\mathbb{R}$。\n\n两个线性泛函是 $f_1(x) = c_1^\\top x$ (其中 $c_1 = (1,-1)$) 和 $f_2(x) = c_2^\\top x$ (其中 $c_2 = (1,0)$)。\n\n让我们对一个通用点 $x = (t,t) \\in \\mathcal{A}$ 计算这两个泛函的值：\n- 对于 $f_1(x)$：$f_1((t,t)) = c_1^\\top (t,t) = (1, -1) \\cdot (t, t) = 1 \\cdot t + (-1) \\cdot t = t - t = 0$。\n- 对于 $f_2(x)$：$f_2((t,t)) = c_2^\\top (t,t) = (1, 0) \\cdot (t, t) = 1 \\cdot t + 0 \\cdot t = t$。\n\n现在我们可以评估每个陈述。\n\n**A. 对于 $f_1$，在 $\\operatorname{aff}\\{x_i\\}$ 上最大化得到的最优值与在 $\\operatorname{conv}\\{x_i\\}$ 上最大化得到的最优值相同，并且 $\\operatorname{aff}\\{x_i\\}$ 中的每个点都是在 $\\operatorname{aff}\\{x_i\\}$ 上最大化 $f_1$ 时的最优点。**\n\n- **在 $\\mathcal{A} = \\operatorname{aff}\\{x_i\\}$ 上最大化 $f_1$**：如上计算，$f_1(x) = 0$ 对所有 $x \\in \\mathcal{A}$ 成立。该函数在整个可行集上是常数。最大值是 $0$。因为函数值处处相同，所以每个点 $x \\in \\mathcal{A}$ 都是一个最大化点。\n- **在 $\\mathcal{C} = \\operatorname{conv}\\{x_i\\}$ 上最大化 $f_1$**：因为 $\\mathcal{C} \\subset \\mathcal{A}$，函数 $f_1(x)$ 对于所有 $x \\in \\mathcal{C}$ 也为常数 $0$。最大值是 $0$。\n- **比较**：在 $\\mathcal{A}$ 上最大化的最优值是 $0$。在 $\\mathcal{C}$ 上最大化的最优值也是 $0$。它们是相同的。陈述的第二部分，即 $\\operatorname{aff}\\{x_i\\}$ 的每个点都是在 $\\operatorname{aff}\\{x_i\\}$ 上最大化的最优点，也是正确的。\n\n因此，陈述 A 是 **正确的**。\n\n**B. 对于 $f_2$，在 $\\operatorname{aff}\\{x_i\\}$ 上最大化是上无界的，而在 $\\operatorname{conv}\\{x_i\\}$ 上最大化在 $x_3$ 处达到有限的最大值。**\n\n- **在 $\\mathcal{A} = \\operatorname{aff}\\{x_i\\}$ 上最大化 $f_2$**：问题是在定义域 $t \\in \\mathbb{R}$ 上最大化 $f_2((t,t)) = t$。由于 $t$ 可以任意大，该函数的值是上无界的。\n- **在 $\\mathcal{C} = \\operatorname{conv}\\{x_i\\}$ 上最大化 $f_2$**：问题是在定义域 $t \\in [0,3]$ 上最大化 $f_2((t,t)) = t$。最大值是 $3$，在 $t=3$ 时达到。对应于 $t=3$ 的点是 $(3,3)$，即点 $x_3$。所以，最大化在 $x_3$ 处达到有限的最大值。\n- 陈述的两部分都是准确的。\n\n因此，陈述 B 是 **正确的**。\n\n**C. 对于任何线性泛函 $f(x) = c^\\top x$，在 $\\operatorname{conv}\\{x_i\\}$ 上的最大值不能出现在极点上；它必须出现在 $\\operatorname{conv}\\{x_i\\}$ 的相对内部的一个点上。**\n\n这个陈述是关于凸包上线性优化的一般性论断。线性规划基本定理指出，一个线性函数在紧凸集（例如有限个点凸包形成的多胞体）上的最大值（如果存在）总是在其某个极点（顶点）上达到。\n在我们的具体例子中，凸包 $\\mathcal{C}$ 是一条线段。其极点是 $x_1=(0,0)$ 和 $x_3=(3,3)$。相对内部是它们之间的开线段，即 $\\{(t,t) : t \\in (0,3)\\}$。\n- 作为一个反例，考虑在 $\\mathcal{C}$ 上最大化 $f_2(x)$。我们在对 B 的分析中发现，最大值出现在 $x_3$ 处，而 $x_3$ 是一个极点。这直接与该陈述矛盾。\n- 另一个反例：考虑在 $\\mathcal{C}$ 上最小化 $f_2(x)$。最小值是 $0$，在另一个极点 $x_1$ 处达到。\n该陈述提出的主张与既定理论相反。\n\n因此，陈述 C 是 **不正确的**。\n\n**D. 如果 $c$ 与 $\\operatorname{aff}\\{x_i\\}$ 的方向子空间正交，那么在 $\\operatorname{aff}\\{x_i\\}$ 上最大化 $c^\\top x$ 有一个唯一的优化点，该点等于点集 $\\{x_i\\}$ 的质心（算术平均值）。**\n\n设 $\\mathcal{A} = \\operatorname{aff}\\{x_i\\}$ 是一个仿射集。它可以写成 $\\mathcal{A} = x_0 + V$，其中 $x_0 \\in \\mathcal{A}$，$V$ 是方向子空间。对于我们的问题，方向子空间是 $V = \\operatorname{span}\\{(1,1)\\}$，因为 $\\mathcal{A}$ 是通过原点且方向向量为 $(1,1)$ 的直线。\n条件是 $c$ 与 $V$ 正交，即对于所有 $v \\in V$，有 $c^\\top v = 0$。\n让我们为任意两点 $x_a, x_b \\in \\mathcal{A}$ 计算 $f(x) = c^\\top x$ 的值。我们可以写出 $x_b = x_a + v$，其中某个 $v \\in V$。那么，$f(x_b) = c^\\top x_b = c^\\top(x_a + v) = c^\\top x_a + c^\\top v$。由于 $c^\\top v = 0$，我们有 $f(x_b) = c^\\top x_a$。这表明函数 $f(x)$ 在整个仿射包 $\\mathcal{A}$ 上是常数。\n如果函数在 $\\mathcal{A}$ 上是常数，那么 $\\mathcal{A}$ 中的每个点都是最大化点。最优点集就是 $\\mathcal{A}$ 本身。最优点是唯一的当且仅当集合 $\\mathcal{A}$ 只包含一个点，而这在本问题中不成立。\n质心是 $\\bar{x} = \\frac{1}{3}(x_1+x_2+x_3) = \\frac{1}{3}((0,0)+(2,2)+(3,3)) = (\\frac{5}{3}, \\frac{5}{3})$。这个点在 $\\mathcal{A}$ 中。它是一个最优点，但不是唯一的。例如，$x_1=(0,0)$ 也是一个最优点。\n问题陈述中的向量 $c_1=(1,-1)$ 与 $V=\\operatorname{span}\\{(1,1)\\}$ 正交，因为 $c_1^\\top (1,1) = 1-1=0$。如在对 A 的分析中所示，$f_1(x)$ 在 $\\mathcal{A}$ 上是常数，每个点都是最优点。这为唯一性的主张提供了一个直接的反例。\n\n因此，陈述 D 是 **不正确的**。", "answer": "$$\\boxed{AB}$$", "id": "3096352"}, {"introduction": "在处理大规模数据集时，我们需要一种稳健的计算方法来确定其内在的仿射结构。这个练习将仿射包的概念与数据科学中的核心技术——主成分分析（PCA）——联系起来，指导你通过编程实践来确定一个点集的仿射维度，并计算任意点到这个仿射空间的距离。这项实践不仅能让你掌握一种强大的计算工具，还能让你领会到仿射几何在数据降维和异常检测等现代应用中的重要价值。[@problem_id:3096329]", "problem": "给你实欧几里得空间中的有限样本点集，每个集合附带一个查询点。你的任务是使用主成分分析（PCA）计算包含这些样本点的最小仿射子空间，并评估查询点到该仿射子空间的距离。使用以下定义作为基本依据：$\\mathbb{R}^n$ 中的仿射集是线性子空间的任意平移；集合 $S \\subset \\mathbb{R}^n$ 的仿射包，记为 $\\mathrm{aff}(S)$，是包含 $S$ 的最小仿射集。主成分分析（PCA）指的是识别能够捕获中心化数据最大方差的正交方向，这些方向可以从中心化数据矩阵的奇异值分解中获得。欧几里得范数是由 $\\mathbb{R}^n$ 上的标准内积导出的范数。\n\n实现一个程序，对每个测试用例执行以下操作：\n- 设样本点为 $\\{x_i\\}_{i=1}^m \\subset \\mathbb{R}^n$，查询点为 $y \\in \\mathbb{R}^n$。计算样本点的经验中心 $x_c$，然后计算中心化数据矩阵，其行向量为 $x_i - x_c$。\n- 对中心化数据矩阵应用主成分分析（PCA），通过奇异值分解来确定样本点仿射包方向子空间的一个正交基。使用严格大于某个数值阈值的奇异值数量来确定仿射维数。该阈值必须相对于最大奇异值来定义，以确保尺度不变性。\n- 设 $V_r$ 是由PCA确定的方向子空间的一个正交基。计算 $y$ 到仿射包的欧几里得距离，其定义为当 $y - x_c$ 正交投影到主方向张成的空间上时，残差的欧几里得范数。\n\n你的程序必须为每个测试用例输出一个结果。对每个测试用例，输出一个包含两个元素的列表 $[d,\\ \\delta]$，其中 $d$ 是 $\\mathrm{aff}(\\{x_i\\})$ 的整数仿射维数，$\\delta$ 是从 $y$ 到 $\\mathrm{aff}(\\{x_i\\})$ 的欧几里得距离，表示为四舍五入到六位小数的浮点数。将所有测试用例的结果汇总到一行输出中，该行包含一个用方括号括起来的逗号分隔列表，例如 $\\left[\\left[d_1,\\ \\delta_1\\right],\\left[d_2,\\ \\delta_2\\right],\\dots\\right]$。\n\n使用以下测试套件。每个测试指定了环境维数 $n$、样本点列表 $\\{x_i\\}$ 和查询点 $y$。\n\n- 测试用例1：环境维数 $n = 2$。样本点 $x_1 = \\left(0, 1\\right)$, $x_2 = \\left(1, 3\\right)$, $x_3 = \\left(2, 5\\right)$, $x_4 = \\left(3, 7\\right)$。查询点 $y = \\left(4, 9\\right)$。\n- 测试用例2：环境维数 $n = 3$。样本点 $x_1 = \\left(0, 0, 0\\right)$, $x_2 = \\left(1, 0, 1\\right)$, $x_3 = \\left(0, 1, 2\\right)$, $x_4 = \\left(2, -1, 0\\right)$。查询点 $y = \\left(1, 1, 3\\right)$。\n- 测试用例3：环境维数 $n = 4$。样本点 $x_1 = \\left(1, 1, 1, 1\\right)$, $x_2 = \\left(1, 1, 1, 1\\right)$, $x_3 = \\left(1, 1, 1, 1\\right)$, $x_4 = \\left(1, 1, 1, 1\\right)$。查询点 $y = \\left(0, 0, 0, 0\\right)$。\n- 测试用例4：环境维数 $n = 3$。样本点 $x_1 = \\left(0, 0, 0\\right)$, $x_2 = \\left(1, 0, 0\\right)$, $x_3 = \\left(0, 1, 0\\right)$。查询点 $y = \\left(0, 0, 1\\right)$。\n- 测试用例5：环境维数 $n = 3$。样本点 $x_1 = \\left(1, 2, 3\\right)$, $x_2 = \\left(2, 4, 6\\right)$, $x_3 = \\left(3, 6, 9\\right)$。查询点 $y = \\left(1, 0, 0\\right)$。\n\n需强制执行的数值细节：\n- 将奇异值的数值阈值定义为最大奇异值的 $10^{-10}$ 倍（如果最大奇异值为零，则仿射维数为 $0$）。\n- 使用欧几里得距离（不涉及物理单位）。报告 $\\delta$ 时四舍五入到六位小数。\n\n最终输出格式：\n- 你的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，其中每个内部结果是一个包含两个元素的列表 $\\left[d,\\ \\delta\\right]$，$\\delta$ 四舍五入到六位小数。例如 $\\left[\\left[d_1,\\ \\delta_1\\right],\\left[d_2,\\ \\delta_2\\right],\\left[d_3,\\ \\delta_3\\right]\\right]$。", "solution": "我们从欧几里得空间 $\\mathbb{R}^n$ 中的基本定义开始。仿射集是线性子空间的任意平移。对于一个有限集 $S = \\{x_i\\}_{i=1}^m \\subset \\mathbb{R}^n$，其仿射包 $\\mathrm{aff}(S)$ 是包含 $S$ 的最小仿射集。一个经典的刻画是，对于任意固定的 $x_c \\in \\mathbb{R}^n$（例如，经验均值），$\\mathrm{aff}(S)$ 等于 $x_c + \\mathrm{span}\\{x_i - x_c : i = 1,\\dots,m\\}$。这是因为仿射包中的任何点都可以写成这些点的仿射组合，而相对于一个固定中心的差向量则生成了其方向子空间。\n\n为了通过算法识别方向子空间，我们使用主成分分析（PCA）。主成分分析（PCA）提供了能够捕获中心化数据方差的正交方向。形式上，构建中心化数据矩阵 $Z \\in \\mathbb{R}^{m \\times n}$，其第 $i$ 行为 $(x_i - x_c)^\\top$。计算其奇异值分解 $Z = U \\Sigma V^\\top$，其中 $U \\in \\mathbb{R}^{m \\times m}$，$\\Sigma \\in \\mathbb{R}^{m \\times n}$ 的对角线元素为非负值（即奇异值），$V \\in \\mathbb{R}^{n \\times n}$ 是正交矩阵。与严格正奇异值相关联的右奇异向量（$V$ 的列）张成了 $Z^\\top$ 的列空间，这恰好是 $\\mathrm{span}\\{x_i - x_c\\}$。因此，$\\mathrm{aff}(S)$ 的方向子空间由 $V$ 中对应于数值上被视为非零的奇异值的列向量子集张成。如果我们用 $r$ 表示严格大于阈值 $\\tau$ 的奇异值的数量，那么仿射维数就是 $r$，方向子空间的一个正交基由 $V_r \\in \\mathbb{R}^{n \\times r}$ 给出，该矩阵由 $V$ 的前 $r$ 列组成。\n\n为了计算查询点 $y \\in \\mathbb{R}^n$ 到仿射包的距离，我们注意到 $\\mathrm{aff}(S) = x_c + \\mathrm{span}(V_r)$，其中 $V_r$ 的列是正交的。考虑向量 $v = y - x_c \\in \\mathbb{R}^n$。$v$ 在 $\\mathrm{span}(V_r)$ 上的正交投影是 $V_r (V_r^\\top v)$，因为当列是正交的时，$V_r^\\top V_r = I_r$。因此，$y$ 在仿射包上的投影是 $x_c + V_r (V_r^\\top (y - x_c))$。与仿射包正交的残差向量是\n$$\nr_{\\perp} = (y - x_c) - V_r (V_r^\\top (y - x_c)),\n$$\n从 $y$ 到 $\\mathrm{aff}(S)$ 的欧几里得距离是 $\\|r_{\\perp}\\|_2$。在 $r = 0$（所有奇异值均为零）的特殊情况下，方向子空间是平凡的，$\\mathrm{aff}(S)$ 简化为单点 $\\{x_c\\}$；距离变为 $\\|y - x_c\\|_2$。\n\n数值秩的确定需要一个阈值来判断哪些奇异值实际上非零。为了保证尺度不变性，我们将阈值设置为\n$$\n\\tau = 10^{-10} \\cdot \\sigma_{\\max},\n$$\n其中 $\\sigma_{\\max}$ 是最大的奇异值。如果 $\\sigma_{\\max} = 0$，那么根据定义所有奇异值都为零，仿射维数为 $0$。\n\n每个测试用例的算法步骤：\n- 构建样本矩阵 $X \\in \\mathbb{R}^{m \\times n}$，计算 $x_c = \\frac{1}{m} \\sum_{i=1}^m x_i$，并构建行向量为 $x_i - x_c$ 的中心化矩阵 $Z$。\n- 使用奇异值分解计算 $U, \\Sigma, V^\\top = \\mathrm{svd}(Z)$；提取奇异值 $\\sigma_1 \\ge \\sigma_2 \\ge \\cdots$。\n- 如果 $\\sigma_{\\max} > 0$，定义 $\\tau = 10^{-10} \\cdot \\sigma_{\\max}$，否则将仿射维数设为 $0$。\n- 令 $r$ 为满足 $\\sigma_j > \\tau$ 的 $\\sigma_j$ 的数量。通过取前 $r$ 个右奇异向量来构成 $V_r$。\n- 计算 $v = y - x_c$，如果 $r > 0$，则残差 $r_{\\perp} = v - V_r(V_r^\\top v)$，否则 $r_{\\perp} = v$。\n- 距离为 $\\delta = \\|r_{\\perp}\\|_2$。\n- 输出 $[r,\\ \\delta]$，其中 $\\delta$ 四舍五入到六位小数。\n\n现在考虑提供的测试套件：\n- 测试用例1在 $\\mathbb{R}^2$ 中，点位于一条仿射直线上，查询点也在同一条线上；仿射维数应为 $1$，距离应为 $0$。\n- 测试用例2在 $\\mathbb{R}^3$ 中，点位于由 $z = x + 2y$ 描述的平面上，查询点也在该平面上；仿射维数应为 $2$，距离应为 $0$。\n- 测试用例3在 $\\mathbb{R}^4$ 中重复同一点，使得仿射包为一个单点；仿射维数应为 $0$，距离等于查询点到 $x_c$ 的欧几里得范数，即 $\\sqrt{4} = 2$。\n- 测试用例4将点放置在 $\\mathbb{R}^3$ 中的平面 $z = 0$ 上，查询点的 $z$ 坐标为 $1$；仿射维数应为 $2$，距离应为 $1$。\n- 测试用例5将点放置在 $\\mathbb{R}^3$ 中方向为 $\\left(1, 2, 3\\right)$ 的直线上，查询点不在此线上；仿射维数应为 $1$，计算出的距离将是一个由上述正交投影公式确定的正值。\n\n该程序实现了这些步骤，并打印一行包含列表 $\\left[\\left[d_1,\\ \\delta_1\\right],\\left[d_2,\\ \\delta_2\\right],\\left[d_3,\\ \\delta_3\\right],\\left[d_4,\\ \\delta_4\\right],\\left[d_5,\\ \\delta_5\\right]\\right]$ 的内容，其中每个 $\\delta_i$ 都四舍五入到六位小数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef affine_hull_pca_dimension_and_distance(points: np.ndarray, query: np.ndarray) -> tuple[int, float]:\n    \"\"\"\n    Compute the affine hull dimension via PCA and the Euclidean distance\n    from the query point to the affine hull.\n    \"\"\"\n    # Compute empirical center\n    xc = np.mean(points, axis=0)\n\n    # Center the data\n    Z = points - xc  # shape (m, n)\n\n    # SVD of the centered data matrix\n    # full_matrices=False ensures compact SVD with shapes:\n    # U: (m, min(m, n)), s: (min(m, n),), Vt: (min(m, n), n)\n    U, s, Vt = np.linalg.svd(Z, full_matrices=False)\n\n    # Numerical threshold relative to the largest singular value\n    if s.size == 0:\n        # No data cases, but with given tests m >= 1; handle gracefully\n        r = 0\n        Vr = np.zeros((points.shape[1], 0))\n    else:\n        s_max = s[0] if s.size > 0 else 0.0\n        if s_max > 0.0:\n            tau = 1e-10 * s_max\n            r = int(np.sum(s > tau))\n        else:\n            r = 0\n        # Basis of direction subspace from right singular vectors\n        Vr = Vt[:r, :].T if r > 0 else np.zeros((points.shape[1], 0))\n\n    # Distance from query to affine hull\n    v = query - xc\n    if r > 0:\n        # Orthogonal projection residual\n        # residual = v - Vr @ (Vr.T @ v)\n        proj_coeffs = Vr.T @ v\n        residual = v - (Vr @ proj_coeffs)\n    else:\n        residual = v\n    distance = float(np.linalg.norm(residual))\n\n    return r, distance\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case is a tuple: (points_array, query_point)\n    test_cases = [\n        # Test Case 1: R^2, points on a line, query on the line\n        (np.array([[0.0, 1.0],\n                   [1.0, 3.0],\n                   [2.0, 5.0],\n                   [3.0, 7.0]]),\n         np.array([4.0, 9.0])),\n        # Test Case 2: R^3, points on a plane z = x + 2y, query on the plane\n        (np.array([[0.0, 0.0, 0.0],\n                   [1.0, 0.0, 1.0],\n                   [0.0, 1.0, 2.0],\n                   [2.0, -1.0, 0.0]]),\n         np.array([1.0, 1.0, 3.0])),\n        # Test Case 3: R^4, identical points (affine hull is a single point)\n        (np.array([[1.0, 1.0, 1.0, 1.0],\n                   [1.0, 1.0, 1.0, 1.0],\n                   [1.0, 1.0, 1.0, 1.0],\n                   [1.0, 1.0, 1.0, 1.0]]),\n         np.array([0.0, 0.0, 0.0, 0.0])),\n        # Test Case 4: R^3, points on plane z=0, query with z=1\n        (np.array([[0.0, 0.0, 0.0],\n                   [1.0, 0.0, 0.0],\n                   [0.0, 1.0, 0.0]]),\n         np.array([0.0, 0.0, 1.0])),\n        # Test Case 5: R^3, points on a line direction (1,2,3), query off the line\n        (np.array([[1.0, 2.0, 3.0],\n                   [2.0, 4.0, 6.0],\n                   [3.0, 6.0, 9.0]]),\n         np.array([1.0, 0.0, 0.0])),\n    ]\n\n    results_str = []\n    for points, query in test_cases:\n        dim, dist = affine_hull_pca_dimension_and_distance(points, query)\n        # Format distance to six decimal places, ensure exact required format\n        results_str.append(f\"[{dim},{format(dist, '.6f')}]\")\n\n    # Final print statement in the exact required format: single line\n    print(f\"[[{','.join(results_str)}]]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3096329"}]}