{"hands_on_practices": [{"introduction": "要应用一个数学概念，第一步是学会如何识别它。本练习提供了一个具体的机会，将自协调性的数学定义应用于机器学习中一个著名的函数——Huber损失函数。通过计算其各阶导数，我们将直接检验它是否满足关键的不等式 $|h'''(t)| \\le \\nu(h''(t))^{3/2}$，从而为一个看似抽象的理论提供一个清晰且易于上手的切入点。[@problem_id:3176704]", "problem": "设参数为 $\\delta0$ 的 Huber 损失函数对 $t\\in\\mathbb{R}$ 定义为\n$$\nh(t)=\\begin{cases}\n\\frac{1}{2}\\,t^{2},   \\text{若 } |t|\\le \\delta,\\\\\n\\delta\\left(|t|-\\frac{\\delta}{2}\\right),   \\text{若 } |t|\\delta.\n\\end{cases}\n$$\n在凸优化的一维自协调框架内。从 $h(t)$ 的定义和微分法则出发，完成以下任务：\n1) 在 $\\mathbb{R}$ 的每个光滑区域上，计算存在导数的 $h''(t)$ 和 $h'''(t)$。\n2) 考虑集合 $S=\\{t\\in\\mathbb{R}:\\, h''(t)0\\}$。使用一维自协调比较 $|h'''(t)|$ 与 $(h''(t))^{3/2}$，确定最小的常数 $\\nu\\ge 0$ 使得\n$$\n|h'''(t)|\\le \\nu(h''(t))^{3/2}\\quad\\text{对所有 }t\\in S.\n$$\n给出 $\\nu$ 的精确值作为你的最终答案。不需要四舍五入。你可以在推导中包含任何关于自协调的定性评论，但你的最终答案必须是一个实数。", "solution": "问题要求我们分析 Huber 损失函数 $h(t)$ 的一维自协调性，该函数对参数 $\\delta  0$ 和 $t \\in \\mathbb{R}$ 定义如下\n$$\nh(t)=\\begin{cases}\n\\frac{1}{2}\\,t^{2},  \\text{若 } |t|\\le \\delta \\\\\n\\delta\\left(|t|-\\frac{\\delta}{2}\\right),  \\text{若 } |t|\\delta\n\\end{cases}\n$$\n为了方便求导，我们可以将 $h(t)$ 在三个不同的区间上明确写出：\n$$\nh(t) = \\begin{cases}\n-\\delta t - \\frac{\\delta^2}{2},  \\text{对于 } t  -\\delta \\\\\n\\frac{1}{2} t^2,  \\text{对于 } -\\delta \\le t \\le \\delta \\\\\n\\delta t - \\frac{\\delta^2}{2},  \\text{对于 } t  \\delta\n\\end{cases}\n$$\n\n第一步是在函数光滑的区域上计算 $h(t)$ 的一阶、二阶和三阶导数。\n\n一阶导数 $h'(t)$ 通过对每一部分求导得到：\n$$\nh'(t) = \\begin{cases}\n-\\delta,  \\text{对于 } t  -\\delta \\\\\nt,  \\text{对于 } -\\delta  t  \\delta \\\\\n\\delta,  \\text{对于 } t  \\delta\n\\end{cases}\n$$\n我们必须检查在点 $t = -\\delta$ 和 $t = \\delta$ 处的连续性。\n在 $t = \\delta$ 处：\n左极限是 $\\lim_{t \\to \\delta^-} h'(t) = \\lim_{t \\to \\delta^-} t = \\delta$。\n右极限是 $\\lim_{t \\to \\delta^+} h'(t) = \\lim_{t \\to \\delta^+} \\delta = \\delta$。\n由于极限相等，$h'(t)$ 在 $t = \\delta$ 处是连续的。\n\n在 $t = -\\delta$ 处：\n左极限是 $\\lim_{t \\to -\\delta^-} h'(t) = \\lim_{t \\to -\\delta^-} (-\\delta) = -\\delta$。\n右极限是 $\\lim_{t \\to -\\delta^+} h'(t) = \\lim_{t \\to -\\delta^+} t = -\\delta$。\n由于极限相等，$h'(t)$ 在 $t = -\\delta$ 处是连续的。\n因此，$h(t)$ 是在 $\\mathbb{R}$ 上的一个连续可微函数（$C^1$ 函数）。\n\n二阶导数 $h''(t)$ 是 $h'(t)$ 的导数，定义在开区间 $(-\\infty, -\\delta)$、$(-\\delta, \\delta)$ 和 $(\\delta, \\infty)$ 上：\n$$\nh''(t) = \\begin{cases}\n\\frac{d}{dt}(-\\delta) = 0,  \\text{对于 } t \\in (-\\infty, -\\delta) \\\\\n\\frac{d}{dt}(t) = 1,  \\text{对于 } t \\in (-\\delta, \\delta) \\\\\n\\frac{d}{dt}(\\delta) = 0,  \\text{对于 } t \\in (\\delta, \\infty)\n\\end{cases}\n$$\n所以，$h''(t)$ 是一个分段常数函数。注意，由于跳跃不连续性，$h''(t)$ 在 $t = \\pm\\delta$ 处没有定义。\n\n三阶导数 $h'''(t)$ 是 $h''(t)$ 的导数，定义在相同的开区间上：\n$$\nh'''(t) = \\begin{cases}\n\\frac{d}{dt}(0) = 0,  \\text{对于 } t \\in (-\\infty, -\\delta) \\\\\n\\frac{d}{dt}(1) = 0,  \\text{对于 } t \\in (-\\delta, \\delta) \\\\\n\\frac{d}{dt}(0) = 0,  \\text{对于 } t \\in (\\delta, \\infty)\n\\end{cases}\n$$\n因此，对所有 $t \\in \\mathbb{R} \\setminus \\{-\\delta, \\delta\\}$，$h'''(t) = 0$。这完成了问题的第一部分。\n\n接下来，我们考虑集合 $S = \\{t \\in \\mathbb{R} : h''(t)  0\\}$。从我们对 $h''(t)$ 的表达式中，我们看到 $h''(t) = 1  0$ 当且仅当 $t \\in (-\\delta, \\delta)$。因此，集合 $S$ 是开区间 $(-\\delta, \\delta)$。\n\n问题的最后一部分是确定最小的常数 $\\nu \\ge 0$，使得不等式\n$$\n|h'''(t)| \\le \\nu (h''(t))^{3/2}\n$$\n对所有 $t \\in S$ 成立。最小的 $\\nu$ 由右侧比率在集合 $S$ 上的上确界给出：\n$$\n\\nu = \\sup_{t \\in S} \\frac{|h'''(t)|}{(h''(t))^{3/2}}\n$$\n我们对 $t \\in S = (-\\delta, \\delta)$ 计算这个表达式。对于此区间内的任何 $t$，我们有：\n$h''(t) = 1$\n$h'''(t) = 0$\n\n将这些值代入比率中得到：\n$$\n\\frac{|h'''(t)|}{(h''(t))^{3/2}} = \\frac{|0|}{(1)^{3/2}} = \\frac{0}{1} = 0\n$$\n对于每个 $t \\in S$，这个比率都恰好是 $0$。一个只包含值 $0$ 的集合的上确界是 $0$。\n因此，最小的常数 $\\nu$ 是 $0$。\n\n这个结果与自协调函数的理论是一致的。一个函数如果在某个区间上的自协调参数 $\\nu$ 为 $0$，那么它在该区间上的三阶导数必须恒为零。这是二次函数的特征。Huber 损失函数 $h(t)$ 在指定的定义域 $S = (-\\delta, \\delta)$ 上确实是一个二次函数，$h(t) = \\frac{1}{2}t^2$。", "answer": "$$\n\\boxed{0}\n$$", "id": "3176704"}, {"introduction": "在学会验证一个性质后，更深入的理解来自于探索其边界。本练习旨在探究自协调性是否在常见的函数变换（例如指数变换）下得以保持。通过分析这个反例，你将洞察到自协调函数所需的精细数学结构，并理解为何它并非一个普遍保持的性质。[@problem_id:3176742]", "problem": "考虑一个在 $\\mathbb{R}$ 的一个开区间上定义的三次连续可微的凸函数 $f$。在一维情况下，如果一个函数在其定义域内的所有 $x$ 上都满足不等式 $\\lvert f^{\\prime\\prime\\prime}(x)\\rvert \\leq 2(f^{\\prime\\prime}(x))^{3/2}$，则称该函数是自协调的（self-concordant）。定义 $g(x) = \\exp(f(x))$。仅使用自协调的定义、链式法则和标准微积分，分析当 $f$ 是自协调函数时，$g$ 是否也可能是自协调的。作为一个测试案例，取定义在 $(0,\\infty)$ 上的 $f(t) = -\\log t$，这是一个标准的自协调障碍函数，并计算 $g(t) = \\exp(f(t))$ 是否在 $(0,\\infty)$ 上满足自协调不等式。根据您的推导，选择所有正确的陈述。\n\n选项：\nA. 如果 $f$ 在其定义域上是自协调的，那么 $g(x)=\\exp(f(x))$ 在相同的定义域上也是自协调的，且参数相同。\n\nB. 对于在 $(0,\\infty)$ 上的 $f(t) = -\\log t$，$g(t) = \\exp(f(t))$ 对每个 $t0$ 都违反了自协调不等式。\n\nC. 对于 $f(t) = -\\log t$，函数 $g(t) = \\exp(f(t)) = 1/t$ 在某些 $t0$ 处不满足自协调不等式，这表明即使 $f$ 是自协调的，$\\exp(f)$ 也未必是自协调的。\n\nD. 存在一个常数 $\\alpha0$，使得对于 $f(t) = -\\log t$，函数 $g_\\alpha(t) = \\exp(\\alpha f(t))$ 在 $(0,\\infty)$ 上是自协调的。\n\nE. $\\exp(f)$ 的失效模式之所以出现，是因为涉及 $f^{\\prime}(x)$ 的项（例如 $g^{\\prime\\prime\\prime}$ 中的 $(f^{\\prime}(x))^{3}$）不受仅对 $f^{\\prime\\prime\\prime}$ 的自协调界限的控制，因此即使 $f$ 是自协调的，该不等式也可能不成立。", "solution": "问题要求分析函数 $g(x) = \\exp(f(x))$ 的自协调性质，已知 $f(x)$ 是在 $\\mathbb{R}$ 的一个开区间上的自协调函数。\n\n### 步骤 1：问题验证\n\n**1.1. 提取已知条件**\n- $f$ 是一个三次连续可微的凸函数。\n- $f$ 的定义域是 $\\mathbb{R}$ 中的一个开区间。\n- 一维函数 $f$ 是自协调的条件是，在其定义域中的所有 $x$ 都满足 $\\lvert f^{\\prime\\prime\\prime}(x)\\rvert \\leq 2(f^{\\prime\\prime}(x))^{3/2}$。\n- 定义了一个新函数 $g(x) = \\exp(f(x))$。\n- 提供了一个测试案例：$f(t) = -\\log t$，定义域为 $(0,\\infty)$。\n- 分析必须只使用自协调的定义、链式法则和标准微积分。\n\n**1.2. 使用提取的已知条件进行验证**\n- **科学性：** 该问题基于单变量函数自协调的标准定义，这是凸优化中内点法理论的一个关键概念。所有的数学对象和运算都是明确定义的。\n- **适定性：** 问题陈述清晰，要求对一个数学性质进行严格分析。测试案例为研究提供了一条具体的路径。可以得出明确的结论。$f$ 是凸函数的条件意味着 $f''(x) \\ge 0$，这确保了项 $(f^{\\prime\\prime}(x))^{3/2}$ 是实数值。\n- **客观性：** 问题使用精确、客观的数学语言陈述，没有歧义或主观论断。\n\n**1.3. 结论与行动**\n问题陈述是有效的。它具有科学性、适定性和客观性。我将继续进行全面分析。\n\n### 步骤 2：对 $g(x) = \\exp(f(x))$ 的一般性分析\n\n要确定 $g(x)$ 是否是自协调的，我们必须计算它的前三阶导数，并检查它们是否满足自协调不等式 $\\lvert g^{\\prime\\prime\\prime}(x)\\rvert \\leq 2(g^{\\prime\\prime}(x))^{3/2}$。\n\n使用链式法则，我们计算 $g(x) = \\exp(f(x))$ 的导数：\n$g^{\\prime}(x) = f^{\\prime}(x) \\exp(f(x))$\n$g^{\\prime\\prime}(x) = f^{\\prime\\prime}(x) \\exp(f(x)) + f^{\\prime}(x) \\cdot (f^{\\prime}(x) \\exp(f(x))) = (f^{\\prime\\prime}(x) + (f^{\\prime}(x))^2) \\exp(f(x))$\n为了使 $g(x)$ 成为自协调函数的候选者，它必须是凸函数，即 $g^{\\prime\\prime}(x) \\ge 0$。由于 $\\exp(f(x))  0$，这要求 $f^{\\prime\\prime}(x) + (f^{\\prime}(x))^2 \\ge 0$。因为 $f$ 是凸函数，$f^{\\prime\\prime}(x) \\ge 0$，所以这个条件成立。\n\n三阶导数是：\n$g^{\\prime\\prime\\prime}(x) = (f^{\\prime\\prime\\prime}(x) + 2f^{\\prime}(x)f^{\\prime\\prime}(x)) \\exp(f(x)) + (f^{\\prime\\prime}(x) + (f^{\\prime}(x))^2) \\cdot (f^{\\prime}(x) \\exp(f(x)))$\n$g^{\\prime\\prime\\prime}(x) = (f^{\\prime\\prime\\prime}(x) + 2f^{\\prime}(x)f^{\\prime\\prime}(x) + f^{\\prime}(x)f^{\\prime\\prime}(x) + (f^{\\prime}(x))^3) \\exp(f(x))$\n$g^{\\prime\\prime\\prime}(x) = ((f^{\\prime}(x))^3 + 3f^{\\prime}(x)f^{\\prime\\prime}(x) + f^{\\prime\\prime\\prime}(x)) \\exp(f(x))$\n\n$g(x)$ 的自协调不等式是：\n$$\n\\lvert g^{\\prime\\prime\\prime}(x) \\rvert \\le 2( g^{\\prime\\prime}(x) )^{3/2}\n$$\n代入我们推导出的表达式：\n$$\n\\left\\lvert ((f^{\\prime}(x))^3 + 3f^{\\prime}(x)f^{\\prime\\prime}(x) + f^{\\prime\\prime\\prime}(x)) \\exp(f(x)) \\right\\rvert \\le 2 [ (f^{\\prime\\prime}(x) + (f^{\\prime}(x))^2) \\exp(f(x)) ]^{3/2}\n$$\n由于 $\\exp(f(x))  0$：\n$$\n\\exp(f(x)) \\left\\lvert (f^{\\prime}(x))^3 + 3f^{\\prime}(x)f^{\\prime\\prime}(x) + f^{\\prime\\prime\\prime}(x) \\right\\rvert \\le 2 (f^{\\prime\\prime}(x) + (f^{\\prime}(x))^2)^{3/2} (\\exp(f(x)))^{3/2}\n$$\n两边同除以 $\\exp(f(x))$：\n$$\n\\left\\lvert (f^{\\prime}(x))^3 + 3f^{\\prime}(x)f^{\\prime\\prime}(x) + f^{\\prime\\prime\\prime}(x) \\right\\rvert \\le 2 (f^{\\prime\\prime}(x) + (f^{\\prime}(x))^2)^{3/2} (\\exp(f(x)))^{1/2}\n$$\n$f$ 的自协调性质给了我们 $\\lvert f^{\\prime\\prime\\prime}(x)\\rvert \\le 2(f^{\\prime\\prime}(x))^{3/2}$。然而，$g(x)$ 的不等式包含了涉及 $f(x)$ 和 $f^{\\prime}(x)$ 的项，这些项不能被 $f$ 的自协调性质直接界定。这表明该性质可能不会被保持。\n\n### 步骤 3：分析测试案例 $f(t) = -\\log t$\n\n我们来测试定义在 $(0, \\infty)$ 上的特定函数 $f(t) = -\\log t$。\n首先，我们验证 $f(t)$ 是自协调的。\n$f^{\\prime}(t) = -t^{-1}$\n$f^{\\prime\\prime}(t) = t^{-2}$\n$f^{\\prime\\prime\\prime}(t) = -2t^{-3}$\n由于 $f^{\\prime\\prime}(t) = 1/t^2  0$ 对所有 $t \\in (0, \\infty)$ 成立，其凸性得到确认。\n$f(t)$ 的自协调不等式是：\n$\\lvert f^{\\prime\\prime\\prime}(t) \\rvert \\le 2(f^{\\prime\\prime}(t))^{3/2} \\implies \\lvert -2t^{-3} \\rvert \\le 2(t^{-2})^{3/2} \\implies 2t^{-3} \\le 2t^{-3}$。\n等式成立，所以 $f(t) = -\\log t$ 是自协调的。\n\n现在，我们分析 $g(t) = \\exp(f(t)) = \\exp(-\\log t) = 1/t = t^{-1}$。\n我们检查 $g(t)$ 是否是自协调的。\n$g^{\\prime}(t) = -t^{-2}$\n$g^{\\prime\\prime}(t) = 2t^{-3}$\n$g^{\\prime\\prime\\prime}(t) = -6t^{-4}$\n由于 $g^{\\prime\\prime}(t) = 2/t^3  0$ 对所有 $t \\in (0, \\infty)$ 成立，$g(t)$ 的凸性得到确认。\n$g(t)$ 的自协调不等式是：\n$\\lvert g^{\\prime\\prime\\prime}(t) \\rvert \\le 2(g^{\\prime\\prime}(t))^{3/2} \\implies \\lvert -6t^{-4} \\rvert \\le 2(2t^{-3})^{3/2}$\n$6t^{-4} \\le 2 \\cdot 2^{3/2} \\cdot (t^{-3})^{3/2}$\n$6t^{-4} \\le 2 \\cdot 2\\sqrt{2} \\cdot t^{-9/2}$\n$6t^{-4} \\le 4\\sqrt{2} t^{-4.5}$\n为了简化，我们将两边同乘以 $t^{4.5}$（对于 $t0$ 它是正数）：\n$6t^{0.5} \\le 4\\sqrt{2}$\n$3\\sqrt{t} \\le 2\\sqrt{2}$\n$\\sqrt{t} \\le \\frac{2\\sqrt{2}}{3}$\n两边平方得：\n$t \\le \\left(\\frac{2\\sqrt{2}}{3}\\right)^2 = \\frac{8}{9}$\n要使 $g(t)$ 在其整个定义域 $(0, \\infty)$ 上是自协调的，这个不等式必须对所有 $t \\in (0, \\infty)$ 都成立。这是错误的。对于任何 $t  8/9$（例如，$t=1$），该不等式被违反。因此，$g(t)=1/t$ 在 $(0, \\infty)$ 上不是自协调的。\n\n### 步骤 4：逐项分析选项\n\n**A. 如果 $f$ 在其定义域上是自协调的，那么 $g(x)=\\exp(f(x))$ 在相同的定义域上也是自协调的，且参数相同。**\n我们的测试案例提供了一个直接的反例。$f(t) = -\\log t$ 是自协调的，但 $g(t) = \\exp(f(t)) = 1/t$ 不是。\n**结论：不正确。**\n\n**B. 对于在 $(0,\\infty)$ 上的 $f(t) = -\\log t$，$g(t) = \\exp(f(t))$ 对每个 $t0$ 都违反了自协调不等式。**\n我们的分析表明，不等式仅在 $t  8/9$ 时被违反。对于 $t \\in (0, 8/9]$，不等式是成立的。声称它对*每个* $t  0$ 都失败是错误的。\n**结论：不正确。**\n\n**C. 对于 $f(t) = -\\log t$，函数 $g(t) = \\exp(f(t)) = 1/t$ 在某些 $t0$ 处不满足自协调不等式，这表明即使 $f$ 是自协调的，$\\exp(f)$ 也未必是自协调的。**\n我们的分析表明，对于任何 $t  8/9$，不等式都不成立。这个失效区域的存在证明了 $g(t)=1/t$ 在 $(0, \\infty)$ 上不是自协调的。这可以作为 $\\exp(f)$ 保持自协调性这一一般命题的一个有效反例。该陈述完全正确。\n**结论：正确。**\n\n**D. 存在一个常数 $\\alpha0$，使得对于 $f(t) = -\\log t$，函数 $g_\\alpha(t) = \\exp(\\alpha f(t))$ 在 $(0,\\infty)$ 上是自协调的。**\n令 $h(t) = g_\\alpha(t) = \\exp(\\alpha(-\\log t)) = (t^{\\alpha})^{-1} = t^{-\\alpha}$，其中 $\\alpha  0$。\n$h^{\\prime}(t) = -\\alpha t^{-\\alpha-1}$\n$h^{\\prime\\prime}(t) = \\alpha(\\alpha+1)t^{-\\alpha-2}$\n$h^{\\prime\\prime\\prime}(t) = -\\alpha(\\alpha+1)(\\alpha+2)t^{-\\alpha-3}$\n自协调不等式为 $\\lvert h^{\\prime\\prime\\prime}(t) \\rvert \\le 2(h^{\\prime\\prime}(t))^{3/2}$。\n$\\alpha(\\alpha+1)(\\alpha+2)t^{-\\alpha-3} \\le 2(\\alpha(\\alpha+1)t^{-\\alpha-2})^{3/2}$\n$\\alpha(\\alpha+1)(\\alpha+2)t^{-\\alpha-3} \\le 2(\\alpha(\\alpha+1))^{3/2} t^{-3(\\alpha+2)/2}$\n$\\alpha(\\alpha+1)(\\alpha+2)t^{-\\alpha-3} \\le 2(\\alpha(\\alpha+1))^{3/2} t^{-1.5\\alpha - 3}$\n我们来分析比率 $\\kappa(t) = \\frac{\\lvert h^{\\prime\\prime\\prime}(t) \\rvert}{(h^{\\prime\\prime}(t))^{3/2}} = \\frac{\\alpha(\\alpha+1)(\\alpha+2)t^{-\\alpha-3}}{(\\alpha(\\alpha+1))^{3/2} t^{-1.5\\alpha - 3}} = \\frac{\\alpha(\\alpha+1)(\\alpha+2)}{(\\alpha(\\alpha+1))^{3/2}} t^{0.5\\alpha}$。\n为了满足自协调性，必须对所有 $t  0$ 都有 $\\kappa(t) \\le 2$。然而，由于 $\\alpha  0$，指数 $0.5\\alpha$ 是正的。因此，$\\kappa(t)$ 是一个关于 $t$ 的增函数，当 $t \\to \\infty$ 时，它无界增长。它在整个定义域 $(0,\\infty)$ 上不可能被 $2$ 界定。因此，不存在这样的 $\\alpha  0$。\n**结论：不正确。**\n\n**E. $\\exp(f)$ 的失效模式之所以出现，是因为涉及 $f^{\\prime}(x)$ 的项（例如 $g^{\\prime\\prime\\prime}$ 中的 $(f^{\\prime}(x))^{3}$）不受仅对 $f^{\\prime\\prime\\prime}$ 的自协调界限的控制，因此即使 $f$ 是自协调的，该不等式也可能不成立。**\n该陈述正确地指出了潜在失效的结构性原因。$g'''(x)$ 的表达式是 $((f^{\\prime}(x))^3 + 3f^{\\prime}(x)f^{\\prime\\prime}(x) + f^{\\prime\\prime\\prime}(x)) \\exp(f(x))$。$f$ 的自协调条件使用 $f''(x)$ 来界定 $\\lvert f'''(x) \\rvert$，但它没有对 $f(x)$ 或 $f'(x)$ 提供任何控制。新出现的项，特别是 $(f'(x))^3$，不受前提条件的限制。虽然在某些情况下这些项可能不会导致不等式失效，但它们的存在意味着失效是可能的，正如测试案例所证明的那样。这准确地描述了为什么自协调性在这种变换下不被保持的数学原因。\n**结论：正确。**", "answer": "$$\\boxed{CE}$$", "id": "3176742"}, {"introduction": "自协调性的真正价值在于其对算法的意义，特别是它为牛顿法的性能提供了保证。这个编程练习将理论付诸实践，要求你推导并用实验验证优化过程中函数值的保证下降量。通过对比自协调函数与非自协调函数的表现，你将亲眼见证该性质所带来的稳定性和可预测性。[@problem_id:3176724]", "problem": "考虑以下将牛顿法应用于两个凸函数的比较，其中一个函数是自协调的，而另一个不是。设 $x \\in \\mathbb{R}^n$，定义牛顿步长方向为 $p(x) = -\\nabla^2 f(x)^{-1}\\nabla f(x)$，牛顿减量为 $\\lambda(x) = \\sqrt{\\nabla f(x)^\\top \\nabla^2 f(x)^{-1}\\nabla f(x)}$。实际的单步函数值下降量为 $\\Delta f = f(x) - f(x^+)$。在自协调分析中，存在一个仅依赖于 $\\lambda(x)$ 的规范预测函数，当使用适当的步长时，该函数为单步下降量提供了一个下界。您的任务是推导这个适当的预测函数，然后实现一个程序，以通过实验比较下面两个函数的实际单步下降量与此预测。\n\n推导的基本依据：\n- 牛顿法由方向 $p(x)$、梯度 $\\nabla f(x)$ 和海森矩阵 $\\nabla^2 f(x)$ 定义。\n- 牛顿减量 $\\lambda(x)$ 是如上定义的标量，在二阶方法中用于衡量与最优解的接近程度。\n- 对于自协调函数，阻尼牛顿步的分析提供了一个关于函数值下降量的下界，该下界是 $\\lambda(x)$ 的一个函数，且与具体函数实例无关。\n\n用于比较的函数：\n1. 正象限上的自协调障碍函数：\n   $$f_{\\text{bar}}(x) = -\\sum_{i=1}^n \\log x_i \\quad \\text{定义域为 } x_i  0。$$\n2. 非自协调的光滑凸函数：\n   $$f_{\\text{sqrt}}(x) = \\sum_{i=1}^n \\sqrt{1 + x_i^2}。$$\n\n使用的步长策略：\n- 完整牛顿步：$x^+ = x + p(x)$。\n- 由 $\\lambda(x)$ 控制的阻尼牛顿步：$x^+ = x + \\alpha(x)\\,p(x)$，其中 $\\alpha(x)$ 仅依赖于 $\\lambda(x)$。\n\n任务：\n1. 在相应的阻尼牛顿步下，推导为自协调函数的单步下降量提供下界的 $\\lambda(x)$ 的规范预测函数。\n2. 实现一个程序，对于下述每个测试用例，计算：\n   - 牛顿方向 $p(x)$，\n   - 牛顿减量 $\\lambda(x)$，\n   - 由所选策略决定的步长 $\\alpha(x)$，\n   - 新的点 $x^+$，\n   - 实际下降量 $\\Delta f = f(x) - f(x^+)$，\n   - 仅通过推导出的预测函数表示的预测下界，\n   - 比率 $r = \\Delta f$ 除以预测下界。\n3. 使用比率 $r$ 来衡量可预测性。若值 $r \\ge 1$ 则表明实际下降量达到或超过预测值，而 $r  1$ 则表明违反了该预测。\n\n测试套件：\n- 用例 A：$f_{\\text{bar}}$，$n=2$，$x = [0.8,\\,1.2]$，阻尼步。\n- 用例 B：$f_{\\text{bar}}$，$n=3$，$x = [0.2,\\,0.5,\\,2.0]$，阻尼步。\n- 用例 C：$f_{\\text{sqrt}}$，$n=2$，$x = [2.0,\\,-1.0]$，阻尼步。\n- 用例 D：$f_{\\text{sqrt}}$，$n=2$，$x = [3.0,\\,3.0]$，完整步。\n\n输出规范：\n- 您的程序应生成单行输出，其中包含四个用例的比率 $r$，按 A、B、C、D 的顺序排列，形式为用方括号括起来的逗号分隔列表（例如，$[r_A,r_B,r_C,r_D]$）。\n- 每个 $r$ 必须以浮点数形式输出。不适用任何物理单位。\n\n科学真实性：\n- 确保所有中间计算在数学上是一致的，并尊重函数定义域（对于 $f_{\\text{bar}}$，始终保持 $x_i  0$）。", "solution": "该问题要求推导在自协调函数上使用牛顿法时单步下降量的规范预测函数，并随后与一个非自协调函数进行实验性比较。\n\n### 第一部分：预测函数的推导\n\n对自协调函数的牛顿法分析提供了一个关于函数值下降量的保证下界，该下界仅依赖于牛顿减量 $\\lambda(x)$，而不依赖于具体的函数或点 $x$。\n\n一个函数 $f$ 被定义为自协调的，如果它是凸函数、$C^3$光滑，并且其三阶导数受其二阶导数约束。形式上，对于定义域中的所有 $x$ 和所有方向 $h \\in \\mathbb{R}^n$，不等式 $|D^3 f(x)[h,h,h]| \\le 2 (D^2 f(x)[h,h])^{3/2}$ 成立。此性质使得函数相对于其局部二次近似的行为具有强界。\n\n对于一个自协调函数 $f$，一个关键不等式使用在 $x$ 点的信息来约束附近点 $y$ 的函数值：\n$$f(y) \\le f(x) + \\nabla f(x)^\\top (y-x) - \\left( \\|y-x\\|_x + \\log(1 - \\|y-x\\|_x) \\right)$$\n其中 $\\|u\\|_x = \\sqrt{u^\\top \\nabla^2 f(x) u}$ 是在 $x$ 点的局部范数。此不等式对于所有满足 $\\|y-x\\|_x  1$ 的 $y$ 均成立。\n\n我们分析 $f$ 沿着牛顿方向 $p(x) = -\\nabla^2 f(x)^{-1}\\nabla f(x)$ 的变化。设新点为 $x^+ = x + \\alpha p(x)$，其中 $\\alpha \\in [0, 1)$ 是步长。从 $x$ 到 $x^+$ 的向量是 $\\alpha p(x)$。它在局部范数下的长度为：\n$$ \\|\\alpha p(x)\\|_x = \\alpha \\sqrt{p(x)^\\top \\nabla^2 f(x) p(x)} $$\n通过代入 $p(x)$ 的定义，我们发现：\n$$ p(x)^\\top \\nabla^2 f(x) p(x) = (-\\nabla^2 f(x)^{-1}\\nabla f(x))^\\top \\nabla^2 f(x) (-\\nabla^2 f(x)^{-1}\\nabla f(x)) = \\nabla f(x)^\\top \\nabla^2 f(x)^{-1} \\nabla f(x) = \\lambda(x)^2 $$\n因此，$\\|\\alpha p(x)\\|_x = \\alpha \\lambda(x)$。如果 $\\alpha \\lambda(x)  1$，则自协调不等式适用。\n\n将 $y-x = \\alpha p(x)$ 代入不等式中，得到：\n$$ f(x+\\alpha p(x)) \\le f(x) + \\alpha \\nabla f(x)^\\top p(x) - \\left( \\alpha\\lambda(x) + \\log(1 - \\alpha\\lambda(x)) \\right) $$\n我们还知道 $\\nabla f(x)^\\top p(x) = -\\lambda(x)^2$。代入此式可得 $f(x^+)$ 的一个上界：\n$$ f(x+\\alpha p(x)) \\le f(x) - \\alpha\\lambda(x)^2 - \\alpha\\lambda(x) - \\log(1 - \\alpha\\lambda(x)) $$\n此界对任何满足 $\\alpha  1/\\lambda(x)$ 的步长 $\\alpha$ 都成立。阻尼牛顿法的目标是选择 $\\alpha$ 以实现最大的保证下降量，这对应于最小化 $f(x^+)$ 的这个上界。设 $g(\\alpha)$ 是依赖于 $\\alpha$ 的项：\n$$ g(\\alpha) = -\\alpha\\lambda(x)^2 - \\alpha\\lambda(x) - \\log(1 - \\alpha\\lambda(x)) $$\n为了找到最优的 $\\alpha$，我们将 $g(\\alpha)$ 对 $\\alpha$ 求导并令其为零：\n$$ g'(\\alpha) = -\\lambda(x)^2 - \\lambda(x) - \\frac{-\\lambda(x)}{1 - \\alpha\\lambda(x)} = -\\lambda(x)^2 - \\lambda(x) + \\frac{\\lambda(x)}{1 - \\alpha\\lambda(x)} = 0 $$\n假设 $\\lambda(x)  0$，我们可以除以 $\\lambda(x)$：\n$$ -\\lambda(x) - 1 + \\frac{1}{1 - \\alpha\\lambda(x)} = 0 \\implies \\lambda(x) + 1 = \\frac{1}{1 - \\alpha\\lambda(x)} $$\n$$ 1 - \\alpha\\lambda(x) = \\frac{1}{1+\\lambda(x)} \\implies \\alpha\\lambda(x) = 1 - \\frac{1}{1+\\lambda(x)} = \\frac{\\lambda(x)}{1+\\lambda(x)} $$\n这得出了阻尼牛顿法的最优步长：\n$$ \\alpha(x) = \\frac{1}{1+\\lambda(x)} $$\n该步长始终满足条件 $\\alpha(x) \\lambda(x)  1$。\n\n现在，我们将这个最优步长代回到 $f(x^+)$ 的不等式中，以找到保证的下降量：\n$$ f(x^+) \\le f(x) - \\left(\\frac{1}{1+\\lambda(x)}\\right)\\lambda(x)^2 - \\left(\\frac{1}{1+\\lambda(x)}\\right)\\lambda(x) - \\log\\left(1 - \\frac{\\lambda(x)}{1+\\lambda(x)}\\right) $$\n$$ f(x^+) \\le f(x) - \\frac{\\lambda(x)^2+\\lambda(x)}{1+\\lambda(x)} - \\log\\left(\\frac{1}{1+\\lambda(x)}\\right) $$\n$$ f(x^+) \\le f(x) - \\lambda(x) + \\log(1+\\lambda(x)) $$\n整理此式可得单步下降量 $\\Delta f = f(x) - f(x^+)$ 的下界：\n$$ \\Delta f \\ge \\lambda(x) - \\log(1+\\lambda(x)) $$\n推导至此完成。下降量下界的规范预测函数是 $\\psi(\\lambda) = \\lambda - \\log(1+\\lambda)$，它在使用阻尼步长 $\\alpha(\\lambda) = 1/(1+\\lambda)$ 时有效。\n\n### 第二部分：测试函数分析\n\n我们将此分析应用于给定的两个函数。\n\n1.  **自协调障碍函数：$f_{\\text{bar}}(x) = -\\sum_{i=1}^n \\log x_i$**\n    - 梯度：$\\nabla f_{\\text{bar}}(x)_i = -1/x_i$。\n    - 海森矩阵：$\\nabla^2 f_{\\text{bar}}(x)$ 是一个对角矩阵，其对角元素为 $(\\nabla^2 f_{\\text{bar}}(x))_{ii} = 1/x_i^2$。\n    - 逆海森矩阵：$(\\nabla^2 f_{\\text{bar}}(x)^{-1})_{ii} = x_i^2$。\n    - 牛顿步：$p(x) = -(\\nabla^2 f_{\\text{bar}})^{-1} \\nabla f_{\\text{bar}} = -\\text{diag}(x_i^2) \\cdot [-1/x_i] = [x_i]$，所以 $p(x)=x$。\n    - 牛顿减量：$\\lambda(x)^2 = \\nabla f_{\\text{bar}}^\\top (\\nabla^2 f_{\\text{bar}})^{-1} \\nabla f_{\\text{bar}} = \\sum_{i=1}^n (-1/x_i)^2 (x_i^2) = \\sum_{i=1}^n 1 = n$。\n    - 因此，对于此函数，$\\lambda(x) = \\sqrt{n}$，是一个常数。对于用例 A ($n=2$) 和 B ($n=3$)，$\\lambda$ 将分别为 $\\sqrt{2}$ 和 $\\sqrt{3}$。理论预测比率 $r = \\Delta f / (\\lambda - \\log(1+\\lambda))$ 将大于或等于 1。\n\n2.  **非自协调函数：$f_{\\text{sqrt}}(x) = \\sum_{i=1}^n \\sqrt{1 + x_i^2}$**\n    - 梯度：$\\nabla f_{\\text{sqrt}}(x)_i = x_i / \\sqrt{1 + x_i^2}$。\n    - 海森矩阵：$\\nabla^2 f_{\\text{sqrt}}(x)$ 是一个对角矩阵，其对角元素为 $(\\nabla^2 f_{\\text{sqrt}}(x))_{ii} = (1 + x_i^2)^{-3/2}$。\n    - 逆海森矩阵：$(\\nabla^2 f_{\\text{sqrt}}(x)^{-1})_{ii} = (1 + x_i^2)^{3/2}$。\n    - 牛顿步：$p(x)_i = -(1+x_i^2)^{3/2} \\cdot (x_i/\\sqrt{1+x_i^2}) = -x_i(1+x_i^2)$。\n    - 牛顿减量：$\\lambda(x)^2 = \\sum_{i=1}^n (x_i/\\sqrt{1+x_i^2})^2 (1+x_i^2)^{3/2} = \\sum_{i=1}^n x_i^2\\sqrt{1+x_i^2}$。\n    - 由于此函数不是自协调的，推导出的预测不保证成立。我们预计会发现比率 $r  1$ 的情况。用例 C 使用阻尼步，可能满足也可能不满足该界。用例 D 使用完整牛顿步 ($\\alpha=1$)，已知对于远离最优解的非自协调函数，这可能是潜在不稳定的。\n\n### 第三部分：计算过程\n\n对于每个测试用例，按顺序计算以下量：\n1.  从测试套件中获取向量 $x$、所选函数（$f_{\\text{bar}}$ 或 $f_{\\text{sqrt}}$）和步长策略。\n2.  根据解析公式计算梯度 $\\nabla f(x)$ 和海森矩阵 $\\nabla^2 f(x)$。\n3.  通过求解系统 $\\nabla^2 f(x) p(x) = -\\nabla f(x)$ 来计算牛顿步。对于给定的函数，由于海森矩阵是对角阵，计算简化为：$p(x) = -(\\nabla^2 f(x))^{-1} \\nabla f(x)$。\n4.  计算牛顿减量为 $\\lambda(x) = \\sqrt{-\\nabla f(x)^\\top p(x)}$。\n5.  确定步长 $\\alpha(x)$：对于“阻尼”步，$\\alpha(x) = 1/(1+\\lambda(x))$；对于“完整”步，$\\alpha(x)=1$。\n6.  计算下一个迭代点：$x^+ = x + \\alpha(x) p(x)$。\n7.  计算函数值的实际下降量：$\\Delta f = f(x) - f(x^+)$。\n8.  使用推导出的公式计算预测的下界：$\\Delta f_{\\text{pred}} = \\lambda(x) - \\log(1+\\lambda(x))$。\n9.  计算比率 $r = \\Delta f / \\Delta f_{\\text{pred}}$ 以评估预测的有效性。\n\n实现将对所有四个指定的测试用例执行这些步骤。", "answer": "```python\nimport numpy as np\n\ndef f_bar(x):\n    \"\"\"\n    Computes value, gradient, and Hessian for f(x) = -sum(log(x_i)).\n    \"\"\"\n    if np.any(x = 0):\n        # The point must be in the domain of the function.\n        raise ValueError(\"Input x must be in the positive orthant.\")\n    val = -np.sum(np.log(x))\n    grad = -1.0 / x\n    hess = np.diag(1.0 / (x**2))\n    return val, grad, hess\n\ndef f_bar_val(x):\n    \"\"\"\n    Computes only the value of f_bar.\n    \"\"\"\n    if np.any(x = 0):\n        return np.inf\n    return -np.sum(np.log(x))\n\ndef f_sqrt(x):\n    \"\"\"\n    Computes value, gradient, and Hessian for f(x) = sum(sqrt(1 + x_i^2)).\n    \"\"\"\n    term = np.sqrt(1 + x**2)\n    val = np.sum(term)\n    grad = x / term\n    hess = np.diag(1.0 / (term**3))\n    return val, grad, hess\n\ndef f_sqrt_val(x):\n    \"\"\"\n    Computes only the value of f_sqrt.\n    \"\"\"\n    term = np.sqrt(1 + x**2)\n    return np.sum(term)\n\ndef solve():\n    \"\"\"\n    Main function to run the Newton's method comparison for the given test cases.\n    \"\"\"\n    test_cases = [\n        {'func_handle': f_bar, 'val_handle': f_bar_val, 'x': np.array([0.8, 1.2]), 'policy': 'damped'},\n        {'func_handle': f_bar, 'val_handle': f_bar_val, 'x': np.array([0.2, 0.5, 2.0]), 'policy': 'damped'},\n        {'func_handle': f_sqrt, 'val_handle': f_sqrt_val, 'x': np.array([2.0, -1.0]), 'policy': 'damped'},\n        {'func_handle': f_sqrt, 'val_handle': f_sqrt_val, 'x': np.array([3.0, 3.0]), 'policy': 'full'}\n    ]\n\n    ratios = []\n\n    for case in test_cases:\n        func = case['func_handle']\n        val_func = case['val_handle']\n        x = case['x']\n        policy = case['policy']\n\n        # 1. Get function value, gradient, and Hessian at x.\n        f_x, grad_x, hess_x = func(x)\n        \n        # 2. Compute Newton step p and decrement lambda.\n        # p = -H^{-1}g. `solve` is more stable than `inv` but for diagonal H, direct inversion is fine.\n        p_x = -np.linalg.solve(hess_x, grad_x)\n        \n        # lambda^2 = -g^T p\n        lambda_sq = -grad_x.T @ p_x\n        # Prevent numerical issues with small negative numbers due to floating point arithmetic.\n        lambda_x = np.sqrt(max(0, lambda_sq))\n\n        # 3. Determine step size alpha.\n        if policy == 'damped':\n            alpha = 1.0 / (1.0 + lambda_x)\n        else:  # 'full'\n            alpha = 1.0\n\n        # 4. Compute new point x_plus.\n        x_plus = x + alpha * p_x\n        \n        # 5. Compute actual decrease delta_f.\n        f_x_plus = val_func(x_plus)\n        delta_f_actual = f_x - f_x_plus\n\n        # 6. Compute predicted lower bound on decrease.\n        # This prediction is derived for self-concordant functions with a damped step.\n        if lambda_x  1e-9: # Avoid log(1) issues, though lambda isn't zero for these cases.\n            delta_f_pred = lambda_x - np.log(1.0 + lambda_x)\n        else:\n            # For lambda - 0, lambda - log(1+lambda) approx lambda - (lambda - lambda^2/2) = lambda^2/2\n            delta_f_pred = 0.5 * lambda_x**2\n\n        # 7. Compute the ratio r.\n        # A ratio r = 1 means the prediction holds.\n        if abs(delta_f_pred)  1e-12:\n            # If predicted decrease is zero, the ratio is conceptually infinite if there's any actual decrease.\n            # This case does not occur in the problem set.\n            ratio = np.inf if delta_f_actual  1e-12 else 1.0\n        else:\n            ratio = delta_f_actual / delta_f_pred\n        \n        ratios.append(ratio)\n\n    # Format and print the final output as specified.\n    print(f\"[{','.join(map(str, ratios))}]\")\n\nsolve()\n```", "id": "3176724"}]}