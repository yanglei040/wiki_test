{"hands_on_practices": [{"introduction": "这项练习在中心路径理论及其实际计算之间建立了基础性的联系。您将首先推导线性规划中心路径的基石恒等式，它将对偶间隙与障碍参数 $\\mu$ 直接关联起来。然后，通过实现一个牛顿法求解器，您将数值计算出路径上的点，并验证您的计算结果与理论预测完全一致，从而加深您对这一核心概念的理解 [@problem_id:3107281]。", "problem": "考虑一个具有非负性约束的等式形式的标准线性规划。原始问题是最小化 $c^{\\mathsf{T}} x$，约束条件为 $A x = b$ 和 $x \\ge 0$；对偶问题是最大化 $b^{\\mathsf{T}} y$，约束条件为 $A^{\\mathsf{T}} y + s = c$ 和 $s \\ge 0$。对于一个障碍参数 $\\mu \\in \\mathbb{R}_{0}$，中心路径被定义为满足扰动 Karush–Kuhn–Tucker (KKT) 条件的三元组 $(x(\\mu), y(\\mu), s(\\mu))$ 的集合\n$$\nA x = b,\\quad A^{\\mathsf{T}} y + s = c,\\quad X S \\mathbf{e} = \\mu \\mathbf{e},\\quad x > 0,\\ s > 0,\n$$\n其中 $X = \\mathrm{diag}(x)$，$S = \\mathrm{diag}(s)$，并且 $\\mathbf{e}$ 是维度为 $n$ 的全1向量。\n\n任务：\n1. 仅从原始问题和对偶问题的定义、平稳性条件和互补松弛条件以及上述中心路径的定义出发，推导出一个符号恒等式，该恒等式将对偶间隙 $g(\\mu) \\equiv c^{\\mathsf{T}} x(\\mu) - b^{\\mathsf{T}} y(\\mu)$ 完全用障碍参数 $\\mu$ 和原始变量的数量 $n$ 来表示。除这些定义外，不要假设任何其他结果。\n2. 设计一个阻尼牛顿法，在给定 $(A,b,c)$ 和一个正数 $\\mu$ 的情况下，通过求解非线性系统，数值计算中心路径方程的一个严格正解 $(x(\\mu), y(\\mu), s(\\mu))$\n$$\nF(x,y,s;\\mu) \\equiv \n\\begin{bmatrix}\nA x - b \\\\\nA^{\\mathsf{T}} y + s - c \\\\\nX S \\mathbf{e} - \\mu \\mathbf{e}\n\\end{bmatrix}\n= \\mathbf{0},\n$$\n并采用线搜索来维持 $x > 0$ 和 $s > 0$。使用通过在当前迭代点线性化 $F$ 得到的牛顿步长，并采用“到边界的分数”步长来强制保持正性。\n3. 对于下面的每个测试用例，使用同一组障碍参数 $\\mu \\in \\{ 1.0,\\ 0.1,\\ 10^{-3},\\ 10^{-6} \\}$。对于每个 $\\mu$ 和每个测试用例，使用你的牛顿法计算一个数值中心路径解 $(x(\\mu),y(\\mu),s(\\mu))$。然后评估绝对偏差\n$$\n\\Delta(\\mu) \\equiv \\left|\\, c^{\\mathsf{T}} x(\\mu) - b^{\\mathsf{T}} y(\\mu) \\;-\\; f(n,\\mu)\\,\\right|,\n$$\n其中 $f(n,\\mu)$ 是你在任务1中推导出的关于 $n$ 和 $\\mu$ 的函数。对于每个测试用例，你的程序必须输出一个 $\\Delta(\\mu)$ 值的列表，该列表对应于四个指定的 $\\mu$ 值，并按给定的确切顺序排列。\n\n测试套件：\n- 测试用例1：\n  - $m = 1$, $n = 2$,\n  - $A = \\begin{bmatrix} 1  1 \\end{bmatrix}$,\n  - $b = \\begin{bmatrix} 2 \\end{bmatrix}$,\n  - $c = \\begin{bmatrix} 2  1.5 \\end{bmatrix}^{\\mathsf{T}}$。\n- 测试用例2：\n  - $m = 2$, $n = 3$,\n  - $A = \\begin{bmatrix} 1  2  0 \\\\ 0  1  1 \\end{bmatrix}$,\n  - $b = \\begin{bmatrix} 3 \\\\ 2 \\end{bmatrix}$,\n  - $c = \\begin{bmatrix} 1  3  2 \\end{bmatrix}^{\\mathsf{T}}$。\n- 测试用例3：\n  - $m = 3$, $n = 5$,\n  - $A = \\begin{bmatrix}\n      1  0  1  0  1 \\\\\n      0  1  1  2  0 \\\\\n      2  0  0  1  1\n    \\end{bmatrix}$,\n  - $b = \\begin{bmatrix} 3 \\\\ 4 \\\\ 4 \\end{bmatrix}$,\n  - $c = \\begin{bmatrix} 1  2  3  4  1 \\end{bmatrix}^{\\mathsf{T}}$。\n- 测试用例4：\n  - $m = 2$, $n = 4$,\n  - $A = \\begin{bmatrix} 1  0  1  0 \\\\ 0  1  1  1 \\end{bmatrix}$,\n  - $b = \\begin{bmatrix} 2 \\\\ 3 \\end{bmatrix}$,\n  - $c = \\begin{bmatrix} 0.5  1.5  2.0  3.0 \\end{bmatrix}^{\\mathsf{T}}$。\n\n实现细节与要求：\n- 在每次迭代中，使用通过对 $F(x,y,s;\\mu)$ 微分得到的牛顿系统来计算 $(\\Delta x, \\Delta y, \\Delta s)$。使用因子为 $\\tau = 0.99$ 的“到边界的分数”步长来维持 $x$ 和 $s$ 的严格正性。如果需要，采用简单的回溯线搜索来减小残差范数 $\\|F\\|_2$。\n- 对于给定的测试用例，使用初始严格可行点 $x^{(0)} = \\mathbf{1}_n$, $y^{(0)} = \\mathbf{0}_m$, $s^{(0)} = c$。可以验证对于所提供的测试用例，该点满足 $A x^{(0)} = b$ 和 $A^{\\mathsf{T}} y^{(0)} + s^{(0)} = c$，且 $x^{(0)}  0$, $s^{(0)}  0$。\n- 必须选择合适的数值公差，以在 $\\mu = 10^{-6}$ 时，能够可靠地将 $\\Delta(\\mu)$ 的绝对值解析到至少 $10^{-9}$。\n- 你的程序必须生成单行输出，其中包含一个由四个子列表组成的逗号分隔列表，每个子列表对应一个测试用例，并且每个子列表按照 $\\mu \\in \\{ 1.0,\\ 0.1,\\ 10^{-3},\\ 10^{-6} \\}$ 的顺序，列出四个 $\\Delta(\\mu)$ 值。例如，输出格式必须是\n  $$\n  \\big[\\,[\\Delta_1(\\mu_1),\\Delta_1(\\mu_2),\\Delta_1(\\mu_3),\\Delta_1(\\mu_4)],\\ [\\Delta_2(\\mu_1),\\ldots],\\ [\\Delta_3(\\mu_1),\\ldots],\\ [\\Delta_4(\\mu_1),\\ldots]\\,\\big]\n  $$\n  不带任何额外文本。", "solution": "该问题被评估为有效，因为它科学地基于线性规划内点法的既定理论，问题设定良好并提供了所有必要信息，且表述客观。\n\n### 任务1：对偶间隙的符号恒等式\n\n第一个任务是推导中心路径上的对偶间隙 $g(\\mu)$ 的恒等式，用障碍参数 $\\mu$ 和原始变量的数量 $n$ 来表示。对偶间隙定义为原始和对偶目标函数值之差：\n$$\ng(\\mu) \\equiv c^{\\mathsf{T}} x(\\mu) - b^{\\mathsf{T}} y(\\mu)\n$$\n其中 $(x(\\mu), y(\\mu), s(\\mu))$ 是中心路径上的一个点。中心路径由对数障碍问题的 Karush-Kuhn-Tucker (KKT) 条件定义。问题陈述中提供的相关条件是：\n1. 原始可行性：$A x = b$\n2. 对偶可行性与平稳性：$A^{\\mathsf{T}} y + s = c$\n3. 扰动互补松弛性：$X S \\mathbf{e} = \\mu \\mathbf{e}$，其中 $X = \\mathrm{diag}(x)$ 且 $S = \\mathrm{diag}(s)$\n\n我们从对偶间隙的定义开始。我们可以将对偶可行性条件中 $c$ 的表达式代入间隙方程：\n$$\ng(\\mu) = (A^{\\mathsf{T}} y + s)^{\\mathsf{T}} x - b^{\\mathsf{T}} y\n$$\n利用转置的性质 $(U+V)^{\\mathsf{T}} = U^{\\mathsf{T}} + V^{\\mathsf{T}}$ 和 $(UV)^{\\mathsf{T}} = V^{\\mathsf{T}} U^{\\mathsf{T}}$，我们展开第一项：\n$$\ng(\\mu) = (y^{\\mathsf{T}} A + s^{\\mathsf{T}}) x - b^{\\mathsf{T}} y = y^{\\mathsf{T}} (Ax) + s^{\\mathsf{T}} x - b^{\\mathsf{T}} y\n$$\n接下来，我们使用原始可行性条件 $A x = b$ 来替换项 $(Ax)$：\n$$\ng(\\mu) = y^{\\mathsf{T}} b + s^{\\mathsf{T}} x - b^{\\mathsf{T}} y\n$$\n$y^{\\mathsf{T}} b$ 和 $b^{\\mathsf{T}} y$ 两项都是表示相同内积的标量，因此它们是相等的。于是，它们相互抵消：\n$$\ng(\\mu) = s^{\\mathsf{T}} x\n$$\n这表明对偶间隙等于原始变量 $x$ 和对偶松弛变量 $s$ 的内积。\n\n现在，我们使用扰动互补松弛性条件 $X S \\mathbf{e} = \\mu \\mathbf{e}$。这是一个向量方程，可以按分量写成：\n$$\nx_i s_i = \\mu \\quad \\text{for } i = 1, 2, \\ldots, n\n$$\n内积 $s^{\\mathsf{T}} x$ 是这些分量乘积的和：\n$$\ns^{\\mathsf{T}} x = \\sum_{i=1}^{n} s_i x_i\n$$\n将 $x_i s_i = \\mu$ 代入求和中的每一项，我们得到：\n$$\ns^{\\mathsf{T}} x = \\sum_{i=1}^{n} \\mu = n \\mu\n$$\n因此，中心路径上的对偶间隙与障碍参数 $\\mu$ 和原始变量的数量 $n$ 成正比。\n$$\ng(\\mu) = c^{\\mathsf{T}} x(\\mu) - b^{\\mathsf{T}} y(\\mu) = n \\mu\n$$\n因此，问题中要求的函数 $f(n, \\mu)$ 是 $f(n, \\mu) = n \\mu$。\n\n### 任务2：阻尼牛顿法设计\n\n第二个任务是设计一个阻尼牛顿法，以找到给定 $\\mu > 0$ 时中心路径上的一个点 $(x(\\mu), y(\\mu), s(\\mu))$。这涉及求解非线性方程组 $F(x,y,s;\\mu) = \\mathbf{0}$，其中：\n$$\nF(x,y,s;\\mu) = \n\\begin{bmatrix}\nA x - b \\\\\nA^{\\mathsf{T}} y + s - c \\\\\nX S \\mathbf{e} - \\mu \\mathbf{e}\n\\end{bmatrix}\n= \\mathbf{0}\n$$\n牛顿法通过求解线性化系统 $J \\begin{pmatrix} \\Delta x \\\\ \\Delta y \\\\ \\Delta s \\end{pmatrix} = -F$ 来迭代地寻找搜索方向 $(\\Delta x, \\Delta y, \\Delta s)$，其中 $J$ 是 $F$ 的雅可比矩阵。$F$ 相对于 $(x, y, s)$ 的雅可比矩阵是：\n$$\nJ(x,y,s) = \n\\begin{pmatrix}\n\\frac{\\partial}{\\partial x}(Ax-b)  \\frac{\\partial}{\\partial y}(Ax-b)  \\frac{\\partial}{\\partial s}(Ax-b) \\\\\n\\frac{\\partial}{\\partial x}(A^{\\mathsf{T}}y+s-c)  \\frac{\\partial}{\\partial y}(A^{\\mathsf{T}}y+s-c)  \\frac{\\partial}{\\partial s}(A^{\\mathsf{T}}y+s-c) \\\\\n\\frac{\\partial}{\\partial x}(XSe-\\mu e)  \\frac{\\partial}{\\partial y}(XSe-\\mu e)  \\frac{\\partial}{\\partial s}(XSe-\\mu e)\n\\end{pmatrix}\n=\n\\begin{pmatrix}\nA   \\mathbf{0}  \\mathbf{0} \\\\\n\\mathbf{0}  A^{\\mathsf{T}}  I \\\\\nS  \\mathbf{0}  X\n\\end{pmatrix}\n$$\n牛顿系统定义为 $J \\begin{pmatrix} \\Delta x \\\\ \\Delta y \\\\ \\Delta s \\end{pmatrix} = -\\begin{pmatrix} A x - b \\\\ A^{\\mathsf{T}} y + s - c \\\\ X S \\mathbf{e} - \\mu \\mathbf{e} \\end{pmatrix}$。我们定义原始可行性残差 ($r_p$)、对偶可行性残差 ($r_d$) 和中心性残差 ($r_c$)：\n$$\nr_p = b - Ax \\\\\nr_d = c - A^{\\mathsf{T}} y - s \\\\\nr_c = \\mu \\mathbf{e} - X S \\mathbf{e}\n$$\n牛顿系统变为：\n1. $A \\Delta x = r_p$\n2. $A^{\\mathsf{T}} \\Delta y + \\Delta s = r_d$\n3. $S \\Delta x + X \\Delta s = r_c$\n\n为了高效求解该系统，我们使用分块消元法。从(2)中，我们用 $\\Delta y$ 表示 $\\Delta s$：$\\Delta s = r_d - A^{\\mathsf{T}} \\Delta y$。将其代入(3)：\n$$\nS \\Delta x + X(r_d - A^{\\mathsf{T}} \\Delta y) = r_c \\implies S \\Delta x - X A^{\\mathsf{T}} \\Delta y = r_c - X r_d\n$$\n由于 $S$ 是对角且正的（因为 $s>0$），我们可以求解 $\\Delta x$：\n$$\n\\Delta x = S^{-1}(X A^{\\mathsf{T}} \\Delta y + r_c - X r_d) = X S^{-1} A^{\\mathsf{T}} \\Delta y + S^{-1}(r_c - X r_d)\n$$\n现在将这个 $\\Delta x$ 的表达式代入(1)：\n$$\nA \\left( X S^{-1} A^{\\mathsf{T}} \\Delta y + S^{-1}(r_c - X r_d) \\right) = r_p\n$$\n重新整理得到关于 $\\Delta y$ 的正规方程组：\n$$\n(A X S^{-1} A^{\\mathsf{T}}) \\Delta y = r_p - A S^{-1}(r_c - X r_d)\n$$\n这是一个关于 $\\Delta y$ 的大小为 $m \\times m$ 的线性系统，其中 $m$ 是 $A$ 的行数。矩阵 $M = A X S^{-1} A^{\\mathsf{T}}$ 是对称正定的（假设 $A$ 行满秩），因此是可逆的。\n\n单次牛顿迭代的算法如下：\n1. 给定当前迭代点 $(x, y, s)$，计算残差 $r_p$、$r_d$ 和 $r_c$。\n2. 构造正规方程矩阵 $M = A \\mathrm{diag}(x) \\mathrm{diag}(s^{-1}) A^{\\mathsf{T}}$ 和右侧向量 $v = r_p - A \\mathrm{diag}(s^{-1})(r_c - \\mathrm{diag}(x)r_d)$。\n3. 求解 $m \\times m$ 系统 $M \\Delta y = v$ 得到 $\\Delta y$。\n4. 回代求解 $\\Delta s$：$\\Delta s = r_d - A^{\\mathsf{T}} \\Delta y$。\n5. 回代求解 $\\Delta x$：$\\Delta x = S^{-1}(r_c - X \\Delta s) = \\mathrm{diag}(s^{-1})(r_c - \\mathrm{diag}(x)\\Delta s)$。\n\n为保持 $x$ 和 $s$ 的严格正性，需要执行线搜索。选择一个步长 $\\alpha \\in (0, 1]$。然后更新为 $(x, y, s) \\leftarrow (x, y, s) + \\alpha (\\Delta x, \\Delta y, \\Delta s)$。\n步长 $\\alpha$ 由“到边界的分数”规则确定：\n$$\n\\alpha_x^{\\max} = \\min \\left( \\{1\\} \\cup \\{ -x_i/\\Delta x_i \\mid \\Delta x_i  0 \\} \\right) \\\\\n\\alpha_s^{\\max} = \\min \\left( \\{1\\} \\cup \\{ -s_i/\\Delta s_i \\mid \\Delta s_i  0 \\} \\right) \\\\\n\\alpha = \\tau \\min(\\alpha_x^{\\max}, \\alpha_s^{\\max})\n$$\n其中 $\\tau \\in (0, 1)$ 是一个安全因子，给定为 $\\tau=0.99$。如果需要回溯，可以进一步减小 $\\alpha$（例如，乘以因子0.5），直到残差范数 $\\|F\\|_2$ 减小。\n\n### 任务3：数值实现与评估\n\n最后一个任务是实现牛顿法并将其应用于给定的测试用例。对于每个测试用例和每个 $\\mu \\in \\{ 1.0, 0.1, 10^{-3}, 10^{-6} \\}$ 值，算法计算中心路径点 $(x(\\mu), y(\\mu), s(\\mu))$。牛顿迭代的初始点指定为 $x^{(0)} = \\mathbf{1}_n$，$y^{(0)} = \\mathbf{0}_m$ 和 $s^{(0)} = c$。可以验证，对于所有提供的测试用例，该初始点都是严格可行的，满足 $A x^{(0)} = b$，$A^{\\mathsf{T}} y^{(0)} + s^{(0)} = c$，$x^{(0)} > 0$ 和 $s^{(0)} > 0$。迭代将持续进行，直到残差向量的欧几里得范数 $\\|F(x,y,s;\\mu)\\|_2$ 小于预定公差（例如，$10^{-12}$）。\n\n收敛后，计算绝对偏差 $\\Delta(\\mu)$：\n$$\n\\Delta(\\mu) = \\left| c^{\\mathsf{T}} x(\\mu) - b^{\\mathsf{T}} y(\\mu) - n \\mu \\right|\n$$\n考虑到对于可行点有 $c^{\\mathsf{T}}x-b^{\\mathsf{T}}y = s^{\\mathsf{T}}x$，并且算法将 $XSe$ 驱动向 $\\mu e$，我们也可以将其写为：\n$$\n\\Delta(\\mu) = \\left| s(\\mu)^{\\mathsf{T}} x(\\mu) - n \\mu \\right|\n$$\n这个值衡量了数值计算的对偶间隙与中心路径上的理论值匹配的紧密程度。最终输出将是一个列表，包含每个测试用例计算出的 $\\Delta(\\mu)$ 值。", "answer": "```python\nimport numpy as np\n\ndef newton_solver(A, b, c, mu, x0, y0, s0):\n    \"\"\"\n    Solves the central path equations using a damped Newton method.\n    F(x,y,s;mu) = [Ax - b; A^T y + s - c; X S e - mu e] = 0\n    \"\"\"\n    x, y, s = x0.copy(), y0.copy(), s0.copy()\n    m, n = A.shape\n    e = np.ones(n)\n    \n    # Algorithmic parameters\n    max_iter = 50\n    tolerance = 1e-12  # Tolerance for the residual norm\n    tau = 0.99  # Fraction-to-the-boundary factor\n\n    for i in range(max_iter):\n        # Calculate residuals\n        r_p = b - (A @ x)\n        r_d = c - (A.T @ y) - s\n        r_c = mu * e - x * s\n\n        # Check for convergence\n        residuals = np.concatenate((r_p, r_d, r_c))\n        res_norm = np.linalg.norm(residuals)\n        if res_norm = tolerance:\n            break\n\n        # Solve the Newton system using normal equations\n        # Efficiently compute M = A @ diag(x/s) @ A.T\n        x_over_s = x / s\n        M = (A * x_over_s) @ A.T\n\n        # Efficiently compute rhs = r_p - A @ ((r_c - x * r_d) / s)\n        rhs_vec = (r_c - x * r_d) / s\n        rhs = r_p - A @ rhs_vec\n\n        # Solve for dy\n        dy = np.linalg.solve(M, rhs)\n        \n        # Back-substitute for ds\n        ds = r_d - A.T @ dy\n        \n        # Back-substitute for dx\n        dx = (r_c - x * ds) / s\n\n        # Line search (fraction-to-the-boundary rule)\n        alpha_x_vals = [-xi / dxi for xi, dxi in zip(x, dx) if dxi  0]\n        alpha_x = min([1.0] + alpha_x_vals)\n\n        alpha_s_vals = [-si / dsi for si, dsi in zip(s, ds) if dsi  0]\n        alpha_s = min([1.0] + alpha_s_vals)\n\n        alpha = tau * min(alpha_x, alpha_s)\n        \n        # Simple backtracking to ensure residual reduction (optional but good practice)\n        current_res_norm_sq = res_norm**2\n        for _ in range(10): # Max 10 backtracking steps\n            x_new, y_new, s_new = x + alpha * dx, y + alpha * dy, s + alpha * ds\n            r_p_new = b - (A @ x_new)\n            r_d_new = c - (A.T @ y_new) - s_new\n            r_c_new = mu * e - x_new * s_new\n            new_res_norm_sq = np.linalg.norm(r_p_new)**2 + np.linalg.norm(r_d_new)**2 + np.linalg.norm(r_c_new)**2\n            if new_res_norm_sq = current_res_norm_sq:\n                break\n            alpha *= 0.5 # Reduce step size\n        \n        # Update variables\n        x, y, s = x_new, y_new, s_new\n\n    return x, y, s\n\ndef solve_for_case(A, b, c):\n    \"\"\"\n    Computes the absolute deviation Delta(mu) for a given problem instance\n    and a set of mu values.\n    \"\"\"\n    m, n = A.shape\n    mu_values = [1.0, 0.1, 1e-3, 1e-6]\n    delta_values = []\n\n    for mu in mu_values:\n        # Per the problem, use the same initial feasible point for each mu.\n        x0 = np.ones(n)\n        y0 = np.zeros(m)\n        s0 = c.copy()\n\n        # Compute the point on the central path\n        x_mu, y_mu, s_mu = newton_solver(A, b, c, mu, x0, y0, s0)\n\n        # Calculate the numerical duality gap\n        # Although c.T@x - b.T@y is the primary definition, s.T@x is numerically\n        # more direct for checking the centrality condition.\n        # The KKT conditions imply they are equal at the solution.\n        numerical_gap = s_mu.T @ x_mu\n\n        # Theoretical gap on the central path is n*mu\n        theoretical_gap = n * mu\n\n        # Calculate the absolute deviation\n        delta = abs(numerical_gap - theoretical_gap)\n        delta_values.append(delta)\n        \n    return delta_values\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and generate the final output.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        {\n            \"A\": np.array([[1.0, 1.0]]),\n            \"b\": np.array([2.0]),\n            \"c\": np.array([2.0, 1.5])\n        },\n        # Test case 2\n        {\n            \"A\": np.array([[1.0, 2.0, 0.0], [0.0, 1.0, 1.0]]),\n            \"b\": np.array([3.0, 2.0]),\n            \"c\": np.array([1.0, 3.0, 2.0])\n        },\n        # Test case 3\n        {\n            \"A\": np.array([\n                [1.0, 0.0, 1.0, 0.0, 1.0],\n                [0.0, 1.0, 1.0, 2.0, 0.0],\n                [2.0, 0.0, 0.0, 1.0, 1.0]\n            ]),\n            \"b\": np.array([3.0, 4.0, 4.0]),\n            \"c\": np.array([1.0, 2.0, 3.0, 4.0, 1.0])\n        },\n        # Test case 4\n        {\n            \"A\": np.array([[1.0, 0.0, 1.0, 0.0], [0.0, 1.0, 1.0, 1.0]]),\n            \"b\": np.array([2.0, 3.0]),\n            \"c\": np.array([0.5, 1.5, 2.0, 3.0])\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        result = solve_for_case(case[\"A\"], case[\"b\"], case[\"c\"])\n        all_results.append(result)\n\n    # Format the final output string to be exactly as required (no spaces)\n    output_str = repr(all_results).replace(\" \", \"\")\n    print(output_str)\n\nsolve()\n```", "id": "3107281"}, {"introduction": "在掌握了基本原理之后，这项练习将探索中心路径在挑战性场景下的几何行为及其对数值计算的影响。您将构建一个线性规划问题，其可行域形成一个狭窄的楔形，迫使中心路径急剧转向。通过实现路径跟随算法并追踪海森矩阵的条件数，您将直观地理解病态问题是如何产生的，以及它如何影响内点法的稳定性和性能 [@problem_id:3107306]。", "problem": "您将构建并分析一个二维线性规划族，其有效约束的法向量近似平行，然后实现一个基于对数障碍的路径跟踪内点法，以通过经验揭示中心路径如何在一个狭窄的可行楔形区域中移动，以及矩阵条件数如何影响牛顿步。\n\n您应使用的基本理论基础包括对数障碍的凸性、Karush–Kuhn–Tucker (KKT) 最优性条件，以及用于求解障碍增广目标的光滑无约束最小化问题的牛顿法。基于这些，推导出中心路径方程和障碍子问题的牛顿步。\n\n考虑以下构造。对于给定的角度参数 $\\theta \\in (0,\\pi/2)$（角度单位：弧度），定义两个具有近似平行外法向量的不等式约束\n$$\na_1 = \\begin{bmatrix}1 \\\\ 0\\end{bmatrix},\\quad a_2 = \\begin{bmatrix}\\cos\\theta \\\\ \\sin\\theta\\end{bmatrix},\\quad b_1 = 1,\\quad b_2 = 1,\n$$\n以及对称的箱式约束\n$$\n- B \\le x_1 \\le B,\\quad - B \\le x_2 \\le B,\\quad \\text{with } B = 2.\n$$\n令目标为最小化 $c^\\top x$，其中\n$$\nc = - (a_1 + a_2).\n$$\n这个选择会使得最优解出现在 $a_1^\\top x = b_1$ 和 $a_2^\\top x = b_2$ 同时为积极约束的交点附近。对于一组由 $i \\in \\{1,\\dots,m\\}$ 索引的不等式约束，将它们统一写为\n$$\ng_i(x) = b_i - a_i^\\top x > 0,\\quad \\text{因此 } x \\text{ 必须对所有 } i \\text{ 满足 } g_i(x) > 0。\n$$\n对于参数 $t > 0$，对数障碍路径跟踪子问题为\n$$\n\\min_{x \\in \\mathbb{R}^2} \\; f_t(x) = t\\, c^\\top x - \\sum_{i=1}^m \\log\\big(g_i(x)\\big),\n$$\n其中心路径由 $f_t$ 的唯一最小化点 $x^\\star(t)$ 在 $t \\to +\\infty$ 时的轨迹来表征。\n\n您必须完成的任务：\n\n1) 从 $f_t(x)$ 和 $g_i(x)$ 的定义出发，用 $\\{a_i,b_i\\}$ 和 $t$ 表示梯度 $\\nabla f_t(x)$ 和 Hessian 矩阵 $\\nabla^2 f_t(x)$。\n\n2) 实现一个路径跟踪（障碍）方法，该方法构建一个递增序列 $t_k$，并对每个 $t_k$，从前一个中心点作为热启动开始，对 $f_{t_k}$ 应用阻尼牛顿步来找到牛顿点 $x^\\star(t_k)$。使用以下具体且可测试的选择：\n- 在 $t_0 = 1$ 和 $x_0 = \\begin{bmatrix}0 \\\\ 0\\end{bmatrix}$ 处初始化。\n- 使用乘法更新规则 $t_{k+1} = \\mu \\, t_k$，其中 $\\mu = 10$。\n- 令不等式约束的数量为 $m = 6$（两个角度约束和四个箱式约束）。\n- 当代理对偶间隙 $m / t_k \\le \\varepsilon_{\\text{gap}}$ 时终止外循环，其中 $\\varepsilon_{\\text{gap}} = 10^{-4}$。\n- 对于固定的 $t_k$ 的内层牛顿循环，通过求解 $\\nabla^2 f_{t_k}(x)\\, \\Delta x = - \\nabla f_{t_k}(x)$ 计算牛顿步 $\\Delta x$，并使用一个强制执行以下条件的回溯线搜索：\n  (i) 通过比例为 $\\eta = 0.99$ 的边界分数步长确保严格可行性 $g_i(x + \\alpha \\Delta x) > 0$，\n  (ii) 使用参数 $\\beta = 10^{-4}$ 和回溯收缩因子 $\\gamma = 0.5$ 的 Armijo 下降条件，从 $\\alpha = 1$ 开始。\n- 当牛顿二次减量 $\\lambda(x)^2 = \\nabla f_t(x)^\\top \\left(\\nabla^2 f_t(x)\\right)^{-1} \\nabla f_t(x)$ 满足 $\\lambda(x)^2 / 2 \\le 10^{-8}$ 时停止内层牛顿循环。\n\n3) 量化条件数。在每次牛顿迭代中，计算 Hessian 矩阵 $\\nabla^2 f_t(x)$ 的条件数（在谱 2-范数下）。汇总整个运行过程中观察到的最大值。\n\n4) 量化步长接受情况。在整个运行过程中，跟踪回溯线搜索所接受的最小步长 $\\alpha$。\n\n5) 量化计算开销。统计所有外层迭代直到终止所花费的总牛顿步数。\n\n通过对以下角度（单位：弧度）评估算法，提供一个教学数据集，这些角度从良态条件区域过渡到近似平行区域：\n- $\\theta = 0.5$,\n- $\\theta = 0.1$,\n- $\\theta = 0.01$,\n- $\\theta = 0.001$.\n\n对于每个测试用例 $\\theta$，您的程序必须返回一个三元组\n$$\n[\\text{total\\_newton\\_steps},\\; \\text{max\\_condition\\_number},\\; \\text{min\\_accepted\\_step}],\n$$\n其中 $\\text{total\\_newton\\_steps}$ 是一个整数，另外两个量是实数。不涉及物理单位；角度单位如指定为弧度。\n\n最终输出格式要求：\n- 您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果，其中每个元素按上述顺序对应一个测试用例，并且本身是一个 $[\\text{total\\_newton\\_steps},\\text{max\\_condition\\_number},\\text{min\\_accepted\\_step}]$ 形式的列表。例如，其形状必须是\n$$\n\\big[ [\\cdot,\\cdot,\\cdot], [\\cdot,\\cdot,\\cdot], [\\cdot,\\cdot,\\cdot], [\\cdot,\\cdot,\\cdot] \\big].\n$$", "solution": "用户希望实现并分析一种路径跟踪内点法，用于求解一个二维线性规划（LP）族。这些 LP 的定义特征是存在两个约束法向量，当参数 $\\theta$ 趋近于零时变得近似平行，这旨在突显与病态条件相关的数值挑战。\n\n解决方案将按以下步骤呈现：\n1.  对数障碍目标函数的梯度和 Hessian 矩阵的推导。\n2.  路径跟踪算法的详细描述，包括用于更新障碍参数 $t$ 的外循环和用于中心化的内层牛顿法循环。\n3.  线搜索过程的解释，协调指定的多个条件。\n4.  对要收集的数据的说明：总牛顿步数、最大 Hessian 条件数和最小接受步长。\n\n### 1. 数学公式与导数\n\n问题是最小化一个线性目标 $c^\\top x$，受一组线性不等式约束。我们给定 $m=6$ 个约束，写作 $a_i^\\top x  b_i$ 的形式，其中 $i=1,\\dots,m$。在障碍法中，通过定义函数 $g_i(x) = b_i - a_i^\\top x > 0$ 来处理这些约束。\n\n路径跟踪法求解一系列由目标函数 $f_t(x)$ 定义的无约束优化问题：\n$$ f_t(x) = t c^\\top x - \\sum_{i=1}^m \\log\\big(g_i(x)\\big) = t c^\\top x - \\sum_{i=1}^m \\log(b_i - a_i^\\top x) $$\n其中 $t > 0$ 是障碍参数。对于 $t > 0$ 的最小化点集合 $x^\\star(t)$ 构成了中心路径。\n\n**任务 1：梯度和 Hessian 矩阵推导**\n\n为了应用牛顿法最小化 $f_t(x)$，我们必须计算其梯度 $\\nabla f_t(x)$ 和 Hessian 矩阵 $\\nabla^2 f_t(x)$。\n\n**梯度 $\\nabla f_t(x)$:**\n梯度是通过对 $f_t(x)$ 关于向量 $x$ 求导来计算的。对对数项使用链式法则，$\\nabla_x \\log(u(x)) = \\frac{1}{u(x)}\\nabla_x u(x)$。\n这里，$u(x) = g_i(x) = b_i - a_i^\\top x$，所以 $\\nabla_x g_i(x) = -a_i$。\n线性项 $\\nabla_x(t c^\\top x)$ 的梯度就是 $t c$。\n$$ \\nabla f_t(x) = \\nabla \\left( t c^\\top x - \\sum_{i=1}^m \\log(b_i - a_i^\\top x) \\right) $$\n$$ \\nabla f_t(x) = t c - \\sum_{i=1}^m \\frac{1}{b_i - a_i^\\top x} (-a_i) $$\n$$ \\nabla f_t(x) = t c + \\sum_{i=1}^m \\frac{a_i}{b_i - a_i^\\top x} $$\n\n**Hessian 矩阵 $\\nabla^2 f_t(x)$:**\nHessian 矩阵是二阶偏导数矩阵，通过对梯度求导得到。线性项 $t c$ 的 Hessian 矩阵为零。对于求和项，我们对 $\\frac{a_i}{b_i - a_i^\\top x}$ 关于 $x$ 求导。\n$$ \\nabla^2 f_t(x) = \\nabla \\left( t c + \\sum_{i=1}^m \\frac{a_i}{b_i - a_i^\\top x} \\right)^\\top $$\n使用规则 $\\nabla_x \\left( \\frac{v(x)}{u(x)} \\right) = \\frac{u \\nabla v - v \\nabla u^\\top}{u^2}$ 比较复杂。一个更简单的方法是将每一项看作 $a_i (b_i - a_i^\\top x)^{-1}$ 并再次应用链式法则。\n$$ \\nabla_x \\left( (b_i - a_i^\\top x)^{-1} \\right) = -(b_i - a_i^\\top x)^{-2} (-a_i^\\top) = \\frac{a_i^\\top}{(b_i - a_i^\\top x)^2} $$\n该向量值函数的导数则为：\n$$ \\nabla_x \\left( \\frac{a_i}{b_i - a_i^\\top x} \\right) = a_i \\otimes \\nabla_x \\left( \\frac{1}{b_i - a_i^\\top x} \\right) = a_i \\frac{a_i^\\top}{(b_i - a_i^\\top x)^2} = \\frac{a_i a_i^\\top}{(b_i - a_i^\\top x)^2} $$\n符号 $\\otimes$ 表示外积。对所有约束求和得到 Hessian 矩阵：\n$$ \\nabla^2 f_t(x) = \\sum_{i=1}^m \\frac{a_i a_i^\\top}{(b_i - a_i^\\top x)^2} $$\nHessian 矩阵是正半定秩一矩阵的和。由于向量集 $\\{a_i\\}$ 张成 $\\mathbb{R}^2$，对于可行集严格内部的任何 $x$，Hessian 矩阵都是正定的，这确保了 $f_t(x)$ 是严格凸的并且有唯一的最小化点。\n\n### 2. 算法实现\n\n该算法包含两个嵌套循环。\n\n**外循环：路径跟踪**\n该循环迭代地增加障碍参数 $t$，以将解推向可行域的边界，原始 LP 的最优解就位于该边界上。\n1.  **初始化**：从 $t_0=1$ 和一个严格可行点 $x_0 = [0, 0]^\\top$ 开始。\n2.  **迭代**：在每一步 $k$，使用牛顿法求解无约束子问题 $\\min_x f_{t_k}(x)$，从上一个解 $x^\\star(t_{k-1})$ 作为热启动开始。结果是 $x^\\star(t_k)$。\n3.  **更新**：使用乘法规则 $t_{k+1} = \\mu t_k$ 增加障碍参数，其中 $\\mu = 10$。\n4.  **终止**：当代理对偶间隙 $m/t_k$ 低于指定的容差 $\\varepsilon_{\\text{gap}} = 10^{-4}$ 时，循环终止。代理间隙 $m/t$ 是真实对偶间隙的一个上界，也是障碍法的一个标准终止准则。\n\n**内循环：用于中心化的牛顿法**\n对于固定的 $t=t_k$，我们使用阻尼牛顿法找到 $f_t(x)$ 的最小化点。\n1.  **初始化**：从 $x = x^\\star(t_{k-1})$ 开始（对于第一个外层迭代，则从 $x_0$ 开始）。\n2.  **牛顿步计算**：通过求解线性系统来计算牛顿步 $\\Delta x$：\n    $$ \\nabla^2 f_t(x) \\Delta x = - \\nabla f_t(x) $$\n    其中梯度和 Hessian 矩阵在当前迭代点 $x$ 处计算。\n3.  **牛顿减量**：计算牛顿二次减量 $\\lambda(x)^2$：\n    $$ \\lambda(x)^2 = \\nabla f_t(x)^\\top (\\nabla^2 f_t(x))^{-1} \\nabla f_t(x) = - \\nabla f_t(x)^\\top \\Delta x $$\n4.  **终止**：当 $\\lambda(x)^2 / 2 \\le 10^{-8}$ 时，内循环终止。量 $\\lambda(x)^2/2$ 是次优性 $f_t(x) - f_t(x^\\star(t))$ 的一个估计。\n5.  **线搜索与更新**：使用回溯线搜索找到一个合适的步长 $\\alpha$。更新解：$x \\leftarrow x + \\alpha \\Delta x$。\n\n### 3. 回溯线搜索\n\n步长 $\\alpha$ 对于确保收敛至关重要。问题指定了一个具有多个条件的回溯线搜索，这可以被解释为一个鲁棒的过程：\n1.  **可行性上限**：首先，确定能保持严格可行性（即 $g_i(x + \\alpha \\Delta x) > 0$）的最大可能步长 $\\alpha_{\\text{max}}$。它由 $\\alpha_{\\text{max}} = \\min \\{ (b_i - a_i^\\top x) / (a_i^\\top \\Delta x) \\}$ 给出，其中 $i$ 遍历所有使 $a_i^\\top \\Delta x > 0$ 的索引。提出的初始步长为 $\\alpha = \\min(1.0, \\eta \\alpha_{\\text{max}})$，其中 $\\eta=0.99$。这可以防止步长恰好落在边界上，那将使对数障碍函数无定义。这种解释协调了“从 $\\alpha=1$ 开始”的一般指令与特定的“边界分数”规则。\n2.  **Armijo 条件**：从这个有上限的 $\\alpha$ 开始，然后线搜索收缩步长，直到满足 Armijo-Goldstein 充分下降条件：\n    $$ f_t(x + \\alpha \\Delta x) \\le f_t(x) + \\beta \\alpha \\nabla f_t(x)^\\top \\Delta x $$\n    其中 $\\beta=10^{-4}$。如果条件不满足，步长将乘以一个因子 $\\gamma=0.5$：$\\alpha \\leftarrow \\gamma \\alpha$。\n\n这种两阶段方法（为保证可行性设置上限，然后为保证充分下降而回溯）确保每一步既是严格可行的，又在最小化目标函数方面取得了足够的进展。\n\n### 4. 分析与量化指标\n\n问题要求量化算法的性能，特别是当约束变得近似平行时（$\\theta \\to 0$）。\n-   **总牛顿步数**：这衡量了将 LP 求解到所需精度所需的总计算量。随着 $\\theta$ 减小，中心路径变得更尖锐，热启动的效果变差，可能导致每个外层迭代的牛顿步数增加。\n-   **最大 Hessian 条件数**：条件数 $\\kappa(\\nabla^2 f_t(x))$ 衡量了牛顿系统解对扰动的敏感性。当 $\\theta \\to 0$ 时，$a_1$ 和 $a_2$ 变得近似共线。当迭代点 $x$ 靠近这两个约束都为积极约束的角落时，Hessian 矩阵求和中的相应项 $\\frac{a_1 a_1^\\top}{g_1(x)^2}$ 和 $\\frac{a_2 a_2^\\top}{g_2(x)^2}$ 会产生一个具有一个非常大的特征值（方向 $a_1+a_2$）和一个小得多的特征值（方向 $a_1-a_2$）的矩阵。这导致条件数爆炸，表明存在严重的病态问题。\n-   **最小接受步长**：这跟踪了线搜索接受的最小步长 $\\alpha$。严重的病态问题或中心路径的急剧弯曲可能会迫使算法采取非常小的步长来满足可行性和/或 Armijo 条件，表明在取得进展方面存在困难。\n\n通过对递减的 $\\theta$ 值跟踪这三个指标，我们可以通过经验观察到内点法理论所预测的数值性能下降。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the path-following algorithm for the specified test cases.\n    \"\"\"\n\n    # --- Problem Parameters ---\n    B = 2.0  # Box constraint size\n    M = 6    # Number of inequality constraints\n\n    # --- Path-Following Algorithm Parameters ---\n    T_0 = 1.0          # Initial barrier parameter\n    MU = 10.0          # Barrier parameter update factor\n    EPS_GAP = 1e-4     # Surrogate duality gap tolerance for termination\n\n    # --- Newton's Method (Inner Loop) Parameters ---\n    NEWTON_TOL_LAMBDA_SQ = 2 * 1e-8  # Termination tolerance for lambda^2\n    ETA = 0.99                     # Fraction-to-the-boundary for line search\n    BETA = 1e-4                    # Armijo condition parameter\n    GAMMA = 0.5                    # Backtracking line search contraction factor\n\n    def setup_problem(theta):\n        \"\"\"Constructs the LP matrices A, b, and cost vector c for a given theta.\"\"\"\n        a1 = np.array([1.0, 0.0])\n        b1 = 1.0\n        a2 = np.array([np.cos(theta), np.sin(theta)])\n        b2 = 1.0\n        \n        c = -(a1 + a2)\n        \n        A = np.array([\n            a1,                      # Constraint: x1  1\n            a2,                      # Constraint: cos(theta)*x1 + sin(theta)*x2  1\n            [1.0, 0.0],              # Box: x1  2\n            [-1.0, 0.0],             # Box: -x1  2\n            [0.0, 1.0],              # Box: x2  2\n            [0.0, -1.0]              # Box: -x2  2\n        ])\n        \n        b = np.array([b1, b2, B, B, B, B])\n        \n        return c, A, b\n\n    def objective_f_t(t, c, A, b, x):\n        \"\"\"Computes the log-barrier objective function f_t(x).\"\"\"\n        g = b - A @ x\n        if np.any(g = 1e-12):  # Safety check for strict feasibility\n            return np.inf\n        return t * (c @ x) - np.sum(np.log(g))\n\n    def solve_for_theta(theta):\n        \"\"\"\n        Runs the full path-following method for a single theta value.\n        \n        Returns:\n            A list containing [total_newton_steps, max_condition_number, min_accepted_step].\n        \"\"\"\n        c, A, b = setup_problem(theta)\n        \n        # Initialization\n        t = T_0\n        x = np.array([0.0, 0.0])\n\n        total_newton_steps = 0\n        max_condition_number = 0.0\n        min_accepted_step = 1.0\n\n        # --- Outer Loop: Path-Following ---\n        while M / t > EPS_GAP:\n            \n            # --- Inner Loop: Newton's Method for Centering ---\n            while True:\n                total_newton_steps += 1\n                # Calculate g(x), gradient, and Hessian\n                g = b - A @ x\n                inv_g = 1.0 / g\n                \n                grad = t * c + A.T @ inv_g\n                \n                weights = inv_g**2\n                H = A.T @ (A * weights[:, np.newaxis])\n                \n                # Track condition number\n                cond_H = np.linalg.cond(H)\n                max_condition_number = max(max_condition_number, cond_H)\n\n                # Solve Newton system: H * delta_x = -grad\n                try:\n                    delta_x = np.linalg.solve(H, -grad)\n                except np.linalg.LinAlgError:\n                    # Fallback for singular Hessian, though unlikely in theory\n                    delta_x = np.linalg.pinv(H, rcond=1e-15) @ -grad\n\n                # Calculate squared Newton decrement\n                lambda_sq = -grad.T @ delta_x\n                \n                # Check for inner loop convergence\n                if lambda_sq = NEWTON_TOL_LAMBDA_SQ:\n                    break\n                \n                # --- Backtracking Line Search ---\n                # 1. Cap step size by fraction-to-the-boundary rule\n                alpha_max_boundary = np.inf\n                v = A @ delta_x\n                # Indices where we are moving towards a boundary (a_i^T * delta_x > 0)\n                mask = v > 1e-12\n                if np.any(mask):\n                    alpha_max_boundary = np.min(g[mask] / v[mask])\n                \n                alpha = min(1.0, ETA * alpha_max_boundary)\n\n                # 2. Enforce Armijo sufficient decrease condition\n                f_current = objective_f_t(t, c, A, b, x)\n                armijo_check_term = BETA * grad.T @ delta_x\n\n                while True:\n                    x_next = x + alpha * delta_x\n                    f_next = objective_f_t(t, c, A, b, x_next)\n                    if f_next = f_current + alpha * armijo_check_term:\n                        break  # Armijo condition satisfied\n                    \n                    alpha *= GAMMA\n                    if alpha  1e-16: # Safety break for extremely small alpha\n                        break\n                \n                # Update x and tracking variables\n                x = x_next\n                min_accepted_step = min(min_accepted_step, alpha)\n            \n            # --- Update t for the next outer iteration ---\n            t *= MU\n\n        return [total_newton_steps, max_condition_number, min_accepted_step]\n\n    # --- Main Execution ---\n    test_cases = [0.5, 0.1, 0.01, 0.001]\n    \n    # Store results from each test case\n    results = []\n    for theta in test_cases:\n        res = solve_for_theta(theta)\n        results.append(res)\n    \n    # Format the output string exactly as required\n    formatted_results = []\n    for res in results:\n        # Format: [integer, float, float]\n        formatted_sublist = f\"[{res[0]},{res[1]},{res[2]}]\"\n        formatted_results.append(formatted_sublist)\n    final_output_string = f\"[{','.join(formatted_results)}]\"\n    \n    print(final_output_string)\n\n# Run the main solver\nsolve()\n```", "id": "3107306"}, {"introduction": "这最后一个练习通过对比中心路径与最终最优解，阐明了内点法的一个决定性特征。您将求解一个定义在超立方体上的简单线性规划，其精确解已知位于顶点上。通过计算中心路径上的一个点，您将观察到该点严格位于可行域的内部，这突显了其基本特性：中心路径提供了通往最优解的途径，但永远不会在有限步内到达边界顶点 [@problem_id:3107367]。", "problem": "考虑在 $\\ell_{\\infty}$ 球上最小化线性目标的线性优化问题。设 $n \\in \\mathbb{N}$ 为维度，$r \\in \\mathbb{R}_{0}$ 为球半径，$c \\in \\mathbb{R}^{n}$ 为目标系数向量。问题是在约束 $\\lVert x \\rVert_{\\infty} \\le r$ 下最小化 $c^{\\top} x$，这等价于对所有 $i \\in \\{1,\\dots,n\\}$ 的 $2n$ 个线性不等式组 $-r \\le x_i \\le r$。除非 $c$ 的某个分量为零，否则该线性规划的精确解位于超立方体 $\\{-r,r\\}^{n}$ 的一个顶点上。\n\n本任务是使用对数障碍和路径跟踪法实现中心路径计算，然后数值上检验中心路径如何避开顶点，而精确解却位于顶点上。使用以下基本原理：\n- $\\ell_{\\infty}$ 球 $\\{x \\in \\mathbb{R}^{n} : \\lVert x \\rVert_{\\infty} \\le r\\}$ 是所有 $i \\in \\{1,\\dots,n\\}$ 的不等式 $x_i \\le r$ 和 $-x_i \\le r$ 的交集。\n- 一个不等式 $a^{\\top} x \\le b$ 的对数障碍是 $-\\log(b - a^{\\top} x)$，当松弛量 $b - a^{\\top} x$ 从正侧趋近于 $0$ 时，该值趋向于 $+\\infty$。\n- 中心路径由严格凸的障碍增广目标对 $t \\in \\mathbb{R}_{0}$ 的唯一最小化子 $x(t)$ 定义，该路径从一个内点开始，并在所有有限 $t$ 值下都保持在内部。\n\n从这些原则出发，不要使用任何快捷公式。从头开始推导所需内容。具体而言：\n1. 针对 $\\ell_{\\infty}$ 球约束重新表述障碍问题。说明障碍函数如何增广目标 $c^{\\top} x$，并解释为什么所得函数是严格凸的，且仅在 $\\lVert x \\rVert_{\\infty}  r$ 时为有限值。\n2. 推导中心路径点 $x(t)$ 的平稳性条件，并实现一个阻尼牛顿法来求解给定 $t$ 下的非线性系统。通过选择合适的步长，确保该方法在每次迭代中都保持可行性，即 $\\lVert x \\rVert_{\\infty}  r$。\n3. 仅使用关于箱型区域上线性目标的基本推理，计算原始线性规划的精确解 $x^{\\star}$。以科学合理的方式处理某些 $c_i = 0$ 的情况。\n4. 对于每个测试用例，在计算出中心路径点 $x(t)$ 后，报告：\n   - $x(t)$ 到超立方体 $\\{-r,r\\}^{n}$ 最近顶点的欧几里得距离，以实数形式表示。\n   - 目标间隙 $c^{\\top} x(t) - c^{\\top} x^{\\star}$，以实数形式表示。\n   - 一个布尔值，如果 $\\max_i |x_i(t)|  r$ 则为真，否则为假，表示对于所选的有限 $t$，中心路径点是否严格避开边界（从而避开顶点）。\n\n您的程序必须实现阻尼牛顿法，并为以下参数值的测试套件生成输出：\n- 测试用例 1：$n = 2$，$r = 0.2$，$c = (1,2)$，$t = 5$。\n- 测试用例 2：$n = 2$，$r = 0.2$，$c = (1,2)$，$t = 100$。\n- 测试用例 3：$n = 3$，$r = 0.1$，$c = (1,-0.5,3)$，$t = 20$。\n- 测试用例 4：$n = 3$，$r = 0.1$，$c = (1,0,1)$，$t = 20$。\n- 测试用例 5：$n = 2$，$r = 0.05$，$c = (-1,-1)$，$t = 50$。\n\n此问题中没有物理量，因此不需要物理单位。没有出现角度，因此不需要角度单位。不使用百分比。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试用例的结果必须是 $[d, g, b]$ 形式的列表，其中 $d$ 是到最近顶点的欧几里得距离，$g$ 是目标间隙，$b$ 是内点布尔值。例如，输出应为 $[[d_1,g_1,b_1],[d_2,g_2,b_2],\\dots]$ 的形式。", "solution": "该问题要求为 $\\ell_{\\infty}$ 球上的线性规划实现中心路径和路径跟踪法。我们必须从第一性原理出发推导必要的组成部分，并使用阻尼牛顿法进行计算。\n\n### 1. 问题重构与障碍函数\n\n线性优化问题是在约束 $\\lVert x \\rVert_{\\infty} \\le r$ 下最小化目标函数 $f_0(x) = c^{\\top}x$，其中 $x \\in \\mathbb{R}^n$。这里，$c \\in \\mathbb{R}^n$ 是目标系数向量，$r \\in \\mathbb{R}_{0}$ 是球的半径。\n\n约束 $\\lVert x \\rVert_{\\infty} \\le r$ 等价于 $2n$ 个线性不等式组：\n$x_i \\le r, \\quad \\text{对于 } i \\in \\{1,\\dots,n\\}$\n$-x_i \\le r, \\quad \\text{对于 } i \\in \\{1,\\dots,n\\}$\n\n这组不等式的对数障碍函数 $\\Phi(x)$ 是各单个障碍之和：\n$$ \\Phi(x) = \\sum_{i=1}^{n} \\left( -\\log(r - x_i) - \\log(r - (-x_i)) \\right) = - \\sum_{i=1}^{n} \\log(r^2 - x_i^2) $$\n$\\Phi(x)$ 的定义域是所有使对数参数为正的点集，即对所有 $i$ 都有 $r^2 - x_i^2 > 0$。此条件等价于对所有 $i$ 都有 $|x_i|  r$，或 $\\lVert x \\rVert_{\\infty}  r$。这是可行集的严格内部。当任何 $x_i$ 趋近于 $r$ 或 $-r$ 时，项 $\\log(r^2 - x_i^2)$ 趋近于 $-\\infty$，因此 $\\Phi(x)$ 趋近于 $+\\infty$。\n\n中心路径由参数 $t > 0$ 的障碍增广目标函数的最小化子 $x(t)$ 定义：\n$$ F(x, t) = c^{\\top}x + \\frac{1}{t}\\Phi(x) = c^{\\top}x - \\frac{1}{t}\\sum_{i=1}^{n} \\log(r^2 - x_i^2) $$\n此函数仅在可行集的严格内部 $\\{x \\in \\mathbb{R}^n : \\lVert x \\rVert_{\\infty}  r\\}$ 上有定义且为有限值。\n\n为了证明 $F(x, t)$ 是严格凸的，我们分析其 Hessian 矩阵。目标 $c^{\\top}x$ 是线性的，因此是凸的。我们考察障碍项的凸性。设 $\\phi(x) = -\\frac{1}{t} \\sum_{i=1}^n \\log(r^2 - x_i^2)$。二阶偏导数为：\n$$ \\frac{\\partial^2 \\phi}{\\partial x_j \\partial x_k} = 0 \\quad \\text{对于 } j \\neq k $$\n$$ \\frac{\\partial^2 \\phi}{\\partial x_j^2} = -\\frac{1}{t} \\frac{\\partial^2}{\\partial x_j^2} \\log(r^2 - x_j^2) = -\\frac{1}{t} \\frac{\\partial}{\\partial x_j} \\left( \\frac{-2x_j}{r^2 - x_j^2} \\right) = \\frac{2}{t} \\frac{(r^2 - x_j^2) - x_j(-2x_j)}{(r^2-x_j^2)^2} = \\frac{2}{t} \\frac{r^2 + x_j^2}{(r^2 - x_j^2)^2} $$\n因为 $t>0$，$r>0$，且 $|x_j|  r$，所以项 $\\frac{\\partial^2 \\phi}{\\partial x_j^2}$ 是严格为正的。因此，$\\phi(x)$ 的 Hessian 矩阵是一个对角线上元素严格为正的对角矩阵，这意味着它是正定的。因此，$\\phi(x)$ 是一个严格凸函数。一个凸函数（$c^{\\top}x$）与一个严格凸函数（$\\phi(x)$）之和是严格凸的。凸集上的严格凸函数有唯一的最小化子。\n\n### 2. 中心路径平稳性与牛顿法\n\n中心路径上的点 $x(t)$ 是 $F(x, t)$ 的唯一最小化子。为了找到它们，我们将 $F(x,t)$ 关于 $x$ 的梯度设为零（平稳性条件）：\n$$ \\nabla_x F(x, t) = \\nabla_x \\left( c^{\\top}x - \\frac{1}{t}\\sum_{i=1}^{n} \\log(r^2 - x_i^2) \\right) = 0 $$\n梯度向量 $\\nabla_x F(x, t)$ 的分量为：\n$$ (\\nabla_x F(x, t))_j = c_j - \\frac{1}{t} \\frac{-2x_j}{r^2 - x_j^2} = c_j + \\frac{2x_j}{t(r^2 - x_j^2)} $$\n我们必须解非线性方程组 $\\nabla_x F(x, t) = 0$ 来求 $x$。阻尼牛顿法是为此目的的一种迭代过程。从点 $x_k$ 开始，下一个迭代点是 $x_{k+1} = x_k + \\alpha_k \\Delta x_k$，其中 $\\Delta x_k$ 是牛顿步长，$\\alpha_k$ 是步长大小。\n\n牛顿步长 $\\Delta x_k$ 通过求解线性系统得到：\n$$ \\nabla^2 F(x_k, t) \\Delta x_k = - \\nabla F(x_k, t) $$\n其中 $\\nabla^2 F(x_k, t)$ 是 $F(x,t)$ 在 $x_k$ 处的 Hessian 矩阵。如前所述，Hessian 矩阵是一个对角矩阵，其对角元素为：\n$$ (\\nabla^2 F(x, t))_{jj} = \\frac{2}{t} \\frac{r^2 + x_j^2}{(r^2 - x_j^2)^2} $$\n由于 Hessian 矩阵是对角的，系统解耦，牛顿步长的分量很容易计算：\n$$ (\\Delta x_k)_j = - \\frac{(\\nabla F(x_k, t))_j}{(\\nabla^2 F(x_k, t))_{jj}} $$\n步长 $\\alpha_k \\in (0, 1]$ 通过回溯线搜索来选择，以确保两个条件：\n1.  **可行性**：下一个迭代点 $x_{k+1}$ 必须保持严格可行，即 $\\lVert x_k + \\alpha_k \\Delta x_k \\rVert_{\\infty}  r$。\n2.  **充分下降**：步长必须提供目标函数值的充分下降，通常通过 Armijo 条件强制执行：$F(x_k + \\alpha_k \\Delta x_k, t) \\le F(x_k, t) + \\gamma \\alpha_k \\nabla F(x_k, t)^{\\top} \\Delta x_k$，其中 $\\gamma \\in (0, 0.5)$ 是一个小常数。\n\n迭代过程从一个严格可行点开始，例如 $x_0 = 0$，并持续进行，直到梯度范数 $\\lVert \\nabla F(x_k, t) \\rVert_2$ 低于某个容差，表明已找到一个平稳点。\n\n### 3. 线性规划的精确解\n\n原始问题是在对所有 $i$ 满足 $-r \\le x_i \\le r$ 的约束下最小化 $\\sum_{i=1}^n c_i x_i$。目标和约束是可分离的。每个分量 $c_i x_i$ 对总和的贡献可以独立最小化。\n要最小化区间 $[-r, r]$ 上的 $c_i x_i$：\n- 如果 $c_i > 0$，当 $x_i$ 取负最大值时达到最小值，所以 $x_i^{\\star} = -r$。\n- 如果 $c_i  0$，当 $x_i$ 取正最大值时达到最小值，所以 $x_i^{\\star} = r$。\n- 如果 $c_i = 0$，项 $c_i x_i$ 总是 $0$，因此该分量的任何 $x_i \\in [-r, r]$ 都是最优的。最优解集是超立方体的一个面。\n\n无论当某些 $c_i=0$ 时 $x^\\star$ 是否唯一，最优目标值 $p^{\\star} = c^{\\top}x^{\\star}$ 都是唯一的。它可以计算为：\n$$ p^{\\star} = \\sum_{i: c_i > 0} c_i(-r) + \\sum_{i: c_i  0} c_i(r) = -r \\sum_{i: c_i > 0} c_i + r \\sum_{i: c_i  0} c_i = -r \\left( \\sum_{i: c_i > 0} |c_i| + \\sum_{i: c_i  0} |c_i| \\right) = -r \\sum_{i=1}^n |c_i| $$\n\n### 4. 所需计算\n\n对于每个测试用例，在计算出中心路径点 $x(t)$ 后，我们确定以下量：\n\n- **到最近顶点的欧几里得距离 ($d$)**：可行超立方体的顶点是 $\\{-r, r\\}^n$ 中的点。对于一个给定的点 $x(t)$，在欧几里得距离上最近的顶点 $v^{\\star}$ 是通过将每个分量 $v^{\\star}_i$ 设置为 $-r$ 或 $r$ 中较近的一个来找到的。即 $v^{\\star}_i = r \\cdot \\text{sign}(x_i(t))$（按惯例，$\\text{sign}(0)$ 为 $1$ 或 $-1$，这里取为正）。距离是 $d = \\lVert x(t) - v^{\\star} \\rVert_2$。\n\n- **目标间隙 ($g$)**：这是中心路径点处的目标值与真实最优值之间的差：$g = c^{\\top}x(t) - p^{\\star}$。\n\n- **内点布尔值 ($b$)**：如果计算出的点 $x(t)$ 严格位于可行区域内，即 $\\max_i |x_i(t)|  r$，则此布尔值为 `true`，否则为 `false`。对于有限的 $t$ 和正确的实现，此值应始终为 `true`。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the specified optimization problems using a damped Newton method\n    for the central path and computes the required metrics.\n    \"\"\"\n    \n    test_cases = [\n        {'n': 2, 'r': 0.2, 'c': np.array([1, 2]), 't': 5},\n        {'n': 2, 'r': 0.2, 'c': np.array([1, 2]), 't': 100},\n        {'n': 3, 'r': 0.1, 'c': np.array([1, -0.5, 3]), 't': 20},\n        {'n': 3, 'r': 0.1, 'c': np.array([1, 0, 1]), 't': 20},\n        {'n': 2, 'r': 0.05, 'c': np.array([-1, -1]), 't': 50}\n    ]\n\n    results = []\n\n    for case in test_cases:\n        n, r, c, t = case['n'], case['r'], case['c'], case['t']\n\n        # --- Damped Newton Method to find x(t) ---\n        \n        def F(x, t_p, c_p, r_p):\n            # Barrier augmented objective function\n            if np.max(np.abs(x)) >= r_p:\n                return np.inf\n            return c_p.T @ x - (1/t_p) * np.sum(np.log(r_p**2 - x**2))\n\n        def grad_F(x, t_p, c_p, r_p):\n            # Gradient of F\n            return c_p + (2 / t_p) * (x / (r_p**2 - x**2))\n\n        def Hess_F_diag(x, t_p, c_p, r_p):\n            # Diagonal of the Hessian of F\n            return (2 / t_p) * (r_p**2 + x**2) / (r_p**2 - x**2)**2\n\n        # Newton method parameters\n        x_t = np.zeros(n)\n        max_iter = 100\n        tolerance = 1e-9\n        \n        # Backtracking line search parameters\n        alpha = 1.0\n        beta = 0.5  # backtracking factor\n        gamma = 0.01 # Armijo condition parameter\n\n        for _ in range(max_iter):\n            grad = grad_F(x_t, t, c, r)\n            \n            # Check for convergence\n            if np.linalg.norm(grad) = tolerance:\n                break\n            \n            hess_diag = Hess_F_diag(x_t, t, c, r)\n            delta_x = -grad / hess_diag\n            \n            # Backtracking line search\n            alpha = 1.0\n            m = gamma * grad.T @ delta_x # Precompute for Armijo condition\n            f_x = F(x_t, t, c, r)\n            \n            while True:\n                x_new = x_t + alpha * delta_x\n                # Check feasibility first, as F is undefined outside\n                if np.max(np.abs(x_new)) >= r:\n                    alpha *= beta\n                    continue\n                # Check Armijo condition\n                if F(x_new, t, c, r) = f_x + alpha * m:\n                    break\n                else:\n                    alpha *= beta\n\n            x_t += alpha * delta_x\n\n        # --- Exact Solution Calculation ---\n        p_star = -r * np.sum(np.abs(c))\n\n        # --- Compute required outputs ---\n        \n        # 1. Distance d to the nearest vertex\n        # The nearest vertex v_star has components r*sign(x_i)\n        v_star = np.where(x_t >= 0, r, -r)\n        d = np.linalg.norm(x_t - v_star)\n        \n        # 2. Objective gap g\n        g = c.T @ x_t - p_star\n        \n        # 3. Interior boolean b\n        b = np.max(np.abs(x_t))  r\n\n        results.append([d, g, b])\n\n    # --- Format final output string ---\n    formatted_results = []\n    for res in results:\n        # Format boolean as lowercase 'true'/'false'\n        formatted_res = f\"[{res[0]},{res[1]},{str(res[2]).lower()}]\"\n        formatted_results.append(formatted_res)\n\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3107367"}]}