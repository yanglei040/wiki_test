## 引言
在[数学优化](@entry_id:165540)领域，非线性约束优化问题构成了众多科学与工程挑战的核心。这些问题因其[目标函数](@entry_id:267263)和约束条件的复杂性，往往难以直接求解。序列二次规划（Sequential Quadratic Programming, SQP）方法应运而生，它作为一种[迭代算法](@entry_id:160288)，为解决这类难题提供了极其强大和高效的框架。SQP的精髓在于化繁为简：它并非试图一步到位地解决复杂的原始问题，而是通过一系列逻辑清晰的步骤，在当前解的附近构建并求解一个更简单的二次规划（QP）近似模型，从而逐步逼近最优解。

本文旨在对序列二次规划方法进行一次系统而全面的介绍。我们将从其基本原理出发，深入剖析其算法机制，并展示其在不同学科中的广泛应用。通过阅读本文，您将：

*   在“原理与机制”一章中，理解SQP如何构建QP子问题，其与[牛顿法](@entry_id:140116)的深刻理论联系，以及保证算法稳健运行的[全局化策略](@entry_id:177837)。
*   在“应用与跨学科联系”一章中，探索SQP在[几何优化](@entry_id:151817)、[最优控制](@entry_id:138479)、电力系统、[金融工程](@entry_id:136943)等真实世界问题中的强大威力，了解理论如何转化为实践。
*   最后，在“动手实践”部分，通过具体的计算练习，亲手实践SQP的核心步骤，巩固所学知识，并洞察算法在实际操作中可能遇到的问题。

让我们一同开启这段旅程，揭开序列二次规划这一现代优化基石的奥秘。

## 原理与机制

本章旨在深入剖析序列二次规划（Sequential Quadratic Programming, SQP）方法的基本原理与核心机制。作为求解非线性[约束优化](@entry_id:635027)问题的最强大、最流行的方法之一，SQP通过一系列逻辑清晰的步骤，将一个复杂的原始问题转化为一列易于处理的子问题。我们将从其基本思想出发，系统地构建SQP的迭代框架，并探讨其理论基础、实际实现中的关键技术以及保证[算法稳健性](@entry_id:635315)的[全局化策略](@entry_id:177837)。

### 核心思想：序列化近似

求解一个一般的[非线性规划](@entry_id:636219)（Nonlinear Program, NLP）问题，即在满足一组[非线性](@entry_id:637147)等式和[不等式约束](@entry_id:176084)的条件下，最小化一个[非线性](@entry_id:637147)[目标函数](@entry_id:267263)，是一项极具挑战性的任务。SQP方法的核心思想并非试图“一步到位”地解决这个复杂问题，而是采用一种迭代的、不断逼近的策略。

在每一次迭代中，SQP方法会在当前解的估计点 $x_k$ 附近，为原始的NL[P问题](@entry_id:267898)构建一个简化的、局部的“模型”。这个模型被设计成一个二次规划（Quadratic Program, QP）问题，因为Q[P问题](@entry_id:267898)（即[目标函数](@entry_id:267263)为二次函数，约束条件为线性函数）已经有非常成熟和高效的求解算法。通过求解这个QP子问题，我们并非直接得到原问题的解，而是获得一个最有希望的**搜索方向** $p_k$ [@problem_id:2201997]。这个方向指明了从当前点 $x_k$ 出发，如何移动才能最有效地逼近原问题的解。随后，算法会沿着这个方向进行线搜索，确定一个合适的步长 $\alpha_k$，最终更新迭代点为 $x_{k+1} = x_k + \alpha_k p_k$。这个“建模-求解-更新”的过程被不断重复，形成一个“序列”，直至最终收敛到满足精度要求的解。因此，方法的名称“序列二次规划”精准地概括了其本质。

### 构建二次规划（QP）子问题

构建QP子问题的过程，是SQP方法的技术核心。它涉及到如何对原始NLP的目标函数和约束条件进行合理的二次和线性近似。

#### [拉格朗日函数](@entry_id:174593)：信息的融合

在约束优化中，目标函数 $f(x)$ 和约束函数（例如 $h(x)=0, g(x) \le 0$）并非独立存在。为了在一个统一的框架内同时处理目标和约束，我们引入**[拉格朗日函数](@entry_id:174593)**（Lagrangian function）。对于一个给定的NL[P问题](@entry_id:267898)，其[拉格朗日函数](@entry_id:174593) $\mathcal{L}(x, \lambda, \mu)$ 定义为[目标函数](@entry_id:267263)与约束函[数乘](@entry_id:155971)以其对应拉格朗日乘子（Lagrange multiplier）的[线性组合](@entry_id:154743)。

例如，对于如下形式的[优化问题](@entry_id:266749) [@problem_id:2202030]：
最小化 $f(x_1, x_2) = \exp(x_1) + x_1 x_2^2 + 3x_2$
满足约束 $h(x_1, x_2) = x_1^2 + \sin(x_2) - 5 = 0$
以及 $g(x_1, x_2) = x_1 + x_2 - 2 \le 0$

其对应的拉格朗日函数为：
$\mathcal{L}(x_1, x_2, \lambda, \mu) = f(x_1, x_2) + \lambda h(x_1, x_2) + \mu g(x_1, x_2)$
$= \exp(x_1) + x_1 x_2^2 + 3x_2 + \lambda(x_1^2 + \sin(x_2) - 5) + \mu(x_1 + x_2 - 2)$

其中 $\lambda$ 和 $\mu$ 分别是[等式约束](@entry_id:175290)和[不等式约束](@entry_id:176084)的拉格朗日乘子。[拉格朗日函数](@entry_id:174593)之所以重要，是因为最优解的[一阶必要条件](@entry_id:170730)（[KKT条件](@entry_id:185881)）可以直接通过其梯度来表达。SQP方法巧妙地利用了这一点，它在QP子问题中近似的并非原始目标函数 $f(x)$，而是更为关键的[拉格朗日函数](@entry_id:174593) $\mathcal{L}(x, \lambda, \mu)$。

#### 约束的线性化

为了使子问题具有线性的约束结构，SQP方法将原始问题中的所有非[线性约束](@entry_id:636966)在当前迭代点 $x_k$ 进行一阶泰勒展开。对于一个[等式约束](@entry_id:175290) $c(x)=0$，其在 $x_k$ 处的线性近似为：
$c(x) \approx c(x_k) + \nabla c(x_k)^T (x - x_k)$

令步长 $p = x - x_k$，则该近似约束可以写成一个关于 $p$ 的线性方程：
$\nabla c(x_k)^T p + c(x_k) = 0$

这个线性化步骤是SQP方法能够成立的基石。其主要的计算动机在于，只有将所有非[线性约束](@entry_id:636966)都转化为[线性形式](@entry_id:276136)，整个子问题才能被构建为一个标准的二次规划（QP）问题，从而可以利用现成的、高效的QP求解器来解决 [@problem_id:2202046]。

#### 目标函数的二次近似

在QP子问题中，[目标函数](@entry_id:267263)是对拉格朗日函数 $\mathcal{L}(x, \lambda_k)$ 在 $x_k$ 点的二次近似。令 $p = x - x_k$，这个近似可以写作：
$\mathcal{L}(x_k + p, \lambda_k) \approx \mathcal{L}(x_k, \lambda_k) + \nabla_x \mathcal{L}(x_k, \lambda_k)^T p + \frac{1}{2} p^T \nabla_{xx}^2 \mathcal{L}(x_k, \lambda_k) p$

在QP子问题的[目标函数](@entry_id:267263)中，常数项 $\mathcal{L}(x_k, \lambda_k)$ 不影响最优解 $p$，因此可以忽略。$\nabla_x \mathcal{L}(x_k, \lambda_k)$ 是拉格朗日函数在 $(x_k, \lambda_k)$ 对 $x$ 的梯度，而 $\nabla_{xx}^2 \mathcal{L}(x_k, \lambda_k)$ 则是其Hessian矩阵。因此，在第 $k$ 次迭代，SQP方法构建并求解如下的QP子问题：

$\min_{p} \quad \nabla f(x_k)^T p + \frac{1}{2} p^T B_k p$
满足 $\nabla h(x_k)^T p + h(x_k) = 0$
$\nabla g(x_k)^T p + g(x_k) \le 0$

这里，[目标函数](@entry_id:267263)中的梯度项通常直接使用原始[目标函数](@entry_id:267263)的梯度 $\nabla f(x_k)$（因为 $\nabla_x \mathcal{L}(x_k, \lambda_k)^T p$ 和 $\nabla f(x_k)^T p$ 之间可以通过约束的线性化建立联系，这简化了表达）。矩阵 $B_k$ 是对拉格朗日函数Hessian矩阵 $\nabla_{xx}^2 \mathcal{L}(x_k, \lambda_k)$ 的一个（精确或近似的）表示。

### SQP迭代步：求解QP子问题

一旦QP子问题被构建，下一步就是求解它以获得搜索方向 $p_k$ 和新的[拉格朗日乘子](@entry_id:142696)估计。

#### QP子问题的[KKT条件](@entry_id:185881)

求解上述QP子问题等价于求解其自身的[KKT条件](@entry_id:185881)。对于一个仅含[等式约束](@entry_id:175290)的QP子问题（为简化表达），其[KKT系统](@entry_id:751047)是一个线性方程组。例如，考虑问题 [@problem_id:2202032]：
最小化 $f(x_1, x_2) = x_1^2 + \exp(x_2)$
满足 $c(x_1, x_2) = x_1^2 + x_2^2 - 1 = 0$

从初始点 $x_0 = (1, 1)^T$ 开始，并使用[单位矩阵](@entry_id:156724) $B_0 = I$ 作为Hessian近似，QP子问题为：
$\min_{p} \quad \nabla f(x_0)^T p + \frac{1}{2} p^T I p$
满足 $\nabla c(x_0)^T p + c(x_0) = 0$

计算在 $x_0=(1,1)^T$ 的相关量：
$\nabla f(x_0) = \begin{pmatrix} 2 \\ e \end{pmatrix}$, $c(x_0) = 1^2 + 1^2 - 1 = 1$, $\nabla c(x_0) = \begin{pmatrix} 2 \\ 2 \end{pmatrix}$

该QP子问题的[KKT条件](@entry_id:185881)可以写成一个关于步长 $p_0$ 和QP乘子 $\lambda_{QP}$ 的[线性系统](@entry_id:147850)：
$I p_0 + \nabla f(x_0) + \nabla c(x_0) \lambda_{QP} = 0$
$\nabla c(x_0)^T p_0 + c(x_0) = 0$

将具体数值代入，即：
$\begin{pmatrix} p_1 \\ p_2 \end{pmatrix} + \begin{pmatrix} 2 \\ e \end{pmatrix} + \begin{pmatrix} 2 \\ 2 \end{pmatrix} \lambda_{QP} = 0$
$2p_1 + 2p_2 + 1 = 0$

求解这个线性系统，就可以得到第一个SQP迭代的搜索方向 $p_0 = \begin{pmatrix} \frac{2e - 5}{4} \\ \frac{3 - 2e}{4} \end{pmatrix}$。这个计算过程清晰地展示了SQP迭代步的核心计算任务：构建并求解一个[线性系统](@entry_id:147850)。

### 理论核心：SQP与牛顿法的深刻联系

SQP方法之所以如此高效，其背后有着深刻的理论根源：它与功能强大的牛顿法（Newton's method）紧密相关。

#### [KKT条件](@entry_id:185881)的[牛顿法](@entry_id:140116)视角

一个非线性约束优化问题的最优解 $(x^*, \lambda^*)$ 必须满足其[KKT条件](@entry_id:185881)。对于仅含[等式约束](@entry_id:175290) $h(x)=0$ 的问题，[KKT条件](@entry_id:185881)是：
$\nabla_x \mathcal{L}(x, \lambda) = \nabla f(x) + \nabla h(x) \lambda = 0$
$h(x) = 0$

这是一个关于变量 $(x, \lambda)$ 的非线性方程组。我们可以使用[牛顿法](@entry_id:140116)来求解这个[方程组](@entry_id:193238)。将该系统记为 $F(x, \lambda) = 0$，[牛顿法](@entry_id:140116)的每一步都需要求解一个[线性系统](@entry_id:147850)：
$J_F(x_k, \lambda_k) \begin{pmatrix} p_k \\ q_k \end{pmatrix} = -F(x_k, \lambda_k)$
其中 $J_F$ 是 $F$ 的雅可比矩阵，$p_k = x_{k+1}-x_k$ 是原始变量的步长，$q_k = \lambda_{k+1}-\lambda_k$ 是乘子的步长。

展开这个雅可比矩阵，我们得到：
$\begin{pmatrix} \nabla_{xx}^2 \mathcal{L}(x_k, \lambda_k)  \nabla h(x_k) \\ \nabla h(x_k)^T  0 \end{pmatrix} \begin{pmatrix} p_k \\ \lambda_{k+1} \end{pmatrix} = -\begin{pmatrix} \nabla f(x_k) \\ h(x_k) \end{pmatrix}$
(这里对 $\lambda_{k+1}$ 的定义稍有调整以简化形式)

惊人的是，这个[线性系统](@entry_id:147850)与我们之[前推](@entry_id:158718)导的、使用**精确拉格朗日Hessian矩阵** ($B_k = \nabla_{xx}^2 \mathcal{L}(x_k, \lambda_k)$) 的SQP子问题的[KKT条件](@entry_id:185881)是完[全等](@entry_id:273198)价的 [@problem_id:2202015]。这意味着，当使用精确的二阶信息时，SQP方法本质上就是在对原始问题的[KKT条件](@entry_id:185881)应用[牛顿法](@entry_id:140116)。

这一联系揭示了SQP方法的威力来源。它继承了牛顿法在解附近的快速收敛特性。当算法的迭代点足够接近最优解时，采用精确Hessian矩阵的SQP方法将表现出**二次收敛**（quadratic convergence）速率，即每一步迭代的误差大约是上一步误差的平方，[收敛速度](@entry_id:636873)极快。

### 实用算法：拟牛顿SQP

尽管基于精确Hessian的SQP方法理论上非常优美，但在实际应用中，计算和存储[拉格朗日函数](@entry_id:174593)的Hessian矩阵 $\nabla_{xx}^2 \mathcal{L}$ 可能非常昂贵，甚至解析表达式都难以获得。为了克服这一障碍，实用的SQP算法通常采用**拟牛顿法**（Quasi-Newton methods）来近似这个Hessian矩阵。

#### [拉格朗日函数](@entry_id:174593)Hessian矩阵的近似

[拟牛顿法](@entry_id:138962)的核心思想是，不直接计算Hessian矩阵，而是通过迭代过程中收集到的[一阶导数](@entry_id:749425)（梯度）信息，来逐步构建和更新一个Hessian矩阵的近似 $B_k$。最著名的更新公式之一是**BFGS** (Broyden–Fletcher–Goldfarb–Shanno) 公式：
$B_{k+1} = B_k - \frac{B_k s_k s_k^T B_k}{s_k^T B_k s_k} + \frac{y_k y_k^T}{y_k^T s_k}$

这里的关键在于如何定义向量 $s_k$ 和 $y_k$。在SQP的背景下，它们被定义为：
- $s_k = x_{k+1} - x_k$：[原始变量](@entry_id:753733)的步长。
- $y_k = \nabla_x \mathcal{L}(x_{k+1}, \lambda_{k+1}) - \nabla_x \mathcal{L}(x_k, \lambda_{k+1})$：**[拉格朗日函数](@entry_id:174593)梯度**的变化量。

注意 $y_k$ 的定义中使用了新的乘子估计 $\lambda_{k+1}$，这对于保证 $B_k$ 能很好地近似 $\nabla_{xx}^2 \mathcal{L}$ 至关重要。通过一个具体的例子可以更好地理解这个[更新过程](@entry_id:273573) [@problem_id:2202033]。

#### 收敛速度：[超线性收敛](@entry_id:141654)

使用BFGS等拟牛顿方法近似Hessian矩阵，虽然牺牲了二次收敛性，但带来了巨大的计算便利。这种拟牛顿SQP方法，在满足一定条件下，能够实现**[超线性收敛](@entry_id:141654)**（superlinear convergence）[@problem_id:2201981]。[超线性收敛](@entry_id:141654)意味着误差比率 $\|x_{k+1}-x^*\| / \|x_k-x^*\|$ 趋向于0，其[收敛速度](@entry_id:636873)虽然慢于二次收敛，但远快于[线性收敛](@entry_id:163614)。对于大多数实际问题而言，这已经是一个非常理想的收敛性能。

### [全局化策略](@entry_id:177837)：确保算法的稳健性

SQP方法（无论是精确Hessian还是拟牛顿版本）的快速收敛特性通常只在迭代点足够接近最优解时（即局部）才能得到保证。如果初始点 $x_0$ 离最优解很远，单纯的SQP步长 $p_k$（特别是当步长为1时）可能导致迭代发散。为了确保算法从任意初始点都能稳定地走向解，必须引入**[全局化策略](@entry_id:177837)**。

#### [价值函数](@entry_id:144750) (Merit Function)

全局化的核心工具是**价值函数**（merit function）。在[约束优化](@entry_id:635027)中，我们有两个相互竞争的目标：一是降低目标函数 $f(x)$ 的值，二是减小约束违反度（例如 $\|c(x)\|$）。一个好的迭代步应该在这两个目标上都取得进展。然而，有时一步可以显著降低目标函数值，却增大了约束违反；反之亦然。

价值函数的作用就是将这两个目标组合成一个单一的标量函数，用以衡量一个点的“优劣”程度。它的主要目的，是提供一个复合度量，平衡降低目标函数值和满足非[线性约束](@entry_id:636966)这两个目标，从而指导[线搜索](@entry_id:141607)过程，找到一个即使从不可行点出发也能代表总体进展的步长 [@problem_id:2202029]。

#### $l_1$价值函数与罚参数

一个常用且理论性质良好的价值函数是 $l_1$ 价值函数，其形式为：
$\phi_1(x; \rho) = f(x) + \rho \sum_{i} |c_i(x)| + \rho \sum_{j} \max(0, g_j(x))$

其中 $\rho > 0$ 是一个**罚参数**（penalty parameter）。这个参数至关重要，它控制了对约束违反的惩罚权重。如果 $\rho$ 太小，算法可能会过分关注最小化 $f(x)$ 而忽略约束；如果 $\rho$ 太大，算法则可能只顾满足约束而忽略了目标函数。

一个关键的要求是，由QP子问题产生的搜索方向 $p_k$ 必须是价值函数在 $x_k$ 点的一个**下降方向**。理论分析表明，为了保证这一点，罚参数 $\rho$ 必须足够大。具体来说，对于[等式约束](@entry_id:175290)问题，需要满足 $\rho > \|\lambda_{k+1}\|_{\infty}$，其中 $\lambda_{k+1}$ 是从QP子问题中得到的乘子估计值 [@problem_id:2201986]。例如，如果某次迭代计算出的乘子估计为 $\lambda_{k+1} = (-2.5, 12.0)$，那么为了确保 $p_k$ 是 $l_1$ [价值函数](@entry_id:144750)的下降方向，罚参数 $\rho$ 必须大于 $\max(|-2.5|, |12.0|) = 12.0$。

#### [线搜索](@entry_id:141607)

一旦我们有了一个[价值函数](@entry_id:144750) $\phi(x; \rho)$ 和一个它的[下降方向](@entry_id:637058) $p_k$，我们就可以通过**[线搜索](@entry_id:141607)**（line search）来确定一个步长 $\alpha_k \in (0, 1]$。[线搜索](@entry_id:141607)的目标是寻找一个 $\alpha_k$，使得新的迭代点 $x_{k+1} = x_k + \alpha_k p_k$ 能够充分地降低[价值函数](@entry_id:144750)的值（例如，满足[Armijo条件](@entry_id:169106)）。这样就保证了每一步迭代都是有益的，从而引导整个算法序列走向全局最优解。

### 完整的迭代过程：[原始变量](@entry_id:753733)与[对偶变量](@entry_id:143282)的更新

总结起来，一个完整的SQP迭代步包含对原始变量 $x$ 和[对偶变量](@entry_id:143282)（拉格朗日乘子）$\lambda$ 的[同步更新](@entry_id:271465)。

1.  **给定** 当前迭代点 $(x_k, \lambda_k)$ 和Hessian近似 $B_k$。
2.  **构建QP子问题**：在 $x_k$ 处线性化约束，并使用 $B_k$ 构建[拉格朗日函数](@entry_id:174593)的二次模型。
3.  **求解QP子问题**：得到搜索方向 $p_k$ 和该子问题的拉格朗日乘子，后者作为原问题新乘子的一个估计，记为 $\lambda_{QP}$。
4.  **更新[拉格朗日乘子](@entry_id:142696)**：新的乘子估计 $\lambda_{k+1}$ 可以直接取 $\lambda_{QP}$，或者通过一个更新公式如 $\lambda_{k+1} = \lambda_k + q_k$ 得到，其中 $q_k$ 也来自于QP子问题的解 [@problem_id:2201973]。
5.  **全局化**：
    a.  如有必要，更新罚参数 $\rho$ 以确保 $\rho > \|\lambda_{k+1}\|_{\infty}$。
    b.  沿着方向 $p_k$ 进行[线搜索](@entry_id:141607)，寻找步长 $\alpha_k$ 以使[价值函数](@entry_id:144750) $\phi(x; \rho)$ 获得充分下降。
6.  **更新[原始变量](@entry_id:753733)**：计算新的迭代点 $x_{k+1} = x_k + \alpha_k p_k$。
7.  **更新Hessian近似**：使用 $s_k = x_{k+1} - x_k$ 和 $y_k = \nabla_x \mathcal{L}(x_{k+1}, \lambda_{k+1}) - \nabla_x \mathcal{L}(x_k, \lambda_{k+1})$，通过BFGS公式更新 $B_k$ 得到 $B_{k+1}$。

通过这一系列精巧而严谨的机制，SQP方法成功地将求解非[线性约束](@entry_id:636966)优化问题的复杂性分解，以一种高效、稳健且理论基础坚实的方式，逐步逼近问题的最优解。