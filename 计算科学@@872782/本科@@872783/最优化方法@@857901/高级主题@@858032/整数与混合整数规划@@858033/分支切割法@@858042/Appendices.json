{"hands_on_practices": [{"introduction": "理论知识需要通过实践来巩固。本节将从一个基本但至关重要的练习开始：从单纯形表中手动推导一个割平面。Gomory 分数割平面是一种通用的割平面，可以直接从导致分数解的任何约束行中生成。通过完成这个练习 [@problem_id:3104181]，您将深入理解割平面是如何利用整数变量的特性，从代数上“切掉”线性规划松弛问题的最优分数解，同时保留所有可行的整数解。", "problem": "考虑一个 $0$–$1$ 背包问题，其决策变量为 $x_{1}, x_{2}, x_{3}, x_{4} \\in \\{0,1\\}$，容量约束为 $\\sum_{i=1}^{4} w_{i} x_{i} \\leq W$，以及一个待最大化的线性目标 $\\sum_{i=1}^{4} p_{i} x_{i}$。在线性规划 (LP) 松弛中，变量边界 $x_{i} \\leq 1$ 被表示为等式 $x_{i} + s_{i} = 1$，其中 $s_{i} \\geq 0$ 是松弛变量。假设该 LP 松弛问题已通过单纯形表求解得到一个最优基本可行解 $\\hat{x}$，其中受整数约束的基变量是 $x_{3}$，其在表中的行为\n$$\nx_{3} + 2.75\\, s_{1} - 1.30\\, s_{2} + 0.45\\, s_{4} = 0.37462\n$$\n假设在此 LP 解中，该行中的非基松弛变量满足 $\\hat{s}_{1} = 0$, $\\hat{s}_{2} = 0$ 和 $\\hat{s}_{4} = 0$，因此基变量的值为 $\\hat{x}_{3} = 0.37462$，这是一个分数，因此对于 $0$–$1$ 背包问题是不可行的。\n\n仅使用整数变量、向下取整和分数部分运算的基本定义，以及单纯形表的结构，推导适用于形如 $x_{k} + \\sum_{j} a_{j} s_{j} = b_{k}$ 的混合整数表行的 Gomory 分数割，其中 $x_{k}$ 要求为整数，而 $s_{j} \\geq 0$ 是连续变量。然后，将此推导应用于给定的行以获得特定的割，并计算 LP 解 $\\hat{x}$ 违反此割的量；即，计算数量\n$$\n\\text{违反量} \\;=\\; \\text{RHS} \\;-\\; \\text{LHS 在 } \\hat{s} \\text{ 处的值}.\n$$\n将最终数值答案四舍五入至四位有效数字，并以无单位的纯数形式报告违反量。", "solution": "任务是为一个一般的混合整数规划问题推导 Gomory 分数割，然后将其应用于一个 $0$–$1$ 背包问题的特定单纯形表行。最后，我们必须计算当前线性规划 (LP) 松弛解违反此割的量。\n\n首先，我们推导 Gomory 混合整数割。\n考虑一个混合整数规划的 LP 松弛问题的最优单纯形表中的一个一般行：\n$$ x_{k} + \\sum_{j \\in N} a_{j} s_{j} = b_{k} $$\n在这个方程中，$x_k$ 是一个要求为整数的基变量。对于 $j \\in N$ 的变量 $s_j$ 是非基变量，假设它们是连续且非负的 ($s_j \\ge 0$)。在当前的基本可行解中，对于所有 $j \\in N$，$s_j=0$，这意味着 $x_k = b_k$。当 $b_k$ 不是整数时，问题就出现了，因为它违反了对 $x_k$ 的整数约束。\n\n令 $f_0$ 为 $b_k$ 的分数部分，定义为 $f_0 = b_k - \\lfloor b_k \\rfloor$。由于 $b_k$ 不是整数，我们有 $0  f_0  1$。通过分离出包含非基变量的项，可以将该表中的方程重写为：\n$$ \\sum_{j \\in N} a_{j} s_{j} = b_k - x_k $$\n代入 $b_k = \\lfloor b_k \\rfloor + f_0$，我们得到：\n$$ \\sum_{j \\in N} a_{j} s_{j} = \\lfloor b_k \\rfloor - x_k + f_0 $$\n对于混合整数问题的任何可行解，$x_k$ 必须是整数。由于 $\\lfloor b_k \\rfloor$ 也是整数，项 $I = \\lfloor b_k \\rfloor - x_k$ 必须是整数。因此方程变为：\n$$ \\sum_{j \\in N} a_{j} s_{j} = I + f_0, \\quad \\text{对于某个整数 } I $$\n为了继续推导，我们将非基变量的索引集 $N$ 划分为两个不相交的集合：$N^+ = \\{ j \\in N \\mid a_j \\ge 0 \\}$ 和 $N^- = \\{ j \\in N \\mid a_j  0 \\}$。然后方程为：\n$$ \\sum_{j \\in N^+} a_{j} s_{j} + \\sum_{j \\in N^-} a_{j} s_{j} = I + f_0 $$\n我们根据 $I$ 的整数值分析两种情况。\n\n情况 1：$I \\ge 0$。\n给定对于所有 $j$，$s_j \\ge 0$，且对于 $j \\in N^-$，$a_j  0$，则项 $\\sum_{j \\in N^-} a_{j} s_{j}$ 必须为非正数 ($\\le 0$)。因此，我们可以写出：\n$$ \\sum_{j \\in N^+} a_{j} s_{j} \\ge I + f_0 $$\n由于 $I$ 是一个整数且 $I \\ge 0$，右侧在 $I=0$ 时最小化。这给出 $I+f_0 \\ge f_0$。因此，在这种情况下，任何可行的整数解都必须满足：\n$$ \\sum_{j \\in N^+} a_{j} s_{j} \\ge f_0 $$\n\n情况 2：$I \\le -1$。\n给定对于所有 $j$，$s_j \\ge 0$，且对于 $j \\in N^+$，$a_j \\ge 0$，则项 $\\sum_{j \\in N^+} a_{j} s_{j}$ 必须为非负数 ($\\ge 0$)。因此，我们有：\n$$ \\sum_{j \\in N^-} a_{j} s_{j} \\le I + f_0 $$\n由于 $0  f_0  1$，项 $f_0 - 1$ 是负数。将不等式乘以负数 $\\frac{f_0}{f_0-1}$ 会反转不等号：\n$$ \\frac{f_0}{f_0 - 1} \\sum_{j \\in N^-} a_{j} s_{j} \\ge \\frac{f_0}{f_0 - 1} (I + f_0) $$\n对于右侧，由于 $I$ 是整数且 $I \\le -1$，我们有 $I + f_0 \\le -1 + f_0 = -(1-f_0)$。除以 $f_0 - 1 = -(1-f_0)$ 再次反转不等号：$\\frac{I+f_0}{f_0-1} \\ge \\frac{-(1-f_0)}{-(1-f_0)} = 1$。乘以 $f_0 > 0$ 得到 $\\frac{f_0(I+f_0)}{f_0-1} \\ge f_0$。因此，在这种情况下，任何可行的整数解都必须满足：\n$$ \\frac{f_0}{f_0 - 1} \\sum_{j \\in N^-} a_{j} s_{j} \\ge f_0 $$\n\n一个有效的割必须对任何可行的整数解都成立，而这些解必然属于情况 1 或情况 2。我们可以将推导出的两个不等式合并成一个单一的有效割。\n注意到 $\\sum_{j \\in N^+} a_{j} s_{j} \\ge 0$ 且 $\\frac{f_0}{f_0-1} \\sum_{j \\in N^-} a_{j} s_{j} \\ge 0$。\n如果一个解属于情况 1，它满足 $\\sum_{j \\in N^+} a_j s_j \\ge f_0$。将非负项 $\\frac{f_0}{f_0-1} \\sum_{j \\in N^-} a_j s_j$ 加到左侧，不等式仍然成立。\n如果一个解属于情况 2，它满足 $\\frac{f_0}{f_0 - 1} \\sum_{j \\in N^-} a_{j} s_{j} \\ge f_0$。将非负项 $\\sum_{j \\in N^+} a_j s_j$ 加到左侧，不等式仍然成立。\n因此，以下不等式对所有可行的整数解都有效：\n$$ \\sum_{j \\in N^+} a_{j} s_{j} + \\frac{f_0}{f_0 - 1} \\sum_{j \\in N^-} a_{j} s_{j} \\ge f_0 $$\n这就是 Gomory 混合整数分数割。\n\n现在，我们将此推导应用于所提供的特定单纯形表行：\n$$ x_{3} + 2.75\\, s_{1} - 1.30\\, s_{2} + 0.45\\, s_{4} = 0.37462 $$\n这里，整数基变量是 $x_k = x_3$。非基变量是 $s_1, s_2, s_4$。\n右侧是 $b_3 = 0.37462$。分数部分是 $f_0 = b_3 - \\lfloor b_3 \\rfloor = 0.37462 - 0 = 0.37462$。\n非基变量的系数是 $a_1 = 2.75$，$a_2 = -1.30$ 和 $a_4 = 0.45$。\n我们根据它们的符号进行分类：\n$N^+ = \\{1, 4\\}$ 因为 $a_1 = 2.75 > 0$ 且 $a_4 = 0.45 > 0$。\n$N^- = \\{2\\}$ 因为 $a_2 = -1.30  0$。\n\n将这些值代入通用割公式：\n$$ a_1 s_1 + a_4 s_4 + \\frac{f_0}{f_0 - 1} a_2 s_2 \\ge f_0 $$\n$$ 2.75\\, s_{1} + 0.45\\, s_{4} + \\left( \\frac{0.37462}{0.37462 - 1} \\right) (-1.30)\\, s_{2} \\ge 0.37462 $$\n$s_2$ 的系数计算如下：\n$$ \\left( \\frac{0.37462}{-0.62538} \\right) (-1.30) = \\frac{-0.487006}{-0.62538} \\approx 0.778736 $$\n所以，特定的割是：\n$$ 2.75\\, s_{1} + 0.778736...\\, s_{2} + 0.45\\, s_{4} \\ge 0.37462 $$\n问题要求计算在当前 LP 解下对此割的违反量。在一个最优 LP 表中，所有非基变量均为零。因此，$\\hat{s}_1 = 0$，$\\hat{s}_2 = 0$ 和 $\\hat{s}_4 = 0$。\n违反量定义为 $\\text{RHS} - \\text{LHS}$，在当前解 $\\hat{s}$ 处求值。\n在当前解下，割的左侧 (LHS) 是：\n$$ \\text{LHS} = 2.75(0) + 0.778736...(0) + 0.45(0) = 0 $$\n割的右侧 (RHS) 是 $f_0 = 0.37462$。\n因此，违反量为：\n$$ \\text{违反量} = \\text{RHS} - \\text{LHS} = 0.37462 - 0 = 0.37462 $$\n当前的 LP 解违反了该割，因为 $0 \\ge 0.37462$ 是不成立的。违反量为 $0.37462$。\n将结果四舍五入到四位有效数字，得到 $0.3746$。", "answer": "$$\\boxed{0.3746}$$", "id": "3104181"}, {"introduction": "在学会了如何生成单个割平面之后，下一步是理解它在完整算法中的作用。这个实践练习 [@problem_id:3104203] 将指导您为一个经典的组合优化问题——背包问题，实现一个基础的分支切割算法。与可以从任何问题中推导的通用 Gomory 割平面不同，您将使用问题特定的“覆盖不等式”。通过编程实现并比较添加割平面前后搜索树的节点数量，您将亲身体验到割平面在减少计算量和加速求解过程中的强大威力。", "problem": "考虑二进制背包问题，其目标为最大化 $ \\sum_{i=1}^{n} v_i x_i $，约束条件为容量约束 $ \\sum_{i=1}^{n} w_i x_i \\le W $ 和整数约束 $ x \\in \\{0,1\\}^n $。线性规划松弛将 $ x \\in \\{0,1\\}^n $ 替换为 $ 0 \\le x_i \\le 1 $，从而得到最优值的一个有效上界。覆盖（cover）是满足 $ \\sum_{i \\in C} w_i  W $ 的任意索引集 $ C \\subseteq \\{1,\\ldots,n\\} $。最小覆盖是一个覆盖 $ C $，使得对于任意 $ j \\in C $ 都有 $ \\sum_{i \\in C \\setminus \\{j\\}} w_i \\le W $。对于任意最小覆盖 $ C $，不等式 $ \\sum_{i \\in C} x_i \\le |C| - 1 $ 是有效的，并且可以在分支切割方案中作为切割平面在根节点添加。\n\n基于这些核心定义，设计一个程序，该程序：\n- 实现一个分支定界搜索，在每个节点使用线性规划松弛来计算上界，并剪除那些无法改进目标函数的节点。\n- 实现一个分支切割变体，在根节点添加一个最小覆盖不等式（并在整个搜索过程中保持它），并衡量其相对于不带切割的分支定界算法在已处理节点数量上的影响。\n- 使用确定性分支规则，选择松弛解中值为分数的变量，并选择值最接近 $ 0.5 $ 的那个，先对 $ x_j = 1 $进行分支，然后对 $ x_j = 0 $进行分支。\n- 将节点计数为求解了线性规划松弛的节点数量。一个仅通过固定赋值就被检测为不可行而未求解松弛的节点不应被计数。\n\n您的程序必须：\n1. 从 $ (w, W) $ 自动构建一个最小覆盖 $ C $。一种有效的方法是：按照 $ w_i $ 的非递增顺序选取物品，直到它们的总和超过 $ W $，从而选择一个初始覆盖；然后，只要移除 C 中权重最小的物品后，剩余集合仍然是覆盖，就重复此移除操作。当移除 C 中当前权重最小的物品会导致该集合不再是覆盖时，该过程终止，此时的 C 即为最小覆盖。\n2. 在每个节点使用线性规划松弛来计算上界，通过在以下约束下最小化 $ -\\sum_{i=1}^{n} v_i x_i $：$ \\sum_{i=1}^{n} w_i x_i \\le W $，如果存在覆盖，则加上 $ \\sum_{i \\in C} x_i \\le |C| - 1 $，以及 $ 0 \\le x_i \\le 1 $ 和任何来自自分支的变量固定。\n3. 使用一个贪心启发式算法构建的可行解来初始化当前最优解。该算法按 $ v_i / w_i $ 的非递增顺序选取物品，直到达到容量上限。\n\n测试套件。使用以下三个测试用例来探索不同的行为：\n- A用例（存在非平凡的最小覆盖）：$ n = 7 $, $ v = [16, 14, 13, 12, 10, 8, 6] $, $ w = [8, 7, 6, 6, 5, 4, 3] $, $ W = 15 $。此处存在一个最小覆盖（例如，选择最重的物品直到超出容量）。\n- B用例（不存在覆盖）：$ n = 6 $, $ v = [7, 9, 6, 5, 4, 8] $, $ w = [3, 4, 5, 2, 1, 4] $, $ W = 25 $。由于 $ \\sum_{i=1}^{n} w_i  W $，不存在覆盖，因此相对于仅使用分支的算法，添加切割应该没有效果。\n- C用例（双物品最小覆盖）：$ n = 5 $, $ v = [12, 12, 9, 9, 8] $, $ w = [6, 6, 5, 5, 4] $, $ W = 10 $。在最重的物品中存在一个大小为2的最小覆盖，其不等式 $ x_{i} + x_{j} \\le 1 $可以收紧松弛。\n\n最终输出格式。您的程序应该生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例贡献一个双元素列表 $ [N_{\\text{branch}}, N_{\\text{cut}}] $，其中 $ N_{\\text{branch}} $ 等于仅使用分支时处理的节点数，$ N_{\\text{cut}} $ 等于添加了最小覆盖不等式后处理的节点数。例如，打印的字符串应如下所示：$ [[N_1^{\\text{branch}},N_1^{\\text{cut}}],[N_2^{\\text{branch}},N_2^{\\text{cut}}],[N_3^{\\text{branch}},N_3^{\\text{cut}}]] $。", "solution": "用户要求设计一个程序，用于比较标准分支定界算法和一个分支切割变体在解决二进制背包问题时的性能。性能通过搜索树中处理的节点数量来衡量。如果一个节点对应的线性规划（$LP$）松弛问题被求解，那么该节点将被计数。\n\n问题定义为最大化总价值 $Z = \\sum_{i=1}^{n} v_i x_i$，约束条件为一个容量约束 $\\sum_{i=1}^{n} w_i x_i \\le W$ 和一个二进制变量约束 $x_i \\in \\{0, 1\\}$（对所有 $i \\in \\{1, \\ldots, n\\}$）。变量 $v_i$ 和 $w_i$ 分别代表物品 $i$ 的价值和重量，$W$ 是背包容量。\n\n该解决方案围绕一个深度优先的分支定界搜索框架构建。这个框架对每个测试用例执行两次：一次作为纯粹的分支定界算法，另一次作为整合了特定切割平面的分支切割算法。\n\n**1. 初始下界（当前最优解）**\n\n为了实现有效剪枝，搜索过程会用一个高质量的可行解进行初始化，这个解为最优目标值提供了一个初始下界。该解使用贪心启发式算法构建。物品按其价值重量比 $v_i / w_i$ 的非递增顺序排序。如果不违反容量约束 $W$，它们会被顺序添加到背包中。这个贪心解的总价值作为初始的当前最优值 $Z_{best}$。\n\n**2. 覆盖不等式生成**\n\n对于分支切割变体，会生成一个被称为覆盖不等式的有效不等式，并将其添加到根节点的 $LP$ 松弛中。这个不等式在整个搜索树中保持有效。\n\n一个覆盖 $C$ 是一个物品索引集合，其总重量超过背包容量：$\\sum_{i \\in C} w_i  W$。一个最小覆盖是一个其任何真子集都不是覆盖的覆盖；也就是说，对于任何物品 $j \\in C$，都有 $\\sum_{i \\in C \\setminus \\{j\\}} w_i \\le W$。对于任何最小覆盖 $C$，不等式 $\\sum_{i \\in C} x_i \\le |C| - 1$ 对整数问题是有效的。这是因为如果 $C$ 中的所有物品都被选中（即对所有 $i \\in C$ 都有 $x_i=1$），它们的总重量将超过 $W$，从而违反容量约束。因此，一个可行解中最多只能包含来自最小覆盖 $C$ 中的 $|C| - 1$ 个物品。\n\n生成一个这样的最小覆盖的具体步骤如下：\n- 按物品重量 $w_i$ 的非递增顺序选择物品，直到它们的累积重量刚好超过 $W$，从而形成一个初始覆盖。\n- 然后通过重复尝试移除权重最小的物品来使这个初始覆盖变为最小覆盖。如果移除该物品后剩下的集合仍然是一个覆盖（即其重量和仍然超过 $W$），则永久移除该物品，并对较小的集合重复此过程。当移除当前最轻的物品将导致集合不再是覆盖时，该过程终止。\n\n如果没有任何物品集合的总重量大于 $W$（即 $\\sum_{i=1}^n w_i \\le W$），则不存在覆盖，分支切割算法就等同于分支定界算法。\n\n**3. 分支定界/切割引擎**\n\n该算法的核心是对二叉搜索树的探索，此处通过使用一个栈来实现深度优先搜索（DFS）遍历。树中的每个节点对应一个子问题，在该子问题中，一部分变量被固定为 $0$ 或 $1$。\n\n在每个节点，执行以下步骤：\n1.  **可行性预检查**：在求解任何 $LP$ 之前，会执行一个简单的检查。如果固定为 $1$ 的物品的总重量已经超过容量 $W$，该节点不可行并被剪枝。此类节点不被计数。\n2.  **节点处理**：如果节点可能是可行的，它将被正式计数，并求解其 $LP$ 松弛问题。$LP$ 松弛问题包括在以下约束下最大化目标函数 $\\sum v_i x_i$：\n    - 容量约束：$\\sum_{i=1}^{n} w_i x_i \\le W$。\n    - 边界约束：$0 \\le x_i \\le 1$。\n    - 来自自分支的变量固定，例如 $x_j=0$ 或 $x_j=1$。\n    - （对于分支切割）覆盖不等式：$\\sum_{i \\in C} x_i \\le |C| - 1$。\n    `scipy.optimize.linprog` 函数用于此目的，并配置为最小化负的目标函数 $-\\sum v_i x_i$。\n\n3.  **剪枝**：求解 $LP$ 后，其结果决定了下一步的操作。设松弛问题的最优值为 $Z_{LP}$。\n    - **因不可行性剪枝**：如果 $LP$ 松弛问题不可行，则该子问题不包含可行解。该节点被剪枝。\n    - **因界限剪枝**：如果 $Z_{LP} \\le Z_{best}$，则该子树中的任何解都无法改进已知的最佳整数解。该节点被剪枝。\n    - **因整数性剪枝**：如果 $LP$ 解向量 $\\mathbf{x}^*$ 是整数值（在很小的容差范围内），它就是原始背包问题的一个可行解。如果其价值 $\\sum v_i x_i^*$ 大于 $Z_{best}$，$Z_{best}$ 将被更新。然后该节点被剪枝，因为在此路径上进一步分支无法产生更好的解。\n\n4.  **分支**：如果节点未被剪枝且 $LP$ 解 $\\mathbf{x}^*$ 是小数，则进行分支。\n    - **变量选择**：分支变量 $x_j$ 被确定性地选择为那个值为小数且最接近 $0.5$ 的变量。\n    - **子节点生成**：为搜索栈创建两个新节点：一个对应于固定 $x_j=1$，另一个对应于 $x_j=0$。为了遵守首先探索 $x_j=1$ 分支的要求，先将 $x_j=0$ 的节点推入栈中，然后是 $x_j=1$ 的节点。\n\n当栈为空时，搜索终止，这意味着整个可行空间都已被隐式枚举。每个测试用例的最终输出是一对整数：纯分支定界运行的总节点数和分支切割运行的总节点数。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Main function to run the branch-and-cut experiments on the given test cases.\n    \"\"\"\n    test_cases = [\n        # Case A (nontrivial minimal cover present)\n        {'v': [16, 14, 13, 12, 10, 8, 6], 'w': [8, 7, 6, 6, 5, 4, 3], 'W': 15},\n        # Case B (no cover exists)\n        {'v': [7, 9, 6, 5, 4, 8], 'w': [3, 4, 5, 2, 1, 4], 'W': 25},\n        # Case C (two-item minimal cover)\n        {'v': [12, 12, 9, 9, 8], 'w': [6, 6, 5, 5, 4], 'W': 10},\n    ]\n\n    results = []\n    for case in test_cases:\n        v, w, W = case['v'], case['w'], case['W']\n        n_branch = solve_knapsack_instance(v, w, W, use_cut=False)\n        n_cut = solve_knapsack_instance(v, w, W, use_cut=True)\n        results.append([n_branch, n_cut])\n\n    # The final print statement must follow the exact specified format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef generate_minimal_cover(w, W):\n    \"\"\"\n    Generates a single minimal cover based on the provided algorithm.\n    \"\"\"\n    n = len(w)\n    if np.sum(w) = W:\n        return None\n\n    # Sort items by weight in descending order to build initial cover\n    sorted_indices = np.argsort(w)[::-1]\n    \n    cover_indices = set()\n    current_weight = 0\n    for i in sorted_indices:\n        cover_indices.add(i)\n        current_weight += w[i]\n        if current_weight > W:\n            break\n    \n    # Iteratively make the cover minimal\n    while True:\n        if len(cover_indices) = 1:\n            break\n            \n        weights_in_cover = [(idx, w[idx]) for idx in cover_indices]\n        min_weight_item_idx, min_weight = min(weights_in_cover, key=lambda item: item[1])\n        \n        # If removing the lightest item still results in a cover, do it\n        if np.sum([w[i] for i in cover_indices]) - min_weight > W:\n            cover_indices.remove(min_weight_item_idx)\n        else:\n            break # Cover is now minimal\n            \n    return sorted(list(cover_indices))\n\ndef greedy_heuristic(v, w, W):\n    \"\"\"\n    Finds an initial feasible solution using a greedy approach based on v/w ratio.\n    \"\"\"\n    n = len(v)\n    ratios = v / w\n    \n    sorted_indices = np.argsort(ratios)[::-1]\n    \n    x = np.zeros(n)\n    current_weight = 0\n    current_value = 0.0\n    \n    for i in sorted_indices:\n        if current_weight + w[i] = W:\n            x[i] = 1.0\n            current_weight += w[i]\n            current_value += v[i]\n            \n    return current_value, x\n\ndef solve_knapsack_instance(v_in, w_in, W, use_cut):\n    \"\"\"\n    Solves a knapsack instance using branch-and-bound, optionally with a cover cut.\n    \"\"\"\n    n = len(v_in)\n    v = np.array(v_in, dtype=float)\n    w = np.array(w_in, dtype=float)\n\n    # 1. Get initial lower bound from greedy heuristic\n    lower_bound, _ = greedy_heuristic(v, w, W)\n\n    # 2. Setup base LP constraints\n    c_obj = -v\n    A_ub_list = [w]\n    b_ub_list = [W]\n    \n    if use_cut:\n        cover = generate_minimal_cover(w, W)\n        if cover:\n            cover_ineq = np.zeros(n)\n            cover_ineq[cover] = 1.0\n            A_ub_list.append(cover_ineq)\n            b_ub_list.append(float(len(cover) - 1))\n\n    A_ub = np.array(A_ub_list)\n    b_ub = np.array(b_ub_list)\n    \n    # 3. Branch-and-Bound search\n    node_count = 0\n    stack = [{}]  # Stack for DFS, stores dicts of fixed variables\n\n    while stack:\n        fixed_vars = stack.pop()\n\n        # Pre-check: prune if fixed items already violate capacity\n        current_weight = sum(w[i] for i, val in fixed_vars.items() if val == 1)\n        if current_weight > W:\n            continue\n\n        # Node is processed: an LP will be solved\n        node_count += 1\n        \n        # Setup bounds for the current subproblem\n        bounds = [(0.0, 1.0) for _ in range(n)]\n        for i, val in fixed_vars.items():\n            bounds[i] = (float(val), float(val))\n\n        # Solve the LP relaxation\n        res = linprog(c=c_obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs-ds')\n        \n        # Pruning based on LP result\n        if not res.success:\n            continue  # Prune by infeasibility\n            \n        upper_bound = -res.fun\n        if upper_bound = lower_bound + 1e-9:\n            continue  # Prune by bound\n            \n        x_sol = res.x\n        is_integer = np.all(np.isclose(x_sol, np.round(x_sol)))\n        \n        if is_integer:\n            current_value = np.dot(v, np.round(x_sol))\n            if current_value > lower_bound:\n                lower_bound = current_value\n            continue  # Prune by integrality\n            \n        # Branching on the most fractional variable\n        fractional_indices = np.where((x_sol > 1e-9)  (x_sol  1 - 1e-9))[0]\n        \n        if not fractional_indices.any():\n            continue # Should be caught by is_integer, but as a safeguard\n\n        branch_var_idx = min(fractional_indices, key=lambda i: abs(x_sol[i] - 0.5))\n        \n        # Push child nodes for DFS (x=1 branch explored first)\n        fixed_0 = fixed_vars.copy()\n        fixed_0[branch_var_idx] = 0\n        stack.append(fixed_0)\n        \n        fixed_1 = fixed_vars.copy()\n        fixed_1[branch_var_idx] = 1\n        stack.append(fixed_1)\n        \n    return node_count\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3104203"}, {"introduction": "在实际的分支切割求解器中，一个核心的挑战是如何有效地找到违反当前分数解的割平面，这个问题被称为“分离问题”。这个高级实践 [@problem_id:3104276] 引导您探索两种不同的割平面生成策略：一种是基于当前解的启发式方法，它能快速找到一个“足够好”的割平面；另一种是精确分离算法，它能保证找到“最深”的割平面，即最能有效切割当前分数解的那个。通过比较这两种策略在收紧界限方面的效果，您将了解到在设计高效优化算法时所面临的“速度”与“质量”之间的权衡。", "problem": "您的任务是在一个简化的分支切割框架内，为一个二元背包优化问题实现并比较两种割平面生成策略。考虑一个二元决策向量 $x \\in \\{0,1\\}^n$、利润向量 $p \\in \\mathbb{R}^n_{\\ge 0}$、重量向量 $a \\in \\mathbb{Z}^n_{0}$ 和容量 $b \\in \\mathbb{Z}_{0}$。二元背包问题是在单个背包不等式的约束下，最大化线性目标函数：\n$$\n\\max \\; p^\\top x \\quad \\text{subject to} \\quad a^\\top x \\le b, \\quad x \\in \\{0,1\\}^n.\n$$\n其线性规划松弛将 $x \\in \\{0,1\\}^n$ 替换为 $0 \\le x_i \\le 1$。分支切割法通过有效不等式（割平面）迭代地加强此松弛，并在必要时对当前解的分数分量进行分支。\n\n您的程序必须实现并比较两种基于 Chvátal-Gomory 割（CG 割）的割平面生成器，这两种生成器专门用于背包覆盖不等式：\n\n- 一个“基于舍入”的 CG 割平面生成器：给定当前的线性规划松弛解 $\\hat{x} \\in [0,1]^n$，按 $\\hat{x}_i$ 的降序对索引进行排序，并贪婪地构建一个集合 $S$，不断添加物品，直到累积重量 $\\sum_{i \\in S} a_i$ 严格超过容量 $b$。如果找到这样的集合，则提出覆盖不等式\n$$\n\\sum_{i \\in S} x_i \\le |S| - 1,\n$$\n并且仅当它被当前解违反时才接受它，即\n$$\n\\sum_{i \\in S} \\hat{x}_i - (|S| - 1)  0.\n$$\n\n- 一个用于背包覆盖不等式的“精确分离”CG 割平面生成器：在所有满足 $\\sum_{i \\in S} a_i  b$（一个覆盖）的子集 $S \\subseteq \\{1,\\dots,n\\}$ 中，找到使违背量最大化的子集\n$$\n\\sum_{i \\in S} \\hat{x}_i - (|S| - 1).\n$$\n仅当最大违背量严格为正时，才生成相应的不等式。\n\n这些覆盖不等式是 Chvátal-Gomory 割的一个特例。从背包不等式 $a^\\top x \\le b$ 出发，任何满足 $\\sum_{i \\in S} a_i  b$ 的子集 $S$ 都能导出覆盖不等式 $\\sum_{i \\in S} x_i \\le |S| - 1$，该不等式对于所有满足 $a^\\top x \\le b$ 的 $x \\in \\{0,1\\}^n$ 均有效。\n\n您必须实现：\n1. 一个使用标准方法求解线性规划松弛的优化例程。\n2. 上面定义的基于舍入的割平面生成器。\n3. 一个能最优地解决覆盖分离问题的精确分离例程。\n4. 在根节点进行单轮割平面生成（此任务不需要进一步分支）。\n5. 一个用于计算精确最优整数解值以便比较的动态规划例程。\n\n对于每个测试用例，计算：\n- 在根节点分别添加基于舍入的割平面（如果有）和精确分离的割平面（如果有）后，线性规划松弛的界。\n- 通过动态规划得到的最优整数解值。\n- 添加割平面后的相对差距（以小数表示）：\n$$\n\\text{gap}_{\\text{round}} = \\frac{\\text{LP}_{\\text{round}} - \\text{OPT}_{\\text{int}}}{\\text{OPT}_{\\text{int}}}, \\quad\n\\text{gap}_{\\text{exact}} = \\frac{\\text{LP}_{\\text{exact}} - \\text{OPT}_{\\text{int}}}{\\text{OPT}_{\\text{int}}}.\n$$\n- 一个布尔值，指示精确分离是否比基于舍入的割平面获得了严格更小的差距，评估方式为 $\\text{gap}_{\\text{exact}}  \\text{gap}_{\\text{round}}$。\n\n在您的推导和实现中使用的基本原理：\n- 二元整数规划的线性规划松弛及其可行域 $0 \\le x_i \\le 1$。\n- 从背包约束导出的背包覆盖不等式的有效性，其依据是 $x$ 的二元性质和超出容量的条件。\n- 用于求解具有整数重量和容量的精确 0–1 背包优化的动态规划。\n\n测试套件：\n使用以下具有整数重量和容量的实例：\n- 测试用例 1（一般分数情况）：\n  - $p = [20,18,14,11]$\n  - $a = [7,6,5,4]$\n  - $b = 10$\n- 测试用例 2（整松弛情况，边界）：\n  - $p = [9,7,5]$\n  - $a = [5,4,3]$\n  - $b = 9$\n- 测试用例 3（较大的分数情况）：\n  - $p = [28,26,21,18,16]$\n  - $a = [10,9,7,6,5]$\n  - $b = 17$\n\n最终输出格式：\n您的程序应生成单行输出，其中包含所有测试用例的结果，格式为列表的列表。每个内部列表的形式必须是 $[\\text{gap}_{\\text{round}}, \\text{gap}_{\\text{exact}}, \\text{exact\\_better}]$，其中前两个条目是浮点数，第三个是布尔值。例如：\n$[[g_1^{\\text{round}},g_1^{\\text{exact}},\\text{True}],[g_2^{\\text{round}},g_2^{\\text{exact}},\\text{False}],\\dots]$。", "solution": "所提供的问题要求为二元背包问题实现并比较两种割平面生成策略。该解决方案需要一个多步骤方法，涉及整数优化、线性规划和专门的割平面生成算法。以下是所用方法的详细、基于原理的阐述。\n\n### 1. 通过动态规划求解最优整数解\n\n0-1 二元背包问题的精确最优值，记作 $\\text{OPT}_{\\text{int}}$，作为比较线性规划（LP）松弛界的基准。对于一个具有整数重量 $a_i$ 和整数容量 $b$ 的问题，动态规划（DP）提供了一种精确且高效的方法来找到这个值。\n\n令 $dp(i, w)$ 为使用前 $i$ 个物品（索引从 $0$ 到 $i-1$）且总重量限制恰好为 $w$ 时可实现的最大利润。状态转移或递推关系定义如下：对于每个物品 $i$ 和容量 $w$，我们决定是否包含物品 $i-1$（利润为 $p_{i-1}$，重量为 $a_{i-1}$）。\n\n- 如果不包含物品 $i-1$，利润与使用前 $i-1$ 个物品在容量为 $w$ 时的最大利润相同，即 $dp(i-1, w)$。\n- 如果包含物品 $i-1$（仅当 $w \\ge a_{i-1}$ 时可能），利润为 $p_{i-1}$ 加上从前 $i-1$ 个物品在剩余容量 $w - a_{i-1}$ 下可获得的最大利润，即 $p_{i-1} + dp(i-1, w - a_{i-1})$。\n\n因此，递推关系为：\n$$\ndp(i, w) = \\begin{cases}\n    dp(i-1, w)  \\text{if } a_{i-1}  w \\\\\n    \\max(dp(i-1, w), p_{i-1} + dp(i-1, w - a_{i-1}))  \\text{if } a_{i-1} \\le w\n\\end{cases}\n$$\nDP 表以 $dp(0, w) = 0$ 对所有 $w$ 进行初始化，表示没有物品时利润为零。填充完所有 $i \\in \\{1, \\dots, n\\}$ 和 $w \\in \\{1, \\dots, b\\}$ 的表后，最优整数解值在 $dp(n, b)$ 处找到。\n\n### 2. 线性规划松弛与割平面生成\n\n分支切割法首先求解整数规划的 LP 松弛。二元约束 $x \\in \\{0, 1\\}^n$ 被松弛为连续界 $0 \\le x_i \\le 1$ 对所有 $i$。初始 LP 松弛为：\n$$\n\\max \\; p^\\top x \\quad \\text{subject to} \\quad a^\\top x \\le b, \\quad 0 \\le x_i \\le 1 \\quad \\forall i.\n$$\n该问题使用标准 LP 求解器求解。设解为 $\\hat{x}$。如果 $\\hat{x}$ 完全是整数，它就是原问题的最优解。如果 $\\hat{x}$ 有分数分量，LP 界 $p^\\top \\hat{x}$ 是 $\\text{OPT}_{\\text{int}}$ 的一个上界。我们接着寻求添加被 $\\hat{x}$ 违反的有效不等式（割平面）来收紧这个界。问题指定使用背包覆盖不等式。一个集合 $S \\subseteq \\{1, \\dots, n\\}$ 是一个**覆盖**，如果 $\\sum_{i \\in S} a_i  b$。相应的**覆盖不等式**是 $\\sum_{i \\in S} x_i \\le |S| - 1$。这个不等式是有效的，因为如果从 $S$ 中选择了超过 $|S|-1$ 个物品（即，对于 $x \\in \\{0,1\\}^n$ 有 $\\sum_{i \\in S} x_i \\ge |S|$），它们的总重量将超过容量 $b$，从而违反背包约束。\n\n一个割平面只有在被当前 LP 解 $\\hat{x}$ 违反时才有用，即 $\\sum_{i \\in S} \\hat{x}_i  |S| - 1$。\n\n#### 2.1. 基于舍入的割平面生成器\n\n这是一种寻找被违反的覆盖不等式的启发式方法。它利用了这样一个直觉：在 $\\hat{x}$ 中具有高分数值的物品是构成被违反覆盖的主要候选者。算法如下：\n1. 按相应值 $\\hat{x}_i$ 的降序对物品索引 $i$ 进行排序。\n2. 按照这个排序顺序，贪婪地将物品添加到集合 $S$ 中。\n3. 一旦 $S$ 中物品的累积重量超过容量 $b$（即 $\\sum_{i \\in S} a_i  b$），就停止。\n4. 如果找到了这样的覆盖 $S$，检查它是否被 $\\hat{x}$ 违反：$\\sum_{i \\in S} \\hat{x}_i  |S| - 1$。如果是，则生成此割平面。\n\n#### 2.2. 精确分离割平面生成器\n\n此方法旨在找到*违背程度最大*的覆盖不等式。寻找使违背量 $\\sum_{i \\in S} \\hat{x}_i - (|S| - 1)$ 最大化的覆盖 $S$ 的问题，被称为背包覆盖不等式的**分离问题**。我们可以将其形式化为一个优化问题。令 $y_i$ 为一个二元变量，如果物品 $i$ 在 $S$ 中，则 $y_i=1$，否则 $y_i=0$。\n我们希望最大化 $\\sum_{i=1}^n \\hat{x}_i y_i - (\\sum_{i=1}^n y_i - 1)$，这等价于最大化 $\\sum_{i=1}^n (\\hat{x}_i - 1)y_i + 1$，约束条件为 $\\sum_{i=1}^n a_i y_i  b$。由于 $a_i$ 和 $b$ 是整数，这等价于 $\\sum_{i=1}^n a_i y_i \\ge b+1$。\n\n令 $v_i = \\hat{x}_i - 1$。分离问题是：\n$$\n\\max \\sum_{i=1}^n v_i y_i \\quad \\text{subject to} \\quad \\sum_{i=1}^n a_i y_i \\ge b+1, \\quad y \\in \\{0,1\\}^n.\n$$\n这是背包问题的一个变种。它可以使用动态规划求得最优解。令 $dp_{sep}(i, w)$ 为使用前 $i$ 个物品子集且总重量恰好为 $w$ 时 $\\sum_{j=1}^i v_j y_j$ 的最大值。其递推关系类似于标准背包 DP。计算完表格后，分离目标的最大值通过取 $\\max_{w \\ge b+1} dp_{sep}(n, w)$ 得到。最大违背量是这个值加 $1$。如果这个最大违背量为正，我们通过回溯 DP 表来重建最优覆盖集 $S$。\n\n### 3. 比较与评估\n\n对于每个测试用例，流程如下：\n1. 使用背包 DP 计算 $\\text{OPT}_{\\text{int}}$。\n2. 求解初始 LP 松弛以获得根解 $\\hat{x}$。\n3. 使用基于舍入的启发式方法生成一个割平面。如果找到一个有效且被违反的割平面，则将其添加到 LP 中并重新求解，得到 $\\text{LP}_{\\text{round}}$。如果没有找到割平面，$\\text{LP}_{\\text{round}}$ 就是初始 LP 值。\n4. 使用精确分离例程生成一个割平面。如果找到一个有效且被违反的割平面，则将其添加到初始 LP 中并重新求解，得到 $\\text{LP}_{\\text{exact}}$。如果没有找到割平面，$\\text{LP}_{\\text{exact}}$ 就是初始 LP 值。\n5. 计算相对差距 $\\text{gap}_{\\text{round}} = (\\text{LP}_{\\text{round}} - \\text{OPT}_{\\text{int}}) / \\text{OPT}_{\\text{int}}$ 和 $\\text{gap}_{\\text{exact}} = (\\text{LP}_{\\text{exact}} - \\text{OPT}_{\\text{int}}) / \\text{OPT}_{\\text{int}}$。\n6. 判断精确方法是否提供了严格更小的差距，即 $\\text{gap}_{\\text{exact}}  \\text{gap}_{\\text{round}}$。\n\n这种结构化的比较能够对一个简单的启发式方法与一个精确（但计算上更密集）的割平面生成方法的效果进行量化评估。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Main solver function that processes all test cases and prints the final result.\n    \"\"\"\n    test_cases = [\n        {\n            \"p\": np.array([20, 18, 14, 11], dtype=float),\n            \"a\": np.array([7, 6, 5, 4], dtype=int),\n            \"b\": 10\n        },\n        {\n            \"p\": np.array([9, 7, 5], dtype=float),\n            \"a\": np.array([5, 4, 3], dtype=int),\n            \"b\": 9\n        },\n        {\n            \"p\": np.array([28, 26, 21, 18, 16], dtype=float),\n            \"a\": np.array([10, 9, 7, 6, 5], dtype=int),\n            \"b\": 17\n        },\n    ]\n\n    all_results = []\n\n    def solve_knapsack_dp(p, a, b):\n        \"\"\"Solves the 0-1 knapsack problem using dynamic programming.\"\"\"\n        n = len(p)\n        dp = np.zeros((n + 1, b + 1), dtype=float)\n        for i in range(1, n + 1):\n            profit = p[i - 1]\n            weight = a[i - 1]\n            for w in range(b + 1):\n                if weight = w:\n                    dp[i, w] = max(dp[i - 1, w], profit + dp[i - 1, w - weight])\n                else:\n                    dp[i, w] = dp[i - 1, w]\n        return dp[n, b]\n\n    def solve_lp(p, A_ub, b_ub):\n        \"\"\"Helper function to solve the LP relaxation.\"\"\"\n        n = len(p)\n        c = -p\n        bounds = [(0, 1) for _ in range(n)]\n        # Using 'highs' for robustness and performance, as recommended by SciPy.\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        if res.success:\n            return -res.fun, res.x\n        else:\n            # For this problem, LPs should always be feasible.\n            raise RuntimeError(\"LP solver failed.\")\n\n    def rounding_cut_generator(x_hat, a, b):\n        \"\"\"Generates a cover inequality using a rounding-based heuristic.\"\"\"\n        n = len(a)\n        indices = np.argsort(-x_hat)\n        cover_s = []\n        current_weight = 0\n        for idx in indices:\n            cover_s.append(idx)\n            current_weight += a[idx]\n            if current_weight > b:\n                break\n        else:  # 'else' on a for-loop executes if the loop completed without break\n            return None # No cover found\n\n        violation = np.sum(x_hat[cover_s]) - (len(cover_s) - 1)\n        if violation > 1e-9:\n            return cover_s\n        return None\n\n    def exact_separation_generator(x_hat, a, b):\n        \"\"\"Finds the most violated cover inequality using dynamic programming.\"\"\"\n        n = len(a)\n        v = x_hat - 1  # Profits for the separation problem\n        total_weight = int(np.sum(a))\n        \n        # dp[i, w]: max value for items up to i-1 with exact weight w\n        dp = np.full((n + 1, total_weight + 1), -np.inf)\n        parent = {} # For backtracking\n        dp[0, 0] = 0\n\n        for i in range(1, n + 1):\n            profit = v[i - 1]\n            weight = a[i - 1]\n            for w in range(total_weight + 1):\n                # Case 1: Don't include item i-1\n                dp[i, w] = dp[i-1, w]\n                parent[(i, w)] = (i-1, w)\n\n                # Case 2: Include item i-1\n                if w >= weight:\n                    val_with_item = profit + dp[i-1, w - weight]\n                    if val_with_item > dp[i, w]:\n                        dp[i, w] = val_with_item\n                        parent[(i, w)] = (i-1, w - weight)\n\n        max_val = -np.inf\n        best_w = -1\n        capacity_limit = b + 1\n        \n        for w in range(capacity_limit, total_weight + 1):\n            if dp[n, w] > max_val:\n                max_val = dp[n, w]\n                best_w = w\n        \n        max_violation = max_val + 1\n        if max_violation > 1e-9:\n            # Backtrack to find the cover set\n            cover_s = []\n            curr_w = best_w\n            for i in range(n, 0, -1):\n                prev_i, prev_w = parent[(i, curr_w)]\n                if curr_w != prev_w: # This means item i-1 was taken\n                    cover_s.append(i-1)\n                    curr_w = prev_w\n            return cover_s\n        return None\n\n    for case in test_cases:\n        p, a, b = case[\"p\"], case[\"a\"], case[\"b\"]\n        n = len(p)\n        \n        opt_int = solve_knapsack_dp(p, a, b)\n        \n        A_orig = a.reshape(1, -1)\n        b_orig = np.array([b])\n        \n        lp_root_val, x_hat = solve_lp(p, A_orig, b_orig)\n\n        # Rounding-based cut path\n        S_round = rounding_cut_generator(x_hat, a, b)\n        lp_round_val = lp_root_val\n        if S_round:\n            cut_row = np.zeros(n)\n            cut_row[S_round] = 1\n            A_new = np.vstack([A_orig, cut_row])\n            b_new = np.append(b_orig, [len(S_round) - 1])\n            lp_round_val, _ = solve_lp(p, A_new, b_new)\n        \n        # Exact separation cut path\n        S_exact = exact_separation_generator(x_hat, a, b)\n        lp_exact_val = lp_root_val\n        if S_exact:\n            cut_row = np.zeros(n)\n            cut_row[S_exact] = 1\n            A_new = np.vstack([A_orig, cut_row])\n            b_new = np.append(b_orig, [len(S_exact) - 1])\n            lp_exact_val, _ = solve_lp(p, A_new, b_new)\n            \n        # Calculate gaps and comparison\n        if opt_int > 0:\n            gap_round = (lp_round_val - opt_int) / opt_int\n            gap_exact = (lp_exact_val - opt_int) / opt_int\n        else: # Handle case of zero optimal value to avoid division by zero\n            gap_round = lp_round_val if lp_round_val > 0 else 0.0\n            gap_exact = lp_exact_val if lp_exact_val > 0 else 0.0\n\n        exact_better = gap_exact  gap_round\n\n        all_results.append([gap_round, gap_exact, exact_better])\n\n    # Format the final output string exactly as requested.\n    result_str = \"[\" + \",\".join(f\"[{r[0]},{r[1]},{str(r[2])}]\" for r in all_results) + \"]\"\n    print(result_str)\n\nsolve()\n```", "id": "3104276"}]}