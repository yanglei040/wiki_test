{"hands_on_practices": [{"introduction": "这个练习将引导你将一个现实世界中的资源分配问题——大学考试安排——转化为加权集合包装模型 [@problem_id:3181311]。通过解决一系列精心设计的小规模实例，你将亲身体验如何将抽象的约束（如资源不重叠）具体化为数学形式。这个练习强调了模型构建和通过详尽搜索解决小规模组合优化问题的核心技能，为你分析更复杂的问题打下坚实的基础。", "problem": "您需要使用集合包装问题的框架，为一组小规模、自包含的大学考试调度实例进行建模和求解。其根本基础是集合包装的核心定义：给定一个基础项全集和一个子集族，从中选择一个由两两不相交的子集构成的子族，以最大化给定的目标。在此设定中，基础项是资源（监考员和教室），每个子集代表一个占用特定资源集的可能考试安排选项。不相交原则通过一个二元关联矩阵和线性不等式来强制执行。\n\n令资源全集由有限集 $U$ 表示，考试选项的索引集为 $S = \\{1,2,\\dots,m\\}$。对于每个选项 $s \\in S$，令 $R(s) \\subseteq U$ 表示选项 $s$ 占用的资源集。定义一个关联矩阵 $A \\in \\{0,1\\}^{|U|\\times m}$ 如下：\n$$\nA_{u,s} = \\begin{cases}\n1  &\\text{若 } u \\in R(s),\\\\\n0  &\\text{否则。}\n\\end{cases}\n$$\n令 $x \\in \\{0,1\\}^m$ 为决策向量，指示选择了哪些选项，令 $w \\in \\mathbb{R}_+^m$ 为非负公平性权重向量。带权重的集合包装模型为：\n$$\n\\max_{x \\in \\{0,1\\}^m} \\quad \\sum_{s=1}^m w_s x_s \\quad \\text{约束条件为} \\quad A x \\le \\mathbf{1},\n$$\n其中 $\\mathbf{1}$ 是 $\\mathbb{R}^{|U|}$ 中的全1向量，且不等式是按分量计算的。约束条件 $A x \\le \\mathbf{1}$ 确保任何资源 $u \\in U$ 不被多于一个选定的选项使用，即选定的选项在资源上是两两不相交的。公平性权重 $w_s$ 代表选择每个选项的相对期望程度。\n\n您的程序必须为下面的每个测试实例计算在所有满足 $A x \\le \\mathbf{1}$ 和 $x \\in \\{0,1\\}^m$ 的 $x$ 中，最优目标值 $\\sum_{s=1}^m w_s x_s$。如果最优目标值出现平局，则优先选择基数 $\\sum_{s=1}^m x_s$ 更大的解。如果仍然存在平局，则优先选择所选选项的索引集字典序最小的解。\n\n测试套件。请精确使用以下四个实例。对于每个实例，都提供了一个明确的全集 $U$、占用资源的集合族 $\\{R(s)\\}_{s=1}^m$ 以及公平性权重 $w$。资源标签纯粹是符号性的；将标签的相等性视为资源的同一性。\n\n- 实例 $1$ (理想情况，教室和监考员之间有有意义的重叠)：\n  - 全集 $U^{(1)} = \\{I1, I2, I3, R101, R102\\}$。\n  - 选项及所需资源：\n    - $s=1$: $R^{(1)}(1) = \\{I1, I2, R101\\}$，权重 $w^{(1)}_1 = 8.0$。\n    - $s=2$: $R^{(1)}(2) = \\{I2, I3, R101\\}$，权重 $w^{(1)}_2 = 7.5$。\n    - $s=3$: $R^{(1)}(3) = \\{I1, I3, R102\\}$，权重 $w^{(1)}_3 = 6.0$。\n    - $s=4$: $R^{(1)}(4) = \\{I2, R102\\}$，权重 $w^{(1)}_4 = 4.5$。\n    - $s=5$: $R^{(1)}(5) = \\{I3, R102\\}$，权重 $w^{(1)}_5 = 5.0$。\n    - $s=6$: $R^{(1)}(6) = \\{I1, R101\\}$，权重 $w^{(1)}_6 = 4.0$。\n- 实例 $2$ (边界情况：高公平性选项共享监考员，最多只允许选择一个)：\n  - 全集 $U^{(2)} = \\{I1, I2, R101, R102, R103\\}$。\n  - 选项及所需资源：\n    - $s=1$: $R^{(2)}(1) = \\{I1, I2, R101\\}$，权重 $w^{(2)}_1 = 9.0$。\n    - $s=2$: $R^{(2)}(2) = \\{I1, I2, R102\\}$，权重 $w^{(2)}_2 = 9.5$。\n    - $s=3$: $R^{(2)}(3) = \\{I1, I2, R103\\}$，权重 $w^{(2)}_3 = 9.2$。\n- 实例 $3$ (边缘情况：所有选项相互不相交，选择所有选项是可行的)：\n  - 全集 $U^{(3)} = \\{I1, I2, I3, I4, R101, R102, R103, R104\\}$。\n  - 选项及所需资源：\n    - $s=1$: $R^{(3)}(1) = \\{I1, R101\\}$，权重 $w^{(3)}_1 = 2.5$。\n    - $s=2$: $R^{(3)}(2) = \\{I2, R102\\}$，权重 $w^{(3)}_2 = 2.5$。\n    - $s=3$: $R^{(3)}(3) = \\{I3, R103\\}$，权重 $w^{(3)}_3 = 2.5$。\n    - $s=4$: $R^{(3)}(4) = \\{I4, R104\\}$，权重 $w^{(3)}_4 = 2.5$。\n- 实例 $4$ (平局情况，说明了可行性与最优性之间的张力以及通过基数进行决胜)：\n  - 全集 $U^{(4)} = \\{I1, I2, I3, R101, R102, R103\\}$。\n  - 选项及所需资源：\n    - $s=1$: $R^{(4)}(1) = \\{I1, R101\\}$，权重 $w^{(4)}_1 = 4.0$。\n    - $s=2$: $R^{(4)}(2) = \\{I2, R102\\}$，权重 $w^{(4)}_2 = 4.0$。\n    - $s=3$: $R^{(4)}(3) = \\{I1, I2, R103\\}$，权重 $w^{(4)}_3 = 8.0$。\n\n最终输出格式。您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表。对于每个实例 $k \\in \\{1,2,3,4\\}$，输出一个包含两个元素的列表，依次为最优目标值和所选选项的数量。因此，最终输出必须具有以下形式：\n$$\n\\big[ [\\text{opt}^{(1)}, \\text{card}^{(1)}], [\\text{opt}^{(2)}, \\text{card}^{(2)}], [\\text{opt}^{(3)}, \\text{card}^{(3)}], [\\text{opt}^{(4)}, \\text{card}^{(4)}] \\big],\n$$\n打印行中无空格。不涉及物理单位或角度单位；所有数值结果均为无量纲实数和整数。", "solution": "该问题要求解一系列带权重的集合包装实例，这是组合优化中的一个经典问题。该问题被正式定义为一个整数线性规划：\n$$\n\\max_{x \\in \\{0,1\\}^m} \\quad \\sum_{s=1}^m w_s x_s \\quad \\text{约束条件为} \\quad A x \\le \\mathbf{1}\n$$\n其中 $x$ 是一个二元决策向量，指示 $m$ 个选项中哪些被选中，$w$ 是一个非负权重向量，约束条件 $A x \\le \\mathbf{1}$ 确保没有资源被重复使用。矩阵 $A$ 是一个关联矩阵，其中如果资源 $u$ 被选项 $s$ 使用，则 $A_{u,s} = 1$，否则 $A_{u,s} = 0$。不等式 $A x \\le \\mathbf{1}$ 等价于声明对于任意两个选定的选项 $s_i$ 和 $s_j$（其中 $x_i=1$ 且 $x_j=1$），它们各自的资源集 $R(s_i)$ 和 $R(s_j)$ 必须不相交，即 $R(s_i) \\cap R(s_j) = \\emptyset$。\n\n任务是找到一个最大化目标函数 $\\sum w_s x_s$ 的可行解 $x$。由于决策向量 $x$ 在 $\\{0,1\\}^m$ 中，所有可能的 $x$ 选择集合是有限的，其大小为 $2^m$。对于给定的实例，选项数量 $m$ 很小（$m \\le 6$），这使得对所有 $2^m$ 个可能的选项子集进行穷举搜索在计算上是可行的。\n\n求解算法通过为每个实例迭代所有可能的选项子集来进行。对于每个子集，我们执行以下步骤：\n$1$. **可行性检查**：一个选项子集是可行的，当且仅当子集内的所有选项对在其资源需求上是相互不相交的。这通过验证子集中的任意两个不同选项 $s_i$ 和 $s_j$，其资源集的交集 $R(s_i) \\cap R(s_j)$ 为空集来检查。\n\n$2$. **评估**：如果一个子集被发现是可行的，则通过将子集中所有选项 $s$ 的权重 $w_s$ 相加来计算其目标值。基数就是子集中选项的数量。\n\n$3$. **最优解的选择**：算法会记录迄今为止找到的最佳解。如果一个新的可行解根据指定的分层决胜规则优于当前的最佳解，则它将取代当前最佳解：\n    a. 新解具有严格更大的目标值 $\\sum w_s x_s$。\n    b. 如果目标值相等，新解具有严格更大的基数 $\\sum x_s$。\n    c. 如果目标值和基数都相等，新解的选项索引集在字典序上小于当前最佳解。\n\n此过程保证找到问题陈述所定义的唯一最优解。我们将此算法应用于四个实例中的每一个。\n\n**实例 1**：$m=6$，因此有 $2^6=64$ 个子集需要检查。在检查所有可行子集后，使目标最大化的子集是 $\\{s=1, s=5\\}$。\n- 资源集：$R^{(1)}(1) = \\{I1, I2, R101\\}$ 和 $R^{(1)}(5) = \\{I3, R102\\}$。它们的交集为空，因此该选择是可行的。\n- 目标值：$w^{(1)}_1 + w^{(1)}_5 = 8.0 + 5.0 = 13.0$。\n- 基数：$2$。\n这比任何其他可行子集产生更高的目标值。例如，次优值为 $12.0$，对应集合 $\\{s=2, s=4\\}$。因此，最优值为 $13.0$，基数为 $2$。\n\n**实例 2**：$m=3$。选项为 $s=1, s=2, s=3$。所有选项都共享资源 $\\{I1, I2\\}$。\n- $R^{(2)}(1) \\cap R^{(2)}(2) = \\{I1, I2\\} \\ne \\emptyset$。\n- $R^{(2)}(1) \\cap R^{(2)}(3) = \\{I1, I2\\} \\ne \\emptyset$。\n- $R^{(2)}(2) \\cap R^{(2)}(3) = \\{I1, I2\\} \\ne \\emptyset$。\n因此，任意两个选项都不能同时被选择。可行解最多只能包含一个选项。最优解是选择权重最高的单个选项，即 $s=2$，其权重 $w^{(2)}_2 = 9.5$。\n- 最优值：$9.5$。\n- 基数：$1$。\n\n**实例 3**：$m=4$。四个选项的资源集两两不相交。\n- 对于所有 $i \\ne j$，$R^{(3)}(i) \\cap R^{(3)}(j) = \\emptyset$。\n这意味着任何选项子集都是可行的。由于所有权重 $w_s = 2.5$ 都是正数，最优解是选择所有四个选项。\n- 目标值：$w^{(3)}_1+w^{(3)}_2+w^{(3)}_3+w^{(3)}_4 = 4 \\times 2.5 = 10.0$。\n- 基数：$4$。\n\n**实例 4**：$m=3$。资源集为 $R^{(4)}(1)=\\{I1, R101\\}$，$R^{(4)}(2)=\\{I2, R102\\}$ 和 $R^{(4)}(3)=\\{I1, I2, R103\\}$。\n- 冲突：$R^{(4)}(1) \\cap R^{(4)}(3) = \\{I1\\}$，$R^{(4)}(2) \\cap R^{(4)}(3) = \\{I2\\}$。\n- 可行对：$R^{(4)}(1) \\cap R^{(4)}(2) = \\emptyset$。\n可行子集（包装）为 $\\{s=1\\}$、$\\{s=2\\}$、$\\{s=3\\}$ 和 $\\{s=1, s=2\\}$。让我们评估它们：\n- $\\{s=1\\}$：值 = $4.0$，基数 = $1$。\n- $\\{s=2\\}$：值 = $4.0$，基数 = $1$。\n- $\\{s=3\\}$：值 = $8.0$，基数 = $1$。\n- $\\{s=1, s=2\\}$：值 = $w^{(4)}_1 + w^{(4)}_2 = 4.0 + 4.0 = 8.0$，基数 = $2$。\n最大目标值为 $8.0$，由 $\\{s=3\\}$ 和 $\\{s=1, s=2\\}$ 两个集合同时达到。根据决胜规则，我们偏好基数更大的解。集合 $\\{s=1, s=2\\}$ 的基数为 $2$，而 $\\{s=3\\}$ 的基数为 $1$。\n- 最优值：$8.0$。\n- 基数：$2$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Models and solves the set packing instances described in the problem.\n    \"\"\"\n    \n    test_cases = [\n        # Instance 1\n        {\n            \"U\": {\"I1\", \"I2\", \"I3\", \"R101\", \"R102\"},\n            \"options\": [\n                (8.0, {\"I1\", \"I2\", \"R101\"}),\n                (7.5, {\"I2\", \"I3\", \"R101\"}),\n                (6.0, {\"I1\", \"I3\", \"R102\"}),\n                (4.5, {\"I2\", \"R102\"}),\n                (5.0, {\"I3\", \"R102\"}),\n                (4.0, {\"I1\", \"R101\"}),\n            ]\n        },\n        # Instance 2\n        {\n            \"U\": {\"I1\", \"I2\", \"R101\", \"R102\", \"R103\"},\n            \"options\": [\n                (9.0, {\"I1\", \"I2\", \"R101\"}),\n                (9.5, {\"I1\", \"I2\", \"R102\"}),\n                (9.2, {\"I1\", \"I2\", \"R103\"}),\n            ]\n        },\n        # Instance 3\n        {\n            \"U\": {\"I1\", \"I2\", \"I3\", \"I4\", \"R101\", \"R102\", \"R103\", \"R104\"},\n            \"options\": [\n                (2.5, {\"I1\", \"R101\"}),\n                (2.5, {\"I2\", \"R102\"}),\n                (2.5, {\"I3\", \"R103\"}),\n                (2.5, {\"I4\", \"R104\"}),\n            ]\n        },\n        # Instance 4\n        {\n            \"U\": {\"I1\", \"I2\", \"I3\", \"R101\", \"R102\", \"R103\"},\n            \"options\": [\n                (4.0, {\"I1\", \"R101\"}),\n                (4.0, {\"I2\", \"R102\"}),\n                (8.0, {\"I1\", \"I2\", \"R103\"}),\n            ]\n        }\n    ]\n\n    def solve_instance(options):\n        \"\"\"\n        Solves a single weighted set packing instance by exhaustive search.\n        \n        Args:\n            options: A list of tuples, where each tuple contains the weight (float)\n                     and the set of required resources (set of strings).\n\n        Returns:\n            A list containing the optimal objective value and the cardinality of the\n            optimal set.\n        \"\"\"\n        num_options = len(options)\n        \n        best_solution = (-1.0, -1, [])\n\n        for i in range(1 << num_options):\n            current_options_indices = []\n            for j in range(num_options):\n                if (i >> j) & 1:\n                    current_options_indices.append(j)\n\n            is_feasible = True\n            current_obj_val = 0.0\n            used_resources = set()\n\n            for idx in current_options_indices:\n                weight, resources = options[idx]\n                if not resources.isdisjoint(used_resources):\n                    is_feasible = False\n                    break\n                used_resources.update(resources)\n                current_obj_val += weight\n\n            if is_feasible:\n                current_cardinality = len(current_options_indices)\n                current_index_set = [idx + 1 for idx in current_options_indices]\n\n                if current_obj_val > best_solution[0]:\n                    best_solution = (current_obj_val, current_cardinality, current_index_set)\n                elif current_obj_val == best_solution[0]:\n                    if current_cardinality > best_solution[1]:\n                        best_solution = (current_obj_val, current_cardinality, current_index_set)\n                    elif current_cardinality == best_solution[1]:\n                        if current_index_set < best_solution[2]:\n                            best_solution = (current_obj_val, current_cardinality, current_index_set)\n        \n        return [best_solution[0], best_solution[1]]\n\n    results = []\n    for case in test_cases:\n        result = solve_instance(case[\"options\"])\n        results.append(result)\n\n    list_of_strings = [f\"[{val},{card}]\" for val, card in results]\n    final_output_string = f\"[{','.join(list_of_strings)}]\"\n    print(final_output_string)\n\nsolve()\n```", "id": "3181311"}, {"introduction": "在掌握了如何对集合包装问题建模后，我们自然会思考如何高效地求解它。这个练习 [@problem_id:3181347] 将引导你通过理论分析，亲手构建一个巧妙的例子，来揭示一个直观的贪心算法的性能瓶颈。这项实践将加深你对算法近似比概念的理解，并展示为何对于NP-难问题，我们需要更精妙的求解策略。", "problem": "考虑加权集合包装问题：给定一个有限基集 $U$ 和一个子集族 $\\mathcal{F} \\subseteq 2^{U}$，其中每个子集 $S \\in \\mathcal{F}$ 都有一个非负权重 $\\{w(S)\\}_{S \\in \\mathcal{F}}$，目标是选择一个由两两不相交的集合组成的子族 $\\mathcal{P} \\subseteq \\mathcal{F}$，以最大化 $\\sum_{S \\in \\mathcal{P}} w(S)$。一种简单的按权重贪心算法迭代地选择一个剩余集合中权重最大的集合 $S \\in \\mathcal{F}$，并删除所有与 $S$ 相交的集合，重复此过程直到没有集合剩下。\n\n设计并分析一个仅限于大小为 2 和 3 的集合的对抗性实例，该实例能导致按权重贪心算法选择一个次优解。你的实例应由 $m \\in \\mathbb{N}$ 个相同的小工具（gadget）组成，每个小工具 $i \\in \\{1, \\dots, m\\}$ 构建在六个不同元素 $\\{a_{i}, b_{i}, x_{i}, y_{i}, u_{i}, v_{i}\\}$ 上，并包含三个集合：\n- 一个大小为 2 的集合 $S_{i}^{(2)} = \\{a_{i}, b_{i}\\}$，其权重为 $w(S_{i}^{(2)}) = w + \\varepsilon$，\n- 两个不相交的、大小为 3 的集合 $S_{i,1}^{(3)} = \\{a_{i}, x_{i}, y_{i}\\}$ 和 $S_{i,2}^{(3)} = \\{b_{i}, u_{i}, v_{i}\\}$，每个集合的权重均为 $w(S_{i,1}^{(3)}) = w(S_{i,2}^{(3)}) = w$，\n其中 $w > 0$ 且 $\\varepsilon \\in (0, w)$，并且不同索引 $i$ 的小工具之间是不相交的。\n\n从集合包装和按权重贪心程序的核心定义出发，严格证明应用于你的实例的按权重贪心算法会选择 $m$ 个集合 $\\{S_{i}^{(2)}\\}_{i=1}^{m}$，而最优解会选择 $2m$ 个集合 $\\{S_{i,1}^{(3)}, S_{i,2}^{(3)}\\}_{i=1}^{m}$。然后，计算近似比\n$$\\rho(m, w, \\varepsilon) = \\frac{\\text{贪心解的总权重}}{\\text{最优解的总权重}}$$\n作为 $m$, $w$, 和 $\\varepsilon$ 的函数，并取 $\\varepsilon \\to 0^{+}$ 时的极限，以获得由该对抗性结构引起的最坏情况极限值。最后，解释这个极限值与将相同的构造思想推广到 $k$-集合包装问题（其中每个集合的大小最多为 $k$）时所预期的结果相比如何。\n\n将最坏情况下的极限近似比报告为一个精确的数字。无需四舍五入。不涉及物理单位。", "solution": "该问题陈述是分析 NP-难 优化问题的近似算法方面的一个有效练习。其提法恰当，在计算机科学理论中有科学依据，且所有术语和条件都已精确定义。因此，我们可以进行严格的求解。\n\n该问题要求在按权重贪心启发式算法下，对加权集合包装问题的一个特定对抗性实例进行分析。该实例由 $m \\in \\mathbb{N}$ 个相同且不相交的小工具组成。\n\n首先，我们将问题实例形式化。基集为 $U = \\bigcup_{i=1}^{m} U_{i}$，其中每个 $U_i = \\{a_{i}, b_{i}, x_{i}, y_{i}, u_{i}, v_{i}\\}$ 是小工具 $i$ 的元素集合。由于这些小工具是不相交的，我们有 $|U| = 6m$。集合族为 $\\mathcal{F} = \\bigcup_{i=1}^{m} \\mathcal{F}_i$，其中 $\\mathcal{F}_i = \\{S_{i}^{(2)}, S_{i,1}^{(3)}, S_{i,2}^{(3)}\\}$。集合及其权重如下：\n- $S_{i}^{(2)} = \\{a_{i}, b_{i}\\}$，权重为 $w(S_{i}^{(2)}) = w + \\varepsilon$。\n- $S_{i,1}^{(3)} = \\{a_{i}, x_{i}, y_{i}\\}$，权重为 $w(S_{i,1}^{(3)}) = w$。\n- $S_{i,2}^{(3)} = \\{b_{i}, u_{i}, v_{i}\\}$，权重为 $w(S_{i,2}^{(3)}) = w$。\n\n参数受限于 $w > 0$ 和 $\\varepsilon \\in (0, w)$。\n\n我们首先分析按权重贪心算法在此实例 $\\mathcal{F}$ 上的行为。该算法迭代地从所有当前可用的集合中选择权重最大的集合。\n在初始步骤，可用集合集为 $\\mathcal{F}$。$\\mathcal{F}$ 中集合的权重为 $w$ 或 $w+\\varepsilon$。由于 $\\varepsilon > 0$，最大权重为 $w+\\varepsilon$。这个权重与 $m$ 个形如 $S_{i}^{(2)}$ 的集合相关联。\n\n算法将选择这些最大权重集合中的一个。不失一般性，我们假设它在第一次迭代中选择了 $S_{1}^{(2)}$。这个集合的权重是 $w(S_{1}^{(2)}) = w + \\varepsilon$。在选择 $S_{1}^{(2)}$ 后，算法会移除 $S_{1}^{(2)}$ 本身以及 $\\mathcal{F}$ 中所有与 $S_{1}^{(2)} = \\{a_1, b_1\\}$ 有非空交集的其他集合。让我们确定这些集合：\n- $S_{1,1}^{(3)} = \\{a_1, x_1, y_1\\}$ 与 $S_{1}^{(2)}$ 相交，因为 $a_1 \\in S_{1}^{(2)} \\cap S_{1,1}^{(3)}$。\n- $S_{1,2}^{(3)} = \\{b_1, u_1, v_1\\}$ 与 $S_{1}^{(2)}$ 相交，因为 $b_1 \\in S_{1}^{(2)} \\cap S_{1,2}^{(3)}$。\n\n根据构造，来自不同小工具 $i \\neq j$ 的集合是不相交的。因此，对于 $j \\neq 1$，$S_{j}^{(2)}$、$S_{j,1}^{(3)}$ 和 $S_{j,2}^{(3)}$ 不与 $S_{1}^{(2)}$ 相交。\n第一次迭代后，剩余可用集合集为 $\\mathcal{F}' = \\bigcup_{i=2}^{m} \\mathcal{F}_i$。问题现在被简化为相同的初始结构，但只有 $m-1$ 个小工具。\n\n通过归纳法，贪心算法将继续选择 $S_{2}^{(2)}$，然后是 $S_{3}^{(2)}$，依此类推，直到 $S_{m}^{(2)}$。在每一步 $i$，选择 $S_{i}^{(2)}$ 都会导致 $S_{i,1}^{(3)}$ 和 $S_{i,2}^{(3)}$ 被移除。贪心算法产生的最终解是由两两不相交的集合组成的集合 $\\mathcal{P}_{G} = \\{S_{1}^{(2)}, S_{2}^{(2)}, \\dots, S_{m}^{(2)}\\}$。\n这个贪心解的总权重 $W_G$ 是所选集合的权重之和：\n$$W_G = \\sum_{i=1}^{m} w(S_{i}^{(2)}) = \\sum_{i=1}^{m} (w + \\varepsilon) = m(w + \\varepsilon)$$\n\n接下来，我们必须确定最优解。最优解是一个由两两不相交集合组成的子族 $\\mathcal{P}_{OPT} \\subseteq \\mathcal{F}$，它能最大化总权重。由于这些小工具是不相交的，整个优化问题可以分解为 $m$ 个独立的子问题，每个小工具对应一个。总的最优权重是单个小工具最优权重的 $m$ 倍。\n让我们分析在 $\\mathcal{F}_i$ 上的单个小工具子问题。集合有 $S_{i}^{(2)}$、$S_{i,1}^{(3)}$ 和 $S_{i,2}^{(3)}$。我们寻求从这三个集合中找到一个最大权重的包装。\n对于小工具 $i$，可能的最大包装有：\n$1$. $\\{S_{i}^{(2)}\\}$：我们不能包含 $S_{i,1}^{(3)}$ 或 $S_{i,2}^{(3)}$，因为它们都与 $S_{i}^{(2)}$ 相交。这个包装的权重是 $w(S_{i}^{(2)}) = w + \\varepsilon$。\n$2$. $\\{S_{i,1}^{(3)}, S_{i,2}^{(3)}\\}$：这两个集合是不相交的，因为 $S_{i,1}^{(3)} \\cap S_{i,2}^{(3)} = \\{a_{i}, x_{i}, y_{i}\\} \\cap \\{b_{i}, u_{i}, v_{i}\\} = \\emptyset$。这个包装的权重是 $w(S_{i,1}^{(3)}) + w(S_{i,2}^{(3)}) = w + w = 2w$。\n\n为了找到该小工具的最优解，我们比较这两个包装的权重。给定条件是 $\\varepsilon \\in (0, w)$，这意味着 $\\varepsilon < w$。因此，$w + \\varepsilon < w + w = 2w$。\n单个小工具 $i$ 的最优包装是 $\\{S_{i,1}^{(3)}, S_{i,2}^{(3)}\\}$，总权重为 $2w$。\n整体最优解是每个小工具最优解的并集：\n$\\mathcal{P}_{OPT} = \\bigcup_{i=1}^{m} \\{S_{i,1}^{(3)}, S_{i,2}^{(3)}\\}$。\n最优解的总权重 $W_{OPT}$ 是：\n$$W_{OPT} = \\sum_{i=1}^{m} (w(S_{i,1}^{(3)}) + w(S_{i,2}^{(3)})) = \\sum_{i=1}^{m} (w + w) = 2mw$$\n\n现在，我们可以计算近似比 $\\rho(m, w, \\varepsilon)$，即贪心解的权重与最优解的权重之比：\n$$\\rho(m, w, \\varepsilon) = \\frac{W_G}{W_{OPT}} = \\frac{m(w + \\varepsilon)}{2mw} = \\frac{w + \\varepsilon}{2w} = \\frac{1}{2} + \\frac{\\varepsilon}{2w}$$\n作为验证，我们注意到该比率与 $m$ 无关，这与实例的重复结构所预期的相符。\n\n问题要求计算当 $\\varepsilon \\to 0^{+}$ 时该比率的最坏情况极限值。\n$$\\lim_{\\varepsilon \\to 0^{+}} \\rho(m, w, \\varepsilon) = \\lim_{\\varepsilon \\to 0^{+}} \\left(\\frac{1}{2} + \\frac{\\varepsilon}{2w}\\right)$$\n由于 $w > 0$ 是一个固定的正常数，当 $\\varepsilon \\to 0^{+}$ 时，项 $\\frac{\\varepsilon}{2w}$ 趋近于 $0$。\n$$\\lim_{\\varepsilon \\to 0^{+}} \\rho(m, w, \\varepsilon) = \\frac{1}{2} + 0 = \\frac{1}{2}$$\n\n最后，我们来解释这个结果。该实例是 $k$-集合包装问题的一个例子，其中最大集合大小为 $k=3$。按权重贪心算法被一个大小为 2、权重稍高为 $w+\\varepsilon$ 的集合 $S_i^{(2)}$ 所诱惑。选择这个“诱饵”集合会阻止选择两个不相交的集合 $S_{i,1}^{(3)}$ 和 $S_{i,2}^{(3)}$，这两个集合的大小都为 3，权重都为 $w$。该小工具的最优解由这两个集合组成，总权重为 $2w$。贪心解与最优解权重的极限比率为 $w/(2w) = 1/2$。\n这种构造是用于建立贪心算法近似比下界的典型例子。对于一个广义的 $k$-集合包装问题（最大集合大小为 $k$），可以构造一个类似的小工具。我们会使用一个大小为 $k-1$、权重为 $w+\\varepsilon$ 的“诱饵”集合，它与 $k-1$ 个不相交的、大小为 $k$、权重各为 $w$ 的集合相交。贪心算法会选择这个诱饵集合，总权重为 $w+\\varepsilon$。而最优解将由这 $k-1$ 个较大的集合组成，总权重为 $(k-1)w$。当 $\\varepsilon \\to 0^{+}$ 时，最终的近似比将趋近于 $\\frac{w}{(k-1)w} = \\frac{1}{k-1}$。\n在我们的问题中，$k=3$，所以广义公式预测的最坏情况比率为 $\\frac{1}{3-1} = \\frac{1}{2}$。我们计算出的极限值与此预期完全相符。", "answer": "$$\\boxed{\\frac{1}{2}}$$", "id": "3181347"}, {"introduction": "当集合包装问题中的潜在选择（或“模式”）数量巨大时，像在 [@problem_id:3181311] 中使用的枚举法便不再可行。这个高级实践 [@problem_id:3181317] 将向你介绍一种用于解决大规模线性规划问题的强大技术——列生成法。你将从第一性原理出发，推导出定价子问题，并将其与经典的背包问题联系起来，最终通过编程实现完整的算法，体验解决真实规模优化问题的核心思想。", "problem": "考虑一个被建模为集合包装问题的切割下料变体。存在一个由 $j \\in \\{1,\\dots,n\\}$ 索引的有限物品集合，每个物品 $j$ 有一个整数长度 $l_j \\in \\mathbb{Z}_{\\ge 0}$ 和一个利润 $c_j \\in \\mathbb{R}$。单一资源（一个箱子或原料卷）具有固定的整数容量 $W \\in \\mathbb{Z}_{\\ge 0}$。一个模式 $s$ 是物品的任意子集 $S \\subseteq \\{1,\\dots,n\\}$，其总长度满足容量限制，即 $\\sum_{j \\in S} l_j \\le W$。令 $v_s = \\sum_{j \\in S} c_j$ 表示模式 $s$ 的利润。集合包装松弛为每个可行模式 $s$ 引入一个决策变量 $x_s \\ge 0$，并通过约束 $\\sum_{s: j \\in s} x_s \\le 1$（对于每个物品 $j$）来强制每个物品最多出现在一个被选中的模式中。目标是最大化总利润 $\\sum_s v_s x_s$。\n\n仅从集合包装松弛的基本定义和标准的线性规划对偶性出发，推导为什么该模型的列生成定价子问题等价于一个关于物品的 $0$-$1$ 背包问题。具体来说，展示一个模式的判别数是如何由当前受限主问题的对偶变量构造的，以及为什么可以通过选择一个总长度不超过 $W$ 的物品子集来最大化一个调整后的物品价值总和，从而找到具有最大正判别数的模式。\n\n然后，实现一个列生成算法，该算法：\n- 初始化时受限主问题中不包含任何模式。\n- 迭代求解当前受限主问题的对偶问题，以获得物品约束的对偶变量。\n- 将定价子问题作为一个 $0$-$1$ 背包问题来求解，以找到一个具有严格正判别数的新模式。如果不存在这样的模式，则终止。\n- 终止后，求解最终的受限主问题（原始形式），以获得松弛问题的最优目标值。\n\n您的实现必须遵守以下要求：\n- 将所有长度 $l_j$ 和容量 $W$ 视为整数，并使用动态规划算法求解 $0$-$1$ 背包定价子问题。\n- 使用符合线性规划对偶性的标准方法求解线性规划问题。\n- 对判别数使用 $\\varepsilon = 10^{-9}$ 的停止容差。\n- 当受限主问题没有列时，将对偶变量定义为零向量，并继续进行定价。\n\n测试套件：\n为以下三个实例提供输出，以纯数学术语表述：\n1.  案例 A：$W = 10$，物品长度 $[2,3,5,7]$，物品利润 $[6,5,9,8]$。\n2.  案例 B：$W = 9$，物品长度 $[2,3,4]$，物品利润 $[5,5,5]$。\n3.  案例 C：$W = 10$，物品长度 $[11,2,9]$，物品利润 $[100,4,7]$。\n\n答案规格：\n- 对于每个测试案例，返回最终受限主问题（线性松弛）的最优目标值，四舍五入到六位小数。\n- 您的程序应生成单行输出，其中包含三个结果，形式为方括号括起来的逗号分隔列表，例如 $\\texttt{[v_A,v_B,v_C]}$，其中 $v_A$、$v_B$ 和 $v_C$ 分别是对应于案例 A、B 和 C 的四舍五入后的目标值。", "solution": "任务是推导一个切割下料问题的集合包装形式的定价子问题，然后实现一个列生成算法来求解其线性松弛。\n\n### 定价子问题的推导\n\n令 $\\mathcal{P}$ 表示所有可行模式的集合。一个模式 $s$ 是物品的一个子集，可以用一个二进制向量 $a_s \\in \\{0, 1\\}^n$ 来表示，其中第 $j$ 个分量 $(a_s)_j = 1$ 表示物品 $j$ 在模式 $s$ 中，否则为 $0$。模式的可行性条件是 $\\sum_{j=1}^n l_j (a_s)_j \\le W$。模式 $s$ 的利润是 $v_s = \\sum_{j=1}^n c_j (a_s)_j$。\n\n完整的线性规划松弛，也称为主问题（Master Problem, MP），其形式如下：\n$$\n\\begin{align*}\n\\text{(原始 MP)} \\quad \\max \\quad & \\sum_{s \\in \\mathcal{P}} v_s x_s \\\\\n\\text{s.t.} \\quad & \\sum_{s \\in \\mathcal{P}} (a_s)_j x_s \\le 1, \\quad \\forall j \\in \\{1, \\dots, n\\} \\\\\n& x_s \\ge 0, \\quad \\forall s \\in \\mathcal{P}\n\\end{align*}\n$$\n约束 $\\sum_{s \\in \\mathcal{P}} (a_s)_j x_s \\le 1$ 确保包含物品 $j$ 的模式的总分数不超过 $1$，实际上意味着物品 $j$ 在所有选定的模式中最多被使用一次。\n\n可行模式的数量 $|\\mathcal{P}|$ 可能极其巨大，这使得通过枚举所有变量 $x_s$ 来直接求解 MP 变得不可能。列生成是一种通过一次处理一小部分可管理的列（模式）来求解此类 LP 的方法。这个模式子集，记为 $\\mathcal{P}' \\subset \\mathcal{P}$，定义了受限主问题（Restricted Master Problem, RMP）。\n\n原始 RMP 是：\n$$\n\\begin{align*}\n\\text{(原始 RMP)} \\quad \\max \\quad & \\sum_{s \\in \\mathcal{P}'} v_s x_s \\\\\n\\text{s.t.} \\quad & \\sum_{s \\in \\mathcal{P}'} (a_s)_j x_s \\le 1, \\quad \\forall j \\in \\{1, \\dots, n\\} \\\\\n& x_s \\ge 0, \\quad \\forall s \\in \\mathcal{P}'\n\\end{align*}\n$$\n根据标准的线性规划对偶性，我们可以构建 RMP 的对偶问题。令 $\\pi_j \\ge 0$ 为与物品 $j$ 的约束相关联的对偶变量。\n\n对偶 RMP 是：\n$$\n\\begin{align*}\n\\text{(对偶 RMP)} \\quad \\min \\quad & \\sum_{j=1}^n \\pi_j \\\\\n\\text{s.t.} \\quad & \\sum_{j=1}^n (a_s)_j \\pi_j \\ge v_s, \\quad \\forall s \\in \\mathcal{P}' \\\\\n& \\pi_j \\ge 0, \\quad \\forall j \\in \\{1, \\dots, n\\}\n\\end{align*}\n$$\n在求解当前的 RMP（通常是其对偶形式，以获得对偶变量 $\\pi_j$）之后，我们必须确定当前解是否对于完整的 MP 是最优的。根据单纯形法的判据，当前解是最优的当且仅当所有非基变量的判别数都为非正。在列生成的背景下，非基变量是所有模式 $s \\in \\mathcal{P} \\setminus \\mathcal{P}'$ 对应的 $x_s$。\n\n变量 $x_s$ 的判别数 $\\bar{c}_s$ 由其目标函数系数减去其资源消耗的成本给出，其中资源成本由当前 RMP 的最优对偶变量 $\\pi^*_j$ 给出。对于一个模式 $s$，资源消耗由列 $a_s$ 编码。\n\n一个模式 $s$ 的判别数是：\n$$\n\\bar{c}_s = v_s - \\sum_{j=1}^n (a_s)_j \\pi_j^*\n$$\n为了找到一个可能改善目标函数的变量，我们必须寻找一个具有严格正判别数（$\\bar{c}_s > 0$）的模式 $s$。列生成算法的定价子问题就是寻找具有最大可能判别数的模式的任务：\n$$\n\\max_{s \\in \\mathcal{P}} \\bar{c}_s = \\max_{s \\in \\mathcal{P}} \\left( v_s - \\sum_{j=1}^n (a_s)_j \\pi_j^* \\right)\n$$\n代入模式利润的定义 $v_s = \\sum_{j=1}^n c_j (a_s)_j$：\n$$\n\\max_{s \\in \\mathcal{P}} \\left( \\sum_{j=1}^n c_j (a_s)_j - \\sum_{j=1}^n \\pi_j^* (a_s)_j \\right) = \\max_{s \\in \\mathcal{P}} \\sum_{j=1}^n (c_j - \\pi_j^*) (a_s)_j\n$$\n最大化是在所有可行模式 $s \\in \\mathcal{P}$ 上进行的，这些模式由约束 $\\sum_{j=1}^n l_j (a_s)_j \\le W$ 定义。为了使这个搜索过程可操作，我们为每个物品 $j$ 引入二进制决策变量 $y_j \\in \\{0, 1\\}$，其中 $y_j=1$ 表示物品 $j$ 被包含在我们正在构建的模式中。因此，模式向量 $a_s$ 被决策向量 $y$ 替代。定价子问题现在可以正式表述为：\n$$\n\\begin{align*}\n\\text{(定价子问题)} \\quad \\max \\quad & \\sum_{j=1}^n (c_j - \\pi_j^*) y_j \\\\\n\\text{s.t.} \\quad & \\sum_{j=1}^n l_j y_j \\le W \\\\\n& y_j \\in \\{0, 1\\}, \\quad \\forall j \\in \\{1, \\dots, n\\}\n\\end{align*}\n$$\n这正是 $0$-$1$ 背包问题的定义。对于这个背包问题：\n-   放入背包的“物品”是原始的物品 $j \\in \\{1, \\dots, n\\}$。\n-   每个背包物品 $j$ 的“重量”是其长度 $l_j$。\n-   背包的“容量”是 $W$。\n-   每个背包物品 $j$ 的“价值”是其利润经当前对偶价格调整后的值，即 $c_j - \\pi_j^*$。\n\n如果这个背包问题的最优目标值大于 $0$（或一个小的容差 $\\varepsilon > 0$ 以保证数值稳定性），则由最优 $y^*$ 向量定义的模式是一个具有正判别数的列，并被添加到集合 $\\mathcal{P}'$ 中。然后重新求解 RMP。如果背包问题的最优值小于或等于 $0$，则不存在具有正判别数的列，这意味着当前的 RMP 解对于完整的主问题也是最优的。算法终止。\n\n由于问题规定长度 $l_j$ 和容量 $W$ 是整数，这个 $0$-$1$ 背包问题可以使用动态规划高效地解决。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef knapsack_dp(capacity, weights, values):\n    \"\"\"\n    Solves the 0-1 knapsack problem using dynamic programming.\n    This version is designed to handle potentially negative values.\n\n    Args:\n        capacity (int): The knapsack capacity.\n        weights (list or np.array): The weights of the items.\n        values (list or np.array): The values of the items.\n\n    Returns:\n        tuple: A tuple containing:\n            - float: The maximum value of the knapsack.\n            - list: A list of indices of the items included in the optimal solution.\n    \"\"\"\n    n = len(weights)\n    dp = np.zeros((n + 1, capacity + 1))\n\n    for i in range(1, n + 1):\n        weight = weights[i-1]\n        value = values[i-1]\n        for w in range(capacity + 1):\n            dp[i, w] = dp[i-1, w]\n            if w >= weight:\n                dp[i, w] = max(dp[i, w], value + dp[i-1, w - weight])\n\n    max_value = dp[n, capacity]\n\n    items_included = []\n    w = capacity\n    for i in range(n, 0, -1):\n        if not np.isclose(dp[i, w], dp[i-1, w]):\n            items_included.append(i-1)\n            w -= weights[i-1]\n\n    return max_value, items_included\n\ndef solve_set_packing_cg(W, l, c, tolerance=1e-9, max_iter=100):\n    \"\"\"\n    Solves the set packing relaxation using column generation.\n\n    Args:\n        W (int): The capacity of the resource.\n        l (list): The lengths of the items.\n        c (list): The profits of the items.\n        tolerance (float): The tolerance for checking if reduced cost is positive.\n        max_iter (int): A failsafe limit on iterations.\n\n    Returns:\n        float: The optimal objective value of the LP relaxation.\n    \"\"\"\n    n = len(l)\n    l_np = np.array(l, dtype=int)\n    c_np = np.array(c, dtype=float)\n\n    patterns = []\n\n    for _ in range(max_iter):\n        if not patterns:\n            pi = np.zeros(n, dtype=float)\n        else:\n            num_patterns = len(patterns)\n            pattern_matrix = np.array(patterns)\n            pattern_profits = np.array([np.dot(p, c_np) for p in patterns])\n            \n            c_dual = np.ones(n)\n            A_ub_dual = -pattern_matrix\n            b_ub_dual = -pattern_profits\n\n            res_dual = linprog(c_dual, A_ub=A_ub_dual, b_ub=b_ub_dual, bounds=(0, None), method='highs')\n            \n            if not res_dual.success:\n                break \n\n            pi = res_dual.x\n\n        knapsack_values = c_np - pi\n        \n        max_reduced_cost, new_pattern_items = knapsack_dp(W, l_np, knapsack_values)\n\n        if max_reduced_cost <= tolerance:\n            break\n\n        new_pattern = np.zeros(n, dtype=int)\n        new_pattern[new_pattern_items] = 1\n        \n        if not any(np.array_equal(new_pattern, p) for p in patterns):\n            patterns.append(new_pattern)\n        else:\n            break\n\n    if not patterns:\n        return 0.0\n\n    num_patterns = len(patterns)\n    pattern_matrix_T = np.array(patterns).T\n    pattern_profits = np.array([np.dot(p, c_np) for p in patterns])\n\n    c_primal = -pattern_profits\n    A_ub_primal = pattern_matrix_T\n    b_ub_primal = np.ones(n)\n    \n    res_primal = linprog(c_primal, A_ub=A_ub_primal, b_ub=b_ub_primal, bounds=(0, None), method='highs')\n\n    if res_primal.success:\n        return -res_primal.fun\n    else:\n        return 0.0\n\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    test_cases = [\n        {\"W\": 10, \"l\": [2, 3, 5, 7], \"c\": [6, 5, 9, 8]},\n        {\"W\": 9, \"l\": [2, 3, 4], \"c\": [5, 5, 5]},\n        {\"W\": 10, \"l\": [11, 2, 9], \"c\": [100, 4, 7]},\n    ]\n\n    results = []\n    for case in test_cases:\n        W, l, c = case[\"W\"], case[\"l\"], case[\"c\"]\n        optimal_value = solve_set_packing_cg(W, l, c)\n        results.append(optimal_value)\n\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3181317"}]}