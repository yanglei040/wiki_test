{"hands_on_practices": [{"introduction": "许多现实世界中的成本并非严格线性；例如，成本可能会在达到某个阈值时发生变化（如批量折扣或加班费率）。本练习模拟了一个带有此类成本的最小成本网络流问题。它将教你一种强大的建模技术——分段线性化，即将一个凸的非线性成本函数通过引入新变量，转化为一个等价的线性函数。掌握这项技能将极大地扩展你能用线性规划解决的问题范围，使你能够更精确地为更真实、更复杂的情景建模。[@problem_id:3106543]", "problem": "要求您使用线性规划（LP）建立并求解一个带有分段线性弧成本的单商品最小成本网络流模型。其基本原理是网络流量守恒定律：对于每个节点，总流出量减去总流入量等于该节点的净供给（源点为正）或净需求（汇点为负），以及线性优化的定义，即在线性等式约束和变量边界条件下最小化一个线性目标函数。\n\n每条有向弧 $(i,j)$ 都有一个容量 $u_{ij}$ 和一个凸分段线性成本，形式为 $c_{ij}(f_{ij}) = a_{ij} f_{ij} + b_{ij} \\max(0, f_{ij} - \\theta_{ij})$，其中 $f_{ij}$ 是弧 $(i,j)$ 上的流量，$a_{ij} \\ge 0$，$b_{ij} \\ge 0$ 且 $\\theta_{ij} \\ge 0$。为了得到一个线性规划，使用两个非负的段变量来表示 $f_{ij}$，这两个变量相对于阈值 $\\theta_{ij}$ 来分割流量，并施加适当的边界和守恒约束。在满足每个节点的流量守恒和弧容量限制的条件下，最小化总成本。\n\n您的程序必须：\n- 为每个测试用例构建上述描述所隐含的线性规划（LP）：为每条弧引入段变量以线性化成本，施加从 $u_{ij}$ 和 $\\theta_{ij}$ 导出的段边界，并施加从节点供给和需求导出的节点流量守恒等式。\n- 求解该线性规划，并为每个测试用例返回最优目标值（总成本），格式为十进制数。\n\n不涉及物理单位。不出现角度。不出现百分比。\n\n测试套件：\n提供一个能够解决以下三个测试用例的单一程序。每个测试用例描述一个有向网络。节点由标签表示，弧由元组 $(i,j,a_{ij},b_{ij},\\theta_{ij},u_{ij})$ 给出，其中所有数学实体（包括数字）均用 LaTeX 书写。\n\n- 测试用例 $1$（正常路径，混合阈值和容量）：\n  - 节点：$\\{S,A,B,T\\}$。\n  - 供给/需求：$s_S = 6$, $s_A = 0$, $s_B = 0$, $s_T = -6$。\n  - 弧：\n    - $(S,A,a_{SA}=2,b_{SA}=3,\\theta_{SA}=3,u_{SA}=5)$,\n    - $(S,B,a_{SB}=1,b_{SB}=0.5,\\theta_{SB}=1,u_{SB}=4)$,\n    - $(A,T,a_{AT}=1.5,b_{AT}=2,\\theta_{AT}=2,u_{AT}=4)$,\n    - $(B,T,a_{BT}=2,b_{BT}=1,\\theta_{BT}=4,u_{BT}=5)$,\n    - $(S,T,a_{ST}=3,b_{ST}=1,\\theta_{ST}=1,u_{ST}=2)$.\n\n- 测试用例 $2$（边界情况：容量等于阈值或容量低于阈值）：\n  - 节点：$\\{S,A,T\\}$。\n  - 供给/需求：$s_S = 5$, $s_A = 0$, $s_T = -5$。\n  - 弧：\n    - $(S,A,a_{SA}=1,b_{SA}=5,\\theta_{SA}=3,u_{SA}=3)$,\n    - $(A,T,a_{AT}=2,b_{AT}=4,\\theta_{AT}=5,u_{AT}=3)$,\n    - $(S,T,a_{ST}=4,b_{ST}=0,\\theta_{ST}=2,u_{ST}=2)$.\n\n- 测试用例 $3$（边缘情况：零阈值）：\n  - 节点：$\\{S,C,T\\}$。\n  - 供给/需求：$s_S = 4$, $s_C = 0$, $s_T = -4$。\n  - 弧：\n    - $(S,C,a_{SC}=1,b_{SC}=2,\\theta_{SC}=0,u_{SC}=5)$,\n    - $(C,T,a_{CT}=1,b_{CT}=1,\\theta_{CT}=0,u_{CT}=5)$,\n    - $(S,T,a_{ST}=0,b_{ST}=0,\\theta_{ST}=0,u_{ST}=1)$.\n\n最终输出格式：\n您的程序应生成单行输出，其中包含三个测试用例的最优目标值，形式为用方括号括起来的逗号分隔列表（例如，$[result_1,result_2,result_3]$）。每个 $result_k$ 必须是十进制数（浮点数）。程序必须是自包含的，无需输入，并直接按规定求解所提供的三个测试用例。", "solution": "该问题要求建立并求解一个单商品最小成本网络流问题，其中每条弧的成本是流量的凸分段线性函数。该问题需要被建模为线性规划（LP）。\n\n其基本原理是通过引入新变量来表示成本函数不同分段上的流量，从而将一个凸分段线性目标函数转化为线性目标函数。由于原始目标函数是凸的，且约束是线性的，最小化求解器会自然地优先使用成本较低的分段上的流量，然后再使用成本较高的分段，从而验证了这种分解的有效性，无需额外的整数变量或特殊的分支规则。\n\n设网络由有向图 $G = (V, E)$ 表示，其中 $V$ 是节点集合，$E$ 是弧集合。对于每个节点 $i \\in V$，有一个净供给 $s_i$。如果 $s_i > 0$，节点 $i$ 是一个源点。如果 $s_i  0$，它是一个汇点。如果 $s_i = 0$，它是一个转运节点。对于一个有效的问题，总供给必须等于总需求，即 $\\sum_{i \\in V} s_i = 0$。\n\n对于每条弧 $(i,j) \\in E$，给定：\n- $u_{ij}$：弧的最大容量。\n- 弧上流量 $f_{ij}$ 的一个凸分段线性成本函数 $c_{ij}(f_{ij})$，定义为：\n$$ c_{ij}(f_{ij}) = a_{ij} f_{ij} + b_{ij} \\max(0, f_{ij} - \\theta_{ij}) $$\n其中 $a_{ij} \\ge 0$，$b_{ij} \\ge 0$，$\\theta_{ij} \\ge 0$ 是成本函数斜率变化的流量阈值。\n\n优化问题是：\n$$ \\text{minimize} \\quad Z = \\sum_{(i,j) \\in E} c_{ij}(f_{ij}) $$\n约束条件：\n$1$. 每个节点 $k \\in V$ 的流量守恒：\n$$ \\sum_{j:(k,j) \\in E} f_{kj} - \\sum_{i:(i,k) \\in E} f_{ik} = s_k $$\n$2$. 每条弧 $(i,j) \\in E$ 的弧容量约束：\n$$ 0 \\le f_{ij} \\le u_{ij} $$\n\n为了线性化目标函数，我们将每条弧的流量变量 $f_{ij}$ 分解为两个非负变量 $f_{ij}^{(1)}$ 和 $f_{ij}^{(2)}$：\n$$ f_{ij} = f_{ij}^{(1)} + f_{ij}^{(2)} $$\n这些变量代表成本函数两个线性分段上的流量：\n- $f_{ij}^{(1)}$ 是第一段的流量，最高到阈值 $\\theta_{ij}$。\n- $f_{ij}^{(2)}$ 是第二段的流量，超过阈值 $\\theta_{ij}$。\n\n这种分解受以下边界约束：\n$$ 0 \\le f_{ij}^{(1)} \\le \\theta_{ij} $$\n$$ f_{ij}^{(2)} \\ge 0 $$\n这样，成本函数中的项 $\\max(0, f_{ij} - \\theta_{ij})$ 就等价于 $f_{ij}^{(2)}$。弧 $(i,j)$ 的成本函数现在可以重写为这些新变量的线性函数：\n$$ c_{ij}(f_{ij}^{(1)}, f_{ij}^{(2)}) = a_{ij} (f_{ij}^{(1)} + f_{ij}^{(2)}) + b_{ij} f_{ij}^{(2)} = a_{ij} f_{ij}^{(1)} + (a_{ij} + b_{ij}) f_{ij}^{(2)} $$\n第一段流量的边际成本是 $a_{ij}$，第二段是 $a_{ij} + b_{ij}$。由于 $b_{ij} \\ge 0$，第二段的成本总是大于或等于第一段。因此，一个最小化总成本的线性规划求解器会自动地先填满第一段（直到其边界 $\\theta_{ij}$），然后再将任何流量分配给更昂贵的第二段。\n\n完整的线性规划（LP）构建如下：\n\n**决策变量：**\n对于每条弧 $(i,j) \\in E$，我们有两个变量，$f_{ij}^{(1)}$ 和 $f_{ij}^{(2)}$。\n\n**目标函数：**\n最小化总线性成本：\n$$ \\text{minimize} \\quad Z = \\sum_{(i,j) \\in E} \\left( a_{ij} f_{ij}^{(1)} + (a_{ij} + b_{ij}) f_{ij}^{(2)} \\right) $$\n\n**约束条件：**\n$1$. 每个节点 $k \\in V$ 的流量守恒：\n$$ \\sum_{j:(k,j) \\in E} \\left( f_{kj}^{(1)} + f_{kj}^{(2)} \\right) - \\sum_{i:(i,k) \\in E} \\left( f_{ik}^{(1)} + f_{ik}^{(2)} \\right) = s_k $$\n这构成了一组线性等式约束（$A_{eq}x = b_{eq}$）。\n\n$2$. 每条弧 $(i,j) \\in E$ 的弧容量：\n$$ f_{ij}^{(1)} + f_{ij}^{(2)} \\le u_{ij} $$\n这构成了一组线性不等式约束（$A_{ub}x \\le b_{ub}$）。\n\n$3$. 每条弧 $(i,j) \\in E$ 的变量边界：\n$$ 0 \\le f_{ij}^{(1)} \\le \\theta_{ij} $$\n$$ f_{ij}^{(2)} \\ge 0 $$\n$f_{ij}^{(2)}$ 的上界由弧容量约束隐式处理。标准的线性规划形式将这些组合成一个单一的边界向量。\n\n为每个测试用例实现了这个构建。节点和弧的数据用于构建目标向量 $c$、约束矩阵 $A_{eq}$ 和 $A_{ub}$、相应的右侧向量 $b_{eq}$ 和 $b_{ub}$ 以及变量边界。然后使用一个标准的线性规划求解器，如 `scipy.optimize.linprog`，来找到最小化目标函数 $Z$ 的解向量 $x = [..., f_{ij}^{(1)}, f_{ij}^{(2)}, ...]^T$。$Z$ 的最优值是网络流的最小总成本，也就是所要求的输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Solves three minimum-cost network flow problems with piecewise-linear costs.\n    \"\"\"\n    test_cases = [\n        # Test Case 1\n        {\n            \"nodes\": [\"S\", \"A\", \"B\", \"T\"],\n            \"supplies\": {\"S\": 6.0, \"A\": 0.0, \"B\": 0.0, \"T\": -6.0},\n            \"arcs\": [\n                # (from, to, a, b, theta, u)\n                (\"S\", \"A\", 2.0, 3.0, 3.0, 5.0),\n                (\"S\", \"B\", 1.0, 0.5, 1.0, 4.0),\n                (\"A\", \"T\", 1.5, 2.0, 2.0, 4.0),\n                (\"B\", \"T\", 2.0, 1.0, 4.0, 5.0),\n                (\"S\", \"T\", 3.0, 1.0, 1.0, 2.0)\n            ]\n        },\n        # Test Case 2\n        {\n            \"nodes\": [\"S\", \"A\", \"T\"],\n            \"supplies\": {\"S\": 5.0, \"A\": 0.0, \"T\": -5.0},\n            \"arcs\": [\n                (\"S\", \"A\", 1.0, 5.0, 3.0, 3.0),\n                (\"A\", \"T\", 2.0, 4.0, 5.0, 3.0),\n                (\"S\", \"T\", 4.0, 0.0, 2.0, 2.0)\n            ]\n        },\n        # Test Case 3\n        {\n            \"nodes\": [\"S\", \"C\", \"T\"],\n            \"supplies\": {\"S\": 4.0, \"C\": 0.0, \"T\": -4.0},\n            \"arcs\": [\n                (\"S\", \"C\", 1.0, 2.0, 0.0, 5.0),\n                (\"C\", \"T\", 1.0, 1.0, 0.0, 5.0),\n                (\"S\", \"T\", 0.0, 0.0, 0.0, 1.0)\n            ]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        nodes = case[\"nodes\"]\n        supplies = case[\"supplies\"]\n        arcs_data = case[\"arcs\"]\n\n        num_nodes = len(nodes)\n        num_arcs = len(arcs_data)\n        num_vars = 2 * num_arcs\n\n        node_map = {name: i for i, name in enumerate(nodes)}\n\n        # LP formulation: min c'x s.t. A_eq x = b_eq, A_ub x = b_ub, and bounds on x.\n        \n        # 1. Objective function vector c\n        c = np.zeros(num_vars)\n        for i, arc in enumerate(arcs_data):\n            _, _, a, b, _, _ = arc\n            c[2 * i] = a         # Cost for the first segment f_ij^(1)\n            c[2 * i + 1] = a + b # Cost for the second segment f_ij^(2)\n            \n        # 2. Equality constraints A_eq, b_eq (flow conservation)\n        A_eq = np.zeros((num_nodes, num_vars))\n        b_eq = np.array([supplies[name] for name in nodes])\n        \n        for i, arc in enumerate(arcs_data):\n            u_name, v_name, _, _, _, _ = arc\n            u_idx, v_idx = node_map[u_name], node_map[v_name]\n            \n            # For arc i, variables are at 2*i and 2*i+1.\n            # Total flow on arc i is f_i^(1) + f_i^(2).\n            # It is an outflow from node u, so coefficient is +1.\n            A_eq[u_idx, 2 * i] = 1.0\n            A_eq[u_idx, 2 * i + 1] = 1.0\n            \n            # It is an inflow to node v, so coefficient is -1.\n            A_eq[v_idx, 2 * i] = -1.0\n            A_eq[v_idx, 2 * i + 1] = -1.0\n\n        # 3. Inequality constraints A_ub, b_ub (arc capacity)\n        A_ub = np.zeros((num_arcs, num_vars))\n        b_ub = np.zeros(num_arcs)\n        for i, arc in enumerate(arcs_data):\n            _, _, _, _, _, u_cap = arc\n            # f_i^(1) + f_i^(2) = u_i\n            A_ub[i, 2 * i] = 1.0\n            A_ub[i, 2 * i + 1] = 1.0\n            b_ub[i] = u_cap\n\n        # 4. Variable bounds\n        bounds = []\n        for arc in arcs_data:\n            _, _, _, _, theta, _ = arc\n            # 0 = f_i^(1) = theta_i\n            bounds.append((0, theta))\n            # 0 = f_i^(2)\n            bounds.append((0, None))\n\n        # Solve the Linear Program\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')\n\n        if res.success:\n            results.append(res.fun)\n        else:\n            # This path is not expected for the given valid test cases.\n            results.append(float('nan')) \n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3106543"}, {"introduction": "高效地调度任务是制造业、计算和物流领域的一个关键问题。本练习旨在解决带有优先次序依赖的作业在并行机器上的调度问题。这个实践超越了纯粹的线性规划，探索了组合优化。其解决方案需要理解离散决策（分配和排序）如何构建一个约束图，以及寻找最优调度与分析该图之间的关系。通过系统性地探索解空间，这个动手练习能够培养你对组合复杂性的直觉，并锻炼你的算法思维，展示如何从第一性原理出发解决调度问题。[@problem_id:3106622]", "problem": "您需要使用离散决策建模和基于图的可行性的第一性原理，设计并解决一个经典的调度优化问题。考虑有 $m$ 台同构并行机和 $n$ 个不可抢占的作业。每个作业 $j \\in \\{1,\\dots,n\\}$ 都有一个严格为正的处理时间 $p_j$ 和一个非负权重 $w_j$，并且可能受到优先约束的限制。优先约束由有向弧 $(j,k)$ 表示，意指作业 $j$ 必须在作业 $k$ 开始前完成。设 $s_j \\ge 0$ 表示作业 $j$ 的开始时间，其完成时间为 $C_j = s_j + p_j$。作业必须被分配到机器上，且分配到同一台机器上的作业不能重叠。目标是最小化总加权完成时间 $\\sum_{j=1}^n w_j C_j$。\n\n基本建模基础：\n- 优先约束可以通过对每个有向弧 $(j,k)$ 建立形如 $s_k \\ge s_j + p_j$ 的开始时间不等式来捕捉。\n- 每台机器上的不重叠约束强制执行一个析取条件：对于分配到同一台机器上的任意两个作业 $j$ 和 $k$，要么 $j$ 在 $k$ 之前处理，要么 $k$ 在 $j$ 之前处理。这个经典的析取条件在混合整数规划中可以通过一个足够大的常数 $M$ (大-$M$) 进行线性化，但其核心逻辑是通过对每对作业做出排序决策来消除重叠。\n- 对于同构机器和不可抢占作业，一旦机器分配和每台机器上的作业顺序被确定，所有开始时间都可由可行性推导得出（即在由优先弧和同机作业链构成的无环约束图上进行最长路径评估）。\n\n您的任务是编写一个完整的程序，对于一组给定的的小规模实例，通过穷举考虑所有离散的分配和排序决策，然后确定与优先约束和不重叠约束一致的最早可行开始时间，从而计算出总加权完成时间 $\\sum_{j=1}^n w_j C_j$ 的最小可能值。您不得假设或使用任何外部求解器。您的推断过程必须通过以下方式执行：\n- 枚举机器分配（每个作业映射到 $m$ 台机器之一）。\n- 枚举每台机器上的作业顺序。\n- 拒绝任何与优先约束相矛盾的分配-顺序组合（这会产生环路）。\n- 对于可行的组合，通过在由优先弧和同机作业链边构成的有向无环图（DAG）中进行最长路径传播来计算开始时间，然后评估目标值。\n\n所有时间量均以抽象时间单位（缩写为“tu”）表示。由于测试套件中所有的 $p_j$ 和 $w_j$ 都是整数，最终答案必须是无单位的数值总和（整数）。\n\n测试套件：\n您必须为以下每个实例计算 $\\sum_{j=1}^n w_j C_j$ 的最小值。描述中的索引是基于 1 的；如果您的程序使用基于 0 的数组，请进行相应调整。在每个实例中，$m$ 是机器数量，$n$ 是作业数量，$p$ 是处理时间列表，$w$ 是权重列表，$A$ 是优先弧 $(j,k)$ 的集合。\n\n- 案例 1 (理想路径)：$m = 2$, $n = 5$, $p = [\\,3,\\,2,\\,4,\\,1,\\,2\\,]$, $w = [\\,4,\\,1,\\,3,\\,2,\\,5\\,]$, $A = \\{(1,3),(2,3),(4,5)\\}$。\n- 案例 2 (单机边界情况)：$m = 1$, $n = 5$, $p = [\\,2,\\,2,\\,1,\\,3,\\,2\\,]$, $w = [\\,1,\\,1,\\,1,\\,1,\\,1\\,]$, $A = \\{(1,2),(2,3),(3,4),(4,5)\\}$。\n- 案例 3 (多台机器，无优先约束)：$m = 3$, $n = 4$, $p = [\\,1,\\,3,\\,2,\\,4\\,]$, $w = [\\,10,\\,1,\\,1,\\,1\\,]$, $A = \\varnothing$。\n- 案例 4 (耦合的优先约束，中等规模)：$m = 2$, $n = 6$, $p = [\\,3,\\,3,\\,2,\\,2,\\,4,\\,1\\,]$, $w = [\\,2,\\,2,\\,3,\\,3,\\,1,\\,5\\,]$, $A = \\{(1,5),(2,5),(3,4)\\}$。\n- 案例 5 (机器数不少于作业数，优先约束阻塞一个作业)：$m = 5$, $n = 3$, $p = [\\,5,\\,1,\\,2\\,]$, $w = [\\,1,\\,7,\\,3\\,]$, $A = \\{(3,1)\\}$。\n\n输出规范：\n您的程序应生成一行输出，其中包含案例 1 到 5 的结果，按顺序排列，形式为用方括号括起来的逗号分隔的整数列表，例如 $[x_1,x_2,x_3,x_4,x_5]$，其中每个 $x_i$ 是案例 $i$ 的 $\\sum_{j=1}^n w_j C_j$ 的最小值。", "solution": "### 基于原理的解决方案\n目标是找到一个调度方案，以最小化 $n$ 个作业在 $m$ 台同构并行机上的总加权完成时间 $Z = \\sum_{j=1}^{n} w_j C_j$。一个调度方案由每个作业到机器的分配以及每台机器上作业的具体处理序列完全确定。解决方法是穷举枚举所有可能的有效调度方案。\n\n**1. 调度方案的枚举**\n一个调度方案包括两个组成部分：\n- **机器分配：** 一个将每个作业 $j \\in \\{1, \\dots, n\\}$ 映射到某台机器 $k \\in \\{1, \\dots, m\\}$ 的函数。此类分配的总数为 $m^n$。\n- **作业排序：** 对于每台机器，分配给它的作业的一个排列。如果 $n_k$ 个作业被分配到机器 $k$，则有 $n_k!$ 种可能的排序。\n\n该算法遍历每一种可能的机器分配。对于每一种分配，它接着遍历所有机器上作业排序的每一种可能组合。\n\n**2. 通过约束图进行可行性分析**\n每个潜在的调度方案（一个分配-排序对）都会导出一组关于作业开始时间 $s_j$ 的约束。这些约束可以表示为一个有向图 $\\mathcal{G} = (\\mathcal{J}, \\mathcal{E})$，其中 $\\mathcal{J}=\\{1, \\dots, n\\}$ 是作业（节点）的集合，$\\mathcal{E}$ 是表示时间依赖关系的有向边（弧）的集合。这些边有两个来源：\n- **优先约束：** 对于每个给定的优先约束 $(j, k)$，从节点 $j$ 到节点 $k$ 添加一条边。这表示 $s_k \\ge s_j + p_j$，其中 $p_j$ 是作业 $j$ 的处理时间。\n- **机器排序约束：** 如果作业 $j_1, j_2, \\dots, j_r$ 按该特定顺序分配给同一台机器，则将边 $(j_1, j_2), (j_2, j_3), \\dots, (j_{r-1}, j_r)$ 添加到图中。边 $(j_i, j_{i+1})$ 表示 $s_{j_{i+1}} \\ge s_{j_i} + p_{j_i}$。\n\n一个调度方案是可行的，当且仅当其对应的约束图 $\\mathcal{G}$ 是一个有向无环图（DAG）。图中的环路，例如 $j \\rightarrow k \\rightarrow j$，将意味着一个不可能的条件，如 $s_k \\ge s_j + p_j$ 和 $s_j \\ge s_k + p_k$。由于所有 $p_j  0$，这是一个矛盾。我们使用深度优先搜索（DFS）算法来检测环路。如果检测到环路，则该调度方案无效并被丢弃。\n\n**3. 可行调度方案的开始时间计算**\n对于一个可行的（无环的）调度方案，我们必须确定满足所有约束的所有作业的最早可能开始时间 $s_j$。作业 $j$ 的最早开始时间（记为 $s_j$）是在约束图中从一个概念上的“零时刻”源点到节点 $j$ 的最长路径的长度。在此路径计算中，边 $(u,v)$ 的权重是源作业 $u$ 的处理时间 $p_u$。\n\nDAG 中的最长路径可以使用基于拓扑排序的算法高效计算：\n1.  将所有作业 $j$ 的开始时间 $s_j$ 初始化为 0。\n2.  计算约束图 $\\mathcal{G}$ 中每个节点的入度。\n3.  创建一个队列，并将所有入度为 0 的节点加入队列。这些作业没有前驱作业，可以在时间 $s_j=0$ 开始。\n4.  当队列不为空时，从队列中取出一个节点 $u$。对于它的每个邻居节点 $v$（即对于每条边 $(u,v) \\in \\mathcal{E}$）：\n    -   通过更新 $v$ 的开始时间来松弛边：$s_v = \\max(s_v, s_u + p_u)$。\n    -   将 $v$ 的入度减一。\n    -   如果 $v$ 的入度变为 0，则将 $v$ 加入队列。\n这个过程确保了一个作业的开始时间只有在其所有前驱作业的开始时间都确定后才被最终确定。\n\n**4. 目标函数评估**\n一旦计算出可行调度方案的最早开始时间 $\\{s_j\\}$，每个作业的完成时间为 $C_j = s_j + p_j$。然后，该调度方案的总加权完成时间计算为 $Z = \\sum_{j=1}^{n} w_j C_j$。\n\n**5. 优化**\n该算法维护一个变量，用于保存迄今为止找到的最小目标值。每当找到一个具有更低总加权完成时间的调度方案时，就更新该值。在穷举所有有效的分配和排序组合后，该变量将包含问题实例的最优值。由于所有输入的时间量和权重都是整数，最终的目标值也将是整数。", "answer": "```python\nimport itertools\nimport collections\n\ndef solve():\n    \"\"\"\n    Solves a series of P|prec|sum(w_j C_j) scheduling problems by exhaustive search.\n    \"\"\"\n    test_cases = [\n        # Case 1: m=2, n=5, p=[3,2,4,1,2], w=[4,1,3,2,5], A={(1,3),(2,3),(4,5)}\n        {'m': 2, 'n': 5, 'p': [3, 2, 4, 1, 2], 'w': [4, 1, 3, 2, 5], 'A': {(0, 2), (1, 2), (3, 4)}},\n        # Case 2: m=1, n=5, p=[2,2,1,3,2], w=[1,1,1,1,1], A={(1,2),(2,3),(3,4),(4,5)}\n        {'m': 1, 'n': 5, 'p': [2, 2, 1, 3, 2], 'w': [1, 1, 1, 1, 1], 'A': {(0, 1), (1, 2), (2, 3), (3, 4)}},\n        # Case 3: m=3, n=4, p=[1,3,2,4], w=[10,1,1,1], A={}\n        {'m': 3, 'n': 4, 'p': [1, 3, 2, 4], 'w': [10, 1, 1, 1], 'A': set()},\n        # Case 4: m=2, n=6, p=[3,3,2,2,4,1], w=[2,2,3,3,1,5], A={(1,5),(2,5),(3,4)}\n        {'m': 2, 'n': 6, 'p': [3, 3, 2, 2, 4, 1], 'w': [2, 2, 3, 3, 1, 5], 'A': {(0, 4), (1, 4), (2, 3)}},\n        # Case 5: m=5, n=3, p=[5,1,2], w=[1,7,3], A={(3,1)}\n        {'m': 5, 'n': 3, 'p': [5, 1, 2], 'w': [1, 7, 3], 'A': {(2, 0)}}\n    ]\n\n    results = []\n\n    for case in test_cases:\n        m, n, p, w, A = case['m'], case['n'], case['p'], case['w'], case['A']\n        min_total_w_c = float('inf')\n\n        # 1. Enumerate all machine assignments for n jobs\n        assignments = itertools.product(range(m), repeat=n)\n\n        for assignment in assignments:\n            # Group jobs by their assigned machine\n            jobs_on_machine = [[] for _ in range(m)]\n            for job_idx, machine_idx in enumerate(assignment):\n                jobs_on_machine[machine_idx].append(job_idx)\n\n            # 2. Enumerate all job orderings for each machine\n            orderings_per_machine = [itertools.permutations(jobs) for jobs in jobs_on_machine]\n\n            for ordering_combo in itertools.product(*orderings_per_machine):\n                # 3. Build the constraint graph and check for cycles\n                adj = collections.defaultdict(list)\n                for u, v in A:\n                    adj[u].append(v)\n                \n                for machine_order in ordering_combo:\n                    for i in range(len(machine_order) - 1):\n                        u, v = machine_order[i], machine_order[i+1]\n                        adj[u].append(v)\n\n                # Cycle detection using DFS with a 3-state visited array\n                # 0: unvisited, 1: visiting, 2: visited\n                visited = [0] * n\n                is_cyclic = False\n\n                def has_cycle_util(u):\n                    visited[u] = 1 # Mark as visiting\n                    for v_neighbor in adj[u]:\n                        if visited[v_neighbor] == 1:\n                            return True\n                        if visited[v_neighbor] == 0:\n                            if has_cycle_util(v_neighbor):\n                                return True\n                    visited[u] = 2 # Mark as visited\n                    return False\n\n                for i in range(n):\n                    if visited[i] == 0:\n                        if has_cycle_util(i):\n                            is_cyclic = True\n                            break\n                \n                if is_cyclic:\n                    continue # Invalid schedule, skip\n\n                # 4. If acyclic, compute longest path for earliest start times\n                in_degree = [0] * n\n                adj_weighted = collections.defaultdict(list)\n                \n                for u, v_set in adj.items():\n                    for v in v_set:\n                      adj_weighted[u].append(v)\n                      in_degree[v] += 1\n                \n                queue = collections.deque([i for i in range(n) if in_degree[i] == 0])\n                start_times = [0] * n\n\n                while queue:\n                    u = queue.popleft()\n                    for v in adj_weighted[u]:\n                        new_start_time = start_times[u] + p[u]\n                        if new_start_time > start_times[v]:\n                            start_times[v] = new_start_time\n                        in_degree[v] -= 1\n                        if in_degree[v] == 0:\n                            queue.append(v)\n                \n                # 5. Evaluate objective function\n                current_total_w_c = 0\n                for i in range(n):\n                    completion_time = start_times[i] + p[i]\n                    current_total_w_c += w[i] * completion_time\n\n                # 6. Update minimum\n                min_total_w_c = min(min_total_w_c, current_total_w_c)\n        \n        results.append(int(min_total_w_c))\n    \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3106622"}]}