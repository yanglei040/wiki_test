{"hands_on_practices": [{"introduction": "动态规划的核心在于将问题分解为更小的、可管理的状态，并找到这些状态之间的转换关系。这个练习是一个经典的例子，它模拟了股票交易的决策过程。我们将学习如何定义“持有股票”和“持有现金”这两种状态，并通过构建状态转移方程，在每日价格波动中找到最大化利润的最优策略。这个问题是理解状态定义和递推关系在动态规划中作用的绝佳起点。[@problem_id:3230619]", "problem": "给定一支股票的有限每日价格序列，以及一个非负的固定交易费，该费用在每次完成“先买后卖”的交易并卖出时收取一次。你可以完成任意数量的交易，但受限于在任何时候持有的股票不能超过一股；也就是说，你必须先卖出才能再次买入。不允许卖空。你的任务是设计并实现一个程序，为每个给定的测试用例计算在这些规则下的最大可能总利润。\n\n仅使用以下基本原理来推理和推导你的算法：动态规划（DP）中的最优化原理和子问题分解，以及利润的标准定义，即已完成交易的实现收益的累积和。程序必须计算精确的最优值，而不是近似值，并且必须足够高效，能够以线性时间和常数额外空间处理长序列。\n\n假设与说明：\n- 手续费在每次交易卖出时收取一次，买入时不收取。\n- 价格为非负整数。\n- 如果不存在可盈利的交易，则最大利润为零。\n- 在任何一天开始前的初始状态是：不持有股票，累积利润为零。\n\n在你的程序中实现和评估的测试套件（按所列顺序处理）：\n- 情况 $1$：价格 $[1,3,2,8,4,9]$，手续费 $2$。\n- 情况 $2$：价格 $[9,8,7,6,5]$，手续费 $1$。\n- 情况 $3$：价格 $[1,5,3,8,4,9]$，手续费 $10$。\n- 情况 $4$：价格 $[1,2,3,4,5]$，手续费 $0$。\n- 情况 $5$：价格 $[5]$，手续费 $3$。\n- 情况 $6$：价格 $[1,1,1,2,2,3,1,2]$，手续费 $1$。\n- 情况 $7$：价格 $[]$（空序列），手续费 $5$。\n- 情况 $8$：价格 $[3,2,6,5,0,3]$，手续费 $1$。\n\n输出要求：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，`[result1,result2,result3,...]`），其中每个结果是对应测试用例的最大利润，表示为一个非负整数。", "solution": "带固定手续费的股票交易利润最大化问题是一个经典的优化问题，可以使用动态规划（DP）的原理高效解决。该问题具有最优子结构，意味着一个价格序列的最优解可以由其前缀的最优解构造而成。这使我们能够将问题分解为一系列更小的、重叠的子问题。\n\n我们的推导过程将首先定义系统的状态，然后构建控制状态转移的递推关系，建立初始条件，最后展示这些元素如何结合起来，以线性时间和常数空间复杂度得出解。\n\n设每日价格序列为 $P = [p_0, p_1, \\dots, p_{n-1}]$，交易费为 $f$。在任何给定的一天 $i$ 结束时，我们的财务状况完全由我们的累积利润和是否持有股票决定。这引出了为每一天 $i$ 定义两个状态变量：\n\n1.  $cash_i$：在第 $i$ 天结束时，如果我们**不**持有股票（即我们持有现金），可以实现的最大利润。\n2.  $hold_i$：在第 $i$ 天结束时，如果我们**正**持有一股股票，可以实现的最大利润。请注意，这个值可以是负数，因为它代表了我们包含所持股票成本在内的净资产。\n\n现在我们可以建立状态转移方程，或称递推关系，根据第 $i-1$ 天的状态来定义 $cash_i$ 和 $hold_i$。\n\n为了计算 $cash_i$，我们考虑在第 $i$ 天结束时的两种可能性：\n- 我们在第 $i-1$ 天结束时已处于现金状态，并选择不进行任何操作。在这种情况下，我们的利润保持为 $cash_{i-1}$。\n- 我们在第 $i-1$ 天结束时持有一支股票，并在第 $i$ 天卖出。卖出股票获得价格 $p_i$，但需支付手续费 $f$。我们的新利润是前一个状态的值 $hold_{i-1}$ 与卖出净收益 $p_i - f$ 的和。\n第 $i$ 天的最优现金状态是这两种结果中的最大值：\n$$ cash_i = \\max(cash_{i-1}, hold_{i-1} + p_i - f) $$\n\n为了计算 $hold_i$，我们同样考虑在第 $i$ 天结束时的两种可能性：\n- 我们在第 $i-1$ 天结束时已持有一支股票，并选择继续持有。我们的状态值保持为 $hold_{i-1}$。\n- 我们在第 $i-1$ 天结束时处于现金状态，并选择在第 $i$ 天买入一股股票。这个操作花费 $p_i$，这笔钱从我们的可用现金 $cash_{i-1}$ 中扣除。\n第 $i$ 天的最优持有状态是这两种情况中的最大值。这反映了是继续持有之前购入的股票，还是以当前价格买入一支股票的策略，取两者中能带来更好（负得更少或正得更多）头寸的那个：\n$$ hold_i = \\max(hold_{i-1}, cash_{i-1} - p_i) $$\n\n这些递推关系的基础情况对应于第一天之前的状态（即在 $i=-1$ 时）。\n- 最初，我们利润为零且不持有股票。因此，$cash_{-1} = 0$。\n- 在过程开始时不可能已经持有股票。为了在递推中正确地对此建模，我们将持有状态初始化为一个值，以确保它在第一步中不会成为最大值，除非买入了股票。负无穷大的值，$hold_{-1} = -\\infty$，可以达到此目的。\n\n算法通过从第 $i=0$ 天迭代到第 $i=n-1$ 天，在每一步应用状态转移方程。最终答案是最后一天之后的最大利润。由于只有在不持有任何股票时才能实现利润，所以解是最后一天的现金状态值 $cash_{n-1}$。递推关系确保了这个值是非负的，因为 $cash_i$ 从 $0$ 开始，并且只有在发生有利可图的交易时才会增加。\n\n这些递推关系表明可以使用两个大小为 $n$ 的数组来存储所有 $i$ 的 $cash_i$ 和 $hold_i$ 值。然而，请注意，第 $i$ 天的计算仅依赖于第 $i-1$ 天的值。这使得进行显著的空间优化成为可能。我们无需存储整个历史记录，只需维护两个变量来表示现金和持有状态的最新值。\n\n设这些变量为 $current\\_cash$ 和 $current\\_hold$。迭代算法如下：\n1.  初始化 $current\\_cash = 0$ 和 $current\\_hold = -\\infty$。\n2.  对于价格序列 $P$ 中的每个价格 $p$：\n    a. 将上一步的 $current\\_cash$ 值存储在一个临时变量中，例如 $previous\\_cash = current\\_cash$。\n    b. 更新 $current\\_cash = \\max(current\\_cash, current\\_hold + p - f)$。\n    c. 更新 $current\\_hold = \\max(current\\_hold, previous\\_cash - p)$。\n3.  循环结束后，最终结果是 $current\\_cash$。\n\n这种优化方法的时间复杂度为 $O(n)$，因为它只对价格序列进行单次遍历；空间复杂度为 $O(1)$，因为它只使用几个变量来存储当前状态。这满足了问题的效率要求。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_max_profit(prices, fee):\n    \"\"\"\n    Computes the maximum profit from stock transactions with a fee.\n\n    This function uses a dynamic programming approach with O(1) space complexity.\n    It maintains two state variables:\n    - cash: the maximum profit at the end of a day if not holding a stock.\n    - hold: the maximum profit at the end of a day if holding a stock.\n\n    Args:\n        prices (list[int]): A list of daily stock prices.\n        fee (int): The transaction fee applied on each sale.\n\n    Returns:\n        int: The maximum possible profit.\n    \"\"\"\n    # cash: max profit if we end the day with no stock\n    cash = 0\n    # hold: max profit if we end the day with one stock\n    # Initialized to a very small number, as it's impossible to hold a stock\n    # before the first day. This represents a state of negative infinity.\n    hold = -np.inf\n\n    # Iterate through each day's price\n    for price in prices:\n        # Cache the cash value from the previous step before it's updated.\n        # This is crucial because the new 'hold' state depends on the 'cash'\n        # state before any transaction on the current day.\n        prev_cash = cash\n\n        # Update the 'cash' state.\n        # We can either do nothing (maintaining 'cash') or sell the stock we're\n        # holding ('hold + price - fee'). We take the maximum.\n        cash = max(cash, hold + price - fee)\n\n        # Update the 'hold' state.\n        # We can either do nothing (maintaining 'hold') or buy a stock today,\n        # which transitions from the previous cash state ('prev_cash - price').\n        # We take the maximum.\n        hold = max(hold, prev_cash - price)\n\n    # The final profit must be an integer and is the profit in the 'cash' state\n    # after the last day, as we must sell all stock to realize profit.\n    return int(cash)\n\ndef solve():\n    \"\"\"\n    Defines and runs the test suite for the stock profit problem.\n    \"\"\"\n    # The test suite provided in the problem statement.\n    test_cases = [\n        # (prices, fee)\n        ([1, 3, 2, 8, 4, 9], 2),       # Case 1\n        ([9, 8, 7, 6, 5], 1),         # Case 2\n        ([1, 5, 3, 8, 4, 9], 10),      # Case 3\n        ([1, 2, 3, 4, 5], 0),         # Case 4\n        ([5], 3),                     # Case 5\n        ([1, 1, 1, 2, 2, 3, 1, 2], 1), # Case 6\n        ([], 5),                      # Case 7\n        ([3, 2, 6, 5, 0, 3], 1),      # Case 8\n    ]\n\n    results = []\n    for prices, fee in test_cases:\n        result = compute_max_profit(prices, fee)\n        results.append(result)\n\n    # Print the final results in the specified format.\n    print(f\"[{','.join(map(str, results))}]\")\n\n# Execute the solver.\nsolve()\n```", "id": "3230619"}, {"introduction": "动态规划的强大之处在于其远见——它通过评估未来的最优结果来做出当前的最佳决策，从而避免短视的“贪心”选择。这个资源分配问题通过一个具体的反例，生动地展示了为什么局部最优选择不一定能导向全局最优解。通过解决这个问题，你将亲身体验贝尔曼最优性原理的威力，学会如何从最终目标出发，反向推导每一步的最优决策路径。[@problem_id:3124007]", "problem": "考虑一个有限期资源分配问题，该问题包含 $T=2$ 个离散时期和两个项目 $A$ 和 $B$。在每个时期 $t \\in \\{1,2\\}$，必须将 $1$ 个不可分割的资源单位精确地分配给一个项目。令 $x_A$ 和 $x_B$ 表示到第 2 时期结束时，分配给项目 $A$ 和 $B$ 的累计资源单位数，因此 $x_A + x_B = 2$ 且 $x_A, x_B \\in \\{0,1,2\\}$。到第 2 时期结束时的总回报是项目特定回报之和 $f_A(x_A) + f_B(x_B)$，其中项目回报函数 $f_A$ 和 $f_B$ 在集合 $\\{0,1,2\\}$ 上的定义如下：\n- $f_A(0)=0$, $f_A(1)=8$, $f_A(2)=9$,\n- $f_B(0)=0$, $f_B(1)=7$, $f_B(2)=20$.\n\n一种忽略未来时期的自然贪心策略如下：在每个时期 $t$，将当前资源单位分配给当前边际回报增量 $\\Delta f_i(x_i) = f_i(x_i+1)-f_i(x_i)$ 最大的项目，平局则任意选择。\n\n任务：\n1. 使用动态规划中的最优性原理，定义一个关于时间 $t$ 和一个捕获累计分配的适当状态的值函数，并写出相应的贝尔曼递归式，该递归式在终止时间计算总回报为 $f_A(x_A)+f_B(x_B)$。\n2. 使用此递归式计算最优分配及其总回报。\n3. 计算上述贪心策略获得的总回报，并证明其严格小于最优值，从而提供一个具体反例，说明按最大边际增量选择的贪心策略失败，而基于时间 $t$ 的动态规划（DP）能得出最优分配。\n\n最终答案仅需提供最优总回报，以单个实数表示。无需四舍五入，不涉及单位。", "solution": "所述问题是一个有限期资源分配问题。它自成体系，数学上一致，并且属于优化方法的标准框架。因此，该问题是有效的。我们按顺序解决这三个任务。\n\n### 任务 1：动态规划建模\n\n设时间周期由 $t \\in \\{1, 2\\}$ 索引。在每个时期，一个不可分割的资源单位被分配给两个项目 $A$ 或 $B$ 中的一个。待分配的单位总数为 $T=2$。\n\n我们将时期 $t$ 开始时的系统状态定义为 $s_t = (n_A, n_B)$，其中 $n_A$ 和 $n_B$ 分别是在时期 $1, \\dots, t-1$ 期间分配给项目 $A$ 和 $B$ 的累计单位数。这意味着状态约束为 $n_A + n_B = t-1$。\n\n时期 $t$ 的决策（或行动）是 $u_t \\in \\{A, B\\}$，表示选择将单位分配给项目 $A$ 或项目 $B$。\n\n状态转移是确定性的。如果时期 $t$ 的状态是 $(n_A, n_B)$，则时期 $t+1$ 的状态变为：\n- 若行动为 $u_t=A$，则为 $(n_A+1, n_B)$。\n- 若行动为 $u_t=B$，则为 $(n_A, n_B+1)$。\n\n目标是最大化在期末的总回报，其由 $f_A(x_A) + f_B(x_B)$ 给出，其中 $(x_A, x_B)$ 是在 $T=2$ 个时期后的最终分配，且 $x_A+x_B=2$。\n\n设 $J_t(n_A, n_B)$ 是系统在时期 $t$ 开始时处于状态 $(n_A, n_B)$ 的条件下，从该时刻到期末所能获得的最优（最大）总回报。这是一个定义在状态和时间上的值函数。根据最优性原理，通过时间逆向推导，可得以下贝尔曼递归式：\n$$\nJ_t(n_A, n_B) = \\max \\begin{cases} J_{t+1}(n_A+1, n_B)   \\text{若 } u_t=A \\\\ J_{t+1}(n_A, n_B+1)   \\text{若 } u_t=B \\end{cases}\n$$\n递归在一个概念上的时期 $t=3$ 终止，此时所有 2 个分配都已完成。在这个终止阶段的值就是总回报本身，基于最终分配 $(x_A, x_B)$：\n$$\nJ_3(x_A, x_B) = f_A(x_A) + f_B(x_B) \\quad \\text{其中 } x_A+x_B=2.\n$$\n\n### 任务 2：最优分配与回报的计算\n\n我们应用任务 1 中建立的逆向递归。\n\n**终止阶段 ($t=3$):**\n我们计算所有可能的最终分配 $(x_A, x_B)$ 的值，其中 $x_A, x_B \\in \\{0,1,2\\}$ 且 $x_A+x_B=2$。\n- 对于分配 $(2,0)$：$J_3(2,0) = f_A(2) + f_B(0) = 9 + 0 = 9$。\n- 对于分配 $(1,1)$：$J_3(1,1) = f_A(1) + f_B(1) = 8 + 7 = 15$。\n- 对于分配 $(0,2)$：$J_3(0,2) = f_A(0) + f_B(2) = 0 + 20 = 20$。\n\n**时期 $t=2$:**\n在时期 2 开始时，已分配了一个单位 ($t-1=1$)。可能的状态是 $(1,0)$ 和 $(0,1)$。\n- 对于状态 $s_2 = (1,0)$：我们决定第二个单位的分配。\n  - 行动 $A$：导致最终状态 $(2,0)$。值为 $J_3(2,0)=9$。\n  - 行动 $B$：导致最终状态 $(1,1)$。值为 $J_3(1,1)=15$。\n  因此，$J_2(1,0) = \\max\\{9, 15\\} = 15$。最优行动是 $B$。\n- 对于状态 $s_2 = (0,1)$：我们决定第二个单位的分配。\n  - 行动 $A$：导致最终状态 $(1,1)$。值为 $J_3(1,1)=15$。\n  - 行动 $B$：导致最终状态 $(0,2)$。值为 $J_3(0,2)=20$。\n  因此，$J_2(0,1) = \\max\\{15, 20\\} = 20$。最优行动是 $B$。\n\n**时期 $t=1$:**\n在时期 1 开始时，没有单位被分配，所以状态是 $s_1 = (0,0)$。我们决定第一个单位的分配。\n- 行动 $A$：导致在 $t=2$ 时的状态为 $(1,0)$。此路径的最优值为 $J_2(1,0)=15$。\n- 行动 $B$：导致在 $t=2$ 时的状态为 $(0,1)$。此路径的最优值为 $J_2(0,1)=20$。\n因此，可实现的最大回报为 $J_1(0,0) = \\max\\{15, 20\\} = 20$。第一个最优行动是 $B$。\n\n通过正向追踪最优决策：\n1. 在 $t=1$ 时，从状态 $(0,0)$ 开始，最优行动是 $B$。系统转移到状态 $(0,1)$。\n2. 在 $t=2$ 时，处于状态 $(0,1)$，最优行动是 $B$。系统转移到最终分配 $(0,2)$。\n\n最优分配是 $(x_A, x_B) = (0,2)$，其产生的最优总回报为 $f_A(0) + f_B(2) = 0 + 20 = 20$。\n\n### 任务 3：贪心策略分析\n\n贪心策略在每个时期将单位分配给当前边际回报最大的项目，边际回报定义为 $\\Delta f_i(x_i) = f_i(x_i+1) - f_i(x_i)$，其中 $x_i$ 是当前已分配给项目 $i$ 的单位数。\n\n首先，我们计算边际回报：\n- 对于项目 $A$：\n  - $\\Delta f_A(0) = f_A(1) - f_A(0) = 8 - 0 = 8$.\n  - $\\Delta f_A(1) = f_A(2) - f_A(1) = 9 - 8 = 1$.\n- 对于项目 $B$：\n  - $\\Delta f_B(0) = f_B(1) - f_B(0) = 7 - 0 = 7$.\n  - $\\Delta f_B(1) = f_B(2) - f_B(1) = 20 - 7 = 13$.\n\n现在，我们模拟贪心策略：\n- **时期 $t=1$**：当前分配为 $(0,0)$。我们比较增加第一个单位的边际回报：$\\Delta f_A(0)=8$ 和 $\\Delta f_B(0)=7$。由于 $8 > 7$，贪心策略将单位分配给项目 $A$。分配变为 $(1,0)$。\n- **时期 $t=2$**：当前分配为 $(1,0)$。我们比较增加第二个单位的边际回报：项目 $A$ 的 $\\Delta f_A(1)=1$ 和项目 $B$ 的 $\\Delta f_B(0)=7$。由于 $7 > 1$，贪心策略将单位分配给项目 $B$。最终分配变为 $(1,1)$。\n\n贪心策略的最终分配是 $(x_A, x_B) = (1,1)$。此分配的总回报是：\n$$ f_A(1) + f_B(1) = 8 + 7 = 15. $$\n贪心策略获得的总回报为 $15$，严格小于使用动态规划找到的最优回报 $20$。这证实了短视的贪心方法对于此问题是次优的。在 $t=1$ 时的贪心选择使系统无法达到回报最高的状态 $(0,2)$，因为它没有考虑到对项目 $B$ 进行第二次分配所能带来的巨大未来边际收益。", "answer": "$$\n\\boxed{20}\n$$", "id": "3124007"}, {"introduction": "当我们遇到的问题状态不能简单地用时间或序列索引来表示时，动态规划的灵活性就体现出来了。这个作业排序问题是著名的旅行商问题（Traveling Salesperson Problem, TSP）的一个变体，它的状态需要包含一个已完成任务的“子集”。通过这个练习，你将学会如何处理更复杂的组合优化问题，通过定义一个能够封装未来决策所需全部信息的“状态”，来系统地探索一个看似庞大的解空间。[@problem_id:3123982]", "problem": "一个制造单元必须处理一组索引为 $[n] = \\{1,2,3,4,5\\}$ 的作业。从作业 $i$ 切换到作业 $j$ 会产生一个与设置相关的成本 $s_{ij}$，从初始机器状态 $0$ 切换到作业 $j$ 会产生成本 $s_{0j}$。每个作业必须在从初始状态 $0$ 开始的某个序列中被精确处理一次。总序列成本定义为沿序列的设置成本之和，即，如果序列是 $0 \\to j_{1} \\to j_{2} \\to \\dots \\to j_{n}$，则总成本为 $s_{0,j_{1}} + \\sum_{k=1}^{n-1} s_{j_{k}, j_{k+1}}$。目标是最小化这个总设置成本。\n\n实例由以下数据给出。初始设置成本为\n$$\n\\bigl(s_{0,1}, s_{0,2}, s_{0,3}, s_{0,4}, s_{0,5}\\bigr) = (8, 3, 9, 4, 7)\n$$\n对于 $i,j \\in \\{1,2,3,4,5\\}$，作业间的设置成本 $s_{ij}$ 由以下矩阵指定\n$$\n\\begin{bmatrix}\ns_{1,1}   s_{1,2}   s_{1,3}   s_{1,4}   s_{1,5} \\\\\ns_{2,1}   s_{2,2}   s_{2,3}   s_{2,4}   s_{2,5} \\\\\ns_{3,1}   s_{3,2}   s_{3,3}   s_{3,4}   s_{3,5} \\\\\ns_{4,1}   s_{4,2}   s_{4,3}   s_{4,4}   s_{4,5} \\\\\ns_{5,1}   s_{5,2}   s_{5,3}   s_{5,4}   s_{5,5}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n0   6   7   5   3 \\\\\n4   0   5   2   6 \\\\\n7   4   0   7   5 \\\\\n1   6   6   0   4 \\\\\n5   5   2   6   0\n\\end{bmatrix}.\n$$\n\n从基本的 Bellman 最优性原理出发，推导一个使用形式为 $(S,j)$ 的状态的动态规划公式，其中 $S \\subseteq [n]$ 是已完成作业的集合，$j \\in S$ 是最后一个完成的作业，以计算最小总设置成本。然后，将您的公式应用于给定实例，计算所有从初始状态 $0$ 开始并精确访问每个作业一次的序列所能达到的最小总设置成本。\n\n将最终答案表示为一个精确的整数，不进行四舍五入，也不带单位。", "solution": "根据指定的验证标准对问题进行评估。\n\n### 问题验证\n**步骤 1：提取已知条件**\n- 作业集：$[n] = \\{1, 2, 3, 4, 5\\}$。\n- 初始机器状态：$0$。\n- 从作业 $i$ 到作业 $j$ 的设置成本：$s_{ij}$。\n- 从状态 $0$ 到作业 $j$ 的初始设置成本：$s_{0j}$。\n- 初始设置成本数据：$(s_{0,1}, s_{0,2}, s_{0,3}, s_{0,4}, s_{0,5}) = (8, 3, 9, 4, 7)$。\n- 对于 $i,j \\in \\{1,2,3,4,5\\}$，作业间的设置成本 $s_{ij}$ 数据：\n$$\n\\begin{bmatrix}\n0   6   7   5   3 \\\\\n4   0   5   2   6 \\\\\n7   4   0   7   5 \\\\\n1   6   6   0   4 \\\\\n5   5   2   6   0\n\\end{bmatrix}\n$$\n- 约束：每个作业必须被精确处理一次。\n- 操作序列：$0 \\to j_{1} \\to j_{2} \\to \\dots \\to j_{n}$。\n- 目标函数：最小化总成本，定义为 $s_{0,j_{1}} + \\sum_{k=1}^{n-1} s_{j_{k}, j_{k+1}}$。\n- 任务：推导一个状态为 $(S, j)$ 的动态规划公式，并应用它来找到最小总设置成本。\n\n**步骤 2：使用提取的已知条件进行验证**\n- **科学依据**：该问题是非对称旅行商路径问题（ATSPP）的经典实例，这是组合优化和运筹学中一个成熟的问题。所要求的解决方法，即动态规划，是解决此类问题（特别是 Held-Karp 算法）的标准且强大的技术。该问题在数学上和科学上都是合理的。\n- **适定性**：该问题是适定的。它旨在在一个有限、非空的排列集合上找到一个成本函数的最小值。最小值保证存在。动态规划方法确保能找到唯一的最小成本。\n- **客观性**：该问题以精确、客观的语言陈述。所有成本都以明确的数值数据给出，目标函数定义明确。\n- **完整性和一致性**：提供了所有必要的数据（成本）和约束。问题陈述中没有矛盾。对角线元素 $s_{ii}=0$ 与问题中每个作业只访问一次的约束是一致的，该约束排除了从一个作业到其自身的转换。\n\n**步骤 3：结论与行动**\n该问题是有效的，因为它具有科学依据、适定、客观和完整。将推导和计算解决方案。\n\n### 动态规划公式\n\n该问题可以建模为在状态空间图中寻找最短路径，因此适合使用动态规划。该公式基于 Bellman 最优性原理，该原理指出最优路径由最优子路径组成。\n\n令 $S \\subseteq [n]$ 为已处理作业的子集，令 $j \\in S$ 为序列中最后一个处理的作业。我们将状态定义为序对 $(S, j)$。\n\n令 $C(S, j)$ 为从初始机器状态 $0$ 开始，精确访问集合 $S$ 中的每个作业一次，并以作业 $j$ 结束的路径的最小成本。\n\n**基本情况：**\n对于只访问了一个作业的路径，已访问作业的集合为 $S = \\{j\\}$。路径就是简单的 $0 \\to j$。成本是初始设置成本 $s_{0j}$。\n因此，对于每个 $j \\in [n]$，基本情况为：\n$$\nC(\\{j\\}, j) = s_{0j}\n$$\n\n**递推关系：**\n对于任何大小 $|S|  1$ 的集合 $S$ 和任何作业 $j \\in S$，覆盖 $S$ 中所有作业并到达 $j$ 的最优路径必定来自某个作业 $i \\in S \\setminus \\{j\\}$。根据 Bellman 原理，到达 $i$ 的子路径必须覆盖了 $S \\setminus \\{j\\}$ 中的所有作业，并且其本身必须是最优的。这样一条子路径的成本是 $C(S \\setminus \\{j\\}, i)$。从 $i$ 到 $j$，我们会产生一个额外的设置成本 $s_{ij}$。为了找到以 $j$ 作为集合 $S$ 中最后一个作业的最小成本，我们必须考虑所有可能的倒数第二个作业 $i$，并选择使总成本最小化的那一个。\n\n这给出了 $|S| \\geq 2$ 时的递推关系：\n$$\nC(S, j) = \\min_{i \\in S \\setminus \\{j\\}} \\{ C(S \\setminus \\{j\\}, i) + s_{ij} \\}\n$$\n\n**最终解：**\n问题要求处理所有 $n$ 个作业。最终访问的作业集合是 $S = [n] = \\{1, 2, 3, 4, 5\\}$。序列可以在任何作业 $j \\in [n]$ 结束。最小总设置成本是所有可能的完整序列成本的最小值。\n$$\n\\text{最小总成本} = \\min_{j \\in [n]} \\{ C([n], j) \\}\n$$\n\n### 应用于给定实例\n我们现在将此公式应用于所提供的数据，其中 $n=5$。\n\n**阶段 1：$|S|=1$**\n成本是初始设置成本 $s_{0j}$。\n$C(\\{1\\}, 1) = s_{0,1} = 8$\n$C(\\{2\\}, 2) = s_{0,2} = 3$\n$C(\\{3\\}, 3) = s_{0,3} = 9$\n$C(\\{4\\}, 4) = s_{0,4} = 4$\n$C(\\{5\\}, 5) = s_{0,5} = 7$\n\n**阶段 2：$|S|=2$**\n我们计算 $C(\\{i,j\\}, j) = C(\\{i\\}, i) + s_{ij}$。\n$C(\\{1,2\\}, 1) = C(\\{2\\},2)+s_{2,1} = 3+4 = 7$\n$C(\\{1,2\\}, 2) = C(\\{1\\},1)+s_{1,2} = 8+6 = 14$\n$C(\\{1,3\\}, 1) = C(\\{3\\},3)+s_{3,1} = 9+7 = 16$\n$C(\\{1,3\\}, 3) = C(\\{1\\},1)+s_{1,3} = 8+7 = 15$\n$C(\\{1,4\\}, 1) = C(\\{4\\},4)+s_{4,1} = 4+1 = 5$\n$C(\\{1,4\\}, 4) = C(\\{1\\},1)+s_{1,4} = 8+5 = 13$\n$C(\\{1,5\\}, 1) = C(\\{5\\},5)+s_{5,1} = 7+5 = 12$\n$C(\\{1,5\\}, 5) = C(\\{1\\},1)+s_{1,5} = 8+3 = 11$\n$C(\\{2,3\\}, 2) = C(\\{3\\},3)+s_{3,2} = 9+4 = 13$\n$C(\\{2,3\\}, 3) = C(\\{2\\},2)+s_{2,3} = 3+5 = 8$\n$C(\\{2,4\\}, 2) = C(\\{4\\},4)+s_{4,2} = 4+6 = 10$\n$C(\\{2,4\\}, 4) = C(\\{2\\},2)+s_{2,4} = 3+2 = 5$\n$C(\\{2,5\\}, 2) = C(\\{5\\},5)+s_{5,2} = 7+5 = 12$\n$C(\\{2,5\\}, 5) = C(\\{2\\},2)+s_{2,5} = 3+6 = 9$\n$C(\\{3,4\\}, 3) = C(\\{4\\},4)+s_{4,3} = 4+6 = 10$\n$C(\\{3,4\\}, 4) = C(\\{3\\},3)+s_{3,4} = 9+7 = 16$\n$C(\\{3,5\\}, 3) = C(\\{5\\},5)+s_{5,3} = 7+2 = 9$\n$C(\\{3,5\\}, 5) = C(\\{3\\},3)+s_{3,5} = 9+5 = 14$\n$C(\\{4,5\\}, 4) = C(\\{5\\},5)+s_{5,4} = 7+6 = 13$\n$C(\\{4,5\\}, 5) = C(\\{4\\},4)+s_{4,5} = 4+4 = 8$\n\n**阶段 3：$|S|=3$**\n使用递推式 $C(S,k) = \\min_{j \\in S \\setminus \\{k\\}} \\{ C(S \\setminus \\{k\\}, j) + s_{jk} \\}$。\n$C(\\{1,2,3\\},1) = \\min\\{C(\\{2,3\\},2)+s_{21}, C(\\{2,3\\},3)+s_{31}\\} = \\min\\{13+4, 8+7\\} = 15$\n$C(\\{1,2,3\\},2) = \\min\\{C(\\{1,3\\},1)+s_{12}, C(\\{1,3\\},3)+s_{32}\\} = \\min\\{16+6, 15+4\\} = 19$\n$C(\\{1,2,3\\},3) = \\min\\{C(\\{1,2\\},1)+s_{13}, C(\\{1,2\\},2)+s_{23}\\} = \\min\\{7+7, 14+5\\} = 14$\n$C(\\{1,2,4\\},1) = \\min\\{C(\\{2,4\\},2)+s_{21}, C(\\{2,4\\},4)+s_{41}\\} = \\min\\{10+4, 5+1\\} = 6$\n$C(\\{1,2,4\\},2) = \\min\\{C(\\{1,4\\},1)+s_{12}, C(\\{1,4\\},4)+s_{42}\\} = \\min\\{5+6, 13+6\\} = 11$\n$C(\\{1,2,4\\},4) = \\min\\{C(\\{1,2\\},1)+s_{14}, C(\\{1,2\\},2)+s_{24}\\} = \\min\\{7+5, 14+2\\} = 12$\n$C(\\{1,3,5\\},3) = \\min\\{C(\\{1,5\\},1)+s_{13}, C(\\{1,5\\},5)+s_{53}\\} = \\min\\{12+7, 11+2\\} = 13$\n$C(\\{2,3,4\\},3) = \\min\\{C(\\{2,4\\},2)+s_{23}, C(\\{2,4\\},4)+s_{43}\\} = \\min\\{10+5, 5+6\\} = 11$\n$C(\\{2,3,5\\},3) = \\min\\{C(\\{2,5\\},2)+s_{23}, C(\\{2,5\\},5)+s_{53}\\} = \\min\\{12+5, 9+2\\} = 11$\n$C(\\{2,4,5\\},5) = \\min\\{C(\\{2,4\\},2)+s_{25}, C(\\{2,4\\},4)+s_{45}\\} = \\min\\{10+6, 5+4\\} = 9$\n$C(\\{3,4,5\\},3) = \\min\\{C(\\{4,5\\},4)+s_{43}, C(\\{4,5\\},5)+s_{53}\\} = \\min\\{13+6, 8+2\\} = 10$\n对于 $|S|=3$ 的其他值也类似计算。\n\n**阶段 4：$|S|=4$**\n计算继续进行。例如，对于 $S=\\{1,2,3,4\\}$：\n$C(\\{1,2,3,4\\},1) = \\min\\{C(\\{2,3,4\\},2)+s_{21}, C(\\{2,3,4\\},3)+s_{31}, C(\\{2,3,4\\},4)+s_{41}\\} = \\min\\{14+4, 11+7, 15+1\\} = 16$\n$C(\\{1,2,3,4\\},2) = \\min\\{C(\\{1,3,4\\},1)+s_{12}, C(\\{1,3,4\\},3)+s_{32}, C(\\{1,3,4\\},4)+s_{42}\\} = \\min\\{17+6, 12+4, 21+6\\} = 16$\n$C(\\{1,2,3,4\\},3) = \\min\\{C(\\{1,2,4\\},1)+s_{13}, C(\\{1,2,4\\},2)+s_{23}, C(\\{1,2,4\\},4)+s_{43}\\} = \\min\\{6+7, 11+5, 12+6\\} = 13$\n$C(\\{1,2,3,4\\},4) = \\min\\{C(\\{1,2,3\\},1)+s_{14}, C(\\{1,2,3\\},2)+s_{24}, C(\\{1,2,3\\},3)+s_{34}\\} = \\min\\{15+5, 19+2, 14+7\\} = 20$\n对于 $|S|=4$ 的其他值也类似计算，得到以下用于最后阶段的值：\n$C(\\{1,2,3,5\\},1)=17, C(\\{1,2,3,5\\},2)=17, C(\\{1,2,3,5\\},3)=12, C(\\{1,2,3,5\\},5)=18$\n$C(\\{1,2,4,5\\},1)=14, C(\\{1,2,4,5\\},2)=13, C(\\{1,2,4,5\\},4)=16, C(\\{1,2,4,5\\},5)=9$\n$C(\\{1,3,4,5\\},1)=17, C(\\{1,3,4,5\\},3)=10, C(\\{1,3,4,5\\},4)=20, C(\\{1,3,4,5\\},5)=17$\n$C(\\{2,3,4,5\\},2)=14, C(\\{2,3,4,5\\},3)=11, C(\\{2,3,4,5\\},4)=15, C(\\{2,3,4,5\\},5)=16$\n\n**阶段 5：$|S|=5$**\n我们计算完整集合 $S=\\{1,2,3,4,5\\}$ 的成本。\n$C(S,1) = \\min\\{C(\\{2,3,4,5\\},2)+s_{21}, C(\\{2,3,4,5\\},3)+s_{31}, C(\\{2,3,4,5\\},4)+s_{41}, C(\\{2,3,4,5\\},5)+s_{51}\\} = \\min\\{14+4, 11+7, 15+1, 16+5\\} = \\min\\{18, 18, 16, 21\\} = 16$。\n\n$C(S,2) = \\min\\{C(\\{1,3,4,5\\},1)+s_{12}, C(\\{1,3,4,5\\},3)+s_{32}, C(\\{1,3,4,5\\},4)+s_{42}, C(\\{1,3,4,5\\},5)+s_{52}\\} = \\min\\{17+6, 10+4, 20+6, 17+5\\} = \\min\\{23, 14, 26, 22\\} = 14$。\n\n$C(S,3) = \\min\\{C(\\{1,2,4,5\\},1)+s_{13}, C(\\{1,2,4,5\\},2)+s_{23}, C(\\{1,2,4,5\\},4)+s_{43}, C(\\{1,2,4,5\\},5)+s_{53}\\} = \\min\\{14+7, 13+5, 16+6, 9+2\\} = \\min\\{21, 18, 22, 11\\} = 11$。\n\n$C(S,4) = \\min\\{C(\\{1,2,3,5\\},1)+s_{14}, C(\\{1,2,3,5\\},2)+s_{24}, C(\\{1,2,3,5\\},3)+s_{34}, C(\\{1,2,3,5\\},5)+s_{54}\\} = \\min\\{17+5, 17+2, 12+7, 18+6\\} = \\min\\{22, 19, 19, 24\\} = 19$。\n\n$C(S,5) = \\min\\{C(\\{1,2,3,4\\},1)+s_{15}, C(\\{1,2,3,4\\},2)+s_{25}, C(\\{1,2,3,4\\},3)+s_{35}, C(\\{1,2,3,4\\},4)+s_{45}\\} = \\min\\{16+3, 16+6, 13+5, 20+4\\} = \\min\\{19, 22, 18, 24\\} = 18$。\n\n**最终答案计算**\n最小总设置成本是所有可能的结束作业的成本中的最小值：\n$$\n\\text{最小总成本} = \\min \\{ C(S,1), C(S,2), C(S,3), C(S,4), C(S,5) \\}\n$$\n$$\n\\text{最小总成本} = \\min \\{16, 14, 11, 19, 18\\} = 11\n$$\n产生此成本的最优序列可以通过回溯计算找到。最小成本 $11$ 是 $C(\\{1,2,3,4,5\\},3)$。这是从状态 $(\\{1,2,4,5\\}, 5)$ 以成本 $C(\\{1,2,4,5\\},5)+s_{53} = 9+2=11$ 实现的。进一步回溯揭示最优路径是 $0 \\to 2 \\to 4 \\to 1 \\to 5 \\to 3$，总成本为 $s_{0,2} + s_{2,4} + s_{4,1} + s_{1,5} + s_{5,3} = 3 + 2 + 1 + 3 + 2 = 11$。", "answer": "$$\n\\boxed{11}\n$$", "id": "3123982"}]}