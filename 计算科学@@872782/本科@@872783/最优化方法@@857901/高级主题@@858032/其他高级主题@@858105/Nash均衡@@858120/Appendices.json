{"hands_on_practices": [{"introduction": "这个练习旨在巩固你对纳什均衡核心数学定义的理解。通过在一个简单的双人博弈中求解均衡点，并将其与社会最优结果进行比较，你将直接观察到“无政府代价”（Price of Anarchy）——即非合作的自利行为所带来的效率损失。这项基础计算是理解更复杂博弈模型中个体理性与集体理性之间冲突的基石 [@problem_id:3154673]。", "problem": "考虑一个双人线性二次博弈，其中参与人 $i \\in \\{1,2\\}$ 选择一个标量决策变量 $x_i \\in \\mathbb{R}$。成本函数由下式给出：\n$$\nf_i(x_1,x_2) \\;=\\; \\frac{1}{2} \\, q_i \\, x_i^{2} \\;+\\; b_i \\, x_i \\, x_{-i} \\;+\\; c_i \\, x_i,\n$$\n其中 $x_{-i}$ 表示另一位参与人的决策。令 $q_1 = 2$，$q_2 = 4$，$b_1 = 1$，$b_2 = 1$，$c_1 = -5$，且 $c_2 = 1$。假设对于每个参与人都有 $q_i > 0$，因此每个参与人的优化问题对于其自身的决策变量是严格凸的。\n\n从纳什均衡（NE）的定义（即没有参与人可以通过单方面偏离来降低自己的成本）出发，并利用可微凸函数的一阶最优性条件，推导刻画纳什均衡的分块线性系统，并求解均衡点 $(x_1^{\\ast}, x_2^{\\ast})$。然后，构建最小化社会成本\n$$\nF(x_1,x_2) \\;=\\; f_1(x_1,x_2) \\;+\\; f_2(x_1,x_2),\n$$\n的中心化优化问题，推导其一阶最优性条件，并求解中心化最优解 $(x_1^{c}, x_2^{c})$。\n\n将两个解连接成一个行向量 $\\big(x_1^{\\ast}, \\, x_2^{\\ast}, \\, x_1^{c}, \\, x_2^{c}\\big)$ 作为最终结果。无需四舍五入。", "solution": "该问题要求为一个双人线性二次博弈找到两个不同的解：纳什均衡（NE）和中心化（社会最优）解。\n\n首先，我们确定纳什均衡，记为 $(x_1^{\\ast}, x_2^{\\ast})$。纳什均衡是一种状态，在该状态下，假设另一位参与人的决策保持不变，任何参与人都不能通过单方面改变自己的决策来改善其结果（即降低其成本）。对于成本函数 $f_i(x_1, x_2)$ 对其自身决策变量 $x_i$ 是可微且凸的参与人 $i \\in \\{1,2\\}$，此条件在数学上通过一阶最优性条件 $\\frac{\\partial f_i}{\\partial x_i} = 0$ 来表达。\n\n参与人 $i$ 的成本函数如下：\n$$\nf_i(x_1,x_2) = \\frac{1}{2} q_i x_i^{2} + b_i x_i x_{-i} + c_i x_i\n$$\n其中 $x_{-i}$ 是另一位参与人的决策。问题陈述 $q_i > 0$，确保 $f_i$ 关于 $x_i$ 是严格凸的，这保证了一阶条件能够确定参与人 $i$ 优化问题的唯一最小值。\n\n让我们计算每个参与人的偏导数。\n对于参与人 1：\n$$\nf_1(x_1,x_2) = \\frac{1}{2} q_1 x_1^{2} + b_1 x_1 x_2 + c_1 x_1\n$$\n一阶条件是：\n$$\n\\frac{\\partial f_1}{\\partial x_1} = q_1 x_1 + b_1 x_2 + c_1 = 0\n$$\n\n对于参与人 2：\n$$\nf_2(x_1,x_2) = \\frac{1}{2} q_2 x_2^{2} + b_2 x_2 x_1 + c_2 x_2\n$$\n一阶条件是：\n$$\n\\frac{\\partial f_2}{\\partial x_2} = q_2 x_2 + b_2 x_1 + c_2 = 0\n$$\n\n这两个方程构成了纳什均衡 $(x_1^{\\ast}, x_2^{\\ast})$ 的一个线性系统：\n\\begin{align*}\nq_1 x_1^{\\ast} + b_1 x_2^{\\ast} = -c_1 \\\\\nb_2 x_1^{\\ast} + q_2 x_2^{\\ast} = -c_2\n\\end{align*}\n其矩阵形式为：\n$$\n\\begin{pmatrix} q_1 & b_1 \\\\ b_2 & q_2 \\end{pmatrix} \\begin{pmatrix} x_1^{\\ast} \\\\ x_2^{\\ast} \\end{pmatrix} = \\begin{pmatrix} -c_1 \\\\ -c_2 \\end{pmatrix}\n$$\n给定参数值为：$q_1 = 2$，$q_2 = 4$，$b_1 = 1$，$b_2 = 1$，$c_1 = -5$，且 $c_2 = 1$。将这些值代入系统，得到：\n\\begin{align*}\n2 x_1^{\\ast} + 1 x_2^{\\ast} = -(-5) = 5 \\\\\n1 x_1^{\\ast} + 4 x_2^{\\ast} = -1\n\\end{align*}\n从第一个方程，我们可以用 $x_1^{\\ast}$ 表示 $x_2^{\\ast}$：\n$$\nx_2^{\\ast} = 5 - 2 x_1^{\\ast}\n$$\n将此代入第二个方程：\n$$\nx_1^{\\ast} + 4(5 - 2 x_1^{\\ast}) = -1\n$$\n$$\nx_1^{\\ast} + 20 - 8 x_1^{\\ast} = -1\n$$\n$$\n-7 x_1^{\\ast} = -21\n$$\n$$\nx_1^{\\ast} = 3\n$$\n现在，我们将 $x_1^{\\ast}$ 的值代回，求出 $x_2^{\\ast}$：\n$$\nx_2^{\\ast} = 5 - 2(3) = 5 - 6 = -1\n$$\n因此，纳什均衡为 $(x_1^{\\ast}, x_2^{\\ast}) = (3, -1)$。\n\n接下来，我们确定中心化最优解，记为 $(x_1^{c}, x_2^{c})$。这是一组能最小化总成本或社会成本 $F(x_1,x_2) = f_1(x_1,x_2) + f_2(x_1,x_2)$ 的决策。\n让我们写出社会成本函数 $F(x_1,x_2)$：\n$$\nF(x_1,x_2) = \\left(\\frac{1}{2} q_1 x_1^{2} + b_1 x_1 x_2 + c_1 x_1\\right) + \\left(\\frac{1}{2} q_2 x_2^{2} + b_2 x_1 x_2 + c_2 x_2\\right)\n$$\n$$\nF(x_1,x_2) = \\frac{1}{2} q_1 x_1^{2} + \\frac{1}{2} q_2 x_2^{2} + (b_1 + b_2) x_1 x_2 + c_1 x_1 + c_2 x_2\n$$\n这是一个关于变量 $(x_1, x_2)$ 的联合优化问题。为了找到最小值，我们计算 $F$ 的梯度并令其为零。一阶条件是 $\\frac{\\partial F}{\\partial x_1} = 0$ 和 $\\frac{\\partial F}{\\partial x_2} = 0$。\n$$\n\\frac{\\partial F}{\\partial x_1} = q_1 x_1 + (b_1 + b_2) x_2 + c_1 = 0\n$$\n$$\n\\frac{\\partial F}{\\partial x_2} = q_2 x_2 + (b_1 + b_2) x_1 + c_2 = 0\n$$\n这为我们提供了求解中心化最优解 $(x_1^{c}, x_2^{c})$ 的一个线性方程组：\n\\begin{align*}\nq_1 x_1^{c} + (b_1 + b_2) x_2^{c} = -c_1 \\\\\n(b_1 + b_2) x_1^{c} + q_2 x_2^{c} = -c_2\n\\end{align*}\n为确保这是一个最小值，我们可以检查 $F$ 的海森矩阵，即 $H_F = \\begin{pmatrix} q_1 & b_1+b_2 \\\\ b_1+b_2 & q_2 \\end{pmatrix}$。使用给定值，$H_F = \\begin{pmatrix} 2 & 2 \\\\ 2 & 4 \\end{pmatrix}$。主子式为 $2 > 0$ 和 $\\det(H_F) = 2(4) - 2(2) = 4 > 0$。由于海森矩阵是正定的，所以 $F$ 是严格凸的，一阶条件的解是唯一的全局最小值。\n\n将参数值代入中心化解的系统中：\n\\begin{align*}\n2 x_1^{c} + (1+1) x_2^{c} = -(-5) \\implies 2 x_1^{c} + 2 x_2^{c} = 5 \\\\\n(1+1) x_1^{c} + 4 x_2^{c} = -1 \\implies 2 x_1^{c} + 4 x_2^{c} = -1\n\\end{align*}\n我们现在解这个方程组。用第二个方程减去第一个方程，得到：\n$$\n(2 x_1^{c} + 4 x_2^{c}) - (2 x_1^{c} + 2 x_2^{c}) = -1 - 5\n$$\n$$\n2 x_2^{c} = -6\n$$\n$$\nx_2^{c} = -3\n$$\n将 $x_2^{c} = -3$ 代入第一个方程：\n$$\n2 x_1^{c} + 2(-3) = 5\n$$\n$$\n2 x_1^{c} - 6 = 5\n$$\n$$\n2 x_1^{c} = 11\n$$\n$$\nx_1^{c} = \\frac{11}{2}\n$$\n因此，中心化最优解为 $(x_1^{c}, x_2^{c}) = (\\frac{11}{2}, -3)$。\n\n问题要求将最终结果表示为连接的行向量 $\\big(x_1^{\\ast}, x_2^{\\ast}, x_1^{c}, x_2^{c}\\big)$。\n计算出的值为 $x_1^{\\ast} = 3$，$x_2^{\\ast} = -1$，$x_1^{c} = \\frac{11}{2}$，以及 $x_2^{c} = -3$。\n最终向量为 $\\big(3, -1, \\frac{11}{2}, -3\\big)$。", "answer": "$$\n\\boxed{\\begin{pmatrix} 3 & -1 & \\frac{11}{2} & -3 \\end{pmatrix}}\n$$", "id": "3154673"}, {"introduction": "在掌握了基础计算之后，我们将把这些概念应用到一个经典的经济学场景：双寡头垄断市场。本练习将对比一个同时行动的博弈（古诺模型）与一个序贯行动的博弈（斯塔克尔伯格模型）。通过求解这两种情况下的均衡，你将能够量化率先行动的战略价值，即所谓的“先行者优势” [@problem_id:3154609]。", "problem": "考虑一个同质商品的双寡头数量竞争模型。市场逆需求函数为 $p(Q) = a - bQ$，其中 $a = 120$ 且 $b = 2$，$Q = q_{1} + q_{2}$ 是总产量，$q_{i} \\ge 0$ 是企业 $i$ 的产量，其中 $i \\in \\{1,2\\}$。每个企业的固定边际成本为 $c = 20$，固定成本为零，因此企业 $i$ 的利润为 $\\pi_{i}(q_{i}, q_{j}) = \\big(p(q_{1}+q_{2}) - c\\big) q_{i}$。\n\n你将使用第一性原理的优化方法分析两种博弈顺序：\n\n- Stackelberg（两阶段）：企业 $1$（领导者）在阶段 $1$ 选择 $q_{1}$。然后企业 $2$（跟随者）观察到 $q_{1}$ 并在阶段 $2$ 选择 $q_{2}$。\n- Cournot（同时行动）：企业 $1$ 和企业 $2$ 同时选择 $q_{1}$ 和 $q_{2}$。\n\n使用纳什均衡（NE）作为相互最优反应的定义，通过求取适当的导数并应用一阶条件（FOC）来解决每个企业的问题，必要时通过凹性验证最优性。对于 Stackelberg 情况，使用逆向归纳法推导跟随者的最优反应和领导者的最优选择，然后计算由此产生的均衡产量和企业 $1$ 的利润。接下来，通过求解最优反应方程组，推导 Cournot 博弈中的同时行动纳什均衡产量和企业 $1$ 的利润。\n\n最后，计算企业 $1$ 作为 Stackelberg 领导者相对于同时行动纳什均衡所获得的精确利润增益，定义为\n$\\Delta \\pi_{1} = \\pi_{1}^{\\text{Stackelberg}} - \\pi_{1}^{\\text{Cournot}}$。\n请以精确有理数形式给出最终答案（不要四舍五入）。最终答案中不要包含任何单位。", "solution": "首先验证问题以确保其自洽、有科学依据、良定且客观。\n\n**步骤 1：提取已知条件**\n- 市场逆需求函数: $p(Q) = a - bQ$\n- 参数 $a$: $a = 120$\n- 参数 $b$: $b = 2$\n- 总产量: $Q = q_{1} + q_{2}$\n- 企业产量: $q_{i} \\ge 0$ 对于 $i \\in \\{1,2\\}$\n- 边际成本: $c = 20$ 对两个企业均适用\n- 固定成本: $0$ 对两个企业均适用\n- 企业 $i$ 的利润函数: $\\pi_{i}(q_{i}, q_{j}) = \\big(p(q_{1}+q_{2}) - c\\big) q_{i}$\n- 待分析的两个模型：Stackelberg（企业 1 为领导者，企业 2 为跟随者）和 Cournot（同时行动）。\n- 目标：计算企业 1 的利润增益，$\\Delta \\pi_{1} = \\pi_{1}^{\\text{Stackelberg}} - \\pi_{1}^{\\text{Cournot}}$。\n\n**步骤 2：使用提取的已知条件进行验证**\n- **有科学依据：** 该问题使用了微观经济学理论中标准且成熟的双寡头模型（Cournot 和 Stackelberg 竞争）。函数形式是典型的。没有违反任何科学原理。\n- **良定：** 利润函数相对于每个企业自身的产量是二次且凹的，确保了利润最大化的一阶条件能产生唯一的最大值。两个模型得到的均衡产量都是良定且唯一的。\n- **客观：** 问题使用了精确的数学定义和客观的语言来陈述。\n- **结论：** 该问题是一个标准的微观经济优化练习，没有列出的任何缺陷，因此是有效的。\n\n**步骤 3：进行求解**\n\n首先，我们通过代入给定参数来写出企业 $i$ 的具体利润函数。价格为 $p(q_1+q_2) = 120 - 2(q_1+q_2)$。企业 $i$ 的利润为：\n$$ \\pi_{i}(q_1, q_2) = (120 - 2(q_1+q_2) - 20)q_i = (100 - 2q_1 - 2q_2)q_i $$\n\n**Stackelberg 模型分析**\n\n我们使用逆向归纳法求解，从阶段 2 中跟随者的问题开始。\n\n**阶段 2：跟随者（企业 2）的问题**\n企业 2 将 $q_1$ 视为给定，选择 $q_2$ 以最大化其利润 $\\pi_2$。\n$$ \\pi_2(q_1, q_2) = (100 - 2q_1 - 2q_2)q_2 = 100q_2 - 2q_1q_2 - 2q_2^2 $$\n为了找到最大值，我们对 $\\pi_2$ 求关于 $q_2$ 的导数，并令其等于零（一阶条件，FOC）：\n$$ \\frac{\\partial \\pi_2}{\\partial q_2} = 100 - 2q_1 - 4q_2 = 0 $$\n求解 $q_2$ 得到企业 2 的最优反应函数 $R_2(q_1)$：\n$$ 4q_2 = 100 - 2q_1 \\implies q_2 = R_2(q_1) = 25 - \\frac{1}{2}q_1 $$\n二阶条件（SOC）确认了这是一个最大值，因为利润函数在 $q_2$ 上是凹的：$\\frac{\\partial^2 \\pi_2}{\\partial q_2^2} = -4 < 0$。\n\n**阶段 1：领导者（企业 1）的问题**\n企业 1 预测到企业 2 的反应 $R_2(q_1)$，并选择 $q_1$ 以最大化其自身利润 $\\pi_1$。我们将 $R_2(q_1)$ 代入 $\\pi_1$ 的表达式中：\n$$ \\pi_1(q_1) = \\left(100 - 2q_1 - 2\\left(25 - \\frac{1}{2}q_1\\right)\\right)q_1 $$\n$$ \\pi_1(q_1) = (100 - 2q_1 - 50 + q_1)q_1 $$\n$$ \\pi_1(q_1) = (50 - q_1)q_1 = 50q_1 - q_1^2 $$\n为了找到最优的 $q_1$，我们应用一阶条件（FOC）：\n$$ \\frac{d\\pi_1}{dq_1} = 50 - 2q_1 = 0 \\implies q_1^{\\text{Stackelberg}} = 25 $$\n二阶条件（SOC）满足：$\\frac{d^2\\pi_1}{dq_1^2} = -2 < 0$。\n\n现在我们通过将领导者的产量代入最优反应函数来找到跟随者的产量：\n$$ q_2^{\\text{Stackelberg}} = 25 - \\frac{1}{2}(25) = 12.5 $$\n总产量为 $Q^{\\text{Stackelberg}} = 25 + 12.5 = 37.5$。\n市场价格为 $p^{\\text{Stackelberg}} = 120 - 2(37.5) = 120 - 75 = 45$。\n企业 1 在 Stackelberg 均衡中的利润是：\n$$ \\pi_1^{\\text{Stackelberg}} = (p^{\\text{Stackelberg}} - c)q_1^{\\text{Stackelberg}} = (45 - 20)(25) = 25 \\times 25 = 625 $$\n\n**Cournot 模型分析**\n\n在 Cournot 模型中，两个企业同时选择其产量。纳什均衡是一对产量 $(q_1, q_2)$，其中每个企业的产量都是对另一个企业产量的最优反应。\n\n**企业 1 的最优反应**\n企业 1 选择 $q_1$ 以最大化 $\\pi_1(q_1, q_2) = 100q_1 - 2q_1^2 - 2q_1q_2$，并将 $q_2$ 视为给定。\n企业 1 的一阶条件（FOC）：\n$$ \\frac{\\partial \\pi_1}{\\partial q_1} = 100 - 4q_1 - 2q_2 = 0 $$\n求解 $q_1$ 得到企业 1 的最优反应函数 $R_1(q_2)$：\n$$ 4q_1 = 100 - 2q_2 \\implies q_1 = R_1(q_2) = 25 - \\frac{1}{2}q_2 $$\n\n**企业 2 的最优反应**\n根据对称性，企业 2 的最优反应函数 $R_2(q_1)$ 形式相同：\n$$ q_2 = R_2(q_1) = 25 - \\frac{1}{2}q_1 $$\n\n**Cournot-Nash 均衡**\n通过求解两个最优反应函数的方程组来找到均衡点：\n$$ q_1 = 25 - \\frac{1}{2}q_2 $$\n$$ q_2 = 25 - \\frac{1}{2}q_1 $$\n将第二个方程代入第一个方程：\n$$ q_1 = 25 - \\frac{1}{2}\\left(25 - \\frac{1}{2}q_1\\right) = 25 - \\frac{25}{2} + \\frac{1}{4}q_1 $$\n$$ q_1 - \\frac{1}{4}q_1 = \\frac{25}{2} $$\n$$ \\frac{3}{4}q_1 = \\frac{25}{2} \\implies q_1^{\\text{Cournot}} = \\frac{25}{2} \\times \\frac{4}{3} = \\frac{50}{3} $$\n由于对称性，$q_2^{\\text{Cournot}} = q_1^{\\text{Cournot}} = \\frac{50}{3}$。\n\n现在我们计算企业 1 在 Cournot 均衡中的利润。\n总产量：$Q^{\\text{Cournot}} = \\frac{50}{3} + \\frac{50}{3} = \\frac{100}{3}$。\n市场价格：$p^{\\text{Cournot}} = 120 - 2\\left(\\frac{100}{3}\\right) = \\frac{360 - 200}{3} = \\frac{160}{3}$。\n企业 1 的利润是：\n$$ \\pi_1^{\\text{Cournot}} = (p^{\\text{Cournot}} - c)q_1^{\\text{Cournot}} = \\left(\\frac{160}{3} - 20\\right)\\frac{50}{3} $$\n$$ \\pi_1^{\\text{Cournot}} = \\left(\\frac{160 - 60}{3}\\right)\\frac{50}{3} = \\frac{100}{3} \\times \\frac{50}{3} = \\frac{5000}{9} $$\n\n**利润增益计算**\n\n最后，我们计算企业 1 作为 Stackelberg 领导者相较于 Cournot 结果所获得的利润增益。\n$$ \\Delta \\pi_1 = \\pi_1^{\\text{Stackelberg}} - \\pi_1^{\\text{Cournot}} $$\n$$ \\Delta \\pi_1 = 625 - \\frac{5000}{9} $$\n$$ \\Delta \\pi_1 = \\frac{625 \\times 9}{9} - \\frac{5000}{9} = \\frac{5625 - 5000}{9} = \\frac{625}{9} $$\n企业 1 的利润增益为 $\\frac{625}{9}$。", "answer": "$$\\boxed{\\frac{625}{9}}$$", "id": "3154609"}, {"introduction": "虽然简单的博弈可以通过代数方法求解，但复杂的高维问题则需要依赖数值方法。这最后一个实践练习将挑战你实现并比较多种求解纳什均衡的迭代算法，从经典的“最佳响应”动态到更现代的“超梯度法”。通过对这些算法进行基准测试，你将对大规模博弈问题的计算方法有更深入的认识 [@problem_id:3154618]。", "problem": "要求您设计、实现并比较四种迭代方法，用于计算光滑、严格凸二次双人博弈中的纳什均衡，并在一系列测试案例中对它们的收敛行为进行基准测试。纳什均衡定义为每个参与者的策略在给定其他参与者策略的情况下均为最优的点。对于可微的成本函数，一阶最优性条件将纳什均衡刻画为一个合适算子的零点。您的程序必须是一个完整的、可运行的程序，它不接受任何输入，并打印包含汇总结果的单行输出。\n\n此任务的基础如下。\n\n- 两名参与者分别选择向量 $x \\in \\mathbb{R}^{n}$ 和 $y \\in \\mathbb{R}^{m}$。参与者 1 最小化二次目标函数\n$$\nf_1(x,y) = \\tfrac{1}{2} x^\\top Q_1 x + x^\\top C y + b_1^\\top x + c_1,\n$$\n参与者 2 最小化\n$$\nf_2(x,y) = \\tfrac{1}{2} y^\\top Q_2 y + y^\\top D x + b_2^\\top y + c_2,\n$$\n其中 $Q_1 \\in \\mathbb{R}^{n \\times n}$ 和 $Q_2 \\in \\mathbb{R}^{m \\times m}$ 是对称正定矩阵，$C \\in \\mathbb{R}^{n \\times m}$ 和 $D \\in \\mathbb{R}^{m \\times n}$ 是耦合矩阵，$b_1 \\in \\mathbb{R}^n$，$b_2 \\in \\mathbb{R}^m$ 是向量。常数 $c_1$ 和 $c_2$ 对最优性没有影响，可以是任意值。\n\n- 编码一阶最优性条件的算子映射为\n$$\nF(z) = \\begin{bmatrix}\n\\nabla_x f_1(x,y) \\\\\n\\nabla_y f_2(x,y)\n\\end{bmatrix}\n= M z + q,\n\\quad\nz = \\begin{bmatrix} x \\\\ y \\end{bmatrix},\n\\quad\nM = \\begin{bmatrix} Q_1 & C \\\\ D & Q_2 \\end{bmatrix},\n\\quad\nq = \\begin{bmatrix} b_1 \\\\ b_2 \\end{bmatrix}.\n$$\n当 $M$ 是对称正定矩阵时（例如，当 $D=C^\\top$ 且 $Q_1, Q_2$ 对称正定时），$F$ 是强单调且利普希茨连续的。唯一的纳什均衡 $z^\\star$ 满足 $F(z^\\star) = 0$。\n\n您的任务是基于上述基础，实现以下迭代方法，并且不依赖问题陈述中的任何快捷公式。\n\n- 最佳响应 (BR)：在对手当前策略固定的情况下，依次最小化每个参与者的目标函数，使用二次子问题的精确解。\n\n- 梯度博弈 (GP)：使用算子 $F$ 对两个参与者的策略应用同步的基于梯度的步骤。\n\n- 近端最佳响应 (PBR)：通过在每个参与者的子问题中添加一个二次正则化项来修改最佳响应，该正则化项惩罚与当前迭代点的偏差，以引发收缩并稳定迭代过程。\n\n- 外梯度法 (EG)：在主更新之前应用一个额外的前瞻梯度步骤，以校正算子的曲率；在两个阶段都使用映射 $F$。\n\n对于梯度博弈和外梯度法，您必须根据 $F$ 的利普希茨常数选择步长。对于二次博弈，$F$ 是线性的，利普希茨常数等于 $M$ 的谱范数，记为 $L$。一个安全的选择是步长 $\\gamma$ 满足 $0 < \\gamma \\leq 1/L$。对于近端最佳响应，选择一个正则化参数 $\\rho > 0$；一个实用且有理论依据的选择是 $\\rho = L$。\n\n需遵循的实现细节：\n\n- 初始化：对所有方法使用零向量 $z_0 = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}$。\n\n- 终止准则：对于每种方法，迭代直到欧几里得范数误差 $\\lVert z_k - z^\\star \\rVert_2$ 小于容忍度 $\\varepsilon = 10^{-8}$，或直到达到最大迭代次数 $N_{\\max} = 5000$。如果方法在 $N_{\\max}$ 次迭代内未能达到容忍度，则为该方法报告 $-1$。\n\n- 输出：对于每个测试用例，报告一个包含 4 个整数的列表，分别对应 BR、GP、PBR 和 EG 所用的迭代次数，顺序如此。您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，每个元素本身是针对一个测试用例的列表。例如，一个有效的输出格式是\n$$\n[\\,[i_{1,\\mathrm{BR}}, i_{1,\\mathrm{GP}}, i_{1,\\mathrm{PBR}}, i_{1,\\mathrm{EG}}],\\,[i_{2,\\mathrm{BR}}, i_{2,\\mathrm{GP}}, i_{2,\\mathrm{PBR}}, i_{2,\\mathrm{EG}}],\\,\\dots\\,]\n$$\n其中每个 $i_{\\cdot,\\cdot}$ 都是一个整数。\n\n测试套件规范：\n\n提供以下五个凸二次博弈，所有博弈都设置 $D = C^\\top$ 以确保 $M$ 是对称的。\n\n- 案例 1（标量变量，中等耦合）：\n$$\nn=m=1,\\quad\nQ_1 = [\\,2\\,],\\quad\nQ_2 = [\\,3\\,],\\quad\nC = [\\,0.5\\,],\\quad\nb_1 = [\\,1\\,],\\quad\nb_2 = [\\,-2\\,].\n$$\n\n- 案例 2（标量变量，解耦边界情况）：\n$$\nn=m=1,\\quad\nQ_1 = [\\,1.5\\,],\\quad\nQ_2 = [\\,2.5\\,],\\quad\nC = [\\,0.0\\,],\\quad\nb_1 = [\\,-1.0\\,],\\quad\nb_2 = [\\,3.0\\,].\n$$\n\n- 案例 3（二维变量，中等耦合）：\n$$\nn=m=2,\\quad\nQ_1 = \\begin{bmatrix} 2 & 0 \\\\ 0 & 4 \\end{bmatrix},\\quad\nQ_2 = \\begin{bmatrix} 3 & 0 \\\\ 0 & 1.5 \\end{bmatrix},\\quad\nC = \\begin{bmatrix} 0.3 & -0.1 \\\\ 0.2 & 0.0 \\end{bmatrix},\\quad\nb_1 = \\begin{bmatrix} 1 \\\\ -1 \\end{bmatrix},\\quad\nb_2 = \\begin{bmatrix} 0.5 \\\\ -0.5 \\end{bmatrix}.\n$$\n\n- 案例 4（二维变量，病态但稳定）：\n$$\nn=m=2,\\quad\nQ_1 = \\begin{bmatrix} 0.01 & 0 \\\\ 0 & 100 \\end{bmatrix},\\quad\nQ_2 = \\begin{bmatrix} 0.001 & 0 \\\\ 0 & 50 \\end{bmatrix},\\quad\nC = \\begin{bmatrix} 0.05 & 0.0 \\\\ 0.0 & 0.05 \\end{bmatrix},\\quad\nb_1 = \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix},\\quad\nb_2 = \\begin{bmatrix} -1 \\\\ 2 \\end{bmatrix}.\n$$\n\n- 案例 5（三维变量，更强但仍稳定的耦合）：\n$$\nn=m=3,\\quad\nQ_1 = \\mathrm{diag}(1,2,3),\\quad\nQ_2 = \\mathrm{diag}(1.5,2.5,3.5),\\quad\nC = 0.3\\,I_3,\\quad\nb_1 = \\begin{bmatrix} 1 \\\\ -2 \\\\ 0.5 \\end{bmatrix},\\quad\nb_2 = \\begin{bmatrix} -1 \\\\ 1 \\\\ 2 \\end{bmatrix},\n$$\n其中 $I_3$ 是 $3 \\times 3$ 的单位矩阵。\n\n实现约束：\n\n- 通过求解线性系统 $M z^\\star + q = 0$ 来精确计算 $z^\\star$。\n\n- 对于梯度博弈和外梯度法，将 $L$ 计算为 $M$ 的谱范数，并使用 $\\gamma = 1/L$。\n\n- 对于近端最佳响应，使用 $\\rho = L$。\n\n- 确保所有迭代从 $z_0 = 0$ 开始，并使用欧几里得范数误差容忍度 $\\varepsilon = 10^{-8}$。\n\n您的最终程序必须以指定格式将所有五个案例的结果打印为单行输出，每个内部列表给出相应案例的迭代次数 $[i_{\\mathrm{BR}}, i_{\\mathrm{GP}}, i_{\\mathrm{PBR}}, i_{\\mathrm{EG}}]$。", "solution": "我们从可微、严格凸二次博弈中纳什均衡和一阶最优性的基本定义出发。参与者 1 关于 $x$ 的梯度是\n$$\n\\nabla_x f_1(x,y) = Q_1 x + C y + b_1,\n$$\n参与者 2 关于 $y$ 的梯度是\n$$\n\\nabla_y f_2(x,y) = Q_2 y + D x + b_2.\n$$\n将变量 $z = \\begin{bmatrix} x \\\\ y \\end{bmatrix}$ 和梯度堆叠起来，得到算子 $F(z) = M z + q$，其中\n$$\nM = \\begin{bmatrix} Q_1 & C \\\\ D & Q_2 \\end{bmatrix}, \\quad q = \\begin{bmatrix} b_1 \\\\ b_2 \\end{bmatrix}.\n$$\n当 $M$ 是对称正定矩阵时，通过取 $D=C^\\top$ 且 $Q_1, Q_2$ 为对称正定矩阵，以及足够小的耦合，这一条件在测试套件中成立，此时 $F$ 是强单调且利普希茨连续的。唯一的纳什均衡解 $F(z^\\star) = 0$。由于 $F$ 是线性的，我们得到\n$$\nM z^\\star + q = 0 \\quad \\Rightarrow \\quad z^\\star = - M^{-1} q,\n$$\n这可以通过线性求解器计算。\n\n现在我们从核心原理推导每种迭代方法。\n\n- 最佳响应 (BR)。保持对手的策略固定，将每个参与者的问题简化为关于其自身变量的严格凸二次问题。二次函数 $x \\mapsto \\tfrac{1}{2} x^\\top Q_1 x + (C y_k + b_1)^\\top x$ 的最小化点由一阶条件 $Q_1 x_{k+1} + C y_k + b_1 = 0$ 刻画，即\n$$\nx_{k+1} = -Q_1^{-1}(C y_k + b_1).\n$$\n然后，给定 $x_{k+1}$，参与者 2 的最佳响应满足 $Q_2 y_{k+1} + D x_{k+1} + b_2 = 0$，即\n$$\ny_{k+1} = -Q_2^{-1}(D x_{k+1} + b_2).\n$$\n这两个更新实现了求解 $M z + q = 0$ 的块高斯-赛德尔方法。\n\n- 梯度博弈 (GP)。对两个参与者使用算子 $F$ 的同步梯度步骤为\n$$\nz_{k+1} = z_k - \\gamma F(z_k) = z_k - \\gamma (M z_k + q).\n$$\n对于常数为 $L = \\lVert M \\rVert_2$（谱范数）的线性利普希茨算子，稳定性的一个充分条件是 $0 < \\gamma \\le 1/L$。我们选择 $\\gamma = 1/L$ 以获得一个安全的步长。\n\n- 近端最佳响应 (PBR)。近端修改添加了一个二次正则化项，惩罚与当前迭代点的变化。对于参与者 1，子问题是\n$$\n\\min_x \\left\\{ \\tfrac{1}{2} x^\\top Q_1 x + (C y_k + b_1)^\\top x + \\tfrac{\\rho}{2} \\lVert x - x_k \\rVert_2^2 \\right\\}.\n$$\n其一阶条件是\n$$\nQ_1 x_{k+1} + C y_k + b_1 + \\rho (x_{k+1} - x_k) = 0 \\quad \\Rightarrow \\quad (Q_1 + \\rho I) x_{k+1} = \\rho x_k - C y_k - b_1,\n$$\n得到\n$$\nx_{k+1} = (Q_1 + \\rho I)^{-1}(\\rho x_k - C y_k - b_1).\n$$\n类似地，参与者 2 的更新是\n$$\ny_{k+1} = (Q_2 + \\rho I)^{-1}(\\rho y_k - D x_{k+1} - b_2).\n$$\n选择 $\\rho = L$ 会产生一个强收缩，与未正则化的 BR 相比，它能稳定并通常加速收敛。\n\n- 外梯度法 (EG)。Korpelevich 用于单调变分不等式的外梯度法在主更新前计算一个前瞻点并在该点评估算子。对于我们无约束的线性算子 $F$，\n$$\nz_{k+\\tfrac{1}{2}} = z_k - \\gamma F(z_k), \\quad\nz_{k+1} = z_k - \\gamma F(z_{k+\\tfrac{1}{2}}),\n$$\n使用同样的安全步长选择 $\\gamma = 1/L$。这校正了曲率，并比普通梯度博弈法提供了更好的鲁棒性，在许多情况下收敛速度也更快。\n\n所有方法都从 $z_0 = 0$ 开始。当欧几里得范数误差满足\n$$\n\\lVert z_k - z^\\star \\rVert_2 \\le \\varepsilon, \\quad \\varepsilon = 10^{-8},\n$$\n或者当迭代次数超过 $N_{\\max} = 5000$ 时，我们终止迭代。在后一种情况下，我们报告失败代码 $-1$。\n\n对于由 $(Q_1, Q_2, C, D, b_1, b_2)$ 定义的每个测试用例，我们：\n\n1. 构建 $M$ 和 $q$。\n2. 计算均衡点 $z^\\star = -M^{-1} q$。\n3. 通过奇异值计算谱范数 $L = \\lVert M \\rVert_2$，并设置 $\\gamma = 1/L$ 和 $\\rho = L$。\n4. 从 $z_0 = 0$ 开始运行 BR、GP、PBR 和 EG，计算迭代次数直到达到容忍度或发生失败。\n5. 记录四个整数 $[i_{\\mathrm{BR}}, i_{\\mathrm{GP}}, i_{\\mathrm{PBR}}, i_{\\mathrm{EG}}]$。\n\n测试套件中的设计覆盖：\n\n- 案例 2 设置 $C = 0$，创建了解耦问题。BR 和 PBR 在一次迭代中即可获得精确解，因为每个参与者的子问题是独立的；GP 和 EG 仍然线性收敛，但通常需要多次迭代。这是一个测试正确性和精确性的边界情况。\n\n- 案例 4 使用病态的 $Q_1$ 和 $Q_2$，耦合虽小但非零。由于条件数问题，GP 的速度显著减慢；EG 和 PBR 提高了稳定性。这测试了对条件数的敏感性以及正则化和前瞻步骤的好处。\n\n- 案例 1、3 和 5 分别在一维、二维和三维设置中提供了常规路径和更强耦合的场景，测试了方法在不同维度下的可扩展性和鲁棒性。\n\n最终程序精确实现了这些步骤，并打印一行包含五个案例的迭代次数嵌套列表的输出。这通过固定容忍度下的迭代次数，使用相同的初始化和从算子利普希茨常数推导出的理论安全参数选择，定量地对收敛行为（“速率”）进行了基准测试。", "answer": "```python\n# Python 3.12; numpy 1.23.5; scipy not used.\nimport numpy as np\n\ndef spectral_norm(M: np.ndarray) -> float:\n    # Spectral norm (largest singular value)\n    return np.linalg.svd(M, compute_uv=False)[0]\n\ndef equilibrium(M: np.ndarray, q: np.ndarray) -> np.ndarray:\n    # Solve M z* + q = 0 => z* = - M^{-1} q\n    return -np.linalg.solve(M, q)\n\ndef best_response(Q1, Q2, C, D, b1, b2, z_star, tol=1e-8, max_iters=5000):\n    n = Q1.shape[0]\n    m = Q2.shape[0]\n    x = np.zeros(n)\n    y = np.zeros(m)\n    for k in range(1, max_iters + 1):\n        # Player 1 best response\n        rhs1 = -C @ y - b1\n        x = np.linalg.solve(Q1, rhs1)\n        # Player 2 best response\n        rhs2 = -D @ x - b2\n        y = np.linalg.solve(Q2, rhs2)\n        z = np.concatenate([x, y])\n        err = np.linalg.norm(z - z_star)\n        if err <= tol:\n            return k\n    return -1\n\ndef proximal_best_response(Q1, Q2, C, D, b1, b2, z_star, rho, tol=1e-8, max_iters=5000):\n    n = Q1.shape[0]\n    m = Q2.shape[0]\n    x = np.zeros(n)\n    y = np.zeros(m)\n    Q1p = Q1 + rho * np.eye(n)\n    Q2p = Q2 + rho * np.eye(m)\n    for k in range(1, max_iters + 1):\n        rhs1 = rho * x - C @ y - b1\n        x = np.linalg.solve(Q1p, rhs1)\n        rhs2 = rho * y - D @ x - b2\n        y = np.linalg.solve(Q2p, rhs2)\n        z = np.concatenate([x, y])\n        err = np.linalg.norm(z - z_star)\n        if err <= tol:\n            return k\n    return -1\n\ndef gradient_play(M, q, z_star, gamma, tol=1e-8, max_iters=5000):\n    z = np.zeros_like(z_star)\n    for k in range(1, max_iters + 1):\n        Fz = M @ z + q\n        z = z - gamma * Fz\n        err = np.linalg.norm(z - z_star)\n        if err <= tol:\n            return k\n    return -1\n\ndef extragradient(M, q, z_star, gamma, tol=1e-8, max_iters=5000):\n    z = np.zeros_like(z_star)\n    for k in range(1, max_iters + 1):\n        Fz = M @ z + q\n        z_half = z - gamma * Fz\n        Fz_half = M @ z_half + q\n        z = z - gamma * Fz_half\n        err = np.linalg.norm(z - z_star)\n        if err <= tol:\n            return k\n    return -1\n\ndef build_block_matrix(Q1, Q2, C, D):\n    return np.block([[Q1, C],\n                     [D, Q2]])\n\ndef solve_case(Q1, Q2, C, D, b1, b2):\n    M = build_block_matrix(Q1, Q2, C, D)\n    q = np.concatenate([b1, b2])\n    z_star = equilibrium(M, q)\n    L = spectral_norm(M)\n    gamma = 1.0 / L\n    rho = L\n    it_br = best_response(Q1, Q2, C, D, b1, b2, z_star, tol=1e-8, max_iters=5000)\n    it_gp = gradient_play(M, q, z_star, gamma=gamma, tol=1e-8, max_iters=5000)\n    it_pbr = proximal_best_response(Q1, Q2, C, D, b1, b2, z_star, rho=rho, tol=1e-8, max_iters=5000)\n    it_eg = extragradient(M, q, z_star, gamma=gamma, tol=1e-8, max_iters=5000)\n    return [it_br, it_gp, it_pbr, it_eg]\n\ndef solve():\n    test_cases = []\n\n    # Case 1: scalar, moderate coupling\n    Q1 = np.array([[2.0]])\n    Q2 = np.array([[3.0]])\n    C = np.array([[0.5]])\n    D = C.T\n    b1 = np.array([1.0])\n    b2 = np.array([-2.0])\n    test_cases.append((Q1, Q2, C, D, b1, b2))\n\n    # Case 2: scalar, decoupled\n    Q1 = np.array([[1.5]])\n    Q2 = np.array([[2.5]])\n    C = np.array([[0.0]])\n    D = C.T\n    b1 = np.array([-1.0])\n    b2 = np.array([3.0])\n    test_cases.append((Q1, Q2, C, D, b1, b2))\n\n    # Case 3: 2D, moderate coupling\n    Q1 = np.array([[2.0, 0.0],\n                   [0.0, 4.0]])\n    Q2 = np.array([[3.0, 0.0],\n                   [0.0, 1.5]])\n    C = np.array([[0.3, -0.1],\n                  [0.2,  0.0]])\n    D = C.T\n    b1 = np.array([1.0, -1.0])\n    b2 = np.array([0.5, -0.5])\n    test_cases.append((Q1, Q2, C, D, b1, b2))\n\n    # Case 4: 2D, ill-conditioned\n    Q1 = np.array([[0.01, 0.0],\n                   [0.0, 100.0]])\n    Q2 = np.array([[0.001, 0.0],\n                   [0.0, 50.0]])\n    C = np.array([[0.05, 0.0],\n                  [0.0, 0.05]])\n    D = C.T\n    b1 = np.array([1.0, 1.0])\n    b2 = np.array([-1.0, 2.0])\n    test_cases.append((Q1, Q2, C, D, b1, b2))\n\n    # Case 5: 3D, stronger but stable coupling\n    Q1 = np.diag([1.0, 2.0, 3.0])\n    Q2 = np.diag([1.5, 2.5, 3.5])\n    C = 0.3 * np.eye(3)\n    D = C.T\n    b1 = np.array([1.0, -2.0, 0.5])\n    b2 = np.array([-1.0, 1.0, 2.0])\n    test_cases.append((Q1, Q2, C, D, b1, b2))\n\n    results = []\n    for Q1, Q2, C, D, b1, b2 in test_cases:\n        res = solve_case(Q1, Q2, C, D, b1, b2)\n        results.append(res)\n\n    print(str(results).replace(' ', ''))\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3154618"}]}