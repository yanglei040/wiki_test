{"hands_on_practices": [{"introduction": "这个实践探讨了约束优化的核心——卡罗需-库恩-塔克（Karush-Kuhn-Tucker, KKT）条件。通过一个精心设计的简单例子，你将观察当积极集方法遇到“退化”解时算法的行为，在这种情况下，标准的最优性信号（拉格朗日乘子）可能会变得模糊。这揭示了深刻理解优化理论中细微之处的重要性，特别是在解释算法输出时。", "problem": "考虑一个含两个变量的二次规划 (QP) 问题，其目标函数为 $f(x)=\\tfrac{1}{2} x^{\\top} Q x$，线性不等式约束为 $A x \\le b$，其中 $Q \\in \\mathbb{R}^{2 \\times 2}$，$A \\in \\mathbb{R}^{2 \\times 2}$，$b \\in \\mathbb{R}^{2}$。令 $Q=I_{2}$，$A=-I_{2}$，以及 $b=\\begin{pmatrix}0 \\\\ 0\\end{pmatrix}$。因此，可行域为 $\\{x \\in \\mathbb{R}^{2} : x \\ge 0\\}$，$f$ 的无约束极小值点为 $x=\\begin{pmatrix}0 \\\\ 0\\end{pmatrix}$。\n\n您将从可行点 $x^{0}=\\begin{pmatrix}1 \\\\ 1\\end{pmatrix}$ 和初始工作集 $W^{0}=\\varnothing$ 开始，运行一次主动集方法的迭代。在由 $W^{0}$ 定义的等式约束子问题中，计算在 $W^{0}$ 约束下使 $f$ 最小化的搜索方向 $p^{0}$。然后，沿射线 $x(\\alpha)=x^{0}+\\alpha p^{0}$ 应用标准的保持可行性的步长接受准则，以确定使 $A x(\\alpha) \\le b$ 成立的最大可接受步长 $\\alpha^{\\star}$。在采用可接受步长得到 $x^{1}=x^{0}+\\alpha^{\\star} p^{0}$，并将所有在 $x^{1}$ 处变为主动的约束加入以更新工作集后，使用约束二次最小化的最优性条件，计算与 $x^{1}$ 处主动约束相关的拉格朗日乘子。\n\n仅使用可行性、平稳性和互补性的基本定义，以及主动集方法的逻辑，确定可接受的步长 $\\alpha^{\\star}$ 和所得点处与两个约束相关的乘子 $\\lambda_{1}^{\\star}$ 和 $\\lambda_{2}^{\\star}$。将您的最终答案表示为一个行矩阵，其元素为 $\\alpha^{\\star}$、$\\lambda_{1}^{\\star}$、$\\lambda_{2}^{\\star}$。无需四舍五入。", "solution": "该问题是一个二次规划 (QP) 问题，定义如下：\n$$\n\\text{最小化} \\quad f(x) = \\frac{1}{2} x^{\\top} Q x \\\\\n\\text{满足} \\quad A x \\le b\n$$\n其中 $x \\in \\mathbb{R}^{2}$。给定的参数为海森矩阵 $Q = I_{2} = \\begin{pmatrix} 1  0 \\\\ 0  1 \\end{pmatrix}$，约束矩阵 $A = -I_{2} = \\begin{pmatrix} -1  0 \\\\ 0  -1 \\end{pmatrix}$，以及向量 $b = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}$。\n\n目标函数可以写为 $f(x_1, x_2) = \\frac{1}{2} (x_1^2 + x_2^2)$。目标函数的梯度为 $\\nabla f(x) = Qx = I_{2}x = x$。\n约束 $A x \\le b$ 等价于 $-I_{2}x \\le 0$，可以简化为 $-x \\le 0$，即 $x \\ge 0$。这可以写成两个独立的线性不等式约束：\n$c_1(x): -x_1 \\le 0$\n$c_2(x): -x_2 \\le 0$\n矩阵 $A$ 的行向量为 $a_1^{\\top} = \\begin{pmatrix} -1  0 \\end{pmatrix}$ 和 $a_2^{\\top} = \\begin{pmatrix} 0  -1 \\end{pmatrix}$。\n\n我们从可行点 $x^{0}=\\begin{pmatrix}1 \\\\ 1\\end{pmatrix}$ 和初始工作集 $W^{0}=\\varnothing$ 开始，进行一次主动集方法的迭代。在 $x^0$ 处，我们有 $c_1(x^0) = -1  0$ 和 $c_2(x^0) = -1  0$，这确认了没有约束是主动的，并且 $W^0$ 的选择是一致的。\n\n首先，我们通过求解由当前工作集 $W^0$ 定义的等式约束子问题来计算搜索方向 $p^0$。我们寻找一个步长 $p$，它能在 $W^0$ 中的约束为主动的条件下最小化 $f(x^0+p)$，即对于所有 $i \\in W^0$ 都有 $a_i^{\\top} p = 0$。\n由于 $W^0 = \\varnothing$，$p$ 不受任何约束。该子问题是 $f(x^0+p) = \\frac{1}{2}(x^0+p)^{\\top}Q(x^0+p)$ 的无约束最小化问题。关于 $p$ 的目标函数是 $\\frac{1}{2}p^{\\top}Qp + (Qx^0)^{\\top}p + \\text{常数项}$。\n通过将关于 $p$ 的梯度设为零，可以找到最优步长 $p^0$：\n$$\n\\nabla_p f(x^0+p) \\Big|_{p=p^0} = Q p^0 + Q x^0 = 0\n$$\n这给出了线性系统 $Q p^0 = -Q x^0$。代入给定的矩阵 $Q=I_2$：\n$$\nI_2 p^0 = -I_2 x^0 \\implies p^0 = -x^0\n$$\n当 $x^0 = \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}$ 时，搜索方向为 $p^0 = \\begin{pmatrix} -1 \\\\ -1 \\end{pmatrix}$。\n\n接下来，我们确定保持可行性的最大步长 $\\alpha^{\\star}$。新的点是 $x(\\alpha) = x^0 + \\alpha p^0$。我们需要 $x(\\alpha)$ 满足所有不在工作集中的约束，即对于 $i \\in \\{1, 2\\}$，有 $a_i^{\\top}(x^0 + \\alpha p^0) \\le b_i$。由于两个约束都有 $b_i=0$，此式为 $a_i^{\\top}x^0 + \\alpha a_i^{\\top}p^0 \\le 0$。\n要使约束 $i$ 变为主动，我们必须向其边界移动。这在 $a_i^{\\top} p^0  0$ 的条件下发生。使约束 $i$ 变为主动的步长由 $\\alpha_i = \\frac{b_i-a_i^{\\top}x^0}{a_i^{\\top}p^0} = \\frac{-a_i^{\\top}x^0}{a_i^{\\top}p^0}$ 给出。\n\n对于约束 1：$a_1^{\\top} = \\begin{pmatrix} -1  0 \\end{pmatrix}$。\n$a_1^{\\top}p^0 = \\begin{pmatrix} -1  0 \\end{pmatrix} \\begin{pmatrix} -1 \\\\ -1 \\end{pmatrix} = 1  0$。\n到达此约束边界的步长为 $\\alpha_1 = \\frac{-a_1^{\\top}x^0}{a_1^{\\top}p^0} = \\frac{-(-1)}{1} = 1$。\n\n对于约束 2：$a_2^{\\top} = \\begin{pmatrix} 0  -1 \\end{pmatrix}$。\n$a_2^{\\top}p^0 = \\begin{pmatrix} 0  -1 \\end{pmatrix} \\begin{pmatrix} -1 \\\\ -1 \\end{pmatrix} = 1  0$。\n到达此约束边界的步长为 $\\alpha_2 = \\frac{-a_2^{\\top}x^0}{a_2^{\\top}p^0} = \\frac{-(-1)}{1} = 1$。\n\n在违反任何约束之前的最大步长为 $\\alpha_{max} = \\min\\{\\alpha_1, \\alpha_2\\} = \\min\\{1, 1\\} = 1$。\n到达无约束子问题极小值点的步长为 1，因为 $x^0 + 1 \\cdot p^0 = x^0 - x^0 = 0$。\n可接受的步长 $\\alpha^{\\star}$ 是到达子问题极小值点的步长与最大可行步长中的较小者：$\\alpha^{\\star} = \\min(1, \\alpha_{max}) = \\min(1, 1) = 1$。\n\n新的迭代点是 $x^1 = x^0 + \\alpha^{\\star} p^0$：\n$$\nx^1 = \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix} + 1 \\cdot \\begin{pmatrix} -1 \\\\ -1 \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}\n$$\n在 $x^1$ 处，两个约束都是主动的：\n$c_1(x^1) = -x_1^1 = 0$\n$c_2(x^1) = -x_2^1 = 0$\n由于步长同时受到约束 1 和 2 的限制，新的工作集更新为包含它们的索引：$W^1 = \\{1, 2\\}$。\n\n最后，我们计算与 $x^1$ 处主动约束相关的拉格朗日乘子 $\\lambda^{\\star} = \\begin{pmatrix} \\lambda_1^{\\star} \\\\ \\lambda_2^{\\star} \\end{pmatrix}$。原始 QP 问题的一阶最优性（平稳性）条件表明，在一个约束极小值点处，目标函数的梯度必须是主动约束梯度的线性组合：\n$$\n\\nabla f(x^1) + \\sum_{i \\in W^1} \\lambda_i^{\\star} \\nabla c_i (x^1) = 0\n$$\n在 $x^1 = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}$ 处的目标函数梯度为 $\\nabla f(x^1) = x^1 = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}$。\n约束的梯度是常数向量：$\\nabla c_1(x) = a_1 = \\begin{pmatrix} -1 \\\\ 0 \\end{pmatrix}$ 和 $\\nabla c_2(x) = a_2 = \\begin{pmatrix} 0 \\\\ -1 \\end{pmatrix}$。\n平稳性条件变为：\n$$\n\\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix} + \\lambda_1^{\\star} \\begin{pmatrix} -1 \\\\ 0 \\end{pmatrix} + \\lambda_2^{\\star} \\begin{pmatrix} 0 \\\\ -1 \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}\n$$\n这等价于线性系统：\n$$\n\\begin{pmatrix} -1  0 \\\\ 0  -1 \\end{pmatrix} \\begin{pmatrix} \\lambda_1^{\\star} \\\\ \\lambda_2^{\\star} \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}\n$$\n该系统有唯一解 $\\lambda_1^{\\star} = 0$ 和 $\\lambda_2^{\\star} = 0$。\n\n单次迭代的结果是：可接受的步长 $\\alpha^{\\star} = 1$，以及拉格朗日乘子 $\\lambda_1^{\\star} = 0$ 和 $\\lambda_2^{\\star} = 0$。", "answer": "$$\n\\boxed{\\begin{pmatrix} 1  0  0 \\end{pmatrix}}\n$$", "id": "3094761"}, {"introduction": "最后的这个实践挑战你综合运用所学知识，为一个在统计学和机器学习中非常常见的问题——带边界约束的岭回归——构建一个完整的积极集求解器。你将从第一性原理出发实现该算法，生成具有已知解的测试案例，并验证求解器的正确性。这个练习旨在将理论概念与编写实用、稳健的数值代码的实践联系起来，是理论通向应用的关键一步。", "problem": "我们要求您实现一个完整的、可运行的程序，该程序解决一系列源自岭回归的严格凸、有界约束的二次规划问题，并验证活动集方法在有噪声的情况下是否能正确识别饱和的系数。目标是从第一性原理出发，从 Karush–Kuhn–Tucker (KKT) 条件和岭回归的结构开始，推导并实现一个用于有界约束二次规划的活动集方法。\n\n考虑带有界约束的岭回归二次规划问题\n$$\n\\min_{x \\in \\mathbb{R}^n} \\;\\; \\tfrac{1}{2}\\|A x - b\\|_2^2 + \\tfrac{\\lambda}{2}\\|x\\|_2^2 \\quad \\text{subject to} \\quad \\ell \\le x \\le u,\n$$\n其中 $A \\in \\mathbb{R}^{m \\times n}$，$b \\in \\mathbb{R}^{m}$，$\\lambda \\in \\mathbb{R}_{0}$，且界限 $\\ell, u \\in \\mathbb{R}^n$ 对所有 $i \\in \\{1,\\dots,n\\}$ 满足 $\\ell_i \\le u_i$。这可以写成标准的二次规划 (QP) 形式\n$$\n\\min_{x \\in \\mathbb{R}^n} \\;\\; \\tfrac{1}{2} x^\\top Q x + c^\\top x \\quad \\text{subject to} \\quad \\ell \\le x \\le u,\n$$\n其中 $Q = A^\\top A + \\lambda I$ 且 $c = -A^\\top b$。因为 $\\lambda \\in \\mathbb{R}_{0}$，$Q$ 是对称正定的。\n\n您必须实现一个专门用于界约束的原始可行活动集方法。设计必须从基本定义开始：凸性、拉格朗日最优性和有界约束凸 QP 的 KKT 条件。算法在每次迭代中应将当前活动的界限视为等式约束，为自由变量求解降维后的无约束 QP，通过采用最大可行步长来强制可行性，并根据乘子违反 KKT 符号条件的情况来更新活动集。必须明确选择数值容差，并根据 KKT 条件的性质给出理由。\n\n测试实例的构建。对于下面的每个测试用例，您将使用固定的伪随机种子生成一个具有独立标准正态分布元素的矩阵 $A$，然后从一个设计好的可行点 $x_\\star$ 和一个设计好的 KKT 残差向量 $g_\\star$（该向量编码了哪些界限应处于活动状态）构造一个严格凸的 QP 实例。具体来说：\n- 令 $Q = A^\\top A + \\lambda I$。\n- 选择一个可行点 $x_\\star$ 满足 $\\ell \\le x_\\star \\le u$，其中一些坐标恰好在其界限上，以指定目标活动集。\n- 选择一个向量 $g_\\star \\in \\mathbb{R}^n$，其元素满足：如果 $x_{\\star,i} \\in (\\ell_i, u_i)$，则 $g_{\\star,i} = 0$；如果 $x_{\\star,i} = \\ell_i$，则 $g_{\\star,i} \\in \\mathbb{R}_{0}$；如果 $x_{\\star,i} = u_i$，则 $g_{\\star,i} \\in \\mathbb{R}_{\\le 0}$。这些与界约束的 KKT 符号条件是一致的。\n- 设 $c = -g_\\star - Q x_\\star$，从而 $Q x_\\star + c = g_\\star$ 成立。\n- 通过选择 $b$ 作为 $A^\\top b = -c$ 的最小范数解来强制 $c = -A^\\top b$，即 $b = A (A^\\top A)^{-1} (-c)$。\n- 使用固定的伪随机种子向 $b$ 添加均值为 $0$、方差为 $\\sigma^2$ 的独立高斯噪声，得到 $\\tilde{b} = b + \\varepsilon$。\n\n您的求解器必须接着求解带噪声的、有界约束的岭回归 QP\n$$\n\\min_{x \\in \\mathbb{R}^n} \\;\\; \\tfrac{1}{2}\\|A x - \\tilde{b}\\|_2^2 + \\tfrac{\\lambda}{2}\\|x\\|_2^2 \\quad \\text{subject to} \\quad \\ell \\le x \\le u\n$$\n并输出所识别的活动集是否与设计的活动集相等。对于指定的容差 $\\tau \\in \\mathbb{R}_{0}$，如果 $x_i \\le \\ell_i + \\tau$，则系数 $x_i$ 被识别为下界活动；如果 $x_i \\ge u_i - \\tau$，则被识别为上界活动。您还必须确保当 KKT 条件在指定的容差 $\\epsilon \\in \\mathbb{R}_{0}$ 内满足时，您的迭代终止。请在您的求解器中选择并论证小的容差值。\n\n测试套件。实现以下四个测试用例。所有尺寸、界限、种子和噪声水平都已指定。对于每个用例，完全按照上述描述构造 $A$、$Q$、$x_\\star$、$g_\\star$、$c$、$b$ 和 $\\tilde{b}$。使用具有固定种子的独立同分布标准正态生成器来构造 $A$ 和高斯噪声；使用经典的伪随机生成器，该生成器对给定的整数种子产生确定性的流。\n\n- 用例 #1（理想情况，混合活动状态）：\n  - 维度：$m = 30$, $n = 4$。\n  - 用于 $A$ 的种子：$123$。\n  - 岭参数：$\\lambda = 0.5$。\n  - 界限：$\\ell = [0, 0, 0, 0]$，$u = [0.3, 0.2, 0.5, 0.1]$。\n  - 设计点：$x_\\star = [0.3, 0.0, 0.2, 0.1]$。\n  - 设计的 KKT 残差：$g_\\star = [-0.6, 0.4, 0.0, -0.5]$。\n  - 噪声标准差：$\\sigma = 10^{-4}$。\n  - 用于噪声的种子：$999$。\n  - 预期的活动集：下界活动索引是 $\\{1\\}$，上界活动索引是 $\\{0, 3\\}$。\n\n- 用例 #2（内部解，无活动状态）：\n  - 维度：$m = 25$, $n = 4$。\n  - 用于 $A$ 的种子：$321$。\n  - 岭参数：$\\lambda = 0.3$。\n  - 界限：$\\ell = [-1, -1, -1, -1]$，$u = [1, 1, 1, 1]$。\n  - 设计点：$x_\\star = [0.2, -0.3, 0.1, 0.05]$。\n  - 设计的 KKT 残差：$g_\\star = [0, 0, 0, 0]$。\n  - 噪声标准差：$\\sigma = 10^{-4}$。\n  - 用于噪声的种子：$1001$。\n  - 预期的活动集：两者均为空。\n\n- 用例 #3（所有下界均活动）：\n  - 维度：$m = 28$, $n = 4$。\n  - 用于 $A$ 的种子：$222$。\n  - 岭参数：$\\lambda = 0.2$。\n  - 界限：$\\ell = [0, 0, 0, 0]$，$u = [1, 1, 1, 1]$。\n  - 设计点：$x_\\star = [0, 0, 0, 0]$。\n  - 设计的 KKT 残差：$g_\\star = [0.7, 0.5, 0.6, 0.4]$。\n  - 噪声标准差：$\\sigma = 10^{-4}$。\n  - 用于噪声的种子：$77$。\n  - 预期的活动集：下界 $\\{0, 1, 2, 3\\}$，上界为空。\n\n- 用例 #4（单个上界活动，其余自由）：\n  - 维度：$m = 26$, $n = 4$。\n  - 用于 $A$ 的种子：$555$。\n  - 岭参数：$\\lambda = 0.4$。\n  - 界限：$\\ell = [-0.2, -0.2, -0.2, -0.2]$，$u = [0.05, 0.05, 0.05, 0.05]$。\n  - 设计点：$x_\\star = [0.05, -0.1, 0.0, 0.02]$。\n  - 设计的 KKT 残差：$g_\\star = [-0.3, 0.0, 0.0, 0.0]$。\n  - 噪声标准差：$\\sigma = 10^{-4}$。\n  - 用于噪声的种子：$4242$。\n  - 预期的活动集：上界 $\\{0\\}$，下界为空。\n\n求解器与评估要求。\n- 实现一个活动集方法，该方法从一个可行点开始，保持可行性，并在 KKT 条件在容差 $\\epsilon$ 内满足时停止。\n- 通过使用容差 $\\tau$ 进行阈值判断来识别活动集，如下所示：如果 $x_i \\le \\ell_i + \\tau$，则索引 $i$ 被识别为下界活动；如果 $x_i \\ge u_i - \\tau$，则被识别为上界活动。\n- 对每个测试用例，返回一个布尔值，指示识别出的下界活动集是否等于设计的下界活动集，并且识别出的上界活动集是否等于设计的上界活动集。\n\n最终输出格式。\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$[r_1,r_2,r_3,r_4]$），其中每个 $r_i$ 是对应于第 $i$ 个测试用例的布尔值。不应打印任何其他文本。", "solution": "用户提供了一个在凸优化领域中适定（well-posed）的问题。任务是为一类特定的有界约束二次规划（QP）问题推导并实现一个原始活动集方法，并在生成的一组测试用例上验证其性能。\n\n### 步骤 1：提取已知条件\n\n- **问题表述**：最小化带界约束的岭回归目标函数：\n$$\n\\min_{x \\in \\mathbb{R}^n} \\;\\; \\tfrac{1}{2}\\|A x - b\\|_2^2 + \\tfrac{\\lambda}{2}\\|x\\|_2^2 \\quad \\text{subject to} \\quad \\ell \\le x \\le u\n$$\n- **标准 QP 形式**：该问题等价于 $\\min_{x \\in \\mathbb{R}^n} \\;\\; \\tfrac{1}{2} x^\\top Q x + c^\\top x$，其中：\n  - $Q = A^\\top A + \\lambda I$，对于 $\\lambda \\in \\mathbb{R}_{0}$，该矩阵是对称正定的。\n  - $c = -A^\\top b$。\n  - 界限 $\\ell, u \\in \\mathbb{R}^n$ 满足对所有 $i$ 都有 $\\ell_i \\le u_i$。\n- **算法要求**：实现一个从 Karush–Kuhn–Tucker (KKT) 条件推导出的原始可行活动集方法。该方法必须：\n  1. 从一个可行点开始。\n  2. 在每次迭代中保持可行性。\n  3. 将活动界限视为等式约束，并为自由变量求解一个降维 QP。\n  4. 使用最大可行步长。\n  5. 根据 KKT 乘子符号违规情况更新活动集。\n  6. 当 KKT 条件在容差 $\\epsilon$ 内满足时终止。\n- **测试用例构建**：\n  - 使用固定种子生成 $A \\in \\mathbb{R}^{m \\times n}$，其元素来自 $\\mathcal{N}(0,1)$。\n  - $Q = A^\\top A + \\lambda I$。\n  - 给定一个设计好的可行点 $x_\\star$，满足 $\\ell \\le x_\\star \\le u$。\n  - 给定一个设计好的 KKT 残差向量 $g_\\star$，与 $x_\\star$ 的 KKT 符号条件一致。\n  - $c = -g_\\star - Q x_\\star$。\n  - $b = A (A^\\top A)^{-1} (-c)$，即 $A^\\top b = -c$ 的最小范数解。\n  - $\\tilde{b} = b + \\varepsilon$，其中 $\\varepsilon$ 是均值为 $0$、方差为 $\\sigma^2 I$ 的高斯噪声，使用固定种子生成。\n  - 求解器将使用 $\\tilde{c} = -A^\\top \\tilde{b}$。\n- **评估**：\n  - 最终的活动集使用容差 $\\tau$ 来识别：如果 $x_i \\le \\ell_i + \\tau$，则 $x_i$ 是下界活动的；如果 $x_i \\ge u_i - \\tau$，则是上界活动的。\n  - 每个测试用例的结果是一个布尔值，指示识别出的下界和上界活动集是否与从 $x_\\star$ 派生出的设计活动集相匹配。\n- **测试套件**：提供了四个具体的测试用例，包含所有参数：维度 $(m,n)$、种子、$\\lambda$、界限 $(\\ell, u)$、设计点 $x_\\star$、设计残差 $g_\\star$ 和噪声水平 $\\sigma$。\n- **输出格式**：单行 `[r_1,r_2,r_3,r_4]`，其中 $r_i$ 是用例 $i$ 的布尔结果。\n\n### 步骤 2：使用提取的已知条件进行验证\n\n- **科学基础**：该问题是一个标准的有界约束二次规划问题，是数学优化中的一个基本主题。基于岭回归的表述在统计学和机器学习中很常见。KKT 条件的使用是约束优化理论的基石。用已知属性生成测试实例的程序是验证优化求解器的有效和标准的技术。该问题牢固地建立在公认的数学原理之上。\n- **适定性**：条件 $\\lambda  0$ 确保了 Hessian 矩阵 $Q = A^\\top A + \\lambda I$ 是对称正定的，因为 $A^\\top A$ 是半正定的。这使得目标函数是严格凸的。一个严格凸函数在一个闭合的凸可行集（一个超矩形或箱体）上有一个唯一的全局极小值点。因此，该问题是适定的。\n- **客观性**：问题以精确的数学语言陈述。所有参数和程序都得到了明确的定义。没有主观或基于意见的陈述。\n- **完整性**：提供了实现求解器和构建测试用例所需的所有信息，包括维度、种子、参数值和对构建过程的清晰描述。\n- **一致性**：问题陈述在内部是一致的。数学推导是正确的。用例 #1 中的注释澄清了索引，避免了歧义。\n\n### 步骤 3：结论和行动\n\n该问题是有效的。它是一个定义明确、科学合理且自成体系的数值优化任务。我将着手提供一个解决方案。\n\n### 基于原理的解决方案设计\n\n解决方案是实现一个用于有界约束二次规划的原始活动集方法。该设计源于 Karush-Kuhn-Tucker (KKT) 最优性条件。\n\n**1. 最优性条件 (KKT)**\n\n问题是最小化 $f(x) = \\tfrac{1}{2} x^\\top Q x + c^\\top x$，约束条件为 $\\ell_i \\le x_i \\le u_i$，对于 $i=1, \\dots, n$。我们可以将约束写为 $x_i - \\ell_i \\ge 0$ 和 $u_i - x_i \\ge 0$。拉格朗日函数是：\n$$\nL(x, \\mu, \\nu) = f(x) - \\sum_{i=1}^n \\mu_i (x_i - \\ell_i) - \\sum_{i=1}^n \\nu_i (u_i - x_i)\n$$\n其中 $\\mu \\in \\mathbb{R}^n$ 和 $\\nu \\in \\mathbb{R}^n$ 分别是下界和上界的拉格朗日乘子向量。\n\n对于一个点 $x^\\star$ 是最优的，它必须满足 KKT 条件：\n1.  **驻定性**：$\\nabla_x L(x^\\star, \\mu, \\nu) = 0 \\implies Q x^\\star + c - \\mu + \\nu = 0$。\n2.  **原始可行性**：$\\ell \\le x^\\star \\le u$。\n3.  **对偶可行性**：对所有 $i$，$\\mu_i \\ge 0$ 且 $\\nu_i \\ge 0$。\n4.  **互补松弛性**：对所有 $i$，$\\mu_i (x^\\star_i - \\ell_i) = 0$ 且 $\\nu_i (u^\\star_i - x_i) = 0$。\n\n这些条件可以根据目标函数的梯度 $g(x) = \\nabla f(x) = Qx + c$ 来重新表述。\n- 如果一个变量是自由的，即 $\\ell_i  x^\\star_i  u_i$，互补松弛性意味着 $\\mu_i = \\nu_i = 0$。驻定性则要求 $g(x^\\star)_i = 0$。\n- 如果一个变量在其下界上，即 $x^\\star_i = \\ell_i$，互补松弛性意味着 $\\nu_i = 0$。驻定性给出 $g(x^\\star)_i = \\mu_i$。对偶可行性要求 $\\mu_i \\ge 0$，所以 $g(x^\\star)_i \\ge 0$。\n- 如果一个变量在其上界上，即 $x^\\star_i = u_i$，互补松弛性意味着 $\\mu_i = 0$。驻定性给出 $g(x^\\star)_i = -\\nu_i$。对偶可行性要求 $\\nu_i \\ge 0$，所以 $g(x^\\star)_i \\le 0$。\n\n当这些条件在容差 $\\epsilon$ 内满足时，算法将终止。\n\n**2. 原始活动集算法**\n\n算法从一个可行点开始，并全程保持可行性。它通过迭代改进一个被视为活动的（即保持为等式的）约束的“工作集” $\\mathcal{W}$。工作集被划分为下界活动索引 $\\mathcal{L}$ 和上界活动索引 $\\mathcal{U}$。\n\n- **初始化**：从一个可行点 $x^{(0)}$ 开始，例如，通过将原点投影到可行箱体上得到的点：$x^{(0)}_i = \\max(\\ell_i, \\min(u_i, 0))$。初始工作集 $\\mathcal{W}^{(0)}$ 由所有 $x^{(0)}_i$ 恰好在其界限上的索引 $i$ 组成。\n\n- **迭代 $k$**：给定迭代点 $x^{(k)}$ 和工作集 $\\mathcal{W}^{(k)} = \\mathcal{L}^{(k)} \\cup \\mathcal{U}^{(k)}$。其余索引构成自由集 $\\mathcal{F}^{(k)}$。\n\n    1.  **求解子问题以获得搜索方向**：我们寻找一个搜索方向 $p$，使得 $x^{(k+1)} = x^{(k)} + p$ 能够改进目标函数，同时遵守活动约束。对于 $i \\in \\mathcal{W}^{(k)}$，我们强制 $p_i = 0$。对于自由变量 $i \\in \\mathcal{F}^{(k)}$，我们关于 $p_{\\mathcal{F}}$ 最小化二次目标。通过将关于自由变量的梯度设为零来找到最小值：$(Q(x^{(k)}+p)+c)_{\\mathcal{F}} = 0$。这产生了关于搜索方向自由分量的线性系统：\n        $$\n        Q_{\\mathcal{F}\\mathcal{F}} p_{\\mathcal{F}} = -(Qx^{(k)} + c)_{\\mathcal{F}}\n        $$\n        其中 $Q_{\\mathcal{F}\\mathcal{F}}$ 是 $Q$ 对应于自由索引的主子矩阵。由于 $Q$ 是对称正定的，所以 $Q_{\\mathcal{F}\\mathcal{F}}$ 也是，这保证了 $p_{\\mathcal{F}}$ 有唯一解。\n\n    2.  **最优性检查**：如果子问题的解产生一个接近零的搜索方向，即 $\\|p_{\\mathcal{F}}\\| \\le \\epsilon_p$（一个小的容差），这意味着 $x^{(k)}$ 对于当前的自由集 $\\mathcal{F}^{(k)}$ 是最优的。然后我们必须检查活动集 $\\mathcal{W}^{(k)}$ 上的 KKT 符号条件。拉格朗日乘子由梯度分量给出：对于 $i \\in \\mathcal{L}^{(k)}$，$\\mu_i = (Qx^{(k)}+c)_i$；对于 $i \\in \\mathcal{U}^{(k)}$，$\\nu_i = -(Qx^{(k)}+c)_i$。\n        - 如果对所有 $i \\in \\mathcal{L}^{(k)}$ 都有 $\\mu_i \\ge -\\epsilon$，并且对所有 $i \\in \\mathcal{U}^{(k)}$ 都有 $\\nu_i \\ge -\\epsilon$（即，对 $i \\in \\mathcal{U}^{(k)}$ 有 $(Qx^{(k)}+c)_i \\le \\epsilon$），则 KKT 条件得到满足，算法终止。\n        - 否则，在 $\\mathcal{W}^{(k)}$ 中存在一个可以被放松以进一步降低目标的约束。我们识别出对应于最违反乘子（例如，最大的负 $\\mu_j$ 或最大的负 $\\nu_j$）的索引 $j$，并将其从工作集中移除。迭代点 $x^{(k)}$ 保持不变，过程以更新后的工作集继续。\n\n    3.  **步长计算**：如果 $\\|p_{\\mathcal{F}}\\|  \\epsilon_p$，我们从 $x^{(k)}$ 沿着方向 $p$ 移动。为保持可行性，步长 $\\alpha$ 的选择必须使得 $\\ell \\le x^{(k)} + \\alpha p \\le u$。无约束的最优步长是 $\\alpha=1$。因此，我们计算最大可行步长 $\\alpha_{\\max}$：\n        $$\n        \\alpha_{\\max} = \\min \\left( \\{1.0\\} \\cup \\{\\tfrac{u_i - x^{(k)}_i}{p_i} \\mid i \\in \\mathcal{F}^{(k)}, p_i  0 \\} \\cup \\{\\tfrac{\\ell_i - x^{(k)}_i}{p_i} \\mid i \\in \\mathcal{F}^{(k)}, p_i  0 \\} \\right)\n        $$\n        新的迭代点是 $x^{(k+1)} = x^{(k)} + \\alpha_{\\max}p$。\n\n    4.  **更新工作集**：如果 $\\alpha_{\\max}  1$，这意味着步长被一个或多个非活动约束所阻塞。这些新“阻塞”约束的索引将被添加到下一次迭代的工作集 $\\mathcal{W}$ 中。\n\n这个过程重复进行，直到找到最优点。问题的严格凸性和对工作集的系统管理确保了算法在有限步数内终止于唯一的全局解。\n\n**3. 容差的理由**\n\n- **KKT 容差 ($\\epsilon = 10^{-8}$)**：此容差用于验证一阶最优性条件，这些条件涉及检查梯度的分量是否为零（对于自由变量）或具有正确的符号（对于活动变量）。鉴于使用双精度浮点运算，检查精确的零是不切实际的。$10^{-8}$ 的值是一个标准且稳健的选择，它在数值精度和实际收敛之间取得了平衡。\n- **活动集识别容差 ($\\tau = 10^{-6}$)**：此容差在求解后用于分类最终解向量中的哪些变量位于其界限上。这是一个实用的阈值。它需要大于数值噪声，但又要足够小以具有意义。$10^{-6}$ 的值可以正确捕捉求解器已驱动至界限的变量，同时允许迭代数值方法固有的小偏差，这些方法基于 KKT 容差 $\\epsilon$ 终止。\n- **步长容差 ($\\epsilon_p = 10^{-12}$)**：此容差用于确定在子空间中计算出的搜索方向是否实际上为零。一个接近机器精度的值（相对于问题的尺度）是合适的，因为它表示迭代点在当前自由变量集合内是静止的。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the active-set QP solver.\n    \"\"\"\n    \n    test_cases = [\n        # Case #1 (happy path, mixed activity)\n        {\n            \"m\": 30, \"n\": 4, \"seed_A\": 123, \"lambda\": 0.5,\n            \"l\": np.array([0.0, 0.0, 0.0, 0.0]),\n            \"u\": np.array([0.3, 0.2, 0.5, 0.1]),\n            \"x_star\": np.array([0.3, 0.0, 0.2, 0.1]),\n            \"g_star\": np.array([-0.6, 0.4, 0.0, -0.5]),\n            \"sigma\": 1e-4, \"seed_noise\": 999,\n        },\n        # Case #2 (interior solution, no activity)\n        {\n            \"m\": 25, \"n\": 4, \"seed_A\": 321, \"lambda\": 0.3,\n            \"l\": np.array([-1.0, -1.0, -1.0, -1.0]),\n            \"u\": np.array([1.0, 1.0, 1.0, 1.0]),\n            \"x_star\": np.array([0.2, -0.3, 0.1, 0.05]),\n            \"g_star\": np.array([0.0, 0.0, 0.0, 0.0]),\n            \"sigma\": 1e-4, \"seed_noise\": 1001,\n        },\n        # Case #3 (all lower bounds active)\n        {\n            \"m\": 28, \"n\": 4, \"seed_A\": 222, \"lambda\": 0.2,\n            \"l\": np.array([0.0, 0.0, 0.0, 0.0]),\n            \"u\": np.array([1.0, 1.0, 1.0, 1.0]),\n            \"x_star\": np.array([0.0, 0.0, 0.0, 0.0]),\n            \"g_star\": np.array([0.7, 0.5, 0.6, 0.4]),\n            \"sigma\": 1e-4, \"seed_noise\": 77,\n        },\n        # Case #4 (single upper bound active, others free)\n        {\n            \"m\": 26, \"n\": 4, \"seed_A\": 555, \"lambda\": 0.4,\n            \"l\": np.array([-0.2, -0.2, -0.2, -0.2]),\n            \"u\": np.array([0.05, 0.05, 0.05, 0.05]),\n            \"x_star\": np.array([0.05, -0.1, 0.0, 0.02]),\n            \"g_star\": np.array([-0.3, 0.0, 0.0, 0.0]),\n            \"sigma\": 1e-4, \"seed_noise\": 4242,\n        }\n    ]\n\n    results = []\n\n    def solve_qp_active_set(Q, c, l, u, x0, max_iter=100, kkt_tol=1e-8, step_tol=1e-12):\n        \"\"\"\n        Solves a bound-constrained QP using a primal active-set method.\n        min 1/2 x'Qx + c'x  s.t. l = x = u\n        \"\"\"\n        n = len(c)\n        x = np.copy(x0)\n        x = np.maximum(l, np.minimum(x, u)) # Ensure initial feasibility\n\n        # Using a small tolerance to initialize the active set robustly\n        active_L = {i for i in range(n) if x[i] = l[i] + step_tol}\n        active_U = {i for i in range(n) if x[i] >= u[i] - step_tol}\n\n        for _ in range(max_iter):\n            free_indices = sorted(list(set(range(n)) - active_L - active_U))\n            g = Q @ x + c\n            \n            p = np.zeros(n)\n            is_subspace_optimal = True\n\n            if free_indices:\n                Q_FF = Q[np.ix_(free_indices, free_indices)]\n                g_F = g[free_indices]\n                try:\n                    p_F = np.linalg.solve(Q_FF, -g_F)\n                    if np.linalg.norm(p_F) > step_tol:\n                        p[free_indices] = p_F\n                        is_subspace_optimal = False\n                except np.linalg.LinAlgError:\n                    # Should not occur with SPD Q, but treat as optimal in subspace if it does\n                    pass\n\n            if is_subspace_optimal:\n                # Check KKT multipliers on the active set\n                violations = {}\n                for i in active_L:\n                    if g[i]  -kkt_tol:\n                        violations[i] = -g[i] # Store violation magnitude\n                for i in active_U:\n                    if g[i] > kkt_tol:\n                        violations[i] = g[i]\n\n                if not violations:\n                    # Check free set gradient components\n                    if not free_indices or np.all(np.abs(g[free_indices]) = kkt_tol):\n                        return x  # KKT conditions met, optimal solution found\n\n                # Release the most violating constraint\n                if violations:\n                    idx_to_release = max(violations, key=violations.get)\n                    if idx_to_release in active_L:\n                        active_L.remove(idx_to_release)\n                    else: # in active_U\n                        active_U.remove(idx_to_release)\n                # Continue to next iteration with modified working set\n                continue\n\n            # Take a step along p\n            alpha = 1.0\n            \n            for i in free_indices:\n                if p[i] > 1e-12: # Check for positive direction\n                    alpha = min(alpha, (u[i] - x[i]) / p[i])\n                elif p[i]  -1e-12: # Check for negative direction\n                    alpha = min(alpha, (l[i] - x[i]) / p[i])\n\n            x += alpha * p\n\n            # Update active set with any new blocking constraints\n            for i in free_indices:\n                if alpha  1.0:\n                    if x[i] >= u[i] - step_tol:\n                        active_U.add(i)\n                    if x[i] = l[i] + step_tol:\n                        active_L.add(i)\n\n        return x # Return current solution if max_iter is reached\n\n    for case in test_cases:\n        m, n, seed_A, lam = case[\"m\"], case[\"n\"], case[\"seed_A\"], case[\"lambda\"]\n        l, u, x_star, g_star = case[\"l\"], case[\"u\"], case[\"x_star\"], case[\"g_star\"]\n        sigma, seed_noise = case[\"sigma\"], case[\"seed_noise\"]\n\n        # 1. Construct the QP instance without noise\n        rng_A = np.random.default_rng(seed_A)\n        A = rng_A.standard_normal((m, n))\n        Q = A.T @ A + lam * np.eye(n)\n        \n        c = -g_star - (Q @ x_star)\n        \n        # Calculate b such that c = -A'b\n        # We need the min-norm solution of A'b = -c\n        # b = A * (A'A)^(-1) * (-c)\n        y = np.linalg.solve(A.T @ A, -c)\n        b = A @ y\n\n        # 2. Add noise to b\n        rng_noise = np.random.default_rng(seed_noise)\n        noise = rng_noise.normal(0, sigma, size=m)\n        b_tilde = b + noise\n\n        # 3. Define the QP to be solved (with noisy data)\n        c_tilde = -A.T @ b_tilde\n\n        # 4. Set initial point for the solver\n        x0 = np.zeros(n)\n\n        # 5. Solve the QP\n        x_sol = solve_qp_active_set(Q, c_tilde, l, u, x0)\n        \n        # 6. Evaluate the result\n        tau = 1e-6\n        \n        # Designed active sets from x_star\n        designed_lower_active = {i for i in range(n) if np.isclose(x_star[i], l[i])}\n        designed_upper_active = {i for i in range(n) if np.isclose(x_star[i], u[i])}\n\n        # Found active sets from solver's solution\n        found_lower_active = {i for i in range(n) if x_sol[i] = l[i] + tau}\n        found_upper_active = {i for i in range(n) if x_sol[i] >= u[i] - tau}\n\n        # Compare and store result\n        is_correct = (designed_lower_active == found_lower_active) and \\\n                     (designed_upper_active == found_upper_active)\n        results.append(is_correct)\n\n    # Final print statement\n    print(f\"[{','.join(str(r).lower() for r in results)}]\")\n\nsolve()\n```", "id": "3094679"}]}