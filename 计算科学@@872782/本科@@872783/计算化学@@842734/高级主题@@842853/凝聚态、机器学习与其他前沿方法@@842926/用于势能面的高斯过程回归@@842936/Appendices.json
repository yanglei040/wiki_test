{"hands_on_practices": [{"introduction": "为了掌握高斯过程回归的核心，我们首先从一个简单的二维解析势能面着手。这个练习将直观地展示GPR模型的预测准确性如何严重依赖于训练数据点的分布，特别是我们感兴趣的区域附近是否有数据点。通过对比在过渡态鞍点附近有无采样点时的预测结果，我们将深刻理解在数据驱动建模中，可靠的内插和不确定的外推之间的关键区别。[@problem_id:2455992]", "problem": "给定一个由解析函数定义的二维势能面（PES），其单位为无量纲单位\n$$\nV(x,y) = (x^2 - 1)^2 + a\\, y^2,\n$$\n其中参数 $a = 0.5$。该势能面在 $(x,y) = (-1,0)$ 和 $(x,y) = (1,0)$ 附近有两个极小值点，并在 $(x,y) = (0,0)$ 处有一个能量为 $V(0,0) = 1$ 的一阶鞍点。考虑对势能面值使用零均值高斯过程（GP）先验，其协方差核为平方指数核\n$$\nk(\\mathbf{r}, \\mathbf{r}') = \\sigma_f^2 \\exp\\!\\left(-\\tfrac{1}{2}\\sum_{i=1}^{2} \\frac{(r_i - r'_i)^2}{\\ell^2}\\right),\n$$\n其中 $\\mathbf{r} = (x,y)$，$\\ell$ 是一个各向同性长度尺度，$\\sigma_f$ 是信号振幅。假设能量值上叠加了独立同分布的高斯观测噪声，其方差为 $\\sigma_n^2$。在查询点 $\\mathbf{r}_\\star$ 处，GP 的后验预测均值由标准高斯条件公式定义，该公式涉及训练输入的核矩阵、训练输入与 $\\mathbf{r}_\\star$ 之间的交叉核向量以及观测到的能量。\n\n您的任务是实现一个程序，在以下四种测试用例下，计算鞍点 $\\mathbf{r}_\\star = (0,0)$ 处的 GP 后验预测均值。程序需使用上述精确的 PES 生成无噪声的训练能量。所有量均为无量纲。除非另有说明，否则使用固定的超参数 $\\sigma_f = 1$ 和 $\\sigma_n^2 = 10^{-12}$。长度尺度 $\\ell$ 将在下面的每个测试用例中指定。\n\n在所有情况下，均需将 PES 参数 $a$ 精确定义为上述的 $0.5$。\n\n必须严格按照列表使用训练输入。对于每个训练输入 $(x_j,y_j)$，使用给定的解析表达式计算训练目标 $V(x_j,y_j)$。\n\n测试用例 1（无鞍点附近采样）：\n- 长度尺度：$\\ell = 0.4$。\n- 训练输入（$(x,y)$ 列表）：\n  - $(-1, 0)$, $(1, 0)$,\n  - $(-1, 0.5)$, $(1, 0.5)$, $(-1, -0.5)$, $(1, -0.5)$,\n  - $(0.9, 0)$, $(-0.9, 0)$,\n  - $(-0.75, 0.8)$, $(0.75, -0.8)$.\n- 任务：预测 $(0,0)$ 处的 GP 后验均值。\n\n测试用例 2（有鞍点附近采样）：\n- 长度尺度：$\\ell = 0.4$。\n- 训练输入：测试用例 1 中的所有点，外加额外的点 $(0.1, 0)$, $(-0.1, 0)$, $(0, 0.1)$, $(0, -0.1)$。\n- 任务：预测 $(0,0)$ 处的 GP 后验均值。\n\n测试用例 3（边界情况：极短相关长度且无鞍点附近采样）：\n- 长度尺度：$\\ell = 0.1$。\n- 训练输入：与测试用例 1 相同。\n- 任务：预测 $(0,0)$ 处的 GP 后验均值。\n\n测试用例 4（边界情况：在鞍点处精确观测）：\n- 长度尺度：$\\ell = 0.4$。\n- 训练输入：测试用例 1 中的所有点，外加精确的鞍点 $(0,0)$。\n- 任务：预测 $(0,0)$ 处的 GP 后验均值。\n\n程序输入：无外部输入；所有数据均在此处指定。程序输出：您的程序应生成单行输出，其中包含按测试用例 1、2、3、4 的顺序排列的结果，形式为用方括号括起来的逗号分隔列表。每个数字必须是相应测试用例在 $(0,0)$ 处的后验预测均值，四舍五入到 6 位小数。例如：“[m1,m2,m3,m4]”。\n\n您的程序必须使用上述定义从第一性原理出发计算所有量。所有能量必须以指定的无量纲单位计算，此处出现的任何角度（若有）均不相关。最终输出为浮点数。这四个测试用例套件涵盖了：无局部数据时的一般预测、有邻近数据时的改进预测、无邻近数据时极短相关长度的影响，以及当查询点本身就是训练输入时的极限情况。", "solution": "问题陈述已经过严格验证，被认定为科学上合理、问题定义明确且无矛盾。它提出了一个标准且明确定义的练习，即应用高斯过程回归来建模势能面，这是计算化学中的一项常见任务。因此，我们将着手提供一个符合原理的完整解法。\n\n目标是计算高斯过程（GP）模型在给定二维势能面（PES）的特定查询点，即鞍点 $\\mathbf{r}_\\star = (0,0)$ 处的后验预测均值。该解法源于应用于函数空间的贝叶斯推断基本原理。\n\nPES 由以下解析函数定义：\n$$\nV(\\mathbf{r}) = (x^2 - 1)^2 + a y^2\n$$\n其中 $\\mathbf{r} = (x,y)$，参数 $a$ 固定为 $a=0.5$。鞍点 $\\mathbf{r}_\\star = (0,0)$ 处的真实能量为 $V(0,0) = (0^2-1)^2 + 0.5(0^2) = 1$。\n\n我们使用零均值高斯过程 $f(\\mathbf{r}) \\sim \\mathcal{GP}(0, k(\\mathbf{r}, \\mathbf{r}'))$ 对 PES 进行建模。任意两点 $\\mathbf{r}$ 和 $\\mathbf{r}'$ 处函数值之间的协方差由平方指数核给出：\n$$\nk(\\mathbf{r}, \\mathbf{r}') = \\sigma_f^2 \\exp\\!\\left(-\\frac{\\|\\mathbf{r} - \\mathbf{r}'\\|^2}{2\\ell^2}\\right)\n$$\n此处，$\\|\\mathbf{r} - \\mathbf{r}'\\|^2$ 是欧氏距离的平方，$\\sigma_f$ 是信号振幅，$\\ell$ 是特征长度尺度。问题指定 $\\sigma_f = 1$。\n\n我们给定一组包含 $N$ 个训练输入的集合 $\\mathbf{X} = \\{\\mathbf{r}_1, \\ldots, \\mathbf{r}_N\\}$ 以及对应的无噪声训练目标 $\\mathbf{y} = \\{y_1, \\ldots, y_N\\}$，其中 $y_j = V(\\mathbf{r}_j)$。尽管训练目标是无噪声的，但模型包含一个方差为 $\\sigma_n^2$ 的观测噪声项，这是确保数值稳定性的标准技术。在测试点 $\\mathbf{r}_\\star$ 处，以训练数据 $(\\mathbf{X}, \\mathbf{y})$ 为条件的函数值 $f_\\star = f(\\mathbf{r}_\\star)$ 的后验分布也是一个高斯分布。其均值，也就是我们所求的量，由 GP 回归方程给出：\n$$\n\\bar{f}_\\star = \\mathbf{k}_\\star^T (K + \\sigma_n^2 I)^{-1} \\mathbf{y}\n$$\n其中：\n- $K$ 是训练输入的 $N \\times N$ 格拉姆矩阵，其元素为 $K_{ij} = k(\\mathbf{r}_i, \\mathbf{r}_j)$。\n- $\\mathbf{k}_\\star$ 是训练输入与测试点之间的 $N \\times 1$ 协方差向量，其元素为 $(\\mathbf{k}_\\star)_i = k(\\mathbf{r}_i, \\mathbf{r}_\\star)$。\n- $I$ 是 $N \\times N$ 单位矩阵。\n- $\\sigma_n^2$ 是噪声方差，指定为 $10^{-12}$。这个小值通常被称为“块金值”（nugget），它对矩阵 $K$ 进行正则化，保证其可逆性。\n\n计算流程如下：\n1.  对于每个测试用例，整合指定的训练输入 $\\mathbf{X}$ 和固定的超参数 $\\ell$、$\\sigma_f$ 和 $\\sigma_n^2$。\n2.  通过在每个训练输入 $\\mathbf{r}_j \\in \\mathbf{X}$ 上评估函数 $V(\\mathbf{r})$ 来计算训练目标 $\\mathbf{y}$。\n3.  通过计算所有训练输入对的 $k(\\mathbf{r}_i, \\mathbf{r}_j)$ 来构建核矩阵 $K$。\n4.  通过计算所有训练输入 $\\mathbf{r}_i$ 相对于查询点 $\\mathbf{r}_\\star=(0,0)$ 的 $k(\\mathbf{r}_i, \\mathbf{r}_\\star)$ 来构建交叉协方差向量 $\\mathbf{k}_\\star$。\n5.  我们不进行显式的矩阵求逆（这在数值上不稳定），而是求解更稳定的线性系统 $(K + \\sigma_n^2 I) \\boldsymbol{\\alpha} = \\mathbf{y}$ 来得到权重向量 $\\boldsymbol{\\alpha}$。\n6.  然后，后验均值通过内积 $\\bar{f}_\\star = \\mathbf{k}_\\star^T \\boldsymbol{\\alpha}$ 计算得出。\n\n此流程将应用于四个指定的测试用例，这些用例旨在探究 GP 回归的不同方面：\n- **测试用例 1** 建立一个基线预测，其中训练数据与查询点相对较远。该预测将是训练目标的加权平均值，权重随距离衰减，并被拉向先验均值 $0$。\n- **测试用例 2** 展示了在查询点附近添加局部数据的效果。预期这些新信息将主导预测，使后验均值更接近真实值 $V(0,0) = 1$。\n- **测试用例 3** 探究了极短相关长度 $\\ell$ 的影响。这使得模型假设函数变化迅速，因此远处训练点的影响急剧减小。在 $(0,0)$ 处的预测将更强烈地回归到先验均值 $0$。\n- **测试用例 4** 验证了 GP 的插值行为。通过将查询点 $(0,0)$ 包含在训练集中，模型被约束为非常接近观测值 $V(0,0)=1$，任何偏差都是小的正则化项 $\\sigma_n^2$ 的结果。结果应该非常接近 $1$。\n\n实现将严格遵循这一经过验证的方法论。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Gaussian Process Regression problem for four test cases.\n    \"\"\"\n\n    # --- Problem Definition ---\n\n    # PES analytic function V(x,y)\n    a_param = 0.5\n    def v_pes(r):\n        x, y = r\n        return (x**2 - 1)**2 + a_param * y**2\n\n    # Squared-exponential kernel function k(r, r')\n    def kernel(r1, r2, sigma_f, ell):\n        dist_sq = np.sum((np.array(r1) - np.array(r2))**2)\n        return sigma_f**2 * np.exp(-dist_sq / (2 * ell**2))\n\n    # --- Fixed Parameters ---\n    sigma_f_val = 1.0\n    sigma_n_sq_val = 1e-12\n    r_star = np.array([0.0, 0.0])\n\n    # --- Test Case Definitions ---\n    train_inputs_case1 = [\n        (-1.0, 0.0), (1.0, 0.0),\n        (-1.0, 0.5), (1.0, 0.5), (-1.0, -0.5), (1.0, -0.5),\n        (0.9, 0.0), (-0.9, 0.0),\n        (-0.75, 0.8), (0.75, -0.8)\n    ]\n\n    train_inputs_case2 = train_inputs_case1 + [\n        (0.1, 0.0), (-0.1, 0.0), (0.0, 0.1), (0.0, -0.1)\n    ]\n\n    train_inputs_case4 = train_inputs_case1 + [(0.0, 0.0)]\n\n    test_cases = [\n        {\"ell\": 0.4, \"train_inputs\": train_inputs_case1},\n        {\"ell\": 0.4, \"train_inputs\": train_inputs_case2},\n        {\"ell\": 0.1, \"train_inputs\": train_inputs_case1},\n        {\"ell\": 0.4, \"train_inputs\": train_inputs_case4},\n    ]\n\n    # --- Main Calculation Loop ---\n    results = []\n    for case in test_cases:\n        ell_val = case[\"ell\"]\n        train_inputs = np.array(case[\"train_inputs\"])\n        n_train = len(train_inputs)\n\n        # 1. Generate training targets y\n        y_train = np.array([v_pes(r) for r in train_inputs])\n\n        # 2. Construct kernel matrix K\n        K = np.zeros((n_train, n_train))\n        for i in range(n_train):\n            for j in range(n_train):\n                K[i, j] = kernel(train_inputs[i], train_inputs[j], sigma_f_val, ell_val)\n        \n        # 3. Add regularization term\n        K_reg = K + sigma_n_sq_val * np.identity(n_train)\n        \n        # 4. Construct cross-kernel vector k_star\n        k_star = np.array([kernel(r, r_star, sigma_f_val, ell_val) for r in train_inputs])\n        \n        # 5. Solve for weights alpha\n        alpha = np.linalg.solve(K_reg, y_train)\n        \n        # 6. Compute posterior mean\n        mean_prediction = np.dot(k_star, alpha)\n        \n        results.append(mean_prediction)\n\n    # Round results to 6 decimal places for the final output\n    rounded_results = [round(res, 6) for res in results]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, rounded_results))}]\")\n\nsolve()\n```", "id": "2455992"}, {"introduction": "真实的分子系统通常包含多种不同物理特性的内部坐标，例如键的伸缩和二面角的扭转。本次实践将引导我们如何通过组合不同的核函数——一个用于键长的平方指数核和一个用于二面角的周期核——来构建一个复合核函数，从而创建一个更符合物理直觉的模型。这是为真实分子体系构建精确GPR-PES模型的关键一步，它展示了GPR框架的灵活性。[@problem_id:2456000]", "problem": "您正在为一个分子碎片建模一个约化势能面，该势能面由两个键伸缩和一个二面角描述。令每个构型由描述符向量 $\\mathbf{x} = (r_1, r_2, \\phi)$ 表示，其中 $r_1$ 和 $r_2$ 是以 $\\text{\\AA}$ 为单位的键长，$\\phi$ 是以弧度为单位的二面角。您将假设一个零均值的高斯过程先验和一个复合核函数，该核函数是键伸缩上的平方指数项和二面角上的周期项之和：\n$$\nk(\\mathbf{x},\\mathbf{x}') \\equiv k_{\\mathrm{SE}}(\\mathbf{x},\\mathbf{x}') + k_{\\mathrm{Per}}(\\mathbf{x},\\mathbf{x}'),\n$$\n其中\n$$\nk_{\\mathrm{SE}}(\\mathbf{x},\\mathbf{x}') = \\sigma_s^2 \\exp\\left(-\\tfrac{1}{2}\\sum_{i=1}^{2}\\left(\\frac{r_i - r_i'}{\\ell_s}\\right)^2\\right),\n$$\n并且\n$$\nk_{\\mathrm{Per}}(\\mathbf{x},\\mathbf{x}') = \\sigma_p^2 \\exp\\left(-\\frac{2\\sin^2\\left(\\tfrac{\\phi - \\phi'}{2}\\right)}{\\ell_p^2}\\right).\n$$\n使用超参数 $\\sigma_s = 2.5$ $\\text{eV}$，$\\ell_s = 0.2$ $\\text{\\AA}$，$\\sigma_p = 0.4$ $\\text{eV}$，以及 $\\ell_p = 0.5$（在弧度中无量纲）。假设观测噪声是独立同分布的，其方差为 $\\sigma_n^2$，其中 $\\sigma_n = 0.02$ $\\text{eV}$。\n\n观测到的训练能量由一个受物理启发的参考能量函数生成，该函数由两个相同的 Morse 键项和一个扭转项组成：\n$$\nE_{\\mathrm{ref}}(r_1,r_2,\\phi) = \\sum_{i=1}^{2}\\left[D\\left(1 - e^{-a(r_i - r_0)}\\right)^2 - D\\right] + V_0\\left(1 - \\cos(n\\phi)\\right),\n$$\n参数为 $D = 4.5$ $\\text{eV}$，$a = 1.7$ $\\text{\\AA}^{-1}$，$r_0 = 1.09$ $\\text{\\AA}$，$V_0 = 0.18$ $\\text{eV}$，以及 $n = 3$。训练输入 $\\{\\mathbf{x}_j\\}_{j=1}^{N}$ 和对应的输出 $\\{y_j\\}_{j=1}^{N}$ 由 $y_j = E_{\\mathrm{ref}}(\\mathbf{x}_j)$ 在以下 $N = 5$ 个构型上定义（单位：$r$ 以 $\\text{\\AA}$ 计，$\\phi$ 以弧度计）：\n- $\\mathbf{x}_1 = (r_0, r_0, 0.0)$,\n- $\\mathbf{x}_2 = (r_0 + 0.1, r_0, 0.5)$,\n- $\\mathbf{x}_3 = (r_0, r_0 + 0.15, 1.0)$,\n- $\\mathbf{x}_4 = (r_0 + 0.2, r_0 + 0.2, 2.0)$,\n- $\\mathbf{x}_5 = (r_0 - 0.1, r_0, 3.0)$.\n\n假设一个零均值的高斯过程先验，其协方差函数为如上所述的 $k(\\cdot,\\cdot)$，以及一个带有方差为 $\\sigma_n^2$ 的加性高斯噪声的似然。令测试输入为以下 $M = 4$ 个构型（单位：$r$ 以 $\\text{\\AA}$ 计，$\\phi$ 以弧度计）：\n- $\\mathbf{x}_1^\\star = (r_0, r_0, 0.0)$,\n- $\\mathbf{x}_2^\\star = (r_0, r_0, \\pi)$,\n- $\\mathbf{x}_3^\\star = (r_0 + 0.3, r_0, -\\pi)$,\n- $\\mathbf{x}_4^\\star = (r_0 + 0.05, r_0 + 0.05, 1.0)$.\n\n计算高斯过程在每个测试输入处的后验预测均值，其定义为在具有指定核函数和噪声方差的联合多元正态模型下，给定训练数据时预测能量的条件期望。所有预测能量以 $\\text{eV}$ 表示。不允许使用角度制；所有角度必须以弧度表示。\n\n您的程序必须严格实现上述规范，使用给定的超参数和由 $E_{\\mathrm{ref}}$ 生成的训练数据。测试套件包含上述 $M = 4$ 个测试构型，并涵盖以下情况：一个与训练构型重合的点，一个在 $\\phi = \\pi$ 处的最大交错二面角，一个在 $\\phi = -\\pi$ 处的周期性包裹，以及一个具有中等二面角的小的对称键伸缩。要求的输出是 $M = 4$ 个后验均值预测，以 $\\text{eV}$ 为单位的实数表示。\n\n最终输出格式：您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表，其中每个值都四舍五入到恰好 $6$ 位小数，例如 $[x_1,x_2,x_3,x_4]$，其中每个 $x_i$ 是一个表示能量（单位为 $\\text{eV}$）的十进制数。", "solution": "所述问题是高斯过程回归（GPR）在模拟分子势能面方面一个定义明确的标准应用。它在科学上是合理的，在数学上是一致的，并包含了获得唯一解所需的所有信息。我们将着手进行推导。\n\n基本任务是在给定一组训练数据的情况下，计算高斯过程（GP）在一组测试点上的后验预测均值。GP 定义了函数上的一个分布，在此背景下，我们将势能 $E$ 建模为分子构型 $\\mathbf{x}$ 的函数，使得 $E(\\mathbf{x}) \\sim \\mathcal{GP}(m(\\mathbf{x}), k(\\mathbf{x}, \\mathbf{x}'))$。\n\n问题指定了零均值函数 $m(\\mathbf{x}) = 0$ 和复合协方差函数（核函数）$k(\\mathbf{x}, \\mathbf{x}')$。观测值（用 $y$ 表示）被假定为真实能量函数 $E(\\mathbf{x})$ 的带噪声的测量，即 $y = E(\\mathbf{x}) + \\epsilon$，其中噪声 $\\epsilon$ 从一个独立同分布的高斯分布中抽取，其均值为零，方差为 $\\sigma_n^2$，即 $\\epsilon \\sim \\mathcal{N}(0, \\sigma_n^2)$。\n\n设训练数据为一组 $N$ 个构型 $X = \\{\\mathbf{x}_j\\}_{j=1}^{N}$ 及其对应的观测能量 $\\mathbf{y} = \\{y_j\\}_{j=1}^{N}$。设测试数据为一组 $M$ 个构型 $X_* = \\{\\mathbf{x}_i^\\star\\}_{i=1}^{M}$，我们希望预测其能量 $\\mathbf{E}_* = \\{E(\\mathbf{x}_i^\\star)\\}_{i=1}^M$。\n\n在 GP 模型下，观测到的训练输出 $\\mathbf{y}$ 和测试点处的潜在函数值 $\\mathbf{E}_*$ 的联合分布是一个多元高斯分布：\n$$\n\\begin{pmatrix} \\mathbf{y} \\\\ \\mathbf{E}_* \\end{pmatrix} \\sim \\mathcal{N}\\left(\n\\begin{pmatrix} \\mathbf{0} \\\\ \\mathbf{0} \\end{pmatrix},\n\\begin{pmatrix}\nK(X, X) + \\sigma_n^2 I  K(X, X_*) \\\\\nK(X_*, X)  K(X_*, X_*)\n\\end{pmatrix}\n\\right)\n$$\n此处，$K(X, X)$ 是在所有训练点对上求值的 $N \\times N$ 协方差矩阵，其元素为 $(K(X, X))_{ij} = k(\\mathbf{x}_i, \\mathbf{x}_j)$。类似地，$K(X_*, X)$ 是 $M \\times N$ 矩阵，其元素为 $(K(X_*, X))_{ij} = k(\\mathbf{x}_i^\\star, \\mathbf{x}_j)$，而 $K(X_*, X_*)$ 是测试点上的 $M \\times M$ 协方差矩阵。$I$ 是 $N \\times N$ 单位矩阵。\n\n后验预测分布 $p(\\mathbf{E}_* | X, \\mathbf{y}, X_*)$ 也是高斯分布。其均值（即我们所求的量）由条件高斯分布的标准公式给出：\n$$\n\\bar{\\mathbf{E}}_* = \\mathbb{E}[\\mathbf{E}_* | X, \\mathbf{y}, X_*] = K(X_*, X) \\left[K(X, X) + \\sigma_n^2 I\\right]^{-1} \\mathbf{y}\n$$\n求解过程包括三个主要步骤：\n\n1.  **生成训练数据：** 训练输出 $\\mathbf{y}$ 没有直接给出，必须使用参考能量函数 $E_{\\mathrm{ref}}(r_1, r_2, \\phi)$ 对每个训练输入 $\\mathbf{x}_j$ 进行计算。\n    该函数为：\n    $$\n    E_{\\mathrm{ref}}(r_1,r_2,\\phi) = \\sum_{i=1}^{2}\\left[D\\left(1 - e^{-a(r_i - r_0)}\\right)^2 - D\\right] + V_0\\left(1 - \\cos(n\\phi)\\right)\n    $$\n    参数为 $D = 4.5\\ \\text{eV}$，$a = 1.7\\ \\text{\\AA}^{-1}$，$r_0 = 1.09\\ \\text{\\AA}$，$V_0 = 0.18\\ \\text{eV}$，以及 $n=3$。我们为给定的 $N=5$ 个训练构型计算 $y_j = E_{\\mathrm{ref}}(\\mathbf{x}_j)$。\n\n2.  **构建核矩阵：** 我们必须构建协方差矩阵 $K(X, X)$ 和 $K(X_*, X)$。核函数是两个键长 $(r_1, r_2)$ 的平方指数项和二面角 $\\phi$ 的周期项之和：\n    $$\n    k(\\mathbf{x}, \\mathbf{x}') = \\sigma_s^2 \\exp\\left(-\\frac{1}{2\\ell_s^2}\\sum_{i=1}^{2}(r_i - r_i')^2\\right) + \\sigma_p^2 \\exp\\left(-\\frac{2\\sin^2\\left(\\tfrac{\\phi - \\phi'}{2}\\right)}{\\ell_p^2}\\right)\n    $$\n    给定的超参数为 $\\sigma_s = 2.5\\ \\text{eV}$，$\\ell_s = 0.2\\ \\text{\\AA}$，$\\sigma_p = 0.4\\ \\text{eV}$，以及 $\\ell_p = 0.5$。噪声水平为 $\\sigma_n = 0.02\\ \\text{eV}$，因此噪声方差为 $\\sigma_n^2 = 0.0004\\ \\text{eV}^2$。我们计算 $5 \\times 5$ 矩阵 $K(X, X)$ 和 $4 \\times 5$ 矩阵 $K(X_*, X)$。\n\n3.  **计算后验均值：** 执行预测均值 $\\bar{\\mathbf{E}}_*$ 的最终计算。为了数值稳定性，我们不显式地对矩阵 $\\left[K(X, X) + \\sigma_n^2 I\\right]$ 求逆。而是首先求解以下线性方程组：\n    $$\n    \\left[K(X, X) + \\sigma_n^2 I\\right] \\boldsymbol{\\alpha} = \\mathbf{y}\n    $$\n    以求得权重向量 $\\boldsymbol{\\alpha}$。然后通过矩阵-向量乘积获得后验均值：\n    $$\n    \\bar{\\mathbf{E}}_* = K(X_*, X) \\boldsymbol{\\alpha}\n    $$\n此过程完全按照所述实现，以找到 $M=4$ 个测试构型的 GPR 预测能量。所有计算均使用浮点运算，角度以弧度为单位。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Gaussian process regression problem for a potential energy surface.\n    \"\"\"\n\n    # --- Define Constants and Hyperparameters ---\n    \n    # Reference energy function parameters\n    D = 4.5  # eV\n    a = 1.7  # 1/Angstrom\n    r0 = 1.09 # Angstrom\n    V0 = 0.18 # eV\n    n = 3    # dimensionless\n\n    # GPR kernel hyperparameters\n    sigma_s = 2.5  # eV\n    ell_s = 0.2    # Angstrom\n    sigma_p = 0.4  # eV\n    ell_p = 0.5    # dimensionless (for radians)\n    \n    # Observation noise\n    sigma_n = 0.02 # eV\n\n    # --- Define Training and Test Data ---\n\n    # Training configurations (N=5)\n    train_x = np.array([\n        [r0, r0, 0.0],\n        [r0 + 0.1, r0, 0.5],\n        [r0, r0 + 0.15, 1.0],\n        [r0 + 0.2, r0 + 0.2, 2.0],\n        [r0 - 0.1, r0, 3.0]\n    ])\n\n    # Test configurations (M=4)\n    test_x = np.array([\n        [r0, r0, 0.0],\n        [r0, r0, np.pi],\n        [r0 + 0.3, r0, -np.pi],\n        [r0 + 0.05, r0 + 0.05, 1.0]\n    ])\n\n    # --- Step 1: Generate Training Outputs (y) ---\n\n    def E_ref(r1, r2, phi):\n        \"\"\"Computes the reference energy.\"\"\"\n        morse_term = D * (1 - np.exp(-a * (r1 - r0)))**2 - D + \\\n                     D * (1 - np.exp(-a * (r2 - r0)))**2 - D\n        torsional_term = V0 * (1 - np.cos(n * phi))\n        return morse_term + torsional_term\n\n    train_y = np.array([E_ref(x[0], x[1], x[2]) for x in train_x])\n\n    # --- Step 2: Construct Kernel Matrices ---\n\n    def kernel(x1, x2):\n        \"\"\"Computes the composite kernel value k(x1, x2).\"\"\"\n        r1_1, r2_1, phi_1 = x1\n        r1_2, r2_2, phi_2 = x2\n\n        # Squared-exponential kernel for bond stretches\n        sq_dist_r = (r1_1 - r1_2)**2 + (r2_1 - r2_2)**2\n        k_se = (sigma_s**2) * np.exp(-0.5 * sq_dist_r / (ell_s**2))\n\n        # Periodic kernel for dihedral angle\n        d_phi = phi_1 - phi_2\n        k_per = (sigma_p**2) * np.exp(-2.0 * (np.sin(d_phi / 2.0)**2) / (ell_p**2))\n        \n        return k_se + k_per\n    \n    N = len(train_x)\n    M = len(test_x)\n\n    # K(X, X): training data covariance matrix (N x N)\n    K_XX = np.zeros((N, N))\n    for i in range(N):\n        for j in range(N):\n            K_XX[i, j] = kernel(train_x[i], train_x[j])\n\n    # K(X_*, X): test-training data covariance matrix (M x N)\n    K_starX = np.zeros((M, N))\n    for i in range(M):\n        for j in range(N):\n            K_starX[i, j] = kernel(test_x[i], train_x[j])\n\n    # --- Step 3: Compute the Posterior Mean ---\n    \n    # Add noise variance to the diagonal of K(X, X)\n    K_y = K_XX + (sigma_n**2) * np.eye(N)\n    \n    # Solve the linear system for alpha: K_y * alpha = y\n    try:\n        alpha = np.linalg.solve(K_y, train_y)\n    except np.linalg.LinAlgError:\n        # Fallback to pseudoinverse if solve fails, though not expected here\n        alpha = np.linalg.pinv(K_y) @ train_y\n\n    # Compute posterior predictive mean: E_star = K(X_*, X) * alpha\n    E_star_mean = K_starX @ alpha\n    \n    # --- Final Output Formatting ---\n    \n    results = [f\"{val:.6f}\" for val in E_star_mean]\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2456000"}, {"introduction": "在掌握了GPR建模的基本技术后，我们必须思考其应用的边界和局限性。这个思想实验将探讨一个至关重要的问题：一个在某一种分子上训练的模型，能否预测其同分异构体的性质？通过分析这个案例，我们将理解为何标准的GPR模型默认难以泛化到训练数据未覆盖的化学物种，这强调了构建一个能代表目标化学空间的训练集是何等重要。[@problem_id:2455968]", "problem": "一个高斯过程回归 (GPR) 模型经过训练，用于近似势能面 (PES)，该势能面将原子核坐标 $\\mathbf{x}$ 映射到总电子能量 $E(\\mathbf{x})$。该模型使用一个旋转、平移和置换不变的描述符 $\\phi(\\mathbf{x})$ 以及一个平稳、光滑的核函数 $k\\!\\left(\\phi(\\mathbf{x}),\\phi(\\mathbf{x}')\\right)$。先验均值为 $m(\\mathbf{x}) = 0$。训练集完全由围绕 $\\mathrm{C}_4\\mathrm{H}_{10}$ 的线性异构体（丁烷）的低能构象采样的构型组成。训练中不包含支链异构体（异丁烷）的任何构型。当预测属于异丁烷的构型 $\\mathbf{x}_*$ 的能量 $E(\\mathbf{x}_*)$ 时，这个 GPR 模型预期会表现如何？\n\nA. 它通常是不可靠的：因为异丁烷的构型在描述符空间中远离丁烷训练集，所以核相似度很小，预测均值趋向于先验均值，同时预测方差很大，误差可能很大。\n\nB. 它将是准确的：因为两种分子具有相同的分子式 $\\mathrm{C}_4\\mathrm{H}_{10}$，所以它们的势能面基本相同，模型将能够很好地进行插值。\n\nC. 它将在一个加性常数的范围内是准确的：平稳核保证了对异丁烷的预测与真实能量之差仅为一个恒定的能量偏移。\n\nD. 如果使用线性核，它将是准确的：线性模型比非线性核的外推能力更好，因此缺少异丁烷数据不是问题。", "solution": "高斯过程 (GP) 是一组随机变量的集合，其中任意有限个随机变量都具有联合高斯分布。一个 GP 由一个均值函数 $m(\\mathbf{x})$ 和一个协方差函数或核函数 $k(\\mathbf{x}, \\mathbf{x}')$ 完全确定。在这个问题中，GP 的输入是描述符 $\\phi(\\mathbf{x})$。\n\n函数 $f(\\phi)$ 的先验分布由下式给出：\n$$f(\\phi) \\sim \\mathcal{GP}(m(\\phi), k(\\phi, \\phi'))$$\n给定训练数据 $\\{(\\phi_i, y_i)\\}_{i=1}^N$，其中 $\\phi_i = \\phi(\\mathbf{x}_i)$ 是训练构型的描述符，而 $y_i = E(\\mathbf{x}_i)$ 是它们对应的能量，GPR 模型计算新测试点 $\\phi_* = \\phi(\\mathbf{x}_*)$ 的后验分布。\n\n测试点 $\\phi_*$ 的预测均值 $\\mu_*$ 和预测方差 $\\sigma_*^2$ 由标准 GPR 方程给出。假设先验均值为 $m(\\phi)=0$（如题所述），并允许方差为 $\\sigma_n^2$ 的观测噪声：\n$$ \\mu_* = \\mathbf{k}_*^T (\\mathbf{K} + \\sigma_n^2 \\mathbf{I})^{-1} \\mathbf{y} $$\n$$ \\sigma_*^2 = k(\\phi_*, \\phi_*) - \\mathbf{k}_*^T (\\mathbf{K} + \\sigma_n^2 \\mathbf{I})^{-1} \\mathbf{k}_* $$\n在这里，$\\mathbf{K}$ 是训练点的 $N \\times N$ 核矩阵，其元素为 $K_{ij} = k(\\phi_i, \\phi_j)$。向量 $\\mathbf{k}_*$ 包含测试点与每个训练点之间的核函数评估值，其元素为 $k_{*i} = k(\\phi_*, \\phi_i)$。向量 $\\mathbf{y}$ 包含训练目标能量。\n\n核心问题是异丁烷的测试点描述符 $\\phi_*$ 与丁烷的训练集描述符 $\\{\\phi_i\\}$ 之间的关系。丁烷和异丁烷是结构异构体。它们有相同的化学式 $\\mathrm{C}_4\\mathrm{H}_{10}$，但具有不同的原子连接方式和三维结构。一个对相同原子的旋转、平移和置换保持不变的描述符 $\\phi(\\mathbf{x})$，仍然必须能够区分不同的异构体。因此，对应于异丁烷构象的描述符空间区域将与对应于丁烷构象的区域不同且相距甚远。该模型被要求在其训练数据范围之外很远的地方进行外推。\n\n问题指出核函数 $k$ 是平稳且光滑的。一个典型的例子是平方指数（或 RBF）核函数：\n$$ k(\\phi_i, \\phi_j) = \\sigma_f^2 \\exp\\left(-\\frac{1}{2l^2} ||\\phi_i - \\phi_j||^2\\right) $$\n其中 $\\sigma_f^2$ 是信号方差， $l$ 是长度尺度。对于像这样的平稳核，核函数值随着输入之间距离的增加而减小。当测试点 $\\phi_*$ 远离所有训练点 $\\{\\phi_i\\}$ 时，对于所有 $i = 1, \\dots, N$，距离 $||\\phi_* - \\phi_i||$ 都很大。因此，核函数值 $k(\\phi_*, \\phi_i)$ 将非常接近于零。向量 $\\mathbf{k}_*$ 将趋近于零向量：$\\mathbf{k}_* \\to \\mathbf{0}$。\n\n让我们在这个极限下分析预测方程：\n1.  **预测均值：** 当 $\\mathbf{k}_* \\to \\mathbf{0}$ 时，项 $\\mathbf{k}_*^T (\\mathbf{K} + \\sigma_n^2 \\mathbf{I})^{-1} \\mathbf{y}$ 也趋于零。因此，预测均值回归到先验均值：\n    $$ \\mu_* \\to m(\\phi_*) = 0 $$\n2.  **预测方差：** 当 $\\mathbf{k}_* \\to \\mathbf{0}$ 时，方差方程中的第二项 $\\mathbf{k}_*^T (\\mathbf{K} + \\sigma_n^2 \\mathbf{I})^{-1} \\mathbf{k}_*$ 趋于零。预测方差回归到先验方差：\n    $$ \\sigma_*^2 \\to k(\\phi_*, \\phi_*) $$\n    对于平稳核，$k(\\phi_*, \\phi_*) = k(\\mathbf{0})$，这是函数的先验方差 $\\sigma_f^2$。这是可能的最大预测方差。\n\n总而言之，当对异丁烷进行预测时，仅在丁烷上训练的 GPR 模型将预测一个接近先验均值 $0$ 的能量，并报告非常高的不确定性（大的预测方差）。由于异丁烷的真实电子能量是一个很大的负数（相对于分离的原子），因此该预测将非常不准确。大的方差是模型表明其在描述符空间的这个未知区域缺乏知识的方式。\n\n**逐项分析**\n\n**A. 它通常是不可靠的：因为异丁烷的构型在描述符空间中远离丁烷训练集，所以核相似度很小，预测均值趋向于先验均值，同时预测方差很大，误差可能很大。**\n该陈述正确地指出异丁烷在描述符空间中与丁烷是不同的。它正确地推断出这会导致小的核相似度。它正确地陈述了这对 GPR 的影响：预测均值回归到先验均值（此处为 $0$），预测方差变得很大（回归到先验方差）。这种组合导致了不可靠的预测和巨大的误差。这个分析完全符合 GPR 的原理。\n**结论：正确**\n\n**B. 它将是准确的：因为两种分子具有相同的分子式 $\\mathrm{C}_4\\mathrm{H}_{10}$，所以它们的势能面基本相同，模型将能够很好地进行插值。**\n该陈述包含一个根本性的科学错误。像丁烷和异丁烷这样的结构异构体具有截然不同的势能面。它们是具有不同连接性、键长、键角和能量的不同化学物种。在一个异构体的局部 PES 上训练的模型不能简单地“插值”到另一个异构体。这是一项外推任务，而不是插值任务。\n**结论：错误**\n\n**C. 它将在一个加性常数的范围内是准确的：平稳核保证了对异丁烷的预测与真实能量之差仅为一个恒定的能量偏移。**\n这是对平稳核性质的误解。平稳核 $k(\\phi, \\phi') = k(\\phi - \\phi')$，意味着 GP 的统计特性在输入（描述符）空间中对平移是不变的。它并不意味着在远离训练数据的区域中的预测准确性有任何保证。如推导所示，预测值回归到先验值，而不是偏移一个常数的真实能量。\n**结论：错误**\n\n**D. 如果使用线性核，它将是准确的：线性模型比非线性核的外推能力更好，因此缺少异丁烷数据不是问题。**\n该陈述因多种原因而存在缺陷。首先，线性核 $k(\\phi, \\phi') = \\phi^T \\phi'$ 不是平稳的，这与问题陈述相矛盾。其次，“线性模型外推能力更好”的说法是一种危险的过度简化。线性模型会进行线性外推，但这仅在基础函数确实是线性的情况下才适用。由于 $\\mathrm{C}_4\\mathrm{H}_{10}$ 的全局 PES 是高度复杂和非线性的，从丁烷区域进行的线性外推几乎可以肯定对异丁烷区域是灾难性错误的。一个带有衰减核的非线性 GPR 能在外推时正确地报告其高度不确定性，这比做出一个自信但错误的线性预测是一种更“诚实”和更可取的行为。\n**结论：错误**", "answer": "$$\\boxed{A}$$", "id": "2455968"}]}