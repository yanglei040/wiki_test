{"hands_on_practices": [{"introduction": "本练习将通过一个简化的苯分子休克尔模型，带你领会FMO2方法的核心原理。通过比较两种不同的分子碎片划分方案，你将亲手实践多体展开的计算过程，并直观地理解碎片划分策略如何直接影响计算的准确性。[@problem_id:2464440]", "problem": "给定一个苯环，它被建模为一个由六个碳原子组成的环状图，原子标记为 $1,2,3,4,5,6$，每个原子贡献一个 $\\pi$ 电子。考虑在零重叠的简化休克尔分子轨道 (HMO) 模型下，将两体展开水平 (FMO2) 的片段分子轨道 (FMO) 方法应用于此系统。对于任意原子集合 $S$，休克尔哈密顿量定义为一个实对称矩阵 $H(S)$，其矩阵元为\n$$\nH_{ij}(S) =\n\\begin{cases}\n\\alpha,  \\text{如果 } i=j \\in S, \\\\\n\\beta,  \\text{如果 } i\\neq j,\\ i\\in S,\\ j\\in S,\\ \\text{且 } i \\text{ 和 } j \\text{ 在苯环中成键}, \\\\\n0,  \\text{其他情况},\n\\end{cases}\n$$\n其中 $\\alpha$ 是库仑参数（在位能），$\\beta$ 是共振积分（最近邻相互作用）。苯的成键模式是一个6元环：原子 $i$ 与原子 $i-1$ 和 $i+1$（模6）成键。假设轨道重叠为零，且不考虑原子核排斥的贡献。对于任何子系统 $S$，其总电子能量 $E(S)$ 通过求解本征值问题 $H(S)\\mathbf{c}_k=\\varepsilon_k\\mathbf{c}_k$ 来定义，将本征值 $\\varepsilon_k$ 按升序排列，然后根据构造原理填充电子：每个分子轨道最多可容纳2个自旋相反的电子。如果电子数 $N(S)$ 为奇数，则最高占据分子轨道为单占据。由于每个碳原子有一个 $\\pi$ 电子，因此使用 $N(S)=|S|$。\n\n将片段划分 $\\mathcal{F}=\\{F_1,\\dots,F_M\\}$ 的 FMO2 总能量定义为\n$$\nE_{\\mathrm{FMO2}}(\\mathcal{F}) \\;=\\; \\sum_{I=1}^{M} E(F_I) \\;+\\; \\sum_{1 \\le I  J \\le M} \\left[ E(F_I \\cup F_J) - E(F_I) - E(F_J) \\right].\n$$\n精确总能量 $E_{\\mathrm{exact}}$ 是 $E(\\{1,2,3,4,5,6\\})$。\n\n考虑苯的两种片段划分：\n- 片段划分 $\\mathcal{F}_{2+2+2}$：划分为三个类乙炔单元（每个单元包含两个相邻的碳原子）：$F_1=\\{1,2\\}$、$F_2=\\{3,4\\}$、$F_3=\\{5,6\\}$。\n- 片段划分 $\\mathcal{F}_{3+3}$：划分为两个类烯丙基单元（每个单元包含三个相邻的碳原子）：$G_1=\\{1,2,3\\}$、$G_2=\\{4,5,6\\}$。\n\n对于下面测试套件中的每组参数 $(\\alpha,\\beta)$，计算两种片段划分的 FMO2 总能量误差，其定义为\n$$\n\\Delta E_{\\mathcal{F}} \\;=\\; E_{\\mathrm{FMO2}}(\\mathcal{F}) - E_{\\mathrm{exact}}.\n$$\n能量以电子伏特 (eV) 为单位报告，四舍五入到六位小数。\n\n测试套件（每对 $(\\alpha,\\beta)$ 的单位均为 eV）：\n- 情况 A (通用): $(\\alpha,\\beta) = (\\,0.0,\\,-2.5\\,)$。\n- 情况 B (边界，无耦合): $(\\alpha,\\beta) = (\\,1.0,\\,0.0\\,)$。\n- 情况 C (符号反转耦合): $(\\alpha,\\beta) = (\\,0.5,\\,2.0\\,)$。\n\n您的程序必须输出单一行，其中包含一个结果列表，每个测试用例对应一个结果，每个结果都是该用例的列表 $[\\Delta E_{\\mathcal{F}_{2+2+2}},\\, \\Delta E_{\\mathcal{F}_{3+3}}]$，其顺序与测试套件的顺序相同。最终输出必须是单一行，采用方括号括起来的逗号分隔列表的精确格式，例如 $[[x_1,y_1],[x_2,y_2],[x_3,y_3]]$，其中每个 $x_i$ 和 $y_i$ 是一个以 eV 为单位、四舍五入到六位小数的浮点数。", "solution": "该问题定义明确且科学上合理，基于计算化学的既定原理，特别是休克尔分子轨道 (HMO) 模型和片段分子轨道 (FMO) 方法。所有必需的定义、参数和约束均已提供。我将着手提供解决方案。\n\n问题的核心是计算苯环的两种不同片段划分在两体FMO近似 (FMO2) 下的误差。误差 $\\Delta E_{\\mathcal{F}}$ 定义为 FMO2 能量与完整系统精确能量之间的差值：\n$$\n\\Delta E_{\\mathcal{F}} = E_{\\mathrm{FMO2}}(\\mathcal{F}) - E_{\\mathrm{exact}}\n$$\n该系统是一个具有六个碳原子的苯环，每个碳原子贡献一个 $\\pi$ 电子。任何子系统 $S$ 中的总电子数等于其原子数 $|S|$。\n\n首先，必须建立一个在 HMO 模型下计算子系统 $S$ 的总电子能量 $E(S)$ 的通用步骤。\n1.  **构建休克尔哈密顿矩阵 $H(S)$**：对于由原子集合 $S$ 组成的子系统，哈密顿量 $H(S)$ 是一个 $|S| \\times |S|$ 矩阵。其矩阵元定义为：对于原子 $i \\in S$，$H_{ii}(S) = \\alpha$；如果原子 $i, j \\in S$ 在原始苯分子中成键，则 $H_{ij}(S) = \\beta$。所有其他矩阵元为 $0$。苯中的成键是环状的：原子 $i \\in \\{1, \\dots, 6\\}$ 与 $i-1$ 和 $i+1$ 成键（索引对6取模，并将 $0$ 映射到 $6$）。\n2.  **求解本征值问题**：分子轨道能量 $\\varepsilon_k$ 是 $H(S)$ 的本征值。我们通过求解久期方程 $H(S)\\mathbf{c}_k = \\varepsilon_k \\mathbf{c}_k$ 来找到它们。本征值必须按升序排序。\n3.  **计算总能量**：总电子能量 $E(S)$ 是通过根据构造原理用可用电子 $N(S) = |S|$ 填充分子轨道来获得的。有 $N_{\\text{pairs}} = \\lfloor N(S)/2 \\rfloor$ 个双占据轨道和 $N_{\\text{unpaired}} = N(S) \\pmod 2$ 个单占据轨道，能量为：\n    $$\n    E(S) = \\sum_{k=1}^{N_{\\text{pairs}}} 2\\varepsilon_k + \\sum_{k=N_{\\text{pairs}}+1}^{N_{\\text{pairs}}+N_{\\text{unpaired}}} \\varepsilon_k\n    $$\n\n精确能量 $E_{\\mathrm{exact}}$ 是整个苯分子的能量，即 $E(\\{1,2,3,4,5,6\\})$。\n\n接下来，我们评估每种片段划分的 FMO2 能量。通用的 FMO2 公式为：\n$$\nE_{\\mathrm{FMO2}}(\\mathcal{F}) = \\sum_{I=1}^{M} E(F_I) + \\sum_{1 \\le I  J \\le M} \\left[ E(F_I \\cup F_J) - E(F_I) - E(F_J) \\right]\n$$\n\n**片段划分 $\\mathcal{F}_{3+3}$:**\n这种划分由两个片段组成，$G_1=\\{1,2,3\\}$ 和 $G_2=\\{4,5,6\\}$。在这种情况下，$M=2$。FMO2 公式显著简化为：\n$$\nE_{\\mathrm{FMO2}}(\\mathcal{F}_{3+3}) = E(G_1) + E(G_2) + \\left[ E(G_1 \\cup G_2) - E(G_1) - E(G_2) \\right] = E(G_1 \\cup G_2)\n$$\n由于 $G_1 \\cup G_2 = \\{1,2,3,4,5,6\\}$ 是整个苯分子，FMO2 能量恰好是完整系统的能量：\n$$\nE_{\\mathrm{FMO2}}(\\mathcal{F}_{3+3}) = E(\\{1,2,3,4,5,6\\}) = E_{\\mathrm{exact}}\n$$\n因此，无论参数 $\\alpha$ 和 $\\beta$ 如何，这种片段划分的误差始终为零：\n$$\n\\Delta E_{\\mathcal{F}_{3+3}} = E_{\\mathrm{FMO2}}(\\mathcal{F}_{3+3}) - E_{\\mathrm{exact}} = 0\n$$\n\n**片段划分 $\\mathcal{F}_{2+2+2}$:**\n这种划分由三个片段组成：$F_1=\\{1,2\\}$、$F_2=\\{3,4\\}$ 和 $F_3=\\{5,6\\}$。这里 $M=3$。FMO2 能量为：\n$$\nE_{\\mathrm{FMO2}}(\\mathcal{F}_{2+2+2}) = \\sum_{I=1}^{3} E(F_I) + \\sum_{1 \\le I  J \\le 3} \\left[ E(F_I \\cup F_J) - E(F_I) - E(F_J) \\right]\n$$\n这个表达式可以重排为：\n$$\nE_{\\mathrm{FMO2}}(\\mathcal{F}_{2+2+2}) = E(F_1 \\cup F_2) + E(F_1 \\cup F_3) + E(F_2 \\cup F_3) - E(F_1) - E(F_2) - E(F_3)\n$$\n根据苯环的对称性和片段划分模式：\n- 片段 $F_1, F_2, F_3$ 是等价的（两个相邻原子），所以 $E(F_1) = E(F_2) = E(F_3)$。\n- 片段对 $F_1 \\cup F_2 = \\{1,2,3,4\\}$ 和 $F_2 \\cup F_3 = \\{3,4,5,6\\}$ 是等价的（四个原子的线性链），所以 $E(F_1 \\cup F_2) = E(F_2 \\cup F_3)$。\n- 片段对 $F_1 \\cup F_3 = \\{1,2,5,6\\}$ 是不同的，因为原子 $1$ 和 $6$ 成键，形成了一个非线性结构。\n\nFMO2 能量的简化公式为：\n$$\nE_{\\mathrm{FMO2}}(\\mathcal{F}_{2+2+2}) = 2E(F_1 \\cup F_2) + E(F_1 \\cup F_3) - 3E(F_1)\n$$\n为了找到误差 $\\Delta E_{\\mathcal{F}_{2+2+2}}$，我们必须计算四个子系统的能量：\n1.  $S_1 = \\{1,2,3,4,5,6\\}$ 以获得 $E_{\\mathrm{exact}}$。\n2.  $S_2 = F_1 = \\{1,2\\}$ 以获得 $E(F_1)$。\n3.  $S_3 = F_1 \\cup F_2 = \\{1,2,3,4\\}$ 以获得 $E(F_1 \\cup F_2)$。\n4.  $S_4 = F_1 \\cup F_3 = \\{1,2,5,6\\}$ 以获得 $E(F_1 \\cup F_3)$。\n\n对于每个测试用例 $(\\alpha, \\beta)$，我们将为这些子系统中的每一个数值构建哈密顿矩阵，计算它们的本征值，通过填充轨道确定总电子能量，最后计算误差 $\\Delta E_{\\mathcal{F}_{2+2+2}}$。\n\n算法如下：\n1. 对于测试套件中的每对 $(\\alpha, \\beta)$：\n2. 定义苯中的键集合：$\\{(1,2), (2,3), (3,4), (4,5), (5,6), (6,1)\\}$。\n3. 计算 $E_{\\mathrm{exact}} = E(\\{1,2,3,4,5,6\\})$。\n4. 计算 $E(F_1) = E(\\{1,2\\})$。\n5. 计算 $E(F_1 \\cup F_2) = E(\\{1,2,3,4\\})$。\n6. 计算 $E(F_1 \\cup F_3) = E(\\{1,2,5,6\\})$。\n7. 计算 $E_{\\mathrm{FMO2}}(\\mathcal{F}_{2+2+2}) = 2E(F_1 \\cup F_2) + E(F_1 \\cup F_3) - 3E(F_1)$。\n8. 计算误差 $\\Delta E_{\\mathcal{F}_{2+2+2}} = E_{\\mathrm{FMO2}}(\\mathcal{F}_{2+2+2}) - E_{\\mathrm{exact}}$。\n9. 误差 $\\Delta E_{\\mathcal{F}_{3+3}}$ 为 $0.0$。\n10. 存储这对误差值，四舍五入到六位小数。\n11. 处理完所有测试用例后，将收集到的结果格式化为指定的输出字符串。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_huckel_energy(atoms, alpha, beta):\n    \"\"\"\n    Calculates the Hückel molecular orbital energy for a given subsystem of benzene.\n\n    Args:\n        atoms (tuple): A tuple of 1-based atom indices in the subsystem.\n        alpha (float): The Coulomb parameter (on-site energy).\n        beta (float): The resonance integral (hopping parameter).\n\n    Returns:\n        float: The total electronic energy of the subsystem.\n    \"\"\"\n    n = len(atoms)\n    if n == 0:\n        return 0.0\n\n    # Define benzene bonds (1-based indexing)\n    bonds = {frozenset({1, 2}), frozenset({2, 3}), frozenset({3, 4}), \n             frozenset({4, 5}), frozenset({5, 6}), frozenset({6, 1})}\n\n    # Map 1-based atom indices to 0-based matrix indices\n    atom_map = {atom_idx: i for i, atom_idx in enumerate(atoms)}\n\n    # Build the Hückel Hamiltonian matrix\n    H = np.zeros((n, n))\n    for i in range(n):\n        for j in range(i, n):\n            atom1 = atoms[i]\n            atom2 = atoms[j]\n            if i == j:\n                H[i, j] = alpha\n            elif frozenset({atom1, atom2}) in bonds:\n                H[i, j] = H[j, i] = beta\n\n    # Calculate eigenvalues (molecular orbital energies)\n    # np.linalg.eigh returns sorted eigenvalues for Hermitian matrices\n    eigenvalues = np.linalg.eigh(H)[0]\n\n    # Fill orbitals with electrons (N_electrons = N_atoms)\n    num_electrons = n\n    num_pairs = num_electrons // 2\n    num_unpaired = num_electrons % 2\n    \n    total_energy = 0.0\n    # Add energy from doubly-occupied orbitals\n    total_energy += 2.0 * np.sum(eigenvalues[:num_pairs])\n    # Add energy from singly-occupied orbitals (if any)\n    if num_unpaired  0:\n        total_energy += eigenvalues[num_pairs]\n\n    return total_energy\n\ndef solve():\n    \"\"\"\n    Solves the FMO problem for the given test cases.\n    \"\"\"\n    # Test suite: (alpha, beta) pairs in eV\n    test_cases = [\n        (0.0, -2.5),  # Case A\n        (1.0, 0.0),   # Case B\n        (0.5, 2.0),   # Case C\n    ]\n\n    all_results = []\n\n    # Define atom sets for required subsystems\n    all_atoms = tuple(range(1, 7))\n    F1_atoms = (1, 2)\n    F1F2_atoms = (1, 2, 3, 4)\n    F1F3_atoms = (1, 2, 5, 6)\n    \n    for alpha, beta in test_cases:\n        # 1. Calculate the exact energy of the full system\n        e_exact = calculate_huckel_energy(all_atoms, alpha, beta)\n\n        # 2. Calculate error for fragmentation F_2+2+2\n        # F_2+2+2 = {F1, F2, F3} where F1={1,2}, F2={3,4}, F3={5,6}\n        # E_fmo2 = E(F1 U F2) + E(F1 U F3) + E(F2 U F3) - E(F1) - E(F2) - E(F3)\n        # By symmetry: E(F1)=E(F2)=E(F3), E(F1 U F2) = E(F2 U F3)\n        # E_fmo2 = 2*E(F1 U F2) + E(F1 U F3) - 3*E(F1)\n        \n        e_f1 = calculate_huckel_energy(F1_atoms, alpha, beta)\n        e_f1f2 = calculate_huckel_energy(F1F2_atoms, alpha, beta)\n        e_f1f3 = calculate_huckel_energy(F1F3_atoms, alpha, beta)\n        \n        e_fmo2_222 = 2 * e_f1f2 + e_f1f3 - 3 * e_f1\n        delta_e_222 = e_fmo2_222 - e_exact\n\n        # 3. Calculate error for fragmentation F_3+3\n        # F_3+3 = {G1, G2} where G1={1,2,3}, G2={4,5,6}\n        # For M=2 fragments, E_fmo2 = E(G1 U G2) = E_exact.\n        # Thus, the error is always zero.\n        delta_e_333 = 0.0\n\n        all_results.append([delta_e_222, delta_e_333])\n\n    # Format the final output string exactly as specified.\n    inner_parts = [f\"[{res[0]:.6f},{res[1]:.6f}]\" for res in all_results]\n    final_output = f\"[{','.join(inner_parts)}]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "2464440"}, {"introduction": "“对相互作用能”（Pair Interaction Energy, PIE）是FMO方法中的一个核心概念，但它究竟代表了哪些物理作用力？本实践将运用一个经典模型，将一个离子与一个水分子间的相互作用分解为直观的静电和极化两部分，为抽象的能量项提供一个具体的物理图像。[@problem_id:2464489]", "problem": "您将实现一个完整的程序，该程序使用一种受片段分子轨道 (FMO) 方法启发的、简化的第一性原理静电加诱导模型，来计算和比较单个水分子和单原子离子之间的近似对相互作用能 (PIE)。在片段分子轨道 (FMO) 方法中，两个片段之间的对相互作用能 (PIE) 定义为在使用与总体系相同的哈密顿量时，片段结合所引起的能量变化。在此问题中，您将计算 PIE 的经典近似值，该近似值是两个具有物理动机的项之和：离子与固定的水分子部分电荷之间的直接库仑相互作用，以及由于离子的电场极化水分子而产生的诱导能。所需的所有量和单位均在下面指定。\n\n水分子的几何与电荷模型：\n- 将氧原子置于原点。分子位于 $xz$ 平面内，H–O–H 角的角平分线沿 $+z$ 轴排列。\n- O–H 键长为 $0.9572~\\mathrm{\\AA}$。H–O–H 键角为 $104.52^\\circ$。\n- 令 $\\theta = 104.52^\\circ/2 = 52.26^\\circ$。氢原子的位置是\n  $$\n  \\mathbf{r}_{\\mathrm{H}_1} = \\bigl( \\, 0.9572\\sin\\theta,\\, 0,\\, 0.9572\\cos\\theta \\, \\bigr)~\\mathrm{\\AA}, \\quad\n  \\mathbf{r}_{\\mathrm{H}_2} = \\bigl( \\, -0.9572\\sin\\theta,\\, 0,\\, 0.9572\\cos\\theta \\, \\bigr)~\\mathrm{\\AA}.\n  $$\n- 水分子上的固定部分电荷（单位为元电荷 $e$）：氧上为 $q_{\\mathrm{O}}=-0.834\\,e$，每个氢上为 $q_{\\mathrm{H}}=+0.417\\,e$。\n\n离子模型与位置：\n- 考虑一个电荷为 $q_{\\mathrm{ion}}=\\pm 1\\,e$ 的单原子离子，位于 $+z$ 轴上，位置为 $\\mathbf{r}_{\\mathrm{ion}}=(0,0,R)$，其中 $R$ 以 $\\mathrm{\\AA}$ 为单位指定。锂阳离子 $\\mathrm{Li}^+$ 使用 $q_{\\mathrm{ion}}=+1\\,e$，氟阴离子 $\\mathrm{F}^-$ 使用 $q_{\\mathrm{ion}}=-1\\,e$。\n\n能量模型：\n- 总相互作用能建模为\n  $$\n  E_{\\mathrm{tot}}(R;q_{\\mathrm{ion}})=E_{\\mathrm{coul}}(R;q_{\\mathrm{ion}})+E_{\\mathrm{ind}}(R;q_{\\mathrm{ion}}),\n  $$\n  其中库仑项是离子-位点对相互作用的总和，诱导项模拟了离子电场对水的各向同性极化。\n- 库仑项：\n  $$\n  E_{\\mathrm{coul}}(R;q_{\\mathrm{ion}})=k_e \\sum_{a\\in\\{\\mathrm{O},\\mathrm{H}_1,\\mathrm{H}_2\\}} \\frac{q_{\\mathrm{ion}}\\, q_a}{\\|\\mathbf{r}_{\\mathrm{ion}}-\\mathbf{r}_a\\|},\n  $$\n  其中 $k_e=\\dfrac{1}{4\\pi\\varepsilon_0}=8.9875517923\\times 10^9~\\mathrm{N\\,m^2\\,C^{-2}}$。在以焦耳为单位计算 $E_{\\mathrm{coul}}$ 之前，使用元电荷大小 $e=1.602176634\\times 10^{-19}~\\mathrm{C}$ 将电荷 $q_{\\mathrm{ion}}$ 和 $q_a$ 转换为库仑，并使用 $1~\\mathrm{\\AA}=1.0\\times 10^{-10}~\\mathrm{m}$ 将所有距离从 $\\mathrm{\\AA}$ 转换为米。\n- 诱导项（各向同性、线性响应、以氧为中心）：\n  $$\n  E_{\\mathrm{ind}}(R;q_{\\mathrm{ion}})=-\\frac{1}{2}\\,\\alpha\\, \\|\\mathbf{E}_{\\mathrm{ion}\\to \\mathrm{O}}\\|^2,\n  $$\n  其中 $\\alpha$ 是水的各向同性分子极化率，$\\mathbf{E}_{\\mathrm{ion}\\to \\mathrm{O}}$ 是仅由离子在氧原子处产生的电场。将水视为仅在氧原子处可极化。距离 $R$ 处的点电荷 $q_{\\mathrm{ion}}$ 在氧原子处产生的电场强度大小为\n  $$\n  \\|\\mathbf{E}_{\\mathrm{ion}\\to \\mathrm{O}}\\|=\\frac{k_e\\,|q_{\\mathrm{ion}}|}{R^2},\n  $$\n  其中 $R$ 以米为单位，$q_{\\mathrm{ion}}$ 以库仑为单位。使用各向同性极化率 $\\alpha=1.45~\\mathrm{\\AA^3}$，通过 $1~\\mathrm{\\AA^3}=1.64877727436\\times 10^{-41}~\\mathrm{C\\,m^2\\,V^{-1}}$ 转换为国际单位制。\n- 使用 Avogadro 常数 $N_{\\mathrm{A}}=6.02214076\\times 10^{23}~\\mathrm{mol^{-1}}$ 和 $1~\\mathrm{kJ}=10^3~\\mathrm{J}$ 将最终能量从焦耳/分子转换为 $\\mathrm{kJ/mol}$。\n\n角度单位说明：\n- 三角函数使用弧度。给定的键角（以度为单位）在需要时必须转换为弧度。电场和库仑表达式要求距离以米为单位。\n\n测试套件：\n- 针对以下离子-氧分离距离 $R$（以 $\\mathrm{\\AA}$ 为单位）：$[\\,2.0,\\, 2.5,\\, 3.5,\\, 10.0\\,]$，评估该模型。对于每个 $R$，计算三个量（以 $\\mathrm{kJ/mol}$ 为单位）：\n  1. $\\mathrm{Li}^+$ 的 $E_{\\mathrm{tot}}(R;+1\\,e)$，\n  2. $\\mathrm{F}^-$ 的 $E_{\\mathrm{tot}}(R;-1\\,e)$，\n  3. $\\Delta E(R)=E_{\\mathrm{tot}}(R;+1\\,e)-E_{\\mathrm{tot}}(R;-1\\,e)$。\n- 所有报告的能量必须四舍五入到恰好 $6$ 位小数，并以 $\\mathrm{kJ/mol}$ 表示。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个类 JSON 的 Python 列表的列表，每个内部列表对应一个测试用例，顺序与测试套件相同。每个内部列表必须按 $[E_{\\mathrm{tot}}(R;+1\\,e),\\,E_{\\mathrm{tot}}(R;-1\\,e),\\,\\Delta E(R)]$ 的顺序排列，每个浮点数四舍五入到恰好 $6$ 位小数。例如：$[[x_{1},y_{1},z_{1}],[x_{2},y_{2},z_{2}],\\dots]$。", "solution": "所提出的问题是计算物理和计算化学中的一个有效练习。它具有科学依据，问题明确，客观，并包含唯一解所需的所有必要信息。它要求应用静电学的基本原理来模拟简化的离子-分子相互作用，这是分子力学力场和量子化学片段化方法开发和理解中的常见做法。我们将着手对解进行严格的推导。\n\n离子与水分子之间的总相互作用能 $E_{\\mathrm{tot}}$ 由库仑项 $E_{\\mathrm{coul}}$ 和诱导项 $E_{\\mathrm{ind}}$ 的和给出。我们将分别分析每个分量，确保所有量都以国际单位制（SI）表示以进行计算，然后将最终能量转换为所需的单位 $\\mathrm{kJ/mol}$。\n\n首先，我们确定国际单位制（SI）形式的基本常数和转换因子：\n- 库仑常数：$k_e = 8.9875517923 \\times 10^9~\\mathrm{N\\,m^2\\,C^{-2}}$\n- 元电荷：$e = 1.602176634 \\times 10^{-19}~\\mathrm{C}$\n- Avogadro 常数：$N_{\\mathrm{A}} = 6.02214076 \\times 10^{23}~\\mathrm{mol^{-1}}$\n- 埃到米的转换：$1~\\mathrm{\\AA} = 1.0 \\times 10^{-10}~\\mathrm{m}$\n- 极化率体积转换（$\\mathrm{\\AA^3}$ 到 SI）：$1~\\mathrm{\\AA^3} = 1.64877727436 \\times 10^{-41}~\\mathrm{C\\,m^2\\,V^{-1}}$\n\n接下来，我们确定水分子的几何结构。氧原子位于原点，$\\mathbf{r}_{\\mathrm{O}} = (0, 0, 0)$。O-H 键长为 $d_{\\mathrm{OH}} = 0.9572~\\mathrm{\\AA}$，H-O-H 键角为 $\\phi = 104.52^\\circ$。半角 $\\theta = \\phi/2 = 52.26^\\circ$ 必须转换为弧度以在三角函数中使用：$\\theta_{\\mathrm{rad}} = 52.26 \\cdot (\\pi / 180)$。氢原子的坐标则为：\n$z_{\\mathrm{H}} = d_{\\mathrm{OH}} \\cos(\\theta_{\\mathrm{rad}})$\n$x_{\\mathrm{H}} = d_{\\mathrm{OH}} \\sin(\\theta_{\\mathrm{rad}})$\n所以，$\\mathbf{r}_{\\mathrm{H}_1} = (x_{\\mathrm{H}}, 0, z_{\\mathrm{H}})$ 且 $\\mathbf{r}_{\\mathrm{H}_2} = (-x_{\\mathrm{H}}, 0, z_{\\mathrm{H}})$。\n离子位于 $\\mathbf{r}_{\\mathrm{ion}} = (0, 0, R)$。所有坐标最初都以埃为单位。\n\n**1. 库仑相互作用能，$E_{\\mathrm{coul}}$**\n\n库仑能是离子与水分子上部分电荷之间成对相互作用的总和：\n$$\nE_{\\mathrm{coul}}(R; q_{\\mathrm{ion}}) = k_e \\sum_{a \\in \\{\\mathrm{O}, \\mathrm{H}_1, \\mathrm{H}_2\\}} \\frac{q_{\\mathrm{ion}} q_a}{\\|\\mathbf{r}_{\\mathrm{ion}} - \\mathbf{r}_a\\|}\n$$\n电荷 $q_{\\mathrm{ion}}$ 和 $q_a$ 以 $e$ 的倍数给出。设无量纲电荷值为 $q'_{\\mathrm{ion}}$ 和 $q'_a$。实际电荷为 $q'_{\\mathrm{ion}}e$ 和 $q'_a e$。距离必须以米为单位。\n离子与水原子之间的距离是：\n- 离子-氧距离：$d_{\\mathrm{ion-O}} = \\|\\mathbf{r}_{\\mathrm{ion}} - \\mathbf{r}_{\\mathrm{O}}\\| = \\|(0,0,R) - (0,0,0)\\| = R$。\n- 离子-氢距离：根据对称性，两个氢原子的距离相同。\n$$\nd_{\\mathrm{ion-H}} = \\|\\mathbf{r}_{\\mathrm{ion}} - \\mathbf{r}_{\\mathrm{H}_1}\\| = \\sqrt{(0 - x_{\\mathrm{H}})^2 + (0 - 0)^2 + (R - z_{\\mathrm{H}})^2} = \\sqrt{x_{\\mathrm{H}}^2 + (R - z_{\\mathrm{H}})^2}\n$$\n将这些代入能量表达式中，其中距离以 $\\mathrm{\\AA}$ 为单位，转换因子为 $10^{-10}~\\mathrm{m/\\AA}$：\n$$\nE_{\\mathrm{coul}} [\\mathrm{J}] = k_e \\frac{(q'_{\\mathrm{ion}}e)(q'_{\\mathrm{O}}e)}{R \\times 10^{-10}} + 2 \\cdot k_e \\frac{(q'_{\\mathrm{ion}}e)(q'_{\\mathrm{H}}e)}{d_{\\mathrm{ion-H}} \\times 10^{-10}}\n$$\n$$\nE_{\\mathrm{coul}} [\\mathrm{J}] = \\frac{k_e e^2}{10^{-10}} q'_{\\mathrm{ion}} \\left( \\frac{q'_{\\mathrm{O}}}{R} + \\frac{2q'_{\\mathrm{H}}}{d_{\\mathrm{ion-H}}} \\right)\n$$\n为了将其转换为 $\\mathrm{kJ/mol}$，我们乘以 $N_{\\mathrm{A}}/1000$。预因子变为：\n$$\nC_{\\mathrm{coul}} = \\frac{k_e e^2 N_{\\mathrm{A}}}{10^{-10} \\times 1000} \\approx 1389.3546~\\mathrm{kJ \\cdot \\AA \\cdot mol^{-1}}\n$$\n所以，对于 $q'_{\\mathrm{ion}}=+1$ 时，库仑能的实用公式是：\n$$\nE_{\\mathrm{coul}}(R; +1e) [\\mathrm{kJ/mol}] = C_{\\mathrm{coul}} \\left( \\frac{-0.834}{R} + \\frac{2 \\times 0.417}{\\sqrt{x_{\\mathrm{H}}^2 + (R - z_{\\mathrm{H}})^2}} \\right)\n$$\n注意 $E_{\\mathrm{coul}}(R; -1e) = -E_{\\mathrm{coul}}(R; +1e)$。\n\n**2. 诱导能，$E_{\\mathrm{ind}}$**\n\n诱导能由离子电场对水分子的极化引起。其表达式为：\n$$\nE_{\\mathrm{ind}}(R; q_{\\mathrm{ion}}) = -\\frac{1}{2} \\alpha \\|\\mathbf{E}_{\\mathrm{ion}\\to\\mathrm{O}}\\|^2\n$$\n距离 $R$ 处的离子在氧原子核（原点）处产生的电场大小为：\n$$\n\\|\\mathbf{E}_{\\mathrm{ion}\\to\\mathrm{O}}\\| = \\frac{k_e |q_{\\mathrm{ion}}|}{(R \\times 10^{-10})^2} = \\frac{k_e |q'_{\\mathrm{ion}}| e}{(R \\times 10^{-10})^2}\n$$\n极化率 $\\alpha = 1.45~\\mathrm{\\AA^3}$ 必须转换为国际单位制（SI）单位：$\\alpha_{\\mathrm{SI}} = 1.45 \\times (1.64877727436 \\times 10^{-41})~\\mathrm{C\\,m^2\\,V^{-1}}$。\n将这些代入诱导能公式中（其中 $|q'_{\\mathrm{ion}}|=1$）：\n$$\nE_{\\mathrm{ind}} [\\mathrm{J}] = -\\frac{1}{2} \\alpha_{\\mathrm{SI}} \\left( \\frac{k_e e}{R^2 \\times (10^{-10})^2} \\right)^2 = -\\frac{1}{2} \\frac{\\alpha_{\\mathrm{SI}} (k_e e)^2}{(10^{-10})^4} \\frac{1}{R^4}\n$$\n其中 $R$ 以埃为单位。为了转换为 $\\mathrm{kJ/mol}$，我们再次乘以 $N_{\\mathrm{A}}/1000$：\n$$\nC_{\\mathrm{ind}} = \\frac{1}{2} \\frac{\\alpha_{\\mathrm{SI}} (k_e e)^2 N_{\\mathrm{A}}}{(10^{-10})^4 \\times 1000} = \\frac{1}{2} \\frac{(1.45 \\times 1.648... \\times 10^{-41}) (k_e e)^2 N_{\\mathrm{A}}}{10^{-40} \\times 1000} \\approx 149.2868~\\mathrm{kJ \\cdot \\AA^4 \\cdot mol^{-1}}\n$$\n因此，诱导能的实用公式是：\n$$\nE_{\\mathrm{ind}} [\\mathrm{kJ/mol}] = - \\frac{C_{\\mathrm{ind}}}{R^4}\n$$\n这一项与离子电荷的符号无关，因为它依赖于 $|q_{\\mathrm{ion}}|^2$。\n\n**3. 总能量和差值项**\n\n对于测试套件中的每个距离 $R$，我们计算所需的量：\n1.  对于 $\\mathrm{Li}^+$ ($q'_{\\mathrm{ion}}=+1$)：\n    $E_{\\mathrm{tot}}(R;+1e) = E_{\\mathrm{coul}}(R;+1e) + E_{\\mathrm{ind}}(R)$\n2.  对于 $\\mathrm{F}^-$ ($q'_{\\mathrm{ion}}=-1$)：\n    $E_{\\mathrm{tot}}(R;-1e) = E_{\\mathrm{coul}}(R;-1e) + E_{\\mathrm{ind}}(R) = -E_{\\mathrm{coul}}(R;+1e) + E_{\\mathrm{ind}}(R)$\n3.  差值项：\n    $\\Delta E(R) = E_{\\mathrm{tot}}(R;+1e) - E_{\\mathrm{tot}}(R;-1e)$\n    $\\Delta E(R) = (E_{\\mathrm{coul}}(R;+1e) + E_{\\mathrm{ind}}(R)) - (-E_{\\mathrm{coul}}(R;+1e) + E_{\\mathrm{ind}}(R))$\n    $\\Delta E(R) = 2 \\cdot E_{\\mathrm{coul}}(R;+1e)$\n\n这表明相互作用能的不对称性完全是由水分子的固定、不对称电荷分布引起的，因为诱导项相对于离子电荷的符号是对称的。\n\n计算步骤如下：\n- 定义所有常数和转换因子。\n- 预先计算水分子的几何参数 ($x_H, z_H$)。\n- 遍历每个指定的距离 $R$。\n- 对于每个 $R$，使用推导出的实用公式计算 $E_{\\mathrm{coul}}(R;+1e)$ 和 $E_{\\mathrm{ind}}(R)$（单位为 $\\mathrm{kJ/mol}$）。\n- 组合这些结果以求得 $E_{\\mathrm{tot}}(R;+1e)$、$E_{\\mathrm{tot}}(R;-1e)$ 和 $\\Delta E(R)$。\n- 将这三个值中的每一个都四舍五入到六位小数。\n- 存储结果并按指定格式化最终输出。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes and compares an approximate Pair Interaction Energy (PIE)\n    between a water molecule and a monatomic ion (Li+ or F-).\n    \"\"\"\n\n    # --- Constants and Conversion Factors (SI units) ---\n    K_E = 8.9875517923e9  # Coulomb's constant (N m^2 C^-2)\n    E_CHARGE = 1.602176634e-19  # Elementary charge (C)\n    N_A = 6.02214076e23  # Avogadro constant (mol^-1)\n    \n    # Conversion factors\n    ANGSTROM_TO_METER = 1.0e-10\n    ANGSTROM3_TO_SI_POL = 1.64877727436e-41 # (C m^2 V^-1) / A^3\n    JOULE_TO_KJ_MOL = N_A / 1000.0\n\n    # --- Problem-Specific Parameters ---\n    # Water geometry\n    D_OH = 0.9572  # O-H bond length (Angstrom)\n    THETA_HOH_DEG = 104.52  # H-O-H bond angle (degrees)\n\n    # Water partial charges (in units of elementary charge e)\n    Q_O = -0.834\n    Q_H = 0.417\n\n    # Water polarizability\n    ALPHA_WATER_A3 = 1.45 # (Angstrom^3)\n\n    # Ion charges (in units of elementary charge e)\n    Q_ION_LI = 1.0\n    Q_ION_F = -1.0\n    \n    # Test suite of ion-oxygen separations (Angstrom)\n    R_VALUES = [2.0, 2.5, 3.5, 10.0]\n\n    # --- Pre-calculations ---\n    \n    # Water atom coordinates (Angstroms)\n    theta_rad = np.deg2rad(THETA_HOH_DEG / 2.0)\n    z_h = D_OH * np.cos(theta_rad)\n    x_h = D_OH * np.sin(theta_rad)\n\n    # Prefactor for Coulomb energy calculation, converting from (e^2/Angstrom) to (kJ/mol)\n    # C_coul = (k_e * e^2) / (angstrom_to_meter) * (N_A / 1000)\n    coulomb_prefactor = (K_E * E_CHARGE**2 / ANGSTROM_TO_METER) * JOULE_TO_KJ_MOL\n\n    # Prefactor for induction energy, converting from (A^3 / A^4) to (kJ/mol)\n    # C_ind = 0.5 * (alpha_A3*conv_pol) * (k_e*e)^2 / (angstrom_to_meter)^4 * (N_A/1000)\n    # C_ind = 0.5 * alpha_A3 * [conv_pol * (k_e*e)^2 * N_A / (angstrom^4 * 1000)]\n    induction_prefactor = (0.5 * ALPHA_WATER_A3 * ANGSTROM3_TO_SI_POL * \n                           (K_E * E_CHARGE)**2 / (ANGSTROM_TO_METER**4) * \n                           JOULE_TO_KJ_MOL)\n                           \n    results = []\n    \n    # --- Main Calculation Loop ---\n    for R in R_VALUES:\n        # Distance between ion and hydrogen atoms (Angstrom)\n        d_ion_h = np.sqrt(x_h**2 + (R - z_h)**2)\n        \n        # --- 1. Coulomb Energy Calculation ---\n        # Calculate for a +1e charge (Li+)\n        # E_coul = C_coul * q_ion * (q_O/d_O + 2*q_H/d_H)\n        e_coul_pos_kjmol = coulomb_prefactor * Q_ION_LI * (\n            Q_O / R + 2 * Q_H / d_ion_h\n        )\n\n        # --- 2. Induction Energy Calculation ---\n        # The induction energy is proportional to q_ion^2, so it's the same\n        # for Li+ and F- (|q_ion|=1). The formula is E_ind = -C_ind / R^4.\n        e_ind_kjmol = -induction_prefactor / (R**4)\n\n        # --- 3. Total Energies and Difference ---\n        # Energy for Li+ (q_ion = +1)\n        e_tot_li = e_coul_pos_kjmol + e_ind_kjmol\n        \n        # Energy for F- (q_ion = -1)\n        # E_coul for -1 charge is -E_coul for +1 charge.\n        e_tot_f = -e_coul_pos_kjmol + e_ind_kjmol\n\n        # Difference E(Li+) - E(F-)\n        delta_e = e_tot_li - e_tot_f\n        # An equivalent and more direct calculation: delta_e = 2 * e_coul_pos_kjmol\n        \n        # Round results to 6 decimal places and store\n        results.append([\n            round(e_tot_li, 6),\n            round(e_tot_f, 6),\n            round(delta_e, 6)\n        ])\n\n    # --- Final Output Formatting ---\n    # Manually format the list of lists to match the required output string\n    # e.g., \"[[x1,y1,z1],[x2,y2,z2]]\"\n    output_str = '[' + ','.join(map(str, results)) + ']'\n    print(output_str)\n\nsolve()\n```", "id": "2464489"}, {"introduction": "为了让大体系的计算成为可能，FMO方法采用了一系列近似，尤其是在处理远距离相互作用时。本练习将深入探讨多极展开这一关键技术，它被用来近似描述远处碎片的静电势，通过这个实践，你将能够量化分析计算效率与准确性之间的权衡。[@problem_id:2464495]", "problem": "您正在执行一项与计算化学中的片段分子轨道 (FMO) 方法相关的定量分析。任务是评估在使用点电荷（单极）近似或高阶多极展开对远距离片段的静电势进行建模时引入的误差。从离散电荷的基本库仑势和多极矩的正式定义开始。整个计算过程完全使用原子单位，其中库仑常数等于 $1$，电荷以基本电荷为单位，长度以玻尔为单位，静电势以哈特里/基本电荷为单位。所有报告的电势和误差都必须以哈特里/基本电荷为单位。\n\n您的程序必须：\n\n- 使用由位置和电荷定义的一组离散点电荷产生的静电势。场点 $\\mathbf{r}$ 处的精确电势由库仑定律给出，即对所有电荷的贡献求和。所有计算都必须使用关于一个明确定义原点的多极展开，该原点选择为几何中心（片段位点位置的算术平均值）。定义片段关于此中心的多极矩（单极、偶极和四极）。\n\n- 按如下方式定义 $L \\in \\{0,1,2\\}$ 阶的多极近似：$L=0$ 阶仅使用单极项（点电荷模型），$L=1$ 阶使用单极和偶极项，$L=2$ 阶使用单极、偶极和四极项。多极展开必须从格林函数 $|\\mathbf{r}-\\mathbf{R}|^{-1}$ 关于原点的泰勒展开推导得出，并用片段关于几何中心的多极矩表示。四极张量必须使用基于电荷分布二阶矩的标准无迹定义。\n\n- 对于每个测试用例，在以片段几何中心为中心、半径为 $R$ 的球面上，评估精确静电势及其多极近似。使用由黄金角 $\\alpha = \\pi \\left(3 - \\sqrt{5}\\right)$ 定义的斐波那契球面网格在球面上生成 $N$ 个均匀分布的方向。对于 $k \\in \\{0,1,\\dots,N-1\\}$，定义\n  - $z_k = 1 - \\dfrac{2(k+0.5)}{N}$，\n  - $\\rho_k = \\sqrt{1 - z_k^2}$，\n  - $\\phi_k = k \\, \\alpha$，\n  - $\\hat{\\mathbf{u}}_k = \\left(\\rho_k \\cos \\phi_k,\\ \\rho_k \\sin \\phi_k,\\ z_k\\right)$，\n  - $\\mathbf{r}_k = R \\, \\hat{\\mathbf{u}}_k$。\n  使用这些 $\\mathbf{r}_k$ 作为 $N$ 个场点。\n\n- 对于每个阶数 $L \\in \\{0,1,2\\}$，计算精确电势 $V_{\\text{exact}}(\\mathbf{r}_k)$ 与 $L$ 阶多极近似 $V_L(\\mathbf{r}_k)$ 在 $N$ 个方向上的均方根 (RMS) 绝对误差：\n  $$\\mathrm{RMS}_L = \\sqrt{\\dfrac{1}{N} \\sum_{k=0}^{N-1} \\left( V_{\\text{exact}}(\\mathbf{r}_k) - V_L(\\mathbf{r}_k) \\right)^2 }.$$\n  以哈特里/基本电荷为单位报告 $\\mathrm{RMS}_L$。\n\n您可以使用的基本原理：\n- 点电荷的库仑定律和线性叠加原理。\n- $|\\mathbf{r}-\\mathbf{R}|^{-1}$ 在 $|\\mathbf{r}| \\gg |\\mathbf{R}|$ 条件下关于原点的泰勒展开。\n- 关于指定原点的多极矩（单极、偶极矢量和无迹四极张量）的定义。\n\n实现以下测试套件。每个测试用例将一个片段指定为元组列表 $(q_i, x_i, y_i, z_i)$、观测半径 $R$ 和方向数 $N$：\n\n- 测试用例 A（带电，良好分离）：\n  - 片段：$\\left[(+1.0, 0.0, 0.0, 0.0),\\ (+0.5, 1.0, 0.0, 0.0)\\right]$。\n  - 半径：$R = 25.0$。\n  - 方向数：$N = 64$。\n\n- 测试用例 B（中性偶极，良好分离）：\n  - 片段：$\\left[(+1.0, 0.0, 0.0, -1.0),\\ (-1.0, 0.0, 0.0, +1.0)\\right]$。\n  - 半径：$R = 30.0$。\n  - 方向数：$N = 64$。\n\n- 测试用例 C（中性、无偶极、四极主导、良好分离）：\n  - 片段：$\\left[(+1.0, +1.0, 0.0, 0.0),\\ (+1.0, -1.0, 0.0, 0.0),\\ (-1.0, 0.0, +1.0, 0.0),\\ (-1.0, 0.0, -1.0, 0.0)\\right]$。\n  - 半径：$R = 40.0$。\n  - 方向数：$N = 64$。\n\n- 测试用例 D（中性偶极，临界分离距离）：\n  - 片段：$\\left[(+1.0, 0.0, 0.0, -5.0),\\ (-1.0, 0.0, 0.0, +5.0)\\right]$。\n  - 半径：$R = 10.0$。\n  - 方向数：$N = 64$。\n\n所有坐标 $(x_i, y_i, z_i)$ 和半径 $R$ 的单位均为玻尔。所有电荷 $q_i$ 的单位均为基本电荷。必须使用几何中心（位点位置的算术平均值）作为展开原点和观测球面的中心。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果。\n- 每个测试用例的结果必须是一个包含三个浮点数的列表 $[\\mathrm{RMS}_0, \\mathrm{RMS}_1, \\mathrm{RMS}_2]$，分别对应于 $L=0,1,2$ 阶的 RMS 绝对误差。\n- 因此，总输出必须是一个包含四个列表的列表，顺序与测试用例 A, B, C, D 一致。\n- 每个浮点数必须精确到 $8$ 位小数。\n- 例如，一个语法正确且带有占位符值的输出应如下所示：$[[0.12345678,0.01234567,0.00123456],[\\dots],[\\dots],[\\dots]]$。\n\n您的程序必须实现所有步骤，并仅按所述确切格式打印所需的单行输出。", "solution": "该问题要求对离散电荷分布的静电势进行多极近似所引入的误差进行定量分析，这是片段分子轨道 (FMO) 等方法中的一个基本概念。分析必须在原子单位下进行。\n\n第一步是建立严谨的数学框架。对于位于位置 $\\{\\mathbf{R}_i\\}$ 的 $n$ 个点电荷 $\\{q_i\\}$ 的集合，场点 $\\mathbf{r}$ 处的精确静电势由线性叠加原理和库仑定律给出：\n$$\nV_{\\text{exact}}(\\mathbf{r}) = \\sum_{i=1}^{n} \\frac{q_i}{|\\mathbf{r} - \\mathbf{R}_i|}\n$$\n这个精确电势作为衡量所有近似值的参考基准。\n\n多极展开为远离电荷分布的场点 $\\mathbf{r}$ 处的电势提供了一个近似。该展开被表述为格林函数 $1/|\\mathbf{r}-\\mathbf{R}|$ 围绕选定原点的泰勒级数。根据题目要求，展开的原点 $\\mathbf{R}_{\\text{orig}}$ 是电荷位点的几何中心：\n$$\n\\mathbf{R}_{\\text{orig}} = \\frac{1}{n} \\sum_{i=1}^{n} \\mathbf{R}_i\n$$\n这种原点选择在许多 FMO 实现中是标准的。我们定义相对于此中心的坐标：电荷的位置为 $\\mathbf{R'}_i = \\mathbf{R}_i - \\mathbf{R}_{\\text{orig}}$，场点为 $\\mathbf{r'} = \\mathbf{r} - \\mathbf{R}_{\\text{orig}}$。当对于所有 $i$ 都有 $|\\mathbf{r'}| \\gg |\\mathbf{R'}_i|$ 时，该展开有效。\n\n然后，静电势可以表示为关于电荷分布多极矩的级数。这些矩是相对于几何中心定义的。\n单极矩是片段的总电荷：\n$$\nq = \\sum_{i=1}^{n} q_i\n$$\n偶极矩是一个矢量：\n$$\n\\mathbf{p} = \\sum_{i=1}^{n} q_i \\mathbf{R'}_i\n$$\n无迹四极矩是一个二阶张量，其分量为 $Q_{\\alpha\\beta}$（其中 $\\alpha, \\beta \\in \\{x, y, z\\}$）：\n$$\nQ_{\\alpha\\beta} = \\sum_{i=1}^{n} q_i (3 R'_{i\\alpha} R'_{i\\beta} - |\\mathbf{R'}_i|^2 \\delta_{\\alpha\\beta})\n$$\n其中 $\\delta_{\\alpha\\beta}$ 是克罗内克 δ。\n\n使用这些矩，场点 $\\mathbf{r'}$ 处的电势可以近似到不同的阶数 $L$。\n$L=0$ 阶近似仅包括单极项：\n$$\nV_{0}(\\mathbf{r'}) = \\frac{q}{|\\mathbf{r'}|}\n$$\n这是点电荷近似。\n$L=1$ 阶近似包括单极和偶极项：\n$$\nV_{1}(\\mathbf{r'}) = \\frac{q}{|\\mathbf{r'}|} + \\frac{\\mathbf{p} \\cdot \\mathbf{r'}}{|\\mathbf{r'}|^{3}}\n$$\n$L=2$ 阶近似增加了四极项：\n$$\nV_{2}(\\mathbf{r'}) = \\frac{q}{|\\mathbf{r'}|} + \\frac{\\mathbf{p} \\cdot \\mathbf{r'}}{|\\mathbf{r'}|^{3}} + \\frac{1}{2} \\sum_{\\alpha, \\beta} Q_{\\alpha\\beta} \\frac{r'_{\\alpha} r'_{\\beta}}{|\\mathbf{r'}|^{5}}\n$$\n\n为了评估这些近似的准确性，我们在以片段几何中心为中心、半径为 $R$ 的球面上均匀分布的一组 $N$ 个场点上计算电势。这些场点的位置是使用斐波那契球面网格算法生成的。对于 $k \\in \\{0, 1, ..., N-1\\}$，第 $k$ 个场点相对于中心的位置矢量是 $\\mathbf{r'}_k = R \\hat{\\mathbf{u}}_k$，其中 $\\hat{\\mathbf{u}}_k$ 是单位矢量。绝对位置是 $\\mathbf{r}_k = \\mathbf{R}_{\\text{orig}} + \\mathbf{r'}_k$。\n\n每个近似的误差通过 $N$ 个场点上的均方根 (RMS) 绝对误差来量化：\n$$\n\\mathrm{RMS}_L = \\sqrt{\\frac{1}{N} \\sum_{k=0}^{N-1} \\left( V_{\\text{exact}}(\\mathbf{r}_k) - V_L(\\mathbf{r'}_k) \\right)^2 }\n$$\n对于 $L \\in \\{0, 1, 2\\}$。\n\n每个测试用例的算法如下：\n1.  给定片段的电荷 $\\{q_i\\}$ 和位置 $\\{\\mathbf{R}_i\\}$，计算几何中心 $\\mathbf{R}_{\\text{orig}}$。\n2.  计算相对位置 $\\mathbf{R'}_i = \\mathbf{R}_i - \\mathbf{R}_{\\text{orig}}$。\n3.  计算单极矩 $q$、偶极矩矢量 $\\mathbf{p}$ 和无迹四极张量 $\\mathbf{Q}$。\n4.  在以 $\\mathbf{R}_{\\text{orig}}$ 为中心、半径为 $R$ 的球面上生成 $N$ 个场点 $\\{\\mathbf{r}_k\\}$。相对位置是 $\\{\\mathbf{r'}_k\\}$。\n5.  对每个点 $k$，使用原始电荷位置计算精确电势 $V_{\\text{exact}}(\\mathbf{r}_k)$。\n6.  对每个点 $k$，使用多极矩计算近似电势 $V_0(\\mathbf{r'}_k)$、$V_1(\\mathbf{r'}_k)$ 和 $V_2(\\mathbf{r'}_k)$。\n7.  根据上述公式计算 RMS 误差 $\\mathrm{RMS}_0$、$\\mathrm{RMS}_1$ 和 $\\mathrm{RMS}_2$。\n将此过程系统地应用于所有提供的测试用例，以得出所需的数值结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import linalg # Not required for this implementation\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    It calculates the RMS errors for multipole expansions of the electrostatic potential.\n    \"\"\"\n\n    def compute_errors_for_case(fragment_data, R, N):\n        \"\"\"\n        Computes the RMS errors [RMS_0, RMS_1, RMS_2] for a single test case.\n\n        Args:\n            fragment_data (np.ndarray): Array of shape (num_atoms, 4) with [q, x, y, z].\n            R (float): Radius of the observation sphere in bohr.\n            N (int): Number of field points on the sphere.\n\n        Returns:\n            list: A list of three floats [rms0, rms1, rms2].\n        \"\"\"\n        # 1. Parse Input Data from fragment\n        charges = fragment_data[:, 0]\n        positions = fragment_data[:, 1:]\n\n        # 2. Calculate Geometric Centroid\n        centroid = np.mean(positions, axis=0)\n\n        # 3. Shift Coordinates to be relative to the centroid\n        rel_positions = positions - centroid\n\n        # 4. Calculate Multipole Moments\n        # Monopole (L=0)\n        monopole_q = np.sum(charges)\n\n        # Dipole (L=1)\n        dipole_p = np.sum(charges[:, np.newaxis] * rel_positions, axis=0)\n\n        # Traceless Quadrupole Tensor (L=2)\n        # Q_{\\alpha\\beta} = \\sum_i q_i (3 R'_{i\\alpha} R'_{i\\beta} - |\\mathbf{R'}_i|^2 \\delta_{\\alpha\\beta})\n        term1_matrix = 3 * np.einsum('i,ia,ib-ab', charges, rel_positions, rel_positions)\n        rel_pos_sq_mag = np.sum(rel_positions**2, axis=1)\n        trace_I = np.sum(charges * rel_pos_sq_mag)\n        term2_matrix = -trace_I * np.identity(3)\n        quadrupole_Q = term1_matrix + term2_matrix\n\n        # 5. Generate Field Points using Fibonacci spherical grid\n        k = np.arange(N)\n        golden_angle = np.pi * (3 - np.sqrt(5))\n        \n        z_k = 1 - (2 * (k + 0.5)) / N\n        rho_k = np.sqrt(1 - z_k**2)\n        phi_k = k * golden_angle\n        \n        x_k = rho_k * np.cos(phi_k)\n        y_k = rho_k * np.sin(phi_k)\n        \n        unit_vectors = np.stack([x_k, y_k, z_k], axis=1)  # Shape (N, 3)\n        \n        # Relative and absolute positions of field points\n        field_points_rel = R * unit_vectors\n        field_points_abs = field_points_rel + centroid\n\n        # 6. Calculate Potentials\n        # Exact Potential V_exact(r_k)\n        # Broadcasting is used for an efficient calculation over all field points.\n        # dist_matrix[k, i] = |r_k - R_i|\n        dist_matrix = np.linalg.norm(field_points_abs[:, np.newaxis, :] - positions[np.newaxis, :, :], axis=2)\n        # V_exact[k] = sum_i q_i / |r_k - R_i|\n        V_exact = np.sum(charges / dist_matrix, axis=1)  # Shape (N,)\n        \n        # Multipole Potentials V_L(r'_k)\n        # Order L=0 (Monopole)\n        V0 = np.full(N, monopole_q / R if R != 0 else np.inf)\n        \n        # Order L=1 (Monopole + Dipole)\n        # V_dipole_term = (p . r') / |r'|^3\n        V_dipole_term = np.dot(field_points_rel, dipole_p) / (R**3)\n        V1 = V0 + V_dipole_term\n        \n        # Order L=2 (Monopole + Dipole + Quadrupole)\n        # V_quad_term = 1/2 \\sum Q_ab r'_a r'_b / |r'|^5\n        quad_form = np.einsum('ki,ij,kj-k', field_points_rel, quadrupole_Q, field_points_rel)\n        V_quad_term = 0.5 * quad_form / (R**5)\n        V2 = V1 + V_quad_term\n        \n        # 7. Calculate RMS Errors\n        rms0 = np.sqrt(np.mean((V_exact - V0)**2))\n        rms1 = np.sqrt(np.mean((V_exact - V1)**2))\n        rms2 = np.sqrt(np.mean((V_exact - V2)**2))\n        \n        return [rms0, rms1, rms2]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case A\n        {'fragment': np.array([[+1.0, 0.0, 0.0, 0.0], [+0.5, 1.0, 0.0, 0.0]]),\n         'R': 25.0, 'N': 64},\n        # Test case B\n        {'fragment': np.array([[+1.0, 0.0, 0.0, -1.0], [-1.0, 0.0, 0.0, +1.0]]),\n         'R': 30.0, 'N': 64},\n        # Test case C\n        {'fragment': np.array([[+1.0, +1.0, 0.0, 0.0], [+1.0, -1.0, 0.0, 0.0],\n                               [-1.0, 0.0, +1.0, 0.0], [-1.0, 0.0, -1.0, 0.0]]),\n         'R': 40.0, 'N': 64},\n        # Test case D\n        {'fragment': np.array([[+1.0, 0.0, 0.0, -5.0], [-1.0, 0.0, 0.0, +5.0]]),\n         'R': 10.0, 'N': 64},\n    ]\n\n    results = []\n    for case in test_cases:\n        rms_errors = compute_errors_for_case(case['fragment'], case['R'], case['N'])\n        results.append(rms_errors)\n\n    # Format final output string as per requirements\n    result_strings = []\n    for res in results:\n        # Each floating-point number must be rounded to exactly 8 decimal places.\n        formatted_res = [f\"{x:.8f}\" for x in res]\n        result_strings.append(f\"[{','.join(formatted_res)}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```", "id": "2464495"}]}