{"hands_on_practices": [{"introduction": "要真正掌握最少切换表面跳跃 (FSSH) 算法的精髓，没有什么比从头开始构建它更好的方法了。[@problem_id:2463158] 这个实践将指导你在一个简化的一维双态系统中，实现一个完整的 FSSH 模拟。通过对经典核运动、量子电子演化以及随机跳跃过程进行编程积分，你将对这些组件如何协同工作以模拟非绝热动力学，获得深刻且实用的理解。", "problem": "您需要实现一个一维双态最少切换表面跳跃 (FSSH) 模拟，使用无量纲原子单位 (a.u.)，角度以弧度为单位。该系统有两个绝热势能面 (PES)，由函数 $V_1(x) = \\sin(x)$ 和 $V_2(x) = \\cos(2x)$ 定义。核坐标为 $x(t)$，核速度为 $v(t)$。核质量为 $m$。动力学演化遵循以下原理。\n\n- 在当前活动绝热面上的经典核运动遵循牛顿第二定律：$m \\,\\dfrac{d^2 x}{dt^2} = -\\dfrac{d V_s(x)}{d x}$，其中 $s \\in \\{1,2\\}$ 是活动面的索引。\n\n- 电子振幅 $c_1(t)$ 和 $c_2(t)$ 在绝热表象中遵循含时薛定谔方程，其中包含一个非绝热耦合 (NAC) 函数 $d_{12}(x)$，并使用无量纲原子单位（其中约化普朗克常数为 $1$）。设 $E(x) = \\mathrm{diag}\\big(V_1(x), V_2(x)\\big)$，非绝热耦合矩阵为 $d(x)$，其元素为 $d_{12}(x)$、$d_{21}(x) = -\\,d_{12}(x)$ 和 $d_{11}(x)=d_{22}(x)=0$。则振幅动力学满足\n$$\n\\frac{d}{dt}\\begin{bmatrix} c_1 \\\\ c_2 \\end{bmatrix}\n= -\\,\\mathrm{i}\\,E(x)\\begin{bmatrix} c_1 \\\\ c_2 \\end{bmatrix}\n- v \\, d(x)\\begin{bmatrix} c_1 \\\\ c_2 \\end{bmatrix}.\n$$\n\n- 非绝热耦合函数规定为\n$$\nd_{12}(x) = \\kappa \\exp\\!\\left(-\\frac{(x-x_c)^2}{2\\,\\sigma^2}\\right),\n$$\n其中参数为 $\\kappa$、$x_c$ 和 $\\sigma > 0$。所有量均以原子单位表示；角度以弧度解释。\n\n- 最少切换表面跳跃 (FSSH) 规则指定了在一个时长为 $\\Delta t$ 的时间步内，从活动态 $i$ 到另一态 $j \\neq i$ 的随机跳跃概率为\n$$\ng_{i\\to j} = \\max\\!\\left(0,\\; \\frac{2\\,\\Delta t\\,\\Re\\!\\left[c_i^*(t)\\,c_j(t)\\,v(t)\\,d_{ij}(x(t))\\right]}{|c_i(t)|^2}\\right),\n$$\n其中，当 $(i,j)=(1,2)$ 时 $d_{ij}(x)$ 等于 $d_{12}(x)$，当 $(i,j)=(2,1)$ 时 $d_{21}(x)=-d_{12}(x)$。当一个从 $i\\to j$ 的跳跃被接受时，调整核速度以保持沿单一核自由度的总能量守恒，\n$$\n\\frac{1}{2} m\\,v'(t)^2 + V_j\\!\\big(x(t)\\big) \\;=\\; \\frac{1}{2} m\\,v(t)^2 + V_i\\!\\big(x(t)\\big),\n$$\n即，\n$$\nv'(t) = \\mathrm{sign}\\!\\big(v(t)\\big)\\,\\sqrt{\\,v(t)^2 + \\frac{2}{m}\\,\\big(V_i(x(t)) - V_j(x(t))\\big)\\,}\\,.\n$$\n如果平方根内的参数为负，则该跳跃作为受挫跳跃被拒绝，活动态保持为 $i$，速度不变。复振幅在任何时候都必须归一化，以使 $|c_1|^2+|c_2|^2=1$。初始振幅在初始活动面 $s$ 上满足 $c_s(0)=1$，在另一表面上满足 $c_{3-s}(0)=0$。\n\n- 初始条件：$x(0)=x_0$、$v(0)=v_0$、质量 $m$、时间步长 $\\Delta t$ 和总模拟时间 $T$。总离散步数为 $N=\\lfloor T/\\Delta t \\rceil$，因此模拟的最终时间为 $N\\,\\Delta t$。使用一个以给定整数 $r$ 为种子的伪随机数生成器来决定跳跃，以确保可复现性。\n\n对于下面的每个测试用例，从 $t=0$ 模拟到 $t=T$，并输出最终位置 $x(T)$、最终速度 $v(T)$、最终活动面索引 $s(T)\\in\\{1,2\\}$ 以及接受的跳跃总数（一个整数计数）。将 $x(T)$ 和 $v(T)$ 以原子单位 (a.u.) 表示，并四舍五入到六位小数。角度必须以弧度处理。\n\n测试套件（所有量均以原子单位表示，角度以弧度为单位）：\n\n- 情况 A (一般交叉)：$m=1$，$x_0=-2.0$，$v_0=1.2$，$\\kappa=0.5$，$x_c=0.0$，$\\sigma=0.6$，$\\Delta t=0.002$，$T=10.0$，初始表面 $s=1$，随机种子 $r=1337$。\n\n- 情况 B (无耦合)：$m=1$，$x_0=-1.0$，$v_0=0.8$，$\\kappa=0.0$，$x_c=0.0$，$\\sigma=0.6$，$\\Delta t=0.002$，$T=4.0$，初始表面 $s=1$，随机种子 $r=42$。\n\n- 情况 C (从第二表面开始)：$m=1$，$x_0=-3.0$，$v_0=2.0$，$\\kappa=0.7$，$x_c=-1.0$，$\\sigma=0.4$，$\\Delta t=0.0015$，$T=6.0$，初始表面 $s=2$，随机种子 $r=2023$。\n\n- 情况 D (强耦合，慢通过)：$m=1$，$x_0=0.0$，$v_0=0.3$，$\\kappa=1.0$，$x_c=0.0$，$\\sigma=0.2$，$\\Delta t=0.001$，$T=8.0$，初始表面 $s=1$，随机种子 $r=7$。\n\n您的程序应生成单行输出，其中包含一个逗号分隔的各用例结果列表。每个用例结果是一个形如 $[x(T),v(T),s(T),\\text{hops}]$ 的列表，其中 $x(T)$ 和 $v(T)$ 四舍五入到六位小数，$s(T)$ 和 $\\text{hops}$ 为整数。四个用例的结果必须包含在一个外部列表中，并按 A、B、C、D 的顺序打印。例如，一个有效的输出格式是 $[[x_A,v_A,s_A,h_A],[x_B,v_B,s_B,h_B],[x_C,v_C,s_C,h_C],[x_D,v_D,s_D,h_D]]$，具有指定的四舍五入和类型。", "solution": "该问题要求实现一个一维双态的最少切换表面跳跃 (FSSH) 模拟。这是一个基于成熟半经典方法的有效且适定的计算物理问题。一个完整的解决方案需要对给定势能面和参数下的耦合经典-量子运动方程进行数值积分。\n\n首先，我们定义物理系统的各个组成部分。两个绝热势能面 (PES) 由 $V_1(x) = \\sin(x)$ 和 $V_2(x) = \\cos(2x)$ 给出。对应的作用在质量为 $m$ 的核上的力是 $F_1(x) = -\\frac{d V_1(x)}{dx} = -\\cos(x)$ 和 $F_2(x) = -\\frac{d V_2(x)}{dx} = 2\\sin(2x)$。两态之间的非绝热耦合 (NAC) 由函数 $d_{12}(x) = \\kappa \\exp\\left(-\\frac{(x-x_c)^2}{2\\sigma^2}\\right)$ 给出，并具有性质 $d_{21}(x) = -d_{12}(x)$。\n\n该模拟涉及一个时间步进程序来传播系统状态，该状态包括核位置 $x(t)$、速度 $v(t)$、活动电子面索引 $s(t) \\in \\{1, 2\\}$ 以及复电子振幅 $c_1(t)$ 和 $c_2(t)$。总步数是 $N = \\lfloor T/\\Delta t \\rceil$，这被解释为将 $T/\\Delta t$ 四舍五入到最近的整数。\n\n解决方案的核心是数值积分算法。虽然问题没有指定积分器，但对此类模拟而言，一个标准且稳健的选择是结合用于核运动的速度 Verlet 算法的对称分裂算符方法。此方法能确保经典和量子子系统之间的稳定性和适当同步。从 $t_n$ 到 $t_{n+1} = t_n + \\Delta t$ 的单个时间步的步骤如下：\n\n设时间 $t_n$ 的状态为 $(x_n, v_n, \\mathbf{c}_n, s_n)$，其中 $\\mathbf{c}_n = [c_{1,n}, c_{2,n}]^T$，$s_n$ 是活动面索引。\n\n1.  **核传播**：使用速度 Verlet 算法在当前活动面 $s_n$ 上将核坐标从 $t_n$ 传播到 $t_{n+1}$。这会产生一个暂定的最终位置和速度。\n    - 首先，计算在位置 $x_n$ 处活动面 $s_n$ 上的力：$F_n = - \\frac{d V_{s_n}}{dx}(x_n)$。\n    - 将速度推进半步：$v_{n+1/2} = v_n + \\frac{F_n}{2m} \\Delta t$。\n    - 将位置推进一个整步：$x_{n+1} = x_n + v_{n+1/2} \\Delta t$。\n    - 计算在新位置上同一表面的暂定力：$F_{n+1}^{(s_n)} = - \\frac{d V_{s_n}}{dx}(x_{n+1})$。\n    - 计算暂定的最终速度：$v_{n+1}^{(s_n)} = v_{n+1/2} + \\frac{F_{n+1}^{(s_n)}}{2m} \\Delta t$。\n\n2.  **电子传播**：通过求解含时薛定谔方程 $\\frac{d\\mathbf{c}}{dt} = -i \\mathbf{H}_{el} \\mathbf{c}$，将电子振幅 $\\mathbf{c}_n$ 传播到 $\\mathbf{c}_{n+1}$。绝热基下的电子哈密顿量为：\n    $$\n    \\mathbf{H}_{el}(x, v) = \\begin{bmatrix} V_1(x) & -i v d_{12}(x) \\\\ i v d_{12}(x) & V_2(x) \\end{bmatrix}\n    $$\n    在一个时间步 $\\Delta t$ 上的形式解是 $\\mathbf{c}_{n+1} = \\exp(-i \\mathbf{H}_{el} \\Delta t) \\mathbf{c}_n$。为了获得更好的精度，哈密顿量 $\\mathbf{H}_{el}$ 使用区间内的代表性位置和速度值进行评估，例如中点值 $x_{\\text{mid}} = (x_n+x_{n+1})/2$ 和 $v_{\\text{mid}} = v_{n+1/2}$。矩阵指数通过数值方法计算。传播后，对振幅矢量进行重新归一化，$\\mathbf{c}_{n+1} \\leftarrow \\mathbf{c}_{n+1} / \\|\\mathbf{c}_{n+1}\\|$，以校正任何数值漂移并确保概率守恒，即 $|c_1|^2 + |c_2|^2 = 1$。\n\n3.  **表面跳跃决策**：做出是否切换电子表面的随机决策。设活动面为 $i=s_n$，另一面为 $j=3-i$。使用时间步结束时的系统状态计算跳跃概率：\n    $$\n    g_{i\\to j} = \\max\\!\\left(0,\\; \\frac{2\\,\\Delta t\\,\\Re\\!\\left[c_{i, n+1}^*(t)\\,c_{j, n+1}(t)\\,v_{n+1}^{(i)}\\,d_{ij}(x_{n+1})\\right]}{|c_{i, n+1}(t)|^2}\\right)\n    $$\n    生成一个均匀分布的随机数 $\\zeta \\in [0, 1]$。如果 $\\zeta  g_{i \\to j}$，则尝试进行一次跳跃。\n\n4.  **速度调整与跳跃最终确定**：如果尝试从表面 $i$ 跳到 $j$，必须检查能量守恒。新的动能必须为非负。\n    - 我们测试条件 $(v_{n+1}^{(i)})^2 + \\frac{2}{m}(V_i(x_{n+1}) - V_j(x_{n+1})) \\ge 0$ 是否满足。\n    - 如果为真（跳跃被接受），则将活动面更新为 $s_{n+1} = j$，跳跃计数器加一，并重新缩放速度以保持总能量守恒：\n      $$\n      v_{n+1} = \\mathrm{sign}(v_{n+1}^{(i)})\\,\\sqrt{ (v_{n+1}^{(i)})^2 + \\frac{2}{m}(V_i(x_{n+1}) - V_j(x_{n+1})) }\n      $$\n    - 如果为假（跳跃受挫），系统停留在原始表面，$s_{n+1} = i$，速度不变，$v_{n+1} = v_{n+1}^{(i)}$。\n    - 如果没有尝试跳跃，系统也停留在原始表面，速度未经调整，$s_{n+1}=i$ 且 $v_{n+1}=v_{n+1}^{(i)}$。\n\n这个四步过程重复 $N$ 个时间步。对于每个测试用例，使用提供的参数（包括用于随机跳跃决策可复现性的随机种子 $r$）来初始化模拟。记录最终位置 $x(T)$、速度 $v(T)$、活动面索引 $s(T)$ 和接受的跳跃总数。\n\n该实现利用 Python 及其 `numpy` 库进行数值运算，并使用 `scipy.linalg.expm` 来计算矩阵指数，这是此类科学计算的标准做法。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef solve():\n    \"\"\"\n    Implements a one-dimensional, two-state Fewest Switches Surface Hopping (FSSH) simulation.\n    \"\"\"\n\n    # --- Define physical system functions ---\n    def V1(x):\n        return np.sin(x)\n\n    def dV1dx(x):\n        return np.cos(x)\n\n    def V2(x):\n        return np.cos(2 * x)\n\n    def dV2dx(x):\n        return -2 * np.sin(2 * x)\n\n    def d12(x, kappa, xc, sigma):\n        return kappa * np.exp(-((x - xc)**2) / (2 * sigma**2))\n\n    # --- Test suite from the problem statement ---\n    test_cases = [\n        # Case A: m, x0, v0, kappa, xc, sigma, dt, T, s_initial, seed\n        (1.0, -2.0, 1.2, 0.5, 0.0, 0.6, 0.002, 10.0, 1, 1337),\n        # Case B:\n        (1.0, -1.0, 0.8, 0.0, 0.0, 0.6, 0.002, 4.0, 1, 42),\n        # Case C:\n        (1.0, -3.0, 2.0, 0.7, -1.0, 0.4, 0.0015, 6.0, 2, 2023),\n        # Case D:\n        (1.0, 0.0, 0.3, 1.0, 0.0, 0.2, 0.001, 8.0, 1, 7),\n    ]\n\n    results = []\n    \n    # Store potentials and forces in lists for easy indexing (0-indexed)\n    potentials = [V1, V2]\n    forces_func = [lambda x: -dV1dx(x), lambda x: -dV2dx(x)]\n\n    # --- Main simulation loop for each test case ---\n    for case in test_cases:\n        m, x0, v0, kappa, xc, sigma, dt, T, s_initial, seed = case\n        \n        # Initialize state\n        x = x0\n        v = v0\n        s = s_initial  # Active surface index (1 or 2)\n        \n        c = np.zeros(2, dtype=np.complex128)\n        c[s - 1] = 1.0 + 0.0j\n        \n        hops = 0\n        rng = np.random.default_rng(seed)\n        \n        num_steps = int(round(T / dt))\n\n        for _ in range(num_steps):\n            # i is 0-indexed surface, j is the other surface\n            i = s - 1\n            j = 1 - i\n\n            # --- 1. Nuclear Propagation (Velocity Verlet) ---\n            # Propagate on the current active surface 'i'\n            force_current = forces_func[i](x)\n            v_half = v + 0.5 * force_current / m * dt\n            x_new = x + v_half * dt\n            \n            force_new_i = forces_func[i](x_new)\n            v_new_i = v_half + 0.5 * force_new_i / m * dt\n\n            # --- 2. Electronic Propagation ---\n            # Use midpoint values for better accuracy\n            x_mid = (x + x_new) / 2\n            v_mid = v_half\n            \n            d12_val = d12(x_mid, kappa, xc, sigma)\n            H_el = np.array([\n                [potentials[0](x_mid), -1j * v_mid * d12_val],\n                [1j * v_mid * d12_val,  potentials[1](x_mid)]\n            ], dtype=np.complex128)\n            \n            # Propagate electronic coefficients using matrix exponential\n            c_new = expm(-1j * H_el * dt) @ c\n            \n            # Renormalize to conserve probability\n            c_new /= np.linalg.norm(c_new)\n\n            # --- 3. Surface Hopping Decision ---\n            # Use state at the end of the step\n            d12_new = d12(x_new, kappa, xc, sigma)\n            \n            # d_ij term depends on direction of hop\n            # From i to j: use d_ji. In our notation, d_{01} = d12, d_{10} = -d12\n            d_ij = d12_new if i == 0 else -d12_new \n            \n            # Hopping probability from surface i to j\n            c_i_sq = np.abs(c_new[i])**2\n            if c_i_sq  1e-12: # Avoid division by zero\n                # Note: c_i^* c_j v d_ij\n                # c_new[i].conj() * c_new[j] gives c_0^* c_1 or c_1^* c_0\n                # v_new_i is used as the velocity for the step\n                # d_ij is d_{01} or d_{10}\n                numerator = 2.0 * dt * np.real(c_new[i].conj() * c_new[j] * v_new_i * d_ij)\n                g_ij = max(0.0, numerator / c_i_sq)\n            else:\n                g_ij = 0.0\n\n            s_new = s\n            v_new = v_new_i\n            \n            if rng.random()  g_ij:\n                # --- 4. Velocity Adjustment (Hop Attempted) ---\n                v_sq_current = v_new_i**2\n                delta_V = potentials[i](x_new) - potentials[j](x_new)\n                \n                v_sq_new = v_sq_current + 2.0 / m * delta_V\n                \n                if v_sq_new = 0: # Hop accepted\n                    s_new = j + 1\n                    hops += 1\n                    v_new = np.sign(v_new_i) * np.sqrt(v_sq_new)\n                # Else: Frustrated hop, state remains unchanged (s_new=s, v_new=v_new_i)\n\n            # Update state for the next step\n            x, v, s, c = x_new, v_new, s_new, c_new\n\n        # Format results for this case\n        results.append(f\"[{x:.6f},{v:.6f},{s},{hops}]\")\n        \n    # --- Final Output ---\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2463158"}, {"introduction": "在一维模型的基础上，[@problem_id:2463200] 这个练习将带你进入更真实的二维系统世界。在二维空间中模拟动力学，需要我们将标量概念扩展为矢量，包括位置、动量、力以及非绝热耦合。这项实践将挑战你在二维势能面上实现 FSSH 算法，并特别关注在跳跃过程中为保持能量守恒所需的基于矢量的动量重标度方法。", "problem": "您需要实现一个完整的、可运行的程序，模拟一个与两个绝热电子态耦合的单个经典核的二维最少切换表面跳跃 (FSSH) 轨道。该模拟应以原子单位进行。势能面和非绝热耦合 (NAC) 矢量场以模仿用户勾画的景观的方式进行参数化，但您必须使用下面提供的精确数学定义以及指定的测试套件。您的程序必须计算每个测试用例的最终活性电子态指数，并将所有结果以方括号括起来的逗号分隔列表形式单行输出。\n\n需要实现的数学模型（原子单位，其中普朗克常数 $1$）：\n\n- 几何与运动学：\n  - 核位置为 $\\mathbf{R}(t) = (x(t), y(t))$，核动量为 $\\mathbf{P}(t) = (p_x(t), p_y(t))$。\n  - 质量为 $M$（标量，对 $x$ 和 $y$ 相同），因此核速度为 $\\dot{\\mathbf{R}}(t) = \\mathbf{P}(t)/M$。\n\n- 势能面：\n  - 两个绝热势能面 $E_1(\\mathbf{R})$ 和 $E_2(\\mathbf{R})$ 分别定义为中心在 $( -x_c, 0 )$ 和 $( +x_c, 0 )$ 的高斯凸起，具有相同的高度和宽度：\n    $$E_1(x,y) = A \\exp\\!\\left(-\\frac{(x + x_c)^2 + y^2}{\\sigma^2}\\right), \\quad E_2(x,y) = A \\exp\\!\\left(-\\frac{(x - x_c)^2 + y^2}{\\sigma^2}\\right)。$$\n  - 相应的梯度为\n    $$\\nabla E_1(x,y) = -\\frac{2A}{\\sigma^2}\\exp\\!\\left(-\\frac{(x + x_c)^2 + y^2}{\\sigma^2}\\right)\\begin{bmatrix}x + x_c \\\\ y\\end{bmatrix}, \\quad \\nabla E_2(x,y) = -\\frac{2A}{\\sigma^2}\\exp\\!\\left(-\\frac{(x - x_c)^2 + y^2}{\\sigma^2}\\right)\\begin{bmatrix}x - x_c \\\\ y\\end{bmatrix}。$$\n\n- 非绝热耦合 (NAC) 矢量场：\n  - 唯一非零的 NAC 矢量是 $\\mathbf{d}_{12}(\\mathbf{R})$，且 $\\mathbf{d}_{21}(\\mathbf{R}) = -\\mathbf{d}_{12}(\\mathbf{R})$，其中 $\\mathbf{d}_{11}(\\mathbf{R}) = \\mathbf{d}_{22}(\\mathbf{R}) = \\mathbf{0}$。\n  - NAC 矢量场是一个具有指定恒定方向 $\\hat{\\mathbf{u}} = (u_x, u_y)$（$\\|\\hat{\\mathbf{u}}\\| = 1$）、中心在 $(x_{\\mathrm{NAC}}, y_{\\mathrm{NAC}})$、振幅为 $C$、宽度参数为 $\\lambda$ 的局域高斯函数：\n    $$\\mathbf{d}_{12}(x,y) = \\frac{C}{\\lambda}\\exp\\!\\left(-\\frac{(x - x_{\\mathrm{NAC}})^2 + (y - y_{\\mathrm{NAC}})^2}{\\lambda^2}\\right)\\hat{\\mathbf{u}}。$$\n\n- 电子振幅：\n  - 在绝热表象中，电子态矢量为 $\\mathbf{c}(t) = \\big(c_1(t), c_2(t)\\big)$，满足 $\\|\\mathbf{c}(t)\\|^2 = |c_1(t)|^2 + |c_2(t)|^2 = 1$。\n  - 振幅的含时薛定谔方程为\n    $$i\\frac{d c_k}{dt} = E_k(\\mathbf{R})c_k - i\\sum_{\\ell=1}^{2} \\big(\\dot{\\mathbf{R}}\\cdot \\mathbf{d}_{k\\ell}(\\mathbf{R})\\big)c_\\ell, \\quad k \\in \\{1,2\\}。$$\n\n- 活性势能面上的核运动方程：\n  - 设活性势能面指数为 $s(t)\\in\\{1,2\\}$。核在活性势能面上遵循经典动力学：\n    $$\\dot{\\mathbf{R}} = \\frac{\\mathbf{P}}{M}, \\quad \\dot{\\mathbf{P}} = -\\nabla E_{s(t)}(\\mathbf{R})。$$\n\n- 跳跃概率与决策：\n  - 在时间步长 $\\Delta t$ 内，从当前活性态 $k$ 跳跃到另一个态 $\\ell\\neq k$ 的瞬时概率为\n    $$g_{k\\to \\ell} = \\max\\left(0, \\frac{2\\,\\Delta t\\,\\mathrm{Re}\\!\\left[c_k^*(t)\\,c_\\ell(t)\\,\\big(\\dot{\\mathbf{R}}(t)\\cdot \\mathbf{d}_{k\\ell}(\\mathbf{R}(t))\\big)\\right]}{|c_k(t)|^2}\\right)。$$\n  - 在每个测试用例开始时，使用整数 $12345$ 作为种子，初始化一个在 $[0,1)$ 区间上的均匀随机数生成器。如果随机变量 $r$ 满足 $r  g_{k\\to \\ell}$，则发生跳跃 $k\\to \\ell$，否则该步不发生跳跃。\n\n- 成功跳跃后的动量重标度：\n  - 设 $\\Delta E = E_\\ell(\\mathbf{R}) - E_k(\\mathbf{R})$ 为跳跃位置的能量差。\n  - 设 $\\hat{\\mathbf{n}} = \\mathbf{d}_{k\\ell}(\\mathbf{R})/\\|\\mathbf{d}_{k\\ell}(\\mathbf{R})\\|$ 为沿 NAC 方向的单位矢量。仅沿 $\\hat{\\mathbf{n}}$ 方向重标度动量以保持总能量守恒：\n    $$\\mathbf{P}' = \\mathbf{P} + \\alpha\\,\\hat{\\mathbf{n}}, \\quad \\text{其中 } \\alpha \\text{ 的选择需满足 } \\frac{\\|\\mathbf{P}'\\|^2}{2M} + E_\\ell(\\mathbf{R}) = \\frac{\\|\\mathbf{P}\\|^2}{2M} + E_k(\\mathbf{R})。$$\n  - 标量 $\\alpha$ 必须满足二次方程\n    $$\\alpha^2 + 2\\alpha\\,(\\mathbf{P}\\cdot \\hat{\\mathbf{n}}) + 2M\\,\\Delta E = 0。$$\n    如果判别式为负或 $\\|\\mathbf{d}_{k\\ell}(\\mathbf{R})\\|=0$，则声明为受阻跳跃并保持当前状态（不对 $\\mathbf{P}$ 做任何改变）。如果允许跳跃，则选择\n    $$\\alpha = -(\\mathbf{P}\\cdot \\hat{\\mathbf{n}}) + \\mathrm{sign}\\!\\big(\\mathbf{P}\\cdot \\hat{\\mathbf{n}}\\big)\\sqrt{(\\mathbf{P}\\cdot \\hat{\\mathbf{n}})^2 - 2M\\,\\Delta E}。$$\n\n所有情况通用的数值参数：\n- 使用 $A = 0.02$, $\\sigma = 1.0$, $x_c = 1.0$。\n- 使用 $M = 10.0$。\n- 使用时间步长 $\\Delta t = 0.01$，总模拟时间 $T = 40.0$，即 $N = 4000$ 个等长步。\n- 在每个时间步后对电子振幅 $\\mathbf{c}(t)$ 进行归一化，以强制 $\\|\\mathbf{c}(t)\\|=1$。\n- 所有量均采用原子单位。\n\n测试套件（四个独立的模拟）。在每个案例中，用种子 $12345$ 初始化随机数生成器。\n\n- 案例 1（顺利路径，强耦合中心位于轨道上）：\n  - 初始核位置 $(x_0, y_0) = (-4.0, 0.0)$。\n  - 初始核动量 $(p_{x,0}, p_{y,0}) = (5.0, 0.0)$。\n  - 初始电子态：活性势能面 $s(0) = 1$，振幅 $\\mathbf{c}(0) = (1+0i,\\,0+0i)$。\n  - NAC 参数：$C = 4.0$, $\\lambda = 1.0$, $(x_{\\mathrm{NAC}}, y_{\\mathrm{NAC}}) = (0.0, 0.0)$, $\\hat{\\mathbf{u}} = (1.0, 0.0)$。\n\n- 案例 2（边界情况，零耦合）：\n  - 与案例 1 相同，除了 NAC 振幅 $C = 0.0$。\n\n- 案例 3（反向和初始状态）：\n  - 初始核位置 $(x_0, y_0) = (4.0, 0.0)$。\n  - 初始核动量 $(p_{x,0}, p_{y,0}) = (-5.0, 0.0)$。\n  - 初始电子态：活性势能面 $s(0) = 2$，振幅 $\\mathbf{c}(0) = (0+0i,\\,1+0i)$。\n  - NAC 参数：$C = 4.0$, $\\lambda = 1.0$, $(x_{\\mathrm{NAC}}, y_{\\mathrm{NAC}}) = (0.0, 0.0)$, $\\hat{\\mathbf{u}} = (1.0, 0.0)$。\n\n- 案例 4（边缘情况，NAC 中心偏离路径）：\n  - 与案例 1 相同，除了 NAC 中心 $(x_{\\mathrm{NAC}}, y_{\\mathrm{NAC}}) = (0.0, 3.0)$，且 $C = 4.0$，$λ = 1.0$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含一个方括号括起来的逗号分隔列表形式的结果。对于每个案例，按案例 1 到 4 的顺序报告在时间 $T$ 时的最终活性势能面指数，为整数 $1$ 或 $2$。例如，一个有效的输出行为 “[1,2,1,2]”（不含引号）。\n\n没有用户输入。所有常数和初始条件均已提供。所有计算和最终输出都必须以原子单位进行，本问题不使用角度。", "solution": "该问题陈述经过了严格验证，并被认定为有效。它在科学上基于非绝热量子动力学原理，特别是最少切换表面跳跃（FSSH）算法，这是计算化学中一种标准的半经典方法。该问题定义明确，为四个不同的测试案例提供了一套完整且一致的数学定义、物理常数、初始条件，以及一个精确的数值积分方案。所有术语都得到了客观且明确的定义。该问题是基于已建立的物理理论进行数值模拟的形式化请求，因此是可解的。\n\n任务是模拟一个质量为 $M$ 的经典核在二维空间 $\\mathbf{R}(t) = (x(t), y(t))$ 中运动的轨道，同时与两个量子电子态耦合。其动力学由 FSSH 算法控制。在任意给定时间 $t$，系统由核的位置 $\\mathbf{R}(t)$ 和动量 $\\mathbf{P}(t)$、电子波函数系数 $\\mathbf{c}(t) = (c_1(t), c_2(t))$ 以及活性电子势能面指数 $s(t) \\in \\{1, 2\\}$ 来表征。\n\n模拟通过在总时间 $T$ 内以离散时间步长 $\\Delta t$ 对运动方程进行数值积分来进行。在从 $t$ 到 $t+\\Delta t$ 的每个时间步长内的工作流程如下：\n\n1.  **核传播**：核在当前活性势能面 (PES) $E_{s(t)}(\\mathbf{R})$ 上进行经典运动。运动方程是牛顿第二定律 $\\dot{\\mathbf{P}} = -\\nabla E_{s(t)}(\\mathbf{R})$ 和 $\\dot{\\mathbf{R}} = \\mathbf{P}/M$。我们采用速度 Verlet 算法以实现稳定和精确的积分。给定状态 $(\\mathbf{R}(t), \\mathbf{P}(t))$ 和活性势能面 $s(t)$：\n    -   首先，计算当前位置的力：$\\mathbf{F}(t) = -\\nabla E_{s(t)}(\\mathbf{R}(t))$。\n    -   将动量更新到半步：$\\mathbf{P}(t+\\Delta t/2) = \\mathbf{P}(t) + \\mathbf{F}(t) \\frac{\\Delta t}{2}$。\n    -   将位置更新一个完整步长：$\\mathbf{R}(t+\\Delta t) = \\mathbf{R}(t) + \\frac{\\mathbf{P}(t+\\Delta t/2)}{M} \\Delta t$。\n    -   确定新位置的力，仍然在同一势能面 $s(t)$ 上：$\\mathbf{F}(t+\\Delta t) = -\\nabla E_{s(t)}(\\mathbf{R}(t+\\Delta t))$。\n    -   更新动量的第二个半步，以获得在该步结束时的临时动量：$\\mathbf{P}_{\\text{temp}}(t+\\Delta t) = \\mathbf{P}(t+\\Delta t/2) + \\mathbf{F}(t+\\Delta t) \\frac{\\Delta t}{2}$。该动量将作为跳跃决策的基础。\n\n2.  **电子传播**：电子系数 $c_k(t)$ 根据绝热表象中的含时薛定谔方程 (TDSE) 演化：\n    $$i\\frac{d c_k}{dt} = E_k(\\mathbf{R})c_k - i\\sum_{\\ell=1}^{2} \\big(\\dot{\\mathbf{R}}\\cdot \\mathbf{d}_{k\\ell}(\\mathbf{R})\\big)c_\\ell$$\n    我们使用一阶前向欧拉法来积分这个方程，这对于给定的小时间步长 $\\Delta t$ 来说是足够的。导数 $\\dot{c}_k(t)$ 是使用时间步开始时的状态 $(\\mathbf{R}(t), \\mathbf{P}(t), \\mathbf{c}(t))$ 计算的。然后将更新后的系数归一化以保持总概率，即 $\\|\\mathbf{c}(t+\\Delta t)\\|^2=1$。\n\n3.  **跳跃概率计算**：在传播核和电子之后，进行一个随机决策，以决定是否切换活性电子势能面。从当前活性态 $k$ 跳跃到另一个态 $\\ell$ 的概率计算如下：\n    $$g_{k\\to \\ell} = \\max\\left(0, \\frac{2\\,\\Delta t\\,\\mathrm{Re}\\!\\left[c_k^*(t)\\,c_\\ell(t)\\,\\big(\\dot{\\mathbf{R}}(t)\\cdot \\mathbf{d}_{k\\ell}(\\mathbf{R}(t))\\big)\\right]}{|c_k(t)|^2}\\right)$$\n    此概率使用时间间隔开始时的状态变量 $(\\mathbf{R}(t), \\mathbf{P}(t), \\mathbf{c}(t))$ 计算。将一个均匀生成的随机数 $r \\in [0,1)$ 与 $g_{k\\to \\ell}$ 进行比较。如果 $r  g_{k\\to \\ell}$，则尝试进行跳跃。\n\n4.  **跳跃决策和动量重标度**：如果尝试从态 $k$ 跳跃到态 $\\ell$，必须强制执行能量守恒。在跳跃位置 $\\mathbf{R}(t+\\Delta t)$ 的势能变化为 $\\Delta E = E_\\ell(\\mathbf{R}(t+\\Delta t)) - E_k(\\mathbf{R}(t+\\Delta t))$。这必须通过核动能的变化来补偿。动量沿着非绝热耦合矢量的方向 $\\hat{\\mathbf{n}} = \\mathbf{d}_{k\\ell}(\\mathbf{R}(t+\\Delta t))/\\|\\mathbf{d}_{k\\ell}(\\mathbf{R}(t+\\Delta t))\\|$ 进行重标度。对动量的调整 $\\alpha$（即 $\\mathbf{P}' = \\mathbf{P}_{\\text{temp}}(t+\\Delta t) + \\alpha\\,\\hat{\\mathbf{n}}$）通过求解由能量守恒产生的二次方程得到：\n    $$\\alpha^2 + 2\\alpha\\,\\big(\\mathbf{P}_{\\text{temp}}(t+\\Delta t)\\cdot \\hat{\\mathbf{n}}\\big) + 2M\\,\\Delta E = 0$$\n    只有当判别式非负时，$\\alpha$ 才存在实数解：$\\big(\\mathbf{P}_{\\text{temp}}(t+\\Delta t)\\cdot \\hat{\\mathbf{n}}\\big)^2 - 2M\\,\\Delta E \\geq 0$。如果此条件成立且耦合矢量非零，则跳跃成功。我们选择使动量变化最小的 $\\alpha$ 解。活性态更新为 $s(t+\\Delta t) = \\ell$，该步的最终动量为 $\\mathbf{P}(t+\\Delta t) = \\mathbf{P}'$。如果判别式为负或 $\\|\\mathbf{d}_{k\\ell}\\|=0$，则跳跃是“受阻的”并被拒绝。系统保持在原始势能面上，因此 $s(t+\\Delta t) = k$，且动量不作调整，$\\mathbf{P}(t+\\Delta t) = \\mathbf{P}_{\\text{temp}}(t+\\Delta t)$。如果没有尝试跳跃，状态和动量也同样在没有变化的情况下最终确定。\n\n这个四步过程会重复执行总步数 $N = T/\\Delta t$ 次。对于每个测试案例，使用指定的参数初始化模拟，并记录最终的活性势能面指数 $s(T)$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Main function to run the FSSH simulation for all test cases and print results.\n    \"\"\"\n    \n    # Global constants defined in the problem\n    A = 0.02\n    SIGMA = 1.0\n    XC = 1.0\n    M = 10.0\n    DT = 0.01\n    T_TOTAL = 40.0\n    N_STEPS = int(T_TOTAL / DT)\n\n    # --- Mathematical Model Implementation ---\n\n    def E1(R):\n        \"\"\"Potential energy of surface 1.\"\"\"\n        x, y = R\n        return A * np.exp(-((x + XC)**2 + y**2) / SIGMA**2)\n\n    def E2(R):\n        \"\"\"Potential energy of surface 2.\"\"\"\n        x, y = R\n        return A * np.exp(-((x - XC)**2 + y**2) / SIGMA**2)\n\n    def grad_E1(R):\n        \"\"\"Gradient of potential energy surface 1.\"\"\"\n        x, y = R\n        prefactor = - (2.0 * A / SIGMA**2) * np.exp(-((x + XC)**2 + y**2) / SIGMA**2)\n        return prefactor * np.array([x + XC, y])\n\n    def grad_E2(R):\n        \"\"\"Gradient of potential energy surface 2.\"\"\"\n        x, y = R\n        prefactor = - (2.0 * A / SIGMA**2) * np.exp(-((x - XC)**2 + y**2) / SIGMA**2)\n        return prefactor * np.array([x - XC, y])\n\n    def d12(R, C, lam, R_nac, u_hat):\n        \"\"\"Nonadiabatic coupling vector d_12.\"\"\"\n        x, y = R\n        x_nac, y_nac = R_nac\n        prefactor = (C / lam) * np.exp(-((x - x_nac)**2 + (y - y_nac)**2) / lam**2)\n        return prefactor * u_hat\n\n    def simulate(R0, P0, s0, c0, nac_params):\n        \"\"\"\n        Performs a single FSSH trajectory simulation for one test case.\n        \"\"\"\n        rng = np.random.default_rng(12345)\n\n        R = np.array(R0, dtype=float)\n        P = np.array(P0, dtype=float)\n        s = s0\n        c = np.array(c0, dtype=complex)\n\n        energies_funcs = [E1, E2]\n        gradients_funcs = [grad_E1, grad_E2]\n\n        for _ in range(N_STEPS):\n            # --- 1. Propagate nuclei using Velocity Verlet ---\n            active_idx = s - 1\n            \n            # F = -grad(E), so P_dot = -grad(E)\n            F_t = -gradients_funcs[active_idx](R)\n            \n            P_half = P + F_t * DT / 2.0\n            R_new = R + P_half / M * DT\n            \n            # Force at new position, still on the same surface 's'\n            F_t_plus_dt = -gradients_funcs[active_idx](R_new)\n            P_pre_hop = P_half + F_t_plus_dt * DT / 2.0\n\n            # --- 2. Propagate electronic coefficients using Forward Euler ---\n            E_k = np.array([E1(R), E2(R)])\n            V = P / M\n            d12_vec_t = d12(R, **nac_params)\n            V_dot_d12 = np.dot(V, d12_vec_t)\n\n            c_dot = np.zeros(2, dtype=complex)\n            c_dot[0] = -1j * E_k[0] * c[0] - V_dot_d12 * c[1]\n            c_dot[1] = -1j * E_k[1] * c[1] + V_dot_d12 * c[0]\n            \n            c_new = c + c_dot * DT\n            c_new /= np.linalg.norm(c_new)\n\n            # --- 3. Calculate hopping probability ---\n            k, l = s, 3 - s\n            k_idx, l_idx = k - 1, l - 1\n\n            d_kl_vec_t = d12_vec_t if k == 1 else -d12_vec_t\n            V_dot_dkl = np.dot(V, d_kl_vec_t)\n\n            numerator = 2.0 * DT * np.real(c[k_idx].conj() * c[l_idx]) * V_dot_dkl\n            denominator = np.abs(c[k_idx])**2\n            \n            g_kl = 0.0\n            if denominator  1e-12:\n                g_kl = max(0.0, numerator / denominator)\n\n            # --- 4. Hopping decision and momentum resale ---\n            P_final = P_pre_hop\n            s_new = s\n\n            if rng.random()  g_kl: # Attempt hop\n                delta_E = energies_funcs[l_idx](R_new) - energies_funcs[k_idx](R_new)\n                d_kl_vec_new = d12(R_new, **nac_params) if k == 1 else -d12(R_new, **nac_params)\n                d_kl_norm = np.linalg.norm(d_kl_vec_new)\n\n                if d_kl_norm  1e-12:\n                    n_hat = d_kl_vec_new / d_kl_norm\n                    P_dot_n = np.dot(P_pre_hop, n_hat)\n                    discriminant = P_dot_n**2 - 2.0 * M * delta_E\n\n                    if discriminant = 0:\n                        # Successful hop\n                        alpha = -P_dot_n + np.sign(P_dot_n) * np.sqrt(discriminant)\n                        P_final = P_pre_hop + alpha * n_hat\n                        s_new = l\n                # If d_kl_norm is too small or discriminant is negative, it's a frustrated hop.\n                # In that case, s and P remain unchanged from their pre-hop values.\n            \n            # --- 5. Update state variables for the next step ---\n            R, P, s, c = R_new, P_final, s_new, c_new\n\n        return s\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        {\n            \"R0\": [-4.0, 0.0], \"P0\": [5.0, 0.0], \"s0\": 1, \"c0\": [1.0 + 0.0j, 0.0 + 0.0j],\n            \"nac_params\": {\"C\": 4.0, \"lam\": 1.0, \"R_nac\": [0.0, 0.0], \"u_hat\": np.array([1.0, 0.0])}\n        },\n        # Case 2\n        {\n            \"R0\": [-4.0, 0.0], \"P0\": [5.0, 0.0], \"s0\": 1, \"c0\": [1.0 + 0.0j, 0.0 + 0.0j],\n            \"nac_params\": {\"C\": 0.0, \"lam\": 1.0, \"R_nac\": [0.0, 0.0], \"u_hat\": np.array([1.0, 0.0])}\n        },\n        # Case 3\n        {\n            \"R0\": [4.0, 0.0], \"P0\": [-5.0, 0.0], \"s0\": 2, \"c0\": [0.0 + 0.0j, 1.0 + 0.0j],\n            \"nac_params\": {\"C\": 4.0, \"lam\": 1.0, \"R_nac\": [0.0, 0.0], \"u_hat\": np.array([1.0, 0.0])}\n        },\n        # Case 4\n        {\n            \"R0\": [-4.0, 0.0], \"P0\": [5.0, 0.0], \"s0\": 1, \"c0\": [1.0 + 0.0j, 0.0 + 0.0j],\n            \"nac_params\": {\"C\": 4.0, \"lam\": 1.0, \"R_nac\": [0.0, 3.0], \"u_hat\": np.array([1.0, 0.0])}\n        },\n    ]\n\n    results = [simulate(**case) for case in test_cases]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2463200"}, {"introduction": "FSSH 算法是一种强大的近似方法，但它并非没有缺陷。一个众所周知的问题是“伪回跳”(spurious recrossing)，即轨迹跳跃到另一个电子态后几乎立即跳回，这通常是不符合物理实际的。[@problem_id:2463206] 这项实践将重点从生成轨迹转移到分析轨迹，要求你实现一种算法来检测和修正这些伪事件，从而提高模拟结果的准确性。", "problem": "考虑一条由 Fewest Switches Surface Hopping (FSSH) 生成的轨迹。设有一个长度为 $N$、时间严格递增的时间有序序列 $t_0  t_1  \\dots  t_{N-1}$，一个“活性电子态”索引序列 $s_0, s_1, \\dots, s_{N-1}$（其中每个 $s_i$ 为一个整数标签），以及一个非负的“核动能”序列 $K_0, K_1, \\dots, K_{N-1}$。对于任何满足 $s_i \\neq s_{i-1}$ 的索引 $i \\in \\{1,\\dots,N-1\\}$，定义一个“跳跃事件”。对于索引 $i$ 处的跳跃事件，定义“跳跃前态”$p_i = s_{i-1}$、“跳跃后态”$q_i = s_i$、“跳跃时间”$\\tau_i = t_i$ 和“跳跃能量”$\\kappa_i = K_i$。\n\n跳跃事件的“重渡对”是指在跳跃事件序列中，一对相邻的跳跃事件 $(i, j)$（其中 $j = i + 1$）满足以下所有三个条件：\n- 状态返回条件：$p_i = q_j$ 且 $q_i = p_j$。\n- 时间邻近条件：$\\tau_j - \\tau_i \\le \\tau_{\\mathrm{tol}}$，其中 $\\tau_{\\mathrm{tol}}  0$ 是给定的时间阈值。\n- 能量邻近条件：$\\lvert \\kappa_j - \\kappa_i \\rvert \\le \\Delta K_{\\mathrm{tol}}$，其中 $\\Delta K_{\\mathrm{tol}} \\ge 0$ 是给定的能量阈值。\n\n重渡对 $(i, j)$ 的“修正”定义为：将从第一个跳跃索引到第二个跳跃索引的闭合索引区间内的活性态替换为第一个跳跃的跳跃前态，即对于所有满足 $i \\le k \\le j$ 的整数索引 $k$，设置 $s_k \\leftarrow p_i$。应用任何修正后，跳跃事件序列会根据新的状态序列被隐式更新。检测和修正重渡对的过程需要迭代应用，直到不再有重渡对存在。\n\n您的任务是实现这个重渡检测与修正规则，并报告每条轨迹通过此迭代过程修正的重渡对总数。时间和能量可被视为无量纲量；最终答案是整数，不带物理单位。\n\n测试套件。对于下方的每个测试用例，给定序列 $(t_i)_{i=0}^{N-1}$、$(s_i)_{i=0}^{N-1}$、$(K_i)_{i=0}^{N-1}$ 以及阈值 $\\tau_{\\mathrm{tol}}$ 和 $\\Delta K_{\\mathrm{tol}}$。\n\n- 测试用例 1：\n  - $t = [\\,0.0,\\,0.05,\\,0.10,\\,0.15\\,]$\n  - $s = [\\,0,\\,1,\\,0,\\,0\\,]$\n  - $K = [\\,1.000,\\,0.990,\\,1.005,\\,1.006\\,]$\n  - $\\tau_{\\mathrm{tol}} = 0.06$, $\\Delta K_{\\mathrm{tol}} = 0.03$\n\n- 测试用例 2 (边界相等情况应符合重渡条件)：\n  - $t = [\\,0.0,\\,0.10,\\,0.15,\\,0.20\\,]$\n  - $s = [\\,0,\\,1,\\,1,\\,0\\,]$\n  - $K = [\\,1.00,\\,0.95,\\,0.96,\\,0.90\\,]$\n  - $\\tau_{\\mathrm{tol}} = 0.10$, $\\Delta K_{\\mathrm{tol}} = 0.05$\n\n- 测试用例 3 (不满足能量邻近条件，因此不是重渡)：\n  - $t = [\\,0.0,\\,0.05,\\,0.08\\,]$\n  - $s = [\\,0,\\,1,\\,0\\,]$\n  - $K = [\\,1.0,\\,0.2,\\,0.9\\,]$\n  - $\\tau_{\\mathrm{tol}} = 0.05$, $\\Delta K_{\\mathrm{tol}} = 0.20$\n\n- 测试用例 4 (两个涉及不同状态的独立重渡)：\n  - $t = [\\,0.0,\\,0.02,\\,0.04,\\,0.06,\\,0.08,\\,0.10\\,]$\n  - $s = [\\,0,\\,1,\\,0,\\,0,\\,2,\\,0\\,]$\n  - $K = [\\,0.50,\\,0.49,\\,0.51,\\,0.52,\\,0.50,\\,0.49\\,]$\n  - $\\tau_{\\mathrm{tol}} = 0.03$, $\\Delta K_{\\mathrm{tol}} = 0.03$\n\n- 测试用例 5 (交替重渡的重叠序列)：\n  - $t = [\\,0.0,\\,0.02,\\,0.04,\\,0.06,\\,0.08\\,]$\n  - $s = [\\,0,\\,1,\\,0,\\,1,\\,0\\,]$\n  - $K = [\\,1.00,\\,0.98,\\,1.01,\\,0.99,\\,1.02\\,]$\n  - $\\tau_{\\mathrm{tol}} = 0.03$, $\\Delta K_{\\mathrm{tol}} = 0.03$\n\n最终输出格式。您的程序应生成单行输出，其中包含一个方括号括起来的逗号分隔列表，按给定顺序包含每个测试用例的总修正次数，例如 $[x_1,x_2,\\dots,x_5]$，其中每个 $x_i$ 都是整数。", "solution": "该问题已经过验证，并被认定为有效。它在计算化学领域具有科学依据，特别涉及对诸如 Fewest Switches Surface Hopping (FSSH) 等方法的非绝热分子动力学轨迹进行后处理。其定义精确、客观且数学上适定，构成了一个完整且一致的算法问题。不存在矛盾、歧义或事实错误。\n\n任务是实现一个迭代算法，用于识别和修正轨迹中的“重渡对”跳跃事件，直到不再存在此类事件对。一条轨迹由时间序列 $(t_i)_{i=0}^{N-1}$、活性电子态索引序列 $(s_i)_{i=0}^{N-1}$ 和核动能序列 $(K_i)_{i=0}^{N-1}$ 描述。\n\n首先，我们必须形式化“跳跃事件”的概念。如果在索引为 $i \\in \\{1, \\dots, N-1\\}$ 的时间步上活性态发生变化，即 $s_i \\neq s_{i-1}$，则发生了一次跳跃事件。对于每个此类事件，我们定义其属性：跳跃前态 $p_i = s_{i-1}$、跳跃后态 $q_i = s_i$、跳跃时间 $\\tau_i = t_i$ 和跳跃能量 $\\kappa_i = K_i$。我们可以将跳跃事件表示为其属性的有序元组，例如 $H_k = (i_k, p_{i_k}, q_{i_k}, \\tau_{i_k}, \\kappa_{i_k})$，其中 $k$ 是跳跃事件序列中的索引。\n\n接下来，为所有跳跃事件的时间有序序列中的两个*相邻*跳跃事件定义“重渡对”。设这两个相邻的跳跃为 $H_k$ 和 $H_{k+1}$，分别发生在原始轨迹索引 $i_k$ 和 $i_{k+1}$ 处。如果这对跳跃满足三个特定条件，则构成一次重渡：\n1. 状态返回：系统必须返回到第一次跳跃的初始态。形式上，$p_{i_k} = q_{i_{k+1}}$ 且 $q_{i_k} = p_{i_{k+1}}$。\n2. 时间邻近：两次跳跃之间经过的时间不得超过给定的阈值 $\\tau_{\\mathrm{tol}}  0$。形式上，$\\tau_{i_{k+1}} - \\tau_{i_k} \\le \\tau_{\\mathrm{tol}}$。\n3. 能量邻近：跳跃后核动能的绝对差不得超过给定的阈值 $\\Delta K_{\\mathrm{tol}} \\ge 0$。形式上，$|\\kappa_{i_{k+1}} - \\kappa_{i_k}| \\le \\Delta K_{\\mathrm{tol}}$。\n\n问题的核心是迭代修正过程。该过程必须持续进行，直到在轨迹中找不到重渡对为止。这意味着一个在收敛时终止的循环。一个确定性算法设计如下：\n\n设修正次数为 $C$，初始化为 $C=0$。状态序列 $s$ 被视为一个可变对象。\n\n1. 开始一个迭代循环。只要在一次遍历中进行了修正，该循环就继续。\n2. 在每次迭代中，首先根据*当前*状态序列 $s$ 生成所有跳跃事件的完整时间有序序列。如果存在的跳跃少于两次，则不可能发生重渡，过程终止。\n3. 扫描相邻跳跃事件对 $(H_k, H_{k+1})$ 的序列。\n4. 对于*第一个*满足所有三个重渡条件的事件对：\n    a. 应用“修正”。设两次跳跃的原始轨迹索引为 $i_k$ 和 $i_{k+1}$。通过为闭区间 $[i_k, i_{k+1}]$ 中的所有索引 $l$ 设置 $s_l \\leftarrow p_{i_k}$ 来修改状态序列。这有效地擦除了这对跳跃，并将轨迹段恢复到第一次跳跃之前的状态。\n    b. 增加总修正计数器：$C \\leftarrow C + 1$。\n    c. 由于状态序列 $s$已被修改，当前的跳跃事件列表现在无效。停止扫描其他重渡对，算法必须返回步骤 2，从迭代循环的开始重新评估轨迹。\n5. 如果扫描完所有相邻跳跃对后未发现重渡对，则意味着根据给定标准，轨迹是“干净的”。迭代循环终止。\n\n对于给定的轨迹，$C$ 的最终值即为结果。此过程保证会终止，因为每次修正都会从轨迹中移除至少两个跳跃事件，而初始可能发生的跳跃次数是有限的。通过总是在顺序扫描中修正找到的第一个重渡对，该算法是确定性的，并产生唯一的最终状态和修正计数。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the recrossing correction algorithm on all test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"t\": [0.0, 0.05, 0.10, 0.15],\n            \"s\": [0, 1, 0, 0],\n            \"K\": [1.000, 0.990, 1.005, 1.006],\n            \"tau_tol\": 0.06,\n            \"dK_tol\": 0.03,\n        },\n        {\n            \"t\": [0.0, 0.10, 0.15, 0.20],\n            \"s\": [0, 1, 1, 0],\n            \"K\": [1.00, 0.95, 0.96, 0.90],\n            \"tau_tol\": 0.10,\n            \"dK_tol\": 0.05,\n        },\n        {\n            \"t\": [0.0, 0.05, 0.08],\n            \"s\": [0, 1, 0],\n            \"K\": [1.0, 0.2, 0.9],\n            \"tau_tol\": 0.05,\n            \"dK_tol\": 0.20,\n        },\n        {\n            \"t\": [0.0, 0.02, 0.04, 0.06, 0.08, 0.10],\n            \"s\": [0, 1, 0, 0, 2, 0],\n            \"K\": [0.50, 0.49, 0.51, 0.52, 0.50, 0.49],\n            \"tau_tol\": 0.03,\n            \"dK_tol\": 0.03,\n        },\n        {\n            \"t\": [0.0, 0.02, 0.04, 0.06, 0.08],\n            \"s\": [0, 1, 0, 1, 0],\n            \"K\": [1.00, 0.98, 1.01, 0.99, 1.02],\n            \"tau_tol\": 0.03,\n            \"dK_tol\": 0.03,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        result = process_trajectory(\n            case[\"t\"], case[\"s\"], case[\"K\"], case[\"tau_tol\"], case[\"dK_tol\"]\n        )\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef process_trajectory(t_sequence, s_sequence, k_sequence, tau_tol, dK_tol):\n    \"\"\"\n    Applies the iterative recrossing detection and correction algorithm.\n\n    Args:\n        t_sequence (list): Time sequence.\n        s_sequence (list): Active electronic state sequence.\n        k_sequence (list): Nuclear kinetic energy sequence.\n        tau_tol (float): Temporal proximity threshold.\n        dK_tol (float): Energetic proximity threshold.\n\n    Returns:\n        int: The total number of corrections made.\n    \"\"\"\n    s_current = list(s_sequence)  # Use a mutable copy\n    total_corrections = 0\n\n    while True:\n        # Step 1: Find all hop events in the current state sequence.\n        # A hop event is represented by a dictionary containing its properties.\n        hops = []\n        for i in range(1, len(s_current)):\n            if s_current[i] != s_current[i - 1]:\n                hop_info = {\n                    \"index\": i,  # original index in the full sequence\n                    \"p\": s_current[i - 1],  # pre-hop state\n                    \"q\": s_current[i],  # post-hop state\n                    \"tau\": t_sequence[i],  # hop time\n                    \"kappa\": k_sequence[i],  # hop energy\n                }\n                hops.append(hop_info)\n\n        # If there are fewer than 2 hops, no recrossing pairs are possible.\n        if len(hops)  2:\n            break\n\n        # Step 2: Scan for the first recrossing pair among adjacent hop events.\n        corrected_this_pass = False\n        for hop_list_index in range(len(hops) - 1):\n            hop1 = hops[hop_list_index]\n            hop2 = hops[hop_list_index + 1]\n\n            # Condition 1: State return\n            state_return_ok = hop1[\"p\"] == hop2[\"q\"] and hop1[\"q\"] == hop2[\"p\"]\n\n            # Condition 2: Temporal proximity\n            temporal_prox_ok = hop2[\"tau\"] - hop1[\"tau\"] = tau_tol\n\n            # Condition 3: Energetic proximity\n            energetic_prox_ok = np.abs(hop2[\"kappa\"] - hop1[\"kappa\"]) = dK_tol\n\n            if state_return_ok and temporal_prox_ok and energetic_prox_ok:\n                # A recrossing pair is found.\n                total_corrections += 1\n                corrected_this_pass = True\n                \n                # Retrieve the original indices for the state sequence modification.\n                start_index = hop1[\"index\"]\n                end_index = hop2[\"index\"]\n                \n                # The state to revert to is the pre-hop state of the first hop.\n                correction_state = hop1[\"p\"]\n                \n                # Apply the correction to the state sequence over the closed interval.\n                # A list slice assignment is used for efficient replacement.\n                num_elements_to_replace = end_index - start_index + 1\n                s_current[start_index : end_index + 1] = [\n                    correction_state\n                ] * num_elements_to_replace\n                \n                # As the state sequence has changed, the 'hops' list is now invalid.\n                # Break the inner loop to restart the process and regenerate the hops list.\n                break\n        \n        # If no corrections were made after checking all hop pairs, the process has converged.\n        if not corrected_this_pass:\n            break\n            \n    return total_corrections\n\nsolve()\n```", "id": "2463206"}]}