{"hands_on_practices": [{"introduction": "约束优化在药物设计中至关重要，我们必须在分子的稳定性（低能量）和期望的性质（如由 LogP 代表的溶解度）之间取得平衡。本练习 [@problem_id:2453478] 提供了一个清晰的一维例子，帮助我们掌握“活性”约束的核心思想，即最优解被强制推向可行域的边界。通过这个简单的模型，我们可以直观地理解当无约束最优解不满足必要条件时，如何找到受约束下的最佳方案。", "problem": "在一个简化的、基于物理的药物设计场景中，考虑一个由单一描述符 $x$ 参数化的连续类似物系列，该描述符 $x$ 量化了固定骨架上疏水性取代基的程度。假设辛醇/水分配系数 (LogP) 符合经验性的线性自由能关系\n$$\n\\mathrm{LogP}(x) = \\ell_{0} + \\ell_{1} x,\n$$\n其中 $\\ell_{0} = 4.2$ 且 $\\ell_{1} = 1.0$。在分子力学替代模型下，分子在参考类似物附近的分子内势能通过谐波展开进行建模\n$$\nE(x) = E_{\\mathrm{ref}} + \\kappa \\left(x - x^{\\star}\\right)^{2},\n$$\n其中 $E_{\\mathrm{ref}} = 10$ kJ/mol, $\\kappa = 50$ kJ/mol, 且 $x^{\\star} = 1.3$。设计一个候选分子，使其在满足 LogP 值必须符合 $\\mathrm{LogP}(x) \\leq 5$ 的类药性约束条件下，最小化 $E(x)$。\n\n在此约束条件下，最小化的能量值是多少？将您的答案四舍五入至 $4$ 位有效数字。最终能量以 kJ/mol 为单位表示。在最终的方框答案中不要包含单位。", "solution": "所述问题构成了一个有效的、定义明确的约束优化练习，其基础是计算化学中简化但标准的原理。我们已获得所有必要信息，可以进行严谨的求解。\n\n任务是求势能函数 $E(x)$ 在亲脂性描述符 $\\mathrm{LogP}(x)$ 约束下的最小值。\n\n目标函数为势能，由谐波模型给出：\n$$ E(x) = E_{\\mathrm{ref}} + \\kappa \\left(x - x^{\\star}\\right)^{2} $$\n代入所给常数 $E_{\\mathrm{ref}} = 10$ kJ/mol, $\\kappa = 50$ kJ/mol, 和 $x^{\\star} = 1.3$，我们得到：\n$$ E(x) = 10 + 50 \\left(x - 1.3\\right)^{2} $$\n这是一个关于描述符 $x$ 的二次函数。二次项的系数为正 ($\\kappa = 50 > 0$)，因此抛物线开口向上，该函数拥有唯一的全局最小值。为了找到无约束最小值，我们将 $E(x)$ 对 $x$求导，并令导数等于零：\n$$ \\frac{dE}{dx} = 2\\kappa(x - x^{\\star}) = 2(50)(x - 1.3) = 100(x - 1.3) $$\n令 $\\frac{dE}{dx} = 0$ 可得 $100(x - 1.3) = 0$，由此解得无约束极小点 $x_{\\text{unconstrained}} = 1.3$。在此点，无约束最小能量为 $E(1.3) = 10 + 50(1.3 - 1.3)^{2} = 10$ kJ/mol。\n\n接下来，我们必须分析系统的约束条件。类药性约束为 $\\mathrm{LogP}(x) \\leq 5$。函数 $\\mathrm{LogP}(x)$ 由以下线性关系定义：\n$$ \\mathrm{LogP}(x) = \\ell_{0} + \\ell_{1} x $$\n使用给定参数 $\\ell_{0} = 4.2$ 和 $\\ell_{1} = 1.0$，约束变为：\n$$ 4.2 + 1.0x \\leq 5 $$\n对 $x$ 求解此不等式，定义了描述符的可行域：\n$$ x \\leq 5 - 4.2 $$\n$$ x \\leq 0.8 $$\n可行域是区间 $(-\\infty, 0.8]$ 中所有 $x$ 的集合。\n\n该优化问题是在此可行域内最小化 $E(x)$。我们现在必须将无约束最小值点 $x_{\\text{unconstrained}} = 1.3$ 与可行域进行比较。由于 $1.3 > 0.8$，无约束最小值点位于可行域之外。\n\n函数 $E(x)$ 是一个抛物线，其顶点（最小值点）在 $x = 1.3$。对于所有 $x  1.3$，函数 $E(x)$ 随着 $x$ 的增加而单调递减。可行域 $x \\leq 0.8$ 完全位于此单调行为区间内。为了找到可行域内 $E(x)$ 的最小值，我们必须选择可行域中离无约束极小点 $x = 1.3$ 最近的点。这个点就是可行域的边界，$x_{\\text{opt}} = 0.8$。此时，该约束被称为“激活的”约束。\n\n最后，我们通过计算能量函数在 $x_{\\text{opt}} = 0.8$ 处的值来得到约束下的最小能量 $E_{\\text{min}}$：\n$$ E_{\\text{min}} = E(0.8) = 10 + 50(0.8 - 1.3)^{2} $$\n$$ E_{\\text{min}} = 10 + 50(-0.5)^{2} $$\n$$ E_{\\text{min}} = 10 + 50(0.25) $$\n$$ E_{\\text{min}} = 10 + 12.5 $$\n$$ E_{\\text{min}} = 22.5 \\, \\text{kJ/mol} $$\n题目要求答案四舍五入到 $4$ 位有效数字。数值 $22.5$ 写成 $22.50$ 以满足此要求。", "answer": "$$\\boxed{22.50}$$", "id": "2453478"}, {"introduction": "在掌握了基本概念之后，我们从简化的一维描述符转向分子的完整三维坐标。本练习 [@problem_id:2453470] 将使用经典的力场来寻找分子的最低能量构象，但增加了原子之间不能靠得太近的真实物理约束。这项实践需要使用数值求解器，并展示了空间位阻等约束如何塑造最终的分子结构，这是分子模拟中的一个基本问题。", "problem": "您的任务是根据基本原理，构建并求解一个带约束的分子构象优化问题。目标是在与非键合氢原子相关的几何约束下，最小化一个经典分子力学能量。所有距离必须以埃（Angstrom）为单位，记作 $\\mathrm{\\AA}$；所有能量必须以千焦每摩尔为单位，记作 $\\mathrm{kJ\\ mol^{-1}}$。作为参数提供的角度以度为单位指定；所有三角函数计算必须在弧度下进行。\n\n对于一个原子位置为 $\\{\\mathbf{r}_i\\}_{i=1}^{N}$（其中 $\\mathbf{r}_i \\in \\mathbb{R}^3$）的构象，其总势能定义为谐振键项和谐振角项之和：\n$$\nE(\\{\\mathbf{r}_i\\}) \\;=\\; \\sum_{(i,j)\\in \\mathcal{B}} \\frac{1}{2} k_{b,ij}\\left(\\lVert \\mathbf{r}_i - \\mathbf{r}_j \\rVert - r_{0,ij}\\right)^2 \\;+\\; \\sum_{(i,j,k)\\in \\mathcal{A}} \\frac{1}{2} k_{\\theta,ijk}\\left(\\theta_{ijk} - \\theta_{0,ijk}\\right)^2,\n$$\n其中 $\\mathcal{B}$ 是键合对的集合，$\\mathcal{A}$ 是已定义角的集合，$k_{b,ij}$ 是单位为 $\\mathrm{kJ\\ mol^{-1}\\ \\AA^{-2}}$ 的键力常数，$r_{0,ij}$ 是单位为 $\\mathrm{\\AA}$ 的平衡键长，$k_{\\theta,ijk}$ 是单位为 $\\mathrm{kJ\\ mol^{-1}\\ rad^{-2}}$ 的角力常数，而 $\\theta_{ijk}$ 是由向量 $(\\mathbf{r}_i-\\mathbf{r}_j)$ 和 $(\\mathbf{r}_k-\\mathbf{r}_j)$ 在原子 $j$ 处形成的角，以弧度为单位测量。对于任何点积计算，使用\n$$\n\\theta_{ijk} \\;=\\; \\arccos \\!\\left( \\frac{(\\mathbf{r}_i-\\mathbf{r}_j)\\cdot(\\mathbf{r}_k-\\mathbf{r}_j)}{\\lVert \\mathbf{r}_i-\\mathbf{r}_j \\rVert \\,\\lVert \\mathbf{r}_k-\\mathbf{r}_j \\rVert} \\right),\n$$\n其中 $\\arccos$ 的参数在数值上被裁剪到区间 $[-1,1]$ 内。\n\n几何约束为：对于每一对不直接键合的氢原子，它们之间的距离必须满足\n$$\n\\lVert \\mathbf{r}_p - \\mathbf{r}_q \\rVert \\;\\ge\\; 2.0,\n$$\n距离单位为 $\\mathrm{\\AA}$。此处，“非键合氢原子对”指两个原子均为氢元素，且该原子对不属于集合 $\\mathcal{B}$。\n\n您的程序必须针对以下每个测试用例，在这些不等式约束下求解 $E(\\{\\mathbf{r}_i\\})$ 的最小值。不得有用户输入。输出必须是单行内容，包含一个浮点数列表，每个测试用例对应一个数值，该数值等于最小化的总能量（单位为 $\\mathrm{kJ\\ mol^{-1}}$），并精确到三位小数。\n\n测试套件（所有坐标单位为 $\\mathrm{\\AA}$；所有角度参数 $\\theta_0$ 单位为度；所有三角函数计算必须使用弧度）：\n\n- 测试用例 1（氢气分子, $ \\mathrm{H_2} $）：\n  - 原子（索引: 元素）：$0:\\ \\mathrm{H}$，$1:\\ \\mathrm{H}$。\n  - 键 $\\mathcal{B}$：$(0,1)$，其中 $k_b = 450.0$，$r_0 = 0.74$。\n  - 角 $\\mathcal{A}$：无。\n  - 初始坐标 $\\mathbf{r}_0$：$\\mathbf{r}_0(0)=(0.0,\\,0.0,\\,0.0)$，$\\mathbf{r}_0(1)=(1.0,\\,0.0,\\,0.0)$。\n\n- 测试用例 2（水分子, $ \\mathrm{H_2O} $）：\n  - 原子：$0:\\ \\mathrm{O}$，$1:\\ \\mathrm{H}$，$2:\\ \\mathrm{H}$。\n  - 键 $\\mathcal{B}$：$(0,1)$，其中 $k_b = 450.0$，$r_0 = 0.96$；$(0,2)$，其中 $k_b = 450.0$，$r_0 = 0.96$。\n  - 角 $\\mathcal{A}$：$(1,0,2)$，其中 $k_{\\theta} = 55.0$，$\\theta_0 = 104.5$。\n  - 初始坐标：\n    - 设 $r = 0.96$，$\\theta_0 = 104.5$ 度。\n    - $\\mathbf{r}_0(0)=(0.0,\\,0.0,\\,0.0)$,\n      $\\mathbf{r}_0(1)=(r,\\,0.0,\\,0.0)$,\n      $\\mathbf{r}_0(2)=(r\\cos\\theta_0,\\,r\\sin\\theta_0,\\,0.0)$，计算三角函数时需将 $\\theta_0$ 转换为弧度。\n  - 约束应用于非键合氢原子对 $(1,2)$：它们的距离必须至少为 $2.0$。\n\n- 测试用例 3（线性 $\\mathrm{H{-}C{-}C{-}H}$）：\n  - 原子：$0:\\ \\mathrm{H}$，$1:\\ \\mathrm{C}$，$2:\\ \\mathrm{C}$，$3:\\ \\mathrm{H}$。\n  - 键 $\\mathcal{B}$：$(0,1)$，其中 $k_b = 300.0$，$r_0 = 1.09$；$(1,2)$，其中 $k_b = 300.0$，$r_0 = 1.54$；$(2,3)$，其中 $k_b = 300.0$，$r_0 = 1.09$。\n  - 角 $\\mathcal{A}$：$(0,1,2)$，其中 $k_{\\theta} = 20.0$，$\\theta_0 = 180.0$；$(1,2,3)$，其中 $k_{\\theta} = 20.0$，$\\theta_0 = 180.0$。\n  - 初始坐标（沿 $x$ 轴共线）：\n    - $\\mathbf{r}_0(0)=(0.0,\\,0.0,\\,0.0)$,\n      $\\mathbf{r}_0(1)=(1.09,\\,0.0,\\,0.0)$,\n      $\\mathbf{r}_0(2)=(1.09+1.54,\\,0.0,\\,0.0)$,\n      $\\mathbf{r}_0(3)=(1.09+1.54+1.09,\\,0.0,\\,0.0)$.\n  - 约束应用于非键合氢原子对 $(0,3)$：它们的距离必须至少为 $2.0$。\n\n您的程序应生成单行输出，其中包含三个测试用例的最小化能量，形式为方括号内以逗号分隔的列表，例如，“[e1,e2,e3]”。每个条目必须是对应测试用例的最小化总能量（单位为 $\\mathrm{kJ\\ mol^{-1}}$），并精确到三位小数。不应打印任何其他文本。", "solution": "所提出的问题是一个源于计算化学领域的带约束非线性优化任务。其目标是确定几个小分子的最小势能构象，同时满足原子间距离的特定几何约束。\n\n在继续之前，需要对问题陈述进行验证。\n\n**步骤 1：提取的已知条件**\n\n1.  **目标函数（势能）**：\n    $$\n    E(\\{\\mathbf{r}_i\\}) \\;=\\; \\sum_{(i,j)\\in \\mathcal{B}} \\frac{1}{2} k_{b,ij}\\left(\\lVert \\mathbf{r}_i - \\mathbf{r}_j \\rVert - r_{0,ij}\\right)^2 \\;+\\; \\sum_{(i,j,k)\\in \\mathcal{A}} \\frac{1}{2} k_{\\theta,ijk}\\left(\\theta_{ijk} - \\theta_{0,ijk}\\right)^2\n    $$\n    其中：\n    - $\\{\\mathbf{r}_i\\}$ 是原子 $i$ 的三维坐标。\n    - $\\mathcal{B}$ 是键合原子对的集合。\n    - $\\mathcal{A}$ 是定义一个角度的原子三元组的集合。\n    - $k_{b,ij}$ 是单位为 $\\mathrm{kJ\\ mol^{-1}\\ \\AA^{-2}}$ 的键力常数。\n    - $r_{0,ij}$ 是单位为 $\\mathrm{\\AA}$ 的平衡键长。\n    - $k_{\\theta,ijk}$ 是单位为 $\\mathrm{kJ\\ mol^{-1}\\ rad^{-2}}$ 的角力常数。\n    - $\\theta_{0,ijk}$ 是平衡角，以弧度为单位（由参数中提供的度数转换而来）。\n    - $\\theta_{ijk} = \\arccos \\!\\left( \\frac{(\\mathbf{r}_i-\\mathbf{r}_j)\\cdot(\\mathbf{r}_k-\\mathbf{r}_j)}{\\lVert \\mathbf{r}_i-\\mathbf{r}_j \\rVert \\,\\lVert \\mathbf{r}_k-\\mathbf{r}_j \\rVert} \\right)$，其参数被裁剪到 $[-1, 1]$ 范围内。\n\n2.  **约束条件**：对于任意一对不属于键集合 $\\mathcal{B}$ 的氢原子 $(p, q)$，它们的距离必须满足：\n    $$\n    \\lVert \\mathbf{r}_p - \\mathbf{r}_q \\rVert \\;\\ge\\; 2.0\\ \\mathrm{\\AA}\n    $$\n\n3.  **测试用例**：提供了三个特定的分子系统，每个系统都定义了原子、元素、键合拓扑、力场参数（$k_b, r_0, k_\\theta, \\theta_0$）和初始坐标。\n\n4.  **输出格式**：一个单行列表，包含每个测试用例的最小化能量（单位为 $\\mathrm{kJ\\ mol^{-1}}$），四舍五入到三位小数。\n\n**步骤 2：验证**\n\n根据所需标准对问题进行分析：\n- **科学依据**：势能函数是一个简化的经典分子力学力场，由谐振键伸缩项和角弯曲项组成。这是用于分子建模的标准且成熟的模型。对非键合氢原子距离的约束代表了空间排斥（泡利不相容原理排斥）的一个基本模型，这在物理上是合理的。所提供的所有参数对于指定的分子都在实际范围内。\n- **适定性**：该问题是一个标准的非线性规划（NLP）问题：在满足一组不等式约束的条件下，最小化一个连续可微的函数（除了在坐标重合点，这被势能的排斥性所阻止；以及在 `arccos` 定义域的边界处，这通过数值裁剪来处理）。预期存在解。\n- **客观性和完整性**：问题陈述使用了精确的数学定义和客观的语言。每个测试用例都提供了所有必要的数据（原子组成、参数、初始几何构型）。\n\n**步骤 3：结论**\n\n该问题被判定为 **有效**。它是一个定义明确、有科学依据且在计算上可解的约束优化问题。\n\n**求解方法**\n\n该问题将使用数值优化方法求解。对于一个包含 $N$ 个原子的系统，所有原子坐标构成的向量 $\\mathbf{x} \\in \\mathbb{R}^{3N}$ 作为优化的变量。目标函数是势能 $E(\\mathbf{x})$。约束条件的形式为 $g_p(\\mathbf{x}) \\le 0$，对于每个受约束的原子对 $(p,q)$，我们可以写成 $d_{\\mathrm{min}} - \\lVert \\mathbf{r}_p - \\mathbf{r}_q \\rVert \\le 0$，其中 $d_{\\mathrm{min}} = 2.0\\ \\mathrm{\\AA}$。\n\n我们将采用序列最小二乘规划（Sequential Least Squares Programming, SLSQP）算法，该算法在 `scipy.optimize.minimize` 函数中得以实现。此方法适用于带有不等式约束的非线性优化问题。\n\n该实现需要一个 Python 函数来计算总能量 $E(\\mathbf{x})$，以及一组表示约束条件的函数。\n\n**测试用例分析**\n\n1.  **测试用例 1（氢气分子，$\\mathrm{H}_2$）**：该系统由两个通过化学键连接的氢原子 $(0,1)$ 组成。势能仅包含一个键伸缩项：$E = \\frac{1}{2} k_{b,01} (\\lVert \\mathbf{r}_0 - \\mathbf{r}_1 \\rVert - r_{0,01})^2$。当键长等于平衡长度 $\\lVert \\mathbf{r}_0 - \\mathbf{r}_1 \\rVert = r_{0,01} = 0.74\\ \\mathrm{\\AA}$ 时，该函数达到最小值，此时能量 $E=0$。约束规则适用于非键合的氢原子对。由于唯一的氢原子对是键合的，因此没有约束。这是一个无约束优化问题，预期的最小能量恰好是 $0.0\\ \\mathrm{kJ\\ mol^{-1}}$。\n\n2.  **测试用例 2（水分子，$\\mathrm{H_2O}$）**：该系统由一个氧原子 ($0$) 和两个氢原子 ($1, 2$) 组成。在无约束的情况下，能量最小的构象将具有键长 $d_{O-H} = 0.96\\ \\mathrm{\\AA}$ 和键角 $\\theta_{H-O-H} = 104.5^\\circ$。在这种几何结构中，使用余弦定理计算出的两个氢原子之间的距离为 $d_{H-H} = \\sqrt{2 \\cdot (0.96)^2 \\cdot (1 - \\cos(104.5^\\circ))} \\approx 1.518\\ \\mathrm{\\AA}$。这个距离违反了 $d_{H-H} \\ge 2.0\\ \\mathrm{\\AA}$ 的约束。因此，该约束是激活的。优化器必须找到一个满足 $d_{H-H} \\ge 2.0\\ \\mathrm{\\AA}$ 的新几何构型，同时最小化由此产生的键和角的应变能。最终能量将大于零。\n\n3.  **测试用例 3（线性 $\\mathrm{H-C-C-H}$）**：该系统被配置为线性结构，平衡角为 $180^\\circ$。在无约束的能量最小值处，所有键长都处于其平衡值（$1.09\\ \\mathrm{\\AA}$、$1.54\\ \\mathrm{\\AA}$、$1.09\\ \\mathrm{\\AA}$），分子是完全线性的。两个非键合氢原子 ($0, 3$) 之间的距离是平衡键长之和：$d_{H-H} = 1.09 + 1.54 + 1.09 = 3.72\\ \\mathrm{\\AA}$。这个距离大于所要求的最小值 $2.0\\ \\mathrm{\\AA}$。因此，该约束是未激活的，因为它在全局无约束最小值处已经得到满足。优化器将收敛到这个构型，其能量为 $0.0\\ \\mathrm{kJ\\ mol^{-1}}$。提供的初始坐标已经代表了这个最小能量状态。\n\n以下 Python 代码实现了这一策略，以求解每个测试用例的最小能量。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    \"\"\"\n    Formulates and solves the constrained molecular optimization problem for three test cases.\n    \"\"\"\n\n    # --- Test Case Data ---\n\n    # Initial coordinates for Water (Test Case 2)\n    r_oh_h2o = 0.96\n    theta_hoh_deg = 104.5\n    theta_hoh_rad = np.deg2rad(theta_hoh_deg)\n    h2o_initial_coords = np.array([\n        [0.0, 0.0, 0.0],\n        [r_oh_h2o, 0.0, 0.0],\n        [r_oh_h2o * np.cos(theta_hoh_rad), r_oh_h2o * np.sin(theta_hoh_rad), 0.0]\n    ])\n\n    # Initial coordinates for Linear H-C-C-H (Test Case 3)\n    hcch_initial_coords = np.array([\n        [0.0, 0.0, 0.0],\n        [1.09, 0.0, 0.0],\n        [1.09 + 1.54, 0.0, 0.0],\n        [1.09 + 1.54 + 1.09, 0.0, 0.0]\n    ])\n\n    test_cases = [\n        {\n            \"name\": \"Diatomic Hydrogen\",\n            \"atoms\": {\"H\": [0, 1]},\n            \"bonds\": [(0, 1, 450.0, 0.74)],\n            \"angles\": [],\n            \"initial_coords\": np.array([[0.0, 0.0, 0.0], [1.0, 0.0, 0.0]]),\n        },\n        {\n            \"name\": \"Water\",\n            \"atoms\": {\"O\": [0], \"H\": [1, 2]},\n            \"bonds\": [(0, 1, 450.0, 0.96), (0, 2, 450.0, 0.96)],\n            \"angles\": [(1, 0, 2, 55.0, 104.5)],\n            \"initial_coords\": h2o_initial_coords,\n        },\n        {\n            \"name\": \"Linear H-C-C-H\",\n            \"atoms\": {\"H\": [0, 3], \"C\": [1, 2]},\n            \"bonds\": [\n                (0, 1, 300.0, 1.09),\n                (1, 2, 300.0, 1.54),\n                (2, 3, 300.0, 1.09),\n            ],\n            \"angles\": [\n                (0, 1, 2, 20.0, 180.0),\n                (1, 2, 3, 20.0, 180.0)\n            ],\n            \"initial_coords\": hcch_initial_coords,\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        # --- Objective Function ---\n        def objective_function(x, bonds, angles):\n            coords = x.reshape(-1, 3)\n            energy = 0.0\n\n            # Bond energy calculation\n            for i, j, k_b, r_0 in bonds:\n                dist = np.linalg.norm(coords[i] - coords[j])\n                energy += 0.5 * k_b * (dist - r_0)**2\n\n            # Angle energy calculation\n            for i, j, k, k_theta, theta_0_deg in angles:\n                v_ji = coords[i] - coords[j]\n                v_jk = coords[k] - coords[j]\n                norm_ji = np.linalg.norm(v_ji)\n                norm_jk = np.linalg.norm(v_jk)\n                \n                if norm_ji == 0 or norm_jk == 0:\n                    return np.inf # Penalize collapsed atoms with infinite energy\n\n                cos_theta = np.dot(v_ji, v_jk) / (norm_ji * norm_jk)\n                cos_theta_clipped = np.clip(cos_theta, -1.0, 1.0)\n                theta_rad = np.arccos(cos_theta_clipped)\n                theta_0_rad = np.deg2rad(theta_0_deg)\n                energy += 0.5 * k_theta * (theta_rad - theta_0_rad)**2\n            \n            return energy\n\n        # --- Constraints ---\n        constraints = []\n        if 'H' in case['atoms']:\n            h_indices = case['atoms']['H']\n            bonded_h_pairs = set()\n            for i, j, _, _ in case['bonds']:\n                if i in h_indices and j in h_indices:\n                    bonded_h_pairs.add(tuple(sorted((i, j))))\n\n            for i in range(len(h_indices)):\n                for j in range(i + 1, len(h_indices)):\n                    p, q = h_indices[i], h_indices[j]\n                    if tuple(sorted((p, q))) not in bonded_h_pairs:\n                        # Constraint is dist >= 2.0, which scipy expects as dist - 2.0 >= 0\n                        def constr_func(x, p=p, q=q):\n                            coords = x.reshape(-1, 3)\n                            dist = np.linalg.norm(coords[p] - coords[q])\n                            return dist - 2.0\n                        \n                        constraints.append({'type': 'ineq', 'fun': constr_func})\n\n        # --- Optimization ---\n        x0 = case['initial_coords'].flatten()\n        bonds = case['bonds']\n        angles = case['angles']\n        \n        opt_result = minimize(\n            objective_function, \n            x0, \n            args=(bonds, angles), \n            method='SLSQP', \n            constraints=constraints\n        )\n\n        results.append(opt_result.fun)\n    \n    # Final print statement in the exact required format.\n    formatted_results = \",\".join([f\"{r:.3f}\" for r in results])\n    print(f\"[{formatted_results}]\")\n\nsolve()\n```", "id": "2453470"}, {"introduction": "最后，我们将应用范围从单个分子扩展到扩展材料。本练习 [@problem_id:2453398] 模拟了晶界（晶体中的一种缺陷）的弛豫过程，即原子如何调整自身位置以适应两个不同取向晶粒之间的错位。在这里，约束条件是代表体相晶体的模拟盒子边缘的原子的固定位置，这是一种常见的等式约束，在材料建模中广泛应用。这个例子展示了如何处理包含大量变量的复杂优化问题。", "problem": "考虑一个单原子硅二维条带，其在方形晶格上建模，并具有最近邻谐波相互作用。设晶格有 $N_x$ 列和 $N_y$ 行，两个方向上的晶格间距均为 $a$。每个原子的位置为 $\\mathbf{r}_{i,j} \\in \\mathbb{R}^2$，其中列索引 $i \\in \\{0,1,\\dots,N_x-1\\}$，行索引 $j \\in \\{0,1,\\dots,N_y-1\\}$。总势能由所有最近邻原子对（水平和垂直）的求和定义为\n$$\nE(\\{\\mathbf{r}_{i,j}\\}) \\;=\\; \\sum_{\\langle (i,j),(i',j') \\rangle} \\frac{k}{2} \\left(\\|\\mathbf{r}_{i,j} - \\mathbf{r}_{i',j'}\\| - a \\right)^2,\n$$\n其中 $k$ 是一个正常数刚度常数，求和遍历所有由水平或垂直晶格键连接的无序最近邻原子对 $\\langle (i,j),(i',j') \\rangle$。\n\n定义旋转矩阵\n$$\nR(\\theta) \\;=\\; \\begin{bmatrix}\n\\cos\\theta  -\\sin\\theta \\\\\n\\sin\\theta  \\cos\\theta\n\\end{bmatrix}.\n$$\n令 $W = (N_x - 1)\\,a$。左边缘（$i=0$）和右边缘（$i=N_x-1$）的原子受到约束，以匹配由角度 $\\alpha_L$ 和 $\\alpha_R$（单位为弧度）分别表征的两种不同晶格取向。这通过以下等式约束实现，适用于所有 $j \\in \\{0,1,\\dots,N_y-1\\}$：\n$$\n\\mathbf{r}_{0,j} \\;=\\; R(\\alpha_L)\\,\\begin{bmatrix} 0 \\\\ j\\,a \\end{bmatrix}, \n\\qquad\n\\mathbf{r}_{N_x-1,j} \\;=\\; R(\\alpha_R)\\,\\begin{bmatrix} W \\\\ j\\,a \\end{bmatrix}.\n$$\n所有 $i \\in \\{1,2,\\dots,N_x-2\\}$ 的原子都可以在 $\\mathbb{R}^2$ 中自由移动。\n\n对于下方的每组参数，计算在满足上述等式约束条件下的 $E(\\{\\mathbf{r}_{i,j}\\})$ 的最小值。使用以下测试套件（角度单位为弧度，能量要求使用约化单位，其中 $k$ 和 $a$ 为给定值，位置也使用相同的约化单位）。您的程序必须从一个合理的、确定性的初始条件开始最小化能量，并为每种情况返回最小化的总能量（一个实数）。\n\n测试套件（每种情况是一个元组 $(N_x, N_y, a, k, \\alpha_L, \\alpha_R)$）：\n1. $(4, 3, 1.0, 1.0, 0.0, 0.0)$\n2. $(5, 4, 1.0, 1.0, -0.2, 0.2)$\n3. $(5, 1, 1.0, 1.0, 0.0, 0.5)$\n4. $(3, 3, 1.0, 0.5, 0.3, -0.3)$\n\n要求：\n- 角度必须以弧度为单位进行解释。\n- 将每个最小化能量报告为约化能量单位（无物理单位）的浮点数，由您的程序四舍五入到小数点后六位。\n- 您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表，结果按测试套件的顺序列出，例如 $[e_1,e_2,e_3,e_4]$，其中每个 $e_i$ 是情况 $i$ 的最小化能量。\n\n您的实现必须对所定义的 $N_x$、$N_y$、$a$、$k$、$\\alpha_L$ 和 $\\alpha_R$ 具有通用性。不得使用任何随机化方法。无约束原子的初始位置应以确定性方式选择，并且必须与给定的几何结构一致；例如，使用 $\\alpha_L$ 和 $\\alpha_R$ 之间的取向角的逐列线性插值来构建初始猜测\n$$\n\\mathbf{r}^{(0)}_{i,j} \\;=\\; R\\!\\left(\\alpha_L + \\frac{i}{N_x - 1}(\\alpha_R - \\alpha_L)\\right)\\!\n\\begin{bmatrix} i\\,a \\\\ j\\,a \\end{bmatrix},\n\\quad \\text{for all } i \\in \\{0,\\dots,N_x-1\\},\\; j \\in \\{0,\\dots,N_y-1\\},\n$$\n同时在 $i=0$ 和 $i=N_x-1$ 处强制执行精确的边界约束。\n\n最终输出格式必须是单行：\n- 一个形如 $[e_1,e_2,e_3,e_4]$ 的列表式字符串，其中每个 $e_i$ 是一个四舍五入到小数点后六位的浮点数。", "solution": "所提出的问题是计算化学领域中一个适定性很好的练习，特别是在分子力学和几何优化领域。它要求在固定边界条件下，最小化一个二维原子晶格的势能函数。该问题具有科学依据，数学上清晰，并包含了确定性求解所需的所有信息。\n\n任务是找到势能函数 $E(\\{\\mathbf{r}_{i,j}\\})$ 的最小值：\n$$\nE(\\{\\mathbf{r}_{i,j}\\}) \\;=\\; \\sum_{\\langle (i,j),(i',j') \\rangle} \\frac{k}{2} \\left(\\|\\mathbf{r}_{i,j} - \\mathbf{r}_{i',j'}\\| - a \\right)^2\n$$\n此优化的变量是“自由”原子的坐标，即列索引为 $i \\in \\{1, 2, \\dots, N_x-2\\}$ 的原子。位于边界 $i=0$ 和 $i=N_x-1$ 处的原子，其位置由给定的约束条件固定。自由原子的总数为 $N_{free} = (N_x-2) \\times N_y$，并且由于每个原子有两个坐标，因此优化在维度为 $2 \\cdot N_{free}$ 的空间中进行。\n\n这是一个无约束的非线性优化问题。为了解决这个问题，我们采用了一种基于梯度的拟牛顿法，特别是 L-BFGS-B 算法，该算法以其解决此类问题的效率而闻名。这一选择要求目标函数 $E$ 相对于自由原子坐标的解析梯度。使用解析梯度优于数值近似，因为它能提供更高的准确性和计算效率。\n\n让我们来推导梯度。势能 $E$ 是与最近邻原子对相关的项的总和。$E$ 相对于一个自由原子 $(m,n)$ 的位置向量 $\\mathbf{r}_{m,n}$ 的梯度，是其与邻近原子相互作用贡献的总和。考虑原子 $(m,n)$ 与其邻近原子 $(i',j')$ 之间的单个相互作用项，记为 $E_{pair}$：\n$$\nE_{pair} = \\frac{k}{2} \\left(\\|\\mathbf{r}_{m,n} - \\mathbf{r}_{i',j'}\\| - a \\right)^2\n$$\n该项相对于 $\\mathbf{r}_{m,n}$ 的梯度为：\n$$\n\\nabla_{\\mathbf{r}_{m,n}} E_{pair} = k \\left(\\|\\mathbf{r}_{m,n} - \\mathbf{r}_{i',j'}\\| - a \\right) \\frac{\\partial}{\\partial \\mathbf{r}_{m,n}} \\|\\mathbf{r}_{m,n} - \\mathbf{r}_{i',j'}\\|\n$$\n欧几里得范数的导数为 $\\frac{\\partial}{\\partial \\mathbf{v}} \\|\\mathbf{v}\\| = \\frac{\\mathbf{v}}{\\|\\mathbf{v}\\|}$。应用此公式，我们得到：\n$$\n\\nabla_{\\mathbf{r}_{m,n}} E_{pair} = k \\left(\\|\\mathbf{r}_{m,n} - \\mathbf{r}_{i',j'}\\| - a \\right) \\frac{\\mathbf{r}_{m,n} - \\mathbf{r}_{i',j'}}{\\|\\mathbf{r}_{m,n} - \\mathbf{r}_{i',j'}\\|} = k \\left(1 - \\frac{a}{\\|\\mathbf{r}_{m,n} - \\mathbf{r}_{i',j'}\\|}\\right) (\\mathbf{r}_{m,n} - \\mathbf{r}_{i',j'})\n$$\n原子 $(m,n)$ 的总梯度是来自其所有最近邻 $(i',j')$ 的这些贡献的向量和：\n$$\n\\nabla_{\\mathbf{r}_{m,n}} E = \\sum_{(i',j') \\text{ neighbor of } (m,n)} k \\left(1 - \\frac{a}{\\|\\mathbf{r}_{m,n} - \\mathbf{r}_{i',j'}\\|}\\right) (\\mathbf{r}_{m,n} - \\mathbf{r}_{i',j'})\n$$\n此表达式在任意两个原子不重叠，即 $\\|\\mathbf{r}_{m,n} - \\mathbf{r}_{i',j'}\\| \\neq 0$ 的条件下有效，这个条件对于任何物理上合理的构型都成立。\n\n求解步骤如下：\n1.  对于每个测试用例，我们首先建立系统的几何结构。所有原子（包括固定和自由的）的位置都存储在一个形状为 $(N_x, N_y, 2)$ 的三维数组中。\n2.  根据约束条件计算固定边界原子的位置。\n3.  使用问题描述中提供的确定性公式生成自由原子的初始构型。该公式定义了从左边界到右边界晶格取向的平滑插值。然后将这些自由原子的坐标展开成一个一维向量，作为优化器的初始猜测值 $\\mathbf{x}_0$。\n4.  我们定义两个传递给优化器的函数：\n    a. 一个能量函数，它接受一个包含自由原子坐标的一维向量，重构完整的原子位置数组，并计算总势能 $E$。\n    b. 一个梯度函数，它接受相同的一维向量，重构位置数组，使用推导出的公式计算每个自由原子的梯度向量 $\\nabla E$，并以一维向量的形式返回结果。\n5.  调用带有 `L-BFGS-B` 方法的 `scipy.optimize.minimize` 函数，使用初始猜测值 $\\mathbf{x}_0$ 以及解析的能量和梯度函数。优化过程将持续进行，直到梯度范数低于指定的容差，从而确保找到一个驻点。\n6.  提取并存储最小化后的能量，即在找到的最优点处的函数值。对所有测试用例重复此过程。然后按要求格式化所得能量。\n\n对于第一个测试用例，$(N_x, N_y, a, k, \\alpha_L, \\alpha_R) = (4, 3, 1.0, 1.0, 0.0, 0.0)$，边界角度为零。初始猜测对应于一个完美的、未旋转的晶格，其中每个最近邻距离都恰好是 $a$。此构型的势能恒为零。由于能量是非负项的总和，因此这是全局最小值。梯度也恒为零，因此优化器将立即终止，返回能量值 $0.0$。这可以作为对该方法的验证。对于其他边界角度非零的情况，会引入应变，预计会得到一个非零的最小能量。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    \"\"\"\n    test_cases = [\n        (4, 3, 1.0, 1.0, 0.0, 0.0),\n        (5, 4, 1.0, 1.0, -0.2, 0.2),\n        (5, 1, 1.0, 1.0, 0.0, 0.5),\n        (3, 3, 1.0, 0.5, 0.3, -0.3)\n    ]\n\n    results = []\n    for case in test_cases:\n        energy = compute_minimized_energy(*case)\n        results.append(f\"{energy:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef compute_minimized_energy(Nx, Ny, a, k, alpha_L, alpha_R):\n    \"\"\"\n    Computes the minimum energy for a single parameter set.\n    \"\"\"\n    if Nx  3:\n        # No free atoms, calculate energy of the fixed configuration.\n        pos = np.zeros((Nx, Ny, 2))\n        _set_boundary_positions(pos, Nx, Ny, a, alpha_L, alpha_R)\n        return _calculate_energy(pos, Nx, Ny, a, k)\n\n    # All atom positions, including fixed boundaries\n    all_pos = np.zeros((Nx, Ny, 2))\n    \n    # Set fixed boundary positions\n    _set_boundary_positions(all_pos, Nx, Ny, a, alpha_L, alpha_R)\n\n    # Initial guess for all atoms based on interpolated angle\n    initial_all_pos = np.zeros((Nx, Ny, 2))\n    for i in range(Nx):\n        alpha_i = alpha_L + i / (Nx - 1) * (alpha_R - alpha_L)\n        R_i = _rotation_matrix(alpha_i)\n        for j in range(Ny):\n            # The initial guess formula is applied to all atoms\n            # We then overwrite boundaries to ensure they are exact\n            if i == 0:\n                initial_all_pos[i, j] = all_pos[i,j]\n            elif i == Nx - 1:\n                initial_all_pos[i, j] = all_pos[i,j]\n            else:\n                base_pos = np.array([i * a, j * a])\n                initial_all_pos[i, j] = R_i @ base_pos\n    \n    # Optimization variables are the coordinates of the free atoms\n    x0 = initial_all_pos[1:Nx-1, :, :].flatten()\n    \n    def _get_full_pos(x_flat):\n        \"\"\"Reconstruct the full position array from the flat vector of free variables.\"\"\"\n        full_pos = np.copy(all_pos)\n        full_pos[1:Nx-1, :, :] = x_flat.reshape((Nx - 2, Ny, 2))\n        return full_pos\n\n    def energy_function(x_flat):\n        \"\"\"Calculates the total potential energy.\"\"\"\n        current_pos = _get_full_pos(x_flat)\n        return _calculate_energy(current_pos, Nx, Ny, a, k)\n\n    def gradient_function(x_flat):\n        \"\"\"Calculates the gradient of the energy with respect to the free variables.\"\"\"\n        current_pos = _get_full_pos(x_flat)\n        grad = np.zeros((Nx - 2, Ny, 2))\n\n        for i in range(1, Nx - 1):\n            for j in range(Ny):\n                r_ij = current_pos[i, j]\n                grad_ij = np.zeros(2)\n\n                # Neighbors: left, right, top, bottom\n                neighbors_indices = [(i - 1, j), (i + 1, j)]\n                if j > 0:\n                    neighbors_indices.append((i, j - 1))\n                if j  Ny - 1:\n                    neighbors_indices.append((i, j + 1))\n\n                for ni, nj in neighbors_indices:\n                    r_neighbor = current_pos[ni, nj]\n                    d_vec = r_ij - r_neighbor\n                    dist = np.linalg.norm(d_vec)\n                    \n                    if dist > 1e-12: # Avoid division by zero\n                        grad_ij += k * (1 - a / dist) * d_vec\n                \n                grad[i - 1, j, :] = grad_ij\n        \n        return grad.flatten()\n\n    res = minimize(energy_function, x0, method='L-BFGS-B', jac=gradient_function,\n                   options={'gtol': 1e-7, 'ftol': 1e-12})\n\n    return res.fun\n\ndef _rotation_matrix(theta):\n    \"\"\"Returns the 2D rotation matrix R(theta).\"\"\"\n    c, s = np.cos(theta), np.sin(theta)\n    return np.array([[c, -s], [s, c]])\n\ndef _set_boundary_positions(pos_array, Nx, Ny, a, alpha_L, alpha_R):\n    \"\"\"Sets the coordinates of the fixed boundary atoms.\"\"\"\n    R_L = _rotation_matrix(alpha_L)\n    for j in range(Ny):\n        pos_array[0, j] = R_L @ np.array([0, j * a])\n\n    if Nx > 1:\n        R_R = _rotation_matrix(alpha_R)\n        W = (Nx - 1) * a\n        for j in range(Ny):\n            pos_array[Nx - 1, j] = R_R @ np.array([W, j * a])\n\ndef _calculate_energy(pos, Nx, Ny, a, k):\n    \"\"\"Helper function to calculate total energy for a given configuration.\"\"\"\n    total_energy = 0.0\n    # Sum over horizontal bonds\n    for i in range(Nx - 1):\n        for j in range(Ny):\n            d_vec = pos[i, j] - pos[i + 1, j]\n            dist = np.linalg.norm(d_vec)\n            total_energy += 0.5 * k * (dist - a)**2\n    # Sum over vertical bonds\n    for i in range(Nx):\n        for j in range(Ny - 1):\n            d_vec = pos[i, j] - pos[i, j + 1]\n            dist = np.linalg.norm(d_vec)\n            total_energy += 0.5 * k * (dist - a)**2\n    return total_energy\n\nsolve()\n```", "id": "2453398"}]}