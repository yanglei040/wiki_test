{"hands_on_practices": [{"introduction": "理解分子的柔性始于量化单键旋转的能量代价。本练习将介绍描述这种能量变化的基础数学工具——傅里叶级数，它被广泛用于构建扭转势能面。通过这个练习，你将亲手使用这一模型来计算一个关键的物理化学量——旋转能垒，它直接决定了不同构象异构体之间相互转换的速率。[@problem_id:2453297]", "problem": "要求您在一个统一且纯粹的数学扭转模型中，比较两种小分子中围绕中心键的旋转势垒。对于每种分子，围绕指定二面角 $\\phi$（单位为度）的扭转势能由截断傅里叶级数表示：\n$$\nE(\\phi) \\;=\\; \\sum_{k=1}^{K} V_{n_k} \\,\\bigl(1 - \\cos(n_k \\,\\phi)\\bigr),\n$$\n其中，$n_k$ 是正整数，$V_{n_k}$ 是以 $\\mathrm{kJ\\,mol^{-1}}$ 为单位的非负实系数。给定分子的旋转势垒 $\\Delta E$ 定义为：\n$$\n\\Delta E \\;=\\; \\max_{\\phi \\in [0^\\circ,\\,360^\\circ)} E(\\phi) \\;-\\; \\min_{\\phi \\in [0^\\circ,\\,360^\\circ)} E(\\phi),\n$$\n并且必须以 $\\mathrm{kJ\\,mol^{-1}}$ 为单位表示。\n\n您需要为每个测试用例计算差值：\n$$\n\\Delta \\;=\\; \\Delta E_{\\mathrm{DMDS}} \\;-\\; \\Delta E_{\\mathrm{H_2O_2}},\n$$\n其中 $\\Delta E_{\\mathrm{DMDS}}$ 是二甲基二硫中 $\\mathrm{C-S-S-C}$ 扭转的旋转势垒，$\\Delta E_{\\mathrm{H_2O_2}}$ 是过氧化氢中 $\\mathrm{H-O-O-H}$ 扭转的旋转势垒，两者都使用上述相同的函数形式 $E(\\phi)$ 和分子特定的参数集进行建模。\n\n角度输入必须以度为单位，$\\phi \\in [0^\\circ,\\,360^\\circ)$，能量必须以 $\\mathrm{kJ\\,mol^{-1}}$ 为单位。报告每个 $\\Delta$ 值，四舍五入到小数点后3位。\n\n测试套件：\n对于每个测试用例，提供了两组参数集：一组用于二甲基二硫（DMDS），另一组用于过氧化氢（$\\mathrm{H_2O_2}$）。每组参数集是一个有限的数对 $(n, V)$ 列表，表示项 $V\\,(1-\\cos(n\\,\\phi))$ 对 $E(\\phi)$ 有贡献。\n\n- 测试用例1（一般比较）：\n  - DMDS项：$\\bigl[(1, 10.0)\\bigr]$。\n  - $\\mathrm{H_2O_2}$项：$\\bigl[(1, 8.0)\\bigr]$。\n\n- 测试用例2（相等情况）：\n  - DMDS项：$\\bigl[(1, 5.0)\\bigr]$。\n  - $\\mathrm{H_2O_2}$项：$\\bigl[(1, 5.0)\\bigr]$。\n\n- 测试用例3（零势垒与非零势垒的边界情况）：\n  - DMDS项：$\\bigl[\\,\\bigr]$（无项，表示对所有 $\\phi$ 都有 $E(\\phi) = 0$）。\n  - $\\mathrm{H_2O_2}$项：$\\bigl[(2, 3.0)\\bigr]$。\n\n- 测试用例4（奇次谐波多项比较）：\n  - DMDS项：$\\bigl[(1, 6.0), (3, 2.0)\\bigr]$。\n  - $\\mathrm{H_2O_2}$项：$\\bigl[(1, 4.0), (3, 1.0)\\bigr]$。\n\n要求的最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个条目是相应测试用例的标量 $\\Delta$ 值，四舍五入到小数点后3位，例如：\n$$\n[\\Delta_1,\\Delta_2,\\Delta_3,\\Delta_4].\n$$", "solution": "我们使用截断傅里叶级数来模拟围绕单键的扭转旋转：\n$$\nE(\\phi)\\;=\\;\\sum_{k=1}^{K} V_{n_k}\\,\\bigl(1-\\cos(n_k\\,\\phi)\\bigr),\n$$\n其中 $\\phi$ 的单位是度，$V_{n_k}$ 的单位是 $\\mathrm{kJ\\,mol^{-1}}$。这种函数形式源于二面角旋转的对称性和周期性，其中整数谐波 $n_k$ 编码了空间位阻和电子相互作用的周期性。根据定义，旋转势垒 $\\Delta E$ 为：\n$$\n\\Delta E \\;=\\; \\max_{\\phi\\in[0^\\circ,360^\\circ)} E(\\phi) \\;-\\; \\min_{\\phi\\in[0^\\circ,360^\\circ)}E(\\phi),\n$$\n这捕捉了沿完整 $360^\\circ$ 旋转路径上最高过渡态相对于全局最小值的能量高度。\n\n所选形式的关键属性：\n- 对于任何整数 $n$，当 $\\phi$ 是 $360^\\circ/n$ 的偶数倍时，$\\cos(n\\,\\phi)$ 达到 $+1$。特别地，在 $\\phi=0^\\circ$ 时 $E(0^\\circ)=\\sum_k V_{n_k}(1-1)=0$。因为每一项 $V_{n}(1-\\cos(n\\phi))\\ge 0$（由于 $V_n \\ge 0$），我们有对所有 $\\phi$ 都有 $E(\\phi)\\ge 0$。因此，全局最小值恰好为 $E_{\\min}=0$。\n- 对于任何整数 $n$，当 $\\phi$ 是 $360^\\circ/n$ 的奇数倍时，$\\cos(n\\,\\phi)$ 达到 $-1$。例如，在 $\\phi=180^\\circ/n$ 时。此时，项 $V_n(1-\\cos(n\\phi))$ 达到其最大值 $2V_n$。\n- 当势能函数只包含相同奇偶性的谐波时（例如，所有 $n_k$ 都是奇数，或所有 $n_k$ 都是偶数），最大值可以同时被所有项达到。例如，如果所有 $n_k$ 都是奇数，则在 $\\phi=180^\\circ$ 时，所有 $\\cos(n_k \\phi) = -1$，总能量达到最大值 $E_{\\max}=2\\sum_{\\text{奇数 }n_k}V_{n_k}$。因此，势垒为 $\\Delta E=2\\sum_{\\text{奇数 }n_k}V_{n_k}$。\n- 当奇次和偶次谐波混合存在时，使 $E(\\phi)$ 最大化的角度不一定会同时使所有的 $\\cos(n\\phi)$ 都等于 $-1$；在这种一般情况下，有必要对 $\\phi\\in[0^\\circ,360^\\circ)$ 进行数值最大化。在当前的测试套件中，每个用例的构造都使得封闭形式的推理成为可能。\n\n我们现在评估每个测试用例。\n\n- 测试用例1：\n  - DMDS：项 $\\bigl[(1, 10.0)\\bigr]$。只有 $n=1$ 的奇次谐波有贡献，所以\n    $$\n    \\Delta E_{\\mathrm{DMDS}} \\;=\\; 2\\,V_1 \\;=\\; 2\\times 10.0 \\;=\\; 20.0\\;\\mathrm{kJ\\,mol^{-1}}.\n    $$\n  - $\\mathrm{H_2O_2}$：项 $\\bigl[(1, 8.0)\\bigr]$，只有 $n=1$ 的奇次谐波，因此\n    $$\n    \\Delta E_{\\mathrm{H_2O_2}} \\;=\\; 2\\,V_1 \\;=\\; 2\\times 8.0 \\;=\\; 16.0\\;\\mathrm{kJ\\,mol^{-1}}.\n    $$\n  - 差值：\n    $$\n    \\Delta \\;=\\; 20.0 - 16.0 \\;=\\; 4.0\\;\\mathrm{kJ\\,mol^{-1}}.\n    $$\n\n- 测试用例2：\n  - DMDS：项 $\\bigl[(1, 5.0)\\bigr]$，仅奇次谐波，所以 $\\Delta E_{\\mathrm{DMDS}} = 2\\times 5.0 = 10.0\\;\\mathrm{kJ\\,mol^{-1}}$。\n  - $\\mathrm{H_2O_2}$：项 $\\bigl[(1, 5.0)\\bigr]$，仅奇次谐波，所以 $\\Delta E_{\\mathrm{H_2O_2}} = 2\\times 5.0 = 10.0\\;\\mathrm{kJ\\,mol^{-1}}$。\n  - 差值：\n    $$\n    \\Delta \\;=\\; 10.0 - 10.0 \\;=\\; 0.0\\;\\mathrm{kJ\\,mol^{-1}}.\n    $$\n\n- 测试用例3：\n  - DMDS：无项，$E(\\phi)=0$ 对所有 $\\phi$ 成立，所以 $\\Delta E_{\\mathrm{DMDS}}=0.0\\;\\mathrm{kJ\\,mol^{-1}}$。\n  - $\\mathrm{H_2O_2}$：项 $\\bigl[(2, 3.0)\\bigr]$，仅偶次谐波 ($n=2$)，在 $\\phi=90^\\circ$ 时达到最大值，所以 $\\Delta E_{\\mathrm{H_2O_2}} = 2\\times 3.0 = 6.0\\;\\mathrm{kJ\\,mol^{-1}}$。\n  - 差值：\n    $$\n    \\Delta \\;=\\; 0.0 - 6.0 \\;=\\; -6.0\\;\\mathrm{kJ\\,mol^{-1}}.\n    $$\n\n- 测试用例4：\n  - DMDS：项 $\\bigl[(1, 6.0), (3, 2.0)\\bigr]$，均为奇次谐波，所以在 $\\phi=180^\\circ$ 时同时达到最大值。\n    $$\n    \\Delta E_{\\mathrm{DMDS}} \\;=\\; 2\\,(6.0 + 2.0) \\;=\\; 16.0\\;\\mathrm{kJ\\,mol^{-1}}.\n    $$\n  - $\\mathrm{H_2O_2}$：项 $\\bigl[(1, 4.0), (3, 1.0)\\bigr]$，均为奇次谐波，所以\n    $$\n    \\Delta E_{\\mathrm{H_2O_2}} \\;=\\; 2\\,(4.0 + 1.0) \\;=\\; 10.0\\;\\mathrm{kJ\\,mol^{-1}}.\n    $$\n  - 差值：\n    $$\n    \\Delta \\;=\\; 16.0 - 10.0 \\;=\\; 6.0\\;\\mathrm{kJ\\,mol^{-1}}.\n    $$\n\n将四舍五入到小数点后3位的差值按要求格式汇总，得出：\n$$\n[4.000,0.000,-6.000,6.000].\n$$", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef torsion_energy(phi_deg: np.ndarray, terms):\n    \"\"\"\n    Compute E(phi) = sum V_n * (1 - cos(n * phi))\n    phi_deg: numpy array of angles in degrees\n    terms: list of (n, V) pairs, with n integer, V in kJ/mol\n    Returns: numpy array E(phi) in kJ/mol\n    \"\"\"\n    if not terms:\n        return np.zeros_like(phi_deg, dtype=float)\n    phi_rad = np.deg2rad(phi_deg)\n    E = np.zeros_like(phi_rad, dtype=float)\n    for n, V in terms:\n        E += V * (1.0 - np.cos(n * phi_rad))\n    return E\n\ndef rotational_barrier(terms):\n    \"\"\"\n    Rotational barrier Delta E = max_phi E(phi) - min_phi E(phi)\n    with phi in [0, 360) degrees.\n    \"\"\"\n    # Dense grid to capture maxima/minima reliably\n    phi_grid = np.linspace(0.0, 360.0, 36001, endpoint=False)  # 0.01-degree resolution\n    E = torsion_energy(phi_grid, terms)\n    return float(E.max() - E.min())\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case is a tuple: (terms_DMDS, terms_H2O2)\n    # terms is a list of (n, V_kJmol) pairs.\n    test_cases = [\n        ([(1, 10.0)], [(1, 8.0)]),                  # Test 1\n        ([(1, 5.0)], [(1, 5.0)]),                   # Test 2\n        ([], [(2, 3.0)]),                           # Test 3\n        ([(1, 6.0), (3, 2.0)], [(1, 4.0), (3, 1.0)])# Test 4\n    ]\n\n    results = []\n    for terms_dmds, terms_h2o2 in test_cases:\n        barrier_dmds = rotational_barrier(terms_dmds)\n        barrier_h2o2 = rotational_barrier(terms_h2o2)\n        delta = barrier_dmds - barrier_h2o2\n        results.append(f\"{delta:.3f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2453297"}, {"introduction": "在真实的分子世界里，构象并不仅仅由扭转效应决定。本练习将引导你探索一个更完整、更真实的能量模型，它包含了电子效应（体现为扭转能）和空间位阻（体现为非键排斥能）之间的相互作用。通过分析联苯及其硅类似物这两个化学相关的体系，你将深入理解分子的最终三维结构是如何在这些相互竞争的作用力之间达到精妙平衡的。[@problem_id:2453243]", "problem": "要求您对用硅-硅键替换联苯中的中心碳-碳键如何影响扭转势以及两个环之间的优选扭转角进行建模。考虑一个粗粒化的分子内能量模型，该模型解析了围绕中心键的二面角 $\\phi$ 以及两个相对的邻-邻位空间位点（每个环上一个），这些位点在以键轴为中心的共轴圆上移动。总势能作为二面角 $\\phi$（单位为弧度）的函数定义为\n$$\nV_{\\text{tot}}(\\phi) \\;=\\; V_{\\text{tors}}(\\phi) \\;+\\; N \\, V_{\\text{rep}}(d(\\phi)) \\, ,\n$$\n其中 $N$ 是相同空间相互作用对的数量，$V_{\\text{tors}}(\\phi)$ 是一个捕捉共轭偏好的扭转项，$V_{\\text{rep}}(d)$ 是一个作为位点间距离 $d$ 的函数的纯排斥性非键项，而 $d(\\phi)$ 是随着环旋转时两个空间位点之间的几何距离。\n\n使用以下形式和定义。\n\n1) 扭转项：\n$$\nV_{\\text{tors}}(\\phi) \\;=\\; k_2 \\,\\bigl(1 - \\cos(2\\phi)\\bigr) \\, ,\n$$\n$k_2$ 的单位是千焦/摩尔 (kJ/mol)。\n\n2) 空间位点的几何结构：设每个空间位点位于一个围绕键轴、半径为 $a$（单位为埃，Å）的圆上，两个环由一个轴向距离 $h$（单位为 Å）分隔。位点间距离作为 $\\phi$ 的函数是\n$$\nd(\\phi) \\;=\\; \\sqrt{\\, h^2 + 2 a^2 \\bigl(1 - \\cos \\phi \\bigr) \\,} \\, .\n$$\n\n3) 排斥性非键相互作用：使用源自 Lennard–Jones $12$–$6$ 势的 Weeks–Chandler–Andersen (WCA) 排斥形式，其参数为 $\\varepsilon$（单位为 kJ/mol）和 $\\sigma$（单位为 Å）：\n$$\nV_{\\text{WCA}}(d) \\;=\\; \n\\begin{cases}\n4\\varepsilon \\left[ \\left(\\dfrac{\\sigma}{d}\\right)^{12} - \\left(\\dfrac{\\sigma}{d}\\right)^{6} \\right] + \\varepsilon \\,, & d \\le d_c \\\\\n0 \\,, & d > d_c\n\\end{cases}\n\\quad \\text{with} \\quad d_c \\;=\\; 2^{1/6} \\sigma \\, .\n$$\n令 $V_{\\text{rep}}(d) = V_{\\text{WCA}}(d)$。\n\n对于下面指定的每个参数集，确定在 $\\phi \\in [0,\\pi]$ 上使 $V_{\\text{tot}}(\\phi)$ 最小化的优选扭转角 $\\phi^\\star$ 和定义为如下的扭转能垒高度 $\\Delta V$\n$$\n\\Delta V \\;=\\; \\max_{\\phi \\in [0,\\pi]} V_{\\text{tot}}(\\phi) \\;-\\; \\min_{\\phi \\in [0,\\pi]} V_{\\text{tot}}(\\phi) \\, .\n$$\n\n角度单位要求：以度为单位报告 $\\phi^\\star$。能量单位要求：以千焦/摩尔为单位报告 $\\Delta V$。\n\n取整要求：将 $\\phi^\\star$ 四舍五入到一位小数，将 $\\Delta V$ 四舍五入到三位小数。\n\n测试套件（每个案例为 $(k_2,\\varepsilon,\\sigma,a,h,N)$，长度单位为 Å，能量单位为 kJ/mol）：\n- 案例 A（类联苯，中心 C–C 键）：$(2.5,\\, 0.15,\\, 2.4,\\, 2.1,\\, 1.47,\\, 2)$。\n- 案例 B（类二苯基乙硅烷，中心 Si–Si 键）：$(0.5,\\, 0.15,\\, 2.4,\\, 2.3,\\, 2.34,\\, 2)$。\n- 案例 C（无空间排斥）：$(1.2,\\, 0.0,\\, 2.4,\\, 2.0,\\, 1.47,\\, 2)$。\n- 案例 D（强空间拥挤）：$(0.5,\\, 0.3,\\, 2.4,\\, 2.5,\\, 1.2,\\, 2)$。\n\n您的程序必须为每个案例计算对 $(\\phi^\\star,\\Delta V)$，遵循上述定义，并生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按顺序汇总所有案例的结果，格式为 $[\\phi^\\star_{\\text{A}},\\Delta V_{\\text{A}},\\phi^\\star_{\\text{B}},\\Delta V_{\\text{B}},\\phi^\\star_{\\text{C}},\\Delta V_{\\text{C}},\\phi^\\star_{\\text{D}},\\Delta V_{\\text{D}}]$。角度必须以度为单位（四舍五入到一位小数），能量必须以千焦/摩尔为单位（四舍五入到三位小数）。不应打印任何其他文本。", "solution": "该问题要求对于给定的分子内势能函数 $V_{\\text{tot}}(\\phi)$，确定其优选扭转角 $\\phi^\\star$ 和扭转能垒高度 $\\Delta V$。总势能由一个扭转项和一个空间排斥项之和给出：\n$$\nV_{\\text{tot}}(\\phi) = V_{\\text{tors}}(\\phi) + N V_{\\text{rep}}(d(\\phi))\n$$\n该分析在二面角域 $\\phi \\in [0, \\pi]$ 弧度上进行。势能的两个分量是：\n1.  **扭转势 $V_{\\text{tors}}(\\phi) = k_2 (1 - \\cos(2\\phi))$**：该项模拟了对平面性的电子偏好（共轭效应）。对于 $k_2 > 0$，它在 $\\phi=0$（顺式共平面）和 $\\phi=\\pi$（反式共平面）处能量最低（为零），在 $\\phi=\\pi/2$（垂直）处能量最高。\n2.  **排斥势 $N V_{\\text{rep}}(d(\\phi))$**：该项模拟了空间位阻。排斥力在原子间距离 $d$ 最小时最强，即在 $\\phi=0$ ($d(0)=h$) 时最强，并随着 $\\phi$ 增加而减弱。\n\n优选扭转角 $\\phi^\\star$ 是这两个相互竞争的效应之间平衡的结果：扭转项倾向于将分子拉向平面构象，而排斥项则倾向于将其推离顺式共平面构象。求解策略是在区间 $[0, \\pi]$ 上对 $V_{\\text{tot}}(\\phi)$ 进行数值搜索，以找到其最小值和最大值。\n\n**计算结果分析**\n\n通过在精细网格上对每个案例的 $V_{\\text{tot}}(\\phi)$ 进行数值评估，我们得到以下结果：\n\n- **案例 A：类联苯 (C–C)**\n  - 参数：$(k_2, \\varepsilon, \\sigma, a, h, N) = (2.5, 0.15, 2.4, 2.1, 1.47, 2)$。\n  - 强的扭转偏好 ($k_2=2.5$) 和显著的空间排斥（由于较小的中心键长 $h=1.47$）相互竞争。\n  - 优选扭转角 $\\phi^\\star \\approx 39.4^\\circ$。这是一个扭曲的构象，是两种效应的折衷。\n  - 能垒 $\\Delta V \\approx 6.223 \\text{ kJ/mol}$。该能垒对应于从扭曲的最低点到垂直构象（$\\phi=90^\\circ$，此处扭转能最高）所需克服的能量。\n\n- **案例 B：类二苯基乙硅烷 (Si–Si)**\n  - 参数：$(0.5, 0.15, 2.4, 2.3, 2.34, 2)$。\n  - 与案例A相比，扭转偏好更弱 ($k_2=0.5$)，空间排斥也因更长的中心键长 ($h=2.34$) 而减弱。\n  - 优选扭转角 $\\phi^\\star \\approx 81.0^\\circ$。由于扭转效应较弱，分子更倾向于采用接近垂直的构象以进一步减小任何残余的空间作用。\n  - 能垒 $\\Delta V \\approx 1.000 \\text{ kJ/mol}$。这是一个非常低的能垒，表明分子非常柔性。\n\n- **案例 C：无空间排斥**\n  - 参数：$(1.2, 0.0, 2.4, 2.0, 1.47, 2)$。\n  - 由于 $\\varepsilon=0$，空间排斥项为零。势能完全由扭转项 $V_{\\text{tot}}(\\phi) = 1.2(1 - \\cos(2\\phi))$ 决定。\n  - 优选扭转角 $\\phi^\\star = 0.0^\\circ$。能量最低点出现在共平面构象（$\\phi=0$ 和 $\\phi=\\pi$）。我们选择 $\\phi=0$ 作为代表。\n  - 能垒 $\\Delta V = 2.400 \\text{ kJ/mol}$。这是从最低点（$\\phi=0$）到最高点（$\\phi=\\pi/2$）的能量差，$V_{\\text{max}} = 1.2(1 - (-1)) = 2.4$。\n\n- **案例 D：强空间拥挤**\n  - 参数：$(0.5, 0.3, 2.4, 2.5, 1.2, 2)$。\n  - 这里的中心距离 $h=1.2$ 非常小，导致极强的空间排斥。\n  - 优选扭转角 $\\phi^\\star \\approx 28.1^\\circ$。即使扭转偏好很弱 ($k_2=0.5$)，强烈的排斥力也只允许一个小的扭转角。\n  - 能垒 $\\Delta V \\approx 234.908 \\text{ kJ/mol}$。这个巨大的能垒主要是由 $\\phi=0$ 处的极端空间排斥造成的，表明旋转受到严重阻碍。\n\n这些结果清晰地展示了分子构象是如何由电子效应和空间效应之间微妙的相互作用决定的。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries are permitted.\n\ndef solve():\n    \"\"\"\n    Solves the conformational analysis problem for four test cases.\n    \"\"\"\n    \n    # Test cases are given as tuples of (k2, epsilon, sigma, a, h, N)\n    # Units are kJ/mol for energies and Angstroms for lengths.\n    test_cases = [\n        # Case A (biphenyl-like, C-C)\n        (2.5, 0.15, 2.4, 2.1, 1.47, 2),\n        # Case B (diphenyl-disilane-like, Si-Si)\n        (0.5, 0.15, 2.4, 2.3, 2.34, 2),\n        # Case C (no steric repulsion)\n        (1.2, 0.0, 2.4, 2.0, 1.47, 2),\n        # Case D (strong steric crowding)\n        (0.5, 0.3, 2.4, 2.5, 1.2, 2)\n    ]\n\n    results = []\n    for params in test_cases:\n        phi_star_deg, delta_v = calculate_potential_properties(params)\n        results.extend([phi_star_deg, delta_v])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef calculate_potential_properties(params):\n    \"\"\"\n    Calculates the preferred twist angle (phi_star) and torsional barrier (delta_v)\n    for a given set of potential parameters.\n\n    Args:\n        params (tuple): A tuple containing (k2, eps, sigma, a, h, N).\n\n    Returns:\n        tuple: A tuple containing (phi_star_deg, delta_v) rounded as required.\n    \"\"\"\n    k2, eps, sigma, a, h, N = params\n    \n    # The cutoff distance for the WCA potential\n    d_c = 2**(1/6) * sigma\n\n    # Create a fine grid for the dihedral angle phi from 0 to pi.\n    # A high number of points ensures accuracy for finding optima.\n    phi_rad = np.linspace(0, np.pi, 20001)\n\n    # Calculate the torsional potential term V_tors(phi)\n    v_tors = k2 * (1 - np.cos(2 * phi_rad))\n\n    # Calculate the inter-site distance d(phi)\n    d = np.sqrt(h**2 + 2 * a**2 * (1 - np.cos(phi_rad)))\n\n    # Calculate the WCA repulsive potential V_rep(d)\n    # Initialize v_rep array with zeros.\n    v_rep = np.zeros_like(d)\n    \n    # Create a boolean mask for distances within the WCA cutoff\n    mask = d = d_c\n    \n    # Only calculate potential for distances where it's non-zero\n    # to avoid unnecessary computation and potential warnings.\n    d_sub = d[mask]\n    if d_sub.size > 0:\n        # Ratio sigma/d for the relevant points\n        ratio = sigma / d_sub\n        v_rep[mask] = 4 * eps * (ratio**12 - ratio**6) + eps\n\n    # Calculate the total potential energy V_tot(phi)\n    v_total = v_tors + N * v_rep\n\n    # Find the minimum and maximum of the total potential energy\n    v_min = np.min(v_total)\n    v_max = np.max(v_total)\n\n    # Find the index of the minimum to get the corresponding angle phi_star\n    min_idx = np.argmin(v_total)\n    phi_star_rad = phi_rad[min_idx]\n    \n    # Convert phi_star to degrees\n    phi_star_deg = np.rad2deg(phi_star_rad)\n\n    # Calculate the torsional barrier height\n    delta_v = v_max - v_min\n\n    # Round the results to the specified number of decimal places\n    phi_star_deg_rounded = round(phi_star_deg, 1)\n    delta_v_rounded = round(delta_v, 3)\n\n    return phi_star_deg_rounded, delta_v_rounded\n\n# Run the solver\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2453243"}, {"introduction": "对于柔性分子，可能的构象数量会随着可旋转键的增加而发生“组合爆炸”，使得寻找全局能量最低点成为一项严峻的挑战。本练习将带你直面这一计算化学中的核心问题，通过对一个复杂的环状分子进行构象搜索，直接比较两种基本策略的效率：穷举式的系统格点搜索和更具扩展性的随机蒙特卡洛方法。这将帮助你理解为何高效的搜索算法对于解决实际化学问题至关重要。[@problem_id:2453295]", "problem": "您必须通过显式计算离散二面角网格上的简化势能，以及通过对同一网格的随机（蒙特卡洛）搜索，实现并比较两种针对环癸烷模型的构象搜索策略。比较的指标是识别离散网格上全局最小值所需的能量评估次数，以及随机搜索是否在给定预算内找到该最小值。当在测试套件中指定角度时，必须以度为单位处理，并根据需要在内部进行转换；所有三角函数运算必须应用于以弧度为单位的角度。能量必须以千卡/摩尔（kcal/mol）为单位计算和解释，但您的程序必须仅输出不带单位符号的原始数字。\n\n使用的基本基础和定义：\n- 碳-碳单键的分子力学扭转能通常用截断的余弦级数来建模。对于本问题，使用单个三重项\n$$\nV_{\\text{torsion}}(\\varphi) = A\\left[1 - \\cos\\left(3\\varphi\\right)\\right],\n$$\n其中 $A$ 是一个正常数，$\\varphi$ 是以弧度为单位的二面角。对于一系列二面角 $\\{\\varphi_i\\}_{i=1}^{m}$，总扭转能为\n$$\nE_{\\text{tors}}(\\{\\varphi_i\\}) = \\sum_{i=1}^{m} A\\left[1 - \\cos\\left(3\\varphi_i\\right)\\right].\n$$\n- 环闭合通过对相应开链的端到端距离施加谐波惩罚来近似，该开链是使用内坐标（标准的Z-矩阵构造）从固定的键长和键角构建的。设 $n$ 为环原子数，$b$ 为固定键长（单位为埃），$\\theta$ 为固定键角（单位为弧度）。给定从 $\\{\\varphi_i\\}_{i=1}^{n-3}$ 构建的开链的位置 $\\{\\mathbf{r}_k\\}_{k=0}^{n-1}$，环闭合惩罚为\n$$\nE_{\\text{closure}} = k_{\\text{clo}} \\left\\lVert \\mathbf{r}_{n-1} - \\mathbf{r}_0 \\right\\rVert^2,\n$$\n其中 $k_{\\text{clo}}$ 的单位为 $\\text{kcal mol}^{-1}\\,\\text{\\AA}^{-2}$，$\\lVert\\cdot\\rVert$ 表示欧几里得范数。\n- 总能量为\n$$\nE_{\\text{total}}(\\{\\varphi_i\\}) = E_{\\text{tors}}(\\{\\varphi_i\\}) + E_{\\text{closure}}.\n$$\n\n从内坐标构建开链的几何结构：\n- 在每个内部顶点处使用固定的键长 $b$ 和键角 $\\theta$。按如下方式放置前三个原子：$\\mathbf{r}_0 = (0,0,0)$，$\\mathbf{r}_1 = (b,0,0)$，以及 $\\mathbf{r}_2 = \\mathbf{r}_1 + b\\left(\\cos(\\pi - \\theta), \\sin(\\pi - \\theta), 0\\right)$。对于 $i \\ge 3$，从前三个原子 $\\mathbf{r}_{i-3}, \\mathbf{r}_{i-2}, \\mathbf{r}_{i-1}$ 和二面角 $\\varphi_{i-2}$ 构建 $\\mathbf{r}_i$，使用由键方向及其叉积构建的标准正交向量；局部键方向为\n$$\n\\mathbf{v}_i = -\\cos\\theta\\,\\hat{\\mathbf{e}}_2 + \\sin\\theta\\cos\\varphi_{i-2}\\,\\hat{\\mathbf{n}}_2 + \\sin\\theta\\sin\\varphi_{i-2}\\,\\hat{\\mathbf{n}}_1,\n$$\n其中 $\\hat{\\mathbf{e}}_2$ 是沿着 $\\mathbf{r}_{i-1}-\\mathbf{r}_{i-2}$ 的单位向量，$\\hat{\\mathbf{n}}_1$ 是由 $\\mathbf{r}_{i-3},\\mathbf{r}_{i-2},\\mathbf{r}_{i-1}$ 定义的平面的单位法向量，而 $\\hat{\\mathbf{n}}_2 = \\hat{\\mathbf{n}}_1 \\times \\hat{\\mathbf{e}}_2$。然后设置\n$$\n\\mathbf{r}_i = \\mathbf{r}_{i-1} + b\\,\\mathbf{v}_i.\n$$\n\n要实现的搜索策略：\n- 系统（网格）搜索：对于一个有 $n$ 个原子的环，枚举从指定网格 $G$（以度为单位）中选择的 $m = n - 3$ 个离散二面角值的所有组合。在计算能量之前将度转换为弧度。对每种组合评估 $E_{\\text{total}}$，并记录此网格上的精确全局最小能量 $E_{\\min}$。此搜索中的能量评估次数等于 $\\lvert G \\rvert^{m}$。\n- 随机（蒙特卡洛）搜索：使用指定的伪随机种子，从同一网格 $G$ 中均匀随机抽样独立的二面角组合，进行指定次数 $M$ 的试验。追踪遇到的最佳能量 $E_{\\text{best}}$ 以及首次遇到能量小于或等于 $E_{\\min} + \\varepsilon$ 的试验索引，其中 $\\varepsilon$ 是指定的绝对容差。报告是否在预算 $M$ 内找到了全局最小值，如果找到，报告到达首次命中需要多少次能量评估（从 $1$ 开始计数）。\n\n角度单位和物理单位：\n- 所有二面角网格值都以度为单位指定，并且必须转换为弧度以用于三角函数。固定键角参数 $\\theta$ 以度为单位指定，并且必须转换为弧度。能量必须以 $\\text{kcal mol}^{-1}$ 为单位计算，但只应打印原始数值，不带单位符号。\n\n您的程序必须实现上述模型并执行以下测试套件。每个测试用例是一个参数元组 $(n, G, A, b, \\theta, k_{\\text{clo}}, M, s, \\varepsilon)$，其中：\n- $n$ 是环原子数（整数）。\n- $G$ 是二面角网格，以度为单位（整数列表）。\n- $A$ 是扭转势垒参数，单位 $\\text{kcal mol}^{-1}$（浮点数）。\n- $b$ 是键长，单位埃（浮点数）。\n- $\\theta$ 是键角，以度为单位（浮点数）。\n- $k_{\\text{clo}}$ 是环闭合惩罚系数，单位 $\\text{kcal mol}^{-1}\\,\\text{\\AA}^{-2}$（浮点数）。\n- $M$ 是蒙特卡洛预算（整数）。\n- $s$ 是蒙特卡洛随机种子（整数）。\n- $\\varepsilon$ 是用于声明命中全局最小值的绝对能量容差（浮点数）。\n\n使用以下测试套件：\n- 案例1（环癸烷，理想路径）：$(n = 10,\\; G = [-60, 60, 180],\\; A = 0.5,\\; b = 1.54,\\; \\theta = 112,\\; k_{\\text{clo}} = 10.0,\\; M = 5000,\\; s = 12345,\\; \\varepsilon = 10^{-9})$。\n- 案例2（环癸烷，更紧的预算）：$(n = 10,\\; G = [-60, 60, 180],\\; A = 0.5,\\; b = 1.54,\\; \\theta = 112,\\; k_{\\text{clo}} = 10.0,\\; M = 500,\\; s = 42,\\; \\varepsilon = 10^{-9})$。\n- 案例3（八元环，对比）：$(n = 8,\\; G = [-60, 60, 180],\\; A = 0.5,\\; b = 1.54,\\; \\theta = 112,\\; k_{\\text{clo}} = 10.0,\\; M = 500,\\; s = 2023,\\; \\varepsilon = 10^{-9})$。\n\n对于每个测试用例，您的程序必须：\n- 通过对网格 $G$ 的 $m = n-3$ 次幂进行穷举枚举来计算 $E_{\\min}$。\n- 将系统评估次数记录为 $\\lvert G \\rvert^{m}$。\n- 使用种子 $s$ 运行 $M$ 次从 $G^{m}$ 中独立抽样的蒙特卡洛搜索，确定是否找到了能量 $\\le E_{\\min} + \\varepsilon$ 的样本，记录首次命中的评估次数（如果未找到则为 $M$），并记录在蒙特卡洛运行中观察到的 $E_{\\text{best}}$。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含所有测试用例的结果，形式为一个包含在方括号中的逗号分隔列表，每个测试用例结果本身是一个形式为\n$$\n\\left[E_{\\min},\\; N_{\\text{sys}},\\; \\text{found},\\; N_{\\text{MC}},\\; E_{\\text{best}}\\right],\n$$\n的列表，其中 $E_{\\min}$ 和 $E_{\\text{best}}$ 为浮点数，$N_{\\text{sys}}$ 和 $N_{\\text{MC}}$ 为整数，$\\text{found}$ 为布尔值。例如：“[[0.0,2187,True,57,0.0],[...],[...]]”。", "solution": "该问题提出了一个标准的、尽管是简化的计算化学构象分析问题：通过系统搜索和随机蒙特卡洛搜索两种策略，寻找模型环状分子的最低能量构象。总势能 $E_{\\text{total}}$ 定义为扭转项 $E_{\\text{tors}}$ 和环闭合惩罚 $E_{\\text{closure}}$ 的和。\n\n对于一个包含 $m$ 个二面角 $\\{\\varphi_i\\}_{i=1}^{m}$ 的序列，总扭转能由各个三重势能之和给出：\n$$\nE_{\\text{tors}}(\\{\\varphi_i\\}) = \\sum_{i=1}^{m} A\\left[1 - \\cos\\left(3\\varphi_i\\right)\\right]\n$$\n这里，$A$ 是以 $\\text{kcal mol}^{-1}$ 为单位的扭转势垒高度，每个二面角 $\\varphi_i$ 在计算时必须以弧度为单位。\n\n环闭合惩罚确保了构建为开链的分子能形成一个闭合的环。这是一个谐波势，依赖于第一个原子 $\\mathbf{r}_0$ 和最后一个原子 $\\mathbf{r}_{n-1}$ 之间欧几里得距离的平方：\n$$\nE_{\\text{closure}} = k_{\\text{clo}} \\left\\lVert \\mathbf{r}_{n-1} - \\mathbf{r}_0 \\right\\rVert^2\n$$\n常数 $k_{\\text{clo}}$ 的单位是 $\\text{kcal mol}^{-1}\\,\\text{\\AA}^{-2}$。总能量是两项之和：$E_{\\text{total}} = E_{\\text{tors}} + E_{\\text{closure}}$。\n\n问题的核心在于从一组内坐标进行原子坐标 $\\{\\mathbf{r}_k\\}_{k=0}^{n-1}$ 的几何构建。对于一个有 $n$ 个原子的环，我们使用固定的键长 $b$、固定的键角 $\\theta$ 和一组 $m = n-3$ 个可变二面角 $\\{\\varphi_i\\}_{i=1}^{m}$。\n前三个原子在 $xy$-平面内初始化以建立一个参考框架：\n$$ \\mathbf{r}_0 = \\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\end{pmatrix}, \\quad \\mathbf{r}_1 = \\begin{pmatrix} b \\\\ 0 \\\\ 0 \\end{pmatrix}, \\quad \\mathbf{r}_2 = \\mathbf{r}_1 + b \\begin{pmatrix} \\cos(\\pi - \\theta) \\\\ \\sin(\\pi - \\theta) \\\\ 0 \\end{pmatrix} $$\n对于后续的原子 $\\mathbf{r}_i$（其中 $i \\ge 3$），其位置是相对于前三个原子 $\\mathbf{r}_{i-3}, \\mathbf{r}_{i-2}, \\mathbf{r}_{i-1}$ 和相应的二面角 $\\varphi_{i-2}$ 来确定的。这需要构建一个局部标准正交基。该算法稳健地处理了这一几何构建过程。所有以度为单位指定的角度 $\\theta$ 和 $\\varphi_i$ 在用于任何三角函数之前都必须通过公式 $\\alpha_{\\text{rad}} = \\alpha_{\\text{deg}} \\cdot (\\pi / 180)$ 转换为弧度。\n\n该解决方案按以下算法进行：\n1. **系统搜索**：可能的构象空间是一个由笛卡尔积 $G^m$ 定义的离散网格，其中 $G$ 是允许的二面角集合，$m = n-3$。我们枚举每一种可能的二面角组合，构建相应的分子几何结构，计算其总能量，并确定此网格上的全局最小能量 $E_{\\min}$。总的能量评估次数为 $N_{\\text{sys}} = \\lvert G \\rvert^m$。\n\n2. **随机搜索**：通过抽样 $M$ 个构象来执行蒙特卡洛模拟。对于每次试验，通过从网格 $G$ 中均匀且独立地抽样来选择一组 $m$ 个二面角。随机数生成器使用特定的整数 $s$ 作为种子以确保可复现性。对于每个抽样的构象，计算其能量。我们记录在所有 $M$ 次试验中找到的最低能量 $E_{\\text{best}}$。我们还确定是否有任何试验产生的能量 $E \\le E_{\\min} + \\varepsilon$，其中 $\\varepsilon$ 是一个小的容差。如果找到了这样的构象，我们将首次出现的试验次数记录为 $N_{\\text{MC}}$；否则，$N_{\\text{MC}}$ 设置为总预算 $M$。布尔标志 `found` 指示是否在容差范围内成功定位了全局最小值。\n\n整个过程在一个Python脚本中实现。用于几何构建和能量计算的辅助函数使代码模块化。主函数遍历提供的测试用例，为每个用例执行两种搜索策略，并将得到的五个值——$E_{\\min}$、$N_{\\text{sys}}$、`found`、$N_{\\text{MC}}$、$E_{\\text{best}}$——格式化为指定的输出字符串格式。向量和矩阵运算使用 `numpy` 库高效处理。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport itertools\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for conformational search comparison.\n    \"\"\"\n    \n    test_cases = [\n        # Case 1 (cyclodecane, happy path)\n        (10, [-60, 60, 180], 0.5, 1.54, 112, 10.0, 5000, 12345, 1e-9),\n        # Case 2 (cyclodecane, tighter budget)\n        (10, [-60, 60, 180], 0.5, 1.54, 112, 10.0, 500, 42, 1e-9),\n        # Case 3 (eight-membered ring, contrast)\n        (8, [-60, 60, 180], 0.5, 1.54, 112, 10.0, 500, 2023, 1e-9),\n    ]\n\n    results = []\n    for case in test_cases:\n        n, G_deg, A, b, theta_deg, k_clo, M, s, eps = case\n        \n        # Convert angles to radians\n        theta_rad = np.deg2rad(theta_deg)\n        G_rad = [np.deg2rad(angle) for angle in G_deg]\n        \n        # Perform systematic search to find the exact minimum on the grid\n        E_min, N_sys = _systematic_search(n, G_rad, A, b, theta_rad, k_clo)\n        \n        # Perform stochastic search\n        found, N_MC, E_best = _stochastic_search(n, G_rad, E_min, A, b, theta_rad, k_clo, M, s, eps)\n        \n        results.append([E_min, N_sys, found, N_MC, E_best])\n\n    # Format the final output string exactly as required\n    result_strings = []\n    for r in results:\n        # Format floats to have a consistent representation\n        r[0] = f\"{r[0]:.10f}\"\n        r[4] = f\"{r[4]:.10f}\"\n        result_strings.append(f\"[{','.join(map(str, r))}]\")\n    \n    print(f\"[{','.join(result_strings)}]\")\n\ndef _build_chain(dihedrals_rad, n, b, theta_rad):\n    \"\"\"\n    Constructs the Cartesian coordinates of an n-atom open chain.\n    \"\"\"\n    coords = [np.zeros(3)] * n\n    coords[0] = np.array([0.0, 0.0, 0.0])\n    if n > 1:\n        coords[1] = np.array([b, 0.0, 0.0])\n    if n > 2:\n        r2_vec = np.array([b * np.cos(np.pi - theta_rad), b * np.sin(np.pi - theta_rad), 0.0])\n        coords[2] = coords[1] + r2_vec\n\n    for i in range(3, n):\n        r_im1, r_im2, r_im3 = coords[i-1], coords[i-2], coords[i-3]\n        \n        u1 = r_im2 - r_im3\n        u2 = r_im1 - r_im2\n        \n        e2_hat = u2 / np.linalg.norm(u2)\n        \n        cross_prod = np.cross(u1, u2)\n        norm_cross_prod = np.linalg.norm(cross_prod)\n        \n        if norm_cross_prod > 1e-9: # Non-collinear case is expected\n            n1_hat = cross_prod / norm_cross_prod\n        else: # Fallback for collinear case (not expected in this problem)\n            # Create an arbitrary vector perpendicular to e2_hat\n            temp_vec = np.array([0.0, 0.0, 1.0])\n            if np.abs(np.dot(e2_hat, temp_vec)) > 0.99:\n                 temp_vec = np.array([1.0, 0.0, 0.0])\n            n1_hat = np.cross(e2_hat, temp_vec)\n            n1_hat /= np.linalg.norm(n1_hat)\n\n        n2_hat = np.cross(n1_hat, e2_hat)\n        \n        phi = dihedrals_rad[i-3]\n        \n        cos_theta = np.cos(theta_rad)\n        sin_theta = np.sin(theta_rad)\n        cos_phi = np.cos(phi)\n        sin_phi = np.sin(phi)\n        \n        v_i = -cos_theta * e2_hat + sin_theta * cos_phi * n2_hat + sin_theta * sin_phi * n1_hat\n        coords[i] = r_im1 + b * v_i\n        \n    return coords\n\ndef _calculate_energy(dihedrals_rad, coords, A, k_clo):\n    \"\"\"\n    Calculates the total potential energy of a conformation.\n    \"\"\"\n    n = len(coords)\n    E_tors = np.sum([A * (1.0 - np.cos(3.0 * phi)) for phi in dihedrals_rad])\n    \n    dist_sq = np.sum((coords[n-1] - coords[0])**2)\n    E_closure = k_clo * dist_sq\n    \n    return E_tors + E_closure\n\ndef _systematic_search(n, G_rad, A, b, theta_rad, k_clo):\n    \"\"\"\n    Performs an exhaustive grid search to find the global minimum energy.\n    \"\"\"\n    m = n - 3\n    if m = 0: # for n=3 rings\n        coords = _build_chain([], n, b, theta_rad)\n        energy = _calculate_energy([], coords, A, k_clo)\n        return energy, 1\n\n    num_evals = len(G_rad)**m\n    min_energy = float('inf')\n    \n    for dihedrals_tuple in itertools.product(G_rad, repeat=m):\n        dihedrals_rad = list(dihedrals_tuple)\n        coords = _build_chain(dihedrals_rad, n, b, theta_rad)\n        energy = _calculate_energy(dihedrals_rad, coords, A, k_clo)\n        if energy  min_energy:\n            min_energy = energy\n            \n    return min_energy, num_evals\n\ndef _stochastic_search(n, G_rad, E_min, A, b, theta_rad, k_clo, M, s, eps):\n    \"\"\"\n    Performs a Monte Carlo search for the minimum energy conformation.\n    \"\"\"\n    rng = np.random.default_rng(s)\n    m = n - 3\n    if m = 0:\n        coords = _build_chain([], n, b, theta_rad)\n        energy = _calculate_energy([], coords, A, k_clo)\n        found = energy = E_min + eps\n        return found, 1, energy\n        \n    best_energy = float('inf')\n    found = False\n    first_hit_trial = M\n    \n    for trial in range(1, M + 1):\n        indices = rng.integers(0, len(G_rad), size=m)\n        dihedrals_rad = [G_rad[i] for i in indices]\n        \n        coords = _build_chain(dihedrals_rad, n, b, theta_rad)\n        energy = _calculate_energy(dihedrals_rad, coords, A, k_clo)\n        \n        if energy  best_energy:\n            best_energy = energy\n            \n        if not found and energy = E_min + eps:\n            found = True\n            first_hit_trial = trial\n            \n    return found, first_hit_trial, best_energy\n\nif __name__ == '__main__':\n    solve()\n```", "id": "2453295"}]}