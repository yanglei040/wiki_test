{"hands_on_practices": [{"introduction": "分子动力学模拟的核心是求解牛顿运动方程，从而追踪原子和分子随时间的运动轨迹。数值积分算法的选择对模拟的长期稳定性和准确性至关重要，尤其是对于像能量这样的守恒量。本练习 [@problem_id:2452284] 将通过一个经典的开普勒轨道问题，让您亲手比较一种简单的非辛积分方法（前向欧拉法）和一种在分子模拟中广泛使用的辛积分方法（速度Verlet算法），直观地揭示后者在能量守恒方面的优越性。", "problem": "考虑无量纲单位下的平面开普勒二体问题，其中引力参数 $\\mu$ 和粒子质量 $m$ 均设为 $1$。设位置为 $\\mathbf{r}(t) \\in \\mathbb{R}^2$，速度为 $\\mathbf{v}(t) \\in \\mathbb{R}^2$。力是中心力，由 $\\mathbf{F}(\\mathbf{r}) = -\\mu \\, \\mathbf{r}/\\lVert \\mathbf{r} \\rVert^{3}$ 给出，因此加速度为 $\\mathbf{a}(\\mathbf{r}) = \\mathbf{F}(\\mathbf{r}) / m = - \\mathbf{r}/\\lVert \\mathbf{r} \\rVert^{3}$。哈密顿量（总能量）为\n$$\nH(\\mathbf{r},\\mathbf{v}) \\;=\\; \\frac{1}{2}\\,\\lVert \\mathbf{v} \\rVert^2 \\;-\\; \\frac{1}{\\lVert \\mathbf{r} \\rVert}.\n$$\n您将比较应用于该系统的两种离散时间更新映射的长期能量行为：\n\n- 方法 A (前向欧拉法，一种非辛映射):\n$$\n\\mathbf{r}_{n+1} \\;=\\; \\mathbf{r}_n \\;+\\; \\Delta t \\,\\mathbf{v}_n,\\qquad\n\\mathbf{v}_{n+1} \\;=\\; \\mathbf{v}_n \\;+\\; \\Delta t \\,\\mathbf{a}(\\mathbf{r}_n).\n$$\n\n- 方法 B (速度 Verlet 法，一种辛映射):\n$$\n\\mathbf{r}_{n+1} \\;=\\; \\mathbf{r}_n \\;+\\; \\Delta t \\,\\mathbf{v}_n \\;+\\; \\tfrac{1}{2}\\,\\Delta t^2\\,\\mathbf{a}(\\mathbf{r}_n),\\qquad\n\\mathbf{v}_{n+1} \\;=\\; \\mathbf{v}_n \\;+\\; \\tfrac{1}{2}\\,\\Delta t \\,\\big(\\mathbf{a}(\\mathbf{r}_n)+\\mathbf{a}(\\mathbf{r}_{n+1})\\big).\n$$\n\n通过选择一个半长轴 $a=1$ 且离心率 $e \\in (0,1)$ 的椭圆来初始化每个测试。将粒子放置在 $x$ 轴的近拱点上，其\n$$\n\\mathbf{r}_0 \\;=\\; \\big(a(1-e),\\,0\\big),\\qquad\n\\mathbf{v}_0 \\;=\\; \\big(0,\\,\\sqrt{\\mu\\,\\tfrac{1+e}{a(1-e)}}\\big),\n$$\n并取 $\\mu=1$ 和 $a=1$。精确的轨道周期为 $T = 2\\pi$。对于给定的时间步长 $\\Delta t$，将系统演化 $N = \\left\\lfloor \\dfrac{M\\,T}{\\Delta t} \\right\\rfloor$ 步，其中 $M$ 是规定的要模拟的轨道周期数。在每一步 $n$，计算能量\n$$\nE_n \\;=\\; \\frac{1}{2}\\,\\lVert \\mathbf{v}_n \\rVert^2 \\;-\\; \\frac{1}{\\lVert \\mathbf{r}_n \\rVert},\n$$\n并将模拟过程中的最大相对能量偏差定义为\n$$\n\\delta_{\\max} \\;=\\; \\max_{0 \\le n \\le N} \\frac{\\lvert E_n - E_0 \\rvert}{\\lvert E_0 \\rvert}.\n$$\n分别为方法 A 和方法 B 报告 $\\delta_{\\max}$。量 $\\delta_{\\max}$ 是无量纲的，并且必须以浮点数形式报告。\n\n测试组：\n- 情况 1：$e = 0.2$, $\\Delta t = 0.02$, $M = 200$。\n- 情况 2：$e = 0.6$, $\\Delta t = 0.02$, $M = 200$。\n- 情况 3：$e = 0.2$, $\\Delta t = 0.05$, $M = 100$。\n\n您的程序必须为每种情况计算分别对应于方法 A 和方法 B 的序对 $\\big(\\delta_{\\max}^{\\mathrm{A}}, \\delta_{\\max}^{\\mathrm{B}}\\big)$。最终输出格式必须是单行，包含一个逗号分隔的列表，其中包含所有六个浮点数结果，并严格按照以下顺序排列\n$$\n\\big[\\delta_{\\max}^{\\mathrm{A}}(1),\\;\\delta_{\\max}^{\\mathrm{B}}(1),\\;\\delta_{\\max}^{\\mathrm{A}}(2),\\;\\delta_{\\max}^{\\mathrm{B}}(2),\\;\\delta_{\\max}^{\\mathrm{A}}(3),\\;\\delta_{\\max}^{\\mathrm{B}}(3)\\big].\n$$\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果（例如，$\\big[0.1,0.2,0.3,0.4,0.5,0.6\\big]$）。所有量都是无量纲的，无需报告任何角度。每个测试用例的答案必须是浮点数。不要读取任何输入；在您的程序中严格使用上面指定的测试组。", "solution": "问题陈述已经过分析并被确定为有效。它具有科学依据，是适定的、客观的，并包含进行求解所需的所有必要信息。该问题涉及计算物理学中的一个基本主题：哈密顿系统（特别是开普勒问题）常微分方程的数值积分。其目标是比较非辛积分器（前向欧拉法）与辛积分器（速度 Verlet 法）在长期能量守恒方面的表现。\n\n所考虑的系统是由哈密顿量控制的平面二体问题\n$$\nH(\\mathbf{r},\\mathbf{v}) \\;=\\; \\frac{1}{2}\\,m\\lVert \\mathbf{v} \\rVert^2 \\;-\\; \\frac{\\mu}{\\lVert \\mathbf{r} \\rVert}.\n$$\n在给定的无量纲单位下，引力参数 $\\mu$ 和质量 $m$ 均设为 $1$。运动方程为\n$$\n\\dot{\\mathbf{r}} = \\mathbf{v}, \\qquad \\dot{\\mathbf{v}} = \\mathbf{a}(\\mathbf{r}) = -\\frac{\\mathbf{r}}{\\lVert \\mathbf{r} \\rVert^3}.\n$$\n这是一个保守系统，意味着总能量 $E = H(\\mathbf{r}, \\mathbf{v})$ 对于精确的连续时间解是一个运动常量。在数值模拟中观察到的任何能量偏差都是积分算法的人为产物。量 $\\delta_{\\max}$ 是衡量积分器在能量守恒方面质量的一个指标。\n\n初始条件是为半长轴 $a=1$ 的椭圆轨道设置的。这种轨道的理论能量是恒定的，由 $E = -\\frac{\\mu}{2a}$ 给出。当 $\\mu=1$ 和 $a=1$ 时，初始能量必须为 $E_0 = -0.5$。问题提供了近拱点的初始条件，这与该能量值正确对应。\n\n我们现在分析这两种数值方法。\n\n方法 A：前向欧拉法\n更新规则是：\n$$\n\\mathbf{r}_{n+1} \\;=\\; \\mathbf{r}_n \\;+\\; \\Delta t \\,\\mathbf{v}_n \\\\\n\\mathbf{v}_{n+1} \\;=\\; \\mathbf{v}_n \\;+\\; \\Delta t \\,\\mathbf{a}(\\mathbf{r}_n)\n$$\n这是一种显式的一阶方法。它不是辛的。对于哈密顿系统，非辛方法通常在长时间尺度上无法（即使是近似地）守恒能量。对于像开普勒问题这样的振荡系统，前向欧拉法通常会引入系统性的能量漂移。数值能量 $E_n$ 将会长期增长，导致模拟轨道偏离真实的椭圆路径并向外螺旋运动。因此，最大能量偏差 $\\delta_{\\max}^{\\mathrm{A}}$ 预计会随着总积分步数 $N$ 的增加而增长，并可能变得相当大。\n\n方法 B：速度 Verlet 法\n更新规则是：\n$$\n\\mathbf{r}_{n+1} \\;=\\; \\mathbf{r}_n \\;+\\; \\Delta t \\,\\mathbf{v}_n \\;+\\; \\tfrac{1}{2}\\,\\Delta t^2\\,\\mathbf{a}(\\mathbf{r}_n) \\\\\n\\mathbf{v}_{n+1} \\;=\\; \\mathbf{v}_n \\;+\\; \\tfrac{1}{2}\\,\\Delta t \\,\\big(\\mathbf{a}(\\mathbf{r}_n)+\\mathbf{a}(\\mathbf{r}_{n+1})\\big)\n$$\n这是一种二阶、时间可逆的辛积分器。当应用于哈密顿系统时，辛积分器具有一个关键特性：它们不守恒精确的哈密顿量 $H$，但它们确实精确守恒一个附近的“影子”哈密顿量 $H_{\\Delta t}$，该影子哈密顿量与 $H$ 相差 $\\Delta t^2$ 阶的项（对于二阶方法而言）。因此，计算出的能量 $E_n$ 不会长期漂移，而是在其初始值 $E_0$ 附近呈现有界振荡。这些振荡的幅度取决于 $\\Delta t$，但误差不会随时间累积。因此，我们预计最大能量偏差 $\\delta_{\\max}^{\\mathrm{B}}$ 将显著小于 $\\delta_{\\max}^{\\mathrm{A}}$，并在长时间的模拟中保持稳定。\n\n解决该问题的算法如下：\n1. 对于每个由离心率 $e$、时间步长 $\\Delta t$ 和轨道数 $M$ 指定的测试用例：\n2. 计算初始条件。位置为 $\\mathbf{r}_0 = (1-e, 0)$，速度为 $\\mathbf{v}_0 = (0, \\sqrt{(1+e)/(1-e)})$。\n3. 计算初始能量 $E_0 = \\frac{1}{2}\\lVert \\mathbf{v}_0 \\rVert^2 - 1/\\lVert \\mathbf{r}_0 \\rVert$，其值应恰好为 $-0.5$。\n4. 计算总步数 $N = \\lfloor 2\\pi M / \\Delta t \\rfloor$。\n5. 对于每种方法（A 和 B），执行一个从 $n=0$到 $N-1$ 的循环：\n    a. 在每一步，使用各自的积分公式将位置 $\\mathbf{r}_n$ 和速度 $\\mathbf{v}_n$ 更新为 $\\mathbf{r}_{n+1}$ 和 $\\mathbf{v}_{n+1}$。加速度为 $\\mathbf{a}(\\mathbf{r}) = -\\mathbf{r} / \\lVert \\mathbf{r} \\rVert^3$。\n    b. 使用新的状态向量计算能量 $E_{n+1}$。\n    c. 计算相对能量偏差 $|E_{n+1} - E_0|/|E_0|$。\n    d. 记录整个模拟过程中发现的最大相对偏差。\n6. 循环完成后，最终的最大相对偏差 $\\delta_{\\max}$ 即为该方法和测试用例的结果。\n7. 收集 6 个结果并按要求格式化。\n\n此过程将使用 `numpy` 库在 Python 中实现，以进行高效的向量运算。预期的结果将清楚地证明辛速度 Verlet 积分器在哈密顿系统长期模拟中的优越性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Kepler problem for given test cases using Forward Euler and Velocity Verlet methods,\n    and computes the maximum relative energy deviation for each.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (e, dt, M)\n        (0.2, 0.02, 200),\n        (0.6, 0.02, 200),\n        (0.2, 0.05, 100),\n    ]\n\n    results = []\n    for e, dt, M in test_cases:\n        # Run simulation for Method A (Forward Euler)\n        delta_max_A = run_simulation(e, dt, M, method='euler')\n        results.append(delta_max_A)\n\n        # Run simulation for Method B (Velocity Verlet)\n        delta_max_B = run_simulation(e, dt, M, method='verlet')\n        results.append(delta_max_B)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_simulation(e, dt, M, method):\n    \"\"\"\n    Performs a single simulation run for a given method and parameters.\n\n    Args:\n        e (float): Eccentricity of the orbit.\n        dt (float): Time step for the integration.\n        M (int): Number of orbital periods to simulate.\n        method (str): Integration method, either 'euler' or 'verlet'.\n\n    Returns:\n        float: The maximum relative energy deviation over the simulation.\n    \"\"\"\n    # System parameters (dimensionless)\n    mu = 1.0\n    a = 1.0\n    \n    # Initial conditions at periapsis\n    r = np.array([a * (1.0 - e), 0.0])\n    v = np.array([0.0, np.sqrt(mu * (1.0 + e) / (a * (1.0 - e)))])\n\n    def acceleration(pos):\n        \"\"\"Computes acceleration a(r) = -mu * r / ||r||^3.\"\"\"\n        norm_r = np.linalg.norm(pos)\n        if norm_r == 0:\n            # This should not happen in a Kepler orbit\n            return np.array([0.0, 0.0])\n        return -mu * pos / norm_r**3\n\n    def energy(pos, vel):\n        \"\"\"Computes total energy E = 0.5*||v||^2 - mu/||r||.\"\"\"\n        return 0.5 * np.dot(vel, vel) - mu / np.linalg.norm(pos)\n\n    # Initial energy\n    E0 = energy(r, v)\n    if abs(E0) == 0:\n        # Avoid division by zero, though E0 = -0.5 for these orbits\n        # so this case is not expected to be triggered.\n        return 0.0\n\n    # Simulation time and number of steps\n    T = 2.0 * np.pi * np.sqrt(a**3 / mu)\n    N = int(np.floor(M * T / dt))\n    \n    max_rel_error = 0.0\n\n    if method == 'euler':\n        for _ in range(N):\n            acc = acceleration(r)\n            r = r + dt * v\n            v = v + dt * acc\n            \n            E_n = energy(r, v)\n            rel_error = abs(E_n - E0) / abs(E0)\n            if rel_error > max_rel_error:\n                max_rel_error = rel_error\n                \n    elif method == 'verlet':\n        acc = acceleration(r)\n        for _ in range(N):\n            r_new = r + dt * v + 0.5 * dt**2 * acc\n            acc_new = acceleration(r_new)\n            v_new = v + 0.5 * dt * (acc + acc_new)\n            \n            r, v, acc = r_new, v_new, acc_new\n            \n            E_n = energy(r, v)\n            rel_error = abs(E_n - E0) / abs(E0)\n            if rel_error > max_rel_error:\n                max_rel_error = rel_error\n    else:\n        raise ValueError(\"Invalid method specified. Choose 'euler' or 'verlet'.\")\n\n    return max_rel_error\n    \nsolve()\n```", "id": "2452284"}, {"introduction": "在许多情况下，我们更关心的是系统在特定温度下的宏观平均性质（如平均能量），而不是其精确的微观运动轨迹。蒙特卡洛方法为此提供了一个强大的随机抽样框架，可以直接从指定的统计系综（如正则系综）中抽取代表性构型。本练习 [@problem_id:2452273] 将指导您实现基础的Metropolis蒙特卡洛算法，通过模拟一个简单的一维Lennard-Jones二聚体，来计算其平衡态下的平均势能。", "problem": "实现一个完整的程序，在正则系综中使用Metropolis Monte Carlo算法估算一维Lennard–Jones (LJ) 二聚体的平衡平均势能。该系统由两个被约束在一条一维线上的点状粒子组成。系统的状态完全由标量分离距离 $r \\in (0,\\infty)$ 指定。对相互作用是Lennard–Jones势\n$$\nU(r;\\epsilon,\\sigma) = 4\\epsilon\\left[\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^6\\right],\n$$\n其中 $\\epsilon$ 设定了能量尺度，$\\sigma$ 设定了特征长度。请在约化的Lennard–Jones单位制中进行计算，该单位制中长度以 $\\sigma$ 为单位，能量以 $\\epsilon$ 为单位。在这些约化单位中，记为 $r^\\star = r/\\sigma$，$U^\\star(r^\\star) = U(r)/\\epsilon$，以及温度 $T^\\star = T/\\epsilon$，且根据约化单位的定义，玻尔兹曼常数取为 $k_{\\mathrm{B}} = 1$。\n\n您的程序必须：\n- 通过单个标量 $r^\\star \\in (0,\\infty)$ 表示微观状态。\n- 在约化单位中使用对称的提议核，通过从 $[-\\Delta^\\star, \\Delta^\\star]$ 的均匀分布中抽样一个步长 $\\xi$ 来尝试一个均匀位移 $r^\\star \\to r^{\\star\\prime}$，然后在硬边界 $r^\\star = 0$ 处应用反射，以使提议始终保持在 $(0,\\infty)$ 内。\n- 在固定的约化温度 $T^\\star$ 下，强制执行相对于 $r^\\star$ 的正则（Boltzmann）平衡分布的细致平衡，该分布与 $\\exp\\!\\left(-U^\\star(r^\\star)/T^\\star\\right)$ 成正比。\n- 使用一个指定步数的预烧阶段（从平均中丢弃），随后是一个生产阶段，在此期间累积 $U^\\star(r^\\star)$ 的样本平均值。\n- 在 $r^\\star_0 = 1.5$ 处初始化链。\n- 确保数值稳定性，绝不在 $r^\\star = 0$ 处精确计算势能；如果一个提议值会导致 $r^\\star \\le 0$，则将其反射到 $(0,\\infty)$ 内，并且如有需要，为了安全计算，将其限制在一个小的正数下界。\n\n以约化单位报告最终的平均势能，即，作为一个等于 $\\langle U \\rangle / \\epsilon = \\langle U^\\star \\rangle$ 的无量纲数。无需报告物理单位，仅报告约化单位。本问题不使用角度。所有随机数生成必须通过使用提供的种子来保证可复现。\n\n推导和设计的出发点：使用经典统计力学中的正则系综，在该系综中，一个具有势能 $U$、温度为 $T$ 的构型的概率密度与 $\\exp(-U/(k_{\\mathrm{B}}T))$ 成正比，并对具有对称提议分布的蒙特卡洛转移概率施加细致平衡。\n\n测试套件：\n实现您的程序以运行以下四个测试用例，每个用例由元组 $(T^\\star, \\Delta^\\star, N_{\\mathrm{steps}}, N_{\\mathrm{burn}}, \\text{seed})$ 指定，其中 $T^\\star$ 是约化温度，$\\Delta^\\star$ 是约化提议半宽，$N_{\\mathrm{steps}}$ 是Metropolis总步数，$N_{\\mathrm{burn}}$ 是作为预烧阶段丢弃的初始步数，$\\text{seed}$ 用于初始化伪随机数生成器。所有用例使用相同的Lennard–Jones参数，即在约化单位中 $\\epsilon = 1$ 和 $\\sigma = 1$。\n\n- 用例1：$(T^\\star = 1.0,\\ \\Delta^\\star = 0.3,\\ N_{\\mathrm{steps}} = 300000,\\ N_{\\mathrm{burn}} = 50000,\\ \\text{seed} = 12345)$\n- 用例2：$(T^\\star = 0.2,\\ \\Delta^\\star = 0.05,\\ N_{\\mathrm{steps}} = 300000,\\ N_{\\mathrm{burn}} = 50000,\\ \\text{seed} = 54321)$\n- 用例3：$(T^\\star = 5.0,\\ \\Delta^\\star = 0.5,\\ N_{\\mathrm{steps}} = 300000,\\ N_{\\mathrm{burn}} = 50000,\\ \\text{seed} = 2023)$\n- 用例4：$(T^\\star = 0.05,\\ \\Delta^\\star = 0.02,\\ N_{\\mathrm{steps}} = 300000,\\ N_{\\mathrm{burn}} = 50000,\\ \\text{seed} = 98765)$\n\n程序输出规范：\n- 对每个测试用例，仅计算生产阶段的 $U^\\star$ 样本平均值。\n- 最终的程序输出必须是单行，包含一个Python风格的列表字面量，其中按顺序列出四个平均值，格式化为小数点后恰好有六位的小数，并用逗号分隔，例如 $[a,b,c,d]$，其中 $a$、$b$、$c$ 和 $d$ 是对应于四个用例的四个平均值。\n\n覆盖性设计：\n- 用例1是在中等 $T^\\star$ 下的典型情景。\n- 用例2探测了势能最小值附近的低 $T^\\star$ 情况，此时谐振行为占主导。\n- 用例3测试了高 $T^\\star$ 情况，此时链会探索更广的范围。\n- 用例4是一个极低 $T^\\star$ 的边缘用例，使用非常小的步长以维持合理的接受率。\n\n您的程序必须是自包含的，不需要任何输入，并严格遵守指定的输出格式。", "solution": "问题陈述已经过仔细审查，并被确定为有效。它在科学上基于经典统计力学的原理，问题设定良好，具有一套完整且一致的参数，并以客观、正式的语言呈现。该任务是计算统计物理学中的一个标准练习：使用Metropolis Monte Carlo方法估算一个简单模型系统的热力学可观测量。我们现在将进行推导和实现。\n\n目标是在正则系综中计算一维Lennard-Jones (LJ) 二聚体的平均势能 $\\langle U^\\star \\rangle$。系统的状态由粒子分离距离 $r^\\star = r/\\sigma$ 定义，其中所有量都以约化的LJ单位（$\\epsilon=1$，$\\sigma=1$，$k_{\\mathrm{B}}=1$）表示。约化势能由下式给出：\n$$\nU^\\star(r^\\star) = 4\\left[ (r^\\star)^{-12} - (r^\\star)^{-6} \\right]\n$$\n在正则系综中，于一个固定的约化温度 $T^\\star$ 下，微观状态 $r^\\star$ 的平衡概率分布是Boltzmann分布：\n$$\np(r^\\star) \\propto \\exp\\left(-\\frac{U^\\star(r^\\star)}{T^\\star}\\right)\n$$\n任何可观测量 $A(r^\\star)$ 的期望值由积分 $\\langle A \\rangle = \\int_0^\\infty A(r^\\star) p(r^\\star) dr^\\star / \\int_0^\\infty p(r^\\star) dr^\\star$ 给出。我们将通过使用Metropolis Monte Carlo算法从 $p(r^\\star)$ 中抽样来估算这个平均值。\n\nMetropolis算法生成一个状态的马尔可夫链 $\\{r^\\star_0, r^\\star_1, r^\\star_2, \\ldots\\}$，使得该链的平稳分布是目标分布 $p(r^\\star)$。这是通过构造满足细致平衡条件的转移概率 $P(r^\\star \\to r^{\\star\\prime})$ 实现的：\n$$\np(r^\\star) P(r^\\star \\to r^{\\star\\prime}) = p(r^{\\star\\prime}) P(r^{\\star\\prime} \\to r^\\star)\n$$\n转移概率被分解为提议概率 $T(r^{\\star\\prime}|r^\\star)$ 和接受概率 $A(r^{\\star\\prime}|r^\\star)$。细致平衡方程则变为：\n$$\np(r^\\star) T(r^{\\star\\prime}|r^\\star) A(r^{\\star\\prime}|r^\\star) = p(r^{\\star\\prime}) T(r^\\star|r^{\\star\\prime}) A(r^\\star|r^{\\star\\prime})\n$$\n接受概率的标准选择是Metropolis-Hastings形式：\n$$\nA(r^{\\star\\prime}|r^\\star) = \\min\\left(1, \\frac{p(r^{\\star\\prime}) T(r^\\star|r^{\\star\\prime})}{p(r^\\star) T(r^{\\star\\prime}|r^\\star)}\\right)\n$$\n问题指定了一个对称的提议核。从当前状态 $r^\\star_{curr}$ 提议一个新状态 $r^{\\star\\prime}$ 的方法是：从 $[-\\Delta^\\star, \\Delta^\\star]$ 上的均匀分布中生成一个随机位移 $\\xi$，并通过在 $r^\\star=0$ 处的硬墙边界进行反射来处理。提议的状态为 $r^{\\star}_{prop} = |r^\\star_{curr} + \\xi|$。这个提议机制是对称的，即 $T(r^{\\star\\prime}|r^\\star) = T(r^\\star|r^{\\star\\prime})$，因为从 $r^\\star$ 提议 $r^{\\star\\prime}$ 的概率取决于 $|r^{\\star\\prime}-r^\\star|$ 和 $|r^{\\star\\prime}+r^\\star|$，这些量在交换 $r^\\star$ 和 $r^{\\star\\prime}$ 时是对称的。\n\n对于对称提议核，接受概率简化为Metropolis形式：\n$$\nA(r^{\\star\\prime}|r^\\star) = \\min\\left(1, \\frac{p(r^{\\star\\prime})}{p(r^\\star)}\\right) = \\min\\left(1, \\exp\\left[-\\frac{U^\\star(r^{\\star\\prime}) - U^\\star(r^\\star)}{T^\\star}\\right]\\right) = \\min\\left(1, \\exp\\left[-\\frac{\\Delta U^\\star}{T^\\star}\\right]\\right)\n$$\n其中 $\\Delta U^\\star = U^\\star(r^{\\star\\prime}) - U^\\star(r^\\star)$。\n\n模拟算法如下：\n1.  在状态 $r^\\star_0 = 1.5$ 初始化系统。\n2.  迭代总共 $N_{\\mathrm{steps}}$ 步，索引为 $i = 0, 1, \\ldots, N_{\\mathrm{steps}}-1$。对于每一步：\n    a.  设当前状态为 $r^\\star_{curr}$。\n    b.  提议一个新状态 $r^{\\star}_{prop}$。首先，从 $[-\\Delta^\\star, \\Delta^\\star]$ 中均匀生成一个随机数 $\\xi$。然后计算原始提议 $r^\\star_{raw} = r^\\star_{curr} + \\xi$。最终的提议通过在原点处的反射得到：$r^{\\star}_{prop} = |r^\\star_{raw}|$。这确保了 $r^{\\star}_{prop} \\in (0, \\infty)$。\n    c.  计算势能变化，$\\Delta U^\\star = U^\\star(r^{\\star}_{prop}) - U^\\star(r^\\star_{curr})$。\n    d.  计算接受概率 $P_{\\mathrm{acc}} = \\min(1, \\exp(-\\Delta U^\\star / T^\\star))$。\n    e.  从 $[0, 1]$ 中均匀生成一个随机数 $u$。\n    f.  如果 $u  P_{\\mathrm{acc}}$，则接受移动：下一个状态是 $r^\\star_{next} = r^{\\star}_{prop}$。否则，拒绝移动：下一个状态是 $r^\\star_{next} = r^\\star_{curr}$。\n3.  前 $N_{\\mathrm{burn}}$ 步构成平衡或“预烧”阶段，生成的构型将被丢弃。\n4.  对于从 $N_{\\mathrm{burn}}$ 到 $N_{\\mathrm{steps}}-1$ 的步数 $i$（生产阶段），累加势能值 $U^\\star(r^\\star_{i+1})$。\n5.  平均势能的估计值是生产阶段的算术平均值：\n$$\n\\langle U^\\star \\rangle \\approx \\frac{1}{N_{\\mathrm{steps}} - N_{\\mathrm{burn}}} \\sum_{i=N_{\\mathrm{burn}}}^{N_{\\mathrm{steps}}-1} U^\\star(r^\\star_{i+1})\n$$\n\n这个过程将为四个指定的测试用例分别实现。实现将使用 `numpy` 进行数值计算，并使用其 `random` 子模块，并设置种子以保证可复现性。为高效计算势能，将先计算一次 $(r^\\star)^{-6}$ 项，然后平方得到 $(r^\\star)^{-12}$。最终结果将按要求格式化。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the Monte Carlo simulations for the given test cases\n    and print the results in the specified format.\n    \"\"\"\n    \n    test_cases = [\n        # (T_star, delta_star, N_steps, N_burn, seed)\n        (1.0, 0.3, 300000, 50000, 12345),\n        (0.2, 0.05, 300000, 50000, 54321),\n        (5.0, 0.5, 300000, 50000, 2023),\n        (0.05, 0.02, 300000, 50000, 98765),\n    ]\n\n    results = []\n    for case in test_cases:\n        T_star, delta_star, N_steps, N_burn, seed = case\n        avg_potential = run_simulation(T_star, delta_star, N_steps, N_burn, seed)\n        results.append(f\"{avg_potential:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef lennard_jones_potential_reduced(r_star: float) -> float:\n    \"\"\"\n    Calculates the Lennard-Jones potential in reduced units.\n    \n    Args:\n        r_star: The separation distance in reduced units (r/sigma).\n\n    Returns:\n        The potential energy in reduced units (U/epsilon).\n    \"\"\"\n    # Defensive check for safety, though the algorithm should prevent r_star = 0.\n    if r_star = 0:\n        return np.inf\n\n    r_inv = 1.0 / r_star\n    r_inv6 = r_inv**6\n    r_inv12 = r_inv6**2\n    return 4.0 * (r_inv12 - r_inv6)\n\ndef run_simulation(T_star: float, delta_star: float, N_steps: int, N_burn: int, seed: int) -> float:\n    \"\"\"\n    Performs a Metropolis Monte Carlo simulation for a 1D LJ dimer.\n\n    Args:\n        T_star: Reduced temperature (T/epsilon).\n        delta_star: Half-width of the uniform proposal distribution.\n        N_steps: Total number of MC steps.\n        N_burn: Number of burn-in steps to discard.\n        seed: Seed for the random number generator.\n\n    Returns:\n        The average potential energy over the production phase.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    \n    # Initialize the system state\n    r_star = 1.5\n    \n    potential_sum = 0.0\n    production_steps_count = 0\n    \n    # Pre-calculate current potential to avoid re-computation in the loop\n    current_potential = lennard_jones_potential_reduced(r_star)\n\n    for i in range(N_steps):\n        # Propose a move\n        xi = rng.uniform(-delta_star, delta_star)\n        r_star_proposed = r_star + xi\n        \n        # Apply reflection at the hard boundary r_star = 0\n        if r_star_proposed = 0:\n            r_star_proposed = -r_star_proposed\n            \n        # Calculate potential for the proposed state\n        proposed_potential = lennard_jones_potential_reduced(r_star_proposed)\n        \n        # Calculate change in energy\n        delta_U_star = proposed_potential - current_potential\n        \n        # Metropolis acceptance criterion\n        accept = False\n        if delta_U_star  0:\n            accept = True\n        else:\n            acceptance_prob = np.exp(-delta_U_star / T_star)\n            if rng.random()  acceptance_prob:\n                accept = True\n        \n        if accept:\n            r_star = r_star_proposed\n            current_potential = proposed_potential\n            \n        # Accumulate data after burn-in phase\n        if i >= N_burn:\n            potential_sum += current_potential\n            production_steps_count += 1\n            \n    # Calculate the average potential energy\n    if production_steps_count > 0:\n        average_potential = potential_sum / production_steps_count\n    else:\n        # Should not happen with valid N_steps > N_burn\n        average_potential = 0.0\n\n    return average_potential\n\n# Execute the main function\nsolve()\n```", "id": "2452273"}, {"introduction": "经典模拟中使用的力场和能量，其物理根源在于系统底层的电子结构，这必须通过量子力学来描述。然而，对于绝大多数分子体系，精确求解薛定谔方程是不现实的，因此必须采用近似方法，其中最核心的一步就是使用原子轨道基组来构建分子轨道。本练习 [@problem_id:2452274] 提供了一个宝贵的机会，让您为一个简化的模型体系从零开始构建量子化学求解器，并亲眼见证不同规模的基组选择如何直接影响我们对分子能量和波函数的计算精度。", "problem": "考虑一维空间中双原子氢分子的 Born–Oppenheimer 处理，其中两个质子固定在 $x$ 轴上的 $x = -R/2$ 和 $x = +R/2$ 位置，核间距为 $R$（以原子单位计）。将电子运动的模型建立在软库仑势中\n$$\nV(x;R,a) \\;=\\; -\\dfrac{1}{\\sqrt{(x - R/2)^2 + a^2}} \\;-\\; \\dfrac{1}{\\sqrt{(x + R/2)^2 + a^2}},\n$$\n其中 $a$ 是一个以玻尔（bohr）为单位的软化参数。所有计算完全采用哈特里原子单位制（Hartree atomic units）。单电子哈密顿算符为\n$$\n\\hat{H} \\;=\\; -\\dfrac{1}{2}\\dfrac{d^2}{dx^2} \\;+\\; V(x;R,a).\n$$\n\n您的任务是为此单电子问题实现两种独立的基态分子轨道和能量的近似方法，并量化基组的选择相对于数值网格参考解的准确性。这反映了不同高斯基组（例如用三个高斯函数表示的斯莱特型轨道（Slater-Type-Orbital with three Gaussians, STO-3G）与相关一致性极化价三重泽塔（correlation-consistent polarized valence triple-zeta, cc-pVTZ））的影响，此处为了教学目的，将其改编为一维的替代模型。\n\n1) 网格上的参考解（作为真实解的代理）：\n   - 在间距为 $h$ 的均匀网格 $x \\in [-L, +L]$ 上离散化不含时薛定谔方程，动能项使用中心有限差分，并采用狄利克雷边界条件（Dirichlet boundary conditions）$\\psi(-L) = \\psi(+L) = 0$。\n   - 对于内部格点，这会产生一个实对称三对角哈密顿矩阵，其主对角线元素为 $d_i = \\dfrac{1}{h^2} + V(x_i;R,a)$，次对角线元素为 $e_i = -\\dfrac{1}{2h^2}$。\n   - 计算最低的本征值 $E_{\\text{ref}}(R)$ 和相应的归一化本征矢量 $\\psi_{\\text{ref}}(x;R)$，作为参考能量和轨道。在整个网格上使用梯形法则进行归一化。\n\n2) 在有限高斯基组中的 Rayleigh–Ritz 变分近似：\n   - 使用变分原理和一组有限的一维高斯基函数 $\\{\\phi_\\mu(x)\\}$ 来求解广义本征问题\n     $$\n     \\sum_\\nu H_{\\mu\\nu} c_\\nu \\;=\\; E \\sum_\\nu S_{\\mu\\nu} c_\\nu,\n     $$\n     其中\n     $$\n     S_{\\mu\\nu} \\;=\\; \\int \\phi_\\mu(x)\\,\\phi_\\nu(x)\\,dx, \\qquad\n     H_{\\mu\\nu} \\;=\\; \\int \\phi_\\mu(x)\\,\\hat{H}\\,\\phi_\\nu(x)\\,dx.\n     $$\n   - 在相同的网格上使用梯形法则数值计算积分。对于动能，使用通过分部积分推导出的对称梯度形式，\n     $$\n     T_{\\mu\\nu} \\;=\\; \\dfrac{1}{2} \\int \\left(\\dfrac{d\\phi_\\mu}{dx}\\right)\\left(\\dfrac{d\\phi_\\nu}{dx}\\right) dx,\n     $$\n     因此 $H_{\\mu\\nu} = T_{\\mu\\nu} + \\int \\phi_\\mu(x)\\,V(x;R,a)\\,\\phi_\\nu(x)\\,dx$。\n\n   - 定义以下以 $x_0$ 为中心的归一化一维高斯原函数：\n     - $s$ 型: $\\;g_s(x;x_0,\\alpha) = \\mathcal{N}_s(\\alpha)\\,\\exp\\!\\big(-\\alpha (x - x_0)^2\\big)$，其中 $\\mathcal{N}_s(\\alpha) = \\left(\\dfrac{2\\alpha}{\\pi}\\right)^{1/4}$，\n     - $p$ 型（极化）: $\\;g_p(x;x_0,\\alpha) = \\mathcal{N}_p(\\alpha)\\,(x - x_0)\\,\\exp\\!\\big(-\\alpha (x - x_0)^2\\big)$，其中 $\\mathcal{N}_p(\\alpha) = \\dfrac{2^{5/4}\\,\\alpha^{3/4}}{\\pi^{1/4}}$。\n     它们的 $x$ 导数将用于计算动能矩阵：\n     $$\n     \\dfrac{d}{dx}g_s(x;x_0,\\alpha) \\;=\\; -2\\alpha(x - x_0)\\,g_s(x;x_0,\\alpha), \\quad\n     \\dfrac{d}{dx}g_p(x;x_0,\\alpha) \\;=\\; \\mathcal{N}_p(\\alpha)\\,e^{-\\alpha (x - x_0)^2}\\,\\big(1 - 2\\alpha(x - x_0)^2\\big).\n     $$\n\n   - 在每个氢中心（$x = \\pm R/2$）处有两种基组选择：\n     a) 每个中心上类似 STO-3G 的收缩 $s$ 函数（总共两个基函数）：\n        - 使用三个 $s$ 型原函数，其指数和收缩系数为\n          $$\n          \\boldsymbol{\\alpha}^{\\text{STO}} = [\\,3.42525091,\\;0.62391373,\\;0.16885540\\,], \\qquad\n          \\mathbf{c}^{\\text{STO}} = [\\,0.15432897,\\;0.53532814,\\;0.44463454\\,].\n          $$\n        - 位于中心 $x_0$ 的收缩函数为 $\\phi_{s}^{\\text{STO}}(x;x_0) = \\sum_{i=1}^{3} c^{\\text{STO}}_i\\,g_s(x;x_0,\\alpha^{\\text{STO}}_i)$。在 $x_0 = -R/2$ 和 $x_0 = +R/2$ 处各构建一个这样的收缩函数。\n\n     b) 每个中心上类似 cc-pVTZ 的非收缩 $s$ 函数外加一个 $p$ 极化函数（总共八个基函数）：\n        - 每个中心的 $s$ 型原函数，其指数为\n          $$\n          \\boldsymbol{\\alpha}^{\\text{cc-s}} = [\\,13.010701,\\;1.9622572,\\;0.44453796\\,],\n          $$\n          被视为独立的基函数（非收缩）。\n        - 每个中心一个 $p$ 型原函数，其指数为\n          $$\n          \\alpha^{\\text{cc-p}} = 0.730\n          $$\n        - 在每个中心 $x_0 = \\pm R/2$ 上，包含所有 $\\alpha \\in \\boldsymbol{\\alpha}^{\\text{cc-s}}$ 的三个 $s$ 型函数 $g_s(x;x_0,\\alpha)$ 和一个 $p$ 型函数 $g_p(x;x_0,\\alpha^{\\text{cc-p}})$。\n\n   - 对每个基组，求解广义本征问题，并提取最低本征值 $E_{\\text{STO}}(R)$ 或 $E_{\\text{cc}}(R)$ 以及相应的归一化本征矢量，它定义了变分轨道 $\\psi_{\\text{STO}}(x;R)$ 或 $\\psi_{\\text{cc}}(x;R)$。在整个网格上使用梯形法则进行归一化。\n\n3) 每个测试用例需报告的指标：\n   - 绝对能量误差（单位：哈特里）：$|E_{\\text{STO}}(R) - E_{\\text{ref}}(R)|$ 和 $|E_{\\text{cc}}(R) - E_{\\text{ref}}(R)|$。\n   - “一减去重叠积分”以量化轨道一致性（无单位）：$1 - \\big|\\int \\psi_{\\text{STO}}(x;R)\\,\\psi_{\\text{ref}}(x;R)\\,dx \\big|$ 和 $1 - \\big|\\int \\psi_{\\text{cc}}(x;R)\\,\\psi_{\\text{ref}}(x;R)\\,dx \\big|$，所有积分均在整个网格上通过梯形法则计算。\n\n对所有测试用例使用以下固定的数值参数：\n- 网格半范围 $L = 15.0$ 玻尔，间距 $h = 0.01$ 玻尔。\n- 软库仑参数 $a = 0.6$ 玻尔。\n\n测试套件（三种核间距，单位：玻尔）：\n- 用例 1: $R = 1.40$。\n- 用例 2: $R = 0.70$。\n- 用例 3: $R = 5.00$。\n\n程序要求和输出：\n- 无需任何外部数据文件，实现上述完整流程。\n- 对于每个测试用例，按以下顺序计算四个浮点数：类似 STO-3G 的绝对能量误差（哈特里），类似 cc-pVTZ 的绝对能量误差（哈特里），类似 STO-3G 的“一减去重叠积分”（无单位），类似 cc-pVTZ 的“一减去重叠积分”（无单位）。\n- 将每个报告的浮点数四舍五入到恰好六位小数。能量单位必须是哈特里。重叠积分必须是小数形式，不带百分号。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表内容按测试用例（从用例 1 到用例 3）排序，且在每个用例内部，按上述指定顺序排列。例如：\"[v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12]\"。", "solution": "所提出的问题是计算量子力学中一个定义明确的练习，特别关注于对氢分子离子 $H_2^+$ 的一维模型应用 Born-Oppenheimer 近似和变分原理。该问题具有科学依据，内容自洽，且算法明确。因此，该问题被认为是有效的，并将提供一个解决方案。\n\n目标是比较两种基于有限高斯函数基组的常见近似方案，并与在密集网格上获得的数值精确参考解进行对比。这旨在说明在量子化学中至关重要的计算成本与准确性之间的权衡。所有计算均在哈特里原子单位制下进行。\n\n该系统由单电子哈密顿算符描述：\n$$\n\\hat{H} \\;=\\; \\hat{T} + \\hat{V} \\;=\\; -\\dfrac{1}{2}\\dfrac{d^2}{dx^2} \\;-\\; \\dfrac{1}{\\sqrt{(x - R/2)^2 + a^2}} \\;-\\; \\dfrac{1}{\\sqrt{(x + R/2)^2 + a^2}}\n$$\n其中 $R$ 是核间距，$a$ 是库仑势的软化参数。我们必须找到不含时薛定谔方程（TISE）$\\hat{H}\\psi(x) = E\\psi(x)$ 的基态（最低）本征值 $E$ 和相应的本征函数 $\\psi(x)$。\n\n**1. 参考解：有限差分法**\n\n为建立准确性的基准，在区间 $[-L, +L]$ 上定义的均匀空间网格上求解 TISE，网格间距为 $h$。格点为 $x_i = -L + i \\cdot h$，其中 $i=0, 1, \\dots, N-1$，$N$ 是总点数。波函数 $\\psi(x)$ 由其在这些点上的值 $\\psi_i = \\psi(x_i)$ 表示。\n\n动能算符 $\\hat{T} = -\\frac{1}{2}\\frac{d^2}{dx^2}$ 使用三点中心有限差分公式对二阶导数进行近似：\n$$\n\\dfrac{d^2\\psi}{dx^2}\\bigg|_{x_i} \\;\\approx\\; \\dfrac{\\psi_{i+1} - 2\\psi_i + \\psi_{i-1}}{h^2}\n$$\n将此应用于内部格点 $x_i$（其中 $i=1, \\dots, N-2$）处的 TISE，得到：\n$$\n-\\dfrac{1}{2h^2}(\\psi_{i+1} - 2\\psi_i + \\psi_{i-1}) + V(x_i; R, a)\\psi_i \\;=\\; E\\psi_i\n$$\n重新整理此方程得到：\n$$\n-\\dfrac{1}{2h^2}\\psi_{i-1} + \\left(\\dfrac{1}{h^2} + V(x_i; R, a)\\right)\\psi_i - \\dfrac{1}{2h^2}\\psi_{i+1} \\;=\\; E\\psi_i\n$$\n问题指定了狄利克雷边界条件，$\\psi(-L) = \\psi_0 = 0$ 和 $\\psi(+L) = \\psi_{N-1} = 0$。这些条件使我们能够将所有内部点的方程写成矩阵本征值问题 $\\mathbf{H}_{\\text{grid}}\\boldsymbol{\\psi} = E\\boldsymbol{\\psi}$。矩阵 $\\mathbf{H}_{\\text{grid}}$ 是一个大小为 $(N-2) \\times (N-2)$ 的实对称三对角矩阵，其对角元素为 $d_i = \\frac{1}{h^2} + V(x_i; R, a)$，次对角元素为 $e_i = -\\frac{1}{2h^2}$。\n\n求解该问题可得到一组本征值和本征矢量。最低的本征值是参考基态能量 $E_{\\text{ref}}$。相应的本征矢量包含波函数 $\\psi_{\\text{ref}}$ 在内部格点上的值，然后通过边界零点进行扩展，并使用梯形法则进行归一化，使得 $\\int |\\psi_{\\text{ref}}(x)|^2 dx \\approx \\sum_{i=0}^{N-2} \\frac{(\\psi_i^2 + \\psi_{i+1}^2)}{2}h = 1$。\n\n**2. 变分解：高斯基组中的 Rayleigh-Ritz 方法**\n\n变分原理指出，对于任何归一化的试探波函数 $\\Psi$，哈密顿算符的期望值提供了真实基态能量 $E_0$ 的一个上界：\n$$\nE[\\Psi] \\;=\\; \\dfrac{\\langle\\Psi|\\hat{H}|\\Psi\\rangle}{\\langle\\Psi|\\Psi\\rangle} \\;\\ge\\; E_0\n$$\n我们将试探波函数构建为 $N_{bf}$ 个已知基函数 $\\{\\phi_\\nu(x)\\}$ 的线性组合：\n$$\n\\Psi(x) \\;=\\; \\sum_{\\nu=1}^{N_{bf}} c_\\nu \\phi_\\nu(x)\n$$\n将此代入能量泛函，并对系数 $\\{c_\\mu\\}$ 进行最小化，可得到 Roothaan-Hall 方程，这是一个广义本征值问题：\n$$\n\\sum_\\nu H_{\\mu\\nu} c_\\nu \\;=\\; E \\sum_\\nu S_{\\mu\\nu} c_\\nu \\quad \\text{或，在矩阵形式下，} \\quad \\mathbf{H}\\mathbf{c} = E\\mathbf{S}\\mathbf{c}\n$$\n矩阵 $\\mathbf{H}$ 和 $\\mathbf{S}$ 分别是哈密顿矩阵和重叠矩阵，其元素为：\n$$\nS_{\\mu\\nu} \\;=\\; \\int \\phi_\\mu(x)\\,\\phi_\\nu(x)\\,dx\n$$\n$$\nH_{\\mu\\nu} \\;=\\; \\int \\phi_\\mu(x)\\,\\hat{H}\\,\\phi_\\nu(x)\\,dx \\;=\\; T_{\\mu\\nu} + V_{\\mu\\nu}\n$$\n使用分部积分，动能矩阵元 $T_{\\mu\\nu}$ 以其对称形式计算：\n$$\nT_{\\mu\\nu} \\;=\\; \\int \\phi_\\mu(x)\\left(-\\dfrac{1}{2}\\dfrac{d^2}{dx^2}\\right)\\phi_\\nu(x)\\,dx \\;=\\; \\dfrac{1}{2} \\int \\left(\\dfrac{d\\phi_\\mu}{dx}\\right)\\left(\\dfrac{d\\phi_\\nu}{dx}\\right) dx\n$$\n势能矩阵元为：\n$$\nV_{\\mu\\nu} \\;=\\; \\int \\phi_\\mu(x)\\,V(x;R,a)\\,\\phi_\\nu(x)\\,dx\n$$\n所有矩阵元都通过在同一网格上使用梯形法则进行数值积分来计算。\n\n研究了两种基组：\na) 一个最小的收缩基组（“类似STO-3G”），由两个函数组成。每个函数是三个原始 $s$ 型高斯函数的固定线性组合，以其中一个质子（$x = \\pm R/2$）为中心。该基组总共有 $N_{bf}=2$ 个函数。\nb) 一个更大的非收缩基组（“类似cc-pVTZ”），包含八个函数。对于每个质子，我们使用三个不同的 $s$ 型高斯原函数和一个 $p$ 型极化函数作为独立的基函数。这总共得到 $2 \\times (3 + 1) = 8$ 个基函数，因此 $N_{bf}=8$。\n\n对每个基组，求解广义本征值问题可得到一组能量本征值和相应的系数矢量。最低的本征值是基态能量的变分近似值 $E_{\\text{approx}}$。相关的本征矢量 $\\mathbf{c}$ 用于构建近似波函数 $\\psi_{\\text{approx}}(x) = \\sum_\\nu c_\\nu \\phi_\\nu(x)$。然后，该波函数再次使用梯形法则在网格上进行归一化。\n\n**3. 比较指标**\n\n对于每个给定的核间距 $R$，每种基组近似的质量通过两个指标来量化：\n- **绝对能量误差**：$|E_{\\text{approx}}(R) - E_{\\text{ref}}(R)|$。根据变分原理，该误差必须为非负。较小的值表示对能量的近似更好。\n- **轨道“一减去重叠积分”**：$1 - \\left|\\int \\psi_{\\text{approx}}(x;R)\\,\\psi_{\\text{ref}}(x;R)\\,dx \\right|$。这衡量了近似波函数与参考波函数的偏差。一个接近零的值表示对电子空间分布的描述更好。\n\n该算法将使用 Python 实现，利用 `numpy` 库进行数值运算，并使用 `scipy.linalg` 库求解本征值问题。将对三个指定的 $R$ 值进行计算，并将结果编译成所需的输出格式。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import eigh, eigh_tridiagonal\n\n# Constants given in the problem\nL_BOHR = 15.0\nH_BOHR = 0.01\nA_BOHR = 0.6\n\n# Basis set parameters\nALPHA_STO = np.array([3.42525091, 0.62391373, 0.16885540])\nC_STO = np.array([0.15432897, 0.53532814, 0.44463454])\nALPHA_CC_S = np.array([13.010701, 1.9622572, 0.44453796])\nALPHA_CC_P = 0.730\n\ndef potential_func(x, R, a):\n    \"\"\"Computes the 1D soft-Coulomb potential.\"\"\"\n    return -1.0 / np.sqrt((x - R / 2.0)**2 + a**2) - 1.0 / np.sqrt((x + R / 2.0)**2 + a**2)\n\ndef solve_grid_reference(R, L, h, a):\n    \"\"\"Solves the TISE on a grid using finite differences.\"\"\"\n    x_full = np.arange(-L, L + h, h)\n    x_interior = x_full[1:-1]\n    \n    V_interior = potential_func(x_interior, R, a)\n    \n    # Construct the tridiagonal Hamiltonian for interior points\n    diag = 1.0 / h**2 + V_interior\n    off_diag = -1.0 / (2.0 * h**2) * np.ones(len(x_interior) - 1)\n    \n    # Solve the eigenvalue problem\n    eigvals, eigvecs = eigh_tridiagonal(diag, off_diag)\n    \n    # Ground state is the lowest eigenvalue and corresponding eigenvector\n    E_ref = eigvals[0]\n    psi_interior = eigvecs[:, 0]\n    \n    # Reconstruct full wavefunction with boundary conditions\n    psi_ref_unnormalized = np.zeros_like(x_full)\n    psi_ref_unnormalized[1:-1] = psi_interior\n    \n    # Normalize using the trapezoidal rule\n    norm_sq = np.trapz(psi_ref_unnormalized**2, x_full)\n    psi_ref = psi_ref_unnormalized / np.sqrt(norm_sq)\n    \n    return E_ref, psi_ref, x_full\n\ndef g_s_primitive(x, x0, alpha):\n    \"\"\"Normalized s-type Gaussian primitive.\"\"\"\n    norm = (2 * alpha / np.pi)**0.25\n    return norm * np.exp(-alpha * (x - x0)**2)\n\ndef dg_s_primitive_dx(x, x0, alpha):\n    \"\"\"Derivative of a normalized s-type Gaussian primitive.\"\"\"\n    return -2.0 * alpha * (x - x0) * g_s_primitive(x, x0, alpha)\n\ndef g_p_primitive(x, x0, alpha):\n    \"\"\"Normalized p-type Gaussian primitive.\"\"\"\n    norm = (2**1.25 * alpha**0.75) / (np.pi**0.25) # Typo in problem statement for N_p, using correct analytical form\n    return norm * (x - x0) * np.exp(-alpha * (x - x0)**2)\n\ndef dg_p_primitive_dx(x, x0, alpha):\n    \"\"\"Derivative of a normalized p-type Gaussian primitive.\"\"\"\n    norm = (2**1.25 * alpha**0.75) / (np.pi**0.25) # Typo in problem statement for N_p, using correct analytical form\n    return norm * np.exp(-alpha * (x - x0)**2) * (1 - 2 * alpha * (x - x0)**2)\n\ndef get_basis_functions(basis_type, R, x):\n    \"\"\"Generates basis functions and their derivatives on the grid.\"\"\"\n    centers = [-R / 2.0, R / 2.0]\n    functions = []\n    derivatives = []\n\n    if basis_type == 'STO':\n        for x0 in centers:\n            phi = np.zeros_like(x)\n            dphi_dx = np.zeros_like(x)\n            for i in range(len(ALPHA_STO)):\n                alpha = ALPHA_STO[i]\n                c = C_STO[i]\n                phi += c * g_s_primitive(x, x0, alpha)\n                dphi_dx += c * dg_s_primitive_dx(x, x0, alpha)\n            functions.append(phi)\n            derivatives.append(dphi_dx)\n    elif basis_type == 'CC':\n        for x0 in centers:\n            # s-type functions\n            for alpha_s in ALPHA_CC_S:\n                functions.append(g_s_primitive(x, x0, alpha_s))\n                derivatives.append(dg_s_primitive_dx(x, x0, alpha_s))\n            # p-type function\n            functions.append(g_p_primitive(x, x0, ALPHA_CC_P))\n            derivatives.append(dg_p_primitive_dx(x, x0, ALPHA_CC_P))\n    \n    return functions, derivatives\n\ndef solve_variational(R, a, x_grid, basis_type):\n    \"\"\"Solves the TISE using the Rayleigh-Ritz variational method.\"\"\"\n    basis_funcs, basis_derivs = get_basis_functions(basis_type, R, x_grid)\n    n_basis = len(basis_funcs)\n    \n    S = np.zeros((n_basis, n_basis))\n    H = np.zeros((n_basis, n_basis))\n    \n    V_grid = potential_func(x_grid, R, a)\n\n    for i in range(n_basis):\n        for j in range(n_basis):\n            # Overlap matrix element\n            integrand_S = basis_funcs[i] * basis_funcs[j]\n            S[i, j] = np.trapz(integrand_S, x_grid)\n            \n            # Kinetic energy matrix element\n            integrand_T = basis_derivs[i] * basis_derivs[j]\n            T_ij = 0.5 * np.trapz(integrand_T, x_grid)\n            \n            # Potential energy matrix element\n            integrand_V = basis_funcs[i] * V_grid * basis_funcs[j]\n            V_ij = np.trapz(integrand_V, x_grid)\n            \n            H[i, j] = T_ij + V_ij\n\n    # Solve the generalized eigenvalue problem\n    eigvals, eigvecs = eigh(H, S)\n    \n    # Ground state is the lowest eigenvalue and corresponding eigenvector\n    E_basis = eigvals[0]\n    coeffs = eigvecs[:, 0]\n    \n    # Construct the wavefunction from the basis functions and coefficients\n    psi_unnormalized = np.zeros_like(x_grid)\n    for i in range(n_basis):\n        psi_unnormalized += coeffs[i] * basis_funcs[i]\n        \n    # Normalize the final wavefunction\n    norm_sq = np.trapz(psi_unnormalized**2, x_grid)\n    psi_basis = psi_unnormalized / np.sqrt(norm_sq)\n    \n    return E_basis, psi_basis\n\ndef solve():\n    test_cases = [1.40, 0.70, 5.00]\n    all_results = []\n    \n    # Correction for N_p in problem description: (2^(5/4) * alpha^(3/4)) / pi^(1/4) != sqrt(sqrt(2^2.5 * alpha^1.5 / pi^0.5)). \n    # The correct 1D p-type normalization constant is (4 * alpha^3 / (9 * pi))^(1/4) * sqrt(3) is not it.\n    # The correct 1D p-type normalization for (x-x0) * exp(-alpha*(x-x0)^2) is sqrt(2*alpha / Gamma(3/2)) = sqrt(4*alpha/sqrt(pi)).\n    # The provided N_p seems to have an error. For the sake of reproducibility, the problem's formula is used, but a silent correction might be needed.\n    # After checking the derivation, N_p(alpha) = 2^(5/4)*alpha^(3/4)/pi^(1/4) is correct. My re-derivation was faulty. No code change needed.\n    \n    for R_val in test_cases:\n        # 1. Compute reference solution\n        E_ref, psi_ref, x = solve_grid_reference(R_val, L_BOHR, H_BOHR, A_BOHR)\n\n        # 2. Compute STO-3G-like solution\n        E_sto, psi_sto = solve_variational(R_val, A_BOHR, x, 'STO')\n        \n        # 3. Compute cc-pVTZ-like solution\n        E_cc, psi_cc = solve_variational(R_val, A_BOHR, x, 'CC')\n        \n        # 4. Calculate metrics\n        err_E_sto = abs(E_sto - E_ref)\n        err_E_cc = abs(E_cc - E_ref)\n        \n        overlap_sto = np.trapz(psi_sto * psi_ref, x)\n        err_psi_sto = 1.0 - abs(overlap_sto)\n        \n        overlap_cc = np.trapz(psi_cc * psi_ref, x)\n        err_psi_cc = 1.0 - abs(overlap_cc)\n        \n        all_results.extend([err_E_sto, err_E_cc, err_psi_sto, err_psi_cc])\n\n    # Format the final output string\n    formatted_results = [f\"{val:.6f}\" for val in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2452274"}]}