{"hands_on_practices": [{"introduction": "统计力学的核心基石之一是将宏观熵 $S$ 与微观状态数 $W$ 联系起来的 Boltzmann 公式 $S = k_{\\mathrm{B}} \\ln W$。然而，“如何正确计数 $W$” 这个问题本身就是一个深刻的挑战，直接导致了著名的 Gibbs 佯谬：经典理论预测当两种相同的气体混合时会产生熵增，这与热力学实验相矛盾。这个练习 [@problem_id:2462921] 让你通过编程直接面对这个佯谬，通过对比可区分粒子和不可区分粒子两种计数方式下的熵变计算，你将亲手揭示为何粒子的不可区分性——一个纯粹的量子概念——对于构建一个自洽的统计理论至关重要。", "problem": "您将编写一个完整、可运行的程序，在理想气体的经典统计力学假设下，计算移除两个隔间之间的隔板并让其内容物混合后的熵变。您必须对比两种计数约定来展示 Gibbs 佯谬：一种将粒子视为可分辨的，另一种将粒子视为不可分辨的。假设在微正则系综中有无相互作用的点粒子，根据各态遍历假说所隐含的等概率先验假设，固定能量壳层中的每个可及微观态都是等概率的，并且熵定义为 $S = k_{\\mathrm{B}} \\ln W$，其中 $W$ 是可及微观态的数量，$k_{\\mathrm{B}}$ 是玻尔兹曼常数。\n\n考虑一个刚性绝热容器，被一个可移除的隔板分成体积为 $V_A$ 的隔间 $A$ 和体积为 $V_B$ 的隔间 $B$。最初，隔间 $A$ 包含 $N_A$ 个粒子，隔间 $B$ 包含 $N_B$ 个粒子。两个隔间具有相等的数密度和相等的比能，因此移除隔板后，除了因混合导致的可及组态空间增加外，没有净能量交换。您必须使用自然对数，并以 $k_{\\mathrm{B}}$ 为单位表示所有熵变（即，将 $S/k_{\\mathrm{B}}$ 报告为无量纲数）。\n\n定义两种计数约定如下：\n- 可分辨粒子：可及微观态的数量与 $W \\propto V^{N}$ 成正比，不除以粒子数的阶乘。\n- 不可分辨粒子：可及微观态的数量与 $W \\propto V^{N} / N!$ 成正比，其中 $N!$ 是粒子数的阶乘。\n\n对于每个测试用例，分别计算两种约定下的混合熵变 $\\Delta S = S_{\\text{after}} - S_{\\text{before}}$，并将这两个值报告为 $S/k_{\\mathrm{B}}$。\n\n使用以下测试套件（每个测试用例是一个元组 $(N_A, N_B, V_A, V_B)$）：\n- 测试用例 1：$(100, 100, 1.0, 1.0)$。\n- 测试用例 2：$(50, 150, 0.75, 2.25)$。\n- 测试用例 3：$(3, 2, 0.3, 0.2)$。\n- 测试用例 4：$(1, 1, 0.1, 0.1)$。\n- 测试用例 5：$(1000, 1000, 10.0, 10.0)$。\n\n所有五个测试用例都满足 $N_A/V_A = N_B/V_B$，因此初始数密度相等。\n\n您的程序必须输出单行，包含一个无空格的实数扁平列表，按顺序表示每个测试用例的：\n- 可分辨粒子熵变 $\\Delta S_{\\mathrm{dist}}/k_{\\mathrm{B}}$，以浮点数表示。\n- 不可分辨粒子熵变 $\\Delta S_{\\mathrm{indist}}/k_{\\mathrm{B}}$，以浮点数表示。\n\n因此，最终输出应为单行，格式为\n$[d_1,i_1,d_2,i_2,d_3,i_3,d_4,i_4,d_5,i_5]$\n其中 $d_j$ 和 $i_j$ 是测试用例 $j$ 的两个所求浮点数。这些数值必须根据指定的第一性原理计算，使用自然对数打印，并以 $k_{\\mathrm{B}}$ 为单位表示。", "solution": "我们被要求在经典理想气体框架内，用两种计数约定来计算混合过程的熵变。微正则系综假设，根据各态遍历假说，具有相同守恒量的所有微观态都是等概率的。熵根据第一性原理定义为 $S = k_{\\mathrm{B}} \\ln W$，其中 $W$ 是可及微观态的数量。\n\n设置：最初，有两个独立的子系统，$A$ 中有 $N_A$ 个粒子被限制在体积 $V_A$ 内，$B$ 中有 $N_B$ 个粒子被限制在体积 $V_B$ 内。移除隔板后，每个粒子都可以进入总体积 $V = V_A + V_B$。我们假设粒子是理想的、无相互作用的，并且初始时具有相等的数密度和比能，因此动量空间贡献和任何与能量相关的项在初态和末态之间相互抵消。因此，混合时的熵变完全由组态空间多重性的变化决定。\n\n可分辨计数法：在没有不可分辨性修正的经典力学中，对于体积 $V$ 中的 $N$ 个已标记粒子，组态空间多重性与 $W \\propto V^{N}$ 成正比。对于初始状态，\n$$\nW_{\\text{before}}^{\\text{(dist)}} \\propto V_A^{N_A} \\, V_B^{N_B}.\n$$\n混合后，\n$$\nW_{\\text{after}}^{\\text{(dist)}} \\propto (V_A + V_B)^{N_A + N_B}.\n$$\n因此，以 $k_{\\mathrm{B}}$ 为单位的熵变为\n$$\n\\frac{\\Delta S_{\\text{dist}}}{k_{\\mathrm{B}}}\n= \\ln \\frac{W_{\\text{after}}^{\\text{(dist)}}}{W_{\\text{before}}^{\\text{(dist)}}}\n= (N_A + N_B) \\ln (V_A + V_B) - N_A \\ln V_A - N_B \\ln V_B\n= N_A \\ln \\frac{V_A + V_B}{V_A} + N_B \\ln \\frac{V_A + V_B}{V_B}.\n$$\n\n不可分辨计数法：对于不可分辨的经典粒子，需要除以阶乘来消除相同粒子的排列。对于最初分离（物理上不相交）的两个隔间，多重性为\n$$\nW_{\\text{before}}^{\\text{(indist)}} \\propto \\frac{V_A^{N_A}}{N_A!} \\, \\frac{V_B^{N_B}}{N_B!}.\n$$\n对相同粒子移除隔板后，\n$$\nW_{\\text{after}}^{\\text{(indist)}} \\propto \\frac{(V_A + V_B)^{N_A + N_B}}{(N_A + N_B)!}.\n$$\n因此，\n$$\n\\frac{\\Delta S_{\\text{indist}}}{k_{\\mathrm{B}}}\n= \\ln \\frac{W_{\\text{after}}^{\\text{(indist)}}}{W_{\\text{before}}^{\\text{(indist)}}}\n= \\left[(N_A + N_B) \\ln (V_A + V_B) - \\ln (N_A + N_B)!\\right]\n- \\left[N_A \\ln V_A - \\ln N_A! + N_B \\ln V_B - \\ln N_B!\\right]\n$$\n$$\n= N_A \\ln \\frac{V_A + V_B}{V_A} + N_B \\ln \\frac{V_A + V_B}{V_B}\n- \\left[\\ln (N_A + N_B)! - \\ln N_A! - \\ln N_B!\\right].\n$$\n比较两者，不可分辨的结果减去了多项式组合因子 $\\ln \\frac{(N_A + N_B)!}{N_A! \\, N_B!}$，该因子计算了为原本相同的粒子分配标签的方式数。这种减法解决了 Gibbs 佯谬：对于相等的初始数密度，在热力学极限下，混合的广延性 $\\mathcal{O}(N)$ 贡献与组合项相抵消，使得相同粒子的混合熵在每个粒子上趋于零。有限系统保留了一个次广延的 $\\mathcal{O}(\\ln N)$ 阶修正。\n\n算法实现：为了数值稳定性，通过伽马函数的对数来计算 $\\ln n!$，使用 $\\ln n! = \\ln \\Gamma(n+1)$。给定一个测试用例 $(N_A, N_B, V_A, V_B)$：\n- 计算 $V = V_A + V_B$。\n- 计算 $\\frac{\\Delta S_{\\text{dist}}}{k_{\\mathrm{B}}} = N_A \\ln (V/V_A) + N_B \\ln (V/V_B)$。\n- 计算 $\\frac{\\Delta S_{\\text{indist}}}{k_{\\mathrm{B}}} = \\frac{\\Delta S_{\\text{dist}}}{k_{\\mathrm{B}}} - \\left[\\ln \\Gamma(N_A + N_B + 1) - \\ln \\Gamma(N_A + 1) - \\ln \\Gamma(N_B + 1)\\right]$。\n\n应用于测试套件：\n- 测试用例 1 $(100, 100, 1.0, 1.0)$ 得出 $\\frac{\\Delta S_{\\text{dist}}}{k_{\\mathrm{B}}} = 200 \\ln 2$ 和 $\\frac{\\Delta S_{\\text{indist}}}{k_{\\mathrm{B}}} = 200 \\ln 2 - \\ln \\binom{200}{100}$，与广延性的可分辨结果相比，这是一个小的次广延正数。\n- 测试用例 2 $(50, 150, 0.75, 2.25)$ 得出 $\\frac{\\Delta S_{\\text{dist}}}{k_{\\mathrm{B}}} = 50 \\ln 4 + 150 \\ln \\frac{4}{3}$ 和 $\\frac{\\Delta S_{\\text{indist}}}{k_{\\mathrm{B}}} = \\frac{\\Delta S_{\\text{dist}}}{k_{\\mathrm{B}}} - \\ln \\binom{200}{50}$。\n- 测试用例 3 $(3, 2, 0.3, 0.2)$ 得出 $\\frac{\\Delta S_{\\text{dist}}}{k_{\\mathrm{B}}} = 3 \\ln \\frac{5}{3} + 2 \\ln \\frac{5}{2}$ 和 $\\frac{\\Delta S_{\\text{indist}}}{k_{\\mathrm{B}}} = \\frac{\\Delta S_{\\text{dist}}}{k_{\\mathrm{B}}} - \\ln 10$。\n- 测试用例 4 $(1, 1, 0.1, 0.1)$ 得出 $\\frac{\\Delta S_{\\text{dist}}}{k_{\\mathrm{B}}} = 2 \\ln 2$ 和 $\\frac{\\Delta S_{\\text{indist}}}{k_{\\mathrm{B}}} = \\ln 2$。\n- 测试用例 5 $(1000, 1000, 10.0, 10.0)$ 说明了热力学极限：$\\frac{\\Delta S_{\\text{dist}}}{k_{\\mathrm{B}}} = 2000 \\ln 2$ 而 $\\frac{\\Delta S_{\\text{indist}}}{k_{\\mathrm{B}}} = 2000 \\ln 2 - \\ln \\binom{2000}{1000}$ 是次广延的，且仅以 $\\frac{1}{2}\\ln(\\pi N)$ 的方式增长，因此每个粒子的熵变趋于零。\n\n最后，将五个案例的结果按指定顺序汇总到一个扁平列表中，并在一行上打印为 $[d_1,i_1,d_2,i_2,d_3,i_3,d_4,i_4,d_5,i_5]$，其中每个条目都是一个表示 $S/k_{\\mathrm{B}}$ 的浮点数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import gammaln\n\ndef mixing_entropy_distinguishable(Na, Nb, Va, Vb):\n    V = Va + Vb\n    return Na * np.log(V / Va) + Nb * np.log(V / Vb)\n\ndef mixing_entropy_indistinguishable(Na, Nb, Va, Vb):\n    # Use gamma function for exact ln(n!) stability: ln(n!) = gammaln(n+1)\n    dist = mixing_entropy_distinguishable(Na, Nb, Va, Vb)\n    comb = gammaln(Na + Nb + 1) - gammaln(Na + 1) - gammaln(Nb + 1)\n    return dist - comb\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case is (N_A, N_B, V_A, V_B)\n    test_cases = [\n        (100, 100, 1.0, 1.0),\n        (50, 150, 0.75, 2.25),\n        (3, 2, 0.3, 0.2),\n        (1, 1, 0.1, 0.1),\n        (1000, 1000, 10.0, 10.0),\n    ]\n\n    results = []\n    for Na, Nb, Va, Vb in test_cases:\n        d = mixing_entropy_distinguishable(Na, Nb, Va, Vb)\n        i = mixing_entropy_indistinguishable(Na, Nb, Va, Vb)\n        # Format as floats; keep a consistent decimal representation\n        results.append(f\"{d:.6f}\")\n        results.append(f\"{i:.6f}\")\n\n    # Final print statement in the exact required format: no spaces\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2462921"}, {"introduction": "统计系综理论的预测是基于对一个系统所有可能微观状态的平均，但在模拟中我们通常只跟踪一条长长的轨迹。连接这两者的桥梁是遍历性假设，它断言时间平均等于系综平均。然而，当系统被高高的能垒分隔成多个区域时（例如在蛋白质折叠中），这个假设可能会在有限的模拟时间内失效。这个动手实践 [@problem_id:2462993] 将抽象的遍历性概念变得具体可感，你将构建一个具有多个势阱的系统，并使用分子动力学模拟来观察温度如何决定系统是被“遍历性破缺”地困在单一状态，还是能够遍历地探索所有可能的状态。", "problem": "你需要构建并模拟一个具有多个极小值的二维势能面，并使用随机分子动力学来检验遍历性假设。从基本原理出发：牛顿第二定律、力定义为势的负梯度，以及作为恒温器驱动动力学目标的正则系综。使用标准的 Langevin 恒温器对温度进行建模，该恒温器在长时间极限下会产生正则（Boltzmann）稳态分布。\n\n定义一个对称的四阱势能面，其势阱中心位于 $(\\pm x_0,\\pm y_0)$，使用约化的无量纲单位，其中 Boltzmann 常数 $k_B$ 設为 $1$。设势为\n$$\nV(x,y) = \\sum_{s_x\\in\\{-1,+1\\}} \\sum_{s_y\\in\\{-1,+1\\}} \\left[-A \\exp\\!\\left(-\\frac{(x-s_x x_0)^2 + (y-s_y y_0)^2}{2\\sigma^2}\\right)\\right],\n$$\n参数为 $A>0$, $\\sigma>0$, $x_0>0$, $y_0>0$。力由 $\\mathbf{F}(x,y) = -\\nabla V(x,y)$ 定义。考虑一个质量为 $m$ 的粒子在该势场中遵循 Langevin 动力学，\n$$\nm\\ddot{\\mathbf{r}} = \\mathbf{F}(\\mathbf{r}) - \\gamma m \\dot{\\mathbf{r}} + \\sqrt{2\\gamma m k_B T}\\,\\boldsymbol{\\eta}(t),\n$$\n其中 $\\gamma>0$ 是摩擦系数，$T$ 是温度（在约化单位下，因此 $k_B=1$），$\\boldsymbol{\\eta}(t)$ 是零均值和单位协方差的高斯白噪声。使用与此随机微分方程一致的时间离散化方法，并在恒温器步骤中保持速度的正确稳态分布。\n\n你的程序必须：\n- 全程使用约化的无量纲单位，并明确设置 $k_B=1$。\n- 实现一个对称的四阱势，固定参数如下：$A=2.0$, $\\sigma=0.35$, $x_0=1.0$, $y_0=1.0$, $m=1.0$, $\\gamma=1.0$，以及时间步长 $\\Delta t=0.005$。\n- 使用 BAOAB 分裂方案进行 Langevin 动力学模拟，其中长度为 $\\Delta t$ 的一个完整步骤包括：\n  - $B$：使用保守力进行半步速度更新，\n  $$\n  \\mathbf{v} \\leftarrow \\mathbf{v} + \\frac{\\Delta t}{2m}\\,\\mathbf{F}(\\mathbf{r}),\n  $$\n  - $A$：半步位置更新，\n  $$\n  \\mathbf{r} \\leftarrow \\mathbf{r} + \\frac{\\Delta t}{2}\\,\\mathbf{v},\n  $$\n  - $O$：完整的 Ornstein–Uhlenbeck 速度更新，\n  $$\n  \\mathbf{v} \\leftarrow e^{-\\gamma \\Delta t}\\,\\mathbf{v} + \\sqrt{\\frac{k_B T}{m}\\left(1-e^{-2\\gamma \\Delta t}\\right)}\\,\\mathbf{G},\n  $$\n  其中 $\\mathbf{G}$ 是一个由独立标准正态变量组成的向量，\n  - $A$：另一次半步位置更新，\n  $$\n  \\mathbf{r} \\leftarrow \\mathbf{r} + \\frac{\\Delta t}{2}\\,\\mathbf{v},\n  $$\n  - $B$：使用新位置处的保守力进行最后半步速度更新，\n  $$\n  \\mathbf{v} \\leftarrow \\mathbf{v} + \\frac{\\Delta t}{2m}\\,\\mathbf{F}(\\mathbf{r}).\n  $$\n- 在极小值点 $(x_0,y_0)$ 处初始化轨迹，初始速度为零，即 $\\mathbf{r}(0)=(x_0,y_0)$ 和 $\\mathbf{v}(0)=(0,0)$。\n- 使用固定的随机数生成器种子 $12345$，以确保随机步骤的可复现性。\n- 根据 $(x,y)$ 平面中 $x$ 和 $y$ 的符号将平面划分为四个盆地。使用整数索引标记盆地\n$$\nb(x,y) = \\begin{cases}\n0  \\text{ if } x\\ge 0 \\text{ and } y\\ge 0,\\\\\n1  \\text{ if } x  0 \\text{ and } y\\ge 0,\\\\\n2  \\text{ if } x\\ge 0 \\text{ and } y  0,\\\\\n3  \\text{ if } x  0 \\text{ and } y  0.\n\\end{cases}\n$$\n- 对于每次模拟，统计整个轨迹（包括初始构型）访问过的不同盆地的数量。\n\n你的任务是通过以下方式证明低温下的遍历性破缺：对于足够小的 $T$ 和有限的模拟时间，轨迹仍然被限制在其初始盆地内；而在相当的时间内，对于足够大的 $T$，轨迹会访问多个盆地。为了使其具体且可测试，请运行以下温度-步数对 $(T, N_{\\text{steps}})$ 的测试套件：\n- $(0.02, 0)$,\n- $(0.02, 20000)$,\n- $(0.02, 60000)$,\n- $(2.0, 20000)$,\n- $(20.0, 20000)$.\n\n对于每对参数，执行长度为 $N_{\\text{steps}}$ 时间步的模拟，并输出访问过的不同盆地的整数数量。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。例如，如果五个计数分别为 $c_1$ 到 $c_5$，则输出必须为\n$$\n[\\;c_1,c_2,c_3,c_4,c_5\\;].\n$$\n不应打印任何额外文本。", "solution": "所述问题在科学上是合理的、提法恰当，并包含获得唯一、可验证解所需的所有必要信息。它要求实现一个分子动力学模拟，以研究二维势能面上粒子的遍历性假设。我们将着手构建所需的模拟。\n\n该系统由一个质量为 $m$ 的粒子在二维势 $V(x,y)$ 中运动来定义。势能面是一个对称的四阱势，其表达式为：\n$$\nV(x,y) = \\sum_{s_x\\in\\{-1,+1\\}} \\sum_{s_y\\in\\{-1,+1\\}} \\left[-A \\exp\\!\\left(-\\frac{(x-s_x x_0)^2 + (y-s_y y_0)^2}{2\\sigma^2}\\right)\\right]\n$$\n参数指定为 $A=2.0$, $\\sigma=0.35$, $x_0=1.0$, and $y_0=1.0$（在约化的无量纲单位下）。\n\n作用在粒子上的保守力是势的负梯度，$\\mathbf{F}(\\mathbf{r}) = -\\nabla V(\\mathbf{r})$，其中 $\\mathbf{r}=(x,y)$。力向量的分量 $F_x$ 和 $F_y$ 是通过对 $x$ 和 $y$ 求导得出的：\n$$\nF_x(x,y) = -\\frac{\\partial V}{\\partial x} = -\\frac{A}{\\sigma^2} \\sum_{s_x, s_y} (x - s_x x_0) \\exp\\left(-\\frac{(x-s_x x_0)^2 + (y-s_y y_0)^2}{2\\sigma^2}\\right)\n$$\n$$\nF_y(x,y) = -\\frac{\\partial V}{\\partial y} = -\\frac{A}{\\sigma^2} \\sum_{s_x, s_y} (y - s_y y_0) \\exp\\left(-\\frac{(x-s_x x_0)^2 + (y-s_y y_0)^2}{2\\sigma^2}\\right)\n$$\n这些表达式将用于计算模拟中每一步的力。\n\n系统的演化由 Langevin 方程控制，该方程通过包含摩擦项和随机噪声项来模拟温度为 $T$ 的正则系综：\n$$\nm\\ddot{\\mathbf{r}} = \\mathbf{F}(\\mathbf{r}) - \\gamma m \\dot{\\mathbf{r}} + \\sqrt{2\\gamma m k_B T}\\,\\boldsymbol{\\eta}(t)\n$$\n这里，$\\gamma=1.0$ 是摩擦系数，$m=1.0$ 是质量，$k_B=1.0$ 是 Boltzmann 常数，$\\boldsymbol{\\eta}(t)$ 代表高斯白噪声。这个随机微分方程使用指定的 BAOAB 分裂方案进行数值积分。这是一个对称、时间可逆且保体积的积分器，能够为正则系综提供精确的构型空间采样。一个持续时间为 $\\Delta t = 0.005$ 的单积分步由以下五个子步骤依次组成：\n\n1.  **B-步（力传播）**：在保守力 $\\mathbf{F}$ 的作用下，更新半个时间步的速度。\n    $$\n    \\mathbf{v} \\leftarrow \\mathbf{v} + \\frac{\\Delta t}{2m}\\,\\mathbf{F}(\\mathbf{r})\n    $$\n2.  **A-步（位置传播）**：使用新的速度更新半个时间步的位置。\n    $$\n    \\mathbf{r} \\leftarrow \\mathbf{r} + \\frac{\\Delta t}{2}\\,\\mathbf{v}\n    $$\n3.  **O-步（恒温器）**：根据 Ornstein-Uhlenbeck 过程的精确解更新速度，该过程模拟了来自热浴的摩擦和随机力的综合效应。\n    $$\n    \\mathbf{v} \\leftarrow e^{-\\gamma \\Delta t}\\,\\mathbf{v} + \\sqrt{\\frac{k_B T}{m}\\left(1-e^{-2\\gamma \\Delta t}\\right)}\\,\\mathbf{G}\n    $$\n    其中 $\\mathbf{G}$ 是一个由两个从标准正态分布中抽取的独立随机数组成的向量。\n4.  **A-步（位置传播）**：更新第二个半时间步的位置。\n    $$\n    \\mathbf{r} \\leftarrow \\mathbf{r} + \\frac{\\Delta t}{2}\\,\\mathbf{v}\n    $$\n5.  **B-步（力传播）**：使用新计算出的位置上的力，更新最后半个时间步的速度。\n    $$\n    \\mathbf{v} \\leftarrow \\mathbf{v} + \\frac{\\Delta t}{2m}\\,\\mathbf{F}(\\mathbf{r})\n    $$\n\n对测试套件中提供的每对温度 $T$ 和步数 $N_{\\text{steps}}$ 执行模拟协议。对于每个测试用例，系统在位置 $\\mathbf{r}(0)=(x_0, y_0)=(1.0, 1.0)$ 处初始化，初始速度为零 $\\mathbf{v}(0)=(0,0)$。为确保结果可复现，在每次独立模拟运行开始时，使用值 $12345$ 为伪随机数生成器设置种子。\n\n在每次模拟期间，监测粒子的位置。根据 $x$ 和 $y$ 坐标的符号将平面划分为四个盆地。盆地索引 $b(x,y)$ 的确定方式如下：\n$$\nb(x,y) = \\begin{cases}\n0  \\text{ if } x\\ge 0 \\text{ and } y\\ge 0,\\\\\n1  \\text{ if } x  0 \\text{ and } y\\ge 0,\\\\\n2  \\text{ if } x\\ge 0 \\text{ and } y  0,\\\\\n3  \\text{ if } x  0 \\text{ and } y  0.\n\\end{cases}\n$$\n从初始盆地开始，在整个轨迹中跟踪访问过的盆地集合。主要的可观测量是在模拟过程中访问过的不同盆地的总数。\n\n该分析用于检验遍历性假设。遍历性意味着，只要时间足够长，系统将探索所有具有相同能量的可及状态。在该系统中，四个势阱是能量上等价的极小值点。在低温下，热能 $k_B T$ 与分隔势阱的势垒相比很小。因此，预计系统在模拟期间会一直被困在初始盆地中，在这个有限的时间尺度上表现出非遍历性行为。在高温下，热能足以频繁地克服势垒，使系统能够探索所有四个盆地，从而表现出遍历性行为。来自指定测试用例的结果将展示这种依赖于温度的转变。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of simulating a particle in a four-well potential\n    using Langevin dynamics to test the ergodic hypothesis.\n    \"\"\"\n\n    # --- Fixed Parameters ---\n    A = 2.0\n    sigma = 0.35\n    x0 = 1.0\n    y0 = 1.0\n    m = 1.0\n    gamma = 1.0\n    dt = 0.005\n    k_B = 1.0  # Boltzmann constant in reduced units\n\n    # --- Test Cases (T, N_steps) ---\n    test_cases = [\n        (0.02, 0),\n        (0.02, 20000),\n        (0.02, 60000),\n        (2.0, 20000),\n        (20.0, 20000),\n    ]\n\n    # --- Helper Functions ---\n    def get_force(r: np.ndarray) - np.ndarray:\n        \"\"\"\n        Calculates the force F = -nabla(V) at position r.\n        \"\"\"\n        x, y = r\n        force = np.zeros(2)\n        s_vals = [-1.0, 1.0]\n        prefactor = A / (sigma**2)\n        \n        for sx in s_vals:\n            for sy in s_vals:\n                dx = x - sx * x0\n                dy = y - sy * y0\n                arg = -(dx**2 + dy**2) / (2 * sigma**2)\n                exp_term = np.exp(arg)\n                force[0] -= prefactor * dx * exp_term\n                force[1] -= prefactor * dy * exp_term\n        return force\n\n    def get_basin(r: np.ndarray) - int:\n        \"\"\"\n        Determines the basin index for a given position r.\n        \"\"\"\n        x, y = r\n        if x = 0 and y = 0:\n            return 0\n        elif x  0 and y = 0:\n            return 1\n        elif x = 0 and y  0:\n            return 2\n        else:  # x  0 and y  0\n            return 3\n\n    results = []\n    # --- Main Simulation Loop ---\n    for T, N_steps in test_cases:\n        # Re-seed for each independent simulation to ensure comparability\n        rng = np.random.default_rng(12345)\n\n        # Initial conditions\n        r = np.array([x0, y0])\n        v = np.array([0.0, 0.0])\n\n        # Track visited basins\n        visited_basins = {get_basin(r)}\n\n        # BAOAB integrator constants for the O-step\n        c1 = np.exp(-gamma * dt)\n        c2 = np.sqrt((k_B * T / m) * (1 - c1**2))\n\n        for _ in range(N_steps):\n            # B-step (half)\n            force = get_force(r)\n            v += (dt / (2 * m)) * force\n\n            # A-step (half)\n            r += (dt / 2) * v\n\n            # O-step\n            G = rng.standard_normal(2)\n            v = c1 * v + c2 * G\n\n            # A-step (half)\n            r += (dt / 2) * v\n\n            # B-step (half)\n            force = get_force(r)\n            v += (dt / (2 * m)) * force\n\n            # Update visited basins\n            visited_basins.add(get_basin(r))\n        \n        results.append(len(visited_basins))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2462993"}, {"introduction": "在之前的练习中，我们直观地看到了遍历性破缺的现象，但这引出了一个更实际的问题：我们如何定量地判断一次模拟是否充分地探索了相空间？一个运行时间虽长但非遍历的模拟会产生误导性的结果。这个最终的练习 [@problem_id:2462952] 为你提供了这样一个诊断工具，你将实现一个“遍历性分数”的统计量，它通过比较模拟轨迹不同部分之间的涨落与一个表现良好的平稳过程所预期的涨落，来评估采样的质量。这使得我们能从对遍历性的概念性理解，跨越到对模拟数据的实际分析。", "problem": "您将获得来自分子模拟合成的单个标量可观测量的离散时间轨迹。目标是通过比较属性在时间段上的方差与根据轨迹内的时间相关性预测的方差，来量化单个长轨迹对稳态分布（遍历性）的采样效果。\n\n从以下基本原理出发：在稳态遍历过程中，时间平均与系综平均一致；样本方差量化了涨落；时间相关性会增大块平均的方差。对于以均匀间隔采样的离散时间序列 $\\{x_k\\}_{k=1}^N$，从第一性原理定义以下量：\n\n- 样本均值 $\\mu = \\frac{1}{N}\\sum_{k=1}^N x_k$。\n- 无偏样本方差 $\\sigma^2 = \\frac{1}{N-1}\\sum_{k=1}^N (x_k - \\mu)^2$。\n- 延迟为 $k \\ge 0$ 的无偏样本自协方差，\n  $$C(k) = \\frac{1}{N-k}\\sum_{t=1}^{N-k} \\left(x_t - \\mu\\right)\\left(x_{t+k} - \\mu\\right),$$\n  以及对于 $k \\ge 1$ 的归一化自相关 $\\rho(k) = \\frac{C(k)}{C(0)}$，根据定义 $\\rho(0) = 1$。\n- 统计不等效性 $g$，使用初始正序列截断规则估计，\n  $$g = 1 + 2\\sum_{k=1}^{K^\\star} \\rho(k),$$\n  其中 $K^\\star$ 是满足对所有 $1 \\le k \\le K^\\star$ 都有 $\\rho(k)  0$ 的最大非负整数，且 $K^\\star \\le L-1$。这里 $L$ 是下文定义的每个段的公共长度。如果不存在正延迟，则取 $K^\\star = 0$，此时 $g=1$。\n\n将轨迹划分为 $M$ 个长度相等的连续、不重叠的段，每段长度为 $L = N/M$（假设 $M$ 能整除 $N$）。对于段 $i \\in \\{1,\\dots,M\\}$，设段均值为 $\\mu_i = \\frac{1}{L}\\sum_{k=(i-1)L+1}^{iL} x_k$。设段均值间的无偏样本方差为\n$$s_\\mu^2 = \\frac{1}{M-1}\\sum_{i=1}^M \\left(\\mu_i - \\bar{\\mu}\\right)^2,$$\n其中 $\\bar{\\mu} = \\frac{1}{M}\\sum_{i=1}^M \\mu_i$。\n\n在稳态和遍历性条件下，块（段）均值的方差因时间相关性而增大，并可由下式预测\n$$\\operatorname{Var}(\\mu_{\\text{block}}) \\approx \\frac{\\sigma^2\\, g}{L}.$$\n定义遍历性分数\n$$E = \\frac{s_\\mu^2}{\\sigma^2 g / L}.$$\n对于一个长的、稳态遍历的轨迹，如果 $L$ 相对于相关时间足够大，则预期 $E \\approx 1$。$E \\gg 1$ 的值表示在观测窗口内存在慢探索或非稳态性。\n\n任务：编写一个完整程序，对下面的每个测试用例，生成指定的时间序列，按所述方式进行划分，使用上述定义计算 $E$，并输出结果。\n\n约定和边界情况：\n- 在指定之处使用无偏估计量。\n- 在计算 $g$ 时，通过对 $\\rho(k)$ 求和来实现截断，求和仅持续到第一个 $\\rho(k) \\le 0$ 的延迟，并且绝不包括超过 $L-1$ 的延迟。\n- 如果 $\\sigma^2 = 0$ 或 $M  2$，为避免未定义操作，按约定定义 $E = 0.0$。\n- 所有随机数生成必须使用给定的种子以保证可复现性。\n\n测试套件：\n1. 一阶稳态自回归过程 (AR(1)): $x_k = \\phi x_{k-1} + \\xi_k$，其中 $\\phi = 0.8$，高斯噪声 $\\xi_k \\sim \\mathcal{N}(0,\\sigma_\\xi^2)$，$\\sigma_\\xi^2 = 1 - \\phi^2$ 以使稳态方差为 $1$。从 $\\mathcal{N}(0,1)$ 初始化 $x_1$。使用 $N = 10000$, $M = 20$，随机种子为 $12345$。\n2. 窗口内非遍历（分段均值）：具有中途均值漂移的独立高斯样本。具体来说，对于 $k \\le N/2$，$x_k \\sim \\mathcal{N}(-2, 0.2^2)$；对于 $k  N/2$，$x_k \\sim \\mathcal{N}(+2, 0.2^2)$。使用 $N = 10000$, $M = 20$，随机种子为 $24680$ 以保证高斯抽样的可复现性。\n3. 退化可观测量：恒定信号 $x_k \\equiv 3.14$。使用 $N = 5000$, $M = 10$。\n\n要求的最终输出格式：您的程序应生成单行输出，其中包含三个遍历性分数，以逗号分隔的列表形式包含在方括号中，每个值四舍五入到六位小数（例如，“[1.000000,2.345678,0.000000]”）。不应打印任何其他文本。", "solution": "问题陈述已经过分析并被确定为有效。它在科学上基于统计力学和时间序列分析的原理，特别是关于相关数据中统计误差的估计。该问题是适定的，所有必要的数学定义、参数和计算过程都已明确指定。它是客观的，没有会妨碍得出唯一、可验证解的歧义。\n\n任务是为三个不同的时间序列计算遍历性分数 $E$。该分数比较了观测到的块平均均值的方差 $s_\\mu^2$ 与基于稳态过程理论的模型预测的方差 $\\operatorname{Var}(\\mu_{\\text{block}}) \\approx \\frac{\\sigma^2 g}{L}$。$E \\approx 1$ 的分数表明，在观测窗口内，该轨迹的行为类似于来自稳态遍历过程的样本。与 $E=1$ 的偏差可能表示非稳态性或采样不佳。计算过程将通过精心实现问题陈述中提供的公式来进行。\n\n每个测试用例的总体流程如下：\n1.  根据指定的模型和参数生成时间序列 $\\{x_k\\}_{k=1}^N$。\n2.  处理指定的边界情况：如果段数 $M  2$ 或总方差 $\\sigma^2 = 0$，则分数 $E$ 定义为 $0.0$。\n3.  计算完整时间序列的基本统计量：样本均值 $\\mu = \\frac{1}{N}\\sum_{k=1}^N x_k$ 和无偏样本方差 $\\sigma^2 = \\frac{1}{N-1}\\sum_{k=1}^N (x_k - \\mu)^2$。\n4.  计算统计不等效性 $g$。这需要几个子步骤：\n    a.  计算延迟 $k$ 从 $0$ 到 $L-1$ 的样本自协方差函数 $C(k)$，其中 $L=N/M$ 是段长度。问题指定了无偏估计量 $C(k) = \\frac{1}{N-k}\\sum_{t=1}^{N-k} (x_t - \\mu)(x_{t+k} - \\mu)$。\n    b.  将自协方差归一化以获得自相关函数 $\\rho(k) = C(k)/C(0)$。注意 $C(0)$ 是使用 $k=0$ 的 $C(k)$ 公式计算的，这对应于有偏样本方差。\n    c.  确定截断延迟 $K^\\star$，其为满足对所有 $1 \\le k \\le K^\\star$ 都有 $\\rho(k)  0$ 的最大整数，且 $K^\\star \\le L-1$。\n    d.  使用公式 $g = 1 + 2\\sum_{k=1}^{K^\\star} \\rho(k)$ 计算 $g$。如果不存在这样的正延迟，则 $K^\\star=0$ 且 $g=1$。\n5.  计算块均值的方差 $s_\\mu^2$。\n    a.  将长度为 $N$ 的时间序列划分为 $M$ 个长度为 $L$ 的不重叠段。\n    b.  计算每个段 $i \\in \\{1, \\dots, M\\}$ 的均值 $\\mu_i$。\n    c.  计算这 $M$ 个段均值的无偏样本方差 $s_\\mu^2 = \\frac{1}{M-1}\\sum_{i=1}^M (\\mu_i - \\bar{\\mu})^2$，其中 $\\bar{\\mu}$ 是段均值的均值。\n6.  最后，使用提供的公式计算遍历性分数 $E$：$E = \\frac{s_\\mu^2}{\\sigma^2 g / L}$。\n\n将此流程应用于三个测试用例中的每一个。\n\n-   **测试用例 1 (AR(1) 过程)：** 生成一个稳态、遍历的自回归过程。对于此类过程，预测公式所基于的假设得到满足。因此，我们预期观测到的块均值方差会接近预测方差，从而得出遍历性分数 $E \\approx 1$。\n\n-   **测试用例 2 (分段均值)：** 通过连接两个均值截然不同的段来生成一个非稳态过程。这违反了稳态性假设。总方差 $\\sigma^2$ 会很大，主要由均值的跳跃决定。自相关将非常缓慢地衰减，导致 $g$ 值很大。块均值的方差 $s_\\mu^2$ 也会很大，因为一半的块具有低均值，另一半具有高均值。分数 $E$ 是这些量的比值。问题陈述指出 $E \\gg 1$ 表明非稳态性，但结果取决于观测到的块均值方差是大于还是小于通过形式上应用稳态过程公式预测的值。\n\n-   **测试用例 3 (退化可观测量)：** 生成一个恒定信号。对于这个平凡情况，数据的方差为零。根据问题的明确规则，由于 $\\sigma^2 = 0$，遍历性分数立即确定为 $E=0.0$。\n\n该实现将使用 `numpy` 库进行高效的数值计算，特别是用于生成随机变量、计算方差以及计算自协方差函数所需的相关和。将按指定的方式为随机数生成器设定种子，以确保可复现性。", "answer": "```python\nimport numpy as np\n\ndef calculate_ergodicity_score(x: np.ndarray, M: int) - float:\n    \"\"\"\n    Computes the ergodicity score E for a given time series.\n    \n    Args:\n        x (np.ndarray): The time series data.\n        M (int): The number of segments to partition the data into.\n        \n    Returns:\n        float: The calculated ergodicity score E.\n    \"\"\"\n    N = len(x)\n\n    # Per problem statement conventions for M  2\n    if M  2:\n        return 0.0\n\n    L = N // M\n    if L == 0:\n        # This case implies N  M, which is not in the test suite.\n        # But for robustness, we can handle it. s_mu^2 would be ill-defined.\n        return 0.0\n        \n    # Calculate unbiased sample variance of the entire trajectory\n    # This is sigma^2\n    sigma_sq = np.var(x, ddof=1)\n    \n    # Per problem statement conventions for sigma^2 = 0\n    if sigma_sq == 0.0:\n        return 0.0\n\n    # Calculate the statistical inefficiency g\n    mu = np.mean(x)\n    y = x - mu\n    \n    # Use numpy.correlate to get sums for autocovariance calculation\n    # The result `corr_sum` has length 2*N - 1.\n    # The item at index (N-1) corresponds to lag 0.\n    # The item at index (N-1+k) corresponds to lag k.\n    corr_sum = np.correlate(y, y, mode='full')\n    \n    # C(k) = (1/(N-k)) * sum_{t=1}^{N-k} (x_t-mu)(x_{t+k}-mu)\n    # C(0) is calculated with k=0, so denominator is N. This is the biased variance.\n    c0 = corr_sum[N - 1] / N\n    \n    g = 1.0\n    if c0 > 0:\n        # Sum rho(k) according to the initial-positive-sequence rule.\n        # The maximum lag to consider for the sum is K_star = L-1.\n        for k in range(1, L):\n            # C(k) is an unbiased estimator, so we divide by (N-k)\n            ck = corr_sum[N - 1 + k] / (N - k)\n            rho_k = ck / c0\n            if rho_k > 0:\n                g += 2.0 * rho_k\n            else:\n                # Truncate sum at the first non-positive rho(k)\n                break\n    \n    # Calculate the unbiased sample variance of the segment means, s_mu^2\n    segments = x.reshape((M, L))\n    segment_means = np.mean(segments, axis=1)\n    s_mu_sq = np.var(segment_means, ddof=1)\n    \n    # Calculate the predicted variance of the block mean\n    predicted_var = (sigma_sq * g) / L\n    \n    if predicted_var == 0.0:\n        # This is unlikely if sigma_sq > 0, g >= 1, L > 0.\n        # If it happens, E could be inf or nan. Returning 0.0 is a safe fallback.\n        return 0.0\n\n    # Calculate the final ergodicity score E\n    E = s_mu_sq / predicted_var\n    \n    return E\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # (N, M, generator_func, seed)\n        (10000, 20, 'ar1', 12345),\n        (10000, 20, 'piecewise', 24680),\n        (5000, 10, 'constant', None),\n    ]\n\n    results = []\n    \n    for N, M, generator_type, seed in test_cases:\n        rng = np.random.default_rng(seed)\n        x = np.zeros(N)\n\n        if generator_type == 'ar1':\n            phi = 0.8\n            sigma_xi_sq = 1 - phi**2\n            sigma_xi = np.sqrt(sigma_xi_sq)\n            \n            # Initialize from stationary distribution N(0, 1)\n            x[0] = rng.normal(loc=0.0, scale=1.0)\n            noise = rng.normal(loc=0.0, scale=sigma_xi, size=N-1)\n            for k in range(1, N):\n                x[k] = phi * x[k-1] + noise[k-1]\n\n        elif generator_type == 'piecewise':\n            half_n = N // 2\n            mean1, mean2 = -2.0, 2.0\n            std_dev = 0.2\n            \n            x[:half_n] = rng.normal(loc=mean1, scale=std_dev, size=half_n)\n            x[half_n:] = rng.normal(loc=mean2, scale=std_dev, size=N - half_n)\n\n        elif generator_type == 'constant':\n            x[:] = 3.14\n\n        E = calculate_ergodicity_score(x, M)\n        results.append(E)\n\n    # Format the output as specified\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2462952"}]}