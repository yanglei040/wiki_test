{"hands_on_practices": [{"introduction": "配分函数 $Z$ 是统计力学的基石，它构成了连接系统微观量子能级与宏观热力学性质的数学桥梁。本练习将通过一个最简单却也最重要的量子模型——一维无限深势阱中的粒子——来探索这一基本联系。通过数值计算量子配分函数并将其与经典对应物进行比较，你将直接观察到离散的量子世界如何平滑地过渡到连续的经典极限，这是对对应原理的一个完美诠释。[@problem_id:2463653]", "problem": "考虑一个被限制在长度为 $L$、具有完全刚性壁的一维（1D）无限深势阱中的单个无相互作用的量子粒子。在温度为 $T$ 的正则系综中，微观状态的能量由正整数 $n$ 标记。您的任务是通过计算正则配分函数，并将精确的量子结果与其经典（高温）极限进行比较，从而将微观能谱与宏观热力学行为联系起来。\n\n要求和基础：\n- 在正则系综中使用 Boltzmann 分布，其中正则配分函数定义为 $Z = \\sum_{i} e^{-\\beta E_{i}}$，其中 $\\beta = 1/(k_{\\mathrm{B}} T)$，$k_{\\mathrm{B}}$ 是 Boltzmann 常数。\n- 对于长度为 $L$ 的一维无限深势阱中的粒子，其能量本征值是一个经过充分检验的结果：$E_{n} = \\dfrac{n^{2} h^{2}}{8 m L^{2}}$，其中 $n = 1, 2, 3, \\dots$，$h$ 是 Planck 常数，$m$ 是粒子质量。\n- 从第一性原理出发，通过位置和动量的相空间积分并使用标准相空间元体积量子 $h$ 来推导配分函数的经典对应物，即 $Z_{\\mathrm{cl}} = \\dfrac{1}{h} \\int_{0}^{L} \\int_{-\\infty}^{\\infty} \\exp\\!\\left(-\\beta \\dfrac{p^{2}}{2m}\\right) \\, \\mathrm{d}p \\, \\mathrm{d}x$。在建立此积分时，不要近似量子能谱；仅应用适用于经典极限的连续介质方法。\n\n您的程序必须执行的算法任务：\n1. 实现量子配分函数的数值稳定计算\n   $$Z_{\\mathrm{q}}(m,L,T) = \\sum_{n=1}^{\\infty} \\exp\\!\\left(-\\beta \\dfrac{n^{2} h^{2}}{8 m L^{2}}\\right).$$\n   通过自适应地截断无限级数，即累加项直到下一项小于预设的容差。确保您的截断逻辑基于正项的单调递减性是合理的，并且它能避免在 $T$ 较小或较大时不必要的计算。\n2. 从上述经典相空间积分出发，进行符号推导，以获得经典配分函数 $Z_{\\mathrm{cl}}(m,L,T)$ 的闭合形式表达式，您的程序将对其进行数值计算。始终使用国际单位制（SI）：$m$ 单位为 $\\mathrm{kg}$，$L$ 单位为 $\\mathrm{m}$，$T$ 单位为 $\\mathrm{K}$，$h$ 单位为 $\\mathrm{J\\,s}$，$k_{\\mathrm{B}}$ 单位为 $\\mathrm{J/K}$。配分函数是无量纲的。\n3. 对于每个测试用例，计算相对偏差\n   $$\\delta = \\dfrac{Z_{\\mathrm{q}} - Z_{\\mathrm{cl}}}{Z_{\\mathrm{cl}}}.$$\n   将 $\\delta$ 报告为一个四舍五入到 $6$ 位小数的浮点数。\n\n常数：\n- 使用 $k_{\\mathrm{B}} = 1.380649\\times 10^{-23}\\ \\mathrm{J/K}$ 和 $h = 6.62607015\\times 10^{-34}\\ \\mathrm{J\\,s}$。\n\n测试套件（请精确使用这些值）：\n- 案例 $1$（正常路径，中等量子化）：$m = 9.1093837015\\times 10^{-31}\\ \\mathrm{kg}$, $L = 1.0\\times 10^{-9}\\ \\mathrm{m}$, $T = 300\\ \\mathrm{K}$。\n- 案例 $2$（高温经典极限）：$m = 9.1093837015\\times 10^{-31}\\ \\mathrm{kg}$, $L = 1.0\\times 10^{-9}\\ \\mathrm{m}$, $T = 1.0\\times 10^{7}\\ \\mathrm{K}$。\n- 案例 $3$（较重粒子，在环境条件下更接近经典）：$m = 6.6335209\\times 10^{-26}\\ \\mathrm{kg}$, $L = 1.0\\times 10^{-9}\\ \\mathrm{m}$, $T = 300\\ \\mathrm{K}$。\n- 案例 $4$（较小盒子，在高温下量子化更强）：$m = 9.1093837015\\times 10^{-31}\\ \\mathrm{kg}$, $L = 2.0\\times 10^{-10}\\ \\mathrm{m}$, $T = 1000\\ \\mathrm{K}$。\n\n附加数值要求：\n- 为截断量子级数实现一个绝对容差；求和的截断点应使得第一个被忽略的项严格小于 $10^{-12}$。\n- 通过识别自然指数中指数小于 $-700$ 的项在双精度下实际上为零，来防止数值下溢。\n- 所有计算必须如上所述，使用国际单位制（SI）进行。\n\n最终输出格式：\n- 您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表，其中每个条目是相应测试用例的 $\\delta$ 值，四舍五入到 $6$ 位小数。例如，格式必须为 $[x_{1},x_{2},x_{3},x_{4}]$，其中每个 $x_{i}$ 是一个小数点后有 $6$ 位数字的十进制数。", "solution": "我们从统计力学中的正则系综开始，这是计算化学中连接微观能级与宏观热力学性质的基础。Boltzmann 分布将概率 $p_{i} = e^{-\\beta E_{i}}/Z$ 分配给微观态 $i$，其中正则配分函数定义为\n$$\nZ = \\sum_{i} e^{-\\beta E_{i}}, \\quad \\beta = \\dfrac{1}{k_{\\mathrm{B}} T}.\n$$\n配分函数是无量纲的，并提供了与宏观量（如 Helmholtz 自由能 $A = -k_{\\mathrm{B}} T \\ln Z$）的核心联系。\n\n微观模型：一个长度为 $L$、具有完全刚性壁的一维（1D）无限深势阱，其定态能量本征值为\n$$\nE_{n} = \\dfrac{n^{2} h^{2}}{8 m L^{2}}, \\quad n = 1, 2, 3, \\dots,\n$$\n这是通过求解具有 Dirichlet 边界条件的定态 Schrödinger 方程得到的标准结果。因此，量子正则配分函数为\n$$\nZ_{\\mathrm{q}}(m,L,T) = \\sum_{n=1}^{\\infty} \\exp\\!\\left(-\\beta \\dfrac{n^{2} h^{2}}{8 m L^{2}}\\right).\n$$\n定义 $a = \\beta h^{2}/(8 m L^{2})$。被加项是 $e^{-a n^{2}}$，对于 $a  0$，它关于 $n$ 是严格为正且严格递减的。这种单调性证明了当第一个被忽略的项低于指定的容差 $\\varepsilon$ 时截断无限级数是合理的，因为此时级数尾部可以通过积分判别法来界定：\n$$\n\\sum_{n=N+1}^{\\infty} e^{-a n^{2}} \\le \\int_{N}^{\\infty} e^{-a x^{2}} \\, \\mathrm{d}x = \\dfrac{1}{2}\\sqrt{\\dfrac{\\pi}{a}}\\, \\mathrm{erfc}\\!\\big(\\sqrt{a}\\, N\\big),\n$$\n因此选择使 $e^{-a N^{2}}  \\varepsilon$ 的 $N$ 可以确保尾部很小。一个高效的实用截断点是\n$$\nN = \\left\\lceil \\sqrt{\\dfrac{\\ln(1/\\varepsilon)}{a}} \\right\\rceil,\n$$\n这保证了 $e^{-a N^{2}} \\le \\varepsilon$。在浮点运算中，指数小于 $-700$ 的项在双精度下实际上为零，所以我们也将其视为零。\n\n经典极限：在高温极限下，离散的量子能级变得密集，经典配分函数从使用 Liouville 测度和相空间元体积量子 $h$ 的相空间积分中得出：\n$$\nZ_{\\mathrm{cl}} = \\dfrac{1}{h} \\int_{0}^{L} \\int_{-\\infty}^{\\infty} \\exp\\!\\left(-\\beta \\dfrac{p^{2}}{2m}\\right) \\, \\mathrm{d}p \\, \\mathrm{d}x.\n$$\n位置积分得到 $\\int_{0}^{L} \\mathrm{d}x = L$。动量积分是一个标准的高斯积分：\n$$\n\\int_{-\\infty}^{\\infty} \\exp\\!\\left(-\\beta \\dfrac{p^{2}}{2m}\\right) \\, \\mathrm{d}p = \\sqrt{\\dfrac{2 \\pi m}{\\beta}} = \\sqrt{2 \\pi m k_{\\mathrm{B}} T}.\n$$\n因此，一维经典平动配分函数是\n$$\nZ_{\\mathrm{cl}}(m,L,T) = \\dfrac{L}{h} \\sqrt{2 \\pi m k_{\\mathrm{B}} T}.\n$$\n这个结果在量子能级间距与 $k_{\\mathrm{B}} T$ 相比可以忽略不计的情况下有效。微观到宏观的联系是明确的：$Z_{\\mathrm{q}}$ 是对微观能级的求和，而 $Z_{\\mathrm{cl}}$ 是一个连续相空间测度，当 $T$ 很大或 $m$ 和 $L$ 使能级间距很小时，它可以近似这个求和。\n\n渐近一致性：级数 $\\sum_{n=1}^{\\infty} e^{-a n^{2}}$ 与 Jacobi theta 函数有关。使用 Poisson 求和公式或 theta 函数的模性质，可以找到高温（小 $a$）下的渐近展开式\n$$\n\\sum_{n=1}^{\\infty} e^{-a n^{2}} = \\dfrac{1}{2} \\sqrt{\\dfrac{\\pi}{a}} - \\dfrac{1}{2} + \\mathcal{O}\\!\\left(e^{-\\pi^{2}/a}\\right).\n$$\n当 $a = \\beta h^{2}/(8 m L^{2})$ 时，其首项给出\n$$\n\\sum_{n=1}^{\\infty} e^{-a n^{2}} \\sim \\dfrac{1}{2} \\sqrt{\\dfrac{\\pi}{a}} = \\dfrac{L}{h} \\sqrt{2 \\pi m k_{\\mathrm{B}} T} = Z_{\\mathrm{cl}}(m,L,T),\n$$\n因此当 $T \\to \\infty$ 时 $Z_{\\mathrm{q}} \\to Z_{\\mathrm{cl}}$，这验证了从微观到宏观的过渡。\n\n数值算法设计：\n- 每个案例的输入：$(m, L, T)$，单位为国际单位制。常数：$k_{\\mathrm{B}} = 1.380649\\times 10^{-23}\\ \\mathrm{J/K}$，$h = 6.62607015\\times 10^{-34}\\ \\mathrm{J\\,s}$。\n- 计算 $\\beta = 1/(k_{\\mathrm{B}} T)$ 和 $a = \\beta h^{2}/(8 m L^{2})$。\n- 选择容差 $\\varepsilon = 10^{-12}$。设置\n  $$\n  N = \\max\\!\\left(1,\\ \\left\\lceil \\sqrt{\\dfrac{\\ln(1/\\varepsilon)}{a}} \\right\\rceil \\right),\n  $$\n  这确保了第一个被忽略的项低于容差。如果需要，可以为 $N$ 设置上限；对于所提供的测试套件，$N$ 保持在适度的大小（百的数量级）。\n- 计算\n  $$\n  Z_{\\mathrm{q}} = \\sum_{n=1}^{N} e^{-a n^{2}},\n  $$\n  跳过指数低于 $-700$ 的项以避免下溢。\n- 计算\n  $$\n  Z_{\\mathrm{cl}} = \\dfrac{L}{h} \\sqrt{2 \\pi m k_{\\mathrm{B}} T}.\n  $$\n- 计算相对偏差\n  $$\n  \\delta = \\dfrac{Z_{\\mathrm{q}} - Z_{\\mathrm{cl}}}{Z_{\\mathrm{cl}}}.\n  $$\n- 将 $\\delta$ 四舍五入到 $6$ 位小数。\n- 对给定的四个测试用例重复此过程。\n\n测试套件原理说明：\n- 案例 1 测试了在环境温度下，纳米盒子中电子的中等量子区域。\n- 案例 2 探测高温极限以确认 $Z_{\\mathrm{q}} \\approx Z_{\\mathrm{cl}}$。\n- 案例 3 使用一个更重的粒子（氩原子），在相同的 $L$ 和 $T$ 条件下，经典行为更容易出现。\n- 案例 4 采用更小的盒子和升高的温度来测试强量子化和求和的数值稳定性。\n\n最终程序将计算并打印单行输出，格式为 $[\\delta_{1},\\delta_{2},\\delta_{3},\\delta_{4}]$，其中每个值都四舍五入到 $6$ 位小数，$\\delta_{i}$ 是第 $i$ 个测试用例的相对偏差。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Physical constants (SI)\nk_B = 1.380649e-23      # Boltzmann constant in J/K\nh = 6.62607015e-34      # Planck constant in J*s\n\ndef quantum_partition_1d_box(m, L, T, tol=1e-12):\n    \"\"\"\n    Compute the quantum canonical partition function for a particle in a 1D infinite well:\n        Z_q = sum_{n=1}^\\infty exp(-beta * n^2 * h^2 / (8 m L^2))\n    using an adaptive truncation where the first neglected term is  tol.\n\n    Parameters:\n        m : mass in kg\n        L : length in m\n        T : temperature in K\n        tol : absolute tolerance for truncation\n\n    Returns:\n        Z_q : float\n    \"\"\"\n    if T == 0.0:\n        # Physically undefined; here return 0 to avoid division by zero in beta\n        return 0.0\n\n    beta = 1.0 / (k_B * T)\n    a = beta * h * h / (8.0 * m * L * L)\n\n    if a == 0.0:\n        # Degenerate case; treat as zero spacing -> diverging sum; not expected in test suite\n        return np.inf\n\n    # Determine cutoff N such that exp(-a * N^2)  tol\n    # If ln(1/tol)/a is very small, ensure N at least 1\n    target = np.log(1.0 / tol) / a\n    if target = 1.0:\n        N = 1\n    else:\n        N = int(np.ceil(np.sqrt(target)))\n\n    # Safety cap to prevent accidental huge loops (not expected to trigger for given cases)\n    N = min(N, 2_000_000)\n\n    # Sum terms, skipping those that underflow in double precision (exp(-x) ~ 0 for x > ~ 700)\n    Z_q = 0.0\n    # For efficiency, sum in blocks using vectorization when N is moderate\n    # But also handle underflow to avoid unnecessary exponent evaluations\n    n_values = np.arange(1, N + 1, dtype=np.float64)\n    exponents = -a * n_values * n_values\n    # Mask out underflow-prone terms\n    mask = exponents > -700.0\n    if np.any(mask):\n        Z_q = float(np.exp(exponents[mask]).sum())\n    else:\n        Z_q = 0.0\n\n    return Z_q\n\ndef classical_partition_1d(m, L, T):\n    \"\"\"\n    Classical 1D translational partition function:\n        Z_cl = (L/h) * sqrt(2 * pi * m * k_B * T)\n    \"\"\"\n    if T == 0.0:\n        return 0.0\n    return (L / h) * np.sqrt(2.0 * np.pi * m * k_B * T)\n\ndef relative_deviation(m, L, T, tol=1e-12):\n    Z_q = quantum_partition_1d_box(m, L, T, tol=tol)\n    Z_cl = classical_partition_1d(m, L, T)\n    if Z_cl == 0.0:\n        # Avoid division by zero; define deviation as 0 if both zero else +/-inf\n        if Z_q == 0.0:\n            return 0.0\n        else:\n            return float('inf') if Z_q > 0.0 else float('-inf')\n    return (Z_q - Z_cl) / Z_cl\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (m [kg], L [m], T [K])\n    test_cases = [\n        (9.1093837015e-31, 1.0e-9, 300.0),        # Case 1\n        (9.1093837015e-31, 1.0e-9, 1.0e7),        # Case 2\n        (6.6335209e-26,   1.0e-9, 300.0),         # Case 3\n        (9.1093837015e-31, 2.0e-10, 1000.0),      # Case 4\n    ]\n\n    results = []\n    for m, L, T in test_cases:\n        delta = relative_deviation(m, L, T, tol=1e-12)\n        # Round to 6 decimal places as required\n        if np.isfinite(delta):\n            results.append(f\"{delta:.6f}\")\n        else:\n            # Represent infinities explicitly if they occur (not expected here)\n            results.append(\"inf\" if delta > 0 else \"-inf\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2463653"}, {"introduction": "配分函数提供了理论基础，而分子模拟则提供了原始数据：粒子随时间变化的位置和速度。一个关键的挑战是如何从这些微观信息中提取宏观热力学量，例如熵。本实践介绍了一种直接而直观的方法——空间分箱（spatial binning）——通过粗粒化的概率分布来处理系统状态，从而根据一组粒子坐标计算构型熵。这个练习将熵的概念植根于粒子在空间中的具体排列，从而使其不再神秘。[@problem_id:2463576]", "problem": "一个处于热平衡状态的简单液体的二维粗粒化描述通过玻尔兹曼框架将微观粒子位置分布与宏观构型熵联系起来。考虑一个边长为 $L_x$ 和 $L_y$ (单位为 $\\mathrm{nm}$) 的正方形或矩形模拟盒子，它被划分为一个由 $n_x \\times n_y$ 个矩形箱格组成的均匀网格。一次模拟提供了 $F$ 个快照（帧），每个快照包含 $N$ 个粒子位置 $\\{(x_{j,f}, y_{j,f})\\}$，其中 $j \\in \\{1,\\dots,N\\}$，$f \\in \\{1,\\dots,F\\}$，且 $x_{j,f} \\in [0,L_x]$ 和 $y_{j,f} \\in [0,L_y]$ 的单位为 $\\mathrm{nm}$。假设粒子是不可区分的，采样处于平衡状态，并且在单粒子位置分布的层面上是独立的，这样为了估计粗粒化的、基于单粒子的构型熵，多体关联被忽略。施加了周期性边界条件 (PBC)。\n\n对于每个箱格 $i$，通过计算落入该箱格的所有帧中的粒子实例数，并除以总实例数 $N F$，来定义经验单粒子位置概率质量 $p_i$。在周期性边界条件和箱格离散化下，使用箱格宽度 $\\Delta x = L_x/n_x$ 和 $\\Delta y = L_y/n_y$ 根据以下规则将位置为 $(x,y)$ 的粒子分配到箱格索引 $(i_x,i_y)$：\n- $i_x = \\lfloor x / \\Delta x \\rfloor$ 且 $i_y = \\lfloor y / \\Delta y \\rfloor$，\n- 如果 $x = L_x$ 则设置 $i_x = n_x - 1$；如果 $y = L_y$ 则设置 $i_y = n_y - 1$，\n- 对于恰好位于内部箱格边界上的 $x$ 或 $y$（即 $x = m \\Delta x$，其中 $m$ 为整数且 $0  x  L_x$，或 $y$ 的情况类似），该点属于沿该轴索引较大的箱格，\n- $i_x \\in \\{0,\\dots,n_x-1\\}$，$i_y \\in \\{0,\\dots,n_y-1\\}$。\n\n使用玻尔兹曼常数 $k_\\mathrm{B} = 1.380649 \\times 10^{-23}\\ \\mathrm{J}\\ \\mathrm{K}^{-1}$ 和自然对数，从第一性原理计算该 $N$ 粒子系统的粗粒化构型熵，并以 $\\mathrm{J}\\ \\mathrm{K}^{-1}$ 为单位表示。将 $p_i = 0$ 的箱格对总和的贡献视为 $0$。所有结果必须以 $\\mathrm{J}\\ \\mathrm{K}^{-1}$ 为单位报告。\n\n您的程序必须为以下每个测试用例评估熵。在所有情况下，坐标和盒子长度的单位均为 $\\mathrm{nm}$；不涉及角度。对于每个用例，除非另有说明，否则 $F=1$，且所有帧都包含相同的 $N$。\n\n- 测试用例 1 (箱格均匀占据):\n  - $L_x = 2.0$, $L_y = 2.0$, $n_x = 2$, $n_y = 2$, $F = 1$, $N = 4$。\n  - 第 1 帧位置：$(0.5, 0.5)$, $(1.5, 0.5)$, $(0.5, 1.5)$, $(1.5, 1.5)$。\n\n- 测试用例 2 (所有粒子在一个箱格中):\n  - $L_x = 2.0$, $L_y = 2.0$, $n_x = 2$, $n_y = 2$, $F = 1$, $N = 4$。\n  - 第 1 帧位置：$(0.25, 0.25)$, $(0.25, 0.25)$, $(0.25, 0.25)$, $(0.25, 0.25)$。\n\n- 测试用例 3 (两个箱格等可能占据):\n  - $L_x = 2.0$, $L_y = 2.0$, $n_x = 2$, $n_y = 2$, $F = 1$, $N = 4$。\n  - 第 1 帧位置：$(0.25, 0.25)$, $(0.25, 0.25)$, $(1.75, 1.75)$, $(1.75, 1.75)$。\n\n- 测试用例 4 (周期性边界条件下的箱格边缘和边界处理):\n  - $L_x = 1.0$, $L_y = 1.0$, $n_x = 2$, $n_y = 2$, $F = 1$, $N = 4$。\n  - 第 1 帧位置：$(0.5, 0.25)$, $(0.25, 0.5)$, $(1.0, 0.75)$, $(0.75, 1.0)$。\n\n- 测试用例 5 (矩形盒子、非方形网格、不均匀占据):\n  - $L_x = 3.0$, $L_y = 1.0$, $n_x = 3$, $n_y = 1$, $F = 1$, $N = 3$。\n  - 第 1 帧位置：$(0.25, 0.5)$, $(0.75, 0.5)$, $(1.25, 0.5)$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含五个测试用例的熵，格式为方括号内以逗号分隔的列表，例如 $[e_1,e_2,e_3,e_4,e_5]$。\n- 每个 $e_i$ 都必须是科学记数法表示的浮点数，小数点后恰好有六位数字，使用小写字母 $e$ 表示指数，并且必须代表以 $\\mathrm{J}\\ \\mathrm{K}^{-1}$ 为单位的熵。\n- 单个值的所需格式示例：$7.000000\\mathrm{e}{-23}$。\n\n要求的输出是实数 (浮点数)。", "solution": "所提出的问题是计算统计力学中一个有效的练习。它要求根据模拟的粒子坐标计算简单液体的粗粒化构型熵。所有必要的参数和一个清晰但简化的物理模型均已提供。该问题具有科学依据、提法恰当且客观。我现在将提供解决方案。\n\n基本原理是熵的宏观热力学性质 $S$ 与系统微观状态之间的联系，这一联系由 Ludwig Boltzmann 建立并由 J. Willard Gibbs 推广。一个系统的熵是与给定宏观状态相对应的可及微观状态数量的度量。对于一个处于热平衡状态的系统，发现其处于某一特定微观状态的概率由玻尔兹曼分布给出。Gibbs 熵公式为一组概率为 $P_i$ 的状态 $\\{i\\}$ 上的任何概率分布提供了一个通用表达式：\n$$S = -k_{\\mathrm{B}} \\sum_{i} P_i \\ln P_i$$\n其中 $k_{\\mathrm{B}}$ 是玻尔兹曼常数，其值为 $k_{\\mathrm{B}} = 1.380649 \\times 10^{-23}\\ \\mathrm{J}\\ \\mathrm{K}^{-1}$。\n\n在这个问题中，我们不处理完整的微观相空间。相反，我们使用一种粗粒化表示，其中系统状态由粒子在有限数量的空间箱格中的分布来描述。该问题通过假设粒子是独立的来进一步简化模型。这是一个关键的简化，意味着我们忽略了显式的多体关联。在此假设下，$N$粒子系统的总构型熵 $S_N$ 可以近似为单粒子熵的总和。由于所有粒子都是不可区分的，它们共享相同的单粒子概率分布，因此也具有相同的单粒子熵 $S_1$。因此，系统的总熵是单粒子熵的 $N$ 倍：\n$$S_N = N \\cdot S_1 = -N k_{\\mathrm{B}} \\sum_{i} p_i \\ln p_i$$\n这里，求和是针对所有空间箱格 $i$，$p_i$ 是在箱格 $i$ 中找到单个特定粒子的概率。问题指出，概率为零（$p_i = 0$）的箱格对总和没有贡献，这与数学极限 $\\lim_{p\\to 0} p \\ln p = 0$ 一致。\n\n解决此问题的算法步骤如下：\n\n1.  **系统离散化**：对于每个测试用例，大小为 $L_x \\times L_y$ 的模拟盒子被划分为一个 $n_x \\times n_y$ 的网格。每个箱格的尺寸为 $\\Delta x = L_x / n_x$ 和 $\\Delta y = L_y / n_y$。\n\n2.  **数据统计**：必须将一个大小为 $n_x \\times n_y$ 的二维数组（或直方图）初始化为零，以存储每个箱格的粒子计数。我们遍历所有 $F$ 帧以及每帧中的所有 $N$ 个粒子。对于每个粒子位置 $(x, y)$，我们使用指定的规则确定其对应的箱格索引 $(i_x, i_y)$：\n    - 一般规则基于向下取整函数：$i_x = \\lfloor x / \\Delta x \\rfloor$ 和 $i_y = \\lfloor y / \\Delta y \\rfloor$。\n    - 这个规则正确处理了内部箱格的边界，因为边界 $x=m\\Delta x$ 上的点被映射到箱格 $m$，与箱格 $m-1$ 相比，这是一个更高的索引。\n    - 必须处理 $x=L_x$ 和 $y=L_y$ 处的特殊边界条件，以防止索引越界。一个稳健的实现方法是将索引限制在其最大值：$i_x = \\min(n_x-1, \\lfloor x / \\Delta x \\rfloor)$ 和 $i_y = \\min(n_y-1, \\lfloor y / \\Delta y \\rfloor)$。\n    - 然后，已识别的箱格 $(i_x, i_y)$ 的计数加一。\n\n3.  **概率计算**：处理完所有粒子位置后，每个箱格中的计数代表了在该空间区域内观察到的粒子总数。单个粒子位于箱格 $i$ 的经验概率 $p_i$ 通过将箱格的计数除以粒子观测总数 $N_{\\text{total}} = N \\times F$ 计算得出。\n\n4.  **熵计算**：有了所有箱格的概率集合 $\\{p_i\\}$，我们计算总和 $\\sum_i p_i \\ln p_i$，其中只有 $p_i  0$ 的项有贡献。然后使用公式 $S_N = -N k_{\\mathrm{B}} \\sum_{i} p_i \\ln p_i$ 计算 $N$ 粒子系统的最终构型熵。\n\n让我们将此过程应用于一个示例，测试用例 1：\n- 参数：$L_x = 2.0$, $L_y = 2.0$, $n_x = 2$, $n_y = 2$, $F = 1$, $N = 4$。\n- 箱格尺寸：$\\Delta x = 2.0/2 = 1.0$，$\\Delta y = 2.0/2 = 1.0$。\n- 位置：$(0.5, 0.5)$, $(1.5, 0.5)$, $(0.5, 1.5)$, $(1.5, 1.5)$。\n- 分箱：\n    - $(0.5, 0.5) \\rightarrow i_x=0, i_y=0$。\n    - $(1.5, 0.5) \\rightarrow i_x=1, i_y=0$。\n    - $(0.5, 1.5) \\rightarrow i_x=0, i_y=1$。\n    - $(1.5, 1.5) \\rightarrow i_x=1, i_y=1$。\n- 计数：四个箱格中的每一个计数都为 1。\n- 概率：总观测数 $N \\times F = 4$。每个箱格的概率 $p_i = 1/4$。\n- 熵：有 4 个箱格的概率不为零。\n    $$S = -4 k_{\\mathrm{B}} \\sum_{i=1}^{4} \\left(\\frac{1}{4} \\ln \\frac{1}{4}\\right) = -4 k_{\\mathrm{B}} \\left(4 \\cdot \\frac{1}{4} \\cdot (-\\ln 4)\\right) = 4 k_{\\mathrm{B}} \\ln 4$$\n    $$S = 4 \\times (1.380649 \\times 10^{-23}) \\times \\ln(4) \\approx 7.656360 \\times 10^{-23}\\ \\mathrm{J}\\ \\mathrm{K}^{-1}$$\n\n这种对第一性原理的系统应用可以为所有指定的测试用例得出所需的结果。以下程序实现了这一逻辑。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem for all test cases and prints the formatted output.\n    \"\"\"\n    # Define Boltzmann's constant\n    K_B = 1.380649e-23  # J/K\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"Lx\": 2.0, \"Ly\": 2.0, \"nx\": 2, \"ny\": 2, \"N\": 4, \"F\": 1,\n            \"positions\": [(0.5, 0.5), (1.5, 0.5), (0.5, 1.5), (1.5, 1.5)]\n        },\n        {\n            \"Lx\": 2.0, \"Ly\": 2.0, \"nx\": 2, \"ny\": 2, \"N\": 4, \"F\": 1,\n            \"positions\": [(0.25, 0.25), (0.25, 0.25), (0.25, 0.25), (0.25, 0.25)]\n        },\n        {\n            \"Lx\": 2.0, \"Ly\": 2.0, \"nx\": 2, \"ny\": 2, \"N\": 4, \"F\": 1,\n            \"positions\": [(0.25, 0.25), (0.25, 0.25), (1.75, 1.75), (1.75, 1.75)]\n        },\n        {\n            \"Lx\": 1.0, \"Ly\": 1.0, \"nx\": 2, \"ny\": 2, \"N\": 4, \"F\": 1,\n            \"positions\": [(0.5, 0.25), (0.25, 0.5), (1.0, 0.75), (0.75, 1.0)]\n        },\n        {\n            \"Lx\": 3.0, \"Ly\": 1.0, \"nx\": 3, \"ny\": 1, \"N\": 3, \"F\": 1,\n            \"positions\": [(0.25, 0.5), (0.75, 0.5), (1.25, 0.5)]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        Lx, Ly, nx, ny = case[\"Lx\"], case[\"Ly\"], case[\"nx\"], case[\"ny\"]\n        N, F = case[\"N\"], case[\"F\"]\n        positions = case[\"positions\"]\n\n        # Calculate bin widths\n        dx = Lx / nx\n        dy = Ly / ny\n\n        # Initialize histogram for bin counts\n        counts = np.zeros((nx, ny), dtype=int)\n\n        # Populate histogram based on particle positions\n        for x, y in positions:\n            # The binning rule is robustly implemented by capping the index at nx-1 (or ny-1).\n            # This handles both internal edges (via floor) and the box boundary x=Lx (via min).\n            ix = min(nx - 1, int(np.floor(x / dx)))\n            iy = min(ny - 1, int(np.floor(y / dy)))\n            counts[ix, iy] += 1\n        \n        # Total number of particle instances across all frames\n        total_particle_instances = N * F\n        \n        # If there are no particles, entropy is zero.\n        if total_particle_instances == 0:\n            entropy = 0.0\n        else:\n            # Flatten the counts array and calculate probabilities\n            probabilities = counts.flatten() / total_particle_instances\n\n            # Calculate the sum part of the entropy formula: sum(p_i * ln(p_i))\n            # Only consider non-zero probabilities as lim_{p->0} p*ln(p) = 0\n            entropy_sum = np.sum(probabilities[probabilities > 0] * np.log(probabilities[probabilities > 0]))\n\n            # Calculate the final N-particle system entropy\n            # S = -N * k_B * sum(p_i * ln(p_i))\n            entropy = -N * K_B * entropy_sum\n\n        results.append(entropy)\n\n    # Format the results according to the specified output format.\n    formatted_results = [f\"{r:.6e}\" for r in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2463576"}, {"introduction": "前一个练习假设我们已有一组代表特定温度的粒子构型。但在计算机模拟中，这些构型是如何产生的呢？本实践将深入分子动力学的核心，实现一个 Nosé-Hoover 控温器，这是一种巧妙的确定性算法，旨在确保模拟系统正确地对正则系综进行抽样。通过模拟一个简谐振子并根据玻尔兹曼分布的预测来验证其统计特性，你将深入了解模拟如何维持恒定温度并生成符合物理现实的微观状态。[@problem_id:2463631]", "problem": "要求您编写一个完整的程序，模拟一个与单变量 Nosé–Hoover 温控器耦合的一维谐振子，并证明所生成的构型与约化单位下温度为 $T$ 的正则系综一致。所有量均采用约化单位，其中粒子质量 $m=1$、玻尔兹曼常数 $k_{\\mathrm{B}}=1$，因此温度 $T$ 与能量具有相同的单位。除这些约化单位外，不需要其他物理单位。\n\n该系统具有坐标 $x$、速度 $v$ 和温控器摩擦变量 $\\zeta$。势能为 $U(x) = \\tfrac{1}{2} k x^2$，其中 $k$ 为弹性系数。在这些约化单位下，单个 Nosé–Hoover 温控器的运动方程为（其中温控器质量参数为 $Q$）：\n- $\\dot{x} = v$,\n- $\\dot{v} = -k x - \\zeta v$,\n- $\\dot{\\zeta} = \\dfrac{v^2 - T}{Q}$。\n\n从非平衡初始条件 $x(0)=5$, $v(0)=0$, $\\zeta(0)=0$ 出发，您必须使用固定的时间步长 $dt$ 和四阶龙格－库塔方法对这些方程进行数值积分。丢弃前 $20\\%$ 的步数作为预烧（burn-in）阶段。从剩余的轨迹中，每隔 $10$ 步采样一次，以形成采样位置和速度的数组。将采样得到的数组表示为 $\\{x_i\\}$ 和 $\\{v_i\\}$。\n\n对于下面测试套件中的每组参数，您的程序必须计算以下诊断量，这些诊断量将微观采样与正则分布所预期的宏观系综属性联系起来：\n- 位置的样本方差 $\\mathrm{Var}(x)$ 和速度的样本方差 $\\mathrm{Var}(v)$。对于约化单位下的谐振子，根据正则系综，玻尔兹曼分布所蕴含的理论方差为 $\\sigma_x^2 = T/k$ 和 $\\sigma_v^2 = T$。定义相对误差 $e_x = \\left|\\mathrm{Var}(x)-\\sigma_x^2\\right|/\\sigma_x^2$ 和 $e_v = \\left|\\mathrm{Var}(v)-\\sigma_v^2\\right|/\\sigma_v^2$。\n- $x$ 和 $v$ 之间的经验皮尔逊相关系数。在位置和速度的正则分解下，该值应接近 $0$。\n- 位置的单样本柯尔莫哥洛夫－斯米尔诺夫统计量：用理论标准差对位置进行归一化，$z_i = x_i/\\sqrt{T/k}$，然后计算柯尔莫哥洛夫－斯米尔诺夫统计量\n$$\nD = \\max\\left\\{\\max_{1\\le i\\le n}\\left(\\frac{i}{n} - \\Phi(z_{(i)})\\right),\\ \\max_{1\\le i\\le n}\\left(\\Phi(z_{(i)}) - \\frac{i-1}{n}\\right)\\right\\},\n$$\n其中 $z_{(i)}$ 是排序后的归一化位置，$\\Phi$ 是标准正态分布的累积分布函数。此项检验用于测试采样的 $x$ 边际分布是否与正则系综预测的高斯分布一致。\n\n对于每组参数，返回一个布尔值，指示是否同时满足以下所有三个条件：\n- $e_x  0.15$ 且 $e_v  0.15$，\n- $|{\\rm Corr}(x,v)|  0.10$，\n- $D  0.12$。\n\n请明确地实现四阶龙格－库塔方法，不要使用任何随机温控器或速度重标方法；仅使用上述确定性的 Nosé–Hoover 方程。\n\n测试套件：\n请提供以下参数集 $(T, k, Q, dt, \\text{steps})$ 的结果：\n- 案例 $1$：$(1.0, 1.0, 1.0, 0.005, 60000)$，\n- 案例 $2$：$(0.5, 2.0, 1.0, 0.005, 60000)$，\n- 案例 $3$：$(1.5, 0.7, 1.0, 0.004, 60000)$。\n\n需遵循的数值细节和约定：\n- 所有情况均使用初始条件 $x(0)=5$, $v(0)=0$, $\\zeta(0)=0$。\n- 預烧（burn-in）比例为总步数的 $0.20$；此后每 $10$ 步采样一次。\n- 在预烧和降采样后，使用基于数据数组的无偏定义计算样本均值和方差。\n- 本问题不使用角度。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含按测试套件案例顺序排列的结果，形式为方括号内以逗号分隔的列表，且不含空格。例如，如果所有三个案例都通过，输出必须是\n[True,True,True]\n其中的布尔值为您的结果。", "solution": "本问题要求验证 Nosé–Hoover 温控器作为一种为一维谐振子生成符合正则系综构型的方法的有效性。这是计算统计力学中的一个基本练习。该过程包括对一个扩展系统的运动方程进行数值积分，然后从所得轨迹中计算特定的统计诊断量，以便与玻尔兹曼分布的理论预测进行比较。\n\n该扩展系统的状态由向量 $\\mathbf{y}(t) = [x(t), v(t), \\zeta(t)]^T$ 描述，其中 $x$ 是位置，$v$ 是速度，$\\zeta$ 是温控器的摩擦参数。其动力学由一个一阶常微分方程（ODE）组控制。在指定的约化单位（$m=1$, $k_{\\mathrm{B}}=1$）下，这些方程为：\n$$\n\\begin{cases}\n\\dot{x} = v \\\\\n\\dot{v} = -k x - \\zeta v \\\\\n\\dot{\\zeta} = \\dfrac{v^2 - T}{Q}\n\\end{cases}\n$$\n在此，$k$ 是谐振子势能 $U(x) = \\frac{1}{2} k x^2$ 的弹性系数，$T$ 是目标温度，$Q$ 是温控器质量参数，它控制温控器响应的时间尺度。\n\n为了数值求解该系统，我们采用四阶龙格－库塔（RK4）方法，这是一种稳健且广泛使用的数值积分器。对于一个通用 ODE 系统 $\\dot{\\mathbf{y}} = \\mathbf{f}(\\mathbf{y}, t)$，从时间 $t_n$ 的状态 $\\mathbf{y}_n$ 更新到时间 $t_{n+1} = t_n + dt$ 的状态 $\\mathbf{y}_{n+1}$ 由以下公式给出：\n$$\n\\begin{align*}\n\\mathbf{k}_1 = \\mathbf{f}(\\mathbf{y}_n, t_n) \\\\\n\\mathbf{k}_2 = \\mathbf{f}(\\mathbf{y}_n + \\frac{dt}{2} \\mathbf{k}_1, t_n + \\frac{dt}{2}) \\\\\n\\mathbf{k}_3 = \\mathbf{f}(\\mathbf{y}_n + \\frac{dt}{2} \\mathbf{k}_2, t_n + \\frac{dt}{2}) \\\\\n\\mathbf{k}_4 = \\mathbf{f}(\\mathbf{y}_n + dt \\mathbf{k}_3, t_n + dt) \\\\\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{dt}{6} (\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n\\end{align*}\n$$\n在我们的特定情况下，函数 $\\mathbf{f}$ 不显式依赖于时间 $t$。模拟从一个指定的非平衡状态开始：$x(0)=5$, $v(0)=0$, $\\zeta(0)=0$。\n\n模拟运行指定的总步数。轨迹的最初 $20\\%$ 构成“预烧”或平衡阶段，在此期间系统从其初始状态演化到目标正则分布。这些初始步骤将被丢弃。从剩余 $80\\%$ 的轨迹中，我们每隔 $10$ 步对状态进行采样，以减少数据点之间的序列相关性，从而得到样本集 $\\{x_i\\}$ 和 $\\{v_i\\}$。\n\n为了验证采样数据符合温度 $T$ 下的正则系综，我们计算三个诊断量：\n\n1.  **方差与能量均分定理**：对于处于热平衡状态的经典系统，能量均分定理指出，哈密顿量中的每个二次自由度对平均内能的贡献为 $\\frac{1}{2}k_{\\mathrm{B}}T$。对于我们的谐振子，动能为 $\\frac{1}{2}mv^2$，势能为 $\\frac{1}{2}kx^2$。在约化单位（$m=1, k_{\\mathrm{B}}=1$）下，这意味着 $\\langle \\frac{1}{2}v^2 \\rangle = \\frac{1}{2}T$ 和 $\\langle \\frac{1}{2}kx^2 \\rangle = \\frac{1}{2}T$。由于平均位置和平均速度必须为零，即 $\\langle x \\rangle = 0$ 和 $\\langle v \\rangle = 0$，理论方差为 $\\sigma_x^2 = \\langle x^2 \\rangle = T/k$ 和 $\\sigma_v^2 = \\langle v^2 \\rangle = T$。我们计算无偏样本方差 $\\mathrm{Var}(x)$ 和 $\\mathrm{Var}(v)$，以及它们的相对误差 $e_x = |\\mathrm{Var}(x) - \\sigma_x^2| / \\sigma_x^2$ 和 $e_v = |\\mathrm{Var}(v) - \\sigma_v^2| / \\sigma_v^2$。成功的热化要求这些误差很小。\n\n2.  **位置－速度相关性**：对于形式为 $H(x,v) = U(x) + K(v)$ 的哈密顿量，其正则概率密度函数为 $p(x,v) \\propto e^{-\\beta U(x)} e^{-\\beta K(v)}$，其中 $\\beta = 1/(k_{\\mathrm{B}}T)$。该分布函数可以分解，意味着位置和速度是统计独立的变量。因此，它们的理论相关系数为零。我们从样本中计算经验皮尔逊相关系数 $\\mathrm{Corr}(x,v)$；其绝对值应接近于零。\n\n3.  **位置分布**：位置 $x$ 的边际概率分布是均值为 $0$、方差为 $\\sigma_x^2 = T/k$ 的高斯（正态）分布。为了检验这个假设，我们对采样位置进行归一化，创建一个新变量 $z_i = x_i / \\sigma_x$，它应遵循标准正态分布 $\\mathcal{N}(0, 1)$。我们使用柯尔莫哥洛夫－斯米尔诺夫（KS）检验，将 $\\{z_i\\}$ 数据的经验累积分布函数（CDF）与标准正态分布的 CDF $\\Phi(z)$进行比较。KS 统计量 $D$ 是这两个 CDF 之间的最大绝对差。提供的具体计算公式是：\n    $$\n    D = \\max\\left\\{\\max_{1\\le i\\le n}\\left(\\frac{i}{n} - \\Phi(z_{(i)})\\right),\\ \\max_{1\\le i\\le n}\\left(\\Phi(z_{(i)}) - \\frac{i-1}{n}\\right)\\right\\}\n    $$\n    其中 $z_{(i)}$ 是排序后的歸一化位置，$n$ 是樣本數量。$D$ 值很小表示吻合度高。\n\n程序将遍历所提供的测试案例。对于每个案例，它将执行模拟、采样和诊断计算。最终会根据是否同时满足所有三个指定的数值阈值（$e_x, e_v  0.15$，$|\\mathrm{Corr}(x,v)|  0.10$ 和 $D  0.12$）来生成一个布尔结果。该实现将使用 `numpy` 进行数值数组和运算，并使用 `scipy.stats.norm.cdf` 来计算标准正态 CDF $\\Phi$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Main function to run simulations for all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # (T, k, Q, dt, steps)\n        (1.0, 1.0, 1.0, 0.005, 60000),\n        (0.5, 2.0, 1.0, 0.005, 60000),\n        (1.5, 0.7, 1.0, 0.004, 60000),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_simulation_and_analyze(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef derivatives(state, k, T, Q):\n    \"\"\"\n    Computes the time derivatives for the Nosé–Hoover system.\n    state: numpy array [x, v, zeta]\n    k: spring constant\n    T: target temperature\n    Q: thermostat mass parameter\n    Returns: numpy array [dx/dt, dv/dt, dzeta/dt]\n    \"\"\"\n    x, v, zeta = state\n    dxdt = v\n    dvdt = -k * x - zeta * v\n    dzetadt = (v**2 - T) / Q\n    return np.array([dxdt, dvdt, dzetadt])\n\ndef rk4_step(state, dt, k, T, Q):\n    \"\"\"\n    Performs a single 4th-order Runge–Kutta step.\n    state: current state vector [x, v, zeta]\n    dt: time step\n    k, T, Q: system parameters\n    Returns: new state vector\n    \"\"\"\n    k1 = derivatives(state, k, T, Q)\n    k2 = derivatives(state + 0.5 * dt * k1, k, T, Q)\n    k3 = derivatives(state + 0.5 * dt * k2, k, T, Q)\n    k4 = derivatives(state + dt * k3, k, T, Q)\n    new_state = state + (dt / 6.0) * (k1 + 2*k2 + 2*k3 + k4)\n    return new_state\n\ndef run_simulation_and_analyze(params):\n    \"\"\"\n    Runs a full simulation for one parameter set and computes diagnostics.\n    params: tuple (T, k, Q, dt, steps)\n    Returns: boolean indicating if all conditions are met.\n    \"\"\"\n    T, k, Q, dt, total_steps = params\n    \n    # Initial conditions\n    x0, v0, z0 = 5.0, 0.0, 0.0\n    state = np.array([x0, v0, z0])\n    \n    # Store trajectory history\n    x_history = np.zeros(total_steps)\n    v_history = np.zeros(total_steps)\n    \n    # Simulation loop\n    for i in range(total_steps):\n        x_history[i] = state[0]\n        v_history[i] = state[1]\n        state = rk4_step(state, dt, k, T, Q)\n        \n    # Apply burn-in and sampling\n    burn_in_steps = int(0.20 * total_steps)\n    sample_stride = 10\n    \n    x_samples = x_history[burn_in_steps::sample_stride]\n    v_samples = v_history[burn_in_steps::sample_stride]\n    \n    # --- Diagnostic Calculations ---\n    \n    # 1. Sample Variances and Relative Errors\n    var_x = np.var(x_samples, ddof=1)  # Unbiased sample variance\n    var_v = np.var(v_samples, ddof=1)\n    \n    theory_var_x = T / k\n    theory_var_v = T\n    \n    e_x = np.abs(var_x - theory_var_x) / theory_var_x\n    e_v = np.abs(var_v - theory_var_v) / theory_var_v\n    \n    # 2. Pearson Correlation Coefficient\n    corr_xv = np.corrcoef(x_samples, v_samples)[0, 1]\n    \n    # 3. Kolmogorov–Smirnov Statistic\n    n_samples = len(x_samples)\n    sigma_x_theory = np.sqrt(theory_var_x)\n    z_scores = x_samples / sigma_x_theory\n    z_sorted = np.sort(z_scores)\n    \n    cdf_empirical_upper = np.arange(1, n_samples + 1) / n_samples\n    cdf_empirical_lower = np.arange(0, n_samples) / n_samples\n    cdf_theoretical = norm.cdf(z_sorted)\n    \n    d_plus = np.max(cdf_empirical_upper - cdf_theoretical)\n    d_minus = np.max(cdf_theoretical - cdf_empirical_lower)\n    D_ks = np.max([d_plus, d_minus])\n\n    # --- Validation Check ---\n    \n    cond1 = (e_x  0.15) and (e_v  0.15)\n    cond2 = np.abs(corr_xv)  0.10\n    cond3 = D_ks  0.12\n    \n    return cond1 and cond2 and cond3\n\nsolve()\n```", "id": "2463631"}]}