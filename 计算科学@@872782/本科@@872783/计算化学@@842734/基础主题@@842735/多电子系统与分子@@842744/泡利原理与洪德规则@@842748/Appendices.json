{"hands_on_practices": [{"introduction": "将诸如 Aufbau 原理和洪特规则等基本原理转化为计算模型，是计算化学的核心实践之一。本练习将指导你编写一个程序，根据这些规则自动预测元素的电子排布，并通过与实验数据对比，揭示这些简化模型的适用范围及其局限性[@problem_id:2459984]。这个过程不仅能加深你对原子结构理论的理解，还能让你体会到理论模型在现实世界中的预测能力和挑战。", "problem": "您需要将泡利不相容原理、洪特规则和构造原理形式化为一个可计算模型，并用它来分析基态电子排布。设原子序数用 $Z \\in \\mathbb{Z}_{\\ge 0}$ 表示。一个亚层由主量子数 $n \\in \\mathbb{Z}_{\\ge 1}$ 和角量子数 $\\ell \\in \\{0,1,2,3\\}$（对应光谱学符号 $s,p,d,f$）指定。亚层 $(n,\\ell)$ 的容量为 $2(2\\ell+1)$ 个电子。构造原理根据 $n+\\ell$ 的严格递增顺序对亚层进行排序，若出现相同值则按较小的 $n$ 排序。电子遵循此顺序填充亚层，并遵守泡利不相容原理（每个空间轨道不超过 $2$ 个电子，等效于每个亚层不超过 $2(2\\ell+1)$ 个电子）。报告时，电子排布必须以光谱学顺序表示：按 $n$ 递增列出已占据的亚层，若 $n$ 相等，则按 $\\ell$ 以 $s,p,d,f$ 的顺序排列，使用 $n\\ell^{k}$ 形式的连续项，其中 $k$ 是该亚层的电子数。例如，一个闭合的类氖核记为 $1s^{2}\\ 2s^{2}\\ 2p^{6}$。\n\n洪特第一规则规定，对于任何部分填充的 $\\ell$ 亚层，在成对之前，通过在每个 $g=2\\ell+1$ 个简并轨道中各放入一个自旋平行的电子，可以得到最大数量的未成对电子。对于亚层占据数为 $k$ 的情况，该亚层中的未成对电子数为 $u(k,\\ell)=\\min\\{k,\\ 2g-k\\}$，其中 $g=2\\ell+1$。将“最外层部分填充亚层”定义为满足 $0  k  2(2\\ell+1)$ 的亚层中，具有最大主量子数 $n$ 的那一个，若 $n$ 相等，则按最大的 $\\ell$ 来区分。您的任务是编写一个程序，该程序接受一个原子序数的有序列表 $\\mathcal{T}$，并为每个 $Z \\in \\mathcal{T}$ 计算：(a) 一个布尔值 $b(Z)$，指示根据构造原理生成的“朴素”排布是否与提供的参考排布相匹配；(b) 集合 $\\mathcal{T}$ 中朴素排布首次与参考排布不符的最小原子序数 $Z_{\\min}$；以及 (c) 根据朴素排布，对两个特定原子序数 $Z=7$ 和 $Z=24$ 计算未成对电子数 $u_7$ 和 $u_{24}$。\n\n最终输出必须是一个包含以下所有值的单一列表：$[Z_{\\min}, b(Z_1), b(Z_2), \\dots, b(Z_{|\\mathcal{T}|}), u_7, u_{24}]$，其中 $Z_i$ 是 $\\mathcal{T}$ 中的第 $i$ 个元素。如果所有排布都匹配，则 $Z_{\\min}=-1$。测试集为 $\\mathcal{T}=[\\,0,1,2,7,10,18,19,20,21,24,29,30\\,]$。参考排布（去除所有空格和上标）为：$Z=0$: \"\"; $Z=1$: \"1s1\"; $Z=2$: \"1s2\"; $Z=7$: \"1s22s22p3\"; $Z=10$: \"1s22s22p6\"; $Z=18$: \"1s22s22p63s23p6\"; $Z=19$: \"1s22s22p63s23p64s1\"; $Z=20$: \"1s22s22p63s23p64s2\"; $Z=21$: \"1s22s22p63s23p63d14s2\"; $Z=24$: \"1s22s22p63s23p63d54s1\"; $Z=29$: \"1s22s22p63s23p63d104s1\"; $Z=30$: \"1s22s22p63s23p63d104s2\"。", "solution": "问题陈述已经过严格验证，被认为是科学可靠、定义明确且客观的。它提供了一套完整且一致的规则，用于将基于既定原理的原子电子排布“朴素”模型形式化为可计算模型，并将其预测结果与参考数据进行比较。该任务是计算化学中的一个标准练习，需要实现构造原理、泡利不相容原理和洪特第一规则。我们将开始进行形式化的解答。\n\n该解答基于以下物理原理和算法设计构建：\n\n**1. 亚层排序与构造原理**\n\n该模型的基础是构造原理，它规定了电子占据亚层的顺序。一个亚层由一对量子数唯一确定：主量子数 $n \\in \\mathbb{Z}_{\\ge 1}$ 和角量子数 $\\ell \\in \\{0, 1, ..., n-1\\}$。对于本问题，我们考虑 $\\ell \\in \\{0,1,2,3\\}$，它们对应于光谱学符号 $s,p,d,f$。\n\n填充顺序由马德隆规则确定：亚层按 $n+\\ell$ 之和的严格递增值排序。任何相等情况都通过选择 $n$ 值较小的亚层来解决。为了构建这个序列，我们为足够大的 $n$ 范围（例如，$n=1$ 到 $8$）生成亚层 $(n, \\ell)$，并根据键 $(n+\\ell, n)$ 对它们进行排序。这会产生众所周知的生活序列：\n$$1s, 2s, 2p, 3s, 3p, 4s, 3d, 4p, 5s, 4d, 5p, 6s, 4f, ...$$\n其中数字是 $n$，字母对应于 $\\ell=0,1,2,3$。\n\n**2. 电子填充算法与泡利原理**\n\n给定代表电子总数的原子序数 $Z$，我们按照前述的构造原理顺序填充亚层。通过将每个亚层 $(n,\\ell)$ 的容量限制为 $C(n,\\ell) = 2(2\\ell+1)$ 个电子来强制执行泡利不相容原理。\n\n该算法按以下步骤进行：\n- 我们从总共 $Z$ 个电子开始。\n- 我们遍历已排序的亚层列表。\n- 对每个亚层，我们计算其容量 $C(n,\\ell)$。\n- 放入该亚层的电子数 $k$ 是剩余电子数和亚层容量的最小值。\n- 我们从剩余电子数中减去 $k$，并记录占据情况 $(n, \\ell, k)$。\n- 这个过程一直持续到所有 $Z$ 个电子都被分配完毕。\n\n这个过程生成一组已占据亚层及其电子数，例如 $\\{(n_1, \\ell_1, k_1), (n_2, \\ell_2, k_2), ...\\}$。\n\n**3. 排布字符串生成**\n\n问题要求电子排布以“光谱学顺序”报告。这意味着已占据的亚层按主量子数 $n$ 递增列出，若 $n$ 相等，则按角量子数 $\\ell$ 递增列出。因此，已占据亚层的集合 $\\{(n_i, \\ell_i, k_i)\\}$ 必须按键 $(n, \\ell)$ 排序。\n\n然后将每个排序后的项 $(n, \\ell, k)$ 格式化为字符串 $n\\ell^k$，其中 $\\ell$ 被其对应的光谱学字母（$s,p,d,f$）替换。这些字符串被连接起来（不带空格）形成最终的排布字符串，例如 $1s^22s^22p^6$。对于 $Z=0$，排布是一个空字符串。\n\n**4. 洪特规则与未成对电子**\n\n洪特第一规则用于确定“最外层部分填充亚层”中的未成对电子数。\n- 首先，我们从计算出的朴素排布中识别出所有部分填充的亚层。如果一个亚层 $(n, \\ell)$ 的占据数 $k$ 满足 $0  k  C(n,\\ell)$，则该亚层是部分填充的。\n- 从这组部分填充的亚层中，我们找到“最外层”的那个，它被定义为具有最大 $n$ 的亚层，若 $n$ 相同则按最大的 $\\ell$ 来区分。\n- 如果不存在部分填充的亚层，则未成对电子数为 $0$。\n- 否则，对于确定的最外层亚层 $(n_{out}, \\ell_{out}, k_{out})$，未成对电子数 $u$ 由公式 $u(k, \\ell) = \\min\\{k, 2g - k\\}$ 给出，其中 $g = 2\\ell+1$ 是亚层中简并轨道的数量。因此，对于最外层亚层，我们计算 $u = \\min\\{k_{out}, 2(2\\ell_{out}+1) - k_{out}\\}$。\n\n**5. 分析与比较**\n\n所实现的算法用于对测试集 $\\mathcal{T}=[\\,0,1,2,7,10,18,19,20,21,24,29,30\\,]$ 执行所需任务。\n- 对于每个 $Z \\in \\mathcal{T}$，生成朴素排布字符串，并与提供的参考字符串（在去除空格进行标准化后）进行比较。结果存储为布尔值 $b(Z)$。\n- 将 $\\mathcal{T}$ 中朴素排布与参考排布不符的最小 $Z$ 识别为 $Z_{\\min}$。例如，对于 $Z=24$，朴素模型预测为 $...3d^44s^2$，而参考（实验）排布为 $...3d^54s^1$。这种不匹配的发生是因为简单的马德隆规则没有考虑半满和全满 $d$-亚层的额外稳定性。测试集中第一个此类异常出现在 $Z=24$，因此 $Z_{\\min}=24$。\n- 根据 $Z=7$ 和 $Z=24$ 各自的朴素排布，计算未成对电子数。\n    - 对于 $Z=7$（朴素排布为 $1s^22s^22p^3$），最外层部分填充亚层是 $2p^3$。此处，$n=2, \\ell=1, k=3$。未成对电子数为 $u_7 = \\min\\{3, 2(2(1)+1)-3\\} = \\min\\{3, 3\\} = 3$。\n    - 对于 $Z=24$（朴素排布为 $...3d^44s^2$），唯一部分填充的亚层是 $3d^4$。此处，$n=3, \\ell=2, k=4$。未成对电子数为 $u_{24} = \\min\\{4, 2(2(2)+1)-4\\} = \\min\\{4, 6\\} = 4$。\n\n然后将所有计算值汇总到由输出格式指定的单个列表中。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the computational chemistry problem by implementing the Aufbau principle,\n    Hund's rule, and comparing the resulting naive electron configurations to\n    reference data.\n    \"\"\"\n    \n    # Spectroscopy and constants\n    L_TO_CHAR = {0: 's', 1: 'p', 2: 'd', 3: 'f'}\n\n    # Reference data provided in the problem statement, with spaces and superscripts removed.\n    REFERENCE_CONFIGS = {\n        0: \"\",\n        1: \"1s1\",\n        2: \"1s2\",\n        7: \"1s22s22p3\",\n        10: \"1s22s22p6\",\n        18: \"1s22s22p63s23p6\",\n        19: \"1s22s22p63s23p64s1\",\n        20: \"1s22s22p63s23p64s2\",\n        21: \"1s22s22p63s23p63d14s2\",\n        24: \"1s22s22p63s23p63d54s1\",\n        29: \"1s22s22p63s23p63d104s1\",\n        30: \"1s22s22p63s23p63d104s2\",\n    }\n    \n    def generate_filling_order():\n        \"\"\"Generates the subshell filling order based on the Madelung (n+l, n) rule.\"\"\"\n        subshells = []\n        # Generate subshells up to n=8, which is sufficient for all known elements.\n        for n in range(1, 9):\n            for l in range(n):\n                if l in L_TO_CHAR:\n                    subshells.append({'n': n, 'l': l})\n        # Sort according to the Aufbau principle (n+l, then n)\n        subshells.sort(key=lambda s: (s['n'] + s['l'], s['n']))\n        return subshells\n\n    FILLING_ORDER = generate_filling_order()\n\n    def get_naive_config(Z):\n        \"\"\"\n        Calculates the naive electron configuration for a given atomic number Z.\n        Returns the configuration as a list of dictionaries and a formatted string.\n        \"\"\"\n        if Z == 0:\n            return [], \"\"\n\n        electrons_remaining = Z\n        occupied_subshells = []\n        \n        for subshell_template in FILLING_ORDER:\n            if electrons_remaining == 0:\n                break\n            \n            n, l = subshell_template['n'], subshell_template['l']\n            capacity = 2 * (2 * l + 1)\n            \n            electrons_to_add = min(electrons_remaining, capacity)\n            \n            occupied_subshells.append({'n': n, 'l': l, 'k': electrons_to_add})\n            electrons_remaining -= electrons_to_add\n\n        # Sort for spectroscopic notation (by n, then l)\n        occupied_subshells.sort(key=lambda s: (s['n'], s['l']))\n\n        # Generate the contiguous string representation\n        config_str = \"\".join([f\"{s['n']}{L_TO_CHAR[s['l']]}{s['k']}\" for s in occupied_subshells])\n        \n        return occupied_subshells, config_str\n\n    def get_unpaired_electrons(config):\n        \"\"\"\n        Calculates the number of unpaired electrons in the outermost partially\n        filled subshell according to Hund's rule.\n        \"\"\"\n        partially_filled = []\n        for sub in config:\n            n, l, k = sub['n'], sub['l'], sub['k']\n            capacity = 2 * (2 * l + 1)\n            if 0  k  capacity:\n                partially_filled.append(sub)\n        \n        if not partially_filled:\n            return 0\n\n        # Find the outermost subshell: sort by n descending, then l descending.\n        partially_filled.sort(key=lambda s: (s['n'], s['l']), reverse=True)\n        \n        outermost = partially_filled[0]\n        k_out, l_out = outermost['k'], outermost['l']\n        \n        # Apply Hund's rule formula: u(k,l) = min(k, 2*(2l+1) - k)\n        g = 2 * l_out + 1\n        return min(k_out, 2 * g - k_out)\n\n    # Main execution logic\n    test_suite = [0, 1, 2, 7, 10, 18, 19, 20, 21, 24, 29, 30]\n    \n    z_min = -1\n    b_values = []\n    \n    for z in test_suite:\n        _, naive_str = get_naive_config(z)\n        ref_str = REFERENCE_CONFIGS[z]\n        is_match = (naive_str == ref_str)\n        b_values.append(is_match)\n        \n        if not is_match and z_min == -1:\n            z_min = z\n\n    # Calculate specific unpaired electron counts\n    config_7, _ = get_naive_config(7)\n    u_7 = get_unpaired_electrons(config_7)\n    \n    config_24, _ = get_naive_config(24)\n    u_24 = get_unpaired_electrons(config_24)\n\n    # Assemble the final list of results for printing\n    final_results = [z_min] + b_values + [u_7, u_24]\n    \n    # Format the final output string exactly as specified\n    output_str = f\"[{','.join(map(str, final_results))}]\"\n    print(output_str)\n\nsolve()\n```", "id": "2459984"}, {"introduction": "洪特规则为确定多电子原子的基态能项符号提供了简洁的指导，但这些规则源于何处？本练习通过一个具体的编码任务，让你从第一性原理出发，通过枚举所有符合泡利不相容原理的微观量子态来验证洪特规则的预测[@problem_id:2459996]。通过这个实践，你将深刻理解宏观的能项符号（如 $^{4}S$）是如何从电子在轨道中的具体排布（微观态）中涌现出来的。", "problem": "您必须编写一个完整、可运行的程序，对于一个轨道角动量 $l=1$ 的 $p$ 型开放亚层，该程序使用第一性原理验证由最大总磁量子数 $M_L$ 和 $M_S$ 确定的状态，是否与洪特规则为 $p^3$ 构型预测的基态谱项符号相对应，并评估几个相关的 $p^n$ 情况。将每个微观态视为一组 $n$ 个不同单电子自旋轨道的集合，每个自旋轨道由一对 $(m_l,m_s)$ 标记，其中 $m_l \\in \\{-1,0,1\\}$ 且 $m_s \\in \\left\\{-\\tfrac{1}{2},+\\tfrac{1}{2}\\right\\}$。严格执行泡利不相容原理，即约束任意两个电子不能占据相同的 $(m_l,m_s)$ 对。对于任何有效的微观态，定义 $M_L=\\sum_i m_l^{(i)}$ 和 $M_S=\\sum_i m_s^{(i)}$。在 Russell–Saunders (LS) 耦合极限下，基态谱项符号由总自旋 $S$、总轨道角动量 $L$ 和总角动量 $J$ 来表征，通常写作 $^{2S+1}\\Lambda_J$，其中 $\\Lambda$ 是 $L$ 的字母代码（$L=0,1,2,3,\\dots$ 对应于 $S,P,D,F,\\dots$）。此处相关的洪特规则是：(i) 最大化 $S$；(ii) 对于未满半充满的亚层，选择最小的 $L$；对于超过半充满的亚层，选择最大的 $L$；对于恰好半充满的亚层（在 $p$ 亚层中为 $n=3$），具有最大 $S$ 的状态有 $L=0$；(iii) 对于给定的 $L$ 和 $S$，如果亚层未满半充满，则最低的 $J$ 为 $J=\\lvert L-S\\rvert$；如果亚层超过半充满，则最高的 $J$ 为 $J=L+S$；当 $L=0$ 时，$J=S$。\n\n您的程序必须针对每个指定的电子数 $n$，从所有有效微观态的集合中计算出可能的最大 $M_S$ 值（记为 $M_S^{\\max}$），然后在所有满足 $M_S=M_S^{\\max}$ 的微观态中，找出可能的最大 $M_L$ 值（记为 $M_L^{\\max}$）。将 $S=M_S^{\\max}$ 和 $L^{(\\text{micro})}=M_L^{\\max}$ 解释为一个谱项的最高权重标记。另外，应用洪特规则得到与该 $n$ 和相同的 $S$ 对应的基态谱项的 $L^{(\\text{Hund})}$。同时，根据洪特第三规则计算相应的 $J$。对于 $n=3$，此过程必须将基态谱项识别为 $^{4}S$，即 $2S+1=4$ 且 $L=0$。\n\n测试套件和要求输出：\n\n- 对 $p^n$ 亚层，使用由有序列表 $[\\,3,\\,1,\\,5,\\,2,\\,4,\\,0,\\,6\\,]$ 给出的电子数 $n$ 的测试套件。\n- 按该顺序为每个 $n$ 生成一个结果列表 $[\\,2S+1,\\,L^{(\\text{micro})},\\,J,\\,L^{(\\text{Hund})},\\,\\text{match}\\,]$，其中 $2S+1$ 和 $L^{(\\text{Hund})}$ 是整数，$L^{(\\text{micro})}$ 是一个整数，$J$ 是一个等于适当的半整数或整数的实数，而 $\\text{match}$ 是一个布尔值，指示 $L^{(\\text{micro})}=L^{(\\text{Hund})}$ 是否成立。$S$ 的值必须与从微观态中找到的 $M_S^{\\max}$ 相一致，因此 $2S+1=2\\,M_S^{\\max}+1$。\n- 程序的最终输出必须是单行，包含所有按情况计算的结果列表，顺序与测试套件相同，格式为方括号内以逗号分隔的列表，例如 $[\\text{result}_1,\\text{result}_2,\\dots]$，其中每个 $\\text{result}_i$ 本身都是一个包含指定数值和布尔条目的列表。\n\n不涉及物理单位，也不使用角度。所有数值答案必须按规定以纯数字（整数、实数）或布尔值的形式提供。程序必须在没有用户输入和外部文件的情况下运行。主要目标是通过与泡利原理一致的第一性原理枚举来证明，对于 $p^3$，具有最大 $M_S$ 且在该集合内具有最大 $M_L$ 的状态，得出的基态谱项是洪特规则预测的 $^{4}S$，并报告测试套件中其他 $p^n$ 情况的类似量。", "solution": "问题陈述是一个有效且适定的计算量子化学练习。它要求通过枚举所有符合泡利不相容原理的可能量子微观态，来验证原子 $p^n$ 构型的洪特规则。该问题提供了一套自成体系、尽管略显独特的洪特规则，必须严格遵守。该任务具有科学依据且在计算上是可行的。我们现在将进行形式化的求解。\n\n基本目标是使用两种方法确定 $p^n$ 电子构型的基态谱项符号并比较它们的结果。第一种方法是对所有有效微观态进行直接的第一性原理枚举。第二种是应用所提供的洪特规则的具体表述。\n\n一个 $p$ 亚层由轨道角动量量子数 $l=1$ 表征。因此磁量子数 $m_l$ 可以取值 $m_l \\in \\{-1, 0, 1\\}$。每个电子还有一个自旋量子数 $s=1/2$，其磁自旋量子数 $m_s$ 取值 $m_s \\in \\{-\\frac{1}{2}, +\\frac{1}{2}\\}$。单电子态，或称自旋轨道，由一对量子数 $(m_l, m_s)$ 唯一确定。对于 $p$ 亚层，存在 $2(2l+1) = 2(2 \\cdot 1 + 1) = 6$ 个不同的自旋轨道：\n$$\n\\left\\{ \\left(1, +\\tfrac{1}{2}\\right), \\left(1, -\\tfrac{1}{2}\\right), \\left(0, +\\tfrac{1}{2}\\right), \\left(0, -\\tfrac{1}{2}\\right), \\left(-1, +\\tfrac{1}{2}\\right), \\left(-1, -\\tfrac{1}{2}\\right) \\right\\}\n$$\n根据泡利不相容原理，一个 $n$ 电子系统的微观态是 $n$ 个不同自旋轨道的唯一集合。对于一个给定的微观态，总轨道磁量子数和总自旋磁量子数（分别为 $M_L$ 和 $M_S$）是通过对被占据自旋轨道的量子数求和来计算的：\n$$\nM_L = \\sum_{i=1}^{n} m_l^{(i)} \\quad \\text{和} \\quad M_S = \\sum_{i=1}^{n} m_s^{(i)}\n$$\n对于给定的构型，所有可能的 $(M_L, M_S)$ 对的集合定义了光谱项，记为 $^{2S+1}L_J$。在 Russell-Saunders 耦合的框架内，一个谱项由总自旋角动量 $S$ 和总轨道角动量 $L$ 标识。该谱项与一个包含 $(2S+1)(2L+1)$ 个微观态的多重态相关联。最高权重态原理使我们能从所有微观态的集合中识别出 $S$ 和 $L$。一个谱项的总自旋 $S$ 由该谱项多重态中找到的 $M_S$ 的最大值给出，$S = \\max(M_S)$。基态谱项将对应于该构型所有微观态中的全局最大可能总自旋，$S = M_S^{\\max}$。对于该 $S$ 值，总轨道角动量 $L$ 由所有满足 $M_S = M_S^{\\max}$ 的状态中的 $M_L$ 最大值给出。我们将此值记为 $L^{(\\text{micro})} = (M_L)^{\\max}_{\\text{at } M_S=M_S^{\\max}}$。\n\n从第一性原理确定 $L^{(\\text{micro})}$ 和 $S$ 的算法如下：\n1.  定义 $p$ 亚层的 6 个基本自旋轨道。\n2.  对于给定的电子数 $n$，从基本集合中生成 $n$ 个自旋轨道的所有可能的唯一组合。每个组合代表一个有效的微观态。\n3.  对每个微观态，计算其 $(M_L, M_S)$ 对。\n4.  遍历所有生成的微观态，找到 $M_S$ 的全局最大值，我们将其识别为 $S$。因此，$S = M_S^{\\max}$。\n5.  筛选微观态集合，只保留那些满足 $M_S = M_S^{\\max}$ 的微观态。\n6.  在此微观态子集中，找到 $M_L$ 的最大值。此值被识别为 $L^{(\\text{micro})}$。\n\n接下来，我们必须通过应用给定的洪特规则来确定基态量子数 $L^{(\\text{Hund})}$ 和 $J$。\n1.  **洪特第一规则**：最大化 $S$。这与我们的微观态分析一致，其中我们使用 $S = M_S^{\\max}$。自旋多重度为 $2S+1$。\n2.  **洪特第二规则（按规定）**：对于最大 $S$，我们确定 $L^{(\\text{Hund})}$。\n    - 如果亚层未满半充满 ($n  3$)，选择最小的 $L$。\n    - 如果亚层恰好半充满 ($n=3$)，具有最大 $S$ 的状态有 $L=0$。\n    - 如果亚层超过半充满 ($n > 3$)，选择最大的 $L$。\n    对于 $p$ 壳层，可以证明对于任何给定的最大 $S$，只有一个可能的 $L$ 值。因此，“最小”和“最大”$L$ 之间的区别是无关紧要的；我们只需选择与最大 $S$ 谱项相关联的唯一 $L$ 值。这对于 $p^1, p^2, p^4, p^5$ 得到 $L^{(\\text{Hund})}=1$，对于 $p^3$ 得到 $L^{(\\text{Hund})}=0$。对于闭壳层情况 $p^0$ 和 $p^6$，我们有 $S=0$ 和 $L=0$。\n3.  **洪特第三规则**：对于给定的 $L$ 和 $S$，确定总角动量 $J$。\n    - 如果 $n  3$，$J = |L-S|$。\n    - 如果 $n = 3$，$J = S$（因为 $L=0$）。\n    - 如果 $n > 3$，$J = L+S$。\n\n程序将对测试套件 $[\\,3,\\,1,\\,5,\\,2,\\,4,\\,0,\\,6\\,]$ 中的每个 $n$ 执行此过程。对于每种情况，它会计算列表 $[\\,2S+1,\\,L^{(\\text{micro})},\\,J,\\,L^{(\\text{Hund})},\\,\\text{match}\\,]$，其中 $S$ 和 $L^{(\\text{micro})}$ 来自微观态分析，$L^{(\\text{Hund})}$ 和 $J$ 来自洪特规则，而 $\\text{match}$ 是一个比较 $L^{(\\text{micro})}$ 与 $L^{(\\text{Hund})}$ 的布尔值。对于 $n=3$ 的主要检查确实预期会得出 $S=3/2$ 和 $L=0$，对应于一个 $^4S$ 谱项，从而确认 $L^{(\\text{micro})} = L^{(\\text{Hund})} = 0$。对所有指定的 $n$ 值进行比较，可以作为对最高权重态方法和洪特规则在确定基态谱项方面一致性的更广泛验证。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom itertools import combinations\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    It verifies Hund's rules for p-shell configurations by enumerating microstates.\n    \"\"\"\n\n    def process_n(n: int) - list:\n        \"\"\"\n        Calculates the ground state properties for a p^n configuration.\n        \n        Args:\n            n (int): The number of electrons in the p subshell.\n        \n        Returns:\n            list: A list containing [2S+1, L_micro, J, L_Hund, match].\n        \"\"\"\n        p_subshell_capacity = 6\n\n        # Handle trivial cases: empty or full subshell\n        if n == 0 or n == p_subshell_capacity:\n            S_max = 0.0\n            L_micro = 0\n            L_hund = 0\n            # For n=0, less than half-filled, J=|L-S|=|0-0|=0\n            # For n=6, more than half-filled, J=L+S=0+0=0\n            J = 0.0\n            spin_multiplicity = 1\n            return [spin_multiplicity, L_micro, J, L_hund, L_micro == L_hund]\n\n        # Define the set of single-electron spin-orbitals for a p-shell (l=1)\n        # (m_l, m_s)\n        spin_orbitals = [\n            (1, 0.5), (1, -0.5),\n            (0, 0.5), (0, -0.5),\n            (-1, 0.5), (-1, -0.5)\n        ]\n\n        # Generate all valid microstates (combinations of n spin-orbitals)\n        microstates = combinations(spin_orbitals, n)\n\n        # Calculate (M_L, M_S) for each microstate\n        ml_ms_pairs = []\n        for state in microstates:\n            state_array = np.array(state)\n            m_l_total = np.sum(state_array[:, 0])\n            m_s_total = np.sum(state_array[:, 1])\n            ml_ms_pairs.append((m_l_total, m_s_total))\n\n        # ---- Microstate Analysis (Highest-Weight State) ----\n        \n        # 1. Find the maximum M_S value (identifies S)\n        S_max = -1e9  # Initialize with a very small number\n        for _, m_s in ml_ms_pairs:\n            if m_s  S_max:\n                S_max = m_s\n        \n        # 2. Find the maximum M_L for microstates with M_S = S_max (identifies L)\n        L_micro = -1e9 # Initialize with a very small number\n        for m_l, m_s in ml_ms_pairs:\n            if abs(m_s - S_max)  1e-9: # Floating point comparison\n                if m_l  L_micro:\n                    L_micro = m_l\n        \n        L_micro = int(L_micro) # L is always integer\n        spin_multiplicity = int(2 * S_max + 1)\n\n        # ---- Hund's Rules Application ----\n        \n        # Rule 1: Maximize S. We use S_max found from microstates.\n        # S is already determined as S_max.\n\n        # Rule 2: Determine L for the given S_max.\n        L_hund = -1 # Should be overwritten\n        if n == 3: # Half-filled\n            L_hund = 0\n        elif n in [1, 2, 4, 5]: # Other open shells\n            L_hund = 1\n         \n        # Rule 3: Determine J for the given L and S.\n        J = -1.0 # Should be overwritten\n        half_occupancy = p_subshell_capacity / 2.0\n        if n  half_occupancy:\n            J = abs(L_hund - S_max)\n        elif n > half_occupancy:\n            J = L_hund + S_max\n        else: # n == half_occupancy\n            J = S_max # Since L=0\n\n        # Assemble the result\n        match = (L_micro == L_hund)\n        \n        return [spin_multiplicity, L_micro, J, L_hund, match]\n\n    # Define the test cases from the problem statement.\n    test_cases = [3, 1, 5, 2, 4, 0, 6]\n\n    results = []\n    for n in test_cases:\n        result = process_n(n)\n        results.append(result)\n\n    # Format the final output as a string representing a list of lists.\n    # The `repr` function is used to correctly format the boolean `True`/`False`.\n    result_str = \",\".join(f\"[{r[0]},{r[1]},{r[2]},{r[3]},{repr(r[4])}]\" for r in results)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{result_str}]\")\n\nsolve()\n```", "id": "2459996"}, {"introduction": "洪特第一规则指出，对于给定的电子排布，具有最高自旋多重度的能项能量最低，但这背后的物理原因是什么？本练习通过构建和分析一个简化的“玩具”能量泛函，让你能够亲手调节代表不同物理效应的参数，并观察它们如何影响原子能项的能量顺序[@problem_id:2459995]。这个思想实验旨在揭示自旋相关的能量贡献（特别是交换能）是如何成为洪特规则的根本驱动力的。", "problem": "考虑碳原子的价层电子构型，其 $2p$ 亚层中有两个电子（即 $p^2$ 构型）。Pauli 不相容原理要求，对于每个空间轨道，占据数 $n_{m\\uparrow}$ 和 $n_{m\\downarrow}$ 只能是 $0$ 或 $1$，每个空间轨道最多容纳两个电子，且在双占据时自旋相反。由此构型产生的原子光谱项符号包括 $^{3}\\!P$、$^{1}\\!D$ 和 $^{1}\\!S$。根据洪特第一规则，当其他条件相当时，总自旋 $S$ 最高的态应具有最低的能量。在本问题中，您将构建一个简单的模型，该模型模拟了密度泛函理论（DFT）的交换贡献，但其构造方式会错误地惩罚高自旋态，您将评估由此产生的光谱项排序。\n\n定义一个包含 $N$ 个电子的 $p$ 亚层的玩具总能量泛函为\n$$\nE(N,D,S;\\,\\varepsilon_p,A,B,C)\\;=\\;N\\,\\varepsilon_p\\;+\\;A\\,\\frac{N(N-1)}{2}\\;+\\;B\\,D\\;+\\;C\\,S(S+1),\n$$\n其中：\n- $N$ 是 $p$ 亚层中的电子数，\n- $\\varepsilon_p$ 是每个 $p$ 轨道的单电子能量（假设有三个简并的 $p$ 轨道），\n- $A$ 是一个平均双电子排斥参数，\n- $B$ 是每个双占据空间轨道的能量惩罚，其中 $D=\\sum_{m} n_{m\\uparrow}n_{m\\downarrow}$，\n- $C$ 是一个自旋相关系数，如果为正，则惩罚较高的总自旋 $S$。\n\n对于碳的 $p^2$ 构型，使用以下与允许的微观态和 Russell–Saunders 耦合一致的赋值：\n- 对于 $^{3}\\!P$：$N=2$, $S=1$, $D=0$。\n- 对于 $^{1}\\!D$：$N=2$, $S=0$, $D=0$。\n- 对于 $^{1}\\!S$：$N=2$, $S=0$, $D=1$。\n\n所有能量均以 Hartree 单位计。您需要在一组固定的参数集 $(\\varepsilon_p,A,B,C)$ 测试套件上评估该模型，并对每组参数确定模型是否产生洪特第一规则对此亚层所要求的严格排序，即\n$$\nE(^{3}\\!P)  E(^{1}\\!D)  E(^{1}\\!S).\n$$\n\n测试套件（每个元组按顺序列表 $(\\varepsilon_p,A,B,C)$，单位为 Hartree）：\n- 情况 $1$：$\\big(-0.5,\\;0.2,\\;0.3,\\;0.1\\big)$。\n- 情况 $2$：$\\big(-0.5,\\;0.2,\\;0.3,\\;-0.1\\big)$。\n- 情况 $3$：$\\big(-0.5,\\;0.2,\\;0.3,\\;0.0\\big)$。\n\n对于每种情况，您的程序必须使用上述泛函计算 $E(^{3}\\!P)$、$E(^{1}\\!D)$ 和 $E(^{1}\\!S)$，并返回一个布尔值，指示严格不等式 $E(^{3}\\!P)  E(^{1}\\!D)  E(^{1}\\!S)$ 是否成立。最终输出必须是一个包含按顺序排列的三个布尔值的列表，例如 `[False,True,False]`。", "solution": "问题陈述已经过验证，并被认为是有效的。它提出了一个定义明确的计算化学理论练习，要求根据已知的物理原理（Hund 规则）评估一个玩具能量泛函。该问题是自洽的，作为一个教学模型具有科学依据，并且在数学上是明确的。我们将继续进行解答。\n\n任务是确定给定的玩具能量泛函是否能重现洪特规则所规定的 $p^2$ 电子构型的原子光谱项能量排序。指定的正确排序是 $E(^{3}\\!P)  E(^{1}\\!D)  E(^{1}\\!S)$。\n\n总能量泛函给出如下：\n$$\nE(N,D,S;\\,\\varepsilon_p,A,B,C)\\;=\\;N\\,\\varepsilon_p\\;+\\;A\\,\\frac{N(N-1)}{2}\\;+\\;B\\,D\\;+\\;C\\,S(S+1)\n$$\n对于 $p^2$ 构型，电子数为 $N=2$。因此，所有态的能量公共部分为：\n$$\nE_{\\text{common}} = 2\\varepsilon_p + A\\frac{2(2-1)}{2} = 2\\varepsilon_p + A\n$$\n现在我们使用为三个光谱项提供的参数来评估各自的能量。\n\n1.  **$^{3}\\!P$ 态的能量**：\n    参数为 $N=2$，$S=1$ 和 $D=0$。\n    $$\n    E(^{3}\\!P) = E_{\\text{common}} + B(0) + C(1)(1+1) = 2\\varepsilon_p + A + 2C\n    $$\n\n2.  **$^{1}\\!D$ 态的能量**：\n    参数为 $N=2$，$S=0$ 和 $D=0$。\n    $$\n    E(^{1}\\!D) = E_{\\text{common}} + B(0) + C(0)(0+1) = 2\\varepsilon_p + A\n    $$\n\n3.  **$^{1}\\!S$ 态的能量**：\n    参数为 $N=2$，$S=0$ 和 $D=1$。\n    $$\n    E(^{1}\\!S) = E_{\\text{common}} + B(1) + C(0)(0+1) = 2\\varepsilon_p + A + B\n    $$\n\n需要验证的条件是严格不等式：\n$$\nE(^{3}\\!P)  E(^{1}\\!D)  E(^{1}\\!S)\n$$\n代入导出的表达式，我们得到：\n$$\n2\\varepsilon_p + A + 2C  2\\varepsilon_p + A  2\\varepsilon_p + A + B\n$$\n公共项 $2\\varepsilon_p + A$ 可以从复合不等式的各个部分中减去，从而将条件简化为：\n$$\n2C  0  B\n$$\n这等价于两个独立的条件：\n1.  $C  0$\n2.  $B > 0$\n\n要使模型重现指定的排序，两个条件都必须严格满足。$C \\geq 0$ 的值将违反洪特第一规则（通过使三重态能量高于或简并于具有相同 $D$ 的单重态），而 $B \\leq 0$ 的值将违反单重态的排序。\n\n我们现在评估提供的三个测试用例。\n\n**情况 1**：参数 $(\\varepsilon_p, A, B, C) = (-0.5, 0.2, 0.3, 0.1)$。\n-   条件 1：$C = 0.1$。不等式 $C  0$ 不满足，因为 $0.1 \\not 0$。\n-   条件 2：$B = 0.3$。不等式 $B > 0$ 满足，因为 $0.3 > 0$。\n由于一个条件不满足，总体排序不正确。\n为了明确起见，我们以 Hartree 单位计算能量：\n-   $E_{\\text{common}} = 2(-0.5) + 0.2 = -1.0 + 0.2 = -0.8$。\n-   $E(^{3}\\!P) = -0.8 + 2(0.1) = -0.6$。\n-   $E(^{1}\\!D) = -0.8$。\n-   $E(^{1}\\!S) = -0.8 + 0.3 = -0.5$。\n得到的排序是 $E(^{1}\\!D)  E(^{3}\\!P)  E(^{1}\\!S)$，因为 $-0.8  -0.6  -0.5$。这不是所要求的排序。结果是 **False**。\n\n**情况 2**：参数 $(\\varepsilon_p, A, B, C) = (-0.5, 0.2, 0.3, -0.1)$。\n-   条件 1：$C = -0.1$。不等式 $C  0$ 满足，因为 $-0.1  0$。\n-   条件 2：$B = 0.3$。不等式 $B > 0$ 满足，因为 $0.3 > 0$。\n两个条件都满足。排序应该是正确的。\n显式计算：\n-   $E_{\\text{common}} = 2(-0.5) + 0.2 = -0.8$。\n-   $E(^{3}\\!P) = -0.8 + 2(-0.1) = -1.0$。\n-   $E(^{1}\\!D) = -0.8$。\n-   $E(^{1}\\!S) = -0.8 + 0.3 = -0.5$。\n得到的排序是 $E(^{3}\\!P)  E(^{1}\\!D)  E(^{1}\\!S)$，因为 $-1.0  -0.8  -0.5$。这与要求的排序相符。结果是 **True**。\n\n**情况 3**：参数 $(\\varepsilon_p, A, B, C) = (-0.5, 0.2, 0.3, 0.0)$。\n-   条件 1：$C = 0.0$。严格不等式 $C  0$ 不满足。此处 $C=0$。\n-   条件 2：$B = 0.3$。不等式 $B > 0$ 满足。\n由于对 $C$ 的条件是严格不等式，所以 $C=0$ 导致失败。$2C  0$ 变为 $0  0$，这是错误的。这意味着 $E(^{3}\\!P)$ 并不严格小于 $E(^{1}\\!D)$，而是相等。\n显式计算：\n-   $E_{\\text{common}} = 2(-0.5) + 0.2 = -0.8$。\n-   $E(^{3}\\!P) = -0.8 + 2(0.0) = -0.8$。\n-   $E(^{1}\\!D) = -0.8$。\n-   $E(^{1}\\!S) = -0.8 + 0.3 = -0.5$。\n结果是 $E(^{3}\\!P) = E(^{1}\\!D)  E(^{1}\\!S)$。严格不等式 $E(^{3}\\!P)  E(^{1}\\!D)$ 未被满足。结果是 **False**。\n\n结果总结：[False, True, False]。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Evaluates a toy energy functional for the p^2 configuration of a carbon atom\n    and determines if the energy ordering of term symbols matches Hund's rules.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple represents (epsilon_p, A, B, C) in Hartree units.\n    test_cases = [\n        (-0.5, 0.2, 0.3, 0.1),  # Case 1\n        (-0.5, 0.2, 0.3, -0.1), # Case 2\n        (-0.5, 0.2, 0.3, 0.0),  # Case 3\n    ]\n\n    results = []\n    for case in test_cases:\n        eps_p, A, B, C = case\n        \n        # All states have N=2 electrons. The common energy term is:\n        # E_common = N*eps_p + A*N*(N-1)/2, for N=2 this is 2*eps_p + A.\n        e_common = 2 * eps_p + A\n        \n        # Energy for the 3P state (S=1, D=0):\n        # E(3P) = E_common + B*D + C*S*(S+1)\n        #       = E_common + B*0 + C*1*(1+1) = E_common + 2*C\n        e_3p = e_common + 2 * C\n        \n        # Energy for the 1D state (S=0, D=0):\n        # E(1D) = E_common + B*D + C*S*(S+1)\n        #       = E_common + B*0 + C*0*(0+1) = E_common\n        e_1d = e_common\n        \n        # Energy for the 1S state (S=0, D=1):\n        # E(1S) = E_common + B*D + C*S*(S+1)\n        #       = E_common + B*1 + C*0*(0+1) = E_common + B\n        e_1s = e_common + B\n        \n        # Check if the strict inequality E(3P)  E(1D)  E(1S) holds.\n        is_hunds_ordering = (e_3p  e_1d) and (e_1d  e_1s)\n        \n        results.append(is_hunds_ordering)\n\n    # Final print statement in the exact required format.\n    # The map(str, ...) correctly converts Python booleans True/False to strings.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2459995"}]}