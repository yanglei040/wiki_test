{"hands_on_practices": [{"introduction": "分子对称性操作本质上是三维空间中的几何变换。在计算化学中，我们通常使用 $3 \\times 3$ 矩阵来表示这些操作，通过矩阵乘法将它们作用于代表原子位置的坐标向量上。本练习将引导你将对称操作的几何定义（如旋转、反映和反演）转化为具体的计算机代码，让你亲手实现这些变换。通过这个实践 [@problem_id:2458763]，你将不仅仅是识别对称元素，而是从第一性原理层面深刻理解它们如何精确地改变空间中的每一个点，为后续学习更复杂的群论应用打下坚实的基础。", "problem": "编写一个完整、可运行的程序，该程序实现一个函数，根据第一性原理定义，将三维分子对称操作应用于一个点。该函数必须接受一个点 $(x, y, z)$ 和一个操作字符串，并返回变换后的坐标 $(x', y', z')$。所有操作都在右手笛卡尔坐标系中主动作用于该点。\n\n需要实现的操作及其数学定义：\n- 恒等操作：字符串 \"E\" 代表恒等操作，它使点保持不变。如果输入为 $(x, y, z)$，则输出为 $(x', y', z') = (x, y, z)$。\n- 反演操作：字符串 \"i\" 代表通过原点的反演，$(x, y, z) \\mapsto (-x, -y, -z)$。\n- 绕坐标轴的正常旋转：字符串 \"C\" 后跟一个正整数 $n$ 和一个轴字母 $\\{x, y, z\\}$，例如 \"C2z\" 或 \"C3x\"。这表示使用右手定则，绕指定轴旋转角度 $\\theta = \\frac{2\\pi}{n}$（以弧度为单位）。对于 $z$ 轴，旋转操作如下\n$$\n\\begin{pmatrix}\nx' \\\\ y' \\\\ z'\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n\\cos\\theta  -\\sin\\theta  0 \\\\\n\\sin\\theta  \\cos\\theta  0 \\\\\n0  0  1\n\\end{pmatrix}\n\\begin{pmatrix}\nx \\\\ y \\\\ z\n\\end{pmatrix},\n$$\n对于 $x$ 轴和 $y$ 轴，有类似的标准旋转矩阵。\n- 通过坐标平面的反映：字符串 \"sigma_\" 后跟一个平面名称 $\\{\\text{xy}, \\text{xz}, \\text{yz}\\}$，例如 \"sigma_xy\"。这些操作是跨指定平面的反映，即\n$\\sigma_{xy}: (x, y, z) \\mapsto (x, y, -z)$,\n$\\sigma_{xz}: (x, y, z) \\mapsto (x, -y, z)$,\n$\\sigma_{yz}: (x, y, z) \\mapsto (-x, y, z)$。\n- 绕坐标轴的非正常旋转：字符串 \"S\" 后跟一个正整数 $n$ 和一个轴字母 $\\{x, y, z\\}$，例如 \"S4z\"。这表示一个复合操作，首先绕指定轴进行角度为 $\\theta = \\frac{2\\pi}{n}$（以弧度为单位）的正常旋转，然后通过垂直于该轴的平面进行反映。例如，\"S4z\" 是绕 $z$ 轴旋转 $\\frac{\\pi}{2}$，然后通过 $xy$ 平面进行反映。\n\n角度单位要求：\n- 所有角度都应以弧度处理。\"C$n$axis\" 或 \"S$n$axis\" 中的参数 $n$ 意味着 $\\theta = \\frac{2\\pi}{n}$ 弧度。\n\n您的程序必须在以下输入案例测试套件上评估该函数。每个案例都是由一个点 $(x, y, z)$ 和一个操作字符串组成的一对：\n- 案例 1：点 $(1.0, 2.0, 3.0)$ 与操作 \"C2z\"。\n- 案例 2：点 $(1.0, 0.0, 0.0)$ 与操作 \"sigma_yz\"。\n- 案例 3：点 $(0.0, 1.0, 0.0)$ 与操作 \"C3x\"。\n- 案例 4：点 $(0.0, 0.0, 1.0)$ 与操作 \"S4z\"。\n- 案例 5：点 $(1.0, 1.0, 1.0)$ 与操作 \"C4z\"。\n- 案例 6：点 $(0.0, 0.0, 5.0)$ 与操作 \"C6z\"。\n- 案例 7：点 $(3.0, -2.0, 0.0)$ 与操作 \"sigma_xy\"。\n- 案例 8：点 $(-1.5, 2.5, -3.5)$ 与操作 \"i\"。\n- 案例 9：点 $(2.0, 0.0, 0.0)$ 与操作 \"E\"。\n- 案例 10：点 $(1.0, 2.0, 3.0)$ 与操作 \"C2y\"。\n\n数值输出规格：\n- 对于每个测试案例，计算变换后的坐标 $(x', y', z')$，并将每个坐标四舍五入到恰好六位小数。\n- 您的程序必须生成单行输出，其中包含结果，格式为逗号分隔的坐标三元组列表，每个三元组写在方括号中，如 $[x',y',z']$，并且所有三元组都包含在一对单独的方括号中。例如：\"[[a,b,c],[d,e,f],...]\"。\n- 输出不应包含任何空格。所有坐标必须打印小数点后恰好六位数字。\n- 此问题中没有物理单位，因此不应打印任何单位。\n\n覆盖设计：\n- 提供的测试套件涵盖了旋转的一般情况、跨坐标平面的反映、反演、恒等操作、旋转的多个轴、旋转轴上的点（在正常旋转下的不变性），以及由旋转和垂直平面反映组成的非正常旋转。每个测试案例的答案都是一个包含三个浮点数的列表。", "solution": "问题陈述已经过严格验证，被认为是有效的。它具有科学依据，问题定义明确，客观，并包含推导唯一、可验证解所需的所有必要信息。该问题要求实现分子群论中的基本对称操作，这些操作在数学上表示为三维欧几里得空间中的线性变换。我们将继续进行求解。\n\n核心原理是，每个对称操作都可以用一个 $3 \\times 3$ 矩阵 $M$ 来表示，该矩阵作用于代表点坐标的列向量 $\\vec{v} = \\begin{pmatrix} x \\\\ y \\\\ z \\end{pmatrix}$。变换后的点 $\\vec{v}' = \\begin{pmatrix} x' \\\\ y' \\\\ z' \\end{pmatrix}$ 是通过矩阵-向量乘法获得的：$\\vec{v}' = M \\vec{v}$。我们将为每个指定的操作构建矩阵。坐标系是标准的右手笛卡尔坐标系。\n\n1.  **恒等操作 ($E$)**: 此操作使点保持不变。它由 $3 \\times 3$ 单位矩阵 $I_3$ 表示。\n    $$\n    M_E = I_3 = \\begin{pmatrix} 1  0  0 \\\\ 0  1  0 \\\\ 0  0  1 \\end{pmatrix}\n    $$\n    因此，$(x', y', z') = (x, y, z)$。\n\n2.  **反演操作 ($i$)**: 此操作通过原点反演点。矩阵是单位矩阵的负数。\n    $$\n    M_i = \\begin{pmatrix} -1  0  0 \\\\ 0  -1  0 \\\\ 0  0  -1 \\end{pmatrix}\n    $$\n    因此，$(x', y', z') = (-x, -y, -z)$。\n\n3.  **反映 ($\\sigma$)**: 跨平面的反映也是一个线性变换。\n    -   通过 $xy$ 平面的反映 ($\\sigma_{xy}$): $z$ 坐标取反。\n        $$\n        M_{\\sigma_{xy}} = \\begin{pmatrix} 1  0  0 \\\\ 0  1  0 \\\\ 0  0  -1 \\end{pmatrix}\n        $$\n    -   通过 $xz$ 平面的反映 ($\\sigma_{xz}$): $y$ 坐标取反。\n        $$\n        M_{\\sigma_{xz}} = \\begin{pmatrix} 1  0  0 \\\\ 0  -1  0 \\\\ 0  0  1 \\end{pmatrix}\n        $$\n    -   通过 $yz$ 平面的反映 ($\\sigma_{yz}$): $x$ 坐标取反。\n        $$\n        M_{\\sigma_{yz}} = \\begin{pmatrix} -1  0  0 \\\\ 0  1  0 \\\\ 0  0  1 \\end{pmatrix}\n        $$\n\n4.  **正常旋转 ($C_n$)**: 绕指定轴旋转角度 $\\theta = \\frac{2\\pi}{n}$ 弧度。在右手坐标系中，主动旋转的矩阵如下：\n    -   绕 $z$ 轴旋转, $R_z(\\theta)$:\n        $$\n        M_{C_n(z)} = R_z(\\theta) = \\begin{pmatrix} \\cos\\theta  -\\sin\\theta  0 \\\\ \\sin\\theta  \\cos\\theta  0 \\\\ 0  0  1 \\end{pmatrix}\n        $$\n    -   绕 $x$ 轴旋转, $R_x(\\theta)$:\n        $$\n        M_{C_n(x)} = R_x(\\theta) = \\begin{pmatrix} 1  0  0 \\\\ 0  \\cos\\theta  -\\sin\\theta \\\\ 0  \\sin\\theta  \\cos\\theta \\end{pmatrix}\n        $$\n    -   绕 $y$ 轴旋转, $R_y(\\theta)$:\n        $$\n        M_{C_n(y)} = R_y(\\theta) = \\begin{pmatrix} \\cos\\theta  0  \\sin\\theta \\\\ 0  1  0 \\\\ -\\sin\\theta  0  \\cos\\theta \\end{pmatrix}\n        $$\n\n5.  **非正常旋转 ($S_n$)**: 这是一个复合操作，包括一次正常旋转 ($C_n$)，然后是在垂直于旋转轴的平面上进行一次反映 ($\\sigma_h$)。最终的变换矩阵是各个矩阵的乘积：$M_{S_n} = M_{\\sigma_h} M_{C_n}$。\n    -   绕 $z$ 轴的非正常旋转, $S_n(z)$: 旋转是 $C_n(z)$，反映是 $\\sigma_{xy}$。\n        $$\n        M_{S_n(z)} = M_{\\sigma_{xy}} M_{C_n(z)} = \\begin{pmatrix} 1  0  0 \\\\ 0  1  0 \\\\ 0  0  -1 \\end{pmatrix} \\begin{pmatrix} \\cos\\theta  -\\sin\\theta  0 \\\\ \\sin\\theta  \\cos\\theta  0 \\\\ 0  0  1 \\end{pmatrix} = \\begin{pmatrix} \\cos\\theta  -\\sin\\theta  0 \\\\ \\sin\\theta  \\cos\\theta  0 \\\\ 0  0  -1 \\end{pmatrix}\n        $$\n    -   绕 $x$ 轴的非正常旋转, $S_n(x)$: 旋转是 $C_n(x)$，反映是 $\\sigma_{yz}$。\n        $$\n        M_{S_n(x)} = M_{\\sigma_{yz}} M_{C_n(x)} = \\begin{pmatrix} -1  0  0 \\\\ 0  1  0 \\\\ 0  0  1 \\end{pmatrix} \\begin{pmatrix} 1  0  0 \\\\ 0  \\cos\\theta  -\\sin\\theta \\\\ 0  \\sin\\theta  \\cos\\theta \\end{pmatrix} = \\begin{pmatrix} -1  0  0 \\\\ 0  \\cos\\theta  -\\sin\\theta \\\\ 0  \\sin\\theta  \\cos\\theta \\end{pmatrix}\n        $$\n    -   绕 $y$ 轴的非正常旋转, $S_n(y)$: 旋转是 $C_n(y)$，反映是 $\\sigma_{xz}$。\n        $$\n        M_{S_n(y)} = M_{\\sigma_{xz}} M_{C_n(y)} = \\begin{pmatrix} 1  0  0 \\\\ 0  -1  0 \\\\ 0  0  1 \\end{pmatrix} \\begin{pmatrix} \\cos\\theta  0  \\sin\\theta \\\\ 0  1  0 \\\\ -\\sin\\theta  0  \\cos\\theta \\end{pmatrix} = \\begin{pmatrix} \\cos\\theta  0  \\sin\\theta \\\\ 0  -1  0 \\\\ -\\sin\\theta  0  \\cos\\theta \\end{pmatrix}\n        $$\n\n该算法将首先解析输入的操作字符串，以识别操作类型、阶数 $n$（如果适用）和轴（如果适用）。根据这些信息，构建相应的 $3 \\times 3$ 变换矩阵 $M$。然后通过计算矩阵-向量乘积 $M\\vec{v}$ 来变换输入点向量 $\\vec{v}$。结果向量的分量被格式化为指定的精度。此过程系统地应用于所有测试案例。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef apply_symmetry_operation(point, op_string):\n    \"\"\"\n    Applies a 3D symmetry operation to a point.\n\n    Args:\n        point (np.ndarray): A 1D numpy array of shape (3,) representing the coordinates (x, y, z).\n        op_string (str): The string representation of the symmetry operation.\n\n    Returns:\n        np.ndarray: The transformed point coordinates.\n    \"\"\"\n    op_type = op_string[0]\n    \n    # Identity\n    if op_type == 'E':\n        return point\n\n    # Inversion\n    if op_type == 'i':\n        M = -np.identity(3)\n        return M @ point\n\n    # Reflection\n    if op_type == 's':  # for \"sigma\"\n        plane = op_string.split('_')[1]\n        M = np.identity(3)\n        if plane == 'xy':\n            M[2, 2] = -1.0\n        elif plane == 'xz':\n            M[1, 1] = -1.0\n        elif plane == 'yz':\n            M[0, 0] = -1.0\n        return M @ point\n\n    # Proper and Improper Rotations\n    if op_type in ('C', 'S'):\n        n = int(op_string[1:-1])\n        axis = op_string[-1]\n        \n        if n == 0:\n            raise ValueError(\"Rotation order n must be a positive integer.\")\n            \n        theta = (2 * np.pi) / n\n        cos_theta = np.cos(theta)\n        sin_theta = np.sin(theta)\n        \n        # Proper Rotation Matrix (R)\n        if axis == 'z':\n            R = np.array([\n                [cos_theta, -sin_theta, 0],\n                [sin_theta,  cos_theta, 0],\n                [0,          0,         1]\n            ])\n        elif axis == 'x':\n            R = np.array([\n                [1, 0,           0],\n                [0, cos_theta,  -sin_theta],\n                [0, sin_theta,   cos_theta]\n            ])\n        elif axis == 'y':\n            R = np.array([\n                [cos_theta,  0, sin_theta],\n                [0,          1, 0],\n                [-sin_theta, 0, cos_theta]\n            ])\n        else:\n            raise ValueError(f\"Invalid rotation axis: {axis}\")\n\n        # If it's a proper rotation (C)\n        if op_type == 'C':\n            return R @ point\n\n        # If it's an improper rotation (S)\n        if op_type == 'S':\n            # Sigma_h reflection matrix\n            sigma_h = np.identity(3)\n            if axis == 'x':\n                sigma_h[0, 0] = -1.0\n            elif axis == 'y':\n                sigma_h[1, 1] = -1.0\n            elif axis == 'z':\n                sigma_h[2, 2] = -1.0\n            \n            # S_n = sigma_h * C_n\n            M = sigma_h @ R\n            return M @ point\n            \n    raise ValueError(f\"Unknown operation string: {op_string}\")\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # language: Python\n    # version: 3.12\n    # libraries:\n    #     - name: numpy\n    #       version: 1.23.5\n    test_cases = [\n        ((1.0, 2.0, 3.0), \"C2z\"),\n        ((1.0, 0.0, 0.0), \"sigma_yz\"),\n        ((0.0, 1.0, 0.0), \"C3x\"),\n        ((0.0, 0.0, 1.0), \"S4z\"),\n        ((1.0, 1.0, 1.0), \"C4z\"),\n        ((0.0, 0.0, 5.0), \"C6z\"),\n        ((3.0, -2.0, 0.0), \"sigma_xy\"),\n        ((-1.5, 2.5, -3.5), \"i\"),\n        ((2.0, 0.0, 0.0), \"E\"),\n        ((1.0, 2.0, 3.0), \"C2y\"),\n    ]\n\n    results = []\n    for point_coords, op_string in test_cases:\n        point_vec = np.array(point_coords, dtype=float)\n        \n        transformed_point = apply_symmetry_operation(point_vec, op_string)\n        \n        # Format the result with 6 decimal places and no spaces.\n        formatted_result = f\"[{transformed_point[0]:.6f},{transformed_point[1]:.6f},{transformed_point[2]:.6f}]\"\n        results.append(formatted_result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2458763"}, {"introduction": "一个分子的所有对称操作并非随意组合，它们共同构成一个具有严格规则的数学结构——群。这个结构由四个基本公理定义：封闭性、结合律、单位元存在性和逆元存在性。本练习 [@problem_id:2458755] 要求你编写一个程序，以编程方式验证给定的对称操作矩阵集合是否满足这四个群公理。通过亲手实现这个验证过程，你将把抽象的群论定义与具体的矩阵表示联系起来，从而深刻理解为何一组给定的操作能够（或不能够）构成一个有效的点群。", "problem": "给定有限的实数方阵集合，这些集合代表了在矩阵乘法下的三维对称操作，这是计算化学中用于模拟分子点群的常用框架。一个矩阵集合在矩阵乘法下构成一个数学群，当且仅当它对其二元运算满足以下所有四个公理：\n\n1. 封闭性：对于集合 $S$ 中的所有元素 $A$ 和 $B$，其乘积 $AB$ 也在 $S$ 中。\n2. 结合律：对于集合 $S$ 中的所有元素 $A$、$B$ 和 $C$，$(AB)C = A(BC)$。\n3. 单位元：集合 $S$ 中存在一个元素 $E$，使得对于 $S$ 中的所有 $A$，都有 $EA = AE = A$。\n4. 逆元：对于集合 $S$ 中的每个元素 $A$，都存在一个集合 $S$ 中的元素 $B$，使得 $AB = BA = E$，其中 $E$ 是公理3中的单位元。\n\n在本任务中，矩阵相等性必须在数值上带有一个容差来解释：两个矩阵 $X$ 和 $Y$ 被认为是相等的，如果 $\\max_{i,j} |X_{ij} - Y_{ij}| \\le \\tau$，其中 $\\tau = 10^{-8}$。\n\n您的程序必须为每个提供的测试集验证这四个公理的真值，并报告该集合是否是一个群（四个公理的逻辑与）。所有乘法都是标准的 $3 \\times 3$ 实数矩阵乘法，矩阵元素是实数。所有角度（当出现在下面的旋转矩阵中时）都由其三角函数值隐式定义，输入中不需要明确的角度单位，因为只提供了数值矩阵。\n\n测试套件（每个集合 $S_k$ 是 $\\mathbb{R}^{3 \\times 3}$ 的一个有限子集）：\n\n- 集合 $S_1$ （点群 $\\mathrm{C}_{2v}$，主轴沿 $z$ 轴；元素是单位元、一个绕 $z$ 轴的 $180^\\circ$ 旋转和两个镜面反射）：\n  $$\n  I = \\begin{bmatrix} 1  0  0 \\\\ 0  1  0 \\\\ 0  0  1 \\end{bmatrix},\\quad\n  C_{2z} = \\begin{bmatrix} -1  0  0 \\\\ 0  -1  0 \\\\ 0  0  1 \\end{bmatrix},\\quad\n  \\sigma_{xz} = \\begin{bmatrix} 1  0  0 \\\\ 0  -1  0 \\\\ 0  0  1 \\end{bmatrix},\\quad\n  \\sigma_{yz} = \\begin{bmatrix} -1  0  0 \\\\ 0  1  0 \\\\ 0  0  1 \\end{bmatrix}.\n  $$\n  定义 $S_1 = \\{ I, C_{2z}, \\sigma_{xz}, \\sigma_{yz} \\}$。\n\n- 集合 $S_2$ （一个混合了旋转和反射的非封闭集合）：\n  $$\n  I = \\begin{bmatrix} 1  0  0 \\\\ 0  1  0 \\\\ 0  0  1 \\end{bmatrix},\\quad\n  R_{z,90} = \\begin{bmatrix} 0  -1  0 \\\\ 1  0  0 \\\\ 0  0  1 \\end{bmatrix},\\quad\n  \\sigma_{yz} = \\begin{bmatrix} -1  0  0 \\\\ 0  1  0 \\\\ 0  0  1 \\end{bmatrix}.\n  $$\n  定义 $S_2 = \\{ I, R_{z,90}, \\sigma_{yz} \\}$。\n\n- 集合 $S_3$ （一个没有单位元的封闭集合）：\n  $$\n  O = \\begin{bmatrix} 0  0  0 \\\\ 0  0  0 \\\\ 0  0  0 \\end{bmatrix},\\quad\n  N = \\begin{bmatrix} 0  1  0 \\\\ 0  0  0 \\\\ 0  0  0 \\end{bmatrix}.\n  $$\n  定义 $S_3 = \\{ O, N \\}$。\n\n- 集合 $S_4$ （一个有单位元但其有元素缺少逆元的幺半群）：\n  $$\n  I = \\begin{bmatrix} 1  0  0 \\\\ 0  1  0 \\\\ 0  0  1 \\end{bmatrix},\\quad\n  P = \\begin{bmatrix} 1  0  0 \\\\ 0  0  0 \\\\ 0  0  0 \\end{bmatrix}.\n  $$\n  定义 $S_4 = \\{ I, P \\}$。\n\n- 集合 $S_5$ （循环点群 $\\mathrm{C}_3$，包含绕 $z$ 轴旋转 $0^\\circ$、$120^\\circ$ 和 $240^\\circ$ 的操作）：\n  $$\n  R_{z,120} = \\begin{bmatrix}\n  -\\tfrac{1}{2}  -\\tfrac{\\sqrt{3}}{2}  0 \\\\\n  \\tfrac{\\sqrt{3}}{2}  -\\tfrac{1}{2}  0 \\\\\n  0  0  1\n  \\end{bmatrix},\\quad\n  R_{z,240} = \\begin{bmatrix}\n  -\\tfrac{1}{2}  \\tfrac{\\sqrt{3}}{2}  0 \\\\\n  -\\tfrac{\\sqrt{3}}{2}  -\\tfrac{1}{2}  0 \\\\\n  0  0  1\n  \\end{bmatrix}.\n  $$\n  定义 $S_5 = \\{ I, R_{z,120}, R_{z,240} \\}$，其中 $I$ 如上所述。\n\n每个测试集 $S_k$ 的要求输出：\n\n- 对于每个 $S_k$，按 $[\\text{is\\_group}, \\text{closure}, \\text{associativity}, \\text{identity\\_exists}, \\text{inverses\\_exist}]$ 的顺序返回一个包含五个布尔值的列表，其中 $\\text{is\\_group}$ 是这四个性质的逻辑与。\n- 您的程序应生成单行输出，其中包含 $S_1$ 到 $S_5$ 的结果，格式为一个由这五个元素的列表组成的逗号分隔列表，并用方括号括起来，例如：$[[\\dots],[\\dots],[\\dots],[\\dots],[\\dots]]$。\n\n不提供用户输入；所有矩阵都必须按照上述规定在程序内部定义。所有矩阵的数值比较都必须使用定义的容差 $\\tau = 10^{-8}$。", "solution": "该问题要求验证几个 $3 \\times 3$ 实数矩阵有限集的群论性质，其中的二元运算是标准矩阵乘法。如果一个给定集合 $S$ 满足四个基本公理：封闭性、结合律、存在单位元和每个元素都存在逆元，那么它就构成一个群。分析必须通过算法进行，并考虑使用指定的容差处理数值精度问题。\n\n由于浮点数运算，必须谨慎处理矩阵的相等性判断。两个矩阵 $X$ 和 $Y$ 被认为是相等的，如果它们对应元素之间的最大绝对差不大于容差 $\\tau = 10^{-8}$。这个条件表示为 $\\max_{i,j} |X_{ij} - Y_{ij}| \\le \\tau$。\n\n每个公理的验证过程如下：\n\n1.  **封闭性**：为了验证封闭性，必须确认对于集合 $S$ 中的每一对元素 $A, B \\in S$，其乘积 $C = AB$ 也是 $S$ 中的一个元素。算法遍历集合 $S$ 中的所有有序对 $(A, B)$，计算它们的乘积 $C$，然后检查 $S$ 中是否有任何矩阵在给定的容差 $\\tau$ 内与 $C$ 相等。如果发现任何乘积不在 $S$ 中，则封闭性为假。如果所有乘积都在 $S$ 中，则该性质为真。\n\n2.  **结合律**：矩阵乘法的结合律 $(AB)C = A(BC)$ 是线性代数的一个基本定理。它对于任何三个可以进行乘积定义的矩阵都成立。由于我们处理的是相同维度（$3 \\times 3$）的方阵，这个性质对于这类矩阵的任何子集都保证为真。因此，不需要进行计算检查；对于所有提供的测试集，这个公理都得到满足。结合律的结果总是为真。\n\n3.  **单位元**：为了验证单位元的存在性，算法必须在集合 $S$ 中搜索一个元素 $E$，使得对于 $S$ 中的所有元素 $A$，乘积 $EA = A$ 和 $AE = A$ 都成立。该过程包括遍历 $S$ 中的每个候选元素 $E_{\\text{cand}}$，并测试它是否与 $S$ 中的每个其他元素 $A$ 满足单位元性质。如果找到了这样的元素 $E$，则该性质成立，并且这个唯一的单位元将被存储起来用于逆元检查。如果搜索完成而没有找到这样的元素，则该性质为假。\n\n4.  **逆元**：逆元的存在取决于单位元 $E$ 的存在。如果不存在单位元，根据定义，此性质为假。如果单位元 $E$ 存在，算法必须接着验证对于 $S$ 中的每个元素 $A$，是否存在一个对应的元素 $B \\in S$（$A$ 的逆元），使得 $AB = BA = E$。这是通过遍历 $S$ 中的每个 $A$，并为每个 $A$ 搜索一个满足逆元条件的合适的 $B \\in S$ 来检查的。如果 $S$ 中的每个元素在 $S$ 中都有逆元，则该性质为真。如果有一个元素在 $S$ 中缺少逆元，则该性质为假。\n\n最后，当且仅当所有四个公理——封闭性、结合律、单位元和逆元——同时为真时，$\\text{is\\_group}$ 性质才为真。\n\n对于给定的测试集：\n-   $S_1 = \\{ I, C_{2z}, \\sigma_{xz}, \\sigma_{yz} \\}$，其中 $I = \\begin{bmatrix} 1  0  0 \\\\ 0  1  0 \\\\ 0  0  1 \\end{bmatrix}$, $C_{2z} = \\begin{bmatrix} -1  0  0 \\\\ 0  -1  0 \\\\ 0  0  1 \\end{bmatrix}$, $\\sigma_{xz} = \\begin{bmatrix} 1  0  0 \\\\ 0  -1  0 \\\\ 0  0  1 \\end{bmatrix}$, $\\sigma_{yz} = \\begin{bmatrix} -1  0  0 \\\\ 0  1  0 \\\\ 0  0  1 \\end{bmatrix}$。这个集合代表点群 $\\mathrm{C}_{2v}$，并且预期是一个群。\n-   $S_2 = \\{ I, R_{z,90}, \\sigma_{yz} \\}$，其中 $R_{z,90} = \\begin{bmatrix} 0  -1  0 \\\\ 1  0  0 \\\\ 0  0  1 \\end{bmatrix}$。这个集合在乘法下不封闭（例如，$R_{z,90} \\cdot \\sigma_{yz}$ 不在 $S_2$ 中）。\n-   $S_3 = \\{ O, N \\}$，其中 $O = \\begin{bmatrix} 0  0  0 \\\\ 0  0  0 \\\\ 0  0  0 \\end{bmatrix}$，$N = \\begin{bmatrix} 0  1  0 \\\\ 0  0  0 \\\\ 0  0  0 \\end{bmatrix}$。这个集合是封闭的，但缺少单位元。\n-   $S_4 = \\{ I, P \\}$，其中 $P = \\begin{bmatrix} 1  0  0 \\\\ 0  0  0 \\\\ 0  0  0 \\end{bmatrix}$。这个集合构成一个幺半群；它是封闭的且有单位元，但投影矩阵 $P$ 是奇异的并且缺少逆元。\n-   $S_5 = \\{ I, R_{z,120}, R_{z,240} \\}$，其中 $R_{z,120} = \\begin{bmatrix} -\\tfrac{1}{2}  -\\tfrac{\\sqrt{3}}{2}  0 \\\\ \\tfrac{\\sqrt{3}}{2}  -\\tfrac{1}{2}  0 \\\\ 0  0  1 \\end{bmatrix}$ 和 $R_{z,240} = \\begin{bmatrix} -\\tfrac{1}{2}  \\tfrac{\\sqrt{3}}{2}  0 \\\\ -\\tfrac{\\sqrt{3}}{2}  -\\tfrac{1}{2}  0 \\\\ 0  0  1 \\end{bmatrix}$。这代表循环群 $\\mathrm{C}_{3}$，并且预期是一个群。\n\n实现将包括用于每个公理检查的辅助函数，这些函数由一个主函数协调，该主函数处理每个测试集并将结果整合到所需的输出格式中。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and compute group properties.\n    \"\"\"\n    \n    # Define the tolerance for matrix equality checks.\n    tau = 1e-8\n\n    # Define common matrices used in the test sets.\n    I = np.array([[1., 0., 0.], [0., 1., 0.], [0., 0., 1.]])\n    sigma_yz = np.array([[-1., 0., 0.], [0., 1., 0.], [0., 0., 1.]])\n\n    # Define the test suites as lists of numpy arrays.\n    test_cases = [\n        # Set S1 (point group C2v)\n        [\n            I,\n            np.array([[-1., 0., 0.], [0., -1., 0.], [0., 0., 1.]]), # C2z\n            np.array([[1., 0., 0.], [0., -1., 0.], [0., 0., 1.]]), # sigma_xz\n            sigma_yz,\n        ],\n        # Set S2 (non-closed set)\n        [\n            I,\n            np.array([[0., -1., 0.], [1., 0., 0.], [0., 0., 1.]]), # R_z,90\n            sigma_yz,\n        ],\n        # Set S3 (closed, no identity)\n        [\n            np.array([[0., 0., 0.], [0., 0., 0.], [0., 0., 0.]]), # O\n            np.array([[0., 1., 0.], [0., 0., 0.], [0., 0., 0.]]), # N\n        ],\n        # Set S4 (monoid, lacks inverses)\n        [\n            I,\n            np.array([[1., 0., 0.], [0., 0., 0.], [0., 0., 0.]]), # P\n        ],\n        # Set S5 (point group C3)\n        [\n            I,\n            np.array([[-0.5, -np.sqrt(3)/2, 0.], [np.sqrt(3)/2, -0.5, 0.], [0., 0., 1.]]), # R_z,120\n            np.array([[-0.5, np.sqrt(3)/2, 0.], [-np.sqrt(3)/2, -0.5, 0.], [0., 0., 1.]]), # R_z,240\n        ],\n    ]\n\n    # --- Helper functions for axiom verification ---\n\n    def are_matrices_equal(A, B, tol):\n        \"\"\"Checks if two matrices A and B are equal within a given tolerance.\"\"\"\n        return np.max(np.abs(A - B)) = tol\n\n    def check_closure(S, tol):\n        \"\"\"Checks if the set S is closed under matrix multiplication.\"\"\"\n        for A in S:\n            for B in S:\n                product = A @ B\n                is_in_set = any(are_matrices_equal(product, C, tol) for C in S)\n                if not is_in_set:\n                    return False\n        return True\n\n    def find_identity_element(S, tol):\n        \"\"\"Finds the identity element in set S, if it exists.\"\"\"\n        for E_cand in S:\n            is_identity = all(\n                are_matrices_equal(E_cand @ A, A, tol) and \n                are_matrices_equal(A @ E_cand, A, tol)\n                for A in S\n            )\n            if is_identity:\n                return E_cand\n        return None\n\n    def check_inverses(S, E, tol):\n        \"\"\"Checks if every element in S has an inverse in S.\"\"\"\n        if E is None:\n            return False\n        for A in S:\n            has_inverse = any(\n                are_matrices_equal(A @ B, E, tol) and \n                are_matrices_equal(B @ A, E, tol)\n                for B in S\n            )\n            if not has_inverse:\n                return False\n        return True\n\n    # --- Main processing loop ---\n\n    results = []\n    for S in test_cases:\n        # Axiom 1: Closure\n        closure = check_closure(S, tau)\n\n        # Axiom 2: Associativity (always true for matrix multiplication)\n        associativity = True\n\n        # Axiom 3: Identity\n        identity_element = find_identity_element(S, tau)\n        identity_exists = identity_element is not None\n        \n        # Axiom 4: Inverses\n        inverses_exist = check_inverses(S, identity_element, tau)\n        \n        # Is it a group? (logical conjunction of all axioms)\n        is_group = closure and associativity and identity_exists and inverses_exist\n\n        results.append([is_group, closure, associativity, identity_exists, inverses_exist])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2458755"}, {"introduction": "群论在化学中最强大的应用之一是帮助我们理解分子振动，并阐释红外（IR）和拉曼（Raman）光谱。本练习 [@problem_id:2458793] 以甲烷分子（$T_d$ 对称性）为案例，让你亲手实践这一应用。你将首先确定分子的 C-H 键伸缩振动在 $T_d$ 点群的各个对称操作下如何变换，然后运用约化公式将得到的可约表示分解为不可约表示。这个过程不仅能让你掌握群论在振动分析中的核心技术，更能让你体会到如何仅利用对称性原理，就能预测哪些振动模式是光谱活性的，从而将抽象的理论与可观测的实验现象紧密联系起来。", "problem": "甲烷具有四面体对称性，其点群为$T_{d}$。考虑四个$\\mathrm{C-H}$伸缩内坐标，每个坐标沿着一个$\\mathrm{C-H}$键，它们构成一个四维向量空间。令$\\Gamma_{\\text{stretch}}$为这四个基函数在$T_{d}$点群操作下所形成的可约表示。\n\n该群的阶为$h=24$，共轭类为$E$、$8C_{3}$、$3C_{2}$、$6S_{4}$和$6\\sigma_{d}$。不可约表示及其特征标如下：\n- $A_{1}$：$1, 1, 1, 1, 1$\n- $A_{2}$：$1, 1, 1, -1, -1$\n- $E$：$2, -1, 2, 0, 0$\n- $T_{1}$：$3, 0, -1, 1, -1$\n- $T_{2}$：$3, 0, -1, -1, 1$\n\n为确定各种操作如何作用于$\\mathrm{C-H}$键，需要了解关于$T_{d}$的几何事实：每个$C_{3}$轴穿过一个$\\mathrm{C-H}$键；每个$C_{2}$和$S_{4}$轴穿过相对棱的中点；每个$\\sigma_{d}$平面包含碳原子和恰好两个氢原子。\n\n确定在$\\Gamma_{\\text{stretch}}$分解为不可约表示分量的过程中，每个不可约表示的重数。将你的最终答案表示为一个行矩阵，其中包含按顺序$\\left(A_{1}, A_{2}, E, T_{1}, T_{2}\\right)$排列的重数。无需四舍五入，也无需报告单位。", "solution": "该问题要求将基于甲烷的四个$\\mathrm{C-H}$伸缩坐标的可约表示$\\Gamma_{\\text{stretch}}$，在$T_{d}$点群内分解为其组成的不可约表示。该问题在科学上是合理的，提法明确，并包含了获得唯一解所需的所有信息。因此，我们着手进行分析。\n\n第一步是确定可约表示$\\Gamma_{\\text{stretch}}$对于$T_{d}$群的每个共轭类$R$的特征标$\\chi_{\\text{stretch}}(R)$。一个操作的特征标是在该操作下保持不变的基函数（在此情况下为四个$\\mathrm{C-H}$键矢量）的数量。\n\n基组由四个向量$r_{1}, r_{2}, r_{3}, r_{4}$组成，每个向量都沿着一个$\\mathrm{C-H}$键。我们分析每个共轭类中一个代表性操作的效果。\n\n1.  **恒等操作 ($E$)**：恒等操作使所有四个$\\mathrm{C-H}$键保持不变。因此，特征标为$4$。\n    $$\\chi_{\\text{stretch}}(E) = 4$$\n\n2.  **$C_{3}$旋转 ($8C_{3}$)**：每个$C_{3}$轴穿过碳原子和一个氢原子，即沿着一个$\\mathrm{C-H}$键。此操作使位于轴上的键保持不变，同时置换其他三个键。因此，只有一个键未移动。\n    $$\\chi_{\\text{stretch}}(C_{3}) = 1$$\n\n3.  **$C_{2}$旋转 ($3C_{2}$)**：每个$C_{2}$轴平分两个相对的$\\mathrm{H-C-H}$角，穿过碳原子但不穿过任何氢原子。例如，一个轴可能穿过$\\mathrm{H}_{1}-\\mathrm{H}_{2}$对和$\\mathrm{H}_{3}-\\mathrm{H}_{4}$对之间。绕此轴的$C_{2}$旋转将交换$\\mathrm{H}_{1}$与$\\mathrm{H}_{2}$以及$\\mathrm{H}_{3}$与$\\mathrm{H}_{4}$。因此，所有四个$\\mathrm{C-H}$键都被移动到不同位置。没有键保持不变。\n    $$\\chi_{\\text{stretch}}(C_{2}) = 0$$\n\n4.  **$S_{4}$瑕旋转 ($6S_{4}$)**：$S_{4}$轴与$C_{2}$轴重合。一个$S_{4}$操作包括一个$90^{\\circ}$旋转，然后在一个垂直于该轴的平面上进行反映。这个复杂的操作将每个氢原子移动到新位置，这意味着每个$\\mathrm{C-H}$键都被移动。\n    $$\\chi_{\\text{stretch}}(S_{4}) = 0$$\n\n5.  **$\\sigma_{d}$二面角反映 ($6\\sigma_{d}$)**：每个$\\sigma_{d}$平面包含碳原子和两个氢原子，例如$\\mathrm{H}_{1}$和$\\mathrm{H}_{2}$。与这些原子相关的两个$\\mathrm{C-H}$键（$\\mathrm{C-H}_{1}$和$\\mathrm{C-H}_{2}$）位于反映平面内，因此保持不变。另外两个键（$\\mathrm{C-H}_{3}$和$\\mathrm{C-H}_{4}$）相互反映。因此，恰好有两个键保持不变。\n    $$\\chi_{\\text{stretch}}(\\sigma_{d}) = 2$$\n\n因此，可约表示$\\Gamma_{\\text{stretch}}$的特征标集为$\\chi_{\\text{stretch}} = (4, 1, 0, 0, 2)$。\n\n下一步是使用大正交定理的约化公式来找出$\\Gamma_{\\text{stretch}}$中每个不可约表示（irrep）$i$的重数$a_{i}$：\n$$a_{i} = \\frac{1}{h} \\sum_{R} n(R) \\chi_{i}(R) \\chi_{\\text{stretch}}(R)$$\n这里，$h$是群的阶，为$24$。$n(R)$是类$R$中操作的数量，$\\chi_{i}(R)$是不可约表示$i$对类$R$的特征标。\n\n我们为每个不可约表示计算$a_{i}$：$A_{1}$、$A_{2}$、$E$、$T_{1}$和$T_{2}$。\n\n-   **对于$A_{1}$**：$\\chi(A_{1}) = (1, 1, 1, 1, 1)$\n    $$a_{A_{1}} = \\frac{1}{24} [1(4)(1) + 8(1)(1) + 3(0)(1) + 6(0)(1) + 6(2)(1)]$$\n    $$a_{A_{1}} = \\frac{1}{24} [4 + 8 + 0 + 0 + 12] = \\frac{24}{24} = 1$$\n\n-   **对于$A_{2}$**：$\\chi(A_{2}) = (1, 1, 1, -1, -1)$\n    $$a_{A_{2}} = \\frac{1}{24} [1(4)(1) + 8(1)(1) + 3(0)(1) + 6(0)(-1) + 6(2)(-1)]$$\n    $$a_{A_{2}} = \\frac{1}{24} [4 + 8 + 0 + 0 - 12] = \\frac{0}{24} = 0$$\n\n-   **对于$E$**：$\\chi(E) = (2, -1, 2, 0, 0)$\n    $$a_{E} = \\frac{1}{24} [1(4)(2) + 8(1)(-1) + 3(0)(2) + 6(0)(0) + 6(2)(0)]$$\n    $$a_{E} = \\frac{1}{24} [8 - 8 + 0 + 0 + 0] = \\frac{0}{24} = 0$$\n\n-   **对于$T_{1}$**：$\\chi(T_{1}) = (3, 0, -1, 1, -1)$\n    $$a_{T_{1}} = \\frac{1}{24} [1(4)(3) + 8(1)(0) + 3(0)(-1) + 6(0)(1) + 6(2)(-1)]$$\n    $$a_{T_{1}} = \\frac{1}{24} [12 + 0 + 0 + 0 - 12] = \\frac{0}{24} = 0$$\n\n-   **对于$T_{2}$**：$\\chi(T_{2}) = (3, 0, -1, -1, 1)$\n    $$a_{T_{2}} = \\frac{1}{24} [1(4)(3) + 8(1)(0) + 3(0)(-1) + 6(0)(-1) + 6(2)(1)]$$\n    $$a_{T_{2}} = \\frac{1}{24} [12 + 0 + 0 + 0 + 12] = \\frac{24}{24} = 1$$\n\n因此，可约表示的分解为：\n$$\\Gamma_{\\text{stretch}} = 1 A_{1} \\oplus 0 A_{2} \\oplus 0 E \\oplus 0 T_{1} \\oplus 1 T_{2} = A_{1} \\oplus T_{2}$$\n按$(A_{1}, A_{2}, E, T_{1}, T_{2})$顺序排列的不可约表示的重数为$(1, 0, 0, 0, 1)$。", "answer": "$$\\boxed{\\begin{pmatrix} 1  0  0  0  1 \\end{pmatrix}}$$", "id": "2458793"}]}