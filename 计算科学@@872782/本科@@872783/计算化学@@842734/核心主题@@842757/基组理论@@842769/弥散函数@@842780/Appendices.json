{"hands_on_practices": [{"introduction": "我们从最基础的阴离子——氢负离子（$H^-$）——开始我们的实践。这项练习将引导你通过变分法，从第一性原理出发，为描述弱束缚电子的斯莱特型轨道（用高斯函数近似）寻找最优的指数。通过这项实践，你将深入理解弥散函数的本质，即它们是如何因描述弱束缚电子的需求而产生，以及如何通过优化其“弥散度”（即指数）来最小化体系能量的。[@problem_id:2454144]", "problem": "您的任务是设计并执行一个以原子单位进行的数值实验，以在哈特里-福克水平上确定一个双电子、单中心体系的单个弥散高斯型轨道的最优指数。考虑一个闭壳层氢负离子（$H^-$）模型，其中两个电子占据相同的空间轨道。该空间轨道是位于原点的单个、归一化的原初 s 型高斯轨道 (GTO)，其指数为 $\\alpha$，由 $\\phi(\\mathbf{r};\\alpha)=N(\\alpha)\\exp(-\\alpha r^{2})$ 给出，其中 $N(\\alpha)$ 是归一化常数，$r=\\lVert \\mathbf{r}\\rVert$。完全在原子单位下进行计算，其中长度单位是玻尔 (Bohr)，能量单位是哈特里 (Hartree)。核电荷由 $Z$ 表示。\n\n定义单电子算符 $h=-\\frac{1}{2}\\nabla^{2}-\\frac{Z}{r}$ 和电子-电子排斥算符 $r_{12}^{-1}$。对于一个具有单个双占据空间轨道的闭壳层体系，作为 $\\alpha$ 的函数的哈特里-福克总能量为\n$$\nE(\\alpha)=2\\langle\\phi|h|\\phi\\rangle+\\langle\\phi\\phi|r_{12}^{-1}|\\phi\\phi\\rangle,\n$$\n其中所有积分都在 $\\mathbb{R}^{3}$ 上精确计算，$\\phi$ 表示上面定义的归一化 GTO。\n\n您的任务是编写一个完整、可运行的程序，对于每个指定的核电荷 $Z$，确定在 $\\alpha>0$ 上使 $E(\\alpha)$ 最小化的值 $\\alpha^{\\star}\\ge 0$，并返回相应的最小能量 $E(\\alpha^{\\star})$。如果在 $\\alpha>0$ 上不存在有限的最小值点，则报告在 $\\alpha\\ge 0$ 上的下确界。报告 $\\alpha^{\\star}$ 的单位为 $\\text{Bohr}^{-2}$，$E(\\alpha^{\\star})$ 的单位为 Hartree。将所有报告的浮点数四舍五入到 $8$ 位小数。\n\n使用以下核电荷（无量纲）测试组：$[1.0,\\,2.0,\\,\\frac{1}{2\\sqrt{2}},\\,0.6]$。\n\n最终输出格式：您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个元素都是一个双元素列表 $[\\alpha^{\\star},E(\\alpha^{\\star})]$，其顺序与测试组相同。例如，输出必须如下所示：\n$$\n[[a_{1},e_{1}],[a_{2},e_{2}],[a_{3},e_{3}],[a_{4},e_{4}]]\n$$\n其中每个 $a_{k}$ 和 $e_{k}$ 都四舍五入到 $8$ 位小数，且没有额外的字符或行。", "solution": "在尝试求解之前，对问题陈述进行验证。\n\n**步骤 1：提取已知条件**\n- 体系：双电子、单中心、闭壳层体系。\n- 空间轨道：一个单个、归一化的原初 s 型高斯型轨道 (GTO) $\\phi(\\mathbf{r};\\alpha)=N(\\alpha)\\exp(-\\alpha r^{2})$，以原点为中心，指数为 $\\alpha>0$。\n- 核电荷：$Z$。\n- 单电子算符：$h = -\\frac{1}{2}\\nabla^{2}-\\frac{Z}{r}$。\n- 双电子算符：$r_{12}^{-1}$。\n- 总能量表达式：$E(\\alpha) = 2\\langle\\phi|h|\\phi\\rangle + \\langle\\phi\\phi|r_{12}^{-1}|\\phi\\phi\\rangle$。\n- 任务：对于每个给定的 $Z$，在定义域 $\\alpha>0$ 上找到最小值点 $\\alpha^{\\star} \\ge 0$ 和对应的最小能量 $E(\\alpha^{\\star})$。如果不存在有限的最小值点，则报告在 $\\alpha \\ge 0$ 上的下确界。\n- 测试组：$Z \\in [1.0, 2.0, \\frac{1}{2\\sqrt{2}}, 0.6]$。\n- 单位：原子单位（玻尔，哈特里）。\n- 输出：对于每个 $Z$，报告 $[\\alpha^{\\star}, E(\\alpha^{\\star})]$，数值四舍五入到 8 位小数。\n\n**步骤 2：使用提取的已知条件进行验证**\n该问题是计算量子化学中的一个标准练习：使用最小 STO-1G 基组对一个双电子原子进行限制性哈特里-福克 (RHF) 计算。所提供的能量表达式对于具有两个电子在单个空间轨道中的闭壳层体系是正确的。算符和轨道的定义是标准的。该问题具有科学依据，提法明确，客观，并包含足够的信息以通过推导所需积分来解决。未发现科学或逻辑上的缺陷。\n\n**步骤 3：结论与行动**\n问题被判定为**有效**。将进行求解。\n\n**求解推导**\n\n体系的总能量作为高斯指数 $\\alpha$ 的函数，由下式给出：\n$$\nE(\\alpha) = 2h_{11}(\\alpha) + J_{11}(\\alpha)\n$$\n其中 $h_{11}(\\alpha) = \\langle\\phi|h|\\phi\\rangle$ 是单电子积分，$J_{11}(\\alpha) = \\langle\\phi\\phi|r_{12}^{-1}|\\phi\\phi\\rangle$ 是双电子库仑积分。空间轨道 $\\phi(\\mathbf{r};\\alpha)$ 是一个归一化的 s 型 GTO。其归一化常数 $N(\\alpha)$ 通过要求 $\\langle\\phi|\\phi\\rangle=1$ 来找到：\n$$\n\\int_{\\mathbb{R}^3} |N(\\alpha)e^{-\\alpha r^2}|^2 d\\mathbf{r} = N(\\alpha)^2 \\int_0^\\infty e^{-2\\alpha r^2} 4\\pi r^2 dr = N(\\alpha)^2 \\left(\\frac{\\pi}{2\\alpha}\\right)^{3/2} = 1\n$$\n这得到 $N(\\alpha) = (\\frac{2\\alpha}{\\pi})^{3/4}$。\n\n首先，我们评估单电子积分 $h_{11}(\\alpha) = \\langle\\phi|-\\frac{1}{2}\\nabla^2|\\phi\\rangle - Z\\langle\\phi|r^{-1}|\\phi\\rangle$。这包括动能 $T(\\alpha)$ 和核吸引能 $V_{ne}(\\alpha)$。\n一个归一化的 1s GTO 的动能积分为：\n$$\nT(\\alpha) = \\langle\\phi|-\\frac{1}{2}\\nabla^2|\\phi\\rangle = \\frac{3\\alpha}{2}\n$$\n核吸引积分为：\n$$\nV_{ne}(\\alpha) = -Z\\langle\\phi|r^{-1}|\\phi\\rangle = -Z \\left(\\frac{2\\alpha}{\\pi}\\right)^{3/2} \\int_{\\mathbb{R}^3} \\frac{e^{-2\\alpha r^2}}{r} d\\mathbf{r} = -Z \\left(\\frac{2\\alpha}{\\pi}\\right)^{3/2} \\left(\\frac{\\pi}{\\alpha}\\right) = -Z\\sqrt{\\frac{8\\alpha}{\\pi}} = -2Z\\sqrt{\\frac{2\\alpha}{\\pi}}\n$$\n因此，单电子部分为 $h_{11}(\\alpha) = \\frac{3\\alpha}{2} - 2Z\\sqrt{\\frac{2\\alpha}{\\pi}}$。\n\n接下来，我们评估双电子库仑积分 $J_{11}(\\alpha)$。这表示两个相同电荷分布 $\\rho(\\mathbf{r}) = |\\phi(\\mathbf{r})|^2$ 之间的静电排斥。\n$$\nJ_{11}(\\alpha) = \\langle\\phi\\phi|r_{12}^{-1}|\\phi\\phi\\rangle = \\iint |\\phi(\\mathbf{r}_1)|^2 \\frac{1}{r_{12}} |\\phi(\\mathbf{r}_2)|^2 d\\mathbf{r}_1 d\\mathbf{r}_2\n$$\n对于四个相同的归一化原初轨道 $\\phi(\\mathbf{r};\\alpha)$，标准公式给出：\n$$\nJ_{11}(\\alpha) = \\left(N(\\alpha)\\right)^4 \\frac{\\pi^{5/2}}{4\\alpha^{5/2}} = \\left(\\left(\\frac{2\\alpha}{\\pi}\\right)^{3/4}\\right)^4 \\frac{\\pi^{5/2}}{4\\alpha^{5/2}} = \\left(\\frac{2\\alpha}{\\pi}\\right)^3 \\frac{\\pi^{5/2}}{4\\alpha^{5/2}} = \\frac{8\\alpha^3}{\\pi^3} \\frac{\\pi^{5/2}}{4\\alpha^{5/2}} = \\frac{2\\alpha^{1/2}}{\\sqrt{\\pi}} = \\sqrt{\\frac{4\\alpha}{\\pi}}\n$$\n\n现在，我们组合总能量表达式：\n$$\nE(\\alpha) = 2h_{11}(\\alpha) + J_{11}(\\alpha) = 2\\left(\\frac{3\\alpha}{2} - 2Z\\sqrt{\\frac{2\\alpha}{\\pi}}\\right) + \\sqrt{\\frac{4\\alpha}{\\pi}}\n$$\n$$\nE(\\alpha) = 3\\alpha - 4Z\\sqrt{\\frac{2\\alpha}{\\pi}} + 2\\sqrt{\\frac{\\alpha}{\\pi}} = 3\\alpha - (4Z\\sqrt{2}-2)\\sqrt{\\frac{\\alpha}{\\pi}}\n$$\n$$\nE(\\alpha) = 3\\alpha - 2(\\sqrt{8}Z-1)\\sqrt{\\frac{\\alpha}{\\pi}}\n$$\n为了找到最优指数 $\\alpha^{\\star}$，我们必须对 $\\alpha>0$ 上的 $E(\\alpha)$ 求最小值。我们计算导数并令其为零：\n$$\n\\frac{dE}{d\\alpha} = 3 - \\frac{2(\\sqrt{8}Z-1)}{\\sqrt{\\pi}} \\frac{1}{2\\sqrt{\\alpha}} = 3 - \\frac{\\sqrt{8}Z-1}{\\sqrt{\\pi\\alpha}} = 0\n$$\n$$\n3\\sqrt{\\pi\\alpha} = \\sqrt{8}Z-1 \\implies \\sqrt{\\alpha} = \\frac{\\sqrt{8}Z-1}{3\\sqrt{\\pi}}\n$$\n只有当右边为正时，才存在具有物理意义的解 $\\alpha>0$，这要求 $\\sqrt{8}Z-1 > 0$，即 $Z > 1/\\sqrt{8} = 1/(2\\sqrt{2})$。二阶导数为 $\\frac{d^2E}{d\\alpha^2} = \\frac{\\sqrt{8}Z-1}{2\\sqrt{\\pi}}\\alpha^{-3/2}$，当 $\\sqrt{8}Z-1 > 0$ 时为正，证实了这是一个极小值。\n\n情况 1：$Z > 1/(2\\sqrt{2})$\n最优指数为：\n$$\n\\alpha^{\\star} = \\left(\\frac{\\sqrt{8}Z-1}{3\\sqrt{\\pi}}\\right)^2 = \\frac{(\\sqrt{8}Z-1)^2}{9\\pi}\n$$\n对应的最小能量为：\n$$\nE(\\alpha^{\\star}) = 3\\alpha^{\\star} - \\frac{2(\\sqrt{8}Z-1)}{\\sqrt{\\pi}}\\sqrt{\\alpha^{\\star}} = 3\\left(\\frac{(\\sqrt{8}Z-1)^2}{9\\pi}\\right) - \\frac{2(\\sqrt{8}Z-1)}{\\sqrt{\\pi}}\\left(\\frac{\\sqrt{8}Z-1}{3\\sqrt{\\pi}}\\right)\n$$\n$$\nE(\\alpha^{\\star}) = \\frac{(\\sqrt{8}Z-1)^2}{3\\pi} - \\frac{2(\\sqrt{8}Z-1)^2}{3\\pi} = -\\frac{(\\sqrt{8}Z-1)^2}{3\\pi}\n$$\n\n情况 2：$Z \\le 1/(2\\sqrt{2})$\n在这种情况下，$\\sqrt{8}Z-1 \\le 0$。导数 $\\frac{dE}{d\\alpha} = 3 - \\frac{\\sqrt{8}Z-1}{\\sqrt{\\pi\\alpha}}$ 对于 $\\alpha>0$ 总是正的。因此，$E(\\alpha)$ 是 $\\alpha$ 在 $(0, \\infty)$ 上的严格递增函数。它在这个开区间上没有最小值。问题要求的是在 $\\alpha \\ge 0$ 上的下确界。当 $\\alpha \\to 0^+$ 时，$E(\\alpha) \\to 0$。该函数在 $\\alpha=0$ 处连续，且 $E(0)=0$。因此，在定义域 $\\alpha \\ge 0$ 上的最小值为 $0$，出现在 $\\alpha^\\star=0$ 处。\n\n我们现在将这些公式应用于给定的测试组。$Z$ 的临界值是 $1/(2\\sqrt{2}) \\approx 0.35355339$。\n\n1.  $Z=1.0$：由于 $1.0 > 1/(2\\sqrt{2})$，我们使用情况 1 的公式。\n    $\\alpha^{\\star} = \\frac{(\\sqrt{8}(1.0)-1)^2}{9\\pi} \\approx 0.11823616$\n    $E(\\alpha^{\\star}) = -\\frac{(\\sqrt{8}(1.0)-1)^2}{3\\pi} \\approx -0.35470847$\n\n2.  $Z=2.0$：由于 $2.0 > 1/(2\\sqrt{2})$，我们使用情况 1 的公式。\n    $\\alpha^{\\star} = \\frac{(\\sqrt{8}(2.0)-1)^2}{9\\pi} \\approx 0.76015693$\n    $E(\\alpha^{\\star}) = -\\frac{(\\sqrt{8}(2.0)-1)^2}{3\\pi} \\approx -2.28047079$\n\n3.  $Z = 1/(2\\sqrt{2})$：这是边界情况，$Z = 1/(2\\sqrt{2})$。我们使用情况 2。\n    $\\alpha^{\\star} = 0.0$\n    $E(\\alpha^{\\star}) = 0.0$\n\n4.  $Z=0.6$：由于 $0.6 > 1/(2\\sqrt{2})$，我们使用情况 1 的公式。\n    $\\alpha^{\\star} = \\frac{(\\sqrt{8}(0.6)-1)^2}{9\\pi} \\approx 0.01718580$\n    $E(\\alpha^{\\star}) = -\\frac{(\\sqrt{8}(0.6)-1)^2}{3\\pi} \\approx -0.05155741$", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the optimal Gaussian exponent and minimum energy for a two-electron,\n    one-center system at the Hartree-Fock level.\n    \"\"\"\n    \n    # Test suite of nuclear charges Z\n    test_cases_z = [\n        1.0,\n        2.0,\n        1.0 / (2.0 * np.sqrt(2.0)),\n        0.6\n    ]\n\n    results = []\n    \n    # The critical value of Z that separates the two solution regimes.\n    z_critical = 1.0 / np.sqrt(8.0)\n\n    for z in test_cases_z:\n        if z > z_critical:\n            # For Z > 1/sqrt(8), a non-trivial minimum exists for alpha > 0.\n            # Term inside the square for alpha_star and e_star calculation.\n            term = np.sqrt(8.0) * z - 1.0\n            \n            # Optimal exponent alpha_star\n            alpha_star = (term**2) / (9.0 * np.pi)\n            \n            # Minimum energy E(alpha_star)\n            e_star = - (term**2) / (3.0 * np.pi)\n            \n        else:\n            # For Z = 1/sqrt(8), E(alpha) increases for alpha > 0.\n            # The infimum is at alpha = 0, where E(0) = 0.\n            alpha_star = 0.0\n            e_star = 0.0\n\n        results.append([round(alpha_star, 8), round(e_star, 8)])\n\n    # Format the final output string as per the problem specification.\n    # e.g., [[a1,e1],[a2,e2],...]\n    output_items = [f\"[{res[0]:.8f},{res[1]:.8f}]\" for res in results]\n    output_str = f\"[{','.join(output_items)}]\"\n    \n    print(output_str)\n\nsolve()\n```", "id": "2454144"}, {"introduction": "在理解了弥散函数对阴离子的重要性之后，一个自然的问题是：它们是否总是必需的？这项练习将通过一个紧凑的阳离子（如$Li^+$）来探讨这一问题。你将运用线性变分法，定量评估在一个紧凑的电子体系中加入弥散函数对总能量的影响，从而证明在这种情况下，这样做几乎没有益处。通过这项实践，你将建立起何时使用以及何时*不*使用弥散函数的关键直觉，从而避免不必要的计算开销。[@problem_id:2454101]", "problem": "考虑在原子单位（Hartree 原子单位）下，一个电子在有效核电荷为 $Z$ 的球对称库仑场中的单电子非相对论哈密顿算符，其表达式为 $$H = -\\dfrac{1}{2} \\nabla^2 - \\dfrac{Z}{r}$$。设一个有限维试探子空间由一组位于原点的归一化原初 $s$ 型高斯函数张成，其形式为 $\\phi_i(\\mathbf{r}) = N(\\alpha_i) \\exp(-\\alpha_i r^2)$，其中 $r = \\lVert\\mathbf{r}\\rVert$，$N(\\alpha) = \\left(\\dfrac{2 \\alpha}{\\pi}\\right)^{3/4}$。对于给定的一组指数 $\\{\\alpha_i\\}$，定义重叠矩阵 $S$，其矩阵元为 $S_{ij} = \\langle \\phi_i | \\phi_j \\rangle$，以及哈密顿矩阵 $H$，其矩阵元为 $H_{ij} = \\langle \\phi_i | \\left(-\\dfrac{1}{2} \\nabla^2 - \\dfrac{Z}{r}\\right) | \\phi_j \\rangle$。在此子空间中的基态变分能是 $H \\mathbf{c} = E S \\mathbf{c}$ 的最小广义本征值 $E$。\n\n你的任务是，使用这种变分构造，对于三种指定的有效电荷 $Z$，量化通过在一个紧凑的 $s$-高斯函数集上增加一个弥散的 $s$-高斯函数所获得的能量降低（单位为 Hartree）。对每个 $Z$ 值使用以下两种基组选择：\n- 指数为 $\\{\\alpha\\} = \\{5.0, 15.0, 45.0\\}$ 的紧凑（紧密）集。\n- 在紧凑集上增加一个弥散指数 $\\alpha_{\\text{diff}} = 0.2$ 的扩充集，即 $\\{5.0, 15.0, 45.0, 0.2\\}$。\n\n对于每种情况，计算能量差 $\\Delta E = E_{\\text{augmented}} - E_{\\text{compact}}$（单位为 Hartree），其中 $E_{\\text{compact}}$ 是从紧凑集获得的最小广义本征值，$E_{\\text{augmented}}$ 是从扩充集获得的最小广义本征值。$\\Delta E$ 的负值表示包含弥散函数降低了变分能。所有积分必须通过在三维空间 $\\mathbb{R}^3$ 上的积分来精确计算。所有能量必须以 Hartree 为单位表示，并且报告的每个 $\\Delta E$ 必须四舍五入到 $8$ 位小数。\n\n测试组（每一项都是一个独立的测试用例，具有自己的 $Z$ 值）：\n- 情况 1（代表 $\\text{Li}^+$ 的紧凑阳离子核）：$Z = 2.69$。\n- 情况 2（更紧凑的核）：$Z = 5.0$。\n- 情况 3（一个边缘情况，密度较不紧凑）：$Z = 1.0$。\n\n你的程序应生成单行输出，其中包含上述三种情况的三个结果 $\\Delta E$，按所列顺序排列，形式为一个逗号分隔的列表，并用方括号括起来，例如 $[\\Delta E_1,\\Delta E_2,\\Delta E_3]$。每个 $\\Delta E$ 必须是四舍五入到 $8$ 位小数的十进制数，并且数字必须以 Hartree 为单位。", "solution": "该问题要求计算在一个紧凑的 $s$ 型高斯基函数集上增加一个弥散函数所导致的能量降低。这是量子化学中线性变分法的一个标准应用，用于近似计算有效核电荷为 $Z$ 的单电子类氢原子的基态能量。该系统的哈密顿算符在 Hartree 原子单位下为：\n$$\nH = -\\frac{1}{2} \\nabla^2 - \\frac{Z}{r}\n$$\n其中 $-\\frac{1}{2} \\nabla^2$ 是动能算符，$-\\frac{Z}{r}$ 是描述与原子核之间库仑吸引的势能算符。\n\n根据变分原理，对于任何试探波函数 $\\Psi$，哈密顿算符的期望值是真实基态能量 $E_0$ 的一个上界。我们通过基函数 $\\phi_i$ 的线性组合来构造试探波函数：\n$$\n\\Psi = \\sum_{i=1}^{N} c_i \\phi_i\n$$\n基函数被指定为位于原点的归一化 $s$ 型高斯函数：\n$$\n\\phi_i(\\mathbf{r}) = \\left(\\frac{2\\alpha_i}{\\pi}\\right)^{3/4} \\exp(-\\alpha_i r^2)\n$$\n其中 $\\{\\alpha_i\\}$ 是一组给定的指数。\n\n对能量泛函 $E[\\Psi] = \\frac{\\langle \\Psi | H | \\Psi \\rangle}{\\langle \\Psi | \\Psi \\rangle}$ 关于系数 $c_i$ 进行最小化，可得到久期方程。由于高斯基函数不是正交的，这会形成一个广义本征值问题：\n$$\nH \\mathbf{c} = E S \\mathbf{c}\n$$\n这里，$H$ 是哈密顿矩阵，其矩阵元为 $H_{ij} = \\langle \\phi_i | H | \\phi_j \\rangle$；$S$ 是重叠矩阵，其矩阵元为 $S_{ij} = \\langle \\phi_i | \\phi_j \\rangle$；$\\mathbf{c}$ 是系数 $c_i$ 构成的向量。该方程的最小本征值 $E$ 是给定基组下对基态能量的变分近似。\n\n任务的核心是计算矩阵元 $S_{ij}$ 和 $H_{ij}$。哈密顿矩阵元可以分解为动能和势能的贡献：$H_{ij} = T_{ij} + V_{ij}$。这些矩阵元通过在全空间 $\\mathbb{R}^3$ 上积分来计算。对于两个位于原点、指数分别为 $\\alpha_i$ 和 $\\alpha_j$ 的 $s$ 型高斯函数 $\\phi_i$ 和 $\\phi_j$，这些积分的精确解析公式是众所周知的：\n\n1.  **重叠矩阵元 ($S_{ij}$):** 这两个函数之间的重叠积分是：\n    $$\n    S_{ij} = \\langle \\phi_i | \\phi_j \\rangle = \\left( \\frac{2\\sqrt{\\alpha_i \\alpha_j}}{\\alpha_i + \\alpha_j} \\right)^{3/2}\n    $$\n\n2.  **动能矩阵元 ($T_{ij}$):** 动能积分是：\n    $$\n    T_{ij} = \\left\\langle \\phi_i \\left| -\\frac{1}{2}\\nabla^2 \\right| \\phi_j \\right\\rangle = S_{ij} \\frac{3\\alpha_i \\alpha_j}{\\alpha_i + \\alpha_j}\n    $$\n    这个公式巧妙地将动能矩阵元与相应的重叠矩阵元关联起来。\n\n3.  **势能矩阵元 ($V_{ij}$):** 核吸引积分是：\n    $$\n    V_{ij} = \\left\\langle \\phi_i \\left| -\\frac{Z}{r} \\right| \\phi_j \\right\\rangle = -S_{ij} \\frac{2Z\\sqrt{\\alpha_i + \\alpha_j}}{\\sqrt{\\pi}}\n    $$\n    该矩阵元描述了电子与有效电荷为 $Z$ 的原子核之间的库仑吸引。\n\n总的哈密顿矩阵元是动能和势能部分的总和：\n$$\nH_{ij} = T_{ij} + V_{ij} = S_{ij} \\left( \\frac{3\\alpha_i \\alpha_j}{\\alpha_i + \\alpha_j} - \\frac{2Z\\sqrt{\\alpha_i + \\alpha_j}}{\\sqrt{\\pi}} \\right)\n$$\n\n对于每个指定的 $Z$ 值，计算步骤如下：\n首先，我们使用指数为 $\\{\\alpha\\} = \\{5.0, 15.0, 45.0\\}$ 的紧凑基组。利用上述公式构建一个 $3 \\times 3$ 的重叠矩阵 $S_{\\text{compact}}$ 和一个 $3 \\times 3$ 的哈密顿矩阵 $H_{\\text{compact}}$。求解广义本征值问题 $H_{\\text{compact}} \\mathbf{c} = E S_{\\text{compact}} \\mathbf{c}$，并将最小的本征值记为 $E_{\\text{compact}}$。\n\n其次，我们对扩充基组 $\\{\\alpha\\} = \\{5.0, 15.0, 45.0, 0.2\\}$ 重复此过程，该基组包含了弥散指数 $\\alpha_{\\text{diff}} = 0.2$。这将产生 $4 \\times 4$ 的矩阵 $S_{\\text{augmented}}$ 和 $H_{\\text{augmented}}$，求解相应的本征值问题得到一个新的最低能量 $E_{\\text{augmented}}$。\n\n最后，能量降低 $\\Delta E$ 按以下差值计算：\n$$\n\\Delta E = E_{\\text{augmented}} - E_{\\text{compact}}\n$$\n根据变分原理，向基组中添加一个新的线性无关函数必定会降低变分能，因此我们预期 $\\Delta E$ 为负。这种降低的幅度取决于所添加的弥散函数在多大程度上改善了对电子密度尾部的描述，而对于较小的 $Z$ 值，电子密度尾部更为延展。因此，我们预期对于 $Z=1.0$ 会有最大的能量降低（最负的 $\\Delta E$），而对于 $Z=5.0$ 能量降低最小。\n\n实现过程将构建这些矩阵，并使用一个数值线性代数库来求解广义本征值问题。对三个给定的 $Z$ 值中的每一个都执行此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef solve():\n    \"\"\"\n    Main function to solve the specified quantum chemistry problem.\n    It calculates the energy lowering from adding a diffuse Gaussian function\n    to a compact basis set for a hydrogen-like atom with different Zeff.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a distinct value of effective nuclear charge Z.\n    test_cases = [\n        2.69,  # Case 1 (Li+ like)\n        5.0,   # Case 2 (more compact core)\n        1.0,   # Case 3 (H-atom like)\n    ]\n\n    # Define the basis set exponents\n    compact_exponents = [5.0, 15.0, 45.0]\n    diffuse_exponent = 0.2\n    augmented_exponents = compact_exponents + [diffuse_exponent]\n\n    results = []\n    \n    for Z in test_cases:\n        # Calculate the ground state energy for the compact basis set\n        E_compact = calculate_ground_state_energy(compact_exponents, Z)\n        \n        # Calculate the ground state energy for the augmented basis set\n        E_augmented = calculate_ground_state_energy(augmented_exponents, Z)\n        \n        # Calculate the energy difference\n        delta_E = E_augmented - E_compact\n        \n        # Round the result to 8 decimal places as required\n        results.append(round(delta_E, 8))\n\n    # Format the final output string as specified\n    output_str = f\"[{','.join(map(str, results))}]\"\n    print(output_str)\n\ndef calculate_ground_state_energy(exponents, Z):\n    \"\"\"\n    Calculates the ground-state variational energy for a given set of Gaussian\n    exponents and effective nuclear charge Z.\n\n    Args:\n        exponents (list of float): The list of Gaussian exponents.\n        Z (float): The effective nuclear charge.\n\n    Returns:\n        float: The lowest generalized eigenvalue (ground state energy in Hartree).\n    \"\"\"\n    n_basis = len(exponents)\n    S = np.zeros((n_basis, n_basis))\n    H = np.zeros((n_basis, n_basis))\n    \n    sqrt_pi = np.sqrt(np.pi)\n\n    # Build the overlap (S) and Hamiltonian (H) matrices\n    for i in range(n_basis):\n        for j in range(n_basis):\n            alpha_i = exponents[i]\n            alpha_j = exponents[j]\n            \n            p = alpha_i + alpha_j\n            \n            # Overlap matrix element S_ij\n            # S_ij = (2 * sqrt(alpha_i * alpha_j) / p)^(3/2)\n            S_ij = (2 * np.sqrt(alpha_i * alpha_j) / p)**1.5\n            S[i, j] = S_ij\n            \n            # Kinetic energy matrix element T_ij\n            T_ij = S_ij * (3 * alpha_i * alpha_j / p)\n            \n            # Potential energy matrix element V_ij\n            V_ij = -S_ij * (2 * Z * np.sqrt(p) / sqrt_pi)\n            \n            # Hamiltonian matrix element H_ij\n            H[i, j] = T_ij + V_ij\n            \n    # Solve the generalized eigenvalue problem Hc = ESc\n    # eigh returns eigenvalues in ascending order. The first one is the ground state.\n    eigenvalues, _ = eigh(H, S)\n    ground_state_energy = eigenvalues[0]\n    \n    return ground_state_energy\n\nsolve()\n```", "id": "2454101"}, {"introduction": "在掌握了弥散函数的基本概念和适用范围后，我们将进入一个更高级和实际的应用场景。这项练习将引导你为像六氟化硫阴离子（$\\text{SF}_6^-$）这样的复杂离域阴离子，比较不同标准弥散基组（如Pople风格的`+`基组与Dunning风格的`aug-`基组）的性能。你将学习如何构建一个定量指标，超越简单的能量比较，来衡量不同基组描述离域超额电子的能力。这项练习将深化你对基组选择策略的理解，并为你处理更复杂的真实化学问题打下坚实基础。[@problem_id:2454077]", "problem": "本题要求你形式化并计算一种第一性原理度量，用以评估两类弥散基函数表示以六氟化硫阴离子（$\\text{SF}_6^-$）为模型的离域阴离子中超额电子的能力。这两类基函数是：(i) 用加号表示的Pople风格弥散函数，以及 (ii) 用前缀“aug-”表示的增广相关一致函数。分子表示为一个理想的八面体，其中一个硫原子位于原点，六个氟原子位于笛卡尔坐标 $\\pm R \\hat{x}$、$\\pm R \\hat{y}$ 和 $\\pm R \\hat{z}$ 处，其中 $R$ 是指定的键长。所有距离必须以玻尔（bohr）为单位，所有高斯指数必须以玻尔的负二次方为单位。\n\n用一个归一化的、球对称的、指数为 $\\alpha_{\\mathrm{t}}$ 且中心位于原点的s型高斯型轨道（GTO）来模拟超额电子。将此目标函数表示为 $t(\\mathbf{r})$。对于位于 $\\mathbf{R}_{a}$ 的任意中心和指数 $\\alpha_{a}$，定义一个归一化的s型高斯原函数为\n$$\n\\chi_{a}(\\mathbf{r}) = \\mathcal{N}(\\alpha_{a}) \\exp\\!\\left(-\\alpha_{a}\\,\\lVert \\mathbf{r} - \\mathbf{R}_{a}\\rVert^{2}\\right),\n$$\n其中 $\\mathcal{N}(\\alpha_{a})$ 是归一化常数，其选择需满足\n$$\n\\int_{\\mathbb{R}^{3}} \\left|\\chi_{a}(\\mathbf{r})\\right|^{2}\\, \\mathrm{d}^{3}\\mathbf{r} = 1.\n$$\n所有内积均为 $\\mathbb{R}^{3}$ 上的标准 $L^{2}$ 内积。\n\n对于一组给定的基函数 $\\{\\chi_{i}\\}_{i=1}^{n}$（通过选择如下指定的中心和指数来构建），将性能度量定义为目标函数 $t(\\mathbf{r})$ 与由 $\\{\\chi_{i}\\}_{i=1}^{n}$ 线性张成的空间中任意归一化函数之间的最大可能重叠平方。也就是说，如果 $\\mathcal{V} = \\mathrm{span}\\{\\chi_{i}\\}_{i=1}^{n}$，那么该度量为\n$$\n\\max_{\\phi \\in \\mathcal{V},\\, \\lVert \\phi \\rVert = 1} \\left|\\langle t \\mid \\phi \\rangle\\right|^{2},\n$$\n其中 $\\langle \\cdot \\mid \\cdot \\rangle$ 是 $L^{2}$ 内积，$\\lVert \\cdot \\rVert$ 是诱导范数。当 $t$ 被归一化时，该值位于区间 $[0,1]$ 内。\n\n你必须为每个测试用例比较两类基函数：\n- Pople风格弥散基组：每个氟中心上有一个指数为 $\\alpha_{\\mathrm{F}}^{\\mathrm{P}}$ 的s型弥散原函数，并且如果指定包含硫的弥散函数，则在硫上有一个指数为 $\\alpha_{\\mathrm{S}}^{\\mathrm{P}}$ 的s型弥散原函数。\n- 增广相关一致弥散基组：每个氟中心上有一个指数为 $\\alpha_{\\mathrm{F}}^{\\mathrm{A}}$ 的s型弥散原函数，并且如果指定包含硫的弥散函数，则在硫上有一个指数为 $\\alpha_{\\mathrm{S}}^{\\mathrm{A}}$ 的s型弥散原函数。\n\n对于下面的每个测试用例，计算Pople风格基组和增广相关一致基组的性能度量，然后报告其差值\n$$\n\\Delta = \\left(\\text{增广相关一致最大重叠平方}\\right) - \\left(\\text{Pople风格最大重叠平方}\\right).\n$$\n\n所有距离 $R$ 必须以玻尔为单位，所有高斯指数 $\\alpha$ 必须以玻尔的负二次方为单位，最终报告的差值 $\\Delta$ 必须以十进制浮点数形式打印，并四舍五入到小数点后六位。\n\n测试组（单位如上所述）：\n- 用例 1（通用情况，正常路径）：\n  - $R = 2.948$\n  - $\\alpha_{\\mathrm{t}} = 0.03$\n  - 两类基组均包含硫的弥散函数。\n  - Pople风格指数：$\\alpha_{\\mathrm{F}}^{\\mathrm{P}} = 0.15$, $\\alpha_{\\mathrm{S}}^{\\mathrm{P}} = 0.12$\n  - 增广指数：$\\alpha_{\\mathrm{F}}^{\\mathrm{A}} = 0.05$, $\\alpha_{\\mathrm{S}}^{\\mathrm{A}} = 0.035$\n- 用例 2（排除中心硫弥散函数的影响）：\n  - $R = 2.948$\n  - $\\alpha_{\\mathrm{t}} = 0.03$\n  - 两类基组均不包含硫的弥散函数。\n  - Pople风格指数：$\\alpha_{\\mathrm{F}}^{\\mathrm{P}} = 0.15$\n  - 增广指数：$\\alpha_{\\mathrm{F}}^{\\mathrm{A}} = 0.05$\n- 用例 3（极度弥散的目标）：\n  - $R = 2.948$\n  - $\\alpha_{\\mathrm{t}} = 0.01$\n  - 两类基组均包含硫的弥散函数。\n  - Pople风格指数：$\\alpha_{\\mathrm{F}}^{\\mathrm{P}} = 0.15$, $\\alpha_{\\mathrm{S}}^{\\mathrm{P}} = 0.12$\n  - 增广指数：$\\alpha_{\\mathrm{F}}^{\\mathrm{A}} = 0.03$, $\\alpha_{\\mathrm{S}}^{\\mathrm{A}} = 0.02$\n- 用例 4（作为边界条件的紧凑目标）：\n  - $R = 2.948$\n  - $\\alpha_{\\mathrm{t}} = 0.5$\n  - 两类基组均包含硫的弥散函数。\n  - Pople风格指数：$\\alpha_{\\mathrm{F}}^{\\mathrm{P}} = 0.3$, $\\alpha_{\\mathrm{S}}^{\\mathrm{P}} = 0.25$\n  - 增广指数：$\\alpha_{\\mathrm{F}}^{\\mathrm{A}} = 0.2$, $\\alpha_{\\mathrm{S}}^{\\mathrm{A}} = 0.15$\n\n你的程序必须计算与四个用例相对应的四个 $\\Delta$ 值，将每个值四舍五入到小数点后六位，并生成单行输出，其中包含用方括号括起来并以逗号分隔的结果，例如 $[\\Delta_{1},\\Delta_{2},\\Delta_{3},\\Delta_{4}]$，其中每个 $\\Delta_{k}$ 都显示到小数点后六位。", "solution": "我们在一个使用归一化s型高斯型轨道（GTO）的单电子、基投影框架内，将此比较形式化。每个中心位于 $\\mathbf{R}_{a}$ 且指数为 $\\alpha_{a}$ 的基元函数为\n$$\n\\chi_{a}(\\mathbf{r}) = \\mathcal{N}(\\alpha_{a}) \\exp\\!\\left(-\\alpha_{a}\\,\\lVert \\mathbf{r} - \\mathbf{R}_{a}\\rVert^{2}\\right),\n$$\n其归一化常数由以下要求确定\n$$\n\\int_{\\mathbb{R}^{3}} \\left|\\chi_{a}(\\mathbf{r})\\right|^{2}\\, \\mathrm{d}^{3}\\mathbf{r} = 1.\n$$\n对于三维s型高斯函数，归一化常数为\n$$\n\\mathcal{N}(\\alpha) = \\left(\\frac{2\\alpha}{\\pi}\\right)^{3/4}.\n$$\n目标函数是一个中心在原点、指数为 $\\alpha_{\\mathrm{t}}$ 的归一化s型高斯函数，\n$$\nt(\\mathbf{r}) = \\mathcal{N}(\\alpha_{\\mathrm{t}})\\exp\\!\\left(-\\alpha_{\\mathrm{t}}\\,\\lVert \\mathbf{r}\\rVert^{2}\\right).\n$$\n\n给定一个有限的基函数集合 $\\{\\chi_{i}\\}_{i=1}^{n}$，我们寻求目标函数 $t$ 与由 $\\{\\chi_{i}\\}$ 张成的空间 $\\mathcal{V} = \\mathrm{span}\\{\\chi_{i}\\}$ 中的任意归一化函数之间的最大重叠平方。$\\mathcal{V}$ 中的任意函数 $\\phi$ 都可以写成 $\\phi = \\sum_{i=1}^{n} c_{i}\\chi_{i}$。重叠平方为\n$$\n\\left|\\langle t \\mid \\phi \\rangle\\right|^{2} = \\left|\\sum_{i=1}^{n} c_{i} \\langle t \\mid \\chi_{i} \\rangle \\right|^{2}.\n$$\n施加归一化约束 $\\lVert \\phi \\rVert^{2} = \\langle \\phi \\mid \\phi \\rangle = 1$ 会得到一个约束最大化问题。定义重叠矩阵 $S \\in \\mathbb{R}^{n\\times n}$，其元素为\n$$\nS_{ij} = \\langle \\chi_{i} \\mid \\chi_{j} \\rangle,\n$$\n并定义向量 $b \\in \\mathbb{R}^{n}$，其元素为\n$$\nb_{i} = \\langle \\chi_{i} \\mid t \\rangle.\n$$\n根据在由 $S$ 诱导的度量下的柯西-施瓦茨不等式，在 $\\mathcal{V}$ 中所有归一化函数 $\\phi$ 上的最大重叠平方由下式给出\n$$\n\\max_{\\phi \\in \\mathcal{V},\\ \\lVert \\phi \\rVert = 1} \\left|\\langle t \\mid \\phi \\rangle\\right|^{2} = b^{\\mathsf{T}} S^{-1} b,\n$$\n条件是 $S$ 必须是正定的，对于位于不同中心且具有正指数的线性无关高斯原函数，该条件成立。最佳系数为 $c^{\\star} = S^{-1} b$（不计归一化因子），其值 $b^{\\mathsf{T}} S^{-1} b$ 等于 $\\langle t \\mid P \\mid t \\rangle$，其中 $P$ 是在 $L^{2}$ 内积下到 $\\mathcal{V}$ 上的正交投影算子。\n\n因此，计算过程简化为通过s型高斯函数的解析重叠积分来计算 $S$ 和 $b$。对于指数为 $\\alpha_{i}$ 和 $\\alpha_{j}$、中心分别位于 $\\mathbf{R}_{i}$ 和 $\\mathbf{R}_{j}$ 的原函数，其通用的s-s高斯重叠积分为\n$$\n\\langle \\chi_{i} \\mid \\chi_{j} \\rangle = \\mathcal{N}(\\alpha_{i})\\,\\mathcal{N}(\\alpha_{j}) \\left(\\frac{\\pi}{\\alpha_{i}+\\alpha_{j}}\\right)^{3/2} \\exp\\!\\left(-\\frac{\\alpha_{i}\\alpha_{j}}{\\alpha_{i}+\\alpha_{j}}\\,\\lVert \\mathbf{R}_{i} - \\mathbf{R}_{j}\\rVert^{2}\\right).\n$$\n类似地，基函数与目标函数之间的重叠积分可以通过在同一表达式中代入 $\\alpha_{j} \\leftarrow \\alpha_{\\mathrm{t}}$ 和 $\\mathbf{R}_{j} \\leftarrow \\mathbf{0}$ 来获得。\n\n对于每个测试用例，我们：\n- 将硫原子置于 $\\mathbf{0}$，六个氟原子置于 $\\pm R \\hat{x}$、$\\pm R \\hat{y}$ 和 $\\pm R \\hat{z}$ 处，其中给定的 $R$ 以玻尔为单位。\n- 构建两个基组，一个用于Pople风格指数，另一个用于增广相关一致指数，并根据指定包含或排除硫的弥散原函数。\n- 使用上述解析公式构建重叠矩阵 $S$ 和向量 $b$。\n- 对每个基组计算最大重叠平方 $b^{\\mathsf{T}} S^{-1} b$。\n- 计算 $\\Delta$ 作为增广相关一致值与Pople风格值之间的差。\n- 将每个 $\\Delta$ 四舍五入到小数点后六位。\n\n所有量的量纲都是一致的：位置以玻尔为单位，指数以玻尔的负二次方为单位，重叠积分为无量纲。对于归一化的目标，所得的最大重叠平方位于 $[0,1]$ 区间内，$\\Delta$ 也继承了这一尺度。最终输出为包含列表 $[\\Delta_{1},\\Delta_{2},\\Delta_{3},\\Delta_{4}]$ 的单行，其中每个条目都四舍五入到小数点后六位。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef norm_const(alpha):\n    # Normalization constant for 3D s-type Gaussian: (2a/pi)^(3/4)\n    return (2.0 * alpha / np.pi) ** 0.75\n\ndef overlap_ss(alpha_i, Ri, alpha_j, Rj):\n    # Analytic overlap between two normalized s-type Gaussians\n    Ri = np.asarray(Ri, dtype=float)\n    Rj = np.asarray(Rj, dtype=float)\n    Rij2 = float(np.dot(Ri - Rj, Ri - Rj))\n    N = norm_const(alpha_i) * norm_const(alpha_j)\n    pref = (np.pi / (alpha_i + alpha_j)) ** 1.5\n    expo = np.exp(- (alpha_i * alpha_j / (alpha_i + alpha_j)) * Rij2)\n    return N * pref * expo\n\ndef max_squared_overlap(target_alpha, basis):\n    # basis: list of tuples (alpha, center)\n    n = len(basis)\n    if n == 0:\n        return 0.0\n    S = np.empty((n, n), dtype=float)\n    b = np.empty(n, dtype=float)\n    # Target centered at origin\n    Rt = np.zeros(3, dtype=float)\n    for i, (ai, Ri) in enumerate(basis):\n        b[i] = overlap_ss(ai, Ri, target_alpha, Rt)\n        for j, (aj, Rj) in enumerate(basis):\n            if j < i:\n                S[i, j] = S[j, i]\n            else:\n                S[i, j] = overlap_ss(ai, Ri, aj, Rj)\n    # Solve S c = b; maximum squared overlap = b^T c\n    # Guard against numerical issues by using solve; clip result into [0,1]\n    c = np.linalg.solve(S, b)\n    o2 = float(np.dot(b, c))\n    # Numerical safety\n    if o2 < 0.0:\n        o2 = 0.0\n    if o2 > 1.0:\n        o2 = 1.0\n    return o2\n\ndef build_centers(R):\n    # Six fluorine positions in an octahedral arrangement around origin\n    return [\n        np.array([ R, 0.0, 0.0]),\n        np.array([-R, 0.0, 0.0]),\n        np.array([0.0,  R, 0.0]),\n        np.array([0.0, -R, 0.0]),\n        np.array([0.0, 0.0,  R]),\n        np.array([0.0, 0.0, -R]),\n    ]\n\ndef build_basis(R, alpha_F, alpha_S=None, include_S=True):\n    basis = []\n    # Fluorine centers\n    for RF in build_centers(R):\n        basis.append((alpha_F, RF))\n    # Optional sulfur at origin\n    if include_S and (alpha_S is not None):\n        basis.append((alpha_S, np.zeros(3)))\n    return basis\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case is a dict specifying R, alpha_t, inclusion of S, and exponents for both families.\n    test_cases = [\n        # Case 1\n        {\n            \"R\": 2.948,\n            \"alpha_t\": 0.03,\n            \"include_S\": True,\n            \"pople\": {\"alpha_F\": 0.15, \"alpha_S\": 0.12},\n            \"aug\":   {\"alpha_F\": 0.05, \"alpha_S\": 0.035},\n        },\n        # Case 2\n        {\n            \"R\": 2.948,\n            \"alpha_t\": 0.03,\n            \"include_S\": False,\n            \"pople\": {\"alpha_F\": 0.15, \"alpha_S\": None},\n            \"aug\":   {\"alpha_F\": 0.05, \"alpha_S\": None},\n        },\n        # Case 3\n        {\n            \"R\": 2.948,\n            \"alpha_t\": 0.01,\n            \"include_S\": True,\n            \"pople\": {\"alpha_F\": 0.15, \"alpha_S\": 0.12},\n            \"aug\":   {\"alpha_F\": 0.03, \"alpha_S\": 0.02},\n        },\n        # Case 4\n        {\n            \"R\": 2.948,\n            \"alpha_t\": 0.5,\n            \"include_S\": True,\n            \"pople\": {\"alpha_F\": 0.3, \"alpha_S\": 0.25},\n            \"aug\":   {\"alpha_F\": 0.2, \"alpha_S\": 0.15},\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        R = case[\"R\"]\n        alpha_t = case[\"alpha_t\"]\n        include_S = case[\"include_S\"]\n\n        # Build Pople-style basis\n        p_alpha_F = case[\"pople\"][\"alpha_F\"]\n        p_alpha_S = case[\"pople\"][\"alpha_S\"]\n        basis_pople = build_basis(R, p_alpha_F, p_alpha_S, include_S)\n\n        # Build augmented corr.-consistent basis\n        a_alpha_F = case[\"aug\"][\"alpha_F\"]\n        a_alpha_S = case[\"aug\"][\"alpha_S\"]\n        basis_aug = build_basis(R, a_alpha_F, a_alpha_S, include_S)\n\n        # Compute maximum squared overlaps\n        o2_pople = max_squared_overlap(alpha_t, basis_pople)\n        o2_aug = max_squared_overlap(alpha_t, basis_aug)\n\n        delta = o2_aug - o2_pople\n        # Round to six decimal places in the output formatting\n        results.append(delta)\n\n    # Final print statement in the exact required format with six decimals.\n    formatted = \",\".join(f\"{x:.6f}\" for x in results)\n    print(f\"[{formatted}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2454077"}]}