{"hands_on_practices": [{"introduction": "要真正理解自洽场 (SCF) 方法，最好的方式莫过于亲手实现它。本练习将指导你为一个简单的双原子阳离子 HeH⁺，在一个最小基组下，从头开始编写一个完整的限制性哈特里-福克 (RHF) SCF 程序。通过这个实践，你将具体地了解福克矩阵、密度矩阵和分子轨道是如何通过迭代不断优化，最终达到“自洽”状态的，从而牢固掌握 SCF 算法的核心机制。[@problem_id:2465550]", "problem": "实现一个程序，在由两个以原子为中心的基函数组成的最小基组中，根据闭壳层限制性 Hartree–Fock 自洽场 (SCF) 程序，计算双原子阳离子氢化氦（记为 HeH$^+$）的分子轨道系数的演化过程。原子轨道基组由两个函数组成：索引为 $0$ 的在氦上，索引为 $1$ 的在氢上。分子轨道在此原子轨道基组中展开为系数 $\\mathbf{c}$ 的列向量。所有量均使用原子单位。\n\n给定如下所列的重叠矩阵 $\\mathbf{S}$、单电子核心哈密顿矩阵 $\\mathbf{h}$ 以及非零双电子互斥积分 $(\\mu \\nu \\lvert \\lambda \\sigma)$，对于密度矩阵 $\\mathbf{P}$，闭壳层 Fock 矩阵 $\\mathbf{F}$ 定义为\n$$\nF_{\\mu \\nu} \\;=\\; h_{\\mu \\nu} \\;+\\; \\sum_{\\lambda,\\sigma} P_{\\lambda \\sigma}\\,\\Big[\\,(\\mu \\nu \\lvert \\lambda \\sigma)\\;-\\;\\tfrac{1}{2}\\,(\\mu \\sigma \\lvert \\lambda \\nu)\\,\\Big].\n$$\n占据分子轨道的系数向量 $\\mathbf{c}$（对于能量最低的轨道）求解广义本征值问题\n$$\n\\mathbf{F}\\,\\mathbf{c} \\;=\\; \\epsilon\\,\\mathbf{S}\\,\\mathbf{c}, \\quad \\text{其归一化条件为 } \\mathbf{c}^{\\mathsf{T}} \\mathbf{S}\\, \\mathbf{c} \\;=\\; 1,\n$$\n闭壳层密度矩阵为\n$$\n\\mathbf{P} \\;=\\; 2\\,\\mathbf{c}\\,\\mathbf{c}^{\\mathsf{T}}.\n$$\n\n使用以下数据，这些数据为 HeH$^+$ 定义了一个一致的最小基组模型：\n- 重叠矩阵\n$$\n\\mathbf{S} \\;=\\; \\begin{bmatrix} 1  0.2 \\\\ 0.2  1 \\end{bmatrix}\n$$\n- 单电子核心哈密顿量\n$$\n\\mathbf{h} \\;=\\; \\begin{bmatrix} -2.0  -0.2 \\\\ -0.2  -1.0 \\end{bmatrix}\n$$\n- 使用化学家标记法 $(\\mu \\nu \\lvert \\lambda \\sigma)$ 的非零双电子互斥积分如下：\n$$\n(0\\,0 \\lvert 0\\,0) \\,=\\, 1.0,\\quad\n(1\\,1 \\lvert 1\\,1) \\,=\\, 0.7,\\quad\n(0\\,0 \\lvert 1\\,1) \\,=\\, (1\\,1 \\lvert 0\\,0) \\,=\\, 0.6,\\quad\n(0\\,1 \\lvert 0\\,1) \\,=\\, (0\\,1 \\lvert 1\\,0) \\,=\\, (1\\,0 \\lvert 0\\,1) \\,=\\, (1\\,0 \\lvert 1\\,0) \\,=\\, 0.2,\n$$\n且任何无法通过置换上述积分的索引得到的积分均为零。\n\n对于给定的初始占据轨道系数猜测值 $\\mathbf{c}^{(0)}$（不必归一化），将初始密度定义为\n$$\n\\mathbf{P}^{(0)} \\;=\\; 2\\,\\tilde{\\mathbf{c}}^{(0)}\\,\\tilde{\\mathbf{c}}^{(0)\\mathsf{T}},\n$$\n其中 $\\tilde{\\mathbf{c}}^{(0)}$ 是 $\\mathbf{c}^{(0)}$ 归一化后满足 $\\tilde{\\mathbf{c}}^{(0)\\mathsf{T}} \\mathbf{S}\\,\\tilde{\\mathbf{c}}^{(0)} = 1$ 的向量。在其后的每次 SCF 迭代 $k \\to k+1$ 中，获得新的占据轨道 $\\mathbf{c}^{(k+1)}$，作为 $\\mathbf{F}[\\mathbf{P}^{(k)}]$ 的广义本征问题的归一化最低本征值解。施加相位约定\n$$\n\\tilde{\\mathbf{c}}^{(k+1)} \\;\\leftarrow\\; \\operatorname{sign}\\!\\big( \\tilde{\\mathbf{c}}^{(k+1)\\mathsf{T}} \\mathbf{S}\\, \\tilde{\\mathbf{c}}^{(k)} \\big)\\,\\tilde{\\mathbf{c}}^{(k+1)},\n$$\n以确保系数的连续性，其中 $\\tilde{\\mathbf{c}}^{(k)}$ 表示在迭代 $k$ 时的 $\\mathbf{S}$-归一化占据轨道。形成原始的更新密度 $\\mathbf{P}^{(k+1),\\mathrm{raw}} = 2\\,\\tilde{\\mathbf{c}}^{(k+1)} \\tilde{\\mathbf{c}}^{(k+1)\\mathsf{T}}$。应用参数为 $\\alpha \\in [0,1)$ 的线性混合来定义\n$$\n\\mathbf{P}^{(k+1)} \\;=\\; (1-\\alpha)\\,\\mathbf{P}^{(k+1),\\mathrm{raw}} \\;+\\; \\alpha\\,\\mathbf{P}^{(k)}.\n$$\n当逐元素的无穷范数满足\n$$\n\\|\\mathbf{P}^{(k+1)} - \\mathbf{P}^{(k)}\\|_{\\infty}  \\tau,\n$$\n时，达到收敛，其中阈值为 $\\tau = 10^{-10}$；或者达到 $200$ 次迭代的硬性上限时。\n\n任务。对于下方的每个测试用例，从给定的初始猜测值和混合参数开始，计算并记录在迭代 $k$ 时的占据分子轨道的氦基函数系数 $c_0^{(k)}$ 的序列，包括初始的归一化猜测值 $c_0^{(0)}$ 以及其后每次迭代的一个值，直到收敛（或达到 $200$ 次迭代上限）。在每一步都使用上述相位约定。将每个记录的 $c_0^{(k)}$ 四舍五入到 $6$ 位小数。\n\n测试套件。使用以下四个测试用例，每个用例由混合参数 $\\alpha$ 和初始猜测向量 $\\mathbf{c}^{(0)}$ 指定：\n- 用例 A (理想路径)：$\\alpha = 0.0$, $\\mathbf{c}^{(0)} = \\begin{bmatrix} 1.0 \\\\ 0.0 \\end{bmatrix}$。\n- 用例 B (备用起点)：$\\alpha = 0.0$, $\\mathbf{c}^{(0)} = \\begin{bmatrix} 0.0 \\\\ 1.0 \\end{bmatrix}$。\n- 用例 C (阻尼混合)：$\\alpha = 0.5$, $\\mathbf{c}^{(0)} = \\begin{bmatrix} 0.6 \\\\ 0.8 \\end{bmatrix}$。\n- 用例 D (边缘用例，强阻尼)：$\\alpha = 0.9$, $\\mathbf{c}^{(0)} = \\begin{bmatrix} -0.7 \\\\ 0.3 \\end{bmatrix}$。\n\n最终输出格式。你的程序应该生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表，列表中的每个元素本身是该测试用例的、四舍五入后的 $c_0^{(k)}$ 值的、用方括号括起来的、以逗号分隔的列表，并按 A, B, C, D 的顺序排列。例如，一个包含两个假设用例的输出看起来会像 `[[0.123456,0.234567],[0.345678,0.456789]]`。你的实际程序必须以这种嵌套格式精确地打印所有四个用例的列表。", "solution": "提交分析的问题陈述是要求为双原子阳离子 HeH$^+$ 实现闭壳层限制性 Hartree-Fock (RHF) 自洽场 (SCF) 程序。必须对该问题进行验证。\n\n### 第 1 步：提取已知条件\n问题以原子单位提供了以下量和定义：\n- 基组：最小基组，函数 $0$ 在氦上，函数 $1$ 在氢上。\n- 重叠矩阵：$\\mathbf{S} = \\begin{bmatrix} 1  0.2 \\\\ 0.2  1 \\end{bmatrix}$。\n- 核心哈密顿矩阵：$\\mathbf{h} = \\begin{bmatrix} -2.0  -0.2 \\\\ -0.2  -1.0 \\end{bmatrix}$。\n- 化学家标记法中的非零双电子互斥积分 (ERI)：\n  $(0\\,0 \\lvert 0\\,0) = 1.0$,\n  $(1\\,1 \\lvert 1\\,1) = 0.7$,\n  $(0\\,0 \\lvert 1\\,1) = (1\\,1 \\lvert 0\\,0) = 0.6$,\n  $(0\\,1 \\lvert 0\\,1) = (0\\,1 \\lvert 1\\,0) = (1\\,0 \\lvert 0\\,1) = (1\\,0 \\lvert 1\\,0) = 0.2$。\n- Fock 矩阵：$F_{\\mu \\nu} = h_{\\mu \\nu} + \\sum_{\\lambda,\\sigma} P_{\\lambda \\sigma}\\,\\Big[\\,(\\mu \\nu \\lvert \\lambda \\sigma)\\;-\\;\\tfrac{1}{2}\\,(\\mu \\sigma \\lvert \\lambda \\nu)\\,\\Big]$。\n- 密度矩阵：对于单个占据轨道，$\\mathbf{P} = 2\\,\\mathbf{c}\\,\\mathbf{c}^{\\mathsf{T}}$。\n- Roothaan-Hall 方程：$\\mathbf{F}\\,\\mathbf{c} = \\epsilon\\,\\mathbf{S}\\,\\mathbf{c}$，归一化条件为 $\\mathbf{c}^{\\mathsf{T}} \\mathbf{S}\\, \\mathbf{c} = 1$。\n- SCF 迭代过程：\n  1. 初始猜测值 $\\mathbf{c}^{(0)}$ 经 $\\mathbf{S}$-归一化为 $\\tilde{\\mathbf{c}}^{(0)}$ 以形成 $\\mathbf{P}^{(0)} = 2\\,\\tilde{\\mathbf{c}}^{(0)}\\,\\tilde{\\mathbf{c}}^{(0)\\mathsf{T}}$。\n  2. 对于 $k \\ge 0$，求解 $\\mathbf{F}[\\mathbf{P}^{(k)}]$ 的最低能量本征向量，记为 $\\tilde{\\mathbf{c}}^{(k+1)}$。\n  3. 应用相位约定：$\\tilde{\\mathbf{c}}^{(k+1)} \\leftarrow \\operatorname{sign}(\\tilde{\\mathbf{c}}^{(k+1)\\mathsf{T}} \\mathbf{S}\\, \\tilde{\\mathbf{c}}^{(k)})\\,\\tilde{\\mathbf{c}}^{(k+1)}$。\n  4. 形成原始密度：$\\mathbf{P}^{(k+1),\\mathrm{raw}} = 2\\,\\tilde{\\mathbf{c}}^{(k+1)} \\tilde{\\mathbf{c}}^{(k+1)\\mathsf{T}}$。\n  5. 应用线性混合：$\\mathbf{P}^{(k+1)} = (1-\\alpha)\\,\\mathbf{P}^{(k+1),\\mathrm{raw}} + \\alpha\\,\\mathbf{P}^{(k)}$。\n- 收敛准则：$\\|\\mathbf{P}^{(k+1)} - \\mathbf{P}^{(k)}\\|_{\\infty}  \\tau = 10^{-10}$。\n- 迭代上限：$200$。\n- 测试用例：提供了四对 $(\\alpha, \\mathbf{c}^{(0)})$。\n- 要求输出：每次迭代中占据轨道的系数 $c_0$ 序列，四舍五入到 6 位小数。\n\n### 第 2 步：验证已知条件\n根据所需标准对问题进行评估。\n1.  **科学基础**：该问题描述了标准的 RHF-SCF 方法，这是计算量子化学的基石。Fock 矩阵、密度矩阵和 Roothaan-Hall 系统的方程是该理论对于一个闭壳层双电子体系的正确表述。\n2.  **适定性**：该问题定义了一个完整的迭代算法，包括初始条件、每一步的精确更新规则、确保本征向量唯一性的清晰相位约定，以及一个明确的收敛准则。使用线性混合（阻尼）是确保或加速收敛的标准技术。\n3.  **客观性**：该问题以精确的数学和算法术语陈述，没有任何主观性。\n4.  **一致性**：所有提供的数据和方程都是自洽且一致的。Fock 矩阵的定义虽然对交换项 $(\\mu \\sigma \\lvert \\lambda \\nu)$ 使用了一个稍微不常见的表示法，但证明对于给定的积分集合，它等价于标准形式 $(\\mu \\lambda \\lvert \\nu \\sigma)$，并确保 Fock 矩阵保持对称，这是一个物理要求。因此，该表述是内部一致且物理上合理的。\n5.  **完整性**：该问题提供了所有必要的数值数据（$\\mathbf{S}$, $\\mathbf{h}$, ERI 值）、算法参数（$\\alpha$, $\\tau$, 迭代上限）和初始状态，以执行所有测试用例的计算。\n\n### 第 3 步：结论\n该问题是**有效的**。它是一个定义明确、科学合理且自洽的计算任务。继续进行求解是合理的。\n\n### 求解\n目标是使用自洽场方法，在指定的最小基组内为 HeH$^+$ 阳离子求解 Roothaan-Hall 方程。HeH$^+$ 是一个双电子体系，因此在基态下，这两个电子占据能量最低的分子轨道 (MO)。\n\n分子轨道 $\\psi_i$ 表示为原子轨道 (LCAO) $\\phi_\\mu$ 的线性组合，$\\psi_i = \\sum_{\\mu} c_{\\mu i} \\phi_\\mu$。对于我们的双基函数系统（$\\mu \\in \\{0, 1\\}$），占据轨道系数形成一个向量 $\\mathbf{c} = \\begin{bmatrix} c_0 \\\\ c_1 \\end{bmatrix}$。SCF 程序迭代地优化这些系数，直到它们产生的电子场与生成它们的场相一致。\n\n算法流程如下：\n\n**1. 初始化**\n首先，我们构建双电子互斥积分的四维张量，$\\text{ERI}_{\\mu\\nu\\lambda\\sigma} = (\\mu \\nu \\lvert \\lambda \\sigma)$。该张量使用提供的非零值及其固有的置换对称性填充：$(\\mu\\nu|\\lambda\\sigma) = (\\nu\\mu|\\lambda\\sigma) = (\\mu\\nu|\\sigma\\lambda) = (\\lambda\\sigma|\\mu\\nu)$。所有其他元素均为零。\n\n对于给定的测试用例，从一个初始猜测向量 $\\mathbf{c}^{(0)}$ 开始，我们计算其 $\\mathbf{S}$-范数：$N = \\sqrt{\\mathbf{c}^{(0)\\mathsf{T}} \\mathbf{S}\\, \\mathbf{c}^{(0)}}$。归一化的初始系数向量为 $\\tilde{\\mathbf{c}}^{(0)} = \\mathbf{c}^{(0)} / N$。初始的氦基函数系数 $c_0^{(0)} = \\tilde{c}_0^{(0)}$ 是记录的第一个值。由此，形成初始密度矩阵：$\\mathbf{P}^{(0)} = 2\\,\\tilde{\\mathbf{c}}^{(0)}\\,\\tilde{\\mathbf{c}}^{(0)\\mathsf{T}}$。因子 2 是因为单个占据的空间轨道中有两个电子。\n\n**2. SCF 迭代循环**\n迭代过程开始，以 $k=0, 1, 2, \\dots$ 为索引。在每次迭代 $k$ 中，我们有密度矩阵 $\\mathbf{P}^{(k)}$ 和上一步的系数向量 $\\tilde{\\mathbf{c}}^{(k)}$。\n\n_a. 构建 Fock 矩阵_\nFock 矩阵 $\\mathbf{F}^{(k)}$ 被构建为单电子核心哈密顿量 $\\mathbf{h}$ 和双电子项 $\\mathbf{G}^{(k)}$ 的和：$\\mathbf{F}^{(k)} = \\mathbf{h} + \\mathbf{G}^{(k)}$。矩阵 $\\mathbf{G}^{(k)}$ 表示平均的电子-电子互斥作用，使用密度矩阵 $\\mathbf{P}^{(k)}$ 和 ERI 张量计算得出：\n$$\nG_{\\mu \\nu}^{(k)} \\;=\\; \\sum_{\\lambda,\\sigma} P^{(k)}_{\\lambda \\sigma}\\,\\Big[\\,(\\mu \\nu \\lvert \\lambda \\sigma)\\;-\\;\\tfrac{1}{2}\\,(\\mu \\sigma \\lvert \\lambda \\nu)\\,\\Big]\n$$\n此操作可以使用张量缩并高效实现，例如，使用 `numpy.einsum`。\n\n_b. 求解 Roothaan-Hall 方程_\nSCF 迭代的核心是求解广义本征值问题 $\\mathbf{F}^{(k)}\\mathbf{c} = \\epsilon \\mathbf{S} \\mathbf{c}$。由于 $\\mathbf{F}^{(k)}$ 和 $\\mathbf{S}$ 都是对称矩阵，且 $\\mathbf{S}$ 是正定的，这个问题可以使用数值库（例如 `scipy.linalg.eigh`）可靠地求解。求解结果得到一组本征值（轨道能）$\\epsilon_i$ 和对应的本征向量（MO 系数）$\\mathbf{c}_i$。我们选择对应于最低本征值的本征向量，它代表占据分子轨道。我们称此本征向量为 $\\mathbf{c}^{(k+1)}_{\\text{raw}}$。`scipy.linalg.eigh` 函数方便地返回已经归一化以满足 $\\mathbf{c}^{\\mathsf{T}}\\mathbf{S}\\mathbf{c} = 1$ 的本征向量。\n\n_c. 相位校正_\n本征向量在相差一个符号的情况下是唯一的。为确保系数的连续演化，我们强制与前一次迭代的向量 $\\tilde{\\mathbf{c}}^{(k)}$ 保持一致的相位：\n$$\n\\tilde{\\mathbf{c}}^{(k+1)} = \\operatorname{sign}\\big( (\\mathbf{c}^{(k+1)}_{\\text{raw}})^{\\mathsf{T}} \\mathbf{S}\\, \\tilde{\\mathbf{c}}^{(k)} \\big)\\,\\mathbf{c}^{(k+1)}_{\\text{raw}}\n$$\n如果新向量与旧向量在 $\\mathbf{S}$ 度量下的重叠为负，则新向量的符号被翻转。这个经过相位校正的向量的氦基函数分量 $c_0^{(k+1)} = \\tilde{c}_0^{(k+1)}$ 被记录下来。\n\n_d. 密度矩阵更新与混合_\n根据更新后的系数计算一个新的“原始”密度矩阵：$\\mathbf{P}^{(k+1),\\mathrm{raw}} = 2\\,\\tilde{\\mathbf{c}}^{(k+1)}\\,\\tilde{\\mathbf{c}}^{(k+1)\\mathsf{T}}$。为提高收敛稳定性，此原始密度与前一次迭代的密度使用混合参数 $\\alpha$ 进行混合：\n$$\n\\mathbf{P}^{(k+1)} = (1-\\alpha)\\,\\mathbf{P}^{(k+1),\\mathrm{raw}} + \\alpha\\,\\mathbf{P}^{(k)}\n$$\n\n**3. 收敛性检查**\n如果新旧密度矩阵之间的逐元素最大绝对差值低于阈值 $\\tau=10^{-10}$，则认为迭代收敛：\n$$\n\\|\\mathbf{P}^{(k+1)} - \\mathbf{P}^{(k)}\\|_{\\infty} = \\max_{i,j} |P_{ij}^{(k+1)} - P_{ij}^{(k)}|  \\tau\n$$\n如果满足此条件，SCF 循环终止。否则，过程从步骤 2a 用新的密度矩阵 $\\mathbf{P}^{(k+1)}$ 开始重复。如果在 200 次迭代内未达到收敛，则过程停止。\n\n将这整个过程应用于问题陈述中指定的四个测试用例中的每一个，以生成所需的系数 $c_0$ 序列。", "answer": "```python\nimport numpy as np\nimport scipy.linalg\n\ndef solve():\n    \"\"\"\n    Implements the RHF-SCF procedure for HeH+ in a minimal basis\n    and computes the evolution of the MO coefficients for four test cases.\n    \"\"\"\n    \n    # --- Problem Data ---\n    S = np.array([[1.0, 0.2],\n                  [0.2, 1.0]], dtype=np.float64)\n    \n    h = np.array([[-2.0, -0.2],\n                  [-0.2, -1.0]], dtype=np.float64)\n\n    # Two-electron repulsion integral (ERI) tensor in chemists' notation\n    # ERI[mu, nu, lam, sig] = (mu nu | lam sig)\n    ERI = np.zeros((2, 2, 2, 2), dtype=np.float64)\n    ERI[0, 0, 0, 0] = 1.0\n    ERI[1, 1, 1, 1] = 0.7\n    ERI[0, 0, 1, 1] = 0.6\n    ERI[1, 1, 0, 0] = 0.6\n    # From (01|01) = (01|10) = (10|01) = (10|10) = 0.2\n    ERI[0, 1, 0, 1] = 0.2\n    ERI[1, 0, 0, 1] = 0.2\n    ERI[0, 1, 1, 0] = 0.2\n    ERI[1, 0, 1, 0] = 0.2\n    \n    # SCF parameters\n    convergence_threshold = 1e-10\n    max_iterations = 200\n\n    # Test suite\n    test_cases = [\n        {'alpha': 0.0, 'c_initial': np.array([1.0, 0.0])},  # Case A\n        {'alpha': 0.0, 'c_initial': np.array([0.0, 1.0])},  # Case B\n        {'alpha': 0.5, 'c_initial': np.array([0.6, 0.8])},  # Case C\n        {'alpha': 0.9, 'c_initial': np.array([-0.7, 0.3])}, # Case D\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        alpha = case['alpha']\n        c_unnorm = case['c_initial']\n        c0_sequence = []\n\n        # --- Step 0: Initialization ---\n        # S-normalize the initial guess vector\n        norm_sq = c_unnorm.T @ S @ c_unnorm\n        c_k = c_unnorm / np.sqrt(norm_sq)\n        \n        # Record the initial c0 value (rounded)\n        c0_sequence.append(c_k[0])\n\n        # Form initial density matrix\n        P_k = 2.0 * np.outer(c_k, c_k)\n\n        # --- SCF Iteration Loop ---\n        for i in range(max_iterations):\n            # Store old density for convergence check and mixing\n            P_old = P_k\n\n            # --- Step 1: Build Fock Matrix ---\n            # G_munu = sum_ls P_ls * [(munu|ls) - 0.5 * (mus|ln)]\n            # J[mu,nu] = sum_ls P_ls * (munu|ls)\n            J = np.einsum('ls,mnls->mn', P_old, ERI)\n            # K[mu,nu] = sum_ls P_ls * (mus|ln)\n            K = np.einsum('ls,msln->mn', P_old, ERI)\n            \n            G = J - 0.5 * K\n            F = h + G\n\n            # --- Step 2: Solve Generalized Eigenvalue Problem ---\n            # F c = e S c\n            # eigh returns S-normalized eigenvectors sorted by eigenvalue\n            eigvals, eigvecs = scipy.linalg.eigh(F, S)\n            \n            # Select eigenvector for the lowest energy orbital\n            c_k_plus_1 = eigvecs[:, 0]\n\n            # --- Step 3: Phase Convention ---\n            # Enforce sign consistency with the previous iteration's coefficients\n            overlap = c_k_plus_1.T @ S @ c_k\n            if overlap  0.0:\n                c_k_plus_1 *= -1.0\n            \n            # Record new c0 value\n            c0_sequence.append(c_k_plus_1[0])\n\n            # Update orbital coefficients for next phase check\n            c_k = c_k_plus_1\n\n            # --- Step 4: Update Density Matrix with Mixing ---\n            P_raw = 2.0 * np.outer(c_k, c_k)\n            P_k = (1.0 - alpha) * P_raw + alpha * P_old\n\n            # --- Step 5: Check for Convergence ---\n            max_diff = np.max(np.abs(P_k - P_old))\n            if max_diff  convergence_threshold:\n                break\n        \n        # Round all collected coefficients to 6 decimal places for final output\n        all_results.append([round(val, 6) for val in c0_sequence])\n\n    # Format the final output string as specified\n    formatted_cases = []\n    for case_results in all_results:\n        # Format each number to 6 decimal places.\n        formatted_nums = [f\"{val:.6f}\" for val in case_results]\n        formatted_cases.append(f\"[{','.join(formatted_nums)}]\")\n    final_output = f\"[{','.join(formatted_cases)}]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "2465550"}, {"introduction": "在掌握了基本的 SCF 实现之后，我们将探讨一个更复杂的场景，这揭示了平均场理论的一个深刻而有趣的特性。尽管 SCF 方法非常强大，但它有时会产生一些有悖于直觉的结果。本练习利用一个对称双势阱模型，演示了 SCF 迭代过程如何可能“打破”系统的内在对称性，并收敛到一个局域化的解，这突显了初始猜测在决定最终结果时的关键作用。[@problem_id:2465549]", "problem": "您的任务是实现一个最小化的、完全自包含的自洽场 (SCF) 模拟，该模拟能捕捉到一个对称性破缺的平均场解如何在一个对称双势阱模型中出现并使迭代陷入其中。该模型是一个双位点系统，在最小基组 $\\{\\phi_L,\\phi_R\\}$ 中描述，该基组代表左、右势阱上的定域函数。考虑两个电子处于闭壳层构型（一个双占据空间轨道）。所有量纲均为无量纲。\n\n起始点与定义：\n- 在 $\\{\\phi_L,\\phi_R\\}$ 基组中，单电子核心哈密頓量 $H_{\\mathrm{core}}$ 为\n$$\nH_{\\mathrm{core}} \\;=\\; \\begin{pmatrix} 0  -t \\\\ -t  0 \\end{pmatrix}, \\quad t>0.\n$$\n- 平均场 (类Fock) 矩阵为\n$$\nF[P] \\;=\\; H_{\\mathrm{core}} + V[P],\n$$\n其中反馈项为\n$$\nV[P] \\;=\\; \\begin{pmatrix}\n- g m  0 \\\\\n0  + g m\n\\end{pmatrix}, \\quad m \\equiv P_{LL} - P_{RR},\n$$\n其中 $P$ 是原子轨道基组中的单粒子密度矩阵。标量 $g \\ge 0$ 是控制非线性反馈的耦合强度。布居数不平衡量 $m$ 用于量化左右不对稱性。\n- 在一个闭壳层、双电子、单轨道模型中，密度矩阵为\n$$\nP \\;=\\; 2\\, \\mathbf{c}\\,\\mathbf{c}^{\\top}, \\qquad \\mathbf{c} = \\begin{pmatrix} c_L \\\\ c_R \\end{pmatrix}, \\quad \\|\\mathbf{c}\\|_2=1,\n$$\n其中 $\\mathbf{c}$ 是已占据分子轨道在 $\\{\\phi_L,\\phi_R\\}$ 基组中的系数向量。因此 $P_{LL} = 2 c_L^2$ 且 $P_{RR} = 2 c_R^2$，而 $m = 2(c_L^2 - c_R^2)$。\n\n需要实现的SCF迭代过程：\n1. 根据一个不平衡种子 $\\varepsilon$ 初始化已占据轨道的系数 $\\mathbf{c}^{(0)}$：\n$$\n\\mathbf{c}^{(0)} \\;\\propto\\; \\begin{pmatrix} \\sqrt{0.5 + \\varepsilon} \\\\ \\sqrt{0.5 - \\varepsilon} \\end{pmatrix}, \\quad \\|\\mathbf{c}^{(0)}\\|_2=1,\n$$\n然后设置 $P^{(0)} = 2\\,\\mathbf{c}^{(0)} \\mathbf{c}^{(0)\\top}$。\n2. 在第 $k$ 次迭代时，计算 $m^{(k)} = P_{LL}^{(k)} - P_{RR}^{(k)}$，构建 $F^{(k)} = H_{\\mathrm{core}} + V[P^{(k)}]$，并求解这个 $2\\times 2$ 的本征问题以获得能量最低的归一化本征向量 $\\mathbf{v}^{(k)}$。\n3. 构建新的密度矩阵 $P_{\\mathrm{new}}^{(k)} = 2\\,\\mathbf{v}^{(k)}\\mathbf{v}^{(k)\\top}$。\n4. 使用参数 $\\alpha \\in (0,1]$ 进行线性密度混合：\n$$\nP^{(k+1)} \\;=\\; (1-\\alpha)\\,P^{(k)} + \\alpha\\,P_{\\mathrm{new}}^{(k)}.\n$$\n5. 收敛判据：如果 Frobenius 范数满足 $\\|P^{(k+1)} - P^{(k)}\\|_{F}  \\tau$，或者达到最大迭代次数 $N_{\\max}$，则停止。报告最终的不平衡量 $m^{(\\mathrm{final})} = P_{LL}^{(\\mathrm{final})} - P_{RR}^{(\\mathrm{final})}$。\n\n您的任务：\n- 实现上述SCF迭代过程。\n- 对下面列出的每个测试用例，运行SCF并返回最终不平衡量 $m^{(\\mathrm{final})}$，四舍五入至六位小数。\n- 目的是为了展示，对于足够强的反馈耦合 $g$，即使 $H_{\\mathrm{core}}$ 是对称的，SCF迭代也可能收敛到一个对称性破缺解（$m^{(\\mathrm{final})} \\neq 0$）并陷入其中。\n\n测试组（所有参数均为无量纲）：\n1. $(t,g,\\alpha,\\varepsilon,N_{\\max},\\tau) = (1.0,\\;0.2,\\;0.5,\\; +0.01,\\; 200,\\; 10^{-12})$.\n2. $(t,g,\\alpha,\\varepsilon,N_{\\max},\\tau) = (1.0,\\;1.0,\\;0.5,\\; +0.001,\\; 200,\\; 10^{-12})$.\n3. $(t,g,\\alpha,\\varepsilon,N_{\\max},\\tau) = (1.0,\\;1.0,\\;0.5,\\; -0.001,\\; 200,\\; 10^{-12})$.\n4. $(t,g,\\alpha,\\varepsilon,N_{\\max},\\tau) = (1.0,\\;1.0,\\;0.5,\\; 0.0,\\; 200,\\; 10^{-12})$.\n5. $(t,g,\\alpha,\\varepsilon,N_{\\max},\\tau) = (1.0,\\;0.51,\\;0.5,\\; +0.001,\\; 200,\\; 10^{-12})$.\n\n最终输出格式：\n- 您的程序应产生单行输出，其中包含五个测试用例的结果，格式为方括号内以逗号分隔的列表，例如，\n$$\n[\\text{m\\_final\\_1},\\text{m\\_final\\_2},\\text{m\\_final\\_3},\\text{m\\_final\\_4},\\text{m\\_final\\_5}],\n$$\n其中每个 $\\text{m\\_final\\_i}$ 是最终的不平衡量，四舍五入到六位小数，并表示为无单位的浮点数。", "solution": "所提出的问题是计算量子化学中一个有效且定义明确的练习。它是一个极簡但富有启发性的模型，用于演示自洽场 (SCF) 框架内的自发对称性破缺现象，这是多体物理和化学中的一个核心概念。该问题在科学上是合理的，其参数是完整且一致的，并且程序在算法上是明确的。因此，我们将着手提供一个完整的解决方案。\n\n该问题要求为一个由定域原子轨道最小基组 $\\{\\phi_L, \\phi_R\\}$ 描述的双电子、双位点系统实现一个SCF程序。目标是找到单粒子密度矩阵 $P$ 的自洽解。\n\n问题的核心在于类Fock矩阵 $F[P]$ 的结构，它决定了有效的单粒子哈密頓量：\n$$\nF[P] \\;=\\; H_{\\mathrm{core}} + V[P] \\;=\\; \\begin{pmatrix}\n0  -t \\\\\n-t  0\n\\end{pmatrix} + \\begin{pmatrix}\n- g m  0 \\\\\n0  + g m\n\\end{pmatrix} \\;=\\; \\begin{pmatrix}\n- g m  -t \\\\\n-t  + g m\n\\end{pmatrix}\n$$\n此处，$t  0$ 是动能跃迁参数，它允许电子在左 ($L$) 和右 ($R$) 位点之间隧穿，有利于离域。$V[P]$ 项代表简化的电子-电子相互作用，其中耦合参数 $g \\ge 0$ 控制非线性反馈机制的强度。这种反馈取决于布居数不平衡量 $m = P_{LL} - P_{RR}$。一个非零的不平衡量 $m \\neq 0$ 会在两个位点之间产生有效势差，使一个位点变得更具吸引力 ($-gm$)，而另一个位点变得更具排斥性 ($+gm$)。这种反馈机制在能量上倾向于定域化。\n\n$t$ 的离域效应与 $g$ 的定域效应之间的竞争是产生有趣物理现象的原因。SCF程序是一种迭代方法，用于寻找该系统的稳态，其中生成Fock矩阵 $F[P]$ 的密度矩阵 $P$ 反过来又是由同一个 $F[P]$ 的基态本征向量产生的。\n\n不平衡量 $m$ 的自洽条件可以被推导出来。给定一个由输入不平衡量 $m_{\\mathrm{in}}$ 构建的Fock矩阵，其能量最低的归一化本征向量 $\\mathbf{c} = (c_L, c_R)^\\top$ 会产生一个输出不平衡量 $m_{\\mathrm{out}} = 2(c_L^2 - c_R^2)$。$F[P]$ 的本征值为 $\\lambda_{\\pm} = \\pm \\sqrt{t^2 + (gm_{\\mathrm{in}})^2}$。对于最低本征值 $\\lambda_{-} = -\\sqrt{t^2 + (gm_{\\mathrm{in}})^2}$，其本征向量的分量可以证明满足：\n$$\nc_L^2 = \\frac{1}{2}\\left(1 + \\frac{gm_{\\mathrm{in}}}{\\sqrt{t^2+(gm_{\\mathrm{in}})^2}}\\right), \\quad c_R^2 = \\frac{1}{2}\\left(1 - \\frac{gm_{\\mathrm{in}}}{\\sqrt{t^2+(gm_{\\mathrm{in}})^2}}\\right)\n$$\n这导致输出不平衡量为：\n$$\nm_{\\mathrm{out}} = 2(c_L^2 - c_R^2) = \\frac{2gm_{\\mathrm{in}}}{\\sqrt{t^2+(gm_{\\mathrm{in}})^2}}\n$$\n一个自洽解是这个映射的一个不动点，即 $m = m_{\\mathrm{in}} = m_{\\mathrm{out}}$。这给出了方程：\n$$\nm = \\frac{2gm}{\\sqrt{t^2+(gm)^2}}\n$$\n一个平凡解总是 $m=0$。这对应于电子密度均匀分布的对称态 ($c_L^2 = c_R^2 = 0.5$)。如果 $m \\neq 0$，我们可以两边同除以 $m$ 来找到其他解：\n$$\n1 = \\frac{2g}{\\sqrt{t^2+(gm)^2}} \\implies t^2+g^2m^2 = (2g)^2 \\implies m^2 = \\frac{4g^2-t^2}{g^2} = 4 - \\left(\\frac{t}{g}\\right)^2\n$$\n这些对称性破缺解 $m = \\pm \\sqrt{4 - (t/g)^2}$ 仅当 $g > t/2$ 时才为实数且非零。对于 $t=1.0$，这个临界点是 $g_c = 0.5$。\n- 如果 $g \\le g_c$，只存在对称解 $m=0$。\n- 如果 $g  g_c$，存在三个解：对称解 $m=0$（此解变得不稳定）和两个稳定、简并的对称性破缺解 $m \\neq 0$。\n\n问题中指定的SCF算法是寻找这些稳定解之一的数值程序。\n\n**算法步骤：**\n\n1.  **初始化**：我们从轨道系数的初始猜测 $\\mathbf{c}^{(0)}$ 开始，它由一个小的对称性破缺种子 $\\varepsilon$ 定义。一个正的 $\\varepsilon$ 会轻微增加左边位点的布居数，而一个负的 $\\varepsilon$ 则相反。\n    $$\n    \\mathbf{c}^{(0)} = \\begin{pmatrix} \\sqrt{0.5 + \\varepsilon} \\\\ \\sqrt{0.5 - \\varepsilon} \\end{pmatrix}\n    $$\n    该向量已经是归一化的，因为 $(\\sqrt{0.5+\\varepsilon})^2 + (\\sqrt{0.5-\\varepsilon})^2 = 1.0$。初始密度矩阵为 $P^{(0)} = 2 \\mathbf{c}^{(0)}{\\mathbf{c}^{(0)}}^\\top$。这产生的初始不平衡量为 $m^{(0)} = 2((0.5+\\varepsilon) - (0.5-\\varepsilon)) = 4\\varepsilon$。\n\n2.  **迭代 ($k$)**：该过程迭代进行。\n    - 计算不平衡量 $m^{(k)} = P_{LL}^{(k)} - P_{RR}^{(k)}$。\n    - 使用 $m^{(k)}$、$t$ 和 $g$ 构建Fock矩阵 $F^{(k)}$。\n    - 求解 $2 \\times 2$ Hermitian矩阵 $F^{(k)}$ 的本征系统。这会得到两个本征值及其对应的本征向量。我们选择与最低本征值对应的本征向量 $\\mathbf{v}^{(k)}$。\n    - 根据此本征向量构建一个新的密度矩阵：$P_{\\mathrm{new}}^{(k)} = 2 \\mathbf{v}^{(k)}{\\mathbf{v}^{(k)}}^\\top$。\n\n3.  **密度混合**：为了稳定收敛，下一次迭代的密度矩阵 $P^{(k+1)}$ 通过旧密度和新密度的线性混合形成：\n    $$\n    P^{(k+1)} = (1-\\alpha)P^{(k)} + \\alpha P_{\\mathrm{new}}^{(k)}\n    $$\n    参数 $\\alpha \\in (0, 1]$ 用于抑制迭代过程中可能出现的振荡。\n\n4.  **收敛**：循环继续，直到连续两次迭代之间密度矩阵的变化量小于阈值 $\\tau$（通过Frobenius范数 $\\|P^{(k+1)} - P^{(k)}\\|_F$ 衡量）。如果达到最大迭代次数 $N_{\\max}$，过程也会停止。\n\n最终报告的值是来自收敛密度矩阵的不平衡量 $m^{(\\mathrm{final})}$。我们将实现此程序来解决给定的测试用例。根据我们的分析，预期是对于 $g  g_c=0.5$ 的情况，最终状态将取决于初始种子 $\\varepsilon$ 的符号，收敛到两个稳定的对称性破缺解之一。对于 $g \\le g_c$ 的情况，它将收敛到对称态 $m=0$。特殊情况 $\\varepsilon=0$ 从不稳定的不动点（对于 $g  g_c$）开始，在没有数值噪音的情况下，应该会保持在该点。", "answer": "```python\nimport numpy as np\n\ndef run_scf(t, g, alpha, epsilon, n_max, tau):\n    \"\"\"\n    Performs a Self-Consistent Field (SCF) iteration for a two-site model.\n\n    Args:\n        t (float): Hopping parameter.\n        g (float): Coupling strength for nonlinear feedback.\n        alpha (float): Linear mixing parameter for density matrix update.\n        epsilon (float): Initial imbalance seed.\n        n_max (int): Maximum number of iterations.\n        tau (float): Convergence threshold for the Frobenius norm of the density matrix change.\n\n    Returns:\n        float: The final converged population imbalance 'm'.\n    \"\"\"\n    # 1. Initialization\n    # The problem statement ensures that c0 is already normalized.\n    c0_L = np.sqrt(0.5 + epsilon)\n    c0_R = np.sqrt(0.5 - epsilon)\n    c0 = np.array([c0_L, c0_R])\n    \n    # P = 2 * c * c^T. np.outer(c, c) computes c * c^T.\n    p_k = 2 * np.outer(c0, c0)\n\n    # Define the core Hamiltonian\n    h_core = np.array([[0.0, -t], [-t, 0.0]])\n\n    # 2. SCF Iteration Loop\n    for _ in range(n_max):\n        # Calculate imbalance 'm' from the current density matrix P_k\n        m_k = p_k[0, 0] - p_k[1, 1]\n        \n        # Assemble the Fock-like matrix F[P] = H_core + V[P]\n        # V[P] is a diagonal matrix with elements [-g*m, +g*m]\n        v_p = np.array([[-g * m_k, 0.0], [0.0, g * m_k]])\n        f_k = h_core + v_p\n        \n        # Solve the 2x2 eigenproblem for F_k\n        # numpy.linalg.eigh is for Hermitian matrices and sorts eigenvalues in ascending order.\n        eigenvalues, eigenvectors = np.linalg.eigh(f_k)\n        \n        # The lowest-energy eigenvector is the first column of the eigenvectors matrix.\n        v_k = eigenvectors[:, 0]\n        \n        # Form the new density matrix P_new\n        p_new = 2 * np.outer(v_k, v_k)\n        \n        # Apply linear density mixing\n        p_k_plus_1 = (1 - alpha) * p_k + alpha * p_new\n        \n        # Check for convergence using the Frobenius norm of the difference matrix\n        diff_norm = np.linalg.norm(p_k_plus_1 - p_k, 'fro')\n        \n        # Update the density matrix for the next iteration\n        p_k = p_k_plus_1\n        \n        if diff_norm  tau:\n            break\n            \n    # After the loop, calculate the final imbalance from the converged density matrix\n    m_final = p_k[0, 0] - p_k[1, 1]\n    \n    return m_final\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Format: (t, g, alpha, epsilon, n_max, tau)\n    test_cases = [\n        (1.0, 0.2, 0.5, +0.01, 200, 1e-12),\n        (1.0, 1.0, 0.5, +0.001, 200, 1e-12),\n        (1.0, 1.0, 0.5, -0.001, 200, 1e-12),\n        (1.0, 1.0, 0.5, 0.0, 200, 1e-12),\n        (1.0, 0.51, 0.5, +0.001, 200, 1e-12),\n    ]\n\n    results = []\n    for params in test_cases:\n        t, g, alpha, epsilon, n_max, tau = params\n        m_final = run_scf(t, g, alpha, epsilon, n_max, tau)\n        # Round the result to six decimal places as requested.\n        results.append(round(m_final, 6))\n\n    # Format the final output as a comma-separated list in square brackets.\n    # Using f-string formatting to ensure standard float representation.\n    results_str = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```", "id": "2465549"}, {"introduction": "自洽场计算的最终目标是获得对化学体系的深刻洞见，而不仅仅是输出一堆数字。本练习将 SCF 的数值结果与基本的化学原理联系起来。我们将使用一个线性氢链模型，任务不仅是执行 SCF 计算，更重要的是分析最终得到的分子轨道，特别是它们的节面结构。通过这种方式，你将看到即使在考虑了电子相互作用的情况下，计算结果如何反映了轨道能量和成键理论的基本原则。[@problem_id:2465579]", "problem": "考虑一个由四个氢原子组成的线性链，该链在一个最小正交归一的原子轨道基组 $\\{|\\chi_1\\rangle,|\\chi_2\\rangle,|\\chi_3\\rangle,|\\chi_4\\rangle\\}$ 中建模，其中 $|\\chi_i\\rangle$ 以沿链顺序排列的原子 $i$ 为中心。假设每个位点有一个空间轨道，每个空间轨道有两个自旋态，总共有 $4$ 个电子（闭壳层，自旋限制）。使用单带 Hubbard 型电子结构模型，其包含以下组成部分：\n\n- 单电子项由在位能 $\\varepsilon_i$（对角元）和最近邻跃迁 $t_{i,i+1}$（$i$ 和 $i+1$ 之间的非对角元）给出，所有能量均以电子伏特 (eV) 表示。\n- 在位电子排斥参数 $U_i$（以 eV 为单位）。\n- 自洽场 (SCF) 问题在此基组中由限制性 Hartree-Fock 平均场不动点定义。令 $D$ 表示在位点基组中自旋求和的单粒子密度矩阵，$F(D)$ 表示相应的 Fock 矩阵。在针对在位相互作用 Hubbard 模型的限制性 Hartree-Fock 近似中，Fock 矩阵是三对角的，其形式为\n  - $F_{ii}(D)=\\varepsilon_i + U_i\\,\\frac{n_i}{2}$，其中 $n_i=D_{ii}$ 是总在位布居数，\n  - 对于最近邻，$F_{i,i+1}=F_{i+1,i}=t_{i,i+1}$，\n  - 所有其他矩阵元均为 $0$。\n自洽时的自旋求和密度矩阵为 $D = 2\\sum_{p\\in\\text{occ}} \\mathbf{c}_p \\mathbf{c}_p^\\top$，其中 $\\mathbf{c}_p$ 是 $F(D)$ 的正交归一特征向量，与 $2$ 个最低的特征值相关联（每个轨道双占据），上标 $\\top$ 表示转置。\n\n收敛后，四个正则分子轨道是收敛的 $F$ 矩阵的四个实数归一化特征向量 $\\mathbf{c}_1,\\mathbf{c}_2,\\mathbf{c}_3,\\mathbf{c}_4$，按轨道能递增的顺序排列。对于每个分子轨道，将节点数定义为沿链的连续系数之间的符号变化次数：\n给定 $\\mathbf{c}=(c_1,c_2,c_3,c_4)$，其节点数是满足 $c_i c_{i+1}\\le 0$ 的索引 $i\\in\\{1,2,3\\}$ 的数量。$\\mathbf{c}$ 的总体相位是任意的，不影响节点数。\n\n任务：对于下面的每个参数集，计算上述定义的收敛的限制性 Hartree-Fock 解，并报告四个正则分子轨道（按轨道能递增排序）的节点数列表。\n\n所有能量必须以电子伏特 (eV) 为单位。要求的输出是整数（节点数），无单位。\n\n测试集（每个案例指定 $(\\varepsilon_1,\\varepsilon_2,\\varepsilon_3,\\varepsilon_4)$、$(t_{12},t_{23},t_{34})$ 和 $(U_1,U_2,U_3,U_4)$）：\n- 案例 A（对称相互作用链）：$(0,0,0,0)$、$(-1.0,-1.0,-1.0)$、$(2.0,2.0,2.0,2.0)$。\n- 案例 B（对称非相互作用链）：$(0,0,0,0)$、$(-1.0,-1.0,-1.0)$、$(0.0,0.0,0.0,0.0)$。\n- 案例 C（一端不对称的在位能）：$(0.5,0,0,0)$、$(-1.0,-1.0,-1.0)$、$(2.0,2.0,2.0,2.0)$。\n- 案例 D（非均匀键合）：$(0,0,0,0)$、$(-1.5,-0.5,-1.0)$、$(2.0,2.0,2.0,2.0)$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个条目对应一个测试案例，并且本身是一个包含四个整数的列表，给出四个收敛的正则分子轨道（按轨道能递增排序）的节点数。例如，一个包含两个假设案例的输出应如下所示：`[[0,1,2,3],[0,1,1,2]]`。", "solution": "所提出的问题是在限制性 Hartree-Fock (RHF) 近似下自洽场 (SCF) 方法的一个有效且适定的应用。它涉及一个由单带 Hubbard 型哈密顿量描述的四个氢原子线性链的简化但科学上合理的模型。所有参数、定义和目标都得到了清晰客观的定义，从而可以直接进行数值求解。\n\n任务是求解一个具有 $4$ 个电子（闭壳层情况）的 $4$-位点系统的 RHF 方程。这涉及为单粒子密度矩阵 $D$ 和相应的 Fock 矩阵 $F(D)$ 寻找一个自洽解。该解将通过实施迭代 SCF 程序来获得。\n\n设正交归一的原子轨道基组为 $\\{|\\chi_1\\rangle, |\\chi_2\\rangle, |\\chi_3\\rangle, |\\chi_4\\rangle\\}$。在此基组中，Fock 矩阵 $F$ 和密度矩阵 $D$ 表示为 $4 \\times 4$ 矩阵。\n\nFock 矩阵 $F$ 由其矩阵元定义：\n$$\nF_{ij} = H^{\\text{core}}_{ij} + G_{ij}(D)\n$$\n其中 $H^{\\text{core}}$ 包含单电子项（在位能和跃迁），$G(D)$ 以平均场的方式包含双电子项（电子-电子排斥）。\n\n根据问题描述：\n- Fock 矩阵的对角元由 $F_{ii}(D) = \\varepsilon_i + U_i \\frac{n_i}{2}$ 给出，其中 $\\varepsilon_i$ 是在位能，$U_i$ 是在位排斥参数，$n_i = D_{ii}$ 是位点 $i$ 上的电子布居数。\n- 最近邻的非对角元为 $F_{i,i+1} = F_{i+1,i} = t_{i,i+1}$，其中 $t_{i,i+1}$ 是跃迁积分。\n- 所有其他非对角元均为零。\n\n这定义了一个三对角的 Fock 矩阵：\n$$\nF(D) = \\begin{pmatrix}\n\\varepsilon_1 + \\frac{U_1}{2}D_{11}  t_{12}  0  0 \\\\\nt_{12}  \\varepsilon_2 + \\frac{U_2}{2}D_{22}  t_{23}  0 \\\\\n0  t_{23}  \\varepsilon_3 + \\frac{U_3}{2}D_{33}  t_{34} \\\\\n0  0  t_{34}  \\varepsilon_4 + \\frac{U_4}{2}D_{44}\n\\end{pmatrix}\n$$\n\nSCF 程序是一个迭代过程，旨在找到一个密度矩阵 $D$，使其与它所生成的 Fock 矩阵相一致。步骤如下：\n\n1.  **初始化**：需要一个密度矩阵 $D^{(0)}$ 的初始猜测。一个常用且有效的选择是从非相互作用问题的解开始，这等同于使用核心哈密顿量 $H^{\\text{core}}$（即所有 $U_i = 0$ 时的 Fock 矩阵）作为初始 Fock 矩阵 $F^{(0)}$。\n\n2.  **迭代循环**：对于每次迭代 $k = 0, 1, 2, \\dots$：\n    a.  **求解 Roothaan-Hall 方程**：求解当前 Fock 矩阵 $F^{(k)}$ 的特征值问题：\n        $$\n        F^{(k)} \\mathbf{c}_p = \\epsilon_p \\mathbf{c}_p\n        $$\n        由于基组是正交归一的，这是一个标准的矩阵对角化问题。这将产生四个实数特征值 $\\epsilon_p$（轨道能）和四个相应的正交归一特征向量 $\\mathbf{c}_p$（分子轨道系数）。特征向量按特征值递增的顺序排序：$\\epsilon_1 \\le \\epsilon_2 \\le \\epsilon_3 \\le \\epsilon_4$。\n\n    b.  **构建新的密度矩阵**：对于 $4$ 个电子，能量最低的两个空间轨道 $\\mathbf{c}_1$ 和 $\\mathbf{c}_2$ 是双占据的。新的自旋求和密度矩阵 $D^{(\\text{new})}$ 由这些占据轨道构建：\n        $$\n        D^{(\\text{new})} = 2 \\sum_{p=1}^{2} \\mathbf{c}_p \\mathbf{c}_p^\\top\n        $$\n        以矩阵形式表示，如果 $C_{\\text{occ}}$ 是一个 $4 \\times 2$ 的矩阵，其列为 $\\mathbf{c}_1$ 和 $\\mathbf{c}_2$，则 $D^{(\\text{new})} = 2 C_{\\text{occ}} C_{\\text{occ}}^\\top$。\n\n    c.  **检查收敛性**：当密度矩阵在迭代之间不再有显著变化时，过程即为收敛。应用一个收敛准则，例如检查新旧密度矩阵元素之间的最大绝对差值是否小于一个很小的容差 $\\delta$：\n        $$\n        \\max_{i,j} |D^{(\\text{new})}_{ij} - D^{(k)}_{ij}|  \\delta\n        $$\n        如果收敛，则循环终止。\n\n    d.  **准备下一次迭代**：如果未收敛，则形成一个新的密度矩阵 $D^{(k+1)}$。为防止振荡并改善收敛性，通常采用简单的混合方法：\n        $$\n        D^{(k+1)} = \\alpha D^{(\\text{new})} + (1-\\alpha) D^{(k)}\n        $$\n        其中 $\\alpha$ 是一个混合参数（$0  \\alpha \\le 1$）。然后使用 $D^{(k+1)}$ 的对角元构建一个新的 Fock 矩阵 $F^{(k+1)}$：\n        $$\n        F^{(k+1)}_{ii} = \\varepsilon_i + \\frac{U_i}{2} D^{(k+1)}_{ii}\n        $$\n\n3.  **SCF 后计算**：一旦 SCF 程序收敛到最终的密度矩阵 $D_{\\text{conv}}$ 和 Fock 矩阵 $F_{\\text{conv}}$，最终的正则分子轨道 $\\mathbf{c}_1, \\mathbf{c}_2, \\mathbf{c}_3, \\mathbf{c}_4$ 就是 $F_{\\text{conv}}$ 的特征向量，按其对应的能量特征值排序。对于每个特征向量 $\\mathbf{c}_p = (c_{1p}, c_{2p}, c_{3p}, c_{4p})^\\top$，计算其节点数。节点数是连续系数之间符号变化的次数，定义为满足条件 $c_{ip} c_{i+1,p} \\le 0$ 的索引 $i \\in \\{1, 2, 3\\}$ 的数量。此程序将应用于四个测试案例中的每一个。\n\n对于非相互作用情况（案例 B，其中所有 $U_i=0$），Fock 矩阵就是核心哈密顿量，并且不依赖于密度。SCF 程序在一步内收敛。对于相互作用情况（A、C、D），通常需要多次迭代才能达到自洽。下面的实现为每个指定的参数集执行此算法。", "answer": "```python\nimport numpy as np\n\ndef compute_node_count(vector: np.ndarray) -> int:\n    \"\"\"\n    Computes the node count of a vector representing a molecular orbital.\n    A node is a sign change between consecutive coefficients.\n    The condition c_i * c_{i+1} = 0 includes cases where a coefficient is zero.\n    \"\"\"\n    count = 0\n    for i in range(len(vector) - 1):\n        if vector[i] * vector[i + 1] = 0:\n            count += 1\n    return count\n\ndef run_scf_procedure(eps: np.ndarray, t: np.ndarray, U: np.ndarray) -> list[int]:\n    \"\"\"\n    Performs the self-consistent field (SCF) calculation for a 4-site Hubbard model.\n\n    Args:\n        eps: Array of site energies (4 elements).\n        t: Array of nearest-neighbor hopping integrals (3 elements).\n        U: Array of on-site repulsion parameters (4 elements).\n\n    Returns:\n        A list of four integers representing the node counts of the converged\n        canonical molecular orbitals, ordered by increasing energy.\n    \"\"\"\n    num_sites = 4\n    num_electrons = 4\n    num_occupied_orbitals = num_electrons // 2\n    \n    # Convergence parameters\n    tolerance = 1e-9\n    max_iterations = 200\n    mixing_alpha = 0.7  # Damping factor to aid convergence\n\n    # 1. Initialization: Build the core Hamiltonian (U=0 Fock matrix)\n    fock_matrix = np.diag(eps)\n    for i in range(num_sites - 1):\n        fock_matrix[i, i + 1] = fock_matrix[i + 1, i] = t[i]\n    \n    density_matrix = np.zeros((num_sites, num_sites))\n\n    for i in range(max_iterations):\n        # 2a. Solve eigenvalue problem for the current Fock matrix\n        # np.linalg.eigh returns eigenvalues in ascending order and corresponding eigenvectors\n        # as columns of the matrix.\n        orbital_energies, orbital_coeffs = np.linalg.eigh(fock_matrix)\n\n        # 2b. Construct new density matrix from occupied orbitals\n        occupied_coeffs = orbital_coeffs[:, :num_occupied_orbitals]\n        new_density_matrix = 2.0 * (occupied_coeffs @ occupied_coeffs.T)\n\n        # 2c. Check for convergence\n        error = np.max(np.abs(new_density_matrix - density_matrix))\n        if error  tolerance:\n            break\n\n        # 2d. Prepare for next iteration: mix density matrices\n        density_matrix = mixing_alpha * new_density_matrix + (1.0 - mixing_alpha) * density_matrix\n        \n        # Update Fock matrix with the new density\n        fock_diag = eps + (U * np.diag(density_matrix)) / 2.0\n        np.fill_diagonal(fock_matrix, fock_diag)\n    \n    # 3. Post-SCF: Calculate node counts from the converged orbitals\n    # Re-diagonalize the final Fock matrix to get final canonical orbitals\n    final_energies, final_orbitals = np.linalg.eigh(fock_matrix)\n\n    node_counts = []\n    for i in range(num_sites):\n        orbital_vector = final_orbitals[:, i]\n        nodes = compute_node_count(orbital_vector)\n        node_counts.append(nodes)\n        \n    return node_counts\n\ndef solve():\n    \"\"\"\n    Defines test cases and computes the solution for each, printing the final result.\n    \"\"\"\n    # Test cases: (eps_array, t_array, U_array)\n    test_cases = [\n        # Case A: symmetric interacting chain\n        (np.array([0.0, 0.0, 0.0, 0.0]), np.array([-1.0, -1.0, -1.0]), np.array([2.0, 2.0, 2.0, 2.0])),\n        # Case B: symmetric non-interacting chain\n        (np.array([0.0, 0.0, 0.0, 0.0]), np.array([-1.0, -1.0, -1.0]), np.array([0.0, 0.0, 0.0, 0.0])),\n        # Case C: asymmetric site energy at one end\n        (np.array([0.5, 0.0, 0.0, 0.0]), np.array([-1.0, -1.0, -1.0]), np.array([2.0, 2.0, 2.0, 2.0])),\n        # Case D: non-uniform bonding\n        (np.array([0.0, 0.0, 0.0, 0.0]), np.array([-1.5, -0.5, -1.0]), np.array([2.0, 2.0, 2.0, 2.0])),\n    ]\n\n    results = []\n    for case_params in test_cases:\n        eps_vals, t_vals, U_vals = case_params\n        result = run_scf_procedure(eps_vals, t_vals, U_vals)\n        results.append(str(result))\n    \n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2465579"}]}