{"hands_on_practices": [{"introduction": "掌握 DIIS 的第一步是理解其核心数学原理。这个练习将带你推导一个简单情形下的 DIIS 系数，通过求解一个 2x2 线性方程组，你将亲手揭示该方法背后简洁的线性代数结构。这个“笔和纸”的练习是后续编程实践的基础 [@problem_id:207916]。", "problem": "在用于加速自洽场 (SCF) 计算收敛的迭代子空间直接反演 (DIIS) 方法中，下一次迭代的改进 Fock 矩阵 $\\mathbf{F}_{\\text{DIIS}}$ 被构造为来自先前 $m$ 次迭代的 Fock 矩阵的线性组合：\n$$\n\\mathbf{F}_{\\text{DIIS}} = \\sum_{i=1}^{m} c_i \\mathbf{F}_i\n$$\n系数 $c_i$ 是通过最小化一个相关误差向量的范数来确定的，该误差向量也以同样的方式进行外插：$\\mathbf{e}_{\\text{DIIS}} = \\sum_{i=1}^{m} c_i \\mathbf{e}_i$。最小化在系数之和为1的约束条件下进行，即 $\\sum_{i=1}^{m} c_i = 1$。\n\n这个约束最小化问题可以构建为一个线性方程组。对于一个由 $m$ 个误差向量 $\\{\\mathbf{e}_1, \\ldots, \\mathbf{e}_m\\}$ 构成的基，该方程组的形式如下：\n$$\n\\begin{pmatrix}\nB_{11}  B_{12}  \\cdots  B_{1m}  1 \\\\\nB_{21}  B_{22}  \\cdots  B_{2m}  1 \\\\\n\\vdots  \\vdots  \\ddots  \\vdots  \\vdots \\\\\nB_{m1}  B_{m2}  \\cdots  B_{mm}  1 \\\\\n1  1  \\cdots  1  0\n\\end{pmatrix}\n\\begin{pmatrix}\nc_1 \\\\\nc_2 \\\\\n\\vdots \\\\\nc_m \\\\\n-\\lambda\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n0 \\\\\n0 \\\\\n\\vdots \\\\\n0 \\\\\n1\n\\end{pmatrix}\n$$\n其中 $B_{ij} = \\langle \\mathbf{e}_i | \\mathbf{e}_j \\rangle$ 是误差向量的内积（例如，矩阵乘积的迹），$\\lambda$ 是归一化约束的拉格朗日乘子。\n\n考虑一个使用两个先前误差向量 $\\mathbf{e}_1$ 和 $\\mathbf{e}_2$（即 $m=2$）的 DIIS 过程。这些误差向量的内积给出如下：\n- $B_{11} = \\langle \\mathbf{e}_1 | \\mathbf{e}_1 \\rangle = A$\n- $B_{22} = \\langle \\mathbf{e}_2 | \\mathbf{e}_2 \\rangle = B$\n- $B_{12} = B_{21} = \\langle \\mathbf{e}_1 | \\mathbf{e}_2 \\rangle = C$\n\n假设 $A, B, C$ 的取值使得存在唯一解，请确定系数 $c_1$ 的解析表达式。", "solution": "对于 $m=2$，我们有如下线性方程组：\n$$\n\\begin{cases}\nA\\,c_1 + C\\,c_2 - \\lambda = 0,\\\\\nC\\,c_1 + B\\,c_2 - \\lambda = 0,\\\\\nc_1 + c_2 = 1.\n\\end{cases}\n$$\n1. 根据前两个方程：\n$$\nA\\,c_1 + C\\,c_2 = \\lambda,\n\\quad\nC\\,c_1 + B\\,c_2 = \\lambda\n\\;\\Longrightarrow\\;\nA\\,c_1 + C\\,c_2 = C\\,c_1 + B\\,c_2.\n$$\n2. 重新整理可得\n$$\n(A - C)\\,c_1 = (B - C)\\,c_2\n\\quad\\Longrightarrow\\quad\nc_2 = \\frac{A - C}{\\,B - C\\,}\\,c_1.\n$$\n3. 代入归一化条件 $c_1 + c_2 = 1$：\n$$\nc_1 + \\frac{A - C}{B - C}\\,c_1 = 1\n\\quad\\Longrightarrow\\quad\nc_1\\Bigl(1 + \\frac{A - C}{B - C}\\Bigr) = 1\n\\quad\\Longrightarrow\\quad\nc_1 \\,\\frac{A + B - 2C}{B - C} = 1.\n$$\n4. 因此\n$$\nc_1 = \\frac{B - C}{A + B - 2C}.\n$$", "answer": "$$\\boxed{\\frac{B - C}{A + B - 2C}}$$", "id": "207916"}, {"introduction": "理论在手，我们便可将其转化为代码。这个练习聚焦于编写一个执行单步 DIIS 更新的函数，这是任何量子化学程序中 DIIS 模块的核心。通过处理包括数值不稳定情况在内的不同测试用例，你将学会如何在实践中构建一个稳健的 DIIS 步骤 [@problem_id:2923103]。", "problem": "要求您实现迭代子空间直接反演（Direct Inversion in the Iterative Subspace, DIIS）的一个步骤，这是一种在量子化学的自洽场程序中常用的收敛加速方法。DIIS 步骤应纯粹用线性代数术语来表述，从以下定义开始：给定一组残差矩阵 $\\{ \\mathbf{r}_i \\}_{i=1}^{m}$ 和相应的类算子矩阵 $\\{ \\mathbf{F}_i \\}_{i=1}^{m}$，确定系数 $\\mathbf{c} = (c_1, \\dots, c_m)^\\top$，使得残差组合的 Frobenius 范数在满足一个仿射约束的条件下最小化，\n$$\n\\min_{\\mathbf{c}} \\left\\| \\sum_{i=1}^{m} c_i \\mathbf{r}_i \\right\\|_F^2 \\quad \\text{subject to} \\quad \\sum_{i=1}^{m} c_i = 1.\n$$\n通过 Frobenius 内积定义对称矩阵 $\\mathbf{B} \\in \\mathbb{R}^{m \\times m}$，\n$$\nB_{ij} = \\langle \\mathbf{r}_i, \\mathbf{r}_j \\rangle_F = \\mathrm{tr}(\\mathbf{r}_i^\\top \\mathbf{r}_j).\n$$\n为了处理潜在的病态问题，使用一个带有小标量 $\\delta \\ge 0$ 的 Tikhonov 正则化矩阵 $\\mathbf{B}_\\delta = \\mathbf{B} + \\delta \\mathbf{I}$。系数 $\\mathbf{c}$ 和一个 Lagrange 乘子 $\\lambda$ 应通过求解强制执行仿射和约束的相关线性系统来获得。然后构成外推矩阵\n$$\n\\mathbf{F}_\\mathrm{DIIS} = \\sum_{i=1}^{m} c_i \\mathbf{F}_i.\n$$\n您的任务是编写一个完整的、可运行的程序，对下面的每个测试用例，从提供的残差计算 $\\mathbf{B}$，应用指定的正则化 $\\delta$，在仿射约束下求解 $\\mathbf{c}$，构建 $\\mathbf{F}_\\mathrm{DIIS}$，并以行主序展平 $\\mathbf{F}_\\mathrm{DIIS}$，每个条目四舍五入到 $8$ 位小数后输出。\n\n该程序必须处理三个独立的测试用例，每个用例都有 $m = 3$ 个先前的迭代和大小为 $2 \\times 2$ 的小型实数矩阵。对于每个用例，输入是列表 $\\{\\mathbf{F}_1, \\mathbf{F}_2, \\mathbf{F}_3\\}$ 和 $\\{\\mathbf{r}_1, \\mathbf{r}_2, \\mathbf{r}_3\\}$，以及标量 $\\delta$。使用 Frobenius 内积构建 $\\mathbf{B}$，通过加上 $\\delta$ 来正则化其对角线，求解约束系统得到 $\\mathbf{c}$，并形成最终的 $\\mathbf{F}_\\mathrm{DIIS}$。\n\n测试套件：\n- 用例 $1$ (良态残差几何):\n  - $\\mathbf{F}_1 = \\begin{bmatrix} 1.0  0.2 \\\\ 0.2  0.9 \\end{bmatrix}$, $\\mathbf{F}_2 = \\begin{bmatrix} 0.9  0.1 \\\\ 0.1  0.8 \\end{bmatrix}$, $\\mathbf{F}_3 = \\begin{bmatrix} 0.85  0.05 \\\\ 0.05  0.75 \\end{bmatrix}$。\n  - $\\mathbf{r}_1 = \\begin{bmatrix} 0.05  -0.02 \\\\ -0.02  0.03 \\end{bmatrix}$, $\\mathbf{r}_2 = \\begin{bmatrix} 0.02  -0.01 \\\\ -0.01  0.015 \\end{bmatrix}$, $\\mathbf{r}_3 = \\begin{bmatrix} 0.01  -0.005 \\\\ -0.005  0.007 \\end{bmatrix}$。\n  - $\\delta = 10^{-10}$。\n- 用例 $2$ (近线性相关的残差):\n  - $\\mathbf{F}_1 = \\begin{bmatrix} -0.5  0.0 \\\\ 0.0  -0.4 \\end{bmatrix}$, $\\mathbf{F}_2 = \\begin{bmatrix} -0.45  0.0 \\\\ 0.0  -0.35 \\end{bmatrix}$, $\\mathbf{F}_3 = \\begin{bmatrix} -0.425  0.0 \\\\ 0.0  -0.325 \\end{bmatrix}$。\n  - $\\mathbf{r}_1 = \\begin{bmatrix} 10^{-3}  2 \\cdot 10^{-3} \\\\ 2 \\cdot 10^{-3}  4 \\cdot 10^{-3} \\end{bmatrix}$, $\\mathbf{r}_2 = 2 \\mathbf{r}_1$, $\\mathbf{r}_3 = \\tfrac{1}{2} \\mathbf{r}_1$。\n  - $\\delta = 10^{-8}$。\n- 用例 $3$ (消失的残差；边界行为):\n  - $\\mathbf{F}_1 = \\begin{bmatrix} 0.3  -0.1 \\\\ -0.1  0.25 \\end{bmatrix}$, $\\mathbf{F}_2 = \\begin{bmatrix} 0.28  -0.08 \\\\ -0.08  0.22 \\end{bmatrix}$, $\\mathbf{F}_3 = \\begin{bmatrix} 0.27  -0.07 \\\\ -0.07  0.21 \\end{bmatrix}$。\n  - $\\mathbf{r}_1 = \\begin{bmatrix} 0.0  0.0 \\\\ 0.0  0.0 \\end{bmatrix}$, $\\mathbf{r}_2 = \\begin{bmatrix} 0.0  0.0 \\\\ 0.0  0.0 \\end{bmatrix}$, $\\mathbf{r}_3 = \\begin{bmatrix} 0.0  0.0 \\\\ 0.0  0.0 \\end{bmatrix}$。\n  - $\\delta = 10^{-6}$。\n\n数值和格式要求：\n- 全程使用实数算术。\n- 构建 $\\mathbf{B}$，其条目为 $B_{ij} = \\sum_{a,b} r_i(a,b) \\, r_j(a,b)$。\n- 在求解 $\\mathbf{c}$ 的约束线性系统之前，将 $\\delta$ 加到 $\\mathbf{B}$ 的对角线上。\n- 计算 $\\mathbf{F}_\\mathrm{DIIS} = \\sum_{i=1}^{3} c_i \\mathbf{F}_i$。\n- 对于每个测试用例，输出 $\\mathbf{F}_\\mathrm{DIIS}$ 条目的行主序展平列表，每个条目四舍五入到 8 位小数。\n- 最终输出格式：您的程序应生成单行输出，其中包含结果，形式为三个展平列表的逗号分隔列表，并用一对单独的方括号括起来。例如，包含三个结果的输出应类似于 $[\\,[x_{11}, x_{12}, x_{21}, x_{22}],\\,[y_{11}, y_{12}, y_{21}, y_{22}],\\,[z_{11}, z_{12}, z_{21}, z_{22}]\\,]$，其中每个 $x_{ij}$、$y_{ij}$ 和 $z_{ij}$ 都是四舍五入到 8 位小数的浮点数。", "solution": "问题陈述是线性代数和数值优化中一个有效且适定的练习，要求实现迭代子空间直接反演（Direct Inversion in the Iterative Subspace, DIIS）程序的一个步骤。该方法是加速量子化学中自洽场计算收敛的基石。该问题具有科学依据，形式上明确，并包含唯一解所需的所有数据。我们将继续进行形式推导和实现。\n\nDIIS 方法的核心是找到先前类 Fock 矩阵 $\\mathbf{F}_i$ 的一个线性组合，该组合能够最小化相应残差矩阵 $\\mathbf{r}_i$ 线性组合的范数。该组合的系数之和必须为一，以确保如果所有先前的迭代都是解，则新的迭代也将是解。这被表述为一个约束优化问题。\n\n设 $\\{\\mathbf{r}_i\\}_{i=1}^m$ 为一组 $m$ 个残差矩阵，$\\{\\mathbf{F}_i\\}_{i=1}^m$ 为相应的类算子矩阵集合。我们寻求一个系数向量 $\\mathbf{c} = (c_1, \\dots, c_m)^\\top$ 来求解：\n$$\n\\min_{\\mathbf{c}} \\left\\| \\sum_{i=1}^{m} c_i \\mathbf{r}_i \\right\\|_F^2 \\quad \\text{subject to} \\quad \\sum_{i=1}^{m} c_i = 1\n$$\n目标函数是残差线性组合的 Frobenius 范数的平方。我们可以使用 Frobenius 内积的定义 $\\langle \\mathbf{A}, \\mathbf{B} \\rangle_F = \\mathrm{tr}(\\mathbf{A}^\\top \\mathbf{B})$ 来展开此项。对于实数矩阵，这等价于逐元素乘积之和。\n$$\nJ(\\mathbf{c}) = \\left\\| \\sum_{i=1}^{m} c_i \\mathbf{r}_i \\right\\|_F^2 = \\left\\langle \\sum_{i=1}^{m} c_i \\mathbf{r}_i, \\sum_{j=1}^{m} c_j \\mathbf{r}_j \\right\\rangle_F = \\sum_{i=1}^{m} \\sum_{j=1}^{m} c_i c_j \\langle \\mathbf{r}_i, \\mathbf{r}_j \\rangle_F\n$$\n我们定义一个对称矩阵 $\\mathbf{B} \\in \\mathbb{R}^{m \\times m}$，其元素是残差矩阵的内积：\n$$\nB_{ij} = \\langle \\mathbf{r}_i, \\mathbf{r}_j \\rangle_F\n$$\n根据这个定义，目标函数变成了关于 $\\mathbf{c}$ 的二次型：\n$$\nJ(\\mathbf{c}) = \\mathbf{c}^\\top \\mathbf{B} \\mathbf{c}\n$$\n约束是线性的：$\\sum_{i=1}^{m} c_i = 1$，可以写成向量形式 $\\mathbf{1}^\\top \\mathbf{c} = 1$，其中 $\\mathbf{1}$ 是一个包含 $m$ 个 1 的列向量。\n\n问题指出，为处理残差向量之间潜在的线性相关性（这会使 $\\mathbf{B}$ 成为奇异矩阵），我们必须使用 Tikhonov 正则化。这涉及将 $\\mathbf{B}$ 替换为正则化矩阵 $\\mathbf{B}_\\delta$：\n$$\n\\mathbf{B}_\\delta = \\mathbf{B} + \\delta \\mathbf{I}\n$$\n其中 $\\delta \\ge 0$ 是一个小标量，$\\mathbf{I}$ 是 $m \\times m$ 的单位矩阵。优化问题现在是在 $\\mathbf{1}^\\top \\mathbf{c} = 1$ 的约束下最小化 $\\mathbf{c}^\\top \\mathbf{B}_\\delta \\mathbf{c}$。\n\n我们使用 Lagrange 乘子法来解决这个问题。该问题的 Lagrangian 函数 $\\mathcal{L}$ 是：\n$$\n\\mathcal{L}(\\mathbf{c}, \\lambda) = \\mathbf{c}^\\top \\mathbf{B}_\\delta \\mathbf{c} - 2\\lambda \\left( \\mathbf{1}^\\top \\mathbf{c} - 1 \\right)\n$$\n其中 $2\\lambda$ 是 Lagrange 乘子（因子 $2$ 是为了代数上的方便）。为了找到最小值，我们将 $\\mathcal{L}$ 关于 $\\mathbf{c}$ 的梯度和关于 $\\lambda$ 的偏导数设为零。\n$$\n\\nabla_{\\mathbf{c}} \\mathcal{L} = 2 \\mathbf{B}_\\delta \\mathbf{c} - 2\\lambda \\mathbf{1} = \\mathbf{0} \\quad \\implies \\quad \\mathbf{B}_\\delta \\mathbf{c} - \\lambda \\mathbf{1} = \\mathbf{0}\n$$\n$$\n\\frac{\\partial \\mathcal{L}}{\\partial \\lambda} = -2 \\left( \\mathbf{1}^\\top \\mathbf{c} - 1 \\right) = 0 \\quad \\implies \\quad \\mathbf{1}^\\top \\mathbf{c} = 1\n$$\n这两个方程构成了一个关于 $m$ 个系数 $c_i$ 和乘子 $\\lambda$ 的 $m+1$ 个线性方程组。我们可以用分块矩阵形式表示该系统：\n$$\n\\begin{pmatrix}\n\\mathbf{B}_\\delta  -\\mathbf{1} \\\\\n\\mathbf{1}^\\top  0\n\\end{pmatrix}\n\\begin{pmatrix}\n\\mathbf{c} \\\\\n\\lambda\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n\\mathbf{0} \\\\\n1\n\\end{pmatrix}\n$$\n其中 $\\mathbf{0}$ 是大小为 $m$ 的零向量。对于问题中给出的具体情况 $m=3$，这是一个 $4 \\times 4$ 的线性系统。只要 $\\mathbf{B}_\\delta$ 是正定的，左侧的矩阵就是可逆的，如果原始残差向量不全为零，则 $\\delta > 0$ 可以保证这一点。\n\n计算过程如下：\n1. 给定残差矩阵 $\\{\\mathbf{r}_1, \\mathbf{r}_2, \\mathbf{r}_3\\}$，构建 $3 \\times 3$ 矩阵 $\\mathbf{B}$，其中 $B_{ij} = \\sum_{k,l} (\\mathbf{r}_i)_{kl} (\\mathbf{r}_j)_{kl}$。\n2. 给定正则化参数 $\\delta$，形成 $\\mathbf{B}_\\delta = \\mathbf{B} + \\delta\\mathbf{I}$。\n3. 构建 $4 \\times 4$ 的增广矩阵 $\\mathbf{A}_{\\text{aug}} = \\begin{pmatrix} \\mathbf{B}_\\delta  -\\mathbf{1} \\\\ \\mathbf{1}^\\top  0 \\end{pmatrix}$ 和右侧向量 $\\mathbf{b}_{\\text{aug}} = (0, 0, 0, 1)^\\top$。\n4. 求解线性系统 $\\mathbf{A}_{\\text{aug}} \\mathbf{x} = \\mathbf{b}_{\\text{aug}}$ 以找到解向量 $\\mathbf{x} = (c_1, c_2, c_3, \\lambda)^\\top$。\n5. 提取系数 $\\mathbf{c} = (c_1, c_2, c_3)^\\top$。\n6. 使用矩阵 $\\{\\mathbf{F}_1, \\mathbf{F}_2, \\mathbf{F}_3\\}$，计算外推矩阵 $\\mathbf{F}_{\\text{DIIS}}$：\n$$\n\\mathbf{F}_{\\text{DIIS}} = \\sum_{i=1}^3 c_i \\mathbf{F}_i\n$$\n此过程将应用于所提供的三个测试用例中的每一个。", "answer": "```python\nimport numpy as np\n\ndef perform_diis_step(F_matrices, r_matrices, delta):\n    \"\"\"\n    Performs a single step of the DIIS procedure.\n\n    Args:\n        F_matrices (list of np.ndarray): List of operator-like matrices {F_i}.\n        r_matrices (list of np.ndarray): List of residual matrices {r_i}.\n        delta (float): Tikhonov regularization parameter.\n\n    Returns:\n        np.ndarray: The extrapolated matrix F_DIIS.\n    \"\"\"\n    m = len(r_matrices)\n    if m == 0:\n        return np.zeros_like(F_matrices[0]) if F_matrices else np.array([])\n\n    # 1. Construct the B matrix\n    B = np.zeros((m, m))\n    for i in range(m):\n        for j in range(i, m):\n            # Frobenius inner product: tr(A.T @ B)\n            val = np.trace(r_matrices[i].T @ r_matrices[j])\n            B[i, j] = val\n            B[j, i] = val\n    \n    # Apply Tikhonov regularization\n    B_delta = B + delta * np.eye(m)\n\n    # 2. Set up and solve the augmented linear system\n    # The Lagrange system is [[B_delta, -1], [1^T, 0]] [c, lambda]^T = [0, 1]^T\n    A_aug = np.zeros((m + 1, m + 1))\n    A_aug[:m, :m] = B_delta\n    A_aug[:m, m] = -1.0\n    A_aug[m, :m] = 1.0\n\n    b_aug = np.zeros(m + 1)\n    b_aug[m] = 1.0\n\n    # Solve the system\n    try:\n        # The solution vector is [c_1, ..., c_m, lambda]\n        x = np.linalg.solve(A_aug, b_aug)\n        coeffs = x[:m]\n    except np.linalg.LinAlgError:\n        # Fallback in case of singularity despite regularization\n        coeffs = np.zeros(m)\n        coeffs[-1] = 1.0\n    \n    # 3. Form the extrapolated F_DIIS matrix\n    F_diis = np.zeros_like(F_matrices[0], dtype=np.float64)\n    for i in range(m):\n        F_diis += coeffs[i] * F_matrices[i]\n\n    return F_diis\n\ndef solve():\n    \"\"\"\n    Runs the test suite for the DIIS step problem and prints the results.\n    \"\"\"\n    test_cases = [\n        {\n            \"Fs\": [np.array([[1.0, 0.2], [0.2, 0.9]]), np.array([[0.9, 0.1], [0.1, 0.8]]), np.array([[0.85, 0.05], [0.05, 0.75]])],\n            \"rs\": [np.array([[0.05, -0.02], [-0.02, 0.03]]), np.array([[0.02, -0.01], [-0.01, 0.015]]), np.array([[0.01, -0.005], [-0.005, 0.007]])],\n            \"delta\": 1e-10\n        },\n        {\n            \"Fs\": [np.array([[-0.5, 0.0], [0.0, -0.4]]), np.array([[-0.45, 0.0], [0.0, -0.35]]), np.array([[-0.425, 0.0], [0.0, -0.325]])],\n            \"rs\": [np.array([[1e-3, 2e-3], [2e-3, 4e-3]]), 2 * np.array([[1e-3, 2e-3], [2e-3, 4e-3]]), 0.5 * np.array([[1e-3, 2e-3], [2e-3, 4e-3]])],\n            \"delta\": 1e-8\n        },\n        {\n            \"Fs\": [np.array([[0.3, -0.1], [-0.1, 0.25]]), np.array([[0.28, -0.08], [-0.08, 0.22]]), np.array([[0.27, -0.07], [-0.07, 0.21]])],\n            \"rs\": [np.array([[0.0, 0.0], [0.0, 0.0]]), np.array([[0.0, 0.0], [0.0, 0.0]]), np.array([[0.0, 0.0], [0.0, 0.0]])],\n            \"delta\": 1e-6\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        F_diis = perform_diis_step(case[\"Fs\"], case[\"rs\"], case[\"delta\"])\n        flattened = F_diis.flatten()\n        rounded = [f\"{x:.8f}\" for x in flattened]\n        all_results.append(f\"[{', '.join(rounded)}]\")\n    \n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```", "id": "2923103"}, {"introduction": "现在，是时候让 DIIS 在其“自然栖息地”——一个完整的自洽场（SCF）计算循环中大显身手了。你将构建一个完整的（尽管是简化的）SCF 迭代过程，并利用 DIIS 加速其收敛。我们还将进行一个有趣的数值实验，通过向 DIIS 子空间故意“投毒”，来测试该方法对历史不良信息的鲁棒性 [@problem_id:2454236]。", "problem": "实现一个完整、可运行的程序，模拟一个在二维基组中（重叠矩阵为单位矩阵）的闭壳层双电子体系的最小自洽场（SCF）过程，并使用迭代子空间直接反演（DIIS）方法加速收敛。您的目标是通过有意地将一个来自早期不正确迭代的陈旧Fock矩阵引入DIIS子空间（一次“投毒”事件）来研究DIIS的鲁棒性，并量化其对收敛所需迭代次数的影响。\n\n使用以下基本设置：\n\n- 基函数是标准正交的，因此重叠矩阵为 $S = I$。\n- 体系有 $N_e = 2$ 个电子（闭壳层，一个双占据空间轨道）。\n- 核心哈密顿量 $H$ 是一个固定的 $2 \\times 2$ 实对称矩阵：\n  $$ H = \\begin{pmatrix} -1.0  -0.25 \\\\ -0.25  0.30 \\end{pmatrix}. $$\n- 第 $k$ 次迭代的Fock矩阵 $F(P)$ 由一个简单的平均场映射定义，\n  $$ F(P) = H + \\alpha P, $$\n  其中 $\\alpha = 0.7$，$P$ 是当前的密度矩阵。\n- 给定任意对称的 $2 \\times 2$ Fock矩阵 $F$，通过对角化 $F$ 并用 $2$ 个电子占据最低本征值来获得下一个密度矩阵 $P_{\\text{new}}$：\n  $$ F C = C \\varepsilon, \\quad P_{\\text{new}} = 2\\, c_0 c_0^\\top, $$\n  其中 $c_0$ 是 $F$ 对应于最低本征值的归一化本征向量。\n- 从一个故意选择的不佳初始猜测 $P^{(0)}$ 开始，该猜测定义为 $H$ 的双占据激发态轨道：对角化 $H$，选择与其较高本征值相关联的本征向量，并设置 $P^{(0)} = 2\\, v_1 v_1^\\top$。\n\n使用对易子残差（在 $S = I$ 时有效）定义第 $k$ 次迭代的SCF误差，\n$$ E^{(k)} = [F^{(k)}, P^{(k)}] = F^{(k)} P^{(k)} - P^{(k)} F^{(k)}, $$\n并按如下方式对Fock矩阵执行DIIS外推。维持一个最多包含 $m$ 个存储对 $\\{(F^{(i)}, E^{(i)})\\}$ 的子空间。对于 $n \\ge 2$ 个存储的误差矩阵，确定系数 $c_i$ 以最小化外推残差的Frobenius范数，并满足一个仿射约束条件，\n$$ \\min_{\\{c_i\\}} \\left\\| \\sum_{i=1}^{n} c_i E^{(i)} \\right\\|_F^2 \\quad \\text{subject to} \\quad \\sum_{i=1}^{n} c_i = 1. $$\n设对称矩阵 $B \\in \\mathbb{R}^{n \\times n}$ 的元素为\n$$ B_{ij} = \\langle E^{(i)}, E^{(j)} \\rangle = \\operatorname{Tr}\\!\\left( (E^{(i)})^\\top E^{(j)} \\right). $$\n使用带有乘子 $\\lambda$ 的拉格朗日乘数法，这个约束最小二乘问题导出一个线性系统\n$$\n\\begin{pmatrix}\nB  -\\mathbf{1} \\\\\n\\mathbf{1}^\\top  0\n\\end{pmatrix}\n\\begin{pmatrix}\n\\mathbf{c} \\\\ \\lambda\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n\\mathbf{0} \\\\ 1\n\\end{pmatrix},\n$$\n其中 $\\mathbf{1}$ 是包含 $n$ 个1的列向量，$\\mathbf{0}$ 是包含 $n$ 个0的向量，$\\mathbf{c} = (c_1,\\dots,c_n)^\\top$。构建DIIS外推的Fock矩阵\n$$ F_{\\text{DIIS}} = \\sum_{i=1}^{n} c_i F^{(i)}, $$\n并使用上述对角化规则用它来形成 $P_{\\text{new}}$。如果可用存储对少于 $2$ 个，则设置 $F_{\\text{DIIS}} = F^{(k)}$。\n\n为研究鲁棒性，在指定的迭代索引 $k_{\\text{poison}}$ 处引入一次“投毒”事件：在该次迭代中，不将当前对 $\\left(F^{(k)}, E^{(k)}\\right)$ 附加到DIIS子空间，而是附加一个来自更早迭代索引 $j$（其中 $j \\ge 0$ 且 $j  k$）的陈旧对 $\\left(F^{(j)}, E^{(j)}\\right)$。通过在超出容量时丢弃最旧的存储对来维持最大子空间大小为 $m$。如果DIIS线性系统是病态的，对 $B$ 使用一个小的对角正则化，以使增广系统保持可解；正则化项必须是严格正的，并且与 $B$ 的典型尺度相比非常小。\n\n收敛准则和保障措施：\n\n- 当密度矩阵的均方根变化小于容差 $\\tau = 10^{-8}$ 时，宣布收敛：\n  $$ \\Delta_P = \\sqrt{\\frac{1}{4} \\sum_{a,b=1}^{2} \\left( P_{\\text{new},ab} - P_{ab} \\right)^2 }  \\tau. $$\n- 强加一个 $k_{\\max} = 200$ 次迭代的硬上限；如果达到此上限，则认为运行未收敛。\n\n您的程序必须实现以上内容并运行以下测试套件。每个测试返回达到密度容差实际使用的迭代次数 $k_{\\text{conv}}$（如果未收敛则返回 $k_{\\max}$）：\n\n- 测试1（正常路径，无投毒）：$m = 4$，不存在 $k_{\\text{poison}}$。\n- 测试2（单次投毒，中等子空间）：$m = 4$，在 $k_{\\text{poison}} = 5$ 处使用最早的可用对 $j = 0$ 进行一次投毒。\n- 测试3（边界子空间大小，投毒）：$m = 2$，在 $k_{\\text{poison}} = 5$ 处使用最早的可用对 $j = 0$ 进行一次投毒。\n\n最终输出格式：\n\n- 您的程序应生成单行输出，其中包含按测试1到3的顺序排列、用方括号括起来的逗号分隔列表的结果：\n  \"[k1,k2,k3]\".\n- 所有输出均为整数。此问题的输出不涉及任何单位。", "solution": "问题陈述已经过严格验证，并被确定为是合理的。它在科学上基于计算量子化学的原理，问题设定良好，具有清晰的算法结构，并以客观、明确的语言表述。任务是为一个最小的双电子、双基函数模型体系实现一个自洽场（SCF）过程，并结合迭代子空间直接反演（DIIS）收敛加速技术。需要研究的一个特定特性是DIIS在有意将其迭代子空间中引入一个“陈旧”或“有毒”的Fock矩阵时的鲁棒性。\n\n该解决方案实现为一个数值算法，它迭代地优化电子密度矩阵的初始猜测，直到达到自洽。\n\n基本常数和矩阵按规定定义：\n- 核心哈密顿量 $H$，一个 $2 \\times 2$ 的实对称矩阵：\n$$ H = \\begin{pmatrix} -1.0  -0.25 \\\\ -0.25  0.30 \\end{pmatrix} $$\n- 电子排斥比例因子 $\\alpha = 0.7$。\n- 密度矩阵变化的收敛容差 $\\tau = 10^{-8}$。\n- 允许的最大迭代次数 $k_{\\max} = 200$。\n\n算法按以下步骤进行：\n\n1.  **初始化**：SCF过程从迭代 $k=0$ 开始，使用密度矩阵的初始猜测 $P^{(0)}$。根据规定，这是一个从基态核心哈密顿量的*激发*态导出的故意选择的不佳猜测。我们对角化 $H$ 以找到其本征值 $\\varepsilon_0, \\varepsilon_1$ 和对应的本征向量 $v_0, v_1$。然后从与较高本征值 $\\varepsilon_1$ 相关联的本征向量 $v_1$ 构建初始密度：\n    $$ P^{(0)} = 2\\, v_1 v_1^\\top $$\n    在整个运行过程中，会维护所有计算出的Fock和误差矩阵对 $\\{(F^{(i)}, E^{(i)})\\}$ 的历史记录。同时，也会初始化一个最大容量为 $m$ 对的独立DIIS子空间。\n\n2.  **SCF迭代循环**：对于每次迭代 $k = 0, 1, 2, \\dots$ 直到 $k_{\\max}-1$：\n    a.  **Fock矩阵构建**：使用上一步的密度矩阵 $P^{(k)}$ 构建当前迭代的Fock矩阵 $F^{(k)}$：\n        $$ F^{(k)} = H + \\alpha P^{(k)} $$\n    b.  **误差矩阵计算**：DIIS误差矩阵 $E^{(k)}$ 计算为Fock矩阵和密度矩阵的对易子。这种形式的残差是有效的，因为基是标准正交的，即重叠矩阵是单位矩阵 $S = I$。\n        $$ E^{(k)} = [F^{(k)}, P^{(k)}] = F^{(k)} P^{(k)} - P^{(k)} F^{(k)} $$\n        对 $(F^{(k)}, E^{(k)})$ 被存储在历史记录中。\n\n    c.  **DIIS子空间管理与外推**：\n        i.  **投毒逻辑**：如果当前迭代 $k$ 与指定的投毒迭代 $k_{\\text{poison}}$ 匹配，则选择来自指定先前迭代 $j$ 的陈旧对 $(F^{(j)}, E^{(j)})$。否则，选择当前对 $(F^{(k)}, E^{(k)})$。\n        ii. **子空间更新**：将选定的对添加到DIIS子空间。如果子空间的大小超过了允许的最大值 $m$，则丢弃最旧的对以保持容量。\n        iii. **外推**：如果DIIS子空间包含少于 $n=2$ 对，则不执行外推，后续的Fock矩阵就是当前的 $F^{(k)}$。如果 $n \\ge 2$，则形成子空间中Fock矩阵的最优线性组合 $F_{\\text{DIIS}} = \\sum_{i=1}^{n} c_i F^{(i)}$。系数 $c_i$ 通过求解约束最小二乘问题来确定，该问题旨在最小化外推误差的范数 $\\min \\|\\sum_{i=1}^{n} c_i E^{(i)}\\|_F^2$，并满足约束条件 $\\sum_{i=1}^{n} c_i = 1$。这导出了 $(n+1) \\times (n+1)$ 的增广线性系统：\n            $$\n            \\begin{pmatrix}\n            B  -\\mathbf{1} \\\\\n            \\mathbf{1}^\\top  0\n            \\end{pmatrix}\n            \\begin{pmatrix}\n            \\mathbf{c} \\\\ \\lambda\n            \\end{pmatrix}\n            =\n            \\begin{pmatrix}\n            \\mathbf{0} \\\\ 1\n            \\end{pmatrix}\n            $$\n            矩阵 $B$ 由子空间中误差矩阵的Frobenius内积构建而成：$B_{ij} = \\operatorname{Tr}((E^{(i)})^\\top E^{(j)})$。为确保对误差向量之间潜在线性相关性（这会使 $B$ 奇异）的数值稳定性，在求解系统之前，向 $B$ 添加一个小的对角正则化项 $\\epsilon I$（其中 $\\epsilon=10^{-10}$）。\n        iv. **下一步的Fock矩阵**：下一步的Fock矩阵 $F_{\\text{next}}$ 设置为外推矩阵 $F_{\\text{DIIS}}$。\n\n    d.  **密度矩阵更新**：对角化 $F_{\\text{next}}$ 以找到其本征值和本征向量。新的密度矩阵 $P_{\\text{new}}$ 从对应于最低本征值的本征向量 $c_0$ 构建，代表单个双占据分子轨道：\n        $$ P_{\\text{new}} = 2\\, c_0 c_0^\\top $$\n\n    e.  **收敛检查**：密度矩阵的变化通过其均方根偏差来量化：\n        $$ \\Delta_P = \\sqrt{\\frac{1}{4} \\sum_{a,b=1}^{2} \\left( P_{\\text{new},ab} - P^{(k)}_{ab} \\right)^2 } $$\n        如果 $\\Delta_P  \\tau$，则过程收敛。循环终止，并记录迭代次数 $k+1$。\n\n    f.  **循环**：如果未收敛，则为下一次迭代更新密度 $P^{(k+1)} \\leftarrow P_{\\text{new}}$，并继续循环。\n\n3.  **终止**：如果循环完成 $k_{\\max}$ 次迭代仍未满足收敛准则，则认为运行未收敛，并记录值 $k_{\\max}$。\n\n对于问题陈述中指定的三个测试用例，均执行此完整算法，以确定收敛所需的迭代次数。", "answer": "```python\nimport numpy as np\nfrom collections import deque\n\ndef run_scf(m, k_poison=None, j_poison=None):\n    \"\"\"\n    Runs a minimal SCF procedure with DIIS acceleration.\n\n    Args:\n        m (int): Maximum size of the DIIS subspace.\n        k_poison (int, optional): Iteration index at which to poison the subspace.\n        j_poison (int, optional): Index of the stale data to use for poisoning.\n\n    Returns:\n        int: The number of iterations to converge, or k_max if not converged.\n    \"\"\"\n    # System parameters\n    H_core = np.array([[-1.0, -0.25], [-0.25, 0.30]])\n    alpha = 0.7\n    tol = 1e-8\n    k_max = 200\n    reg_eps = 1e-10  # Regularization parameter for the DIIS B-matrix\n\n    # 1. Initialization: Create a poor initial guess from the excited state of H_core\n    _, eigvecs_H = np.linalg.eigh(H_core)\n    # v1 is the eigenvector for the higher eigenvalue\n    v1 = eigvecs_H[:, 1].reshape(2, 1)\n    P = 2.0 * (v1 @ v1.T)\n\n    diis_space = deque(maxlen=m)\n    history = []  # Stores all (F, E) pairs by iteration index\n\n    for k in range(k_max):\n        # 2a. Fock Matrix Construction\n        F = H_core + alpha * P\n\n        # 2b. Error Matrix Calculation\n        E = F @ P - P @ F\n        history.append((F, E))\n\n        # 2c. DIIS Subspace Management and Extrapolation\n        # i. Poisoning Logic\n        if k == k_poison and j_poison is not None and j_poison  len(history):\n            pair_to_add = history[j_poison]\n        else:\n            pair_to_add = (F, E)\n        \n        # ii. Subspace Update\n        diis_space.append(pair_to_add)\n\n        # iii. Extrapolation\n        if len(diis_space)  2:\n            F_next = F\n        else:\n            n = len(diis_space)\n            B = np.zeros((n, n))\n            for i in range(n):\n                for j in range(n):\n                    Ei = diis_space[i][1]\n                    Ej = diis_space[j][1]\n                    B[i, j] = np.trace(Ei.T @ Ej)\n\n            # Add regularization for numerical stability\n            B += np.eye(n) * reg_eps\n\n            # Build and solve the augmented linear system\n            aug_B = np.zeros((n + 1, n + 1))\n            aug_B[:n, :n] = B\n            aug_B[:n, n] = -1.0\n            aug_B[n, :n] = 1.0\n            \n            rhs = np.zeros(n + 1)\n            rhs[n] = 1.0\n\n            try:\n                coeffs_lambda = np.linalg.solve(aug_B, rhs)\n                coeffs = coeffs_lambda[:n]\n\n                # iv. Next Fock Matrix\n                F_next = np.zeros_like(F)\n                for i in range(n):\n                    F_next += coeffs[i] * diis_space[i][0]\n            except np.linalg.LinAlgError:\n                # If solver fails despite regularization, fall back to no extrapolation\n                F_next = F\n\n        # 2d. Density Matrix Update\n        eigvals, eigvecs = np.linalg.eigh(F_next)\n        # c0 is the eigenvector for the lowest eigenvalue\n        c0 = eigvecs[:, 0].reshape(2, 1)\n        P_new = 2.0 * (c0 @ c0.T)\n\n        # 2e. Convergence Check\n        delta_P = np.sqrt(np.sum((P_new - P)**2) / 4.0)\n\n        if delta_P  tol:\n            return k + 1\n\n        # 2f. Cycle\n        P = P_new\n\n    return k_max\n\ndef solve():\n    \"\"\"\n    Executes the test suite for the DIIS robustness investigation.\n    \"\"\"\n    test_cases = [\n        # Test 1: m=4, no poisoning\n        {'m': 4},\n        # Test 2: m=4, poison at k=5 with data from j=0\n        {'m': 4, 'k_poison': 5, 'j_poison': 0},\n        # Test 3: m=2, poison at k=5 with data from j=0\n        {'m': 2, 'k_poison': 5, 'j_poison': 0},\n    ]\n\n    results = []\n    for params in test_cases:\n        num_iterations = run_scf(**params)\n        results.append(num_iterations)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2454236"}]}