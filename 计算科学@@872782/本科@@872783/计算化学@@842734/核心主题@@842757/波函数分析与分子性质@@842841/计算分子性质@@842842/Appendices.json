{"hands_on_practices": [{"introduction": "本练习将介绍紧束缚模型，这是一个强大而简洁的工具，用于理解共轭体系的电子结构。通过为聚乙炔构建并对角化哈密顿矩阵，我们将亲手揭示分子结构（链长和键长交替）如何决定其关键的电子性质——HOMO-LUMO能隙 [@problem_id:2451347]。这一性质是理解分子颜色、导电性和反应活性的基础。", "problem": "要求您计算在共轭 $\\pi$ 体系的单电子最近邻紧束缚哈密顿量水平下建模时，最高占据分子轨道 (HOMO) 和最低未占分子轨道 (LUMO) 的能隙如何随有限反式聚乙炔链的长度而变化。考虑一个具有 $2n$ 个碳位点（每个碳有一个 $p_z$ 轨道）的有限开链，其中 $n$ 是 $\\text{-CH=CH-}$ 重复单元的数量。每个位点的在位能为 $0$ 电子伏特 (eV)，且仅存在伴有键交替（二聚化）的最近邻耦合。最近邻跃迁积分沿链交替为 $t_1$ 和 $t_2$，其中 $t_1 = t_0(1+\\delta)$ 且 $t_2 = t_0(1-\\delta)$。使用以下常数：$t_0 = 2.50$ eV 和 $\\delta = 0.15$ (无量纲)。哈密顿矩阵 $H \\in \\mathbb{R}^{2n \\times 2n}$ 定义为：对所有位点 $i$，$H_{i,i} = 0$ eV，且对于 $i=1,\\dots,2n-1$：\n- 如果位点 $i$ 和 $i+1$ 之间的键是 $t_1$ 类型，则 $H_{i,i+1} = H_{i+1,i} = t_1$，\n- 如果位点 $i$ 和 $i+1$ 之间的键是 $t_2$ 类型，则 $H_{i,i+1} = H_{i+1,i} = t_2$，\n采用开放边界条件。交替从位点 1 和 2 之间的 $t_1$ 开始，然后是位点 2 和 3 之间的 $t_2$，如此类推，依次交替贯穿整个链。\n\n假设为中性链，每个碳有一个 $\\pi$ 电子，并具有隐式自旋简并（即每个分子轨道可以容纳两个自旋相反的电子）。设排序后的单电子能量本征值为 $E_1 \\le E_2 \\le \\dots \\le E_{2n}$ (单位为 eV)。在半填充时，HOMO 能量为 $E_n$，LUMO 能量为 $E_{n+1}$。HOMO-LUMO 能隙为 $\\Delta = E_{n+1} - E_n$ (单位为 eV)。\n\n测试组：\n- 使用四种链长 $n \\in \\{2,4,6,8\\}$。\n- 对所有测试用例，使用上文指定的相同 $t_0$ 和 $\\delta$。\n\n您的任务是编写一个完整、可运行的程序，该程序对测试组中的每个元素，构建哈密顿量 $H$，获得本征值，按定义确定 HOMO-LUMO 能隙 $\\Delta$，并返回能隙。以电子伏特 (eV) 表示每个能隙，四舍五入到 $6$ 位小数。\n\n最终输出格式：\n- 您的程序应产生单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表，结果按测试组 $n$ 值从小到大的顺序排列。例如，输出格式必须类似于 [$x_1$,$x_2$,$x_3$,$x_4$]，其中每个 $x_k$ 是对应 $n$ 的能隙，单位为 eV，四舍五入到 $6$ 位小数。", "solution": "所述问题是有效的。它在科学上基于用于描述共轭聚合物电子结构的成熟的紧束缚模型，它提法明确，所有必要的参数和条件都已定义，并且是客观的，没有歧义。我们将着手解决。\n\n问题要求计算有限 `trans`-聚乙炔链的最高占据分子轨道 (HOMO) 到最低未占分子轨道 (LUMO) 的能隙 $\\Delta$。所采用的模型是用于 $\\pi$ 电子体系的单电子、最近邻紧束缚哈密顿量。该链由 $2n$ 个碳原子组成，其中 $n$ 是 $\\text{-CH=CH-}$ 单元的数量。\n\n哈密顿矩阵 $H$ 是一个维度为 $2n \\times 2n$ 的实对称矩阵。在位能，即矩阵的对角元素，被设为零：对于所有位点 $i=1, \\dots, 2n$，$H_{i,i} = 0$。非对角元素 $H_{i,j}$ 代表位点 $i$ 和 $j$ 之间的跃迁积分。在此模型中，这些仅对最近邻非零。键表现出交替（二聚化），具有两个不同的跃迁积分 $t_1$ 和 $t_2$。交替从位点 1 和 2 之间的 $t_1$ 型键开始，接着是位点 2 和 3 之间的 $t_2$ 型键，依此类推。这种模式定义了三对角哈密顿矩阵的结构：\n$$\nH_{i,i+1} = H_{i+1,i} = \\begin{cases} t_1  \\text{if } i \\text{ is odd} \\\\ t_2  \\text{if } i \\text{ is even} \\end{cases}\n$$\n对于 $i = 1, \\dots, 2n-1$。所有其他非对角元素均为零。链是有限的，意味着开放边界条件，即位点 1 和位点 $2n$ 之间没有跃迁积分。\n\n跃迁积分的值由参数 $t_0 = 2.50$ eV 和 $\\delta = 0.15$ 确定。\n“强”键的跃迁积分为 $t_1 = t_0(1+\\delta) = 2.50(1+0.15) = 2.875$ eV。\n“弱”键的跃迁积分为 $t_2 = t_0(1-\\delta) = 2.50(1-0.15) = 2.125$ eV。\n\n$\\pi$ 体系的单粒子能级是哈密顿矩阵 $H$ 的本征值。我们必须求解本征值方程 $H\\mathbf{c}_k = E_k \\mathbf{c}_k$，其中 $E_k$ 是能量本征值，$\\mathbf{c}_k$ 是对应的本征矢量（分子轨道）。对于一个 $2n \\times 2n$ 的矩阵，将有 $2n$ 个本征值，我们将其排序为 $E_1 \\le E_2 \\le \\dots \\le E_{2n}$。\n\n该体系是一个中性链，每个碳原子有一个 $\\pi$ 电子，总共有 $2n$ 个电子。根据泡利不相容原理，每个分子轨道（能级）可以容纳两个自旋相反的电子。因此，这 $2n$ 个电子将占据能量最低的 $n$ 个轨道。被占据的轨道集合对应于能量 $\\{E_1, E_2, \\dots, E_n\\}$。\n\n最高占据分子轨道 (HOMO) 是被占据的能量最高的轨道，即能量为 $E_n$ 的第 $n$ 个轨道。最低未占分子轨道 (LUMO) 是未被占据的能量最低的轨道，即能量为 $E_{n+1}$ 的第 $(n+1)$ 个轨道。HOMO-LUMO 能隙定义为它们之间的能量差：\n$$\n\\Delta = E_{LUMO} - E_{HOMO} = E_{n+1} - E_n\n$$\n对于测试组 $\\{2, 4, 6, 8\\}$ 中的每个 $n$ 值，计算步骤如下：\n$1$. 根据上述规则构建 $2n \\times 2n$ 的哈密顿矩阵 $H$。当 $n=2$ 时矩阵大小为 $4 \\times 4$，$n=4$ 时为 $8 \\times 8$，$n=6$ 时为 $12 \\times 12$，$n=8$ 时为 $16 \\times 16$。\n$2$. 对矩阵 $H$ 进行数值对角化，以获得其 $2n$ 个本征值。我们将使用一个标准的数值线性代数库函数，该函数返回按非递减顺序排序的本征值。\n$3$. 确定 HOMO 能量 $E_n$ 和 LUMO 能量 $E_{n+1}$。在一个长度为 $2n$、零索引的已排序本征值数组中，它们分别对应于索引为 $n-1$ 和 $n$ 的元素。\n$4$. 计算能隙 $\\Delta = E_{n+1} - E_n$。\n对测试组中的每个 $n$ 重复此过程，并收集所得的能隙。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the HOMO-LUMO gap for finite trans-polyacetylene chains\n    using a nearest-neighbor tight-binding model.\n    \"\"\"\n    # Define constants from the problem statement.\n    t0_ev = 2.50  # Base hopping integral in eV\n    delta = 0.15      # Dimerization parameter, dimensionless\n\n    # Calculate the alternating hopping integrals t1 and t2.\n    # t1 corresponds to the stronger bond (e.g., double bond character)\n    # t2 corresponds to the weaker bond (e.g., single bond character)\n    t1 = t0_ev * (1 + delta)\n    t2 = t0_ev * (1 - delta)\n\n    # Define the test cases from the problem statement.\n    # n is the number of repeating -CH=CH- units.\n    # The total number of carbon sites is 2n.\n    test_cases = [2, 4, 6, 8]\n\n    # List to store the calculated gaps for each test case.\n    results = []\n\n    # Iterate through each value of n in the test suite.\n    for n in test_cases:\n        # The size of the Hamiltonian matrix is N x N, where N = 2n.\n        N = 2 * n\n\n        # Initialize an N x N zero matrix for the Hamiltonian.\n        hamiltonian_matrix = np.zeros((N, N))\n\n        # Populate the off-diagonal elements of the Hamiltonian matrix.\n        # The matrix is tridiagonal with alternating hopping integrals t1 and t2.\n        # H_i,i+1 = H_i+1,i\n        # The bond between sites 1 and 2 (indices 0 and 1) is t1.\n        # The bond between sites 2 and 3 (indices 1 and 2) is t2.\n        # The pattern is t1, t2, t1, t2, ...\n        for i in range(N - 1):\n            if i % 2 == 0:  # Odd-numbered bond (1-2, 3-4, ...) -> even index i\n                hop_integral = t1\n            else:  # Even-numbered bond (2-3, 4-5, ...) -> odd index i\n                hop_integral = t2\n            \n            hamiltonian_matrix[i, i + 1] = hop_integral\n            hamiltonian_matrix[i + 1, i] = hop_integral\n\n        # The eigenvalues of the Hamiltonian are the one-electron energy levels.\n        # np.linalg.eigh is used for Hermitian (real symmetric) matrices and\n        # returns eigenvalues sorted in ascending order.\n        # We only need the eigenvalues, not the eigenvectors.\n        eigenvalues = np.linalg.eigh(hamiltonian_matrix)[0]\n\n        # In a neutral system with 2n electrons, the first n orbitals are filled.\n        # The HOMO is the n-th orbital, and the LUMO is the (n+1)-th orbital.\n        # In a 0-indexed array, these correspond to indices n-1 and n.\n        e_homo = eigenvalues[n - 1]\n        e_lumo = eigenvalues[n]\n\n        # Calculate the HOMO-LUMO gap.\n        gap = e_lumo - e_homo\n\n        # Append the calculated gap to the results list.\n        results.append(gap)\n\n    # Format the final output as a comma-separated list of strings,\n    # with each gap rounded to 6 decimal places, enclosed in brackets.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\n# Execute the main function.\nsolve()\n```", "id": "2451347"}, {"introduction": "本练习将从简化模型深入到LCAO（原子轨道线性组合）方法的更基础的实现。你将从零开始计算水分子的偶极矩，亲手处理基函数、重叠积分和密度矩阵 [@problem_id:2451307]。这个实践过程揭示了量子化学软件计算分子性质的“黑箱”，并强调了选择合适的基组对获得准确结果的重要性。", "problem": "您需要编写一个完整、可运行的程序，该程序使用原子轨道线性组合 (LCAO) 紧束缚模型和数值积分，为五组模拟基组灵活性增加的不同高斯宽度参数集，计算水分子的永久偶极矩大小。其目标是研究数值收敛于已知气相实验偶极矩的趋势，而不调用任何外部量子化学软件。该程序必须输出单行，其中包含两个列表：第一个列表包含每个参数集计算出的偶极矩大小，第二个列表包含相对于实验值的绝对误差，所有值均以德拜 (Debye) 为单位，四舍五入到三位小数。\n\n请使用以下科学标准定义和建模假设作为基础：\n\n- 在 Born–Oppenheimer (BO) 近似下，中性分子的电子偶极矩定义为\n$$\n\\boldsymbol{\\mu} = \\sum_{A} Z_{A} \\mathbf{R}_{A} - \\int \\rho_{e}(\\mathbf{r})\\,\\mathbf{r}\\,d^3\\mathbf{r},\n$$\n其中 $Z_{A}$ 和 $\\mathbf{R}_{A}$ 分别是原子核 $A$ 的电荷和位置，$\\rho_{e}(\\mathbf{r})$ 是电子密度。对于闭壳层体系，\n$$\n\\rho_{e}(\\mathbf{r}) = 2 \\sum_{a \\in \\text{occ}} \\left| \\psi_{a}(\\mathbf{r}) \\right|^{2}.\n$$\n- 在原子轨道线性组合 (LCAO) 近似中，每个分子轨道展开为\n$$\n\\psi_{a}(\\mathbf{r}) = \\sum_{i=1}^{N} C_{ia}\\,\\phi_{i}(\\mathbf{r}),\n$$\n其中 $\\phi_{i}(\\mathbf{r})$ 是以原子为中心、归一化的笛卡尔高斯基元函数。在氧原子上使用一个 $2s$ 和三个 $2p$ ($p_x,p_y,p_z$) 函数，在每个氢原子上使用一个 $1s$ 函数，总共 $N=6$ 个基函数。每个位于中心 $\\mathbf{R}_{A}$ 上的基元函数具有以下形式\n- $s$ 型: $\\phi_{s}(\\mathbf{r}) = N_{s}\\,\\exp\\!\\left(-\\alpha\\left\\|\\mathbf{r}-\\mathbf{R}_{A}\\right\\|^{2}\\right)$,\n- $p_x$ 型: $\\phi_{p_x}(\\mathbf{r}) = N_{p}\\,(x-X_{A})\\,\\exp\\!\\left(-\\alpha\\left\\|\\mathbf{r}-\\mathbf{R}_{A}\\right\\|^{2}\\right)$,\n$p_y$ 和 $p_z$ 的定义与此类似。归一化常数为\n$$\nN_{s} = \\left(\\frac{2\\alpha}{\\pi}\\right)^{3/4}, \\quad\nN_{p} = \\left(\\frac{128\\,\\alpha^{5}}{\\pi^{3}}\\right)^{1/4}.\n$$\n- 通过求解广义特征值问题来确定占据分子轨道\n$$\n\\mathbf{H}\\,\\mathbf{C} = \\mathbf{S}\\,\\mathbf{C}\\,\\boldsymbol{\\varepsilon},\n$$\n其中 $\\mathbf{S}_{ij}=\\int \\phi_{i}(\\mathbf{r})\\phi_{j}(\\mathbf{r})\\,d^{3}\\mathbf{r}$ 是重叠矩阵，$\\mathbf{H}$ 是单电子哈密顿量，采用 Wolfsberg–Helmholtz (WH) 方法近似：\n$$\nH_{ii} = \\varepsilon_{i}, \\quad\nH_{ij} = K\\,S_{ij}\\,\\frac{\\varepsilon_{i}+\\varepsilon_{j}}{2} \\quad (i\\neq j),\n$$\n其中 $K$ 是一个无量纲常数。使用 $K=1.75$ 和对角轨道能 $\\varepsilon_{\\text{O}\\,2s}=-32.3\\,\\text{eV}$，$\\varepsilon_{\\text{O}\\,2p}=-14.8\\,\\text{eV}$，以及 $\\varepsilon_{\\text{H}\\,1s}=-13.6\\,\\text{eV}$。用 $8$ 个电子（四个双占据轨道）填充能量最低的分子轨道，这对应于氧的价电子数为 $6$，每个氢的价电子数为 $1$。对氧使用 $Z_{\\text{O,eff}}=6$ 的有效核电荷（氧的核电荷 $8$ 减去一个包含 $2$ 个电子的隐式 $1s$ 内核），对每个氢使用 $Z_{\\text{H}}=1$，这样总的有效核电荷等于总电子数，确保了价电子模型内的整体电中性。\n- 在包围整个分子的规则三维网格上，通过数值积分计算所有必需的积分。对于体积元为 $\\Delta V$ 的任意网格点 $\\mathbf{r}_{g}$，近似为\n$$\nS_{ij} \\approx \\sum_{g} \\phi_{i}(\\mathbf{r}_{g})\\,\\phi_{j}(\\mathbf{r}_{g})\\,\\Delta V,\n\\quad\nD^{(k)}_{ij} \\approx \\sum_{g} \\phi_{i}(\\mathbf{r}_{g})\\,r^{(k)}_{g}\\,\\phi_{j}(\\mathbf{r}_{g})\\,\\Delta V,\n$$\n其中 $k\\in\\{x,y,z\\}$，$D^{(k)}$ 是位置算符的偶极积分。电子偶极矩分量为\n$$\n\\mu^{(k)}_{\\text{el}} = - \\sum_{i,j} P_{ij}\\,D^{(k)}_{ij},\n$$\n其中密度矩阵 $\\mathbf{P} = 2\\,\\mathbf{C}_{\\text{occ}}\\mathbf{C}_{\\text{occ}}^{\\top}$。核偶极矩为 $\\boldsymbol{\\mu}_{\\text{nuc}} = \\sum_{A} Z_{A}\\,\\mathbf{R}_{A}$。总偶极矩为 $\\boldsymbol{\\mu}=\\boldsymbol{\\mu}_{\\text{nuc}}+\\boldsymbol{\\mu}_{\\text{el}}$。计算其大小 $\\|\\boldsymbol{\\mu}\\|$ 并使用 $1\\,e\\cdot\\text{\\AA} = 4.803204712\\,\\text{Debye}$ 将其表示为德拜单位。\n\n几何结构和单位：\n- 使用水分子的几何结构，其中 O 位于原点，分子位于 $x$-$z$ 平面内。O–H 键长为 $r_{\\text{OH}}=0.9572\\,\\text{\\AA}$，H–O–H 键角为 $\\theta=104.52$ 度。将氢原子置于\n$$\n\\mathbf{R}_{\\text{H1}} = (r_{\\text{OH}}\\sin(\\theta/2),\\,0,\\,r_{\\text{OH}}\\cos(\\theta/2)), \\quad\n\\mathbf{R}_{\\text{H2}} = (-r_{\\text{OH}}\\sin(\\theta/2),\\,0,\\,r_{\\text{OH}}\\cos(\\theta/2)).\n$$\n- 所有用于积分的空间坐标单位必须是 $\\text{\\AA}$，最终的偶极矩大小必须以德拜为单位报告，并四舍五入到三位小数。角度单位是度。\n\n数值网格：\n- 在每个笛卡尔方向上使用一个从 $-4.0\\,\\text{\\AA}$ 到 $+4.0\\,\\text{\\AA}$ 的均匀立方网格，选择合适的间距将此区间均匀划分，形成一个足够精细的网格，以保证数值稳定性和重叠矩阵的正定性。程序应在所有计算中使用相同的网格。\n\n测试套件（五组参数集）：\n- 对于以下五种情况，设置高斯指数（单位为 $\\text{\\AA}^{-2}$）如下\n1. A 组 (紧凑，类最小基组)：$\\alpha_{\\text{O},2s}=2.00$, $\\alpha_{\\text{O},2p}=1.60$, $\\alpha_{\\text{H},1s}=1.30$.\n2. B 组：$\\alpha_{\\text{O},2s}=1.60$, $\\alpha_{\\text{O},2p}=1.20$, $\\alpha_{\\text{H},1s}=1.00$.\n3. C 组：$\\alpha_{\\text{O},2s}=1.20$, $\\alpha_{\\text{O},2p}=0.90$, $\\alpha_{\\text{H},1s}=0.80$.\n4. D 组：$\\alpha_{\\text{O},2s}=0.90$, $\\alpha_{\\text{O},2p}=0.70$, $\\alpha_{\\text{H},1s}=0.60$.\n5. E 组 (弥散，类增广基组)：$\\alpha_{\\text{O},2s}=0.70$, $\\alpha_{\\text{O},2p}=0.55$, $\\alpha_{\\text{H},1s}=0.45$.\n\n参考值：\n- 使用气相实验偶极矩大小 $\\mu_{\\text{exp}}=1.855$ 德拜。\n\n您的程序必须：\n- 实现上述 LCAO 紧束缚模型和数值积分，为五组参数集中的每一组计算 $\\|\\boldsymbol{\\mu}\\|$（单位为德拜）。\n- 对每种情况，计算绝对误差 $|\\|\\boldsymbol{\\mu}\\| - \\mu_{\\text{exp}}|$（单位为德拜）。\n- 生成单行输出，其中包含两个列表：第一个列表是五个偶极矩大小（单位为德拜），第二个列表是五个绝对误差（单位为德拜）。两个列表必须包含在一个外部列表中，并显示为\n$$\n[\\,[\\mu_{A},\\mu_{B},\\mu_{C},\\mu_{D},\\mu_{E}],\\,[e_{A},e_{B},e_{C},e_{D},e_{E}]\\,],\n$$\n其中每个数字都四舍五入到三位小数。\n\n约束条件：\n- 代码必须完全自包含，不需要用户输入，并且必须遵守指定的执行环境。\n- 计算必须按照描述进行；不允许硬编码目标偶极矩结果或使用黑箱量子化学软件包。", "solution": "所述问题经过了严格验证。\n\n**步骤 1：提取给定条件**\n\n*   **偶极矩定义 (Born-Oppenheimer):** $\\boldsymbol{\\mu} = \\sum_{A} Z_{A} \\mathbf{R}_{A} - \\int \\rho_{e}(\\mathbf{r})\\,\\mathbf{r}\\,d^3\\mathbf{r}$\n*   **电子密度:** $\\rho_{e}(\\mathbf{r}) = 2 \\sum_{a \\in \\text{occ}} \\left| \\psi_{a}(\\mathbf{r}) \\right|^{2}$\n*   **LCAO 展开:** $\\psi_{a}(\\mathbf{r}) = \\sum_{i=1}^{N} C_{ia}\\,\\phi_{i}(\\mathbf{r})$\n*   **基组 ($N=6$):** O: 一个 $2s$，三个 $2p$ ($p_x, p_y, p_z$)；每个 H: 一个 $1s$。\n*   **高斯基元函数形式:** $\\phi_{s}(\\mathbf{r}) = N_{s}\\,\\exp\\!\\left(-\\alpha\\left\\|\\mathbf{r}-\\mathbf{R}_{A}\\right\\|^{2}\\right)$, $\\phi_{p_x}(\\mathbf{r}) = N_{p}\\,(x-X_{A})\\,\\exp\\!\\left(-\\alpha\\left\\|\\mathbf{r}-\\mathbf{R}_{A}\\right\\|^{2}\\right)$。\n*   **归一化常数:** $N_{s} = \\left(\\frac{2\\alpha}{\\pi}\\right)^{3/4}$, $N_{p} = \\left(\\frac{128\\,\\alpha^{5}}{\\pi^{3}}\\right)^{1/4}$。\n*   **久期方程:** $\\mathbf{H}\\,\\mathbf{C} = \\mathbf{S}\\,\\mathbf{C}\\,\\boldsymbol{\\varepsilon}$，其中 $\\mathbf{S}_{ij}=\\int \\phi_{i}(\\mathbf{r})\\phi_{j}(\\mathbf{r})\\,d^{3}\\mathbf{r}$。\n*   **Wolfsberg-Helmholtz 哈密顿量:** $H_{ii} = \\varepsilon_{i}$，$H_{ij} = K\\,S_{ij}\\,\\frac{\\varepsilon_{i}+\\varepsilon_{j}}{2}$ (当 $i\\neq j$)。\n*   **参数:** $K=1.75$，$\\varepsilon_{\\text{O}\\,2s}=-32.3\\,\\text{eV}$，$\\varepsilon_{\\text{O}\\,2p}=-14.8\\,\\text{eV}$，$\\varepsilon_{\\text{H}\\,1s}=-13.6\\,\\text{eV}$。\n*   **电子构型:** $8$ 个价电子，填充 $4$ 个能量最低的分子轨道。\n*   **有效核电荷:** $Z_{\\text{O,eff}}=6$，$Z_{\\text{H}}=1$。\n*   **数值积分:** $S_{ij} \\approx \\sum_{g} \\phi_{i}(\\mathbf{r}_{g})\\,\\phi_{j}(\\mathbf{r}_{g})\\,\\Delta V$, $D^{(k)}_{ij} \\approx \\sum_{g} \\phi_{i}(\\mathbf{r}_{g})\\,r^{(k)}_{g}\\,\\phi_{j}(\\mathbf{r}_{g})\\,\\Delta V$。\n*   **电子偶极矩:** $\\mu^{(k)}_{\\text{el}} = - \\sum_{i,j} P_{ij}\\,D^{(k)}_{ij}$，其中 $\\mathbf{P} = 2\\,\\mathbf{C}_{\\text{occ}}\\mathbf{C}_{\\text{occ}}^{\\top}$。\n*   **核偶极矩:** $\\boldsymbol{\\mu}_{\\text{nuc}} = \\sum_{A} Z_{A}\\,\\mathbf{R}_{A}$。\n*   **转换因子:** $1\\,e\\cdot\\text{\\AA} = 4.803204712\\,\\text{Debye}$。\n*   **几何结构:** O 位于 $(0,0,0)$；$r_{\\text{OH}}=0.9572\\,\\text{\\AA}$；H-O-H 键角 $\\theta=104.52^\\circ$。分子位于 $xz$ 平面。位置 $\\mathbf{R}_{\\text{H1}} = (r_{\\text{OH}}\\sin(\\theta/2),\\,0,\\,r_{\\text{OH}}\\cos(\\theta/2))$，$\\mathbf{R}_{\\text{H2}} = (-r_{\\text{OH}}\\sin(\\theta/2),\\,0,\\,r_{\\text{OH}}\\cos(\\theta/2))$。\n*   **数值网格:** 均匀立方体，每个维度从 $[-4.0, +4.0]\\,\\text{\\AA}$。\n*   **测试集 ($\\alpha$ 单位为 $\\text{\\AA}^{-2}$):**\n    1.  A: $\\alpha_{\\text{O},2s}=2.00$, $\\alpha_{\\text{O},2p}=1.60$, $\\alpha_{\\text{H},1s}=1.30$。\n    2.  B: $\\alpha_{\\text{O},2s}=1.60$, $\\alpha_{\\text{O},2p}=1.20$, $\\alpha_{\\text{H},1s}=1.00$。\n    3.  C: $\\alpha_{\\text{O},2s}=1.20$, $\\alpha_{\\text{O},2p}=0.90$, $\\alpha_{\\text{H},1s}=0.80$。\n    4.  D: $\\alpha_{\\text{O},2s}=0.90$, $\\alpha_{\\text{O},2p}=0.70$, $\\alpha_{\\text{H},1s}=0.60$。\n    5.  E: $\\alpha_{\\text{O},2s}=0.70$, $\\alpha_{\\text{O},2p}=0.55$, $\\alpha_{\\text{H},1s}=0.45$。\n*   **参考值:** $\\mu_{\\text{exp}}=1.855$ 德拜。\n*   **输出格式:** `[[mu_A,...,mu_E],[e_A,...,e_E]]` 四舍五入到三位小数。\n\n**步骤 2：使用提取的给定条件进行验证**\n\n该问题具有科学依据，采用了计算化学中一个标准但简化的 LCAO 模型。这是一个适定问题，提供了所有必要的物理参数、数学公式和几何数据，以便为每个指定的测试案例得出确切的数值结果。对“合理精细的网格”的要求是数值分析中的一个标准指令，而非缺陷，它只是将选择足够网格分辨率的任务交给了实现者。问题是客观的，没有矛盾。价电子数 ($8$) 与有效核电荷之和 ($6+1+1=8$) 正确匹配，确保了模型体系的电中性。\n\n**步骤 3：结论与行动**\n\n问题是**有效的**。将构建一个解决方案。\n\n**解题步骤**\n\n分子偶极矩的计算从第一性原理出发，并根据指定的近似方法进行调整。其基础是 Born-Oppenheimer 近似，该近似将原子核与电子的运动分离开来。总偶极矩 $\\boldsymbol{\\mu}$ 是核贡献 $\\boldsymbol{\\mu}_{\\text{nuc}}$ 和电子贡献 $\\boldsymbol{\\mu}_{\\text{el}}$ 的和。\n\n**1. 分子几何与基组**\n水分子按规定放置在笛卡尔坐标系中。氧原子位于原点 $\\mathbf{R}_{\\text{O}} = (0,0,0)\\,\\text{\\AA}$。给定 $r_{\\text{OH}}=0.9572\\,\\text{\\AA}$ 和 $\\theta=104.52^\\circ$，氢原子坐标计算如下：\n$\\theta/2 = 52.26^\\circ$。\n$$ \\mathbf{R}_{\\text{H1}} = (0.9572 \\sin(52.26^\\circ), 0, 0.9572 \\cos(52.26^\\circ)) \\approx (0.7569, 0, 0.5859)\\,\\text{\\AA} $$\n$$ \\mathbf{R}_{\\text{H2}} = (-0.9572 \\sin(52.26^\\circ), 0, 0.9572 \\cos(52.26^\\circ)) \\approx (-0.7569, 0, 0.5859)\\,\\text{\\AA} $$\n最小价基组由 $N=6$ 个原子轨道 (AO) 组成：\n\\begin{itemize}\n    \\item $\\phi_0$: O $2s$，中心在 $\\mathbf{R}_{\\text{O}}$\n    \\item $\\phi_1$: O $2p_x$，中心在 $\\mathbf{R}_{\\text{O}}$\n    \\item $\\phi_2$: O $2p_y$，中心在 $\\mathbf{R}_{\\text{O}}$\n    \\item $\\phi_3$: O $2p_z$，中心在 $\\mathbf{R}_{\\text{O}}$\n    \\item $\\phi_4$: H1 $1s$，中心在 $\\mathbf{R}_{\\text{H1}}$\n    \\item $\\phi_5$: H2 $1s$，中心在 $\\mathbf{R}_{\\text{H2}}$\n\\end{itemize}\n每个原子轨道都是一个归一化的笛卡尔高斯函数，其具体指数 $\\alpha$ 由参数集 A 到 E 给出。\n\n**2. 数值积分网格**\n所有积分都通过数值方法计算。在 $[-4.0, +4.0]\\,\\text{\\AA}$ 的区域上构建一个均匀的立方网格。为确保数值稳定性和合理的精度，每个轴选择 $101$ 个点的分辨率。这得到的网格间距为 $\\Delta x = 8.0 / (101-1) = 0.08\\,\\text{\\AA}$，体积元为 $\\Delta V = (\\Delta x)^3 = 0.000512\\,\\text{\\AA}^3$。\n\n**3. 矩阵构建**\n分子轨道 $\\psi_a$ 通过求解广义特征值问题 $\\mathbf{H}\\,\\mathbf{C} = \\mathbf{S}\\,\\mathbf{C}\\,\\boldsymbol{\\varepsilon}$ 来确定。必须首先构建矩阵 $\\mathbf{S}$ 和 $\\mathbf{H}$。\n\n重叠矩阵元 $S_{ij}$ 通过对所有网格点 $\\mathbf{r}_g$ 求和来计算：\n$$ S_{ij} = \\int \\phi_i^*(\\mathbf{r}) \\phi_j(\\mathbf{r})\\,d^3\\mathbf{r} \\approx \\sum_{g} \\phi_i(\\mathbf{r}_g) \\phi_j(\\mathbf{r}_g) \\Delta V $$\n\n哈密顿矩阵 $\\mathbf{H}$ 使用 Wolfsberg-Helmholtz 近似构建。对角元是原子轨道电离势：\n$$ H_{ii} = \\varepsilon_{i} $$\n其中 $\\varepsilon_i \\in \\{\\varepsilon_{\\text{O}\\,2s}, \\varepsilon_{\\text{O}\\,2p}, \\varepsilon_{\\text{H}\\,1s}\\}$ 对应于原子轨道 $\\phi_i$。非对角元与重叠成正比：\n$$ H_{ij} = K\\,S_{ij}\\,\\frac{\\varepsilon_{i}+\\varepsilon_{j}}{2} \\quad (i\\neq j) $$\n其中 $K=1.75$。\n\n**4. 求解久期方程并构建密度矩阵**\n使用标准的数值线性代数程序求解广义特征值问题，得到 MO 能量 $\\varepsilon_a$ 和 MO 系数矩阵 $\\mathbf{C}$（其中列是特征向量）。水分子有 $6$ (来自 O) + $1$ (来自 H1) + $1$ (来自 H2) = $8$ 个价电子。这些电子双占据能量最低的 $4$ 个分子轨道。矩阵 $\\mathbf{C}_{\\text{occ}}$ 由 $\\mathbf{C}$ 的前 $4$ 列构成。然后计算单电子密度矩阵 $\\mathbf{P}$：\n$$ \\mathbf{P} = 2\\,\\mathbf{C}_{\\text{occ}}\\mathbf{C}_{\\text{occ}}^{\\top} $$\n\n**5. 偶极矩计算**\n总偶极矩 $\\boldsymbol{\\mu}$ 是核部分和电子部分的总和。\n\n核贡献 $\\boldsymbol{\\mu}_{\\text{nuc}}$ 是在位置 $\\mathbf{R}_A$ 上的有效核电荷 $Z_A$ 的总和：\n$$ \\boldsymbol{\\mu}_{\\text{nuc}} = \\sum_{A} Z_A \\mathbf{R}_A = Z_{\\text{O,eff}}\\mathbf{R}_{\\text{O}} + Z_{\\text{H}}\\mathbf{R}_{\\text{H1}} + Z_{\\text{H}}\\mathbf{R}_{\\text{H2}} $$\n给定 $Z_{\\text{O,eff}}=6$，$Z_{\\text{H}}=1$，$\\mathbf{R}_{\\text{O}}=(0,0,0)$，并利用氢位置的对称性，唯一的非零分量是：\n$$ \\mu_{\\text{nuc},z} = 1 \\cdot (r_{\\text{OH}}\\cos(\\theta/2)) + 1 \\cdot (r_{\\text{OH}}\\cos(\\theta/2)) = 2 r_{\\text{OH}}\\cos(\\theta/2) $$\n单位是基本电荷 ($e$) 乘以埃 ($\\text{\\AA}$)。\n\n电子贡献 $\\boldsymbol{\\mu}_{\\text{el}}$ 是根据密度矩阵 $\\mathbf{P}$ 和每个笛卡尔分量 $k \\in \\{x, y, z\\}$ 的偶极积分矩阵 $\\mathbf{D}^{(k)}$ 计算的。偶极积分矩阵在网格上计算：\n$$ D^{(k)}_{ij} = \\int \\phi_i(\\mathbf{r}) r^{(k)} \\phi_j(\\mathbf{r})\\,d^3\\mathbf{r} \\approx \\sum_{g} \\phi_i(\\mathbf{r}_g) r^{(k)}_g \\phi_j(\\mathbf{r}_g) \\Delta V $$\n电子偶极矩分量则为：\n$$ \\mu^{(k)}_{\\text{el}} = - \\sum_{i,j} P_{ij} D^{(k)}_{ij} = -\\text{Tr}(\\mathbf{P} \\mathbf{D}^{(k)}) $$\n由于分子对称性 ($C_{2v}$)，总偶极矩矢量 $\\boldsymbol{\\mu} = \\boldsymbol{\\mu}_{\\text{nuc}} + \\boldsymbol{\\mu}_{\\text{el}}$ 预期沿 $z$ 轴，因此 $\\mu_x$ 和 $\\mu_y$ 应为零。\n\n最后，计算总偶极矩的大小并转换为德拜：\n$$ \\|\\boldsymbol{\\mu}\\| = \\sqrt{\\mu_x^2 + \\mu_y^2 + \\mu_z^2} $$\n$$ \\|\\boldsymbol{\\mu}\\|_{\\text{Debye}} = \\|\\boldsymbol{\\mu}\\|_{e\\cdot\\text{\\AA}} \\times 4.803204712 $$\n然后为每个参数集计算相对于实验值 $\\mu_{\\text{exp}}=1.855$ 德拜的绝对误差。对五组高斯指数中的每一组重复整个过程。减小指数（从 A 到 E）会使基函数更弥散，这通常会改善对电荷分布和偶极矩等性质的描述。因此，预计误差会呈现减小的趋势。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Computes the dipole moment of a water molecule using a semi-empirical\n    LCAO model for five different basis set parameter sets.\n    \"\"\"\n\n    # --- 1. Constants and Parameters ---\n    K_WH = 1.75  # Wolfsberg-Helmholtz constant\n    E_O_2S = -32.3  # eV\n    E_O_2P = -14.8  # eV\n    E_H_1S = -13.6  # eV\n    Z_O_eff = 6.0  # Effective nuclear charge for Oxygen\n    Z_H = 1.0     # Nuclear charge for Hydrogen\n    N_ELECTRONS = 8\n    MU_EXP_DEBYE = 1.855  # Experimental dipole moment in Debye\n    E_A_TO_DEBYE = 4.803204712\n\n    # --- 2. Geometry Setup ---\n    r_OH = 0.9572  # Angstrom\n    theta_HOH_deg = 104.52\n    theta_rad = np.deg2rad(theta_HOH_deg)\n\n    R_O = np.array([0.0, 0.0, 0.0])\n    R_H1 = np.array([r_OH * np.sin(theta_rad / 2.0), 0.0, r_OH * np.cos(theta_rad / 2.0)])\n    R_H2 = np.array([-r_OH * np.sin(theta_rad / 2.0), 0.0, r_OH * np.cos(theta_rad / 2.0)])\n    \n    atom_coords = [R_O, R_H1, R_H2]\n    atom_charges = [Z_O_eff, Z_H, Z_H]\n\n    # --- 3. Basis Set Definition ---\n    # Order: 0:O(2s), 1:O(2px), 2:O(2py), 3:O(2pz), 4:H1(1s), 5:H2(1s)\n    basis_info = [\n        {'type': 's',  'atom_idx': 0, 'energy': E_O_2S},\n        {'type': 'px', 'atom_idx': 0, 'energy': E_O_2P},\n        {'type': 'py', 'atom_idx': 0, 'energy': E_O_2P},\n        {'type': 'pz', 'atom_idx': 0, 'energy': E_O_2P},\n        {'type': 's',  'atom_idx': 1, 'energy': E_H_1S},\n        {'type': 's',  'atom_idx': 2, 'energy': E_H_1S},\n    ]\n    N_BASIS = len(basis_info)\n    H_diag = np.array([b['energy'] for b in basis_info])\n\n    # --- 4. Test Cases ---\n    test_cases = [\n        {'name': 'A', 'alpha_O_2s': 2.00, 'alpha_O_2p': 1.60, 'alpha_H_1s': 1.30},\n        {'name': 'B', 'alpha_O_2s': 1.60, 'alpha_O_2p': 1.20, 'alpha_H_1s': 1.00},\n        {'name': 'C', 'alpha_O_2s': 1.20, 'alpha_O_2p': 0.90, 'alpha_H_1s': 0.80},\n        {'name': 'D', 'alpha_O_2s': 0.90, 'alpha_O_2p': 0.70, 'alpha_H_1s': 0.60},\n        {'name': 'E', 'alpha_O_2s': 0.70, 'alpha_O_2p': 0.55, 'alpha_H_1s': 0.45},\n    ]\n\n    # --- 5. Numerical Grid Setup ---\n    N_GRID_PTS = 101\n    GRID_MIN, GRID_MAX = -4.0, 4.0\n    grid_coords_1d = np.linspace(GRID_MIN, GRID_MAX, N_GRID_PTS)\n    dx = grid_coords_1d[1] - grid_coords_1d[0]\n    dV = dx**3\n\n    x, y, z = np.meshgrid(grid_coords_1d, grid_coords_1d, grid_coords_1d, indexing='ij')\n    grid = np.vstack([x.ravel(), y.ravel(), z.ravel()]).T\n\n    # --- 6. Main Calculation Loop ---\n    dipole_magnitudes = []\n    absolute_errors = []\n\n    for case in test_cases:\n        # Assign alpha values for the current case\n        alphas = [\n            case['alpha_O_2s'],\n            case['alpha_O_2p'], case['alpha_O_2p'], case['alpha_O_2p'],\n            case['alpha_H_1s'],\n            case['alpha_H_1s'],\n        ]\n\n        # Evaluate all basis functions on the grid\n        phi_grid = np.zeros((grid.shape[0], N_BASIS))\n        for i in range(N_BASIS):\n            info = basis_info[i]\n            alpha = alphas[i]\n            center = atom_coords[info['atom_idx']]\n            \n            r_minus_RA = grid - center\n            r_sq = np.sum(r_minus_RA**2, axis=1)\n            gauss_part = np.exp(-alpha * r_sq)\n\n            if info['type'] == 's':\n                norm = (2 * alpha / np.pi)**0.75\n                phi_grid[:, i] = norm * gauss_part\n            else: # p-type\n                norm = (128 * alpha**5 / np.pi**3)**0.25\n                if info['type'] == 'px':\n                    phi_grid[:, i] = norm * r_minus_RA[:, 0] * gauss_part\n                elif info['type'] == 'py':\n                    phi_grid[:, i] = norm * r_minus_RA[:, 1] * gauss_part\n                elif info['type'] == 'pz':\n                    phi_grid[:, i] = norm * r_minus_RA[:, 2] * gauss_part\n\n        # Compute Overlap (S) and Dipole (D) matrices\n        S = phi_grid.T @ phi_grid * dV\n        Dx = phi_grid.T @ (grid[:, 0, np.newaxis] * phi_grid) * dV\n        Dy = phi_grid.T @ (grid[:, 1, np.newaxis] * phi_grid) * dV\n        Dz = phi_grid.T @ (grid[:, 2, np.newaxis] * phi_grid) * dV\n\n        # Compute Hamiltonian matrix (H)\n        H = np.diag(H_diag)\n        H_off_diag = 0.5 * K_WH * S * (H_diag[:, np.newaxis] + H_diag)\n        H = H + (H_off_diag - np.diag(np.diag(H_off_diag)))\n\n        # Solve generalized eigenvalue problem: HC = SCe\n        energies, C = linalg.eigh(H, S)\n        \n        # Form density matrix from occupied orbitals\n        C_occ = C[:, :N_ELECTRONS // 2]\n        P = 2.0 * (C_occ @ C_occ.T)\n\n        # Compute electronic dipole moment\n        mu_el_x = -np.trace(P @ Dx)\n        mu_el_y = -np.trace(P @ Dy)\n        mu_el_z = -np.trace(P @ Dz)\n        mu_el = np.array([mu_el_x, mu_el_y, mu_el_z])\n\n        # Compute nuclear dipole moment\n        mu_nuc = np.zeros(3)\n        for i in range(len(atom_coords)):\n            mu_nuc += atom_charges[i] * atom_coords[i]\n\n        # Total dipole moment\n        mu_total = mu_nuc + mu_el  # in e*A\n        mu_mag_eA = np.linalg.norm(mu_total)\n        mu_mag_debye = mu_mag_eA * E_A_TO_DEBYE\n\n        # Store results\n        dipole_magnitudes.append(mu_mag_debye)\n        absolute_errors.append(abs(mu_mag_debye - MU_EXP_DEBYE))\n\n    # --- 7. Final Output ---\n    formatted_dms = [f\"{dm:.3f}\" for dm in dipole_magnitudes]\n    formatted_errs = [f\"{err:.3f}\" for err in absolute_errors]\n    \n    print(f\"[[{','.join(formatted_dms)}],[{','.join(formatted_errs)}]]\")\n\nsolve()\n\n```", "id": "2451307"}, {"introduction": "精确计算分子间的相互作用能是计算化学的基石之一。本练习将探讨一个常见的计算陷阱：基组重叠误差（Basis Set Superposition Error, BSSE）。通过对水二聚体的结合能进行衡态校正（counterpoise correction），你将掌握一项提高相互作用能计算精度的标准技术 [@problem_id:2451348]，这对于研究分子识别、对接和溶剂化效应至关重要。", "problem": "给定一个固定几何构型的水二聚体及其组分单体在相同几何构型下计算的总电子能量，单位为哈特里 (hartree)。对于每个测试用例，提供了五个量：在二聚体基组中二聚体的能量，记为 $E_{AB}$；在各自单体基组中孤立单体的能量，记为 $E_{A}$ 和 $E_{B}$；以及在伙伴基函数存在但无电子或原子核（鬼基组）的情况下计算的单体能量，记为 $E_{A}^{\\ast}$ 和 $E_{B}^{\\ast}$。未经平衡校正的结合能定义为差值 $\\,\\Delta E_{\\mathrm{bind}} = E_{AB} - \\left(E_{A} + E_{B}\\right)\\,$，而针对基组重叠误差（BSSE）进行平衡校正后的结合能定义为 $\\,\\Delta E_{\\mathrm{bind}}^{\\mathrm{CP}} = E_{AB} - \\left(E_{A}^{\\ast} + E_{B}^{\\ast}\\right)\\,$。使用换算关系 $\\,1\\,\\text{hartree} = 2625.49962\\,\\text{kJ}\\cdot\\text{mol}^{-1}\\,$，将两种结合能都转换为千焦每摩尔 ($\\text{kJ}\\cdot\\text{mol}^{-1}$)。所有最终能量均以 $\\text{kJ}\\cdot\\text{mol}^{-1}$ 为单位表示，并四舍五入到三位小数。\n\n使用以下测试套件，其中每组括号内列出了以哈特里为单位的 $\\left(E_{AB}, E_{A}, E_{B}, E_{A}^{\\ast}, E_{B}^{\\ast}\\right)$：\n- 用例 A: $\\left(-152.058500,\\,-76.025000,\\,-76.025000,\\,-76.025950,\\,-76.025950\\right)$。\n- 用例 B: $\\left(-152.052300,\\,-76.026000,\\,-76.026000,\\,-76.026000,\\,-76.026000\\right)$。\n- 用例 C: $\\left(-152.042300,\\,-76.020000,\\,-76.022000,\\,-76.020200,\\,-76.022300\\right)$。\n- 用例 D: $\\left(-152.010000,\\,-76.000000,\\,-76.000000,\\,-76.003000,\\,-76.003000\\right)$。\n\n你的程序必须为每个用例计算一个包含两个元素的列表，其中包含未经平衡校正的结合能和经过平衡校正的结合能，两者均以 $\\text{kJ}\\cdot\\text{mol}^{-1}$ 为单位并四舍五入到三位小数。将所有用例的结果按以上顺序汇总到一个列表中。你的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表，每个元素本身也是一个包含两个元素的列表，例如 $[\\,[x_{1},y_{1}],\\,[x_{2},y_{2}],\\,[x_{3},y_{3}],\\,[x_{4},y_{4}]\\,]$，其中所有 $x_{i}$ 和 $y_{i}$ 均以 $\\text{kJ}\\cdot\\text{mol}^{-1}$ 为单位，并四舍五入到三位小数的浮点数形式给出。", "solution": "问题陈述已经过严格验证，并被认定为有效。它具有科学依据、提法明确且客观。它提出了一个标准的计算化学问题，涉及计算包含和不包含基组重叠误差（BSSE）校正的相互作用能。所有必需的数据、公式和常数均已提供，不存在内部矛盾或歧义。\n\n任务是根据几组预先计算好的电子能量，计算水二聚体的结合能 $\\Delta E$。这将通过两种方式完成：首先是简单的（未校正的）结合能，其次是使用 Boys 和 Bernardi 的平衡（CP）方法对 BSSE 进行校正后的结合能。最初以哈特里原子单位计算的结果，必须转换为千焦每摩尔（$\\text{kJ}\\cdot\\text{mol}^{-1}$）并四舍五入到三位小数。\n\n未校正的结合能 $\\Delta E_{\\mathrm{bind}}$ 定义为二聚体复合物的总能量 $E_{AB}$ 与孤立单体能量之和 $(E_{A} + E_{B})$ 之间的差值。\n$$\n\\Delta E_{\\mathrm{bind}} = E_{AB} - (E_{A} + E_{B})\n$$\n\n然而，在使用有限的、以原子为中心的基组时，这个定义是有缺陷的。在二聚体的计算中，每个单体都可以从其伙伴那里“借用”基函数，而这种效应在孤立单体的计算中是不存在的。这种纯粹由数学带来的额外灵活性，使得单体的电子密度可以被更好地描述，从而人为地降低了复合物的能量 $E_{AB}$。这导致了对结合引力的过高估计。这种赝象被称为基组重叠误差。\n\n为了校正这个问题，平衡方法引入了“鬼”轨道。每个单体的能量在其伙伴的基函数存在但没有其原子核或电子的情况下被重新计算。这些能量记为 $E_{A}^{\\ast}$ 和 $E_{B}^{\\ast}$。根据变分原理，$E_{A}^{\\ast} \\leq E_{A}$ 且 $E_{B}^{\\ast} \\leq E_{B}$，因为额外基函数的存在只能降低或保持计算出的能量。\n\n经过平衡校正的结合能 $\\Delta E_{\\mathrm{bind}}^{\\mathrm{CP}}$ 定义为：\n$$\n\\Delta E_{\\mathrm{bind}}^{\\mathrm{CP}} = E_{AB} - (E_{A}^{\\ast} + E_{B}^{\\ast})\n$$\n该表达式将二聚体的能量与在等效扩展基组中计算出的单体能量进行比较，从而提供一个更具物理意义的相互作用能。\n\n从哈特里到 $\\text{kJ}\\cdot\\text{mol}^{-1}$ 的转换是使用提供的常数 $k = 2625.49962\\,\\text{kJ}\\cdot\\text{mol}^{-1}\\cdot\\text{hartree}^{-1}$ 进行的。每个测试用例的步骤如下：\n1. 以哈特里为单位计算 $\\Delta E_{\\mathrm{bind}}$。\n2. 以哈特里为单位计算 $\\Delta E_{\\mathrm{bind}}^{\\mathrm{CP}}$。\n3. 将两个结果都乘以转换因子 $k$。\n4. 将最终值四舍五入到三位小数。\n\n让我们以用例 A 为例进行演示：\n给定的能量（单位为哈特里）是：$E_{AB} = -152.058500$, $E_{A} = -76.025000$, $E_{B} = -76.025000$, $E_{A}^{\\ast} = -76.025950$ 及 $E_{B}^{\\ast} = -76.025950$。\n\n1. 计算 $\\Delta E_{\\mathrm{bind}}$:\n    $$\n    \\Delta E_{\\mathrm{bind}} = -152.058500 - (-76.025000 + -76.025000) = -152.058500 - (-152.050000) = -0.008500\\,\\text{hartree}\n    $$\n2. 计算 $\\Delta E_{\\mathrm{bind}}^{\\mathrm{CP}}$:\n    $$\n    \\Delta E_{\\mathrm{bind}}^{\\mathrm{CP}} = -152.058500 - (-76.025950 + -76.025950) = -152.058500 - (-152.051900) = -0.006600\\,\\text{hartree}\n    $$\n3. 转换为 $\\text{kJ}\\cdot\\text{mol}^{-1}$:\n    $$\n    \\Delta E_{\\mathrm{bind}} (\\text{kJ}\\cdot\\text{mol}^{-1}) = -0.008500 \\times 2625.49962 \\approx -22.31675\\,\\text{kJ}\\cdot\\text{mol}^{-1}\n    $$\n    $$\n    \\Delta E_{\\mathrm{bind}}^{\\mathrm{CP}} (\\text{kJ}\\cdot\\text{mol}^{-1}) = -0.006600 \\times 2625.49962 \\approx -17.32830\\,\\text{kJ}\\cdot\\text{mol}^{-1}\n    $$\n4. 四舍五入到三位小数：\n    用例 A 得到的值对是 $[-22.317, -17.328]$。\n\n同样的系统性步骤将应用于所有提供的测试用例。实现将精确地遵循这一逻辑。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates uncorrected and counterpoise-corrected binding energies for\n    a water dimer based on provided electronic energy values.\n    \"\"\"\n\n    # The conversion factor from hartree to kJ/mol.\n    # 1 hartree = 2625.49962 kJ/mol\n    HARTREE_TO_KJ_MOL = 2625.49962\n\n    # Define the test cases from the problem statement.\n    # Each tuple contains (E_AB, E_A, E_B, E_A_star, E_B_star) in hartree.\n    test_cases = [\n        (-152.058500, -76.025000, -76.025000, -76.025950, -76.025950), # Case A\n        (-152.052300, -76.026000, -76.026000, -76.026000, -76.026000), # Case B\n        (-152.042300, -76.020000, -76.022000, -76.020200, -76.022300), # Case C\n        (-152.010000, -76.000000, -76.000000, -76.003000, -76.003000), # Case D\n    ]\n\n    all_results = []\n    for case in test_cases:\n        E_AB, E_A, E_B, E_A_star, E_B_star = case\n\n        # Calculate binding energy without counterpoise correction (in hartree)\n        # delta_E_bind = E_AB - (E_A + E_B)\n        delta_e_bind_hartree = E_AB - (E_A + E_B)\n\n        # Calculate binding energy with counterpoise correction (in hartree)\n        # delta_E_bind_CP = E_AB - (E_A* + E_B*)\n        delta_e_bind_cp_hartree = E_AB - (E_A_star + E_B_star)\n\n        # Convert both binding energies to kJ/mol\n        delta_e_bind_kj_mol = delta_e_bind_hartree * HARTREE_TO_KJ_MOL\n        delta_e_bind_cp_kj_mol = delta_e_bind_cp_hartree * HARTREE_TO_KJ_MOL\n\n        # Round the results to three decimal places\n        rounded_bind = round(delta_e_bind_kj_mol, 3)\n        rounded_bind_cp = round(delta_e_bind_cp_kj_mol, 3)\n\n        # Append the pair of results for the current case\n        all_results.append([rounded_bind, rounded_bind_cp])\n\n    # Format the final output string to match the required format:\n    # [[x1,y1],[x2,y2],[x3,y3],[x4,y4]]\n    # This is done by creating a string representation for each inner list\n    # and then joining them with commas.\n    inner_strings = [f\"[{res[0]},{res[1]}]\" for res in all_results]\n    final_output_string = f\"[{','.join(inner_strings)}]\"\n\n    # Final print statement in the exact required format.\n    print(final_output_string)\n\nsolve()\n```", "id": "2451348"}]}