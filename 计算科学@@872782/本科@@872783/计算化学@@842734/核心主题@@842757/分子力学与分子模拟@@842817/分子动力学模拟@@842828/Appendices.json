{"hands_on_practices": [{"introduction": "在分子动力学模拟中，积分步长$dt$的选择是一个至关重要的权衡。过大的步长会导致能量不守恒和模拟“爆炸”，而过小的步长则会极大地增加计算成本。这项练习将通过一个简化的谐振子模型，帮助你亲手探索数值稳定性的极限，并理解为何必须根据系统中最高频率的运动来选择合适的$dt$。[@problem_id:2458247]", "problem": "要求您实现一个自洽的、基于第一性原理的计算实验，以研究代表蛋白质分子动力学（MD）中刚性简正模的单一维谐波模的时间步长稳定性。该系统是一个质量为 $m$ 的粒子，在力常数为 $k$ 的谐波势中运动，其演化遵循牛顿第二定律。在整个过程中使用约化的无量纲单位；不要为任何量附加物理单位。\n\n动力学由牛顿第二定律定义：\n$$ m \\ddot{x}(t) = -k x(t) $$\n初始条件为 $x(0) = x_0$ 和 $\\dot{x}(0) = v_0$。总能量为：\n$$ E(t) = \\frac{1}{2} m \\dot{x}(t)^2 + \\frac{1}{2} k x(t)^2 $$\n对于给定的离散时间步长 $dt$，模拟总模拟时间 $T$ 内的运动，并在轨迹中监测 $E(t)$。\n\n对于选定的 $dt$，如果在任何模拟步骤中发生以下三个事件之一，则定义为发生了“爆炸”：\n- 计算出的总能量 $E(t)$ 变为非有限值（即，不是一个实数、有限的数）。\n- 相对能量误差超过指定容差，即在模拟结束前的任何时间 $t$，有 $\\lvert E(t) - E(0) \\rvert / E(0) > \\varepsilon$。\n- 位置的量值超过了从初始能量导出的预设界限，即对于任何 $t$，有 $\\lvert x(t) \\rvert > B \\, A_0$，其中 $A_0 = \\sqrt{2 E(0)/k}$。\n\n对于下面的每个测试用例，您将获得参数集 $(m, k, x_0, v_0, T, \\varepsilon, B)$ 和一个有序的时间步长列表 $[dt_1, dt_2, \\dots, dt_n]$。对于每个测试用例，按给定顺序分别为列表中的每个 $dt_i$ 模拟系统，并找出列表中导致上述定义下发生爆炸的最小 $dt_i$。如果列出的 $dt_i$ 均未导致爆炸，则返回哨兵值 $-1.0$。\n\n使用以下四个测试用例。下面所有的符号和数字都应解释为约化的无量纲单位。\n\n测试用例 1:\n- 参数：$m = 1.0$, $k = 1.0$, $x_0 = 1.0$, $v_0 = 1.0$, $T = 100.0$, $\\varepsilon = 0.20$, $B = 100.0$。\n- 待测试的时间步长（按升序排列）：$[0.1, 0.5, 1.5, 1.9, 2.0, 2.1]$。\n\n测试用例 2:\n- 参数：$m = 1.0$, $k = 16.0$, $x_0 = 1.0$, $v_0 = 1.0$, $T = 20.0$, $\\varepsilon = 0.10$, $B = 100.0$。\n- 待测试的时间步长（按升序排列）：$[0.05, 0.10, 0.30, 0.49, 0.50, 0.51]$。\n\n测试用例 3:\n- 参数：$m = 2.0$, $k = 0.5$, $x_0 = 1.0$, $v_0 = 1.0$, $T = 50.0$, $\\varepsilon = 0.05$, $B = 1000.0$。\n- 待测试的时间步长（按升序排列）：$[0.50, 1.00, 2.00, 3.00, 3.50]$。\n\n测试用例 4:\n- 参数：$m = 1.0$, $k = 100.0$, $x_0 = 1.0$, $v_0 = 1.0$, $T = 8.0$, $\\varepsilon = 0.15$, $B = 100.0$。\n- 待测试的时间步长（按升序排列）：$[0.02, 0.10, 0.19, 0.20, 0.25]$。\n\n您的程序必须生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。每个结果必须是浮点数，保留六位小数，并与上述测试用例的顺序相同。例如，如果四个测试用例的结果是 $r_1$、$r_2$、$r_3$ 和 $r_4$，您的程序必须精确打印\n\"[r1,r2,r3,r4]\"\n其中每个 $r_i$ 格式化为六位小数，且不含任何附加文本。\n\n如果内部出现任何角度量，必须以弧度处理。此问题中的所有值通过构造都是无量纲的，因此输出中不应显示任何物理单位。", "solution": "该问题要求进行一个计算实验，以确定一维谐振子数值积分方案的稳定性极限。该谐振子可作为分子动力学（MD）模拟中刚性振动模式的模型。该问题是适定的且具有科学依据。它构成了对数值积分稳定性的直接测试，这是计算科学中的一个基本概念。\n\n该系统由简谐振子的运动方程描述：\n$$\nm \\frac{d^2x}{dt^2} = -k x(t)\n$$\n其中 $m$ 是质量，$k$ 是力常数，$x(t)$ 是位置。该振子的角频率为 $\\omega = \\sqrt{k/m}$。动力学将从初始条件 $x(0) = x_0$ 和 $\\dot{x}(0) = v_0$ 开始，使用离散时间步长 $dt$ 进行传播。\n\n问题陈述没有指定数值积分算法。对于牛顿力学的 MD 模拟，Velocity-Verlet 算法因其时间可逆性和辛性质而成为一种标准、广泛使用且稳健的选择，这些特性使其具有良好的长期能量守恒性。因此，Velocity-Verlet 积分器是适合实现的算法。\n\nVelocity-Verlet 算法包含以下步骤，用于将系统从时间 $t$推进到 $t+dt$：\n1.  计算半步速度：\n    $$\n    v(t + \\tfrac{1}{2}dt) = v(t) + \\tfrac{1}{2} a(t) dt\n    $$\n2.  将位置更新到完整的新时间步：\n    $$\n    x(t + dt) = x(t) + v(t + \\tfrac{1}{2}dt) dt\n    $$\n3.  计算新位置处的加速度。加速度由力 $F(x) = -kx$ 导出，因此 $a(x) = F(x)/m = -(k/m)x$：\n    $$\n    a(t + dt) = -\\frac{k}{m} x(t + dt)\n    $$\n4.  计算新时间点的全步速度：\n    $$\n    v(t + dt) = v(t + \\tfrac{1}{2}dt) + \\tfrac{1}{2} a(t + dt) dt\n    $$\n\n对于每个测试用例，我们都得到一组参数 $(m, k, x_0, v_0, T, \\varepsilon, B)$ 和一个有序的时间步长列表 $[dt_1, dt_2, \\dots]$。任务是从这个列表中找出导致模拟变得不稳定或“爆炸”的最小 $dt_i$。对于给定的 $dt$，模拟运行总时间 $T$，对应于 $N_{steps} = \\lfloor T/dt \\rfloor$ 个积分步长。\n\n在模拟循环开始之前，我们必须为爆炸标准建立基线。初始总能量 $E(0)$ 计算如下：\n$$\nE(0) = \\frac{1}{2} m v_0^2 + \\frac{1}{2} k x_0^2\n$$\n问题指出，对于所有测试用例，$x_0$、$v_0$、$m$ 和 $k$ 均为正值，确保 $E(0) > 0$。特征振幅 $A_0$ 定义为：\n$$\nA_0 = \\sqrt{\\frac{2 E(0)}{k}}\n$$\n这个 $A_0$ 代表了精确解析解中的最大位移。\n\n模拟通过迭代 Velocity-Verlet 算法 $N_{steps}$ 次来进行。每一步之后，我们获得新的状态 $(x(t+dt), v(t+dt))$ 并检查三个爆炸条件：\n1.  **能量的有限性**：新步骤的总能量 $E(t+dt) = \\frac{1}{2} m v(t+dt)^2 + \\frac{1}{2} k x(t+dt)^2$ 必须是一个有限实数。在计算上，通过验证值是否不是 `NaN`（非数字）或无穷大来检查。此条件检测灾难性的数值溢出。\n2.  **相对能量守恒**：当前能量与初始能量的相对偏差不得超过容差 $\\varepsilon$：\n    $$\n    \\frac{\\lvert E(t+dt) - E(0) \\rvert}{E(0)} > \\varepsilon\n    $$\n    此条件检测数值积分误差何时导致总能量出现显著的、非物理性的漂移，即使轨迹尚未发散到无穷大。\n3.  **位置界限**：位置的量值不得超过特征振幅的一个大倍数：\n    $$\n    \\lvert x(t+dt) \\rvert > B \\cdot A_0\n    $$\n    这是对轨迹发散的另一个实用检查，其中粒子会逃逸到离势能最小值非物理性的大距离处。\n\n每个测试用例的总体流程如下：\n遍历所提供的按升序排序的时间步长列表 $dt_i$。对于每个 $dt_i$：\n- 运行时间为 $T$ 的完整模拟。\n- 在模拟的每一步，检查三个爆炸条件。\n- 如果在模拟过程中的任何时刻满足任何条件，则认为该 $dt_i$ 的模拟是不稳定的。这个 $dt_i$ 就是该测试用例的结果，然后我们继续处理下一个测试用例。\n- 如果模拟在时间 $T$ 内完成且未发生任何爆炸，则认为此 $dt_i$ 是稳定的。然后我们继续测试列表中的下一个 $dt_i$。\n\n如果给定测试用例列表中的所有时间步长都导致稳定的模拟，则该测试用例的结果是哨兵值 $-1.0$。\n\n实现将包括一个主函数，该函数遍历所有测试用例。该函数将为每个测试用例调用一个子函数，该子函数又会遍历提供的 $dt$ 值并调用一个模拟函数。模拟函数实现 Velocity-Verlet 循环和上述稳定性检查。最终输出是每个案例中导致爆炸的最小 $dt$ 列表，如果没有找到，则为 $-1.0$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(m, k, x0, v0, T, epsilon, B, dt) -> bool:\n    \"\"\"\n    Runs a simulation of a 1D harmonic oscillator using the Velocity-Verlet algorithm.\n\n    Args:\n        m (float): Mass.\n        k (float): Force constant.\n        x0 (float): Initial position.\n        v0 (float): Initial velocity.\n        T (float): Total simulation time.\n        epsilon (float): Relative energy error tolerance.\n        B (float): Position bound factor.\n        dt (float): Time step.\n\n    Returns:\n        bool: True if an explosion occurs, False otherwise.\n    \"\"\"\n    if dt <= 0:\n        return False  # A time step of zero or less is not meaningful.\n\n    num_steps = int(T / dt)\n    \n    # Initial conditions\n    x = float(x0)\n    v = float(v0)\n    \n    # Calculate initial energy and derived bounds for explosion criteria\n    e0 = 0.5 * m * v**2 + 0.5 * k * x**2\n    \n    # The problem constraints ensure e0 > 0, so no division by zero.\n    a0 = np.sqrt(2 * e0 / k)\n    x_bound = B * a0\n\n    # Initial acceleration\n    a = -(k / m) * x\n    \n    # Main simulation loop\n    for _ in range(num_steps):\n        # Velocity-Verlet integrator\n        # v(t + dt/2)\n        v_half = v + 0.5 * a * dt\n        # x(t + dt)\n        x = x + v_half * dt\n        # a(t + dt)\n        a_new = -(k / m) * x\n        # v(t + dt)\n        v = v_half + 0.5 * a_new * dt\n        \n        # Update acceleration for the next step\n        a = a_new\n        \n        # Calculate current energy at the full step\n        e_current = 0.5 * m * v**2 + 0.5 * k * x**2\n        \n        # --- Check for explosion conditions ---\n        \n        # 1. Non-finite energy (numerical overflow)\n        if not np.isfinite(e_current):\n            return True  # Explosion\n            \n        # 2. Relative energy error exceeds tolerance\n        # In the case e0 is 0, any change would be an infinite relative error.\n        # But for the given test cases, e0 is always positive.\n        if abs(e_current - e0) / e0 > epsilon:\n            return True  # Explosion\n        \n        # 3. Position exceeds bound\n        if abs(x) > x_bound:\n            return True  # Explosion\n            \n    return False  # No explosion occurred\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        {\n            'params': (1.0, 1.0, 1.0, 1.0, 100.0, 0.20, 100.0),\n            'dts': [0.1, 0.5, 1.5, 1.9, 2.0, 2.1],\n        },\n        {\n            'params': (1.0, 16.0, 1.0, 1.0, 20.0, 0.10, 100.0),\n            'dts': [0.05, 0.10, 0.30, 0.49, 0.50, 0.51],\n        },\n        {\n            'params': (2.0, 0.5, 1.0, 1.0, 50.0, 0.05, 1000.0),\n            'dts': [0.50, 1.00, 2.00, 3.00, 3.50],\n        },\n        {\n            'params': (1.0, 100.0, 1.0, 1.0, 8.0, 0.15, 100.0),\n            'dts': [0.02, 0.10, 0.19, 0.20, 0.25],\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        m, k, x0, v0, T, epsilon, B = case['params']\n        dts = case['dts']\n        \n        explosion_dt = -1.0\n        # The 'dts' lists are sorted, so we find the smallest by breaking on the first hit.\n        for dt in dts:\n            if run_simulation(m, k, x0, v0, T, epsilon, B, dt):\n                explosion_dt = dt\n                break\n        \n        results.append(f\"{explosion_dt:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2458247"}, {"introduction": "为了在有限的计算资源下模拟宏观系统，我们通常使用周期性边界条件（PBC）来消除表面效应。在PBC下计算粒子间相互作用的关键是最小镜像约定（MIC），它确保我们总是计算粒子与其最近的周期性镜像之间的距离。这个练习将指导你实现这一核心算法，这是构建任何有效的MD模拟程序的基础。[@problem_id:2458300]", "problem": "你需要编写一个完整、可运行的程序，来演示分子动力学 (MD) 模拟中周期性边界条件下最小镜像约定的效果。程序必须以两种方式计算正交周期性模拟盒子中两个粒子之间的欧几里得距离：(1) 忽略周期性的朴素欧几里得距离，以及 (2) 应用最小镜像约定后的欧几里得距离。距离必须以纳米 (nm) 为单位表示，并四舍五入到恰好六位小数。\n\n背景与基本原理：在带有周期性边界条件 (PBC) 的分子动力学 (MD) 模拟中，使用有限模拟盒子的无限平铺来模拟宏观体系的行为。两个粒子之间的物理距离被解释为一个粒子与另一个粒子的任意周期性镜像之间的最小距离。其底层的几何规则源自欧几里得距离的定义和晶格的平移对称性。对于边长为 $L_x$、$L_y$ 和 $L_z$ 的正交盒子，最小距离是通过沿每个轴选择整数倍的盒子长度平移来获得的，从而使位移向量的欧几里得范数最小化。你的程序必须实现这一规则。\n\n你的任务：\n- 定义一个函数，给定两个以纳米为单位的三维位置 $\\mathbf{r}_i$ 和 $\\mathbf{r}_j$ 以及以纳米为单位的盒子长度 $(L_x,L_y,L_z)$，返回两个值：\n  1) 以 nm 为单位的朴素欧几里得距离 $d_{\\text{naive}} = \\lVert \\mathbf{r}_j - \\mathbf{r}_i \\rVert$，\n  2) 以 nm 为单位的最小镜像约定距离 $d_{\\text{mic}}$，通过将位移分量平移 $(L_x,L_y,L_z)$ 的整数倍以最小化范数而获得。\n- 将盒子视为正交且轴对齐的。\n- 位置可能位于主盒子区间之外。你的实现仍必须利用周期性正确计算 $d_{\\text{mic}}$。\n- 为使你的实现清晰，请在程序中包含一个多行伪代码字符串（不打印），概述你所实现的最小镜像约定逻辑。\n\n数值和单位要求：\n- 所有距离必须以纳米 (nm) 为单位。\n- 报告的距离需四舍五入到恰好 $6$ 位小数。\n\n测试套件：\n你的程序必须按规定顺序为以下 $5$ 个测试用例中的每一个计算 $[d_{\\text{naive}}, d_{\\text{mic}}]$。\n\n1) 正常情况，盒子内的小分离：\n- 盒子: $(L_x,L_y,L_z) = (\\,3.0\\,\\text{nm},\\,3.0\\,\\text{nm},\\,3.0\\,\\text{nm}\\,)$\n- $\\mathbf{r}_i = (\\,0.5\\,\\text{nm},\\,1.0\\,\\text{nm},\\,1.5\\,\\text{nm}\\,)$\n- $\\mathbf{r}_j = (\\,0.7\\,\\text{nm},\\,1.2\\,\\text{nm},\\,1.6\\,\\text{nm}\\,)$\n\n2) 沿一个轴穿越周期性边界：\n- 盒子: $(L_x,L_y,L_z) = (\\,3.0\\,\\text{nm},\\,3.0\\,\\text{nm},\\,3.0\\,\\text{nm}\\,)$\n- $\\mathbf{r}_i = (\\,0.1\\,\\text{nm},\\,1.0\\,\\text{nm},\\,1.0\\,\\text{nm}\\,)$\n- $\\mathbf{r}_j = (\\,2.9\\,\\text{nm},\\,1.0\\,\\text{nm},\\,1.0\\,\\text{nm}\\,)$\n\n3) 各向异性盒子和多轴环绕：\n- 盒子: $(L_x,L_y,L_z) = (\\,2.0\\,\\text{nm},\\,4.0\\,\\text{nm},\\,5.0\\,\\text{nm}\\,)$\n- $\\mathbf{r}_i = (\\,1.9\\,\\text{nm},\\,0.2\\,\\text{nm},\\,4.8\\,\\text{nm}\\,)$\n- $\\mathbf{r}_j = (\\,0.1\\,\\text{nm},\\,3.9\\,\\text{nm},\\,0.3\\,\\text{nm}\\,)$\n\n4) 沿一个轴恰好为半个盒子长度的分离（临界情况）：\n- 盒子: $(L_x,L_y,L_z) = (\\,4.0\\,\\text{nm},\\,4.0\\,\\text{nm},\\,4.0\\,\\text{nm}\\,)$\n- $\\mathbf{r}_i = (\\,0.0\\,\\text{nm},\\,0.0\\,\\text{nm},\\,0.0\\,\\text{nm}\\,)$\n- $\\mathbf{r}_j = (\\,2.0\\,\\text{nm},\\,0.0\\,\\text{nm},\\,0.0\\,\\text{nm}\\,)$\n\n5) 位置在主盒子区间之外：\n- 盒子: $(L_x,L_y,L_z) = (\\,3.0\\,\\text{nm},\\,3.0\\,\\text{nm},\\,3.0\\,\\text{nm}\\,)$\n- $\\mathbf{r}_i = (\\,{-}0.1\\,\\text{nm},\\,{-}0.1\\,\\text{nm},\\,{-}0.1\\,\\text{nm}\\,)$\n- $\\mathbf{r}_j = (\\,3.1\\,\\text{nm},\\,3.1\\,\\text{nm},\\,3.1\\,\\text{nm}\\,)$\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的、由逗号分隔的数对列表。每个数对对应指定顺序的一个测试用例，并且必须采用 $[d_{\\text{naive}},d_{\\text{mic}}]$ 的形式，两个值都以纳米为单位，并四舍五入到恰好 $6$ 位小数。输出中不得有空格。\n- 例如，要求的整体格式类似于 $[[a_1,b_1],[a_2,b_2],\\dots]$，其中每个 $a_k$ 和 $b_k$ 都是以纳米为单位且恰好有 $6$ 位小数的浮点数。", "solution": "所提出的问题是计算统计力学中的一个基础练习，具体涉及分子动力学 (MD) 模拟中周期性边界条件 (PBC) 的实现。使用 PBC 是通过模拟少量有限粒子来近似宏观系统性质的一种标准且必要的技术。它减轻了严重的表面效应，否则这些效应将主导小系统的行为。这个问题的核心是正确计算粒子间距离，这由最小镜像约定 (MIC) 所支配。\n\n问题提法明确，具有科学依据，并为得到唯一且可验证的解提供了所有必要的数据。我们将进行严谨的推导和实现。\n\n设正交模拟盒子由一组对应于边长的三个正交向量定义，$\\mathbf{L} = (L_x, L_y, L_z)$。两个粒子 $i$ 和 $j$ 的位置由向量 $\\mathbf{r}_i$ 和 $\\mathbf{r}_j$ 给出。\n\n首先，我们定义朴素欧几里得距离 $d_{\\text{naive}}$。这是非周期性三维欧几里得空间中的标准距离。它是通过位移向量 $\\Delta\\mathbf{r} = \\mathbf{r}_j - \\mathbf{r}_i$ 的范数计算得出的。\n$$\nd_{\\text{naive}} = \\lVert \\Delta\\mathbf{r} \\rVert = \\sqrt{(\\Delta x)^2 + (\\Delta y)^2 + (\\Delta z)^2}\n$$\n其中 $\\Delta\\mathbf{r} = (\\Delta x, \\Delta y, \\Delta z)$。此计算忽略了模拟盒子的周期性，并将系统视为孤立在真空中。\n\n其次，我们讨论最小镜像约定距离 $d_{\\text{mic}}$。在周期性系统中，模拟盒子在所有方向上无限复制。位于位置 $\\mathbf{r}$ 的粒子在位置 $\\mathbf{r} + n_x L_x \\hat{\\mathbf{x}} + n_y L_y \\hat{\\mathbf{y}} + n_z L_z \\hat{\\mathbf{z}}$ 处拥有一个无限的周期性镜像晶格，其中 $n_x, n_y, n_z$ 是任意整数。粒子 $i$ 和粒子 $j$ 之间的物理距离是粒子 $i$ 与粒子 $j$ 的*任何*一个周期性镜像之间的最短距离。\n\n数学上，这表示为：\n$$\nd_{\\text{mic}} = \\min_{n_x, n_y, n_z \\in \\mathbb{Z}} \\left\\lVert (\\mathbf{r}_j - \\mathbf{r}_i) - (n_x L_x \\hat{\\mathbf{x}} + n_y L_y \\hat{\\mathbf{y}} + n_z L_z \\hat{\\mathbf{z}}) \\right\\rVert\n$$\n对于正交盒子，范数的最小化可以对每个笛卡尔分量独立进行。让我们考虑位移向量的 $x$ 分量，$\\Delta x = x_j - x_i$。我们必须找到一个整数 $n_x$ 来最小化 $|\\Delta x - n_x L_x|$。当 $n_x$ 是与比率 $\\Delta x / L_x$ 最接近的整数时，即可实现此目的。这就是“最近整数函数”，通常表示为 $\\text{nint}(s)$ 或通过 `round(s)` 实现。\n\n因此，经过 MIC 调整的位移分量 $\\Delta x'$ 为：\n$$\n\\Delta x' = \\Delta x - L_x \\cdot \\text{round}\\left(\\frac{\\Delta x}{L_x}\\right)\n$$\n这个公式正确地将位移向量分量“包裹”到区间 $[-L_x/2, L_x/2]$ 内。同样的逻辑也适用于 $y$ 和 $z$ 分量。那么，完整的经 MIC 调整的位移向量 $\\Delta\\mathbf{r}'$ 是：\n$$\n\\Delta\\mathbf{r}' = \\left( \\Delta x - L_x \\cdot \\text{round}\\left(\\frac{\\Delta x}{L_x}\\right), \\Delta y - L_y \\cdot \\text{round}\\left(\\frac{\\Delta y}{L_y}\\right), \\Delta z - L_z \\cdot \\text{round}\\left(\\frac{\\Delta z}{L_z}\\right) \\right)\n$$\n这种向量运算是稳健的，并且能正确处理粒子坐标可能位于主模拟盒子之外的情况，因为只有它们的相对位移是重要的。\n\n最小镜像距离 $d_{\\text{mic}}$ 是这个调整后位移向量的欧几里得范数：\n$$\nd_{\\text{mic}} = \\lVert \\Delta\\mathbf{r}' \\rVert = \\sqrt{(\\Delta x')^2 + (\\Delta y')^2 + (\\Delta z')^2}\n$$\n\n所提供的测试用例将使用这种既定方法来解决。实现将利用 `numpy` 库进行高效的向量运算。对于每个测试用例，我们将计算 $d_{\\text{naive}}$ 和 $d_{\\text{mic}}$，并按规定将结果四舍五入到恰好 $6$ 位小数进行报告。位移恰好为盒子长度一半的特殊情况，例如 $\\Delta x = L_x/2$，由 `round` 函数处理，该函数通常四舍五入到最近的偶数（例如，在 `numpy` 中），但无论调整后位移的符号选择如何，最终的距离都是唯一的 $L_x/2$。对于 $\\Delta x = L_x/2$，$\\Delta x' = L_x/2 - L_x \\cdot \\text{round}(0.5) = L_x/2 - L_x \\cdot 0 = L_x/2$。其大小是明确的。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of calculating naive and minimum image convention (MIC)\n    distances for a set of test cases in a molecular dynamics context.\n    \"\"\"\n\n    # Per the problem specification, this multi-line string contains the\n    # pseudocode explaining the implemented MIC logic. It is not printed.\n    # noinspection PyUnusedLocal\n    MIC_PSEUDOCODE = \"\"\"\n    function calculate_minimum_image_distance(r_i, r_j, box_dims):\n        // r_i, r_j: 3D position vectors [x, y, z] of two particles in nm.\n        // box_dims: 3D vector of orthorhombic box lengths [L_x, L_y, L_z] in nm.\n\n        // 1. Calculate the raw displacement vector.\n        //    This is a simple vector subtraction.\n        delta_r = r_j - r_i\n\n        // 2. Apply the minimum image convention to each component of the displacement vector.\n        //    For an orthorhombic box, this can be done independently for each axis.\n        //    The principle is to find the closest periodic image by shifting the displacement\n        //    by an integer number of box lengths. This is mathematically equivalent to\n        //    finding the nearest integer multiple of the box length to subtract.\n        \n        //    Let dr_c be a component of delta_r (e.g., delta_x) and L_c be the\n        //    corresponding box length (e.g., L_x).\n        //    The scaled displacement is s = dr_c / L_c.\n        //    The nearest integer number of box lengths to shift by is n = round(s).\n        //    The MIC-adjusted displacement component is dr'_c = dr_c - n * L_c.\n\n        //    In vector notation, this is:\n        mic_delta_r = delta_r - box_dims * np.round(delta_r / box_dims)\n        \n        // 3. Calculate the Euclidean norm (length) of the MIC-adjusted displacement vector.\n        //    This is the final minimum image distance.\n        distance_mic = sqrt(mic_delta_r[0]^2 + mic_delta_r[1]^2 + mic_delta_r[2]^2)\n        \n        return distance_mic\n    \"\"\"\n\n    def compute_distances(r_i_tuple, r_j_tuple, box_dims_tuple):\n        \"\"\"\n        Calculates naive and MIC distances for a single pair of particles.\n        \n        Args:\n            r_i_tuple (tuple): Position of particle i.\n            r_j_tuple (tuple): Position of particle j.\n            box_dims_tuple (tuple): Orthorhombic box dimensions (Lx, Ly, Lz).\n        \n        Returns:\n            A list containing two floats: [d_naive, d_mic].\n        \"\"\"\n        r_i = np.array(r_i_tuple, dtype=float)\n        r_j = np.array(r_j_tuple, dtype=float)\n        box_dims = np.array(box_dims_tuple, dtype=float)\n\n        # 1. Naive Euclidean distance\n        delta_r_naive = r_j - r_i\n        d_naive = np.linalg.norm(delta_r_naive)\n\n        # 2. Minimum Image Convention (MIC) distance\n        # The logic delta_r - L * round(delta_r / L) correctly finds the\n        # shortest vector in a periodic lattice.\n        delta_r_mic = delta_r_naive - box_dims * np.round(delta_r_naive / box_dims)\n        d_mic = np.linalg.norm(delta_r_mic)\n        \n        return [d_naive, d_mic]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # 1) Happy path, small separation\n        {'r_i': (0.5, 1.0, 1.5), 'r_j': (0.7, 1.2, 1.6), 'box': (3.0, 3.0, 3.0)},\n        # 2) Crossing a periodic boundary\n        {'r_i': (0.1, 1.0, 1.0), 'r_j': (2.9, 1.0, 1.0), 'box': (3.0, 3.0, 3.0)},\n        # 3) Anisotropic box and multi-axis wrapping\n        {'r_i': (1.9, 0.2, 4.8), 'r_j': (0.1, 3.9, 0.3), 'box': (2.0, 4.0, 5.0)},\n        # 4) Exactly half-box separation\n        {'r_i': (0.0, 0.0, 0.0), 'r_j': (2.0, 0.0, 0.0), 'box': (4.0, 4.0, 4.0)},\n        # 5) Positions outside the primary box\n        {'r_i': (-0.1, -0.1, -0.1), 'r_j': (3.1, 3.1, 3.1), 'box': (3.0, 3.0, 3.0)},\n    ]\n\n    result_strings = []\n    for case in test_cases:\n        d_naive, d_mic = compute_distances(case['r_i'], case['r_j'], case['box'])\n        \n        # Format the numbers to exactly 6 decimal places and create the pair string.\n        # This ensures trailing zeros are included and meets the formatting requirement.\n        result_strings.append(f\"[{d_naive:.6f},{d_mic:.6f}]\")\n\n    # Final print statement in the exact required format: [[a1,b1],[a2,b2],...]\n    # without spaces between elements.\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```", "id": "2458300"}, {"introduction": "分子动力学模拟的最终目标是从生成的轨迹中提取有意义的科学结论。这项实践将带你进入模拟后分析的世界，以一个常见的任务为例：分析氢键的动态行为。你将编写一个脚本，根据几何标准来识别氢键，并量化它们的寿命，这是理解分子识别和复合物稳定性的关键一步。[@problem_id:2458278]", "problem": "您将获得简化的分子轨迹数据，这些数据代表了蛋白质-配体复合物中候选氢键的特定供体-氢-受体三联体。对于每个测试用例，您将获得以皮秒为单位的时间步长 $\\Delta t$，以埃（记作 $\\mathrm{\\AA}$）为单位的距离截断值 $r_{\\mathrm{cut}}$，以及以度为单位的角度截断值 $\\theta_{\\mathrm{cut}}$。在帧索引为 $i$ 时，当且仅当以下两个几何标准都满足时，定义为存在一个氢键：\n\n1. 氢-受体距离满足 $\\lVert \\mathbf{r}_{\\mathrm{A}}(i) - \\mathbf{r}_{\\mathrm{H}}(i) \\rVert \\le r_{\\mathrm{cut}}$，单位为 $\\mathrm{\\AA}$。\n2. 供体-氢-受体角度满足 $\\angle \\mathrm{D}\\!-\\!\\mathrm{H}\\!-\\!\\mathrm{A}(i) \\ge \\theta_{\\mathrm{cut}}$，单位为度，其中 $\\angle \\mathrm{D}\\!-\\!\\mathrm{H}\\!-\\!\\mathrm{A}(i)$ 是由向量 $\\mathbf{u}(i) = \\mathbf{r}_{\\mathrm{D}}(i) - \\mathbf{r}_{\\mathrm{H}}(i)$ 和 $\\mathbf{v}(i) = \\mathbf{r}_{\\mathrm{A}}(i) - \\mathbf{r}_{\\mathrm{H}}(i)$ 在氢原子处形成的角，通过以下公式计算：\n$$\n\\angle \\mathrm{D}\\!-\\!\\mathrm{H}\\!-\\!\\mathrm{A}(i) = \\cos^{-1}\\!\\left(\\frac{\\mathbf{u}(i)\\cdot \\mathbf{v}(i)}{\\lVert \\mathbf{u}(i)\\rVert\\,\\lVert \\mathbf{v}(i)\\rVert}\\right)\\,.\n$$\n\n对于每个测试用例，考虑所有提供的目标三联体（每个三联体定义一个跨帧追踪的候选氢键）。将连续氢键事件定义为键合条件为真的最大连续帧块。设事件的持续时间为该块中的帧数乘以 $\\Delta t$，并以皮秒表示。在测试用例的所有三联体中，汇总来自每个三联体的每个事件，并计算：\n\n- 平均连续寿命（单位：皮秒），等于所有事件持续时间的算术平均值（如果没有事件，则定义为 $0$）。\n- 最长连续寿命（单位：皮秒）（如果没有事件，则定义为 $0$）。\n- 连续事件的总数（一个整数）。\n- 延迟 $L=2$ 帧的存活分数，定义为连续持续时间跨越至少 $L+1$ 帧（即帧长度 $\\ge 3$）的事件所占的比例。将其表示为 $[0,1]$ 范围内的小数（如果没有事件，则定义为 $0$）。\n\n角度必须以度处理，距离以 $\\mathrm{\\AA}$ 处理，寿命以皮秒处理。您的程序必须使用以下测试套件，并按要求的输出格式生成结果。\n\n测试套件：\n\n测试用例 1：\n- $\\Delta t = 0.1$ ps, $r_{\\mathrm{cut}} = 2.5$ $\\mathrm{\\AA}$, $\\theta_{\\mathrm{cut}} = 150$ 度。\n- 两个三联体，每个追踪 $10$ 帧，索引为 $i = 0,1,\\dots,9$。\n- 在此测试用例中，对于两个三联体以及在每一帧，供体和氢的坐标是恒定的：$\\mathbf{r}_{\\mathrm{D}}(i) = (0,0,0)$ $\\mathrm{\\AA}$ 和 $\\mathbf{r}_{\\mathrm{H}}(i) = (1,0,0)$ $\\mathrm{\\AA}$。\n- 三联体 1 的受体坐标（按帧）：\n  当 $i=0,1,2$ 时为 $(2.0,0,0)$ $\\mathrm{\\AA}$；当 $i=3$ 时为 $(5.0,0,0)$ $\\mathrm{\\AA}$；当 $i=4,5,6$ 时为 $(2.2,0,0)$ $\\mathrm{\\AA}$；当 $i=7,8,9$ 时为 $(5.0,0,0)$ $\\mathrm{\\AA}$。\n- 三联体 2 的受体坐标（按帧）：\n  对于帧 $i \\in \\{0,1,3,6,7,8\\}$，为成键几何构型，$\\mathbf{r}_{\\mathrm{A}}(i) = (2.2,0,0)$ $\\mathrm{\\AA}$；对于帧 $i \\in \\{2,4,5,9\\}$，为非成键角度几何构型，$\\mathbf{r}_{\\mathrm{A}}(i) = (1.6,1.0392304845,0)$ $\\mathrm{\\AA}$。\n\n测试用例 2：\n- $\\Delta t = 0.05$ ps, $r_{\\mathrm{cut}} = 2.5$ $\\mathrm{\\AA}$, $\\theta_{\\mathrm{cut}} = 150$ 度。\n- 一个三联体，共 $5$ 帧，对于所有 $i$，$\\mathbf{r}_{\\mathrm{D}}(i) = (0,0,0)$ $\\mathrm{\\AA}$，$\\mathbf{r}_{\\mathrm{H}}(i) = (1,0,0)$ $\\mathrm{\\AA}$，以及 $\\mathbf{r}_{\\mathrm{A}}(i) = (2.0,0,0)$ $\\mathrm{\\AA}$。\n\n测试用例 3：\n- $\\Delta t = 0.1$ ps, $r_{\\mathrm{cut}} = 2.5$ $\\mathrm{\\AA}$, $\\theta_{\\mathrm{cut}} = 150$ 度。\n- 一个三联体，共 $6$ 帧，对于所有 $i$，$\\mathbf{r}_{\\mathrm{D}}(i) = (0,0,0)$ $\\mathrm{\\AA}$，$\\mathbf{r}_{\\mathrm{H}}(i) = (1,0,0)$ $\\mathrm{\\AA}$，以及 $\\mathbf{r}_{\\mathrm{A}}(i) = (10.0,0,0)$ $\\mathrm{\\AA}$。\n\n测试用例 4：\n- $\\Delta t = 0.1$ ps, $r_{\\mathrm{cut}} = 2.5$ $\\mathrm{\\AA}$, $\\theta_{\\mathrm{cut}} = 150$ 度。\n- 一个三联体，共 $8$ 帧，其中 $\\mathbf{r}_{\\mathrm{D}}(i) = (0,0,0)$ $\\mathrm{\\AA}$，$\\mathbf{r}_{\\mathrm{H}}(i) = (1,0,0)$ $\\mathrm{\\AA}$，受体坐标按帧交替变化：对于偶数 $i \\in \\{0,2,4,6\\}$，$\\mathbf{r}_{\\mathrm{A}}(i) = (2.2,0,0)$ $\\mathrm{\\AA}$；对于奇数 $i \\in \\{1,3,5,7\\}$，$\\mathbf{r}_{\\mathrm{A}}(i) = (5.0,0,0)$ $\\mathrm{\\AA}$。\n\n答案规格和单位：\n- 以浮点数形式报告平均寿命（单位：皮秒）。\n- 以浮点数形式报告最长寿命（单位：皮秒）。\n- 以整数形式报告事件数量。\n- 以 $[0,1]$ 范围内的小数（非百分比）形式报告延迟 $L=2$ 时的存活分数。\n- 您的程序应生成单行输出，其中包含四个测试用例的结果，形式为用方括号括起来的逗号分隔列表，每个元素是按 [average_lifetime_ps, longest_lifetime_ps, number_of_events, survival_fraction] 顺序排列的列表。例如：\"[[a1,b1,c1,d1],[a2,b2,c2,d2],[a3,b3,c3,d3],[a4,b4,c4,d4]]\"。", "solution": "问题陈述已经过严格审查，并被确定为有效。其科学基础在于计算化学的原理，特别是分子动力学轨迹的分析。该问题定义明确，提供了所有必要的数据和定义，确保了唯一且可计算的解。语言客观、精确，没有歧义或矛盾。因此，我们可以着手进行形式化的求解。\n\n任务是分析简化的分子轨迹数据，以表征氢键的动力学特性。这涉及计算几个统计指标：平均连续寿命、最长连续寿命、总成键事件数以及一个存活分数。解决方案需要对每个候选氢键（三联体）进行逐帧的系统分析，然后对给定测试用例内的所有三联体的结果进行汇总。\n\n算法流程如下：\n\n首先，对于每个测试用例，我们初始化一个全局列表，用于累积所有连续氢键事件的持续时间。然后，我们遍历所提供的每个供体-氢-受体三联体。\n\n对于单个三联体，我们必须首先确定在每一帧 $i$ 中是否存在氢键。这是通过对照给定的截断值 $r_{\\mathrm{cut}}$ 和 $\\theta_{\\mathrm{cut}}$ 检查两个几何标准来完成的。\n\n1.  **几何标准评估**：\n    对于每一帧 $i$，我们都获得了供体原子 $\\mathbf{r}_{\\mathrm{D}}(i)$、氢原子 $\\mathbf{r}_{\\mathrm{H}}(i)$ 和受体原子 $\\mathbf{r}_{\\mathrm{A}}(i)$ 的坐标。\n    \n    a. 我们定义两个源自氢原子的向量：指向供体的 $\\mathbf{u}(i) = \\mathbf{r}_{\\mathrm{D}}(i) - \\mathbf{r}_{\\mathrm{H}}(i)$ 和指向受体的 $\\mathbf{v}(i) = \\mathbf{r}_{\\mathrm{A}}(i) - \\mathbf{r}_{\\mathrm{H}}(i)$。\n    \n    b. 第一个标准是氢-受体距离。我们计算向量 $\\mathbf{v}(i)$ 的欧几里得范数，记为 $d_{\\mathrm{HA}}(i) = \\lVert \\mathbf{v}(i) \\rVert$。仅当 $d_{\\mathrm{HA}}(i) \\le r_{\\mathrm{cut}}$ 时，才可能形成键。\n    \n    c. 第二个标准是供体-氢-受体角度 $\\angle \\mathrm{D}\\!-\\!\\mathrm{H}\\!-\\!\\mathrm{A}(i)$。这是向量 $\\mathbf{u}(i)$ 和 $\\mathbf{v}(i)$ 之间的夹角，使用点积公式计算：\n    $$\n    \\angle \\mathrm{D}\\!-\\!\\mathrm{H}\\!-\\!\\mathrm{A}(i) = \\arccos\\left(\\frac{\\mathbf{u}(i)\\cdot \\mathbf{v}(i)}{\\lVert \\mathbf{u}(i)\\rVert\\,\\lVert \\mathbf{v}(i)\\rVert}\\right)\n    $$\n    `arccos` 函数的结果是弧度，必须转换为度才能与 $\\theta_{\\mathrm{cut}}$ 进行比较。转换公式为 $\\text{angle}_{\\text{deg}} = \\text{angle}_{\\text{rad}} \\times \\frac{180}{\\pi}$。仅当 $\\angle \\mathrm{D}\\!-\\!\\mathrm{H}\\!-\\!\\mathrm{A}(i) \\ge \\theta_{\\mathrm{cut}}$ 时，才可能形成键。\n\n    当且仅当两个条件都满足时，帧 $i$ 处存在氢键。此过程为每个三联体生成一个布尔时间序列，其中每个元素指示在该帧处氢键的存在 ($True$) 或不存在 ($False$)。\n\n2.  **连续事件的识别**：\n    “连续氢键事件”是键合条件为真的最大连续帧块。为了找出这些事件的长度，我们分析布尔时间序列。一种有效的方法是找到状态变化的索引。通过在布尔序列的开头和结尾填充 $False$，我们可以可靠地识别出每个 $True$ 值序列的开始和结束。结束索引和开始索引之差给出了每个连续事件的帧长度。对于一个布尔数组 `B`，我们构建一个填充过的整数数组 `P`。事件的开始索引对应于 `diff(P)` 为 $1$ 的位置，结束索引对应于 `diff(P)` 为 $-1$ 的位置。然后从这些对应的索引计算出长度。当前三联体的所有此类事件的长度被添加到测试用例的全局事件持续时间列表中。\n\n3.  **最终指标的计算**：\n    处理完一个测试用例中的所有三联体后，我们得到一个以帧为单位的所有事件长度的列表。设此列表为 $L_{\\text{frames}}$。\n\n    a. **处理空事件情况**：如果没有发现事件（$L_{\\text{frames}}$ 为空），则平均寿命、最长寿命、事件数和存活分数都定义为 $0$。\n\n    b. **转换为物理单位**：如果存在事件，我们首先将每个帧长度乘以时间步长 $\\Delta t$，将其转换为以皮秒为单位的寿命。设这个新列表为 $L_{\\text{ps}}$。\n    \n    c. **平均寿命和最长寿命**：平均连续寿命是 $L_{\\text{ps}}$ 中值的算术平均值。最长连续寿命是 $L_{\\text{ps}}$ 中的最大值。\n    \n    d. **事件总数**：这只是找到的事件总数，即列表 $L_{\\text{frames}}$ 的长度。\n    \n    e. **存活分数**：我们需要计算延迟 $L=2$ 时的存活分数。这是持续至少 $L+1 = 3$ 帧的事件所占的比例。我们计算 $L_{\\text{frames}}$ 中大于或等于 $3$ 的元素数量，然后将该计数除以事件总数。\n\n这整个过程被封装到一个函数中，应用于问题陈述中定义的每个测试用例。每个用例的结果被收集并格式化为指定的字符串输出。使用 `numpy` 库对于高效和准确的向量代数至关重要。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the hydrogen bond analysis problem for all test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"dt\": 0.1, \"rcut\": 2.5, \"thcut\": 150.0,\n            \"triplets\": [\n                {\n                    \"rD\": np.array([[0.0, 0.0, 0.0]] * 10),\n                    \"rH\": np.array([[1.0, 0.0, 0.0]] * 10),\n                    \"rA\": np.array([\n                        [2.0, 0.0, 0.0], [2.0, 0.0, 0.0], [2.0, 0.0, 0.0],  # 0,1,2\n                        [5.0, 0.0, 0.0],  # 3\n                        [2.2, 0.0, 0.0], [2.2, 0.0, 0.0], [2.2, 0.0, 0.0],  # 4,5,6\n                        [5.0, 0.0, 0.0], [5.0, 0.0, 0.0], [5.0, 0.0, 0.0]   # 7,8,9\n                    ])\n                },\n                {\n                    \"rD\": np.array([[0.0, 0.0, 0.0]] * 10),\n                    \"rH\": np.array([[1.0, 0.0, 0.0]] * 10),\n                    \"rA\": np.array([\n                        [2.2, 0.0, 0.0],                            # 0\n                        [2.2, 0.0, 0.0],                            # 1\n                        [1.6, 1.0392304845, 0.0],                   # 2\n                        [2.2, 0.0, 0.0],                            # 3\n                        [1.6, 1.0392304845, 0.0],                   # 4\n                        [1.6, 1.0392304845, 0.0],                   # 5\n                        [2.2, 0.0, 0.0],                            # 6\n                        [2.2, 0.0, 0.0],                            # 7\n                        [2.2, 0.0, 0.0],                            # 8\n                        [1.6, 1.0392304845, 0.0]                    # 9\n                    ])\n                }\n            ]\n        },\n        {\n            \"dt\": 0.05, \"rcut\": 2.5, \"thcut\": 150.0,\n            \"triplets\": [\n                {\n                    \"rD\": np.array([[0.0, 0.0, 0.0]] * 5),\n                    \"rH\": np.array([[1.0, 0.0, 0.0]] * 5),\n                    \"rA\": np.array([[2.0, 0.0, 0.0]] * 5)\n                }\n            ]\n        },\n        {\n            \"dt\": 0.1, \"rcut\": 2.5, \"thcut\": 150.0,\n            \"triplets\": [\n                {\n                    \"rD\": np.array([[0.0, 0.0, 0.0]] * 6),\n                    \"rH\": np.array([[1.0, 0.0, 0.0]] * 6),\n                    \"rA\": np.array([[10.0, 0.0, 0.0]] * 6)\n                }\n            ]\n        },\n        {\n            \"dt\": 0.1, \"rcut\": 2.5, \"thcut\": 150.0,\n            \"triplets\": [\n                {\n                    \"rD\": np.array([[0.0, 0.0, 0.0]] * 8),\n                    \"rH\": np.array([[1.0, 0.0, 0.0]] * 8),\n                    \"rA\": np.array([\n                        [2.2, 0.0, 0.0], [5.0, 0.0, 0.0],\n                        [2.2, 0.0, 0.0], [5.0, 0.0, 0.0],\n                        [2.2, 0.0, 0.0], [5.0, 0.0, 0.0],\n                        [2.2, 0.0, 0.0], [5.0, 0.0, 0.0]\n                    ])\n                }\n            ]\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        result = analyze_case(case[\"dt\"], case[\"rcut\"], case[\"thcut\"], case[\"triplets\"])\n        all_results.append(result)\n    \n    # Format the final output string exactly as specified.\n    # The map(str, ...) converts each sublist like [0.24, 0.3, 5, 0.6] into its string representation.\n    # The join function then concatenates them with commas.\n    print(f\"[{','.join(map(str, all_results))}]\", end=\"\")\n\n\ndef get_run_lengths(bool_array):\n    \"\"\"\n    Calculates the lengths of contiguous runs of True values in a boolean array.\n    This is a form of run-length encoding.\n    \"\"\"\n    if not np.any(bool_array):\n        return []\n    \n    # Pad the array with False at both ends to ensure runs at the start/end are captured.\n    padded = np.concatenate(([False], bool_array, [False]))\n    \n    # Convert to integer (0 or 1) to use np.diff\n    int_array = padded.astype(int)\n    \n    # Find indices where the sequence changes\n    diffs = np.diff(int_array)\n    \n    # Starts of runs are where the difference is +1 (False -> True)\n    starts = np.where(diffs == 1)[0]\n    \n    # Ends of runs are where the difference is -1 (True -> False)\n    ends = np.where(diffs == -1)[0]\n    \n    # The length of each run is the difference between its end and start index.\n    lengths = ends - starts\n    return lengths.tolist()\n\ndef analyze_case(dt, rcut, thcut, triplets_data):\n    \"\"\"\n    Analyzes a single test case to compute hydrogen bond statistics.\n    \"\"\"\n    all_event_frame_lengths = []\n\n    for triplet in triplets_data:\n        rD, rH, rA = triplet[\"rD\"], triplet[\"rH\"], triplet[\"rA\"]\n        num_frames = rD.shape[0]\n        \n        is_hbond_series = np.zeros(num_frames, dtype=bool)\n\n        for i in range(num_frames):\n            u = rD[i] - rH[i]  # Vector H -> D\n            v = rA[i] - rH[i]  # Vector H -> A\n\n            # Check distance criterion\n            dist_ha = np.linalg.norm(v)\n            if dist_ha > rcut:\n                continue\n\n            # Check angle criterion\n            # Handle potential zero-length vectors to avoid division by zero\n            norm_u = np.linalg.norm(u)\n            norm_v = dist_ha # already computed\n            if norm_u == 0 or norm_v == 0:\n                continue\n            \n            cos_theta = np.dot(u, v) / (norm_u * norm_v)\n            # Clip to handle floating point inaccuracies that may push cos_theta outside [-1, 1]\n            cos_theta = np.clip(cos_theta, -1.0, 1.0)\n            \n            angle_rad = np.arccos(cos_theta)\n            angle_deg = np.rad2deg(angle_rad)\n\n            if angle_deg >= thcut:\n                is_hbond_series[i] = True\n        \n        event_lengths = get_run_lengths(is_hbond_series)\n        all_event_frame_lengths.extend(event_lengths)\n    \n    # Calculate final metrics\n    num_events = len(all_event_frame_lengths)\n    \n    if num_events == 0:\n        return [0.0, 0.0, 0, 0.0]\n\n    # Convert frame lengths to picoseconds\n    event_durations_ps = np.array(all_event_frame_lengths) * dt\n\n    avg_lifetime = np.mean(event_durations_ps)\n    longest_lifetime = np.max(event_durations_ps)\n\n    # Survival fraction for lag L=2 (duration >= L+1=3 frames)\n    surviving_events = np.sum(np.array(all_event_frame_lengths) >= 3)\n    survival_fraction = surviving_events / num_events\n\n    return [round(avg_lifetime, 6), round(longest_lifetime, 6), int(num_events), round(survival_fraction, 6)]\n\n# Execute the main function\nsolve()\n```", "id": "2458278"}]}