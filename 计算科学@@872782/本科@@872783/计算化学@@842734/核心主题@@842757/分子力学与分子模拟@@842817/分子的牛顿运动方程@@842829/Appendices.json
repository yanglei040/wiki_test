{"hands_on_practices": [{"introduction": "理论学习的最终目的是应用于实践。第一个练习是一个经典的入门实践，它将一个分子简化到其最简单的形式——一个双原子系统，并运用牛顿第二定律来推导其自然振动频率。这个练习将抽象的经典力学与分子的具体属性联系起来，为分子模拟中使用的谐振子势模型奠定了基础。[@problem_id:2686820]", "problem": "一个线性双原子分子被建模为两个质点 $m_1$ 和 $m_2$ ，它们被约束在核间轴上运动，并通过围绕平衡间距 $r_e$ 的谐振势相互作用。假设小振幅（谐振）近似，因此恢复力由胡克定律（力常数为 $k$）支配。仅从牛顿第二定律和胡克定律出发，写出两个原子核偏离平衡位置的位移的耦合运动方程，消除质心运动以获得关于内坐标（键伸缩）的单个常微分方程，并由此确定振动角频率（用 $m_1$、$m_2$ 和 $k$ 表示）。\n\n将最终结果表示为角频率的单个闭合形式解析表达式。最终答案中不要提供中间步骤。无需单位，也无需四舍五入。", "solution": "该问题陈述是经典力学应用于分子振动的一个标准且适定的练习。它具有科学依据，内部一致，并包含求解所需的所有信息。我们将进行推导。\n\n设两个质点 $m_1$ 和 $m_2$ 沿核间轴的位置分别表示为 $x_1(t)$ 和 $x_2(t)$。平衡位置为 $x_{1,e}$ 和 $x_{2,e}$。平衡间距是一个常数，$r_e = x_{2,e} - x_{1,e}$。我们将每个质量偏离其各自平衡位置的位移定义为 $\\delta_1(t) = x_1(t) - x_{1,e}$ 和 $\\delta_2(t) = x_2(t) - x_{2,e}$。\n\n瞬时核间距为 $r(t) = x_2(t) - x_1(t)$。内坐标，表示化学键从其平衡长度的伸长量，定义为 $q(t) = r(t) - r_e$。这可以用各个位移来表示：\n$$q(t) = (x_2(t) - x_1(t)) - (x_{2,e} - x_{1,e}) = (x_2(t) - x_{2,e}) - (x_1(t) - x_{1,e}) = \\delta_2(t) - \\delta_1(t)$$\n\n恢复力由胡克定律 $F = -k'x'$ 支配，其中 $x'$ 是偏离平衡位置的位移。在我们的例子中，位移是内坐标 $q$。系统的势能为 $V = \\frac{1}{2} k q^2$。作用在每个质量上的力由势能的负梯度求得。\n作用在质量 $m_1$ 上的力是：\n$$F_1 = -\\frac{\\partial V}{\\partial x_1} = -\\frac{\\partial}{\\partial x_1} \\left( \\frac{1}{2} k (x_2 - x_1 - r_e)^2 \\right) = -k(x_2 - x_1 - r_e) \\cdot (-1) = k(x_2 - x_1 - r_e) = k q$$\n作用在质量 $m_2$ 上的力是：\n$$F_2 = -\\frac{\\partial V}{\\partial x_2} = -\\frac{\\partial}{\\partial x_2} \\left( \\frac{1}{2} k (x_2 - x_1 - r_e)^2 \\right) = -k(x_2 - x_1 - r_e) \\cdot (1) = -k(x_2 - x_1 - r_e) = -k q$$\n系统上的总外力为 $F_{total} = F_1 + F_2 = k q - k q = 0$，这证实了质心运动与内运动是解耦的。\n\n我们对每个质量应用牛顿第二定律 $F=ma$。加速度是位置的二阶时间导数，$\\ddot{x}$。由于平衡位置是恒定的，所以 $\\ddot{x}_1 = \\ddot{\\delta}_1$ 且 $\\ddot{x}_2 = \\ddot{\\delta}_2$。\n由此得到的位移的耦合运动方程为：\n$$m_1 \\ddot{\\delta}_1 = F_1 = k q$$\n$$m_2 \\ddot{\\delta}_2 = F_2 = -k q$$\n代入 $q = \\delta_2 - \\delta_1$，我们得到：\n$$m_1 \\ddot{\\delta}_1 = k (\\delta_2 - \\delta_1)$$\n$$m_2 \\ddot{\\delta}_2 = -k (\\delta_2 - \\delta_1)$$\n\n为了得到关于内坐标 $q$ 的单个微分方程，我们取其二阶时间导数：\n$$\\ddot{q} = \\ddot{\\delta}_2 - \\ddot{\\delta}_1$$\n从运动方程中，我们分离出加速度：\n$$\\ddot{\\delta}_1 = \\frac{k}{m_1} q$$\n$$\\ddot{\\delta}_2 = -\\frac{k}{m_2} q$$\n将这些表达式代入 $\\ddot{q}$ 的方程中：\n$$\\ddot{q} = \\left(-\\frac{k}{m_2} q\\right) - \\left(\\frac{k}{m_1} q\\right) = -k \\left( \\frac{1}{m_1} + \\frac{1}{m_2} \\right) q$$\n这就是关于内坐标 $q$ 的单个常微分方程。通常定义约化质量 $\\mu$ 为 $\\frac{1}{\\mu} = \\frac{1}{m_1} + \\frac{1}{m_2}$，这可将方程简化为：\n$$\\ddot{q} = -\\frac{k}{\\mu} q$$\n这可以重新排列成简谐振子的标准形式：\n$$\\ddot{q} + \\frac{k}{\\mu} q = 0$$\n简谐振子的一般方程是 $\\ddot{x} + \\omega^2 x = 0$，其中 $\\omega$ 是角频率。通过将我们的 $q$ 方程与一般形式直接比较，我们确定角频率的平方为：\n$$\\omega^2 = \\frac{k}{\\mu}$$\n因此，振动角频率为：\n$$\\omega = \\sqrt{\\frac{k}{\\mu}}$$\n为了仅用给定的参数 $k$、$m_1$ 和 $m_2$ 来表示，我们代入约化质量的定义：\n$$\\frac{1}{\\mu} = \\frac{1}{m_1} + \\frac{1}{m_2} = \\frac{m_2 + m_1}{m_1 m_2}$$\n因此，角频率的最终表达式是：\n$$\\omega = \\sqrt{k \\left(\\frac{1}{m_1} + \\frac{1}{m_2}\\right)} = \\sqrt{\\frac{k(m_1 + m_2)}{m_1 m_2}}$$\n这个结果是在谐振近似下双原子分子的基本振动频率。", "answer": "$$\\boxed{\\sqrt{\\frac{k(m_1 + m_2)}{m_1 m_2}}}$$", "id": "2686820"}, {"introduction": "对于复杂分子而言，解析解非常罕见，这时就需要计算机的帮助。这个练习将带你从纸笔推导转向编程实践，你将实现一个常用的积分算法（速度Verlet算法）来模拟一个粒子的运动，并亲眼见证当底层物理模型不正确时会发生什么。这个练习深刻揭示了精确的力计算与分子动力学轨迹稳定性之间的关键关系。[@problem_id:2459291]", "problem": "考虑一个被约束在一维空间中的单分子。设其坐标为 $r(t)$，速度为 $v(t) = \\frac{dr}{dt}$，质量为 $m$。其基本动力学方程为牛顿第二定律，$m \\frac{d^2 r}{dt^2} = F(r)$，其中 $F(r)$ 是沿该坐标的力。在平衡位置 $r_0$ 附近的典型谐波近似中，会使用与位移成正比的恢复力。然而，假设该力被错误地计算为位移的平方而不是线性项。您的任务是形式化所得到的运动方程，解释轨迹在性质上的差异，并通过数值积分来量化这些差异。\n\n从牛顿第二定律和核心运动学定义出发，在 $m = 1$、$k = 1$ 和 $r_0 = 0$ 的简化（无量纲）单位下执行以下操作：\n\n1. 对于正确的谐波模型，力为 $F_{\\text{harm}}(r) = -k (r - r_0)$。\n2. 对于不正确的模型，力为 $F_{\\text{sq}}(r) = -k (r - r_0)^2$。\n\n实现一个适用于二阶常微分方程的时间可逆辛积分器（例如，速度-Verlet 方案），用于从相同的初始条件出发，对两种力模型的 $m \\frac{d^2 r}{dt^2} = F(r)$ 进行积分。每次测试使用固定的时间步长 $\\Delta t$ 和固定的步数 $N$。为确保数值安全性，如果在对不正确模型进行积分的过程中，位置的绝对值超过了发散阈值 $R_{\\max}$，则提前终止该模型的积分，并将最终位置视为在阈值处的截断值（也就是说，如果 $r$ 的绝对值将要超过 $R_{\\max}$，则将 $r$ 设置为带有相应符号的 $\\pm R_{\\max}$，并停止该轨迹的积分）。\n\n对于每个测试用例，您的程序必须计算标量\n$$D = r_{\\text{sq}}(T) - r_{\\text{harm}}(T),$$\n其中 $r_{\\text{sq}}(T)$ 和 $r_{\\text{harm}}(T)$ 分别是在最终时间 $t = T = N \\Delta t$ 时，不正确模型和正确模型的最终位置。\n\n使用以下测试套件（全部采用简化无量纲单位）：\n- 测试 A（正常路径，静止于偏离位置）：$m = 1$, $k = 1$, $r_0 = 0$, $r(0) = 0.5$, $v(0) = 0$, $\\Delta t = 10^{-3}$, $N = 6283$（因此 $T \\approx 2\\pi$），$R_{\\max} = 10^6$。\n- 测试 B（边界平衡）：$m = 1$, $k = 1$, $r_0 = 0$, $r(0) = 0$, $v(0) = 0$, $\\Delta t = 10^{-3}$, $N = 6283$, $R_{\\max} = 10^6$。\n- 测试 C（以初速度通过平衡点）：$m = 1$, $k = 1$, $r_0 = 0$, $r(0) = 0$, $v(0) = 1$, $\\Delta t = 10^{-3}$, $N = 6283$, $R_{\\max} = 10^6$。\n\n科学真实性：在分子模拟中，无量纲化（简化单位）被广泛用于分析动力学，而无需拘泥于特定的单位尺度。上述选择对应一个代表性问题，其中 $r_0$ 是平衡键长，$k$ 以简化形式编码了刚度。\n\n角度单位不适用。由于所有量在构造上都是无量纲的，因此不需要进行物理单位转换。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，顺序为 $[D_A, D_B, D_C]$，其中每个 $D$ 是一个四舍五入到恰好六位小数的浮点数（例如，$[1.234567,0.000000,-2.500000]$）。", "solution": "提交审议的问题陈述已经过严格验证。\n\n**第一步：提取已知条件**\n- 运动方程：$m \\frac{d^2 r}{dt^2} = F(r)$\n- 简化单位：$m = 1$, $k = 1$, $r_0 = 0$\n- 谐波力模型：$F_{\\text{harm}}(r) = -k (r - r_0)$\n- 平方力模型：$F_{\\text{sq}}(r) = -k (r - r_0)^2$\n- 数值积分：使用时间步长 $\\Delta t$ 和 $N$ 步的时间可逆辛积分器（例如，速度-Verlet）。\n- 平方模型的发散处理：如果 $|r|  R_{\\max}$，积分停止，且 $r$ 被截断为 $\\pm R_{\\max}$。\n- 输出量：在最终时间 $T = N \\Delta t$ 时的 $D = r_{\\text{sq}}(T) - r_{\\text{harm}}(T)$。\n- 测试用例：\n  - 测试 A：$r(0) = 0.5$, $v(0) = 0$, $\\Delta t = 10^{-3}$, $N = 6283$, $R_{\\max} = 10^6$。\n  - 测试 B：$r(0) = 0$, $v(0) = 0$, $\\Delta t = 10^{-3}$, $N = 6283$, $R_{\\max} = 10^6$。\n  - 测试 C：$r(0) = 0$, $v(0) = 1$, $\\Delta t = 10^{-3}$, $N = 6283$, $R_{\\max} = 10^6$。\n\n**第二步：使用提取的已知条件进行验证**\n该问题具有科学依据，提法明确且客观。它提出了一个计算物理学中的标准练习，比较了一个正则系统（谐振子）与一个非标准的、用于说明的对应系统的动力学。所有参数、初始条件和程序要求都已完整且无矛盾地指定。该问题没有违反任何力学或数学的基本原理；相反，它以这些原理为基础进行比较性数值研究。\n\n**第三步：结论与行动**\n该问题被判定为**有效**。将提供一个解决方案。\n\n解决方案首先将运动方程形式化，并分析它们所蕴含的性质行为。随后，详细说明指定的数值积分算法，即速度-Verlet方法。最后，将此算法应用于提供的测试用例，以计算所需的量 $D$。\n\n在指定的简化单位中，$m=1$，$k=1$，$r_0=0$，两个运动方程为：\n1.  **谐波模型：**\n    $$\n    \\frac{d^2 r}{dt^2} = F_{\\text{harm}}(r) = -r\n    $$\n    这是简谐运动的定义方程。力总是指向平衡位置 $r=0$，其大小与位移成正比。势能为 $V_{\\text{harm}}(r) = \\frac{1}{2}r^2$，是一个对称的抛物线。对于任何总能量 $E  0$，运动都是有界的，并且是周期性的，角频率为 $\\omega = \\sqrt{k/m} = 1$。轨迹是正弦形的。\n\n2.  **平方模型：**\n    $$\n    \\frac{d^2 r}{dt^2} = F_{\\text{sq}}(r) = -r^2\n    $$\n    这个模型呈现出一幅截然不同的物理图像。无论 $r$ 的符号如何，力总是非正的，$F_{\\text{sq}}(r) \\le 0$。\n    - 对于 $r  0$，力是负的（恢复力），将粒子拉向 $r=0$。\n    - 对于 $r  0$，力*也是*负的（反向恢复力），将粒子进一步推向 $r = -\\infty$。\n    势能为 $V_{\\text{sq}}(r) = \\int_0^r -F_{\\text{sq}}(x) dx = \\int_0^r x^2 dx = \\frac{1}{3}r^3$。这个势在 $r=0$ 处有一个局部最小值，但当 $r \\to -\\infty$ 时，它是无下界的。因此，任何以非零能量进入 $r  0$ 区域的粒子都将无限制地加速向负无穷大。这不是一个稳定振荡运动的模型。\n\n为了对这些二阶常微分方程进行积分，速度-Verlet算法是一个合适的选择，因为它具有时间可逆性和辛性质，这使其对于哈密顿系统具有出色的长期能量守恒特性。对于给定的位置 $r(t)$、速度 $v(t)$ 和加速度 $a(t) = F(r(t))/m$，该算法计算 $t+\\Delta t$ 时刻状态的一步如下：\n1.  更新位置：\n    $$\n    r(t+\\Delta t) = r(t) + v(t)\\Delta t + \\frac{1}{2}a(t)\\Delta t^2\n    $$\n2.  计算新位置处的加速度：\n    $$\n    a(t+\\Delta t) = \\frac{F(r(t+\\Delta t))}{m}\n    $$\n3.  使用旧加速度和新加速度的平均值更新速度：\n    $$\n    v(t+\\Delta t) = v(t) + \\frac{1}{2}[a(t) + a(t+\\Delta t)]\\Delta t\n    $$\n从初始条件 $r(0)$ 和 $v(0)$ 开始，将此操作序列迭代 $N$ 次，以获得直到最终时间 $T=N\\Delta t$ 的轨迹。对于平方模型，在每次位置更新后都会进行检查。如果 $|r_{\\text{sq}}|$ 超过 $R_{\\max}$，则位置被截断，并且该轨迹的积分将停止。\n\n将此应用于测试用例：\n- **测试 A: $r(0) = 0.5, v(0) = 0$。**\n  - $r_{\\text{harm}}(t) = 0.5 \\cos(t)$。在 $T = 6.283 \\approx 2\\pi$ 时，$r_{\\text{harm}}(T)$ 将非常接近 $r(0) = 0.5$。\n  - 对于平方模型，粒子从 $r>0$ 开始，被拉向 $r=0$，越过该点进入 $r0$ 区域，然后无界加速。它将达到发散阈值，因此 $r_{\\text{sq}}(T) = -R_{\\max} = -10^6$。\n  - $D_A = r_{\\text{sq}}(T) - r_{\\text{harm}}(T)$ 将大约为 $-10^6 - 0.5$。\n\n- **测试 B: $r(0) = 0, v(0) = 0$。**\n  - 对于两种模型，初始力和速度均为零。粒子处于稳定（对谐波模型）或亚稳态（对平方模型）平衡位置。它将不会移动。\n  - $r_{\\text{harm}}(T)=0$ 且 $r_{\\text{sq}}(T)=0$。\n  - $D_B = 0 - 0 = 0$。\n\n- **测试 C: $r(0) = 0, v(0) = 1$。**\n  - $r_{\\text{harm}}(t) = \\sin(t)$。在 $T = 6.283 \\approx 2\\pi$ 时，$r_{\\text{harm}}(T)$ 将非常接近 $\\sin(2\\pi) = 0$。\n  - 对于平方模型，初速度将粒子带入 $r>0$ 区域。力 $-r^2$ 使其减速，掉头，然后它再次通过 $r=0$ 进入 $r0$ 区域，并在那里发散。它将达到阈值，因此 $r_{\\text{sq}}(T) = -R_{\\max} = -10^6$。\n  - $D_C = r_{\\text{sq}}(T) - r_{\\text{harm}}(T)$ 将大约为 $-10^6 - 0$。\n\n以下程序实现了此逻辑，以提供精确的数值结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of comparing harmonic vs. squared force models\n    using a velocity-Verlet integrator.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test A (happy path, displaced at rest)\n        {'m': 1.0, 'k': 1.0, 'r0_val': 0.0, 'r_init': 0.5, 'v_init': 0.0, \n         'dt': 1e-3, 'N': 6283, 'R_max': 1e6},\n        # Test B (boundary equilibrium)\n        {'m': 1.0, 'k': 1.0, 'r0_val': 0.0, 'r_init': 0.0, 'v_init': 0.0, \n         'dt': 1e-3, 'N': 6283, 'R_max': 1e6},\n        # Test C (initial velocity through equilibrium)\n        {'m': 1.0, 'k': 1.0, 'r0_val': 0.0, 'r_init': 0.0, 'v_init': 1.0, \n         'dt': 1e-3, 'N': 6283, 'R_max': 1e6}\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        m, k, r0_val = case['m'], case['k'], case['r0_val']\n        r_init, v_init = case['r_init'], case['v_init']\n        dt, N, R_max = case['dt'], case['N'], case['R_max']\n        \n        # Force functions for the two models\n        def force_harm(r):\n            return -k * (r - r0_val)\n        \n        def force_sq(r):\n            return -k * (r - r0_val)**2\n\n        # Initialize positions, velocities, and accelerations for both models\n        r_harm, v_harm = r_init, v_init\n        a_harm = force_harm(r_harm) / m\n        \n        r_sq, v_sq = r_init, v_init\n        a_sq = force_sq(r_sq) / m\n        \n        # Flag to indicate if the squared model has diverged and integration stopped\n        sq_diverged = False\n\n        # Main integration loop\n        for _ in range(N):\n            # --- Velocity-Verlet step for Harmonic model ---\n            # 1. Update position\n            r_harm = r_harm + v_harm * dt + 0.5 * a_harm * dt**2\n            # 2. Calculate new acceleration\n            a_harm_new = force_harm(r_harm) / m\n            # 3. Update velocity\n            v_harm = v_harm + 0.5 * (a_harm + a_harm_new) * dt\n            # 4. Store new acceleration for the next step\n            a_harm = a_harm_new\n\n            # --- Velocity-Verlet step for Squared model ---\n            if not sq_diverged:\n                # 1. Update position\n                r_sq_new = r_sq + v_sq * dt + 0.5 * a_sq * dt**2\n                \n                # Check for divergence\n                if abs(r_sq_new) > R_max:\n                    r_sq = R_max * np.sign(r_sq_new)\n                    sq_diverged = True\n                    # Do not update velocity or acceleration further\n                else:\n                    r_sq = r_sq_new\n                    # 2. Calculate new acceleration\n                    a_sq_new = force_sq(r_sq) / m\n                    # 3. Update velocity\n                    v_sq = v_sq + 0.5 * (a_sq + a_sq_new) * dt\n                    # 4. Store new acceleration for the next step\n                    a_sq = a_sq_new\n        \n        # Calculate the final difference D\n        D = r_sq - r_harm\n        results.append(D)\n\n    # Format the final output as a string with exactly 6 decimal places per value\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2459291"}, {"introduction": "真实的分子不仅仅是用弹簧连接的原子对，它们的几何构型还受到涉及三个原子的键角所控制。这最后一个练习将处理这种复杂性，你将需要推导并实现由键角势产生的力，这是任何实际分子力场的关键组成部分。通过这个练习，你将更深刻地理解我们如何用数学来描述和模拟分子的复杂三维结构。[@problem_id:2459282]", "problem": "考虑三个点粒子，标记为 $i$、$j$ 和 $k$，它们在三维空间中的位置分别为 $\\mathbf{r}_i$、$\\mathbf{r}_j$ 和 $\\mathbf{r}_k$。在约化单位制（质量 $m = 1$、能量 $= 1$、长度 $= 1$、时间 $= 1$）下，它们通过一个纯粹的三体角势相互作用，该势能取决于由向量 $\\mathbf{a} = \\mathbf{r}_i - \\mathbf{r}_j$ 和 $\\mathbf{b} = \\mathbf{r}_k - \\mathbf{r}_j$ 在粒子 $j$ 处形成的夹角。对于一个三元组 $(i,j,k)$，其势能为\n$$\nV_{ijk} = k \\left(\\theta_{ijk} - \\theta_0\\right)^2,\n$$\n其中 $\\theta_{ijk}$ 是在 $j$ 处向量 $\\mathbf{a}$ 和 $\\mathbf{b}$ 之间的夹角，力常数 $k$ 是一个正标量，参考角为 $\\theta_0 = \\pi/2$。所有角度必须以弧度表示。除此之外，该系统没有其他相互作用。动力学遵循牛顿第二定律，即对于每个粒子 $\\alpha \\in \\{i,j,k\\}$，有 $m \\, d^2 \\mathbf{r}_\\alpha/dt^2 = \\mathbf{F}_\\alpha$，其中 $\\mathbf{F}_\\alpha = -\\nabla_{\\mathbf{r}_\\alpha} V_{ijk}$。\n\n任务 A。仅从以下基本原理出发：\n- 牛顿第二定律，$m \\, d^2 \\mathbf{r}/dt^2 = \\mathbf{F}$，\n- 速度 $d\\mathbf{r}/dt$ 和加速度 $d^2\\mathbf{r}/dt^2$ 的定义，\n- 两个非零向量 $\\mathbf{a}$ 和 $\\mathbf{b}$ 之间夹角 $\\theta$ 的定义，通过 $\\cos \\theta = \\dfrac{\\mathbf{a} \\cdot \\mathbf{b}}{\\lVert \\mathbf{a} \\rVert \\lVert \\mathbf{b} \\rVert}$ 和 $\\theta = \\arccos(\\cos \\theta)$，\n推导出由 $V_{ijk}$ 产生的力 $\\mathbf{F}_i$、$\\mathbf{F}_j$ 和 $\\mathbf{F}_k$ 的显式解析表达式，用 $\\mathbf{a}$、$\\mathbf{b}$ 及其范数表示。您的推导必须从链式法则和向量微积分恒等式出发，不得假定任何预先制定的力公式。\n\n任务 B。实现一个程序，对于单个三元组 $(i,j,k)$，计算其势能 $V_{ijk}$ 以及由您在任务 A 中得到的结果所蕴含的力向量 $\\mathbf{F}_i$、$\\mathbf{F}_j$ 和 $\\mathbf{F}_k$。在数值上，请遵循以下算法指导以确保稳定性：\n- 将 $\\theta$ 计算为 $\\theta = \\operatorname{atan2}\\!\\left(\\lVert \\mathbf{a} \\times \\mathbf{b} \\rVert, \\mathbf{a} \\cdot \\mathbf{b}\\right)$，单位为弧度。\n- 通过将分母中任何出现的 $\\lVert \\mathbf{a} \\rVert$、$\\lVert \\mathbf{b} \\rVert$ 或 $\\sin \\theta$ 的值若小于 $\\varepsilon$ 则替换为 $\\varepsilon$（其中 $\\varepsilon = 10^{-12}$）来保护所有分母，以避免在近共线极限情况下出现除以零的错误。\n\n任务 C。使用以下测试套件验证您的实现。在每种情况下，使用给定的位置和参数值，并计算三个浮点数：\n- 势能 $V_{ijk}$，\n- 总力的欧几里得范数 $\\lVert \\mathbf{F}_i + \\mathbf{F}_j + \\mathbf{F}_k \\rVert$，\n- 角度 $\\theta$，单位为弧度。\n报告这三个浮点数，四舍五入到 $10$ 位小数。\n\n使用以下测试套件（所有坐标均为约化单位，角度为弧度）：\n- 案例 $1$（理想情况，直角）：$\\mathbf{r}_i = (\\,\\,$$1$$,\\, $$0$$,\\, $$0$$\\,)$, $\\mathbf{r}_j = (\\,\\,$$0$$,\\, $$0$$,\\, $$0$$\\,)$, $\\mathbf{r}_k = (\\,\\,$$0$$,\\, $$1$$,\\, $$0$$\\,)$, $k = $$10$$$。\n- 案例 $2$（锐角）：$\\mathbf{r}_i = (\\,\\,$$1$$,\\, $$0$$,\\, $$0$$\\,)$, $\\mathbf{r}_j = (\\,\\,$$0$$,\\, $$0$$,\\, $$0$$\\,)$, $\\mathbf{r}_k = (\\,\\,$$1$$,\\, $$1$$,\\, $$0$$\\,)$, $k = $$10$$$。\n- 案例 $3$（钝角）：$\\mathbf{r}_i = (\\,\\,$$1$$,\\, $$0$$,\\, $$0$$\\,)$, $\\mathbf{r}_j = (\\,\\,$$0$$,\\, $$0$$,\\, $$0$$\\,)$, $\\mathbf{r}_k = (\\,\\,$$-1$$,\\, $$1$$,\\, $$0$$\\,)$, $k = $$10$$$。\n- 案例 $4$（近共线边缘情况）：$\\mathbf{r}_i = (\\,\\,$$1$$,\\, $$0$$,\\, $$0$$\\,)$, $\\mathbf{r}_j = (\\,\\,$$0$$,\\, $$0$$,\\, $$0$$\\,)$, $\\mathbf{r}_k = (\\,\\,$$10$$,\\, $$0.01$$,\\, $$0$$\\,)$, $k = $$10$$$。\n\n最终输出格式：您的程序应生成单行输出，其中包含结果，格式为逗号分隔的列表的列表，每个内部列表对应一种情况，并按上述顺序包含三个浮点数，四舍五入到 $10$ 位小数，例如 $[\\,[v_1, f_1, \\theta_1],[v_2, f_2, \\theta_2],\\ldots\\,]$。所有角度必须是弧度。能量以约化（无量纲）单位报告。角度单位是弧度。每个浮点数必须精确到 10 位小数。", "solution": "此问题经评估有效。这是一个在经典力学和向量微积分领域中定义明确、有科学依据的练习，在计算化学领域很常见。我们开始进行推导和后续的实现。\n\n任务是推导三个粒子 $i$、$j$ 和 $k$ 在三体势 $V_{ijk} = k(\\theta_{ijk} - \\theta_0)^2$ 相互作用下所受的力。粒子 $\\alpha$ 上所受的力由势能对其位置坐标 $\\mathbf{r}_\\alpha$ 的负梯度给出：\n$$\n\\mathbf{F}_\\alpha = -\\nabla_{\\mathbf{r}_\\alpha} V_{ijk}\n$$\n势能 $V_{ijk}$ 是角度 $\\theta_{ijk}$ 的函数，而角度又取决于粒子的位置。我们应用链式法则：\n$$\n\\mathbf{F}_\\alpha = - \\frac{dV_{ijk}}{d\\theta_{ijk}} \\nabla_{\\mathbf{r}_\\alpha} \\theta_{ijk}\n$$\n首先，我们计算势能相对于角度 $\\theta \\equiv \\theta_{ijk}$ 的导数：\n$$\n\\frac{dV}{d\\theta} = \\frac{d}{d\\theta} \\left[ k(\\theta - \\theta_0)^2 \\right] = 2k(\\theta - \\theta_0)\n$$\n接下来，我们推导角度 $\\theta$ 相对于粒子位置的梯度。角度 $\\theta$ 由向量 $\\mathbf{a} = \\mathbf{r}_i - \\mathbf{r}_j$ 和 $\\mathbf{b} = \\mathbf{r}_k - \\mathbf{r}_j$ 通过点积定义：\n$$\n\\cos\\theta = \\frac{\\mathbf{a} \\cdot \\mathbf{b}}{\\lVert \\mathbf{a} \\rVert \\lVert \\mathbf{b} \\rVert} = \\frac{\\mathbf{a} \\cdot \\mathbf{b}}{ab}\n$$\n其中 $a = \\lVert \\mathbf{a} \\rVert$，$b = \\lVert \\mathbf{b} \\rVert$。使用单位向量 $\\hat{\\mathbf{a}} = \\mathbf{a}/a$ 和 $\\hat{\\mathbf{b}} = \\mathbf{b}/b$ 会更方便，这样 $\\cos\\theta = \\hat{\\mathbf{a}} \\cdot \\hat{\\mathbf{b}}$。\n\n为了求得 $\\nabla_{\\mathbf{r}_\\alpha} \\theta$，我们首先求 $\\nabla_{\\mathbf{r}_\\alpha} \\cos\\theta$ 并使用关系式 $\\frac{d(\\arccos u)}{du} = -1/\\sqrt{1-u^2}$。\n$$\n\\nabla_{\\mathbf{r}_\\alpha} \\theta = \\nabla_{\\mathbf{r}_\\alpha} \\arccos(\\cos\\theta) = \\frac{d(\\arccos(\\cos\\theta))}{d(\\cos\\theta)} \\nabla_{\\mathbf{r}_\\alpha} \\cos\\theta = -\\frac{1}{\\sin\\theta} \\nabla_{\\mathbf{r}_\\alpha} \\cos\\theta\n$$\n此式在 $\\theta \\in (0, \\pi)$ 且 $\\sin\\theta \\neq 0$ 时成立。原子共线的情况将进行数值处理。\n\n向量 $\\mathbf{a}$ 和 $\\mathbf{b}$ 相对于粒子位置的梯度为：\n$$\n\\nabla_{\\mathbf{r}_i} \\mathbf{a} = \\mathbf{I}, \\quad \\nabla_{\\mathbf{r}_j} \\mathbf{a} = -\\mathbf{I}, \\quad \\nabla_{\\mathbf{r}_k} \\mathbf{a} = \\mathbf{0}\n$$\n$$\n\\nabla_{\\mathbf{r}_i} \\mathbf{b} = \\mathbf{0}, \\quad \\nabla_{\\mathbf{r}_j} \\mathbf{b} = -\\mathbf{I}, \\quad \\nabla_{\\mathbf{r}_k} \\mathbf{b} = \\mathbf{I}\n$$\n其中 $\\mathbf{I}$ 是 2 阶单位张量。\n\n单位向量 $\\hat{\\mathbf{u}} = \\mathbf{u}/u$（$u = \\lVert \\mathbf{u} \\rVert$）相对于向量 $\\mathbf{x}$ 的梯度为：\n$$\n\\nabla_{\\mathbf{x}} \\hat{\\mathbf{u}} = \\frac{1}{u}\\nabla_{\\mathbf{x}}\\mathbf{u} - \\frac{\\mathbf{u}}{u^2} (\\nabla_{\\mathbf{x}} u)^T = \\frac{1}{u}(\\mathbf{I} - \\hat{\\mathbf{u}}\\hat{\\mathbf{u}}^T)\\nabla_{\\mathbf{x}}\\mathbf{u}\n$$\n\n现在我们计算每个粒子所受的力。\n\n**粒子 $i$ 所受的力 ($\\mathbf{F}_i$)：**\n我们需要 $\\nabla_{\\mathbf{r}_i} \\cos\\theta = \\nabla_{\\mathbf{r}_i} (\\hat{\\mathbf{a}} \\cdot \\hat{\\mathbf{b}}) = (\\nabla_{\\mathbf{r}_i} \\hat{\\mathbf{a}}) \\cdot \\hat{\\mathbf{b}} + (\\nabla_{\\mathbf{r}_i} \\hat{\\mathbf{b}}) \\cdot \\hat{\\mathbf{a}}$。\n由于 $\\mathbf{b}$ 不依赖于 $\\mathbf{r}_i$，因此 $\\nabla_{\\mathbf{r}_i} \\hat{\\mathbf{b}} = \\mathbf{0}$。\n$$\n\\nabla_{\\mathbf{r}_i} \\hat{\\mathbf{a}} = \\frac{1}{a}(\\mathbf{I} - \\hat{\\mathbf{a}}\\hat{\\mathbf{a}}^T)(\\nabla_{\\mathbf{r}_i}\\mathbf{a}) = \\frac{1}{a}(\\mathbf{I} - \\hat{\\mathbf{a}}\\hat{\\mathbf{a}}^T)\n$$\n因此，\n$$\n\\nabla_{\\mathbf{r}_i} \\cos\\theta = \\frac{1}{a}(\\mathbf{I} - \\hat{\\mathbf{a}}\\hat{\\mathbf{a}}^T)\\hat{\\mathbf{b}} = \\frac{1}{a}(\\hat{\\mathbf{b}} - \\hat{\\mathbf{a}}(\\hat{\\mathbf{a}}\\cdot\\hat{\\mathbf{b}})) = \\frac{\\hat{\\mathbf{b}} - \\cos\\theta\\,\\hat{\\mathbf{a}}}{a}\n$$\n角度的梯度是：\n$$\n\\nabla_{\\mathbf{r}_i} \\theta = -\\frac{1}{\\sin\\theta} \\left( \\frac{\\hat{\\mathbf{b}} - \\cos\\theta\\,\\hat{\\mathbf{a}}}{a} \\right) = \\frac{\\cos\\theta\\,\\hat{\\mathbf{a}} - \\hat{\\mathbf{b}}}{a\\sin\\theta}\n$$\n力则是：\n$$\n\\mathbf{F}_i = -\\frac{dV}{d\\theta} \\nabla_{\\mathbf{r}_i} \\theta = -2k(\\theta - \\theta_0) \\left(\\frac{\\cos\\theta\\,\\hat{\\mathbf{a}} - \\hat{\\mathbf{b}}}{a\\sin\\theta}\\right) = \\frac{2k(\\theta - \\theta_0)}{a\\sin\\theta}(\\hat{\\mathbf{b}} - \\cos\\theta\\,\\hat{\\mathbf{a}})\n$$\n\n**粒子 $k$ 所受的力 ($\\mathbf{F}_k$)：**\n通过交换粒子 $i \\leftrightarrow k$ 和向量 $\\mathbf{a} \\leftrightarrow \\mathbf{b}$，其推导过程与 $\\mathbf{F}_i$ 的推导对称。\n$$\n\\nabla_{\\mathbf{r}_k} \\cos\\theta = \\frac{\\hat{\\mathbf{a}} - \\cos\\theta\\,\\hat{\\mathbf{b}}}{b}\n$$\n$$\n\\nabla_{\\mathbf{r}_k} \\theta = \\frac{\\cos\\theta\\,\\hat{\\mathbf{b}} - \\hat{\\mathbf{a}}}{b\\sin\\theta}\n$$\n$$\n\\mathbf{F}_k = -\\frac{dV}{d\\theta} \\nabla_{\\mathbf{r}_k} \\theta = -2k(\\theta - \\theta_0) \\left(\\frac{\\cos\\theta\\,\\hat{\\mathbf{b}} - \\hat{\\mathbf{a}}}{b\\sin\\theta}\\right) = \\frac{2k(\\theta-\\theta_0)}{b\\sin\\theta}(\\hat{\\mathbf{a}} - \\cos\\theta\\,\\hat{\\mathbf{b}})\n$$\n\n**粒子 $j$ 所受的力 ($\\mathbf{F}_j$)：**\n位置 $\\mathbf{r}_j$ 同时影响 $\\mathbf{a}$ 和 $\\mathbf{b}$。\n$$\n\\begin{aligned}\n\\nabla_{\\mathbf{r}_j} \\cos\\theta = (\\nabla_{\\mathbf{r}_j}\\hat{\\mathbf{a}})\\cdot\\hat{\\mathbf{b}} + (\\nabla_{\\mathbf{r}_j}\\hat{\\mathbf{b}})\\cdot\\hat{\\mathbf{a}} \\\\\n\\nabla_{\\mathbf{r}_j}\\hat{\\mathbf{a}} = \\frac{1}{a}(\\mathbf{I}-\\hat{\\mathbf{a}}\\hat{\\mathbf{a}}^T)(\\nabla_{\\mathbf{r}_j}\\mathbf{a}) = -\\frac{1}{a}(\\mathbf{I}-\\hat{\\mathbf{a}}\\hat{\\mathbf{a}}^T) \\\\\n\\nabla_{\\mathbf{r}_j}\\hat{\\mathbf{b}} = \\frac{1}{b}(\\mathbf{I}-\\hat{\\mathbf{b}}\\hat{\\mathbf{b}}^T)(\\nabla_{\\mathbf{r}_j}\\mathbf{b}) = -\\frac{1}{b}(\\mathbf{I}-\\hat{\\mathbf{b}}\\hat{\\mathbf{b}}^T)\n\\end{aligned}\n$$\n将这些代入 $\\cos\\theta$ 的梯度中：\n$$\n\\begin{aligned}\n\\nabla_{\\mathbf{r}_j} \\cos\\theta = -\\frac{1}{a}(\\mathbf{I}-\\hat{\\mathbf{a}}\\hat{\\mathbf{a}}^T)\\hat{\\mathbf{b}} - \\frac{1}{b}(\\mathbf{I}-\\hat{\\mathbf{b}}\\hat{\\mathbf{b}}^T)\\hat{\\mathbf{a}} \\\\\n= -\\frac{1}{a}(\\hat{\\mathbf{b}} - \\cos\\theta\\,\\hat{\\mathbf{a}}) - \\frac{1}{b}(\\hat{\\mathbf{a}} - \\cos\\theta\\,\\hat{\\mathbf{b}}) \\\\\n= -(\\nabla_{\\mathbf{r}_i}\\cos\\theta + \\nabla_{\\mathbf{r}_k}\\cos\\theta)\n\\end{aligned}\n$$\n这意味着 $\\nabla_{\\mathbf{r}_j} \\theta = -(\\nabla_{\\mathbf{r}_i} \\theta + \\nabla_{\\mathbf{r}_k} \\theta)$。\n势能 $V_{ijk}$ 在整个系统进行统一平移（对于所有 $\\alpha$，$\\mathbf{r}_\\alpha \\to \\mathbf{r}_\\alpha + \\mathbf{c}$）时保持不变，因此力的总和必须为零。\n$$\n\\mathbf{F}_i + \\mathbf{F}_j + \\mathbf{F}_k = -\\nabla_{\\mathbf{r}_i}V - \\nabla_{\\mathbf{r}_j}V - \\nabla_{\\mathbf{r}_k}V = \\mathbf{0}\n$$\n由此，我们推断出 $\\mathbf{F}_j = -(\\mathbf{F}_i + \\mathbf{F}_k)$。这与我们的梯度计算结果一致，因为：\n$$\n\\mathbf{F}_j = -\\frac{dV}{d\\theta} \\nabla_{\\mathbf{r}_j}\\theta = -\\frac{dV}{d\\theta} [-(\\nabla_{\\mathbf{r}_i}\\theta + \\nabla_{\\mathbf{r}_k}\\theta)] = -(\\mathbf{F}_i + \\mathbf{F}_k)\n$$\n\n**用于实现的最终表达式：**\n令 $C = 2k(\\theta - \\theta_0)$。\n$$\n\\mathbf{F}_i = \\frac{C}{a\\sin\\theta}(\\hat{\\mathbf{b}} - \\cos\\theta\\,\\hat{\\mathbf{a}})\n$$\n$$\n\\mathbf{F}_k = \\frac{C}{b\\sin\\theta}(\\hat{\\mathbf{a}} - \\cos\\theta\\,\\hat{\\mathbf{b}})\n$$\n$$\n\\mathbf{F}_j = -(\\mathbf{F}_i + \\mathbf{F}_k)\n$$\n这些表达式将被实现。为了数值稳定性，根据问题陈述，分母 $a$、$b$ 和 $\\sin\\theta$ 将被保护，防止其值小于一个小的正常数 $\\varepsilon = 10^{-12}$。角度 $\\theta$ 使用 $\\theta = \\operatorname{atan2}(\\lVert \\mathbf{a} \\times \\mathbf{b} \\rVert, \\mathbf{a} \\cdot \\mathbf{b})$ 进行稳健计算。\n\n该实现将计算势能 $V_{ijk}$、角度 $\\theta$ 和总力的欧几里得范数 $\\lVert \\mathbf{F}_i + \\mathbf{F}_j + \\mathbf{F}_k \\rVert$。由于使用了有限精度算法，这个范数预计会是一个接近零的非常小的数，而不是精确的零。", "answer": "```python\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Computes potential energy, total force norm, and angle for a three-body system.\n    \"\"\"\n    test_cases = [\n        {'r_i': np.array([1.0, 0.0, 0.0]), 'r_j': np.array([0.0, 0.0, 0.0]), 'r_k': np.array([0.0, 1.0, 0.0]), 'k': 10.0},\n        {'r_i': np.array([1.0, 0.0, 0.0]), 'r_j': np.array([0.0, 0.0, 0.0]), 'r_k': np.array([1.0, 1.0, 0.0]), 'k': 10.0},\n        {'r_i': np.array([1.0, 0.0, 0.0]), 'r_j': np.array([0.0, 0.0, 0.0]), 'r_k': np.array([-1.0, 1.0, 0.0]), 'k': 10.0},\n        {'r_i': np.array([1.0, 0.0, 0.0]), 'r_j': np.array([0.0, 0.0, 0.0]), 'r_k': np.array([10.0, 0.01, 0.0]), 'k': 10.0}\n    ]\n\n    all_results = []\n    \n    # Constants\n    theta_0 = math.pi / 2.0\n    epsilon = 1.e-12\n\n    for case in test_cases:\n        r_i = case['r_i']\n        r_j = case['r_j']\n        r_k = case['r_k']\n        k = case['k']\n\n        # 1. Define vectors\n        a_vec = r_i - r_j\n        b_vec = r_k - r_j\n\n        # 2. Compute norms and guarded norms\n        a_norm = np.linalg.norm(a_vec)\n        b_norm = np.linalg.norm(b_vec)\n        a_norm_g = max(a_norm, epsilon)\n        b_norm_g = max(b_norm, epsilon)\n\n        # 3. Compute angle theta\n        dot_product = np.dot(a_vec, b_vec)\n        cross_product_norm = np.linalg.norm(np.cross(a_vec, b_vec))\n        theta = np.arctan2(cross_product_norm, dot_product)\n\n        # 4. Compute potential energy\n        V = k * (theta - theta_0)**2\n\n        # 5. Compute forces\n        cos_theta = dot_product / (a_norm_g * b_norm_g)\n        sin_theta = math.sin(theta)\n        sin_theta_g = max(sin_theta, epsilon)\n\n        # Prefactor for forces\n        C = 2.0 * k * (theta - theta_0)\n\n        # Unit vectors\n        a_hat = a_vec / a_norm_g\n        b_hat = b_vec / b_norm_g\n        \n        # Calculate forces using the derived expressions\n        F_i = (C / (a_norm_g * sin_theta_g)) * (b_hat - cos_theta * a_hat)\n        F_k = (C / (b_norm_g * sin_theta_g)) * (a_hat - cos_theta * b_hat)\n        F_j = -(F_i + F_k)\n\n        # 6. Compute total force and its norm\n        F_total = F_i + F_j + F_k\n        F_total_norm = np.linalg.norm(F_total)\n        \n        # 7. Format results\n        results_per_case = [\n            f\"{V:.10f}\",\n            f\"{F_total_norm:.10f}\",\n            f\"{theta:.10f}\"\n        ]\n        \n        formatted_sublist = f\"[{','.join(results_per_case)}]\"\n        all_results.append(formatted_sublist)\n\n    # Final print statement requires a slight reformatting to match the problem's example output style\n    # The example is [[v1, f1, t1], [v2, f2, t2], ...]\n    # My previous implementation was creating strings of the inner lists.\n    # Let's fix that. The problem asks for float numbers, not strings.\n    # The example output format string in problem 2 was like `[1.234567,0.000000,-2.500000]`.\n    # Let me re-read problem 3's format instruction: `[[v_1, f_1, \\theta_1],[v_2, f_2, \\theta_2],\\ldots\\,]`\n    # And \"每个浮点数必须精确到 10 位小数。\"\n    # The code produces a list of strings: `['[0.000...]', '[2.356...]', ...]`\n    # This is not `[[...], [...]]`.\n    # I should re-write the last part of the script.\n\n    # Let's re-do the result collection\n    all_results_as_lists = []\n    for case in test_cases:\n        r_i = case['r_i']\n        r_j = case['r_j']\n        r_k = case['r_k']\n        k = case['k']\n        a_vec = r_i - r_j\n        b_vec = r_k - r_j\n        a_norm = np.linalg.norm(a_vec)\n        b_norm = np.linalg.norm(b_vec)\n        a_norm_g = max(a_norm, epsilon)\n        b_norm_g = max(b_norm, epsilon)\n        dot_product = np.dot(a_vec, b_vec)\n        cross_product_norm = np.linalg.norm(np.cross(a_vec, b_vec))\n        theta = np.arctan2(cross_product_norm, dot_product)\n        V = k * (theta - theta_0)**2\n        cos_theta = dot_product / (a_norm_g * b_norm_g)\n        sin_theta = math.sin(theta)\n        sin_theta_g = max(sin_theta, epsilon)\n        C = 2.0 * k * (theta - theta_0)\n        a_hat = a_vec / a_norm_g\n        b_hat = b_vec / b_norm_g\n        F_i = (C / (a_norm_g * sin_theta_g)) * (b_hat - cos_theta * a_hat)\n        F_k = (C / (b_norm_g * sin_theta_g)) * (a_hat - cos_theta * b_hat)\n        F_j = -(F_i + F_k)\n        F_total = F_i + F_j + F_k\n        F_total_norm = np.linalg.norm(F_total)\n        \n        all_results_as_lists.append([V, F_total_norm, theta])\n    \n    # Custom print to match the format [[...],[...]] with 10 decimal places.\n    output_str = \"[\"\n    for i, res_list in enumerate(all_results_as_lists):\n        v_str = f\"{res_list[0]:.10f}\"\n        f_str = f\"{res_list[1]:.10f}\"\n        t_str = f\"{res_list[2]:.10f}\"\n        output_str += f\"[{v_str},{f_str},{t_str}]\"\n        if i  len(all_results_as_lists) - 1:\n            output_str += \",\"\n    output_str += \"]\"\n    print(output_str)\n\n# I'll just put the full, corrected code back into the answer. \n# The issue was that the original python solution had an incorrect logic for formatting the final string output. \n# I will rewrite the loop to be more direct and correct the final print formatting.\ndef solve_corrected():\n    test_cases = [\n        {'r_i': np.array([1.0, 0.0, 0.0]), 'r_j': np.array([0.0, 0.0, 0.0]), 'r_k': np.array([0.0, 1.0, 0.0]), 'k': 10.0},\n        {'r_i': np.array([1.0, 0.0, 0.0]), 'r_j': np.array([0.0, 0.0, 0.0]), 'r_k': np.array([1.0, 1.0, 0.0]), 'k': 10.0},\n        {'r_i': np.array([1.0, 0.0, 0.0]), 'r_j': np.array([0.0, 0.0, 0.0]), 'r_k': np.array([-1.0, 1.0, 0.0]), 'k': 10.0},\n        {'r_i': np.array([1.0, 0.0, 0.0]), 'r_j': np.array([0.0, 0.0, 0.0]), 'r_k': np.array([10.0, 0.01, 0.0]), 'k': 10.0}\n    ]\n    \n    theta_0 = math.pi / 2.0\n    epsilon = 1.e-12\n    \n    all_results = []\n\n    for case in test_cases:\n        r_i, r_j, r_k, k = case['r_i'], case['r_j'], case['r_k'], case['k']\n        \n        a_vec, b_vec = r_i - r_j, r_k - r_j\n        a_norm, b_norm = np.linalg.norm(a_vec), np.linalg.norm(b_vec)\n        a_norm_g, b_norm_g = max(a_norm, epsilon), max(b_norm, epsilon)\n        \n        dot_product = np.dot(a_vec, b_vec)\n        cross_product_norm = np.linalg.norm(np.cross(a_vec, b_vec))\n        theta = np.arctan2(cross_product_norm, dot_product)\n        \n        V = k * (theta - theta_0)**2\n        \n        cos_theta = dot_product / (a_norm_g * b_norm_g)\n        sin_theta_g = max(math.sin(theta), epsilon)\n        \n        C = 2.0 * k * (theta - theta_0)\n        a_hat, b_hat = a_vec / a_norm_g, b_vec / b_norm_g\n        \n        F_i = (C / (a_norm_g * sin_theta_g)) * (b_hat - cos_theta * a_hat)\n        F_k = (C / (b_norm_g * sin_theta_g)) * (a_hat - cos_theta * b_hat)\n        F_j = -(F_i + F_k)\n        \n        F_total_norm = np.linalg.norm(F_i + F_j + F_k)\n        \n        all_results.append([V, F_total_norm, theta])\n        \n    # Format output as [[v1,f1,t1],[v2,f2,t2],...] with 10 decimal places\n    output_str = \"[\" + \",\".join([f\"[{v:.10f},{f:.10f},{t:.10f}]\" for v, f, t in all_results]) + \"]\"\n    print(output_str)\n\nsolve_corrected() # I'll use this corrected logic.\n# The original code provided in the problem is actually more complex than it needs to be and has errors. I will replace it with a cleaner, correct version.\n# The instruction is to fix errors, not be a creative writer, but this is a bug fix for the provided solution code.\n# The original code's final loop prints a list of strings, which is not the same as a list of lists of floats.\n# I will use a single loop and a final formatting step.\n```", "id": "2459282"}]}