{"hands_on_practices": [{"introduction": "掌握蒙特卡洛方法的第一步是亲手实现其核心算法。本练习 [@problem_id:2458836] 将引导您为一个离散系统构建一个 Metropolis 蒙特卡洛模拟。通过为一个像整理书架这样直观的问题建立模型，您将学习如何定义能量函数、设计提议移动以及应用 Metropolis 接受准则，从而为理解更复杂的物理和化学系统奠定坚实的编程和概念基础。", "problem": "给定一个有限的离散对象集合，称为书籍，由整数集 $\\{1,2,\\dots,N\\}$ 索引。每本书 $i$ 有两个属性：一个正实数宽度 $w_i$ 和一个标题字符串 $s_i$。对于由 $\\{1,2,\\dots,N\\}$ 的一个排列 $\\pi$ 表示的任何书籍排列，定义以下量。\n\n1. 通过按字典序对标题进行排序，并根据该排序顺序分配 $r_i \\in \\{1,2,\\dots,N\\}$（排名 $1$ 是按字母顺序最小的），来定义每个标题 $s_i$ 的字母排名 $r_i$。在下面的所有测试用例中，所有标题都是唯一的，因此排名是良定义的。\n\n2. 定义尺寸失配成本\n$$\nM(\\pi) \\;=\\; \\sum_{k=1}^{N-1} \\left|\\, w_{\\pi_{k+1}} - w_{\\pi_{k}} \\,\\right|.\n$$\n\n3. 定义非字母序成本为关于排名的逆序数\n$$\nI(\\pi) \\;=\\; \\left|\\left\\{\\, (k,\\ell) \\,\\middle|\\, 1 \\le k  \\ell \\le N,\\; r_{\\pi_k} > r_{\\pi_\\ell} \\,\\right\\}\\right|.\n$$\n\n4. 给定正权重 $a>0$ 和 $b>0$，定义总能量\n$$\nE(\\pi) \\;=\\; a \\, M(\\pi) \\;+\\; b \\, I(\\pi).\n$$\n\n考虑在绝对温度 $T>0$、玻尔兹曼常数 $k_\\mathrm{B}=1$ 时，排列上的正则平衡分布，\n$$\n\\mathbb{P}(\\pi) \\;\\propto\\; \\exp\\!\\big(\\,-E(\\pi)/T\\,\\big).\n$$\n\n定义排列空间上的一个离散时间马尔可夫链如下。在时间步 $t=0$ 时，使用单位排列 $\\pi^{(0)}$ 进行初始化，该排列将书籍按原始列出顺序放置。对于每一步 $t=1,2,\\dots,M$，从 $\\{1,2,\\dots,N\\}$ 中均匀随机选择两个不同的位置 $u,v$，令 $\\tilde{\\pi}$ 为通过交换 $\\pi^{(t-1)}$ 中位置 $u$ 和 $v$ 处的条目而得到的排列，计算 $\\Delta E = E(\\tilde{\\pi}) - E(\\pi^{(t-1)})$，并设置\n$$\n\\pi^{(t)} \\;=\\; \\begin{cases}\n\\tilde{\\pi},  \\text{with probability } \\min\\left\\{\\,1,\\; \\exp\\!\\big(-\\Delta E/T\\big)\\,\\right\\},\\\\\n\\pi^{(t-1)},  \\text{otherwise}.\n\\end{cases}\n$$\n\n所有伪随机选择必须使用一个伪随机数生成器进行，该生成器在每个测试用例开始时使用指定的整数种子 $s$ 进行初始化，以便整个轨迹由参数唯一确定。令\n$$\nE_{\\min} \\;=\\; \\min\\{\\, E(\\pi^{(t)}) \\,\\mid\\, t = 0,1,\\dots,M \\,\\}\n$$\n为沿轨迹遇到的最低能量，包括初始状态。\n\n任务：对于下面的每个测试用例，计算 $E_{\\min}$ 并将其报告为一个四舍五入到六位小数的实数。\n\n测试套件（每个用例是一个元组 $\\big((w_1,\\dots,w_N),(s_1,\\dots,s_N),a,b,T,M,s\\big)$）：\n\n- 用例 $1$（一般情况）：$\\big(([1.0, 1.5, 0.9, 2.0, 1.2, 1.8],\\;[\"C\", \"A\", \"F\", \"B\", \"D\", \"E\"],\\; 1.0,\\; 0.5,\\; 0.5,\\; 10000,\\; 314159)\\big)$。\n\n- 用例 $2$（边界：单本书）：$\\big(([1.0],\\;[\"A\"],\\; 2.0,\\; 1.0,\\; 1.0,\\; 10,\\; 7)\\big)$。\n\n- 用例 $3$（两本书，逆字母序）：$\\big(([1.0, 2.0],\\;[\"B\", \"A\"],\\; 0.1,\\; 5.0,\\; 0.1,\\; 100,\\; 999)\\big)$。\n\n- 用例 $4$（边缘：尺寸相等，起始为逆字母序）：$\\big(([1.0, 1.0, 1.0, 1.0],\\;[\"d\", \"c\", \"b\", \"a\"],\\; 2.0,\\; 1.0,\\; 2.0,\\; 5000,\\; 2024)\\big)$。\n\n最终输出格式：您的程序应生成单行输出，其中包含四个结果，形式为用方括号括起来的逗号分隔列表，每个条目都四舍五-五入到六位小数且不含额外空格，例如 $[x_1,x_2,x_3,x_4]$，其中每个 $x_i$ 是一个小数点后恰好有六位数字的实数。", "solution": "所提出的问题是统计力学领域中一个明确定义的计算任务，具体要求实现一个离散状态、离散时间的马尔可夫链蒙特卡洛（MCMC）模拟。所描述的算法是标准的Metropolis-Hastings算法，此处用于探索一组对象（称为书籍）的排列构成的构型空间。目标是找到在有限的模拟轨迹中遇到的最小能量。\n\n在继续之前，需要对问题陈述进行验证。\n\n**步骤1：提取的已知条件**\n- 一个有限的对象（书籍）集合由集合 $\\{1,2,\\dots,N\\}$ 索引。\n- 每本书 $i$ 有一个正实数宽度 $w_i > 0$ 和一个唯一的标题字符串 $s_i$。\n- 书籍的一个排列由 $\\pi$ 表示，它是 $\\{1,2,\\dots,N\\}$ 的一个排列。$\\pi_k$ 是位置 $k$ 上书籍的索引。\n- 字母排名 $r_i$ 是标题 $s_i$ 在所有标题的字典序排序列表中的排名，其中 $r_i \\in \\{1,2,\\dots,N\\}$。\n- 尺寸失配成本：$M(\\pi) = \\sum_{k=1}^{N-1} |w_{\\pi_{k+1}} - w_{\\pi_k}|$。\n- 非字母序成本（逆序数）：$I(\\pi) = |\\{ (k,\\ell) | 1 \\le k  \\ell \\le N, r_{\\pi_k} > r_{\\pi_\\ell} \\}|$。\n- 总能量：$E(\\pi) = a M(\\pi) + b I(\\pi)$，其中给定的权重 $a>0, b>0$。\n- 概率分布：正则平衡分布由 $P(\\pi) \\propto \\exp(-E(\\pi)/T)$ 给出，其中 $T>0$ 是绝对温度，玻尔兹曼常数 $k_\\mathrm{B}=1$。\n- 马尔可夫链蒙特卡洛模拟：\n    - 初始状态 ($t=0$)：$\\pi^{(0)}$ 是单位排列，代表原始的列出顺序。\n    - 提议步骤：在每个时间步 $t \\in \\{1,\\dots,M\\}$，从 $\\{1,\\dots,N\\}$ 中均匀随机选择两个不同的位置 $u,v$。通过交换当前排列 $\\pi^{(t-1)}$ 中位置 $u,v$ 处的元素，生成一个提议排列 $\\tilde{\\pi}$。\n    - 接受步骤：该提议以概率 $p_{acc} = \\min\\{1, \\exp(-\\Delta E/T)\\}$ 被接受，即 $\\pi^{(t)} = \\tilde{\\pi}$，其中 $\\Delta E = E(\\tilde{\\pi}) - E(\\pi^{(t-1)})$。否则，状态保持不变，即 $\\pi^{(t)} = \\pi^{(t-1)}$。\n- 伪随机性：伪随机数生成器需使用特定的整数 $s$ 作为种子。\n- 目标：计算 $E_{\\min} = \\min\\{ E(\\pi^{(t)}) | t = 0,1,\\dots,M \\}$。\n- 测试用例提供元组 $(\\{w_i\\}, \\{s_i\\}, a, b, T, M, s)$。\n\n**步骤2：使用提取的已知条件进行验证**\n根据所需标准对问题进行评估。\n- **科学性**：该问题在根本上是合理的。它描述了 Metropolis-Hastings 算法，这是计算统计物理学和化学的基石，应用于一个组合系统。能量函数、玻尔兹曼分布和接受准则都是标准的且公式正确。\n- **适定性**：该问题是适定的。对于给定的一组参数和指定的伪随机数生成器种子，系统的整个轨迹是确定性的。因此，遇到的最小能量 $E_{\\min}$ 是一个唯一定义且可计算的量。\n- **客观性**：该问题使用精确且无歧义的数学语言陈述，不含任何主观或基于意见的声明。\n\n问题的所有方面（定义、参数、算法）都得到了完整且一致的说明。没有科学缺陷、歧义或矛盾。\n\n**步骤3：结论与行动**\n该问题是**有效的**。将构建一个解决方案。\n\n**基于原理的解决方案设计**\n\n任务的核心是实现指定的MCMC模拟。我们系统的状态是书籍的排列。为便于计算，我们将一个排列表示为一个原始书籍索引的数组。设此数组为 $p$，长度为 $N$。元素 $p[k]$（使用从 $0$ 开始的索引）是位置 $k+1$ 处书籍的原始索引。\n\n1.  **排名的预计算**：字母排名 $\\{r_i\\}$ 在模拟过程中不会改变。它们可以在开始时一次性计算出来。我们将每个原始书籍索引 $i \\in \\{0, \\dots, N-1\\}$ 与其标题 $s_i$ 关联起来，根据标题对这些配对进行排序，然后分配从 $1$ 到 $N$ 的排名。结果存储在一个数组中，其中第 $i$-个元素是原始索引为 $i$ 的书籍的排名。\n\n2.  **能量计算**：需要一个函数来计算任何给定排列 $p$ 的总能量 $E(\\pi)$。\n    - 尺寸失配成本 $M(\\pi)$ 计算为排列中相邻书籍宽度的绝对差之和：\n    $$\n    M(p) = \\sum_{k=0}^{N-2} |w_{p[k+1]} - w_{p[k]}|\n    $$\n    这是一个 $O(N)$ 的计算。\n    - 非字母序成本 $I(\\pi)$ 是与排列对应的排名序列中的逆序数。对于一个排列 $p$，排名序列为 $(r_{p[0]}, r_{p[1]}, \\dots, r_{p[N-1]})$。逆序数是：\n    $$\n    I(p) = |\\{ (k,\\ell) | 0 \\le k  \\ell \\le N-1, r_{p[k]} > r_{p[\\ell]} \\}|\n    $$\n    一个直接的双循环实现来计算逆序数的时间复杂度为 $O(N^2)$。鉴于测试套件中 $N$ 的最大值很小（例如，$N=6$），这种复杂度是完全可以接受的，并且其实现简单明了，从而最大限度地降低了逻辑错误的风险。对于更大的 $N$，基于归并排序的 $O(N \\log N)$ 算法将更适合计算 $I(\\pi)$，或者在交换期间对 $\\Delta I$ 进行 $O(N)$ 更新。在这里，重新计算是足够的。\n    - 那么总能量是 $E(p) = a M(p) + b I(p)$。\n\n3.  **模拟轨迹**：\n    - **初始化**：我们从伪随机数生成器的种子 $s$ 开始，以确保可复现性。初始排列 $p^{(0)}$ 是单位排列，$p^{(0)} = [0, 1, \\dots, N-1]$。计算初始能量 $E^{(0)} = E(p^{(0)})$，并将迄今为止见到的最小能量初始化为 $E_{\\min} = E^{(0)}$。\n    - **迭代**：模拟进行 $M$ 步。在每一步 $t = 1, \\dots, M$中：\n        a. 当前状态是 $(\\pi^{(t-1)}, E^{(t-1)})$。\n        b. 均匀随机选择两个不同的位置，例如 $u$ 和 $v$，其中 $0 \\le u, v  N, u \\neq v$。\n        c. 通过交换当前排列 $p^{(t-1)}$ 中索引 $u$ 和 $v$ 处的元素，创建一个提议排列 $\\tilde{p}$。\n        d. 从头开始计算提议状态的能量 $\\tilde{E} = E(\\tilde{p})$，如上所述。能量变化为 $\\Delta E = \\tilde{E} - E^{(t-1)}$。\n        e. 应用 Metropolis 准则：从均匀分布 $U(0,1)$ 中抽取一个随机变量 $z$。如果 $z  \\exp(-\\Delta E / T)$，则接受该提议。这个单一条件正确地处理了能量降低（$\\Delta E \\le 0$，此时 $\\exp(-\\Delta E/T) \\ge 1$）和能量升高（$\\Delta E > 0$）的移动。\n        f. 如果移动被接受，新状态为 $(\\pi^{(t)}, E^{(t)}) = (\\tilde{p}, \\tilde{E})$。如果被拒绝，状态保持不变：$(\\pi^{(t)}, E^{(t)}) = (\\pi^{(t-1)}, E^{(t-1)})$。\n        g. 更新最小能量：$E_{\\min} = \\min(E_{\\min}, E^{(t)})$。\n\n4.  **特殊情况**：\n    - 对于 $N=1$，排列空间只包含一个元素。不可能进行交换。尺寸失配成本 $M(\\pi)$ 和逆序数 $I(\\pi)$ 根据定义都为 $0$。因此，$E(\\pi) = 0$ 且 $E_{\\min}$ 必须为 $0$。\n    - 如果所有宽度 $\\{w_i\\}$ 都相等，那么对于所有排列 $\\pi$，$M(\\pi) = 0$。能量简化为 $E(\\pi) = b I(\\pi)$，模拟的目标就仅仅是最小化字母逆序数。\n\n这种结构化的方法确保了一个正确且稳健的实现，该实现直接遵循问题的形式化规范。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the book arrangement problem using a Metropolis Monte Carlo simulation\n    for a given set of test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case 1: General case\n        (\n            [1.0, 1.5, 0.9, 2.0, 1.2, 1.8],\n            [\"C\", \"A\", \"F\", \"B\", \"D\", \"E\"],\n            1.0, 0.5, 0.5, 10000, 314159\n        ),\n        # Case 2: Boundary - single book\n        (\n            [1.0],\n            [\"A\"],\n            2.0, 1.0, 1.0, 10, 7\n        ),\n        # Case 3: Two books, reversed alphabetical order\n        (\n            [1.0, 2.0],\n            [\"B\", \"A\"],\n            0.1, 5.0, 0.1, 100, 999\n        ),\n        # Case 4: Edge - equal sizes, reverse alphabetical starting order\n        (\n            [1.0, 1.0, 1.0, 1.0],\n            [\"d\", \"c\", \"b\", \"a\"],\n            2.0, 1.0, 2.0, 5000, 2024\n        ),\n    ]\n\n    results = []\n    for case in test_cases:\n        widths, titles, a, b, T, M, seed = case\n        N = len(widths)\n        \n        # Consistent RNG for reproducibility\n        rng = np.random.default_rng(seed)\n\n        # Handle trivial case N = 1\n        if N == 1:\n            results.append(0.0)\n            continue\n\n        # --- Pre-computation ---\n        # 1. Convert to numpy arrays for efficiency\n        widths_np = np.array(widths, dtype=float)\n        \n        # 2. Determine alphabetical ranks (1-based)\n        # Pair original indices with titles, sort, and extract ranks\n        indexed_titles = sorted(enumerate(titles), key=lambda x: x[1])\n        ranks = np.zeros(N, dtype=int)\n        for rank, (original_index, _) in enumerate(indexed_titles, 1):\n            ranks[original_index] = rank\n\n        # --- Energy Calculation Function ---\n        def calculate_energy(p, widths, ranks, a, b):\n            \"\"\"Calculates the total energy for a given permutation p.\"\"\"\n            p_ranks = ranks[p]\n            p_widths = widths[p]\n            \n            # M(pi): Size-mismatch cost\n            m_cost = np.sum(np.abs(p_widths[1:] - p_widths[:-1]))\n            \n            # I(pi): Non-alphabetical cost (inversion count)\n            # A simple O(N^2) implementation is sufficient for small N.\n            i_cost = 0\n            for i in range(N):\n                for j in range(i + 1, N):\n                    if p_ranks[i] > p_ranks[j]:\n                        i_cost += 1\n            \n            return a * m_cost + b * i_cost\n\n        # --- MCMC Simulation ---\n        # Initial state (identity permutation)\n        current_p = np.arange(N)\n        current_energy = calculate_energy(current_p, widths_np, ranks, a, b)\n        min_energy = current_energy\n\n        # Main simulation loop\n        for _ in range(M):\n            # Propose a move: swap two distinct elements\n            # rng.choice is efficient and ensures u != v\n            u, v = rng.choice(N, size=2, replace=False)\n            \n            proposal_p = current_p.copy()\n            proposal_p[u], proposal_p[v] = proposal_p[v], proposal_p[u]\n            \n            proposal_energy = calculate_energy(proposal_p, widths_np, ranks, a, b)\n            \n            delta_E = proposal_energy - current_energy\n            \n            # Metropolis-Hastings acceptance criterion\n            if delta_E = 0 or rng.random()  np.exp(-delta_E / T):\n                current_p = proposal_p\n                current_energy = proposal_energy\n            \n            # Update minimum energy found\n            if current_energy  min_energy:\n                min_energy = current_energy\n        \n        results.append(min_energy)\n\n    # Format output as specified\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2458836"}, {"introduction": "从简单模型转向实际物理系统时，我们常常需要使用非笛卡尔坐标。本练习 [@problem_id:2458841] 探讨了在非笛卡尔坐标中正确实现蒙特卡洛模拟的一个关键细节。为了确保模拟的平稳分布与物理现实一致（例如，在球面上均匀分布），必须在 Metropolis-Hastings 接受概率中引入一个雅可比行列式（Jacobian）修正因子。通过亲手实现这个修正，您将深刻理解细致平衡原理以及它在坐标变换中的重要应用。", "problem": "一个粒子被约束在三维欧几里得空间中半径为 $R$ 的球面上运动。该球面由球坐标 $(\\theta,\\phi)$ 参数化，其中 $\\theta \\in [0,\\pi]$ 是极角，$\\phi \\in [0,2\\pi)$ 是方位角。粒子的平衡（目标）分布相对于球面上的表面积测度是均匀的。通过将独立的零均值增量 $\\Delta \\theta$ 和 $\\Delta \\phi$ 加到 $(\\theta,\\phi)$ 上，构造一个角度空间中的提议；然后通过在边界 $0$ 和 $\\pi$ 处反射 $\\theta$ 以及将 $\\phi$ 进行模 $2\\pi$ 环绕，将扰动后的角度映射回其规范范围。提议增量 $\\Delta \\theta$ 和 $\\Delta \\phi$ 服从具有指定标准差的高斯分布。所得到的马尔可夫链必须使均匀的表面积分布保持不变。当核函数在角坐标中指定时，$(\\theta,\\phi)$ 和表面积之间的变量变换会引入一个雅可比行列式，该行列式会影响表面上的提议密度。\n\n你的任务是：\n\n- 仅使用第一性原理，确定从角坐标 $(\\theta,\\phi)$ 到半径为 $R$ 的球面上的表面积元的变换的雅可比行列式 $J(R,\\theta)$。用 $R$ 和 $\\theta$ 表示你的结果。\n\n- 对于对称的角度扰动（角度空间中的前向和后向分布相同），从第一性原理出发，确定接受率中纯粹由 $(\\theta,\\phi)$ 与表面积测度之间的提议密度变换产生的乘法因子，该因子用 $\\theta$ 和 $\\theta'$ 表示，对应于一次移动 $(\\theta,\\phi) \\to (\\theta',\\phi')$。\n\n- 使用上述角度提议，实现粒子在球面上的蒙特卡洛（MC; Monte Carlo）模拟。构建两个变体：\n  1. 一个在其接受决策中使用了由你的雅可比行列式所蕴含的正确提议密度变换的变体，从而使链对于均匀表面积分布保持不变。\n  2. 一个在其接受决策中错误地忽略了此变换的变体。\n\n- 对于每个变体，使用固定的种子以保证可复现性，估计可观测量 $f(\\theta,\\phi) = \\cos^2(\\theta)$ 在链的稳态分布下的期望值。\n\n角度必须以弧度为单位。所有数值答案必须表示为不带单位的实数。\n\n测试套件和要求的输出：\n\n1. 在以下参数对上计算雅可比行列式 $J(R,\\theta)$：\n   - $(R,\\theta) = (1,\\pi/6)$，\n   - $(R,\\theta) = (2,\\pi/2)$，\n   - $(R,\\theta) = (3,\\pi)$。\n\n2. 对于对称角度扰动，为以下 $(\\theta,\\theta')$ 对计算提议密度雅可比比率因子：\n   - $(\\theta,\\theta') = (\\pi/12,\\pi/3)$，\n   - $(\\theta,\\theta') = (\\pi/3,5\\pi/12)$。\n\n3. 运行一个模拟，总步数为 $N = 200000$，预烧期为 $B = 5000$，半径为 $R = 1$，起始角度为 $(\\theta_0,\\phi_0) = (1.234,2.345)$，高斯提议标准差为 $\\sigma_\\theta = 0.3$ 和 $\\sigma_\\phi = 0.6$。使用固定的种子 $123$。为 $\\mathbb{E}[\\cos^2(\\theta)]$ 生成两个估计值：\n   - 一个使用正确考虑了由你的雅可比行列式引起的提议密度变换的接受决策。\n   - 一个使用忽略了提议密度变换的接受决策。\n\n最终输出格式：\n\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按以下顺序排列：\n  - 项目 $1$ 中的三个雅可比行列式值，按给定顺序。\n  - 项目 $2$ 中的两个提议密度雅可比比率因子，按给定顺序。\n  - 项目 $3$ 中的两个蒙特卡洛估计值，按给定顺序（首先是正确变体的估计值，然后是错误变体的估计值）。\n  例如，输出必须具有 $[\\text{J1},\\text{J2},\\text{J3},\\text{F1},\\text{F2},\\text{E\\_correct},\\text{E\\_wrong}]$ 的形式。", "solution": "所提出的问题是计算统计力学中一个定义明确且具有科学依据的练习，具体涉及将 Metropolis-Hastings 算法应用于非笛卡尔坐标系。对问题陈述的严格验证没有发现任何不一致、歧义或违反科学原理之处。因此，我将从第一性原理出发，给出一个完整的解决方案。\n\n解决方案分为三个部分，与问题陈述中概述的任务相对应。\n\n首先，我们确定从球坐标到球面上表面积元的变换的雅可比行列式。半径为 $R$ 的球面上的一个点在笛卡尔坐标 $(x, y, z)$ 中使用球坐标 $(\\theta, \\phi)$ 参数化为：\n$$\n\\vec{r}(\\theta, \\phi) = (R \\sin\\theta \\cos\\phi, R \\sin\\theta \\sin\\phi, R \\cos\\theta)\n$$\n其中 $\\theta \\in [0, \\pi]$ 是极角，$\\phi \\in [0, 2\\pi)$ 是方位角。无穷小表面积元 $dA$ 由切向量 $\\frac{\\partial\\vec{r}}{\\partial\\theta}$ 和 $\\frac{\\partial\\vec{r}}{\\partial\\phi}$ 的叉积的模给出。\n\n偏导数为：\n$$\n\\frac{\\partial\\vec{r}}{\\partial\\theta} = (R \\cos\\theta \\cos\\phi, R \\cos\\theta \\sin\\phi, -R \\sin\\theta)\n$$\n$$\n\\frac{\\partial\\vec{r}}{\\partial\\phi} = (-R \\sin\\theta \\sin\\phi, R \\sin\\theta \\cos\\phi, 0)\n$$\n叉积为：\n$$\n\\frac{\\partial\\vec{r}}{\\partial\\theta} \\times \\frac{\\partial\\vec{r}}{\\partial\\phi} = (R^2 \\sin^2\\theta \\cos\\phi, R^2 \\sin^2\\theta \\sin\\phi, R^2 \\sin\\theta \\cos\\theta)\n$$\n该向量的模，即为变换的雅可比行列式，是：\n$$\nJ(R, \\theta) = \\left\\| \\frac{\\partial\\vec{r}}{\\partial\\theta} \\times \\frac{\\partial\\vec{r}}{\\partial\\phi} \\right\\| = \\sqrt{(R^2 \\sin^2\\theta \\cos\\phi)^2 + (R^2 \\sin^2\\theta \\sin\\phi)^2 + (R^2 \\sin\\theta \\cos\\theta)^2}\n$$\n$$\nJ(R, \\theta) = \\sqrt{R^4 \\sin^4\\theta (\\cos^2\\phi + \\sin^2\\phi) + R^4 \\sin^2\\theta \\cos^2\\theta} = \\sqrt{R^4 \\sin^2\\theta (\\sin^2\\theta + \\cos^2\\theta)} = \\sqrt{R^4 \\sin^2\\theta}\n$$\n由于 $\\theta \\in [0, \\pi]$，所以 $\\sin\\theta \\ge 0$。因此，雅可比行列式为：\n$$\nJ(R, \\theta) = R^2 \\sin\\theta\n$$\n该量将球面上的微分面积元 $dA$ 与角坐标的微分增量联系起来：$dA = J(R, \\theta) d\\theta d\\phi = R^2 \\sin\\theta d\\theta d\\phi$。\n\n其次，我们确定 Metropolis-Hastings 接受率中由坐标变换引起的因子。从状态 $s$ 到提议状态 $s'$ 的移动的接受概率 $\\alpha$ 由下式给出：\n$$\n\\alpha(s \\to s') = \\min\\left(1, \\frac{\\pi(s')}{\\pi(s)} \\frac{g(s' \\to s)}{g(s \\to s')}\\right)\n$$\n这里，$\\pi(s)$ 是目标概率密度，$g(s \\to s')$ 是从 $s$ 到 $s'$ 的提议概率密度。状态 $s$ 和 $s'$ 是球面上的点。目标分布相对于表面积测度是均匀的，这意味着对于球面上所有的点 $s$，$\\pi(s) = \\text{constant}$。因此，目标密度的比值 $\\frac{\\pi(s')}{\\pi(s)} = 1$。\n\n提议是在角坐标 $(\\theta, \\phi)$ 中进行的，而不是直接在球面上。设 $g_{ang}((\\theta,\\phi) \\to (\\theta',\\phi'))$ 为角坐标空间中的提议密度。球面上的相应提议密度 $g(s \\to s')$ 必须相对于表面积测度 $dA$ 定义。概率守恒要求 $g(s \\to s') dA' = g_{ang}((\\theta,\\phi) \\to (\\theta',\\phi')) d\\theta' d\\phi'$。使用 $dA' = J(\\theta') d\\theta' d\\phi'$，我们发现：\n$$\ng(s \\to s') = \\frac{g_{ang}((\\theta,\\phi) \\to (\\theta',\\phi'))}{J(\\theta')}\n$$\n类似地，对于逆向移动：\n$$\ng(s' \\to s) = \\frac{g_{ang}((\\theta',\\phi') \\to (\\theta,\\phi))}{J(\\theta)}\n$$\n因此，接受概率中的提议密度比为：\n$$\n\\frac{g(s' \\to s)}{g(s \\to s')} = \\frac{g_{ang}((\\theta',\\phi') \\to (\\theta,\\phi))}{g_{ang}((\\theta,\\phi) \\to (\\theta',\\phi'))} \\times \\frac{J(\\theta')}{J(\\theta)}\n$$\n问题陈述中指出，角度扰动是对称的，意味着角度空间中的前向和后向提议具有相同的分布。这意味着 $g_{ang}((\\theta',\\phi') \\to (\\theta,\\phi)) = g_{ang}((\\theta,\\phi) \\to (\\theta',\\phi'))$。因此，该比率简化为雅可比行列式的比值：\n$$\n\\frac{g(s' \\to s)}{g(s \\to s')} = \\frac{J(\\theta')}{J(\\theta)} = \\frac{R^2 \\sin\\theta'}{R^2 \\sin\\theta} = \\frac{\\sin\\theta'}{\\sin\\theta}\n$$\n这就是所要求的乘法因子。正确的接受概率是 $\\alpha = \\min\\left(1, \\frac{\\sin\\theta'}{\\sin\\theta}\\right)$。\n\n第三，我们设计蒙特卡洛模拟。目标是估计在球面上均匀分布下，可观测量 $f(\\theta, \\phi) = \\cos^2(\\theta)$ 的期望值。理论期望值为：\n$$\n\\mathbb{E}[\\cos^2\\theta] = \\frac{\\int_0^{2\\pi} \\int_0^\\pi \\cos^2\\theta \\sin\\theta \\,d\\theta d\\phi}{\\int_0^{2\\pi} \\int_0^\\pi \\sin\\theta \\,d\\theta d\\phi} = \\frac{2\\pi \\int_0^\\pi \\cos^2\\theta \\sin\\theta \\,d\\theta}{4\\pi} = \\frac{1}{2}\\left[-\\frac{\\cos^3\\theta}{3}\\right]_0^\\pi = \\frac{1}{2}\\left(-\\frac{(-1)^3}{3} - \\left(-\\frac{1^3}{3}\\right)\\right) = \\frac{1}{3}\n$$\n模拟的实现如下：\n1.  在 $k=0$ 时将状态 $(\\theta_k, \\phi_k)$ 初始化为 $(\\theta_0, \\phi_0)$。\n2.  对 $k = 0, \\dots, N-1$ 进行迭代：\n    a. 通过从高斯分布 $\\mathcal{N}(0, \\sigma_\\theta^2)$ 和 $\\mathcal{N}(0, \\sigma_\\phi^2)$ 分别抽取独立增量 $\\Delta\\theta$ 和 $\\Delta\\phi$ 来提议一个新状态 $(\\theta_p, \\phi_p)$。\n    b. 应用边界条件。新的极角 $\\theta_p$ 是通过在边界 $0$ 和 $\\pi$ 处反射 $\\theta_k + \\Delta\\theta$ 得到的。这可以通过变换 $\\theta_p = \\text{mod}(\\theta_k+\\Delta\\theta, 2\\pi)$，然后如果 $\\theta_p > \\pi$ 则 $\\theta_p = 2\\pi - \\theta_p$ 来实现。新的方位角 $\\phi_p$ 是通过将 $\\phi_k + \\Delta\\phi$ 进行模 $2\\pi$ 环绕得到的。\n    c. 计算接受概率 $\\alpha$。\n       - **正确变体**：$\\alpha = \\min\\left(1, \\frac{\\sin\\theta_p}{\\sin\\theta_k}\\right)$。\n       - **错误变体**：雅可比因子被忽略。接受概率变为 $\\alpha = \\min(1, 1) = 1$，意味着所有移动都被接受。\n    d. 抽取一个随机数 $u \\sim U(0,1)$。如果 $u  \\alpha$，则设置 $(\\theta_{k+1}, \\phi_{k+1}) = (\\theta_p, \\phi_p)$。否则，$(\\theta_{k+1}, \\phi_{k+1}) = (\\theta_k, \\phi_k)$。\n3.  经过 $B$ 步的预烧期后，通过对剩下的 $N-B$ 步中的 $\\cos^2(\\theta_k)$进行平均来估计期望值 $\\mathbb{E}[\\cos^2\\theta]$。\n\n错误变体在 $(\\theta, \\phi)$ 空间中对一个均匀的概率密度进行采样，即 $p(\\theta, \\phi) \\propto 1$。在这个不正确的分布下的期望值是 $\\mathbb{E}_{incorrect}[\\cos^2\\theta] = \\frac{1}{2\\pi^2} \\int_0^{2\\pi} d\\phi \\int_0^\\pi \\cos^2\\theta \\,d\\theta = \\frac{1}{\\pi} \\int_0^\\pi \\frac{1+\\cos(2\\theta)}{2}d\\theta = \\frac{1}{2\\pi}[\\theta + \\frac{\\sin(2\\theta)}{2}]_0^\\pi = \\frac{1}{2}$。模拟结果应符合这些 $1/3$ 和 $1/2$ 的理论预测。实现将精确地遵循此设计。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_mc_simulation(params, correct_jacobian, seed):\n    \"\"\"\n    Runs a Monte Carlo simulation of a particle on a sphere.\n\n    Args:\n        params (tuple): A tuple containing simulation parameters:\n                        (N, B, R, theta0, phi0, sigma_theta, sigma_phi).\n        correct_jacobian (bool): If True, use the correct acceptance criterion.\n                                 If False, use the incorrect one.\n        seed (int): The seed for the random number generator.\n\n    Returns:\n        float: The estimated expectation value of cos^2(theta).\n    \"\"\"\n    N, B, R, theta0, phi0, sigma_theta, sigma_phi = params\n    \n    # Initialize a new random number generator for each independent run\n    rng = np.random.default_rng(seed)\n    \n    theta = theta0\n    phi = phi0\n    \n    observable_sum = 0.0\n    samples_collected = 0\n    \n    for step in range(N):\n        # Propose a move in angular coordinates\n        d_theta = rng.normal(0.0, sigma_theta)\n        d_phi = rng.normal(0.0, sigma_phi)\n        \n        theta_prop = theta + d_theta\n        phi_prop = phi + d_phi\n        \n        # Apply boundary conditions\n        # For theta: reflection at 0 and pi\n        # This maps the real line to [0, pi] via folding\n        theta_p = np.mod(theta_prop, 2.0 * np.pi)\n        if theta_p > np.pi:\n            theta_p = 2.0 * np.pi - theta_p\n            \n        # For phi: wrapping modulo 2*pi\n        phi_p = np.mod(phi_prop, 2.0 * np.pi)\n        \n        # Calculate acceptance probability\n        if correct_jacobian:\n            # The target distribution is uniform on the sphere, so pi(s')/pi(s) = 1.\n            # The acceptance probability is determined by the Jacobian factor.\n            sin_theta_k = np.sin(theta)\n            sin_theta_p = np.sin(theta_p)\n            \n            # To avoid division by zero if theta is at a pole (0 or pi).\n            if sin_theta_k  1e-12:\n                # If moving from a pole, the volume element is increasing from zero,\n                # so the move should always be accepted unless the proposed\n                # point is also a pole, in which case the ratio is 1.\n                acceptance_ratio = 1.0 if sin_theta_p  1e-12 else np.inf\n            else:\n                acceptance_ratio = sin_theta_p / sin_theta_k\n            \n            alpha = min(1.0, acceptance_ratio)\n        else:\n            # Incorrect variant: ignore the Jacobian factor.\n            # Since the target density is uniform, the acceptance probability is 1.\n            alpha = 1.0\n            \n        # Accept or reject the move\n        if rng.uniform(0.0, 1.0)  alpha:\n            theta = theta_p\n            phi = phi_p\n            \n        # Collect samples after the burn-in period\n        if step >= B:\n            observable_sum += np.cos(theta)**2\n            samples_collected += 1\n            \n    if samples_collected == 0:\n        return np.nan\n        \n    return observable_sum / samples_collected\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem, calculate all required values,\n    and print the final output in the specified format.\n    \"\"\"\n    # ====== Task 1: Evaluate Jacobian determinant J(R, theta) ======\n    # J(R, theta) = R^2 * sin(theta)\n    \n    # Test case 1: (R, theta) = (1, pi/6)\n    R1, theta1 = 1.0, np.pi/6.0\n    J1 = R1**2 * np.sin(theta1)\n    \n    # Test case 2: (R, theta) = (2, pi/2)\n    R2, theta2 = 2.0, np.pi/2.0\n    J2 = R2**2 * np.sin(theta2)\n    \n    # Test case 3: (R, theta) = (3, pi)\n    R3, theta3 = 3.0, np.pi\n    J3 = R3**2 * np.sin(theta3)\n    \n    # ====== Task 2: Evaluate proposal-density Jacobian ratio factor ======\n    # Factor = sin(theta') / sin(theta)\n    \n    # Test case 1: (theta, theta') = (pi/12, pi/3)\n    theta_a1, theta_a2 = np.pi/12.0, np.pi/3.0\n    F1 = np.sin(theta_a2) / np.sin(theta_a1)\n\n    # Test case 2: (theta, theta') = (pi/3, 5*pi/12)\n    theta_b1, theta_b2 = np.pi/3.0, 5.0*np.pi/12.0\n    F2 = np.sin(theta_b2) / np.sin(theta_b1)\n    \n    # ====== Task 3: Run Monte Carlo simulations ======\n    sim_params = (\n        200000,  # N: total steps\n        5000,    # B: burn-in steps\n        1.0,     # R: radius\n        1.234,   # theta0\n        2.345,   # phi0\n        0.3,     # sigma_theta\n        0.6      # sigma_phi\n    )\n    seed = 123\n    \n    # Run simulation with correct Jacobian factor\n    E_correct = run_mc_simulation(sim_params, correct_jacobian=True, seed=seed)\n    \n    # Run simulation with incorrect (ignored) Jacobian factor\n    E_wrong = run_mc_simulation(sim_params, correct_jacobian=False, seed=seed)\n\n    # Collate results\n    results = [J1, J2, J3, F1, F2, E_correct, E_wrong]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2458841"}, {"introduction": "除了模拟统计力学分布，蒙特卡洛方法也是高维数值积分的基石。本练习 [@problem_id:2458838] 将带您探索一种超越标准蒙特卡洛积分的先进技术——拟蒙特卡洛（Quasi-Monte Carlo, QMC）方法。与使用伪随机数的传统方法不同，QMC 采用低差异序列（如 Sobol 序列）以更均匀地覆盖积分区域，从而通常能以更少的样本点实现更高的精度。通过比较这两种方法的性能，您将获得关于方差缩减技术的实践经验，并了解 QMC 在计算科学中的优势。", "problem": "您必须编写一个完整、可运行的程序，比较伪随机蒙特卡洛方法与Sobol序列（一种拟随机序列）在对一族与计算化学相关的可分离、光滑被积函数进行积分时产生的绝对误差。考虑单位超立方体上的$d$维积分：\n$$\nI_d \\;=\\; \\int_{[0,1]^d} f_d(\\mathbf{x}) \\,\\mathrm{d}\\mathbf{x}, \\quad \\text{其中} \\quad f_d(\\mathbf{x}) \\;=\\; \\prod_{i=1}^{d} \\exp\\!\\big(-\\, i \\, x_i\\big),\n$$\n其中 $\\mathbf{x} = (x_1,\\dots,x_d)$ 且 $d \\in \\mathbb{N}$。函数 $f_d$ 是光滑且可分离的，对于每个整数 $d \\geq 1$，$I_d$ 都是有限且严格为正的。\n\n对于每个指定的数对 $(d,N)$，您的程序必须执行以下操作：\n- 直接根据第一性原理计算 $I_d$ 的解析值。\n- 使用伪随机蒙特卡洛估计器估算 $I_d$，该估计器使用 $N$ 个在 $[0,1]^d$ 上均匀分布的独立样本。对于每个测试用例，伪随机生成器必须使用固定的种子 $s = 12345$ 进行独立初始化。\n- 使用拟蒙特卡洛估计器估算 $I_d$，该估计器使用维度为 $d$ 的标准（未加扰）Sobol序列的前 $N$ 个点，从索引 $0$ 开始。\n- 对每个估计器，计算绝对误差，定义为 $| \\widehat{I}_d - I_d |$，其中 $\\widehat{I}_d$ 表示估计值。\n- 对于每个测试用例，当且仅当基于Sobol序列的绝对误差严格小于伪随机方法的绝对误差时，返回布尔值 $\\,\\text{True}\\,$。\n\n程序中需使用的定义和约定：\n- 对于从 $[0,1]^d$ 上的均匀分布中抽取的 $N$ 个样本 $\\{\\mathbf{x}^{(n)}\\}_{n=1}^N$， $I_d$ 的蒙特卡洛估计器为\n$$\n\\widehat{I}_d^{\\text{MC}} \\;=\\; \\frac{1}{N} \\sum_{n=1}^{N} f_d\\!\\big(\\mathbf{x}^{(n)}\\big).\n$$\n- 对于 $d$ 维Sobol序列（无加扰）的前 $N$ 个点 $\\{\\mathbf{q}^{(n)}\\}_{n=1}^N$，拟蒙特卡洛估计器为\n$$\n\\widehat{I}_d^{\\text{QMC}} \\;=\\; \\frac{1}{N} \\sum_{n=1}^{N} f_d\\!\\big(\\mathbf{q}^{(n)}\\big).\n$$\n\n测试套件：\n您的程序必须运行以下四个测试用例，并按指定的最终输出格式汇总它们的结果。\n- 用例A：$(d,N) = (1,1)$，一个一维单样本的边界情况。\n- 用例B：$(d,N) = (1,64)$，一个中等样本量的一维情况。\n- 用例C：$(d,N) = (3,1000)$，一个样本量非2的幂的中等维度情况。\n- 用例D：$(d,N) = (6,4096)$，一个样本量为2的幂的较高维度情况。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。该列表必须按A、B、C、D的顺序包含每个测试用例的四个布尔值结果。例如，输出格式必须为\n$[b_A,b_B,b_C,b_D]$\n其中每个 $b_\\cdot$ 为 $\\,\\text{True}\\,$ 或 $\\,\\text{False}\\,$（不带引号）。不应打印任何其他文本。", "solution": "该问题是有效的。它提出了一个在数值积分领域中定义明确的计算任务，该任务基于既定的数学原理和标准计算方法。所有必要的参数、定义和条件都已提供，确保了问题的自洽性、一致性，并允许一个唯一且可验证的解。\n\n该问题要求对用于数值积分的伪随机蒙特卡洛（MC）方法和拟蒙特卡洛（QMC）方法进行比较。比较的依据是每种方法相对于一个特定$d$维积分解析值的绝对误差。被积函数是一个在单位超立方体 $[0,1]^d$ 上定义的光滑、可分离函数。该过程必须对由数对 $(d, N)$ 定义的四个不同测试用例执行，其中 $d$ 是维度，$N$ 是样本点数。\n\n对于每个测试用例 $(d,N)$，问题的核心涉及三个主要任务：\n$1$. 积分真值 $I_d$ 的解析计算。\n$2$. 使用MC估计器 $\\widehat{I}_d^{\\text{MC}}$ 和QMC估计器 $\\widehat{I}_d^{\\text{QMC}}$ 对积分进行数值估计。\n$3$. 比较绝对误差 $|\\widehat{I}_d^{\\text{MC}} - I_d|$ 和 $|\\widehat{I}_d^{\\text{QMC}} - I_d|$。\n\n让我们系统地处理每个任务。\n\n**$1$. 积分的解析评估**\n\n需要计算的积分由下式给出\n$$\nI_d \\;=\\; \\int_{[0,1]^d} f_d(\\mathbf{x}) \\,\\mathrm{d}\\mathbf{x}\n$$\n其中被积函数 $f_d(\\mathbf{x})$ 定义为\n$$\nf_d(\\mathbf{x}) \\;=\\; \\prod_{i=1}^{d} \\exp\\!\\big(-\\, i \\, x_i\\big).\n$$\n此函数是可分离的，意味着它可以表示为单变量函数的乘积。因此，多维积分可以分解为一维积分的乘积，这是由富比尼定理（Fubini's theorem）得出的性质：\n$$\nI_d \\;=\\; \\int_0^1 \\cdots \\int_0^1 \\left( \\prod_{i=1}^{d} e^{-ix_i} \\right) dx_1 \\cdots dx_d \\;=\\; \\prod_{i=1}^{d} \\left( \\int_0^1 e^{-ix_i} \\,dx_i \\right).\n$$\n每个一维积分的形式为 $\\int_0^1 e^{-kx} \\,dx$，其中 $k$ 为常数。这个积分是初等的：\n$$\n\\int_0^1 e^{-kx} \\,dx \\;=\\; \\left[ -\\frac{1}{k} e^{-kx} \\right]_0^1 \\;=\\; -\\frac{1}{k} \\left( e^{-k \\cdot 1} - e^{-k \\cdot 0} \\right) \\;=\\; -\\frac{1}{k} (e^{-k} - 1) \\;=\\; \\frac{1 - e^{-k}}{k}.\n$$\n将此结果代入乘积中，对于从 $i=1$到$d$的每一项，令$k = i$，我们得到 $I_d$ 的解析表达式：\n$$\nI_d \\;=\\; \\prod_{i=1}^{d} \\frac{1 - e^{-i}}{i}.\n$$\n该公式允许对任何给定维度 $d$ 的积分值进行直接和精确的计算。\n\n**$2$. 积分的数值估计**\n\n积分 $I_d$ 使用两种不同的蒙特卡洛方法进行估计。两者都依赖于将积分近似为被积函数在一组样本点上的平均值，再乘以积分域的体积（对于单位超立方体 $[0,1]^d$ 而言，体积为1）。\n\n出于计算目的，最好通过先对指数求和来计算被积函数，以防止潜在的数值下溢并提高效率。对于单个点 $\\mathbf{x} = (x_1, \\dots, x_d)$，该函数计算如下：\n$$\nf_d(\\mathbf{x}) = \\exp\\left( \\sum_{i=1}^d -i x_i \\right) = \\exp\\left( -\\mathbf{k} \\cdot \\mathbf{x} \\right)\n$$\n其中 $\\mathbf{k}$ 是系数向量 $(1, 2, \\dots, d)$。\n\n**伪随机蒙特卡洛（MC）估计**\nMC估计器定义为\n$$\n\\widehat{I}_d^{\\text{MC}} \\;=\\; \\frac{1}{N} \\sum_{n=1}^{N} f_d\\!\\big(\\mathbf{x}^{(n)}\\big).\n$$\n点集 $\\{\\mathbf{x}^{(n)}\\}_{n=1}^N$ 是从 $[0,1]^d$ 上的均匀分布中抽取的 $N$ 个独立样本。为确保可复现性，对于每个新的测试用例 $(d,N)$，伪随机数生成器都使用固定的种子 $s = 12345$进行初始化。\n\n**拟蒙特卡洛（QMC）估计**\nQMC估计器具有相同的形式：\n$$\n\\widehat{I}_d^{\\text{QMC}} \\;=\\; \\frac{1}{N} \\sum_{n=1}^{N} f_d\\!\\big(\\mathbf{q}^{(n)}\\big).\n$$\n然而，点集 $\\{\\mathbf{q}^{(n)}\\}_{n=1}^N$ 并非伪随机点。它们是 $d$ 维Sobol序列的前 $N$ 个点，Sobol序列是一种确定性的低差异序列，旨在比伪随机点更均匀地覆盖样本空间。我们使用该序列的标准、未加扰版本，从其第一个点（索引为0）开始。\n\n**$3$. 误差比较与实现**\n\n对于每个测试用例，我们计算解析值 $I_d$ 和两个估计值 $\\widehat{I}_d^{\\text{MC}}$ 和 $\\widehat{I}_d^{\\text{QMC}}$。然后计算各自的绝对误差：\n$$\n\\text{Error}_{\\text{MC}} = \\left| \\widehat{I}_d^{\\text{MC}} - I_d \\right|\n$$\n$$\n\\text{Error}_{\\text{QMC}} = \\left| \\widehat{I}_d^{\\text{QMC}} - I_d \\right|\n$$\n该测试用例的最终结果是严格不等式的布尔值：\n$$\n\\text{Error}_{\\text{QMC}}  \\text{Error}_{\\text{MC}}.\n$$\n对四个指定的 $(d,N)$ 对中的每一个重复此过程。实现将使用 `numpy` 库进行高效的数组操作及其伪随机数生成器 (`numpy.random.default_rng`)。将使用 `scipy.stats.qmc.Sobol` 类来生成Sobol序列点。对于每个测试用例，都会重新实例化随机数生成器和Sobol序列生成器，以确保根据问题规范进行独立且确定性的试验。", "answer": "```python\nimport numpy as np\nfrom scipy.stats.qmc import Sobol\n\ndef solve():\n    \"\"\"\n    Compares the absolute integration error of a pseudo-random Monte Carlo method\n    against a quasi-Monte Carlo method (Sobol sequence) for a family of\n    separable, smooth integrands.\n    \"\"\"\n    \n    # Define test cases: (dimension d, number of samples N)\n    test_cases = [\n        (1, 1),       # Case A\n        (1, 64),      # Case B\n        (3, 1000),    # Case C\n        (6, 4096),    # Case D\n    ]\n\n    # Fixed seed for the pseudo-random number generator\n    seed = 12345\n    \n    results = []\n\n    for d, N in test_cases:\n        # Step 1: Compute the analytical value of the integral I_d\n        # The integral is I_d = product_{i=1 to d} (1 - exp(-i)) / i.\n        # This is calculated using a vectorized numpy operation.\n        i_vals = np.arange(1, d + 1, dtype=float)\n        terms = (1.0 - np.exp(-i_vals)) / i_vals\n        I_d_analytical = np.prod(terms)\n\n        # Vector of coefficients for the integrand exponent: k = (1, 2, ..., d)\n        k_vec = np.arange(1, d + 1, dtype=float)\n\n        # Vectorized integrand function f_d(x) = exp(-k_vec . x) for N points.\n        # This function takes an array of points of shape (N, d).\n        def f_d(x_points):\n            # The matrix-vector product `x_points @ k_vec` computes the dot product\n            # for each of the N points efficiently, returning a shape (N,) array.\n            return np.exp(-x_points @ k_vec)\n\n        # Step 2: Estimate I_d using pseudo-random Monte Carlo (MC)\n        # A new RNG is initialized for each test case to ensure independence.\n        rng = np.random.default_rng(seed=seed)\n        # Generate N points uniformly in the d-dimensional unit hypercube.\n        points_mc = rng.random(size=(N, d))\n        # Evaluate the integrand at these pseudo-random points.\n        values_mc = f_d(points_mc)\n        # The MC estimate is the mean of the function values.\n        I_hat_mc = np.mean(values_mc)\n\n        # Step 3: Estimate I_d using quasi-Monte Carlo (QMC) with a Sobol sequence\n        # A new Sobol sequence generator is created for each case, starting at index 0.\n        sobol_gen = Sobol(d=d, scramble=False)\n        # Generate the first N points of the unscrambled Sobol sequence.\n        points_qmc = sobol_gen.random(n=N)\n        # Evaluate the integrand at these quasi-random points.\n        values_qmc = f_d(points_qmc)\n        # The QMC estimate is the mean of the function values.\n        I_hat_qmc = np.mean(values_qmc)\n\n        # Step 4: Compute absolute errors and compare\n        error_mc = abs(I_hat_mc - I_d_analytical)\n        error_qmc = abs(I_hat_qmc - I_d_analytical)\n        \n        # The result is True if and only if the Sobol error is strictly smaller.\n        is_sobol_better = error_qmc  error_mc\n        results.append(is_sobol_better)\n\n    # The final output must be a single string in the specified format.\n    print(f\"[{','.join(str(r) for r in results)}]\")\n\nsolve()\n```", "id": "2458838"}]}