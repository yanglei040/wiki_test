{"hands_on_practices": [{"introduction": "The cornerstone of fixed-income analysis is the construction of a smooth, arbitrage-free discount curve from a collection of observed bond prices. This first practice guides you through this fundamental process using a practical, code-based approach. You will implement a least-squares method to fit a curve to market data that may be overdetermined or contain noise, and then learn to perform a critical validation step: checking for negative forward rates that signal arbitrage opportunities [@problem_id:2377895].", "id": "2377895", "problem": "Consider a frictionless market with deterministic term structure. Let $P(0,t)$ denote the discount factor at time $t \\ge 0$, which is the present value at time $0$ of one unit of currency received at time $t$. For any fixed set of cash flows $\\{(t_k,a_k)\\}_{k=1}^K$ with payment times $t_k$ (in years) and amounts $a_k$ (in currency units), the no-arbitrage pricing relation requires that the time-$0$ price $V$ of the instrument satisfies\n$$\nV = \\sum_{k=1}^K a_k \\, P(0,t_k).\n$$\nFor a grid of maturities $0 < t_1 < t_2 < \\dots < t_n$, define piecewise-constant forward rates on adjacent intervals by\n$$\nf_i = -\\frac{\\ln\\!\\left(\\frac{P(0,t_{i+1})}{P(0,t_i)}\\right)}{t_{i+1}-t_i}, \\quad i=1,\\dots,n-1.\n$$\nIn this setting, under the assumption of a nonnegative short-rate economy, violations of $f_i \\ge 0$ indicate an arbitrage signal in the derived curve. Treat a forward rate $f_i$ as negative if $f_i < -10^{-10}$.\n\nYour task is to, for each dataset below, construct discount factors $P(0,t_i)$ on the union of all distinct cash flow times in the dataset such that the corresponding instrument pricing relations hold as closely as possible in the least-squares sense when equations are overdetermined, subject to $P(0,t_i) > 0$ for all $i$. Then, using the fitted discount factors, compute the piecewise-constant forward rates on the sorted time grid and count how many are strictly negative according to the threshold above.\n\nAll currency amounts are per $100$ units of face value. All times are in years. All rates (yields and forwards) must be handled as decimals (for example, write $0.05$ for five percent). The required outputs are integers (counts). No other units are required.\n\nTest Suite (three datasets):\n\n- Dataset A (clean zero-coupon instruments): Each instrument pays a single cash flow of $100$ at its maturity; the observed prices are as follows:\n  - Cash flow times and prices:\n    - $(t,a)=(0.5,100)$ with price $98.5112$\n    - $(t,a)=(1.0,100)$ with price $96.8500$\n    - $(t,a)=(1.5,100)$ with price $94.8841$\n    - $(t,a)=(2.0,100)$ with price $92.8642$\n    - $(t,a)=(3.0,100)$ with price $88.6920$\n    - $(t,a)=(5.0,100)$ with price $79.8516$\n\n- Dataset B (noisy zero-coupon instruments resembling real-world quotes): Each instrument pays a single cash flow of $100$ at its maturity; the observed prices are as follows:\n  - Cash flow times (semiannual grid) and prices:\n    - $(0.5, 98.050)$, $(1.0, 96.000)$, $(1.5, 94.250)$, $(2.0, 92.200)$, $(2.5, 90.600)$,\n      $(3.0, 88.800)$, $(3.5, 86.900)$, $(4.0, 85.100)$, $(4.5, 83.650)$, $(5.0, 81.900)$,\n      $(5.5, 80.300)$, $(6.0, 78.600)$, $(6.5, 77.200)$, $(7.0, 75.500)$, $(7.5, 74.100)$,\n      $(8.0, 72.500)$, $(8.5, 71.300)$, $(9.0, 69.700)$, $(9.5, 67.800)$, $(10.0, 68.200)$.\n\n- Dataset C (edge case with a short-dated zero and a one-year coupon bond):\n  - Instrument 1: $(t,a)=(0.5,100)$ with price $98.000$.\n  - Instrument 2: coupon bond with semiannual coupons of amount $2.0$ at $t=0.5$ and $t=1.0$, plus principal $100.0$ at $t=1.0$, with observed price $102.500$.\n\nFor each dataset:\n1. Form the union of all distinct cash flow times $\\{t_i\\}$.\n2. Determine discount factors $\\{P(0,t_i)\\}$ that minimize the sum of squared pricing errors across the instruments, subject to $P(0,t_i) > 0$ for all $i$.\n3. Compute the forward rates $\\{f_i\\}$ on adjacent grid intervals using the formula above.\n4. Count the number of indices $i$ with $f_i < -10^{-10}$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the three integer results, in the order of datasets A, B, C, as a comma-separated list enclosed in square brackets (e.g., \"[0,1,2]\").", "solution": "The problem requires the construction of a discount curve from a set of observed financial instrument prices. This process, known as bootstrapping, is fundamental to quantitative finance. The validity of the constructed curve is to be checked for arbitrage opportunities, which are signaled by negative forward interest rates under the assumption of a non-negative short-rate economy. I will first validate the problem statement and then provide a complete solution.\n\nThe problem is subjected to rigorous validation.\n\n**Step 1: Extract Givens**\n-   The no-arbitrage price $V$ of an instrument with cash flows $\\{(t_k, a_k)\\}_{k=1}^K$ is $V = \\sum_{k=1}^K a_k P(0,t_k)$, where $P(0,t)$ is the time-$0$ discount factor for maturity $t$.\n-   The grid of maturities is $0 < t_1 < t_2 < \\dots < t_n$.\n-   The piecewise-constant forward rate on $[t_i, t_{i+1}]$ is $f_i = -\\frac{\\ln(P(0,t_{i+1})/P(0,t_i))}{t_{i+1}-t_i}$.\n-   An arbitrage signal is present if $f_i < -10^{-10}$.\n-   Task: For three datasets, find discount factors $P(0,t_i)$ on the union of cash flow times by minimizing the sum of squared pricing errors, subject to $P(0,t_i) > 0$. Then, count the number of negative forward rates.\n-   Datasets A, B, and C provide prices and cash flows for various instruments.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is scientifically grounded in the principles of no-arbitrage asset pricing. The formulation of the price as a linear combination of discount factors is standard theory. The use of least-squares optimization is a standard technique for bootstrapping a yield curve from market data, which may contain noise or be overdetermined. The definition of forward rates and the condition for arbitrage are also standard. The problem is well-posed; it asks for the solution to a constrained least-squares problem, for which robust algorithms exist. The data and objective are expressed in unambiguous, quantitative terms. No flaws from the checklist are identified. The problem is therefore deemed **valid**.\n\n**Methodology**\n\nFor each dataset, we must perform the following steps:\n\n1.  **Establish the Time Grid**: Let the set of all unique cash flow times from all instruments in a dataset be $\\{t_1, t_2, \\dots, t_n\\}$, sorted in increasing order, where $t_1 > 0$. These times form our grid. The unknown variables are the corresponding discount factors, which we denote by the vector $\\mathbf{p} = [p_1, p_2, \\dots, p_n]^T$, where $p_i = P(0, t_i)$.\n\n2.  **Formulate the Linear System**: Each instrument $j$ (for $j=1, \\dots, m$) has an observed price $V_j$ and a set of cash flows $\\{a_{jk}\\}$ at times $\\{t_{jk}\\}$. The pricing equation for instrument $j$ can be written as a linear equation in terms of the unknown discount factors $\\mathbf{p}$:\n    $$ \\sum_{i=1}^n C_{ji} p_i = V_j $$\n    where $C_{ji}$ is the cash flow amount of instrument $j$ at time $t_i$. This forms a system of $m$ linear equations in $n$ unknowns, which can be expressed in matrix form as:\n    $$ C\\mathbf{p} = \\mathbf{v} $$\n    Here, $C$ is the $m \\times n$ cash flow matrix, $\\mathbf{p}$ is the $n \\times 1$ vector of discount factors, and $\\mathbf{v}$ is the $m \\times 1$ vector of observed prices.\n\n3.  **Solve the Optimization Problem**: The problem is to find the vector $\\mathbf{p}$ that minimizes the sum of squared differences between the model prices $C\\mathbf{p}$ and the observed prices $\\mathbf{v}$, subject to the constraint that all discount factors are positive. This is a constrained optimization problem:\n    $$ \\min_{\\mathbf{p}} \\| C\\mathbf{p} - \\mathbf{v} \\|_2^2 \\quad \\text{subject to} \\quad \\mathbf{p} > 0 $$\n    This is a Non-Negatively Constrained Least Squares (NNLS) problem. We use the slightly weaker, but computationally standard, constraint $\\mathbf{p} \\ge 0$, as the provided data results in strictly positive solutions.\n\n4.  **Compute and Analyze Forward Rates**: After solving for $\\mathbf{p} = [p_1, \\dots, p_n]^T$, we compute the piecewise-constant forward rates $f_i$ for each adjacent interval $[t_i, t_{i+1}]$ for $i=1, \\dots, n-1$:\n    $$ f_i = -\\frac{\\ln(p_{i+1}/p_i)}{t_{i+1}-t_i} $$\n    A negative forward rate arises if $p_{i+1} > p_i$, which implies that money at a later time $t_{i+1}$ is worth more today than money at an earlier time $t_i$. This constitutes an arbitrage opportunity. We count the number of instances where $f_i < -10^{-10}$.\n\n**Application to Datasets**\n\n**Dataset A: Clean Zero-Coupon Instruments**\n-   The time grid is $\\{0.5, 1.0, 1.5, 2.0, 3.0, 5.0\\}$. There are $n=6$ time points and $m=6$ instruments.\n-   Each instrument is a zero-coupon bond paying $100$ at maturity. The system of equations is:\n    $$ 100 \\cdot P(0, t_i) = V_i \\quad \\text{for } i=1, \\dots, 6 $$\n-   This system is diagonal and is solved directly: $P(0, t_i) = V_i / 100$. The computed discount factors are: $0.985112$, $0.968500$, $0.948841$, $0.928642$, $0.886920$, $0.798516$.\n-   The sequence of discount factors is strictly decreasing, thus $P(0, t_{i+1}) < P(0, t_i)$ for all $i$. Consequently, $p_{i+1}/p_i < 1$, $\\ln(p_{i+1}/p_i) < 0$, and every forward rate $f_i$ will be positive.\n-   The number of negative forward rates is $0$.\n\n**Dataset B: Noisy Zero-Coupon Instruments**\n-   The time grid is the semiannual grid from $0.5$ to $10.0$ years, comprising $n=20$ points. There are $m=20$ instruments.\n-   As in Dataset A, the problem reduces to solving $P(0, t_i) = V_i / 100$ for each of the $20$ maturities.\n-   We inspect the sequence of prices $V_i$ to check if the corresponding discount factors are monotonically decreasing. The prices are: $98.050, 96.000, \\dots, 69.700, 67.800, 68.200$.\n-   An anomaly occurs at the end of the term structure. We have $V_{19} = 67.800$ for $t_{19} = 9.5$ and $V_{20} = 68.200$ for $t_{20} = 10.0$.\n-   This gives discount factors $p_{19} = P(0, 9.5) = 0.67800$ and $p_{20} = P(0, 10.0) = 0.68200$.\n-   Since $p_{20} > p_{19}$, the forward rate $f_{19}$ for the interval $[9.5, 10.0]$ will be negative:\n    $$ f_{19} = -\\frac{\\ln(0.68200 / 0.67800)}{10.0 - 9.5} \\approx -0.01176 $$\n    This value is less than $-10^{-10}$. All other adjacent prices are decreasing, so no other forward rates are negative.\n-   The number of negative forward rates is $1$.\n\n**Dataset C: Edge Case with Coupon Bond**\n-   The distinct cash flow times are $t_1=0.5$ and $t_2=1.0$, so $n=2$. There are $m=2$ instruments.\n-   The system of linear equations is:\n    $$\n    \\begin{pmatrix}\n    100 & 0 \\\\\n    2.0 & 102.0\n    \\end{pmatrix}\n    \\begin{pmatrix}\n    P(0, 0.5) \\\\\n    P(0, 1.0)\n    \\end{pmatrix}\n    =\n    \\begin{pmatrix}\n    98.000 \\\\\n    102.500\n    \\end{pmatrix}\n    $$\n-   This system is exactly determined. Solving the first equation gives $p_1 = P(0, 0.5) = 98.000 / 100 = 0.98000$.\n-   Substituting into the second equation: $2.0(0.98000) + 102.0 \\cdot p_2 = 102.500$, which yields $1.96 + 102.0 \\cdot p_2 = 102.500$.\n-   Solving for $p_2$ gives $p_2 = P(0, 1.0) = (102.500 - 1.96) / 102.0 = 100.54 / 102.0 \\approx 0.985686$.\n-   Here, $p_2 \\approx 0.985686 > p_1 = 0.98000$. This implies a negative forward rate over the interval $[0.5, 1.0]$:\n    $$ f_1 = -\\frac{\\ln(0.985686 / 0.98000)}{1.0 - 0.5} \\approx -0.01157 $$\n    This value is less than $-10^{-10}$.\n-   The number of negative forward rates is $1$.\n\nThe final counts are $0$, $1$, and $1$. The code will implement this logic systematically.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import nnls\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all datasets and print the result.\n    \"\"\"\n    \n    # Dataset A (clean zero-coupon instruments)\n    dataset_a = [\n        (98.5112, [(0.5, 100.0)]),\n        (96.8500, [(1.0, 100.0)]),\n        (94.8841, [(1.5, 100.0)]),\n        (92.8642, [(2.0, 100.0)]),\n        (88.6920, [(3.0, 100.0)]),\n        (79.8516, [(5.0, 100.0)]),\n    ]\n\n    # Dataset B (noisy zero-coupon instruments)\n    prices_b = [\n        98.050, 96.000, 94.250, 92.200, 90.600, 88.800, 86.900, 85.100, \n        83.650, 81.900, 80.300, 78.600, 77.200, 75.500, 74.100, 72.500, \n        71.300, 69.700, 67.800, 68.200\n    ]\n    times_b = np.arange(0.5, 10.1, 0.5)\n    dataset_b = [(price, [(time, 100.0)]) for price, time in zip(prices_b, times_b)]\n\n    # Dataset C (edge case with a short-dated zero and a one-year coupon bond)\n    dataset_c = [\n        (98.000, [(0.5, 100.0)]),\n        (102.500, [(0.5, 2.0), (1.0, 102.0)]),\n    ]\n    \n    test_cases = [dataset_a, dataset_b, dataset_c]\n    \n    results = []\n    for case in test_cases:\n        count = solve_dataset(case)\n        results.append(count)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef solve_dataset(instruments):\n    \"\"\"\n    Constructs discount curve for a given dataset and counts negative forward rates.\n\n    Args:\n        instruments: A list of tuples, where each tuple contains an instrument's\n                     price and a list of its cash flows (time, amount).\n\n    Returns:\n        An integer count of negative forward rates.\n    \"\"\"\n    \n    # 1. Establish the Time Grid\n    all_times = set()\n    for _, cash_flows in instruments:\n        for t, _ in cash_flows:\n            all_times.add(t)\n    \n    sorted_times = sorted(list(all_times))\n    time_to_idx = {t: i for i, t in enumerate(sorted_times)}\n    n_times = len(sorted_times)\n    n_instruments = len(instruments)\n\n    # 2. Formulate the Linear System\n    C = np.zeros((n_instruments, n_times))\n    v = np.zeros(n_instruments)\n\n    for j, (price, cash_flows) in enumerate(instruments):\n        v[j] = price\n        for t, amount in cash_flows:\n            if t in time_to_idx:\n                i = time_to_idx[t]\n                C[j, i] += amount\n\n    # 3. Solve the Optimization Problem (NNLS)\n    p, _ = nnls(C, v)\n\n    # 4. Compute and Analyze Forward Rates\n    negative_forward_count = 0\n    neg_threshold = -1.0e-10\n\n    for i in range(n_times - 1):\n        t_i = sorted_times[i]\n        t_i_plus_1 = sorted_times[i+1]\n        \n        p_i = p[i]\n        p_i_plus_1 = p[i+1]\n\n        # Avoid log(0) or division by zero. If p_i is zero, the forward rate\n        # would be infinite, not negative. With the given data, p_i > 0.\n        if p_i > 1e-12:  # Practical threshold for being non-zero\n            ratio = p_i_plus_1 / p_i\n            # If ratio is non-positive, log is undefined. Assume positive discount factors.\n            if ratio > 1e-12:\n                log_ratio = np.log(ratio)\n                delta_t = t_i_plus_1 - t_i\n                \n                # Ensure delta_t is not zero\n                if delta_t > 1e-12:\n                    forward_rate = -log_ratio / delta_t\n                    if forward_rate < neg_threshold:\n                        negative_forward_count += 1\n\n    return negative_forward_count\n\nsolve()\n```"}, {"introduction": "A yield curve is constructed from a finite set of bond maturities, yet we often require rates for periods that lie beyond our data. This exercise explores the common practice of extrapolation and its potential pitfalls. By applying a simple linear extrapolation to a given yield curve, you will calculate rates and forward rates beyond the observed range and discover how this seemingly straightforward assumption can lead to economically nonsensical results, a powerful lesson in model risk [@problem_id:2419260].", "id": "2419260", "problem": "A fixed-income analyst observes the following continuously compounded zero-coupon yields for default-free bonds at maturities $T$ (in years): $(T, z(T)) = (5, 0.0340)$, $(10, 0.0320)$, $(15, 0.0307)$, and $(20, 0.0113)$. No market quotes exist beyond $T = 20$. The analyst models the zero-yield curve $z(T)$ using piecewise linear interpolation in $T$ between the quoted nodes and, for $T$ beyond the last node, uses linear extrapolation that extends the slope of the last observed segment. Assume the price of a default-free zero-coupon bond maturing at time $T$ is $P(T) = \\exp(-T\\,z(T))$.\n\nUsing this interpolation and extrapolation convention:\n- Extrapolate $z(25)$.\n- Then compute the continuously compounded annualized $5$-year forward rate spanning from $T = 20$ to $T = 25$ implied by these zero rates.\n\nExpress the final forward rate as a decimal per year under continuous compounding, and round your answer to four significant figures.", "solution": "The problem will first be subjected to a rigorous validation procedure before any attempt at a solution is made.\n\nProblem Validation\n\nStep 1: Extract Givens\nThe explicitly stated givens are as follows:\n- Data points for continuously compounded zero-coupon yields $z(T)$ at maturity $T$ (in years): $(T, z(T)) = (5, 0.0340)$, $(10, 0.0320)$, $(15, 0.0307)$, and $(20, 0.0113)$.\n- The yield curve $z(T)$ is modeled by piecewise linear interpolation in $T$ between the given nodes.\n- For maturities $T > 20$, the model uses linear extrapolation that extends the slope of the last observed segment.\n- The price of a default-free zero-coupon bond maturing at time $T$ is given by the formula $P(T) = \\exp(-T\\,z(T))$.\n- The tasks are to:\n    1. Extrapolate the yield for a $25$-year maturity, $z(25)$.\n    2. Compute the continuously compounded annualized $5$-year forward rate, $f(20, 25)$, spanning from $T = 20$ to $T = 25$.\n- The final forward rate must be expressed as a decimal rounded to four significant figures.\n\nStep 2: Validate Using Extracted Givens\nThe problem is assessed against the criteria for validity.\n- **Scientifically Grounded**: The problem is based on standard, fundamental concepts in quantitative finance and fixed-income analysis. The definitions of continuously compounded yield, bond pricing, forward rates, and piecewise linear interpolation/extrapolation are all well-established and mathematically sound.\n- **Well-Posed**: The problem is clearly stated. All necessary data and modeling conventions (interpolation and extrapolation rules) are provided. The questions are mathematically precise and lead to a unique, determinable solution.\n- **Objective**: The language is formal and unambiguous. It presents a clear computational task without subjective or speculative elements.\n- **Completeness and Consistency**: The problem is self-contained. The data and methods are sufficient to perform the required calculations. There are no internal contradictions. The specified extrapolation method (linear continuation of the last segment's slope) is a common, if simplistic, technique in practice.\n\nStep 3: Verdict and Action\nThe problem is deemed **valid**. It is a standard exercise in applying interpolation and extrapolation techniques to a yield curve and deriving financial instruments from it. I will proceed with the solution.\n\nSolution\n\nThe problem requires a two-step calculation. First, the zero-coupon yield for a $25$-year maturity, $z(25)$, must be determined using the specified extrapolation method. Second, this extrapolated yield is used to compute the $5$-year forward rate from year $20$ to year $25$.\n\nThe extrapolation for $T > 20$ is linear and uses the slope of the last observed segment, which is the segment between $T_3 = 15$ years and $T_4 = 20$ years. The corresponding yields are $z(T_3) = 0.0307$ and $z(T_4) = 0.0113$.\n\nThe slope, $m$, of the yield curve over this final segment is calculated as:\n$$\nm = \\frac{z(T_4) - z(T_3)}{T_4 - T_3} = \\frac{0.0113 - 0.0307}{20 - 15} = \\frac{-0.0194}{5} = -0.00388\n$$\nThe extrapolation is a linear function of $T$ for $T \\ge 20$, with its origin at the point $(T_4, z(T_4))$ and slope $m$. The formula for the extrapolated yield $z(T)$ is:\n$$\nz(T) = z(20) + m \\cdot (T - 20)\n$$\nWe apply this formula to find $z(25)$:\n$$\nz(25) = z(20) + m \\cdot (25 - 20) = 0.0113 + (-0.00388) \\cdot 5 = 0.0113 - 0.0194 = -0.0081\n$$\nThe extrapolated yield $z(25)$ is $-0.0081$. A negative yield, while unusual, is a direct and valid consequence of the specified linear extrapolation model applied to the given data. This model is known to produce such non-physical results when the yield curve has significant curvature.\n\nNext, we compute the continuously compounded annualized forward rate, $f(T_1, T_2)$, spanning the period from $T_1$ to $T_2$. The no-arbitrage condition relating zero-coupon bond prices and forward rates is:\n$$\nP(T_2) = P(T_1) \\cdot \\exp(-(T_2 - T_1) f(T_1, T_2))\n$$\nSubstituting the given bond price formula $P(T) = \\exp(-T\\,z(T))$:\n$$\n\\exp(-T_2 z(T_2)) = \\exp(-T_1 z(T_1)) \\cdot \\exp(-(T_2 - T_1) f(T_1, T_2))\n$$\nTaking the natural logarithm of both sides gives a linear relationship:\n$$\n-T_2 z(T_2) = -T_1 z(T_1) - (T_2 - T_1) f(T_1, T_2)\n$$\nSolving for the forward rate $f(T_1, T_2)$:\n$$\nf(T_1, T_2) = \\frac{T_2 z(T_2) - T_1 z(T_1)}{T_2 - T_1}\n$$\nWe need to calculate the $5$-year forward rate from $T_1 = 20$ to $T_2 = 25$. We have the required values: $z(20) = 0.0113$ and our calculated $z(25) = -0.0081$.\nSubstituting these values into the forward rate formula:\n$$\nf(20, 25) = \\frac{25 \\cdot z(25) - 20 \\cdot z(20)}{25 - 20} = \\frac{25 \\cdot (-0.0081) - 20 \\cdot (0.0113)}{5}\n$$\nWe compute the numerator:\n$$\n25 \\cdot (-0.0081) = -0.2025\n$$\n$$\n20 \\cdot (0.0113) = 0.2260\n$$\n$$\n\\text{Numerator} = -0.2025 - 0.2260 = -0.4285\n$$\nNow, we compute the forward rate:\n$$\nf(20, 25) = \\frac{-0.4285}{5} = -0.0857\n$$\nThe problem requires the answer to be rounded to four significant figures. The calculated value $-0.0857$ has exactly three significant figures ($8$, $5$, $7$). To express this with four significant figures, a trailing zero must be added. Thus, the final answer is $-0.08570$. This negative forward rate is, again, a logical consequence of the simplistic extrapolation model generating a negative yield.", "answer": "$$\n\\boxed{-0.08570}\n$$"}, {"introduction": "Building a yield curve is the first step; understanding its sensitivity to market price movements is the mark of an advanced practitioner. This final practice moves from construction to analysis, guiding you through the derivation and implementation of a key tool in fixed-income risk management: the Jacobian matrix of sensitivities. By applying principles of calculus to the bootstrapping equations, you will compute exactly how each zero-coupon rate, $z_i$, responds to a small change in an input bond price, $P_j$, a measure essential for hedging and sophisticated risk analysis [@problem_id:2377880].", "id": "2377880", "problem": "You are given a family of fixed-income instruments used to bootstrap a continuously compounded zero-coupon yield curve at a finite set of maturities. Let there be $n$ instruments with increasing payment times $\\{t_1,\\dots,t_n\\}$ in years, and let instrument $j$ ($1 \\leq j \\leq n$) pay cash flows on $\\{t_1,\\dots,t_j\\}$. Denote the annualized coupon rate of instrument $j$ by $c_j$ (expressed as a decimal, not a percentage) and the clean price by $P_j$. Assume notional $1$ for all instruments, and that coupon amounts over an accrual interval equal the coupon rate times the year fraction of that interval. Specifically, define the accrual fractions by $\\Delta t_1 = t_1 - 0$ and $\\Delta t_k = t_k - t_{k-1}$ for all $k \\geq 2$. Then the cash flow of instrument $j$ at time $t_k$ for $k \\leq j$ is $c_j \\,\\Delta t_k$, plus an additional principal repayment of $1$ at $t_j$. Denote the continuously compounded zero rate at $t_k$ by $z_k$. Under absence of arbitrage, the clean price of instrument $j$ is given by the discounting relation\n$$\nP_j \\;=\\; \\sum_{k=1}^{j} \\left(c_j\\,\\Delta t_k + \\mathbf{1}_{\\{k=j\\}}\\right)\\exp\\!\\left(-z_k\\,t_k\\right),\n$$\nwhere $\\mathbf{1}_{\\{k=j\\}}$ is the indicator equal to $1$ if $k=j$ and $0$ otherwise.\n\nDefine the vector of unknown zero rates $\\mathbf{z} = (z_1,\\dots,z_n)^\\top$ and the vector of observed prices $\\mathbf{P}=(P_1,\\dots,P_n)^\\top$. Define the system of $n$ nonlinear equations in $n$ unknowns as\n$$\nF_j(\\mathbf{z},\\mathbf{P}) \\;=\\; \\sum_{k=1}^{j} \\left(c_j\\,\\Delta t_k + \\mathbf{1}_{\\{k=j\\}}\\right)\\exp\\!\\left(-z_k\\,t_k\\right) \\;-\\; P_j \\;=\\; 0,\\quad j=1,\\dots,n.\n$$\nBy construction of the instruments, this system is lower triangular in the sense that equation $j$ only involves $\\{z_1,\\dots,z_j\\}$.\n\nTask: Starting strictly from the arbitrage-free pricing relation above and the definition of the system $F_j(\\mathbf{z},\\mathbf{P})=0$, derive an algorithm to compute the Jacobian matrix of sensitivities of the bootstrapped zero rates with respect to the input prices,\n$$\nJ \\;=\\; \\left[\\frac{\\partial z_i}{\\partial P_j}\\right]_{i,j=1}^n.\n$$\nYour derivation must proceed from first principles by differentiating the defining equations and exploiting the lower-triangular structure, without invoking any pre-packaged sensitivity formulas. Then implement the derived algorithm as a complete, runnable program that performs the following for each test case in the provided test suite:\n\n1. Construct the cash flow matrix implied by $\\{t_k\\}$ and $\\{c_j\\}$ using the accrual convention above.\n2. Compute synthetic clean prices $\\{P_j\\}$ using a provided vector of “true” zero rates $\\{z_k^{\\text{true}}\\}$ via the pricing relation.\n3. Bootstrap $\\{z_k\\}$ from $\\{P_j\\}$ using the triangular structure.\n4. Assemble the appropriate system resulting from the implicit differentiation of $F_j(\\mathbf{z},\\mathbf{P})=0$ to solve for the full Jacobian $J$.\n5. Return, for each test case, the entire Jacobian flattened in row-major order as a list of real numbers rounded to $8$ decimal places.\n\nUnits and conventions:\n- All times $\\{t_k\\}$ are in years.\n- All rates $\\{c_j\\}$ and $\\{z_k\\}$ are decimals (for example, $0.02$ means two percent).\n- Discounting uses continuous compounding, that is $\\exp(-z_k\\,t_k)$.\n\nTest suite:\n- Case A (general semiannual coupon structure, “happy path”): $n=4$, $t=[0.5,1.0,1.5,2.0]$, $c=[0.0,0.02,0.025,0.03]$, $z^{\\text{true}}=[0.018,0.020,0.0215,0.022]$.\n- Case B (all zero-coupon bonds, diagonal structure boundary): $n=3$, $t=[0.25,0.5,1.0]$, $c=[0.0,0.0,0.0]$, $z^{\\text{true}}=[0.015,0.016,0.0175]$.\n- Case C (very small coupons, numerically delicate but well-posed): $n=3$, $t=[1.0,2.0,3.0]$, $c=[0.0001,0.0001,0.0001]$, $z^{\\text{true}}=[0.03,0.031,0.032]$.\n\nFinal output format:\n- Your program should produce a single line of output containing a list of three elements, one for each test case in the order A, B, C.\n- Each element must itself be a list of the Jacobian entries $\\left[\\frac{\\partial z_i}{\\partial P_j}\\right]$ flattened in row-major order, rounded to $8$ decimal places.\n- Concretely, if a test case has dimension $n$, output a list of length $n\\times n$ containing $J_{1,1},J_{1,2},\\dots,J_{1,n},J_{2,1},\\dots,J_{n,n}$ in that order.\n- The single printed line must be a standard Python-style nested list literal, for example, $\\texttt{[[0.12345678,0.0,\\dots],[\\dots],[\\dots]]}$, with values rounded to $8$ decimal places.", "solution": "The problem as stated is scientifically sound, well-posed, and objective. It is grounded in the fundamental principles of arbitrage-free pricing and the term structure of interest rates, a core topic in computational finance. All necessary data and definitions are provided, and the problem structure leads to a unique, meaningful solution. There are no logical contradictions, unrealistic assumptions, or ambiguities. I will therefore proceed with a complete solution.\n\nThe objective is to derive an algorithm to compute the Jacobian matrix of bootstrapped zero rates with respect to the input instrument prices, defined as $J = \\left[\\frac{\\partial z_i}{\\partial P_j}\\right]_{i,j=1}^n$. The derivation will be based on the implicit function theorem applied to the system of non-linear pricing equations.\n\nThe system of $n$ equations relating the prices $\\mathbf{P}=(P_1, \\dots, P_n)^\\top$ to the zero rates $\\mathbf{z}=(z_1, \\dots, z_n)^\\top$ is given by:\n$$\nF_j(\\mathbf{z}, \\mathbf{P}) = \\sum_{k=1}^{j} \\left(c_j\\,\\Delta t_k + \\mathbf{1}_{\\{k=j\\}}\\right)\\exp(-z_k\\,t_k) - P_j = 0, \\quad \\text{for } j=1, \\dots, n.\n$$\nHere, the zero rates $\\mathbf{z}$ are implicitly defined as functions of the market prices $\\mathbf{P}$. To find the sensitivity of $\\mathbf{z}$ with respect to $\\mathbf{P}$, we consider the total differential of the system of equations $\\mathbf{F}(\\mathbf{z}(\\mathbf{P}), \\mathbf{P}) = \\mathbf{0}$. For each component $F_j$, we have:\n$$\ndF_j = \\sum_{i=1}^{n} \\frac{\\partial F_j}{\\partial z_i} dz_i + \\sum_{m=1}^{n} \\frac{\\partial F_j}{\\partial P_m} dP_m = 0.\n$$\nThis can be expressed in matrix form using Jacobian matrices:\n$$\n\\frac{\\partial \\mathbf{F}}{\\partial \\mathbf{z}} d\\mathbf{z} + \\frac{\\partial \\mathbf{F}}{\\partial \\mathbf{P}} d\\mathbf{P} = \\mathbf{0}.\n$$\nLet us denote the Jacobian matrix of the system with respect to the rates as $J_z = \\frac{\\partial \\mathbf{F}}{\\partial \\mathbf{z}}$ and with respect to the prices as $J_P = \\frac{\\partial \\mathbf{F}}{\\partial \\mathbf{P}}$. The equation becomes:\n$$\nJ_z d\\mathbf{z} + J_P d\\mathbf{P} = \\mathbf{0}.\n$$\nThe desired Jacobian, $J = \\frac{\\partial \\mathbf{z}}{\\partial \\mathbf{P}}$, relates the differentials $d\\mathbf{z}$ and $d\\mathbf{P}$ via $d\\mathbf{z} = J d\\mathbf{P}$. Substituting this into the previous equation yields:\n$$\nJ_z (J d\\mathbf{P}) + J_P d\\mathbf{P} = \\mathbf{0} \\implies (J_z J + J_P) d\\mathbf{P} = \\mathbf{0}.\n$$\nSince this relation must hold for any infinitesimal change in prices $d\\mathbf{P}$, the matrix in parentheses must be the zero matrix.\n$$\nJ_z J + J_P = \\mathbf{0} \\implies J = -(J_z)^{-1} J_P.\n$$\nNext, we determine the matrices $J_z$ and $J_P$.\nThe partial derivative of $F_j$ with respect to a price $P_m$ is non-zero only if $m=j$:\n$$\n(J_P)_{jm} = \\frac{\\partial F_j}{\\partial P_m} = \\frac{\\partial}{\\partial P_m} \\left( \\dots - P_j \\right) = -\\delta_{jm},\n$$\nwhere $\\delta_{jm}$ is the Kronecker delta. Thus, $J_P$ is the negative identity matrix, $J_P = -I$.\n\nSubstituting $J_P=-I$ into the expression for $J$ gives a simplified result:\n$$\nJ = -(J_z)^{-1}(-I) = (J_z)^{-1}.\n$$\nThe problem is now reduced to computing the matrix $J_z = \\frac{\\partial \\mathbf{F}}{\\partial \\mathbf{z}}$ and finding its inverse. The elements of $J_z$ are $(J_z)_{ji} = \\frac{\\partial F_j}{\\partial z_i}$.\nFrom the definition of $F_j$, the rate $z_i$ only appears in the formula if $i \\le j$. Consequently, $\\frac{\\partial F_j}{\\partial z_i} = 0$ for $i > j$, which confirms that $J_z$ is a lower triangular matrix.\n\nFor $i \\le j$, the derivative is:\n$$\n(J_z)_{ji} = \\frac{\\partial F_j}{\\partial z_i} = \\frac{\\partial}{\\partial z_i} \\left[ \\left(c_j\\,\\Delta t_i + \\mathbf{1}_{\\{i=j\\}}\\right)\\exp(-z_i\\,t_i) \\right] = -\\left(c_j\\,\\Delta t_i + \\mathbf{1}_{\\{i=j\\}}\\right) t_i \\exp(-z_i\\,t_i).\n$$\nSpecifically, the elements of $J_z$ are:\n- Diagonal elements ($i=j$): $(J_z)_{jj} = -(c_j \\Delta t_j + 1) t_j \\exp(-z_j t_j)$.\n- Off-diagonal elements ($i<j$): $(J_z)_{ji} = -c_j \\Delta t_i t_i \\exp(-z_i t_i)$.\n\nThe final algorithm is as follows:\n1.  Given a set of instrument prices $\\{P_j\\}_{j=1}^n$, first bootstrap the zero rates $\\{z_k\\}_{k=1}^n$. This is done iteratively. For $j=1, \\dots, n$, solve for $z_j$ using the known rates $z_1, \\dots, z_{j-1}$:\n    $$\n    z_j = -\\frac{1}{t_j} \\ln \\left( \\frac{P_j - \\sum_{k=1}^{j-1} c_j \\Delta t_k \\exp(-z_k t_k)}{c_j \\Delta t_j + 1} \\right).\n    $$\n2.  Using the bootstrapped rates $\\mathbf{z}$, assemble the lower triangular matrix $J_z$ according to the formulas derived above. The derivatives must be evaluated at the point $(\\mathbf{z}, \\mathbf{P})$ that satisfies the pricing equations.\n3.  Compute the desired Jacobian $J$ by inverting $J_z$. Since $J_z$ is lower triangular, its inverse $J = (J_z)^{-1}$ is also lower triangular and can be computed efficiently by solving the system $J_z J = I$ using forward substitution. This is numerically stable and efficient, as the diagonal elements $(J_z)_{jj}$ are non-zero for any $t_j > 0$.\n\nThe implementation will first compute synthetic prices from a given set of `true` zero rates, then bootstrap the rates from these prices (which should recover the `true` rates, up to numerical precision), and finally compute the Jacobian using these bootstrapped rates.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_triangular\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n\n    def compute_jacobian(t, c, z_true):\n        \"\"\"\n        Derives and computes the Jacobian of zero rates w.r.t. instrument prices.\n\n        Args:\n            t (list): Payment times in years.\n            c (list): Annualized coupon rates (decimal).\n            z_true (list): True zero rates for generating synthetic prices.\n\n        Returns:\n            list: Flattened Jacobian matrix in row-major order, rounded to 8 decimal places.\n        \"\"\"\n        n = len(t)\n        t_arr = np.array(t, dtype=float)\n        c_arr = np.array(c, dtype=float)\n        z_true_arr = np.array(z_true, dtype=float)\n\n        # Step 0: Pre-computation of accrual fractions (delta_t)\n        delta_t = np.zeros(n)\n        delta_t[0] = t_arr[0]\n        if n > 1:\n            delta_t[1:] = t_arr[1:] - t_arr[:-1]\n\n        # Step 2: Compute synthetic clean prices P_j from z_true\n        prices = np.zeros(n)\n        for j in range(n):\n            price = 0.0\n            # Sum of present values of coupons before maturity\n            for k in range(j):\n                price += c_arr[j] * delta_t[k] * np.exp(-z_true_arr[k] * t_arr[k])\n            # Add PV of final payment (last coupon + principal)\n            price += (c_arr[j] * delta_t[j] + 1.0) * np.exp(-z_true_arr[j] * t_arr[j])\n            prices[j] = price\n\n        # Step 3: Bootstrap zero rates z_k from prices P_j\n        # This step recovers z_true and provides the point for derivative evaluation.\n        z_boot = np.zeros(n)\n        for j in range(n):\n            known_pv_of_coupons = 0.0\n            for k in range(j):\n                known_pv_of_coupons += c_arr[j] * delta_t[k] * np.exp(-z_boot[k] * t_arr[k])\n            \n            final_cash_flow = c_arr[j] * delta_t[j] + 1.0\n            \n            # From P_j - known_pv = final_cash_flow * exp(-z_j * t_j)\n            arg_of_log = (prices[j] - known_pv_of_coupons) / final_cash_flow\n            \n            # Handle potential numerical issues for log\n            if arg_of_log <= 0:\n                raise ValueError(f\"Invalid argument for log at step j={j}: {arg_of_log}\")\n\n            z_boot[j] = -np.log(arg_of_log) / t_arr[j]\n\n        # Step 4a: Assemble the matrix J_z = dF/dz\n        J_z = np.zeros((n, n))\n        for j in range(n):\n            for i in range(j + 1):\n                discount_factor = np.exp(-z_boot[i] * t_arr[i])\n                if i < j:\n                    # Off-diagonal element (J_z)_ji\n                    # Derivative of F_j w.r.t z_i where i < j\n                    J_z[j, i] = -c_arr[j] * delta_t[i] * t_arr[i] * discount_factor\n                else:  # i == j\n                    # Diagonal element (J_z)_jj\n                    # Derivative of F_j w.r.t z_j\n                    final_payment = c_arr[j] * delta_t[j] + 1.0\n                    J_z[j, j] = -final_payment * t_arr[j] * discount_factor\n\n        # Step 4b: Solve for the Jacobian J = (J_z)^-1\n        # We are solving J_z @ J = I, where I is the identity matrix.\n        # solve_triangular is efficient for this as J_z is lower-triangular.\n        identity_matrix = np.identity(n)\n        J = solve_triangular(J_z, identity_matrix, lower=True)\n\n        # Step 5: Return flattened Jacobian, rounded to 8 decimal places.\n        return np.round(J.flatten(order='C'), 8).tolist()\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: General semiannual coupon structure\n        {'t': [0.5, 1.0, 1.5, 2.0], 'c': [0.0, 0.02, 0.025, 0.03], 'z_true': [0.018, 0.020, 0.0215, 0.022]},\n        # Case B: All zero-coupon bonds\n        {'t': [0.25, 0.5, 1.0], 'c': [0.0, 0.0, 0.0], 'z_true': [0.015, 0.016, 0.0175]},\n        # Case C: Very small coupons\n        {'t': [1.0, 2.0, 3.0], 'c': [0.0001, 0.0001, 0.0001], 'z_true': [0.03, 0.031, 0.032]}\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_jacobian(**case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The string representation is formatted to remove spaces for a compact output.\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n```"}]}