{"hands_on_practices": [{"introduction": "The efficient frontier presents a menu of optimal risk-return tradeoffs, but the question remains: which portfolio is best for a given individual? This first practice guides you through a direct calculation to answer that question, connecting an investor's personal risk aversion to their unique optimal portfolio [@problem_id:2383572]. You will apply the celebrated Merton's portfolio rule to see how the abstract concept of a utility parameter, $\\gamma$, translates into a concrete asset allocation.", "id": "2383572", "problem": "An investor with Constant Relative Risk Aversion (CRRA) preferences has utility over terminal wealth given by $U(W) = \\frac{W^{1-\\gamma}}{1-\\gamma}$ with risk aversion parameter $\\gamma = 3$. The investor operates in continuous time over a horizon of length $T = 1$, with initial wealth $W_{0} &gt; 0$, and can invest in two risky assets and a risk-free asset. The risk-free asset grows at a continuously compounded rate $r = 0.02$. The risky assets follow correlated Geometric Brownian Motion (GBM) dynamics:\n$$\n\\frac{dS_{i}(t)}{S_{i}(t)} = \\mu_{i}\\,dt + \\sigma_{i}\\,dB_{i}(t), \\quad i \\in \\{1,2\\},\n$$\nwhere $B_{1}(t)$ and $B_{2}(t)$ are standard Brownian motions with instantaneous correlation $\\rho = 0.25$. The parameters are:\n- Expected returns $\\mu_{1} = 0.06$ and $\\mu_{2} = 0.09$,\n- Volatilities $\\sigma_{1} = 0.2$ and $\\sigma_{2} = 0.3$,\n- Correlation $\\rho = 0.25$,\n- Risk-free rate $r = 0.02$,\n- Risk aversion $\\gamma = 3$.\n\nThe investor chooses constant portfolio weights $w = (w_{1}, w_{2})$ in the risky assets over $[0,1]$, investing the remaining fraction $1 - w_{1} - w_{2}$ in the risk-free asset. Assume there are no constraints on short sales or borrowing.\n\nDetermine the optimal risky-asset weight vector $w^{\\star} = (w_{1}^{\\star}, w_{2}^{\\star})$ that maximizes $\\mathbb{E}[U(W_{1})]$. Express your final answer as exact values. No rounding is required.", "solution": "The problem has been validated and is a well-posed, scientifically grounded problem in quantitative finance. It is a standard application of Merton's portfolio theory. I will proceed with the solution.\n\nThe investor's objective is to maximize the expected utility of terminal wealth, $\\mathbb{E}[U(W_{T})]$, for a power utility function (CRRA) of the form $U(W) = \\frac{W^{1-\\gamma}}{1-\\gamma}$, with a coefficient of relative risk aversion $\\gamma$. The investment opportunity set is assumed to be constant. In this continuous-time framework, the optimal allocation to the risky assets, denoted by the vector $w^{\\star}$, is constant and given by the Merton's portfolio rule:\n$$ w^{\\star} = \\frac{1}{\\gamma} \\Sigma^{-1} (\\mu - r \\mathbf{1}) $$\nHere, $w^{\\star}$ is the column vector of optimal weights for the risky assets, $\\gamma$ is the risk aversion parameter, $\\Sigma$ is the covariance matrix of the risky asset returns, $\\mu$ is the vector of expected returns for the risky assets, $r$ is the risk-free rate, and $\\mathbf{1}$ is a column vector of ones with appropriate dimension.\n\nThe parameters provided in the problem are:\n- Risk aversion parameter: $\\gamma = 3$\n- Risk-free rate: $r = 0.02$\n- Expected returns vector: $\\mu = \\begin{pmatrix} \\mu_{1} \\\\ \\mu_{2} \\end{pmatrix} = \\begin{pmatrix} 0.06 \\\\ 0.09 \\end{pmatrix}$\n- Volatilities: $\\sigma_{1} = 0.2$, $\\sigma_{2} = 0.3$\n- Correlation: $\\rho = 0.25$\n\nFirst, we compute the vector of excess returns (risk premia), $\\mu - r \\mathbf{1}$:\n$$ \\mu - r \\mathbf{1} = \\begin{pmatrix} 0.06 - 0.02 \\\\ 0.09 - 0.02 \\end{pmatrix} = \\begin{pmatrix} 0.04 \\\\ 0.07 \\end{pmatrix} $$\n\nNext, we construct the covariance matrix $\\Sigma$ of the risky asset returns. The elements of $\\Sigma$ are $\\Sigma_{ij} = \\sigma_i \\sigma_j \\rho_{ij}$, where $\\rho_{11} = \\rho_{22} = 1$ and $\\rho_{12} = \\rho_{21} = \\rho = 0.25$.\nThe diagonal elements are the variances:\n$$ \\Sigma_{11} = \\sigma_{1}^{2} = (0.2)^{2} = 0.04 $$\n$$ \\Sigma_{22} = \\sigma_{2}^{2} = (0.3)^{2} = 0.09 $$\nThe off-diagonal elements are the covariances:\n$$ \\Sigma_{12} = \\Sigma_{21} = \\sigma_{1} \\sigma_{2} \\rho = (0.2)(0.3)(0.25) = (0.06)(0.25) = 0.015 $$\nThus, the covariance matrix is:\n$$ \\Sigma = \\begin{pmatrix} 0.04 & 0.015 \\\\ 0.015 & 0.09 \\end{pmatrix} $$\n\nTo apply the formula, we need the inverse of $\\Sigma$. For a $2 \\times 2$ matrix $\\begin{pmatrix} a & b \\\\ c & d \\end{pmatrix}$, its inverse is given by $\\frac{1}{ad-bc} \\begin{pmatrix} d & -b \\\\ -c & a \\end{pmatrix}$.\nFirst, we find the determinant of $\\Sigma$:\n$$ \\det(\\Sigma) = (0.04)(0.09) - (0.015)(0.015) = 0.0036 - 0.000225 = 0.003375 $$\nThe inverse matrix $\\Sigma^{-1}$ is then:\n$$ \\Sigma^{-1} = \\frac{1}{0.003375} \\begin{pmatrix} 0.09 & -0.015 \\\\ -0.015 & 0.04 \\end{pmatrix} $$\n\nNow, we substitute all parts into the Merton's formula for the optimal weight vector $w^{\\star} = \\begin{pmatrix} w_{1}^{\\star} \\\\ w_{2}^{\\star} \\end{pmatrix}$:\n$$ w^{\\star} = \\frac{1}{3} \\left( \\frac{1}{0.003375} \\begin{pmatrix} 0.09 & -0.015 \\\\ -0.015 & 0.04 \\end{pmatrix} \\right) \\begin{pmatrix} 0.04 \\\\ 0.07 \\end{pmatrix} $$\nLet us first compute the product $\\Sigma^{-1} (\\mu - r \\mathbf{1})$:\n$$ \\Sigma^{-1} (\\mu - r \\mathbf{1}) = \\frac{1}{0.003375} \\begin{pmatrix} (0.09)(0.04) - (0.015)(0.07) \\\\ -(0.015)(0.04) + (0.04)(0.07) \\end{pmatrix} $$\n$$ \\Sigma^{-1} (\\mu - r \\mathbf{1}) = \\frac{1}{0.003375} \\begin{pmatrix} 0.0036 - 0.00105 \\\\ -0.0006 + 0.0028 \\end{pmatrix} = \\frac{1}{0.003375} \\begin{pmatrix} 0.00255 \\\\ 0.0022 \\end{pmatrix} $$\nNow we incorporate the risk aversion term $\\frac{1}{\\gamma} = \\frac{1}{3}$:\n$$ w^{\\star} = \\frac{1}{3} \\begin{pmatrix} \\frac{0.00255}{0.003375} \\\\ \\frac{0.0022}{0.003375} \\end{pmatrix} = \\begin{pmatrix} \\frac{0.00255}{0.010125} \\\\ \\frac{0.0022}{0.010125} \\end{pmatrix} $$\nTo obtain exact values, we convert these to fractions:\n$$ w_{1}^{\\star} = \\frac{0.00255}{0.010125} = \\frac{2550}{10125} $$\nTo simplify this fraction, we find the greatest common divisor of the numerator and denominator.\n$$ \\frac{2550}{10125} = \\frac{2 \\times 3 \\times 5^{2} \\times 17}{3^{4} \\times 5^{3}} = \\frac{2 \\times 17}{3^{3} \\times 5} = \\frac{34}{27 \\times 5} = \\frac{34}{135} $$\nFor the second weight:\n$$ w_{2}^{\\star} = \\frac{0.0022}{0.010125} = \\frac{2200}{10125} $$\nSimplifying this fraction:\n$$ \\frac{2200}{10125} = \\frac{2^{3} \\times 5^{2} \\times 11}{3^{4} \\times 5^{3}} = \\frac{2^{3} \\times 11}{3^{4} \\times 5} = \\frac{8 \\times 11}{81 \\times 5} = \\frac{88}{405} $$\nSo, the optimal weight vector is $w^{\\star} = \\begin{pmatrix} \\frac{34}{135} \\\\ \\frac{88}{405} \\end{pmatrix}$. This corresponds to an investment of approximately $25.2\\%$ in asset $1$ and $21.7\\%$ in asset $2$. The remaining fraction, $1 - \\frac{34}{135} - \\frac{88}{405} = 1 - \\frac{102}{405} - \\frac{88}{405} = 1 - \\frac{190}{405} = \\frac{215}{405} = \\frac{43}{81} \\approx 53.1\\%$, is invested in the risk-free asset.", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{34}{135} & \\frac{88}{405}\n\\end{pmatrix}\n}\n$$"}, {"introduction": "Beyond the basic model, real-world portfolio management involves satisfying additional constraints, such as tracking a market benchmark's risk profile (its beta). This hands-on coding task requires you to move beyond simple variance minimization by incorporating a target-beta constraint into the optimization problem [@problem_id:2383619]. You will translate the analytical solution from the method of Lagrange multipliers into a robust program, a core skill for any quantitative analyst.", "id": "2383619", "problem": "Write a complete, runnable program that computes, for each specified test case, the minimum-variance portfolio subject to two equality constraints: the portfolio’s beta with respect to the market equals $1$, and the full-investment budget constraint holds (weights sum to $1$). Use the following foundational definitions and facts as the starting point for your reasoning and algorithm design.\n\n- For $N$ risky assets with return vector $R \\in \\mathbb{R}^N$, covariance matrix $\\Sigma \\in \\mathbb{R}^{N \\times N}$ that is symmetric positive definite, and a market return $R_m$, the variance of a portfolio with weight vector $w \\in \\mathbb{R}^N$ is $w^{\\top} \\Sigma w$.\n- For each asset $i$, the beta with respect to the market is $\\beta_i = \\frac{\\operatorname{Cov}(R_i, R_m)}{\\operatorname{Var}(R_m)}$. Given the vector $c \\in \\mathbb{R}^N$ whose entries are $c_i = \\operatorname{Cov}(R_i, R_m)$ and the market variance $\\sigma_m^2 = \\operatorname{Var}(R_m)$, the asset beta vector is $\\beta = c / \\sigma_m^2$ (element-wise division).\n- The portfolio beta is $\\beta_p = \\beta^{\\top} w$.\n\nYour task is to compute, for each test instance:\n- A portfolio weight vector $w \\in \\mathbb{R}^N$ that minimizes $w^{\\top} \\Sigma w$ subject to $1^{\\top} w = 1$ and $\\beta^{\\top} w = 1$, where $1$ denotes the $N$-dimensional vector of ones.\n- The resulting portfolio variance $w^{\\top} \\Sigma w$.\n- The achieved portfolio beta $\\beta^{\\top} w$.\n- The sum of weights $1^{\\top} w$.\n\nFeasibility and degeneracy requirements and edge cases:\n- If the two constraints are linearly independent (that is, the two columns $1$ and $\\beta$ are linearly independent), solve the two-constraint minimum-variance problem.\n- If the two constraints are linearly dependent, there are two sub-cases:\n    - If $\\beta = k \\cdot 1$ for some scalar $k$ and $k = 1$, then the beta constraint is identical to the budget constraint. In this case, compute the minimum-variance portfolio subject to $1^{\\top} w = 1$ only.\n    - If $\\beta = k \\cdot 1$ for some scalar $k$ and $k \\neq 1$, then the system $1^{\\top} w = 1$ and $\\beta^{\\top} w = 1$ is infeasible. In this case, return an empty list for that test case.\n\nNumerical details:\n- For each test case, return a list containing the asset weights $w_1, \\dots, w_N$, followed by the portfolio variance $w^{\\top} \\Sigma w$, the achieved portfolio beta $\\beta^{\\top} w$, and the sum of weights $1^{\\top} w$. Round every reported number to $6$ decimal places.\n- If a test case is infeasible (as defined above), return an empty list for that test case.\n- Angles are not involved. There are no physical units. All numerical quantities should be treated as pure numbers.\n- Use a numerical tolerance of $10^{-10}$ to assess linear dependence and feasibility consistency.\n\nTest suite to implement inside your program (each test case provides $\\Sigma$, $c$, and $\\sigma_m^2$; compute $\\beta = c / \\sigma_m^2$ internally):\n1. Happy path, $N=3$:\n   - $\\Sigma = \\begin{bmatrix} 0.04 & 0.006 & 0.004 \\\\ 0.006 & 0.09 & 0.018 \\\\ 0.004 & 0.018 & 0.16 \\end{bmatrix}$,\n   - $c = \\begin{bmatrix} 0.02 \\\\ 0.03 \\\\ 0.04 \\end{bmatrix}$,\n   - $\\sigma_m^2 = 0.05$.\n2. Degenerate but feasible (constraints linearly dependent with consistency), $N=3$:\n   - $\\Sigma = \\begin{bmatrix} 0.01 & 0.002 & 0.0015 \\\\ 0.002 & 0.02 & 0.003 \\\\ 0.0015 & 0.003 & 0.03 \\end{bmatrix}$,\n   - $c = \\begin{bmatrix} 0.02 \\\\ 0.02 \\\\ 0.02 \\end{bmatrix}$,\n   - $\\sigma_m^2 = 0.02$.\n3. Degenerate and infeasible (constraints linearly dependent without consistency), $N=3$:\n   - $\\Sigma = \\begin{bmatrix} 0.06 & 0.01 & 0.008 \\\\ 0.01 & 0.08 & 0.012 \\\\ 0.008 & 0.012 & 0.1 \\end{bmatrix}$,\n   - $c = \\begin{bmatrix} 0.03 \\\\ 0.03 \\\\ 0.03 \\end{bmatrix}$,\n   - $\\sigma_m^2 = 0.025$.\n4. General $N=4$:\n   - $\\Sigma = \\begin{bmatrix} 0.05 & 0.01 & 0.005 & 0.004 \\\\ 0.01 & 0.07 & 0.011 & 0.006 \\\\ 0.005 & 0.011 & 0.09 & 0.012 \\\\ 0.004 & 0.006 & 0.012 & 0.11 \\end{bmatrix}$,\n   - $c = \\begin{bmatrix} 0.03 \\\\ 0.025 \\\\ 0.02 \\\\ 0.015 \\end{bmatrix}$,\n   - $\\sigma_m^2 = 0.06$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results for all test cases as a comma-separated list enclosed in square brackets, where each element is either:\n    - a list of $N+3$ floats: $[w_1,\\dots,w_N,\\, w^{\\top}\\Sigma w,\\, \\beta^{\\top}w,\\, 1^{\\top}w]$ rounded to $6$ decimals, or\n    - an empty list if infeasible.\n- For example, a valid overall output structure with two feasible cases might look like: [[0.2,0.3,0.5,0.012345,1.0,1.0],[...]].", "solution": "The problem presented is a constrained quadratic optimization task, which is a fundamental problem in computational finance. The objective is to find the portfolio weight vector $w \\in \\mathbb{R}^N$ that minimizes the portfolio variance, given by the quadratic form $w^{\\top} \\Sigma w$, subject to two linear equality constraints. The covariance matrix $\\Sigma \\in \\mathbb{R}^{N \\times N}$ is specified as symmetric and positive definite, which ensures that the objective function is strictly convex and thus possesses a unique minimum.\n\nThe optimization problem can be formally stated as:\n$$\n\\begin{aligned}\n& \\underset{w}{\\text{minimize}}\n& & w^{\\top} \\Sigma w \\\\\n& \\text{subject to}\n& & \\mathbf{1}^{\\top} w = 1 \\\\\n& & & \\beta^{\\top} w = 1\n\\end{aligned}\n$$\nwhere $\\mathbf{1}$ is the $N$-dimensional vector of ones, and $\\beta$ is the vector of asset betas.\n\nThe standard and rigorous method for solving such a problem is the method of Lagrange multipliers. We construct the Lagrangian function $L(w, \\lambda_1, \\lambda_2)$:\n$$\nL(w, \\lambda_1, \\lambda_2) = w^{\\top} \\Sigma w - \\lambda_1 (\\mathbf{1}^{\\top} w - 1) - \\lambda_2 (\\beta^{\\top} w - 1)\n$$\nHere, $\\lambda_1$ and $\\lambda_2$ are the Lagrange multipliers associated with the full-investment and a target-beta constraint, respectively. To find the optimal $w$, we derive the first-order necessary conditions by setting the partial derivatives of $L$ with respect to $w$, $\\lambda_1$, and $\\lambda_2$ to zero.\n\nThe partial derivative with respect to the vector $w$ is:\n$$\n\\frac{\\partial L}{\\partial w} = 2 \\Sigma w - \\lambda_1 \\mathbf{1} - \\lambda_2 \\beta = 0\n$$\nSince $\\Sigma$ is positive definite, it is invertible. We can therefore solve for $w$:\n$$\nw = \\frac{1}{2} \\Sigma^{-1} (\\lambda_1 \\mathbf{1} + \\lambda_2 \\beta)\n$$\nThe remaining first-order conditions simply recover the original constraints:\n$$\n\\frac{\\partial L}{\\partial \\lambda_1} = -(\\mathbf{1}^{\\top} w - 1) = 0 \\implies \\mathbf{1}^{\\top} w = 1\n$$\n$$\n\\frac{\\partial L}{\\partial \\lambda_2} = -(\\beta^{\\top} w - 1) = 0 \\implies \\beta^{\\top} w = 1\n$$\nWe substitute the expression for $w$ into these two constraints to form a system of linear equations for $\\lambda_1$ and $\\lambda_2$.\n\nSubstituting into the first constraint:\n$$\n\\mathbf{1}^{\\top} \\left( \\frac{1}{2} \\Sigma^{-1} (\\lambda_1 \\mathbf{1} + \\lambda_2 \\beta) \\right) = 1 \\implies \\lambda_1 (\\mathbf{1}^{\\top} \\Sigma^{-1} \\mathbf{1}) + \\lambda_2 (\\mathbf{1}^{\\top} \\Sigma^{-1} \\beta) = 2\n$$\nSubstituting into the second constraint:\n$$\n\\beta^{\\top} \\left( \\frac{1}{2} \\Sigma^{-1} (\\lambda_1 \\mathbf{1} + \\lambda_2 \\beta) \\right) = 1 \\implies \\lambda_1 (\\beta^{\\top} \\Sigma^{-1} \\mathbf{1}) + \\lambda_2 (\\beta^{\\top} \\Sigma^{-1} \\beta) = 2\n$$\nLet us define the scalars $A$, $B$, and $C$ to simplify the notation:\n$$\nA = \\mathbf{1}^{\\top} \\Sigma^{-1} \\mathbf{1} \\quad ; \\quad B = \\mathbf{1}^{\\top} \\Sigma^{-1} \\beta \\quad ; \\quad C = \\beta^{\\top} \\Sigma^{-1} \\beta\n$$\nNote that since $\\Sigma^{-1}$ is symmetric, we have $B = \\beta^{\\top} \\Sigma^{-1} \\mathbf{1}$. The system for the multipliers becomes:\n$$\n\\begin{pmatrix} A & B \\\\ B & C \\end{pmatrix} \\begin{pmatrix} \\lambda_1 \\\\ \\lambda_2 \\end{pmatrix} = \\begin{pmatrix} 2 \\\\ 2 \\end{pmatrix}\n$$\nThe determinant of the coefficient matrix is $D = AC - B^2$. This determinant is zero if and only if the constraint vectors $\\mathbf{1}$ and $\\beta$ are linearly dependent, as guaranteed by the Cauchy-Schwarz inequality for the inner product defined by $\\Sigma^{-1}$.\n\nCase 1: Linearly independent constraints ($D \\neq 0$).\nThe system has a unique solution for $(\\lambda_1, \\lambda_2)$, which can be found using Cramer's rule or matrix inversion:\n$$\n\\lambda_1 = \\frac{2(C - B)}{AC - B^2} \\quad ; \\quad \\lambda_2 = \\frac{2(A - B)}{AC - B^2}\n$$\nWith these values, the optimal weight vector $w$ is uniquely determined.\n\nCase 2: Linearly dependent constraints ($D \\approx 0$).\nThis occurs if and only if $\\beta = k \\cdot \\mathbf{1}$ for some scalar $k$. The constraints become:\n$$\n\\mathbf{1}^{\\top} w = 1\n$$\n$$\n(k \\cdot \\mathbf{1})^{\\top} w = 1 \\implies k (\\mathbf{1}^{\\top} w) = 1\n$$\nSubstituting the first constraint into the second yields $k(1) = 1$, which implies $k=1$.\n- Sub-case 2a: Feasible ($k = 1$). If the beta of every asset is $1$, the two constraints are identical. The problem degenerates to minimizing $w^{\\top} \\Sigma w$ subject only to $\\mathbf{1}^{\\top} w = 1$. The Lagrangian is $L(w, \\lambda) = w^{\\top} \\Sigma w - \\lambda(\\mathbf{1}^{\\top} w - 1)$. The first-order condition $\\frac{\\partial L}{\\partial w} = 2 \\Sigma w - \\lambda \\mathbf{1} = 0$ gives $w = \\frac{\\lambda}{2} \\Sigma^{-1} \\mathbf{1}$. Substituting into the constraint gives $\\frac{\\lambda}{2} (\\mathbf{1}^{\\top} \\Sigma^{-1} \\mathbf{1}) = 1$, so $\\frac{\\lambda}{2} = \\frac{1}{\\mathbf{1}^{\\top} \\Sigma^{-1} \\mathbf{1}}$. The optimal weights are:\n  $$\n  w = \\frac{\\Sigma^{-1} \\mathbf{1}}{\\mathbf{1}^{\\top} \\Sigma^{-1} \\mathbf{1}}\n  $$\n- Sub-case 2b: Infeasible ($k \\neq 1$). The constraints are contradictory. No solution exists. The problem is infeasible.\n\nThe computational algorithm directly follows this analytical framework:\n1.  For each test case, compute the beta vector $\\beta = c / \\sigma_m^2$.\n2.  Check for linear dependence of $\\mathbf{1}$ and $\\beta$. This is done by testing if all elements of $\\beta$ are equal to a constant $k$ within a specified numerical tolerance of $10^{-10}$.\n3.  If they are linearly dependent:\n    a. Check if $k$ is consistent with the constraints, i.e., $|k - 1| < 10^{-10}$.\n    b. If consistent, solve the single-constraint problem using the derived formula.\n    c. If inconsistent, the problem is infeasible.\n4.  If they are linearly independent, solve the $2 \\times 2$ system for $\\lambda_1, \\lambda_2$ and compute the weights $w$.\n5.  For any feasible solution, compute the portfolio variance $w^{\\top} \\Sigma w$, achieved beta $\\beta^{\\top} w$, and sum of weights $\\mathbf{1}^{\\top} w$. The latter two serve as a verification of constraint satisfaction.\n6.  Format all numerical results to $6$ decimal places as required.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the minimum-variance portfolio under beta and budget constraints.\n    \"\"\"\n    \n    # Numerical tolerance for floating point comparisons.\n    TOL = 1e-10\n\n    test_cases = [\n        {\n            # Happy path, N=3\n            \"Sigma\": np.array([\n                [0.04, 0.006, 0.004],\n                [0.006, 0.09, 0.018],\n                [0.004, 0.018, 0.16]\n            ]),\n            \"c\": np.array([0.02, 0.03, 0.04]),\n            \"sigma_m_sq\": 0.05\n        },\n        {\n            # Degenerate but feasible, N=3\n            \"Sigma\": np.array([\n                [0.01, 0.002, 0.0015],\n                [0.002, 0.02, 0.003],\n                [0.0015, 0.003, 0.03]\n            ]),\n            \"c\": np.array([0.02, 0.02, 0.02]),\n            \"sigma_m_sq\": 0.02\n        },\n        {\n            # Degenerate and infeasible, N=3\n            \"Sigma\": np.array([\n                [0.06, 0.01, 0.008],\n                [0.01, 0.08, 0.012],\n                [0.008, 0.012, 0.1]\n            ]),\n            \"c\": np.array([0.03, 0.03, 0.03]),\n            \"sigma_m_sq\": 0.025\n        },\n        {\n            # General N=4\n            \"Sigma\": np.array([\n                [0.05, 0.01, 0.005, 0.004],\n                [0.01, 0.07, 0.011, 0.006],\n                [0.005, 0.011, 0.09, 0.012],\n                [0.004, 0.006, 0.012, 0.11]\n            ]),\n            \"c\": np.array([0.03, 0.025, 0.02, 0.015]),\n            \"sigma_m_sq\": 0.06\n        }\n    ]\n\n    results_for_print = []\n\n    for case in test_cases:\n        Sigma = case[\"Sigma\"]\n        c = case[\"c\"]\n        sigma_m_sq = case[\"sigma_m_sq\"]\n        N = Sigma.shape[0]\n\n        beta = c / sigma_m_sq\n        ones = np.ones(N)\n\n        # Check for linear dependence: beta = k * 1\n        # This is true if all elements of beta are the same.\n        is_dependent = np.allclose(beta, beta[0], atol=TOL, rtol=TOL)\n\n        w = None\n        if is_dependent:\n            k = beta[0]\n            # Check for feasibility: k must equal 1\n            if np.isclose(k, 1.0, atol=TOL):\n                # Constraints are redundant and feasible. Solve single-constraint problem.\n                # min w'Sw s.t. 1'w = 1\n                Sigma_inv = np.linalg.inv(Sigma)\n                numerator = Sigma_inv @ ones\n                denominator = ones.T @ numerator\n                w = numerator / denominator\n            else:\n                # Constraints are contradictory. Infeasible.\n                results_for_print.append(\"[]\")\n                continue\n        else:\n            # Constraints are linearly independent. Solve two-constraint problem.\n            Sigma_inv = np.linalg.inv(Sigma)\n            \n            # Define scalars for the 2x2 system\n            A = ones.T @ Sigma_inv @ ones\n            B = ones.T @ Sigma_inv @ beta\n            C = beta.T @ Sigma_inv @ beta\n\n            # Solve for Lagrange multipliers lambda1, lambda2\n            matrix_D = A * C - B * B\n            if abs(matrix_D) < TOL:\n                # This should not be reached due to the initial check but is a safeguard.\n                results_for_print.append(\"[]\")\n                continue\n\n            # System is [A, B; B, C][l1; l2] = [2; 2]\n            lambda1 = 2 * (C - B) / matrix_D\n            lambda2 = 2 * (A - B) / matrix_D\n\n            # Compute weights\n            w = 0.5 * (Sigma_inv @ (lambda1 * ones + lambda2 * beta))\n\n        if w is not None:\n            # Calculate final portfolio characteristics\n            portfolio_variance = w.T @ Sigma @ w\n            portfolio_beta = beta.T @ w\n            portfolio_weight_sum = np.sum(w)\n            \n            # Prepare result list and round all numbers\n            final_list = list(w) + [portfolio_variance, portfolio_beta, portfolio_weight_sum]\n            rounded_list = [f\"{x:.6f}\" for x in final_list]\n            results_for_print.append(f\"[{','.join(rounded_list)}]\")\n\n    # Print the final result string in the required format\n    print(f\"[{','.join(results_for_print)}]\")\n\nsolve()\n```"}, {"introduction": "Standard theory assumes a convex, or \"unbroken,\" set of investment choices, which results in the familiar smooth curve of the efficient frontier. This advanced computational exercise challenges that assumption by introducing a non-convex constraint—a \"hole\" in the feasible set of portfolios [@problem_id:2384354]. By programming a solution that navigates this complex space, you will discover the surprising possibility of a disjoint, or fragmented, efficient frontier, demonstrating the power of numerical methods to explore finance beyond textbook scenarios.", "id": "2384354", "problem": "Let there be a one-period mean–variance portfolio selection problem with three risky assets. Let the expected gross returns (as decimals per unit invested) be given by the vector $r = (0.20, 0.06, 0.04)$ and let the covariance matrix of returns be the symmetric matrix\n$$\n\\Sigma \\;=\\;\n\\begin{pmatrix}\n0.0625 & 0.005 & 0.002 \\\\\n0.005 & 0.010 & 0.002 \\\\\n0.002 & 0.002 & 0.0064\n\\end{pmatrix}.\n$$\nA portfolio is a weight vector $w = (w_1,w_2,w_3)$ satisfying $w_i \\ge 0$ for each $i \\in \\{1,2,3\\}$ and $\\sum_{i=1}^3 w_i = 1$. For any feasible $w$, the expected return is $\\mu(w) = r^\\top w$ and the variance is $\\sigma^2(w) = w^\\top \\Sigma \\, w$.\n\nConsider an additional non-convex constraint that introduces a “hole” in the budget set: there exist parameters $\\alpha,\\beta$ with $0 \\le \\alpha \\le \\beta \\le 1$ such that feasible portfolios must satisfy the disjunction $w_1 \\le \\alpha$ or $w_1 \\ge \\beta$. For given $\\alpha,\\beta$, define the efficient frontier as the set of variance-minimizing portfolios among all feasible $w$ that achieve a given target expected return $\\mu^\\star$, where target expected returns are restricted to a grid on the feasible range described below.\n\nFor each parameter pair $(\\alpha,\\beta)$, define the feasible target-return range as follows. Consider the extreme feasible corner portfolios obtained by taking the union of the corners of the two convex subsets defined by $w_1 \\le \\alpha$ and by $w_1 \\ge \\beta$, namely the portfolios with $(w_1,w_2,w_3) \\in \\{(0,1,0),(0,0,1),(\\alpha,1-\\alpha,0),(\\alpha,0,1-\\alpha),(\\beta,1-\\beta,0),(\\beta,0,1-\\beta),(1,0,0)\\}$ that satisfy $0 \\le \\alpha \\le \\beta \\le 1$. Let $\\mu_{\\min}$ be the minimum of $\\mu(w)$ over these portfolios, and let $\\mu_{\\max}$ be the maximum of $\\mu(w)$ over these portfolios. Consider the linearly spaced grid of target returns\n$$\n\\{\\mu^\\star_k : k = 0,1,\\dots,60\\}, \\quad \\mu^\\star_k \\;=\\; \\mu_{\\min} + \\frac{k}{60}\\,(\\mu_{\\max}-\\mu_{\\min}).\n$$\n\nFor each $\\mu^\\star_k$, a target is deemed feasible if there exists a feasible $w$ (i.e., $w_i \\ge 0$, $\\sum_i w_i = 1$, and $w_1 \\le \\alpha$ or $w_1 \\ge \\beta$) such that $|\\mu(w) - \\mu^\\star_k| \\le \\varepsilon$ with $\\varepsilon = 10^{-6}$. Among all feasible portfolios meeting this target, the efficient variance at $\\mu^\\star_k$ is the minimum of $\\sigma^2(w)$.\n\nDefine that the efficient frontier is disjoint if, when scanning the ordered grid $\\{\\mu^\\star_k\\}_{k=0}^{60}$, the set of indices $k$ for which the efficient variance is defined (i.e., the target is feasible) decomposes into at least two nonempty, disjoint, maximal contiguous blocks. Otherwise, the efficient frontier is connected.\n\nYour task is to write a complete program that, for each test case specified below, determines whether the efficient frontier is disjoint according to the definition above. The program must use the fixed $r$ and $\\Sigma$ given above and must enforce non-negativity and the budget constraint.\n\nTest suite (each test case is a pair $(\\alpha,\\beta)$):\n- Case 1: $(\\alpha,\\beta) = (0.20, 0.80)$.\n- Case 2: $(\\alpha,\\beta) = (0.00, 0.00)$.\n- Case 3: $(\\alpha,\\beta) = (0.49, 0.51)$.\n- Case 4: $(\\alpha,\\beta) = (0.30, 0.70)$.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list of booleans enclosed in square brackets (e.g., “[True,False,True,False]”), where each boolean corresponds, in order, to Cases $1$ through $4$ and indicates whether the efficient frontier is disjoint (True) or connected (False) under that case’s non-convex constraint. No other text should be printed. All numerical quantities in the computation are unit-free and should be treated as decimals (not percentages).", "solution": "The problem statement is critically examined and found to be valid. It presents a well-posed problem in computational finance, specifically in mean-variance portfolio optimization. The givens are complete, mathematically consistent, and scientifically grounded in established financial economic theory. The covariance matrix $\\Sigma$ is symmetric and its principal minors are all positive ($M_1 = 0.0625$, $M_2 = 0.0006$, $M_3 \\approx 3.59 \\times 10^{-6}$), which, by Sylvester's criterion, confirms that $\\Sigma$ is positive definite. This guarantees that the objective function, the portfolio variance $\\sigma^2(w) = w^\\top \\Sigma w$, is strictly convex, ensuring a unique solution for any convexly constrained variance minimization problem. The task is to determine a property—the disjointness—of the efficient frontier under a non-convex constraint, which is a programmatically verifiable question.\n\nThe core of the problem is to determine, for a grid of target expected returns $\\{\\mu^\\star_k\\}$, which targets are feasible. A target $\\mu^\\star_k$ is feasible if there exists a portfolio $w$ that satisfies all given constraints and achieves an expected return $\\mu(w)$ such that $|\\mu(w) - \\mu^\\star_k| \\le \\varepsilon$. The efficient frontier is considered disjoint if the set of indices $k$ corresponding to feasible targets is not a single contiguous block.\n\nThe primary difficulty arises from the non-convex constraint on the portfolio weights: $w_1 \\le \\alpha$ or $w_1 \\ge \\beta$. This constraint defines the total feasible set of portfolios, let us call it $F$, as the union of two disjoint convex sets (polytopes):\n$S_1 = \\{ w \\in \\mathbb{R}^3 \\mid \\sum_{i=1}^3 w_i = 1, w_i \\ge 0 \\text{ for } i=1,2,3, \\text{ and } w_1 \\le \\alpha \\}$\n$S_2 = \\{ w \\in \\mathbb{R}^3 \\mid \\sum_{i=1}^3 w_i = 1, w_i \\ge 0 \\text{ for } i=1,2,3, \\text{ and } w_1 \\ge \\beta \\}$\nSo, $F = S_1 \\cup S_2$.\n\nTo determine if a target return $\\mu^\\star_k$ is feasible, we must ascertain if there exists any portfolio $w \\in F$ that satisfies the return condition $|\\mu(w) - \\mu^\\star_k| \\le \\varepsilon$. Since $F = S_1 \\cup S_2$, this is equivalent to checking if at least one of the following two conditions holds:\n1. There exists a portfolio $w^{(1)} \\in S_1$ such that $|\\mu(w^{(1)}) - \\mu^\\star_k| \\le \\varepsilon$.\n2. There exists a portfolio $w^{(2)} \\in S_2$ such that $|\\mu(w^{(2)}) - \\mu^\\star_k| \\le \\varepsilon$.\n\nThe problem asks to find the efficient variance, which is the minimum variance for a given target return. This suggests framing the feasibility check as an optimization problem. For each target return $\\mu^\\star_k$, we can solve two separate Quadratic Programming (QP) problems:\n**Problem P1:**\n$$ \\min_{w} \\quad w^\\top \\Sigma w $$\n$$ \\text{subject to} \\quad w \\in S_1, \\quad |\\mu(w) - \\mu^\\star_k| \\le \\varepsilon $$\n**Problem P2:**\n$$ \\min_{w} \\quad w^\\top \\Sigma w $$\n$$ \\text{subject to} \\quad w \\in S_2, \\quad |\\mu(w) - \\mu^\\star_k| \\le \\varepsilon $$\n\nA target return $\\mu^\\star_k$ is feasible if and only if at least one of these two QP problems has a feasible solution. A numerical QP solver, such as the Sequential Least Squares Programming (SLSQP) algorithm, can be used. If the solver successfully finds a solution for either P1 or P2, the target $\\mu^\\star_k$ is feasible. If both solvers fail to find a solution (typically indicating an empty feasible set for the respective subproblem), then $\\mu^\\star_k$ is infeasible.\n\nThe overall algorithm proceeds as follows for each test case $(\\alpha, \\beta)$:\n1.  **Construct the Return Grid**: First, calculate the expected returns $\\mu(w) = r^\\top w$ for the seven specified corner portfolios. The minimum and maximum of these values, $\\mu_{\\min}$ and $\\mu_{\\max}$, define the range of the target return grid. The grid of $61$ points, $\\{\\mu^\\star_k\\}_{k=0}^{60}$, is then constructed by linear interpolation.\n2.  **Check Feasibility for Each Target**: For each $\\mu^\\star_k$ in the grid, solve both QP problems, P1 and P2. The constraints are encoded for a numerical solver. A boolean flag, `is_feasible[k]`, is set to `True` if either P1 or P2 has a solution, and `False` otherwise.\n3.  **Analyze Connectivity**: After populating the `is_feasible` array for all $k \\in \\{0, \\dots, 60\\}$, we analyze its structure. If the array contains no `True` values, the frontier is trivially connected. Otherwise, we find the index of the first `True` entry and the last `True` entry. If all entries between these two indices (inclusive) are `True`, the set of feasible returns forms a single contiguous block, and the frontier is connected. If there is at least one `False` entry between the first and last `True` entries, a gap exists, and the frontier is declared disjoint.\n\nThis procedure is systematically applied to each $(\\alpha, \\beta)$ pair from the test suite to produce the final boolean results.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    \"\"\"\n    Solves the mean-variance portfolio problem with a non-convex constraint for multiple test cases.\n    \"\"\"\n    # Problem constants\n    R_VEC = np.array([0.20, 0.06, 0.04])\n    _T = R_VEC.T\n    SIGMA = np.array([\n        [0.0625, 0.005, 0.002],\n        [0.005, 0.010, 0.002],\n        [0.002, 0.002, 0.0064]\n    ])\n    RETURN_TOLERANCE_EPSILON = 1e-6\n    GRID_POINTS = 60\n\n    test_cases = [\n        (0.20, 0.80),\n        (0.00, 0.00),\n        (0.49, 0.51),\n        (0.30, 0.70)\n    ]\n\n    results = []\n\n    for alpha, beta in test_cases:\n        # Step 1: Define the feasible target-return range from corner portfolios\n        corner_portfolios = set()\n        # The set automatically handles duplicates, e.g., when alpha=0 or beta=0\n        if 1 - alpha >= 0:\n            corner_portfolios.add((alpha, 1 - alpha, 0))\n            corner_portfolios.add((alpha, 0, 1 - alpha))\n        if 1 - beta >= 0:\n            corner_portfolios.add((beta, 1 - beta, 0))\n            corner_portfolios.add((beta, 0, 1 - beta))\n        \n        corner_portfolios.add((0, 1, 0))\n        corner_portfolios.add((0, 0, 1))\n        corner_portfolios.add((1, 0, 0))\n        \n        corner_returns = [R_VEC @ np.array(w) for w in corner_portfolios]\n        \n        mu_min = min(corner_returns)\n        mu_max = max(corner_returns)\n        \n        mu_grid = np.linspace(mu_min, mu_max, GRID_POINTS + 1)\n\n        # Step 2: For each target return, check if a feasible portfolio exists\n        is_feasible_on_grid = []\n        \n        # Objective function for QP: variance\n        objective_func = lambda w: w.T @ SIGMA @ w\n        # Standard bounds w_i >= 0\n        bounds = [(0, None), (0, None), (0, None)]\n        # Standard constraint sum(w_i) = 1\n        sum_constraint = {'type': 'eq', 'fun': lambda w: np.sum(w) - 1}\n\n        for mu_star in mu_grid:\n            k_is_feasible = False\n            \n            # Constraints for return target mu_star with tolerance\n            return_constraints = [\n                {'type': 'ineq', 'fun': lambda w, mu=mu_star: mu + RETURN_TOLERANCE_EPSILON - R_VEC @ w},\n                {'type': 'ineq', 'fun': lambda w, mu=mu_star: R_VEC @ w - (mu - RETURN_TOLERANCE_EPSILON)}\n            ]\n\n            # Sub-problem 1: w_1 <= alpha\n            cons1 = [sum_constraint] + return_constraints + [{'type': 'ineq', 'fun': lambda w: alpha - w[0]}]\n            # Feasible initial guess for S1\n            x0_1 = np.array([alpha/2.0, (1.0-alpha/2.0)/2.0, (1.0-alpha/2.0)/2.0])\n            res1 = minimize(objective_func, x0_1, method='SLSQP', bounds=bounds, constraints=cons1, tol=1e-9)\n            if res1.success:\n                k_is_feasible = True\n\n            # Sub-problem 2: w_1 >= beta\n            if not k_is_feasible:\n                cons2 = [sum_constraint] + return_constraints + [{'type': 'ineq', 'fun': lambda w: w[0] - beta}]\n                # Feasible initial guess for S2\n                x0_2 = np.array([beta, (1.0 - beta) / 2.0, (1.0 - beta) / 2.0]) if beta < 1 else np.array([1.0, 0.0, 0.0])\n                res2 = minimize(objective_func, x0_2, method='SLSQP', bounds=bounds, constraints=cons2, tol=1e-9)\n                if res2.success:\n                    k_is_feasible = True\n            \n            is_feasible_on_grid.append(k_is_feasible)\n\n        # Step 3: Analyze the feasibility array for disjointness\n        is_feasible_np = np.array(is_feasible_on_grid)\n        \n        if not np.any(is_feasible_np):\n            # No feasible points found, so a single (empty) block. Connected.\n            is_disjoint = False\n        else:\n            first_true = np.argmax(is_feasible_np)\n            last_true = len(is_feasible_np) - 1 - np.argmax(is_feasible_np[::-1])\n            # Check if all elements between the first and last 'True' are also 'True'\n            is_connected = np.all(is_feasible_np[first_true : last_true + 1])\n            is_disjoint = not is_connected\n            \n        results.append(is_disjoint)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"}]}