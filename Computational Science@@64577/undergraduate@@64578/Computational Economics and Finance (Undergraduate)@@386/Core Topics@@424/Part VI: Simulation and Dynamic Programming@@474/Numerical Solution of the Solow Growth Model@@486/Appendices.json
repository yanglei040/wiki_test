{"hands_on_practices": [{"introduction": "The cornerstone of analyzing any dynamic economic model is identifying its long-run equilibrium, or steady state. This first exercise guides you through the process of computing the Solow model's steady-state capital stock by framing it as a fixed-point problem [@problem_id:2393421]. By implementing a fixed-point iteration, you will gain hands-on experience with one of the most fundamental iterative methods in computational economics and develop a concrete understanding of how an economy converges to its balanced growth path.", "id": "2393421", "problem": "You are given a one-sector Solow growth model with exogenous population growth, technology growth, and depreciation. The steady state for capital per effective worker is characterized by the equilibrium condition that net investment equals zero. Starting from fundamental definitions, formulate a fixed-point problem whose solution is the steady-state capital stock per effective worker and solve it numerically by a Fixed Point Iteration (FPI).\n\nUse the following core definitions as the base:\n- Steady state is defined by the condition that next-period capital per effective worker equals current capital per effective worker.\n- Aggregate output is produced by a twice continuously differentiable, strictly increasing, and concave per-effective-worker production function. For concreteness in the test suite, this will be the Cobb–Douglas production function with parameterized elasticity.\n- Savings is a constant fraction of output, and the effective depreciation rate is the sum of population growth, technology growth, and physical depreciation.\n\nYour task:\n1. Derive a fixed-point map from the steady-state condition using only the fundamental definitions above. Explain the mathematical object whose fixed point you will compute, and why a fixed point exists on a compact convex set under the given assumptions.\n2. Implement a Fixed Point Iteration that, for given parameters, iterates from a strictly positive initial guess until a convergence criterion is satisfied.\n3. Use a stopping rule based on the fixed-point residual. Specifically, let the iterates be $k_{t}$ and the map be $T(k)$. Stop when $\\lvert T(k_{t}) - k_{t} \\rvert \\le \\varepsilon \\cdot \\max\\{1,\\lvert k_{t} \\rvert\\}$, with tolerance $\\varepsilon$ specified below.\n4. Use a maximum iteration safeguard to guarantee termination if the tolerance is not met.\n\nNumerical requirements:\n- Use tolerance $\\varepsilon = 10^{-12}$.\n- Use a uniform initial guess $k_{0} = 1.0$ for all test cases.\n- If savings is zero, return the steady-state value implied by the map directly without iteration.\n- If any parameter set implies a nonpositive effective depreciation term, do not attempt to iterate; instead, return a non-number flag value. For concreteness, in that case return the floating-point not-a-number value (NaN).\n\nModel specification for the test suite:\n- Production is Cobb–Douglas with $f(k) = A \\, k^{\\alpha}$.\n- Savings rate is $s \\in [0,1]$.\n- The effective depreciation term is $\\nu = n + g + \\delta$, with population growth $n \\ge 0$, technology growth $g \\ge 0$, and depreciation $\\delta \\ge 0$.\n\nFor each parameter tuple $(A,\\alpha,s,n,g,\\delta)$, compute the steady-state $k^{\\star}$ as the fixed point of your derived map using FPI with the requirements above. Report the results as floating-point numbers rounded to six digits after the decimal point.\n\nTest suite:\n- Case $1$: $(A,\\alpha,s,n,g,\\delta) = (\\,1.0,\\,0.3,\\,0.25,\\,0.01,\\,0.02,\\,0.08\\,)$.\n- Case $2$: $(A,\\alpha,s,n,g,\\delta) = (\\,1.0,\\,0.5,\\,0.10,\\,0.02,\\,0.02,\\,0.06\\,)$.\n- Case $3$: $(A,\\alpha,s,n,g,\\delta) = (\\,1.0,\\,0.3,\\,0.00,\\,0.02,\\,0.01,\\,0.07\\,)$.\n- Case $4$: $(A,\\alpha,s,n,g,\\delta) = (\\,0.8,\\,0.8,\\,0.30,\\,0.03,\\,0.01,\\,0.04\\,)$.\n- Case $5$: $(A,\\alpha,s,n,g,\\delta) = (\\,1.0,\\,0.9,\\,0.20,\\,0.01,\\,0.02,\\,0.07\\,)$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the same order as the test cases, for example $[\\text{result}_{1},\\text{result}_{2},\\dots]$.\n- Each $\\text{result}_{i}$ must be a floating-point number rounded to six digits after the decimal point.", "solution": "The problem statement is subjected to validation before a solution is attempted.\n\n**Step 1: Extract Givens**\n- **Model**: One-sector Solow growth model with exogenous population growth `$n \\ge 0$`, technology growth `$g \\ge 0$`, and depreciation `$\\delta \\ge 0$`.\n- **Production Function**: A twice continuously differentiable, strictly increasing, and concave per-effective-worker production function `$f(k)$`. For the test suite, this is the Cobb-Douglas function `$f(k) = A \\, k^{\\alpha}$`.\n- **Savings**: A constant fraction `$s \\in [0,1]$` of output.\n- **Effective Depreciation**: The effective depreciation rate is `$\\nu = n + g + \\delta$`.\n- **Steady-State Definition**: The state where next-period capital per effective worker equals current capital per effective worker, which implies the fundamental differential equation for capital per effective worker, `$\\dot{k}$`, is zero.\n- **Task**: Formulate a fixed-point problem for the steady-state capital per effective worker `$k^{\\star}$` and solve it using Fixed Point Iteration (FPI).\n- **Fixed-Point Map**: Must be derived from the steady-state condition `$s f(k) = \\nu k$`.\n- **Algorithm**: Fixed Point Iteration starting from an initial guess `$k_{0} = 1.0$`.\n- **Stopping Rule**: The iteration on `$k_t$` with map `$T(k)$` terminates when `$\\lvert T(k_{t}) - k_{t} \\rvert \\le \\varepsilon \\cdot \\max\\{1,\\lvert k_{t} \\rvert\\}$`.\n- **Numerical Parameters**: Tolerance `$\\varepsilon = 10^{-12}$`; initial guess `$k_{0} = 1.0$`. A maximum iteration safeguard must be used.\n- **Special Cases**:\n    - If `$s = 0$`, return the steady-state value without iteration.\n    - If `$\\nu \\le 0$`, return a not-a-number (`NaN`) value.\n- **Test Suite**: Five parameter tuples `$(A,\\alpha,s,n,g,\\delta)$` are provided.\n    - Case $1$: `$(\\,1.0,\\,0.3,\\,0.25,\\,0.01,\\,0.02,\\,0.08\\,)$`.\n    - Case $2$: `$(\\,1.0,\\,0.5,\\,0.10,\\,0.02,\\,0.02,\\,0.06\\,)$`.\n    - Case $3$: `$(\\,1.0,\\,0.3,\\,0.00,\\,0.02,\\,0.01,\\,0.07\\,)$`.\n    - Case $4$: `$(\\,0.8,\\,0.8,\\,0.30,\\,0.03,\\,0.01,\\,0.04\\,)$`.\n    - Case $5$: `$(\\,1.0,\\,0.9,\\,0.20,\\,0.01,\\,0.02,\\,0.07\\,)$`.\n\n**Step 2: Validate Using Extracted Givens**\n- **Scientific Grounding**: The problem is based on the Solow-Swan model, a fundamental and well-established framework in macroeconomics. The use of a Cobb-Douglas production function and the derivation of the steady state via a fixed-point problem are standard textbook procedures. The problem is scientifically sound.\n- **Well-Posedness**: The problem is well-posed. For the given parameter constraints (`$0 < \\alpha < 1$`, `$s > 0$`, `$\\nu > 0$`), the model guarantees the existence of a unique, non-trivial, and stable steady-state capital stock. The problem provides all necessary information and a clear objective.\n- **Objectivity**: The problem is stated using precise, objective, and formal mathematical and economic language. There are no subjective or ambiguous statements.\n\n**Step 3: Verdict and Action**\nThe problem is valid. It is a standard, well-defined problem in computational economics that is scientifically grounded and internally consistent. A full solution will be provided.\n\n**Derivation of the Fixed-Point Map and Existence of Solution**\n\nLet `$k$` be capital per effective worker. The fundamental equation of motion for `$k$` in the continuous-time Solow model is given by the differential equation:\n$$ \\dot{k} = s f(k) - (n + g + \\delta)k $$\nwhere `$s f(k)$` represents gross investment per effective worker and `$(n + g + \\delta)k$` represents the effective depreciation per effective worker. The term `$\\nu = n + g + \\delta$` is the effective depreciation rate, which accounts for physical depreciation (`$\\delta$`), capital dilution due to population growth (`$n$`), and capital dilution due to technological progress (`$g$`).\n\nThe steady state, denoted `$k^{\\star}$`, is an equilibrium point where the stock of capital per effective worker is constant, i.e., `$\\dot{k} = 0$`. This yields the steady-state condition:\n$$ s f(k^{\\star}) = \\nu k^{\\star} $$\nProvided that `$\\nu > 0$`, we can rearrange this equation to define a fixed-point problem. A fixed point of a function `$T(k)$` is a value `$k^{\\star}$` such that `$T(k^{\\star}) = k^{\\star}$`. We can define such a function `$T(k)$` from our steady-state condition:\n$$ k^{\\star} = \\frac{s}{\\nu} f(k^{\\star}) $$\nThus, the mathematical object whose fixed point we must compute is the map `$T: \\mathbb{R}_+ \\to \\mathbb{R}_+$` defined by:\n$$ T(k) = \\frac{s}{\\nu} f(k) $$\nFor the specific Cobb-Douglas production function `$f(k) = A k^{\\alpha}$`, the map becomes:\n$$ T(k) = \\left( \\frac{sA}{\\nu} \\right) k^{\\alpha} $$\nThe existence of a fixed point on a compact convex set is guaranteed by Brouwer's Fixed-Point Theorem under certain conditions. The theorem states that any continuous function mapping a compact, convex, non-empty set into itself has at least one fixed point.\n\nLet us analyze the map `$T(k)$` for `$k \\ge 0$`, assuming `$s>0$`, `$\\nu>0$`, `$A>0$`, and `$0 < \\alpha < 1$`.\n$1$. The domain of interest is `$k \\in [0, \\infty)$`. The function `$T(k)$` is continuous on this domain.\n$2$. We need to find a compact convex set `$D \\subset [0, \\infty)$` such that `$T(D) \\subseteq D$`. Let `$D = [k_{min}, k_{max}]$` for some `$0 < k_{min} < k_{max}$`.\n$3$. The standard Inada conditions for the production function, which are satisfied by the Cobb-Douglas form with `$0 < \\alpha < 1$`, are `$\\lim_{k \\to 0} f'(k) = \\infty$` and `$\\lim_{k \\to \\infty} f'(k) = 0$`.\n$4$. These conditions on `$f'(k)$` imply that the slope of `$T(k)$`, which is `$T'(k) = \\frac{s}{\\nu} f'(k)$`, also approaches infinity as `$k \\to 0$` and approaches zero as `$k \\to \\infty$`.\n$5$. The condition `$\\lim_{k \\to 0} T'(k) = \\infty$` ensures that for a sufficiently small `$k_{min} > 0$`, the graph of `$T(k)$` is steeper than the line `$y=k$`, which means `$T(k_{min}) > k_{min}$`.\n$6$. The condition `$\\lim_{k \\to \\infty} T'(k) = 0$` ensures that for a sufficiently large `$k_{max}$`, the graph of `$T(k)$` is flatter than the line `$y=k$`, which means `$T(k_{max}) < k_{max}$`.\n$7$. Since `$T(k)$` is a continuous function, we can apply the Intermediate Value Theorem to the function `$g(k) = T(k) - k$` on the interval `$[k_{min}, k_{max}]$`. As `$g(k_{min}) > 0$` and `$g(k_{max}) < 0$`, there must exist at least one point `$k^{\\star} \\in (k_{min}, k_{max})`` such that `$g(k^{\\star}) = 0$`, which implies `$T(k^{\\star}) = k^{\\star}$`. This establishes the existence of a fixed point. For `$0 < \\alpha < 1$`, `$T(k)$` is strictly concave, which ensures the positive fixed point `$k^{\\star}$` is unique.\n\n**Algorithmic Implementation**\n\nThe Fixed Point Iteration (FPI) algorithm generates a sequence `$\\{k_t\\}_{t=0}^\\infty$` using the recurrence relation `$k_{t+1} = T(k_t)$`. Given the properties of `$T(k)$`, this sequence is guaranteed to converge to the unique positive fixed point `$k^{\\star}$` for any initial guess `$k_0 > 0$`.\n\nThe algorithm is as follows:\n$1$. For a given parameter set `$(A, \\alpha, s, n, g, \\delta)$`, first compute the effective depreciation `$\\nu = n+g+\\delta$`.\n$2$. Handle special cases: If `$\\nu \\le 0$`, the model is ill-defined; return `NaN`. If `$s = 0$`, the only investment is zero, so the steady state is `$k^{\\star} = 0$`; return `$0.0$`.\n$3$. Initialize the iteration with `$k_t = k_0 = 1.0$`.\n$4$. In a loop, compute the next iterate `$k_{t+1} = T(k_t) = (s A_t k_{t}^{\\alpha}) / \\nu$`.\n$5$. Check for convergence using the specified stopping rule: `$\\lvert k_{t+1} - k_t \\rvert \\le \\varepsilon \\cdot \\max\\{1, \\lvert k_t \\rvert\\}$`, with `$\\varepsilon = 10^{-12}$`.\n$6$. If the condition is met, the iteration has converged. Return `$k_{t+1}$`.\n$7$. If the condition is not met, update `$k_t \\leftarrow k_{t+1}$` and continue to the next iteration.\n$8$. A maximum number of iterations must be imposed to guarantee termination in case of non-convergence, although convergence is expected for the given test cases.", "answer": "```python\nimport numpy as np\n\ndef solve_fpi(params):\n    \"\"\"\n    Computes the steady-state capital per effective worker for the Solow model\n    using Fixed Point Iteration.\n\n    Args:\n        params (tuple): A tuple containing the model parameters (A, alpha, s, n, g, delta).\n\n    Returns:\n        float: The steady-state capital k*, or np.nan if the model is ill-defined.\n    \"\"\"\n    A, alpha, s, n, g, delta = params\n    \n    # Calculate the effective depreciation rate\n    nu = n + g + delta\n    \n    # Handle special case: non-positive effective depreciation\n    if nu <= 0:\n        return np.nan\n        \n    # Handle special case: zero savings rate\n    # If s = 0, T(k) = 0 for all k, so the fixed point is k* = 0.\n    if s == 0.0:\n        return 0.0\n\n    # FPI parameters\n    k_curr = 1.0  # Initial guess k_0\n    eps = 1e-12   # Tolerance\n    max_iter = 5000 # Maximum iteration safeguard\n\n    for _ in range(max_iter):\n        # Apply the fixed-point map T(k) = (s * A * k^alpha) / nu\n        try:\n            k_next = (s * A * (k_curr ** alpha)) / nu\n        except (ValueError, OverflowError):\n            # Handle potential numerical errors for very large k\n            return np.nan\n\n        # Check for convergence using the specified mixed absolute/relative tolerance\n        if abs(k_next - k_curr) <= eps * max(1.0, abs(k_curr)):\n            return k_next\n        \n        # Update for the next iteration\n        k_curr = k_next\n\n    # If max_iter is reached without convergence, return the last computed value\n    # as a best-effort result, though this case is not expected for the given tests.\n    return k_curr\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    test_cases = [\n        # (A, alpha, s, n, g, delta)\n        (1.0, 0.3, 0.25, 0.01, 0.02, 0.08),  # Case 1\n        (1.0, 0.5, 0.10, 0.02, 0.02, 0.06),  # Case 2\n        (1.0, 0.3, 0.00, 0.02, 0.01, 0.07),  # Case 3\n        (0.8, 0.8, 0.30, 0.03, 0.01, 0.04),  # Case 4\n        (1.0, 0.9, 0.20, 0.01, 0.02, 0.07),  # Case 5\n    ]\n    \n    results = []\n    for case in test_cases:\n        k_star = solve_fpi(case)\n        results.append(k_star)\n\n    # Format results to six decimal places for printing\n    formatted_results = []\n    for res in results:\n        if np.isnan(res):\n            formatted_results.append('nan')\n        else:\n            formatted_results.append(f\"{res:.6f}\")\n\n    # Print the final output in the specified format\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"}, {"introduction": "Real-world modeling often requires moving beyond the simplest functional forms. This practice introduces the more flexible Constant Elasticity of Substitution (CES) production function, where finding the steady-state analytically can be challenging. You will learn to solve for the equilibrium by reframing the problem as a root-finding task and implementing the powerful secant method [@problem_id:2443698]. This exercise demonstrates how to adapt your numerical toolkit to handle more complex and realistic economic models.", "id": "2443698", "problem": "Consider a discrete-time Solow growth model with Harrod-neutral technological progress where aggregate output per efficiency unit is given by a constant elasticity of substitution (CES) production function. Let $k$ denote capital per efficiency unit of labor, $y$ denote output per efficiency unit, $s \\in (0,1)$ denote the constant savings rate, $n \\ge 0$ the population growth rate, $g \\ge 0$ the labor-augmenting technology growth rate, and $\\delta \\in (0,1)$ the depreciation rate. In steady state, capital per efficiency unit $k^{\\ast}$ satisfies the condition\n$$\ns\\, f(k^{\\ast}) = (n+g+\\delta)\\, k^{\\ast}.\n$$\nAssume the per-efficiency-unit production function $f(k)$ is CES with distribution parameter $\\theta \\in (0,1)$ and elasticity of substitution $\\sigma > 0$, defined by\n$$\nf(k) =\n\\begin{cases}\n\\left[\\theta\\, k^{\\rho} + (1-\\theta)\\right]^{1/\\rho}, & \\text{if } \\rho \\ne 0,\\\n$$6pt]\nk^{\\theta}, & \\text{if } \\rho = 0,\n\\end{cases}\n\\quad\\text{where}\\quad \\rho \\equiv \\frac{\\sigma - 1}{\\sigma}.\n$$\nDefine the steady-state residual function\n$$\nF(k) \\equiv s\\, f(k) - (n+g+\\delta)\\, k.\n$$\nA steady state $k^{\\ast}$ is any value $k^{\\ast} > 0$ such that $F(k^{\\ast}) = 0$.\n\nYour task is to write a complete, runnable program that, for each test case below, computes a numerical approximation $\\widehat{k}$ to $k^{\\ast}$ that satisfies the equation $F(\\widehat{k}) = 0$ up to an absolute tolerance of $10^{-10}$, using only the information provided. For each test case, treat the listed pair of positive values as the two starting values for $k$ to initialize your computation. If a test case has no positive solution under the given parameters, or if your computation fails to meet the tolerance within a finite number of steps, you must still output a numeric value; however, in this assignment, all provided cases are constructed to have a unique positive solution.\n\nTest suite (each line is one test case with parameters $(s, n, g, \\delta, \\theta, \\sigma, k_{0}, k_{1})$):\n- Case A: $(s, n, g, \\delta, \\theta, \\sigma, k_{0}, k_{1}) = (\\,0.200,\\ 0.010,\\ 0.020,\\ 0.050,\\ 0.400,\\ 0.800,\\ 0.100,\\ 50.000\\,)$\n- Case B: $(s, n, g, \\delta, \\theta, \\sigma, k_{0}, k_{1}) = (\\,0.200,\\ 0.010,\\ 0.020,\\ 0.050,\\ 0.400,\\ 1.500,\\ 0.100,\\ 20.000\\,)$\n- Case C: $(s, n, g, \\delta, \\theta, \\sigma, k_{0}, k_{1}) = (\\,0.250,\\ 0.015,\\ 0.020,\\ 0.050,\\ 0.300,\\ 0.990,\\ 1.000,\\ 10.000\\,)$\n\nProgram requirements:\n- For each test case, compute a numerical approximation $\\widehat{k}$ to the unique positive steady state $k^{\\ast}$ such that $|F(\\widehat{k})| \\le 10^{-10}$.\n- Use the CES function as defined above with $\\rho = (\\sigma - 1)/\\sigma$ and the Cobb–Douglas limit $f(k) = k^{\\theta}$ when $\\rho = 0$.\n- Output format: Your program should produce a single line of output containing the three results as a comma-separated list enclosed in square brackets, with each $\\widehat{k}$ rounded to $10$ decimal places (for example, $[x_{A},x_{B},x_{C}]$ where each $x_{\\cdot}$ is a float with exactly $10$ digits after the decimal point).", "solution": "The problem requires the computation of the steady-state capital per efficiency unit, denoted as $k^{\\ast}$, for a Solow growth model with a Constant Elasticity of Substitution (CES) production function. The steady state is defined as a positive value $k^{\\ast} > 0$ that satisfies the equilibrium condition:\n$$\ns\\, f(k^{\\ast}) = (n+g+\\delta)\\, k^{\\ast}\n$$\nThis equation can be reformulated as a root-finding problem by defining a residual function $F(k)$:\n$$\nF(k) \\equiv s\\, f(k) - (n+g+\\delta)\\, k\n$$\nThe objective is to find a numerical approximation $\\widehat{k}$ such that $F(\\widehat{k}) = 0$. More precisely, we seek a value $\\widehat{k}$ for which the absolute value of the residual is less than or equal to a specified tolerance, $|F(\\widehat{k})| \\le 10^{-10}$.\n\nThe production function per efficiency unit, $f(k)$, is of the CES type, defined as:\n$$\nf(k) =\n\\begin{cases}\n\\left[\\theta\\, k^{\\rho} + (1-\\theta)\\right]^{1/\\rho}, & \\text{if } \\rho \\ne 0 \\\\\nk^{\\theta}, & \\text{if } \\rho = 0\n\\end{cases}\n$$\nwhere the parameter $\\rho$ is related to the elasticity of substitution $\\sigma$ by the formula $\\rho = (\\sigma - 1)/\\sigma$. The parameters $s$, $n$, $g$, $\\delta$, $\\theta$, and $\\sigma$ are provided for each test case, and all lie within their theoretically valid ranges.\n\nThe problem provides two initial approximations for $k$, which we denote as $k_0$ and $k_1$, for each case. This structure indicates the suitability of a two-point iterative method. We will employ the secant method, which is a well-established and generally efficient root-finding algorithm for such nonlinear equations.\n\nThe secant method generates a sequence of approximations $\\{k_i\\}_{i=0}^{\\infty}$ that, under appropriate conditions, converges to the root $k^{\\ast}$. Given two initial points $k_{i-1}$ and $k_i$, the next point in the sequence, $k_{i+1}$, is calculated as the abscissa of the intersection of the secant line connecting the points $(k_{i-1}, F(k_{i-1}))$ and $(k_i, F(k_i))$ with the horizontal axis. The iterative formula is given by:\n$$\nk_{i+1} = k_i - F(k_i) \\frac{k_i - k_{i-1}}{F(k_i) - F(k_{i-1})}\n$$\nThe computational algorithm proceeds as follows:\n1. Initialize the first two iterates, $k_0$ and $k_1$, using the values provided in the corresponding test case.\n2. Compute the function values at these points, $F_0 = F(k_0)$ and $F_1 = F(k_1)$.\n3. For each iteration $i=1, 2, 3, \\dots$:\n   a. Check if the denominator $F(k_i) - F(k_{i-1})$ is sufficiently far from zero to avoid numerical instability. If it is close to zero, the method's progress stagnates, and the current best estimate should be returned.\n   b. Compute the next approximation $k_{i+1}$ using the secant formula.\n   c. Compute the new residual $F(k_{i+1})$.\n   d. Check for convergence: if $|F(k_{i+1})| \\le 10^{-10}$, the algorithm terminates, and the solution is taken as $\\widehat{k} = k_{i+1}$.\n   e. Otherwise, update the iterates for the next step by setting $k_{i-1} \\leftarrow k_i$ and $k_i \\leftarrow k_{i+1}$.\n4. To guarantee termination, a maximum number of iterations is imposed. As the problem statement assures convergence, this serves as a safeguard for a general-purpose implementation.\n\nFor each test case, the specific parameters $(s, n, g, \\delta, \\theta, \\sigma)$ are used to define the concrete form of the function $F(k)$. The secant method is then applied with the corresponding initial values $(k_0, k_1)$ to find the root $\\widehat{k}$ that satisfies the tolerance requirement. For all provided test cases, the value of $\\sigma$ is not equal to $1$, thus $\\rho \\ne 0$, and the general form of the CES function is applicable.\n\nThe specific parameterizations for the function $F(k)$ are:\n- Case A: $(s, n, g, \\delta, \\theta, \\sigma) = (0.200, 0.010, 0.020, 0.050, 0.400, 0.800)$. The term $(n+g+\\delta)$ equals $0.080$.\n- Case B: $(s, n, g, \\delta, \\theta, \\sigma) = (0.200, 0.010, 0.020, 0.050, 0.400, 1.500)$. The term $(n+g+\\delta)$ equals $0.080$.\n- Case C: $(s, n, g, \\delta, \\theta, \\sigma) = (0.250, 0.015, 0.020, 0.050, 0.300, 0.990)$. The term $(n+g+\\delta)$ equals $0.085$.\n\nThe following program implements this numerical procedure to solve for $\\widehat{k}$ for each case.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the steady-state capital per efficiency unit for a set of test cases\n    using the secant method.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each tuple contains: (s, n, g, delta, theta, sigma, k0, k1)\n    test_cases = [\n        (0.200, 0.010, 0.020, 0.050, 0.400, 0.800, 0.100, 50.000),\n        (0.200, 0.010, 0.020, 0.050, 0.400, 1.500, 0.100, 20.000),\n        (0.250, 0.015, 0.020, 0.050, 0.300, 0.990, 1.000, 10.000)\n    ]\n\n    TOLERANCE = 1e-10\n    MAX_ITER = 100\n\n    def F_residual(k, s, n, g, delta, theta, sigma):\n        \"\"\"\n        Computes the steady-state residual function F(k).\n        F(k) = s*f(k) - (n+g+delta)*k\n        \n        The function assumes k > 0.\n        \"\"\"\n        # CES production function f(k)\n        if np.isclose(sigma, 1.0):\n            # Cobb-Douglas case: f(k) = k^theta\n            # This case is included for completeness but not used by the test data.\n            f_k = np.power(k, theta)\n        else:\n            # General CES case\n            rho = (sigma - 1.0) / sigma\n            # Use numpy.power for robust floating-point exponentiation.\n            f_k = np.power(theta * np.power(k, rho) + (1.0 - theta), 1.0 / rho)\n        \n        # Effective depreciation rate, which is the slope of the break-even investment line.\n        effective_depreciation = n + g + delta\n        \n        return s * f_k - effective_depreciation * k\n\n    def secant_solver(params, k0, k1):\n        \"\"\"\n        Finds the root of F_residual using the secant method.\n        The function takes a tuple of parameters and two initial guesses.\n        \"\"\"\n        s, n, g, delta, theta, sigma = params\n        \n        k_prev, k_curr = float(k0), float(k1)\n\n        f_prev = F_residual(k_prev, s, n, g, delta, theta, sigma)\n        f_curr = F_residual(k_curr, s, n, g, delta, theta, sigma)\n        \n        for _ in range(MAX_ITER):\n            if abs(f_curr) <= TOLERANCE:\n                return k_curr\n\n            # Calculate the denominator for the secant update.\n            delta_f = f_curr - f_prev\n            \n            # If the change in function value is negligible, the method cannot proceed.\n            # Return the current best guess. This is unlikely given the problem's guarantees.\n            if np.isclose(delta_f, 0.0):\n                return k_curr\n            \n            # Secant method update formula.\n            k_next = k_curr - f_curr * (k_curr - k_prev) / delta_f\n            \n            # Update iterates for the next step.\n            k_prev, f_prev = k_curr, f_curr\n            k_curr = k_next\n            f_curr = F_residual(k_curr, s, n, g, delta, theta, sigma)\n            \n        # As per problem instructions, return the last computed value if max iterations are reached.\n        return k_curr\n\n    results = []\n    for case in test_cases:\n        # Unpack parameters and initial guesses for the solver.\n        params_tuple = case[:6]  # s, n, g, delta, theta, sigma\n        k_init_0, k_init_1 = case[6], case[7]\n        \n        # Compute the steady-state capital.\n        k_star_approx = secant_solver(params_tuple, k_init_0, k_init_1)\n        \n        # Format the result to 10 decimal places.\n        results.append(f\"{k_star_approx:.10f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"}, {"introduction": "While steady states describe the long-run destination, the transition path details the economic journey. This advanced exercise tackles the model's dynamics directly by asking you to find the precise starting point that allows an economy to hit a specific target at a future date [@problem_id:2416228]. You will implement a 'shooting algorithm,' a sophisticated technique that combines numerical integration of the model's law of motion with a root-finding search, providing a powerful tool for analyzing dynamic trajectories and policy scenarios.", "id": "2416228", "problem": "You are to write a complete, runnable program that numerically solves the continuous-time Solow growth model in capital per effective worker using a shooting algorithm to meet a terminal condition at a fixed horizon, rather than stepping forward from a given initial condition. The program must implement the following mathematical setup and requirements.\n\nConsider the continuous-time Solow model in capital per effective worker $k(t)$, derived from the standard Solow model with Cobb–Douglas production and exogenous population and technology growth. With a constant savings rate $s \\in (0,1)$, capital depreciation rate $\\delta \\ge 0$, population growth rate $n \\ge 0$, technology growth rate $g \\ge 0$, and output per effective worker production function $f(k) = k^{\\alpha}$ with $\\alpha \\in (0,1)$, the law of motion for capital per effective worker is the first-order autonomous Ordinary Differential Equation (ODE):\n$$\n\\frac{dk(t)}{dt} = s \\, k(t)^{\\alpha} - (n+g+\\delta)\\,k(t).\n$$\nBy construction, $k(t) \\ge 0$ for $t \\ge 0$. The steady state $k^{\\ast}$ satisfies\n$$\n0 = s \\, (k^{\\ast})^{\\alpha} - (n+g+\\delta)\\,k^{\\ast}.\n$$\n\nYour task is to implement a shooting algorithm to find the initial condition $k(0) = k_0$ such that the solution $k(t)$ of the ODE satisfies a terminal condition at a fixed finite time $T > 0$:\n$$\nk(T; k_0) = \\bar{k},\n$$\nwhere $\\bar{k} > 0$ is a given target terminal capital per effective worker. The shooting algorithm must:\n- Define the shooting function $\\phi(k_0) = k(T; k_0) - \\bar{k}$.\n- Numerically integrate the ODE forward in time from $t=0$ to $t = T$ for any proposed $k_0$ to evaluate $k(T; k_0)$.\n- Use a robust one-dimensional root-finding method on $\\phi(k_0)$ with bracketing to determine $k_0$ such that $\\phi(k_0) = 0$, within a numerical tolerance suitable for double-precision computations.\n\nFundamental bases permitted for derivation and algorithm design:\n- The law of motion stated above for $k(t)$ with Cobb–Douglas $f(k)=k^{\\alpha}$.\n- Definitions of steady state, existence and uniqueness of solutions for Lipschitz continuous right-hand sides of ODEs, and the monotonicity (order-preserving property) of solutions for scalar autonomous ODEs with continuous right-hand sides.\n\nImplementation details and numerical requirements:\n- Use a high-accuracy ODE integrator. When relevant, tolerances should be chosen to ensure that the terminal condition is met within a small error.\n- Implement a bracket-expansion strategy to ensure the root of $\\phi(k_0)$ is bracketed before calling a bracketing root solver. Your method must guard against failure by expanding the bracket geometrically until a sign change is observed or until a reasonable cap is reached.\n- Ensure $k(t)$ remains nonnegative; you must initialize $k_0 > 0$ and choose bracketing values accordingly.\n- When computing the steady state $k^{\\ast}$ for parameter sets, use the algebraic condition $s \\, (k^{\\ast})^{\\alpha} = (n+g+\\delta)\\,k^{\\ast}$, noting that $k^{\\ast} > 0$ when $s > 0$ and $n+g+\\delta > 0$, and express it as a function of parameters in your program, not by closed-form in the problem statement.\n\nTest suite:\nYour program must compute $k_0$ for each of the following four parameter sets. For each case, the target terminal capital $\\bar{k}$ is specified in terms of the steady state $k^{\\ast}$ under the same parameters. All scalars must be treated as dimensionless.\n\n- Case A (baseline steady-state target):\n  - $\\alpha = 0.33$, $s = 0.25$, $n = 0.01$, $g = 0.02$, $\\delta = 0.05$, $T = 5.0$, $\\bar{k} = k^{\\ast}$.\n- Case B (below-steady target, shorter horizon):\n  - $\\alpha = 0.33$, $s = 0.25$, $n = 0.01$, $g = 0.02$, $\\delta = 0.05$, $T = 2.0$, $\\bar{k} = 0.5 \\times k^{\\ast}$.\n- Case C (no population or technology growth, above-steady target, long horizon):\n  - $\\alpha = 0.40$, $s = 0.15$, $n = 0.0$, $g = 0.0$, $\\delta = 0.07$, $T = 10.0$, $\\bar{k} = 1.2 \\times k^{\\ast}$.\n- Case D (higher savings, short horizon, slightly below steady state):\n  - $\\alpha = 0.33$, $s = 0.35$, $n = 0.02$, $g = 0.01$, $\\delta = 0.04$, $T = 1.0$, $\\bar{k} = 0.9 \\times k^{\\ast}$.\n\nOutput specification:\n- For each case, compute the required initial capital per effective worker $k_0$ that achieves the terminal condition at time $T$.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order [Case A, Case B, Case C, Case D].\n- Each number must be rounded to six decimal places.\n- Example format (illustrative only): [$1.234567$,$0.500000$,$3.210000$,$0.987654$].\n\nConstraints and expectations:\n- Your solution must be fully numerical: do not use closed-form solutions of the ODE or any transformation that bypasses numerical integration and root finding.\n- The algorithm should be robust to the provided parameter sets and should reliably find $k_0$ whenever a solution exists.\n- All numeric outputs must be floats. No percentages are to be printed. No angle units are involved.", "solution": "The problem presented is a well-posed two-point boundary value problem for a first-order autonomous ordinary differential equation (ODE) that describes the Solow-Swan growth model. It is scientifically grounded in established economic theory and mathematically sound. All parameters and conditions are specified, allowing for a unique and meaningful solution. The problem is therefore deemed valid. We proceed with the derivation of the numerical solution.\n\nThe core of the problem is to find an initial state, the capital per effective worker $k(0) = k_0$, such that the system's trajectory reaches a specified terminal state $\\bar{k}$ at a finite time $T > 0$. The dynamics are governed by the ODE:\n$$\n\\frac{dk(t)}{dt} = s \\, k(t)^{\\alpha} - (n+g+\\delta)\\,k(t)\n$$\nwhere $k(t) \\ge 0$, the savings rate $s \\in (0,1)$, the output elasticity of capital $\\alpha \\in (0,1)$, and the effective depreciation rate is the sum of population growth $n \\ge 0$, technological progress $g \\ge 0$, and capital depreciation $\\delta \\ge 0$. Let $\\lambda = n+g+\\delta$. The ODE is then:\n$$\n\\frac{dk}{dt} = s k^{\\alpha} - \\lambda k\n$$\nThe problem is to solve for $k_0$ in the equation $k(T; k_0) = \\bar{k}$, where $k(t; k_0)$ denotes the unique solution to the ODE with initial condition $k(0)=k_0$.\n\nThis is a boundary value problem, which we will solve using a shooting algorithm as specified. The algorithm transforms the boundary value problem into a root-finding problem. We define a shooting function, $\\phi(k_0)$, whose root corresponds to the desired initial condition $k_0$:\n$$\n\\phi(k_0) = k(T; k_0) - \\bar{k}\n$$\nTo evaluate $\\phi(k_0)$ for a given trial value of $k_0$, we must solve the initial value problem (IVP) for the ODE from $t=0$ to $t=T$. For this purpose, a high-accuracy numerical ODE integrator is required. The `scipy.integrate.solve_ivp` function with a method such as `RK45` or `DOP853` and sufficiently small relative and absolute tolerances (e.g., $10^{-9}$ and $10^{-12}$, respectively) is appropriate.\n\nThe crucial property of the shooting function $\\phi(k_0)$ is its monotonicity. For a scalar autonomous ODE $\\dot{x} = f(x)$ where $f$ is Lipschitz continuous, solution trajectories are ordered. If $x_1(0) > x_2(0)$, then $x_1(t) > x_2(t)$ for all $t > 0$. In our problem, the right-hand side $s k^{\\alpha} - \\lambda k$ is continuously differentiable for $k > 0$, hence Lipschitz continuous on any compact subinterval of $(0, \\infty)$. Therefore, if we choose two initial conditions $k_{0,1} > k_{0,2} > 0$, the corresponding solutions satisfy $k(t; k_{0,1}) > k(t; k_{0,2})$ for all $t > 0$. This implies that $k(T; k_0)$ is a strictly increasing function of $k_0$. Consequently, $\\phi(k_0)$ is also strictly increasing. A strictly monotonic continuous function can have at most one root, which guarantees that if a solution $k_0$ exists, it is unique.\n\nTo find this root, we employ a bracketing root-finder like the Brent-Dekker method, available as `scipy.optimize.brentq`. This method requires an initial interval $[a, b]$ such that $\\phi(a)$ and $\\phi(b)$ have opposite signs. A robust bracketing strategy is therefore essential.\n\nFirst, we determine the non-trivial steady state $k^{\\ast} > 0$, where $\\frac{dk}{dt} = 0$:\n$$\ns(k^{\\ast})^{\\alpha} - \\lambda k^{\\ast} = 0 \\implies s(k^{\\ast})^{\\alpha-1} = \\lambda \\implies k^{\\ast} = \\left(\\frac{s}{\\lambda}\\right)^{\\frac{1}{1-\\alpha}}\n$$\nThis steady state is a global attractor for all $k_0 > 0$. This property informs our bracketing strategy.\nThere is a trivial special case: if the target is the steady state, $\\bar{k} = k^{\\ast}$, the solution is trivially $k_0 = k^{\\ast}$. If $k(0)=k^{\\ast}$, then $\\frac{dk}{dt}=0$, so $k(t)=k^{\\ast}$ for all $t$, and thus $k(T)=k^{\\ast}=\\bar{k}$.\n\nFor the general case $\\bar{k} \\neq k^{\\ast}$, we analyze the dynamics:\n1.  If the target $\\bar{k} < k^{\\ast}$: To reach $\\bar{k}$ at time $T$, the trajectory must be evolving towards $k^{\\ast}$. If we start at $k_0 < k^{\\ast}$, $k(t)$ increases towards $k^{\\ast}$. To end up at $\\bar{k}$ at time $T$, we must start at some $k_0 < \\bar{k}$. Therefore, the root $k_0$ must lie in the interval $(0, \\bar{k})$. This suggests a bracket, for instance, $[\\epsilon, \\bar{k}]$ for some small $\\epsilon > 0$. Let's test this:\n    - $\\phi(\\epsilon) = k(T; \\epsilon) - \\bar{k}$. Since $k(t)$ starts near zero and increases, $k(T; \\epsilon)$ will be small, so $\\phi(\\epsilon) < 0$.\n    - $\\phi(\\bar{k}) = k(T; \\bar{k}) - \\bar{k}$. Since $\\bar{k} < k^{\\ast}$, $\\frac{dk}{dt}|_{k=\\bar{k}} > 0$. Thus, the trajectory starting at $\\bar{k}$ increases, meaning $k(T; \\bar{k}) > \\bar{k}$, and $\\phi(\\bar{k}) > 0$.\n    The interval $[\\epsilon, \\bar{k}]$ indeed brackets the root.\n\n2.  If the target $\\bar{k} > k^{\\ast}$: To reach $\\bar{k}$ at time $T$, the trajectory must be evolving towards $k^{\\ast}$. If we start at $k_0 > k^{\\ast}$, $k(t)$ decreases towards $k^{\\ast}$. To end up at $\\bar{k}$ at time $T$, we must start at some $k_0 > \\bar{k}$. The root $k_0$ must lie in the interval $(\\bar{k}, \\infty)$. This suggests an initial trial bracket like $[\\bar{k}, M]$ for some $M > \\bar{k}$. Let's test this:\n    - $\\phi(\\bar{k}) = k(T; \\bar{k}) - \\bar{k}$. Since $\\bar{k} > k^{\\ast}$, $\\frac{dk}{dt}|_{k=\\bar{k}} < 0$. The trajectory starting at $\\bar{k}$ decreases, so $k(T; \\bar{k}) < \\bar{k}$, and $\\phi(\\bar{k}) < 0$.\n    - For a sufficiently large upper bound $M$, $k(T; M)$ will also be large, specifically $k(T; M) > \\bar{k}$, hence $\\phi(M) > 0$.\n    Thus an interval like $[\\bar{k}, 2\\bar{k}]$ is a plausible starting point.\n\nTo meet the problem's strict requirement for a robust bracket-expansion strategy, we implement the following general procedure:\nStart with an initial bracket $[a, b]$, for instance, guided by the logic above. If $\\phi(a) \\cdot \\phi(b) \\ge 0$, expand the bracket geometrically. Since $\\phi$ is increasing:\n- If $\\phi(a) > 0$ and $\\phi(b) > 0$, the root is smaller than $a$. Update the bracket to $[a/F, a]$ for some factor $F>1$.\n- If $\\phi(a) < 0$ and $\\phi(b) < 0$, the root is larger than $b$. Update the bracket to $[b, b \\cdot F]$.\nThis expansion is repeated until a sign change is detected or a maximum number of iterations is reached, to prevent failure. This systematic approach ensures the preconditions for the bracketing root-finder are met.\n\nThe final algorithm for each test case is as follows:\n1.  Compute $\\lambda = n+g+\\delta$ and $k^{\\ast} = (s/\\lambda)^{1/(1-\\alpha)}$.\n2.  Compute the target value $\\bar{k}$ based on $k^{\\ast}$.\n3.  If $\\bar{k} = k^{\\ast}$, the result is $k_0 = k^{\\ast}$.\n4.  Otherwise, define the shooting function $\\phi(k_0)$ which internally solves the ODE IVP.\n5.  Establish an initial bracket $[a, b]$ based on the relation between $\\bar{k}$ and $k^{\\ast}$.\n6.  If this is not a valid bracket, iteratively expand it until $\\phi(a) \\cdot \\phi(b) < 0$.\n7.  Use `scipy.optimize.brentq` on $\\phi$ with the located bracket $[a, b]$ to find the root $k_0$.\n8.  Store the resulting $k_0$, rounded to the specified precision.\nThis procedure will be implemented for all provided test cases.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Numerically solves the continuous-time Solow growth model for the initial condition k_0\n    that results in a specific terminal condition k(T) = k_bar, using a shooting algorithm.\n    \"\"\"\n\n    # Test cases from the problem statement:\n    # (alpha, s, n, g, delta, T, k_bar_factor)\n    test_cases = [\n        (0.33, 0.25, 0.01, 0.02, 0.05, 5.0, 1.0),    # Case A\n        (0.33, 0.25, 0.01, 0.02, 0.05, 2.0, 0.5),    # Case B\n        (0.40, 0.15, 0.0,  0.0,  0.07, 10.0, 1.2),   # Case C\n        (0.33, 0.35, 0.02, 0.01, 0.04, 1.0, 0.9),    # Case D\n    ]\n\n    results = []\n    \n    # Constants for numerical methods\n    BRACKET_EXPAND_FACTOR = 2.0\n    BRACKET_MAX_ITER = 100\n    ODE_RTOL = 1e-9\n    ODE_ATOL = 1e-12\n    # A small positive number to avoid k=0 issues\n    EPSILON = 1e-9\n\n    for case in test_cases:\n        alpha, s, n, g, delta, T, k_bar_factor = case\n        \n        # Effective depreciation rate\n        lambd = n + g + delta\n        \n        # Calculate the steady state k* if it exists and is positive\n        if lambd <= 0 or s <= 0:\n            # For the given problem constraints, this branch is not taken\n            raise ValueError(\"Invalid parameters: steady state is not well-defined and positive.\")\n        \n        k_star = (s / lambd)**(1 / (1 - alpha))\n        \n        # Calculate the target terminal capital k_bar\n        k_bar = k_bar_factor * k_star\n        \n        # Special case: If target is the steady state, the solution is trivial.\n        if np.isclose(k_bar, k_star):\n            results.append(k_star)\n            continue\n            \n        # Define the right-hand side of the ODE dk/dt = s*k^alpha - lambda*k\n        def solow_ode(t, k, alpha_p, s_p, lambd_p):\n            # Ensure k is not negative, which can happen due to numerical error\n            k_val = max(k[0], 0.0)\n            return [s_p * (k_val**alpha_p) - lambd_p * k_val]\n\n        # Define the shooting function phi(k0) = k(T, k0) - k_bar\n        def shooting_function(k0):\n            if k0 <= 0:\n                # k0 must be positive. For k0->0+, k(t)->0, so phi < 0 for k_bar > 0.\n                return -k_bar\n            \n            # Solve the IVP from t=0 to T with initial condition k0\n            sol = solve_ivp(\n                fun=lambda t, y: solow_ode(t, y, alpha, s, lambd),\n                t_span=[0, T],\n                y0=[k0],\n                method='DOP853',\n                rtol=ODE_RTOL,\n                atol=ODE_ATOL\n            )\n            \n            k_T = sol.y[0, -1]\n            return k_T - k_bar\n\n        # --- Bracket finding logic ---\n        # Use model dynamics to propose an intelligent initial bracket\n        if k_bar < k_star:\n            # We expect k0 < k_bar. Root is in (0, k_bar].\n            bracket_low = EPSILON\n            bracket_high = k_bar\n        else: # k_bar > k_star\n            # We expect k0 > k_bar. Root is in (k_bar, infinity).\n            bracket_low = k_bar\n            bracket_high = k_bar * BRACKET_EXPAND_FACTOR\n            \n        val_low = shooting_function(bracket_low)\n        val_high = shooting_function(bracket_high)\n\n        # Expand bracket if root is not bracketed by the initial guess\n        for _ in range(BRACKET_MAX_ITER):\n            if val_low * val_high < 0:\n                break # Bracket found\n\n            # Since the shooting function is monotonically increasing:\n            if val_low < 0 and val_high < 0:\n                # Both points are below the root, expand to the right\n                bracket_low = bracket_high\n                bracket_high *= BRACKET_EXPAND_FACTOR\n                val_low = val_high\n                val_high = shooting_function(bracket_high)\n            elif val_low > 0 and val_high > 0:\n                # Both points are above the root, expand to the left\n                bracket_high = bracket_low\n                bracket_low /= BRACKET_EXPAND_FACTOR\n                # Ensure lower bound remains positive\n                bracket_low = max(bracket_low, EPSILON)\n                val_high = val_low\n                val_low = shooting_function(bracket_low)\n            else: # One of the ends is already the root\n                break \n        else:\n            raise RuntimeError(f\"Failed to find a bracket for case: {case}\")\n            \n        # Use a robust root-finding algorithm (Brent's method)\n        k0_solution = brentq(shooting_function, bracket_low, bracket_high)\n        results.append(k0_solution)\n\n    # Format the final output as specified\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```"}]}