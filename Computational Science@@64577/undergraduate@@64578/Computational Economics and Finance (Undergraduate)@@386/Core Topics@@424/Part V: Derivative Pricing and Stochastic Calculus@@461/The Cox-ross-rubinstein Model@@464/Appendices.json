{"hands_on_practices": [{"introduction": "The theoretical price derived from the Cox-Ross-Rubinstein model is not just an abstract number; it represents the precise initial capital needed to perfectly replicate the option's payoff. This exercise brings that core concept to life by tasking you with implementing a dynamic Delta-hedging strategy. By tracking the portfolio's value against the option's theoretical price along a specific path, you will empirically verify the principle of perfect replication and see that, in an ideal frictionless market, the hedging error is theoretically zero [@problem_id:2412792].", "id": "2412792", "problem": "You are given a discrete-time, multi-period binomial asset pricing model. Let the underlying asset price process $\\{S_{t}\\}_{t=0}^{N}$ follow multiplicative dynamics where, in each period, the price either moves up by a factor $u$ or down by a factor $d$, with $u&gt;d&gt;0$. The per-period gross risk-free return is $R$, with the no-arbitrage condition $d&lt;R&lt;u$. Consider a European call option written on this asset with strike $K$ and maturity at time step $N$. Let $C_{t}$ denote the unique no-arbitrage time-$t$ value of the option at a given node, computed under the risk-neutral measure with probability $q=(R-d)/(u-d)$, and terminal condition $C_{N}=\\max(S_{N}-K,0)$. At each non-terminal node, define the local Delta as the number of shares in the replicating portfolio,\n$$\n\\Delta_{t}=\\frac{C_{t+1}^{(u)}-C_{t+1}^{(d)}}{S_{t+1}^{(u)}-S_{t+1}^{(d)}},\n$$\nwhere superscripts indicate the value in the up- or down-child node.\n\nA trader is short one unit of the call at time $0$, receives the premium $C_{0}$, and dynamically hedges the short position by holding $\\Delta_{t}$ shares and a risk-free account position $B_{t}$, with zero transaction costs and a self-financing constraint. The initial hedge satisfies $B_{0}=C_{0}-\\Delta_{0}S_{0}$. Along a realized price path of length $N$, let the pre-rebalancing hedging error at the end of period $t$ be\n$$\ne_{t}=\\Delta_{t-1}S_{t}+B_{t-1}R-C_{t},\\quad t=1,2,\\dots,N,\n$$\nwhere $C_{t}$ is the option value at the reached node at time $t$, with $C_{N}=\\max(S_{N}-K,0)$. After measuring $e_{t}$, the hedge is rebalanced to $\\Delta_{t}$ at time $t$ for $t=1,2,\\dots,N-1$.\n\nYour task is to implement a program that, for each given parameter set and realized path, constructs the binomial price tree, computes the option value tree, implements the dynamic Delta-hedging strategy for the short call as defined above, and returns the sequence $\\{e_{t}\\}_{t=1}^{N}$ along the path. All values must be expressed as decimals (no percentage signs), and each $e_{t}$ must be rounded to $10$ decimal places.\n\nTest Suite. For each case below, use the provided parameters and realized path of up/down moves, where $U$ denotes an up move by factor $u$ and $D$ denotes a down move by factor $d$:\n- Case $1$ (general multi-period path): $S_{0}=100.0$, $u=1.1$, $d=0.9$, $R=1.02$, $K=100.0$, $N=4$, path $[U,D,U,U]$.\n- Case $2$ (boundary, single period): $S_{0}=50.0$, $u=1.2$, $d=0.8$, $R=1.0$, $K=50.0$, $N=1$, path $[U]$.\n- Case $3$ (edge, zero interest and all downs): $S_{0}=80.0$, $u=1.25$, $d=0.8$, $R=1.0$, $K=90.0$, $N=3$, path $[D,D,D]$.\n- Case $4$ (edge, deep in-the-money and all ups): $S_{0}=100.0$, $u=1.2$, $d=0.8$, $R=1.01$, $K=80.0$, $N=3$, path $[U,U,U]$.\n\nRequired final output format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each element of this list must be the list of rounded hedging errors $[e_{1},e_{2},\\dots,e_{N}]$ for the corresponding test case. For example, an output with two cases should look like $[[e_{1}^{(1)},\\dots,e_{N\\_{1}}^{(1)}],[e_{1}^{(2)},\\dots,e_{N\\_{2}}^{(2)}]]$ with no spaces anywhere in the line.", "solution": "The problem statement is subjected to validation.\n\nGivens are extracted verbatim:\n- Asset price process: $\\{S_{t}\\}_{t=0}^{N}$ following a multiplicative binomial model.\n- Up-move factor: $u$. Down-move factor: $d$. With $u > d > 0$.\n- Per-period gross risk-free return: $R$.\n- No-arbitrage condition: $d < R < u$.\n- Derivative: European call option, strike $K$, maturity $N$.\n- Option value: $C_{t}$ at time $t$.\n- Terminal condition: $C_{N} = \\max(S_{N}-K, 0)$.\n- Risk-neutral probability of an up move: $q = \\frac{R-d}{u-d}$.\n- Option valuation: under the risk-neutral measure, implying $C_{t} = R^{-1}[q C_{t+1}^{(u)} + (1-q) C_{t+1}^{(d)}]$.\n- Replicating portfolio Delta: $\\Delta_{t}=\\frac{C_{t+1}^{(u)}-C_{t+1}^{(d)}}{S_{t+1}^{(u)}-S_{t+1}^{(d)}}$.\n- Hedging strategy: Short one call option, hedge with $\\Delta_{t}$ shares and a risk-free account position $B_{t}$.\n- Initial hedge: $B_{0}=C_{0}-\\Delta_{0}S_{0}$.\n- Pre-rebalancing hedging error: $e_{t}=\\Delta_{t-1}S_{t}+B_{t-1}R-C_{t}$ for $t=1, 2, \\dots, N$.\n- Rebalancing: The hedge is rebalanced to $\\Delta_{t}$ at time $t$ for $t=1, 2, \\dots, N-1$ under a self-financing constraint.\n- Test cases: Four specific sets of parameters ($S_{0}, u, d, R, K, N$) and realized paths are provided.\n- Output requirement: A list of lists of hedging errors $\\{e_{t}\\}_{t=1}^{N}$ for each case, rounded to $10$ decimal places.\n\nValidation verdict: The problem is valid.\nIt is scientifically grounded, being a standard exercise in the Cox-Ross-Rubinstein binomial option pricing model, a fundamental concept in computational finance. The problem is well-posed; all parameters, definitions, and constraints are provided, ensuring a unique solution can be computationally determined. The definitions of option value, risk-neutral probability, and delta are standard and correct. The problem is objective and contains no ambiguities. The no-arbitrage condition is correctly stated and satisfied by the test cases. The core of the problem is to verify the central claim of the binomial model: that a derivative's payoff can be perfectly replicated by a dynamic, self-financing trading strategy in the underlying asset and a risk-free bond. The hedging error, as defined, should therefore be theoretically zero at all time steps, with any non-zero results attributable only to floating-point numerical precision.\n\nA complete solution is now presented. The methodology is structured upon the foundational principles of discrete-time asset pricing.\n\nFirst, we construct the binomial lattice for the underlying asset price, $\\{S_{t}\\}_{t=0}^{N}$. A node in the tree at time step $i$ ($0 \\le i \\le N$) after $j$ up-moves ($0 \\le j \\le i$) has a price given by:\n$$S_{i,j} = S_{0} u^{j} d^{i-j}$$\n\nSecond, we determine the option value at each node of the tree. This is done by backward induction, starting from the known option values at maturity, $t=N$. The value of the European call option at maturity is its intrinsic value:\n$$C_{N,j} = \\max(S_{N,j} - K, 0) \\quad \\text{for } j = 0, 1, \\dots, N$$\nFor any non-terminal node $(i,j)$ where $i < N$, the no-arbitrage option value $C_{i,j}$ is the discounted expected value of the option in the next period, computed under the risk-neutral measure. The risk-neutral probability of an up-move is $q = \\frac{R-d}{u-d}$. The valuation formula is:\n$$C_{i,j} = \\frac{1}{R} \\left[ q C_{i+1,j+1} + (1-q) C_{i+1,j} \\right]$$\nThis backward recursive calculation populates the entire option value tree, $\\{C_{i,j}\\}$.\n\nThird, we implement the dynamic hedging strategy along a specified path of asset price moves. The strategy involves creating a portfolio of $\\Delta_{t}$ shares of the asset and a cash position $B_{t}$ in a risk-free account. The value of this portfolio at time $t$ is $V_t = \\Delta_t S_t + B_t$.\n\nThe strategy is initiated at $t=0$. The initial portfolio is constructed to replicate the option's value, $V_0 = C_0$. The number of shares, $\\Delta_0$, is given by the delta-hedging formula:\n$$\\Delta_{0} = \\frac{C_{1,1} - C_{1,0}}{S_{1,1} - S_{1,0}}$$\nThe initial cash position, $B_0$, is then set to ensure the portfolio value matches the option value: $B_{0} = C_{0,0} - \\Delta_{0}S_{0,0}$.\n\nThe portfolio is self-financing. This means that for any subsequent period $t > 0$, any change in the portfolio composition is financed internally, with no external cash infusions or withdrawals. At the beginning of a period $t$ (after the price move from $t-1$), the value of the portfolio from the previous period, $(\\Delta_{t-1}, B_{t-1})$, has evolved to:\n$$V_{t}^{-} = \\Delta_{t-1}S_{t} + B_{t-1}R$$\nThe problem defines the hedging error at time $t$ as the difference between this portfolio value and the theoretical option price $C_{t}$ at the new node:\n$$e_{t} = V_{t}^{-} - C_{t}$$\nA core result of the binomial model is that the replicating portfolio's value, $V_{t}^{-}$, will exactly match the option's value, $C_{t}$, at each node. Therefore, we expect $e_t = 0$ for all $t$, subject to numerical precision.\n\nAfter calculating the error, the portfolio is rebalanced for the next period (if $t < N$). The new number of shares, $\\Delta_t$, is calculated based on the current node's successor values:\n$$\\Delta_{t} = \\frac{C_{t+1}^{\\text{(up)}} - C_{t+1}^{\\text{(down)}}}{S_{t+1}^{\\text{(up)}} - S_{t+1}^{\\text{(down)}}}$$\nThe new cash position, $B_t$, is determined by the self-financing condition. The value of the portfolio is preserved during rebalancing, so the post-rebalancing value $V_t^{+} = \\Delta_t S_t + B_t$ must equal the pre-rebalancing value $V_t^{-}$. Thus, the new cash position is:\n$$B_{t} = V_{t}^{-} - \\Delta_{t}S_{t}$$\nThis process of moving along the path, calculating hedging error, and rebalancing is repeated until maturity at $t=N$. The sequence of calculated errors $\\{e_t\\}_{t=1}^N$ is the final result for the given path.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n\n    test_cases = [\n        {'S0': 100.0, 'u': 1.1, 'd': 0.9, 'R': 1.02, 'K': 100.0, 'N': 4, 'path': ['U', 'D', 'U', 'U']},\n        {'S0': 50.0, 'u': 1.2, 'd': 0.8, 'R': 1.0, 'K': 50.0, 'N': 1, 'path': ['U']},\n        {'S0': 80.0, 'u': 1.25, 'd': 0.8, 'R': 1.0, 'K': 90.0, 'N': 3, 'path': ['D', 'D', 'D']},\n        {'S0': 100.0, 'u': 1.2, 'd': 0.8, 'R': 1.01, 'K': 80.0, 'N': 3, 'path': ['U', 'U', 'U']}\n    ]\n\n    results = []\n    for case in test_cases:\n        errors = _calculate_hedging_errors(\n            S0=case['S0'],\n            u=case['u'],\n            d=case['d'],\n            R=case['R'],\n            K=case['K'],\n            N=case['N'],\n            path=case['path']\n        )\n        results.append(errors)\n    \n    # Format the final output string precisely as required.\n    inner_parts = []\n    for err_list in results:\n        # Format each error to a string with the required precision.\n        # Although the errors are theoretically zero, they may be small non-zero floats.\n        # We ensure standard float representation e.g. '0.0' instead of '0'\n        # The rounding is already done, this is for formatting.\n        formatted_list = [f\"{err:.10f}\".rstrip('0').rstrip('.') if err != 0 else '0.0' for err in err_list]\n        inner_parts.append(f\"[{','.join(formatted_list)}]\")\n        \n    final_output = f\"[{','.join(inner_parts)}]\"\n    print(final_output)\n\ndef _calculate_hedging_errors(S0: float, u: float, d: float, R: float, K: float, N: int, path: list[str]) -> list[float]:\n    \"\"\"\n    Calculates the sequence of dynamic hedging errors for a given path.\n\n    Args:\n        S0: Initial asset price.\n        u: Up-move factor.\n        d: Down-move factor.\n        R: Gross risk-free return per period.\n        K: Option strike price.\n        N: Number of periods to maturity.\n        path: A list of 'U' or 'D' strings representing the realized path.\n\n    Returns:\n        A list of hedging errors {e_t} for t=1,...,N, rounded to 10 decimal places.\n    \"\"\"\n    # 1. Construct asset price and option value trees\n    # Risk-neutral probability\n    q = (R - d) / (u - d)\n\n    # Initialize trees\n    S_tree = np.zeros((N + 1, N + 1))\n    C_tree = np.zeros((N + 1, N + 1))\n\n    # Populate asset price tree S[i,j] = price at time i after j up-moves\n    for i in range(N + 1):\n        for j in range(i + 1):\n            S_tree[i, j] = S0 * (u**j) * (d**(i - j))\n\n    # Populate option value tree at maturity (t=N)\n    C_tree[N, :] = np.maximum(S_tree[N, :] - K, 0)\n\n    # Populate option value tree by backward induction\n    for i in range(N - 1, -1, -1):\n        for j in range(i + 1):\n            C_up = C_tree[i + 1, j + 1]\n            C_down = C_tree[i + 1, j]\n            C_tree[i, j] = (q * C_up + (1 - q) * C_down) / R\n\n    # 2. Trace the path and compute hedging errors\n    hedging_errors = []\n    \n    # Initial portfolio setup at t=0\n    num_ups = 0  # number of up moves from t=0\n    \n    # Initial delta (Delta_0)\n    delta_prev = (C_tree[1, 1] - C_tree[1, 0]) / (S_tree[1, 1] - S_tree[1, 0])\n    \n    # Initial bond position (B_0)\n    B_prev = C_tree[0, 0] - delta_prev * S_tree[0, 0]\n\n    # Iterate along the path from t=1 to N\n    for t in range(1, N + 1):\n        # Determine current node based on path\n        move = path[t - 1]\n        if move == 'U':\n            num_ups += 1\n        \n        # Current asset and option values at node (t, num_ups)\n        current_S = S_tree[t, num_ups]\n        current_C = C_tree[t, num_ups]\n        \n        # Value of hedge portfolio before rebalancing\n        portfolio_val_pre_rebalance = delta_prev * current_S + B_prev * R\n        \n        # Calculate hedging error e_t\n        error = portfolio_val_pre_rebalance - current_C\n        hedging_errors.append(round(error, 10))\n\n        # Rebalance the portfolio for the next period (if not at maturity)\n        if t < N:\n            # Calculate new delta (Delta_t) at the current node\n            delta_curr = (C_tree[t + 1, num_ups + 1] - C_tree[t + 1, num_ups]) / \\\n                         (S_tree[t + 1, num_ups + 1] - S_tree[t + 1, num_ups])\n            \n            # Calculate new bond position (B_t) to maintain self-financing\n            # New portfolio value V_t+ must equal V_t-\n            B_curr = portfolio_val_pre_rebalance - delta_curr * current_S\n            \n            # Update portfolio for the next iteration\n            delta_prev = delta_curr\n            B_prev = B_curr\n\n    return hedging_errors\n\nif __name__ == \"__main__\":\n    solve()\n```"}, {"introduction": "Building on the foundational replication principle, we now apply the CRR framework to a more sophisticated derivative: the forward-start option. This practice challenges you to derive a pricing formula from first principles, rather than relying on a pre-packaged solution. The key insight lies in leveraging the martingale property of the discounted asset price to simplify the valuation, demonstrating how complex problems can be broken down into manageable parts [@problem_id:2439216].", "id": "2439216", "problem": "Consider the Cox–Ross–Rubinstein (CRR) binomial asset pricing model under no-arbitrage. An asset price process $\\{S_n\\}_{n=0}^{N}$ evolves over $N$ discrete periods, where at each step the asset either moves up by a factor $u$ or down by a factor $d$, so that $S_{n+1} \\in \\{u S_n, d S_n\\}$. The per-period risk-free gross rate is $R$, assumed constant over time, with no-arbitrage condition $d < R < u$. Under the risk-neutral probability $p$, defined by the fundamental theorem of asset pricing through $p = (R - d)/(u - d)$, the discounted asset price $\\{S_n / R^n\\}$ is a martingale and the time-$0$ price of any contingent claim with maturity $N$ equals its risk-neutral discounted expectation.\n\nA forward-start European call option is specified by an activation time $t_1$ corresponding to step index $m \\in \\{0,1,\\dots,N\\}$. At time $m$, the strike is set to be the then-prevailing asset price, $K = S_m$. The option expires at time $N$ with payoff $(S_N - S_m)^{+}$, where $(x)^{+} = \\max\\{x, 0\\}$.\n\nTask: Starting only from the core definitions above (binomial dynamics, no-arbitrage, risk-neutral pricing, and discounted martingale property), derive an algorithm to compute the time-$0$ price of this forward-start call option for arbitrary inputs $(S_0, u, d, R, N, m)$ satisfying $d < R < u$ and $0 \\le m \\le N$. Your program must implement this algorithm without using any continuous-time approximations or external formulas beyond these principles. The implementation should use a numerically stable computation of risk-neutral expectations, and must handle edge cases such as $m = 0$ and $m = N$.\n\nInput and output specification for testing: Your program should hard-code the following test suite of parameter sets, each given as a tuple $(S_0, u, d, R, N, m)$:\n\n- Test $1$ (general case): $(100.0, 1.1, 0.9, 1.02, 6, 2)$.\n- Test $2$ (boundary $m = 0$): $(100.0, 1.1, 0.9, 1.02, 6, 0)$.\n- Test $3$ (boundary $m = N$): $(75.0, 1.08, 0.93, 1.01, 5, 5)$.\n- Test $4$ (zero interest per step $R = 1$ with symmetric factors): $(50.0, 1.2, 1.0/1.2, 1.0, 4, 1)$.\n- Test $5$ (short remaining horizon after $m$): $(80.0, 1.05, 0.95, 1.01, 10, 7)$.\n\nThe required final output format is a single line containing the prices for the tests, in order, as a comma-separated list enclosed in square brackets. Each price must be a real number rounded to exactly $6$ decimal places. For example, an output with three hypothetical results should look like: \"[12.345678,0.000000,3.210000]\".", "solution": "We work in the Cox–Ross–Rubinstein (CRR) binomial model with no-arbitrage condition $d < R < u$. By the fundamental theorem of asset pricing, there exists a risk-neutral probability $p = \\frac{R - d}{u - d}$ under which the discounted asset price process $\\left\\{\\frac{S_n}{R^n}\\right\\}_{n=0}^{N}$ is a martingale. The time-$0$ price $V_0$ of any contingent claim $X_N$ measurable at time $N$ is given by $V_0 = \\mathbb{E}^{\\mathbb{Q}}\\!\\left[R^{-N} X_N\\right]$, where $\\mathbb{Q}$ denotes the risk-neutral measure.\n\nWe consider a forward-start European call option that becomes active at step $m$ with strike $K = S_m$ and expires at step $N$, with payoff $X_N = (S_N - S_m)^{+}$. To compute its time-$0$ price, we use two fundamental principles:\n\n1. Risk-neutral pricing for the sub-horizon from $m$ to $N$.\n2. The martingale property of the discounted asset.\n\nFix the filtration $\\{\\mathcal{F}_n\\}$ generated by the binomial process. At time $m$, conditional on $\\mathcal{F}_m$, the payoff can be rewritten as\n$$\nX_N = \\left(S_N - S_m\\right)^{+} = S_m \\left(\\frac{S_N}{S_m} - 1\\right)^{+}.\n$$\nDefine the multiplicative return over the sub-horizon as\n$$\nY := \\frac{S_N}{S_m},\n$$\nwhich depends only on the $N - m$ coin flips after time $m$; in particular, $Y \\in \\{u^k d^{(N-m)-k} : k = 0,1,\\dots,N-m\\}$. The time-$m$ value is then\n$$\nV_m = \\mathbb{E}^{\\mathbb{Q}}\\!\\left[R^{-(N-m)} X_N \\,\\middle|\\, \\mathcal{F}_m \\right]\n= \\mathbb{E}^{\\mathbb{Q}}\\!\\left[R^{-(N-m)} S_m (Y - 1)^{+} \\,\\middle|\\, \\mathcal{F}_m \\right].\n$$\nBecause $S_m$ is $\\mathcal{F}_m$-measurable and $Y$ depends only on future moves given $\\mathcal{F}_m$, we can factor out $S_m$:\n$$\nV_m = S_m \\cdot \\underbrace{\\mathbb{E}^{\\mathbb{Q}}\\!\\left[R^{-(N-m)} (Y - 1)^{+} \\right]}_{=: c_{\\text{rel}}}.\n$$\nThe quantity $c_{\\text{rel}}$ is deterministic (it does not depend on the realized $S_m$), since it depends only on $u$, $d$, $R$, and the number of steps $N - m$. Therefore,\n$$\nV_m = S_m \\, c_{\\text{rel}}.\n$$\n\nNext, apply risk-neutral valuation from time $0$ to time $m$:\n$$\nV_0 = \\mathbb{E}^{\\mathbb{Q}}\\!\\left[R^{-m} V_m \\right] = \\mathbb{E}^{\\mathbb{Q}}\\!\\left[R^{-m} S_m \\right] \\, c_{\\text{rel}}.\n$$\nBy the martingale property of discounted prices, $\\mathbb{E}^{\\mathbb{Q}}\\!\\left[R^{-m} S_m\\right] = S_0$. Hence,\n$$\nV_0 = S_0 \\, c_{\\text{rel}}.\n$$\n\nIt remains to compute $c_{\\text{rel}}$ from first principles. Under $\\mathbb{Q}$, the number of up moves $K$ in $N - m$ steps is binomial with parameters $n := N - m$ and $p = \\frac{R - d}{u - d}$. The multiplicative return is $Y = u^{K} d^{n-K}$. Thus,\n$$\nc_{\\text{rel}} = R^{-n} \\sum_{k=0}^{n} \\binom{n}{k} p^{k} (1-p)^{n-k} \\, \\max\\!\\left(u^{k} d^{n-k} - 1, 0\\right).\n$$\nThis formula is obtained directly from the risk-neutral discounted expectation and the binomial distribution of future up moves. Two boundary checks follow immediately:\n- If $m = N$, then $n = 0$ and $Y = 1$, hence $\\max(Y - 1, 0) = 0$ and $c_{\\text{rel}} = 0$, giving $V_0 = 0$.\n- If $m = 0$, then $V_0 = S_0 \\, c_{\\text{rel}}$ equals the time-$0$ price of an at-the-money call with $K = S_0$ over $N$ steps, consistent with the definition of a forward-start option that activates immediately.\n\nAlgorithmic design:\n- Input $(S_0, u, d, R, N, m)$ with $d < R < u$ and $0 \\le m \\le N$.\n- Compute $n \\leftarrow N - m$. If $n = 0$, return $0.0$.\n- Compute $p \\leftarrow (R - d)/(u - d)$ and $q \\leftarrow 1 - p$.\n- Compute\n$$\nc_{\\text{rel}} \\leftarrow R^{-n} \\sum_{k=0}^{n} \\binom{n}{k} p^{k} q^{n-k} \\, \\max\\!\\left(u^{k} d^{n-k} - 1, 0\\right).\n$$\n- Return $V_0 \\leftarrow S_0 \\cdot c_{\\text{rel}}$.\n- For numerical stability, compute $\\binom{n}{k} p^{k} q^{n-k}$ either via recursive updates of the binomial probability mass function or using exact integer binomial coefficients with floating-point powers when $n$ is modest. The tests here use modest $n$, so either approach is stable. Results are rounded to $6$ decimal places.\n\nThis construction uses only core principles: the existence of a risk-neutral measure under no-arbitrage, the martingale property of discounted prices, and the definition of risk-neutral pricing as discounted expectation. It avoids any continuous-time approximations and relies solely on the binomial structure and elementary probability.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef forward_start_call_price_crr(S0, u, d, R, N, m):\n    \"\"\"\n    Price a forward-start European call in the CRR model.\n    At time m, the strike is set to S_m; maturity at N; payoff is (S_N - S_m)+.\n    Parameters:\n        S0 : float, initial asset price S_0\n        u  : float, up factor per step\n        d  : float, down factor per step\n        R  : float, risk-free gross rate per step\n        N  : int, total number of steps to maturity\n        m  : int, activation step (0 <= m <= N)\n    Returns:\n        float, time-0 price\n    \"\"\"\n    # Handle trivial case: if m == N, payoff is zero.\n    n = N - m\n    if n == 0:\n        return 0.0\n\n    # Risk-neutral probability\n    p = (R - d) / (u - d)\n    q = 1.0 - p\n\n    # Compute c_rel = E[ R^{-n} * max(Y - 1, 0) ] with Y = u^K d^{n-K}, K ~ Bin(n,p)\n    # Use exact binomial coefficients for modest n.\n    c_rel = 0.0\n    R_disc = R ** (-n)\n    # To avoid redundant power computations, precompute powers if beneficial\n    # but here n is small in tests; we compute directly for clarity.\n    for k in range(n + 1):\n        # Binomial probability\n        comb = math.comb(n, k)\n        prob = comb * (p ** k) * (q ** (n - k))\n        # Relative terminal factor\n        y = (u ** k) * (d ** (n - k))\n        payoff = y - 1.0\n        if payoff > 0.0:\n            c_rel += prob * payoff\n\n    c_rel *= R_disc\n    return S0 * c_rel\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case is (S0, u, d, R, N, m)\n    test_cases = [\n        (100.0, 1.1, 0.9, 1.02, 6, 2),                         # Test 1\n        (100.0, 1.1, 0.9, 1.02, 6, 0),                         # Test 2 (m=0)\n        (75.0, 1.08, 0.93, 1.01, 5, 5),                        # Test 3 (m=N -> price 0)\n        (50.0, 1.2, 1.0/1.2, 1.0, 4, 1),                       # Test 4 (R=1, symmetric u,d)\n        (80.0, 1.05, 0.95, 1.01, 10, 7),                       # Test 5 (short remaining horizon)\n    ]\n\n    results = []\n    for case in test_cases:\n        S0, u, d, R, N, m = case\n        price = forward_start_call_price_crr(S0, u, d, R, N, m)\n        results.append(f\"{price:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"}, {"introduction": "The standard CRR model assumes a perfect, frictionless market, but what happens when we introduce real-world imperfections? This exercise explores the consequences of having different interest rates for borrowing and lending. You will discover that the unique no-arbitrage price is replaced by a no-arbitrage price *range*, bounded by the seller's cost to super-replicate the payoff and the buyer's proceeds from sub-replicating it, providing a fundamental basis for understanding bid-ask spreads in financial markets [@problem_id:2439179].", "id": "2439179", "problem": "Consider a two-period Cox-Ross-Rubinstein (CRR) binomial market with a risky asset and a bank account in discrete time. The risky asset has initial price $S_{0} = 100$, and in each period it moves up by a factor $u = 1.2$ or down by a factor $d = 0.9$, independently across periods. The bank account has asymmetric simple interest rates: if a self-financing strategy’s cash position is nonnegative over a period, it accrues at the lending rate $r_{l} = 0.02$ for that period; if the cash position is negative, it accrues at the borrowing rate $r_{b} = 0.08$ for that period. There are no dividends, no transaction costs, and trading is frictionless except for the borrowing–lending rate asymmetry. Assume short selling of the stock is allowed and that the asymmetry applies period-by-period based on the sign of the strategy’s cash position at the start of each period.\n\nLet $C$ be a European call option on the risky asset with strike $K = 100$ and maturity at the end of two periods. Under the absence of arbitrage, the option need not have a unique price because of the rate asymmetry.\n\nDetermine the range of arbitrage-free time-$0$ prices for $C$ (i.e., the interval of no-arbitrage prices). Round your two numerical endpoints to four significant figures. Provide your final answer as two numbers in a single row matrix.", "solution": "The problem asks for the range of arbitrage-free prices for a European call option in a two-period binomial market with asymmetric interest rates. This is a problem of option pricing in an incomplete market. The absence of a single risk-neutral probability measure leads to a range of prices, bounded by the buyer's price (the bid price) and the seller's price (the ask price).\n\nLet $S_t$ be the price of the risky asset at time $t$. The initial price is $S_0 = 100$. In each period, the price is multiplied by an up-factor $u=1.2$ or a down-factor $d=0.9$. The risk-free rates for lending and borrowing are $r_l=0.02$ and $r_b=0.08$, respectively. The option is a European call with strike price $K=100$ and maturity $T=2$.\n\nFirst, we map the possible paths of the stock price:\nAt $t=0$: $S_0 = 100$.\nAt $t=1$: $S_1(u) = 100 \\times 1.2 = 120$, $S_1(d) = 100 \\times 0.9 = 90$.\nAt $t=2$: $S_2(uu) = 120 \\times 1.2 = 144$, $S_2(ud) = 120 \\times 0.9 = 108$, $S_2(dd) = 90 \\times 0.9 = 81$.\n\nThe option payoff $C_2 = \\max(S_2 - K, 0)$ at $t=2$ is:\n$C_2(uu) = \\max(144 - 100, 0) = 44$.\n$C_2(ud) = \\max(108 - 100, 0) = 8$.\n$C_2(dd) = \\max(81 - 100, 0) = 0$.\n\nThe range of arbitrage-free prices at time $t=0$ is $[C_0^{min}, C_0^{max}]$.\nThe upper bound, $C_0^{max}$, is the seller's price (ask price). It is the minimum initial capital required to set up a portfolio that super-replicates the option's payoff, i.e., its value at maturity is always at least the option's payoff.\nThe lower bound, $C_0^{min}$, is the buyer's price (bid price). It is the maximum initial capital that can be withdrawn from a portfolio that sub-replicates the option's payoff, i.e., its value at maturity is always at most the option's payoff. This is related by duality: $C_0^{min}(C) = -C_0^{max}(-C)$.\n\nWe solve this problem using backward induction.\n\n**1. Calculation of the Seller's Price, $C_0^{max}$**\n\nThis is the minimum cost of a super-replicating strategy. A strategy involves holding $\\phi_t$ shares of the stock and a cash amount $\\psi_t$ at each time $t$. The interest rate applied to $\\psi_t$ depends on its sign.\n\n**Step 1.1: Pricing at $t=1$**\nAt each node at $t=1$, we find the minimum cost to super-replicate the $t=2$ payoffs. A portfolio $(\\phi_1, \\psi_1)$ must satisfy $V_2 = \\phi_1 S_2 + \\psi_1(1+r_1) \\ge C_2$.\nAt node $S_1(u)=120$:\nWe need to find $\\min(\\phi_1 \\cdot 120 + \\psi_1)$ subject to:\n$\\phi_1 \\cdot 144 + \\psi_1(1+r_1) \\ge 44$\n$\\phi_1 \\cdot 108 + \\psi_1(1+r_1) \\ge 8$\nSolving with equality gives $\\phi_1 = \\frac{44-8}{144-108} = 1$. This implies $\\psi_1(1+r_1) = 8 - 1 \\cdot 108 = -100$.\nSince $\\psi_1(1+r_1)$ is negative, $\\psi_1$ must be negative. Therefore, the borrowing rate $r_1=r_b=0.08$ applies.\n$\\psi_1 = -100 / (1+0.08) = -100/1.08$. The a priori sign assumption on $\\psi_1$ is consistent.\nThe cost at this node is $C_1^{max}(u) = 1 \\cdot 120 - 100/1.08 = 120 - \\frac{100}{1.08} = \\frac{129.6 - 100}{1.08} = \\frac{29.6}{1.08} = \\frac{2960}{108} = \\frac{740}{27}$.\n\nAt node $S_1(d)=90$:\nWe need to find $\\min(\\phi_1 \\cdot 90 + \\psi_1)$ subject to:\n$\\phi_1 \\cdot 108 + \\psi_1(1+r_1) \\ge 8$\n$\\phi_1 \\cdot 81 + \\psi_1(1+r_1) \\ge 0$\nSolving with equality gives $\\phi_1 = \\frac{8-0}{108-81} = \\frac{8}{27}$. This implies $\\psi_1(1+r_1) = 0 - \\frac{8}{27} \\cdot 81 = -24$.\n$\\psi_1$ must be negative, so $r_1=r_b=0.08$ applies.\n$\\psi_1 = -24/1.08$. The cost is $C_1^{max}(d) = \\frac{8}{27} \\cdot 90 - \\frac{24}{1.08} = \\frac{80}{3} - \\frac{24}{1.08} = \\frac{80}{3} - \\frac{2400}{108} = \\frac{80}{3} - \\frac{200}{9} = \\frac{240-200}{9} = \\frac{40}{9}$.\n\nSince any super-replicating strategy must have $\\psi_1<0$ at both nodes, the costs $C_1^{max}(u)$ and $C_1^{max}(d)$ are uniquely determined.\n\n**Step 1.2: Pricing at $t=0$**\nWe find the minimum cost $\\min(\\phi_0 S_0 + \\psi_0)$ subject to:\n$\\phi_0 S_1(u) + \\psi_0(1+r_0) \\ge C_1^{max}(u) = 740/27$\n$\\phi_0 S_1(d) + \\psi_0(1+r_0) \\ge C_1^{max}(d) = 40/9$\nwhere $r_0=r_l$ if $\\psi_0 \\ge 0$ and $r_0=r_b$ if $\\psi_0 < 0$. We must find the minimum cost over both possibilities.\n\nCase A: Assume $\\psi_0 < 0$, so $r_0 = r_b = 0.08$.\nSolving with equality: $\\phi_0 = \\frac{740/27 - 40/9}{120-90} = \\frac{(740-120)/27}{30} = \\frac{620}{810} = \\frac{62}{81}$.\n$\\psi_0(1.08) = 40/9 - (62/81) \\cdot 90 = (360-620)/9 = -580/9$.\n$\\psi_0 = -580/(9 \\cdot 1.08) < 0$. This is consistent with our assumption.\nThe cost is $V_0^{borrow} = \\phi_0 S_0 + \\psi_0 = \\frac{62}{81} \\cdot 100 - \\frac{580}{9 \\cdot 1.08} = \\frac{6200}{81} - \\frac{580}{9.72} = \\frac{18600-14500}{243} = \\frac{4100}{243}$.\n\nCase B: Assume $\\psi_0 \\ge 0$, so $r_0=r_l=0.02$.\nThe strategy must satisfy the constraints. The minimal cost is achieved at a vertex of the feasible region. One such vertex is where $\\psi_0 = 0$ and one constraint is an equality. Let's try $\\psi_0=0, \\phi_0 S_1(u) \\ge C_1^{max}(u)$. This means $120\\phi_0 \\ge 740/27 \\implies \\phi_0=37/162$. Cost is $V_0 = 100 \\cdot (37/162) = 1850/81$. This portfolio must also satisfy the second constraint: $90 \\cdot (37/162) = 185/9 = 20.55\\ldots$, which is indeed $\\ge 40/9 = 4.44\\ldots$. So this is a valid super-replicating portfolio.\nThe cost is $V_0^{lend} = 1850/81$.\n\nTo find the seller's price $C_0^{max}$, we take the minimum of the costs from the possible strategies:\n$C_0^{max} = \\min(V_0^{borrow}, V_0^{lend}) = \\min(\\frac{4100}{243}, \\frac{1850}{81}) = \\min(\\frac{4100}{243}, \\frac{5550}{243}) = \\frac{4100}{243}$.\n$C_0^{max} \\approx 16.8724$.\n\n**2. Calculation of the Buyer's Price, $C_0^{min}$**\n\nWe use the duality $C_0^{min}(C) = -C_0^{max}(-C)$. We compute the seller's price for an option with payoff $-C_2$.\nThe payoffs are $-C_2(uu)=-44$, $-C_2(ud)=-8$, $-C_2(dd)=0$.\n\n**Step 2.1: Pricing $-C$ at $t=1$**\nAt node $S_1(u)=120$: payoffs are $-44, -8$.\nSolving for replication: $\\phi_1 = \\frac{-44 - (-8)}{144-108} = -1$.\n$\\psi_1(1+r_1) = -8 - (-1) \\cdot 108 = 100$.\nSince $\\psi_1(1+r_1) > 0$, $\\psi_1$ must be positive. Thus, the lending rate $r_1=r_l=0.02$ applies.\nThe cost is $C_1^{ask}(-C)(u) = -1 \\cdot 120 + 100/1.02 = (-122.4+100)/1.02 = -22.4/1.02$.\n\nAt node $S_1(d)=90$: payoffs are $-8, 0$.\n$\\phi_1 = \\frac{-8-0}{108-81} = -8/27$.\n$\\psi_1(1+r_1) = 0 - (-8/27) \\cdot 81 = 24$.\n$\\psi_1 > 0$, so $r_1=r_l=0.02$ applies.\nThe cost is $C_1^{ask}(-C)(d) = (-8/27) \\cdot 90 + 24/1.02 = -80/3 + 24/1.02 = (-80 \\cdot 1.02 + 72)/3.06 = -9.6/3.06 = -160/51$.\n\n**Step 2.2: Pricing $-C$ at $t=0$**\nWe find $\\min(\\phi_0 S_0 + \\psi_0)$ subject to:\n$\\phi_0 S_1(u) + \\psi_0(1+r_0) \\ge C_1^{ask}(-C)(u) = -22.4/1.02$\n$\\phi_0 S_1(d) + \\psi_0(1+r_0) \\ge C_1^{ask}(-C)(d) = -160/51$\nCase A: Assume $\\psi_0 \\ge 0$, use $r_0=r_l=0.02$.\nSolving with equality: $\\phi_0 = \\frac{-22.4/1.02 - (-160/51)}{30} = \\frac{1}{30}(\\frac{-22.4 \\cdot 50/51 + 160/51}{1}) = \\frac{-1120+160}{30 \\cdot 51} = \\frac{-960}{1530} = -32/51$.\n$\\psi_0(1.02) = -160/51 - (-32/51) \\cdot 90 = (-160+2880)/51 = 2720/51$.\n$\\psi_0 = 2720/(51 \\cdot 1.02) > 0$. This is consistent.\nThe cost is $V_0^{lend} = \\phi_0 S_0 + \\psi_0 = -32/51 \\cdot 100 + \\frac{2720}{51 \\cdot 1.02} = \\frac{-3200 \\cdot 1.02 + 2720}{51 \\cdot 1.02} = \\frac{-3264+2720}{52.02} = \\frac{-544}{52.02} = \\frac{-27200}{2601}$.\n\nCase B: Assume $\\psi_0 < 0$, use $r_0=r_b=0.08$.\nThe replicating $\\phi_0$ is the same, $-32/51$.\n$\\psi_0(1.08) = 2720/51 \\implies \\psi_0 > 0$. This contradicts the assumption $\\psi_0 < 0$. So, a super-replicating strategy for $-C$ with borrowing at $t=0$ is not possible.\n\nThe seller's price for $-C$ is therefore $C_0^{max}(-C) = -27200/2601$.\nThe buyer's price for $C$ is $C_0^{min}(C) = -C_0^{max}(-C) = 27200/2601$.\n$C_0^{min} \\approx 10.4575$.\n\n**3. Conclusion**\nThe arbitrage-free price range for the European call option at $t=0$ is $[C_0^{min}, C_0^{max}]$.\n$C_0^{min} = 27200/2601 \\approx 10.457516$\n$C_0^{max} = 4100/243 \\approx 16.872428$\n\nRounding to four significant figures, the range is $[10.46, 16.87]$.", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n10.46 & 16.87\n\\end{pmatrix}\n}\n$$"}]}