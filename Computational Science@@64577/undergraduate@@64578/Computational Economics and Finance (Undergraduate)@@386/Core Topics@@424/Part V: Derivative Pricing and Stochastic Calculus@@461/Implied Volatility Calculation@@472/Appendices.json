{"hands_on_practices": [{"introduction": "This first practice is your entry point into the world of quantitative finance, where you will build a solver to extract implied volatility from a European option price. You will implement the powerful Newton-Raphson method to invert the Black-Scholes formula, a fundamental skill for any financial modeler [@problem_id:2400522]. This exercise demonstrates how a theoretical model is connected to real-world market data, turning an observed price into the key parameter of implied volatility, $\\sigma$.", "id": "2400522", "problem": "You are to implement a program that, for a set of European options on a non-dividend-paying asset under the Black–Scholes model, computes the implied volatility defined as the unique nonnegative value of the annualized standard deviation that, when substituted into the Black–Scholes price, matches a given observed option price. Let $S$ denote the spot price, $K$ the strike price, $r$ the continuously compounded risk-free rate, $T$ the time to maturity (in years), $\\sigma$ the annualized volatility (in decimal form), $\\Phi(\\cdot)$ the cumulative distribution function (CDF) of the standard normal distribution, and $\\phi(\\cdot)$ its probability density function (PDF). For a European call option,\n$$\nC(S,K,r,T,\\sigma) \\;=\\; S\\,\\Phi(d_1) \\;-\\; K\\,e^{-rT}\\,\\Phi(d_2),\n$$\nand for a European put option,\n$$\nP(S,K,r,T,\\sigma) \\;=\\; K\\,e^{-rT}\\,\\Phi(-d_2) \\;-\\; S\\,\\Phi(-d_1),\n$$\nwhere\n$$\nd_1 \\;=\\; \\frac{\\ln(S/K) + \\left(r + \\tfrac{1}{2}\\sigma^2\\right)T}{\\sigma\\sqrt{T}}, \n\\qquad\nd_2 \\;=\\; d_1 - \\sigma\\sqrt{T}.\n$$\nThe implied volatility for a given observed option price $p_{\\text{obs}}$ is the value $\\sigma^\\star \\ge 0$ such that the corresponding Black–Scholes price equals $p_{\\text{obs}}$. If $p_{\\text{obs}}$ is at the no-arbitrage lower bound (i.e., $p_{\\text{obs}} = \\max\\{0, S - K e^{-rT}\\}$ for a call or $p_{\\text{obs}} = \\max\\{0, K e^{-rT} - S\\}$ for a put), then the implied volatility must be $0$. All outputs must be in annualized volatility units (decimal, not a percentage).\n\nYour program must compute the implied volatility for each of the following test cases, treating the option type as either call ($\\text{C}$) or put ($\\text{P}$), and all times $T$ as measured in years:\n\n- Test case $1$: type $\\text{C}$, $S=100.0$, $K=100.0$, $r=0.0$, $T=1.0$, observed price $68.268949213709$.\n- Test case $2$: type $\\text{C}$, $S=60.653065971263$, $K=100.0$, $r=0.0$, $T=1.0$, observed price $14.461007592486$.\n- Test case $3$: type $\\text{P}$, $S=60.653065971263$, $K=100.0$, $r=0.0$, $T=1.0$, observed price $53.807941621223$.\n- Test case $4$: type $\\text{C}$, $S=120.0$, $K=100.0$, $r=0.0$, $T=1.0$, observed price $20.0$.\n- Test case $5$: type $\\text{P}$, $S=80.0$, $K=100.0$, $r=0.0$, $T=1.0$, observed price $20.0$.\n- Test case $6$: type $\\text{C}$, $S=100.0$, $K=100.0$, $r=0.0$, $T=1.0$, observed price $7.965567455406$.\n\nYour program must produce a single line of output containing the implied volatilities for the test cases in order, rounded to exactly six digits after the decimal point. The output format must be a single list on one line as a comma-separated list enclosed in square brackets, with no extra whitespace. For example, the output format must look like \"[v1,v2,v3,v4,v5,v6]\" where each $v_i$ is a float rounded to six decimal places.\n\nThe program must be self-contained and must not read any input. The final answers must be floats in decimal form (not percentages). Ensure numerical stability and correct handling for cases that lie on the no-arbitrage lower bound. The data above are scientifically grounded, and each case admits a unique nonnegative implied volatility consistent with the Black–Scholes model and the no-arbitrage bounds. The set of cases provides coverage of general behavior, deep in-the-money (ITM) and out-of-the-money (OTM) regimes, and boundary conditions. The final output must aggregate the six results as specified on a single line.", "solution": "The problem requires the computation of implied volatility, $\\sigma^\\star$, for a set of European options, given their observed market prices, $p_{\\text{obs}}$. This is a classic inverse problem in quantitative finance. The implied volatility is defined as the value of the volatility parameter, $\\sigma$, that makes the theoretical Black-Scholes price of an option equal to its observed price.\n\nThe core of the task is to solve the equation $f(\\sigma) = 0$ for $\\sigma \\ge 0$, where $f(\\sigma)$ is the difference between the Black-Scholes price and the observed price:\n$$\nf(\\sigma) = \\text{BS}(S, K, r, T, \\sigma) - p_{\\text{obs}} = 0\n$$\nHere, $\\text{BS}(S, K, r, T, \\sigma)$ is the price of the option (either a call $C$ or a put $P$) as given by the Black-Scholes formulas provided in the problem statement.\n\nThe Black-Scholes price function, $\\text{BS}(\\sigma)$, is a strictly increasing and continuous function of volatility $\\sigma$ for any time to maturity $T > 0$. This monotonicity guarantees that if a solution for $\\sigma^\\star$ exists, it is unique. This property makes the problem well-suited for numerical root-finding algorithms. We will employ the Newton-Raphson method, known for its rapid convergence when the derivative of the function is available and well-behaved.\n\nThe Newton-Raphson method is an iterative scheme that finds successively better approximations to the roots of a real-valued function. The iteration is given by:\n$$\n\\sigma_{k+1} = \\sigma_k - \\frac{f(\\sigma_k)}{f'(\\sigma_k)}\n$$\nIn our context, $f(\\sigma) = \\text{BS}(\\sigma) - p_{\\text{obs}}$, and its derivative with respect to $\\sigma$ is:\n$$\nf'(\\sigma) = \\frac{\\partial}{\\partial \\sigma} \\left[ \\text{BS}(\\sigma) - p_{\\text{obs}} \\right] = \\frac{\\partial \\text{BS}(\\sigma)}{\\partial \\sigma}\n$$\nThis derivative is a very important quantity in options pricing known as Vega, denoted by $\\mathcal{V}$. For both call and put options, Vega is given by:\n$$\n\\mathcal{V} = S \\phi(d_1) \\sqrt{T}\n$$\nwhere $\\phi(\\cdot)$ is the probability density function (PDF) of the standard normal distribution and $d_1$ is defined as in the problem statement. Since $\\phi(x) > 0$ for all real $x$, and $S, T > 0$, Vega is strictly positive. This confirms the monotonic nature of the pricing function.\n\nThe iterative formula for the implied volatility thus becomes:\n$$\n\\sigma_{k+1} = \\sigma_k - \\frac{\\text{BS}(\\sigma_k) - p_{\\text{obs}}}{\\mathcal{V}(\\sigma_k)}\n$$\n\nThe overall algorithm is designed as follows:\nFirst, we handle a critical boundary condition. The problem states that if the observed price $p_{\\text{obs}}$ is equal to the option's no-arbitrage lower bound (its intrinsic value), the implied volatility is $0$. The intrinsic value for a call is $\\max\\{0, S - K e^{-rT}\\}$ and for a put is $\\max\\{0, K e^{-rT} - S\\}$. Our implementation will first check if $p_{\\text{obs}}$ matches this value within a small numerical tolerance. If it does, we return $\\sigma^\\star = 0$ immediately, without iteration.\n\nIf the price is above the intrinsic value, we proceed with the Newton-Raphson solver.\n1.  An initial guess, $\\sigma_0$, is chosen. A value of $\\sigma_0 = 0.5$ is a reasonable and robust starting point for a wide range of option parameters.\n2.  The algorithm iterates, calculating $\\sigma_{k+1}$ from $\\sigma_k$ using the formula above.\n3.  The iteration continues until the absolute difference between the calculated Black-Scholes price at $\\sigma_k$ and the observed price $p_{\\text{obs}}$ is smaller than a predefined tolerance, for instance, $10^{-12}$.\n4.  To ensure the algorithm terminates, a maximum number of iterations (e.g., $100$) is enforced. For the well-behaved test cases provided, convergence is expected to be very rapid.\n\nThe implementation consists of three main Python functions:\n-   A function to calculate the Black-Scholes price for a call or put, using `scipy.stats.norm.cdf` to represent the standard normal cumulative distribution function $\\Phi(\\cdot)$.\n-   A function to calculate Vega, $\\mathcal{V}$, using `scipy.stats.norm.pdf` to represent the standard normal probability density function $\\phi(\\cdot)$.\n-   A primary function that orchestrates the process: it checks the boundary condition and, if necessary, executes the Newton-Raphson iteration to find the implied volatility.\n\nFinally, this process is applied to each of the six test cases defined in the problem. The resulting implied volatilities are collected, formatted to six decimal places, and printed to standard output in the specified list format.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Computes implied volatility for a set of European options using the Black-Scholes model\n    and the Newton-Raphson method.\n    \"\"\"\n\n    def black_scholes_price(S, K, r, T, sigma, option_type):\n        \"\"\"\n        Calculates the Black-Scholes price for a European option.\n        \"\"\"\n        # For non-positive sigma, price is intrinsic value.\n        if sigma <= 0.0:\n            if option_type == 'C':\n                return np.maximum(0.0, S - K * np.exp(-r * T))\n            else:  # 'P'\n                return np.maximum(0.0, K * np.exp(-r * T) - S)\n\n        # To prevent division by zero for T=0\n        if T == 0:\n            if option_type == 'C':\n                return np.maximum(0.0, S - K)\n            else: # 'P'\n                return np.maximum(0.0, K - S)\n\n        d1 = (np.log(S / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))\n        d2 = d1 - sigma * np.sqrt(T)\n\n        if option_type == 'C':\n            price = S * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)\n        elif option_type == 'P':\n            price = K * np.exp(-r * T) * norm.cdf(-d2) - S * norm.cdf(-d1)\n        else:\n            raise ValueError(\"Invalid option type. Must be 'C' or 'P'.\")\n        return price\n\n    def vega(S, K, r, T, sigma):\n        \"\"\"\n        Calculates the Vega of a European option.\n        \"\"\"\n        if sigma <= 0.0 or T <= 0.0:\n            return 0.0\n        \n        d1 = (np.log(S / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))\n        return S * norm.pdf(d1) * np.sqrt(T)\n\n    def implied_volatility(S, K, r, T, p_obs, option_type):\n        \"\"\"\n        Calculates the implied volatility using the Newton-Raphson method.\n        \"\"\"\n        # Check if price is at the no-arbitrage lower bound (intrinsic value)\n        if option_type == 'C':\n            intrinsic_value = np.maximum(0.0, S - K * np.exp(-r * T))\n        else:  # 'P'\n            intrinsic_value = np.maximum(0.0, K * np.exp(-r * T) - S)\n        \n        # Using a small tolerance for floating point comparison\n        if np.isclose(p_obs, intrinsic_value):\n            return 0.0\n\n        # Newton-Raphson settings\n        sigma = 0.5  # Initial guess\n        max_iter = 100\n        tolerance = 1e-12\n\n        for _ in range(max_iter):\n            price = black_scholes_price(S, K, r, T, sigma, option_type)\n            v = vega(S, K, r, T, sigma)\n            \n            diff = price - p_obs\n\n            if abs(diff) < tolerance:\n                return sigma\n            \n            if v < 1e-13:\n                # Vega is too small, Newton-Raphson is unstable.\n                # This should not happen for the given test cases.\n                # A more robust solver would switch to bisection here.\n                break\n\n            sigma = sigma - diff / v\n        \n        # Return the last calculated sigma if max iterations are reached\n        return sigma\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (option_type, S, K, r, T, p_obs)\n        ('C', 100.0, 100.0, 0.0, 1.0, 68.268949213709),\n        ('C', 60.653065971263, 100.0, 0.0, 1.0, 14.461007592486),\n        ('P', 60.653065971263, 100.0, 0.0, 1.0, 53.807941621223),\n        ('C', 120.0, 100.0, 0.0, 1.0, 20.0),\n        ('P', 80.0, 100.0, 0.0, 1.0, 20.0),\n        ('C', 100.0, 100.0, 0.0, 1.0, 7.965567455406),\n    ]\n\n    results = []\n    for case in test_cases:\n        # Main logic to calculate the result for one case goes here.\n        option_type, S, K, r, T, p_obs = case\n        result = implied_volatility(S, K, r, T, p_obs, option_type)\n        results.append(f\"{result:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"}, {"introduction": "Having mastered European options, we now tackle the challenge of American options, which introduce the complexity of early exercise. In this exercise, you will use a binomial tree model—a versatile numerical method—to first price the option and then back out the corresponding implied volatility [@problem_id:2400466]. This practice is crucial for learning how to handle derivatives that lack simple closed-form solutions and for understanding the impact of features like early exercise rights.", "id": "2400466", "problem": "You are asked to write a complete, runnable program that computes implied volatility for American-style options on a dividend-paying stock using a recombining binomial tree model and risk-neutral valuation with early exercise. The program must construct a pricing function for American options that accounts for a continuous dividend yield and then solve for the unique volatility that makes the model price match a given observed price. For testing, each observed price is to be generated synthetically by first pricing the same option with a known volatility on the same binomial tree specification.\n\nAll parameters are annualized and continuous where applicable. The underlying follows a multiplicative binomial process over a fixed number of time steps under the risk-neutral measure. The stock pays a continuous dividend yield. At each node, the American option value equals the greater of its immediate exercise value and the discounted expected continuation value under the risk-neutral probabilities. Implied volatility is defined as the nonnegative real number that, when substituted as the volatility in the same binomial model, makes the computed American option price equal to the observed price.\n\nUnits and conventions:\n- The risk-free rate $r$ and dividend yield $q$ are continuously compounded annual rates given as decimals.\n- Time to maturity $T$ is in years.\n- The underlying price $S_0$ and strike $K$ are in arbitrary currency units; report volatilities as decimals.\n- No angles are involved.\n- All rates and volatilities must be treated as decimals, not percentages.\n\nTest suite:\nFor each test case, first compute the observed option price $V^{obs}$ by pricing the American option using the provided volatility $\\,\\sigma^\\star\\,$ and the specified binomial tree step count $\\,N\\,$. Then, using only $V^{obs}$ (not $\\,\\sigma^\\star\\,$), solve for the implied volatility $\\,\\hat{\\sigma}\\,$ that reproduces $V^{obs}$ in the same model. Your program should return $\\,\\hat{\\sigma}\\,$ for each case, rounded to six decimal places.\n\n- Case A (general, at-the-money American put): $S_0 = 100$, $K = 100$, $r = 0.05$, $q = 0.02$, $T = 1.0$, $N = 300$, option type put, forward-pricing volatility $\\,\\sigma^\\star = 0.20$.\n- Case B (American call with dividend yield, potential early exercise): $S_0 = 120$, $K = 100$, $r = 0.01$, $q = 0.06$, $T = 0.5$, $N = 300$, option type call, forward-pricing volatility $\\,\\sigma^\\star = 0.25$.\n- Case C (short maturity): $S_0 = 100$, $K = 95$, $r = 0.03$, $q = 0.00$, $T = \\tfrac{7}{365}$, $N = 120$, option type call, forward-pricing volatility $\\,\\sigma^\\star = 0.15$.\n- Case D (deep out-of-the-money American put, longer maturity): $S_0 = 150$, $K = 100$, $r = 0.03$, $q = 0.02$, $T = 2.0$, $N = 400$, option type put, forward-pricing volatility $\\,\\sigma^\\star = 0.35$.\n\nFinal output format:\nYour program should produce a single line of output containing the four implied volatilities for Cases A–D in order, rounded to six decimal places, as a comma-separated list enclosed in square brackets. For example, the format must be\n\"[vA,vB,vC,vD]\"\nwith no extra spaces or characters, where each of $vA$, $vB$, $vC$, and $vD$ is a float in decimal form rounded to six decimal places.", "solution": "The problem statement presented is subjected to rigorous validation before any attempt at a solution.\n\nStep 1: Extraction of Givens\n- **Model Type**: Recombining binomial tree model for American-style options.\n- **Underlying Asset**: Stock paying a continuous dividend yield.\n- **Valuation Methodology**: Risk-neutral valuation with early exercise.\n- **Stock Price Process**: Multiplicative binomial process, $S_{t+\\Delta t} = S_t \\cdot u$ or $S_{t+\\Delta t} = S_t \\cdot d$.\n- **Option Value Rule**: At any node, the value is the maximum of its immediate exercise value and its discounted expected continuation value under risk-neutral probabilities.\n- **Implied Volatility ($\\hat{\\sigma}$)**: The unique non-negative real number for volatility $\\sigma$ such that the model price equals the observed market price $V^{obs}$.\n- **Observed Price Generation**: Each $V^{obs}$ is synthetically generated by pricing the option with a known volatility, denoted $\\sigma^\\star$.\n- **Model Parameters**:\n    - $S_0$: Initial stock price.\n    - $K$: Strike price.\n    - $r$: Risk-free interest rate (continuous, annual).\n    - $q$: Dividend yield (continuous, annual).\n    - $T$: Time to maturity (years).\n    - $N$: Number of time steps in the binomial tree.\n    - `option_type`: 'call' or 'put'.\n- **Test Cases**:\n    - **A**: $S_0 = 100$, $K = 100$, $r = 0.05$, $q = 0.02$, $T = 1.0$, $N = 300$, type = put, $\\sigma^\\star = 0.20$.\n    - **B**: $S_0 = 120$, $K = 100$, $r = 0.01$, $q = 0.06$, $T = 0.5$, $N = 300$, type = call, $\\sigma^\\star = 0.25$.\n    - **C**: $S_0 = 100$, $K = 95$, $r = 0.03$, $q = 0.00$, $T = \\frac{7}{365}$, $N = 120$, type = call, $\\sigma^\\star = 0.15$.\n    - **D**: $S_0 = 150$, $K = 100$, $r = 0.03$, $q = 0.02$, $T = 2.0$, $N = 400$, type = put, $\\sigma^\\star = 0.35$.\n- **Output Requirement**: A list of four implied volatilities, $\\hat{\\sigma}$, corresponding to the test cases, rounded to six decimal places.\n\nStep 2: Validation\n- **Scientific Grounding**: The problem is based on the Cox-Ross-Rubinstein (CRR) binomial options pricing model, a cornerstone of computational finance. Risk-neutral valuation, the treatment of American options with early exercise, and the concept of implied volatility are all standard, well-established principles. The model is scientifically sound.\n- **Well-Posedness**: The problem requires finding a root for the equation $V_{model}(\\sigma) - V^{obs} = 0$. The option price, $V_{model}(\\sigma)$, is a monotonically increasing function of volatility $\\sigma$ for standard options (i.e., vega is positive). This ensures that a unique solution for $\\sigma$ exists for any valid observed price $V^{obs}$. The problem's structure, where $V^{obs}$ is generated from a known $\\sigma^\\star$ using the same model, guarantees that a solution $\\hat{\\sigma} = \\sigma^\\star$ exists, making the problem well-posed.\n- **Objectivity**: All parameters and definitions are quantitative and precise. The problem is free of subjective language or speculative claims.\n- **Completeness**: All necessary parameters ($S_0, K, r, q, T, N, \\text{type}$) are provided for each test case, making the problem self-contained.\n- **Consistency**: The problem statement contains no internal contradictions.\n\nStep 3: Verdict\nThe problem is deemed **valid**. It is scientifically grounded, well-posed, objective, complete, and consistent. It represents a standard computational task in quantitative finance. I will now proceed with the derivation and implementation of the solution.\n\nThe solution is a two-stage process. First, an American option pricer is constructed based on the specified binomial model. Second, a numerical root-finding algorithm is used to solve for the implied volatility.\n\n**Part 1: Binomial Model for American Option Pricing**\n\nThe binomial model discretizes time into $N$ steps of duration $\\Delta t = T/N$. At each node, the stock price moves up by a factor $u$ or down by a factor $d$. We use the standard Cox-Ross-Rubinstein (CRR) formulation for these factors, which depends on the volatility $\\sigma$.\n\n1.  **Model Parameters**:\n    The length of a single time step is $\\Delta t = T/N$.\n    The up-move factor is $u = e^{\\sigma \\sqrt{\\Delta t}}$.\n    The down-move factor is $d = e^{-\\sigma \\sqrt{\\Delta t}} = 1/u$.\n\n2.  **Risk-Neutral Probability**:\n    For the discounted stock price process to be a martingale under the risk-neutral measure, taking into account the continuous dividend yield $q$, the expected stock price at time $t+\\Delta t$, discounted at the risk-free rate $r$, must equal the stock price at time $t$ after accounting for the loss in value due to the dividend payment over the interval $\\Delta t$. This gives the relation:\n    $$S_t e^{-q \\Delta t} = e^{-r \\Delta t} [p (S_t u) + (1-p) (S_t d)]$$\n    Solving for the risk-neutral probability $p$ of an up-move yields:\n    $$p = \\frac{e^{(r-q)\\Delta t} - d}{u - d}$$\n    The probability of a down-move is then $1-p$. The condition $0 < p < 1$ must hold, which requires $d < e^{(r-q)\\Delta t} < u$. This is satisfied for typical parameter values and non-zero volatility.\n\n3.  **Backward Induction Algorithm**:\n    The value of the American option is determined by working backward from maturity.\n    - **At maturity (Time $T$, step $N$)**: The option value is its intrinsic value. A tree of stock prices at maturity is constructed. For $j$ up-moves and $N-j$ down-moves (where $j \\in \\{0, 1, \\dots, N\\}$), the stock price is $S_{N,j} = S_0 u^j d^{N-j}$. The option value is:\n    $$V_{N,j} = \\max(S_{N,j} - K, 0) \\quad \\text{for a call option}$$\n    $$V_{N,j} = \\max(K - S_{N,j}, 0) \\quad \\text{for a put option}$$\n\n    - **At intermediate steps (Time $i \\Delta t$, step $i < N$)**: The option value at any node $(i, j)$ is the maximum of the early exercise value and the discounted expected continuation value.\n    The continuation value is the expected value of the option at step $i+1$, discounted back one period:\n    $$C_{i,j} = e^{-r \\Delta t} [p V_{i+1, j+1} + (1-p) V_{i+1, j}]$$\n    The early exercise value at node $(i,j)$, where the stock price is $S_{i,j} = S_0 u^j d^{i-j}$, is:\n    $$E_{i,j} = \\max(S_{i,j} - K, 0) \\quad \\text{for a call option}$$\n    $$E_{i,j} = \\max(K - S_{i,j}, 0) \\quad \\text{for a put option}$$\n    The value of the American option is therefore:\n    $$V_{i,j} = \\max(E_{i,j}, C_{i,j})$$\n    This backward iteration proceeds until step $i=0$. The price of the option at time $t=0$ is the value at the single node, $V_{0,0}$. This entire procedure constitutes the pricing function, which we denote $V_{\\text{model}}(S_0, K, r, q, T, N, \\sigma, \\text{type})$.\n\n**Part 2: Implied Volatility Calculation**\n\nImplied volatility, $\\hat{\\sigma}$, is the value of $\\sigma$ that equates the model price to an observed market price, $V^{obs}$. We must solve the following equation for $\\sigma$:\n$$f(\\sigma) = V_{\\text{model}}(S_0, K, r, q, T, N, \\sigma, \\text{type}) - V^{obs} = 0$$\n\nSince $V_{\\text{model}}$ does not have a simple closed-form expression, we must use a numerical root-finding method. Brent's method is a robust and efficient choice. It requires an interval $[a, b]$ where $f(a)$ and $f(b)$ have opposite signs.\n\n1.  **Objective Function**: The function to be minimized is `objective_func(sigma) = american_option_pricer(...) - V_obs`.\n2.  **Generate Observed Price**: For each test case, we first compute $V^{obs}$ by calling our pricing function with the given forward-pricing volatility $\\sigma^\\star$.\n3.  **Root Finding**: We then use Brent's method (available in `scipy.optimize.brentq`) to find the root of `objective_func`.\n    - A suitable search interval for volatility is required. A lower bound can be a small positive number, e.g., $10^{-6}$, since volatility cannot be negative. An upper bound of $5.0$ (representing $500\\%$ volatility) is extremely conservative and will suffice for bracketing the solution for any realistic option price.\n    - Since option price is a monotonically increasing function of volatility, and we know a solution exists at $\\sigma = \\sigma^\\star$, finding a bracketing interval is straightforward.\n\nThe final program will encapsulate these two parts. For each test case, it will first compute $V^{obs}$ and then solve for $\\hat{\\sigma}$. The problem formulation guarantees that the result $\\hat{\\sigma}$ will be equal to $\\sigma^\\star$ within the solver's tolerance. The final results are rounded as specified.", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef american_option_pricer(S0, K, r, q, T, N, sigma, option_type):\n    \"\"\"\n    Prices an American option using a recombining binomial tree model.\n\n    Args:\n        S0 (float): Initial stock price.\n        K (float): Strike price.\n        r (float): Risk-free interest rate (annual, continuous).\n        q (float): Dividend yield (annual, continuous).\n        T (float): Time to maturity (years).\n        N (int): Number of time steps in the binomial tree.\n        sigma (float): Volatility of the underlying stock.\n        option_type (str): Type of option, 'call' or 'put'.\n\n    Returns:\n        float: The price of the American option.\n    \"\"\"\n    # 1. Parameter setup for the binomial model\n    # Ensure sigma is not too close to zero to avoid division issues.\n    if sigma < 1e-9:\n        sigma = 1e-9\n\n    dt = T / N\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1.0 / u\n\n    # Check for arbitrage condition and calculate risk-neutral probability\n    a = np.exp((r - q) * dt)\n    if not (d < a < u):\n        # Fallback or handle arbitrage condition violation\n        # For this problem's context, this is unlikely.\n        # This can be triggered if r-q is very large or sigma very small.\n        # If it happens, we can approximate p to be very close to 1 or 0.\n        if a >= u:\n            p = 1.0 \n        else: # a <= d\n            p = 0.0\n    else:\n        p = (a - d) / (u - d)\n\n    # 2. Initialize option values at maturity (time T)\n    # The prices are stored in a 1D array representing nodes at a given time step.\n    V = np.zeros(N + 1)\n    \n    # Stock prices at maturity\n    S_T = S0 * (d ** np.arange(N, -1, -1)) * (u ** np.arange(0, N + 1, 1))\n\n    if option_type == 'call':\n        V[:] = np.maximum(S_T - K, 0)\n        payoff_sign = 1\n    else:  # put\n        V[:] = np.maximum(K - S_T, 0)\n        payoff_sign = -1\n\n    # 3. Backward induction through the tree\n    for i in range(N - 1, -1, -1):\n        # Calculate continuation value at step i (vector of size i+1)\n        # V is of size i+2 from the previous step i+1.\n        # We use V's relevant subarray [0:i+2]\n        continuation_value = np.exp(-r * dt) * (p * V[1:i + 2] + (1 - p) * V[0:i + 1])\n\n        # Calculate stock prices at step i\n        S_i = S0 * (d ** np.arange(i, -1, -1)) * (u ** np.arange(0, i + 1, 1))\n\n        # Calculate early exercise value\n        exercise_value = np.maximum((S_i - K) * payoff_sign, 0)\n\n        # Update option values at step i\n        V[0:i + 1] = np.maximum(continuation_value, exercise_value)\n\n    return V[0]\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and compute implied volatilities.\n    \"\"\"\n    test_cases = [\n        # (S0, K, r, q, T, N, option_type, sigma_star)\n        (100.0, 100.0, 0.05, 0.02, 1.0, 300, 'put', 0.20),  # Case A\n        (120.0, 100.0, 0.01, 0.06, 0.5, 300, 'call', 0.25), # Case B\n        (100.0, 95.0, 0.03, 0.00, 7.0/365.0, 120, 'call', 0.15), # Case C\n        (150.0, 100.0, 0.03, 0.02, 2.0, 400, 'put', 0.35), # Case D\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        S0, K, r, q, T, N, option_type, sigma_star = case\n\n        # 1. Generate the \"observed\" option price using the known volatility\n        observed_price = american_option_pricer(S0, K, r, q, T, N, sigma_star, option_type)\n\n        # 2. Define the objective function for the root-finder\n        # The function calculates the difference between model price and observed price.\n        def objective_func(sigma):\n            return american_option_pricer(S0, K, r, q, T, N, sigma, option_type) - observed_price\n\n        # 3. Find the implied volatility using Brent's method\n        # A search bracket from 0.0001 (0.01%) to 5.0 (500%) is very safe.\n        try:\n            implied_vol = brentq(objective_func, a=1e-6, b=5.0, xtol=1e-12, rtol=1e-12)\n        except ValueError:\n            # This would happen if f(a) and f(b) don't have opposite signs.\n            # Given the problem's synthetic nature, this is not expected.\n            implied_vol = np.nan\n\n        results.append(round(implied_vol, 6))\n\n    # Final output format: \"[vA,vB,vC,vD]\"\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"}, {"introduction": "Our final practice moves to the cutting edge by exploring a world where volatility is not constant, a key limitation of the Black-Scholes model. You will work with the celebrated SABR (Stochastic Alpha, Beta, Rho) model, a market standard for describing the volatility smile and skew observed in options markets [@problem_id:2400489]. By implementing its famous asymptotic formula, you will gain direct insight into how practitioners generate consistent volatility surfaces across different strikes and maturities from a few intuitive parameters.", "id": "2400489", "problem": "Implement a complete program that computes the lognormal Black implied volatility for European options generated by the Stochastic Alpha Beta Rho (SABR) model. The SABR dynamics are defined under the risk-neutral measure by the coupled stochastic differential equations\n$$\n\\mathrm{d}F_t = \\alpha_t F_t^{\\beta}\\,\\mathrm{d}W_t^{(1)}, \\qquad \\mathrm{d}\\alpha_t = \\nu \\alpha_t\\,\\mathrm{d}W_t^{(2)}, \\qquad \\mathrm{d}\\langle W^{(1)}, W^{(2)}\\rangle_t = \\rho\\,\\mathrm{d}t,\n$$\nwhere $F_t$ is the forward underlying at time $t$, $\\alpha_t$ is the instantaneous volatility, $\\beta \\in [0,1]$, $\\rho \\in (-1,1)$ is the instantaneous correlation, and $\\nu \\ge 0$ is the volatility of volatility. For a maturity $T>0$, a forward price $F>0$, a strike $K>0$, and SABR parameters $(\\alpha,\\beta,\\rho,\\nu)$ with $\\alpha>0$, the lognormal Black implied volatility $\\sigma_{\\mathrm{imp}}(F,K,T;\\alpha,\\beta,\\rho,\\nu)$ is defined as the unique $\\sigma$ such that the Black-Scholes (lognormal) formula with volatility $\\sigma$ matches the SABR option price at maturity $T$. In the short-maturity asymptotic regime, this implied volatility is well-defined by the standard first-order small-time expression as a deterministic function of $(F,K,T,\\alpha,\\beta,\\rho,\\nu)$.\n\nYour program must, for each parameter set in the test suite below, compute the corresponding lognormal Black implied volatility $\\sigma_{\\mathrm{imp}}$ according to this short-maturity SABR-implied volatility mapping. All returned volatilities must be expressed as decimals (for example, $0.2$ denotes twenty hundredths), and each result must be rounded to $8$ decimal places.\n\nTest Suite (each case is a tuple $(F,K,T,\\alpha,\\beta,\\rho,\\nu)$ with all quantities dimensionless and $T$ measured in years):\n- Case $1$: $(F,K,T,\\alpha,\\beta,\\rho,\\nu) = (1.0,\\,1.1,\\,1.0,\\,0.3,\\,0.7,\\,-0.3,\\,0.5)$\n- Case $2$ (at-the-money): $(F,K,T,\\alpha,\\beta,\\rho,\\nu) = (1.0,\\,1.0,\\,2.0,\\,0.25,\\,1.0,\\,0.0,\\,0.4)$\n- Case $3$ (very short maturity): $(F,K,T,\\alpha,\\beta,\\rho,\\nu) = (1.0,\\,0.9,\\,0.0001,\\,0.2,\\,0.5,\\,0.5,\\,1.2)$\n- Case $4$ (high positive correlation): $(F,K,T,\\alpha,\\beta,\\rho,\\nu) = (2.0,\\,1.0,\\,3.0,\\,0.15,\\,0.9,\\,0.99,\\,0.8)$\n- Case $5$ (high negative correlation, low $\\beta$): $(F,K,T,\\alpha,\\beta,\\rho,\\nu) = (0.5,\\,0.8,\\,0.5,\\,0.4,\\,0.3,\\,-0.99,\\,1.0)$\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. In order, report the $5$ implied volatilities corresponding to Cases $1$ through $5$, each rounded to $8$ decimal places. For example,\n\"[v1,v2,v3,v4,v5]\"\nwhere each $v_i$ is a float formatted to exactly $8$ decimal places.", "solution": "The posed problem requires the computation of the lognormal Black implied volatility for European options priced under the Stochastic Alpha Beta Rho (SABR) model. The computation must be performed using the standard first-order small-time asymptotic formula developed by Hagan, Kumar, Lesniewski, and Woodward.\n\nFirst, the validity of the problem is established. The problem is scientifically grounded in the established theory of stochastic volatility models in quantitative finance. It is well-posed, objective, and provides all necessary parameters and conditions for a unique solution. The reference to the \"standard first-order small-time expression\" unambiguously points to the widely used Hagan et al. formula. All provided test cases adhere to the defined parameter constraints of the SABR model, i.e., $F>0$, $K>0$, $T>0$, $\\alpha>0$, $\\beta \\in [0,1]$, $\\rho \\in (-1,1)$, and $\\nu \\ge 0$. The problem is therefore deemed valid and a rigorous solution can be constructed.\n\nThe core of the solution is the implementation of the Hagan asymptotic formula for the Black-Scholes implied volatility, $\\sigma_{\\mathrm{imp}}$. The formula provides an accurate approximation of the SABR price-to-volatility mapping, particularly for short maturities.\n\nThe general formula for implied volatility $\\sigma_{\\mathrm{imp}}$ for a given forward price $F$, strike price $K$, time to maturity $T$, initial volatility $\\alpha$, and SABR parameters $\\beta, \\rho, \\nu$ is given by:\n$$ \\sigma_{\\mathrm{imp}}(F,K) \\approx \\frac{\\alpha}{\\left(FK\\right)^{\\frac{1-\\beta}{2}} \\left[1 + \\frac{(1-\\beta)^2}{24}\\log^2\\left(\\frac{F}{K}\\right) + \\frac{(1-\\beta)^4}{1920}\\log^4\\left(\\frac{F}{K}\\right)\\right]} \\times \\left(\\frac{z}{\\chi(z)}\\right) \\times \\left[1 + \\left(\\frac{(1-\\beta)^2\\alpha^2}{24(FK)^{1-\\beta}} + \\frac{\\rho\\beta\\nu\\alpha}{4(FK)^{\\frac{1-\\beta}{2}}} + \\frac{2-3\\rho^2}{24}\\nu^2\\right)T\\right] $$\nThis expression consists of three main components:\n$1$. A backbone term, which depends on the moneyness $\\log(F/K)$ and the parameter $\\beta$. For completeness, we include the expansion in $\\log(F/K)$ up to the fourth order, which is standard practice for improved accuracy away from the money.\n$2$. A term $\\frac{z}{\\chi(z)}$ which corrects for the stochasticity of the volatility process, driven by $\\nu$ and its correlation $\\rho$ with the forward's process. The auxiliary variables $z$ and $\\chi(z)$ are defined as:\n$$ z = \\frac{\\nu}{\\alpha}(FK)^{\\frac{1-\\beta}{2}} \\log\\left(\\frac{F}{K}\\right) $$\n$$ \\chi(z) = \\log\\left(\\frac{\\sqrt{1-2\\rho z+z^2}+z-\\rho}{1-\\rho}\\right) $$\n$3$. A time-dependent factor $[1 + (\\dots)T]$ which represents the first-order correction in time to maturity $T$.\n\nA critical aspect of a robust implementation is handling the singularities and numerical instabilities in this formula. Specifically, when the option is at-the-money ($F=K$), the moneyness $\\log(F/K)=0$, which implies $z=0$. This leads to an indeterminate form $0/0$ in the term $z/\\chi(z)$. To resolve this, we must evaluate the limit as $K \\to F$. In this limit, $\\log(F/K) \\to 0$, all expansion terms in $\\log(F/K)$ vanish, and $\\lim_{z \\to 0} \\frac{z}{\\chi(z)} = 1$. The formula simplifies to the at-the-money (ATM) implied volatility:\n$$ \\sigma_{\\mathrm{imp}}(F,F) = \\frac{\\alpha}{F^{1-\\beta}} \\left[1 + \\left(\\frac{(1-\\beta)^2\\alpha^2}{24F^{2(1-\\beta)}} + \\frac{\\rho\\beta\\nu\\alpha}{4F^{1-\\beta}} + \\frac{2-3\\rho^2}{24}\\nu^2\\right)T\\right] $$\nThis specialized ATM formula must be used for Case $2$ of the test suite and for any case where $F$ is numerically indistinguishable from $K$.\n\nThe algorithmic design is as follows:\n$1$. For each set of input parameters $(F, K, T, \\alpha, \\beta, \\rho, \\nu)$, first evaluate the log-moneyness $x = \\log(F/K)$.\n$2$. If $|x|$ is smaller than a small numerical tolerance (e.g., $10^{-7}$), the option is considered at-the-money. The simplified ATM formula is applied to compute the implied volatility. This branch correctly handles Case $2$, where $F=K$, and prevents numerical errors for near-the-money options.\n$3$. If the option is not at-the-money, the full asymptotic formula is used.\n    a. Calculate $f = (FK)^{(1-\\beta)/2}$ and $z = (\\nu/\\alpha)f x$.\n    b. Calculate the backbone term denominator, including terms up to $\\log^4(F/K)$.\n    c. Calculate $\\chi(z)$ and subsequently the ratio $z/\\chi(z)$. The formula for $\\chi(z)$ is numerically stable for the parameter range provided in test cases, including $\\rho$ values close to $\\pm 1$.\n    d. Calculate the time-dependent adjustment factor.\n    e. Combine all terms to compute the final implied volatility.\n\nThis structured approach ensures both mathematical correctness according to the specified model and numerical robustness across a range of input parameters. The final results are rounded to $8$ decimal places as required.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the lognormal Black implied volatility for European options\n    under the SABR model using the first-order small-time asymptotic formula\n    by Hagan et al. (2002).\n    \"\"\"\n\n    def sabr_implied_vol(F, K, T, alpha, beta, rho, nu):\n        \"\"\"\n        Calculates SABR implied volatility.\n\n        Args:\n            F (float): Forward price.\n            K (float): Strike price.\n            T (float): Time to maturity in years.\n            alpha (float): Initial volatility.\n            beta (float): Exponent parameter.\n            rho (float): Correlation parameter.\n            nu (float): Volatility of volatility.\n\n        Returns:\n            float: The SABR implied volatility.\n        \"\"\"\n        # For numerical stability, treat cases where F and K are very close as at-the-money.\n        # This avoids issues with log(F/K) and z being close to zero.\n        if abs(F - K) < 1e-7:\n            f_atm = F**(1 - beta)\n            term1 = (1 - beta)**2 * alpha**2 / (24 * f_atm**2)\n            term2 = rho * beta * nu * alpha / (4 * f_atm)\n            term3 = (2 - 3 * rho**2) * nu**2 / 24\n            time_adj = 1 + (term1 + term2 + term3) * T\n            return (alpha / f_atm) * time_adj\n\n        log_FK = np.log(F / K)\n        f = (F * K)**((1 - beta) / 2)\n        \n        # Check for nu=0, which corresponds to the CEV model. In this case, z=0 and z/chi(z)=1.\n        if nu == 0:\n            z = 0.\n            z_over_chi = 1.\n        else:\n            z = nu / alpha * f * log_FK\n            # Use full expression for chi(z) as it's stable for given test cases.\n            sqrt_term = np.sqrt(1 - 2 * rho * z + z**2)\n            chi_z = np.log((sqrt_term + z - rho) / (1 - rho))\n            z_over_chi = z / chi_z\n\n        # Backbone term including expansion up to 4th order in log-moneyness for accuracy.\n        denom_beta_expansion = (1 +\n                                (1 - beta)**2 / 24 * log_FK**2 +\n                                (1 - beta)**4 / 1920 * log_FK**4)\n\n        # Time-dependent adjustment term (first-order in T).\n        term1 = (1 - beta)**2 * alpha**2 / (24 * f**2)\n        term2 = rho * beta * nu * alpha / (4 * f)\n        term3 = (2 - 3 * rho**2) * nu**2 / 24\n        time_adj = 1 + (term1 + term2 + term3) * T\n\n        vol = (alpha / (f * denom_beta_expansion)) * z_over_chi * time_adj\n        return vol\n\n    # Test Suite from the problem statement.\n    # Each case is a tuple (F, K, T, alpha, beta, rho, nu).\n    test_cases = [\n        (1.0, 1.1, 1.0, 0.3, 0.7, -0.3, 0.5), # Case 1\n        (1.0, 1.0, 2.0, 0.25, 1.0, 0.0, 0.4), # Case 2 (at-the-money)\n        (1.0, 0.9, 0.0001, 0.2, 0.5, 0.5, 1.2), # Case 3 (very short maturity)\n        (2.0, 1.0, 3.0, 0.15, 0.9, 0.99, 0.8), # Case 4 (high positive correlation)\n        (0.5, 0.8, 0.5, 0.4, 0.3, -0.99, 1.0), # Case 5 (high negative correlation, low beta)\n    ]\n\n    results = []\n    for case in test_cases:\n        F, K, T, alpha, beta, rho, nu = case\n        implied_vol = sabr_implied_vol(F, K, T, alpha, beta, rho, nu)\n        # Round the result to 8 decimal places.\n        results.append(f\"{implied_vol:.8f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"}]}