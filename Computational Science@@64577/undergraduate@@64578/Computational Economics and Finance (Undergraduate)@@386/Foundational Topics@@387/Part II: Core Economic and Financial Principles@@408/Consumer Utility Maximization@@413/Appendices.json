{"hands_on_practices": [{"introduction": "We begin our hands-on practices by exploring a foundational scenario in consumer theory: choosing among indivisible goods. This situation, where goods can only be purchased in whole units, renders traditional calculus-based methods ineffective. This exercise guides you to reframe the consumer's problem as a classic 0/1 knapsack problem, establishing a powerful link between microeconomics and computational science [@problem_id:2384164]. By implementing an exact algorithm like dynamic programming, you will learn to solve for the optimal consumption bundle when choices are discrete, a common feature in many real-world markets.", "id": "2384164", "problem": "You are given a discrete-time consumer choice problem with indivisible goods. The consumer faces a finite set of goods indexed by $i \\in \\{1,\\dots,n\\}$. Each good can be either not purchased or purchased in one unit. The consumer has a nonnegative, additively separable utility index represented by a vector $u \\in \\mathbb{R}_{\\ge 0}^{n}$, where $u_i$ is the utility of obtaining one unit of good $i$, and strictly nonnegative prices represented by a vector $p \\in \\mathbb{R}_{\\ge 0}^{n}$, where $p_i$ is the price of one unit of good $i$. The consumer has a budget $M \\in \\mathbb{R}_{\\ge 0}$. The decision variables are $x_i \\in \\{0,1\\}$ for each $i$, indicating whether good $i$ is purchased. The consumer seeks to maximize total utility subject to the budget constraint.\n\nFrom fundamental microeconomic principles, the consumer problem is to maximize a utility function subject to a resource constraint. Under additivity across goods and indivisibility, this becomes a combinatorial optimization problem. Your task is to:\n\n- Derive the precise mathematical formulation of this discrete consumer choice problem from the definitions of utility maximization and the budget set, introducing binary decision variables and a linear budget constraint. Express the problem using a valid integer program.\n- Explain how this formulation is an instance of the zero-one knapsack problem, in which utilities play the role of values, prices play the role of weights, and the budget is the capacity.\n- Design and implement an exact algorithm that solves the problem as an integer program. You must produce an exact maximizer of total utility. You may use a principled algorithm such as a branch-and-bound scheme with a fractional knapsack upper bound, or a pseudo-polynomial dynamic program, ensuring correctness for all provided test cases. Clearly explain the algorithmic logic from first principles.\n\nYour program must implement the solver and apply it to the following test suite of instances, each specified by a utilities vector $u$, a prices vector $p$, and a budget $M$:\n\n- Test $1$ (general case): $u = [9,6,7,3]$, $p = [4,3,5,2]$, $M = 7$.\n- Test $2$ (zero budget boundary): $u = [5,4]$, $p = [1,2]$, $M = 0$.\n- Test $3$ (zero-price item): $u = [4,10,2]$, $p = [0,5,3]$, $M = 5$.\n- Test $4$ (tie in per-dollar utilities, unique optimal utility): $u = [6,6,5]$, $p = [4,4,5]$, $M = 8$.\n- Test $5$ (dominated item present): $u = [8,7,6,9]$, $p = [5,6,4,7]$, $M = 9$.\n- Test $6$ (budget exceeds total cost, take all): $u = [3,5,2]$, $p = [1,2,1]$, $M = 10$.\n\nDesign for coverage:\n- Test $1$ is a standard nontrivial instance.\n- Test $2$ checks the boundary case $M = 0$.\n- Test $3$ checks handling of zero-price items.\n- Test $4$ checks behavior under ties in utility-price ratios, with a unique optimal total utility.\n- Test $5$ includes a dominated option to verify correct pruning.\n- Test $6$ checks the capacity-dominated regime where the optimal choice is to buy all goods.\n\nAssumptions:\n- All utility entries satisfy $u_i \\ge 0$.\n- All prices satisfy $p_i \\ge 0$, with at least one $p_i > 0$ unless otherwise stated.\n- If any $p_i = 0$ and $u_i > 0$, it is always rational to set $x_i = 1$ for such items.\n\nYour program should compute, for each test case, the maximum achievable total utility as a single integer. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example $[a_1,a_2,\\dots,a_6]$, where $a_j$ is the maximum total utility for test $j$, in the order given above. No physical units or angle units are involved. Express each number as an integer. No percentages are used anywhere in this problem.", "solution": "The problem of discrete consumer choice under an additively separable utility function and a budget constraint is a classic model in microeconomic theory and a fundamental problem in combinatorial optimization. We shall first validate the problem statement, then derive its mathematical formulation, connect it to a known problem structure, and finally design and implement a correct and exact algorithm.\n\n**Problem Formulation**\n\nThe consumer's objective is to maximize total utility derived from a collection of goods, subject to a budget constraint. Let the set of goods be indexed by $i \\in \\{1, \\dots, n\\}$. For each good $i$, the consumer makes a binary decision, represented by the variable $x_i$, where $x_i = 1$ if the good is purchased and $x_i = 0$ if it is not.\nThe utility is additively separable, meaning the total utility is the sum of utilities from individual goods purchased. Given a utility vector $u = (u_1, u_2, \\dots, u_n)$, the total utility is expressed as the linear function:\n$$\nU(x) = \\sum_{i=1}^{n} u_i x_i\n$$\nThe consumer faces a budget constraint. Given a price vector $p = (p_1, p_2, \\dots, p_n)$ and a total budget $M$, the total expenditure must not exceed the budget. This is expressed as the linear inequality:\n$$\n\\sum_{i=1}^{n} p_i x_i \\le M\n$$\nCombining the objective function, the budget constraint, and the binary nature of the decision variables, we arrive at the following integer linear program (ILP) formulation:\n$$\n\\begin{aligned}\n\\text{maximize} \\quad & \\sum_{i=1}^{n} u_i x_i \\\\\n\\text{subject to} \\quad & \\sum_{i=1}^{n} p_i x_i \\le M \\\\\n& x_i \\in \\{0, 1\\}, \\quad \\forall i \\in \\{1, \\dots, n\\}\n\\end{aligned}\n$$\nThis formulation precisely captures the consumer's optimization problem as described. All parameters ($u_i$, $p_i$, $M$) are non-negative real numbers, as given.\n\n**Relation to the 0-1 Knapsack Problem**\n\nThe derived ILP is structurally identical to the canonical 0-1 knapsack problem. The 0-1 knapsack problem is a combinatorial optimization problem defined as follows: given a set of items, each with a value and a weight, determine the subset of items to include in a collection (a \"knapsack\") so that the total value is maximized, subject to the constraint that the total weight does not exceed a given capacity.\n\nThe formal mapping is direct and unambiguous:\n-   The consumer's goods correspond to the *items* in the knapsack problem.\n-   The utility $u_i$ of good $i$ corresponds to the *value* of item $i$.\n-   The price $p_i$ of good $i$ corresponds to the *weight* of item $i$.\n-   The consumer's budget $M$ corresponds to the *capacity* of the knapsack.\n-   The decision variable $x_i$ (to purchase or not) is equivalent to the decision to include an item in the knapsack or not.\n\nTherefore, solving the consumer's utility maximization problem is equivalent to solving an instance of the 0-1 knapsack problem. This problem is known to be NP-hard, which implies that no known algorithm can solve it in time that is polynomial in the number of items and the number of bits required to represent the inputs. However, it admits a pseudo-polynomial time solution via dynamic programming.\n\n**Algorithmic Design: Dynamic Programming**\n\nWe will construct a dynamic programming algorithm to find the exact optimal utility. The algorithm relies on the principle of optimality: an optimal solution to the problem can be constructed from optimal solutions to its subproblems.\n\nFirst, we address the special case of zero-price items. As per the problem's assumption, if a good $i$ has $p_i=0$ and $u_i > 0$, it is always optimal to acquire it, as it provides positive utility at no cost to the budget. We can therefore preprocess the item list. We sum the utilities of all such zero-price items to establish a `base_utility` and then solve the remaining problem for goods with positive prices using the original budget $M$.\n\nLet the remaining items (with $p_i>0$) be indexed from $1$ to $n'$. The subproblem is defined as finding the maximum utility obtainable using a subset of the first $i$ items ($1 \\le i \\le n'$) with a budget of $w$ ($0 \\le w \\le M$). Let $dp[i][w]$ denote the value of this solution.\n\nThe recurrence relation is derived by considering the $i$-th item (utility $u_i$, price $p_i$):\n1.  **Do not include item $i$**: The maximum utility is the same as that achievable with the first $i-1$ items and budget $w$. This value is $dp[i-1][w]$.\n2.  **Include item $i$**: This is possible only if its price $p_i$ does not exceed the current budget $w$. If included, it contributes $u_i$ to the utility, and the remaining budget $w - p_i$ can be used optimally for the first $i-1$ items. The total utility in this case is $u_i + dp[i-1][w-p_i]$.\n\nThe optimal choice is the maximum of these two options. Thus, the recurrence is:\n$$\ndp[i][w] = \\begin{cases}\ndp[i-1][w] & \\text{if } p_i > w \\\\\n\\max(dp[i-1][w], u_i + dp[i-1][w-p_i]) & \\text{if } p_i \\le w\n\\end{cases}\n$$\nThe base cases are $dp[0][w] = 0$ for all $w$, as there is no utility to be gained from zero items.\n\nThis two-dimensional DP formulation has a time complexity of $O(n'M)$ and a space complexity of $O(n'M)$. The space complexity can be optimized to $O(M)$ by observing that the calculation for row $i$ only depends on row $i-1$. By using a single one-dimensional array `dp[w]` and iterating the budget `w` downwards from $M$ to $p_i$, we prevent using the information of item $i$ multiple times within the same item-processing step. The optimized recurrence for a single array `dp` of size $M+1$ is:\n\nFor each item $i$ from $1$ to $n'$:\nFor each budget $w$ from $M$ down to $p_i$:\n$$\ndp[w] = \\max(dp[w], u_i + dp[w-p_i])\n$$\nThe final solution for the subproblem is $dp[M]$. The total maximum utility is this value plus the `base_utility` from zero-price items. Since the problem's test cases involve integer prices and budgets, this DP approach is applicable and efficient. The implementation will follow this optimized space approach.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Solves the discrete consumer choice problem for a suite of test cases.\n    This problem is equivalent to the 0-1 knapsack problem.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test 1 (general case)\n        {'u': [9, 6, 7, 3], 'p': [4, 3, 5, 2], 'M': 7},\n        # Test 2 (zero budget boundary)\n        {'u': [5, 4], 'p': [1, 2], 'M': 0},\n        # Test 3 (zero-price item)\n        {'u': [4, 10, 2], 'p': [0, 5, 3], 'M': 5},\n        # Test 4 (tie in per-dollar utilities, unique optimal utility)\n        {'u': [6, 6, 5], 'p': [4, 4, 5], 'M': 8},\n        # Test 5 (dominated item present)\n        {'u': [8, 7, 6, 9], 'p': [5, 6, 4, 7], 'M': 9},\n        # Test 6 (budget exceeds total cost, take all)\n        {'u': [3, 5, 2], 'p': [1, 2, 1], 'M': 10},\n    ]\n\n    results = []\n    for case in test_cases:\n        utilities = case['u']\n        prices = case['p']\n        budget = case['M']\n        \n        n = len(utilities)\n        base_utility = 0\n        \n        # Preprocessing step for zero-price items\n        positive_price_items = []\n        for i in range(n):\n            if prices[i] == 0:\n                if utilities[i] > 0:\n                    base_utility += utilities[i]\n            else:\n                # We only consider items that could potentially fit in the budget\n                if prices[i] <= budget:\n                    positive_price_items.append({'u': utilities[i], 'p': prices[i]})\n\n        # If budget is 0, no items with positive price can be bought.\n        if budget == 0:\n            results.append(base_utility)\n            continue\n\n        # Dynamic Programming solution for the 0-1 Knapsack problem\n        # dp[w] stores the maximum utility for a budget of w.\n        # The budget is treated as an integer quantity.\n        dp = np.zeros(budget + 1, dtype=int)\n        \n        for item in positive_price_items:\n            utility = item['u']\n            price = item['p']\n            # Iterate backwards to use each item at most once\n            for w in range(budget, price - 1, -1):\n                dp[w] = max(dp[w], utility + dp[w - price])\n                \n        max_utility = dp[budget] + base_utility\n        results.append(int(max_utility))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"}, {"introduction": "Real-world markets are filled with creative pricing strategies that go beyond simple linear prices. This practice explores a common promotional tactic, the \"Buy-One-Get-One-Free\" (BOGO) offer, which creates a non-linear budget constraint for the consumer [@problem_id:2384155]. You will analyze how a consumer with Cobb-Douglas preferences responds to this non-linearity and compare the outcome to a seemingly equivalent, but structurally different, uniform price reduction. This exercise sharpens your ability to model consumer behavior under the complex budget sets that arise from modern marketing strategies.", "id": "2384155", "problem": "Consider a single consumer who allocates a nonnegative quantity of a marketed good $x$ and a nonnegative quantity of a composite outside good $y$ to maximize a Cobb–Douglas utility function $u(x,y) = x^{\\alpha} y^{1-\\alpha}$, where $0 &lt; \\alpha &lt; 1$. The consumer faces a linear budget with total income $I &gt; 0$. The price of $y$ is $p_y &gt; 0$. The marketed good $x$ is sold under two alternative pricing regimes:\n\n- Regime A (Buy-One-Get-One-Free, abbreviated as BOGO): for every unit of $x$ purchased at price $p_x &gt; 0$, the consumer receives one unit of $x$ at zero marginal price. The consumer must choose $x$ in integer units. Under this regime, to consume $x \\in \\{0,1,2,\\dots\\}$ units, the total expenditure on $x$ is $p_x \\cdot \\lceil x/2 \\rceil$, where $\\lceil \\cdot \\rceil$ denotes the ceiling function. The outside good $y$ is continuously divisible.\n- Regime B (Uniform Equivalent Price Reduction): the good $x$ is priced at a uniform per-unit price equal to one half of the original price, that is $p_x' = p_x/2$, with no quantity-based promotions. Both $x$ and $y$ are continuously divisible.\n\nYour task is to simulate and compare the consumer’s optimal choices under these two regimes for a set of parameter values. Use only the foundational definitions of utility maximization and budget feasibility. Do not assume any special structure beyond what is explicitly stated above.\n\nRequirements to implement:\n\n- Under Regime A, the consumer solves the discrete–continuous problem: choose an integer $x \\in \\{0,1,2,\\dots\\}$ and a nonnegative real $y \\ge 0$ to maximize $u(x,y)$ subject to the budget constraint $p_x \\cdot \\lceil x/2 \\rceil + p_y \\cdot y \\le I$. For any fixed feasible integer $x$, the optimal $y$ exhausts the remaining budget. Search over all feasible integers $x$ for which the budget constraint can be satisfied.\n- Under Regime B, the consumer solves the continuous problem: choose $x \\ge 0$ and $y \\ge 0$ to maximize $u(x,y)$ subject to $p_x' x + p_y y \\le I$, where $p_x' = p_x/2$.\n\nFor each test case below, compute:\n- The optimal choice under Regime A, reported as the pair $(x_A^\\star, y_A^\\star)$ with $x_A^\\star$ an integer and $y_A^\\star$ a real number.\n- The optimal choice under Regime B, reported as the pair $(x_B^\\star, y_B^\\star)$, both real numbers.\n- The corresponding utilities $u_A^\\star = u(x_A^\\star, y_A^\\star)$ and $u_B^\\star = u(x_B^\\star, y_B^\\star)$.\n\nTest suite (parameters provided as $(I, p_x, p_y, \\alpha)$):\n\n- Case $1$: $(100, 10, 10, 0.5)$.\n- Case $2$: $(9, 10, 1, 0.5)$.\n- Case $3$: $(20, 7, 2, 0.3)$.\n- Case $4$: $(11, 5, 1, 0.7)$.\n- Case $5$: $(50, 8, 12, 0.1)$.\n\nFinal output format:\n\n- Your program should produce a single line of output containing a list of results for the five cases, in the same order as listed. Each case’s result must be a list of the form $[x_A^\\star, y_A^\\star, x_B^\\star, y_B^\\star, u_A^\\star, u_B^\\star]$.\n- The overall output must thus look like a single list of five inner lists. All real numbers must be rounded to $6$ decimal places. For example: $[[\\dots],[\\dots],[\\dots],[\\dots],[\\dots]]$.", "solution": "The problem presented is a well-defined exercise in consumer theory, a branch of microeconomics. It requires the determination of optimal consumption bundles under two different pricing schemes for a single good, subject to a budget constraint, for a consumer with a Cobb-Douglas utility function. The problem is scientifically grounded, internally consistent, and requires no information beyond what is provided. Thus, it is a valid problem, and a rigorous solution can be constructed.\n\nThe consumer's objective is to maximize the utility function $u(x,y) = x^{\\alpha} y^{1-\\alpha}$ for $x \\ge 0$, $y \\ge 0$, and $0 < \\alpha < 1$. The utility function is strictly increasing in both arguments, which implies that the consumer will always exhaust their entire income, $I$. The budget constraint will therefore always be binding, holding with equality. We analyze the two specified pricing regimes.\n\n### Regime B: Uniform Equivalent Price Reduction\n\nThis regime represents a standard continuous optimization problem. The consumer chooses continuous quantities of goods $x$ and $y$ to maximize utility. The price of good $x$ is set to $p_x' = p_x/2$. The budget constraint is linear:\n$$p_x' x + p_y y = I$$\nSubstituting $p_x' = p_x/2$, we have:\n$$\\frac{p_x}{2} x + p_y y = I$$\nThis is a classic utility maximization problem with a Cobb-Douglas utility function. The solution is found by setting the marginal rate of substitution (MRS) equal to the price ratio.\n$$MRS_{x,y} = \\frac{\\partial u / \\partial x}{\\partial u / \\partial y} = \\frac{\\alpha x^{\\alpha-1} y^{1-\\alpha}}{(1-\\alpha) x^{\\alpha} y^{-\\alpha}} = \\frac{\\alpha y}{(1-\\alpha) x}$$\nThe price ratio is:\n$$\\frac{p_x'}{p_y} = \\frac{p_x/2}{p_y} = \\frac{p_x}{2p_y}$$\nEquating the MRS and the price ratio gives the tangency condition:\n$$\\frac{\\alpha y}{(1-\\alpha) x} = \\frac{p_x}{2p_y}$$\n$$p_y y = \\frac{1-\\alpha}{\\alpha} \\frac{p_x}{2} x$$\nSubstituting this into the budget constraint:\n$$\\frac{p_x}{2} x + \\left(\\frac{1-\\alpha}{\\alpha} \\frac{p_x}{2} x\\right) = I$$\n$$\\frac{p_x}{2} x \\left(1 + \\frac{1-\\alpha}{\\alpha}\\right) = I$$\n$$\\frac{p_x}{2} x \\left(\\frac{\\alpha + 1 - \\alpha}{\\alpha}\\right) = I$$\n$$\\frac{p_x}{2} x \\left(\\frac{1}{\\alpha}\\right) = I$$\nSolving for the optimal quantity $x_B^\\star$:\n$$x_B^\\star = \\frac{2 \\alpha I}{p_x}$$\nSubstituting $x_B^\\star$ back into the expression for $p_y y$:\n$$p_y y_B^\\star = I - \\frac{p_x}{2} x_B^\\star = I - \\frac{p_x}{2} \\left(\\frac{2 \\alpha I}{p_x}\\right) = I - \\alpha I = (1-\\alpha)I$$\nSolving for the optimal quantity $y_B^\\star$:\n$$y_B^\\star = \\frac{(1-\\alpha)I}{p_y}$$\nThese are the Marshallian demand functions for Regime B. The corresponding maximum utility is $u_B^\\star = u(x_B^\\star, y_B^\\star)$.\n\n### Regime A: Buy-One-Get-One-Free (BOGO)\n\nThis regime presents a discrete-continuous optimization problem. The quantity of good $x$ must be an integer, $x_A \\in \\{0, 1, 2, \\ldots\\}$, while the quantity of good $y$ is continuous, $y_A \\ge 0$. The budget constraint is non-linear due to the pricing structure for $x$:\n$$p_x \\lceil x_A/2 \\rceil + p_y y_A = I$$\nwhere $\\lceil \\cdot \\rceil$ is the ceiling function.\n\nFor any given integer choice of $x_A$, the optimal quantity of $y_A$ is determined by the binding budget constraint:\n$$y_A(x_A) = \\frac{I - p_x \\lceil x_A/2 \\rceil}{p_y}$$\nThis choice is feasible only if $y_A(x_A) \\ge 0$, which implies $p_x \\lceil x_A/2 \\rceil \\le I$. This condition establishes an upper bound on the possible integer values of $x_A$. Specifically, $\\lceil x_A/2 \\rceil \\le I/p_x$, which implies $x_A/2 \\le I/p_x$, so $x_A \\le 2I/p_x$. The search for the optimal integer $x_A^\\star$ can be restricted to the finite set:\n$$x_A \\in \\{0, 1, 2, \\ldots, \\lfloor 2I/p_x \\rfloor\\}$$\nalthough a more precise check $p_x \\lceil x_A/2 \\rceil \\le I$ for each $x_A$ is required.\n\nThe problem reduces to a one-dimensional search for the integer $x_A$ that maximizes the utility function, where $y_A$ is substituted out:\n$$\\max_{x_A \\in \\mathbb{Z}_{\\ge 0}, \\, p_x \\lceil x_A/2 \\rceil \\le I} u(x_A, y_A(x_A)) = (x_A)^{\\alpha} \\left( \\frac{I - p_x \\lceil x_A/2 \\rceil}{p_y} \\right)^{1-\\alpha}$$\nThe optimal bundle $(x_A^\\star, y_A^\\star)$ is found by iterating through all feasible integer values of $x_A$ from $0$ up to the maximum value allowed by the budget, calculating the corresponding $y_A(x_A)$ and the utility $u(x_A, y_A(x_A))$, and identifying the value $x_A$ that yields the highest utility.\n\nThe case $x_A = 0$ must be considered. In this case, $y_A(0) = I/p_y$ and $u(0, I/p_y) = 0$. This serves as a baseline utility. The algorithm will search for a positive integer $x_A$ that yields a utility greater than $0$.\n\n### Computational Algorithm\n\nFor each set of parameters $(I, p_x, p_y, \\alpha)$:\n\n1.  **Solve for Regime B:**\n    - Calculate $x_B^\\star = \\frac{2 \\alpha I}{p_x}$.\n    - Calculate $y_B^\\star = \\frac{(1-\\alpha)I}{p_y}$.\n    - Calculate $u_B^\\star = (x_B^\\star)^{\\alpha} (y_B^\\star)^{1-\\alpha}$.\n\n2.  **Solve for Regime A:**\n    - Initialize optimal values: $x_A^\\star = 0$, $y_A^\\star = I/p_y$, $u_A^\\star = 0$.\n    - Determine the maximum search value for $x_A$: $x_{max} = \\lfloor 2I/p_x \\rfloor$.\n    - Iterate $x_{test}$ from $1$ to $x_{max}$.\n    - For each $x_{test}$:\n        - Calculate the expenditure on $x$: $E_x = p_x \\cdot \\lceil x_{test}/2 \\rceil$.\n        - If $E_x > I$, this and all subsequent values of $x_{test}$ are infeasible, so terminate the search.\n        - Calculate the corresponding quantity of $y$: $y_{test} = (I - E_x)/p_y$.\n        - Calculate the utility: $u_{test} = (x_{test})^{\\alpha} (y_{test})^{1-\\alpha}$.\n        - If $u_{test} > u_A^\\star$, update the optimal values: $x_A^\\star = x_{test}$, $y_A^\\star = y_{test}$, $u_A^\\star = u_{test}$.\n\n3.  **Report Results:**\n    - Collect the computed values $(x_A^\\star, y_A^\\star, x_B^\\star, y_B^\\star, u_A^\\star, u_B^\\star)$ for the given parameter set.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the consumer utility maximization problem for two different pricing regimes\n    across a suite of test cases.\n    \"\"\"\n    # Test cases are provided as tuples of (I, p_x, p_y, alpha)\n    test_cases = [\n        (100.0, 10.0, 10.0, 0.5),\n        (9.0, 10.0, 1.0, 0.5),\n        (20.0, 7.0, 2.0, 0.3),\n        (11.0, 5.0, 1.0, 0.7),\n        (50.0, 8.0, 12.0, 0.1),\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        I, px, py, alpha = case\n\n        # --- Regime B: Uniform Equivalent Price Reduction (Continuous) ---\n        # Price of x is halved: p_x' = p_x / 2\n        px_prime = px / 2.0\n        \n        # Standard Cobb-Douglas demand functions\n        x_star_B = (alpha * I) / px_prime\n        y_star_B = ((1.0 - alpha) * I) / py\n        \n        # Calculate resulting utility\n        u_star_B = (x_star_B**alpha) * (y_star_B**(1.0 - alpha))\n        \n        # --- Regime A: Buy-One-Get-One-Free (Discrete-Continuous) ---\n        # Initialize with the bundle (0, I/py), which has utility 0\n        x_star_A = 0\n        y_star_A = I / py\n        u_star_A = 0.0\n\n        # Maximum possible integer value for x to search\n        x_max_search = int(np.floor(2.0 * I / px))\n\n        for x_test in range(1, x_max_search + 1):\n            # Cost of x under BOGO pricing: p_x * ceil(x/2)\n            cost_x = px * np.ceil(x_test / 2.0)\n\n            # If expenditure on x exceeds income, it's not a feasible bundle\n            if cost_x > I:\n                # Since cost_x is non-decreasing in x_test, we can stop searching\n                break\n            \n            # Remaining budget for y\n            y_test = (I - cost_x) / py\n            \n            # Calculate utility for this (x, y) bundle\n            # y_test will be non-negative due to the check above\n            u_test = (x_test**alpha) * (y_test**(1.0 - alpha))\n\n            # If this utility is the best so far, update the optimal choice\n            if u_test > u_star_A:\n                u_star_A = u_test\n                x_star_A = x_test\n                y_star_A = y_test\n\n        # Store results for this case. x_star_A is already an integer.\n        # Round all float values to 6 decimal places for final output.\n        case_results = [\n            x_star_A,\n            round(y_star_A, 6),\n            round(x_star_B, 6),\n            round(y_star_B, 6),\n            round(u_star_A, 6),\n            round(u_star_B, 6),\n        ]\n        all_results.append(case_results)\n\n    # Format the final output as a single-line string representation of a list of lists.\n    # Convert each inner list to its string representation and join them.\n    results_str = ','.join(map(str, all_results))\n    print(f\"[{results_str}]\")\n\nsolve()\n```"}, {"introduction": "This final practice is a comprehensive challenge that synthesizes many core concepts to tackle a highly realistic problem: selecting the best mobile data plan. You are tasked with maximizing a logarithmic utility function subject to a complex, piecewise-linear budget constraint featuring fixed fees, tiered pricing, and a hard data cap [@problem_id:2384169]. This requires you to develop a robust computational strategy that evaluates all possible optimal points—both interior solutions within price tiers and boundary solutions at the kinks—and then compares utility across different plans. Mastering this problem will equip you with the skills to model and solve complex, real-world consumer choice problems from first principles.", "id": "2384169", "problem": "A single representative consumer chooses a mobile data plan and a data usage level to maximize utility subject to a budget constraint that incorporates a fixed subscription fee, tiered per-unit prices, and a hard data cap. The consumer has exogenous income $I \\in \\mathbb{R}_{++}$ and derives utility from data usage $x \\in \\mathbb{R}_{+}$ and from a composite numeraire good $y \\in \\mathbb{R}_{+}$. The utility function is\n$$\nu(x,y) \\;=\\; a \\,\\ln(x + s) \\;+\\; b \\,\\ln(y),\n$$\nwhere $a \\in \\mathbb{R}_{++}$ and $b \\in \\mathbb{R}_{++}$ are preference weights, and $s \\in \\mathbb{R}_{++}$ is a small smoothing constant that guarantees that $\\ln(x+s)$ is well-defined at $x=0$.\n\nA mobile data plan $j$ is defined by a fixed fee $F_j \\in \\mathbb{R}_{+}$, a hard cap $C_j \\in \\mathbb{R}_{+}$, and a finite tiered price schedule with breakpoints\n$$\n0 \\;=\\; b_{j,0} \\;<\\; b_{j,1} \\;<\\; \\cdots \\;<\\; b_{j,K_j} \\;=\\; C_j,\n$$\nand corresponding per-unit prices $p_{j,1},\\dots,p_{j,K_j} \\in \\mathbb{R}_{+}$, where for tier $k \\in \\{1,\\dots,K_j\\}$ the marginal price is $p_{j,k}$ for usage $x \\in (b_{j,k-1}, b_{j,k}]$. The total data expenditure at usage $x$ is the piecewise-linear function\n$$\n\\operatorname{Cost}_j(x) \\;=\\; \\sum_{k=1}^{K_j} p_{j,k} \\,\\max\\!\\left(\\min\\!\\left(x - b_{j,k-1},\\, b_{j,k}-b_{j,k-1}\\right),\\, 0\\right).\n$$\nThe budget constraint under plan $j$ is\n$$\ny \\;=\\; I \\;-\\; F_j \\;-\\; \\operatorname{Cost}_j(x),\n$$\nwith the feasibility requirement $y \\in \\mathbb{R}_{++}$ due to the logarithmic term, and the data usage constraint $0 \\le x \\le C_j$ due to the hard cap. The consumer may also choose an outside option of \"no plan,\" denoted by index $-1$, which yields $x=0$, $y=I$, and utility $u(0,I)=a\\ln(s)+b\\ln(I)$.\n\nYour task is to compute the optimal plan choice and data usage that maximize utility. The problem must be derived from first principles and implemented as a complete program that solves a fixed test suite.\n\nFoundational base for derivation and algorithm design:\n- The utility maximization principle: choose $(x,y)$ to maximize $u(x,y)$ subject to a linear budget constraint and nonnegativity constraints.\n- Concavity of the logarithm implies that $u(x,y)$ is strictly concave in $(x,y)$ for $a>0$, $b>0$, $s>0$.\n- Piecewise linear pricing implies a piecewise linear budget frontier in $(x,y)$ for a given plan.\n- Kuhn–Tucker conditions with Lagrangian multipliers for inequality constraints are valid for characterizing optima in concave programs.\n\nWithin any tier $k$ of plan $j$ where the marginal price is constant, the marginal price is $p_{j,k}$ for $x \\in (b_{j,k-1}, b_{j,k}]$. Let the cumulative cost up to $b_{j,k-1}$ be\n$$\nS_{j,k-1} \\;=\\; \\sum_{i=1}^{k-1} p_{j,i}\\,\\left(b_{j,i} - b_{j,i-1}\\right),\n$$\nand define\n$$\nA_{j,k} \\;=\\; I \\;-\\; F_j \\;-\\; S_{j,k-1} \\;+\\; p_{j,k}\\,b_{j,k-1}.\n$$\nAssuming an interior solution within tier $k$ (that is, $b_{j,k-1} < x < b_{j,k}$ and $y>0$), the first-order optimality conditions imply\n$$\n\\frac{a}{x+s} \\;=\\; \\lambda\\,p_{j,k}, \n\\qquad \n\\frac{b}{y} \\;=\\; \\lambda,\n\\qquad \ny \\;=\\; A_{j,k} \\;-\\; p_{j,k}\\,x,\n$$\nwhich combine to the candidate interior solution\n$$\nx^{\\star}_{j,k} \\;=\\; \\frac{\\frac{A_{j,k}}{p_{j,k}} \\;-\\; \\frac{b}{a}\\,s}{1 \\;+\\; \\frac{b}{a}}, \n\\qquad \ny^{\\star}_{j,k} \\;=\\; A_{j,k} \\;-\\; p_{j,k}\\,x^{\\star}_{j,k}.\n$$\nThis candidate is only valid if $b_{j,k-1} < x^{\\star}_{j,k} < b_{j,k}$ and $y^{\\star}_{j,k} > 0$. Otherwise, the optimum in that tier lies on a boundary ($x=b_{j,k-1}$ or $x=b_{j,k}$). Globally for a given plan, the optimum is the maximum of the utility evaluated at:\n- All interior candidates $x^{\\star}_{j,k}$ that are feasible.\n- All tier boundaries $x \\in \\{0, b_{j,1},\\dots,b_{j,K_j}\\}$ with $y>0$.\nFinally, across all plans and the outside option, choose the option with the highest utility.\n\nImplement a program that, for each test case below, computes:\n- The index of the chosen plan ($-1$ for the outside option, otherwise $0$-based plan index within that test case).\n- The optimal data usage $x^{\\star}$.\n- The optimal leftover money $y^{\\star}$.\n- The achieved utility $u^{\\star}$.\n\nAll numerical results must be printed as real numbers except for the plan index, which is an integer. For evaluation purposes, round $x^{\\star}$, $y^{\\star}$, and $u^{\\star}$ to $6$ decimal places in the final output. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[r_1,r_2,\\dots]$), where each $r_i$ is the Python list representation of $[\\text{plan\\_index}, x^{\\star}, y^{\\star}, u^{\\star}]$ for the corresponding test case.\n\nTest Suite:\nFor each case, the tuple lists $(I, a, b, s)$ and then the plan set. Each plan is specified as $(F, C, \\text{tiers})$, where $\\text{tiers}$ is a sequence of $(\\text{upper\\_breakpoint}, \\text{price})$ pairs that strictly increase in the breakpoint and end at the cap.\n\n- Case $1$: $(I, a, b, s) = (\\,100,\\, 0.6,\\, 0.4,\\, 0.1\\,)$ with plans:\n  - Plan $0$: $(F, C, \\text{tiers}) = (\\,10,\\, 50,\\, [\\,(10,\\, 2.0),\\, (30,\\, 1.0),\\, (50,\\, 3.0)\\,]\\,)$.\n  - Plan $1$: $(F, C, \\text{tiers}) = (\\,25,\\, 120,\\, [\\,(60,\\, 0.8),\\, (120,\\, 1.5)\\,]\\,)$.\n- Case $2$: $(I, a, b, s) = (\\,8,\\, 0.5,\\, 0.5,\\, 0.1\\,)$ with plans:\n  - Plan $0$: $(F, C, \\text{tiers}) = (\\,10,\\, 20,\\, [\\,(10,\\, 1.5),\\, (20,\\, 2.0)\\,]\\,)$.\n  - Plan $1$: $(F, C, \\text{tiers}) = (\\,15,\\, 100,\\, [\\,(50,\\, 1.0),\\, (100,\\, 1.0)\\,]\\,)$.\n- Case $3$: $(I, a, b, s) = (\\,60,\\, 0.9,\\, 0.1,\\, 0.1\\,)$ with plans:\n  - Plan $0$: $(F, C, \\text{tiers}) = (\\,5,\\, 5,\\, [\\,(5,\\, 1.0)\\,]\\,)$.\n  - Plan $1$: $(F, C, \\text{tiers}) = (\\,5,\\, 100,\\, [\\,(100,\\, 10.0)\\,]\\,)$.\n- Case $4$: $(I, a, b, s) = (\\,40,\\, 0.6,\\, 0.4,\\, 0.1\\,)$ with plans:\n  - Plan $0$: $(F, C, \\text{tiers}) = (\\,0,\\, 20,\\, [\\,(10,\\, 0.5),\\, (20,\\, 5.0)\\,]\\,)$.\n  - Plan $1$: $(F, C, \\text{tiers}) = (\\,5,\\, 20,\\, [\\,(20,\\, 1.5)\\,]\\,)$.\n- Case $5$: $(I, a, b, s) = (\\,50,\\, 0.3,\\, 0.7,\\, 0.1\\,)$ with plans:\n  - Plan $0$: $(F, C, \\text{tiers}) = (\\,45,\\, 100,\\, [\\,(100,\\, 0.1)\\,]\\,)$.\n  - Plan $1$: $(F, C, \\text{tiers}) = (\\,5,\\, 30,\\, [\\,(15,\\, 3.0),\\, (30,\\, 5.0)\\,]\\,)$.\n\nYour program must compute the optimal choice for each case and output a single line:\n- The line must be the Python list literal of the case-by-case results, where each case result is $[\\text{plan\\_index}, x^{\\star}, y^{\\star}, u^{\\star}]$ with $x^{\\star}$, $y^{\\star}$, and $u^{\\star}$ rounded to $6$ decimals.", "solution": "The user demands a solution to a consumer utility maximization problem involving a complex budget constraint. I will first validate the problem statement and then, if it is valid, proceed to a principled derivation and algorithmic solution.\n\n### Step 1: Extract Givens\n\n- **Utility Function**: $u(x,y) = a \\ln(x + s) + b \\ln(y)$, for data usage $x \\in \\mathbb{R}_{+}$ and a numeraire good $y \\in \\mathbb{R}_{+}$.\n- **Parameters**: Income $I \\in \\mathbb{R}_{++}$, preference weights $a, b \\in \\mathbb{R}_{++}$, and smoothing constant $s \\in \\mathbb{R}_{++}$.\n- **Plan Definition**: A plan $j$ is defined by a fixed fee $F_j \\in \\mathbb{R}_{+}$, a hard cap $C_j \\in \\mathbb{R}_{+}$, and a tiered price schedule with breakpoints $0 = b_{j,0} < b_{j,1} < \\cdots < b_{j,K_j} = C_j$ and corresponding marginal prices $p_{j,k} \\in \\mathbb{R}_{++}$ for usage $x \\in (b_{j,k-1}, b_{j,k}]$.\n- **Cost Function**: $\\operatorname{Cost}_j(x) = \\sum_{k=1}^{K_j} p_{j,k} \\max(\\min(x - b_{j,k-1}, b_{j,k}-b_{j,k-1}), 0)$.\n- **Budget Constraint**: $y = I - F_j - \\operatorname{Cost}_j(x)$, subject to $y > 0$ and $0 \\le x \\le C_j$.\n- **Outside Option**: An option with index $-1$ yielding $x=0$, $y=I$, and utility $u(-1) = a\\ln(s) + b\\ln(I)$.\n- **Optimization Strategy Hint**: The global optimum for a plan is found by comparing utility at all tier boundaries $\\{0, b_{j,1}, \\dots, b_{j,K_j}\\}$ and all valid interior candidates $x^{\\star}_{j,k}$ derived from first-order conditions for each tier.\n- **Interior Candidate Formula**: For tier $k$, the candidate is $x^{\\star}_{j,k} = \\frac{\\frac{A_{j,k}}{p_{j,k}} - \\frac{b}{a}s}{1 + \\frac{b}{a}}$, where $A_{j,k} = I - F_j - \\sum_{i=1}^{k-1} p_{j,i}(b_{j,i} - b_{j,i-1}) + p_{j,k}b_{j,k-1}$.\n- **Test Suite**: Five test cases are provided with specific numerical values for all parameters.\n\n### Step 2: Validate Using Extracted Givens\n\nThe problem is subjected to rigorous validation.\n\n1.  **Scientifically Grounded**: The problem is a standard exercise in microeconomic consumer theory. The utility function is a variant of the Cobb-Douglas form, which is strictly quasi-concave. The budget constraint is piecewise linear, a common feature in real-world pricing schemes. The optimization approach using first-order (Kuhn-Tucker) conditions is the correct and standard method for such problems. The problem is fundamentally sound.\n2.  **Well-Posed**: The utility function $u(x,y)$ is continuous and strictly concave on its domain $\\mathbb{R}_{++} \\times \\mathbb{R}_{++}$. For each plan $j$, the set of feasible consumption bundles $(x,y)$ forms a convex set. The requirement $y>0$ due to the $\\ln(y)$ term means the feasible set is not closed, but the Inada condition on $y$ (marginal utility of $y$ approaches infinity as $y$ approaches zero) ensures that any optimal solution must have $y^* > 0$. An optimum therefore exists and is unique due to strict concavity. The problem is well-posed.\n3.  **Objective**: All terms are defined with mathematical precision. The problem is stated objectively, free from ambiguity or subjective content.\n4.  **Completeness**: All required data ($I, a, b, s$, and plan structures) are provided for each test case. The problem is self-contained. The provided formulas are mathematically consistent.\n5.  **Structure and Feasibility**: The problem structure is logical. It requires finding the maximum of a function over a domain composed of several linear segments. The proposed method of checking segment interiors and boundaries (kink points) is a complete approach for finding the global optimum for a given plan. The parameters are within realistic numerical ranges.\n\n### Step 3: Verdict and Action\n\nThe problem is **valid**. It is a well-defined, solvable problem in computational economics. I will now provide a complete solution.\n\n### Principle-Based Solution Design\n\nThe problem is to maximize a strictly concave utility function $u(x,y)$ over a budget set defined by a piecewise linear cost function. The optimal solution for the consumer is found by a two-stage process: first, for each available plan $j$, find the optimal consumption bundle $(x_j^*, y_j^*)$ and the corresponding maximum utility $u_j^*$; second, compare these utilities across all plans and the outside option to identify the global optimum.\n\n**Stage 1: Solving for a Single Plan $j$**\n\nFor a given plan $j$, the budget set is $\\{(x,y) | y = I - F_j - \\operatorname{Cost}_j(x), 0 \\le x \\le C_j, y > 0 \\}$. The total cost function $\\operatorname{Cost}_j(x)$ is continuous and piecewise linear, with kinks at the tier breakpoints $b_{j,k}$. Consequently, the budget frontier in $(x,y)$-space is also piecewise linear.\n\nThe maximum of a concave function over such a set must lie at one of two types of locations:\n1.  **A kink point**: These are the points corresponding to data usage levels at the tier boundaries, $x \\in \\{b_{j,0}, b_{j,1}, \\dots, b_{j,K_j}\\}$.\n2.  **An interior point of a linear segment**: Within a given tier $k$, for $x \\in (b_{j,k-1}, b_{j,k})$, the marginal price of data is constant at $p_{j,k}$. The budget constraint becomes linear: $y = A_{j,k} - p_{j,k}x$. The optimum within this segment, if it exists, is found by solving the first-order conditions of the Lagrangian, yielding the candidate solution $x_{j,k}^{\\star}$ as given in the problem statement.\n\nThe algorithm for solving for a single plan $j$ is as follows:\n\n1.  **Assemble Candidate Points**: Create a set of candidate values for the optimal data usage $x$.\n    -   Add all tier boundaries to this set: $\\{0, b_{j,1}, \\dots, b_{j,K_j}\\}$. Note that $b_{j,0}=0$ and $b_{j,K_j}=C_j$.\n    -   For each tier $k \\in \\{1, \\dots, K_j\\}$:\n        -   Calculate the parameters of the linear budget segment: the constant price $p_{j,k}$ and the effective income intercept $A_{j,k}$.\n        -   Compute the interior candidate $x_{j,k}^{\\star}$ using the formula:\n            $$\n            x^{\\star}_{j,k} = \\frac{(a/p_{j,k}) A_{j,k} - b s}{a+b}\n            $$\n        -   If this candidate is strictly within the tier's bounds, i.e., $b_{j,k-1} < x_{j,k}^{\\star} < b_{j,k}$, add it to the set of candidate points.\n\n2.  **Evaluate Candidates**: Iterate through the set of unique candidate points $x_{cand}$.\n    -   For each $x_{cand}$, calculate the total expenditure $\\operatorname{Cost}_j(x_{cand})$ and the remaining income for the numeraire good, $y_{cand} = I - F_j - \\operatorname{Cost}_j(x_{cand})$.\n    -   Check for feasibility: the plan is only viable if the fixed fee is affordable ($I > F_j$) and the chosen consumption bundle yields a positive amount of the numeraire good ($y_{cand} > 0$). The term $\\ln(y)$ in the utility function already enforces this; any candidate with $y_{cand} \\le 0$ is implicitly rejected as it yields a utility of $-\\infty$.\n    -   If feasible ($y_{cand} > 0$), compute the utility $u(x_{cand}, y_{cand}) = a \\ln(x_{cand} + s) + b \\ln(y_{cand})$.\n\n3.  **Determine Plan Optimum**: The optimal bundle for plan $j$, $(x_j^*, y_j^*)$, is the feasible candidate pair $(x_{cand}, y_{cand})$ that yields the highest utility. The maximum utility for the plan is $u_j^*$.\n\n**Stage 2: Global Optimization**\n\n1.  **Establish Baseline**: Calculate the utility of the \"no plan\" outside option, where $x_{-1}^*=0$ and $y_{-1}^*=I$. The utility is $u_{-1}^* = a \\ln(s) + b \\ln(I)$. This serves as the initial best-case scenario.\n\n2.  **Iterate and Compare**: For each plan $j=0, 1, \\dots$, perform Stage 1 to find its optimal utility $u_j^*$. Compare this with the current highest utility found so far. If $u_j^*$ is greater, then plan $j$ becomes the new best choice, and its optimal bundle $(x_j^*, y_j^*)$ and utility $u_j^*$ are recorded.\n\n3.  **Final Result**: After evaluating all plans, the recorded best choice represents the global optimum for the consumer. The final output consists of the index of this optimal plan (or $-1$ for the outside option), the optimal data usage $x^*$, the optimal numeraire consumption $y^*$, and the maximized utility $u^*$.\n\nThis systematic search guarantees finding the global maximum because it considers all possible types of optima for a concave program with a piecewise linear boundary.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the consumer utility maximization problem for a series of test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1\n        {\n            \"params\": (100, 0.6, 0.4, 0.1),\n            \"plans\": [\n                (10, 50, [(10, 2.0), (30, 1.0), (50, 3.0)]),\n                (25, 120, [(60, 0.8), (120, 1.5)]),\n            ],\n        },\n        # Case 2\n        {\n            \"params\": (8, 0.5, 0.5, 0.1),\n            \"plans\": [\n                (10, 20, [(10, 1.5), (20, 2.0)]),\n                (15, 100, [(50, 1.0), (100, 1.0)]),\n            ],\n        },\n        # Case 3\n        {\n            \"params\": (60, 0.9, 0.1, 0.1),\n            \"plans\": [\n                (5, 5, [(5, 1.0)]),\n                (5, 100, [(100, 10.0)]),\n            ],\n        },\n        # Case 4\n        {\n            \"params\": (40, 0.6, 0.4, 0.1),\n            \"plans\": [\n                (0, 20, [(10, 0.5), (20, 5.0)]),\n                (5, 20, [(20, 1.5)]),\n            ],\n        },\n        # Case 5\n        {\n            \"params\": (50, 0.3, 0.7, 0.1),\n            \"plans\": [\n                (45, 100, [(100, 0.1)]),\n                (5, 30, [(15, 3.0), (30, 5.0)]),\n            ],\n        },\n    ]\n\n    results = []\n\n    for case in test_cases:\n        I, a, b, s = case[\"params\"]\n        plans = case[\"plans\"]\n\n        # Initialize with the outside option (\"no plan\")\n        best_option = {\n            \"plan_index\": -1,\n            \"x\": 0.0,\n            \"y\": I,\n            \"u\": a * np.log(s) + b * np.log(I),\n        }\n\n        for j, plan_spec in enumerate(plans):\n            F, C, tiers = plan_spec\n\n            if I < F:\n                continue  # Fixed fee is unaffordable\n\n            breakpoints = [0.0] + [t[0] for t in tiers]\n            prices = [t[1] for t in tiers]\n\n            # --- Stage 1: Find best option for this plan ---\n            \n            # 1. Assemble candidate points for x\n            candidate_x = set(breakpoints)\n\n            cumulative_cost_at_prev_breakpoint = 0.0\n            for k in range(len(prices)):\n                p_k = prices[k]\n                b_prev = breakpoints[k]\n                b_curr = breakpoints[k+1]\n\n                # S_{j,k-1} from problem description\n                S_prev = cumulative_cost_at_prev_breakpoint\n                # A_{j,k} from problem description\n                A_k = I - F - S_prev + p_k * b_prev\n\n                # Calculate interior candidate x_star\n                # Using formula: x_star = (a*A/p - b*s)/(a+b)\n                if p_k > 0:\n                    numerator = a * A_k / p_k - b * s\n                    if numerator > 0:\n                        x_star = numerator / (a + b)\n                        if b_prev < x_star < b_curr:\n                            candidate_x.add(x_star)\n                \n                # Update cumulative cost for the next tier\n                cumulative_cost_at_prev_breakpoint += p_k * (b_curr - b_prev)\n\n            plan_best_u = -np.inf\n            plan_best_x = 0.0\n            plan_best_y = 0.0\n\n            # 2. Evaluate all candidates\n            for x_cand in sorted(list(candidate_x)):\n                \n                # Calculate cost for x_cand\n                cost = 0.0\n                x_remaining = x_cand\n                for k in range(len(prices)):\n                    tier_start = breakpoints[k]\n                    tier_end = breakpoints[k+1]\n                    tier_price = prices[k]\n\n                    if x_remaining <= 0:\n                        break\n                    \n                    usage_in_tier = min(x_remaining, tier_end - tier_start)\n                    cost += usage_in_tier * tier_price\n                    x_remaining -= usage_in_tier\n                \n                y_cand = I - F - cost\n                \n                # Check feasibility and calculate utility\n                if y_cand > 0:\n                    u_cand = a * np.log(x_cand + s) + b * np.log(y_cand)\n                    if u_cand > plan_best_u:\n                        plan_best_u = u_cand\n                        plan_best_x = x_cand\n                        plan_best_y = y_cand\n\n            # --- Stage 2: Compare plan's best with overall best ---\n            if plan_best_u > best_option[\"u\"]:\n                best_option = {\n                    \"plan_index\": j,\n                    \"x\": plan_best_x,\n                    \"y\": plan_best_y,\n                    \"u\": plan_best_u,\n                }\n\n        results.append([\n            best_option[\"plan_index\"],\n            round(best_option[\"x\"], 6),\n            round(best_option[\"y\"], 6),\n            round(best_option[\"u\"], 6),\n        ])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"}]}