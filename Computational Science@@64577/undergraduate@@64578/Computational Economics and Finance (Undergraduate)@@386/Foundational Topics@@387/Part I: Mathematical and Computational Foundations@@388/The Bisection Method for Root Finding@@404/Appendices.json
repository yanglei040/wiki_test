{"hands_on_practices": [{"introduction": "The bisection method is prized not just for its simplicity but for its guaranteed convergence. This guarantee is not merely a qualitative assurance; it is quantitatively precise. By understanding the method's error bounds, we can determine, even before running the algorithm, the exact number of iterations needed to narrow the solution down to any desired level of accuracy.\n\nThis first practice exercise [@problem_id:2438012] invites you to perform such a calculation. You will determine the minimum number of steps required to find a project's Internal Rate of Return (IRR) within a specific tolerance. This reinforces the core principle of exponential error reduction and highlights the predictable performance that makes the bisection method a reliable tool in the computational toolkit.", "id": "2438012", "problem": "A capital budgeting analysis considers a conventional investment project with horizon $50$ years: an initial outlay $c_{0} &lt; 0$ at time $t=0$ followed by nonnegative net cash flows $c_{t} \\ge 0$ for $t=1,2,\\dots,50$, not all cash flows equal to zero. The Internal Rate of Return (IRR) $r^{\\ast}$ is defined as the root of the net present value function\n$$\n\\mathrm{NPV}(r) \\equiv \\sum_{t=0}^{50} \\frac{c_{t}}{(1+r)^{t}} = 0,\n$$\nwhere $r \\ge 0$ is the discount rate in decimal form. Under these cash-flow conditions, $\\mathrm{NPV}(r)$ is continuous and strictly decreasing in $r$ for $r \\ge 0$, so any sign change bracket contains a unique IRR.\n\nSuppose it is known that $r^{\\ast} \\in [0,\\,0.30]$, and that $\\mathrm{NPV}(0) \\ge 0$ while $\\mathrm{NPV}(0.30) \\le 0$, so the bisection method can be applied on the initial bracket $[a_{0}, b_{0}] = [0,\\,0.30]$. You use the bisection method and, at iteration $N$, report the midpoint of the current bracketing interval as the estimate of $r^{\\ast}$. You want to guarantee that the absolute estimation error is at most one basis point, where one basis point is $0.0001$ in decimal units of rate.\n\nAssuming worst-case placement of $r^{\\ast}$ within the bracket at each iteration, what is the minimal number of bisection iterations $N$ required to guarantee $|r_{N} - r^{\\ast}| \\le 0.0001$, where $r_{N}$ is the midpoint after $N$ iterations? Provide your answer as a single integer. No rounding is required.", "solution": "The problem statement has been validated and is deemed valid. It is scientifically grounded, well-posed, objective, and internally consistent. It presents a standard application of the bisection method for root finding in the context of computational finance, a problem which is well-defined and solvable.\n\nThe problem asks for the minimum number of iterations $N$ of the bisection method to guarantee a certain precision for the estimate of the Internal Rate of Return, $r^{\\ast}$. The core of the solution lies in the error analysis of the bisection method.\n\nLet the initial interval be $[a_0, b_0]$, where the root $r^{\\ast}$ is known to lie. The length of this interval is $L_0 = b_0 - a_0$. The bisection method iteratively halves the length of the bracketing interval. After $N$ iterations, the new interval containing the root, $[a_N, b_N]$, will have a length of:\n$$\nL_N = b_N - a_N = \\frac{b_0 - a_0}{2^N}\n$$\nThe problem specifies that the estimate of the root after $N$ iterations, denoted $r_N$, is the midpoint of this resulting interval $[a_N, b_N]$.\n$$\nr_N = \\frac{a_N + b_N}{2}\n$$\nSince the true root $r^{\\ast}$ is guaranteed to be within the interval $[a_N, b_N]$, i.e., $a_N \\le r^{\\ast} \\le b_N$, the absolute error of the estimate $r_N$ is given by $|r_N - r^{\\ast}|$. The problem states to assume the worst-case placement of $r^{\\ast}$. The maximum possible error occurs when $r^{\\ast}$ is located at one of the endpoints of the interval.\n$$\n|r_N - r^{\\ast}| \\le \\max(r_N - a_N, b_N - r_N)\n$$\nSince $r_N$ is the midpoint, this maximum error is half the length of the interval $[a_N, b_N]$:\n$$\n|r_N - r^{\\ast}| \\le \\frac{b_N - a_N}{2} = \\frac{L_N}{2}\n$$\nSubstituting the expression for $L_N$, we obtain the error bound after $N$ iterations:\n$$\n|r_N - r^{\\ast}| \\le \\frac{b_0 - a_0}{2^{N+1}}\n$$\nThe problem provides the initial interval $[a_0, b_0] = [0, 0.30]$. Thus, $a_0 = 0$ and $b_0 = 0.30$. The required absolute error tolerance is one basis point, which is $0.0001$. We must find the minimum integer $N$ that satisfies the condition:\n$$\n|r_N - r^{\\ast}| \\le 0.0001\n$$\nUsing the error bound, we establish the inequality:\n$$\n\\frac{b_0 - a_0}{2^{N+1}} \\le 0.0001\n$$\nSubstituting the values for $a_0$ and $b_0$:\n$$\n\\frac{0.30 - 0}{2^{N+1}} \\le 0.0001\n$$\n$$\n\\frac{0.30}{2^{N+1}} \\le 0.0001\n$$\nTo solve for $N$, we rearrange the inequality:\n$$\n0.30 \\le 0.0001 \\times 2^{N+1}\n$$\n$$\n\\frac{0.30}{0.0001} \\le 2^{N+1}\n$$\n$$\n3000 \\le 2^{N+1}\n$$\nTo isolate the exponent, we take the base-$2$ logarithm of both sides:\n$$\n\\log_{2}(3000) \\le N+1\n$$\nWe can compute the value of $\\log_{2}(3000)$ using the change of base formula, $\\log_{b}(x) = \\frac{\\ln(x)}{\\ln(b)}$:\n$$\n\\frac{\\ln(3000)}{\\ln(2)} \\le N+1\n$$\nUsing numerical values for the natural logarithms, $\\ln(3000) \\approx 8.006367$ and $\\ln(2) \\approx 0.693147$:\n$$\n\\frac{8.006367}{0.693147} \\approx 11.5507 \\le N+1\n$$\nSubtracting $1$ from both sides gives the condition for $N$:\n$$\n11.5507 - 1 \\le N\n$$\n$$\n10.5507 \\le N\n$$\nSince the number of iterations $N$ must be an integer, we must select the smallest integer that satisfies this condition. The smallest integer $N$ greater than or equal to $10.5507$ is $11$.\nThus, a minimum of $11$ iterations are required to guarantee that the absolute estimation error is at most $0.0001$.", "answer": "$$\\boxed{11}$$"}, {"introduction": "Having explored the theoretical convergence of the bisection method, it is time to apply it to a practical scenario. One of the most common applications of root-finding algorithms in finance is the calculation of a bond's yield, which is the interest rate that equates the present value of its future cash flows to its current market price. Since the bond price is a monotonic function of the yield, the bisection method is a perfectly suitable and robust tool for this task.\n\nIn this hands-on coding exercise [@problem_id:2437995], you will implement the bisection algorithm to compute the Yield-to-Call (YTC) for a callable bond. This task bridges the gap between abstract algorithm and concrete application, giving you direct experience in building a function from financial principles and using the bisection method to solve for a key financial metric.", "id": "2437995", "problem": "You are tasked with computing the annual nominal Yield-to-Call (YTC) for callable fixed-coupon bonds by numerically solving the bond pricing fixed-point equation using the bisection method. Work in purely mathematical terms and consider the following foundational base: the present value of future deterministic cash flows equals the observed market price when discounted at the correct yield. For a callable bond that is certain to be called after a specified number of future coupon periods, the cash flows consist of periodic coupons until the call date and a final combined payment at the call date equal to the last coupon plus the call price. Assume no default risk, deterministic discounting, and no day-count conventions beyond the specified discrete compounding.\n\nDefinition of quantities:\n- Let $P$ denote the observed bond price.\n- Let $M$ denote the bondâ€™s par value.\n- Let $\\kappa$ denote the annual coupon rate (as a decimal).\n- Let $m$ denote the number of coupon payments per year (an integer).\n- Let $n$ denote the number of coupon periods until the call date (an integer).\n- Let $K$ denote the call price received at the call date.\n- Let $y$ denote the annual nominal YTC with compounding frequency $m$ (as a decimal).\n- Let $C$ denote the per-period coupon given by $C = \\frac{\\kappa}{m} M$.\n- Let $r$ denote the per-period yield given by $r = \\frac{y}{m}$.\n- Let $D_t(y)$ denote the discount factor for period $t$, given by $D_t(y) = \\left(1 + \\frac{y}{m}\\right)^{-t}$.\n\nFundamental pricing relation:\nThe YTC $y$ is defined implicitly by equating the present value of cash flows to price $P$:\n$$\nP = \\sum_{t=1}^{n-1} C \\cdot D_t(y) \\;+\\; \\big(C + K\\big)\\cdot D_n(y).\n$$\nEquivalently, define the function\n$$\nf(y) = \\sum_{t=1}^{n-1} \\frac{C}{\\left(1 + \\frac{y}{m}\\right)^t} + \\frac{C + K}{\\left(1 + \\frac{y}{m}\\right)^n} - P,\n$$\nand find $y$ such that $f(y) = 0$.\n\nAlgorithmic requirement:\n- Implement the bisection method to solve $f(y) = 0$ on a bracket $[y_{\\min}, y_{\\max}]$ with $y_{\\min} > -m$ so that $1 + \\frac{y}{m} > 0$. Ensure $f(y_{\\min}) \\cdot f(y_{\\max}) \\le 0$ before iterating.\n- Use a stopping rule that terminates when either the bracket width is at most $\\varepsilon$ in $y$ or $|f(y)| \\le \\varepsilon$ for a given tolerance $\\varepsilon$.\n- Use a maximum number of iterations to prevent infinite loops.\n\nAngle units are not applicable. No physical units are involved. All rates must be expressed as decimals, not with a percentage sign.\n\nTest suite:\nCompute the YTC for the following three cases. Each case is independently parameterized by $(M, \\kappa, m, n, K, P)$:\n\n- Case A (single-period boundary check):\n  - $M = 1000$, $\\kappa = 0.06$, $m = 2$, $n = 1$, $K = 1010$, $P = 1000$.\n- Case B (happy path at par):\n  - $M = 1000$, $\\kappa = 0.06$, $m = 2$, $n = 10$, $K = 1000$, $P = 1000$.\n- Case C (zero-coupon edge case):\n  - $M = 1000$, $\\kappa = 0.00$, $m = 2$, $n = 4$, $K = 1000$, $P = 822.7024747919322$.\n\nNumerical settings:\n- Use $y_{\\min} = -0.90$, $y_{\\max} = 1.00$, tolerance $\\varepsilon = 10^{-12}$, and a maximum of $100000$ iterations.\n\nRequired final output format:\n- Your program should produce a single line of output containing the three computed YTC values, rounded to $8$ decimal places, as a comma-separated list enclosed in square brackets, for example, $[0.01234567,0.07654321,0.00000000]$.", "solution": "The problem presented is a well-defined exercise in computational finance, specifically concerning the numerical determination of a bond's yield-to-call. The task is to find the root of a non-linear equation derived from the principle of discounted cash flows. This is a standard application of numerical methods. The problem is valid as it is scientifically grounded in established financial theory, mathematically consistent, complete in its specification, and objective.\n\nThe core of the problem is to solve the equation $f(y) = 0$ for the annual nominal yield-to-call, $y$. The function $f(y)$ represents the difference between the present value ($PV$) of the bond's future cash flows and its observed market price, $P$. The cash flows consist of $n$ coupon payments and a final payment of the call price, $K$.\n\nThe pricing equation is given as:\n$$\nP = \\sum_{t=1}^{n-1} \\frac{C}{\\left(1 + \\frac{y}{m}\\right)^t} + \\frac{C + K}{\\left(1 + \\frac{y}{m}\\right)^n}\n$$\nwhere $C$ is the periodic coupon payment, $C = \\frac{\\kappa}{m} M$, $m$ is the number of coupon payments per year, and $n$ is the number of coupon periods until the call date. The function to solve is thus $f(y) = PV(y) - P$, where $PV(y)$ is the right-hand side of the equation.\n\nFor computational efficiency, we can recognize that the sum of discounted coupons is a geometric series. A more standard and equivalent representation of the present value is:\n$$\nPV(y) = \\sum_{t=1}^{n} \\frac{C}{\\left(1 + \\frac{y}{m}\\right)^t} + \\frac{K}{\\left(1 + \\frac{y}{m}\\right)^n}\n$$\nThe summation term is the present value of an ordinary annuity, which has a closed-form expression. Letting $r = y/m$ be the periodic discount rate, the sum is $\\frac{C}{r}\\left(1 - (1+r)^{-n}\\right)$. Thus, the function $f(y)$ can be written as:\n$$\nf(y) = \\frac{C}{y/m}\\left(1 - \\left(1+\\frac{y}{m}\\right)^{-n}\\right) + K\\left(1+\\frac{y}{m}\\right)^{-n} - P\n$$\nThis formula is valid for $y \\neq 0$. In the special case where $y = 0$, we must evaluate the limit of the first term. Using L'HÃ´pital's rule on the term $\\frac{1-(1+r)^{-n}}{r}$ as $r \\to 0$, we find the limit is $n$. Therefore, for $y = 0$, the function is:\n$$\nf(0) = C \\cdot n + K - P\n$$\nThe derivative of the present value with respect to $y$ is:\n$$\n\\frac{d(PV)}{dy} = \\sum_{t=1}^{n-1} C \\cdot \\frac{-t}{m}\\left(1+\\frac{y}{m}\\right)^{-t-1} + (C+K) \\cdot \\frac{-n}{m}\\left(1+\\frac{y}{m}\\right)^{-n-1}\n$$\nSince all cash flows ($C, K$) are non-negative, and parameters $t, n, m$ are positive, this derivative is strictly negative for any $y$ in the valid domain ($y > -m$). This proves that $f(y)$ is a strictly monotonically decreasing function of $y$. This property is crucial, as it guarantees that if a root exists within a given interval, it is unique. The bisection method is therefore an appropriate and robust choice for finding this root.\n\nThe bisection method is an iterative root-finding algorithm that operates on an interval $[a, b]$ where the function $f$ has opposite signs at the endpoints, i.e., $f(a) \\cdot f(b) \\le 0$. The Intermediate Value Theorem guarantees at least one root exists in $[a, b]$. The algorithm proceeds as follows:\n\n$1$. Initialize the search interval with $[y_{\\min}, y_{\\max}]$. Verify that $f(y_{\\min}) \\cdot f(y_{\\max}) \\le 0$. For this problem, the interval is given as $[-0.90, 1.00]$.\n\n$2$. Begin iteration, up to a maximum of $100000$ iterations.\n\n$3$. In each iteration, calculate the midpoint of the interval, $y_{mid} = \\frac{y_{\\min} + y_{\\max}}{2}$.\n\n$4$. Evaluate the function at the midpoint, $f(y_{mid})$.\n\n$5$. Check the stopping criteria:\n    - If the interval width $(y_{\\max} - y_{\\min})$ is less than or equal to the tolerance $\\varepsilon = 10^{-12}$.\n    - Or if the absolute value of the function at the midpoint, $|f(y_{mid})|$, is less than or equal to $\\varepsilon = 10^{-12}$.\n    - If either condition is met, the algorithm terminates and $y_{mid}$ is the approximate root.\n\n$6$. If stopping criteria are not met, update the interval. Since $f(y)$ is monotonic decreasing:\n    - If $f(y_{mid}) > 0$, the root must lie in the upper half of the interval. We set $y_{\\min} = y_{mid}$.\n    - If $f(y_{mid}) < 0$, the root must lie in the lower half. We set $y_{\\max} = y_{mid}$.\n    - If $f(y_{mid}) = 0$, the exact root is found, and we can terminate.\n\n$7$. Repeat from step $3$.\n\nThis algorithm will be implemented and applied to each of the three test cases provided. For each case, the parameters $(M, \\kappa, m, n, K, P)$ define a specific instance of the function $f(y)$. The implementation will use the numerically stable and efficient closed-form expression for the present value, with special handling for the $y=0$ case.\n\nThe parameters for the three cases are:\n- Case A: $(M, \\kappa, m, n, K, P) = (1000, 0.06, 2, 1, 1010, 1000)$.\n- Case B: $(M, \\kappa, m, n, K, P) = (1000, 0.06, 2, 10, 1000, 1000)$.\n- Case C: $(M, \\kappa, m, n, K, P) = (1000, 0.00, 2, 4, 1000, 822.7024747919322)$.\n\nThe numerical settings are $y_{\\min} = -0.90$, $y_{\\max} = 1.00$, $\\varepsilon = 10^{-12}$, and maximum iterations = $100000$. The final computed yields for each case will be rounded to $8$ decimal places as required.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the Yield-to-Call (YTC) for callable bonds using the bisection method.\n    \"\"\"\n\n    def bisection(f, a, b, tol=1e-12, max_iter=100000):\n        \"\"\"\n        Finds the root of a function f within the interval [a, b] using the bisection method.\n\n        Args:\n            f (callable): The function for which to find a root.\n            a (float): The lower bound of the interval.\n            b (float): The upper bound of the interval.\n            tol (float): The tolerance for stopping criteria.\n            max_iter (int): The maximum number of iterations.\n\n        Returns:\n            float: The approximate root, or None if the method fails.\n        \"\"\"\n        fa = f(a)\n        fb = f(b)\n\n        if fa * fb > 0:\n            # This check is important, but for the given monotonic function and\n            # wide interval, it is expected to hold for all test cases.\n            return None\n\n        for _ in range(max_iter):\n            c = (a + b) / 2\n            fc = f(c)\n\n            # Stopping criteria\n            if (b - a) <= tol or abs(fc) <= tol:\n                return c\n\n            # Update interval\n            # Since the function is monotonically decreasing, we can use a simpler check\n            # if fa * fc < 0:\n            if fc > 0: # Root is in the upper half\n                a = c\n                # fa = fc # Not needed because we only compare fc to 0\n            else: # Root is in the lower half (or fc is 0)\n                b = c\n                # fb = fc\n        \n        return (a + b) / 2 # Return the best estimate after max_iter\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: (M, kappa, m, n, K, P)\n        (1000, 0.06, 2, 1, 1010, 1000),\n        # Case B:\n        (1000, 0.06, 2, 10, 1000, 1000),\n        # Case C:\n        (1000, 0.00, 2, 4, 1000, 822.7024747919322),\n    ]\n\n    # Numerical settings\n    y_min = -0.90\n    y_max = 1.00\n    tolerance = 1e-12\n    max_iterations = 100000\n\n    results = []\n    for case in test_cases:\n        M, kappa, m, n, K, P = case\n        C = (kappa / m) * M\n\n        def f_ytc(y):\n            \"\"\"\n            The function f(y) = PV(y) - P whose root we are seeking.\n            \"\"\"\n            if m + y <= 0:  # Avoid division by zero or negative base in power for 1+y/m\n                return np.inf # Return a large number to guide the search away\n\n            if abs(y) < 1e-12: # Handle the case y -> 0\n                # Using L'Hopital's rule, the PV limit is C*n + K\n                pv = C * n + K\n            else:\n                r = y / m\n                # Use the closed-form expression for annuity present value\n                pv_coupons = (C / r) * (1 - (1 + r)**-n)\n                pv_principal = K * (1 + r)**-n\n                pv = pv_coupons + pv_principal\n            \n            return pv - P\n\n        # Solve for YTC using the bisection method\n        ytc = bisection(f_ytc, y_min, y_max, tol=tolerance, max_iter=max_iterations)\n        results.append(ytc)\n\n    # Format the results as specified\n    formatted_results = [f\"{res:.8f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"}, {"introduction": "A powerful algorithm's effectiveness depends on its underlying assumptions being met. The bisection method's guarantee of finding a root relies on the Intermediate Value Theorem, which holds only for continuous functions. But what happens if this fundamental assumption is violated? Real-world implementations must be robust enough to handle such edge cases gracefully.\n\nThis final practice challenges you to think critically about the limitations of the bisection method [@problem_id:2437948]. By considering a scenario where the search interval for a bond's yield contains a singularityâ€”a point where the pricing function is discontinuousâ€”you will explore why the algorithm fails. This exercise emphasizes the crucial importance of domain awareness and building robust code that anticipates and correctly handles scenarios where an algorithm's mathematical preconditions are not satisfied.", "id": "2437948", "problem": "A fixed-income analyst computes the yield to maturity (YTM) for a conventional coupon bond by solving for the interest rate $r$ that zeros the mispricing function\n$$f(r) \\equiv \\sum_{t=1}^{T} \\frac{C_t}{(1+r)^t} - P_{\\text{mkt}},$$\nwhere $T \\in \\mathbb{N}$ is the maturity in periods, cash flows satisfy $C_t \\ge 0$ with $C_T > 0$, and $P_{\\text{mkt}} > 0$ is the observed market price. The analyst plans to use the bisection method on an initial interval $[a,b]$. Consider the case where the initial interval is poorly chosen and contains the point $r=-1$, i.e., $a < -1 < b$.\n\nWhich statement best describes what will happen and how the algorithm should be made robust in this setting?\n\nA. The bisection method will still converge as long as $f(a)f(b) < 0$, because a sign change is sufficient even if $f$ is undefined at $r=-1$. No special handling is needed.\n\nB. The bisection method can fail or return meaningless results because $f(r)$ is undefined at $r=-1$ and not continuous on $[a,b]$; a sign change across $r=-1$ does not imply a root. Robustness requires enforcing the domain $r>-1$ (for example, by reparameterizing with $x=\\log(1+r)$ so $r=e^x-1$ and bracketing in $x$), and verifying a valid bracket with $f(a)f(b)<0$ entirely within the feasible domain.\n\nC. The bisection method will only be affected by numerical overflow; using a smaller tolerance for the midpoint and ignoring any non-numeric evaluations is sufficient to preserve convergence even if $[a,b]$ contains $-1$.\n\nD. Because bond prices are monotone in $r$, any initial $[a,b]$ will eventually lead bisection to the YTM; floating-point arithmetic will automatically skip over $r=-1$ if encountered, so no change is necessary.", "solution": "The problem statement is subjected to validation.\n\n**Step 1: Extract Givens**\n\nThe problem defines a mispricing function for a bond's yield to maturity (YTM), $r$:\n$$f(r) \\equiv \\sum_{t=1}^{T} \\frac{C_t}{(1+r)^t} - P_{\\text{mkt}}$$\nThe parameters and conditions are:\n- Maturity: $T \\in \\mathbb{N}$\n- Cash flows: $C_t \\ge 0$ for $t=1, \\dots, T-1$, and $C_T > 0$\n- Market price: $P_{\\text{mkt}} > 0$\n- Numerical method: Bisection method\n- Initial interval for the search: $[a,b]$\n- Specific scenario under consideration: The interval contains $r=-1$, such that $a < -1 < b$.\n\nThe question asks to describe the outcome for the bisection algorithm and how to make the implementation robust.\n\n**Step 2: Validate Using Extracted Givens**\n\nThe problem is scientifically grounded in the fields of fixed-income analysis and numerical methods. The formula for the present value of a bond is standard. The use of a root-finding algorithm like the bisection method to find the YTM is a common application in computational finance.\n\nThe critical aspect of the problem is the analysis of the function $f(r)$ and the bisection method's requirements. The bisection method guarantees convergence to a root under two conditions:\n1. The function $f$ must be continuous on the closed interval $[a,b]$.\n2. The function values at the endpoints must have opposite signs, i.e., $f(a)f(b) < 0$.\n\nThe problem statement directs us to examine the case where the interval is $[a,b]$ with $a < -1 < b$. Let us inspect the function $f(r)$ at the point $r=-1$. The denominator of each term in the summation is $(1+r)^t$. When $r=-1$, this denominator becomes $(1-1)^t = 0^t = 0$ for any $t \\ge 1$. Since it is given that $C_T > 0$ (and other $C_t \\ge 0$), at least one term in the summation attempts a division by zero. Therefore, the function $f(r)$ has a vertical asymptote at $r=-1$ and is discontinuous on any interval containing this point.\n\nThe problem is thus well-posed, complete, and devoid of contradictions. It sets up a valid, albeit problematic, scenario to test the understanding of the theoretical underpinnings of a numerical algorithm. The problem is not ill-posed, ambiguous, or trivial.\n\n**Step 3: Verdict and Action**\n\nThe problem statement is **valid**. It presents a clear and analyzable scenario concerning the limitations of the bisection method. I will proceed to derive the solution and evaluate the options.\n\n**Derivation of Solution**\n\nThe fundamental principle governing the bisection method is the Intermediate Value Theorem (IVT). The IVT states that for a function $f$ that is continuous on a closed interval $[a,b]$, if $f(a)$ and $f(b)$ have opposite signs, there must exist at least one point $c \\in (a,b)$ such that $f(c)=0$.\n\nIn the given scenario, the interval is $[a,b]$ where $a < -1 < b$. The function $f(r)$ is discontinuous at $r=-1$. Consequently, the primary hypothesis of the IVT is violated. Therefore, even if $f(a)f(b) < 0$, we cannot conclude that a root exists in $(a,b)$. The sign change can occur across the singularity at $r=-1$. For example, as $r \\to -1^+$, the sum $\\sum_{t=1}^{T} \\frac{C_t}{(1+r)^t}$ tends to $+\\infty$ (since $C_t \\ge 0$ with at least one $C_t > 0$), so $f(r) \\to +\\infty$. As $r \\to -1^-$, the signs of the terms $(1+r)^t$ will alternate depending on whether $t$ is even or odd, but the magnitude will still diverge. This discontinuity means a sign change is not indicative of a root.\n\nThe bisection algorithm proceeds by calculating the midpoint $c_k = (a_k+b_k)/2$ and evaluating $f(c_k)$. If the initial interval $[a,b]$ contains $-1$, the sequence of midpoints may eventually attempt to evaluate $f(r)$ at or very close to $r=-1$. This will result in a fatal error (division by zero) or a numerical overflow (a very large floating-point number), causing the algorithm to fail. The logic of narrowing the bracket based on the sign of $f(c_k)$ collapses because the evaluation itself is compromised.\n\nTo create a robust algorithm, one must respect the domain of the function $f(r)$. From a financial perspective, the discount factor $1+r$ must be positive, which implies $r > -1$. A yield of $-100\\%$ or lower is economically meaningless, as it implies an infinite or negative present value for positive future cash flows. The search for YTM must be restricted to the domain $r \\in (-1, \\infty)$.\n\nA robust procedure must therefore:\n1.  Ensure the initial search interval $[a,b]$ is chosen such that $a > -1$.\n2.  Verify that a valid bracket is found within this domain, i.e., $f(a)f(b) < 0$ for $-1 < a < b$.\n\nA more sophisticated technique to enforce the domain constraint is to reparameterize the problem. Let $x = \\log(1+r)$. This maps the domain $r \\in (-1, \\infty)$ to the entire real line $x \\in (-\\infty, \\infty)$. The inverse transformation is $r = e^x - 1$. The function becomes:\n$$g(x) = f(e^x-1) = \\sum_{t=1}^{T} \\frac{C_t}{(1+(e^x-1))^t} - P_{\\text{mkt}} = \\sum_{t=1}^{T} C_t e^{-xt} - P_{\\text{mkt}}$$\nThis function $g(x)$ is continuous and well-behaved for all $x \\in \\mathbb{R}$. The bisection method can be applied to $g(x)$ on any real interval $[x_a, x_b]$ without risk of singularities. Once a root $x^*$ is found for $g(x)$, the corresponding yield is recovered as $r^* = e^{x^*} - 1$.\n\n**Option-by-Option Analysis**\n\nA. The bisection method will still converge as long as $f(a)f(b) < 0$, because a sign change is sufficient even if $f$ is undefined at $r=-1$. No special handling is needed.\nThis statement is fundamentally incorrect. The convergence guarantee of the bisection method depends critically on the continuity of the function, which is violated here. A sign change across a singularity does not imply a root, and the algorithm is susceptible to failure when evaluating the function near the singularity.\n**Verdict: Incorrect**\n\nB. The bisection method can fail or return meaningless results because $f(r)$ is undefined at $r=-1$ and not continuous on $[a,b]$; a sign change across $r=-1$ does not imply a root. Robustness requires enforcing the domain $r>-1$ (for example, by reparameterizing with $x=\\log(1+r)$ so $r=e^x-1$ and bracketing in $x$), and verifying a valid bracket with $f(a)f(b)<0$ entirely within the feasible domain.\nThis statement correctly identifies the mathematical failure: lack of continuity invalidates the premise of the bisection method. It correctly diagnoses that a sign change is not sufficient. It correctly identifies the valid domain for the yield, $r > -1$. It proposes a valid and standard method for ensuring robustness through reparameterization, and correctly states the need to find a proper bracket within the valid domain. This analysis is complete and accurate.\n**Verdict: Correct**\n\nC. The bisection method will only be affected by numerical overflow; using a smaller tolerance for the midpoint and ignoring any non-numeric evaluations is sufficient to preserve convergence even if $[a,b]$ contains $-1$.\nThis is incorrect. The issue is a fundamental mathematical discontinuity, not just a numerical precision problem. \"Ignoring a non-numeric evaluation\" is not a coherent strategy; if the function cannot be evaluated at the midpoint, the algorithm cannot decide how to proceed. Changing the tolerance does not fix the singularity.\n**Verdict: Incorrect**\n\nD. Because bond prices are monotone in $r$, any initial $[a,b]$ will eventually lead bisection to the YTM; floating-point arithmetic will automatically skip over $r=-1$ if encountered, so no change is necessary.\nThis is incorrect. While the bond price function is monotone for $r > -1$, this property does not allow the bisection method to overcome a singularity within its search interval. The assertion that floating-point arithmetic will \"skip over\" a point of failure is nonsensical. An operation like division by zero will cause an exception or return an IEEE $754$ special value like `Inf` or `NaN`, which will break the algorithm's control flow.\n**Verdict: Incorrect**", "answer": "$$\\boxed{B}$$"}]}