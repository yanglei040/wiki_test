{"hands_on_practices": [{"introduction": "The binomial tree model is a cornerstone of computational finance, offering an intuitive yet powerful method for pricing options with early exercise features. This first practice moves beyond the textbook case by incorporating a time-dependent structure to model real-world complexities. By valuing an American option on a commodity with seasonal price effects and storage costs, you will implement a binomial lattice where the risk-neutral probabilities change at each time step, providing a robust hands-on application of dynamic programming. [@problem_id:2420641]", "id": "2420641", "problem": "You are asked to programmatically compute the value of an American option written on a commodity whose spot price process is affected by seasonality and storage costs. Work under the risk-neutral measure. The commodity spot price process $\\{S_t\\}_{t \\in [0,T]}$ has instantaneous dynamics\n$$\n\\frac{dS_t}{S_t} = \\left(r - q(t)\\right) \\, dt + \\sigma \\, dW_t,\n$$\nwhere $r$ is the continuously compounded risk-free interest rate, $\\sigma$ is the volatility, and $q(t)$ is a time-dependent effective yield. The effective yield combines a deterministic seasonal component and a storage cost treated as a negative continuous dividend yield:\n$$\nq(t) = q_0 + A \\cos\\left(2\\pi t + \\phi\\right) - s.\n$$\nHere $q_0$ is a baseline convenience yield level, $A$ is the seasonal amplitude, $\\phi$ is the phase (in radians), and $s$ is the storage cost rate. All rates are expressed per year as decimals, time $t$ is measured in years, and $T$ is in years.\n\nFor numerical valuation, use a discrete-time approximation with a Cox-Ross-Rubinstein recombining binomial model over $N$ equal steps of length $\\Delta t = T/N$. The up and down multipliers are\n$$\nu = e^{\\sigma \\sqrt{\\Delta t}}, \\quad d = \\frac{1}{u},\n$$\nand at step $i \\in \\{0,1,\\dots,N-1\\}$ corresponding to time $t_i = i \\Delta t$, the one-step risk-neutral probability is\n$$\np_i = \\frac{e^{(r - q(t_i)) \\Delta t} - d}{u - d}.\n$$\nThe one-step discount factor is $D = e^{-r \\Delta t}$. The American option value at time $0$ is the supremum over all stopping times $\\tau$ taking values on the grid $\\{0, \\Delta t, 2 \\Delta t, \\dots, T\\}$ of the discounted expected payoff under the above model. For a call, the payoff function is $\\Pi(S) = \\max(S - K, 0)$, and for a put, it is $\\Pi(S) = \\max(K - S, 0)$.\n\nImplement a program that computes the American option value at time $0$ for each of the following test cases. All inputs use the units specified above, with $\\phi$ given in radians. The output for each case must be a single real number (a float). Each result must be rounded to six decimal places.\n\nTest Suite:\n- Case 1 (seasonal effective yield oscillating around negative due to storage, baseline one-year maturity):\n  - $S_0 = 100.0$, $K = 100.0$, $r = 0.05$, $\\sigma = 0.2$, $T = 1.0$, $N = 400$, option type: put.\n  - $q_0 = 0.0$, $A = 0.03$, $\\phi = 0.0$, $s = 0.02$.\n- Case 2 (very short maturity boundary, one-step tree):\n  - $S_0 = 80.0$, $K = 100.0$, $r = 0.01$, $\\sigma = 0.25$, $T = 1/365$, $N = 1$, option type: put.\n  - $q_0 = 0.0$, $A = 0.02$, $\\phi = \\pi/2$, $s = 0.01$.\n- Case 3 (American call with negative effective yield due to storage and zero risk-free rate):\n  - $S_0 = 50.0$, $K = 40.0$, $r = 0.0$, $\\sigma = 0.3$, $T = 0.5$, $N = 300$, option type: call.\n  - $q_0 = 0.0$, $A = 0.0$, $\\phi = 0.0$, $s = 0.05$.\n- Case 4 (positive effective yield due to strong convenience yield, one-year maturity):\n  - $S_0 = 100.0$, $K = 90.0$, $r = 0.02$, $\\sigma = 0.25$, $T = 1.0$, $N = 400$, option type: put.\n  - $q_0 = 0.07$, $A = 0.02$, $\\phi = \\pi$, $s = 0.02$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each price rounded to six decimal places and printed as a decimal number (for example, $[12.345678,9.876543,0.123456,4.000000]$). No other text should be printed.", "solution": "The problem is subjected to validation before a solution is attempted.\n\n### Step 1: Extract Givens\n\nThe spot price process $\\{S_t\\}_{t \\in [0,T]}$ follows the stochastic differential equation:\n$$\n\\frac{dS_t}{S_t} = \\left(r - q(t)\\right) \\, dt + \\sigma \\, dW_t\n$$\nwhere $r$ is the risk-free rate, $\\sigma$ is volatility, and $q(t)$ is the time-dependent effective yield.\n\nThe effective yield is defined as:\n$$\nq(t) = q_0 + A \\cos\\left(2\\pi t + \\phi\\right) - s\n$$\nwhere $q_0$ is the baseline convenience yield, $A$ is seasonal amplitude, $\\phi$ is phase, and $s$ is storage cost rate.\n\nThe numerical method is a Cox-Ross-Rubinstein (CRR) binomial model with $N$ steps over a period $T$.\n- Time step: $\\Delta t = T/N$.\n- Up/down multipliers: $u = e^{\\sigma \\sqrt{\\Delta t}}$, $d = 1/u$.\n- One-step risk-neutral probability at time $t_i = i \\Delta t$:\n$$\np_i = \\frac{e^{(r - q(t_i)) \\Delta t} - d}{u - d}\n$$\n- One-step discount factor: $D = e^{-r \\Delta t}$.\n- Payoff functions: $\\Pi(S) = \\max(S - K, 0)$ for a call, and $\\Pi(S) = \\max(K - S, 0)$ for a put.\n\nTest Cases:\n1.  **Case 1**: $S_0 = 100.0$, $K = 100.0$, $r = 0.05$, $\\sigma = 0.2$, $T = 1.0$, $N = 400$, `option type: put`. Parameters for $q(t)$: $q_0 = 0.0$, $A = 0.03$, $\\phi = 0.0$, $s = 0.02$.\n2.  **Case 2**: $S_0 = 80.0$, $K = 100.0$, $r = 0.01$, $\\sigma = 0.25$, $T = 1/365$, $N = 1$, `option type: put`. Parameters for $q(t)$: $q_0 = 0.0$, $A = 0.02$, $\\phi = \\pi/2$, $s = 0.01$.\n3.  **Case 3**: $S_0 = 50.0$, $K = 40.0$, $r = 0.0$, $\\sigma = 0.3$, $T = 0.5$, $N = 300$, `option type: call`. Parameters for $q(t)$: $q_0 = 0.0$, $A = 0.0$, $\\phi = 0.0$, $s = 0.05$.\n4.  **Case 4**: $S_0 = 100.0$, $K = 90.0$, $r = 0.02$, $\\sigma = 0.25$, $T = 1.0$, $N = 400$, `option type: put`. Parameters for $q(t)$: $q_0 = 0.07$, $A = 0.02$, $\\phi = \\pi$, $s = 0.02$.\n\n### Step 2: Validate Using Extracted Givens\n\nThe problem is evaluated against the validation criteria.\n- **Scientifically Grounded**: The model provided is a variant of Geometric Brownian Motion with a time-dependent drift, which is a standard framework for modeling commodity prices in quantitative finance. The form of the effective yield $q(t)$ incorporating seasonality and storage costs is also a conventional approach. The numerical valuation method, a binomial tree, is a cornerstone of computational finance for option pricing. All equations and concepts are based on established financial engineering principles.\n- **Well-Posed**: The problem is well-posed. The inputs for each test case are complete and sufficient to compute a unique numerical result using the specified algorithm. The CRR model with a time-dependent dividend yield is known to provide a converging approximation to the continuous-time solution. The parameters are within reasonable bounds, ensuring that the risk-neutral probabilities $p_i$ satisfy the no-arbitrage condition $0 < p_i < 1$.\n- **Objective**: The problem is stated in precise, objective mathematical and financial language. It provides concrete test cases and requires a numerical output, leaving no room for subjective interpretation.\n\nThe problem does not exhibit any flaws such as scientific unsoundness, incompleteness, contradiction, or ambiguity. It is a standard and well-defined problem in computational economics and finance.\n\n### Step 3: Verdict and Action\n\nThe problem statement is **valid**. A solution will be provided.\n\nThe valuation of an American option on a commodity with the specified dynamics is performed using a binomial lattice. The fundamental principle is risk-neutral valuation combined with dynamic programming to account for the early exercise feature. The American option price at any point in time is the maximum of its intrinsic value (from immediate exercise) and its continuation value (from holding the option).\n\nThe algorithm proceeds via backward induction on a recombining binomial tree.\n\n1.  **Discretization of the Model**: The time to maturity $T$ is divided into $N$ equal intervals of length $\\Delta t = T/N$. The state space of the commodity price $S$ is discretized into a binomial lattice. The price at node $(i, j)$ at time $t_i = i\\Delta t$, having experienced $j$ up-moves and $i-j$ down-moves, is given by $S_{i,j} = S_0 u^j d^{i-j}$. The up and down multipliers, $u$ and $d$, are determined by the volatility $\\sigma$ and time step $\\Delta t$ as per the CRR model:\n    $$\n    u = e^{\\sigma \\sqrt{\\Delta t}}, \\quad d = e^{-\\sigma \\sqrt{\\Delta t}} = \\frac{1}{u}\n    $$\n    The one-step discount factor is constant: $D = e^{-r \\Delta t}$.\n\n2.  **Time-Dependent Risk-Neutral Probability**: The risk-neutral probability of an up-move is not constant but depends on the time step $i$ due to the time-dependent effective yield $q(t_i)$. For each time step $t_i = i \\Delta t$, where $i \\in \\{0, 1, \\dots, N-1\\}$, the effective yield is:\n    $$\n    q(t_i) = q_0 + A \\cos(2\\pi t_i + \\phi) - s\n    $$\n    This yields a step-dependent risk-neutral probability $p_i$ for the transition from $t_i$ to $t_{i+1}$:\n    $$\n    p_i = \\frac{e^{(r - q(t_i)) \\Delta t} - d}{u - d}\n    $$\n\n3.  **Backward Induction Algorithm**:\n    - **Initialization at Maturity (Time $T$)**: At the final time step $N$, the option value at each of the $N+1$ nodes is simply its intrinsic value, given by the payoff function. Let $\\omega = 1$ for a call and $\\omega = -1$ for a put. The value $V_{N,j}$ at node $(N,j)$ is:\n      $$\n      V_{N,j} = \\max(\\omega \\cdot (S_{N,j} - K), 0) \\quad \\text{for } j = 0, 1, \\dots, N\n      $$\n      These values are stored in a one-dimensional array of size $N+1$.\n\n    - **Iteration**: The algorithm iterates backward from time step $i = N-1$ down to $0$. At each step $i$, it computes the option values $V_{i,j}$ for all nodes $j \\in \\{0, 1, \\dots, i\\}$.\n      - For each node $(i,j)$, the continuation value, $C_{i,j}$, is the discounted expected value of the option in the next time step, calculated using the risk-neutral probability $p_i$:\n        $$\n        C_{i,j} = D \\cdot [p_i V_{i+1, j+1} + (1-p_i) V_{i+1, j}]\n        $$\n      - The intrinsic value, $I_{i,j}$, is the value if exercised at node $(i,j)$:\n        $$\n        I_{i,j} = \\max(\\omega \\cdot (S_{i,j} - K), 0)\n        $$\n      - The American option value at this node is the maximum of these two values, reflecting the optimal decision:\n        $$\n        V_{i,j} = \\max(I_{i,j}, C_{i,j})\n        $$\n      In implementation, a single array representing the option values at step $i+1$ can be updated in-place to store the values for step $i$.\n\n    - **Final Value**: The process terminates at step $i=0$. The single value $V_{0,0}$ is the price of the American option at time $t=0$.\n\nThis procedure is implemented for each test case to compute the required option prices.", "answer": "```python\nimport numpy as np\n\ndef calculate_american_option(S0, K, r, sigma, T, N, option_type, q_params):\n    \"\"\"\n    Computes the value of an American option on a commodity with seasonality.\n\n    Args:\n        S0 (float): Initial spot price.\n        K (float): Strike price.\n        r (float): Risk-free interest rate.\n        sigma (float): Volatility.\n        T (float): Time to maturity in years.\n        N (int): Number of steps in the binomial tree.\n        option_type (str): 'call' or 'put'.\n        q_params (dict): Parameters for the effective yield q(t).\n                         Keys: 'q0', 'A', 'phi', 's'.\n\n    Returns:\n        float: The price of the American option at time 0.\n    \"\"\"\n    # Unpack parameters for q(t)\n    q0 = q_params['q0']\n    A = q_params['A']\n    phi = q_params['phi']\n    s = q_params['s']\n\n    # Step 1: Discretization and constant parameters\n    dt = T / N\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1.0 / u\n    discount_factor = np.exp(-r * dt)\n\n    # Step 2: Initialize option values at maturity (time T)\n    # Omega = 1 for call, -1 for put\n    omega = 1.0 if option_type == 'call' else -1.0\n    \n    # Create a vector for option values. This will be updated at each step.\n    # It stores values at step i+1, and is used to compute values at step i.\n    V = np.zeros(N + 1)\n    \n    # Asset prices at maturity\n    S_T = np.array([(S0 * u**j * d**(N - j)) for j in range(N + 1)])\n    \n    # Option payoff at maturity\n    V[:] = np.maximum(omega * (S_T - K), 0)\n\n    # Step 3: Backward induction\n    for i in range(N - 1, -1, -1):\n        # Calculate time-dependent risk-neutral probability for this step\n        ti = i * dt\n        q_ti = q0 + A * np.cos(2 * np.pi * ti + phi) - s\n        \n        # Risk-neutral probability for transition from t_i to t_{i+1}\n        p_i = (np.exp((r - q_ti) * dt) - d) / (u - d)\n        \n        # Stability check, should hold for reasonable parameters\n        if not (0 < p_i < 1):\n             # This indicates an arbitrage opportunity or unstable parameters.\n             # The problem parameters are well-behaved, so this is a safeguard.\n             # For some extreme parameters, one might need to adjust u,d,p.\n             # but here it is not necessary.\n             pass\n\n        # Calculate option values at time step i\n        for j in range(i + 1):\n            # Continuation value (if not exercised)\n            continuation_value = discount_factor * (p_i * V[j+1] + (1 - p_i) * V[j])\n            \n            # Stock price at this node (i, j)\n            S_ij = S0 * u**j * d**(i - j)\n            \n            # Intrinsic value (if exercised now)\n            intrinsic_value = np.maximum(omega * (S_ij - K), 0)\n            \n            # American option value is the max of exercising or holding\n            V[j] = np.maximum(intrinsic_value, continuation_value)\n            \n    # The final result is the option value at the root of the tree (t=0)\n    return round(V[0], 6)\n\ndef solve():\n    \"\"\"\n    Solves the problem for the given test suite.\n    \"\"\"\n    test_cases = [\n        # Case 1\n        {'S0': 100.0, 'K': 100.0, 'r': 0.05, 'sigma': 0.2, 'T': 1.0, 'N': 400, 'option_type': 'put',\n         'q_params': {'q0': 0.0, 'A': 0.03, 'phi': 0.0, 's': 0.02}},\n        # Case 2\n        {'S0': 80.0, 'K': 100.0, 'r': 0.01, 'sigma': 0.25, 'T': 1/365, 'N': 1, 'option_type': 'put',\n         'q_params': {'q0': 0.0, 'A': 0.02, 'phi': np.pi/2, 's': 0.01}},\n        # Case 3\n        {'S0': 50.0, 'K': 40.0, 'r': 0.0, 'sigma': 0.3, 'T': 0.5, 'N': 300, 'option_type': 'call',\n         'q_params': {'q0': 0.0, 'A': 0.0, 'phi': 0.0, 's': 0.05}},\n        # Case 4\n        {'S0': 100.0, 'K': 90.0, 'r': 0.02, 'sigma': 0.25, 'T': 1.0, 'N': 400, 'option_type': 'put',\n         'q_params': {'q0': 0.07, 'A': 0.02, 'phi': np.pi, 's': 0.02}},\n    ]\n\n    results = []\n    for case in test_cases:\n        price = calculate_american_option(\n            S0=case['S0'],\n            K=case['K'],\n            r=case['r'],\n            sigma=case['sigma'],\n            T=case['T'],\n            N=case['N'],\n            option_type=case['option_type'],\n            q_params=case['q_params']\n        )\n        results.append(price)\n    \n    # Format the final output according to specification\n    print(f\"[{','.join(map(lambda x: f'{x:.6f}', results))}]\")\n\nsolve()\n```"}, {"introduction": "While discrete-time models like binomial trees are intuitive, many financial models are formulated in continuous time using partial differential equations (PDEs). For American options, this leads to a \"variational inequality\" that combines the Black-Scholes-Merton PDE with an early exercise constraint. This practice challenges you to implement a finite difference method to solve this inequality, bridging the gap between discrete and continuous models and introducing crucial numerical analysis concepts like grid construction, boundary conditions, and stability. [@problem_id:2420683]", "id": "2420683", "problem": "Consider a non-dividend-paying underlying asset with spot price $S(t)$ following a geometric Brownian motion under the risk-neutral measure, and an American put option with strike $K$ and maturity $T$. Starting from the fundamental no-arbitrage principle and the existence of a self-financing replicating portfolio, derive the variational inequality that characterizes the arbitrage-free value function $V(S,t)$ of an American option. Your derivation must explicitly state the differential operator for the diffusion and drift terms, the time evolution, and the early-exercise (obstacle) constraint, as well as the complementary slackness structure that links them. Then, transform the spatial variable to log-price $x = \\ln S$ and express the inequality in terms of a function $u(x,t) = V(e^{x},t)$, detailing the new drift and diffusion coefficients in the transformed operator.\n\nNext, design an explicit finite difference method in the log-price variable $x$ to compute the American put price numerically by evolving backward from maturity. Use central differences in space and forward Euler in time (backward in the sense of calendar time, starting from $t=T$ and stepping to $t=0$), and enforce the early exercise feature at each time step by projecting onto the obstacle. Specify and implement no-flux-consistent Dirichlet boundary conditions in $x$ that are financially meaningful for an American put on a non-dividend-paying underlying.\n\nFor stability analysis, consider the explicit scheme on a uniform log-price grid with spatial step $\\Delta x$ and time step $\\Delta t$. State a sufficient diffusion-dominated stability condition on $\\Delta t$ in terms of $\\Delta x$ and the volatility $\\sigma$ that ensures numerical stability of the explicit scheme with central spatial differences and explain why violating this condition can cause spurious oscillations or blow-up.\n\nYour program must implement the above method and run the following test suite. For all tests, use the same spatial domain and grid unless otherwise noted:\n- Common settings for all tests:\n    - Option type: American put.\n    - Dividend yield: $q = 0$.\n    - Spatial domain in price: $S_{\\min} = 10^{-4}$ and $S_{\\max} = 5K$.\n    - Log-price domain: $x_{\\min} = \\ln S_{\\min}$ and $x_{\\max} = \\ln S_{\\max}$.\n    - Number of spatial intervals: $M = 400$ (thus $\\Delta x = (x_{\\max} - x_{\\min})/M$).\n    - Boundary conditions for all $t \\in [0,T]$: $V(S_{\\min},t) = K$ and $V(S_{\\max},t) = 0$.\n    - Terminal payoff at $t = T$: $V(S,T) = \\max(K - S, 0)$.\n    - American constraint at each time step: $V(S,t) \\leftarrow \\max(V(S,t), \\max(K - S, 0))$.\n    - Log-space explicit scheme with central differences in space.\n\n- Time step selection rule definition for stability analysis:\n    - Let the diffusion-based sufficient condition be $\\Delta t \\le \\Delta x^{2}/\\sigma^{2}$. Define the bound $B = \\Delta x^{2}/\\sigma^{2}$.\n    - For a given bound $B$ and maturity $T$, define:\n        - A stable time-step count $N_{\\text{stable}} = \\left\\lceil \\dfrac{T}{0.9 B} \\right\\rceil$ so that $\\Delta t_{\\text{stable}} = T/N_{\\text{stable}} \\le 0.9 B$.\n        - An unstable time-step count $N_{\\text{unstable}} = \\max\\left(1, \\left\\lfloor \\dfrac{T}{1.1 B} \\right\\rfloor \\right)$ so that $\\Delta t_{\\text{unstable}} = T/N_{\\text{unstable}} \\ge 1.1 B$.\n\n- Test cases:\n    1. Happy-path stability case:\n        - Parameters: $K = 100$, $r = 0.05$, $\\sigma = 0.2$, $T = 1.0$, $S_{0} = 100$.\n        - Use $N_{\\text{stable}}$ and compute the American put price at $S_{0}$.\n\n    2. Violated stability case:\n        - Same parameters as Test 1.\n        - Use $N_{\\text{unstable}}$ and compute the American put price at $S_{0}$.\n        - Also report whether the stability bound is violated, i.e., whether $\\Delta t_{\\text{unstable}} > B$.\n\n    3. Near-boundary asset price case:\n        - Parameters: $K = 100$, $r = 0.05$, $\\sigma = 0.2$, $T = 1.0$, $S_{0} = 1$.\n        - Use $N_{\\text{stable}}$ and compute the American put price at $S_{0}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must be ordered as follows:\n- First entry: the computed price from Test 1 (a float).\n- Second entry: the computed price from Test 2 (a float).\n- Third entry: the violation indicator from Test 2, equal to $1$ if $\\Delta t_{\\text{unstable}} > B$ and $0$ otherwise (an integer).\n- Fourth entry: the computed price from Test 3 (a float).\n\nNo external input is required, and there is no angle or physical unit involved. Express all numerical outputs as plain decimal numbers. The code must be a complete, runnable program that follows the specified algorithm and outputs exactly one line in the required format.", "solution": "The problem requires the derivation of the governing variational inequality for an American option, its transformation into log-price coordinates, the design of an explicit finite difference scheme for its numerical solution, and a stability analysis of the proposed scheme. This shall be done before implementing the method to price an American put option under several scenarios.\n\nFirst, we derive the variational inequality governing the value $V(S,t)$ of an American option on a non-dividend-paying stock, whose price $S(t)$ follows a geometric Brownian motion $dS = rS dt + \\sigma S dW_t$ under the risk-neutral measure, where $r$ is the risk-free rate and $\\sigma$ is the volatility. A portfolio is constructed by shorting one option and holding $\\Delta$ units of the underlying asset. The value of this portfolio is $\\Pi = -V + \\Delta S$. The change in its value is $d\\Pi = -dV + \\Delta dS$. According to Itô's lemma, the change in the option value is $dV = \\frac{\\partial V}{\\partial t}dt + \\frac{\\partial V}{\\partial S}dS + \\frac{1}{2}\\frac{\\partial^2 V}{\\partial S^2}(dS)^2$. Substituting $dS$ and $(dS)^2 = \\sigma^2 S^2 dt$, we get $dV = (\\frac{\\partial V}{\\partial t} + rS\\frac{\\partial V}{\\partial S} + \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2})dt + \\sigma S \\frac{\\partial V}{\\partial S}dW_t$. To eliminate risk from the portfolio, we choose $\\Delta = \\frac{\\partial V}{\\partial S}$ (delta-hedging). The change in the portfolio value becomes purely deterministic: $d\\Pi = -(\\frac{\\partial V}{\\partial t} + \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2})dt$. The return on this risk-free portfolio cannot offer an arbitrage opportunity. In the region where the option is not exercised (the continuation region), the portfolio must earn exactly the risk-free rate, i.e., $d\\Pi = r\\Pi dt = r(-V + S\\frac{\\partial V}{\\partial S})dt$. Equating the two expressions for $d\\Pi$ yields the Black-Scholes partial differential equation (PDE): $\\frac{\\partial V}{\\partial t} + rS\\frac{\\partial V}{\\partial S} + \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} - rV = 0$.\n\nFor an American option, the holder has the right to exercise at any time $t \\in [0,T]$. This imposes two key conditions. First, the option's value can never be less than its intrinsic value upon immediate exercise, $P(S,t)$, which is $\\max(K-S, 0)$ for a put. This is the obstacle constraint: $V(S,t) \\ge P(S)$. Second, in the continuation region where $V(S,t) > P(S)$, the option is held and its value evolves according to the Black-Scholes PDE. However, because of the early exercise right, the return on a portfolio that is short the American option must be no more than the risk-free rate, which prevents arbitrage for the buyer. This implies that the change in the value of the hedged portfolio $d\\Pi$ is less than or equal to the risk-free return $r\\Pi dt$. This leads to the inequality: $\\frac{\\partial V}{\\partial t} + rS\\frac{\\partial V}{\\partial S} + \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} - rV \\le 0$. This inequality holds everywhere in the domain $(S,t) \\in (0, \\infty) \\times [0, T)$.\n\nThese conditions form a complementary slackness problem, which is a type of variational inequality. The problem is summarized as follows:\n$1.$ Obstacle constraint: $V(S,t) \\ge \\max(K-S, 0)$.\n$2.$ PDE inequality: $\\mathcal{L}V \\equiv \\frac{\\partial V}{\\partial t} + \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} + rS\\frac{\\partial V}{\\partial S} - rV \\le 0$.\n$3.$ Complementary slackness: $(V(S,t) - \\max(K-S, 0)) \\times (\\mathcal{L}V) = 0$.\nThis means that in the continuation region $V > P(S)$, we must have $\\mathcal{L}V=0$. In the exercise region $V=P(S)$, we must have $\\mathcal{L}V \\le 0$. The differential operator for drift and diffusion is $\\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2}{\\partial S^2} + rS\\frac{\\partial}{\\partial S}$.\n\nNext, we transform the problem to log-price coordinates by setting $x = \\ln S$, so $S = e^x$. Let $u(x,t) = V(e^x, t)$. The derivatives transform as:\n$\\frac{\\partial V}{\\partial t} = \\frac{\\partial u}{\\partial t}$\n$\\frac{\\partial V}{\\partial S} = \\frac{\\partial u}{\\partial x} \\frac{\\partial x}{\\partial S} = \\frac{1}{S}\\frac{\\partial u}{\\partial x}$\n$\\frac{\\partial^2 V}{\\partial S^2} = \\frac{1}{S^2}(\\frac{\\partial^2 u}{\\partial x^2} - \\frac{\\partial u}{\\partial x})$\nSubstituting these into the inequality $\\mathcal{L}V \\le 0$ gives:\n$\\frac{\\partial u}{\\partial t} + \\frac{1}{2}\\sigma^2 S^2 \\left(\\frac{1}{S^2}(\\frac{\\partial^2 u}{\\partial x^2} - \\frac{\\partial u}{\\partial x})\\right) + rS \\left(\\frac{1}{S}\\frac{\\partial u}{\\partial x}\\right) - ru \\le 0$\nSimplifying and grouping terms yields the transformed inequality with constant coefficients:\n$\\frac{\\partial u}{\\partial t} + (r - \\frac{1}{2}\\sigma^2) \\frac{\\partial u}{\\partial x} + \\frac{1}{2}\\sigma^2 \\frac{\\partial^2 u}{\\partial x^2} - ru \\le 0$\nThe new drift coefficient is $(r - \\frac{1}{2}\\sigma^2)$ and the new diffusion coefficient is $\\frac{1}{2}\\sigma^2$. The obstacle constraint becomes $u(x,t) \\ge \\max(K-e^x, 0)$.\n\nTo solve this numerically, we design an explicit finite difference method. We discretize the $(x,t)$ domain with a uniform grid: $x_j = x_{\\min} + j\\Delta x$ for $j=0, \\dots, M$ and $t_n = T - n\\Delta t$ for $n=0, \\dots, N$. Let $u_j^n \\approx u(x_j, t_n)$. We solve backward in time from the known terminal condition $u(x,T) = \\max(K-e^x, 0)$.\nThe time derivative is approximated using a forward difference in backward time: $\\frac{\\partial u}{\\partial t} \\approx \\frac{u(t_n) - u(t_{n+1})}{\\Delta t} = \\frac{u_j^n - u_j^{n+1}}{\\Delta t}$.\nThe spatial derivatives are approximated using central differences at time level $n$:\n$\\frac{\\partial u}{\\partial x} \\approx \\frac{u_{j+1}^n - u_{j-1}^n}{2\\Delta x}$\n$\\frac{\\partial^2 u}{\\partial x^2} \\approx \\frac{u_{j+1}^n - 2u_j^n + u_{j-1}^n}{(\\Delta x)^2}$\nSubstituting these into the PDE (ignoring the inequality for a moment) gives an explicit update rule for $u_j^{n+1}$ (the value at the previous time step $t_{n+1} = t_n - \\Delta t$):\n$u_j^{n+1} = u_j^n - \\Delta t \\left[ (r - \\frac{1}{2}\\sigma^2) \\frac{u_{j+1}^n - u_{j-1}^n}{2\\Delta x} + \\frac{1}{2}\\sigma^2 \\frac{u_{j+1}^n - 2u_j^n + u_{j-1}^n}{(\\Delta x)^2} - ru_j^n \\right]$\nThis can be written as $u_j^{n+1} = a u_{j-1}^n + b u_j^n + c u_{j+1}^n$ where:\n$a = \\Delta t \\left( \\frac{\\sigma^2}{2(\\Delta x)^2} - \\frac{r - \\sigma^2/2}{2\\Delta x} \\right)$\n$b = 1 - \\Delta t \\left( \\frac{\\sigma^2}{(\\Delta x)^2} + r \\right)$\n$c = \\Delta t \\left( \\frac{\\sigma^2}{2(\\Delta x)^2} + \\frac{r - \\sigma^2/2}{2\\Delta x} \\right)$\nAfter computing this PDE-based value, we must enforce the American early exercise constraint:\n$u_j^{n+1} \\leftarrow \\max(u_j^{n+1}, \\max(K-e^{x_j}, 0))$\n\nThe problem specifies Dirichlet boundary conditions: $V(S_{\\min},t) = K$ and $V(S_{\\max},t) = 0$. These are financially meaningful. As $S \\to S_{\\max}$ for a put option, its value approaches $0$. As $S \\to S_{\\min}$ (very small), the put is deep-in-the-money. For a non-dividend paying stock, it is often optimal to exercise an American put early. Its value is then $K-S$. For a very small $S_{\\min}$, $K-S_{\\min} \\approx K$. Thus, the provided boundary conditions are reasonable approximations. In log-space, these are $u(x_{\\min},t) = K$ and $u(x_{\\max},t)=0$. These are applied at each time step.\n\nFor stability of the explicit scheme, all coefficients $a,b,c$ in the update rule must be non-negative. The most restrictive condition typically comes from the coefficient $b$:\n$b = 1 - \\Delta t \\left( \\frac{\\sigma^2}{(\\Delta x)^2} + r \\right) \\ge 0 \\implies \\Delta t \\le \\frac{1}{\\frac{\\sigma^2}{(\\Delta x)^2} + r}$\nA simpler, sufficient condition, often used and requested here, considers only the diffusion term, which is the highest order derivative and most sensitive to instability. This leads to the diffusion-dominated stability condition:\n$\\Delta t \\le \\frac{(\\Delta x)^2}{\\sigma^2}$\nViolation of this condition can make the coefficient $b$ negative. When $b < 0$, a positive value $u_j^n$ contributes negatively to the updated value $u_j^{n+1}$. This causes spurious, non-physical oscillations in the solution which can grow in magnitude as the computation proceeds backward in time. If the condition is violated severely, the sum of the absolute values of the coefficients can exceed $1$, leading to numerical blow-up where the solution grows without bound.", "answer": "```python\nimport numpy as np\nimport math\n\ndef price_american_put_fdm(K, r, sigma, T, S0, M, S_min_val, S_max_factor, N):\n    \"\"\"\n    Computes the American put option price using an explicit finite difference method.\n\n    Args:\n        K (float): Strike price.\n        r (float): Risk-free interest rate.\n        sigma (float): Volatility of the underlying asset.\n        T (float): Time to maturity.\n        S0 (float): Initial stock price.\n        M (int): Number of spatial intervals.\n        S_min_val (float): Minimum value for the price domain S.\n        S_max_factor (float): Factor to determine S_max = S_max_factor * K.\n        N (int): Number of time steps.\n\n    Returns:\n        float: The price of the American put option at S0 and t=0.\n    \"\"\"\n    # 1. Setup grid\n    S_max = S_max_factor * K\n    x_min, x_max = np.log(S_min_val), np.log(S_max)\n    dx = (x_max - x_min) / M\n    dt = T / N\n\n    x_grid = np.linspace(x_min, x_max, M + 1)\n    S_grid = np.exp(x_grid)\n\n    # 2. Initial condition at maturity T (n=0)\n    V = np.maximum(K - S_grid, 0)\n\n    # 3. FDM coefficients\n    nu = r - 0.5 * sigma**2\n    \n    # Coefficients for the explicit scheme u_j^{n+1} = a*u_{j-1}^n + b*u_j^n + c*u_{j+1}^n\n    # Note: we are calculating V at previous time step (n+1 in backward time) from current (n)\n    a = dt * (0.5 * sigma**2 / dx**2 - nu / (2 * dx))\n    b = 1 - dt * (sigma**2 / dx**2 + r)\n    c = dt * (0.5 * sigma**2 / dx**2 + nu / (2 * dx))\n\n    # 4. Time-stepping loop (from T back to 0)\n    for _ in range(N):\n        V_old = V.copy()\n        \n        # Update interior points using the PDE\n        V[1:-1] = a * V_old[:-2] + b * V_old[1:-1] + c * V_old[2:]\n\n        # Apply boundary conditions\n        V[0] = K  # V(S_min, t) = K\n        V[-1] = 0 # V(S_max, t) = 0\n        \n        # Apply American option early exercise constraint\n        payoff = np.maximum(K - S_grid, 0)\n        V = np.maximum(V, payoff)\n\n    # 5. Interpolate to find price at S0\n    price_at_t0 = np.interp(S0, S_grid, V)\n    \n    return price_at_t0\n\ndef solve():\n    \"\"\"\n    Main solver function that runs the test suite.\n    \"\"\"\n    # Common settings from the problem statement\n    M = 400\n    S_min_val = 1e-4\n    S_max_factor = 5.0\n    \n    test_cases = [\n        # Test 1: Happy-path stability case\n        {'K': 100.0, 'r': 0.05, 'sigma': 0.2, 'T': 1.0, 'S0': 100.0, 'case_type': 'stable'},\n        # Test 2: Violated stability case\n        {'K': 100.0, 'r': 0.05, 'sigma': 0.2, 'T': 1.0, 'S0': 100.0, 'case_type': 'unstable'},\n        # Test 3: Near-boundary asset price case\n        {'K': 100.0, 'r': 0.05, 'sigma': 0.2, 'T': 1.0, 'S0': 1.0, 'case_type': 'stable'}\n    ]\n\n    results = []\n\n    # Calculate stability parameters (only depends on K, sigma, M) for the first two tests\n    params1 = test_cases[0]\n    K1, sigma1, T1 = params1['K'], params1['sigma'], params1['T']\n    \n    S_max1 = S_max_factor * K1\n    x_min1 = np.log(S_min_val)\n    x_max1 = np.log(S_max1)\n    dx1 = (x_max1 - x_min1) / M\n    \n    # Diffusion-based stability bound B\n    B = dx1**2 / sigma1**2\n    \n    # Time step counts\n    N_stable = int(math.ceil(T1 / (0.9 * B)))\n    N_unstable = int(max(1, math.floor(T1 / (1.1 * B))))\n\n    # --- Test Case 1 ---\n    price1 = price_american_put_fdm(\n        K=params1['K'], r=params1['r'], sigma=params1['sigma'], T=params1['T'], S0=params1['S0'],\n        M=M, S_min_val=S_min_val, S_max_factor=S_max_factor, N=N_stable\n    )\n    results.append(price1)\n    \n    # --- Test Case 2 ---\n    params2 = test_cases[1]\n    price2 = price_american_put_fdm(\n        K=params2['K'], r=params2['r'], sigma=params2['sigma'], T=params2['T'], S0=params2['S0'],\n        M=M, S_min_val=S_min_val, S_max_factor=S_max_factor, N=N_unstable\n    )\n    results.append(price2)\n    \n    dt_unstable = params2['T'] / N_unstable\n    violation_indicator = 1 if dt_unstable > B else 0\n    results.append(violation_indicator)\n\n    # --- Test Case 3 ---\n    params3 = test_cases[2]\n    # Reuse N_stable as per problem description\n    price3 = price_american_put_fdm(\n        K=params3['K'], r=params3['r'], sigma=params3['sigma'], T=params3['T'], S0=params3['S0'],\n        M=M, S_min_val=S_min_val, S_max_factor=S_max_factor, N=N_stable\n    )\n    results.append(price3)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"}, {"introduction": "The framework of optimal stopping extends far beyond risk-neutral pricing. This final practice shifts the perspective to that of an individual agent making decisions to maximize their personal economic utility. You will apply the same dynamic programming logic learned in pricing problems to determine the optimal exercise strategy for a risk-averse agent, framing the problem in terms of maximizing expected utility and calculating the strategy's monetary value through its certainty equivalent. This exercise highlights the versatility of computational methods in modeling rational economic behavior. [@problem_id:2420671]", "id": "2420671", "problem": "You are given a discrete-time financial market for an American put option held by an agent with exponential utility. Time is divided into $N$ steps, with dates $t \\in \\{0,1,\\dots,N\\}$ and total horizon $T>0$. Let $\\Delta t = T/N$. The underlying price process $\\{S_t\\}$ evolves as a multiplicative random walk:\n$$\nS_{t+1} = S_t \\cdot \\begin{cases}\nu & \\text{with probability } p,\\\\\nd & \\text{with probability } 1-p,\n\\end{cases}\n$$\nwhere $u = \\exp(\\sigma \\sqrt{\\Delta t})$, $d = 1/u$, and $p = \\dfrac{\\exp(\\mu \\Delta t) - d}{u - d}$. The continuously compounded risk-free rate is $r$, so the per-step gross return is $R = \\exp(r \\Delta t)$. The agent holds one American put with strike $K$; the immediate exercise payoff at date $t$ is $P_t = \\max(K - S_t, 0)$. If exercised at date $t$, the payoff $P_t$ is deposited in the risk-free asset until $T$, yielding a terminal deposit value $R^{N - t} P_t$. The agent’s utility over terminal wealth $W_T$ is exponential with constant absolute risk aversion (CARA): $U(W_T) = -\\exp(-\\gamma W_T)$, where $\\gamma>0$ is the risk aversion coefficient. Assume initial wealth $W_0 = 0$ so that $W_T$ equals the terminal value generated by the option exercise decision alone.\n\nDefine the agent’s objective as choosing a stopping time $\\tau \\in \\{0,1,\\dots,N\\}$ adapted to the price process to maximize the expected utility of terminal wealth:\n$$\n\\sup_{\\tau \\in \\{0,1,\\dots,N\\}} \\mathbb{E}\\left[ U\\left( R^{N-\\tau} \\max(K - S_\\tau, 0) \\right) \\right].\n$$\n\nYour task is to write a program that, for each specified parameter set, computes the following two outputs:\n- The present-value certainty equivalent at date $0$ of the utility-optimal exercise policy,\n$$\n\\text{CE}_0 = \\frac{1}{R^N} \\cdot \\left( -\\frac{1}{\\gamma} \\ln \\left( \\inf_{\\tau \\in \\{0,1,\\dots,N\\}} \\mathbb{E}\\left[ \\exp\\left( -\\gamma \\, R^{N-\\tau} \\max(K - S_\\tau, 0) \\right) \\right] \\right) \\right),\n$$\nexpressed in the same currency units as $S$ and $K$, and reported as a floating-point number rounded to $6$ decimal places.\n- A boolean indicating whether exercising immediately at $t=0$ is optimal under the same utility criterion.\n\nUse the following test suite. In all cases, express all rates as decimals (not as percentages), and all outputs must be in currency units consistent with $S$ and $K$.\n\nTest cases, each tuple $(S_0, K, r, \\mu, \\sigma, T, N, \\gamma)$:\n- Case $1$: $(100, 100, 0.02, 0.06, 0.2, 1, 50, 1)$.\n- Case $2$: $(40, 100, 0.02, 0.06, 0.2, 1, 50, 1)$.\n- Case $3$: $(100, 100, 0.02, 0.06, 0.2, 1, 50, 10^{-6})$.\n- Case $4$: $(90, 100, 0.10, 0.00, 0.25, 1, 50, 5)$.\n\nFinal output format requirement:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order\n$$\n[\\text{CE}_0^{(1)}, \\text{ExNow}^{(1)}, \\text{CE}_0^{(2)}, \\text{ExNow}^{(2)}, \\text{CE}_0^{(3)}, \\text{ExNow}^{(3)}, \\text{CE}_0^{(4)}, \\text{ExNow}^{(4)}],\n$$\nwhere $\\text{CE}_0^{(i)}$ is the date-$0$ certainty equivalent for case $i$ (rounded to $6$ decimal places), and $\\text{ExNow}^{(i)}$ is a boolean that is $\\text{True}$ if immediate exercise at $t=0$ is optimal for case $i$, and $\\text{False}$ otherwise. The output must contain exactly $8$ entries on one line, formatted as specified, and nothing else.", "solution": "The posed problem is a discrete-time optimal stopping problem. The agent's objective is to choose an exercise time $\\tau$ for an American put option to maximize the expected utility of terminal wealth. The utility function is of the exponential form $U(W_T) = -\\exp(-\\gamma W_T)$, which implies constant absolute risk aversion (CARA). The problem can be solved using dynamic programming by working backward in time from the option's expiration.\n\nLet us define a value function $J(t, S_t)$ that represents the minimum expected value of $\\exp(-\\gamma W_T)$, conditional on the stock price being $S_t$ at time $t$. Maximizing the expected utility $\\mathbb{E}[U(W_T)]$ is equivalent to minimizing $\\mathbb{E}[\\exp(-\\gamma W_T)]$, since $U(W_T)$ is a strictly decreasing, monotonic transformation of $\\exp(-\\gamma W_T)$. The value function is thus defined as:\n$$\nJ(t, S_t) = \\inf_{\\tau \\in \\{t, \\dots, N\\}} \\mathbb{E} \\left[ \\exp\\left( -\\gamma R^{N-\\tau} \\max(K - S_\\tau, 0) \\right) \\, \\Big| \\, S_t \\right]\n$$\nwhere $\\mathbb{E}[\\cdot|S_t]$ denotes the expectation conditional on the information at time $t$. The solution is found by applying the principle of optimality (the Bellman equation) at each time step.\n\nAt any time $t < N$ and for a given stock price $S_t$, the agent has two choices: exercise the option immediately or continue to hold it. The value function is the minimum of the values associated with these two actions.\n$$\nJ(t, S_t) = \\min\\left( J_{\\text{exercise}}(t, S_t), J_{\\text{hold}}(t, S_t) \\right)\n$$\n\nThe value of immediate exercise, $J_{\\text{exercise}}(t, S_t)$, is obtained by exercising the option to receive a payoff of $P_t = \\max(K-S_t, 0)$. This amount is then invested at the risk-free rate until the terminal date $T$. The terminal wealth is $W_T = R^{N-t} P_t$. Since this outcome is certain once the decision to exercise is made, the value is:\n$$\nJ_{\\text{exercise}}(t, S_t) = \\exp\\left( -\\gamma R^{N-t} \\max(K - S_t, 0) \\right)\n$$\n\nThe value of holding the option, $J_{\\text{hold}}(t, S_t)$, is the expected value of the decision problem at the next time step, $t+1$. The underlying price $S_t$ can move to $S_{t+1}^u = S_t \\cdot u$ with physical probability $p$ or to $S_{t+1}^d = S_t \\cdot d$ with probability $1-p$. The hold value is therefore:\n$$\nJ_{\\text{hold}}(t, S_t) = \\mathbb{E} \\left[ J(t+1, S_{t+1}) \\,|\\, S_t \\right] = p \\cdot J(t+1, S_t u) + (1-p) \\cdot J(t+1, S_t d)\n$$\nThe probabilities $p$ and $1-p$ are the real-world (or physical) probabilities, derived from the expected return $\\mu$ of the asset, which is appropriate for a utility maximization problem.\n\nThe problem is solved via backward induction on a binomial lattice representing the possible evolution of the stock price.\nThe state at time $t$ can be uniquely identified by the number of up-moves, $j \\in \\{0, 1, \\dots, t\\}$, leading to a stock price $S_{t, j} = S_0 u^j d^{t-j}$.\n\n1.  **Terminal Condition (at $t=N$)**: At expiration, the option must be exercised if it is in the money. There is no \"hold\" choice. The terminal wealth is simply the immediate payoff $\\max(K-S_N, 0)$, as $R^{N-N}=R^0=1$. Thus, for each possible final stock price $S_{N, j} = S_0 u^j d^{N-j}$ where $j \\in \\{0, 1, \\dots, N\\}$:\n    $$\n    J(N, S_{N,j}) = \\exp\\left( -\\gamma \\max(K - S_{N,j}, 0) \\right)\n    $$\n\n2.  **Backward Induction (for $t=N-1, \\dots, 0$)**: For each time step $t$ and for each state $j \\in \\{0, 1, \\dots, t\\}$ corresponding to price $S_{t,j}$:\n    *   Compute the exercise value $J_{\\text{exercise}}(t, S_{t,j})$.\n    *   Compute the hold value $J_{\\text{hold}}(t, S_{t,j}) = p \\cdot J(t+1, S_{t+1, j+1}) + (1-p) \\cdot J(t+1, S_{t+1, j})$.\n    *   The value at this node is $J(t, S_{t,j}) = \\min\\left(J_{\\text{exercise}}(t, S_{t,j}), J_{\\text{hold}}(t, S_{t,j})\\right)$.\n\nThis process continues until time $t=0$, yielding the value $J(0, S_0)$. This is the minimal expected transformed terminal wealth.\nThe optimal exercise policy is implicitly determined at each node: exercise if $J_{\\text{exercise}} \\le J_{\\text{hold}}$. The boolean for whether to exercise immediately at $t=0$ is therefore determined by comparing $J_{\\text{exercise}}(0, S_0)$ and $J_{\\text{hold}}(0, S_0)$.\n\nFinally, we compute the present-value certainty equivalent, $\\text{CE}_0$. The certainty equivalent terminal wealth, $\\text{CE}_T$, is the certain amount of wealth that provides the same utility as the optimal (but uncertain) exercise strategy. It is defined by $U(\\text{CE}_T) = \\mathbb{E}[U(W_T^*)]$, where $W_T^*$ is the optimal terminal wealth.\n$$\n-\\exp(-\\gamma \\cdot \\text{CE}_T) = \\sup_{\\tau} \\mathbb{E} \\left[ -\\exp\\left(-\\gamma R^{N-\\tau}\\max(K-S_\\tau, 0)\\right) \\right] = -J(0, S_0)\n$$\nSolving for $\\text{CE}_T$, we get:\n$$\n\\text{CE}_T = -\\frac{1}{\\gamma} \\ln\\left( J(0, S_0) \\right)\n$$\nThe problem asks for the present value of this certainty equivalent, discounted from time $T$ to time $0$ at the risk-free rate. The total discount factor is $R^N = (\\exp(r \\Delta t))^N = \\exp(r T)$.\n$$\n\\text{CE}_0 = \\frac{\\text{CE}_T}{R^N} = \\frac{1}{R^N} \\left( -\\frac{1}{\\gamma} \\ln\\left( J(0, S_0) \\right) \\right)\n$$\nThis formula provides the final required monetary value. The algorithm computes $J(0, S_0)$, the immediate exercise decision, and $\\text{CE}_0$ for each parameter set.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    It computes the certainty equivalent and optimal immediate exercise decision\n    for an American put option under exponential utility.\n    \"\"\"\n\n    test_cases = [\n        # (S0, K, r, mu, sigma, T, N, gamma)\n        (100.0, 100.0, 0.02, 0.06, 0.2, 1.0, 50, 1.0),\n        (40.0, 100.0, 0.02, 0.06, 0.2, 1.0, 50, 1.0),\n        (100.0, 100.0, 0.02, 0.06, 0.2, 1.0, 50, 1e-6),\n        (90.0, 100.0, 0.10, 0.00, 0.25, 1.0, 50, 5.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        ce_0, ex_now = calculate_utility_optimal_policy(*case)\n        results.append(f\"{ce_0:.6f}\")\n        results.append(str(ex_now))\n\n    print(f\"[{','.join(results)}]\")\n\ndef calculate_utility_optimal_policy(S0, K, r, mu, sigma, T, N, gamma):\n    \"\"\"\n    Calculates the present-value certainty equivalent and immediate exercise decision\n    for an American put option with exponential utility via dynamic programming.\n\n    Args:\n        S0 (float): Initial stock price.\n        K (float): Strike price.\n        r (float): Risk-free interest rate (continuously compounded).\n        mu (float): Expected return of the stock (continuously compounded).\n        sigma (float): Volatility of the stock.\n        T (float): Time to maturity in years.\n        N (int): Number of time steps in the binomial model.\n        gamma (float): Coefficient of absolute risk aversion.\n\n    Returns:\n        tuple: A tuple containing:\n            - ce_0 (float): The present-value certainty equivalent at time 0.\n            - ex_now (bool): True if immediate exercise at t=0 is optimal, False otherwise.\n    \"\"\"\n    # 1. Calculate model parameters\n    delta_t = T / N\n    u = np.exp(sigma * np.sqrt(delta_t))\n    d = 1.0 / u\n    R = np.exp(r * delta_t)  # Gross risk-free return per step\n    p = (np.exp(mu * delta_t) - d) / (u - d) # Physical probability\n\n    # 2. Initialize values at terminal time N\n    # J_next stores the values of the function J(t+1, S)\n    # The size is N+1 for the N+1 possible stock prices at time N.\n    J_next = np.zeros(N + 1)\n    for j in range(N + 1):\n        S_N = S0 * (u**j) * (d**(N - j))\n        payoff = max(K - S_N, 0)\n        J_next[j] = np.exp(-gamma * payoff)\n\n    # Variables to store the decision at t=0\n    ex_now = False\n\n    # 3. Backward induction from t=N-1 to t=0\n    for t in range(N - 1, -1, -1):\n        # J_curr stores the values of J(t, S)\n        # There are t+1 possible nodes at time t.\n        J_curr = np.zeros(t + 1)\n        for j in range(t + 1):\n            S_t = S0 * (u**j) * (d**(t - j))\n            \n            # Calculate exercise value\n            payoff_t = max(K - S_t, 0)\n            terminal_value_of_payoff = payoff_t * (R**(N - t))\n            J_exercise = np.exp(-gamma * terminal_value_of_payoff)\n            \n            # Calculate continuation (hold) value\n            # Next states from (t,j) are (t+1, j+1) [up] and (t+1, j) [down]\n            J_hold = p * J_next[j + 1] + (1 - p) * J_next[j]\n\n            # Bellman equation: take the minimum\n            J_curr[j] = min(J_exercise, J_hold)\n\n            # At t=0, determine if immediate exercise is optimal\n            if t == 0:\n                # Standard convention: exercise if equal\n                if J_exercise <= J_hold:\n                    ex_now = True\n\n        J_next = J_curr\n\n    # 4. Calculate final results\n    J_0_S0 = J_next[0]\n    \n    # Handle the case where J_0_S0 is extremely close to 0, which can lead to -inf\n    if J_0_S0 <= 0:\n      # This corresponds to infinite utility, so CE is infinite.\n      # Highly unlikely with finite payoffs, but a safeguard.\n      ce_T = float('inf')\n    else:\n      ce_T = -np.log(J_0_S0) / gamma\n    \n    # Discount to present value\n    total_discount_factor = np.exp(r * T)\n    ce_0 = ce_T / total_discount_factor\n    \n    return ce_0, ex_now\n\nif __name__ == '__main__':\n    solve()\n```"}]}