{"hands_on_practices": [{"introduction": "This first practice is your entry point into the practical world of the Black-Litterman model. By translating its core equations into a functional program, you will build the engine that powers this sophisticated portfolio allocation strategy. This exercise will solidify your understanding of how the model elegantly combines a market-equilibrium prior with an investor's subjective views, giving you a hands-on feel for the Bayesian mechanics at its heart [@problem_id:2376247].", "id": "2376247", "problem": "You are tasked with implementing the Black–Litterman portfolio model as a fully specified computational program. The model combines a prior market-implied multivariate normal distribution of returns with linear Gaussian investor views to produce a posterior distribution of returns, and then computes the unconstrained mean–variance optimal weights using the same covariance matrix and a given risk aversion parameter.\n\nLet there be $n$ risky assets with excess returns represented by the random vector $\\mathbf{r} \\in \\mathbb{R}^n$. Assume the following modeling framework:\n\n1. Prior (market-implied) beliefs: $\\mathbf{r}$ is modeled as a multivariate normal with mean $\\boldsymbol{\\mu}_0 \\in \\mathbb{R}^n$ and covariance $\\tau \\boldsymbol{\\Sigma} \\in \\mathbb{R}^{n \\times n}$, where $\\tau \\in \\mathbb{R}_{>0}$ is a scalar representing the uncertainty scaling of the prior, and $\\boldsymbol{\\Sigma} \\in \\mathbb{R}^{n \\times n}$ is a positive definite covariance matrix of asset returns. The prior mean is implied by market capitalization weights $\\mathbf{w}_m \\in \\mathbb{R}^n$ and a risk aversion parameter $\\lambda \\in \\mathbb{R}_{>0}$ via $\\boldsymbol{\\mu}_0 = \\lambda \\boldsymbol{\\Sigma} \\mathbf{w}_m$.\n\n2. Linear Gaussian views: There are $k$ linear views represented by $\\mathbf{P} \\in \\mathbb{R}^{k \\times n}$ and $\\mathbf{Q} \\in \\mathbb{R}^k$, with view noise covariance $\\boldsymbol{\\Omega} \\in \\mathbb{R}^{k \\times k}$, positive definite. The observed views are modeled as $\\mathbf{P} \\mathbf{r}$ being a noisy observation of $\\mathbf{Q}$ with Gaussian noise having covariance $\\boldsymbol{\\Omega}$.\n\n3. Posterior belief: Using these assumptions, compute the posterior mean of $\\mathbf{r}$ after observing the views, denoted $\\boldsymbol{\\mu}_{\\text{BL}} \\in \\mathbb{R}^n$.\n\n4. Unconstrained optimal weights: Using the same covariance matrix $\\boldsymbol{\\Sigma}$ and risk aversion $\\lambda$, compute the unconstrained mean–variance optimal weights $\\mathbf{w}_{\\text{BL}} \\in \\mathbb{R}^n$ based on $\\boldsymbol{\\mu}_{\\text{BL}}$. The weights must be expressed as decimals (not as percentages).\n\nYou must write a program that, for each test case below, computes and outputs the vector $\\mathbf{w}_{\\text{BL}}$.\n\nDefinitions and assumptions to be used are as follows:\n- The prior mean is $\\boldsymbol{\\mu}_0 = \\lambda \\boldsymbol{\\Sigma} \\mathbf{w}_m$.\n- The prior covariance of $\\mathbf{r}$ is $\\tau \\boldsymbol{\\Sigma}$.\n- The investor views are linear with Gaussian noise as described above.\n- The unconstrained mean–variance optimal weights are obtained from the posterior mean and the covariance matrix under the given risk aversion parameter.\n- All computations are in consistent, dimensionless units; all outputs must be decimals.\n\nTest Suite (three cases):\n\nCase A (general informative views):\n- Number of assets: $n = 3$.\n- Covariance matrix:\n$$\n\\boldsymbol{\\Sigma}_A =\n\\begin{bmatrix}\n0.04 & 0.006 & 0.004 \\\\\n0.006 & 0.09 & 0.002 \\\\\n0.004 & 0.002 & 0.0225\n\\end{bmatrix}.\n$$\n- Market capitalization weights:\n$$\n\\mathbf{w}_{m,A} = \\begin{bmatrix} 0.6 \\\\ 0.3 \\\\ 0.1 \\end{bmatrix}.\n$$\n- Risk aversion: $\\lambda_A = 2.5$.\n- Prior uncertainty scaling: $\\tau_A = 0.05$.\n- Views:\n$$\n\\mathbf{P}_A =\n\\begin{bmatrix}\n1 & -1 & 0 \\\\\n0 & 1 & -1\n\\end{bmatrix}, \\quad\n\\mathbf{Q}_A = \\begin{bmatrix} 0.02 \\\\ 0.01 \\end{bmatrix}, \\quad\n\\boldsymbol{\\Omega}_A = \\begin{bmatrix} 0.0004 & 0 \\\\ 0 & 0.0009 \\end{bmatrix}.\n$$\n\nCase B (no views edge case):\n- Number of assets: $n = 3$.\n- Covariance matrix:\n$$\n\\boldsymbol{\\Sigma}_B =\n\\begin{bmatrix}\n0.04 & 0.006 & 0.004 \\\\\n0.006 & 0.09 & 0.002 \\\\\n0.004 & 0.002 & 0.0225\n\\end{bmatrix}.\n$$\n- Market capitalization weights:\n$$\n\\mathbf{w}_{m,B} = \\begin{bmatrix} 0.6 \\\\ 0.3 \\\\ 0.1 \\end{bmatrix}.\n$$\n- Risk aversion: $\\lambda_B = 2.5$.\n- Prior uncertainty scaling: $\\tau_B = 0.05$.\n- Views: $k = 0$ (no views), represented by an empty matrix $\\mathbf{P}_B \\in \\mathbb{R}^{0 \\times 3}$, empty vector $\\mathbf{Q}_B \\in \\mathbb{R}^{0}$, and empty $\\boldsymbol{\\Omega}_B \\in \\mathbb{R}^{0 \\times 0}$.\n\nCase C (high-confidence single relative view):\n- Number of assets: $n = 3$.\n- Covariance matrix:\n$$\n\\boldsymbol{\\Sigma}_C =\n\\begin{bmatrix}\n0.05 & 0.01 & 0.0 \\\\\n0.01 & 0.07 & 0.005 \\\\\n0.0 & 0.005 & 0.03\n\\end{bmatrix}.\n$$\n- Market capitalization weights:\n$$\n\\mathbf{w}_{m,C} = \\begin{bmatrix} 0.4 \\\\ 0.4 \\\\ 0.2 \\end{bmatrix}.\n$$\n- Risk aversion: $\\lambda_C = 3.0$.\n- Prior uncertainty scaling: $\\tau_C = 0.1$.\n- Views:\n$$\n\\mathbf{P}_C = \\begin{bmatrix} 1 & 0 & -1 \\end{bmatrix}, \\quad\n\\mathbf{Q}_C = \\begin{bmatrix} 0.05 \\end{bmatrix}, \\quad\n\\boldsymbol{\\Omega}_C = \\begin{bmatrix} 10^{-6} \\end{bmatrix}.\n$$\n\nRequired final output format:\n- Your program must process the three cases in the order A, B, C and output a single line containing a list of three lists, where each inner list contains the three components of $\\mathbf{w}_{\\text{BL}}$ for that case, rounded to six decimal places. The exact format is:\n\"[ [wA1,wA2,wA3], [wB1,wB2,wB3], [wC1,wC2,wC3] ]\" with no spaces except those shown and no additional text.\n- Each weight must be expressed as a decimal number rounded to six digits after the decimal point.\n\nYour program should produce a single line of output containing the results as a comma-separated list of lists enclosed in square brackets, exactly as described above.", "solution": "The problem as stated is subjected to validation.\n\nStep 1: Extract Givens\n- Number of assets: $n$.\n- Asset excess returns: random vector $\\mathbf{r} \\in \\mathbb{R}^n$.\n- Prior distribution: $\\mathbf{r} \\sim \\mathcal{N}(\\boldsymbol{\\mu}_0, \\tau \\boldsymbol{\\Sigma})$.\n- Prior mean (market-implied): $\\boldsymbol{\\mu}_0 = \\lambda \\boldsymbol{\\Sigma} \\mathbf{w}_m$.\n- Market capitalization weights: $\\mathbf{w}_m \\in \\mathbb{R}^n$.\n- Risk aversion parameter: $\\lambda \\in \\mathbb{R}_{>0}$.\n- Prior covariance matrix: $\\tau \\boldsymbol{\\Sigma}$. $\\boldsymbol{\\Sigma} \\in \\mathbb{R}^{n \\times n}$ is a positive definite covariance matrix, and $\\tau \\in \\mathbb{R}_{>0}$ is a scalar for uncertainty scaling.\n- Number of investor views: $k$.\n- View matrix: $\\mathbf{P} \\in \\mathbb{R}^{k \\times n}$.\n- View outcomes: $\\mathbf{Q} \\in \\mathbb{R}^k$.\n- View noise covariance: $\\boldsymbol{\\Omega} \\in \\mathbb{R}^{k \\times k}$, positive definite.\n- View model: $\\mathbf{P} \\mathbf{r}$ is a noisy observation of $\\mathbf{Q}$ with Gaussian noise having covariance $\\boldsymbol{\\Omega}$.\n- Posterior mean of returns: $\\boldsymbol{\\mu}_{\\text{BL}}$.\n- Unconstrained mean-variance optimal weights: $\\mathbf{w}_{\\text{BL}} = \\frac{1}{\\lambda} \\boldsymbol{\\Sigma}^{-1} \\boldsymbol{\\mu}_{\\text{BL}}$.\n- Three test cases (A, B, C) are provided with specific numerical values for all parameters.\n- Output format: A single-line string representing a list of lists of weights, with each weight rounded to six decimal places.\n\nStep 2: Validate Using Extracted Givens\n- **Scientific Grounding**: The problem describes the Black–Litterman model, a well-established and scientifically sound method in quantitative finance for portfolio allocation. The underlying mathematics are based on Bayesian inference for multivariate normal distributions, which is a fundamental concept in statistics. The problem is scientifically grounded.\n- **Well-Posed**: All necessary parameters for each test case are provided. The matrices $\\boldsymbol{\\Sigma}$ and $\\boldsymbol{\\Omega}$ are specified as positive definite, which guarantees that their inverses exist, a necessary condition for the computation. The problem structure allows for a unique solution. It is well-posed.\n- **Objective**: The problem is stated using precise mathematical language and definitions. It is free of subjective or ambiguous terminology.\n- **Completeness and Consistency**: The problem is self-contained. It provides all data and definitions required for a solution. The definitions are consistent with standard literature on the subject. The 'no views' case is specified with empty matrices, which is a coherent special case.\n- **Realism**: The numerical values provided are within a realistic range for financial applications.\n- **Structure**: The problem is well-structured, presenting the model, the required calculations, and the test data in a clear, logical sequence.\n\nStep 3: Verdict and Action\nThe problem is valid. It is a direct application of established theory in computational finance. A solution will be provided.\n\nThe Black–Litterman model combines a prior distribution of expected asset returns with investor-specified views to produce a posterior distribution of returns. The task is to compute the unconstrained mean-variance optimal portfolio weights based on this posterior mean.\n\nThe model is defined by two Gaussian information sources:\n1.  The prior belief, derived from market equilibrium, states that the returns vector $\\mathbf{r}$ is distributed as $\\mathbf{r} \\sim \\mathcal{N}(\\boldsymbol{\\mu}_0, \\tau \\boldsymbol{\\Sigma})$, where the prior mean is $\\boldsymbol{\\mu}_0 = \\lambda \\boldsymbol{\\Sigma} \\mathbf{w}_m$.\n2.  The investor views provide additional information. The problem states that $\\mathbf{P}\\mathbf{r}$ is a noisy observation of $\\mathbf{Q}$. This is modeled as a linear Gaussian constraint: $\\mathbf{P}\\mathbf{r} \\sim \\mathcal{N}(\\mathbf{Q}, \\boldsymbol{\\Omega})$.\n\nCombining these two Gaussian information sources is a standard Bayesian inference problem. The posterior distribution for $\\mathbf{r}$ is also Gaussian. We are interested in its mean, $\\boldsymbol{\\mu}_{\\text{BL}}$. A numerically stable and elegant method to find the posterior is by combining the precision matrices (inverse covariance matrices) of the prior and the likelihood term from the views.\n\nThe precision matrix of the prior is $(\\tau\\boldsymbol{\\Sigma})^{-1} = \\frac{1}{\\tau}\\boldsymbol{\\Sigma}^{-1}$.\nThe view equation $\\mathbf{P}\\mathbf{r} \\sim \\mathcal{N}(\\mathbf{Q}, \\boldsymbol{\\Omega})$ can be rewritten as $\\mathbf{Q} = \\mathbf{P}\\mathbf{r} + \\boldsymbol{\\epsilon}$ with $\\boldsymbol{\\epsilon} \\sim \\mathcal{N}(\\mathbf{0}, \\boldsymbol{\\Omega})$. The log-likelihood for $\\mathbf{r}$ given the view is proportional to $-(\\mathbf{P}\\mathbf{r} - \\mathbf{Q})^T \\boldsymbol{\\Omega}^{-1} (\\mathbf{P}\\mathbf{r} - \\mathbf{Q})$. This corresponds to a precision term of $\\mathbf{P}^T \\boldsymbol{\\Omega}^{-1} \\mathbf{P}$ being added to the prior precision.\n\nThe posterior precision matrix is the sum of the prior and view-implied precision matrices:\n$$\n\\mathbf{\\Sigma}_{\\text{BL}}^{-1} = (\\tau\\boldsymbol{\\Sigma})^{-1} + \\mathbf{P}^T\\boldsymbol{\\Omega}^{-1}\\mathbf{P}\n$$\nThe posterior mean $\\boldsymbol{\\mu}_{\\text{BL}}$ is then a precision-weighted average of the prior mean and the view-implied mean:\n$$\n\\boldsymbol{\\mu}_{\\text{BL}} = \\mathbf{\\Sigma}_{\\text{BL}} \\left( (\\tau\\boldsymbol{\\Sigma})^{-1}\\boldsymbol{\\mu}_0 + \\mathbf{P}^T\\boldsymbol{\\Omega}^{-1}\\mathbf{Q} \\right)\n$$\nSubstituting the posterior precision matrix gives the full expression for the posterior mean:\n$$\n\\boldsymbol{\\mu}_{\\text{BL}} = \\left( (\\tau\\boldsymbol{\\Sigma})^{-1} + \\mathbf{P}^T\\boldsymbol{\\Omega}^{-1}\\mathbf{P} \\right)^{-1} \\left( (\\tau\\boldsymbol{\\Sigma})^{-1}\\boldsymbol{\\mu}_0 + \\mathbf{P}^T\\boldsymbol{\\Omega}^{-1}\\mathbf{Q} \\right)\n$$\n\nThe computational steps are as follows:\n\n1.  Calculate the prior mean vector $\\boldsymbol{\\mu}_0$:\n    $$\n    \\boldsymbol{\\mu}_0 = \\lambda \\boldsymbol{\\Sigma} \\mathbf{w}_m\n    $$\n\n2.  Handle the edge case where there are no views ($k=0$). In this scenario, $\\mathbf{P}$, $\\mathbf{Q}$, and $\\boldsymbol{\\Omega}$ are empty. The terms involving these matrices are zero, so the posterior precision equals the prior precision, and the posterior mean equals the prior mean:\n    $$\n    \\boldsymbol{\\mu}_{\\text{BL}} = \\boldsymbol{\\mu}_0 \\quad (\\text{if } k=0)\n    $$\n\n3.  For the general case ($k > 0$), compute the posterior mean $\\boldsymbol{\\mu}_{\\text{BL}}$:\n    a. Compute matrix inverses: $\\boldsymbol{\\Sigma}^{-1}$ and $\\boldsymbol{\\Omega}^{-1}$. This is possible as both matrices are given as positive definite.\n    b. Compute the posterior precision matrix: $\\mathbf{M}_{\\text{post}} = \\frac{1}{\\tau}\\boldsymbol{\\Sigma}^{-1} + \\mathbf{P}^T\\boldsymbol{\\Omega}^{-1}\\mathbf{P}$.\n    c. Compute the weighted mean term: $\\mathbf{v}_{\\text{post}} = \\frac{1}{\\tau}\\boldsymbol{\\Sigma}^{-1}\\boldsymbol{\\mu}_0 + \\mathbf{P}^T\\boldsymbol{\\Omega}^{-1}\\mathbf{Q}$.\n    d. Compute the posterior mean: $\\boldsymbol{\\mu}_{\\text{BL}} = \\mathbf{M}_{\\text{post}}^{-1} \\mathbf{v}_{\\text{post}}$.\n\n4.  Calculate the unconstrained mean-variance optimal weights $\\mathbf{w}_{\\text{BL}}$. The problem explicitly states to use the original covariance matrix $\\boldsymbol{\\Sigma}$ and risk aversion parameter $\\lambda$. The standard formula for unconstrained optimization is:\n    $$\n    \\mathbf{w}_{\\text{BL}} = \\frac{1}{\\lambda} \\boldsymbol{\\Sigma}^{-1} \\boldsymbol{\\mu}_{\\text{BL}}\n    $$\n    For the no-views case ($k=0$), this simplifies to $\\mathbf{w}_{\\text{BL}} = \\frac{1}{\\lambda}\\boldsymbol{\\Sigma}^{-1}\\boldsymbol{\\mu}_0 = \\frac{1}{\\lambda}\\boldsymbol{\\Sigma}^{-1}(\\lambda\\boldsymbol{\\Sigma}\\mathbf{w}_m) = \\mathbf{w}_m$. The resulting portfolio is simply the market portfolio, which is the correct and expected outcome.\n\nThis structured algorithm will be implemented to solve for the weights in each of the three test cases.", "answer": "```python\nimport numpy as np\n\ndef calculate_bl_weights(Sigma, w_m, lam, tau, P, Q, Omega):\n    \"\"\"\n    Computes the Black-Litterman optimal portfolio weights.\n\n    Args:\n        Sigma (np.ndarray): n x n covariance matrix of asset returns.\n        w_m (np.ndarray): n x 1 vector of market capitalization weights.\n        lam (float): Risk aversion parameter.\n        tau (float): Uncertainty scaling of the prior.\n        P (np.ndarray): k x n matrix for linear views.\n        Q (np.ndarray): k x 1 vector for view outcomes.\n        Omega (np.ndarray): k x k covariance matrix of view noise.\n\n    Returns:\n        np.ndarray: n x 1 vector of unconstrained optimal weights.\n    \"\"\"\n    n, k = Sigma.shape[0], P.shape[0]\n\n    # Step 1: Calculate the prior mean (market-implied returns)\n    mu_0 = lam * Sigma @ w_m\n\n    # Pre-calculate inverse of Sigma as it's used multiple times\n    Sigma_inv = np.linalg.inv(Sigma)\n\n    # Step 2 & 3: Compute the posterior mean\n    if k == 0:\n        # If there are no views, posterior mean equals prior mean\n        mu_bl = mu_0\n    else:\n        # Invert the view noise covariance matrix\n        Omega_inv = np.linalg.inv(Omega)\n\n        # Posterior precision matrix\n        # M_post = (1/tau) * Sigma_inv + P.T @ Omega_inv @ P\n        # Using np.linalg.multi_dot for potential efficiency and clarity\n        posterior_precision = (1 / tau) * Sigma_inv + np.linalg.multi_dot([P.T, Omega_inv, P])\n\n        # Weighted mean term\n        # v_post = (1/tau) * Sigma_inv @ mu_0 + P.T @ Omega_inv @ Q\n        # Using np.linalg.multi_dot here as well\n        weighted_mean_term = (1 / tau) * (Sigma_inv @ mu_0) + np.linalg.multi_dot([P.T, Omega_inv, Q])\n\n        # Posterior mean\n        mu_bl = np.linalg.inv(posterior_precision) @ weighted_mean_term\n\n    # Step 4: Calculate unconstrained mean-variance optimal weights\n    w_bl = (1 / lam) * (Sigma_inv @ mu_bl)\n\n    return w_bl\n\ndef solve():\n    \"\"\"\n    Defines test cases, computes results, and formats the output.\n    \"\"\"\n    # Case A: General informative views\n    Sigma_A = np.array([\n        [0.04, 0.006, 0.004],\n        [0.006, 0.09, 0.002],\n        [0.004, 0.002, 0.0225]\n    ])\n    w_m_A = np.array([0.6, 0.3, 0.1])\n    lambda_A = 2.5\n    tau_A = 0.05\n    P_A = np.array([\n        [1, -1, 0],\n        [0, 1, -1]\n    ])\n    Q_A = np.array([0.02, 0.01])\n    Omega_A = np.array([\n        [0.0004, 0],\n        [0, 0.0009]\n    ])\n\n    # Case B: No views edge case\n    Sigma_B = np.array([\n        [0.04, 0.006, 0.004],\n        [0.006, 0.09, 0.002],\n        [0.004, 0.002, 0.0225]\n    ])\n    w_m_B = np.array([0.6, 0.3, 0.1])\n    lambda_B = 2.5\n    tau_B = 0.05\n    # k=0 means P has 0 rows, Q and Omega are empty\n    P_B = np.empty((0, 3))\n    Q_B = np.empty((0,))\n    Omega_B = np.empty((0, 0))\n\n    # Case C: High-confidence single relative view\n    Sigma_C = np.array([\n        [0.05, 0.01, 0.0],\n        [0.01, 0.07, 0.005],\n        [0.0, 0.005, 0.03]\n    ])\n    w_m_C = np.array([0.4, 0.4, 0.2])\n    lambda_C = 3.0\n    tau_C = 0.1\n    P_C = np.array([[1, 0, -1]])\n    Q_C = np.array([0.05])\n    Omega_C = np.array([[1e-6]])\n\n    test_cases = [\n        (Sigma_A, w_m_A, lambda_A, tau_A, P_A, Q_A, Omega_A),\n        (Sigma_B, w_m_B, lambda_B, tau_B, P_B, Q_B, Omega_B),\n        (Sigma_C, w_m_C, lambda_C, tau_C, P_C, Q_C, Omega_C)\n    ]\n\n    results = []\n    for case in test_cases:\n        w_bl = calculate_bl_weights(*case)\n        # Round the numerical values to 6 decimal places\n        w_bl_rounded_list = np.round(w_bl, 6).tolist()\n        results.append(w_bl_rounded_list)\n\n    # Format the final output string exactly as required\n    # str() on a list of lists of floats and removing spaces is robust\n    output_string = str(results).replace(\" \", \"\")\n    print(output_string)\n\nsolve()\n```"}, {"introduction": "Having built the basic model, we now explore a more nuanced aspect: the art of formulating views. The Black-Litterman framework's power depends critically on how you translate qualitative beliefs into the quantitative inputs of the matrices $P$ and $Q$. This practice challenges you to investigate whether different mathematical representations of the same economic idea—such as an absolute versus a relative return forecast—lead to the same outcome, providing a crucial lesson in the sensitivity and precision required for real-world application [@problem_id:2376222].", "id": "2376222", "problem": "You will implement and analyze a Black-Litterman portfolio optimization under different view-encoding structures to test whether expressing the same economic belief as an absolute view versus a relative view changes the resulting optimal portfolio and by how much.\n\nStart from these fundamental bases:\n- Markowitz mean-variance optimality: For a given vector of expected excess returns $ \\mu \\in \\mathbb{R}^{n} $, covariance matrix $ \\Sigma \\in \\mathbb{R}^{n \\times n} $, and risk-aversion parameter $ \\lambda \\in \\mathbb{R}_{+} $, the mean-variance optimal weights are $ w^{\\star}(\\mu) = \\frac{1}{\\lambda} \\Sigma^{-1} \\mu $.\n- Reverse optimization for equilibrium implied returns: If the market capitalization weights are $ w^{mkt} \\in \\mathbb{R}^{n} $, the implied equilibrium expected excess returns are $ \\pi = \\lambda \\Sigma w^{mkt} $.\n- Bayesian updating under a multivariate normal prior and linear noisy observations: Assume the unknown expected excess return vector $ \\mu $ has a prior $ \\mu \\sim \\mathcal{N}(\\pi, \\tau \\Sigma) $ with $ \\tau \\in \\mathbb{R}_{+} $ and that linear views are modeled as $ P \\mu + \\varepsilon = q $ where $ P \\in \\mathbb{R}^{k \\times n} $, $ q \\in \\mathbb{R}^{k} $, and $ \\varepsilon \\sim \\mathcal{N}(0, \\Omega) $ with $ \\Omega \\in \\mathbb{R}^{k \\times k} $ symmetric positive definite. You must derive the posterior mean of $ \\mu $ and use it to compute the posterior optimal portfolio weights under mean-variance optimality.\n\nNumerical setup (all numbers are dimensionless and there are no physical units):\n- Number of assets $ n = 3 $.\n- Covariance matrix\n$$\n\\Sigma =\n\\begin{bmatrix}\n0.04 & 0.006 & 0.012 \\\\\n0.006 & 0.09 & 0.018 \\\\\n0.012 & 0.018 & 0.16\n\\end{bmatrix}.\n$$\n- Market capitalization weights $ w^{mkt} = [0.5, 0.3, 0.2]^{\\top} $.\n- Risk aversion $ \\lambda = 2.5 $.\n- Prior scaling $ \\tau = 0.05 $.\n- A single economic belief: “Asset $ 1 $ should have an expected excess return higher than its equilibrium implied value by $ \\Delta = 0.01 $,” i.e., a shift of $ 0.01 $ in the expected excess return of asset $ 1 $.\n\nViews and test suite:\nFor all views, construct the view covariance $ \\Omega $ as a diagonal matrix with entries equal to the model-implied variance of each view, that is, the $ i $-th diagonal element is the variance of the $ i $-th linear view under the prior $ \\mathcal{N}(\\pi, \\tau \\Sigma) $, computed as the $ i $-th diagonal entry of $ P (\\tau \\Sigma) P^{\\top} $. This ensures comparable confidence across different view parameterizations.\n\nDefine the following three test cases, each yielding an optimal Black-Litterman portfolio. You must compute $ \\pi $, then the posterior mean of $ \\mu $ given each view structure, and then the corresponding optimal weights $ w^{\\star} $.\n\n- Test case A (absolute view versus “relative-to-cash” view):\n  - Absolute view: $ P_{A,abs} = [1, 0, 0] $, $ q_{A,abs} = \\pi_{1} + \\Delta $.\n  - Relative-to-cash view: In an excess-return setting, cash corresponds to $ 0 $, so $ P_{A,rel} = [1, 0, 0] $, $ q_{A,rel} = \\pi_{1} + \\Delta $.\n  - Compute the Euclidean distance between the two resulting optimal weight vectors:\n    $$ d_{A} = \\lVert w^{\\star}_{A,abs} - w^{\\star}_{A,rel} \\rVert_{2}. $$\n\n- Test case B (absolute view versus relative-to-asset-$ 2 $ view):\n  - Absolute view: $ P_{B,abs} = [1, 0, 0] $, $ q_{B,abs} = \\pi_{1} + \\Delta $.\n  - Relative view to asset $ 2 $: $ P_{B,rel} = [1, -1, 0] $, and choose $ q_{B,rel} = (\\pi_{1} + \\Delta) - \\pi_{2} $ so that the target difference between assets $ 1 $ and $ 2 $ matches the difference implied by the absolute target for asset $ 1 $ when asset $ 2 $ remains at its prior mean.\n  - Compute the Euclidean distance:\n    $$ d_{B} = \\lVert w^{\\star}_{B,abs} - w^{\\star}_{B,rel} \\rVert_{2}. $$\n\n- Test case C (view duplication sensitivity):\n  - Single relative view to asset $ 2 $: $ P_{C,1} = [1, -1, 0] $, $ q_{C,1} = (\\pi_{1} + \\Delta) - \\pi_{2} $.\n  - Duplicated view (two identical rows): \n    $$\n    P_{C,2} =\n    \\begin{bmatrix}\n    1 & -1 & 0 \\\\\n    1 & -1 & 0\n    \\end{bmatrix}, \\quad\n    q_{C,2} =\n    \\begin{bmatrix}\n    (\\pi_{1} + \\Delta) - \\pi_{2} \\\\\n    (\\pi_{1} + \\Delta) - \\pi_{2}\n    \\end{bmatrix}.\n    $$\n    Use the same diagonal construction for $ \\Omega $ for each row. This duplication increases effective precision of the same linear belief.\n  - Compute the Euclidean distance between the resulting optimal weights:\n    $$ d_{C} = \\lVert w^{\\star}_{C,1} - w^{\\star}_{C,2} \\rVert_{2}. $$\n\nYour program must:\n1. Compute $ \\pi $ from the given $ \\Sigma $, $ \\lambda $, and $ w^{mkt} $.\n2. For each view specification, form $ \\Omega $ as described from $ P (\\tau \\Sigma) P^{\\top} $.\n3. Compute the posterior mean of $ \\mu $ under the normal-linear Bayesian update.\n4. Compute $ w^{\\star} = \\frac{1}{\\lambda} \\Sigma^{-1} \\mu_{post} $ for each case.\n5. Output a single line containing the list $ [d_{A}, d_{B}, d_{C}] $ where each $ d $ is a float rounded to eight decimal places.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., “[0.00000000,0.01234567,0.00123456]”).", "solution": "The problem requires an analysis of the Black-Litterman portfolio optimization model, specifically investigating the sensitivity of the resulting optimal portfolio weights to the formulation of an investor's view. The analysis will be performed by comparing portfolios derived from expressing the same economic belief in different mathematical forms: as an absolute view and as a relative view.\n\nThe theoretical foundation of this problem rests on two pillars: Markowitz mean-variance optimization and the Black-Litterman model for deriving expected returns.\n\nFirst, the Markowitz model posits that for a given vector of expected excess returns $ \\mu \\in \\mathbb{R}^{n} $, an asset covariance matrix $ \\Sigma \\in \\mathbb{R}^{n \\times n} $, and a scalar risk-aversion parameter $ \\lambda > 0 $, the optimal portfolio weights $ w^{\\star} $ that maximize the utility function $ U(w) = w^{\\top}\\mu - \\frac{\\lambda}{2}w^{\\top}\\Sigma w $ are given by:\n$$\nw^{\\star}(\\mu) = \\frac{1}{\\lambda} \\Sigma^{-1} \\mu\n$$\n\nSecond, the Black-Litterman model provides a Bayesian framework to determine the expected returns vector $ \\mu $. It starts by reverse-engineering the market's consensus expectations from observable market capitalization weights, $ w^{mkt} $. These are termed the implied equilibrium returns, $ \\pi $, calculated as:\n$$\n\\pi = \\lambda \\Sigma w^{mkt}\n$$\nThese equilibrium returns serve as the center of a prior distribution for the unknown true expected returns $ \\mu $. The prior is assumed to be a multivariate normal distribution:\n$$\n\\mu \\sim \\mathcal{N}(\\pi, \\tau\\Sigma)\n$$\nwhere $ \\tau \\in \\mathbb{R}_{+} $ is a scaling factor that controls the confidence in the prior mean $ \\pi $. A smaller $ \\tau $ indicates higher confidence.\n\nThe investor's private views are expressed as a set of $ k $ linear equations, incorporating uncertainty:\n$$\nP \\mu + \\varepsilon = q\n$$\nHere, $ P \\in \\mathbb{R}^{k \\times n} $ is the \"pick\" or \"view\" matrix, which identifies the assets involved in each view. The vector $ q \\in \\mathbb{R}^{k} $ contains the expected outcomes for these linear combinations. The term $ \\varepsilon \\sim \\mathcal{N}(0, \\Omega) $ represents the uncertainty in the views, with $ \\Omega \\in \\mathbb{R}^{k \\times k} $ being the covariance matrix of the view errors.\n\nTo obtain the posterior distribution of $ \\mu $, we combine the prior distribution with the likelihood function derived from the views using Bayes' theorem. For multivariate normal distributions, the posterior is also normal. The posterior mean, $ \\mu_{post} $, is derived by minimizing the sum of squared Mahalanobis distances corresponding to the negative log-likelihoods of the prior and the view model:\n$$\nL(\\mu) = (\\mu - \\pi)^{\\top}(\\tau\\Sigma)^{-1}(\\mu - \\pi) + (q - P\\mu)^{\\top}\\Omega^{-1}(q - P\\mu)\n$$\nTaking the derivative with respect to $ \\mu $ and setting it to zero yields:\n$$\n\\frac{\\partial L}{\\partial \\mu} = 2(\\tau\\Sigma)^{-1}(\\mu - \\pi) - 2P^{\\top}\\Omega^{-1}(q - P\\mu) = 0\n$$\n$$\n\\left( (\\tau\\Sigma)^{-1} + P^{\\top}\\Omega^{-1}P \\right) \\mu = (\\tau\\Sigma)^{-1}\\pi + P^{\\top}\\Omega^{-1}q\n$$\nSolving for $ \\mu $ gives the posterior mean of the expected returns:\n$$\n\\mu_{post} = \\left( (\\tau\\Sigma)^{-1} + P^{\\top}\\Omega^{-1}P \\right)^{-1} \\left( (\\tau\\Sigma)^{-1}\\pi + P^{\\top}\\Omega^{-1}q \\right)\n$$\nThis posterior mean $ \\mu_{post} $ represents a sophisticated blend of market equilibrium and the investor's specific views. It is then used in the Markowitz formula to compute the final Black-Litterman optimal portfolio weights:\n$$\nw^{\\star}_{BL} = \\frac{1}{\\lambda} \\Sigma^{-1} \\mu_{post}\n$$\nThe problem specifies a particular method for constructing the view uncertainty matrix $ \\Omega $: it is a diagonal matrix where the $ i $-th diagonal element is the variance of the $ i $-th view as implied by the prior distribution. This variance is calculated as the $ i $-th diagonal element of the matrix $ P(\\tau\\Sigma)P^{\\top} $.\n\nThe computational procedure is as follows:\n1.  Using the provided numerical values for $ \\lambda $, $ \\Sigma $, and $ w^{mkt} $, we first compute the implied equilibrium returns vector $ \\pi $.\n2.  For each test case, we construct the specific $ P $ and $ q $ matrices/vectors that encode the view.\n3.  We then construct the view covariance matrix $ \\Omega $ for each view structure, as specified.\n4.  Using the derived formula, we compute the posterior expected returns $ \\mu_{post} $ for each scenario.\n5.  We then calculate the corresponding optimal portfolio weights $ w^{\\star} $ for each scenario.\n6.  Finally, we compute the Euclidean distances $ d_A, d_B, d_C $ between the relevant pairs of weight vectors.\n\n**Test Case A**: This case compares an absolute view on asset $ 1 $ with a \"relative-to-cash\" view. In an excess return framework, the return on cash is zero. Therefore, a view on the excess return of an asset is inherently relative to cash. The mathematical formulations for both scenarios are identical: $ P = [1, 0, 0] $ and $ q = \\pi_1 + \\Delta $. Consequently, the resulting posterior returns and portfolio weights must be identical, leading to an expected distance $ d_A = 0 $. This serves as a consistency check.\n\n**Test Case B**: This case contrasts an absolute view on asset $ 1 $ ($ P_{abs} = [1, 0, 0] $) with a relative view involving asset $ 1 $ and asset $ 2 $ ($ P_{rel} = [1, -1, 0] $). The target for the relative view, $ q_{rel} $, is set to be consistent with the absolute view under the assumption that asset $ 2 $'s expected return remains at its prior mean. Despite this consistency in the economic idea, the mathematical structures are different ($ P_{abs} \\neq P_{rel} $). This will lead to different $ \\Omega $ matrices and different posterior updates, resulting in different optimal portfolios. The distance $ d_B $ will quantify this difference.\n\n**Test Case C**: This case examines the effect of view duplication. We compare the portfolio from a single relative view (identical to the relative view in Case B) against a portfolio where the same view is stated twice. By constructing $ P $ with two identical rows and $ q $ with two identical entries, and using the specified diagonal construction for $ \\Omega $, we are effectively increasing the confidence in that single economic belief. The term $ P^{\\top}\\Omega^{-1}P $ in the posterior mean formula will be larger for the duplicated case, pulling the posterior mean more strongly towards the view. The distance $ d_C $ will measure the portfolio's shift due to this increased confidence.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements the Black-Litterman model to analyze portfolio sensitivity\n    to different view formulations.\n    \"\"\"\n    # Numerical setup from the problem statement\n    n = 3\n    Sigma = np.array([\n        [0.04, 0.006, 0.012],\n        [0.006, 0.09, 0.018],\n        [0.012, 0.018, 0.16]\n    ])\n    w_mkt = np.array([0.5, 0.3, 0.2])\n    lam = 2.5\n    tau = 0.05\n    Delta = 0.01\n\n    # Pre-compute matrices that are used repeatedly\n    Sigma_inv = np.linalg.inv(Sigma)\n    tau_Sigma = tau * Sigma\n    tau_Sigma_inv = np.linalg.inv(tau_Sigma)\n\n    # Step 1: Compute implied equilibrium returns (pi)\n    pi = lam * Sigma @ w_mkt\n\n    def compute_bl_weights(P, q, pi_vec, tau_Sigma_mat, tau_Sigma_inv_mat, Sigma_inv_mat, lam_val):\n        \"\"\"\n        Computes the Black-Litterman optimal portfolio weights for a given set of views.\n        Args:\n            P (np.ndarray): The view matrix (k x n).\n            q (np.ndarray): The view outcomes vector (k,).\n            pi_vec (np.ndarray): The equilibrium returns vector (n,).\n            tau_Sigma_mat (np.ndarray): The scaled prior covariance matrix (n x n).\n            tau_Sigma_inv_mat (np.ndarray): The inverse of tau_Sigma_mat (n x n).\n            Sigma_inv_mat (np.ndarray): The inverse asset covariance matrix (n x n).\n            lam_val (float): The risk aversion parameter.\n        Returns:\n            np.ndarray: The optimal portfolio weights vector (n,).\n        \"\"\"\n        # Ensure P is 2D\n        if P.ndim == 1:\n            P = P.reshape(1, -1)\n        \n        # Ensure q is 1D\n        if q.ndim > 1:\n            q = q.flatten()\n\n        # Step 2: Construct the view covariance Omega\n        # Omega is a diagonal matrix with diagonal elements from P * (tau*Sigma) * P.T\n        view_var_cov = P @ tau_Sigma_mat @ P.T\n        Omega_diag = np.diag(view_var_cov)\n        Omega = np.diag(Omega_diag)\n        Omega_inv = np.linalg.inv(Omega)\n\n        # Step 3: Compute the posterior mean of mu\n        # Formula: mu_post = inv(inv(tau*Sigma) + P.T*inv(Omega)*P) * (inv(tau*Sigma)*pi + P.T*inv(Omega)*q)\n        posterior_precision = tau_Sigma_inv_mat + P.T @ Omega_inv @ P\n        posterior_covariance = np.linalg.inv(posterior_precision)\n        \n        rhs_vector = tau_Sigma_inv_mat @ pi_vec + P.T @ Omega_inv @ q\n        \n        mu_post = posterior_covariance @ rhs_vector\n\n        # Step 4: Compute the optimal portfolio weights\n        w_star = (1 / lam_val) * Sigma_inv_mat @ mu_post\n        \n        return w_star\n\n    # ----- Test Case A -----\n    # Absolute view\n    P_A_abs = np.array([1, 0, 0])\n    q_A_abs = np.array([pi[0] + Delta])\n    w_A_abs = compute_bl_weights(P_A_abs, q_A_abs, pi, tau_Sigma, tau_Sigma_inv, Sigma_inv, lam)\n    \n    # Relative-to-cash view (mathematically identical to absolute view in this context)\n    P_A_rel = np.array([1, 0, 0])\n    q_A_rel = np.array([pi[0] + Delta])\n    w_A_rel = compute_bl_weights(P_A_rel, q_A_rel, pi, tau_Sigma, tau_Sigma_inv, Sigma_inv, lam)\n\n    d_A = np.linalg.norm(w_A_abs - w_A_rel)\n\n    # ----- Test Case B -----\n    # Absolute view (same as w_A_abs)\n    w_B_abs = w_A_abs\n    \n    # Relative view to asset 2\n    P_B_rel = np.array([1, -1, 0])\n    q_B_rel_val = (pi[0] + Delta) - pi[1]\n    q_B_rel = np.array([q_B_rel_val])\n    w_B_rel = compute_bl_weights(P_B_rel, q_B_rel, pi, tau_Sigma, tau_Sigma_inv, Sigma_inv, lam)\n\n    d_B = np.linalg.norm(w_B_abs - w_B_rel)\n    \n    # ----- Test Case C -----\n    # Single relative view (same as w_B_rel)\n    w_C_1 = w_B_rel\n\n    # Duplicated relative view\n    P_C_2 = np.array([[1, -1, 0], [1, -1, 0]])\n    q_C_2 = np.array([q_B_rel_val, q_B_rel_val])\n    w_C_2 = compute_bl_weights(P_C_2, q_C_2, pi, tau_Sigma, tau_Sigma_inv, Sigma_inv, lam)\n    \n    d_C = np.linalg.norm(w_C_1 - w_C_2)\n\n    # Final output formatting\n    results = [round(d, 8) for d in [d_A, d_B, d_C]]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"}, {"introduction": "In our final practice, we flip the problem on its head to demonstrate the model's power as an analytical tool. Instead of constructing a portfolio from a set of known views, you will learn to reverse-engineer the views implied by an existing portfolio's structure. This \"reverse Black-Litterman\" technique provides you with a lens to analyze the strategies of portfolio managers or the expectations priced into the market itself, a skill invaluable for any quantitative analyst [@problem_id:2376249].", "id": "2376249", "problem": "You are given a stylized setting for Black-Litterman (BL) portfolio optimization, in which a manager’s reported portfolio weights are assumed to be the exact mean-variance optimal solution under some posterior expected excess returns that result from combining a market-based prior with linear views. Your task is to derive the manager’s “implied view” vector that would rationalize the observed weights under the Black-Litterman model, and implement the derivation as a complete, runnable program that computes these implied views for a small test suite.\n\nStart from the following foundational base:\n- Mean-variance optimization with a risk-free asset: The optimal risky portfolio weights $w$ maximize $U(w) = w^{\\top} \\mu - \\frac{\\lambda}{2} w^{\\top} \\Sigma w$, where $w$ are portfolio weights on $n$ risky assets, $\\mu$ is the vector of expected excess returns, $\\Sigma$ is the symmetric positive definite covariance matrix of excess returns, and $\\lambda &gt; 0$ is the risk-aversion coefficient. Use the first-order optimality condition to relate $w$, $\\mu$, $\\Sigma$, and $\\lambda$.\n- Market equilibrium prior: The market-capitalization-weighted portfolio $w^{\\text{mkt}}$ is assumed to be the mean-variance optimal risky portfolio for the prior expected excess returns $\\pi$, given the same $\\Sigma$ and $\\lambda$.\n- Black-Litterman (BL) linear-Gaussian view structure: Prior $r \\sim \\mathcal{N}(\\pi, \\tau \\Sigma)$, where $\\tau &gt; 0$ is a scalar, and views $P r \\sim \\mathcal{N}(Q, \\Omega)$, where $P$ is the $k \\times n$ view-matrix, $Q$ is the $k \\times 1$ view vector to be determined, and $\\Omega$ is the symmetric positive definite $k \\times k$ view error covariance.\n\nAssume the manager’s reported weights $w^{\\text{mgr}}$ are exactly optimal for mean-variance with respect to the BL posterior mean of excess returns. Derive an explicit expression for the implied view vector $Q$ that is consistent with the observed $w^{\\text{mgr}}$ and the specified model inputs. Your derivation must proceed from the base principles listed above, without using any shortcut formulas that assume knowledge of the Black-Litterman posterior in closed form.\n\nThen, implement a program that computes the implied views $Q$ for each test case specified below. All returns must be treated as excess returns and expressed as decimals (not percentages). Angles do not appear, so no angle unit is required. No physical units appear.\n\nFor all test cases, use $n = 3$ assets and $k = 3$ absolute views with $P = I_3$, the $3 \\times 3$ identity matrix. The covariance matrix $\\Sigma$ is the same across cases:\n- $\\Sigma = \\begin{bmatrix}\n0.040 & 0.018 & 0.012 \\\\\n0.018 & 0.035 & 0.015 \\\\\n0.012 & 0.015 & 0.030\n\\end{bmatrix}$\n\nThe market-capitalization weights are the same across cases:\n- $w^{\\text{mkt}} = \\begin{bmatrix} 0.5 \\\\ 0.3 \\\\ 0.2 \\end{bmatrix}$\n\nFor each case, you are given the manager’s observed weights $w^{\\text{mgr}}$, the risk aversion $\\lambda$, the scalar $\\tau$, and the diagonal entries of $\\Omega$.\n\nTest Suite (three cases):\n- Case 1 (general happy path):\n  - $w^{\\text{mgr}} = \\begin{bmatrix} 0.3 \\\\ 0.4 \\\\ 0.3 \\end{bmatrix}$, $\\lambda = 2.5$, $\\tau = 0.05$, $\\Omega = \\operatorname{diag}(0.01, 0.02, 0.03)$.\n- Case 2 (boundary on $\\tau$ small):\n  - $w^{\\text{mgr}} = \\begin{bmatrix} 0.6 \\\\ 0.2 \\\\ 0.2 \\end{bmatrix}$, $\\lambda = 2.5$, $\\tau = 0.001$, $\\Omega = \\operatorname{diag}(0.02, 0.02, 0.02)$.\n- Case 3 (boundary on large $\\Omega$):\n  - $w^{\\text{mgr}} = \\begin{bmatrix} 0.2 \\\\ 0.5 \\\\ 0.3 \\end{bmatrix}$, $\\lambda = 2.5$, $\\tau = 0.05$, $\\Omega = \\operatorname{diag}(0.2, 0.15, 0.25)$.\n\nWhat to compute for each case:\n1. Using the mean-variance first-order condition, compute the equilibrium prior expected excess returns $\\pi$ from $w^{\\text{mkt}}$, $\\Sigma$, and $\\lambda$.\n2. Using the same first-order condition, compute the posterior-optimizing expected excess returns $\\mu^{\\star}$ implied by $w^{\\text{mgr}}$, $\\Sigma$, and $\\lambda$.\n3. Using the Black-Litterman linear-Gaussian framework with $P = I_3$, $\\tau$, and $\\Omega$, derive and compute the implied absolute-view vector $Q$ that would produce the posterior mean $\\mu^{\\star}$.\n\nFinal Output Format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets.\n- For each case, output the three entries of the corresponding implied view vector $Q$ in order; concatenate the three cases in the order Case 1, Case 2, Case 3.\n- Round each floating-point result to exactly six decimal places before printing.\n- Example of structure (not actual values): [$q_{1,1}$,$q_{1,2}$,$q_{1,3}$,$q_{2,1}$,$q_{2,2}$,$q_{2,3}$,$q_{3,1}$,$q_{3,2}$,$q_{3,3}$].\n\nYour submission must be a complete, runnable program that computes these nine numbers with the specified rounding and prints them exactly in the described single-line format.", "solution": "The problem statement has been analyzed and is deemed valid. It is scientifically grounded in established principles of computational finance, specifically mean-variance portfolio optimization and the Black-Litterman model. The problem is well-posed, with sufficient data and consistent constraints to permit a unique solution. All terms are defined with sufficient mathematical rigor.\n\nThe task is to derive the manager's implied view vector, $Q$, that rationalizes an observed portfolio, $w^{\\text{mgr}}$. The derivation will proceed from the foundational principles specified.\n\n**Step 1: Derivation of the Mean-Variance First-Order Condition**\n\nThe optimization problem for an investor is to select portfolio weights $w$ to maximize the utility function $U(w)$:\n$$ \\max_{w} U(w) = w^{\\top} \\mu - \\frac{\\lambda}{2} w^{\\top} \\Sigma w $$\nHere, $w$ is the $n \\times 1$ vector of portfolio weights in risky assets, $\\mu$ is the $n \\times 1$ vector of expected excess returns, $\\Sigma$ is the $n \\times n$ covariance matrix of excess returns (symmetric and positive definite), and $\\lambda > 0$ is the scalar coefficient of risk aversion.\n\nTo find the optimal weights, we compute the gradient of $U(w)$ with respect to $w$ and set it to zero. Using standard matrix calculus, the first-order condition (FOC) is:\n$$ \\frac{\\partial U(w)}{\\partial w} = \\mu - \\lambda \\Sigma w = 0 $$\nThis yields the fundamental relationship between expected excess returns and the optimal portfolio weights:\n$$ \\mu = \\lambda \\Sigma w $$\nThis equation allows one to determine the expected returns that would make a given portfolio $w$ optimal. This is often referred to as \"reverse optimization\".\n\n**Step 2: Computation of Implied Prior and Posterior Returns**\n\nThe problem posits two applications of this reverse optimization principle.\n\nFirst, the market equilibrium prior returns, denoted $\\pi$, are those returns for which the market-capitalization portfolio $w^{\\text{mkt}}$ is optimal. Applying the FOC:\n$$ \\pi = \\lambda \\Sigma w^{\\text{mkt}} $$\n\nSecond, the manager's observed portfolio, $w^{\\text{mgr}}$, is assumed to be optimal with respect to the Black-Litterman posterior expected returns, which we denote $\\mu^{\\star}$. Therefore:\n$$ \\mu^{\\star} = \\lambda \\Sigma w^{\\text{mgr}} $$\n\n**Step 3: Derivation of the Implied View Vector $Q$**\n\nThe Black-Litterman model provides a formula for the posterior mean expected returns, $\\mu^{\\text{BL}}$, by combining the prior distribution of returns, $r \\sim \\mathcal{N}(\\pi, \\tau \\Sigma)$, with a set of linear views, $P r \\sim \\mathcal{N}(Q, \\Omega)$. The formula for the posterior mean is the result of Bayesian inference:\n$$ \\mu^{\\text{BL}} = \\left[ (\\tau \\Sigma)^{-1} + P^{\\top} \\Omega^{-1} P \\right]^{-1} \\left[ (\\tau \\Sigma)^{-1} \\pi + P^{\\top} \\Omega^{-1} Q \\right] $$\nWe are given that the manager's implied returns $\\mu^{\\star}$ are equal to the BL posterior mean, so $\\mu^{\\star} = \\mu^{\\text{BL}}$. Our objective is to solve for the view vector $Q$.\n\nLet us rearrange the equation:\n$$ \\left[ (\\tau \\Sigma)^{-1} + P^{\\top} \\Omega^{-1} P \\right] \\mu^{\\star} = (\\tau \\Sigma)^{-1} \\pi + P^{\\top} \\Omega^{-1} Q $$\nIsolating the term containing $Q$:\n$$ P^{\\top} \\Omega^{-1} Q = \\left[ (\\tau \\Sigma)^{-1} + P^{\\top} \\Omega^{-1} P \\right] \\mu^{\\star} - (\\tau \\Sigma)^{-1} \\pi $$\nDistributing $\\mu^{\\star}$ on the right-hand side:\n$$ P^{\\top} \\Omega^{-1} Q = (\\tau \\Sigma)^{-1} \\mu^{\\star} + P^{\\top} \\Omega^{-1} P \\mu^{\\star} - (\\tau \\Sigma)^{-1} \\pi $$\nGrouping terms:\n$$ P^{\\top} \\Omega^{-1} Q = (\\tau \\Sigma)^{-1} (\\mu^{\\star} - \\pi) + P^{\\top} \\Omega^{-1} P \\mu^{\\star} $$\nThe problem specifies that there are $k=n=3$ absolute views, such that the view matrix $P$ is the $3 \\times 3$ identity matrix, $P = I_3$. As $P$ is the identity matrix, it is its own inverse and its own transpose, i.e., $P = P^{\\top} = P^{-1} = I_n$. Substituting $P = I_n$ and $P^{\\top} = I_n$ simplifies the equation significantly:\n$$ I_n^{\\top} \\Omega^{-1} Q = (\\tau \\Sigma)^{-1} (\\mu^{\\star} - \\pi) + I_n^{\\top} \\Omega^{-1} I_n \\mu^{\\star} $$\n$$ \\Omega^{-1} Q = (\\tau \\Sigma)^{-1} (\\mu^{\\star} - \\pi) + \\Omega^{-1} \\mu^{\\star} $$\nTo solve for $Q$, we pre-multiply both sides by $\\Omega$. Since $\\Omega$ is specified as symmetric positive definite, its inverse $\\Omega^{-1}$ exists.\n$$ Q = \\Omega \\left[ (\\tau \\Sigma)^{-1} (\\mu^{\\star} - \\pi) + \\Omega^{-1} \\mu^{\\star} \\right] $$\n$$ Q = \\Omega (\\tau \\Sigma)^{-1} (\\mu^{\\star} - \\pi) + \\Omega \\Omega^{-1} \\mu^{\\star} $$\nSimplifying, we arrive at the final expression for the implied view vector $Q$:\n$$ Q = \\mu^{\\star} + \\frac{1}{\\tau} \\Omega \\Sigma^{-1} (\\mu^{\\star} - \\pi) $$\n\n**Summary of Computational Procedure**\n\nFor each test case, with given parameters $\\{\\Sigma, w^{\\text{mkt}}, w^{\\text{mgr}}, \\lambda, \\tau, \\Omega\\}$, the following steps are executed:\n1.  Compute the market-implied prior returns: $\\pi = \\lambda \\Sigma w^{\\text{mkt}}$.\n2.  Compute the manager-implied posterior returns: $\\mu^{\\star} = \\lambda \\Sigma w^{\\text{mgr}}$.\n3.  Compute the inverse of the covariance matrix, $\\Sigma^{-1}$.\n4.  Compute the implied view vector $Q$ using the derived formula: $Q = \\mu^{\\star} + \\frac{1}{\\tau} \\Omega \\Sigma^{-1} (\\mu^{\\star} - \\pi)$.\n\nThis procedure will be implemented to solve for $Q$ for the specified test cases.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the implied view vector Q in the Black-Litterman model for three test cases.\n    \"\"\"\n    \n    # Common parameters for all test cases\n    Sigma = np.array([\n        [0.040, 0.018, 0.012],\n        [0.018, 0.035, 0.015],\n        [0.012, 0.015, 0.030]\n    ])\n    \n    w_mkt = np.array([0.5, 0.3, 0.2])\n    \n    # Test suite: (w_mgr, lambda, tau, Omega_diag)\n    test_cases = [\n        (np.array([0.3, 0.4, 0.3]), 2.5, 0.05, np.array([0.01, 0.02, 0.03])),\n        (np.array([0.6, 0.2, 0.2]), 2.5, 0.001, np.array([0.02, 0.02, 0.02])),\n        (np.array([0.2, 0.5, 0.3]), 2.5, 0.05, np.array([0.2, 0.15, 0.25]))\n    ]\n\n    all_q_values = []\n\n    # Pre-compute inverse of Sigma as it is constant\n    Sigma_inv = np.linalg.inv(Sigma)\n\n    for case in test_cases:\n        w_mgr, lambda_val, tau, Omega_diag = case\n        \n        # Build the diagonal Omega matrix\n        Omega = np.diag(Omega_diag)\n        \n        # Step 1: Compute equilibrium prior expected excess returns (pi)\n        # pi = lambda * Sigma * w_mkt\n        pi = lambda_val * (Sigma @ w_mkt)\n        \n        # Step 2: Compute posterior-optimizing expected excess returns (mu_star)\n        # mu_star = lambda * Sigma * w_mgr\n        mu_star = lambda_val * (Sigma @ w_mgr)\n        \n        # Step 3: Compute the implied absolute-view vector (Q)\n        # Q = mu_star + (1/tau) * Omega * Sigma_inv * (mu_star - pi)\n        mu_diff = mu_star - pi\n        adjustment_term = (1 / tau) * (Omega @ Sigma_inv @ mu_diff)\n        Q = mu_star + adjustment_term\n        \n        all_q_values.extend(Q)\n\n    # Format the final output string with 6 decimal places for each value\n    results_str = [f\"{val:.6f}\" for val in all_q_values]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```"}]}