{"hands_on_practices": [{"introduction": "The Heston model's primary contribution is its ability to generate \"fat-tailed\" return distributions, a feature consistently observed in financial markets but absent in simpler models like Black-Scholes. This practice guides you through simulating log-returns from the Heston model to directly observe this phenomenon [@problem_id:2441188]. By implementing a formal statistical test for excess kurtosis, you will gain a concrete understanding of how stochastic volatility shapes the statistical properties of asset returns.", "id": "2441188", "problem": "You are asked to design and implement a complete, runnable program to test a statistical hypothesis about the tail thickness of log-returns generated by the Heston stochastic volatility model. The starting point is the Heston system of stochastic differential equations for a risky asset price process $\\{S_t\\}_{t \\ge 0}$ and its instantaneous variance process $\\{v_t\\}_{t \\ge 0}$:\n$$\ndS_t = \\mu S_t \\, dt + \\sqrt{v_t}\\, S_t \\, dW_t^{(1)}, \\qquad\ndv_t = \\kappa(\\theta - v_t)\\, dt + \\sigma \\sqrt{v_t}\\, dW_t^{(2)},\n$$\nwith instantaneous correlation $\\mathrm{corr}(dW_t^{(1)}, dW_t^{(2)}) = \\rho$. In this problem, set the drift to $\\mu = 0$ to isolate tail behavior and avoid confounding from drift. Work with a single time-step horizon of length $\\Delta t > 0$ and define the one-step log-return as $r = \\log(S_{t+\\Delta t}/S_t)$. For small $\\Delta t$, use the leading-order discretization implied by Itô calculus that, conditional on $v_t$, the log-return $r$ is approximately normal:\n$$\nr \\mid v_t \\sim \\mathcal{N}\\!\\left(-\\tfrac{1}{2} v_t \\Delta t,\\; v_t \\Delta t\\right).\n$$\n\nYour simulation must generate an independent and identically distributed sample $\\{r_i\\}_{i=1}^n$ of one-step log-returns by sampling the instantaneous variance $v$ from the stationary distribution of the Cox–Ingersoll–Ross (CIR) process that drives $v_t$. A well-tested and widely used fact is that when $\\kappa > 0$, the stationary distribution of $v_t$ is Gamma with shape parameter $k = \\frac{2\\kappa\\theta}{\\sigma^2}$ and scale parameter $b = \\frac{\\sigma^2}{2\\kappa}$, which yields $\\mathbb{E}[v] = k b = \\theta$. In the special case $\\sigma = 0$, treat $v$ as degenerate at $v = \\theta$ (constant variance). You may assume $\\rho$ does not affect the one-step marginal distribution of $r$ conditional on $v$ and therefore does not enter the sampling scheme for $r$ in this setup.\n\nFormulate and implement a one-sided hypothesis test at significance level $\\alpha = 0.05$ to assess whether the simulated distribution of log-returns exhibits higher kurtosis (fatter tails) than a normal distribution with the same variance. Use the following principle-based test grounded in classical asymptotic theory: under the null hypothesis that $r$ is normally distributed with variance equal to the sample variance of $\\{r_i\\}_{i=1}^n$, the sample excess kurtosis\n$$\ng_2 = \\frac{m_4}{m_2^2} - 3, \\quad m_j = \\frac{1}{n}\\sum_{i=1}^n (r_i - \\bar{r})^j,\\quad \\bar{r} = \\frac{1}{n}\\sum_{i=1}^n r_i,\n$$\nhas asymptotic standard deviation $\\sqrt{\\frac{24}{n}}$ for large $n$. Construct the $z$-statistic\n$$\nz = \\frac{g_2 - 0}{\\sqrt{24/n}},\n$$\nand reject the null hypothesis in favor of the alternative of higher kurtosis if $z > z_{1-\\alpha}$, where $z_{1-\\alpha}$ is the $(1-\\alpha)$-quantile of the standard normal distribution.\n\nImplement the simulation and test as described, using the stationary Gamma sampling scheme for $v$ and the conditional normal sampling for $r$ given $v$. To ensure reproducibility and independence across test cases, seed the random number generator separately for each case.\n\nUse the following test suite with four parameter sets, each specified as a tuple $(\\text{seed}, \\kappa, \\theta, \\sigma, \\Delta t, n)$:\n- Case A (boundary case with constant variance): $(12345, 2.0, 0.04, 0.0, 1.0, 200000)$.\n- Case B (high volatility of volatility; expected fatter tails): $(12346, 2.0, 0.04, 1.0, 1.0, 200000)$.\n- Case C (moderate volatility of volatility but small sample size; low power edge case): $(12347, 1.5, 0.04, 0.5, 1.0, 2000)$.\n- Case D (fast mean-reversion and small volatility of volatility; closer to normal): $(12348, 5.0, 0.04, 0.1, 1.0, 50000)$.\n\nYour program must, for each case, output a boolean indicating whether the null hypothesis is rejected at level $\\alpha = 0.05$ using the test described above. The final output must be a single line containing the list of booleans for the four cases in order, formatted exactly as a comma-separated Python-style list in a single line, for example: \"[True,False,True,False]\".\n\nNo physical units or angles are involved. Express all numerical probabilities as decimals, not as percentages. The random number generator seeds must be set exactly to the provided integer values for each case to guarantee reproducibility. Do not read any input; all parameters are hard-coded as above.", "solution": "The problem requires the design and implementation of a statistical test to determine if the distribution of log-returns, generated under the Heston stochastic volatility model, exhibits fatter tails (leptokurtosis) than a Gaussian distribution. This task is accomplished by simulating data according to the model's specified dynamics and then applying an asymptotically-justified hypothesis test for excess kurtosis.\n\nThe theoretical framework is the Heston model, described by a system of two stochastic differential equations for an asset's price $S_t$ and its instantaneous variance $v_t$:\n$$\ndS_t = \\mu S_t \\, dt + \\sqrt{v_t}\\, S_t \\, dW_t^{(1)}\n$$\n$$\ndv_t = \\kappa(\\theta - v_t)\\, dt + \\sigma \\sqrt{v_t}\\, dW_t^{(2)}\n$$\nHere, $W_t^{(1)}$ and $W_t^{(2)}$ are Wiener processes with an instantaneous correlation $\\rho$. For the purposes of this problem, the drift parameter of the asset price is set to $\\mu = 0$ to isolate the effects of stochastic volatility on the return distribution's shape. We consider the one-step log-return, defined as $r = \\log(S_{t+\\Delta t}/S_t)$ over a time horizon of length $\\Delta t$. Using a first-order approximation derived from Itô's lemma, the conditional distribution of the log-return, given the variance $v_t$ at the start of the interval, is normal:\n$$\nr \\mid v_t \\sim \\mathcal{N}\\!\\left(-\\tfrac{1}{2} v_t \\Delta t,\\; v_t \\Delta t\\right)\n$$\nThe simulation procedure generates an independent and identically distributed (i.i.d.) sample $\\{r_i\\}_{i=1}^n$. This is achieved by first sampling the variance, $v_i$, from the stationary distribution of the Cox–Ingersoll–Ross (CIR) process that governs $v_t$. For parameters $\\kappa > 0$ and $\\theta > 0$, this stationary distribution is a Gamma distribution. The shape parameter is $k = \\frac{2\\kappa\\theta}{\\sigma^2}$ and the scale parameter is $b = \\frac{\\sigma^2}{2\\kappa}$. The mean of this distribution is $\\mathbb{E}[v] = k b = \\theta$. A special case is defined for $\\sigma = 0$, where the variance process is deterministic, and thus $v$ is a constant equal to its mean, $\\theta$. For each simulated variance $v_i$, a corresponding log-return $r_i$ is then drawn from the conditional normal distribution specified above. This two-step generation process—sampling from a mixture distribution for variance and subsequently sampling from a conditional normal distribution—is what induces non-normal characteristics, specifically leptokurtosis, in the marginal distribution of $r$.\n\nThe hypothesis test is designed to statistically detect this leptokurtosis. The null hypothesis, $H_0$, is that the sample of log-returns $\\{r_i\\}_{i=1}^n$ is drawn from a normal distribution. The alternative hypothesis, $H_1$, is that the distribution has a higher kurtosis than a normal distribution (i.e., is leptokurtic, or has \"fatter tails\"). The test is conducted at a significance level of $\\alpha = 0.05$. The test statistic is based on the sample excess kurtosis, $g_2$, defined as:\n$$\ng_2 = \\frac{m_4}{m_2^2} - 3\n$$\nwhere $m_j$ is the $j$-th sample central moment, $m_j = \\frac{1}{n}\\sum_{i=1}^n (r_i - \\bar{r})^j$, with $\\bar{r}$ being the sample mean. For a true normal distribution, the population excess kurtosis is $0$. Under the null hypothesis of normality, for a large sample size $n$, the sampling distribution of $g_2$ is asymptotically normal with a mean of $0$ and a standard deviation of $\\sqrt{24/n}$. This property allows for the construction of a standardized $z$-statistic:\n$$\nz = \\frac{g_2 - 0}{\\sqrt{24/n}}\n$$\nFor a one-sided test against the alternative of positive excess kurtosis, we reject the null hypothesis $H_0$ if the observed $z$-statistic is greater than the critical value $z_{1-\\alpha}$, which is the $(1-\\alpha)$-quantile of the standard normal distribution. For $\\alpha = 0.05$, the critical value is $z_{0.95} \\approx 1.64485$.\n\nThe implementation will proceed by generating samples for each of the four specified test cases. For each case, the random number generator is seeded with the provided value to ensure reproducibility. The parameters $(\\kappa, \\theta, \\sigma, \\Delta t, n)$ dictate the simulation details. The special case $\\sigma=0$ is handled by setting the variance to a constant value of $\\theta$. For $\\sigma > 0$, variances are drawn from the corresponding Gamma distribution. Subsequently, log-returns are generated, the $z$-statistic is computed, and the decision to reject or not reject $H_0$ is made by comparing the statistic to $z_{0.95}$. The boolean outcome of this decision for each case is then recorded and reported as specified.", "answer": "```python\nimport numpy as np\nfrom scipy.stats import norm\n\ndef run_heston_kurtosis_test(seed, kappa, theta, sigma, delta_t, n):\n    \"\"\"\n    Simulates Heston model log-returns and tests for excess kurtosis.\n\n    Args:\n        seed (int): The seed for the random number generator.\n        kappa (float): The rate of mean reversion for the variance process.\n        theta (float): The long-run mean of the variance process.\n        sigma (float): The volatility of the variance process.\n        delta_t (float): The time step for the log-return.\n        n (int): The number of samples to generate.\n\n    Returns:\n        bool: True if the null hypothesis of normality is rejected in favor of\n              higher kurtosis, False otherwise.\n    \"\"\"\n    # Initialize a random number generator with the given seed for reproducibility.\n    # Using PCG64 is the modern, recommended practice.\n    rng = np.random.Generator(np.random.PCG64(seed))\n\n    # Step 1: Generate the variance sample {v_i}.\n    if sigma == 0.0:\n        # Special degenerate case: variance is constant at its mean theta.\n        # This corresponds to the Black-Scholes-Merton model where returns are normal.\n        v_sample = np.full(n, theta)\n    else:\n        # In the stationary state, variance v follows a Gamma distribution.\n        # Shape parameter k = 2*kappa*theta / sigma^2\n        # Scale parameter b = sigma^2 / (2*kappa)\n        shape_k = 2 * kappa * theta / (sigma**2)\n        scale_b = (sigma**2) / (2 * kappa)\n        v_sample = rng.gamma(shape_k, scale=scale_b, size=n)\n\n    # Step 2: Generate the log-return sample {r_i}.\n    # The conditional distribution r | v is Normal.\n    # Mean = -0.5 * v * delta_t\n    # Standard deviation = sqrt(v * delta_t)\n    means = -0.5 * v_sample * delta_t\n    # Ensure standard deviation is non-negative, though v_sample from Gamma should be.\n    std_devs = np.sqrt(v_sample * delta_t)\n    r_sample = rng.normal(loc=means, scale=std_devs)\n\n    # Step 3: Perform the hypothesis test for excess kurtosis.\n    # Calculate sample mean.\n    r_bar = np.mean(r_sample)\n    \n    # Calculate 2nd and 4th central moments.\n    m2 = np.mean((r_sample - r_bar)**2)\n    m4 = np.mean((r_sample - r_bar)**4)\n\n    # Avoid division by zero if sample variance is zero (highly improbable).\n    if m2 == 0.0:\n        return False\n\n    # Calculate sample excess kurtosis (g2).\n    g2 = m4 / (m2**2) - 3.0\n\n    # Calculate the z-statistic for the one-sided test.\n    # Under H0 (normality), the standard error of g2 is sqrt(24/n).\n    z_stat = g2 / np.sqrt(24.0 / n)\n\n    # Define significance level and find the critical value.\n    alpha = 0.05\n    # For a one-sided test (H1: kurtosis > 0), we use the (1-alpha) quantile.\n    z_critical = norm.ppf(1 - alpha)\n\n    # Make the decision: reject H0 if z_stat exceeds the critical value.\n    reject_h0 = z_stat > z_critical\n    \n    return reject_h0\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    # Test cases defined in the problem statement.\n    # Format: (seed, kappa, theta, sigma, delta_t, n)\n    test_cases = [\n        (12345, 2.0, 0.04, 0.0, 1.0, 200000),   # Case A\n        (12346, 2.0, 0.04, 1.0, 1.0, 200000),   # Case B\n        (12347, 1.5, 0.04, 0.5, 1.0, 2000),     # Case C\n        (12348, 5.0, 0.04, 0.1, 1.0, 50000),    # Case D\n    ]\n\n    results = []\n    for case in test_cases:\n        # Unpack parameters for each test case\n        seed, kappa, theta, sigma, delta_t, n = case\n        # Run the test and store the boolean result\n        result = run_heston_kurtosis_test(seed, kappa, theta, sigma, delta_t, n)\n        results.append(result)\n\n    # Print the final list of results in the specified format.\n    # The str() of a boolean is 'True' or 'False' (capitalized), which is the standard format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"}, {"introduction": "After exploring the random behavior of the variance process, we can analyze its expected path, which is crucial for pricing certain derivatives. This exercise bridges theory and practice by tasking you with deriving the fair price of a variance swap from first principles, based on the expected path of the instantaneous variance $\\mathbb{E}^{\\mathbb{Q}}[v_t]$ [@problem_id:2441205]. You will solve the governing ordinary differential equation and implement the resulting formula, developing skills in both analytical modeling and robust numerical computation.", "id": "2441205", "problem": "You are asked to formulate and compute the present value of a fixed-strike variance swap when the underlying asset price follows Heston dynamics under the risk-neutral measure. The Heston model is defined by the system of stochastic differential equations\n$dS_t = S_t \\left( r \\, dt + \\sqrt{v_t} \\, dW_t^{S} \\right)$ and $dv_t = \\kappa \\left( \\theta - v_t \\right) dt + \\sigma \\sqrt{v_t} \\, dW_t^{v}$ with $\\mathrm{corr}(dW_t^{S}, dW_t^{v}) = \\rho$, where $S_t$ is the asset price, $v_t$ is the instantaneous variance, $r$ is the continuously compounded risk-free rate, $\\kappa$ is the variance mean-reversion speed, $\\theta$ is the long-run variance, $\\sigma$ is the volatility of variance (also known as vol-of-vol), and $\\rho$ is the correlation between the Brownian motions. The variance process $v_t$ is a Cox–Ingersoll–Ross (CIR) square-root process.\n\nA variance swap with maturity $T$ has a payoff at time $T$ equal to $N_{\\mathrm{var}} \\left( K_{\\mathrm{realized}} - K_{\\mathrm{fixed}} \\right)$, where $N_{\\mathrm{var}}$ is the variance notional in variance-rate units, $K_{\\mathrm{fixed}}$ is the fixed strike in variance-rate units, and the annualized realized variance is $K_{\\mathrm{realized}} = \\dfrac{1}{T} \\int_{0}^{T} v_t \\, dt$. You must compute the present value (time $0$) of this payoff, measured in the same currency as $N_{\\mathrm{var}}$, assuming all rates are continuously compounded and expressed as decimals (not percentages).\n\nYour derivation must start from the following fundamental base:\n- Risk-neutral pricing principle: the present value equals the discounted risk-neutral expectation of the payoff, that is, $e^{-r T} \\, \\mathbb{E}^{\\mathbb{Q}}\\left[ \\cdot \\right]$.\n- For a continuous semimartingale model without jumps, the annualized realized variance equals the time-average of the instantaneous variance, that is, $K_{\\mathrm{realized}} = \\dfrac{1}{T} \\int_{0}^{T} v_t \\, dt$.\n- The expectation of a Cox–Ingersoll–Ross (CIR) square-root diffusion satisfies a first-order linear ordinary differential equation obtained by taking expectations of its drift, and standard existence and uniqueness results apply. Do not assume any closed-form expressions for the solution of this ordinary differential equation; derive the expected variance path from this base.\n\nTasks:\n1) Starting from the definitions above, derive an expression for the fair variance swap rate $K_{\\mathrm{fair}} = \\mathbb{E}^{\\mathbb{Q}} \\left[ K_{\\mathrm{realized}} \\right]$ in terms of the model parameters $v_0$, $\\kappa$, and $\\theta$. Treat carefully the boundary behavior when $\\kappa \\to 0$.\n2) Use the risk-neutral pricing principle to express the present value at time $0$ of the fixed-strike variance swap payoff as a function of $K_{\\mathrm{fair}}$, $K_{\\mathrm{fixed}}$, $N_{\\mathrm{var}}$, $r$, and $T$.\n3) Implement a program that computes the present value for each of the parameter sets in the test suite below. In all computations, rates must be treated as decimals (for example, $0.04$ for a $4$ percent per annum variance level) and time to maturity $T$ is in years. The final program output must be a single line string in the format described at the end of this problem statement.\n4) Ensure numerical stability for very small $|\\kappa|$ by using an analytically justified limiting expression obtained via L’Hôpital’s rule when needed.\n\nTest suite:\nProvide the present value for each of the following four parameter sets. Each tuple is ordered as $(\\kappa, \\theta, \\sigma, \\rho, v_0, r, T, N_{\\mathrm{var}}, K_{\\mathrm{fixed}})$.\n\n- Case A (general “happy path”): $(2.0, 0.04, 0.6, -0.7, 0.04, 0.01, 1.0, 1.0, 0.05)$\n- Case B (near-non-mean-reverting boundary): $(0.00000001, 0.09, 0.3, 0.2, 0.16, 0.0, 0.25, 1.0, 0.15)$\n- Case C (long maturity dominance by long-run variance): $(3.0, 0.09, 0.5, -0.9, 0.04, 0.02, 5.0, 1.0, 0.08)$\n- Case D (moderate mean reversion with nonunit notional): $(0.5, 0.06, 1.0, 0.5, 0.10, 0.0, 2.0, 2.0, 0.08)$\n\nAnswer requirements:\n- Express all rates as decimals, not with a percentage sign.\n- No physical units or angles appear in this problem.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[x_1,x_2,x_3,x_4]$), where each $x_i$ is the present value for the corresponding test case in the order A, B, C, D.", "solution": "The problem statement is scientifically grounded, well-posed, and contains all necessary information for a unique solution. It is a standard problem in quantitative finance, based on the Heston stochastic volatility model and the principle of risk-neutral pricing. The problem is therefore deemed **valid**.\n\nThe objective is to compute the present value of a fixed-strike variance swap. This requires two primary steps: first, deriving the fair variance swap rate, $K_{\\mathrm{fair}}$, and second, using this rate to find the present value of the swap's payoff.\n\n**1. Derivation of the Expected Variance Path**\n\nThe Heston model specifies the dynamics of the instantaneous variance $v_t$ under the risk-neutral measure $\\mathbb{Q}$ as a Cox-Ingersoll-Ross (CIR) process:\n$$dv_t = \\kappa (\\theta - v_t) dt + \\sigma \\sqrt{v_t} dW_t^v$$\nwhere $\\kappa$ is the speed of mean reversion, $\\theta$ is the long-run mean variance, and $\\sigma$ is the volatility of variance. Let $\\bar{v}(t) = \\mathbb{E}^{\\mathbb{Q}}[v_t]$ be the expected value of the variance at time $t$. By taking the expectation of the stochastic differential equation (SDE), we can derive an ordinary differential equation (ODE) for $\\bar{v}(t)$. The expectation of the stochastic term is zero, i.e., $\\mathbb{E}^{\\mathbb{Q}}[\\sigma \\sqrt{v_t} dW_t^v] = 0$. This leads to:\n$$d\\mathbb{E}^{\\mathbb{Q}}[v_t] = \\mathbb{E}^{\\mathbb{Q}}[\\kappa (\\theta - v_t)] dt$$\nUsing the linearity of the expectation operator, we have:\n$$\\frac{d\\bar{v}(t)}{dt} = \\kappa (\\theta - \\bar{v}(t))$$\nThis is a first-order linear ODE with the initial condition $\\bar{v}(0) = v_0$. We can rewrite it as:\n$$\\frac{d\\bar{v}(t)}{dt} + \\kappa \\bar{v}(t) = \\kappa \\theta$$\nThe solution is found using an integrating factor $I(t) = e^{\\int \\kappa dt} = e^{\\kappa t}$. Multiplying the ODE by $I(t)$ gives:\n$$e^{\\kappa t} \\frac{d\\bar{v}(t)}{dt} + \\kappa e^{\\kappa t} \\bar{v}(t) = \\kappa \\theta e^{\\kappa t}$$\n$$\\frac{d}{dt} \\left( e^{\\kappa t} \\bar{v}(t) \\right) = \\kappa \\theta e^{\\kappa t}$$\nIntegrating from $0$ to $t$:\n$$\\int_0^t \\frac{d}{ds} \\left( e^{\\kappa s} \\bar{v}(s) \\right) ds = \\int_0^t \\kappa \\theta e^{\\kappa s} ds$$\n$$e^{\\kappa t} \\bar{v}(t) - e^0 \\bar{v}(0) = \\kappa \\theta \\left[ \\frac{e^{\\kappa s}}{\\kappa} \\right]_0^t = \\theta(e^{\\kappa t} - 1)$$\nSolving for $\\bar{v}(t)$:\n$$e^{\\kappa t} \\bar{v}(t) = v_0 + \\theta(e^{\\kappa t} - 1)$$\n$$\\bar{v}(t) = v_0 e^{-\\kappa t} + \\theta(1 - e^{-\\kappa t})$$\nThis is the expected path of the instantaneous variance at any time $t > 0$.\n\n**2. Derivation of the Fair Variance Swap Rate, $K_{\\mathrm{fair}}$**\n\nThe fair variance swap rate, $K_{\\mathrm{fair}}$, is defined as the risk-neutral expectation of the annualized realized variance $K_{\\mathrm{realized}}$.\n$$K_{\\mathrm{fair}} = \\mathbb{E}^{\\mathbb{Q}}[K_{\\mathrm{realized}}] = \\mathbb{E}^{\\mathbb{Q}}\\left[\\frac{1}{T} \\int_0^T v_t dt\\right]$$\nBy applying Fubini's theorem to interchange the expectation and integration:\n$$K_{\\mathrm{fair}} = \\frac{1}{T} \\int_0^T \\mathbb{E}^{\\mathbb{Q}}[v_t] dt = \\frac{1}{T} \\int_0^T \\bar{v}(t) dt$$\nSubstituting the expression for $\\bar{v}(t)$:\n$$K_{\\mathrm{fair}} = \\frac{1}{T} \\int_0^T \\left( v_0 e^{-\\kappa t} + \\theta(1 - e^{-\\kappa t}) \\right) dt$$\n$$K_{\\mathrm{fair}} = \\frac{1}{T} \\int_0^T \\left( (v_0 - \\theta) e^{-\\kappa t} + \\theta \\right) dt$$\nPerforming the integration for $\\kappa \\neq 0$:\n$$K_{\\mathrm{fair}} = \\frac{1}{T} \\left[ (v_0 - \\theta) \\frac{e^{-\\kappa t}}{-\\kappa} + \\theta t \\right]_0^T$$\n$$K_{\\mathrm{fair}} = \\frac{1}{T} \\left( \\left( (v_0 - \\theta) \\frac{e^{-\\kappa T}}{-\\kappa} + \\theta T \\right) - \\left( (v_0 - \\theta) \\frac{1}{-\\kappa} \\right) \\right)$$\n$$K_{\\mathrm{fair}} = \\frac{1}{T} \\left( \\frac{v_0 - \\theta}{\\kappa} (1 - e^{-\\kappa T}) + \\theta T \\right)$$\n$$K_{\\mathrm{fair}} = \\theta + (v_0 - \\theta) \\frac{1 - e^{-\\kappa T}}{\\kappa T}$$\n\n**3. Limiting Case for Small $\\kappa$**\n\nFor numerical stability, we must analyze the behavior of the expression for $K_{\\mathrm{fair}}$ as $\\kappa \\to 0$. The fraction $\\frac{1 - e^{-\\kappa T}}{\\kappa T}$ becomes an indeterminate form $\\frac{0}{0}$. We apply L'Hôpital's rule to the function $f(x) = \\frac{1 - e^{-x}}{x}$ as $x = \\kappa T \\to 0$:\n$$\\lim_{x \\to 0} \\frac{1 - e^{-x}}{x} = \\lim_{x \\to 0} \\frac{\\frac{d}{dx}(1 - e^{-x})}{\\frac{d}{dx}(x)} = \\lim_{x \\to 0} \\frac{e^{-x}}{1} = 1$$\nTherefore, the limit of $K_{\\mathrm{fair}}$ as $\\kappa \\to 0$ is:\n$$\\lim_{\\kappa \\to 0} K_{\\mathrm{fair}} = \\theta + (v_0 - \\theta) \\cdot 1 = v_0$$\nThis is consistent with the fact that for $\\kappa=0$, the expected variance is constant at its initial value, $\\bar{v}(t) = v_0$.\nFor implementation, direct computation of $1 - e^{-x}$ for small $x$ leads to catastrophic cancellation. A more accurate result is obtained from a first-order Taylor series expansion of $f(x)$ around $x=0$: $f(x) \\approx f(0) + f'(0)x$. We found $f(0)=1$. The derivative is $f'(x) = \\frac{-x e^{-x} - (1-e^{-x})}{x^2}$, and $\\lim_{x \\to 0} f'(x) = -1/2$.\nThus, for small $x = \\kappa T$, we have $\\frac{1 - e^{-\\kappa T}}{\\kappa T} \\approx 1 - \\frac{\\kappa T}{2}$.\nSubstituting this into the expression for $K_{\\mathrm{fair}}$ yields a numerically stable approximation for small $\\kappa$:\n$$K_{\\mathrm{fair}} \\approx \\theta + (v_0 - \\theta) \\left(1 - \\frac{\\kappa T}{2}\\right) = v_0 - (v_0 - \\theta)\\frac{\\kappa T}{2}$$\nThis approximation will be used when $|\\kappa|$ is below a small threshold.\n\n**4. Present Value of the Variance Swap**\n\nThe payoff of the variance swap at maturity $T$ is $N_{\\mathrm{var}} (K_{\\mathrm{realized}} - K_{\\mathrm{fixed}})$. According to the risk-neutral pricing principle, the present value at time $0$ is the discounted expected payoff:\n$$PV_0 = e^{-rT} \\mathbb{E}^{\\mathbb{Q}}\\left[N_{\\mathrm{var}} (K_{\\mathrm{realized}} - K_{\\mathrm{fixed}})\\right]$$\nBy linearity of expectation, and since $N_{\\mathrm{var}}$ and $K_{\\mathrm{fixed}}$ are constants:\n$$PV_0 = N_{\\mathrm{var}} e^{-rT} \\left(\\mathbb{E}^{\\mathbb{Q}}[K_{\\mathrm{realized}}] - \\mathbb{E}^{\\mathbb{Q}}[K_{\\mathrm{fixed}}]\\right)$$\n$$PV_0 = N_{\\mathrm{var}} e^{-rT} (K_{\\mathrm{fair}} - K_{\\mathrm{fixed}})$$\n\n**5. Implementation Summary**\n\nThe program will implement these derived formulas. A function `calculate_k_fair` computes the fair variance swap rate based on the parameters $v_0$, $\\kappa$, $\\theta$, and $T$. This function will check if $|\\kappa|$ is below a threshold (e.g., $10^{-8}$) and apply the stable Taylor series approximation; otherwise, it will use the standard formula, implemented using `numpy.expm1` to maintain precision. A second function `calculate_pv` will use this fair rate to compute the final present value for each test case provided. The parameters $\\sigma$ and $\\rho$ are irrelevant for this calculation, as they do not affect the expected path of the variance.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the present value of a fixed-strike variance swap\n    under the Heston model for a suite of test cases.\n    \"\"\"\n\n    def calculate_k_fair(v0, kappa, theta, T):\n        \"\"\"\n        Calculates the fair variance swap rate, K_fair.\n\n        Args:\n            v0 (float): Initial variance.\n            kappa (float): Mean-reversion speed.\n            theta (float): Long-run variance.\n            T (float): Time to maturity in years.\n\n        Returns:\n            float: The fair variance swap rate.\n        \"\"\"\n        # For very small kappa, the standard formula is numerically unstable\n        # due to catastrophic cancellation. We use a first-order Taylor\n        # expansion derived in the solution.\n        if abs(kappa) < 1e-8:\n            # K_fair ≈ v₀ - (v₀ - θ) * κ * T / 2\n            return v0 - (v0 - theta) * kappa * T / 2.0\n        else:\n            # Standard formula: K_fair = θ + (v₀ - θ) * (1 - e^(-κT)) / (κT)\n            # We use np.expm1 for precision: 1 - exp(-x) = -expm1(-x)\n            x = kappa * T\n            term = -np.expm1(-x) / x\n            return theta + (v0 - theta) * term\n\n    def calculate_pv(v0, kappa, theta, T, N_var, k_fixed, r):\n        \"\"\"\n        Calculates the present value of the variance swap.\n\n        Args:\n            v0 (float): Initial variance.\n            kappa (float): Mean-reversion speed.\n            theta (float): Long-run variance.\n            T (float): Time to maturity in years.\n            N_var (float): Variance notional.\n            k_fixed (float): Fixed variance strike.\n            r (float): Risk-free rate.\n            \n        Returns:\n            float: The present value of the variance swap.\n        \"\"\"\n        k_fair = calculate_k_fair(v0, kappa, theta, T)\n        pv = N_var * np.exp(-r * T) * (k_fair - k_fixed)\n        return pv\n\n    # Define the test cases from the problem statement.\n    # Each tuple is ordered as (κ, θ, σ, ρ, v₀, r, T, N_var, K_fixed).\n    test_cases = [\n        # Case A: General \"happy path\"\n        (2.0, 0.04, 0.6, -0.7, 0.04, 0.01, 1.0, 1.0, 0.05),\n        # Case B: Near-non-mean-reverting boundary\n        (1.0e-8, 0.09, 0.3, 0.2, 0.16, 0.0, 0.25, 1.0, 0.15),\n        # Case C: Long maturity dominance by long-run variance\n        (3.0, 0.09, 0.5, -0.9, 0.04, 0.02, 5.0, 1.0, 0.08),\n        # Case D: Moderate mean reversion with non-unit notional\n        (0.5, 0.06, 1.0, 0.5, 0.10, 0.0, 2.0, 2.0, 0.08),\n    ]\n\n    results = []\n    for case in test_cases:\n        # Unpack parameters, ignoring sigma and rho as they are not needed.\n        kappa, theta, _sigma, _rho, v0, r, T, N_var, k_fixed = case\n        \n        # Calculate the present value for the current case.\n        pv = calculate_pv(v0, kappa, theta, T, N_var, k_fixed, r)\n        results.append(pv)\n\n    # Final print statement in the exact required format.\n    # The format uses high precision to avoid rounding issues.\n    print(f\"[{','.join(f'{x:.12f}' for x in results)}]\")\n\nsolve()\n```"}, {"introduction": "This advanced practice delves into the practical art of risk management and model-based trading, demonstrating how to isolate risks associated with specific model parameters [@problem_id:2441262]. You will construct a \"Volga-pure\" portfolio of options designed to be sensitive only to the \"volatility of volatility\" parameter, $\\sigma$, while being neutral to other primary market and model risks. This exercise shows how abstract model parameters can be targeted and managed using a portfolio of standard financial instruments by solving a system of linear equations derived from option sensitivities.", "id": "2441262", "problem": "A financial market is modeled under the risk-neutral measure by the Heston stochastic volatility model. The asset price process $S_t$ and the variance process $v_t$ satisfy the coupled stochastic differential equations\n$$\n\\mathrm{d}S_t = (r-q)\\,S_t\\,\\mathrm{d}t + \\sqrt{v_t}\\,S_t\\,\\mathrm{d}W_t^{(1)}, \\quad \\mathrm{d}v_t = \\kappa(\\theta - v_t)\\,\\mathrm{d}t + \\sigma \\sqrt{v_t}\\,\\mathrm{d}W_t^{(2)},\n$$\nwith correlation $\\mathrm{d}\\langle W^{(1)},W^{(2)}\\rangle_t = \\rho\\,\\mathrm{d}t$, where $r$ is the continuously compounded risk-free rate, $q$ is the continuous dividend yield, $\\kappa$ is the variance mean-reversion speed, $\\theta$ is the long-run variance, $\\sigma$ is the volatility of variance (vol-of-vol), and $\\rho$ is the instantaneous correlation between the Brownian motions. The initial conditions are $S_0$ and $v_0$ at time $t=0$.\n\nFor a European call option with strike $K$ and maturity $T$, denote its arbitrage-free price by $C(K,T;\\boldsymbol{\\Theta})$, where $\\boldsymbol{\\Theta} = (S_0,v_0,\\rho,\\kappa,\\theta,\\sigma,r,q)$.\n\nDefine the first-order parameter sensitivity of the option price with respect to a model input $p$ by the partial derivative $\\partial C / \\partial p$ evaluated at a specified parameter vector $\\boldsymbol{\\Theta}$. Consider a static portfolio of $N$ vanilla European call options with weights $w_1,\\dots,w_N$ (each weight may be any real number), where option $j$ has strike $K_j$ and maturity $T_j$. The portfolio value is $V = \\sum_{j=1}^N w_j\\,C(K_j,T_j;\\boldsymbol{\\Theta})$.\n\nA portfolio is said to be \"Volga-pure with respect to vol-of-vol\" if, to first order, its sensitivity to the vol-of-vol parameter $\\sigma$ equals $1$ and its sensitivities to the other five model inputs $S_0$, $v_0$, $\\rho$, $\\kappa$, and $\\theta$ are all $0$:\n$$\n\\sum_{j=1}^N w_j\\,\\frac{\\partial C_j}{\\partial \\sigma} = 1, \\quad \\sum_{j=1}^N w_j\\,\\frac{\\partial C_j}{\\partial S_0} = 0, \\quad \\sum_{j=1}^N w_j\\,\\frac{\\partial C_j}{\\partial v_0} = 0, \\quad \\sum_{j=1}^N w_j\\,\\frac{\\partial C_j}{\\partial \\rho} = 0, \\quad \\sum_{j=1}^N w_j\\,\\frac{\\partial C_j}{\\partial \\kappa} = 0, \\quad \\sum_{j=1}^N w_j\\,\\frac{\\partial C_j}{\\partial \\theta} = 0,\n$$\nwhere $C_j = C(K_j,T_j;\\boldsymbol{\\Theta})$.\n\nYour task is to construct such a portfolio using $N=6$ vanilla call options, taking the options to be the same across all test cases with strikes and maturities\n$$\n(K_1,T_1)=(80,0.5),\\ (K_2,T_2)=(100,0.5),\\ (K_3,T_3)=(120,0.5),\\ (K_4,T_4)=(80,1.0),\\ (K_5,T_5)=(100,1.0),\\ (K_6,T_6)=(120,1.0).\n$$\n\nFor each of the following parameter sets (test suite), compute a vector of weights $\\boldsymbol{w}=(w_1,\\dots,w_6)$ that satisfies the six linear sensitivity constraints above, using the European call option price $C(K,T;\\boldsymbol{\\Theta})$ under the Heston model and first principles. The program should internally approximate sensitivities by a numerically consistent method and verify the constraints at the provided parameter values. The risk-free rate $r$ and dividend yield $q$ are continuously compounded. All rates, variances, and correlations must be treated as dimensionless decimals. There are no physical units in this problem.\n\nTest suite (each item is $(S_0,v_0,\\rho,\\kappa,\\theta,\\sigma,r,q)$):\n- Case $1$: $(100.0,0.04,-0.5,1.5,0.04,0.5,0.02,0.0)$\n- Case $2$: $(100.0,0.05,-0.3,2.0,0.06,0.1,0.01,0.0)$\n- Case $3$: $(100.0,0.04,-0.9,3.0,0.04,0.4,0.03,0.0)$\n\nFor each case, your program must:\n1. Compute a weight vector $\\boldsymbol{w}$ that exactly satisfies, in the linear algebraic sense, the six constraints for the six parameters $(S_0,v_0,\\rho,\\kappa,\\theta,\\sigma)$ at the given $\\boldsymbol{\\Theta}$.\n2. Independently verify by direct recomputation of the sensitivities at the same $\\boldsymbol{\\Theta}$ that the portfolio satisfies\n$$\n\\left|\\sum_{j=1}^6 w_j\\,\\frac{\\partial C_j}{\\partial S_0}\\right| \\le 10^{-4},\\quad\n\\left|\\sum_{j=1}^6 w_j\\,\\frac{\\partial C_j}{\\partial v_0}\\right| \\le 10^{-4},\\quad\n\\left|\\sum_{j=1}^6 w_j\\,\\frac{\\partial C_j}{\\partial \\rho}\\right| \\le 10^{-4},\\quad\n\\left|\\sum_{j=1}^6 w_j\\,\\frac{\\partial C_j}{\\partial \\kappa}\\right| \\le 10^{-4},\\quad\n\\left|\\sum_{j=1}^6 w_j\\,\\frac{\\partial C_j}{\\partial \\theta}\\right| \\le 10^{-4},\\quad\n\\left|\\sum_{j=1}^6 w_j\\,\\frac{\\partial C_j}{\\partial \\sigma} - 1\\right| \\le 10^{-4}.\n$$\n\nFinal output format:\n- Your program should produce a single line of output containing the verification results for the three cases as a comma-separated list of booleans enclosed in square brackets (for example, $[{\\rm True},{\\rm False},{\\rm True}]$), where each boolean indicates whether the constructed portfolio for that case meets all six inequalities at the stated tolerances.", "solution": "The problem presented is a well-posed exercise in computational finance that is grounded in established principles of financial engineering. Its validity is confirmed upon examination. The task requires the construction of a specific portfolio of European call options whose sensitivities to a set of Heston model parameters meet a prescribed profile. The solution involves solving a system of linear equations, where the coefficients are the first-order sensitivities, or \"Greeks,\" of the options.\n\nThe core of the problem is to find a vector of weights $\\boldsymbol{w} = (w_1, \\dots, w_6)^T$ for a portfolio of $N=6$ European call options. This portfolio must be \"Volga-pure with respect to vol-of-vol,\" which is defined by a set of six linear constraints on its sensitivities. Let $C_j = C(K_j, T_j; \\boldsymbol{\\Theta})$ be the price of the $j$-th option, where $\\boldsymbol{\\Theta} = (S_0, v_0, \\rho, \\kappa, \\theta, \\sigma, r, q)$ is the vector of model parameters and market conditions. The six parameters of interest for sensitivity are $p_1=S_0$, $p_2=v_0$, $p_3=\\rho$, $p_4=\\kappa$, $p_5=\\theta$, and $p_6=\\sigma$. The constraints can be expressed as a linear system:\n$$\n\\sum_{j=1}^{6} w_j \\frac{\\partial C_j}{\\partial p_i} = b_i, \\quad \\text{for } i=1, \\dots, 6\n$$\nwhere the target sensitivity vector is $\\boldsymbol{b} = (0, 0, 0, 0, 0, 1)^T$. In matrix form, this is $A \\boldsymbol{w} = \\boldsymbol{b}$, where $A$ is the $6 \\times 6$ sensitivity matrix with elements $A_{ij} = \\frac{\\partial C_j}{\\partial p_i}$. The solution for the weights is formally given by $\\boldsymbol{w} = A^{-1}\\boldsymbol{b}$, provided the matrix $A$ is invertible. The invertibility of $A$ depends on the linear independence of the sensitivity vectors of the six distinct options provided, which is generally expected to hold for non-degenerate parameter sets.\n\nThe solution proceeds in two main stages:\n1.  **Computation of Heston Option Prices and Sensitivities**: The price of a European call option under the Heston model is computed using the semi-analytical solution involving Fourier transforms. The sensitivities are then approximated using a central finite difference scheme.\n2.  **Solving the Linear System**: With the sensitivity matrix $A$ constructed, the system $A\\boldsymbol{w}=\\boldsymbol{b}$ is solved using a standard linear algebra library routine to find the weights $\\boldsymbol{w}$. The validity of the solution is then checked against the specified tolerances.\n\n**1. Heston Model Option Pricing**\n\nThe price of a European call option with strike $K$ and maturity $T$ is given by\n$$\nC(S_0, K, T) = S_0 e^{-qT} P_1 - K e^{-rT} P_2\n$$\nwhere $S_0$ is the initial asset price, $r$ is the risk-free rate, and $q$ is the dividend yield. The terms $P_1$ and $P_2$ are probabilities under different measures, calculated by inverting their respective characteristic functions via numerical integration:\n$$\nP_j = \\frac{1}{2} + \\frac{1}{\\pi} \\int_0^\\infty \\text{Re}\\left[ \\frac{e^{-i\\phi \\ln K} f_j(\\phi; S_0, v_0, T)}{i\\phi} \\right] d\\phi, \\quad \\text{for } j=1, 2\n$$\nThe characteristic functions $f_j$ are given by\n$$\nf_j(\\phi) = \\exp\\left( C_j(\\phi, T) + D_j(\\phi, T)v_0 + i\\phi \\ln S_0 \\right)\n$$\nThe complex-valued coefficients $C_j$ and $D_j$ are defined as:\n$$\nC_j(\\phi, T) = i\\phi(r-q)T + \\frac{\\kappa\\theta}{\\sigma^2} \\left[ (b_j - d_j)T - 2\\ln\\left( \\frac{1-g_j e^{-d_j T}}{1-g_j} \\right) \\right]\n$$\n$$\nD_j(\\phi, T) = \\frac{b_j-d_j}{\\sigma^2} \\left( \\frac{1-e^{-d_j T}}{1-g_j e^{-d_j T}} \\right)\n$$\nThe auxiliary variables are:\n$$\nd_j = \\sqrt{b_j^2 - \\sigma^2(2u_j i \\phi - \\phi^2)}\n$$\n$$\ng_j = \\frac{b_j-d_j}{b_j+d_j}\n$$\nThe constants $u_j$ and variables $b_j$ depend on which probability ($P_1$ or $P_2$) is being calculated:\n- For $P_1$: $u_1 = 1/2$, $b_1 = \\kappa - \\rho\\sigma i\\phi$.\n- For $P_2$: $u_2 = -1/2$, $b_2 = \\kappa$.\n\nThe improper integrals for $P_1$ and $P_2$ are computed numerically using quadrature methods. The integrand is well-behaved at $\\phi=0$, and the integral converges rapidly, allowing for truncation of the integration domain at a sufficiently large upper bound.\n\n**2. Sensitivity Calculation and System Solution**\n\nThe partial derivatives $\\frac{\\partial C_j}{\\partial p_i}$ that form the matrix $A$ are approximated using a second-order central finite difference formula:\n$$\n\\frac{\\partial C(p)}{\\partial p} \\approx \\frac{C(p + h) - C(p - h)}{2h}\n$$\nwhere $h$ is a small step size. A relative step size of the form $h = \\epsilon |p|$ is used for most parameters, with a small absolute step size $\\epsilon$ (e.g., $10^{-5}$) for parameters that could be near zero, to maintain numerical stability and accuracy.\n\nFor each test case, the algorithm is as follows:\na. Define the set of Heston parameters $\\boldsymbol{\\Theta}$ from the test suite.\nb. Define the six options $(K_j, T_j)$ comprising the portfolio.\nc. Construct the $6 \\times 6$ sensitivity matrix $A$. Each column $j$ corresponds to an option and each row $i$ corresponds to a parameter $p_i$. The element $A_{ij}$ is computed by applying the finite difference formula to the Heston pricing function for option $j$ with respect to parameter $p_i$.\nd. Define the target vector $\\boldsymbol{b} = (0, 0, 0, 0, 0, 1)^T$.\ne. Solve the linear system $A\\boldsymbol{w} = \\boldsymbol{b}$ for the weight vector $\\boldsymbol{w}$ using a standard numerical linear solver.\nf. Verify the solution by computing the portfolio's sensitivity profile, $\\boldsymbol{s} = A\\boldsymbol{w}$.\ng. Check if each element of the resulting vector $\\boldsymbol{s}$ matches the target vector $\\boldsymbol{b}$ within the specified tolerance of $10^{-4}$. That is, check if $|s_i - b_i| \\leq 10^{-4}$ for all $i=1, \\dots, 6$. The result of this verification (True or False) is recorded for the test case.\n\nThis procedure is repeated for each of the three parameter sets provided in the test suite. The final output is a list of these boolean verification results.", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Main function to construct and verify the Volga-pure portfolios.\n    \"\"\"\n\n    def heston_char_func_integrand(phi, params, K, T, j):\n        \"\"\"\n        Computes the integrand for P1 and P2 probabilities in the Heston model.\n        j=1 for P1, j=2 for P2.\n        \"\"\"\n        S0, v0, rho, kappa, theta, sigma, r, q = params\n        \n        if j == 1:\n            u, b = 0.5, kappa - rho * sigma * 1j * phi\n        else: # j == 2\n            u, b = -0.5, kappa\n\n        d = np.sqrt(b**2 - sigma**2 * (2 * u * 1j * phi - phi**2))\n        g = (b - d) / (b + d)\n        \n        # Numerically stable calculation for log term\n        # C = i*phi*(r-q)*T + kappa*theta/sigma**2 * ( (b-d)*T - 2*log((1-g*exp(-d*T))/(1-g)) )\n        # The log term can be unstable if g is close to 1.\n        # This happens when d is small.\n        # d -> 0 implies b^2 - sigma^2(...) -> 0.\n        # Another formulation of the log term:\n        # 2*log( (1-g*exp(-d*T))/(1-g) ) = 2*log( (b+d- (b-d)exp(-d*T))/(2d)) is not better.\n        # Let's use the standard form and rely on numpy's complex arithmetic precision.\n        \n        # When d*T is large, exp(-d*T) -> 0.\n        # When d*T is small, exp(-d*T) approx 1-d*T.\n        # (1-g*exp(-d*T))/(1-g) = (1-g+g*d*T)/(1-g) = 1 + g*d*T/(1-g)\n        # log(...) approx g*d*T/(1-g)\n        \n        # Use a check for small sigma to avoid division by zero, though not needed for test cases.\n        if sigma < 1e-10:\n            return 0.0\n\n        C_term_log = np.log((1 - g * np.exp(-d * T)) / (1 - g))\n        D = (b - d) / sigma**2 * ((1 - np.exp(-d * T)) / (1 - g * np.exp(-d * T)))\n        C = 1j * phi * (r - q) * T + kappa * theta / sigma**2 * ((b - d) * T - 2 * C_term_log)\n        \n        f = np.exp(C + D * v0 + 1j * phi * np.log(S0))\n        \n        integrand = np.real(np.exp(-1j * phi * np.log(K)) * f / (1j * phi))\n        return integrand\n\n    def heston_call_price(params, K, T):\n        \"\"\"\n        Calculates the price of a European call option using the Heston model.\n        \"\"\"\n        S0, v0, rho, kappa, theta, sigma, r, q = params\n        \n        # Integral P1\n        args_1 = (params, K, T, 1)\n        # The quad function can handle complex-valued functions by integrating real and imag parts\n        # but here the integrand is already made real.\n        integral_1, _ = quad(heston_char_func_integrand, 0, 200, args=args_1)\n        P1 = 0.5 + integral_1 / np.pi\n        \n        # Integral P2\n        args_2 = (params, K, T, 2)\n        integral_2, _ = quad(heston_char_func_integrand, 0, 200, args=args_2)\n        P2 = 0.5 + integral_2 / np.pi\n        \n        price = S0 * np.exp(-q * T) * P1 - K * np.exp(-r * T) * P2\n        return price\n\n    # Define the portfolio of 6 options\n    options = [\n        (80.0, 0.5), (100.0, 0.5), (120.0, 0.5),\n        (80.0, 1.0), (100.0, 1.0), (120.0, 1.0)\n    ]\n\n    # Test suite from the problem statement\n    test_cases = [\n        (100.0, 0.04, -0.5, 1.5, 0.04, 0.5, 0.02, 0.0),\n        (100.0, 0.05, -0.3, 2.0, 0.06, 0.1, 0.01, 0.0),\n        (100.0, 0.04, -0.9, 3.0, 0.04, 0.4, 0.03, 0.0)\n    ]\n    \n    # Parameters for which sensitivities are needed\n    param_indices = [0, 1, 2, 3, 4, 5]  # Indices for S0, v0, rho, kappa, theta, sigma\n    h_rel = 1e-5 # Relative step size for finite differences\n    h_abs = 1e-5 # Absolute step size for certain parameters\n\n    results = []\n    \n    for case_params in test_cases:\n        A = np.zeros((6, 6))\n        \n        for j, (K, T) in enumerate(options):\n            for i, p_idx in enumerate(param_indices):\n                params_list = list(case_params)\n                p_val = params_list[p_idx]\n                \n                # Choose step size h\n                if p_idx == 2: # rho\n                    h = h_abs\n                else: # S0, v0, kappa, theta, sigma\n                    h = h_rel * abs(p_val) if p_val != 0 else h_abs\n                \n                params_plus = params_list[:]\n                params_plus[p_idx] = p_val + h\n                price_plus = heston_call_price(tuple(params_plus), K, T)\n                \n                params_minus = params_list[:]\n                params_minus[p_idx] = p_val - h\n                price_minus = heston_call_price(tuple(params_minus), K, T)\n\n                sensitivity = (price_plus - price_minus) / (2 * h)\n                A[i, j] = sensitivity\n\n        b = np.array([0.0, 0.0, 0.0, 0.0, 0.0, 1.0])\n        \n        try:\n            w = np.linalg.solve(A, b)\n        except np.linalg.LinAlgError:\n            # If the matrix is singular, the portfolio cannot be constructed.\n            results.append(False)\n            continue\n            \n        # Verification step\n        portfolio_sensitivities = A @ w\n        \n        sens_zeros = portfolio_sensitivities[:5]\n        sens_one = portfolio_sensitivities[5]\n        \n        tolerance = 1e-4\n        \n        check_zeros = np.all(np.abs(sens_zeros) <= tolerance)\n        check_one = np.abs(sens_one - 1.0) <= tolerance\n        \n        results.append(check_zeros and check_one)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"}]}