{"hands_on_practices": [{"introduction": "The equity premium puzzle highlights the inability of standard consumption-based models to explain the high returns on stocks. This exercise explores the Rietz-Barro rare disaster model, where the stochastic discount factor (SDF), $m_{t+1} = \\beta g_{t+1}^{-\\gamma}$, becomes highly volatile due to rare but severe drops in consumption ($g_{t+1}$). By calculating asset prices analytically in this setting, you will gain a deep intuition for how the potential for disasters can generate a realistic equity premium, demonstrating the SDF's role in explaining fundamental market phenomena [@problem_id:2421399].", "id": "2421399", "problem": "Consider a representative-agent endowment economy with Constant Relative Risk Aversion (CRRA) utility. Let aggregate consumption be $\\{C_t\\}_{t \\ge 0}$, and define gross consumption growth as $g_{t+1} = \\frac{C_{t+1}}{C_t}$. The agent’s stochastic discount factor (SDF) is given by $m_{t+1} = \\beta \\, g_{t+1}^{-\\gamma}$, where $\\beta \\in (0,1)$ is the subjective discount factor and $\\gamma \\gt 0$ is the coefficient of relative risk aversion. Consumption growth follows a rare-disaster mixture process: \n$$\n\\log g_{t+1} = \\mu + \\sigma \\,\\varepsilon_{t+1} + \\ln(1-b)\\, J_{t+1},\n$$\nwith $\\varepsilon_{t+1} \\sim \\mathcal{N}(0,1)$, $J_{t+1} \\sim \\text{Bernoulli}(p)$, and $(\\varepsilon_{t+1}, J_{t+1})$ independent across time and mutually independent. The parameter $b \\in (0,1)$ is the proportional drop in consumption during a disaster, and $p \\in [0,1]$ is the probability of a disaster in a given period. The parameters $\\mu \\in \\mathbb{R}$ and $\\sigma \\ge 0$ govern the lognormal component of consumption growth.\n\nConsider two one-period assets priced by the fundamental pricing equation $P_t = \\mathbb{E}_t[m_{t+1} X_{t+1}]$, where $X_{t+1}$ is the next-period payoff:\n- A risk-free one-period pure-discount bond with gross return $R_f$ that satisfies $\\mathbb{E}[m_{t+1}] \\, R_f = 1$.\n- A risky “equity” claim with one-period payoff $X_{t+1} = g_{t+1}$. Its date-$t$ price is $P_e = \\mathbb{E}[m_{t+1} g_{t+1}]$, and its one-period gross return is $R_e = \\frac{g_{t+1}}{P_e}$. Define the expected equity return as $\\mathbb{E}[R_e]$ and the equity premium as $\\mathbb{E}[R_e] - R_f$.\n\nUsing only the definitions above and the specified probabilistic structure for $g_{t+1}$, compute, for each parameter set in the test suite, the triplet of floats $(R_f, \\mathbb{E}[R_e], \\mathbb{E}[R_e] - R_f)$.\n\nTest Suite (each tuple is $(\\beta, \\gamma, \\mu, \\sigma, p, b)$):\n- Case A (no disasters baseline): $(0.99, 4.0, 0.005, 0.02, 0.0, 0.3)$.\n- Case B (rare moderate disasters): $(0.99, 4.0, 0.005, 0.02, 0.01, 0.3)$.\n- Case C (rare severe disasters): $(0.99, 4.0, 0.005, 0.02, 0.01, 0.5)$.\n- Case D (disasters without diffusive risk): $(0.99, 4.0, 0.005, 0.0, 0.02, 0.4)$.\n- Case E (higher risk aversion with rare moderate disasters): $(0.99, 8.0, 0.005, 0.02, 0.01, 0.3)$.\n\nYour program must produce a single line of output containing the results for the five cases, formatted as a comma-separated list of five inner lists, each inner list containing the three floats $(R_f, \\mathbb{E}[R_e], \\mathbb{E}[R_e] - R_f)$ in that order. The line must have no spaces and must be enclosed in square brackets. For example, the required shape is $[[x_{1,1},x_{1,2},x_{1,3}],[x_{2,1},x_{2,2},x_{2,3}],[x_{3,1},x_{3,2},x_{3,3}],[x_{4,1},x_{4,2},x_{4,3}],[x_{5,1},x_{5,2},x_{5,3}]]$, where each $x_{i,j}$ is a float.", "solution": "The problem statement is subjected to rigorous validation and is found to be valid. It is scientifically grounded in established macroeconomic and financial theory, specifically the asset pricing framework with a representative agent, CRRA utility, and a rare-disaster process for consumption growth. The problem is well-posed, with all necessary parameters and distributions defined, ensuring that a unique and meaningful solution can be calculated. The language is objective and mathematically precise.\n\nThe solution proceeds by deriving the necessary analytical expressions. The core of the problem is the calculation of various expected values involving the gross consumption growth, $g_{t+1}$. The process for log-consumption growth is given by:\n$$ \\log g_{t+1} = \\mu + \\sigma \\varepsilon_{t+1} + \\ln(1-b) J_{t+1} $$\nwhere $\\varepsilon_{t+1} \\sim \\mathcal{N}(0,1)$ and $J_{t+1} \\sim \\text{Bernoulli}(p)$ are independent. We can write $g_{t+1}$ as the product of two independent random variables:\n$$ g_{t+1} = \\exp(\\mu + \\sigma \\varepsilon_{t+1}) \\cdot (1-b)^{J_{t+1}} $$\nLet $Z = \\exp(\\mu + \\sigma \\varepsilon_{t+1})$ and $V = (1-b)^{J_{t+1}}$. The variable $Z$ is log-normally distributed, with $\\log Z \\sim \\mathcal{N}(\\mu, \\sigma^2)$. The variable $V$ takes the value $1-b$ with probability $p$ and $1$ with probability $1-p$.\n\nThe key to solving the problem is to derive a general formula for the $k$-th moment of $g_{t+1}$, which is $\\mathbb{E}[g_{t+1}^k]$. Due to the independence of $Z$ and $V$, we have:\n$$ \\mathbb{E}[g_{t+1}^k] = \\mathbb{E}[Z^k V^k] = \\mathbb{E}[Z^k] \\mathbb{E}[V^k] $$\nThe expectation of $Z^k$ is a standard result for log-normal distributions:\n$$ \\mathbb{E}[Z^k] = \\mathbb{E}[\\exp(k(\\mu + \\sigma \\varepsilon_{t+1}))] = \\exp(k\\mu + \\frac{1}{2} k^2 \\sigma^2) $$\nThe expectation of $V^k$ is calculated from its discrete distribution:\n$$ \\mathbb{E}[V^k] = \\mathbb{E}[((1-b)^{J_{t+1}})^k] = (1-p) \\cdot (1-b)^{k \\cdot 0} + p \\cdot (1-b)^{k \\cdot 1} = (1-p) + p(1-b)^k $$\nCombining these results yields the general moment-generating formula for $g_{t+1}$:\n$$ \\mathbb{E}[g_{t+1}^k] = \\exp(k\\mu + \\frac{1}{2} k^2 \\sigma^2) \\left[ (1-p) + p(1-b)^k \\right] $$\nWe now apply this formula to derive the quantities of interest.\n\n1.  **Risk-Free Gross Return ($R_f$)**\n    The risk-free rate is defined by the equation $1 = \\mathbb{E}[m_{t+1}] R_f$. Thus, $R_f = 1 / \\mathbb{E}[m_{t+1}]$.\n    The stochastic discount factor (SDF) is $m_{t+1} = \\beta g_{t+1}^{-\\gamma}$. Its expectation is:\n    $$ \\mathbb{E}[m_{t+1}] = \\beta \\mathbb{E}[g_{t+1}^{-\\gamma}] $$\n    Using our general formula with $k = -\\gamma$:\n    $$ \\mathbb{E}[g_{t+1}^{-\\gamma}] = \\exp(-\\gamma\\mu + \\frac{1}{2} \\gamma^2 \\sigma^2) \\left[ (1-p) + p(1-b)^{-\\gamma} \\right] $$\n    Therefore, the risk-free rate is given by:\n    $$ R_f = \\frac{1}{\\beta \\exp(-\\gamma\\mu + \\frac{1}{2} \\gamma^2 \\sigma^2) \\left[ (1-p) + p(1-b)^{-\\gamma} \\right]} $$\n\n2.  **Expected Equity Gross Return ($\\mathbb{E}[R_e]$)**\n    The equity claim has a payoff $X_{t+1} = g_{t+1}$. Its price at time $t$ is $P_e = \\mathbb{E}[m_{t+1} X_{t+1}]$.\n    $$ P_e = \\mathbb{E}[\\beta g_{t+1}^{-\\gamma} g_{t+1}] = \\beta \\mathbb{E}[g_{t+1}^{1-\\gamma}] $$\n    Using the general formula with $k = 1-\\gamma$:\n    $$ \\mathbb{E}[g_{t+1}^{1-\\gamma}] = \\exp((1-\\gamma)\\mu + \\frac{1}{2} (1-\\gamma)^2 \\sigma^2) \\left[ (1-p) + p(1-b)^{1-\\gamma} \\right] $$\n    The gross return on equity is $R_e = g_{t+1} / P_e$. Its expectation is:\n    $$ \\mathbb{E}[R_e] = \\frac{\\mathbb{E}[g_{t+1}]}{P_e} = \\frac{\\mathbb{E}[g_{t+1}]}{\\beta \\mathbb{E}[g_{t+1}^{1-\\gamma}]} $$\n    The term $\\mathbb{E}[g_{t+1}]$ is found by setting $k=1$ in the general formula:\n    $$ \\mathbb{E}[g_{t+1}] = \\exp(\\mu + \\frac{1}{2} \\sigma^2) \\left[ (1-p) + p(1-b) \\right] = \\exp(\\mu + \\frac{1}{2} \\sigma^2) (1-pb) $$\n    Substituting the expressions for the expectations, we obtain the formula for the expected equity return.\n\n3.  **Equity Premium ($\\mathbb{E}[R_e] - R_f$)**\n    The equity premium is the difference between the expected gross return on equity and the risk-free gross return:\n    $$ \\text{Equity Premium} = \\mathbb{E}[R_e] - R_f $$\n    This is computed directly from the two previously derived quantities.\n\nThese formulae are implemented to calculate the required triplet $(R_f, \\mathbb{E}[R_e], \\mathbb{E}[R_e] - R_f)$ for each parameter set provided in the test suite.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the rare-disaster asset pricing model for the given test cases.\n    \"\"\"\n    \n    # Test Suite: tuples of (beta, gamma, mu, sigma, p, b)\n    test_cases = [\n        # Case A (no disasters baseline)\n        (0.99, 4.0, 0.005, 0.02, 0.0, 0.3),\n        # Case B (rare moderate disasters)\n        (0.99, 4.0, 0.005, 0.02, 0.01, 0.3),\n        # Case C (rare severe disasters)\n        (0.99, 4.0, 0.005, 0.02, 0.01, 0.5),\n        # Case D (disasters without diffusive risk)\n        (0.99, 4.0, 0.005, 0.0, 0.02, 0.4),\n        # Case E (higher risk aversion with rare moderate disasters)\n        (0.99, 8.0, 0.005, 0.02, 0.01, 0.3),\n    ]\n\n    all_results = []\n\n    def _calculate_moment(k, mu, sigma, p, b):\n        \"\"\"\n        Calculates the k-th moment of the gross consumption growth, E[g^k].\n        \"\"\"\n        lognormal_term = np.exp(k * mu + 0.5 * (k * sigma)**2)\n        disaster_term = (1 - p) + p * ((1 - b)**k)\n        return lognormal_term * disaster_term\n\n    for case in test_cases:\n        beta, gamma, mu, sigma, p, b = case\n\n        # 1. Calculate the Risk-Free Gross Return (Rf)\n        # E[m] = beta * E[g^(-gamma)]\n        e_g_neg_gamma = _calculate_moment(-gamma, mu, sigma, p, b)\n        e_m = beta * e_g_neg_gamma\n        r_f = 1.0 / e_m\n\n        # 2. Calculate the Expected Equity Gross Return (E[Re])\n        # E[Re] = E[g] / P_e, where P_e = beta * E[g^(1-gamma)]\n        \n        # E[g] = E[g^1]\n        e_g = _calculate_moment(1.0, mu, sigma, p, b)\n        \n        # E[g^(1-gamma)]\n        e_g_one_minus_gamma = _calculate_moment(1.0 - gamma, mu, sigma, p, b)\n        \n        # Price of equity, P_e\n        p_e = beta * e_g_one_minus_gamma\n        \n        # E[Re]\n        e_r_e = e_g / p_e\n\n        # 3. Calculate the Equity Premium (EP)\n        equity_premium = e_r_e - r_f\n        \n        result_triplet = [r_f, e_r_e, equity_premium]\n        all_results.append(result_triplet)\n\n    # Format the final output string as required, with no spaces.\n    final_output = str(all_results).replace(\" \", \"\")\n    print(final_output)\n\nsolve()\n```"}, {"introduction": "After exploring the theoretical foundations of the SDF, a crucial next step is to evaluate its empirical performance. This practice guides you through a direct comparison of two workhorse models: the theory-driven consumption-based SDF and an empirically-motivated linear factor-based SDF. You will learn to estimate the parameters of a factor model from asset data and use the root mean squared pricing error to quantify and compare how well each model prices a cross-section of assets, a core skill in empirical finance [@problem_id:2421338].", "id": "2421338", "problem": "You are given a small artificial panel of asset gross returns, traded factor excess returns, a constant risk-free gross return, and aggregate consumption growth, all at a monthly frequency. Your task is to compute, from first principles, pricing errors implied by two distinct Stochastic Discount Factor (SDF) specifications on a cross-section of three industry portfolios, and to compare their root mean squared pricing errors. All returns are dimensionless gross returns. There are no physical units involved.\n\nData for $T=8$ consecutive months:\n- Risk-free gross return (constant across $t$): $R_{f} = 1.0025$.\n- Traded factor excess returns (two factors), for $t=1,\\dots,8$:\n  - Factor $1$: $\\{0.012,\\,0.005,\\,-0.010,\\,0.018,\\,-0.004,\\,0.009,\\,0.002,\\,0.015\\}$.\n  - Factor $2$: $\\{0.008,\\,-0.006,\\,0.004,\\,0.011,\\,-0.003,\\,0.007,\\,-0.002,\\,0.010\\}$.\n  Denote $f_{t} \\in \\mathbb{R}^{2}$ as the vector of the two factor excess returns in month $t$.\n- Gross returns of three industry portfolios, for $t=1,\\dots,8$:\n  - Industry $1$: $\\{1.015,\\,1.010,\\,0.995,\\,1.022,\\,1.000,\\,1.013,\\,1.005,\\,1.020\\}$.\n  - Industry $2$: $\\{1.012,\\,1.008,\\,0.992,\\,1.018,\\,0.998,\\,1.009,\\,1.004,\\,1.017\\}$.\n  - Industry $3$: $\\{1.018,\\,1.012,\\,0.997,\\,1.025,\\,1.003,\\,1.016,\\,1.006,\\,1.022\\}$.\n  Denote $R_{i,t}$ as the gross return of industry $i \\in \\{1,2,3\\}$ in month $t$.\n- Aggregate consumption growth (gross), for $t=1,\\dots,8$: $\\{1.003,\\,1.004,\\,0.999,\\,1.005,\\,1.001,\\,1.004,\\,1.002,\\,1.006\\}$.\n  Denote $g_{t} = C_{t}/C_{t-1}$.\n\nConsider two SDF specifications:\n1. Consumption-based SDF with power utility: for given discount factor $\\beta$ and relative risk aversion $\\gamma$, the SDF is $m^{C}_{t} = \\beta \\cdot g_{t}^{-\\gamma}$. Use $\\beta = 0.99$ and three values of $\\gamma$ as specified in the test suite below.\n2. Linear factor-based SDF: $m^{F}_{t} = a - b^{\\top} f_{t}$, where $a \\in \\mathbb{R}$ and $b \\in \\mathbb{R}^{2}$. Assume the two factors are returns on traded factor-mimicking portfolios in excess of the risk-free asset. Impose the asset pricing Euler equations for the (constant) risk-free asset and the traded factors using sample averages as empirical expectations: $\\mathbb{E}[m^{F}_{t}] \\cdot R_{f} = 1$ and $\\mathbb{E}[m^{F}_{t} f_{t}] = 0$.\n\nFor each SDF specification and for each industry $i \\in \\{1,2,3\\}$, define the pricing error as the sample-mean Euler equation deviation\n$$\n\\epsilon_{i} = \\frac{1}{T} \\sum_{t=1}^{T} m_{t} R_{i,t} - 1.\n$$\nFor each SDF specification, compute the root mean squared pricing error across the three industries,\n$$\n\\text{RMSPE} = \\sqrt{\\frac{1}{3} \\sum_{i=1}^{3} \\epsilon_{i}^{2}}.\n$$\n\nTest suite (three parameter sets for the consumption-based SDF, holding the factor-based SDF fixed by the data and $R_{f}$):\n- Case $1$: $\\gamma = 0.0$.\n- Case $2$: $\\gamma = 2.0$.\n- Case $3$: $\\gamma = 6.0$.\nIn all cases, use $\\beta = 0.99$.\n\nRequired final output format:\n- Your program should produce a single line of output containing a list of three items, one per test case in the order above. Each item must be a list with two floating-point numbers $[\\text{RMSPE}^{C}, \\text{RMSPE}^{F}]$, where $\\text{RMSPE}^{C}$ is the root mean squared pricing error from the consumption-based SDF for that case and $\\text{RMSPE}^{F}$ is the corresponding value from the factor-based SDF (the latter does not depend on $\\gamma$).\n- Round each floating-point number to exactly six digits after the decimal point.\n- The overall output must therefore have the form\n$$\n[[x_{1},y_{1}],[x_{2},y_{2}],[x_{3},y_{3}]],\n$$\nwhere each $x_{k}$ and $y_{k}$ are decimals with exactly six digits after the decimal point and there are no additional characters or whitespace beyond what is needed for a valid list.", "solution": "The problem presented is a well-posed exercise in empirical asset pricing, requiring the computation and comparison of pricing errors from two canonical Stochastic Discount Factor (SDF) models. The data and definitions are complete, scientifically sound, and internally consistent. It is a valid problem. We shall proceed with the solution.\n\nThe core of asset pricing is the Euler equation, which states that for any traded asset with gross return $R_t$, the following holds:\n$$\n1 = \\mathbb{E}[m_t R_t]\n$$\nwhere $m_t$ is the stochastic discount factor. In practice, models for $m_t$ do not perfectly price all assets. The deviation from this equation, the pricing error, is a measure of a model's performance. For a set of $N$ test assets with returns $R_{i,t}$, the pricing error for asset $i$ is defined using the sample analogue of the Euler equation:\n$$\n\\epsilon_i = \\frac{1}{T} \\sum_{t=1}^{T} m_t R_{i,t} - 1\n$$\nA common aggregate measure of performance is the root mean squared pricing error (RMSPE) across the test assets:\n$$\n\\text{RMSPE} = \\sqrt{\\frac{1}{N} \\sum_{i=1}^{N} \\epsilon_i^2}\n$$\nIn this problem, we evaluate two specific models for $m_t$ using a cross-section of $N=3$ industry portfolios.\n\n**1. Consumption-Based SDF ($m^C_t$)**\n\nThis model, rooted in the consumption decisions of a representative agent with power utility, specifies the SDF as:\n$$\nm^C_t = \\beta \\left(\\frac{C_t}{C_{t-1}}\\right)^{-\\gamma} = \\beta g_t^{-\\gamma}\n$$\nHere, $\\beta$ is the agent's subjective time discount factor, $g_t$ is the growth rate of aggregate consumption, and $\\gamma$ is the coefficient of relative risk aversion. The parameters $\\beta=0.99$ and $T=8$ are given, along with the time series for consumption growth $g_t$ and industry returns $R_{i,t}$. The task requires evaluating the model for three distinct values of risk aversion: $\\gamma \\in \\{0.0, 2.0, 6.0\\}$.\n\nFor each given $\\gamma$, the procedure is as follows:\na. Compute the time series for the SDF, $m^C_t$, for $t=1, \\dots, 8$.\nb. For each of the three industry portfolios ($i=1,2,3$), calculate the pricing error $\\epsilon_i^C = \\frac{1}{T} \\sum_{t=1}^{T} m^C_t R_{i,t} - 1$.\nc. Compute the $\\text{RMSPE}^C = \\sqrt{\\frac{1}{3} \\sum_{i=1}^{3} (\\epsilon_i^C)^2}$.\n\n**2. Linear Factor-Based SDF ($m^F_t$)**\n\nThis model posits that the SDF is a linear function of a set of traded factor excess returns, $f_t \\in \\mathbb{R}^K$. Here, $K=2$.\n$$\nm^F_t = a - b^\\top f_t\n$$\nThe scalar parameter $a$ and vector $b \\in \\mathbb{R}^2$ are not given a priori. Instead, they are determined by imposing that the model must correctly price the assets used to construct it. These assets are the risk-free asset, with constant gross return $R_f$, and the factor-mimicking portfolios themselves, which have excess returns $f_t$.\n\nThe pricing conditions, expressed using sample moments as estimators for expectations, are:\n1. For the risk-free asset: $\\mathbb{E}[m^F_t] R_f = 1 \\implies \\left(\\frac{1}{T} \\sum_{t=1}^{T} m^F_t\\right) R_f = 1$.\n2. For the factor excess returns: $\\mathbb{E}[m^F_t f_t] = \\vec{0} \\implies \\frac{1}{T} \\sum_{t=1}^{T} m^F_t f_t = \\vec{0}$.\n\nSubstituting the definition of $m^F_t$ into these conditions yields a system of equations for $a$ and $b$. Let $\\bar{f} = \\frac{1}{T}\\sum_t f_t$ be the sample mean of the factors and $\\overline{ff^\\top} = \\frac{1}{T}\\sum_t f_t f_t^\\top$ be the second-moment matrix.\n\nFrom condition 1:\n$$\n\\frac{1}{T} \\sum_{t=1}^{T} (a - b^\\top f_t) = \\frac{1}{R_f} \\implies a - b^\\top \\bar{f} = \\frac{1}{R_f} \\quad (*).\n$$\nFrom condition 2:\n$$\n\\frac{1}{T} \\sum_{t=1}^{T} (a - b^\\top f_t) f_t = \\vec{0} \\implies a \\bar{f} - \\overline{ff^\\top} b = \\vec{0} \\quad (**).\n$$\nFrom $(*)$, we express $a = \\frac{1}{R_f} + b^\\top \\bar{f}$. Substituting this into $(**)$:\n$$\n\\left(\\frac{1}{R_f} + b^\\top \\bar{f}\\right) \\bar{f} - \\overline{ff^\\top} b = \\vec{0}\n$$\n$$\n\\frac{1}{R_f}\\bar{f} + (\\bar{f} \\bar{f}^\\top) b - \\overline{ff^\\top} b = \\vec{0}\n$$\nRearranging to solve for $b$:\n$$\n(\\overline{ff^\\top} - \\bar{f} \\bar{f}^\\top) b = \\frac{1}{R_f} \\bar{f}\n$$\nThe term $(\\overline{ff^\\top} - \\bar{f} \\bar{f}^\\top)$ is precisely the sample covariance matrix of the factors, $\\Sigma_{ff}$. Thus, we have a linear system for the vector $b$:\n$$\n\\Sigma_{ff} b = \\frac{1}{R_f} \\bar{f}\n$$\nThis system can be solved for $b$, assuming $\\Sigma_{ff}$ is invertible. With $b$ determined, $a$ is found from equation $(*)$.\n\nThe procedure for the factor model is:\na. Compute the sample mean vector $\\bar{f}$ and sample covariance matrix $\\Sigma_{ff}$ from the provided factor data $f_t$.\nb. Solve the linear system $\\Sigma_{ff} b = \\frac{1}{R_f} \\bar{f}$ for the vector of factor loadings $b$.\nc. Calculate the intercept $a = \\frac{1}{R_f} + b^\\top \\bar{f}$.\nd. Construct the SDF time series $m^F_t = a - b^\\top f_t$ for $t=1, \\dots, 8$.\ne. For each of the three industry portfolios ($i=1,2,3$), calculate the pricing error $\\epsilon_i^F = \\frac{1}{T} \\sum_{t=1}^{T} m^F_t R_{i,t} - 1$.\nf. Compute the $\\text{RMSPE}^F = \\sqrt{\\frac{1}{3} \\sum_{i=1}^{3} (\\epsilon_i^F)^2}$. Since the factor model's parameters do not depend on $\\gamma$, this value will be the same for all three test cases.\n\nThe final output will list the pairs $[\\text{RMSPE}^C, \\text{RMSPE}^F]$ for each specified value of $\\gamma$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes and compares the Root Mean Squared Pricing Errors (RMSPE)\n    for a consumption-based SDF and a linear factor-based SDF.\n    \"\"\"\n    \n    # 1. Define Givens from the problem statement\n    \n    # Constants and parameters\n    T = 8\n    R_f = 1.0025\n    beta = 0.99\n    gammas = [0.0, 2.0, 6.0]\n\n    # Time series data as numpy arrays\n    # Factor excess returns, shape (T, 2)\n    factors = np.array([\n        [0.012, 0.008],\n        [0.005, -0.006],\n        [-0.010, 0.004],\n        [0.018, 0.011],\n        [-0.004, -0.003],\n        [0.009, 0.007],\n        [0.002, -0.002],\n        [0.015, 0.010]\n    ])\n\n    # Industry portfolio gross returns, shape (T, 3)\n    industry_returns = np.array([\n        [1.015, 1.012, 1.018],\n        [1.010, 1.008, 1.012],\n        [0.995, 0.992, 0.997],\n        [1.022, 1.018, 1.025],\n        [1.000, 0.998, 1.003],\n        [1.013, 1.009, 1.016],\n        [1.005, 1.004, 1.006],\n        [1.020, 1.017, 1.022]\n    ])\n\n    # Aggregate consumption growth, shape (T,)\n    cons_growth = np.array([1.003, 1.004, 0.999, 1.005, 1.001, 1.004, 1.002, 1.006])\n\n    def calculate_rmspe(m, R):\n        \"\"\"\n        Calculates the RMSPE given an SDF vector and a matrix of asset returns.\n        \n        Args:\n            m (np.ndarray): The SDF time series, shape (T,).\n            R (np.ndarray): The asset returns time series, shape (T, N_assets).\n            \n        Returns:\n            float: The root mean squared pricing error.\n        \"\"\"\n        # Reshape m to (T, 1) for broadcasting\n        m_reshaped = m[:, np.newaxis]\n        \n        # Calculate pricing products m*R for each asset and time point\n        pricing_products = m_reshaped * R\n        \n        # Compute sample mean of m*R for each asset\n        mean_pricing_products = np.mean(pricing_products, axis=0)\n        \n        # Calculate pricing errors (alpha)\n        pricing_errors = mean_pricing_products - 1.0\n        \n        # Calculate root mean squared pricing error\n        rmspe = np.sqrt(np.mean(pricing_errors**2))\n        \n        return rmspe\n\n    # 2. Compute parameters and RMSPE for the Linear Factor-Based SDF\n    \n    # Sample mean of factor excess returns\n    f_mean = np.mean(factors, axis=0)\n    \n    # Sample covariance matrix of factors (ddof=0 for population formula 1/T)\n    f_cov = np.cov(factors, rowvar=False, ddof=0)\n    \n    # Solve the system Sigma_ff * b = (1/R_f) * f_mean for b\n    b = np.linalg.solve(f_cov, f_mean / R_f)\n    \n    # Calculate the intercept a\n    a = 1.0 / R_f + np.dot(b, f_mean)\n    \n    # Construct the SDF time series for the factor model\n    m_factor = a - factors @ b\n    \n    # Calculate the RMSPE for the factor model\n    rmspe_factor = calculate_rmspe(m_factor, industry_returns)\n\n    # 3. Compute RMSPE for the Consumption-Based SDF for each gamma\n    \n    results = []\n    for gamma in gammas:\n        # Construct the SDF time series for the consumption model\n        m_consumption = beta * (cons_growth ** (-gamma))\n        \n        # Calculate the RMSPE for the consumption model\n        rmspe_consumption = calculate_rmspe(m_consumption, industry_returns)\n        \n        # Store the pair of results for this case\n        results.append([rmspe_consumption, rmspe_factor])\n\n    # 4. Format and print the final output\n    \n    formatted_results = []\n    for res_pair in results:\n        # Format each number to exactly six decimal places\n        formatted_pair = f'[{res_pair[0]:.6f},{res_pair[1]:.6f}]'\n        formatted_results.append(formatted_pair)\n        \n    # Join the formatted pairs into the final string\n    final_output = f\"[{','.join(formatted_results)}]\"\n    \n    print(final_output)\n\nsolve()\n```"}, {"introduction": "While specific parametric models are powerful, they risk being misspecified; a more robust approach is to test the fundamental properties of the SDF with fewer assumptions. This exercise introduces the \"pricing kernel puzzle,\" a famous disconnect between theory and data, by having you estimate the SDF non-parametrically and test its predicted monotonicity with respect to aggregate wealth. This practice teaches a powerful estimation technique and encourages critical thinking about the limits of standard financial theories when confronted with empirical evidence [@problem_id:2421410].", "id": "2421410", "problem": "You are asked to investigate the so-called pricing kernel puzzle by testing whether an empirically estimated stochastic discount factor (also called the pricing kernel) is monotonically decreasing in aggregate wealth, as predicted by representative-agent models with concave utility. You must implement a complete program that estimates the stochastic discount factor from synthetic asset returns and then evaluates monotonicity against aggregate wealth for a provided test suite.\n\nStart from the fundamental intertemporal asset-pricing condition that for each asset $i$ with gross return $R_i$, there exists a stochastic discount factor $m$ such that the sample Euler equation holds:\n$$\n\\mathbb{E}[\\,m R_i\\,] = 1,\n$$\nwhere $\\mathbb{E}[\\cdot]$ denotes the empirical expectation over a finite number of equally likely states.\n\nIn a finite-state economy with $S$ states, let $m$ be represented by the length-$S$ vector $m = (m_1,\\dots,m_S)^\\top$ and let the returns across $N$ assets be given by the $S \\times N$ matrix $R$ whose $(s,i)$ entry is $R_{s,i}$. Under equal state probabilities $p_s = 1/S$ for all $s$, the Euler equation for all $i \\in \\{1,\\dots,N\\}$ can be written as the linear system\n$$\n\\frac{1}{S} R^\\top m = \\mathbf{1}_N,\n$$\nwhere $\\mathbf{1}_N$ is the length-$N$ vector of ones. Among all $m$ that satisfy this system, define the empirical estimator as the vector with minimum Euclidean norm:\n$$\n\\text{find } m \\text{ that minimizes } \\|m\\|_2 \\text{ subject to } \\frac{1}{S} R^\\top m = \\mathbf{1}_N.\n$$\n\nYour program must:\n1. For each test case below, construct a returns matrix $R$ deterministically from a target stochastic discount factor $m^{\\star}$ using the following construction. Fix $S = 4$ and $N = 4$, and let $\\epsilon = 0.45$. Let $\\mathbf{1}_4$ be the $4$-vector of ones. Define four direction vectors $v_j \\in \\mathbb{R}^4$ that are orthogonal to $m^{\\star}$ under the standard dot product, that is, $m^{\\star \\top} v_j = 0$ for all $j \\in \\{1,2,3,4\\}$. Use:\n   - $v_1 = (1,\\; -m^{\\star}_1/m^{\\star}_2,\\; 0,\\; 0)^\\top$,\n   - $v_2 = (1,\\; 0,\\; -m^{\\star}_1/m^{\\star}_3,\\; 0)^\\top$,\n   - $v_3 = (1,\\; 0,\\; 0,\\; -m^{\\star}_1/m^{\\star}_4)^\\top$,\n   - $v_4 = (0,\\; 1,\\; -m^{\\star}_2/m^{\\star}_3,\\; 0)^\\top$.\n   Construct each return column as\n   $$\n   R_{:,j} = \\mathbf{1}_4 + \\epsilon\\, v_j.\n   $$\n   This guarantees $m^{\\star \\top} R_{:,j} = \\sum_{s=1}^4 m^{\\star}_s$ for all $j$. Impose the normalization $\\sum_{s=1}^4 m^{\\star}_s = 4$ so that $m^{\\star \\top} R_{:,j} = 4$ for every $j$, which makes $m^{\\star}$ a feasible solution to the Euler equations with equal state probabilities.\n\n2. Given $R$, compute the minimum-norm solution $\\hat m$ to the linear system $\\frac{1}{4} R^\\top m = \\mathbf{1}_4$.\n\n3. For the aggregate wealth vector $W \\in \\mathbb{R}^4$ provided in each test case, evaluate monotonicity as follows. The theoretical prediction is that the stochastic discount factor is decreasing in aggregate wealth. Define the set of comparable state pairs\n   $$\n   \\mathcal{P} = \\{(i,j) \\in \\{1,2,3,4\\}^2 \\;|\\; i \\neq j, \\; W_i > W_j\\}.\n   $$\n   A pair $(i,j) \\in \\mathcal{P}$ is a violation if $\\hat m_i \\ge \\hat m_j$. Let $V$ be the number of violations and $T = |\\mathcal{P}|$ be the number of comparable pairs. The violation rate is defined as the fraction $V/T$. Use a numerical tolerance $\\tau = 10^{-10}$ so that the inequality $\\hat m_i \\ge \\hat m_j$ is interpreted as $\\hat m_i - \\hat m_j \\ge -\\tau$.\n\n4. For each test case, compute and report the violation rate as a real number. The final output must be a single line containing the list of violation rates for all test cases, in order, enclosed in square brackets and separated by commas, for example, $[0.0,0.5,0.0]$. Round each violation rate to exactly six decimal places when printing.\n\nTest suite:\n- Case A (strictly decreasing target stochastic discount factor consistent with increasing wealth):\n  - Wealth: $W = (0.9,\\; 1.0,\\; 1.1,\\; 1.2)^\\top$.\n  - Target: $m^{\\star} = (1.4,\\; 1.1,\\; 0.8,\\; 0.7)^\\top$ with $\\sum_s m^{\\star}_s = 4$.\n- Case B (hump-shaped target implying non-monotonicity):\n  - Wealth: $W = (0.9,\\; 1.0,\\; 1.1,\\; 1.2)^\\top$.\n  - Target: $m^{\\star} = (1.0,\\; 1.5,\\; 0.9,\\; 0.6)^\\top$ with $\\sum_s m^{\\star}_s = 4$.\n- Case C (ties in wealth; comparable pairs exclude equal-wealth states):\n  - Wealth: $W = (1.0,\\; 1.0,\\; 1.2,\\; 1.3)^\\top$.\n  - Target: $m^{\\star} = (1.1,\\; 1.3,\\; 0.9,\\; 0.7)^\\top$ with $\\sum_s m^{\\star}_s = 4$.\n- Case D (near-monotone with a local inversion):\n  - Wealth: $W = (0.9,\\; 1.0,\\; 1.1,\\; 1.2)^\\top$.\n  - Target: $m^{\\star} = (1.2,\\; 0.98,\\; 1.0,\\; 0.82)^\\top$ with $\\sum_s m^{\\star}_s = 4$.\n\nYour program should produce a single line of output containing the four violation rates, in the order A, B, C, D, as a comma-separated list enclosed in square brackets. No other output is permitted. All computations are dimensionless; there are no physical units or angles involved.", "solution": "The problem statement is subjected to rigorous validation before any attempt at a solution is made. A problem must be self-contained, scientifically sound, and logically consistent.\n\nFirst, we extract the given information and constraints as stated.\nGivens:\n1.  **Asset Pricing Framework**: The fundamental sample Euler equation is $\\mathbb{E}[\\,m R_i\\,] = 1$ for each asset $i$, where $m$ is the stochastic discount factor (SDF), and $R_i$ is the gross return.\n2.  **Finite-State Model**: There are $S$ states and $N$ assets. The state probabilities are uniform, $p_s = 1/S$. The returns are given by an $S \\times N$ matrix $R$. The SDF is a vector $m \\in \\mathbb{R}^S$. The Euler equations form a linear system: $\\frac{1}{S} R^\\top m = \\mathbf{1}_N$.\n3.  **SDF Estimator**: The empirical SDF estimator, $\\hat m$, is defined as the minimum Euclidean norm solution to the linear system: minimize $\\|m\\|_2$ subject to $\\frac{1}{S} R^\\top m = \\mathbf{1}_N$.\n4.  **Problem Parameters**: The model is specified with $S=4$ states and $N=4$ assets.\n5.  **Returns Matrix Construction**: The returns matrix $R$ is constructed from a target SDF $m^\\star \\in \\mathbb{R}^4$ that satisfies the normalization $\\sum_{s=1}^4 m^{\\star}_s = 4$. The columns of $R$ are given by $R_{:,j} = \\mathbf{1}_4 + \\epsilon v_j$ for $j \\in \\{1,2,3,4\\}$, where $\\epsilon = 0.45$ and the vectors $v_j$ are constructed to be orthogonal to $m^\\star$ ($m^{\\star \\top} v_j = 0$):\n    -   $v_1 = (1,\\; -m^{\\star}_1/m^{\\star}_2,\\; 0,\\; 0)^\\top$\n    -   $v_2 = (1,\\; 0,\\; -m^{\\star}_1/m^{\\star}_3,\\; 0)^\\top$\n    -   $v_3 = (1,\\; 0,\\; 0,\\; -m^{\\star}_1/m^{\\star}_4)^\\top$\n    -   $v_4 = (0,\\; 1,\\; -m^{\\star}_2/m^{\\star}_3,\\; 0)^\\top$\n6.  **Monotonicity Test**: The estimated SDF, $\\hat m$, is tested for monotonicity with respect to an aggregate wealth vector $W \\in \\mathbb{R}^4$.\n    -   The set of comparable state pairs is $\\mathcal{P} = \\{(i,j) \\in \\{1,2,3,4\\}^2 \\;|\\; i \\neq j, \\; W_i > W_j\\}$.\n    -   A violation occurs for a pair $(i,j) \\in \\mathcal{P}$ if $\\hat m_i \\ge \\hat m_j$.\n    -   Numerical tolerance for the check is $\\tau = 10^{-10}$, so a violation is registered if $\\hat m_i - \\hat m_j \\ge -\\tau$.\n    -   The violation rate is $V/T$, where $V$ is the count of violations and $T=|\\mathcal{P}|$.\n7.  **Test Suite**:\n    -   Case A: $W = (0.9,\\; 1.0,\\; 1.1,\\; 1.2)^\\top$, $m^{\\star} = (1.4,\\; 1.1,\\; 0.8,\\; 0.7)^\\top$.\n    -   Case B: $W = (0.9,\\; 1.0,\\; 1.1,\\; 1.2)^\\top$, $m^{\\star} = (1.0,\\; 1.5,\\; 0.9,\\; 0.6)^\\top$.\n    -   Case C: $W = (1.0,\\; 1.0,\\; 1.2,\\; 1.3)^\\top$, $m^{\\star} = (1.1,\\; 1.3,\\; 0.9,\\; 0.7)^\\top$.\n    -   Case D: $W = (0.9,\\; 1.0,\\; 1.1,\\; 1.2)^\\top$, $m^{\\star} = (1.2,\\; 0.98,\\; 1.0,\\; 0.82)^\\top$.\n\nValidation based on these givens confirms that the problem is scientifically grounded in asset pricing theory, objective, and well-posed. The construction of the returns matrix $R$ guarantees that the linear system for $m$ is consistent, as the target $m^\\star$ is a feasible solution. This ensures the existence of a unique minimum-norm solution. All required data and definitions are provided. The problem is deemed valid. We proceed to the solution.\n\nThe core of the problem is to solve the constrained optimization problem:\n$$\n\\text{minimize } \\frac{1}{2} m^\\top m \\quad \\text{subject to} \\quad A m = b\n$$\nwhere $A = \\frac{1}{S} R^\\top$ is an $N \\times S$ matrix, $m \\in \\mathbb{R}^S$, and $b = \\mathbf{1}_N \\in \\mathbb{R}^N$. For this problem, we have $S=N=4$.\n\nThe unique minimum-norm solution to a consistent linear system $Am=b$ is given by $\\hat m = A^\\dagger b$, where $A^\\dagger$ is the Moore-Penrose pseudoinverse of $A$. This result from linear algebra provides a direct method for computing the estimated SDF, $\\hat m$.\n\nThe procedure for each test case is as follows:\n\n1.  **Construct the Returns Matrix $R$**:\n    For a given test case with a target SDF $m^\\star = (m^\\star_1, m^\\star_2, m^\\star_3, m^\\star_4)^\\top$, we first construct the four auxiliary vectors $v_1, v_2, v_3, v_4 \\in \\mathbb{R}^4$ according to the specified formulae. The components of $m^\\star$ in all test cases are non-zero, so the definitions of the $v_j$ are well-defined. We then form the $4 \\times 4$ matrix $V = [v_1, v_2, v_3, v_4]$ whose columns are these vectors. The $4 \\times 4$ returns matrix $R$ is then assembled. The $j$-th column of $R$ is $R_{:,j} = \\mathbf{1}_4 + \\epsilon v_j$, where $\\mathbf{1}_4$ is a vector of ones and $\\epsilon = 0.45$. This can be written compactly as $R = J + \\epsilon V$, where $J$ is the $4 \\times 4$ matrix of all ones.\n\n2.  **Estimate the Stochastic Discount Factor $\\hat m$**:\n    With $R$ constructed, we form the matrix $A = \\frac{1}{4}R^\\top$. The system to be solved is $Am = \\mathbf{1}_4$. We compute the Moore-Penrose pseudoinverse $A^\\dagger$ and then find the estimated SDF as $\\hat m = A^\\dagger \\mathbf{1}_4$. It must be emphasized that the minimum-norm solution $\\hat m$ is not, in general, equal to the target vector $m^\\star$. The vector $m^\\star$ is merely one point in the affine subspace of solutions, whereas $\\hat m$ is the unique element of this subspace closest to the origin.\n\n3.  **Evaluate Monotonicity and Compute Violation Rate**:\n    Given the wealth vector $W = (W_1, W_2, W_3, W_4)^\\top$ and the estimated SDF $\\hat m = (\\hat m_1, \\hat m_2, \\hat m_3, \\hat m_4)^\\top$, we must assess whether $\\hat m$ is a decreasing function of $W$. We iterate through all distinct pairs of state indices $(i, j)$ where $i,j \\in \\{1, 2, 3, 4\\}$.\n    -   We first count the total number of comparable pairs, $T$. A pair $(i, j)$ is comparable if $W_i > W_j$. We find all such ordered pairs.\n    -   _Note that we use $0$-based indexing in implementation, so we are comparing $W_i$ and $W_j$ for $i,j \\in \\{0, 1, 2, 3\\}$._\n    -   For each comparable pair where $W_i > W_j$, we check for a monotonicity violation. A violation is defined to occur if the SDF does not strictly decrease, i.e., $\\hat m_i \\ge \\hat m_j$. We implement this check using the provided numerical tolerance $\\tau = 10^{-10}$ as $\\hat m_i - \\hat m_j \\ge -\\tau$.\n    -   We count the total number of such violations, $V$.\n    -   The violation rate is the ratio $V/T$. If $T=0$, the rate is $0$.\n\nThis entire procedure is encapsulated in a program which, for each test case, computes and reports the violation rate, rounded to six decimal places.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the pricing kernel puzzle problem for a suite of test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: Strictly decreasing target SDF\n        {\n            \"W\": np.array([0.9, 1.0, 1.1, 1.2]),\n            \"m_star\": np.array([1.4, 1.1, 0.8, 0.7]),\n        },\n        # Case B: Hump-shaped target SDF\n        {\n            \"W\": np.array([0.9, 1.0, 1.1, 1.2]),\n            \"m_star\": np.array([1.0, 1.5, 0.9, 0.6]),\n        },\n        # Case C: Ties in wealth\n        {\n            \"W\": np.array([1.0, 1.0, 1.2, 1.3]),\n            \"m_star\": np.array([1.1, 1.3, 0.9, 0.7]),\n        },\n        # Case D: Near-monotone target SDF\n        {\n            \"W\": np.array([0.9, 1.0, 1.1, 1.2]),\n            \"m_star\": np.array([1.2, 0.98, 1.0, 0.82]),\n        },\n    ]\n\n    results = []\n    \n    # Constants from the problem statement\n    S = 4\n    N = 4\n    epsilon = 0.45\n    tau = 1e-10\n\n    for case in test_cases:\n        W = case[\"W\"]\n        m_star = case[\"m_star\"]\n\n        # 1. Construct the returns matrix R\n        # Define the orthogonal vectors v_j\n        # Indices are 0-based for array access.\n        v1 = np.array([1.0, -m_star[0] / m_star[1], 0.0, 0.0])\n        v2 = np.array([1.0, 0.0, -m_star[0] / m_star[2], 0.0])\n        v3 = np.array([1.0, 0.0, 0.0, -m_star[0] / m_star[3]])\n        v4 = np.array([0.0, 1.0, -m_star[1] / m_star[2], 0.0])\n        \n        # Stack vectors into a matrix V\n        V = np.column_stack([v1, v2, v3, v4])\n        \n        # Construct R = J + epsilon * V, where J is a matrix of ones\n        R = np.ones((S, N)) + epsilon * V\n\n        # 2. Compute the minimum-norm SDF estimator m_hat\n        # System is (1/S) * R^T * m = 1_N\n        A = (1 / S) * R.T\n        b = np.ones(N)\n        \n        # The minimum-norm solution is m_hat = A_pinv * b\n        A_pinv = np.linalg.pinv(A)\n        m_hat = A_pinv @ b\n\n        # 3. Evaluate monotonicity and compute violation rate\n        num_comparable_pairs = 0\n        num_violations = 0\n        \n        for i in range(S):\n            for j in range(S):\n                if i == j:\n                    continue\n                \n                # A pair is comparable if wealth levels are different\n                if W[i] > W[j]:\n                    num_comparable_pairs += 1\n                    # A violation occurs if SDF is not strictly decreasing\n                    if m_hat[i] - m_hat[j] >= -tau:\n                        num_violations += 1\n        \n        if num_comparable_pairs == 0:\n            violation_rate = 0.0\n        else:\n            violation_rate = num_violations / num_comparable_pairs\n            \n        results.append(f\"{violation_rate:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"}]}