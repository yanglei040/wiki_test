{"hands_on_practices": [{"introduction": "Explicit methods are often the first choice for solving partial differential equations due to their implementation simplicity, but their utility is governed by strict stability conditions that link the time step to the spatial grid size. This exercise challenges you to apply an explicit scheme to a non-uniform grid, a practical technique used to increase resolution around key financial points like the strike price, where the solution changes most rapidly. Deriving the adapted stability condition from first principles for this non-trivial grid configuration will deepen your understanding of how stability is fundamentally linked to the discrete operator's coefficients [@problem_id:2391401].", "id": "2391401", "problem": "You are asked to design, analyze, and implement an explicit time-marching method for the Black–Scholes partial differential equation on a non-uniform spatial grid that is denser around the strike price. Your task has three parts: (i) derive a stable explicit finite-difference scheme on a non-uniform grid for the forward-in-time formulation in time-to-maturity, (ii) derive an adapted stability condition expressed in terms of the local mesh widths, and (iii) implement a complete, runnable program that evaluates the method on a small suite of test cases and prints the results in the required format.\n\nStart from the following base, which is standard in computational finance under the risk-neutral measure. Let $V(S,\\tau)$ denote the option value as a function of the underlying asset price $S \\ge 0$ and time-to-maturity $\\tau \\in [0,T]$, with volatility $\\sigma > 0$, risk-free rate $r \\ge 0$, and maturity $T>0$. After the standard change of variables from calendar time $t$ to time-to-maturity $\\tau = T - t$, the Black–Scholes equation for a European call is the linear parabolic equation\n$$\n\\frac{\\partial V}{\\partial \\tau}(S,\\tau) \\;=\\; \\frac{1}{2}\\,\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2}(S,\\tau)\\;+\\; r S \\frac{\\partial V}{\\partial S}(S,\\tau)\\;-\\; r\\,V(S,\\tau),\n$$\nfor $S \\in (0,S_{\\max})$ and $\\tau \\in (0,T]$, with initial condition (payoff at $\\tau = 0$)\n$$\nV(S,0) \\;=\\; \\max(S-K, 0),\n$$\nand boundary conditions\n$$\nV(0,\\tau) \\;=\\; 0,\\qquad V(S_{\\max},\\tau) \\;=\\; S_{\\max} - K\\,e^{-r \\tau},\n$$\nfor $\\tau \\in [0,T]$, where $K>0$ is the strike and $S_{\\max} > K$ is a sufficiently large truncation of the semi-infinite domain.\n\nSpatial discretization. Consider a strictly increasing, non-uniform grid $\\{S_i\\}_{i=0}^M$ with $S_0=0$, $S_M=S_{\\max}$, and with a dense region around $S=K$ constructed as follows. For given fine spacing $h_f>0$, coarse spacing $h_c>0$, and a half-width $w>0$, define the central strip $[K-w,K+w]$. The grid is piecewise-uniform with spacing $h_c$ on $[0,K-w]$ and $[K+w,S_{\\max}]$, and spacing $h_f$ on $[K-w,K+w]$, adjusted at segment joins so that $K-w$ and $K+w$ are grid nodes. Let $h_{i-1} = S_i - S_{i-1}$ and $h_i = S_{i+1} - S_i$ denote the left and right local mesh widths at an interior node $i \\in \\{1,\\dots,M-1\\}$.\n\nTime discretization and spatial finite differences. Use explicit forward Euler in time with a step size $\\Delta \\tau > 0$. On the non-uniform grid, approximate the second derivative at interior nodes by the standard non-uniform central formula:\n$$\n\\left.\\frac{\\partial^2 V}{\\partial S^2}\\right|_{S=S_i}\n\\;\\approx\\; \\frac{2}{h_{i-1}+h_i} \\left(\\frac{V_{i+1}-V_i}{h_i} \\;-\\; \\frac{V_i - V_{i-1}}{h_{i-1}}\\right).\n$$\nApproximate the first derivative by the upwind choice consistent with the transport direction in the forward-in-$\\tau$ equation. Because the convection coefficient in the forward equation is $+r S$, adopt the forward (downstream) difference,\n$$\n\\left.\\frac{\\partial V}{\\partial S}\\right|_{S=S_i}\n\\;\\approx\\; \\frac{V_{i+1}-V_i}{h_i},\n$$\nto ensure monotonicity of the explicit update for $r \\ge 0$ and $S \\ge 0$. The explicit update at interior nodes is then\n$$\nV_i^{n+1} \\;=\\; V_i^n \\;+\\; \\Delta \\tau \\left[\n\\frac{1}{2}\\sigma^2 S_i^2 \\cdot \\frac{2}{h_{i-1}+h_i} \\left(\\frac{V_{i+1}^n - V_i^n}{h_i} - \\frac{V_i^n - V_{i-1}^n}{h_{i-1}}\\right)\n\\;+\\; r S_i \\cdot \\frac{V_{i+1}^n - V_i^n}{h_i}\n\\;-\\; r V_i^n\n\\right],\n$$\nwith boundary nodes set from the boundary conditions at each time level. Here $V_i^n \\approx V(S_i, n\\,\\Delta \\tau)$.\n\nStability requirement to be derived. For an explicit method on a non-uniform grid, stability and monotonicity can be enforced by requiring that the update at each interior node is a convex combination of $V_{i-1}^n$, $V_i^n$, and $V_{i+1}^n$ with nonnegative weights and a nonnegative remainder due solely to the reaction term $-r V$. Derive, from first principles and the discrete coefficients above, a sufficient local constraint on $\\Delta \\tau$ that guarantees nonnegativity of the update weights at every interior node $i$. Express the adapted stability bound as\n$$\n\\Delta \\tau \\;\\le\\; \\min_{i=1,\\dots,M-1} \\frac{1}{\\Lambda_i},\n$$\nfor an explicit formula of $\\Lambda_i$ in terms of $\\sigma$, $r$, $S_i$, $h_{i-1}$, and $h_i$, deduced from the discrete operator.\n\nImplementation requirements. Implement the scheme described above as a complete, runnable program that:\n- constructs the piecewise-uniform non-uniform grid defined by $h_f$, $h_c$, and $w$;\n- computes the adapted stability bound $\\Delta \\tau_{\\max}$ from your derived $\\Lambda_i$;\n- chooses a time step $\\Delta \\tau = \\theta\\,\\Delta \\tau_{\\max}$ with a safety factor $\\theta \\in (0,1)$ and marches from $\\tau=0$ to $\\tau=T$; in practice, set the number of steps $N_\\tau = \\lceil T/(\\theta\\,\\Delta \\tau_{\\max}) \\rceil$ and then use the uniform step $\\Delta \\tau = T/N_\\tau$;\n- enforces the boundary conditions at each time step and uses the initial condition at $\\tau=0$;\n- for given $S_0$, returns the option value at $S=S_0$ via piecewise-linear interpolation on the final grid.\n\nTesting, units, and output format. Use the following test suite. All scalar inputs are dimensionless standard financial parameters; you must output numeric results as specified, with no units. For each test, compute the specified output and aggregate into a single printed line as described.\n\n- Test A (accuracy near the strike, “happy path”): $K=100$, $r=0.05$, $\\sigma=0.2$, $T=1.0$, $S_{\\max}=400$, central band width $w=20$, fine spacing $h_f=1.0$, coarse spacing $h_c=5.0$, safety factor $\\theta=0.9$, evaluation spot $S_0=K$. Output the absolute error between your numerical price and the analytical Black–Scholes call price at $S_0$, as a float.\n\n- Test B (stability check at a slightly violated bound): Use the same parameters as Test A. Compute $\\Delta \\tau_{\\max}$ from your stability formula and then check the nonnegativity of the explicit update weights at every interior node if one were to use $\\Delta \\tau = 1.05\\,\\Delta \\tau_{\\max}$. Output a boolean indicating whether all update weights remain nonnegative under this larger step (this should be false for a correct stability bound).\n\n- Test C (denser central grid and a sub-strike evaluation): $K=100$, $r=0.05$, $\\sigma=0.2$, $T=0.5$, $S_{\\max}=400$, $w=30$, $h_f=0.5$, $h_c=5.0$, $\\theta=0.9$, evaluation spot $S_0=80$. Output the absolute error between your numerical price and the analytical Black–Scholes call price at $S_0$, as a float.\n\n- Test D (reported stability scale under higher volatility): $K=100$, $r=0.02$, $\\sigma=0.5$, $T=1.0$, $S_{\\max}=400$, $w=20$, $h_f=1.0$, $h_c=5.0$. Output $\\Delta \\tau_{\\max}$ as a float computed from your stability formula.\n\nFinal output format. Your program should produce a single line of output containing the results for Tests A–D as a comma-separated list enclosed in square brackets and in the exact order [A,B,C,D]. For example, the printed line must look like\n\"[A_result,B_result,C_result,D_result]\"\nwith no additional text. All numbers must be printed in standard Python string form, booleans as \"True\" or \"False\".\n\nNote on angles and units. No angular quantities are involved. All outputs must be dimensionless numbers. Percentages, if any, must be expressed as decimals, but none are requested here.", "solution": "The problem as stated constitutes a well-posed, scientifically grounded exercise in the application of numerical methods to partial differential equations in finance. All parameters, equations, and boundary conditions are provided, and the task is clearly defined. The problem is therefore valid, and we proceed to a complete solution.\n\nThe problem requires the design, analysis, and implementation of an explicit finite-difference scheme for the Black-Scholes equation on a non-uniform spatial grid. The solution is presented in three parts, corresponding to the tasks specified.\n\n### Part (i): The Explicit Finite-Difference Scheme\n\nThe governing equation is the forward Black-Scholes PDE for a European option value $V(S,\\tau)$, where $S$ is the asset price and $\\tau$ is the time-to-maturity:\n$$\n\\frac{\\partial V}{\\partial \\tau} = \\frac{1}{2}\\,\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} + r S \\frac{\\partial V}{\\partial S} - r\\,V\n$$\nThis is defined on the domain $(S, \\tau) \\in (0, S_{\\max}) \\times (0, T]$. The initial condition at $\\tau=0$ is the payoff function, $V(S,0) = \\max(S-K, 0)$ for a call option. The boundary conditions are $V(0, \\tau) = 0$ and $V(S_{\\max}, \\tau) = S_{\\max} - Ke^{-r\\tau}$.\n\nThe spatial domain $[0, S_{\\max}]$ is discretized using a non-uniform grid $\\{S_i\\}_{i=0}^M$. At an interior node $S_i$, the local mesh widths are $h_{i-1} = S_i - S_{i-1}$ and $h_i = S_{i+1} - S_i$. The time domain $[0, T]$ is discretized with a uniform step $\\Delta \\tau$. Let $V_i^n \\approx V(S_i, n\\Delta \\tau)$.\n\nThe problem prescribes specific finite-difference approximations. The time derivative is approximated using explicit forward Euler. The spatial derivatives are approximated as follows:\n- Second derivative (central difference on non-uniform grid):\n$$\n\\left.\\frac{\\partial^2 V}{\\partial S^2}\\right|_{S_i} \\approx \\frac{2}{h_{i-1}+h_i} \\left(\\frac{V_{i+1}^n-V_i^n}{h_i} - \\frac{V_i^n - V_{i-1}^n}{h_{i-1}}\\right)\n$$\n- First derivative (forward difference, as specified):\n$$\n\\left.\\frac{\\partial V}{\\partial S}\\right|_{S_i} \\approx \\frac{V_{i+1}^n-V_i^n}{h_i}\n$$\nSubstituting these expressions into the PDE yields the fully discrete explicit update equation for interior nodes $i \\in \\{1, \\dots, M-1\\}$:\n$$\n\\frac{V_i^{n+1} - V_i^n}{\\Delta \\tau} = \\frac{1}{2}\\sigma^2 S_i^2 \\left[ \\frac{2}{h_{i-1}+h_i} \\left(\\frac{V_{i+1}^n-V_i^n}{h_i} - \\frac{V_i^n - V_{i-1}^n}{h_{i-1}}\\right) \\right] + r S_i \\left[ \\frac{V_{i+1}^n-V_i^n}{h_i} \\right] - rV_i^n\n$$\nRearranging for $V_i^{n+1}$ gives the final form of the scheme as stated in the problem:\n$$\nV_i^{n+1} = V_i^n + \\Delta \\tau \\left[ \\frac{\\sigma^2 S_i^2}{h_{i-1}+h_i} \\left(\\frac{V_{i+1}^n - V_i^n}{h_i} - \\frac{V_i^n - V_{i-1}^n}{h_{i-1}}\\right) + \\frac{r S_i}{h_i} (V_{i+1}^n - V_i^n) - r V_i^n \\right]\n$$\n\n### Part (ii): Derivation of the Stability Condition\n\nTo ensure stability and prevent non-physical oscillations, the coefficients in the explicit update must satisfy certain positivity conditions. We require that the update for $V_i^{n+1}$ is a convex combination of its neighbors $V_{i-1}^n$, $V_i^n$, and $V_{i+1}^n$. To derive this condition, we reorganize the scheme to express $V_i^{n+1}$ as a linear combination of values at time level $n$:\n$$\nV_i^{n+1} = a_i V_{i-1}^n + b_i V_i^n + c_i V_{i+1}^n\n$$\nWe find the coefficients $a_i$, $b_i$, and $c_i$ by collecting terms from the update equation:\n\n- Coefficient of $V_{i-1}^n$:\n$$\na_i = \\Delta \\tau \\left( \\frac{\\sigma^2 S_i^2}{h_{i-1}(h_{i-1}+h_i)} \\right)\n$$\nSince $\\sigma$, $S_i$, $h_{i-1}$, and $h_i$ are all positive, $a_i \\ge 0$ for any $\\Delta \\tau > 0$.\n\n- Coefficient of $V_{i+1}^n$:\n$$\nc_i = \\Delta \\tau \\left( \\frac{\\sigma^2 S_i^2}{h_i(h_{i-1}+h_i)} + \\frac{r S_i}{h_i} \\right)\n$$\nSince $r \\ge 0$, we have $c_i \\ge 0$ for any $\\Delta \\tau > 0$.\n\n- Coefficient of $V_i^n$:\n$$\nb_i = 1 + \\Delta \\tau \\left[ -\\frac{\\sigma^2 S_i^2}{h_{i-1}+h_i}\\left(\\frac{1}{h_i} + \\frac{1}{h_{i-1}}\\right) - \\frac{r S_i}{h_i} - r \\right]\n$$\nSimplifying the term in the parentheses:\n$$\n-\\frac{\\sigma^2 S_i^2}{h_{i-1}+h_i}\\left(\\frac{h_{i-1}+h_i}{h_i h_{i-1}}\\right) - \\frac{r S_i}{h_i} - r = -\\frac{\\sigma^2 S_i^2}{h_i h_{i-1}} - \\frac{r S_i}{h_i} - r\n$$\nSo, the coefficient is:\n$$\nb_i = 1 - \\Delta \\tau \\left( \\frac{\\sigma^2 S_i^2}{h_i h_{i-1}} + \\frac{r S_i}{h_i} + r \\right)\n$$\nFor stability, we must enforce $b_i \\ge 0$. This leads to the condition:\n$$\n1 \\ge \\Delta \\tau \\left( \\frac{\\sigma^2 S_i^2}{h_i h_{i-1}} + \\frac{r S_i}{h_i} + r \\right)\n$$\nIsolating $\\Delta \\tau$ gives the local stability constraint at each interior node $S_i$:\n$$\n\\Delta \\tau \\le \\frac{1}{\\frac{\\sigma^2 S_i^2}{h_i h_{i-1}} + \\frac{r S_i}{h_i} + r}\n$$\nThis defines the term $\\Lambda_i$ from the problem statement:\n$$\n\\Lambda_i = \\frac{\\sigma^2 S_i^2}{h_i h_{i-1}} + \\frac{r S_i}{h_i} + r\n$$\nTo ensure stability across the entire grid, the time step $\\Delta \\tau$ must satisfy this condition for all interior nodes $i \\in \\{1, \\dots, M-1\\}$. Therefore, the global time step must be bounded by the most restrictive local condition:\n$$\n\\Delta \\tau \\le \\min_{i=1,\\dots,M-1} \\left( \\frac{1}{\\Lambda_i} \\right) = \\frac{1}{\\max_{i=1,\\dots,M-1} (\\Lambda_i)}\n$$\nThis completes the derivation of the stability condition.\n\n### Part (iii): Implementation Synopsis\n\nThe numerical implementation proceeds as follows:\n1.  **Grid Construction**: A function generates the non-uniform grid $\\{S_i\\}_{i=0}^M$ based on the parameters $K$, $S_{\\max}$, $w$, $h_f$, and $h_c$. The grid is constructed by concatenating three piecewise-uniform segments corresponding to $[0, K-w]$, $[K-w, K+w]$, and $[K+w, S_{\\max}]$, ensuring that the segment boundaries are grid nodes by adjusting the number of points in each segment.\n2.  **Stability Bound**: The maximum allowable time step, $\\Delta \\tau_{\\max}$, is computed by first calculating $\\Lambda_i$ for each interior node $i=1, \\dots, M-1$ using the derived formula and the generated grid spacings $h_{i-1}$ and $h_i$. Then, $\\Delta \\tau_{\\max} = 1 / \\max_i(\\Lambda_i)$.\n3.  **Time Marching**: The total number of time steps is set to $N_\\tau = \\lceil T/(\\theta \\cdot \\Delta \\tau_{\\max}) \\rceil$, where $\\theta$ is a safety factor. The actual time step used is $\\Delta \\tau = T/N_\\tau$.\n    - The simulation starts at $\\tau=0$ with the initial condition $V_i^0 = \\max(S_i - K, 0)$.\n    - The solution is advanced in a loop for $n$ from $0$ to $N_\\tau - 1$:\n        - At each step $n+1$, the boundary conditions $V_0^{n+1} = 0$ and $V_M^{n+1} = S_{\\max} - Ke^{-r((n+1)\\Delta\\tau)}$ are enforced.\n        - For all interior nodes $i$, $V_i^{n+1}$ is computed using the explicit update formula derived in Part (i).\n4.  **Result Evaluation**: After the final time step, the computed option values $\\{V_i^{N_\\tau}\\}$ at maturity $T$ are available on the grid $\\{S_i\\}$. The option value at a specific spot price $S_0$ is obtained using piecewise-linear interpolation on this final data.\n5.  **Analytical Solution**: For error calculation, the analytical Black-Scholes formula for a European call is required:\n    $$\n    C(S, \\tau) = S N(d_1) - K e^{-r\\tau} N(d_2)\n    $$\n    where $d_1 = \\frac{\\ln(S/K) + (r + \\sigma^2/2)\\tau}{\\sigma\\sqrt{\\tau}}$, $d_2 = d_1 - \\sigma\\sqrt{\\tau}$, and $N(\\cdot)$ is the standard normal cumulative distribution function.\nThe provided Python code implements this logic to solve the test cases.", "answer": "```python\nimport numpy as np\nfrom scipy.stats import norm\nimport math\n\ndef build_grid(K, S_max, w, h_f, h_c):\n    \"\"\"Constructs the piecewise-uniform non-uniform grid.\"\"\"\n    \n    # Region 1: [0, K-w] with spacing h_c\n    num_intervals_1 = max(1, round((K-w) / h_c))\n    grid1 = np.linspace(0, K-w, num=num_intervals_1 + 1)\n    \n    # Region 2: [K-w, K+w] with spacing h_f\n    num_intervals_2 = max(1, round(2 * w / h_f))\n    grid2 = np.linspace(K-w, K+w, num=num_intervals_2 + 1)\n    \n    # Region 3: [K+w, S_max] with spacing h_c\n    num_intervals_3 = max(1, round((S_max - (K+w)) / h_c))\n    grid3 = np.linspace(K+w, S_max, num=num_intervals_3 + 1)\n    \n    # Concatenate, removing duplicate points at boundaries\n    S = np.concatenate((grid1[:-1], grid2[:-1], grid3))\n    return S\n\ndef analytical_bs_call(S, K, T, r, sigma):\n    \"\"\"Computes the analytical Black-Scholes price for a European call.\"\"\"\n    if T == 0 or sigma == 0:\n        return np.maximum(S-K, 0)\n    d1 = (np.log(S / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))\n    d2 = d1 - sigma * np.sqrt(T)\n    price = S * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)\n    return price\n\ndef solve_case(params):\n    \"\"\"\n    Solves one test case configuration for the Black-Scholes PDE.\n    This function encapsulates the logic for grid generation, stability calculation,\n    time marching, and result extraction.\n    \"\"\"\n    K = params['K']\n    r = params['r']\n    sigma = params['sigma']\n    T = params['T']\n    S_max = params['S_max']\n    w = params['w']\n    h_f = params['h_f']\n    h_c = params['h_c']\n    \n    # 1. Grid Construction\n    S = build_grid(K, S_max, w, h_f, h_c)\n    M = len(S) - 1\n\n    # 2. Stability Bound Calculation\n    lambda_vals = []\n    for i in range(1, M):\n        h_im1 = S[i] - S[i-1]\n        h_i = S[i+1] - S[i]\n        \n        # Guard against zero S_i or h_i\n        if S[i] < 1e-9 or h_i < 1e-9 or h_im1 < 1e-9:\n            continue\n\n        term1 = (sigma**2 * S[i]**2) / (h_i * h_im1)\n        term2 = (r * S[i]) / h_i\n        term3 = r\n        lambda_i = term1 + term2 + term3\n        lambda_vals.append(lambda_i)\n        \n    if not lambda_vals:\n        # This case should not be reached with valid parameters\n        raise ValueError(\"Could not compute stability condition.\")\n        \n    max_lambda = np.max(lambda_vals)\n    d_tau_max = 1.0 / max_lambda\n\n    # Handling different test case requirements\n    test_id = params['test_id']\n    if test_id == 'B':\n        d_tau_test = 1.05 * d_tau_max\n        all_non_negative = True\n        for i in range(1, M):\n            h_im1 = S[i] - S[i-1]\n            h_i = S[i+1] - S[i]\n            if S[i] < 1e-9 or h_i < 1e-9 or h_im1 < 1e-9: continue\n            \n            lambda_i = (sigma**2 * S[i]**2) / (h_i * h_im1) + (r * S[i]) / h_i + r\n            b_i = 1.0 - d_tau_test * lambda_i\n            if b_i < 0:\n                all_non_negative = False\n                break\n        return all_non_negative\n\n    if test_id == 'D':\n        return d_tau_max\n\n    # Common path for tests A and C\n    theta = params['theta']\n    S0_eval = params['S0_eval']\n\n    # 3. Time Marching\n    N_tau = math.ceil(T / (theta * d_tau_max))\n    d_tau = T / N_tau\n\n    V = np.maximum(S - K, 0.0) # Initial condition at tau=0\n\n    # Pre-calculate some coefficients\n    h_im1 = S[1:M] - S[0:M-1]\n    h_i = S[2:M+1] - S[1:M]\n    S_interior = S[1:M]\n    \n    alpha = (sigma**2 * S_interior**2) / (h_im1 * (h_im1 + h_i))\n    gamma = (sigma**2 * S_interior**2) / (h_i * (h_im1 + h_i)) + (r * S_interior) / h_i\n    beta = (sigma**2 * S_interior**2) / (h_i * h_im1) + (r * S_interior) / h_i + r\n    \n    for n in range(N_tau):\n        V_new = np.zeros_like(V)\n        \n        # Boundary conditions at tau_{n+1}\n        V_new[0] = 0.0\n        tau_np1 = (n + 1) * d_tau\n        V_new[M] = S_max - K * np.exp(-r * tau_np1)\n        \n        # Interior nodes update\n        V_im1 = V[0:M-1]\n        V_i = V[1:M]\n        V_ip1 = V[2:M+1]\n        \n        V_new[1:M] = V_i + d_tau * (alpha * V_im1 - beta * V_i + gamma * V_ip1)\n        \n        V = V_new\n\n    # 4. Result Evaluation\n    numerical_price = np.interp(S0_eval, S, V)\n    analytical_price = analytical_bs_call(S0_eval, K, T, r, sigma)\n    \n    return abs(numerical_price - analytical_price)\n\ndef solve():\n    \"\"\"Main function to run all test cases and print results.\"\"\"\n    \n    test_cases = [\n        # Test A\n        {'test_id': 'A', 'K': 100, 'r': 0.05, 'sigma': 0.2, 'T': 1.0, 'S_max': 400,\n         'w': 20, 'h_f': 1.0, 'h_c': 5.0, 'theta': 0.9, 'S0_eval': 100},\n        # Test B\n        {'test_id': 'B', 'K': 100, 'r': 0.05, 'sigma': 0.2, 'T': 1.0, 'S_max': 400,\n         'w': 20, 'h_f': 1.0, 'h_c': 5.0},\n        # Test C\n        {'test_id': 'C', 'K': 100, 'r': 0.05, 'sigma': 0.2, 'T': 0.5, 'S_max': 400,\n         'w': 30, 'h_f': 0.5, 'h_c': 5.0, 'theta': 0.9, 'S0_eval': 80},\n        # Test D\n        {'test_id': 'D', 'K': 100, 'r': 0.02, 'sigma': 0.5, 'T': 1.0, 'S_max': 400,\n         'w': 20, 'h_f': 1.0, 'h_c': 5.0}\n    ]\n\n    results = []\n    for case_params in test_cases:\n        result = solve_case(case_params)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"}, {"introduction": "The Crank-Nicolson scheme is a workhorse in computational finance, prized for its unconditional stability which frees us from the strict time-step constraints of explicit methods. However, its excellent stability properties do not prevent the generation of non-physical, spurious oscillations, a common issue when pricing options with non-smooth payoffs at maturity. This practice will guide you to observe this classic numerical artifact and implement Rannacher damping, a widely-used technique to smooth the solution and ensure it adheres to financial principles like monotonicity, without sacrificing the benefits of an implicit scheme [@problem_id:2391467].", "id": "2391467", "problem": "You are asked to implement two unconditionally stable finite-difference time-stepping schemes for the Black–Scholes partial differential equation (PDE) of a European put option, and to quantify the spurious oscillations that can arise near the strike price immediately after stepping back from maturity. The Black–Scholes PDE is\n$$\n\\frac{\\partial V}{\\partial t} + \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} + r S \\frac{\\partial V}{\\partial S} - r V = 0,\n$$\nfor asset price $S \\in [0,S_{\\max}]$ and time $t \\in [0,T]$, with terminal condition (at maturity $t=T$) for a European put\n$$\nV(S,T) = \\max(K - S, 0).\n$$\nUse Dirichlet boundary conditions\n$$\nV(0,t) = K e^{-r (T-t)}, \\quad V(S_{\\max}, t) = 0.\n$$\nThe unknown is the option value $V(S,t)$; $S$ is the underlying asset price; $t$ is calendar time; $T$ is the maturity; $\\sigma$ is the volatility (assumed constant); and $r$ is the constant risk-free rate.\n\nYour program must:\n- Discretize the spatial domain on a uniform grid $S_i = i\\,\\Delta S$ for $i \\in \\{0,1,\\dots,N\\}$ with $\\Delta S = S_{\\max}/N$ and $N \\in \\mathbb{N}$.\n- Discretize time uniformly with $M \\in \\mathbb{N}$ steps of size $\\Delta t = T/M$, marching backward from $t=T$ to $t = T - \\Delta t$ for a single step to isolate behavior immediately after maturity.\n\nImplement and compare the following two schemes for the first backward step (from $t=T$ to $t=T-\\Delta t$):\n\n1) Crank–Nicolson scheme (time-centered, second-order):\nStart from the operator form $\\partial_t V = -\\mathcal{A} V$ where $\\mathcal{A} V = \\frac{1}{2}\\sigma^2 S^2 V_{SS} + r S V_S - r V$. The Crank–Nicolson update is\n$$\n\\left(I + \\frac{\\Delta t}{2}\\mathcal{A}\\right) V^{n+1} = \\left(I - \\frac{\\Delta t}{2}\\mathcal{A}\\right) V^n,\n$$\nwith $V^n(\\cdot) = V(\\cdot, t_n)$ and $t_{n+1} = t_n - \\Delta t$, where $t_n = T$. Spatial derivatives $\\partial_S V$ and $\\partial_{SS} V$ must be approximated using central differences at interior nodes $i \\in \\{1,\\dots,N-1\\}$:\n$$\nV_S(S_i) \\approx \\frac{V_{i+1}-V_{i-1}}{2\\Delta S}, \\quad V_{SS}(S_i) \\approx \\frac{V_{i+1} - 2V_i + V_{i-1}}{\\Delta S^2}.\n$$\n\n2) Rannacher-damped Crank–Nicolson:\nPerform two initial fully implicit (Backward Euler) half-steps of size $\\Delta t/2$ each, followed by nothing else (since only one full $\\Delta t$ backstep is needed for this task). The Backward Euler scheme for a half-step is\n$$\n\\left(I + \\frac{\\Delta t}{2}\\mathcal{A}\\right) V^{n+\\frac{1}{2}} = V^n, \\quad\n\\left(I + \\frac{\\Delta t}{2}\\mathcal{A}\\right) V^{n+1} = V^{n+\\frac{1}{2}}.\n$$\n\nIn both schemes, enforce the Dirichlet boundary conditions by appropriately adjusting the right-hand side at the first and last interior grid points. The tridiagonal linear systems that arise must be solved exactly (e.g., via the Thomas algorithm). All parameters are deterministic and the setting is risk-neutral and arbitrage-free.\n\nDetection and quantification of spurious oscillations:\n- For a European put, the exact price is monotone non-increasing in $S$. Define the discrete forward differences at a given time level as $\\Delta V_i = V_{i+1} - V_i$. Any instance where $\\Delta V_i > 0$ is a monotonicity violation consistent with spurious oscillations.\n- Let $i_K = \\left\\lfloor K/\\Delta S \\right\\rfloor$ and define a symmetric strike-centered window of half-width $w \\in \\mathbb{N}$ as indices $i \\in \\{\\max(0,i_K-w), \\dots, \\min(N-1,i_K+w)\\}$. Within this window, compute the maximum positive slope $\\max\\{0, \\max_{i \\text{ in window}} \\Delta V_i\\}$ as a measure of overshoot amplitude near the strike.\n\nNumerical foundation required:\n- Use the linear differential operator $\\mathcal{A}$ from the PDE and central finite differences as the sole spatial discretization tool.\n- Do not use any analytical Black–Scholes pricing formulas in your implementation or in your checks.\n- Assemble the tridiagonal matrices explicitly and solve them using a numerically stable direct tridiagonal solver.\n\nTest suite:\nUse the following parameter sets. For each, compute results after one full backward time step from $t=T$ to $t=T-\\Delta t$ using both schemes. Parameters common to all cases are $K = 100$, $T = 1.0$, $S_{\\max} = 500$, $r = 0.05$, $\\sigma = 0.2$, and $w = 5$.\n- Case A (coarse time step): $N = 200$, $M = 10$ (so $\\Delta t = 0.1$).\n- Case B (moderate time step): $N = 400$, $M = 50$ (so $\\Delta t = 0.02$).\n- Case C (fine time step): $N = 400$, $M = 200$ (so $\\Delta t = 0.005$).\n\nFor each case, report the following six quantities in this order:\n1) The integer count of monotonicity violations over the full grid for Crank–Nicolson at $t=T-\\Delta t$.\n2) The integer count of monotonicity violations within the strike-centered window for Crank–Nicolson at $t=T-\\Delta t$.\n3) The integer count of monotonicity violations over the full grid for Rannacher-damped at $t=T-\\Delta t$.\n4) The integer count of monotonicity violations within the strike-centered window for Rannacher-damped at $t=T-\\Delta t$.\n5) The maximum positive discrete slope within the strike-centered window for Crank–Nicolson at $t=T-\\Delta t$ (a nonnegative real number).\n6) The maximum positive discrete slope within the strike-centered window for Rannacher-damped at $t=T-\\Delta t$ (a nonnegative real number).\n\nFinal output format:\nYour program should produce a single line of output containing a list of three lists (one per case), each inner list containing the six results for that case in the order defined above. The output must be exactly of the form\n$$\n\\text{[}[a_{1},a_{2},a_{3},a_{4},a_{5},a_{6}],[b_{1},b_{2},b_{3},b_{4},b_{5},b_{6}],[c_{1},c_{2},c_{3},c_{4},c_{5},c_{6}]\\text{]}\n$$\nwith commas separating all numbers and no extra whitespace, where each $a_i$, $b_i$, and $c_i$ is a number. Angles are not involved, and there are no physical units to report. All numerical quantities should be printed as plain numbers; overshoot amplitudes should be printed as standard decimals.", "solution": "The problem statement is evaluated and found to be valid. It describes a well-posed numerical analysis task based on the fundamental Black-Scholes partial differential equation (PDE), a cornerstone of quantitative finance. All parameters and methods are defined with sufficient precision for a unique, verifiable solution. The task is to implement and compare two finite-difference schemes, Crank-Nicolson and a Rannacher-damped variant, to solve for a European put option price and quantify the spurious oscillations near the strike price that arise from the non-smooth terminal condition.\n\nWe begin by formalizing the discretization of the Black-Scholes PDE. The equation is given as\n$$\n\\frac{\\partial V}{\\partial t} + \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} + r S \\frac{\\partial V}{\\partial S} - r V = 0\n$$\nThis can be written in the operator form $\\frac{\\partial V}{\\partial t} + \\mathcal{A}V = 0$, or $\\frac{\\partial V}{\\partial t} = -\\mathcal{A}V$, where the linear operator $\\mathcal{A}$ is defined as\n$$\n\\mathcal{A}V := \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} + r S \\frac{\\partial V}{\\partial S} - rV\n$$\nWe discretize the spatial domain $S \\in [0, S_{\\max}]$ into $N$ uniform intervals of width $\\Delta S = S_{\\max}/N$, creating grid points $S_i = i\\Delta S$ for $i \\in \\{0, 1, \\dots, N\\}$. The solution $V(S_i, t)$ at these points is denoted $V_i(t)$. Using central finite differences for the spatial derivatives at an interior grid point $S_i$ (where $i \\in \\{1, \\dots, N-1\\}$), the operator $\\mathcal{A}$ acting on the vector of values $V$ is approximated as:\n$$\n(\\mathcal{A}V)_i \\approx \\left(\\frac{\\sigma^2 S_i^2}{2\\Delta S^2} - \\frac{rS_i}{2\\Delta S}\\right)V_{i-1} + \\left(-\\frac{\\sigma^2 S_i^2}{\\Delta S^2} - r\\right)V_i + \\left(\\frac{\\sigma^2 S_i^2}{2\\Delta S^2} + \\frac{rS_i}{2\\Delta S}\\right)V_{i+1}\n$$\nSubstituting $S_i = i\\Delta S$, we define the coefficients for the discrete operator matrix for row $i$:\n$$\n\\begin{aligned}\n\\alpha_i &= \\frac{1}{2}\\sigma^2 i^2 - \\frac{1}{2}ri \\\\\n\\beta_i &= -\\sigma^2 i^2 - r \\\\\n\\gamma_i &= \\frac{1}{2}\\sigma^2 i^2 + \\frac{1}{2}ri\n\\end{aligned}\n$$\nsuch that $(\\mathcal{A}V)_i \\approx \\alpha_i V_{i-1} + \\beta_i V_i + \\gamma_i V_{i+1}$. This formulation is valid for the interior grid points $i \\in \\{1, \\dots, N-1\\}$.\n\nThe time-stepping proceeds backward from maturity $T$ in steps of $\\Delta t=T/M$. Let $V^n$ denote the option value at time $t_n = T$, and we seek $V^{n+1}$ at time $t_{n+1} = T - \\Delta t$.\n\nFirst, the Crank-Nicolson scheme is implemented. The problem specifies the update rule:\n$$\n\\left(I + \\frac{\\Delta t}{2}\\mathcal{A}\\right) V^{n+1} = \\left(I - \\frac{\\Delta t}{2}\\mathcal{A}\\right) V^n\n$$\nFor each interior node $i$, this translates to a linear equation:\n$$\n\\left(\\frac{\\Delta t}{2}\\alpha_i\\right)V_{i-1}^{n+1} + \\left(1 + \\frac{\\Delta t}{2}\\beta_i\\right)V_i^{n+1} + \\left(\\frac{\\Delta t}{2}\\gamma_i\\right)V_{i+1}^{n+1} = \\left(-\\frac{\\Delta t}{2}\\alpha_i\\right)V_{i-1}^{n} + \\left(1 - \\frac{\\Delta t}{2}\\beta_i\\right)V_i^{n} + \\left(-\\frac{\\Delta t}{2}\\gamma_i\\right)V_{i+1}^{n}\n$$\nThis forms a tridiagonal system of $N-1$ linear equations for the $N-1$ unknown interior values $\\{V_1^{n+1}, \\dots, V_{N-1}^{n+1}\\}$. The known boundary values $V_0$ and $V_N$ must be incorporated. The Dirichlet boundary conditions are $V(0, t) = K e^{-r(T-t)}$ and $V(S_{\\max}, t) = 0$.\nSo, $V_0^n = K$, $V_N^n = 0$, $V_0^{n+1} = Ke^{-r\\Delta t}$, and $V_N^{n+1} = 0$.\nFor the first interior equation ($i=1$), the term involving $V_0^{n+1}$ is known and moved to the right-hand side. The right-hand side for the first equation is thus modified by subtracting $(\\frac{\\Delta t}{2}\\alpha_1)V_0^{n+1}$. For the last interior equation ($i=N-1$), terms involving $V_N^{n+1}$ and $V_N^n$ are zero and require no adjustment.\n\nSecond, the Rannacher-damped scheme consists of two initial fully implicit (Backward Euler) steps, each of half size $\\Delta t/2$. We only need to perform these two steps to cover the required single time step of size $\\Delta t$. The update rules are:\n$$\n\\begin{aligned}\n\\text{Step 1: } \\left(I + \\frac{\\Delta t}{2}\\mathcal{A}\\right) V^{n+\\frac{1}{2}} &= V^n \\\\\n\\text{Step 2: } \\left(I + \\frac{\\Delta t}{2}\\mathcal{A}\\right) V^{n+1} &= V^{n+\\frac{1}{2}}\n\\end{aligned}\n$$\nwhere $V^{n+\\frac{1}{2}}$ is the solution at the intermediate time $t = T - \\Delta t/2$. The left-hand side operator matrix is identical to the one used in the Crank-Nicolson method.\nFor Step 1, the right-hand side is the vector $V^n$ at the interior points. The boundary condition at $S=0$ is $V_0^{n+\\frac{1}{2}} = Ke^{-r\\Delta t/2}$. The right-hand side for the first equation ($i=1$) is adjusted by subtracting $(\\frac{\\Delta t}{2}\\alpha_1)V_0^{n+\\frac{1}{2}}$.\nFor Step 2, the right-hand side is the vector $V^{n+\\frac{1}{2}}$ computed in Step 1. The boundary condition at $S=0$ is $V_0^{n+1} = Ke^{-r\\Delta t}$. The right-hand side for the first equation is adjusted by subtracting $(\\frac{\\Delta t}{2}\\alpha_1)V_0^{n+1}$.\nIn both schemes, the resulting tridiagonal system is solved using the Thomas algorithm, a direct and numerically stable method for such systems.\n\nFinally, to quantify spurious oscillations, we analyze the computed solution $V^{n+1}$. The value of a put option must be a monotone non-increasing function of the asset price $S$. Therefore, any positive discrete slope $\\Delta V_i = V_{i+1} - V_i > 0$ indicates a violation of this property and is a signature of spurious numerical oscillations. We compute two metrics: the total count of such violations across the entire grid, and the count within a specified window of half-width $w$ centered at the strike price $K$. The window for the difference index $i$ is defined as $i \\in \\{\\max(0, i_K-w), \\dots, \\min(N-1, i_K+w)\\}$, where $i_K = \\lfloor K/\\Delta S \\rfloor$. We also compute the maximum positive slope, $\\max(0, \\max_{i \\text{ in window}} \\Delta V_i)$, as a measure of the oscillation amplitude near the strike. These six quantities are computed for each test case.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_tridiagonal(a, b, c, d):\n    \"\"\"\n    Solves a tridiagonal linear system Ax=d using the Thomas algorithm.\n    a: sub-diagonal (length n-1)\n    b: main diagonal (length n)\n    c: super-diagonal (length n-1)\n    d: right-hand side vector (length n)\n    \"\"\"\n    n = len(d)\n    c_prime = np.zeros(n - 1)\n    d_prime = np.zeros(n)\n    x = np.zeros(n)\n\n    if n == 0:\n        return x\n    \n    # Forward elimination\n    c_prime[0] = c[0] / b[0]\n    d_prime[0] = d[0] / b[0]\n    for i in range(1, n - 1):\n        denum = b[i] - a[i - 1] * c_prime[i - 1]\n        c_prime[i] = c[i] / denum\n    for i in range(1, n):\n        denum = b[i] - a[i - 1] * c_prime[i - 1]\n        d_prime[i] = (d[i] - a[i - 1] * d_prime[i - 1]) / denum\n\n    # Backward substitution\n    x[n - 1] = d_prime[n - 1]\n    for i in range(n - 2, -1, -1):\n        x[i] = d_prime[i] - c_prime[i] * x[i + 1]\n\n    return x\n\ndef analyze_oscillations(values, N, dS, K, w):\n    \"\"\"\n    Analyzes the solution vector for monotonicity violations.\n    \"\"\"\n    diffs = np.diff(values)\n    \n    # Full grid analysis\n    full_grid_violations = np.sum(diffs > 0.0)\n\n    # Window analysis\n    i_K = int(np.floor(K / dS))\n    window_start = max(0, i_K - w)\n    window_end = min(N - 1, i_K + w)\n    \n    window_diffs = diffs[window_start : window_end + 1]\n    \n    window_violations = np.sum(window_diffs > 0.0)\n    max_overshoot = 0.0\n    if window_diffs.size > 0:\n        max_overshoot = np.max(window_diffs, initial=0.0)\n\n    return int(full_grid_violations), int(window_violations), float(max_overshoot)\n\n\ndef run_case(case_params):\n    \"\"\"\n    Runs a single test case for the Black-Scholes PDE problem.\n    \"\"\"\n    N, M, K, T, S_max, r, sigma, w = case_params\n\n    # Grid setup\n    dt = T / M\n    dS = S_max / N\n    S = np.linspace(0, S_max, N + 1)\n\n    # Terminal condition V(S, T)\n    V_current = np.maximum(K - S, 0.0)\n\n    # Discretized operator coefficients\n    i = np.arange(1, N)\n    alpha = 0.5 * sigma**2 * i**2 - 0.5 * r * i\n    beta = -sigma**2 * i**2 - r\n    gamma = 0.5 * sigma**2 * i**2 + 0.5 * r * i\n\n    # --- 1. Crank-Nicolson Scheme ---\n    \n    # LHS matrix (I + dt/2 * A) diagonals\n    # System is defined for interior points [1, ..., N-1]\n    # Matrix size is (N-1) x (N-1)\n    a_LHS = 0.5 * dt * alpha[1:]          # sub-diagonal, length N-2\n    b_LHS = 1.0 + 0.5 * dt * beta         # main-diagonal, length N-1\n    c_LHS = 0.5 * dt * gamma[:-1]         # super-diagonal, length N-2\n\n    # RHS vector (I - dt/2 * A)V^n\n    V_int_current = V_current[1:N]\n    rhs_cn = (1.0 - 0.5 * dt * beta) * V_int_current\n    rhs_cn[1:] -= 0.5 * dt * alpha[1:] * V_current[1:N-1] # V_{i-1} term\n    rhs_cn[:-1] -= 0.5 * dt * gamma[:-1] * V_current[2:N] # V_{i+1} term\n    \n    # Boundary conditions for CN\n    v0_n = K\n    v0_n_plus_1 = K * np.exp(-r * dt)\n    \n    # Adjust RHS for BC: term with V_0_n\n    rhs_cn[0] -= 0.5 * dt * alpha[0] * v0_n\n    # Adjust RHS for BC: move known V_0_n+1 term from LHS\n    rhs_cn[0] -= 0.5 * dt * alpha[0] * v0_n_plus_1\n    \n    # Solve tridiagonal system for interior points\n    V_int_new_cn = solve_tridiagonal(a_LHS, b_LHS, c_LHS, rhs_cn)\n\n    # Assemble full solution vector\n    V_cn = np.zeros(N + 1)\n    V_cn[0] = v0_n_plus_1\n    V_cn[1:N] = V_int_new_cn\n    V_cn[N] = 0.0 # V(S_max, t) = 0\n\n    # Analyze oscillations\n    cn_full, cn_window, cn_max_slope = analyze_oscillations(V_cn, N, dS, K, w)\n\n    # --- 2. Rannacher Damping Scheme ---\n\n    # LHS matrix is the same as for CN\n    # This matrix is used for both half-steps\n    \n    # Step 1: V^n -> V^(n+1/2)\n    V_int_step1_rhs = V_int_current.copy()\n    v0_n_plus_half = K * np.exp(-r * dt * 0.5)\n    # Adjust RHS for BC: move known V_0_n+1/2 term from LHS\n    V_int_step1_rhs[0] -= 0.5 * dt * alpha[0] * v0_n_plus_half\n    \n    V_int_half = solve_tridiagonal(a_LHS, b_LHS, c_LHS, V_int_step1_rhs)\n\n    # Step 2: V^(n+1/2) -> V^(n+1)\n    V_int_step2_rhs = V_int_half.copy()\n    v0_n_plus_1 = K * np.exp(-r * dt)\n    # Adjust RHS for BC: move known V_0_n+1 term from LHS\n    V_int_step2_rhs[0] -= 0.5 * dt * alpha[0] * v0_n_plus_1\n    \n    V_int_new_rannacher = solve_tridiagonal(a_LHS, b_LHS, c_LHS, V_int_step2_rhs)\n\n    # Assemble full solution vector\n    V_rannacher = np.zeros(N + 1)\n    V_rannacher[0] = v0_n_plus_1\n    V_rannacher[1:N] = V_int_new_rannacher\n    V_rannacher[N] = 0.0\n\n    # Analyze oscillations\n    r_full, r_window, r_max_slope = analyze_oscillations(V_rannacher, N, dS, K, w)\n\n    return [cn_full, cn_window, r_full, r_window, cn_max_slope, r_max_slope]\n\ndef solve():\n    # Define parameters common to all cases\n    K = 100.0\n    T = 1.0\n    S_max = 500.0\n    r = 0.05\n    sigma = 0.2\n    w = 5\n    \n    # Define the test cases from the problem statement\n    test_cases_params = [\n        # (N, M)\n        (200, 10),  # Case A\n        (400, 50),  # Case B\n        (400, 200), # Case C\n    ]\n\n    results = []\n    for N, M in test_cases_params:\n        case_params = (N, M, K, T, S_max, r, sigma, w)\n        case_results = run_case(case_params)\n        results.append(case_results)\n\n    # Final print statement in the exact required format.\n    # e.g. [[1,2,3,4,5.0,6.0],[...],[...]]\n    formatted_results = [\n        \"[\" + \",\".join(map(str, res)) + \"]\" for res in results\n    ]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"}, {"introduction": "Once a stable and reliable numerical solver is established, a key question is how to improve its accuracy efficiently. Richardson Extrapolation provides a powerful and surprisingly general answer, allowing you to combine results from runs with different step sizes to create a new estimate with a higher order of convergence. By implementing this method on top of a Crank-Nicolson solver, you will not only produce more precise option prices but also gain practical insight into the concepts of convergence order and systematic error cancellation [@problem_id:2391443].", "id": "2391443", "problem": "Consider the Black–Scholes partial differential equation (PDE) under the risk-neutral valuation principle for the value of a European call option on a non-dividend-paying asset with spot price $S$, strike $K$, volatility $\\sigma$, continuously compounded risk-free rate $r$, and time to maturity $T$. The value function $V(S,t)$ satisfies, for $0 < S < S_{\\max}$ and $0 \\le t < T$, the backward parabolic PDE\n$$\n\\frac{\\partial V}{\\partial t} + \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} + r S \\frac{\\partial V}{\\partial S} - r V = 0,\n$$\nwith terminal condition $V(S,T) = \\max(S - K, 0)$ and the following boundary conditions for a European call: $V(0,t) = 0$, and, for large asset price, $V(S_{\\max},t) = S_{\\max} - K e^{-r (T - t)}$. Assume $S_{\\max}$ is sufficiently large so the boundary is accurate.\n\nYour task is to implement a Crank–Nicolson finite-difference solver on a uniform grid in space to step the PDE backward in time from $t = T$ to $t = 0$. Use central differences in space for the first and second derivatives. Then apply Richardson Extrapolation in time by computing the solution at $t=0$ twice on the same spatial grid: once with time step $\\Delta t = T/N$ and once with $\\Delta t/2 = T/(2N)$, and combine them into a higher-order estimate. Specifically, if $p$ denotes the temporal order of accuracy of the scheme, the extrapolated estimate at any fixed spatial point is\n$$\nV_{\\mathrm{Rich}} = V_{\\Delta t/2} + \\frac{V_{\\Delta t/2} - V_{\\Delta t}}{2^p - 1}.\n$$\nFor the Crank–Nicolson method, take $p = 2$. For each case, report the extrapolated option value at a given spot $S_0$.\n\nAs a validation against a well-tested formula, also compute the corresponding European call price from the Black–Scholes closed-form solution using the same $S_0$, $K$, $r$, $\\sigma$, and $T$. For the degenerate case $\\sigma = 0$, use the risk-neutral limit $V_{\\mathrm{BS}} = \\max(S_0 - K e^{-r T}, 0)$. For $\\sigma > 0$, use the usual Gaussian cumulative distribution function in the Black–Scholes formula. For each case, report the absolute error between the Richardson-extrapolated finite-difference estimate and the analytical Black–Scholes price.\n\nImplementation requirements:\n- Spatial grid: uniform in $S$ over $[0, S_{\\max}]$ with $M$ subintervals (thus $M+1$ grid points). Use $M \\ge 2$.\n- Time-stepping: Crank–Nicolson implicit method, uniform steps backward from $t = T$ to $t = 0$.\n- Linear system solver: exploit the tridiagonal structure via the Thomas algorithm or an equivalent banded solve.\n- Interpolation: return the price at $t=0$ and $S_0$ by linear interpolation on the $S$-grid.\n- Richardson Extrapolation: combine the solutions from $\\Delta t$ and $\\Delta t/2$ with $p=2$ as $V_{\\mathrm{Rich}} = V_{\\Delta t/2} + \\frac{V_{\\Delta t/2} - V_{\\Delta t}}{3}$.\n- Units: all monetary quantities are nominal and unitless for the purpose of this computation; report numerical values as floating-point numbers.\n- Angle units do not apply.\n\nTest Suite:\nImplement your program to run the following four parameter sets, each specified as a tuple $(S_0, K, r, \\sigma, T, S_{\\max}, M, N)$:\n1) $(S_0, K, r, \\sigma, T, S_{\\max}, M, N) = (100, 100, 0.05, 0.2, 1.0, 400, 200, 50)$.\n2) $(S_0, K, r, \\sigma, T, S_{\\max}, M, N) = (80, 100, 0.03, 0.25, 2.0, 400, 200, 80)$.\n3) $(S_0, K, r, \\sigma, T, S_{\\max}, M, N) = (120, 100, 0.0, 0.2, 0.25, 400, 200, 40)$.\n4) $(S_0, K, r, \\sigma, T, S_{\\max}, M, N) = (100, 100, 0.05, 0.0, 1.0, 400, 200, 40)$.\n\nFor each case $i \\in \\{1,2,3,4\\}$, compute:\n- The Richardson-extrapolated Crank–Nicolson estimate $V_{\\mathrm{Rich},i}$ at $t=0$ and $S_0$.\n- The absolute error $E_i = |V_{\\mathrm{Rich},i} - V_{\\mathrm{BS},i}|$ where $V_{\\mathrm{BS},i}$ is the Black–Scholes analytical price for the same parameters.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order\n$$\n[V_{\\mathrm{Rich},1}, E_1, V_{\\mathrm{Rich},2}, E_2, V_{\\mathrm{Rich},3}, E_3, V_{\\mathrm{Rich},4}, E_4].\n$$\nAll entries must be floating-point numbers. No other text should be printed.", "solution": "The problem presented is a standard exercise in computational finance, requiring the numerical solution of the Black–Scholes partial differential equation (PDE) for a European call option. The problem is well-defined, scientifically sound, and internally consistent. It specifies the PDE, terminal and boundary conditions, and the required numerical method—Crank–Nicolson with Richardson extrapolation. All parameters for the test cases are provided, and the validation against an analytical solution is a standard and proper verification procedure. The problem is therefore deemed **valid**.\n\nWe proceed to develop the solution. The Black–Scholes PDE is given by:\n$$\n\\frac{\\partial V}{\\partial t} + \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} + r S \\frac{\\partial V}{\\partial S} - r V = 0\n$$\nThis is a backward parabolic PDE. For numerical convenience, we perform a change of variables to forward time, $\\tau = T - t$. The PDE transforms to:\n$$\n\\frac{\\partial V}{\\partial \\tau} = \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} + r S \\frac{\\partial V}{\\partial S} - r V\n$$\nWe solve this equation for $\\tau$ from $0$ to $T$. The terminal condition at $t=T$ becomes the initial condition at $\\tau=0$:\n$$\nV(S, \\tau=0) = \\max(S - K, 0)\n$$\nThe boundary conditions are:\n$$\nV(0, \\tau) = 0 \\quad \\text{and} \\quad V(S_{\\max}, \\tau) = S_{\\max} - K e^{-r\\tau}\n$$\n\nWe discretize the domain on a uniform grid:\n- Spatial grid: $S_i = i \\Delta S$ for $i = 0, 1, \\dots, M$, where $\\Delta S = S_{\\max} / M$.\n- Temporal grid: $\\tau_j = j \\Delta \\tau$ for $j = 0, 1, \\dots, N$, where $\\Delta \\tau = T / N$.\nLet $V_i^j$ denote the numerical approximation of $V(S_i, \\tau_j)$.\n\nThe Crank–Nicolson method is applied, which is an implicit finite-difference scheme that averages the spatial derivatives at time steps $j$ and $j+1$:\n$$\n\\frac{V_i^{j+1} - V_i^j}{\\Delta \\tau} = \\frac{1}{2} \\left( \\mathcal{L}_h V_i^{j+1} + \\mathcal{L}_h V_i^j \\right)\n$$\nwhere $\\mathcal{L}_h$ is the discretized spatial operator using central differences:\n$$\n\\mathcal{L}_h V_i = \\left(\\frac{\\sigma^2 S_i^2}{2(\\Delta S)^2} - \\frac{r S_i}{2(2\\Delta S)}\\right)V_{i-1} + \\left(-\\frac{\\sigma^2 S_i^2}{(\\Delta S)^2} - r\\right)V_i + \\left(\\frac{\\sigma^2 S_i^2}{2(\\Delta S)^2} + \\frac{r S_i}{2(2\\Delta S)}\\right)V_{i+1}\n$$\nSubstituting $S_i = i\\Delta S$, the operator coefficients for $V_{i-1}$, $V_i$, and $V_{i+1}$ are:\n$$\n\\alpha_i = \\frac{1}{2}\\sigma^2 i^2 - \\frac{1}{2}ri, \\quad \\beta_i = -\\sigma^2 i^2 - r, \\quad \\gamma_i = \\frac{1}{2}\\sigma^2 i^2 + \\frac{1}{2}ri\n$$\nRearranging the Crank–Nicolson scheme isolates the unknown values $V^{j+1}$ on the left-hand side (LHS) and known values $V^j$ on the right-hand side (RHS):\n$$\n\\left(I - \\frac{\\Delta \\tau}{2}\\mathcal{L}_h\\right) V^{j+1} = \\left(I + \\frac{\\Delta \\tau}{2}\\mathcal{L}_h\\right) V^j\n$$\nThis represents a system of linear equations for the interior grid points $i=1, \\dots, M-1$. The system is tridiagonal:\n$$\na_i V_{i-1}^{j+1} + b_i V_i^{j+1} + c_i V_{i+1}^{j+1} = d_i\n$$\nwhere the LHS coefficients are:\n$$\na_i = -\\frac{\\Delta \\tau}{2}\\alpha_i, \\quad b_i = 1 - \\frac{\\Delta \\tau}{2}\\beta_i, \\quad c_i = -\\frac{\\Delta \\tau}{2}\\gamma_i\n$$\nAnd the RHS is constructed from known values at time step $j$:\n$$\nd_i = \\frac{\\Delta \\tau}{2}\\alpha_i V_{i-1}^j + \\left(1 + \\frac{\\Delta \\tau}{2}\\beta_i\\right) V_i^j + \\frac{\\Delta \\tau}{2}\\gamma_i V_{i+1}^j\n$$\nThe boundary conditions $V_0^{j+1}=0$ and $V_M^{j+1}=S_{\\max}-Ke^{-r\\tau_{j+1}}$ are incorporated into the first ($i=1$) and last ($i=M-1$) equations of the linear system. The resulting tridiagonal system is efficiently solved at each time step using a specialized algorithm such as the Thomas algorithm, available in `scipy.linalg.solve_banded`.\n\nThis process is iterated from $\\tau=0$ to $\\tau=T$. The final solution vector $V^N$ gives the option values at $t=0$. To find the value at a specific spot price $S_0$, we use linear interpolation on the final grid values.\n\nThe procedure is run twice: once with $N$ time steps (step size $\\Delta \\tau = T/N$) yielding a solution $V_{\\Delta \\tau}$, and once with $2N$ time steps (step size $\\Delta \\tau/2 = T/(2N)$) yielding $V_{\\Delta \\tau/2}$. Since the Crank–Nicolson method has a temporal order of accuracy $p=2$, we apply Richardson extrapolation to obtain a more accurate estimate:\n$$\nV_{\\mathrm{Rich}} = V_{\\Delta \\tau/2} + \\frac{V_{\\Delta \\tau/2} - V_{\\Delta \\tau}}{2^p - 1} = V_{\\Delta \\tau/2} + \\frac{V_{\\Delta \\tau/2} - V_{\\Delta \\tau}}{3}\n$$\n\nFor validation, this numerical result is compared against the analytical Black–Scholes formula for a European call:\n$$\nV_{\\mathrm{BS}}(S, t) = S_0 N(d_1) - K e^{-r(T-t)} N(d_2)\n$$\nwhere $N(\\cdot)$ is the standard normal cumulative distribution function (CDF), and\n$$\nd_1 = \\frac{\\ln(S_0/K) + (r + \\frac{1}{2}\\sigma^2)(T-t)}{\\sigma\\sqrt{T-t}}, \\quad d_2 = d_1 - \\sigma\\sqrt{T-t}\n$$\nIn the case of zero volatility ($\\sigma=0$), the formula degenerates to the risk-neutral discounted payoff:\n$$\nV_{\\mathrm{BS}}(S_0, t) = \\max(S_0 - K e^{-r(T-t)}, 0)\n$$\nThe absolute error $E = |V_{\\mathrm{Rich}} - V_{\\mathrm{BS}}|$ at $t=0$ quantifies the accuracy of our numerical implementation.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\nfrom scipy.special import erf\n\ndef black_scholes_analytical(S0, K, r, sigma, T):\n    \"\"\"\n    Computes the analytical Black-Scholes price for a European call option.\n    \"\"\"\n    if sigma == 0:\n        return np.maximum(S0 - K * np.exp(-r * T), 0)\n\n    def norm_cdf(x):\n        return 0.5 * (1 + erf(x / np.sqrt(2)))\n\n    if T == 0:\n        return np.maximum(S0 - K, 0)\n        \n    d1 = (np.log(S0 / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))\n    d2 = d1 - sigma * np.sqrt(T)\n    \n    call_price = S0 * norm_cdf(d1) - K * np.exp(-r * T) * norm_cdf(d2)\n    return call_price\n\ndef run_crank_nicolson(S0, K, r, sigma, T, Smax, M, N_steps):\n    \"\"\"\n    Solves the Black-Scholes PDE using the Crank-Nicolson method.\n    \"\"\"\n    # Grid parameters\n    dt = T / N_steps\n    dS = Smax / M\n    S_vec = np.linspace(0, Smax, M + 1)\n    \n    # Grid of interior asset prices\n    i_vec = np.arange(1, M)\n\n    # Initial condition at t=T (tau=0)\n    V = np.maximum(S_vec - K, 0)\n    \n    # Coefficients for the tridiagonal system. These are constant in time.\n    # LHS matrix A = I - dt/2 * L_h\n    # where L_h is the discretized spatial operator\n    alpha = 0.5 * (sigma**2 * i_vec**2 - r * i_vec)\n    beta = -(sigma**2 * i_vec**2 + r)\n    gamma = 0.5 * (sigma**2 * i_vec**2 + r * i_vec)\n    \n    # LHS matrix elements\n    l = -0.5 * dt * alpha\n    d = 1 - 0.5 * dt * beta\n    u = -0.5 * dt * gamma\n\n    # Banded matrix format for scipy's solver: (l, u), (M-1)\n    # The matrix has 1 lower and 1 upper diagonal.\n    A_banded = np.zeros((3, M - 1))\n    A_banded[0, 1:] = u[:-1]\n    A_banded[1, :] = d\n    A_banded[2, :-1] = l[1:]\n    \n    # Time-stepping loop (forward in tau, backward in t)\n    for j in range(1, N_steps + 1):\n        tau = j * dt\n        \n        # RHS vector: B * V^j = (I + dt/2 * L_h) * V^j\n        # The elements of B are given by changing signs of off-diagonal elements of A\n        # and changing the main diagonal from (1-...) to (1+...).\n        rhs = (0.5 * dt * alpha) * V[:-2] + (1 + 0.5 * dt * beta) * V[1:-1] + (0.5 * dt * gamma) * V[2:]\n        \n        # Boundary conditions at time tau\n        # V(0, tau) = 0 is handled implicitly as V[0] = 0.\n        V_M_tau = Smax - K * np.exp(-r * tau)\n        \n        # Adjust RHS for the known boundary value at S_max\n        # The term u[-1] * V_M_tau from the LHS matrix is moved to the RHS.\n        rhs[-1] -= u[-1] * V_M_tau\n        \n        # Solve the tridiagonal system A*V_new = rhs\n        V_interior = solve_banded((1, 1), A_banded, rhs, check_finite=False)\n        \n        # Update V for the next time step\n        V[1:-1] = V_interior\n        V[-1] = V_M_tau # Dirichlet boundary condition at S_max\n\n    # Interpolate to find the price at S0\n    return np.interp(S0, S_vec, V)\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and generate final output.\n    \"\"\"\n    test_cases = [\n        # (S0, K, r, sigma, T, Smax, M, N)\n        (100, 100, 0.05, 0.2, 1.0, 400, 200, 50),\n        (80, 100, 0.03, 0.25, 2.0, 400, 200, 80),\n        (120, 100, 0.0, 0.2, 0.25, 400, 200, 40),\n        (100, 100, 0.05, 0.0, 1.0, 400, 200, 40),\n    ]\n\n    results = []\n    for case in test_cases:\n        S0, K, r, sigma, T, Smax, M, N = case\n        \n        # Calculate numerical solution with N and 2*N time steps\n        V_N = run_crank_nicolson(S0, K, r, sigma, T, Smax, M, N)\n        V_2N = run_crank_nicolson(S0, K, r, sigma, T, Smax, M, 2 * N)\n        \n        # Richardson Extrapolation (p=2 for Crank-Nicolson)\n        # V_rich = V_2N + (V_2N - V_N) / (2^p - 1)\n        V_rich = V_2N + (V_2N - V_N) / 3.0\n        \n        # Calculate analytical solution for comparison\n        V_bs = black_scholes_analytical(S0, K, r, sigma, T)\n        \n        # Calculate absolute error\n        error = np.abs(V_rich - V_bs)\n        \n        results.extend([V_rich, error])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"}]}