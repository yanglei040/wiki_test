{"hands_on_practices": [{"introduction": "Our first exercise provides a foundational look at how agent behavior directly influences market stability. We will construct a \"toy model\" of a market populated exclusively by contrarian agents, who systematically trade against recent price trends. This practice [@problem_id:2372768] will allow you to analytically and numerically explore the conditions under which such negative feedback leads to a stable price equilibrium, versus those that result in explosive oscillations.", "id": "2372768", "problem": "Consider an artificial stock market populated solely by contrarian agents who always trade against the most recent market trend. The market evolves in discrete time. Let $p_t$ denote the (log) price at time $t$ and $r_t$ the one-step return, defined by $r_t = p_t - p_{t-1}$. Assume the following foundational principles, which are standard in market microstructure and agent-based modeling:\n\n- Linear price impact: the price update is proportional to aggregate excess demand. There exists a constant $\\kappa > 0$ such that $p_t = p_{t-1} + \\kappa \\cdot ED_t$, where $ED_t$ is the aggregate excess demand at time $t$.\n- Contrarian demand: aggregate excess demand is proportional to the negative of the most recent realized return. There exists a constant $\\beta > 0$ such that $ED_t = -\\beta \\cdot r_{t-1}$.\n\nInitial conditions are specified by $p_0$ and $r_0$. Interpret $r_0$ as the realized return from $t=-1$ to $t=0$, so that the first contrarian response at $t=1$ depends on $r_0$.\n\nDefine asymptotic price stability for this contrarian-only market to mean both that returns vanish and that the price converges to a finite limit, specifically that $\\lim_{t \\to \\infty} r_t = 0$ and $\\lim_{t \\to \\infty} p_t$ exists and is finite.\n\nYour tasks are as follows:\n- Using only the two foundational principles above and the definition of returns, derive from first principles the necessary and sufficient condition on parameters for asymptotic price stability in the contrarian-only market.\n- Design an algorithm that, given $(\\kappa, \\beta, p_0, r_0, T, \\varepsilon)$, simulates the market dynamics implied by the foundational principles and declares the market asymptotically price-stable if the magnitude of the return falls below a tolerance $\\varepsilon$ by or before time $T$. This finite-horizon numerical criterion operationalizes the asymptotic definition for testing purposes and must be consistent with your derived analytical condition.\n\nImplement a complete, runnable program that evaluates the following test suite. Each test case is a tuple $(\\kappa, \\beta, p_0, r_0, T, \\varepsilon)$:\n\n- Case A (general stable case): $(\\kappa, \\beta, p_0, r_0, T, \\varepsilon) = (\\,0.2,\\, 2.5,\\, 0.0,\\, 0.1,\\, 200,\\, 10^{-6}\\,)$.\n- Case B (boundary condition): $(\\kappa, \\beta, p_0, r_0, T, \\varepsilon) = (\\,0.5,\\, 2.0,\\, 0.0,\\, 0.1,\\, 200,\\, 10^{-6}\\,)$.\n- Case C (unstable case): $(\\kappa, \\beta, p_0, r_0, T, \\varepsilon) = (\\,0.8,\\, 2.0,\\, 0.0,\\, 0.1,\\, 50,\\, 10^{-6}\\,)$.\n- Case D (near-boundary slow convergence): $(\\kappa, \\beta, p_0, r_0, T, \\varepsilon) = (\\,0.95,\\, 1.0,\\, 0.0,\\, -0.2,\\, 500,\\, 10^{-3}\\,)$.\n- Case E (fast convergence from large initial move): $(\\kappa, \\beta, p_0, r_0, T, \\varepsilon) = (\\,0.05,\\, 1.0,\\, 0.0,\\, 1.0,\\, 50,\\, 10^{-6}\\,)$.\n\nYour program must:\n- Implement the simulation exactly as implied by the two foundational principles and the definition of returns, starting from the provided initial conditions and iterating until time $T$.\n- For each case, output a boolean indicating whether, by time $T$, the absolute return $\\lvert r_t \\rvert$ has fallen below $\\varepsilon$ at some step $t \\in \\{1, 2, \\dots, T\\}$, which is the operational test for asymptotic price stability.\n- Produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[\\,\\text{True},\\text{False},\\dots\\,]$). No additional text should be printed.\n\nNote: All quantities are unitless. Angles are not applicable. Express all tolerances as decimal fractions (for instance, $10^{-6}$), not percentages. The final outputs are booleans. The test suite is designed to include a general stable case, a boundary case, an unstable case, a near-boundary case with slow convergence, and a case with rapid convergence from a large initial move.", "solution": "The problem requires the derivation of the necessary and sufficient condition for asymptotic price stability in a contrarian-only artificial stock market, followed by the design and implementation of an algorithm to simulate the market and numerically test for this stability.\n\nFirst, we derive the stability condition from first principles. The model is defined by three equations:\n1.  The definition of the one-step return $r_t$: $r_t = p_t - p_{t-1}$, where $p_t$ is the log price at time $t$.\n2.  The linear price impact rule: $p_t = p_{t-1} + \\kappa \\cdot ED_t$, where $\\kappa > 0$ and $ED_t$ is the aggregate excess demand.\n3.  The contrarian demand function: $ED_t = -\\beta \\cdot r_{t-1}$, where $\\beta > 0$.\n\nBy combining these principles, we can establish a recurrence relation for the return series $r_t$. From the first two equations, it is clear that the return $r_t$ is directly proportional to the excess demand:\n$$r_t = p_t - p_{t-1} = \\kappa \\cdot ED_t$$\nNow, we substitute the expression for contrarian demand, $ED_t$, into this relationship:\n$$r_t = \\kappa \\cdot (-\\beta \\cdot r_{t-1})$$\nThis simplifies to a first-order linear homogeneous difference equation for the returns:\n$$r_t = -(\\kappa\\beta) \\cdot r_{t-1}$$\nThis is a geometric progression. Given the initial return $r_0$, which is the return from $t=-1$ to $t=0$, we can write the general solution for $r_t$ as:\n$$r_t = (-\\kappa\\beta)^t \\cdot r_0$$\nThe problem defines asymptotic price stability by two conditions:\n1.  Returns must vanish: $\\lim_{t \\to \\infty} r_t = 0$.\n2.  The price must converge to a finite limit: $\\lim_{t \\to \\infty} p_t$ exists and is finite.\n\nWe analyze these two conditions. For the first condition, $\\lim_{t \\to \\infty} r_t = \\lim_{t \\to \\infty} (-\\kappa\\beta)^t \\cdot r_0 = 0$. This limit holds for any non-zero initial return $r_0 \\neq 0$ if and only if the absolute value of the common ratio is less than $1$:\n$$|-\\kappa\\beta| < 1$$\nSince the parameters $\\kappa$ and $\\beta$ are given as positive constants ($\\kappa > 0$, $\\beta > 0$), their product $\\kappa\\beta$ is also positive. The condition thus simplifies to:\n$$\\kappa\\beta < 1$$\n\nFor the second condition, we analyze the convergence of the price $p_t$. The price at time $t$ can be expressed as the initial price $p_0$ plus the sum of all subsequent returns:\n$$p_t = p_0 + \\sum_{i=1}^{t} r_i = p_0 + \\sum_{i=1}^{t} (-\\kappa\\beta)^i \\cdot r_0$$\nThe limit of the price as $t \\to \\infty$ is:\n$$\\lim_{t \\to \\infty} p_t = p_0 + r_0 \\sum_{i=1}^{\\infty} (-\\kappa\\beta)^i$$\nThis is a geometric series with a common ratio of $c = -\\kappa\\beta$. The series converges to a finite sum if and only if $|c| < 1$, which is precisely the same condition derived for the returns:\n$$|-\\kappa\\beta| < 1 \\implies \\kappa\\beta < 1$$\nWhen this condition holds, the price converges to the finite value $p_{\\infty} = p_0 + r_0 \\left( \\frac{-\\kappa\\beta}{1 - (-\\kappa\\beta)} \\right) = p_0 - r_0 \\frac{\\kappa\\beta}{1 + \\kappa\\beta}$.\n\nBoth conditions for asymptotic price stability lead to the same requirement. Therefore, the necessary and sufficient condition for asymptotic price stability in this market is $\\kappa\\beta < 1$.\n\nNext, we design an algorithm to numerically evaluate this stability condition over a finite horizon. The task is to determine if the magnitude of the return, $|r_t|$, falls below a tolerance $\\varepsilon$ at any time step $t$ in the range $\\{1, 2, \\dots, T\\}$. This can be implemented by simulating the return dynamics derived above.\nThe algorithm proceeds as follows for each test case $(\\kappa, \\beta, p_0, r_0, T, \\varepsilon)$:\n1.  Initialize a boolean flag, `is_stable`, to `False`.\n2.  Initialize the current return, `current_r`, with the value of $r_0$.\n3.  Calculate the constant multiplicative factor for the recurrence relation, $c = -\\kappa\\beta$.\n4.  Iterate for $t$ from $1$ to $T$. In each step:\n    a. Update the return: `current_r` becomes $c \\cdot \\text{current\\_r}$. This corresponds to calculating $r_t$.\n    b. Check the stability criterion: if $| \\text{current\\_r} | < \\varepsilon$, set `is_stable` to `True` and terminate the loop for this test case, as the condition has been met.\n5.  After the loop finishes (either by completion or early termination), the value of `is_stable` is the result for the given test case. This algorithm correctly operationalizes the stability definition by checking if the decay of returns is sufficiently rapid to meet the tolerance within the specified time horizon. The price $p_t$ does not need to be simulated as it is not part of the numerical test criterion.\nThis provides a complete plan for the required program.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by simulating a contrarian agent-based market model\n    for several test cases and checking for numerical stability.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple is (kappa, beta, p_0, r_0, T, epsilon)\n    test_cases = [\n        (0.2, 2.5, 0.0, 0.1, 200, 1e-6),   # Case A: Stable (kappa*beta = 0.5 < 1)\n        (0.5, 2.0, 0.0, 0.1, 200, 1e-6),   # Case B: Boundary (kappa*beta = 1.0)\n        (0.8, 2.0, 0.0, 0.1, 50, 1e-6),    # Case C: Unstable (kappa*beta = 1.6 > 1)\n        (0.95, 1.0, 0.0, -0.2, 500, 1e-3), # Case D: Near-boundary, slow convergence\n        (0.05, 1.0, 0.0, 1.0, 50, 1e-6),    # Case E: Fast convergence\n    ]\n\n    results = []\n    for case in test_cases:\n        kappa, beta, p0, r0, T, epsilon = case\n        \n        # This boolean will store the outcome for the current test case.\n        # It is initialized to False, assuming instability unless proven otherwise.\n        is_stable_numerically = False\n        \n        # The initial return r_0 is for the time step from t=-1 to t=0.\n        # The simulation starts by calculating r_1.\n        current_r = r0\n        \n        # The constant factor in the recurrence relation r_t = factor * r_{t-1}\n        # is derived from the model's foundational principles.\n        factor = -kappa * beta\n\n        # The problem asks to check for stability at any step t in {1, 2, ..., T}.\n        # The loop simulates the returns from t=1 to t=T.\n        for t in range(1, T + 1):\n            # Calculate the next return in the sequence: r_t = factor * r_{t-1}\n            current_r = factor * current_r\n            \n            # Check the operational stability criterion.\n            # If the absolute value of the return falls below the tolerance,\n            # the market is considered stable for this test.\n            if np.abs(current_r) < epsilon:\n                is_stable_numerically = True\n                # Stability is detected, no need for further simulation for this case.\n                break\n        \n        results.append(is_stable_numerically)\n\n    # Final print statement in the exact required format.\n    # The output is a comma-separated list of booleans enclosed in square brackets.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"}, {"introduction": "Building on the concept of feedback, we now populate our market with two iconic agent types: fundamentalists and trend-followers. This exercise [@problem_id:2372769] investigates how the interaction between these opposing strategies creates price dynamics that depend critically on the nature of the asset's underlying fundamental value. You will compare market outcomes when the fundamental value is anchored (mean-reverting) versus when it follows an unpredictable \"random walk,\" revealing key insights into sources of market volatility.", "id": "2372769", "problem": "Consider a simplified artificial stock market with a single risky asset. The asset has a latent fundamental value process $\\{v_t\\}_{t \\ge 0}$ and a market price process $\\{p_t\\}_{t \\ge -1}$. The market is populated by two representative trading strategies: a fundamental trader and a trend-follower. The total excess demand at time $t$ is the sum of the demands of these two strategies, and the price adjusts linearly to excess demand.\n\nFundamental base (model definitions):\n\n1. Fundamental value dynamics (two alternatives):\n   - Mean-reverting fundamental (discrete-time mean reversion to level $\\mu$):\n     $$\n     v_{t+1} = \\mu + \\rho \\left(v_t - \\mu\\right) + \\sigma_v \\,\\varepsilon_t,\\quad \\text{with } 0 \\le \\rho < 1,\n     $$\n     where $\\{\\varepsilon_t\\}$ are independent and identically distributed standard normal shocks, $\\varepsilon_t \\sim \\mathcal{N}(0,1)$.\n   - Random-walk fundamental (zero-drift random walk):\n     $$\n     v_{t+1} = v_t + \\sigma_v \\,\\varepsilon_t.\n     $$\n\n2. Trading rules and price adjustment:\n   - Fundamentalist demand:\n     $$\n     D_t^{(f)} = \\beta_f \\left(v_t - p_t\\right),\n     $$\n     where $\\beta_f \\ge 0$ measures fundamentalist aggressiveness.\n   - Trend-follower demand:\n     $$\n     D_t^{(c)} = \\beta_c \\left(p_t - p_{t-1}\\right),\n     $$\n     where $\\beta_c \\ge 0$ measures trend-following aggressiveness.\n   - Price adjustment (linear market impact):\n     $$\n     p_{t+1} = p_t + \\kappa \\left(D_t^{(f)} + D_t^{(c)}\\right) = p_t + \\kappa \\left[\\beta_f \\left(v_t - p_t\\right) + \\beta_c \\left(p_t - p_{t-1}\\right)\\right],\n     $$\n     where $\\kappa > 0$ is the price impact coefficient.\n\nInitial conditions and shocks:\n- Use $p_{-1} = p_0 = v_0 = \\mu$ for the mean-reverting case and $p_{-1} = p_0 = v_0 = 0$ for the random-walk case (equivalently, take $\\mu = 0$).\n- The shock sequence $\\{\\varepsilon_t\\}_{t=0}^{T-1}$ must be independent and identically distributed with $\\varepsilon_t \\sim \\mathcal{N}(0,1)$ and must be identical across the mean-reverting and random-walk simulations within each test case so that differences are attributable solely to the fundamental-value dynamics.\n\nTask:\n- For each parameter set in the test suite below, simulate the market for $T$ periods under both fundamental specifications (mean-reversion and random walk).\n- Compute the root mean squared deviation (RMSD) between price and fundamental value,\n  $$\n  \\mathrm{RMSD} = \\sqrt{\\frac{1}{T}\\sum_{t=1}^{T} \\left(p_t - v_t\\right)^2}.\n  $$\n- For each parameter set, compute the ratio\n  $$\n  R = \\frac{\\mathrm{RMSD}_{\\text{mean-reverting}}}{\\mathrm{RMSD}_{\\text{random-walk}}},\n  $$\n  rounded to $6$ decimal places.\n\nAngle units and physical units:\n- There are no physical units or angles in this problem.\n\nTest suite (each case specifies $(\\kappa,\\beta_f,\\beta_c,\\sigma_v,\\rho,\\mu,T,\\text{seed})$):\n- Case $1$ (happy path): $(0.1, 0.6, 0.6, 0.5, 0.95, 0.0, 4000, 12345)$.\n- Case $2$ (boundary: no trend-following): $(0.1, 0.8, 0.0, 0.5, 0.9, 0.0, 4000, 2024)$.\n- Case $3$ (strong but stable trend-following): $(0.1, 0.8, 1.2, 0.4, 0.9, 0.0, 5000, 777)$.\n- Case $4$ (small price impact): $(0.02, 0.6, 0.8, 0.6, 0.85, 0.0, 5000, 42)$.\n\nFinal output format:\n- Your program should produce a single line of output containing the ratios $R$ for the four cases as a comma-separated list enclosed in square brackets, for example, $\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4\\right]$, where each result is a float rounded to $6$ decimal places.\n- The program must be completely deterministic: within each case, use the given seed to generate a single shock sequence $\\{\\varepsilon_t\\}$ shared by both fundamental specifications.\n\nNo user input:\n- The program must not read any input and must run as-is to completion.", "solution": "The problem statement is subjected to validation. It formulates a well-defined computational task based on a standard agent-based model from financial econometrics, specifically of the Brock-Hommes variety. The system is described by a set of coupled, first- and second-order stochastic difference equations. All parameters, initial conditions, and procedural steps are explicitly defined. The problem is therefore deemed valid, and a solution is constructed as follows.\n\nThe core of the solution is a direct numerical simulation of the market dynamics over a discrete time horizon of $T$ periods. This is performed for two distinct specifications of the fundamental value process: a mean-reverting process and a random-walk process. The objective is to compute the ratio of the root mean squared deviation (RMSD) between price and value for these two scenarios. The procedure is organized into four distinct steps for each given parameter set.\n\nStep 1: Shock Generation. For each test case, a sequence of $T$ independent and identically distributed standard normal shocks, $\\{\\varepsilon_t\\}_{t=0}^{T-1}$ where $\\varepsilon_t \\sim \\mathcal{N}(0,1)$, is generated using the `numpy` random number generator. The generator is initialized with the specified seed to ensure that the results are deterministic and reproducible. This same sequence of shocks is used for both the mean-reverting and random-walk simulations within a single test case, ensuring that any observed differences in outcomes are attributable solely to the difference in the fundamental value dynamics.\n\nStep 2: Time Series Simulation. A simulation function is implemented to generate the time series for the fundamental value, $\\{v_t\\}$, and the market price, $\\{p_t\\}$. This function accommodates both specified models for fundamental value.\n- **Initialization:** For a simulation of duration $T$, we initialize arrays for $v_t$ for $t \\in \\{0, 1, \\dots, T\\}$ and $p_t$ for $t \\in \\{-1, 0, \\dots, T\\}$. The initial conditions are set according to the problem statement: $p_{-1} = p_0 = v_0 = \\mu$ for the mean-reverting case and $p_{-1} = p_0 = v_0 = 0$ for the random-walk case. As all provided test cases specify the mean level $\\mu=0$, the initial state is consistently $(v_0, p_0, p_{-1}) = (0, 0, 0)$ for both models.\n- **Iterative Calculation:** The system is evolved iteratively for time steps $t$ from $0$ to $T-1$. In each step, we first compute $v_{t+1}$ and then $p_{t+1}$.\n  - The fundamental value $v_{t+1}$ is updated according to its specified dynamics, using the pre-generated shock $\\varepsilon_t$:\n    - For the mean-reverting model: $v_{t+1} = \\mu + \\rho (v_t - \\mu) + \\sigma_v \\varepsilon_t$.\n    - For the random-walk model: $v_{t+1} = v_t + \\sigma_v \\varepsilon_t$.\n  - The market price $p_{t+1}$ is then updated based on the total excess demand at time $t$, which is the sum of the fundamentalist demand $D_t^{(f)} = \\beta_f (v_t - p_t)$ and the trend-follower demand $D_t^{(c)} = \\beta_c (p_t - p_{t-1})$. The price adjustment mechanism is:\n    $$p_{t+1} = p_t + \\kappa \\left[\\beta_f (v_t - p_t) + \\beta_c (p_t - p_{t-1})\\right].$$\nThis iterative process yields the complete time series $\\{v_t\\}_{t=0}^T$ and $\\{p_t\\}_{t=-1}^T$.\n\nStep 3: RMSD Calculation. Following the simulation, the root mean squared deviation (RMSD) is calculated for each of the two models. The RMSD quantifies the average magnitude of the price-value mispricing over the simulation period, excluding the initial state at $t=0$. It is defined as:\n$$\n\\mathrm{RMSD} = \\sqrt{\\frac{1}{T}\\sum_{t=1}^{T} \\left(p_t - v_t\\right)^2}.\n$$\nThis calculation is implemented using vectorized operations in `numpy` for computational efficiency, applied to the generated time series slices $\\{p_t\\}_{t=1}^T$ and $\\{v_t\\}_{t=1}^T$.\n\nStep 4: Ratio Computation. For each parameter set provided in the test suite, the final result is the ratio $R$ of the RMSD from the mean-reverting model to the RMSD from the random-walk model:\n$$\nR = \\frac{\\mathrm{RMSD}_{\\text{mean-reverting}}}{\\mathrm{RMSD}_{\\text{random-walk}}}.\n$$\nThis ratio is calculated and subsequently rounded to $6$ decimal places, as specified in the problem statement, before being included in the final output. The entire process is repeated for all test cases.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(params, shocks, model_type):\n    \"\"\"\n    Simulates the artificial stock market for a given model type and parameters.\n\n    Args:\n        params (tuple): A tuple of model parameters: \n                        (kappa, beta_f, beta_c, sigma_v, rho, mu, T).\n        shocks (np.ndarray): A pre-generated array of standard normal shocks.\n        model_type (str): 'mean-reverting' or 'random-walk'.\n\n    Returns:\n        float: The calculated Root Mean Squared Deviation (RMSD).\n    \"\"\"\n    kappa, beta_f, beta_c, sigma_v, rho, mu, T = params\n    \n    # Initialize arrays for fundamental value and price\n    # v is of size T+1 for t=0...T\n    # p is of size T+2 for t=-1...T (p_t is at index t+1)\n    v = np.zeros(T + 1)\n    p = np.zeros(T + 2)\n\n    # Set initial conditions\n    # For all test cases, mu=0, so ICs are the same for both models.\n    v[0] = mu if model_type == 'mean-reverting' else 0.0\n    p[1] = v[0]  # p_0 = v_0\n    p[0] = v[0]  # p_{-1} = v_0\n\n    # Main simulation loop\n    for t in range(T):\n        # Update fundamental value v_{t+1}\n        if model_type == 'mean-reverting':\n            v[t + 1] = mu + rho * (v[t] - mu) + sigma_v * shocks[t]\n        elif model_type == 'random-walk':\n            v[t + 1] = v[t] + sigma_v * shocks[t]\n\n        # Update price p_{t+1}\n        # Accessing p_t, p_{t-1}, v_t\n        p_t = p[t + 1]\n        p_t_minus_1 = p[t]\n        v_t = v[t]\n        \n        demand_f = beta_f * (v_t - p_t)\n        demand_c = beta_c * (p_t - p_t_minus_1)\n        \n        p[t + 2] = p_t + kappa * (demand_f + demand_c)\n\n    # Calculate RMSD for the period t=1...T\n    # The sum is over t=1 to T.\n    # p_series corresponds to p_1, ..., p_T, which are at indices 2 to T+1\n    # v_series corresponds to v_1, ..., v_T, which are at indices 1 to T\n    p_series = p[2:]\n    v_series = v[1:]\n    \n    deviations_sq = (p_series - v_series)**2\n    rmsd = np.sqrt(np.mean(deviations_sq))\n    \n    return rmsd\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Test suite: (kappa, beta_f, beta_c, sigma_v, rho, mu, T, seed)\n    test_cases = [\n        (0.1, 0.6, 0.6, 0.5, 0.95, 0.0, 4000, 12345),\n        (0.1, 0.8, 0.0, 0.5, 0.9, 0.0, 4000, 2024),\n        (0.1, 0.8, 1.2, 0.4, 0.9, 0.0, 5000, 777),\n        (0.02, 0.6, 0.8, 0.6, 0.85, 0.0, 5000, 42),\n    ]\n\n    results = []\n    for case in test_cases:\n        kappa, beta_f, beta_c, sigma_v, rho, mu, T, seed = case\n        \n        # Generate the common shock sequence\n        rng = np.random.default_rng(seed)\n        shocks = rng.standard_normal(size=T)\n        \n        # Parameters for the simulation function\n        sim_params = (kappa, beta_f, beta_c, sigma_v, rho, mu, T)\n        \n        # Run simulation for mean-reverting case\n        rmsd_mr = run_simulation(sim_params, shocks, 'mean-reverting')\n        \n        # Run simulation for random-walk case\n        rmsd_rw = run_simulation(sim_params, shocks, 'random-walk')\n\n        # Compute the ratio and round to 6 decimal places\n        if rmsd_rw == 0:\n            # Handle potential division by zero, though unlikely in this model\n            ratio = np.nan\n        else:\n            ratio = rmsd_mr / rmsd_rw\n        \n        results.append(round(ratio, 6))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"}, {"introduction": "In our final practice, we construct a more sophisticated artificial stock market where agents are not static but adaptive. This model [@problem_id:2372798], based on the seminal Brock-Hommes framework, allows agents to switch between fundamental and trend-following strategies based on which has been more profitable recently. By simulating this \"market ecology,\" you will explore how the interplay between strategy performance and population dynamics can generate complex phenomena, from stable convergence to excessive volatility.", "id": "2372798", "problem": "Construct an Artificial Stock Market (ASM) with two representative strategies, \"fundamentalist\" and \"chartist,\" in discrete time indexed by $t \\in \\{0,1,\\dots,T\\}$. Let the asset price be $p_t \\in \\mathbb{R}$ and the constant fundamental value be $v \\in \\mathbb{R}$. The fractions of agents using the fundamentalist and chartist strategies at time $t$ are $w^F_t \\in [0,1]$ and $w^C_t \\in [0,1]$, respectively, with $w^F_t + w^C_t = 1$ for all $t$. Let $p_{-1} = p_0$.\n\nThe individual (normalized) demands at time $t$ are given by:\n- Fundamentalist demand: $d^F_t = \\beta_F \\left( v - p_t \\right)$.\n- Chartist (trend-following) demand: $d^C_t = \\beta_C \\left( p_t - p_{t-1} \\right)$.\n\nAggregate excess demand is $ED_t = w^F_t d^F_t + w^C_t d^C_t$. The market maker adjusts the price according to:\n$$\np_{t+1} = p_t + \\alpha \\, ED_t,\n$$\nwhere $\\alpha \\in \\mathbb{R}_{\\ge 0}$ is the price impact parameter.\n\nDefine the realized one-period profit for strategy $s \\in \\{F,C\\}$ at time $t$ by:\n$$\n\\pi^s_t = d^s_t \\left(p_{t+1} - p_t\\right) - \\frac{c}{2} \\left(d^s_t\\right)^2,\n$$\nwhere $c \\in \\mathbb{R}_{\\ge 0}$ is a transaction cost parameter. Let $U^s_t$ be the performance score of strategy $s$ at time $t$, initialized at $U^F_0 = 0$ and $U^C_0 = 0$, and update the scores via exponential smoothing:\n$$\nU^s_{t+1} = (1 - \\delta) U^s_t + \\delta \\, \\pi^s_t,\n$$\nwith smoothing parameter $\\delta \\in (0,1]$.\n\nAgents switch strategies according to a multinomial logit (discrete choice) rule with intensity of choice $\\gamma \\in \\mathbb{R}_{\\ge 0}$:\n$$\nw^F_{t+1} = \\frac{\\exp\\left(\\gamma U^F_{t+1}\\right)}{\\exp\\left(\\gamma U^F_{t+1}\\right) + \\exp\\left(\\gamma U^C_{t+1}\\right)}, \\quad\nw^C_{t+1} = 1 - w^F_{t+1}.\n$$\n\nFor each simulation, define the return sequence $r_t = p_t - p_{t-1}$ for $t \\in \\{1,\\dots,T\\}$ and its volatility as the standard deviation:\n$$\n\\sigma = \\sqrt{\\frac{1}{T} \\sum_{t=1}^{T} \\left( r_t - \\bar{r} \\right)^2},\n$$\nwhere $\\bar{r} = \\frac{1}{T} \\sum_{t=1}^{T} r_t$.\n\nYour task is to implement the above model exactly and compute, for each parameter set in the test suite below, the tuple consisting of:\n- The terminal price $p_T$,\n- The terminal chartist fraction $w^C_T$,\n- The volatility $\\sigma$.\n\nAll initial conditions are $p_{-1} = p_0$, $U^F_0 = 0$, $U^C_0 = 0$, and the initial weight $w^F_0$ is given per test case (with $w^C_0 = 1 - w^F_0$). All outputs must be real numbers.\n\nTest suite (use these four parameter sets exactly, in the order listed):\n- Case $1$: $T = 50$, $v = 1.0$, $p_0 = 0.8$, $\\alpha = 0.4$, $\\beta_F = 1.0$, $\\beta_C = 1.0$, $c = 0.1$, $\\delta = 0.5$, $\\gamma = 2.0$, $w^F_0 = 0.5$.\n- Case $2$: $T = 50$, $v = 1.0$, $p_0 = 0.2$, $\\alpha = 0.5$, $\\beta_F = 1.0$, $\\beta_C = 0.0$, $c = 0.1$, $\\delta = 0.5$, $\\gamma = 2.0$, $w^F_0 = 1.0$.\n- Case $3$: $T = 30$, $v = 1.0$, $p_0 = 0.5$, $\\alpha = 0.0$, $\\beta_F = 1.0$, $\\beta_C = 1.0$, $c = 0.1$, $\\delta = 0.5$, $\\gamma = 3.0$, $w^F_0 = 0.5$.\n- Case $4$: $T = 80$, $v = 1.0$, $p_0 = 1.2$, $\\alpha = 0.3$, $\\beta_F = 0.8$, $\\beta_C = 1.2$, $c = 0.05$, $\\delta = 0.3$, $\\gamma = 5.0$, $w^F_0 = 0.5$.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For each case $i \\in \\{1,2,3,4\\}$, append the three numbers $(p_T, w^C_T, \\sigma)$ in that order. Thus the final output must be of the form\n$[p_T^{(1)}, w^{C,(1)}_T, \\sigma^{(1)}, p_T^{(2)}, w^{C,(2)}_T, \\sigma^{(2)}, p_T^{(3)}, w^{C,(3)}_T, \\sigma^{(3)}, p_T^{(4)}, w^{C,(4)}_T, \\sigma^{(4)}]$.\n\nAll numeric answers are unitless real numbers and must be reported as raw decimal values. No angles or physical units are involved. Do not include percentage signs; express fractions in $[0,1]$ as decimals.", "solution": "The problem statement has been rigorously evaluated and is determined to be valid. It constitutes a well-posed problem in the domain of computational economics, specifically the simulation of an Artificial Stock Market (ASM). The model is a discrete-time dynamical system based on the established Brock-Hommes framework. All model equations, parameters, and initial conditions required for a unique numerical solution are provided unambiguously. The problem is scientifically grounded, internally consistent, and objective. I will now proceed to construct the solution.\n\nThe model is a system of coupled, non-linear difference equations. The state of the system at any given time $t$ can be specified by the vector of variables $(p_t, p_{t-1}, U^F_t, U^C_t, w^F_t)$. Given the state at time $t$, the state at time $t+1$ is determined uniquely. The solution approach is therefore a direct numerical simulation, stepping forward in time from $t=0$ to $T$.\n\nLet us define the state variables and their initialization:\n- Price history: An array to store $p_t$ for $t \\in \\{0, 1, \\dots, T\\}$. We are given $p_0$ and the condition $p_{-1} = p_0$.\n- Fundamentalist fraction history: An array for $w^F_t$. We are given $w^F_0$.\n- Performance score histories: Arrays for $U^F_t$ and $U^C_t$. We are given initial conditions $U^F_0 = 0$ and $U^C_0 = 0$.\n\nThe simulation proceeds via a loop from $t=0$ to $T-1$. In each iteration $t$, we compute the state for time $t+1$ based on the state at time $t$ (and $t-1$ for the price). The sequence of operations is as follows:\n\n1.  **Calculate Individual Demands**: At time $t$, the demands for the two types of agents are determined.\n    - Fundamentalist demand depends on the deviation of the current price $p_t$ from the fundamental value $v$:\n    $$\n    d^F_t = \\beta_F (v - p_t)\n    $$\n    - Chartist demand is based on the most recent price trend, $(p_t - p_{t-1})$:\n    $$\n    d^C_t = \\beta_C (p_t - p_{t-1})\n    $$\n    For the initial step $t=0$, we use the condition $p_{-1} = p_0$, which results in $d^C_0 = 0$.\n\n2.  **Calculate Aggregate Excess Demand**: The total excess demand $ED_t$ is the weighted average of the individual demands, using the population fractions $w^F_t$ and $w^C_t = 1 - w^F_t$ at time $t$:\n    $$\n    ED_t = w^F_t d^F_t + w^C_t d^C_t\n    $$\n\n3.  **Update Price**: The market maker adjusts the price in proportion to the excess demand, governed by the price impact parameter $\\alpha$:\n    $$\n    p_{t+1} = p_t + \\alpha ED_t\n    $$\n\n4.  **Calculate Realized Profits**: Once the next period's price $p_{t+1}$ is determined, the one-period profits $\\pi^s_t$ for each strategy $s \\in \\{F,C\\}$ can be computed. The profit consists of capital gains from the position taken, minus a quadratic transaction cost:\n    $$\n    \\pi^s_t = d^s_t (p_{t+1} - p_t) - \\frac{c}{2} (d^s_t)^2\n    $$\n    Note that the price change term can be substituted as $(p_{t+1} - p_t) = \\alpha ED_t$.\n\n5.  **Update Performance Scores**: The performance scores $U^s_t$, which represent the perceived fitness of each strategy, are updated using an exponential smoothing average of past profits. The parameter $\\delta$ controls the \"memory\" of the agents:\n    $$\n    U^s_{t+1} = (1 - \\delta) U^s_t + \\delta \\pi^s_t\n    $$\n\n6.  **Update Strategy Fractions**: Agents re-evaluate their strategy choice for the next period based on the updated performance scores. The fraction of agents choosing the fundamentalist strategy at time $t+1$ is given by the discrete choice (multinomial logit) probability, with $\\gamma$ as the intensity of choice parameter:\n    $$\n    w^F_{t+1} = \\frac{\\exp(\\gamma U^F_{t+1})}{\\exp(\\gamma U^F_{t+1}) + \\exp(\\gamma U^C_{t+1})} = \\frac{1}{1 + \\exp\\left(\\gamma (U^C_{t+1} - U^F_{t+1})\\right)}\n    $$\n    The second form is preferable for numerical stability, as it mitigates the risk of floating-point overflow when the exponent is large and positive. The chartist fraction is simply $w^C_{t+1} = 1 - w^F_{t+1}$.\n\nThis loop runs for $T$ iterations, generating the time series for all state variables up to time $T$.\n\nAfter the simulation is complete, the final output quantities are computed:\n- The terminal price is $p_T$.\n- The terminal chartist fraction is $w^C_T = 1 - w^F_T$.\n- The volatility $\\sigma$ is calculated over the time series of returns $r_t = p_t - p_{t-1}$ for $t \\in \\{1, \\dots, T\\}$. This involves computing the mean return $\\bar{r}$ and then the population standard deviation of the returns:\n$$\n\\sigma = \\sqrt{\\frac{1}{T} \\sum_{t=1}^{T} (r_t - \\bar{r})^2}\n$$\nThis procedure will be implemented for each of the four specified parameter sets to produce the final results.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(T, v, p0, alpha, beta_F, beta_C, c, delta, gamma, wF0):\n    \"\"\"\n    Simulates the Artificial Stock Market model for a given set of parameters.\n    \"\"\"\n    # Initialize arrays to store time series data\n    p = np.zeros(T + 1)\n    wF = np.zeros(T + 1)\n    UF = np.zeros(T + 1)\n    UC = np.zeros(T + 1)\n\n    # Set initial conditions at t=0\n    p[0] = p0\n    wF[0] = wF0\n    # UF[0] and UC[0] are initialized to 0 by np.zeros\n\n    # Main simulation loop from t=0 to T-1\n    for t in range(T):\n        # Retrieve current state variables for time t\n        p_t = p[t]\n        p_tm1 = p[t-1] if t > 0 else p[0]  # Condition: p_{-1} = p_0\n\n        wF_t = wF[t]\n        wC_t = 1.0 - wF_t\n        \n        UF_t = UF[t]\n        UC_t = UC[t]\n        \n        # Step 1: Calculate individual demands\n        dF_t = beta_F * (v - p_t)\n        dC_t = beta_C * (p_t - p_tm1)\n        \n        # Step 2: Calculate aggregate excess demand\n        ED_t = wF_t * dF_t + wC_t * dC_t\n        \n        # Step 3: Update price\n        p_tp1 = p_t + alpha * ED_t\n        p[t+1] = p_tp1\n        \n        # Step 4: Calculate realized profits\n        price_change = p_tp1 - p_t\n        profitF_t = dF_t * price_change - (c / 2.0) * dF_t**2\n        profitC_t = dC_t * price_change - (c / 2.0) * dC_t**2\n        \n        # Step 5: Update performance scores\n        UF_tp1 = (1.0 - delta) * UF_t + delta * profitF_t\n        UC_tp1 = (1.0 - delta) * UC_t + delta * profitC_t\n        UF[t+1] = UF_tp1\n        UC[t+1] = UC_tp1\n        \n        # Step 6: Update strategy fractions (with numerical stability)\n        diff_U = gamma * (UC_tp1 - UF_tp1)\n        \n        # Handle potential overflow in np.exp()\n        if diff_U > 700:\n            wF_tp1 = 0.0\n        else:\n            wF_tp1 = 1.0 / (1.0 + np.exp(diff_U))\n        \n        wF[t+1] = wF_tp1\n\n    # After the loop, calculate final results\n    p_T = p[T]\n    wF_T = wF[T]\n    wC_T = 1.0 - wF_T\n    \n    # Calculate volatility of returns\n    if T > 0:\n        returns = p[1:] - p[:-1]\n        sigma = np.std(returns)\n    else:  # Edge case where T=0, though not in test suite\n        sigma = 0.0\n\n    return p_T, wC_T, sigma\n\ndef solve():\n    \"\"\"\n    Runs the simulations for all test cases and prints the formatted output.\n    \"\"\"\n    test_cases = [\n        # Case 1\n        {'T': 50, 'v': 1.0, 'p0': 0.8, 'alpha': 0.4, 'beta_F': 1.0, 'beta_C': 1.0, 'c': 0.1, 'delta': 0.5, 'gamma': 2.0, 'wF0': 0.5},\n        # Case 2\n        {'T': 50, 'v': 1.0, 'p0': 0.2, 'alpha': 0.5, 'beta_F': 1.0, 'beta_C': 0.0, 'c': 0.1, 'delta': 0.5, 'gamma': 2.0, 'wF0': 1.0},\n        # Case 3\n        {'T': 30, 'v': 1.0, 'p0': 0.5, 'alpha': 0.0, 'beta_F': 1.0, 'beta_C': 1.0, 'c': 0.1, 'delta': 0.5, 'gamma': 3.0, 'wF0': 0.5},\n        # Case 4\n        {'T': 80, 'v': 1.0, 'p0': 1.2, 'alpha': 0.3, 'beta_F': 0.8, 'beta_C': 1.2, 'c': 0.05, 'delta': 0.3, 'gamma': 5.0, 'wF0': 0.5},\n    ]\n\n    results = []\n    for params in test_cases:\n        p_T, wC_T, sigma = run_simulation(**params)\n        results.extend([p_T, wC_T, sigma])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"}]}