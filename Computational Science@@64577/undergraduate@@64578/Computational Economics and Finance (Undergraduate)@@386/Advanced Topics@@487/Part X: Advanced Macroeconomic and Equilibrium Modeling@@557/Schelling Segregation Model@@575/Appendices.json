{"hands_on_practices": [{"introduction": "This first practice is your entry into simulating emergent social phenomena. You will build the classic Schelling model from scratch, where individual agents make simple decisions to move if their local neighborhood doesn't meet a minimum preference for 'like' neighbors. By implementing a dynamic where unsatisfied agents randomly move to vacant spots, you will witness firsthand how macro-level segregation can arise from micro-level preferences, even when those preferences are quite mild [@problem_id:2411695]. This exercise provides a concrete foundation in agent-based modeling and illustrates the model's core, often surprising, insight.", "id": "2411695", "problem": "You will model Schelling’s residential segregation as a time-homogeneous Markov chain on a two-dimensional periodic square lattice, formulated in the language of statistical physics. The lattice has linear size $N$, sites indexed by integer coordinates $(i,j)$ with $i \\in \\{0,\\dots,N-1\\}$ and $j \\in \\{0,\\dots,N-1\\}$, and periodic boundary conditions. Each site carries a state $s_{i,j} \\in \\{-1,0,+1\\}$, where $s_{i,j}=+1$ denotes an agent of group $A$, $s_{i,j}=-1$ denotes an agent of group $B$, and $s_{i,j}=0$ denotes an empty site.\n\nDefine the Moore neighborhood of radius $r$ for site $(i,j)$ to be all sites $(i+\\Delta i \\bmod N, j+\\Delta j \\bmod N)$ with $\\Delta i,\\Delta j \\in \\{-r,\\dots,r\\}$ excluding $(\\Delta i,\\Delta j)=(0,0)$. For any occupied site $(i,j)$ with $s_{i,j} \\in \\{-1,+1\\}$, define the occupied-neighbor count $n_{i,j}^{\\mathrm{occ}}$ as the number of occupied neighbors in its neighborhood, and define the like-neighbor count $n_{i,j}^{\\mathrm{like}}$ as the number of those occupied neighbors whose state equals $s_{i,j}$. The satisfaction fraction is\n$$\n\\phi_{i,j} =\n\\begin{cases}\n\\frac{n_{i,j}^{\\mathrm{like}}}{n_{i,j}^{\\mathrm{occ}}}, & \\text{if } n_{i,j}^{\\mathrm{occ}} > 0,\\\n$$6pt]\n1, & \\text{if } n_{i,j}^{\\mathrm{occ}} = 0,\n\\end{cases}\n$$\nand an occupied site is said to be satisfied at threshold $\\tau \\in [0,1]$ if $\\phi_{i,j} \\ge \\tau$. Empty sites have no satisfaction value.\n\nLet the state space be the set of all configurations with fixed counts of $+1$, $-1$, and $0$ determined by specified fractions. The Markov chain transitions in discrete time as follows. At each step, if at least one occupied site is unsatisfied, choose uniformly at random one unsatisfied occupied site and uniformly at random one empty site, and move the chosen agent to the chosen empty site (the agent’s original site becomes empty). If no occupied site is unsatisfied, the chain remains in the current state. This defines a time-homogeneous Markov chain on the finite state space with periodic boundary conditions. The process is terminated either when all occupied sites are satisfied (an absorbing configuration for this kernel) or when a specified maximum number of steps $S_{\\max}$ is reached.\n\nInitialization is random subject to fixed counts: given $N$, an empty-site fraction $f_{\\mathrm{empty}} \\in [0,1)$, and a plus-type fraction among occupied sites $f_{+} \\in [0,1]$, the total number of sites is $N^2$, the number of empty sites is $N^2 f_{\\mathrm{empty}}$, and among the $N^2(1-f_{\\mathrm{empty}})$ occupied sites, $N^2(1-f_{\\mathrm{empty}}) f_{+}$ are $+1$ and the remainder are $-1$. Assume all these counts are integers for the specified test cases. The initial configuration is constructed by placing these counts uniformly at random across the lattice without bias.\n\nFor each test case below, simulate the chain from the specified random initial condition with the given neighborhood radius $r$, satisfaction threshold $\\tau$, and maximum steps $S_{\\max}$. Let $T$ be the number of executed moves until termination (so $T=0$ if the initial configuration is already absorbing, and $T=S_{\\max}$ if the cap is reached before absorption). Let $\\bar{\\phi}$ be the mean satisfaction fraction at termination, defined as the arithmetic mean of $\\phi_{i,j}$ over all occupied sites $(i,j)$. Report $\\bar{\\phi}$ rounded to three decimal places.\n\nYour program must produce results for the following test suite. In each case, use independent pseudo-random initialization and random choices with the given seed for reproducibility.\n\n- Case $1$: $N=20$, $f_{\\mathrm{empty}}=0.1$, $f_{+}=0.5$, $\\tau=0.5$, $r=1$, $S_{\\max}=20000$, $\\text{seed}=1$.\n- Case $2$: $N=15$, $f_{\\mathrm{empty}}=0.2$, $f_{+}=0.5$, $\\tau=0$, $r=1$, $S_{\\max}=20000$, $\\text{seed}=2$.\n- Case $3$: $N=20$, $f_{\\mathrm{empty}}=0.2$, $f_{+}=0.5$, $\\tau=0.9$, $r=1$, $S_{\\max}=20000$, $\\text{seed}=3$.\n- Case $4$: $N=5$, $f_{\\mathrm{empty}}=0.2$, $f_{+}=0.5$, $\\tau=0.6$, $r=1$, $S_{\\max}=20000$, $\\text{seed}=4$.\n\nFinal output format: Your program should produce a single line containing the results as a comma-separated list enclosed in square brackets, where each element is the pair $[T,\\bar{\\phi}]$ for a test case, with $\\bar{\\phi}$ rounded to three decimal places. For example, a valid output with two hypothetical results would look like \"[[$1$, $0.750$],[$200$, $0.643$]]\". There must be no additional text. All reported $\\bar{\\phi}$ values must be rounded to three decimal places, and $T$ must be an integer.", "solution": "The problem is valid. It presents a well-defined computational task based on the established Schelling model of segregation, formulated within the framework of statistical physics using a time-homogeneous Markov chain on a lattice. All parameters, initial conditions, and dynamics are specified unambiguously.\n\nThe solution requires the simulation of this Markov chain. The core of the methodology is outlined below.\n\n**1. System State and Initialization**\nThe system state is a configuration on a `$2$`-dimensional square lattice of linear size $N$. This is represented by an $N \\times N$ matrix, $\\mathbf{S}$, with periodic boundary conditions. Each site $(i,j)$ has a state $s_{i,j} \\in \\{-1, 0, +1\\}$, where `$+1$` and `$-1$` denote agents of two different types, and `$0$` denotes an empty site.\n\nThe initial configuration is generated randomly, but with fixed numbers of each type of site. Given the total number of sites $N^2$, an empty-site fraction $f_{\\mathrm{empty}}$, and a plus-type fraction among occupied sites $f_{+}$, the counts are:\n- Number of empty sites: $N_{\\mathrm{empty}} = \\lfloor N^2 f_{\\mathrm{empty}} \\rfloor$\n- Number of occupied sites: $N_{\\mathrm{occ}} = N^2 - N_{\\mathrm{empty}}$\n- Number of type `$+1$` agents: $N_{+} = \\lfloor N_{\\mathrm{occ}} f_{+} \\rfloor$\n- Number of type `$-1$` agents: $N_{-} = N_{\\mathrm{occ}} - N_{+}$\n\nA `$1$`-dimensional array is created with these specified counts of `$+1$`, `$-1$`, and `$0$` values. This array is shuffled using the provided pseudo-random seed and then reshaped into the $N \\times N$ matrix $\\mathbf{S}$, ensuring a uniform random placement of agents.\n\n**2. Agent Satisfaction and Neighborhood Analysis**\nThe dynamics are driven by agent dissatisfaction. The satisfaction of an agent at an occupied site $(i,j)$ is quantified by the satisfaction fraction $\\phi_{i,j}$. This is determined by its local environment within a Moore neighborhood of radius $r$. For each agent, we must compute the number of its occupied neighbors, $n_{i,j}^{\\mathrm{occ}}$, and the number of its neighbors of the same type, $n_{i,j}^{\\mathrm{like}}$. The satisfaction fraction is defined as:\n$$\n\\phi_{i,j} =\n\\begin{cases}\n\\frac{n_{i,j}^{\\mathrm{like}}}{n_{i,j}^{\\mathrm{occ}}}, & \\text{if } n_{i,j}^{\\mathrm{occ}} > 0\\\\\n1, & \\text{if } n_{i,j}^{\\mathrm{occ}} = 0\n\\end{cases}\n$$\nAn agent is deemed unsatisfied if its satisfaction fraction is below a given threshold, i.e., $\\phi_{i,j} < \\tau$.\n\nTo compute the neighbor counts efficiently for all sites simultaneously, we employ `$2$`-dimensional convolution. We define binary indicator matrices for occupied sites ($\\mathbf{M}_{\\mathrm{occ}}$), type `$+1$` sites ($\\mathbf{M}_{+}$), and type `$-1$` sites ($\\mathbf{M}_{-}$). A convolution kernel $\\mathbf{K}$, a $(2r+1) \\times (2r+1)$ matrix of `$1$`s with a `$0$` at its center, represents the neighborhood sum. The neighbor count maps are then given by the convolution operation (denoted by $*$) with periodic boundary handling:\n- Occupied neighbor count map: $\\mathbf{N}_{\\mathrm{occ}} = \\mathbf{M}_{\\mathrm{occ}} * \\mathbf{K}$\n- Type `$+1$` neighbor map: $\\mathbf{N}_{+} = \\mathbf{M}_{+} * \\mathbf{K}$\n- Type `$-1$` neighbor map: $\\mathbf{N}_{-} = \\mathbf{M}_{-} * \\mathbf{K}$\nFrom these maps, the $n_{i,j}^{\\mathrm{like}}$ value for each site is determined by its own type, and the matrix of $\\phi_{i,j}$ values is subsequently calculated.\n\n**3. Markov Chain Dynamics**\nThe system evolves over discrete time steps. The simulation proceeds for a maximum of $S_{\\max}$ steps. In each step:\n1.  The satisfaction of every agent is computed. The set of all coordinates of unsatisfied agents is identified.\n2.  If this set is empty, all agents are satisfied. The system has reached an absorbing state, and the simulation terminates. The total number of moves, $T$, is recorded.\n3.  If unsatisfied agents exist, `$1$` unsatisfied agent and `$1$` empty site are chosen uniformly at random from their respective sets of available locations.\n4.  The state of the chosen agent's site is swapped with the state of the chosen empty site. This constitutes `$1$` move, and the step counter $T$ is incremented.\n5.  If the simulation runs for the maximum number of steps without reaching an absorbing state, it terminates, and $T=S_{\\max}$.\n\n**4. Final Measurement**\nUpon termination, the final mean satisfaction fraction, $\\bar{\\phi}$, is calculated. This is the arithmetic mean of $\\phi_{i,j}$ over all occupied sites in the final grid configuration. The required outputs for each test case are the integer number of moves $T$ and the value of $\\bar{\\phi}$ rounded to `$3$` decimal places. The implementation performs this entire procedure for each test case specified in the problem.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.signal import convolve2d\n\ndef run_simulation(N, f_empty, f_plus, tau, r, S_max, seed):\n    \"\"\"\n    Simulates Schelling's segregation model for a given set of parameters.\n\n    Args:\n        N (int): Linear size of the lattice.\n        f_empty (float): Fraction of empty sites.\n        f_plus (float): Fraction of +1 agents among occupied sites.\n        tau (float): Satisfaction threshold.\n        r (int): Radius of the Moore neighborhood.\n        S_max (int): Maximum number of simulation steps.\n        seed (int): Seed for the pseudo-random number generator.\n\n    Returns:\n        tuple[int, float]: A tuple containing the number of moves (T)\n                           and the mean satisfaction (phi_bar).\n    \"\"\"\n    # 1. Initialization\n    rng = np.random.default_rng(seed)\n\n    N_total = N * N\n    N_empty = int(N_total * f_empty)\n    N_occ = N_total - N_empty\n    N_plus = int(N_occ * f_plus)\n    N_minus = N_occ - N_plus\n\n    # Create and shuffle the initial population on a 1D array\n    initial_flat_grid = np.array(\n        [1] * N_plus + [-1] * N_minus + [0] * N_empty, dtype=np.int8\n    )\n    rng.shuffle(initial_flat_grid)\n    grid = initial_flat_grid.reshape((N, N))\n\n    # Convolution kernel for Moore neighborhood\n    kernel = np.ones((2 * r + 1, 2 * r + 1), dtype=np.uint8)\n    kernel[r, r] = 0\n\n    T = 0\n    # 2. Main simulation loop\n    for _ in range(S_max):\n        occupied_mask = grid != 0\n        plus_mask = grid == 1\n        minus_mask = grid == -1\n\n        # Use convolution to find neighbor counts efficiently\n        n_occ_map = convolve2d(occupied_mask, kernel, mode=\"same\", boundary=\"wrap\")\n\n        # Calculate satisfaction for all agents\n        # Default phi to 1, for agents with 0 occupied neighbors\n        phi_map = np.ones_like(grid, dtype=float)\n        \n        # Identify sites where phi needs to be calculated (occupied with neighbors)\n        calc_phi_mask = occupied_mask & (n_occ_map > 0)\n\n        if np.any(calc_phi_mask):\n            n_plus_neighbors = convolve2d(plus_mask, kernel, mode=\"same\", boundary=\"wrap\")\n            n_minus_neighbors = convolve2d(minus_mask, kernel, mode=\"same\", boundary=\"wrap\")\n\n            n_like_map = np.zeros_like(grid, dtype=int)\n            n_like_map[plus_mask] = n_plus_neighbors[plus_mask]\n            n_like_map[minus_mask] = n_minus_neighbors[minus_mask]\n            \n            # Use errstate to prevent warnings on potential division by zero,\n            # though the mask should already prevent this.\n            with np.errstate(divide='ignore', invalid='ignore'):\n                phi_map[calc_phi_mask] = n_like_map[calc_phi_mask] / n_occ_map[calc_phi_mask]\n\n        unsatisfied_mask = occupied_mask & (phi_map < tau)\n        unsatisfied_coords = np.argwhere(unsatisfied_mask)\n\n        # Check for termination (absorbing state)\n        if len(unsatisfied_coords) == 0:\n            break\n\n        # 3. Perform a move\n        T += 1\n        empty_coords = np.argwhere(grid == 0)\n\n        # Choose one unsatisfied agent and one empty site uniformly at random\n        u_idx = rng.choice(len(unsatisfied_coords))\n        e_idx = rng.choice(len(empty_coords))\n\n        u_coords = tuple(unsatisfied_coords[u_idx])\n        e_coords = tuple(empty_coords[e_idx])\n\n        # Swap the agent and the empty site\n        grid[e_coords], grid[u_coords] = grid[u_coords], grid[e_coords]\n\n    # 4. Final calculation of mean satisfaction\n    occupied_mask = grid != 0\n    num_occupied = np.sum(occupied_mask)\n\n    if num_occupied == 0:\n        mean_phi = 0.0 # Should not happen based on problem constraints\n    else:\n        # Recalculate phi_map for the final configuration\n        n_occ_map = convolve2d(occupied_mask, kernel, mode=\"same\", boundary=\"wrap\")\n        phi_map = np.ones_like(grid, dtype=float)\n        calc_phi_mask = occupied_mask & (n_occ_map > 0)\n\n        if np.any(calc_phi_mask):\n            plus_mask = grid == 1\n            minus_mask = grid == -1\n            n_plus_neighbors = convolve2d(plus_mask, kernel, mode=\"same\", boundary=\"wrap\")\n            n_minus_neighbors = convolve2d(minus_mask, kernel, mode=\"same\", boundary=\"wrap\")\n            \n            n_like_map = np.zeros_like(grid, dtype=int)\n            n_like_map[plus_mask] = n_plus_neighbors[plus_mask]\n            n_like_map[minus_mask] = n_minus_neighbors[minus_mask]\n\n            with np.errstate(divide='ignore', invalid='ignore'):\n                phi_map[calc_phi_mask] = n_like_map[calc_phi_mask] / n_occ_map[calc_phi_mask]\n\n        total_phi = np.sum(phi_map[occupied_mask])\n        mean_phi = total_phi / num_occupied\n\n    return T, mean_phi\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, f_empty, f_plus, tau, r, S_max, seed)\n        (20, 0.1, 0.5, 0.5, 1, 20000, 1),\n        (15, 0.2, 0.5, 0.0, 1, 20000, 2),\n        (20, 0.2, 0.5, 0.9, 1, 20000, 3),\n        (5, 0.2, 0.5, 0.6, 1, 20000, 4),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, f_empty, f_plus, tau, r, S_max, seed = case\n        T, phi_bar = run_simulation(N, f_empty, f_plus, tau, r, S_max, seed)\n        results.append(f\"[{T}, {phi_bar:.3f}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"}, {"introduction": "Building on the foundational model, this practice explores a more 'rational' agent behavior and a dynamic environment. Instead of moving randomly, unsatisfied agents will now actively search for the first available location that meets their satisfaction threshold [@problem_id:2428508]. Furthermore, the model unfolds in stages, with the city's population growing over time. This exercise demonstrates how different assumptions about agent decision-making and environmental dynamics, such as deterministic best-response strategies, can significantly influence the speed and structure of emergent segregation.", "id": "2428508", "problem": "Consider a two-type Schelling segregation model on a finite square lattice. Let the grid be an $N \\times N$ array of cells. Each cell is either vacant (state $0$) or occupied by one of two agent types (state $1$ for type $A$, state $2$ for type $B$). Each agent has the same preference threshold $\\tau \\in [0,1]$ and evaluates satisfaction with respect to her Moore neighborhood of radius $1$ (the $8$ surrounding cells, fewer on edges and corners). An occupied cell at site $(i,j)$ is satisfied if the fraction of its occupied neighbors who are of the same type is at least $\\tau$. If the cell has zero occupied neighbors, it is considered satisfied by convention.\n\nThe vacancy rate varies over discrete stages, so that the grid fills up over time: given a schedule $\\{\\rho_0,\\rho_1,\\dots,\\rho_K\\}$ with $\\rho_{k+1} \\le \\rho_k$ for all $k$, the target number of vacant cells at stage $k$ is defined as $V_k = \\left\\lfloor \\rho_k N^2 + \\tfrac{1}{2} \\right\\rfloor$. The initial grid is empty (all cells vacant), and before any mobility at stage $k$ the number of new agents to add is $\\Delta_k = V_{k-1} - V_k$ (with $V_{-1} := N^2$ for the empty grid). New agents arrive in a fixed population mix: a fraction $p_A \\in [0,1]$ of arrivals are type $A$ and a fraction $1 - p_A$ are type $B$. For each stage $k$, new agents are added deterministically in row-major order to the first $\\Delta_k$ currently vacant cells, placing first $\\lfloor p_A \\Delta_k \\rfloor$ type $A$ agents followed by $\\Delta_k - \\lfloor p_A \\Delta_k \\rfloor$ type $B$ agents, regardless of their initial satisfaction upon entry.\n\nAfter arrivals at stage $k$, agents may move to improve satisfaction according to the following sequential best-response dynamic repeated in sweeps. In one sweep, visit all cells in row-major order. For each occupied cell that is currently unsatisfied, search the list of currently vacant cells in row-major order and move the agent to the first vacant cell at which it would be satisfied upon arrival (evaluated as if the agent vacated its current cell and occupied the candidate cell). If no such vacancy exists, the agent does not move in that sweep. Each successful move updates the set of vacancies accordingly. Continue performing sweeps until either (i) a sweep completes with no moves, or (ii) the number of sweeps at the current stage reaches a given maximum $M$.\n\nAt the end of the final stage $K$, after arrivals and mobility sweeps are complete, compute the segregation index defined as the average local homophily:\n$$\nS = \\frac{1}{|\\mathcal{O}|} \\sum_{(i,j)\\in\\mathcal{O}} h_{ij},\n\\quad h_{ij} =\n\\begin{cases}\n\\frac{\\text{same-type occupied neighbors at }(i,j)}{\\text{total occupied neighbors at }(i,j)}, & \\text{if total occupied neighbors} > 0,\\\\\n1, & \\text{if total occupied neighbors} = 0,\n\\end{cases}\n$$\nwhere $\\mathcal{O}$ is the set of occupied cells. The value $S$ must be reported as a real number rounded to four decimal places.\n\nImplement the above dynamics exactly as specified, with all tie-breaking by row-major order and all counts computed on the Moore neighborhood. There must be no randomness at any step.\n\nYour program must solve the following test suite. For each test case, the program should run the model and output the final segregation index $S$ rounded to four decimals.\n\nTest cases:\n1) $N = 10$, $\\{\\rho_k\\}_{k=0}^2 = \\{0.6, 0.4, 0.2\\}$, $\\tau = 0.3$, $p_A = 0.5$, $M = 200$.\n2) $N = 10$, $\\{\\rho_k\\}_{k=0}^2 = \\{0.6, 0.4, 0.2\\}$, $\\tau = 0.6$, $p_A = 0.5$, $M = 200$.\n3) $N = 8$, $\\{\\rho_k\\}_{k=0}^2 = \\{0.7, 0.5, 0.3\\}$, $\\tau = 0.0$, $p_A = 0.7$, $M = 200$.\n4) $N = 12$, $\\{\\rho_k\\}_{k=0}^2 = \\{0.8, 0.5, 0.2\\}$, $\\tau = 1.0$, $p_A = 0.5$, $M = 300$.\n\nFinal output format: Your program should produce a single line of output containing the results for the test suite as a comma-separated list enclosed in square brackets, in the same order as listed above, for example, $[x_1,x_2,x_3,x_4]$, where each $x_i$ is the corresponding $S$ rounded to four decimals. There must be no extra text before or after the list. No physical units or angle units are involved. All fractions must be reported as decimals rounded as specified.", "solution": "The problem requires the implementation of a deterministic, multi-stage Schelling segregation model on a square lattice. The validity of the problem statement is confirmed, as it is scientifically grounded in established agent-based modeling principles, is well-posed with all necessary parameters and rules defined without ambiguity, and is algorithmically specified to ensure a unique, verifiable solution.\n\nThe solution is constructed by directly translating the specified dynamics into a computational algorithm. The system's state is represented by an $N \\times N$ matrix, where each cell can be vacant (state $0$), or occupied by an agent of type $A$ (state $1$) or type $B$ (state $2$). The simulation proceeds through a series of discrete stages, $k=0, 1, \\dots, K$.\n\nEach stage $k$ consists of two phases: agent addition and agent mobility.\n\n1.  **Agent Addition**: The grid population grows at each stage. The target number of vacant cells, $V_k$, is determined by the vacancy rate schedule $\\{\\rho_k\\}$ according to $V_k = \\left\\lfloor \\rho_k N^2 + \\tfrac{1}{2} \\right\\rfloor$. The number of new agents to be added at stage $k$ is $\\Delta_k = V_{k-1} - V_k$, where $V_{-1} = N^2$ for the initially empty grid. These $\\Delta_k$ agents consist of $\\lfloor p_A \\Delta_k \\rfloor$ agents of type $A$ and the remainder of type $B$. They are placed deterministically into the first $\\Delta_k$ vacant cells found in row-major order, with all type $A$ agents placed before type $B$ agents.\n\n2.  **Agent Mobility**: Following agent addition, a dynamic process of relocation occurs, driven by agent preferences for homophily. This process is modeled as a sequence of sweeps. In a single sweep, all grid cells are visited in row-major order.\n    - An agent at a site $(i,j)$ evaluates its satisfaction based on the composition of its Moore neighborhood (the $8$ surrounding cells).\n    - The local homophily for the agent, $h_{ij}$, is the fraction of its occupied neighbors that are of its own type. If an agent has no occupied neighbors, it is satisfied by convention.\n    - The agent is deemed satisfied if its local homophily $h_{ij}$ meets or exceeds a global preference threshold $\\tau$, i.e., $h_{ij} \\ge \\tau$.\n    - If an agent is unsatisfied, it searches for a vacant cell to move to. The search for a target vacant cell proceeds through the list of all currently vacant cells, ordered in row-major fashion. The agent moves to the *first* vacant cell from which it would be satisfied. This hypothetical satisfaction is evaluated based on the neighborhood composition at the target cell.\n    - Each move is executed immediately, updating the grid state. The sweep then continues its scan from the next cell in the row-major sequence.\n    - The mobility phase for a given stage terminates when either a full sweep results in no agent movements, indicating a stable configuration, or a maximum number of sweeps, $M$, is reached.\n\nAfter the final stage $K$ is completed, a global segregation index, $S$, is calculated. This index is the average local homophily over all occupied cells in the final grid configuration:\n$$S = \\frac{1}{|\\mathcal{O}|} \\sum_{(i,j)\\in\\mathcal{O}} h_{ij}$$\nwhere $\\mathcal{O}$ is the set of all occupied cells. For this calculation, the homophily $h_{ij}$ for an agent with zero occupied neighbors is defined to be $1$. The final value of $S$ is reported rounded to four decimal places. The entire process is deterministic due to the strict ordering rules for all actions, including tie-breaking.", "answer": "```python\nimport numpy as np\n\ndef custom_round(x):\n    \"\"\"\n    Rounds a number to the nearest integer according to the problem specification,\n    which is equivalent to floor(x + 0.5) for non-negative x.\n    \"\"\"\n    return int(x + 0.5)\n\ndef get_neighbor_stats(grid, agent_type, r, c):\n    \"\"\"\n    Calculates neighbor statistics for an agent of a given type at position (r, c).\n    \n    Args:\n        grid (np.array): The current state of the grid.\n        agent_type (int): The type of the agent (1 or 2).\n        r (int): The row coordinate.\n        c (int): The column coordinate.\n        \n    Returns:\n        tuple[int, int]: A tuple containing (same_type_neighbors, total_occupied_neighbors).\n    \"\"\"\n    N = grid.shape[0]\n    same_type_neighbors = 0\n    total_occupied_neighbors = 0\n    \n    # Iterate over the Moore neighborhood of radius 1\n    for dr in [-1, 0, 1]:\n        for dc in [-1, 0, 1]:\n            if dr == 0 and dc == 0:\n                continue\n            \n            nr, nc = r + dr, c + dc\n            \n            if 0 <= nr < N and 0 <= nc < N:\n                neighbor_state = grid[nr, nc]\n                if neighbor_state != 0:  # If the neighbor cell is occupied\n                    total_occupied_neighbors += 1\n                    if neighbor_state == agent_type:\n                        same_type_neighbors += 1\n                        \n    return same_type_neighbors, total_occupied_neighbors\n\ndef run_simulation(N, rhos, tau, p_A, M):\n    \"\"\"\n    Executes the full Schelling model simulation for one test case.\n    \"\"\"\n    grid = np.zeros((N, N), dtype=int)\n    V_prev = N * N\n\n    for rho_k in rhos:\n        # ===== 1. AGENT ADDITION PHASE =====\n        V_k = custom_round(rho_k * N * N)\n        delta_k = V_prev - V_k\n        V_prev = V_k\n\n        if delta_k > 0:\n            num_A = int(p_A * delta_k)\n            num_B = delta_k - num_A\n\n            # Find vacant cells in row-major order\n            vacant_cells = np.argwhere(grid == 0)\n            \n            # Place type A agents\n            for i in range(num_A):\n                r, c = vacant_cells[i]\n                grid[r, c] = 1\n            \n            # Place type B agents\n            for i in range(num_A, delta_k):\n                r, c = vacant_cells[i]\n                grid[r, c] = 2\n\n        # ===== 2. MOBILITY PHASE =====\n        for _ in range(M):\n            moved_in_sweep = False\n            \n            # Visit all cells in row-major order\n            for r_orig in range(N):\n                for c_orig in range(N):\n                    agent_type = grid[r_orig, c_orig]\n                    if agent_type == 0:\n                        continue\n\n                    # Check if the agent at (r_orig, c_orig) is satisfied\n                    same, total = get_neighbor_stats(grid, agent_type, r_orig, c_orig)\n                    \n                    # An agent is satisfied if it has no neighbors or if homophily >= tau.\n                    # same >= tau * total is used to avoid float division.\n                    is_satisfied = (total == 0) or (same >= tau * total)\n\n                    if not is_satisfied:\n                        # Agent is unsatisfied, so search for a new location.\n                        # Get a current list of vacant cells, sorted row-major.\n                        vacant_cells = np.argwhere(grid == 0)\n                        \n                        for r_new, c_new in vacant_cells:\n                            # Check if moving to (r_new, c_new) would be satisfactory.\n                            same_h, total_h = get_neighbor_stats(grid, agent_type, r_new, c_new)\n                            \n                            would_be_satisfied = (total_h == 0) or (same_h >= tau * total_h)\n                                \n                            if would_be_satisfied:\n                                # First suitable vacancy found, so move the agent.\n                                grid[r_new, c_new] = agent_type\n                                grid[r_orig, c_orig] = 0\n                                moved_in_sweep = True\n                                break  # Agent moved, stop searching for vacancies.\n\n            if not moved_in_sweep:\n                break  # Equilibrium for this stage is reached.\n\n    # ===== 3. FINAL SEGREGATION INDEX CALCULATION =====\n    occupied_cells = np.argwhere(grid > 0)\n    num_occupied = len(occupied_cells)\n\n    if num_occupied == 0:\n        return 0.0\n\n    total_homophily = 0.0\n    for r, c in occupied_cells:\n        agent_type = grid[r, c]\n        same, total = get_neighbor_stats(grid, agent_type, r, c)\n        \n        # Local homophily is 1 if agent has no neighbors.\n        homophily = 1.0 if total == 0 else same / total\n        total_homophily += homophily\n        \n    S = total_homophily / num_occupied\n    \n    return S\n\ndef solve():\n    \"\"\"\n    Defines and runs the test suite, then prints the results in the required format.\n    \"\"\"\n    test_cases = [\n        # (N, {rho_k}, tau, p_A, M)\n        (10, [0.6, 0.4, 0.2], 0.3, 0.5, 200),\n        (10, [0.6, 0.4, 0.2], 0.6, 0.5, 200),\n        (8, [0.7, 0.5, 0.3], 0.0, 0.7, 200),\n        (12, [0.8, 0.5, 0.2], 1.0, 0.5, 300),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, rhos, tau, p_A, M = case\n        result = run_simulation(N, rhos, tau, p_A, M)\n        # Format the result to four decimal places as required.\n        results.append(f\"{result:.4f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"}, {"introduction": "Our final practice introduces a layer of complexity that brings the model closer to real-world social landscapes: agent heterogeneity. You will introduce immobile 'influencer' agents who act as fixed anchors in the community, shaping the settlement patterns of mobile agents around them [@problem_id:2428488]. This exercise is crucial for understanding how fixed features, like institutions, landmarks, or established communities, can create path dependency and powerful local effects. You will also learn to quantify this phenomenon by calculating a custom metric, the 'anchoring lift', to measure the influence of these fixed agents on their local environment.", "id": "2428488", "problem": "Consider a two-type Schelling segregation model on a finite two-dimensional discrete lattice with immobile \"influencer\" agents. The lattice is an $n \\times n$ grid with toroidal boundary conditions (wrap-around on both axes). Each site holds either an empty cell (coded $0$), a type $1$ agent (coded $1$), or a type $2$ agent (coded $2$). A subset of agents are influencers: they have a fixed type and fixed positions and never move; non-influencer agents may move. Neighborhoods are of Moore type with radius $1$ under toroidal geometry: each cell has $8$ neighbors (all cells whose Chebyshev distance is exactly $1$ on the torus). For any occupied cell at coordinates $(i,j)$ with agent type $s \\in \\{1,2\\}$, define its local same-type fraction as\n$$\nf_s(i,j) \\equiv \n\\begin{cases}\n\\frac{\\text{number of occupied neighbors of type } s}{\\text{number of occupied neighbors}}, & \\text{if the number of occupied neighbors} \\gt 0,\\\\\n1, & \\text{if the number of occupied neighbors} = 0.\n\\end{cases}\n$$\nAn agent is satisfied if $f_s(i,j) \\ge \\tau$, where $\\tau \\in [0,1]$ is the common tolerance.\n\nInitialization: For given integers $N_1 \\ge 0$ and $N_2 \\ge 0$ with $N_1 + N_2 \\le n^2$, place all influencers first at their specified coordinates with their specified types (they count toward the totals $N_1$ or $N_2$). Then, fill the remaining $N_1 + N_2 - (\\text{number of influencers})$ non-influencer agents in row-major order (increasing row index $i$, breaking ties by increasing column index $j$), skipping already occupied influencer cells. The non-influencer agents are placed by alternating types $1,2,1,2,\\dots$ starting with type $1$, subject to the remaining counts of each type: when the remaining count of the current type is zero, switch to the other type; continue until all required agents are placed. All remaining cells are empty.\n\nDynamics: Only non-influencer agents may move. The dynamics proceed in discrete sweeps indexed by $t = 1,2,\\dots$, each sweep iterating over all grid coordinates in row-major order. During a sweep, whenever a non-influencer agent of type $s$ at $(i,j)$ is encountered, compute its current $f_s(i,j)$. If $f_s(i,j) \\ge \\tau$, it does not move. If $f_s(i,j) \\lt \\tau$, consider all currently empty cells as potential destinations; for each empty cell, evaluate the same-type fraction the agent of type $s$ would have if placed at that destination, under the state where the agent’s current cell $(i,j)$ is vacated prior to evaluation. The agent selects the destination that maximizes this fraction; if there are multiple maximizers, choose the lexicographically smallest coordinates (smallest row, then smallest column). The agent moves if and only if the maximal destination fraction is strictly greater than its current $f_s(i,j)$. Influencers never move. A sweep ends after all coordinates are processed; the process stops when a full sweep occurs with no movements, or when a specified maximum number of sweeps $T_{\\max}$ is reached.\n\nSegregation metrics after termination: Let $H$ denote the global mean homophily,\n$$\nH \\equiv \\frac{1}{M}\\sum_{(i,j)\\ \\text{occupied}} f_{s(i,j)}(i,j),\n$$\nwhere $M$ is the number of occupied cells and $s(i,j)\\in\\{1,2\\}$ is the type at $(i,j)$. For each influencer $k$ of type $s_k$ at position $(i_k,j_k)$, and a given neighborhood radius $r \\in \\mathbb{N}$, define the influencer’s local same-type share $L_k$ as the fraction of occupied cells within Chebyshev distance at most $r$ on the torus from $(i_k,j_k)$ that are of type $s_k$ (include the influencer’s own cell in both numerator and denominator). Let $G_{s}$ be the global share of type $s$ among all occupied cells, i.e.,\n$$\nG_s \\equiv \\frac{\\text{number of occupied cells of type } s}{M}.\n$$\nDefine the anchoring lift of influencer $k$ as $L_k - G_{s_k}$. For each test case below, define the test-case result as the arithmetic mean of the anchoring lifts across its influencers. If a test case has zero influencers, define its result to be $H$.\n\nImplement the model exactly as defined above and compute, for each test case, the test-case result. Use Chebyshev distance and toroidal wrap-around consistently for all neighborhood and radius calculations. All coordinates are zero-indexed with rows and columns in $\\{0,1,\\dots,n-1\\}$.\n\nTest suite:\n- Case A (general case): $n=10$, tolerance $\\tau=0.5$, maximum sweeps $T_{\\max}=200$, radius $r=2$, totals $(N_1,N_2)=(45,45)$, influencers: two type $1$ influencers at $(0,0)$ and $(9,9)$.\n- Case B (central anchors of the other type): $n=10$, tolerance $\\tau=0.5$, maximum sweeps $T_{\\max}=200$, radius $r=2$, totals $(N_1,N_2)=(45,45)$, influencers: two type $2$ influencers at $(5,5)$ and $(5,6)$.\n- Case C (higher tolerance boundary): $n=10$, tolerance $\\tau=0.75$, maximum sweeps $T_{\\max}=200$, radius $r=2$, totals $(N_1,N_2)=(50,40)$, influencers: one type $1$ influencer at $(0,0)$ and one type $2$ influencer at $(0,9)$.\n- Case D (no vacancies edge case): $n=10$, tolerance $\\tau=0.5$, maximum sweeps $T_{\\max}=200$, radius $r=2$, totals $(N_1,N_2)=(50,50)$, influencers: one type $1$ influencer at $(5,5)$.\n\nFinal output format: Your program should produce a single line of output containing the results for Cases A through D in that order as a comma-separated list of four real numbers enclosed in square brackets, with each number rounded to exactly four digits after the decimal point (e.g., [$x_A$,$x_B$,$x_C$,$x_D$]).", "solution": "The problem is subjected to validation.\n\n### Step 1: Extract Givens\n- **Lattice:** $n \\times n$ grid with toroidal boundary conditions.\n- **Cell States:** Empty ($0$), Type $1$ ($1$), Type $2$ ($2$).\n- **Agent Types:** Mobile non-influencers and immobile influencers with fixed positions and types.\n- **Neighborhood:** Moore, radius $1$, toroidal geometry ($8$ neighbors).\n- **Local Same-Type Fraction ($f_s(i,j)$):** For an agent of type $s$ at $(i,j)$, the fraction of its occupied neighbors that are of type $s$. If there are no occupied neighbors, $f_s(i,j) = 1$.\n- **Satisfaction:** Agent is satisfied if $f_s(i,j) \\ge \\tau$.\n- **Initialization:** Place influencers first. Then, fill remaining agents ($N_1$, $N_2$ total) in row-major order, alternating types ($1,2,1,2,\\dots$) but using the other type if the preferred one is exhausted.\n- **Dynamics:** Sweeps iterate over the grid in row-major order. Unsatisfied non-influencers evaluate all empty cells as potential destinations. A move to the destination that maximizes the hypothetical same-type fraction occurs only if this maximum is strictly greater than the current fraction. Tie-breaking for destinations is lexicographical. Grid updates are sequential within a sweep.\n- **Termination:** Stop after a sweep with zero moves or after $T_{\\max}$ sweeps.\n- **Metrics:**\n  - $H$: Global mean homophily.\n  - $L_k$: For influencer $k$ of type $s_k$, the fraction of same-type agents within a Chebyshev distance $r$ on the torus.\n  - $G_s$: Global fraction of agents of type $s$.\n  - Anchoring Lift: $L_k - G_{s_k}$.\n- **Test-Case Result:** The arithmetic mean of anchoring lifts for all influencers. If no influencers, the result is $H$.\n- **Test Cases:**\n  - A: $n=10, \\tau=0.5, T_{\\max}=200, r=2, (N_1,N_2)=(45,45)$, influencers: two type $1$ at $(0,0), (9,9)$.\n  - B: $n=10, \\tau=0.5, T_{\\max}=200, r=2, (N_1,N_2)=(45,45)$, influencers: two type $2$ at $(5,5), (5,6)$.\n  - C: $n=10, \\tau=0.75, T_{\\max}=200, r=2, (N_1,N_2)=(50,40)$, influencers: one type $1$ at $(0,0)$, one type $2$ at $(0,9)$.\n  - D: $n=10, \\tau=0.5, T_{\\max}=200, r=2, (N_1,N_2)=(50,50)$, influencer: one type $1$ at $(5,5)$.\n\n### Step 2: Validate Using Extracted Givens\n1.  **Scientifically Grounded:** The problem describes a variant of Schelling's segregation model, a canonical model in computational social science. The rules are extensions of the standard model and are scientifically coherent.\n2.  **Well-Posed:** The problem is deterministic. The initialization rules, agent dynamics, and tie-breaking procedures are specified unambiguously, guaranteeing a unique evolution of the system from a given initial state. Termination is guaranteed.\n3.  **Objective:** The problem is stated in precise, mathematical, and algorithmic terms, free of any subjectivity.\n4.  **Completeness:** All necessary parameters ($n$, $\\tau$, $N_1$, $N_2$, $T_{\\max}$, $r$, influencer details) are provided. The rules for all special cases (e.g., zero occupied neighbors, no empty cells) are logically consistent with the overall framework.\n5.  **Structure:** The problem is well-structured and poses a clear computational task.\n\n### Step 3: Verdict and Action\nThe problem is valid. The premises are sound, and the specifications are complete and unambiguous. We proceed with the construction of a solution.\n\nThe solution is a direct simulation of the described agent-based model. The implementation is structured into three principal components: grid initialization, simulation of agent dynamics, and calculation of the final segregation metrics.\n\n**1. Grid Initialization**\n\nThe $n \\times n$ lattice is represented by a two-dimensional integer array. A parallel boolean array is used to flag influencer locations.\n- The process begins by creating an $n \\times n$ grid initialized to state $0$ (empty).\n- Influencers are placed at their specified coordinates $(i,j)$ with their given types $s \\in \\{1,2\\}$. The corresponding entries in the influencer flag array are set to true. The total counts of agents to be placed, $N_1$ and $N_2$, are decremented accordingly.\n- The remaining non-influencer agents are placed in the vacant cells by iterating through the grid in row-major order (from $(0,0)$ to $(n-1, n-1)$). Agent types are assigned by following an alternating sequence $1, 2, 1, 2, \\dots$. If the count for the designated type in the sequence is exhausted, the other type is placed instead. The sequence then continues its alternation for the next available cell. This process continues until all $N_1$ and $N_2$ agents are on the grid.\n\n**2. Simulation of Dynamics**\n\nThe simulation proceeds in discrete sweeps, up to a maximum of $T_{\\max}$.\n- Each sweep consists of a single pass over all grid cells $(i,j)$ in row-major order.\n- At each cell, if it contains a non-influencer agent of type $s$, its local same-type fraction $f_s(i,j)$ is calculated.\n- If the agent is unsatisfied, i.e., $f_s(i,j) < \\tau$, a search for a new location is initiated.\n  - The set of potential destinations comprises all currently empty cells on the grid.\n  - For each potential destination, a hypothetical same-type fraction is calculated. This is the fraction the agent would experience if it moved there. The calculation is performed on a hypothetical grid copy where the agent's original cell $(i,j)$ has been vacated.\n  - The agent identifies the destination that yields the maximum hypothetical fraction. Ties are broken by selecting the destination with the lexicographically smallest coordinates.\n  - A move is executed only if this maximal destination fraction is strictly greater than the agent's current fraction $f_s(i,j)$.\n- If a move occurs, the grid is updated immediately: the agent's type is placed in the new cell, and its original cell becomes empty. This updated grid state is used for all subsequent agent evaluations within the same sweep.\n- The simulation terminates if a full sweep completes with no agent movements, or if $T_{\\max}$ sweeps are completed.\n\n**3. Metric Calculation**\n\nAfter the simulation terminates, the final test-case result is computed from the final grid configuration.\n- For each test case, which contains influencers, the result is the arithmetic mean of the anchoring lifts of all influencers.\n- The anchoring lift for an influencer $k$ of type $s_k$ is $L_k - G_{s_k}$.\n- $G_{s_k}$ is the global share of agents of type $s_k$, given by $G_{s_k} = \\frac{N_{s_k}}{N_1 + N_2}$.\n- $L_k$ is the influencer's local same-type share. To compute it, we consider a square neighborhood of radius $r$ around the influencer at $(i_k,j_k)$ using the toroidal Chebyshev distance. $L_k$ is the ratio of the number of occupied cells of type $s_k$ within this neighborhood to the total number of occupied cells within the same neighborhood. The influencer's own cell is included in both counts.\n\nThis detailed algorithmic procedure ensures a faithful implementation of the model as specified.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Schelling segregation model for the provided test suite.\n    \"\"\"\n    test_cases = [\n        # Case A\n        {'n': 10, 'tau': 0.5, 'T_max': 200, 'r': 2, 'N1': 45, 'N2': 45, \n         'influencers': [((0, 0), 1), ((9, 9), 1)]},\n        # Case B\n        {'n': 10, 'tau': 0.5, 'T_max': 200, 'r': 2, 'N1': 45, 'N2': 45, \n         'influencers': [((5, 5), 2), ((5, 6), 2)]},\n        # Case C\n        {'n': 10, 'tau': 0.75, 'T_max': 200, 'r': 2, 'N1': 50, 'N2': 40, \n         'influencers': [((0, 0), 1), ((0, 9), 2)]},\n        # Case D\n        {'n': 10, 'tau': 0.5, 'T_max': 200, 'r': 2, 'N1': 50, 'N2': 50, \n         'influencers': [((5, 5), 1)]},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = process_case(case)\n        results.append(result)\n\n    print(f\"[{','.join([f'{x:.4f}' for x in results])}]\")\n\ndef process_case(params):\n    \"\"\"\n    Processes a single test case from initialization to final metric calculation.\n    \"\"\"\n    n, N1, N2, tau, T_max, r = params['n'], params['N1'], params['N2'], params['tau'], params['T_max'], params['r']\n    influencers = params['influencers']\n\n    grid, is_influencer, influencer_info = initialize_grid(n, N1, N2, influencers)\n    final_grid = run_simulation(grid, is_influencer, n, tau, T_max)\n    metric = calculate_metrics(final_grid, N1, N2, influencer_info, n, r)\n    \n    return metric\n\ndef get_moore_neighbors(r, c, n):\n    \"\"\"Gets Moore neighborhood coordinates with toroidal boundary.\"\"\"\n    neighbors = []\n    for dr in [-1, 0, 1]:\n        for dc in [-1, 0, 1]:\n            if dr == 0 and dc == 0:\n                continue\n            nr, nc = (r + dr) % n, (c + dc) % n\n            neighbors.append((nr, nc))\n    return neighbors\n\ndef calculate_homophily(grid, r, c, agent_type, n):\n    \"\"\"\n    Calculates the local same-type fraction for an agent of `agent_type` at (r,c).\n    \"\"\"\n    neighbors = get_moore_neighbors(r, c, n)\n    same_type_neighbors = 0\n    occupied_neighbors = 0\n    \n    for nr, nc in neighbors:\n        neighbor_type = grid[nr, nc]\n        if neighbor_type > 0:\n            occupied_neighbors += 1\n            if neighbor_type == agent_type:\n                same_type_neighbors += 1\n    \n    if occupied_neighbors == 0:\n        return 1.0\n    return same_type_neighbors / occupied_neighbors\n\ndef initialize_grid(n, N1, N2, influencers):\n    \"\"\"Initializes the grid according to the problem statement.\"\"\"\n    grid = np.zeros((n, n), dtype=int)\n    is_influencer = np.zeros((n, n), dtype=bool)\n    \n    rem_N1, rem_N2 = N1, N2\n    influencer_info = []\n\n    for pos, type in influencers:\n        grid[pos] = type\n        is_influencer[pos] = True\n        influencer_info.append((pos, type))\n        if type == 1:\n            rem_N1 -= 1\n        else:\n            rem_N2 -= 1\n            \n    next_type_in_sequence = 1\n    for r in range(n):\n        for c in range(n):\n            if rem_N1 == 0 and rem_N2 == 0:\n                break\n            if grid[r, c] == 0:\n                type_to_place = 0\n                if next_type_in_sequence == 1:\n                    if rem_N1 > 0:\n                        type_to_place = 1\n                    elif rem_N2 > 0:\n                        type_to_place = 2\n                else: \n                    if rem_N2 > 0:\n                        type_to_place = 2\n                    elif rem_N1 > 0:\n                        type_to_place = 1\n                \n                if type_to_place == 1:\n                    grid[r, c] = 1\n                    rem_N1 -= 1\n                elif type_to_place == 2:\n                    grid[r, c] = 2\n                    rem_N2 -= 1\n                \n                next_type_in_sequence = 3 - next_type_in_sequence\n        if rem_N1 == 0 and rem_N2 == 0:\n            break\n            \n    return grid, is_influencer, influencer_info\n\ndef run_simulation(grid, is_influencer, n, tau, T_max):\n    \"\"\"Runs the Schelling model simulation with sequential updates.\"\"\"\n    current_grid = grid.copy()\n    for _ in range(T_max):\n        moved_in_sweep = False\n        for r in range(n):\n            for c in range(n):\n                agent_type = current_grid[r, c]\n                if agent_type > 0 and not is_influencer[r, c]:\n                    current_f = calculate_homophily(current_grid, r, c, agent_type, n)\n                    \n                    if current_f < tau:\n                        empty_cells = list(zip(*np.where(current_grid == 0)))\n                        if not empty_cells:\n                            continue\n\n                        max_f = -1.0\n                        best_dest = None\n                        \n                        hypothetical_grid = current_grid.copy()\n                        hypothetical_grid[r, c] = 0\n\n                        for dest_r, dest_c in empty_cells:\n                            f_dest = calculate_homophily(hypothetical_grid, dest_r, dest_c, agent_type, n)\n                            if f_dest > max_f:\n                                max_f = f_dest\n                                best_dest = (dest_r, dest_c)\n                            elif f_dest == max_f:\n                                if (dest_r, dest_c) < best_dest:\n                                    best_dest = (dest_r, dest_c)\n                        \n                        if best_dest is not None and max_f > current_f:\n                            current_grid[best_dest] = agent_type\n                            current_grid[r, c] = 0\n                            moved_in_sweep = True\n                            \n        if not moved_in_sweep:\n            break\n            \n    return current_grid\n\ndef torus_chebyshev_dist(p1, p2, n):\n    \"\"\"Calculates Chebyshev distance on an n x n torus.\"\"\"\n    dr = abs(p1[0] - p2[0])\n    dc = abs(p1[1] - p2[1])\n    torus_dr = min(dr, n - dr)\n    torus_dc = min(dc, n - dc)\n    return max(torus_dr, torus_dc)\n\ndef calculate_metrics(final_grid, N1, N2, influencer_info, n, r):\n    \"\"\"Calculates the final test-case result (mean anchoring lift).\"\"\"\n    M = N1 + N2\n    if M == 0: return 0.0\n\n    if not influencer_info: # This case is not in the test suite but handled for completeness\n        total_homophily = 0.0\n        occupied_coords = np.argwhere(final_grid > 0)\n        for r_occ, c_occ in occupied_coords:\n            agent_type = final_grid[r_occ, c_occ]\n            total_homophily += calculate_homophily(final_grid, r_occ, c_occ, agent_type, n)\n        return total_homophily / M\n    \n    lifts = []\n    G1 = N1 / M\n    G2 = N2 / M\n    G_map = {1: G1, 2: G2}\n\n    for inf_pos, inf_type in influencer_info:\n        local_same_count = 0\n        local_total_count = 0\n        for r_cell in range(n):\n            for c_cell in range(n):\n                if torus_chebyshev_dist(inf_pos, (r_cell, c_cell), n) <= r:\n                    cell_type = final_grid[r_cell, c_cell]\n                    if cell_type > 0:\n                        local_total_count += 1\n                        if cell_type == inf_type:\n                            local_same_count += 1\n        \n        Lk = local_same_count / local_total_count if local_total_count > 0 else 0.0\n        Gs_k = G_map[inf_type]\n        lift = Lk - Gs_k\n        lifts.append(lift)\n        \n    return np.mean(lifts)\n\nsolve()\n\n```"}]}