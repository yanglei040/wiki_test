{"hands_on_practices": [{"introduction": "Before building a solver, it is essential to understand what a \"good\" solution looks like. This first exercise focuses on the critical skill of validating an approximate policy function. By taking a given solution and calculating its Euler equation residual across the state space, you will gain a concrete understanding of this fundamental error metric, which is precisely what projection methods aim to minimize [@problem_id:2422834]. This practice provides a tangible feel for the accuracy of an approximation before you tackle the challenge of computing one yourself.", "id": "2422834", "problem": "Consider the deterministic neoclassical growth model with constant relative risk aversion (CRRA) preferences and Cobbâ€“Douglas production. Let the representative agent have preferences over consumption given by the period utility function $u(c)$, with\n$$\nu(c) =\n\\begin{cases}\n\\dfrac{c^{1-\\sigma}}{1-\\sigma}, & \\text{if } \\sigma \\neq 1, \\\\\n\\ln(c), & \\text{if } \\sigma = 1,\n\\end{cases}\n$$\nwhere $\\sigma > 0$ is the coefficient of relative risk aversion. Capital $k$ evolves according to\n$$\nk' = A k^{\\alpha} + (1-\\delta) k - c,\n$$\nwhere $A > 0$ is total factor productivity, $\\alpha \\in (0,1)$ is the capital share in production, and $\\delta \\in (0,1)$ is the depreciation rate. The Euler equation characterizing an optimal policy in this deterministic setting is\n$$\nu'(c(k)) = \\beta \\, u'(c(k')) \\left( A \\alpha (k')^{\\alpha - 1} + 1 - \\delta \\right),\n$$\nwith the marginal utility given by\n$$\nu'(c) =\n\\begin{cases}\nc^{-\\sigma}, & \\text{if } \\sigma \\neq 1, \\\\\n\\dfrac{1}{c}, & \\text{if } \\sigma = 1.\n\\end{cases}\n$$\n\nSuppose you are given an approximate consumption policy function $\\hat{c}(k)$ that was previously obtained by a projection method on Chebyshev polynomials up to degree $3$ over a capital domain $[k_{\\min}, k_{\\max}]$. Define the affine transformation from capital $k \\in [k_{\\min}, k_{\\max}]$ to the Chebyshev domain $x \\in [-1,1]$ by\n$$\nx(k) = \\frac{2 k - (k_{\\min} + k_{\\max})}{k_{\\max} - k_{\\min}}.\n$$\nLet the first four Chebyshev polynomials of the first kind be\n$$\nT_0(x) = 1,\\quad T_1(x) = x,\\quad T_2(x) = 2x^2 - 1,\\quad T_3(x) = 4x^3 - 3x.\n$$\nThe approximate consumption policy is\n$$\n\\hat{c}(k) = \\theta_0 T_0(x(k)) + \\theta_1 T_1(x(k)) + \\theta_2 T_2(x(k)) + \\theta_3 T_3(x(k)),\n$$\nwith coefficient vector $\\boldsymbol{\\theta} = (\\theta_0,\\theta_1,\\theta_2,\\theta_3)$ specific to each parameter set. For any given $k$, define implied next-period capital\n$$\nk'(k) = A k^{\\alpha} + (1-\\delta) k - \\hat{c}(k),\n$$\nand define the absolute Euler equation residual at $k$ as\n$$\n\\left| u'(\\hat{c}(k)) - \\beta \\, u'(\\hat{c}(k'(k))) \\left( A \\alpha (k'(k))^{\\alpha - 1} + 1 - \\delta \\right) \\right|.\n$$\nYour task is to compute, for each parameter set below, the maximum absolute Euler equation residual over a fine uniform grid of $N_{\\text{fine}}$ points spanning $[k_{\\min}, k_{\\max}]$. Use a grid that includes both endpoints. The answer has no physical units.\n\nTest suite (each case specifies $(A,\\alpha,\\beta,\\delta,\\sigma)$, the domain $[k_{\\min},k_{\\max}]$, the coefficient vector $\\boldsymbol{\\theta}$, and $N_{\\text{fine}}$):\n\n- Case 1 (baseline, interior): $(A,\\alpha,\\beta,\\delta,\\sigma) = (1.0, 0.33, 0.96, 0.08, 2.0)$, $[k_{\\min}, k_{\\max}] = [0.5, 3.0]$, $\\boldsymbol{\\theta} = (0.75, 0.35, 0.02, -0.01)$, $N_{\\text{fine}} = 2001$.\n\n- Case 2 (higher risk aversion): $(A,\\alpha,\\beta,\\delta,\\sigma) = (1.0, 0.33, 0.96, 0.08, 5.0)$, $[k_{\\min}, k_{\\max}] = [0.5, 3.0]$, $\\boldsymbol{\\theta} = (0.70, 0.32, 0.00, 0.00)$, $N_{\\text{fine}} = 2001$.\n\n- Case 3 (higher depreciation and lower patience): $(A,\\alpha,\\beta,\\delta,\\sigma) = (1.0, 0.33, 0.92, 0.15, 2.0)$, $[k_{\\min}, k_{\\max}] = [0.5, 3.0]$, $\\boldsymbol{\\theta} = (0.65, 0.28, 0.03, 0.00)$, $N_{\\text{fine}} = 2001$.\n\n- Case 4 (near-log utility): $(A,\\alpha,\\beta,\\delta,\\sigma) = (1.0, 0.33, 0.96, 0.08, 1.01)$, $[k_{\\min}, k_{\\max}] = [0.5, 3.0]$, $\\boldsymbol{\\theta} = (0.74, 0.34, 0.01, 0.02)$, $N_{\\text{fine}} = 2001$.\n\n- Case 5 (log utility edge case): $(A,\\alpha,\\beta,\\delta,\\sigma) = (1.0, 0.33, 0.96, 0.08, 1.0)$, $[k_{\\min}, k_{\\max}] = [0.5, 3.0]$, $\\boldsymbol{\\theta} = (0.72, 0.33, 0.01, 0.00)$, $N_{\\text{fine}} = 2001$.\n\nFor each case, compute the maximum absolute Euler equation residual over the fine grid. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4,result5]\"). Report each result as a floating-point number without any percentage sign, with no specific rounding requirement.", "solution": "The problem statement submitted is a well-defined exercise in computational economics. It is scientifically grounded, internally consistent, and contains all necessary information to proceed. The task is to assess the accuracy of a pre-computed approximate policy function for the deterministic neoclassical growth model by calculating the maximum Euler equation residual over a specified domain. I will proceed with the solution.\n\nThe objective is to compute the maximum absolute Euler equation residual, defined as\n$$\n\\text{Res}(k) = \\left| u'(\\hat{c}(k)) - \\beta \\, u'(\\hat{c}(k'(k))) \\left( A \\alpha (k'(k))^{\\alpha - 1} + 1 - \\delta \\right) \\right|,\n$$\nfor a set of capital grid points $k \\in [k_{\\min}, k_{\\max}]$. The policy function for consumption, $\\hat{c}(k)$, is approximated using a linear combination of the first four Chebyshev polynomials of the first kind, $T_n(x)$.\n\nThe computational procedure for each test case is as follows:\n\n1.  **Establish the Capital Grid**: A uniform grid of $N_{\\text{fine}}$ capital levels, denoted $\\{k_i\\}_{i=1}^{N_{\\text{fine}}}$, is constructed over the interval $[k_{\\min}, k_{\\max}]$. This grid includes the endpoints.\n\n2.  **Evaluate Current Consumption $\\hat{c}(k)$**: For each capital level $k_i$ on the grid, we first map it to the Chebyshev domain $x_i = x(k_i) \\in [-1,1]$ using the affine transformation:\n    $$\n    x(k_i) = \\frac{2 k_i - (k_{\\min} + k_{\\max})}{k_{\\max} - k_{\\min}}.\n    $$\n    The approximate consumption $\\hat{c}(k_i)$ is then computed by evaluating the Chebyshev polynomial expansion with the given coefficient vector $\\boldsymbol{\\theta} = (\\theta_0, \\theta_1, \\theta_2, \\theta_3)$:\n    $$\n    \\hat{c}(k_i) = \\sum_{j=0}^{3} \\theta_j T_j(x(k_i)).\n    $$\n    The basis polynomials are $T_0(x) = 1$, $T_1(x) = x$, $T_2(x) = 2x^2 - 1$, and $T_3(x) = 4x^3 - 3x$.\n\n3.  **Determine Next-Period Capital $k'$**: Using the law of motion for capital, the implied next-period capital stock, $k'_i = k'(k_i)$, is calculated for each $k_i$:\n    $$\n    k'_i = A k_i^{\\alpha} + (1-\\delta) k_i - \\hat{c}(k_i).\n    $$\n\n4.  **Evaluate Next-Period Consumption $\\hat{c}(k')$**: The consumption in the next period, $\\hat{c}(k'_i)$, is determined by applying the same approximate policy function to the resulting capital stock $k'_i$. This involves mapping each $k'_i$ to its corresponding Chebyshev domain value $x'_i = x(k'_i)$ and evaluating the polynomial expansion:\n    $$\n    \\hat{c}(k'_i) = \\sum_{j=0}^{3} \\theta_j T_j(x(k'_i)).\n    $$\n    Note that $k'_i$ is not guaranteed to be within the original approximation domain $[k_{\\min}, k_{\\max}]$. In such cases, the polynomial provides an extrapolation.\n\n5.  **Calculate Marginal Utilities**: The marginal utility of consumption, $u'(c)$, is evaluated for both current and next-period consumption. The function depends on the coefficient of relative risk aversion, $\\sigma$:\n    $$\n    u'(c) =\n    \\begin{cases}\n    c^{-\\sigma}, & \\text{if } \\sigma \\neq 1, \\\\\n    c^{-1}, & \\text{if } \\sigma = 1.\n    \\end{cases}\n    $$\n    We compute $u'(\\hat{c}(k_i))$ and $u'(\\hat{c}(k'_i))$ for all points on the grid.\n\n6.  **Calculate the Euler Equation Residual**: For each grid point $k_i$, the two sides of the Euler equation are computed and compared. The left-hand side (LHS) is $u'(\\hat{c}(k_i))$. The right-hand side (RHS) is\n    $$\n    \\text{RHS}_i = \\beta \\, u'(\\hat{c}(k'_i)) \\left( A \\alpha (k'_i)^{\\alpha - 1} + 1 - \\delta \\right).\n    $$\n    The term $A \\alpha (k'_i)^{\\alpha - 1} + 1 - \\delta$ represents the gross return on capital in the next period. The absolute residual at $k_i$ is $\\text{Res}(k_i) = |\\text{LHS}_i - \\text{RHS}_i|$.\n\n7.  **Find the Maximum Residual**: After calculating the residual $\\text{Res}(k_i)$ for all $i=1, \\dots, N_{\\text{fine}}$, the maximum value is identified:\n    $$\n    \\max_{i} \\text{Res}(k_i).\n    $$\nThis maximum value quantifies the largest error of the approximate policy function in satisfying the model's optimality condition over the specified grid. The entire process is implemented using vectorized numerical operations for efficiency.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the maximum absolute Euler equation residual for several parameterizations\n    of the neoclassical growth model, given an approximate consumption policy function\n    represented by Chebyshev polynomials.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: (A, alpha, beta, delta, sigma), [k_min, k_max], theta, N_fine\n        ( (1.0, 0.33, 0.96, 0.08, 2.0), [0.5, 3.0], [0.75, 0.35, 0.02, -0.01], 2001 ),\n        # Case 2\n        ( (1.0, 0.33, 0.96, 0.08, 5.0), [0.5, 3.0], [0.70, 0.32, 0.00, 0.00], 2001 ),\n        # Case 3\n        ( (1.0, 0.33, 0.92, 0.15, 2.0), [0.5, 3.0], [0.65, 0.28, 0.03, 0.00], 2001 ),\n        # Case 4\n        ( (1.0, 0.33, 0.96, 0.08, 1.01), [0.5, 3.0], [0.74, 0.34, 0.01, 0.02], 2001 ),\n        # Case 5\n        ( (1.0, 0.33, 0.96, 0.08, 1.0), [0.5, 3.0], [0.72, 0.33, 0.01, 0.00], 2001 )\n    ]\n\n    results = []\n\n    def evaluate_chebyshev_policy(k, k_min, k_max, theta_coeffs):\n        \"\"\"\n        Evaluates the consumption policy approximated by Chebyshev polynomials.\n        It is vectorized to operate on an array of capital levels k.\n        \"\"\"\n        # Map capital k from [k_min, k_max] to x in [-1, 1]\n        x = (2 * k - (k_min + k_max)) / (k_max - k_min)\n        \n        # Chebyshev polynomials T0, T1, T2, T3\n        T0 = np.ones_like(x)\n        T1 = x\n        T2 = 2 * x**2 - 1\n        T3 = 4 * x**3 - 3 * x\n        \n        # Form the basis matrix (N x 4)\n        chebyshev_basis = np.vstack([T0, T1, T2, T3]).T\n        \n        # Calculate consumption c_hat using matrix-vector product\n        c_hat = chebyshev_basis @ theta_coeffs\n        return c_hat\n\n    for case in test_cases:\n        params, k_domain, theta_list, N_fine = case\n        A, alpha, beta, delta, sigma = params\n        k_min, k_max = k_domain\n        theta = np.array(theta_list)\n\n        # 1. Create the capital grid\n        k_grid = np.linspace(k_min, k_max, N_fine)\n        \n        # 2. Evaluate current consumption on the grid\n        c_k = evaluate_chebyshev_policy(k_grid, k_min, k_max, theta)\n        \n        # 3. Determine next-period capital\n        k_prime = A * k_grid**alpha + (1 - delta) * k_grid - c_k\n        \n        # 4. Evaluate next-period consumption\n        c_k_prime = evaluate_chebyshev_policy(k_prime, k_min, k_max, theta)\n        \n        # 5. Calculate marginal utilities\n        if sigma == 1.0:\n            mu_k = 1.0 / c_k\n            mu_k_prime = 1.0 / c_k_prime\n        else:\n            mu_k = c_k**(-sigma)\n            mu_k_prime = c_k_prime**(-sigma)\n\n        # 6. Calculate the RHS of the Euler equation\n        # Marginal product of capital in the next period\n        mpk_prime = A * alpha * k_prime**(alpha - 1) + 1 - delta\n        \n        # Full RHS\n        euler_rhs = beta * mu_k_prime * mpk_prime\n        \n        # 7. Calculate the absolute residuals\n        residuals = np.abs(mu_k - euler_rhs)\n        \n        # 8. Find the maximum residual and store it\n        max_residual = np.max(residuals)\n        results.append(max_residual)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"}, {"introduction": "Now you are ready to construct a complete solver from scratch for a canonical deterministic growth model. This practice introduces a powerful and modern technique: using automatic differentiation (AD) to compute the Jacobian matrix required for a Newton's method solver. By implementing a simple dual number class, you will see how AD can elegantly handle the complex derivatives involved in projection methods, allowing you to build a more robust and efficient solver [@problem_id:2422824].", "id": "2422824", "problem": "You are asked to implement and solve, by projection and collocation with automatic differentiation, a deterministic one-state neoclassical growth model using polynomial policy approximation. The numerical target is to approximate the optimal policy that satisfies the intertemporal optimality condition, and to report the maximum Euler-equation residual on an evaluation grid for several parameter sets. Your program must be a complete, runnable program and produce the specified single-line output.\n\nModel and fundamental base:\n- The representative agent chooses consumption $c_t$ and next-period capital $k_{t+1}$ to maximize the discounted sum of period utility\n$$\\sum_{t=0}^{\\infty} \\beta^t u(c_t),$$\nsubject to the law of motion for resources\n$$c_t + k_{t+1} = f(k_t) + (1-\\delta)\\,k_t,$$\nwith production $f(k) = A\\,k^{\\alpha}$, discount factor $\\beta \\in (0,1)$, capital share $\\alpha \\in (0,1)$, depreciation rate $\\delta \\in (0,1)$, and productivity $A > 0$. Preferences are Constant Relative Risk Aversion (CRRA) with parameter $\\gamma > 0$, given by\n$$u(c) = \n\\begin{cases}\n\\frac{c^{1-\\gamma}}{1-\\gamma}, & \\gamma \\neq 1,\\\\\n\\ln(c), & \\gamma = 1,\n\\end{cases}\n\\quad\\text{so that}\\quad\nu'(c) = \n\\begin{cases}\nc^{-\\gamma}, & \\gamma \\neq 1,\\\\\n\\frac{1}{c}, & \\gamma = 1.\n\\end{cases}$$\n- The intertemporal optimality (Euler) condition for an interior solution is\n$$u'(c_t) = \\beta\\,u'(c_{t+1})\\left(f'(k_{t+1}) + 1 - \\delta\\right),$$\nwhere $f'(k) = \\alpha A k^{\\alpha - 1}$.\n\nPolicy representation and projection setup:\n- Define available resources $R(k) = f(k)+(1-\\delta)k$.\n- Parameterize the policy as a smooth savings share $s(k) \\in (0,1)$, and set\n$$k' = s(k)\\,R(k), \\quad c = (1-s(k))\\,R(k).$$\n- Let $x(k)$ be the affine map that takes $k \\in [k_{\\min},k_{\\max}]$ into $[-1,1]$:\n$$x(k) = \\frac{2k - (k_{\\min} + k_{\\max})}{k_{\\max} - k_{\\min}}.$$\n- Approximate the logit of the savings share by a truncated Chebyshev series of degree $n-1$:\n$$\\phi(k) \\equiv \\log\\left(\\frac{s(k)}{1 - s(k)}\\right) \\approx \\sum_{j=0}^{n-1} a_j\\,T_j(x(k)),$$\nand then $s(k) = \\sigma(\\phi(k))$ with the logistic map $\\sigma(z) = \\frac{1}{1+e^{-z}}$.\n- Collocation: choose $n$ Chebyshev nodes $x_i = \\cos\\left(\\frac{2i-1}{2n}\\pi\\right)$ for $i=1,\\dots,n$ and map them to capital gridpoints $k_i$ via $x \\mapsto k$. Impose the $n$ Euler equation residuals to be zero at the $n$ nodes, defining the residual vector $R(a)\\in\\mathbb{R}^n$ by\n$$R_i(a) = u'\\big(c(k_i;a)\\big) - \\beta\\,u'\\big(c(k'_i;a)\\big)\\left(f'(k'_i)+1-\\delta\\right), \\quad k'_i = s(k_i;a)\\,R(k_i), \\quad c(k_i;a) = R(k_i) - k'_i,$$\n$$c(k'_i;a) = R(k'_i) - s(k'_i;a)\\,R(k'_i).$$\nHere $a = (a_0,\\dots,a_{n-1})$ are the unknown coefficients.\n\nAutomatic differentiation requirement:\n- To implement a stable and accurate Newton solver for the nonlinear system $R(a) = 0$, compute the Jacobian matrix $\\frac{\\partial R}{\\partial a}(a)$ using automatic differentiation. You may implement forward-mode dual numbers to achieve this behavior, so that the code remains self-contained and does not rely on external packages beyond the allowed libraries.\n\nNumerical specifications to ensure realism and reproducibility:\n- For each parameter set, compute the steady-state capital level $k^{\\ast}$ implied by the steady-state Euler condition\n$$f'(k^{\\ast}) + 1 - \\delta = \\frac{1}{\\beta}, \\quad\\text{that is}\\quad \\alpha A (k^{\\ast})^{\\alpha - 1} = \\frac{1}{\\beta} - 1 + \\delta,$$\nand set the approximation interval $[k_{\\min},k_{\\max}] = [\\zeta_1 k^{\\ast},\\, \\zeta_2 k^{\\ast}]$ with $\\zeta_1 = 0.7$ and $\\zeta_2 = 1.3$.\n- Use $n = 7$ Chebyshev basis functions and $n = 7$ collocation nodes.\n- Initialize the coefficients with a constant logit corresponding to the steady-state savings share $s^{\\ast} = \\frac{k^{\\ast}}{R(k^{\\ast})}$, i.e., set $a_0 = \\log\\left(\\frac{s^{\\ast}}{1-s^{\\ast}}\\right)$ and $a_j = 0$ for $j \\ge 1$.\n\nTest suite:\nImplement your solver and evaluate the quality of the projection solution by computing, for each parameter set below, the maximum absolute Euler residual on an evaluation grid of $M = 80$ equally spaced points over $[k_{\\min},k_{\\max}]$:\n$$\\max_{k \\in \\mathcal{G}} \\left| u'\\big(c(k;a)\\big) - \\beta\\,u'\\big(c(k';a)\\big)\\left(f'(k')+1-\\delta\\right) \\right|,$$\nwhere $\\mathcal{G}$ is the uniform grid and $k' = s(k;a)R(k)$, $c(k;a)=R(k)-k'$, $c(k';a)=R(k')-s(k';a)R(k')$ as above. Report this maximum as a floating-point number per test case.\n\nThe parameter sets are:\n- Case A (baseline): $(\\alpha,\\beta,\\delta,\\gamma,A) = (0.33,\\,0.96,\\,0.08,\\,2.0,\\,1.0)$.\n- Case B (patient): $(\\alpha,\\beta,\\delta,\\gamma,A) = (0.36,\\,0.99,\\,0.025,\\,2.0,\\,1.0)$.\n- Case C (high depreciation and risk aversion): $(\\alpha,\\beta,\\delta,\\gamma,A) = (0.40,\\,0.95,\\,0.15,\\,3.0,\\,1.0)$.\n- Case D (log utility): $(\\alpha,\\beta,\\delta,\\gamma,A) = (0.33,\\,0.97,\\,0.08,\\,1.0,\\,1.0)$.\n\nAlgorithmic requirements:\n- Use Newton's method with backtracking line search on the coefficient vector $a$ to solve $R(a) = 0$. Terminate when the infinity norm of the residual vector is below $\\varepsilon = 10^{-8}$ or a maximum of $I_{\\max} = 50$ iterations is reached.\n- Compute the Jacobian $\\frac{\\partial R}{\\partial a}(a)$ by forward-mode dual numbers, differentiating through the Chebyshev recurrence $T_0(x)=1$, $T_1(x)=x$, $T_{j+1}(x) = 2xT_j(x) - T_{j-1}(x)$ and all downstream computations, including $k'$, $c$, $c'$.\n- When solving the Newton step, you may use a least-squares step if the Jacobian is singular or ill-conditioned.\n\nFinal output format:\n- For the four cases Aâ€“D in the order given, your program should produce a single line of output containing the four maximum residual values as a comma-separated list enclosed in square brackets, for example, \"[vA,vB,vC,vD]\". Each entry must be a floating-point number.\n\nNo physical units or angle units are involved. Express all final numerical values as plain floating-point numbers without percent signs. The program must be self-contained and must not require any user input or external files. The only allowed libraries are the Python standard library, NumPy, and SciPy as declared in the execution environment.", "solution": "The problem presented is a standard, well-defined exercise in computational economics: the numerical solution of the deterministic neoclassical growth model using a projection method. All components of the problemâ€”the economic model, the approximation architecture, and the numerical algorithmâ€”are based on established and scientifically sound principles. The problem is self-contained, internally consistent, and Factual soundness, well-posedness, and objectivity are all satisfied, rendering the problem valid for a full solution.\n\nWe begin from the fundamental optimality condition of the model, the Euler equation, which links marginal utility across time:\n$$\nu'(c_t) = \\beta\\,u'(c_{t+1})\\left(f'(k_{t+1}) + 1 - \\delta\\right)\n$$\nHere, $c_t$ is consumption at time $t$, $k_t$ is the capital stock, $\\beta$ is the discount factor, and $\\delta$ is the capital depreciation rate. The utility function is of the Constant Relative Risk Aversion (CRRA) form, $u(c) = \\frac{c^{1-\\gamma}}{1-\\gamma}$ (or $\\ln(c)$ if $\\gamma=1$), for which the marginal utility is consistently $u'(c) = c^{-\\gamma}$. The production function is Cobb-Douglas, $f(k) = Ak^{\\alpha}$, with marginal product $f'(k) = \\alpha A k^{\\alpha-1}$.\n\nThe objective is to find the optimal policy function, which dictates the next period's capital, $k_{t+1}$, for any given current capital stock, $k_t$. We denote this function as $k_{t+1} = g(k_t)$. The projection method approximates this unknown function $g(k)$ with a known, parameterized functional form. The problem specifies a numerically stable parameterization via the savings share, $s(k) \\in (0,1)$, such that:\n$$\nk_{t+1} = s(k_t) R(k_t) \\quad \\text{and} \\quad c_t = (1-s(k_t))R(k_t)\n$$\nwhere $R(k) = f(k) + (1-\\delta)k$ represents the total resources available from production and undepreciated capital. This formulation ensures the resource constraint is met by construction.\n\nTo facilitate approximation over an unbounded range, the savings share $s(k)$ is transformed using the logit function, $\\phi(k) = \\log\\left(\\frac{s(k)}{1-s(k)}\\right)$. This transformed policy function $\\phi(k)$ is approximated by a truncated series of $n$ Chebyshev polynomials of the first kind, $T_j(x)$:\n$$\n\\phi(k; a) \\approx \\sum_{j=0}^{n-1} a_j T_j(x(k))\n$$\nwhere $a = (a_0, \\dots, a_{n-1})$ is the vector of unknown coefficients to be determined. The variable $x(k)$ is an affine transformation that maps the capital approximation domain $[k_{\\min}, k_{\\max}]$ to the domain of Chebyshev polynomials, $[-1, 1]$. Given the coefficients $a$, the savings share is recovered via the inverse logit (logistic) function, $s(k;a) = \\frac{1}{1+e^{-\\phi(k;a)}}$.\n\nThe core of the projection method is to determine the coefficients $a$ by requiring the Euler equation to hold exactly at a set of $n$ specific points, known as collocation nodes. The problem specifies these nodes to be the $n$ roots of the Chebyshev polynomial $T_n(x)$, mapped back to the capital domain $[k_{\\min}, k_{\\max}]$. This creates a system of $n$ nonlinear equations for the $n$ unknown coefficients. For each collocation node $k_i$, we define a residual function $E_i(a)$:\n$$\nE_i(a) = u'(c_i) - \\beta u'(c'_i)(f'(k'_i) + 1 - \\delta) = 0\n$$\nwhere $c_i = c(k_i; a)$, $k'_i = k(k_i; a)$, and $c'_i = c(k'_i; a)$. The goal is to find the vector $a$ that solves the system $E(a) = 0$.\n\nThis system is solved using Newton's method, an iterative algorithm that requires the computation of the Jacobian matrix, $J(a) = \\frac{\\partial E}{\\partial a}(a)$. The entry $J_{ij}$ is the partial derivative of the $i$-th residual with respect to the $j$-th coefficient. The update rule for the coefficients is:\n$$\na_{new} = a_{old} - J(a_{old})^{-1} E(a_{old})\n$$\nThe problem demands the Jacobian be computed via forward-mode automatic differentiation (AD). This is achieved by implementing a dual number system. A dual number $z = v + \\dot{v}\\epsilon$ has a value part $v$ and a derivative part $\\dot{v}$, with the property $\\epsilon^2 = 0$. All mathematical operations and functions are overloaded to propagate derivatives according to the rules of calculus. For instance, for a function $h(z)$, we have $h(v + \\dot{v}\\epsilon) = h(v) + h'(v)\\dot{v}\\epsilon$. To compute the $j$-th column of the Jacobian, we initialize the coefficient vector as $a_k = a_k^{\\text{val}} + \\delta_{kj}\\epsilon$ (where $\\delta_{kj}$ is the Kronecker delta) and compute the entire residual vector $E$. The derivative part of the $i$-th resulting dual number, $\\dot{E_i}$, is precisely the Jacobian element $J_{ij}$.\n\nThe Newton's method is augmented with a backtracking line search to ensure robust convergence. If a full Newton step does not decrease the norm of the residual vector, the step size is successively reduced. The solver iterates until the infinity norm of the residual vector falls below a specified tolerance $\\varepsilon = 10^{-8}$.\n\nOnce the optimal coefficient vector $a^*$ is found, the quality of the approximation is assessed by computing the maximum absolute Euler equation residual on a fine grid of $M=80$ points spanning the approximation interval $[k_{\\min}, k_{\\max}]$. This value serves as the final reportable metric for each parameter set.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# ---- Automatic Differentiation: Dual Number Implementation ----\nclass Dual:\n    \"\"\"\n    A class for forward-mode automatic differentiation.\n    A Dual number z = val + der * epsilon, where epsilon^2 = 0.\n    \"\"\"\n    def __init__(self, val, der=0.0):\n        self.val = val\n        self.der = der\n\n    def __add__(self, other):\n        if isinstance(other, Dual):\n            return Dual(self.val + other.val, self.der + other.der)\n        return Dual(self.val + other, self.der)\n\n    def __radd__(self, other):\n        return self.__add__(other)\n\n    def __sub__(self, other):\n        if isinstance(other, Dual):\n            return Dual(self.val - other.val, self.der - other.der)\n        return Dual(self.val - other, self.der)\n\n    def __rsub__(self, other):\n        return Dual(other - self.val, -self.der)\n\n    def __mul__(self, other):\n        if isinstance(other, Dual):\n            return Dual(self.val * other.val, self.der * other.val + self.val * other.der)\n        return Dual(self.val * other, self.der * other)\n\n    def __rmul__(self, other):\n        return self.__mul__(other)\n\n    def __truediv__(self, other):\n        if isinstance(other, Dual):\n            val = self.val / other.val\n            der = (self.der * other.val - self.val * other.der) / (other.val**2)\n            return Dual(val, der)\n        return Dual(self.val / other, self.der / other)\n\n    def __rtruediv__(self, other):\n        val = other / self.val\n        der = (-other * self.der) / (self.val**2)\n        return Dual(val, der)\n\n    def __pow__(self, power):\n        val = self.val ** power\n        der = power * (self.val ** (power - 1)) * self.der\n        return Dual(val, der)\n\n    def __neg__(self):\n        return Dual(-self.val, -self.der)\n\n    def __repr__(self):\n        return f\"Dual(val={self.val}, der={self.der})\"\n\ndef dual_exp(d):\n    if isinstance(d, Dual):\n        val = np.exp(d.val)\n        return Dual(val, val * d.der)\n    return np.exp(d)\n\ndef dual_pow(base, exp):\n    if isinstance(base, Dual):\n        return base ** exp\n    return base ** exp\n\n\n# ---- Model and Numerical Method Implementation ----\n\ndef chebyshev_poly_vals(x, n):\n    \"\"\"Evaluates the first n Chebyshev polynomials T_0, ..., T_{n-1} at x.\"\"\"\n    if n == 0:\n        return []\n    \n    T = [1.0, x] if not isinstance(x, Dual) else [Dual(1.0), x]\n    \n    for _ in range(n - 2):\n        T.append(2.0 * x * T[-1] - T[-2])\n    return T[:n]\n\ndef evaluate_policy(k, coeffs, params):\n    \"\"\"\n    Given capital k and coefficients a, computes c and k'.\n    This function handles both float and Dual types.\n    \"\"\"\n    alpha, _, delta, _, A, k_min, k_max, n = params\n    \n    is_dual = isinstance(coeffs[0], Dual) or isinstance(k, Dual)\n\n    # 1. Map k to x in [-1, 1]\n    x = (2.0 * k - (k_min + k_max)) / (k_max - k_min)\n\n    # 2. Evaluate Chebyshev basis\n    T_vals = chebyshev_poly_vals(x, n)\n    \n    # 3. Compute logit of savings share phi = sum(a_j * T_j(x))\n    phi = Dual(0.0) if is_dual else 0.0\n    for i in range(n):\n        phi += coeffs[i] * T_vals[i]\n\n    # 4. Compute savings share s = 1 / (1 + exp(-phi))\n    s = 1.0 / (1.0 + dual_exp(-phi))\n\n    # 5. Compute resources R(k), next-period capital k', and consumption c\n    R_k = A * dual_pow(k, alpha) + (1.0 - delta) * k\n    k_prime = s * R_k\n    c = (1.0 - s) * R_k\n\n    return c, k_prime\n\ndef calculate_residuals(coeffs, k_nodes, params):\n    \"\"\"\n    Calculates the Euler equation residuals at the given capital nodes.\n    Handles both float and Dual coefficients.\n    \"\"\"\n    alpha, beta, delta, gamma, A, _, _, _ = params\n    is_dual_input = isinstance(coeffs[0], Dual)\n    residuals = []\n\n    for k_node in k_nodes:\n        # Get c and k' at the current node k\n        c, k_prime = evaluate_policy(k_node, coeffs, params)\n        \n        # Get c' at the future capital level k'\n        c_prime, _ = evaluate_policy(k_prime, coeffs, params)\n\n        # Marginal utility and marginal product\n        u_prime_c = dual_pow(c, -gamma)\n        u_prime_c_prime = dual_pow(c_prime, -gamma)\n        f_prime_k_prime = alpha * A * dual_pow(k_prime, alpha - 1)\n        \n        # Euler residual\n        res = u_prime_c - beta * u_prime_c_prime * (f_prime_k_prime + 1.0 - delta)\n        residuals.append(res)\n    \n    if not is_dual_input:\n        return np.array([r for r in residuals])\n    return residuals\n\ndef solve_for_case(case_params):\n    \"\"\"\n    Solves the model for a single set of parameters.\n    \"\"\"\n    alpha, beta, delta, gamma, A = case_params\n    n, M, tol, max_iter = 7, 80, 1e-8, 50\n\n    # 1. Steady state capital\n    k_ss_numerator = alpha * A\n    k_ss_denominator = 1.0 / beta - 1.0 + delta\n    k_ss = (k_ss_numerator / k_ss_denominator) ** (1.0 / (1.0 - alpha))\n\n    # 2. Grid and state space\n    k_min, k_max = 0.7 * k_ss, 1.3 * k_ss\n    params = (alpha, beta, delta, gamma, A, k_min, k_max, n)\n    \n    # Collocation nodes (zeros of T_n)\n    chebyshev_zeros = np.cos((2 * np.arange(1, n + 1) - 1) * np.pi / (2 * n))\n    k_nodes = (k_min + k_max) / 2.0 + (k_max - k_min) / 2.0 * chebyshev_zeros\n    \n    # 3. Initial guess for coefficients 'a'\n    R_k_ss = A * k_ss**alpha + (1.0 - delta) * k_ss\n    s_ss = k_ss / R_k_ss\n    a = np.zeros(n)\n    a[0] = np.log(s_ss / (1.0 - s_ss))\n\n    # 4. Newton's method solver\n    for i in range(max_iter):\n        # Calculate residuals R(a)\n        R_val = calculate_residuals(a, k_nodes, params)\n        \n        res_norm = np.linalg.norm(R_val, np.inf)\n        if res_norm < tol:\n            break\n\n        # Calculate Jacobian J(a) using Automatic Differentiation\n        J = np.zeros((n, n))\n        for j in range(n):\n            a_dual = [Dual(val, 1.0 if idx == j else 0.0) for idx, val in enumerate(a)]\n            R_dual = calculate_residuals(a_dual, k_nodes, params)\n            J[:, j] = [res.der for res in R_dual]\n        \n        # Solve Newton step using least squares for robustness\n        delta_a = np.linalg.lstsq(J, -R_val, rcond=None)[0]\n        \n        # Backtracking line search\n        lambda_ = 1.0\n        for _ in range(10): # At most 10 backtracking steps\n            a_new = a + lambda_ * delta_a\n            R_new = calculate_residuals(a_new, k_nodes, params)\n            if np.linalg.norm(R_new, np.inf) < res_norm:\n                a = a_new\n                break\n            lambda_ *= 0.5\n        else: # If line search fails, take the small step and hope for the best\n            a = a + lambda_ * delta_a\n\n    # 5. Evaluate solution quality on a fine grid\n    eval_grid = np.linspace(k_min, k_max, M)\n    final_residuals = calculate_residuals(a, eval_grid, params)\n    max_abs_residual = np.max(np.abs(final_residuals))\n    \n    return max_abs_residual\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0.33, 0.96, 0.08, 2.0, 1.0),   # Case A (baseline)\n        (0.36, 0.99, 0.025, 2.0, 1.0),  # Case B (patient)\n        (0.40, 0.95, 0.15, 3.0, 1.0),   # Case C (high depreciation and risk aversion)\n        (0.33, 0.97, 0.08, 1.0, 1.0),   # Case D (log utility)\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_for_case(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"}, {"introduction": "This final practice moves from the certainty of deterministic models to the more realistic world of stochastic dynamics. You will solve a Real Business Cycle (RBC) model where productivity shocks introduce uncertainty, requiring the evaluation of an expectation within the Euler equation. The exercise [@problem_id:2422848] focuses on the art of numerical integration, challenging you to compare a naive quadrature method with a more sophisticated one, thereby deepening your understanding of the nuances and potential pitfalls in solving stochastic models.", "id": "2422848", "problem": "Consider a real business cycle (RBC) economy with inelastic labor supply, capital as the only state variable besides productivity, power utility, and Cobbâ€“Douglas production. Productivity is multiplicative and stochastic. The Bellman formulation leads to first-order optimality conditions that can be summarized by the Euler equation and the resource constraint. Let $k_t$ denote capital, $s_t$ denote the logarithm of productivity, and $z_t = \\exp(s_t)$ denote productivity. Preferences are given by $u(c) = \\frac{c^{1-\\gamma}}{1-\\gamma}$ with risk aversion parameter $\\gamma \\gt 0$, and production follows $y_t = z_t k_t^{\\alpha}$ with capital depreciation rate $\\delta \\in (0,1)$ and capital share $\\alpha \\in (0,1)$. The Euler equation and resource constraint are\n$$\nu'(c_t) = \\beta \\mathbb{E}\\left[u'(c_{t+1})\\left(\\alpha z_{t+1} k_{t+1}^{\\alpha-1} + 1 - \\delta\\right)\\right],\n\\quad\nc_t + k_{t+1} = z_t k_t^{\\alpha} + (1-\\delta)k_t,\n$$\nwhere $\\beta \\in (0,1)$ is the discount factor and expectations are taken with respect to the law of motion of productivity.\n\nUnlike the standard formulation, assume that $s_t$ is independent and identically distributed (i.i.d.) with a bimodal mixture-of-normals distribution:\n$$\ns_t \\sim p \\cdot \\mathcal{N}(\\mu_1,\\sigma_1^2) + (1-p)\\cdot \\mathcal{N}(\\mu_2,\\sigma_2^2),\n$$\nwith mixture weight $p \\in (0,1)$, and component parameters $\\mu_1,\\mu_2 \\in \\mathbb{R}$ and $\\sigma_1,\\sigma_2 \\gt 0$. The process is i.i.d. over time.\n\nYour task is to construct a projection-method solution for the optimal savings-rate policy $\\phi(k,s) \\in (0,1)$ defined by\n$$\nk' = \\phi(k,s)\\left(z k^{\\alpha} + (1-\\delta)k\\right),\n\\quad\nc = \\left(1-\\phi(k,s)\\right)\\left(z k^{\\alpha} + (1-\\delta)k\\right),\n$$\nusing a tensor-product Chebyshev polynomial basis in $(k,s)$ and collocation to minimize the Euler equation residual. The Euler residual at $(k,s)$ is\n$$\n\\mathcal{R}(k,s;\\theta) \\equiv u'(c(k,s;\\theta)) - \\beta\\, \\mathbb{E}\\left[u'(c'(k,s;\\theta,s'))\\left(\\alpha \\exp(s') k'(k,s;\\theta)^{\\alpha-1} + 1-\\delta\\right)\\right],\n$$\nwhere $\\theta$ are the basis coefficients, $k' = \\phi(k,s;\\theta)\\left(\\exp(s)k^{\\alpha} + (1-\\delta)k\\right)$, and $c' = \\left(1-\\phi(k',s';\\theta)\\right)\\left(\\exp(s')k'^{\\alpha} + (1-\\delta)k'\\right)$.\n\nTo compute expectations, use Gaussianâ€“Hermite quadrature (with order specified below). Consider two quadrature schemes for the distribution of $s'$:\n- A naive single-normal scheme that approximates the mixture by a single normal $\\mathcal{N}(\\mu_{\\text{mix}},\\sigma_{\\text{mix}}^2)$ whose mean and variance match those of the mixture. Under this approximation, use Gaussianâ€“Hermite quadrature to compute $\\mathbb{E}[g(s')]$ via the change of variables $s' = \\mu_{\\text{mix}} + \\sqrt{2}\\,\\sigma_{\\text{mix}} x$ with weights adjusted accordingly.\n- A mixture-correct scheme that computes $\\mathbb{E}[g(s')]$ as $p$ times the Gaussianâ€“Hermite quadrature under $\\mathcal{N}(\\mu_1,\\sigma_1^2)$ plus $(1-p)$ times the Gaussianâ€“Hermite quadrature under $\\mathcal{N}(\\mu_2,\\sigma_2^2)$.\n\nYou must:\n- Specify the projection basis as a tensor product of Chebyshev polynomials up to degree $d_k$ in $k$ and $d_s$ in $s$. Map the domains of $k$ and $s$ affinely to $[-1,1]$ before evaluating Chebyshev polynomials. Use $d_k = 3$ and $d_s = 2$.\n- Parameterize the policy as $\\phi(k,s;\\theta) = \\sigma\\!\\left(B(k,s)^{\\top}\\theta\\right)$ where $B(k,s)$ is the basis vector and $\\sigma(\\cdot)$ is the logistic sigmoid mapping to $(0,1)$. This enforces feasibility $c \\in (0, z k^{\\alpha} + (1-\\delta)k)$ for all $(k,s)$.\n- Choose a rectangular collocation grid as the tensor product of Chebyshev nodes in $k$ and $s$ of sizes $N_k=7$ and $N_s=5$ respectively.\n- Compute the deterministic steady-state capital $k^{\\star}$ under the unconditional mean of productivity $\\mathbb{E}[z] = \\mathbb{E}[\\exp(s)]$ implied by the mixture, and set the domain for $k$ to $[0.75\\,k^{\\star}, 1.25\\,k^{\\star}]$. Set the domain for $s$ to $[\\min(\\mu_1 - 3\\sigma_1, \\mu_2 - 3\\sigma_2), \\max(\\mu_1 + 3\\sigma_1, \\mu_2 + 3\\sigma_2)]$.\n- Solve for basis coefficients $\\theta$ by nonlinear least squares on the Euler residuals at collocation nodes. Do this twice: once using the naive single-normal quadrature in the residual definition, and once using the mixture-correct quadrature.\n- Validate each solution on a finer rectangular grid of size $N_k^{\\text{val}}=13$ by $N_s^{\\text{val}}=9$ (Chebyshev nodes mapped to the same domains), computing the supremum norm of the Euler residual evaluated with the true mixture-correct quadrature.\n\nUse the following fixed structural parameters: $\\alpha = 0.33$, $\\beta = 0.96$, $\\delta = 0.08$, $\\gamma = 2.0$. Use Gaussianâ€“Hermite quadrature of order $N_q = 7$ for expectations.\n\nTest suite. Solve the problem for the three independent cases below (all other parameters as specified above):\n- Case A (balanced bimodality): $p = 0.5$, $\\mu_1 = -0.1$, $\\sigma_1 = 0.05$, $\\mu_2 = 0.1$, $\\sigma_2 = 0.05$.\n- Case B (asymmetric and more separated): $p = 0.7$, $\\mu_1 = -0.2$, $\\sigma_1 = 0.08$, $\\mu_2 = 0.2$, $\\sigma_2 = 0.08$.\n- Case C (degenerate to unimodal): $p = 0.4$, $\\mu_1 = 0.0$, $\\sigma_1 = 0.07$, $\\mu_2 = 0.0$, $\\sigma_2 = 0.07$.\n\nFor each case, after solving for the policy under both quadrature schemes, compute on the validation grid:\n- $r_{\\text{mix}}$: the supremum norm of the Euler residual using the mixture-correct policy evaluated with the mixture-correct quadrature.\n- $r_{\\text{naive}\\to \\text{true}}$: the supremum norm of the Euler residual using the naive-quadrature policy evaluated with the mixture-correct quadrature.\n- $\\Delta r \\equiv r_{\\text{naive}\\to \\text{true}} - r_{\\text{mix}}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets in the order\n$$\n\\left[r_{\\text{mix}}^{(A)},\\; r_{\\text{naive}\\to \\text{true}}^{(A)},\\; \\Delta r^{(A)},\\; r_{\\text{mix}}^{(B)},\\; r_{\\text{naive}\\to \\text{true}}^{(B)},\\; \\Delta r^{(B)},\\; r_{\\text{mix}}^{(C)},\\; r_{\\text{naive}\\to \\text{true}}^{(C)},\\; \\Delta r^{(C)}\\right].\n$$\nAll numbers are unitless real values. No angles or percentages are involved.\n\nThe final answer must be a complete, runnable program that implements the above specifications and prints exactly one line in the required format. Do not require any user input.", "solution": "The problem presented is a well-posed exercise in computational economics, requiring the application of projection methods to solve a dynamic stochastic general equilibrium model. Its parameters are clearly defined, its scientific basis is sound within the framework of real business cycle theory, and the specified numerical methods are standard and appropriate for the task. The problem is therefore valid, and a solution will be constructed.\n\nThe objective is to find an approximate solution for the optimal consumption-savings policy in a stochastic growth model. The economy's dynamics are governed by the intertemporal Euler equation, which equates the marginal utility cost of sacrificing a unit of current consumption to the expected discounted marginal utility benefit of the resulting future consumption. The state of the economy is described by the capital stock, $k$, and the logarithm of productivity, $s$.\n\nThe governing functional equation is the Euler equation:\n$$\nu'(c_t) = \\beta \\mathbb{E}_t\\left[u'(c_{t+1})\\left(\\alpha z_{t+1} k_{t+1}^{\\alpha-1} + 1 - \\delta\\right)\\right]\n$$\nwhere $u'(c) = c^{-\\gamma}$ is the marginal utility of consumption, $\\beta$ is the discount factor, $\\alpha$ is the capital share in production, $\\delta$ is the capital depreciation rate, and $z_{t+1} = \\exp(s_{t+1})$ is the future productivity level. The expectation $\\mathbb{E}_t[\\cdot]$ is taken over the distribution of the future productivity shock $s_{t+1}$. The law of motion for capital is determined by the resource constraint, $c_t + k_{t+1} = z_t k_t^{\\alpha} + (1-\\delta)k_t$.\n\nThe core of the problem is that an analytical solution for the policy functionsâ€”consumption $c(k,s)$ and next-period capital $k'(k,s)$â€”is not available. We thus resort to numerical approximation.\n\n**1. Policy Function Approximation**\n\nWe approximate the optimal savings-rate policy $\\phi(k,s)$, which dictates the fraction of available resources to be saved. The policy functions for next-period capital and current consumption are then:\n$$\nk'(k,s) = \\phi(k,s) \\left( \\exp(s) k^{\\alpha} + (1-\\delta)k \\right)\n$$\n$$\nc(k,s) = (1-\\phi(k,s)) \\left( \\exp(s) k^{\\alpha} + (1-\\delta)k \\right)\n$$\nThe savings rate must lie in the interval $(0,1)$ to ensure both consumption and investment are positive. We enforce this constraint by parameterizing the policy using the logistic sigmoid function, $\\sigma(x) = (1+e^{-x})^{-1}$:\n$$\n\\phi(k,s; \\theta) = \\sigma\\left(\\sum_{i=0}^{d_k} \\sum_{j=0}^{d_s} \\theta_{ij} T_i(\\hat{k}) T_j(\\hat{s})\\right)\n$$\nHere, $\\{T_i\\}$ and $\\{T_j\\}$ are Chebyshev polynomials of the first kind. The state variables $(k,s)$ are linearly mapped to $(\\hat{k}, \\hat{s})$ in the canonical domain $[-1,1]$ over which the polynomials are defined. The set of coefficients $\\{\\theta_{ij}\\}$ are the parameters to be determined. The degrees are specified as $d_k=3$ and $d_s=2$, resulting in $(3+1)(2+1)=12$ basis functions and corresponding coefficients $\\theta$.\n\n**2. State-Space and Collocation Grid**\n\nThe approximation is performed over a bounded domain for the state variables.\n- The domain for capital $k$ is centered around the deterministic steady-state capital stock $k^{\\star}$. This steady state is found by assuming productivity is fixed at its unconditional mean, $\\mathbb{E}[z] = \\mathbb{E}[\\exp(s)]$, and all state variables are constant. Solving the steady-state Euler equation $1 = \\beta (\\alpha \\mathbb{E}[z] (k^{\\star})^{\\alpha-1} + 1 - \\delta)$ yields:\n$$\nk^{\\star} = \\left( \\frac{\\alpha \\mathbb{E}[z]}{\\frac{1}{\\beta} - 1 + \\delta} \\right)^{\\frac{1}{1-\\alpha}}\n$$\nThe expectation $\\mathbb{E}[z]$ is computed with respect to the specified mixture-of-normals distribution for $s$:\n$$\n\\mathbb{E}[z] = \\mathbb{E}[\\exp(s)] = p \\cdot \\mathbb{E}_{\\mathcal{N}(\\mu_1,\\sigma_1^2)}[\\exp(s)] + (1-p) \\cdot \\mathbb{E}_{\\mathcal{N}(\\mu_2,\\sigma_2^2)}[\\exp(s)] = p e^{\\mu_1 + \\sigma_1^2/2} + (1-p) e^{\\mu_2 + \\sigma_2^2/2}\n$$\nThe domain for $k$ is then set to $[0.75 k^{\\star}, 1.25 k^{\\star}]$.\n- The domain for the productivity shock $s$ is set to cover the bulk of its probability mass: $[\\min(\\mu_1 - 3\\sigma_1, \\mu_2 - 3\\sigma_2), \\max(\\mu_1 + 3\\sigma_1, \\mu_2 + 3\\sigma_2)]$.\n\nTo solve for the coefficients $\\theta$, we use the collocation method. We enforce the Euler equation at a set of discrete points (collocation nodes) within the domain. These nodes are chosen as the tensor product of the roots of Chebyshev polynomials, specifically a grid of $N_k=7$ points for capital and $N_s=5$ points for log-productivity.\n\n**3. Euler Equation Residual and Solution**\n\nThe approximated policy function $\\phi(k,s;\\theta)$ will not satisfy the Euler equation exactly. We define the Euler equation residual $\\mathcal{R}(k,s;\\theta)$ as the difference between the left and right sides of the equation:\n$$\n\\mathcal{R}(k,s;\\theta) \\equiv c(k,s;\\theta)^{-\\gamma} - \\beta \\mathbb{E}\\left[c'(k,s;\\theta,s')^{-\\gamma}\\left(\\alpha \\exp(s') k'(k,s;\\theta)^{\\alpha-1} + 1-\\delta\\right)\\right]\n$$\nThe coefficients $\\theta$ are chosen to minimize the sum of squared residuals over the set of collocation nodes. This is a nonlinear least-squares problem: $\\min_{\\theta} \\sum_{i,j} [\\mathcal{R}(k_i, s_j; \\theta)]^2$.\n\n**4. Numerical Quadrature for Expectation**\n\nA central task is the numerical evaluation of the expectation term. The problem mandates a comparison of two schemes, both based on $N_q=7$-point Gaussian-Hermite quadrature. For a generic function $g(s')$, the expectation under a normal distribution $s' \\sim \\mathcal{N}(\\mu, \\sigma^2)$ is approximated as:\n$$\n\\mathbb{E}[g(s')] = \\frac{1}{\\sqrt{\\pi}} \\int_{-\\infty}^{\\infty} g(\\mu + \\sqrt{2}\\sigma x) e^{-x^2} dx \\approx \\frac{1}{\\sqrt{\\pi}} \\sum_{j=1}^{N_q} w_j g(\\mu + \\sqrt{2}\\sigma x_j)\n$$\nwhere $(x_j, w_j)$ are the standard Gaussian-Hermite quadrature nodes and weights.\n\n- **Naive Single-Normal Scheme:** The bimodal mixture distribution of $s'$ is approximated by a single normal distribution $\\mathcal{N}(\\mu_{\\text{mix}}, \\sigma_{\\text{mix}}^2)$ with matching mean and variance.\n    - $\\mu_{\\text{mix}} = p\\mu_1 + (1-p)\\mu_2$\n    - $\\sigma_{\\text{mix}}^2 = [p\\sigma_1^2 + (1-p)\\sigma_2^2] + p(1-p)(\\mu_1-\\mu_2)^2$\n    The expectation is then computed using the formula above with parameters $(\\mu_{\\text{mix}}, \\sigma_{\\text{mix}})$.\n\n- **Mixture-Correct Scheme:** The expectation is computed directly using the definition of the mixture distribution:\n    $$\n    \\mathbb{E}[g(s')] = p \\cdot \\mathbb{E}_{\\mathcal{N}(\\mu_1,\\sigma_1^2)}[g(s')] + (1-p) \\cdot \\mathbb{E}_{\\mathcal{N}(\\mu_2,\\sigma_2^2)}[g(s')]\n    $$\n    Each of the two expectation terms on the right is evaluated using its own Gaussian-Hermite quadrature, one centered at $\\mu_1$ with scale $\\sigma_1$, and the other at $\\mu_2$ with scale $\\sigma_2$.\n\n**5. Validation**\n\nWe obtain two sets of coefficients: $\\theta_{\\text{naive}}$ by solving with the naive quadrature, and $\\theta_{\\text{mix}}$ by solving with the mixture-correct quadrature. The quality of these solutions is assessed by evaluating the supremum norm of the Euler residual on a finer validation grid ($N_k^{\\text{val}}=13 \\times N_s^{\\text{val}}=9$). Crucially, for both policies, this validation residual is computed using the accurate **mixture-correct quadrature**. This procedure isolates the error introduced by the naive approximation during the solution phase. The quantities to be reported are:\n- $r_{\\text{mix}}$: sup-norm of the residual for the policy $\\phi(k,s;\\theta_{\\text{mix}})$, which serves as our benchmark.\n- $r_{\\text{naive}\\to\\text{true}}$: sup-norm of the residual for the policy $\\phi(k,s;\\theta_{\\text{naive}})$, showing the error of the naive policy when evaluated correctly.\n- $\\Delta r = r_{\\text{naive}\\to\\text{true}} - r_{\\text{mix}}$: the excess error attributable to the naive approximation method.\n\nThis rigorous process allows for a quantitative comparison of the two quadrature schemes for handling mixture distributions in this class of models.", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import least_squares\nfrom scipy.special import expit, logit\nfrom numpy.polynomial import chebyshev, hermite\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases and print the results.\n    \"\"\"\n    # Fixed structural parameters\n    alpha = 0.33\n    beta = 0.96\n    delta = 0.08\n    gamma = 2.0\n\n    # Numerical approximation parameters\n    d_k = 3\n    d_s = 2\n    N_k = 7\n    N_s = 5\n    N_q = 7\n    N_k_val = 13\n    N_s_val = 9\n\n    test_cases = [\n        # Case A: balanced bimodality\n        {'p': 0.5, 'mu1': -0.1, 'sigma1': 0.05, 'mu2': 0.1, 'sigma2': 0.05},\n        # Case B: asymmetric and more separated\n        {'p': 0.7, 'mu1': -0.2, 'sigma1': 0.08, 'mu2': 0.2, 'sigma2': 0.08},\n        # Case C: degenerate to unimodal\n        {'p': 0.4, 'mu1': 0.0, 'sigma1': 0.07, 'mu2': 0.0, 'sigma2': 0.07},\n    ]\n\n    all_results = []\n    for case_params in test_cases:\n        params = {\n            'alpha': alpha, 'beta': beta, 'delta': delta, 'gamma': gamma,\n            **case_params\n        }\n        \n        # Unpack degrees and grid sizes\n        degrees = (d_k, d_s)\n        collocation_grid_sizes = (N_k, N_s)\n        validation_grid_sizes = (N_k_val, N_s_val)\n\n        r_mix, r_naive_to_true, delta_r = solve_case(\n            params, degrees, collocation_grid_sizes, validation_grid_sizes, N_q\n        )\n        all_results.extend([r_mix, r_naive_to_true, delta_r])\n\n    print(f\"[{','.join(map(str, all_results))}]\")\n\ndef solve_case(params, degrees, collocation_grid_sizes, validation_grid_sizes, N_q):\n    \"\"\"\n    Solves for and validates policies for a single parameter case.\n    \"\"\"\n    # 1. State-space domain\n    k_domain, s_domain = calculate_domains(params)\n\n    # 2. Quadrature nodes and weights for expectation\n    # hermgauss returns nodes/weights for integral with weight e^(-x^2)\n    q_nodes, q_weights = hermite.hermgauss(N_q)\n    q_weights /= np.sqrt(np.pi)  # Adjust for standard normal probability measure\n    \n    # 3. Collocation grid\n    collocation_grid = create_chebyshev_grid(collocation_grid_sizes, k_domain, s_domain)\n\n    # 4. Initial guess for theta (based on deterministic steady state)\n    theta0 = get_initial_theta(params, degrees, k_domain)\n\n    # Arguments for the solver\n    solver_args = (params, degrees, k_domain, s_domain, collocation_grid, q_nodes, q_weights)\n\n    # 5. Solve for theta_mix\n    res_mix = least_squares(\n        euler_residuals, theta0, args=(*solver_args, 'mixture_correct'),\n        method='lm', jac='2-point'\n    )\n    theta_mix = res_mix.x\n\n    # 6. Solve for theta_naive\n    res_naive = least_squares(\n        euler_residuals, theta0, args=(*solver_args, 'naive'),\n        method='lm', jac='2-point'\n    )\n    theta_naive = res_naive.x\n\n    # 7. Validation\n    validation_grid = create_chebyshev_grid(validation_grid_sizes, k_domain, s_domain)\n    val_args = (params, degrees, k_domain, s_domain, validation_grid, q_nodes, q_weights)\n\n    # Evaluate mixture-correct policy with mixture-correct quadrature\n    residuals_mix = euler_residuals(theta_mix, *val_args, 'mixture_correct')\n    r_mix = np.max(np.abs(residuals_mix))\n\n    # Evaluate naive policy with mixture-correct quadrature\n    residuals_naive_true = euler_residuals(theta_naive, *val_args, 'mixture_correct')\n    r_naive_to_true = np.max(np.abs(residuals_naive_true))\n\n    delta_r = r_naive_to_true - r_mix\n\n    return r_mix, r_naive_to_true, delta_r\n\ndef calculate_domains(params):\n    \"\"\"Calculates the state-space domains for k and s.\"\"\"\n    p, mu1, s1, mu2, s2 = params['p'], params['mu1'], params['sigma1'], params['mu2'], params['sigma2']\n    alpha, beta, delta = params['alpha'], params['beta'], params['delta']\n    \n    # Unconditional mean of productivity z = exp(s)\n    expected_z = p * np.exp(mu1 + s1**2 / 2) + (1 - p) * np.exp(mu2 + s2**2 / 2)\n    \n    # Deterministic steady-state capital k_star\n    k_star = ((alpha * expected_z) / (1 / beta - 1 + delta))**(1 / (1 - alpha))\n    k_domain = [0.75 * k_star, 1.25 * k_star]\n    \n    # Domain for s\n    s_min = min(mu1 - 3 * s1, mu2 - 3 * s2)\n    s_max = max(mu1 + 3 * s1, mu2 + 3 * s2)\n    s_domain = [s_min, s_max]\n    \n    return k_domain, s_domain\n\ndef get_initial_theta(params, degrees, k_domain):\n    \"\"\"Computes an informed initial guess for theta.\"\"\"\n    p, mu1, s1, mu2, s2 = params['p'], params['mu1'], params['sigma1'], params['mu2'], params['sigma2']\n    alpha, beta, delta = params['alpha'], params['beta'], params['delta']\n    \n    expected_z = p * np.exp(mu1 + s1**2 / 2) + (1 - p) * np.exp(mu2 + s2**2 / 2)\n    k_star = ((alpha * expected_z) / (1 / beta - 1 + delta))**(1 / (1 - alpha))\n    y_star = expected_z * k_star**alpha\n    phi_star = k_star / (y_star + (1 - delta) * k_star)\n    \n    d_k, d_s = degrees\n    num_coeffs = (d_k + 1) * (d_s + 1)\n    theta0 = np.zeros(num_coeffs)\n    theta0[0] = logit(phi_star)\n    return theta0\n\ndef cheb_transform(x, domain):\n    \"\"\"Maps points from a domain to [-1, 1].\"\"\"\n    return 2 * (x - domain[0]) / (domain[1] - domain[0]) - 1\n\ndef cheb_basis_tensor(k_hat, s_hat, degrees):\n    \"\"\"Computes a tensor product Chebyshev basis matrix.\"\"\"\n    d_k, d_s = degrees\n    basis_k = chebyshev.chebvander(k_hat, d_k)\n    basis_s = chebyshev.chebvander(s_hat, d_s)\n    # Reshape for broadcasting and then combine\n    # B[i, j, :] is the basis vector for grid point (i, j)\n    B = basis_k[:, np.newaxis, :] * basis_s[np.newaxis, :, :]\n    # Reshape B to be (Nk * Ns, N_coeffs)\n    return B.reshape(-1, (d_k + 1) * (d_s + 1))\n\n\ndef create_chebyshev_grid(grid_sizes, k_domain, s_domain):\n    \"\"\"Creates a tensor product grid of Chebyshev nodes.\"\"\"\n    N_k, N_s = grid_sizes\n    # Use chebpts1 for nodes including endpoints - common in collocation\n    k_nodes_hat = chebyshev.chebpts1(N_k) # in [-1, 1]\n    s_nodes_hat = chebyshev.chebpts1(N_s) # in [-1, 1]\n    \n    k_grid = (k_nodes_hat + 1) / 2 * (k_domain[1] - k_domain[0]) + k_domain[0]\n    s_grid = (s_nodes_hat + 1) / 2 * (s_domain[1] - s_domain[0]) + s_domain[0]\n    \n    return k_grid, s_grid\n\ndef get_policy(k, s, theta, params, degrees, k_domain, s_domain):\n    \"\"\"Computes policy (phi), consumption (c), and next-period capital (k_prime).\"\"\"\n    k_hat = cheb_transform(k, k_domain)\n    s_hat = cheb_transform(s, s_domain)\n    \n    d_k, d_s = degrees\n    basis_k = chebyshev.chebvander(k_hat.flatten(), d_k)\n    basis_s = chebyshev.chebvander(s_hat.flatten(), d_s)\n    \n    # Manual tensor product broadcasting\n    flat_basis_tensor = (basis_k[:, :, np.newaxis] * basis_s[:, np.newaxis, :]).reshape(len(k.flatten()), -1)\n    \n    # Savings rate\n    phi = expit(flat_basis_tensor @ theta).reshape(k.shape)\n\n    z = np.exp(s)\n    resources = z * k**params['alpha'] + (1 - params['delta']) * k\n    \n    c = (1 - phi) * resources\n    k_prime = phi * resources\n    \n    return c, k_prime\n\ndef euler_residuals(theta, params, degrees, k_domain, s_domain, grid, q_nodes, q_weights, quadrature_scheme):\n    \"\"\"\n    Computes the Euler equation residuals over a grid.\n    Vectorized for efficiency.\n    \"\"\"\n    k_grid, s_grid = grid\n    K, S = np.meshgrid(k_grid, s_grid, indexing='ij')\n\n    alpha, beta, delta, gamma = params['alpha'], params['beta'], params['delta'], params['gamma']\n\n    # Current period values\n    c_t, k_prime = get_policy(K, S, theta, params, degrees, k_domain, s_domain)\n    marginal_utility_t = c_t**(-gamma)\n\n    # Expected future values\n    def get_integrand(s_prime_nodes):\n        # s_prime_nodes is a vector of quadrature points for s'\n        # k_prime is an Nk x Ns matrix\n        # Need to evaluate policy at all (k_prime, s_prime) pairs\n        num_q_nodes = len(s_prime_nodes)\n        \n        # Reshape for broadcasting\n        k_prime_flat = k_prime.flatten() # (Nk*Ns)\n        k_prime_rep = np.tile(k_prime_flat, (num_q_nodes, 1)).T # (Nk*Ns, Nq)\n        s_prime_rep = np.tile(s_prime_nodes, (len(k_prime_flat), 1)) # (Nk*Ns, Nq)\n        \n        c_prime, _ = get_policy(k_prime_rep, s_prime_rep, theta, params, degrees, k_domain, s_domain)\n        \n        marginal_utility_prime = c_prime**(-gamma)\n        \n        mpk_prime = alpha * np.exp(s_prime_rep) * k_prime_rep**(alpha - 1) + (1 - delta)\n        \n        return (marginal_utility_prime * mpk_prime).reshape(K.shape[0], K.shape[1], -1)\n\n    if quadrature_scheme == 'mixture_correct':\n        p, mu1, s1, mu2, s2 = params['p'], params['mu1'], params['sigma1'], params['mu2'], params['sigma2']\n        \n        s_prime_nodes1 = mu1 + np.sqrt(2) * s1 * q_nodes\n        integrand1 = get_integrand(s_prime_nodes1)\n        E1 = np.sum(integrand1 * q_weights, axis=2)\n        \n        s_prime_nodes2 = mu2 + np.sqrt(2) * s2 * q_nodes\n        integrand2 = get_integrand(s_prime_nodes2)\n        E2 = np.sum(integrand2 * q_weights, axis=2)\n        \n        E_term = p * E1 + (1 - p) * E2\n        \n    elif quadrature_scheme == 'naive':\n        p, mu1, s1, mu2, s2 = params['p'], params['mu1'], params['sigma1'], params['mu2'], params['sigma2']\n        mu_mix = p * mu1 + (1 - p) * mu2\n        var_mix = p * s1**2 + (1 - p) * s2**2 + p * (1 - p) * (mu1 - mu2)**2\n        s_mix = np.sqrt(var_mix)\n        \n        s_prime_nodes_mix = mu_mix + np.sqrt(2) * s_mix * q_nodes\n        integrand_mix = get_integrand(s_prime_nodes_mix)\n        E_term = np.sum(integrand_mix * q_weights, axis=2)\n\n    else:\n        raise ValueError(\"Invalid quadrature scheme.\")\n\n    residuals = marginal_utility_t - beta * E_term\n    return residuals.flatten()\n\n\nif __name__ == '__main__':\n    solve()\n\n```"}]}