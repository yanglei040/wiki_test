{"hands_on_practices": [{"introduction": "To begin our exploration of financial contagion, we start with a foundational linear model. This exercise demonstrates how an initial financial shock can propagate through an interbank network over time, much like ripples spreading on a pond. By simulating the shock's journey using simple matrix operations, you will gain hands-on experience with a core mechanism of contagion and see how the total impact can be quantified [@problem_id:2432984]. This practice is key to understanding the direct transmission of risk in a simplified yet powerful framework.", "id": "2432984", "problem": "Consider an interbank lending network with $n$ banks, represented by a directed weighted adjacency matrix $A \\in \\mathbb{R}^{n \\times n}$, where $A_{ij}$ is the fraction of a shock at bank $i$ that is transmitted to bank $j$ in one iteration. By construction, for each row $i$, $\\sum_{j=1}^{n} A_{ij} \\leq 1$. Let $s_t \\in \\mathbb{R}^n$ denote the nonnegative shock intensity vector at discrete time $t \\in \\mathbb{N}_0$. The shock propagation is defined by the linear recurrence\n$$\ns_{t+1} = A^{\\top} s_t,\n$$\nwith a given initial condition $s_0 \\in \\mathbb{R}^n_{\\ge 0}$. For a given nonnegative threshold $\\theta \\in \\mathbb{R}_{\\ge 0}$, define the number of distressed banks at time $T$ as the count of indices $i \\in \\{1,\\dots,n\\}$ such that $s_{T,i} \\ge \\theta$. Define the total shock mass at time $T$ as the $1$-norm $\\lVert s_T \\rVert_1 = \\sum_{i=1}^n |s_{T,i}|$.\n\nYour task is to compute, for each test case specified below, the pair consisting of:\n- the total shock mass $\\lVert s_T \\rVert_1$, rounded to $6$ decimal places using standard rounding, and\n- the integer number of distressed banks at time $T$ under the criterion $s_{T,i} \\ge \\theta$.\n\nAll quantities are unitless. There are no angles or percentages involved.\n\nTest suite:\n- Test case $1$:\n  - $n = 6$.\n  - Nonzero entries of $A$ are given by the list of triples $(i,j,w)$ meaning $A_{ij} = w$:\n    $$(0,1,0.5),\\ (0,2,0.3),\\ (1,2,0.4),\\ (1,3,0.4),\\ (2,3,0.6),\\ (3,4,0.5),\\ (4,5,0.3).$$\n  - Initial shock $s_0 = [1,0,0,0,0,0]$.\n  - Horizon $T = 4$.\n  - Threshold $\\theta = 0.15$.\n- Test case $2$:\n  - $n = 4$.\n  - Nonzero entries of $A$:\n    $$(0,1,1.0),\\ (1,2,1.0),\\ (2,3,1.0).$$\n  - Initial shock $s_0 = [0,0,1,0]$.\n  - Horizon $T = 0$.\n  - Threshold $\\theta = 0.5$.\n- Test case $3$:\n  - $n = 3$.\n  - $A$ has no nonzero entries.\n  - Initial shock $s_0 = [0,0.8,0]$.\n  - Horizon $T = 3$.\n  - Threshold $\\theta = 0.1$.\n- Test case $4$:\n  - $n = 5$.\n  - Nonzero entries of $A$:\n    $$(0,1,1.0),\\ (1,2,1.0),\\ (2,3,1.0),\\ (3,4,1.0),\\ (4,0,1.0).$$\n  - Initial shock $s_0 = [1,0,0,0,0]$.\n  - Horizon $T = 5$.\n  - Threshold $\\theta = 0.4$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case result is itself a two-element list $[\\lVert s_T \\rVert_1,\\ \\text{count}]$. For example, a valid output formatting for four test cases is\n$$\n[[x_1,c_1],[x_2,c_2],[x_3,c_3],[x_4,c_4]]\n$$\nwith each $x_k$ a float rounded to $6$ decimal places and each $c_k$ an integer.", "solution": "The problem statement has been validated and is deemed valid. It is scientifically grounded, well-posed, objective, and complete. It describes a standard discrete-time linear dynamical system used for modeling network propagation phenomena, such as financial contagion. All parameters for the test cases are provided and are consistent.\n\nThe problem requires the analysis of a shock propagation model in a network of $n$ banks. The dynamics are governed by the linear recurrence relation:\n$$ s_{t+1} = A^{\\top} s_t $$\nwhere $s_t \\in \\mathbb{R}^n$ is the vector of shock intensities at time $t \\in \\mathbb{N}_0$, and $A \\in \\mathbb{R}^{n \\times n}$ is the weighted adjacency matrix of the network. The entry $A_{ij}$ represents the fraction of a shock transmitted from bank $i$ to bank $j$. The condition $\\sum_{j=1}^{n} A_{ij} \\leq 1$ for each row $i$ ensures that the total shock propagated by any bank does not exceed the shock it has received, guaranteeing that the total shock mass in the system, $\\lVert s_t \\rVert_1$, is non-increasing.\n\nGiven an initial shock vector $s_0$, the state of the system at any future time $T \\in \\mathbb{N}_0$ is determined by recursively applying the propagation rule. The solution at time $T$ is given by:\n$$ s_T = (A^{\\top})^T s_0 $$\nThis can be computed algorithmically by initializing a vector $s$ to $s_0$ and iteratively updating it through $T$ matrix-vector multiplications: $s \\leftarrow A^{\\top} s$.\n\nThe interbank network is specified by a list of nonzero entries of $A$, which implies that for any realistically sized network ($n$ large), the matrix $A$ is sparse. To handle this efficiently, one must employ sparse matrix data structures and algorithms. The provided triples $(i,j,w)$ naturally define the matrix in a Coordinate (COO) format. For efficient repeated matrix-vector multiplications, this matrix is best converted to a format such as Compressed Sparse Row (CSR) or Compressed Sparse Column (CSC). The transpose operation $A^{\\top}$ is computationally inexpensive for sparse matrices.\n\nThe algorithm to solve this problem for each test case is as follows:\n\n$1$. **Matrix Construction**: The matrix $A$ is constructed from the given list of triples $(i,j,w)$, where $A_{ij} = w$. We use a sparse matrix representation, for instance, from the `scipy.sparse` library. Given the $0$-based indexing in the test cases, we build an $n \\times n$ sparse matrix.\n\n$2$. **Iterative Shock Propagation**: We initialize the shock vector $s$ with the given $s_0$. Then, we simulate the propagation over $T$ time steps. For each step $t$ from $0$ to $T-1$, we update the shock vector by computing $s_{t+1} = A^{\\top} s_t$. If $T=0$, the final shock vector is simply $s_0$.\n\n$3$. **Calculation of Metrics**: After $T$ iterations, we obtain the final shock vector $s_T$. From this vector, we compute two quantities:\n    - The total shock mass, which is the $L_1$-norm of $s_T$, $\\lVert s_T \\rVert_1 = \\sum_{i=1}^{n} |s_{T,i}|$. Since the initial shock $s_0$ is non-negative and all entries of $A$ are non-negative, all subsequent shock vectors $s_t$ will be non-negative. Thus, the norm is simply the sum of the vector's components, $\\sum_{i=1}^{n} s_{T,i}$. This value is then rounded to $6$ decimal places.\n    - The number of distressed banks, which is the count of indices $i$ such that the shock intensity $s_{T,i}$ meets or exceeds a given threshold $\\theta$, i.e., $|\\{i \\in \\{1,\\dots,n\\} \\mid s_{T,i} \\ge \\theta\\}|$.\n\n$4$. **Output Formatting**: For each test case, the computed pair of values—the rounded total shock mass and the integer count of distressed banks—is formatted into a list, and the results from all test cases are aggregated into a list of lists as required.", "answer": "```python\nimport numpy as np\nfrom scipy.sparse import coo_matrix\n\ndef solve():\n    \"\"\"\n    Solves the shock propagation problem for a suite of test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"n\": 6,\n            \"A_triples\": [(0, 1, 0.5), (0, 2, 0.3), (1, 2, 0.4), (1, 3, 0.4), (2, 3, 0.6), (3, 4, 0.5), (4, 5, 0.3)],\n            \"s0\": [1, 0, 0, 0, 0, 0],\n            \"T\": 4,\n            \"theta\": 0.15,\n        },\n        {\n            \"n\": 4,\n            \"A_triples\": [(0, 1, 1.0), (1, 2, 1.0), (2, 3, 1.0)],\n            \"s0\": [0, 0, 1, 0],\n            \"T\": 0,\n            \"theta\": 0.5,\n        },\n        {\n            \"n\": 3,\n            \"A_triples\": [],\n            \"s0\": [0, 0.8, 0],\n            \"T\": 3,\n            \"theta\": 0.1,\n        },\n        {\n            \"n\": 5,\n            \"A_triples\": [(0, 1, 1.0), (1, 2, 1.0), (2, 3, 1.0), (3, 4, 1.0), (4, 0, 1.0)],\n            \"s0\": [1, 0, 0, 0, 0],\n            \"T\": 5,\n            \"theta\": 0.4,\n        }\n    ]\n\n    results_str_list = []\n    for case in test_cases:\n        n = case[\"n\"]\n        A_triples = case[\"A_triples\"]\n        s0 = case[\"s0\"]\n        T = case[\"T\"]\n        theta = case[\"theta\"]\n\n        # 1. Construct the sparse matrix A and its transpose A_T.\n        if not A_triples:\n            # If there are no non-zero entries, A is the zero matrix.\n            A = coo_matrix((n, n), dtype=float)\n        else:\n            rows, cols, data = zip(*A_triples)\n            A = coo_matrix((data, (rows, cols)), shape=(n, n), dtype=float)\n        \n        # Using CSC format for A.T is efficient for matrix-vector products.\n        A_T = A.T.tocsc()\n\n        # 2. Iteratively compute the shock propagation.\n        s = np.array(s0, dtype=float)\n        for _ in range(T):\n            s = A_T @ s\n        \n        s_T = s\n\n        # 3. Calculate total shock mass and the number of distressed banks.\n        # Since s0 >= 0 and A >= 0, s_T will be non-negative.\n        total_mass = np.sum(s_T)\n        distressed_count = np.sum(s_T >= theta)\n        \n        # 4. Format the result for the current test case.\n        # \"standard rounding\" is taken to be Python's built-in round.\n        rounded_mass = round(total_mass, 6)\n        \n        # Format the float to a string with 6 decimal places.\n        mass_str = f'{rounded_mass:.6f}'\n        \n        result_str = f'[{mass_str},{distressed_count}]'\n        results_str_list.append(result_str)\n\n    # 5. Print the final results in the required format.\n    print(f\"[{','.join(results_str_list)}]\")\n\nsolve()\n```"}, {"introduction": "Building on the idea of propagation, we now explore contagion as a cascade of failures using a threshold model, a concept borrowed from percolation theory. In this scenario, a bank's survival depends on the health of its neighbors; it fails if too many of its connected counterparties collapse. This exercise allows you to simulate these \"domino effects\" and discover how network topology can either contain a shock or amplify it into a full-blown systemic crisis [@problem_id:2426234]. Understanding these non-linear dynamics is crucial for grasping why small initial failures can sometimes have unexpectedly large consequences.", "id": "2426234", "problem": "Consider a contagion process on a finite, simple, undirected graph, motivated by percolation theory applied to financial networks. Let the graph be denoted by $G = (V,E)$ with $|V| = N$. Each vertex represents a bank, and each undirected edge represents a bilateral exposure. A bank is either solvent (active) or failed (inactive). The contagion evolves in discrete time steps according to a synchronous threshold rule (a form of bootstrap percolation): a solvent vertex fails at the next time step if at least a critical number $T$ of its neighbors are failed at the current time step; failed vertices remain failed forever. The dynamics starts from a specified initial failed set $S_0 \\subseteq V$.\n\nFundamental base and definitions:\n- A state is a function $x: V \\to \\{0,1\\}$ with $x(i) = 1$ if vertex $i$ is failed and $x(i) = 0$ otherwise.\n- The neighborhood of $i \\in V$ is $N(i) = \\{j \\in V : (i,j) \\in E\\}$.\n- Given threshold $T \\in \\mathbb{Z}$, the synchronous update rule is: for each $i \\in V$,\n$$\nx_{t+1}(i) = \\begin{cases}\n1, & \\text{if } x_t(i) = 1 \\text{ or } \\sum_{j \\in N(i)} x_t(j) \\ge T, \\\\\n0, & \\text{otherwise.}\n\\end{cases}\n$$\n- The process halts at the first time $t^\\star$ for which $x_{t^\\star+1} = x_{t^\\star}$, and the final failed set is $S_\\infty = \\{ i \\in V : x_{t^\\star}(i) = 1 \\}$. The final failed fraction is $|S_\\infty|/N$.\n\nTask:\n- Implement a program that, for each specified test case (graph $G$, threshold $T$, and initial failed set $S_0$), computes the final failed fraction $|S_\\infty|/N$ under the synchronous threshold dynamics defined above. There is no randomness in any test case. Use only the stated rule and halt when a fixed point is reached.\n\nAlgorithmic requirements:\n- Use synchronous updates: all vertices evaluate their failure condition against the state at time $t$ and update simultaneously to produce the state at time $t+1$.\n- The graph is simple and undirected; do not include self-loops or parallel edges.\n- The initial state $x_0$ is defined by $S_0$: for $i \\in S_0$, $x_0(i)=1$, otherwise $x_0(i)=0$.\n- Thresholds are integers. If $T \\le 0$, then all vertices fail at $t=1$. If $T$ is larger than the degree of a vertex, that vertex cannot fail unless it is in $S_0$.\n\nTest suite:\nCompute the final failed fraction $|S_\\infty|/N$ (rounded to $6$ decimal places) for each of the following $6$ cases. In all cases, vertices are labeled by consecutive integers starting at $0$.\n\n- Case $1$ (path graph cascade):\n  - Graph: path on $N=5$ vertices with edges $\\{(0,1),(1,2),(2,3),(3,4)\\}$.\n  - Threshold: $T=1$.\n  - Initial failed set: $S_0=\\{0\\}$.\n\n- Case $2$ (path graph blocked by higher threshold):\n  - Graph: path on $N=5$ vertices with edges $\\{(0,1),(1,2),(2,3),(3,4)\\}$.\n  - Threshold: $T=2$.\n  - Initial failed set: $S_0=\\{2\\}$.\n\n- Case $3$ (star graph with center at $0$):\n  - Graph: star on $N=6$ vertices with edges $\\{(0,1),(0,2),(0,3),(0,4),(0,5)\\}$.\n  - Threshold: $T=3$.\n  - Initial failed set: $S_0=\\{1,2,3\\}$.\n\n- Case $4$ (grid graph with $4$-neighbor connectivity):\n  - Graph: $3\\times 3$ square grid ($N=9$) with $4$-neighbor adjacency. Use row-major indexing: vertex $(r,c)$ (row $r \\in \\{0,1,2\\}$, column $c \\in \\{0,1,2\\}$) maps to index $i = 3r + c$. Two vertices are adjacent if and only if they are unit distance apart in either the same row or the same column.\n  - Threshold: $T=2$.\n  - Initial failed set: $S_0=\\{1,3\\}$.\n\n- Case $5$ (triangle with zero threshold):\n  - Graph: ring on $N=3$ vertices (a triangle) with edges $\\{(0,1),(1,2),(2,0)\\}$.\n  - Threshold: $T=0$.\n  - Initial failed set: $S_0=\\emptyset$.\n\n- Case $6$ (ring with high threshold):\n  - Graph: ring on $N=4$ vertices with edges $\\{(0,1),(1,2),(2,3),(3,0)\\}$.\n  - Threshold: $T=3$.\n  - Initial failed set: $S_0=\\{0,1,2\\}$.\n\nOutput specification:\n- For each test case, compute the final failed fraction $|S_\\infty|/N$ as a floating-point number rounded to $6$ decimal places.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets in the order of Cases $1$ through $6$, for example, $[x_1,x_2,x_3,x_4,x_5,x_6]$ where each $x_k$ is the rounded value for Case $k$.\n- Do not read any input. Embed the test suite in the program. The output must be exactly one line in the specified format.\n\nNo physical units are involved. Angles are not involved. Express all fractions as decimals rounded to $6$ places as specified.", "solution": "The problem posed is a well-defined computational exercise in the field of network dynamics, specifically modeling a contagion process via bootstrap percolation on a graph. Before proceeding to a solution, a rigorous validation is necessary.\n\nFirst, all givens are extracted from the problem statement.\nThe model is a contagion process on a finite, simple, undirected graph $G=(V, E)$ with $|V| = N$ vertices. A vertex $i \\in V$ is in one of two states: solvent ($x(i)=0$) or failed ($x(i)=1$). The dynamics evolve in discrete time steps $t$ according to a synchronous threshold rule. A solvent vertex $i$ fails at time $t+1$ if the number of its failed neighbors at time $t$, $\\sum_{j \\in N(i)} x_t(j)$, is greater than or equal to a threshold $T$. Failed vertices remain failed. The process begins with an initial set of failed vertices $S_0$ and terminates when a fixed point is reached, yielding a final failed set $S_\\infty$. The objective is to compute the final failed fraction $|S_\\infty|/N$. Six specific test cases, each defined by a graph, a threshold $T$, and an initial set $S_0$, are provided.\n\nNext, the problem is validated against the required criteria.\n1.  **Scientifically Grounded:** The model is a standard deterministic threshold model, a fundamental concept in the study of complex networks, cellular automata, and statistical physics. It is mathematically sound and based on established principles. The problem is free of pseudoscience or speculation.\n2.  **Well-Posed:** The problem is well-posed. The state space is finite, containing $2^N$ possible configurations. The dynamics are monotonic because a vertex, once failed, never reverts to a solvent state. This ensures that the system must reach a unique fixed point in at most $N$ time steps from any initial condition.\n3.  **Objective:** The problem is stated in precise, unambiguous mathematical language. All terms like \"synchronous update,\" \"neighborhood,\" and \"threshold\" are clearly defined.\n4.  **Completeness and Consistency:** Each test case is fully specified with all necessary data: the number of vertices $N$, the set of edges $E$, the integer threshold $T$, and the initial failed set $S_0$. The rules are internally consistent.\n5.  **Feasibility:** The graphs in the test suite are small, making the simulation computationally trivial and readily solvable.\n\nThe verdict is that the problem is **valid**. It is a clear, self-contained, and solvable computational task. The solution can now be constructed.\n\nThe core of the solution is an algorithm that simulates the synchronous dynamics. The state of the system is represented by a binary vector $\\mathbf{x} \\in \\{0, 1\\}^N$. The graph topology is encoded in an adjacency matrix $A$, an $N \\times N$ matrix where $A_{ij}=1$ if an edge exists between vertices $i$ and $j$, and $A_{ij}=0$ otherwise.\n\nThe simulation algorithm proceeds as follows:\n1.  **Initialization**: The state vector at time $t=0$, denoted $\\mathbf{x}_0$, is initialized according to the given set $S_0$. For each vertex $i \\in V$, $x_0(i) = 1$ if $i \\in S_0$, and $x_0(i) = 0$ otherwise.\n\n2.  **Iteration**: The system state is updated iteratively until a fixed point is reached. At each time step $t$, the state $\\mathbf{x}_{t+1}$ is computed from $\\mathbf{x}_t$.\n    a. First, the number of failed neighbors for every vertex must be counted. This can be achieved efficiently for all vertices at once through a matrix-vector multiplication. Let $\\mathbf{c}_t$ be the vector of failed neighbor counts at time $t$. Then,\n    $$\n    \\mathbf{c}_t = A \\cdot \\mathbf{x}_t\n    $$\n    The $i$-th component of $\\mathbf{c}_t$, denoted $c_t(i)$, is precisely $\\sum_{j \\in N(i)} x_t(j)$.\n\n    b. According to the synchronous update rule, the state vector $\\mathbf{x}_{t+1}$ is determined by considering only the state at time $t$. A vertex $i$ will be failed in the next step if it was already failed at time $t$, or if it was solvent and the number of its failed neighbors met the threshold. This can be expressed for each vertex $i$:\n    $$\n    x_{t+1}(i) = 1 \\quad \\text{if} \\quad (x_t(i) = 1) \\lor (x_t(i)=0 \\land c_t(i) \\ge T)\n    $$\n    Equivalently, one can identify the set of all solvent vertices $\\{ i \\mid x_t(i)=0 \\}$ and, among these, find the subset of vertices for which $c_t(i) \\ge T$. These are the vertices that will newly fail.\n\n    c. The new state vector $\\mathbf{x}_{t+1}$ is formed by setting the corresponding components for these newly failed vertices to $1$.\n\n3.  **Termination**: The iterative process continues until the state no longer changes, i.e., when $\\mathbf{x}_{t+1} = \\mathbf{x}_t$. At this point, the system has reached a stable fixed point, $\\mathbf{x}_\\infty = \\mathbf{x}_t$.\n\n4.  **Final Calculation**: Upon termination, the final number of failed vertices is $|S_\\infty| = \\sum_{i=0}^{N-1} x_\\infty(i)$. The required final failed fraction is this sum divided by the total number of vertices $N$.\n\nThis algorithm is implemented and applied to each of the six test cases. For each case, the graph structure is used to build the adjacency matrix $A$, and the initial state vector $\\mathbf{x}_0$ is constructed from $S_0$. The simulation loop runs until convergence, and the final fraction is calculated and rounded to $6$ decimal places as specified.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(N, edges, T, S0):\n    \"\"\"\n    Simulates the synchronous threshold contagion process on a graph.\n\n    Args:\n        N (int): The number of vertices in the graph.\n        edges (list of tuples): The list of edges defining the graph.\n        T (int): The failure threshold.\n        S0 (set): The set of initially failed vertices.\n\n    Returns:\n        float: The final fraction of failed vertices.\n    \"\"\"\n    # 1. Build the adjacency matrix from the edge list.\n    adj_matrix = np.zeros((N, N), dtype=int)\n    for u, v in edges:\n        adj_matrix[u, v] = 1\n        adj_matrix[v, u] = 1\n\n    # 2. Initialize the state vector based on the initial failed set S0.\n    x = np.zeros(N, dtype=int)\n    if S0:\n        # The set S0 might be empty.\n        initial_indices = list(S0)\n        x[initial_indices] = 1\n\n    # 3. Run the simulation loop until a fixed point is reached.\n    while True:\n        # Store the current state to check for convergence later.\n        x_old = x.copy()\n        \n        # Calculate the number of failed neighbors for each vertex using a\n        # matrix-vector product. This is the core of the state evaluation.\n        failed_neighbors_count = adj_matrix @ x_old\n\n        # Identify solvent vertices that are to fail in this step.\n        # A vertex `i` fails if it is currently solvent (x_old[i] == 0) and\n        # its number of failed neighbors meets the threshold (failed_neighbors_count[i] >= T).\n        # This is a vectorized implementation of the synchronous update rule.\n        solvent_mask = (x_old == 0)\n        threshold_met_mask = (failed_neighbors_count >= T)\n        \n        # The new failures occur where both conditions are true.\n        newly_failed_mask = solvent_mask & threshold_met_mask\n        \n        # If there are no new failures, the system has reached a fixed point.\n        if not np.any(newly_failed_mask):\n            break\n            \n        # Update the state vector by setting the newly failed vertices to 1.\n        x[newly_failed_mask] = 1\n\n    # 4. Calculate the final failed fraction.\n    final_failed_count = np.sum(x)\n    return final_failed_count / N\n\ndef solve():\n    \"\"\"\n    Defines and runs the test suite for the contagion model.\n    \"\"\"\n    # Define the 6 test cases as specified in the problem statement.\n    # Each case is a tuple: (N, edges, T, S0)\n    \n    # Case 1: Path graph cascade\n    case1 = (5, [(0, 1), (1, 2), (2, 3), (3, 4)], 1, {0})\n    \n    # Case 2: Path graph blocked\n    case2 = (5, [(0, 1), (1, 2), (2, 3), (3, 4)], 2, {2})\n    \n    # Case 3: Star graph\n    case3 = (6, [(0, 1), (0, 2), (0, 3), (0, 4), (0, 5)], 3, {1, 2, 3})\n    \n    # Case 4: 3x3 grid graph\n    grid_edges = []\n    rows, cols = 3, 3\n    for r in range(rows):\n        for c in range(cols):\n            i = r * cols + c\n            # Horizontal connection to the right\n            if c < cols - 1:\n                grid_edges.append((i, i + 1))\n            # Vertical connection downwards\n            if r < rows - 1:\n                grid_edges.append((i, i + cols))\n    case4 = (9, grid_edges, 2, {1, 3})\n    \n    # Case 5: Triangle with zero threshold\n    case5 = (3, [(0, 1), (1, 2), (2, 0)], 0, set())\n    \n    # Case 6: Ring with high threshold\n    case6 = (4, [(0, 1), (1, 2), (2, 3), (3, 0)], 3, {0, 1, 2})\n\n    test_cases = [case1, case2, case3, case4, case5, case6]\n\n    results = []\n    for N, edges, T, S0 in test_cases:\n        fraction = run_simulation(N, edges, T, S0)\n        # Format the result to 6 decimal places as required.\n        results.append(f\"{fraction:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"}, {"introduction": "Our final practice advances to a more structurally realistic model of the financial system based on the seminal work of Eisenberg and Noe. Here, contagion is not just an abstract shock but a direct consequence of banks being unable to meet their payment obligations after an initial loss. You will implement an iterative clearing mechanism to determine the final settlement of payments in the network, effectively solving a complex fixed-point problem [@problem_id:2410802]. This exercise provides crucial insights into how limited liability and the web of mutual obligations can propagate failures, and allows you to compare the systemic impact of idiosyncratic versus correlated shocks.", "id": "2410802", "problem": "You are given a closed financial network of $n$ banks with nominal interbank liabilities and external assets. Let the nominal liabilities matrix be $L \\in \\mathbb{R}_{\\ge 0}^{n \\times n}$, where $L_{ij}$ is the amount that bank $i$ owes to bank $j$. Define the total nominal interbank liabilities of bank $i$ as $\\bar{p}_i = \\sum_{j=1}^n L_{ij}$ and the vector $\\bar{p} \\in \\mathbb{R}_{\\ge 0}^{n}$ with entries $\\bar{p}_i$. Let the relative liabilities matrix $\\Pi \\in \\mathbb{R}_{\\ge 0}^{n \\times n}$ be given by $\\Pi_{ij} = \\frac{L_{ij}}{\\bar{p}_i}$ if $\\bar{p}_i > 0$, and $\\Pi_{ij} = 0$ if $\\bar{p}_i = 0$. Let $x \\in \\mathbb{R}_{\\ge 0}^{n}$ be the vector of external (non-interbank) assets.\n\nConsider two shock scenarios applied to external assets:\n- Idiosyncratic shock to a single bank $k \\in \\{1,\\dots,n\\}$ with magnitude $s_{\\mathrm{id}} \\in [0,1]$ (expressed as a decimal, not a percentage): post-shock external assets are $x^{\\mathrm{id}}$ with $x^{\\mathrm{id}}_k = (1 - s_{\\mathrm{id}})\\, x_k$ and $x^{\\mathrm{id}}_i = x_i$ for all $i \\ne k$.\n- Common (correlated) stress with magnitude $s_{\\mathrm{com}} \\in [0,1]$ (expressed as a decimal, not a percentage): post-shock external assets are $x^{\\mathrm{com}}$ with $x^{\\mathrm{com}}_i = (1 - s_{\\mathrm{com}})\\, x_i$ for all $i$.\n\nAssume proportional repayment under limited liability in the sense of the Eisenberg–Noe (EN) clearing mechanism. For a given post-shock external asset vector $x' \\in \\{x^{\\mathrm{id}}, x^{\\mathrm{com}}\\}$, a clearing payment vector $p \\in \\mathbb{R}_{\\ge 0}^{n}$ must satisfy\n$$\np = \\min\\!\\big(\\,\\bar{p},\\; x' + \\Pi^{\\top} p\\,\\big),\n$$\nwhere the minimum is taken elementwise. A bank $i$ is said to be in default if $p_i < \\bar{p}_i$. Let the number of defaulting banks be $D(x') = \\sum_{i=1}^n \\mathbf{1}\\{p_i < \\bar{p}_i\\}$ and the aggregate unpaid liabilities be $U(x') = \\sum_{i=1}^n (\\bar{p}_i - p_i)$.\n\nYour task is to compute, for each test case below, the pair of metrics under both scenarios: the number of defaults and the aggregate unpaid liabilities. For each test case, return the list $[D(x^{\\mathrm{id}}), D(x^{\\mathrm{com}}), U(x^{\\mathrm{id}}), U(x^{\\mathrm{com}})]$, where the unpaid liabilities $U(\\cdot)$ must be rounded to six decimal places.\n\nAll monetary amounts are in consistent arbitrary units (no unit conversion required). Shock magnitudes must be treated as decimals in $[0,1]$.\n\nTest suite (each test case specifies $n$, $L$, $x$, $k$, $s_{\\mathrm{id}}$, $s_{\\mathrm{com}}$):\n\n- Test case $1$:\n$$\nn = 4,\\quad\nL = \\begin{bmatrix}\n0 & 2 & 1 & 2 \\\\\n1 & 0 & 1 & 2 \\\\\n1 & 1 & 0 & 1 \\\\\n0 & 1 & 2 & 0\n\\end{bmatrix},\\quad\nx = \\begin{bmatrix}\n6.0\\\\ 4.5\\\\ 3.5\\\\ 3.0\n\\end{bmatrix},\\quad\nk = 1,\\quad\ns_{\\mathrm{id}} = 0.6,\\quad\ns_{\\mathrm{com}} = 0.3.\n$$\n\n- Test case $2$ (baseline, no shock):\n$$\nn = 4,\\quad\nL = \\begin{bmatrix}\n0 & 2 & 1 & 2 \\\\\n1 & 0 & 1 & 2 \\\\\n1 & 1 & 0 & 1 \\\\\n0 & 1 & 2 & 0\n\\end{bmatrix},\\quad\nx = \\begin{bmatrix}\n6.0\\\\ 4.5\\\\ 3.5\\\\ 3.0\n\\end{bmatrix},\\quad\nk = 3,\\quad\ns_{\\mathrm{id}} = 0.0,\\quad\ns_{\\mathrm{com}} = 0.0.\n$$\n\n- Test case $3$ (severe stress comparison):\n$$\nn = 4,\\quad\nL = \\begin{bmatrix}\n0 & 2 & 1 & 2 \\\\\n1 & 0 & 1 & 2 \\\\\n1 & 1 & 0 & 1 \\\\\n0 & 1 & 2 & 0\n\\end{bmatrix},\\quad\nx = \\begin{bmatrix}\n6.0\\\\ 4.5\\\\ 3.5\\\\ 3.0\n\\end{bmatrix},\\quad\nk = 2,\\quad\ns_{\\mathrm{id}} = 0.9,\\quad\ns_{\\mathrm{com}} = 0.75.\n$$\n\nFinal output format: Your program should produce a single line of output containing the results for all test cases as a comma-separated list enclosed in square brackets, where each element is the list for one test case. For example, a valid structure is\n$[[D_1^{\\mathrm{id}}, D_1^{\\mathrm{com}}, U_1^{\\mathrm{id}}, U_1^{\\mathrm{com}}],[D_2^{\\mathrm{id}}, D_2^{\\mathrm{com}}, U_2^{\\mathrm{id}}, U_2^{\\mathrm{com}}],\\dots]$.", "solution": "The problem is subjected to validation.\n\n**Step 1: Extract Givens**\n\n-   Number of banks: $n$.\n-   Nominal liabilities matrix: $L \\in \\mathbb{R}_{\\ge 0}^{n \\times n}$, where $L_{ij}$ is the amount bank $i$ owes bank $j$.\n-   Total nominal interbank liabilities of bank $i$: $\\bar{p}_i = \\sum_{j=1}^n L_{ij}$. Vector form: $\\bar{p} \\in \\mathbb{R}_{\\ge 0}^{n}$.\n-   Relative liabilities matrix: $\\Pi \\in \\mathbb{R}_{\\ge 0}^{n \\times n}$, with $\\Pi_{ij} = \\frac{L_{ij}}{\\bar{p}_i}$ if $\\bar{p}_i > 0$, and $\\Pi_{ij} = 0$ if $\\bar{p}_i = 0$.\n-   Vector of external assets: $x \\in \\mathbb{R}_{\\ge 0}^{n}$.\n-   Idiosyncratic shock: Affects a single bank $k \\in \\{1,\\dots,n\\}$ with magnitude $s_{\\mathrm{id}} \\in [0,1]$. Post-shock assets are $x^{\\mathrm{id}}$ where $x^{\\mathrm{id}}_k = (1 - s_{\\mathrm{id}})\\, x_k$ and $x^{\\mathrm{id}}_i = x_i$ for $i \\ne k$.\n-   Common shock: Affects all banks with magnitude $s_{\\mathrm{com}} \\in [0,1]$. Post-shock assets are $x^{\\mathrm{com}}$ where $x^{\\mathrm{com}}_i = (1 - s_{\\mathrm{com}})\\, x_i$ for all $i$.\n-   Clearing payment vector: $p \\in \\mathbb{R}_{\\ge 0}^{n}$ is a solution to the fixed-point equation $p = \\min\\!\\big(\\,\\bar{p},\\; x' + \\Pi^{\\top} p\\,\\big)$, where $x'$ is a post-shock asset vector.\n-   Default condition: Bank $i$ is in default if its actual payment $p_i$ is less than its nominal liability $\\bar{p}_i$.\n-   Metrics to compute:\n    1.  Number of defaulting banks: $D(x') = \\sum_{i=1}^n \\mathbf{1}\\{p_i < \\bar{p}_i\\}$.\n    2.  Aggregate unpaid liabilities: $U(x') = \\sum_{i=1}^n (\\bar{p}_i - p_i)$. $U(\\cdot)$ must be rounded to six decimal places.\n-   Task: For each test case defined by ($n$, $L$, $x$, $k$, $s_{\\mathrm{id}}$, $s_{\\mathrm{com}}$), compute the four-element list $[D(x^{\\mathrm{id}}), D(x^{\\mathrm{com}}), U(x^{\\mathrm{id}}), U(x^{\\mathrm{com}})]$.\n\n**Step 2: Validate Using Extracted Givens**\n\n-   **Scientific Grounding**: The problem statement describes a canonical model of financial contagion, specifically the Eisenberg–Noe (2001) clearing system. This is a foundational and scientifically rigorous model in computational finance and economics for analyzing systemic risk in interbank networks. The premises are factually sound and based on established economic theory.\n-   **Well-Posedness**: The core of the problem is to find the clearing vector $p$ as a fixed point of the equation $p = f(p) = \\min\\!\\big(\\,\\bar{p},\\; x' + \\Pi^{\\top} p\\,\\big)$. The function $f$ is a monotone function on the complete lattice $[0, \\bar{p}] = \\{ p \\in \\mathbb{R}^n \\mid 0 \\le p_i \\le \\bar{p}_i \\text{ for all } i \\}$. By Tarski's fixed-point theorem, a fixed point exists. Eisenberg and Noe demonstrate that the greatest fixed point is the economically meaningful clearing vector. This can be found via the iterative procedure $p^{(m+1)} = f(p^{(m)})$, starting with $p^{(0)} = \\bar{p}$. This sequence is non-increasing and bounded below, thus it is guaranteed to converge. The problem is well-posed.\n-   **Objectivity**: The problem is formulated with precise mathematical definitions and objective language. There are no subjective or ambiguous terms.\n-   **Completeness**: All necessary data and parameters ($L$, $x$, $k$, $s_{\\mathrm{id}}$, $s_{\\mathrm{com}}$) are provided for each test case. The model and metrics are fully specified.\n\n**Step 3: Verdict and Action**\n\nThe problem is scientifically grounded, well-posed, objective, and complete. It is therefore deemed **valid**. A solution will be provided.\n\n**Solution Methodology**\n\nThe problem requires the computation of default statistics for a financial network under two shock scenarios. The solution follows the Eisenberg–Noe model. For each test case and each shock scenario, the following steps are performed:\n\n1.  **System Specification**: From the given nominal liabilities matrix $L$, we first compute the vector of total nominal liabilities $\\bar{p}$. Each element $\\bar{p}_i$ is the sum of row $i$ of $L$:\n    $$\n    \\bar{p}_i = \\sum_{j=1}^{n} L_{ij}\n    $$\n    Next, we compute the relative liabilities matrix $\\Pi$, where each element $\\Pi_{ij}$ represents the proportion of bank $i$'s total debt that is owed to bank $j$:\n    $$\n    \\Pi_{ij} = \\begin{cases} L_{ij} / \\bar{p}_i & \\text{if } \\bar{p}_i > 0 \\\\ 0 & \\text{if } \\bar{p}_i = 0 \\end{cases}\n    $$\n\n2.  **Shock Application**: We determine the post-shock external asset vector $x'$ for each scenario.\n    -   For an idiosyncratic shock of magnitude $s_{\\mathrm{id}}$ to bank $k$, the asset vector $x^{\\mathrm{id}}$ is:\n        $$\n        x^{\\mathrm{id}}_i = \\begin{cases} (1 - s_{\\mathrm{id}}) x_k & \\text{if } i = k \\\\ x_i & \\text{if } i \\ne k \\end{cases}\n        $$\n    -   For a common shock of magnitude $s_{\\mathrm{com}}$, the asset vector $x^{\\mathrm{com}}$ is:\n        $$\n        x^{\\mathrm{com}} = (1 - s_{\\mathrm{com}}) x\n        $$\n\n3.  **Clearing Vector Computation**: The central task is to find the clearing payment vector $p$, which is the greatest fixed point of the iterative map:\n    $$\n    p = \\min\\!\\big(\\,\\bar{p},\\; x' + \\Pi^{\\top} p\\,\\big)\n    $$\n    This fixed point is found by iteration. We initialize the payment vector with the most optimistic assumption, $p^{(0)} = \\bar{p}$ (all banks intend to pay their debts in full). We then iterate the following update rule until convergence, i.e., until $p^{(m+1)} = p^{(m)}$:\n    $$\n    p^{(m+1)} = \\min\\!\\big(\\,\\bar{p},\\; x' + \\Pi^{\\top} p^{(m)}\\,\\big)\n    $$\n    The term $\\Pi^{\\top}p^{(m)}$ represents the vector of interbank assets received by each bank, assuming other banks make payments according to $p^{(m)}$. The total available funds for bank $i$ are its post-shock external assets $x'_i$ plus its interbank receivables. The payment $p_i$ is capped by its total nominal debt $\\bar{p}_i$. The sequence of vectors $\\{p^{(m)}\\}_{m=0}^\\infty$ is non-increasing and bounded below by the zero vector, guaranteeing convergence to the greatest fixed point.\n\n4.  **Metrics Calculation**: Once the converged clearing vector $p$ is obtained, we compute the required metrics:\n    -   **Number of Defaults ($D$)**: A bank $i$ defaults if its payment $p_i$ is strictly less than its obligation $\\bar{p}_i$. We count the number of such banks.\n        $$\n        D(x') = \\sum_{i=1}^{n} \\mathbf{1}\\{p_i < \\bar{p}_i\\}\n        $$\n        A small numerical tolerance is used in implementation to robustly handle floating-point comparisons.\n    -   **Aggregate Unpaid Liabilities ($U$)**: This is the total shortfall across the entire system, calculated as the sum of differences between nominal liabilities and actual payments for all banks.\n        $$\n        U(x') = \\sum_{i=1}^{n} (\\bar{p}_i - p_i)\n        $$\n    The value of $U(x')$ is then rounded to six decimal places as required.\n\nThis procedure is applied to both the idiosyncratic and common shock scenarios for each test case to produce the final four-element result vector.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that processes all test cases and prints the final result.\n    \"\"\"\n    \n    test_cases = [\n        # Test case 1\n        (4,\n         np.array([[0, 2, 1, 2], [1, 0, 1, 2], [1, 1, 0, 1], [0, 1, 2, 0]], dtype=float),\n         np.array([6.0, 4.5, 3.5, 3.0], dtype=float),\n         1, 0.6, 0.3),\n        # Test case 2 (baseline, no shock)\n        (4,\n         np.array([[0, 2, 1, 2], [1, 0, 1, 2], [1, 1, 0, 1], [0, 1, 2, 0]], dtype=float),\n         np.array([6.0, 4.5, 3.5, 3.0], dtype=float),\n         3, 0.0, 0.0),\n        # Test case 3 (severe stress comparison)\n        (4,\n         np.array([[0, 2, 1, 2], [1, 0, 1, 2], [1, 1, 0, 1], [0, 1, 2, 0]], dtype=float),\n         np.array([6.0, 4.5, 3.5, 3.0], dtype=float),\n         2, 0.9, 0.75),\n    ]\n\n    results = []\n    for case in test_cases:\n        n, L, x, k, s_id, s_com = case\n        result = compute_for_case(n, L, x, k, s_id, s_com)\n        results.append(result)\n\n    # Format the final output as a string representation of a list of lists.\n    # e.g., [[val1, val2], [val3, val4]]\n    # Using map(str, ...) handles the inner lists correctly.\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef compute_for_case(n, L, x, k, s_id, s_com):\n    \"\"\"\n    Computes the required metrics for a single test case.\n    \"\"\"\n    # Step 1: System Specification\n    p_bar = L.sum(axis=1)\n    \n    # Calculate relative liabilities matrix Pi, handling division by zero for banks with no liabilities.\n    Pi = np.divide(L, p_bar[:, np.newaxis], out=np.zeros_like(L, dtype=float), where=(p_bar[:, np.newaxis] != 0))\n    Pi_T = Pi.T\n\n    # --- Idiosyncratic Shock Scenario ---\n    # Step 2: Apply idiosyncratic shock\n    x_id = x.copy()\n    if k is not None:\n        # Note: problem uses 1-based indexing for k, Python uses 0-based.\n        x_id[k - 1] *= (1 - s_id)\n    \n    # Steps 3 & 4: Compute clearing vector and metrics\n    D_id, U_id = find_clearing_vector_and_metrics(p_bar, Pi_T, x_id)\n\n    # --- Common Shock Scenario ---\n    # Step 2: Apply common shock\n    x_com = x * (1 - s_com)\n    \n    # Steps 3 & 4: Compute clearing vector and metrics\n    D_com, U_com = find_clearing_vector_and_metrics(p_bar, Pi_T, x_com)\n\n    return [D_id, D_com, round(U_id, 6), round(U_com, 6)]\n\n\ndef find_clearing_vector_and_metrics(p_bar, Pi_T, x_shocked, max_iter=100, tol=1e-12):\n    \"\"\"\n    Computes the Eisenberg-Noe clearing vector and derived metrics.\n    \n    Args:\n        p_bar (np.ndarray): Vector of total nominal liabilities.\n        Pi_T (np.ndarray): Transposed relative liabilities matrix.\n        x_shocked (np.ndarray): Post-shock external asset vector.\n        max_iter (int): Maximum number of iterations for the fixed-point solver.\n        tol (float): Tolerance for default detection and convergence.\n        \n    Returns:\n        tuple[int, float]: A tuple containing the number of defaults (D) and \n                           aggregate unpaid liabilities (U).\n    \"\"\"\n    # Step 3: Clearing Vector Computation (Iterative Fixed-Point Method)\n    p = p_bar.copy()  # Initialize with optimistic p(0) = p_bar\n\n    for _ in range(max_iter):\n        p_old = p\n        \n        # Calculate incoming interbank payments\n        interbank_assets = Pi_T @ p_old\n        \n        # Calculate total available assets and update payments\n        p = np.minimum(p_bar, x_shocked + interbank_assets)\n        \n        # Check for convergence\n        if np.allclose(p, p_old, atol=tol, rtol=0):\n            break\n\n    # Step 4: Metrics Calculation\n    # Number of defaults D: count banks where payment is less than liability\n    # Use a tolerance to avoid floating-point inaccuracies.\n    defaults = (p_bar - p) > tol\n    num_defaults = int(np.sum(defaults))\n    \n    # Aggregate unpaid liabilities U: sum of shortfalls across all banks\n    unpaid_liabilities = float(np.sum(p_bar - p))\n    \n    return num_defaults, unpaid_liabilities\n\nif __name__ == \"__main__\":\n    solve()\n```"}]}