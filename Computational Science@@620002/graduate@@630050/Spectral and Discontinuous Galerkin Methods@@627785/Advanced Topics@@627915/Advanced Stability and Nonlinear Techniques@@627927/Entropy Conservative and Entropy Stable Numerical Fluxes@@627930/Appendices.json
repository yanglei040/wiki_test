{"hands_on_practices": [{"introduction": "This first practice takes us back to the foundational principles of entropy conservation. By working through a guided derivation for the scalar Burgers' equation, you will construct a two-point entropy conservative flux from the ground up [@problem_id:3384448]. This pen-and-paper exercise is essential for demystifying the algebraic structure of these fluxes and internalizing the connection between the physical flux, a chosen entropy function, and the resulting numerical flux.", "problem": "Consider the scalar conservation law for viscous-free flow, Burgers’ equation, given by $u_{t} + \\left(f(u)\\right)_{x} = 0$ with $f(u) = \\frac{u^{2}}{2}$, discretized by a discontinuous Galerkin (DG) method. Let an entropy pair $(U(u),q(u))$ be defined by a strictly convex entropy $U(u)$ and an associated entropy flux $q(u)$ satisfying the compatibility condition $q^{\\prime}(u) = v(u)\\,f^{\\prime}(u)$, where the entropy variable is $v(u) = U^{\\prime}(u)$. The Tadmor entropy conservation condition for a two-point numerical flux $f^{ec}(u_{L},u_{R})$ is that the interface contribution satisfies a discrete chain rule using a flux potential $\\psi(u)$, namely $\\left(v_{R} - v_{L}\\right)\\,f^{ec}(u_{L},u_{R}) = \\psi(u_{R}) - \\psi(u_{L})$, where $\\psi(u)$ is defined in terms of the entropy pair and the physical flux.\n\nUsing only the definitions of an entropy pair and the above discrete entropy conservation condition, specialize to the quadratic entropy $U(u) = \\frac{u^{2}}{2}$ and perform the following steps:\n- Derive the entropy flux $q(u)$ from the compatibility condition $q^{\\prime}(u) = v(u)\\,f^{\\prime}(u)$.\n- Define the flux potential $\\psi(u)$ from the entropy pair and the physical flux using the identity $\\psi(u) = v(u)\\,f(u) - q(u)$.\n- Use the Tadmor condition to construct a closed-form expression for the two-point entropy conservative flux $f^{ec}(u_{L},u_{R})$ that is symmetric, consistent, and continuous in the limit $u_{L} \\to u_{R}$.\n\nState your final answer as a single closed-form analytic expression for $f^{ec}(u_{L},u_{R})$. No numerical evaluation or rounding is required.", "solution": "The problem statement is evaluated as valid, as it is scientifically grounded, well-posed, and objective. It presents a standard derivation in the field of numerical methods for hyperbolic conservation laws, specifically the construction of an entropy conservative flux. All definitions and conditions provided are standard in the literature (e.g., Tadmor, 1987).\n\nWe proceed with the derivation as requested. The problem specifies the Burgers' equation, for which the physical flux is $f(u) = \\frac{u^{2}}{2}$. We are to use the specific quadratic entropy function $U(u) = \\frac{u^{2}}{2}$.\n\nFirst, we derive the associated entropy variable $v(u)$ and entropy flux $q(u)$.\nThe entropy variable $v(u)$ is defined as the derivative of the entropy function $U(u)$ with respect to the conserved variable $u$:\n$$v(u) = U^{\\prime}(u) = \\frac{d}{du}\\left(\\frac{u^{2}}{2}\\right) = u$$\nThe entropy flux $q(u)$ is determined by the compatibility condition $q^{\\prime}(u) = v(u)f^{\\prime}(u)$. First, we find the derivative of the physical flux $f(u)$:\n$$f^{\\prime}(u) = \\frac{d}{du}\\left(\\frac{u^{2}}{2}\\right) = u$$\nNow we substitute $v(u)$ and $f^{\\prime}(u)$ into the compatibility condition:\n$$q^{\\prime}(u) = (u)(u) = u^{2}$$\nTo find $q(u)$, we integrate $q^{\\prime}(u)$ with respect to $u$. We can set the constant of integration to zero, as the entropy flux is defined up to an additive constant, which will be eliminated when taking differences:\n$$q(u) = \\int u^{2} \\, du = \\frac{u^{3}}{3}$$\n\nNext, we define the flux potential $\\psi(u)$ using the provided identity $\\psi(u) = v(u)f(u) - q(u)$. We substitute the expressions for $v(u)$, $f(u)$, and $q(u)$:\n$$\\psi(u) = (u)\\left(\\frac{u^{2}}{2}\\right) - \\frac{u^{3}}{3} = \\frac{u^{3}}{2} - \\frac{u^{3}}{3}$$\nCombining the terms gives the expression for the flux potential:\n$$\\psi(u) = \\frac{3u^{3} - 2u^{3}}{6} = \\frac{u^{3}}{6}$$\n\nFinally, we construct the two-point entropy conservative flux $f^{ec}(u_{L}, u_{R})$ using the Tadmor entropy conservation condition:\n$$\\left(v(u_{R}) - v(u_{L})\\right)f^{ec}(u_{L}, u_{R}) = \\psi(u_{R}) - \\psi(u_{L})$$\nSubstituting the expressions we found for $v(u)$ and $\\psi(u)$, we have $v(u_{L}) = u_{L}$, $v(u_{R}) = u_{R}$, $\\psi(u_{L}) = \\frac{u_{L}^{3}}{6}$, and $\\psi(u_{R}) = \\frac{u_{R}^{3}}{6}$. The condition becomes:\n$$\\left(u_{R} - u_{L}\\right)f^{ec}(u_{L}, u_{R}) = \\frac{u_{R}^{3}}{6} - \\frac{u_{L}^{3}}{6}$$\nTo find the flux, we solve for $f^{ec}(u_{L}, u_{R})$ by dividing by $(u_{R} - u_{L})$, assuming $u_{R} \\neq u_{L}$:\n$$f^{ec}(u_{L}, u_{R}) = \\frac{1}{u_{R} - u_{L}}\\left(\\frac{u_{R}^{3} - u_{L}^{3}}{6}\\right) = \\frac{u_{R}^{3} - u_{L}^{3}}{6(u_{R} - u_{L})}$$\nTo obtain a closed-form expression that is continuous and well-defined even when $u_{L} = u_{R}$, we use the algebraic identity for the difference of cubes, $a^{3} - b^{3} = (a-b)(a^{2} + ab + b^{2})$:\n$$u_{R}^{3} - u_{L}^{3} = (u_{R} - u_{L})(u_{R}^{2} + u_{R}u_{L} + u_{L}^{2})$$\nSubstituting this factored form into the expression for the flux:\n$$f^{ec}(u_{L}, u_{R}) = \\frac{(u_{R} - u_{L})(u_{R}^{2} + u_{R}u_{L} + u_{L}^{2})}{6(u_{R} - u_{L})}$$\nCanceling the $(u_{R} - u_{L})$ term, we arrive at the final expression for the entropy conservative flux:\n$$f^{ec}(u_{L}, u_{R}) = \\frac{u_{L}^{2} + u_{L}u_{R} + u_{R}^{2}}{6}$$\nThis expression is symmetric, as swapping $u_{L}$ and $u_{R}$ leaves the expression unchanged. It is also consistent, since in the limit $u_{L} \\to u_{R} = u$, we have:\n$$f^{ec}(u, u) = \\frac{u^{2} + u \\cdot u + u^{2}}{6} = \\frac{3u^{2}}{6} = \\frac{u^{2}}{2} = f(u)$$\nThis fulfills all the requirements of the problem.", "answer": "$$\\boxed{\\frac{u_{L}^{2} + u_{L}u_{R} + u_{R}^{2}}{6}}$$", "id": "3384448"}, {"introduction": "Building upon the continuous theory, this practice explores a critical aspect of discrete implementation within a Discontinuous Galerkin (DG) framework: the role of numerical quadrature. You will write a program to investigate how inexact integration of the volume terms can lead to spurious, non-physical entropy production [@problem_id:3384466]. This exercise provides crucial, practical insight into ensuring that the discrete scheme respects the continuous entropy identity, highlighting the minimum quadrature accuracy required for a truly conservative formulation.", "problem": "You will investigate how volume underintegration in nodal spectral and discontinuous Galerkin discretizations affects the discrete entropy balance for one-dimensional scalar conservation laws. Consider the scalar conservation law $u_t + f(u)_x = 0$ on the reference interval $[-1,1]$. Let $U(u)$ denote a strictly convex mathematical entropy and let $F(u)$ denote the associated entropy flux satisfying $F'(u) = U'(u) f'(u)$. For sufficiently smooth $u$, the continuous entropy identity reads $U(u)_t + F(u)_x = 0$, and after integration over $[-1,1]$, one obtains $\\frac{d}{dt} \\int_{-1}^{1} U(u) \\, dx + \\left[ F(u) \\right]_{x=-1}^{x=1} = 0$. In a nodal spectral or discontinuous Galerkin discretization, the semi-discrete entropy balance depends on how the volume term $\\int_{-1}^{1} U'(u) \\, f(u)_x \\, dx$ is approximated. When the volume integral is computed by an underintegrated quadrature, spurious entropy production may result.\n\nYour tasks are:\n- Derive, from the fundamental properties of the scalar conservation law and the chain rule, a bound on the polynomial degree of the integrand appearing in the discrete volume contribution to the entropy balance when $u$ is approximated by a polynomial of degree $p$ and the nonlinear flux is Burgers flux $f(u) = \\frac{1}{2} u^2$ with the quadratic entropy $U(u) = \\frac{1}{2} u^2$. Use this to infer a minimum quadrature exactness requirement in terms of $p$ that suffices to avoid spurious entropy production in the volume contribution.\n- Quantify the effect of underintegration using two families of element-volume quadrature rules:\n  1. Gauss–Legendre quadrature with $N$ points on $[-1,1]$, which is exact for polynomials up to degree $2N - 1$.\n  2. Gauss–Lobatto–Legendre quadrature with $N$ points on $[-1,1]$, which is exact for polynomials up to degree $2N - 3$.\n- Implement a program that, for a given polynomial degree $p$, constructs a representative polynomial approximation $u_p(x)$ of degree $p$ and evaluates the discrete entropy residual\n  $$ R_N = \\sum_{i=1}^{N} w_i \\, U'(u_p(x_i)) \\, \\frac{d}{dx} f(u_p(x_i)) \\;-\\; \\left[ F(u_p(x)) \\right]_{x=-1}^{x=1}, $$\n  where $\\{x_i,w_i\\}_{i=1}^{N}$ are the quadrature nodes and weights for either Gauss–Legendre or Gauss–Lobatto–Legendre quadrature. Here, $U(u) = \\frac{1}{2} u^2$, $U'(u) = u$, $f(u) = \\frac{1}{2} u^2$, and $F(u) = \\frac{1}{3} u^3$. Choose\n  $$ u_p(x) = \\sum_{k=0}^{p} \\frac{1}{k+1} P_k(x), $$\n  where $P_k(x)$ denotes the degree-$k$ Legendre polynomial on $[-1,1]$, so that $u_p$ has nontrivial contributions from all degrees up to $p$. Compute $\\frac{d}{dx} f(u_p(x))$ exactly by differentiating $u_p$ analytically in $x$.\n- For a tolerance of $10^{-12}$, identify the smallest $N$ such that $|R_N| \\le 10^{-12}$ for each of the two quadrature families and for each polynomial degree $p$. Also, quantify the magnitude of spurious entropy production by reporting $|R_{p+1}|$ for both Gauss–Legendre and Gauss–Lobatto–Legendre quadrature (i.e., using $N = p+1$ volume points).\n\nUse the following test suite for $p$:\n- $p = 1$ (boundary case where low-degree interactions may be exactly integrated by modest quadrature),\n- $p = 2$ (moderate degree),\n- $p = 3$ (typical nontrivial case),\n- $p = 4$ (higher degree to expose scaling).\n\nYour program must:\n- For each $p$ in the test suite, compute and return a list of four values:\n  1. the smallest $N$ for Gauss–Legendre such that $|R_N| \\le 10^{-12}$,\n  2. the smallest $N$ for Gauss–Lobatto–Legendre such that $|R_N| \\le 10^{-12}$,\n  3. the value of $|R_{p+1}|$ using Gauss–Legendre with $N = p+1$,\n  4. the value of $|R_{p+1}|$ using Gauss–Lobatto–Legendre with $N = p+1$.\n- Aggregate the results for the test suite into a single line of output as a comma-separated list of lists enclosed in square brackets (e.g., $[ [a_1,a_2,a_3,a_4], [b_1,b_2,b_3,b_4], \\dots ]$).\n\nNotes and constraints:\n- The analysis and the program must be based on the chain rule identity for $U'(u) f'(u) u_x$ and exact endpoint evaluation of $F(u)$. No additional stabilization or interface terms are to be included, and no physical units are present in this problem.\n- Angles are not used in this problem.\n- All outputs must be plain numbers; do not use percentage signs or any units.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[[r_{11},r_{12},r_{13},r_{14}],[r_{21},r_{22},r_{23},r_{24}],[r_{31},r_{32},r_{33},r_{34}],[r_{41},r_{42},r_{43},r_{44}]]$), where each $r_{ij}$ is a number as specified above.", "solution": "The problem requires an analysis of the spurious entropy production arising from volume underintegration in a nodal spectral or discontinuous Galerkin method for a scalar conservation law. We must first formulate the discrete entropy balance and then determine the conditions under which the volume integral term is computed exactly.\n\nThe semi-discrete form of the conservation law, after multiplication by a test function $\\phi$ and integration over a reference element $I = [-1, 1]$, is\n$$ \\frac{d}{dt} \\int_{-1}^{1} u_p \\phi \\, dx - \\int_{-1}^{1} f(u_p) \\phi_x \\, dx + \\left[ f(u_p) \\phi \\right]_{x=-1}^{x=1} = 0 $$\nwhere $u_p$ is a polynomial approximation of degree $p$ to the solution $u$. To analyze entropy stability, one typically chooses the test function $\\phi$ to be related to the entropy variable, $v = U'(u)$. In a nodal DG setting, we can take $\\phi = v(u_p) = U'(u_p)$. The time derivative term becomes $\\int_{-1}^{1} U'(u_p) \\frac{\\partial u_p}{\\partial t} \\, dx = \\frac{d}{dt} \\int_{-1}^{1} U(u_p) \\, dx$. The semi-discrete entropy balance for the element is then\n$$ \\frac{d}{dt} \\int_{-1}^{1} U(u_p) \\, dx + \\int_{-1}^{1} U'(u_p) f(u_p)_x \\, dx = \\text{Boundary and interface terms} $$\nThe continuous entropy identity states $U(u)_t + F(u)_x = 0$. Integrating over the element gives $\\frac{d}{dt} \\int_{-1}^{1} U(u) \\, dx + \\left[ F(u) \\right]_{x=-1}^{x=1} = 0$. The discrete formulation should mimic this. The focus of this problem is the volume integral $\\int_{-1}^{1} U'(u_p(x)) f(u_p(x))_x \\, dx$.\n\nIn a numerical implementation, this integral is replaced by a quadrature sum:\n$$ \\int_{-1}^{1} U'(u_p(x)) f(u_p(x))_x \\, dx \\approx \\sum_{i=1}^{N} w_i U'(u_p(x_i)) f(u_p(x_i))_x $$\nwhere $\\{x_i, w_i\\}_{i=1}^{N}$ are the quadrature nodes and weights.\n\nThe core of the analysis lies in the identity relating the integrand to the entropy flux $F(u)$. By the chain rule, $f(u_p(x))_x = f'(u_p(x)) u_p'(x)$. The integrand is thus:\n$$ I(x) = U'(u_p(x)) f'(u_p(x)) u_p'(x) $$\nThe entropy flux $F(u)$ is defined such that $F'(u) = U'(u) f'(u)$. Substituting this into the integrand gives:\n$$ I(x) = F'(u_p(x)) u_p'(x) $$\nBy another application of the chain rule, this is precisely the derivative of the composite function $F(u_p(x))$:\n$$ I(x) = \\frac{d}{dx} F(u_p(x)) $$\nTherefore, the exact value of the volume integral can be found using the Fundamental Theorem of Calculus:\n$$ \\int_{-1}^{1} U'(u_p(x)) f(u_p(x))_x \\, dx = \\int_{-1}^{1} \\frac{d}{dx} F(u_p(x)) \\, dx = \\left[ F(u_p(x)) \\right]_{x=-1}^{x=1} $$\nThe discrete entropy residual, $R_N$, as defined in the problem, measures the error of the quadrature rule for this integral:\n$$ R_N = \\left( \\sum_{i=1}^{N} w_i I(x_i) \\right) - \\int_{-1}^{1} I(x) \\, dx $$\nThe residual $R_N$ is zero if and only if the quadrature rule is exact for the integrand $I(x)$. To determine the required exactness, we must find the polynomial degree of $I(x)$.\n\nThe problem specifies the Burgers' flux $f(u) = \\frac{1}{2} u^2$ and the quadratic entropy $U(u) = \\frac{1}{2} u^2$. This gives the entropy variable $U'(u) = u$ and the entropy flux $F(u) = \\frac{1}{3} u^3$.\nThe solution approximation $u_p(x)$ is a polynomial of degree $p$.\nThe composite function $F(u_p(x)) = \\frac{1}{3} (u_p(x))^3$ is a polynomial of degree $3p$.\nThe integrand $I(x) = \\frac{d}{dx} F(u_p(x))$ is therefore a polynomial of degree $3p-1$.\n\nFor the residual $R_N$ to be zero (up to machine precision), the quadrature rule must be exact for all polynomials of degree up to $3p-1$.\n\nWe now apply this requirement to the two specified quadrature families:\n1.  **Gauss–Legendre Quadrature**: A rule with $N$ points is exact for polynomials of degree up to $2N-1$. To avoid spurious entropy production from the volume term, we require:\n    $$ 2N - 1 \\ge 3p - 1 \\implies 2N \\ge 3p \\implies N \\ge \\frac{3p}{2} $$\n    Since $N$ must be an integer, the minimum number of Gauss-Legendre points is $N_{GL} = \\lceil \\frac{3p}{2} \\rceil$.\n\n2.  **Gauss–Lobatto–Legendre Quadrature**: A rule with $N$ points is exact for polynomials of degree up to $2N-3$. The requirement is:\n    $$ 2N - 3 \\ge 3p - 1 \\implies 2N \\ge 3p + 2 \\implies N \\ge \\frac{3p}{2} + 1 $$\n    The minimum number of Gauss-Lobatto-Legendre points is $N_{GLL} = \\lceil \\frac{3p}{2} + 1 \\rceil$.\n\nThese results provide the theoretical minimum number of quadrature points to ensure the discrete volume integral matches the change in entropy flux at the boundaries, thus preserving the local cell entropy balance for smooth solutions. The provided implementation will verify these theoretical predictions and quantify the error when an insufficient number of points ($N=p+1$) is used, a common scenario in underintegrated or collocated discontinuous Galerkin methods.", "answer": "```python\nimport numpy as np\nfrom scipy.special import legendre, roots_legendre\n\ndef solve():\n    \"\"\"\n    Analyzes the effect of volume underintegration on the discrete entropy balance\n    for a nodal DG discretization of a scalar conservation law.\n    \"\"\"\n    TOL = 1e-12\n    test_ps = [1, 2, 3, 4]\n    all_results = []\n\n    def get_up_and_dup_poly1d(p):\n        \"\"\"Constructs polynomial objects for u_p(x) and its derivative u_p'(x).\"\"\"\n        u_p_poly = np.poly1d([0.0])\n        for k in range(p + 1):\n            coeff = 1.0 / (k + 1)\n            P_k = legendre(k)\n            u_p_poly += coeff * P_k\n        \n        du_p_poly = u_p_poly.deriv(1)\n        return u_p_poly, du_p_poly\n\n    def get_gll_quadrature(N):\n        \"\"\"\n        Computes Gauss-Lobatto-Legendre quadrature nodes and weights for [-1, 1].\n        This implementation is for SciPy versions < 1.12.0 where roots_lobatto is not available.\n        \"\"\"\n        if N < 2:\n            raise ValueError(\"Gauss-Lobatto-Legendre quadrature requires N >= 2 points.\")\n\n        # Nodes are {-1, 1} and the roots of P'_{N-1}(x)\n        p_N_minus_1_deriv = legendre(N - 1).deriv(1)\n        interior_nodes = p_N_minus_1_deriv.roots\n        nodes = np.zeros(N)\n        nodes[0] = -1.0\n        nodes[N - 1] = 1.0\n        nodes[1:-1] = np.sort(np.real_if_close(interior_nodes))\n\n        # Weights w_i = 2 / (N(N-1) * [P_{N-1}(x_i)]^2)\n        weights = np.zeros(N)\n        p_N_minus_1 = legendre(N - 1)\n        weights = 2.0 / (N * (N - 1) * p_N_minus_1(nodes)**2)\n        \n        return nodes, weights\n\n    def calculate_residual(p, N, quad_type):\n        \"\"\"Calculates the discrete entropy residual R_N.\"\"\"\n        u_p, du_p = get_up_and_dup_poly1d(p)\n\n        if quad_type == 'gauss-legendre':\n            if N == 0: return np.inf # Not meaningful\n            nodes, weights = roots_legendre(N)\n        elif quad_type == 'gauss-lobatto':\n            if N < 2: return np.inf # Not meaningful\n            nodes, weights = get_gll_quadrature(N)\n        else:\n            raise ValueError(\"Unknown quadrature type\")\n\n        # Integrand I(x) = U'(u_p) * (d/dx f(u_p)) = u_p * (u_p * u_p') = u_p^2 * u_p'\n        u_p_vals = u_p(nodes)\n        du_p_vals = du_p(nodes)\n        integrand_vals = u_p_vals**2 * du_p_vals\n\n        # discrete volume integral\n        quad_sum = np.sum(weights * integrand_vals)\n\n        # Exact boundary term: [F(u_p(x))]_{-1}^1\n        # F(u) = 1/3 * u^3\n        u_p_at_1 = u_p(1.0)\n        u_p_at_minus_1 = u_p(-1.0)\n        boundary_term = (1.0 / 3.0) * (u_p_at_1**3 - u_p_at_minus_1**3)\n\n        residual = quad_sum - boundary_term\n        return residual\n\n    for p in test_ps:\n        p_results = []\n\n        # 1. Smallest N for Gauss-Legendre\n        N = 1\n        while True:\n            residual = calculate_residual(p, N, 'gauss-legendre')\n            if abs(residual) <= TOL:\n                p_results.append(N)\n                break\n            N += 1\n            if N > 50: # Safety break\n                p_results.append(-1)\n                break\n\n        # 2. Smallest N for Gauss-Lobatto-Legendre\n        N = 2\n        while True:\n            residual = calculate_residual(p, N, 'gauss-lobatto')\n            if abs(residual) <= TOL:\n                p_results.append(N)\n                break\n            N += 1\n            if N > 50: # Safety break\n                p_results.append(-1)\n                break\n\n        # 3. |R_{p+1}| for Gauss-Legendre\n        N_gl = p + 1\n        residual_gl = calculate_residual(p, N_gl, 'gauss-legendre')\n        p_results.append(abs(residual_gl))\n\n        # 4. |R_{p+1}| for Gauss-Lobatto-Legendre\n        N_gll = p + 1\n        residual_gll = calculate_residual(p, N_gll, 'gauss-lobatto')\n        p_results.append(abs(residual_gll))\n        \n        all_results.append(p_results)\n    \n    # Format output as a single string, a list of lists with no spaces\n    print(str(all_results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "3384466"}, {"introduction": "Our final practice scales up the concept from a single scalar equation to a system of nonlinear conservation laws: the compressible Euler equations. You will implement a complete Discontinuous Galerkin Spectral Element Method (DGSEM) using a celebrated entropy-conservative flux for this system [@problem_id:3384472]. This capstone exercise demonstrates how to assemble the theoretical components into a sophisticated, entropy-conservative numerical method for a challenging physical model and verify its properties numerically.", "problem": "Consider the one-dimensional compressible Euler equations for an ideal gas with ratio of specific heats $\\gamma \\in (1,2)$, written in conservation form for the vector of conservative variables $u = [\\rho, \\rho u, \\rho E]^T$,\n$$\n\\frac{\\partial u}{\\partial t} + \\frac{\\partial f(u)}{\\partial x} = 0,\n$$\nwhere the physical flux $f(u)$ is\n$$\nf(u) = \\begin{bmatrix}\n\\rho u \\\\\n\\rho u^2 + p \\\\\nu (\\rho E + p)\n\\end{bmatrix},\n$$\nand the pressure $p$ satisfies the ideal gas equation of state\n$$\np = (\\gamma - 1)\\left(\\rho E - \\tfrac{1}{2}\\rho u^2\\right).\n$$\nLet the mathematical entropy be the convex scalar $\\eta(u)$ defined by\n$$\n\\eta(u) = -\\frac{\\rho}{\\gamma - 1}\\left(\\ln p - \\gamma \\ln \\rho\\right),\n$$\nwith associated entropy variables $v(u) = \\nabla_u \\eta(u)$ and entropy flux $\\phi(u)$ satisfying\n$$\n\\nabla_u \\eta(u)^T \\nabla_u f(u) = \\nabla_u \\phi(u).\n$$\nA two-point numerical flux $h_{EC}(u_L,u_R)$ is entropy conservative if it satisfies Tadmor’s identity\n$$\n\\left(v(u_R) - v(u_L)\\right)^T h_{EC}(u_L,u_R) = \\psi(u_R) - \\psi(u_L),\n$$\nwhere $\\psi(u) = v(u)^T f(u) - \\phi(u)$ is the entropy potential.\n\nOn each element $K$ of a periodic mesh that partitions the computational domain $[0,1]$ into $K_{\\text{el}}$ equal segments, consider a Discontinuous Galerkin Spectral Element Method (DGSEM) with polynomial degree $N$ using Legendre–Gauss–Lobatto quadrature points $\\{x_i\\}_{i=0}^N$ and weights $\\{w_i\\}_{i=0}^N$ on the reference interval $[-1,1]$. Let $D$ be the nodal differentiation matrix for the Lagrange basis at the Legendre–Gauss–Lobatto nodes, and let $B = \\text{diag}(-1,0,\\dots,0,1)$. The split-form flux differencing DGSEM semi-discrete strong form can be written for each node $i$ in element $K$ as\n$$\n\\frac{\\partial u_i}{\\partial t} = -\\frac{2}{J_K}\\sum_{j=0}^N D_{ij}\\,h_{EC}(u_i,u_j) + \\frac{1}{J_K} B_{ii}\\left(f^\\ast_{\\partial K} - f(u_i)\\right),\n$$\nwhere $J_K$ is the affine mapping Jacobian from $[-1,1]$ to the physical element $K$, and $f^\\ast_{\\partial K}$ is the interface numerical flux at the left/right face of element $K$ constructed by applying the same two-point entropy-conservative flux $h_{EC}$ to the left and right traces at each face.\n\nYou must:\n\n1. Construct the DGSEM with split-form flux differencing for the one-dimensional compressible Euler equations using Chandrashekar’s entropy-conservative two-point flux $h_{EC}(u_L,u_R)$ and the ideal gas entropy $\\eta(u)$ defined above. Use $N \\ge 2$ and $K_{\\text{el}} \\ge 2$.\n\n2. On a periodic mesh, implement the semi-discrete DGSEM and compute the discrete total entropy rate\n$$\n\\frac{d}{dt}\\sum_{K}\\int_{K}\\eta(u)\\,dx \\approx \\sum_K J_K \\sum_{i=0}^N w_i \\, v(u_{K,i})^T \\frac{\\partial u_{K,i}}{\\partial t},\n$$\nand verify numerically that it equals the negative sum of entropy flux contributions over all element boundaries,\n$$\n-\\sum_{\\partial K}\\widehat{\\Phi}_\\eta,\n$$\nwhere the boundary entropy flux $\\widehat{\\Phi}_\\eta$ is induced by the same entropy-conservative interface flux and must vanish on a periodic mesh. Therefore, on a periodic mesh, the discrete total entropy rate must be approximately zero for physically admissible states.\n\nBase your derivation and construction on the following foundational principles, without shortcut formulas provided in the problem statement:\n- Conservation form of the compressible Euler equations, the ideal gas law, and convex entropy with associated entropy variables and entropy flux.\n- The Summation-By-Parts (SBP) property of Legendre–Gauss–Lobatto quadrature with the Lagrange basis and its differentiation matrix on $[-1,1]$.\n- Tadmor’s entropy conservation framework for two-point fluxes and flux differencing.\n\nImplement a complete program that:\n- Computes Legendre–Gauss–Lobatto nodes and weights for a specified polynomial degree $N$, constructs the barycentric differentiation matrix $D$, and verifies internally the SBP identity $M D + D^T M = B$, where $M = \\text{diag}(w_0,\\dots,w_N)$.\n- Implements Chandrashekar’s entropy-conservative two-point flux $h_{EC}(u_L,u_R)$ for the one-dimensional Euler equations using logarithmic means and appropriate averages.\n- Assembles the DGSEM residual for a periodic mesh with $K_{\\text{el}}$ elements and computes the discrete total entropy rate using the entropy variables.\n- Verifies numerically, for a selection of smooth physically admissible test states, that the discrete total entropy rate on a periodic mesh is approximately zero.\n\nUse the following test suite of parameter values and initial states on $[0,1]$:\n- Test case 1 (constant state, happy path): $\\gamma=1.4$, $N=4$, $K_{\\text{el}}=4$, $\\rho(x)=1$, $u(x)=0.3$, $p(x)=1$.\n- Test case 2 (smooth perturbation): $\\gamma=1.4$, $N=5$, $K_{\\text{el}}=3$, $\\rho(x)=1+0.01\\cos(2\\pi x)$, $u(x)=0.5+0.05\\sin(2\\pi x)$, $p(x)=1+0.02\\cos(2\\pi x+0.3)$.\n- Test case 3 (small random perturbation around a constant state): $\\gamma=1.4$, $N=3$, $K_{\\text{el}}=5$, $\\rho(x)=1+10^{-3}\\,\\xi_1(x)$, $u(x)=0.2+10^{-3}\\,\\xi_2(x)$, $p(x)=1+10^{-3}\\,\\xi_3(x)$ where $\\xi_k(x)$ are independent smooth random fields generated by sampling independent uniform random values per element and interpolating to nodal points with a degree-$N$ Lagrange interpolant; ensure $p(x) > 0.5$ everywhere by shifting if necessary.\n- Test case 4 (boundary resolution edge case): $\\gamma=1.4$, $N=2$, $K_{\\text{el}}=2$, $\\rho(x)=1+0.005\\sin(4\\pi x)$, $u(x)=0.1+0.005\\cos(4\\pi x)$, $p(x)=1+0.005\\sin(4\\pi x)$, adjusted if needed to maintain positivity.\n\nFor each test case, your program must compute the discrete total entropy rate on the periodic mesh using the DGSEM residual and determine whether its magnitude is less than a tolerance $\\tau = 10^{-10}$, returning a boolean result for each case.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4]\"), where each result is a boolean indicating whether the discrete total entropy rate is approximately zero for the corresponding test case.", "solution": "The user seeks to verify the entropy conservation property of a Discontinuous Galerkin Spectral Element Method (DGSEM) for the one-dimensional compressible Euler equations. The method is based on a split-form flux differencing approach using Legendre-Gauss-Lobatto (LGL) nodes and Chandrashekar's entropy-conservative two-point flux. The problem requires a numerical verification that for smooth, physically admissible initial states on a periodic domain, the discrete total entropy production rate is approximately zero, as dictated by the theory of entropy-conservative schemes.\n\nThe solution is structured as follows:\n1.  **Mathematical and Numerical Preliminaries**: Functions are established to handle the necessary components of the DGSEM framework. This includes:\n    *   Generation of Legendre-Gauss-Lobatto (LGL) nodes and quadrature weights for a given polynomial degree $N$. The nodes are the roots of $(1-x^2)P_N'(x)$, where $P_N(x)$ is the Legendre polynomial of degree $N$.\n    *   Construction of the nodal differentiation matrix $D$ for the Lagrange basis defined on the LGL nodes. The off-diagonal entries are computed using properties of Legendre polynomials, and the diagonal entries are determined by the condition that the derivative of a constant must be zero ($\\sum_j D_{ij} = 0$).\n    *   An internal verification of the Summation-By-Parts (SBP) property, $M D + D^T M = B$, where $M$ is the diagonal mass matrix of quadrature weights and $B$ is the boundary operator $\\text{diag}(-1, 0, \\dots, 0, 1)$. This confirms the correctness of the discrete operators.\n\n2.  **Physics Modeling**: Functions are implemented to describe the physics of an ideal gas according to the one-dimensional compressible Euler equations.\n    *   Conversions between conservative variables $u=[\\rho, \\rho u, \\rho E]^T$ and primitive variables $[\\rho, u, p]$.\n    *   The physical flux $f(u) = [\\rho u, \\rho u^2 + p, u (\\rho E + p)]^T$.\n    *   Computation of the entropy variables $v(u) = \\nabla_u \\eta(u)$ from the conservative state $u$. The entropy variables are derived from the specified convex entropy function $\\eta(u)$ and are found to be $v = [(\\gamma-s)/(\\gamma-1) - \\rho u^2/(2p), \\rho u/p, -\\rho/p]^T$, where $s = \\ln(p/\\rho^\\gamma)$.\n\n3.  **Entropy-Conservative Flux**: Chandrashekar's entropy-conservative two-point flux, $h_{EC}(u_L, u_R)$, is implemented. This flux is crucial for the scheme's stability properties. Its formulation relies on specific averages of the fluid properties from the left ($L$) and right ($R$) states. Specifically, we use arithmetic means $\\overline{(\\cdot)}$, a logarithmic mean $\\overline{(\\cdot)}^{\\ln}$, and a special pressure average $\\overline{p} = (\\rho_L+\\rho_R) / (\\rho_L/p_L + \\rho_R/p_R)$. The flux components are:\n    $$ f_1^* = \\overline{\\rho}^{\\ln} \\overline{u} $$\n    $$ f_2^* = \\overline{p} + \\overline{u} f_1^* $$\n    $$ f_3^* = \\overline{u}\\left( \\frac{\\gamma\\overline{p}}{\\gamma-1} + \\frac{1}{2}\\overline{\\rho}^{\\ln}\\overline{u^2} \\right) $$\n\n4.  **DGSEM Residual Assembly**: The semi-discrete form of the DGSEM is assembled to compute the time derivative of the solution, $\\partial u_i / \\partial t$, at each node $i$. This involves two main parts for each element:\n    *   **Volume Integral**: A flux-differencing term, $-\\frac{2}{J_K}\\sum_{j=0}^N D_{ij}\\,h_{EC}(u_i,u_j)$, which approximates the divergence of the flux within the element.\n    *   **Surface Integral**: A term to couple adjacent elements, $\\frac{1}{J_K} B_{ii}\\left(f^\\ast_{\\partial K} - f(u_i)\\right)$, penalizing the difference between the interface flux $f^\\ast$ and the physical flux $f(u_i)$ at the element boundaries. For periodic boundary conditions, the interface flux at an element boundary is constructed using Chandrashekar's flux $h_{EC}$ applied to the interior state and the state from the corresponding periodic neighbor.\n\n5.  **Entropy Conservation Verification**: The core task is to compute the discrete total entropy production rate and verify that it is negligible. The rate is given by the chain rule applied to the total discrete entropy:\n    $$ \\frac{d\\mathcal{E}}{dt} = \\frac{d}{dt}\\sum_{K} J_K \\sum_{i=0}^N w_i \\eta(u_{K,i}) = \\sum_K J_K \\sum_{i=0}^N w_i \\, v(u_{K,i})^T \\frac{\\partial u_{K,i}}{\\partial t} $$\n    The term $\\partial u_{K,i} / \\partial t$ is the DGSEM residual computed in the previous step. For an entropy-conservative scheme on a periodic domain, this quantity is theoretically zero. The implementation calculates this sum and checks if its magnitude is below a numerical tolerance of $\\tau=10^{-10}$.\n\n6.  **Test Execution**: The procedure is applied to the four test cases specified in the problem statement, covering constant states, smooth perturbations, and random perturbations. For each case, the initial conditions are set up, the DGSEM residual is computed, the entropy rate is calculated, and the result is compared against the tolerance. A list of boolean outcomes is then generated.", "answer": "```python\nimport numpy as np\nfrom scipy.special import legendre, roots_jacobi\n\ndef solve():\n    \"\"\"\n    Main function to run the DGSEM entropy conservation verification.\n    \"\"\"\n    \n    # Test suite from problem statement\n    TEST_SUITE = [\n        {'gamma': 1.4, 'N': 4, 'K_el': 4, 'case': 'constant'},\n        {'gamma': 1.4, 'N': 5, 'K_el': 3, 'case': 'smooth_pert'},\n        {'gamma': 1.4, 'N': 3, 'K_el': 5, 'case': 'random_pert'},\n        {'gamma': 1.4, 'N': 2, 'K_el': 2, 'case': 'bdy_res'}\n    ]\n    TOLERANCE = 1e-10\n    LOGMEAN_EPS = 1e-5\n\n    # --- Start of Helper Functions ---\n    \n    def legendre_gauss_lobatto(N):\n        \"\"\"\n        Computes Legendre-Gauss-Lobatto nodes and weights on [-1, 1].\n        \"\"\"\n        if N == 0:\n            return np.array([0.0]), np.array([2.0])\n        if N == 1:\n            return np.array([-1.0, 1.0]), np.array([1.0, 1.0])\n\n        interior_nodes, _ = roots_jacobi(N - 1, 1, 1)\n        nodes = np.sort(np.concatenate(([-1.0], interior_nodes, [1.0])))\n        \n        Pn = legendre(N)\n        weights = 2 / (N * (N + 1) * Pn(nodes)**2)\n        return nodes, weights\n\n    def differentiation_matrix(N, nodes):\n        \"\"\"\n        Computes the differentiation matrix for Lagrange basis on LGL nodes.\n        \"\"\"\n        D = np.zeros((N + 1, N + 1))\n        Pn = legendre(N)\n        for i in range(N + 1):\n            for j in range(N + 1):\n                if i != j:\n                    D[i, j] = Pn(nodes[i]) / (Pn(nodes[j]) * (nodes[i] - nodes[j]))\n        \n        for i in range(N + 1):\n            D[i, i] = -np.sum(D[i, :])\n        return D\n\n    def sbp_check(N, D, M, B):\n        \"\"\"\n        Verifies the SBP property: M D + D^T M = B.\n        \"\"\"\n        err = np.linalg.norm(M @ D + D.T @ M - B)\n        if err > 1e-12:\n            raise RuntimeError(f\"SBP property check failed for N={N}. Error: {err}\")\n\n    def prim_to_cons(rho, u, p, gamma):\n        rho_u = rho * u\n        rho_E = p / (gamma - 1) + 0.5 * rho * u**2\n        return np.stack([rho, rho_u, rho_E], axis=-1)\n\n    def cons_to_prim(U, gamma):\n        rho = U[..., 0]\n        rho_u = U[..., 1]\n        rho_E = U[..., 2]\n        \n        # Add a small stabilization for division by zero\n        rho_stable = rho + 1e-40\n\n        u = rho_u / rho_stable\n        p = (gamma - 1) * (rho_E - 0.5 * rho * u**2)\n        return rho, u, p\n\n    def cons_to_entropy_vars(U, gamma):\n        rho, u, p = cons_to_prim(U, gamma)\n        s = np.log(p) - gamma * np.log(rho)\n        v1 = (gamma - s) / (gamma - 1) - 0.5 * rho * u**2 / p\n        v2 = rho * u / p\n        v3 = -rho / p\n        return np.stack([v1, v2, v3], axis=-1)\n\n    def physical_flux(U, gamma):\n        rho, u, p = cons_to_prim(U, gamma)\n        rho_E = U[..., 2]\n        \n        f1 = rho * u\n        f2 = rho * u**2 + p\n        f3 = (rho_E + p) * u\n        return np.stack([f1, f2, f3], axis=-1)\n\n    def logmean(a, b, epsilon=LOGMEAN_EPS):\n        a_ = np.asarray(a)\n        b_ = np.asarray(b)\n        out = np.zeros_like(a_, dtype=np.promote_types(a_.dtype, b_.dtype))\n\n        ratio = np.divide(b_, a_, where=a_!=0)\n        idx_close = np.abs(ratio - 1.0) < epsilon\n\n        # Non-broadcasted part\n        if a_.ndim == 0:\n            if idx_close: return (a_ + b_) / 2.0\n            return (a_ - b_) / (np.log(a_) - np.log(b_))\n        \n        out[idx_close] = (a_[idx_close] + b_[idx_close]) / 2.0\n        \n        idx_not_close = ~idx_close\n        a_nc, b_nc = a_[idx_not_close], b_[idx_not_close]\n        \n        # Handle cases where a_nc or b_nc could be zero\n        log_a = np.log(a_nc, where=a_nc>0)\n        log_b = np.log(b_nc, where=b_nc>0)\n\n        out[idx_not_close] = (a_nc - b_nc) / (log_a - log_b)\n        \n        return out\n\n    def chandrashekar_ec_flux(u_L, u_R, gamma):\n        rho_L, u_L, p_L = cons_to_prim(u_L, gamma)\n        rho_R, u_R, p_R = cons_to_prim(u_R, gamma)\n\n        rho_ln = logmean(rho_L, rho_R)\n        u_mean = 0.5 * (u_L + u_R)\n        u_sq_mean = 0.5 * (u_L**2 + u_R**2)\n\n        # Harmonic mean of pressure weighted by density\n        p_mean = (rho_L + rho_R) / (rho_L / p_L + rho_R / p_R)\n        \n        f1 = rho_ln * u_mean\n        f2 = p_mean + u_mean * f1\n        f3 = u_mean * (gamma * p_mean / (gamma - 1) + 0.5 * rho_ln * u_sq_mean)\n        \n        return np.stack([f1, f2, f3], axis=-1)\n\n    def dgsem_residual(u_all, K_el, N, D, gamma, Jk):\n        residual = np.zeros_like(u_all)\n        \n        for k in range(K_el):\n            u_k = u_all[k, :, :]\n            h_matrix = np.array([[chandrashekar_ec_flux(u_k[i], u_k[j], gamma) for j in range(N + 1)] for i in range(N + 1)])\n            vol_term = -2.0 / Jk * np.einsum('ij,ijk->ik', D, h_matrix)\n            residual[k, :, :] += vol_term\n\n        for k in range(K_el):\n            k_neighbor_L = (k - 1 + K_el) % K_el\n            u_inner_L = u_all[k, 0, :]\n            u_outer_L = u_all[k_neighbor_L, N, :]\n            f_star_L = chandrashekar_ec_flux(u_outer_L, u_inner_L, gamma)\n            f_inner_L = physical_flux(u_inner_L, gamma)\n            residual[k, 0, :] += (1.0 / Jk) * (-1.0) * (f_star_L - f_inner_L)\n\n            k_neighbor_R = (k + 1) % K_el\n            u_inner_R = u_all[k, N, :]\n            u_outer_R = u_all[k_neighbor_R, 0, :]\n            f_star_R = chandrashekar_ec_flux(u_inner_R, u_outer_R, gamma)\n            f_inner_R = physical_flux(u_inner_R, gamma)\n            residual[k, N, :] += (1.0 / Jk) * (1.0) * (f_star_R - f_inner_R)\n            \n        return residual\n\n    def compute_total_entropy_rate(u_all, dudt, weights, Jk, gamma):\n        v_all = cons_to_entropy_vars(u_all, gamma)\n        integrand = np.einsum('kni,kni->kn', v_all, dudt)\n        elementwise_sum = np.sum(integrand * weights, axis=1)\n        total_rate = Jk * np.sum(elementwise_sum)\n        return total_rate\n\n    def run_test_case(params, test_seed):\n        gamma, N, K_el, case = params['gamma'], params['N'], params['K_el'], params['case']\n        \n        nodes_ref, weights = legendre_gauss_lobatto(N)\n        D = differentiation_matrix(N, nodes_ref)\n        \n        M = np.diag(weights)\n        B = np.diag([-1.] + [0.]*(N-1) + [1.]) if N > 0 else np.diag([-1.0])\n        sbp_check(N, D, M, B)\n        \n        dx = 1.0 / K_el\n        Jk = dx / 2.0\n        x_nodes = np.array([k * dx + dx * (nodes_ref + 1) / 2.0 for k in range(K_el)])\n\n        u_all = np.zeros((K_el, N + 1, 3))\n        \n        rho_vals, u_vals, p_vals = None, None, None\n\n        if case == 'constant':\n            rho_vals = np.full_like(x_nodes, 1.0)\n            u_vals = np.full_like(x_nodes, 0.3)\n            p_vals = np.full_like(x_nodes, 1.0)\n        elif case == 'smooth_pert':\n            rho_vals = 1.0 + 0.01 * np.cos(2 * np.pi * x_nodes)\n            u_vals = 0.5 + 0.05 * np.sin(2 * np.pi * x_nodes)\n            p_vals = 1.0 + 0.02 * np.cos(2 * np.pi * x_nodes + 0.3)\n        elif case == 'random_pert':\n            rng = np.random.default_rng(test_seed)\n            rho_vals = 1.0 + 1e-3 * rng.uniform(-1, 1, size=(K_el, N + 1))\n            u_vals = 0.2 + 1e-3 * rng.uniform(-1, 1, size=(K_el, N + 1))\n            p_vals = 1.0 + 1e-3 * rng.uniform(-1, 1, size=(K_el, N + 1))\n        elif case == 'bdy_res':\n            rho_vals = 1.0 + 0.005 * np.sin(4 * np.pi * x_nodes)\n            u_vals = 0.1 + 0.005 * np.cos(4 * np.pi * x_nodes)\n            p_vals = 1.0 + 0.005 * np.sin(4 * np.pi * x_nodes)\n\n        # Ensure positivity of pressure (and density)\n        min_p = np.min(p_vals)\n        if min_p < 0.5:\n            p_vals += (0.5 - min_p)\n        min_rho = np.min(rho_vals)\n        if min_rho <= 0:\n            rho_vals += (-min_rho + 1e-6)\n\n        u_all = prim_to_cons(rho_vals, u_vals, p_vals, gamma)\n\n        dudt = dgsem_residual(u_all, K_el, N, D, gamma, Jk)\n        rate = compute_total_entropy_rate(u_all, dudt, weights, Jk, gamma)\n        \n        return abs(rate) < TOLERANCE\n\n    # --- End of Helper Functions ---\n\n    results = []\n    # Use a fixed seed for the random test case to ensure reproducibility\n    random_test_seed = 42\n    for params in TEST_SUITE:\n        result = run_test_case(params, random_test_seed)\n        results.append(str(result).lower())\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3384472"}]}