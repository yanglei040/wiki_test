{"hands_on_practices": [{"introduction": "The foundation of many wall models for Large Eddy Simulation (LES) rests on the equilibrium logarithmic law of the wall. This practice guides you through the essential task of implementing such a model, which requires inverting the log-law to determine the wall shear stress from a velocity measurement at the first off-wall grid point. By completing this exercise [@problem_id:3427246], you will not only build a functional wall model but also derive and compute its sensitivity to the empirical constants, providing critical insight into model uncertainty.", "problem": "Consider an incompressible, fully developed turbulent plane channel flow simulated with Large Eddy Simulation (LES, Large Eddy Simulation) using a high-order Spectral Element Method (SEM, Spectral Element Method) or Discontinuous Galerkin (DG, Discontinuous Galerkin) discretization, where the first off-wall solution point is located at wall-unit distance $y^{+}\\approx 50$. A minimal functional wall model is desired to supply the wall shear stress $\\tau_{w}$ to the numerical scheme without resolving the viscous sublayer. You are to construct and implement the following model and associated sensitivity analysis as a self-contained program.\n\nStarting from the standard definitions of wall scaling,\n- the friction velocity $u_{\\tau}$ satisfies $\\tau_{w}=\\rho\\,u_{\\tau}^{2}$,\n- the inner-scaled velocity is $U^{+}=U/u_{\\tau}$,\n- the inner-scaled wall-normal distance is $y^{+}=y\\,u_{\\tau}/\\nu$,\nand the overlap-layer logarithmic law of the wall,\n$$\nU^{+}=\\frac{1}{\\kappa}\\ln(y^{+})+B,\n$$\nderive a nonlinear equation for the unknown $u_{\\tau}$ in terms of the measurable local LES-resolved streamwise velocity magnitude $U$, the wall-normal distance $y$, the kinematic viscosity $\\nu$, the fluid density $\\rho$, and the model constants $\\kappa$ and $B$. Establish existence and uniqueness of a physically admissible solution $u_{\\tau} > 0$ by analyzing the monotonicity of the resulting scalar residual.\n\nThen, design a robust root-finding algorithm based only on first principles to compute $u_{\\tau}$ for given parameters. Your algorithm must use a bracketing strategy that guarantees convergence for any positive inputs and may combine bisection with Newton updates or use a safeguarded bisection method. Once $u_{\\tau}$ is obtained, compute the wall shear stress $\\tau_{w}$ in pascals (express the final $\\tau_{w}$ in $\\mathrm{Pa}$), and quantify the sensitivity of $\\tau_{w}$ to the model constants by implicitly differentiating your nonlinear equation to obtain the normalized sensitivities\n$$\nS_{\\kappa}=\\frac{\\partial \\ln \\tau_{w}}{\\partial \\kappa},\\qquad S_{B}=\\frac{\\partial \\ln \\tau_{w}}{\\partial B}.\n$$\nClearly state your expressions for these sensitivities in terms of the converged $u_{\\tau}$ and the inputs.\n\nYour program must implement the following for each test case:\n1. Form the nonlinear equation implied by the above model from the provided $U$, $y$, $\\nu$, $\\rho$, $\\kappa$, and $B$.\n2. Solve for $u_{\\tau}$ using a globally convergent scalar root-finding procedure with explicit bracketing.\n3. Compute $\\tau_{w}=\\rho\\,u_{\\tau}^{2}$ in $\\mathrm{Pa}$.\n4. Compute the normalized sensitivities $S_{\\kappa}$ and $S_{B}$ using the analytically derived implicit differentiation formulas evaluated at the converged $u_{\\tau}$.\n\nUse the following test suite of parameter values (covering a representative case, a near-buffer low-$y^{+}$ edge case for the logarithmic law, a coarse first-point case, and a model-constant variation for sensitivity assessment). All quantities must be interpreted in International System of Units (SI):\n- Case A (representative air flow at $y^{+}\\approx 50$): $U=8.0\\,\\mathrm{m/s}$, $y=0.002\\,\\mathrm{m}$, $\\nu=1.5\\times 10^{-5}\\,\\mathrm{m^{2}/s}$, $\\rho=1.2\\,\\mathrm{kg/m^{3}}$, $\\kappa=0.41$, $B=5.2$.\n- Case B (near-buffer edge case in water): $U=0.608\\,\\mathrm{m/s}$, $y=0.0002\\,\\mathrm{m}$, $\\nu=1.0\\times 10^{-6}\\,\\mathrm{m^{2}/s}$, $\\rho=1000.0\\,\\mathrm{kg/m^{3}}$, $\\kappa=0.41$, $B=5.2$.\n- Case C (coarse first-point air case): $U=6.08\\,\\mathrm{m/s}$, $y=0.005\\,\\mathrm{m}$, $\\nu=1.5\\times 10^{-5}\\,\\mathrm{m^{2}/s}$, $\\rho=1.2\\,\\mathrm{kg/m^{3}}$, $\\kappa=0.41$, $B=5.2$.\n- Case D (model-constant variation to probe sensitivity): $U=8.0\\,\\mathrm{m/s}$, $y=0.002\\,\\mathrm{m}$, $\\nu=1.5\\times 10^{-5}\\,\\mathrm{m^{2}/s}$, $\\rho=1.2\\,\\mathrm{kg/m^{3}}$, $\\kappa=0.384$, $B=4.17$.\n\nRequirements and numerical details:\n- Your derivation must begin only from the core definitions $U^{+}=U/u_{\\tau}$, $y^{+}=y\\,u_{\\tau}/\\nu$, $\\tau_{w}=\\rho u_{\\tau}^{2}$, and the logarithmic law $U^{+}=(1/\\kappa)\\ln(y^{+})+B$; do not assume any other empirical closure.\n- For the numerical solution, ensure positivity of $u_{\\tau}$ and bracket the root by demonstrating that the residual is positive as $u_{\\tau}\\to 0^{+}$ and negative for sufficiently large $u_{\\tau}$.\n- Express the final outputs for each case as a list of three floats $[\\tau_{w},S_{\\kappa},S_{B}]$, where $\\tau_{w}$ is in $\\mathrm{Pa}$ and $S_{\\kappa}$ and $S_{B}$ are dimensionless. No angles are involved. Do not include units in the numeric outputs.\n- Your program should produce a single line of output containing the results for all four cases as a comma-separated list enclosed in square brackets, where each case contributes one inner list. For example, your final output must have the form `[[τ_w^(A),S_κ^(A),S_B^(A)],[τ_w^(B),S_κ^(B),S_B^(B)],[τ_w^(C),S_κ^(C),S_B^(C)],[τ_w^(D),S_κ^(D),S_B^(D)]]` with floating-point numbers.", "solution": "The problem statement is critically evaluated for validity before proceeding to a solution.\n\n### Step 1: Extract Givens\n- **Context**: Incompressible, fully developed turbulent plane channel flow.\n- **Simulation Method**: Large Eddy Simulation (LES) with a high-order Spectral Element Method (SEM) or Discontinuous Galerkin (DG) method.\n- **Wall Model Position**: First off-wall point at $y^{+} \\approx 50$.\n- **Objective**: Construct a functional wall model to compute wall shear stress $\\tau_{w}$.\n- **Underlying Definitions**:\n    1. Friction velocity definition: $\\tau_{w} = \\rho u_{\\tau}^{2}$.\n    2. Inner-scaled velocity: $U^{+} = U/u_{\\tau}$.\n    3. Inner-scaled wall-normal distance: $y^{+} = y u_{\\tau}/\\nu$.\n- **Empirical Law**: Logarithmic law of the wall, $U^{+} = \\frac{1}{\\kappa}\\ln(y^{+}) + B$.\n- **Input Parameters**: Streamwise velocity $U$, wall-normal distance $y$, kinematic viscosity $\\nu$, fluid density $\\rho$.\n- **Model Constants**: von Kármán constant $\\kappa$, log-law intercept $B$.\n- **Primary Unknown**: Friction velocity $u_{\\tau}$.\n- **Tasks**:\n    1. Derive a nonlinear equation for $u_{\\tau}$.\n    2. Prove existence and uniqueness of a physically admissible solution $u_{\\tau} > 0$.\n    3. Design a robust, bracketing-based root-finding algorithm.\n    4. Compute $\\tau_{w}$ in Pascals ($\\mathrm{Pa}$).\n    5. Derive and compute the normalized sensitivities $S_{\\kappa} = \\frac{\\partial \\ln \\tau_{w}}{\\partial \\kappa}$ and $S_{B} = \\frac{\\partial \\ln \\tau_{w}}{\\partial B}$.\n- **Test Cases (SI units)**:\n    - **Case A**: $U=8.0$, $y=0.002$, $\\nu=1.5 \\times 10^{-5}$, $\\rho=1.2$, $\\kappa=0.41$, $B=5.2$.\n    - **Case B**: $U=0.608$, $y=0.0002$, $\\nu=1.0 \\times 10^{-6}$, $\\rho=1000.0$, $\\kappa=0.41$, $B=5.2$.\n    - **Case C**: $U=6.08$, $y=0.005$, $\\nu=1.5 \\times 10^{-5}$, $\\rho=1.2$, $\\kappa=0.41$, $B=5.2$.\n    - **Case D**: $U=8.0$, $y=0.002$, $\\nu=1.5 \\times 10^{-5}$, $\\rho=1.2$, $\\kappa=0.384$, $B=4.17$.\n- **Output Format**: For each case, a list of three floats $[\\tau_{w}, S_{\\kappa}, S_{B}]$. The final output is a single line containing a list of these lists.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is evaluated against the validation criteria.\n- **Scientifically Grounded**: The problem is based on fundamental principles of turbulent boundary layer theory, specifically the law of the wall, which is a cornerstone of wall-modeling in LES. The definitions and relationships are standard in fluid mechanics. All physical parameters and constants are realistic.\n- **Well-Posed**: The problem is well-posed. It requests the derivation and solution of a single nonlinear scalar equation for a single unknown, $u_{\\tau}$. All inputs required for the calculation ($U$, $y$, $\\nu$, $\\rho$, $\\kappa$, $B$) are provided. The tasks of analyzing the solution's existence/uniqueness and calculating sensitivities are standard mathematical procedures.\n- **Objective**: The problem is stated in precise, technical, and unbiased language, free of any subjective claims.\n\nThe problem does not exhibit any of the defined invalidity flaws. It is scientifically sound, formalizable, complete, realistic, and well-structured.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. A full solution will be provided.\n\n### Solution Derivation and Analysis\n\n**1. Derivation of the Nonlinear Equation for $u_{\\tau}$**\n\nWe begin with the logarithmic law of the wall:\n$$\nU^{+} = \\frac{1}{\\kappa}\\ln(y^{+}) + B\n$$\nThe definitions of the inner-scaled quantities are substituted into this equation:\n$$\n\\frac{U}{u_{\\tau}} = \\frac{1}{\\kappa}\\ln\\left(\\frac{y u_{\\tau}}{\\nu}\\right) + B\n$$\nwhere $U$, $y$, $\\nu$, $\\kappa$, and $B$ are known parameters and $u_{\\tau}$ is the unknown variable. This is the implicit, nonlinear equation for the friction velocity $u_{\\tau}$. To solve it numerically, we define a residual function $f(u_{\\tau})$ whose root is the solution. For robustness and to align with the problem's suggestion for bracketing, we define the residual as:\n$$\nf(u_{\\tau}) = U - u_{\\tau} \\left[ \\frac{1}{\\kappa}\\ln\\left(\\frac{y u_{\\tau}}{\\nu}\\right) + B \\right]\n$$\nThe solution to the wall model is the value of $u_{\\tau} > 0$ for which $f(u_{\\tau}) = 0$.\n\n**2. Existence and Uniqueness of the Solution**\n\nTo establish the existence and uniqueness of a physically admissible solution ($u_{\\tau} > 0$), we analyze the behavior of the residual function $f(u_{\\tau})$.\n\n- **Behavior as $u_{\\tau} \\to 0^{+}$**:\nThe term $u_{\\tau}\\ln(u_{\\tau})$ is an indeterminate form $0 \\cdot (-\\infty)$. We analyze its limit using L'Hôpital's rule:\n$$\n\\lim_{u_{\\tau} \\to 0^{+}} u_{\\tau}\\ln(u_{\\tau}) = \\lim_{u_{\\tau} \\to 0^{+}} \\frac{\\ln(u_{\\tau})}{1/u_{\\tau}} = \\lim_{u_{\\tau} \\to 0^{+}} \\frac{1/u_{\\tau}}{-1/u_{\\tau}^2} = \\lim_{u_{\\tau} \\to 0^{+}} (-u_{\\tau}) = 0\n$$\nApplying this to our residual function:\n$$\n\\lim_{u_{\\tau} \\to 0^{+}} f(u_{\\tau}) = U - \\lim_{u_{\\tau} \\to 0^{+}} \\left[ \\frac{u_{\\tau}}{\\kappa} \\left(\\ln\\left(\\frac{y}{\\nu}\\right) + \\ln(u_{\\tau})\\right) + B u_{\\tau} \\right] = U - 0 = U\n$$\nSince the velocity $U$ is strictly positive, $f(u_{\\tau})$ is positive as $u_{\\tau}$ approaches $0$ from the right.\n\n- **Behavior as $u_{\\tau} \\to \\infty$**:\nAs $u_{\\tau}$ becomes very large, the logarithmic term $\\ln(u_{\\tau})$ also grows, but slower than $u_{\\tau}$. The product $u_{\\tau}\\ln(u_{\\tau})$ grows to infinity. Therefore:\n$$\n\\lim_{u_{\\tau} \\to \\infty} f(u_{\\tau}) = U - \\infty = -\\infty\n$$\n\n- **Monotonicity**:\nWe examine the derivative of $f(u_{\\tau})$ with respect to $u_{\\tau}$:\n$$\nf'(u_{\\tau}) = \\frac{d}{du_{\\tau}} \\left( U - \\frac{u_{\\tau}}{\\kappa}\\ln\\left(\\frac{y u_{\\tau}}{\\nu}\\right) - B u_{\\tau} \\right)\n$$\nUsing the product rule for the term $\\frac{u_{\\tau}}{\\kappa}\\ln\\left(\\frac{y u_{\\tau}}{\\nu}\\right)$:\n$$\nf'(u_{\\tau}) = - \\left[ \\left(\\frac{1}{\\kappa}\\ln\\left(\\frac{y u_{\\tau}}{\\nu}\\right) + \\frac{u_{\\tau}}{\\kappa}\\frac{1}{u_{\\tau}}\\right) + B \\right] = - \\left[ \\frac{1}{\\kappa}\\ln(y^{+}) + \\frac{1}{\\kappa} + B \\right]\n$$\nThe logarithmic law is applied in the overlap layer, where $y^{+}$ is sufficiently large (e.g., $y^{+} > 30$) for $\\ln(y^{+})$ to be positive. The model constants $\\kappa$ and $B$ are also positive. Consequently, the term inside the square brackets is strictly positive for any physically relevant $u_{\\tau}$. This implies that $f'(u_{\\tau})  0$ for all $u_{\\tau} > 0$.\n\n- **Conclusion**:\nThe function $f(u_{\\tau})$ is continuous for $u_{\\tau} > 0$, positive as $u_{\\tau} \\to 0^{+}$, tends to $-\\infty$ as $u_{\\tau} \\to \\infty$, and is strictly monotonically decreasing. By the Intermediate Value Theorem, there must be at least one root. Because the function is strictly monotonic, this root is unique. This guarantees the existence and uniqueness of a physically admissible solution $u_{\\tau} > 0$.\n\n**3. Derivation of Sensitivity Expressions**\n\nWe are asked to find the normalized sensitivities $S_{\\kappa} = \\frac{\\partial \\ln \\tau_{w}}{\\partial \\kappa}$ and $S_{B} = \\frac{\\partial \\ln \\tau_{w}}{\\partial B}$.\nFrom $\\tau_{w} = \\rho u_{\\tau}^2$, we have $\\ln \\tau_{w} = \\ln \\rho + 2 \\ln u_{\\tau}$. Differentiating with respect to a parameter $p$ (where $p$ is $\\kappa$ or $B$) gives:\n$$\n\\frac{\\partial \\ln \\tau_{w}}{\\partial p} = \\frac{2}{u_{\\tau}} \\frac{\\partial u_{\\tau}}{\\partial p}\n$$\nWe find $\\frac{\\partial u_{\\tau}}{\\partial p}$ by implicit differentiation of the governing equation, which we write as $G(u_{\\tau}, \\kappa, B) = 0$:\n$$\nG = \\frac{U}{u_{\\tau}} - \\frac{1}{\\kappa}\\ln\\left(\\frac{y u_{\\tau}}{\\nu}\\right) - B = 0\n$$\nThe general formula from implicit differentiation is $\\frac{\\partial u_{\\tau}}{\\partial p} = - \\frac{\\partial G/\\partial p}{\\partial G/\\partial u_{\\tau}}$.\nFirst, we compute the partial derivative with respect to $u_{\\tau}$:\n$$\n\\frac{\\partial G}{\\partial u_{\\tau}} = -\\frac{U}{u_{\\tau}^2} - \\frac{1}{\\kappa u_{\\tau}} = -\\frac{1}{u_{\\tau}} \\left(\\frac{U}{u_{\\tau}} + \\frac{1}{\\kappa}\\right)\n$$\nNext, we compute the partial derivatives with respect to $\\kappa$ and $B$:\n$$\n\\frac{\\partial G}{\\partial \\kappa} = \\frac{1}{\\kappa^2}\\ln\\left(\\frac{y u_{\\tau}}{\\nu}\\right)\n\\quad , \\quad\n\\frac{\\partial G}{\\partial B} = -1\n$$\nNow we can find the sensitivities.\n\n- **Sensitivity to $B$**:\n$$\n\\frac{\\partial u_{\\tau}}{\\partial B} = - \\frac{-1}{-\\frac{1}{u_{\\tau}} \\left(\\frac{U}{u_{\\tau}} + \\frac{1}{\\kappa}\\right)} = -\\frac{u_{\\tau}}{U/u_{\\tau} + 1/\\kappa}\n$$\nThe normalized sensitivity $S_B$ is then:\n$$\nS_{B} = \\frac{2}{u_{\\tau}} \\frac{\\partial u_{\\tau}}{\\partial B} = \\frac{2}{u_{\\tau}} \\left( -\\frac{u_{\\tau}}{U/u_{\\tau} + 1/\\kappa} \\right) = -\\frac{2}{U/u_{\\tau} + 1/\\kappa}\n$$\n\n- **Sensitivity to $\\kappa$**:\n$$\n\\frac{\\partial u_{\\tau}}{\\partial \\kappa} = - \\frac{\\frac{1}{\\kappa^2}\\ln(y u_{\\tau}/\\nu)}{-\\frac{1}{u_{\\tau}} \\left(\\frac{U}{u_{\\tau}} + \\frac{1}{\\kappa}\\right)} = \\frac{u_{\\tau} \\ln(y u_{\\tau}/\\nu)}{\\kappa^2 (U/u_{\\tau} + 1/\\kappa)}\n$$\nTo simplify, we use the fact that at the solution, $\\frac{1}{\\kappa}\\ln(y u_{\\tau}/\\nu) = U/u_{\\tau} - B$.\n$$\n\\frac{\\partial u_{\\tau}}{\\partial \\kappa} =  \\frac{u_{\\tau} \\kappa(U/u_{\\tau} - B)}{\\kappa^2 (U/u_{\\tau} + 1/\\kappa)} = \\frac{u_{\\tau}(U/u_{\\tau} - B)}{\\kappa (U/u_{\\tau} + 1/\\kappa)}\n$$\nThe normalized sensitivity $S_\\kappa$ is then:\n$$\nS_{\\kappa} = \\frac{2}{u_{\\tau}} \\frac{\\partial u_{\\tau}}{\\partial \\kappa} = \\frac{2(U/u_{\\tau} - B)}{\\kappa (U/u_{\\tau} + 1/\\kappa)}\n$$\nThese final expressions for $S_B$ and $S_\\kappa$ depend only on the converged solution $u_{\\tau}$ and the input parameters, and are efficient to compute.\n\n**4. Numerical Implementation Strategy**\nThe unique root of $f(u_{\\tau})=0$ can be found robustly using a bracketing algorithm.\n- **Bracket**: We established that $f(u_{\\tau})>0$ for $u_{\\tau} \\to 0^{+}$ and $f(u_{\\tau})0$ for large $u_{\\tau}$. A suitable bracket is $[u_{low}, u_{high}]$. We can choose a small positive number for $u_{low}$ (e.g., $10^{-8}$) and the measurable velocity $U$ for $u_{high}$, as it is physically expected that $u_{\\tau} \\ll U$. Test calculations confirm that $f(U)0$ for the given parameter ranges.\n- **Algorithm**: A standard, globally convergent algorithm such as Brent's method is ideal. This method, available in `SciPy` as `scipy.optimize.brentq`, combines the safety of bisection with the speed of secant and inverse quadratic interpolation methods, making it robust and efficient.\n- **Procedure**: For each test case, the program will:\n    1. Define the residual function $f(u_{\\tau})$.\n    2. Solve for $u_{\\tau}$ using `brentq` within the bracket $[10^{-8}, U]$.\n    3. Compute $\\tau_{w} = \\rho u_{\\tau}^2$.\n    4. Compute $S_{\\kappa}$ and $S_{B}$ using the derived analytical formulas evaluated at the computed $u_{\\tau}$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import optimize\n\ndef solve():\n    \"\"\"\n    Solves for wall shear stress and model sensitivities for a series of test cases\n    based on a logarithmic law of the wall model.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (U, y, nu, rho, kappa, B) in SI units.\n    test_cases = [\n        # Case A: representative air flow\n        (8.0, 0.002, 1.5e-5, 1.2, 0.41, 5.2),\n        # Case B: near-buffer edge case in water\n        (0.608, 0.0002, 1.0e-6, 1000.0, 0.41, 5.2),\n        # Case C: coarse first-point air case\n        (6.08, 0.005, 1.5e-5, 1.2, 0.41, 5.2),\n        # Case D: model-constant variation to probe sensitivity\n        (8.0, 0.002, 1.5e-5, 1.2, 0.384, 4.17),\n    ]\n\n    results = []\n    \n    # Machine epsilon can be used for a robust lower bound close to zero.\n    machine_epsilon = np.finfo(float).eps\n\n    for case in test_cases:\n        U, y, nu, rho, kappa, B = case\n\n        # 1. Form the nonlinear equation f(u_tau) = 0\n        # The residual function f(u_tau) = U - u_tau * ( (1/kappa)*ln(y*u_tau/nu) + B )\n        # is defined for u_tau  0.\n        def residual(u_tau):\n            # Check for domain of log\n            if u_tau = 0:\n                # Return a large positive value to guide the solver away from non-physical domain,\n                # consistent with the limit of the function as u_tau - 0+.\n                return U\n            \n            y_plus_term = y * u_tau / nu\n            log_term = np.log(y_plus_term)\n            u_plus = (1.0 / kappa) * log_term + B\n            \n            return U - u_tau * u_plus\n\n        # 2. Solve for u_tau using a globally convergent scalar root-finding procedure.\n        # We bracket the root. As shown in the derivation, the residual is positive\n        # for u_tau - 0+ and becomes negative for large u_tau. U itself serves\n        # as a safe upper bound, since u_tau  U in all physical flows.\n        lower_bound = machine_epsilon # A small positive number\n        upper_bound = U # Physical upper bound\n        \n        try:\n            # Brent's method is robust and guarantees convergence if the root is bracketed.\n            u_tau = optimize.brentq(residual, lower_bound, upper_bound, xtol=1e-12, rtol=1e-12)\n        except ValueError:\n            # This should not happen given the analysis of the residual function.\n            # However, it is good practice to handle potential solver failures.\n            u_tau = np.nan\n            tau_w = np.nan\n            S_kappa = np.nan\n            S_B = np.nan\n            results.append([tau_w, S_kappa, S_B])\n            continue\n\n        # 3. Compute tau_w in Pascals.\n        tau_w = rho * u_tau**2\n\n        # 4. Compute the normalized sensitivities S_kappa and S_B.\n        # These formulas were derived via implicit differentiation.\n        U_over_u_tau = U / u_tau\n        \n        # Denominator for both sensitivities\n        common_denominator = U_over_u_tau + (1.0 / kappa)\n        \n        # Sensitivity to B\n        S_B = -2.0 / common_denominator\n        \n        # Sensitivity to kappa\n        # This form is computationally efficient as it reuses U_over_u_tau\n        S_kappa = (2.0 * (U_over_u_tau - B)) / (kappa * common_denominator)\n        \n        results.append([tau_w, S_kappa, S_B])\n\n    # Format the final output string as per the problem specification.\n    # e.g., [[val1,val2,val3],[val4,val5,val6],...]\n    results_str_parts = []\n    for res in results:\n        # Format each float to a reasonable precision for clean output.\n        results_str_parts.append(f\"[{res[0]},{res[1]},{res[2]}]\")\n    \n    final_output_str = f\"[{','.join(results_str_parts)}]\"\n\n    print(final_output_str)\n\nsolve()\n```", "id": "3427246"}, {"introduction": "The accuracy of a wall-modeled simulation depends critically on the fidelity of the underlying numerical scheme, especially in how it computes near-wall gradients. This exercise [@problem_id:3427163] explores the subtle but significant issue of aliasing error in Discontinuous Galerkin methods, which can arise from inexact numerical integration. You will use a manufactured solution to demonstrate how aliasing corrupts wall gradient calculations and derive the necessary quadrature accuracy to eliminate this error, ensuring your numerical method is robust.", "problem": "Consider one-dimensional wall-normal flow in the first element adjacent to a solid wall, parameterized by the coordinate $y \\in [0,1]$ with the wall located at $y=0$. Let the near-wall velocity profile inside this element be represented by the manufactured field\n$$\nu(y) = u_{1}\\, y + c\\, \\phi_{2p}(y),\n$$\nwhere $u_{1}  0$ and $c \\neq 0$ are constants, $p \\in \\mathbb{N}$ is the chosen polynomial degree of the local approximation space, and $\\phi_{n}(y) = P_{n}(2y-1)$ denotes the shifted Legendre polynomial of degree $n$ formed from the Legendre polynomial $P_{n}(x)$ on $[-1,1]$. The Discontinuous Galerkin (DG) approximation in this element uses a modal basis $\\{\\phi_{n}\\}_{n=0}^{p}$ and computes the $L^{2}$ projection coefficients\n$$\na_{n} = \\frac{\\int_{0}^{1} u(y)\\, \\phi_{n}(y)\\, dy}{\\int_{0}^{1} \\phi_{n}(y)^{2}\\, dy}, \\quad n=0,1,\\dots,p,\n$$\nby replacing the integrals with Gauss–Lobatto–Legendre (GLL) quadrature having $N_{q}$ points. The GLL rule with $N_{q}$ points is known to integrate exactly any polynomial integrand up to total degree $2N_{q}-3$. The wall-normal gradient inferred from the projected polynomial $u_{p}(y)=\\sum_{n=0}^{p} a_{n}\\, \\phi_{n}(y)$ is\n$$\n\\left.\\frac{\\partial u_{p}}{\\partial y}\\right|_{y=0} = \\sum_{n=0}^{p} a_{n}\\, \\phi'_{n}(0).\n$$\n\nStarting from the orthogonality of Legendre polynomials on $[0,1]$ under the standard $L^{2}$ inner product, and the fact that exact integration yields $\\int_{0}^{1} \\phi_{m}(y)\\, \\phi_{n}(y)\\, dy = 0$ for $m \\neq n$, do the following:\n\n1. Show that, under exact integration, the unresolved component $\\phi_{2p}(y)$ is orthogonal to every $\\phi_{n}(y)$ for $n \\leq p$, so that the contribution of $c\\, \\phi_{2p}(y)$ to the DG projection coefficients $a_{n}$ is zero for all $n \\leq p$, and therefore the wall-normal gradient at $y=0$ equals $u_{1}$ exactly.\n\n2. Show that when the projection integrals are evaluated by GLL quadrature with $N_{q} = p+1$ points (the standard collocation choice for degree $p$), the orthogonality integrals $\\int_{0}^{1} \\phi_{2p}(y)\\, \\phi_{n}(y)\\, dy$ for $n \\leq p$ need not be integrated exactly because the integrand degree is $2p+n$, which exceeds the exactness degree $2N_{q}-3=2p-1$ for some $n$. Conclude that aliasing produces spurious nonzero $a_{n}$, $n \\leq p$, thereby corrupting $\\left.\\partial u_{p}/\\partial y\\right|_{y=0}$.\n\n3. Derive the minimal number of GLL quadrature points $N_{q}$ required to guarantee that all inner products $\\int_{0}^{1} \\phi_{2p}(y)\\, \\phi_{n}(y)\\, dy$ for $n=0,1,\\dots,p$ are integrated exactly, so that the aliasing contribution of $c\\, \\phi_{2p}(y)$ to the projected polynomial vanishes and $\\left.\\partial u_{p}/\\partial y\\right|_{y=0}$ remains equal to $u_{1}$. Express $N_{q}$ as a closed-form function of $p$.\n\nIn addition, starting from the weak form of a model nonlinear conservation law such as the viscous Burgers equation with flux $f(u)=\\tfrac{1}{2}u^{2}$, outline how a symmetric split-form (flux differencing) within the element eliminates quadratic aliasing in the volume term by replacing $\\partial_{y} f(u)$ with a skew-symmetric discretization that enforces a discrete Summation-By-Parts property. Your derivation must begin from the weak form and the definition of the DG volume and surface terms. No shortcut formulas may be assumed without derivation. The final numerical answer to report is only the minimal $N_{q}$ as a function of $p$. No rounding is required and no units are involved in the final answer.", "solution": "The problem statement has been validated and is deemed a well-posed, scientifically grounded problem in the field of numerical analysis for partial differential equations. All necessary information is provided, and the questions are logically structured and answerable through rigorous mathematical derivation.\n\nThe problem investigates aliasing errors in a Discontinuous Galerkin (DG) method arising from the representation of a manufactured solution and the quadrature used for projections. It consists of three parts analyzing the aliasing error in the computation of a wall-normal velocity gradient and a fourth part outlining a technique to mitigate aliasing in nonlinear problems.\n\n**Part 1: Exact Integration**\n\nThe DG approximation computes the $L^{2}$ projection coefficients $a_{n}$ of the manufactured velocity field $u(y) = u_{1}\\, y + c\\, \\phi_{2p}(y)$ onto the basis $\\{\\phi_{n}\\}_{n=0}^{p}$. Under exact integration, the formula for the coefficients is:\n$$\na_{n} = \\frac{\\int_{0}^{1} u(y)\\, \\phi_{n}(y)\\, dy}{\\int_{0}^{1} \\phi_{n}(y)^{2}\\, dy}\n$$\nSubstituting the expression for $u(y)$, we get:\n$$\na_{n} = \\frac{\\int_{0}^{1} (u_{1}\\, y + c\\, \\phi_{2p}(y))\\, \\phi_{n}(y)\\, dy}{\\int_{0}^{1} \\phi_{n}(y)^{2}\\, dy} = \\frac{u_{1} \\int_{0}^{1} y\\, \\phi_{n}(y)\\, dy}{\\int_{0}^{1} \\phi_{n}(y)^{2}\\, dy} + \\frac{c \\int_{0}^{1} \\phi_{2p}(y)\\, \\phi_{n}(y)\\, dy}{\\int_{0}^{1} \\phi_{n}(y)^{2}\\, dy}\n$$\nThe basis functions $\\phi_{n}(y) = P_{n}(2y-1)$ are shifted Legendre polynomials, which are orthogonal on the interval $[0,1]$ with a weight of $1$. The orthogonality property states that for $m \\neq n$:\n$$\n\\int_{0}^{1} \\phi_{m}(y)\\, \\phi_{n}(y)\\, dy = 0\n$$\nWe are considering the projection onto the basis for $n=0, 1, \\dots, p$. The unresolved component of the velocity field is $c\\, \\phi_{2p}(y)$. Since $p \\in \\mathbb{N}$, we have $p \\geq 1$, which implies $2p > p$. Therefore, for any $n \\in \\{0, 1, \\dots, p\\}$, it holds that $n \\neq 2p$. Consequently, due to orthogonality, the integral in the second term is zero:\n$$\n\\int_{0}^{1} \\phi_{2p}(y)\\, \\phi_{n}(y)\\, dy = 0, \\quad \\forall n \\in \\{0, 1, \\dots, p\\}\n$$\nThis demonstrates that under exact integration, the contribution of the $c\\, \\phi_{2p}(y)$ component to all projection coefficients $a_{n}$ for $n \\leq p$ is exactly zero.\n\nThe coefficients are thus determined solely by the projection of the linear term $u_{1} y$:\n$$\na_{n} = \\frac{u_{1} \\int_{0}^{1} y\\, \\phi_{n}(y)\\, dy}{\\int_{0}^{1} \\phi_{n}(y)^{2}\\, dy}\n$$\nThe projected polynomial is $u_{p}(y)=\\sum_{n=0}^{p} a_{n}\\, \\phi_{n}(y)$. This is the best $L^{2}$ approximation of the function $u_{1} y$ in the space of polynomials of degree at most $p$, which is $\\mathbb{P}_{p}$. Since the function $u_{1} y$ is itself a polynomial of degree $1$, for any $p \\geq 1$, it is an element of the approximation space $\\mathbb{P}_{p}$. The best approximation of a function that is already in the space is the function itself. Therefore, with exact integration, the projected polynomial is exactly the linear part of the manufactured solution:\n$$\nu_{p}(y) = u_{1}\\, y\n$$\nThe wall-normal gradient at the wall ($y=0$) is then calculated as:\n$$\n\\left.\\frac{\\partial u_{p}}{\\partial y}\\right|_{y=0} = \\left.\\frac{\\partial}{\\partial y}(u_{1}\\, y)\\right|_{y=0} = u_{1}\n$$\nThis proves that with exact integration, the DG method perfectly recovers the wall gradient of the linear part of the velocity profile, unaffected by the higher-degree term.\n\n**Part 2: Aliasing with Standard Quadrature ($N_{q} = p+1$)**\n\nWhen the integrals are evaluated using Gauss–Lobatto–Legendre (GLL) quadrature with $N_{q}$ points, the integration is exact for polynomial integrands of degree up to $2N_{q}-3$. For the standard choice $N_{q} = p+1$, the maximum degree for exact integration is $2(p+1)-3 = 2p-1$.\n\nThe aliasing error originates from the numerical evaluation of the integral involving the unresolved component $\\phi_{2p}(y)$:\n$$\n\\int_{0}^{1} c\\, \\phi_{2p}(y)\\, \\phi_{n}(y)\\, dy, \\quad n \\in \\{0, 1, \\dots, p\\}\n$$\nThe integrand is a polynomial of degree $2p+n$. For this integral to be evaluated exactly by the GLL rule, the degree of the integrand must not exceed the degree of exactness of the rule:\n$$\n2p+n \\leq 2p-1 \\implies n \\leq -1\n$$\nThis condition is never met, as $n$ ranges from $0$ to $p$. The degree of the integrand ranges from $2p$ (for $n=0$) to $3p$ (for $n=p$), all of which are strictly greater than $2p-1$ for $p \\geq 1$.\n\nBecause the GLL quadrature rule is not exact for these integrands, the computed value of the integral will generally be non-zero due to aliasing. This means that the numerical projection will produce spurious, non-zero contributions to the coefficients $a_{n}$ from the $c\\, \\phi_{2p}(y)$ term. Let's denote these spurious contributions as $a_{n}^{\\text{alias}}$. The computed coefficients will be $a_{n} = a_{n}^{\\text{exact}} + a_{n}^{\\text{alias}}$, where $a_{n}^{\\text{exact}}$ are the coefficients from projecting $u_1 y$.\n\nThe resulting projected polynomial is $u_{p}(y) = u_{1} y + \\sum_{n=0}^{p} a_{n}^{\\text{alias}}\\, \\phi_{n}(y)$. The computed wall-normal gradient is then:\n$$\n\\left.\\frac{\\partial u_{p}}{\\partial y}\\right|_{y=0} = u_{1} + \\sum_{n=0}^{p} a_{n}^{\\text{alias}}\\, \\phi'_{n}(0)\n$$\nSince the $a_{n}^{\\text{alias}}$ are generally non-zero, the sum $\\sum_{n=0}^{p} a_{n}^{\\text{alias}}\\, \\phi'_{n}(0)$ constitutes an aliasing error that corrupts the computed wall gradient, which will no longer be equal to $u_{1}$.\n\n**Part 3: Minimal Quadrature Points for Exactness**\n\nTo eliminate this aliasing error, the number of GLL quadrature points $N_{q}$ must be sufficient to integrate all inner products $\\int_{0}^{1} \\phi_{2p}(y)\\, \\phi_{n}(y)\\, dy$ exactly for all $n=0, 1, \\dots, p$.\n\nThe integrand is the polynomial $\\phi_{2p}(y)\\, \\phi_{n}(y)$, which has a degree of $2p+n$. To ensure that all these integrals are exact, the quadrature rule must be exact for the polynomial of the highest degree that occurs in this set of integrals. The highest degree occurs for the largest value of $n$, which is $n=p$.\n$$\n\\text{deg}_{\\max} = 2p + p = 3p\n$$\nThe GLL quadrature rule with $N_{q}$ points is exact for polynomials of degree up to $2N_{q}-3$. To guarantee exact integration of the highest-degree polynomial, we must satisfy:\n$$\n2N_{q}-3 \\geq 3p\n$$\nSolving for $N_{q}$:\n$$\n2N_{q} \\geq 3p+3\n$$\n$$\nN_{q} \\geq \\frac{3p+3}{2}\n$$\nSince the number of quadrature points $N_{q}$ must be an integer, the minimal number of points required is the smallest integer satisfying this inequality, which is given by the ceiling function:\n$$\nN_{q, \\min} = \\left\\lceil \\frac{3p+3}{2} \\right\\rceil\n$$\nThis formula provides the minimal number of GLL quadrature points needed to de-alias the projection and ensure the computed wall gradient is exactly $u_{1}$.\n\n**Part 4: Outline of Split-Form DG for Nonlinear Aliasing**\n\nFor a model nonlinear conservation law like the viscous Burgers' equation, $\\partial_{t} u + \\partial_{y} f(u) - \\nu \\partial_{y}^2 u = 0$ with flux $f(u) = \\frac{1}{2}u^{2}$, the nonlinear advection term $\\partial_{y} f(u)$ is a source of instability in standard DG methods due to aliasing. A symmetric split-form, also known as a skew-symmetric formulation, can eliminate the instability caused by quadratic aliasing in the volume term.\n\n1.  **Weak Form and Standard DG Discretization**: We start from the weak form of the advection term, obtained by multiplying by a test function $v$ and integrating over an element $\\Omega_j$: $\\int_{\\Omega_j} v\\, \\partial_{y}f(u)\\, dy$. The standard DG approach applies integration by parts (IBP), resulting in two terms: a volume integral and a surface integral.\n    $$\n    \\int_{\\Omega_j} v\\, \\partial_{y}f(u)\\, dy = -\\int_{\\Omega_j} (\\partial_y v)\\, f(u)\\, dy + [v f(u)]_{\\partial\\Omega_j}\n    $$\n    The volume integral is $-\\int_{\\Omega_j} (\\partial_y v)\\, f(u)\\, dy$. For $u \\in \\mathbb{P}_p$, $f(u)=u^2/2 \\in \\mathbb{P}_{2p}$ and $\\partial_y v \\in \\mathbb{P}_{p-1}$. The integrand's degree is $3p-1$. Using a standard $N_q=p+1$ GLL quadrature (exact up to degree $2p-1$) results in aliasing errors for $p \\ge 2$, which leads to numerical instability.\n\n2.  **Symmetric Split-Form**: To remedy this, the advection term's weak form is rewritten. Note that $\\partial_y f(u) = \\partial_y(u^2/2) = u \\partial_y u$. Instead of $\\int v u \\partial_y u\\, dy$, we use an equivalent formulation that exhibits discrete conservation properties. The symmetric split-form is based on creating a skew-symmetric integrand. For two functions $u$ and $v$, the expression $v u \\partial_y u - u^2 \\partial_y v$ is skew-symmetric. We construct the integral:\n    $$\n    V_{\\text{split}}(u,v) = \\int_{\\Omega_j} \\frac{1}{2}(v u \\partial_y u - u^2 \\partial_y v) dy\n    $$\n    This form is equivalent to the original volume integral up to boundary terms (since $\\int (v u u_y - u^2 v_y) dy = \\int v u u_y dy - \\int u^2 v_y dy = \\int v u u_y dy + \\int (u^2)_y v dy - [vu^2]_\\text{bdy}$, which relates back to $\\int v u u_y dy$ plus another copy). The boundary term differences are absorbed into the definition of the numerical flux at element interfaces.\n\n3.  **Elimination of Quadratic Aliasing**: The crucial benefit of the split form appears upon numerical quadrature. Let the integral be approximated using any nodal quadrature rule (such as GLL) with points $\\{y_i\\}$ and weights $\\{w_i\\}$:\n    $$\n    V_{\\text{split}} \\approx \\sum_{i} w_i \\frac{1}{2} \\left[ v(y_i) u(y_i) \\frac{\\partial u}{\\partial y}(y_i) - u(y_i)^2 \\frac{\\partial v}{\\partial y}(y_i) \\right]\n    $$\n    To analyze stability, we examine the discrete rate of change of energy, $\\frac{1}{2}\\frac{d}{dt}\\int u^2 dy$, which requires setting the test function $v$ equal to the solution $u$. Substituting $v=u$ into the discrete sum gives:\n    $$\n    \\sum_{i} w_i \\frac{1}{2} \\left[ u(y_i) u(y_i) \\frac{\\partial u}{\\partial y}(y_i) - u(y_i)^2 \\frac{\\partial u}{\\partial y}(y_i) \\right] = \\sum_i w_i \\frac{1}{2} \\left[ u(y_i)^2 \\frac{\\partial u}{\\partial y}(y_i) - u(y_i)^2 \\frac{\\partial u}{\\partial y}(y_i) \\right]\n    $$\n    The term inside the brackets is identically zero at *every quadrature point* $y_i$. Consequently, the entire sum is zero.\n\n4.  **Conclusion**: This pointwise cancellation means the discrete volume integral makes no contribution to the energy budget of the element. This property holds true regardless of the quadrature rule's degree of exactness. The aliasing errors that would arise from the individual terms of the split form perfectly cancel each other out. This enforces a discrete version of the energy conservation/dissipation property of the original PDE, thereby ensuring nonlinear stability without requiring expensive over-integration (i.e., increasing $N_q$). This is how the \"skew-symmetric discretization\" eliminates the instability from quadratic aliasing.", "answer": "$$\n\\boxed{\\left\\lceil \\frac{3p+3}{2} \\right\\rceil}\n$$", "id": "3427163"}, {"introduction": "Efficiently capturing the multi-scale physics of a turbulent boundary layer requires allocating computational effort intelligently. This practice introduces a $p$-adaptivity strategy, an advanced technique to automatically adjust the polynomial degree of spectral/DG elements based on their location within the near-wall layers. By developing an algorithm to resolve the buffer layer with higher-order polynomials while using lower orders elsewhere, you will learn how to create a more accurate and cost-effective simulation [@problem_id:3427198].", "problem": "Consider a one-dimensional stack of wall-normal spectral or Discontinuous Galerkin (DG) elements used for wall modeling in turbulent high Reynolds number flows. Let the wall be at physical coordinate $y=0$ (in meters), and each element $i$ is defined by its lower and upper physical bounds $[y_{i,\\mathrm{low}}, y_{i,\\mathrm{high}}]$ (in meters). You are given the friction velocity $u_{\\tau}$ (in meters per second) and the kinematic viscosity $\\nu$ (in square meters per second). The local inner-normal coordinate is defined by the dimensionless quantity $y^+ = y\\,u_{\\tau}/\\nu$, which partitions the near-wall region into the viscous sublayer, buffer layer, and logarithmic layer. In this problem, the buffer layer is defined by the inclusive interval $[y^+_{\\mathrm{buf,low}}, y^+_{\\mathrm{buf,high}}]$, and the viscous sublayer threshold is $y^+  y^+_{\\mathrm{visc,max}}$.\n\nYou must implement $p$-adaptivity with the following rules and objective:\n- Rule 1 (Sampling at nodal points): For each element $i$, compute $y^+$ at a chosen set of $n_{\\mathrm{LGL}}$ Legendre–Gauss–Lobatto (LGL) nodal points mapped linearly from the reference interval $[-1,1]$ to the physical interval $[y_{i,\\mathrm{low}}, y_{i,\\mathrm{high}}]$. The LGL nodes are the endpoints $-1$ and $+1$ together with the roots of the derivative of the Legendre polynomial of degree $n_{\\mathrm{LGL}}-1$.\n- Rule 2 (Triggering conditions for required polynomial degree): For element $i$, define the required minimal polynomial degree $r_i$ by the following classification:\n  - If any sampled $y^+$ in element $i$ lies in the inclusive buffer interval $[y^+_{\\mathrm{buf,low}}, y^+_{\\mathrm{buf,high}}]$, then $r_i = p_{\\mathrm{buffer}}$.\n  - Else if any sampled $y^+$ in element $i$ satisfies $y^+  y^+_{\\mathrm{visc,max}}$, then $r_i = p_{\\mathrm{viscous}}$.\n  - Else $r_i = p_{\\mathrm{far}}$.\n- Rule 3 (Global bounds and smoothing): The actual polynomial degree $p_i$ in element $i$ must satisfy $p_{\\min} \\le p_i \\le p_{\\max}$ and $p_i \\ge r_i$. Additionally, to control inter-element numerical smoothness, enforce the neighbor-difference constraint $\\lvert p_i - p_{i+1} \\rvert \\le 1$ for all adjacent elements.\n- Objective: Among all integer-valued assignments $\\{p_i\\}$ that satisfy the above constraints, find the assignment that minimizes the sum $\\sum_i p_i$.\n\nIf the constraints are infeasible (for example, if any $r_i  p_{\\max}$ or if the neighbor-difference constraints force some $p_i$ to exceed $p_{\\max}$), then the output for that test case must indicate infeasibility as specified below.\n\nFundamental base and definitions:\n- Incompressible turbulent boundary layer near-wall scaling uses the inner coordinate $y^+ = y\\,u_{\\tau}/\\nu$.\n- Friction velocity $u_{\\tau}$ is defined by $u_{\\tau} = \\sqrt{\\tau_w/\\rho}$, where $\\tau_w$ is the wall shear stress and $\\rho$ is the fluid density (these quantities are not required as inputs; only $u_{\\tau}$ is provided).\n- Legendre–Gauss–Lobatto nodes for $n_{\\mathrm{LGL}}$ points are $-1$, $+1$, and the $n_{\\mathrm{LGL}}-2$ roots of the derivative of the Legendre polynomial of degree $n_{\\mathrm{LGL}}-1$ in the reference interval.\n\nPhysical units requirement:\n- Distances $y$ must be interpreted in meters.\n- Friction velocity $u_{\\tau}$ must be interpreted in meters per second.\n- Kinematic viscosity $\\nu$ must be interpreted in square meters per second.\n- The quantity $y^+$ is dimensionless.\n- The output polynomial degrees $p_i$ are dimensionless integers.\n\nTest suite:\nProvide a program that computes $\\{p_i\\}$ for the following test cases. For each case, the program must generate the results as specified in the final output format.\n\n- Test Case $1$ (general near-wall stack, typical parameters):\n  - $u_{\\tau} = 0.4$ (meters per second), $\\nu = 1.5\\times 10^{-5}$ (square meters per second).\n  - Element bounds (meters): [(0.0, 0.0002), (0.0002, 0.0004), (0.0004, 0.0008), (0.0008, 0.0012), (0.0012, 0.0020), (0.0020, 0.0030), (0.0030, 0.0045), (0.0045, 0.0060), (0.0060, 0.0080), (0.0080, 0.0100)].\n  - $n_{\\mathrm{LGL}} = 4$.\n  - Thresholds: $y^+_{\\mathrm{visc,max}} = 5$, $y^+_{\\mathrm{buf,low}} = 5$, $y^+_{\\mathrm{buf,high}} = 30$.\n  - Degrees: $p_{\\min} = 2$, $p_{\\max} = 6$, $p_{\\mathrm{viscous}} = 4$, $p_{\\mathrm{buffer}} = 5$, $p_{\\mathrm{far}} = 2$.\n\n- Test Case $2$ (boundary inclusions at exact thresholds):\n  - $u_{\\tau} = 0.3$ (meters per second), $\\nu = 1.0\\times 10^{-5}$ (square meters per second).\n  - Element bounds (meters): [(0.0, 0.0001), (0.0001666666667, 0.0003), (0.0008, 0.0010), (0.0012, 0.0020)].\n  - $n_{\\mathrm{LGL}} = 4$.\n  - Thresholds: $y^+_{\\mathrm{visc,max}} = 5$, $y^+_{\\mathrm{buf,low}} = 5$, $y^+_{\\mathrm{buf,high}} = 30$.\n  - Degrees: $p_{\\min} = 2$, $p_{\\max} = 6$, $p_{\\mathrm{viscous}} = 4$, $p_{\\mathrm{buffer}} = 5$, $p_{\\mathrm{far}} = 2$.\n\n- Test Case $3$ (infeasible due to low $p_{\\max}$):\n  - $u_{\\tau} = 0.4$ (meters per second), $\\nu = 1.5\\times 10^{-5}$ (square meters per second).\n  - Element bounds (meters): same as Test Case $1$.\n  - $n_{\\mathrm{LGL}} = 4$.\n  - Thresholds: $y^+_{\\mathrm{visc,max}} = 5$, $y^+_{\\mathrm{buf,low}} = 5$, $y^+_{\\mathrm{buf,high}} = 30$.\n  - Degrees: $p_{\\min} = 2$, $p_{\\max} = 3$, $p_{\\mathrm{viscous}} = 4$, $p_{\\mathrm{buffer}} = 5$, $p_{\\mathrm{far}} = 2$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The $i$-th entry corresponds to the $i$-th test case and must be either:\n- A list of integers representing the optimized polynomial degrees $\\{p_i\\}$ for all elements in that case, or\n- The single-element list `[-1]` if the constraints are infeasible for that case.\n\nFor example, a valid final output could look like `[[2,3,4],[3,3,2],[-1]]` for three test cases. Your program must produce exactly one such line and nothing else.", "solution": "The problem presents a well-defined task in the domain of computational fluid dynamics, specifically concerning adaptive numerical methods for wall-bounded turbulent flows. The problem statement is to be validated before a solution is attempted.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n\nThe problem provides the following data, definitions, and constraints:\n- **Physical Context**: A one-dimensional stack of wall-normal spectral or Discontinuous Galerkin (DG) elements for wall modeling.\n- **Coordinate System**: The wall is at $y=0$. Element $i$ spans $[y_{i,\\mathrm{low}}, y_{i,\\mathrm{high}}]$.\n- **Flow Parameters**: Friction velocity $u_{\\tau}$ (m/s) and kinematic viscosity $\\nu$ (m²/s).\n- **Dimensionless Coordinate**: Inner-normal coordinate $y^+ = y\\,u_{\\tau}/\\nu$.\n- **Flow Layer Definitions**:\n  - Buffer layer: inclusive interval $[y^+_{\\mathrm{buf,low}}, y^+_{\\mathrm{buf,high}}]$.\n  - Viscous sublayer: $y^+  y^+_{\\mathrm{visc,max}}$.\n- **Rule 1 (Sampling)**: For each element $i$, $y^+$ is sampled at $n_{\\mathrm{LGL}}$ Legendre–Gauss–Lobatto (LGL) nodal points mapped from $[-1,1]$ to $[y_{i,\\mathrm{low}}, y_{i,\\mathrm{high}}]$.\n- **Rule 2 (Required Degree)**: The required minimal polynomial degree $r_i$ for element $i$ is:\n  - $p_{\\mathrm{buffer}}$ if any sampled $y^+$ is in $[y^+_{\\mathrm{buf,low}}, y^+_{\\mathrm{buf,high}}]$.\n  - $p_{\\mathrm{viscous}}$ if no point is in the buffer layer, but any sampled $y^+$ is less than $y^+_{\\mathrm{visc,max}}$.\n  - $p_{\\mathrm{far}}$ otherwise.\n- **Rule 3 (Global Constraints)**: The actual polynomial degree $p_i$ for element $i$ must satisfy:\n  - $p_{\\min} \\le p_i \\le p_{\\max}$.\n  - $p_i \\ge r_i$.\n  - Neighbor-difference constraint: $\\lvert p_i - p_{i+1} \\rvert \\le 1$ for all adjacent elements.\n- **Objective**: Find the integer-valued assignment $\\{p_i\\}$ that satisfies all constraints and minimizes the total sum $\\sum_i p_i$.\n- **Infeasibility**: If no such assignment exists, the algorithm must report it.\n- **Test Cases**: Specific numerical values for all parameters are provided for three distinct test cases.\n\n**Step 2: Validate Using Extracted Givens**\n\nThe problem is evaluated against the validation criteria:\n- **Scientifically Grounded**: The problem is based on fundamental principles of turbulent boundary layer theory ($y^+$ scaling) and established numerical techniques (DG/spectral methods, LGL quadrature, p-adaptivity). These are standard concepts in advanced computational fluid dynamics. The problem is scientifically sound.\n- **Well-Posed**: The problem is a constrained integer optimization problem. The objective function ($\\sum_i p_i$) and the constraints are clearly defined. The rules provide a deterministic procedure to find a solution, and the possibility of infeasibility is acknowledged and handled. An algorithm exists to find a unique, minimal solution.\n- **Objective**: The language is precise and mathematical. All rules are stated formally, leaving no room for subjective interpretation.\n- **Completeness and Consistency**: All necessary data for solving the test cases are provided. The rules are internally consistent, although they may lead to an infeasible setup for certain parameter choices, a condition the problem explicitly requires handling.\n\n**Step 3: Verdict and Action**\n\nThe problem is deemed **valid**. It is a well-posed, scientifically grounded, and objective problem in applied mathematics and computational engineering. A solution will be provided.\n\n### Algorithmic Solution Design\n\nThe objective is to find a vector of integer polynomial degrees $\\{p_i\\}_{i=0}^{N-1}$ for a stack of $N$ elements that minimizes the total cost $\\sum_{i=0}^{N-1} p_i$, subject to a set of constraints. The solution can be constructed through a multi-step algorithm.\n\n**Step 1: Determination of Required Polynomial Degrees ($r_i$)**\n\nThe first step is to translate the physical criteria into a minimum polynomial degree requirement, $r_i$, for each element $i$.\n\n1.  **Compute LGL Nodes**: For a specified number of sampling points, $n_{\\mathrm{LGL}}$, the Legendre-Gauss-Lobatto nodes $\\{\\xi_j\\}_{j=0}^{n_{\\mathrm{LGL}}-1}$ are computed in the reference interval $[-1, 1]$. These consist of the endpoints $-1$ and $+1$, and the $n_{\\mathrm{LGL}}-2$ roots of the first derivative of the Legendre polynomial of degree $n_{\\mathrm{LGL}}-1$, denoted $P'_{n_{\\mathrm{LGL}}-1}(x)$. The roots of $P'_{k}(x)$ are equivalent to the roots of the Jacobi polynomial $P_{k-1}^{(1,1)}(x)$.\n\n2.  **Map Nodes to Physical and Wall-Unit Coordinates**: For each element $i$, defined by the physical interval $[y_{i,\\mathrm{low}}, y_{i,\\mathrm{high}}]$, the reference nodes $\\xi_j$ are linearly mapped to physical sample points $y_{i,j}$:\n    $$y_{i,j} = y_{i,\\mathrm{low}} + \\frac{\\xi_j + 1}{2} (y_{i,\\mathrm{high}} - y_{i,\\mathrm{low}})$$\n    These physical coordinates are then converted to dimensionless wall units, $y^+_{i,j}$:\n    $$y^+_{i,j} = \\frac{y_{i,j} u_{\\tau}}{\\nu}$$\n\n3.  **Classify Element and Assign $r_i$**: The set of sample points $\\{y^+_{i,j}\\}$ for element $i$ is used to determine $r_i$ according to Rule $2$:\n    - If there exists any $j$ such that $y^+_{i,j} \\in [y^+_{\\mathrm{buf,low}}, y^+_{\\mathrm{buf,high}}]$, then $r_i = p_{\\mathrm{buffer}}$.\n    - Otherwise, if there exists any $j$ such that $y^+_{i,j}  y^+_{\\mathrm{visc,max}}$, then $r_i = p_{\\mathrm{viscous}}$.\n    - Otherwise, $r_i = p_{\\mathrm{far}}$.\n\n**Step 2: Establishment of Lower Bounds and Initial Feasibility Check**\n\nThe constraints $p_i \\ge r_i$ and $p_i \\ge p_{\\min}$ are combined into a single effective lower bound, $L_i$, for the polynomial degree in each element $i$:\n$$L_i = \\max(p_{\\min}, r_i)$$\nAt this stage, a primary feasibility check is performed. The constraints are immediately violated if the required lower bound for any element exceeds the absolute maximum allowed degree.\n- If $L_i  p_{\\max}$ for any $i \\in [0, N-1]$, the problem is **infeasible**.\n\n**Step 3: Optimization via Two-Pass Smoothing Algorithm**\n\nIf the initial feasibility check passes, we seek a vector $\\{p_i\\}$ that satisfies $L_i \\le p_i \\le p_{\\max}$ and the neighbor-difference constraint $|\\,p_i - p_{i+1}\\,| \\le 1$, while minimizing $\\sum p_i$. The minimization objective implies we should select the smallest possible $p_i$ values. This can be achieved with a standard two-pass smoothing algorithm.\n\n1.  **Initialization**: An initial vector of polynomial degrees $\\{p_i\\}$ is created by setting each $p_i$ to its minimum possible value:\n    $$p_i \\leftarrow L_i \\quad \\text{for } i = 0, \\dots, N-1$$\n    This assignment satisfies $p_i \\ge L_i$ by construction but may violate the neighbor-difference constraint.\n\n2.  **Forward Pass (Left-to-Right Propagation)**: The neighbor-difference constraint is enforced by propagating adjustments from left to right. For $i$ from $1$ to $N-1$, we update $p_i$ to ensure $p_i \\ge p_{i-1} - 1$:\n    $$p_i \\leftarrow \\max(p_i, p_{i-1} - 1)$$\n    This pass guarantees that for any element $i$, its degree $p_i$ is at least $p_{i-1}-1$, satisfying one half of the smoothness constraint. Any necessary increase in degree due to a high requirement in an element to the left is propagated forward.\n\n3.  **Backward Pass (Right-to-Left Propagation)**: A second pass propagates constraints from right to left. For $i$ from $N-2$ down to $0$, we update $p_i$ to ensure $p_i \\ge p_{i+1} - 1$:\n    $$p_i \\leftarrow \\max(p_i, p_{i+1} - 1)$$\n    This pass ensures the other half of the smoothness constraint is met. After this pass, the condition $|\\,p_i - p_{i+1}\\,| \\le 1$ is fully satisfied for all adjacent pairs. The resulting vector $\\{p_i\\}$ is the one with the smallest possible integer values that satisfies both the local lower bounds $L_i$ and the global smoothness constraint.\n\n**Step 4: Final Feasibility Check**\n\nThe smoothing algorithm may increase some $p_i$ values beyond their initial $L_i$ values. A final check is required to ensure that no $p_i$ has been pushed above the maximum allowed degree $p_{\\max}$.\n- If $p_i  p_{\\max}$ for any $i \\in [0, N-1]$, the combined constraints are unsatisfiable, and the problem is **infeasible**.\n- Otherwise, the final vector $\\{p_i\\}$ is the valid, optimal solution.\n\nThis algorithm deterministically computes the vector of polynomial degrees that meets all specified rules while minimizing the total polynomial cost, or it correctly identifies cases where no such solution exists.", "answer": "```python\nimport numpy as np\nfrom scipy.special import j_roots\n\ndef solve():\n    \"\"\"\n    Main solver function that processes all test cases and prints the results.\n    \"\"\"\n    \n    # Test Case 1: General near-wall stack, typical parameters\n    case1 = {\n        \"u_tau\": 0.4, \"nu\": 1.5e-5,\n        \"element_bounds\": [\n            (0.0, 0.0002), (0.0002, 0.0004), (0.0004, 0.0008),\n            (0.0008, 0.0012), (0.0012, 0.0020), (0.0020, 0.0030),\n            (0.0030, 0.0045), (0.0045, 0.0060), (0.0060, 0.0080),\n            (0.0080, 0.0100)\n        ],\n        \"n_lgl\": 4,\n        \"y_plus_visc_max\": 5, \"y_plus_buf_low\": 5, \"y_plus_buf_high\": 30,\n        \"p_min\": 2, \"p_max\": 6, \"p_viscous\": 4, \"p_buffer\": 5, \"p_far\": 2\n    }\n\n    # Test Case 2: Boundary inclusions at exact thresholds\n    case2 = {\n        \"u_tau\": 0.3, \"nu\": 1.0e-5,\n        \"element_bounds\": [\n            (0.0, 0.0001), \n            (0.00016666666666666666, 0.0003), # Lower bound is y+=5\n            (0.0008, 0.0010),                 # Upper bound is y+=30\n            (0.0012, 0.0020)\n        ],\n        \"n_lgl\": 4,\n        \"y_plus_visc_max\": 5, \"y_plus_buf_low\": 5, \"y_plus_buf_high\": 30,\n        \"p_min\": 2, \"p_max\": 6, \"p_viscous\": 4, \"p_buffer\": 5, \"p_far\": 2\n    }\n\n    # Test Case 3: Infeasible due to low p_max\n    case3 = {\n        \"u_tau\": 0.4, \"nu\": 1.5e-5,\n        \"element_bounds\": case1[\"element_bounds\"], # Same as Case 1\n        \"n_lgl\": 4,\n        \"y_plus_visc_max\": 5, \"y_plus_buf_low\": 5, \"y_plus_buf_high\": 30,\n        \"p_min\": 2, \"p_max\": 3, \"p_viscous\": 4, \"p_buffer\": 5, \"p_far\": 2\n    }\n\n    test_cases = [case1, case2, case3]\n    results = [calculate_p_adaptivity(case) for case in test_cases]\n\n    # Format the final output string to match the required format exactly.\n    # e.g., [[2,3,4],[3,3,2],[-1]]\n    final_output = str(results).replace(\" \", \"\")\n    print(final_output)\n\ndef get_lgl_nodes(n):\n    \"\"\"Computes n Legendre-Gauss-Lobatto nodes on the [-1, 1] interval.\"\"\"\n    if n == 1:\n        return np.array([0.0])\n    if n == 2:\n        return np.array([-1.0, 1.0])\n    \n    # Interior nodes are the roots of P'_{n-1}(x), which corresponds to the\n    # roots of the Jacobi polynomial P_{n-2}^{(1,1)}(x).\n    degree_jacobi = n - 2\n    roots, _ = j_roots(degree_jacobi, 1, 1)\n    \n    return np.sort(np.concatenate(([-1.0], roots, [1.0])))\n\ndef calculate_p_adaptivity(params):\n    \"\"\"\n    Calculates the optimized polynomial degrees {p_i} for a single test case.\n    \"\"\"\n    # Unpack parameters\n    u_tau = params[\"u_tau\"]\n    nu = params[\"nu\"]\n    element_bounds = params[\"element_bounds\"]\n    n_lgl = params[\"n_lgl\"]\n    y_plus_visc_max = params[\"y_plus_visc_max\"]\n    y_plus_buf_low = params[\"y_plus_buf_low\"]\n    y_plus_buf_high = params[\"y_plus_buf_high\"]\n    p_min = params[\"p_min\"]\n    p_max = params[\"p_max\"]\n    p_viscous = params[\"p_viscous\"]\n    p_buffer = params[\"p_buffer\"]\n    p_far = params[\"p_far\"]\n\n    num_elements = len(element_bounds)\n    required_degrees = np.zeros(num_elements, dtype=int)\n    \n    lgl_nodes_ref = get_lgl_nodes(n_lgl)\n    y_plus_converter = u_tau / nu\n\n    # Step 1: Determine the required minimum polynomial degrees r_i\n    for i, (y_low, y_high) in enumerate(element_bounds):\n        # Map LGL nodes from reference [-1, 1] to physical element [y_low, y_high]\n        y_physical_samples = y_low + (lgl_nodes_ref + 1.0) / 2.0 * (y_high - y_low)\n        y_plus_samples = y_physical_samples * y_plus_converter\n        \n        # Apply Rule 2 to classify the element\n        if np.any((y_plus_samples = y_plus_buf_low)  (y_plus_samples = y_plus_buf_high)):\n            required_degrees[i] = p_buffer\n        elif np.any(y_plus_samples  y_plus_visc_max):\n            required_degrees[i] = p_viscous\n        else:\n            required_degrees[i] = p_far\n\n    # Step 2: Define initial lower bounds L_i and check for immediate infeasibility\n    lower_bounds_p = np.maximum(p_min, required_degrees)\n    \n    if np.any(lower_bounds_p  p_max):\n        return [-1]\n\n    # Step 3: Enforce neighbor-difference constraint via two-pass smoothing\n    p = np.copy(lower_bounds_p)\n    \n    # Forward pass (left-to-right)\n    for i in range(1, num_elements):\n        p[i] = max(p[i], p[i-1] - 1)\n        \n    # Backward pass (right-to-left)\n    for i in range(num_elements - 2, -1, -1):\n        p[i] = max(p[i], p[i+1] - 1)\n        \n    # Step 4: Final feasibility check against p_max\n    if np.any(p  p_max):\n        return [-1]\n\n    return p.tolist()\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3427198"}]}