{"hands_on_practices": [{"introduction": "Before implementing complex numerical schemes, it is essential to understand their theoretical foundations. This practice guides you through the construction of a high-order exponential integrator from first principles, revealing how the ubiquitous $\\varphi$-functions arise directly from integrating the variation-of-constants formula against a polynomial approximation of the nonlinear term [@problem_id:3386138]. By deriving the quadrature weights for a collocation method, you will gain a deeper appreciation for how these advanced time-steppers are designed.", "problem": "Consider the semilinear stiff ordinary differential equation (ODE) $u'(t) = A\\,u(t) + N(u(t))$ on a single time step $[t_n, t_{n+1}]$ with step size $h = t_{n+1} - t_n$, where $A \\in \\mathbb{R}^{d \\times d}$ is a constant stiff linear operator and $N: \\mathbb{R}^d \\to \\mathbb{R}^d$ is a polynomial nonlinearity. Starting from the variation-of-constants formula, construct an exponential collocation method that uses Discontinuous Galerkin (DG) nodal points chosen as the three Legendre–Gauss–Lobatto (LGL) points on $[0,1]$, namely $c_0 = 0$, $c_1 = \\tfrac{1}{2}$, and $c_2 = 1$, as temporal collocation nodes for $\\varphi$-function quadrature. Let $L_i(\\theta)$, $i=0,1,2$, denote the Lagrange basis polynomials associated with $\\{c_0,c_1,c_2\\}$ on the unit interval, and define the exponential quadrature weights\n$$\nb_i(hA) = \\int_0^1 \\exp\\!\\big((1-\\theta)\\,hA\\big)\\,L_i(\\theta)\\,d\\theta,\\quad i=0,1,2,\n$$\nin terms of the operator $\\varphi$-functions $\\varphi_k(hA)$, $k \\in \\mathbb{N}$, where $\\varphi_1(X) = ( \\exp(X) - I ) X^{-1}$ and, recursively, $\\varphi_{k+1}(X) = \\big( \\varphi_k(X) - \\tfrac{1}{k!} I \\big) X^{-1}$ for $k \\geq 1$. Derive explicit closed-form expressions for $b_0(hA)$, $b_1(hA)$, and $b_2(hA)$ in terms of $\\varphi_1(hA)$, $\\varphi_2(hA)$, and $\\varphi_3(hA)$, and from first principles determine the condition under which the resulting exponential collocation method is exact on the time step when $N(u)$ is polynomial and $A$ is stiff linear. Your final answer must be the single row vector containing the three weights $\\big(b_0(hA),\\,b_1(hA),\\,b_2(hA)\\big)$ as a closed-form analytical expression using only $\\varphi_1(hA)$, $\\varphi_2(hA)$, and $\\varphi_3(hA)$.", "solution": "This problem requires the derivation of the quadrature weights for an exponential collocation method and determining the condition for its exactness. Let $Z = hA$ for notational convenience.\n\n**1. Lagrange Basis Polynomials**\n\nFirst, we construct the Lagrange basis polynomials $L_i(\\theta)$ for the nodes $c_0 = 0$, $c_1 = 1/2$, and $c_2 = 1$.\n- $L_0(\\theta) = \\frac{(\\theta - c_1)(\\theta - c_2)}{(c_0 - c_1)(c_0 - c_2)} = \\frac{(\\theta - 1/2)(\\theta - 1)}{(0 - 1/2)(0 - 1)} = 2\\theta^2 - 3\\theta + 1$\n- $L_1(\\theta) = \\frac{(\\theta - c_0)(\\theta - c_2)}{(c_1 - c_0)(c_1 - c_2)} = \\frac{(\\theta - 0)(\\theta - 1)}{(1/2 - 0)(1/2 - 1)} = -4\\theta^2 + 4\\theta$\n- $L_2(\\theta) = \\frac{(\\theta - c_0)(\\theta - c_1)}{(c_2 - c_0)(c_2 - c_1)} = \\frac{(\\theta - 0)(\\theta - 1/2)}{(1 - 0)(1 - 1/2)} = 2\\theta^2 - \\theta$\n\n**2. Integrals of Monomials and $\\varphi$-functions**\n\nThe quadrature weights $b_i(Z)$ are linear combinations of the integrals $I_k(Z) = \\int_0^1 \\exp((1-\\theta)Z) \\theta^k d\\theta$ for $k=0, 1, 2$. We express these integrals in terms of the $\\varphi$-functions using the identity $I_k(Z) = k! \\varphi_{k+1}(Z)$, which can be derived via integration by parts.\n- For $k=0$: $I_0(Z) = \\int_0^1 \\exp((1-\\theta)Z) d\\theta = (\\exp(Z) - I)Z^{-1} = \\varphi_1(Z)$.\n- For $k=1$: $I_1(Z) = \\int_0^1 \\exp((1-\\theta)Z) \\theta d\\theta = (\\varphi_1(Z) - I)Z^{-1} = \\varphi_2(Z)$.\n- For $k=2$: $I_2(Z) = \\int_0^1 \\exp((1-\\theta)Z) \\theta^2 d\\theta = 2(\\varphi_2(Z) - \\frac{1}{2}I)Z^{-1} = 2\\varphi_3(Z)$.\n\n**3. Derivation of Quadrature Weights**\n\nWe now substitute the monomial integrals into the expressions for the weights.\n- For $b_0(Z) = \\int_0^1 \\exp((1-\\theta)Z) (2\\theta^2 - 3\\theta + 1) d\\theta$:\n$$\nb_0(Z) = 2I_2(Z) - 3I_1(Z) + I_0(Z) = 2(2\\varphi_3(Z)) - 3\\varphi_2(Z) + \\varphi_1(Z) = \\varphi_1(Z) - 3\\varphi_2(Z) + 4\\varphi_3(Z)\n$$\n- For $b_1(Z) = \\int_0^1 \\exp((1-\\theta)Z) (-4\\theta^2 + 4\\theta) d\\theta$:\n$$\nb_1(Z) = -4I_2(Z) + 4I_1(Z) = -4(2\\varphi_3(Z)) + 4\\varphi_2(Z) = 4\\varphi_2(Z) - 8\\varphi_3(Z)\n$$\n- For $b_2(Z) = \\int_0^1 \\exp((1-\\theta)Z) (2\\theta^2 - \\theta) d\\theta$:\n$$\nb_2(Z) = 2I_2(Z) - I_1(Z) = 2(2\\varphi_3(Z)) - \\varphi_2(Z) = -\\varphi_2(Z) + 4\\varphi_3(Z)\n$$\nReplacing $Z$ with $hA$ gives the expressions in the final answer.\n\n**4. Condition for Exactness**\n\nThe exact solution is given by the variation-of-constants formula:\n$$ u(t_{n+1}) = \\exp(hA)u(t_n) + h \\int_0^1 \\exp((1-s)hA) N(u(t_n+sh)) ds $$\nThe exponential collocation method approximates the integral by replacing the integrand function $g(s) = N(u(t_n+sh))$ with its unique quadratic polynomial interpolant $P(s)$ at the nodes $\\{c_0, c_1, c_2\\}$. The method is exact if and only if this approximation is exact, which occurs when the function being interpolated is identical to its interpolant, i.e., $g(s) \\equiv P(s)$. This holds if and only if $g(s) = N(u(t_n+sh))$ is a polynomial in the scaled time variable $s$ of degree at most 2 on the interval $[0,1]$.", "answer": "$$\n\\boxed{\\begin{pmatrix} \\varphi_1(hA) - 3\\varphi_2(hA) + 4\\varphi_3(hA) & 4\\varphi_2(hA) - 8\\varphi_3(hA) & -\\varphi_2(hA) + 4\\varphi_3(hA) \\end{pmatrix}}\n$$", "id": "3386138"}, {"introduction": "With a grasp of how exponential integrators are constructed, the next logical step is to apply one to a practical problem. This exercise challenges you to implement a second-order Lawson method, a foundational type of exponential integrator, for a semi-discretized advection-diffusion equation that models stiff systems in physics and engineering [@problem_id:3386153]. You will translate the abstract formula into concrete algorithmic steps, handling the stiff diffusive part with a matrix exponential and the non-stiff advective part with an explicit scheme, thereby mastering the core operator-splitting paradigm of exponential integrators.", "problem": "Consider the one-dimensional linear advection–diffusion partial differential equation posed on the periodic interval $[0,1]$,\n$$\nu_t + a\\,u_x = \\nu\\,u_{xx},\n$$\nwith constant advection speed $a \\in \\mathbb{R}$ and constant diffusion coefficient $\\nu \\ge 0$. Discretize the spatial domain with a uniform mesh of $K$ elements of width $h = 1/K$, and let $u_j(t)$ denote the element-wise constant approximation (piecewise polynomial of degree $p=0$) of $u$ in cell $j$ for $j=0,1,\\dots,K-1$. Use periodic boundary conditions, that is, index arithmetic is performed modulo $K$.\n\nThe discontinuous Galerkin (DG) semi-discretization at degree $p=0$ for this equation can be formulated using interface numerical fluxes for advection and diffusion. Define the upwind numerical flux for advection at interface $j+\\tfrac{1}{2}$ by\n$$\nF^{\\mathrm{adv}}_{j+\\frac{1}{2}}(u) =\n\\begin{cases}\na\\,u_j, & \\text{if } a \\ge 0,\\\\\na\\,u_{j+1}, & \\text{if } a < 0,\n\\end{cases}\n$$\nand the central gradient-based numerical flux for diffusion by\n$$\nF^{\\mathrm{diff}}_{j+\\frac{1}{2}}(u) = -\\nu\\,\\frac{u_{j+1}-u_j}{h}.\n$$\nThe semi-discrete balance in cell $j$ (with periodic indexing) is then\n$$\n\\frac{d}{dt}u_j = -\\frac{1}{h}\\left(F^{\\mathrm{adv}}_{j+\\frac{1}{2}}(u) - F^{\\mathrm{adv}}_{j-\\frac{1}{2}}(u)\\right) - \\frac{1}{h}\\left(F^{\\mathrm{diff}}_{j+\\frac{1}{2}}(u) - F^{\\mathrm{diff}}_{j-\\frac{1}{2}}(u)\\right).\n$$\nThis yields a system of ordinary differential equations in vector form,\n$$\n\\frac{d}{dt}\\mathbf{u} = L\\,\\mathbf{u} + N(\\mathbf{u}),\n$$\nwhere:\n- $\\mathbf{u} \\in \\mathbb{R}^K$ collects the $K$ cell values $u_j$,\n- $L \\in \\mathbb{R}^{K \\times K}$ is the linear diffusion operator originating from the diffusion flux, specifically\n$$\n(L\\,\\mathbf{u})_j = \\nu\\,\\frac{u_{j+1} - 2u_j + u_{j-1}}{h^2},\n$$\nwith periodic wrap-around $u_{-1} \\equiv u_{K-1}$ and $u_K \\equiv u_0$,\n- $N(\\mathbf{u}) \\in \\mathbb{R}^K$ encodes the explicit advection contribution via the upwind numerical flux,\n$$\nN(\\mathbf{u})_j = -\\frac{1}{h}\\left(F^{\\mathrm{adv}}_{j+\\frac{1}{2}}(\\mathbf{u}) - F^{\\mathrm{adv}}_{j-\\frac{1}{2}}(\\mathbf{u})\\right).\n$$\n\nYour task is to implement a single time step of a second-order Lawson method for the semi-discrete system $\\mathbf{u}' = L\\,\\mathbf{u} + N(\\mathbf{u})$ by expressing the algorithm exclusively in terms of the action of the matrix exponential $e^{\\Delta t\\,L}$ on vectors and evaluations of the numerical advection flux $N(\\cdot)$. The second-order method to be used is the explicit midpoint Runge–Kutta scheme formulated in Lawson variables. You must not assume any simplifications beyond the definitions given above, and your implementation must work for any $K \\ge 3$, any real $a$, any $\\nu \\ge 0$, and any $\\Delta t > 0$.\n\nUse the following test suite, with the initial condition defined by sampling $u(x,0) = \\sin(2\\pi x)$ at cell centers $x_j = (j+\\tfrac{1}{2})h$:\n1. $K = 64$, $a = 1.0$, $\\nu = 0.05$, $\\Delta t = 10^{-3}$.\n2. $K = 64$, $a = 0.0$, $\\nu = 0.05$, $\\Delta t = 10^{-3}$.\n3. $K = 64$, $a = 3.0$, $\\nu = 0.0$, $\\Delta t = 10^{-1}$.\n\nFor each of the three test cases, after performing exactly one Lawson step starting from the given initial condition, compute and report the following scalar quantities:\n- For case 1: the discrete $L^2$ norm of the updated solution, defined by\n$$\n\\left\\|\\mathbf{u}\\right\\|_{2,h} = \\sqrt{h\\,\\sum_{j=0}^{K-1} u_j^2}.\n$$\n- For case 2: the discrete $L^2$ norm of the difference between your Lawson update and the purely diffusive update $e^{\\Delta t\\,L}\\,\\mathbf{u}$, that is,\n$$\n\\sqrt{h\\,\\sum_{j=0}^{K-1} \\left(u^{\\mathrm{Lawson}}_j - u^{\\mathrm{diffusion}}_j\\right)^2}.\n$$\n- For case 3: the maximum absolute value over all cells of the updated solution, $\\max_{0 \\le j \\le K-1} |u_j|$.\n\nFinal output format requirement: Your program should produce a single line of output containing the three results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3]\") in this exact order corresponding to the test cases above. No additional text should be printed. No physical units or angle units are involved; all quantities are dimensionless real numbers.", "solution": "The problem requires the implementation of a single time step for the semi-discrete advection-diffusion equation using a second-order exponential integrator. The system of ODEs is given by\n$$ \\frac{d\\mathbf{u}}{dt} = L\\mathbf{u} + N(\\mathbf{u}) $$\nwhere $L$ is a linear operator representing diffusion, and $N(\\mathbf{u})$ is a (in this case, linear) operator representing advection. The splitting isolates the stiff diffusion term, which contains derivatives scaled by $1/h^2$, into the linear part $L\\mathbf{u}$ that will be handled exactly by the matrix exponential.\n\n#### The Second-Order Lawson-Midpoint Method\n\nThe Lawson method transforms the variable to filter out the fast dynamics of the linear part. Let $\\mathbf{v}(t) = e^{-tL} \\mathbf{u}(t)$. Differentiating with respect to time $t$ yields the transformed ODE for $\\mathbf{v}$:\n$$ \\frac{d\\mathbf{v}}{dt} = -L e^{-tL} \\mathbf{u}(t) + e^{-tL} \\frac{d\\mathbf{u}}{dt} = -L e^{-tL} \\mathbf{u}(t) + e^{-tL} (L\\mathbf{u}(t) + N(\\mathbf{u}(t))) = e^{-tL} N(e^{tL} \\mathbf{v}(t)) $$\nWe solve this transformed equation for one step $\\Delta t$ starting from $\\mathbf{v}_n$ at time $t_n$ using the explicit midpoint Runge-Kutta method. For simplicity, we set $t_n=0$, so $\\mathbf{v}_0 = \\mathbf{u}_n$. The midpoint method is:\n1.  Compute the slope at the starting point:\n    $ \\mathbf{k}_1 = \\left. \\frac{d\\mathbf{v}}{dt} \\right|_{t=0} = e^{-0\\cdot L} N(e^{0\\cdot L} \\mathbf{v}_0) = N(\\mathbf{u}_n) $\n2.  Take a half-step to find the midpoint state:\n    $ \\mathbf{v}_{mid} = \\mathbf{v}_0 + \\frac{\\Delta t}{2} \\mathbf{k}_1 = \\mathbf{u}_n + \\frac{\\Delta t}{2} N(\\mathbf{u}_n) $\n3.  Evaluate the slope at the midpoint time $t=\\Delta t/2$ using state $\\mathbf{v}_{mid}$:\n    $ \\mathbf{k}_2 = \\left. \\frac{d\\mathbf{v}}{dt} \\right|_{t=\\Delta t/2, \\mathbf{v}=\\mathbf{v}_{mid}} = e^{-\\frac{\\Delta t}{2}L} N(e^{\\frac{\\Delta t}{2}L} \\mathbf{v}_{mid}) $\n    Substituting for $\\mathbf{v}_{mid}$:\n    $ \\mathbf{k}_2 = e^{-\\frac{\\Delta t}{2}L} N\\left(e^{\\frac{\\Delta t}{2}L} \\left(\\mathbf{u}_n + \\frac{\\Delta t}{2} N(\\mathbf{u}_n)\\right)\\right) = e^{-\\frac{\\Delta t}{2}L} N\\left(e^{\\frac{\\Delta t}{2}L}\\mathbf{u}_n + \\frac{\\Delta t}{2} e^{\\frac{\\Delta t}{2}L}N(\\mathbf{u}_n)\\right) $\n4.  Take a full step using the midpoint slope $\\mathbf{k}_2$:\n    $ \\mathbf{v}_{n+1} = \\mathbf{v}_0 + \\Delta t \\mathbf{k}_2 = \\mathbf{u}_n + \\Delta t e^{-\\frac{\\Delta t}{2}L} N\\left(e^{\\frac{\\Delta t}{2}L}\\mathbf{u}_n + \\frac{\\Delta t}{2} e^{\\frac{\\Delta t}{2}L}N(\\mathbf{u}_n)\\right) $\nFinally, we transform back to the original variable $\\mathbf{u}_{n+1}$:\n$ \\mathbf{u}_{n+1} = e^{\\Delta t L} \\mathbf{v}_{n+1} = e^{\\Delta t L} \\mathbf{u}_n + \\Delta t e^{\\Delta t L} e^{-\\frac{\\Delta t}{2}L} N\\left( \\dots \\right) $\nThis simplifies to the final update formula:\n$$ \\mathbf{u}_{n+1} = e^{\\Delta t L} \\mathbf{u}_n + \\Delta t\\, e^{\\frac{\\Delta t}{2} L} N\\left(e^{\\frac{\\Delta t}{2} L} \\mathbf{u}_n + \\frac{\\Delta t}{2} e^{\\frac{\\Delta t}{2} L} N(\\mathbf{u}_n)\\right) $$\nThis is a second-order accurate exponential Runge-Kutta method.\n\n#### Implementation Strategy\n\n**1. The Operators $L$ and $N$**\nThe linear operator $L$ represents the periodic centered difference approximation of $\\nu \\frac{\\partial^2}{\\partial x^2}$. Its matrix representation is a circulant matrix.\nThe operator $N(\\mathbf{u})$ can be written explicitly. For $a \\ge 0$, the upwind flux is $F^{\\mathrm{adv}}_{j \\pm 1/2}(u) = a u_{j \\pm 1/2 - 1/2} = a u_{j \\text{ or } j-1}$.\n$$ N(\\mathbf{u})_j = -\\frac{1}{h} (a u_j - a u_{j-1}) = -\\frac{a}{h} (u_j - u_{j-1}) $$\nFor $a < 0$, the upwind flux is $F^{\\mathrm{adv}}_{j \\pm 1/2}(u) = a u_{j \\pm 1/2 + 1/2} = a u_{j+1 \\text{ or } j}$.\n$$ N(\\mathbf{u})_j = -\\frac{1}{h} (a u_{j+1} - a u_j) = -\\frac{a}{h} (u_{j+1} - u_j) $$\nThese operations can be efficiently implemented using vector shifts (e.g., `numpy.roll`).\n\n**2. Action of the Matrix Exponential**\nThe action of the matrix exponential $e^{\\tau L}$ on a vector $\\mathbf{v}$ can be computed efficiently in Fourier space. Since $L$ is a circulant matrix, it is diagonalized by the Discrete Fourier Transform (DFT). The eigenvalues $\\lambda_k$ of the operator $L$ corresponding to the $k$-th Fourier mode $e^{2\\pi i k x}$ are:\n$$ \\lambda_k = -\\frac{4\\nu}{h^2} \\sin^2\\left(\\frac{\\pi k}{K}\\right), \\quad k = 0, 1, \\dots, K-1 $$\nThe action $e^{\\tau L}\\mathbf{v}$ is computed via the following steps:\n1.  Compute the DFT of the vector $\\mathbf{v}$: $\\hat{\\mathbf{v}} = \\text{DFT}(\\mathbf{v})$.\n2.  Multiply each component $\\hat{v}_k$ by the corresponding exponential factor $e^{\\tau \\lambda_k}$.\n3.  Compute the inverse DFT of the result: $\\mathbf{w} = \\text{IDFT}(e^{\\tau \\Lambda} \\hat{\\mathbf{v}})$.\nThis process is highly efficient and avoids the explicit construction and exponentiation of the matrix $L$.\n\n**3. Algorithmic Steps**\nTo compute $\\mathbf{u}_{n+1}$ from $\\mathbf{u}_n$:\n1.  Compute the advection term for the initial state: $N_n = N(\\mathbf{u}_n)$.\n2.  Evolve $\\mathbf{u}_n$ and $N_n$ by a half-step with the linear operator:\n    - $\\mathbf{v}_1 = e^{\\frac{\\Delta t}{2} L} \\mathbf{u}_n$\n    - $\\mathbf{v}_2 = e^{\\frac{\\Delta t}{2} L} N_n$\n3.  Form the intermediate state $\\mathbf{u}_{mid}$:\n    - $\\mathbf{u}_{mid} = \\mathbf{v}_1 + \\frac{\\Delta t}{2} \\mathbf{v}_2$\n4.  Compute the advection term at the intermediate state: $N_{mid} = N(\\mathbf{u}_{mid})$.\n5.  Evolve $\\mathbf{u}_n$ by a full step and $N_{mid}$ by a half-step with the linear operator:\n    - $\\mathbf{v}_3 = e^{\\Delta t L} \\mathbf{u}_n$ (This can be computed as $e^{\\frac{\\Delta t}{2} L} \\mathbf{v}_1$)\n    - $\\mathbf{v}_4 = e^{\\frac{\\Delta t}{2} L} N_{mid}$\n6.  Combine to form the final result:\n    - $\\mathbf{u}_{n+1} = \\mathbf{v}_3 + \\Delta t \\, \\mathbf{v}_4$\n\n**4. Special Test Cases**\n- **Case 2 ($a=0$):** In this case, $N(\\mathbf{u}) \\equiv \\mathbf{0}$. The Lawson-midpoint formula simplifies to $\\mathbf{u}_{n+1} = e^{\\Delta t L} \\mathbf{u}_n$, which is the exact solution to the pure diffusion equation $\\mathbf{u}' = L\\mathbf{u}$. Thus, $\\mathbf{u}^{\\mathrm{Lawson}}$ is identical to $\\mathbf{u}^{\\mathrm{diffusion}}$, and their difference norm is zero.\n- **Case 3 ($\\nu=0$):** In this case, the diffusion operator $L \\equiv \\mathbf{0}$, so its eigenvalues are all zero. The matrix exponential becomes the identity operator: $e^{\\tau L} = I$. The Lawson-midpoint formula reduces to the standard explicit midpoint Runge-Kutta method for the pure advection equation $\\mathbf{u}' = N(\\mathbf{u})$:\n  - $\\mathbf{u}_{mid} = \\mathbf{u}_n + \\frac{\\Delta t}{2} N(\\mathbf{u}_n)$\n  - $\\mathbf{u}_{n+1} = \\mathbf{u}_n + \\Delta t N(\\mathbf{u}_{mid})$\nThe implementation will handle these cases naturally without special code paths, serving as a validation of the general algorithm.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom numpy.fft import fft, ifft, fftfreq\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the second-order Lawson method.\n    \"\"\"\n    test_cases = [\n        {'K': 64, 'a': 1.0, 'nu': 0.05, 'dt': 1e-3, 'task': 1},\n        {'K': 64, 'a': 0.0, 'nu': 0.05, 'dt': 1e-3, 'task': 2},\n        {'K': 64, 'a': 3.0, 'nu': 0.0,  'dt': 1e-1, 'task': 3},\n    ]\n\n    results = []\n    for params in test_cases:\n        result = run_one_case(**params)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.15g}' for r in results)}]\")\n\ndef run_one_case(K, a, nu, dt, task):\n    \"\"\"\n    Sets up and solves a single test case.\n    \"\"\"\n    # 1. Setup grid and initial condition\n    h = 1.0 / K\n    x = (np.arange(K) + 0.5) * h\n    u0 = np.sin(2 * np.pi * x)\n\n    # 2. Perform one step of the Lawson-Midpoint method\n    u1 = lawson_midpoint_step(u0, K, a, nu, dt, h)\n    \n    # 3. Compute the required metric for the task\n    if task == 1:\n        # Discrete L2 norm ||u||_{2,h}\n        return np.sqrt(h * np.sum(u1**2))\n    elif task == 2:\n        # L2 norm of the difference ||u_lawson - u_diffusion||_{2,h}\n        # For a=0, N=0, and the Lawson method should reduce to the exact solution\n        # of the linear part. The difference should be zero up to machine precision.\n        u_diffusion = exp_L_action(u0, dt, K, nu, h)\n        diff = u1 - u_diffusion\n        return np.sqrt(h * np.sum(diff**2))\n    elif task == 3:\n        # Max absolute value max|u|\n        return np.max(np.abs(u1))\n    else:\n        raise ValueError(\"Invalid task number.\")\n\ndef lawson_midpoint_step(u_n, K, a, nu, dt, h):\n    \"\"\"\n    Performs one step of the second-order Lawson method (based on explicit midpoint RK).\n    u_{n+1} = exp(dt*L)u_n + dt*exp(dt/2*L)*N(exp(dt/2*L)u_n + dt/2*exp(dt/2*L)N(u_n))\n    \"\"\"\n    \n    # Define the nonlinear advection operator N(u)\n    def N(u, a_val, h_val):\n        if a_val >= 0:\n            # Upwind flux difference for a > 0\n            flux_diff = u - np.roll(u, 1)\n        else:\n            # Upwind flux difference for a < 0\n            flux_diff = np.roll(u, -1) - u\n        return -a_val / h_val * flux_diff\n        \n    # --- Algorithm Steps ---\n    \n    # 1. Compute initial nonlinear term\n    N_n = N(u_n, a, h)\n    \n    # 2. Evolve u_n and N_n by a half-step under the linear operator L\n    u_n_half_evolved = exp_L_action(u_n, dt / 2.0, K, nu, h)\n    N_n_half_evolved = exp_L_action(N_n, dt / 2.0, K, nu, h)\n    \n    # 3. Form the intermediate state for the midpoint evaluation\n    u_mid = u_n_half_evolved + (dt / 2.0) * N_n_half_evolved\n    \n    # 4. Evaluate nonlinear term at the intermediate state\n    N_mid = N(u_mid, a, h)\n    \n    # 5. Evolve u_n by a full step and N_mid by a half-step\n    # We can reuse u_n_half_evolved to get the full-step evolution\n    # exp(dt*L)u_n = exp(dt/2*L) * exp(dt/2*L)u_n\n    u_n_full_evolved = exp_L_action(u_n_half_evolved, dt / 2.0, K, nu, h)\n    N_mid_half_evolved = exp_L_action(N_mid, dt / 2.0, K, nu, h)\n    \n    # 6. Combine to form the final solution\n    u_np1 = u_n_full_evolved + dt * N_mid_half_evolved\n    \n    return u_np1\n\ndef exp_L_action(v, tau, K, nu, h):\n    \"\"\"\n    Computes the action of the matrix exponential exp(tau*L) on a vector v\n    using the Fourier spectral method.\n    \"\"\"\n    # If nu=0, L is the zero matrix, so exp(tau*L) is the identity\n    if nu == 0.0:\n        return v\n    \n    # Calculate eigenvalues of the operator L in Fourier space.\n    # fftfreq provides the correct frequency ordering for numpy's FFT.\n    # The term k/K in the sin argument corresponds to freq*h, where freq are the wavenumbers.\n    k_indices = fftfreq(K) * K\n    lambda_k = -4.0 * nu / h**2 * np.sin(np.pi * k_indices / K)**2\n    \n    # Apply the operator in Fourier space\n    v_hat = fft(v)\n    v_hat_evolved = np.exp(tau * lambda_k) * v_hat\n    v_evolved = ifft(v_hat_evolved)\n    \n    # The result should be real since the operator and input are real.\n    return np.real(v_evolved)\n\nsolve()\n```", "id": "3386153"}, {"introduction": "High-performance scientific computing requires not only choosing the right algorithm but also implementing its core components efficiently. This final practice addresses a critical challenge in applying exponential integrators to systems from Discontinuous Galerkin (DG) methods: the computation of $\\varphi$-function actions on matrices with widely clustered eigenvalues [@problem_id:3386179]. By implementing and comparing a standard contour integral method with an advanced spectral partitioning strategy, you will learn how to tailor numerical linear algebra techniques to the specific structure of your problem, dramatically improving performance and robustness.", "problem": "Consider the matrix function arising in exponential integrators, the function $\\varphi_1(z)$ defined by $\\varphi_1(z) = \\frac{e^{z} - 1}{z}$ for $z \\neq 0$ and $\\varphi_1(0) = 1$, and its action on a matrix $A$ scaled by a time step $h > 0$, namely $\\varphi_1(h A)$. In the context of spectral and Discontinuous Galerkin (DG) methods, stabilization terms and numerical fluxes often produce stiffness matrices $A$ whose eigenvalues are real, negative, and may be split into clusters of distinct magnitudes due to penalty parameters and mesh size scaling, which is a well-documented phenomenon in DG stabilization. A robust and general representation of $f(A)$ for an analytic function $f$ is given by the Dunford–Taylor integral\n$$\nf(A) = \\frac{1}{2\\pi i} \\int_{\\Gamma} f(z)\\,(z I - A)^{-1}\\, dz,\n$$\nwhere $\\Gamma$ is a positively oriented contour enclosing the spectrum of $A$, and $i$ is the imaginary unit. For $f(z) = \\varphi_1(h z)$, this yields a contour-integral representation for $\\varphi_1(h A)$. Approximating this integral by the trapezoidal rule on a circular contour $\\Gamma: z(\\theta) = c + R e^{i \\theta}$ with $\\theta \\in [0, 2\\pi)$ gives a quadrature of the form\n$$\n\\varphi_1(h A)\\, b \\approx \\sum_{k=0}^{M-1} w_k \\, \\big(z_k I - A\\big)^{-1} b, \\quad z_k = c + R e^{i \\theta_k}, \\quad \\theta_k = \\frac{2\\pi k}{M},\n$$\nwith weights\n$$\nw_k = \\frac{R e^{i \\theta_k}}{M} \\, \\varphi_1(h z_k).\n$$\nHere $b$ is a given vector. The trapezoidal rule exhibits exponential convergence for periodic analytic integrands; however, when the spectrum of $A$ is spread across multiple clusters with very different magnitudes, a single-circle contour that encloses the entire spectrum may either need a large radius (which can traverse regions where $\\operatorname{Re}(z)$ is close to $0$ or positive, causing $e^{h z}$ growth and reduced efficiency) or may become poorly balanced relative to the location of poles of the resolvent $(z I - A)^{-1}$. A classical device from the functional calculus is to partition the contour into disjoint sub-contours $\\Gamma = \\Gamma_1 \\cup \\Gamma_2$ that enclose disjoint portions of the spectrum; the additive property\n$$\n\\frac{1}{2\\pi i} \\int_{\\Gamma} f(z) (z I - A)^{-1} dz = \\sum_{j} \\frac{1}{2\\pi i} \\int_{\\Gamma_j} f(z) (z I - A)^{-1} dz\n$$\nthen permits evaluating each integral with a contour adapted to its local spectral subset. This is referred to here as spectral partitioning.\n\nYour task is to evaluate the consistency and efficiency of the quadrature-based computation of $\\varphi_1(h A)\\, b$ for matrices $A$ with eigenvalue clustering motivated by Discontinuous Galerkin (DG) stabilization, and to implement a spectral partitioning strategy that automatically splits the spectrum into two clusters and assigns a separate circular contour to each cluster to improve quadrature efficiency.\n\nFundamental base to use:\n- The Dunford–Taylor representation of matrix functions for analytic $f$.\n- The definition of $\\varphi_1(z)$ via the exponential function.\n- The basic convergence property of the trapezoidal rule for periodic analytic integrands.\n- The block-exponential identity: if $M = \\begin{bmatrix} h A & I \\\\ 0 & 0 \\end{bmatrix}$, then $\\exp(M) = \\begin{bmatrix} \\exp(h A) & \\varphi_1(h A) \\\\ 0 & I \\end{bmatrix}$, so the upper-right block equals $\\varphi_1(h A)$.\n\nDesign requirements:\n- Construct test matrices $A$ that are diagonal with real negative eigenvalues arranged in two clusters, emulating clustering from DG stabilization. For each test case, $A = \\operatorname{diag}(\\lambda_1, \\dots, \\lambda_n)$ with $n = 60$, and the vector $b \\in \\mathbb{R}^n$ has entries $b_i = 1$ for all $i$.\n- Implement the quadrature on a circle $\\Gamma: z(\\theta) = c + R e^{i \\theta}$ with weights and nodes as above for an integer $M \\ge 8$.\n- Implement a spectral partitioning algorithm that:\n  1. Sorts the real parts of the eigenvalues and finds the largest consecutive gap to split them into two clusters.\n  2. For each cluster, defines a circle with center $c_j = \\frac{\\lambda_{\\min,j} + \\lambda_{\\max,j}}{2}$ and radius $R_j = \\alpha \\frac{\\lambda_{\\max,j} - \\lambda_{\\min,j}}{2}$ with expansion factor $\\alpha = 1.3$.\n  3. If $c_j + R_j \\ge 0$, shift the center left so that $c_j + R_j = -1$ to keep the contour strictly in the open left half-plane, thereby controlling $e^{h z}$.\n  4. Approximates $\\varphi_1(h A) b$ by summing the two contour contributions.\n- Define a single-circle strategy that uses the same center-radius formula with the full spectrum and the same left-shift safeguard.\n- For both strategies, determine the smallest $M$ in the candidate set $\\{8, 16, 32, 64, 128\\}$ that achieves a relative $\\ell^2$-error less than or equal to a tolerance $\\varepsilon = 10^{-8}$, where the reference solution is computed by the block-exponential identity as described above using the matrix exponential of size $2n \\times 2n$.\n\nNumerical details to implement:\n- Use $n = 60$ and $b_i = 1$ for all $i$.\n- For each cluster, draw $30$ eigenvalues uniformly from the interval $[\\text{center} - \\frac{\\text{width}}{2}, \\text{center} + \\frac{\\text{width}}{2}]$.\n- Implement $\\varphi_1$ robustly using the series $\\varphi_1(z) = 1 + \\frac{z}{2} + \\frac{z^2}{6} + \\frac{z^3}{24} + \\frac{z^4}{120}$ for $\\lvert z \\rvert \\le 10^{-6}$ to avoid cancellation.\n- The relative error is measured as $\\frac{\\lVert y_{\\text{approx}} - y_{\\text{ref}} \\rVert_2}{\\lVert y_{\\text{ref}} \\rVert_2}$.\n\nTest suite:\n- Case $1$: cluster centers $-10$ and $-200$, widths $1$ and $10$, and $h = 0.1$.\n- Case $2$: cluster centers $-50$ and $-5000$, widths $5$ and $50$, and $h = 0.05$.\n- Case $3$: cluster centers $-100$ and $-150$, widths $2$ and $2$, and $h = 0.2$.\n\nFor each case, compute the efficiency ratio\n$$\n\\rho = \\frac{M_{\\text{single}}}{M_{\\text{partition}}},\n$$\nwhere $M_{\\text{single}}$ is the minimal number of nodes needed by the single-circle strategy to reach the tolerance, and $M_{\\text{partition}}$ is the minimal number of nodes needed by the partitioned strategy to reach the same tolerance. If neither strategy reaches the tolerance within the candidate set, use the largest tested $M$ for that strategy.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list should contain the efficiency ratios $\\rho$ for the three test cases in the order given, represented as floating-point numbers, for example, $[\\rho_1,\\rho_2,\\rho_3]$.", "solution": "We start from the Dunford–Taylor representation for analytic functions of a matrix. For an analytic scalar function $f$, the operator $f(A)$ for a matrix $A$ with spectrum enclosed by a positively oriented contour $\\Gamma$ is given by\n$$\nf(A) = \\frac{1}{2\\pi i} \\int_{\\Gamma} f(z)\\,(z I - A)^{-1}\\, dz.\n$$\nChoosing $f(z) = \\varphi_1(h z)$ yields\n$$\n\\varphi_1(h A) = \\frac{1}{2\\pi i} \\int_{\\Gamma} \\varphi_1(h z)\\,(z I - A)^{-1}\\, dz.\n$$\nTo compute the action on a vector $b$, we write\n$$\n\\varphi_1(h A)\\, b = \\frac{1}{2\\pi i} \\int_{\\Gamma} \\varphi_1(h z)\\,(z I - A)^{-1}\\, b \\, dz.\n$$\nWe parameterize a circular contour by $z(\\theta) = c + R e^{i \\theta}$ with $\\theta \\in [0, 2\\pi)$, for which $dz = i R e^{i \\theta} d\\theta$. Discretizing by the trapezoidal rule with $M$ nodes $\\theta_k = \\frac{2\\pi k}{M}$ yields an exponentially convergent approximation for periodic analytic integrands:\n$$\n\\varphi_1(h A) \\, b \\approx \\sum_{k=0}^{M-1} w_k \\,(z_k I - A)^{-1} b, \\quad z_k = c + R e^{i \\theta_k},\n$$\nwith weights obtained by substituting $dz$ and the $1/(2\\pi i)$ factor:\n$$\nw_k = \\frac{R e^{i \\theta_k}}{M} \\, \\varphi_1(h z_k).\n$$\nThe error of the trapezoidal rule for analytic periodic functions decays like $e^{-a M}$, where $a$ is the half-width of the strip of analyticity in the complex $\\theta$-plane. For a circular contour enclosing poles of the resolvent at eigenvalues of $A$, the nearest singularities in the $\\theta$-plane occur when $z(\\theta)$ analytically continues to the eigenvalues, leading to a strip width roughly $\\log\\!\\big(\\frac{R}{r_{\\max}}\\big)$, where $r_{\\max}$ is the maximum distance of enclosed poles (eigenvalues) from the circle’s center. Thus, if we choose $R = \\alpha r_{\\max}$ with a modest expansion $\\alpha > 1$, we obtain a strip width $\\log(\\alpha)$ and exponential convergence $\\sim e^{-\\log(\\alpha) M}$. However, if the full spectrum spans widely separated clusters, placing a single circle around the entire spectrum forces the center and radius to balance both clusters, which can push parts of the circle toward the imaginary axis or even into the right half-plane. Since $\\varphi_1(h z)$ inherits $e^{h z}$ behavior, excursions with $\\operatorname{Re}(z)$ near or above $0$ demand larger $M$ to control error. \n\nSpectral partitioning addresses this by dividing the spectrum into disjoint subsets $\\{\\sigma_1(A), \\sigma_2(A)\\}$ and using separate contours $\\Gamma_1, \\Gamma_2$ that each enclose only one subset. The linearity of the Dunford–Taylor integral and contour additivity give\n$$\n\\varphi_1(h A) = \\frac{1}{2\\pi i} \\int_{\\Gamma_1 \\cup \\Gamma_2} \\varphi_1(h z)\\,(z I - A)^{-1}\\, dz = \\sum_{j=1}^{2} \\frac{1}{2\\pi i} \\int_{\\Gamma_j} \\varphi_1(h z)\\,(z I - A)^{-1}\\, dz.\n$$\nEach $\\Gamma_j$ is chosen to enclose only $\\sigma_j(A)$, which allows a center near the cluster and a modest radius expansion factor $\\alpha$, while keeping the entire circle in the left half-plane, ensuring that $\\operatorname{Re}(z) \\ll 0$ and thereby controlling $\\varphi_1(h z)$.\n\nReference computation and consistency. To assess the consistency (accuracy) of the quadrature, we require a reliable ground truth. Using the block-exponential identity,\n$$\n\\exp\\!\\left( \\begin{bmatrix} h A & I \\\\ 0 & 0 \\end{bmatrix} \\right) = \\begin{bmatrix} \\exp(h A) & \\varphi_1(h A) \\\\ 0 & I \\end{bmatrix},\n$$\nwe can compute $\\varphi_1(h A)$ as the $(1,2)$ block of $\\exp(M)$, where $M$ is the augmented matrix. This avoids inverting $A$ and remains valid even if $A$ is singular. For a given $b$, we compute $y_{\\text{ref}} = \\varphi_1(h A)\\, b$ by forming $M$, computing $\\exp(M)$ via a stable algorithm, and extracting the appropriate block. In practice, with $A$ diagonal of size $n = 60$, the augmented matrix is of size $2n \\times 2n$, which is numerically manageable.\n\nAlgorithmic design.\n1. Matrix and vector construction. For each test case, construct $A = \\operatorname{diag}(\\lambda_1, \\dots, \\lambda_n)$ where the eigenvalues are arranged in two clusters. For cluster $j \\in \\{1,2\\}$, sample $n/2$ eigenvalues uniformly from an interval $[\\mu_j - \\frac{w_j}{2}, \\mu_j + \\frac{w_j}{2}]$, where $\\mu_j < 0$ is the cluster center and $w_j > 0$ is the cluster width. Set $b \\in \\mathbb{R}^n$ with $b_i = 1$ for all $i$.\n2. Robust $\\varphi_1$. Implement $\\varphi_1(z)$ so that for $\\lvert z \\rvert \\le 10^{-6}$, use the Taylor series $\\varphi_1(z) \\approx 1 + \\frac{z}{2} + \\frac{z^2}{6} + \\frac{z^3}{24} + \\frac{z^4}{120}$ to avoid catastrophic cancellation in $(e^z - 1)/z$.\n3. Single-circle strategy. Compute $c = \\frac{\\lambda_{\\min} + \\lambda_{\\max}}{2}$ and $R = \\alpha \\frac{\\lambda_{\\max} - \\lambda_{\\min}}{2}$ with $\\alpha = 1.3$. If $c + R \\ge 0$, shift $c$ left to enforce $c + R = -1$ so that the circle lies in the left half-plane. For a candidate $M$, approximate\n$$\ny_{\\text{single}}(M) = \\sum_{k=0}^{M-1} \\frac{R e^{i \\theta_k}}{M} \\, \\varphi_1(h z_k)\\, (z_k I - A)^{-1} b, \\quad z_k = c + R e^{i \\theta_k}.\n$$\n4. Spectral partitioning. Sort the eigenvalues by real part and find the largest gap between consecutive entries. Split at this gap into two clusters. For each cluster $j$, set $c_j = \\frac{\\lambda_{\\min,j} + \\lambda_{\\max,j}}{2}$ and $R_j = \\alpha \\frac{\\lambda_{\\max,j} - \\lambda_{\\min,j}}{2}$ with the same $\\alpha = 1.3$, and enforce $c_j + R_j < 0$ by shifting to $c_j + R_j = -1$ if necessary. Compute\n$$\ny_{\\text{part}}(M) = \\sum_{j=1}^{2} \\sum_{k=0}^{M-1} \\frac{R_j e^{i \\theta_k}}{M} \\, \\varphi_1(h z_{j,k})\\, (z_{j,k} I - A)^{-1} b, \\quad z_{j,k} = c_j + R_j e^{i \\theta_k}.\n$$\n5. Reference solution. Form $M = \\begin{bmatrix} h A & I \\\\ 0 & 0 \\end{bmatrix}$ and compute $\\exp(M)$. Extract the $(1,2)$ block to get $\\varphi_1(h A)$, and compute $y_{\\text{ref}} = \\varphi_1(h A) b$.\n6. Error and minimal $M$. For each strategy and each candidate $M$ in $\\{8, 16, 32, 64, 128\\}$, compute the relative $\\ell^2$-error\n$$\nE(M) = \\frac{\\lVert y_{\\text{approx}}(M) - y_{\\text{ref}} \\rVert_2}{\\lVert y_{\\text{ref}} \\rVert_2}.\n$$\nSelect the smallest $M$ with $E(M) \\le \\varepsilon$, where $\\varepsilon = 10^{-8}$. If none meet the tolerance, choose the largest $M$.\n7. Efficiency ratio. For each test case, compute $\\rho = \\frac{M_{\\text{single}}}{M_{\\text{partition}}}$.\n\nTest suite definitions. We adopt three cases with $n = 60$ and $b_i = 1$:\n- Case $1$: cluster centers $\\mu_1 = -10$, $\\mu_2 = -200$, widths $w_1 = 1$, $w_2 = 10$, and $h = 0.1$.\n- Case $2$: cluster centers $\\mu_1 = -50$, $\\mu_2 = -5000$, widths $w_1 = 5$, $w_2 = 50$, and $h = 0.05$.\n- Case $3$: cluster centers $\\mu_1 = -100$, $\\mu_2 = -150$, widths $w_1 = 2$, $w_2 = 2$, and $h = 0.2$.\n\nScientific rationale. Discontinuous Galerkin stabilization, such as interior penalty terms, produces discrete operators with eigenvalues that scale like negative powers of the mesh size, which results in clusters of large negative values. The contour-integral approach is compatible with such stiffness but requires careful contour placement to avoid regions where $\\operatorname{Re}(z)$ is close to or greater than $0$, which would make $\\varphi_1(h z)$ large and degrade accuracy for fixed $M$. Spectral partitioning allows each contour to be adapted to a cluster, maintaining a safe distance from the imaginary axis and ensuring the analyticity strip width is not unduly reduced by far-away spectral components. This improves quadrature efficiency as quantified by the smaller $M$ required to meet the tolerance.\n\nFinal output specification. Your program must output a single line with a list of three floating-point numbers $[\\rho_1,\\rho_2,\\rho_3]$ corresponding to the three test cases in the order defined above.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef phi1_scalar(z):\n    \"\"\"Stable evaluation of phi1(z) = (exp(z) - 1)/z with series near zero.\"\"\"\n    # Use series for small |z|\n    if np.abs(z) <= 1e-6:\n        # 1 + z/2 + z^2/6 + z^3/24 + z^4/120\n        return 1.0 + z/2.0 + (z*z)/6.0 + (z*z*z)/24.0 + (z*z*z*z)/120.0\n    else:\n        return (np.exp(z) - 1.0) / z\n\ndef phi1_array(z):\n    \"\"\"Vectorized phi1 for numpy arrays of complex numbers.\"\"\"\n    z = np.asarray(z, dtype=complex)\n    out = np.empty_like(z, dtype=complex)\n    small = np.abs(z) <= 1e-6\n    not_small = ~small\n    # Series for small\n    zs = z[small]\n    out[small] = 1.0 + zs/2.0 + (zs*zs)/6.0 + (zs*zs*zs)/24.0 + (zs*zs*zs*zs)/120.0\n    # Direct for others\n    zn = z[not_small]\n    out[not_small] = (np.exp(zn) - 1.0) / zn\n    return out\n\ndef generate_eigenvalues(center1, width1, center2, width2, n_per_cluster=30, seed=42):\n    \"\"\"Generate two clusters of negative real eigenvalues.\"\"\"\n    rng = np.random.default_rng(seed)\n    lam1 = rng.uniform(center1 - width1/2.0, center1 + width1/2.0, size=n_per_cluster)\n    lam2 = rng.uniform(center2 - width2/2.0, center2 + width2/2.0, size=n_per_cluster)\n    lambdas = np.concatenate([lam1, lam2])\n    # Ensure strictly negative\n    lambdas = np.minimum(lambdas, -1e-12)\n    return np.sort(lambdas)\n\ndef build_reference_phi1A_times_b(lambdas, h, b):\n    \"\"\"Compute y_ref = phi1(h A) b using block-exponential identity.\n       A is diagonal with eigenvalues lambdas.\"\"\"\n    n = lambdas.size\n    # Build A as diagonal matrix\n    A = np.diag(lambdas)\n    # Build augmented matrix M = [[hA, I],[0, 0]], shape 2n x 2n\n    M = np.zeros((2*n, 2*n), dtype=float)\n    M[:n, :n] = h * A\n    M[:n, n:] = np.eye(n)\n    # exp(M)\n    EM = expm(M)\n    # Top-right block is phi1(hA)\n    phi_block = EM[:n, n:]\n    y_ref = phi_block @ b\n    return y_ref\n\ndef circle_params_from_spectrum(lambdas, alpha=1.3):\n    \"\"\"Compute circle center c and radius R for a set of real eigenvalues.\"\"\"\n    lam_min = np.min(lambdas.real)\n    lam_max = np.max(lambdas.real)\n    c = 0.5 * (lam_min + lam_max)\n    base = 0.5 * (lam_max - lam_min)\n    # If base is zero (all equal), set a minimal radius\n    if base == 0.0:\n        base = max(1.0, abs(c) * 0.1 + 1.0)\n    R = alpha * base\n    # Shift left if rightmost point is not strictly negative\n    if c + R >= -1e-12:\n        # Move c so that c + R = -1\n        c = -1.0 - R\n    return c, R\n\ndef largest_gap_partition(lambdas):\n    \"\"\"Partition eigenvalues into two clusters by the largest consecutive gap.\"\"\"\n    vals = np.sort(lambdas.real)\n    gaps = np.diff(vals)\n    # Handle uniform case: if no positive gap, split in the middle\n    if gaps.size == 0:\n        idx = 0\n    else:\n        idx = int(np.argmax(gaps))\n    threshold = (vals[idx] + vals[idx+1]) / 2.0 if gaps.size > 0 else vals[0]\n    mask = lambdas.real <= threshold\n    cluster1 = lambdas[mask]\n    cluster2 = lambdas[~mask]\n    # Ensure both non-empty; if one empty, split evenly\n    if cluster1.size == 0 or cluster2.size == 0:\n        half = lambdas.size // 2\n        cluster1 = lambdas[:half]\n        cluster2 = lambdas[half:]\n    return cluster1, cluster2\n\ndef resolvent_action_diag(z, lambdas, b):\n    \"\"\"Compute (z I - A)^{-1} b for diagonal A with eigenvalues lambdas.\"\"\"\n    return b / (z - lambdas)\n\ndef contour_quad_apply_phi1(lambdas, h, b, c, R, M):\n    \"\"\"Approximate y = phi1(h A) b by contour quadrature on circle (c, R) with M nodes.\"\"\"\n    thetas = 2.0 * np.pi * np.arange(M) / M\n    z_k = c + R * np.exp(1j * thetas)\n    weights = (R * np.exp(1j * thetas) / M) * phi1_array(h * z_k)\n    # Sum weights * resolvent_action\n    y = np.zeros_like(b, dtype=complex)\n    for wk, zk in zip(weights, z_k):\n        y += wk * resolvent_action_diag(zk, lambdas, b)\n    # The integral already includes 1/(2πi) factor via our weight derivation\n    # Indeed, weights were derived: w_k = (R e^{iθ_k}/M) * phi1(h z_k), which accounts for 1/(2πi) * dz.\n    # Take real part if close to real\n    return np.real_if_close(y, tol=1e-10)\n\ndef single_circle_min_M(lambdas, h, b, y_ref, candidates, tol):\n    c, R = circle_params_from_spectrum(lambdas)\n    chosen = candidates[-1]\n    for M in candidates:\n        y = contour_quad_apply_phi1(lambdas, h, b, c, R, M)\n        err = np.linalg.norm(y - y_ref) / np.linalg.norm(y_ref)\n        if err <= tol:\n            chosen = M\n            break\n    return chosen\n\ndef partitioned_circles_min_M(lambdas, h, b, y_ref, candidates, tol):\n    cluster1, cluster2 = largest_gap_partition(lambdas)\n    c1, R1 = circle_params_from_spectrum(cluster1)\n    c2, R2 = circle_params_from_spectrum(cluster2)\n    chosen = candidates[-1]\n    for M in candidates:\n        y1 = contour_quad_apply_phi1(lambdas, h, b, c1, R1, M)\n        y2 = contour_quad_apply_phi1(lambdas, h, b, c2, R2, M)\n        y = y1 + y2\n        err = np.linalg.norm(y - y_ref) / np.linalg.norm(y_ref)\n        if err <= tol:\n            chosen = M\n            break\n    return chosen\n\ndef run_case(center1, width1, center2, width2, h, n_per_cluster=30, seed=42, tol=1e-8):\n    lambdas = generate_eigenvalues(center1, width1, center2, width2, n_per_cluster=n_per_cluster, seed=seed)\n    n = lambdas.size\n    b = np.ones(n, dtype=float)\n    y_ref = build_reference_phi1A_times_b(lambdas, h, b)\n    candidates = [8, 16, 32, 64, 128]\n    M_single = single_circle_min_M(lambdas, h, b, y_ref, candidates, tol)\n    M_part = partitioned_circles_min_M(lambdas, h, b, y_ref, candidates, tol)\n    ratio = float(M_single) / float(M_part) if M_part != 0 else float('inf')\n    return ratio\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case: (center1, width1, center2, width2, h)\n    test_cases = [\n        (-10.0, 1.0, -200.0, 10.0, 0.1),   # Case 1\n        (-50.0, 5.0, -5000.0, 50.0, 0.05), # Case 2\n        (-100.0, 2.0, -150.0, 2.0, 0.2),   # Case 3\n    ]\n\n    results = []\n    for center1, width1, center2, width2, h in test_cases:\n        ratio = run_case(center1, width1, center2, width2, h, n_per_cluster=30, seed=42, tol=1e-8)\n        # For stable, readable output, round to 3 decimals\n        results.append(f\"{ratio:.3f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3386179"}]}