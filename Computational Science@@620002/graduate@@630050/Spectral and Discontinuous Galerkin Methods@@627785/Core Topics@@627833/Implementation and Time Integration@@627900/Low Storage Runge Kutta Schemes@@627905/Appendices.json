{"hands_on_practices": [{"introduction": "This first practice exercise builds your foundational understanding of stability analysis from first principles. You will derive the stability function for a popular third-order low-storage scheme and combine it with the eigenvalue spectrum of a simple Discontinuous Galerkin operator to determine the maximum stable Courant number. This pencil-and-paper exercise is crucial for demystifying how the choice of time-stepper and spatial discretization interact to govern the stability of a numerical simulation.", "problem": "Consider the one-dimensional linear advection equation $u_{t} + a\\,u_{x} = 0$ with constant advection speed $a > 0$ on a periodic domain $x \\in [0,L]$. Discretize in space using a discontinuous Galerkin (DG) method with piecewise constants (polynomial degree $p=0$) on a uniform mesh with $K$ elements, element size $h = L/K$, numerical flux equal to the upwind flux, and standard $L^{2}$ mass-lumping within each element. This yields a semi-discrete method of lines $\\frac{\\mathrm{d}}{\\mathrm{d}t}\\mathbf{u}(t) = L\\,\\mathbf{u}(t)$ with a block-circulant matrix $L$.\n\nTime advance is performed by the following two-register low-storage three-stage, third-order scheme (equivalent to the Shu–Osher strong-stability-preserving Runge–Kutta method of order three), written for any right-hand side $F(\\mathbf{u})$:\n- Stage $1$: $\\mathbf{u}^{(1)} = \\mathbf{u}^{n} + \\Delta t\\,F(\\mathbf{u}^{n})$.\n- Stage $2$: $\\mathbf{u}^{(2)} = \\frac{3}{4}\\,\\mathbf{u}^{n} + \\frac{1}{4}\\left(\\mathbf{u}^{(1)} + \\Delta t\\,F(\\mathbf{u}^{(1)})\\right)$.\n- Stage $3$: $\\mathbf{u}^{n+1} = \\frac{1}{3}\\,\\mathbf{u}^{n} + \\frac{2}{3}\\left(\\mathbf{u}^{(2)} + \\Delta t\\,F(\\mathbf{u}^{(2)})\\right)$.\n\nYour tasks are:\n1. Starting from the definition of the absolute stability function for a Runge–Kutta method applied to the linear test equation $y'(t) = \\lambda\\,y(t)$, derive the stability function $R(z)$ of the above low-storage scheme, where $z = \\lambda\\,\\Delta t$.\n2. For the DG semi-discretization with $p=0$ and upwind flux on a uniform periodic grid, derive the eigenvalue set $\\Lambda(L)$ of the semi-discrete operator $L$ by applying a Fourier mode ansatz. Then, using the Courant number $C = a\\,\\Delta t/h$, express the stability condition $\\max_{\\lambda \\in \\Lambda(L)}\\left|R(\\Delta t\\,\\lambda)\\right| \\le 1$ as a condition on $C$ involving an explicit univariate extremization with respect to a Fourier phase $\\theta \\in [0,2\\pi]$.\n3. Determine the largest admissible Courant number $C_{\\max}$ such that the absolute stability condition is satisfied for all $\\lambda \\in \\Lambda(L)$. Your final answer must be a single real number. Round your answer to four significant figures.\n\nNo further simplifications or prederived formulas may be used beyond the above definitions and the stated scheme. State clearly any intermediate transformations you make and justify each step from first principles of the method of lines, the DG semi-discretization with upwind flux, and the definition of a Runge–Kutta absolute stability function. The final answer must be the single value of $C_{\\max}$ (no units).", "solution": "The user has provided a three-part problem concerning the stability analysis of a discontinuous Galerkin (DG) finite element method combined with a low-storage Runge-Kutta (RK) time integration scheme for the linear advection equation. First, the problem's validity must be established.\n\n### Step 1: Extract Givens\n- **Equation**: One-dimensional linear advection equation $u_{t} + a\\,u_{x} = 0$, with constant advection speed $a > 0$.\n- **Domain**: Periodic, $x \\in [0,L]$.\n- **Spatial Discretization**:\n    - Method: Discontinuous Galerkin (DG).\n    - Polynomial Degree: $p=0$ (piecewise constants).\n    - Mesh: Uniform with $K$ elements, element size $h = L/K$.\n    - Numerical Flux: Upwind flux.\n    - Mass Matrix: Standard $L^2$ mass-lumping.\n- **Semi-Discrete Form**: $\\frac{\\mathrm{d}}{\\mathrm{d}t}\\mathbf{u}(t) = L\\,\\mathbf{u}(t)$, where $L$ is a block-circulant matrix.\n- **Time Integration Scheme**: A two-register low-storage three-stage, third-order scheme (SSP-RK3):\n    - Stage $1$: $\\mathbf{u}^{(1)} = \\mathbf{u}^{n} + \\Delta t\\,F(\\mathbf{u}^{n})$.\n    - Stage $2$: $\\mathbf{u}^{(2)} = \\frac{3}{4}\\,\\mathbf{u}^{n} + \\frac{1}{4}\\left(\\mathbf{u}^{(1)} + \\Delta t\\,F(\\mathbf{u}^{(1)})\\right)$.\n    - Stage $3$: $\\mathbf{u}^{n+1} = \\frac{1}{3}\\,\\mathbf{u}^{n} + \\frac{2}{3}\\left(\\mathbf{u}^{(2)} + \\Delta t\\,F(\\mathbf{u}^{(2)})\\right)$.\n- **Definitions**: Courant number $C = a\\,\\Delta t/h$.\n- **Tasks**:\n    1. Derive the stability function $R(z)$ of the scheme for $z = \\lambda\\,\\Delta t$.\n    2. Derive the eigenvalue set $\\Lambda(L)$ of the DG semi-discretization and express the stability condition $\\max_{\\lambda \\in \\Lambda(L)}\\left|R(\\Delta t\\,\\lambda)\\right| \\le 1$ as an extremization problem for $C$ over a Fourier phase $\\theta$.\n    3. Determine the largest admissible Courant number $C_{\\max}$.\n\n### Step 2: Validate Using Extracted Givens\n1.  **Scientifically Grounded**: The problem is firmly rooted in the field of numerical analysis for partial differential equations. The DG method, Runge-Kutta schemes, and stability analysis are standard, well-established topics. The linear advection equation is a canonical model problem. All elements are scientifically sound.\n2.  **Well-Posed**: The problem is structured as a sequence of derivations leading to a final numerical value. Each part is clearly defined and builds upon the previous one, leading to a unique and meaningful solution ($C_{\\max}$).\n3.  **Objective**: The problem is stated in precise, objective mathematical language. There are no subjective or opinion-based claims.\n4.  **Completeness**: The problem provides all necessary information: the PDE, the discretization details (DG, $p=0$, upwind flux, periodic BC), the time-stepping scheme, and the definition of the Courant number. While the problem labels the matrix $L$ as \"block-circulant\", for $p=0$ it is a simple (non-block) circulant matrix. This is a minor terminological imprecision but does not affect the solvability or create a contradiction, as the structure is fully determined by the other specifications.\n5.  **Other Flaws**: The problem is not metaphorical, trivial, ill-posed, or unverifiable. It is a standard, albeit detailed, problem in numerical analysis.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. A complete, reasoned solution will now be provided.\n\n### Solution\n\nThe problem is addressed in three sequential parts as requested.\n\n**Part 1: Derivation of the Stability Function $R(z)$**\n\nThe stability function $R(z)$ for a Runge-Kutta method is defined by the relation $y^{n+1} = R(z) y^n$ when the method is applied to the linear test equation $y'(t) = \\lambda y(t)$. Here, the right-hand side function is $F(y) = \\lambda y$, and we define $z = \\lambda \\Delta t$. We apply this to the given three-stage scheme.\n\nFor the first stage:\n$$y^{(1)} = y^n + \\Delta t F(y^n) = y^n + \\Delta t (\\lambda y^n) = (1 + \\lambda \\Delta t) y^n = (1+z) y^n$$\n\nFor the second stage, we first compute the argument of $F$, which is $y^{(1)}$, and then substitute the expression for $y^{(1)}$:\n$$y^{(2)} = \\frac{3}{4} y^n + \\frac{1}{4} \\left( y^{(1)} + \\Delta t F(y^{(1)}) \\right) = \\frac{3}{4} y^n + \\frac{1}{4} \\left( y^{(1)} + \\Delta t (\\lambda y^{(1)}) \\right)$$\n$$y^{(2)} = \\frac{3}{4} y^n + \\frac{1}{4} (1 + \\lambda \\Delta t) y^{(1)} = \\frac{3}{4} y^n + \\frac{1}{4} (1+z) y^{(1)}$$\nSubstituting $y^{(1)} = (1+z)y^n$:\n$$y^{(2)} = \\frac{3}{4} y^n + \\frac{1}{4} (1+z)(1+z) y^n = \\left[ \\frac{3}{4} + \\frac{1}{4}(1+z)^2 \\right] y^n$$\nExpanding the polynomial in $z$:\n$$y^{(2)} = \\left[ \\frac{3}{4} + \\frac{1}{4}(1 + 2z + z^2) \\right] y^n = \\left[ \\frac{3}{4} + \\frac{1}{4} + \\frac{2}{4}z + \\frac{1}{4}z^2 \\right] y^n = \\left( 1 + \\frac{1}{2}z + \\frac{1}{4}z^2 \\right) y^n$$\n\nFor the third and final stage:\n$$y^{n+1} = \\frac{1}{3} y^n + \\frac{2}{3} \\left( y^{(2)} + \\Delta t F(y^{(2)}) \\right) = \\frac{1}{3} y^n + \\frac{2}{3} (1 + \\lambda \\Delta t) y^{(2)}$$\n$$y^{n+1} = \\frac{1}{3} y^n + \\frac{2}{3} (1+z) y^{(2)}$$\nSubstituting the expression for $y^{(2)}$:\n$$y^{n+1} = \\left[ \\frac{1}{3} + \\frac{2}{3} (1+z) \\left( 1 + \\frac{1}{2}z + \\frac{1}{4}z^2 \\right) \\right] y^n$$\nThe expression in the square brackets is the stability function $R(z)$. We expand it:\n$$R(z) = \\frac{1}{3} + \\frac{2}{3} \\left( 1 \\cdot (1 + \\frac{1}{2}z + \\frac{1}{4}z^2) + z \\cdot (1 + \\frac{1}{2}z + \\frac{1}{4}z^2) \\right)$$\n$$R(z) = \\frac{1}{3} + \\frac{2}{3} \\left( 1 + \\frac{1}{2}z + \\frac{1}{4}z^2 + z + \\frac{1}{2}z^2 + \\frac{1}{4}z^3 \\right)$$\n$$R(z) = \\frac{1}{3} + \\frac{2}{3} \\left( 1 + \\frac{3}{2}z + \\frac{3}{4}z^2 + \\frac{1}{4}z^3 \\right)$$\n$$R(z) = \\frac{1}{3} + \\frac{2}{3} + z + \\frac{1}{2}z^2 + \\frac{1}{6}z^3$$\n$$R(z) = 1 + z + \\frac{1}{2}z^2 + \\frac{1}{6}z^3$$\nThis is the Taylor series expansion of $\\exp(z)$ up to the third-order term, confirming the method's third-order accuracy.\n\n**Part 2: Eigenvalue Spectrum and Stability Condition**\n\nWe first derive the semi-discrete system for the DG method with $p=0$. The DG weak formulation on an element $I_j = [x_{j-1/2}, x_{j+1/2}]$ is to find $u_h$ such that for all test functions $v_h$:\n$$\\int_{I_j} \\frac{\\partial u_h}{\\partial t} v_h \\,dx + \\int_{I_j} a \\frac{\\partial u_h}{\\partial x} v_h \\,dx = 0$$\nUsing integration by parts on the second term:\n$$\\int_{I_j} \\frac{\\partial u_h}{\\partial t} v_h \\,dx - \\int_{I_j} a u_h \\frac{\\partial v_h}{\\partial x} \\,dx + [a u_h^* v_h]_{x_{j-1/2}}^{x_{j+1/2}} = 0$$\nFor $p=0$, $u_h(x,t) = u_j(t)$ and $v_h(x) = v_j$ are constants on $I_j$. Let $v_j=1$. The derivatives inside the integrals vanish. The equation becomes:\n$$h \\frac{du_j}{dt} + a u^*(x_{j+1/2}) - a u^*(x_{j-1/2}) = 0$$\nThe problem specifies the upwind flux. Since $a>0$, the wind blows from left to right. The numerical flux $u^*$ at an interface is the value from the left (upwind) side.\nAt interface $x_{j+1/2}$, the left state is $u_j$ and the right state is $u_{j+1}$. So, $u^*(x_{j+1/2}) = u_j$.\nAt interface $x_{j-1/2}$, the left state is $u_{j-1}$ and the right state is $u_j$. So, $u^*(x_{j-1/2}) = u_{j-1}$.\nSubstituting these fluxes into the semi-discrete equation:\n$$h \\frac{du_j}{dt} + a u_j - a u_{j-1} = 0 \\implies \\frac{du_j}{dt} = -\\frac{a}{h} (u_j - u_{j-1})$$\nThis defines the action of the operator $L$: $(L\\mathbf{u})_j = -\\frac{a}{h} (u_j - u_{j-1})$.\nTo find the eigenvalues $\\lambda$ of $L$, we use a Fourier mode ansatz for the grid function $\\mathbf{u}$, accounting for periodicity. Let $u_j(t) = \\hat{u}(t) e^{i k x_j}$ where $x_j = j h$ and $k$ is the wavenumber.\n$$\\frac{d}{dt} (\\hat{u} e^{ikjh}) = -\\frac{a}{h} (\\hat{u} e^{ikjh} - \\hat{u} e^{ik(j-1)h})$$\n$$\\frac{d\\hat{u}}{dt} e^{ikjh} = -\\frac{a}{h} \\hat{u} e^{ikjh} (1 - e^{-ikh})$$\n$$\\frac{d\\hat{u}}{dt} = \\left[-\\frac{a}{h} (1 - e^{-ikh})\\right] \\hat{u}$$\nThe eigenvalues of the operator $L$ are thus $\\lambda(k) = -\\frac{a}{h} (1 - e^{-ikh})$.\nThe periodic domain $[0, L]$ with grid size $h=L/K$ requires that the wavenumbers satisfy $kL = 2\\pi m$ for integer $m$. Thus, $k = \\frac{2\\pi m}{L} = \\frac{2\\pi m}{Kh}$.\nLet $\\theta_m = kh = \\frac{2\\pi m}{K}$ be the discrete Fourier phase, where $m = 0, 1, \\dots, K-1$. For a large number of elements $K \\to \\infty$, $\\theta$ can be treated as a continuous variable in $[0, 2\\pi]$.\nThe eigenvalues are $\\lambda(\\theta) = -\\frac{a}{h}(1 - e^{-i\\theta}) = \\frac{a}{h}(e^{-i\\theta} - 1)$.\nThe argument of the stability function $R(z)$ is $z = \\Delta t \\lambda$.\n$$z(\\theta) = \\Delta t \\lambda(\\theta) = \\frac{a \\Delta t}{h} (e^{-i\\theta} - 1) = C(e^{-i\\theta} - 1)$$\nwhere $C = a \\Delta t/h$ is the Courant number.\nThe stability condition is that for all eigenvalues $\\lambda$ of $L$, the amplification factor $|R(\\Delta t \\lambda)|$ must be no greater than $1$. In the limit $K \\to \\infty$, this becomes an extremization problem over the continuous phase $\\theta$:\n$$\\max_{\\theta \\in [0, 2\\pi]} |R(z(\\theta))| \\le 1$$\nSubstituting the expressions for $R(z)$ and $z(\\theta)$, the condition is:\n$$\\max_{\\theta \\in [0, 2\\pi]} \\left| 1 + C(e^{-i\\theta}-1) + \\frac{1}{2} C^2(e^{-i\\theta}-1)^2 + \\frac{1}{6} C^3(e^{-i\\theta}-1)^3 \\right| \\le 1$$\n\n**Part 3: Maximum Admissible Courant Number $C_{\\max}$**\n\nThe set of points $z(\\theta) = C(e^{-i\\theta} - 1)$ for $\\theta \\in [0, 2\\pi]$ traces a circle in the complex plane. Writing $z = x+iy$, we have $x = C(\\cos\\theta - 1)$ and $y = -C\\sin\\theta$. It follows that $(x+C)^2 + y^2 = C^2\\cos^2\\theta + C^2\\sin^2\\theta = C^2$. This is a circle of radius $C$ centered at $-C$.\n\nThe stability condition demands that this entire circle lies within the absolute stability region of the RK method, defined by $\\{z \\in \\mathbb{C} : |R(z)| \\le 1\\}$. The largest admissible Courant number $C_{\\max}$ is the value of $C$ for which this circle is tangent to the boundary of the stability region from within.\n\nFor many dissipative numerical schemes, the most restrictive stability constraint arises from the highest frequency mode representable on the grid. For the upwind scheme, this corresponds to $\\theta=\\pi$, where the eigenvalue has the largest negative real part. Let us assume the maximum of $|R(z(\\theta))|$ occurs at $\\theta=\\pi$.\nAt $\\theta = \\pi$, we have $e^{-i\\pi} = -1$. The corresponding value of $z$ is:\n$$z(\\pi) = C(-1-1) = -2C$$\nThis point lies on the negative real axis. The stability condition for this point is $|R(-2C)| \\leq 1$.\nThe stability function for a real negative argument $-x$ (with $x > 0$) is real:\n$$R(-x) = 1 - x + \\frac{1}{2}x^2 - \\frac{1}{6}x^3$$\nSo, we require $|R(-2C)| \\le 1$, which is equivalent to $-1 \\le R(-2C) \\le 1$. Let's check these two inequalities.\n$$R(-2C) = 1 - 2C + 2C^2 - \\frac{4}{3}C^3$$\n1. The inequality $R(-2C) \\le 1$:\n$$1 - 2C + 2C^2 - \\frac{4}{3}C^3 \\le 1 \\implies -2C + 2C^2 - \\frac{4}{3}C^3 \\le 0$$\nDividing by $-2C$ (and flipping the inequality sign as $-2C<0$):\n$$1 - C + \\frac{2}{3}C^2 \\ge 0$$\nThe discriminant of this quadratic is $D = (-1)^2 - 4(\\frac{2}{3})(1) = 1 - \\frac{8}{3} < 0$. Since the leading coefficient is positive, the quadratic is always positive. This inequality is satisfied for all $C$.\n\n2. The inequality $R(-2C) \\ge -1$:\n$$1 - 2C + 2C^2 - \\frac{4}{3}C^3 \\ge -1$$\n$$2 - 2C + 2C^2 - \\frac{4}{3}C^3 \\ge 0$$\nLet $f(C) = 2 - 2C + 2C^2 - \\frac{4}{3}C^3$. We need to find the largest $C$ that satisfies $f(C) \\ge 0$. Let's examine the derivative:\n$$f'(C) = -2 + 4C - 4C^2 = -2(1 - 2C + 2C^2)$$\nThe discriminant of the quadratic $1 - 2C + 2C^2$ is $D = (-2)^2 - 4(2)(1) = 4 - 8 = -4 < 0$. Since the leading coefficient is positive, the quadratic is always positive. Therefore, $f'(C)$ is always negative, and $f(C)$ is a strictly decreasing function for all $C$.\nThe maximum allowed value of $C$, denoted $C_{\\max}$, will be the root of the equation $f(C) = 0$.\n$$2 - 2C_{\\max} + 2C_{\\max}^2 - \\frac{4}{3}C_{\\max}^3 = 0$$\nMultiplying by $-\\frac{3}{2}$ to simplify:\n$$2C_{\\max}^3 - 3C_{\\max}^2 + 3C_{\\max} - 3 = 0$$\nThis is a cubic equation for $C_{\\max}$. We must solve it numerically. Let $g(C) = 2C^3 - 3C^2 + 3C - 3$.\n$g(1) = 2-3+3-3 = -1$.\n$g(1.5) = 2(3.375) - 3(2.25) + 3(1.5) - 3 = 6.75 - 6.75 + 4.5 - 3 = 1.5$.\nThe root lies between $1$ and $1.5$. Using a numerical solver (e.g., Newton's method):\nLet's start with an initial guess $C_0 = 1.2$.\n$g(1.2) = 2(1.728) - 3(1.44) + 3(1.2) - 3 = 3.456 - 4.32 + 3.6 - 3 = -0.264$.\n$g'(C) = 6C^2 - 6C + 3$.\n$g'(1.2) = 6(1.44) - 6(1.2) + 3 = 8.64 - 7.2 + 3 = 4.44$.\n$C_1 = C_0 - \\frac{g(C_0)}{g'(C_0)} = 1.2 - \\frac{-0.264}{4.44} \\approx 1.2 + 0.059459 = 1.259459$.\nFurther iteration gives a more accurate value for the root:\n$C_{\\max} \\approx 1.2564115$.\nRounding the answer to four significant figures, we get $C_{\\max} = 1.256$.", "answer": "$$\\boxed{1.256}$$", "id": "3397065"}, {"introduction": "Building on the theoretical groundwork, this exercise transitions to a computational setting to compare the practical performance of different schemes. You will implement a high-order Discontinuous Galerkin method and use its numerically computed eigenvalue spectrum to find the stability-limited timestep for both the classical fourth-order Runge-Kutta method and a widely used five-stage, fourth-order low-storage variant. This practice provides direct, hands-on experience with the trade-offs in stability properties that motivate the use of specialized LSRK methods.", "problem": "Consider the one-dimensional linear advection initial value problem on the periodic domain $[0,1]$ with advection speed $a = 1$, given by $u_t + a u_x = 0$. Discretize the spatial domain using a high-order discontinuous Galerkin (DG) method with a uniform partition into $N$ elements of size $h = 1/N$, and on each element use a nodal basis at the Legendre–Gauss–Lobatto points of polynomial degree $p$ (so that there are $p+1$ nodes per element). Use the upwind numerical flux consistent with $a = 1$.\n\nThe semi-discrete DG operator can be written in the strong form using the Summation-By-Parts property, where the derivative matrix $D$ and quadrature weight matrix $W$ on the reference element satisfy $Q = W D$ and $Q + Q^\\top = B$, with $B$ diagonal selecting the boundary nodes. In this formulation, the semi-discrete system is of the form $\\mathbf{u}_t = L \\mathbf{u}$, where $L$ is the global DG matrix assembled from element-wise volume terms and face coupling terms due to the upwind flux and periodic boundary conditions. For explicit time stepping, stability of a one-step method applied to the semi-discrete system $\\mathbf{u}_t = L \\mathbf{u}$ is governed by the absolute stability function $R(z)$ evaluated at $z = \\Delta t \\lambda$, where $\\lambda$ ranges over the eigenvalues of $L$. Stability requires $\\max_{\\lambda \\in \\Lambda(L)} |R(\\Delta t \\lambda)| \\le 1$. It is well-established in high-order DG analysis that the spectral radius of the advection operator scales as $\\mathcal{O}(p^2/h)$ due to inverse inequalities and trace estimates, motivating a Courant–Friedrichs–Lewy (CFL) condition of the form $\\Delta t \\le C/(p^2 h)$ for explicit Runge–Kutta-type methods.\n\nYour task is to implement and compare the stability-limited time step coefficient $C$ when switching from the classical fourth-order Runge–Kutta method (RK4) to a two-register low-storage Runge–Kutta method of five stages and fourth order (commonly referred to as a Carpenter–Kennedy 2N-storage low-storage scheme). The classical fourth-order Runge–Kutta method has a known stability function, and the low-storage method can be represented by a stage-recursive update using two registers and constant coefficients. In all cases, the temporal stability must be verified against the full complex spectrum of the assembled DG operator for the given $p$ and $N$.\n\nBase your derivation on the following fundamental facts:\n- The semi-discrete DG formulation for linear advection with upwind flux and periodic boundary conditions yields a linear system $\\mathbf{u}_t = L \\mathbf{u}$ with eigenvalues scaling in magnitude as $\\mathcal{O}(p^2/h)$.\n- For explicit Runge–Kutta methods applied to $\\mathbf{u}_t = L \\mathbf{u}$, stability is determined by the magnitude of the stability function $R(z)$ on the set $z = \\Delta t \\lambda$, where $\\lambda$ are the eigenvalues of $L$.\n\nFrom these bases, derive an algorithm to compute, for fixed $p$ and $N$, the largest $\\Delta t$ such that the method remains stable, and report the corresponding $C$ via $C = \\Delta t \\, p^2 / h$. Implement $L$ by assembling:\n- The reference-element Legendre–Gauss–Lobatto nodes and weights of degree $p$.\n- The nodal differentiation matrix $D$ on the reference element constructed via barycentric weights.\n- The global strong-form DG advection operator $L$ with upwind flux and periodic boundary conditions over $N$ elements.\n\nThen, for each Runge–Kutta scheme:\n- Compute the eigenvalues of $L$.\n- Determine the maximal stable $\\Delta t$ via a monotone bisection on $\\Delta t$ checking $\\max_{\\lambda} |R(\\Delta t \\lambda)| \\le 1$ at each step.\n- Compute $C = \\Delta t \\, p^2 / h$.\n\nAngle measurements are not required, and no physical units are needed; all quantities are nondimensional.\n\nTest Suite:\n- Use $N = 16$ elements, advection speed $a = 1$, and periodic boundary conditions.\n- Evaluate the schemes for $p \\in \\{2,4,8\\}$.\n- Schemes:\n  1. Classical fourth-order Runge–Kutta (denote by the code string \"RK4\").\n  2. Two-register low-storage five-stage fourth-order Runge–Kutta (denote by the code string \"LSRK54\").\n\nRequired final output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must be ordered as $[C_{\\mathrm{RK4}}(p{=}2), C_{\\mathrm{LSRK54}}(p{=}2), C_{\\mathrm{RK4}}(p{=}4), C_{\\mathrm{LSRK54}}(p{=}4), C_{\\mathrm{RK4}}(p{=}8), C_{\\mathrm{LSRK54}}(p{=}8)]$.", "solution": "The user has provided a scientifically valid and well-posed problem. The task is to compute the stability-limited Courant–Friedrichs–Lewy (CFL) coefficient, denoted as $C$, for a high-order discontinuous Galerkin (DG) discretization of the one-dimensional linear advection equation. This analysis will be performed for two different explicit Runge-Kutta time-stepping schemes.\n\nThe problem is governed by the initial value problem:\n$$ u_t + a u_x = 0, \\quad x \\in [0,1], \\quad t > 0 $$\nwith advection speed $a=1$ and periodic boundary conditions.\n\nThe solution proceeds in several steps:\n1.  **Construct the Semi-Discrete DG Operator**: The spatial domain is discretized into $N$ elements, and a nodal polynomial basis of degree $p$ on the Legendre-Gauss-Lobatto (LGL) points is used within each element. The semi-discrete system is a system of ordinary differential equations of the form $\\frac{d\\vec{U}}{dt} = L\\vec{U}$, where $\\vec{U}$ is the global vector of nodal values and $L$ is the global DG operator. The matrix $L$ is constructed by assembling local operators from each element, incorporating both the volume derivative and the inter-element flux contributions. For this problem, an upwind flux is used.\n\n2.  **Derive the DG Operator Matrix ($L$)**: The global operator $L$ is an $N(p+1) \\times N(p+1)$ matrix.\n    -   **LGL Nodes and Weights**: For a polynomial degree $p$, we require the $p+1$ LGL nodes $\\xi_j$ and quadrature weights $w_j$ on the reference element $[-1,1]$. The nodes are the roots of $(1-x^2)P_p'(x)$, where $P_p(x)$ is the Legendre polynomial of degree $p$.\n    -   **Differentiation Matrix ($D$)**: A differentiation matrix $D$ on the reference element is constructed such that for a vector of nodal values $\\vec{v}$, $D\\vec{v}$ approximates the derivative at the nodes.\n    -   **Strong Form Operator**: The strong form of the DG operator applied to the solution $\\vec{u}_k$ on element $k$ (of size $h=1/N$) is composed of a volume term and a surface flux correction term. The time evolution of the nodal values $\\vec{u}_k$ on element $k$ is given by:\n        $$ \\frac{d\\vec{u}_k}{dt} = -\\frac{2a}{h} D \\vec{u}_k + \\text{FluxCorrection}(\\vec{u}_k, \\vec{u}_{neighbors}) $$\n    -   **Upwind Flux**: For $a=1>0$, the upwind flux at an interface is the value from the element to the left. At the right boundary of element $k$ (interface $k+1/2$), the numerical flux equals the interior trace $u_{k,p}$, so the correction is zero. At the left boundary (interface $k-1/2$), the numerical flux is the exterior trace $u_{k-1,p}$. The flux correction term affects only the first node of the element, $u_{k,0}$. This correction to $\\frac{du_{k,0}}{dt}$ is given by:\n        $$ M_0^{-1} a ( u_{k,0} - u_{k-1,p} ) = \\frac{a}{w_0 h/2} ( u_{k,0} - u_{k-1,p} ) = \\frac{2a}{h w_0} ( u_{k,0} - u_{k-1,p} ) $$\n        This term is added to the right-hand side.\n    -   **Assembling L**: The global matrix $L$ is assembled by distributing these local contributions. For each element $k$, a block corresponding to $-\\frac{2a}{h}D$ is placed on the diagonal. Then, the flux correction term adds a value of $\\frac{2a}{h w_0}$ to the matrix entry mapping $u_{k,0}$ to $\\dot{u}_{k,0}$ and a value of $-\\frac{2a}{h w_0}$ to the entry mapping $u_{k-1,p}$ to $\\dot{u}_{k,0}$. Periodic boundary conditions dictate that the \"previous\" element for $k=0$ is $k=N-1$.\n\n3.  **Analyze Temporal Stability**: The stability of an explicit Runge-Kutta method applied to $\\frac{d\\vec{U}}{dt} = L\\vec{U}$ is determined by its stability function $R(z)$. The method is stable if and only if $|R(\\Delta t \\lambda)| \\le 1$ for all eigenvalues $\\lambda$ of $L$.\n    -   **Eigenvalues of L**: The eigenvalues $\\lambda$ are computed numerically.\n    -   **Stability Functions**:\n        -   For the classical fourth-order Runge-Kutta method (RK4), the stability polynomial is the Taylor expansion of $e^z$ up to degree $4$:\n            $$ R_{\\mathrm{RK4}}(z) = 1 + z + \\frac{z^2}{2!} + \\frac{z^3}{3!} + \\frac{z^4}{4!} $$\n        -   For the specified five-stage, fourth-order, two-register low-storage Runge-Kutta scheme (LSRK54), the stability polynomial is constructed from its recurrence relations. The scheme can be written as:\n            $$ d_0 = 0, \\quad q_0 = U_n $$\n            $$ d_i = A_i d_{i-1} + \\Delta t f(q_{i-1}), \\quad q_i = q_{i-1} + B_i d_i \\quad \\text{for } i=1,\\dots,5 $$\n            $$ U_{n+1} = q_5 $$\n            Applying this to the test equation $u'=\\lambda u$ (so $f(u)=\\lambda u$), with $z = \\Delta t \\lambda$, allows one to recursively construct the stability polynomial $R_{\\mathrm{LSRK54}}(z) = q_5/q_0$.\n\n4.  **Compute Maximum Stable Time Step and C**: For each scheme, we must find the largest $\\Delta t$ that maintains stability. This is equivalent to finding the maximum $\\Delta t$ such that the scaled spectrum $\\Delta t \\Lambda(L)$ remains within the stability region $\\{z \\in \\mathbb{C} : |R(z)| \\le 1\\}$.\n    -   A bisection search is performed on $\\Delta t$. For a given $\\Delta t$, stability is checked by evaluating $|R(z)|$ for all $z \\in \\Delta t \\Lambda(L)$ and ensuring the maximum magnitude does not exceed $1$.\n    -   Once the maximum stable time step, $\\Delta t_{\\mathrm{max}}$, is found, the stability-limited coefficient $C$ is calculated using the problem-defined scaling relation:\n        $$ C = \\Delta t_{\\mathrm{max}} \\cdot p^2 \\cdot h^{-1} = \\Delta t_{\\mathrm{max}} \\cdot p^2 \\cdot N $$\n\nThe implementation will carry out these steps for the specified parameters ($N=16$, $a=1$) and polynomial degrees ($p \\in \\{2,4,8\\}$), reporting the coefficient $C$ for each case.", "answer": "```python\nimport numpy as np\nimport scipy.special\n\ndef solve():\n    \"\"\"\n    Computes the stability-limited CFL coefficient C for a DG discretization of\n    the linear advection equation using RK4 and LSRK54 time-stepping schemes.\n    \"\"\"\n\n    def leg_gauss_lobatto(p):\n        \"\"\"\n        Computes the Legendre-Gauss-Lobatto nodes and weights on [-1, 1].\n\n        Args:\n            p (int): Polynomial degree.\n\n        Returns:\n            tuple: A tuple containing:\n                - np.ndarray: LGL nodes.\n                - np.ndarray: LGL weights.\n        \"\"\"\n        if p == 0:\n            return np.array([0.0]), np.array([2.0])\n        if p == 1:\n            return np.array([-1.0, 1.0]), np.array([1.0, 1.0])\n        \n        # Nodes are -1, 1, and the roots of P_p'(x).\n        # Roots of P_p'(x) are roots of the Jacobi polynomial P_{p-1}^{(1,1)}(x).\n        roots_jacobi, _ = scipy.special.roots_jacobi(p - 1, 1, 1)\n        nodes = np.concatenate(([-1.0], np.sort(roots_jacobi), [1.0]))\n        \n        # Weights are given by w_i = 2 / (p*(p+1) * [P_p(x_i)]^2).\n        P_p_at_nodes = scipy.special.eval_legendre(p, nodes)\n        weights = 2.0 / (p * (p + 1) * P_p_at_nodes**2)\n        \n        return nodes, weights\n\n    def diff_matrix(p, nodes):\n        \"\"\"\n        Computes the 1D nodal differentiation matrix on LGL nodes.\n\n        Args:\n            p (int): Polynomial degree.\n            nodes (np.ndarray): LGL nodes.\n\n        Returns:\n            np.ndarray: The (p+1)x(p+1) differentiation matrix.\n        \"\"\"\n        n_pts = p + 1\n        D = np.zeros((n_pts, n_pts))\n        P_p_at_nodes = scipy.special.eval_legendre(p, nodes)\n        \n        for i in range(n_pts):\n            for j in range(n_pts):\n                if i != j:\n                    D[i, j] = P_p_at_nodes[i] / (P_p_at_nodes[j] * (nodes[i] - nodes[j]))\n        \n        D[0, 0] = -p * (p + 1) / 4.0\n        D[p, p] = p * (p + 1) / 4.0\n        # For i=1..p-1, D[i,i] = 0, which is the default from np.zeros.\n        \n        return D\n\n    def build_L_matrix(p, N, a, D, weights):\n        \"\"\"\n        Builds the global strong-form DG operator matrix L.\n\n        Args:\n            p (int): Polynomial degree.\n            N (int): Number of elements.\n            a (float): Advection speed.\n            D (np.ndarray): Reference element differentiation matrix.\n            weights (np.ndarray): LGL quadrature weights.\n\n        Returns:\n            np.ndarray: The global DG operator matrix.\n        \"\"\"\n        n_pts = p + 1\n        total_dofs = N * n_pts\n        L = np.zeros((total_dofs, total_dofs), dtype=np.float64)\n        h = 1.0 / N\n        w0 = weights[0]\n        \n        flux_coeff = 2.0 * a / (h * w0)\n\n        for k in range(N):\n            start_idx = k * n_pts\n            end_idx = start_idx + n_pts\n            \n            # Volume term (block diagonal part)\n            L[start_idx:end_idx, start_idx:end_idx] = - (2.0 * a / h) * D\n            \n            # Surface flux correction term (upwind for a>0)\n            # This adds to the row for u_{k,0} from u_{k,0} and u_{k-1,p}.\n            row_idx = start_idx\n            \n            # Contribution from u_{k,0}\n            L[row_idx, row_idx] += flux_coeff\n            \n            # Contribution from u_{k-1, p} (periodic boundary)\n            prev_k = (k - 1 + N) % N\n            col_idx = prev_k * n_pts + p\n            L[row_idx, col_idx] -= flux_coeff\n            \n        return L\n\n    def get_stability_poly(scheme):\n        \"\"\"\n        Returns the stability polynomial for a given RK scheme.\n        \n        Args:\n            scheme (str): The scheme identifier (\"RK4\" or \"LSRK54\").\n\n        Returns:\n            np.poly1d: The stability polynomial.\n        \"\"\"\n        if scheme == \"RK4\":\n            # R(z) = 1 + z + z^2/2! + z^3/3! + z^4/4!\n            coeffs = [1/24.0, 1/6.0, 1/2.0, 1.0, 1.0]\n            return np.poly1d(coeffs)\n        elif scheme == \"LSRK54\":\n            # 2-register, 5-stage, 4th-order scheme (Carpenter-Kennedy)\n            # Recurrence: d_i = A_i*d_{i-1} + dt*f(q_{i-1}), q_i = q_{i-1} + B_i*d_i\n            B = np.array([0.118888066885314, 0.281111933114686, 0.5, 0.6, 1.0])\n            A = np.array([0.0, 0.0, -0.0911516952733231, -1.0911516952733231, -1.2])\n\n            z = np.poly1d([1, 0])\n            q_poly = np.poly1d([1.0])\n            d_poly = np.poly1d([0.0])\n\n            for i in range(5):\n                d_poly_new = A[i] * d_poly + q_poly\n                q_poly = q_poly + B[i] * z * d_poly_new\n                d_poly = d_poly_new\n            return q_poly\n        else:\n            raise ValueError(f\"Unknown scheme: {scheme}\")\n\n    def find_max_dt(eigs, stability_poly):\n        \"\"\"\n        Finds the maximum stable time step using bisection.\n\n        Args:\n            eigs (np.ndarray): Eigenvalues of the DG operator.\n            stability_poly (np.poly1d): The stability polynomial.\n\n        Returns:\n            float: The maximum stable time step.\n        \"\"\"\n        def is_stable(dt):\n            if dt <= 1e-12: return True\n            z = dt * eigs\n            R_z = stability_poly(z)\n            return np.max(np.abs(R_z)) <= 1.000000001 # Numerical tolerance\n\n        max_eig_mag = np.max(np.abs(eigs))\n        if max_eig_mag < 1e-9: return np.inf\n        \n        dt_low = 0.0\n        dt_high = 10.0 / max_eig_mag\n        \n        for _ in range(100):\n            dt_mid = (dt_low + dt_high) / 2.0\n            if is_stable(dt_mid):\n                dt_low = dt_mid\n            else:\n                dt_high = dt_mid\n        \n        return dt_low\n\n    # Problem parameters\n    N = 16\n    a = 1.0\n    p_values = [2, 4, 8]\n    schemes = [\"RK4\", \"LSRK54\"]\n    \n    results = []\n\n    for p in p_values:\n        nodes, weights = leg_gauss_lobatto(p)\n        D = diff_matrix(p, nodes)\n        L = build_L_matrix(p, N, a, D, weights)\n        \n        eigenvalues = np.linalg.eigvals(L)\n        \n        for scheme_name in schemes:\n            poly = get_stability_poly(scheme_name)\n            dt_max = find_max_dt(eigenvalues, poly)\n            h = 1.0 / N\n            C = dt_max * p**2 / h\n            results.append(f\"{C:.6f}\")\n    \n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3397159"}, {"introduction": "Our final practice addresses a subtle but critical implementation detail that arises in high-performance computing: ensuring conservation with local time-stepping. You will investigate how a naive implementation of an LSRK scheme can fail to conserve mass and then implement a memory-aware modification to restore this essential property. This exercise highlights the importance of careful algorithm design when optimizing codes and demonstrates how the structure of LSRK methods can be adapted to preserve fundamental physical principles.", "problem": "Consider the one-dimensional scalar advection equation $u_t + a u_x = 0$ with constant speed $a > 0$ on a periodic domain partitioned into $N$ elements. Use the Discontinuous Galerkin (DG) method with piecewise constant basis functions (polynomial degree $p = 0$). In this setting, the semi-discrete evolution of the element-average values $u_e(t)$ is driven solely by interface fluxes. Let elements be indexed cyclically as $e \\in \\{0,1,\\dots,N-1\\}$, with interface $i$ between element $e=i$ and $f=(i+1) \\bmod N$. With upwind flux for $a>0$, the numerical flux at interface $i$ is $\\phi_i = a u_e$, and the semi-discrete residual per element $e$ is\n$$\nL_e(u) = \\phi_{e-1} - \\phi_e = a u_{e-1} - a u_e,\n$$\nwith index arithmetic modulo $N$ and periodic boundary conditions.\n\nAdvance the solution in time with a Low Storage Runge-Kutta (LSRK) method having $S$ stages and coefficients $\\{\\alpha_s\\}_{s=1}^S$ and $\\{\\beta_s\\}_{s=1}^S$, implemented in the two-register form\n$$\nr^{(s)} = \\alpha_s r^{(s-1)} + L\\!\\left(w^{(s-1)}\\right), \\quad\nw^{(s)} = w^{(s-1)} + \\beta_s \\, \\gamma_s \\, \\Delta t_e \\, r^{(s)} \\quad \\text{elementwise},\n$$\nwhere $w^{(0)} = u^n$ is the initial field at the start of the time step, $r^{(0)} = 0$ is the residual buffer, $\\Delta t_e$ is the local time step at element $e$, and $\\gamma_s$ is a stage-dependent scaling factor. This implementation reuses a single residual buffer $r$ and applies local time step scaling elementwise at the update. Note that $L(w)$ depends on $w$ through the interface fluxes.\n\nThe total discrete mass is defined as\n$$\nM(t) = \\sum_{e=0}^{N-1} u_e(t).\n$$\nUnder periodic boundary conditions and exact pairwise cancellation of internal interface fluxes, the semi-discrete method is conservative, meaning $dM/dt = 0$. However, when $\\Delta t_e$ varies with $e$ and $\\gamma_s$ varies with $s$, the above LSRK update can destroy discrete conservation because equal-and-opposite interface contributions are scaled by different factors on neighboring elements.\n\nYour tasks are:\n1. Implement the described naive LSRK update that reuses a single residual buffer and applies local time step rescaling elementwise at each stage.\n2. Propose and implement a memory-aware modification that preserves discrete conservation across interfaces under elementwise local time steps and stage-wise scaling. The modification should use an additional buffer to accumulate interface contributions per interface and apply a common pairwise scaling at each interface so that the contributions to the two adjacent elements are equal and opposite at every stage. Specifically, maintain a per-interface buffer $s_i$ updated by\n$$\ns_i^{(s)} = \\alpha_s s_i^{(s-1)} + \\phi_i\\!\\left(w^{(s-1)}\\right),\n$$\nand update adjacent elements $e$ and $f$ using a common pairwise scaling $\\widehat{\\Delta t}_i$ (for example, $\\widehat{\\Delta t}_i = \\min(\\Delta t_e,\\Delta t_f)$) to ensure exact cancellation:\n$$\nw_e^{(s)} \\gets w_e^{(s)} - \\beta_s \\, \\gamma_s \\, \\widehat{\\Delta t}_i \\, s_i^{(s)}, \\quad\nw_f^{(s)} \\gets w_f^{(s)} + \\beta_s \\, \\gamma_s \\, \\widehat{\\Delta t}_i \\, s_i^{(s)}.\n$$\n\nUsing the Carpenter–Kennedy Low Storage Runge-Kutta (LSRK) five-stage, fourth-order coefficients\n$$\n\\alpha = \\left[\n0,\\,\n-\\frac{567301805773}{1357537059087},\\,\n-\\frac{2404267990393}{2016746695238},\\,\n-\\frac{3550918686646}{2091501179385},\\,\n-\\frac{1275806237668}{842570457699}\n\\right],\n$$\n$$\n\\beta = \\left[\n\\frac{1432997174477}{9575080441755},\\,\n\\frac{5161836677717}{13612068292357},\\,\n\\frac{1720146321549}{2090206949498},\\,\n\\frac{3134564353537}{4481467310338},\\,\n\\frac{2277821191437}{14882151754819}\n\\right],\n$$\nand stage-wise scaling\n$$\n\\gamma = [1.0,\\, 0.9,\\, 1.1,\\, 0.95,\\, 1.05],\n$$\nwrite a program that, for each test case below, performs one composite time step (all $S$ stages) with both the naive and the modified scheme, and then computes the discrete mass change $\\Delta M = M^{n+1} - M^n$ for each scheme.\n\nTest suite:\n- Case 1 (uniform local time step): $N=4$, $a=1.0$, $u^n = [1.0, 2.0, 3.0, 4.0]$, $\\Delta t = [0.1, 0.1, 0.1, 0.1]$.\n- Case 2 (nonuniform local time steps): $N=4$, $a=1.0$, $u^n = [1.0, 2.0, 3.0, 4.0]$, $\\Delta t = [0.10, 0.05, 0.20, 0.15]$.\n- Case 3 (single element, periodic): $N=1$, $a=1.0$, $u^n = [1.23]$, $\\Delta t = [0.1]$.\n- Case 4 (many elements, deterministic variability): $N=20$, $a=1.0$, $u^n$ given by $u_e^n = \\sin\\!\\left(2\\pi e/N\\right) + 0.5\\, e/N$ for $e=0,\\dots,19$, and $\\Delta t_e = 0.05 + 0.01\\left( (e \\bmod 5) \\right)$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with one pair per test case in order. Each pair is a two-element list of floats $[\\Delta M_{\\text{naive}}, \\Delta M_{\\text{modified}}]$. For example, the output should look like\n$$\n[\\,[\\Delta M_{1,\\text{naive}},\\Delta M_{1,\\text{modified}}],\\,[\\Delta M_{2,\\text{naive}},\\Delta M_{2,\\text{modified}}],\\,[\\Delta M_{3,\\text{naive}},\\Delta M_{3,\\text{modified}}],\\,[\\Delta M_{4,\\text{naive}},\\Delta M_{4,\\text{modified}}]\\,].\n$$\nAll answers are dimensionless real numbers; no physical units are required. Ensure the single-line output matches exactly this specification.", "solution": "The problem is assessed to be valid as it represents a well-posed, scientifically grounded question in the field of numerical analysis for partial differential equations. All parameters, equations, and initial conditions are clearly defined, enabling a unique and verifiable solution.\n\nThe core of the problem lies in the numerical time integration of a semi-discretized advection equation, $u_t + a u_x = 0$, using a Low Storage Runge-Kutta (LSRK) method. The spatial discretization is performed with a Discontinuous Galerkin (DG) method using piecewise constant basis functions ($p=0$) on a periodic domain of $N$ elements.\n\n### Semi-Discrete Formulation\nFor a DG($p=0$) scheme, the solution within each element $e$ is represented by its average value, $u_e$. The semi-discrete form of the advection equation, which governs the time evolution of these averages, is given by\n$$\n\\frac{du_e}{dt} = L_e(u)\n$$\nwhere $L_e(u)$ is the residual for element $e$. This residual aggregates the net effect of fluxes across the element's boundaries. The problem defines the upwind flux at interface $i$ (between element $e=i$ and $f=(i+1) \\bmod N$) for a positive advection speed $a>0$ as $\\phi_i = a u_i$. The residual for element $e$ is then the difference between the incoming flux from interface $e-1$ and the outgoing flux at interface $e$:\n$$\nL_e(u) = \\phi_{e-1} - \\phi_e = a u_{e-1} - a u_e\n$$\nHere, indices are taken modulo $N$ to enforce periodic boundary conditions. The total discrete mass is defined as $M(t) = \\sum_{e=0}^{N-1} u_e(t)$. The semi-discrete system is conservative because the sum of all residuals is a telescoping sum that cancels to zero under periodic conditions:\n$$\n\\frac{dM}{dt} = \\sum_{e=0}^{N-1} \\frac{du_e}{dt} = \\sum_{e=0}^{N-1} L_e(u) = \\sum_{e=0}^{N-1} (a u_{e-1} - a u_e) = a \\left( \\sum_{e=0}^{N-1} u_{e-1} - \\sum_{e=0}^{N-1} u_e \\right) = 0\n$$\n\n### Naive LSRK Implementation (Non-Conservative)\nThe specified LSRK scheme uses a two-register form to advance the solution from time level $n$ to $n+1$. The two registers are the solution buffer $w$ and the residual buffer $r$. The update for a single time step, involving $S$ stages, is given by:\n$$\nr^{(s)} = \\alpha_s r^{(s-1)} + L\\!\\left(w^{(s-1)}\\right) \\\\\nw^{(s)} = w^{(s-1)} + \\beta_s \\, \\gamma_s \\, \\Delta t_e \\, r^{(s)}\n$$\nwith initial conditions $w^{(0)} = u^n$ and $r^{(0)} = 0$. The crucial part is the elementwise update of the solution $w^{(s)}$, where the residual $r^{(s)}$ for element $e$ is scaled by its local time step $\\Delta t_e$.\n\nThis scheme fails to preserve discrete mass when local time steps $\\Delta t_e$ are not uniform. The total change in mass over a full time step is $\\Delta M = \\sum_e (w^{(S)}_e - w^{(0)}_e) = \\sum_e \\sum_{s=1}^S \\beta_s \\gamma_s \\Delta t_e r_e^{(s)}$. The sum $\\sum_e r_e^{(s)}$ is zero at every stage, but the weighted sum $\\sum_e \\Delta t_e r_e^{(s)}$ is not, because the non-uniform $\\Delta t_e$ breaks the cancellation. For stage $s=1$, for instance, $\\sum_e \\Delta t_e r_e^{(1)} = \\sum_e \\Delta t_e L_e(u^n) = a \\sum_e \\Delta t_e (u^n_{e-1} - u^n_e) \\neq 0$ if $\\Delta t_e$ is not constant. This introduces a non-zero mass change at the first stage, which propagates through the remaining stages.\n\n### Modified LSRK Implementation (Conservative)\nTo restore conservation, the update mechanism must ensure that the contributions from any given interface to its two neighboring elements are equal and opposite at every stage. The proposed modification achieves this by introducing a per-interface residual buffer, $s_i$.\nThe update for the interface buffer is:\n$$\ns_i^{(s)} = \\alpha_s s_i^{(s-1)} + \\phi_i\\!\\left(w^{(s-1)}\\right)\n$$\nwhere $\\phi_i(w^{(s-1)}) = a w_i^{(s-1)}$ is the flux at interface $i$. The solution update for element $e$ is then constructed from the contributions of its adjacent interfaces, $e-1$ and $e$. The key is to use a common, shared time-step scaling $\\widehat{\\Delta t}_i$ for the flux at interface $i$, defined as $\\widehat{\\Delta t}_i = \\min(\\Delta t_i, \\Delta t_{(i+1)\\bmod N})$.\n\nThe update for an element $e$ at stage $s$ is the sum of an inflow from interface $e-1$ and an outflow to interface $e$:\n$$\n\\Delta w_e^{(s)} = \\underbrace{+\\beta_s \\gamma_s \\widehat{\\Delta t}_{e-1} s_{e-1}^{(s)}}_{\\text{inflow from interface } e-1} \\quad \\underbrace{-\\beta_s \\gamma_s \\widehat{\\Delta t}_{e} s_{e}^{(s)}}_{\\text{outflow to interface } e}\n$$\nThe total update is $w_e^{(s)} = w_e^{(s-1)} + \\Delta w_e^{(s)}$. Summing these updates over all elements $e$ yields a telescoping sum that evaluates to zero:\n$$\n\\sum_{e=0}^{N-1} \\Delta w_e^{(s)} = \\sum_{e=0}^{N-1} \\beta_s \\gamma_s \\left( \\widehat{\\Delta t}_{e-1} s_{e-1}^{(s)} - \\widehat{\\Delta t}_e s_e^{(s)} \\right) = 0\n$$\nThis guarantees that the total discrete mass is conserved at every stage of the time integration, regardless of the non-uniformity of $\\Delta t_e$ or the stage-dependent scaling $\\gamma_s$.\n\n### Implementation\nThe provided five-stage, fourth-order Carpenter-Kennedy LSRK coefficients $\\{\\alpha_s\\}_{s=1}^5$, $\\{\\beta_s\\}_{s=1}^5$ and stage-wise scaling factors $\\{\\gamma_s\\}_{s=1}^5$ are used. For each test case, we compute one full time step (all 5 stages) for both the naive and modified schemes and calculate the change in total discrete mass, $\\Delta M = M^{n+1} - M^n$.\n\n- **Naive Scheme Algorithm**: For each stage $s=1,\\dots,5$:\n    1. Compute the element residual vector $L$ from the current solution $w^{(s-1)}$.\n    2. Update the element residual buffer: $r \\leftarrow \\alpha_s r + L$.\n    3. Update the solution vector: $w \\leftarrow w + (\\beta_s \\gamma_s) \\cdot (\\Delta t \\odot r)$, where $\\odot$ is the elementwise product.\n- **Modified Scheme Algorithm**: For each stage $s=1,\\dots,5$:\n    1. Compute the interface flux vector $\\phi$ from the current solution $w^{(s-1)}$.\n    2. Update the interface residual buffer: $s_{intf} \\leftarrow \\alpha_s s_{intf} + \\phi$.\n    3. Compute the per-interface update term: $U_{intf} = (\\beta_s \\gamma_s) \\cdot (\\widehat{\\Delta t} \\odot s_{intf})$.\n    4. Update the solution vector via flux differencing: $w \\leftarrow w + (\\text{roll}(U_{intf}, 1) - U_{intf})$.\n\nThe results from the test cases will demonstrate that for uniform $\\Delta t$, both schemes are conservative (up to machine precision). However, for non-uniform $\\Delta t$, only the modified scheme preserves discrete mass.", "answer": "```python\nimport numpy as np\n\ndef run_case(N, a, u_initial, dt_local):\n    \"\"\"\n    Runs a single test case for both the naive and modified LSRK schemes.\n\n    Args:\n        N (int): Number of elements.\n        a (float): Advection speed.\n        u_initial (np.ndarray): Initial solution vector.\n        dt_local (np.ndarray): Vector of local time steps for each element.\n\n    Returns:\n        list: A list containing two floats: [delta_mass_naive, delta_mass_modified].\n    \"\"\"\n\n    alpha_coeffs = np.array([\n        0.0,\n        -567301805773.0 / 1357537059087.0,\n        -2404267990393.0 / 2016746695238.0,\n        -3550918686646.0 / 2091501179385.0,\n        -1275806237668.0 / 842570457699.0\n    ])\n\n    beta_coeffs = np.array([\n        1432997174477.0 / 9575080441755.0,\n        5161836677717.0 / 13612068292357.0,\n        1720146321549.0 / 2090206949498.0,\n        3134564353537.0 / 4481467310338.0,\n        2277821191437.0 / 14882151754819.0\n    ])\n    \n    gamma_coeffs = np.array([1.0, 0.9, 1.1, 0.95, 1.05])\n    \n    num_stages = 5\n    m_initial = np.sum(u_initial)\n\n    # --- Naive Scheme Implementation ---\n    w_naive = np.copy(u_initial)\n    r_naive = np.zeros(N, dtype=float)\n\n    for s in range(num_stages):\n        # Calculate residual L(w) = a * (u_{e-1} - u_e)\n        L = a * (np.roll(w_naive, 1) - w_naive)\n        \n        # Update residual buffer r\n        r_naive = alpha_coeffs[s] * r_naive + L\n        \n        # Update solution w\n        w_naive += beta_coeffs[s] * gamma_coeffs[s] * dt_local * r_naive\n\n    m_final_naive = np.sum(w_naive)\n    delta_m_naive = m_final_naive - m_initial\n\n    # --- Modified Scheme Implementation ---\n    w_mod = np.copy(u_initial)\n    s_interface = np.zeros(N, dtype=float)\n    \n    # Pairwise time step scaling at interfaces\n    # Interface i is between element i and (i+1)%N\n    dt_hat = np.minimum(dt_local, np.roll(dt_local, -1))\n\n    for s in range(num_stages):\n        # Calculate flux vector phi_i = a * w_i\n        phi = a * w_mod\n        \n        # Update interface residual buffer s\n        s_interface = alpha_coeffs[s] * s_interface + phi\n        \n        # Calculate update term for each interface\n        update_term = beta_coeffs[s] * gamma_coeffs[s] * dt_hat * s_interface\n        \n        # Apply conservative updates to elements\n        # Element e gets inflow from interface e-1 and outflow to interface e\n        delta_w = np.roll(update_term, 1) - update_term\n        w_mod += delta_w\n\n    m_final_mod = np.sum(w_mod)\n    delta_m_mod = m_final_mod - m_initial\n\n    return [delta_m_naive, delta_m_mod]\n\n\ndef solve():\n    \"\"\"\n    Sets up test cases, runs simulations, and prints the formatted results.\n    \"\"\"\n    # Test Case 1\n    case1 = {\n        \"N\": 4, \"a\": 1.0, \n        \"u_initial\": np.array([1.0, 2.0, 3.0, 4.0]),\n        \"dt_local\": np.array([0.1, 0.1, 0.1, 0.1])\n    }\n\n    # Test Case 2\n    case2 = {\n        \"N\": 4, \"a\": 1.0,\n        \"u_initial\": np.array([1.0, 2.0, 3.0, 4.0]),\n        \"dt_local\": np.array([0.10, 0.05, 0.20, 0.15])\n    }\n\n    # Test Case 3\n    case3 = {\n        \"N\": 1, \"a\": 1.0,\n        \"u_initial\": np.array([1.23]),\n        \"dt_local\": np.array([0.1])\n    }\n\n    # Test Case 4\n    N4 = 20\n    e4 = np.arange(N4)\n    u_n4 = np.sin(2 * np.pi * e4 / N4) + 0.5 * e4 / N4\n    dt4 = 0.05 + 0.01 * (e4 % 5)\n    case4 = {\n        \"N\": N4, \"a\": 1.0,\n        \"u_initial\": u_n4,\n        \"dt_local\": dt4\n    }\n\n    test_cases = [case1, case2, case3, case4]\n    \n    results = []\n    for case in test_cases:\n        res = run_case(case[\"N\"], case[\"a\"], case[\"u_initial\"], case[\"dt_local\"])\n        results.append(res)\n    \n    # Format the final output string as specified\n    result_pairs = [f\"[{res[0]},{res[1]}]\" for res in results]\n    final_output = f\"[{','.join(result_pairs)}]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "3397152"}]}