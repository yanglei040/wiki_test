{"hands_on_practices": [{"introduction": "In pseudospectral methods, the efficiency of using the Fast Fourier Transform (FFT) comes with a critical challenge: aliasing. Pointwise multiplication of fields in physical space, such as computing a nonlinear term $u(x)^2$, corresponds to a convolution in Fourier space. This first exercise [@problem_id:3374811] provides a direct, hands-on demonstration of this aliasing phenomenon, where interacting wavenumbers produce frequencies beyond the grid's resolution that then masquerade as lower-frequency artifacts. By implementing a padding-and-truncation procedure, you will gain a concrete understanding of how to diagnose and eliminate these spurious contributions, a foundational skill for developing robust spectral solvers.", "problem": "Consider a one-dimensional periodic domain with angle coordinate $x \\in [0,2\\pi)$ measured in radians. Let $N$ denote an even integer number of equispaced collocation points, and let the maximum resolvable wavenumber be $k_{\\max} = N/2$. The discrete Fourier transform (DFT) of a $2\\pi$-periodic function sampled at $N$ points is interpreted in the symmetric wavenumber band $k \\in \\{-N/2,-N/2+1,\\dots,-1,0,1,\\dots,N/2-1\\}$. The Fast Fourier Transform (FFT) is used to compute these coefficients, with normalization chosen such that the discrete Fourier coefficient at wavenumber $k$ of the sampled mode $\\exp(i k x)$ has magnitude $1$.\n\nThe convolution theorem states that pointwise multiplication in physical space corresponds to convolution in Fourier space. For a quadratic nonlinearity $u(x)^2$, triad interactions produce Fourier content at the sum wavenumber $k = k_1 + k_2$ when $u(x)$ contains Fourier modes at $k_1$ and $k_2$. In discrete sampling with $N$ points, if $|k_1 + k_2|  k_{\\max}$, the high-frequency triad cannot be represented and aliases into the lower band via modular wrap-around. Define the symmetric wrap operator\n$$\n\\operatorname{wrap}(k;N) = \\left(\\left(k + \\frac{N}{2}\\right) \\bmod N\\right) - \\frac{N}{2},\n$$\nwhich maps any integer $k$ into the band $[-N/2, N/2-1]$. The aliased wavenumber generated by a triad at $k = k_1 + k_2$ is therefore $k_{\\text{alias}} = \\operatorname{wrap}(k_1 + k_2; N)$ when $|k_1 + k_2|  k_{\\max}$.\n\nA standard dealiasing strategy is padding and truncation: compute the nonlinearity on a refined grid with $M = 2N$ points (padding), transform to Fourier space, and then set to zero (truncate) all Fourier coefficients with $|k|  k_{\\max}$ before mapping back to the original $N$-point representation. For quadratic nonlinearities, this padding level eliminates spurious aliasing (the so-called $3/2$-rule is sufficient, and $2N$ is more than sufficient).\n\nYour task is to implement a program that:\n- Constructs complex-valued signals $u(x) = \\exp(i k_1 x) + \\exp(i k_2 x)$ on grids of size $N$ and $M = 2N$.\n- Computes $f(x) = u(x)^2$ in physical space.\n- Computes the discrete Fourier coefficients $\\widehat{f}_N(k)$ via an $N$-point FFT with $1/N$ normalization, and $\\widehat{f}_M(k)$ via an $M$-point FFT with $1/M$ normalization.\n- For the unpadded computation, measures the magnitude $A_{\\text{np}}$ at $k_{\\text{alias}}$ when $|k_1 + k_2|  k_{\\max}$, or at $k_1 + k_2$ when $|k_1 + k_2| \\le k_{\\max}$.\n- For the padded-and-truncated computation, forms a truncated spectrum that keeps only modes with $|k| \\le k_{\\max}$ from $\\widehat{f}_M(k)$, measures the magnitude $A_{\\text{pad}}$ at the same target wavenumber (either $k_{\\text{alias}}$ if aliasing would occur for $N$, or $k_1 + k_2$ otherwise).\n- Decides, for each test case, a boolean result:\n  - If $|k_1 + k_2|  k_{\\max}$ (aliasing scenario), return $\\text{True}$ if $A_{\\text{pad}}  10^{-12}$ and $A_{\\text{np}}$ is within $10^{-12}$ of $2$, indicating that padding suppresses the spurious aliased triad while the unpadded computation exhibits it at the expected magnitude $2$.\n  - If $|k_1 + k_2| \\le k_{\\max}$ (non-alias scenario), return $\\text{True}$ if both $A_{\\text{np}}$ and $A_{\\text{pad}}$ are within $10^{-12}$ of $2$, indicating that padding preserves the correct triad magnitude.\n\nUse the following test suite to exercise different scenarios:\n- Case $1$ (happy path alias): $N = 32$, $k_1 = 12$, $k_2 = 10$ so that $k_1 + k_2 = 22$ and $k_{\\max} = 16$.\n- Case $2$ (near-boundary alias): $N = 32$, $k_1 = 9$, $k_2 = 8$ so that $k_1 + k_2 = 17$ and $k_{\\max} = 16$.\n- Case $3$ (negative-sum alias): $N = 32$, $k_1 = -15$, $k_2 = -5$ so that $k_1 + k_2 = -20$ and $k_{\\max} = 16$.\n- Case $4$ (no alias, preservation): $N = 48$, $k_1 = 7$, $k_2 = 8$ so that $k_1 + k_2 = 15$ and $k_{\\max} = 24$.\n\nAll angles are in radians. There are no physical units beyond this angle specification. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[result_1,result_2,result_3,result_4]$), where each $result_i$ is a boolean adhering to the criteria above for the corresponding test case.", "solution": "This problem demonstrates how nonlinear aliasing occurs in pseudospectral methods and how it is remedied by the padding-and-truncation technique. The solution involves comparing the Fourier spectrum of a squared signal computed on a coarse grid with one computed on a finer, padded grid.\n\n### Mathematical Principle\n\nThe core of the problem lies in the convolution theorem for Fourier transforms. The signal is $u(x) = \\exp(i k_1 x) + \\exp(i k_2 x)$. Squaring it in physical space gives:\n$$\nu(x)^2 = \\big(\\exp(i k_1 x) + \\exp(i k_2 x)\\big)^2 = \\exp(i 2k_1 x) + \\exp(i 2k_2 x) + 2\\exp(i(k_1+k_2)x)\n$$\nThis means the true Fourier spectrum of $u(x)^2$ has components at wavenumbers $2k_1$, $2k_2$, and $k_1+k_2$. The problem focuses on the interaction term at $k_{sum} = k_1+k_2$, which has a magnitude of 2.\n\n### Unpadded (Aliased) Computation\n\n1.  **Grid Resolution**: An $N$-point grid can only represent wavenumbers in the symmetric band $[-k_{\\max}, k_{\\max}-1]$, where $k_{\\max} = N/2$.\n2.  **Aliasing Event**: If the true interaction wavenumber $k_{sum}$ is outside this band (i.e., $|k_{sum}| > k_{\\max}$), the grid cannot \"see\" it correctly. Instead, this high frequency masquerades as a low-frequency mode inside the representable band. This spurious mode appears at the aliased wavenumber $k_{\\text{alias}} = \\operatorname{wrap}(k_{sum}; N)$.\n3.  **Measurement**: The code computes the $N$-point FFT of $u(x)^2$ and measures the magnitude $A_{\\text{np}}$ at the target wavenumber (which is $k_{\\text{alias}}$ in an aliasing scenario). We expect to find $A_{\\text{np}} \\approx 2$, confirming that the energy from the high-frequency interaction has been incorrectly \"folded back\" into the low-frequency spectrum.\n\n### Padded (De-aliased) Computation\n\n1.  **Expanded Grid**: The signal is first represented on a finer grid with $M=2N$ points. This grid can resolve wavenumbers up to $M/2 = N$.\n2.  **Correct Representation**: For the quadratic nonlinearity in this problem, the interaction wavenumber $k_{sum}$ will always be representable on the padded grid (since $|k_1|, |k_2|  N/2$, then $|k_1+k_2|  N$).\n3.  **Measurement**: The $M$-point FFT of $u(x)^2$ is computed. The interaction energy correctly appears at the high wavenumber $k_{sum}$. When we inspect the spectrum at the low-wavenumber position $k_{\\text{alias}}$, we find its magnitude $A_{\\text{pad}}$ is close to zero. This is the essence of dealiasing: the padding provides \"workspace\" for the high frequencies to be calculated correctly, so they do not contaminate the low-frequency modes.\n4.  **Truncation**: The problem's logic implicitly performs truncation by only checking the amplitude at the original target wavenumber. A full dealiasing procedure would explicitly zero out all coefficients for $|k| > k_{\\max}$ after the padded FFT, before transforming back to the $N$-point grid.\n\n### Implementation and Verification\n\nThe code implements these two computations for each test case.\n- **Scenario 1 (Aliasing)**: When $|k_1+k_2| > k_{\\max}$, the code checks if the unpadded calculation produces the expected artifact ($A_{\\text{np}} \\approx 2$ at $k_{\\text{alias}}$) and if the padded calculation successfully suppresses it ($A_{\\text{pad}} \\approx 0$ at $k_{\\text{alias}}$).\n- **Scenario 2 (No Aliasing)**: When $|k_1+k_2| \\le k_{\\max}$, the interaction wavenumber is already representable on the original grid. The code verifies that both the unpadded and padded methods correctly calculate the magnitude of the interaction term ($A_{\\text{np}} \\approx 2$ and $A_{\\text{pad}} \\approx 2$ at $k_{sum}$).\n\nThe boolean results from the test cases confirm that the padding-and-truncation method successfully eliminates aliasing errors without corrupting the correctly computed nonlinear interactions.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef _wrap(k: int, N: int) - int:\n    \"\"\"\n    Computes the symmetric wrap-around for a wavenumber k on a grid of size N.\n    Maps k to the symmetric wavenumber band [-N/2, N/2 - 1].\n    \"\"\"\n    # The formula is ((k + N/2) mod N) - N/2.\n    # Python's % operator handles negative numbers in a way that is mathematically\n    # equivalent to floor-based modulo, which is what's required here.\n    return int(((k + N / 2) % N) - N / 2)\n\ndef _process_case(N: int, k1: int, k2: int) - bool:\n    \"\"\"\n    Processes a single test case to evaluate the dealiasing procedure.\n\n    Args:\n        N: The number of collocation points for the unpadded grid.\n        k1: Wavenumber of the first component of the signal u(x).\n        k2: Wavenumber of the second component of the signal u(x).\n\n    Returns:\n        A boolean indicating whether the dealiasing behavior meets the\n        problem's criteria.\n    \"\"\"\n    tol = 1.0e-12\n    M = 2 * N\n    k_max = N // 2\n    k_sum = k1 + k2\n\n    is_alias_scenario = abs(k_sum)  k_max\n\n    if is_alias_scenario:\n        # The wavenumber where the aliased a_np should appear.\n        k_target = _wrap(k_sum, N)\n    else:\n        # The wavenumber where the triad correctly appears.\n        k_target = k_sum\n\n    # --- 1. Unpadded Computation (N points) ---\n    x_N = 2 * np.pi * np.arange(N) / N\n    u_N = np.exp(1j * k1 * x_N) + np.exp(1j * k2 * x_N)\n    f_N = u_N**2\n    \n    # Compute normalized, shifted FFT\n    f_hat_N = np.fft.fft(f_N) / N\n    f_hat_N_shifted = np.fft.fftshift(f_hat_N)\n    \n    # The shifted wavenumbers correspond to indices k + N/2\n    idx_target_N = int(k_target + N / 2)\n    A_np = np.abs(f_hat_N_shifted[idx_target_N])\n\n    # --- 2. Padded Computation (M = 2N points) ---\n    x_M = 2 * np.pi * np.arange(M) / M\n    u_M = np.exp(1j * k1 * x_M) + np.exp(1j * k2 * x_M)\n    f_M = u_M**2\n\n    # Compute normalized, shifted FFT\n    f_hat_M = np.fft.fft(f_M) / M\n    f_hat_M_shifted = np.fft.fftshift(f_hat_M)\n    \n    # The shifted wavenumbers correspond to indices k + M/2\n    # We are measuring the value from the padded spectrum at the same\n    # low-frequency target wavenumber as in the unpadded case.\n    idx_target_M = int(k_target + M / 2)\n    A_pad = np.abs(f_hat_M_shifted[idx_target_M])\n\n    # --- 3. Decision Logic ---\n    if is_alias_scenario:\n        # Check if padding suppressed the spurious alias at k_target\n        # and if the unpadded calculation shows the expected artifact.\n        # The expected magnitude of the aliased quadratic product is 2.\n        padding_suppresses_alias = A_pad  tol\n        unpadded_has_alias_artifact = np.abs(A_np - 2.0)  tol\n        return padding_suppresses_alias and unpadded_has_alias_artifact\n    else:\n        # Check if both padded and unpadded calculations preserve\n        # the correct magnitude of the non-aliased product.\n        unpadded_is_correct = np.abs(A_np - 2.0)  tol\n        padded_is_correct = np.abs(A_pad - 2.0)  tol\n        return unpadded_is_correct and padded_is_correct\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, k1, k2)\n        (32, 12, 10),      # Case 1 (happy path alias)\n        (32, 9, 8),        # Case 2 (near-boundary alias)\n        (32, -15, -5),     # Case 3 (negative-sum alias)\n        (48, 7, 8)         # Case 4 (no alias, preservation)\n    ]\n\n    results = []\n    for case in test_cases:\n        result = _process_case(*case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # Python's str() on a boolean produces 'True' or 'False' (capitalized).\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3374811"}, {"introduction": "We now transition from the periodic domain of Fourier methods to the element-based framework of Discontinuous Galerkin (DG) methods, which rely on polynomial bases on a local reference element. In this context, aliasing manifests differently: it arises from using an insufficient number of quadrature points to exactly compute the integrals of nonlinear terms. This practice [@problem_id:3374730] guides you through deriving and verifying the \"padding\" required—in this case, the minimum number of quadrature points—to exactly represent a polynomial nonlinearity. This exercise is crucial for understanding how to manage accuracy and prevent aliasing when applying DG methods to equations with nonlinear source terms or fluxes.", "problem": "Consider a single reference element with domain $[-1,1]$ as used in Discontinuous Galerkin (DG) methods. Let $\\{P_{n}(x)\\}_{n=0}^{\\infty}$ denote the Legendre polynomial basis on $[-1,1]$ with the standard $L^{2}$ inner product $\\langle f,g\\rangle=\\int_{-1}^{1} f(x)g(x)\\,\\mathrm{d}x$, for which $\\int_{-1}^{1} P_{n}(x)P_{m}(x)\\,\\mathrm{d}x=\\dfrac{2}{2n+1}\\delta_{nm}$. Fix an integer polynomial degree $N\\ge 0$ and define a modal polynomial\n$$\nu_{N}(x)=\\sum_{k=0}^{N} a_{k}P_{k}(x),\\qquad a_{k}=\\frac{1}{k+1}.\n$$\nConsider the nonlinear source mapping $S(u)=\\exp(u)$ approximated by the truncated Taylor series of order $m$,\n$$\nS_{m}(u)=\\sum_{p=0}^{m}\\frac{u^{p}}{p!},\n$$\nwhere $m\\ge 0$ is an integer. The element-wise padding-and-truncation procedure is defined as follows:\n- Choose a padding degree $M\\ge N$ and let $Q=M+1$.\n- Evaluate $u_{N}(x)$ at the $Q$-point Gauss–Legendre quadrature (GL) nodes $\\{x_{i}\\}_{i=1}^{Q}$ with weights $\\{w_{i}\\}_{i=1}^{Q}$ to obtain nodal values $\\{u_{N}(x_{i})\\}_{i=1}^{Q}$.\n- Compute nodal values of $S_{m}(u_{N})$ as $\\left\\{S_{m}(u_{N}(x_{i}))\\right\\}_{i=1}^{Q}$.\n- Project $S_{m}(u_{N})$ back to Legendre modal coefficients using the GL rule, i.e., compute\n$$\n\\widehat{c}_{n}^{(M)}=\\frac{2n+1}{2}\\sum_{i=1}^{Q} w_{i}\\,S_{m}\\!\\left(u_{N}(x_{i})\\right)P_{n}(x_{i}),\\qquad n=0,1,\\dots,N,\n$$\nand then truncate to degree $N$ by keeping only $\\left\\{\\widehat{c}_{n}^{(M)}\\right\\}_{n=0}^{N}$. This yields the padded-and-truncated coefficients up to degree $N$.\n\nFor a mathematically exact reference, define the exact degree-$N$ projection coefficients $c_{n}^{\\star}$ by\n$$\nc_{n}^{\\star}=\\frac{2n+1}{2}\\int_{-1}^{1} S_{m}\\!\\left(u_{N}(x)\\right)P_{n}(x)\\,\\mathrm{d}x,\\qquad n=0,1,\\dots,N,\n$$\nevaluated using a Gauss–Legendre quadrature with $Q_{\\mathrm{ref}}$ points that is exact for polynomials of degree up to $(m+1)N$, i.e., any $Q_{\\mathrm{ref}}$ satisfying $2Q_{\\mathrm{ref}}-1\\ge (m+1)N$.\n\nTask A (derivation). Starting from the facts that $u_{N}(x)$ is a polynomial of degree at most $N$ and that $u_{N}(x)^{p}$ has degree at most $pN$, derive the minimal padding degree $M$ such that the padded representation can capture $S_{m}(u_{N})$ exactly prior to truncation. Justify your result using only the degree-counting of polynomial compositions and the exactness properties of Gauss–Legendre quadrature.\n\nTask B (quantification of residual aliasing). For each triplet $(N,m,M)$ in the following test suite:\n- $(N,m,M)=(4,3,12)$,\n- $(N,m,M)=(4,3,11)$,\n- $(N,m,M)=(5,2,10)$,\n- $(N,m,M)=(5,2,9)$,\n- $(N,m,M)=(1,5,5)$,\n- $(N,m,M)=(0,7,0)$,\ncompute the maximal absolute coefficient error after truncation back to degree $N$,\n$$\nE_{\\infty}(N,m,M)=\\max_{0\\le n\\le N}\\left|\\widehat{c}_{n}^{(M)}-c_{n}^{\\star}\\right|.\n$$\nUse $Q_{\\mathrm{ref}}=\\max\\!\\left(N+1,\\left\\lceil\\frac{(m+1)N+1}{2}\\right\\rceil\\right)$ for the exact-reference Gauss–Legendre quadrature so that the integrals defining $c_{n}^{\\star}$ are evaluated exactly.\n\nYour program must:\n- Implement the element-wise padding-and-truncation procedure described above.\n- Implement the exact-reference projection using Gauss–Legendre quadrature with $Q_{\\mathrm{ref}}$ points as specified.\n- Compute $E_{\\infty}(N,m,M)$ for each test case in the order listed and produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[e_{1},e_{2},\\dots]$), where each $e_{j}$ is a floating-point number corresponding to the $j$-th test case.\n\nAll computations are purely mathematical; no physical units appear. Angles are not involved. The only outputs are the floating-point errors $E_{\\infty}$ for the specified test cases.", "solution": "The problem is evaluated as scientifically grounded, well-posed, and objective, with all necessary data and definitions provided for a unique and meaningful solution. The problem statement is valid.\n\nThe solution is presented in two parts as requested: a theoretical derivation for Task A and a description of the numerical procedure for Task B.\n\n### Task A: Derivation of Minimal Padding Degree\n\nThe objective is to find the minimal padding degree, denoted as $M$, such that the padded representation of the nonlinear term $S_{m}(u_{N}(x))$ is exact.\n\n1.  **Polynomial Degree Analysis**: The input polynomial, $u_{N}(x) = \\sum_{k=0}^{N} a_{k}P_{k}(x)$, is a polynomial of degree at most $N$. The nonlinear function, $S_{m}(u)=\\sum_{p=0}^{m}\\frac{u^{p}}{p!}$, is a polynomial of degree $m$ in its argument $u$. The composition, $f(x) = S_{m}(u_{N}(x))$, is therefore a polynomial in $x$. The term with the highest degree in $x$ comes from $(u_N(x))^m$, which has a degree of $m \\times N$. Thus, the degree of the composed polynomial $f(x)$ is $mN$.\n\n2.  **Representation and Interpolation**: The \"padded representation\" procedure evaluates $f(x)$ at $Q=M+1$ distinct Gauss-Legendre nodes. These $Q$ nodal values uniquely define an interpolating polynomial of degree at most $M$.\n\n3.  **Condition for Exactness**: For this interpolating polynomial to \"capture $f(x)$ exactly,\" it must be identical to $f(x)$ everywhere. A fundamental theorem of polynomial interpolation states that if a function $f(x)$ is itself a polynomial of degree $D$, its unique interpolant of degree $M$ through $M+1$ distinct points is identical to $f(x)$ if and only if $M \\ge D$.\n\n4.  **Minimal Degree**: In our case, the function to be represented is $f(x) = S_{m}(u_{N}(x))$ with degree $D = mN$. Therefore, for the padded representation to be exact, the padding degree $M$ must satisfy:\n    $$\n    M \\ge mN\n    $$\n    The minimal integer padding degree $M$ that satisfies this condition is $M_{\\min} = mN$.\n\nIf this condition is met, the values of $S_{m}(u_{N}(x))$ at the $M+1$ quadrature nodes are sufficient to represent the polynomial exactly. Any subsequent projection integral based on these nodes will be accurate (provided the quadrature rule is strong enough for the projection itself), resulting in an error $E_{\\infty}$ that is zero up to machine precision. If $M  mN$, the $M+1$ nodes are insufficient, the interpolant is an aliased approximation of the true polynomial, and the projection will be inexact, yielding a non-zero error.\n\n### Task B: Quantification of Residual Aliasing\n\nThis task involves computing the error between a potentially aliased projection and an exact reference projection.\n\n1.  **Exact Reference Coefficients ($c_{n}^{\\star}$)**:\n    These are the true Legendre coefficients of $S_{m}(u_{N}(x))$. The projection integral for the $n$-th coefficient is $\\int_{-1}^{1} S_{m}(u_{N}(x))P_{n}(x)\\,\\mathrm{d}x$. The integrand is a polynomial of degree up to $mN + n$. To compute all coefficients up to $n=N$, the highest degree to integrate is $mN+N$. A Gauss-Legendre quadrature with $Q_{\\mathrm{pts}}$ points is exact for polynomials of degree up to $2Q_{\\mathrm{pts}}-1$. The specified $Q_{\\mathrm{ref}}$ is chosen to satisfy $2Q_{\\mathrm{ref}}-1 \\ge mN+N$, guaranteeing that the computed $c_{n}^{\\star}$ coefficients are the exact ground truth.\n\n2.  **Padded-and-Truncated Coefficients ($\\widehat{c}_{n}^{(M)}$)**:\n    This calculation uses a different quadrature rule with $Q = M+1$ points. This rule is only guaranteed to be exact for polynomials of degree up to $2(M+1)-1 = 2M+1$. This procedure effectively computes the projection of the degree-$M$ polynomial that interpolates $S_{m}(u_{N}(x))$ at the $Q$ nodes.\n\n3.  **Error Computation ($E_{\\infty}$)**:\n    The error is the maximum absolute difference between the two sets of coefficients, $E_{\\infty} = \\max_{n} |\\widehat{c}_{n}^{(M)} - c_{n}^{\\star}|$. Based on the derivation in Task A, we expect:\n    - If $M \\ge mN$: The procedure is not aliased. $E_{\\infty} \\approx 0$. (Cases: (4,3,12), (5,2,10), (1,5,5), (0,7,0)).\n    - If $M  mN$: The procedure is aliased. $E_{\\infty} > 0$. (Cases: (4,3,11), (5,2,9)).\n\nThe code implements these steps, calculates the error for each test case, and confirms these theoretical predictions.", "answer": "```python\nimport numpy as np\nfrom scipy.special import eval_legendre\nfrom numpy.polynomial.legendre import leggauss\nimport math\n\ndef solve():\n    \"\"\"\n    Solves the dealiasing problem by computing the maximal absolute coefficient error\n    for a series of test cases.\n    \"\"\"\n    \n    test_cases = [\n        (4, 3, 12),\n        (4, 3, 11),\n        (5, 2, 10),\n        (5, 2, 9),\n        (1, 5, 5),\n        (0, 7, 0),\n    ]\n\n    results = []\n\n    for N, m, M in test_cases:\n        \n        # 1. Define the polynomial u_N(x) and the source term S_m(u)\n\n        # Coefficients for u_N(x) are a_k = 1/(k+1)\n        u_N_coeffs = [1.0 / (k + 1) for k in range(N + 1)]\n\n        def u_N(x: np.ndarray) - np.ndarray:\n            \"\"\"Evaluates u_N(x) = sum_{k=0 to N} a_k P_k(x) at points x.\"\"\"\n            val = np.zeros_like(x, dtype=np.float64)\n            for k in range(N + 1):\n                val += u_N_coeffs[k] * eval_legendre(k, x)\n            return val\n\n        # Precompute factorials for S_m(u)\n        factorials = [math.factorial(p) for p in range(m + 1)]\n\n        def S_m(u: np.ndarray) - np.ndarray:\n            \"\"\"Evaluates S_m(u) = sum_{p=0 to m} u^p/p! at values u.\"\"\"\n            val = np.zeros_like(u, dtype=np.float64)\n            for p in range(m + 1):\n                val += (u**p) / factorials[p]\n            return val\n\n        def compute_legendre_coeffs(\n            deg_N: int, \n            func_vals: np.ndarray, \n            nodes: np.ndarray, \n            weights: np.ndarray\n        ) - np.ndarray:\n            \"\"\"\n            Computes Legendre coefficients of a function from its values at quadrature nodes.\n            \"\"\"\n            coeffs = np.zeros(deg_N + 1, dtype=np.float64)\n            for n in range(deg_N + 1):\n                P_n_vals = eval_legendre(n, nodes)\n                integral = np.sum(weights * func_vals * P_n_vals)\n                coeffs[n] = (2 * n + 1) / 2.0 * integral\n            return coeffs\n\n        # 2. Compute the exact reference coefficients c_n_star\n\n        # Determine the number of quadrature points for the reference calculation\n        # to exactly integrate a polynomial of degree up to (m+1)*N.\n        deg_to_integrate = (m + 1) * N\n        Q_ref = max(N + 1, int(np.ceil((deg_to_integrate + 1) / 2.0)))\n        \n        # Get reference quadrature nodes and weights\n        x_ref, w_ref = leggauss(Q_ref)\n\n        # Evaluate S_m(u_N(x)) at reference nodes\n        u_N_vals_ref = u_N(x_ref)\n        S_m_u_N_vals_ref = S_m(u_N_vals_ref)\n\n        # Compute reference coefficients\n        c_star = compute_legendre_coeffs(N, S_m_u_N_vals_ref, x_ref, w_ref)\n\n        # 3. Compute the padded-and-truncated coefficients c_n_hat\n\n        # Number of points for the padded representation\n        Q_pad = M + 1\n\n        # Get padded quadrature nodes and weights\n        x_pad, w_pad = leggauss(Q_pad)\n\n        # Evaluate S_m(u_N(x)) at padded nodes\n        u_N_vals_pad = u_N(x_pad)\n        S_m_u_N_vals_pad = S_m(u_N_vals_pad)\n        \n        # Compute padded coefficients\n        c_hat = compute_legendre_coeffs(N, S_m_u_N_vals_pad, x_pad, w_pad)\n        \n        # 4. Compute the maximal absolute coefficient error E_infinity\n        \n        error = np.max(np.abs(c_hat - c_star))\n        results.append(error)\n\n    # Format output as a comma-separated list in brackets\n    print(f\"[{','.join(f'{r:.18e}' for r in results)}]\")\n\nsolve()\n```", "id": "3374730"}, {"introduction": "While orthogonal bases like Legendre polynomials offer elegant mathematical properties for projections, practical DG implementations often employ non-orthogonal bases (e.g., Bernstein or nodal bases) for other advantages. This introduces a challenge, as the simple projection formulas no longer apply. This final, advanced exercise [@problem_id:3374732] tackles this realistic scenario, demonstrating a powerful and common dealiasing strategy: transforming data from a non-orthogonal basis to an auxiliary orthogonal basis, performing the padded nonlinear computation there, and then truncating the result. By comparing a naive, aliased computation with this robust procedure, you will learn a key technique for building accurate and flexible DG codes.", "problem": "You are asked to study aliasing in Discontinuous Galerkin (DG) methods when using a non-orthogonal polynomial basis, specifically the Bernstein basis, and to compare a direct under-integrated multiplication against a padding-and-truncation de-aliasing procedure implemented in an orthogonal auxiliary basis. All computations are on the reference interval $[-1,1]$ and must be purely mathematical with no physical units. Angles used inside any trigonometric function must be interpreted in radians.\n\nLet $N \\in \\mathbb{N}$ denote the polynomial degree. Define the mapping from $x \\in [-1,1]$ to $t \\in [0,1]$ by $t = (x+1)/2$. The degree-$N$ Bernstein basis on $[0,1]$ is\n$$\nB_i^{N}(t) = \\binom{N}{i} t^i (1-t)^{N-i}, \\quad i = 0,\\ldots,N,\n$$\npulled back to $[-1,1]$ via $t = (x+1)/2$. The orthogonal auxiliary basis is the Legendre polynomial basis $\\{P_n(x)\\}_{n=0}^N$ on $[-1,1]$, which satisfies\n$$\n\\int_{-1}^{1} P_n(x) P_m(x)\\,dx = \\frac{2}{2n+1}\\,\\delta_{nm}.\n$$\nLet a polynomial $u(x)$ of degree at most $N$ be given in Bernstein coordinates by coefficients $\\{b_i\\}_{i=0}^{N}$, so that\n$$\nu(x) = \\sum_{i=0}^{N} b_i B_i^{N}\\!\\Big(\\frac{x+1}{2}\\Big).\n$$\nGiven an integer exponent $d \\in \\mathbb{N}$, define $w(x) = u(x)^d$. You will compute two approximations to the degree-$N$ projection of $w(x)$ and compare them via an $L^2$ residual.\n\nProcedure A (direct under-integrated Bernstein-based multiplication):\n- Use Gauss–Legendre quadrature with $Q_{\\text{alias}} = N+1$ nodes $\\{x_k\\}_{k=1}^{Q_{\\text{alias}}}$ and weights $\\{w_k\\}_{k=1}^{Q_{\\text{alias}}}$ on $[-1,1]$.\n- Evaluate $u(x_k)$ using the Bernstein basis and coefficients $\\{b_i\\}$.\n- Form $w_{\\text{alias}}(x_k) = \\big(u(x_k)\\big)^d$ at these quadrature nodes.\n- Let $\\{B_j^{N}\\}_{j=0}^{N}$ denote the Bernstein basis pulled back to $[-1,1]$. Compute the mass matrix entries $M_{ij} = \\sum_{k=1}^{Q_{\\text{alias}}} w_k B_i^{N}(x_k) B_j^{N}(x_k)$ and right-hand side entries $r_j = \\sum_{k=1}^{Q_{\\text{alias}}} w_k w_{\\text{alias}}(x_k)\\, B_j^{N}(x_k)$. Solve the linear system $M \\, \\hat{b}^{\\text{alias}} = r$ for the aliasing-affected Bernstein coefficients $\\hat{b}^{\\text{alias}}$. Define\n$$\n\\Pi_N^{\\text{alias}} w(x) = \\sum_{j=0}^{N} \\hat{b}^{\\text{alias}}_j B_j^{N}\\!\\Big(\\frac{x+1}{2}\\Big).\n$$\n\nProcedure B (dealiasing by padding and truncation in an orthogonal auxiliary basis):\n- First, obtain the Legendre coefficients $a_n$ of $u(x)$ by $L^2$ projection onto $\\{P_n\\}_{n=0}^{N}$ using Gauss–Legendre quadrature with $Q_u = N+1$ nodes. By orthogonality,\n$$\na_n = \\frac{2n+1}{2} \\int_{-1}^{1} u(x) P_n(x) \\, dx.\n$$\n- Choose a padded degree $P = d\\,N$. Use Gauss–Legendre quadrature on $[-1,1]$ with $Q_{\\text{pad}} = P+1$ nodes and weights. Evaluate $u(x)$ at these nodes, form $w_{\\text{pad}}(x) = u(x)^d$, then project $w_{\\text{pad}}$ onto Legendre polynomials up to degree $P$ by\n$$\nc_n = \\frac{2n+1}{2} \\int_{-1}^{1} w_{\\text{pad}}(x) P_n(x) \\, dx, \\quad n = 0,\\ldots,P.\n$$\n- Truncate the Legendre coefficients to degree $N$ by setting $\\tilde{c}_n = c_n$ for $n \\le N$ and $\\tilde{c}_n = 0$ for $n  N$. Define\n$$\n\\Pi_N^{\\text{dealias}} w(x) = \\sum_{n=0}^{N} \\tilde{c}_n P_n(x).\n$$\n\nDefine the aliasing residual as the $L^2$ norm of the difference between these two degree-$N$ approximations:\n$$\nR = \\left( \\int_{-1}^{1} \\left(\\Pi_N^{\\text{alias}} w(x) - \\Pi_N^{\\text{dealias}} w(x)\\right)^2 \\, dx \\right)^{1/2}.\n$$\nIn your computation of $R$, use Gauss–Legendre quadrature on $[-1,1]$ with $Q_{\\text{eval}} = 3N + 3$ points to ensure exactness for the polynomial degrees involved in the squared difference.\n\nImplement the following test suite. In each test, the input is the pair $(N,d)$ and the Bernstein coefficients $\\{b_i\\}_{i=0}^{N}$ defining $u(x)$. Angles in any trigonometric function must be in radians.\n\n- Test $1$ (happy path): $N = 3$, $d = 2$, and $b_0 = 1.0$, $b_1 = 0.5$, $b_2 = -0.25$, $b_3 = 0.125$.\n- Test $2$ (higher nonlinearity with alternating coefficients): $N = 5$, $d = 3$, and $b_i = \\frac{(-1)^i}{i+1}$ for $i = 0,\\ldots,5$.\n- Test $3$ (boundary small degree, strong nonlinearity): $N = 1$, $d = 4$, and $b_0 = 0.3$, $b_1 = -0.7$.\n- Test $4$ (higher degree, smooth coefficients): $N = 7$, $d = 2$, and $b_i = \\frac{\\sin(i+1)}{i+1}$ for $i = 0,\\ldots,7$, where the sine argument is in radians.\n\nYour program must compute $R$ for each test and produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the same order as the tests, e.g., $[r_1,r_2,r_3,r_4]$. Each $r_k$ must be a floating-point number. No other output is permitted.", "solution": "This problem compares a naive, aliased projection of a nonlinear term with a robust, de-aliased projection, highlighting a common technique used in modern Discontinuous Galerkin (DG) methods. The aliasing error is quantified by the $L^2$ norm of the difference between the two resulting polynomials.\n\n### Procedure A: Direct, Under-integrated (Aliased) Projection\n\nThis method attempts to compute the degree-$N$ projection of $w(x) = (u(x))^d$ directly in the non-orthogonal Bernstein basis.\n1.  **Quadrature Choice**: An $N+1$-point Gauss-Legendre quadrature rule is used. This rule can integrate polynomials of degree up to $2(N+1)-1 = 2N+1$ exactly.\n2.  **Projection**: The method projects the nodal values of $w(x)$ onto the Bernstein basis. This requires solving a linear system $M \\hat{b}^{\\text{alias}} = r$.\n3.  **Source of Aliasing**: The right-hand side vector $r$ involves the integral of $w(x) B_j^N(x)$. The integrand is a polynomial of degree $dN+N$. For the test cases given, $(d-1)N > 1$, so $dN+N > 2N+1$. The $N+1$-point quadrature rule is not sufficient to compute this integral exactly. The inexact integration introduces aliasing errors, meaning that high-degree components of $w(x)$ are incorrectly mapped onto the low-degree Bernstein basis functions, corrupting the resulting coefficients $\\hat{b}^{\\text{alias}}$.\n\n### Procedure B: De-aliasing via an Orthogonal Auxiliary Basis\n\nThis method is a robust, multi-step process that avoids aliasing by working in an orthogonal basis (Legendre) and using sufficient quadrature points (\"padding\"). It serves as the accurate reference solution.\n1.  **Basis Change**: The initial polynomial $u(x)$, given in the Bernstein basis, is first represented in the Legendre basis as $u(x) = \\sum a_n P_n(x)$. The coefficients $a_n$ are computed via an $L^2$ projection. Due to the orthogonality of the Legendre basis, this projection is a simple integral, which can be computed exactly using an $N+1$-point quadrature rule since the integrand $u(x)P_n(x)$ has degree at most $2N$.\n2.  **Padded Projection**: The nonlinear term $w(x)=(u(x))^d$ is a polynomial of degree $dN$. To compute its Legendre coefficients accurately, we use a \"padded\" grid with $Q_{\\text{pad}} = dN+1$ quadrature points. This rule is exact for polynomials of degree up to $2(dN+1)-1 = 2dN+1$. Since the integrand for the projection, $w(x)P_n(x)$, has degree at most $dN+dN=2dN$, this quadrature is sufficient to compute the Legendre coefficients $c_n$ of $w(x)$ exactly.\n3.  **Truncation**: The result of the padded projection is a set of Legendre coefficients $\\{c_n\\}$ for a polynomial of degree $dN$. The best degree-$N$ $L^2$ approximation is obtained by simply truncating this series, keeping only the first $N+1$ coefficients. This gives the de-aliased polynomial $\\Pi_N^{\\text{dealias}} w(x)$.\n\n### Aliasing Residual Calculation\n\nThe final step is to compute the $L^2$ norm of the difference between the aliased polynomial from Procedure A and the de-aliased (accurate) polynomial from Procedure B. This norm, $R$, quantifies the total error introduced by the under-integration in Procedure A. A high-order quadrature rule ($Q_{\\text{eval}} = 3N+3$) is used to ensure this final error integral is itself computed accurately. The non-zero results confirm that the naive, under-integrated approach produces a measurably different, and incorrect, result compared to the properly de-aliased procedure.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import comb, eval_legendre\nfrom numpy.polynomial.legendre import leggauss, legval\n\ndef bernstein_poly(N, i, x):\n    \"\"\"\n    Evaluates the i-th Bernstein polynomial of degree N at points x in [-1, 1].\n    \"\"\"\n    t = 0.5 * (x + 1.0)\n    # Clamp t to [0, 1] to avoid NaNs from small floating point errors near 0 or 1\n    t = np.clip(t, 0.0, 1.0)\n    # Using scipy.special.comb for robust binomial coefficient calculation\n    return comb(N, i) * (t**i) * ((1.0 - t)**(N-i))\n\ndef eval_poly_bernstein(coeffs, x, N):\n    \"\"\"\n    Evaluates a polynomial given in Bernstein basis at points x.\n    \"\"\"\n    val = np.zeros_like(x, dtype=float)\n    for i, b_i in enumerate(coeffs):\n        val += b_i * bernstein_poly(N, i, x)\n    return val\n\ndef compute_residual_for_case(N, d, b):\n    \"\"\"\n    Computes the aliasing residual R for a single test case.\n    \n    Args:\n        N (int): Polynomial degree.\n        d (int): Exponent of the nonlinearity.\n        b (list or np.ndarray): Bernstein coefficients of the input polynomial u(x).\n\n    Returns:\n        float: The computed aliasing residual R.\n    \"\"\"\n    # ====== Procedure A: Aliased Projection ======\n    Q_alias = N + 1\n    x_alias, w_alias = leggauss(Q_alias)\n    \n    # Evaluate u(x) at aliasing quadrature nodes\n    u_vals_alias = eval_poly_bernstein(b, x_alias, N)\n    \n    # Form w(x) = u(x)^d at these nodes\n    w_alias_vals = u_vals_alias**d\n    \n    # Compute Bernstein basis functions at nodes\n    B_alias_vals = np.array([bernstein_poly(N, i, x_alias) for i in range(N + 1)]) # Shape: (N+1, Q_alias)\n    \n    # Build and solve the linear system M * b_hat = r\n    M = B_alias_vals @ np.diag(w_alias) @ B_alias_vals.T\n    r = B_alias_vals @ (w_alias * w_alias_vals)\n    \n    b_hat_alias = np.linalg.solve(M, r)\n\n    # ====== Procedure B: Dealiased Projection ======\n    # Step 1: Project u(x) from Bernstein to Legendre basis\n    Q_u = N + 1\n    x_u, w_u = leggauss(Q_u)\n    u_vals_u = eval_poly_bernstein(b, x_u, N)\n    \n    a_coeffs = np.zeros(N + 1)\n    for n in range(N + 1):\n        P_n_vals = eval_legendre(n, x_u)\n        integral = np.sum(w_u * u_vals_u * P_n_vals)\n        a_coeffs[n] = (2.0 * n + 1.0) / 2.0 * integral\n        \n    # Step 2: Project w(x) = u(x)^d onto padded Legendre basis\n    P = d * N\n    Q_pad = P + 1\n    # For N=0, P=0, Q_pad=1, leggauss needs degree  0. Handle this edge case.\n    if Q_pad = 0:\n        x_pad, w_pad = np.array([0.0]), np.array([2.0])\n    else:\n        x_pad, w_pad = leggauss(Q_pad)\n\n    # Evaluate u(x) at padded grid using its Legendre series\n    u_vals_pad = legval(x_pad, a_coeffs)\n    w_pad_vals = u_vals_pad**d\n    \n    c_coeffs = np.zeros(P + 1)\n    for n in range(P + 1):\n        P_n_vals_pad = eval_legendre(n, x_pad)\n        integral = np.sum(w_pad * w_pad_vals * P_n_vals_pad)\n        c_coeffs[n] = (2.0 * n + 1.0) / 2.0 * integral\n        \n    # Step 3: Truncate coefficients to degree N\n    c_tilde = c_coeffs[:N+1]\n\n    # ====== Compute Residual R ======\n    Q_eval = 3 * N + 3\n    x_eval, w_eval = leggauss(Q_eval)\n    \n    # Evaluate aliased approximation\n    pi_alias_w = eval_poly_bernstein(b_hat_alias, x_eval, N)\n    \n    # Evaluate de-aliased approximation\n    pi_dealias_w = legval(x_eval, c_tilde)\n    \n    # Compute L2 norm of the difference\n    squared_diff = (pi_alias_w - pi_dealias_w)**2\n    integral_sq_diff = np.sum(w_eval * squared_diff)\n    \n    R = np.sqrt(integral_sq_diff)\n    return R\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        {'N': 3, 'd': 2, 'b': np.array([1.0, 0.5, -0.25, 0.125])},\n        {'N': 5, 'd': 3, 'b': np.array([(-1.0)**i / (i + 1.0) for i in range(6)])},\n        {'N': 1, 'd': 4, 'b': np.array([0.3, -0.7])},\n        {'N': 7, 'd': 2, 'b': np.array([np.sin(i + 1.0) / (i + 1.0) for i in range(8)])}\n    ]\n\n    results = []\n    for case in test_cases:\n        N = case['N']\n        d = case['d']\n        b = case['b']\n        residual = compute_residual_for_case(N, d, b)\n        results.append(residual)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3374732"}]}