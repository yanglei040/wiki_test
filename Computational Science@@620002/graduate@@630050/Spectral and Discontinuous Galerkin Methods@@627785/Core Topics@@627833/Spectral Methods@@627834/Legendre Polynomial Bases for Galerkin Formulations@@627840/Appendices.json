{"hands_on_practices": [{"introduction": "A cornerstone of spectral methods is the use of orthogonal basis functions, such as Legendre polynomials. This orthogonality provides remarkable computational efficiency, as the coefficients of a least-squares projection can be determined independently of one another. This practice challenges you to demonstrate this powerful property by deriving the coefficients needed to augment an existing approximation, reinforcing the foundational principle of $L^2$ projections in a modal Galerkin framework [@problem_id:3395701].", "problem": "Consider the one-dimensional reference element $\\Omega = [-1,1]$ with the standard Legendre polynomial basis $\\{P_{n}(x)\\}_{n\\geq 0}$, where $P_{n}(1)=1$ and the inner product is defined by $\\langle f,g\\rangle = \\int_{-1}^{1} f(x)\\,g(x)\\,\\mathrm{d}x$. Assume a spectral or discontinuous Galerkin discretization in which the modal approximation uses the non-orthonormal Legendre basis $\\{P_{n}\\}$.\n\nLet the exact target function be $u(x)=\\exp(\\beta x)$ for a fixed parameter $\\beta\\in\\mathbb{R}$. You have an existing modal solution of degree $p$ constructed by least-squares projection in the $L^{2}(\\Omega)$ norm onto $\\operatorname{span}\\{P_{0},P_{1},\\dots,P_{p}\\}$. You are asked to augment the approximation space to degree $p+2$ (i.e., include $P_{p+1}$ and $P_{p+2}$) and determine, using only orthogonality and inner-product relations, the least-squares coefficients of the new modes $P_{p+1}$ and $P_{p+2}$ in closed form.\n\nDerive the expressions for the two augmentation coefficients as analytic functions of $p$ and $\\beta$ and provide your final answer as a single row matrix containing the two coefficients. No numerical rounding is required.", "solution": "The problem requires the determination of the coefficients for the basis functions $P_{p+1}(x)$ and $P_{p+2}(x)$ when a degree-$p$ spectral approximation of the function $u(x) = \\exp(\\beta x)$ is augmented to a degree-$(p+2)$ approximation. The approximation is defined as a least-squares projection in the $L^2(\\Omega)$ norm, where $\\Omega = [-1,1]$.\n\nLet the degree-$N$ approximation of $u(x)$ be denoted by $u_N(x)$, expressed as a linear combination of the Legendre basis polynomials $\\{P_n(x)\\}_{n=0}^N$:\n$$u_N(x) = \\sum_{n=0}^{N} \\hat{u}_n P_n(x)$$\nThe coefficients $\\hat{u}_n$ are determined by the least-squares projection, which is equivalent to the Galerkin condition that the error $u(x) - u_N(x)$ is orthogonal to the approximation space $\\operatorname{span}\\{P_0, \\dots, P_N\\}$. This condition is expressed as:\n$$\\langle u - u_N, v \\rangle = 0, \\quad \\forall v \\in \\operatorname{span}\\{P_0, \\dots, P_N\\}$$\nBy choosing the basis functions $v = P_k(x)$ for $k \\in \\{0, 1, \\dots, N\\}$, we obtain a set of equations:\n$$\\langle u(x) - \\sum_{n=0}^{N} \\hat{u}_n P_n(x), P_k(x) \\rangle = 0$$\n$$\\langle u, P_k \\rangle - \\sum_{n=0}^{N} \\hat{u}_n \\langle P_n, P_k \\rangle = 0$$\nThe standard Legendre polynomials form an orthogonal basis on the interval $[-1,1]$ with respect to the given inner product $\\langle f,g\\rangle = \\int_{-1}^{1} f(x)g(x)\\,\\mathrm{d}x$. Their orthogonality property is:\n$$\\langle P_n, P_k \\rangle = \\int_{-1}^{1} P_n(x) P_k(x) \\,\\mathrm{d}x = \\frac{2}{2n+1} \\delta_{nk}$$\nwhere $\\delta_{nk}$ is the Kronecker delta. The problem states the basis is \"non-orthonormal\", which we interpret as correct in the sense that the basis vectors are not normalized to have a unit norm (i.e., $\\langle P_n, P_n\\rangle \\neq 1$), but they are orthogonal. This orthogonality is crucial and its use is explicitly requested.\n\nSubstituting the orthogonality property into the Galerkin condition, the summation collapses to a single term where $n=k$:\n$$\\langle u, P_k \\rangle - \\hat{u}__k \\langle P_k, P_k \\rangle = 0$$\nThis allows for the direct calculation of each coefficient $\\hat{u}_k$ independently:\n$$\\hat{u}_k = \\frac{\\langle u, P_k \\rangle}{\\langle P_k, P_k \\rangle} = \\frac{\\int_{-1}^{1} u(x) P_k(x) \\,\\mathrm{d}x}{\\frac{2}{2k+1}} = \\frac{2k+1}{2} \\int_{-1}^{1} u(x) P_k(x) \\,\\mathrm{d}x$$\nThis formula is valid for any coefficient $\\hat{u}_k$ in the expansion. A key consequence of orthogonality is that the coefficient $\\hat{u}_k$ depends only on $u(x)$ and $P_k(x)$, not on the dimension of the approximation space. Therefore, when augmenting the approximation from degree $p$ to degree $p+2$, the coefficients $\\hat{u}_0, \\dots, \\hat{u}_p$ remain unchanged. The new coefficients we must find are for the modes $P_{p+1}(x)$ and $P_{p+2}(x)$, which are simply $\\hat{u}_{p+1}$ and $\\hat{u}_{p+2}$.\n\nThe target function is $u(x) = \\exp(\\beta x)$. The coefficients are:\n$$\\hat{u}_{p+1} = \\frac{2(p+1)+1}{2} \\int_{-1}^{1} \\exp(\\beta x) P_{p+1}(x) \\,\\mathrm{d}x = \\frac{2p+3}{2} \\int_{-1}^{1} \\exp(\\beta x) P_{p+1}(x) \\,\\mathrm{d}x$$\n$$\\hat{u}_{p+2} = \\frac{2(p+2)+1}{2} \\int_{-1}^{1} \\exp(\\beta x) P_{p+2}(x) \\,\\mathrm{d}x = \\frac{2p+5}{2} \\int_{-1}^{1} \\exp(\\beta x) P_{p+2}(x) \\,\\mathrm{d}x$$\nTo proceed, we need to evaluate the integral $\\int_{-1}^{1} \\exp(\\beta x) P_n(x) \\,\\mathrm{d}x$. This is a standard integral in the theory of special functions. The result is given in terms of the modified spherical Bessel functions of the first kind, denoted $i_n(z)$:\n$$\\int_{-1}^{1} \\exp(\\beta x) P_n(x) \\,\\mathrm{d}x = 2 i_n(\\beta)$$\nThe functions $i_n(\\beta)$ are analytic functions of $\\beta$ and are expressible in terms of elementary functions (hyperbolic functions and powers of $\\beta$). For example, $i_0(\\beta) = \\frac{\\sinh(\\beta)}{\\beta}$ and $i_1(\\beta) = \\frac{\\cosh(\\beta)}{\\beta} - \\frac{\\sinh(\\beta)}{\\beta^2}$. The problem asks for the coefficients as analytic functions of $p$ and $\\beta$, and expressing them using $i_n(\\beta)$ is the standard and most compact closed form.\n\nSubstituting this identity into the expressions for the coefficients:\nFor the coefficient of $P_{p+1}(x)$:\n$$\\hat{u}_{p+1} = \\frac{2p+3}{2} \\left( 2 i_{p+1}(\\beta) \\right) = (2p+3) i_{p+1}(\\beta)$$\nFor the coefficient of $P_{p+2}(x)$:\n$$\\hat{u}_{p+2} = \\frac{2p+5}{2} \\left( 2 i_{p+2}(\\beta) \\right) = (2p+5) i_{p+2}(\\beta)$$\nThese are the required augmentation coefficients in closed form as analytic functions of $p$ and $\\beta$. The final answer should be presented as a row matrix containing these two expressions.", "answer": "$$ \\boxed{ \\begin{pmatrix} (2p+3) i_{p+1}(\\beta) & (2p+5) i_{p+2}(\\beta) \\end{pmatrix} } $$", "id": "3395701"}, {"introduction": "Moving from theory to practice, the implementation of any Galerkin method requires the evaluation of integrals that define the weak formulation. While we can sometimes solve these analytically, most complex problems, especially those involving nonlinearities, necessitate numerical quadrature. This exercise [@problem_id:3395757] asks you to determine the precise number of quadrature points needed to guarantee exact integration in a Discontinuous Galerkin (DG) setting, a critical skill for designing robust and efficient numerical schemes.", "problem": "Consider the Discontinuous Galerkin (DG) semi-discrete formulation of a scalar conservation law on a one-dimensional reference element with coordinate $x \\in [-1,1]$. Let the trial and test spaces be spanned by Legendre polynomials $\\{P_{k}(x)\\}_{k=0}^{p}$, so that the trace of any solution $u_{h}$ or test function $v_{h}$ on a face parameterized by a local coordinate $s \\in [-1,1]$ is a univariate polynomial of degree at most $p$. Assume that the numerical flux is a two-point function $\\widehat{f}(u^{-},u^{+})$ which, when the physical flux $f(u)$ is polynomial of degree at most $r \\in \\mathbb{N}$, is itself a polynomial in its arguments of total degree at most $r$. Along a face, the DG face integral involves the product of a test trace $v_{h}(s)$ and $\\widehat{f}(u_{h}^{-}(s),u_{h}^{+}(s))$.\n\nUsing only first principles about polynomial degree under algebraic operations and the defining property of Legendre polynomial spaces, determine the minimal number of Gauss–Legendre quadrature points $N_{q}$ on a face that guarantees exact evaluation of the face integral for all $u_{h},v_{h} \\in \\mathbb{P}_{p}$ when $\\widehat{f}$ has total polynomial degree at most $r$ in its arguments. Then, specialize your result to the requirement for exact integration of products whose degree is at most $2p$.\n\nProvide your final answer as a two-entry row vector: the first entry is $N_{q}$ as a function of $p$ and $r$, and the second entry is the minimal $N_{q}$ needed to exactly integrate all products up to degree $2p$. No numerical evaluation is required, and no units are involved. The final answer must be a closed-form expression.", "solution": "The problem requires determining the minimal number of Gauss-Legendre quadrature points, $N_q$, for the exact evaluation of a face integral in a Discontinuous Galerkin (DG) method, and then for a more general case. The validation of the problem statement must be performed first.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n-   **Domain**: A one-dimensional reference element with coordinate $x \\in [-1,1]$.\n-   **Methodology**: Discontinuous Galerkin (DG) semi-discrete formulation for a scalar conservation law.\n-   **Function Spaces**: Trial and test spaces are spanned by Legendre polynomials, $\\{P_{k}(x)\\}_{k=0}^{p}$, denoted as $\\mathbb{P}_{p}$. The solution $u_h$ and test function $v_h$ are in $\\mathbb{P}_{p}$.\n-   **Face Formulation**: Traces of $u_h$ and $v_h$ on a face are parameterized by a local coordinate $s \\in [-1,1]$ and are univariate polynomials of degree at most $p$.\n-   **Numerical Flux**: The numerical flux is a two-point function $\\widehat{f}(u^{-},u^{+})$.\n-   **Flux Property**: When the physical flux $f(u)$ is a polynomial of degree at most $r \\in \\mathbb{N}$, $\\widehat{f}$ is a polynomial in its arguments of total degree at most $r$.\n-   **Integral of Interest**: The face integral involves the product $v_{h}(s) \\widehat{f}(u_{h}^{-}(s),u_{h}^{+}(s))$.\n-   **Quadrature Rule**: Gauss-Legendre quadrature is used.\n-   **Objectives**:\n    1.  Determine the minimal number of quadrature points $N_{q}$ on a face for exact integration, as a function of $p$ and $r$.\n    2.  Determine the minimal $N_{q}$ required to exactly integrate products whose degree is at most $2p$.\n\n**Step 2: Validate Using Extracted Givens**\n-   **Scientific Grounding**: The problem is firmly situated within the established mathematical framework of the Discontinuous Galerkin method, a key topic in numerical analysis for partial differential equations. All concepts used—Legendre polynomials, polynomial approximation spaces ($\\mathbb{P}_p$), Gauss-Legendre quadrature, numerical flux—are standard and rigorously defined. The premises are scientifically sound.\n-   **Well-Posedness**: The problem is well-posed. It asks for the minimal number of quadrature points required to achieve exact integration of a polynomial of a certain degree. This degree is derivable from the given information ($p$ and $r$). A unique, meaningful integer solution for $N_q$ exists for both parts of the problem.\n-   **Objectivity**: The problem is stated using precise, objective, and unambiguous mathematical language. There are no subjective or opinion-based clauses.\n\n**Step 3: Verdict and Action**\nThe problem is scientifically sound, well-posed, and self-contained. It presents a standard analysis task in the study of DG methods. Therefore, the problem is deemed **valid**. A full solution will be provided.\n\n### Solution\n\nThe fundamental principle governing this problem is the exactness property of Gauss-Legendre quadrature. An $N_q$-point Gauss-Legendre quadrature rule on the interval $[-1,1]$ integrates any polynomial of degree at most $2N_q - 1$ exactly. To find the minimal number of points $N_q$, we must first determine the maximum possible degree of the polynomial integrand.\n\n**Part 1: Face Integral Quadrature**\n\nThe face integral to be evaluated is of the form\n$$\nI = \\int_{-1}^{1} v_{h}(s) \\widehat{f}(u_{h}^{-}(s), u_{h}^{+}(s)) ds\n$$\nLet the integrand be denoted by $g(s) = v_{h}(s) \\widehat{f}(u_{h}^{-}(s), u_{h}^{+}(s))$. We need to find the maximum possible polynomial degree of $g(s)$, denoted $\\deg(g)$.\n\n1.  **Degree of the Test Function Trace**: The test function $v_h$ belongs to the space $\\mathbb{P}_p$, which consists of polynomials of degree at most $p$. Its trace on the face, $v_h(s)$, is therefore a polynomial in the face coordinate $s$ with $\\deg(v_h(s)) \\le p$.\n\n2.  **Degree of the Solution Traces**: Similarly, the solution $u_h$ is in $\\mathbb{P}_p$. Its interior and exterior traces on the face, $u_h^-(s)$ and $u_h^+(s)$, are polynomials in $s$, each with a degree of at most $p$. Thus, $\\deg(u_h^-(s)) \\le p$ and $\\deg(u_h^+(s)) \\le p$.\n\n3.  **Degree of the Numerical Flux Term**: The numerical flux $\\widehat{f}(A,B)$ is given to be a polynomial in its arguments $A$ and $B$ of total degree at most $r$. This means it can be expressed as a sum of terms of the form $c_{ij}A^i B^j$ where $i+j \\le r$.\n    In our case, the arguments are the polynomial traces, $A = u_h^-(s)$ and $B = u_h^+(s)$. The degree of a single term in the expansion of $\\widehat{f}(u_h^-(s), u_h^+(s))$ is:\n    $$\n    \\deg\\left( (u_h^-(s))^i (u_h^+(s))^j \\right) = i \\cdot \\deg(u_h^-(s)) + j \\cdot \\deg(u_h^+(s))\n    $$\n    To find the maximum possible degree, we take the maximum degree for the traces:\n    $$\n    \\deg\\left( (u_h^-(s))^i (u_h^+(s))^j \\right) \\le i \\cdot p + j \\cdot p = (i+j)p\n    $$\n    The degree of the entire numerical flux polynomial $\\widehat{f}(u_h^-(s), u_h^+(s))$ is the maximum of the degrees of its constituent terms. This maximum is achieved when the sum $i+j$ is maximized. According to the problem statement, the maximum value of $i+j$ is $r$.\n    Therefore, the maximum degree of the numerical flux as a polynomial in $s$ is $r \\cdot p$. Let's denote this as $\\deg(\\widehat{f}(\\cdot, \\cdot))_s \\le rp$.\n\n4.  **Degree of the Full Integrand**: The integrand is the product $g(s) = v_h(s) \\cdot \\widehat{f}(u_h^-(s), u_h^+(s))$. The degree of a product of polynomials is the sum of their degrees.\n    $$\n    \\deg(g(s)) = \\deg(v_h(s)) + \\deg(\\widehat{f}(u_h^-(s), u_h^+(s)))_s\n    $$\n    The maximum possible degree of the integrand, $D_{\\text{max}}$, is therefore:\n    $$\n    D_{\\text{max}} \\le p + rp = p(r+1)\n    $$\n\n5.  **Required Number of Quadrature Points**: To guarantee exact integration, the Gauss-Legendre quadrature rule must be exact for any polynomial of degree up to $D_{\\text{max}} = p(r+1)$. We must satisfy the condition:\n    $$\n    2N_q - 1 \\ge p(r+1)\n    $$\n    Solving for $N_q$, we get:\n    $$\n    N_q \\ge \\frac{p(r+1) + 1}{2}\n    $$\n    Since $N_q$ must be an integer, the minimal required number of quadrature points is the smallest integer satisfying this inequality, which is given by the ceiling function:\n    $$\n    N_q = \\left\\lceil \\frac{p(r+1) + 1}{2} \\right\\rceil\n    $$\n\n**Part 2: Specialization for Products of Degree at most $2p$**\n\nThe second part asks for the minimal $N_q$ needed to exactly integrate products whose total polynomial degree is at most $2p$. This is a direct application of the same quadrature principle.\n\n1.  **Maximum Degree of the Integrand**: The maximum degree of the polynomial to be integrated is given as $D = 2p$.\n\n2.  **Required Number of Quadrature Points**: We apply the exactness condition for Gauss-Legendre quadrature directly:\n    $$\n    2N_q - 1 \\ge 2p\n    $$\n    Solving for $N_q$:\n    $$\n    2N_q \\ge 2p+1 \\implies N_q \\ge p + \\frac{1}{2}\n    $$\n    Since $N_q$ must be an integer, the minimal number of points is the smallest integer greater than or equal to $p + 1/2$, which is:\n    $$\n    N_q = p+1\n    $$\nThis result corresponds to the standard requirement for exactly computing volume integrals such as the mass matrix term $\\int u_h v_h dx$ in DG methods, where the integrand is a product of two polynomials from $\\mathbb{P}_p$, resulting in a polynomial of degree at most $2p$.\n\nThe final answer is a two-entry row vector containing the results from Part 1 and Part 2.", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\left\\lceil \\frac{p(r+1)+1}{2} \\right\\rceil & p+1\n\\end{pmatrix}\n}\n$$", "id": "3395757"}, {"introduction": "While Legendre polynomial expansions offer exceptional accuracy for smooth functions, they exhibit poor convergence and non-physical oscillations near discontinuities—a phenomenon known as the Gibbs effect. Mitigating these oscillations is a central topic in the practical application of high-order methods. This computational problem [@problem_id:3395740] offers a direct, hands-on opportunity to quantify the Gibbs phenomenon for a step function and to implement and test the effectiveness of modal filtering, a widely used technique to restore stability and improve the quality of the solution.", "problem": "Consider the one-dimensional reference element on the interval $[-1,1]$ and the Legendre polynomial basis $\\{P_n(x)\\}_{n=0}^\\infty$ with the standard $L^2([-1,1])$ inner product and weight equal to $1$. Let the target function be the jump function $f(x)=\\operatorname{sign}(x)$, which takes the value $-1$ for $x&lt;0$ and $+1$ for $x\\ge 0$. The Legendre partial sum of degree $N$ is defined as the $L^2([-1,1])$ projection of $f(x)$ onto the space of polynomials of degree at most $N$, namely\n$$\nS_N(x)=\\sum_{n=0}^N a_n P_n(x),\n$$\nwhere the Legendre coefficients are defined by the orthogonality relation\n$$\na_n=\\frac{2n+1}{2}\\int_{-1}^1 f(x)\\,P_n(x)\\,dx.\n$$\nDefine a modal filter of order $s$ by the diagonal multiplier on the modal coefficients:\n$$\n\\sigma_n^{(s)}=\\exp\\!\\left(-\\alpha\\left(\\frac{n}{N}\\right)^s\\right),\\quad n=0,1,\\dots,N,\n$$\nwith fixed $\\alpha&gt;0$, and set the filtered partial sum as\n$$\nS_N^{(s)}(x)=\\sum_{n=0}^N \\big(\\sigma_n^{(s)} a_n\\big) P_n(x).\n$$\nAdopt the following quantitative measures to assess the Gibbs phenomenon and its mitigation by modal filtering:\n\n1. Overshoot amplitude near the jump at $x=0$: For a chosen window half-width $w\\in(0,1)$, define\n$$\n\\mathcal{O}(N,s;w)=\\max\\Big\\{\\,\\max_{x\\in[0,w]}\\big(S_N^{(s)}(x)-1\\big),\\ \\max_{x\\in[-w,0]}\\big(-S_N^{(s)}(x)-1\\big),\\ 0\\Big\\}.\n$$\nThis measures the maximum positive excursion beyond the local bounded values $\\pm 1$ within the window around the discontinuity.\n\n2. Discrete $L^1$ total variation of the approximation on a uniform grid of $M$ points on $[-1,1]$: For grid points $x_i=-1+\\frac{2i}{M-1}$ for $i=0,1,\\dots,M-1$ and corresponding values $u_i=S_N^{(s)}(x_i)$, define\n$$\n\\operatorname{TV}(N,s;M)=\\sum_{i=0}^{M-2} \\big|u_{i+1}-u_i\\big|.\n$$\n\nYour task is to write a complete, runnable program that:\n- Computes the Legendre coefficients $a_n$ for $f(x)=\\operatorname{sign}(x)$ using only the fundamental orthogonality definition of the $L^2$ projection and well-tested identities for Legendre polynomials.\n- Forms the filtered modal coefficients using the filter weights $\\sigma_n^{(s)}$.\n- Evaluates $S_N^{(s)}(x)$ at the grid points.\n- Computes the overshoot amplitude $\\mathcal{O}(N,s;w)$ and the discrete total variation $\\operatorname{TV}(N,s;M)$.\n\nScientific and algorithmic bases you may use:\n- Orthogonality of Legendre polynomials on $[-1,1]$ with weight $1$:\n$$\n\\int_{-1}^1 P_m(x)P_n(x)\\,dx=\\frac{2}{2n+1}\\delta_{mn}.\n$$\n- The $L^2$ projection definition for coefficients $a_n$ given above.\n- The fact that $f(x)=\\operatorname{sign}(x)$ is odd and that $P_n(x)$ has parity $(-1)^n$.\n- A well-tested antiderivative identity for Legendre polynomials:\n$$\n\\int P_n(x)\\,dx=\\frac{P_{n+1}(x)-P_{n-1}(x)}{2n+1}+C,\n$$\nwhich you may use to evaluate integrals of $P_n(x)$ on subintervals of $[-1,1]$.\n\nUse the following fixed parameters for all computations unless varied as part of the test suite:\n- Filter strength $\\alpha=36$.\n- Window half-width $w=0.2$.\n- Uniform grid size $M=10001$ points on $[-1,1]$.\n\nTest suite:\nCompute and report results for the following $(N,s)$ pairs, in the order listed:\n1. $(N,s)=(16,0)$ interpreted as no filtering, i.e., $\\sigma_n^{(0)}\\equiv 1$ for all $n$.\n2. $(N,s)=(16,4)$.\n3. $(N,s)=(16,8)$.\n4. $(N,s)=(32,0)$ interpreted as no filtering as above.\n5. $(N,s)=(32,8)$.\n6. $(N,s)=(64,16)$.\n\nFor each test case, your program must compute the two numbers $\\mathcal{O}(N,s;w)$ and $\\operatorname{TV}(N,s;M)$. The final output format must be a single line containing a comma-separated list of results for all test cases in a single outer bracket, where each test case result is a two-entry list in the order $[\\mathcal{O}(N,s;w),\\operatorname{TV}(N,s;M)]$. For example, the output format must be\n$$\n[\\,[o_1,t_1],[o_2,t_2],\\dots,[o_6,t_6]\\,],\n$$\nwhere each $o_j$ and $t_j$ is a floating-point number. No other text should be printed.\n\nThere are no physical units, and no angles are involved in this problem. All numeric answers must be reported as floating-point numbers without any percentage symbols.", "solution": "The user requests a numerical solution to analyze the mitigation of the Gibbs phenomenon in Legendre polynomial approximations. The problem is well-posed and scientifically sound, grounded in the principles of numerical analysis and approximation theory. We will proceed by first deriving the necessary analytical expressions and then outlining the computational algorithm.\n\n### 1. Calculation of Legendre Coefficients\n\nThe target function is the sign function, $f(x) = \\operatorname{sign}(x)$, defined on the interval $[-1, 1]$. We seek its expansion in the basis of Legendre polynomials, $\\{P_n(x)\\}_{n=0}^\\infty$. The Legendre partial sum of degree $N$ is given by\n$$\nS_N(x) = \\sum_{n=0}^N a_n P_n(x)\n$$\nwhere the coefficients $a_n$ are determined by the $L^2([-1,1])$ projection:\n$$\na_n = \\frac{\\langle f, P_n \\rangle}{\\langle P_n, P_n \\rangle} = \\frac{\\int_{-1}^1 f(x) P_n(x) \\,dx}{\\int_{-1}^1 P_n(x)^2 \\,dx} = \\frac{2n+1}{2} \\int_{-1}^1 f(x) P_n(x) \\,dx.\n$$\nThe function $f(x) = \\operatorname{sign}(x)$ is an odd function, meaning $f(-x) = -f(x)$. Legendre polynomials $P_n(x)$ have a definite parity: $P_n(-x) = (-1)^n P_n(x)$.\nThe product $f(x) P_n(x)$ is therefore an odd function if $n$ is even, and an even function if $n$ is odd.\nThe integral of an odd function over the symmetric interval $[-1, 1]$ is zero. Thus, for even $n$:\n$$\na_n = \\frac{2n+1}{2} \\int_{-1}^1 \\underbrace{f(x) P_n(x)}_{\\text{odd function}} \\,dx = 0.\n$$\nFor odd $n$, the integrand is even, so the integral becomes:\n$$\na_n = \\frac{2n+1}{2} \\cdot 2 \\int_0^1 f(x) P_n(x) \\,dx = (2n+1) \\int_0^1 (1) \\cdot P_n(x) \\,dx.\n$$\nWe use the provided antiderivative identity:\n$$\n\\int P_n(x) \\,dx = \\frac{P_{n+1}(x) - P_{n-1}(x)}{2n+1} + C.\n$$\nEvaluating the definite integral from $0$ to $1$:\n$$\n\\int_0^1 P_n(x) \\,dx = \\left[ \\frac{P_{n+1}(x) - P_{n-1}(x)}{2n+1} \\right]_0^1 = \\frac{(P_{n+1}(1) - P_{n-1}(1)) - (P_{n+1}(0) - P_{n-1}(0))}{2n+1}.\n$$\nUsing the standard property $P_k(1) = 1$ for all integers $k \\ge 0$, the first term $(P_{n+1}(1) - P_{n-1}(1)) = (1 - 1) = 0$. This simplifies the integral to:\n$$\n\\int_0^1 P_n(x) \\,dx = -\\frac{P_{n+1}(0) - P_{n-1}(0)}{2n+1} = \\frac{P_{n-1}(0) - P_{n+1}(0)}{2n+1}.\n$$\nSubstituting this back into the expression for $a_n$ for odd $n$:\n$$\na_n = (2n+1) \\left( \\frac{P_{n-1}(0) - P_{n+1}(0)}{2n+1} \\right) = P_{n-1}(0) - P_{n+1}(0).\n$$\nSince $n$ is odd, both $n-1$ and $n+1$ are even. The values of $P_k(0)$ for even $k$ are non-zero and can be computed reliably using standard library functions, such as `scipy.special.eval_legendre`.\n\nIn summary, the Legendre coefficients are:\n$$\na_n = \\begin{cases}\n0 & \\text{if } n \\text{ is even} \\\\\nP_{n-1}(0) - P_{n+1}(0) & \\text{if } n \\text{ is odd}\n\\end{cases}\n$$\n\n### 2. Modal Filtering and Filtered Sum\n\nThe Gibbs phenomenon manifests as persistent oscillations and overshoot near the discontinuity at $x=0$. To mitigate this, a modal filter is applied to the coefficients. The filter is defined by the weights:\n$$\n\\sigma_n^{(s)} = \\exp\\left(-\\alpha\\left(\\frac{n}{N}\\right)^s\\right), \\quad n=0, 1, \\dots, N.\n$$\nHere, $s$ is the order of the filter, controlling the shape of the decay, and $\\alpha$ is the filter strength. Higher-order modes (large $n$) are more strongly attenuated. For the test case where $s=0$, the problem specifies this corresponds to no filtering, i.e., $\\sigma_n^{(0)} \\equiv 1$ for all $n$.\n\nThe filtered partial sum $S_N^{(s)}(x)$ is constructed using the filtered coefficients $b_n = \\sigma_n^{(s)} a_n$:\n$$\nS_N^{(s)}(x) = \\sum_{n=0}^N b_n P_n(x) = \\sum_{n=0}^N \\left(\\sigma_n^{(s)} a_n\\right) P_n(x).\n$$\n\n### 3. Numerical Evaluation and Metrics\n\nThe analysis requires evaluating $S_N^{(s)}(x)$ and computing two quantitative metrics.\n\n**Evaluation:** The sum $S_N^{(s)}(x)$ is evaluated on a fine uniform grid of $M=10001$ points, $x_i = -1 + \\frac{2i}{M-1}$ for $i=0, \\dots, M-1$. Let $u_i = S_N^{(s)}(x_i)$. This evaluation is efficiently performed using a matrix-vector product. Let $\\mathbf{b}$ be the column vector of filtered coefficients $[b_0, b_1, \\dots, b_N]^T$ and $\\mathbf{V}$ be a Vandermonde-like matrix with entries $V_{in} = P_n(x_i)$. The vector of values $\\mathbf{u} = [u_0, u_1, \\dots, u_{M-1}]^T$ is then given by $\\mathbf{u} = \\mathbf{V} \\mathbf{b}$.\n\n**Overshoot Amplitude $\\mathcal{O}(N,s;w)$:** This metric quantifies the maximum overshoot near the jump at $x=0$ within a window $[-w, w]$, where $w=0.2$. It is defined as:\n$$\n\\mathcal{O}(N,s;w) = \\max\\Big\\{\\,\\max_{x\\in[0,w]}\\big(S_N^{(s)}(x)-1\\big),\\ \\max_{x\\in[-w,0]}\\big(-S_N^{(s)}(x)-1\\big),\\ 0\\Big\\}.\n$$\nNumerically, this is computed by finding the maximum values of $(u_i-1)$ for grid points $x_i \\in [0, w]$ and $(-u_i-1)$ for $x_i \\in [-w, 0]$, and taking the maximum of these two values and $0$.\n\n**Total Variation $\\operatorname{TV}(N,s;M)$:** This metric measures the total oscillation of the approximation over the entire domain. The discrete total variation is:\n$$\n\\operatorname{TV}(N,s;M)=\\sum_{i=0}^{M-2} \\big|u_{i+1}-u_i\\big|.\n$$\nAn ideal step function from $-1$ to $+1$ has a total variation of $2$. The Gibbs phenomenon introduces spurious oscillations, which increase the TV. A successful filter will reduce the TV, bringing it closer to $2$. This is computed by summing the absolute differences of consecutive elements in the array of values $\\mathbf{u}$.\n\n### 4. Algorithmic Implementation\n\nThe overall algorithm proceeds as follows:\n1.  Set the global parameters $\\alpha=36$, $w=0.2$, and $M=10001$.\n2.  Determine the maximum polynomial degree $N_{max}$ from the test suite (which is $64$).\n3.  Pre-compute the Legendre coefficients $a_n$ for $n=0, \\dots, N_{max}$ using the derived formula.\n4.  Create the uniform evaluation grid $x_i$ on $[-1, 1]$.\n5.  Iterate through each $(N, s)$ pair in the test suite:\n    a.  Extract the required coefficients $a_0, \\dots, a_N$.\n    b.  Compute the filter weights $\\sigma_n^{(s)}$ for $n=0, \\dots, N$.\n    c.  Calculate the filtered coefficients $b_n = \\sigma_n^{(s)} a_n$.\n    d.  Evaluate the filtered sum $S_N^{(s)}(x)$ at all grid points $x_i$ to get the values $u_i$.\n    e.  Compute the overshoot $\\mathcal{O}(N,s;w)$ from the values $u_i$ in the specified window.\n    f.  Compute the total variation $\\operatorname{TV}(N,s;M)$ from all values $u_i$.\n    g.  Store the resulting pair $[\\mathcal{O}, \\operatorname{TV}]$.\n6.  Format the list of all result pairs into the required single-line string format.\n\nThis structured approach ensures correctness by separating the analytical derivation from the numerical implementation, which itself is designed for efficiency and accuracy.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import eval_legendre\n\ndef solve():\n    \"\"\"\n    Computes overshoot and total variation for filtered Legendre series approximations\n    of a step function, demonstrating Gibbs phenomenon mitigation.\n    \"\"\"\n    # Define fixed parameters from the problem statement.\n    alpha = 36.0\n    w = 0.2\n    M = 10001\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (16, 0),  # No filtering\n        (16, 4),\n        (16, 8),\n        (32, 0),  # No filtering\n        (32, 8),\n        (64, 16),\n    ]\n\n    # --- Step 1: Pre-compute Legendre coefficients a_n for f(x) = sign(x) ---\n    max_N = max(N for N, s in test_cases)\n\n    def compute_an(n):\n        \"\"\"\n        Computes the n-th Legendre coefficient for f(x) = sign(x).\n        \"\"\"\n        # For even n, the integral of an odd function (sign(x)*P_n(x)) is 0.\n        if n % 2 == 0:\n            return 0.0\n        # For odd n, a_n = P_{n-1}(0) - P_{n+1}(0).\n        # We use scipy's well-tested function for evaluating Legendre polynomials.\n        p_n_minus_1_at_0 = eval_legendre(n - 1, 0)\n        p_n_plus_1_at_0 = eval_legendre(n + 1, 0)\n        return p_n_minus_1_at_0 - p_n_plus_1_at_0\n\n    a_coeffs = np.array([compute_an(n) for n in range(max_N + 1)])\n\n    # --- Step 2: Set up the evaluation grid ---\n    x_grid = np.linspace(-1.0, 1.0, M)\n\n    # Determine indices for the overshoot calculation window [-w, w]\n    center_idx = (M - 1) // 2\n    # Number of grid points from the center to the window edge\n    w_pts = int(w * (M - 1) / 2)\n    idx_w_neg = center_idx - w_pts\n    idx_w_pos = center_idx + w_pts\n\n    results = []\n    \n    # --- Loop through each test case ---\n    for N, s in test_cases:\n        # --- Step 3: Form filtered modal coefficients ---\n        a_N = a_coeffs[:N + 1]\n        \n        # The case s=0 is explicitly defined as \"no filtering\".\n        if s == 0:\n            sigma = np.ones(N + 1)\n        else:\n            n_vals = np.arange(N + 1)\n            sigma = np.exp(-alpha * (n_vals / N)**s)\n        \n        b_coeffs = a_N * sigma\n        \n        # --- Step 4: Evaluate the filtered sum S_N^{(s)}(x) on the grid ---\n        n_range = np.arange(N + 1)\n        # Create a Vandermonde-like matrix where V[i, j] = P_j(x_i)\n        # Shape: (M, N+1)\n        leg_matrix = eval_legendre(n_range, x_grid[:, None])\n        # u_vals[i] = S_N^{(s)}(x_i), shape (M,)\n        u_vals = leg_matrix.dot(b_coeffs)\n\n        # --- Step 5: Compute the overshoot amplitude O ---\n        # Window for x in [0, w]\n        u_pos_window = u_vals[center_idx : idx_w_pos + 1]\n        # Window for x in [-w, 0]\n        u_neg_window = u_vals[idx_w_neg : center_idx + 1]\n        \n        # Max excursion beyond +1 in the positive window\n        overshoot_pos = np.max(u_pos_window - 1.0)\n        # Max excursion beyond -1 in the negative window\n        overshoot_neg = np.max(-u_neg_window - 1.0)\n        \n        O = np.max([overshoot_pos, overshoot_neg, 0.0])\n        \n        # --- Step 6: Compute the discrete total variation TV ---\n        TV = np.sum(np.abs(np.diff(u_vals)))\n        \n        results.append([O, TV])\n        \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(str(res) for res in results)}]\")\n\nsolve()\n```", "id": "3395740"}]}