{"hands_on_practices": [{"introduction": "Before delving into advanced applications, it is crucial to master the fundamental mechanics of the Discrete Wavelet Transform (DWT). This exercise provides a concrete, step-by-step calculation of a two-level DWT using the Haar basis on a simple piecewise-constant signal. By performing the core operations of filtering and downsampling by hand, you will gain a tangible understanding of how approximation and detail coefficients are generated and how this process leads to a sparse representation [@problem_id:3493857].", "problem": "Consider a real-valued length-$16$ discrete-time signal $x[n]$ defined for $n \\in \\{0,1,\\dots,15\\}$ by the sequence\n$$\nx = \\left[5,\\,5,\\,5,\\,5,\\,2,\\,2,\\,2,\\,2,\\,0,\\,0,\\,8,\\,8,\\,8,\\,8,\\,8,\\,8\\right].\n$$\nLet the analysis filters for the orthonormal two-channel filter bank be specified as the Haar filters\n$$\nh = \\left[\\frac{1}{\\sqrt{2}},\\,\\frac{1}{\\sqrt{2}}\\right], \\qquad g = \\left[\\frac{1}{\\sqrt{2}},\\, -\\frac{1}{\\sqrt{2}}\\right],\n$$\nand use symmetric boundary extension where needed. Perform two levels of the Discrete Wavelet Transform (DWT), defined as follows: the level-$1$ approximation and detail coefficients are\n$$\na_{1}[n] = h_{0}\\,x[2n] + h_{1}\\,x[2n+1], \\qquad d_{1}[n] = g_{0}\\,x[2n] + g_{1}\\,x[2n+1],\n$$\nfor $n = 0,1,\\dots,7$. The level-$2$ coefficients are obtained by applying the same $h$ and $g$ to the level-$1$ approximation $a_{1}$:\n$$\na_{2}[n] = h_{0}\\,a_{1}[2n] + h_{1}\\,a_{1}[2n+1], \\qquad d_{2}[n] = g_{0}\\,a_{1}[2n] + g_{1}\\,a_{1}[2n+1],\n$$\nfor $n = 0,1,2,3$.\n\nCarry out these computations and report the three subband coefficient vectors $a_{2}$, $d_{2}$, and $d_{1}$. Finally, compute the total energy of the level-$2$ detail subband,\n$$\nE_{d_{2}} = \\sum_{n=0}^{3} \\left(d_{2}[n]\\right)^{2},\n$$\nand provide this value as the final answer. Express the final answer as a real number with no rounding.", "solution": "The problem requires the computation of a two-level Discrete Wavelet Transform (DWT) of a given discrete-time signal $x[n]$ and subsequently the energy of the level-$2$ detail coefficients. The signal is of length $N=16$ and given by the sequence:\n$$x = \\left[5,\\,5,\\,5,\\,5,\\,2,\\,2,\\,2,\\,2,\\,0,\\,0,\\,8,\\,8,\\,8,\\,8,\\,8,\\,8\\right]$$\nThe analysis filters for the orthonormal Haar wavelet transform are the low-pass filter $h$ and the high-pass filter $g$:\n$$h = \\left[\\frac{1}{\\sqrt{2}},\\,\\frac{1}{\\sqrt{2}}\\right] \\quad \\implies \\quad h_0 = \\frac{1}{\\sqrt{2}}, h_1 = \\frac{1}{\\sqrt{2}}$$\n$$g = \\left[\\frac{1}{\\sqrt{2}},\\, -\\frac{1}{\\sqrt{2}}\\right] \\quad \\implies \\quad g_0 = \\frac{1}{\\sqrt{2}}, g_1 = -\\frac{1}{\\sqrt{2}}$$\nThe problem specifies that boundary effects are handled by symmetric extension, but given the filter length of $2$ and the signal length being a power of two, no extension is required for this specific calculation.\n\nFirst, we compute the level-$1$ approximation coefficients $a_1[n]$ and detail coefficients $d_1[n]$ for $n \\in \\{0, 1, \\dots, 7\\}$. The governing equations are:\n$$a_{1}[n] = h_{0}\\,x[2n] + h_{1}\\,x[2n+1] = \\frac{1}{\\sqrt{2}}(x[2n] + x[2n+1])$$\n$$d_{1}[n] = g_{0}\\,x[2n] + g_{1}\\,x[2n+1] = \\frac{1}{\\sqrt{2}}(x[2n] - x[2n+1])$$\nWe compute each coefficient as follows:\n$a_1[0] = \\frac{1}{\\sqrt{2}}(x[0]+x[1]) = \\frac{1}{\\sqrt{2}}(5+5) = \\frac{10}{\\sqrt{2}} = 5\\sqrt{2}$\n$d_1[0] = \\frac{1}{\\sqrt{2}}(x[0]-x[1]) = \\frac{1}{\\sqrt{2}}(5-5) = 0$\n$a_1[1] = \\frac{1}{\\sqrt{2}}(x[2]+x[3]) = \\frac{1}{\\sqrt{2}}(5+5) = \\frac{10}{\\sqrt{2}} = 5\\sqrt{2}$\n$d_1[1] = \\frac{1}{\\sqrt{2}}(x[2]-x[3]) = \\frac{1}{\\sqrt{2}}(5-5) = 0$\n$a_1[2] = \\frac{1}{\\sqrt{2}}(x[4]+x[5]) = \\frac{1}{\\sqrt{2}}(2+2) = \\frac{4}{\\sqrt{2}} = 2\\sqrt{2}$\n$d_1[2] = \\frac{1}{\\sqrt{2}}(x[4]-x[5]) = \\frac{1}{\\sqrt{2}}(2-2) = 0$\n$a_1[3] = \\frac{1}{\\sqrt{2}}(x[6]+x[7]) = \\frac{1}{\\sqrt{2}}(2+2) = \\frac{4}{\\sqrt{2}} = 2\\sqrt{2}$\n$d_1[3] = \\frac{1}{\\sqrt{2}}(x[6]-x[7]) = \\frac{1}{\\sqrt{2}}(2-2) = 0$\n$a_1[4] = \\frac{1}{\\sqrt{2}}(x[8]+x[9]) = \\frac{1}{\\sqrt{2}}(0+0) = 0$\n$d_1[4] = \\frac{1}{\\sqrt{2}}(x[8]-x[9]) = \\frac{1}{\\sqrt{2}}(0-0) = 0$\n$a_1[5] = \\frac{1}{\\sqrt{2}}(x[10]+x[11]) = \\frac{1}{\\sqrt{2}}(8+8) = \\frac{16}{\\sqrt{2}} = 8\\sqrt{2}$\n$d_1[5] = \\frac{1}{\\sqrt{2}}(x[10]-x[11]) = \\frac{1}{\\sqrt{2}}(8-8) = 0$\n$a_1[6] = \\frac{1}{\\sqrt{2}}(x[12]+x[13]) = \\frac{1}{\\sqrt{2}}(8+8) = \\frac{16}{\\sqrt{2}} = 8\\sqrt{2}$\n$d_1[6] = \\frac{1}{\\sqrt{2}}(x[12]-x[13]) = \\frac{1}{\\sqrt{2}}(8-8) = 0$\n$a_1[7] = \\frac{1}{\\sqrt{2}}(x[14]+x[15]) = \\frac{1}{\\sqrt{2}}(8+8) = \\frac{16}{\\sqrt{2}} = 8\\sqrt{2}$\n$d_1[7] = \\frac{1}{\\sqrt{2}}(x[14]-x[15]) = \\frac{1}{\\sqrt{2}}(8-8) = 0$\n\nThe resulting level-$1$ coefficient vectors are:\n$$a_1 = \\left[5\\sqrt{2},\\, 5\\sqrt{2},\\, 2\\sqrt{2},\\, 2\\sqrt{2},\\, 0,\\, 8\\sqrt{2},\\, 8\\sqrt{2},\\, 8\\sqrt{2}\\right]$$\n$$d_1 = \\left[0,\\, 0,\\, 0,\\, 0,\\, 0,\\, 0,\\, 0,\\, 0\\right]$$\n\nNext, we compute the level-$2$ coefficients by applying the same filters to the level-$1$ approximation vector $a_1$. The level-$2$ approximation coefficients $a_2[n]$ and detail coefficients $d_2[n]$ are computed for $n \\in \\{0, 1, 2, 3\\}$:\n$$a_{2}[n] = h_{0}\\,a_{1}[2n] + h_{1}\\,a_{1}[2n+1] = \\frac{1}{\\sqrt{2}}(a_{1}[2n] + a_{1}[2n+1])$$\n$$d_{2}[n] = g_{0}\\,a_{1}[2n] + g_{1}\\,a_{1}[2n+1] = \\frac{1}{\\sqrt{2}}(a_{1}[2n] - a_{1}[2n+1])$$\nWe compute each coefficient:\n$a_2[0] = \\frac{1}{\\sqrt{2}}(a_1[0]+a_1[1]) = \\frac{1}{\\sqrt{2}}(5\\sqrt{2}+5\\sqrt{2}) = \\frac{1}{\\sqrt{2}}(10\\sqrt{2}) = 10$\n$d_2[0] = \\frac{1}{\\sqrt{2}}(a_1[0]-a_1[1]) = \\frac{1}{\\sqrt{2}}(5\\sqrt{2}-5\\sqrt{2}) = 0$\n$a_2[1] = \\frac{1}{\\sqrt{2}}(a_1[2]+a_1[3]) = \\frac{1}{\\sqrt{2}}(2\\sqrt{2}+2\\sqrt{2}) = \\frac{1}{\\sqrt{2}}(4\\sqrt{2}) = 4$\n$d_2[1] = \\frac{1}{\\sqrt{2}}(a_1[2]-a_1[3]) = \\frac{1}{\\sqrt{2}}(2\\sqrt{2}-2\\sqrt{2}) = 0$\n$a_2[2] = \\frac{1}{\\sqrt{2}}(a_1[4]+a_1[5]) = \\frac{1}{\\sqrt{2}}(0+8\\sqrt{2}) = \\frac{1}{\\sqrt{2}}(8\\sqrt{2}) = 8$\n$d_2[2] = \\frac{1}{\\sqrt{2}}(a_1[4]-a_1[5]) = \\frac{1}{\\sqrt{2}}(0-8\\sqrt{2}) = -8$\n$a_2[3] = \\frac{1}{\\sqrt{2}}(a_1[6]+a_1[7]) = \\frac{1}{\\sqrt{2}}(8\\sqrt{2}+8\\sqrt{2}) = \\frac{1}{\\sqrt{2}}(16\\sqrt{2}) = 16$\n$d_2[3] = \\frac{1}{\\sqrt{2}}(a_1[6]-a_1[7]) = \\frac{1}{\\sqrt{2}}(8\\sqrt{2}-8\\sqrt{2}) = 0$\n\nThe computed subband coefficient vectors as requested are:\n$$a_2 = \\left[10,\\, 4,\\, 8,\\, 16\\right]$$\n$$d_2 = \\left[0,\\, 0,\\, -8,\\, 0\\right]$$\n$$d_1 = \\left[0,\\, 0,\\, 0,\\, 0,\\, 0,\\, 0,\\, 0,\\, 0\\right]$$\n\nFinally, we compute the total energy of the level-$2$ detail subband, $E_{d_{2}}$:\n$$E_{d_{2}} = \\sum_{n=0}^{3} \\left(d_{2}[n]\\right)^{2}$$\nSubstituting the values from the $d_2$ vector:\n$$E_{d_{2}} = (0)^{2} + (0)^{2} + (-8)^{2} + (0)^{2} = 0 + 0 + 64 + 0 = 64$$\nThe energy of the level-$2$ detail subband is $64$.", "answer": "$$\\boxed{64}$$", "id": "3493857"}, {"introduction": "A key property for sparse signal processing and compressed sensing is the 'incoherence' between the sensing basis and the sparsity basis. This computational exercise tasks you with numerically constructing two fundamental orthonormal bases—the Discrete Fourier Transform ($F$) and the Haar DWT ($W$)—to quantify their mutual coherence. This practice bridges theory and implementation, revealing the relationship between a basis localized in frequency (DFT) and one localized in time and scale (wavelets) [@problem_id:3493805].", "problem": "You are given an integer $n$ such that $n = 2^J$ for some integer $J \\geq 1$. Let $F \\in \\mathbb{C}^{n \\times n}$ denote the unitary Discrete Fourier Transform (DFT) matrix and let $W \\in \\mathbb{R}^{n \\times n}$ denote the orthonormal Haar Discrete Wavelet Transform (DWT) matrix. Your task is to numerically construct $F$ and $W$ from first principles, compute the empirical mutual coherence between these two orthonormal bases, and characterize how the coherence values distribute across Haar wavelet scales.\n\nFundamental definitions to use as the starting point:\n- The unitary Discrete Fourier Transform (DFT) matrix $F$ has entries\n$$\nF_{t,k} = \\frac{1}{\\sqrt{n}} \\exp\\left(2\\pi i \\frac{t k}{n}\\right),\n\\quad t \\in \\{0,1,\\dots,n-1\\},\\ k \\in \\{0,1,\\dots,n-1\\}.\n$$\n- The orthonormal Haar Discrete Wavelet Transform (DWT) matrix $W$ consists of $n$ orthonormal column vectors. One column is the scaling vector $\\phi \\in \\mathbb{R}^n$ with entries $\\phi[t] = \\frac{1}{\\sqrt{n}}$ for all $t$. For each scale $s \\in \\{1,2,\\dots,J\\}$ with support length $L_s = 2^s$, there are $n / L_s$ wavelet atoms $\\{\\psi_{s,k}\\}_{k=0}^{n/L_s - 1}$, where each $\\psi_{s,k} \\in \\mathbb{R}^n$ is defined by\n$$\n\\psi_{s,k}[t] =\n\\begin{cases}\n+\\frac{1}{\\sqrt{L_s}}, & t \\in \\{k L_s, k L_s + 1, \\dots, k L_s + \\frac{L_s}{2} - 1\\}, \\\\\n-\\frac{1}{\\sqrt{L_s}}, & t \\in \\{k L_s + \\frac{L_s}{2}, k L_s + \\frac{L_s}{2}+1, \\dots, (k+1)L_s - 1\\}, \\\\\n0, & \\text{otherwise}.\n\\end{cases}\n$$\nThese vectors are orthonormal under the standard Euclidean inner product, and together with $\\phi$ form a complete orthonormal basis of $\\mathbb{R}^n$.\n\nDefinitions of quantities to compute:\n- The mutual coherence between two orthonormal bases $U, V \\in \\mathbb{C}^{n \\times n}$ with columns $\\{u_i\\}$ and $\\{v_j\\}$ is\n$$\n\\mu(U,V) = \\max_{1 \\leq i,j \\leq n} \\left| \\langle u_i, v_j \\rangle \\right|.\n$$\n- Let $C = F^* W \\in \\mathbb{C}^{n \\times n}$, where $F^*$ denotes the conjugate transpose of $F$. The matrix $C$ collects all pairwise inner products $\\langle f_i, w_j \\rangle$. The empirical mutual coherence is then\n$$\n\\hat{\\mu} = \\max_{i,j} |C_{i,j}|.\n$$\n- For a Haar wavelet scale $s \\in \\{1,2,\\dots,J\\}$, define the set $\\mathcal{J}_s$ of column indices of $W$ corresponding to wavelet atoms at scale $s$. Also define $\\mathcal{J}_0$ as the singleton containing the index of the scaling vector $\\phi$. For each column $j \\in \\mathcal{J}_s$, define its empirical coherence with the DFT basis as\n$$\n\\gamma_j = \\max_{1 \\leq i \\leq n} |C_{i,j}|.\n$$\nThis yields a per-scale collection $\\{\\gamma_j : j \\in \\mathcal{J}_s\\}$, whose distribution at scale $s$ can be summarized by its mean and maximum.\n\nProgram tasks:\n1. From the above definitions, construct $F$ and $W$ numerically for a given $n$.\n2. Verify numerically that $F$ and $W$ are unitary/orthonormal by checking that $F^* F \\approx I_n$ and $W^\\top W \\approx I_n$, where $I_n$ is the $n \\times n$ identity matrix.\n3. Compute $C = F^* W$ and the empirical mutual coherence $\\hat{\\mu} = \\max_{i,j} |C_{i,j}|$.\n4. For each scale $s \\in \\{0,1,2,\\dots,J\\}$, compute the set $\\{\\gamma_j : j \\in \\mathcal{J}_s\\}$, and summarize it by its mean and its maximum.\n5. Numerical stability and normalization: ensure that $F$ is exactly unitary and that the Haar atoms are exactly normalized as specified. All inner products are taken with respect to the standard complex Euclidean inner product.\n6. Test suite and coverage:\n   - Use the test suite $n \\in \\{2, 8, 32\\}$ to cover an extreme small case where bases can coincide, a small multiscale case, and a moderate multiscale case.\n7. Output specification:\n   - For each $n$ in the test suite, produce a list with four items: the integer $n$, the float $\\hat{\\mu}$, the list of per-scale means $[\\text{mean}_s]_{s=0}^J$, and the list of per-scale maxima $[\\text{max}_s]_{s=0}^J$, where scale $s=0$ denotes the scaling vector and scales $s=1,\\dots,J$ denote wavelet scales ordered from finest to coarsest.\n   - Round all floating-point values to $12$ decimal places before output.\n   - Your program should produce a single line of output containing the results for the three test cases as a comma-separated list enclosed in square brackets. Concretely, the final output must be a single list of length $3$, where each element is the per-$n$ list described above, e.g., $[\\text{case}_1, \\text{case}_2, \\text{case}_3]$.\n   - No physical units or angles are involved; all outputs are dimensionless real numbers.", "solution": "The user-provided problem is assessed as **valid**. It is scientifically grounded in the principles of Fourier and wavelet analysis, is well-posed with clear and consistent definitions, and is objective in its formulation. The task is to numerically implement and analyze the relationship between two fundamental orthonormal bases in signal processing.\n\nThe core of the problem is to quantify the \"incoherence\" between the Discrete Fourier Transform (DFT) basis, whose elements are perfectly localized in frequency, and the Haar wavelet basis, whose elements have varying degrees of localization in both time and scale. The mutual coherence serves as a measure of the maximum possible similarity between an element from one basis and an element from the other. A low mutual coherence is a desirable property in fields like compressed sensing, as it guarantees that a signal sparse in one basis will appear as a dense, spread-out signal in the other, enabling robust recovery from few measurements.\n\nThe solution proceeds in several steps:\n1.  Construction of the DFT matrix $F$ and the Haar DWT matrix $W$.\n2.  Computation of the change-of-basis matrix $C = F^*W$.\n3.  Calculation of the overall empirical mutual coherence $\\hat{\\mu}$.\n4.  Per-scale analysis of coherence values.\n\n**1. Construction of the Orthonormal Bases**\n\nGiven an integer $n=2^J$ for some $J \\geq 1$, we construct two $n \\times n$ matrices whose columns form orthonormal bases for $\\mathbb{C}^n$.\n\n**Discrete Fourier Transform (DFT) Matrix, $F$**\nThe DFT matrix $F \\in \\mathbb{C}^{n \\times n}$ is defined by its entries, which correspond to complex sinusoids at different frequencies. The entry in row $t$ and column $k$ is given by:\n$$\nF_{t,k} = \\frac{1}{\\sqrt{n}} \\exp\\left(2\\pi i \\frac{t k}{n}\\right), \\quad t, k \\in \\{0, 1, \\dots, n-1\\}\n$$\nThe columns of $F$, denoted $\\{f_k\\}_{k=0}^{n-1}$, form an orthonormal basis of $\\mathbb{C}^n$. This matrix is unitary, satisfying $F^* F = F F^* = I_n$, where $F^*$ is the conjugate transpose of $F$ and $I_n$ is the $n \\times n$ identity matrix.\n\n**Haar Discrete Wavelet Transform (DWT) Matrix, $W$**\nThe Haar DWT matrix $W \\in \\mathbb{R}^{n \\times n}$ is composed of real-valued, piecewise constant basis vectors. Its columns form an orthonormal basis for $\\mathbb{R}^n$ (and thus also for $\\mathbb{C}^n$). The basis consists of one scaling vector and $n-1$ wavelet vectors organized by scale.\n\n- **Scaling Vector ($\\phi$):** This vector represents the coarsest possible information (the signal's average). It is the first column of our matrix $W$ and corresponds to a \"scale\" we designate as $s=0$:\n$$\n\\phi[t] = \\frac{1}{\\sqrt{n}} \\quad \\text{for } t \\in \\{0, 1, \\dots, n-1\\}\n$$\n\n- **Wavelet Vectors ($\\psi_{s,k}$):** These vectors capture details at different scales and locations. For each scale $s \\in \\{1, 2, \\dots, J\\}$, the support length of the wavelet is $L_s = 2^s$. At each scale $s$, there are $n/L_s$ wavelets, indexed by a translation parameter $k \\in \\{0, 1, \\dots, n/L_s - 1\\}$. The wavelet $\\psi_{s,k}$ is defined as:\n$$\n\\psi_{s,k}[t] =\n\\begin{cases}\n+\\frac{1}{\\sqrt{L_s}}, & \\text{for } t \\in \\{k L_s, \\dots, k L_s + \\frac{L_s}{2} - 1\\} \\\\\n-\\frac{1}{\\sqrt{L_s}}, & \\text{for } t \\in \\{k L_s + \\frac{L_s}{2}, \\dots, (k+1)L_s - 1\\} \\\\\n0, & \\text{otherwise}\n\\end{cases}\n$$\nThe matrix $W$ is constructed by assembling these vectors as its columns. We adopt the ordering where the first column is the scaling vector $\\phi$. This is followed by all wavelet vectors for scale $s=1$ (finest detail, shortest support $L_1=2$), then all for scale $s=2$, and so on, up to the single wavelet for scale $s=J$ (coarsest detail, longest support $L_J=n$). This collection of $1 + \\sum_{s=1}^{J} (n/L_s) = 1 + (n-1) = n$ vectors is orthonormal, so $W^\\top W = I_n$.\n\n**2. Mutual Coherence Calculation**\n\nThe relationship between the two bases is captured by the matrix $C = F^*W$. Each entry $C_{i,j}$ of this matrix is the inner product between the $i$-th DFT basis vector and the $j$-th Haar basis vector:\n$$\nC_{i,j} = \\langle f_i, w_j \\rangle\n$$\nwhere $\\{f_i\\}$ are columns of $F$ and $\\{w_j\\}$ are columns of $W$.\n\nThe **empirical mutual coherence**, $\\hat{\\mu}$, is the maximum absolute value of any inner product between vectors from the two bases. It measures the largest possible projection of a vector from one basis onto a vector from the other.\n$$\n\\hat{\\mu} = \\mu(F, W) = \\max_{0 \\leq i,j < n} |\\langle f_i, w_j \\rangle| = \\max_{i,j} |C_{i,j}|\n$$\n\n**3. Per-Scale Coherence Analysis**\n\nTo understand how coherence is distributed across different Haar scales, we analyze the columns of $C$ corresponding to each scale.\nLet $\\mathcal{J}_s$ be the set of column indices in $W$ (and hence in $C$) corresponding to basis vectors at scale $s$. $\\mathcal{J}_0 = \\{0\\}$ for the scaling vector $\\phi$, and for $s \\in \\{1, \\dots, J\\}$, $\\mathcal{J}_s$ contains the indices for all $\\{\\psi_{s,k}\\}$.\n\nFor each Haar basis vector $w_j$, its individual coherence with the entire DFT basis is defined as:\n$$\n\\gamma_j = \\max_{0 \\leq i < n} |C_{i,j}|\n$$\nThis value represents the maximum similarity of the specific Haar vector $w_j$ to any of the Fourier basis vectors.\n\nWe then summarize the behavior at each scale $s \\in \\{0, 1, \\dots, J\\}$ by computing two statistics over the set of coherence values $\\{\\gamma_j : j \\in \\mathcal{J}_s\\}$:\n- The mean coherence at scale $s$: $\\text{mean}_s = \\frac{1}{|\\mathcal{J}_s|} \\sum_{j \\in \\mathcal{J}_s} \\gamma_j$\n- The maximum coherence at scale $s$: $\\text{max}_s = \\max_{j \\in \\mathcal{J}_s} \\gamma_j$\n\nThe final algorithm implements these constructions and calculations for the specified values of $n$, rounding the floating-point results to $12$ decimal places as required for the output. For $n=2$, the DFT and Haar bases coincide, leading to a coherence of $1$. For larger $n$, the bases are distinct and the coherence is less than $1$, exhibiting a structured distribution across the scales.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs DFT and Haar DWT matrices and computes their mutual coherence.\n    \"\"\"\n    test_cases = [2, 8, 32]\n    all_results = []\n\n    for n in test_cases:\n        # J is determined from n = 2^J\n        J = int(np.log2(n))\n\n        # 1. Construct the unitary DFT matrix F\n        t = np.arange(n).reshape(-1, 1)\n        k = np.arange(n).reshape(1, -1)\n        F = (1 / np.sqrt(n)) * np.exp(2j * np.pi * t * k / n)\n\n        # 2. Construct the orthonormal Haar DWT matrix W\n        W = np.zeros((n, n))\n        scale_indices = {}\n        \n        # Scale s=0: Scaling vector phi\n        W[:, 0] = 1 / np.sqrt(n)\n        scale_indices[0] = [0]\n        col_idx = 1\n        \n        # Scales s=1 to J: Wavelet vectors\n        # Ordered from finest (s=1) to coarsest (s=J)\n        for s in range(1, J + 1):\n            L_s = 2**s\n            num_wavelets = n // L_s\n            current_scale_cols = []\n            for k_trans in range(num_wavelets):\n                psi = np.zeros(n)\n                start = k_trans * L_s\n                mid = start + L_s // 2\n                end = (k_trans + 1) * L_s\n                \n                psi[start:mid] = 1 / np.sqrt(L_s)\n                psi[mid:end] = -1 / np.sqrt(L_s)\n                \n                W[:, col_idx] = psi\n                current_scale_cols.append(col_idx)\n                col_idx += 1\n            scale_indices[s] = current_scale_cols\n\n        # Verification step (for correctness, not part of output)\n        # assert np.allclose(F.conj().T @ F, np.identity(n))\n        # assert np.allclose(W.T @ W, np.identity(n))\n\n        # 3. Compute C = F* W and the empirical mutual coherence\n        C = F.conj().T @ W\n        C_abs = np.abs(C)\n        hat_mu = np.max(C_abs)\n\n        # 4. Per-scale analysis\n        scale_means = []\n        scale_maxs = []\n        \n        # Analysis is over scales s = 0, 1, ..., J\n        for s in range(J + 1):\n            cols = scale_indices[s]\n            # Get the sub-matrix of |C| for the current scale\n            C_sub = C_abs[:, cols]\n            \n            # gamma_j is the max of each column\n            gammas = np.max(C_sub, axis=0)\n            \n            scale_means.append(np.mean(gammas))\n            scale_maxs.append(np.max(gammas))\n            \n        # 5. Format results\n        hat_mu_rounded = round(hat_mu, 12)\n        means_rounded = [round(m, 12) for m in scale_means]\n        maxs_rounded = [round(m, 12) for m in scale_maxs]\n\n        result_for_n = [n, hat_mu_rounded, means_rounded, maxs_rounded]\n        all_results.append(result_for_n)\n\n    # Final print statement must match the specified format.\n    # The standard string representation of a list is used.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "3493805"}, {"introduction": "The standard DWT offers a single, fixed tiling of the time-frequency plane, but many signals are better represented by a more adaptive decomposition. This practice explores the Wavelet Packet Transform (WPT), which generates a rich library of orthonormal bases, and guides you through implementing a 'best-basis' selection algorithm. By using a custom sparsity-entropy cost functional and dynamic programming, you will learn to find the most efficient representation for a given signal, showcasing a powerful technique in adaptive signal analysis [@problem_id:3493807].", "problem": "Consider a real-valued discrete-time signal $x \\in \\mathbb{R}^N$ with $N$ equal to a power of $2$. The goal is to construct an orthonormal dictionary via the Wavelet Packet Transform (WPT) using the Haar wavelet, and to perform adaptive best-basis selection that minimizes a sparsity-entropy cost functional. The problem must be solved from first principles grounded in orthonormal transforms, energy preservation, separability of cost across disjoint coefficient sets, and dynamic programming over a full binary decomposition tree.\n\nStart from the following fundamental definitions and facts:\n\n1. The Haar low-pass and high-pass filters are defined by $h = \\left[\\frac{1}{\\sqrt{2}}, \\frac{1}{\\sqrt{2}}\\right]$ and $g = \\left[\\frac{1}{\\sqrt{2}}, -\\frac{1}{\\sqrt{2}}\\right]$. For any even-length vector $v$ with entries $v[0],v[1],\\dots,v[m-1]$, the two-channel Haar analysis yields two length-$\\frac{m}{2}$ outputs:\n   $$a[k] = \\frac{v[2k] + v[2k+1]}{\\sqrt{2}}, \\quad d[k] = \\frac{v[2k] - v[2k+1]}{\\sqrt{2}}, \\quad k = 0,1,\\dots,\\frac{m}{2}-1.$$\n   This transform is orthonormal, and thus preserves energy, i.e., $\\|v\\|_2^2 = \\|a\\|_2^2 + \\|d\\|_2^2$.\n\n2. The Wavelet Packet Transform (WPT) constructs a full binary tree of coefficient vectors. The root at level $0$ is $x$ itself. Each node at level $\\ell$ holds a coefficient vector of length $N / 2^\\ell$. Its two children at level $\\ell+1$ are obtained by applying the above equations to that node’s vector, producing two children vectors each of length $N / 2^{\\ell+1}$. This decomposition continues until level $J = \\log_2 N$, where all leaves have length $1$.\n\n3. Define the sparsity-entropy cost functional for a nonzero vector $v \\in \\mathbb{R}^m$ as\n   $$C_\\alpha(v) = \\alpha \\|v\\|_1 + (1-\\alpha) H(v),$$\n   where $\\alpha \\in [0,1]$ and $H(v)$ is the Shannon entropy of the normalized energy distribution of $v$, namely, with $E = \\sum_{i=1}^m v_i^2$ and $p_i = \\frac{v_i^2}{E}$, define\n   $$H(v) = -\\sum_{i=1}^m p_i \\log(p_i + \\varepsilon),$$\n   with $\\varepsilon = 10^{-12}$. If $E=0$, define $C_\\alpha(v)=0$. The logarithm is the natural logarithm.\n\n4. The best-basis selection over the full WPT tree is defined by choosing, at each node, either to keep the node unsplit (incurring the cost of its own coefficient vector) or to split into its two children (incurring the sum of the children’s optimal costs), so as to minimize the total cost. Because the cost is additive over disjoint sets of coefficients and the transform is orthonormal, a dynamic programming on the tree that compares the unsplit-node cost to the sum of optimal children costs yields the globally optimal basis. In the case of equality, choose the unsplit node to favor coarser representations.\n\nImplement the following programmatic tasks:\n\n1. Construct the full Wavelet Packet Transform tree using the Haar pairwise formulas given above, for any input signal $x$ of length $N$ with $N$ a power of $2$. Use no boundary extension; apply the pairwise formulas exactly so that every node at level $\\ell$ of length $N/2^\\ell$ produces two children of length $N/2^{\\ell+1}$.\n\n2. Define the node cost $C_\\alpha(v)$ as above. Perform bottom-up dynamic programming to decide, at each node, whether to keep it unsplit or to split into its children, choosing the option that minimizes the cost. In the case of equality of the two options, choose to keep the node unsplit. Return the total optimal cost and the number of selected nodes in the chosen best basis (i.e., the count of nodes that are kept unsplit).\n\n3. Use the following test suite of signals and parameters. In all cases, set $\\varepsilon = 10^{-12}$ and decompose to maximum depth $J = \\log_2 N$.\n\n   - Test Case $1$ (happy path, mixed smooth and sparse):\n     - $N = 64$.\n     - For $n = 0,1,\\dots,63$, define\n       $$x[n] = \\sin\\left(\\frac{2\\pi \\cdot 3 \\cdot n}{64}\\right) + 0.5\\left(\\delta[n - 10] + \\delta[n - 45]\\right),$$\n       where $\\delta[\\cdot]$ is the Kronecker delta.\n     - $\\alpha = 0.5$.\n\n   - Test Case $2$ (boundary with trivial structure):\n     - $N = 64$.\n     - $x[n] = 1$ for all $n$.\n     - $\\alpha = 0.7$.\n\n   - Test Case $3$ (edge case with stochastic content):\n     - $N = 64$.\n     - $x[n]$ are independent and identically distributed samples from a Gaussian distribution $\\mathcal{N}(0,1)$, generated with a fixed random seed $s = 0$.\n     - $\\alpha = 0$.\n\n   - Test Case $4$ (short-length boundary, highly localized):\n     - $N = 8$.\n     - $x[n] = 1$ if $n = 4$ and $x[n] = 0$ otherwise.\n     - $\\alpha = 0.5$.\n\n4. Final Output Format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For each test case, output first the integer number of selected nodes in the best basis, followed by the total optimal cost as a float rounded to six decimal places. Therefore, with four test cases, the output must be\n   $$[n_1, c_1, n_2, c_2, n_3, c_3, n_4, c_4],$$\n   where $n_i$ is an integer and $c_i$ is a float rounded to six decimal places for test case $i$.\n\nAll quantities are dimensionless; no physical units are involved. Angles in trigonometric functions are in radians. Ensure numerical stability for $\\log$ with the specified $\\varepsilon$ and define the entropy for zero-energy vectors to be $0$ as stated.", "solution": "The problem requires the implementation of an adaptive best-basis selection algorithm for a signal using the Wavelet Packet Transform (WPT) with Haar wavelets. The selection criterion is the minimization of a specified sparsity-entropy cost functional. The solution is found using a dynamic programming approach on the full WPT decomposition tree. The process can be broken down into three main conceptual stages: constructing the library of bases, defining the cost metric, and performing the optimization.\n\n### 1. The Wavelet Packet Transform as a Library of Orthonormal Bases\n\nThe Wavelet Packet Transform (WPT) generates a dictionary of orthonormal bases. For a signal $x \\in \\mathbb{R}^N$ where $N$ is a power of $2$, we can construct a full binary tree of coefficient vectors.\n\n-   **Tree Generation**: The root of the tree, at level $\\ell=0$, is the signal $x$ itself. A node at any level $\\ell$ containing a vector $v$ of length $m = N/2^\\ell$ is decomposed into two children nodes at level $\\ell+1$. This decomposition is achieved by applying a two-channel orthonormal filter bank. For the Haar wavelet, the low-pass filter is $h = \\left[\\frac{1}{\\sqrt{2}}, \\frac{1}{\\sqrt{2}}\\right]$ and the high-pass filter is $g = \\left[\\frac{1}{\\sqrt{2}}, -\\frac{1}{\\sqrt{2}}\\right]$. The decomposition formulas are:\n    -   Approximation (low-pass) coefficients: $$a[k] = \\frac{v[2k] + v[2k+1]}{\\sqrt{2}}$$\n    -   Detail (high-pass) coefficients: $$d[k] = \\frac{v[2k] - v[2k+1]}{\\sqrt{2}}$$\n    for $k = 0, 1, \\dots, \\frac{m}{2}-1$. The resulting vectors $a$ and $d$ each have length $m/2$ and form the two children nodes. This process is repeated until the maximum depth $J = \\log_2 N$ is reached, where the leaf nodes contain vectors of length $1$.\n\n-   **Orthonormal Bases**: The full binary tree contains a rich library of orthonormal bases for $\\mathbb{R}^N$. A valid basis is formed by any collection of nodes whose corresponding time-frequency tiles partition the entire time-frequency plane. In terms of the tree structure, this corresponds to any set of terminal nodes that are siblings of pruned branches and which themselves have no descendants in the chosen basis. The root node itself forms one basis (the standard basis representation of $x$). The set of all leaf nodes at level $J$ forms another basis (the full wavelet packet decomposition). The goal of the algorithm is to select the optimal basis from this library.\n\n### 2. The Sparsity-Entropy Cost Functional\n\nTo select a \"best\" basis, we need a quantitative measure of desirability. The problem defines a cost functional $C_\\alpha(v)$ for any coefficient vector $v \\in \\mathbb{R}^m$ in the tree. This functional is designed to favor representations where the signal's energy is concentrated in a few large-magnitude coefficients (i.e., a sparse representation).\n\nFor a nonzero vector $v$, the cost is:\n$$C_\\alpha(v) = \\alpha \\|v\\|_1 + (1-\\alpha) H(v)$$\nwhere $\\alpha \\in [0,1]$.\n\n-   **$L_1$ Norm ($ \\|v\\|_1 = \\sum_{i=1}^m |v_i|$)**: This component is a well-known convex proxy for sparsity. Minimizing the $L_1$ norm encourages solutions with many coefficients close to zero.\n\n-   **Shannon Entropy ($H(v)$)**: This component measures the \"flatness\" or \"spread\" of the signal's energy distribution. It is defined as:\n    $$H(v) = -\\sum_{i=1}^m p_i \\log(p_i + \\varepsilon)$$\n    where $p_i = v_i^2 / E$ is the normalized energy of the $i$-th coefficient, and $E = \\|v\\|_2^2 = \\sum_{i=1}^m v_i^2$ is the total energy of the vector. A signal whose energy is concentrated in a single coefficient has very low entropy, while a signal with energy spread evenly across all coefficients has high entropy. The small constant $\\varepsilon = 10^{-12}$ ensures numerical stability by preventing the evaluation of $\\log(0)$.\n\nIf the energy $E=0$, the cost is defined as $C_\\alpha(v)=0$. The parameter $\\alpha$ balances the trade-off between the two sparsity measures.\n\n### 3. Best-Basis Selection via Dynamic Programming\n\nThe key to finding the globally optimal basis efficiently is the additive nature of the cost functional across disjoint sets of coefficients, enabled by the orthonormality of the transform. This allows the use of a dynamic programming algorithm, commonly known as the Coifman-Wickerhauser algorithm.\n\nThe algorithm proceeds bottom-up on the WPT tree:\n\n1.  **Initialization (Leaves)**: For each leaf node at the maximum depth $J = \\log_2 N$, there is no possibility of splitting further. Its optimal cost is simply the cost of its own coefficient vector, $C_\\alpha(v)$.\n\n2.  **Recursive Step (Bottom-up Traversal)**: We move upwards from level $\\ell = J-1$ to the root at $\\ell = 0$. For each node $P$ at level $\\ell$ with children $C_1$ and $C_2$ at level $\\ell+1$:\n    -   We retrieve the already computed optimal costs for the subtrees rooted at its children, let's call them $C_{\\text{opt}}(C_1)$ and $C_{\\text{opt}}(C_2)$. The \"split\" cost for node $P$ is the sum of these costs: $C_{\\text{split}} = C_{\\text{opt}}(C_1) + C_{\\text{opt}}(C_2)$.\n    -   We compute the \"unsplit\" cost for node $P$, which is the cost of representing the signal subspace with $P$'s own coefficient vector: $C_{\\text{unsplit}} = C_\\alpha(v_P)$.\n    -   **Decision**: We compare the two costs. According to the problem's tie-breaking rule:\n        -   If $C_{\\text{unsplit}} \\le C_{\\text{split}}$, we decide to prune the tree at this node. The optimal cost for the subtree rooted at $P$ is $C_{\\text{opt}}(P) = C_{\\text{unsplit}}$, and we mark $P$ as a terminal node (unsplit).\n        -   Otherwise, if $C_{\\text{unsplit}} > C_{\\text{split}}$, we keep the split. The optimal cost is $C_{\\text{opt}}(P) = C_{\\text{split}}$, and we mark $P$ as a non-terminal (split) node.\n\n3.  **Final Result**: This process continues until we reach the root node $(\\ell=0, \\text{index}=0)$. The value $C_{\\text{opt}}(\\text{root})$ is the minimum possible cost for any basis in the WPT library.\n\nTo find the number of nodes in the selected best basis, we perform a final top-down traversal of the tree, following the decisions made during the dynamic programming phase. Starting from the root, if a node was marked \"unsplit\", we count it and stop traversing that branch. If it was marked \"split\", we recursively descend to its two children and sum their node counts. This traversal counts exactly the terminal nodes of the optimal basis tree.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that orchestrates the entire process.\n    It defines test cases, runs the best-basis selection algorithm\n    for each, and formats the final output.\n    \"\"\"\n    \n    # Global constants defined in the problem\n    EPSILON = 1e-12\n    SQRT2 = np.sqrt(2.0)\n\n    # --- Helper Functions ---\n\n    def generate_signal(case_id, N):\n        \"\"\"Generates the input signal x for a given test case.\"\"\"\n        n_indices = np.arange(N)\n        if case_id == 1:\n            # x[n] = sin(2*pi*3*n/64) + 0.5 * (delta[n-10] + delta[n-45])\n            x = np.sin(2 * np.pi * 3 * n_indices / N)\n            x[10] += 0.5\n            x[45] += 0.5\n            return x\n        elif case_id == 2:\n            # x[n] = 1 for all n\n            return np.ones(N)\n        elif case_id == 3:\n            # N(0,1) with seed 0\n            np.random.seed(0)\n            return np.random.randn(N)\n        elif case_id == 4:\n            # x[n] = delta[n-4]\n            x = np.zeros(N)\n            x[4] = 1.0\n            return x\n        return None\n\n    def cost_functional(v, alpha):\n        \"\"\"\n        Computes the sparsity-entropy cost C_alpha(v) for a vector v.\n        \"\"\"\n        v = np.asarray(v)\n        energy = np.sum(v**2)\n\n        if energy < EPSILON:  # Treat as zero energy\n            return 0.0\n\n        l1_norm = np.sum(np.abs(v))\n        \n        p = (v**2) / energy\n        # Filter p_i that are effectively zero to avoid adding log(epsilon)\n        p_nonzero = p[p > 0] \n        entropy = -np.sum(p_nonzero * np.log(p_nonzero + EPSILON))\n\n        return alpha * l1_norm + (1 - alpha) * entropy\n\n    def haar_analysis(v):\n        \"\"\"\n        Performs one level of Haar wavelet decomposition using vectorized operations.\n        \"\"\"\n        a = (v[0::2] + v[1::2]) / SQRT2\n        d = (v[0::2] - v[1::2]) / SQRT2\n        return a, d\n\n    def find_best_basis_and_cost(x, N, alpha):\n        \"\"\"\n        Implements the main WPT and best-basis selection algorithm.\n        \"\"\"\n        J = int(np.log2(N))\n\n        # 1. Construct the full Wavelet Packet Transform tree\n        # The tree is stored in a dictionary mapping (level, index) to the coefficient vector.\n        tree = {}\n        tree[(0, 0)] = x\n        for level in range(J):\n            num_nodes_in_level = 1 << level\n            for index in range(num_nodes_in_level):\n                parent_vector = tree.get((level, index))\n                if parent_vector is not None:\n                    a, d = haar_analysis(parent_vector)\n                    tree[(level + 1, 2 * index)] = a\n                    tree[(level + 1, 2 * index + 1)] = d\n\n        # 2. Perform bottom-up dynamic programming\n        optimal_costs = {}\n        is_split_decision = {}  # Stores bool: True if node is split, False if not.\n\n        # Initialization at the deepest level (leaves)\n        for index in range(1 << J):\n            leaf_vector = tree[(J, index)]\n            optimal_costs[(J, index)] = cost_functional(leaf_vector, alpha)\n            \n        # Iterate upwards from level J-1 to 0\n        for level in range(J - 1, -1, -1):\n            num_nodes_in_level = 1 << level\n            for index in range(num_nodes_in_level):\n                # Cost if we do not split this node\n                node_vector = tree[(level, index)]\n                cost_unsplit = cost_functional(node_vector, alpha)\n\n                # Cost if we split (sum of optimal costs of children)\n                child1_key = (level + 1, 2 * index)\n                child2_key = (level + 1, 2 * index + 1)\n                cost_split = optimal_costs[child1_key] + optimal_costs[child2_key]\n                \n                # Decision logic with tie-breaking rule\n                if cost_unsplit <= cost_split:\n                    optimal_costs[(level, index)] = cost_unsplit\n                    is_split_decision[(level, index)] = False\n                else:\n                    optimal_costs[(level, index)] = cost_split\n                    is_split_decision[(level, index)] = True\n        \n        total_optimal_cost = optimal_costs[(0, 0)]\n\n        # 3. Count nodes in the chosen best basis by traversing the decision tree\n        def count_basis_nodes(level, index):\n            # If a node is not marked as split, it's a terminal node in the best basis.\n            # Leaves (level J) are terminal by definition and won't be in is_split_decision.\n            if not is_split_decision.get((level, index), False):\n                return 1\n            \n            # If it is split, recurse on its children and sum their counts.\n            count = count_basis_nodes(level + 1, 2 * index) + \\\n                    count_basis_nodes(level + 1, 2 * index + 1)\n            return count\n\n        num_selected_nodes = count_basis_nodes(0, 0)\n        \n        return num_selected_nodes, total_optimal_cost\n\n    # --- Main Execution Loop ---\n\n    test_cases = [\n        {'id': 1, 'N': 64, 'alpha': 0.5},\n        {'id': 2, 'N': 64, 'alpha': 0.7},\n        {'id': 3, 'N': 64, 'alpha': 0.0},\n        {'id': 4, 'N': 8,  'alpha': 0.5},\n    ]\n\n    results = []\n    for case in test_cases:\n        signal = generate_signal(case['id'], case['N'])\n        n_nodes, cost = find_best_basis_and_cost(signal, case['N'], case['alpha'])\n        \n        results.append(str(n_nodes))\n        results.append(f\"{cost:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3493807"}]}