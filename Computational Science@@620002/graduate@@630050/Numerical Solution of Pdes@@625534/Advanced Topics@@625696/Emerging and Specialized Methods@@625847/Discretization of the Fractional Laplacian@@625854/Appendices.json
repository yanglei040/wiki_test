{"hands_on_practices": [{"introduction": "We begin by exploring a direct way to discretize the fractional Laplacian: through its spectral definition. This practice guides you in implementing two spectral methods based on the Discrete Sine Transform, allowing you to directly compare the impact of using continuous versus discrete eigenvalues. By analyzing the convergence rate, you will develop a concrete understanding of discretization error for this non-local operator [@problem_id:3381295].", "problem": "Consider the spectral fractional Laplacian, denoted by $(-\\Delta)^s$, on the $d$-dimensional open unit hypercube $\\Omega=(0,1)^d$ with homogeneous Dirichlet boundary conditions. The spectral definition of fractional powers of the Dirichlet Laplacian proceeds from the orthonormal eigenbasis of the standard Dirichlet Laplacian operator. Let $u:\\Omega\\to\\mathbb{R}$ be square-integrable and suppose $u$ is expanded in sine eigenfunctions. The action of $(-\\Delta)^s$ is defined by raising the corresponding Dirichlet Laplacian eigenvalues to the power $s$ within that expansion.\n\nYour task is to design and implement two consistent discretizations of $(-\\Delta)^s$ that act on grid samples of $u$ restricted to the interior grid of $\\Omega=(0,1)^d$. Both discretizations must rely only on fundamental definitions and well-tested numerical facts, starting from the spectral definition of the Dirichlet Laplacian and making use of the orthogonal sine basis on interior grids.\n\nDiscretization A (continuous-spectrum-based):\n- Use the orthonormal sine basis on the interior grid to map $u$ to sine coefficients via the Discrete Sine Transform (DST).\n- Apply the fractional operator by multiplying each sine coefficient by the appropriate continuous Dirichlet Laplacian eigenvalue raised to $s$, and then invert the transform to return to physical space.\n- This discretization is constructed from the continuous Dirichlet eigenpairs and is consistent with the spectral definition by construction.\n\nDiscretization B (finite-difference spectral matrix power):\n- Use the same sine basis on the interior grid; however, instead of continuous eigenvalues, use the eigenvalues of the standard central-difference Dirichlet discrete Laplacian matrix on the interior grid.\n- Apply the fractional operator by raising those discrete eigenvalues to the power $s$ in the sine basis, and invert the transform.\n\nBenchmark suite setup:\n- Use the test function $u(x)=\\prod_{j=1}^d \\sin(\\pi x_j)$, which is a single sine eigenfunction for the Dirichlet Laplacian on $(0,1)^d$.\n- Derive the exact action of $(-\\Delta)^s$ on $u$ from the spectral definition and the characterization of Dirichlet Laplacian eigenpairs on $(0,1)^d$. Use this exact action as the reference solution to compute errors for both discretizations on interior grids.\n- For each test case, form an interior uniform grid with $N$ points per coordinate direction. The interior grid nodes are $x_i=i/(N+1)$ for $i=1,\\dots,N$ in each dimension, and the grid spacing is $h=1/(N+1)$.\n- Compute the error of Discretization A as the maximum absolute pointwise difference between its output and the exact reference at the finest grid.\n- For Discretization B, compute the relative $\\ell^2$ error $\\|e\\|_2/\\|f\\|_2$, where $e$ is the difference between the discrete output and the exact reference on the grid, and $f$ is the exact reference, for three grid sizes. From these three errors and their associated grid spacings, estimate the observed order of convergence by a least-squares fit to $\\log_{10}(\\text{error})$ versus $\\log_{10}(h)$.\n- The Discrete Sine Transform (DST) refers to an orthonormal Fast Fourier Transform (FFT)-based implementation of the sine expansion on grids that respect Dirichlet boundary conditions on $(0,1)^d$.\n\nTest suite:\n- Dimensions $d\\in\\{1,2\\}$.\n- Fractional orders $s\\in\\{0.25,0.5,0.75\\}$.\n- For each pair $(d,s)$, use interior grid sizes $N\\in\\{15,31,63\\}$ to compute errors and estimate the observed convergence rate for Discretization B. Also compute the Discretization A maximum absolute error at the finest grid $N=63$.\n\nRequired final output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must contain, in order:\n    1. First, for each $(d,s)$ pair with $d$ increasing and, within each $d$, $s$ in increasing order, the observed convergence rate for Discretization B, rounded to three decimal places. There are six such rates (two dimensions times three fractional orders).\n    2. Then, for the same $(d,s)$ order, the maximum absolute pointwise error of Discretization A at $N=63$, rounded to twelve decimal places. There are six such errors.\n- For clarity, the output will therefore contain twelve floating-point numbers. No units apply. Angles are not involved, and no percentages are used; all values are pure real numbers without units.\n- Example output format (with placeholder numbers): \"[r11,r12,r13,r21,r22,r23,e11,e12,e13,e21,e22,e23]\" where $r_{ij}$ represents the rate for dimension $i$ and fractional order index $j$, and $e_{ij}$ the corresponding Discretization A error at the finest grid.\n\nYour implementation must be a complete, runnable program that performs the described computations without any external input or files and prints the single required output line.", "solution": "The problem statement is assessed to be valid. It is scientifically grounded in the theory of partial differential equations and numerical analysis, specifically concerning the spectral definition and numerical approximation of the fractional Laplacian operator. The problem is well-posed, providing a clear objective, a complete set of definitions, a specific test case, and a precisely defined set of required outputs and error metrics. All terms are formally defined and used consistently, and the task is computationally feasible.\n\nThe core of the problem is to discretize the spectral fractional Laplacian $(-\\Delta)^s$ on the domain $\\Omega=(0,1)^d$. The operator is defined via the spectral decomposition of the standard Dirichlet Laplacian $-\\Delta$.\n\nFirst, we establish the analytical foundation. The eigenfunctions and eigenvalues of $-\\Delta$ on $\\Omega=(0,1)^d$ with homogeneous Dirichlet boundary conditions are given by\n$$ \\phi_{\\mathbf{k}}(x) = \\prod_{j=1}^{d} \\sqrt{2} \\sin(k_j \\pi x_j), \\quad \\lambda_{\\mathbf{k}} = \\sum_{j=1}^{d} (k_j \\pi)^2 = \\pi^2 \\|\\mathbf{k}\\|_2^2 $$\nfor a multi-index of positive integers $\\mathbf{k} = (k_1, \\dots, k_d) \\in (\\mathbb{Z}^+)^d$. By spectral definition, the action of $(-\\Delta)^s$ on an eigenfunction is $(-\\Delta)^s \\phi_{\\mathbf{k}} = (\\lambda_{\\mathbf{k}})^s \\phi_{\\mathbf{k}}$.\n\nThe specified test function is $u(x) = \\prod_{j=1}^d \\sin(\\pi x_j)$. This function is proportional to the first eigenfunction $\\phi_{(1,\\dots,1)}(x)$, corresponding to the multi-index $\\mathbf{k}=(1,\\dots,1)$. The associated eigenvalue is $\\lambda_{(1,\\dots,1)} = \\sum_{j=1}^d (1 \\cdot \\pi)^2 = d\\pi^2$.\nTherefore, the exact action of the fractional operator on $u$ is a simple scaling:\n$$ f(x) = (-\\Delta)^s u(x) = (\\lambda_{(1,\\dots,1)})^s u(x) = (d\\pi^2)^s \\prod_{j=1}^d \\sin(\\pi x_j) $$\nThis function $f(x)$ serves as the exact reference solution. We evaluate it on the grid points to obtain the reference grid function $f_{grid}$ for error computations.\n\nThe problem requires discretization on a uniform interior grid with $N$ points in each of the $d$ dimensions. The grid points are $\\mathbf{x}_{\\mathbf{i}} = (i_1 h, \\dots, i_d h)$ for multi-index $\\mathbf{i}=(i_1, \\dots, i_d)$ with $i_j \\in \\{1,\\dots,N\\}$. The grid spacing is $h = 1/(N+1)$.\n\nBoth proposed discretization methods leverage the Discrete Sine Transform (DST). The orthonormal Type-I DST corresponds to a change of basis to the discrete sine functions $\\psi_{\\mathbf{k}}(\\mathbf{i}) \\propto \\prod_{j=1}^d \\sin(\\pi k_j i_j / (N+1))$, which are the exact eigenvectors of the standard central-difference discrete Laplacian on the interior grid. The DST thus diagonalizes the discrete operator, making it the numerical analogue of the continuous sine series expansion. We use the `scipy.fft` library's `dstn` and `idstn` functions with `type=1` and `norm='ortho'`.\n\nDiscretization A (continuous-spectrum-based):\nThis method approximates $(-\\Delta)^s u$ by applying the continuous spectrum in the discrete basis. The algorithm is:\n1.  Compute the grid function $u_{grid}$ by evaluating $u(x)$ at the grid nodes.\n2.  Compute the $d$-dimensional DST of $u_{grid}$ to obtain the coefficients $\\hat{u}_{\\mathbf{k}}$.\n3.  Construct a $d$-dimensional grid of continuous eigenvalues, where the entry at index $\\mathbf{k}$ is $(\\lambda_{\\mathbf{k}})^s = (\\pi^2 \\|\\mathbf{k}\\|_2^2)^s$ for mode $\\mathbf{k}=(k_1,\\dots,k_d)$, with $k_j \\in \\{1,\\dots,N\\}$.\n4.  Multiply the coefficients by the corresponding spectral multipliers: $\\hat{f}_{A,\\mathbf{k}} = (\\lambda_{\\mathbf{k}})^s \\hat{u}_{\\mathbf{k}}$.\n5.  Compute the inverse DST of $\\hat{f}_{A,\\mathbf{k}}$ to obtain the numerical solution $f_{A,grid}$.\nFor the given test function $u(x)$, the grid samples $u_{grid}$ are exactly proportional to the first discrete sine basis vector $\\psi_{(1,\\dots,1)}$. This means its DST, $\\hat{u}_{\\mathbf{k}}$, is a discrete delta function. Since this mode is also an eigenfunction of the continuous operator, and the method uses the exact continuous eigenvalue for this mode, the resulting approximation $f_{A,grid}$ is expected to be identical to the exact solution $f_{grid}$ up to machine precision. The maximum absolute error, $\\max |f_{A,grid} - f_{grid}|$, should therefore be close to zero.\n\nDiscretization B (finite-difference spectral matrix power):\nThis method uses the spectrum of the discrete Laplacian matrix itself. The algorithm is:\n1.  Compute the DST of $u_{grid}$ to get coefficients $\\hat{u}_{\\mathbf{k}}$.\n2.  The eigenvalues of the $d$-dimensional central-difference discrete Laplacian are $\\mu_{\\mathbf{k}} = \\sum_{j=1}^d \\mu_{k_j}$, where the 1D eigenvalues are $\\mu_{k_j} = \\frac{4}{h^2}\\sin^2(\\frac{k_j \\pi h}{2})$.\n3.  Construct a grid of these discrete eigenvalues and compute the spectral multipliers $(\\mu_{\\mathbf{k}})^s$.\n4.  Multiply the coefficients: $\\hat{f}_{B,\\mathbf{k}} = (\\mu_{\\mathbf{k}})^s \\hat{u}_{\\mathbf{k}}$.\n5.  Compute the inverse DST to obtain the numerical solution $f_{B,grid}$.\nThe error in this method comes from approximating the continuous eigenvalues $\\lambda_{\\mathbf{k}}$ with the discrete ones $\\mu_{\\mathbf{k}}$. A Taylor series expansion for small $h$ reveals that $\\mu_k = (k\\pi)^2 - \\frac{(k\\pi)^4}{12}h^2 + O(h^4) = \\lambda_k(1 - \\frac{(k\\pi)^2}{12}h^2 + O(h^4))$. The error in the eigenvalue is of order $O(h^2)$. Consequently, the relative error in the final solution, $\\|f_{B,grid}-f_{grid}\\|_2/\\|f_{grid}\\|_2$, is also expected to be of order $O(h^2)$. The convergence rate, estimated by a least-squares fit on $\\log_{10}(\\text{error})$ versus $\\log_{10}(h)$, should be approximately $2$.\n\nThe implementation will loop over the specified dimensions $d$ and fractional orders $s$. For each pair, it will compute the Discretization A error on the finest grid ($N=63$) and the Discretization B errors for three grid sizes ($N=15, 31, 63$). The latter are used to compute the observed convergence rate for Discretization B. The final results are collected and formatted as specified.", "answer": "```python\nimport numpy as np\nfrom scipy.fft import dstn, idstn\n\ndef solve():\n    \"\"\"\n    Computes errors and convergence rates for two discretizations\n    of the fractional Laplacian.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases_ds = [(d, s) for d in [1, 2] for s in [0.25, 0.5, 0.75]]\n    Ns = [15, 31, 63]\n\n    rates_B = []\n    errors_A_final = []\n\n    for d, s in test_cases_ds:\n        errors_B_case = []\n        hs_B_case = []\n\n        for N in Ns:\n            # Grid setup\n            h = 1.0 / (N + 1)\n            \n            # Create a list of 1D axes for grid creation\n            axes = [np.arange(1, N + 1)] * d\n            # Create indexing grids for coordinates and modes\n            # `ij` indexing aligns with scipy.fft output for separable transforms\n            indices = np.meshgrid(*axes, indexing='ij')\n\n            # Physical grid coordinates\n            grid_coords = [idx * h for idx in indices]\n\n            # Evaluate test function u(x) on the grid\n            sin_parts_u = [np.sin(np.pi * coord) for coord in grid_coords]\n            u_grid = np.prod(sin_parts_u, axis=0)\n\n            # Evaluate exact solution f(x) on the grid\n            # The continuous eigenvalue for u(x) is d * pi^2\n            lambda_u_continuous = d * np.pi**2\n            f_grid = (lambda_u_continuous**s) * u_grid\n\n            # Perform DST on the grid function\n            # Use Type-I orthonormal DST, which corresponds to the sine expansion\n            # for homogeneous Dirichlet boundary conditions.\n            u_hat = dstn(u_grid, type=1, norm='ortho')\n\n            # --- Discretization B (Finite-difference spectral matrix power) ---\n            \n            # Grid of eigenvalues for discrete Laplacian\n            # Mode indices `k` are captured by `indices`\n            sin_sq_parts_mu = [np.sin(k * np.pi * h / 2.0)**2 for k in indices]\n            sum_sin_sq = np.sum(sin_sq_parts_mu, axis=0)\n            mu_discrete_grid = (4.0 / h**2) * sum_sin_sq\n            \n            # Apply fractional operator in spectral domain\n            f_B_hat = u_hat * (mu_discrete_grid**s)\n            \n            # Inverse DST to return to physical space\n            f_B_grid = idstn(f_B_hat, type=1, norm='ortho')\n            \n            # Compute relative l2 error for Discretization B\n            error_vec_B = f_B_grid - f_grid\n            norm_e = np.linalg.norm(error_vec_B)\n            norm_f = np.linalg.norm(f_grid)\n            \n            relative_l2_error_B = norm_e / norm_f if norm_f > 0 else 0.0\n            \n            errors_B_case.append(relative_l2_error_B)\n            hs_B_case.append(h)\n            \n            # --- Discretization A (Continuous-spectrum-based, only for finest grid) ---\n            if N == Ns[-1]:\n                # Grid of eigenvalues for continuous Laplacian\n                sq_k_parts = [k**2 for k in indices]\n                sum_sq_k = np.sum(sq_k_parts, axis=0)\n                lambda_continuous_grid = np.pi**2 * sum_sq_k\n                \n                # Apply fractional operator\n                f_A_hat = u_hat * (lambda_continuous_grid**s)\n                \n                # Inverse DST\n                f_A_grid = idstn(f_A_hat, type=1, norm='ortho')\n                \n                # Compute maximum absolute error for Discretization A\n                max_abs_error_A = np.max(np.abs(f_A_grid - f_grid))\n                errors_A_final.append(max_abs_error_A)\n\n        # After looping through N, compute convergence rate for B\n        log_h = np.log10(np.array(hs_B_case))\n        log_err = np.log10(np.array(errors_B_case))\n        \n        # Fit a line to log(error) vs log(h) to find the slope (rate)\n        # polyfit returns [slope, intercept]\n        rate_B, _ = np.polyfit(log_h, log_err, 1)\n        rates_B.append(rate_B)\n\n    # Format the results for the final output string\n    # Rates are rounded to 3 decimal places\n    # Errors are rounded to 12 decimal places\n    formatted_rates_B = [f\"{r:.3f}\" for r in rates_B]\n    formatted_errors_A = [f\"{e:.12f}\" for e in errors_A_final]\n    \n    # Combine the lists in the specified order: rates first, then errors\n    all_results = formatted_rates_B + formatted_errors_A\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```", "id": "3381295"}, {"introduction": "Having established a method to discretize the operator, we now apply it to solve the fractional Poisson equation. This exercise challenges you to implement a full solver for a problem with a singular right-hand side, a common feature in many physical models. You will construct a high-accuracy reference solution and use it to benchmark your numerical scheme, gaining practical skills in code verification and error analysis for fractional PDEs [@problem_id:3381264].", "problem": "Consider the spectral fractional Laplacian on the open interval domain $\\Omega = (0,1)$ with homogeneous Dirichlet boundary conditions. The spectral fractional Laplacian of order $s \\in (0,1)$ acting on a function $u$ is defined through the eigenpairs of the classical Dirichlet Laplacian on $(0,1)$, which are $e_k(x) = \\sin(k \\pi x)$ with eigenvalues $\\lambda_k = (k \\pi)^2$. In the orthonormal basis $\\varphi_k(x) = \\sqrt{2} \\sin(k \\pi x)$ of $L^2(0,1)$, the operator is given by\n$$\n(-\\Delta)^s u = \\sum_{k=1}^{\\infty} \\lambda_k^s \\widehat{u}_k \\, \\varphi_k(x),\n$$\nwhere $\\widehat{u}_k = \\int_0^1 u(x) \\varphi_k(x) \\, dx$ are the Fourier sine coefficients.\n\nWe consider the fractional Poisson problem\n$$\n(-\\Delta)^s u(x) = f(x) \\quad \\text{for } x \\in (0,1),\n$$\nwith homogeneous Dirichlet boundary conditions, where the forcing term is a singular manufactured right-hand side\n$$\nf(x) = \\operatorname{dist}(x, \\partial \\Omega)^{-\\gamma} = \\min(x, 1-x)^{-\\gamma},\n$$\nfor a parameter $\\gamma \\in (0,1)$, ensuring integrability in $L^1(0,1)$.\n\nYour task is to implement a program that:\n1. Constructs a highly resolved spectral reference solution $u_{\\mathrm{ref}}$ by truncating the continuous spectral expansion. Specifically, compute the coefficients\n$$\n\\widehat{f}_k = \\int_0^1 f(x) \\varphi_k(x) \\, dx,\n$$\nand approximate\n$$\nu_{\\mathrm{ref}}(x) \\approx \\sum_{k=1}^{K_{\\mathrm{ref}}} \\frac{\\widehat{f}_k}{\\lambda_k^s} \\, \\varphi_k(x),\n$$\nevaluated at a uniform grid of $M$ interior points $x_i = \\frac{i}{M+1}$ for $i = 1, \\dots, M$.\n\n2. Constructs a discrete numerical solution $u_{\\mathrm{num}}$ by diagonalizing the standard second-order discrete Dirichlet Laplacian on the same uniform grid and taking a fractional power of the resulting matrix. Specifically, use the Discrete Sine Transform (DST) to diagonalize the discrete Laplacian, apply the fractional power $s$ to its eigenvalues, solve the discrete system for the grid values of $u_{\\mathrm{num}}$, and invert the transform.\n\n3. Compares the discrete numerical solution against the spectral reference solution by computing:\n   - The relative discrete $L^2$-error on the grid,\n     $$\n     \\varepsilon_{\\mathrm{rel}} = \\frac{\\left\\|u_{\\mathrm{num}} - u_{\\mathrm{ref}}\\right\\|_{2}}{\\left\\|u_{\\mathrm{ref}}\\right\\|_{2}},\n     $$\n     where the norm is the Euclidean norm over the $M$ interior grid points.\n   - The discrete residual infinity norm,\n     $$\n     R_{\\infty} = \\left\\| A_h^s u_{\\mathrm{ref}} - f_{\\mathrm{grid}} \\right\\|_{\\infty},\n     $$\n     where $A_h$ is the standard discrete Dirichlet Laplacian on the $M$ interior points with mesh size $h = 1/(M+1)$, $A_h^s$ is its fractional power defined via diagonalization, and $f_{\\mathrm{grid}}$ is the vector $f(x_i)$.\n\nUse radians for all trigonometric computations. There are no physical units to report. The output should be numerical values.\n\nImplement the program to evaluate the following test suite of parameter values $(s, \\gamma, M)$:\n- Test 1 (happy path): $(s, \\gamma, M) = (0.5, 0.25, 64)$\n- Test 2 (high singularity): $(s, \\gamma, M) = (0.9, 0.9, 128)$\n- Test 3 (operator near identity): $(s, \\gamma, M) = (0.1, 0.9, 128)$\n- Test 4 (very strong singularity): $(s, \\gamma, M) = (0.75, 0.99, 96)$\n- Test 5 (smoother forcing): $(s, \\gamma, M) = (0.5, 0.1, 64)$\n\nFor the spectral reference, use a truncation $K_{\\mathrm{ref}} = \\min(256, 4M)$ modes.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered as\n$$\n\\left[ \\varepsilon_{\\mathrm{rel}}^{(1)}, R_{\\infty}^{(1)}, \\varepsilon_{\\mathrm{rel}}^{(2)}, R_{\\infty}^{(2)}, \\dots, \\varepsilon_{\\mathrm{rel}}^{(5)}, R_{\\infty}^{(5)} \\right],\n$$\nwhere the superscript indicates the test case number. Each entry must be a real number (float).", "solution": "The user wants to solve the fractional Poisson problem and compute error metrics.\n\n### Step 1: Extract Givens\n\n- **Domain**: $\\Omega = (0,1)$\n- **Operator**: Spectral fractional Laplacian $(-\\Delta)^s$ with $s \\in (0,1)$ and homogeneous Dirichlet boundary conditions.\n- **Operator Definition**: $(-\\Delta)^s u = \\sum_{k=1}^{\\infty} \\lambda_k^s \\widehat{u}_k \\, \\varphi_k(x)$\n- **Basis**: Orthonormal basis $\\varphi_k(x) = \\sqrt{2} \\sin(k \\pi x)$ for $L^2(0,1)$.\n- **Eigenvalues**: $\\lambda_k = (k \\pi)^2$ for $k=1, 2, \\dots$.\n- **Fourier Coefficients**: $\\widehat{u}_k = \\int_0^1 u(x) \\varphi_k(x) \\, dx$.\n- **Problem**: $(-\\Delta)^s u(x) = f(x)$ for $x \\in (0,1)$.\n- **Forcing Term**: $f(x) = \\operatorname{dist}(x, \\partial \\Omega)^{-\\gamma} = \\min(x, 1-x)^{-\\gamma}$ for $\\gamma \\in (0,1)$.\n- **Grid**: Uniform grid of $M$ interior points $x_i = \\frac{i}{M+1}$ for $i = 1, \\dots, M$.\n- **Reference Solution**: $u_{\\mathrm{ref}}(x) \\approx \\sum_{k=1}^{K_{\\mathrm{ref}}} \\frac{\\widehat{f}_k}{\\lambda_k^s} \\, \\varphi_k(x)$, with $\\widehat{f}_k = \\int_0^1 f(x) \\varphi_k(x) \\, dx$.\n- **Truncation for Reference**: $K_{\\mathrm{ref}} = \\min(256, 4M)$.\n- **Numerical Solution**: $u_{\\mathrm{num}}$ obtained by solving $A_h^s u = f_{\\mathrm{grid}}$, where $A_h$ is the standard second-order discrete Dirichlet Laplacian on the grid, and $A_h^s$ is its fractional power via diagonalization using the Discrete Sine Transform (DST).\n- **Error Metric 1**: Relative discrete $L^2$-error $\\varepsilon_{\\mathrm{rel}} = \\frac{\\left\\|u_{\\mathrm{num}} - u_{\\mathrm{ref}}\\right\\|_{2}}{\\left\\|u_{\\mathrm{ref}}\\right\\|_{2}}$.\n- **Error Metric 2**: Discrete residual infinity norm $R_{\\infty} = \\left\\| A_h^s u_{\\mathrm{ref}} - f_{\\mathrm{grid}} \\right\\|_{\\infty}$.\n- **Test Cases**:\n    1. $(s, \\gamma, M) = (0.5, 0.25, 64)$\n    2. $(s, \\gamma, M) = (0.9, 0.9, 128)$\n    3. $(s, \\gamma, M) = (0.1, 0.9, 128)$\n    4. $(s, \\gamma, M) = (0.75, 0.99, 96)$\n    5. $(s, \\gamma, M) = (0.5, 0.1, 64)$\n- **Output Format**: A single line with a comma-separated list of results: $[\\varepsilon_{\\mathrm{rel}}^{(1)}, R_{\\infty}^{(1)}, \\dots, \\varepsilon_{\\mathrm{rel}}^{(5)}, R_{\\infty}^{(5)}]$.\n\n### Step 2: Validate Using Extracted Givens\n\n- **Scientifically Grounded**: The problem is well-grounded in the theory of fractional partial differential equations and numerical analysis. The spectral definition of the fractional Laplacian is standard. The use of a manufactured solution with a known singularity profile is a common and valid technique for testing numerical methods. The condition on $\\gamma$ ensures the forcing term $f(x)$ is in $L^1(0,1)$, which guarantees a well-defined solution concept.\n- **Well-Posed**: The problem is well-posed. It prescribes a clear, deterministic procedure for computing two numerical quantities, $u_{\\mathrm{ref}}$ and $u_{\\mathrm{num}}$, and their comparison metrics. The underlying fractional Poisson problem has a unique solution under the given conditions.\n- **Objective**: The problem is stated objectively using precise mathematical definitions and terminology. All parameters and procedures are specified without ambiguity.\n- **Completeness**: The problem statement is self-contained. It provides all necessary definitions (operators, basis functions, eigenvalues), parameters (test cases), methods (truncation for reference solution, DST for numerical solution), and evaluation metrics.\n- **No other flaws detected**: The problem does not violate any of the other invalidity criteria. It is a standard numerical experiment in computational mathematics.\n\n### Step 3: Verdict and Action\n\nThe problem is **valid**. A solution will be provided.\n\n### Solution\n\nThe task is to solve the one-dimensional fractional Poisson problem $(-\\Delta)^s u = f$ for a singular forcing term $f(x) = \\min(x, 1-x)^{-\\gamma}$ on the domain $\\Omega = (0,1)$. We will compute a highly accurate reference solution, a numerical solution based on the finite difference method, and then evaluate the error and residual between them.\n\n**1. Grid and Forcing Term**\nFirst, we discretize the domain $(0,1)$ using $M$ interior grid points. The mesh size is $h = 1/(M+1)$, and the grid points are $x_i = i \\cdot h$ for $i=1, \\dots, M$. The forcing term $f(x)$ is evaluated at these points to create a vector $f_{\\mathrm{grid}} \\in \\mathbb{R}^M$, where $(f_{\\mathrm{grid}})_i = f(x_i)$.\n\n**2. Spectral Reference Solution ($u_{\\mathrm{ref}}$)**\nThe reference solution is constructed by truncating the infinite series that defines the exact solution. The solution $u$ can be expressed in the basis of eigenfunctions $\\varphi_k(x) = \\sqrt{2} \\sin(k \\pi x)$ as $u(x) = \\sum_{k=1}^{\\infty} \\widehat{u}_k \\varphi_k(x)$. Applying the operator $(-\\Delta)^s$ yields\n$$\n(-\\Delta)^s u = \\sum_{k=1}^{\\infty} \\lambda_k^s \\widehat{u}_k \\varphi_k(x) = f(x) = \\sum_{k=1}^{\\infty} \\widehat{f}_k \\varphi_k(x).\n$$\nBy comparing coefficients, we find $\\lambda_k^s \\widehat{u}_k = \\widehat{f}_k$, which gives $\\widehat{u}_k = \\widehat{f}_k / \\lambda_k^s$. The reference solution $u_{\\mathrm{ref}}$ is a truncated version of this series, evaluated on the grid points $x_i$:\n$$\nu_{\\mathrm{ref}}(x_i) \\approx \\sum_{k=1}^{K_{\\mathrm{ref}}} \\frac{\\widehat{f}_k}{\\lambda_k^s} \\varphi_k(x_i),\n$$\nwhere $K_{\\mathrm{ref}} = \\min(256, 4M)$, and $\\lambda_k = (k\\pi)^2$ are the eigenvalues of the continuous operator.\n\nThe crucial step is computing the Fourier coefficients $\\widehat{f}_k = \\int_0^1 f(x) \\varphi_k(x) \\, dx$. The integrand is $f(x) \\varphi_k(x) = \\min(x, 1-x)^{-\\gamma} \\sqrt{2} \\sin(k\\pi x)$. Due to the definition of $f(x)$, we split the integral at $x=0.5$ to facilitate numerical quadrature:\n$$\n\\widehat{f}_k = \\sqrt{2} \\left[ \\int_0^{0.5} x^{-\\gamma} \\sin(k\\pi x) \\, dx + \\int_{0.5}^1 (1-x)^{-\\gamma} \\sin(k\\pi x) \\, dx \\right].\n$$\nThese integrals are computed numerically using an adaptive quadrature routine, such as `scipy.integrate.quad`, which can handle the integrable singularities at $x=0$ and $x=1$ since $\\gamma \\in (0,1)$. Once the coefficients $\\widehat{u}_k$ are known, the vector $u_{\\mathrm{ref}}$ is assembled by performing the summation.\n\n**3. Discrete Numerical Solution ($u_{\\mathrm{num}}$)**\nThe numerical solution is based on the finite difference method. The standard second-order central difference approximation for the Laplacian on the grid gives rise to the symmetric, tridiagonal matrix $A_h \\in \\mathbb{R}^{M \\times M}$:\n$$\nA_h = \\frac{1}{h^2} \\begin{pmatrix} 2 & -1 & & \\\\ -1 & 2 & -1 & \\\\ & \\ddots & \\ddots & \\ddots \\\\ & & -1 & 2 & -1 \\\\ & & & -1 & 2 \\end{pmatrix}.\n$$\nThe eigenvectors of this matrix are discrete samples of the sine function, and its eigenvalues are known analytically:\n$$\n\\lambda_{h,j} = \\frac{2}{h^2} \\left(1 - \\cos\\left(\\frac{j\\pi}{M+1}\\right)\\right) = \\frac{4}{h^2} \\sin^2\\left(\\frac{j\\pi}{2(M+1)}\\right), \\quad j=1, \\dots, M.\n$$\nThe matrix $A_h$ is diagonalized by the Type-I Discrete Sine Transform (DST). We use the orthonormal version of the DST, represented by a matrix $S$, which satisfies $S = S^T = S^{-1}$. Then, $A_h = S \\Lambda_h S$, where $\\Lambda_h = \\operatorname{diag}(\\lambda_{h,1}, \\dots, \\lambda_{h,M})$.\n\nThe fractional power $A_h^s$ is defined in the spectral domain: $A_h^s = S \\Lambda_h^s S$. The discrete problem is $A_h^s u_{\\mathrm{num}} = f_{\\mathrm{grid}}$. We solve this efficiently without forming the dense matrix $A_h^s$:\n$$\nu_{\\mathrm{num}} = (A_h^s)^{-1} f_{\\mathrm{grid}} = (S \\Lambda_h^s S)^{-1} f_{\\mathrm{grid}} = S \\Lambda_h^{-s} S f_{\\mathrm{grid}}.\n$$\nThe procedure is as follows:\n1. Compute the DST of the forcing vector: $\\widehat{f}_{\\mathrm{dst}} = S f_{\\mathrm{grid}}$.\n2. Solve for the solution's coefficients in the DST domain: $(\\widehat{u}_{\\mathrm{num}})_j = (\\widehat{f}_{\\mathrm{dst}})_j / \\lambda_{h,j}^s$.\n3. Transform back to the physical domain: $u_{\\mathrm{num}} = S \\widehat{u}_{\\mathrm{num}}$. This final step is also a DST because $S=S^{-1}$.\n\n**4. Error and Residual Evaluation**\nWith both $u_{\\mathrm{ref}}$ and $u_{\\mathrm{num}}$ computed on the same grid, we evaluate the specified metrics.\n\nThe relative discrete $L^2$-error, $\\varepsilon_{\\mathrm{rel}}$, measures the difference between the two solutions. It is computed using the standard Euclidean vector norm (denoted by $\\|\\cdot\\|_2$):\n$$\n\\varepsilon_{\\mathrm{rel}} = \\frac{\\|u_{\\mathrm{num}} - u_{\\mathrm{ref}}\\|_{2}}{\\|u_{\\mathrm{ref}}\\|_{2}}.\n$$\n\nThe discrete residual infinity norm, $R_{\\infty}$, measures how well the reference solution $u_{\\mathrm{ref}}$ satisfies the *discrete* equation. It is defined as:\n$$\nR_{\\infty} = \\| A_h^s u_{\\mathrm{ref}} - f_{\\mathrm{grid}} \\|_{\\infty}.\n$$\nThe term $A_h^s u_{\\mathrm{ref}}$ is computed by applying the discrete fractional operator to the reference solution vector, using the same DST-based procedure as before: $A_h^s u_{\\mathrm{ref}} = S \\Lambda_h^s S u_{\\mathrm{ref}}$. The infinity norm, $\\|\\cdot\\|_{\\infty}$, is the maximum absolute value of the vector's components.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import integrate\nfrom scipy.fft import dst\n\ndef solve():\n    \"\"\"\n    Computes numerical solutions and error metrics for the fractional Poisson problem.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (s, gamma, M)\n        (0.5, 0.25, 64),\n        (0.9, 0.9, 128),\n        (0.1, 0.9, 128),\n        (0.75, 0.99, 96),\n        (0.5, 0.1, 64),\n    ]\n\n    results = []\n    for s, gamma, M in test_cases:\n        # 1. Setup: Grid, Forcing Term, and Parameters\n        h = 1.0 / (M + 1)\n        x_grid = np.linspace(h, 1.0 - h, M)\n        K_ref = min(256, 4 * M)\n        k_modes = np.arange(1, K_ref + 1)\n        j_modes = np.arange(1, M + 1)\n\n        def f_func(x):\n            return np.minimum(x, 1.0 - x)**(-gamma)\n        \n        f_grid = f_func(x_grid)\n\n        # 2. Spectral Reference Solution (u_ref)\n        def phi_k_func(x, k):\n            return np.sqrt(2.0) * np.sin(k * np.pi * x)\n\n        f_hat_k = np.zeros(K_ref)\n        for k_idx, k_val in enumerate(k_modes):\n            integrand_part1 = lambda x: x**(-gamma) * phi_k_func(x, k_val)\n            integrand_part2 = lambda x: (1.0 - x)**(-gamma) * phi_k_func(x, k_val)\n            \n            # Use quad with increased limit for robustness with strong singularities\n            integral1, _ = integrate.quad(integrand_part1, 0, 0.5, limit=200, points=[0])\n            integral2, _ = integrate.quad(integrand_part2, 0.5, 1.0, limit=200, points=[1])\n            \n            f_hat_k[k_idx] = integral1 + integral2\n            \n        lambda_k = (k_modes * np.pi)**2\n        u_hat_k = f_hat_k / (lambda_k**s)\n        \n        phi_matrix = np.sqrt(2.0) * np.sin(np.outer(x_grid, k_modes * np.pi))\n        u_ref = phi_matrix @ u_hat_k\n\n        # 3. Discrete Numerical Solution (u_num)\n        lambda_h_j = (2.0 / h**2) * (1.0 - np.cos(j_modes * np.pi / (M + 1)))\n        \n        f_hat_ortho = dst(f_grid, type=1, norm='ortho')\n        u_hat_ortho = f_hat_ortho / (lambda_h_j**s)\n        u_num = dst(u_hat_ortho, type=1, norm='ortho')\n\n        # 4. Error and Residual Calculation\n        # Relative discrete L2-error\n        norm_diff = np.linalg.norm(u_num - u_ref)\n        norm_ref = np.linalg.norm(u_ref)\n        epsilon_rel = norm_diff / norm_ref\n        \n        # Discrete residual infinity norm\n        u_ref_hat_ortho = dst(u_ref, type=1, norm='ortho')\n        temp_hat = (lambda_h_j**s) * u_ref_hat_ortho\n        A_hs_u_ref_grid = dst(temp_hat, type=1, norm='ortho')\n        \n        residual_vec = A_hs_u_ref_grid - f_grid\n        R_inf = np.linalg.norm(residual_vec, ord=np.inf)\n        \n        results.append(epsilon_rel)\n        results.append(R_inf)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.8e}' for r in results)}]\")\n\nsolve()\n```", "id": "3381264"}, {"introduction": "A major practical challenge in solving fractional PDEs is the poor conditioning of the resulting linear systems, which can slow down iterative solvers. This final practice dives into the critical topic of preconditioning, investigating how the standard Laplacian can be used to accelerate the solution of fractional problems. By numerically estimating how the condition number scales, you will test fundamental theoretical results and understand what makes an efficient and scalable numerical method [@problem_id:3381280].", "problem": "You are asked to investigate the effectiveness of using the local Laplacian operator as a preconditioner for the fractional Laplacian in one spatial dimension on the unit interval with homogeneous Dirichlet boundary conditions. Work entirely in a purely mathematical and algorithmic setting with no physical units. All angles, when needed, must be treated as dimensionless arguments to trigonometric functions. The task is to design and implement a program that constructs discrete operators for two discretization families and empirically estimates the growth rate of the condition number of the preconditioned system as a function of the mesh size and the fractional order.\n\nStart from the following foundational definitions and facts.\n\n1. For a symmetric positive definite matrix operator $A$, its spectral fractional power $A^s$ for $s \\in \\mathbb{R}$ is defined via its spectral decomposition: if $A \\varphi_{i} = \\lambda_{i} \\varphi_{i}$ with orthonormal eigenvectors $\\{\\varphi_{i}\\}$ and eigenvalues $\\{\\lambda_{i}\\} \\subset (0,\\infty)$, then $A^s \\varphi_{i} = \\lambda_{i}^s \\varphi_{i}$ and extended linearly.\n\n2. The condition number of a symmetric positive definite matrix $B$ with respect to the Euclidean norm is $\\kappa(B) = \\lambda_{\\max}(B)/\\lambda_{\\min}(B)$, where $\\lambda_{\\max}(B)$ and $\\lambda_{\\min}(B)$ are the largest and smallest eigenvalues of $B$, respectively.\n\n3. Consider the one-dimensional interval $(0,1)$ with homogeneous Dirichlet boundary conditions at $x=0$ and $x=1$. Two standard discretizations of the Laplacian are:\n   - A finite difference scheme using the standard three-point stencil on a uniform grid of interior points with spacing $h$.\n   - A finite element method using continuous, piecewise linear basis functions on a uniform mesh of elements of size $h$, with assembled stiffness matrix $K$ and mass matrix $M$.\n\n4. For the finite difference discretization, let $A$ denote the symmetric positive definite discrete Laplacian matrix. For the finite element discretization, consider the generalized eigenproblem $K \\phi_{i} = \\lambda_{i} M \\phi_{i}$, where $K$ is the stiffness matrix and $M$ is the mass matrix.\n\nYour task is as follows.\n\nA. For the finite difference discretization:\n   - Construct the discrete Laplacian operator $A$ on $(0,1)$ with homogeneous Dirichlet boundary conditions using the standard three-point stencil on $n$ interior grid points with spacing $h = 1/(n+1)$.\n   - Define the fractional operator $A^s$ for $s \\in (0,1]$ spectrally.\n   - Consider preconditioning the linear system $A^s u = f$ by $A$, forming the preconditioned operator $A^{-1} A^s$.\n   - Theoretical scaling predicts that $\\kappa(A^{-1} A^s)$ grows asymptotically like $h^{-p(s)}$ as $h \\to 0$ for some exponent $p(s)$ depending on $s$.\n   - Implement a procedure that, for fixed $s$, computes $\\kappa(A^{-1} A^s)$ for several values of $n$ (and hence $h$), and estimates the exponent $p(s)$ by a least-squares linear fit of $\\log \\kappa$ versus $\\log h$.\n\nB. For the finite element discretization:\n   - Assemble the stiffness matrix $K$ and mass matrix $M$ for continuous, piecewise linear finite elements on a uniform mesh of $N_{e}$ elements covering $(0,1)$ with homogeneous Dirichlet boundary conditions at the endpoints. The number of interior degrees of freedom is $N = N_{e} - 1$, and the mesh size is $h = 1/N_{e}$.\n   - Consider the generalized eigenpairs $(\\lambda_{i}, \\phi_{i})$ satisfying $K \\phi_{i} = \\lambda_{i} M \\phi_{i}$ with $\\lambda_{i} > 0$.\n   - Define the discrete spectral fractional operator $K^s$ via the generalized eigenpairs, and consider preconditioning the linear system $K^s u = f$ (interpreted in the consistent discrete sense) by $K$, forming the operator $K^{-1} K^s$.\n   - Implement a procedure that, for fixed $s$, computes the generalized extreme eigenvalues needed to determine $\\kappa(K^{-1} K^s)$ for several values of $N_{e}$ (and hence $h$), and estimates the exponent $p(s)$ by a least-squares linear fit of $\\log \\kappa$ versus $\\log h$.\n\nC. For both discretizations in parts A and B, and for each value of $s \\in \\{0.25, 0.5, 0.75, 1.0\\}$, estimate the growth exponent $p(s)$ from three mesh sizes. The mesh sizes must be:\n   - For the finite difference method, use $n \\in \\{63, 127, 255\\}$ interior points, with $h = 1/(n+1)$.\n   - For the finite element method, use $N_{e} \\in \\{64, 128, 256\\}$ elements, with $h = 1/N_{e}$.\n\nD. Theoretical expectation to be tested: under uniform meshes and standard conforming constructions in one dimension, the eigenvalues of the local Laplacian discretization scale like $h^{-2}$. Using this fact and the spectral definition of fractional powers, the theoretically predicted exponent is $p_{\\mathrm{th}}(s) = 2 (1 - s)$ for both discretizations when preconditioning $(-\\Delta)^{s}$ by $(-\\Delta)$.\n\nE. Implement a program that executes the above procedures and, for each of the following eight test cases, returns whether the empirically estimated exponent $p_{\\mathrm{est}}(s)$ matches the theoretical $p_{\\mathrm{th}}(s)$ within a tolerance of $\\pm 0.3$:\n   - Finite difference with $s = 0.25$.\n   - Finite difference with $s = 0.5$.\n   - Finite difference with $s = 0.75$.\n   - Finite difference with $s = 1.0$.\n   - Finite element with $s = 0.25$.\n   - Finite element with $s = 0.5$.\n   - Finite element with $s = 0.75$.\n   - Finite element with $s = 1.0$.\n\nYour program should produce a single line of output containing the results for these eight cases as a comma-separated list of boolean values enclosed in square brackets (for example, \"[True,False,True,True,False,True,True,True]\"). The order of the results in the list must be exactly as listed above. No inputs are to be read, and no units are involved. Angles used in trigonometric functions are to be interpreted as dimensionless quantities. All computations must be reproducible based solely on the definitions and procedures specified here.", "solution": "The problem requires an empirical investigation into the spectral properties of a preconditioned fractional Laplacian system. Specifically, we are to estimate the growth rate of the condition number of the system $(-\\Delta)^{-1}(-\\Delta)^s$ as a function of the mesh size $h$, where $(-\\Delta)$ is the standard one-dimensional Laplacian operator on the interval $(0,1)$ with homogeneous Dirichlet boundary conditions. We will analyze two common discretization schemes: the finite difference method (FDM) and the finite element method (FEM).\n\nThe core of the analysis rests on the spectral definition of fractional matrix powers. For a symmetric positive definite (SPD) matrix operator $A$ with eigenvalues $\\lambda_i$ and corresponding eigenvectors $\\varphi_i$, the operator $A^s$ is defined by its action on the same eigenvectors: $A^s \\varphi_i = \\lambda_i^s \\varphi_i$. The preconditioner is the non-fractional operator $A$ itself. The preconditioned operator is thus $P = A^{-1}A^s$. Since $A^{-1}$ and $A^s$ are both functions of $A$, they commute and share the same eigenvectors $\\varphi_i$. The eigenvalues of the preconditioned operator $P$ are therefore $\\mu_i = \\lambda_i^{-1} \\lambda_i^s = \\lambda_i^{s-1}$.\n\nThe condition number of a symmetric positive definite matrix $B$ is $\\kappa(B) = \\lambda_{\\max}(B)/\\lambda_{\\min}(B)$. For our preconditioned operator $P$, we must determine its extreme eigenvalues. The fractional order $s$ is in the range $(0,1]$, so the exponent $s-1$ is in $(-1,0]$. This means that if $\\lambda_i$ are the eigenvalues of $A$ sorted in increasing order, $\\lambda_{\\min}(A) \\le \\lambda_i \\le \\lambda_{\\max}(A)$, the eigenvalues $\\mu_i = \\lambda_i^{s-1}$ of $P$ will be in reverse order: $\\mu_{\\max}(P) = (\\lambda_{\\min}(A))^{s-1}$ and $\\mu_{\\min}(P) = (\\lambda_{\\max}(A))^{s-1}$. The condition number of the preconditioned system is:\n$$\n\\kappa(P) = \\frac{\\mu_{\\max}(P)}{\\mu_{\\min}(P)} = \\frac{(\\lambda_{\\min}(A))^{s-1}}{(\\lambda_{\\max}(A))^{s-1}} = \\left(\\frac{\\lambda_{\\min}(A)}{\\lambda_{\\max}(A)}\\right)^{s-1} = \\left(\\frac{\\lambda_{\\max}(A)}{\\lambda_{\\min}(A)}\\right)^{1-s}\n$$\nThe problem states that for standard discretizations of the 1D Laplacian, the eigenvalues scale as $\\lambda_{\\min}(A) \\approx C_1$ (a constant) and $\\lambda_{\\max}(A) \\approx C_2 h^{-2}$ as the mesh size $h \\to 0$. Substituting this into the expression for the condition number gives the expected asymptotic behavior:\n$$\n\\kappa(P) \\approx \\left(\\frac{C_2 h^{-2}}{C_1}\\right)^{1-s} \\propto (h^{-2})^{1-s} = h^{-2(1-s)}\n$$\nTaking the logarithm of both sides yields a linear relationship: $\\log(\\kappa) = -2(1-s)\\log(h) + \\text{const}$. The theoretical growth exponent is thus $p_{\\mathrm{th}}(s) = 2(1-s)$. Our task is to estimate this exponent $p(s)$ numerically for several values of $s$ and for both FDM and FEM discretizations.\n\nThe numerical estimation procedure is as follows: for a given discretization method and a fixed value of $s$, we compute the condition number $\\kappa$ for three prescribed mesh sizes $h$. This gives us three data points $(\\log(h_i), \\log(\\kappa_i))$. We then perform a linear least-squares fit on these points to find the slope $m$ of the best-fit line $\\log(\\kappa) = m \\log(h) + c$. The estimated exponent is $p_{\\mathrm{est}}(s) = -m$.\n\n**Part A: Finite Difference Method (FDM)**\nFor the FDM, we discretize the operator $-d^2/dx^2$ on a uniform grid with $n$ interior points. The mesh spacing is $h = 1/(n+1)$. The standard three-point central difference stencil leads to the $n \\times n$ symmetric tridiagonal matrix:\n$$\nA = \\frac{1}{h^2}\n\\begin{pmatrix}\n2 & -1 & & & \\mathbf{0} \\\\\n-1 & 2 & -1 & & \\\\\n& \\ddots & \\ddots & \\ddots & \\\\\n& & -1 & 2 & -1 \\\\\n\\mathbf{0} & & & -1 & 2\n\\end{pmatrix}\n$$\nFor each $n \\in \\{63, 127, 255\\}$, we construct this matrix $A$, compute its minimum and maximum eigenvalues $\\lambda_{\\min}(A)$ and $\\lambda_{\\max}(A)$, calculate $\\kappa = (\\lambda_{\\max}(A)/\\lambda_{\\min}(A))^{1-s}$, and record the point $(\\log(h), \\log(\\kappa))$. A linear fit to these three points gives $p_{\\mathrm{est}}(s)$.\n\n**Part B: Finite Element Method (FEM)**\nFor the FEM, we use continuous, piecewise linear basis functions on a uniform mesh of $N_e$ elements. This yields $N = N_e - 1$ interior degrees of freedom. The mesh size is $h = 1/N_e$. The discretization leads to a generalized eigenvalue problem $K\\phi = \\lambda M\\phi$, where $K$ is the stiffness matrix and $M$ is the mass matrix. These $N \\times N$ matrices are:\n$$\nK = \\frac{1}{h}\n\\begin{pmatrix}\n2 & -1 & & & \\mathbf{0} \\\\\n-1 & 2 & -1 & & \\\\\n& \\ddots & \\ddots & \\ddots & \\\\\n& & -1 & 2 & -1 \\\\\n\\mathbf{0} & & & -1 & 2\n\\end{pmatrix}\n\\quad , \\quad\nM = \\frac{h}{6}\n\\begin{pmatrix}\n4 & 1 & & & \\mathbf{0} \\\\\n1 & 4 & 1 & & \\\\\n& \\ddots & \\ddots & \\ddots & \\\\\n& & 1 & 4 & 1 \\\\\n\\mathbf{0} & & & 1 & 4\n\\end{pmatrix}\n$$\nThe condition number of the preconditioned system is again $\\kappa = (\\lambda_{\\max}/\\lambda_{\\min})^{1-s}$, where $\\lambda_{\\min}$ and $\\lambda_{\\max}$ are the smallest and largest generalized eigenvalues of the pair $(K, M)$. For each $N_e \\in \\{64, 128, 256\\}$, we construct $K$ and $M$, solve for the extreme generalized eigenvalues, compute $\\kappa$, and record $(\\log(h), \\log(\\kappa))$. A linear fit provides $p_{\\mathrm{est}}(s)$.\n\n**Part C, D, E: Final Comparison**\nFor each of the eight test cases (FDM/FEM with $s \\in \\{0.25, 0.5, 0.75, 1.0\\}$), we calculate the theoretical exponent $p_{\\mathrm{th}}(s) = 2(1-s)$. We then check if the empirically estimated exponent $p_{\\mathrm{est}}(s)$ falls within the specified tolerance: $|p_{\\mathrm{est}}(s) - p_{\\mathrm{th}}(s)| \\le 0.3$. The boolean result of this check for each case constitutes the final output. For the special case $s=1.0$, $p_{\\mathrm{th}}(1.0) = 0$, and the preconditioned operator is the identity matrix, so $\\kappa=1$ and $\\log(\\kappa)=0$, which should yield $p_{\\mathrm{est}}(1.0)=0$ exactly, providing a useful sanity check for the implementation.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef estimate_p_fdm(s, n_values):\n    \"\"\"\n    Estimates the exponent p(s) for the Finite Difference Method.\n\n    Args:\n        s (float): The fractional order.\n        n_values (list of int): List of numbers of interior grid points.\n\n    Returns:\n        float: The estimated exponent p_est(s).\n    \"\"\"\n    log_h_vals = []\n    log_kappa_vals = []\n\n    for n in n_values:\n        h = 1.0 / (n + 1)\n        \n        # For s=1.0, the preconditioned operator is the identity, kappa=1.\n        if s == 1.0:\n            kappa = 1.0\n        else:\n            # Construct the FDM Laplacian matrix A.\n            # A = (1/h^2) * tridiag(-1, 2, -1)\n            main_diag = 2.0 * np.ones(n)\n            off_diag = -1.0 * np.ones(n - 1)\n            A = (1 / h**2) * (np.diag(main_diag) + np.diag(off_diag, k=1) + np.diag(off_diag, k=-1))\n            \n            # Eigenvalues of A. eigvalsh is efficient for symmetric matrices.\n            eigenvalues = np.linalg.eigvalsh(A)\n            lambda_min = eigenvalues[0]\n            lambda_max = eigenvalues[-1]\n            \n            # Condition number of the preconditioned operator.\n            kappa = (lambda_max / lambda_min)**(1.0 - s)\n        \n        log_h_vals.append(np.log(h))\n        log_kappa_vals.append(np.log(kappa))\n        \n    # Perform linear least-squares fit: log(kappa) = m * log(h) + c\n    # The slope m is -p_est.\n    coeffs = np.polyfit(log_h_vals, log_kappa_vals, 1)\n    p_est = -coeffs[0]\n    \n    return p_est\n\ndef estimate_p_fem(s, Ne_values):\n    \"\"\"\n    Estimates the exponent p(s) for the Finite Element Method.\n\n    Args:\n        s (float): The fractional order.\n        Ne_values (list of int): List of numbers of elements.\n\n    Returns:\n        float: The estimated exponent p_est(s).\n    \"\"\"\n    log_h_vals = []\n    log_kappa_vals = []\n\n    for Ne in Ne_values:\n        N = Ne - 1\n        h = 1.0 / Ne\n        \n        if s == 1.0:\n            kappa = 1.0\n        else:\n            # Construct the stiffness matrix K and mass matrix M.\n            # K = (1/h) * tridiag(-1, 2, -1)\n            main_diag_K = 2.0 * np.ones(N)\n            off_diag_K = -1.0 * np.ones(N - 1)\n            K = (1 / h) * (np.diag(main_diag_K) + np.diag(off_diag_K, k=1) + np.diag(off_diag_K, k=-1))\n            \n            # M = (h/6) * tridiag(1, 4, 1)\n            main_diag_M = 4.0 * np.ones(N)\n            off_diag_M = 1.0 * np.ones(N - 1)\n            M = (h / 6.0) * (np.diag(main_diag_M) + np.diag(off_diag_M, k=1) + np.diag(off_diag_M, k=-1))\n            \n            # Solve the generalized eigenvalue problem K*v = lambda*M*v.\n            # eigh is suitable for symmetric/Hermitian matrices.\n            eigenvalues = eigh(K, M, eigvals_only=True)\n            lambda_min = eigenvalues[0]\n            lambda_max = eigenvalues[-1]\n            \n            # Condition number of the preconditioned operator.\n            kappa = (lambda_max / lambda_min)**(1.0 - s)\n            \n        log_h_vals.append(np.log(h))\n        log_kappa_vals.append(np.log(kappa))\n        \n    # Perform linear least-squares fit.\n    coeffs = np.polyfit(log_h_vals, log_kappa_vals, 1)\n    p_est = -coeffs[0]\n    \n    return p_est\n\ndef solve():\n    \"\"\"\n    Main function to run the analysis and print the final results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (method, s_value, mesh_sizes)\n        (\"FDM\", 0.25, [63, 127, 255]),\n        (\"FDM\", 0.50, [63, 127, 255]),\n        (\"FDM\", 0.75, [63, 127, 255]),\n        (\"FDM\", 1.00, [63, 127, 255]),\n        (\"FEM\", 0.25, [64, 128, 256]),\n        (\"FEM\", 0.50, [64, 128, 256]),\n        (\"FEM\", 0.75, [64, 128, 256]),\n        (\"FEM\", 1.00, [64, 128, 256]),\n    ]\n    \n    tolerance = 0.3\n    results = []\n\n    for method, s, meshes in test_cases:\n        p_th = 2.0 * (1.0 - s)\n        \n        if method == \"FDM\":\n            p_est = estimate_p_fdm(s, meshes)\n        elif method == \"FEM\":\n            p_est = estimate_p_fem(s, meshes)\n        else:\n            # This case should not be reached with the current test_cases setup.\n            raise ValueError(\"Unknown method specified.\")\n            \n        match = abs(p_est - p_th) = tolerance\n        results.append(match)\n\n    # Final print statement in the exact required format.\n    # str(True) -> 'True', str(False) -> 'False' which is correct for boolean values in the output\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3381280"}]}