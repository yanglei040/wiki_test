{"hands_on_practices": [{"introduction": "Before applying a numerical method to complex problems, it is essential to verify its fundamental properties. This first practice provides a foundational exercise in code verification for the MUSCL reconstruction technique. By applying the reconstruction to a simple, smooth sine wave, you will numerically confirm the scheme's theoretical second-order accuracy, a critical step in building confidence in any numerical implementation [@problem_id:3403631].", "problem": "Consider the one-dimensional reconstruction problem for a smooth scalar field $u(x)$ on a periodic domain $[0,L]$ with $L=2\\pi$. Let $u(x)=\\sin(kx)$ for fixed wavenumber $k>0$. In a uniform finite volume mesh with $N$ cells and mesh width $\\Delta x = L/N$, denote the cell $i$ by the interval $[x_{i-\\frac{1}{2}},x_{i+\\frac{1}{2}}]$ with center $x_i=\\left(i+\\frac{1}{2}\\right)\\Delta x$, where $i\\in\\{0,1,\\dots,N-1\\}$ and periodic indexing is imposed. The cell average is defined by $u_i=\\frac{1}{\\Delta x}\\int_{x_{i-\\frac{1}{2}}}^{x_{i+\\frac{1}{2}}}u(x)\\,\\mathrm{d}x$. In the Monotone Upstream-centered Schemes for Conservation Laws (MUSCL) framework, a piecewise linear reconstruction within each cell is built using a limited slope $s_i$ so that the left and right interface states $u_{i+\\frac{1}{2}}^{-}$ and $u_{i+\\frac{1}{2}}^{+}$ are\n$$\nu_{i+\\frac{1}{2}}^{-} = u_i + \\frac{\\Delta x}{2}\\,s_i,\\qquad\nu_{i+\\frac{1}{2}}^{+} = u_{i+1} - \\frac{\\Delta x}{2}\\,s_{i+1},\n$$\nwith periodic indexing for $i+1$. Use the Monotonized Central limiter, which for smooth $u$ is Total Variation Diminishing (TVD) and defined via the minmod function. Let the one-sided and centered discrete slopes be\n$$\n\\delta^-_i = \\frac{u_i - u_{i-1}}{\\Delta x},\\quad\n\\delta^+_i = \\frac{u_{i+1} - u_{i}}{\\Delta x},\\quad\n\\delta^c_i = \\frac{u_{i+1} - u_{i-1}}{2\\,\\Delta x},\n$$\nand define the limited slope $s_i$ by\n$$\ns_i = \\operatorname{minmod}\\!\\left(\\delta^c_i,\\,2\\,\\delta^-_i,\\,2\\,\\delta^+_i\\right),\n$$\nwhere the three-argument minmod function is\n$$\n\\operatorname{minmod}(a,b,c)=\n\\begin{cases}\n\\operatorname{sign}(a)\\,\\min\\{|a|,|b|,|c|\\}, & \\text{if } \\operatorname{sign}(a)=\\operatorname{sign}(b)=\\operatorname{sign}(c),\\\\\n0, & \\text{otherwise}.\n\\end{cases}\n$$\nDefine the exact interface locations $x_{i+\\frac{1}{2}} = (i+1)\\Delta x$. The interface reconstruction error is measured in a discrete $L^2$ sense by combining both the left and right reconstructed states against the exact pointwise value $u(x_{i+\\frac{1}{2}})$:\n$$\nE(\\Delta x) = \\left( \\frac{1}{N}\\sum_{i=0}^{N-1}\\frac{1}{2}\\left[\\left(u_{i+\\frac{1}{2}}^{-}-u(x_{i+\\frac{1}{2}})\\right)^2 + \\left(u_{i+\\frac{1}{2}}^{+}-u(x_{i+\\frac{1}{2}})\\right)^2\\right] \\right)^{\\frac{1}{2}}.\n$$\nYour task is to perform a consistency check by reconstructing $u(x)=\\sin(kx)$ using the MUSCL procedure described above and computing $E(\\Delta x)$ for multiple mesh widths $\\Delta x$ at fixed $k$. Then, estimate the observed order of accuracy $p$ by fitting the model $E(\\Delta x)\\approx C\\,\\Delta x^{p}$, i.e., perform a least-squares fit of $\\log(E(\\Delta x))$ versus $\\log(\\Delta x)$ and report the slope $p$.\n\nStart from fundamental definitions: the finite volume cell average and the MUSCL reconstruction with a TVD limiter. Do not use any formulas other than those implied by these definitions and the given $u(x)$ to derive the expected scaling. Use periodic boundary conditions to define $u_{-1}=u_{N-1}$ and $u_N=u_0$ wherever needed. The program should compute the exact cell averages analytically from $u(x)=\\sin(kx)$.\n\nTest Suite:\n- Case $1$: $k=3$, $N\\in\\{16,32,64,128\\}$.\n- Case $2$: $k=1$, $N\\in\\{20,40,80,160\\}$.\n- Case $3$: $k=8$, $N\\in\\{64,128,256,512\\}$.\n\nFor each case, compute $E(\\Delta x)$ for the listed values of $N$, fit the order $p$, and return the list $[p_1,p_2,p_3]$ corresponding to the three cases. The final answer must be expressed as a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[p_1,p_2,p_3]$). All quantities are nondimensional; no physical units are involved and no angle units need to be specified. The output values $p_1$, $p_2$, and $p_3$ must be floating-point numbers.", "solution": "The objective of this problem is to perform a numerical experiment to determine the observed order of accuracy for a Monotone Upstream-centered Schemes for Conservation Laws (MUSCL) spatial reconstruction procedure. The reconstruction is applied to a smooth scalar field, $u(x)=\\sin(kx)$, on a one-dimensional periodic domain. The order of accuracy, $p$, is determined by fitting the computed reconstruction error, $E$, to a power-law model of the form $E(\\Delta x) \\approx C(\\Delta x)^p$, where $\\Delta x$ is the grid spacing. The analysis will proceed by first deriving the necessary analytical expressions, then outlining the algorithmic steps for the reconstruction and error calculation, and finally describing the method for estimating $p$.\n\n**1. Analytical Cell Averages**\n\nThe foundation of a finite volume method is the cell average. For cell $i$, defined by the interval $[x_{i-\\frac{1}{2}}, x_{i+\\frac{1}{2}}]$, the cell average $u_i$ of the field $u(x)$ is given by\n$$u_i = \\frac{1}{\\Delta x} \\int_{x_{i-\\frac{1}{2}}}^{x_{i+\\frac{1}{2}}} u(x) \\, \\mathrm{d}x.$$\nThe problem defines a uniform mesh on the domain $[0, L]$ with $L=2\\pi$ and $N$ cells, such that the mesh width is $\\Delta x = L/N = 2\\pi/N$. The cell interfaces are located at $x_{i+\\frac{1}{2}} = (i+1)\\Delta x$ for $i \\in \\{-1, 0, \\dots, N-1\\}$. Consequently, cell $i$ spans the interval $[i\\Delta x, (i+1)\\Delta x]$. The cell center is $x_i = (i+\\frac{1}{2})\\Delta x$.\n\nSubstituting $u(x) = \\sin(kx)$ and the integration limits, we compute the integral analytically:\n$$u_i = \\frac{1}{\\Delta x} \\int_{i\\Delta x}^{(i+1)\\Delta x} \\sin(kx) \\, \\mathrm{d}x = \\frac{1}{\\Delta x} \\left[ -\\frac{1}{k} \\cos(kx) \\right]_{i\\Delta x}^{(i+1)\\Delta x}.$$\nEvaluating the expression at the limits yields\n$$u_i = -\\frac{1}{k\\Delta x} \\left[ \\cos(k(i+1)\\Delta x) - \\cos(ki\\Delta x) \\right].$$\nUsing the trigonometric identity $\\cos(A) - \\cos(B) = -2\\sin\\left(\\frac{A+B}{2}\\right)\\sin\\left(\\frac{A-B}{2}\\right)$, we can simplify this expression. Let $A=k(i+1)\\Delta x$ and $B=ki\\Delta x$. Then $\\frac{A+B}{2} = k(i+\\frac{1}{2})\\Delta x = kx_i$ and $\\frac{A-B}{2} = \\frac{k\\Delta x}{2}$.\nSubstituting these into the formula for $u_i$ gives\n$$u_i = -\\frac{1}{k\\Delta x} \\left[ -2\\sin(kx_i)\\sin\\left(\\frac{k\\Delta x}{2}\\right) \\right] = \\sin(kx_i) \\cdot \\frac{\\sin(k\\Delta x/2)}{k\\Delta x/2}.$$\nThis exact formula for the cell averages, $u_i$, will be used to initialize the discrete data for the reconstruction procedure for any given $k$ and $N$.\n\n**2. MUSCL Reconstruction with Monotonized Central Limiter**\n\nThe MUSCL scheme constructs a piecewise linear approximation of $u(x)$ within each cell $i$, of the form $u_i(x) = u_i + s_i(x-x_i)$. The key component is the limited slope, $s_i$, which is designed to prevent spurious oscillations. The procedure for calculating $s_i$ and the reconstructed interface values is as follows.\n\nFirst, for each cell $i \\in \\{0, 1, \\dots, N-1\\}$, we compute three different finite difference approximations to the slope using the cell averages $\\{u_j\\}$:\n- Backward difference: $\\delta^-_i = \\frac{u_i - u_{i-1}}{\\Delta x}$\n- Forward difference: $\\delta^+_i = \\frac{u_{i+1} - u_i}{\\Delta x}$\n- Centered difference: $\\delta^c_i = \\frac{u_{i+1} - u_{i-1}}{2\\Delta x}$\nPeriodic boundary conditions are imposed, such that $u_{-1}=u_{N-1}$ and $u_N=u_0$.\n\nNext, the Monotonized Central (MC) limiter is applied to these slopes to obtain the final limited slope $s_i$:\n$$s_i = \\operatorname{minmod}\\!\\left(\\delta^c_i,\\,2\\,\\delta^-_i,\\,2\\,\\delta^+_i\\right).$$\nThe three-argument $\\operatorname{minmod}$ function is defined as\n$$\n\\operatorname{minmod}(a,b,c)=\n\\begin{cases}\n\\operatorname{sign}(a)\\,\\min\\{|a|,|b|,|c|\\}, & \\text{if } \\operatorname{sign}(a)=\\operatorname{sign}(b)=\\operatorname{sign}(c),\\\\\n0, & \\text{otherwise}.\n\\end{cases}\n$$\nThis limiter generally selects the centered difference slope in smooth regions of the solution, which yields second-order accuracy. However, near local extrema, the signs of the one-sided differences may oppose, causing the $\\operatorname{minmod}$ function to return $0$. This \"flattening\" of the slope ensures the Total Variation Diminishing (TVD) property but locally reduces the accuracy.\n\nWith the limited slopes $\\{s_i\\}$ computed for all cells, the state of the solution is reconstructed at the left and right sides of each cell interface $x_{i+\\frac{1}{2}}$. The value reconstructed from cell $i$ to its right interface is denoted $u_{i+\\frac{1}{2}}^{-}$, and the value from cell $i+1$ to its left interface is denoted $u_{i+\\frac{1}{2}}^{+}$:\n$$u_{i+\\frac{1}{2}}^{-} = u_i + \\frac{\\Delta x}{2}\\,s_i$$\n$$u_{i+\\frac{1}{2}}^{+} = u_{i+1} - \\frac{\\Delta x}{2}\\,s_{i+1}$$\nAgain, periodic indexing implies $u_{N} = u_0$ and $s_{N} = s_0$ when evaluating expressions for interface $i=N-1$.\n\n**3. Error Calculation**\n\nThe accuracy of the reconstruction is quantified by comparing the reconstructed interface values to the exact pointwise values of the function $u(x)$ at the interfaces, $u(x_{i+\\frac{1}{2}})$. The error is measured using a discrete $L^2$ norm, defined as:\n$$\nE(\\Delta x) = \\left( \\frac{1}{N}\\sum_{i=0}^{N-1}\\frac{1}{2}\\left[\\left(u_{i+\\frac{1}{2}}^{-}-u(x_{i+\\frac{1}{2}})\\right)^2 + \\left(u_{i+\\frac{1}{2}}^{+}-u(x_{i+\\frac{1}{2}})\\right)^2\\right] \\right)^{\\frac{1}{2}}.\n$$\nFor each test case, we compute $E(\\Delta x)$ for a sequence of decreasing mesh sizes $\\Delta x = 2\\pi/N$.\n\n**4. Estimation of the Order of Accuracy**\n\nA numerical scheme is said to be of order $p$ if its error $E$ decreases with the mesh size $\\Delta x$ according to the power law $E(\\Delta x) \\approx C(\\Delta x)^p$ for some constant $C$, as $\\Delta x \\to 0$. To estimate $p$, we can take the logarithm of this relationship:\n$$\\log(E(\\Delta x)) \\approx \\log(C) + p \\log(\\Delta x).$$\nThis shows a linear relationship between $\\log(E)$ and $\\log(\\Delta x)$, with the slope being the order of accuracy $p$. For each test case, we are given a set of $N$ values. We will compute the corresponding pairs $(\\Delta x_j, E_j)$, transform them to $(\\log(\\Delta x_j), \\log(E_j))$, and then perform a linear least-squares regression to find the slope of the best-fit line. This slope provides the estimated numerical order of accuracy, $p$. For the smooth function $u(x)=\\sin(kx)$, the MC limiter is expected to be second-order accurate, so we anticipate $p \\approx 2$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the order of accuracy for MUSCL reconstruction on a sine wave\n    for three different test cases.\n    \"\"\"\n    \n    test_cases = [\n        {'k': 3, 'N_values': [16, 32, 64, 128]},\n        {'k': 1, 'N_values': [20, 40, 80, 160]},\n        {'k': 8, 'N_values': [64, 128, 256, 512]},\n    ]\n    \n    results = []\n    \n    for case in test_cases:\n        k = case['k']\n        N_values = case['N_values']\n        \n        errors = []\n        dx_values = []\n        \n        for N in N_values:\n            L = 2.0 * np.pi\n            dx = L / N\n            dx_values.append(dx)\n            \n            # --- 1. Compute Analytical Cell Averages ---\n            i = np.arange(N)\n            x_i = (i + 0.5) * dx\n            \n            # Formula: u_i = sin(k*x_i) * (sin(k*dx/2) / (k*dx/2))\n            arg = k * dx / 2.0\n            if arg == 0:\n                sinc_term = 1.0\n            else:\n                sinc_term = np.sin(arg) / arg\n            u = np.sin(k * x_i) * sinc_term\n            \n            # --- 2. Compute Limited Slopes ---\n            # Create padded array for periodic boundaries\n            # u_padded = [u_{N-1}, u_0, ..., u_{N-1}, u_0]\n            u_im1 = np.roll(u, 1)\n            u_ip1 = np.roll(u, -1)\n            \n            # One-sided and centered slopes\n            delta_minus = (u - u_im1) / dx\n            delta_plus = (u_ip1 - u) / dx\n            delta_center = (u_ip1 - u_im1) / (2.0 * dx)\n            \n            # Vectorized minmod function for s_i\n            slopes_stack = np.stack((delta_center, 2 * delta_minus, 2 * delta_plus), axis=0)\n            signs = np.sign(slopes_stack)\n            all_same_sign = np.all(signs == signs[0, :], axis=0)\n            \n            min_mags = np.min(np.abs(slopes_stack), axis=0)\n\n            s = np.zeros(N)\n            # Apply minmod rule where signs are the same\n            s[all_same_sign] = np.sign(delta_center[all_same_sign]) * min_mags[all_same_sign]\n\n            # --- 3. Compute Interface Reconstruction and Error ---\n            # Reconstructed values at interface x_{i+1/2}\n            # u_iph_minus from cell i, u_iph_plus from cell i+1\n            u_i = u\n            s_i = s\n            s_ip1 = np.roll(s_i, -1)\n            u_ip1 = np.roll(u_i, -1)\n\n            u_iph_minus = u_i + (dx / 2.0) * s_i\n            u_iph_plus = u_ip1 - (dx / 2.0) * s_ip1\n\n            # Exact values at interfaces x_{i+1/2} = (i+1)*dx\n            x_iph = (i + 1.0) * dx\n            u_exact_iph = np.sin(k * x_iph)\n            \n            # Error calculation\n            err_sq = 0.5 * ((u_iph_minus - u_exact_iph)**2 + (u_iph_plus - u_exact_iph)**2)\n            E = np.sqrt(np.mean(err_sq))\n            errors.append(E)\n\n        # --- 4. Estimate Order of Accuracy ---\n        log_dx = np.log(np.array(dx_values))\n        log_E = np.log(np.array(errors))\n        \n        # Fit a line (polynomial of degree 1) to the log-log data\n        p, _ = np.polyfit(log_dx, log_E, 1)\n        results.append(p)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3403631"}, {"introduction": "When extending numerical schemes from single scalar equations to systems like the Euler equations of gas dynamics, new subtleties arise. The choice of variables in which to apply the limiting procedure is critical and must be informed by the physics of the system. This practice uses a carefully constructed thought experiment to demonstrate why applying limiters to conserved variables can introduce non-physical errors, while limiting in characteristic space—which aligns with the underlying wave structure—preserves key physical properties like pressure equilibrium across a contact discontinuity [@problem_id:3403607].", "problem": "Consider the one-dimensional compressible Euler equations for an ideal gas,\n$$\n\\partial_t U + \\partial_x F(U) = 0,\n$$\nwhere the conserved variables are $U = [\\rho, m, E]^\\top$ with mass density $\\rho$, momentum $m = \\rho u$, and total energy $E$. The flux is\n$$\nF(U) = \\begin{bmatrix}\nm \\\\\n\\frac{m^2}{\\rho} + p \\\\\n\\left(E + p\\right)\\frac{m}{\\rho}\n\\end{bmatrix},\n$$\nand the thermodynamic closure is\n$$\np = (\\gamma - 1)\\left(E - \\frac{m^2}{2 \\rho}\\right),\n$$\nwith constant ratio of specific heats $\\gamma > 1$. A pressure-equilibrium contact discontinuity is a two-state configuration in which the left and right primitive states $W_L = [\\rho_L, u_L, p_L]$ and $W_R = [\\rho_R, u_R, p_R]$ satisfy $u_L = u_R$ and $p_L = p_R$, while $\\rho_L \\ne \\rho_R$.\n\nMonotone Upstream-centered Schemes for Conservation Laws (MUSCL) achieve higher order spatial accuracy by reconstructing interface values using slopes that are limited to preserve monotonicity. A critical design choice is whether to limit in conserved-variable space $U$ or in characteristic space associated with the Jacobian $\\partial F/\\partial U$. In characteristic space, jumps are decomposed along characteristic fields, allowing limiting specifically on the contact field, which, for a pressure-equilibrium contact, has zero pressure and zero velocity jump.\n\nYour task is to demonstrate, using a purely algebraic single-interface reconstruction, that limiting in conserved-variable space can introduce a nonzero pressure jump across a contact, whereas characteristic-wise limiting that acts only on the contact field preserves pressure equilibrium. You must construct the interface value using the following two MUSCL-style reconstructions applied to a single left-right pair $(U_L, U_R)$:\n\n1. Conserved-variable reconstruction: For each conserved component $k \\in \\{\\rho, m, E\\}$, define a limited mixing coefficient $\\phi_k \\in [0,1]$ and set\n$$\nU^{\\text{cons}} = U_L + \\begin{bmatrix}\n\\phi_\\rho \\\\\n\\phi_m \\\\\n\\phi_E\n\\end{bmatrix} \\odot \\left(U_R - U_L\\right),\n$$\nwhere $\\odot$ denotes element-wise multiplication. Compute the reconstructed pressure\n$$\np^{\\text{cons}} = (\\gamma - 1) \\left(E^{\\text{cons}} - \\frac{\\left(m^{\\text{cons}}\\right)^2}{2 \\rho^{\\text{cons}}}\\right).\n$$\nReport the absolute pressure jump $|p^{\\text{cons}} - p_L|$.\n\n2. Characteristic-field reconstruction: Project the jump $dU = U_R - U_L$ onto the characteristic fields of $\\partial F/\\partial U$ linearized about $U_L$. Let $u = m_L/\\rho_L$, $p = p_L$, $a = \\sqrt{\\gamma p/\\rho_L}$ be the speed of sound, and $H = (E_L + p)/\\rho_L$ be the specific enthalpy. Define the right-eigenvectors\n$$\nr_1 = \\begin{bmatrix} 1 \\\\ u - a \\\\ H - u a \\end{bmatrix},\\quad\nr_2 = \\begin{bmatrix} 1 \\\\ u \\\\ \\tfrac{1}{2} u^2 \\end{bmatrix},\\quad\nr_3 = \\begin{bmatrix} 1 \\\\ u + a \\\\ H + u a \\end{bmatrix}.\n$$\nLet the primitive differences be\n$$\nd\\rho = \\rho_R - \\rho_L,\\quad du = \\frac{m_R - m_L - u(\\rho_R - \\rho_L)}{\\rho_L},\\quad dp = (\\gamma - 1)\\left(E_R - E_L - u(m_R - m_L) + \\tfrac{1}{2} u^2(\\rho_R - \\rho_L)\\right).\n$$\nCompute characteristic amplitudes\n$$\n\\alpha_1 = \\frac{dp - \\rho_L a\\, du}{2 a^2},\\quad\n\\alpha_2 = d\\rho - \\frac{dp}{a^2},\\quad\n\\alpha_3 = \\frac{dp + \\rho_L a\\, du}{2 a^2}.\n$$\nFor a pressure-equilibrium contact, $dp = 0$ and $du = 0$, so only the contact amplitude $\\alpha_2$ is nonzero. Define a single contact-limiter $\\phi_c \\in [0,1]$ and reconstruct\n$$\nU^{\\text{char}} = U_L + \\phi_c\\, \\alpha_2\\, r_2,\n$$\nthen compute\n$$\np^{\\text{char}} = (\\gamma - 1) \\left(E^{\\text{char}} - \\frac{\\left(m^{\\text{char}}\\right)^2}{2 \\rho^{\\text{char}}}\\right).\n$$\nReport the absolute pressure jump $|p^{\\text{char}} - p_L|$.\n\nUse the following test suite with three cases that vary the gas, contact strength, and mixing coefficients to cover different regimes. For each case provide $(\\gamma, \\rho_L, \\rho_R, u, p)$ and the conserved-variable mixing coefficients $(\\phi_\\rho, \\phi_m, \\phi_E)$ as well as the characteristic contact limiter $\\phi_c$:\n\n- Case A (general contact): $(\\gamma, \\rho_L, \\rho_R, u, p) = (1.4, 1.0, 0.125, 1.0, 1.0)$, $(\\phi_\\rho, \\phi_m, \\phi_E) = (0.5, 0.55, 0.5)$, $\\phi_c = 0.5$.\n- Case B (moderate contact at lower speed): $(\\gamma, \\rho_L, \\rho_R, u, p) = (1.4, 0.5, 2.0, 0.5, 2.0)$, $(\\phi_\\rho, \\phi_m, \\phi_E) = (0.4, 0.44, 0.4)$, $\\phi_c = 0.5$.\n- Case C (strong contact with monatomic gas): $(\\gamma, \\rho_L, \\rho_R, u, p) = (1.667, 1.0, 10.0, 0.2, 5.0)$, $(\\phi_\\rho, \\phi_m, \\phi_E) = (0.6, 0.62, 0.6)$, $\\phi_c = 0.5$.\n\nYour program must compute, for each case, the two absolute pressure jumps $|p^{\\text{cons}} - p|$ and $|p^{\\text{char}} - p|$ and produce a single line of output containing the six results as a comma-separated list enclosed in square brackets, in the order\n$$\n\\big[ |p^{\\text{cons}} - p|_{\\text{A}}, |p^{\\text{char}} - p|_{\\text{A}}, |p^{\\text{cons}} - p|_{\\text{B}}, |p^{\\text{char}} - p|_{\\text{B}}, |p^{\\text{cons}} - p|_{\\text{C}}, |p^{\\text{char}} - p|_{\\text{C}} \\big].\n$$\nAll outputs must be in decimal form with no units. No angles or percentages are involved.\n\nTo ensure universal applicability, do not use any domain-specific units; treat all quantities as nondimensional. The program must be self-contained and require no user input.\n\nThe problem is scientifically realistic: it isolates MUSCL reconstruction at a single interface and compares component-wise (conserved-variable) limiting to characteristic-field limiting for a pressure-equilibrium contact. The test suite probes a general case, a lower-speed regime, and a strong contact with a different $\\gamma$ to cover representative conditions. The answers are quantifiable floats suitable for automated verification, and the final output format is unambiguous as specified above.", "solution": "The one-dimensional compressible Euler equations in conserved form are\n$$\n\\partial_t U + \\partial_x F(U) = 0,\\quad U = [\\rho, m, E]^\\top,\\quad F(U) = \\begin{bmatrix}\nm \\\\\n\\frac{m^2}{\\rho} + p \\\\\n\\left(E + p\\right)\\frac{m}{\\rho}\n\\end{bmatrix},\n$$\nwith pressure given by the ideal gas closure\n$$\np = (\\gamma - 1)\\left(E - \\frac{m^2}{2 \\rho}\\right).\n$$\nA pressure-equilibrium contact is characterized by left and right primitive states $W_L = [\\rho_L, u_L, p_L]$ and $W_R = [\\rho_R, u_R, p_R]$ that satisfy $u_L = u_R = u$ and $p_L = p_R = p$, but $\\rho_L \\ne \\rho_R$. The corresponding conserved states are\n$$\nU_L = \\begin{bmatrix} \\rho_L \\\\ \\rho_L u \\\\ \\frac{p}{\\gamma - 1} + \\frac{1}{2} \\rho_L u^2 \\end{bmatrix},\\quad\nU_R = \\begin{bmatrix} \\rho_R \\\\ \\rho_R u \\\\ \\frac{p}{\\gamma - 1} + \\frac{1}{2} \\rho_R u^2 \\end{bmatrix}.\n$$\nWe focus on a single-interface reconstruction typical of Monotone Upstream-centered Schemes for Conservation Laws (MUSCL), where a face value is obtained by mixing the left and right cell states with limited slopes. The core question is whether limiting component-wise in conserved variables or limiting characteristic amplitudes yields a face value that preserves $p$ across a contact.\n\nPrinciple-based analysis starts by observing that the mapping from conserved variables to pressure,\n$$\np(U) = (\\gamma - 1)\\left(E - \\frac{m^2}{2 \\rho}\\right),\n$$\nis nonlinear. Therefore, a component-wise linear mix in $U$ generally produces a nonlinear change in $p$. In contrast, the characteristic fields of the Jacobian $\\partial F/\\partial U$ at a given state provide directions along which physical wave properties are isolated. For a pressure-equilibrium contact, the jump lies entirely in the contact field (the middle characteristic), which has zero pressure and zero velocity increments. Limiting only the contact amplitude preserves $p$ exactly.\n\nWe formalize these ideas for a single interface with left and right states $(U_L, U_R)$:\n\n1. Conserved-variable MUSCL reconstruction applies independent limited mixing coefficients to the components,\n$$\nU^{\\text{cons}} = U_L + \\begin{bmatrix}\n\\phi_\\rho \\\\\n\\phi_m \\\\\n\\phi_E\n\\end{bmatrix} \\odot \\left(U_R - U_L\\right),\\quad \\phi_\\rho,\\,\\phi_m,\\,\\phi_E \\in [0,1],\n$$\nwhere $\\odot$ denotes element-wise multiplication. The reconstructed pressure is\n$$\np^{\\text{cons}} = (\\gamma - 1)\\left(E^{\\text{cons}} - \\frac{\\left(m^{\\text{cons}}\\right)^2}{2 \\rho^{\\text{cons}}}\\right).\n$$\nBecause $p(U)$ is nonlinear, any mismatch between the limited mixing of momentum and mass, relative to the constraint $m = \\rho u$, or between energy and the kinetic part, relative to the constraint $E = \\frac{p}{\\gamma - 1} + \\frac{1}{2} \\rho u^2$, generically yields $p^{\\text{cons}} \\ne p$. This manifests as a spurious pressure jump $|p^{\\text{cons}} - p|$ across the reconstructed contact.\n\nTo see this from first principles, consider the pressure after mixing:\n$$\np^{\\text{cons}} = (\\gamma - 1)\\left( E_L + \\phi_E (E_R - E_L) - \\frac{\\left(m_L + \\phi_m (m_R - m_L)\\right)^2}{2\\left(\\rho_L + \\phi_\\rho (\\rho_R - \\rho_L)\\right)} \\right).\n$$\nEven if $u_L = u_R$ and $p_L = p_R$, unless $\\phi_m$ and $\\phi_\\rho$ satisfy the exact constraint $\\phi_m (m_R - m_L) = u\\,\\phi_\\rho (\\rho_R - \\rho_L)$ and $\\phi_E (E_R - E_L) = \\frac{1}{2} u^2 \\phi_\\rho (\\rho_R - \\rho_L)$, the nonlinearity in the kinetic energy term produces $p^{\\text{cons}} \\ne p$.\n\n2. Characteristic-field MUSCL reconstruction isolates wave content. The right-eigenvectors of $\\partial F/\\partial U$ at $U_L$ are\n$$\nr_1 = \\begin{bmatrix} 1 \\\\ u - a \\\\ H - u a \\end{bmatrix},\\quad\nr_2 = \\begin{bmatrix} 1 \\\\ u \\\\ \\tfrac{1}{2} u^2 \\end{bmatrix},\\quad\nr_3 = \\begin{bmatrix} 1 \\\\ u + a \\\\ H + u a \\end{bmatrix},\n$$\nwith $a = \\sqrt{\\gamma p / \\rho_L}$ the speed of sound and $H = (E_L + p)/\\rho_L$ the specific enthalpy. The jump $dU = U_R - U_L$ can be decomposed into characteristic amplitudes using primitive differences $d\\rho = \\rho_R - \\rho_L$, $du = \\frac{m_R - m_L - u(\\rho_R - \\rho_L)}{\\rho_L}$, and\n$$\ndp = (\\gamma - 1)\\left( E_R - E_L - u (m_R - m_L) + \\tfrac{1}{2} u^2 (\\rho_R - \\rho_L) \\right).\n$$\nThe standard decomposition yields\n$$\n\\alpha_1 = \\frac{dp - \\rho_L a\\, du}{2 a^2},\\quad\n\\alpha_2 = d\\rho - \\frac{dp}{a^2},\\quad\n\\alpha_3 = \\frac{dp + \\rho_L a\\, du}{2 a^2}.\n$$\nFor a pressure-equilibrium contact, $dp = 0$ and $du = 0$, so\n$$\n\\alpha_1 = 0,\\quad \\alpha_2 = d\\rho,\\quad \\alpha_3 = 0.\n$$\nLimiting only the contact amplitude with $\\phi_c \\in [0,1]$ gives\n$$\nU^{\\text{char}} = U_L + \\phi_c\\, \\alpha_2\\, r_2 = U_L + \\phi_c\\, d\\rho\\begin{bmatrix} 1 \\\\ u \\\\ \\tfrac{1}{2} u^2 \\end{bmatrix}.\n$$\nCompute the reconstructed pressure:\n$$\np^{\\text{char}} = (\\gamma - 1)\\left( E_L + \\phi_c\\, d\\rho\\, \\tfrac{1}{2} u^2 - \\frac{\\left(m_L + \\phi_c\\, d\\rho\\, u\\right)^2}{2\\left(\\rho_L + \\phi_c\\, d\\rho\\right)} \\right).\n$$\nBecause $m_L = \\rho_L u$, the kinetic term simplifies:\n$$\n\\frac{\\left(m_L + \\phi_c\\, d\\rho\\, u\\right)^2}{2\\left(\\rho_L + \\phi_c\\, d\\rho\\right)} = \\frac{\\left(u(\\rho_L + \\phi_c\\, d\\rho)\\right)^2}{2\\left(\\rho_L + \\phi_c\\, d\\rho\\right)} = \\frac{1}{2} u^2 \\left(\\rho_L + \\phi_c\\, d\\rho\\right).\n$$\nTherefore\n$$\np^{\\text{char}} = (\\gamma - 1)\\left( E_L + \\phi_c\\, d\\rho\\, \\tfrac{1}{2} u^2 - \\tfrac{1}{2} u^2 \\left(\\rho_L + \\phi_c\\, d\\rho\\right) \\right) = (\\gamma - 1)\\left( E_L - \\tfrac{1}{2} u^2 \\rho_L \\right) = p_L = p.\n$$\nThus the characteristic-field reconstruction that limits only the contact field preserves pressure exactly for a pressure-equilibrium contact, independent of $\\phi_c$.\n\nAlgorithmic design for the program:\n\n- For each test case, form $U_L$ and $U_R$ from $(\\gamma, \\rho_L, \\rho_R, u, p)$ using\n$$\nU_L = \\left[\\rho_L,\\, \\rho_L u,\\, \\frac{p}{\\gamma - 1} + \\frac{1}{2} \\rho_L u^2\\right],\\quad U_R = \\left[\\rho_R,\\, \\rho_R u,\\, \\frac{p}{\\gamma - 1} + \\frac{1}{2} \\rho_R u^2\\right].\n$$\n- Conserved-variable reconstruction: apply $(\\phi_\\rho, \\phi_m, \\phi_E)$ to $dU = U_R - U_L$ component-wise to get $U^{\\text{cons}}$, then compute $p^{\\text{cons}}$ with $p(U)$ and store $|p^{\\text{cons}} - p|$.\n- Characteristic-field reconstruction: compute $a = \\sqrt{\\gamma p/\\rho_L}$ and $H = (E_L + p)/\\rho_L$, decompose $dU$ by computing $d\\rho$, $du$, $dp$, and $\\alpha_1, \\alpha_2, \\alpha_3$ as above. For the pure contact, only $\\alpha_2$ is nonzero. Reconstruct $U^{\\text{char}} = U_L + \\phi_c\\, \\alpha_2\\, r_2$ using $r_2 = [1, u, \\tfrac{1}{2} u^2]^\\top$, compute $p^{\\text{char}}$, and store $|p^{\\text{char}} - p|$.\n- Output the six floats for the three cases in the specified order as a single line: $[|p^{\\text{cons}} - p|_{\\text{A}}, |p^{\\text{char}} - p|_{\\text{A}}, |p^{\\text{cons}} - p|_{\\text{B}}, |p^{\\text{char}} - p|_{\\text{B}}, |p^{\\text{cons}} - p|_{\\text{C}}, |p^{\\text{char}} - p|_{\\text{C}}]$.\n\nScientific realism and coverage:\n- The test cases vary $\\gamma$, contact strength $(\\rho_L, \\rho_R)$, and speed $u$, exercising the nonlinear pressure mapping and the characteristic decomposition under different regimes.\n- The conserved-variable mixing coefficients are intentionally chosen to be unequal, reflecting practical component-wise limiting that need not preserve the primitive constraints exactly; this produces spurious pressure deviations in the reconstructed state.\n- The characteristic-field reconstruction limits only the contact amplitude, which, by derivation, preserves pressure exactly for pressure-equilibrium contacts.\n- The final outputs are quantifiable floats, suitable for automated checking, and the program is self-contained.\n\nThis demonstrates from first principles why limiting in conserved variables can generate spurious oscillations across contacts, whereas characteristic-wise limiting aligned with wave physics avoids them.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef primitive_to_conserved(rho, u, p, gamma):\n    E = p / (gamma - 1.0) + 0.5 * rho * u**2\n    m = rho * u\n    return np.array([rho, m, E], dtype=float)\n\ndef pressure_from_conserved(U, gamma):\n    rho, m, E = U\n    return (gamma - 1.0) * (E - 0.5 * (m**2) / rho)\n\ndef characteristic_contact_reconstruction(U_L, U_R, gamma, phi_c):\n    # Left primitive quantities\n    rho_L, m_L, E_L = U_L\n    # Compute left pressure using closure (should match given p, but we recompute for robustness)\n    p_L = pressure_from_conserved(U_L, gamma)\n    u = m_L / rho_L\n    a = np.sqrt(gamma * p_L / rho_L)\n    H = (E_L + p_L) / rho_L\n\n    # Jump in conserved variables\n    dU = U_R - U_L\n    drho = dU[0]\n    # primitive increments linearized about left state\n    du = (dU[1] - u * drho) / rho_L\n    dp = (gamma - 1.0) * (dU[2] - u * dU[1] + 0.5 * u**2 * drho)\n\n    # Characteristic amplitudes\n    alpha1 = (dp - rho_L * a * du) / (2.0 * a**2)\n    alpha2 = drho - dp / (a**2)\n    alpha3 = (dp + rho_L * a * du) / (2.0 * a**2)\n\n    # For a pressure-equilibrium contact, dp=0 and du=0 -> alpha1=alpha3=0, alpha2=drho.\n    # Limit only the contact amplitude.\n    alpha1_l = 0.0\n    alpha2_l = phi_c * alpha2\n    alpha3_l = 0.0\n\n    # Right eigenvectors at U_L\n    r1 = np.array([1.0, u - a, H - u * a], dtype=float)\n    r2 = np.array([1.0, u, 0.5 * u**2], dtype=float)\n    r3 = np.array([1.0, u + a, H + u * a], dtype=float)\n\n    dU_limited = alpha1_l * r1 + alpha2_l * r2 + alpha3_l * r3\n    U_face = U_L + dU_limited\n    return U_face\n\ndef conserved_component_reconstruction(U_L, U_R, phi_rho, phi_m, phi_E):\n    dU = U_R - U_L\n    # Apply component-wise mixing coefficients\n    mix = np.array([phi_rho, phi_m, phi_E], dtype=float) * dU\n    U_face = U_L + mix\n    return U_face\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (gamma, rho_L, rho_R, u, p, phi_rho, phi_m, phi_E, phi_c)\n    test_cases = [\n        (1.4,   1.0,   0.125, 1.0, 1.0, 0.5, 0.55, 0.5, 0.5),     # Case A\n        (1.4,   0.5,   2.0,   0.5, 2.0, 0.4, 0.44, 0.4, 0.5),     # Case B\n        (1.667, 1.0,   10.0,  0.2, 5.0, 0.6, 0.62, 0.6, 0.5),     # Case C\n    ]\n\n    results = []\n    for case in test_cases:\n        gamma, rho_L, rho_R, u, p, phi_rho, phi_m, phi_E, phi_c = case\n\n        # Build conserved left and right states from primitives\n        U_L = primitive_to_conserved(rho_L, u, p, gamma)\n        U_R = primitive_to_conserved(rho_R, u, p, gamma)\n\n        # Conserved-variable reconstruction and pressure jump\n        U_cons = conserved_component_reconstruction(U_L, U_R, phi_rho, phi_m, phi_E)\n        p_cons = pressure_from_conserved(U_cons, gamma)\n        p_jump_cons = abs(p_cons - p)\n\n        # Characteristic-field reconstruction and pressure jump\n        U_char = characteristic_contact_reconstruction(U_L, U_R, gamma, phi_c)\n        p_char = pressure_from_conserved(U_char, gamma)\n        p_jump_char = abs(p_char - p)\n\n        # Append both results for this case\n        results.append(p_jump_cons)\n        results.append(p_jump_char)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(lambda x: f'{x:.12g}', results))}]\")\n\nsolve()\n```", "id": "3403607"}, {"introduction": "A complete numerical solver involves integrating a spatial reconstruction, like MUSCL, with a time-stepping scheme and boundary conditions. However, the performance of such a solver is highly sensitive to parameter choices, particularly the type of slope limiter used. This final practice is a comprehensive study that challenges you to evaluate the trade-offs between accuracy, sharpness, and robustness by testing a full MUSCL-Hancock solver with different limiter settings on a suite of canonical problems, ranging from smooth waves to sharp shocks [@problem_id:3403590].", "problem": "You are to design and implement a program that evaluates the sensitivity of higher-order Monotone Upstream-centered Schemes for Conservation Laws (MUSCL) solutions to limiter parameters on a suite of initial data for scalar conservation laws. The focus is to quantify the tradeoff between accuracy and robustness as the limiter parameter varies.\n\nFundamental base and problem setup:\n- Consider a scalar conservation law in one space dimension, written as $u_t + f(u)_x = 0$, where $u(x,t)$ is the conserved quantity and $f(u)$ is the flux function.\n- Implement a second-order, Total Variation Diminishing (TVD) MUSCL-Hancock finite volume scheme that reconstructs piecewise linear profiles in each cell with a slope limiter. The limiter is parameterized by a real number $\\theta \\in [1,2]$ within a generalized minmod family, controlling compressiveness of reconstructions.\n- Use a robust approximate Riemann solver to compute intercell numerical fluxes based on left and right reconstructed states at half time-step; for example, a local Lax–Friedrichs (Rusanov) flux consistent with the conservation law and characteristic speeds.\n- Enforce Courant–Friedrichs–Lewy (CFL) stability by selecting the time step $\\Delta t$ such that $\\mathrm{CFL} \\leq 1$, based on the maximum characteristic speed $|f'(u)|$.\n\nInitial data suite and governing equations:\n- Case 1 (smooth wave, linear advection): Evolve $u_t + a\\,u_x = 0$ with $a = 1$ on the periodic domain $x \\in [0,1]$, starting from $u(x,0) = \\sin(2\\pi x)$, to final time $T = 1.0$. The exact solution is the advected wave $u(x,T) = \\sin\\big(2\\pi(x - aT)\\big)$.\n- Case 2 (contact discontinuity, linear advection): Evolve $u_t + a\\,u_x = 0$ with $a = 1$ on the periodic domain $x \\in [0,1]$, starting from a step $u(x,0) = 1$ for $x  0.5$ and $u(x,0) = 0$ for $x \\ge 0.5$, to final time $T = 0.25$. The exact solution is the translated step $u(x,T) = 1$ if $(x - aT) \\bmod 1  0.5$ and $u(x,T) = 0$ otherwise.\n- Case 3 (shock, inviscid Burgers): Evolve $u_t + \\left(\\tfrac{1}{2}u^2\\right)_x = 0$ on the nonperiodic domain $x \\in [-1,1]$, starting from a Riemann-type step $u(x,0) = 1$ for $x  0$ and $u(x,0) = 0$ for $x \\ge 0$, with transmissive (zero-gradient) boundary conditions, to final time $T = 0.5$. The exact solution is a shock traveling at speed $s = \\frac{f(1)-f(0)}{1-0} = \\tfrac{1}{2}$, yielding $u(x,T) = 1$ for $x  sT$ and $u(x,T) = 0$ otherwise.\n\nLimiter parameter sensitivity:\n- Use the generalized minmod limiter parameter $\\theta \\in \\{1.0, 1.5, 2.0\\}$, spanning from most diffusive to more compressive reconstructions within the Sweby-family characteristics. For each case and each $\\theta$, run the MUSCL-Hancock scheme to $T$ with an appropriate CFL number.\n\nMetrics to quantify accuracy versus robustness:\n- Accuracy metrics:\n  - The discrete $L^1$ error at final time: approximate $\\int |u_{\\text{num}}(x,T) - u_{\\text{exact}}(x,T)|\\,dx$ by the grid sum with spacing $\\Delta x$.\n  - The discrete $L^\\infty$ error at final time: the maximum absolute difference over all grid points.\n- Robustness metrics:\n  - The total variation ratio $\\mathrm{TV}(u(\\cdot,T))/\\mathrm{TV}(u(\\cdot,0))$, where total variation is computed as the sum of absolute nearest-neighbor jumps, using periodic wrap in periodic cases and no wrap in the nonperiodic case.\n  - The overshoot magnitude relative to known bounds, defined as $\\max\\{0, \\max(u) - u_{\\max}^{\\text{bound}}\\} + \\max\\{0, u_{\\min}^{\\text{bound}} - \\min(u)\\}$ at final time. For Case 1, use bounds $[-1,1]$; for Cases 2 and 3, use bounds $[0,1]$.\n\nDiscretization and parameters:\n- Use uniform grids of $N = 400$ cells for Cases 1 and 2 on $[0,1]$, and $N = 800$ cells for Case 3 on $[-1,1]$.\n- Use a Courant number of $\\mathrm{CFL} = 0.45$.\n- For the linear advection cases, adopt periodic boundary conditions; for Burgers, adopt transmissive (zero-gradient) boundary conditions.\n\nTest suite:\n- The test suite consists of the three cases above combined with the three limiter parameter values $\\theta \\in \\{1.0, 1.5, 2.0\\}$, totaling nine runs. For each run, compute the four metrics as unitless floats.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The outer list must have three entries (one per case), each being a list of three entries (one per limiter parameter), each being a list of four floats in the order $[L^1, L^\\infty, \\mathrm{TV\\ ratio}, \\mathrm{overshoot}]$. For example, an output will have the shape\n$[[[\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot]],[[\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot]],[[\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot]]]$.\n\nAll answers are unitless and must be reported as floats. Angles are not involved. Do not use percentage signs; ratios should be plain decimal numbers.", "solution": "The user has provided a well-posed and scientifically grounded problem in the field of numerical solutions to partial differential equations. The task is to implement a specific numerical scheme and use it to study the effect of a parameter on solution quality for a set of canonical test cases. The problem is valid, and a full solution can be constructed.\n\nThe problem requires the implementation of a second-order, Total Variation Diminishing (TVD) MUSCL-Hancock finite volume scheme to solve the one-dimensional scalar conservation law:\n$$\n\\frac{\\partial u}{\\partial t} + \\frac{\\partial f(u)}{\\partial x} = 0\n$$\nwhere $u(x,t)$ is the conserved quantity and $f(u)$ is the flux function.\n\nThe finite volume method discretizes the domain into cells and evolves the cell-averaged quantity $U_i(t) \\approx \\frac{1}{\\Delta x} \\int_{x_{i-1/2}}^{x_{i+1/2}} u(x,t) dx$. The semi-discrete form of the conservation law is:\n$$\n\\frac{dU_i}{dt} = -\\frac{1}{\\Delta x} \\left( F_{i+1/2} - F_{i-1/2} \\right)\n$$\nwhere $F_{i+1/2}$ is the numerical flux at the interface between cell $i$ and cell $i+1$.\n\nThe MUSCL-Hancock scheme achieves second-order accuracy in both space and time through a predictor-corrector approach.\n\n**1. Spatial Reconstruction (Second-Order Space)**\n\nWithin each cell $i$, a piecewise linear function is reconstructed from the cell average $U_i^n$ at time $t_n$:\n$$\nu_i(x, t_n) = U_i^n + \\frac{s_i}{\\Delta x}(x - x_i)\n$$\nwhere $x_i$ is the center of cell $i$ and $s_i$ is a limited slope (or, more accurately, a limited difference). To maintain the TVD property and prevent spurious oscillations near discontinuities, the slope must be limited. The problem specifies a generalized minmod limiter parameterized by $\\theta \\in [1,2]$. The limited difference $s_i$ is calculated as:\n$$\ns_i = \\text{minmod}\\left(\\theta \\Delta U_{i-\\frac{1}{2}}, \\frac{1}{2}(\\Delta U_{i-\\frac{1}{2}} + \\Delta U_{i+\\frac{1}{2}}), \\theta \\Delta U_{i+\\frac{1}{2}}\\right)\n$$\nwhere $\\Delta U_{i-\\frac{1}{2}} = U_i^n - U_{i-1}^n$ and $\\Delta U_{i+\\frac{1}{2}} = U_{i+1}^n - U_i^n$ are the backward and forward differences, respectively. The $\\text{minmod}$ function returns its argument with the smallest magnitude if all arguments have the same sign, and zero otherwise. A value of $\\theta=1$ corresponds to the most diffusive standard minmod limiter, while $\\theta=2$ (corresponding to the SUPERBEE limiter) is more compressive, aiming to sharpen discontinuities.\n\n**2. Predictor Step (Half-Time Step Evolution)**\n\nThe MUSCL-Hancock method uses a predictor step to evolve the reconstructed states at the cell boundaries to the half-time level $t_{n+1/2} = t_n + \\Delta t/2$. For each cell $i$, we define the left and right states at its boundaries at time $t_n$:\n$$\nu_{i, L}^n = U_i^n - \\frac{s_i}{2} \\quad \\text{and} \\quad u_{i, R}^n = U_i^n + \\frac{s_i}{2}\n$$\nThese states are then evolved over $\\Delta t/2$ using the conservation law itself as a predictor:\n$$\nu_{i, L/R}^* = u_{i, L/R}^n - \\frac{\\Delta t}{2\\Delta x} \\left( f(u_{i, R}^n) - f(u_{i, L}^n) \\right)\n$$\nThese predicted states, $u_{i, L}^*$ and $u_{i, R}^*$, are second-order accurate approximations of the solution at the cell boundaries at the half-time level.\n\n**3. Flux Calculation and Corrector Step**\n\nThe numerical flux $F_{i+1/2}$ at each interface is now computed using a Riemann solver with the predicted states from the adjacent cells as input. At interface $x_{i+1/2}$, the left state is $u_{i, R}^*$ (from cell $i$) and the right state is $u_{i+1, L}^*$ (from cell $i+1$).\n\nThe problem specifies the local Lax-Friedrichs (or Rusanov) flux:\n$$\nF(u_L, u_R) = \\frac{1}{2} \\left[ f(u_L) + f(u_R) \\right] - \\frac{1}{2} \\alpha(u_R - u_L)\n$$\nwhere the dissipation coefficient $\\alpha$ is the maximum local characteristic speed, $\\alpha = \\max(|f'(u_L)|, |f'(u_R)|)$.\nThus, the flux at interface $x_{i+1/2}$ is:\n$$\nF_{i+1/2} = F(u_{i, R}^*, u_{i+1, L}^*)\n$$\nFinally, the corrector step updates the cell averages to the new time level $t_{n+1} = t_n + \\Delta t$:\n$$\nU_i^{n+1} = U_i^n - \\frac{\\Delta t}{\\Delta x} \\left( F_{i+1/2} - F_{i-1/2} \\right)\n$$\nThe time step $\\Delta t$ is dynamically chosen at each step to satisfy the Courant-Friedrichs-Lewy (CFL) condition:\n$$\n\\Delta t = \\text{CFL} \\frac{\\Delta x}{\\max_j |f'(U_j^n)|}\n$$\nwith $\\text{CFL} = 0.45$ as specified.\n\n**4. Boundary Conditions**\n\n- **Periodic:** For Cases 1 and 2, ghost cells are used to wrap the domain. For a grid of $N$ cells indexed $0, \\ldots, N-1$, the neighbors of cell $0$ are cell $N-1$ and cell $1$. The neighbors of cell $N-1$ are cell $N-2$ and cell $0$.\n- **Transmissive (Zero-Gradient):** For Case 3, ghost cells outside the domain are set to the value of the nearest interior cell. At the left boundary, $U_{-1} = U_0$, and at the right boundary, $U_N = U_{N-1}$. This choice results in a zero slope at the boundary cells, preventing spurious waves from reflecting into the domain.\n\n**5. Test Cases and Metrics**\n\nThe implementation is tested on three cases: linear advection of a smooth profile, linear advection of a discontinuity, and the formation of a shock in the inviscid Burgers' equation. For each case and for each value of $\\theta \\in \\{1.0, 1.5, 2.0\\}$, four metrics are calculated:\n1.  **$L^1$ Error:** $\\sum_i |U_i(T) - u_{\\text{exact}}(x_i, T)| \\Delta x$.\n2.  **$L^\\infty$ Error:** $\\max_i |U_i(T) - u_{\\text{exact}}(x_i, T)|$.\n3.  **Total Variation Ratio:** $\\mathrm{TV}(U(T)) / \\mathrm{TV}(U(0))$, where $\\mathrm{TV}(U) = \\sum_i |U_{i+1} - U_i|$ (with periodic wrap-around where appropriate).\n4.  **Overshoot:** The sum of any excursions outside the known physical bounds of the exact solution.\n\nThis comprehensive evaluation framework allows for a quantitative analysis of the trade-off between accuracy (lower errors), sharpness (TV ratio closer to $1$), and robustness (no overshoots) as a function of the limiter parameter $\\theta$.", "answer": "```python\nimport numpy as np\nimport sys\n\n# Ensure platform-independent floating point representation\nif sys.version_info  (3, 9):\n    # This is a fallback for older Python versions, though problem states 3.12\n    # Standard repr might be sufficient, but this can help with cross-platform consistency\n    pass \nnp.set_printoptions(precision=16)\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation suite and generate the final output.\n    \"\"\"\n\n    test_cases_params = [\n        {\n            \"case_id\": 1,\n            \"N\": 400,\n            \"domain\": (0.0, 1.0),\n            \"T\": 1.0,\n            \"bc\": \"periodic\",\n            \"bounds\": (-1.0, 1.0),\n            \"ic_func\": lambda x: np.sin(2 * np.pi * x),\n            \"exact_sol_func\": lambda x, t: np.sin(2 * np.pi * (x - 1.0 * t)),\n            \"flux_func\": lambda u: 1.0 * u,\n            \"flux_prime_func\": lambda u: np.ones_like(u) if isinstance(u, np.ndarray) else 1.0,\n        },\n        {\n            \"case_id\": 2,\n            \"N\": 400,\n            \"domain\": (0.0, 1.0),\n            \"T\": 0.25,\n            \"bc\": \"periodic\",\n            \"bounds\": (0.0, 1.0),\n            \"ic_func\": lambda x: (x  0.5).astype(float),\n            \"exact_sol_func\": lambda x, t: (((x - 1.0 * t) % 1.0)  0.5).astype(float),\n            \"flux_func\": lambda u: 1.0 * u,\n            \"flux_prime_func\": lambda u: np.ones_like(u) if isinstance(u, np.ndarray) else 1.0,\n        },\n        {\n            \"case_id\": 3,\n            \"N\": 800,\n            \"domain\": (-1.0, 1.0),\n            \"T\": 0.5,\n            \"bc\": \"transmissive\",\n            \"bounds\": (0.0, 1.0),\n            \"ic_func\": lambda x: (x  0.0).astype(float),\n            \"exact_sol_func\": lambda x, t: (x  0.5 * t).astype(float),\n            \"flux_func\": lambda u: 0.5 * u**2,\n            \"flux_prime_func\": lambda u: u,\n        },\n    ]\n\n    thetas = [1.0, 1.5, 2.0]\n    CFL = 0.45\n    all_results = []\n\n    for params in test_cases_params:\n        case_results = []\n        for theta in thetas:\n            metrics = run_simulation(params, theta, CFL)\n            case_results.append(metrics)\n        all_results.append(case_results)\n\n    # Format the output string to match the problem specification\n    output_str = repr(all_results).replace(\" \", \"\")\n    print(output_str)\n\ndef minmod_vec(a, b, c):\n    \"\"\"\n    Vectorized minmod function for three numpy arrays.\n    \"\"\"\n    # Stack arrays for vectorized min/max operations\n    stacked = np.stack([a, b, c], axis=0)\n    min_vals = np.min(stacked, axis=0)\n    max_vals = np.max(stacked, axis=0)\n    \n    # Mask for where all arguments have the same sign (or are zero)\n    same_sign_mask = (min_vals * max_vals) = 0\n    \n    res = np.zeros_like(a, dtype=float)\n    \n    # All positive or zero case\n    pos_mask = same_sign_mask  (min_vals = 0)\n    res[pos_mask] = min_vals[pos_mask]\n    \n    # All negative or zero case\n    neg_mask = same_sign_mask  (max_vals = 0)\n    res[neg_mask] = max_vals[neg_mask]\n    \n    return res\n\n\ndef run_simulation(params, theta, CFL):\n    \"\"\"\n    Runs a single simulation for a given case and limiter parameter.\n    \"\"\"\n    N = params[\"N\"]\n    x_min, x_max = params[\"domain\"]\n    dx = (x_max - x_min) / N\n    x = np.linspace(x_min + dx / 2, x_max - dx / 2, N)\n\n    U = params[\"ic_func\"](x)\n    U_initial = U.copy()\n    t = 0.0\n\n    flux_func = params[\"flux_func\"]\n    flux_prime_func = params[\"flux_prime_func\"]\n\n    while t  params[\"T\"]:\n        # Determine max wave speed for CFL condition\n        max_speed = np.max(np.abs(flux_prime_func(U)))\n        if max_speed == 0:\n            max_speed = 1.0 # Avoid division by zero in static cases\n            \n        dt = CFL * dx / max_speed\n        if t + dt  params[\"T\"]:\n            dt = params[\"T\"] - t\n        dtdx = dt/dx\n        \n        # Apply boundary conditions using ghost cells\n        if params[\"bc\"] == \"periodic\":\n            U_ext = np.concatenate(([U[-1]], U, [U[0]]))\n        else: # transmissive\n            U_ext = np.concatenate(([U[0]], U, [U[-1]]))\n\n        # 1. Slope reconstruction\n        delta_m = U_ext[1:-1] - U_ext[:-2]\n        delta_p = U_ext[2:] - U_ext[1:-1]\n        delta_c = 0.5 * (delta_m + delta_p)\n        s = minmod_vec(theta * delta_m, delta_c, theta * delta_p)\n\n        # 2. Predictor Step\n        u_L_in_cell = U - s / 2\n        u_R_in_cell = U + s / 2\n        \n        evol_term = 0.5 * dtdx * (flux_func(u_R_in_cell) - flux_func(u_L_in_cell))\n        \n        u_L_star = u_L_in_cell - evol_term\n        u_R_star = u_R_in_cell - evol_term\n\n        # 3. Flux Calculation at interfaces\n        # Form arrays of left and right states for all N+1 interfaces\n        u_L_at_iface = np.zeros(N + 1)\n        u_R_at_iface = np.zeros(N + 1)\n        \n        # Internal interfaces\n        u_L_at_iface[1:N] = u_R_star[:-1]\n        u_R_at_iface[1:N] = u_L_star[1:]\n\n        # Boundary interfaces\n        if params[\"bc\"] == \"periodic\":\n            u_L_at_iface[0] = u_R_star[-1]\n            u_R_at_iface[0] = u_L_star[0]\n            u_L_at_iface[-1] = u_L_at_iface[0]\n            u_R_at_iface[-1] = u_R_at_iface[0]\n        else: # transmissive BC logic\n            # Left boundary: slope is 0 in ghost cell - u_star = U[0]\n            u_L_at_iface[0] = U[0]\n            u_R_at_iface[0] = u_L_star[0]\n            # Right boundary: slope is 0 in ghost cell - u_star = U[-1]\n            u_L_at_iface[-1] = u_R_star[-1]\n            u_R_at_iface[-1] = U[-1]\n\n        # Rusanov flux\n        alpha = np.maximum(np.abs(flux_prime_func(u_L_at_iface)), \n                           np.abs(flux_prime_func(u_R_at_iface)))\n        F_iface = 0.5 * (flux_func(u_L_at_iface) + flux_func(u_R_at_iface)) \\\n                  - 0.5 * alpha * (u_R_at_iface - u_L_at_iface)\n        \n        # 4. Corrector Step (update)\n        U = U - dtdx * (F_iface[1:] - F_iface[:-1])\n        t += dt\n\n    # Calculate metrics\n    U_exact_final = params[\"exact_sol_func\"](x, params[\"T\"])\n    \n    # L1 and L-infinity errors\n    l1_error = np.sum(np.abs(U - U_exact_final)) * dx\n    linf_error = np.max(np.abs(U - U_exact_final))\n\n    # Total variation ratio\n    if params[\"bc\"] == \"periodic\":\n        tv_initial = np.sum(np.abs(np.diff(np.append(U_initial, U_initial[0]))))\n        tv_final = np.sum(np.abs(np.diff(np.append(U, U[0]))))\n    else:\n        tv_initial = np.sum(np.abs(np.diff(U_initial)))\n        tv_final = np.sum(np.abs(np.diff(U)))\n\n    tv_ratio = tv_final / tv_initial if tv_initial  1e-12 else 1.0\n\n    # Overshoot\n    u_min_bound, u_max_bound = params[\"bounds\"]\n    overshoot = max(0, U.max() - u_max_bound) + max(0, u_min_bound - U.min())\n\n    return [l1_error, linf_error, tv_ratio, overshoot]\n\nif __name__ == \"__main__\":\n    solve()\n\n```", "id": "3403590"}]}