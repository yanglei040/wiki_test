{"hands_on_practices": [{"introduction": "The Discrete Maximum Principle (DMP) is not merely an abstract concept but a direct consequence of the algebraic structure of the matrix generated by a numerical discretization. This first exercise strips away the complexities of PDE discretization to focus on the essential matrix properties. By analyzing a small, explicit matrix, you will demonstrate that being symmetric and positive definite is not sufficient to guarantee the DMP, and discover that the sign pattern of the off-diagonal entries is the critical factor that leads to the stronger condition of being an M-matrix. [@problem_id:3379754]", "problem": "Consider the linear system arising from a finite difference discretization of a second-order elliptic boundary value problem on a one-dimensional uniform mesh with three interior nodes and homogeneous Dirichlet boundary conditions. Suppose the discrete operator uses the tridiagonal stencil with positive off-diagonal entries, leading to the matrix\n$$\nA \\;=\\; \\begin{pmatrix}\n2  1  0 \\\\\n1  2  1 \\\\\n0  1  2\n\\end{pmatrix}.\n$$\nStart from the fundamental definitions that a matrix is symmetric positive definite (SPD) if and only if all its leading principal minors are positive (Sylvester’s criterion), and that a discrete comparison principle for elliptic operators requires the associated stiffness matrix to be an inverse-positive matrix (for example, an $M$-matrix with nonpositive off-diagonal entries), which guarantees that nonnegative load vectors produce nonnegative discrete solutions. Without invoking any pre-packaged theorems beyond these foundational facts, do the following:\n\n1. Verify that $A$ is symmetric positive definite using Sylvester’s criterion.\n2. Compute enough of $A^{-1}$ to decide whether $A^{-1}$ is entrywise nonnegative.\n3. Interpret your findings in terms of the discrete comparison principle for elliptic operators by exhibiting a nonnegative load vector $f$ such that the discrete solution $u = A^{-1} f$ has a negative component, and explain the mechanism of failure in terms of the sign structure of $A$.\n\nYour final reported answer must be the exact value of the $(1,2)$ entry of $A^{-1}$, written as a single reduced fraction with no units. No rounding is required.", "solution": "The problem requires a multi-part analysis of the matrix $A$ in the context of discrete comparison principles for elliptic operators. The analysis will proceed in three steps as requested.\n\nFirst, the given matrix is:\n$$\nA \\;=\\; \\begin{pmatrix}\n2  1  0 \\\\\n1  2  1 \\\\\n0  1  2\n\\end{pmatrix}\n$$\nThe problem statement provides the definitions to be used: a matrix is symmetric positive definite (SPD) if it is symmetric and all its leading principal minors are positive (Sylvester's criterion). A discrete comparison principle holds if the matrix is inverse-positive (all entries of its inverse are nonnegative).\n\n1.  **Verification of Symmetric Positive Definite (SPD) Property**\n\nAccording to Sylvester's criterion, a symmetric matrix is positive definite if and only if all its leading principal minors are positive.\n\nFirst, we observe that $A$ is symmetric, since $A^T = A$.\n\nNext, we compute the leading principal minors of $A$. Let $A_k$ be the $k \\times k$ submatrix in the upper-left corner of $A$.\n\nThe first leading principal minor is the determinant of $A_1$:\n$$\n\\det(A_1) = \\det \\begin{pmatrix} 2 \\end{pmatrix} = 2\n$$\nSince $2  0$, this condition is met.\n\nThe second leading principal minor is the determinant of $A_2$:\n$$\n\\det(A_2) = \\det \\begin{pmatrix} 2  1 \\\\ 1  2 \\end{pmatrix} = (2)(2) - (1)(1) = 4 - 1 = 3\n$$\nSince $3  0$, this condition is met.\n\nThe third leading principal minor is the determinant of $A_3 = A$:\n$$\n\\det(A_3) = \\det(A) = \\det \\begin{pmatrix}\n2  1  0 \\\\\n1  2  1 \\\\\n0  1  2\n\\end{pmatrix}\n$$\nWe can compute this by cofactor expansion along the first row:\n$$\n\\det(A) = 2 \\cdot \\det \\begin{pmatrix} 2  1 \\\\ 1  2 \\end{pmatrix} - 1 \\cdot \\det \\begin{pmatrix} 1  1 \\\\ 0  2 \\end{pmatrix} + 0 = 2(3) - 1((1)(2) - (1)(0)) = 6 - 2 = 4\n$$\nSince $4  0$, this condition is also met.\n\nAll leading principal minors of the symmetric matrix $A$ are positive ($2$, $3$, and $4$). Therefore, by Sylvester's criterion, the matrix $A$ is symmetric positive definite.\n\n2.  **Computation of $A^{-1}$ to Check for Inverse-Positivity**\n\nTo determine if $A$ is inverse-positive, we must compute its inverse, $A^{-1}$. We can use the formula $A^{-1} = \\frac{1}{\\det(A)} \\text{adj}(A)$, where $\\text{adj}(A)$ is the adjugate matrix of $A$, which is the transpose of the cofactor matrix $C$.\n\nFrom the previous step, we know $\\det(A) = 4$.\n\nNow, we compute the cofactor matrix $C$, where $C_{ij} = (-1)^{i+j} M_{ij}$ and $M_{ij}$ is the minor of the entry $a_{ij}$.\n$$\nC_{11} = (-1)^{1+1} \\det \\begin{pmatrix} 2  1 \\\\ 1  2 \\end{pmatrix} = 3\n$$\n$$\nC_{12} = (-1)^{1+2} \\det \\begin{pmatrix} 1  1 \\\\ 0  2 \\end{pmatrix} = -(2-0) = -2\n$$\n$$\nC_{13} = (-1)^{1+3} \\det \\begin{pmatrix} 1  2 \\\\ 0  1 \\end{pmatrix} = 1\n$$\n$$\nC_{21} = (-1)^{2+1} \\det \\begin{pmatrix} 1  0 \\\\ 1  2 \\end{pmatrix} = -(2-0) = -2\n$$\n$$\nC_{22} = (-1)^{2+2} \\det \\begin{pmatrix} 2  0 \\\\ 0  2 \\end{pmatrix} = 4\n$$\n$$\nC_{23} = (-1)^{2+3} \\det \\begin{pmatrix} 2  1 \\\\ 0  1 \\end{pmatrix} = -(2-0) = -2\n$$\n$$\nC_{31} = (-1)^{3+1} \\det \\begin{pmatrix} 1  0 \\\\ 2  1 \\end{pmatrix} = 1\n$$\n$$\nC_{32} = (-1)^{3+2} \\det \\begin{pmatrix} 2  0 \\\\ 1  1 \\end{pmatrix} = -(2-0) = -2\n$$\n$$\nC_{33} = (-1)^{3+3} \\det \\begin{pmatrix} 2  1 \\\\ 1  2 \\end{pmatrix} = 3\n$$\nSo, the cofactor matrix is:\n$$\nC = \\begin{pmatrix}\n3  -2  1 \\\\\n-2  4  -2 \\\\\n1  -2  3\n\\end{pmatrix}\n$$\nThe adjugate matrix is the transpose of $C$. Since $C$ is symmetric, $\\text{adj}(A) = C^T = C$.\n$$\n\\text{adj}(A) = \\begin{pmatrix}\n3  -2  1 \\\\\n-2  4  -2 \\\\\n1  -2  3\n\\end{pmatrix}\n$$\nFinally, the inverse matrix is:\n$$\nA^{-1} = \\frac{1}{4} \\begin{pmatrix}\n3  -2  1 \\\\\n-2  4  -2 \\\\\n1  -2  3\n\\end{pmatrix} = \\begin{pmatrix}\n\\frac{3}{4}  -\\frac{1}{2}  \\frac{1}{4} \\\\\n-\\frac{1}{2}  1  -\\frac{1}{2} \\\\\n\\frac{1}{4}  -\\frac{1}{2}  \\frac{3}{4}\n\\end{pmatrix}\n$$\nThe matrix $A^{-1}$ contains negative entries, for example, $(A^{-1})_{12} = -1/2$. Therefore, $A$ is not an inverse-positive matrix.\n\n3.  **Interpretation and Explanation of Failure**\n\nThe discrete comparison principle requires the discrete operator (matrix) to be inverse-positive. This ensures that for a nonnegative load vector $f \\ge 0$ (component-wise), the solution $u = A^{-1}f$ is also nonnegative, $u \\ge 0$. Since we have shown that $A$ is not inverse-positive, the comparison principle fails for this operator.\n\nTo exhibit this failure, we need to find a nonnegative vector $f$ such that $u = A^{-1}f$ has at least one negative component. The negative entries in $A^{-1}$ guide our choice. Let's choose a load vector $f$ corresponding to a unit load at the second interior node, and zero load elsewhere:\n$$\nf = \\begin{pmatrix} 0 \\\\ 1 \\\\ 0 \\end{pmatrix}\n$$\nThis vector is clearly nonnegative. The solution $u$ is then given by:\n$$\nu = A^{-1}f = \\begin{pmatrix}\n\\frac{3}{4}  -\\frac{1}{2}  \\frac{1}{4} \\\\\n-\\frac{1}{2}  1  -\\frac{1}{2} \\\\\n\\frac{1}{4}  -\\frac{1}{2}  \\frac{3}{4}\n\\end{pmatrix} \\begin{pmatrix} 0 \\\\ 1 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} -\\frac{1}{2} \\\\ 1 \\\\ -\\frac{1}{2} \\end{pmatrix}\n$$\nThe resulting solution vector is $u = (-1/2, 1, -1/2)^T$. The first and third components of $u$ are negative, even though the load vector $f$ was nonnegative. This explicitly demonstrates the failure of the discrete comparison principle.\n\nThe mechanism of this failure lies in the sign structure of the matrix $A$. A sufficient condition for a matrix to be inverse-positive is that it is a non-singular $M$-matrix. A matrix is an $M$-matrix if it is a $Z$-matrix with additional properties (e.g., being SPD). A $Z$-matrix is a matrix whose off-diagonal entries are all non-positive.\nThe given matrix $A$ has positive off-diagonal entries, such as $a_{12} = 1  0$ and $a_{23} = 1  0$. Thus, $A$ is not a $Z$-matrix, and consequently, it cannot be an $M$-matrix.\n\nThe standard finite difference discretization of an elliptic operator like $-u''$ leads to a matrix with positive diagonal entries and negative off-diagonal entries (e.g., the tridiagonal matrix with stencil $[-1, 2, -1]$). Such a matrix is a $Z$-matrix and, being diagonally dominant, is also an $M$-matrix, hence guaranteeing the discrete comparison principle. The matrix $A$ in this problem, with its positive off-diagonal entries, would correspond to a non-elliptic operator (e.g., one related to $+u''$), for which a maximum/comparison principle is not expected to hold. The property of being SPD is not sufficient to guarantee inverse-positivity; the sign structure of the off-diagonal entries is the critical factor that was violated here.\nThe $(1,2)$ entry of $A^{-1}$ is $-\\frac{1}{2}$.", "answer": "$$\\boxed{-\\frac{1}{2}}$$", "id": "3379754"}, {"introduction": "Having established the algebraic foundation, we now connect it to a concrete numerical scheme. This practice explores the DMP within the context of the Finite Difference Method (FDM) for a reaction-diffusion problem. You will implement the standard five-point stencil and observe how it naturally produces an M-matrix for the pure diffusion operator, and then investigate how adding a reaction term $cu$ can either preserve or, if $c \\lt 0$, destroy this vital property, leading to a violation of the maximum principle. [@problem_id:3379721]", "problem": "Consider a linear second-order elliptic partial differential equation (PDE) in two spatial dimensions on the unit square domain $\\Omega = (0,1)\\times(0,1)$ with homogeneous Dirichlet boundary conditions. The operator of interest is $L u = -\\Delta u + c\\,u$, where $\\Delta$ denotes the Laplacian and $c$ is a real constant. The discrete maximum principle (DMP) states, in one of its common discrete forms, that for a monotone discretization of such an operator, if the discrete right-hand side is nonpositive and the boundary data are nonpositive, then the discrete solution is everywhere nonpositive, and any discrete maximum is achieved at the boundary. Your task is to analyze and numerically verify when the DMP holds for the standard five-point finite difference (FD) discretization of $L u$, and to produce a numerical counterexample when it fails.\n\nStarting from fundamental base principles in numerical solution of PDEs:\n- Finite difference (FD) discretization on a uniform grid with spacing $h$ in each spatial direction.\n- The five-point stencil for the Laplacian on interior grid points.\n- The definition of the discrete maximum principle (DMP) and the role of monotone matrices (also known as matrices with nonpositive off-diagonals and inverse that preserves nonnegativity).\n\nYou must:\n1. Construct the standard five-point FD discretization of $L u = -\\Delta u + c\\,u$ on a uniform $N\\times N$ interior grid with homogeneous Dirichlet boundary conditions on $\\partial\\Omega$.\n2. Explain, based on first principles, why adding a nonnegative reaction term ($c\\ge 0$) preserves the DMP for this discretization, and why a negative reaction term ($c0$) can break the DMP.\n3. Implement a program that, for several test cases, assembles the discrete linear system for interior unknowns, solves it, and checks whether the DMP conclusion is satisfied. Use the discrete right-hand side values and boundary values specified per test case below. Interpret the DMP conclusion as: with homogeneous Dirichlet boundary data $u=0$ and a nonpositive discrete right-hand side, the discrete solution must satisfy $\\max u \\le 0$; equivalently, the interior maximum cannot exceed the boundary maximum.\n\nTest suite:\n- Test $1$: $N=20$, $c=0$, discrete right-hand side $f_{ij}\\equiv -1$ for all interior grid points; expect that the DMP holds, i.e., the interior discrete solution satisfies $\\max u \\le 0$.\n- Test $2$: $N=20$, $c=5$, discrete right-hand side $f_{ij}\\equiv -1$ for all interior grid points; expect that the DMP holds, i.e., $\\max u \\le 0$.\n- Test $3$: $N=3$, $c=0$, discrete right-hand side $f_{ij}\\equiv 0$ for all interior grid points; expect that the DMP holds in the trivial sense, i.e., $\\max u \\le 0$.\n- Test $4$: $N=10$, $c=-2000$, discrete right-hand side equal to a point source at the central interior grid point with value $+1$ and $0$ elsewhere (homogeneous Dirichlet boundary). This is designed to demonstrate breakdown for $c0$: check whether the DMP is violated by the presence of a strictly positive interior value, i.e., whether $\\max u  0$.\n\nImplementation details:\n- Use a uniform grid with $N$ interior points per spatial dimension; the grid spacing is $h = 1/(N+1)$.\n- Discretize the operator $L u = -\\Delta u + c\\,u$ using the standard five-point stencil for $-\\Delta$ on interior points and a pointwise reaction term $c\\,u$.\n- Assemble the sparse matrix corresponding to the interior unknowns using standard Kronecker-sum construction for the two-dimensional Laplacian.\n- Enforce homogeneous Dirichlet boundary conditions in the usual way for the interior-only system (there are no boundary contributions to the right-hand side when the boundary data are zero).\n- For each test case, solve the linear system for the interior unknowns and evaluate the discrete maximum principle according to the test’s expectation.\n\nNumerical tolerances and result typing:\n- Use a numerical tolerance of $10^{-12}$ when checking inequalities like $\\max u \\le 0$ so that floating-point roundoff does not cause false failures.\n- For Tests $1$–$3$, return a boolean indicating whether the DMP holds (True if $\\max u \\le 10^{-12}$, False otherwise).\n- For Test $4$, return a boolean indicating whether the DMP is violated (True if $\\max u  10^{-12}$, False otherwise).\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the test suite: $[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4]$, where each entry is a boolean.", "solution": "The problem requires an analysis of the discrete maximum principle (DMP) for a linear elliptic operator $L u = -\\Delta u + c\\,u$ on the unit square with homogeneous Dirichlet boundary conditions. We will first provide a theoretical explanation based on the principles of finite difference discretization and M-matrices, and then present a numerical verification for the specified test cases.\n\n### Step 1: Discretization of the Operator\n\nWe consider a uniform grid on the domain $\\Omega = (0,1)\\times(0,1)$ with $N$ interior points in each direction. The grid spacing is $h = 1/(N+1)$. An interior grid point is denoted by $(x_i, y_j) = (ih, jh)$ for $i,j \\in \\{1, \\dots, N\\}$. The solution at this point is $u_{ij} = u(x_i, y_j)$.\n\nThe operator is $L u = -\\Delta u + c\\,u$. We use the standard five-point stencil to approximate the negative Laplacian, $-\\Delta u$:\n$$\n(-\\Delta u)|_{(x_i, y_j)} \\approx -\\frac{u_{i+1,j} - 2u_{ij} + u_{i-1,j}}{h^2} - \\frac{u_{i,j+1} - 2u_{ij} + u_{i,j-1}}{h^2} = \\frac{4u_{ij} - u_{i+1,j} - u_{i-1,j} - u_{i,j+1} - u_{i,j-1}}{h^2}\n$$\nThe discrete version of the PDE $L u = f$ at the point $(x_i, y_j)$ is therefore:\n$$\n\\frac{4u_{ij} - u_{i+1,j} - u_{i-1,j} - u_{i,j+1} - u_{i,j-1}}{h^2} + c u_{ij} = f_{ij}\n$$\nThe homogeneous Dirichlet boundary conditions imply that for any point $(x_i, y_j)$ adjacent to the boundary, the value of $u$ at the boundary point is zero. For example, if $i=1$, $u_{0,j}=0$.\n\nWe can arrange the $N^2$ interior unknowns $u_{ij}$ into a single vector $\\mathbf{u}$ of size $N^2 \\times 1$. The discrete equations then form a linear system $A\\mathbf{u} = \\mathbf{f}$, where $A$ is an $N^2 \\times N^2$ matrix. By rearranging the terms of the discrete equation, we can identify the entries of the matrix $A$. The equation for the unknown corresponding to $u_{ij}$ is:\n$$\n\\left(\\frac{4}{h^2} + c\\right)u_{ij} - \\frac{1}{h^2}u_{i-1,j} - \\frac{1}{h^2}u_{i+1,j} - \\frac{1}{h^2}u_{i,j-1} - \\frac{1}{h^2}u_{i,j+1} = f_{ij}\n$$\nFrom this, we deduce the structure of the matrix $A$:\n- The diagonal entries are $A_{kk} = \\frac{4}{h^2} + c$.\n- The off-diagonal entries $A_{kl}$ are equal to $-\\frac{1}{h^2}$ if unknown $l$ corresponds to a direct neighbor of unknown $k$ on the grid, and $0$ otherwise.\n\n### Step 2: The Discrete Maximum Principle and M-Matrices\n\nThe discrete maximum principle is intimately connected to the properties of the system matrix $A$. Specifically, for the version of the DMP stated in the problem (non-positive forcing and boundary data imply a non-positive solution), a sufficient condition is that $A$ is an **M-matrix**.\n\nAn M-matrix is defined as a matrix $A$ that satisfies:\n1. $A$ is a **Z-matrix**: all its off-diagonal entries are non-positive ($A_{kl} \\le 0$ for $k \\ne l$).\n2. The inverse of $A$ is non-negative: $A^{-1} \\ge 0$ (element-wise).\n\nFor a Z-matrix, the condition $A^{-1} \\ge 0$ is equivalent to stating that all eigenvalues of $A$ have a positive real part.\n\nLet's analyze the matrix $A$ from our discretization.\n1.  **Z-matrix property**: The off-diagonal entries are either $0$ or $-\\frac{1}{h^2}$. Since $h^20$, these are all non-positive. Thus, $A$ is always a Z-matrix.\n2.  **Eigenvalue condition**: The matrix $A$ is symmetric, so its eigenvalues are real. We need to determine when all its eigenvalues are positive. The matrix $A$ can be written as $A = \\frac{1}{h^2} A_{\\text{lap}} + cI$, where $A_{\\text{lap}}$ is the matrix corresponding to the five-point stencil (diagonals of $4$, off-diagonals of $-1$) and $I$ is the identity matrix. The eigenvalues of $\\frac{1}{h^2}A_{\\text{lap}}$ are the eigenvalues of the discrete negative Laplacian, which are all positive. Let these be $\\lambda_{k,l}  0$. The eigenvalues of $A$ are then $\\mu_{k,l} = \\lambda_{k,l} + c$. For $A$ to be an M-matrix, all its eigenvalues must be positive:\n    $$ \\mu_{k,l} = \\lambda_{k,l} + c  0 \\quad \\text{for all } k, l $$\n    This is equivalent to requiring $c  -\\min_{k,l}(\\lambda_{k,l})$. The smallest eigenvalue of the discrete Laplacian is $\\lambda_{1,1} = \\frac{4}{h^2}\\left(1 - \\cos\\left(\\frac{\\pi}{N+1}\\right)\\right)$, which is strictly positive.\n\nNow we can analyze the conditions on $c$.\n\n**Case 1: $c \\ge 0$ (Tests 1, 2, 3)**\nIf $c \\ge 0$, then since all $\\lambda_{k,l}  0$, the eigenvalues of $A$, $\\mu_{k,l} = \\lambda_{k,l} + c$, are guaranteed to be positive. Thus, for any $c \\ge 0$, $A$ is an M-matrix.\nThe solution to the system is $\\mathbf{u} = A^{-1}\\mathbf{f}$. The problem specifies homogeneous Dirichlet boundary conditions ($u=0$ on $\\partial\\Omega$) and a non-positive right-hand side, $\\mathbf{f} \\le 0$. Since $A$ is an M-matrix, $A^{-1}$ has all non-negative entries. The product of a non-negative matrix and a non-positive vector results in a non-positive vector: $\\mathbf{u} = A^{-1}\\mathbf{f} \\le 0$.\nThe interior solution is non-positive. Since the boundary values are $0$, the maximum value of the discrete solution over the entire domain (interior and boundary) is $0$. This satisfies the DMP condition $\\max u \\le 0$. This confirms the expectation for Tests 1, 2, and 3.\n\n**Case 2: $c  0$ (Test 4)**\nIf $c$ is negative, the DMP may fail. The M-matrix property is lost if $c \\le -\\lambda_{1,1}$. In Test 4, $N=10$, so $h=1/11$ and $\\lambda_{1,1} = 4(11)^2\\left(1 - \\cos(\\pi/11)\\right) \\approx 19.6$. The value $c=-2000$ is far below $-\\lambda_{1,1}$, so $A$ has negative eigenvalues and is not an M-matrix.\n\nWhen $A$ is not an M-matrix, the conclusion of the DMP is not guaranteed. We can investigate this using the classic proof argument for the maximum principle. Assume the solution $\\mathbf{u}$ has a strictly positive interior maximum, $u_{max}  0$, at some node $k$. At this node, $u_k = u_{max}$ and $u_j \\le u_{max}$ for all neighboring nodes $j$. The equation for node $k$ is:\n$$ \\left(\\frac{4}{h^2} + c\\right)u_k + \\sum_{j \\sim k} \\left(-\\frac{1}{h^2}\\right) u_j = f_k $$\nRearranging gives:\n$$ c u_k + \\frac{1}{h^2}\\left(4u_k - \\sum_{j \\sim k} u_j\\right) = f_k $$\nSince $u_k$ is the maximum, the term in the parentheses is non-negative: $4u_k - \\sum u_j \\ge 0$.\nTherefore, we must have $f_k \\ge c u_k$.\n\nIf $c \\ge 0$ and we have a non-positive RHS, $f_k \\le 0$, this leads to $0 \\ge f_k \\ge c u_k \\ge 0$, which implies $u_k=0$, contradicting $u_{max}0$. This proves the DMP for $c \\ge 0$.\n\nHowever, if $c  0$ (as in Test 4), this argument does not lead to a contradiction. The condition becomes $f_k \\ge c u_{max}$. Since $c0$ and $u_{max}0$, the right side $c u_{max}$ is negative. For a non-negative RHS ($f_k \\ge 0$), the inequality $f_k \\ge c u_{max}$ is always satisfied. Thus, the argument does not forbid the existence of a positive interior maximum. Test 4 is designed to numerically demonstrate such a scenario, where the loss of the M-matrix property leads to a violation of the DMP conclusion.\n\n### Step 3: Numerical Verification\n\nThe provided Python code implements the logic described above.\n- It constructs the $N^2 \\times N^2$ sparse matrix $A$ using the Kronecker sum formulation, which is computationally efficient. The 1D operator matrix $A_{1D}$ is created, and the 2D matrix is formed as $A = \\frac{1}{h^2}(I \\otimes A_{1D} + A_{1D} \\otimes I) + cI$.\n- It sets up the corresponding right-hand side vector $\\mathbf{f}$ for each test case.\n- It solves the linear system $A\\mathbf{u}=\\mathbf{f}$ using a sparse linear solver.\n- It finds the maximum value of the solution vector $\\mathbf{u}$ and checks it against the tolerance of $10^{-12}$ to determine if the DMP holds or is violated, as specified for each test.\n\nThe results from running the code will confirm our theoretical analysis: Tests 1-3, where $c \\ge 0$, will satisfy the DMP. Test 4, where $c$ is large and negative, will show a violation, with a strictly positive interior maximum emerging despite the zero-valued boundary.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import sparse\nfrom scipy.sparse import linalg\n\ndef run_test(N, c, f_spec, test_id):\n    \"\"\"\n    Assembles and solves the discrete system for Lu = f and checks the DMP.\n\n    Args:\n        N (int): Number of interior grid points per dimension.\n        c (float): Reaction coefficient in the PDE.\n        f_spec (float or str): Specification for the right-hand side vector.\n                               A float value means a constant RHS.\n                               'point_source' means a central point source.\n        test_id (int): The ID of the test case (1-4).\n\n    Returns:\n        bool: The result of the DMP check for the specific test.\n    \"\"\"\n    # Grid spacing\n    h = 1.0 / (N + 1)\n\n    # 1. Assemble the matrix A\n    # The matrix corresponds to the operator (1/h^2)*(-Delta_h) + c*I\n    \n    # 1D Laplacian matrix (size N x N)\n    diag_1d = np.ones(N) * 2.0\n    offdiag_1d = np.ones(N - 1) * -1.0\n    A_1d = sparse.diags([offdiag_1d, diag_1d, offdiag_1d], [-1, 0, 1], format='csc')\n\n    # 2D Laplacian matrix using Kronecker sum (size N^2 x N^2)\n    # A_2d = I_N kron A_1d + A_1d kron I_N\n    I_n = sparse.identity(N, format='csc')\n    A_lap = sparse.kron(I_n, A_1d) + sparse.kron(A_1d, I_n)\n\n    # Full operator matrix A\n    I_n2 = sparse.identity(N**2, format='csc')\n    A = (1/h**2) * A_lap + c * I_n2\n    A = A.tocsc()\n\n    # 2. Assemble the right-hand side vector f\n    f = np.zeros(N**2)\n    if isinstance(f_spec, (int, float)):\n        f.fill(f_spec)\n    elif f_spec == 'point_source':\n        # Central interior grid point. For even N, there are 4 central points.\n        # We pick one, e.g., (floor(N/2), floor(N/2)) in 1-based indexing.\n        # Convert to 0-based indices:\n        center_i = N // 2\n        center_j = N // 2\n        \n        # Alternative for a more centered point for even N:\n        # center_i = N // 2 - 1 for N >= 2 else 0\n        # center_j = N // 2 - 1 for N >= 2 else 0\n\n        linear_index = center_i * N + center_j\n        f[linear_index] = 1.0\n\n    # 3. Solve the linear system Au = f\n    u = linalg.spsolve(A, f)\n\n    # 4. Check the Discrete Maximum Principle\n    max_u = np.max(u)\n    tol = 1.0e-12\n\n    if test_id in [1, 2, 3]:\n        # For non-positive RHS f and zero boundary, DMP holds if max(u) = 0.\n        return max_u = tol\n    elif test_id == 4:\n        # Check if DMP is violated by the presence of a strictly positive interior value.\n        # This means checking if max(u) > 0.\n        return max_u > tol\n    else:\n        raise ValueError(\"Invalid test_id\")\n\n\ndef solve():\n    \"\"\"\n    Defines test cases, runs them, and prints results.\n    \"\"\"\n    # Test suite: (N, c, f_spec, test_id)\n    test_cases = [\n        (20, 0, -1.0, 1),\n        (20, 5, -1.0, 2),\n        (3, 0, 0.0, 3),\n        (10, -2000, 'point_source', 4)\n    ]\n\n    results = []\n    for N, c, f_spec, test_id in test_cases:\n        result = run_test(N, c, f_spec, test_id)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3379721"}, {"introduction": "Our final practice demonstrates that the validity of the DMP depends not only on the operator but also on the interplay between the discretization method and the mesh geometry. Here, we shift to the Finite Element Method (FEM) and discover that even for the simple Poisson equation, the geometry of the mesh is paramount. This exercise will guide you to create a mesh with obtuse angles, which in turn generates positive off-diagonal entries in the stiffness matrix, violating the M-matrix condition and producing unphysical overshoots in the solution. [@problem_id:3379716]", "problem": "Consider the scalar diffusion equation $-\\nabla \\cdot (\\kappa \\nabla u) = f$ on the unit square domain $\\Omega = [0,1]^2$ with homogeneous Dirichlet boundary conditions $u|_{\\partial \\Omega} = 0$, where $\\kappa(x,y) \\equiv 1$ and $f(x,y)$ is a given source. The weak form is: find $u \\in H_0^1(\\Omega)$ such that for all $v \\in H_0^1(\\Omega)$,\n$$\n\\int_{\\Omega} \\nabla u \\cdot \\nabla v \\, dx = \\int_{\\Omega} f v \\, dx.\n$$\nLet $\\mathcal{T}_h$ be a conforming triangulation of $\\Omega$ and let $\\{ \\varphi_i \\}$ be the standard continuous, piecewise linear (hat) basis functions on $\\mathcal{T}_h$ associated with the mesh nodes. The finite element method seeks $u_h \\in V_h \\subset H_0^1(\\Omega)$ such that\n$$\n\\sum_{i,j} K_{ij} U_j \\, \\varphi_i = \\sum_i F_i \\, \\varphi_i, \\quad \\text{with} \\quad K_{ij}=\\int_{\\Omega} \\nabla \\varphi_i \\cdot \\nabla \\varphi_j \\, dx, \\quad F_i=\\int_{\\Omega} f \\varphi_i \\, dx,\n$$\nand $U_j$ the nodal values of $u_h$. For constant $f$, on each triangle $T \\in \\mathcal{T}_h$ with area $|T|$, the local load vector entries are given by $F_i^T = f|_T \\, |T|/3$ for the three local vertices in $T$. The local element stiffness matrix $\\mathbf{K}^T$ can be assembled from the constant gradients of the local basis functions. The global stiffness matrix $\\mathbf{K}$ is symmetric positive definite on the interior degrees of freedom after enforcing Dirichlet conditions.\n\nA discrete maximum principle states, under suitable mesh conditions, that the discrete solution $u_h$ respects the sign constraints implied by the continuous maximum principle. In particular, for $f \\le 0$ and homogeneous Dirichlet boundary conditions, one expects $u_h \\le 0$ at interior nodes when the reduced stiffness matrix is an $M$-matrix (i.e., off-diagonal entries are nonpositive and the matrix is weakly diagonally dominant). On meshes containing obtuse angles, some off-diagonal entries can become positive, violating the $M$-matrix property and potentially leading to interior overshoot (values $u_h  0$ inside the domain despite $u|_{\\partial \\Omega}=0$ and $f \\le 0$).\n\nYour task is to implement a program that:\n- Builds structured triangular meshes on $\\Omega$ by subdividing into $n_x \\times n_y$ rectangles and splitting each rectangle into two triangles by the diagonal from $(i,j)$ to $(i+1,j+1)$ for all integer grid points $(i,j)$.\n- Optionally perturbs specified interior grid nodes by a small displacement vector to create triangulations with obtuse angles while keeping all nodes inside $\\Omega$.\n- Assembles the global stiffness matrix $\\mathbf{K}$ and load vector $\\mathbf{F}$ using the standard piecewise linear finite element method for the operator $-\\Delta$ with $f(x,y) = -1$.\n- Enforces homogeneous Dirichlet boundary conditions at all nodes with $x=0$, $x=1$, $y=0$, or $y=1$ to obtain a reduced linear system $\\mathbf{K}_{II} \\mathbf{U}_I = \\mathbf{F}_I$ for the interior degrees of freedom.\n- Computes two diagnostics on the reduced system for each mesh:\n  1. Whether there exists a strictly positive off-diagonal entry in $\\mathbf{K}_{II}$ exceeding a threshold $\\tau = 10^{-12}$.\n  2. Whether the maximum interior nodal value of the discrete solution $u_h$ exceeds the same threshold $\\tau$, i.e., $\\max_{i \\in I} U_i  \\tau$ (an interior overshoot relative to the boundary data $u=0$).\n- Returns, for each test case, a boolean equal to the logical conjunction of these diagnostics, i.e., it should return `True` if and only if the reduced stiffness matrix has a positive off-diagonal and the corresponding discrete solution exhibits an interior overshoot.\n\nUse the following finite set of test cases (this constitutes the test suite to evaluate distinct scenarios):\n\n- Case A (baseline mesh with no perturbation; expected to be nonobtuse in aggregate):\n  - Parameters: $(n_x, n_y) = (3,3)$.\n  - Perturbation: none (all node displacements are $(0,0)$).\n\n- Case B (designed to create an obtuse configuration; choose the smallest allowed scale that triggers both diagnostics):\n  - Parameters: $(n_x, n_y) = (3,3)$.\n  - Perturbation pattern is defined on indices $(i,j)$ in grid coordinates with $i \\in \\{0,\\dots,n_x\\}$, $j \\in \\{0,\\dots,n_y\\}$ as:\n    - At $(i,j)=(2,2)$ add base displacement $(\\delta x, \\delta y) = (0.28,-0.15)$.\n    - At $(i,j)=(1,2)$ add base displacement $(\\delta x, \\delta y) = (-0.12,0.09)$.\n    - All other nodes have $(\\delta x, \\delta y)=(0,0)$.\n  - Let $\\mathcal{S} = \\{0.2, 0.4, 0.6, 0.8, 1.0\\}$. Apply the perturbation pattern scaled by a factor $s \\in \\mathcal{S}$ and select the smallest $s$ in $\\mathcal{S}$ for which both diagnostics are satisfied. If no such $s$ exists, use $s = 1.0$.\n  - Report the boolean for this selected mesh.\n\n- Case C (near-threshold perturbation meant to avoid violation):\n  - Parameters: $(n_x, n_y) = (3,3)$.\n  - Perturbation pattern identical to Case B but with fixed scale $s = 0.15$.\n\nIn all cases use $f(x,y) = -1$ and homogeneous Dirichlet boundary data. There are no physical units to report in this problem. Your program should produce a single line of output containing the results for the three cases as a comma-separated list enclosed in square brackets (e.g., `[True,False,True]`) where each entry is either \"True\" or \"False\" in the exact capitalization of the Python programming language boolean literals. The numerical threshold must be $\\tau = 10^{-12}$ for determining positivity and overshoot. The desired final output format is exactly one line:\n\"[result_A,result_B,result_C]\".", "solution": "### 1. Problem Formulation\nThe problem under consideration is the scalar Poisson equation with a constant source term on a two-dimensional domain $\\Omega$:\n$$\n-\\Delta u = f \\quad \\text{in} \\quad \\Omega = [0,1]^2\n$$\nsubject to homogeneous Dirichlet boundary conditions, $u = 0$ on the boundary $\\partial\\Omega$. The source term is given as a constant $f(x,y) = -1$. The continuous weak form of this problem is to find $u \\in H_0^1(\\Omega)$ such that for all test functions $v \\in H_0^1(\\Omega)$:\n$$\n\\int_{\\Omega} \\nabla u \\cdot \\nabla v \\, d\\mathbf{x} = \\int_{\\Omega} f v \\, d\\mathbf{x}\n$$\nThe continuous maximum principle for this operator implies that if $f \\le 0$, the maximum value of $u$ must occur on the boundary $\\partial\\Omega$. Since $u=0$ on $\\partial\\Omega$, this implies $u(\\mathbf{x}) \\le 0$ for all $\\mathbf{x} \\in \\Omega$.\n\n### 2. Finite Element Discretization\n\n#### 2.1. Mesh and Basis Functions\nThe domain $\\Omega$ is discretized using a structured triangular mesh. First, a uniform grid of $(n_x+1) \\times (n_y+1)$ nodes is generated, with initial coordinates $P_{i,j} = (i/n_x, j/n_y)$ for $i \\in \\{0, \\dots, n_x\\}$ and $j \\in \\{0, \\dots, n_y\\}$. These nodes define a set of $n_x \\times n_y$ rectangular cells. Each rectangle, defined by vertices $(i,j)$, $(i+1,j)$, $(i,j+1)$, and $(i+1,j+1)$, is subdivided into two triangles by the diagonal connecting grid points $(i,j)$ and $(i+1,j+1)$. Specific interior nodes may be perturbed from their initial positions.\n\nThe finite element space $V_h$ consists of continuous, piecewise linear functions. The basis for $V_h$ is the set of \"hat\" functions $\\{\\varphi_k\\}$, where $\\varphi_k$ is equal to $1$ at node $k$ and $0$ at all other nodes. The discrete solution $u_h$ is represented as a linear combination of these basis functions:\n$$\nu_h(\\mathbf{x}) = \\sum_{j} U_j \\varphi_j(\\mathbf{x})\n$$\nwhere $U_j$ are the unknown nodal values of the solution.\n\n#### 2.2. Element Stiffness Matrix and Load Vector\nThe finite element method leads to a linear system $\\mathbf{K} \\mathbf{U} = \\mathbf{F}$, where $\\mathbf{K}$ is the global stiffness matrix and $\\mathbf{F}$ is the global load vector. These are assembled from local contributions computed on each triangular element $T \\in \\mathcal{T}_h$.\n\nFor a single triangle $T$ with vertices $\\mathbf{p}_a, \\mathbf{p}_b, \\mathbf{p}_c$, the entries of the $3 \\times 3$ local stiffness matrix $\\mathbf{K}^T$ are given by:\n$$\nK^T_{ij} = \\int_T \\nabla \\varphi_i \\cdot \\nabla \\varphi_j \\, d\\mathbf{x} = (\\nabla \\varphi_i \\cdot \\nabla \\varphi_j) |T|\n$$\nwhere $|T|$ is the area of the triangle. The gradient of a linear basis function $\\varphi_i$ is constant over the triangle. For a triangle with vertices $\\mathbf{p}_1=(x_1, y_1)$, $\\mathbf{p}_2=(x_2, y_2)$, and $\\mathbf{p}_3=(x_3, y_3)$, the gradients of the corresponding local basis functions are:\n$$\n\\nabla \\varphi_1 = \\frac{1}{2|T|} \\begin{pmatrix} y_2 - y_3 \\\\ x_3 - x_2 \\end{pmatrix}, \\quad \\nabla \\varphi_2 = \\frac{1}{2|T|} \\begin{pmatrix} y_3 - y_1 \\\\ x_1 - x_3 \\end{pmatrix}, \\quad \\nabla \\varphi_3 = \\frac{1}{2|T|} \\begin{pmatrix} y_1 - y_2 \\\\ x_2 - x_1 \\end{pmatrix}\n$$\nThe area $|T|$ can be calculated as $|T| = \\frac{1}{2} |x_1(y_2-y_3) + x_2(y_3-y_1) + x_3(y_1-y_2)|$. An off-diagonal entry, for instance $K^T_{12}$, is related to the angle $\\theta_3$ at vertex $\\mathbf{p}_3$ by the cotangent formula: $K^T_{12} = -\\frac{1}{2}\\cot(\\theta_3)$. This entry becomes positive if the angle $\\theta_3$ is obtuse.\n\nThe local load vector $\\mathbf{F}^T$ has entries $F_i^T = \\int_T f \\varphi_i \\, d\\mathbf{x}$. For a constant source term $f$, this integral evaluates to:\n$$\nF_i^T = f \\frac{|T|}{3}\n$$\nGiven $f=-1$, the entries are $F_i^T = -|T|/3$.\n\n### 3. System Assembly and Boundary Conditions\nThe global stiffness matrix $\\mathbf{K}$ and load vector $\\mathbf{F}$ are constructed by iterating over all triangles in the mesh and adding the local element contributions $\\mathbf{K}^T$ and $\\mathbf{F}^T$ into the global system according to the global indices of the element's vertices.\n\nThe homogeneous Dirichlet boundary condition $u=0$ on $\\partial\\Omega$ means that the nodal values $U_j$ for all boundary nodes $j \\in B$ are fixed to $0$. The linear system is partitioned into interior (I) and boundary (B) degrees of freedom:\n$$\n\\begin{pmatrix} \\mathbf{K}_{II}  \\mathbf{K}_{IB} \\\\ \\mathbf{K}_{BI}  \\mathbf{K}_{BB} \\end{pmatrix}\n\\begin{pmatrix} \\mathbf{U}_I \\\\ \\mathbf{U}_B \\end{pmatrix}\n=\n\\begin{pmatrix} \\mathbf{F}_I \\\\ \\mathbf{F}_B \\end{pmatrix}\n$$\nSetting $\\mathbf{U}_B = \\mathbf{0}$, the system reduces to solving for the unknown interior nodal values $\\mathbf{U}_I$:\n$$\n\\mathbf{K}_{II} \\mathbf{U}_I = \\mathbf{F}_I\n$$\nwhere $\\mathbf{K}_{II}$ is the submatrix corresponding to interior-interior interactions, and $\\mathbf{F}_I$ is the subvector of loads at interior nodes.\n\n### 4. Numerical Diagnostics and Discrete Maximum Principle\nA stiffness matrix is an M-matrix if its off-diagonal entries are all non-positive ($K_{ij} \\le 0$ for $i \\ne j$) and it is weakly diagonally dominant. If the reduced stiffness matrix $\\mathbf{K}_{II}$ is an M-matrix, then $(\\mathbf{K}_{II})^{-1}$ will have non-negative entries. Since $\\mathbf{F}_I$ has non-positive entries (as $f=-1$), the solution $\\mathbf{U}_I = (\\mathbf{K}_{II})^{-1} \\mathbf{F}_I$ will have non-positive entries, thus satisfying a discrete maximum principle ($U_i \\le 0$).\n\nThe presence of obtuse angles in the triangulation can lead to positive off-diagonal entries in $\\mathbf{K}_{II}$, violating the M-matrix property. This may, in turn, lead to a violation of the discrete maximum principle, observed as `overshoot` where some interior nodal values $U_i$ become positive, despite the boundary conditions and forcing suggesting they should be non-positive. The task requires checking for two conditions using a numerical tolerance $\\tau=10^{-12}$:\n1.  **Positive Off-Diagonal Entry**: Whether there exists an entry $(\\mathbf{K}_{II})_{ij}  \\tau$ for $i \\ne j$.\n2.  **Interior Overshoot**: Whether the maximum interior nodal value $\\max(\\mathbf{U}_I)  \\tau$.\n\nThe final boolean result for each test case is the logical conjunction of these two conditions.\n\n### 5. Computational Procedure for Test Cases\nThe implementation will follow these steps for each test case:\n1.  Generate the mesh node coordinates for the given $(n_x, n_y)$, applying any specified perturbations.\n2.  Define the list of triangles based on the structured grid topology.\n3.  Identify the global indices corresponding to interior and boundary nodes.\n4.  Assemble the global stiffness matrix $\\mathbf{K}$ and load vector $\\mathbf{F}$ by looping through all triangles.\n5.  Extract the reduced system $\\mathbf{K}_{II}$ and $\\mathbf{F}_I$.\n6.  Solve the linear system $\\mathbf{K}_{II} \\mathbf{U}_I = \\mathbf{F}_I$ for $\\mathbf{U}_I$.\n7.  Perform the two diagnostic checks on $\\mathbf{K}_{II}$ and $\\mathbf{U}_I$.\n8.  For Case B, this procedure is iterated for specified scaling factors $s \\in \\{0.2, 0.4, 0.6, 0.8, 1.0\\}$, selecting the smallest $s$ that satisfies both diagnostics. If no such $s$ exists, the result for $s=1.0$ is used.\n9.  Return the logical AND of the two diagnostic booleans.", "answer": "```python\nimport numpy as np\n\ndef assemble_and_solve(nx, ny, perturbations, f_val, tau):\n    \"\"\"\n    Assembles and solves the FEM system for the Poisson equation.\n\n    Args:\n        nx (int): Number of subdivisions in x-direction.\n        ny (int): Number of subdivisions in y-direction.\n        perturbations (dict): A dict mapping (i,j) grid indices to (dx,dy) perturbations.\n        f_val (float): The constant value of the source term f.\n        tau (float): The numerical threshold for positivity checks.\n\n    Returns:\n        tuple: A tuple of two booleans:\n               (has_positive_off_diagonal, has_overshoot)\n    \"\"\"\n    # 1. Generate node coordinates\n    n_nodes_x = nx + 1\n    n_nodes_y = ny + 1\n    num_nodes = n_nodes_x * n_nodes_y\n    \n    xs = np.linspace(0.0, 1.0, n_nodes_x)\n    ys = np.linspace(0.0, 1.0, n_nodes_y)\n    nodes = np.zeros((num_nodes, 2), dtype=float)\n\n    for j in range(n_nodes_y):\n        for i in range(n_nodes_x):\n            k = i + j * n_nodes_x\n            pert = perturbations.get((i, j), (0.0, 0.0))\n            nodes[k, 0] = xs[i] + pert[0]\n            nodes[k, 1] = ys[j] + pert[1]\n\n    # 2. Generate element connectivity\n    elements = []\n    for j in range(ny):\n        for i in range(nx):\n            n00 = i + j * n_nodes_x\n            n10 = (i + 1) + j * n_nodes_x\n            n01 = i + (j + 1) * n_nodes_x\n            n11 = (i + 1) + (j + 1) * n_nodes_x\n            # Split rectangle by diagonal from (i,j) to (i+1,j+1)\n            elements.append((n00, n10, n11))\n            elements.append((n00, n11, n01))\n\n    # 3. Identify interior and boundary nodes\n    interior_nodes_indices = []\n    for j in range(1, ny):\n        for i in range(1, nx):\n            interior_nodes_indices.append(i + j * n_nodes_x)\n    \n    num_interior_nodes = len(interior_nodes_indices)\n\n    # 4. Assemble global stiffness matrix K and load vector F\n    K = np.zeros((num_nodes, num_nodes), dtype=float)\n    F = np.zeros(num_nodes, dtype=float)\n\n    for el_nodes in elements:\n        p1, p2, p3 = nodes[el_nodes[0]], nodes[el_nodes[1]], nodes[el_nodes[2]]\n        \n        # Area of the triangle\n        area = 0.5 * abs(p1[0]*(p2[1]-p3[1]) + p2[0]*(p3[1]-p1[1]) + p3[0]*(p1[1]-p2[1]))\n        if area  1e-15: continue\n\n        # Gradients of basis functions\n        b = np.array([p2[1] - p3[1], p3[1] - p1[1], p1[1] - p2[1]])\n        c = np.array([p3[0] - p2[0], p1[0] - p3[0], p2[0] - p1[0]])\n        \n        # Local stiffness matrix\n        K_local = np.zeros((3, 3))\n        for i in range(3):\n            for j in range(3):\n                K_local[i, j] = (b[i] * b[j] + c[i] * c[j]) / (4.0 * area)\n\n        # Local load vector\n        F_local = (f_val * area / 3.0) * np.ones(3)\n\n        # Add to global matrix and vector (assembly)\n        for i in range(3):\n            F[el_nodes[i]] += F_local[i]\n            for j in range(3):\n                K[el_nodes[i], el_nodes[j]] += K_local[i, j]\n\n    # 5. Extract reduced system for interior nodes\n    K_II = K[np.ix_(interior_nodes_indices, interior_nodes_indices)]\n    F_I = F[interior_nodes_indices]\n\n    # 6. Solve the linear system\n    try:\n        U_I = np.linalg.solve(K_II, F_I)\n    except np.linalg.LinAlgError:\n        # Singular matrix, likely due to degenerate elements\n        # For this problem, treat as no overshoot and no positive off-diagonal\n        return (False, False)\n\n    # 7. Perform diagnostics\n    # Diagnostic 1: Check for strictly positive off-diagonal entries in K_II\n    K_II_offdiag = K_II.copy()\n    np.fill_diagonal(K_II_offdiag, 0.0)\n    has_pos_offdiag = np.any(K_II_offdiag > tau)\n    \n    # Diagnostic 2: Check for interior overshoot\n    has_overshoot = np.max(U_I) > tau if U_I.size > 0 else False\n\n    return has_pos_offdiag, has_overshoot\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    TAU = 1e-12\n    F_VAL = -1.0\n    NX, NY = 3, 3\n    results = []\n\n    # Case A: Baseline mesh\n    diag1_A, diag2_A = assemble_and_solve(NX, NY, {}, F_VAL, TAU)\n    results.append(diag1_A and diag2_A)\n\n    # Case B: Perturbation with smallest effective scale\n    base_perturbations = {(2, 2): (0.28, -0.15), (1, 2): (-0.12, 0.09)}\n    s_values = [0.2, 0.4, 0.6, 0.8, 1.0]\n    \n    result_B = None\n    result_s1 = None\n\n    for s in s_values:\n        current_perturbations = {\n            node: (s * dx, s * dy) for node, (dx, dy) in base_perturbations.items()\n        }\n        diag1, diag2 = assemble_and_solve(NX, NY, current_perturbations, F_VAL, TAU)\n        \n        current_result_is_true = diag1 and diag2\n        \n        if s == 1.0:\n            result_s1 = current_result_is_true\n        \n        if current_result_is_true and result_B is None:\n            result_B = True # Found smallest s, lock in True\n            \n    if result_B is None: # No s in the list worked\n        result_B = result_s1\n        \n    results.append(result_B)\n\n    # Case C: Near-threshold perturbation\n    s_C = 0.15\n    perturbations_C = {\n        node: (s_C * dx, s_C * dy) for node, (dx, dy) in base_perturbations.items()\n    }\n    diag1_C, diag2_C = assemble_and_solve(NX, NY, perturbations_C, F_VAL, TAU)\n    results.append(diag1_C and diag2_C)\n    \n    # Final print statement\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3379716"}]}