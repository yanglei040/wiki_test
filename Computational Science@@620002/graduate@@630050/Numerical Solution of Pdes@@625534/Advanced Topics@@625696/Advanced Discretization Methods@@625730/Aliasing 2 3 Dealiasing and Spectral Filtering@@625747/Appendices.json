{"hands_on_practices": [{"introduction": "The concept of aliasing can seem abstract, but it arises from a simple mathematical reality: on a discrete grid, high-frequency waves can be indistinguishable from low-frequency ones. This first-principles exercise demystifies this phenomenon by having you manually compute the Discrete Fourier Transform (DFT) of a signal containing both a resolvable and an unresolvable frequency component. By working through the calculation [@problem_id:3362811], you will see precisely how the energy from a high-wavenumber mode \"aliases\" or masquerades as a low-wavenumber mode, providing a foundational understanding of this critical issue in spectral methods.", "problem": "Consider the periodic function $u(x) = \\sin(3x) + \\sin(9x)$ on the interval $[0,2\\pi)$ sampled on an equispaced grid of $N=8$ points at locations $x_j = \\frac{2\\pi j}{N}$ for $j=0,1,\\dots,N-1$. Let the Discrete Fourier Transform (DFT) be defined by\n$$\n\\hat{u}_k \\;=\\; \\sum_{j=0}^{N-1} u(x_j)\\,\\exp\\!\\left(-\\mathrm{i}\\,\\frac{2\\pi k j}{N}\\right), \\quad k=0,1,\\dots,N-1,\n$$\nwith the inverse given by\n$$\nu(x_j) \\;=\\; \\frac{1}{N}\\sum_{k=0}^{N-1} \\hat{u}_k\\,\\exp\\!\\left(\\mathrm{i}\\,\\frac{2\\pi k j}{N}\\right).\n$$\nStarting from these definitions and from first principles about periodic sampling and trigonometric identities, derive the exact DFT coefficients $\\hat{u}_k$ for $k=0,1,\\dots,N-1$ when $N=8$. In your derivation, identify which discrete indices carry nonzero energy for each of the two components $\\sin(3x)$ and $\\sin(9x)$, and explain which high-frequency component aliases to which index and with what complex amplitude due to sampling on $N=8$. Conclude by writing the complete vector of $\\hat{u}_k$ (for $k=0,1,\\dots,7$) as a single row. No numerical rounding is required. Express all mathematical quantities in exact form.", "solution": "The problem requires the derivation of the Discrete Fourier Transform (DFT) coefficients $\\hat{u}_k$ for the function $u(x) = \\sin(3x) + \\sin(9x)$ sampled on a grid of $N=8$ points.\n\nThe given function is $u(x) = \\sin(3x) + \\sin(9x)$. The sampling points are $x_j = \\frac{2\\pi j}{N}$ for $j=0, 1, \\dots, N-1$. The DFT of the sampled sequence $u(x_j)$ is given by\n$$\n\\hat{u}_k \\;=\\; \\sum_{j=0}^{N-1} u(x_j)\\,\\exp\\!\\left(-\\mathrm{i}\\,\\frac{2\\pi k j}{N}\\right), \\quad k=0,1,\\dots,N-1.\n$$\nTo proceed from first principles, we express the sine functions using Euler's formula, $\\sin(\\theta) = \\frac{1}{2\\mathrm{i}}(e^{\\mathrm{i}\\theta} - e^{-\\mathrm{i}\\theta})$.\nThe function $u(x)$ can be written as the sum of four complex exponentials:\n$$\nu(x) = \\frac{1}{2\\mathrm{i}}\\left(e^{\\mathrm{i}3x} - e^{-\\mathrm{i}3x}\\right) + \\frac{1}{2\\mathrm{i}}\\left(e^{\\mathrm{i}9x} - e^{-\\mathrm{i}9x}\\right)\n$$\nDue to the linearity of the DFT, we can find the transform of each component separately and sum the results. Let's analyze the DFT of a general complex exponential term $f_m(x) = e^{\\mathrm{i}mx}$ sampled on the grid, where $m$ is an integer wavenumber. At the grid points $x_j$, this becomes $f_m(x_j) = e^{\\mathrm{i}m(2\\pi j/N)} = \\exp(\\frac{2\\pi \\mathrm{i} m j}{N})$.\n\nThe DFT of this sequence is\n$$\n\\hat{f}_{m,k} = \\sum_{j=0}^{N-1} \\exp\\left(\\frac{2\\pi \\mathrm{i} m j}{N}\\right) \\exp\\left(-\\frac{2\\pi \\mathrm{i} k j}{N}\\right) = \\sum_{j=0}^{N-1} \\exp\\left(\\frac{2\\pi \\mathrm{i} (m-k) j}{N}\\right)\n$$\nThis is a geometric series. According to the orthogonality property of discrete complex exponentials, this sum evaluates to:\n$$\n\\sum_{j=0}^{N-1} \\left(\\exp\\left(\\frac{2\\pi \\mathrm{i} (m-k)}{N}\\right)\\right)^j =\n\\begin{cases}\nN  \\text{if } m-k \\text{ is an integer multiple of } N \\\\\n0  \\text{otherwise}\n\\end{cases}\n$$\nSince the DFT indices $k$ are in the range $\\{0, 1, \\dots, N-1\\}$, the condition \"$m-k$ is an integer multiple of $N$\" simplifies to $k \\equiv m \\pmod N$. For any integer wavenumber $m$, there is a unique index $k$ in this range that satisfies the congruence.\n\nWe now apply this result to each of the four exponential terms in $u(x)$ with $N=8$.\n\nComponent 1: $\\frac{1}{2\\mathrm{i}}e^{\\mathrm{i}3x}$. Here, the wavenumber is $m=3$. The congruence $k \\equiv 3 \\pmod 8$ is satisfied by $k=3$. This term contributes to the DFT coefficient $\\hat{u}_3$. The contribution is its amplitude multiplied by $N$: $\\frac{1}{2\\mathrm{i}} \\times N = \\frac{N}{2\\mathrm{i}} = -\\frac{\\mathrm{i}N}{2}$.\n\nComponent 2: $-\\frac{1}{2\\mathrm{i}}e^{-\\mathrm{i}3x}$. Here, the wavenumber is $m=-3$. The congruence $k \\equiv -3 \\pmod 8$ is satisfied by $k=-3+8=5$. This term contributes to $\\hat{u}_5$. The contribution is its amplitude multiplied by $N$: $-\\frac{1}{2\\mathrm{i}} \\times N = -\\frac{N}{2\\mathrm{i}} = \\frac{\\mathrm{i}N}{2}$.\nThe energy for the $\\sin(3x)$ component is therefore located at indices $k=3$ and $k=5$.\n\nComponent 3: $\\frac{1}{2\\mathrm{i}}e^{\\mathrm{i}9x}$. Here, the wavenumber is $m=9$. This is where aliasing occurs. The Nyquist frequency for a grid of $N=8$ points corresponds to a wavenumber of $N/2=4$. Since $|m|=9  4$, this frequency is aliased. We find its aliased index $k$ from the congruence $k \\equiv 9 \\pmod 8$. Since $9=1 \\times 8 + 1$, we have $k=1$. This high-frequency component is indistinguishable from the component with wavenumber $m=1$ on the discrete grid. Its contribution to the DFT is at index $\\hat{u}_1$. The amplitude is $\\frac{1}{2\\mathrm{i}}$, so the contribution is $\\frac{1}{2\\mathrm{i}} \\times N = -\\frac{\\mathrm{i}N}{2}$.\n\nComponent 4: $-\\frac{1}{2\\mathrm{i}}e^{-\\mathrm{i}9x}$. Here, the wavenumber is $m=-9$. The congruence is $k \\equiv -9 \\pmod 8$. Since $-9=-2 \\times 8 + 7$, we have $k=7$. (Alternatively, $-9 \\equiv -1 \\pmod 8$, which corresponds to index $k=N-1=7$). This component is aliased to the mode with wavenumber $m=-1$. Its contribution to the DFT is at index $\\hat{u}_7$. The amplitude is $-\\frac{1}{2\\mathrm{i}}$, so the contribution is $-\\frac{1}{2\\mathrm{i}} \\times N = \\frac{\\mathrm{i}N}{2}$.\nThe high-frequency component $\\sin(9x)$ aliases to the low-frequency component $\\sin(x)$ on the grid because $e^{\\mathrm{i}9x_j}=e^{\\mathrm{i}9(2\\pi j/8)}=e^{\\mathrm{i}(8+1)(2\\pi j/8)}=e^{\\mathrm{i}2\\pi j}e^{\\mathrm{i}1(2\\pi j/8)}=e^{\\mathrm{i}x_j}$. Similarly, $e^{-\\mathrm{i}9x_j}=e^{-\\mathrm{i}x_j}$. The energy for the $\\sin(9x)$ component is aliased to indices $k=1$ and $k=7$.\n\nWe assemble the complete vector of DFT coefficients $\\hat{u}_k$ by summing the contributions at each index $k \\in \\{0, 1, \\dots, 7\\}$ for $N=8$.\n- $\\hat{u}_0 = 0$, as there is no zero-frequency (constant) term.\n- $\\hat{u}_1$: Contribution from aliased $e^{\\mathrm{i}9x}$ term: $-\\frac{\\mathrm{i}N}{2} = -\\frac{8\\mathrm{i}}{2} = -4\\mathrm{i}$.\n- $\\hat{u}_2 = 0$.\n- $\\hat{u}_3$: Contribution from $e^{\\mathrm{i}3x}$ term: $-\\frac{\\mathrm{i}N}{2} = -\\frac{8\\mathrm{i}}{2} = -4\\mathrm{i}$.\n- $\\hat{u}_4 = 0$.\n- $\\hat{u}_5$: Contribution from $e^{-\\mathrm{i}3x}$ term: $\\frac{\\mathrm{i}N}{2} = \\frac{8\\mathrm{i}}{2} = 4\\mathrm{i}$. (Index $k=5 = 8-3$).\n- $\\hat{u}_6 = 0$.\n- $\\hat{u}_7$: Contribution from aliased $e^{-\\mathrm{i}9x}$ term: $\\frac{\\mathrm{i}N}{2} = \\frac{8\\mathrm{i}}{2} = 4\\mathrm{i}$. (Index $k=7 = 8-1$).\n\nThe complete vector of DFT coefficients is $(\\hat{u}_0, \\hat{u}_1, \\hat{u}_2, \\hat{u}_3, \\hat{u}_4, \\hat{u}_5, \\hat{u}_6, \\hat{u}_7)$.\nSubstituting the calculated values yields:\n$$\n(0, -4\\mathrm{i}, 0, -4\\mathrm{i}, 0, 4\\mathrm{i}, 0, 4\\mathrm{i})\n$$\nThis result reflects the property that for a real-valued input signal $u(x_j)$, the DFT coefficients must satisfy the conjugate symmetry property $\\hat{u}_k = \\overline{\\hat{u}_{N-k}}$ for $k=1, \\dots, N-1$.\nLet's check:\n$\\hat{u}_1 = -4\\mathrm{i}$, $\\hat{u}_{8-1}=\\hat{u}_7 = 4\\mathrm{i}$. $\\overline{\\hat{u}_7} = -4\\mathrm{i} = \\hat{u}_1$. Correct.\n$\\hat{u}_2 = 0$, $\\hat{u}_{8-2}=\\hat{u}_6 = 0$. $\\overline{\\hat{u}_6} = 0 = \\hat{u}_2$. Correct.\n$\\hat{u}_3 = -4\\mathrm{i}$, $\\hat{u}_{8-3}=\\hat{u}_5 = 4\\mathrm{i}$. $\\overline{\\hat{u}_5} = -4\\mathrm{i} = \\hat{u}_3$. Correct.\n$\\hat{u}_4=0$, $\\hat{u}_{8-4}=\\hat{u}_4=0$. This coefficient must be real, which it is. Correct.\nThe derivation is consistent.", "answer": "$$\n\\boxed{\\begin{pmatrix}0  -4\\mathrm{i}  0  -4\\mathrm{i}  0  4\\mathrm{i}  0  4\\mathrm{i}\\end{pmatrix}}\n$$", "id": "3362811"}, {"introduction": "Having seen how aliasing corrupts spectral data, the next step is to learn how to prevent it. For the quadratic nonlinearities common in fluid dynamics and other fields, the \"three-halves rule\" is a standard and effective dealiasing technique. This hands-on coding exercise [@problem_id:3362836] guides you through implementing this rule by zero-padding spectral data, performing the nonlinear multiplication on a larger grid, and verifying that the result matches the exact, non-aliased convolution for the resolved modes. This practice solidifies the connection between the theory of dealiasing and its practical implementation in a numerical code.", "problem": "Consider a one-dimensional, $2\\pi$-periodic function represented on a uniform grid of $N$ points and its Discrete Fourier Transform (DFT). Let the DFT conventions be those used by standard numerical libraries: the forward DFT of a grid function $u_j$, $j=0,\\dots,N-1$, is given by\n$$\n\\hat{u}_k = \\sum_{j=0}^{N-1} u_j \\, e^{-2\\pi i j k / N},\n$$\nand the inverse DFT is given by\n$$\nu_j = \\frac{1}{N} \\sum_{k=0}^{N-1} \\hat{u}_k \\, e^{2\\pi i j k / N}.\n$$\nPointwise multiplication in physical space corresponds to circular convolution in spectral space. Specifically, for the product $w_j = u_j v_j$, one has\n$$\n\\widehat{w}_k = \\frac{1}{N} \\sum_{p=0}^{N-1} \\hat{u}_p \\, \\hat{v}_{(k-p) \\bmod N}.\n$$\nAliasing arises because the spectral convolution is taken modulo $N$. When the input spectra are band-limited to $|k| \\le K_{\\max}$ and one is interested in the product spectrum for $|k| \\le K_{\\max}$, zero-padding the spectra to a longer length $M$ with $M \\ge \\frac{3}{2} N$ (the so-called three-halves rule) and performing the pseudoproduct at this higher resolution prevents wrap-around in the convolution for the resolved band, thereby eliminating aliasing for quadratic nonlinearities.\n\nYour task is to implement a computation for $N=12$ with input spectra supported in $|k| \\le 4$ that demonstrates the following statement:\nfor all resolved modes $|k| \\le 4$, the three-halves padding (zero-padding to $M = \\frac{3}{2} N = 18$) yields the same spectral coefficients $\\widehat{(uv)}_k$ as the exact, non-aliased convolution\n$$\n\\widehat{(uv)}_k^{\\mathrm{exact}} = \\frac{1}{M} \\sum_{p=-4}^{4} \\hat{u}_p \\, \\hat{v}_{k-p},\n$$\nwhere terms with $k-p$ outside $[-4,4]$ are treated as zero. In other words, when the spectra of $u$ and $v$ vanish outside $|k| \\le 4$ and the product is formed by inverse DFT at length $M=18$, multiplication in physical space followed by forward DFT produces\n$$\n\\widehat{(uv)}_k^{\\mathrm{pad}} = \\frac{1}{M} \\sum_{p=-4}^{4} \\hat{u}_p \\, \\hat{v}_{k-p}\n$$\nfor all $|k| \\le 4$, with no circular wrap-around influencing these modes.\n\nImplement a program that:\n- Constructs test spectra $\\hat{u}_k$ and $\\hat{v}_k$ supported in $|k| \\le 4$ on the $N=12$ grid, represented using the $N$-point DFT binning convention for even $N$: the integer wavenumbers $k$ correspond to DFT bins with $k=0,1,\\dots,5,-6,-5,\\dots,-1$ mapped to indices $0,1,\\dots,5,6,7,\\dots,11$ respectively.\n- Builds $M=18$-length zero-padded spectra by placing the same $\\hat{u}_k$ and $\\hat{v}_k$ values at the corresponding $M$-point DFT bins for $k=-4,-3,\\dots,4$ (with $M$ even, bins correspond to $k=0,1,\\dots,8,-9,-8,\\dots,-1$ mapped to indices $0,1,\\dots,8,9,10,\\dots,17$).\n- Computes the padded pseudoproduct by inverse DFT to physical space at length $M$, pointwise multiplication, and forward DFT back to spectral space, yielding $\\widehat{(uv)}_k^{\\mathrm{pad}}$ for $|k| \\le 4$ from the $M$-point transform.\n- Computes the exact, non-aliased convolution coefficients $\\widehat{(uv)}_k^{\\mathrm{exact}}$ for $|k| \\le 4$ using the linear (non-modular) sum shown above with the factor $\\frac{1}{M}$, treating $\\hat{u}_p$ and $\\hat{v}_{q}$ as zero when $p$ or $q$ lie outside $[-4,4]$.\n- Reports, for each test case, the maximum absolute discrepancy\n$$\n\\max_{|k| \\le 4} \\left| \\widehat{(uv)}_k^{\\mathrm{pad}} - \\widehat{(uv)}_k^{\\mathrm{exact}} \\right|.\n$$\n\nDesign a test suite of four cases to exercise different facets:\n1. A general case with random complex coefficients for $\\hat{u}_k$ and $\\hat{v}_k$ over $k=-4,\\dots,4$, using a fixed random seed for reproducibility.\n2. A boundary case where only the highest resolved modes are nonzero: $\\hat{u}_{\\pm 4}$ and $\\hat{v}_{\\pm 4}$ nonzero, all other coefficients zero.\n3. A real-valued function case where $\\hat{u}_k$ satisfies Hermitian symmetry $\\hat{u}_{-k} = \\overline{\\hat{u}_k}$ and $\\hat{u}_0$ is real, while $\\hat{v}_k$ is general complex, both supported in $|k| \\le 4$.\n4. A constant times band-limited case: $\\hat{u}_0$ nonzero and all other $\\hat{u}_k=0$, while $\\hat{v}_k$ is general complex supported in $|k| \\le 4$.\n\nFor each case, your program should compute the maximum discrepancy as specified above. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example:\n$$\n[\\text{e}_1,\\text{e}_2,\\text{e}_3,\\text{e}_4]\n$$\nwhere each $\\text{e}_i$ is a floating-point number. No physical units or angle units are involved. All four outputs must be floats. The expected outcome is that each $\\text{e}_i$ is on the order of machine precision, thereby demonstrating that three-halves padding reproduces the exact, non-aliased convolution for the resolved band $|k| \\le 4$ under the given conditions.", "solution": "The problem statement requires a numerical verification of the three-halves ($3/2$) dealiasing rule for a quadratic nonlinearity in a spectral method context. The problem is scientifically sound, well-posed, and all necessary parameters and definitions for its solution are provided. It is a canonical exercise in understanding the mechanics of spectral transforms and aliasing control.\n\nThe fundamental principle being tested is that pointwise multiplication of two functions, $u(x)$ and $v(x)$, in physical space corresponds to a convolution of their spectra, $\\hat{u}_k$ and $\\hat{v}_k$, in spectral space. When using a Discrete Fourier Transform (DFT) on a finite grid of $N$ points, this convolution becomes circular (i.e., modulo $N$). This circularity can cause high-frequency components of the product to \"wrap around\" and corrupt the low-frequency components, an effect known as aliasing.\n\nThe three-halves rule is a specific form of the more general zero-padding or padding method to eliminate this aliasing. If the input functions $u$ and $v$ are band-limited, with spectra non-zero only for wavenumbers $|k| \\le K_{\\max}$, their product $w = uv$ will have a spectrum band-limited to $|k| \\le 2K_{\\max}$. To prevent aliasing in the original resolved band ($|k| \\le K_{\\max}$), we must perform the calculation on a grid large enough to ensure that wrap-around does not occur. The condition for a quadratic nonlinearity is that the padded grid size $M$ must satisfy $M > 3K_{\\max}$.\n\nIn this problem, we are given $N=12$ and the input spectra are band-limited to $K_{\\max}=4$. The three-halves rule suggests padding to $M = \\frac{3}{2}N = 18$. This satisfies the dealiasing condition, since $M=18 > 3K_{\\max} = 3 \\times 4 = 12$. The task is to show that for the resolved modes $|k| \\le 4$, the result of this padded computation is identical to the exact, non-aliased convolution sum.\n\nThe solution proceeds by implementing and comparing two computational paths for the product spectrum $\\widehat{(uv)}_k$.\n\n**Path 1: Padded Pseudospectral Product $\\widehat{(uv)}_k^{\\mathrm{pad}}$**\n\nThis path simulates the numerical procedure used in spectral codes.\n1.  **Spectrum Representation**: The input spectral coefficients, $\\hat{u}_k$ and $\\hat{v}_k$ for $|k| \\le 4$, are generated for each test case.\n2.  **Zero-Padding**: Two complex-valued arrays of length $M=18$ are initialized to zero. The input coefficients $\\hat{u}_k$ and $\\hat{v}_k$ are placed into these arrays at the indices corresponding to their respective wavenumbers $k \\in [-4, 4]$. The mapping from wavenumber $k$ to a DFT array index for a given transform size is provided by standard library functions, such as `numpy.fft.fftfreq`. For $M=18$, the integer wavenumbers are ordered as $k=0, 1, \\dots, 8, -9, -8, \\dots, -1$.\n3.  **Transform to Physical Space**: An inverse DFT of size $M$ is applied to each padded spectral array, $\\hat{u}^{\\mathrm{pad}}$ and $\\hat{v}^{\\mathrm{pad}}$, to obtain the corresponding functions on the padded physical grid, $u_j$ and $v_j$ for $j=0, \\dots, M-1$. Following the standard convention given, the inverse DFT includes a normalization factor of $1/M$:\n    $$u_j = \\frac{1}{M} \\sum_{k} \\hat{u}^{\\mathrm{pad}}_k e^{2\\pi i j k / M}$$\n4.  **Pointwise Multiplication**: The functions are multiplied pointwise on the $M$-point physical grid: $w_j = u_j v_j$.\n5.  **Transform to Spectral Space**: A forward DFT of size $M$ is applied to the product $w_j$ to obtain its spectrum, $\\widehat{(uv)}_k^{\\mathrm{pad}}$.\n\n**Path 2: Exact Non-Aliased Convolution $\\widehat{(uv)}_k^{\\mathrm{exact}}$**\n\nThis path computes the mathematically exact, linear convolution sum, which serves as the ground truth. The convolution theorem for the DFT states that the padded procedure yields:\n$$ \\widehat{(uv)}_k^{\\mathrm{pad}} = \\frac{1}{M} \\sum_{p} \\hat{u}^{\\mathrm{pad}}_p \\hat{v}^{\\mathrm{pad}}_{(k-p) \\pmod M} $$\nAs established, for $|k| \\le 4$, $|p| \\le 4$, and $M=18$, the sum of wavenumbers $p+(k-p)$ will not alias into the range of interest. Therefore, the modulo operation is inconsequential, and the result should match the linear convolution. We compute this sum directly:\n$$ \\widehat{(uv)}_k^{\\mathrm{exact}} = \\frac{1}{M} \\sum_{p=-4}^{4} \\hat{u}_p \\hat{v}_{k-p} $$\nwhere the input coefficients $\\hat{u}_p$ and $\\hat{v}_{k-p}$ are taken to be zero if their corresponding wavenumbers are outside the range $[-4, 4]$. This sum is computed for each target wavenumber $k \\in [-4, 4]$.\n\n**Comparison and Verification**\n\nFor each of the four test cases, the program computes both $\\widehat{(uv)}_k^{\\mathrm{pad}}$ and $\\widehat{(uv)}_k^{\\mathrm{exact}}$ for all wavenumbers in the original resolved band, $|k| \\le 4$. The maximum absolute difference between the results of the two paths is calculated:\n$$ \\max_{|k| \\le 4} \\left| \\widehat{(uv)}_k^{\\mathrm{pad}} - \\widehat{(uv)}_k^{\\mathrm{exact}} \\right| $$\nAs predicted by the theory, this difference should be on the order of machine floating-point precision, numerically demonstrating that the three-halves padding rule successfully eliminates aliasing error for the resolved spectral modes. The four test cases are designed to probe different scenarios (general, boundary, real-valued, constant) to ensure the robustness of this conclusion.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_discrepancy(u_hat_coeffs, v_hat_coeffs, M, K_max):\n    \"\"\"\n    Calculates the maximum discrepancy between the padded pseudospectral product\n    and the exact non-aliased convolution.\n\n    Args:\n        u_hat_coeffs (dict): Coefficients for u_hat, mapping k - value.\n        v_hat_coeffs (dict): Coefficients for v_hat, mapping k - value.\n        M (int): Padded grid size.\n        K_max (int): Maximum wavenumber for inputs.\n\n    Returns:\n        float: The maximum absolute discrepancy.\n    \"\"\"\n    # Define the wavenumbers we are interested in for both input and output.\n    wavenumbers_of_interest = list(range(-K_max, K_max + 1))\n\n    # --- Path 1: Padded Pseudospectral Product ---\n\n    # Map integer wavenumbers to their indices in the M-point DFT array.\n    k_vals_M = np.fft.fftfreq(M, 1/M)\n    k_map_M = {int(round(k)): i for i, k in enumerate(k_vals_M)}\n\n    # Create M-length spectral arrays and populate them (zero-padding).\n    u_hat_M = np.zeros(M, dtype=complex)\n    v_hat_M = np.zeros(M, dtype=complex)\n    \n    for k in wavenumbers_of_interest:\n        # Check if the wavenumber k is representable on the M-grid\n        if k in k_map_M:\n            idx = k_map_M[k]\n            u_hat_M[idx] = u_hat_coeffs.get(k, 0)\n            v_hat_M[idx] = v_hat_coeffs.get(k, 0)\n\n    # IFFT to physical space, pointwise multiply, then FFT back to spectral space.\n    # numpy's ifft includes the 1/M normalization factor as per the problem.\n    u_M = np.fft.ifft(u_hat_M)\n    v_M = np.fft.ifft(v_hat_M)\n    w_M = u_M * v_M\n    w_hat_padded = np.fft.fft(w_M)\n\n    # --- Path 2: Exact Non-Aliased Convolution ---\n\n    w_hat_exact = {}\n    for k in wavenumbers_of_interest:\n        conv_sum = 0.0 + 0.0j\n        # Sum over p from -K_max to K_max\n        for p in wavenumbers_of_interest:\n            u_p = u_hat_coeffs.get(p, 0)\n            # v_q where q = k-p. .get() handles cases where k-p is out of band.\n            v_k_minus_p = v_hat_coeffs.get(k - p, 0)\n            conv_sum += u_p * v_k_minus_p\n        \n        w_hat_exact[k] = (1 / M) * conv_sum\n\n    # --- Comparison ---\n\n    max_discrepancy = 0.0\n    for k in wavenumbers_of_interest:\n        # Get the coefficient from the padded product result array.\n        idx = k_map_M[k]\n        val_padded = w_hat_padded[idx]\n        \n        # Get the coefficient from the exact convolution calculation.\n        val_exact = w_hat_exact[k]\n        \n        discrepancy = np.abs(val_padded - val_exact)\n        if discrepancy  max_discrepancy:\n            max_discrepancy = discrepancy\n\n    return max_discrepancy\n\ndef solve():\n    \"\"\"\n    Main function to run the four test cases and print results.\n    \"\"\"\n    # Define problem parameters\n    N = 12\n    M = int(N * 3 / 2)  # M = 18\n    K_max = 4\n\n    wavenumbers = list(range(-K_max, K_max + 1))\n    \n    # --- Test Case Generation ---\n\n    # Case 1: General case with random complex coefficients\n    rng1 = np.random.default_rng(seed=123)\n    u_hat_1 = {k: rng1.uniform(-1, 1) + 1j * rng1.uniform(-1, 1) for k in wavenumbers}\n    v_hat_1 = {k: rng1.uniform(-1, 1) + 1j * rng1.uniform(-1, 1) for k in wavenumbers}\n\n    # Case 2: Boundary case where only the highest resolved modes are nonzero\n    rng2 = np.random.default_rng(seed=456)\n    u_hat_2 = {\n        4: rng2.uniform(-1, 1) + 1j * rng2.uniform(-1, 1),\n        -4: rng2.uniform(-1, 1) + 1j * rng2.uniform(-1, 1)\n    }\n    v_hat_2 = {\n        4: rng2.uniform(-1, 1) + 1j * rng2.uniform(-1, 1),\n        -4: rng2.uniform(-1, 1) + 1j * rng2.uniform(-1, 1)\n    }\n\n    # Case 3: Real-valued function u (Hermitian symmetry)\n    rng3 = np.random.default_rng(seed=789)\n    u_hat_3 = {}\n    u_hat_3[0] = rng3.uniform(-1, 1)  # u_0 must be real\n    for k in range(1, K_max + 1):\n        val = rng3.uniform(-1, 1) + 1j * rng3.uniform(-1, 1)\n        u_hat_3[k] = val\n        u_hat_3[-k] = np.conj(val)\n    v_hat_3 = {k: rng3.uniform(-1, 1) + 1j * rng3.uniform(-1, 1) for k in wavenumbers}\n\n    # Case 4: Constant times band-limited case (u has only k=0 mode)\n    rng4 = np.random.default_rng(seed=101)\n    u_hat_4 = {0: rng4.uniform(-1, 1) + 1j * rng4.uniform(-1, 1)}\n    v_hat_4 = {k: rng4.uniform(-1, 1) + 1j * rng4.uniform(-1, 1) for k in wavenumbers}\n    \n    test_cases = [\n        (u_hat_1, v_hat_1),\n        (u_hat_2, v_hat_2),\n        (u_hat_3, v_hat_3),\n        (u_hat_4, v_hat_4),\n    ]\n\n    results = []\n    for u_coeffs, v_coeffs in test_cases:\n        discrepancy = calculate_discrepancy(u_coeffs, v_coeffs, M, K_max)\n        results.append(discrepancy)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3362836"}, {"introduction": "In computational science, accuracy and efficiency are often in tension. While dealiasing techniques like the three-halves rule are essential for numerical stability and correctness, they do not come for free. This analytical exercise [@problem_id:3362866] asks you to quantify the trade-offs by deriving the asymptotic increase in both computational cost and memory footprint associated with this method. By analyzing the algorithm's complexity, you will develop a crucial skill: evaluating not just whether a method works, but how much it costs, which is paramount when designing large-scale simulations.", "problem": "Consider the evaluation of a quadratic nonlinearity in a one-dimensional pseudo-spectral method on a periodic domain, where two fields $u$ and $v$ are represented by their Fourier coefficients $\\{u_{k}\\}$ and $\\{v_{k}\\}$ with $N$ retained modes. The nonlinear product $q(x)=u(x)\\,v(x)$ is computed via transforms between spectral and physical space.\n\nThe naive pseudo-spectral procedure (without dealiasing) computes $u(x)$ and $v(x)$ by inverse Fast Fourier Transform (FFT), multiplies them pointwise in physical space, and then applies a forward FFT to obtain the spectral coefficients $\\{q_{k}\\}$ at length $N$.\n\nTo enforce the two-thirds dealiasing rule, the $3/2$-padding method first zero-pads both $\\{u_{k}\\}$ and $\\{v_{k}\\}$ from length $N$ to length $M=\\frac{3}{2}N$, computes the inverse FFTs at length $M$ to obtain $u(x)$ and $v(x)$ at the padded resolution, multiplies these in physical space, and then applies a forward FFT at length $M$ followed by truncation back to the first $N$ modes and spectral filtering that zeroes all modes beyond the two-thirds cutoff. Assume all non-FFT operations (padding, truncation, masking, and pointwise multiplication) are lower order and can be neglected in the leading-order operation count.\n\nModel the cost of an FFT of length $m$ as $c\\,m\\,\\ln(m)$ floating-point operations for some constant $c0$ that does not depend on $m$. Assume that, at the moment of the pointwise multiplication, the algorithm must hold two complex arrays in memory at the current transform length and that any additional fixed overheads are negligible compared to array storage.\n\nDerive the leading-order asymptotic ratio $R(N)$ of the total operation count of the $3/2$-padding method relative to the naive method, and the leading-order ratio $S(N)$ of the peak memory footprint of the $3/2$-padding method relative to the naive method. Then take the limit $N\\to\\infty$ to obtain constants $R_{\\infty}$ and $S_{\\infty}$.\n\nProvide your final answer as the row matrix $\\begin{pmatrix}R_{\\infty}  S_{\\infty}\\end{pmatrix}$. No rounding is required.", "solution": "The user has asked for a critical validation of the problem statement, followed by a formal solution if the problem is deemed valid.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n- **Computation Task:** Evaluation of a quadratic nonlinearity $q(x) = u(x)v(x)$ in a one-dimensional pseudo-spectral method.\n- **Input Data:** Fourier coefficients $\\{u_k\\}$ and $\\{v_k\\}$ for two fields, with $N$ retained modes.\n- **Naive Method:**\n    1.  Two inverse Fast Fourier Transforms (FFTs) of length $N$.\n    2.  Pointwise multiplication of the resulting physical space arrays.\n    3.  One forward FFT of length $N$.\n- **3/2-Padding Method:**\n    1.  Zero-pad coefficient arrays $\\{u_k\\}$ and $\\{v_k\\}$ from length $N$ to $M = \\frac{3}{2}N$.\n    2.  Two inverse FFTs of length $M$.\n    3.  Pointwise multiplication of the resulting physical space arrays (of length $M$).\n    4.  One forward FFT of length $M$.\n    5.  Truncation and spectral filtering (cost is negligible).\n- **Cost Model for Operations:**\n    - Cost of an FFT of length $m$: $C_{FFT}(m) = c\\,m\\,\\ln(m)$ for some constant $c  0$.\n    - Costs of padding, truncation, filtering, and pointwise multiplication are negligible for the leading-order operation count.\n- **Memory Model:**\n    - Peak memory footprint is the storage for holding two complex arrays at the current transform length during the pointwise multiplication step.\n    - Other memory overheads are negligible.\n- **Required Output:**\n    1.  The leading-order asymptotic ratio $R(N)$ of total operation count ($3/2$-padding vs. naive), and its limit $R_{\\infty} = \\lim_{N\\to\\infty} R(N)$.\n    2.  The leading-order ratio $S(N)$ of peak memory footprint ($3/2$-padding vs. naive), and its limit $S_{\\infty} = \\lim_{N\\to\\infty} S(N)$.\n    3.  The final answer as the row matrix $\\begin{pmatrix} R_{\\infty}  S_{\\infty} \\end{pmatrix}$.\n\n**Step 2: Validate Using Extracted Givens**\n- **Scientifically Grounded:** The problem is grounded in the well-established field of numerical methods for Partial Differential Equations (PDEs), specifically spectral methods. The concept of aliasing in the computation of nonlinear terms and its mitigation via the 2/3-rule (and its implementation via padding) is a standard topic.\n- **Well-Posed:** The problem is well-posed. The algorithms for both methods are described unambiguously. The cost and memory models are explicitly defined, allowing for a unique calculation. The requirement for asymptotic ratios as $N \\to \\infty$ is a standard analysis technique in computational science. The use of $M=\\frac{3}{2}N$ presumes $N$ is even, which is customary for FFTs and does not affect the asymptotic result.\n- **Objective:** The language is formal, precise, and objective, typical of a computational science problem.\n\nThe problem statement is a standard exercise in analyzing the computational complexity of numerical algorithms. It is self-contained, scientifically sound, and unambiguous. There are no contradictions, missing pieces of information, or non-formalizable analogies.\n\n**Step 3: Verdict and Action**\n- **Verdict:** The problem is valid.\n- **Action:** Proceed to the solution.\n\n### Solution\n\nThe solution requires calculating the total operation count and peak memory footprint for the two specified methods and then finding the asymptotic ratio of these quantities.\n\n**1. Operation Count Analysis**\n\nLet the cost of an FFT of length $m$ be given by $C_{FFT}(m) = c\\,m\\,\\ln(m)$, where $c$ is a constant. Per the problem statement, we only consider the cost of FFTs for the leading-order operation count.\n\n**Naive Method:**\nThe naive method involves three FFTs, all of length $N$:\n- One inverse FFT for $\\{u_k\\}$ to get $u(x)$.\n- One inverse FFT for $\\{v_k\\}$ to get $v(x)$.\n- One forward FFT for the product $q(x)$ to get $\\{q_k\\}$.\n\nThe total leading-order operation count for the naive method, $C_{\\text{naive}}(N)$, is the sum of the costs of these three transforms:\n$$C_{\\text{naive}}(N) = 3 \\times C_{FFT}(N) = 3\\,c\\,N\\,\\ln(N)$$\n\n**3/2-Padding Method:**\nThis method pads the arrays to length $M = \\frac{3}{2}N$ and performs the transforms at this larger size. It involves three FFTs, all of length $M$:\n- One inverse FFT for the padded $\\{u_k\\}$.\n- One inverse FFT for the padded $\\{v_k\\}$.\n- One forward FFT for the product.\n\nThe total leading-order operation count for the $3/2$-padding method, $C_{3/2}(N)$, is:\n$$C_{3/2}(N) = 3 \\times C_{FFT}(M) = 3\\,c\\,M\\,\\ln(M)$$\nSubstituting $M = \\frac{3}{2}N$:\n$$C_{3/2}(N) = 3\\,c\\,\\left(\\frac{3}{2}N\\right)\\ln\\left(\\frac{3}{2}N\\right)$$\n\n**Ratio of Operation Counts, $R(N)$:**\nThe ratio $R(N)$ is given by $C_{3/2}(N) / C_{\\text{naive}}(N)$:\n$$R(N) = \\frac{3\\,c\\,\\left(\\frac{3}{2}N\\right)\\ln\\left(\\frac{3}{2}N\\right)}{3\\,c\\,N\\,\\ln(N)} = \\frac{3}{2} \\frac{\\ln\\left(\\frac{3}{2}N\\right)}{\\ln(N)}$$\nUsing the property of logarithms $\\ln(ab) = \\ln(a) + \\ln(b)$:\n$$R(N) = \\frac{3}{2} \\frac{\\ln\\left(\\frac{3}{2}\\right) + \\ln(N)}{\\ln(N)} = \\frac{3}{2} \\left(1 + \\frac{\\ln\\left(\\frac{3}{2}\\right)}{\\ln(N)}\\right)$$\n\n**Asymptotic Limit $R_{\\infty}$:**\nWe take the limit of $R(N)$ as $N \\to \\infty$:\n$$R_{\\infty} = \\lim_{N\\to\\infty} R(N) = \\lim_{N\\to\\infty} \\frac{3}{2} \\left(1 + \\frac{\\ln\\left(\\frac{3}{2}\\right)}{\\ln(N)}\\right)$$\nAs $N \\to \\infty$, $\\ln(N) \\to \\infty$, which implies $\\frac{\\ln(\\frac{3}{2})}{\\ln(N)} \\to 0$.\n$$R_{\\infty} = \\frac{3}{2} (1 + 0) = \\frac{3}{2}$$\n\n**2. Memory Footprint Analysis**\n\nLet $\\sigma$ be the amount of memory required to store a single complex number. The peak memory footprint is determined by the size of the two complex arrays held in memory at the time of the pointwise multiplication.\n\n**Naive Method:**\nThe pointwise multiplication occurs in physical space between two arrays of length $N$. Thus, the peak memory footprint, $M_{\\text{naive}}(N)$, is:\n$$M_{\\text{naive}}(N) = 2\\,\\sigma\\,N$$\n\n**3/2-Padding Method:**\nThe pointwise multiplication occurs on the padded grid of length $M = \\frac{3}{2}N$. The two arrays in physical space are of this length. The peak memory footprint, $M_{3/2}(N)$, is:\n$$M_{3/2}(N) = 2\\,\\sigma\\,M = 2\\,\\sigma\\left(\\frac{3}{2}N\\right) = 3\\,\\sigma\\,N$$\n\n**Ratio of Memory Footprints, $S(N)$:**\nThe ratio $S(N)$ is given by $M_{3/2}(N) / M_{\\text{naive}}(N)$:\n$$S(N) = \\frac{3\\,\\sigma\\,N}{2\\,\\sigma\\,N} = \\frac{3}{2}$$\n\n**Asymptotic Limit $S_{\\infty}$:**\nThe ratio $S(N)$ is a constant, independent of $N$. Therefore, its limit as $N \\to \\infty$ is the constant itself:\n$$S_{\\infty} = \\lim_{N\\to\\infty} S(N) = \\lim_{N\\to\\infty} \\frac{3}{2} = \\frac{3}{2}$$\n\n**Final Answer Construction**\n\nThe problem asks for the final answer in the form of a row matrix $\\begin{pmatrix} R_{\\infty}  S_{\\infty} \\end{pmatrix}$.\nSubstituting the derived values:\n$$R_{\\infty} = \\frac{3}{2}$$\n$$S_{\\infty} = \\frac{3}{2}$$\nThe resulting matrix is $\\begin{pmatrix} \\frac{3}{2}  \\frac{3}{2} \\end{pmatrix}$.", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{3}{2}  \\frac{3}{2}\n\\end{pmatrix}\n}\n$$", "id": "3362866"}]}