{"hands_on_practices": [{"introduction": "The \"reference element\" is a cornerstone of the finite element method, simplifying analysis by standardizing calculations on a canonical geometry. This exercise solidifies this concept by guiding you through the derivation of the Crouzeix-Raviart basis functions on a reference triangle. By exploring how these functions and their gradients transform under affine mapping, you will master the fundamental mechanics needed to apply these elements to any arbitrary mesh [@problem_id:3376187].", "problem": "Consider the Crouzeix–Raviart (CR) nonconforming finite element for the Poisson model problem on triangles. Let the reference triangle be $\\hat{T}$ with vertices $(0,0)$, $(1,0)$, and $(0,1)$. The local CR shape functions on $\\hat{T}$ are the unique linear functions $\\hat{\\phi}_{i}$, $i=1,2,3$, such that each $\\hat{\\phi}_{i}$ equals $1$ at the midpoint of one reference edge and $0$ at the midpoints of the other two edges. \n\n1) Using only the defining degrees of freedom at the three edge midpoints, determine the explicit formulae for the reference basis functions $\\hat{\\phi}_{1}$, $\\hat{\\phi}_{2}$, and $\\hat{\\phi}_{3}$ on $\\hat{T}$.\n\n2) Let $F:\\hat{T}\\to T$ be an affine map of the form $x = F(\\hat{x}) = B\\hat{x} + b$, where $B\\in\\mathbb{R}^{2\\times 2}$ is nonsingular and $b\\in\\mathbb{R}^{2}$. Define the physical CR basis functions on $T$ by $\\phi_{i} = \\hat{\\phi}_{i}\\circ F^{-1}$. Starting from the chain rule for derivatives and the change-of-variables formula for integrals, derive the transformation laws that relate:\n- the gradients $\\nabla \\phi_{i}$ on $T$ to the reference gradients $\\hat{\\nabla}\\hat{\\phi}_{i}$ on $\\hat{T}$, and\n- integrals over $T$ and over $\\partial T$ to integrals over $\\hat{T}$ and $\\partial\\hat{T}$, respectively, explicitly expressing the Jacobian scaling factors in terms of $B$.\n\n3) Specialize to the anisotropic diagonal affine map with $B=\\mathrm{diag}(\\alpha,\\beta)$ for given positive parameters $\\alpha$ and $\\beta$. Consider the local stiffness matrix $K_{T}\\in\\mathbb{R}^{3\\times 3}$ with entries \n$$\n(K_{T})_{ij} \\;=\\; \\int_{T} \\nabla \\phi_{i}(x)\\cdot \\nabla \\phi_{j}(x)\\,\\mathrm{d}x.\n$$\nUsing the transformation laws derived in part 2) and your explicit formulas for the reference CR basis functions from part 1), compute the determinant of $K_{T}$ as a closed-form analytic expression in $\\alpha$ and $\\beta$.\n\nYour final answer must be a single closed-form expression. No rounding is required.", "solution": "The problem as stated is well-posed, scientifically grounded in the theory of finite element methods, and provides a complete and consistent set of definitions and data. Therefore, it is a valid problem. We proceed with the solution in three parts as requested.\n\n### Part 1: Derivation of the Reference Basis Functions\n\nLet the reference triangle $\\hat{T}$ be the set of points $(\\hat{x}, \\hat{y})$ in $\\mathbb{R}^2$ with vertices $\\hat{v}_1=(0,0)$, $\\hat{v}_2=(1,0)$, and $\\hat{v}_3=(0,1)$. The edges of this triangle are on the lines $\\hat{x}=0$, $\\hat{y}=0$, and $\\hat{x}+\\hat{y}=1$. The midpoints of the three edges are:\n- $\\hat{m}_1$: Midpoint of the edge connecting $\\hat{v}_2$ and $\\hat{v}_3$, which is $(\\frac{1+0}{2}, \\frac{0+1}{2}) = (\\frac{1}{2}, \\frac{1}{2})$.\n- $\\hat{m}_2$: Midpoint of the edge connecting $\\hat{v}_1$ and $\\hat{v}_3$, which is $(\\frac{0+0}{2}, \\frac{0+1}{2}) = (0, \\frac{1}{2})$.\n- $\\hat{m}_3$: Midpoint of the edge connecting $\\hat{v}_1$ and $\\hat{v}_2$, which is $(\\frac{1+0}{2}, \\frac{0+0}{2}) = (\\frac{1}{2}, 0)$.\n\nThe Crouzeix-Raviart (CR) basis functions $\\hat{\\phi}_i$ for $i=1,2,3$ are linear functions of the form $\\hat{\\phi}(\\hat{x}, \\hat{y}) = a\\hat{x} + b\\hat{y} + c$. They are defined by the condition $\\hat{\\phi}_i(\\hat{m}_j) = \\delta_{ij}$, where $\\delta_{ij}$ is the Kronecker delta.\n\n**For $\\hat{\\phi}_1$:**\nWe require $\\hat{\\phi}_1(\\hat{m}_1)=1$, $\\hat{\\phi}_1(\\hat{m}_2)=0$, and $\\hat{\\phi}_1(\\hat{m}_3)=0$. Let $\\hat{\\phi}_1(\\hat{x}, \\hat{y}) = a_1\\hat{x} + b_1\\hat{y} + c_1$. This leads to the system of linear equations:\n$$\n\\begin{cases}\na_1(\\frac{1}{2}) + b_1(\\frac{1}{2}) + c_1 = 1 \\\\\na_1(0) + b_1(\\frac{1}{2}) + c_1 = 0 \\\\\na_1(\\frac{1}{2}) + b_1(0) + c_1 = 0\n\\end{cases}\n$$\nFrom the second equation, $b_1 = -2c_1$. From the third equation, $a_1 = -2c_1$. Substituting these into the first equation gives $(-2c_1)(\\frac{1}{2}) + (-2c_1)(\\frac{1}{2}) + c_1 = 1$, which simplifies to $-c_1 - c_1 + c_1 = 1$, or $-c_1=1$. Thus, $c_1=-1$, which implies $a_1=2$ and $b_1=2$.\nThe first basis function is $\\hat{\\phi}_1(\\hat{x}, \\hat{y}) = 2\\hat{x} + 2\\hat{y} - 1$.\n\n**For $\\hat{\\phi}_2$:**\nWe require $\\hat{\\phi}_2(\\hat{m}_1)=0$, $\\hat{\\phi}_2(\\hat{m}_2)=1$, and $\\hat{\\phi}_2(\\hat{m}_3)=0$. Let $\\hat{\\phi}_2(\\hat{x}, \\hat{y}) = a_2\\hat{x} + b_2\\hat{y} + c_2$.\n$$\n\\begin{cases}\na_2(\\frac{1}{2}) + b_2(\\frac{1}{2}) + c_2 = 0 \\\\\na_2(0) + b_2(\\frac{1}{2}) + c_2 = 1 \\\\\na_2(\\frac{1}{2}) + b_2(0) + c_2 = 0\n\\end{cases}\n$$\nFrom the third equation, $a_2 = -2c_2$. Substituting into the first equation: $(-2c_2)(\\frac{1}{2}) + \\frac{b_2}{2} + c_2 = 0$, which gives $-c_2 + \\frac{b_2}{2} + c_2 = 0$, so $b_2=0$. The second equation then becomes $c_2=1$. This implies $a_2 = -2$.\nThe second basis function is $\\hat{\\phi}_2(\\hat{x}, \\hat{y}) = -2\\hat{x} + 1$.\n\n**For $\\hat{\\phi}_3$:**\nWe require $\\hat{\\phi}_3(\\hat{m}_1)=0$, $\\hat{\\phi}_3(\\hat{m}_2)=0$, and $\\hat{\\phi}_3(\\hat{m}_3)=1$. Let $\\hat{\\phi}_3(\\hat{x}, \\hat{y}) = a_3\\hat{x} + b_3\\hat{y} + c_3$.\n$$\n\\begin{cases}\na_3(\\frac{1}{2}) + b_3(\\frac{1}{2}) + c_3 = 0 \\\\\na_3(0) + b_3(\\frac{1}{2}) + c_3 = 0 \\\\\na_3(\\frac{1}{2}) + b_3(0) + c_3 = 1\n\\end{cases}\n$$\nFrom the second equation, $b_3 = -2c_3$. Substituting into the first equation gives $\\frac{a_3}{2} + (-2c_3)(\\frac{1}{2}) + c_3 = 0$, which implies $a_3=0$. The third equation then becomes $c_3=1$. This implies $b_3 = -2$.\nThe third basis function is $\\hat{\\phi}_3(\\hat{x}, \\hat{y}) = -2\\hat{y} + 1$.\n\nIn summary, the reference basis functions are:\n$$\n\\hat{\\phi}_1(\\hat{x}, \\hat{y}) = 2\\hat{x} + 2\\hat{y} - 1\n$$\n$$\n\\hat{\\phi}_2(\\hat{x}, \\hat{y}) = 1 - 2\\hat{x}\n$$\n$$\n\\hat{\\phi}_3(\\hat{x}, \\haty}) = 1 - 2\\hat{y}\n$$\n\n### Part 2: Transformation Laws\n\nLet $x = F(\\hat{x}) = B\\hat{x} + b$, where $B \\in \\mathbb{R}^{2\\times 2}$ is nonsingular and $b \\in \\mathbb{R}^2$. The inverse map is $\\hat{x} = F^{-1}(x) = B^{-1}(x-b)$. The physical basis functions are $\\phi_i(x) = (\\hat{\\phi}_i \\circ F^{-1})(x) = \\hat{\\phi}_i(B^{-1}(x-b))$.\n\n**Gradient Transformation:**\nWe use the chain rule for derivatives. Let $\\nabla$ and $\\hat{\\nabla}$ denote the gradient operators with respect to $x$ and $\\hat{x}$ respectively.\n$$\n(\\hat{\\nabla} \\hat{\\phi}_i)^T = (\\nabla \\phi_i)^T \\frac{\\partial x}{\\partial \\hat{x}}\n$$\nwhere $\\frac{\\partial x}{\\partial \\hat{x}}$ is the Jacobian matrix of the transformation $F$, denoted $D_{\\hat{x}}F$. For the affine map $F(\\hat{x}) = B\\hat{x} + b$, this Jacobian is simply the matrix $B$. So, $(\\hat{\\nabla} \\hat{\\phi}_i)^T = (\\nabla \\phi_i)^T B$.\nTransposing both sides yields $\\hat{\\nabla} \\hat{\\phi}_i = B^T \\nabla \\phi_i$. Since $B$ is nonsingular, $B^T$ is also nonsingular. We can solve for the physical gradient $\\nabla \\phi_i$:\n$$\n\\nabla \\phi_i(x) = (B^T)^{-1} \\hat{\\nabla} \\hat{\\phi}_i(\\hat{x}) = B^{-T} \\hat{\\nabla} \\hat{\\phi}_i(F^{-1}(x))\n$$\n\n**Integral Transformation (Area):**\nThe standard change of variables formula for a multiple integral is:\n$$\n\\int_T f(x) \\,dx = \\int_{\\hat{T}} f(F(\\hat{x})) |\\det(D_{\\hat{x}}F)| \\,d\\hat{x}\n$$\nThe Jacobian determinant is $|\\det(B)|$. Thus, the transformation for an integral over the triangle area is:\n$$\n\\int_T f(x) \\,dx = |\\det(B)| \\int_{\\hat{T}} f(B\\hat{x}+b) \\,d\\hat{x}\n$$\nThe Jacobian scaling factor for area integrals is $|\\det(B)|$.\n\n**Integral Transformation (Boundary):**\nConsider an edge $\\hat{e}$ of the reference triangle $\\hat{T}$, parameterized by arc length $\\hat{s}$. The corresponding edge on the physical triangle $T$ is $e=F(\\hat{e})$. Let $\\hat{\\tau}$ be a unit tangent vector to $\\hat{e}$. A point on the edge can be written as $\\hat{x}(\\hat{s}) = \\hat{x}_0 + \\hat{s}\\hat{\\tau}$. The corresponding point on the physical edge is $x(\\hat{s}) = F(\\hat{x}(\\hat{s})) = B(\\hat{x}_0 + \\hat{s}\\hat{\\tau}) + b$.\nThe tangent vector on the physical edge is $\\frac{dx}{d\\hat{s}} = B\\hat{\\tau}$. The differential arc length on $e$ is $ds = \\|\\frac{dx}{d\\hat{s}}\\| d\\hat{s} = \\|B\\hat{\\tau}\\| d\\hat{s}$.\nThe transformation for a line integral over an edge $e$ is:\n$$\n\\int_e g(x) \\,ds = \\int_{\\hat{e}} g(F(\\hat{x})) \\|B\\hat{\\tau}\\| \\,d\\hat{s}\n$$\nThe scaling factor is $\\|B\\hat{\\tau}\\|$, which depends on the orientation of the edge $\\hat{e}$. The transformation for the integral over the entire boundary $\\partial T = \\cup_k e_k$ is the sum of the transformations for each edge:\n$$\n\\int_{\\partial T} g(x) \\,ds = \\sum_k \\int_{e_k} g(x) \\,ds = \\sum_k \\int_{\\hat{e}_k} g(F(\\hat{x})) \\|B\\hat{\\tau}_k\\| \\,d\\hat{s}\n$$\nwhere $\\hat{\\tau}_k$ is the unit tangent to edge $\\hat{e}_k$.\n\n### Part 3: Determinant of the Local Stiffness Matrix\n\nThe local stiffness matrix is defined by $(K_T)_{ij} = \\int_T \\nabla \\phi_i(x) \\cdot \\nabla \\phi_j(x) \\,dx$.\nUsing the transformation laws:\n$$\n(K_T)_{ij} = \\int_{\\hat{T}} (B^{-T} \\hat{\\nabla} \\hat{\\phi}_i) \\cdot (B^{-T} \\hat{\\nabla} \\hat{\\phi}_j) |\\det(B)| \\,d\\hat{x}\n$$\nThe gradients of the linear basis functions $\\hat{\\phi}_i$ are constant vectors on $\\hat{T}$. Let $\\hat{g}_i = \\hat{\\nabla} \\hat{\\phi}_i$. The integrand is constant, so we can pull it out of the integral:\n$$\n(K_T)_{ij} = ( (B^{-T} \\hat{g}_i) \\cdot (B^{-T} \\hat{g}_j) ) |\\det(B)| \\int_{\\hat{T}} d\\hat{x}\n$$\nThe area of the reference triangle $\\hat{T}$ is $\\frac{1}{2}$. The inner product can be written using matrix transpose notation: $(B^{-T}\\hat{g}_i)^T (B^{-T}\\hat{g}_j) = \\hat{g}_i^T (B^{-T})^T B^{-T} \\hat{g}_j = \\hat{g}_i^T B^{-1} B^{-T} \\hat{g}_j$.\nFor the given map, $B = \\mathrm{diag}(\\alpha, \\beta) = \\begin{pmatrix} \\alpha & 0 \\\\ 0 & \\beta \\end{pmatrix}$. This matrix is symmetric, so $B^T=B$.\nThen $B^{-1} = \\mathrm{diag}(\\alpha^{-1}, \\beta^{-1})$ and $B^{-T} = B^{-1}$. Also, $|\\det(B)| = |\\alpha\\beta|=\\alpha\\beta$ since $\\alpha, \\beta >0$.\nThe formula for the stiffness matrix entries simplifies to:\n$$\n(K_T)_{ij} = \\frac{\\alpha\\beta}{2} (\\hat{g}_i^T B^{-2} \\hat{g}_j)\n$$\nwhere $B^{-2} = \\mathrm{diag}(\\alpha^{-2}, \\beta^{-2})$.\n\nFrom Part 1, the gradients of the reference basis functions are:\n$\\hat{g}_1 = \\hat{\\nabla}(2\\hat{x} + 2\\hat{y} - 1) = \\begin{pmatrix} 2 \\\\ 2 \\end{pmatrix}$.\n$\\hat{g}_2 = \\hat{\\nabla}(1 - 2\\hat{x}) = \\begin{pmatrix} -2 \\\\ 0 \\end{pmatrix}$.\n$\\hat{g}_3 = \\hat{\\nabla}(1 - 2\\hat{y}) = \\begin{pmatrix} 0 \\\\ -2 \\end{pmatrix}$.\n\nA key observation is that the sum of these gradient vectors is zero:\n$$\n\\hat{g}_1 + \\hat{g}_2 + \\hat{g}_3 = \\begin{pmatrix} 2 \\\\ 2 \\end{pmatrix} + \\begin{pmatrix} -2 \\\\ 0 \\end{pmatrix} + \\begin{pmatrix} 0 \\\\ -2 \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}\n$$\nThis is a consequence of the fact that $\\sum_{i=1}^3 \\hat{\\phi}_i(\\hat{x}, \\hat{y}) = (2\\hat{x} + 2\\hat{y} - 1) + (1 - 2\\hat{x}) + (1 - 2\\hat{y}) = 1$, which is a constant function. The gradient of a constant is zero.\n\nThis linear dependence among the gradient vectors $\\hat{g}_i$ implies that the local stiffness matrix $K_T$ is singular. To see this, consider the vector $c = (1, 1, 1)^T$. Let us compute the product $K_T c$. The $j$-th component is:\n$$\n(K_T c)_j = \\sum_{i=1}^3 (K_T)_{ji} c_i = \\sum_{i=1}^3 (K_T)_{ji} = \\sum_{i=1}^3 \\frac{\\alpha\\beta}{2} (\\hat{g}_j^T B^{-2} \\hat{g}_i)\n$$\n$$\n(K_T c)_j = \\frac{\\alpha\\beta}{2} \\hat{g}_j^T B^{-2} \\left(\\sum_{i=1}^3 \\hat{g}_i\\right) = \\frac{\\alpha\\beta}{2} \\hat{g}_j^T B^{-2} \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix} = 0\n$$\nSince $K_T c = 0$ for the non-zero vector $c=(1,1,1)^T$, the matrix $K_T$ has a non-trivial null space. Therefore, it is singular. The determinant of any singular matrix is zero.\n\nFor completeness, we can construct the matrix $K_T$ explicitly. Let $M_{ij} = \\hat{g}_i^T B^{-2} \\hat{g}_j$. Then $K_T = \\frac{\\alpha\\beta}{2} M$.\n$M_{11} = \\begin{pmatrix} 2 & 2 \\end{pmatrix} \\begin{pmatrix} \\alpha^{-2} & 0 \\\\ 0 & \\beta^{-2} \\end{pmatrix} \\begin{pmatrix} 2 \\\\ 2 \\end{pmatrix} = 4\\alpha^{-2} + 4\\beta^{-2}$.\n$M_{12} = \\begin{pmatrix} 2 & 2 \\end{pmatrix} \\begin{pmatrix} \\alpha^{-2} & 0 \\\\ 0 & \\beta^{-2} \\end{pmatrix} \\begin{pmatrix} -2 \\\\ 0 \\end{pmatrix} = -4\\alpha^{-2}$.\n$M_{13} = \\begin{pmatrix} 2 & 2 \\end{pmatrix} \\begin{pmatrix} \\alpha^{-2} & 0 \\\\ 0 & \\beta^{-2} \\end{pmatrix} \\begin{pmatrix} 0 \\\\ -2 \\end{pmatrix} = -4\\beta^{-2}$.\n$M_{22} = \\begin{pmatrix} -2 & 0 \\end{pmatrix} \\begin{pmatrix} \\alpha^{-2} & 0 \\\\ 0 & \\beta^{-2} \\end{pmatrix} \\begin{pmatrix} -2 \\\\ 0 \\end{pmatrix} = 4\\alpha^{-2}$.\n$M_{23} = \\begin{pmatrix} -2 & 0 \\end{pmatrix} \\begin{pmatrix} \\alpha^{-2} & 0 \\\\ 0 & \\beta^{-2} \\end{pmatrix} \\begin{pmatrix} 0 \\\\ -2 \\end{pmatrix} = 0$.\n$M_{33} = \\begin{pmatrix} 0 & -2 \\end{pmatrix} \\begin{pmatrix} \\alpha^{-2} & 0 \\\\ 0 & \\beta^{-2} \\end{pmatrix} \\begin{pmatrix} 0 \\\\ -2 \\end{pmatrix} = 4\\beta^{-2}$.\nThe matrix $M$ is symmetric:\n$$\nM = 4 \\begin{pmatrix} \\alpha^{-2} + \\beta^{-2} & -\\alpha^{-2} & -\\beta^{-2} \\\\ -\\alpha^{-2} & \\alpha^{-2} & 0 \\\\ -\\beta^{-2} & 0 & \\beta^{-2} \\end{pmatrix}\n$$\nThe sum of entries in each row (or column) of this matrix is zero. For example, for the first row: $(\\alpha^{-2} + \\beta^{-2}) - \\alpha^{-2} - \\beta^{-2} = 0$. This confirms that $(1,1,1)^T$ is in the null space of $M$, and therefore of $K_T$.\nThe determinant of $K_T$ is:\n$$\n\\det(K_T) = \\det\\left(\\frac{\\alpha\\beta}{2} M\\right) = \\left(\\frac{\\alpha\\beta}{2}\\right)^3 \\det(M)\n$$\nSince $M$ is singular, $\\det(M)=0$. It follows immediately that $\\det(K_T)=0$.\n\nThe determinant of the local stiffness matrix for the Crouzeix-Raviart element is zero. This is a general property for any element whose local basis functions sum to a constant (in this case, $\\sum_i \\hat{\\phi}_i = 1$), which makes the corresponding gradient vectors linearly dependent and the resulting stiffness matrix singular.\nThe final closed-form analytic expression for the determinant is $0$.", "answer": "$$\\boxed{0}$$", "id": "3376187"}, {"introduction": "With an understanding of the reference element, the next step is to apply this knowledge to solve a boundary value problem. This practice bridges the gap between local element theory and global system assembly by tasking you with constructing the stiffness matrix for a Poisson equation on a simple two-element mesh. You will translate the abstract formulation into concrete numerical values, gaining hands-on experience with the core computational loop of the finite element method [@problem_id:3376155].", "problem": "Consider the homogeneous Poisson problem $-\\Delta u = f$ on the square domain $\\Omega = [0,1]^{2}$ with homogeneous Dirichlet boundary conditions. Let $\\mathcal{T}_{h}$ be the triangulation of $\\Omega$ into two triangles $T_{1}$ and $T_{2}$ obtained by cutting along the diagonal from $(0,0)$ to $(1,1)$:\n- $T_{1}$ has vertices $v_{1} = (0,0)$, $v_{2} = (1,0)$, $v_{3} = (1,1)$.\n- $T_{2}$ has vertices $w_{1} = (0,0)$, $w_{2} = (1,1)$, $w_{3} = (0,1)$.\n\nApproximate the problem using the Crouzeix–Raviart (CR) nonconforming $\\mathbb{P}_{1}$ finite element space, whose degrees of freedom are edge-midpoint values. Impose the homogeneous Dirichlet boundary condition by setting the degrees of freedom on boundary edges to zero.\n\nStarting from the weak form with bilinear form $a(u,v) = \\int_{\\Omega} \\nabla u \\cdot \\nabla v \\, dx$, and using only the following foundational facts:\n- On each triangle $T$, any CR basis function associated with an edge $e$ is affine on $T$ and is uniquely determined by its values at the midpoints of the three edges of $T$.\n- The barycentric coordinates $\\lambda_{i}$ on a triangle are affine, satisfy $\\lambda_{i}(v_{i}) = 1$ and $\\lambda_{i}(v_{j})=0$ for $j \\neq i$, and $\\lambda_{1} + \\lambda_{2} + \\lambda_{3} = 1$.\n- The gradient of an affine function is constant on a triangle, so integrals of gradient products reduce to constant dot products times the triangle’s area.\n\nTask:\n1. On a single triangle $T$ with vertices $(x_{1},y_{1})$, $(x_{2},y_{2})$, $(x_{3},y_{3})$, label edges $e_{i}$ as the edge opposite vertex $i$ and define the local CR basis functions $\\psi_{i}^{T}$ by the conditions $\\psi_{i}^{T}(m_{e_{i}}) = 1$ and $\\psi_{i}^{T}(m_{e_{j}}) = 0$ for $j \\neq i$, where $m_{e}$ denotes the midpoint of edge $e$. Derive the explicit form of $\\psi_{i}^{T}$ in terms of the barycentric coordinates $\\lambda_{i}$, and then derive the explicit formula for the local stiffness matrix entries\n$$\nK^{\\mathrm{CR}}_{T}(i,j) \\;=\\; \\int_{T} \\nabla \\psi_{i}^{T} \\cdot \\nabla \\psi_{j}^{T} \\, dx,\n$$\nexpressed in terms of gradients of barycentric coordinates and the area of $T$.\n\n2. For the specific mesh $\\mathcal{T}_{h} = \\{T_{1}, T_{2}\\}$ defined above, compute the full $3 \\times 3$ local stiffness matrices $K^{\\mathrm{CR}}_{T_{1}}$ and $K^{\\mathrm{CR}}_{T_{2}}$ using the explicit gradients of the barycentric coordinates on each triangle.\n\n3. Assemble the global CR stiffness matrix using edge-based degrees of freedom, with boundary edge degrees of freedom fixed to zero. Identify the single interior edge (the diagonal $(0,0)$–$(1,1)$), denote its global basis function by $\\Phi$, and assemble the scalar global stiffness entry\n$$\nA \\;=\\; \\int_{\\Omega} \\nabla \\Phi \\cdot \\nabla \\Phi \\, dx,\n$$\nas the sum of the appropriate local contributions from $T_{1}$ and $T_{2}$.\n\nProvide the final value of $A$ as a single exact number. No rounding is required.", "solution": "The user has provided a problem to be solved in the context of the Crouzeix-Raviart (CR) nonconforming finite element method.\n\n### Step 1: Extract Givens\n- **Problem**: $-\\Delta u = f$ on the domain $\\Omega = [0,1]^{2}$.\n- **Boundary Conditions**: Homogeneous Dirichlet, $u=0$ on $\\partial\\Omega$.\n- **Triangulation**: $\\mathcal{T}_{h}$ consists of two triangles, $T_{1}$ and $T_{2}$.\n- **Triangle $T_{1}$**: Vertices $v_{1} = (0,0)$, $v_{2} = (1,0)$, $v_{3} = (1,1)$.\n- **Triangle $T_{2}$**: Vertices $w_{1} = (0,0)$, $w_{2} = (1,1)$, $w_{3} = (0,1)$.\n- **Finite Element Space**: Crouzeix-Raviart nonconforming $\\mathbb{P}_{1}$ space.\n- **Degrees of Freedom**: Values at edge midpoints.\n- **BC Implementation**: Degrees of freedom on boundary edges are set to zero.\n- **Bilinear Form**: $a(u,v) = \\int_{\\Omega} \\nabla u \\cdot \\nabla v \\, dx$.\n- **Foundational Fact 1**: On a triangle $T$, any CR basis function associated with an edge $e$ is affine on $T$ and uniquely determined by its values at the midpoints of the three edges of $T$.\n- **Foundational Fact 2**: Barycentric coordinates $\\lambda_{i}$ on a triangle are affine, satisfy $\\lambda_{i}(v_{i}) = 1$ and $\\lambda_{i}(v_{j})=0$ for $j \\neq i$, and $\\sum_{i=1}^3 \\lambda_{i} = 1$.\n- **Foundational Fact 3**: The gradient of an affine function is constant on a triangle.\n- **Task 1**: Derive the explicit form of the local CR basis function $\\psi_{i}^{T}$ in terms of barycentric coordinates and the formula for local stiffness matrix entries $K^{\\mathrm{CR}}_{T}(i,j) = \\int_{T} \\nabla \\psi_{i}^{T} \\cdot \\nabla \\psi_{j}^{T} \\, dx$.\n- **Task 2**: Compute the $3 \\times 3$ local stiffness matrices $K^{\\mathrm{CR}}_{T_{1}}$ and $K^{\\mathrm{CR}}_{T_{2}}$.\n- **Task 3**: Assemble the scalar global stiffness entry $A = \\int_{\\Omega} |\\nabla\\Phi|^2 \\, dx$ for the single interior edge basis function $\\Phi$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is scientifically and mathematically sound. It describes a standard application of the finite element method, a core topic in numerical analysis for partial differential equations. The concepts used—the Poisson equation, weak formulation, Crouzeix-Raviart elements, barycentric coordinates, and stiffness matrix assembly—are all well-established and rigorously defined. The problem is self-contained, with all necessary information provided. The tasks are structured logically, guiding the solver from local element derivations to global assembly. The problem is objective and free of any ambiguities or contradictions.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. A complete, reasoned solution will be provided below.\n\n### Solution\n\n#### Part 1: Derivation of local basis functions and stiffness matrix formula\n\nLet $T$ be a triangle with vertices $v_1, v_2, v_3$. Let $\\lambda_1, \\lambda_2, \\lambda_3$ be the corresponding barycentric coordinates. The edges are denoted $e_i$ for the edge opposite vertex $v_i$, and the midpoint of $e_i$ is $m_{e_i}$. The CR basis function $\\psi_i^T$ is an affine function on $T$ defined by the conditions $\\psi_i^T(m_{e_i}) = 1$ and $\\psi_i^T(m_{e_j}) = 0$ for $j \\neq i$.\n\nThe value of a barycentric coordinate $\\lambda_k$ at the midpoint of an edge, for example $m_{e_1} = (v_2+v_3)/2$, is given by $\\lambda_k(m_{e_1}) = \\frac{1}{2}(\\lambda_k(v_2) + \\lambda_k(v_3))$. Using the property $\\lambda_k(v_j) = \\delta_{kj}$, we find the values of the barycentric coordinates at the three edge midpoints:\n- At $m_{e_1}$: $\\lambda_1(m_{e_1}) = 0$, $\\lambda_2(m_{e_1}) = \\frac{1}{2}$, $\\lambda_3(m_{e_1}) = \\frac{1}{2}$.\n- At $m_{e_2}$: $\\lambda_1(m_{e_2}) = \\frac{1}{2}$, $\\lambda_2(m_{e_2}) = 0$, $\\lambda_3(m_{e_2}) = \\frac{1}{2}$.\n- At $m_{e_3}$: $\\lambda_1(m_{e_3}) = \\frac{1}{2}$, $\\lambda_2(m_{e_3}) = \\frac{1}{2}$, $\\lambda_3(m_{e_3}) = 0$.\n\nWe seek an affine function $\\psi_i^T$ expressed in terms of the affine functions $\\lambda_j$. Let us test the candidate function $1 - 2\\lambda_i$. For $i=1$, the function is $1 - 2\\lambda_1$. Let's evaluate it at the midpoints:\n- at $m_{e_1}$: $1 - 2\\lambda_1(m_{e_1}) = 1 - 2(0) = 1$.\n- at $m_{e_2}$: $1 - 2\\lambda_1(m_{e_2}) = 1 - 2(\\frac{1}{2}) = 0$.\n- at $m_{e_3}$: $1 - 2\\lambda_1(m_{e_3}) = 1 - 2(\\frac{1}{2}) = 0$.\nThese values match the definition of $\\psi_1^T$. Since an affine function on a triangle is uniquely determined by its values at three non-collinear points (such as the edge midpoints), this is the correct form. By symmetry, the local basis function for edge $e_i$ is $\\psi_i^T = 1 - 2\\lambda_i$.\n\nNext, we derive the formula for the local stiffness matrix entries $K^{\\mathrm{CR}}_{T}(i,j) = \\int_{T} \\nabla \\psi_{i}^{T} \\cdot \\nabla \\psi_{j}^{T} \\, dx$.\nTaking the gradient of the basis function gives $\\nabla \\psi_i^T = \\nabla(1 - 2\\lambda_i) = -2 \\nabla \\lambda_i$. Since $\\lambda_i$ is an affine function, its gradient $\\nabla\\lambda_i$ is a constant vector on $T$. The integrand is therefore also constant on $T$:\n$$ \\nabla \\psi_{i}^{T} \\cdot \\nabla \\psi_{j}^{T} = (-2 \\nabla \\lambda_i) \\cdot (-2 \\nabla \\lambda_j) = 4 (\\nabla \\lambda_i \\cdot \\nabla \\lambda_j) $$\nThe integral of a constant over the area of the triangle is the constant times the area, $|T|$.\n$$ K^{\\mathrm{CR}}_{T}(i,j) = \\int_{T} 4 (\\nabla \\lambda_i \\cdot \\nabla \\lambda_j) \\, dx = 4 |T| (\\nabla \\lambda_i \\cdot \\nabla \\lambda_j) $$\n\n#### Part 2: Computation of local stiffness matrices for $T_1$ and $T_2$\n\nFor a triangle with vertices $(x_1, y_1), (x_2, y_2), (x_3, y_3)$, the area is $|T| = \\frac{1}{2} |x_1(y_2-y_3) + x_2(y_3-y_1) + x_3(y_1-y_2)|$ and the gradients of barycentric coordinates are given by:\n$$ \\nabla \\lambda_1 = \\frac{1}{2|T|} \\begin{pmatrix} y_2 - y_3 \\\\ x_3 - x_2 \\end{pmatrix}, \\quad \\nabla \\lambda_2 = \\frac{1}{2|T|} \\begin{pmatrix} y_3 - y_1 \\\\ x_1 - x_3 \\end{pmatrix}, \\quad \\nabla \\lambda_3 = \\frac{1}{2|T|} \\begin{pmatrix} y_1 - y_2 \\\\ x_2 - x_1 \\end{pmatrix} $$\nFor triangle $T_1$ with vertices $v_1=(0,0)$, $v_2=(1,0)$, $v_3=(1,1)$:\nThe area is $|T_1| = \\frac{1}{2} |0(0-1) + 1(1-0) + 1(0-0)| = \\frac{1}{2}$. Thus, $2|T_1| = 1$.\nThe gradients are:\n$$ \\nabla \\lambda_1^{T_1} = \\begin{pmatrix} 0-1 \\\\ 1-1 \\end{pmatrix} = \\begin{pmatrix} -1 \\\\ 0 \\end{pmatrix}, \\quad \\nabla \\lambda_2^{T_1} = \\begin{pmatrix} 1-0 \\\\ 0-1 \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ -1 \\end{pmatrix}, \\quad \\nabla \\lambda_3^{T_1} = \\begin{pmatrix} 0-0 \\\\ 1-0 \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix} $$\nThe matrix of dot products $(\\nabla \\lambda_i^{T_1} \\cdot \\nabla \\lambda_j^{T_1})$ is:\n$$ \\begin{pmatrix} 1 & -1 & 0 \\\\ -1 & 2 & -1 \\\\ 0 & -1 & 1 \\end{pmatrix} $$\nThe local stiffness matrix is $K_{T_1}^{\\mathrm{CR}}(i,j) = 4 |T_1| (\\nabla \\lambda_i^{T_1} \\cdot \\nabla \\lambda_j^{T_1}) = 2 (\\nabla \\lambda_i^{T_1} \\cdot \\nabla \\lambda_j^{T_1})$:\n$$ K^{\\mathrm{CR}}_{T_1} = 2 \\begin{pmatrix} 1 & -1 & 0 \\\\ -1 & 2 & -1 \\\\ 0 & -1 & 1 \\end{pmatrix} = \\begin{pmatrix} 2 & -2 & 0 \\\\ -2 & 4 & -2 \\\\ 0 & -2 & 2 \\end{pmatrix} $$\nFor triangle $T_2$ with vertices $w_1=(0,0)$, $w_2=(1,1)$, $w_3=(0,1)$, we let $v_1=w_1, v_2=w_2, v_3=w_3$.\nThe area is $|T_2| = \\frac{1}{2} |0(1-1) + 1(1-0) + 0(0-1)| = \\frac{1}{2}$. Thus, $2|T_2| = 1$.\nThe gradients are:\n$$ \\nabla \\lambda_1^{T_2} = \\begin{pmatrix} 1-1 \\\\ 0-1 \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ -1 \\end{pmatrix}, \\quad \\nabla \\lambda_2^{T_2} = \\begin{pmatrix} 1-0 \\\\ 0-0 \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix}, \\quad \\nabla \\lambda_3^{T_2} = \\begin{pmatrix} 0-1 \\\\ 1-0 \\end{pmatrix} = \\begin{pmatrix} -1 \\\\ 1 \\end{pmatrix} $$\nThe matrix of dot products $(\\nabla \\lambda_i^{T_2} \\cdot \\nabla \\lambda_j^{T_2})$ is:\n$$ \\begin{pmatrix} 1 & 0 & -1 \\\\ 0 & 1 & -1 \\\\ -1 & -1 & 2 \\end{pmatrix} $$\nThe local stiffness matrix is $K_{T_2}^{\\mathrm{CR}}(i,j) = 4 |T_2| (\\nabla \\lambda_i^{T_2} \\cdot \\nabla \\lambda_j^{T_2}) = 2 (\\nabla \\lambda_i^{T_2} \\cdot \\nabla \\lambda_j^{T_2})$:\n$$ K^{\\mathrm{CR}}_{T_2} = 2 \\begin{pmatrix} 1 & 0 & -1 \\\\ 0 & 1 & -1 \\\\ -1 & -1 & 2 \\end{pmatrix} = \\begin{pmatrix} 2 & 0 & -2 \\\\ 0 & 2 & -2 \\\\ -2 & -2 & 4 \\end{pmatrix} $$\n\n#### Part 3: Assembly of the global stiffness entry\n\nThe mesh has one interior edge, the diagonal from $(0,0)$ to $(1,1)$. Due to the homogeneous Dirichlet boundary conditions, the only active degree of freedom corresponds to this interior edge. Let $\\Phi$ be the global basis function for this degree of freedom. The global stiffness entry is $A = a(\\Phi, \\Phi) = \\int_{\\Omega} |\\nabla\\Phi|^2 \\, dx$. This is the sum of contributions from $T_1$ and $T_2$:\n$$ A = \\int_{T_1} |\\nabla\\Phi|^2 \\, dx + \\int_{T_2} |\\nabla\\Phi|^2 \\, dx $$\nOn $T_1$ with vertices $v_1(0,0), v_2(1,0), v_3(1,1)$, the interior edge from $(0,0)$ to $(1,1)$ is the edge opposite to vertex $v_2$. Thus, the restriction of $\\Phi$ to $T_1$ is the local basis function $\\psi_2^{T_1}$. The contribution from $T_1$ is $\\int_{T_1} |\\nabla\\psi_2^{T_1}|^2 \\, dx = K^{\\mathrm{CR}}_{T_1}(2,2)$.\n\nOn $T_2$ with vertices $w_1(0,0), w_2(1,1), w_3(0,1)$, the interior edge from $(0,0)$ to $(1,1)$ is the edge connecting $w_1$ and $w_2$. This is the edge opposite to vertex $w_3$. Using our calculation mapping $v_1=w_1, v_2=w_2, v_3=w_3$, this corresponds to the edge opposite $v_3$. Therefore, the restriction of $\\Phi$ to $T_2$ is the local basis function $\\psi_3^{T_2}$. The contribution from $T_2$ is $\\int_{T_2} |\\nabla\\psi_3^{T_2}|^2 \\, dx = K^{\\mathrm{CR}}_{T_2}(3,3)$.\n\nThe global stiffness entry is the sum of these local diagonal entries:\n$$ A = K^{\\mathrm{CR}}_{T_1}(2,2) + K^{\\mathrm{CR}}_{T_2}(3,3) $$\nUsing the matrices computed in Part 2:\n$$ K^{\\mathrm{CR}}_{T_1}(2,2) = 4 $$\n$$ K^{\\mathrm{CR}}_{T_2}(3,3) = 4 $$\nTherefore, the final value is:\n$$ A = 4 + 4 = 8 $$", "answer": "$$\\boxed{8}$$", "id": "3376155"}, {"introduction": "Moving from manual calculations to a scalable computer implementation requires robust algorithms for managing mesh data. For nonconforming methods, consistent handling of edge orientations is paramount for the correct assembly of jump terms and boundary integrals. This coding practice challenges you to design and validate an algorithm for global edge numbering and orientation, a critical and practical skill for developing reliable finite element software [@problem_id:3376195].", "problem": "Consider the numerical solution of Partial Differential Equations (PDE) using the Crouzeix-Raviart nonconforming finite element, which has degrees of freedom located at the midpoints of mesh edges. In nonconforming assembly, edge-based integrals and jump terms must be assembled with a consistent orientation so that interior-edge contributions cancel appropriately between adjacent elements. Design and implement an algorithm for global edge numbering and orientation that ensures consistent assembly of edge integrals and jump terms across the mesh, and validate it with mathematically principled tests.\n\nStarting point and fundamental base:\n- Use the definition of a triangulation of a polygonal domain: a set of vertices with coordinates in the plane, and a set of triangular elements specified by vertex indices.\n- Use the notion of element orientation: for a triangle with vertices ordered counterclockwise, the oriented edge list is the ordered sequence of pairs along its boundary.\n- Use the Divergence Theorem: for any sufficiently smooth vector field, the integral of its divergence over an element equals the integral of its normal component over the element boundary. In particular, for a constant vector field with zero divergence, the integral of the outward unit normal over the boundary of any element is zero.\n- Use the definition of jump across an interior edge: if an interior edge is shared by two elements, the jump of a scalar quantity across that edge is the difference of traces from the two sides, where the minus and plus sides are defined by a consistent ordering convention.\n\nAlgorithm requirements:\n1. Construct a globally unique edge list by aggregating all local element edges. For each edge, assign a canonical global orientation from the lower vertex index to the higher vertex index.\n2. For each element, ensure counterclockwise orientation. Define its local oriented edge list along its boundary order.\n3. For each local edge in an element, compute its unit tangent and outward unit normal using the local edge direction. For a counterclockwise-oriented triangle, define the outward unit normal of a local oriented edge with tangent vector $\\boldsymbol{t}$ as the rotation of $\\boldsymbol{t}/\\|\\boldsymbol{t}\\|$ by $-90^\\circ$ (i.e., $\\begin{pmatrix}t_y \\\\ -t_x\\end{pmatrix}$).\n4. For each global edge, store its incident elements along with their local edge directions, and verify that the local edge direction used by the two incident elements is opposite with respect to the canonical global orientation.\n\nValidation tasks derived from first principles:\n- Interior-edge orientation consistency: for any interior edge shared by two elements, the two element-local directions along that shared edge must be opposite relative to the canonical global orientation. This enforces the correct sign for jump terms and ensures cancellation in symmetric edge integrals upon assembly.\n- Element boundary normal balance: for any element, the vector sum of its outward normals multiplied by edge lengths along all its boundary edges must equal the zero vector. This follows from the Divergence Theorem applied to the constant vector field and the geometric closure of the oriented boundary polygon.\n- Interior-edge cancellation for constant flux: for a constant vector field $\\boldsymbol{q}$ with zero divergence, the assembled sum of $\\boldsymbol{q}\\cdot\\boldsymbol{n}$ times edge length over all interior edges, counting both incident elements’ outward normals, must be zero.\n\nMesh generation with curved boundary:\n- Generate a star-shaped triangulation by placing $n$ boundary vertices at angles $\\theta_k$ and radii $r(\\theta_k)$, and connecting each consecutive pair of boundary vertices with the center to form triangles. This constructs a mesh whose boundary lies on a given curve $r(\\theta)$, thereby creating a curved domain boundary in the sense of boundary geometry.\n\nEdge jump convention for Crouzeix-Raviart nonconforming elements:\n- For an interior edge $e$ with incident elements $K^{-}$ and $K^{+}$ chosen by a fixed rule (e.g., element index order), define the jump of a scalar quantity $u$ as $[u]_e = u^{-} - u^{+}$. The chosen orientation must be consistent across the mesh so that the assembly of edge-based bilinear forms respects the required symmetry and cancellation properties.\n\nYour program must implement the preceding algorithm and run the following test suite of meshes and checks. The numerical tolerance for vector equalities must be set to $10^{-10}$ in Euclidean norm.\n\nTest suite:\n- Mesh $\\mathcal{M}_1$: circular boundary with $n=16$ equally spaced angles, $r(\\theta) = 1$, triangles formed by a fan from the center.\n  - Check A: interior-edge orientation consistency.\n  - Check B: element boundary normal balance.\n  - Check C: interior-edge cancellation for constant flux $\\boldsymbol{q} = (1,0)$.\n- Mesh $\\mathcal{M}_2$: sinusoidally perturbed circular boundary with $n=24$ equally spaced angles, $r(\\theta) = 1 + 0.25\\cos(5\\theta)$, triangles formed by a fan from the center.\n  - Check A: interior-edge orientation consistency.\n  - Check B: element boundary normal balance.\n  - Check C: interior-edge cancellation for constant flux $\\boldsymbol{q} = (0,1)$.\n- Mesh $\\mathcal{M}_3$: nearly degenerate circular boundary with $n=20$ angles, modified so that two consecutive angles are separated by a small increment $0.01$ radians, $r(\\theta) = 1$, triangles formed by a fan from the center.\n  - Check A: interior-edge orientation consistency.\n  - Check B: element boundary normal balance.\n  - Check C: interior-edge cancellation for constant flux $\\boldsymbol{q} = \\left(1/\\sqrt{2}, 1/\\sqrt{2}\\right)$.\n\nRequired final output format:\n- Your program should produce a single line of output containing the results of the checks for the three meshes ordered as $[\\text{A}_1,\\text{B}_1,\\text{C}_1,\\text{A}_2,\\text{B}_2,\\text{C}_2,\\text{A}_3,\\text{B}_3,\\text{C}_3]$ as a comma-separated list of boolean values enclosed in square brackets (e.g., $[True,False,True,True,True,False,True,True,True]$).", "solution": "The user has provided a well-defined problem in the domain of numerical methods for Partial Differential Equations (PDEs), specifically concerning the implementation of nonconforming finite elements. The task is to design, implement, and validate an algorithm for establishing a consistent global edge orientation and numbering scheme for a 2D triangular mesh. This is a standard and critical step in finite element software, particularly for methods like the Crouzeix-Raviart element, where degrees of freedom and integrals are associated with mesh edges.\n\n### Problem Validation\nThe problem statement has been rigorously validated and is determined to be valid.\n- **Scientific Grounding**: The problem is based on established principles of the Finite Element Method (FEM), computational geometry, and vector calculus (specifically, the Divergence Theorem). The concepts of nonconforming elements, jump terms, and the necessity of consistent edge orientations are fundamental to this field.\n- **Well-Posedness**: The problem is self-contained. It provides clear definitions for the mesh, element orientation, global edge orientation, and the required validation checks. The test cases are specified with sufficient detail to allow for a unique and verifiable implementation.\n- **Objectivity**: The problem is stated in precise, objective, and formal mathematical language, devoid of any subjectivity or ambiguity.\n\nAll validation criteria are met. The problem is sound and can be solved as stated.\n\n### Algorithmic Design and Principles\n\nThe solution is structured around a series of functions that construct the mesh, establish the geometric and topological data structures, and perform the required validation checks based on first principles.\n\n1.  **Mesh Generation**: A function `generate_mesh($n$, $r(\\theta)$, angle_mod)` is designed to create a star-shaped triangulation.\n    - It places a central vertex at the origin $(0,0)$, which is assigned index $0$.\n    - It generates $n$ boundary vertices, indexed $1$ to $n$, based on a given radius function $r(\\theta)$ and a set of angles $\\theta_k$. For tests $\\mathcal{M}_1$ and $\\mathcal{M}_2$, angles are equally spaced. For test $\\mathcal{M}_3$, the angles are modified to create a nearly degenerate element, testing the algorithm's robustness.\n    - Triangles are formed by connecting the central vertex to consecutive pairs of boundary vertices, i.e., $(0, v_k, v_{k+1})$, ensuring a valid triangulation of the domain.\n\n2.  **Element Orientation and Local Edge Data**:\n    - For each triangular element, its vertices are ordered to ensure a consistent counter-clockwise (CCW) orientation. This is verified by checking the sign of the triangle's area, computed via the shoelace formula: $A = \\frac{1}{2} \\sum_{i=1}^{3} (x_i y_{i+1} - x_{i+1} y_i)$. A positive area corresponds to CCW orientation. Our mesh generation naturally produces CCW elements, but this explicit check guarantees correctness for any input triangulation.\n    - For each element, we traverse its boundary edges in CCW order. For an edge from vertex $\\boldsymbol{p}_1$ to $\\boldsymbol{p}_2$, the tangent vector is $\\boldsymbol{t} = \\boldsymbol{p}_2 - \\boldsymbol{p}_1$.\n    - The outward unit normal $\\boldsymbol{n}$ is obtained by rotating the unit tangent vector $\\hat{\\boldsymbol{t}} = \\boldsymbol{t}/\\|\\boldsymbol{t}\\|$ by $-90^\\circ$. If $\\hat{\\boldsymbol{t}} = (\\hat{t}_x, \\hat{t}_y)$, then $\\boldsymbol{n} = (\\hat{t}_y, -\\hat{t}_x)$.\n\n3.  **Global Edge Data Structure**:\n    - A global dictionary of edges is constructed. Each edge is uniquely identified by a canonical key: a tuple containing the sorted indices of its two vertices, e.g., $(\\min(v_i, v_j), \\max(v_i, v_j))$.\n    - For each edge, we store a list of incident elements and, for each incident element, the corresponding local orientation information. This includes:\n        - The local direction relative to the canonical global orientation, represented by a sign: $+1$ if the element's CCW traversal follows the canonical direction (from lower to higher vertex index), and $-1$ otherwise.\n        - The calculated outward unit normal vector.\n        - The length of the edge.\n\n### Validation Checks\n\nThe correctness of the implementation is verified through three mathematically-principled tests:\n\n**A. Interior-Edge Orientation Consistency:** This check ensures that for any interior edge shared by two elements, their local traversal directions are opposite. In our data structure, this means the sum of their 'local direction' signs must be $-1 + 1 = 0$. This is the fundamental requirement for the cancellation of symmetric interior edge integrals and the consistent definition of jump terms ($\\lbrack u \\rbrack_e = u^{-} - u^{+}$) in FEM assembly.\n\n**B. Element Boundary Normal Balance:** This check is a direct consequence of the Divergence Theorem. For any constant vector field $\\boldsymbol{c}$, its divergence is zero. The theorem states $\\int_K \\nabla \\cdot \\boldsymbol{c} \\, d\\boldsymbol{x} = \\int_{\\partial K} \\boldsymbol{c} \\cdot \\boldsymbol{n} \\, ds$. With $\\nabla \\cdot \\boldsymbol{c} = 0$, we have $\\int_{\\partial K} \\boldsymbol{c} \\cdot \\boldsymbol{n} \\, ds = \\boldsymbol{c} \\cdot \\int_{\\partial K} \\boldsymbol{n} \\, ds = 0$. Since this must hold for any constant vector $\\boldsymbol{c}$, it implies $\\int_{\\partial K} \\boldsymbol{n} \\, ds = \\boldsymbol{0}$. For a triangle, this integral is the sum of the outward normals weighted by edge lengths: $\\sum_{e \\in \\partial K} \\|\\boldsymbol{e}\\| \\boldsymbol{n}_e = \\boldsymbol{0}$. Numerically, we verify that the norm of this sum vector is below a small tolerance ($10^{-10}$) for every element.\n\n**C. Interior-Edge Cancellation for Constant Flux:** This check extends the principle of the Divergence Theorem to the entire mesh. For a constant vector field (flux) $\\boldsymbol{q}$, the sum of flux contributions over all interior edges must be zero. An interior edge $e$ is the boundary of two adjacent elements, $K_1$ and $K_2$. The assembly process would sum the terms $\\boldsymbol{q} \\cdot \\boldsymbol{n}_1 \\|\\boldsymbol{e}\\|$ and $\\boldsymbol{q} \\cdot \\boldsymbol{n}_2 \\|\\boldsymbol{e}\\|$, where $\\boldsymbol{n}_1$ and $\\boldsymbol{n}_2$ are the outward normals from $K_1$ and $K_2$ respectively. Consistent orientation ensures that $\\boldsymbol{n}_1 = -\\boldsymbol{n}_2$. Therefore, their sum is $\\boldsymbol{q} \\cdot (\\boldsymbol{n}_1 + \\boldsymbol{n}_2) \\|\\boldsymbol{e}\\| = \\boldsymbol{q} \\cdot \\boldsymbol{0} \\|\\boldsymbol{e}\\| = 0$. We verify that the sum of these contributions over all interior edges is numerically zero. This test confirms that the normals are correctly computed and oriented for inter-element assembly.\n\nThe implementation successfully passes all checks for the three specified test meshes, demonstrating the correctness and robustness of the algorithm.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and validates an algorithm for global edge numbering and orientation\n    for nonconforming finite element methods.\n    \"\"\"\n    # Numerical tolerance for vector equalities must be set to 10^-10 in Euclidean norm.\n    TOL = 1e-10\n\n    def generate_mesh(n, r_func, angle_mod=None):\n        \"\"\"\n        Generates a star-shaped triangulation of a polygonal domain.\n        The mesh consists of a central vertex (0,0) and n boundary vertices.\n\n        Args:\n            n (int): Number of boundary vertices.\n            r_func (callable): A function r(theta) that defines the boundary radius.\n            angle_mod (dict, optional): A dictionary specifying modifications to angles for test cases.\n\n        Returns:\n            tuple: A tuple containing:\n                - vertices (np.ndarray): Array of vertex coordinates, shape (n+1, 2).\n                - elements (np.ndarray): Array of element definitions, shape (n, 3).\n        \"\"\"\n        vertices = np.zeros((n + 1, 2))  # vertices[0] is center (0,0)\n\n        # Generate angles for boundary vertices\n        angles = np.linspace(0, 2 * np.pi, n, endpoint=False)\n        if angle_mod and angle_mod.get('type') == 'set_one':\n            # Modify an angle for the nearly degenerate case (Mesh M3)\n            angles[angle_mod['index']] = angle_mod['value']\n\n        radii = r_func(angles)\n        vertices[1:, 0] = radii * np.cos(angles)\n        vertices[1:, 1] = radii * np.sin(angles)\n\n        # Create triangular elements connecting the center to pairs of boundary vertices\n        elements = np.zeros((n, 3), dtype=int)\n        for i in range(n):\n            v1_idx = i + 1\n            v2_idx = (i + 1) % n + 1\n            elements[i] = [0, v1_idx, v2_idx]\n\n        return vertices, elements\n\n    def ensure_element_orientation(vertices, elements):\n        \"\"\"\n        Ensures all elements have counter-clockwise (CCW) orientation by reordering\n        vertices if necessary. The check is based on the sign of the triangle's area.\n        \"\"\"\n        oriented_elements = elements.copy()\n        for i, elem in enumerate(elements):\n            p0, p1, p2 = vertices[elem[0]], vertices[elem[1]], vertices[elem[2]]\n            # Shoelace formula for signed area multiplied by 2\n            area = p0[0] * (p1[1] - p2[1]) + p1[0] * (p2[1] - p0[1]) + p2[0] * (p0[1] - p1[1])\n            if area < 0:\n                # If area is negative, vertices are in clockwise order. Swap to fix.\n                oriented_elements[i, 1], oriented_elements[i, 2] = oriented_elements[i, 2], oriented_elements[i, 1]\n        return oriented_elements\n\n    def process_mesh(vertices, elements, q_flux):\n        \"\"\"\n        Implements the main algorithm to build the global edge data structure and\n        perform the three specified validation checks.\n        \"\"\"\n        # Requirement 2: Ensure all elements are CCW oriented\n        elements = ensure_element_orientation(vertices, elements)\n\n        # Requirements 1 & 4: Build global edge list and store local information\n        # The 'edges' dictionary maps a canonical edge key (min_idx, max_idx) to its data.\n        edges = {}\n\n        for i, elem in enumerate(elements):\n            v_indices = list(elem)\n            # Iterate over local edges in CCW order\n            for j in range(3):\n                v_start_idx, v_end_idx = v_indices[j], v_indices[(j + 1) % 3]\n\n                # Canonical global edge representation\n                edge_key = tuple(sorted((v_start_idx, v_end_idx)))\n\n                # Requirement 3: Compute local tangent, normal, and length\n                v_start_coords, v_end_coords = vertices[v_start_idx], vertices[v_end_idx]\n                edge_vec = v_end_coords - v_start_coords\n                edge_length = np.linalg.norm(edge_vec)\n\n                if edge_length < TOL:\n                    unit_tangent = np.array([0.0, 0.0])\n                    outward_normal = np.array([0.0, 0.0])\n                else:\n                    unit_tangent = edge_vec / edge_length\n                    # Outward normal for CCW element is tangent rotated by -90 degrees\n                    outward_normal = np.array([unit_tangent[1], -unit_tangent[0]])\n                \n                # Local direction sign w.r.t. global canonical edge orientation\n                local_direction_sign = 1 if v_start_idx < v_end_idx else -1\n\n                if edge_key not in edges:\n                    edges[edge_key] = {'local_info': []}\n                \n                edges[edge_key]['local_info'].append({\n                    'element_idx': i,\n                    'sign': local_direction_sign,\n                    'normal': outward_normal,\n                    'length': edge_length\n                })\n\n        # --- VALIDATION CHECKS ---\n        interior_edges = [k for k, v in edges.items() if len(v['local_info']) == 2]\n\n        # Check A: Interior-edge orientation consistency\n        check_A_passed = True\n        for edge_key in interior_edges:\n            info = edges[edge_key]['local_info']\n            if info[0]['sign'] + info[1]['sign'] != 0:\n                check_A_passed = False\n                break\n\n        # Check B: Element boundary normal balance\n        check_B_passed = True\n        for i, elem in enumerate(elements):\n            sum_normal_len = np.zeros(2)\n            v_indices = list(elem)\n            for j in range(3):\n                v_start_coords = vertices[v_indices[j]]\n                v_end_coords = vertices[v_indices[(j + 1) % 3]]\n                edge_vec = v_end_coords - v_start_coords\n                # Normal vector scaled by length is the rotated edge vector\n                sum_normal_len += np.array([edge_vec[1], -edge_vec[0]])\n\n            if np.linalg.norm(sum_normal_len) > TOL:\n                check_B_passed = False\n                break\n        \n        # Check C: Interior-edge cancellation for constant flux\n        total_flux_sum = 0.0\n        for edge_key in interior_edges:\n            info1, info2 = edges[edge_key]['local_info']\n            length = info1['length'] # Length is the same from both element views\n            n1, n2 = info1['normal'], info2['normal']\n            # Based on Divergence Theorem, summed flux over an interior edge should be zero\n            flux_contribution = (np.dot(q_flux, n1) + np.dot(q_flux, n2)) * length\n            total_flux_sum += flux_contribution\n        \n        check_C_passed = abs(total_flux_sum) < TOL\n\n        return check_A_passed, check_B_passed, check_C_passed\n\n    # --- DEFINE AND RUN TEST SUITE ---\n    test_cases = [\n        { # Mesh M1: Circular boundary\n            \"n\": 16,\n            \"r_func\": lambda theta: np.full_like(theta, 1.0),\n            \"angle_mod\": None,\n            \"q\": np.array([1.0, 0.0])\n        },\n        { # Mesh M2: Perturbed circular boundary\n            \"n\": 24,\n            \"r_func\": lambda theta: 1.0 + 0.25 * np.cos(5.0 * theta),\n            \"angle_mod\": None,\n            \"q\": np.array([0.0, 1.0])\n        },\n        { # Mesh M3: Nearly degenerate circular boundary\n            \"n\": 20,\n            \"r_func\": lambda theta: np.full_like(theta, 1.0),\n            \"angle_mod\": {'type': 'set_one', 'index': 1, 'value': 0.01},\n            \"q\": np.array([1.0/np.sqrt(2.0), 1.0/np.sqrt(2.0)])\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        vertices, elements = generate_mesh(case[\"n\"], case[\"r_func\"], case[\"angle_mod\"])\n        a, b, c = process_mesh(vertices, elements, case[\"q\"])\n        results.extend([a, b, c])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3376195"}]}