{"hands_on_practices": [{"introduction": "This exercise provides fundamental practice in translating the abstract Symmetric Interior Penalty Galerkin (SIPG) bilinear form into concrete matrix entries for a one-dimensional diffusion problem. By explicitly deriving the local element and face matrices for piecewise linear elements, you will gain a deep understanding of how each term—volume integral, consistency, and penalty—contributes to the final discrete system. The subsequent Fourier analysis [@problem_id:3410379] is a powerful technique for studying the stability and properties of the resulting stencil.", "problem": "Consider the one-dimensional diffusion problem $-\\frac{d}{dx}\\left(\\kappa \\frac{du}{dx}\\right)=f$ with constant diffusivity $\\kappa>0$ on the periodic domain $[0,1]$. Let the domain be partitioned into a uniform mesh of $N$ elements, each of length $h=\\frac{1}{N}$. Use a Discontinuous Galerkin (DG) discretization with piecewise linear polynomials (polynomial degree $p=1$) and the Symmetric Interior Penalty Galerkin (SIPG) method. Denote by $\\eta>0$ the nondimensional penalty parameter, and let the face-wise penalty be scaled as $\\tau=\\eta \\frac{\\kappa}{h}$.\n\nWork in the elementwise nodal basis on each element $K_e=[x_e,x_{e+1}]$, with local basis functions $\\phi_{1}(x)=1-\\frac{x-x_e}{h}$ and $\\phi_{2}(x)=\\frac{x-x_e}{h}$. Adopt the standard DG definitions for interior faces: for a face shared by a left element $K^{-}$ and a right element $K^{+}$, take outward normals $n^{-}=+1$ and $n^{+}=-1$, the jump $[w]=w^{-}n^{-}+w^{+}n^{+}=w^{-}-w^{+}$, and the average $\\{q\\}=\\frac{1}{2}(q^{-}+q^{+})$.\n\nUsing only the fundamental definition of the SIPG bilinear form,\n\n$$\na(u,v)=\\sum_{K}\\int_{K}\\kappa\\,u'(x)\\,v'(x)\\,dx-\\sum_{F}\\left(\\{\\kappa u'\\},[v]\\right)_{F}-\\sum_{F}\\left(\\{\\kappa v'\\},[u]\\right)_{F}+\\sum_{F}\\left(\\tau\\,[u],[v]\\right)_{F},\n$$\n\nderive the following:\n\n1. The explicit $2\\times 2$ local element volume stiffness matrix $A^{\\mathrm{vol}}$ for any element in the basis $\\{\\phi_{1},\\phi_{2}\\}$.\n\n2. The explicit $4\\times 4$ interior-face contribution matrix $A^{\\mathrm{face}}$ that couples the two neighboring elements across a single interior face, written in $2\\times 2$ block form\n\n$$\nA^{\\mathrm{face}}=\\begin{pmatrix}A^{LL} & A^{LR}\\\\ A^{RL} & A^{RR}\\end{pmatrix},\n$$\n\nwhere $A^{LL}$ and $A^{RR}$ are the on-element $2\\times 2$ blocks (left and right, respectively), and $A^{LR}$ and $A^{RL}$ are the $2\\times 2$ coupling blocks. Clearly identify how the penalty part enters these blocks.\n\n3. Under periodic boundary conditions, assemble the global block-circulant stiffness matrix and form its $2\\times 2$ block Fourier symbol $S(\\theta)$ associated with the discrete mode whose element-wise phase is $\\theta\\in[-\\pi,\\pi)$. Then compute the closed-form expression for the determinant $\\det S(\\theta)$ in terms of $\\kappa$, $\\eta$, $h$, and $\\theta$.\n\nProvide the final answer as the single analytic expression for $\\det S(\\theta)$. No rounding is required.", "solution": "We begin from the definition of the Symmetric Interior Penalty Galerkin (SIPG) bilinear form for the diffusion operator with constant $\\kappa$:\n\n$$\na(u,v)=\\sum_{K}\\int_{K}\\kappa\\,u'(x)\\,v'(x)\\,dx-\\sum_{F}\\left(\\{\\kappa u'\\},[v]\\right)_{F}-\\sum_{F}\\left(\\{\\kappa v'\\},[u]\\right)_{F}+\\sum_{F}\\left(\\tau\\,[u],[v]\\right)_{F},\n$$\n\nwhere for an interior face shared by left element $K^{-}$ and right element $K^{+}$, we use $n^{-}=+1$, $n^{+}=-1$, jump $[w]=w^{-}n^{-}+w^{+}n^{+}=w^{-}-w^{+}$, average $\\{q\\}=\\frac{1}{2}(q^{-}+q^{+})$, and face penalty $\\tau=\\eta \\frac{\\kappa}{h}$ with $\\eta>0$.\n\nWe take a uniform mesh with elements $K_e=[x_e,x_{e+1}]$ of length $h=\\frac{1}{N}$ and use the local linear nodal basis on each element,\n\n$$\n\\phi_{1}(x)=1-\\frac{x-x_e}{h},\\qquad \\phi_{2}(x)=\\frac{x-x_e}{h}.\n$$\n\nTheir derivatives on $K_e$ are constants:\n\n$$\n\\phi_{1}'(x)=-\\frac{1}{h},\\qquad \\phi_{2}'(x)=\\frac{1}{h}.\n$$\n\n\n1. Local element volume stiffness matrix. The element volume contribution is\n\n$$\nA^{\\mathrm{vol}}_{ij}=\\int_{K_e}\\kappa\\,\\phi_{i}'(x)\\,\\phi_{j}'(x)\\,dx=\\kappa\\left(\\frac{1}{h^2}\\right)\\int_{x_e}^{x_{e+1}}(\\pm 1)(\\pm 1)\\,dx=\\frac{\\kappa}{h}\\begin{pmatrix}1 & -1\\\\ -1 & 1\\end{pmatrix}_{ij}.\n$$\n\nThus,\n\n$$\nA^{\\mathrm{vol}}=\\frac{\\kappa}{h}\\begin{pmatrix}1 & -1\\\\ -1 & 1\\end{pmatrix}.\n$$\n\n\n2. Interior-face contribution matrix across a single face. Consider an interior face located at $x=x_i$ between a left element $K^{-}$ and a right element $K^{+}$. We construct the $4\\times 4$ face matrix in the basis $\\{\\phi_{1}^{-},\\phi_{2}^{-},\\phi_{1}^{+},\\phi_{2}^{+}\\}$, grouped into $2\\times 2$ blocks as\n\n$$\nA^{\\mathrm{face}}=\\begin{pmatrix}A^{LL} & A^{LR}\\\\ A^{RL} & A^{RR}\\end{pmatrix},\n$$\n\nwhere superscripts indicate left ($L$) or right ($R$) elements.\n\nWe require the traces at the face and the elementwise derivatives:\n\n$$\n\\phi_{1}^{-}(x_i)=0,\\quad \\phi_{2}^{-}(x_i)=1,\\quad \\phi_{1}^{+}(x_i)=1,\\quad \\phi_{2}^{+}(x_i)=0,\n$$\n\n\n$$\n(\\phi_{1}^{-})'=-\\frac{1}{h},\\quad (\\phi_{2}^{-})'=\\frac{1}{h},\\quad (\\phi_{1}^{+})'=-\\frac{1}{h},\\quad (\\phi_{2}^{+})'=\\frac{1}{h}.\n$$\n\nThe jump and average-derivative factors for each basis function are, for any test/trial function $w$ supported on only one element, its trace and derivative from the other element are zero. Hence, defining the jump vector and the average-derivative vector across the four basis functions,\n\n$$\nj=\\begin{pmatrix}[\\,\\phi_{1}^{-}\\,]\\\n$$\\,\\phi_{2}^{-}\\,]\\\n$$\\,\\phi_{1}^{+}\\,]\\\n$$\\,\\phi_{2}^{+}\\,]\\end{pmatrix}\n=\\begin{pmatrix}0\\\\ 1\\\\ -1\\\\ 0\\end{pmatrix},\\qquad\nm=\\begin{pmatrix}\\{\\kappa(\\phi_{1}^{-})'\\}\\\\ \\{\\kappa(\\phi_{2}^{-})'\\}\\\\ \\{\\kappa(\\phi_{1}^{+})'\\}\\\\ \\{\\kappa(\\phi_{2}^{+})'\\}\\end{pmatrix}\n=\\frac{\\kappa}{2h}\\begin{pmatrix}-1\\\\ 1\\\\ -1\\\\ 1\\end{pmatrix}.\n$$\n\nFor trial function $\\psi$ and test function $v$, the face bilinear form reads\n\n$$\na_{F}(\\psi,v)=-\\{\\kappa \\psi'\\}[v]-\\{\\kappa v'\\}[\\psi]+\\tau[\\psi][v].\n$$\n\nTherefore, the $4\\times 4$ face matrix can be compactly written as\n\n$$\nA^{\\mathrm{face}}=-\\,j\\,m^{\\top}-\\,m\\,j^{\\top}+\\tau\\,j\\,j^{\\top}.\n$$\n\nSetting $c=\\frac{\\kappa}{2h}$ and $\\tau=\\eta\\frac{\\kappa}{h}$, we obtain by direct multiplication the four $2\\times 2$ blocks:\n\n$$\nA^{LL}=\\begin{pmatrix}0 & c\\\\ c & -2c+\\tau\\end{pmatrix},\\quad\nA^{LR}=\\begin{pmatrix}-c & 0\\\\ 2c-\\tau & -c\\end{pmatrix},\n$$\n\n\n$$\nA^{RL}=\\begin{pmatrix}-c & 2c-\\tau\\\\ 0 & -c\\end{pmatrix},\\quad\nA^{RR}=\\begin{pmatrix}-2c+\\tau & c\\\\ c & 0\\end{pmatrix}.\n$$\n\nIn these expressions, the penalty part corresponds to the rank-one updates proportional to $\\tau\\,j\\,j^{\\top}$; explicitly, adding $\\tau$ only to the $(2,2)$ entry of $A^{LL}$, to the $(1,1)$ entry of $A^{RR}$, and subtracting $\\tau$ in the off-diagonal blocks at the $(2,1)$ entry of $A^{LR}$ and the $(1,2)$ entry of $A^{RL}$ (consistent with the outer product structure).\n\n3. Global assembly and Fourier symbol. Under periodic boundary conditions, each element contributes its volume matrix to the diagonal block, and each interior face between element $e$ (left) and $e+1$ (right) contributes $A^{LL}$ to block $(e,e)$, $A^{LR}$ to block $(e,e+1)$, $A^{RL}$ to block $(e+1,e)$, and $A^{RR}$ to block $(e+1,e+1)$. Each element has two neighboring faces (left and right), so the total diagonal block for element $e$ is\n\n$$\nK_{0}=A^{\\mathrm{vol}}+A^{LL}+A^{RR}.\n$$\n\nUsing $A^{\\mathrm{vol}}=\\frac{\\kappa}{h}\\begin{pmatrix}1 & -1\\\\ -1 & 1\\end{pmatrix}=2c\\begin{pmatrix}1 & -1\\\\ -1 & 1\\end{pmatrix}$ and the expressions for $A^{LL}$ and $A^{RR}$, we find\n\n$$\nK_{0}=2c\\begin{pmatrix}1 & -1\\\\ -1 & 1\\end{pmatrix}+\\begin{pmatrix}-2c+\\tau & 2c\\\\ 2c & -2c+\\tau\\end{pmatrix}=\\begin{pmatrix}\\tau & 0\\\\ 0 & \\tau\\end{pmatrix}.\n$$\n\nThe upper and lower off-diagonal blocks are, respectively,\n\n$$\nK_{+1}=A^{LR}=\\begin{pmatrix}-c & 0\\\\ 2c-\\tau & -c\\end{pmatrix},\\qquad\nK_{-1}=A^{RL}=\\begin{pmatrix}-c & 2c-\\tau\\\\ 0 & -c\\end{pmatrix}.\n$$\n\nThus, the $2\\times 2$ block Fourier symbol $S(\\theta)$ for mode with element-wise phase $\\theta$ is\n\n$$\nS(\\theta)=K_{0}+K_{+1}\\exp(i\\theta)+K_{-1}\\exp(-i\\theta)=\n\\begin{pmatrix}\n\\tau - c\\left(\\exp(i\\theta)+\\exp(-i\\theta)\\right) & (2c-\\tau)\\exp(-i\\theta)\\\\\n(2c-\\tau)\\exp(i\\theta) & \\tau - c\\left(\\exp(i\\theta)+\\exp(-i\\theta)\\right)\n\\end{pmatrix}.\n$$\n\nUsing $\\exp(i\\theta)+\\exp(-i\\theta)=2\\cos\\theta$, we rewrite\n\n$$\nS(\\theta)=\\begin{pmatrix}\n\\tau-2c\\cos\\theta & (2c-\\tau)\\exp(-i\\theta)\\\\\n(2c-\\tau)\\exp(i\\theta) & \\tau-2c\\cos\\theta\n\\end{pmatrix}.\n$$\n\nThe determinant of a $2\\times 2$ matrix with equal diagonal entries $a=\\tau-2c\\cos\\theta$ and off-diagonal entries $b=(2c-\\tau)\\exp(-i\\theta)$, $\\overline{b}=(2c-\\tau)\\exp(i\\theta)$ is\n\n$$\n\\det S(\\theta)=a^{2}-|b|^{2}=\\left(\\tau-2c\\cos\\theta\\right)^{2}-(2c-\\tau)^{2}.\n$$\n\nSubstituting $c=\\frac{\\kappa}{2h}$ and $\\tau=\\eta\\frac{\\kappa}{h}$ yields $2c=\\frac{\\kappa}{h}$ and\n\n$$\n\\det S(\\theta)=\\left(\\frac{\\kappa}{h}\\right)^{2}\\left[(\\eta-\\cos\\theta)^{2}-(1-\\eta)^{2}\\right].\n$$\n\nThis expression can be factored using the difference of squares:\n\n$$\n(\\eta-\\cos\\theta)^{2}-(1-\\eta)^{2}=\\left((\\eta-\\cos\\theta)-(1-\\eta)\\right)\\left((\\eta-\\cos\\theta)+(1-\\eta)\\right)\n=\\left(2\\eta-1-\\cos\\theta\\right)\\left(1-\\cos\\theta\\right).\n$$\n\nTherefore,\n\n$$\n\\det S(\\theta)=\\left(\\frac{\\kappa}{h}\\right)^{2}\\left(1-\\cos\\theta\\right)\\left(2\\eta-1-\\cos\\theta\\right).\n$$\n\nThis is the requested closed-form expression in terms of $\\kappa$, $\\eta$, $h$, and $\\theta$.", "answer": "$$\\boxed{\\left(\\frac{\\kappa}{h}\\right)^{2}\\left(1-\\cos\\theta\\right)\\left(2\\eta-1-\\cos\\theta\\right)}$$", "id": "3410379"}, {"introduction": "The stability of interior penalty methods hinges on the correct choice of the penalty parameter, which must be large enough to control discontinuities between elements. This problem [@problem_id:3410396] provides a concrete demonstration of this principle by analyzing an under-penalized scenario. By computing the discrete energy of a spurious oscillatory mode, you will see quantitatively how a small penalty parameter $\\sigma$ fails to suppress non-physical solutions, highlighting the crucial role of the penalty in ensuring a stable and meaningful approximation.", "problem": "Consider the scalar Poisson equation $-u'' = f$ posed on the one-dimensional domain $[0,1]$ with homogeneous Dirichlet boundary conditions $u(0) = 0$ and $u(1) = 0$. Let $\\mathcal{T}_h$ be a conforming partition of $[0,1]$ into two equal subintervals (elements) with nodes at $x=0$, $x=1/2$, and $x=1$, so the element size is $h = 1/2$. Let $V_h$ be the space of piecewise constant functions on $\\mathcal{T}_h$ that are allowed to be discontinuous across the interface $x=1/2$. Consider the Symmetric Interior Penalty Galerkin (SIPG) method, where the interior penalty parameter on each face $e$ is taken as $\\sigma/h$, with $\\sigma > 0$, and the Dirichlet boundary conditions are weakly enforced via Nitsche's method. Use the standard discontinuous Galerkin definitions of jumps and averages: at the interior interface $x=1/2$, the jump is $[u] = u^{-} - u^{+}$ and the average is $\\{u'\\} = (u'^{-} + u'^{+})/2$, where the superscripts denote traces from the left and right elements, respectively; at the boundary, the trace $u$ is taken from the adjacent element and the outward normal is used.\n\nConstruct the oscillatory discrete mode $u_h \\in V_h$ that takes the values $u_h(x) = 1$ on the left element $[0,1/2)$ and $u_h(x) = -1$ on the right element $(1/2,1]$. Starting from the fundamental bilinear form of the SIPG method for the Poisson operator and the Nitsche enforcement of homogeneous Dirichlet boundary conditions, derive the interior penalty energy $a(u_h,u_h)$—that is, the value of the SIPG bilinear form evaluated with $u_h$ as both arguments. Your derivation must proceed from the definitions of the broken gradient, the jump and average operators, and the penalty scaling. Finally, provide the closed-form analytic expression for $a(u_h,u_h)$ as a function of $\\sigma$ for this mesh with $h = 1/2$.\n\nAnswer format requirement: Report $a(u_h,u_h)$ as a single symbolic expression depending only on $\\sigma$. No numerical rounding is required. In your construction and derivation, interpret why this oscillatory mode would be disallowed by a continuous finite element method but can have small energy under under-penalization in the interior penalty framework.", "solution": "The SIPG formulation for the Poisson problem $-u'' = f$ on $\\Omega = [0,1]$ with homogeneous Dirichlet boundary conditions $u=0$ on $\\partial\\Omega$ seeks a function $u_h \\in V_h$ such that $a(u_h, v_h) = L(v_h)$ for all $v_h \\in V_h$. The bilinear form $a(u,v)$ is given by:\n$$\na(u,v) = \\sum_{K \\in \\mathcal{T}_h} \\int_K u' v' \\, dx - \\sum_{e \\in \\mathcal{E}_h^i} \\left( \\{u'\\} [v] + \\{v'\\} [u] \\right)|_e + \\sum_{e \\in \\mathcal{E}_h^i} \\frac{\\sigma}{h_e} [u] [v]|_e - \\sum_{e \\in \\mathcal{E}_h^b} \\left( u' n_K v + v' n_K u \\right)|_e + \\sum_{e \\in \\mathcal{E}_h^b} \\frac{\\sigma}{h_e} u v|_e\n$$\nHere, $\\mathcal{E}_h^i$ is the set of interior faces and $\\mathcal{E}_h^b$ is the set of boundary faces. For our specific problem, when $u=v$, this expression becomes:\n$$\na(u,u) = \\sum_{K \\in \\mathcal{T}_h} \\int_K (u')^2 \\, dx - \\sum_{e \\in \\mathcal{E}_h^i} 2 \\{u'\\} [u]|_e + \\sum_{e \\in \\mathcal{E}_h^i} \\frac{\\sigma}{h_e} [u]^2|_e - \\sum_{e \\in \\mathcal{E}_h^b} 2 u' n_K u|_e + \\sum_{e \\in \\mathcal{E}_h^b} \\frac{\\sigma}{h_e} u^2|_e\n$$\nThe domain $[0,1]$ is partitioned into two elements, $K_1 = [0, 1/2]$ and $K_2 = [1/2, 1]$. The element size is $h=1/2$. The interior face is $e_i = \\{1/2\\}$, and the boundary faces are $e_{b0} = \\{0\\}$ and $e_{b1} = \\{1\\}$. The outward unit normals to the domain $\\Omega$ are $n_K = -1$ at $x=0$ and $n_K = 1$ at $x=1$.\n\nThe discrete function $u_h \\in V_h$ is defined as:\n$$\nu_h(x) = \\begin{cases} 1 & \\text{for } x \\in K_1 = [0, 1/2] \\\\ -1 & \\text{for } x \\in K_2 = (1/2, 1] \\end{cases}\n$$\nSince $u_h$ is a piecewise constant function, its derivative within each element is zero: $u_h'(x) = 0$ for $x \\in (0, 1/2)$ and $x \\in (1/2, 1)$.\n\nWe now evaluate each term of $a(u_h, u_h)$:\n\n1.  **Volume Term**: This term measures the energy of the gradient within elements. As $u_h'=0$ almost everywhere, this term is zero.\n    $$\n    \\sum_{K \\in \\mathcal{T}_h} \\int_K (u_h')^2 \\, dx = \\int_{0}^{1/2} (0)^2 \\, dx + \\int_{1/2}^{1} (0)^2 \\, dx = 0\n    $$\n\n2.  **Interior Face Term**: This term is evaluated at the single interior face $e_i = \\{1/2\\}$. We first compute the necessary traces, jump, and average.\n    -   Traces from the left ($^-$) and right ($^+$):\n        $$\n        u_h^- = \\lim_{x \\to 1/2^-} u_h(x) = 1\n        $$\n        $$\n        u_h^+ = \\lim_{x \\to 1/2^+} u_h(x) = -1\n        $$\n    -   Jump of $u_h$:\n        $$\n        [u_h]|_{1/2} = u_h^- - u_h^+ = 1 - (-1) = 2\n        $$\n    -   Traces of the derivative:\n        $$\n        (u_h')^- = \\lim_{x \\to 1/2^-} u_h'(x) = 0\n        $$\n        $$\n        (u_h')^+ = \\lim_{x \\to 1/2^+} u_h'(x) = 0\n        $$\n    -   Average of the derivative:\n        $$\n        \\{u_h'\\}|_{1/2} = \\frac{(u_h')^- + (u_h')^+}{2} = \\frac{0 + 0}{2} = 0\n        $$\n    The interior face contribution consists of the consistency/symmetry term and the penalty term.\n    -   Consistency/Symmetry: $- 2 \\{u_h'\\} [u_h]|_{1/2} = -2 \\cdot (0) \\cdot (2) = 0$.\n    -   Penalty: $\\frac{\\sigma}{h} [u_h]^2|_{1/2}$. With $h=1/2$, this is $\\frac{\\sigma}{1/2} (2)^2 = 2\\sigma \\cdot 4 = 8\\sigma$.\n    The total interior face contribution is $0 + 8\\sigma = 8\\sigma$.\n\n3.  **Boundary Face Terms**: These are evaluated at $e_{b0}=0$ and $e_{b1}=1$.\n    -   **At $x=0$**: The trace is taken from within element $K_1$. The outward normal is $n_K = -1$.\n        -   Trace of $u_h$: $u_h|_0 = u_h(0^+) = 1$.\n        -   Trace of $u_h'$: $u_h'|_0 = u_h'(0^+) = 0$.\n        -   The contribution is $-2 u_h' n_K u_h|_0 + \\frac{\\sigma}{h} u_h^2|_0 = -2 \\cdot (0) \\cdot (-1) \\cdot (1) + \\frac{\\sigma}{1/2} (1)^2 = 0 + 2\\sigma = 2\\sigma$.\n    -   **At $x=1$**: The trace is taken from within element $K_2$. The outward normal is $n_K = 1$.\n        -   Trace of $u_h$: $u_h|_1 = u_h(1^-) = -1$.\n        -   Trace of $u_h'$: $u_h'(1^-) = 0$.\n        -   The contribution is $-2 u_h' n_K u_h|_1 + \\frac{\\sigma}{h} u_h^2|_1 = -2 \\cdot (0) \\cdot (1) \\cdot (-1) + \\frac{\\sigma}{1/2} (-1)^2 = 0 + 2\\sigma = 2\\sigma$.\n    The total boundary face contribution is $2\\sigma + 2\\sigma = 4\\sigma$.\n\n4.  **Total Interior Penalty Energy**: We sum all contributions.\n    $$\n    a(u_h, u_h) = (\\text{Volume Term}) + (\\text{Interior Face Term}) + (\\text{Boundary Face Terms})\n    $$\n    $$\n    a(u_h, u_h) = 0 + 8\\sigma + 4\\sigma = 12\\sigma\n    $$\n\nThe interpretation of this result is as follows. In a standard continuous finite element method (CG-FEM), the trial and test functions must belong to the Sobolev space $H^1([0,1])$, which requires them to be continuous. The function $u_h$ has a jump discontinuity at $x=1/2$ and is therefore not in $H^1([0,1])$. It is simply not an admissible function in a CG-FEM space and is thus \"disallowed\".\n\nIn a discontinuous Galerkin (DG) framework, the function space $V_h$ allows for such discontinuities. The function $u_h$ is a valid member of the piecewise constant space. Its \"energy,\" as measured by the bilinear form $a(u_h, u_h)$, is $12\\sigma$. This energy arises entirely from the penalty terms on the interior and boundary faces, as the bulk (gradient) term is zero. The magnitude of this energy is directly proportional to the penalty parameter $\\sigma$. If $\\sigma$ is chosen to be very small (a condition known as \"under-penalization\"), this highly oscillatory mode $u_h$ will have a very small energy. A stable DG method relies on a sufficiently large $\\sigma$ to ensure that such non-physical oscillations are assigned a large energy, effectively suppressing them in the numerical solution. The existence of such a mode with energy proportional to $\\sigma$ demonstrates the crucial role of the penalty parameter in controlling the inter-element jumps and stabilizing the DG method.\n\nThe final derived expression for the interior penalty energy is $a(u_h, u_h) = 12\\sigma$.", "answer": "$$\\boxed{12\\sigma}$$", "id": "3410396"}, {"introduction": "Beyond basic implementation, a key aspect of modern finite element methods is computational efficiency, especially for large-scale problems. This exercise [@problem_id:3410430] introduces the powerful technique of hybridization, which reduces the globally coupled degrees of freedom to Lagrange multipliers defined only on element faces. You will implement this method for a 1D SIPG discretization, perform static condensation to form the Schur complement system, and numerically investigate its spectral properties.", "problem": "Consider the model problem of the one-dimensional Poisson equation on the unit interval, namely $-u''(x) = f(x)$ for $x \\in (0,1)$ with homogeneous Dirichlet boundary conditions $u(0) = 0$ and $u(1) = 0$. Use the Discontinuous Galerkin framework with the Symmetric Interior Penalty Galerkin (SIPG) method and polynomial degree $p = 1$ per element to formulate the discrete bilinear form. Then, hybridize the SIPG method by introducing face Lagrange multipliers (one scalar per interior face) representing the single-valued numerical trace of $u$. Condense the element-interior degrees of freedom and derive the Schur complement system posed only on the face Lagrange multipliers. Study how the choice of penalty parameter affects the spectrum of this condensed Schur complement.\n\nStart from the fundamental definitions of the Discontinuous Galerkin method for second-order elliptic operators, including:\n- The weak formulation with broken Sobolev spaces and numerical fluxes.\n- The SIPG interface terms constructed from jumps $[\\,\\cdot\\,]$ and averages $\\{\\cdot\\}$ across faces.\n- The penalty contribution $\\sigma/h$ on each face, with $h$ the element size and $\\sigma > 0$ the penalty parameter.\n\nIn one spatial dimension, consider a uniform mesh of $N$ elements on $[0,1]$ with element size $h = 1/N$. For each element $E$, use the local nodal basis at the left and right endpoints, yielding two element-interior degrees of freedom per element, denoted by $u_L$ and $u_R$, and introduce a single face Lagrange multiplier $\\lambda$ per interior face to represent the hybridized trace. In the hybridized SIPG formulation, the per-face SIPG terms can be written per element using the numerical trace $\\hat{u}$ on each face:\n$$\n-\\partial_n u_E\\,(v_E - \\hat{v}) - \\partial_n v_E\\,(u_E - \\hat{u}) + \\frac{\\sigma}{h}\\,(u_E - \\hat{u})(v_E - \\hat{v}),\n$$\nwith outward normal derivative $\\partial_n$ and $u_E, v_E$ denoting the values of the trial and test functions at the face from element $E$. For boundary faces with homogeneous Dirichlet data, set the hybrid trace to the boundary value, which is zero for this problem.\n\nYou must:\n1. Assemble the global hybridized SIPG system matrix in block form\n$$\n\\begin{pmatrix}\nK & B^{\\top} \\\\\nB & C\n\\end{pmatrix},\n$$\nwhere $K$ couples element-interior degrees of freedom, $B$ couples face multipliers to element-interior degrees of freedom, and $C$ couples face multipliers among themselves via the penalty terms. Use the element-wise exact integration for $p=1$ which yields the interior stiffness contribution $\\int_E u' v' \\, dx$ and the face terms above. In one spatial dimension with $p=1$, the basis derivatives are constant on each element, and the face values are the nodal degrees of freedom.\n2. Perform static condensation to eliminate the element-interior degrees of freedom and obtain the Schur complement on the face multipliers,\n$$\nS = C - B\\,K^{-1}\\,B^{\\top}.\n$$\n3. Compute the eigenvalues of $S$, and for each test case report two quantities: the smallest eigenvalue and the spectral condition number defined as the ratio of the largest to the smallest eigenvalue. If the smallest eigenvalue is nonpositive (less than or equal to a tolerance of $10^{-12}$), report the smallest eigenvalue as computed and set the condition number to $+\\infty$.\n\nExplicitly construct the algorithm and computations from the base principles described above, without using any black-box Discontinuous Galerkin assembly shortcuts. Ensure that the hybridization process and the block structure follow from the SIPG bilinear form and that the condensation is implemented by solving linear systems with the $K$ block.\n\nImplement the program for the following test suite of penalty parameters and mesh sizes:\n- Test $1$: $N = 4$, $\\sigma = 1.0$.\n- Test $2$: $N = 4$, $\\sigma = 0.2$.\n- Test $3$: $N = 8$, $\\sigma = 1.0$.\n- Test $4$: $N = 2$, $\\sigma = 0.01$.\n- Test $5$: $N = 6$, $\\sigma = 10.0$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case contributes a two-entry list $[\\text{min\\_eig}, \\text{cond}]$ in that order. For example: $[[a,b],[c,d],\\dots]$. There are no physical units in this problem. Angles are not involved. Percentages are not involved. The outputs must be real numbers (floats). The final matrix must be assembled and analyzed numerically by your program; do not hard-code any analytic eigenvalues.", "solution": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_case(N, sigma):\n    \"\"\"\n    Computes the Schur complement eigenvalues and condition number for a given\n    mesh size N and penalty parameter sigma.\n    \"\"\"\n    h = 1.0 / N\n    \n    # 1. Assemble K, B, C matrices\n    \n    # K is a block-diagonal matrix composed of N element stiffness matrices Ki.\n    # Ki couples the 2 degrees of freedom within one element.\n    num_u_dofs = 2 * N\n    K = np.zeros((num_u_dofs, num_u_dofs))\n    Ki = (1.0 / h) * np.array([[sigma - 1.0, 1.0], \n                                 [1.0, sigma - 1.0]])\n    for i in range(N):\n        K[2*i:2*i+2, 2*i:2*i+2] = Ki\n\n    # C couples the face multipliers to themselves.\n    # It is a diagonal matrix for the (N-1) interior faces.\n    num_lambda_dofs = N - 1\n    if num_lambda_dofs == 0: # Case N=1 has no interior faces.\n        return [0.0, 1.0] \n        \n    C = np.diag(np.full(num_lambda_dofs, 2.0 * sigma / h))\n\n    # B couples the face multipliers to the element-interior degrees of freedom.\n    # It is a sparse (N-1)x(2N) matrix.\n    # Row j-1 of B corresponds to interior face j.\n    B = np.zeros((num_lambda_dofs, num_u_dofs))\n    for face_idx in range(1, N): # Iterate over interior faces 1, ..., N-1\n        # The row in B corresponding to face_idx is (face_idx - 1).\n        row_idx = face_idx - 1\n        \n        # Face face_idx is between element face_idx (left) and element face_idx+1 (right).\n        # In 0-based Python indexing, these are elements (face_idx - 1) and face_idx.\n        \n        # Contribution from the right side of the left element (element face_idx-1)\n        # Affects DoFs indexed by 2*(face_idx-1) and 2*(face_idx-1)+1\n        # This corresponds to the second row of the local B matrix.\n        left_elem_dof_start_idx = 2 * (face_idx - 1)\n        B[row_idx, left_elem_dof_start_idx]     = -1.0 / h\n        B[row_idx, left_elem_dof_start_idx + 1] = (1.0 - sigma) / h\n\n        # Contribution from the left side of the right element (element face_idx)\n        # Affects DoFs indexed by 2*(face_idx) and 2*(face_idx)+1\n        # This corresponds to the first row of the local B matrix.\n        right_elem_dof_start_idx = 2 * face_idx\n        B[row_idx, right_elem_dof_start_idx]     = (1.0 - sigma) / h\n        B[row_idx, right_elem_dof_start_idx + 1] = -1.0 / h\n\n    # 2. Perform static condensation to obtain the Schur complement S.\n    # K is invertible for sigma not in {0, 2}, which is true for all test cases.\n    try:\n        K_inv = np.linalg.inv(K)\n    except np.linalg.LinAlgError:\n        # This will happen if K is singular (e.g., sigma=0 or 2)\n        return [0.0, float('inf')]\n        \n    S = C - B @ K_inv @ B.T\n    \n    # 3. Compute eigenvalues and condition number of S.\n    # S is symmetric, so eigvalsh is efficient and returns sorted eigenvalues.\n    if S.shape[0] == 1:\n        eigenvalues = np.array([S[0,0]])\n    else:\n        eigenvalues = np.linalg.eigvalsh(S)\n    \n    min_eig = eigenvalues[0]\n    max_eig = eigenvalues[-1]\n    \n    if min_eig = 1e-12:\n        cond_num = float('inf')\n    else:\n        cond_num = max_eig / min_eig\n\n    return [min_eig, cond_num]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (4, 1.0),    # Test 1\n        (4, 0.2),    # Test 2\n        (8, 1.0),    # Test 3\n        (2, 0.01),   # Test 4\n        (6, 10.0),   # Test 5\n    ]\n\n    results = []\n    for case in test_cases:\n        N, sigma = case\n        result = solve_case(N, sigma)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # Use map and str to handle potential 'inf' correctly.\n    formatted_results = [f\"[{res[0]},{str(res[1])}]\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_case(N, sigma):\n    \"\"\"\n    Computes the Schur complement eigenvalues and condition number for a given\n    mesh size N and penalty parameter sigma.\n    \"\"\"\n    h = 1.0 / N\n    \n    # 1. Assemble K, B, C matrices\n    \n    # K is a block-diagonal matrix composed of N element stiffness matrices Ki.\n    # Ki couples the 2 degrees of freedom within one element.\n    num_u_dofs = 2 * N\n    K = np.zeros((num_u_dofs, num_u_dofs))\n    Ki = (1.0 / h) * np.array([[sigma - 1.0, 1.0], \n                                 [1.0, sigma - 1.0]])\n    for i in range(N):\n        K[2*i:2*i+2, 2*i:2*i+2] = Ki\n\n    # C couples the face multipliers to themselves.\n    # It is a diagonal matrix for the (N-1) interior faces.\n    num_lambda_dofs = N - 1\n    if num_lambda_dofs == 0: # Case N=1 has no interior faces.\n        return [0.0, 1.0] \n        \n    C = np.diag(np.full(num_lambda_dofs, 2.0 * sigma / h))\n\n    # B couples the face multipliers to the element-interior degrees of freedom.\n    # It is a sparse (N-1)x(2N) matrix.\n    # Row j-1 of B corresponds to interior face j.\n    B = np.zeros((num_lambda_dofs, num_u_dofs))\n    for face_idx in range(1, N): # Iterate over interior faces 1, ..., N-1\n        # The row in B corresponding to face_idx is (face_idx - 1).\n        row_idx = face_idx - 1\n        \n        # Face face_idx is between element face_idx (left) and element face_idx+1 (right).\n        # In 0-based Python indexing, these are elements (face_idx - 1) and face_idx.\n        \n        # Contribution from the right side of the left element (element face_idx-1)\n        # Affects DoFs indexed by 2*(face_idx-1) and 2*(face_idx-1)+1\n        # This corresponds to the second row of the local B matrix.\n        left_elem_dof_start_idx = 2 * (face_idx - 1)\n        B[row_idx, left_elem_dof_start_idx]     = -1.0 / h\n        B[row_idx, left_elem_dof_start_idx + 1] = (1.0 - sigma) / h\n\n        # Contribution from the left side of the right element (element face_idx)\n        # Affects DoFs indexed by 2*(face_idx) and 2*(face_idx)+1\n        # This corresponds to the first row of the local B matrix.\n        right_elem_dof_start_idx = 2 * face_idx\n        B[row_idx, right_elem_dof_start_idx]     = (1.0 - sigma) / h\n        B[row_idx, right_elem_dof_start_idx + 1] = -1.0 / h\n\n    # 2. Perform static condensation to obtain the Schur complement S.\n    # K is invertible for sigma not in {0, 2}, which is true for all test cases.\n    try:\n        K_inv = np.linalg.inv(K)\n    except np.linalg.LinAlgError:\n        # This will happen if K is singular (e.g., sigma=0 or 2)\n        return [0.0, float('inf')]\n        \n    S = C - B @ K_inv @ B.T\n    \n    # 3. Compute eigenvalues and condition number of S.\n    # S is symmetric, so eigvalsh is efficient and returns sorted eigenvalues.\n    if S.shape[0] == 1:\n        eigenvalues = np.array([S[0,0]])\n    else:\n        eigenvalues = np.linalg.eigvalsh(S)\n    \n    min_eig = eigenvalues[0]\n    max_eig = eigenvalues[-1]\n    \n    if min_eig = 1e-12:\n        cond_num = float('inf')\n    else:\n        cond_num = max_eig / min_eig\n\n    return [min_eig, cond_num]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (4, 1.0),    # Test 1\n        (4, 0.2),    # Test 2\n        (8, 1.0),    # Test 3\n        (2, 0.01),   # Test 4\n        (6, 10.0),   # Test 5\n    ]\n\n    results = []\n    for case in test_cases:\n        N, sigma = case\n        result = solve_case(N, sigma)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # Use map and str to handle potential 'inf' correctly.\n    formatted_results = [f\"[{res[0]},{str(res[1])}]\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3410430"}]}