{"hands_on_practices": [{"introduction": "The standard Galerkin finite element method, while powerful for elliptic problems, can produce severe non-physical oscillations when applied to advection-dominated transport phenomena. This first exercise [@problem_id:3447423] provides a direct, hands-on experience with this well-known instability by exploring the role of the element Péclet number, $Pe_h$. You will implement both the standard Galerkin and the Streamline-Upwind/Petrov-Galerkin (SUPG) methods to observe firsthand how a consistent, residual-based stabilization term restores solution monotonicity and physical realism.", "problem": "Consider the steady one-dimensional advection-diffusion Partial Differential Equation (PDE) on the unit interval with homogeneous and inhomogeneous Dirichlet boundary conditions: find $u(x)$ such that\n$$\n- \\epsilon \\, u''(x) + \\beta \\, u'(x) = f(x), \\quad x \\in (0,1),\n$$\nwith boundary conditions $u(0)=0$ and $u(1)=1$. Assume constant parameters $\\epsilon > 0$, $\\beta \\in \\mathbb{R}$, and $f(x)=0$. Starting from the strong form, derive the weak form using the standard procedure of multiplying by a test function $v(x)$, integrating over the domain, and applying integration by parts where appropriate. Use the Finite Element Method (FEM) with continuous, piecewise linear basis functions on a uniform mesh to obtain a discrete Galerkin system. Discuss why the resulting Galerkin discretization becomes numerically unstable for advection-dominated regimes, and define the element Péclet number in terms of mesh size $h$, advection speed $\\beta$, and diffusivity $\\epsilon$. The Péclet number should be defined as a dimensionless ratio that quantifies the relative strength of advection to diffusion at the element level.\n\nTo address instability, construct a stabilized formulation using the Streamline Upwind/Petrov-Galerkin (SUPG) method. Starting from the residual-based idea, enrich the test space in the streamline direction and show how this leads to an additional consistent stabilization term. Derive an expression for the stabilization parameter in terms of the local Péclet number that is asymptotically correct in both diffusion-dominated and advection-dominated limits. Your derivation must proceed from first principles of the weak formulation and the residual-based enrichment mechanism, without quoting or assuming any ready-made formulas.\n\nImplement two solvers on a uniform mesh with $N$ elements:\n- The standard Galerkin FEM solver.\n- The SUPG-stabilized FEM solver using your derived stabilization parameter and consistent addition along streamlines.\n\nFor each solver, assemble the global linear system, impose the Dirichlet boundary conditions strongly, and solve for the nodal values $u_i$.\n\nDefine a monotonicity check for the discrete solution as follows: the solution is monotone non-decreasing if $u_{i+1}-u_i \\ge 0$ for all interior node indices $i$. Use a numerical tolerance of $10^{-12}$ to account for floating-point effects, i.e., treat $u_{i+1}-u_i \\ge -10^{-12}$ as non-decreasing. For each test case, compute:\n- The maximum element Péclet number $Pe_{\\max}$ over the mesh, expressed as a floating-point number.\n- A boolean indicating whether the Galerkin solution is monotone.\n- A boolean indicating whether the SUPG solution is monotone.\n\nUse the following test suite of parameter values $(N,\\beta,\\epsilon)$, which covers a range of regimes:\n1. $(100, 1.0, 10^{-2})$ representing moderately diffusion-dominated behavior.\n2. $(40, 1.0, 5 \\times 10^{-3})$ representing a regime where advection begins to dominate.\n3. $(50, 1.0, 10^{-4})$ representing strongly advection-dominated behavior.\n4. $(50, 0.0, 10^{-2})$ representing pure diffusion (no advection).\n\nAll quantities here are dimensionless. Your program should produce a single line of output containing the results as a comma-separated list of four inner lists, one per test case, where each inner list is of the form $[Pe_{\\max}, M_G, M_S]$ with $Pe_{\\max}$ as a float, and $M_G$, $M_S$ as booleans for the monotonicity of the Galerkin and SUPG solutions, respectively. For example, the final output format must be\n$$\n\\texttt{[[Pe1,MG1,MS1],[Pe2,MG2,MS2],[Pe3,MG3,MS3],[Pe4,MG4,MS4]]}.\n$$", "solution": "The repository of this solution is structured into four main parts: a critical validation of the problem statement, a detailed theoretical derivation of the required numerical methods, the implementation architecture of the final Python code, and the final program itself.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n\n- **Governing Equation:** The steady one-dimensional advection-diffusion PDE is given by $- \\epsilon \\, u''(x) + \\beta \\, u'(x) = f(x)$ for $x \\in (0,1)$.\n- **Parameters:** The diffusivity $\\epsilon$ is positive ($\\epsilon > 0$), the advection speed $\\beta$ is a real number ($\\beta \\in \\mathbb{R}$), and the source term $f(x)$ is zero ($f(x)=0$).\n- **Boundary Conditions:** Inhomogeneous Dirichlet conditions are prescribed: $u(0)=0$ and $u(1)=1$.\n- **Numerical Method:** The Finite Element Method (FEM) is to be used with continuous, piecewise linear basis functions on a uniform mesh with $N$ elements.\n- **Tasks:**\n    1.  Derive the weak form of the PDE.\n    2.  Formulate the standard Galerkin discrete system.\n    3.  Analyze the numerical instability of the Galerkin method in advection-dominated regimes and define the element Péclet number.\n    4.  Derive the Streamline Upwind/Petrov-Galerkin (SUPG) stabilized formulation, including the expression for the stabilization parameter $\\tau$.\n    5.  Implement both the Galerkin and SUPG solvers.\n    6.  For a given set of test cases, compute the maximum element Péclet number ($Pe_{\\max}$), and check the monotonicity of the Galerkin solution ($M_G$) and the SUPG solution ($M_S$).\n- **Monotonicity Criterion:** A discrete solution $\\{u_i\\}$ is considered monotone non-decreasing if $u_{i+1} - u_i \\ge -10^{-12}$ for all adjacent node pairs.\n- **Test Cases:** The analysis is to be performed for four parameter sets $(N, \\beta, \\epsilon)$:\n    1. $(100, 1.0, 10^{-2})$\n    2. $(40, 1.0, 5 \\times 10^{-3})$\n    3. $(50, 1.0, 10^{-4})$\n    4. $(50, 0.0, 10^{-2})$\n\n**Step 2: Validate Using Extracted Givens**\n\n- **Scientific Grounding:** The problem is fundamentally sound. The advection-diffusion equation is a canonical model in transport phenomena. The Galerkin FEM and SUPG stabilization are cornerstone techniques in the field of numerical methods for PDEs. All concepts are well-established within the scientific literature.\n- **Well-Posedness and Completeness:** The problem is well-posed. The PDE combined with the Dirichlet boundary conditions forms a valid boundary value problem with a unique solution. The tasks are specific, and all necessary information (equations, parameters, boundary conditions, numerical methods) is provided.\n- **Objectivity and Feasibility:** The problem is stated in objective, mathematical terms. The required derivations and implementations are standard exercises in computational science and engineering, and the provided test cases are computationally feasible.\n\n**Step 3: Verdict and Action**\n\nThe problem is deemed **valid**. It is a well-defined and standard problem in numerical analysis that requires the derivation and implementation of fundamental FEM techniques. The solution process will now proceed.\n\n### Theoretical Derivation and Formulation\n\n#### 1. Weak Formulation\nWe begin with the strong form of the PDE on the domain $\\Omega = (0,1)$:\n$$\n- \\epsilon u''(x) + \\beta u'(x) = 0, \\quad x \\in (0,1)\n$$\nwith boundary conditions $u(0)=0$ and $u(1)=1$.\n\nTo derive the weak form, we multiply the equation by a test function $v(x)$ from a suitable function space and integrate over the domain $\\Omega$. The test functions are chosen from the space $H^1_0(\\Omega)$, which consists of functions that are square-integrable, have square-integrable first derivatives, and vanish at the boundaries where Dirichlet conditions are specified. In this case, $H^1_0(\\Omega) = \\{v \\in H^1(\\Omega) \\mid v(0)=0, v(1)=0\\}$.\n\n$$\n\\int_0^1 \\left( - \\epsilon u''(x) + \\beta u'(x) \\right) v(x) \\, dx = 0\n$$\n\nThe term with the second derivative is handled using integration by parts:\n$$\n\\int_0^1 - \\epsilon u''(x) v(x) \\, dx = - \\epsilon \\left[ u'(x) v(x) \\right]_0^1 + \\int_0^1 \\epsilon u'(x) v'(x) \\, dx\n$$\nSince $v \\in H^1_0(\\Omega)$, we have $v(0)=0$ and $v(1)=0$. Therefore, the boundary term $- \\epsilon [u'(x)v(x)]_0^1$ vanishes.\n\nSubstituting this back into the integrated equation gives the weak form: Find a function $u \\in H^1(\\Omega)$ satisfying the Dirichlet boundary conditions $u(0)=0$ and $u(1)=1$ such that for all test functions $v \\in H^1_0(\\Omega)$, the following holds:\n$$\n\\int_0^1 \\left( \\epsilon u'(x) v'(x) + \\beta u'(x) v(x) \\right) \\, dx = 0\n$$\nThis can be written compactly as $B(u, v) = 0$, where $B(u, v)$ is the bilinear form associated with the operator.\n\n#### 2. Galerkin Finite Element Discretization\nWe discretize the domain $\\Omega=[0,1]$ with a uniform mesh of $N$ elements, resulting in $N+1$ nodes $x_i = i h$ for $i \\in \\{0, 1, \\dots, N\\}$, where the mesh size is $h = 1/N$.\n\nWe approximate the solution $u(x)$ using continuous, piecewise linear basis functions $\\phi_i(x)$ (hat functions):\n$$\nu_h(x) = \\sum_{j=0}^{N} U_j \\phi_j(x)\n$$\nwhere $U_j$ is the unknown nodal value of the solution at node $x_j$, i.e., $U_j \\approx u(x_j)$. The basis function $\\phi_j(x)$ has the property that $\\phi_j(x_i) = \\delta_{ij}$ (the Kronecker delta).\n\nThe discrete Galerkin formulation requires the weak form to hold for all test functions in a finite-dimensional subspace $V_h \\subset H^1_0(\\Omega)$. This subspace is spanned by the basis functions corresponding to the interior nodes: $V_h = \\text{span}\\{\\phi_1, \\phi_2, \\dots, \\phi_{N-1}\\}$.\n\nThe Galerkin problem is: Find $u_h(x)$ with nodal values $U_0=0$ and $U_N=1$ such that\n$$\n\\int_0^1 \\left( \\epsilon u_h'(x) v_h'(x) + \\beta u_h'(x) v_h(x) \\right) \\, dx = 0 \\quad \\forall v_h \\in V_h\n$$\nBy linearity, this must hold for each basis function $v_h = \\phi_i(x)$ for $i \\in \\{1, \\dots, N-1\\}$. Substituting the expansion for $u_h(x)$ yields a system of linear equations:\n$$\n\\sum_{j=0}^{N} U_j \\left( \\int_0^1 \\left( \\epsilon \\phi_j'(x) \\phi_i'(x) + \\beta \\phi_j'(x) \\phi_i(x) \\right) \\, dx \\right) = 0 \\quad \\text{for } i=1, \\dots, N-1\n$$\nThis defines a linear system $A \\mathbf{U} = \\mathbf{F}$, where $\\mathbf{U} = [U_1, \\dots, U_{N-1}]^T$ is the vector of unknown interior nodal values. The entries of the system matrix and right-hand side are constructed by assembling contributions from each element $K_e = [x_{e-1}, x_e]$. On a generic element $K_e$, the solution is interpolated by the two local basis functions, $N_1(\\xi) = 1 - \\xi/h$ and $N_2(\\xi) = \\xi/h$, where $\\xi = x-x_{e-1}$. The element matrix $A^e$ has entries $A^e_{ij} = B(\\phi_j, \\phi_i)|_{K_e}$. The local derivatives are $N_1' = -1/h$ and $N_2' = 1/h$.\n\nThe element diffusion (stiffness) matrix is:\n$$\nK^e = \\int_{K_e} \\epsilon N_i' N_j' \\, dx = \\frac{\\epsilon}{h} \\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix}\n$$\nThe element advection matrix is:\n$$\nC^e = \\int_{K_e} \\beta N_j' N_i \\, dx = \\frac{\\beta}{2} \\begin{pmatrix} -1 & 1 \\\\ -1 & 1 \\end{pmatrix}\n$$\nThe Galerkin element matrix is $A^e_{Gal} = K^e + C^e$:\n$$\nA^e_{Gal} = \\begin{pmatrix} \\frac{\\epsilon}{h} - \\frac{\\beta}{2} & -\\frac{\\epsilon}{h} + \\frac{\\beta}{2} \\\\ -\\frac{\\epsilon}{h} - \\frac{\\beta}{2} & \\frac{\\epsilon}{h} + \\frac{\\beta}{2} \\end{pmatrix}\n$$\n\n#### 3. Numerical Instability and the Péclet Number\nThe Galerkin method, being equivalent to a central difference scheme in this 1D case, is prone to producing non-physical, spurious oscillations when advection dominates diffusion. This occurs because the centered stencil is not consistent with the directional nature of advective transport.\n\nThe relative strength of advection to diffusion at the element level is quantified by the dimensionless **element Péclet number**, defined as:\n$$\nPe_h = \\frac{|\\beta| h}{2 \\epsilon}\n$$\nThis number compares the cell advection \"time\" ($h/|\\beta|$) to the cell diffusion \"time\" ($h^2/(2\\epsilon)$). When $Pe_h \\gg 1$, advection dominates, and the Galerkin solution becomes unstable, exhibiting oscillations that violate the physical principle of monotonicity. Stability is typically guaranteed only for $Pe_h \\le 1$.\n\n#### 4. Streamline Upwind/Petrov-Galerkin (SUPG) Formulation\nTo counteract these oscillations, a stabilization term is added to the Galerkin formulation. The SUPG method achieves this by enriching the test space. Specifically, each test function $v_h$ is perturbed by a term proportional to its derivative in the streamline (advection) direction. The modified test function is $\\tilde{v}_h = v_h + \\tau_e \\beta v_h'$, where $\\tau_e$ is a stabilization parameter defined on each element $K_e$.\n\nThe motivation for this form comes from a residual-based argument. The exact solution $u$ satisfies the PDE, so its residual $R(u) = -\\epsilon u'' + \\beta u' = 0$. The discrete solution $u_h$ does not, so its element-wise residual is non-zero. For piecewise linear elements, $u_h''=0$ within each element, so the residual simplifies to $R(u_h)|_{K_e} = \\beta u_h'$. The SUPG method adds a term to the weak form that is the integral of this residual against the test function perturbation:\n$$\nB_{SUPG}(u_h, v_h) = B_{Gal}(u_h, v_h) + \\sum_{e=1}^N \\int_{K_e} (\\beta u_h')(\\tau_e \\beta v_h') \\, dx = 0\n$$\nThe full stabilized weak formulation is:\n$$\n\\int_0^1 \\left( \\epsilon u_h' v_h' + \\beta u_h' v_h \\right) \\, dx + \\sum_{e=1}^N \\int_{K_e} \\tau_e \\beta^2 u_h' v_h' \\, dx = 0\n$$\nThe stabilization term introduces an artificial diffusion $\\tau_e \\beta^2$ that acts only along the streamline direction, thus it is often called streamline diffusion. The method is consistent because the added term depends on the residual, which vanishes for the exact solution.\n\nThe element stabilization matrix is:\n$$\nS^e = \\int_{K_e} \\tau_e \\beta^2 N_i' N_j' \\, dx = \\frac{\\tau_e \\beta^2}{h} \\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix}\n$$\nThe SUPG element matrix is $A^e_{SUPG} = A^e_{Gal} + S^e$.\n\nThe stabilization parameter $\\tau_e$ must be chosen carefully. An optimal choice in 1D, which yields nodally exact solutions, is derived to be a function of the element Péclet number:\n$$\n\\tau_e = \\frac{h}{2|\\beta|} \\xi(Pe_h) \\quad \\text{where} \\quad \\xi(Pe_h) = \\coth(Pe_h) - \\frac{1}{Pe_h}\n$$\nThis form has the correct asymptotic behavior:\n- **Advection-dominated limit ($Pe_h \\to \\infty$):** $\\coth(Pe_h) \\to 1$, so $\\xi(Pe_h) \\to 1$. This gives $\\tau_e \\to \\frac{h}{2|\\beta|}$. The artificial diffusion becomes $\\tau_e \\beta^2 = \\frac{|\\beta|h}{2}$, which recovers the first-order upwind scheme.\n- **Diffusion-dominated limit ($Pe_h \\to 0$):** Using the Taylor expansion $\\coth(x) \\approx 1/x + x/3$, we get $\\xi(Pe_h) \\approx Pe_h/3$. This gives $\\tau_e \\approx \\frac{h}{2|\\beta|} \\frac{Pe_h}{3} = \\frac{h^2}{12\\epsilon}$. The artificial diffusion $\\tau_e \\beta^2 = \\frac{h^2 \\beta^2}{12\\epsilon}$ vanishes as $Pe_h \\to 0$, recovering the standard Galerkin method.\nFor the case $\\beta=0$, the Péclet number is $0$, and the stabilization term $\\tau_e\\beta^2$ is manifestly zero, so SUPG correctly reduces to the Galerkin method.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D advection-diffusion problem using Galerkin FEM and SUPG-FEM,\n    and analyzes the monotonicity of the solutions for different regimes.\n    \"\"\"\n\n    test_cases = [\n        # (N, beta, epsilon)\n        (100, 1.0, 1e-2),\n        (40, 1.0, 5e-3),\n        (50, 1.0, 1e-4),\n        (50, 0.0, 1e-2),\n    ]\n\n    results = []\n    for N, beta, epsilon in test_cases:\n        # 1. Calculate problem parameters\n        h = 1.0 / N\n        # The Peclet number is constant over the uniform mesh\n        # Handle the case epsilon > 0 but beta=0, where Pe=0.\n        if abs(beta) < 1e-12 or epsilon == 0:\n            pe_max = 0.0\n        else:\n            pe_max = abs(beta) * h / (2 * epsilon)\n\n        # 2. Solve using Galerkin and SUPG methods\n        sol_galerkin = run_fem_solver(N, beta, epsilon, supg=False)\n        sol_supg = run_fem_solver(N, beta, epsilon, supg=True)\n\n        # 3. Perform monotonicity check\n        tol = -1e-12\n        mono_galerkin = np.all(np.diff(sol_galerkin) >= tol)\n        mono_supg = np.all(np.diff(sol_supg) >= tol)\n\n        # 4. Store results\n        results.append([pe_max, bool(mono_galerkin), bool(mono_supg)])\n    \n    # Final output formatting\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_fem_solver(N, beta, epsilon, supg):\n    \"\"\"\n    Assembles and solves the linear system for the 1D advection-diffusion\n    equation using either standard Galerkin or SUPG stabilization.\n\n    Args:\n        N (int): Number of elements.\n        beta (float): Advection coefficient.\n        epsilon (float): Diffusion coefficient.\n        supg (bool): If True, use SUPG stabilization.\n\n    Returns:\n        np.array: The full solution vector of nodal values, including boundaries.\n    \"\"\"\n    h = 1.0 / N\n    \n    # Calculate stabilization parameter tau for SUPG\n    tau = 0.0\n    if supg and abs(beta) > 1e-12:\n        pe_h = abs(beta) * h / (2.0 * epsilon)\n        # Use Taylor expansion for coth(x) - 1/x for small x to avoid overflow/underflow\n        if pe_h < 1e-8:\n            xi_pe = pe_h / 3.0\n        else:\n            xi_pe = 1.0 / np.tanh(pe_h) - 1.0 / pe_h\n\n        tau = (h / (2.0 * abs(beta))) * xi_pe\n        \n    # Element matrix coefficients\n    # A_e = [[a11, a12], [a21, a22]]\n    # Diffusion part\n    k11 = epsilon / h\n    k12 = -epsilon / h\n    # Advection part\n    c11 = -beta / 2.0\n    c12 = beta / 2.0\n    # Stabilization part (artificial diffusion)\n    s11 = tau * beta**2 / h\n    s12 = -tau * beta**2 / h\n    \n    # Assemble element matrix A_e\n    a11 = k11 + c11 + s11\n    a12 = k12 + c12 + s12\n    a21 = k12 - c12 + s12 # Uses symmetry in diffusion and stab, anti-symm in advection\n    a22 = k11 - c11 + s11\n\n    # Assemble the (N-1)x(N-1) global system for interior nodes\n    num_unknowns = N - 1\n    if num_unknowns == 0:\n        return np.array([0.0, 1.0])\n\n    A_glob = np.zeros((num_unknowns, num_unknowns))\n\n    # Diagonal entries\n    diag_val = a22 + a11\n    np.fill_diagonal(A_glob, diag_val)\n\n    # Super-diagonal entries\n    if num_unknowns > 1:\n        super_diag_val = a12\n        np.fill_diagonal(A_glob[0:, 1:], super_diag_val)\n\n    # Sub-diagonal entries\n    if num_unknowns > 1:\n        sub_diag_val = a21\n        np.fill_diagonal(A_glob[1:, 0:], sub_diag_val)\n\n    # Construct the right-hand side vector F\n    # F is zero everywhere except for the last entry due to u(1)=1 BC\n    F_glob = np.zeros(num_unknowns)\n    F_glob[-1] = -a12 * 1.0 # u(N) = 1\n\n    # Solve the linear system A*U_int = F for interior nodes U_int\n    try:\n        U_interior = np.linalg.solve(A_glob, F_glob)\n    except np.linalg.LinAlgError:\n        # In extreme cases, the matrix might be singular. Return a non-monotone array.\n        U_interior = np.full(num_unknowns, np.nan)\n\n    # Combine with boundary conditions to form the full solution vector\n    U_full = np.concatenate(([0.0], U_interior, [1.0]))\n\n    return U_full\n\n\nsolve()\n```", "id": "3447423"}, {"introduction": "Extending stabilization methods to multiple dimensions reveals new challenges, particularly when the advection field $\\boldsymbol{b}$ is not aligned with the axes of the computational mesh. This practice [@problem_id:3447460] explores these complexities, highlighting the limitations of methods that only add diffusion along streamlines, which can still permit spurious crosswind oscillations. You will implement and compare the SUPG and the more general Galerkin/Least-Squares (GLS) methods, and further learn to diagnose and treat crosswind artifacts by introducing a targeted artificial diffusion.", "problem": "Consider the stationary linear advection-diffusion equation posed on the unit square domain $[0,1]\\times[0,1]$,\n$$ \\boldsymbol{b}\\cdot\\nabla u - \\varepsilon \\Delta u = 0 \\quad \\text{in } \\Omega, $$\nwith essential boundary conditions chosen as follows: on inflow portions of the boundary (where the outward unit normal $\\boldsymbol{n}$ satisfies $\\boldsymbol{b}\\cdot \\boldsymbol{n} &lt; 0$), prescribe $u=1$, and on outflow portions ($\\boldsymbol{b}\\cdot \\boldsymbol{n} \\ge 0$), prescribe $u=0$. The vector $\\boldsymbol{b}$ is constant and misaligned with the mesh axes, and the diffusion coefficient $\\varepsilon > 0$ is small.\n\nYou will discretize this problem using the standard continuous Galerkin finite element method with quadratic Lagrange basis functions on a structured anisotropic mesh of axis-aligned rectangles, and compare two stabilized formulations: the Streamline Upwind/Petrov-Galerkin (SUPG) and the Galerkin/Least-Squares (GLS) methods. Additionally, you will quantify the effect of adding crosswind diffusion (an artificial diffusion orthogonal to the flow direction) on crosswind oscillations.\n\nThe variational base starts from the weak form: find $u \\in H^1(\\Omega)$ satisfying\n$$ a(u,v) = 0 \\quad \\forall v \\in H^1_0(\\Omega), $$\nwhere\n$$ a(u,v) = \\int_{\\Omega} \\varepsilon \\nabla u \\cdot \\nabla v \\, d\\Omega + \\int_{\\Omega} (\\boldsymbol{b}\\cdot \\nabla u) v \\, d\\Omega. $$\n\nThe stabilized formulations modify $a(u,v)$ by adding terms defined elementwise on each mesh cell $\\Omega_e$:\n- Streamline Upwind/Petrov-Galerkin (SUPG): add\n$$ s_{\\mathrm{SUPG}}(u,v) = \\sum_{e} \\int_{\\Omega_e} \\tau_e \\, (\\boldsymbol{b}\\cdot \\nabla u)\\, (\\boldsymbol{b}\\cdot \\nabla v) \\, d\\Omega. $$\n- Galerkin/Least-Squares (GLS): add\n$$ s_{\\mathrm{GLS}}(u,v) = \\sum_{e} \\int_{\\Omega_e} \\tau_e \\, r(u)\\, r(v)\\, d\\Omega, \\quad r(w) := \\boldsymbol{b}\\cdot \\nabla w - \\varepsilon \\Delta w. $$\n\nThe crosswind diffusion augments the physical diffusion by a tensor term orthogonal to the flow direction. Let $\\widehat{\\boldsymbol{b}} = \\boldsymbol{b}/\\|\\boldsymbol{b}\\|$ and define the orthogonal projector onto the crosswind subspace\n$$ \\mathbf{P}_{\\perp} = \\mathbf{I} - \\widehat{\\boldsymbol{b}}\\, \\widehat{\\boldsymbol{b}}^\\top. $$\nWith crosswind diffusion coefficient $\\mu_{\\perp} \\ge 0$, add\n$$ d_{\\perp}(u,v) = \\int_{\\Omega} \\mu_{\\perp}\\, (\\nabla u)^\\top \\mathbf{P}_{\\perp}\\, \\nabla v \\, d\\Omega. $$\n\nUse quadratic ($Q_2$) Lagrange finite elements on rectangles, with the standard reference nodes at $\\xi, \\eta \\in \\{-1, 0, 1\\}$ and the one-dimensional basis functions\n$$ \\ell_{-1}(\\xi) = \\tfrac{1}{2}\\xi(\\xi - 1), \\quad \\ell_0(\\xi) = 1 - \\xi^2, \\quad \\ell_{+1}(\\xi) = \\tfrac{1}{2}\\xi(\\xi + 1), $$\nand their derivatives $\\ell'_{-1}(\\xi) = \\xi - \\tfrac{1}{2}$, $\\ell'_0(\\xi) = -2\\xi$, $\\ell'_{+1}(\\xi) = \\xi + \\tfrac{1}{2}$, and second derivatives $\\ell''_{-1}(\\xi) = 1$, $\\ell''_0(\\xi) = -2$, $\\ell''_{+1}(\\xi) = 1$. On each element with physical sizes $h_x$ and $h_y$, the gradients and Laplacians of shape functions are obtained via the affine mapping $(\\xi,\\eta)\\mapsto (x,y)$:\n$$ \\nabla N(\\xi,\\eta) = \\begin{bmatrix} \\tfrac{2}{h_x}\\,\\partial_{\\xi} N \\\\ \\tfrac{2}{h_y}\\,\\partial_{\\eta} N \\end{bmatrix}, \\quad \\Delta N(\\xi,\\eta) = \\left(\\tfrac{2}{h_x}\\right)^2 \\partial_{\\xi\\xi} N + \\left(\\tfrac{2}{h_y}\\right)^2 \\partial_{\\eta\\eta} N. $$\n\nChoose a stabilization parameter $\\tau_e$ per element based on the directional mesh size along the flow and the Péclet number. Let $\\widehat{\\boldsymbol{b}}=(\\cos\\theta,\\sin\\theta)$, and define the element-wise streamline length\n$$ h_{\\parallel} = \\sqrt{(h_x \\cos\\theta)^2 + (h_y \\sin\\theta)^2}, \\quad \\mathrm{Pe} = \\frac{\\|\\boldsymbol{b}\\|\\, h_{\\parallel}}{2\\varepsilon}. $$\nSet\n$$ \\tau_e = \\frac{h_{\\parallel}}{2\\|\\boldsymbol{b}\\|} \\left(\\coth(\\mathrm{Pe}) - \\frac{1}{\\mathrm{Pe}}\\right), $$\nwith the convention that for very small $\\mathrm{Pe}$, one uses the series approximation $\\coth(\\mathrm{Pe}) - 1/\\mathrm{Pe} \\approx \\mathrm{Pe}/3$.\n\nTo quantify crosswind oscillations, compute two metrics:\n1. The crosswind gradient index,\n$$ I_{\\perp} = \\frac{\\left\\| \\mathbf{P}_{\\perp} \\nabla u \\right\\|_{L^2(\\Omega)}^2}{\\left\\| \\nabla u \\right\\|_{L^2(\\Omega)}^2} = \\frac{\\int_{\\Omega} \\left( \\mathbf{P}_{\\perp} \\nabla u \\right)\\cdot \\left( \\mathbf{P}_{\\perp} \\nabla u \\right)\\, d\\Omega}{\\int_{\\Omega} \\nabla u \\cdot \\nabla u \\, d\\Omega}, $$\nwhich represents the fraction of gradient energy orthogonal to the flow direction.\n2. The interior overshoot/undershoot amplitude,\n$$ A_{\\mathrm{osc}} = \\max\\{0, \\max_{\\Omega^\\circ} u - 1\\} + \\max\\{0, -\\min_{\\Omega^\\circ} u\\}, $$\nwhere $\\Omega^\\circ$ denotes interior degrees of freedom (excluding Dirichlet boundary nodes). This measures nonphysical oscillations above the inflow value $1$ and below the outflow value $0$.\n\nImplement Gaussian quadrature on the reference square with three points in each dimension to compute element integrals exactly for polynomials up to degree five. Assemble the global linear system, impose essential boundary conditions strongly, and solve the resulting non-symmetric system.\n\nTest Suite:\nUse the following fixed parameters for all tests unless toggled as specified:\n- Mesh: $N_x = 18$ elements in $x$, $N_y = 6$ elements in $y$ (anisotropic with $h_x = 1/N_x$, $h_y = 1/N_y$).\n- Advection: $\\boldsymbol{b}$ of magnitude $\\|\\boldsymbol{b}\\|=1$ with angle $\\theta = 33^\\circ$ relative to the $x$-axis, i.e., $\\boldsymbol{b}=(\\cos\\theta,\\sin\\theta)$ in radians.\n- Diffusion: $\\varepsilon = 10^{-4}$.\n- Crosswind diffusion coefficient: $\\mu_{\\perp} = \\alpha_{\\perp} \\, \\|\\boldsymbol{b}\\|\\, h_{\\perp}$, where $h_{\\perp} = \\sqrt{(h_x \\sin\\theta)^2 + (h_y \\cos\\theta)^2}$ and $\\alpha_{\\perp}$ is toggled per test; set $\\alpha_{\\perp}=0$ when off and $\\alpha_{\\perp}=0.05$ when on.\n\nDefine four test cases to compare methods and the effect of crosswind diffusion:\n- Test 1: SUPG stabilization, crosswind diffusion off ($\\alpha_{\\perp}=0$).\n- Test 2: GLS stabilization, crosswind diffusion off ($\\alpha_{\\perp}=0$).\n- Test 3: SUPG stabilization, crosswind diffusion on ($\\alpha_{\\perp}=0.05$).\n- Test 4: GLS stabilization, crosswind diffusion on ($\\alpha_{\\perp}=0.05$).\n\nYour program should produce a single line of output containing the results for these four tests as a comma-separated list enclosed in square brackets. For each test, output two floats: first the crosswind gradient index $I_{\\perp}$, and second the overshoot/undershoot amplitude $A_{\\mathrm{osc}}$. The final output format must be\n$$ [I_{\\perp}^{(1)},A_{\\mathrm{osc}}^{(1)},I_{\\perp}^{(2)},A_{\\mathrm{osc}}^{(2)},I_{\\perp}^{(3)},A_{\\mathrm{osc}}^{(3)},I_{\\perp}^{(4)},A_{\\mathrm{osc}}^{(4)}], $$\nwhere the superscript indicates the test number in the order listed above. All floating-point numbers should be printed in standard decimal notation.", "solution": "The user wants to solve a stationary advection-diffusion problem and compare different finite element stabilization techniques. The solution will be implemented using Python and the NumPy library.\n\n### 1. Problem Formulation and Discretization\n\nThe governing equation is the stationary linear advection-diffusion equation on the unit square $\\Omega = [0,1]^2$:\n$$ \\boldsymbol{b}\\cdot\\nabla u - \\varepsilon \\Delta u = 0 $$\nwhere $\\boldsymbol{b}$ is a constant advection velocity, and $\\varepsilon > 0$ is a small diffusion coefficient. This setup models a transport process where advection dominates diffusion. Boundary conditions are $u=1$ on the inflow boundary (where $\\boldsymbol{b}\\cdot\\boldsymbol{n} < 0$, with $\\boldsymbol{n}$ being the outward normal) and $u=0$ on the outflow boundary ($\\boldsymbol{b}\\cdot\\boldsymbol{n} \\ge 0$).\n\nThe standard Galerkin Finite Element Method (FEM) is applied for discretization. Multiplying the PDE by a test function $v \\in H^1_0(\\Omega)$ and integrating by parts on the diffusion term gives the weak form: find $u \\in H^1(\\Omega)$ such that $u$ satisfies the essential boundary conditions and\n$$ a(u,v) = \\int_{\\Omega} (\\boldsymbol{b}\\cdot \\nabla u) v \\, d\\Omega + \\int_{\\Omega} \\varepsilon \\nabla u \\cdot \\nabla v \\, d\\Omega = 0 \\quad \\forall v \\in H^1_0(\\Omega). $$\nFor advection-dominated problems (small $\\varepsilon$), the standard Galerkin method is known to produce non-physical, spurious oscillations in the numerical solution. This necessitates the use of stabilization techniques.\n\nThe domain is discretized using a structured mesh of $N_x \\times N_y$ rectangular elements, and the solution is approximated using continuous quadratic ($Q_2$) Lagrange basis functions. Each rectangular element has $9$ nodes.\n\n### 2. Stabilization Methods\n\nTwo stabilization methods are considered: Streamline Upwind/Petrov-Galerkin (SUPG) and Galerkin/Least-Squares (GLS). Both methods add terms to the weak form that act along the streamline direction to counteract the instabilities.\n\n**SUPG Stabilization:**\nThe SUPG method modifies the test function to be $v + \\tau_e \\boldsymbol{b}\\cdot\\nabla v$. In the context of modifying the bilinear form, this is equivalent to adding the term:\n$$ s_{\\mathrm{SUPG}}(u,v) = \\sum_{e} \\int_{\\Omega_e} \\tau_e \\, (\\boldsymbol{b}\\cdot \\nabla u)\\, (\\boldsymbol{b}\\cdot \\nabla v) \\, d\\Omega $$\nThis term introduces artificial diffusion purely in the direction of the flow (the streamline direction), damping oscillations that form along streamlines.\n\n**GLS Stabilization:**\nThe GLS method is more comprehensive and adds a term proportional to the PDE's residual, applied to both the trial and test functions. The added term is:\n$$ s_{\\mathrm{GLS}}(u,v) = \\sum_{e} \\int_{\\Omega_e} \\tau_e \\, r(u)\\, r(v)\\, d\\Omega, \\quad \\text{where } r(w) := \\boldsymbol{b}\\cdot \\nabla w - \\varepsilon \\Delta w. $$\nSince the residual $r(u)$ is zero for the exact solution, this method is consistent. When expanded, the GLS term contains the SUPG term plus additional terms involving the Laplacian, providing more stability.\n\nThe stabilization parameter $\\tau_e$ is crucial and is defined based on the element size and local Péclet number, $\\mathrm{Pe} = \\|\\boldsymbol{b}\\| h_{\\parallel} / (2\\varepsilon)$, where $h_\\parallel$ is the effective mesh size along the streamline. The provided formula is a standard choice that provides optimal stability.\n\n### 3. Crosswind Diffusion\n\nWhile SUPG and GLS effectively handle oscillations along streamlines, they do not address oscillations that can occur in the crosswind direction, particularly near sharp gradients or internal layers. To mitigate this, artificial crosswind diffusion is introduced. This is achieved by adding a diffusion term that acts only in the direction orthogonal to the flow. The term is:\n$$ d_{\\perp}(u,v) = \\int_{\\Omega} \\mu_{\\perp}\\, (\\nabla u)^\\top \\mathbf{P}_{\\perp}\\, \\nabla v \\, d\\Omega. $$\nHere, $\\mathbf{P}_{\\perp} = \\mathbf{I} - \\widehat{\\boldsymbol{b}}\\, \\widehat{\\boldsymbol{b}}^\\top$ is the projection matrix onto the subspace orthogonal to the normalized flow direction $\\widehat{\\boldsymbol{b}}$. The coefficient $\\mu_{\\perp}$ controls the amount of added diffusion.\n\n### 4. Implementation Strategy\n\nThe solution is implemented by constructing a finite element solver that can handle the specified variations.\n\n- **Element-wise Computation:** The core of the solver is a loop over all elements in the mesh. For each element, a $9 \\times 9$ local stiffness matrix is computed.\n- **Numerical Integration:** Integrals over the element are approximated using a $3 \\times 3$ Gaussian quadrature rule on the reference square $[-1,1]^2$. This is sufficient to exactly integrate the resulting polynomials.\n- **Basis Functions:** At each quadrature point, the values of the $9$ quadratic basis functions $N_i$ and their gradients $\\nabla N_i$ and Laplacians $\\Delta N_i$ are computed using the provided formulas and the chain rule for the affine element mapping.\n- **Matrix Assembly:** For each pair of trial function $N_j$ and test function $N_i$, the integrand of the full weak form (including stabilization and crosswind terms) is evaluated at the quadrature point and multiplied by the quadrature weight and Jacobian determinant. This value is added to the local stiffness matrix. The local matrices are then assembled into a global system matrix $K$.\n- **Boundary Conditions:** Essential (Dirichlet) boundary conditions are enforced strongly. The global system of equations $KU=F$ is partitioned into known (Dirichlet) and unknown (interior) degrees of freedom. A reduced system is solved for the interior nodes, and the full solution vector is then reconstructed.\n- **Solving:** The resulting linear system is non-symmetric and is solved using a direct solver, `numpy.linalg.solve`.\n\n### 5. Evaluation Metrics\n\nAfter obtaining the discrete solution vector $U$, two metrics are computed to quantify the performance of each method.\n\n1.  **Crosswind Gradient Index ($I_{\\perp}$):** This metric measures the proportion of the solution's gradient energy that is oriented perpendicular to the flow direction. A high value indicates significant crosswind oscillations or smearing. It is computed as the ratio of two $L^2$ norms, evaluated using the same Gaussian quadrature scheme:\n    $$ I_{\\perp} = \\frac{\\int_{\\Omega} \\|\\mathbf{P}_{\\perp} \\nabla u_h \\|^2 \\, d\\Omega}{\\int_{\\Omega} \\|\\nabla u_h\\|^2 \\, d\\Omega} $$\n2.  **Overshoot/Undershoot Amplitude ($A_{\\mathrm{osc}}$):** This metric quantifies the violation of the discrete maximum principle. The exact solution is bounded by its boundary values, $[0, 1]$. The numerical solution may exhibit non-physical oscillations, with values greater than $1$ (overshoots) or less than $0$ (undershoots). This metric sums the magnitudes of the largest overshoot and undershoot found at any interior node:\n    $$ A_{\\mathrm{osc}} = \\max\\{0, \\max_{\\Omega^\\circ} u_h - 1\\} + \\max\\{0, -\\min_{\\Omega^\\circ} u_h\\} $$\n\nBy computing these metrics for the four specified test cases (SUPG vs GLS, with and without crosswind diffusion), a quantitative comparison of the methods' effectiveness in mitigating numerical oscillations is achieved.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the four test cases and print the results.\n    \"\"\"\n\n    def coth(x):\n        \"\"\"Hyperbolic cotangent, with guards for large arguments.\"\"\"\n        # For large |x|, coth(x) approaches +/-1.\n        # This avoids overflow/underflow issues in np.exp.\n        if x > 50:\n            return 1.0\n        if x < -50:\n            return -1.0\n        return np.cosh(x) / np.sinh(x)\n\n    def run_fem_solver(stabilization, alpha_perp):\n        \"\"\"\n        Solves the advection-diffusion problem for a given stabilization method\n        and crosswind diffusion parameter.\n        \"\"\"\n        # --- 1. Define Parameters ---\n        # Fixed parameters from problem statement\n        Nx, Ny = 18, 6\n        theta_deg = 33.0\n        epsilon = 1e-4\n\n        # Derived parameters\n        hx, hy = 1.0 / Nx, 1.0 / Ny\n        theta_rad = np.deg2rad(theta_deg)\n        b = np.array([np.cos(theta_rad), np.sin(theta_rad)])\n        b_norm = np.linalg.norm(b)\n        b_hat = b / b_norm\n\n        # Mesh-dependent lengths for stabilization parameters\n        h_parallel = np.sqrt((hx * np.cos(theta_rad))**2 + (hy * np.sin(theta_rad))**2)\n        h_perp = np.sqrt((hx * np.sin(theta_rad))**2 + (hy * np.cos(theta_rad))**2)\n        \n        # Péclet number and stabilization parameter tau\n        Pe = b_norm * h_parallel / (2.0 * epsilon)\n        if np.abs(Pe) < 1e-6:\n            coth_pe_minus_1_pe = Pe / 3.0\n        else:\n            coth_pe_minus_1_pe = coth(Pe) - 1.0 / Pe\n        tau = (h_parallel / (2.0 * b_norm)) * coth_pe_minus_1_pe\n        \n        # Crosswind diffusion coefficient\n        mu_perp = alpha_perp * b_norm * h_perp\n\n        # --- 2. FEM Discretization Setup ---\n        num_nodes_x = 2 * Nx + 1\n        num_nodes_y = 2 * Ny + 1\n        total_nodes = num_nodes_x * num_nodes_y\n\n        # 1D Q2 Lagrange basis functions and their derivatives\n        def l_vals(xi): return np.array([0.5 * xi * (xi - 1), 1 - xi**2, 0.5 * xi * (xi + 1)])\n        def l_derivs(xi): return np.array([xi - 0.5, -2 * xi, xi + 0.5])\n        def l_derivs2(xi): return np.array([1.0, -2.0, 1.0])\n\n        # 3-point Gaussian quadrature nodes and weights\n        gp_loc = np.array([-np.sqrt(3.0/5.0), 0.0, np.sqrt(3.0/5.0)])\n        gp_w = np.array([5.0/9.0, 8.0/9.0, 5.0/9.0])\n        \n        K = np.zeros((total_nodes, total_nodes))\n\n        # --- 3. Assemble Global Stiffness Matrix K ---\n        for ey in range(Ny):\n            for ex in range(Nx):\n                Ke = np.zeros((9, 9))\n                \n                # Element-to-global node mapping\n                local_to_global = np.array(\n                    [ (2*ey+dy) * num_nodes_x + (2*ex+dx) \n                      for dy in range(3) for dx in range(3) ], dtype=int\n                )\n\n                # Loop over Gauss points for numerical integration\n                d_vol_factor = (hx / 2.0) * (hy / 2.0)\n                for i_eta, eta in enumerate(gp_loc):\n                    for i_xi, xi in enumerate(gp_loc):\n                        weight = gp_w[i_eta] * gp_w[i_xi]\n                        d_vol = d_vol_factor * weight\n\n                        # Evaluate 1D basis functions at the current Gauss point\n                        vals_xi, d_vals_xi, d2_vals_xi = l_vals(xi), l_derivs(xi), l_derivs2(xi)\n                        vals_eta, d_vals_eta, d2_vals_eta = l_vals(eta), l_derivs(eta), l_derivs2(eta)\n                        \n                        N, grad_N, lap_N = np.zeros(9), np.zeros((9, 2)), np.zeros(9)\n                        for k in range(9):\n                            k_xi, k_eta = k % 3, k // 3\n                            N[k] = vals_xi[k_xi] * vals_eta[k_eta]\n                            grad_N[k, 0] = d_vals_xi[k_xi] * vals_eta[k_eta] * (2 / hx)\n                            grad_N[k, 1] = vals_xi[k_xi] * d_vals_eta[k_eta] * (2 / hy)\n                            lap_N[k] = (d2_vals_xi[k_xi] * vals_eta[k_eta] * (2 / hx)**2 +\n                                        vals_xi[k_xi] * d2_vals_eta[k_eta] * (2 / hy)**2)\n\n                        # Compute contributions to element stiffness matrix Ke\n                        for i in range(9):  # Test function index\n                            for j in range(9):  # Trial function index\n                                term_diff = epsilon * np.dot(grad_N[j], grad_N[i])\n                                term_adv = np.dot(b, grad_N[j]) * N[i]\n                                integrand = term_diff + term_adv\n                                \n                                if stabilization == 'SUPG':\n                                    term_supg = tau * np.dot(b, grad_N[j]) * np.dot(b, grad_N[i])\n                                    integrand += term_supg\n                                elif stabilization == 'GLS':\n                                    res_j = np.dot(b, grad_N[j]) - epsilon * lap_N[j]\n                                    res_i = np.dot(b, grad_N[i]) - epsilon * lap_N[i]\n                                    term_gls = tau * res_j * res_i\n                                    integrand += term_gls\n\n                                if alpha_perp > 0:\n                                    P_perp_g_j = grad_N[j] - np.dot(grad_N[j], b_hat) * b_hat\n                                    term_crosswind = mu_perp * np.dot(P_perp_g_j, grad_N[i])\n                                    integrand += term_crosswind\n                                \n                                Ke[i, j] += integrand * d_vol\n                \n                # Assemble local matrix into global matrix\n                K[np.ix_(local_to_global, local_to_global)] += Ke\n\n        # --- 4. Apply Boundary Conditions and Solve ---\n        dirichlet_dofs, interior_dofs = [], []\n        U = np.zeros(total_nodes)\n        for iy in range(num_nodes_y):\n            for ix in range(num_nodes_x):\n                g_idx = iy * num_nodes_x + ix\n                if ix == 0 or iy == 0:  # Inflow boundaries\n                    U[g_idx] = 1.0\n                    dirichlet_dofs.append(g_idx)\n                elif ix == num_nodes_x - 1 or iy == num_nodes_y - 1:  # Outflow boundaries\n                    U[g_idx] = 0.0\n                    dirichlet_dofs.append(g_idx)\n                else:\n                    interior_dofs.append(g_idx)\n        \n        F_interior = -K[np.ix_(interior_dofs, dirichlet_dofs)] @ U[dirichlet_dofs]\n        K_interior = K[np.ix_(interior_dofs, interior_dofs)]\n        \n        U_interior = np.linalg.solve(K_interior, F_interior)\n        U[interior_dofs] = U_interior\n\n        # --- 5. Post-Processing: Compute Metrics ---\n        # Metric 1: Crosswind Gradient Index (I_perp)\n        num_integral, den_integral = 0.0, 0.0\n        for ey in range(Ny):\n            for ex in range(Nx):\n                local_to_global = np.array(\n                    [ (2*ey+dy) * num_nodes_x + (2*ex+dx)\n                      for dy in range(3) for dx in range(3) ], dtype=int\n                )\n                U_local = U[local_to_global]\n\n                d_vol_factor = (hx / 2.0) * (hy / 2.0)\n                for i_eta, eta in enumerate(gp_loc):\n                    for i_xi, xi in enumerate(gp_loc):\n                        weight = gp_w[i_eta] * gp_w[i_xi]\n                        d_vol = d_vol_factor * weight\n                        \n                        vals_xi, d_vals_xi = l_vals(xi), l_derivs(xi)\n                        vals_eta, d_vals_eta = l_vals(eta), l_derivs(eta)\n                        \n                        grad_u = np.zeros(2)\n                        for k in range(9):\n                            k_xi, k_eta = k % 3, k // 3\n                            grad_u[0] += U_local[k] * (d_vals_xi[k_xi] * vals_eta[k_eta] * (2 / hx))\n                            grad_u[1] += U_local[k] * (vals_xi[k_xi] * d_vals_eta[k_eta] * (2 / hy))\n                        \n                        P_perp_grad_u = grad_u - np.dot(grad_u, b_hat) * b_hat\n                        num_integral += np.dot(P_perp_grad_u, P_perp_grad_u) * d_vol\n                        den_integral += np.dot(grad_u, grad_u) * d_vol\n        \n        I_perp = num_integral / den_integral if den_integral > 1e-12 else 0.0\n\n        # Metric 2: Overshoot/Undershoot Amplitude (A_osc)\n        U_interior_only = U[interior_dofs]\n        max_u = np.max(U_interior_only) if U_interior_only.size > 0 else 0.0\n        min_u = np.min(U_interior_only) if U_interior_only.size > 0 else 0.0\n        A_osc = max(0, max_u - 1.0) + max(0, -min_u)\n\n        return I_perp, A_osc\n\n    # Define test cases\n    test_cases = [\n        {'stabilization': 'SUPG', 'alpha_perp': 0.0},\n        {'stabilization': 'GLS', 'alpha_perp': 0.0},\n        {'stabilization': 'SUPG', 'alpha_perp': 0.05},\n        {'stabilization': 'GLS', 'alpha_perp': 0.05}\n    ]\n\n    results = []\n    for case in test_cases:\n        I_perp, A_osc = run_fem_solver(case['stabilization'], case['alpha_perp'])\n        results.extend([I_perp, A_osc])\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3447460"}, {"introduction": "Stabilization methods do more than just improve the physical fidelity of the numerical solution; they fundamentally alter the algebraic properties of the linear system $A\\mathbf{x}=\\mathbf{f}$ that must be solved. This final practice [@problem_id:3447450] investigates these important consequences, connecting the choice of stabilization parameter to the structure and spectral properties of the system matrix $A$. By analyzing the matrix's field-of-values, you will learn to derive theoretical bounds on the convergence rate of iterative methods like GMRES, gaining crucial insight into the trade-offs between accuracy, stability, and computational cost.", "problem": "Consider the steady one-dimensional advection-diffusion model problem on the unit interval with homogeneous Dirichlet boundary conditions: find $u$ such that for all admissible test functions $v$,\n$$ -\\epsilon\\,u''(x) + b\\,u'(x) = f(x)\\quad \\text{for } x\\in(0,1),\\qquad u(0)=u(1)=0,$$\nwhere $\\epsilon>0$ is the diffusion coefficient, $b\\in\\mathbb{R}$ is a constant advection velocity, and $f$ is a given source. In this task, you will analyze the discrete operator alone (no right-hand side is required), within the framework of the stabilized finite element method, and relate its field-of-values to a prediction of Generalized Minimal Residual method (GMRES) convergence.\n\nYou will use continuous, piecewise-linear finite elements on a uniform mesh with $N$ elements on $[0,1]$, mesh size $h=1/N$, and you will apply Streamline-Upwind Petrov-Galerkin (SUPG) stabilization with elementwise parameter $\\tau\\ge 0$. The element Péclet number is defined by\n$$ Pe_h = \\frac{|b|\\,h}{2\\,\\epsilon}. $$\n\nStarting from the standard Galerkin weak form and the definition of the SUPG method, derive the stabilized bilinear form appropriate for this $1$-D setting, and from it derive the assembled stabilized discrete operator matrix $A\\in\\mathbb{R}^{n\\times n}$ acting on the interior degrees of freedom ($n=N-1$) after strongly enforcing $u(0)=u(1)=0$. The analysis should be based only on fundamental definitions of the Galerkin method, the SUPG modification, and the numerical range (field-of-values). Do not assume any shortcut formula that is not derived from these principles.\n\nDefine the field-of-values (numerical range) of a matrix $A$ in the Euclidean inner product by\n$$ W(A) = \\left\\{ \\frac{x^\\ast A x}{x^\\ast x} \\;:\\; x\\in\\mathbb{C}^n\\setminus\\{0\\} \\right\\}. $$\nExplain how to compute the minimum and maximum of $\\operatorname{Re}(z)$ over $z\\in W(A)$ using only the symmetric part of $A$. Using a rigorous field-of-values-based GMRES estimate in terms of the symmetric part and the operator $2$-norm, derive a computable upper bound on the per-iteration residual contraction factor for GMRES without preconditioning applied to $A$, and from it a guaranteed iteration count to reduce the residual norm by a factor $\\text{tol}=10^{-8}$.\n\nYour program must:\n- Assemble $A$ for given $N$, $b$, $\\epsilon$, and $\\tau$ using continuous, piecewise-linear elements on a uniform mesh on $[0,1]$ with homogeneous Dirichlet boundary conditions enforced by row/column elimination of boundary nodes. Use the standard Galerkin advection-diffusion form and add the SUPG streamline-diffusion stabilization appropriate for the $1$-D case.\n- Compute the symmetric part $H=(A+A^\\top)/2$, the smallest eigenvalue of $H$, and the spectral norm $\\|A\\|_2$.\n- From these, compute a rigorous field-of-values-based upper bound on the GMRES per-iteration contraction factor $q\\in(0,1)$ and the smallest integer $k$ such that the bound guarantees a residual reduction by a factor of at least $\\text{tol}=10^{-8}$ after $k$ iterations.\n- For each test case, output the pair $[q,k]$ where $q$ is rounded to six decimal places and $k$ is an integer.\n\nUse the following test suite, which varies the element Péclet number $Pe_h$ and the stabilization parameter $\\tau$ to probe diffusion-dominated, moderately advective, and advection-dominated regimes with and without stabilization. In all cases, take $b=1$, $N=100$ (so $h=0.01$), and homogeneous Dirichlet boundary conditions:\n- Test $1$: $\\epsilon=0.05$ (so $Pe_h=0.1$), $\\tau=0$.\n- Test $2$: $\\epsilon=0.005$ (so $Pe_h=1$), $\\tau=0$.\n- Test $3$: $\\epsilon=0.0005$ (so $Pe_h=10$), $\\tau=0$.\n- Test $4$: $\\epsilon=0.0005$ (so $Pe_h=10$), $\\tau=h/(2b)$.\n- Test $5$: $\\epsilon=0.0005$ (so $Pe_h=10$), $\\tau=h/b$.\n\nAll parameters are non-dimensional for this exercise, and no physical units must be reported. Angles are not involved. Percentages are not involved.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each result is a two-element list $[q,k]$ for the corresponding test case in the order listed above. For example, the output format must be like\n$[[q_1,k_1],[q_2,k_2],[q_3,k_3],[q_4,k_4],[q_5,k_5]]$\nwith $q_i$ printed rounded to six decimals and $k_i$ as an integer.", "solution": "The problem statement is valid as it presents a well-posed problem in numerical analysis, grounded in established scientific principles of the finite element method and iterative linear algebra. All parameters and conditions are clearly defined.\n\nThe analysis begins with the steady one-dimensional advection-diffusion equation on the domain $\\Omega = (0,1)$:\n$$ -\\epsilon\\,u''(x) + b\\,u'(x) = f(x) $$\nwith homogeneous Dirichlet boundary conditions $u(0)=u(1)=0$. The parameter $\\epsilon>0$ is the diffusion coefficient and $b\\in\\mathbb{R}$ is the constant advection velocity.\n\nTo derive the weak formulation, we multiply the equation by an admissible test function $v$ from the Sobolev space $H_0^1(0,1) = \\{ v \\in L^2(0,1) \\,:\\, v' \\in L^2(0,1), v(0)=v(1)=0 \\}$ and integrate over the domain $\\Omega$.\n$$ \\int_0^1 \\left( -\\epsilon\\,u''(x) + b\\,u'(x) \\right) v(x) \\,dx = \\int_0^1 f(x) v(x) \\,dx $$\nApplying integration by parts to the diffusion term gives:\n$$ \\int_0^1 \\epsilon\\,u'(x) v'(x) \\,dx - \\left[ \\epsilon\\,u'(x) v(x) \\right]_0^1 + \\int_0^1 b\\,u'(x) v(x) \\,dx = \\int_0^1 f(x) v(x) \\,dx $$\nSince $v \\in H_0^1(0,1)$, the boundary term vanishes, i.e., $v(0)=v(1)=0$. The standard Galerkin weak form is to find $u \\in H_0^1(0,1)$ such that for all $v \\in H_0^1(0,1)$:\n$$ \\mathcal{B}_G(u,v) = \\mathcal{L}(v) $$\nwhere the bilinear form $\\mathcal{B}_G(u,v)$ and linear form $\\mathcal{L}(v)$ are defined as:\n$$ \\mathcal{B}_G(u,v) = \\int_0^1 \\left( \\epsilon\\,u'(x) v'(x) + b\\,u'(x) v(x) \\right) \\,dx $$\n$$ \\mathcal{L}(v) = \\int_0^1 f(x) v(x) \\,dx $$\n\nFor the finite element discretization, we introduce a uniform mesh of the interval $[0,1]$ with $N$ elements of size $h=1/N$. The nodes are $x_i = i h$ for $i=0, 1, \\dots, N$. We use the space of continuous, piecewise-linear functions, $V_h$, for both trial and test functions. To enforce the homogeneous boundary conditions, we consider basis functions $\\phi_i$ for $i=1, \\dots, N-1$, where $\\phi_i$ is the standard \"hat\" function with $\\phi_i(x_j) = \\delta_{ij}$. An approximate solution $u_h \\in V_h$ is written as $u_h(x) = \\sum_{j=1}^{N-1} U_j \\phi_j(x)$.\n\nThe Streamline-Upwind Petrov-Galerkin (SUPG) method addresses instabilities in advection-dominated problems by modifying the test functions. The test function $v_h \\in V_h$ is replaced by a perturbed test function $\\hat{v}_h = v_h + \\tau b v_h'$, where $\\tau \\ge 0$ is a stabilization parameter. The stabilization is applied element-wise to the strong form residual, $r(u_h) = -\\epsilon u_h'' + b u_h' - f$. The stabilized weak form is $\\mathcal{B}_G(u_h,v_h) + \\mathcal{B}_{stab}(u_h,v_h) = \\mathcal{L}_G(v_h) + \\mathcal{L}_{stab}(v_h)$, where the stabilization term added to the bilinear form is derived from applying the perturbed test function to the residual. For the bilinear form, this becomes:\n$$ \\sum_{e=1}^N \\int_{\\Omega_e} (-\\epsilon u_h'' + b u_h') (\\tau b v_h') \\,dx $$\nFor piecewise-linear elements, the second derivative $u_h''$ is zero inside each element $\\Omega_e$. Thus, the stabilization term added to the bilinear form simplifies to:\n$$ \\mathcal{B}_{stab}(u_h,v_h) = \\sum_{e=1}^N \\int_{\\Omega_e} (b u_h') (\\tau b v_h') \\,dx = \\int_0^1 \\tau b^2 u_h' v_h' \\,dx $$\nThe complete stabilized bilinear form, from which the operator matrix $A$ is derived, is therefore:\n$$ \\mathcal{B}_{SUPG}(u,v) = \\mathcal{B}_G(u,v) + \\mathcal{B}_{stab}(u,v) = \\int_0^1 \\left( \\epsilon u'v' + b u'v \\right) \\,dx + \\int_0^1 \\tau b^2 u'v' \\,dx $$\n$$ \\mathcal{B}_{SUPG}(u,v) = \\int_0^1 \\left( (\\epsilon + \\tau b^2) u'v' + b u'v \\right) \\,dx $$\nThe discrete system $A \\mathbf{U} = \\mathbf{F}$ is obtained with $A_{ij} = \\mathcal{B}_{SUPG}(\\phi_j, \\phi_i)$.\n\nTo compute the entries of the matrix $A$, we evaluate the integrals on a generic element $\\Omega_e = [x_{k-1}, x_k]$ of length $h$. The local basis functions (in local coordinates $\\xi \\in [0,h]$) are $\\psi_1(\\xi) = 1-\\xi/h$ and $\\psi_2(\\xi) = \\xi/h$. Their derivatives are $\\psi_1'(\\xi)=-1/h$ and $\\psi_2'(\\xi)=1/h$.\nThe element stiffness matrix $K^e$ (from diffusion) and advection matrix $C^e$ are:\n$$ K^e_{ij} = \\int_0^h \\psi_j' \\psi_i' d\\xi \\implies K^e = \\frac{1}{h} \\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix} $$\n$$ C^e_{ij} = \\int_0^h \\psi_j' \\psi_i d\\xi \\implies C^e = \\frac{1}{2} \\begin{pmatrix} -1 & 1 \\\\ -1 & 1 \\end{pmatrix} $$\nThe element matrix for the stabilized problem is $A^e = (\\epsilon + \\tau b^2) K^e + b C^e$:\n$$ A^e = \\frac{\\epsilon + \\tau b^2}{h} \\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix} + \\frac{b}{2} \\begin{pmatrix} -1 & 1 \\\\ -1 & 1 \\end{pmatrix} $$\nAssembling these element matrices for the $n=N-1$ interior degrees of freedom yields a tridiagonal matrix $A$. The entries for row $i$ are determined by contributions from elements $[x_{i-1}, x_i]$ and $[x_i, x_{i+1}]$:\n- Diagonal entry $A_{i,i}$: Sum of $A^e_{2,2}$ from left element and $A^e_{1,1}$ from right element.\n  $A_{i,i} = \\left(\\frac{\\epsilon + \\tau b^2}{h} + \\frac{b}{2}\\right) + \\left(\\frac{\\epsilon + \\tau b^2}{h} - \\frac{b}{2}\\right) = \\frac{2(\\epsilon + \\tau b^2)}{h}$.\n- Sub-diagonal entry $A_{i,i-1}$: From $A^e_{2,1}$ of the left element.\n  $A_{i,i-1} = -\\frac{\\epsilon + \\tau b^2}{h} - \\frac{b}{2}$.\n- Super-diagonal entry $A_{i,i+1}$: From $A^e_{1,2}$ of the right element.\n  $A_{i,i+1} = -\\frac{\\epsilon + \\tau b^2}{h} + \\frac{b}{2}$.\n\nThe convergence of the GMRES method for solving $A\\mathbf{x}=\\mathbf{b}$ is related to the field-of-values (or numerical range) of $A$, defined as $W(A) = \\{ z \\in \\mathbb{C} \\,:\\, z = x^*Ax / (x^*x) \\text{ for some } x \\in \\mathbb{C}^n \\setminus \\{0\\}\\}$. The real part of any $z \\in W(A)$ is given by $\\operatorname{Re}(z) = x^* H x / (x^*x)$, where $H = (A+A^\\top)/2$ is the symmetric part of $A$ (since $A$ is real, $A^*=A^\\top$). The set of all such values for $x \\in \\mathbb{C}^n$ is the interval $[\\lambda_{\\min}(H), \\lambda_{\\max}(H)]$ by the Rayleigh-Ritz theorem. Thus, the minimum and maximum of $\\operatorname{Re}(z)$ over $W(A)$ are precisely the minimum and maximum eigenvalues of $H$.\n$$ \\min_{z\\in W(A)} \\operatorname{Re}(z) = \\lambda_{\\min}(H) $$\nA standard GMRES convergence estimate for a matrix $A$ with a positive definite symmetric part ($\\lambda_{\\min}(H) > 0$) provides an upper bound on the relative residual norm after $k$ iterations:\n$$ \\frac{\\|r_k\\|_2}{\\|r_0\\|_2} \\le q^k \\quad \\text{where} \\quad q = \\sqrt{1 - \\left(\\frac{\\lambda_{\\min}(H)}{\\|A\\|_2}\\right)^2} $$\nHere, $\\|A\\|_2$ is the spectral norm of $A$ (its largest singular value). The quantity $q \\in [0,1)$ is an upper bound on the per-iteration residual contraction factor.\n\nTo find the number of iterations $k$ required to guarantee a residual reduction by a factor of $\\text{tol} = 10^{-8}$, we solve the inequality $q^k \\le \\text{tol}$:\n$$ k \\ln(q) \\le \\ln(\\text{tol}) $$\nSince $q<1$, $\\ln(q)$ is negative. Dividing by it reverses the inequality:\n$$ k \\ge \\frac{\\ln(\\text{tol})}{\\ln(q)} $$\nAs $k$ must be an integer, we take the ceiling of this value:\n$$ k = \\left\\lceil \\frac{\\ln(10^{-8})}{\\ln(q)} \\right\\rceil $$\nThis provides the guaranteed iteration count based on the field-of-values estimate. The program will compute $A$, $H$, $\\lambda_{\\min}(H)$, and $\\|A\\|_2$ to find $q$ and $k$ for each test case. For our matrix $A$, the symmetric part $H$ is a symmetric tridiagonal matrix with diagonal entries $\\frac{2(\\epsilon + \\tau b^2)}{h}$ and off-diagonal entries $-\\frac{\\epsilon + \\tau b^2}{h}$. This corresponds to a standard finite element discretization of the operator $-(\\epsilon+\\tau b^2) \\frac{d^2}{dx^2}$ with homogeneous Dirichlet conditions, which is symmetric positive definite. Therefore, $\\lambda_{\\min}(H) > 0$ and the convergence estimate is applicable.", "answer": "```python\nimport numpy as np\nimport math\n\ndef assemble_and_analyze(N, b, epsilon, tau):\n    \"\"\"\n    Assembles the stabilized FEM matrix and computes GMRES convergence estimates.\n\n    Args:\n        N (int): Number of elements.\n        b (float): Advection velocity.\n        epsilon (float): Diffusion coefficient.\n        tau (float): SUPG stabilization parameter.\n\n    Returns:\n        list: A two-element list containing the GMRES contraction factor bound q\n              and the estimated number of iterations k.\n    \"\"\"\n    # System size for interior nodes\n    n = N - 1\n    # Mesh size\n    h = 1.0 / N\n    # Residual reduction tolerance\n    tol = 1e-8\n\n    # Coefficients for the tridiagonal matrix A, based on the derived formulas\n    # d: main diagonal, l: sub-diagonal, u: super-diagonal\n    d = 2.0 * (epsilon + tau * b**2) / h\n    l = -(epsilon + tau * b**2) / h - b / 2.0\n    u = -(epsilon + tau * b**2) / h + b / 2.0\n\n    # Assemble the (n x n) tridiagonal matrix A\n    main_diag = np.full(n, d)\n    sub_diag = np.full(n - 1, l)\n    sup_diag = np.full(n - 1, u)\n    \n    A = np.diag(main_diag) + np.diag(sub_diag, k=-1) + np.diag(sup_diag, k=1)\n\n    # Compute the symmetric part H = (A + A^T) / 2\n    H = (A + A.T) / 2.0\n    \n    # Compute the smallest eigenvalue of H.\n    # eigvalsh is efficient for real symmetric/Hermitian matrices and returns sorted eigenvalues.\n    eigenvalues_H = np.linalg.eigvalsh(H)\n    lambda_min_H = eigenvalues_H[0]\n\n    # Compute the spectral norm (2-norm) of A.\n    norm_A_2 = np.linalg.norm(A, ord=2)\n\n    # The convergence estimate is valid if lambda_min(H) > 0.\n    # For this problem, H is positive definite, so this holds.\n    if lambda_min_H <= 0 or norm_A_2 == 0:\n        return [float('inf'), float('inf')]\n\n    # Compute the GMRES contraction factor bound q.\n    ratio = lambda_min_H / norm_A_2\n    \n    # This term inside sqrt should be in [0, 1]. Clamp to handle potential floating-point inaccuracies.\n    term = max(0.0, 1.0 - ratio**2)\n    q = math.sqrt(term)\n\n    # Compute the smallest integer iteration count k.\n    if q >= 1.0:\n        # If q >= 1, the bound does not guarantee convergence.\n        k = float('inf')\n    else:\n        # k >= log(tol) / log(q). Since k must be an integer, we take the ceiling.\n        k = math.ceil(math.log(tol) / math.log(q))\n\n    return [q, k]\n\ndef solve():\n    \"\"\"\n    Runs the analysis for the test suite defined in the problem statement\n    and prints the results in the required format.\n    \"\"\"\n    # Common parameters for all test cases\n    N_val = 100\n    b_val = 1.0\n    h_val = 1.0 / N_val\n\n    # Test cases defined in the problem description. Each is a tuple (epsilon, tau).\n    test_cases = [\n        # Test 1: Pe_h = 0.1, no stabilization\n        (0.05, 0.0),\n        # Test 2: Pe_h = 1, no stabilization\n        (0.005, 0.0),\n        # Test 3: Pe_h = 10, no stabilization\n        (0.0005, 0.0),\n        # Test 4: Pe_h = 10, SUPG stabilization tau = h/(2b)\n        (0.0005, h_val / (2.0 * b_val)),\n        # Test 5: Pe_h = 10, SUPG stabilization tau = h/b\n        (0.0005, h_val / b_val),\n    ]\n\n    all_results = []\n    for epsilon, tau in test_cases:\n        q, k = assemble_and_analyze(N_val, b_val, epsilon, tau)\n        all_results.append([q, int(k)])\n\n    # Format the results into the required string \"[[q1,k1],[q2,k2],...]\"\n    result_strings = []\n    for res in all_results:\n        q_val, k_val = res\n        # q is rounded to six decimal places, k is an integer.\n        result_strings.append(f\"[{q_val:.6f},{k_val}]\")\n\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```", "id": "3447450"}]}