{"hands_on_practices": [{"introduction": "Before deploying a numerical method to solve complex problems, one must first verify its correctness. The patch test is a fundamental procedure in finite element analysis for ensuring that an implementation is free of bugs and consistent. This practice [@problem_id:3364930] challenges you to implement a series of patch tests, where your code's ability to exactly reproduce a known linear polynomial solution is evaluated, thereby confirming that the core assembly of matrices and vectors is correct.", "problem": "Consider the two-dimensional Poisson equation on a polygonal domain with weak formulation: find a scalar field $u$ in the appropriate Sobolev space such that, for all test functions $v$, the identity $$\\int_{\\Omega} \\nabla u \\cdot \\nabla v \\, d\\Omega = \\int_{\\Omega} r \\, v \\, d\\Omega + \\int_{\\partial \\Omega} g \\, v \\, ds$$ holds. Here, $\\Omega$ is the domain, $\\partial \\Omega$ its boundary, $r$ a volumetric source term, and $g$ a prescribed normal flux on the boundary. In the case of Dirichlet boundary conditions, the space of test functions is restricted to vanish on $\\partial \\Omega$ and the boundary integral is omitted accordingly. Using the Finite Element Method (FEM) with linear Lagrange basis functions over triangular elements, the global linear system consists of a stiffness matrix $K$ and a load vector $b$, assembled from element contributions derived from the weak form.\n\nYour task is to implement in-situ verification via patch tests to detect assembly bugs by checking equilibrium constraints and nullspace properties precisely. The program must:\n- Assemble the global stiffness matrix $K$ and load vector $b$ for meshes obtained by triangulating the unit square $\\Omega = [0,1]^2$ into $N \\times N$ squares and splitting each square into two triangles, and then applying an affine mapping $F(\\mathbf{x}) = A \\mathbf{x} + \\mathbf{t}$ with a given matrix $A$ and vector $\\mathbf{t}$.\n- Use linear Lagrange basis functions (piecewise affine functions) on triangles.\n- Implement the load vector contributions for volumetric sources $r$ (domain integral) and Neumann boundary fluxes $g$ (boundary integral) when applicable.\n- Evaluate patch tests by substituting known polynomial solutions into the assembled discrete system and computing residuals and structural properties that must hold if the assembly is correct.\n\nFundamental base:\n- The weak form of the Poisson equation and the construction of discrete systems by testing against basis functions and integrating over elements are the starting point. Linearity and consistency properties of linear Lagrange elements under affine transformations must be respected.\n- The nullspace property for pure Neumann boundary conditions requires that the constant function lies in the kernel of $K$, implying $K \\mathbf{1} = \\mathbf{0}$.\n- Equilibrium constraints require the compatibility condition $\\int_{\\Omega} r \\, d\\Omega = \\int_{\\partial \\Omega} g \\, ds$ for solvability in the pure Neumann case. When $r = 0$ and $u$ is linear, this reduces to $\\int_{\\partial \\Omega} \\mathbf{n} \\cdot \\nabla u \\, ds = 0$ by the divergence theorem and the vanishing Laplacian of linear polynomials.\n\nImplement the following test suite as specified parameter sets. For each case, compute the designated property and produce a boolean indicating pass or fail under the stated tolerance. All computations are purely mathematical and dimensionless; no physical units are involved.\n\n- Case $1$ (Happy path, Dirichlet linear patch test):\n  - Mesh parameter: $N = 4$.\n  - Affine map: $$A = \\begin{bmatrix}1  0 \\\\ 0  1\\end{bmatrix}$$, $\\mathbf{t} = (0,0)$.\n  - Manufactured solution: $u(\\mathbf{x}) = a + b x + c y$ with $a = \\frac{1}{3}$, $b = \\frac{7}{10}$, $c = -\\frac{2}{5}$.\n  - Source term: $r(\\mathbf{x}) = -\\Delta u(\\mathbf{x}) = 0$.\n  - Boundary condition: homogeneous Dirichlet test space (no boundary flux term).\n  - Verification: compute the residual vector $r_{\\text{vec}} = K u - b$ and check the maximum absolute residual restricted to interior degrees of freedom is at most $\\epsilon = 10^{-12}$.\n\n- Case $2$ (Affine distortion, Dirichlet linear patch test):\n  - Mesh parameter: $N = 3$.\n  - Affine map: $$A = \\begin{bmatrix}1  \\frac{1}{5} \\\\ \\frac{1}{10}  \\frac{13}{10}\\end{bmatrix}$$, $\\mathbf{t} = (0,0)$.\n  - Manufactured solution: $u(\\mathbf{x}) = a + b x + c y$ with $a = \\frac{1}{3}$, $b = \\frac{7}{10}$, $c = -\\frac{2}{5}$.\n  - Source term: $r(\\mathbf{x}) = 0$.\n  - Boundary condition: homogeneous Dirichlet test space.\n  - Verification: as in Case $1$, check interior residual $\\leq \\epsilon$ with $\\epsilon = 10^{-12}$.\n\n- Case $3$ (Nullspace property, pure Neumann with constant solution):\n  - Mesh parameter: $N = 3$.\n  - Affine map: $$A = \\begin{bmatrix}1  0 \\\\ 0  1\\end{bmatrix}$$, $\\mathbf{t} = (0,0)$.\n  - Manufactured solution: $u(\\mathbf{x}) = a$ with $a = \\frac{5}{2}$.\n  - Source term: $r(\\mathbf{x}) = 0$.\n  - Boundary flux: $g(\\mathbf{x}) = 0$ on $\\partial \\Omega$.\n  - Verification: check both $K \\mathbf{1} = \\mathbf{0}$ and $K u = \\mathbf{0}$ to within tolerance $\\epsilon = 10^{-12}$ by verifying the maximum absolute entry of each vector is at most $\\epsilon$.\n\n- Case $4$ (Equilibrium constraint and patch test, pure Neumann with linear solution):\n  - Mesh parameter: $N = 4$.\n  - Affine map: $$A = \\begin{bmatrix}1  0 \\\\ 0  1\\end{bmatrix}$$, $\\mathbf{t} = (0,0)$.\n  - Manufactured solution: $u(\\mathbf{x}) = a + b x + c y$ with $a = 0$, $b = -\\frac{3}{5}$, $c = \\frac{3}{10}$.\n  - Source term: $r(\\mathbf{x}) = 0$.\n  - Boundary flux: $g(\\mathbf{x}) = \\mathbf{n} \\cdot \\nabla u(\\mathbf{x})$ on $\\partial \\Omega$, where $\\mathbf{n}$ is the outward unit normal. For a linear $u$, $\\nabla u$ is constant and the Neumann load is piecewise constant on boundary edges.\n  - Verification:\n    - Residual check: compute $r_{\\text{vec}} = K u - b$ and check the maximum absolute entry is at most $\\epsilon = 10^{-12}$.\n    - Equilibrium constraint: compute the scalar $\\sum_i b_i$ and check its absolute value is at most $\\epsilon = 10^{-12}$, which enforces discrete compatibility consistent with $\\int_{\\partial \\Omega} g \\, ds = 0$.\n\nAngle units are not applicable. No percentages are involved.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[result1,result2,result3,result4]$), where each resultk is a boolean indicating pass (True) or fail (False) for Case k.\n\nYour implementation must be self-contained and use only the Python language and the specified libraries. No user input or external files are permitted.", "solution": "The problem requires the implementation of a Finite Element Method (FEM) assembly process for the two-dimensional Poisson equation and its verification using a series of patch tests. A patch test is a fundamental procedure in computational mechanics to verify the correctness of a finite element implementation. It is based on the principle that the discrete model must be able to exactly reproduce a state of constant strain, which for P1 (linear Lagrange) elements, corresponds to reproducing any linear polynomial solution exactly.\n\nThe weak form of the Poisson equation is given as: find $u \\in H^1(\\Omega)$ such that for all test functions $v \\in V$,\n$$\na(u, v) = L(v)\n$$\nwhere the bilinear form $a(u,v)$ and the linear functional $L(v)$ are defined as:\n$$\na(u, v) = \\int_{\\Omega} \\nabla u \\cdot \\nabla v \\, d\\Omega\n$$\n$$\nL(v) = \\int_{\\Omega} r v \\, d\\Omega + \\int_{\\partial \\Omega} g v \\, ds\n$$\nHere, $\\Omega$ is the domain, $r$ is a volumetric source, and $g$ is a Neumann boundary flux. For Dirichlet boundary conditions, the test function space $V$ is typically $H^1_0(\\Omega)$, the space of functions in $H^1(\\Omega)$ that vanish on the boundary $\\partial \\Omega_D$, and the boundary integral over $\\partial \\Omega_D$ is omitted.\n\nIn the Finite Element Method, the solution $u$ is approximated by a function $u_h$ from a finite-dimensional space $V_h \\subset H^1(\\Omega)$, spanned by a set of basis functions $\\{\\phi_i\\}_{i=1}^{N_{nodes}}$:\n$$\nu_h(\\mathbf{x}) = \\sum_{j=1}^{N_{nodes}} u_j \\phi_j(\\mathbf{x})\n$$\nwhere $u_j$ are the unknown coefficients, representing the value of the solution at the mesh nodes. The weak form is then enforced for a discrete set of test functions, typically the basis functions themselves (the Galerkin method), i.e., $v = \\phi_i$ for $i=1, \\dots, N_{nodes}$. This leads to a system of linear equations $K \\mathbf{u} = \\mathbf{b}$, where $\\mathbf{u}$ is the vector of nodal values $\\{u_j\\}$.\n\nThe entries of the global stiffness matrix $K$ and load vector $\\mathbf{b}$ are given by:\n$$\nK_{ij} = a(\\phi_j, \\phi_i) = \\int_{\\Omega} \\nabla \\phi_j \\cdot \\nabla \\phi_i \\, d\\Omega\n$$\n$$\nb_i = L(\\phi_i) = \\int_{\\Omega} r \\phi_i \\, d\\Omega + \\int_{\\partial \\Omega} g \\phi_i \\, ds\n$$\nThe integrals are computed by summing up contributions from each element $T_e$ in the mesh triangulation $\\mathcal{T}_h$:\n$$\nK_{ij} = \\sum_{T_e \\in \\mathcal{T}_h} \\int_{T_e} \\nabla \\phi_j \\cdot \\nabla \\phi_i \\, d\\Omega = \\sum_{T_e \\in \\mathcal{T}_h} K_e^{ij}\n$$\n$$\nb_i = \\sum_{T_e \\in \\mathcal{T}_h} \\int_{T_e} r \\phi_i \\, d\\Omega + \\sum_{E \\in \\mathcal{E}_h, E \\subset \\partial\\Omega} \\int_E g \\phi_i \\, ds\n$$\nwhere $K_e$ is the element stiffness matrix. The process of summing element contributions into the global system is called assembly.\n\nFor a triangular element with linear Lagrange basis functions (P1 element), the basis function $\\phi_i$ associated with node $i$ is a plane that is $1$ at node $i$ and $0$ at the other two nodes. Consequently, its gradient $\\nabla \\phi_i$ is a constant vector over the element. The element stiffness matrix for a triangle $T_e$ with area $A_e$ and vertices $\\mathbf{p}_1, \\mathbf{p}_2, \\mathbf{p}_3$ has entries:\n$$\nK_e^{ij} = A_e (\\nabla \\phi_i \\cdot \\nabla \\phi_j)\n$$\nThe gradients can be computed from the vertex coordinates. For instance, $\\nabla \\phi_1 = \\frac{1}{2A_e} \\begin{pmatrix} y_2 - y_3 \\\\ x_3 - x_2 \\end{pmatrix}$, and similarly for $\\nabla \\phi_2, \\nabla \\phi_3$ by cyclic permutation of indices.\n\nThe provided test cases verify critical properties of the FEM assembly:\n\n**Case 1  2 (Dirichlet Patch Test):** These tests verify that the implementation can exactly reproduce a linear solution $u(\\mathbf{x}) = a + bx + cy$. For such a $u$, the Laplacian is $\\Delta u = 0$, so the source term is $r=0$. When $u_h$ is a linear polynomial, the exact solution is in the finite element space $V_h$. The Galerkin orthogonality property implies that the residual of the assembled system must be zero for all equations corresponding to interior nodes (where the test functions do not vanish on the boundary). This must hold for regular meshes (Case 1) and for meshes distorted by an affine transformation (Case 2), demonstrating the geometric invariance of the formulation.\n\n**Case 3 (Nullspace Property):** For a pure Neumann problem ($g$ prescribed everywhere on $\\partial\\Omega$), the solution is unique only up to an additive constant. If $u$ is a solution, so is $u+C$. This property is reflected in the stiffness matrix $K$. For any constant function $u(\\mathbf{x}) = C$, its gradient is zero, so $\\int_\\Omega \\nabla u \\cdot \\nabla v \\, d\\Omega = 0$ for any $v$. In the discrete system, if we set the nodal values to a constant vector $\\mathbf{u} = C \\mathbf{1}$ (where $\\mathbf{1}$ is the vector of all ones), the result must be $K(C\\mathbf{1}) = C(K\\mathbf{1}) = \\mathbf{0}$. This means the vector $\\mathbf{1}$ must be in the nullspace of $K$, which implies that the sum of each row of $K$ must be zero. This test verifies this structural property.\n\n**Case 4 (Neumann Patch Test and Equilibrium):** This test considers a linear solution $u(\\mathbf{x}) = bx+cy$ with a consistent Neumann boundary condition $g=\\nabla u \\cdot \\mathbf{n}$. The right-hand side vector $\\mathbf{b}$ is assembled from this boundary flux term. Like the Dirichlet case, the linear solution must be recovered exactly, so the residual $K\\mathbf{u} - \\mathbf{b}$ must be zero everywhere. Additionally, for a pure Neumann problem to have a solution, the source terms must satisfy the compatibility (or equilibrium) condition $\\int_\\Omega r \\, d\\Omega = \\int_{\\partial\\Omega} g \\, ds$. Here, $r=0$, and $g$ is chosen such that $\\int_{\\partial\\Omega} g \\, ds = \\int_{\\partial\\Omega} \\nabla u \\cdot \\mathbf{n} \\, ds = \\int_\\Omega \\Delta u \\, d\\Omega = 0$. The discrete equivalent is that the sum of all entries in the load vector, $\\sum_i b_i$, must be zero. This is because $\\sum_i b_i = \\sum_i \\int_{\\partial\\Omega} g \\phi_i ds = \\int_{\\partial\\Omega} g (\\sum_i \\phi_i) ds = \\int_{\\partial\\Omega} g \\, ds$, using the partition of unity property $\\sum_i \\phi_i = 1$. This test verifies both the correct assembly of Neumann boundary terms and the satisfaction of the discrete equilibrium condition.\n\nThe implementation will follow these principles, constructing the mesh, assembling the matrices and vectors element by element, and then performing the specified numerical checks to a tolerance of $\\epsilon = 10^{-12}$.", "answer": "```python\nimport numpy as np\nfrom scipy.sparse import lil_matrix\n\ndef solve():\n    \"\"\"\n    Main function to run the FEM patch tests and print results.\n    \"\"\"\n\n    def create_mesh(N, A, t):\n        \"\"\"\n        Generates a mesh on the affine-transformed unit square.\n        Args:\n            N (int): Number of subdivisions along each axis of the unit square.\n            A (np.ndarray): 2x2 matrix for the affine transformation.\n            t (np.ndarray): 2x1 translation vector for the affine transformation.\n        Returns:\n            tuple: (nodes, elements)\n                - nodes (np.ndarray): Array of node coordinates, shape (num_nodes, 2).\n                - elements (np.ndarray): Array of element connectivities, shape (num_elements, 3).\n        \"\"\"\n        num_nodes = (N + 1) * (N + 1)\n        nodes = np.zeros((num_nodes, 2))\n        for j in range(N + 1):\n            for i in range(N + 1):\n                node_idx = j * (N + 1) + i\n                ref_pos = np.array([i / N, j / N])\n                nodes[node_idx] = A @ ref_pos + t\n\n        num_elements = 2 * N * N\n        elements = np.zeros((num_elements, 3), dtype=int)\n        elem_idx = 0\n        for j in range(N):\n            for i in range(N):\n                n00 = j * (N + 1) + i\n                n10 = j * (N + 1) + (i + 1)\n                n01 = (j + 1) * (N + 1) + i\n                n11 = (j + 1) * (N + 1) + (i + 1)\n                elements[elem_idx] = [n00, n10, n11]\n                elem_idx += 1\n                elements[elem_idx] = [n00, n11, n01]\n                elem_idx += 1\n        return nodes, elements\n\n    def assemble_stiffness_matrix(nodes, elements):\n        \"\"\"\n        Assembles the global stiffness matrix K using P1 elements.\n        \"\"\"\n        num_nodes = len(nodes)\n        K = lil_matrix((num_nodes, num_nodes))\n\n        for el_nodes_idx in elements:\n            p1, p2, p3 = nodes[el_nodes_idx[0]], nodes[el_nodes_idx[1]], nodes[el_nodes_idx[2]]\n            \n            area = 0.5 * np.abs(p1[0] * (p2[1] - p3[1]) + p2[0] * (p3[1] - p1[1]) + p3[0] * (p1[1] - p2[1]))\n            if area  1e-15: continue\n\n            b = np.array([p2[1] - p3[1], p3[1] - p1[1], p1[1] - p2[1]])\n            c = np.array([p3[0] - p2[0], p1[0] - p3[0], p2[0] - p1[0]])\n            \n            Ke = np.zeros((3, 3))\n            for i in range(3):\n                for j in range(3):\n                    grad_dot_prod = (b[i] * b[j] + c[i] * c[j]) / (4 * area**2)\n                    Ke[i, j] = grad_dot_prod * area\n            \n            for i in range(3):\n                for j in range(3):\n                    gi, gj = el_nodes_idx[i], el_nodes_idx[j]\n                    K[gi, gj] += Ke[i, j]\n        \n        return K.tocsr()\n\n    def run_case(case_params):\n        \"\"\"\n        Executes a single test case.\n        \"\"\"\n        N = case_params['N']\n        A = np.array(case_params['A'])\n        t = np.array(case_params['t'])\n        u_params = case_params['u_params']\n        tol = case_params['tol']\n        \n        nodes, elements = create_mesh(N, A, t)\n        K = assemble_stiffness_matrix(nodes, elements)\n        num_nodes = len(nodes)\n\n        if case_params['type'] == 'dirichlet_linear':\n            a, b_u, c_u = u_params['a'], u_params['b'], u_params['c']\n            b = np.zeros(num_nodes)\n            u_vec = a + b_u * nodes[:, 0] + c_u * nodes[:, 1]\n            residual = K @ u_vec - b\n            \n            interior_nodes_mask = np.ones(num_nodes, dtype=bool)\n            for j in range(N + 1):\n                for i in range(N + 1):\n                    if i == 0 or i == N or j == 0 or j == N:\n                        node_idx = j * (N + 1) + i\n                        interior_nodes_mask[node_idx] = False\n            \n            max_interior_residual = np.max(np.abs(residual[interior_nodes_mask]))\n            return max_interior_residual = tol\n\n        elif case_params['type'] == 'nullspace':\n            a = u_params['a']\n            ones_vec = np.ones(num_nodes)\n            res_null = K @ ones_vec\n            check1 = np.max(np.abs(res_null)) = tol\n            \n            u_vec = np.full(num_nodes, a)\n            res_const = K @ u_vec\n            check2 = np.max(np.abs(res_const)) = tol\n            return check1 and check2\n\n        elif case_params['type'] == 'neumann_linear':\n            a, b_u, c_u = u_params['a'], u_params['b'], u_params['c']\n            b = np.zeros(num_nodes)\n            \n            # g = n . grad(u) = n . [b_u, c_u]\n            # bottom: n=(0,-1) -> g=-c_u\n            # right:  n=(1, 0) -> g=b_u\n            # top:    n=(0, 1) -> g=c_u\n            # left:   n=(-1,0) -> g=-b_u\n            g_bottom, g_right, g_top, g_left = -c_u, b_u, c_u, -b_u\n\n            # Assemble boundary load vector\n            # Bottom edge\n            for i in range(N):\n                n1, n2 = i, i + 1\n                edge_len = np.linalg.norm(nodes[n2] - nodes[n1])\n                b[n1] += g_bottom * edge_len / 2.0\n                b[n2] += g_bottom * edge_len / 2.0\n            \n            # Right edge\n            for j in range(N):\n                n1, n2 = j * (N + 1) + N, (j + 1) * (N + 1) + N\n                edge_len = np.linalg.norm(nodes[n2] - nodes[n1])\n                b[n1] += g_right * edge_len / 2.0\n                b[n2] += g_right * edge_len / 2.0\n\n            # Top edge\n            for i in range(N):\n                n1, n2 = N * (N + 1) + i, N * (N + 1) + (i + 1)\n                edge_len = np.linalg.norm(nodes[n2] - nodes[n1])\n                b[n1] += g_top * edge_len / 2.0\n                b[n2] += g_top * edge_len / 2.0\n                \n            # Left edge\n            for j in range(N):\n                n1, n2 = j * (N + 1), (j + 1) * (N + 1)\n                edge_len = np.linalg.norm(nodes[n2] - nodes[n1])\n                b[n1] += g_left * edge_len / 2.0\n                b[n2] += g_left * edge_len / 2.0\n\n            u_vec = a + b_u * nodes[:, 0] + c_u * nodes[:, 1]\n            residual = K @ u_vec - b\n            check1 = np.max(np.abs(residual)) = tol\n            check2 = np.abs(np.sum(b)) = tol\n\n            return check1 and check2\n        \n        return False\n\n    test_cases = [\n        {\n            'type': 'dirichlet_linear', 'N': 4,\n            'A': [[1, 0], [0, 1]], 't': [0, 0],\n            'u_params': {'a': 1/3, 'b': 7/10, 'c': -2/5},\n            'tol': 1e-12\n        },\n        {\n            'type': 'dirichlet_linear', 'N': 3,\n            'A': [[1, 1/5], [1/10, 13/10]], 't': [0, 0],\n            'u_params': {'a': 1/3, 'b': 7/10, 'c': -2/5},\n            'tol': 1e-12\n        },\n        {\n            'type': 'nullspace', 'N': 3,\n            'A': [[1, 0], [0, 1]], 't': [0, 0],\n            'u_params': {'a': 5/2},\n            'tol': 1e-12\n        },\n        {\n            'type': 'neumann_linear', 'N': 4,\n            'A': [[1, 0], [0, 1]], 't': [0, 0],\n            'u_params': {'a': 0, 'b': -3/5, 'c': 3/10},\n            'tol': 1e-12\n        }\n    ]\n\n    results = [run_case(case) for case in test_cases]\n    \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3364930"}, {"introduction": "Physical systems governed by conservation laws often lead to mathematical models with pure Neumann boundary conditions, resulting in singular linear systems. This practice [@problem_id:3364950] explores the assembly of such a system, where the stiffness matrix has a nullspace corresponding to constant functions, and a solution exists only if a compatibility condition is met. You will verify these properties and implement standard techniques like pinning a degree of freedom and using Lagrange multipliers to enforce solution uniqueness.", "problem": "Consider the one-dimensional diffusion equation, a prototypical Partial Differential Equation (PDE), on the domain $[0,1]$ with pure Neumann boundary conditions in conservation form. Starting from the classical Galerkin weak formulation derived by integration by parts, assemble the global stiffness matrix and load vector using the Finite Element Method (FEM) with continuous piecewise linear (first-order Lagrange) basis functions on a uniform mesh of $N$ intervals. Let the diffusion coefficient be $k(x)=1$. Let the outward unit normal be $n$, and let the prescribed outward fluxes at the boundary be $q(0)$ and $q(1)$, respectively. Denote by $f(x)$ the source term. The pure Neumann problem is solvable if and only if the compatibility condition holds, and the solution is unique only up to an additive constant. Your tasks are:\n\n- Assemble the global stiffness matrix $K$ and load vector $b$ for the Neumann problem, ensuring the correct incorporation of boundary fluxes $q(0)$ and $q(1)$ into the right-hand side.\n- Identify the discrete nullspace vector corresponding to constant functions and verify computationally that $K \\mathbf{1} = \\mathbf{0}$, where $\\mathbf{1}$ is the global vector of ones and $\\mathbf{0}$ is the zero vector of compatible size.\n- Demonstrate discrete conservation for the Neumann problem by verifying numerically that $\\mathbf{1}^{\\mathsf{T}} b$ equals the discrete analogue of the compatibility condition.\n- Resolve the non-uniqueness in two distinct ways and compare the outcomes:\n  1. Pin a single degree of freedom by enforcing a Dirichlet condition at one node (e.g., $u(0)=0$) to obtain a unique solution $u_{\\mathrm{pin}}$.\n  2. Enforce a zero-mean constraint via a single Lagrange multiplier to obtain a unique solution $u_{\\mathrm{lag}}$. Use the exact integral constraint $\\int_{0}^{1} u(x)\\,dx = 0$, represented discretely by the vector $m$ with entries $m_i = \\int_{0}^{1} \\varphi_i(x)\\,dx$, where $\\{\\varphi_i\\}$ are the nodal basis functions. Do not assume a shortcut formula for $m_i$; compute these integrals exactly for the chosen basis on a uniform mesh.\n- To compare $u_{\\mathrm{pin}}$ and $u_{\\mathrm{lag}}$, remove the arbitrary constant from $u_{\\mathrm{pin}}$ by selecting $\\alpha$ that minimizes the discrete $L^{2}$ distance with respect to the quadrature induced by $m$: find $\\alpha$ that minimizes $\\|u_{\\mathrm{pin}} - \\alpha \\mathbf{1} - u_{\\mathrm{lag}}\\|_{M}$, where $\\|w\\|_{M}^{2} = \\sum_{i} m_i w_i^{2}$. Report the minimized distance.\n\nBase your derivation strictly on:\n- The Galerkin weak form and the definition of the FEM assembly from local element contributions.\n- The partition-of-unity property of the basis functions and the exactness of the boundary flux insertion for natural boundary conditions.\n- The conservation property implied by testing the weak form with the constant function.\n\nYou are required to implement a single self-contained program that computes, for each test case, the following three quantitative diagnostics:\n- The Euclidean norm $\\|K \\mathbf{1}\\|_{2}$.\n- The absolute value $|\\mathbf{1}^{\\mathsf{T}} b|$.\n- The mass-weighted distance $\\|u_{\\mathrm{pin}} - \\alpha \\mathbf{1} - u_{\\mathrm{lag}}\\|_{M}$ after optimal alignment by $\\alpha$ as defined above.\n\nTest suite:\n- Case $1$ (happy path, zero-flux, oscillatory zero-mean source): $N=32$, $f(x)=\\sin(2\\pi x)$, $q(0)=0$, $q(1)=0$.\n- Case $2$ (nonzero boundary flux to satisfy compatibility with constant source): $N=9$, $f(x)=1$, $q(0)=0$, $q(1)=-1$.\n- Case $3$ (edge case, coarsest mesh, zero source with balanced opposing fluxes): $N=1$, $f(x)=0$, $q(0)=2$, $q(1)=-2$.\n\nYour program should:\n- Assemble $K$ and $b$ using first-order Lagrange elements on a uniform mesh over $[0,1]$.\n- Use sufficiently accurate numerical quadrature for the element load vector to ensure meaningful verification of conservation and nullspace properties.\n- Compute $u_{\\mathrm{pin}}$ by pinning the value at the left boundary node $x=0$, and $u_{\\mathrm{lag}}$ by solving the augmented saddle-point system with the constraint vector $m$ as defined above.\n- For each case, produce the triple of floats described above.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered as $[\\text{case1\\_k1},\\text{case1\\_b1},\\text{case1\\_d1},\\text{case2\\_k1},\\text{case2\\_b1},\\text{case2\\_d1},\\text{case3\\_k1},\\text{case3\\_b1},\\text{case3\\_d1}]$, where for each case the three entries are, respectively, $\\|K \\mathbf{1}\\|_{2}$, $|\\mathbf{1}^{\\mathsf{T}} b|$, and the minimized mass-weighted distance. All numerical values must be floats.", "solution": "The problem requires the assembly of the global stiffness matrix and load vector for a one-dimensional diffusion equation with pure Neumann boundary conditions using the Finite Element Method (FEM), and a subsequent analysis of the resulting linear system.\n\n### Problem Validation\nThe problem is well-defined, scientifically sound, and internally consistent. It is a standard, albeit comprehensive, problem in the numerical solution of partial differential equations. The core concepts—Galerkin method, Neumann boundary conditions, matrix singularity and nullspace, compatibility conditions, and methods for enforcing uniqueness (pinning, Lagrange multipliers)—are fundamental to the field.\n\nA potential ambiguity arises in the definition of the prescribed outward fluxes, $q(0)$ and $q(1)$. Different conventions exist for Neumann boundary conditions. The ambiguity is resolved by enforcing the compatibility condition, which must hold for a solvable problem, on the provided test cases. This deductive step reveals the requisite convention for the problem to be consistent.\n\nThe compatibility condition is derived by integrating the strong form of the PDE, $-(k(x) u'(x))' = f(x)$, over the domain $\\Omega = [0,1]$:\n$$\n\\int_0^1 -(k u')' dx = \\int_0^1 f(x) dx\n$$\nBy the fundamental theorem of calculus, this becomes:\n$$\n-[k(x) u'(x)]_0^1 = \\int_0^1 f(x) dx \\implies -k(1)u'(1) + k(0)u'(0) = \\int_0^1 f(x) dx\n$$\nThe problem specifies $q(0)$ and $q(1)$ as outward fluxes. At $x=1$, the outward normal is $n=1$, so the outward flux is the physical flux vector projected onto the normal: $(-k u' \\mathbf{i}) \\cdot (1 \\mathbf{i}) = -k u'$. At $x=0$, the outward normal is $n=-1$, so the outward flux is $(-k u' \\mathbf{i}) \\cdot (-1 \\mathbf{i}) = k u'$. The problem statement could be interpreted in multiple ways, but for the provided test cases to satisfy compatibility, the following convention must be adopted: the outward flux at $x=1$ is $q(1) = k(1)u'(1)$ and the outward flux at $x=0$ is $q(0) = -k(0)u'(0)$. Substituting these into the integrated equation (with $k(x)=1$) yields the compatibility condition:\n$$\n\\int_0^1 f(x) dx = -q(0) - q(1)\n$$\nThis condition holds for all three test cases, validating this interpretation.\n\nWith all aspects clarified, the problem is deemed valid.\n\n### Step-by-Step Solution\n\n**1. Weak Formulation**\nThe PDE is $-u''(x) = f(x)$ on $[0,1]$. We multiply by a test function $v(x) \\in H^1(0,1)$ and integrate over the domain:\n$$\n\\int_0^1 -u''(x) v(x) dx = \\int_0^1 f(x) v(x) dx\n$$\nIntegration by parts on the left-hand side yields:\n$$\n\\int_0^1 u'(x) v'(x) dx - [u'(x)v(x)]_0^1 = \\int_0^1 f(x) v(x) dx\n$$\nRearranging and expanding the boundary term gives:\n$$\n\\int_0^1 u'(x) v'(x) dx = \\int_0^1 f(x) v(x) dx + u'(1)v(1) - u'(0)v(0)\n$$\nUsing the validated convention ($k=1$), $u'(1)=q(1)$ and $u'(0)=-q(0)$, the boundary terms become $q(1)v(1) - (-q(0))v(0) = q(1)v(1) + q(0)v(0)$. The final weak form is to find $u \\in H^1(0,1)$ such that for all $v \\in H^1(0,1)$:\n$$\na(u,v) = L(v)\n$$\nwhere the bilinear form is $a(u,v) = \\int_0^1 u'(x) v'(x) dx$ and the linear functional is $L(v) = \\int_0^1 f(x) v(x) dx + q(1)v(1) + q(0)v(0)$.\n\n**2. FEM Discretization and Assembly**\nWe discretize the domain $[0,1]$ into $N$ uniform intervals of length $h=1/N$. This creates $N+1$ nodes, $x_i = i h$ for $i=0, \\dots, N$. We use continuous piecewise linear (P1 Lagrange) basis functions $\\{\\varphi_i(x)\\}_{i=0}^N$, where $\\varphi_i(x_j)=\\delta_{ij}$. The FEM approximation is $u_h(x) = \\sum_{j=0}^N u_j \\varphi_j(x)$.\n\nThe Galerkin method, with $u=u_h$ and $v=\\varphi_i$, leads to the linear system $K\\mathbf{u} = \\mathbf{b}$, where $\\mathbf{u}$ is the vector of nodal unknowns $[u_0, \\dots, u_N]^T$.\nThe entries of the global stiffness matrix $K$ and load vector $\\mathbf{b}$ are:\n$$\nK_{ij} = a(\\varphi_j, \\varphi_i) = \\int_0^1 \\varphi_j'(x) \\varphi_i'(x) dx\n$$\n$$\nb_i = L(\\varphi_i) = \\int_0^1 f(x) \\varphi_i(x) dx + q(1)\\varphi_i(1) + q(0)\\varphi_i(0)\n$$\nFor an element of length $h$, the element stiffness matrix is $K^e = \\frac{1}{h} \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix}$. Assembling these for all $N$ elements, the global $(N+1) \\times (N+1)$ matrix $K$ is tridiagonal:\n$$\nK = \\frac{1}{h} \\begin{pmatrix}\n1  -1    \\\\\n-1  2  -1   \\\\\n \\ddots  \\ddots  \\ddots  \\\\\n  -1  2  -1 \\\\\n   -1  1\n\\end{pmatrix}\n$$\nThe integral part of the load vector, $\\mathbf{b}^{src}_i = \\int_0^1 f(x) \\varphi_i(x) dx$, is computed using numerical quadrature (e.g., 2-point Gauss quadrature on each element for accuracy). The boundary flux terms only affect the first and last entries of the vector since $\\varphi_i(0)=\\delta_{i0}$ and $\\varphi_i(1)=\\delta_{iN}$:\n$$\nb_0 = \\mathbf{b}^{src}_0 + q(0) \\quad , \\quad b_N = \\mathbf{b}^{src}_N + q(1) \\quad , \\quad b_i = \\mathbf{b}^{src}_i \\text{ for } 0  i  N\n$$\n\n**3. Nullspace and Discrete Conservation**\n- **Nullspace:** The vector $\\mathbf{1}=[1, \\dots, 1]^T$ represents a constant function on the mesh. The sum of each row of the matrix $K$ is zero (e.g., for an interior row $i$, $\\frac{1}{h}(-1+2-1)=0$). Therefore, $K\\mathbf{1} = \\mathbf{0}$, meaning $K$ is singular and its nullspace contains constant vectors. The first diagnostic, $\\|K\\mathbf{1}\\|_2$, should be near machine precision.\n- **Conservation:** A solution to $K\\mathbf{u}=\\mathbf{b}$ exists only if $\\mathbf{b}$ is in the range of $K$, which requires $\\mathbf{b}$ to be orthogonal to the nullspace of $K^T=K$. Thus, the discrete compatibility (or solvability) condition is $\\mathbf{1}^T\\mathbf{b} = 0$. Let's verify this analytically:\n$$\n\\mathbf{1}^T\\mathbf{b} = \\sum_{i=0}^N b_i = \\sum_{i=0}^N \\left( \\int_0^1 f(x)\\varphi_i(x)dx + q(1)\\delta_{iN} + q(0)\\delta_{i0} \\right)\n$$\n$$\n= \\int_0^1 f(x) \\left( \\sum_{i=0}^N \\varphi_i(x) \\right) dx + q(1) + q(0)\n$$\nUsing the partition of unity property, $\\sum_{i=0}^N \\varphi_i(x) = 1$, we get:\n$$\n\\mathbf{1}^T\\mathbf{b} = \\int_0^1 f(x) dx + q(1) + q(0)\n$$\nFor solvability, this quantity must be zero (up to quadrature error), which matches the continuous compatibility condition. The second diagnostic, $|\\mathbf{1}^T\\mathbf{b}|$, verifies this.\n\n**4. Resolving Singularity**\n- **Pinning ($u_{\\mathrm{pin}}$):** We enforce uniqueness by setting a value, e.g., $u_0=0$. This removes the first unknown. The system is reduced to an $N \\times N$ system for the remaining unknowns $u_1, \\dots, u_N$. The submatrix $K_{1:,1:}$ is nonsingular. We solve $K_{1:,1:} [u_1, \\dots, u_N]^T = \\mathbf{b}_{1:}$ and prepend $u_0=0$ to get $\\mathbf{u}_{\\mathrm{pin}}$.\n- **Lagrange Multiplier ($u_{\\mathrm{lag}}$):** We enforce the integral constraint $\\int_0^1 u(x) dx = 0$. Discretely, this is $\\mathbf{m}^T\\mathbf{u}=0$, where $m_i = \\int_0^1 \\varphi_i(x) dx$. For a uniform mesh with P1 elements, $m_i=h$ for interior nodes ($i=1,\\dots,N-1$) and $m_i=h/2$ for boundary nodes ($i=0,N$). This leads to the augmented $(N+2)\\times(N+2)$ saddle-point system, which is non-singular:\n$$\n\\begin{pmatrix} K  \\mathbf{m} \\\\ \\mathbf{m}^T  0 \\end{pmatrix} \\begin{pmatrix} \\mathbf{u}_{\\mathrm{lag}} \\\\ \\lambda \\end{pmatrix} = \\begin{pmatrix} \\mathbf{b} \\\\ 0 \\end{pmatrix}\n$$\n\n**5. Solution Comparison**\nThe solutions $\\mathbf{u}_{\\mathrm{pin}}$ and $\\mathbf{u}_{\\mathrm{lag}}$ both satisfy the underlying physics but differ by a constant, reflecting the different uniqueness constraints. We align $\\mathbf{u}_{\\mathrm{pin}}$ to $\\mathbf{u}_{\\mathrm{lag}}$ by finding a constant $\\alpha$ that minimizes the distance $\\| \\mathbf{u}_{\\mathrm{pin}} - \\alpha\\mathbf{1} - \\mathbf{u}_{\\mathrm{lag}} \\|_M$, where the squared norm is defined as $\\|w\\|_M^2 = \\sum_i m_i w_i^2$.\nLet $\\mathbf{v} = \\mathbf{u}_{\\mathrm{pin}} - \\mathbf{u}_{\\mathrm{lag}}$. We minimize $E(\\alpha) = \\sum_i m_i (v_i-\\alpha)^2$. Setting the derivative to zero gives the optimal $\\alpha$:\n$$\n\\frac{dE}{d\\alpha} = -2\\sum_i m_i(v_i-\\alpha)=0 \\implies \\alpha \\sum_i m_i = \\sum_i m_i v_i\n$$\n$$\n\\alpha_{\\mathrm{opt}} = \\frac{\\mathbf{m}^T \\mathbf{v}}{\\mathbf{m}^T \\mathbf{1}} = \\frac{\\mathbf{m}^T (\\mathbf{u}_{\\mathrm{pin}} - \\mathbf{u}_{\\mathrm{lag}})}{\\mathbf{m}^T \\mathbf{1}}\n$$\nSince $\\mathbf{m}^T\\mathbf{u}_{\\mathrm{lag}}=0$ by construction and $\\mathbf{m}^T\\mathbf{1} = \\sum_i m_i = \\int_0^1 (\\sum_i \\varphi_i) dx = \\int_0^1 1 dx = 1$, the optimal shift is $\\alpha_{\\mathrm{opt}} = \\mathbf{m}^T \\mathbf{u}_{\\mathrm{pin}}$. The third diagnostic is the resulting minimized distance, which measures the discrepancy between the two solutions after optimal alignment. This distance is not strictly zero because the pinning procedure solves a slightly modified system, so $\\mathbf{u}_{\\mathrm{pin}}$ is not perfectly a constant-shifted version of a solution to the original singular problem.", "answer": "```python\nimport numpy as np\n\ndef solve_case(N, f, q0, q1):\n    \"\"\"\n    Solves the 1D Neumann problem and computes specified diagnostics.\n\n    Args:\n        N (int): Number of intervals in the uniform mesh.\n        f (callable): Source function f(x).\n        q0 (float): Prescribed flux parameter at x=0.\n        q1 (float): Prescribed flux parameter at x=1.\n\n    Returns:\n        tuple: A tuple containing the three diagnostic values:\n               (norm_k1, abs_one_T_b, dist).\n    \"\"\"\n    h = 1.0 / N\n    nodes = N + 1\n    x_nodes = np.linspace(0, 1, nodes)\n\n    # 1. Assemble Stiffness Matrix K\n    K = np.zeros((nodes, nodes))\n    diag_vals = np.full(nodes, 2.0 / h)\n    diag_vals[0] = 1.0 / h\n    diag_vals[-1] = 1.0 / h\n    np.fill_diagonal(K, diag_vals)\n    off_diag_vals = np.full(nodes - 1, -1.0 / h)\n    np.fill_diagonal(K[1:], off_diag_vals)\n    np.fill_diagonal(K[:, 1:], off_diag_vals)\n\n    # 2. Assemble Load Vector b\n    b = np.zeros(nodes)\n    # Use 2-point Gauss quadrature on a [0,1] reference element\n    gauss_points = 0.5 + np.array([-1.0, 1.0]) / (2.0 * np.sqrt(3.0))\n    gauss_weights = np.array([0.5, 0.5])\n\n    for i in range(N):\n        # Physical coordinates of quadrature points on element [x_i, x_{i+1}]\n        x_phys = x_nodes[i] + h * gauss_points\n        f_vals = f(x_phys)\n        \n        # Contribution to b[i] from local basis function (1-xi)\n        integrand1 = f_vals * (1.0 - gauss_points)\n        b[i] += h * np.dot(gauss_weights, integrand1)\n\n        # Contribution to b[i+1] from local basis function (xi)\n        integrand2 = f_vals * gauss_points\n        b[i + 1] += h * np.dot(gauss_weights, integrand2)\n\n    # Add boundary flux contributions based on the derived weak form\n    b[0] += q0\n    b[-1] += q1\n\n    # Task 1: Compute ||K*1||_2\n    one_vec = np.ones(nodes)\n    norm_k1 = np.linalg.norm(K @ one_vec)\n\n    # Task 2: Compute |1^T * b|\n    abs_one_T_b = np.abs(np.sum(b))\n\n    # 3. Resolve non-uniqueness\n    # Pinning method for u_pin (u(0)=0)\n    K_pin = K[1:, 1:]\n    b_pin = b[1:]\n    u_sub = np.linalg.solve(K_pin, b_pin)\n    u_pin = np.concatenate(([0.0], u_sub))\n\n    # Lagrange multiplier method for u_lag\n    m = h * np.ones(nodes)\n    m[0] = h / 2.0\n    m[-1] = h / 2.0\n    \n    A_aug = np.zeros((nodes + 1, nodes + 1))\n    A_aug[:nodes, :nodes] = K\n    A_aug[:nodes, nodes] = m\n    A_aug[nodes, :nodes] = m\n    \n    b_aug = np.concatenate((b, [0.0]))\n    \n    sol_aug = np.linalg.solve(A_aug, b_aug)\n    u_lag = sol_aug[:-1]\n\n    # Task 3: Compare u_pin and u_lag\n    # Optimal constant alpha to align u_pin with u_lag\n    # alpha = (m.T @ (u_pin - u_lag)) / (m.T @ 1)\n    # Since m.T @ u_lag = 0 and m.T @ 1 = 1, alpha = m.T @ u_pin\n    alpha = np.dot(m, u_pin)\n    \n    # Vector for distance calculation\n    w = u_pin - alpha * one_vec - u_lag\n    \n    # Calculate mass-weighted distance as defined\n    dist_sq = np.sum(m * (w**2))\n    dist = np.sqrt(dist_sq)\n\n    return norm_k1, abs_one_T_b, dist\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    test_cases = [\n        # Case 1: N=32, f(x)=sin(2*pi*x), q(0)=0, q(1)=0\n        (32, lambda x: np.sin(2 * np.pi * x), 0.0, 0.0),\n        # Case 2: N=9, f(x)=1, q(0)=0, q(1)=-1\n        (9, lambda x: np.ones_like(x), 0.0, -1.0),\n        # Case 3: N=1, f(x)=0, q(0)=2, q(1)=-2\n        (1, lambda x: np.zeros_like(x), 2.0, -2.0),\n    ]\n\n    results = []\n    for N, f, q0, q1 in test_cases:\n        norm_k1, abs_one_T_b, dist = solve_case(N, f, q0, q1)\n        results.extend([norm_k1, abs_one_T_b, dist])\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3364950"}, {"introduction": "The theoretical exactness of the finite element method relies on exact integration, but in practice, numerical quadrature is used. Choosing an inadequate quadrature rule, a \"variational crime,\" can compromise the stability of the entire method. This hands-on exercise [@problem_id:3364951] guides you to investigate the consequences of under-integrating the stiffness matrix, leading to a loss of coercivity and the emergence of non-physical \"hourglass\" modes. By comparing different scenarios, you will learn to identify the conditions under which an assembled matrix remains robust and yields a stable solution.", "problem": "Consider the scalar diffusion problem on the unit square domain $\\Omega = (0,1) \\times (0,1)$ with homogeneous Dirichlet boundary conditions. The governing partial differential equation is $- \\nabla \\cdot (\\kappa \\nabla u) = f$ in $\\Omega$ with $u = 0$ on $\\partial \\Omega$, where $\\kappa$ is a strictly positive constant. The weak form seeks $u \\in H_0^1(\\Omega)$ such that $a(u,v) = \\ell(v)$ for all $v \\in H_0^1(\\Omega)$, where $a(u,v) = \\int_{\\Omega} \\kappa \\nabla u \\cdot \\nabla v \\, \\mathrm{d}x$ and $\\ell(v) = \\int_{\\Omega} f v \\, \\mathrm{d}x$. A standard Galerkin finite element method chooses a finite-dimensional subspace $V_h \\subset H_0^1(\\Omega)$ and solves $a(u_h,v_h) = \\ell(v_h)$ for all $v_h \\in V_h$.\n\nIn this problem you will study a variational crime introduced by numerical quadrature used during assembly of the global stiffness matrix, i.e., replacing $\\int_{\\Omega}\\cdot$ by a quadrature rule. You will examine how underintegration may destroy coercivity and reveal spurious zero-energy modes or locking phenomena, and you will identify conditions on quadrature rules under which the assembled global stiffness matrix $A$ remains coercive.\n\nWork from the following foundational bases: the weak form definition, the definition of conforming finite element spaces on simplices and quadrilaterals, the mapping of shape functions from a reference cell, and the definition of numerical quadrature (points and positive weights).\n\nYou must construct two families of meshes and finite element spaces:\n- Piecewise linear Lagrange elements on triangles ($P_1$) obtained by subdividing a uniform Cartesian grid of $\\Omega$ into two triangles per rectangle using an affine mapping on each triangle.\n- Bilinear Lagrange elements on quadrilaterals ($Q_1$) obtained from the same Cartesian grid using a bilinear mapping on each quadrilateral. Additionally, consider a smoothly distorted quadrilateral mesh obtained by moving interior nodes by a small, smooth displacement while keeping boundary nodes fixed on $\\partial \\Omega$.\n\nFor assembly of element stiffness matrices, use the following quadrature rules on the reference cells:\n- For triangles: the single centroid rule with one point at barycentric coordinates $(\\frac{1}{3},\\frac{1}{3})$ and weight equal to the area of the reference triangle, i.e., $\\frac{1}{2}$. This rule is exact for polynomials up to degree $1$.\n- For quadrilaterals: tensor-product Gauss rules on the square $[-1,1]^2$.\n  - The $1 \\times 1$ rule with the single point $(0,0)$ of weight $4$ (exact for polynomials up to degree $1$).\n  - The $2 \\times 2$ rule with the four points $(\\pm \\frac{1}{\\sqrt{3}}, \\pm \\frac{1}{\\sqrt{3}})$, each of weight $1$ (exact for polynomials up to degree $3$).\n\nYou must:\n- Assemble global stiffness matrices $A$ for several scenarios by summing element contributions computed via the stated quadrature rules.\n- Impose homogeneous Dirichlet boundary conditions by eliminating degrees of freedom associated with boundary nodes, forming a reduced matrix $A_I$ on interior degrees of freedom.\n- Define coercivity in this discrete setting as: $A_I$ is symmetric positive definite, equivalently its smallest eigenvalue $\\lambda_{\\min}(A_I)$ is strictly positive.\n- Using first principles, identify conditions on the quadrature that guarantee coercivity for $P_1$ and $Q_1$ discretizations under the given mappings.\n\nYour program must construct and test the following five cases (the test suite), each using $\\kappa = 1$, no load vector assembly is required for this study:\n- Test $\\mathbf{T1}$ (baseline coercive): $P_1$ on an affine triangulation from a uniform $6 \\times 6$ grid, stiffness assembled with the $1$-point centroid rule.\n- Test $\\mathbf{T2}$ (underintegrated, expected spurious modes): $Q_1$ on an undistorted uniform $6 \\times 6$ quadrilateral grid, stiffness assembled with the $1 \\times 1$ Gauss rule.\n- Test $\\mathbf{T3}$ (sufficiently integrated): $Q_1$ on an undistorted uniform $6 \\times 6$ quadrilateral grid, stiffness assembled with the $2 \\times 2$ Gauss rule.\n- Test $\\mathbf{T4}$ (underintegrated on distorted mesh, expected spurious modes): $Q_1$ on a smoothly distorted $6 \\times 6$ quadrilateral grid with interior node displacement $\\delta(x,y) = \\alpha \\sin(\\pi x)\\sin(\\pi y)$ applied identically to both coordinates with $\\alpha = 0.2$, stiffness assembled with the $1 \\times 1$ Gauss rule.\n- Test $\\mathbf{T5}$ (sufficiently integrated on distorted mesh): $Q_1$ on the same distorted grid as in $\\mathbf{T4}$, stiffness assembled with the $2 \\times 2$ Gauss rule.\n\nFor each test, determine a boolean answer indicating whether $A_I$ is coercive by checking if $\\lambda_{\\min}(A_I)  \\varepsilon$, where $\\varepsilon = 10^{-12}$. You must ensure that the interior matrix $A_I$ is assembled and evaluated in a way consistent with the definitions above. No physical units are required for this problem.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order $\\mathbf{T1}$ through $\\mathbf{T5}$, for example, $[b1,b2,b3,b4,b5]$, where each b_i is either True or False depending on whether the corresponding $A_I$ is coercive according to the stated threshold.", "solution": "The problem requires an analysis of the discrete coercivity of the stiffness matrix for a scalar diffusion problem, assembled using various finite elements and numerical quadrature rules. A discrete formulation is coercive if the reduced stiffness matrix $A_I$, corresponding to interior degrees of freedom, is symmetric positive definite. This is equivalent to its smallest eigenvalue, $\\lambda_{\\min}(A_I)$, being strictly positive.\n\nThe continuous problem is governed by the weak form $a(u,v) = \\ell(v)$, with the bilinear form $a(u,v) = \\int_{\\Omega} \\kappa \\nabla u \\cdot \\nabla v \\, \\mathrm{d}x$. In the finite element method, we approximate this by restricting $u$ and $v$ to a finite-dimensional space $V_h$. This leads to a matrix system $A U = F$, where the entries of the stiffness matrix $A$ are given by $A_{ij} = a(\\phi_j, \\phi_i)$, with $\\phi_i$ being the global basis functions. The matrix $A$ is assembled from element stiffness matrices $A^e$, where $A^e_{ij} = \\int_{K_e} \\kappa \\nabla \\phi_j \\cdot \\nabla \\phi_i \\, \\mathrm{d}x$, for an element $K_e$.\n\nThe integral is typically computed on a reference element $\\hat{K}$ via a mapping $F_e: \\hat{K} \\to K_e$. The element stiffness matrix entries are then $A^e_{ij} = \\int_{\\hat{K}} \\kappa (\\nabla \\phi_j \\circ F_e) \\cdot (\\nabla \\phi_i \\circ F_e) |\\det(J_e)| \\, \\mathrm{d}\\hat{x}$, where $J_e$ is the Jacobian of the mapping $F_e$. Using the chain rule, $\\nabla \\phi_k = (J_e^{-1})^T \\nabla \\hat{\\phi}_k$, the integral becomes:\n$$\nA^e_{ij} = \\int_{\\hat{K}} \\kappa \\left( (J_e^{-1})^T \\nabla \\hat{\\phi}_j \\right) \\cdot \\left( (J_e^{-1})^T \\nabla \\hat{\\phi}_i \\right) |\\det(J_e)| \\, \\mathrm{d}\\hat{x}\n$$\nThe \"variational crime\" occurs when this integral is approximated by a numerical quadrature rule, $\\int_{\\hat{K}} g(\\hat{x}) \\, \\mathrm{d}\\hat{x} \\approx \\sum_{q} w_q g(\\hat{x}_q)$, where $\\hat{x}_q$ are the quadrature points and $w_q$ are the positive weights. The approximate element stiffness matrix is:\n$$\n\\tilde{A}^e_{ij} = \\sum_{q} w_q \\left[ \\kappa \\left( (J_e^{-1})^T \\nabla \\hat{\\phi}_j \\right) \\cdot \\left( (J_e^{-1})^T \\nabla \\hat{\\phi}_i \\right) |\\det(J_e)| \\right]_{\\hat{x}=\\hat{x}_q}\n$$\nThe assembled global matrix $\\tilde{A}$ (and its reduced form $\\tilde{A}_I$) may lose positive definiteness if the quadrature is not sufficiently accurate. A loss of coercivity implies the existence of a non-zero discrete function $u_h \\in V_h$ (satisfying homogeneous boundary conditions) for which the discrete energy is zero: $\\tilde{a}_h(u_h, u_h) = U_I^T \\tilde{A}_I U_I = 0$. Since $\\kappa  0$, $|\\det(J_e)|  0$, and $w_q  0$, this can only happen if the integrand itself is zero at all quadrature points across the entire domain. Specifically, this requires that the gradient of the solution, $\\nabla u_h$, vanishes at the physical location of every quadrature point, $x_q = F_e(\\hat{x}_q)$. Such a non-zero $u_h$ is called a \"spurious zero-energy mode\".\n\nWe now analyze each test case based on this principle.\n\n**Test T1: $P_1$ on Affine Triangles, $1$-Point Centroid Rule**\nFor piecewise linear elements ($P_1$) on an affine mesh, the mapping $F_e$ from the reference triangle to any element $K_e$ is affine. Consequently, the Jacobian matrix $J_e$ is constant over the element. The basis functions $\\hat{\\phi}_i$ on the reference element are linear, so their gradients $\\nabla \\hat{\\phi}_i$ are constant vectors. The entire integrand for $A^e_{ij}$ is therefore a constant. The $1$-point centroid quadrature rule integrates constant functions exactly. Thus, $\\tilde{A}^e = A^e$, and no variational crime is committed. The standard coercivity of the $P_1$ discretization is preserved. The matrix $A_I$ will be symmetric positive definite.\n\n**Test T2: $Q_1$ on Uniform Quadrilaterals, $1 \\times 1$ Gauss Rule**\nFor bilinear elements ($Q_1$) on a uniform rectangular grid, the mapping from the reference square $[-1,1]^2$ is affine. The Jacobian $J_e$ is constant. The reference basis functions $\\hat{\\phi}_i$ are bilinear, e.g., $\\hat{\\phi}_1(\\xi,\\eta) = \\frac{1}{4}(1-\\xi)(1-\\eta)$. Their gradients, e.g., $\\nabla\\hat{\\phi}_1 = \\frac{1}{4}[-(1-\\eta), -(1-\\xi)]$, are linear in $\\xi$ and $\\eta$. The integrand for $A^e_{ij}$ involves products of these gradients and is a polynomial of degree up to $2$ in $\\xi$ and $\\eta$. The $1 \\times 1$ Gauss rule, with a single point at $(\\xi,\\eta)=(0,0)$, is only exact for polynomials up to degree $1$. The quadrature is inexact.\nA zero-energy mode exists if $\\nabla u_h$ vanishes at the center of every element. On the reference element, this is equivalent to $\\nabla_{\\hat{x}} u_h(0,0) = \\sum_i U_i^e \\nabla\\hat{\\phi}_i(0,0) = 0$. One can show this condition is satisfied by the \"hourglass\" mode, where the nodal values are $U^e \\propto (-1, 1, -1, 1)$. Such a mode is non-constant, has a non-zero gradient elsewhere, but its computed energy is zero. This local mode can be extended to a global spurious mode over the mesh, which is non-zero but lies in the null space of the reduced matrix $A_I$. Thus, $A_I$ is not positive definite.\n\n**Test T3: $Q_1$ on Uniform Quadrilaterals, $2 \\times 2$ Gauss Rule**\nThe integrand is a polynomial of degree at most $2$ in each variable $\\xi$ and $\\eta$. The $2 \\times 2$ tensor-product Gauss rule is exact for polynomials up to degree $3$ in each variable. Therefore, the quadrature is exact for this case, $\\tilde{A}^e = A^e$. No variational crime is committed. The matrix $A_I$ will be coercive.\n\n**Test T4: $Q_1$ on Distorted Quadrilaterals, $1 \\times 1$ Gauss Rule**\nThe mesh distortion makes the mapping $F_e$ a general bilinear (non-affine) transformation. The Jacobian $J_e$ and its determinant are now non-constant functions of $(\\xi, \\eta)$. The integrand becomes a more complex rational function. However, the condition for a zero-energy mode with $1$-point quadrature remains the same: $\\nabla u_h$ must vanish at the single quadrature point $x_q = F_e(0,0)$. This is equivalent to the gradient on the reference element vanishing, $\\nabla_{\\hat{x}} u_h(0,0) = 0$, since $\\nabla u_h = (J_e^{-1})^T \\nabla_{\\hat{x}} u_h$ and $J_e$ is invertible. The existence of the hourglass mode depends only on the properties of the reference basis functions at $(\\xi,\\eta)=(0,0)$, not on the geometric mapping $F_e$. Therefore, the same spurious zero-energy modes exist as in Test T2, and the matrix $A_I$ will not be coercive.\n\n**Test T5: $Q_1$ on Distorted Quadrilaterals, $2 \\times 2$ Gauss Rule**\nIn this case, the $2 \\times 2$ quadrature rule is no longer exact because the term $|\\det(J_e)|$ is a non-polynomial rational function of $(\\xi, \\eta)$. A variational crime is committed. However, the issue is not merely exactness but stability. A zero-energy mode would require $\\nabla u_h$ to vanish at all four quadrature points inside each element. This translates to $\\nabla_{\\hat{x}} u_h(\\hat{x}_q) = \\sum_i U_i^e \\nabla\\hat{\\phi}_i(\\hat{x}_q) = 0$ for all four Gauss points $\\hat{x}_q$. This imposes $4 \\times 2 = 8$ linear constraints on the $4$ nodal values $U_i^e$ of the element. The only solution is the trivial one, $U_i^e=0$ for all $i$. No element-level zero-energy modes can exist. The quadrature rule is \"strong\" enough to detect the energy of all possible deformation modes, including the hourglass mode. This stability ensures that despite the inexactness, the assembled element matrices (and thus the global matrix $A_I$) remain positive definite.", "answer": "```python\nimport numpy as np\n\ndef get_q1_ref_grads(xi, eta):\n    \"\"\"\n    Computes the gradients of the Q1 basis functions on the reference\n    element [-1,1]^2 at the point (xi, eta).\n    The basis functions are ordered for nodes (-1,-1), (1,-1), (1,1), (-1,1).\n    \"\"\"\n    dphi_dxi = np.array([\n        -0.25 * (1.0 - eta),\n         0.25 * (1.0 - eta),\n         0.25 * (1.0 + eta),\n        -0.25 * (1.0 + eta)\n    ])\n    dphi_deta = np.array([\n        -0.25 * (1.0 - xi),\n        -0.25 * (1.0 + xi),\n         0.25 * (1.0 + xi),\n         0.25 * (1.0 - xi)\n    ])\n    return np.vstack((dphi_dxi, dphi_deta)).T\n\ndef get_p1_ref_grads():\n    \"\"\"\n    Returns the constant gradients of P1 basis functions on the reference\n    triangle (0,0), (1,0), (0,1).\n    \"\"\"\n    return np.array([[-1.0, -1.0], [1.0, 0.0], [0.0, 1.0]])\n\ndef get_quad_rule(rule_type):\n    \"\"\"Returns quadrature points and weights for a given rule type.\"\"\"\n    if rule_type == 'tri_1':\n        # 1-point centroid rule for reference triangle\n        return np.array([[1.0/3.0, 1.0/3.0]]), np.array([0.5])\n    elif rule_type == 'quad_1x1':\n        # 1x1 Gauss rule for reference square [-1,1]^2\n        return np.array([[0.0, 0.0]]), np.array([4.0])\n    elif rule_type == 'quad_2x2':\n        # 2x2 Gauss rule for reference square [-1,1]^2\n        a = 1.0 / np.sqrt(3.0)\n        points = np.array([[-a, -a], [a, -a], [a, a], [-a, a]])\n        weights = np.array([1.0, 1.0, 1.0, 1.0])\n        return points, weights\n    else:\n        raise ValueError(\"Unknown quadrature rule type\")\n\ndef assemble_and_test(N, element_type, distortion_alpha, quad_rule_type):\n    \"\"\"\n    Main function to assemble the stiffness matrix and test for coercivity.\n    \"\"\"\n    # 1. Generate Mesh\n    Nx = Ny = N\n    num_nodes = (Nx + 1) * (Ny + 1)\n    x = np.linspace(0.0, 1.0, Nx + 1)\n    y = np.linspace(0.0, 1.0, Ny + 1)\n    X, Y = np.meshgrid(x, y)\n    node_coords = np.vstack([X.ravel(), Y.ravel()]).T\n\n    if distortion_alpha > 0:\n        # Apply smooth distortion to interior nodes\n        is_interior_node = (node_coords[:, 0] > 1e-9)  (node_coords[:, 0]  1-1e-9)  \\\n                           (node_coords[:, 1] > 1e-9)  (node_coords[:, 1]  1-1e-9)\n        interior_coords = node_coords[is_interior_node]\n        delta_x = distortion_alpha * np.sin(np.pi * interior_coords[:, 0]) * np.sin(np.pi * interior_coords[:, 1])\n        delta_y = delta_x\n        \n        node_coords[is_interior_node, 0] += delta_x\n        node_coords[is_interior_node, 1] += delta_y\n\n    # 2. Define Element Connectivity\n    elements = []\n    if element_type == 'P1':\n        for j in range(Ny):\n            for i in range(Nx):\n                n0 = j * (Nx + 1) + i\n                n1 = j * (Nx + 1) + (i + 1)\n                n2 = (j + 1) * (Nx + 1) + i\n                n3 = (j + 1) * (Nx + 1) + (i + 1)\n                elements.append([n0, n1, n3]) # Tri 1\n                elements.append([n0, n3, n2]) # Tri 2\n    elif element_type == 'Q1':\n        for j in range(Ny):\n            for i in range(Nx):\n                n0 = j * (Nx + 1) + i\n                n1 = j * (Nx + 1) + (i + 1)\n                n2 = (j + 1) * (Nx + 1) + (i + 1)\n                n3 = (j + 1) * (Nx + 1) + i\n                elements.append([n0, n1, n2, n3]) # CCW order\n    \n    elements = np.array(elements)\n    num_local_nodes = elements.shape[1]\n\n    # 3. Assemble Global Stiffness Matrix\n    A = np.zeros((num_nodes, num_nodes))\n    kappa = 1.0\n    quad_points, quad_weights = get_quad_rule(quad_rule_type)\n\n    for el_nodes in elements:\n        el_coords = node_coords[el_nodes]\n        A_e = np.zeros((num_local_nodes, num_local_nodes))\n\n        for q_idx, q_point in enumerate(quad_points):\n            w_q = quad_weights[q_idx]\n\n            if element_type == 'P1':\n                # Affine mapping from ref tri (0,0),(1,0),(0,1)\n                v1, v2, v3 = el_coords[0], el_coords[1], el_coords[2]\n                J = np.array([\n                    [v2[0] - v1[0], v3[0] - v1[0]],\n                    [v2[1] - v1[1], v3[1] - v1[1]]\n                ])\n                dphi_dxi_ref = get_p1_ref_grads()\n            elif element_type == 'Q1':\n                # Bilinear mapping from ref square [-1,1]^2\n                xi, eta = q_point\n                # Grads of basis functions wrt ref coords\n                dphi_ref_at_q = get_q1_ref_grads(xi, eta)\n                # Jacobian of map from ref to physical element\n                J = el_coords.T @ dphi_ref_at_q\n                dphi_dxi_ref = dphi_ref_at_q\n            \n            detJ = np.linalg.det(J)\n            if detJ = 0:\n                raise RuntimeError(\"Jacobian determinant is non-positive.\")\n            invJ_T = np.linalg.inv(J).T\n\n            # Grads of basis functions wrt physical coords\n            B = invJ_T @ dphi_dxi_ref.T\n            A_e += kappa * (B.T @ B) * detJ * w_q\n\n        # Add element matrix to global matrix\n        global_indices = np.ix_(el_nodes, el_nodes)\n        A[global_indices] += A_e\n\n    # 4. Apply Boundary Conditions and Test Coercivity\n    is_boundary = (np.isclose(node_coords[:, 0], 0.0)) | (np.isclose(node_coords[:, 0], 1.0)) | \\\n                  (np.isclose(node_coords[:, 1], 0.0)) | (np.isclose(node_coords[:, 1], 1.0))\n    interior_indices = np.where(~is_boundary)[0]\n    \n    A_I = A[np.ix_(interior_indices, interior_indices)]\n\n    if A_I.shape[0] == 0:\n        return True # No interior nodes, trivially coercive\n\n    min_eig = np.min(np.linalg.eigvalsh(A_I))\n    \n    return min_eig > 1e-12\n\ndef solve():\n    \"\"\"\n    Runs the five test cases as specified in the problem statement.\n    \"\"\"\n    test_cases = [\n        # T1: P1, uniform 6x6, 1-pt centroid\n        {'N': 6, 'element_type': 'P1', 'distortion_alpha': 0.0, 'quad_rule_type': 'tri_1'},\n        # T2: Q1, uniform 6x6, 1x1 Gauss\n        {'N': 6, 'element_type': 'Q1', 'distortion_alpha': 0.0, 'quad_rule_type': 'quad_1x1'},\n        # T3: Q1, uniform 6x6, 2x2 Gauss\n        {'N': 6, 'element_type': 'Q1', 'distortion_alpha': 0.0, 'quad_rule_type': 'quad_2x2'},\n        # T4: Q1, distorted 6x6 (alpha=0.2), 1x1 Gauss\n        {'N': 6, 'element_type': 'Q1', 'distortion_alpha': 0.2, 'quad_rule_type': 'quad_1x1'},\n        # T5: Q1, distorted 6x6 (alpha=0.2), 2x2 Gauss\n        {'N': 6, 'element_type': 'Q1', 'distortion_alpha': 0.2, 'quad_rule_type': 'quad_2x2'},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = assemble_and_test(**case)\n        results.append(result)\n\n    # Format the final output string\n    print(f\"[{','.join(str(r).capitalize() for r in results)}]\")\n\nsolve()\n```", "id": "3364951"}]}