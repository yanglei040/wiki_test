{"hands_on_practices": [{"introduction": "The first step in mastering a numerical method is to understand its construction from fundamental principles. This exercise guides you through the derivation of the Crank-Nicolson scheme for the heat equation, a foundational model for diffusion processes. You will translate the abstract definition of the method, which involves averaging a spatial operator over two time levels, into a concrete linear system of the form $A\\mathbf{u}^{n+1} = B\\mathbf{u}^{n}$ [@problem_id:3375879]. Particular attention is paid to implementing Neumann boundary conditions using ghost points, a common and powerful technique for handling derivative boundary conditions in finite difference methods.", "problem": "Consider the heat equation, a Partial Differential Equation (PDE),\n$$u_{t}(x,t)=\\kappa\\,u_{xx}(x,t),\\qquad x\\in[0,1],\\ t>0,$$\nwith homogeneous Neumann boundary conditions\n$$u_{x}(0,t)=0,\\qquad u_{x}(1,t)=0,$$\nand a given initial condition $u(x,0)=u_{0}(x)$. Let the spatial interval $[0,1]$ be partitioned uniformly into $M$ subintervals with mesh width $h=\\frac{1}{M}$ and grid points $x_{j}=j\\,h$ for $j=0,1,\\dots,M$. Let time be discretized uniformly as $t^{n}=n\\,\\Delta t$ for $n=0,1,2,\\dots$.\n\nStarting from the definition of the second spatial derivative and the trapezoidal rule for time integration of the semi-discrete Ordinary Differential Equation (ODE) system, construct the Crank–Nicolson finite-difference scheme for the unknowns $u_{j}^{n}\\approx u(x_{j},t^{n})$ using centered second-order finite differences in space. Treat the Neumann boundary conditions by introducing ghost points and enforce $u_{x}(0,t)=0$ and $u_{x}(1,t)=0$ via second-order centered differences, eliminating ghost values to obtain a closed linear system for $\\{u_{j}^{n+1}\\}_{j=0}^{M}$. Write the resulting linear system at time level $t^{n+1}$ in the form\n$$A\\,\\mathbf{u}^{n+1}=B\\,\\mathbf{u}^{n},$$\nwhere $\\mathbf{u}^{n}=(u_{0}^{n},u_{1}^{n},\\dots,u_{M}^{n})^{\\top}$, and explicitly specify how the ghost-point conditions modify the first and last equations compared to interior points.\n\nFinally, from your constructed system, extract and report the coefficient multiplying $u_{0}^{n+1}$ in the first equation (corresponding to $j=0$) on the left-hand side matrix $A$. Express your answer as a single simplified symbolic expression in terms of $\\kappa$, $\\Delta t$, and $h$. No numerical evaluation is required.", "solution": "The problem is to construct the Crank-Nicolson finite-difference scheme for the one-dimensional heat equation $u_{t}=\\kappa\\,u_{xx}$ with homogeneous Neumann boundary conditions and to determine a specific coefficient in the resulting linear system.\n\nThe derivation proceeds in several steps:\n1.  Semi-discretization of the PDE in space.\n2.  Application of the trapezoidal rule (Crank-Nicolson method) for time integration.\n3.  Implementation of the Neumann boundary conditions using ghost points.\n4.  Assembly of the final linear system and extraction of the required coefficient.\n\nFirst, we perform a semi-discretization in space. The spatial domain is discretized with points $x_{j}=j\\,h$ for $j=0, 1, \\dots, M$, where $h=1/M$. Let $u_{j}(t)$ be the numerical approximation to $u(x_{j},t)$. We approximate the second spatial derivative $u_{xx}$ at an interior grid point $x_j$ using a second-order centered finite difference:\n$$ u_{xx}(x_j, t) \\approx \\frac{u(x_{j+1},t) - 2u(x_j, t) + u(x_{j-1},t)}{h^2} $$\nSubstituting this into the heat equation $u_{t}=\\kappa\\,u_{xx}$ yields a system of ordinary differential equations (ODEs) for the unknown functions $u_j(t)$:\n$$ \\frac{du_{j}}{dt} = \\kappa \\frac{u_{j+1}(t) - 2u_j(t) + u_{j-1}(t)}{h^2}, \\quad \\text{for } j=1, \\dots, M-1 $$\n\nNext, we discretize in time. The Crank-Nicolson method is equivalent to applying the trapezoidal rule for the time integration of the semi-discrete system. For an equation of the form $\\frac{d\\mathbf{u}}{dt} = \\mathbf{F}(\\mathbf{u})$, the trapezoidal rule from time $t^n=n\\,\\Delta t$ to $t^{n+1}=(n+1)\\,\\Delta t$ is:\n$$ \\frac{\\mathbf{u}^{n+1} - \\mathbf{u}^{n}}{\\Delta t} = \\frac{1}{2}\\left(\\mathbf{F}(\\mathbf{u}^{n+1}) + \\mathbf{F}(\\mathbf{u}^{n})\\right) $$\nwhere $u_j^n \\approx u_j(t^n)$. Applying this to the $j$-th component of our semi-discrete system gives:\n$$ \\frac{u_{j}^{n+1} - u_{j}^{n}}{\\Delta t} = \\frac{\\kappa}{2} \\left[ \\left( \\frac{u_{j+1}^{n+1} - 2u_{j}^{n+1} + u_{j-1}^{n+1}}{h^2} \\right) + \\left( \\frac{u_{j+1}^{n} - 2u_{j}^{n} + u_{j-1}^{n}}{h^2} \\right) \\right] $$\nLet's define the diffusion number $r = \\frac{\\kappa\\,\\Delta t}{h^2}$. Multiplying the equation by $\\Delta t$ and rearranging to separate terms at time level $n+1$ (left-hand side) and $n$ (right-hand side):\n$$ u_{j}^{n+1} - \\frac{r}{2} \\left( u_{j+1}^{n+1} - 2u_{j}^{n+1} + u_{j-1}^{n+1} \\right) = u_{j}^{n} + \\frac{r}{2} \\left( u_{j+1}^{n} - 2u_{j}^{n} + u_{j-1}^{n} \\right) $$\nThis simplifies to the stencil for an interior point $j \\in \\{1, \\dots, M-1\\}$:\n$$ -\\frac{r}{2} u_{j-1}^{n+1} + (1+r) u_{j}^{n+1} - \\frac{r}{2} u_{j+1}^{n+1} = \\frac{r}{2} u_{j-1}^{n} + (1-r) u_{j}^{n} + \\frac{r}{2} u_{j+1}^{n} $$\n\nNow, we must incorporate the homogeneous Neumann boundary conditions, $u_x(0,t)=0$ and $u_x(1,t)=0$. We use second-order centered differences and ghost points.\nAt the left boundary $x_0=0$, we introduce a ghost point at $x_{-1}=-h$. The centered difference approximation for the derivative is:\n$$ u_x(x_0, t) \\approx \\frac{u(x_1, t) - u(x_{-1}, t)}{2h} = 0 $$\nThis implies $u(x_{-1}, t) = u(x_1, t)$. At any time level $n$, this gives the condition $u_{-1}^n = u_1^n$. This relation holds for all time levels, thus $u_{-1}^{n+1} = u_1^{n+1}$.\n\nAt the right boundary $x_M=1$, we introduce a ghost point at $x_{M+1}=1+h$. The centered difference is:\n$$ u_x(x_M, t) \\approx \\frac{u(x_{M+1}, t) - u(x_{M-1}, t)}{2h} = 0 $$\nThis implies $u(x_{M+1}, t) = u(x_{M-1}, t)$, which gives $u_{M+1}^n = u_{M-1}^n$ and $u_{M+1}^{n+1} = u_{M-1}^{n+1}$ for all $n$.\n\nWe now construct the equations for the boundary points $j=0$ and $j=M$.\nFor an equation at $j=0$, we use the general interior stencil and substitute the ghost point condition $u_{-1}^{n+1} = u_1^{n+1}$ and $u_{-1}^n = u_1^n$:\n$$ -\\frac{r}{2} u_{-1}^{n+1} + (1+r) u_0^{n+1} - \\frac{r}{2} u_1^{n+1} = \\frac{r}{2} u_{-1}^{n} + (1-r) u_0^{n} + \\frac{r}{2} u_1^{n} $$\nSubstituting $u_{-1}^{n+1} = u_1^{n+1}$ on the left-hand side:\n$$ -\\frac{r}{2} u_{1}^{n+1} + (1+r) u_0^{n+1} - \\frac{r}{2} u_1^{n+1} = (1+r) u_0^{n+1} - r u_1^{n+1} $$\nSubstituting $u_{-1}^{n} = u_1^{n}$ on the right-hand side:\n$$ \\frac{r}{2} u_{1}^{n} + (1-r) u_0^{n} + \\frac{r}{2} u_1^{n} = (1-r) u_0^{n} + r u_1^{n} $$\nThus, the full equation for $j=0$ is:\n$$ (1+r) u_0^{n+1} - r u_1^{n+1} = (1-r) u_0^{n} + r u_1^{n} $$\nThis is the first row of the linear system $A\\mathbf{u}^{n+1}=B\\mathbf{u}^{n}$. The ghost point condition modifies the standard interior equation by combining the terms for the neighbors: the coefficient of $u_1^{n+1}$ becomes $-r$ instead of $-\\frac{r}{2}$.\n\nFor completeness, for the equation at $j=M$, we substitute $u_{M+1}^{n+1} = u_{M-1}^{n+1}$ and $u_{M+1}^n = u_{M-1}^n$ into the general stencil:\n$$ -r u_{M-1}^{n+1} + (1+r) u_M^{n+1} = r u_{M-1}^{n} + (1-r) u_M^{n} $$\nThis is the last row of the linear system.\n\nThe problem asks for the coefficient multiplying $u_0^{n+1}$ in the first equation of the system $A\\mathbf{u}^{n+1}=B\\mathbf{u}^{n}$. This corresponds to the equation for $j=0$. From our derived equation for $j=0$:\n$$ (1+r) u_0^{n+1} - r u_1^{n+1} = \\dots $$\nThe coefficient of $u_0^{n+1}$ is $(1+r)$. Substituting the definition of $r=\\frac{\\kappa\\,\\Delta t}{h^2}$:\n$$ \\text{Coefficient} = 1 + \\frac{\\kappa\\,\\Delta t}{h^2} $$\nThis is the desired symbolic expression.", "answer": "$$\\boxed{1 + \\frac{\\kappa\\,\\Delta t}{h^2}}$$", "id": "3375879"}, {"introduction": "A key selling point of the Crank-Nicolson method is its second-order accuracy in time, offering a significant improvement over first-order methods like Forward or Backward Euler. However, a theoretical property is only useful if it can be confirmed in practice. This computational exercise challenges you to design and execute a numerical experiment to verify this $\\mathcal{O}(\\Delta t^2)$ accuracy [@problem_id:3220441]. By using Fourier analysis on periodic problems, you can elegantly isolate temporal discretization error from spatial error, allowing for a clean and convincing measurement of the method's convergence rate.", "problem": "You are asked to verify, by computation, the temporal second-order accuracy of the Crank–Nicolson method (Crank–Nicolson (CN) is the trapezoidal rule in time) for linear constant-coefficient partial differential equations (PDEs) while ensuring that spatial discretization error is negligible. Work on the one-dimensional periodic domain $[0,2\\pi]$ and use a Fourier spectral representation for spatial operators so that each Fourier mode evolves independently and spatial differentiation is exact for the chosen initial data.\n\nStarting point and fundamental base: On a periodic domain, a sufficiently smooth function can be expanded in a Fourier series, and constant-coefficient spatial differential operators are diagonal in the Fourier basis. For any linear time-invariant system $u_t = \\mathcal{L} u$, where $\\mathcal{L}$ is a linear spatial operator with constant coefficients, each Fourier mode amplitude $a_k(t)$ satisfies the ordinary differential equation (ODE) $a_k'(t) = \\lambda_k a_k(t)$, where $\\lambda_k$ is the eigenvalue of $\\mathcal{L}$ for wavenumber $k$. The exact solution for a single mode is $a_k(t) = e^{\\lambda_k t} a_k(0)$. The Crank–Nicolson time discretization for an ODE with continuously differentiable right-hand side has local truncation error of order $\\mathcal{O}(\\Delta t^3)$, leading to a global error of order $\\mathcal{O}(\\Delta t^2)$ in time under standard smoothness assumptions.\n\nYour tasks:\n\n1) Spatial model and diagonalization. Consider the following three PDEs on $[0,2\\pi]$ with periodic boundary conditions and initial condition $u(x,0) = e^{\\mathrm{i} k x}$ for a specified integer mode $k$:\n   - Diffusion equation: $u_t = \\nu u_{xx}$ with diffusivity $\\nu > 0$.\n   - Free Schrödinger equation: $\\mathrm{i} \\psi_t = -\\alpha \\psi_{xx}$ with dispersion coefficient $\\alpha > 0$.\n   - Advection–diffusion equation: $u_t + c u_x = \\nu u_{xx}$ with advection speed $c \\in \\mathbb{R}$ and diffusivity $\\nu > 0$.\n\n   Using Fourier series on $[0,2\\pi]$, derive the associated modal ODE for the amplitude $a_k(t)$ of the Fourier mode $e^{\\mathrm{i} k x}$ in each PDE and identify the modal growth/decay rate $\\lambda_k$ in $a_k'(t) = \\lambda_k a_k(t)$.\n\n2) Time discretization. Apply the Crank–Nicolson discretization in time to the modal ODE $a_k'(t) = \\lambda_k a_k(t)$. Express the one-step update in terms of the previous step $a_k^n$ and time-step size $\\Delta t$ and obtain a closed-form formula for the one-step amplification factor in terms of $\\lambda_k$ and $\\Delta t$. Use this to advance $M$ steps to approximate $a_k(T)$ at time $T$.\n\n3) Error measurement and observed order. For each PDE, perform a temporal refinement study using time-step sizes $\\Delta t = T/M$ for the refinement levels $M \\in \\{10,20,40,80,160\\}$. For each $\\Delta t$, compute the numerical amplitude at time $T$ and compare it to the exact amplitude $e^{\\lambda_k T}$, measuring the absolute error $E(\\Delta t) = \\lvert a_k^{\\text{num}}(T) - e^{\\lambda_k T} \\rvert$. Estimate the observed order $p$ by fitting a straight line to $(\\log(\\Delta t), \\log(E(\\Delta t)))$ via least squares and taking the slope, which should be close to $2$ if the method is second order in time. Because the initial condition is a single Fourier mode exactly represented on the grid and the spatial operator is diagonal in Fourier space, the spatial discretization error for this test is negligible.\n\nTest suite specifications:\n\n- Domain: $[0,2pi]$ with periodic boundary conditions.\n- Initial condition for all cases: $u(x,0) = e^{\\mathrm{i} k x}$ with the specified integer $k$ below.\n- Refinement levels: $M \\in \\{10,20,40,80,160\\}$ so that $\\Delta t = T/M$.\n- Cases to test:\n  1) Diffusion: $\\nu = 0.5$, $k = 3$, $T = 1.0$.\n  2) Free Schrödinger: $\\alpha = 0.7$, $k = 4$, $T = 2.0$.\n  3) Advection–diffusion: $c = 2.0$, $\\nu = 0.1$, $k = 5$, $T = 1.5$.\n\nAnswer specification and output format:\n\n- For each case, return the observed order $p$ as a floating-point number computed from the least-squares slope of $\\log(E(\\Delta t))$ versus $\\log(\\Delta t)$.\n- Your program should produce a single line of output containing the three observed orders, in the order listed above, rounded to three decimal places, formatted as a comma-separated Python-style list, for example: `[2.000,2.001,1.999]`.\n- No physical units are involved in this task. Angles (if any) are in radians by construction due to the domain choice $[0,2\\pi]$.\n\nYour final deliverable must be a complete, runnable program that carries out these computations exactly for the test suite above and prints the results in the required one-line format. No user input or external files are allowed. Use only the specified libraries.", "solution": "The problem statement has been validated and is deemed sound, well-posed, and complete. We now proceed with the solution. The core of this problem is to computationally verify the second-order temporal accuracy of the Crank-Nicolson method for several linear partial differential equations (PDEs). The problem is structured such that spatial discretization errors are eliminated by design, allowing for a pure assessment of the temporal error. This is achieved by using an initial condition that is a single Fourier mode, which is an eigenfunction of the constant-coefficient linear spatial operators involved.\n\n**1. Modal Analysis and Eigenvalue Derivation**\n\nWe consider a solution of the form $u(x,t) = a_k(t) e^{\\mathrm{i} k x}$ on the periodic domain $[0, 2\\pi]$ for an integer wavenumber $k$. The initial condition $u(x,0) = e^{\\mathrm{i} k x}$ implies that the initial amplitude of the $k$-th mode is $a_k(0) = 1$, and all other modal amplitudes are zero. Since the governing PDEs are linear, the modes evolve independently. We can analyze the evolution of the single non-zero mode $a_k(t)$ by substituting the solution form into each PDE.\n\nThe spatial derivatives are:\n$$\n\\frac{\\partial u}{\\partial x} = \\frac{\\partial}{\\partial x} \\left( a_k(t) e^{\\mathrm{i} k x} \\right) = \\mathrm{i} k a_k(t) e^{\\mathrm{i} k x}\n$$\n$$\n\\frac{\\partial^2 u}{\\partial x^2} = \\frac{\\partial^2}{\\partial x^2} \\left( a_k(t) e^{\\mathrm{i} k x} \\right) = (\\mathrm{i} k)^2 a_k(t) e^{\\mathrm{i} k x} = -k^2 a_k(t) e^{\\mathrm{i} k x}\n$$\nThe time derivative is $\\frac{\\partial u}{\\partial t} = a_k'(t) e^{\\mathrm{i} k x}$.\n\nFor each PDE of the form $u_t = \\mathcal{L}u$, substituting the modal form yields $a_k'(t) e^{\\mathrm{i} k x} = \\mathcal{L}(a_k(t) e^{\\mathrm{i} k x}) = a_k(t) \\mathcal{L}(e^{\\mathrm{i} k x})$. Since $e^{\\mathrm{i} k x}$ is an eigenfunction of the spatial operator $\\mathcal{L}$, we have $\\mathcal{L}(e^{\\mathrm{i} k x}) = \\lambda_k e^{\\mathrm{i} k x}$, where $\\lambda_k$ is the eigenvalue. This simplifies the PDE to a linear ordinary differential equation (ODE) for the amplitude $a_k(t)$:\n$$\na_k'(t) = \\lambda_k a_k(t)\n$$\nThe exact solution to this ODE with initial condition $a_k(0)=1$ is $a_k(t) = e^{\\lambda_k t}$.\n\nWe now determine $\\lambda_k$ for each specified PDE.\n\n- **Diffusion equation**: $u_t = \\nu u_{xx}$\n  $a_k'(t) e^{\\mathrm{i} k x} = \\nu (-k^2 a_k(t) e^{\\mathrm{i} k x})$. Dividing by $e^{\\mathrm{i} k x}$ gives $a_k'(t) = (-\\nu k^2) a_k(t)$.\n  Thus, the eigenvalue is $\\lambda_k = -\\nu k^2$.\n\n- **Free Schrödinger equation**: $\\mathrm{i} \\psi_t = -\\alpha \\psi_{xx}$. Let the solution be $\\psi(x,t) = a_k(t) e^{\\mathrm{i} k x}$.\n  The equation is equivalent to $\\psi_t = \\frac{-\\alpha}{\\mathrm{i}} \\psi_{xx} = \\mathrm{i} \\alpha \\psi_{xx}$.\n  $a_k'(t) e^{\\mathrm{i} k x} = \\mathrm{i} \\alpha (-k^2 a_k(t) e^{\\mathrm{i} k x})$. This gives $a_k'(t) = (-\\mathrm{i} \\alpha k^2) a_k(t)$.\n  Thus, the eigenvalue is $\\lambda_k = -\\mathrm{i} \\alpha k^2$.\n  (Note: The problem statement says $\\mathrm{i} \\psi_t = -\\alpha \\psi_{xx}$. Substituting gives $\\mathrm{i} a_k' = -\\alpha (-k^2) a_k = \\alpha k^2 a_k$, so $a_k' = \\frac{\\alpha k^2}{\\mathrm{i}} a_k = -\\mathrm{i} \\alpha k^2 a_k$. The result is the same).\n\n- **Advection–diffusion equation**: $u_t + c u_x = \\nu u_{xx}$, or $u_t = -c u_x + \\nu u_{xx}$.\n  $a_k'(t) e^{\\mathrm{i} k x} = -c (\\mathrm{i} k a_k(t) e^{\\mathrm{i} k x}) + \\nu (-k^2 a_k(t) e^{\\mathrm{i} k x})$.\n  This gives $a_k'(t) = (-\\mathrm{i} c k - \\nu k^2) a_k(t)$.\n  Thus, the eigenvalue is $\\lambda_k = -\\nu k^2 - \\mathrm{i} c k$.\n\n**2. Crank-Nicolson Time Discretization**\n\nThe Crank-Nicolson method is an implicit method for integrating ODEs, equivalent to the trapezoidal rule. For the ODE $a' = \\lambda a$, the discretization over a time step $\\Delta t$ from $t_n$ to $t_{n+1}$ is:\n$$\n\\frac{a^{n+1} - a^n}{\\Delta t} = \\frac{1}{2} \\left( \\lambda a^{n+1} + \\lambda a^n \\right)\n$$\nwhere $a^n \\approx a(t_n)$. We solve for $a^{n+1}$:\n$$\na^{n+1} \\left( 1 - \\frac{\\lambda \\Delta t}{2} \\right) = a^n \\left( 1 + \\frac{\\lambda \\Delta t}{2} \\right)\n$$\nThis gives the explicit update formula for a single step:\n$$\na^{n+1} = \\left( \\frac{1 + \\lambda \\Delta t / 2}{1 - \\lambda \\Delta t / 2} \\right) a^n\n$$\nThe term $G(\\lambda, \\Delta t) = \\frac{1 + \\lambda \\Delta t / 2}{1 - \\lambda \\Delta t / 2}$ is the one-step amplification factor. To advance from time $t=0$ to $T = M \\Delta t$ in $M$ steps, we apply this factor $M$ times. With $a^0 = a_k(0) = 1$, the numerical solution at time $T$ is:\n$$\na_k^{\\text{num}}(T) = a^M = (G(\\lambda_k, \\Delta t))^M a^0 = \\left( \\frac{1 + \\lambda_k \\Delta t / 2}{1 - \\lambda_k \\Delta t / 2} \\right)^M\n$$\n\n**3. Error Analysis and Observed Order of Accuracy**\n\nThe method's global error is expected to be second-order in time, meaning the error $E(\\Delta t)$ at a fixed time $T$ behaves as $E(\\Delta t) \\approx C (\\Delta t)^p$ for some constant $C$ and order $p \\approx 2$. The absolute error is defined as:\n$$\nE(\\Delta t) = \\lvert a_k^{\\text{num}}(T) - a_k(T) \\rvert = \\left| \\left( \\frac{1 + \\lambda_k \\Delta t / 2}{1 - \\lambda_k \\Delta t / 2} \\right)^M - e^{\\lambda_k T} \\right|\n$$\nTo determine the observed order $p$, we take the logarithm of the error relation:\n$$\n\\log(E(\\Delta t)) \\approx \\log(C) + p \\log(\\Delta t)\n$$\nThis shows a linear relationship between $\\log(E)$ and $\\log(\\Delta t)$, with the slope being the order of accuracy $p$. We will compute the error for a sequence of time steps $\\Delta t_i = T/M_i$ where $M_i \\in \\{10, 20, 40, 80, 160\\}$. Then, we perform a linear least-squares fit to the data points $(\\log(\\Delta t_i), \\log(E_i))$ to find the slope $p$.\n\nThe computational procedure is as follows for each test case:\n1.  Calculate the eigenvalue $\\lambda_k$ using the given parameters.\n2.  Define the set of refinement levels $M_i$.\n3.  For each $M_i$, calculate the time step $\\Delta t_i = T/M_i$.\n4.  Compute the numerical solution $a_k^{\\text{num}}(T) = \\left( \\frac{1 + \\lambda_k \\Delta t_i / 2}{1 - \\lambda_k \\Delta t_i / 2} \\right)^{M_i}$.\n5.  Compute the exact solution $a_k(T) = e^{\\lambda_k T}$.\n6.  Calculate the absolute error $E_i = |a_k^{\\text{num}}(T) - a_k(T)|$.\n7.  Form two vectors: $x = [\\log(\\Delta t_i)]$ and $y = [\\log(E_i)]$.\n8.  Calculate the slope $p$ of the best-fit line for $(x, y)$, which is the observed order. This will be accomplished using `numpy.polyfit`.\nThe calculations will be performed for the three specified cases.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_observed_order(lambda_k, T, M_levels):\n    \"\"\"\n    Computes the observed order of accuracy for the Crank-Nicolson method.\n\n    Args:\n        lambda_k (complex): The eigenvalue of the spatial operator for mode k.\n        T (float): The final time for the simulation.\n        M_levels (np.ndarray): An array of integers representing the number of time steps.\n\n    Returns:\n        float: The observed order of accuracy, p.\n    \"\"\"\n    delta_ts = T / M_levels\n    errors = np.zeros_like(delta_ts, dtype=float)\n\n    # Calculate the exact solution at time T\n    exact_solution = np.exp(lambda_k * T)\n\n    for i, M in enumerate(M_levels):\n        dt = delta_ts[i]\n        \n        # Calculate the one-step amplification factor\n        z = lambda_k * dt / 2.0\n        amplification_factor = (1.0 + z) / (1.0 - z)\n        \n        # Compute the numerical solution at time T\n        # Initial condition a_k(0) = 1 is implicit\n        numerical_solution = amplification_factor**M\n        \n        # Compute the absolute error\n        errors[i] = np.abs(numerical_solution - exact_solution)\n\n    # Perform a least-squares fit on the log-log data to find the slope\n    log_delta_ts = np.log(delta_ts)\n    log_errors = np.log(errors)\n    \n    # np.polyfit returns [slope, intercept] for degree 1\n    p, _ = np.polyfit(log_delta_ts, log_errors, 1)\n    \n    return p\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # Refinement levels for the temporal grid\n    M_levels = np.array([10, 20, 40, 80, 160])\n    \n    # --- Test Case 1: Diffusion Equation ---\n    # u_t = nu * u_xx\n    # Parameters: nu = 0.5, k = 3, T = 1.0\n    nu1 = 0.5\n    k1 = 3\n    T1 = 1.0\n    # Eigenvalue: lambda_k = -nu * k^2\n    lambda_k1 = -nu1 * k1**2\n    p1 = calculate_observed_order(lambda_k1, T1, M_levels)\n\n    # --- Test Case 2: Free Schrödinger Equation ---\n    # i * psi_t = -alpha * psi_xx  =>  psi_t = -i * alpha * psi_xx\n    # Parameters: alpha = 0.7, k = 4, T = 2.0\n    alpha2 = 0.7\n    k2 = 4\n    T2 = 2.0\n    # Eigenvalue: lambda_k = -i * alpha * k^2\n    lambda_k2 = -1j * alpha2 * k2**2\n    p2 = calculate_observed_order(lambda_k2, T2, M_levels)\n\n    # --- Test Case 3: Advection-Diffusion Equation ---\n    # u_t + c * u_x = nu * u_xx  => u_t = -c * u_x + nu * u_xx\n    # Parameters: c = 2.0, nu = 0.1, k = 5, T = 1.5\n    c3 = 2.0\n    nu3 = 0.1\n    k3 = 5\n    T3 = 1.5\n    # Eigenvalue: lambda_k = -nu * k^2 - i * c * k\n    lambda_k3 = -nu3 * k3**2 - 1j * c3 * k3\n    p3 = calculate_observed_order(lambda_k3, T3, M_levels)\n\n    results = [p1, p2, p3]\n\n    # Format the output as a list of strings with 3 decimal places\n    formatted_results = [f'{p:.3f}' for p in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3220441"}, {"introduction": "No numerical method is perfect, and understanding a method's limitations is as crucial as knowing its strengths. While the Crank-Nicolson method is celebrated for being A-stable and second-order accurate, it possesses a subtle weakness when applied to stiff problems, where physical processes evolve on vastly different time scales. This practice demonstrates that the method can introduce non-physical oscillations when a strong damping or reaction term is present, a consequence of it not being L-stable [@problem_id:3375886]. By contrasting its behavior with the more robust (though less accurate) Backward Euler scheme, you will gain a deeper insight into the practical nuances of numerical stability.", "problem": "Consider the one-dimensional linear reaction–diffusion partial differential equation on the periodic domain $[0,1]$,\n$$\nu_t(x,t) = u_{xx}(x,t) - \\lambda\\,u(x,t),\n$$\nwith spatial variable $x\\in[0,1]$, time $t\\ge 0$, and reaction coefficient $\\lambda \\ge 0$. Use second-order central finite differences in space on a uniform periodic grid of $N$ points to obtain a method-of-lines system of ordinary differential equations in time. Starting from the fundamental definition of the Crank–Nicolson method and backward Euler method for linear systems of ordinary differential equations, design a numerical experiment to reveal and quantify nonphysical temporal oscillations of the Crank–Nicolson time discretization when the reaction is stiff.\n\nYour task is to do all of the following:\n\n1) Spatial semi-discretization. On a uniform grid with $N$ points and periodic boundary conditions, approximate the Laplacian $u_{xx}$ by the standard second-order central difference operator. Denote the resulting discrete Laplacian matrix by $L\\in\\mathbb{R}^{N\\times N}$ and the discrete state vector at time level $n$ by $u^n\\in\\mathbb{R}^N$. The semi-discrete system takes the form\n$$\n\\frac{d}{dt} u(t) = A\\,u(t), \\quad \\text{with } A := L - \\lambda I,\n$$\nwhere $I$ is the identity matrix.\n\n2) Time discretizations from first principles. Starting from the definitions of the Crank–Nicolson method and the backward Euler method for a linear system $y'(t)=A\\,y(t)$, write down the fully discrete one-step update formulas mapping $u^n$ to $u^{n+1}$:\n- Crank–Nicolson: derive the implicit linear system that $u^{n+1}$ must satisfy in terms of $u^n$, time step $\\Delta t$, and matrix $A$.\n- Backward Euler: derive the implicit linear system that $u^{n+1}$ must satisfy in terms of $u^n$, time step $\\Delta t$, and matrix $A$.\n\nDo not assume any special properties of $A$ beyond those defined above, and do not use pre-derived amplification formulas; start from the definition of each method.\n\n3) Initial condition and overshoot metric. Use the spatially constant initial condition\n$$\nu(x,0) \\equiv 1,\n$$\nwhich is admissible under periodic boundary conditions and is nonnegative everywhere. Evolve a single time step to $t=\\Delta t$ with each method. Define the nonphysical overshoot amplitude after one time step by\n$$\n\\mathcal{O}(u^1) := \\frac{\\max\\{0,\\,-\\min_i u^1_i\\}}{\\max_i u^0_i},\n$$\nthat is, the magnitude of the most negative value produced, normalized by the initial maximum; this is a dimensionless quantity. For a physically consistent decay with this initial condition, the exact solution is nonnegative for all $t\\ge 0$, so any negativity in $u^1$ is nonphysical. Quantify how this overshoot amplitude depends on the dimensionless stiffness parameter\n$$\nz := \\lambda\\,\\Delta t.\n$$\n\n4) Test suite and required outputs. Fix $N=64$ grid points and a uniform grid on $[0,1]$ with periodic boundary conditions. Use a single time step of size $\\Delta t=0.1$. Construct the following four test cases, each specified by a target value of $z=\\lambda\\,\\Delta t$:\n- Case A (nonstiff): $z=0.5$.\n- Case B (threshold): $z=2.0$.\n- Case C (stiff): $z=6.0$.\n- Case D (very stiff): $z=100.0$.\nFor each case, choose $\\lambda = z/\\Delta t$ so that the prescribed $z$ is realized. For each case, compute:\n- The Crank–Nicolson overshoot amplitude $\\mathcal{O}_{\\mathrm{CN}}$ after one time step.\n- The backward Euler overshoot amplitude $\\mathcal{O}_{\\mathrm{BE}}$ after one time step.\n\n5) Final output format. Your program should produce a single line of output containing the results aggregated for the four cases in the order A, B, C, D, where each case contributes the pair $(\\mathcal{O}_{\\mathrm{CN}},\\mathcal{O}_{\\mathrm{BE}})$. The line must be a comma-separated list of eight floating-point numbers enclosed in square brackets, with the exact ordering:\n$$\n[\\mathcal{O}_{\\mathrm{CN}}(0.5),\\ \\mathcal{O}_{\\mathrm{BE}}(0.5),\\ \\mathcal{O}_{\\mathrm{CN}}(2.0),\\ \\mathcal{O}_{\\mathrm{BE}}(2.0),\\ \\mathcal{O}_{\\mathrm{CN}}(6.0),\\ \\mathcal{O}_{\\mathrm{BE}}(6.0),\\ \\mathcal{O}_{\\mathrm{CN}}(100.0),\\ \\mathcal{O}_{\\mathrm{BE}}(100.0)].\n$$\n\nAll numerical values are dimensionless, so no physical unit specification is required. Your implementation must be general, solving the implicit linear systems produced by each method for the given matrices, and must not rely on any closed-form solution or mode decoupling shortcut in the code. The code should run without any user input and must adhere to the final output format specified above.", "solution": "The problem as stated is a well-posed and scientifically sound exercise in numerical analysis, specifically focusing on the properties of time-stepping schemes for stiff systems of ordinary differential equations (ODEs) arising from the spatial semi-discretization of a partial differential equation (PDE). All necessary parameters and definitions are provided, and the task is objective and verifiable. The problem is therefore deemed valid and a full solution follows.\n\nThe core of the problem is to investigate the non-physical oscillations generated by the Crank-Nicolson (CN) method when applied to a stiff reaction-diffusion problem, and to contrast this behavior with the Backward Euler (BE) method. Stiffness arises from the reaction term $-\\lambda u(x,t)$ when the reaction coefficient $\\lambda$ is large.\n\n**1. Spatial Semi-discretization**\n\nWe begin by discretizing the spatial domain $x \\in [0,1]$ using a uniform grid of $N$ points, $x_i = i h$ for $i = 0, 1, \\dots, N-1$, where the grid spacing is $h = 1/N$. The value of the solution at grid point $x_i$ and time $t$ is denoted by $u_i(t) \\approx u(x_i, t)$. The periodic boundary conditions imply that indices are taken modulo $N$, i.e., $u_{i+N}(t) = u_i(t)$.\n\nThe second spatial derivative $u_{xx}$ at a point $x_i$ is approximated using a second-order central finite difference formula:\n$$\nu_{xx}(x_i, t) \\approx \\frac{u(x_{i+1}, t) - 2u(x_i, t) + u(x_{i-1}, t)}{h^2}\n$$\nApplying this to our discrete solution values $u_i(t)$, we get:\n$$\n(L u(t))_i = \\frac{1}{h^2} (u_{i+1}(t) - 2u_i(t) + u_{i-1}(t))\n$$\nwhere $u(t) = [u_0(t), u_1(t), \\dots, u_{N-1}(t)]^T$ is the vector of solution values at time $t$. The matrix $L \\in \\mathbb{R}^{N\\times N}$ represents the discrete Laplacian operator. Due to the periodic boundary conditions, $L$ is a circulant matrix. Its entries are given by:\n$$\nL_{ij} = \\frac{1}{h^2} \\begin{cases}\n-2 & \\text{if } i=j \\\\\n1 & \\text{if } |i-j| = 1 \\text{ or } |i-j| = N-1 \\\\\n0 & \\text{otherwise}\n\\end{cases}\n$$\nSubstituting this spatial discretization into the original PDE, $u_t = u_{xx} - \\lambda u$, yields a system of $N$ coupled ODEs, known as the method-of-lines system:\n$$\n\\frac{d}{dt} u(t) = L u(t) - \\lambda I u(t) = (L - \\lambda I) u(t)\n$$\nThis is of the form $\\frac{d}{dt}u(t) = A u(t)$, with the system matrix $A := L - \\lambda I$, where $I$ is the $N \\times N$ identity matrix.\n\n**2. Time Discretizations from First Principles**\n\nWe now discretize time. Let $t_n = n \\Delta t$ be the time at step $n$, and let $u^n \\approx u(t_n)$ be the numerical solution vector. We apply two different one-step methods to advance the solution from $t_n$ to $t_{n+1}$.\n\n**Backward Euler (BE) Method**: This is a first-order, implicit method. The time derivative at $t_{n+1}$ is approximated by a backward difference, and the right-hand side is evaluated at the new time level $t_{n+1}$:\n$$\n\\frac{u^{n+1} - u^n}{\\Delta t} = A u^{n+1}\n$$\nTo solve for $u^{n+1}$, we rearrange the terms, which yields a linear system of equations:\n$$\nu^{n+1} - \\Delta t A u^{n+1} = u^n \\implies (I - \\Delta t A) u^{n+1} = u^n\n$$\nThis implicit equation must be solved for $u^{n+1}$ at each time step.\n\n**Crank-Nicolson (CN) Method**: This is a second-order, implicit method that is an average of the forward Euler and backward Euler methods. It is equivalent to applying the trapezoidal rule to the ODE system. The time derivative is approximated at the midpoint $t_{n+1/2}$, and the right-hand side is the average of its evaluations at $t_n$ and $t_{n+1}$:\n$$\n\\frac{u^{n+1} - u^n}{\\Delta t} = \\frac{1}{2} \\left( A u^n + A u^{n+1} \\right)\n$$\nTo solve for $u^{n+1}$, we group the terms involving $u^{n+1}$ on the left-hand side and terms involving $u^n$ on the right-hand side:\n$$\nu^{n+1} - \\frac{\\Delta t}{2} A u^{n+1} = u^n + \\frac{\\Delta t}{2} A u^n \\implies \\left(I - \\frac{\\Delta t}{2} A\\right) u^{n+1} = \\left(I + \\frac{\\Delta t}{2} A\\right) u^n\n$$\nThis is also an implicit equation that requires solving a linear system for $u^{n+1}$ at each time step.\n\n**3. Initial Condition and Overshoot Metric**\n\nThe initial condition is $u(x,0) = 1$. In our discrete setting, this translates to the initial vector $u^0$ having all its components equal to $1$, i.e., $u^0 = \\mathbf{1}$. It is worth noting that this constant vector $\\mathbf{1}$ is an eigenvector of the discrete Laplacian $L$ with eigenvalue $0$, since for any row $i$, $(L \\mathbf{1})_i = \\frac{1}{h^2}(1 - 2(1) + 1) = 0$. Consequently, $u^0$ is an eigenvector of $A=L-\\lambda I$ with eigenvalue $-\\lambda$, as $A u^0 = L u^0 - \\lambda I u^0 = \\mathbf{0} - \\lambda u^0 = -\\lambda u^0$.\n\nThe exact solution to the PDE with this initial condition is $u(x,t) = e^{-\\lambda t}$, which is spatially uniform and decays monotonically to zero without ever becoming negative. Any negative values in the numerical solution $u^1$ are therefore non-physical artifacts of the discretization method.\n\nThe overshoot amplitude metric is defined as:\n$$\n\\mathcal{O}(u^1) := \\frac{\\max\\{0,\\,-\\min_i u^1_i\\}}{\\max_i u^0_i}\n$$\nGiven $u^0=\\mathbf{1}$, the denominator $\\max_i u^0_i = 1$. The metric simplifies to $\\mathcal{O}(u^1) = \\max\\{0, -\\min_i u^1_i\\}$, which is simply the magnitude of the largest negative component in the solution vector $u^1$, or zero if the solution remains non-negative. This metric is used to quantify the non-physical oscillations as a function of the dimensionless stiffness parameter $z = \\lambda \\Delta t$.\n\n**4. Numerical Experiment Design**\n\nThe experiment is conducted by implementing the setup described above for the specified parameters and test cases. The algorithm for each test case, characterized by a value of $z$, is as follows:\n\n1.  Set fixed parameters: $N=64$ and $\\Delta t = 0.1$. Calculate the grid spacing $h=1/N$.\n2.  For a given $z \\in \\{0.5, 2.0, 6.0, 100.0\\}$, compute the reaction coefficient $\\lambda = z / \\Delta t$.\n3.  Construct the $N \\times N$ discrete Laplacian matrix $L$ for the periodic domain.\n4.  Construct the system matrix $A = L - \\lambda I$.\n5.  Initialize the solution vector $u^0 = \\mathbf{1} \\in \\mathbb{R}^N$.\n6.  For the Crank-Nicolson method:\n    a.  Construct the system matrix $M_{CN} = I - \\frac{\\Delta t}{2} A$.\n    b.  Construct the right-hand side vector $b_{CN} = \\left(I + \\frac{\\Delta t}{2} A\\right) u^0$.\n    c.  Solve the linear system $M_{CN} u^1_{CN} = b_{CN}$ for $u^1_{CN}$.\n    d.  Compute the overshoot $\\mathcal{O}_{\\mathrm{CN}} = \\max\\{0, -\\min_i (u^1_{CN})_i\\}$.\n7.  For the Backward Euler method:\n    a.  Construct the system matrix $M_{BE} = I - \\Delta t A$.\n    b.  The right-hand side vector is simply $b_{BE} = u^0$.\n    c.  Solve the linear system $M_{BE} u^1_{BE} = b_{BE}$ for $u^1_{BE}$.\n    d.  Compute the overshoot $\\mathcal{O}_{\\mathrm{BE}} = \\max\\{0, -\\min_i (u^1_{BE})_i\\}$.\n8.  Collect and report the pair of values $(\\mathcal{O}_{\\mathrm{CN}}, \\mathcal{O}_{\\mathrm{BE}})$.\n\nThis procedure is repeated for all four specified values of $z$. The implementation will use a general-purpose linear solver and will not exploit the eigenvector property of the initial condition, as per the problem's constraints. This experiment will demonstrate that the BE method, being L-stable, produces no oscillations, while the CN method, being A-stable but not L-stable, produces significant non-physical oscillations for large $z$ (i.e., when the problem is stiff). The threshold for these oscillations is expected at $z=2$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import circulant\n\ndef solve():\n    \"\"\"\n    Solves the specified reaction-diffusion problem to quantify\n    overshoot in Crank-Nicolson vs. Backward Euler methods.\n    \"\"\"\n    # Define the problem parameters and test cases from the statement.\n    N = 64\n    dt = 0.1\n    # Test cases are specified by the dimensionless stiffness parameter z.\n    test_cases_z = [0.5, 2.0, 6.0, 100.0]\n\n    results = []\n\n    # Grid spacing for a periodic domain [0,1]\n    h = 1.0 / N\n\n    # Construct the discrete Laplacian matrix L for periodic boundary conditions.\n    # The matrix is circulant. Its first column fully defines it.\n    L_first_col = np.zeros(N)\n    factor = 1.0 / h**2\n    L_first_col[0] = -2.0 * factor\n    L_first_col[1] = 1.0 * factor\n    L_first_col[N - 1] = 1.0 * factor\n    L = circulant(L_first_col)\n\n    # Initial condition u(x,0) = 1\n    u0 = np.ones(N)\n\n    # Loop through each test case\n    for z in test_cases_z:\n        # Determine the reaction coefficient lambda for the target z\n        lambda_val = z / dt\n\n        # Construct the full semi-discrete system matrix A = L - lambda*I\n        I = np.identity(N)\n        A = L - lambda_val * I\n\n        # --- Crank-Nicolson Method ---\n        # The update rule is (I - dt/2 * A) * u1 = (I + dt/2 * A) * u0\n        # Form the matrix for the linear system to be solved.\n        M_cn = I - (dt / 2.0) * A\n        # Form the right-hand side vector.\n        b_cn = (I + (dt / 2.0) * A) @ u0\n        # Solve the linear system for u1.\n        u1_cn = np.linalg.solve(M_cn, b_cn)\n\n        # --- Backward Euler Method ---\n        # The update rule is (I - dt * A) * u1 = u0\n        # Form the matrix for the linear system.\n        M_be = I - dt * A\n        # The right-hand side is just u0.\n        b_be = u0\n        # Solve the linear system for u1.\n        u1_be = np.linalg.solve(M_be, b_be)\n\n        # --- Compute Overshoot Metrics ---\n        # The metric is O(u1) = max{0, -min(u1)} / max(u0).\n        # Since u0 is a vector of ones, max(u0) = 1.\n        \n        # Crank-Nicolson overshoot\n        min_u1_cn = np.min(u1_cn)\n        overshoot_cn = np.maximum(0.0, -min_u1_cn)\n        \n        # Backward Euler overshoot\n        min_u1_be = np.min(u1_be)\n        overshoot_be = np.maximum(0.0, -min_u1_be)\n        \n        # Append results for this case to the list\n        results.extend([overshoot_cn, overshoot_be])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3375886"}]}