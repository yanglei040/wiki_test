{"hands_on_practices": [{"introduction": "In the study of infinite-dimensional function spaces like Sobolev spaces, the distinction between weak and strong convergence is fundamental. This exercise provides a concrete example to make this abstract concept tangible, illustrating how a sequence of functions can converge weakly to a limit without converging strongly [@problem_id:3444217]. Understanding this phenomenon is crucial for analyzing the stability and convergence of numerical methods for PDEs, where approximate solutions may only be guaranteed to converge weakly.", "problem": "Let $\\Omega = (0,1)$, and consider the Sobolev space $H^{1}(\\Omega)$ of functions with square-integrable weak derivatives, with the norm $\\|u\\|_{H^{1}(\\Omega)} = \\left( \\|u\\|_{L^{2}(\\Omega)}^{2} + \\|u'\\|_{L^{2}(\\Omega)}^{2} \\right)^{1/2}$. In the numerical solution of partial differential equations (PDE), the distinction between weak and strong convergence in $H^{1}(\\Omega)$ is critical to understanding stability and consistency of variational discretizations. Define a sequence $(u_{m})_{m \\in \\mathbb{N}}$ in $H^{1}_{0}(\\Omega)$ by\n$$\nu_{m}(x) = \\frac{1}{m} \\sin(2\\pi m x), \\quad x \\in \\Omega.\n$$\nUsing only the foundational definitions of $H^{1}(\\Omega)$, weak and strong convergence in Hilbert spaces, and well-tested facts about oscillatory integrals on bounded intervals, do the following:\n- Justify that $(u_{m})_{m \\in \\mathbb{N}} \\subset H^{1}_{0}(\\Omega)$ and is bounded in $H^{1}(\\Omega)$.\n- Prove that $u_{m} \\to 0$ strongly in $L^{2}(\\Omega)$.\n- Prove that $u_{m} \\rightharpoonup 0$ weakly in $H^{1}(\\Omega)$ but $u_{m} \\not\\to 0$ strongly in $H^{1}(\\Omega)$.\n- Compute the limit\n$$\n\\lim_{m \\to \\infty} \\|u_{m}\\|_{H^{1}(\\Omega)}^{2}.\n$$\nExpress your final answer as a single exact analytical expression. No rounding is required.", "solution": "The problem requires an analysis of the convergence properties of the sequence of functions $u_{m}(x) = \\frac{1}{m} \\sin(2\\pi m x)$ in the Sobolev space $H^{1}(\\Omega)$ where $\\Omega = (0,1)$. We will address each part of the problem sequentially.\n\nFirst, we justify that the sequence $(u_{m})_{m \\in \\mathbb{N}}$ is contained in the space $H^{1}_{0}(\\Omega)$ and is a bounded sequence in $H^{1}(\\Omega)$.\nA function $u$ belongs to $H^{1}(\\Omega)$ if both $u$ and its weak derivative $u'$ are in $L^{2}(\\Omega)$. For the given sequence, each function $u_m(x)$ is infinitely differentiable on $\\Omega$. Therefore, its weak derivative coincides with its classical derivative.\n\nThe function is $u_{m}(x) = \\frac{1}{m} \\sin(2\\pi m x)$.\nIts derivative is $u'_{m}(x) = \\frac{d}{dx} \\left( \\frac{1}{m} \\sin(2\\pi m x) \\right) = \\frac{2\\pi m}{m} \\cos(2\\pi m x) = 2\\pi \\cos(2\\pi m x)$.\n\nTo show $u_m \\in H^{1}(\\Omega)$, we must compute the $L^{2}$ norms of $u_m$ and $u'_m$.\n$$\n\\|u_{m}\\|_{L^{2}(\\Omega)}^{2} = \\int_{0}^{1} |u_{m}(x)|^{2} dx = \\int_{0}^{1} \\left(\\frac{1}{m} \\sin(2\\pi m x)\\right)^{2} dx = \\frac{1}{m^{2}} \\int_{0}^{1} \\sin^{2}(2\\pi m x) dx.\n$$\nUsing the identity $\\sin^{2}(\\theta) = \\frac{1 - \\cos(2\\theta)}{2}$, the integral becomes:\n$$\n\\int_{0}^{1} \\sin^{2}(2\\pi m x) dx = \\int_{0}^{1} \\frac{1 - \\cos(4\\pi m x)}{2} dx = \\left[ \\frac{x}{2} - \\frac{\\sin(4\\pi m x)}{8\\pi m} \\right]_{0}^{1} = \\frac{1}{2}.\n$$\nTherefore, $\\|u_{m}\\|_{L^{2}(\\Omega)}^{2} = \\frac{1}{2m^{2}}$.\n\nNow we compute the norm of the derivative:\n$$\n\\|u'_{m}\\|_{L^{2}(\\Omega)}^{2} = \\int_{0}^{1} |u'_{m}(x)|^{2} dx = \\int_{0}^{1} (2\\pi \\cos(2\\pi m x))^{2} dx = 4\\pi^{2} \\int_{0}^{1} \\cos^{2}(2\\pi m x) dx.\n$$\nUsing the identity $\\cos^{2}(\\theta) = \\frac{1 + \\cos(2\\theta)}{2}$, the integral becomes:\n$$\n\\int_{0}^{1} \\cos^{2}(2\\pi m x) dx = \\int_{0}^{1} \\frac{1 + \\cos(4\\pi m x)}{2} dx = \\left[ \\frac{x}{2} + \\frac{\\sin(4\\pi m x)}{8\\pi m} \\right]_{0}^{1} = \\frac{1}{2}.\n$$\nTherefore, $\\|u'_{m}\\|_{L^{2}(\\Omega)}^{2} = 4\\pi^{2} \\left(\\frac{1}{2}\\right) = 2\\pi^{2}$.\nSince $\\|u_m\\|_{L^2}^2$ and $\\|u'_m\\|_{L^2}^2$ are finite, $u_m \\in H^{1}(\\Omega)$ for all $m \\in \\mathbb{N}$.\n\nTo show $u_m \\in H^{1}_{0}(\\Omega)$, we note that for a function $u \\in H^1(\\Omega) \\cap C(\\bar{\\Omega})$, membership in $H^1_0(\\Omega)$ is equivalent to $u$ vanishing on the boundary $\\partial \\Omega = \\{0, 1\\}$.\nWe check the boundary values for $u_m(x)$:\n$u_{m}(0) = \\frac{1}{m}\\sin(0) = 0$.\n$u_{m}(1) = \\frac{1}{m}\\sin(2\\pi m) = 0$ since $m$ is an integer.\nThus, $u_m$ satisfies the boundary conditions, and so $(u_{m})_{m \\in \\mathbb{N}} \\subset H^{1}_{0}(\\Omega)$.\n\nNext, to show the sequence is bounded in $H^1(\\Omega)$, we examine its norm:\n$$\n\\|u_{m}\\|_{H^{1}(\\Omega)}^{2} = \\|u_{m}\\|_{L^{2}(\\Omega)}^{2} + \\|u'_{m}\\|_{L^{2}(\\Omega)}^{2} = \\frac{1}{2m^{2}} + 2\\pi^{2}.\n$$\nFor any $m \\ge 1$, we have $0  \\frac{1}{2m^2} \\le \\frac{1}{2}$.\nThus, $2\\pi^2  \\|u_{m}\\|_{H^{1}(\\Omega)}^{2} \\le \\frac{1}{2} + 2\\pi^{2}$.\nThis implies the sequence of norms is bounded, so the sequence $(u_m)$ is bounded in $H^{1}(\\Omega)$.\n\nSecond, we prove that $u_{m} \\to 0$ strongly in $L^{2}(\\Omega)$.\nStrong convergence to $0$ in $L^2(\\Omega)$ means that $\\lim_{m \\to \\infty} \\|u_m - 0\\|_{L^2(\\Omega)} = 0$.\nFrom our previous calculation, $\\|u_{m}\\|_{L^{2}(\\Omega)}^{2} = \\frac{1}{2m^{2}}$.\nTaking the limit as $m \\to \\infty$:\n$$\n\\lim_{m \\to \\infty} \\|u_{m}\\|_{L^{2}(\\Omega)}^{2} = \\lim_{m \\to \\infty} \\frac{1}{2m^{2}} = 0.\n$$\nSince the squared norm tends to $0$, the norm itself must also tend to $0$. This confirms that $u_m \\to 0$ strongly in $L^{2}(\\Omega)$.\n\nThird, we prove that $u_{m} \\rightharpoonup 0$ weakly in $H^{1}(\\Omega)$ but not strongly.\nWeak convergence $u_m \\rightharpoonup 0$ in the Hilbert space $H^1(\\Omega)$ means that for any test function $v \\in H^{1}(\\Omega)$, the inner product $\\langle u_m, v \\rangle_{H^{1}(\\Omega)}$ converges to $0$. The inner product is defined as:\n$$\n\\langle u_m, v \\rangle_{H^{1}(\\Omega)} = \\int_{0}^{1} u_m(x)v(x) dx + \\int_{0}^{1} u'_m(x)v'(x) dx.\n$$\nWe analyze each term separately. For the first term, we use the Cauchy-Schwarz inequality:\n$$\n\\left| \\int_{0}^{1} u_m(x)v(x) dx \\right| \\le \\|u_m\\|_{L^2(\\Omega)} \\|v\\|_{L^2(\\Omega)}.\n$$\nSince we have already shown that $\\|u_m\\|_{L^2(\\Omega)} \\to 0$ as $m \\to \\infty$, and $\\|v\\|_{L^2(\\Omega)}$ is a fixed finite value, the first term converges to $0$:\n$$\n\\lim_{m \\to \\infty} \\int_{0}^{1} u_m(x)v(x) dx = 0.\n$$\nFor the second term, we have:\n$$\n\\int_{0}^{1} u'_m(x)v'(x) dx = \\int_{0}^{1} 2\\pi \\cos(2\\pi m x) v'(x) dx.\n$$\nSince $v \\in H^{1}(\\Omega)$, its weak derivative $v'$ is in $L^2(\\Omega)$. On the bounded domain $\\Omega = (0,1)$, any $L^2$ function is also an $L^1$ function ($L^2(\\Omega) \\subset L^1(\\Omega)$). The Riemann-Lebesgue lemma states that for any function $f \\in L^1(\\Omega)$, $\\lim_{k \\to \\infty} \\int_{\\Omega} f(x) \\cos(kx) dx = 0$.\nApplying this lemma with $f(x) = v'(x)$ and $k=2\\pi m$, we conclude that:\n$$\n\\lim_{m \\to \\infty} \\int_{0}^{1} 2\\pi\\cos(2\\pi m x) v'(x) dx = 0.\n$$\nTherefore, the second term of the inner product also converges to $0$.\nCombining both results, we have established that for any $v \\in H^{1}(\\Omega)$:\n$$\n\\lim_{m \\to \\infty} \\langle u_m, v \\rangle_{H^{1}(\\Omega)} = 0 + 0 = 0.\n$$\nThis is the definition of weak convergence to $0$, so $u_m \\rightharpoonup 0$ in $H^1(\\Omega)$.\n\nTo show that the convergence is not strong, we must show that $\\|u_m - 0\\|_{H^1(\\Omega)}$ does not converge to $0$. We have already calculated this norm:\n$$\n\\|u_{m}\\|_{H^{1}(\\Omega)}^{2} = \\frac{1}{2m^{2}} + 2\\pi^{2}.\n$$\nTaking the limit as $m \\to \\infty$:\n$$\n\\lim_{m \\to \\infty} \\|u_{m}\\|_{H^{1}(\\Omega)}^{2} = \\lim_{m \\to \\infty} \\left( \\frac{1}{2m^{2}} + 2\\pi^{2} \\right) = 0 + 2\\pi^{2} = 2\\pi^{2}.\n$$\nSince $\\lim_{m \\to \\infty} \\|u_{m}\\|_{H^{1}(\\Omega)} = \\sqrt{2\\pi^{2}} = \\pi \\sqrt{2} \\neq 0$, the sequence $(u_m)$ does not converge strongly to $0$ in $H^{1}(\\Omega)$.\n\nFinally, we compute the limit $\\lim_{m \\to \\infty} \\|u_{m}\\|_{H^{1}(\\Omega)}^{2}$. This calculation was performed in the previous step as part of the argument against strong convergence. The result is:\n$$\n\\lim_{m \\to \\infty} \\|u_{m}\\|_{H^{1}(\\Omega)}^{2} = 2\\pi^{2}.\n$$", "answer": "$$\\boxed{2\\pi^{2}}$$", "id": "3444217"}, {"introduction": "While the concept of a weak derivative is powerful, its computation for functions that lack classical differentiability requires a numerical approach. This practice guides you through approximating the weak derivative of a Weierstrass-type function, a classic example of a continuous but nowhere differentiable function, using the technique of mollification [@problem_id:3444259]. By implementing this method with the Fast Fourier Transform (FFT), you will gain hands-on experience with spectral methods and the practical meaning of convergence in fractional Sobolev spaces.", "problem": "Consider the $2\\pi$-periodic domain $[0,2\\pi]$ with angles measured in radians. Let the Weierstrass-type function be defined by $$w_{M}(x) = \\sum_{n=0}^{M} a^{n} \\cos\\!\\big(b^{n} x\\big),$$ where $a \\in (0,1)$, $b \\in \\mathbb{N}$ with $b \\geq 2$, and $M \\in \\mathbb{N}$. The weak derivative of a function is defined in the sense of distributions: for a function $u$, a function $v$ is its weak derivative if $$\\int_{0}^{2\\pi} u(x) \\,\\phi'(x)\\,dx = -\\int_{0}^{2\\pi} v(x) \\,\\phi(x)\\,dx$$ for all smooth test functions $\\phi$ with compact support, here understood as $2\\pi$-periodic. A standard way to approximate weak derivatives numerically for rough functions is to mollify by convolution with a Gaussian mollifier and then differentiate. On a periodic domain, this mollification can be represented by the heat semigroup: define $$S_{\\varepsilon} u = e^{\\frac{\\varepsilon^{2}}{2}\\Delta} u,$$ where $\\Delta$ is the Laplacian operator. In the Fourier domain, the action of $S_{\\varepsilon}$ is the multiplier $$\\widehat{S_{\\varepsilon}u}(k) = e^{-\\frac{\\varepsilon^{2}}{2} k^{2}} \\,\\hat{u}(k),$$ where $\\hat{u}(k)$ are the $2\\pi$-Fourier series coefficients of $u$ and $k \\in \\mathbb{Z}$ is the integer wave number. The fractional Sobolev space $H^{s}$ for $s \\in \\mathbb{R}$ on the $2\\pi$-periodic domain is defined by the norm $$\\|f\\|_{H^{s}}^{2} = 2\\pi \\sum_{k \\in \\mathbb{Z}} \\big(1 + k^{2}\\big)^{s} \\, \\big|\\hat{f}(k)\\big|^{2}.$$ The task is to approximate the weak derivative of $w_{M}$ by computing $\\partial_{x} S_{\\varepsilon} w_{M}$ and to measure convergence in $H^{s}$ for $s  \\frac{1}{2}$ as the mollification scale $\\varepsilon$ vanishes and the discretization refines.\n\nYou must implement this numerically using the Fast Fourier Transform (FFT) on a uniform grid of $N$ points, where $x_{j} = \\frac{2\\pi j}{N}$ for $j = 0,1,\\dots,N-1$. Use the $2\\pi$-Fourier series convention so that if $\\mathcal{F}_{k}$ denotes the discrete FFT of $f(x_{j})$, then the Fourier series coefficient is approximated by $$\\hat{f}(k) \\approx \\frac{1}{N} \\,\\mathcal{F}_{k},$$ and the integer wave numbers $k$ are obtained consistently from the FFT frequencies. The numerical approximation for $\\partial_{x} S_{\\varepsilon} w_{M}$ in Fourier space follows from $$\\widehat{\\partial_{x} S_{\\varepsilon} w_{M}}(k) = \\big(ik\\big) \\, e^{-\\frac{\\varepsilon^{2}}{2} k^{2}} \\, \\hat{w}_{M}(k).$$ The $H^{s}$ norm is then computed from the discrete Fourier coefficients by the Fourier-based definition above. To avoid aliasing when constructing $w_{M}$ on a grid with $N$ points, cap the largest frequency by enforcing the effective truncation $$M_{\\mathrm{eff}} = \\max\\Big\\{ n \\in \\mathbb{N} \\ \\big| \\ n \\le M \\ \\text{and} \\ b^{n} \\le \\frac{N}{2} - 1 \\Big\\}.$$ The numerical objective is to quantify $$\\big\\| \\partial_{x} S_{\\varepsilon_{1}} w_{M} - \\partial_{x} S_{\\varepsilon_{2}} w_{M} \\big\\|_{H^{s}}$$ for a sequence of decreasing mollification scales $\\varepsilon_{1}  \\varepsilon_{2}  0$ as the grid is refined.\n\nUse the following test suite of parameter sets $\\big(s,a,b,M,\\varepsilon\\text{-list},N_{\\min},N_{\\max}\\big)$, which cover a general case, boundary cases near $s = \\frac{1}{2}$, and different frequency growth settings. For each case, construct $w_{M}$ on the finest grid with $N = N_{\\max}$ using $M_{\\mathrm{eff}}$, and compute the $H^{s}$ norm of the difference of successive-scale weak derivative approximations at the smallest pair of scales $(\\varepsilon_{p},\\varepsilon_{p+1})$ in the given $\\varepsilon$-list, evaluated on the finest grid. The parameters are:\n- Case $1$: $\\big(s,a,b,M,\\varepsilon\\text{-list},N_{\\min},N_{\\max}\\big) = \\big(0.25,0.5,3,12,[0.4,0.2,0.1],1024,4096\\big)$.\n- Case $2$: $\\big(s,a,b,M,\\varepsilon\\text{-list},N_{\\min},N_{\\max}\\big) = \\big(0.49,0.6,5,10,[0.3,0.15],1024,4096\\big)$.\n- Case $3$: $\\big(s,a,b,M,\\varepsilon\\text{-list},N_{\\min},N_{\\max}\\big) = \\big(0.10,0.7,4,9,[0.5,0.25],512,2048\\big)$.\n- Case $4$: $\\big(s,a,b,M,\\varepsilon\\text{-list},N_{\\min},N_{\\max}\\big) = \\big(0.45,0.4,2,12,[0.2,0.1],512,2048\\big)$.\n\nYour program must:\n- For each case, build $w_{M}$ using $M_{\\mathrm{eff}}$ on the finest grid $N_{\\max}$.\n- Use the Fourier representation to compute $\\partial_{x} S_{\\varepsilon} w_{M}$ for the two smallest scales in the $\\varepsilon$-list via multipliers $e^{-\\frac{\\varepsilon^{2}}{2} k^{2}}$ and differentiation $\\big(ik\\big)$ in Fourier space.\n- Compute the $H^{s}$ norm of the difference $\\partial_{x} S_{\\varepsilon_{p}} w_{M} - \\partial_{x} S_{\\varepsilon_{p+1}} w_{M}$ on the finest grid for the smallest adjacent pair $(\\varepsilon_{p},\\varepsilon_{p+1})$ in the list.\n- Aggregate the resulting four floating-point values, one per case, in order.\n\nFinal output format requirement: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $\\big[\\text{result}_{1},\\text{result}_{2},\\text{result}_{3},\\text{result}_{4}\\big]$). No other text should be printed. No physical units are involved, and all angles are in radians. The final answers per case are floats.", "solution": "The problem describes a numerical procedure to approximate the weak derivative of a Weierstrass-type function and measure the convergence of these approximations in a fractional Sobolev space norm. The method is based on mollification via the heat semigroup, implemented efficiently in the Fourier domain using the Fast Fourier Transform (FFT).\n\nThe core of the procedure is to compute the quantity $\\|\\partial_{x} S_{\\varepsilon_{1}} w_{M} - \\partial_{x} S_{\\varepsilon_{2}} w_{M}\\|_{H^{s}}$ for each given test case. The solution involves the following steps:\n1.  For each case, establish the numerical grid with $N = N_{\\max}$ points and the corresponding integer wave numbers $k$.\n2.  Determine the effective number of terms, $M_{\\mathrm{eff}}$, for the Weierstrass-type series to prevent aliasing on the chosen grid.\n3.  Construct the function $w_M(x)$ on the grid using the sum up to $M_{\\mathrm{eff}}$.\n4.  Compute the discrete Fourier coefficients $\\hat{w}_M(k)$ of the function using the FFT.\n5.  Using the provided Fourier multipliers, compute the Fourier coefficients of the difference function $D(x) = \\partial_{x} S_{\\varepsilon_{1}} w_{M} - \\partial_{x} S_{\\varepsilon_{2}} w_{M}$, where $\\varepsilon_1$ and $\\varepsilon_2$ are the two smallest mollification scales from the given list. The Fourier coefficients are given by $\\hat{D}(k) = (ik) (e^{-\\frac{\\varepsilon_{1}^{2}}{2} k^{2}} - e^{-\\frac{\\varepsilon_{2}^{2}}{2} k^{2}}) \\hat{w}_{M}(k)$.\n6.  Finally, compute the $H^s$ norm of the difference function $D(x)$ using its discrete Fourier coefficients, according to the formula:\n    $$\n    \\|D\\|_{H^{s}}^2 = 2\\pi \\sum_{k} (1 + k^{2})^{s} |\\hat{D}(k)|^{2}.\n    $$\nThe square root of this sum gives the final numerical result for each case.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_norm(s, a, b, M, eps_list, N_max):\n    \"\"\"\n    Calculates the H^s norm of the difference of two mollified weak derivatives\n    of a Weierstrass-type function.\n    \"\"\"\n    # Set the grid size to the finest resolution given.\n    N = N_max\n    \n    # Determine the integer wave numbers `k` corresponding to the FFT output.\n    # numpy.fft.fftfreq(N) * N provides the correct sequence of integers:\n    # [0, 1, ..., N/2-1, -N/2, ..., -1] for N even.\n    k = np.fft.fftfreq(N) * N\n    \n    # Create the uniform spatial grid on [0, 2*pi).\n    x = 2 * np.pi * np.arange(N) / N\n    \n    # Determine the effective truncation M_eff to satisfy the Nyquist criterion\n    # and avoid aliasing. The highest frequency b^n must be less than N/2.\n    # The problem specifies b^n = N/2 - 1.\n    if (N / 2.0 - 1.0) = 0:\n        M_eff = -1\n    else:\n        # We solve for n in b^n = N/2-1, which is n = log_b(N/2-1).\n        M_eff = int(np.floor(np.log(N / 2.0 - 1.0) / np.log(b)))\n    \n    # The effective M is the minimum of the specified M and the aliasing limit.\n    M_eff = min(M, M_eff)\n    \n    # Construct the Weierstrass-type function w_M(x) on the grid.\n    w_M_grid = np.zeros(N, dtype=float)\n    for n in range(M_eff + 1):\n        w_M_grid += a**n * np.cos(b**n * x)\n        \n    # Compute the Fourier series coefficients of w_M using FFT.\n    # The convention is hat{f}(k) = (1/N) * FFT(f).\n    w_M_hat = np.fft.fft(w_M_grid) / N\n    \n    # Select the smallest pair of mollification scales from the provided list.\n    # The lists are given in decreasing order, so we take the last two entries.\n    eps_p = eps_list[-2]\n    eps_q = eps_list[-1]\n    \n    # Compute the Fourier coefficients of the difference:\n    # D(x) = (d/dx S_{eps_p} w_M) - (d/dx S_{eps_q} w_M)\n    # In Fourier space, this becomes:\n    # hat{D}(k) = (ik) * (exp(-eps_p^2/2 * k^2) - exp(-eps_q^2/2 * k^2)) * hat{w}_M(k)\n    k_sq = k**2\n    mollifier_term_p = np.exp(-0.5 * eps_p**2 * k_sq)\n    mollifier_term_q = np.exp(-0.5 * eps_q**2 * k_sq)\n    \n    # Fourier multiplier for the difference of mollified derivatives.\n    full_multiplier = (1j * k) * (mollifier_term_p - mollifier_term_q)\n    \n    # Fourier coefficients of the difference function D(x).\n    diff_hat = full_multiplier * w_M_hat\n    \n    # Compute the squared H^s norm of the difference function D(x) using its\n    # Fourier coefficients, based on the definition:\n    # ||D||^2_{H^s} = 2*pi * sum_k (1+k^2)^s * |hat{D}(k)|^2\n    sobolev_weight = (1 + k_sq)**s\n    \n    # The integrand of the norm sum, computed for each k.\n    norm_sq_integrand = sobolev_weight * np.abs(diff_hat)**2\n    \n    # Sum over all wave numbers k to get the total norm squared.\n    norm_sq = 2 * np.pi * np.sum(norm_sq_integrand)\n    \n    # The final result is the square root of the sum.\n    result = np.sqrt(norm_sq)\n    \n    return result\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (s, a, b, M, eps-list, N_min, N_max)\n        (0.25, 0.5, 3, 12, [0.4, 0.2, 0.1], 1024, 4096),\n        (0.49, 0.6, 5, 10, [0.3, 0.15], 1024, 4096),\n        (0.10, 0.7, 4, 9, [0.5, 0.25], 512, 2048),\n        (0.45, 0.4, 2, 12, [0.2, 0.1], 512, 2048),\n    ]\n\n    results = []\n    for case in test_cases:\n        s, a, b, M, eps_list, N_min, N_max = case\n        \n        # Calculate the required norm for each parameter set.\n        res = calculate_norm(s, a, b, M, eps_list, N_max)\n        results.append(res)\n        \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\n# Execute the main function.\nsolve()\n```", "id": "3444259"}, {"introduction": "The theoretical equivalence of different Sobolev norms is a cornerstone of PDE analysis, underpinning the stability and convergence proofs of many numerical schemes. This exercise explores the practical implications of these equivalences by investigating the one-dimensional biharmonic equation, which models phenomena like beam deflection [@problem_id:3444231]. By numerically solving this equation with a finite difference scheme, you will quantify how the equivalence between the full $H^2(\\Omega)$ norm and the seminorm based on the second derivative is influenced by different physical boundary conditions.", "problem": "Consider the one-dimensional biharmonic problem on the open interval $\\Omega = (0,1)$: find a sufficiently smooth function $u$ satisfying the fourth-order ordinary differential equation $u^{(4)} = f$ in $\\Omega$ together with homogeneous boundary conditions modeling two standard plate end constraints: clamped ends and simply supported ends. Work entirely in the Sobolev space framework and compare the Sobolev space $H^2(\\Omega)$ norm to the $L^2(\\Omega)$ norm of the Laplacian. The goal is to numerically assess the equivalence of the graph norm $\\|u\\|_{H^2(\\Omega)}$ with $\\|\\Delta u\\|_{L^2(\\Omega)}$ under these boundary conditions, and to quantify the sensitivity of this equivalence to imperfect boundary enforcement.\n\nFundamental definitions and starting point:\n- For $u \\in H^2(\\Omega)$, the $H^2(\\Omega)$ norm is defined by $\\|u\\|_{H^2(\\Omega)}^2 = \\|u\\|_{L^2(\\Omega)}^2 + \\|u'\\|_{L^2(\\Omega)}^2 + \\|u''\\|_{L^2(\\Omega)}^2$.\n- In one dimension, the Laplacian simplifies to the second derivative, so $\\Delta u = u''$ and $\\|\\Delta u\\|_{L^2(\\Omega)} = \\|u''\\|_{L^2(\\Omega)}$.\n\nBoundary conditions:\n- Clamped ends: $u(0)=0$, $u'(0)=0$, $u(1)=0$, $u'(1)=0$.\n- Simply supported ends: $u(0)=0$, $u''(0)=0$, $u(1)=0$, $u''(1)=0$.\n\nNumerical discretization:\n- Use a uniform grid with $N$ interior points and mesh width $h = \\frac{1}{N+1}$, with nodal positions $x_i = i h$ for $i = 1,2,\\dots,N$. Denote the discrete unknowns by $u_i \\approx u(x_i)$.\n- Discretize the fourth derivative at interior nodes using the standard centered finite difference formula\n$$\nu^{(4)}(x_i) \\approx \\frac{u_{i-2} - 4u_{i-1} + 6u_i - 4u_{i+1} + u_{i+2}}{h^4}.\n$$\n- Introduce ghost values $u_{-1}$ and $u_{N+2}$ for the stencil near the boundaries and eliminate them using linear relations derived from the boundary conditions. To permit controlled perturbations in boundary enforcement, parameterize the ghost and boundary values through affine relations\n$$\nu_0 = a_L,\\quad u_{-1} = s_L\\,u_1 + b_L, \\quad u_{N+1} = a_R,\\quad u_{N+2} = s_R\\,u_N + b_R,\n$$\nwhere $(s_L,s_R)$ encode the type of boundary condition and $(a_L,a_R,b_L,b_R)$ encode small boundary enforcement perturbations. For exact clamped enforcement use $(s_L,s_R) = (1,1)$ and $(a_L,a_R,b_L,b_R)=(0,0,0,0)$. For exact simply supported enforcement use $(s_L,s_R)=(-1,-1)$ and $(a_L,a_R,b_L,b_R)=(0,0,0,0)$. For imperfect enforcement of either boundary type with a perturbation magnitude $\\delta0$, set $(a_L,a_R,b_L,b_R)=(\\delta,-\\delta,\\delta,-\\delta)$ while keeping $(s_L,s_R)$ as for the exact type.\n- Assemble the linear system for the interior unknowns $u_1,\\dots,u_N$ by writing the discrete biharmonic equation at each interior node and moving all constant contributions from boundary and ghost values to the right-hand side. Use the mesh-based forcing values $f_i = f(x_i)$ and the factor $h^4$ consistently so that the discrete equation reads\n$$\n\\sum_{j=\\max(1,i-2)}^{\\min(N,i+2)} c_{i,j}\\,u_j = h^4 f_i - \\text{boundary\\_constants}_i,\n$$\nwhere $c_{i,j}$ are the coefficients induced by the stencil and the boundary elimination described above.\n\nNumerical norms:\n- Approximate the $L^2(\\Omega)$ norms using the composite trapezoidal rule and centered finite differences:\n    - Construct an array $u^{\\text{full}} = (u_0, u_1, \\dots, u_N, u_{N+1})$ with $u_0 = a_L$, $u_{N+1} = a_R$, and $u_i$ the computed interior values.\n    - Define the discrete first derivatives at interior nodes by $D^1_i = \\frac{u_{i+1} - u_{i-1}}{2h}$ for $i=1,\\dots,N$.\n    - Define the discrete second derivatives at interior nodes by $D^2_i = \\frac{u_{i-1} - 2u_i + u_{i+1}}{h^2}$ for $i=1,\\dots,N$.\n    - Compute\n    $$\n    \\|u\\|_{L^2_h}^2 = h\\left(\\frac{1}{2}u_0^2 + \\sum_{i=1}^{N} u_i^2 + \\frac{1}{2}u_{N+1}^2\\right),\\quad \\|u'\\|_{L^2_h}^2 = h\\sum_{i=1}^N (D^1_i)^2,\\quad \\|u''\\|_{L^2_h}^2 = h\\sum_{i=1}^N (D^2_i)^2.\n    $$\n    - Define the discrete $H^2(\\Omega)$ norm by $\\|u\\|_{H^2_h}^2 = \\|u\\|_{L^2_h}^2 + \\|u'\\|_{L^2_h}^2 + \\|u''\\|_{L^2_h}^2$. The ratio of interest is\n    $$\n    R = \\frac{\\|u\\|_{H^2_h}}{\\|u''\\|_{L^2_h}} = \\sqrt{1 + \\frac{\\|u\\|_{L^2_h}^2 + \\|u'\\|_{L^2_h}^2}{\\|u''\\|_{L^2_h}^2}}.\n    $$\n\nProgram requirements:\n- Implement the finite difference solver and the norm computations described above for $\\Omega=(0,1)$ with $N=64$. Use two smooth forcings:\n    - $f_1(x) = \\sin(\\pi x)$,\n    - $f_2(x) = 1 + x$.\n- Construct the following eight test cases, each producing a single floating-point value $R$:\n    1. Clamped, exact enforcement $(s_L,s_R)=(1,1)$ with $(a_L,a_R,b_L,b_R)=(0,0,0,0)$, forcing $f_1$.\n    2. Clamped, perturbed enforcement with $\\delta=10^{-3}$ so $(a_L,a_R,b_L,b_R)=(10^{-3},-10^{-3},10^{-3},-10^{-3})$, $(s_L,s_R)=(1,1)$, forcing $f_1$.\n    3. Simply supported, exact enforcement $(s_L,s_R)=(-1,-1)$ with $(a_L,a_R,b_L,b_R)=(0,0,0,0)$, forcing $f_1$.\n    4. Simply supported, perturbed enforcement with $\\delta=10^{-3}$ so $(a_L,a_R,b_L,b_R)=(10^{-3},-10^{-3},10^{-3},-10^{-3})$, $(s_L,s_R)=(-1,-1)$, forcing $f_1$.\n    5. Clamped, exact enforcement, forcing $f_2$.\n    6. Clamped, perturbed enforcement with $\\delta=10^{-3}$, forcing $f_2$.\n    7. Simply supported, exact enforcement, forcing $f_2$.\n    8. Simply supported, perturbed enforcement with $\\delta=10^{-3}$, forcing $f_2$.\n\nFinal output format:\n- Your program should produce a single line of output containing the eight ratio values as a comma-separated list enclosed in square brackets. Each value must be rounded to six decimal places. For example, the output format must be exactly like\n\"[r1,r2,r3,r4,r5,r6,r7,r8]\"\nwith each rj a decimal string with six digits after the decimal point and no additional text.\n\nNo physical units are involved. All angles are in radians as implied by the appearance of the sine function. All answers must be real numbers.", "solution": "The solution involves discretizing the biharmonic equation using a finite difference scheme, constructing and solving the resulting linear algebraic system, and then computing the required Sobolev norms from the numerical solution to find their ratio.\n\n### 1. Discretization and Linear System Assembly\n\nThe fourth-order ordinary differential equation $u^{(4)}(x) = f(x)$ on the interval $\\Omega = (0,1)$ is discretized on a uniform grid with $N$ interior points $x_i = ih$ for $i=1, \\dots, N$, where the mesh width is $h = 1/(N+1)$. The unknowns are the approximations $u_i \\approx u(x_i)$ for the interior points.\n\nThe fourth derivative $u^{(4)}$ at an interior node $x_i$ is approximated using a second-order, centered finite difference stencil:\n$$\nu^{(4)}(x_i) \\approx \\frac{u_{i-2} - 4u_{i-1} + 6u_i - 4u_{i+1} + u_{i+2}}{h^4}\n$$\nThis transforms the differential equation into an algebraic equation at each interior node:\n$$\nu_{i-2} - 4u_{i-1} + 6u_i - 4u_{i+1} + u_{i+2} = h^4 f_i\n$$\nwhere $f_i = f(x_i)$. This set of equations for $i = 1, \\dots, N$ forms a linear system $A\\vec{u} = \\vec{b}$, where $\\vec{u} = (u_1, \\dots, u_N)^T$.\n\nThe stencil near the boundaries ($i=1, 2, N-1, N$) involves values $u_{-1}, u_0, u_{N+1}, u_{N+2}$ outside the interior domain. These \"ghost\" values are eliminated by substituting the parameterized boundary conditions:\n$$\nu_0 = a_L, \\quad u_{N+1} = a_R, \\quad u_{-1} = s_L u_1 + b_L, \\quad u_{N+2} = s_R u_N + b_R\n$$\nThis substitution modifies the matrix $A$ and the right-hand side vector $\\vec{b}$ for the rows corresponding to nodes near the boundary. For example, for the first row ($i=1$), the equation becomes:\n$(s_L u_1 + b_L) - 4a_L + 6u_1 - 4u_2 + u_3 = h^4 f_1 \\implies (6+s_L)u_1 - 4u_2 + u_3 = h^4 f_1 + 4a_L - b_L$.\nThis defines the first row of the matrix $A$ and the first entry of the vector $\\vec{b}$. Similar substitutions are made for $i=2, N-1, N$. The resulting $N \\times N$ linear system $A\\vec{u}=\\vec{b}$ is then solved for the interior solution vector $\\vec{u}$.\n\n### 2. Numerical Norm Computation\n\nWith the interior solution $\\vec{u}$ computed, the full solution vector $u^{\\text{full}} = (u_0, u_1, \\dots, u_N, u_{N+1})$ is formed using $u_0=a_L$ and $u_{N+1}=a_R$. The discrete norms are then calculated:\n\n-   The square of the $L^2$-norm is approximated by the composite trapezoidal rule:\n    $$\n    \\|u\\|_{L^2_h}^2 = h\\left(\\frac{1}{2}u_0^2 + \\sum_{i=1}^{N} u_i^2 + \\frac{1}{2}u_{N+1}^2\\right).\n    $$\n\n-   The square of the $L^2$-norm of the first derivative is approximated using centered differences for the derivative and a rectangle rule for the integral:\n    $$\n    \\|u'\\|_{L^2_h}^2 = h\\sum_{i=1}^N (D^1_i)^2, \\quad \\text{where} \\quad D^1_i = \\frac{u_{i+1} - u_{i-1}}{2h}.\n    $$\n\n-   Similarly, for the second derivative (the Laplacian):\n    $$\n    \\|u''\\|_{L^2_h}^2 = h\\sum_{i=1}^N (D^2_i)^2, \\quad \\text{where} \\quad D^2_i = \\frac{u_{i-1} - 2u_i + u_{i+1}}{h^2}.\n    $$\n\n### 3. Ratio Calculation\n\nFinally, the discrete $H^2(\\Omega)$ norm is computed as $\\|u\\|_{H^2_h}^2 = \\|u\\|_{L^2_h}^2 + \\|u'\\|_{L^2_h}^2 + \\|u''\\|_{L^2_h}^2$, and the ratio of interest is calculated:\n$$\nR = \\frac{\\|u\\|_{H^2_h}}{\\|u''\\|_{L^2_h}} = \\sqrt{1 + \\frac{\\|u\\|_{L^2_h}^2 + \\|u'\\|_{L^2_h}^2}{\\|u''\\|_{L^2_h}^2}}.\n$$\nThis procedure is carried out for each of the eight specified test cases.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D biharmonic problem for a series of test cases\n    and computes the ratio of the H^2 norm to the L^2 norm of the Laplacian.\n    \"\"\"\n    \n    def get_forcing_function(name, x_interior):\n        \"\"\"Returns the evaluated forcing function on the grid.\"\"\"\n        if name == 'f1':\n            return np.sin(np.pi * x_interior)\n        elif name == 'f2':\n            return 1.0 + x_interior\n        else:\n            raise ValueError(\"Unknown forcing function name\")\n\n    def solve_biharmonic_case(N, f_name, bc_type, delta):\n        \"\"\"\n        Solves a single case of the biharmonic problem.\n        \n        Args:\n            N (int): Number of interior grid points.\n            f_name (str): Name of the forcing function ('f1' or 'f2').\n            bc_type (str): Type of boundary condition ('clamped' or 'simply_supported').\n            delta (float): Perturbation magnitude for boundary enforcement.\n        \n        Returns:\n            float: The computed ratio R.\n        \"\"\"\n        # 1. Setup grid and parameters\n        h = 1.0 / (N + 1)\n        x_interior = h * np.arange(1, N + 1)\n        \n        f_vec = get_forcing_function(f_name, x_interior)\n\n        if bc_type == 'clamped':\n            s_L, s_R = 1.0, 1.0\n        elif bc_type == 'simply_supported':\n            s_L, s_R = -1.0, -1.0\n        else:\n            raise ValueError(\"Unknown boundary condition type\")\n\n        if delta == 0.0:\n            a_L, a_R, b_L, b_R = 0.0, 0.0, 0.0, 0.0\n        else:\n            a_L, a_R, b_L, b_R = delta, -delta, delta, -delta\n\n        # 2. Assemble the system matrix A\n        A = (np.diag(np.full(N, 6.0)) +\n             np.diag(np.full(N - 1, -4.0), k=1) +\n             np.diag(np.full(N - 1, -4.0), k=-1) +\n             np.diag(np.full(N - 2, 1.0), k=2) +\n             np.diag(np.full(N - 2, 1.0), k=-2))\n        \n        # Modify A for boundary conditions\n        A[0, 0] += s_L\n        A[N - 1, N - 1] += s_R\n\n        # 3. Assemble the right-hand side vector b\n        b = h**4 * f_vec\n        \n        # Modify b for boundary conditions\n        b[0] += 4 * a_L - b_L\n        b[1] -= a_L\n        b[N - 2] -= a_R\n        b[N - 1] += 4 * a_R - b_R\n            \n        # 4. Solve the linear system\n        u_interior = np.linalg.solve(A, b)\n\n        # 5. Compute numerical norms\n        u_full = np.concatenate(([a_L], u_interior, [a_R]))\n\n        # Discrete L^2 norm of u\n        norm_l2_sq = h * (0.5 * u_full[0]**2 + np.sum(u_interior**2) + 0.5 * u_full[-1]**2)\n\n        # Discrete L^2 norm of u'\n        # D^1_i = (u_{i+1} - u_{i-1})/(2h) for i=1,...,N\n        D1 = (u_full[2:] - u_full[0:-2]) / (2 * h)\n        norm_d1_l2_sq = h * np.sum(D1**2)\n\n        # Discrete L^2 norm of u''\n        # D^2_i = (u_{i-1} - 2u_i + u_{i+1})/h^2 for i=1,...,N\n        D2 = (u_full[0:-2] - 2 * u_full[1:-1] + u_full[2:]) / h**2\n        norm_d2_l2_sq = h * np.sum(D2**2)\n\n        if norm_d2_l2_sq == 0:\n            return np.inf\n\n        # 6. Calculate the ratio R\n        ratio_sq = 1.0 + (norm_l2_sq + norm_d1_l2_sq) / norm_d2_l2_sq\n        R = np.sqrt(ratio_sq)\n\n        return R\n\n    # Problem parameters\n    N = 64\n    delta_val = 1e-3\n\n    # Define the 8 test cases\n    test_cases = [\n        # bc_type, delta, f_name\n        ('clamped',          0.0,       'f1'), # Case 1\n        ('clamped',          delta_val, 'f1'), # Case 2\n        ('simply_supported', 0.0,       'f1'), # Case 3\n        ('simply_supported', delta_val, 'f1'), # Case 4\n        ('clamped',          0.0,       'f2'), # Case 5\n        ('clamped',          delta_val, 'f2'), # Case 6\n        ('simply_supported', 0.0,       'f2'), # Case 7\n        ('simply_supported', delta_val, 'f2'), # Case 8\n    ]\n\n    results = []\n    for case in test_cases:\n        bc_type, delta, f_name = case\n        R = solve_biharmonic_case(N, f_name, bc_type, delta)\n        results.append(R)\n\n    # Format and print the final output\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3444231"}]}