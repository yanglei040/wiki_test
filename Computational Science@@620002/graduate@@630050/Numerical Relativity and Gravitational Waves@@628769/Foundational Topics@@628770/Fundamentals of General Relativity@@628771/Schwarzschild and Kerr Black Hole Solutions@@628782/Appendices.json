{"hands_on_practices": [{"introduction": "To simulate black holes or binary systems, one cannot simply use the known analytical metric functions. Instead, numerical relativity relies on the $(3+1)$ decomposition of spacetime, where initial data is specified on a spatial slice and evolved forward in time. This initial data is not arbitrary; it must satisfy the Hamiltonian and momentum constraint equations derived from Einstein's theory. This exercise [@problem_id:3485927] provides direct, hands-on practice with this foundational procedure by having you numerically verify these constraints for standard representations of Schwarzschild (non-spinning) and Kerr-like (spinning) black holes on a computational grid.", "problem": "You are to write a complete, runnable program that verifies and quantifies, by direct numerical discretization, three core aspects of black hole initial data and wave extraction that arise in numerical relativity for Schwarzschild and Kerr black hole solutions. All calculations are to be performed in geometric units where $G = c = 1$, and all angles are to be interpreted in radians. Your program must produce a single-line output as specified at the end.\n\nThe foundational bases permitted are: the $(3+1)$ decomposition of spacetime, the Arnowitt–Deser–Misner (ADM) formalism, the vacuum constraint equations, the conformal method for initial data, the Bowen–York construction for spinning black holes, and the asymptotic Bondi limit where the Newman–Penrose scalar relates to the far-zone gravitational wave strain. You must not use any other unmotivated or shortcut formulas that are not derivable from these bases; the derivation must proceed from the fundamental equations and definitions listed.\n\nThe tasks are:\n\n- Task A: Hamiltonian constraint residual for isotropic Schwarzschild data.\n- Task B: Momentum constraint residual for the spinning Bowen–York extrinsic curvature.\n- Task C: Far-zone gravitational wave extraction via the Newman–Penrose scalar.\n\nFor all tasks, you must implement the discretization and evaluation in a logically consistent way using a uniform Cartesian grid and second-order accurate centered finite differences for spatial derivatives. You must clearly separate interior points from boundaries and must excise a small spherical region around the puncture to avoid the physical singularity. All reported measures must be finite and real-valued.\n\nTask A (Hamiltonian constraint for time-symmetric Schwarzschild foliation):\n- Start from the vacuum Hamiltonian constraint in the $(3+1)$ decomposition, which in geometric units ($G = c = 1$) reads $R + K^{2} - K_{ij} K^{ij} = 0$, where $R$ is the scalar curvature of the spatial metric $\\gamma_{ij}$, $K_{ij}$ is the extrinsic curvature, and $K = \\gamma^{ij} K_{ij}$. For a time-symmetric slice, $K_{ij} = 0$.\n- Consider conformally flat, spherically symmetric, asymptotically flat initial data for a single Schwarzschild black hole expressed in isotropic Cartesian coordinates $(x,y,z)$ with $\\gamma_{ij} = \\psi^{4} \\delta_{ij}$. Outside the excised puncture at the origin, the conformal factor $\\psi$ is harmonic in flat space, tends to $\\psi \\to 1$ at large radius, and encodes an ADM mass parameter $M$; use these conditions to determine the unique spherically symmetric form of $\\psi(r)$.\n- On a cubic domain $[-L,L]^{3}$ with uniform grid spacing $h = 2L/(N-1)$, evaluate the scalar curvature $R$ of $\\gamma_{ij}$ using the appropriate expression implied by the conformal method and your derived $\\psi(r)$, and measure a scalar error norm of the Hamiltonian constraint residual over valid grid points. Use second-order accurate central differences to approximate derivatives and exclude boundary points and excised points (and any finite-difference stencils that would touch excised points).\n- Quantify the observed order of convergence $p_{\\mathrm{H}}$ by computing the error norm at two resolutions with spacings $h_{1}$ and $h_{2}$ and forming $p_{\\mathrm{H}} = \\ln(E_{1}/E_{2})/\\ln(h_{1}/h_{2})$.\n\nTask B (Momentum constraint for spinning Bowen–York data):\n- Start from the vacuum momentum constraint $D_{j}(K^{ij} - \\gamma^{ij} K) = 0$, where $D_{j}$ is the Levi-Civita covariant derivative of $\\gamma_{ij}$. Within the conformal method with $\\gamma_{ij} = \\psi^{4}\\delta_{ij}$ and a trace-free extrinsic curvature, the conformal trace-free part $\\tilde{A}^{ij}$ is chosen to satisfy the flat-space divergence-free condition $\\partial_{j}\\tilde{A}^{ij} = 0$, where indices on $\\tilde{A}^{ij}$ are raised and lowered with $\\delta_{ij}$ and derivatives are with respect to the flat metric.\n- For a single spinning black hole with spin vector aligned with the $z$-axis, derive the explicit analytic form of $\\tilde{A}^{ij}(x^{k})$ that solves the flat momentum constraint, starting from the vector potential construction in the conformal transverse-traceless decomposition, and write it in terms of the unit radial vector $n^{i} = x^{i}/r$ and the constant spin vector $S^{i}$.\n- On the same type of cubic grid (with the same excision and finite-difference rules), evaluate the flat-space divergence $\\partial_{j} \\tilde{A}^{ij}$ using second-order accurate central differences and measure a scalar error norm that quantifies the residual. As this constraint is exactly satisfied analytically outside the puncture, your discretization error should converge to zero as the grid is refined. Compute the observed order of convergence $p_{\\mathrm{M}}$ using the same formula as in Task A.\n\nTask C (Far-zone wave extraction using the Newman–Penrose scalar):\n- At future null infinity in the Bondi gauge, the complex Newman–Penrose scalar $\\Psi_{4}$ is related to the gravitational-wave strains $h_{+}(t,r,\\theta,\\phi)$ and $h_{\\times}(t,r,\\theta,\\phi)$ by $\\Psi_{4} \\approx -\\partial_{t}^{2}(h_{+} - i h_{\\times})$ on an outgoing null foliation. Assume a synthetic, spherically symmetric far-zone waveform where $h_{+}$ and $h_{\\times}$ depend only on the retarded time $u = t - r$ and take the form $h_{+}(u) = A \\exp(-(u/\\sigma)^{2}) \\cos(\\omega u)$ and $h_{\\times}(u) = A \\exp(-(u/\\sigma)^{2}) \\sin(\\omega u)$ with constants $A$, $\\sigma$, and $\\omega$.\n- Use the above relation to compute $\\Psi_{4}(t,r)$ at two different extraction radii $r_{1}$ and $r_{2}$ at a fixed coordinate time $t_{0}$, and evaluate the rescaled amplitudes $Q_{i} = r_{i} |\\Psi_{4}(t_{0}, r_{i})|$ for $i \\in \\{1,2\\}$. Report the relative discrepancy $\\Delta_{\\mathrm{wave}} = |Q_{1} - Q_{2}| / \\left( \\frac{|Q_{1}| + |Q_{2}|}{2} \\right)$ as a dimensionless scalar. Angles must be in radians, and all quantities are dimensionless in geometric units.\n\nDiscretization and norms:\n- Use a second-order accurate, centered finite-difference approximation for all spatial derivatives on a uniform Cartesian grid. For a scalar field $f$, the discrete Laplacian at an interior grid point is approximated by the standard six-point stencil applied with spacing $h$, and the centered finite difference for $\\partial_{x}$ by $(f(x+h)-f(x-h))/(2h)$, and similarly for other components.\n- For Tasks A and B, use an excision sphere of radius $r_{\\mathrm{ex}}$ around the origin and also exclude any interior point whose finite-difference stencil would include any excised point or any boundary point.\n- Use the root-mean-square (RMS) norm of the pointwise residual over all valid interior points to define the error $E$, i.e., $E = \\sqrt{\\frac{1}{N_{\\mathrm{val}}}\\sum_{\\mathrm{valid}} (\\mathrm{residual})^{2}}$.\n\nTest suite:\n- Use the following parameters for two-grid convergence studies in Tasks A and B:\n  - Mass parameter $M = 1$.\n  - Domain half-size $L = 8$ so that the domain is $[-L,L]^{3}$.\n  - Excision radius $r_{\\mathrm{ex}} = 0.5$.\n  - Grid sizes $N_{1} = 41$ and $N_{2} = 81$, corresponding to spacings $h_{1} = 2L/(N_{1}-1)$ and $h_{2} = 2L/(N_{2}-1)$.\n  - For Task B, spin vector $S^{i} = (0,0,S)$ with $S = 0.5$.\n- For Task C (wave extraction), use the waveform parameters $A = 10^{-3}$, $\\sigma = 10$, $\\omega = 0.5$, extraction radii $r_{1} = 50$, $r_{2} = 100$, and extraction time $t_{0} = 120$.\n\nWhat to compute and report:\n- Compute the observed order of convergence $p_{\\mathrm{H}}$ for the Hamiltonian constraint residual (Task A) using the RMS norm at $N_{1}$ and $N_{2}$.\n- Compute the observed order of convergence $p_{\\mathrm{M}}$ for the momentum constraint residual (Task B) using the RMS norm at $N_{1}$ and $N_{2}$.\n- Compute the relative discrepancy $\\Delta_{\\mathrm{wave}}$ for the rescaled Newman–Penrose amplitude (Task C) at the given $r_{1}$ and $r_{2}$ and $t_{0}$.\n\nFinal output format:\n- Your program should produce a single line of output containing the three results as a comma-separated list enclosed in square brackets, in the order $[p_{\\mathrm{H}}, p_{\\mathrm{M}}, \\Delta_{\\mathrm{wave}}]$.\n- Each value must be printed as a floating-point number with at least three decimal places.", "solution": "The user has provided a well-defined computational problem in numerical relativity. The problem is scientifically grounded, free of contradictions, and contains all necessary information to proceed with a solution. The tasks require the numerical verification of fundamental equations in the Arnowitt-Deser-Misner (ADM) formalism and gravitational wave theory.\n\nThe problem is valid based on the following assessment:\n- **Scientifically Grounded and Objective**: The problem is based on the standard $(3+1)$ decomposition of general relativity, specifically the ADM constraint equations and the Newman-Penrose formalism for gravitational waves. All equations and concepts ($R$, $K_{ij}$, $\\gamma_{ij} = \\psi^4 \\delta_{ij}$, Bowen-York curvature, $\\Psi_4$) are standard in the field.\n- **Well-Posed and Complete**: The problem is structured into three distinct, solvable tasks. All required parameters, boundary conditions (asymptotic flatness), and initial data forms (time-symmetric, spinning) are specified. The numerical methods (second-order finite differences), domain, grid sizes, and error norms are explicitly defined, leading to a unique numerical result.\n- **Formalizable and Relevant**: The tasks directly translate into a concrete algorithm. The problem is highly relevant to the specified topic of *Schwarzschild and Kerr black hole solutions* within *numerical relativity and gravitational waves*.\n\nThe solution will be implemented by addressing each task sequentially, deriving the necessary analytical expressions from first principles as required, and then discretizing them numerically.\n\n### Task A: Hamiltonian Constraint for Isotropic Schwarzschild Data\n\n- **Analytical Formulation**: The vacuum Hamiltonian constraint is $H \\equiv R + K^2 - K_{ij}K^{ij} = 0$. For a time-symmetric slice, the extrinsic curvature $K_{ij}=0$, so the constraint reduces to $R=0$, where $R$ is the Ricci scalar of the spatial metric $\\gamma_{ij}$.\n- The spatial metric is conformally flat, $\\gamma_{ij} = \\psi^4 \\delta_{ij}$, where $\\delta_{ij}$ is the flat metric. The Ricci scalar is related to the conformal factor $\\psi$ by $R = -8\\psi^{-5}\\nabla^2\\psi$, where $\\nabla^2$ is the flat-space Laplacian. The constraint $R=0$ implies $\\nabla^2\\psi=0$ for $\\psi \\neq 0$.\n- For a single, non-spinning black hole, we seek a spherically symmetric solution that is asymptotically flat ($\\psi \\to 1$ as $r \\to \\infty$). The general spherically symmetric solution to Laplace's equation is $\\psi(r) = C_1 + C_2/r$. The boundary condition at infinity gives $C_1=1$.\n- The ADM mass $M$ is related to the conformal factor by $M = -\\frac{1}{2\\pi}\\oint_{S_\\infty} \\partial_i\\psi\\,dS^i$. With $\\psi(r) = 1 + C_2/r$, we find $\\partial_r\\psi = -C_2/r^2$. The surface integral gives $M = -\\frac{1}{2\\pi}(-C_2/r^2)(4\\pi r^2) = 2C_2$. Thus, $C_2 = M/2$.\n- The required conformal factor is $\\psi(r) = 1 + \\frac{M}{2r}$. Analytically, $R=0$ for $r0$.\n- **Numerical Discretization**: We will compute the residual $H_{num} = -8\\psi^{-5}\\nabla^2_h\\psi$, where $\\nabla^2_h$ is the second-order accurate finite-difference approximation of the Laplacian on a Cartesian grid with spacing $h$. The error $E_H$ is the Root-Mean-Square (RMS) of $H_{num}$ over all valid grid points. The convergence rate $p_H$ is computed from errors at two resolutions.\n\n### Task B: Momentum Constraint for Spinning Bowen-York Data\n\n- **Analytical Formulation**: The vacuum momentum constraint is $M^i \\equiv D_j(K^{ij} - \\gamma^{ij}K) = 0$. Within the conformal transverse-traceless decomposition, we use a conformally flat metric $\\gamma_{ij} = \\psi^4\\delta_{ij}$ and a trace-free extrinsic curvature, $K=0$. The problem specifies using a quantity $\\tilde{A}^{ij}$ (the conformal extrinsic curvature) that is divergence-free in flat space, i.e., $\\partial_j\\tilde{A}^{ij}=0$, where $\\partial_j$ is the flat-space partial derivative.\n- The Bowen-York solution provides such a tensor for a spinning black hole. For a black hole at the origin with spin vector $\\vec{S}$ and zero linear momentum, this tensor is given by $\\tilde{A}^{ij} = \\frac{3}{r^3}(n^i(\\vec{S}\\times\\vec{n})^j + n^j(\\vec{S}\\times\\vec{n})^i)$, where $\\vec{n} = \\vec{x}/r$ is the radial unit vector.\n- With $\\vec{S} = (0, 0, S)$, we have $(\\vec{S}\\times\\vec{x})^x = -Sy$, $(\\vec{S}\\times\\vec{x})^y = Sx$, and $(\\vec{S}\\times\\vec{x})^z = 0$. The components of $\\tilde{A}^{ij}$ are:\n$$\n\\tilde{A}^{xx} = -\\frac{6Sxy}{r^5}, \\quad \\tilde{A}^{yy} = \\frac{6Sxy}{r^5}, \\quad \\tilde{A}^{zz} = 0 \\\\\n\\tilde{A}^{xy} = \\frac{3S(x^2-y^2)}{r^5}, \\quad \\tilde{A}^{xz} = -\\frac{3Syz}{r^5}, \\quad \\tilde{A}^{yz} = \\frac{3Sxz}{r^5}\n$$\nThis tensor is analytically divergence-free, $\\partial_j\\tilde{A}^{ij}=0$, for $r0$.\n- **Numerical Discretization**: We will compute the numerical divergence $M^i_{num} = \\partial_j^h \\tilde{A}^{ij}$ using second-order centered differences. The scalar residual at each point is taken as the squared magnitude of this vector, $|M_{num}|^2 = (M^x_{num})^2 + (M^y_{num})^2 + (M^z_{num})^2$. The error $E_M$ is the RMS norm of this vector magnitude over all valid grid points. The convergence order $p_M$ is computed similarly to Task A.\n\n### Task C: Far-Zone Wave Extraction\n\n- **Analytical Formulation**: The Newman-Penrose scalar $\\Psi_4$ is related to the complex gravitational wave strain $h = h_+ - ih_\\times$ by $\\Psi_4 \\approx -\\partial_t^2 h$ in the asymptotic far-zone. The retarded time is $u=t-r$.\n- Given the synthetic waveform $h_+(u) = A e^{-(u/\\sigma)^2}\\cos(\\omega u)$ and $h_\\times(u) = A e^{-(u/\\sigma)^2}\\sin(\\omega u)$, the complex strain is $h(u) = A e^{-(u/\\sigma)^2}e^{-i\\omega u} = A \\exp(-(u/\\sigma)^2 - i\\omega u)$.\n- The time derivatives can be replaced by derivatives with respect to $u$, since $\\partial_t = \\partial_u$ for a function of $u=t-r$.\n- First derivative: $\\partial_u h = A \\exp(\\dots) \\cdot (-2u/\\sigma^2 - i\\omega)$.\n- Second derivative: $\\partial_u^2 h = A \\partial_u\\left[\\exp(\\dots)\\cdot(-2u/\\sigma^2 - i\\omega)\\right] = A \\exp(\\dots)\\left[(-2u/\\sigma^2 - i\\omega)^2 - 2/\\sigma^2\\right]$.\n- So, $\\Psi_4(u) = -h(u)\\left[\\left(\\frac{-2u}{\\sigma^2} - i\\omega\\right)^2 - \\frac{2}{\\sigma^2}\\right]$.\n- **Numerical Evaluation**: The problem requires computing the quantity $Q = r|\\Psi_4|$ at two radii $r_1, r_2$ at a fixed time $t_0$. This involves evaluating $u_1 = t_0 - r_1$ and $u_2 = t_0 - r_2$, calculating $\\Psi_4(u_1)$ and $\\Psi_4(u_2)$ using the derived formula, and then finding $Q_1 = r_1|\\Psi_4(u_1)|$ and $Q_2 = r_2|\\Psi_4(u_2)|$. The relative discrepancy is $\\Delta_{\\mathrm{wave}} = |Q_1-Q_2| / ((Q_1 + Q_2)/2)$.\n\nThese steps are implemented in the provided Python code.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# This problem can be solved using only the numpy library.\n# from scipy import ... # is not needed.\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the three tasks and print the final result.\n    \"\"\"\n    \n    # Test suite parameters from the problem statement\n    M = 1.0\n    L = 8.0\n    R_EX = 0.5\n    N1, N2 = 41, 81\n    S_Z = 0.5\n    A_WAVE, SIGMA_WAVE, OMEGA_WAVE = 1e-3, 10.0, 0.5\n    R1_WAVE, R2_WAVE = 50.0, 100.0\n    T0_WAVE = 120.0\n\n    # --- Task A: Hamiltonian Constraint Convergence ---\n    h1 = 2.0 * L / (N1 - 1)\n    h2 = 2.0 * L / (N2 - 1)\n\n    E1_H = compute_hamiltonian_error(M, L, N1, R_EX)\n    E2_H = compute_hamiltonian_error(M, L, N2, R_EX)\n    \n    # Compute convergence order p_H, handling potential division by zero\n    if E1_H > 0 and E2_H > 0:\n        p_H = np.log(E1_H / E2_H) / np.log(h1 / h2)\n    else:\n        p_H = 0.0\n\n    # --- Task B: Momentum Constraint Convergence ---\n    E1_M = compute_momentum_error(S_Z, L, N1, R_EX)\n    E2_M = compute_momentum_error(S_Z, L, N2, R_EX)\n    \n    # Compute convergence order p_M\n    if E1_M > 0 and E2_M > 0:\n        p_M = np.log(E1_M / E2_M) / np.log(h1 / h2)\n    else:\n        p_M = 0.0\n\n    # --- Task C: Wave Extraction Discrepancy ---\n    delta_wave = compute_wave_discrepancy(A_WAVE, SIGMA_WAVE, OMEGA_WAVE, R1_WAVE, R2_WAVE, T0_WAVE)\n\n    # --- Final Output ---\n    results = [p_H, p_M, delta_wave]\n    # The final print statement must follow the specified format exactly.\n    print(f\"[{','.join(f'{x:.7f}' for x in results)}]\")\n\n\ndef get_grid_and_mask(L, N, r_ex):\n    \"\"\"\n    Generates a 3D Cartesian grid, computes radii, and creates a validity mask.\n\n    The validity mask identifies interior grid points whose finite-difference stencil\n    does not intersect the excision region or the grid boundary.\n    \"\"\"\n    h = 2.0 * L / (N - 1)\n    coords = np.linspace(-L, L, N, dtype=np.float64)\n    xx, yy, zz = np.meshgrid(coords, coords, coords, indexing='ij')\n    rr = np.sqrt(xx**2 + yy**2 + zz**2)\n\n    # The mask will be True for points where the stencil is valid.\n    # We only consider the interior region, of size (N-2, N-2, N-2).\n    \n    # Check if the center point and all 6 neighbors are outside the excision radius.\n    mask = (rr[1:-1, 1:-1, 1:-1] > r_ex)  \\\n           (rr[2:,   1:-1, 1:-1] > r_ex)  \\\n           (rr[0:-2, 1:-1, 1:-1] > r_ex)  \\\n           (rr[1:-1, 2:,   1:-1] > r_ex)  \\\n           (rr[1:-1, 0:-2, 1:-1] > r_ex)  \\\n           (rr[1:-1, 1:-1, 2:  ] > r_ex)  \\\n           (rr[1:-1, 1:-1, 0:-2] > r_ex)\n    \n    return (xx, yy, zz, rr, h), mask\n\n\ndef compute_hamiltonian_error(M, L, N, r_ex):\n    \"\"\"\n    Computes the RMS norm of the Hamiltonian constraint residual for Task A.\n    \"\"\"\n    (xx, yy, zz, rr, h), valid_mask_interior = get_grid_and_mask(L, N, r_ex)\n    \n    # Avoid division by zero at the origin (which is excised anyway).\n    rr_safe = np.copy(rr)\n    rr_safe[rr_safe == 0] = 1e-16\n\n    # Conformal factor psi = 1 + M / (2r)\n    psi = 1.0 + M / (2.0 * rr_safe)\n\n    # Compute numerical Laplacian of psi on the interior grid.\n    lap_psi_interior = (psi[2:, 1:-1, 1:-1] + psi[:-2, 1:-1, 1:-1] +\n                        psi[1:-1, 2:, 1:-1] + psi[1:-1, :-2, 1:-1] +\n                        psi[1:-1, 1:-1, 2:] + psi[1:-1, 1:-1, :-2] -\n                        6.0 * psi[1:-1, 1:-1, 1:-1]) / h**2\n\n    # Hamiltonian constraint residual: R = -8 * psi^-5 * lap_psi\n    psi_interior = psi[1:-1, 1:-1, 1:-1]\n    residual_interior = -8.0 * (psi_interior**-5) * lap_psi_interior\n\n    # Filter for valid points and compute RMS error.\n    valid_residuals = residual_interior[valid_mask_interior]\n    if valid_residuals.size == 0:\n        return 0.0\n    \n    error = np.sqrt(np.mean(valid_residuals**2))\n    return error\n\n\ndef compute_momentum_error(S, L, N, r_ex):\n    \"\"\"\n    Computes the RMS norm of the momentum constraint residual for Task B.\n    \"\"\"\n    (xx, yy, zz, rr, h), valid_mask_interior = get_grid_and_mask(L, N, r_ex)\n    \n    # Avoid division by zero at the origin.\n    rr_safe = np.copy(rr)\n    rr_safe[rr_safe == 0] = 1e-16\n    r5 = rr_safe**5\n\n    # Components of Bowen-York conformal extrinsic curvature A_ij\n    A_xx = -6.0 * S * xx * yy / r5\n    A_yy =  6.0 * S * xx * yy / r5\n    A_zz = np.zeros_like(xx)\n    A_xy =  3.0 * S * (xx**2 - yy**2) / r5\n    A_xz = -3.0 * S * yy * zz / r5\n    A_yz =  3.0 * S * xx * zz / r5\n\n    # Compute divergence on the interior grid using centered differences.\n    # M_i = d_j A_ij\n    Mx = ((A_xx[2:, 1:-1, 1:-1] - A_xx[:-2, 1:-1, 1:-1]) / (2*h) +\n          (A_xy[1:-1, 2:, 1:-1] - A_xy[1:-1, :-2, 1:-1]) / (2*h) +\n          (A_xz[1:-1, 1:-1, 2:] - A_xz[1:-1, 1:-1, :-2]) / (2*h))\n\n    My = ((A_xy[2:, 1:-1, 1:-1] - A_xy[:-2, 1:-1, 1:-1]) / (2*h) +\n          (A_yy[1:-1, 2:, 1:-1] - A_yy[1:-1, :-2, 1:-1]) / (2*h) +\n          (A_yz[1:-1, 1:-1, 2:] - A_yz[1:-1, 1:-1, :-2]) / (2*h))\n\n    Mz = ((A_xz[2:, 1:-1, 1:-1] - A_xz[:-2, 1:-1, 1:-1]) / (2*h) +\n          (A_yz[1:-1, 2:, 1:-1] - A_yz[1:-1, :-2, 1:-1]) / (2*h) +\n          (A_zz[1:-1, 1:-1, 2:] - A_zz[1:-1, 1:-1, :-2]) / (2*h))\n    \n    # Pointwise residual magnitude squared\n    residual_sq_interior = Mx**2 + My**2 + Mz**2\n\n    # Filter for valid points and compute RMS error.\n    valid_residuals_sq = residual_sq_interior[valid_mask_interior]\n    if valid_residuals_sq.size == 0:\n        return 0.0\n\n    error = np.sqrt(np.mean(valid_residuals_sq))\n    return error\n\n\ndef compute_wave_discrepancy(A, sigma, omega, r1, r2, t0):\n    \"\"\"\n    Computes the relative discrepancy of the rescaled Newman-Penrose scalar for Task C.\n    \"\"\"\n    u1 = t0 - r1\n    u2 = t0 - r2\n\n    def calculate_psi4(u, A, sigma, omega):\n        \"\"\"Helper function to calculate Psi_4 for a given retarded time u.\"\"\"\n        # complex strain h(u) = A * exp(-(u/sigma)^2 - i*omega*u)\n        h = A * np.exp(-(u/sigma)**2 - 1j * omega * u, dtype=np.complex128)\n        \n        # Psi_4 = -d^2h/dt^2 = -d^2h/du^2\n        # d^2h/du^2 = h * [ (-2u/sigma^2 - i*omega)^2 - 2/sigma^2 ]\n        inner_term = (-2.0 * u / sigma**2 - 1j * omega)**2 - 2.0 / sigma**2\n        ddu_h = h * inner_term\n        \n        psi4 = -ddu_h\n        return psi4\n\n    psi4_1 = calculate_psi4(u1, A, sigma, omega)\n    psi4_2 = calculate_psi4(u2, A, sigma, omega)\n\n    Q1 = r1 * np.abs(psi4_1)\n    Q2 = r2 * np.abs(psi4_2)\n\n    # Calculate relative discrepancy, avoiding division by zero\n    if (Q1 + Q2) == 0:\n        return 0.0\n    \n    discrepancy = np.abs(Q1 - Q2) / (0.5 * (Q1 + Q2))\n    return discrepancy\n\n\nif __name__ == \"__main__\":\n    solve()\n\n```", "id": "3485927"}, {"introduction": "When a black hole is perturbed, it radiates gravitational waves in a characteristic pattern known as quasinormal modes (QNMs), akin to a struck bell ringing at specific frequencies. These frequencies encode fundamental properties of the black hole. This practice [@problem_id:3485877] delves into a profound link between the dissipative part of these modes (the damping rate) and the underlying geometry, showing that it is governed by the instability of null geodesics at the photon sphere. By combining analytical derivation with a targeted numerical check, you will verify the eikonal limit, which beautifully connects the wave dynamics of perturbations to the particle dynamics of light rays.", "problem": "Consider a static, spherically symmetric spacetime with line element given in geometric units ($G=c=1$) by $ds^2=-f(r)\\,dt^2+f(r)^{-1}\\,dr^2+r^2(d\\theta^2+\\sin^2\\theta\\,d\\phi^2)$. Focus on the Schwarzschild case, where $f(r)=1-\\frac{2M}{r}$. Adopt $M=1$ so that all quantities are dimensionless, and treat all angles in radians.\n\nYour tasks are:\n\n1. Starting from the null geodesic equations for equatorial motion, identify the condition that determines the radius $r_{\\rm ph}$ of an unstable circular photon orbit and the corresponding coordinate angular frequency $\\Omega_{\\rm ph}$. Express your results in terms of $f(r)$ and its radial derivatives, evaluated at $r_{\\rm ph}$.\n\n2. By linearizing the radial motion about $r_{\\rm ph}$, derive the Lyapunov exponent $\\lambda$ that governs the exponential growth of small radial perturbations, expressed purely in terms of $f(r)$ and its radial derivatives at $r_{\\rm ph}$. Use coordinate time $t$ as the evolution parameter.\n\n3. For axial (odd-parity) gravitational perturbations of a Schwarzschild black hole, the master equation can be written as $\\frac{d^2\\Psi}{dx^2}+\\big(\\omega^2-V_\\ell(r)\\big)\\Psi=0$, where $x$ is the tortoise coordinate defined by $dx/dr=f(r)^{-1}$ and the Regge–Wheeler potential is $V_\\ell(r)=f(r)\\left(\\frac{\\ell(\\ell+1)}{r^2}-\\frac{6}{r^3}\\right)$ for integer $\\ell\\ge 2$. Using the first-order Wentzel–Kramers–Brillouin (WKB) approximation around the potential peak located at $r=r_0(\\ell)$, obtain the leading-order expression for the imaginary part of the quasinormal mode frequency $\\omega_{\\ell n}$ in terms of the potential $V_\\ell$ and its second derivative with respect to $x$, both evaluated at $r_0(\\ell)$. Treat $n\\in\\{0,1,2,\\dots\\}$ as the overtone index.\n\n4. In the eikonal regime $\\ell\\gg 1$, establish the relation between the damping rate $-\\operatorname{Im}(\\omega_{\\ell n})$ and the Lyapunov exponent $\\lambda$ at the photon orbit, showing that the WKB prediction reduces to the eikonal formula $-\\operatorname{Im}(\\omega_{\\ell n})\\approx (n+\\tfrac{1}{2})\\,\\lambda$.\n\n5. Implement a program that:\n   - Computes $r_{\\rm ph}$ by solving the circular null orbit condition derived in part 1 for $f(r)=1-\\frac{2}{r}$ with $M=1$.\n   - Computes $\\lambda$ using the expression derived in part 2.\n   - For each $(\\ell,n)$ in the test suite below, finds the peak $r_0(\\ell)$ of $V_\\ell(r)$, evaluates $V_\\ell(r_0)$ and its second derivative with respect to the tortoise coordinate $x$, and computes the first-order WKB damping rate $-\\operatorname{Im}(\\omega_{\\ell n})$ as obtained in part 3.\n   - Returns, for each test case, the relative error of the eikonal prediction with respect to the WKB damping rate, defined as $\\left|\\frac{\\,(n+\\tfrac{1}{2})\\lambda - \\left(-\\operatorname{Im}(\\omega_{\\ell n})\\right)\\,}{(n+\\tfrac{1}{2})\\lambda}\\right|$.\n\nUse the following test suite:\n- Case A (happy path): $(\\ell,n)=(10,0)$.\n- Case B (edge: small $\\ell$): $(\\ell,n)=(2,0)$.\n- Case C (edge: high $\\ell$, higher overtone): $(\\ell,n)=(50,1)$.\n\nYour program must produce a single line of output containing the three relative errors for cases A, B, and C, respectively, as a comma-separated list enclosed in square brackets (for example, $[e_A,e_B,e_C]$). No external input is permitted. All computations are in geometric units with $M=1$, and all angles are in radians. The outputs are dimensionless floats.", "solution": "We begin with the Schwarzschild line element in geometric units with $M=1$: $ds^2=-f(r)\\,dt^2+f(r)^{-1}\\,dr^2+r^2(d\\theta^2+\\sin^2\\theta\\,d\\phi^2)$ with $f(r)=1-\\frac{2}{r}$. We consider null equatorial geodesics, so $\\theta=\\frac{\\pi}{2}$ and $ds^2=0$.\n\n1. The geodesic Lagrangian is $\\mathcal{L}=\\tfrac{1}{2}\\left(-f(r)\\dot t^2+f(r)^{-1}\\dot r^2+r^2\\dot\\phi^2\\right)$, where a dot denotes derivative with respect to an affine parameter. Conserved energy and angular momentum per unit mass are $E=f(r)\\dot t$ and $L=r^2\\dot\\phi$. The null condition yields $0=-f(r)\\dot t^2+f(r)^{-1}\\dot r^2+r^2\\dot\\phi^2$. Eliminating $\\dot t$ and $\\dot\\phi$ in favor of $E$ and $L$ gives the radial equation\n$$\n\\dot r^2+V_{\\rm eff}(r)=E^2, \\quad V_{\\rm eff}(r)=f(r)\\frac{L^2}{r^2}.\n$$\nUnstable circular null orbits satisfy $\\dot r=0$ and $dV_{\\rm eff}/dr=0$. The condition $dV_{\\rm eff}/dr=0$ is\n$$\n\\frac{d}{dr}\\left(\\frac{f(r)}{r^2}\\right)=0 \\quad\\Longleftrightarrow\\quad r f'(r)-2 f(r)=0.\n$$\nEvaluated at the photon orbit radius $r=r_{\\rm ph}$, this defines $r_{\\rm ph}$. The coordinate angular frequency is\n$$\n\\Omega_{\\rm ph}\\equiv\\frac{d\\phi}{dt}=\\frac{\\dot\\phi}{\\dot t}=\\frac{L/r^2}{E/f(r)}=\\frac{f(r)}{r^2}\\frac{L}{E}.\n$$\nAt a circular null orbit, $V_{\\rm eff}(r_{\\rm ph})=E^2$, which implies $f(r_{\\rm ph})\\frac{L^2}{r_{\\rm ph}^2}=E^2$. Therefore $L/E=r_{\\rm ph}/\\sqrt{f(r_{\\rm ph})}$, and inserting into the expression for $\\Omega_{\\rm ph}$ yields\n$$\n\\Omega_{\\rm ph}=\\frac{\\sqrt{f(r_{\\rm ph})}}{r_{\\rm ph}}.\n$$\n\n2. To obtain the Lyapunov exponent, we linearize the radial equation about $r_{\\rm ph}$. Write $r(\\lambda)=r_{\\rm ph}+\\delta r(\\lambda)$ with $\\delta r$ small. The radial equation is $\\dot r^2+V_{\\rm eff}(r)=E^2$. Differentiating with respect to the affine parameter and linearizing gives an equation of the form\n$$\n\\ddot{\\delta r}+\\frac{1}{2}V_{\\rm eff}''(r_{\\rm ph})\\,\\delta r=0,\n$$\nwhere primes denote derivatives with respect to $r$. The growth rate measured in coordinate time $t$ requires changing variables via $\\frac{d}{d\\lambda}=\\dot t\\,\\frac{d}{dt}$, with $\\dot t=E/f(r)$. At $r_{\\rm ph}$, $\\dot t_{\\rm ph}=E/f(r_{\\rm ph})$. Thus\n$$\n\\frac{d^2\\delta r}{dt^2}+\\left[\\frac{V_{\\rm eff}''(r_{\\rm ph})}{2\\,\\dot t_{\\rm ph}^2}\\right]\\delta r=0,\n$$\nwhose unstable solution behaves as $\\delta r\\sim e^{\\lambda t}$ with\n$$\n\\lambda=\\sqrt{\\frac{-V_{\\rm eff}''(r_{\\rm ph})}{2\\,\\dot t_{\\rm ph}^2}}.\n$$\nUsing $V_{\\rm eff}=f L^2/r^2$, we compute $V_{\\rm eff}''(r)=L^2\\left[\\frac{f''(r)}{r^2}-\\frac{4 f'(r)}{r^3}+\\frac{6 f(r)}{r^4}\\right]$. The circular orbit condition $r f'(r)-2 f(r)=0$ implies at $r=r_{\\rm ph}$ that $\\frac{f'(r_{\\rm ph})}{r_{\\rm ph}}=\\frac{2 f(r_{\\rm ph})}{r_{\\rm ph}^2}$. Substituting and simplifying yields\n$$\nV_{\\rm eff}''(r_{\\rm ph})=L^2\\left[\\frac{f''(r_{\\rm ph})}{r_{\\rm ph}^2}-\\frac{8 f(r_{\\rm ph})}{r_{\\rm ph}^4}+\\frac{6 f(r_{\\rm ph})}{r_{\\rm ph}^4}\\right]\n=L^2\\left[\\frac{f''(r_{\\rm ph})}{r_{\\rm ph}^2}-\\frac{2 f(r_{\\rm ph})}{r_{\\rm ph}^4}\\right].\n$$\nAt the circular null orbit, $E^2=f(r_{\\rm ph})\\frac{L^2}{r_{\\rm ph}^2}$, so $\\dot t_{\\rm ph}=\\frac{E}{f(r_{\\rm ph})}=\\frac{L}{r_{\\rm ph}\\sqrt{f(r_{\\rm ph})}}$. Therefore\n$$\n\\lambda=\\sqrt{\\frac{-V_{\\rm eff}''(r_{\\rm ph})}{2\\,\\dot t_{\\rm ph}^2}}\n=\\sqrt{\\frac{-\\left[\\frac{f''(r_{\\rm ph})}{r_{\\rm ph}^2}-\\frac{2 f(r_{\\rm ph})}{r_{\\rm ph}^4}\\right] L^2}{2 \\left(\\frac{L^2}{r_{\\rm ph}^2 f(r_{\\rm ph})}\\right)}}\n=\\sqrt{\\frac{f(r_{\\rm ph})}{2}\\left[-f''(r_{\\rm ph})+\\frac{2 f(r_{\\rm ph})}{r_{\\rm ph}^2}\\right]} \\,\\frac{1}{r_{\\rm ph}}.\n$$\nEquivalently,\n$$\n\\lambda=\\sqrt{\\frac{f(r_{\\rm ph})\\left(2 f(r_{\\rm ph})-r_{\\rm ph}^2 f''(r_{\\rm ph})\\right)}{2\\,r_{\\rm ph}^2}}.\n$$\nFor Schwarzschild, $f(r)=1-\\frac{2}{r}$, $f'(r)=\\frac{2}{r^2}$, and $f''(r)=-\\frac{4}{r^3}$. The photon radius condition $r f'(r)-2 f(r)=0$ gives $r_{\\rm ph}=3$. Then\n$$\n\\Omega_{\\rm ph}=\\frac{\\sqrt{1-2/3}}{3}=\\frac{1}{3\\sqrt{3}},\\quad\n\\lambda=\\sqrt{\\frac{(1-2/3)\\left(2(1-2/3)-9(-4/27)\\right)}{2\\cdot 9}}\n=\\frac{1}{3\\sqrt{3}}=\\Omega_{\\rm ph}.\n$$\n\n3. The Regge–Wheeler potential for axial modes is $V_\\ell(r)=f(r)\\left(\\frac{\\ell(\\ell+1)}{r^2}-\\frac{6}{r^3}\\right)$. Define the tortoise coordinate $x$ via $dx/dr=f(r)^{-1}$. Near the peak of the potential at $x=x_0$ (corresponding to $r=r_0(\\ell)$), the first-order WKB approximation (Schutz–Will) gives\n$$\n\\frac{\\omega^2-V_0}{\\sqrt{-2 V_0''}}=-i\\left(n+\\frac{1}{2}\\right),\n$$\nwhere $V_0=V_\\ell(r_0)$ and $V_0''=\\left.\\frac{d^2V_\\ell}{dx^2}\\right|_{x_0}$. Solving for $\\omega$ to leading order yields\n$$\n\\omega\\approx \\sqrt{V_0}-i\\left(n+\\frac{1}{2}\\right)\\frac{\\sqrt{-2 V_0''}}{2\\sqrt{V_0}},\n$$\nso the damping rate is\n$$\n-\\operatorname{Im}(\\omega_{\\ell n})\\approx \\left(n+\\frac{1}{2}\\right)\\frac{\\sqrt{-2 V_0''}}{2\\sqrt{V_0}}=\\left(n+\\frac{1}{2}\\right)\\sqrt{\\frac{-V_0''}{2 V_0}}.\n$$\n\n4. In the eikonal limit $\\ell\\gg 1$, the peak of $V_\\ell$ approaches the photon orbit, $r_0(\\ell)\\to r_{\\rm ph}$, and $V_0\\sim \\ell(\\ell+1)\\frac{f(r_{\\rm ph})}{r_{\\rm ph}^2}=\\ell(\\ell+1)\\Omega_{\\rm ph}^2$. Using $d/dx=f(r)\\,d/dr$, we have $\\frac{d^2V_\\ell}{dx^2}=f^2 \\frac{d^2V_\\ell}{dr^2}+f f'\\frac{dV_\\ell}{dr}$. At the peak, $\\frac{dV_\\ell}{dr}=0$, so $V_0''=f(r_0)^2\\left.\\frac{d^2V_\\ell}{dr^2}\\right|_{r_0}$. In this regime, a direct computation shows that $\\sqrt{\\frac{-V_0''}{2 V_0}}\\to \\lambda$, giving the eikonal formula\n$$\n-\\operatorname{Im}(\\omega_{\\ell n})\\approx \\left(n+\\frac{1}{2}\\right)\\lambda.\n$$\n\n5. Algorithmic implementation:\n- Compute $r_{\\rm ph}$ by solving $r f'(r)-2 f(r)=0$ for $f(r)=1-2/r$; the solution is $r_{\\rm ph}=3$.\n- Compute $\\lambda$ using $\\lambda=\\sqrt{\\frac{f(r_{\\rm ph})\\left(2 f(r_{\\rm ph})-r_{\\rm ph}^2 f''(r_{\\rm ph})\\right)}{2\\,r_{\\rm ph}^2}}$.\n- For each $\\ell$:\n  - Find $r_0(\\ell)$ where $\\frac{dV_\\ell}{dr}=0$.\n  - Compute $V_0=V_\\ell(r_0)$ and $V_0''=\\left.\\frac{d^2V_\\ell}{dx^2}\\right|_{r_0}=f(r_0)^2\\left.\\frac{d^2V_\\ell}{dr^2}\\right|_{r_0}+f(r_0)f'(r_0)\\left.\\frac{dV_\\ell}{dr}\\right|_{r_0}$; at the maximum the second term is negligible by construction.\n  - Compute the WKB damping rate $-\\operatorname{Im}(\\omega_{\\ell n})\\approx\\left(n+\\tfrac{1}{2}\\right)\\sqrt{\\frac{-V_0''}{2 V_0}}$ and the relative error $\\left|\\frac{(n+\\tfrac{1}{2})\\lambda-\\left(-\\operatorname{Im}\\omega\\right)}{(n+\\tfrac{1}{2})\\lambda}\\right|$.\n\nWe then evaluate these relative errors for the specified test suite:\n- Case A: $(\\ell,n)=(10,0)$.\n- Case B: $(\\ell,n)=(2,0)$.\n- Case C: $(\\ell,n)=(50,1)$.\n\nThe program outputs a single line with the three dimensionless relative errors as a comma-separated list enclosed in square brackets, in the order [A,B,C]. This numerically verifies the eikonal relation by demonstrating decreasing relative error as $\\ell$ grows.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import brentq\n\n# Geometric units: G=c=M=1\ndef f(r):\n    return 1.0 - 2.0 / r\n\ndef fp(r):\n    return 2.0 / (r**2)\n\ndef fpp(r):\n    return -4.0 / (r**3)\n\ndef photon_orbit_radius():\n    # Solve r f'(r) - 2 f(r) = 0 for Schwarzschild\n    # Bracket between just outside horizon and a large radius\n    func = lambda r: r * fp(r) - 2.0 * f(r)\n    # The photon sphere is known at r=3; bracket [2.001, 10] ensures bracketing root\n    return brentq(func, 2.001, 10.0)\n\ndef lyapunov_exponent_at_photon_orbit():\n    r_ph = photon_orbit_radius()\n    fr = f(r_ph)\n    frr = fpp(r_ph)\n    # lambda = sqrt( f(r_ph) * [2 f(r_ph) - r_ph^2 f''(r_ph)] / (2 r_ph^2) )\n    lam = np.sqrt(fr * (2.0 * fr - r_ph**2 * frr) / (2.0 * r_ph**2))\n    return lam\n\ndef regge_wheeler_potential(r, ell):\n    L = ell * (ell + 1.0)\n    return f(r) * (L / r**2 - 6.0 / r**3)\n\ndef dV_dr(r, ell):\n    L = ell * (ell + 1.0)\n    fr = f(r)\n    fp_r = fp(r)\n    g = L / r**2 - 6.0 / r**3\n    gp = -2.0 * L / r**3 + 18.0 / r**4\n    return fp_r * g + fr * gp\n\ndef d2V_dr2(r, ell):\n    L = ell * (ell + 1.0)\n    fr = f(r)\n    fp_r = fp(r)\n    fpp_r = fpp(r)\n    g = L / r**2 - 6.0 / r**3\n    gp = -2.0 * L / r**3 + 18.0 / r**4\n    gpp = 6.0 * L / r**4 - 72.0 / r**5\n    return fpp_r * g + 2.0 * fp_r * gp + fr * gpp\n\ndef find_potential_peak_radius(ell):\n    # Find r0 where dV/dr = 0, near r=3. Bracket around [2.001, 10].\n    # dV/dr is positive below the peak and negative above for reasonable ell>=2.\n    func = lambda r: dV_dr(r, ell)\n    # Narrower bracket around 3 improves robustness\n    low = 2.01\n    high = 6.0\n    # Ensure sign change; if not, expand bracket\n    f_low = func(low)\n    f_high = func(high)\n    if f_low * f_high > 0:\n        # Expand bracket if needed\n        low = 2.001\n        high = 10.0\n    r0 = brentq(func, low, high)\n    return r0\n\ndef wkb_damping_rate(ell, n):\n    r0 = find_potential_peak_radius(ell)\n    V0 = regge_wheeler_potential(r0, ell)\n    # Second derivative with respect to tortoise coordinate x:\n    # d/dx = f(r) d/dr, so d2V/dx2 = f^2 d2V/dr2 + f f' dV/dr\n    fr = f(r0)\n    fp_r = fp(r0)\n    Vp = dV_dr(r0, ell)\n    Vpp = d2V_dr2(r0, ell)\n    Vxx = fr * (fr * Vpp + fp_r * Vp)\n    # At the maximum, Vxx should be negative\n    if Vxx >= 0 or V0 = 0:\n        # Safeguard: return NaN to indicate breakdown (should not occur for valid cases)\n        return np.nan\n    gamma = (n + 0.5) * np.sqrt(-Vxx / (2.0 * V0))\n    return gamma\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Cases: A: (ell=10, n=0), B: (ell=2, n=0), C: (ell=50, n=1)\n    test_cases = [\n        (10, 0),\n        (2, 0),\n        (50, 1),\n    ]\n\n    lam = lyapunov_exponent_at_photon_orbit()\n    results = []\n    for ell, n in test_cases:\n        gamma_wkb = wkb_damping_rate(ell, n)\n        target = (n + 0.5) * lam\n        rel_err = abs(target - gamma_wkb) / target\n        results.append(rel_err)\n\n    # Final print statement in the exact required format.\n    # Print floats with sufficient precision, as a comma-separated list enclosed in brackets.\n    print(f\"[{','.join(f'{x:.12g}' for x in results)}]\")\n\nsolve()\n```", "id": "3485877"}, {"introduction": "Studying gravitational or electromagnetic perturbations of a spinning Kerr black hole is significantly more challenging than for the spherically symmetric Schwarzschild case. The spacetime's rotation breaks the simple spherical symmetry, meaning that standard spherical harmonics are no longer the natural basis functions for separating variables in the field equations. This exercise [@problem_id:3485904] tasks you with constructing their replacement: the spin-weighted spheroidal harmonics. You will implement a numerical scheme to solve the governing Sturm-Liouville problem and generate these crucial functions, a vital skill for any advanced analysis of the Kerr geometry and its astrophysical implications.", "problem": "You must write a complete, runnable program that, for given spin weight $s$, azimuthal number $m$, degree $\\ell$, and dimensionless spheroidicity $c = a \\omega$, computes the spin-weighted spheroidal angular functions ${}_sS_{\\ell m}(\\theta;c)$ numerically by solving the associated Sturm–Liouville eigenvalue problem and validates their orthogonality over the unit sphere. Use angles measured in radians throughout. No external input is provided; your program must define and run the specified test suite and print the aggregated results in the required format.\n\nFundamental base and core definitions:\n- In the separable form of the Teukolsky master equation for perturbations of a Kerr black hole, the spin-weighted spheroidal harmonics (SWSphH) ${}_sS_{\\ell m}(\\theta;c)$ are the eigenfunctions of the angular ordinary differential equation obtained by substituting $x=\\cos\\theta$:\n$$\n\\frac{d}{dx}\\left[(1-x^2)\\frac{d S}{dx}\\right] + \\left[(c x)^2 - 2 c s x - \\frac{(m + s x)^2}{1-x^2} + s + A\\right] S(x) = 0,\n$$\nwhere $S(x) = {}_sS_{\\ell m}(\\arccos x;c)$, $c$ is the dimensionless spheroidicity, $s$ is the spin weight, $m$ is the azimuthal integer, and $A$ is the angular separation constant (eigenvalue). For $c=0$, one has $A = \\ell(\\ell+1) - s(s+1)$.\n- The full spin-weighted spheroidal harmonic on the sphere is defined here as\n$$\n{}_s\\mathcal{S}_{\\ell m}(\\theta,\\phi;c) = \\frac{1}{\\sqrt{2\\pi}}\\, {}_sS_{\\ell m}(\\theta;c)\\, e^{i m \\phi},\n$$\nso that the orthonormality relation over the sphere holds in the form\n$$\n\\int_0^{2\\pi}\\!\\!\\int_0^\\pi {}_s\\mathcal{S}_{\\ell m}(\\theta,\\phi;c)\\, {}_s\\mathcal{S}_{\\ell' m'}(\\theta,\\phi;c)^{\\!*}\\, \\sin\\theta\\, d\\theta\\, d\\phi = \\delta_{\\ell\\ell'} \\delta_{mm'}.\n$$\nWith the change of variable $x=\\cos\\theta$, this reduces to\n$$\n\\int_{-1}^{1} {}_sS_{\\ell m}(x;c)\\, {}_sS_{\\ell' m}(x;c)\\, dx = \\delta_{\\ell\\ell'}.\n$$\n\nYour task:\n1) Discretize the self-adjoint angular operator as a one-dimensional Sturm–Liouville problem on $x \\in [-1,1]$ for fixed $(s,m,c)$:\n$$\n\\mathcal{L}[S](x) = \\frac{d}{dx}\\left[(1-x^2)\\frac{d S}{dx}\\right] + V_{s m c}(x)\\, S(x), \\quad\nV_{s m c}(x) = (c x)^2 - 2 c s x - \\frac{(m + s x)^2}{1-x^2} + s,\n$$\nand seek $A$ such that $\\mathcal{L}[S](x) + A\\, S(x) = 0$ with $S(x)$ regular at $x=\\pm 1$. Use a conservative finite-volume discretization on an $N$-cell uniform grid of cell centers covering $[-1,1]$, with natural no-flux boundary behavior imposed at $x=\\pm 1$ for the term $(1-x^2) dS/dx$. Construct a symmetric tridiagonal matrix representing $\\mathcal{L}$ so that the discrete eigenproblem reads\n$$\n\\mathbf{L}\\,\\mathbf{S} = -A\\, \\mathbf{S},\n$$\nand find the smallest eigenvalues $A$ (ascending) and corresponding eigenvectors.\n\n2) Normalize each discrete eigenvector to enforce the continuous normalization condition\n$$\n\\int_{-1}^{1} S_\\alpha(x)\\, S_\\beta(x)\\, dx = \\delta_{\\alpha\\beta},\n$$\nby approximating the integral with the midpoint rule on your uniform cell-centered grid. Here $\\alpha,\\beta$ denote mode indices at fixed $(s,m,c)$. The normalization of the full ${}_s\\mathcal{S}_{\\ell m}$ is then achieved by the prefactor $1/\\sqrt{2\\pi}$ in $\\phi$.\n\n3) Mode identification: for given $(s,m,c)$, the allowed degrees satisfy $\\ell \\ge \\ell_{\\min} = \\max(|m|,|s|)$. Order the eigenpairs by ascending $A$. Associate the $k$-th eigenpair with $\\ell=\\ell_{\\min}+k$, $k\\in\\{0,1,2,\\dots\\}$.\n\n4) Orthogonality validation: For each requested pair of modes, compute the numerical inner product\n$$\nI = \\int_0^{2\\pi}\\!\\!\\int_0^\\pi {}_s\\mathcal{S}_{\\ell m}\\, {}_s\\mathcal{S}_{\\ell' m'}^{\\!*}\\, \\sin\\theta\\, d\\theta\\, d\\phi,\n$$\nby:\n- Using the midpoint rule in $x=\\cos\\theta$ for the $\\theta$-integral, consistent with your grid and normalization.\n- Approximating the $\\phi$-integral with the trapezoidal rule over $M_\\phi$ uniform points on $[0,2\\pi)$ in radians.\n\nReport the absolute error $|I - \\delta_{\\ell\\ell'}\\delta_{mm'}|$ as a float.\n\nAngle unit requirement: All angles are in radians.\n\nTest suite and required outputs:\nImplement and run the following six test cases; for each, output the absolute error $|I - \\delta_{\\ell\\ell'}\\delta_{mm'}|$:\n- Test 1 (happy path, exact spherical limit): $s=-2$, $m=2$, $c=0.0$, compare $(\\ell,\\ell')=(2,2)$.\n- Test 2 (orthogonality across degrees at $c=0$): $s=-2$, $m=2$, $c=0.0$, compare $(\\ell,\\ell')=(2,3)$.\n- Test 3 (spheroidal case, moderate $c$): $s=-2$, $m=2$, $c=0.5$, compare $(\\ell,\\ell')=(2,2)$.\n- Test 4 (orthogonality across azimuthal numbers): $s=-2$, $m=1$ versus $m'=2$, $c=0.5$, both with $\\ell=\\ell'=2$.\n- Test 5 (scalar limit, spherical case): $s=0$, $m=0$, $c=0.0$, compare $(\\ell,\\ell')=(0,1)$.\n- Test 6 (scalar spheroidal, moderate $c$): $s=0$, $m=0$, $c=1.0$, compare $(\\ell,\\ell')=(0,0)$.\n\nNumerical parameters:\n- Use a uniform cell-centered grid with $N=400$ cells on $x\\in[-1,1]$.\n- Use $M_\\phi=256$ uniform points on $\\phi\\in[0,2\\pi)$.\n\nFinal output format:\nYour program should produce a single line of output containing the six floating-point errors for Tests 1–6, as a comma-separated Python list enclosed in square brackets, in the order listed above. For example: \"[e1,e2,e3,e4,e5,e6]\". No other text should be printed.", "solution": "The problem requires the numerical computation of spin-weighted spheroidal harmonics, ${}_sS_{\\ell m}(\\theta;c)$, and the validation of their orthonormality. This is achieved by solving the associated angular differential equation, which forms a Sturm-Liouville problem. The solution is executed via a finite-volume discretization, followed by a numerical verification of the orthogonality relation.\n\n### Principle-Based Design\n\n#### 1. Sturm-Liouville Problem Formulation\nThe governing ordinary differential equation for the angular function $S(x) = {}_sS_{\\ell m}(\\arccos x;c)$ is given by:\n$$\n\\frac{d}{dx}\\left[(1-x^2)\\frac{d S}{dx}\\right] + \\left[(c x)^2 - 2 c s x - \\frac{(m + s x)^2}{1-x^2} + s + A\\right] S(x) = 0\n$$\nThis equation can be expressed in the form of a self-adjoint Sturm-Liouville eigenproblem, $\\mathcal{L}[S](x) + A S(x) = 0$, where the operator $\\mathcal{L}$ is defined as:\n$$\n\\mathcal{L}[S](x) = \\frac{d}{dx}\\left(p(x)\\frac{dS}{dx}\\right) + q(x)S(x)\n$$\nwith $p(x) = 1-x^2$ and the potential $q(x) = V_{s m c}(x) = (c x)^2 - 2 c s x - \\frac{(m + s x)^2}{1-x^2} + s$. The angular separation constant $A$ is the eigenvalue, and the function $S(x)$ is the eigenfunction, which must be regular at the boundaries $x=\\pm 1$.\n\n#### 2. Finite-Volume Discretization\nWe discretize the operator $\\mathcal{L}$ on a uniform grid over the domain $x \\in [-1, 1]$. The domain is divided into $N$ cells of width $\\Delta x = 2/N$. The cell centers are denoted by $x_i = -1 + (i + 0.5)\\Delta x$ for $i=0, 1, \\dots, N-1$, and the cell faces are at $x_{i+1/2} = -1 + (i+1)\\Delta x$.\n\nWe integrate the eigenproblem equation over the $i$-th cell, from $x_{i-1/2}$ to $x_{i+1/2}$:\n$$\n\\int_{x_{i-1/2}}^{x_{i+1/2}} \\left( \\frac{d}{dx}\\left[p(x)\\frac{dS}{dx}\\right] + (q(x)+A)S(x) \\right) dx = 0\n$$\nApplying the fundamental theorem of calculus to the first term and the midpoint rule to the second yields:\n$$\n\\left[p(x)\\frac{dS}{dx}\\right]_{i+1/2} - \\left[p(x)\\frac{dS}{dx}\\right]_{i-1/2} + (q(x_i) + A)S(x_i)\\Delta x \\approx 0\n$$\nThe derivatives at the cell faces are approximated by central differences of the function values at adjacent cell centers, $S_i = S(x_i)$:\n$$\n\\left(\\frac{dS}{dx}\\right)_{i+1/2} \\approx \\frac{S_{i+1} - S_i}{\\Delta x}\n$$\nSubstituting these approximations and dividing by $\\Delta x$ organizes the equation for the $i$-th cell into a linear algebraic equation involving $S_{i-1}$, $S_i$, and $S_{i+1}$.\n\n#### 3. Matrix Eigenproblem Construction\nThis system of $N$ linear equations forms a matrix eigenproblem $\\mathbf{L}\\mathbf{S} = -A\\mathbf{S}$, where $\\mathbf{S}$ is the vector of eigenfunction values $[S_0, S_1, \\dots, S_{N-1}]^T$. The matrix $\\mathbf{L}$ is a real, symmetric, tridiagonal matrix. Its elements are determined from the discretized equation:\n- Diagonal elements: $L_{i,i} = -\\frac{p_{i+1/2} + p_{i-1/2}}{(\\Delta x)^2} + q_i$\n- Off-diagonal elements: $L_{i, i+1} = L_{i+1, i} = \\frac{p_{i+1/2}}{(\\Delta x)^2}$\n\nThe boundary conditions are handled naturally by the factor $p(x)=1-x^2$, which vanishes at the domain endpoints, $p(\\pm 1) = 0$. In our grid, this means $p(x_{-1/2})=0$ and $p(x_{N-1/2})=0$, which simplifies the equations for the first ($i=0$) and last ($i=N-1$) cells, closing the system without requiring ghost cells. This structure ensures $\\mathbf{L}$ is symmetric.\n\n#### 4. Eigenvalue Solution and Mode Identification\nThe symmetric tridiagonal eigenproblem is efficiently solved using specialized numerical routines, such as `scipy.linalg.eigh_tridiagonal`. This yields a set of $N$ real eigenvalues, $\\lambda_k = -A_k$, and their corresponding orthonormal eigenvectors, $\\mathbf{v}_k$. The eigenvalues $A_k$ are sorted in ascending order. The problem specifies a mode identification rule: for fixed $(s, m)$, the $k$-th eigenmode (with $k=0, 1, 2, \\dots$) corresponds to the degree $\\ell = \\ell_{\\min} + k$, where $\\ell_{\\min} = \\max(|m|, |s|)$.\n\n#### 5. Eigenfunction Normalization\nThe eigenvectors $\\mathbf{v}_k$ returned by standard libraries are typically normalized in the Euclidean sense, $\\sum_i (v_{k,i})^2 = 1$. However, the physical orthonormality condition for the continuous functions is $\\int_{-1}^1 S_k(x) S_j(x) dx = \\delta_{kj}$. Approximating this integral with the midpoint rule gives the discrete normalization condition:\n$$\n\\sum_{i=0}^{N-1} S_k(x_i) S_j(x_i) \\Delta x = \\delta_{kj}\n$$\nTo satisfy this, the library's eigenvectors $\\mathbf{v}_k$ must be rescaled. The correctly normalized discrete eigenfunction is given by $\\mathbf{S}_k = \\mathbf{v}_k / \\sqrt{\\Delta x}$.\n\n#### 6. Orthogonality Validation\nThe final step is to validate the orthonormality of the full spheroidal harmonics ${}_s\\mathcal{S}_{\\ell m}(\\theta,\\phi;c)$ by computing the integral:\n$$\nI = \\int_0^{2\\pi}\\!\\!\\int_0^\\pi {}_s\\mathcal{S}_{\\ell m}(\\theta,\\phi;c)\\, {}_s\\mathcal{S}_{\\ell' m'}(\\theta,\\phi;c)^{\\!*}\\, \\sin\\theta\\, d\\theta\\, d\\phi\n$$\nSubstituting the definition ${}_s\\mathcal{S}_{\\ell m} = \\frac{1}{\\sqrt{2\\pi}} {}_sS_{\\ell m} e^{im\\phi}$ and changing variables to $x=\\cos\\theta$, the integral becomes:\n$$\nI = \\left(\\frac{1}{2\\pi} \\int_0^{2\\pi} e^{i(m-m')\\phi} d\\phi\\right) \\left(\\int_{-1}^1 {}_sS_{\\ell m}(x;c)\\, {}_sS_{\\ell' m'}(x;c)\\, dx\\right)\n$$\nThe integral over $\\phi$ is computed using the trapezoidal rule on a uniform grid of $M_\\phi$ points. The integral over $x$ is computed using the midpoint rule, consistent with the grid and normalization established earlier. The final numerical result $I_{\\text{num}}$ is compared against the theoretical value $\\delta_{\\ell\\ell'}\\delta_{mm'}$, and the absolute error is reported. Since the eigenvectors are real, the conjugate on ${}_sS_{\\ell' m'}$ has no effect. The numerical orthogonality of the discrete eigenvectors $\\mathbf{S}_k$ ensures that the $x$-integral evaluates to $\\delta_{\\ell\\ell'}$, and the discrete Fourier sum for the $\\phi$-integral evaluates to $2\\pi \\delta_{mm'}$. Consequently, the total error is expected to be near machine precision, confirming the self-consistency of the entire numerical procedure.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh_tridiagonal\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for spin-weighted spheroidal harmonics.\n    \"\"\"\n\n    # Numerical parameters as specified in the problem statement.\n    N = 400\n    M_phi = 256\n\n    # Test suite definition. Each case is a pair of mode parameter tuples.\n    # Format: ((s, m, c, l), (s', m', c', l'))\n    # s' and c' are always the same as s and c in these tests.\n    test_cases = [\n        ((-2, 2, 0.0, 2), (-2, 2, 0.0, 2)),  # Test 1\n        ((-2, 2, 0.0, 2), (-2, 2, 0.0, 3)),  # Test 2\n        ((-2, 2, 0.5, 2), (-2, 2, 0.5, 2)),  # Test 3\n        ((-2, 1, 0.5, 2), (-2, 2, 0.5, 2)),  # Test 4\n        ((0, 0, 0.0, 0), (0, 0, 0.0, 1)),   # Test 5\n        ((0, 0, 1.0, 0), (0, 0, 1.0, 0)),   # Test 6\n    ]\n\n    results = []\n    memo = {}  # Memoization to store computed eigenpairs for a given (s, m, c)\n\n    def get_spheroidal_harmonic(s, m, c, l):\n        \"\"\"\n        Computes the discrete spin-weighted spheroidal harmonic for given parameters.\n        Utilizes memoization to avoid re-computing for the same (s, m, c).\n        \"\"\"\n        key = (s, m, c)\n        if key not in memo:\n            # Setup grid for x in [-1, 1]\n            dx = 2.0 / N\n            x_centers = -1.0 + (np.arange(N) + 0.5) * dx\n            x_faces = -1.0 + np.arange(N + 1) * dx\n\n            # Define p(x) = 1 - x^2 and q(x) = V(x)\n            p = 1.0 - x_faces**2\n            p[0], p[-1] = 0.0, 0.0 # Enforce boundary conditions exactly\n\n            # Potential term V(x). The grid points x_centers are never exactly +/- 1.\n            V = (c * x_centers)**2 - 2 * c * s * x_centers - (m + s * x_centers)**2 / (1 - x_centers**2) + s\n\n            # Construct the symmetric tridiagonal matrix L\n            diag = -(p[1:] + p[:-1]) / dx**2 + V\n            off_diag = p[1:-1] / dx**2\n\n            # Solve the eigenproblem L*S = -A*S.\n            # eigh_tridiagonal eigenvalues (lambdas) are sorted ascendingly.\n            lambdas, vecs = eigh_tridiagonal(diag, off_diag)\n\n            # Eigenvalues are A = -lambda. Sort A in ascending order.\n            A_sorted = -lambdas[::-1]\n            # Sort eigenvectors accordingly.\n            vecs_sorted = vecs[:, ::-1]\n\n            # Normalize eigenvectors for integral norm.\n            # Integral S^2 dx approx sum(S_i^2 * dx) = 1.\n            # S_i = v_i / sqrt(dx) -> sum(v_i^2/dx * dx) = sum(v_i^2) = 1.\n            S_normalized = vecs_sorted / np.sqrt(dx)\n            \n            memo[key] = {\n                'eigenvalues': A_sorted,\n                'eigenfunctions': S_normalized.T\n            }\n\n        # Identify the requested mode\n        l_min = max(abs(s), abs(m))\n        k = l - l_min\n        if k  0 or k >= N:\n             raise ValueError(f\"Degree l={l} is out of computable range for s={s}, m={m}.\")\n\n        return memo[key]['eigenfunctions'][k]\n\n    for case in test_cases:\n        params1, params2 = case\n        s1, m1, c1, l1 = params1\n        s2, m2, c2, l2 = params2\n\n        # Compute the two eigenfunctions to be compared\n        S1 = get_spheroidal_harmonic(s1, m1, c1, l1)\n        S2 = get_spheroidal_harmonic(s2, m2, c2, l2)\n\n        # Calculate the orthonormality integral numerically\n        dx = 2.0 / N\n        dphi = 2.0 * np.pi / M_phi\n\n        # 1. theta-integral part (using midpoint rule on x = cos(theta))\n        # This is the discrete inner product.\n        theta_integral = np.sum(S1 * S2) * dx\n\n        # 2. phi-integral part (using trapezoidal rule)\n        phi_grid = np.arange(M_phi) * dphi\n        phi_integrand = np.exp(1j * (m1 - m2) * phi_grid)\n        phi_integral = np.sum(phi_integrand) * dphi\n\n        # Combine to get the full integral I\n        I_num = (1.0 / (2.0 * np.pi)) * theta_integral * phi_integral\n        \n        # Determine the exact theoretical value (Kronecker deltas)\n        target = 1.0 if l1 == l2 and m1 == m2 else 0.0\n\n        # Calculate and store the absolute error\n        error = np.abs(I_num - target)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3485904"}]}