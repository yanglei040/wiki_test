{"hands_on_practices": [{"introduction": "The geodesic deviation equation provides a powerful linearization of the relative motion between nearby freely-falling particles. This first exercise is a fundamental validation of this principle in a non-trivial spacetime. By numerically integrating the full, nonlinear geodesic equations for two initially close particles in an exact plane gravitational wave background and comparing their actual separation to the solution of the much simpler, linear geodesic deviation equation, you will directly verify the accuracy and utility of this approximation [@problem_id:3492025]. This practice is a cornerstone of developing intuition and robust computational tools in numerical relativity.", "problem": "A program must be written to numerically integrate both the geodesic equation and the geodesic deviation equation for a plane gravitational wave spacetime expressed in Brinkmann coordinates. The spacetime line element is\n$$\nds^2 = -2\\,du\\,dv + dx^2 + dy^2 + g_{uu}(u,x,y)\\,du^2,\n$$\nwith\n$$\ng_{uu}(u,x,y) = H(u)\\,(x^2 - y^2).\n$$\nHere $u$ is an affine parameter along null geodesics, $v$ is the conjugate null coordinate, and $(x,y)$ are transverse spatial coordinates. The plane wave profile is specified by the function\n$$\nH(u) = A\\,\\exp\\!\\left(-\\frac{(u-u_0)^2}{2\\,\\sigma^2}\\right)\\,\\cos\\!\\left(\\omega\\,(u-u_0)\\right),\n$$\nwhere $A$ is the amplitude, $\\omega$ is the angular frequency, $\\sigma$ is the width of the Gaussian envelope, and $u_0$ is the pulse center. Angles must be interpreted in radians.\n\nStarting from the following fundamental base:\n- The geodesic equation,\n$$\n\\frac{d^2 x^\\mu}{d\\lambda^2} + \\Gamma^\\mu_{\\alpha\\beta}\\,\\frac{d x^\\alpha}{d\\lambda}\\,\\frac{d x^\\beta}{d\\lambda} = 0,\n$$\n- The definition of the Christoffel symbols in terms of the metric $g_{\\mu\\nu}$,\n$$\n\\Gamma^\\mu_{\\alpha\\beta} = \\frac{1}{2} g^{\\mu\\gamma}\\left( \\partial_\\alpha g_{\\beta\\gamma} + \\partial_\\beta g_{\\alpha\\gamma} - \\partial_\\gamma g_{\\alpha\\beta} \\right),\n$$\n- The geodesic deviation equation for a deviation vector $\\xi^\\mu$ along a reference geodesic with tangent $u^\\mu$,\n$$\n\\frac{D^2 \\xi^\\mu}{d\\lambda^2} = - R^\\mu_{\\nu\\rho\\sigma}\\,u^\\nu\\,\\xi^\\rho\\,u^\\sigma,\n$$\nderive the ordinary differential equations (ODEs) for the transverse coordinates $x(u)$ and $y(u)$ of a geodesic when choosing the affine parameter $\\lambda$ equal to $u$, and derive the ODEs for the transverse components of the deviation vector $\\xi^x(u)$ and $\\xi^y(u)$ along the same reference geodesic. All quantities are dimensionless and no physical units are involved.\n\nImplement a numerical solver in Python that:\n1. Integrates a reference geodesic with initial conditions\n$$\nu_{\\mathrm{start}} = 0,\\quad u_{\\mathrm{end}} = 2,\\quad x(0) = x_0,\\quad y(0) = y_0,\\quad \\frac{dx}{du}(0) = v_{x0},\\quad \\frac{dy}{du}(0) = v_{y0}.\n$$\n2. Integrates a neighboring geodesic with initial conditions\n$$\nx(0) = x_0 + \\delta x_0,\\quad y(0) = y_0 + \\delta y_0,\\quad \\frac{dx}{du}(0) = v_{x0},\\quad \\frac{dy}{du}(0) = v_{y0}.\n$$\n3. Integrates the geodesic deviation equation for the transverse deviation vector with initial conditions\n$$\n\\xi^x(0) = \\delta x_0,\\quad \\xi^y(0) = \\delta y_0,\\quad \\frac{d\\xi^x}{du}(0) = 0,\\quad \\frac{d\\xi^y}{du}(0) = 0.\n$$\n\nFor all test cases, use the common initial values\n$$\nx_0 = 0.1,\\quad y_0 = 0.05,\\quad v_{x0} = 0,\\quad v_{y0} = 0,\\quad \\delta x_0 = 10^{-4},\\quad \\delta y_0 = -2\\times 10^{-4}.\n$$\n\nFor each test case, after integrating to $u_{\\mathrm{end}}$, compute the Euclidean norm of the difference between the actual separation vector of the two geodesics and the deviation vector predicted by the geodesic deviation equation,\n$$\n\\varepsilon = \\sqrt{\\left[(x_{\\mathrm{nbr}} - x_{\\mathrm{ref}}) - \\xi^x\\right]^2 + \\left[(y_{\\mathrm{nbr}} - y_{\\mathrm{ref}}) - \\xi^y\\right]^2}\\Bigg|_{u=u_{\\mathrm{end}}},\n$$\nand report $\\varepsilon$ as a float.\n\nTest suite:\n- Case $1$: $A = 0.2$, $\\omega = 6$, $\\sigma = 0.3$, $u_0 = 1.0$.\n- Case $2$: $A = 0$, $\\omega = 6$, $\\sigma = 0.3$, $u_0 = 1.0$.\n- Case $3$: $A = 0.1$, $\\omega = 30$, $\\sigma = 0.2$, $u_0 = 1.0$.\n- Case $4$: $A = 0.5$, $\\omega = 10$, $\\sigma = 0.1$, $u_0 = 1.0$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[r_1,r_2,r_3,r_4]$), where each $r_i$ is the $\\varepsilon$ computed for the corresponding test case. Angles must be treated in radians. No external input is allowed, and the program must run as is.", "solution": "We begin from the fundamental geometric framework of General Relativity. A geodesic $x^\\mu(\\lambda)$ extremizes proper distance and satisfies the geodesic equation,\n$$\n\\frac{d^2 x^\\mu}{d\\lambda^2} + \\Gamma^\\mu_{\\alpha\\beta}(x)\\,\\frac{d x^\\alpha}{d\\lambda}\\,\\frac{d x^\\beta}{d\\lambda} = 0,\n$$\nwhere $\\Gamma^\\mu_{\\alpha\\beta}$ are the Christoffel symbols constructed from the metric $g_{\\mu\\nu}$ via\n$$\n\\Gamma^\\mu_{\\alpha\\beta} = \\frac{1}{2} g^{\\mu\\gamma}\\left( \\partial_\\alpha g_{\\beta\\gamma} + \\partial_\\beta g_{\\alpha\\gamma} - \\partial_\\gamma g_{\\alpha\\beta} \\right).\n$$\nThe deviation of neighboring geodesics is governed by the geodesic deviation equation for the deviation vector $\\xi^\\mu$,\n$$\n\\frac{D^2 \\xi^\\mu}{d\\lambda^2} = - R^\\mu_{\\nu\\rho\\sigma}\\,u^\\nu\\,\\xi^\\rho\\,u^\\sigma,\n$$\nwhere $u^\\mu = \\frac{dx^\\mu}{d\\lambda}$ is the tangent to the reference geodesic and $R^\\mu_{\\nu\\rho\\sigma}$ is the Riemann curvature tensor.\n\nWe are given the Brinkmann-form plane wave metric,\n$$\nds^2 = -2\\,du\\,dv + dx^2 + dy^2 + g_{uu}(u,x,y)\\,du^2, \\quad g_{uu}(u,x,y) = H(u)\\,(x^2 - y^2).\n$$\nThe nonzero metric components are $g_{uv} = g_{vu} = -1$, $g_{xx} = 1$, $g_{yy} = 1$, and $g_{uu} = H(u)\\,(x^2 - y^2)$. The inverse metric in the $\\{u,v\\}$ subspace is obtained by inverting the $2\\times 2$ block\n$$\n\\begin{pmatrix}\ng_{uu}  -1 \\\\\n-1  0\n\\end{pmatrix},\n$$\nwhich yields $g^{uu} = 0$, $g^{uv} = g^{vu} = -1$, and $g^{vv} = -g_{uu}$. In the transverse directions, $g^{xx} = 1$ and $g^{yy} = 1$.\n\nWe choose the affine parameter $\\lambda = u$, that is, we parametrize geodesics by the coordinate $u$. This implies $\\frac{du}{d\\lambda} = 1$. The geodesic equations for the transverse coordinates $x$ and $y$ reduce to\n$$\n\\frac{d^2 x}{du^2} + \\Gamma^x_{uu} = 0, \\qquad \\frac{d^2 y}{du^2} + \\Gamma^y_{uu} = 0,\n$$\nbecause the only nonzero quadratic velocity term involves $u$ derivatives. The Christoffel symbols with indices $(x;u,u)$ and $(y;u,u)$ are\n$$\n\\Gamma^x_{uu} = \\frac{1}{2} g^{x\\gamma}\\left( \\partial_u g_{u\\gamma} + \\partial_u g_{\\gamma u} - \\partial_\\gamma g_{uu} \\right) = -\\frac{1}{2}\\,\\partial_x g_{uu},\n$$\n$$\n\\Gamma^y_{uu} = -\\frac{1}{2}\\,\\partial_y g_{uu},\n$$\nbecause $g_{u\\gamma}$ is independent of $u$ and $g^{x\\gamma}$ picks $\\gamma=x$ while $g^{y\\gamma}$ picks $\\gamma=y$. With $g_{uu} = H(u)\\,(x^2 - y^2)$,\n$$\n\\partial_x g_{uu} = 2 H(u)\\,x, \\qquad \\partial_y g_{uu} = - 2 H(u)\\,y.\n$$\nTherefore,\n$$\n\\Gamma^x_{uu} = - H(u)\\,x, \\qquad \\Gamma^y_{uu} = + H(u)\\,y,\n$$\nand the transverse geodesic equations become the linear ODEs\n$$\n\\frac{d^2 x}{du^2} = H(u)\\,x, \\qquad \\frac{d^2 y}{du^2} = - H(u)\\,y.\n$$\nThese are time-dependent linear second-order ODEs resembling parametric oscillator equations with opposite signs in the two polarizations, a well-known tidal signature of the plus polarization in a plane gravitational wave.\n\nFor the geodesic deviation equation, we need the Riemann curvature components with two legs in the $u$ direction. For Brinkmann plane waves,\n$$\nR_{uiuj} = -\\frac{1}{2}\\,\\partial_i \\partial_j g_{uu},\n$$\nwith $i,j$ running over transverse indices $x,y$. Using $g_{uu} = H(u)\\,(x^2 - y^2)$, we find\n$$\n\\partial_x \\partial_x g_{uu} = 2 H(u), \\quad \\partial_y \\partial_y g_{uu} = -2 H(u), \\quad \\partial_x \\partial_y g_{uu} = 0,\n$$\nthus\n$$\nR_{uxux} = - H(u), \\qquad R_{uyuy} = + H(u), \\qquad R_{uxuy} = R_{uyux} = 0.\n$$\nRaising the first transverse index with $g^{xx} = g^{yy} = 1$ gives\n$$\nR^x_{\\ u x u} = R_{x u x u} = R_{uxux} = - H(u), \\qquad R^y_{\\ u y u} = R_{uyuy} = + H(u).\n$$\nAdopting the standard sign convention for the geodesic deviation equation,\n$$\n\\frac{D^2 \\xi^\\mu}{d\\lambda^2} = - R^\\mu_{\\nu\\rho\\sigma}\\,u^\\nu\\,\\xi^\\rho\\,u^\\sigma,\n$$\nand taking $u^\\mu$ to have only $u$-component equal to $1$ in our parametrization, the transverse components of the deviation equation become\n$$\n\\frac{d^2 \\xi^x}{du^2} = - R^x_{\\ u x u}\\,\\xi^x = + H(u)\\,\\xi^x,\n$$\n$$\n\\frac{d^2 \\xi^y}{du^2} = - R^y_{\\ u y u}\\,\\xi^y = - H(u)\\,\\xi^y.\n$$\nThese exactly match the linearized difference of the transverse geodesic equations, which is expected because the transverse geodesic equations are linear in $(x,y)$. Consequently, for two neighboring geodesics with small initial separation and equal initial transverse velocities, the deviation vector $\\xi^i(u)$ equals the actual separation vector $(x_{\\mathrm{nbr}}(u) - x_{\\mathrm{ref}}(u),\\,y_{\\mathrm{nbr}}(u) - y_{\\mathrm{ref}}(u))$ at all $u$, up to numerical integration errors.\n\nAlgorithmic design:\n- Define the wave profile $H(u)$ with parameters $(A,\\omega,\\sigma,u_0)$:\n$$\nH(u) = A\\,\\exp\\!\\left(-\\frac{(u-u_0)^2}{2\\,\\sigma^2}\\right)\\,\\cos\\!\\left(\\omega\\,(u-u_0)\\right),\n$$\nwith angles in radians.\n- Implement the transverse geodesic ODE system for the state vector $\\mathbf{s} = (x, v_x, y, v_y)$,\n$$\n\\frac{d}{du}\\begin{pmatrix} x \\\\ v_x \\\\ y \\\\ v_y \\end{pmatrix} =\n\\begin{pmatrix}\nv_x \\\\ H(u)\\,x \\\\ v_y \\\\ - H(u)\\,y\n\\end{pmatrix}.\n$$\n- Implement the transverse geodesic deviation ODE for $\\boldsymbol{\\xi} = (\\xi^x, \\dot{\\xi}^x, \\xi^y, \\dot{\\xi}^y)$,\n$$\n\\frac{d}{du}\\begin{pmatrix} \\xi^x \\\\ \\dot{\\xi}^x \\\\ \\xi^y \\\\ \\dot{\\xi}^y \\end{pmatrix} =\n\\begin{pmatrix}\n\\dot{\\xi}^x \\\\ H(u)\\,\\xi^x \\\\ \\dot{\\xi}^y \\\\ - H(u)\\,\\xi^y\n\\end{pmatrix}.\n$$\n- Integrate the reference geodesic, the neighboring geodesic (shifted initial positions by $(\\delta x_0,\\delta y_0)$, same initial velocities), and the deviation vector with zero initial time derivatives using a high-accuracy explicit solver over $u \\in [u_{\\mathrm{start}}, u_{\\mathrm{end}}]$.\n- At $u = u_{\\mathrm{end}}$, compute the error norm\n$$\n\\varepsilon = \\left\\| \\left( x_{\\mathrm{nbr}} - x_{\\mathrm{ref}} - \\xi^x,\\, y_{\\mathrm{nbr}} - y_{\\mathrm{ref}} - \\xi^y \\right) \\right\\|.\n$$\n- Repeat for each test case and output the list $[\\varepsilon_1,\\varepsilon_2,\\varepsilon_3,\\varepsilon_4]$ as a single line.\n\nNumerical considerations:\n- The transverse systems are linear but can exhibit parametric amplification (for $H(u)  0$ along the $x$ direction), which is numerically stable for moderate $A$ and finite support $\\sigma$.\n- Use a high-order nonstiff integrator with tight tolerances, such as the explicit $8$th order method, to ensure that the numerical error is significantly below the magnitude of the physical effect; set relative and absolute tolerances to small values to compare deviation and actual separation with high fidelity.\n- Angles must be treated in radians when evaluating the cosine.\n\nThis design ensures scientific realism and a principled derivation from the metric to the Christoffel symbols, the geodesic equations, and the geodesic deviation equations, and it defines a clear, testable numerical output.", "answer": "```python\n# Numerical integration of geodesics and geodesic deviation in a Brinkmann plane wave spacetime\n# Environment: Python 3.12, numpy 1.23.5, scipy 1.11.4\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef H_profile(u, A, omega, sigma, u0):\n    \"\"\"Plane wave profile H(u) = A * exp(-((u-u0)^2)/(2*sigma^2)) * cos(omega*(u-u0)).\n    Angles in radians.\"\"\"\n    return A * np.exp(-((u - u0) ** 2) / (2.0 * sigma ** 2)) * np.cos(omega * (u - u0))\n\ndef geodesic_rhs(u, state, A, omega, sigma, u0):\n    \"\"\"RHS for transverse geodesic equations in Brinkmann coordinates.\n    state = [x, vx, y, vy]; dots are derivatives w.r.t. u.\"\"\"\n    x, vx, y, vy = state\n    Hu = H_profile(u, A, omega, sigma, u0)\n    dxdu = vx\n    dvxdu = Hu * x\n    dydu = vy\n    dvydu = -Hu * y\n    return [dxdu, dvxdu, dydu, dvydu]\n\ndef deviation_rhs(u, xi_state, A, omega, sigma, u0):\n    \"\"\"RHS for geodesic deviation equations in transverse directions.\n    xi_state = [xi_x, dxi_x, xi_y, dxi_y].\"\"\"\n    xi_x, dxi_x, xi_y, dxi_y = xi_state\n    Hu = H_profile(u, A, omega, sigma, u0)\n    dxi_x_du = dxi_x\n    ddxi_x_du = Hu * xi_x\n    dxi_y_du = dxi_y\n    ddxi_y_du = -Hu * xi_y\n    return [dxi_x_du, ddxi_x_du, dxi_y_du, ddxi_y_du]\n\ndef integrate_case(params, u_start, u_end, x0, y0, vx0, vy0, dx0, dy0):\n    \"\"\"Integrate reference geodesic, neighbor geodesic, and deviation vector; return final error norm.\"\"\"\n    A, omega, sigma, u0 = params\n\n    # Initial states\n    ref_init = [x0, vx0, y0, vy0]\n    nbr_init = [x0 + dx0, vx0, y0 + dy0, vy0]\n    xi_init = [dx0, 0.0, dy0, 0.0]\n\n    # Integration tolerances and method\n    method = 'DOP853'\n    rtol = 1e-12\n    atol = 1e-15\n\n    # Integrate reference geodesic\n    sol_ref = solve_ivp(\n        geodesic_rhs, (u_start, u_end), ref_init,\n        args=(A, omega, sigma, u0), method=method, rtol=rtol, atol=atol\n    )\n    # Integrate neighbor geodesic\n    sol_nbr = solve_ivp(\n        geodesic_rhs, (u_start, u_end), nbr_init,\n        args=(A, omega, sigma, u0), method=method, rtol=rtol, atol=atol\n    )\n    # Integrate deviation\n    sol_xi = solve_ivp(\n        deviation_rhs, (u_start, u_end), xi_init,\n        args=(A, omega, sigma, u0), method=method, rtol=rtol, atol=atol\n    )\n\n    # Extract final values at u_end\n    x_ref, y_ref = sol_ref.y[0, -1], sol_ref.y[2, -1]\n    x_nbr, y_nbr = sol_nbr.y[0, -1], sol_nbr.y[2, -1]\n    xi_x, xi_y = sol_xi.y[0, -1], sol_xi.y[2, -1]\n\n    # Compute error norm\n    err_x = (x_nbr - x_ref) - xi_x\n    err_y = (y_nbr - y_ref) - xi_y\n    err_norm = np.sqrt(err_x * err_x + err_y * err_y)\n    return float(err_norm)\n\ndef solve():\n    # Common initial conditions\n    u_start = 0.0\n    u_end = 2.0\n    x0 = 0.1\n    y0 = 0.05\n    vx0 = 0.0\n    vy0 = 0.0\n    dx0 = 1e-4\n    dy0 = -2e-4\n\n    # Test cases: (A, omega, sigma, u0)\n    test_cases = [\n        (0.2, 6.0, 0.3, 1.0),   # Case 1: moderate amplitude, moderate frequency\n        (0.0, 6.0, 0.3, 1.0),   # Case 2: zero amplitude (boundary case)\n        (0.1, 30.0, 0.2, 1.0),  # Case 3: high frequency\n        (0.5, 10.0, 0.1, 1.0),  # Case 4: short, strong pulse\n    ]\n\n    results = []\n    for params in test_cases:\n        err = integrate_case(params, u_start, u_end, x0, y0, vx0, vy0, dx0, dy0)\n        results.append(err)\n\n    # Final output in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3492025"}, {"introduction": "Having validated the geodesic deviation equation, we now delve into its rich physical content. The heart of the equation is the Riemann curvature tensor, which acts on the separation vector as a tidal tensor, $E_{ij} = R_{i0j0}$. This practice guides you to compute the eigenvalues and eigenvectors of this tensor at a specific moment, which correspond to the principal axes and strengths of tidal stretching and compression [@problem_id:3492033]. Mastering this analysis allows you to translate the abstract components of spacetime curvature into a concrete physical picture of deformation, a crucial skill for interpreting the response of gravitational wave detectors.", "problem": "You are to design and implement a numerical method to construct Jacobi fields that are orthogonal to a given timelike four-velocity $u^\\mu$ along a timelike geodesic, and to project the resulting deviation field onto the eigendirections of the electric part of the curvature. The method must be grounded in first principles and should work for a physically plausible gravitational wave environment in General Relativity (GR). The goal is to quantify tidal stretching or compression by interpreting the eigenvalue spectrum of the electric part of the curvature tensor. All computations must be expressed in coherent units, with distances in meters and time in seconds. Angles must be specified in radians.\n\nStart from the following fundamental base:\n- The geodesic deviation equation (also known as the Jacobi equation): \n  $$\\frac{D^2 \\xi^\\mu}{D\\tau^2} = - R^\\mu{}_{\\nu\\alpha\\beta}\\,u^\\nu\\,\\xi^\\alpha\\,u^\\beta,$$\n  where $\\xi^\\mu$ is the deviation (Jacobi) field, $u^\\mu$ is the four-velocity of the fiducial timelike geodesic, $R^\\mu{}_{\\nu\\alpha\\beta}$ is the Riemann curvature tensor, and $\\tau$ is the proper time along the geodesic.\n- In the instantaneous local rest frame (Fermi normal frame) of the fiducial geodesic with $u^\\mu=(1,0,0,0)$, the spatial components $\\xi^i$ of any Jacobi field orthogonal to $u^\\mu$ satisfy\n  $$\\frac{d^2 \\xi^i}{d\\tau^2} + E^i{}_j(\\tau)\\,\\xi^j = 0,$$\n  where $E_{ij}(\\tau) = R_{i0j0}(\\tau)$ is the electric part of the Riemann tensor. In vacuum, this equals the electric part of the Weyl tensor (Weyl curvature) $C_{i0j0}$.\n- For a weak, plane, transverse-traceless gravitational wave traveling in the $z$-direction, the spatial metric perturbation $h_{ij}^{\\text{TT}}(\\tau)$ in the local rest frame may be taken as\n  $$h_{ij}^{\\text{TT}}(\\tau) = h_+(\\tau)\\left(\\hat{x}_i \\hat{x}_j - \\hat{y}_i \\hat{y}_j\\right) + h_\\times(\\tau)\\left(\\hat{x}_i \\hat{y}_j + \\hat{y}_i \\hat{x}_j\\right),$$\n  where $h_+(\\tau)$ and $h_\\times(\\tau)$ are the plus and cross polarizations, respectively. A well-tested relation between curvature and the metric perturbation in this regime is\n  $$E_{ij}(\\tau) = -\\tfrac{1}{2}\\,\\frac{d^2}{d\\tau^2} h_{ij}^{\\text{TT}}(\\tau).$$\n\nYour program must:\n- Construct $E_{ij}(\\tau)$ for a monochromatic gravitational wave with\n  $$h_+(\\tau) = A_+ \\cos(\\omega \\tau), \\quad h_\\times(\\tau) = A_\\times \\cos(\\omega \\tau + \\phi),$$\n  where $A_+$ and $A_\\times$ are dimensionless amplitudes, $\\omega$ is an angular frequency in $\\text{rad}/\\text{s}$, and $\\phi$ is a phase in radians. From the above relation, the electric part satisfies\n  $$E_{ij}(\\tau) = -\\tfrac{1}{2}\\,\\frac{d^2}{d\\tau^2} h_{ij}^{\\text{TT}}(\\tau).$$\n  Ensure $E_{ij}(\\tau)$ is constructed as a symmetric, trace-free $3\\times 3$ matrix acting on spatial vectors.\n- Numerically integrate the Jacobi equation\n  $$\\ddot{\\xi}^i(\\tau) + E^i{}_j(\\tau)\\,\\xi^j(\\tau) = 0$$\n  for spatial $\\xi^i(\\tau)$, given initial conditions $\\xi^i(0)$ in meters (orthogonal to $u^\\mu$) and $\\dot{\\xi}^i(0)$ in meters per second. Use proper time $\\tau$ in seconds. The dot denotes derivative with respect to $\\tau$.\n- At final proper time $\\tau=T$ (in seconds), compute the eigenvalue decomposition of $E_{ij}(T)$:\n  $$E_{ij}(T)\\,e^{(k)}_j = \\lambda_k\\,e^{(k)}_i,$$\n  with orthonormal eigenvectors $e^{(k)}_i$ and real eigenvalues $\\lambda_k$ (in $\\text{s}^{-2}$). Sort the eigenvalues in ascending order and sort the corresponding eigenvectors consistently with the eigenvalues.\n- Project the final deviation vector $\\xi^i(T)$ onto the eigenbasis:\n  $$p_k = e^{(k)}_i\\,\\xi^i(T),$$\n  so that $p_k$ are the components of $\\xi^i(T)$ along the eigendirections $e^{(k)}_i$. Report each $p_k$ in meters.\n- Provide an interpretable tidal signature by counting the number of negative eigenvalues:\n  $$N_{\\text{stretch}} = \\#\\{k \\mid \\lambda_k  0\\},$$\n  where negative $\\lambda_k$ indicate instantaneous tidal stretching along $e^{(k)}_i$, while positive $\\lambda_k$ indicate compression.\n\nPhysical units:\n- Report all distances in meters, times in seconds, angular frequency in $\\text{rad}/\\text{s}$, and eigenvalues in $\\text{s}^{-2}$. Angles must be provided in radians.\n- All outputs must be numeric; do not output any units text.\n\nTest suite:\nImplement your program for the following $4$ test cases. Each case is specified as a tuple $(\\omega, A_+, A_\\times, \\phi, T, \\xi^i(0), \\dot{\\xi}^i(0))$ with the above units and conventions.\n\n- Case $1$ (happy path, mixed polarizations):\n  - $\\omega = 200.0$\n  - $A_+ = 1.2\\times 10^{-21}$\n  - $A_\\times = 0.8\\times 10^{-21}$\n  - $\\phi = 0.7$\n  - $T = 0.05$\n  - $\\xi^i(0) = [1000.0,\\, 500.0,\\, 0.0]$\n  - $\\dot{\\xi}^i(0) = [0.0,\\, 0.0,\\, 0.0]$\n- Case $2$ (boundary, vanishing curvature):\n  - $\\omega = 150.0$\n  - $A_+ = 0.0$\n  - $A_\\times = 0.0$\n  - $\\phi = 0.0$\n  - $T = 0.1$\n  - $\\xi^i(0) = [0.0,\\, 2.0,\\, 3.0]$\n  - $\\dot{\\xi}^i(0) = [0.0,\\, 0.1,\\, -0.2]$\n- Case $3$ (pure plus, aligned initial separation):\n  - $\\omega = 400.0$\n  - $A_+ = 2.0\\times 10^{-21}$\n  - $A_\\times = 0.0$\n  - $\\phi = 0.0$\n  - $T = 0.02$\n  - $\\xi^i(0) = [1.0,\\, 0.0,\\, 0.0]$\n  - $\\dot{\\xi}^i(0) = [0.0,\\, 0.0,\\, 0.0]$\n- Case $4$ (pure cross, rotated eigendirections):\n  - $\\omega = 300.0$\n  - $A_+ = 0.0$\n  - $A_\\times = 1.0\\times 10^{-21}$\n  - $\\phi = \\pi/3$\n  - $T = 0.03$\n  - $\\xi^i(0) = [0.0,\\, 1.0,\\, 0.0]$\n  - $\\dot{\\xi}^i(0) = [0.0,\\, 0.0,\\, 0.0]$\n\nRequired outputs for each test case:\n- A list containing the $3$ sorted eigenvalues $\\lambda_k(T)$ in $\\text{s}^{-2}$, the $3$ projections $p_k$ in meters, and the integer $N_{\\text{stretch}}$:\n  $$[\\lambda_1,\\,\\lambda_2,\\,\\lambda_3,\\,p_1,\\,p_2,\\,p_3,\\,N_{\\text{stretch}}].$$\n\nFinal output format:\n- Your program should produce a single line of output containing the results for all $4$ test cases as a comma-separated Python-style list of lists, for example:\n  $$\\texttt{[[\\lambda_1,\\lambda_2,\\lambda_3,p_1,p_2,p_3,N],[...],[...],[...]]}.$$\n- Do not print any additional text.\n\nYour program must be self-contained and must not require any input. It must use a robust numerical integrator. The results must be reproducible with standard double-precision floating-point arithmetic. Ensure that the Jacobi field is kept orthogonal to $u^\\mu$ by evolving only spatial components $\\xi^i(\\tau)$ with initial data orthogonal to $u^\\mu$ (i.e., $\\xi^0 = 0$). The numerical construction should reflect the physics: the eigenvalue spectrum encodes instantaneous tidal compression (positive eigenvalues) and stretching (negative eigenvalues).", "solution": "The problem requires the numerical solution of the geodesic deviation equation for a test mass in the presence of a weak, plane, monochromatic gravitational wave. The goal is to determine the final deviation vector and project it onto the eigendirections of the instantaneous tidal field, characterized by the electric part of the Riemann tensor.\n\n### Principle-Based Design\n\nThe solution is grounded in the principles of General Relativity, specifically the description of tidal forces through the geodesic deviation equation.\n\n1.  **Defining the Tidal Field ($E_{ij}$):**\n    For a weak, plane gravitational wave propagating in the $z$-direction, the metric perturbation in the transverse-traceless (TT) gauge is given by $h_{ij}^{\\text{TT}}(\\tau)$. The problem specifies monochromatic waves, where the non-zero components of the perturbation tensor are:\n    $$h_{11}^{\\text{TT}}(\\tau) = -h_{22}^{\\text{TT}}(\\tau) = h_+(\\tau) = A_+ \\cos(\\omega \\tau)$$\n    $$h_{12}^{\\text{TT}}(\\tau) = h_{21}^{\\text{TT}}(\\tau) = h_\\times(\\tau) = A_\\times \\cos(\\omega \\tau + \\phi)$$\n    The components $h_{i3}^{\\text{TT}}$ and $h_{3i}^{\\text{TT}}$ are zero. In matrix form:\n    $$h_{ij}^{\\text{TT}}(\\tau) = \\begin{pmatrix} A_+ \\cos(\\omega \\tau)  A_\\times \\cos(\\omega \\tau + \\phi)  0 \\\\ A_\\times \\cos(\\omega \\tau + \\phi)  -A_+ \\cos(\\omega \\tau)  0 \\\\ 0  0  0 \\end{pmatrix}$$\n    The electric part of the Riemann tensor, $E_{ij}(\\tau)$, which describes the tidal forces in the local rest frame of an observer on a timelike geodesic, is related to the second time derivative of the metric perturbation:\n    $$E_{ij}(\\tau) = -\\frac{1}{2} \\frac{d^2}{d\\tau^2} h_{ij}^{\\text{TT}}(\\tau)$$\n    Taking the second derivative of $h_{ij}^{\\text{TT}}(\\tau)$ with respect to proper time $\\tau$, we find:\n    $$\\frac{d^2}{d\\tau^2} h_+(\\tau) = -A_+ \\omega^2 \\cos(\\omega \\tau)$$\n    $$\\frac{d^2}{d\\tau^2} h_\\times(\\tau) = -A_\\times \\omega^2 \\cos(\\omega \\tau + \\phi)$$\n    Substituting these into the expression for $E_{ij}(\\tau)$, we obtain the explicit form of the tidal tensor:\n    $$E_{ij}(\\tau) = \\frac{\\omega^2}{2} \\begin{pmatrix} A_+ \\cos(\\omega \\tau)  A_\\times \\cos(\\omega \\tau + \\phi)  0 \\\\ A_\\times \\cos(\\omega \\tau + \\phi)  -A_+ \\cos(\\omega \\tau)  0 \\\\ 0  0  0 \\end{pmatrix}$$\n    This $3 \\times 3$ matrix is symmetric ($E_{ij}=E_{ji}$) and trace-free ($\\text{Tr}(E) = E_{11} + E_{22} + E_{33} = 0$), consistent with the properties of tidal forces from gravitational waves in vacuum. Its units are $\\text{s}^{-2}$.\n\n2.  **Numerical Integration of the Geodesic Deviation Equation:**\n    In the observer's local rest frame, where $u^\\mu = (1,0,0,0)$, the geodesic deviation equation for the spatial separation vector $\\xi^i(\\tau)$ simplifies to:\n    $$\\frac{d^2 \\xi^i}{d\\tau^2} + E^i{}_j(\\tau)\\,\\xi^j(\\tau) = 0$$\n    Since we are in a local orthonormal frame, we can use the Euclidean metric to raise and lower spatial indices, so $E^i{}_j(\\tau) = E_{ij}(\\tau)$. The equation becomes a system of three coupled second-order linear ordinary differential equations (ODEs):\n    $$\\ddot{\\vec{\\xi}}(\\tau) = -E(\\tau) \\vec{\\xi}(\\tau)$$\n    where $\\vec{\\xi}$ is the column vector $(\\xi^1, \\xi^2, \\xi^3)^T$, $\\ddot{\\vec{\\xi}}$ is its second derivative with respect to $\\tau$, and $E(\\tau)$ is the matrix $E_{ij}(\\tau)$.\n    To solve this numerically, we convert the system into a set of six first-order ODEs. We define a $6$-dimensional state vector $Y(\\tau)$:\n    $$Y(\\tau) = \\begin{pmatrix} \\vec{\\xi}(\\tau) \\\\ \\dot{\\vec{\\xi}}(\\tau) \\end{pmatrix} = \\begin{pmatrix} \\xi^1 \\\\ \\xi^2 \\\\ \\xi^3 \\\\ \\dot{\\xi}^1 \\\\ \\dot{\\xi}^2 \\\\ \\dot{\\xi}^3 \\end{pmatrix}$$\n    The first-order system is then:\n    $$\\frac{dY}{d\\tau} = \\begin{pmatrix} \\dot{\\vec{\\xi}}(\\tau) \\\\ \\ddot{\\vec{\\xi}}(\\tau) \\end{pmatrix} = \\begin{pmatrix} \\dot{\\vec{\\xi}}(\\tau) \\\\ -E(\\tau) \\vec{\\xi}(\\tau) \\end{pmatrix} = \\begin{pmatrix} 0  I \\\\ -E(\\tau)  0 \\end{pmatrix} Y(\\tau)$$\n    where $I$ is the $3 \\times 3$ identity matrix. This system can be integrated from $\\tau=0$ to $\\tau=T$ using a standard numerical ODE solver, such as a Runge-Kutta method. The integration requires initial conditions for both the deviation vector $\\vec{\\xi}(0)$ and its velocity $\\dot{\\vec{\\xi}}(0)$. The `scipy.integrate.solve_ivp` function is well-suited for this task.\n\n3.  **Physical Interpretation via Eigenvalue Decomposition:**\n    At the final time $\\tau=T$, the tidal tensor $E_{ij}(T)$ represents the instantaneous tidal forces. The physical nature of these forces is revealed by its eigenvalue decomposition:\n    $$E_{ij}(T) e^{(k)}_j = \\lambda_k e^{(k)}_i$$\n    The three real eigenvalues $\\lambda_k$ (in $\\text{s}^{-2}$) and their corresponding orthonormal eigenvectors $\\vec{e}^{(k)}$ define the principal axes of the tidal field.\n    - If $\\lambda_k  0$, the tidal acceleration $\\ddot{\\xi}^i$ has a component opposite to $\\xi^i$ along the direction $\\vec{e}^{(k)}$, indicating **compression**.\n    - If $\\lambda_k  0$, the tidal acceleration has a component along $\\xi^i$ in the direction $\\vec{e}^{(k)}$, indicating **stretching**.\n    - If $\\lambda_k = 0$, there is no tidal force along that principal axis.\n    The number of negative eigenvalues, $N_{\\text{stretch}}$, provides a direct count of the instantaneous stretching directions. We use `numpy.linalg.eigh` for the eigenvalue decomposition, which is optimized for symmetric matrices and returns sorted real eigenvalues and their corresponding orthonormal eigenvectors.\n\n4.  **Projection onto Eigendirections:**\n    To quantify how the final deviation vector $\\vec{\\xi}(T)$ aligns with the principal axes of the tidal field at that moment, we project $\\vec{\\xi}(T)$ onto the orthonormal eigenbasis $\\{\\vec{e}^{(k)}\\}$:\n    $$p_k = \\vec{e}^{(k)} \\cdot \\vec{\\xi}(T) = e^{(k)}_i \\xi^i(T)$$\n    The resulting scalars $p_k$ (in meters) are the components of the final deviation vector along each principal axis.\n\n### Implementation Summary\nThe program iterates through each test case. For each case:\n1.  It defines a function for the matrix $E_{ij}(\\tau)$ based on the given gravitational wave parameters.\n2.  It sets up the first-order ODE system for the $6$-dimensional state vector $Y(\\tau)$.\n3.  It uses `scipy.integrate.solve_ivp` to integrate the system from $\\tau=0$ to $\\tau=T$ with the provided initial conditions $\\vec{\\xi}(0)$ and $\\dot{\\vec{\\xi}}(0)$. A special case for zero-amplitude waves is handled analytically to prevent unnecessary numerical computation.\n4.  At $\\tau=T$, it computes the matrix $E_{ij}(T)$ and performs an eigenvalue decomposition to find the sorted eigenvalues $\\lambda_k$ and eigenvectors $\\vec{e}^{(k)}$.\n5.  It calculates the projections $p_k$ of the final deviation vector $\\vec{\\xi}(T)$ onto the eigenvectors.\n6.  It counts the number of negative eigenvalues, $N_{\\text{stretch}}$.\n7.  The results $[\\lambda_1, \\lambda_2, \\lambda_3, p_1, p_2, p_3, N_{\\text{stretch}}]$ for each case are collected and printed in the specified list-of-lists format.\nAll units are handled as specified: time in seconds ($s$), distance in meters ($m$), and frequency in radians per second ($\\text{rad/s}$).", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Solves the geodesic deviation problem for given gravitational wave parameters.\n    \"\"\"\n    \n    # Test cases: (omega, A_plus, A_cross, phi, T, xi0, xi_dot0)\n    test_cases = [\n        # Case 1\n        (200.0, 1.2e-21, 0.8e-21, 0.7, 0.05, [1000.0, 500.0, 0.0], [0.0, 0.0, 0.0]),\n        # Case 2\n        (150.0, 0.0, 0.0, 0.0, 0.1, [0.0, 2.0, 3.0], [0.0, 0.1, -0.2]),\n        # Case 3\n        (400.0, 2.0e-21, 0.0, 0.0, 0.02, [1.0, 0.0, 0.0], [0.0, 0.0, 0.0]),\n        # Case 4\n        (300.0, 0.0, 1.0e-21, np.pi/3, 0.03, [0.0, 1.0, 0.0], [0.0, 0.0, 0.0])\n    ]\n\n    results = []\n\n    for case in test_cases:\n        omega, A_plus, A_cross, phi, T, xi0_list, xi_dot0_list = case\n        \n        xi0 = np.array(xi0_list, dtype=np.float64)\n        xi_dot0 = np.array(xi_dot0_list, dtype=np.float64)\n\n        def get_E(tau, w, Ap, Ac, p):\n            \"\"\"Computes the electric part of the Riemann tensor E_ij.\"\"\"\n            cos_plus = np.cos(w * tau)\n            cos_cross = np.cos(w * tau + p)\n            \n            c1 = Ap * cos_plus\n            c2 = Ac * cos_cross\n            \n            E = (w**2 / 2.0) * np.array([\n                [c1, c2, 0.0],\n                [c2, -c1, 0.0],\n                [0.0, 0.0, 0.0]\n            ], dtype=np.float64)\n            return E\n\n        # Handle the trivial case (no gravitational wave) analytically\n        if A_plus == 0.0 and A_cross == 0.0:\n            # E_ij is always zero, so d^2(xi)/dtau^2 = 0\n            # xi(T) = xi(0) + xi_dot(0) * T\n            xi_T = xi0 + xi_dot0 * T\n            E_T = np.zeros((3, 3), dtype=np.float64)\n        else:\n            def ode_system(tau, y):\n                \"\"\"Defines the 6D first-order ODE system for geodesic deviation.\"\"\"\n                # y = [xi_x, xi_y, xi_z, v_x, v_y, v_z]\n                xi = y[0:3]\n                d_xi_dt = y[3:6]\n                \n                E_matrix = get_E(tau, omega, A_plus, A_cross, phi)\n                d_v_dt = -E_matrix @ xi\n                \n                return np.concatenate((d_xi_dt, d_v_dt))\n\n            # Set up initial conditions for the 6D state vector\n            y0 = np.concatenate((xi0, xi_dot0))\n\n            # Numerically integrate the ODE system\n            sol = solve_ivp(\n                ode_system,\n                [0, T],\n                y0,\n                t_eval=[T],\n                method='RK45', \n                rtol=1e-12,\n                atol=1e-12\n            )\n            \n            # Extract final state\n            y_final = sol.y[:, -1]\n            xi_T = y_final[0:3]\n            \n            # Compute E_ij at the final time T\n            E_T = get_E(T, omega, A_plus, A_cross, phi)\n\n        # Eigenvalue decomposition of E_ij(T)\n        # np.linalg.eigh returns eigenvalues in ascending order for symmetric matrices\n        lambdas, e_vecs = np.linalg.eigh(E_T)\n\n        # Project final deviation vector xi(T) onto the eigenbasis\n        # e_vecs are columns, so e_vecs.T @ xi_T gives the projections\n        projections = e_vecs.T @ xi_T\n        \n        # Count the number of negative eigenvalues (stretching directions)\n        n_stretch = np.sum(lambdas  0)\n\n        # Assemble results for the current case\n        case_result = lambdas.tolist() + projections.tolist() + [int(n_stretch)]\n        results.append(case_result)\n\n    # Format output as a Python-style list of lists string\n    output_str_parts = []\n    for res_list in results:\n        list_str = \"[\" + \",\".join(map(str, res_list)) + \"]\"\n        output_str_parts.append(list_str)\n        \n    final_output = \"[\" + \",\".join(output_str_parts) + \"]\"\n    print(final_output)\n\nsolve()\n```", "id": "3492033"}, {"introduction": "To fully appreciate relativistic tidal effects, it is instructive to compare them with their Newtonian counterparts. This exercise situates the geodesic deviation concept within the broader framework of gravitational theories by testing the correspondence principle. You will implement both the General Relativistic tidal evolution driven by the electric part of the Weyl tensor, $E_{ij}$, and the Newtonian evolution driven by the Hessian of the gravitational potential, $\\partial_i \\partial_j \\Phi$ [@problem_id:3492002]. This comparison will allow you to quantify the agreement in static, weak fields and, more importantly, to witness the breakdown of the Newtonian model in the presence of gravitational waves, a purely relativistic phenomenon.", "problem": "You are asked to design and implement a program that, in the weak-field regime relevant to Numerical Relativity (NR), compares separation evolution predicted by the geodesic deviation equation driven by the electric part of the Weyl tensor and by the Newtonian tidal approximation driven by the Hessian of a scalar gravitational potential. The comparison must be quantified by norms of the tidal matrix $E_{ij}(t)$ and by deviations in predicted separations $\\xi^i(t)$ over time. Your program must produce results for a small test suite of physically coherent scenarios and aggregate them into a single specified output format.\n\nBegin from the following base definitions and laws:\n\n- The geodesic deviation equation for a congruence of timelike geodesics with tangent $u^\\mu$ and separation vector $\\xi^\\mu$ is\n$$\n\\frac{D^2 \\xi^\\mu}{d\\tau^2} = - R^\\mu{}_{\\alpha\\beta\\gamma}\\,u^\\alpha\\,\\xi^\\beta\\,u^\\gamma,\n$$\nwhere $R^\\mu{}_{\\alpha\\beta\\gamma}$ is the Riemann curvature tensor and $\\tau$ is the proper time. In a local orthonormal frame adapted to static observers where $u^\\mu = (1,0,0,0)$ and $\\tau$ coincides with coordinate time $t$ to leading order in the weak-field approximation, the spatial components satisfy\n$$\n\\frac{d^2 \\xi^i}{dt^2} = - E^i{}_{\\,j}(t)\\,\\xi^j,\n$$\nwith $E_{ij}(t) = R_{i0j0}(t)$ the electric part of the Weyl tensor.\n\n- In Newtonian gravity, a scalar gravitational potential $\\Phi(\\mathbf{x}, t)$ determines tidal accelerations via its spatial Hessian,\n$$\n\\frac{d^2 \\xi^i}{dt^2} = - \\partial_i \\partial_j \\Phi(\\mathbf{x}, t)\\,\\xi^j,\n$$\nevaluated along the reference worldline. In a static, spherically symmetric weak-field configuration sourced by a point mass $M$ at radius $r$, the local tidal matrix equals\n$$\nT_{ij} = \\partial_i \\partial_j \\Phi = \\mathrm{diag}\\!\\left( \\frac{2GM}{r^3}, -\\frac{GM}{r^3}, -\\frac{GM}{r^3} \\right),\n$$\nin an orthonormal triad where the $x$-axis is radial. Here $G$ is Newtonâ€™s gravitational constant.\n\n- For a plane, linearly polarized gravitational wave in the Transverse-Traceless (TT) gauge propagating along the $z$-direction with plus polarization strain $h_+(t) = h_0 \\cos(\\omega t)$, the nonzero components of the electric part are\n$$\nE_{xx}(t) = -\\frac{1}{2}\\ddot{h}_+(t) = \\frac{1}{2} h_0 \\omega^2 \\cos(\\omega t),\\quad E_{yy}(t) = -E_{xx}(t),\\quad E_{zz}(t)=0,\n$$\nand all off-diagonal components vanish to leading order.\n\nYour program must:\n\n1. Implement the general system\n$$\n\\frac{d}{dt}\\begin{pmatrix} \\xi^i \\\\ v^i \\end{pmatrix} =\n\\begin{pmatrix}\nv^i \\\\\n- E^i{}_{\\,j}(t)\\,\\xi^j\n\\end{pmatrix},\n$$\nfor the General Relativity (GR) prediction with $v^i = d\\xi^i/dt$, and the analogous Newtonian prediction using $T_{ij}(t) = \\partial_i \\partial_j \\Phi(\\mathbf{x}, t)$ in place of $E_{ij}(t)$.\n\n2. For each scenario in the test suite, integrate both systems over a specified time interval with the same initial conditions. Use Scientific International System of Units (SI units): positions in meters (m), time in seconds (s), mass in kilograms (kg), and angular frequency in radians per second (rad/s). Angles and angular frequencies must be treated in radians.\n\n3. Quantify the comparison by computing:\n   - The supremum over time of the Frobenius norm of the GR tidal matrix,\n     $$\n     \\|E(t)\\|_F = \\sqrt{\\sum_{i,j} E_{ij}^2(t)},\\qquad \\|E\\|_{F,\\max} = \\sup_{t \\in [0,T]} \\|E(t)\\|_F.\n     $$\n   - The final-time relative deviation,\n     $$\n     \\delta_{\\mathrm{final}} = \\frac{\\|\\xi_{\\mathrm{GR}}(T) - \\xi_{\\mathrm{Newt}}(T)\\|_2}{\\max\\big(\\|\\xi_{\\mathrm{GR}}(T)\\|_2,\\,\\epsilon_{\\mathrm{floor}}\\big)},\n     $$\n     where $\\|\\cdot\\|_2$ is the Euclidean norm, $T$ is the final time, and $\\epsilon_{\\mathrm{floor}}$ is a small positive number to prevent division by zero.\n   - The breakdown time $t_{\\mathrm{break}}$, defined as the earliest $t \\in [0,T]$ such that\n     $$\n     \\|\\xi_{\\mathrm{GR}}(t) - \\xi_{\\mathrm{Newt}}(t)\\|_2 \\ge \\varepsilon\\,\\|\\xi_{\\mathrm{GR}}(t)\\|_2,\n     $$\n     with a dimensionless tolerance $\\varepsilon$ specified below. If this condition is never met, report $t_{\\mathrm{break}}$ as $-1.0$.\n\n4. Produce, for each test case, a result list containing $[\\|E\\|_{F,\\max},\\,\\delta_{\\mathrm{final}},\\,t_{\\mathrm{break}}]$ in SI units where applicable, and aggregate the per-case lists into a single line of output as a comma-separated list enclosed in square brackets.\n\nUse the following test suite, designed to probe different aspects including agreement in static weak fields, breakdown in wave-dominated vacuum, and edge cases:\n\n- Case A (static point mass, happy path): A weak-field region outside a point mass with $M = 5.0\\times 10^{30}$ kg at a fixed radius $r = 2.0\\times 10^{8}$ m. Take the local orthonormal frame with radial direction along the $x$-axis so that\n$$\nE_{ij} = \\mathrm{diag}\\!\\left( \\frac{2GM}{r^3}, -\\frac{GM}{r^3}, -\\frac{GM}{r^3} \\right),\\quad T_{ij} = E_{ij}.\n$$\nIntegrate over $T = 1.0$ s from the initial separation $\\xi(0) = (1.0,\\,0.5,\\,0.0)$ m with initial relative velocity $v(0) = (0.0,\\,0.0,\\,0.0)$ m/s.\n\n- Case B (plane gravitational wave plus polarization, breakdown in vacuum): A monochromatic plane gravitational wave with plus polarization amplitude $h_0 = 1.0\\times 10^{-18}$ and angular frequency $\\omega = 6.28\\times 10^{2}$ rad/s, so that\n$$\nE_{xx}(t)=\\tfrac{1}{2} h_0 \\omega^2 \\cos(\\omega t),\\quad E_{yy}(t)=-E_{xx}(t),\\quad E_{zz}(t)=0.\n$$\nThere is no Newtonian matter source in the local vacuum, so take $\\Phi = 0$ and $T_{ij}(t) = 0$. Integrate over $T = 1.0\\times 10^{3}$ s from $\\xi(0) = (1.0,\\,0.0,\\,0.0)$ m with $v(0) = (0.0,\\,0.0,\\,0.0)$ m/s.\n\n- Case C (gravitational wave, aligned separation, edge case): Same $h_0$ and $\\omega$ as Case B, but with initial separation aligned with the propagation direction where $E_{zz}(t) = 0$, namely $\\xi(0) = (0.0,\\,0.0,\\,1.0)$ m and $v(0) = (0.0,\\,0.0,\\,0.0)$ m/s. Integrate over $T = 1.0\\times 10^{3}$ s with $T_{ij}(t)=0$.\n\n- Case D (null field, boundary condition): No curvature and no Newtonian tidal field, $E_{ij}(t)=0$ and $T_{ij}(t)=0$ for all $t$. Integrate over $T = 1.0\\times 10^{1}$ s from $\\xi(0) = (1.0,\\,1.0,\\,1.0)$ m and $v(0) = (0.0,\\,0.0,\\,0.0)$ m/s.\n\nUse the constants $G = 6.674\\times 10^{-11}$ m$^3$ kg$^{-1}$ s$^{-2}$ and set the breakdown tolerance to $\\varepsilon = 1.0\\times 10^{-6}$. Choose a small floor $\\epsilon_{\\mathrm{floor}} = 1.0\\times 10^{-15}$ m for the denominator in $\\delta_{\\mathrm{final}}$.\n\nYour program should produce a single line of output containing the per-case results as a comma-separated list of three-element lists, enclosed in square brackets, for example, $[[a,b,c],[d,e,f],\\dots]$, where each element $a,b,c,\\dots$ is a floating-point number in SI units as applicable.", "solution": "The problem requires a comparison between the evolution of the separation vector $\\xi^i(t)$ between two nearby geodesics as predicted by two different physical theories: General Relativity (GR) in the weak-field limit and Newtonian gravity. The comparison is to be performed numerically for a suite of four distinct physical scenarios.\n\nThe fundamental principle is the numerical integration of systems of second-order ordinary differential equations (ODEs). For both theories, the governing equation is of the form:\n$$\n\\frac{d^2 \\xi^i}{dt^2} = - K^i{}_{\\,j}(t)\\,\\xi^j\n$$\nwhere $K_{ij}(t)$ is a $3 \\times 3$ time-dependent tidal matrix. For the GR prediction, this matrix is the electric part of the Weyl tensor, $K_{ij}(t) = E_{ij}(t) = R_{i0j0}(t)$. For the Newtonian prediction, it is the Hessian of the gravitational potential, $K_{ij}(t) = T_{ij}(t) = \\partial_i\\partial_j\\Phi$.\n\nTo solve this system numerically, we first convert the second-order ODE into a system of first-order ODEs. We define a state vector $y(t)$ composed of the separation vector $\\xi^i(t)$ and its first time derivative, the relative velocity $v^i(t) = d\\xi^i/dt$. For a three-dimensional spatial problem, the state vector is a six-component vector:\n$$\ny(t) = \\begin{pmatrix} \\xi^1(t) \\\\ \\xi^2(t) \\\\ \\xi^3(t) \\\\ v^1(t) \\\\ v^2(t) \\\\ v^3(t) \\end{pmatrix}\n$$\nThe first-order system is then given by:\n$$\n\\frac{d}{dt}y(t) = \\frac{d}{dt}\\begin{pmatrix} \\xi^i \\\\ v^i \\end{pmatrix} = \\begin{pmatrix} v^i \\\\ -K^i{}_{\\,j}(t)\\,\\xi^j \\end{pmatrix} = F(t, y(t))\n$$\nThis system can be integrated from a set of initial conditions $y(0) = (\\xi^i(0), v^i(0))^T$ over a time interval $[0, T]$ using a standard numerical ODE solver. The implementation will use the `solve_ivp` function from the `scipy.integrate` library, which provides robust and adaptive algorithms for solving initial value problems. For each of the four test cases, we will define the specific forms of the matrices $E_{ij}(t)$ and $T_{ij}(t)$, the initial conditions $\\xi(0)$ and $v(0)$, and the total integration time $T$. Two separate integrations will be performed for each case: one for the GR prediction using $E_{ij}(t)$ and one for the Newtonian prediction using $T_{ij}(t)$.\n\nThe four cases are designed to test the correspondence and divergence of the two theories:\n- **Case A (Static point mass):** Here, $E_{ij}$ and $T_{ij}$ are identical constant matrices, representing the weak-field limit where GR reduces to Newtonian gravity for tidal forces. We expect the solutions $\\xi_{\\mathrm{GR}}(t)$ and $\\xi_{\\mathrm{Newt}}(t)$ to be identical within numerical precision.\n$E_{ij} = T_{ij} = \\mathrm{diag}(2GM/r^3, -GM/r^3, -GM/r^3)$ with $G = 6.674\\times 10^{-11}$ m$^3$ kg$^{-1}$ s$^{-2}$, $M = 5.0\\times 10^{30}$ kg, and $r = 2.0\\times 10^{8}$ m.\n\n- **Case B (Plane gravitational wave):** This scenario models a pure GR effect with no Newtonian analogue. $E_{ij}(t)$ is time-dependent, describing the tidal forces of a plus-polarized gravitational wave, while $T_{ij}(t)=0$. We expect the solutions to diverge.\n$E_{xx}(t) = -E_{yy}(t) = \\frac{1}{2} h_0 \\omega^2 \\cos(\\omega t)$ with $h_0 = 1.0\\times 10^{-18}$ and $\\omega = 6.28\\times 10^{2}$ rad/s.\n\n- **Case C (Gravitational wave, aligned separation):** This is an edge case where the initial separation vector is aligned with the propagation direction of the gravitational wave. Since gravitational waves are transverse, no tidal force should be experienced, and we expect $\\xi_{\\mathrm{GR}}(t)$ and $\\xi_{\\mathrm{Newt}}(t)$ to agree.\n\n- **Case D (Null field):** A trivial case where $E_{ij}=0$ and $T_{ij}=0$, serving as a sanity check for the integrator. Both theories predict no acceleration, so the separation vector should evolve according to its initial velocity.\n\nAfter obtaining the numerical solutions $\\xi_{\\mathrm{GR}}(t)$ and $\\xi_{\\mathrm{Newt}}(t)$ for each case, we will compute three specified metrics. To accurately compute quantities that depend on the continuous time evolution, such as the supremum norm and the breakdown time, we will leverage the `dense_output=True` feature of `solve_ivp`. This provides an interpolated solution that can be evaluated at any point within the integration interval. A fine grid of time points will be used for these evaluations.\n\n1.  **Maximum Frobenius norm $\\|E\\|_{F,\\max}$**: The Frobenius norm of the matrix $E(t)$ is calculated at each point on the time grid. The maximum of these values is taken as the result.\n    $$\n    \\|E(t)\\|_F = \\sqrt{\\sum_{i,j=1}^3 E_{ij}(t)^2} \\qquad \\|E\\|_{F,\\max} = \\sup_{t \\in [0,T]} \\|E(t)\\|_F\n    $$\n2.  **Final-time relative deviation $\\delta_{\\mathrm{final}}$**: This metric quantifies the cumulative difference between the two predictions at the end of the integration time $T$. It is calculated using the final state vectors $\\xi_{\\mathrm{GR}}(T)$ and $\\xi_{\\mathrm{Newt}}(T)$. A floor value $\\epsilon_{\\mathrm{floor}} = 1.0\\times 10^{-15}$ m prevents division by a near-zero norm.\n    $$\n    \\delta_{\\mathrm{final}} = \\frac{\\|\\xi_{\\mathrm{GR}}(T) - \\xi_{\\mathrm{Newt}}(T)\\|_2}{\\max\\big(\\|\\xi_{\\mathrm{GR}}(T)\\|_2, \\epsilon_{\\mathrm{floor}}\\big)}\n    $$\n3.  **Breakdown time $t_{\\mathrm{break}}$**: This is the first time $t$ at which the instantaneous relative difference between the two separation vectors exceeds a given tolerance $\\varepsilon = 1.0\\times 10^{-6}$. We check the condition at each point on our evaluation time grid. If the condition is never met, $t_{\\mathrm{break}}$ is reported as $-1.0$.\n    $$\n    \\|\\xi_{\\mathrm{GR}}(t) - \\xi_{\\mathrm{Newt}}(t)\\|_2 \\ge \\varepsilon\\,\\|\\xi_{\\mathrm{GR}}(t)\\|_2\n    $$\n\nThe final implementation will systematically process each case, compute these three metrics, and format the results into a single list of lists as specified.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\n# Global constants as defined in the problem\nG_CONST = 6.674e-11  # m^3 kg^-1 s^-2\nEPSILON_BREAKDOWN = 1.0e-6\nEPSILON_FLOOR = 1.0e-15\n\ndef ode_system(t, y, K_func):\n    \"\"\"\n    Defines the first-order ODE system dy/dt = F(t, y).\n    y is a 6-element state vector [xi_x, xi_y, xi_z, v_x, v_y, v_z].\n    K_func(t) returns the 3x3 tidal matrix K_ij at time t.\n    \"\"\"\n    xi = y[:3]\n    v = y[3:]\n    K_matrix = K_func(t)\n    acceleration = -K_matrix @ xi\n    return np.concatenate((v, acceleration))\n\ndef solve_case(E_func, T_func, xi0, v0, T_final):\n    \"\"\"\n    Solves a single test case for both GR and Newtonian models and computes metrics.\n    \"\"\"\n    y0 = np.concatenate((xi0, v0))\n    t_span = (0, T_final)\n    \n    # Use a sufficient number of points for accurate post-processing.\n    # The number of oscillations in case B/C is T*omega/(2pi) ~ 1e3 * 628 / 6.28 = 1e5\n    # A grid with ~20 points per oscillation is good, so ~2e6 points.\n    # However, to keep computation time reasonable, we use a slightly coarser grid.\n    # Dense output from solve_ivp ensures accuracy between grid points.\n    num_eval_points = 20001 \n    t_eval = np.linspace(0, T_final, num_eval_points)\n\n    # High-precision solver settings\n    solver_args = {'dense_output': True, 'method': 'RK45', 'atol': 1e-12, 'rtol': 1e-9}\n\n    # Solve for General Relativity\n    sol_gr = solve_ivp(lambda t, y: ode_system(t, y, E_func), t_span, y0, **solver_args)\n    y_gr = sol_gr.sol(t_eval)\n    xi_gr = y_gr[:3, :]\n\n    # Solve for Newtonian gravity\n    sol_newt = solve_ivp(lambda t, y: ode_system(t, y, T_func), t_span, y0, **solver_args)\n    y_newt = sol_newt.sol(t_eval)\n    xi_newt = y_newt[:3, :]\n\n    # --- Metric 1: Maximum Frobenius norm of E(t) ---\n    E_values = np.array([E_func(t) for t in t_eval])\n    frobenius_norms = np.linalg.norm(E_values, ord='fro', axis=(1, 2))\n    E_F_max = np.max(frobenius_norms) if frobenius_norms.size > 0 else 0.0\n\n    # --- Metric 2: Final-time relative deviation ---\n    xi_gr_final = xi_gr[:, -1]\n    xi_newt_final = xi_newt[:, -1]\n    numerator = np.linalg.norm(xi_gr_final - xi_newt_final)\n    denominator = max(np.linalg.norm(xi_gr_final), EPSILON_FLOOR)\n    delta_final = numerator / denominator\n\n    # --- Metric 3: Breakdown time ---\n    diff_norm = np.linalg.norm(xi_gr - xi_newt, axis=0)\n    xi_gr_norm = np.linalg.norm(xi_gr, axis=0)\n    # Avoid division by zero, though not expected in these cases\n    # xi_gr_norm is positive for all test cases.\n    breakdown_condition = diff_norm >= EPSILON_BREAKDOWN * xi_gr_norm\n    breakdown_indices = np.where(breakdown_condition)[0]\n    \n    t_break = t_eval[breakdown_indices[0]] if breakdown_indices.size > 0 else -1.0\n    \n    return [E_F_max, delta_final, t_break]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    \n    # Case A: Static point mass\n    M_A = 5.0e30\n    r_A = 2.0e8\n    c1_A = (2 * G_CONST * M_A) / (r_A**3)\n    c2_A = (-G_CONST * M_A) / (r_A**3)\n    K_A = np.diag([c1_A, c2_A, c2_A])\n    case_A = {\n        'E_func': lambda t: K_A,\n        'T_func': lambda t: K_A,\n        'xi0': np.array([1.0, 0.5, 0.0]),\n        'v0': np.array([0.0, 0.0, 0.0]),\n        'T_final': 1.0\n    }\n\n    # Case B: Plane gravitational wave\n    h0_B = 1.0e-18\n    omega_B = 6.28e2\n    A_B = 0.5 * h0_B * omega_B**2\n    def E_func_B(t):\n        val = A_B * np.cos(omega_B * t)\n        return np.array([[val, 0, 0], [0, -val, 0], [0, 0, 0]])\n    \n    T_func_zero = lambda t: np.zeros((3, 3))\n    \n    case_B = {\n        'E_func': E_func_B,\n        'T_func': T_func_zero,\n        'xi0': np.array([1.0, 0.0, 0.0]),\n        'v0': np.array([0.0, 0.0, 0.0]),\n        'T_final': 1.0e3\n    }\n    \n    # Case C: Gravitational wave, aligned separation\n    case_C = {\n        'E_func': E_func_B, # Same wave as B\n        'T_func': T_func_zero,\n        'xi0': np.array([0.0, 0.0, 1.0]),\n        'v0': np.array([0.0, 0.0, 0.0]),\n        'T_final': 1.0e3\n    }\n\n    # Case D: Null field\n    case_D = {\n        'E_func': T_func_zero,\n        'T_func': T_func_zero,\n        'xi0': np.array([1.0, 1.0, 1.0]),\n        'v0': np.array([0.0, 0.0, 0.0]),\n        'T_final': 1.0e1\n    }\n    \n    test_cases = [case_A, case_B, case_C, case_D]\n    \n    results = []\n    for case_params in test_cases:\n        result = solve_case(**case_params)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The default str() for a list includes spaces, which we remove for a compact representation.\n    # The problem example `print` suggests spaces might be ok, but we follow the format `[[a,b,c],[d,e,f]]` more strictly.\n    formatted_results = ','.join([str(res).replace(' ', '') for res in results])\n    print(f\"[{formatted_results}]\")\n\nsolve()\n\n```", "id": "3492002"}]}