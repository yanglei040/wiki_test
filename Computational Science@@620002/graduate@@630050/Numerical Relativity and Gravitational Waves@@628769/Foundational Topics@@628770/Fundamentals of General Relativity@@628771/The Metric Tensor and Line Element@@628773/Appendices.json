{"hands_on_practices": [{"introduction": "Before we can use the metric tensor to explore complex dynamics or curvature, we must first ensure it is physically valid. In numerical relativity, where the metric is evolved dynamically, errors can accumulate and corrupt its structure. This first practice [@problem_id:3493424] provides a foundational diagnostic tool: verifying that the metric at a given point has the correct Lorentzian signature and that its spatial part is positive-definite, ensuring a clear distinction between space and time.", "problem": "A spacetime metric tensor $g_{\\mu\\nu}$ determines the line element $ds^2 = g_{\\mu\\nu} \\, dx^{\\mu} \\, dx^{\\nu}$ and the causal character of vectors in a numerical relativity simulation. In a physically valid Lorentzian spacetime relevant to gravitational wave modeling, the metric must have signature $(-,+,+,+)$, its induced spatial $3\\times 3$ block must be positive-definite, and the line element must classify representative vectors consistently: a time-like vector $u^{\\mu}$ must yield $ds^2 < 0$, while a space-like vector $s^{\\mu}$ must yield $ds^2 > 0$, in units where the speed of light is $c=1$. Your task is to write a program that verifies these properties for a given test suite of metrics and vectors, as would be required to catch signature or positivity violations in simulations.\n\nFundamental base and core definitions to use:\n- The metric tensor $g_{\\mu\\nu}$ is symmetric and defines the bilinear form for the line element $ds^2 = g_{\\mu\\nu} \\, v^{\\mu} \\, v^{\\nu}$ for any tangent vector $v^{\\mu}$.\n- A metric has Lorentzian signature $(-,+,+,+)$ if, by Sylvester’s law of inertia, the count of negative, positive, and zero eigenvalues of the symmetric matrix $g_{\\mu\\nu}$ is invariant and equals one negative and three positive, with no zero eigenvalues (non-degenerate).\n- In the $3+1$ decomposition, the induced spatial metric $\\gamma_{ij} \\equiv g_{ij}$ (the spatial $3\\times 3$ block in coordinates $(t,x,y,z)$ with indices $i,j \\in \\{1,2,3\\}$) must be positive-definite, i.e., all its eigenvalues must be strictly positive.\n- Causal classification for signature $(-,+,+,+)$: for a physically realizable time-like vector $u^{\\mu}$, $ds^2 = g_{\\mu\\nu} u^{\\mu} u^{\\nu} < 0$, and for a space-like vector $s^{\\mu}$, $ds^2 = g_{\\mu\\nu} s^{\\mu} s^{\\nu} > 0$.\n\nNumerical classification rule:\n- To model floating-point effects, use a tolerance $\\epsilon = 10^{-10}$ to classify eigenvalues and line elements. Count an eigenvalue as negative if it is $< -\\epsilon$, positive if it is $> \\epsilon$, and zero (degenerate) if its absolute value is $\\le \\epsilon$. For the line element classification, require $g_{\\mu\\nu} u^{\\mu} u^{\\nu} < -\\epsilon$ for time-like and $g_{\\mu\\nu} s^{\\mu} s^{\\nu} > \\epsilon$ for space-like.\n\nTest suite:\n- Case A (Minkowski spacetime): $g^{(A)}_{\\mu\\nu} = \\mathrm{diag}(-1,\\,1,\\,1,\\,1)$, $u^{\\mu}=(1,\\,0,\\,0,\\,0)$, $s^{\\mu}=(0,\\,1,\\,0,\\,0)$.\n- Case B (Transverse-Traceless (TT) plus-polarized gravitational wave, weak-field snapshot): $h=10^{-3}$, $g^{(B)}_{\\mu\\nu} = \\mathrm{diag}(-1,\\,1+h,\\,1-h,\\,1)$, $u^{\\mu}=(1,\\,0,\\,0,\\,0)$, $s^{\\mu}=(0,\\,1,\\,0,\\,0)$.\n- Case C (Euclidean metric, invalid for relativity): $g^{(C)}_{\\mu\\nu} = \\mathrm{diag}(1,\\,1,\\,1,\\,1)$, $u^{\\mu}=(1,\\,0,\\,0,\\,0)$, $s^{\\mu}=(0,\\,1,\\,0,\\,0)$.\n- Case D (Near-degenerate boundary case): $g^{(D)}_{\\mu\\nu} = \\mathrm{diag}(-10^{-12},\\,1,\\,1,\\,1)$, $u^{\\mu}=(1,\\,0,\\,0,\\,0)$, $s^{\\mu}=(0,\\,1,\\,0,\\,0)$.\n- Case E (TT cross-polarized gravitational wave, weak-field snapshot with off-diagonal spatial terms): $h=0.05$, components $g^{(E)}_{00}=-1$, $g^{(E)}_{11}=1$, $g^{(E)}_{22}=1$, $g^{(E)}_{33}=1$, $g^{(E)}_{12}=g^{(E)}_{21}=h$, all other components zero; $u^{\\mu}=(1,\\,0,\\,0,\\,0)$, $s^{\\mu}=(0,\\,1,\\,1,\\,0)$.\n\nProgram requirements:\n- For each case, compute:\n    1. Whether the full metric has Lorentzian signature $(-,+,+,+)$ with the tolerance $\\epsilon$.\n    2. Whether the spatial $3\\times 3$ block $g_{ij}$ is positive-definite with the tolerance $\\epsilon$.\n    3. Whether the line elements for $u^{\\mu}$ and $s^{\\mu}$ satisfy $g_{\\mu\\nu} u^{\\mu} u^{\\nu} < -\\epsilon$ and $g_{\\mu\\nu} s^{\\mu} s^{\\nu} > \\epsilon$.\n- Return a boolean per case, which is true if and only if all three checks pass for that case.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, $[r_1,r_2,r_3,r_4,r_5]$, where each $r_k$ is a boolean corresponding to the case $k \\in \\{A,B,C,D,E\\}$.", "solution": "The problem requires the validation of several given spacetime metrics, $g_{\\mu\\nu}$, against a set of fundamental properties required for physical relevance in numerical relativity and gravitational wave modeling. A metric is deemed valid for a given case if it satisfies three specific criteria simultaneously: having the correct Lorentzian signature, inducing a positive-definite spatial metric, and correctly classifying the causal character of representative test vectors.\n\nThe validation process for each case proceeds by implementing three sequential checks based on the definitions provided. A numerical tolerance of $\\epsilon = 10^{-10}$ is used for all floating-point comparisons.\n\n1.  **Lorentzian Signature Verification**: A $4 \\times 4$ metric tensor $g_{\\mu\\nu}$ has a Lorentzian signature $(-,+,+,+)$ if and only if its eigenvalues consist of exactly one negative value, three positive values, and no zero values. To verify this, we compute the eigenvalues of the matrix representation of $g_{\\mu\\nu}$. Using the specified tolerance $\\epsilon$, an eigenvalue $\\lambda$ is counted as negative if $\\lambda < -\\epsilon$, positive if $\\lambda > \\epsilon$, and zero if $|\\lambda| \\le \\epsilon$. The metric is non-degenerate and Lorentzian if the counts are one negative, three positive, and zero 'zero' eigenvalues.\n\n2.  **Positive-Definite Spatial Metric Verification**: In the $3+1$ decomposition of spacetime, the induced spatial metric, $\\gamma_{ij}$, is the $3 \\times 3$ submatrix of $g_{\\mu\\nu}$ corresponding to the spatial indices $i, j \\in \\{1, 2, 3\\}$ (for coordinates $(x^0, x^1, x^2, x^3)$). For a physically valid spacetime, $\\gamma_{ij}$ must be positive-definite, meaning all its eigenvalues must be strictly positive. We check this by computing the three eigenvalues of $\\gamma_{ij}$ and ensuring each is greater than the tolerance $\\epsilon$.\n\n3.  **Causal Character Verification**: The line element $ds^2 = g_{\\mu\\nu} v^{\\mu} v^{\\nu}$ determines the causal nature of a vector $v^{\\mu}$. For the given test vectors, a time-like vector $u^{\\mu}$ must satisfy $g_{\\mu\\nu} u^{\\mu} u^{\\nu} < -\\epsilon$, and a space-like vector $s^{\\mu}$ must satisfy $g_{\\mu\\nu} s^{\\mu} s^{\\nu} > \\epsilon$. This is calculated using matrix-vector multiplication as $(v)^T g v$.\n\nA case passes the overall validation if and only if all three of these checks are successful. We now apply this procedure to each test case.\n\n**Case A: Minkowski Spacetime**\n-   Metric: $g^{(A)}_{\\mu\\nu} = \\mathrm{diag}(-1, 1, 1, 1)$.\n-   Vectors: $u^{\\mu} = (1, 0, 0, 0)$, $s^{\\mu} = (0, 1, 0, 0)$.\n\n1.  **Signature**: The eigenvalues of the diagonal matrix $g^{(A)}_{\\mu\\nu}$ are its diagonal entries: $\\{-1, 1, 1, 1\\}$. There is one negative eigenvalue and three positive eigenvalues. All are well outside the tolerance region. This check **passes**.\n2.  **Spatial Metric**: The spatial block is $\\gamma^{(A)}_{ij} = \\mathrm{diag}(1, 1, 1)$. Its eigenvalues are $\\{1, 1, 1\\}$, all of which are greater than $\\epsilon$. This check **passes**.\n3.  **Causal Character**:\n    -   For $u^{\\mu}$, $ds^2 = g_{00} (u^0)^2 = (-1)(1)^2 = -1$. Since $-1 < -\\epsilon$, this check **passes**.\n    -   For $s^{\\mu}$, $ds^2 = g_{11} (s^1)^2 = (1)(1)^2 = 1$. Since $1 > \\epsilon$, this check **passes**.\n\nAll three checks pass. The result for Case A is **True**.\n\n**Case B: TT Plus-Polarized Gravitational Wave**\n-   Metric: $g^{(B)}_{\\mu\\nu} = \\mathrm{diag}(-1, 1+h, 1-h, 1)$, with $h = 10^{-3}$. So, $g^{(B)}_{\\mu\\nu} = \\mathrm{diag}(-1, 1.001, 0.999, 1)$.\n-   Vectors: $u^{\\mu} = (1, 0, 0, 0)$, $s^{\\mu} = (0, 1, 0, 0)$.\n\n1.  **Signature**: The eigenvalues are $\\{-1, 1.001, 0.999, 1\\}$. There is one negative and three positive eigenvalues. This check **passes**.\n2.  **Spatial Metric**: The spatial block is $\\gamma^{(B)}_{ij} = \\mathrm{diag}(1.001, 0.999, 1)$. Its eigenvalues are $\\{1.001, 0.999, 1\\}$, all positive. This check **passes**.\n3.  **Causal Character**:\n    -   For $u^{\\mu}$, $ds^2 = g_{00} (u^0)^2 = -1 < -\\epsilon$. This check **passes**.\n    -   For $s^{\\mu}$, $ds^2 = g_{11} (s^1)^2 = (1+h)(1)^2 = 1.001 > \\epsilon$. This check **passes**.\n\nAll three checks pass. The result for Case B is **True**.\n\n**Case C: Euclidean Metric**\n-   Metric: $g^{(C)}_{\\mu\\nu} = \\mathrm{diag}(1, 1, 1, 1)$.\n-   Vectors: $u^{\\mu} = (1, 0, 0, 0)$, $s^{\\mu} = (0, 1, 0, 0)$.\n\n1.  **Signature**: The eigenvalues are $\\{1, 1, 1, 1\\}$. There are zero negative eigenvalues and four positive eigenvalues. This violates the $(-,+,+,+)$ signature requirement. This check **fails**.\n\nSince the first check fails, the overall result for the case is determined. The result for Case C is **False**.\n\n**Case D: Near-Degenerate Metric**\n-   Metric: $g^{(D)}_{\\mu\\nu} = \\mathrm{diag}(-10^{-12}, 1, 1, 1)$.\n-   Vectors: $u^{\\mu} = (1, 0, 0, 0)$, $s^{\\mu} = (0, 1, 0, 0)$.\n\n1.  **Signature**: The eigenvalues are $\\{-10^{-12}, 1, 1, 1\\}$. We check the eigenvalue $\\lambda_0 = -10^{-12}$ against the tolerance $\\epsilon = 10^{-10}$. Since $|\\lambda_0| = 10^{-12} \\le 10^{-10}$, this eigenvalue is classified as zero. The counts are zero negative, three positive, and one zero eigenvalue. This violates the non-degenerate Lorentzian signature requirement. This check **fails**.\n\nThe case is invalid. For completeness, we note the causal check for $u^{\\mu}$ also fails: $ds^2 = g_{00}(u^0)^2 = -10^{-12}$. The condition $ds^2 < -\\epsilon$ becomes $-10^{-12} < -10^{-10}$, which is false. The result for Case D is **False**.\n\n**Case E: TT Cross-Polarized Gravitational Wave**\n-   Metric: $g^{(E)}_{\\mu\\nu}$ has components $g_{00}=-1$, $g_{11}=g_{22}=g_{33}=1$, $g_{12}=g_{21}=h=0.05$. In matrix form:\n$$g^{(E)}_{\\mu\\nu} = \\begin{pmatrix} -1 & 0 & 0 & 0 \\\\ 0 & 1 & 0.05 & 0 \\\\ 0 & 0.05 & 1 & 0 \\\\ 0 & 0 & 0 & 1 \\end{pmatrix}$$\n-   Vectors: $u^{\\mu} = (1, 0, 0, 0)$, $s^{\\mu} = (0, 1, 1, 0)$.\n\n1.  **Signature**: The matrix is block-diagonal. The eigenvalues are those of the blocks: $\\{-1\\}$, $\\{1\\}$, and the submatrix $\\begin{pmatrix} 1 & 0.05 \\\\ 0.05 & 1 \\end{pmatrix}$. The eigenvalues of this $2 \\times 2$ submatrix are $\\lambda = 1 \\pm 0.05$, which are $1.05$ and $0.95$. The full set of eigenvalues for $g^{(E)}_{\\mu\\nu}$ is $\\{-1, 1.05, 0.95, 1\\}$. There is one negative and three positive eigenvalues. This check **passes**.\n2.  **Spatial Metric**: The spatial block is $\\gamma^{(E)}_{ij} = \\begin{pmatrix} 1 & 0.05 & 0 \\\\ 0.05 & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix}$. Its eigenvalues are $\\{1.05, 0.95, 1\\}$, all of which are positive. This check **passes**.\n3.  **Causal Character**:\n    -   For $u^{\\mu}$, $ds^2 = g_{00} (u^0)^2 = -1 < -\\epsilon$. This check **passes**.\n    -   For $s^{\\mu}$, $ds^2 = g_{\\mu\\nu} s^{\\mu} s^{\\nu} = g_{11}(s^1)^2 + g_{22}(s^2)^2 + 2g_{12}s^1 s^2 = (1)(1)^2 + (1)(1)^2 + 2(0.05)(1)(1) = 1 + 1 + 0.1 = 2.1$. Since $2.1 > \\epsilon$, this check **passes**.\n\nAll three checks pass. The result for Case E is **True**.\n\nFinal Summary of Booleans:\n- Case A: True\n- Case B: True\n- Case C: False\n- Case D: False\n- Case E: True", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Validates a test suite of spacetime metrics against physical criteria.\n\n    For each case, the program checks:\n    1. If the 4x4 metric has Lorentzian signature (-,+,+,+).\n    2. If the 3x3 spatial sub-metric is positive-definite.\n    3. If representative time-like and space-like vectors are correctly classified.\n\n    A case is valid (True) if and only if all three checks pass.\n    \"\"\"\n    \n    # Define the tolerance for floating-point comparisons as per the problem.\n    epsilon = 1e-10\n\n    # Test Case A: Minkowski spacetime\n    g_A = np.diag([-1.0, 1.0, 1.0, 1.0])\n    u_A = np.array([1.0, 0.0, 0.0, 0.0])\n    s_A = np.array([0.0, 1.0, 0.0, 0.0])\n\n    # Test Case B: Transverse-Traceless (TT) plus-polarized gravitational wave\n    h_B = 1e-3\n    g_B = np.diag([-1.0, 1.0 + h_B, 1.0 - h_B, 1.0])\n    u_B = np.array([1.0, 0.0, 0.0, 0.0])\n    s_B = np.array([0.0, 1.0, 0.0, 0.0])\n\n    # Test Case C: Euclidean metric (invalid for relativity)\n    g_C = np.diag([1.0, 1.0, 1.0, 1.0])\n    u_C = np.array([1.0, 0.0, 0.0, 0.0])\n    s_C = np.array([0.0, 1.0, 0.0, 0.0])\n\n    # Test Case D: Near-degenerate boundary case\n    g_D = np.diag([-1e-12, 1.0, 1.0, 1.0])\n    u_D = np.array([1.0, 0.0, 0.0, 0.0])\n    s_D = np.array([0.0, 1.0, 0.0, 0.0])\n\n    # Test Case E: TT cross-polarized gravitational wave\n    h_E = 0.05\n    g_E = np.array([\n        [-1.0, 0.0, 0.0, 0.0],\n        [0.0, 1.0, h_E, 0.0],\n        [0.0, h_E, 1.0, 0.0],\n        [0.0, 0.0, 0.0, 1.0]\n    ])\n    u_E = np.array([1.0, 0.0, 0.0, 0.0])\n    s_E = np.array([0.0, 1.0, 1.0, 0.0])\n\n    test_cases = [\n        (g_A, u_A, s_A),\n        (g_B, u_B, s_B),\n        (g_C, u_C, s_C),\n        (g_D, u_D, s_D),\n        (g_E, u_E, s_E),\n    ]\n\n    results = []\n    for g, u, s in test_cases:\n        # Check 1: Lorentzian signature\n        # Use np.linalg.eigvalsh as the metrics are real symmetric matrices.\n        eigs_g = np.linalg.eigvalsh(g)\n        \n        neg_count = np.sum(eigs_g < -epsilon)\n        pos_count = np.sum(eigs_g > epsilon)\n        zero_count = np.sum(np.abs(eigs_g) <= epsilon)\n        \n        is_lorentzian = (neg_count == 1 and pos_count == 3 and zero_count == 0)\n\n        # Check 2: Positive-definite spatial metric\n        gamma = g[1:, 1:]\n        eigs_gamma = np.linalg.eigvalsh(gamma)\n        \n        is_spatial_pos_def = np.all(eigs_gamma > epsilon)\n\n        # Check 3: Causal classification\n        # Calculate line elements using matrix multiplication: v.T @ g @ v\n        ds2_u = u @ g @ u\n        ds2_s = s @ g @ s\n        \n        is_causal_correct = (ds2_u < -epsilon and ds2_s > epsilon)\n        \n        # A case is valid if and only if all three checks pass.\n        case_result = is_lorentzian and is_spatial_pos_def and is_causal_correct\n        results.append(case_result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3493424"}, {"introduction": "A cornerstone of general relativity is the principle of general covariance—physical laws are independent of the coordinate system used to describe them. The metric tensor's components transform in a specific way to uphold this principle, ensuring the line element $ds^2$ remains an invariant scalar. This exercise [@problem_id:3493437] has you derive this transformation law from first principles, using the Jacobian matrix to connect different coordinate patches and numerically verifying the invariance of $ds^2$.", "problem": "Consider a weak-field plane gravitational wave propagating in the $+z$ direction in the transverse-traceless gauge. In geometrized units where the speed of light is $c = 1$, the line element in Cartesian coordinates $(t,x,y,z)$ is defined by the metric tensor with components $g_{\\mu\\nu}(t,x,y,z)$ such that the line element satisfies $ds^2 = g_{\\mu\\nu} \\, dx^\\mu \\, dx^\\nu$, where indices $\\mu,\\nu \\in \\{0,1,2,3\\}$ correspond to $(t,x,y,z)$ respectively. The nonzero components of the metric are given by $g_{00} = -1$, $g_{11} = 1 + h_+(u)$, $g_{22} = 1 - h_+(u)$, $g_{33} = 1$, where $u = t - z$ and $h_+(u)$ is a prescribed differentiable function encoding the plus polarization of the gravitational wave. In this problem, take $h_+(u) = \\varepsilon \\sin(\\omega u)$, with $\\varepsilon$ a small dimensionless amplitude and $\\omega$ an angular frequency in radians per unit time.\n\nYou will examine matching across coordinate patches using Jacobian-based transformations and verify the invariance of the line element under coordinate changes. The fundamental starting point is the definition of the line element $ds^2$ and the requirement of its invariance under smooth coordinate transformations, together with the chain rule for differentials. You are not to assume or use any shortcut formulas for transforming the metric; you must derive all necessary relations from the invariance of $ds^2$ and the chain rule.\n\nTwo coordinate patches are considered:\n\n1. A rotated Cartesian patch $(t',x',y',z')$ defined by a rotation by angle $\\alpha$ in the $x$–$y$ plane, with angle measured in radians, specified by:\n   $$\n   t = t', \\quad z = z', \\quad x = x' \\cos\\alpha - y' \\sin\\alpha, \\quad y = x' \\sin\\alpha + y' \\cos\\alpha.\n   $$\n\n2. A spherical spatial patch $(t,r,\\theta,\\phi)$ where angles are measured in radians, specified by the relations:\n   $$\n   t = t, \\quad x = r \\sin\\theta \\cos\\phi, \\quad y = r \\sin\\theta \\sin\\phi, \\quad z = r \\cos\\theta.\n   $$\n\nFor each patch, construct the Jacobian matrix entries associated with the transformation from the patch coordinates to the Cartesian coordinates via the chain rule, use them to compute the metric components in the patch coordinates consistent with the invariance of $ds^2$, and then verify the invariance of the line element by computing $ds^2$ for the same physical displacement expressed in both coordinate systems.\n\nDefine the discrepancy for a given test case as the absolute difference between the line element computed in the original Cartesian coordinates and in the transformed patch coordinates for the same physical displacement. Specifically, given a small displacement vector in the patch coordinates, use the Jacobian to compute the corresponding displacement in Cartesian coordinates, evaluate both line elements at the same event, and report the absolute difference as a floating-point number. Angles must be specified in radians.\n\nYour program must implement this verification for the following test suite. In all cases, angles are in radians, and you should report the discrepancy as a dimensionless floating-point number.\n\n- Test Case $1$ (rotated Cartesian, general case):\n  - Parameters: $\\varepsilon = 10^{-3}$, $\\omega = 100$, $\\alpha = \\pi/6$.\n  - Event in rotated coordinates: $(t',x',y',z') = (0.3, 0.1, -0.2, 0.5)$.\n  - Displacement in rotated coordinates: $(dt', dx', dy', dz') = (10^{-3}, 2\\times 10^{-3}, -10^{-3}, 1.5\\times 10^{-3})$.\n\n- Test Case $2$ (rotated Cartesian, near-identity rotation boundary):\n  - Parameters: $\\varepsilon = 10^{-3}$, $\\omega = 100$, $\\alpha = 10^{-8}$.\n  - Event in rotated coordinates: $(t',x',y',z') = (0.3, 0.1, -0.2, 0.5)$.\n  - Displacement in rotated coordinates: $(dt', dx', dy', dz') = (10^{-3}, -10^{-3}, 1.5\\times 10^{-3}, -2\\times 10^{-3})$.\n\n- Test Case $3$ (spherical patch, near polar axis boundary):\n  - Parameters: $\\varepsilon = 10^{-4}$, $\\omega = 250$.\n  - Event in spherical coordinates: $(t,r,\\theta,\\phi) = (0.25, 1.2, 10^{-6}, 1.0)$.\n  - Displacement in spherical coordinates: $(dt, dr, d\\theta, d\\phi) = (10^{-3}, 5\\times 10^{-4}, 10^{-6}, 10^{-3})$.\n\n- Test Case $4$ (spherical patch, equatorial case):\n  - Parameters: $\\varepsilon = 10^{-3}$, $\\omega = 50$.\n  - Event in spherical coordinates: $(t,r,\\theta,\\phi) = (0.1, 2.0, \\pi/2, 2.0)$.\n  - Displacement in spherical coordinates: $(dt, dr, d\\theta, d\\phi) = (5\\times 10^{-4}, -10^{-3}, 2\\times 10^{-3}, -10^{-3})$.\n\nYour program should produce a single line of output containing the discrepancies for the four test cases as a comma-separated list enclosed in square brackets (for example, $\\,[result_1, result_2, result_3, result_4]$ with each $result_i$ a floating-point number). No units are required because geometrized units are used and the discrepancies are dimensionless. Angles must be treated in radians throughout.", "solution": "The goal is to verify the invariance of the line element $ds^2$ under smooth coordinate transformations by constructing the metric in new coordinates from first principles. The fundamental base is the definition of the line element $ds^2 = g_{\\mu\\nu} \\, dx^\\mu \\, dx^\\nu$, the requirement that $ds^2$ represents the invariant squared interval between neighboring events, and the chain rule for differentials.\n\nStarting point:\n\n1. The line element in Cartesian coordinates $(t,x,y,z)$ is specified by the metric components:\n   $$\n   g_{00} = -1, \\quad g_{11} = 1 + h_+(u), \\quad g_{22} = 1 - h_+(u), \\quad g_{33} = 1,\n   $$\n   with $u = t - z$, and $h_+(u) = \\varepsilon \\sin(\\omega u)$ for given parameters $\\varepsilon$ and $\\omega$.\n\n2. The invariance of the line element under coordinate transformations states that if one introduces new coordinates $x'^a$ with indices $a \\in \\{0,1,2,3\\}$, then the squared interval computed in primed coordinates equals that in unprimed coordinates at the same spacetime event:\n   $$\n   ds^2 = g_{\\mu\\nu}(x) \\, dx^\\mu \\, dx^\\nu = g'_{ab}(x') \\, dx'^a \\, dx'^b.\n   $$\n   The object $g'_{ab}(x')$ is the metric tensor in the primed coordinate system.\n\n3. The chain rule for differentials relates the coordinate differentials in the two systems via the Jacobian matrix of the transformation $x^\\mu(x')$:\n   $$\n   dx^\\mu = \\frac{\\partial x^\\mu}{\\partial x'^a} \\, dx'^a.\n   $$\n   Substituting this into the unprimed expression for $ds^2$ and comparing with the primed expression gives the transformation rule for the metric:\n   $$\n   ds^2 = g_{\\mu\\nu} \\, dx^\\mu \\, dx^\\nu = g_{\\mu\\nu} \\left( \\frac{\\partial x^\\mu}{\\partial x'^a} \\, dx'^a \\right) \\left( \\frac{\\partial x^\\nu}{\\partial x'^b} \\, dx'^b \\right) = \\left( \\frac{\\partial x^\\mu}{\\partial x'^a} \\frac{\\partial x^\\nu}{\\partial x'^b} g_{\\mu\\nu} \\right) dx'^a dx'^b,\n   $$\n   which implies\n   $$\n   g'_{ab}(x') = \\frac{\\partial x^\\mu}{\\partial x'^a} \\frac{\\partial x^\\nu}{\\partial x'^b} g_{\\mu\\nu}(x).\n   $$\n   In matrix form, if one denotes by $J$ the Jacobian with entries $J^\\mu{}_a = \\partial x^\\mu / \\partial x'^a$, and by $g$ the matrix with entries $g_{\\mu\\nu}$, then the primed metric is $g' = J^\\top g J$.\n\nWith these principles, we construct the Jacobians for the two patches and verify the invariance numerically by comparing the line elements for the same physical displacement expressed in both coordinate systems.\n\nRotated Cartesian patch:\n\n- The transformation is given by\n  $$\n  t = t', \\quad z = z', \\quad x = x' \\cos\\alpha - y' \\sin\\alpha, \\quad y = x' \\sin\\alpha + y' \\cos\\alpha,\n  $$\n  which yields the Jacobian entries:\n  $$\n  \\frac{\\partial t}{\\partial t'} = 1, \\quad \\frac{\\partial t}{\\partial x'} = \\frac{\\partial t}{\\partial y'} = \\frac{\\partial t}{\\partial z'} = 0,\n  $$\n  $$\n  \\frac{\\partial x}{\\partial x'} = \\cos\\alpha, \\quad \\frac{\\partial x}{\\partial y'} = -\\sin\\alpha, \\quad \\frac{\\partial x}{\\partial z'} = 0, \\quad \\frac{\\partial x}{\\partial t'} = 0,\n  $$\n  $$\n  \\frac{\\partial y}{\\partial x'} = \\sin\\alpha, \\quad \\frac{\\partial y}{\\partial y'} = \\cos\\alpha, \\quad \\frac{\\partial y}{\\partial z'} = 0, \\quad \\frac{\\partial y}{\\partial t'} = 0,\n  $$\n  $$\n  \\frac{\\partial z}{\\partial z'} = 1, \\quad \\frac{\\partial z}{\\partial t'} = \\frac{\\partial z}{\\partial x'} = \\frac{\\partial z}{\\partial y'} = 0.\n  $$\n  Thus, the Jacobian matrix $J$ is constant with respect to $(x',y',z')$ except for its dependence on $\\alpha$. Given an event $(t',x',y',z')$, one maps it to $(t,x,y,z)$ using the rotation formulas, evaluates $u = t - z$, computes $h_+(u)$, constructs $g_{\\mu\\nu}(t,x,y,z)$, then computes $g'_{ab} = J^\\top g J$.\n\n- To verify invariance, take a displacement $dx'^a = (dt',dx',dy',dz')$, compute the corresponding Cartesian displacement via $dx^\\mu = J^\\mu{}_a \\, dx'^a$, and form\n  $$\n  ds'^2 = g'_{ab} \\, dx'^a \\, dx'^b, \\quad ds^2 = g_{\\mu\\nu} \\, dx^\\mu \\, dx^\\nu.\n  $$\n  The discrepancy reported is $|ds'^2 - ds^2|$.\n\nSpherical spatial patch:\n\n- The transformation is given by\n  $$\n  t = t, \\quad x = r \\sin\\theta \\cos\\phi, \\quad y = r \\sin\\theta \\sin\\phi, \\quad z = r \\cos\\theta.\n  $$\n  The nonzero Jacobian entries follow from partial derivatives:\n  $$\n  \\frac{\\partial t}{\\partial t} = 1, \\quad \\frac{\\partial t}{\\partial r} = \\frac{\\partial t}{\\partial \\theta} = \\frac{\\partial t}{\\partial \\phi} = 0,\n  $$\n  $$\n  \\frac{\\partial x}{\\partial r} = \\sin\\theta \\cos\\phi, \\quad \\frac{\\partial x}{\\partial \\theta} = r \\cos\\theta \\cos\\phi, \\quad \\frac{\\partial x}{\\partial \\phi} = -r \\sin\\theta \\sin\\phi,\n  $$\n  $$\n  \\frac{\\partial y}{\\partial r} = \\sin\\theta \\sin\\phi, \\quad \\frac{\\partial y}{\\partial \\theta} = r \\cos\\theta \\sin\\phi, \\quad \\frac{\\partial y}{\\partial \\phi} = r \\sin\\theta \\cos\\phi,\n  $$\n  $$\n  \\frac{\\partial z}{\\partial r} = \\cos\\theta, \\quad \\frac{\\partial z}{\\partial \\theta} = -r \\sin\\theta, \\quad \\frac{\\partial z}{\\partial \\phi} = 0.\n  $$\n  With these, $J^\\mu{}_a$ is constructed at the event $(t,r,\\theta,\\phi)$. The event is mapped to Cartesian coordinates via the above relations, $u = t - z$ is computed, $h_+(u)$ is evaluated, and $g_{\\mu\\nu}$ is formed. Then $g'_{ab} = J^\\top g J$ yields the spherical-coordinate metric.\n\n- To verify invariance, for a displacement $dx^a = (dt,dr,d\\theta,d\\phi)$, compute $dx^\\mu = J^\\mu{}_a \\, dx^a$, form\n  $$\n  ds'^2 = g'_{ab} \\, dx^a \\, dx^b, \\quad ds^2 = g_{\\mu\\nu} \\, dx^\\mu \\, dx^\\nu,\n  $$\n  and report the discrepancy $|ds'^2 - ds^2|$.\n\nNumerical considerations:\n\n- Because the transformations are smooth and the metric is constructed from the invariance of $ds^2$, the discrepancies should be on the order of floating-point round-off error. Near coordinate singularities (for example, $\\theta \\approx 0$), the Jacobian may become ill-conditioned, and finite-precision arithmetic can amplify errors; nevertheless, the invariance should hold to within numerical tolerance for small displacements.\n\nAlgorithmic design:\n\n- Implement the function $h_+(u) = \\varepsilon \\sin(\\omega u)$.\n- Implement a function to build $g_{\\mu\\nu}(t,x,y,z)$ in Cartesian coordinates.\n- Implement functions to construct the Jacobians for the rotated Cartesian and spherical patches and to map coordinates between patches and Cartesian coordinates.\n- For each test case, compute $J$, map the event to Cartesian coordinates, construct $g$, compute $g'$, then compute $ds^2$ in both coordinate systems for the given displacement and report the absolute difference.\n- Aggregate the four discrepancies into a single output line in the specified format.\n\nAll angles are handled in radians, and all reported discrepancies are dimensionless floats, consistent with geometrized units.", "answer": "```python\n# Python 3.12 program to verify invariance of the line element across coordinate patches\n# under Jacobian transformations for a weak-field plane gravitational wave metric.\n# Uses numpy 1.23.5; no other external libraries are required.\n\nimport numpy as np\n\ndef h_plus(u, eps, omega):\n    \"\"\"Plus polarization of the gravitational wave: h_+(u) = eps * sin(omega * u).\"\"\"\n    return eps * np.sin(omega * u)\n\ndef metric_cartesian(t, x, y, z, eps, omega):\n    \"\"\"\n    Construct the 4x4 metric tensor in Cartesian coordinates for the plane gravitational wave\n    in transverse-traceless gauge with plus polarization, in geometrized units (c=1).\n    Coordinates: (t, x, y, z) -> indices (0,1,2,3).\n    \"\"\"\n    u = t - z\n    hp = h_plus(u, eps, omega)\n    g = np.zeros((4, 4), dtype=float)\n    g[0, 0] = -1.0\n    g[1, 1] = 1.0 + hp\n    g[2, 2] = 1.0 - hp\n    g[3, 3] = 1.0\n    return g\n\ndef jacobian_rotation(alpha):\n    \"\"\"\n    Jacobian J^mu{}_a = ∂x^mu/∂x'^a for rotation in the x-y plane:\n    t = t', z = z', x = x' cos α - y' sin α, y = x' sin α + y' cos α.\n    Coordinates ordering: (t,x,y,z) for mu; (t',x',y',z') for a.\n    \"\"\"\n    ca = np.cos(alpha)\n    sa = np.sin(alpha)\n    J = np.zeros((4, 4), dtype=float)\n    # t row\n    J[0, 0] = 1.0\n    # x row\n    J[1, 1] = ca\n    J[1, 2] = -sa\n    # y row\n    J[2, 1] = sa\n    J[2, 2] = ca\n    # z row\n    J[3, 3] = 1.0\n    return J\n\ndef map_event_rotation(t_p, x_p, y_p, z_p, alpha):\n    \"\"\"\n    Map event from rotated coordinates (t', x', y', z') to Cartesian (t, x, y, z)\n    using the rotation relations.\n    \"\"\"\n    ca = np.cos(alpha)\n    sa = np.sin(alpha)\n    t = t_p\n    x = x_p * ca - y_p * sa\n    y = x_p * sa + y_p * ca\n    z = z_p\n    return t, x, y, z\n\ndef jacobian_spherical(t, r, theta, phi):\n    \"\"\"\n    Jacobian J^mu{}_a = ∂x^mu/∂x^a for spherical spatial coordinates:\n    t = t, x = r sinθ cosφ, y = r sinθ sinφ, z = r cosθ.\n    Coordinates ordering: mu=(t,x,y,z), a=(t,r,theta,phi).\n    \"\"\"\n    st = np.sin(theta)\n    ct = np.cos(theta)\n    cf = np.cos(phi)\n    sf = np.sin(phi)\n    J = np.zeros((4, 4), dtype=float)\n    # t row\n    J[0, 0] = 1.0\n    # x row\n    J[1, 1] = st * cf\n    J[1, 2] = r * ct * cf\n    J[1, 3] = -r * st * sf\n    # y row\n    J[2, 1] = st * sf\n    J[2, 2] = r * ct * sf\n    J[2, 3] = r * st * cf\n    # z row\n    J[3, 1] = ct\n    J[3, 2] = -r * st\n    # J[3, 3] remains 0\n    return J\n\ndef map_event_spherical(t_s, r, theta, phi):\n    \"\"\"\n    Map event from spherical coordinates (t, r, theta, phi) to Cartesian (t, x, y, z).\n    \"\"\"\n    st = np.sin(theta)\n    ct = np.cos(theta)\n    cf = np.cos(phi)\n    sf = np.sin(phi)\n    x = r * st * cf\n    y = r * st * sf\n    z = r * ct\n    return t_s, x, y, z\n\ndef ds2_from_metric_and_displacement(g, dx):\n    \"\"\"Compute ds^2 = dx^T g dx.\"\"\"\n    return float(dx.T @ (g @ dx))\n\ndef run_rotation_case(eps, omega, alpha, event_p, disp_p):\n    \"\"\"\n    Compute discrepancy |ds'^2 - ds^2| for rotated Cartesian patch.\n    event_p: (t', x', y', z'), disp_p: (dt', dx', dy', dz').\n    \"\"\"\n    t_p, x_p, y_p, z_p = event_p\n    dt_p, dx_p, dy_p, dz_p = disp_p\n    J = jacobian_rotation(alpha)\n    t, x, y, z = map_event_rotation(t_p, x_p, y_p, z_p, alpha)\n    g = metric_cartesian(t, x, y, z, eps, omega)\n    g_p = J.T @ g @ J\n    dxp = np.array([dt_p, dx_p, dy_p, dz_p], dtype=float)\n    dx = J @ dxp\n    ds2_p = ds2_from_metric_and_displacement(g_p, dxp)\n    ds2 = ds2_from_metric_and_displacement(g, dx)\n    return abs(ds2_p - ds2)\n\ndef run_spherical_case(eps, omega, event_s, disp_s):\n    \"\"\"\n    Compute discrepancy |ds'^2 - ds^2| for spherical spatial patch.\n    event_s: (t, r, theta, phi), disp_s: (dt, dr, dtheta, dphi).\n    \"\"\"\n    t_s, r, theta, phi = event_s\n    dt_s, dr, dtheta, dphi = disp_s\n    J = jacobian_spherical(t_s, r, theta, phi)\n    t, x, y, z = map_event_spherical(t_s, r, theta, phi)\n    g = metric_cartesian(t, x, y, z, eps, omega)\n    g_s = J.T @ g @ J\n    dxs = np.array([dt_s, dr, dtheta, dphi], dtype=float)\n    dx = J @ dxs\n    ds2_s = ds2_from_metric_and_displacement(g_s, dxs)\n    ds2 = ds2_from_metric_and_displacement(g, dx)\n    return abs(ds2_s - ds2)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case 1: rotated Cartesian, general case\n        (\"rotation\", {\"eps\": 1e-3, \"omega\": 100.0, \"alpha\": np.pi / 6,\n                      \"event_p\": (0.3, 0.1, -0.2, 0.5),\n                      \"disp_p\": (1e-3, 2e-3, -1e-3, 1.5e-3)}),\n        # Test Case 2: rotated Cartesian, near-identity rotation boundary\n        (\"rotation\", {\"eps\": 1e-3, \"omega\": 100.0, \"alpha\": 1e-8,\n                      \"event_p\": (0.3, 0.1, -0.2, 0.5),\n                      \"disp_p\": (1e-3, -1e-3, 1.5e-3, -2e-3)}),\n        # Test Case 3: spherical patch, near polar axis boundary\n        (\"spherical\", {\"eps\": 1e-4, \"omega\": 250.0,\n                       \"event_s\": (0.25, 1.2, 1e-6, 1.0),\n                       \"disp_s\": (1e-3, 5e-4, 1e-6, 1e-3)}),\n        # Test Case 4: spherical patch, equatorial case\n        (\"spherical\", {\"eps\": 1e-3, \"omega\": 50.0,\n                       \"event_s\": (0.1, 2.0, np.pi / 2.0, 2.0),\n                       \"disp_s\": (5e-4, -1e-3, 2e-3, -1e-3)}),\n    ]\n\n    results = []\n    for kind, params in test_cases:\n        if kind == \"rotation\":\n            result = run_rotation_case(params[\"eps\"], params[\"omega\"], params[\"alpha\"],\n                                       params[\"event_p\"], params[\"disp_p\"])\n        elif kind == \"spherical\":\n            result = run_spherical_case(params[\"eps\"], params[\"omega\"],\n                                        params[\"event_s\"], params[\"disp_s\"])\n        else:\n            result = float(\"nan\")\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3493437"}, {"introduction": "The metric tensor is not just a tool for measuring distances; it contains all the information about the spacetime's geometry and curvature. This final practice [@problem_id:3493362] guides you through the process of extracting this information by computing the Christoffel symbols and the Ricci curvature tensor directly from the metric and its derivatives. By testing your implementation against known analytic solutions to Einstein's equations, you will build and validate a core component of any numerical relativity toolkit.", "problem": "You are asked to implement a program that tests a tensor-calculus kernel using analytic metrics that are standard in numerical relativity. The core quantities are the metric tensor and line element. Work in geometrized units where $G=c=1$, and treat all quantities as dimensionless. All angles must be interpreted in radians. Your program must compute, for several analytic spacetimes and specified coordinate points and displacements, the squared line element and verify the vacuum Einstein equations via the Ricci tensor. Your output must aggregate all test results into a single line printed as a comma-separated list enclosed in square brackets.\n\nFundamental base to use:\n\n- The line element is defined by $ds^{2} = g_{\\mu\\nu} \\, dx^{\\mu} \\, dx^{\\nu}$, where $g_{\\mu\\nu}$ is the metric tensor and $dx^{\\mu}$ is an infinitesimal coordinate displacement.\n\n- The Levi-Civita connection (Christoffel symbols) for a metric-compatible, torsion-free connection is\n$$\n\\Gamma^{\\rho}{}_{\\mu\\nu} = \\frac{1}{2} g^{\\rho\\sigma} \\left( \\partial_{\\mu} g_{\\sigma\\nu} + \\partial_{\\nu} g_{\\sigma\\mu} - \\partial_{\\sigma} g_{\\mu\\nu} \\right),\n$$\nwhere $g^{\\mu\\nu}$ is the inverse of $g_{\\mu\\nu}$.\n\n- The derivative of the inverse metric follows from $g^{\\mu\\alpha} g_{\\alpha\\nu} = \\delta^{\\mu}{}_{\\nu}$:\n$$\n\\partial_{\\lambda} g^{\\mu\\nu} = - \\, g^{\\mu\\alpha} \\, (\\partial_{\\lambda} g_{\\alpha\\beta}) \\, g^{\\beta\\nu}.\n$$\n\n- The Ricci tensor is the contraction of the Riemann curvature tensor:\n$$\nR_{\\mu\\nu} = \\partial_{\\alpha} \\Gamma^{\\alpha}{}_{\\mu\\nu} - \\partial_{\\nu} \\Gamma^{\\alpha}{}_{\\mu\\alpha} + \\Gamma^{\\alpha}{}_{\\alpha\\beta} \\Gamma^{\\beta}{}_{\\mu\\nu} - \\Gamma^{\\alpha}{}_{\\mu\\beta} \\Gamma^{\\beta}{}_{\\alpha\\nu}.\n$$\n\nYour program must implement the following requirements:\n\n1. Implement generic routines that, given a metric $g_{\\mu\\nu}(x^{\\lambda})$ and its first and second partial derivatives $\\partial_{\\lambda} g_{\\mu\\nu}$ and $\\partial_{\\kappa}\\partial_{\\lambda} g_{\\mu\\nu}$ at a point, compute:\n   - The inverse metric $g^{\\mu\\nu}$ and its first derivatives $\\partial_{\\lambda} g^{\\mu\\nu}$.\n   - The Christoffel symbols $\\Gamma^{\\rho}{}_{\\mu\\nu}$ and their first derivatives $\\partial_{\\lambda}\\Gamma^{\\rho}{}_{\\mu\\nu}$.\n   - The Ricci tensor $R_{\\mu\\nu}$ from the above definition.\n\n2. Implement three analytic metrics by providing $g_{\\mu\\nu}$, $\\partial_{\\lambda} g_{\\mu\\nu}$, and $\\partial_{\\kappa}\\partial_{\\lambda} g_{\\mu\\nu}$ in closed form:\n   - Minkowski metric in Cartesian coordinates $(t,x,y,z)$ with signature $(-,+,+,+)$:\n     $$\n     g_{\\mu\\nu} = \\mathrm{diag}(-1,\\,1,\\,1,\\,1).\n     $$\n   - Schwarzschild metric in Schwarzschild coordinates $(t,r,\\theta,\\phi)$ with mass parameter $M$:\n     $$\n     g_{tt} = -(1 - 2M/r), \\quad g_{rr} = (1 - 2M/r)^{-1}, \\quad g_{\\theta\\theta} = r^{2}, \\quad g_{\\phi\\phi} = r^{2} \\sin^{2}\\theta,\n     $$\n     with all off-diagonal components equal to $0$.\n   - Plane-fronted gravitational wave with parallel rays (pp-wave) in Brinkmann coordinates $(u,v,x,y)$:\n     $$\n     ds^{2} = -2 \\, du \\, dv + H(u,x,y) \\, du^{2} + dx^{2} + dy^{2},\n     $$\n     with\n     $$\n     H(u,x,y) = \\sin u \\,(x^{2} - y^{2}).\n     $$\n     The nonzero components are $g_{uu} = H$, $g_{uv}=g_{vu}=-1$, $g_{xx}=1$, $g_{yy}=1$.\n\n3. For each specified test case, compute:\n   - The squared line element $ds^{2} = g_{\\mu\\nu} dx^{\\mu} dx^{\\nu}$ for the provided infinitesimal displacement $dx^{\\mu}$.\n   - A vacuum check boolean defined by:\n     $$\n     \\mathrm{vacuum\\_ok} = \\left( \\max_{\\mu,\\nu} |R_{\\mu\\nu}|  \\varepsilon \\right)\n     $$\n     using the threshold $\\varepsilon = 10^{-9}$.\n\n4. Test suite. Use the following parameter values and displacements exactly:\n\n   - Test A (Minkowski):\n     - Coordinates $(t,x,y,z) = (0,\\,1,\\,2,\\,3)$.\n     - Displacement $dx^{\\mu} = (1,\\,0.5,\\,0,\\,0)$.\n     - Expected qualitative behavior: flat spacetime with $R_{\\mu\\nu} = 0$.\n\n   - Test B (Schwarzschild):\n     - Mass $M = 1$.\n     - Coordinates $(t,r,\\theta,\\phi) = (0,\\,10,\\,\\pi/2,\\,0)$.\n     - Displacement $dx^{\\mu} = (1,\\,0,\\,0,\\,0)$.\n     - Expected qualitative behavior: vacuum region with $R_{\\mu\\nu} = 0$.\n\n   - Test C (Schwarzschild, near horizon):\n     - Mass $M = 1$.\n     - Coordinates $(t,r,\\theta,\\phi) = (0,\\,2.1,\\,\\pi/2,\\,0)$.\n     - Displacement $dx^{\\mu} = (1,\\,0,\\,0,\\,0)$.\n     - Expected qualitative behavior: vacuum region with $R_{\\mu\\nu} = 0$; approach to horizon tests numerical stability.\n\n   - Test D (pp-wave, symmetric transverse coordinates):\n     - Coordinates $(u,v,x,y) = (0.3,\\,0,\\,1,\\,1)$.\n     - Displacement $dx^{\\mu} = (1,\\,0,\\,0.5,\\,-0.5)$.\n     - Expected qualitative behavior: $H=0$ at this point, so transverse contribution dominates $ds^{2}$; vacuum solution implies $R_{\\mu\\nu}=0$.\n\n   - Test E (pp-wave, nontrivial profile):\n     - Coordinates $(u,v,x,y) = (1.0,\\,0,\\,2,\\,1)$.\n     - Displacement $dx^{\\mu} = (1,\\,0,\\,0,\\,0)$.\n     - Expected qualitative behavior: $ds^{2} = H(u,x,y)$; vacuum solution implies $R_{\\mu\\nu}=0$.\n\n5. Output format. Your program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For each test case, append two items to the list in the following order:\n   - The computed $ds^{2}$ as a floating-point number (no rounding requirement beyond the language default).\n   - The vacuum check boolean $\\mathrm{vacuum\\_ok}$.\n\nThus, your program must print a single line with ten entries:\n$$\n[\\; ds^{2}_{A},\\ \\mathrm{vacuum\\_ok}_{A},\\ ds^{2}_{B},\\ \\mathrm{vacuum\\_ok}_{B},\\ ds^{2}_{C},\\ \\mathrm{vacuum\\_ok}_{C},\\ ds^{2}_{D},\\ \\mathrm{vacuum\\_ok}_{D},\\ ds^{2}_{E},\\ \\mathrm{vacuum\\_ok}_{E} \\;].\n$$", "solution": "The user problem is a well-posed computational task in the domain of numerical relativity and tensor calculus, requiring the implementation of core general relativistic quantities and their verification for known analytic solutions of Einstein's field equations. The problem is scientifically grounded, formally specified, and free of any invalidating flaws. A complete solution can be constructed by following a systematic, principle-based approach.\n\nThe solution is structured into two primary components:\n1. A set of classes representing the analytic spacetimes, which provide the metric tensor $g_{\\mu\\nu}$ and its first $\\partial_{\\lambda}g_{\\mu\\nu}$ and second $\\partial_{\\kappa}\\partial_{\\lambda}g_{\\mu\\nu}$ partial derivatives in closed form.\n2. A generic tensor computation engine that, given these derivatives at a point, calculates all derived quantities, including the squared line element $ds^2$ and the Ricci tensor $R_{\\mu\\nu}$.\n\nThe coordinates are consistently indexed from $0$ to $3$. For example, in Schwarzschild coordinates $(t,r,\\theta,\\phi)$, the indices are $\\mu=0$ for $t$, $\\mu=1$ for $r$, $\\mu=2$ for $\\theta$, and $\\mu=3$ for $\\phi$. All arrays follow this convention, e.g., a tensor $T_{\\lambda\\mu\\nu}$ is stored in a NumPy array `T` where the component is accessed as `T[l,m,n]`.\n\nThe core computational steps are as follows:\n\n1.  **Metric and its Derivatives**: For each test case, the appropriate metric class is instantiated. This class provides numerical values for the metric tensor $g_{\\mu\\nu}$, its first derivatives $\\partial_{\\lambda} g_{\\mu\\nu}$, and its second derivatives $\\partial_{\\kappa}\\partial_{\\lambda} g_{\\mu\\nu}$ at the specified coordinate point. These serve as the fundamental inputs for all subsequent calculations.\n\n2.  **Squared Line Element $ds^2$**: The squared line element is computed from the metric $g_{\\mu\\nu}$ and the given coordinate displacement vector $dx^{\\mu}$ using Einstein's summation convention, as per the definition:\n    $$\n    ds^{2} = g_{\\mu\\nu} \\, dx^{\\mu} \\, dx^{\\nu}\n    $$\n    This is a tensor contraction implemented efficiently using matrix-vector operations.\n\n3.  **Inverse Metric $g^{\\mu\\nu}$ and its Derivative $\\partial_{\\lambda}g^{\\mu\\nu}$**: The inverse metric $g^{\\mu\\nu}$ is calculated by numerically inverting the matrix representation of $g_{\\mu\\nu}$. The derivative of the inverse metric is then computed from the derivative of the metric using the identity derived from $\\partial_{\\lambda}(g^{\\mu\\alpha}g_{\\alpha\\nu}) = 0$:\n    $$\n    \\partial_{\\lambda} g^{\\mu\\nu} = -g^{\\mu\\alpha} (\\partial_{\\lambda} g_{\\alpha\\beta}) g^{\\beta\\nu}\n    $$\n    This formula is implemented using tensor products (specifically, `numpy.einsum`).\n\n4.  **Christoffel Symbols $\\Gamma^{\\rho}{}_{\\mu\\nu}$ and their Derivatives $\\partial_{\\lambda}\\Gamma^{\\rho}{}_{\\mu\\nu}$**: The Christoffel symbols of the second kind are computed using the standard formula for a metric-compatible, torsion-free connection:\n    $$\n    \\Gamma^{\\rho}{}_{\\mu\\nu} = \\frac{1}{2} g^{\\rho\\sigma} \\left( \\partial_{\\mu} g_{\\sigma\\nu} + \\partial_{\\nu} g_{\\sigma\\mu} - \\partial_{\\sigma} g_{\\mu\\nu} \\right)\n    $$\n    The derivatives of the Christoffel symbols, $\\partial_{\\lambda}\\Gamma^{\\rho}{}_{\\mu\\nu}$, are found by applying the product rule to the above expression:\n    $$\n    \\partial_{\\lambda} \\Gamma^{\\rho}{}_{\\mu\\nu} = \\frac{1}{2} (\\partial_{\\lambda} g^{\\rho\\sigma}) \\left( \\dots \\right) + \\frac{1}{2} g^{\\rho\\sigma} \\left( \\partial_{\\lambda}\\partial_{\\mu} g_{\\sigma\\nu} + \\partial_{\\lambda}\\partial_{\\nu} g_{\\sigma\\mu} - \\partial_{\\lambda}\\partial_{\\sigma} g_{\\mu\\nu} \\right)\n    $$\n    These computations rely on the metric derivatives calculated in step 1 and the inverse metric derivatives from step 3. All tensor contractions are performed using `numpy.einsum` for efficiency and clarity.\n\n5.  **Ricci Tensor $R_{\\mu\\nu}$**: The Ricci tensor is assembled from the Christoffel symbols and their derivatives according to its definition:\n    $$\n    R_{\\mu\\nu} = \\partial_{\\alpha} \\Gamma^{\\alpha}{}_{\\mu\\nu} - \\partial_{\\nu} \\Gamma^{\\alpha}{}_{\\mu\\alpha} + \\Gamma^{\\alpha}{}_{\\alpha\\beta} \\Gamma^{\\beta}{}_{\\mu\\nu} - \\Gamma^{\\alpha}{}_{\\mu\\beta} \\Gamma^{\\beta}{}_{\\alpha\\nu}\n    $$\n    Each term involves contractions over one or two indices, which are again implemented with `numpy.einsum` or explicit loops for clarity where `einsum` notation becomes ambiguous.\n\n6.  **Vacuum Check**: The computed Ricci tensor $R_{\\mu\\nu}$ is used to verify if the spacetime is a vacuum solution at the specified point. All given spacetimes (Minkowski, Schwarzschild outside the mass, and the pp-wave) are exact vacuum solutions, meaning their Ricci tensor should be identically zero, $R_{\\mu\\nu}=0$. Due to floating-point arithmetic, the computed components will be close to, but not exactly, zero. The vacuum condition is therefore checked numerically: $\\mathrm{vacuum\\_ok} = \\left( \\max_{\\mu,\\nu} |R_{\\mu\\nu}|  \\varepsilon \\right)$, where the threshold is given as $\\varepsilon = 10^{-9}$.\n\nBy implementing these steps for each test case specified in the problem, we generate the required sequence of results: the squared line element $ds^2$ and the boolean vacuum check status for each test. The results are then aggregated into a single list and formatted as required.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# language: Python\n# version: 3.12\n# libraries:\n#   - name: numpy\n#     version: 1.23.5\n#   - name: scipy\n#     version: 1.11.4\n\nclass TensorAnalysis:\n    \"\"\"\n    Performs tensor calculus computations given a metric and its derivatives.\n    \"\"\"\n    def __init__(self, g, dg, ddg):\n        self.dim = g.shape[0]\n        self.g = g          # g_mn\n        self.dg = dg        # d_l g_mn\n        self.ddg = ddg      # d_k d_l g_mn\n\n        # Pre-compute all derived quantities\n        self.g_inv = np.linalg.inv(self.g) # g^rs\n        self.dg_inv = self._compute_dg_inv() # d_l g^mn\n        self.gamma = self._compute_gamma() # Gamma^r_mn\n        self.dgamma = self._compute_dgamma() # d_l Gamma^r_mn\n        self.ricci = self._compute_ricci() # R_mn\n\n    def _compute_dg_inv(self):\n        # d_l g^mn = -g^ma (d_l g_ab) g^bn\n        return -np.einsum('ma,lab,bn-lmn', self.g_inv, self.dg, self.g_inv)\n\n    def _compute_gamma(self):\n        # Gamma^r_mn = 1/2 g^rs (d_m g_sn + d_n g_sm - d_s g_mn)\n        christoffel_part_lower = self.dg.transpose(1, 2, 0) + self.dg.transpose(2, 1, 0) - self.dg\n        # The above is a compact way of writing:\n        # christoffel_part_lower[s,m,n] = dg[m,s,n] + dg[n,s,m] - dg[s,m,n]\n        return 0.5 * np.einsum('rs,smn-rmn', self.g_inv, christoffel_part_lower)\n\n    def _compute_dgamma(self):\n        # d_l Gamma^r_mn = 1/2 (d_l g^rs)(...) + 1/2 g^rs (d_l d_m g_sn + ...)\n        christoffel_part_lower = self.dg.transpose(1, 2, 0) + self.dg.transpose(2, 1, 0) - self.dg\n        term1 = 0.5 * np.einsum('lrs,smn-lrmn', self.dg_inv, christoffel_part_lower)\n\n        christoffel_deriv_part_lower = self.ddg.transpose(0, 2, 1, 3) + self.ddg.transpose(0, 3, 1, 2) - self.ddg.transpose(0, 2, 3, 1)        \n        # Above is equivalent to:\n        # cdpl[l,s,m,n] = ddg[l,m,s,n] + ddg[l,n,s,m] - ddg[l,s,m,n]\n        term2 = 0.5 * np.einsum('rs,lsmn-lrmn', self.g_inv, christoffel_deriv_part_lower)\n        \n        return term1 + term2\n\n    def _compute_ricci(self):\n        # R_mn = d_a G^a_mn - d_n G^a_ma + G^a_ab G^b_mn - G^a_mb G^b_an\n        term1 = np.einsum('aamn-mn', self.dgamma)\n        \n        # term2 = d_n G^a_ma. Loop is clearer than tricky einsum.\n        term2 = np.zeros((self.dim, self.dim))\n        for m in range(self.dim):\n            for n in range(self.dim):\n                for a in range(self.dim):\n                    term2[m, n] += self.dgamma[n, a, m, a]\n\n        term3 = np.einsum('aab,bmn-mn', self.gamma, self.gamma)\n        term4 = np.einsum('amb,ban-mn', self.gamma, self.gamma)\n        return term1 - term2 + term3 - term4\n\n    def compute_ds2(self, dx):\n        # ds^2 = g_mn dx^m dx^n\n        return np.einsum('ij,i,j-', self.g, dx, dx)\n\n    def get_ricci_tensor(self):\n        return self.ricci\n\nclass AnalyticMetric:\n    def __init__(self, dim=4, **kwargs):\n        self.dim = dim\n\n    def get_derivatives(self, coords):\n        raise NotImplementedError\n\nclass MinkowskiMetric(AnalyticMetric):\n    def get_derivatives(self, coords):\n        g = np.diag([-1.0, 1.0, 1.0, 1.0])\n        dg = np.zeros((self.dim, self.dim, self.dim))\n        ddg = np.zeros((self.dim, self.dim, self.dim, self.dim))\n        return g, dg, ddg\n\nclass SchwarzschildMetric(AnalyticMetric):\n    def __init__(self, M, dim=4):\n        super().__init__(dim)\n        self.M = M\n\n    def get_derivatives(self, coords):\n        _t, r, th, _p = coords\n        M = self.M\n        g = np.zeros((self.dim, self.dim))\n        dg = np.zeros((self.dim, self.dim, self.dim))\n        ddg = np.zeros((self.dim, self.dim, self.dim, self.dim))\n\n        f = 1.0 - 2.0 * M / r\n        sin_th = np.sin(th)\n        cos_th = np.cos(th)\n        sin_2th = np.sin(2.0 * th)\n        cos_2th = np.cos(2.0 * th)\n\n        # Metric components (non-zero)\n        g[0, 0] = -f\n        g[1, 1] = 1.0 / f\n        g[2, 2] = r**2\n        g[3, 3] = r**2 * sin_th**2\n\n        # First derivatives (only w.r.t r=1 and th=2 are non-zero)\n        # partial_r\n        df_dr = 2.0 * M / r**2\n        gtt_r = -df_dr\n        grr_r = -1.0 / f**2 * df_dr\n        dg[1, 0, 0] = gtt_r\n        dg[1, 1, 1] = grr_r\n        dg[1, 2, 2] = 2.0 * r\n        dg[1, 3, 3] = 2.0 * r * sin_th**2\n        # partial_theta\n        gpp_th = r**2 * sin_2th\n        dg[2, 3, 3] = gpp_th\n\n        # Second derivatives\n        # partial_r partial_r\n        d2f_dr2 = -4.0 * M / r**3\n        gtt_rr = -d2f_dr2\n        grr_rr = (2.0 / f**3) * df_dr**2 - (1.0 / f**2) * d2f_dr2\n        ddg[1, 1, 0, 0] = gtt_rr\n        ddg[1, 1, 1, 1] = grr_rr\n        ddg[1, 1, 2, 2] = 2.0\n        ddg[1, 1, 3, 3] = 2.0 * sin_th**2\n        # partial_th partial_th\n        gpp_thth = r**2 * 2.0 * cos_2th\n        ddg[2, 2, 3, 3] = gpp_thth\n        # partial_r partial_th (mixed)\n        gpp_rth = 2.0 * r * sin_2th\n        ddg[1, 2, 3, 3] = gpp_rth\n        ddg[2, 1, 3, 3] = gpp_rth\n        \n        return g, dg, ddg\n\nclass PPWaveMetric(AnalyticMetric):\n    def get_derivatives(self, coords):\n        u, _v, x, y = coords\n        g = np.zeros((self.dim, self.dim))\n        dg = np.zeros((self.dim, self.dim, self.dim))\n        ddg = np.zeros((self.dim, self.dim, self.dim, self.dim))\n\n        sin_u = np.sin(u)\n        cos_u = np.cos(u)\n        \n        H = sin_u * (x**2 - y**2)\n        \n        # Metric components\n        g[0, 0] = H\n        g[0, 1] = g[1, 0] = -1.0\n        g[2, 2] = 1.0\n        g[3, 3] = 1.0\n\n        # First derivatives (only g_00 depends on coords)\n        dg[0, 0, 0] = cos_u * (x**2 - y**2) # d_u g_uu\n        dg[2, 0, 0] = sin_u * (2.0 * x)     # d_x g_uu\n        dg[3, 0, 0] = sin_u * (-2.0 * y)    # d_y g_uu\n\n        # Second derivatives\n        ddg[0, 0, 0, 0] = -sin_u * (x**2 - y**2) # d_u d_u g_uu\n        ddg[2, 2, 0, 0] = sin_u * 2.0             # d_x d_x g_uu\n        ddg[3, 3, 0, 0] = sin_u * -2.0            # d_y d_y g_uu\n        \n        # Mixed derivatives\n        ddg[0, 2, 0, 0] = ddg[2, 0, 0, 0] = cos_u * (2.0 * x)     # d_u d_x g_uu\n        ddg[0, 3, 0, 0] = ddg[3, 0, 0, 0] = cos_u * (-2.0 * y)    # d_u d_y g_uu\n        # d_x d_y g_uu is zero\n\n        return g, dg, ddg\n\ndef solve():\n    test_cases = [\n        {\n            'name': 'A',\n            'metric_class': MinkowskiMetric,\n            'params': {},\n            'coords': np.array([0.0, 1.0, 2.0, 3.0]),\n            'dx': np.array([1.0, 0.5, 0.0, 0.0]),\n        },\n        {\n            'name': 'B',\n            'metric_class': SchwarzschildMetric,\n            'params': {'M': 1.0},\n            'coords': np.array([0.0, 10.0, np.pi/2, 0.0]),\n            'dx': np.array([1.0, 0.0, 0.0, 0.0]),\n        },\n        {\n            'name': 'C',\n            'metric_class': SchwarzschildMetric,\n            'params': {'M': 1.0},\n            'coords': np.array([0.0, 2.1, np.pi/2, 0.0]),\n            'dx': np.array([1.0, 0.0, 0.0, 0.0]),\n        },\n        {\n            'name': 'D',\n            'metric_class': PPWaveMetric,\n            'params': {},\n            'coords': np.array([0.3, 0.0, 1.0, 1.0]),\n            'dx': np.array([1.0, 0.0, 0.5, -0.5]),\n        },\n        {\n            'name': 'E',\n            'metric_class': PPWaveMetric,\n            'params': {},\n            'coords': np.array([1.0, 0.0, 2.0, 1.0]),\n            'dx': np.array([1.0, 0.0, 0.0, 0.0]),\n        },\n    ]\n\n    results = []\n    vacuum_threshold = 1e-9\n\n    for case in test_cases:\n        metric_instance = case['metric_class'](**case['params'])\n        g, dg, ddg = metric_instance.get_derivatives(case['coords'])\n        \n        analysis = TensorAnalysis(g, dg, ddg)\n        \n        ds2 = analysis.compute_ds2(case['dx'])\n        ricci = analysis.get_ricci_tensor()\n        \n        max_abs_ricci = np.max(np.abs(ricci))\n        vacuum_ok = max_abs_ricci  vacuum_threshold\n        \n        results.append(ds2)\n        results.append(vacuum_ok)\n    \n    # Format boolean as lowercase 'true'/'false' for consistency, then join.\n    formatted_results = [str(r).lower() if isinstance(r, bool) else str(r) for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\n\nsolve()\n\n```", "id": "3493362"}]}