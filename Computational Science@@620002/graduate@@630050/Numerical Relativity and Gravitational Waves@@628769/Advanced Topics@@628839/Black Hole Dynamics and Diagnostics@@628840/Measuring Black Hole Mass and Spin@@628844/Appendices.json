{"hands_on_practices": [{"introduction": "In numerical relativity simulations, we often have direct access to the geometry of a black hole's event horizon. The fundamental properties of a Kerr black hole, its mass $M$ and angular momentum $J$, are uniquely determined by its horizon area $A$ and one other spin-related quantity. This exercise guides you through the derivation of the Christodoulou mass formula, which provides the theoretical backbone for this connection, and its application in a practical algorithm [@problem_id:3479534]. Mastering this practice provides the essential skill of translating direct geometric measurements from a simulation into the core physical parameters of the black hole.", "problem": "You are given a framework to infer the mass and spin of a Kerr black hole from horizon quantities measured in a Numerical Relativity (NR) simulation. Your task is twofold: first, derive the mass–spin–area relation for a Kerr black hole starting from fundamental and well-tested properties of Kerr geometry; second, implement an algorithm that computes the total mass and angular momentum from either a horizon area with an angular momentum measurement or a horizon area with a dimensionless spin measurement.\n\nDerivation task:\n- Starting from the following foundational facts of Kerr black hole geometry in geometric units (where $G=c=1$):\n  - The Kerr black hole has outer horizon radius $r_{+} = M + \\sqrt{M^{2} - a^{2}}$, where $M$ is the total mass and $a = J/M$ is the spin parameter, with $J$ the angular momentum.\n  - The horizon area is $A = 4\\pi (r_{+}^{2} + a^{2}) = 8\\pi M r_{+}$.\n  - The irreducible mass is defined by $M_{\\mathrm{irr}} = \\sqrt{A/(16\\pi)}$.\n  - The dimensionless spin is $\\chi = J/M^{2}$, with $0 \\le \\chi \\le 1$ for a sub-extremal Kerr black hole.\n- Derive, from the above base definitions and relations, the Christodoulou mass formula that relates $M$, $M_{\\mathrm{irr}}$, and $J$ without introducing any new assumptions. Your derivation must proceed step-by-step from the listed base facts and culminate in a relation between $M^{2}$, $M_{\\mathrm{irr}}^{2}$, and $J^{2}$.\n\nAlgorithm design task:\n- Design an algorithm that, given a measured horizon area $A$ and either:\n  - A measured angular momentum magnitude $J$, or\n  - A measured dimensionless spin $\\chi$,\n  computes the total mass $M$ and angular momentum $J$ self-consistently for a Kerr black hole.\n- Use geometric units ($G=c=1$). Express $M$ in units of length and $J$ in units of length squared.\n- Your algorithm must:\n  1. Compute $M_{\\mathrm{irr}}$ from $A$ via $M_{\\mathrm{irr}} = \\sqrt{A/(16\\pi)}$.\n  2. If $J$ is provided, compute $M$ directly from the derived mass–spin–area relation.\n  3. If $\\chi$ is provided, compute $M$ using a numerically stable expression valid for all $0 \\le \\chi \\le 1$, including the boundary case $\\chi=0$; then compute $J$ from $\\chi$ and $M$.\n  4. Handle the boundary cases $J=0$ and $\\chi=0$ consistently with Kerr geometry.\n  5. Return floating-point outputs for $M$ and $J$, rounded to $10$ decimal places.\n\nInput and test suite:\n- Implement your solution as a self-contained program that uses the following test suite, where each test case consists of a horizon area and a spin measurement type:\n  1. Case $1$ (happy path, direct angular momentum): $A = 5026.548245743669$, measurement type $J$, value $J = 20.0$.\n  2. Case $2$ (moderate dimensionless spin): $A = 7238.229473870883$, measurement type $\\chi$, value $\\chi = 0.7$.\n  3. Case $3$ (boundary case $\\chi=0$): $A = 1256.6370614359173$, measurement type $\\chi$, value $\\chi = 0.0$.\n  4. Case $4$ (near-extremal dimensionless spin): $A = 452.3893421169302$, measurement type $\\chi$, value $\\chi = 0.999$.\n- All areas are in geometric units and correspond to $A = 16\\pi M_{\\mathrm{irr}}^{2}$ for $M_{\\mathrm{irr}}$ equal to $10$, $12$, $5$, and $3$ respectively, ensuring scientific consistency of the test cases.\n\nOutput specification:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets.\n- The list must be flattened in the order $[M_{1},J_{1},M_{2},J_{2},M_{3},J_{3},M_{4},J_{4}]$, where $M_{k}$ and $J_{k}$ are the computed values for test case $k$, each rounded to $10$ decimal places.", "solution": "The problem is valid as it is scientifically grounded in the principles of general relativity, specifically the Kerr metric, and is well-posed, providing a complete and consistent set of information for both the derivation and the algorithmic tasks.\n\nThe solution proceeds in two parts as requested. First, a step-by-step derivation of the Christodoulou mass formula from the provided fundamental relations. Second, the design and implementation of an algorithm to compute a Kerr black hole's mass $M$ and angular momentum $J$ from its horizon area $A$ and a spin measurement. All calculations are performed in geometric units where $G=c=1$.\n\n**Part 1: Derivation of the Christodoulou Mass Formula**\n\nThe objective is to derive a formula relating the total mass $M$, the irreducible mass $M_{\\mathrm{irr}}$, and the angular momentum $J$ of a Kerr black hole. The derivation commences from the following established relations:\n1. The irreducible mass definition: $M_{\\mathrm{irr}} = \\sqrt{A/(16\\pi)}$, which implies the horizon area is $A = 16\\pi M_{\\mathrm{irr}}^{2}$.\n2. An alternative expression for the horizon area: $A = 8\\pi M r_{+}$, where $r_{+}$ is the outer horizon radius.\n3. The outer horizon radius: $r_{+} = M + \\sqrt{M^{2} - a^{2}}$.\n4. The spin parameter: $a = J/M$.\n\nThe derivation proceeds as follows:\n\nFirst, we equate the two expressions for the horizon area $A$ given in relations (1) and (2):\n$$16\\pi M_{\\mathrm{irr}}^{2} = 8\\pi M r_{+}$$\nDividing both sides by $8\\pi$ yields a direct relation between the irreducible mass, total mass, and horizon radius:\n$$2 M_{\\mathrm{irr}}^{2} = M r_{+}$$\n\nNext, we substitute the expression for $r_{+}$ from relation (3) into the equation above:\n$$2 M_{\\mathrm{irr}}^{2} = M (M + \\sqrt{M^{2} - a^{2}})$$\nExpanding the right-hand side gives:\n$$2 M_{\\mathrm{irr}}^{2} = M^{2} + M \\sqrt{M^{2} - a^{2}}$$\n\nTo eliminate the square root, we first isolate the term containing it:\n$$M \\sqrt{M^{2} - a^{2}} = 2 M_{\\mathrm{irr}}^{2} - M^{2}$$\nNow, we square both sides of the equation:\n$$(M \\sqrt{M^{2} - a^{2}})^{2} = (2 M_{\\mathrm{irr}}^{2} - M^{2})^{2}$$\nThis leads to:\n$$M^{2} (M^{2} - a^{2}) = (2 M_{\\mathrm{irr}}^{2})^{2} - 2(2 M_{\\mathrm{irr}}^{2})(M^{2}) + (M^{2})^{2}$$\n$$M^{4} - M^{2} a^{2} = 4 M_{\\mathrm{irr}}^{4} - 4 M_{\\mathrm{irr}}^{2} M^{2} + M^{4}$$\n\nThe $M^{4}$ terms on both sides cancel, simplifying the equation to:\n$$-M^{2} a^{2} = 4 M_{\\mathrm{irr}}^{4} - 4 M_{\\mathrm{irr}}^{2} M^{2}$$\n\nWe now substitute the definition of the spin parameter $a = J/M$ from relation (4):\n$$-M^{2} \\left(\\frac{J}{M}\\right)^{2} = 4 M_{\\mathrm{irr}}^{4} - 4 M_{\\mathrm{irr}}^{2} M^{2}$$\n$$-M^{2} \\left(\\frac{J^{2}}{M^{2}}\\right) = 4 M_{\\mathrm{irr}}^{4} - 4 M_{\\mathrm{irr}}^{2} M^{2}$$\n$$-J^{2} = 4 M_{\\mathrm{irr}}^{4} - 4 M_{\\mathrm{irr}}^{2} M^{2}$$\n\nFinally, we rearrange this equation to express $M^{2}$ in terms of $M_{\\mathrm{irr}}^{2}$ and $J^{2}$. This is the Christodoulou mass formula:\n$$4 M_{\\mathrm{irr}}^{2} M^{2} = 4 M_{\\mathrm{irr}}^{4} + J^{2}$$\n$$M^{2} = M_{\\mathrm{irr}}^{2} + \\frac{J^{2}}{4 M_{\\mathrm{irr}}^{2}}$$\nThis formula elegantly decomposes the squared total mass-energy of a rotating black hole into a contribution from its irreducible mass (related to its surface area) and a contribution from its rotational energy (related to its angular momentum).\n\n**Part 2: Algorithm Design**\n\nThe algorithm computes the total mass $M$ and angular momentum $J$ from a given horizon area $A$ and either a direct measurement of $J$ or a measurement of the dimensionless spin $\\chi = J/M^{2}$.\n\nThe first step, common to all cases, is to compute the irreducible mass $M_{\\mathrm{irr}}$ from the horizon area $A$:\n$$M_{\\mathrm{irr}} = \\sqrt{\\frac{A}{16\\pi}}$$\n\nThe subsequent steps depend on the type of spin measurement provided.\n\n**Case 1: Given horizon area $A$ and angular momentum $J$.**\nWith $M_{\\mathrm{irr}}$ computed from $A$ and $J$ given directly, we can use the derived Christodoulou mass formula to solve for $M$:\n$$M = \\sqrt{M_{\\mathrm{irr}}^{2} + \\frac{J^{2}}{4 M_{\\mathrm{irr}}^{2}}}$$\nThis expression is valid for all non-negative $J$. If $J=0$ (the Schwarzschild case), the formula correctly simplifies to $M = \\sqrt{M_{\\mathrm{irr}}^{2}} = M_{\\mathrm{irr}}$. The computed mass $M$ and the given angular momentum $J$ are the outputs.\n\n**Case 2: Given horizon area $A$ and dimensionless spin $\\chi$.**\nIn this case, we have $M_{\\mathrm{irr}}$ from $A$ and the dimensionless spin $\\chi$. The angular momentum is related to $M$ and $\\chi$ by $J = \\chi M^{2}$. We substitute this into the Christodoulou formula:\n$$M^{2} = M_{\\mathrm{irr}}^{2} + \\frac{(\\chi M^{2})^{2}}{4 M_{\\mathrm{irr}}^{2}} = M_{\\mathrm{irr}}^{2} + \\frac{\\chi^{2} M^{4}}{4 M_{\\mathrm{irr}}^{2}}$$\nRearranging this yields a quadratic equation for $M^{2}$:\n$$\\left(\\frac{\\chi^{2}}{4 M_{\\mathrm{irr}}^{2}}\\right)M^{4} - M^{2} + M_{\\mathrm{irr}}^{2} = 0$$\nSolving this quadratic equation for $M^{2}$ gives two potential solutions. The physically correct solution is the one that recovers the Schwarzschild limit ($M \\to M_{\\mathrm{irr}}$) as $\\chi \\to 0$:\n$$M^{2} = 2 M_{\\mathrm{irr}}^{2} \\frac{1 - \\sqrt{1 - \\chi^{2}}}{\\chi^{2}}$$\nHowever, this expression suffers from numerical instability due to catastrophic cancellation when $\\chi$ is small. To create a numerically robust algorithm, we rationalize the numerator:\n$$\\frac{1 - \\sqrt{1 - \\chi^{2}}}{\\chi^{2}} \\times \\frac{1 + \\sqrt{1 - \\chi^{2}}}{1 + \\sqrt{1 - \\chi^{2}}} = \\frac{1 - (1 - \\chi^{2})}{\\chi^{2}(1 + \\sqrt{1 - \\chi^{2}})} = \\frac{1}{1 + \\sqrt{1 - \\chi^{2}}}$$\nThis leads to the numerically stable expression for $M^{2}$:\n$$M^{2} = \\frac{2 M_{\\mathrm{irr}}^{2}}{1 + \\sqrt{1 - \\chi^{2}}}$$\nFrom which we compute the total mass $M$:\n$$M = M_{\\mathrm{irr}} \\sqrt{\\frac{2}{1 + \\sqrt{1 - \\chi^{2}}}}$$\nThis formula is well-behaved for the entire valid range $0 \\le \\chi \\le 1$, including the boundary cases $\\chi=0$ (Schwarzschild) and $\\chi=1$ (extremal Kerr).\n\nOnce $M$ is computed, the angular momentum $J$ is found using its definition in terms of $\\chi$:\n$$J = \\chi M^{2}$$\nThe computed values of $M$ and $J$ are the outputs. The final implementation will round these results to $10$ decimal places as required.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the mass and spin of a Kerr black hole from horizon quantities.\n    \n    This function processes a series of test cases, each providing a horizon area\n    and a spin measurement (either angular momentum J or dimensionless spin chi).\n    It calculates the total mass M and angular momentum J for each case based on\n    the Christodoulou mass formula and prints the aggregated results.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a dictionary specifying the area 'A', the measurement type 'type',\n    # and the measured 'value'.\n    test_cases = [\n        {'A': 5026.548245743669, 'type': 'J', 'value': 20.0},\n        {'A': 7238.229473870883, 'type': 'chi', 'value': 0.7},\n        {'A': 1256.6370614359173, 'type': 'chi', 'value': 0.0},\n        {'A': 452.3893421169302, 'type': 'chi', 'value': 0.999},\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        A = case['A']\n        measurement_type = case['type']\n        value = case['value']\n\n        # Step 1: Compute the irreducible mass from the area A.\n        # The irreducible mass is defined by A = 16 * pi * M_irr^2.\n        M_irr = np.sqrt(A / (16.0 * np.pi))\n\n        M = 0.0\n        J = 0.0\n\n        if measurement_type == 'J':\n            # Case where angular momentum J is given directly.\n            J_val = value\n            \n            # Use the Christodoulou mass formula to find M:\n            # M^2 = M_irr^2 + J^2 / (4 * M_irr^2)\n            # This handles the J=0 case correctly, where M = M_irr.\n            if M_irr == 0:\n                # This case represents a singular state, but for completeness,\n                # if J is also 0, M would be 0. If J > 0, it is unphysical.\n                # Problem constraints ensure M_irr > 0.\n                M = 0.0 if J_val == 0.0 else float('inf')\n            else:\n                M = np.sqrt(M_irr**2 + J_val**2 / (4.0 * M_irr**2))\n            \n            J = J_val\n\n        elif measurement_type == 'chi':\n            # Case where dimensionless spin chi is given.\n            chi_val = value\n\n            # A numerically stable expression for M is used, derived from\n            # M^2 = 2 * M_irr^2 / (1 + sqrt(1 - chi^2)).\n            # This avoids catastrophic cancellation for small chi.\n            # It is well-defined for all 0 <= chi <= 1.\n            radicand = 1.0 - chi_val**2\n            # Handle potential floating point inaccuracies for chi=1\n            if radicand < 0: radicand = 0\n            \n            M = M_irr * np.sqrt(2.0 / (1.0 + np.sqrt(radicand)))\n            \n            # Compute J from the definition chi = J / M^2.\n            J = chi_val * M**2\n\n        # Round results to 10 decimal places as specified.\n        M_rounded = round(M, 10)\n        J_rounded = round(J, 10)\n        \n        results.extend([M_rounded, J_rounded])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3479534"}, {"introduction": "After two black holes merge, the new, distorted black hole settles into its final state by emitting a characteristic \"ringdown\" of gravitational waves, which carry the unique fingerprint of the final object's mass and spin. This practice explores the well-established relationship between the frequency and damping time of these quasinormal modes (QNMs) and the final black hole's parameters. By implementing an inference algorithm, you will learn a primary technique used in gravitational-wave astronomy to measure remnant black hole properties and investigate systematic errors that arise from different waveform extraction methods in simulations [@problem_id:3479619].", "problem": "You are given two sets of ringdown measurements for black hole mergers from Numerical Relativity (NR) simulations: one obtained via Cauchy Characteristic Extraction (CCE) and another obtained by polynomial extrapolation in $1/r$ from finite-radius extractions. The goal is to infer the remnant (final) black hole mass $M_f$ and dimensionless spin $\\chi_f$ from the dominant $l=m=2$, $n=0$ quasinormal mode ringdown and to isolate the systematic bias introduced by near-zone contamination that affects finite-radius extrapolated waveforms relative to CCE. You must implement an inference algorithm that uses well-tested relations from black hole perturbation theory and then apply it consistently to both CCE and finite-radius extrapolated measurements.\n\nFundamental base for inference:\n- In the linear ringdown regime of a Kerr black hole, the complex quasinormal mode frequency scales as $\\omega \\propto 1/M_f$, with the proportionality set by dimensionless functions of the spin $\\chi_f$. The observed ringdown frequency $f$ and damping time $\\tau$ define the quality factor $Q$ via $Q = \\omega_R \\tau / 2 = \\pi f \\tau$, where $\\omega_R = 2\\pi f$ is the real part of the angular frequency. The gravitational-wave measurements are assumed to have $f$ in Hertz and $\\tau$ in seconds.\n- The dominant mode’s dimensionless frequency and quality factor are well-approximated by widely used, literature-validated empirical fits (established facts), which relate the dimensionless quantities to the spin $\\chi_f$. These fits, together with the scale invariance $\\omega \\sim \\hat{\\omega}(\\chi_f) / M_f$, allow one to infer $\\chi_f$ from $Q$ and then infer $M_f$ from $f$ and $\\chi_f$. Physical unit conversion uses $M = G M_f / c^3$ for the mass in time units, where $G$ is the gravitational constant and $c$ is the speed of light.\n\nYour tasks:\n1. For each test case below, compute:\n   - From CCE: infer $M_f$ (expressed in solar masses $M_\\odot$) and $\\chi_f$ from the measured $(f_{\\mathrm{CCE}}, \\tau_{\\mathrm{CCE}})$.\n   - From finite-radius extrapolated waveforms: infer $M_f$ (in $M_\\odot$) and $\\chi_f$ from the measured $(f_{\\mathrm{EXT}}, \\tau_{\\mathrm{EXT}})$.\n2. Isolate near-zone contamination systematics by reporting, for each test case, the pair\n   - $\\Delta M = M_{f,\\mathrm{EXT}} - M_{f,\\mathrm{CCE}}$ in $M_\\odot$,\n   - $\\Delta \\chi = \\chi_{f,\\mathrm{EXT}} - \\chi_{f,\\mathrm{CCE}}$ (dimensionless).\n3. Do not use any external data files or inputs. Hard-code the test suite values below. Express mass differences in solar masses and spin differences as dimensionless decimals. Angles do not appear in this problem. All outputs must be pure numbers without units embedded in the output.\n\nTest suite (each case provides the ground-truth reference $(M_f^{\\mathrm{true}}, \\chi_f^{\\mathrm{true}})$ for context, the CCE measurements $(f_{\\mathrm{CCE}}, \\tau_{\\mathrm{CCE}})$, and the finite-radius extrapolated measurements $(f_{\\mathrm{EXT}}, \\tau_{\\mathrm{EXT}})$):\n- Case A (general): $(M_f^{\\mathrm{true}}, \\chi_f^{\\mathrm{true}}) = (60, 0.7)$, CCE: $f_{\\mathrm{CCE}} = 288.2$ Hz, $\\tau_{\\mathrm{CCE}} = 0.003630$ s; Extrapolated: $f_{\\mathrm{EXT}} = 289.64$ Hz, $\\tau_{\\mathrm{EXT}} = 0.003594$ s.\n- Case B (near-extremal spin): $(M_f^{\\mathrm{true}}, \\chi_f^{\\mathrm{true}}) = (50, 0.98)$, CCE: $f_{\\mathrm{CCE}} = 534.6$ Hz, $\\tau_{\\mathrm{CCE}} = 0.006360$ s; Extrapolated: $f_{\\mathrm{EXT}} = 532.46$ Hz, $\\tau_{\\mathrm{EXT}} = 0.006454$ s.\n- Case C (low spin): $(M_f^{\\mathrm{true}}, \\chi_f^{\\mathrm{true}}) = (30, 0.1)$, CCE: $f_{\\mathrm{CCE}} = 413.9$ Hz, $\\tau_{\\mathrm{CCE}} = 0.001689$ s; Extrapolated: $f_{\\mathrm{EXT}} = 417.21$ Hz, $\\tau_{\\mathrm{EXT}} = 0.001681$ s.\n- Case D (very large mass): $(M_f^{\\mathrm{true}}, \\chi_f^{\\mathrm{true}}) = (200, 0.8)$, CCE: $f_{\\mathrm{CCE}} = 94.70$ Hz, $\\tau_{\\mathrm{CCE}} = 0.01300$ s; Extrapolated: $f_{\\mathrm{EXT}} = 96.59$ Hz, $\\tau_{\\mathrm{EXT}} = 0.01339$ s.\n- Case E (no contamination control): $(M_f^{\\mathrm{true}}, \\chi_f^{\\mathrm{true}}) = (70, 0.5)$, CCE: $f_{\\mathrm{CCE}} = 215.6$ Hz, $\\tau_{\\mathrm{CCE}} = 0.003987$ s; Extrapolated: $f_{\\mathrm{EXT}} = 215.6$ Hz, $\\tau_{\\mathrm{EXT}} = 0.003987$ s.\n\nRequired final output format:\n- Your program should produce a single line of output containing the results as a list of lists, one inner list per test case, in the order A, B, C, D, E. Each inner list must be $[\\Delta M,\\Delta \\chi]$ with $\\Delta M$ in $M_\\odot$ and $\\Delta \\chi$ dimensionless. For example: $[[\\Delta M_A,\\Delta \\chi_A],[\\Delta M_B,\\Delta \\chi_B],\\ldots]$.\n- Your program must print exactly one line, containing only this list. Use decimal notation (no percentage signs).\n\nScientific realism: The empirical relations for the dominant quasinormal mode are known, well-tested, and scale with total mass as required by the properties of Kerr perturbations. The measurements provided are consistent with these relations within realistic rounding. The comparison between CCE and finite-radius extrapolated measurements isolates near-zone contamination as a systematic source of bias, in line with practice in Numerical Relativity and Gravitational Wave data analysis.\n\nAngle unit: Not applicable. All outputs are scalars; when a unit applies, it is explicitly specified above.\n\nExpress all mass differences in $M_\\odot$ and all spin differences as dimensionless decimal fractions.", "solution": "The problem as stated is valid. It is scientifically grounded in the principles of general relativity, specifically the theory of black hole quasinormal modes (QNMs), and is directly relevant to contemporary research in numerical relativity and gravitational-wave astronomy. The problem is well-posed, providing a complete set of measurable quantities ($f$, $\\tau$) from which the desired physical parameters ($M_f$, $\\chi_f$) can be uniquely determined using established theoretical and empirical relations. The internal consistency of the data and the physical realism of the scenario are sound. The task is to implement a standard inference algorithm, which requires identifying and applying widely accepted empirical formulas for QNM properties. This is a reasonable expectation for a problem in this field.\n\nThe solution proceeds by first establishing the theoretical framework and then designing an algorithm based on it.\n\n**1. Theoretical Foundation**\n\nThe final stage of a binary black hole merger is the ringdown, where the newly formed, distorted Kerr black hole settles into its final state by radiating gravitational waves. According to the no-hair theorem, a stationary, uncharged, isolated black hole in four-dimensional spacetime is completely described by its mass $M_f$ and its dimensionless spin parameter $\\chi_f = J_f c / (G M_f^2)$, where $J_f$ is its angular momentum.\n\nThe gravitational radiation during ringdown can be decomposed into a superposition of quasinormal modes, each with a characteristic complex angular frequency $\\omega_{\\ell m n} = \\omega_R + i \\omega_I$. The real part, $\\omega_R$, corresponds to the oscillation frequency of the wave, while the imaginary part, $\\omega_I$, determines the exponential damping time. Due to the scale invariance of the Einstein field equations, these frequencies scale inversely with the black hole mass. For a given mode indexed by $(\\ell, m, n)$, the dimensionless frequency $\\hat{\\omega}_{\\ell m n} = M \\omega_{\\ell m n}$ is a function of the spin $\\chi_f$ only, where $M$ is the mass in geometric units ($M = G M_f / c^3$).\n\nThe problem focuses on the dominant mode, which for most merger configurations is the $\\ell=m=2$, $n=0$ mode. The observables are the gravitational-wave frequency $f$ and damping time $\\tau$, which are related to the complex QNM frequency by:\n$$ f = \\frac{\\omega_R}{2\\pi}, \\quad \\tau = -\\frac{1}{\\omega_I} = \\frac{1}{|\\omega_I|} $$\nFrom these, we define the quality factor $Q$:\n$$ Q = \\frac{\\omega_R \\tau}{2} = \\pi f \\tau $$\nLike the dimensionless frequency, the quality factor $Q$ for a given mode is a function only of the spin $\\chi_f$.\n\n**2. Inference Methodology**\n\nThe inference of $M_f$ and $\\chi_f$ relies on accurate, literature-validated empirical formulas that approximate the relationships $\\hat{\\omega}_R(\\chi_f)$ and $Q(\\chi_f)$ for the $(2,2,0)$ mode. We will use the fitting functions provided by Berti, Cardoso, and Will (Phys. Rev. D 73, 064030, 2006), which are standard in the field.\n\nThe fitting function for the quality factor $Q$ is:\n$$ Q(\\chi_f) = q_1 + q_2 (1 - \\chi_f)^{q_3} $$\nwith coefficients $q_1 = 0.7000$, $q_2 = 1.4187$, and $q_3 = -0.4990$.\n\nThe fitting function for the dimensionless real angular frequency $\\hat{\\omega}_R = M \\omega_R$ is:\n$$ \\hat{\\omega}_R(\\chi_f) = f_1 + f_2 (1 - \\chi_f)^{f_3} $$\nwith coefficients $f_1 = 1.5251$, $f_2 = -1.1568$, and $f_3 = 0.1292$.\n\nThe inference algorithm is a two-step process for a given measurement pair $(f, \\tau)$:\n\n**Step A: Infer Spin $\\chi_f$**\nFirst, calculate the measured quality factor $Q_{meas} = \\pi f \\tau$. Then, invert the fitting function $Q(\\chi_f)$ to solve for $\\chi_f$:\n$$ Q_{meas} = q_1 + q_2 (1 - \\chi_f)^{q_3} $$\n$$ \\implies \\chi_f = 1 - \\left( \\frac{Q_{meas} - q_1}{q_2} \\right)^{1/q_3} $$\n\n**Step B: Infer Mass $M_f$**\nWith the inferred spin $\\chi_f$, calculate the corresponding dimensionless angular frequency $\\hat{\\omega}_R(\\chi_f)$ using its fitting function. Then, from the mass-scaling relation $\\omega_R = \\hat{\\omega}_R(\\chi_f)/M$, we solve for the mass in seconds, $M$:\n$$ M[\\mathrm{s}] = \\frac{\\hat{\\omega}_R(\\chi_f)}{\\omega_R} = \\frac{\\hat{\\omega}_R(\\chi_f)}{2\\pi f} $$\nTo convert this mass from seconds to conventional solar mass units ($M_\\odot$), we use the conversion factor $M_{\\odot,\\mathrm{s}} = G M_\\odot / c^3$, where $G$ is the gravitational constant and $c$ is the speed of light.\n$$ M_f[M_\\odot] = \\frac{M[\\mathrm{s}]}{M_{\\odot,\\mathrm{s}}} = \\frac{M[\\mathrm{s}] c^3}{G M_\\odot} $$\n\n**3. Systematic Bias Calculation**\n\nThis procedure is applied independently to the measurements from Cauchy Characteristic Extraction, $(f_{\\mathrm{CCE}}, \\tau_{\\mathrm{CCE}})$, and from finite-radius extrapolation, $(f_{\\mathrm{EXT}}, \\tau_{\\mathrm{EXT}})$, yielding two sets of inferred parameters: $(M_{f,\\mathrm{CCE}}, \\chi_{f,\\mathrm{CCE}})$ and $(M_{f,\\mathrm{EXT}}, \\chi_{f,\\mathrm{EXT}})$. CCE is considered the \"gold standard\" as it provides waveforms at future null infinity, free from near-zone contamination. The finite-radius extrapolation method is susceptible to residual near-zone effects. The systematic bias introduced by these effects is quantified by the differences:\n$$ \\Delta M = M_{f,\\mathrm{EXT}} - M_{f,\\mathrm{CCE}} $$\n$$ \\Delta \\chi = \\chi_{f,\\mathrm{EXT}} - \\chi_{f,\\mathrm{CCE}} $$\n\nThis entire procedure is implemented for each test case provided in the problem statement. For Case E, the CCE and EXT measurements are identical, correctly yielding zero systematic bias, which serves as a consistency check for the implementation.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.constants import G, c\n\ndef solve():\n    \"\"\"\n    Solves for the mass and spin differences between two ringdown measurement methods.\n    \"\"\"\n    # Define physical and conversion constants.\n    # Solar mass in kilograms.\n    M_SOLAR_KG = 1.98847e30\n    # Conversion factor from solar masses to seconds (geometric units).\n    M_SOLAR_IN_SECONDS = (G * M_SOLAR_KG) / (c**3)\n    \n    # Empirical fit parameters for the l=m=2, n=0 quasinormal mode,\n    # from Berti, Cardoso, and Will (2006).\n    # Fit for dimensionless angular frequency: M * omega_R = f1 + f2*(1-chi)^f3\n    F_FIT_PARAMS = {'f1': 1.5251, 'f2': -1.1568, 'f3': 0.1292}\n    # Fit for quality factor: Q = q1 + q2*(1-chi)^q3\n    Q_FIT_PARAMS = {'q1': 0.7000, 'q2': 1.4187, 'q3': -0.4990}\n\n    def infer_remnant_properties(f, tau, q_params, f_params):\n        \"\"\"\n        Infers remnant mass (in M_solar) and spin (dimensionless) from\n        the measured frequency (f) and damping time (tau) of a ringdown signal.\n        \n        Args:\n            f (float): Measured frequency in Hz.\n            tau (float): Measured damping time in seconds.\n            q_params (dict): Parameters for the Q(chi) fit.\n            f_params (dict): Parameters for the omega_R(chi) fit.\n            \n        Returns:\n            tuple: A tuple containing (inferred_mass, inferred_spin).\n        \"\"\"\n        # A frequency or damping time of zero is unphysical and would lead to errors.\n        if f <= 0 or tau <= 0:\n            return (0.0, 0.0)\n            \n        # Step 1: Calculate the measured quality factor Q.\n        q_meas = np.pi * f * tau\n        \n        # Step 2: Invert the Q(chi) relation to find the spin, chi.\n        q1, q2, q3 = q_params['q1'], q_params['q2'], q_params['q3']\n        # The base of the power must be positive, which holds for the given data\n        # as the Q values are within the fit's domain of validity.\n        base = (q_meas - q1) / q2\n        chi = 1.0 - base**(1.0 / q3)\n        \n        # Clamp chi to the physical range [0, 1) for robustness.\n        chi = np.clip(chi, 0.0, 1.0 - 1e-9)\n\n        # Step 3: Use the inferred chi to find the dimensionless frequency.\n        f1, f2, f3 = f_params['f1'], f_params['f2'], f_params['f3']\n        omega_hat_r = f1 + f2 * (1.0 - chi)**f3\n        \n        # Step 4: Use the mass-scaling relation to find the mass in seconds.\n        m_sec = omega_hat_r / (2.0 * np.pi * f)\n        \n        # Step 5: Convert mass from seconds to solar masses.\n        m_solar = m_sec / M_SOLAR_IN_SECONDS\n        \n        return m_solar, chi\n\n    # Test suite data as provided in the problem description.\n    test_cases = [\n        # Case A: CCE(f, tau), Extrapolated(f, tau)\n        {'cce': (288.2, 0.003630), 'ext': (289.64, 0.003594)},\n        # Case B\n        {'cce': (534.6, 0.006360), 'ext': (532.46, 0.006454)},\n        # Case C\n        {'cce': (413.9, 0.001689), 'ext': (417.21, 0.001681)},\n        # Case D\n        {'cce': (94.70, 0.01300), 'ext': (96.59, 0.01339)},\n        # Case E\n        {'cce': (215.6, 0.003987), 'ext': (215.6, 0.003987)},\n    ]\n\n    results = []\n    for case in test_cases:\n        # Infer properties from CCE measurements\n        f_cce, tau_cce = case['cce']\n        m_cce, chi_cce = infer_remnant_properties(f_cce, tau_cce, Q_FIT_PARAMS, F_FIT_PARAMS)\n        \n        # Infer properties from extrapolated measurements\n        f_ext, tau_ext = case['ext']\n        m_ext, chi_ext = infer_remnant_properties(f_ext, tau_ext, Q_FIT_PARAMS, F_FIT_PARAMS)\n\n        # Calculate the systematic differences\n        delta_m = m_ext - m_cce\n        delta_chi = chi_ext - chi_cce\n        \n        results.append([delta_m, delta_chi])\n\n    # Format the final output string as a list of lists.\n    # e.g., [[val1,val2],[val3,val4],...]\n    output_str = f\"[{','.join([f'[{dm},{dc}]' for dm, dc in results])}]\"\n    \n    # Final print statement in the exact required format.\n    print(output_str)\n\nsolve()\n```", "id": "3479619"}, {"introduction": "While ringdown analysis reveals the properties of the final black hole, the long inspiral signal that precedes the merger encodes rich information about the binary components themselves. This exercise introduces the Fisher information matrix, a powerful statistical tool for forecasting how precisely we can measure source parameters, like mass and spin, from a signal buried in detector noise. You will build a simplified Bayesian estimation framework, providing a hands-on introduction to the methods that are central to extracting physics from real gravitational-wave data [@problem_id:3479528].", "problem": "Design and implement a complete program that performs Bayesian parameter estimation in the linear-Gaussian (Laplace) approximation via the Fisher information matrix for a simplified, frequency-domain gravitational-wave signal from a quasi-circular, non-precessing, aligned-spin binary black hole inspiral. The target is to estimate the chirp mass $M_{\\mathrm{c}}$, the symmetric mass ratio $\\eta$, and an effective aligned dimensionless spin $\\chi$ from a single detector with stationary Gaussian noise.\n\nYour implementation must proceed from the following foundational base, which is sufficient and necessary to derive the required algorithm:\n\n1) Frequency-domain inspiral waveform model under the stationary phase approximation (restricted amplitude):\n- The strain model is $h(f) = \\mathcal{A}(f; M_{\\mathrm{c}}, \\eta, \\chi) \\exp\\left(i \\Psi(f; M_{\\mathrm{c}}, \\eta, \\chi)\\right)$ for $f \\in [f_{\\mathrm{low}}, f_{\\mathrm{high}}]$, where the leading-order amplitude scales as\n$$\n|\\mathcal{A}(f; M_{\\mathrm{c}}, \\eta, \\chi)| = \\mathcal{C} \\frac{M_{\\mathrm{c}}^{5/6}}{D_L} f^{-7/6}, \\quad \\mathcal{C} = \\sqrt{\\frac{5}{24}} \\pi^{-2/3}.\n$$\nHere $D_L$ is the luminosity distance and $\\mathcal{C}$ is an orientation-averaged constant.\n- The phase is taken to $1.5$ post-Newtonian order including leading-order spin-orbit coupling, written as\n$$\n\\Psi(f) = \\frac{3}{128 \\, \\eta} v^{-5} \\left[ 1 + \\alpha_2 v^2 + \\alpha_3 v^3 \\right],\n$$\nwhere $v = (\\pi M f)^{1/3}$, $M = M_{\\mathrm{c}} \\eta^{-3/5}$ is the total mass, $\\alpha_2 = \\frac{3715}{756} + \\frac{55}{9} \\eta$, and\n$$\n\\alpha_3 = 4 \\beta - 16 \\pi, \\quad \\beta(\\eta, \\chi) = \\left(\\frac{113}{12} - \\frac{19}{3}\\eta\\right)\\chi.\n$$\nThe coalescence time and phase are taken as known or marginalized out and omitted from the parameter set.\n\n2) Detector noise and inner product:\n- Assume a one-sided power spectral density $S_n(f)$ and define the noise-weighted inner product for any frequency-domain signals $a(f)$ and $b(f)$ by\n$$\n(a|b) = 4 \\int_{f_{\\mathrm{low}}}^{f_{\\mathrm{high}}} \\frac{a(f) b^*(f)}{S_n(f)} \\, df,\n$$\nand the optimal signal-to-noise ratio by $\\rho^2 = (h|h)$ for the true parameters.\n- Use the following simplified but scientifically plausible analytic model for the noise power spectral density:\n$$\nS_n(f) = S_0 \\left[ \\left( \\frac{f_0}{f} \\right)^4 + 1 + \\left( \\frac{f}{f_1} \\right)^2 \\right],\n$$\nwith $S_0 = 10^{-47}\\,\\mathrm{Hz}^{-1}$, $f_0 = 50\\,\\mathrm{Hz}$, and $f_1 = 200\\,\\mathrm{Hz}$.\n\n3) Information geometry and Bayesian linear-Gaussian posterior:\n- For parameters $\\theta = (M_{\\mathrm{c}}, \\eta, \\chi)$, the Fisher information matrix at an injected parameter point is\n$$\n\\Gamma_{ij} = \\left( \\partial_i h \\mid \\partial_j h \\right),\n$$\nwith $\\partial_i = \\partial / \\partial \\theta_i$.\n- In the restricted-amplitude approximation, with $h(f) = A(f) e^{i\\Psi(f)}$, one may use\n$$\n\\partial_i h(f) = h(f)\\left[ \\partial_i \\ln A(f) + i \\,\\partial_i \\Psi(f) \\right],\n$$\nwhich implies\n$$\n\\Gamma_{ij} = 4 \\int_{f_{\\mathrm{low}}}^{f_{\\mathrm{high}}} \\frac{|h(f)|^2}{S_n(f)} \\left[ \\partial_i \\ln A(f) \\,\\partial_j \\ln A(f) + \\partial_i \\Psi(f) \\,\\partial_j \\Psi(f) \\right] df.\n$$\n- Adopt independent Gaussian priors on the parameters with standard deviations $\\sigma_{M_{\\mathrm{c}},\\mathrm{prior}}$, $\\sigma_{\\eta,\\mathrm{prior}}$, and $\\sigma_{\\chi,\\mathrm{prior}}$, which contribute a prior precision matrix $\\Pi = \\mathrm{diag}(\\sigma_{M_{\\mathrm{c}},\\mathrm{prior}}^{-2}, \\sigma_{\\eta,\\mathrm{prior}}^{-2}, \\sigma_{\\chi,\\mathrm{prior}}^{-2})$. Then the linear-Gaussian posterior covariance is\n$$\n\\Sigma = \\left( \\Gamma + \\Pi \\right)^{-1}.\n$$\n\nYour task:\n- Derive from the above base the expressions needed to compute $\\partial_i \\ln A(f)$ and $\\partial_i \\Psi(f)$ for $\\theta_i \\in \\{M_{\\mathrm{c}}, \\eta, \\chi\\}$, implement the Fisher information matrix, incorporate the Gaussian prior, and compute posterior standard deviations $\\sigma_{M_{\\mathrm{c}}}$, $\\sigma_{\\eta}$, $\\sigma_{\\chi}$ from $\\Sigma$ as well as the correlation coefficients between all parameter pairs. Also compute the optimal signal-to-noise ratio $\\rho$.\n- Use geometric units with $G=c=1$ internally so that masses and distances are in seconds and frequencies in $\\mathrm{Hz}$. For unit conversions, use the following physically consistent constants:\n  - Solar mass in time units: $t_\\odot = G M_\\odot / c^3 = 4.92549095 \\times 10^{-6}\\,\\mathrm{s}$.\n  - Megaparsec in time units: $1\\,\\mathrm{Mpc} = 3.085677581491367 \\times 10^{22}\\,\\mathrm{m}$ and $c = 299{,}792{,}458\\,\\mathrm{m/s}$, hence $1\\,\\mathrm{Mpc}/c = 1.029271250 \\times 10^{14}\\,\\mathrm{s}$.\n- Set the upper cutoff frequency to the minimum of a user-provided cap $f_{\\mathrm{cap}}$ and the innermost stable circular orbit frequency for a Schwarzschild black hole,\n$$\nf_{\\mathrm{ISCO}}(M) = \\frac{1}{6^{3/2} \\pi M}.\n$$\n- Priors: use Gaussian priors with standard deviations $\\sigma_{M_{\\mathrm{c}},\\mathrm{prior}} = 50\\,M_\\odot$ (converted to seconds internally), $\\sigma_{\\eta,\\mathrm{prior}} = 0.10$, and $\\sigma_{\\chi,\\mathrm{prior}} = 0.50$.\n\nRequired outputs and units:\n- For each test case, report a list of seven floats in the following order:\n  1) Posterior standard deviation of chirp mass $\\sigma_{M_{\\mathrm{c}}}$ in $M_\\odot$,\n  2) Posterior standard deviation $\\sigma_{\\eta}$ (dimensionless),\n  3) Posterior standard deviation $\\sigma_{\\chi}$ (dimensionless),\n  4) Correlation coefficient $\\mathrm{corr}(M_{\\mathrm{c}},\\eta)$,\n  5) Correlation coefficient $\\mathrm{corr}(M_{\\mathrm{c}},\\chi)$,\n  6) Correlation coefficient $\\mathrm{corr}(\\eta,\\chi)$,\n  7) Optimal signal-to-noise ratio $\\rho$ (dimensionless).\n- Ensure all mass-related outputs are expressed in solar masses as specified and all other outputs are dimensionless.\n\nNumerical implementation details:\n- Perform the frequency integral numerically using a Riemann sum or trapezoidal rule on a sufficiently fine linear grid between $f_{\\mathrm{low}}$ and $f_{\\mathrm{high}}$.\n- Use at least $N=4000$ frequency samples per test case.\n- Ensure numerical stability by adding the prior precision matrix before inversion of the Fisher matrix.\n\nTest suite:\nImplement the program to compute the outputs for the following three test cases. All masses given below are in $M_\\odot$ and distances in $\\mathrm{Mpc}$; the code must convert them internally to seconds as per the unit instructions and then report the required outputs in the specified units.\n- Case 1 (balanced, moderate mass, zero spin):\n  - $M_{\\mathrm{c}} = 26.0$, $\\eta = 0.25$, $\\chi = 0.0$, $D_L = 500.0$, $f_{\\mathrm{low}} = 20\\,\\mathrm{Hz}$, $f_{\\mathrm{cap}} = 512\\,\\mathrm{Hz}$.\n- Case 2 (lower mass, positive spin, higher bandwidth):\n  - $M_{\\mathrm{c}} = 8.7$, $\\eta = 0.25$, $\\chi = 0.6$, $D_L = 400.0$, $f_{\\mathrm{low}} = 20\\,\\mathrm{Hz}$, $f_{\\mathrm{cap}} = 1024\\,\\mathrm{Hz}$.\n- Case 3 (asymmetric mass ratio, negative spin, low SNR):\n  - $M_{\\mathrm{c}} = 15.0$, $\\eta = 0.16$, $\\chi = -0.4$, $D_L = 2000.0$, $f_{\\mathrm{low}} = 20\\,\\mathrm{Hz}$, $f_{\\mathrm{cap}} = 512\\,\\mathrm{Hz}$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated Python-style list of three sublists, one per test case, each sublist containing the seven floats in the specified order. For example, an output structurally similar to\n$$\n\\texttt{[[x\\_11,x\\_12,\\dots,x\\_17],[x\\_21,x\\_22,\\dots,x\\_27],[x\\_31,x\\_32,\\dots,x\\_37]]}\n$$\nmust be printed, where each $x\\_{ij}$ is a float as defined above. No other text should be printed.\n\nExpress the chirp mass uncertainties in $M_\\odot$ as required, and all other quantities as dimensionless numbers. Angles are not used in this problem. Report all numeric values as raw decimal floats (no percentage signs).", "solution": "The user wants to design and implement a program to perform Bayesian parameter estimation for a simplified gravitational wave signal from a binary black hole inspiral. The estimation is to be conducted within the linear-Gaussian (Laplace) approximation, which relies on the Fisher Information Matrix. The parameters to be estimated are the chirp mass $M_{\\mathrm{c}}$, the symmetric mass ratio $\\eta$, and an effective aligned spin $\\chi$.\n\nThe solution will be developed in three primary stages:\n1.  Analytical derivation of the necessary components for the Fisher Information Matrix, specifically the partial derivatives of the waveform's log-amplitude and phase with respect to the model parameters.\n2.  Formulation of the numerical algorithm to compute the Fisher matrix, incorporate the prior information, and derive the posterior covariance, from which uncertainties and correlations are extracted.\n3.  Specification of the constants and unit conversions required for a complete and correct implementation.\n\nLet the vector of parameters be $\\theta = (\\theta_1, \\theta_2, \\theta_3) = (M_{\\mathrm{c}}, \\eta, \\chi)$.\n\n### 1. Analytical Derivations for the Fisher Matrix\n\nThe Fisher Information Matrix $\\Gamma_{ij}$ is defined by the noise-weighted inner product of the partial derivatives of the waveform $h(f)$ with respect to the parameters $\\theta_i$ and $\\theta_j$. For a waveform of the form $h(f) = A(f) e^{i\\Psi(f)}$, where $A(f)$ is the real-valued amplitude, the provided formula for the Fisher matrix is:\n$$\n\\Gamma_{ij} = 4 \\int_{f_{\\mathrm{low}}}^{f_{\\mathrm{high}}} \\frac{A(f)^2}{S_n(f)} \\left[ (\\partial_i \\ln A(f)) (\\partial_j \\ln A(f)) + (\\partial_i \\Psi(f)) (\\partial_j \\Psi(f)) \\right] df\n$$\nHere, $\\partial_i$ denotes the partial derivative $\\partial/\\partial\\theta_i$. Our task reduces to calculating the derivatives of the log-amplitude, $\\ln A(f)$, and the phase, $\\Psi(f)$, with respect to $M_{\\mathrm{c}}$, $\\eta$, and $\\chi$. All calculations will be performed in geometric units ($G=c=1$).\n\n**1.1. Log-Amplitude Derivatives**\n\nThe amplitude is given by $A(f) \\equiv |\\mathcal{A}(f)| = \\mathcal{C} \\frac{M_{\\mathrm{c}}^{5/6}}{D_L} f^{-7/6}$. The natural logarithm is:\n$$\n\\ln A(f) = \\ln\\left(\\frac{\\mathcal{C}}{D_L}\\right) + \\frac{5}{6}\\ln M_{\\mathrm{c}} - \\frac{7}{6}\\ln f\n$$\nThe luminosity distance $D_L$ is treated as a fixed nuisance parameter in this context. The partial derivatives with respect to our parameters $\\theta = (M_{\\mathrm{c}}, \\eta, \\chi)$ are:\n\\begin{align*}\n\\partial_{M_{\\mathrm{c}}} \\ln A(f) &= \\frac{5}{6 M_{\\mathrm{c}}} \\\\\n\\partial_{\\eta} \\ln A(f) &= 0 \\\\\n\\partial_{\\chi} \\ln A(f) &= 0\n\\end{align*}\nThe amplitude's dependence is solely on the chirp mass, which greatly simplifies the amplitude-related terms in the Fisher matrix.\n\n**1.2. Phase Derivatives**\n\nThe calculation of the phase derivatives requires careful application of the chain rule. The phase $\\Psi(f)$ is a function of the post-Newtonian velocity parameter $v$, which in turn depends on the total mass $M$, and thus on $M_{\\mathrm{c}}$ and $\\eta$. The phase also depends explicitly on $\\eta$ and implicitly on $\\eta$ and $\\chi$ through the coefficients $\\alpha_2$ and $\\alpha_3$.\n\nThe key dependencies are:\n$M = M_{\\mathrm{c}} \\eta^{-3/5}$, $v = (\\pi M f)^{1/3}$, $\\alpha_2(\\eta) = \\frac{3715}{756} + \\frac{55}{9}\\eta$, and $\\alpha_3(\\eta, \\chi) = 4\\beta - 16\\pi$ with $\\beta(\\eta, \\chi) = (\\frac{113}{12} - \\frac{19}{3}\\eta)\\chi$.\n\nThe complete phase expression is:\n$$\n\\Psi(f) = \\frac{3}{128 \\, \\eta} \\left( v^{-5} + \\alpha_2 v^{-3} + \\alpha_3 v^{-2} \\right)\n$$\nUsing the chain rule, we derive the following partial derivatives:\n\n- **Derivative with respect to Chirp Mass ($M_{\\mathrm{c}}$):**\nThe dependency is $\\Psi \\rightarrow v \\rightarrow M \\rightarrow M_{\\mathrm{c}}$.\n$$\n\\partial_{M_{\\mathrm{c}}} \\Psi(f) = \\frac{\\partial \\Psi}{\\partial v} \\frac{\\partial v}{\\partial M} \\frac{\\partial M}{\\partial M_{\\mathrm{c}}}\n$$\nThe intermediate derivatives are $\\frac{\\partial M}{\\partial M_{\\mathrm{c}}} = \\eta^{-3/5}$, $\\frac{\\partial v}{\\partial M} = \\frac{v}{3M}$, and $\\frac{\\partial \\Psi}{\\partial v} = \\frac{3}{128\\eta}(-5v^{-6} - 3\\alpha_2v^{-4} - 2\\alpha_3v^{-3})$. Combining these yields:\n$$\n\\partial_{M_{\\mathrm{c}}} \\Psi(f) = \\frac{1}{128 \\eta M_{\\mathrm{c}}} \\left( -5 v^{-5} - 3 \\alpha_2 v^{-3} - 2 \\alpha_3 v^{-2} \\right)\n$$\n\n- **Derivative with respect to Symmetric Mass Ratio ($\\eta$):**\nThe parameter $\\eta$ appears explicitly and implicitly through $v$, $\\alpha_2$, and $\\alpha_3$. A full derivative calculation yields:\n$$\n\\partial_{\\eta} \\Psi(f) = \\frac{3}{128\\eta^2} \\left[ \\left(\\frac{55}{9}\\eta - \\frac{2}{5}\\alpha_2\\right)v^{-3} + \\left(-\\frac{76}{3}\\chi\\eta - \\frac{3}{5}\\alpha_3\\right)v^{-2} \\right]\n$$\n\n- **Derivative with respect to Effective Spin ($\\chi$):**\nThe spin $\\chi$ only enters the phase via the coefficient $\\alpha_3$. The dependency is $\\Psi \\rightarrow \\alpha_3 \\rightarrow \\beta \\rightarrow \\chi$.\n$$\n\\partial_{\\chi} \\Psi(f) = \\frac{\\partial \\Psi}{\\partial \\alpha_3} \\frac{\\partial \\alpha_3}{\\partial \\chi}\n$$\nWith $\\frac{\\partial \\Psi}{\\partial \\alpha_3} = \\frac{3}{128\\eta}v^{-2}$ and $\\frac{\\partial \\alpha_3}{\\partial \\chi} = 4(\\frac{113}{12} - \\frac{19}{3}\\eta)$, we get:\n$$\n\\partial_{\\chi} \\Psi(f) = \\frac{1}{128 \\eta} (113 - 76\\eta) v^{-2}\n$$\n\n### 2. Numerical Algorithm\n\nThe derived expressions are implemented in a numerical algorithm to compute the desired posterior quantities for each test case.\n\n1.  **Initialization:** The physical constants for unit conversion are defined: solar mass to seconds ($t_\\odot$) and Megaparsec to seconds ($1\\,\\mathrm{Mpc}/c$). Program inputs for each case ($M_{\\mathrm{c}}$ in $M_\\odot$, $\\eta$, $\\chi$, $D_L$ in Mpc, $f_{\\mathrm{low}}$, $f_{\\mathrm{cap}}$) are converted to geometric units (seconds).\n2.  **Frequency Grid:** A discrete frequency grid $f_k$ is constructed from $f_{\\mathrm{low}}$ to $f_{\\mathrm{high}} = \\min(f_{\\mathrm{cap}}, f_{\\mathrm{ISCO}}(M))$, where $f_{\\mathrm{ISCO}}(M) = (6^{3/2} \\pi M)^{-1}$ is the innermost stable circular orbit frequency. A grid of $N=4000$ points is used for numerical integration.\n3.  **Integrand Calculation:** For each frequency $f_k$ on the grid, we compute the following quantities:\n    - The noise power spectral density $S_n(f_k)$.\n    - The squared waveform amplitude $A(f_k)^2$.\n    - The numerical values of the phase derivatives $\\partial_i \\Psi(f_k)$ and the constant log-amplitude derivatives $\\partial_i \\ln A(f_k)$.\n    - The weight function $W(f_k) = 4 A(f_k)^2 / S_n(f_k)$.\n    - The $3 \\times 3$ Fisher matrix integrand at $f_k$: $I_{\\Gamma,ij}(f_k) = W(f_k) \\left[ (\\partial_i \\ln A) (\\partial_j \\ln A) + (\\partial_i \\Psi(f_k)) (\\partial_j \\Psi(f_k)) \\right]$.\n4.  **Numerical Integration:** The Fisher matrix $\\Gamma$ and the squared signal-to-noise ratio $\\rho^2$ are computed by numerically integrating their respective integrands over the frequency grid using the trapezoidal rule (e.g., via `numpy.trapz`).\n    - $\\Gamma_{ij} = \\int_{f_{\\mathrm{low}}}^{f_{\\mathrm{high}}} I_{\\Gamma,ij}(f) df$\n    - $\\rho^2 = \\int_{f_{\\mathrm{low}}}^{f_{\\mathrm{high}}} W(f) df$\n5.  **Posterior Covariance:** A Gaussian prior is incorporated by adding a prior precision matrix $\\Pi$ to the Fisher matrix. $\\Pi$ is diagonal, with entries $\\Pi_{ii} = 1/\\sigma_{i, \\mathrm{prior}}^2$. The parameter-space standard deviations for the prior are given as $\\sigma_{M_{\\mathrm{c}},\\mathrm{prior}} = 50\\,M_\\odot$, $\\sigma_{\\eta,\\mathrm{prior}} = 0.10$, and $\\sigma_{\\chi,\\mathrm{prior}} = 0.50$. The chirp mass prior must be converted to seconds. The posterior covariance matrix $\\Sigma$ is the inverse of the sum:\n    $$\n    \\Sigma = (\\Gamma + \\Pi)^{-1}\n    $$\n6.  **Extraction of Results:** The final quantities are extracted from the posterior covariance matrix $\\Sigma$:\n    - Posterior standard deviations: $\\sigma_i = \\sqrt{\\Sigma_{ii}}$.\n    - Correlation coefficients: $\\mathrm{corr}(\\theta_i, \\theta_j) = \\frac{\\Sigma_{ij}}{\\sqrt{\\Sigma_{ii}\\Sigma_{jj}}}$.\n    - The optimal signal-to-noise ratio is $\\rho = \\sqrt{\\rho^2}$.\n7.  **Finalization:** The posterior standard deviation for the chirp mass, $\\sigma_{M_{\\mathrm{c}}}$, calculated in seconds, is converted back to solar mass units ($M_\\odot$) for the final output. The results for each test case are compiled into a list of seven floating-point numbers as specified.\n\nThis procedure constitutes a complete, principle-based algorithm for solving the problem. The analytical derivatives provide the connection to the underlying physical model, and the numerical steps implement the statistical framework of the Fisher matrix approximation.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Main function to solve the gravitational wave parameter estimation problem\n    for the given test cases.\n    \"\"\"\n\n    # Physical and model constants in SI units, and conversion factors.\n    # Solar mass to seconds: G*M_sun/c^3\n    T_SUN = 4.92549095e-6\n    # Megaparsec to seconds: 1 Mpc / c\n    MPC_TO_S = 1.029271250e14\n    # Constant C in waveform amplitude\n    C_CONST = np.sqrt(5.0 / 24.0) * np.pi**(-2.0 / 3.0)\n\n    # Noise curve parameters for S_n(f)\n    S0 = 1e-47  # Hz^-1\n    F0 = 50.0   # Hz\n    F1 = 200.0  # Hz\n\n    # Prior standard deviations\n    SIGMA_MC_PRIOR_MSUN = 50.0\n    SIGMA_ETA_PRIOR = 0.10\n    SIGMA_CHI_PRIOR = 0.50\n\n    # Numerical integration settings\n    N_FREQ_SAMPLES = 4000\n\n    def perform_calculation(case_params):\n        \"\"\"\n        Performs the Fisher matrix calculation for a single test case.\n        \n        Args:\n            case_params (tuple): A tuple containing (Mc_msun, eta, chi, DL_mpc, f_low, f_cap).\n        \n        Returns:\n            list: A list of 7 floats representing the results.\n        \"\"\"\n        Mc_msun, eta, chi, DL_mpc, f_low, f_cap = case_params\n\n        # 1. Unit Conversions (to geometric units where G=c=1, time/mass/length in seconds)\n        Mc = Mc_msun * T_SUN\n        DL = DL_mpc * MPC_TO_S\n        sigma_mc_prior_s = SIGMA_MC_PRIOR_MSUN * T_SUN\n\n        # 2. Setup frequency grid\n        M = Mc * eta**(-3.0 / 5.0)  # Total mass in seconds\n        f_isco = 1.0 / (6.0**(1.5) * np.pi * M)\n        f_high = min(f_cap, f_isco)\n        f = np.linspace(f_low, f_high, N_FREQ_SAMPLES)\n\n        # 3. Calculate frequency-dependent quantities (vectorized)\n        # Power Spectral Density\n        Sn = S0 * ((F0 / f)**4 + 1 + (f / F1)**2)\n        # Squared amplitude\n        A_sq = (C_CONST * Mc**(5.0/6.0) / DL * f**(-7.0/6.0))**2\n        \n        # PN parameters and coefficients\n        v = (np.pi * M * f)**(1.0/3.0)\n        alpha2 = 3715.0/756.0 + 55.0/9.0 * eta\n        beta = (113.0/12.0 - 19.0/3.0 * eta) * chi\n        alpha3 = 4.0 * beta - 16.0 * np.pi\n\n        # 4. Calculate derivatives\n        # Log-amplitude derivatives (constants in frequency)\n        d_logA_dMc = 5.0 / (6.0 * Mc)\n        d_logA_deta = 0.0\n        d_logA_dchi = 0.0\n        d_logA_dtheta = np.array([d_logA_dMc, d_logA_deta, d_logA_dchi])\n\n        # Phase derivatives (functions of frequency)\n        v_m2 = v**-2\n        v_m3 = v**-3\n        v_m5 = v**-5\n        \n        d_psi_dMc = (1.0 / (128.0 * eta * Mc)) * (-5.0 * v_m5 - 3.0 * alpha2 * v_m3 - 2.0 * alpha3 * v_m2)\n        \n        term_eta_1 = (55.0/9.0 * eta - 2.0/5.0 * alpha2) * v_m3\n        term_eta_2 = (-76.0/3.0 * chi * eta - 3.0/5.0 * alpha3) * v_m2\n        d_psi_deta = (3.0 / (128.0 * eta**2)) * (term_eta_1 + term_eta_2)\n        \n        d_psi_dchi = (1.0 / (128.0 * eta)) * (113.0 - 76.0 * eta) * v_m2\n        \n        d_psi_dtheta = np.stack([d_psi_dMc, d_psi_deta, d_psi_dchi], axis=-1)\n\n        # 5. Compute Fisher matrix integrand\n        weight = 4.0 * A_sq / Sn\n        \n        # Term for logA derivatives: shape (3,3)\n        term_logA = np.outer(d_logA_dtheta, d_logA_dtheta)\n        \n        # Term for Psi derivatives: shape (N, 3, 3)\n        term_psi = d_psi_dtheta[:, :, np.newaxis] * d_psi_dtheta[:, np.newaxis, :]\n        \n        # Full integrand for Gamma: shape (N, 3, 3)\n        integrand_gamma = weight[:, np.newaxis, np.newaxis] * (term_logA[np.newaxis, :, :] + term_psi)\n\n        # 6. Numerical Integration\n        Gamma = np.trapz(integrand_gamma, x=f, axis=0)\n        rho_sq = np.trapz(weight, x=f)\n        rho = np.sqrt(rho_sq)\n\n        # 7. Incorporate Priors and Compute Covariance\n        Pi = np.diag([\n            1.0 / sigma_mc_prior_s**2,\n            1.0 / SIGMA_ETA_PRIOR**2,\n            1.0 / SIGMA_CHI_PRIOR**2\n        ])\n        \n        # Posterior covariance matrix\n        Sigma = np.linalg.inv(Gamma + Pi)\n\n        # 8. Extract Results\n        sigma_mc_s = np.sqrt(Sigma[0, 0])\n        sigma_eta = np.sqrt(Sigma[1, 1])\n        sigma_chi = np.sqrt(Sigma[2, 2])\n\n        # Correlation coefficients\n        corr_mc_eta = Sigma[0, 1] / (sigma_mc_s * sigma_eta)\n        corr_mc_chi = Sigma[0, 2] / (sigma_mc_s * sigma_chi)\n        corr_eta_chi = Sigma[1, 2] / (sigma_eta * sigma_chi)\n\n        # 9. Unit conversion for output\n        sigma_mc_msun = sigma_mc_s / T_SUN\n\n        return [sigma_mc_msun, sigma_eta, sigma_chi, corr_mc_eta, corr_mc_chi, corr_eta_chi, rho]\n\n    # Test suite from the problem statement\n    test_cases = [\n        # Case 1: (Mc[Msun], eta, chi, DL[Mpc], flow[Hz], fcap[Hz])\n        (26.0, 0.25, 0.0, 500.0, 20.0, 512.0),\n        # Case 2:\n        (8.7, 0.25, 0.6, 400.0, 20.0, 1024.0),\n        # Case 3:\n        (15.0, 0.16, -0.4, 2000.0, 20.0, 512.0),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        result_list = perform_calculation(case)\n        all_results.append(result_list)\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"[{','.join(map(str, res))}]\" for res in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3479528"}]}