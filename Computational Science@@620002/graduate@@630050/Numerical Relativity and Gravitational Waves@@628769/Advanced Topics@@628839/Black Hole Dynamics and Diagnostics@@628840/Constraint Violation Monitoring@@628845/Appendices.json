{"hands_on_practices": [{"introduction": "The first step in building confidence in any numerical simulation is to verify that it behaves as theoretically predicted. A fundamental verification technique is the mesh-refinement study, where we confirm that numerical errors decrease at the expected rate as grid resolution increases. This practice [@problem_id:3470034] guides you through implementing this crucial test for proxy constraints that mirror the structure of Einstein's equations, revealing how to diagnose a code's accuracy and uncovering important subtleties in verification procedures.", "problem": "Consider the Arnowitt–Deser–Misner (ADM) formulation of general relativity where the Hamiltonian constraint $H$ and the momentum constraint $M_i$ must vanish in vacuum. In differential geometric terms, for vacuum initial data $(\\gamma_{ij}, K_{ij})$, the Hamiltonian constraint is given by $H = R + K^2 - K_{ij} K^{ij}$ and the momentum constraint by $M_i = \\nabla_j (K^j{}_i - \\delta^j{}_i K)$, where $R$ is the Ricci scalar of the spatial metric $\\gamma_{ij}$, $K$ is the trace of the extrinsic curvature $K_{ij}$, and $\\nabla_j$ is the covariant derivative with respect to $\\gamma_{ij}$. In numerical relativity, these constraints are monitored via norms such as the $L^2$ norm to assess the fidelity of the evolution and the quality of the discretization. For a $p$th-order accurate discretization applied to smooth data, local truncation error is expected to scale as $\\mathcal{O}(h^p)$, where $h$ is the grid spacing, leading to $L^2$ norms of residual constraints that scale as $h^p$ in the asymptotic convergence regime.\n\nTo design a testable and self-contained verification of expected convergence rates without implementing the full curvature tensors, consider the following manufactured proxy constraints on the unit square domain $\\Omega = [0,1]\\times[0,1]$:\n- Let the scalar field $\\phi(x,y) = x^3 - 3 x y^2$, which is harmonic in two dimensions, so the continuum Laplacian satisfies $\\Delta \\phi = \\partial_{xx} \\phi + \\partial_{yy} \\phi = 0$ for all $(x,y) \\in \\Omega$.\n- Let the stream function $\\psi(x,y) = x^3 - 3 x y^2$, and define a vector field $v$ by $v_x = \\partial_y \\psi$ and $v_y = -\\partial_x \\psi$, which ensures $\\nabla \\cdot v = \\partial_x v_x + \\partial_y v_y = 0$ for all $(x,y) \\in \\Omega$.\n\nThese choices yield continuum-proxy constraints that vanish identically:\n- Proxy Hamiltonian constraint $H := \\Delta \\phi = 0$.\n- Proxy momentum constraint $M := \\nabla \\cdot v = 0$.\n\nWhen approximating these differential operators with finite differences of order $p$ on a uniform grid with spacing $h$, the discrete residual fields $H_h$ and $M_h$ are nonzero due to truncation error, and their $L^2$ norms obey\n$$\n\\|H_h\\|_{L^2(\\Omega)} \\approx C_H h^p, \\quad \\|M_h\\|_{L^2(\\Omega)} \\approx C_M h^p,\n$$\nfor constants $C_H, C_M$ depending on higher derivatives of the fields. The observed convergence order $\\hat{p}$ between two grids with spacings $h_1$ and $h_2$ and corresponding norms $E_1$ and $E_2$ is estimated by\n$$\n\\hat{p} = \\frac{\\ln\\left(E_1 / E_2\\right)}{\\ln\\left(h_1 / h_2\\right)}.\n$$\n\nYour task is to write a complete, runnable program that:\n1. Constructs uniform grids on the unit square with $N \\times N$ points and spacing $h = 1/(N-1)$ for specified values of $N$.\n2. Evaluates the analytic fields $\\phi(x,y)$ and $v(x,y)$, where $v_x(x,y) = -6 x y$ and $v_y(x,y) = -3 x^2 + 3 y^2$.\n3. Computes discrete approximations of the proxy constraints using central finite differences of specified orders $p_H$ for the Laplacian and $p_M$ for the divergence. You must implement:\n   - For the Laplacian $\\Delta \\phi$, use standard central finite difference stencils of order $p \\in \\{2,4\\}$ for second derivatives along each axis, combining them additively to form $\\partial_{xx} \\phi + \\partial_{yy} \\phi$. For order $p=2$, use three-point central stencils; for order $p=4$, use five-point central stencils with coefficients yielding fourth-order accuracy.\n   - For the divergence $\\nabla \\cdot v$, use central finite difference stencils of order $p \\in \\{2,4\\}$ for first derivatives $\\partial_x v_x$ and $\\partial_y v_y$ with corresponding three-point or five-point stencils.\n4. Excludes boundary-adjacent points insufficient for the required stencil; compute the $L^2$ norm over the interior points where the discretization is defined. The $L^2$ norm must be computed as\n$$\n\\|f\\|_{L^2(\\Omega_{\\text{int}})} = \\left( \\sum_{(i,j) \\in \\text{interior}} f_{ij}^2 \\, h^2 \\right)^{1/2},\n$$\nwhere $\\Omega_{\\text{int}}$ denotes the interior subset where stencils are valid.\n5. For a sequence of grid sizes $\\{N_k\\}$, computes the arrays of norms $\\{\\|H_{h_k}\\|_{L^2}\\}$ and $\\{\\|M_{h_k}\\|_{L^2}\\}$ for spacings $h_k = 1/(N_k-1)$, and estimates observed orders $\\hat{p}_H^{(k)}$ and $\\hat{p}_M^{(k)}$ for each consecutive pair $(k,k+1)$ using the formula above.\n6. Implements an adaptive stop criterion that triggers when the observed rates deviate from the expected $p$th-order scaling. Given a tolerance $\\varepsilon > 0$ and an expected order $p_{\\text{exp}}$, the criterion must return the boolean value $\\text{True}$ if there exists any consecutive pair $(k,k+1)$ such that either\n$$\n\\left| \\hat{p}_H^{(k)} - p_{\\text{exp}} \\right| > \\varepsilon \\quad \\text{or} \\quad \\left| \\hat{p}_M^{(k)} - p_{\\text{exp}} \\right| > \\varepsilon,\n$$\nand $\\text{False}$ otherwise.\n\nFor scientific realism, note that the above manufactured proxy aligns with the conceptual structure of the ADM constraints: the Hamiltonian constraint resembles second-derivative operators acting on metric-related fields, and the momentum constraint resembles first-derivative divergence-type operators acting on curvature-related fields. Verifying $p$th-order scaling of their residuals is standard in mesh-refinement studies.\n\nAngles do not appear, and no physical units are required since the problem is purely dimensionless on the unit square.\n\nTest Suite:\nImplement the following four parameter cases to exercise the stop criterion:\n- Case $1$ (happy path): $p_H = 2$, $p_M = 2$, $p_{\\text{exp}} = 2$, $\\varepsilon = 0.3$, grid sizes $\\{N_k\\} = \\{33, 65, 129\\}$.\n- Case $2$ (order mismatch): $p_H = 4$, $p_M = 4$, $p_{\\text{exp}} = 2$, $\\varepsilon = 0.3$, grid sizes $\\{N_k\\} = \\{33, 65, 129\\}$.\n- Case $3$ (noise-induced deviation): $p_H = 4$, $p_M = 4$, $p_{\\text{exp}} = 4$, $\\varepsilon = 0.2$, grid sizes $\\{N_k\\} = \\{33, 65, 129\\}$, and additive constraint measurement noise with fixed amplitude to simulate under-resolved contamination. The noise must be added directly to the discrete residual fields before computing norms, using a deterministic pseudo-random generator seeded per test case to ensure reproducibility.\n- Case $4$ (momentum mismatch): $p_H = 4$, $p_M = 2$, $p_{\\text{exp}} = 4$, $\\varepsilon = 0.3$, grid sizes $\\{N_k\\} = \\{33, 65, 129\\}$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the boolean results of the stop criterion for the four cases as a comma-separated list enclosed in square brackets (e.g., $[r_1,r_2,r_3,r_4]$), where each $r_k$ is either $\\text{True}$ or $\\text{False}$.", "solution": "The problem requires the implementation of a numerical verification test for manufactured proxy constraints analogous to those in the Arnowitt–Deser–Misner (ADM) formulation of general relativity. The core task is to compute the convergence rate of finite difference approximations and apply an adaptive stop criterion.\n\nFirst, we formalize the problem. We are given a scalar field $\\phi(x,y) = x^3 - 3 x y^2$ and a vector field derived from a stream function $\\psi(x,y) = \\phi(x,y)$, with components $v_x(x,y) = \\partial_y \\psi = -6 x y$ and $v_y(x,y) = -\\partial_x \\psi = -3 x^2 + 3 y^2$. These fields are defined on the unit square $\\Omega = [0,1]\\times[0,1]$.\n\nThe proxy constraints are the Hamiltonian constraint, $H := \\Delta \\phi = \\partial_{xx} \\phi + \\partial_{yy} \\phi$, and the momentum constraint, $M := \\nabla \\cdot v = \\partial_x v_x + \\partial_y v_y$. Analytically, these constraints are identically zero.\n- For $H$: $\\partial_x \\phi = 3x^2 - 3y^2 \\implies \\partial_{xx} \\phi = 6x$. $\\partial_y \\phi = -6xy \\implies \\partial_{yy} \\phi = -6x$. Thus, $H = 6x - 6x = 0$.\n- For $M$: $\\partial_x v_x = -6y$. $\\partial_y v_y = 6y$. Thus, $M = -6y + 6y = 0$.\n\nThe task is to discretize these differential operators on a uniform $N \\times N$ grid with spacing $h = 1/(N-1)$ and verify that the numerical error, manifested as non-zero residual constraints $H_h$ and $M_h$, converges to zero at an expected rate $p_{\\text{exp}}$.\n\nThe discretization is performed using central finite differences.\nFor the Laplacian $\\Delta = \\partial_{xx} + \\partial_{yy}$, the second derivatives are approximated using:\n- Order $p=2$ (3-point stencil):\n$$ \\partial_{xx} f(x,y) \\approx \\frac{f(x+h, y) - 2f(x,y) + f(x-h,y)}{h^2} $$\n- Order $p=4$ (5-point stencil):\n$$ \\partial_{xx} f(x,y) \\approx \\frac{-f(x+2h, y) + 16f(x+h,y) - 30f(x,y) + 16f(x-h,y) - f(x-2h,y)}{12h^2} $$\nThe same stencils apply for $\\partial_{yy}$.\n\nFor the divergence $\\nabla \\cdot v = \\partial_x v_x + \\partial_y v_y$, the first derivatives are approximated using:\n- Order $p=2$ (3-point stencil):\n$$ \\partial_{x} f(x,y) \\approx \\frac{f(x+h, y) - f(x-h,y)}{2h} $$\n- Order $p=4$ (5-point stencil):\n$$ \\partial_{x} f(x,y) \\approx \\frac{-f(x+2h, y) + 8f(x+h,y) - 8f(x-h,y) + f(x-2h,y)}{12h} $$\n\nA critical step in this analysis is to examine the truncation error of these stencils when applied to the specific polynomials given. The leading-order truncation error for an order-$p$ scheme scales with $h^p$ and a higher-order derivative of the function. For instance, the $2^{nd}$-order stencil for the second derivative has a leading error term proportional to $h^2 \\partial^4 f / \\partial x^4$. The $4^{th}$-order stencil has an error proportional to $h^4 \\partial^6 f / \\partial x^6$. Similarly, the $2^{nd}$ and $4^{th}$-order stencils for the first derivative have leading error terms proportional to $h^2 \\partial^3 f / \\partial x^3$ and $h^4 \\partial^5 f / \\partial x^5$, respectively.\n\nLet us evaluate the relevant higher derivatives for our fields:\n- For $\\phi(x,y) = x^3 - 3xy^2$ (a cubic polynomial): All derivatives of order $4$ and higher are zero.\n- For $v_x(x,y) = -6xy$ and $v_y(x,y) = -3x^2+3y^2$ (quadratic polynomials): All derivatives of order $3$ and higher are zero.\n\nThis has a profound consequence: all specified finite difference schemes are exact for these particular polynomials. The leading truncation error terms, and indeed all subsequent terms, are identically zero. Therefore, the discrete residuals $H_h$ and $M_h$ should be zero up to floating-point round-off error, for all grid spacings $h$.\n\nThe $L^2$ norm of the residual, defined as $\\|f_h\\|_{L^2} = (\\sum_{ij \\in \\text{int}} f_{ij}^2 h^2)^{1/2}$, will therefore not exhibit the expected $h^p$ scaling. Instead, it will hover around machine precision for Cases 1, 2, and 4. The observed convergence order, calculated via $\\hat{p} = \\ln(E_1/E_2)/\\ln(h_1/h_2)$, will be dominated by the noisy ratio of these near-zero norms, yielding unpredictable values not close to the theoretical order $p$.\n\nThis allows us to predict the outcome of the stop criterion check, which is triggered if $|\\hat{p}_H - p_{\\text{exp}}| > \\varepsilon$ or $|\\hat{p}_M - p_{\\text{exp}}| > \\varepsilon$.\n- **Case 1 ($p_{\\text{exp}}=2, \\varepsilon=0.3$):** The computed rates $\\hat{p}_H, \\hat{p}_M$ will be noisy and not consistently close to $2$. The criterion is expected to trigger. Result: `True`.\n- **Case 2 ($p_{\\text{exp}}=2, \\varepsilon=0.3$):** Same as Case 1. The rates will be noisy. The criterion is expected to trigger. Result: `True`.\n- **Case 3 ($p_{\\text{exp}}=4, \\varepsilon=0.2$, with noise):** An additive noise floor is introduced, dominating the floating-point error. The norms $E_1$ and $E_2$ will then be approximately constant, independent of $h$. This leads to $E_1/E_2 \\approx 1$, so $\\ln(E_1/E_2) \\approx 0$, yielding an observed convergence rate $\\hat{p} \\approx 0$. Since $|0 - 4| > 0.2$, the criterion will trigger. Result: `True`.\n- **Case 4 ($p_M=2, p_H=4, p_{\\text{exp}}=4, \\varepsilon=0.3$):** Both discrete constraints are exactly zero (up to machine precision). The observed rates will be noisy and not close to $4$. The criterion is expected to trigger. Result: `True`.\n\nThis problem is a sophisticated test of verification procedures, demonstrating a common pitfall where a manufactured solution is too simple for the numerical scheme, leading to a misleading (or, in this case, correctly failing) convergence test. The algorithm will proceed by computing the norms as specified and applying the criterion.\nThe implementation will define functions for the discrete Laplacian and divergence operators that can handle different orders of accuracy. A main loop will iterate through the test cases, and for each case, a sub-loop will iterate through the grid resolutions to collect norms. Finally, the convergence rates are computed between consecutive resolutions and checked against the stop criterion. The implementation detail for the noise in Case 3 will be a seeded pseudo-random number generator to ensure reproducibility, adding values of a fixed small amplitude (e.g., $10^{-10}$) to the discrete residual fields.", "answer": "```python\nimport numpy as np\n\ndef compute_laplacian(phi, h, p):\n    \"\"\"\n    Computes the discrete Laplacian of a 2D field `phi` with grid spacing `h`\n    using a finite difference scheme of order `p`.\n    \"\"\"\n    laplacian = np.zeros_like(phi)\n    s = p // 2  # Stencil half-width\n\n    if p == 2:\n        # 3-point stencil for second derivative\n        # d2f/dx2 = (f_{i+1} - 2f_i + f_{i-1}) / h^2\n        d2phidx2 = np.zeros_like(phi)\n        d2phidy2 = np.zeros_like(phi)\n        \n        d2phidx2[:, s:-s] = (phi[:, 2*s:] - 2*phi[:, s:-s] + phi[:, :-2*s]) / h**2\n        d2phidy2[s:-s, :] = (phi[2*s:, :] - 2*phi[s:-s, :] + phi[:-2*s, :]) / h**2\n        \n        laplacian = d2phidx2 + d2phidy2\n\n    elif p == 4:\n        # 5-point stencil for second derivative\n        # d2f/dx2 = (-f_{i+2} + 16f_{i+1} - 30f_i + 16f_{i-1} - f_{i-2}) / (12h^2)\n        d2phidx2 = np.zeros_like(phi)\n        d2phidy2 = np.zeros_like(phi)\n\n        d2phidx2[:, s:-s] = (-phi[:, 2*s:] + 16*phi[:, s+1:-s+1] - 30*phi[:, s:-s] + 16*phi[:, s-1:-s-1] - phi[:, :-2*s]) / (12 * h**2)\n        d2phidy2[s:-s, :] = (-phi[2*s:, :] + 16*phi[s+1:-s+1, :] - 30*phi[s:-s, :] + 16*phi[s-1:-s-1, :] - phi[:-2*s, :]) / (12 * h**2)\n        \n        laplacian = d2phidx2 + d2phidy2\n    \n    return laplacian\n\ndef compute_divergence(vx, vy, h, p):\n    \"\"\"\n    Computes the discrete divergence of a 2D vector field (vx, vy) with grid\n    spacing `h` using a finite difference scheme of order `p`.\n    \"\"\"\n    divergence = np.zeros_like(vx)\n    s = p // 2  # Stencil half-width\n\n    if p == 2:\n        # 3-point stencil for first derivative\n        # df/dx = (f_{i+1} - f_{i-1}) / (2h)\n        dvxdx = np.zeros_like(vx)\n        dvydy = np.zeros_like(vy)\n        \n        dvxdx[:, s:-s] = (vx[:, 2*s:] - vx[:, :-2*s]) / (2 * h)\n        dvydy[s:-s, :] = (vy[2*s:, :] - vy[:-2*s, :]) / (2 * h)\n        \n        divergence = dvxdx + dvydy\n\n    elif p == 4:\n        # 5-point stencil for first derivative\n        # df/dx = (-f_{i+2} + 8f_{i+1} - 8f_{i-1} + f_{i-2}) / (12h)\n        dvxdx = np.zeros_like(vx)\n        dvydy = np.zeros_like(vy)\n        \n        dvxdx[:, s:-s] = (-vx[:, 2*s:] + 8*vx[:, s+1:-s+1] - 8*vx[:, s-1:-s-1] + vx[:, :-2*s]) / (12 * h)\n        dvydy[s:-s, :] = (-vy[2*s:, :] + 8*vy[s+1:-s+1, :] - 8*vy[s-1:-s-1, :] + vy[:-2*s, :]) / (12 * h)\n\n        divergence = dvxdx + dvydy\n\n    return divergence\n\ndef run_case(p_H, p_M, p_exp, epsilon, N_values, noise_params=None):\n    \"\"\"\n    Runs a single convergence test case and returns the stop criterion result.\n    \"\"\"\n    h_values = []\n    H_norms = []\n    M_norms = []\n\n    for N in N_values:\n        h = 1.0 / (N - 1)\n        h_values.append(h)\n        \n        # 1. Construct grid and evaluate analytic fields\n        grid_1d = np.linspace(0.0, 1.0, N)\n        x, y = np.meshgrid(grid_1d, grid_1d)\n        \n        phi = x**3 - 3*x*y**2\n        vx = -6*x*y\n        vy = -3*x**2 + 3*y**2\n        \n        # 2. Compute discrete proxy constraints\n        H_h = compute_laplacian(phi, h, p_H)\n        M_h = compute_divergence(vx, vy, h, p_M)\n\n        # 3. Add noise if applicable\n        if noise_params:\n            rng = np.random.default_rng(seed=noise_params['seed'])\n            amp = noise_params['amplitude']\n            H_h += rng.uniform(-amp, amp, size=H_h.shape)\n            M_h += rng.uniform(-amp, amp, size=M_h.shape)\n\n        # 4. Compute L2 norm over interior points\n        s_H = p_H // 2\n        interior_H = H_h[s_H:-s_H, s_H:-s_H]\n        norm_H = np.sqrt(np.sum(interior_H**2) * h**2)\n        H_norms.append(norm_H)\n        \n        s_M = p_M // 2\n        interior_M = M_h[s_M:-s_M, s_M:-s_M]\n        norm_M = np.sqrt(np.sum(interior_M**2) * h**2)\n        M_norms.append(norm_M)\n        \n    # 5. Estimate observed orders and check stop criterion\n    for k in range(len(N_values) - 1):\n        h1, h2 = h_values[k], h_values[k+1]\n        \n        # Avoid division by zero if norms are exactly zero\n        E1_H, E2_H = H_norms[k], H_norms[k+1]\n        p_hat_H = np.log(E1_H / E2_H) / np.log(h1 / h2) if E1_H > 0 and E2_H > 0 else 0\n\n        E1_M, E2_M = M_norms[k], M_norms[k+1]\n        p_hat_M = np.log(E1_M / E2_M) / np.log(h1 / h2) if E1_M > 0 and E2_M > 0 else 0\n        \n        if abs(p_hat_H - p_exp) > epsilon or abs(p_hat_M - p_exp) > epsilon:\n            return True\n            \n    return False\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # Case 1 (happy path, expected to fail check due to exactness)\n        {'p_H': 2, 'p_M': 2, 'p_exp': 2, 'eps': 0.3, 'N': [33, 65, 129], 'noise': None},\n        # Case 2 (order mismatch)\n        {'p_H': 4, 'p_M': 4, 'p_exp': 2, 'eps': 0.3, 'N': [33, 65, 129], 'noise': None},\n        # Case 3 (noise-induced deviation)\n        {'p_H': 4, 'p_M': 4, 'p_exp': 4, 'eps': 0.2, 'N': [33, 65, 129], 'noise': {'seed': 3, 'amplitude': 1e-10}},\n        # Case 4 (momentum mismatch)\n        {'p_H': 4, 'p_M': 2, 'p_exp': 4, 'eps': 0.3, 'N': [33, 65, 129], 'noise': None},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_case(case['p_H'], case['p_M'], case['p_exp'], case['eps'], case['N'], case['noise'])\n        results.append(result)\n        \n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3470034"}, {"introduction": "Beyond simply measuring the magnitude of constraint violation, a key diagnostic task is to understand its origin. Apparent violations can arise from genuine physical inconsistencies in the data, but also from numerical discretization errors or unphysical gauge dynamics. This exercise [@problem_id:3469971] sets up a controlled experiment where you will develop and deploy distinct monitors to distinguish a true, physical source of constraint violation from artifacts related to the chosen coordinates and numerical scheme.", "problem": "Consider the linearized vacuum constraints of the $3+1$ formalism of General Relativity, linearized about flat space, where the spatial metric is $g_{ij} = \\delta_{ij} + h_{ij}$ with a small perturbation $h_{ij}$ and the extrinsic curvature contributions are neglected to first order. The linearized Hamiltonian constraint is\n$$\nH_{\\text{lin}}(x) = \\partial_i \\partial_j h_{ij}(x) - \\partial^2 h(x),\n$$\nwhere $h(x) = h_{ii}(x)$ is the trace of the perturbation, and $\\partial^2 = \\partial_x^2 + \\partial_y^2 + \\partial_z^2$. Assume all fields depend only on the single spatial coordinate $x$, so that $\\partial_y = \\partial_z = 0$, and model periodic boundary conditions on a one-dimensional domain of length $L$. In this one-dimensional dependence setting, the linearized Hamiltonian constraint reduces to\n$$\nH_{\\text{lin}}(x) = \\partial_x^2 h_{xx}(x) - \\partial_x^2 \\left(h_{xx}(x) + h_{yy}(x) + h_{zz}(x)\\right) = -\\partial_x^2\\left(h_{yy}(x) + h_{zz}(x)\\right).\n$$\nThis shows that longitudinal gauge content in $h_{xx}$ does not contribute to $H_{\\text{lin}}$, whereas scalar trace content $h_{yy} + h_{zz}$ does. A physical Transverse-Traceless (TT) wave traveling along the $x$-axis has $h_{xx} = 0$, $h_{yy} = A \\sin(k(x - t))$, $h_{zz} = -A \\sin(k(x - t))$, and therefore $h_{yy} + h_{zz} = 0$, which yields $H_{\\text{lin}}(x) = 0$. A pure gauge wave arising from an infinitesimal coordinate perturbation with displacement $\\xi_x(x,t)$ has $h_{xx}(x,t) = 2 \\partial_x \\xi_x(x,t)$ and $h_{yy} = h_{zz} = 0$, which also yields $H_{\\text{lin}}(x) = 0$.\n\nYour task is to implement a monitoring program that discriminates gauge-induced versus physical (scalar trace) contributions to the $L^2$ norm of the Hamiltonian constraint, $\\|H\\|_{L^2}$, in a controlled synthetic experiment. Work on a periodic domain of length $L = 2\\pi$ with $N$ equispaced grid points and spacing $\\Delta x = L/N$. Use $t = 0$.\n\nDefine the following synthetic injections on the grid $x_n = n \\Delta x$ for $n = 0, 1, \\dots, N-1$:\n\n- A controlled gauge wave:\n$$\n\\xi_x(x, t) = \\frac{a}{k_{\\mathrm{phys}}}\\cos\\left(k_{\\mathrm{phys}}(x - t)\\right), \\quad h_{xx}^{\\mathrm{gauge}}(x, t) = 2 \\partial_x \\xi_x(x, t) = -2 a \\sin\\left(k_{\\mathrm{phys}}(x - t)\\right),\n$$\nwith $h_{yy} = 0$, $h_{zz} = 0$. Here $k_{\\mathrm{phys}} = \\frac{2\\pi m}{L}$ is the physical wavenumber for integer mode number $m$.\n\n- A slightly perturbed, constraint-violating addition:\n$$\nh_{yy}^{\\mathrm{pert}}(x, t) = \\varepsilon \\sin\\left(k_{\\mathrm{phys}}(x - t) + \\phi\\right), \\quad h_{zz}^{\\mathrm{pert}}(x, t) = 0,\n$$\nwhich yields $h_{yy} + h_{zz} \\neq 0$ and therefore a nonzero $H_{\\text{lin}}(x)$.\n\n- A physical Transverse-Traceless (TT) wave traveling along $x$:\n$$\nh_{xx}^{\\mathrm{TT}}(x, t) = 0, \\quad h_{yy}^{\\mathrm{TT}}(x, t) = A_p \\sin\\left(k_{\\mathrm{phys}}(x - t)\\right), \\quad h_{zz}^{\\mathrm{TT}}(x, t) = -A_p \\sin\\left(k_{\\mathrm{phys}}(x - t)\\right),\n$$\nwhich keeps $h_{yy} + h_{zz} = 0$.\n\nConstruct three test cases on the same grid:\n- Test case $1$: only the controlled gauge wave, with $h_{xx} = h_{xx}^{\\mathrm{gauge}}$, $h_{yy} = 0$, $h_{zz} = 0$.\n- Test case $2$: the gauge wave plus the perturbed addition, with $h_{xx} = h_{xx}^{\\mathrm{gauge}}$, $h_{yy} = h_{yy}^{\\mathrm{pert}}$, $h_{zz} = 0$.\n- Test case $3$: the gauge wave plus the physical TT wave, with $h_{xx} = h_{xx}^{\\mathrm{gauge}}$, $h_{yy} = h_{yy}^{\\mathrm{TT}}$, $h_{zz} = h_{zz}^{\\mathrm{TT}}$.\n\nDevelop and compute the following monitors for each test case:\n- A finite-difference approximation to the Hamiltonian constraint on the grid,\n$$\nH_{\\mathrm{fd}}(x_n) = D_{xx} h_{xx}(x_n) - D_{xx}\\left(h_{xx}(x_n) + h_{yy}(x_n) + h_{zz}(x_n)\\right),\n$$\nwhere $D_{xx}$ is the second-order centered finite difference operator,\n$$\nD_{xx} f(x_n) = \\frac{f(x_{n+1}) - 2 f(x_n) + f(x_{n-1})}{\\Delta x^2},\n$$\nwith periodic indexing.\n\n- A spectral-derivative approximation to the scalar-trace contribution, using the discrete Fourier transform (DFT): define $S(x_n) = h_{yy}(x_n) + h_{zz}(x_n)$. Let $\\widehat{f}(k)$ be the DFT of $f(x)$ on the periodic grid, and let $k$ denote the angular wavenumber in Fourier space. Then compute\n$$\n\\left(-\\partial_x^2 S\\right)_{\\mathrm{sp}}(x) = \\mathcal{F}^{-1}\\left[\\left(k^2\\right)\\widehat{S}(k)\\right](x),\n$$\nwhere $\\mathcal{F}^{-1}$ denotes the inverse DFT and the angular wavenumbers are $k_n = \\frac{2\\pi n}{L}$ for integer $n$ matched to the DFT convention.\n\n- The $L^2$ norm of any grid field $f(x_n)$ is\n$$\n\\|f\\|_{L^2} = \\left( \\sum_{n=0}^{N-1} f(x_n)^2 \\Delta x \\right)^{1/2}.\n$$\n\nCompute for each test case:\n- $H$ norm: $\\|H_{\\mathrm{fd}}\\|_{L^2}$.\n- Physical scalar monitor: $M_{\\mathrm{phys}} = \\left\\|\\left(-\\partial_x^2 S\\right)_{\\mathrm{sp}}\\right\\|_{L^2}$.\n- Gauge contamination monitor: $M_{\\mathrm{gauge}} = \\left\\|H_{\\mathrm{fd}} - \\left(-\\partial_x^2 S\\right)_{\\mathrm{sp}}\\right\\|_{L^2}$, which quantifies the portion of the measured Hamiltonian constraint not explained by the scalar-trace contribution and is therefore attributable to gauge-only content and discretization artifacts.\n\nUse the following parameter values for a scientifically sound and nontrivial test suite:\n- Domain length $L = 2\\pi$.\n- Grid size $N = 256$.\n- Mode number $m = 4$, so $k_{\\mathrm{phys}} = \\frac{2\\pi m}{L}$.\n- Gauge amplitude $a = 0.1$.\n- Perturbation amplitude $\\varepsilon = 0.01$ and phase $\\phi = \\pi/5$.\n- Physical TT amplitude $A_p = 0.05$.\n- Time $t = 0$.\n\nYour program should produce a single line of output containing the nine results, in order, as a comma-separated list enclosed in square brackets, specifically\n$$\n[\\|H_{\\mathrm{fd}}\\|_{L^2}^{(1)}, M_{\\mathrm{phys}}^{(1)}, M_{\\mathrm{gauge}}^{(1)}, \\|H_{\\mathrm{fd}}\\|_{L^2}^{(2)}, M_{\\mathrm{phys}}^{(2)}, M_{\\mathrm{gauge}}^{(2)}, \\|H_{\\mathrm{fd}}\\|_{L^2}^{(3)}, M_{\\mathrm{phys}}^{(3)}, M_{\\mathrm{gauge}}^{(3)}],\n$$\nwhere the superscripts indicate the test case number. Express all nine outputs as floating-point numbers. No physical units are involved in this dimensionless synthetic experiment. Round each printed float to $8$ decimal places to make the single-line output stable and unambiguous across platforms.", "solution": "The user's request is to develop a program that monitors Hamiltonian constraint violations in a simplified 1D setting of linearized General Relativity. The goal is to distinguish between physical sources of constraint violation and numerical artifacts, which can be related to gauge dynamics.\n\n### Scientific Principles and Problem Formulation\n\nThe problem is rooted in the $3+1$ \"ADM\" formalism of General Relativity, where spacetime is foliated into a series of spatial slices. The evolution of the geometry is governed by evolution equations, but the initial data on a slice cannot be chosen freely. It must satisfy a set of four constraint equations. Here, we focus on the linearized Hamiltonian constraint, which for a metric perturbation $h_{ij}$ around flat space takes the form:\n$$\nH_{\\text{lin}} = \\partial_i \\partial_j h_{ij} - \\partial^2 h\n$$\nwhere $h=h_{kk}$ is the trace of the perturbation and repeated indices are summed. Specializing to a 1D problem where all fields depend only on the $x$ coordinate ($\\partial_y = \\partial_z = 0$), this constraint simplifies significantly:\n$$\nH_{\\text{lin}}(x) = \\partial_x^2 h_{xx} - \\partial_x^2 (h_{xx} + h_{yy} + h_{zz}) = -\\partial_x^2 (h_{yy} + h_{zz})\n$$\nWe define the scalar trace quantity $S(x) = h_{yy}(x) + h_{zz}(x)$. The Hamiltonian constraint is thus equivalent to the action of the negative Laplacian on this scalar trace:\n$$\nH_{\\text{lin}}(x) = -\\partial_x^2 S(x)\n$$\nThis equation reveals that a non-zero scalar trace $S$ acts as a source for Hamiltonian constraint violation. Importantly, pure gauge modes (unphysical coordinate artifacts) and Transverse-Traceless (TT) physical gravitational waves traveling in the $x$-direction are constructed to have $S=0$ and thus exactly satisfy the Hamiltonian constraint.\n\n### Numerical Implementation and Monitoring Strategy\n\nThe task is to implement and compare different numerical measures of this constraint for three synthetic test cases defined on a periodic 1D grid.\n\n**1. Numerical Operators:**\n\n- **Finite Difference Laplacian:** The continuous operator $\\partial_x^2$ is approximated by a second-order centered finite difference operator, $D_{xx}$:\n  $$\n  D_{xx} f(x_n) = \\frac{f(x_{n+1}) - 2 f(x_n) + f(x_{n-1})}{\\Delta x^2}\n  $$\n  where $\\Delta x$ is the grid spacing and periodic boundary conditions are used for indices. The finite-difference approximation of the Hamiltonian constraint, $H_{\\text{fd}}$, is computed as specified:\n  $$\n  H_{\\text{fd}} = D_{xx} h_{xx} - D_{xx}(h_{xx} + h_{yy} + h_{zz}) = -D_{xx}(S)\n  $$\n  While the $D_{xx} h_{xx}$ terms cancel mathematically, computing them can introduce floating-point noise in a real simulation, and the problem asks to compute it this way.\n\n- **Spectral Laplacian:** For periodic functions, a highly accurate way to compute derivatives is via the Fourier transform ($\\mathcal{F}$). The derivative property of the Fourier transform states that $\\mathcal{F}[\\partial_x f(x)] = ik\\mathcal{F}[f(x)]$, where $k$ is the angular wavenumber. Consequently, $-\\partial_x^2$ becomes multiplication by $k^2$ in Fourier space. The spectral evaluation of the constraint source is:\n  $$\n  (-\\partial_x^2 S)_{\\mathrm{sp}} = \\mathcal{F}^{-1}[k^2 \\mathcal{F}[S]]\n  $$\n  where $\\mathcal{F}^{-1}$ is the inverse Fourier transform. This method is free of truncation error for functions that are well-resolved on the grid.\n\n**2. The Monitors:**\n\nThe problem defines three monitors based on the $L^2$ norm, which for a grid function $f_n$ is $\\|f\\|_{L^2} = (\\sum_{n=0}^{N-1} f_n^2 \\Delta x)^{1/2}$.\n\n- **Total \"Measured\" Constraint Violation:** $\\|H_{\\mathrm{fd}}\\|_{L^2}$. This represents the total constraint violation as measured by the simple finite-difference method.\n\n- **Physical Scalar Monitor:** $M_{\\mathrm{phys}} = \\|(-\\partial_x^2 S)_{\\mathrm{sp}}\\|_{L^2}$. This uses the spectrally accurate method to quantify the \"true\" physical source of constraint violation originating from a non-zero scalar trace $S$.\n\n- **Gauge Contamination Monitor:** $M_{\\mathrm{gauge}} = \\|H_{\\mathrm{fd}} - (-\\partial_x^2 S)_{\\mathrm{sp}}\\|_{L^2}$. This measures the difference between the finite-difference and spectral evaluations. This difference is primarily due to the truncation error of the finite-difference operator. In more complex scenarios, such discrepancies can be seeded or amplified by gauge modes, hence the name.\n\n### Analysis of Test Cases\n\n- **Case 1 (Pure Gauge):** We set $h_{xx}$ to be a gauge wave and $h_{yy} = h_{zz} = 0$. This gives $S = 0$. Consequently, the analytical constraint $H_{\\text{lin}}$ is zero. Both numerical approximations, $H_{\\mathrm{fd}}$ and $(-\\partial_x^2 S)_{\\mathrm{sp}}$, will also be zero (up to machine precision). All three monitors are expected to be zero.\n\n- **Case 2 (Gauge + Perturbation):** We add a constraint-violating perturbation $h_{yy}^{\\mathrm{pert}}$, making $S \\neq 0$.\n    - $M_{\\mathrm{phys}}$ will be non-zero, providing a spectrally accurate measure of the violation.\n    - $\\|H_{\\mathrm{fd}}\\|_{L^2}$ will also be non-zero. Since $D_{xx}$ is a second-order approximation, its result will be close but not identical to the spectral one.\n    - $M_{\\mathrm{gauge}}$ will be small but non-zero, precisely quantifying the truncation error of the finite-difference method for the given grid resolution and wavenumber.\n\n- **Case 3 (Gauge + TT Wave):** We add a physical Transverse-Traceless (TT) gravitational wave. By definition, a TT wave has zero trace, so for this wave, $h_{yy}^{\\mathrm{TT}} + h_{zz}^{\\mathrm{TT}} = 0$. This leaves the total scalar trace $S=0$. This case is therefore identical to Case 1 from the perspective of the Hamiltonian constraint. All three monitors are expected to be zero, demonstrating that the monitors correctly identify this physical wave as a constraint-satisfying solution.\n\nThe implementation will proceed by setting up the grid, defining the helper functions for the numerical operators and the $L^2$ norm, constructing the fields for each of the three test cases, computing the three specified monitors, and formatting the results.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes Hamiltonian constraint monitors for three synthetic test cases\n    in linearized 1D gravity.\n    \"\"\"\n    # Define parameters from the problem statement\n    L = 2.0 * np.pi\n    N = 256\n    m = 4\n    a = 0.1\n    epsilon = 0.01\n    phi = np.pi / 5.0\n    Ap = 0.05\n    t = 0.0\n\n    # Grid setup\n    dx = L / N\n    x = np.arange(N) * dx\n    # Since L=2pi, the physical wavenumber k_phys = 2*pi*m/L simplifies to m.\n    k_phys = float(m)\n\n    # --- Helper functions defined within the solver scope ---\n    def D_xx(f, dx_val):\n        \"\"\"Computes the second derivative using a centered finite difference scheme.\"\"\"\n        f_plus_1 = np.roll(f, -1)\n        f_minus_1 = np.roll(f, 1)\n        return (f_plus_1 - 2.0 * f + f_minus_1) / dx_val**2\n\n    def neg_d2_spectral(f, N_val, dx_val):\n        \"\"\"Computes -d^2/dx^2 of a function f using spectral methods (FFT).\"\"\"\n        f_hat = np.fft.fft(f)\n        # Wavenumbers corresponding to the DFT frequencies.\n        # np.fft.fftfreq gives cycles/sample spacing; multiply by 2*pi for angular k.\n        freqs = np.fft.fftfreq(N_val, d=dx_val)\n        k = 2.0 * np.pi * freqs\n        \n        # In Fourier space, -d^2/dx^2 is equivalent to multiplication by k^2.\n        # d/dx -> ik,  d^2/dx^2 -> (ik)^2 = -k^2,  -d^2/dx^2 -> k^2\n        neg_d2f_hat = (k**2) * f_hat\n        \n        # Inverse FFT to get back to spatial domain.\n        # The result must be real; np.real removes negligible imaginary parts.\n        return np.real(np.fft.ifft(neg_d2f_hat))\n\n    def L2_norm(f, dx_val):\n        \"\"\"Computes the L2 norm of a grid function.\"\"\"\n        return np.sqrt(np.sum(np.square(f)) * dx_val)\n\n    # --- Define field components for test cases ---\n    # Common gauge wave component\n    h_xx_gauge = -2.0 * a * np.sin(k_phys * (x - t))\n    \n    # Empty field for convenience\n    zeros = np.zeros(N)\n    \n    # Constraint-violating perturbation component\n    h_yy_pert = epsilon * np.sin(k_phys * (x - t) + phi)\n    \n    # Transverse-Traceless (TT) wave components\n    h_yy_TT = Ap * np.sin(k_phys * (x - t))\n    h_zz_TT = -Ap * np.sin(k_phys * (x - t))\n\n    # --- Define the test cases from the problem statement ---\n    test_cases = [\n        # Case 1: Pure gauge wave\n        (h_xx_gauge, zeros, zeros),\n        # Case 2: Gauge wave + perturbation\n        (h_xx_gauge, h_yy_pert, zeros),\n        # Case 3: Gauge wave + physical TT wave\n        (h_xx_gauge, h_yy_TT, h_zz_TT)\n    ]\n\n    all_results = []\n    for hxx, hyy, hzz in test_cases:\n        # Compute H_fd using the specified formula: H_fd = Dxx(hxx) - Dxx(hxx + hyy + hzz)\n        # This simplifies to -Dxx(hyy + hzz), but we implement the given form.\n        term1 = D_xx(hxx, dx)\n        term2 = D_xx(hxx + hyy + hzz, dx)\n        H_fd = term1 - term2\n\n        # Scalar trace S = hyy + hzz\n        S = hyy + hzz\n\n        # Compute the spectral scalar-trace contribution: (-d^2 S/dx^2)_sp\n        neg_d2S_sp = neg_d2_spectral(S, N, dx)\n\n        # Compute the three monitors for the current case\n        H_norm = L2_norm(H_fd, dx)\n        M_phys = L2_norm(neg_d2S_sp, dx)\n        M_gauge = L2_norm(H_fd - neg_d2S_sp, dx)\n\n        all_results.extend([H_norm, M_phys, M_gauge])\n        \n    # Format and print the final output as a single line with 8 decimal places\n    output_str = \"[\" + \",\".join([f\"{r:.8f}\" for r in all_results]) + \"]\"\n    print(output_str)\n\nsolve()\n```", "id": "3469971"}, {"introduction": "Monitoring constraint violations is critical, but for many applications, such as generating valid initial data, we must actively reduce or eliminate them. This is often accomplished by solving elliptic equations that \"project\" the inconsistent data onto the physical solution space, known as the constraint manifold. This advanced practice [@problem_id:3470000] walks you through the implementation of a projection step by linearizing a model Hamiltonian constraint, a core and powerful technique used throughout numerical relativity.", "problem": "Consider the Hamiltonian constraint in General Relativity (GR) formulated under a conformal decomposition, where constraint violations in the conformal factor are corrected by projecting onto the constraint manifold via an elliptic solve. In a scientifically consistent simplified model on a two-dimensional, flat, unit square domain $[0,1]\\times[0,1]$, adopt the following constraint functional that mimics the structure of the conformal Lichnerowicz-type equation:\n$$\nH(\\phi) = -8\\,\\Delta \\phi + \\beta\\,\\phi^5 - S(x,y),\n$$\nwhere $\\phi$ is the conformal factor, $\\Delta$ is the Laplacian on $\\mathbb{R}^2$, $\\beta \\ge 0$ is a constant parameter controlling nonlinearity, and $S(x,y)$ is a smooth source constructed from prescribed extrinsic curvature and matter terms. Impose homogeneous Dirichlet boundary conditions $\\,\\phi=0\\,$ on $\\partial([0,1]\\times[0,1])$.\n\nDefine the source as\n$$\nS(x,y) = A\\,\\sin(2\\pi x)\\sin(2\\pi y) + B\\,\\exp\\!\\left(-\\frac{(x-\\tfrac{1}{2})^2+(y-\\tfrac{1}{2})^2}{2\\sigma^2}\\right),\n$$\nwith parameters $A$, $B$, $\\sigma>0$. Use a uniform grid with $N$ interior points per spatial dimension, so that the grid spacing is $h = \\frac{1}{N+1}$ and interior grid points are $(x_i,y_j) = (ih,jh)$ for $i,j \\in \\{1,2,\\dots,N\\}$.\n\nLet the initial conformal factor be\n$$\n\\phi_0(x,y) = \\varepsilon\\,\\sin(\\pi x)\\sin(\\pi y),\n$$\nwith parameter $\\varepsilon \\ge 0$. The goal is to propose and implement a constraint projection step that computes a correction $\\delta\\phi$ by solving a single elliptic equation derived from the linearization of $H(\\phi)$ about the current $\\phi$, and then updates $\\phi \\leftarrow \\phi + \\delta\\phi$. After this projection, evaluate the reduction in the discrete norm of the Hamiltonian constraint.\n\nStarting from fundamental definitions and principles, do the following:\n- Derive the linearized elliptic operator acting on the correction $\\delta\\phi$ by taking the Fréchet derivative of $H(\\phi)$ with respect to $\\phi$ and evaluating it at the current $\\phi$. Use this operator to define the constraint projection equation for $\\delta\\phi$ that must be solved on the grid with homogeneous Dirichlet boundary conditions.\n- Discretize the operators using second-order central differences on the interior grid with the standard five-point stencil for the Laplacian. Treat the boundary by enforcing $\\,\\phi=0\\,$ at grid points on $\\partial([0,1]\\times[0,1])$.\n- Compute the discrete $L^2$ norm of the Hamiltonian constraint residual on the interior grid,\n$$\n\\lVert H \\rVert_{h} = \\sqrt{h^2 \\sum_{i=1}^N \\sum_{j=1}^N \\left(H_{ij}\\right)^2},\n$$\nboth before and after the projection step, and report the reduction ratio\n$$\nr = \\frac{\\lVert H(\\phi_{\\text{after}})\\rVert_{h}}{\\lVert H(\\phi_{\\text{before}})\\rVert_{h}}.\n$$\nIf $\\lVert H(\\phi_{\\text{before}})\\rVert_{h}$ is numerically zero (for example, smaller than a fixed tolerance such as $10^{-14}$), define $r=0$.\n\nYour program must implement this projection and compute $r$ for each of the following test cases, covering diverse regimes including linear and nonlinear constraints, coarse and fine grids, and different source amplitudes. For each case, use the interior grid size $N$, initial amplitude $\\varepsilon$, nonlinearity parameter $\\beta$, and source parameters $A$, $B$, $\\sigma$:\n\n1. $N=32$, $\\varepsilon=0.1$, $\\beta=1.0$, $A=1.0$, $B=0.5$, $\\sigma=0.15$.\n2. $N=8$, $\\varepsilon=0.1$, $\\beta=1.0$, $A=1.0$, $B=0.5$, $\\sigma=0.15$.\n3. $N=32$, $\\varepsilon=0.0$, $\\beta=1.0$, $A=1.0$, $B=0.5$, $\\sigma=0.15$.\n4. $N=32$, $\\varepsilon=0.1$, $\\beta=0.0$, $A=1.0$, $B=0.5$, $\\sigma=0.15$.\n5. $N=64$, $\\varepsilon=0.2$, $\\beta=10.0$, $A=0.5$, $B=1.0$, $\\sigma=0.10$.\n\nYour program should produce a single line of output containing the five reduction ratios as a comma-separated list enclosed in square brackets, with each ratio expressed as a decimal number rounded to six digits after the decimal point (for example, $[0.123456,0.000001,0.987654,0.100000,0.250000]$). No angles or physical units are involved in this problem. Use precise floating-point arithmetic to compute the norms and solutions to the linear systems that arise from the elliptic equations. Ensure scientific realism by solving the linear system exactly using an appropriate method for sparse, symmetric positive definite systems.", "solution": "The problem requires the implementation of a single constraint-projection step for a simplified Hamiltonian constraint equation from numerical relativity. This step is equivalent to one iteration of the Newton-Raphson method for solving a nonlinear elliptic partial differential equation. The core of the task is to derive and discretize the linearized equation for the correction, solve the resulting linear system, and evaluate the reduction in the constraint violation.\n\nFirst, we derive the elliptic equation for the correction term $\\delta\\phi$. The Hamiltonian constraint functional is given as\n$$\nH(\\phi) = -8\\,\\Delta \\phi + \\beta\\,\\phi^5 - S(x,y).\n$$\nWe are given an an initial state for the conformal factor, $\\phi_0$, which does not necessarily satisfy the constraint, meaning $H(\\phi_0) \\neq 0$. We seek a correction $\\delta\\phi$ such that the new field $\\phi = \\phi_0 + \\delta\\phi$ is a better approximation to a solution, i.e., $H(\\phi_0 + \\delta\\phi) \\approx 0$. To find $\\delta\\phi$, we linearize the functional $H(\\phi)$ around $\\phi_0$ by taking its Fréchet derivative. The expansion of $H(\\phi_0 + \\delta\\phi)$ for a small $\\delta\\phi$ is:\n$$\nH(\\phi_0 + \\delta\\phi) = -8\\,\\Delta (\\phi_0 + \\delta\\phi) + \\beta\\,(\\phi_0 + \\delta\\phi)^5 - S(x,y).\n$$\nUsing the binomial expansion for the nonlinear term, $(\\phi_0 + \\delta\\phi)^5 = \\phi_0^5 + 5\\phi_0^4\\delta\\phi + \\mathcal{O}((\\delta\\phi)^2)$, and retaining terms up to first order in $\\delta\\phi$, we get:\n$$\nH(\\phi_0 + \\delta\\phi) \\approx \\left(-8\\,\\Delta \\phi_0 + \\beta\\,\\phi_0^5 - S\\right) + \\left(-8\\,\\Delta(\\delta\\phi) + 5\\beta\\,\\phi_0^4\\delta\\phi\\right).\n$$\nThis expression can be written as $H(\\phi_0 + \\delta\\phi) \\approx H(\\phi_0) + L_{\\phi_0}[\\delta\\phi]$, where $L_{\\phi_0}$ is the linearized operator acting on the correction $\\delta\\phi$:\n$$\nL_{\\phi_0}[\\delta\\phi] = -8\\,\\Delta(\\delta\\phi) + 5\\beta\\,\\phi_0^4\\delta\\phi.\n$$\nThe constraint projection equation sets the linearized expression for $H(\\phi_0 + \\delta\\phi)$ to zero:\n$$\nL_{\\phi_0}[\\delta\\phi] = -H(\\phi_0).\n$$\nSubstituting the expressions for $L_{\\phi_0}$ and $H(\\phi_0)$, we obtain the elliptic partial differential equation for the correction $\\delta\\phi$:\n$$\n-8\\,\\Delta(\\delta\\phi) + 5\\beta\\,\\phi_0^4\\,\\delta\\phi = -(-8\\,\\Delta \\phi_0 + \\beta\\,\\phi_0^5 - S) = 8\\,\\Delta \\phi_0 - \\beta\\,\\phi_0^5 + S.\n$$\nThis equation must be solved for $\\delta\\phi$ on the unit square domain $[0,1]\\times[0,1]$ with homogeneous Dirichlet boundary conditions, $\\delta\\phi = 0$ on the boundary $\\partial([0,1]\\times[0,1])$, since the total field $\\phi$ must satisfy $\\phi=0$ on the boundary, and the initial field $\\phi_0$ is constructed to satisfy this.\n\nNext, we discretize this equation on a uniform grid. The domain is discretized with $N$ interior points in each dimension, leading to a grid spacing of $h = 1/(N+1)$. The interior grid points are $(x_i, y_j) = (ih, jh)$ for $i,j \\in \\{1, \\dots, N\\}$. A function $f(x,y)$ is represented by its values $f_{ij}$ on this grid. We use a second-order accurate five-point stencil for the Laplacian operator $\\Delta$:\n$$\n(\\Delta f)_{ij} \\approx \\frac{f_{i+1,j} + f_{i-1,j} + f_{i,j+1} + f_{i,j-1} - 4f_{ij}}{h^2}.\n$$\nApplying this discretization to the equation for $\\delta\\phi$ at each interior point $(i,j)$ yields a system of $N^2$ linear algebraic equations:\n$$\n-8\\frac{\\delta\\phi_{i+1,j} + \\delta\\phi_{i-1,j} + \\delta\\phi_{i,j+1} + \\delta\\phi_{i,j-1} - 4\\delta\\phi_{ij}}{h^2} + 5\\beta\\,\\phi_{0,ij}^4\\,\\delta\\phi_{ij} = -H(\\phi_0)_{ij}.\n$$\nHere, $\\delta\\phi_{ij}$ are the unknowns, $\\phi_{0,ij}$ are the known values of the initial field, and $H(\\phi_0)_{ij}$ is the discretized residual of the original constraint, calculated as\n$$\nH(\\phi_0)_{ij} = -8(\\Delta\\phi_0)_{ij} + \\beta\\,\\phi_{0,ij}^5 - S_{ij},\n$$\nwhere $(\\Delta\\phi_0)_{ij}$ is also computed using the five-point stencil. The homogeneous Dirichlet boundary conditions are enforced by setting $\\phi_0$ and $\\delta\\phi$ to $0$ for any index $i$ or $j$ equal to $0$ or $N+1$.\n\nThis system of equations can be written in matrix form as $M \\vec{d} = \\vec{b}$, where $\\vec{d}$ is a vector of length $N^2$ formed by flattening the grid of unknowns $\\delta\\phi_{ij}$, and $\\vec{b}$ is a vector of the same size formed by flattening $-H(\\phi_0)_{ij}$. The matrix $M$ is a sparse, symmetric, and positive-definite matrix of size $N^2 \\times N^2$. Its structure arises from the discretized operator $L_{\\phi_0}$. The diagonal entries are $(\\frac{32}{h^2} + 5\\beta\\,\\phi_{0,ij}^4)$, and the non-zero off-diagonal entries are $-\\frac{8}{h^2}$, corresponding to the four nearest neighbors on the grid. Due to its properties, this linear system can be reliably and efficiently solved for $\\vec{d}$.\n\nThe overall algorithm to compute the reduction ratio $r$ for a given set of parameters is as follows:\n1.  Construct the $N \\times N$ interior grid and evaluate the initial field $\\phi_{0,ij}$ and the source function $S_{ij}$ at each grid point.\n2.  Compute the discrete Laplacian of the initial field, $(\\Delta\\phi_0)_{ij}$, using a padded grid to enforce boundary conditions.\n3.  Compute the initial Hamiltonian residual field $H(\\phi_0)_{ij}$.\n4.  Calculate the discrete $L^2$ norm of the initial residual, $\\lVert H(\\phi_0)\\rVert_h = \\sqrt{h^2 \\sum_{i,j=1}^N (H(\\phi_0)_{ij})^2}$. If this norm is less than the tolerance $10^{-14}$, the ratio $r$ is defined as $0$.\n5.  Otherwise, construct the $N^2 \\times N^2$ sparse matrix $M$ representing the discretized linear operator $L_{\\phi_0}$ and the right-hand side vector $\\vec{b}$ by flattening $-H(\\phi_0)_{ij}$.\n6.  Solve the linear system $M \\vec{d} = \\vec{b}$ for the flattened correction vector $\\vec{d}$.\n7.  Reshape $\\vec{d}$ into an $N \\times N$ matrix representing the correction $\\delta\\phi_{ij}$.\n8.  Compute the updated field $\\phi_{\\text{after}, ij} = \\phi_{0,ij} + \\delta\\phi_{ij}$.\n9.  Compute the final Hamiltonian residual $H(\\phi_{\\text{after}})$ by applying the discrete Hamiltonian operator to $\\phi_{\\text{after}}$.\n10. Calculate the norm of the final residual, $\\lVert H(\\phi_{\\text{after}})\\rVert_h$.\n11. The reduction ratio is $r = \\lVert H(\\phi_{\\text{after}})\\rVert_h / \\lVert H(\\phi_0)\\rVert_h$.\n\nThis procedure is applied to each test case to determine the effectiveness of the constraint projection step. For the linear case $\\beta=0$, this single step is expected to solve the equation exactly, yielding a final residual and ratio of approximately zero, limited only by floating-point precision. For nonlinear cases, the ratio quantifies the quadratic convergence characteristic of a Newton-Raphson step.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import diags, identity, kron\nfrom scipy.sparse.linalg import spsolve\n\ndef compute_hamiltonian(phi_interior, S_interior, beta, h, N):\n    \"\"\"Computes the discrete Hamiltonian residual H(phi).\"\"\"\n    phi_padded = np.zeros((N + 2, N + 2))\n    phi_padded[1:-1, 1:-1] = phi_interior\n    \n    # Second-order central difference for the Laplacian\n    lap_phi = (phi_padded[2:, 1:-1] + phi_padded[:-2, 1:-1] +\n               phi_padded[1:-1, 2:] + phi_padded[1:-1, :-2] -\n               4 * phi_interior) / (h**2)\n               \n    # H(phi) = -8*Delta(phi) + beta*phi^5 - S\n    H_val = -8 * lap_phi + beta * (phi_interior**5) - S_interior\n    return H_val\n\ndef compute_norm(H_val, h):\n    \"\"\"Computes the discrete L2 norm of the residual.\"\"\"\n    # norm = sqrt(h^2 * sum(H_ij^2)) = h * ||H||_Frobenius\n    return h * np.linalg.norm(H_val)\n\ndef compute_ratio_for_case(N, epsilon, beta, A, B, sigma):\n    \"\"\"\n    Solves a single test case for the constraint projection problem.\n    \"\"\"\n    h = 1.0 / (N + 1)\n    x = np.linspace(h, 1.0 - h, N)\n    y = np.linspace(h, 1.0 - h, N)\n    xx, yy = np.meshgrid(x, y, indexing='xy')\n\n    # Define initial conformal factor phi_0 and source S on the interior grid\n    phi0_interior = epsilon * np.sin(np.pi * xx) * np.sin(np.pi * yy)\n    S_interior = A * np.sin(2 * np.pi * xx) * np.sin(2 * np.pi * yy) + \\\n                 B * np.exp(-((xx - 0.5)**2 + (yy - 0.5)**2) / (2 * sigma**2))\n\n    # Calculate Hamiltonian residual and norm before projection\n    H_before = compute_hamiltonian(phi0_interior, S_interior, beta, h, N)\n    norm_before = compute_norm(H_before, h)\n\n    # Handle the case where the initial residual is numerically zero\n    if norm_before < 1e-14:\n        return 0.0\n\n    # Set up the linear system M * d_phi = -H_before for the correction d_phi\n    \n    # The matrix M represents the linearized operator L = -8*Delta + 5*beta*phi_0^4\n    # We construct it using the Kronecker product for the 2D Laplacian.\n    N2 = N * N\n    # 1D Laplacian matrix (size N x N)\n    D1_matrix = diags([1, -2, 1], [-1, 0, 1], shape=(N, N))\n    I_N = identity(N)\n    \n    # 2D Laplacian matrix (size N^2 x N^2)\n    Lap_matrix_2D = (kron(I_N, D1_matrix) + kron(D1_matrix, I_N)) / h**2\n    \n    # Operator matrix M\n    M = -8 * Lap_matrix_2D\n    \n    # Add the potential term (diagonal matrix)\n    potential_term_flat = 5 * beta * (phi0_interior.flatten()**4)\n    M += diags(potential_term_flat, 0)\n    \n    # Right-hand side vector\n    b = -H_before.flatten()\n    \n    # Solve the sparse linear system for the correction d_phi\n    delta_phi_flat = spsolve(M, b)\n    delta_phi_interior = delta_phi_flat.reshape((N, N))\n    \n    # Update the field: phi_after = phi_0 + d_phi\n    phi_after_interior = phi0_interior + delta_phi_interior\n    \n    # Calculate Hamiltonian residual and norm after projection\n    H_after = compute_hamiltonian(phi_after_interior, S_interior, beta, h, N)\n    norm_after = compute_norm(H_after, h)\n    \n    # Compute the reduction ratio\n    ratio = norm_after / norm_before\n    \n    return ratio\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, epsilon, beta, A, B, sigma)\n        (32, 0.1, 1.0, 1.0, 0.5, 0.15),\n        (8, 0.1, 1.0, 1.0, 0.5, 0.15),\n        (32, 0.0, 1.0, 1.0, 0.5, 0.15),\n        (32, 0.1, 0.0, 1.0, 0.5, 0.15),\n        (64, 0.2, 10.0, 0.5, 1.0, 0.10)\n    ]\n\n    results = []\n    for case in test_cases:\n        ratio = compute_ratio_for_case(*case)\n        results.append(f\"{ratio:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n\n```", "id": "3470000"}]}