{"hands_on_practices": [{"introduction": "Numerical relativity waveform catalogs are remarkably efficient, containing a few thousand simulations that can model millions of potential gravitational-wave signals. This efficiency hinges on a fundamental property of Einstein's equations: scale invariance. This practice explores this principle, showing how a single simulation of a binary with a given mass ratio can be rescaled to represent any binary with the same mass ratio, regardless of its total mass $M$. By deriving the relationship between the chirp mass $\\mathcal{M}$, total mass $M$, and symmetric mass ratio $\\eta$, you will gain a first-principles understanding of how catalogs are constructed and used.", "problem": "Consider a quasi-circular binary black hole system used to construct entries in a Numerical Relativity (NR) waveform catalog. Let the component masses be $m_1$ and $m_2$, and define the total mass $M$ and symmetric mass ratio $\\eta$ by $M = m_1 + m_2$ and $\\eta = \\frac{m_1 m_2}{M^2}$. The chirp mass, widely used in gravitational-wave data analysis, is defined by $\\mathcal{M} = \\frac{(m_1 m_2)^{3/5}}{(m_1 + m_2)^{1/5}}$. Using only these definitions and the scale-free character of vacuum General Relativity (GR) in geometrized units where $G = c = 1$, derive an explicit expression for $\\mathcal{M}$ in terms of $\\eta$ and $M$. Then, explain why rescaling $M \\to \\alpha M$ for any positive constant $\\alpha$ leaves the dimensionless NR waveform $h$ invariant up to a rescaling of the time coordinate and a shift of the phase origin when the waveform is expressed in terms of the dimensionless time $\\hat{t} = t/M$. For the final answer, provide only the explicit analytic expression for $\\mathcal{M}$ in terms of $\\eta$ and $M$.", "solution": "The problem asks for two main tasks: first, to derive an expression for the chirp mass $\\mathcal{M}$ in terms of the total mass $M$ and the symmetric mass ratio $\\eta$; second, to explain the scaling properties of gravitational waveforms from binary black holes based on the scale-free nature of vacuum General Relativity.\n\nFirst, we address the derivation of the relationship between $\\mathcal{M}$, $M$, and $\\eta$. The provided definitions are:\nTotal mass:\n$$M = m_1 + m_2$$\nSymmetric mass ratio:\n$$\\eta = \\frac{m_1 m_2}{M^2}$$\nChirp mass:\n$$\\mathcal{M} = \\frac{(m_1 m_2)^{3/5}}{(m_1 + m_2)^{1/5}}$$\n\nWe can begin the derivation by substituting the definition of the total mass $M$ into the denominator of the expression for the chirp mass $\\mathcal{M}$:\n$$\\mathcal{M} = \\frac{(m_1 m_2)^{3/5}}{M^{1/5}}$$\nNext, we rearrange the definition of the symmetric mass ratio $\\eta$ to express the product of the component masses, $m_1 m_2$, in terms of $\\eta$ and $M$:\n$$m_1 m_2 = \\eta M^2$$\nNow, we substitute this expression for the product $m_1 m_2$ into the numerator of our equation for $\\mathcal{M}$:\n$$\\mathcal{M} = \\frac{(\\eta M^2)^{3/5}}{M^{1/5}}$$\nUsing the properties of exponents, we can simplify this expression. The term in the numerator becomes $(\\eta M^2)^{3/5} = \\eta^{3/5} (M^2)^{3/5} = \\eta^{3/5} M^{6/5}$. Substituting this back gives:\n$$\\mathcal{M} = \\frac{\\eta^{3/5} M^{6/5}}{M^{1/5}}$$\nFinally, we combine the terms involving $M$ by subtracting the exponent in the denominator from the exponent in the numerator:\n$$\\mathcal{M} = \\eta^{3/5} M^{(6/5 - 1/5)} = \\eta^{3/5} M^{5/5} = \\eta^{3/5} M$$\nThis gives the explicit expression for the chirp mass $\\mathcal{M}$ in terms of the symmetric mass ratio $\\eta$ and the total mass $M$.\n\nSecond, we explain the scaling properties of the numerical relativity (NR) waveform. The problem is set in the framework of vacuum General Relativity (GR) in geometrized units, where $G=c=1$. The governing equations are the vacuum Einstein Field Equations (EFE):\n$$R_{\\mu\\nu} = 0$$\nwhere $R_{\\mu\\nu}$ is the Ricci curvature tensor, which depends on the spacetime metric $g_{\\mu\\nu}$ and its derivatives. A key feature of the vacuum EFE is that they are scale-free. This means that if a metric $g_{\\mu\\nu}(x^\\alpha)$ is a solution describing a system with a characteristic mass (and thus length) scale $M$, then the metric $\\tilde{g}_{\\mu\\nu}(x^\\alpha) = g_{\\mu\\nu}(x^\\alpha / \\alpha)$ for any positive constant $\\alpha$ is also a solution to the EFE. This new solution, $\\tilde{g}_{\\mu\\nu}$, describes a system that is physically identical to the original but with all its characteristic length and time scales stretched by the factor $\\alpha$. Therefore, it corresponds to a system with total mass $\\alpha M$.\n\nThe gravitational waveform, $h$, represents a perturbation of the spacetime metric far from the source. For a source at a luminosity distance $r$, the amplitude of the physical strain $h_{\\text{phys}}$ is proportional to the total mass $M$ and inversely proportional to the distance $r$. The temporal evolution of the waveform (e.g., the orbital frequency and its rate of change) is determined by the characteristic timescale of the system, which is proportional to the total mass $M$.\nConsequently, for a binary black hole system characterized by total mass $M$ and an intrinsic parameter like the symmetric mass ratio $\\eta$, the physical waveform must take the following structural form:\n$$h_{\\text{phys}}(t, r; M, \\eta) = \\frac{M}{r} \\mathcal{F}\\left(\\frac{t}{M}, \\eta\\right)$$\nHere, $\\mathcal{F}$ is a dimensionless function that captures the complex dynamics of the inspiral, merger, and ringdown. Its form depends only on the mass ratio $\\eta$ (and spins, if included) and the dimensionless time $\\hat{t} = t/M$.\n\nNow, consider the impact of rescaling the total mass, $M \\to M' = \\alpha M$, while keeping $\\eta$ constant. The new physical waveform, $h'_{\\text{phys}}$, will be given by:\n$$h'_{\\text{phys}}(t', r; M', \\eta) = \\frac{M'}{r} \\mathcal{F}\\left(\\frac{t'}{M'}, \\eta\\right) = \\frac{\\alpha M}{r} \\mathcal{F}\\left(\\frac{t'}{\\alpha M}, \\eta\\right)$$\nThis demonstrates that the new waveform is simply an amplified and time-stretched version of the original one.\n\nNumerical relativity catalogs are designed to exploit this property. They provide a \"dimensionless NR waveform,\" which we can denote as $h_{\\text{NR}}$, by factoring out the explicit dependence on $M$ and $r$. This is typically defined as:\n$$h_{\\text{NR}} = \\frac{r}{M} h_{\\text{phys}}$$\nApplying this definition to our expression for $h_{\\text{phys}}$ gives:\n$$h_{\\text{NR}}(t; M, \\eta) = \\frac{r}{M} \\left( \\frac{M}{r} \\mathcal{F}\\left(\\frac{t}{M}, \\eta\\right) \\right) = \\mathcal{F}\\left(\\frac{t}{M}, \\eta\\right) = \\mathcal{F}(\\hat{t}, \\eta)$$\nThe final expression shows that the dimensionless NR waveform, when expressed as a function of the dimensionless time $\\hat{t} = t/M$, is a universal function $\\mathcal{F}$ that depends only on the intrinsic parameters of the binary (like $\\eta$) and is completely independent of the overall mass scale $M$. This is why rescaling $M \\to \\alpha M$ leaves this dimensionless representation invariant. The phrase \"up to a rescaling of the time coordinate\" in the problem statement refers to the fact that the physical time $t$ for a system of mass $M$ corresponds to a physical time $t'=\\alpha t$ for a system of mass $\\alpha M$ to reach the same evolutionary state. Once both are mapped to their respective dimensionless times, $\\hat{t}=t/M$ and $\\hat{t}'=t'/(\\alpha M)$, the waveforms are identical. The freedom to \"shift the phase origin\" is an additional degree of freedom related to the initial orbital phase of the binary, which is arbitrary and must be accounted for when comparing any two waveforms, independently of the mass scaling.", "answer": "$$\\boxed{\\eta^{3/5} M}$$", "id": "3481818"}, {"introduction": "While catalogs provide ready-to-use strain waveforms $h(t)$, the raw output of many numerical relativity codes is actually the Newman-Penrose curvature scalar $\\Psi_4(t)$, related to the strain by $\\Psi_4 = \\ddot{h}$. Recovering the physical strain requires a robust signal processing pipeline to perform a double integration without introducing spurious drifts or amplifying low-frequency noise. This hands-on coding exercise challenges you to build such a pipeline, implementing standard techniques like windowing, detrending, and filtering to reliably convert raw $\\Psi_4$ data into a clean, physical strain waveform $h(t)$.", "problem": "You are given a complex time series representing the Newman–Penrose scalar $\\Psi_4(t)$ from a Numerical Relativity (NR) waveform, where the complex strain is $h(t) = h_+(t) - i h_\\times(t)$. The fundamental relation connecting these quantities is $\\Psi_4(t) = \\ddot{h}(t)$, where the overdot denotes differentiation with respect to time. In a time-domain pipeline, recovering $h(t)$ from $\\Psi_4(t)$ requires two numerical integrations and a principled choice of integration constants that suppress secular drifts. Your task is to implement and test a robust time-domain method that:\n- Applies an edge window to $\\Psi_4(t)$ to reduce spectral leakage in subsequent processing.\n- Performs two time-domain integrations using the trapezoidal rule to obtain a preliminary strain $h_0(t)$.\n- Chooses integration constants to minimize secular drift by optimally removing the linear trend from $h_0(t)$ in the least-squares sense.\n- Applies a zero-phase high-pass filter to the detrended $h_0(t)$ to suppress remaining low-frequency contamination without distorting the physical band of interest.\n\nStarting point and constraints:\n- The complex strain is defined as $h(t) = h_+(t) - i h_\\times(t)$, and $\\Psi_4(t) = \\ddot{h}(t)$. The output strain must be dimensionless.\n- The time $t$ is in seconds, frequency $f$ is in Hertz, and the angular phase $\\phi(t)$ is in radians. All angles must be treated in radians.\n- The numerical integration must be performed in the time domain using the cumulative trapezoidal rule.\n- The edge window must be a smooth taper (for example, a Tukey window) characterized by a fractional taper parameter $\\alpha \\in [0,1]$ that governs the cosine-tapered fraction at each end.\n- The high-pass filter must be a Butterworth design with specified order and cutoff frequency $f_c$ in Hertz, applied with zero-phase filtering.\n- The integration constants must be chosen to minimize the $L^2$ norm of the linear trend of the twice-integrated signal by removing the best-fit line $a t + b$ from $h_0(t)$, performed separately for the real and imaginary parts.\n\nSynthetic data to be generated for testing:\n- For each test case, construct a physically plausible complex strain $h_{\\text{true}}(t)$ and then compute $\\Psi_4(t)$ from $h_{\\text{true}}(t)$ via two analytic time derivatives. Contaminate $\\Psi_4(t)$ with low-frequency artifacts (a constant offset, a linear trend, and a low-frequency sinusoid) to emulate extraction and numerical errors typical in NR catalogs. Then apply your method to recover $h(t)$ from the contaminated $\\Psi_4(t)$.\n\nModel families for $h_{\\text{true}}(t)$:\n1. A linear-frequency chirp: $A(t) = A_0\\,(1 + \\beta t)$ and $f(t) = f_0 + \\alpha t$, with phase $\\phi(t) = 2\\pi \\left(f_0 t + \\tfrac{1}{2}\\alpha t^2\\right)$. Define $h_+(t) = A(t)\\cos\\phi(t)$ and $h_\\times(t) = A(t)\\sin\\phi(t)$ so that $h(t) = A(t)e^{-i \\phi(t)}$.\n2. A damped sinusoid (ringdown-like): $A(t) = A_0 e^{-t/\\tau}$ and $\\phi(t) = 2\\pi f t$, with the same polarization convention as above.\n\nAnalytic computation of $\\Psi_4(t)$:\n- For $h(t) = A(t)e^{-i\\phi(t)}$, its second derivative is\n$$\n\\ddot{h}(t) = \\left[A''(t) - 2 i A'(t)\\,\\phi'(t) - i A(t)\\,\\phi''(t) - A(t)\\,(\\phi'(t))^2\\right] e^{-i\\phi(t)},\n$$\nwhere primes denote time derivatives. Use this expression to generate the uncontaminated $\\Psi_4(t)$ from $h_{\\text{true}}(t)$.\n\nContamination model for $\\Psi_4(t)$:\n- Add a constant offset $c_0$, a linear trend $c_1 t$, and a low-frequency sinusoid $s_A \\sin(2\\pi f_{\\text{low}} t)$ to the complex $\\Psi_4(t)$ to simulate realistic low-frequency pollution.\n\nQuality metric:\n- For each test case, compute the relative root-mean-square (RMS) errors for the recovered $h(t)$ separately for the plus and cross polarizations, and report the average of the two:\n$$\n\\varepsilon_+(t) = \\frac{\\sqrt{\\tfrac{1}{N}\\sum_{k=1}^N \\left(h_{+,k}^{\\text{rec}} - h_{+,k}^{\\text{true}}\\right)^2}}{\\sqrt{\\tfrac{1}{N}\\sum_{k=1}^N \\left(h_{+,k}^{\\text{true}}\\right)^2}}, \\quad\n\\varepsilon_\\times(t) = \\frac{\\sqrt{\\tfrac{1}{N}\\sum_{k=1}^N \\left(h_{\\times,k}^{\\text{rec}} - h_{\\times,k}^{\\text{true}}\\right)^2}}{\\sqrt{\\tfrac{1}{N}\\sum_{k=1}^N \\left(h_{\\times,k}^{\\text{true}}\\right)^2}},\n$$\nand return $\\varepsilon = \\tfrac{1}{2}\\left(\\varepsilon_+ + \\varepsilon_\\times\\right)$ as a single float per test case.\n\nTest suite:\n- Implement the following parameter sets. All quantities are in stated units, and amplitudes are dimensionless.\n1. Chirp case: duration $T = 4.0$, sampling rate $f_s = 2048$, $f_0 = 30$, $\\alpha = 40$, $A_0 = 1\\times 10^{-22}$, $\\beta = 0.2$, contamination $(c_0 = 5\\times 10^{-24}, c_1 = 1\\times 10^{-24}, s_A = 1\\times 10^{-23}, f_{\\text{low}} = 2)$, window parameter $\\alpha_{\\text{win}} = 0.1$, high-pass cutoff $f_c = 10$, filter order $n = 4$.\n2. Damped sinusoid: duration $T = 2.0$, sampling rate $f_s = 4096$, $f = 150$, $\\tau = 0.5$, $A_0 = 1\\times 10^{-22}$, contamination $(c_0 = 1\\times 10^{-24}, c_1 = -2\\times 10^{-24}, s_A = 5\\times 10^{-25}, f_{\\text{low}} = 1)$, window parameter $\\alpha_{\\text{win}} = 0.05$, high-pass cutoff $f_c = 10$, filter order $n = 4$.\n3. Low-frequency boundary: duration $T = 3.0$, sampling rate $f_s = 1024$, $f_0 = 5$, $\\alpha = 0$, $A_0 = 5\\times 10^{-22}$, $\\beta = 0.0$, contamination $(c_0 = 5\\times 10^{-24}, c_1 = 2\\times 10^{-24}, s_A = 2\\times 10^{-23}, f_{\\text{low}} = 0.5)$, window parameter $\\alpha_{\\text{win}} = 0.1$, high-pass cutoff $f_c = 2$, filter order $n = 4$.\n4. Short-duration segment: duration $T = 0.5$, sampling rate $f_s = 1024$, $f_0 = 50$, $\\alpha = 0$, $A_0 = 2\\times 10^{-22}$, $\\beta = 0.0$, contamination $(c_0 = 1\\times 10^{-24}, c_1 = 1\\times 10^{-24}, s_A = 1\\times 10^{-23}, f_{\\text{low}} = 1)$, window parameter $\\alpha_{\\text{win}} = 0.2$, high-pass cutoff $f_c = 5$, filter order $n = 4$.\n\nProgram requirements:\n- Construct $h_{\\text{true}}(t)$ according to the specified model for each test case, compute uncontaminated $\\Psi_4(t)$ analytically, add contaminations, and apply the robust recovery pipeline described above to obtain $h^{\\text{rec}}(t)$.\n- Compute the average relative RMS error $\\varepsilon$ for each test case as defined.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[\\varepsilon_1,\\varepsilon_2,\\varepsilon_3,\\varepsilon_4]$), with each value printed as a float.\n\nAnswer all quantities with the stated units: time in seconds, frequency in Hertz, strain dimensionless, angles in radians. Express the final numerical outputs as floats.", "solution": "The problem as stated is scientifically grounded, well-posed, and objective. It presents a standard, albeit non-trivial, signal processing task from the field of gravitational wave data analysis, specifically concerning the recovery of the complex strain $h(t)$ from the Newman–Penrose scalar $\\Psi_4(t)$ obtained from numerical relativity simulations. All parameters, models, and procedures are specified with sufficient clarity and precision to permit a unique and verifiable solution.\n\nThe core of the problem is the numerical integration of the differential equation $\\ddot{h}(t) = \\Psi_4(t)$, where the overdot denotes differentiation with respect to time $t$. A naive double integration of noisy data is numerically unstable, leading to large secular drifts. The problem specifies a robust pipeline to mitigate these issues, which we will implement. The procedure involves generating synthetic test data, applying the recovery pipeline, and evaluating the accuracy of the result.\n\n**1. Synthetic Data Generation**\n\nTo test the recovery algorithm, we first generate a ground-truth complex strain $h_{\\text{true}}(t)$ and from it, the corresponding $\\Psi_4(t)$.\n\n**1.1. True Waveform Models ($h_{\\text{true}}(t)$)**\nThe complex strain is defined as $h(t) = h_+(t) - i h_\\times(t)$, and is modeled by an amplitude $A(t)$ and phase $\\phi(t)$ as $h(t) = A(t)e^{-i\\phi(t)}$. Two models are specified:\n- A linear-frequency chirp, representing the inspiral phase of a binary system:\n  - Amplitude: $A(t) = A_0(1 + \\beta t)$\n  - Instantaneous frequency: $f(t) = f_0 + \\alpha t$\n  - Phase: $\\phi(t) = \\int_0^t 2\\pi f(\\tau) d\\tau = 2\\pi \\left(f_0 t + \\frac{1}{2}\\alpha t^2\\right)$\n- A damped sinusoid, representing the ringdown phase:\n  - Amplitude: $A(t) = A_0 e^{-t/\\tau}$\n  - Phase: $\\phi(t) = 2\\pi f t$\n\n**1.2. Analytic $\\Psi_4(t)$ Calculation**\nThe uncontaminated Newman-Penrose scalar is the second time derivative of $h(t)$, given by:\n$$\n\\Psi_4(t) = \\ddot{h}(t) = \\left[ A''(t) - A(t)(\\phi'(t))^2 - i \\left( 2A'(t)\\phi'(t) + A(t)\\phi''(t) \\right) \\right] e^{-i\\phi(t)}\n$$\nwhere primes denote derivatives with respect to time. We compute these derivatives analytically for each model:\n- For the chirp model:\n  - $A'(t) = A_0\\beta$\n  - $A''(t) = 0$\n  - $\\phi'(t) = 2\\pi(f_0 + \\alpha t)$\n  - $\\phi''(t) = 2\\pi\\alpha$\n- For the damped sinusoid model:\n  - $A'(t) = -A(t)/\\tau$\n  - $A''(t) = A(t)/\\tau^2$\n  - $\\phi'(t) = 2\\pi f$\n  - $\\phi''(t) = 0$\n\n**1.3. Contamination**\nNumerical relativity waveforms often contain low-frequency errors from extraction and numerical artifacts. We simulate this by adding a real-valued contamination signal $C(t)$ to the true $\\Psi_4(t)$:\n$$\nC(t) = c_0 + c_1 t + s_A \\sin(2\\pi f_{\\text{low}} t)\n$$\nThe contaminated signal is then $\\Psi_{4, \\text{cont}}(t) = \\Psi_{4, \\text{true}}(t) + C(t)$. This adds the contamination term to the real part of $\\Psi_4(t)$, while leaving the imaginary part unchanged.\n\n**2. Waveform Recovery Pipeline**\n\nThe core task is to recover $h(t)$ from the contaminated $\\Psi_{4, \\text{cont}}(t)$.\n\n**2.1. Windowing**\nThe first step is to apply a Tukey window $w(t)$ to the data. This is a smooth tapering function that gently brings the signal amplitude to zero at its boundaries. Its purpose is to reduce spectral leakage that can arise from the implicit periodicity assumed by Fourier-based methods and to suppress boundary artifacts from the subsequent integration and filtering steps. The windowed signal is $\\Psi_{4, \\text{win}}(t) = \\Psi_{4, \\text{cont}}(t) \\cdot w(t)$. The window is characterized by a fractional taper parameter $\\alpha_{\\text{win}}$.\n\n**2.2. Numerical Integration**\nWe perform two successive time-domain integrations using the cumulative trapezoidal rule. This approximates the integral of a function $y(t)$ as $\\int_0^t y(\\tau) d\\tau$.\n$$\n\\dot{h}_0(t) = \\int_0^t \\Psi_{4, \\text{win}}(\\tau) d\\tau\n$$\n$$\nh_0(t) = \\int_0^t \\dot{h}_0(\\tau) d\\tau\n$$\nThese numerical integrations are performed assuming zero initial conditions, resulting in a preliminary strain $h_0(t)$.\n\n**2.3. Drift Removal via Detrending**\nThe exact solution for $h(t)$ from $\\ddot{h}(t) = \\Psi_4(t)$ is only defined up to two integration constants, $C_1$ and $C_2$, which introduce an arbitrary linear drift of the form $C_1 t + C_2$. The goal is to determine these constants such that the recovered waveform is physically meaningful (i.e., non-drifting). The specified method is to remove the best-fit linear trend from the preliminary strain $h_0(t)$. This is equivalent to finding coefficients $a$ and $b$ that minimize the $L^2$ norm $\\|h_0(t) - (at+b)\\|^2$. This procedure is applied separately to the real and imaginary parts of $h_0(t)$. The detrended signal is $h_{\\text{detrend}}(t) = h_0(t) - (a_{\\text{Re}}t + b_{\\text{Re}}) - i(a_{\\text{Im}}t + b_{\\text{Im}})$.\n\n**2.4. High-Pass Filtering**\nEven after detrending, low-frequency artifacts persist. These arise from the integration of the added contamination $C(t)$ (e.g., $c_0$ integrates to a quadratic term, $c_1 t$ to a cubic term) and the low-frequency sinusoid. A high-pass filter is applied to remove this residual contamination. A Butterworth filter of order $n$ and cutoff frequency $f_c$ is specified. To prevent introducing phase distortion into the waveform, a zero-phase filtering technique (`filtfilt`) is used. This is achieved by applying the filter once forward and then once backward, which cancels out the phase shift. This yields the final recovered complex strain, $h^{\\text{rec}}(t)$.\n\n**3. Quality Metric**\n\nTo assess the fidelity of the recovery, we compute the average relative root-mean-square (RMS) error. First, we extract the plus ($h_+$) and cross ($h_\\times$) polarizations from both the true and recovered complex strains using the specified convention $h(t) = h_+(t) - i h_\\times(t)$, which implies $h_+(t) = \\text{Re}\\{h(t)\\}$ and $h_\\times(t) = -\\text{Im}\\{h(t)\\}$. The relative RMS errors are:\n$$\n\\varepsilon_+ = \\frac{\\text{RMS}(h_{+}^{\\text{rec}} - h_{+}^{\\text{true}})}{\\text{RMS}(h_{+}^{\\text{true}})} \\quad \\text{and} \\quad \\varepsilon_\\times = \\frac{\\text{RMS}(h_{\\times}^{\\text{rec}} - h_{\\times}^{\\text{true}})}{\\text{RMS}(h_{\\times}^{\\text{true}})}\n$$\nwhere $\\text{RMS}(x) = \\sqrt{\\frac{1}{N}\\sum_{k=1}^N x_k^2}$. The final reported metric is the average of these two errors, $\\varepsilon = \\frac{1}{2}(\\varepsilon_+ + \\varepsilon_\\times)$.\n\nThis comprehensive procedure forms a robust algorithm for recovering gravitational waveforms from numerical relativity data, which is implemented in the provided code.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import cumulative_trapezoid\nfrom scipy.signal import windows, detrend, butter, filtfilt\n\ndef process_case(params):\n    \"\"\"\n    Processes a single test case for waveform recovery.\n    - Generates true waveform and Psi4.\n    - Adds contamination.\n    - Applies the recovery pipeline.\n    - Computes and returns the error metric.\n    \"\"\"\n    T = params['T']\n    fs = params['fs']\n    N = int(T * fs)\n    t = np.linspace(0.0, T, N, endpoint=False)\n\n    # 1. Generate true waveform h_true and its derivatives\n    if params['model'] == 'chirp':\n        f0, alpha_f, A0, beta = params['model_params']\n        \n        # Amplitude and its derivatives\n        A = A0 * (1.0 + beta * t)\n        A_d = A0 * beta * np.ones_like(t)\n        A_dd = np.zeros_like(t)\n\n        # Phase and its derivatives\n        phi = 2.0 * np.pi * (f0 * t + 0.5 * alpha_f * t**2)\n        phi_d = 2.0 * np.pi * (f0 + alpha_f * t)\n        phi_dd = 2.0 * np.pi * alpha_f * np.ones_like(t)\n\n    elif params['model'] == 'damped_sinusoid':\n        f, tau, A0 = params['model_params']\n        \n        # Amplitude and its derivatives\n        A = A0 * np.exp(-t / tau)\n        A_d = -A / tau\n        A_dd = A / (tau**2)\n\n        # Phase and its derivatives\n        phi = 2.0 * np.pi * f * t\n        phi_d = 2.0 * np.pi * f * np.ones_like(t)\n        phi_dd = np.zeros_like(t)\n\n    h_true = A * np.exp(-1j * phi)\n\n    # 2. Compute true Psi4 from analytic derivatives\n    psi4_true = (A_dd - A * (phi_d**2) - 1j * (2 * A_d * phi_d + A * phi_dd)) * np.exp(-1j * phi)\n\n    # 3. Add contamination\n    c0, c1, sA, f_low = params['cont']\n    contamination = c0 + c1 * t + sA * np.sin(2 * np.pi * f_low * t)\n    \n    # As per interpretation, the real-valued contamination is added to the complex signal.\n    # This effectively adds it to the real part: Re(z+r) = Re(z)+r, Im(z+r) = Im(z).\n    psi4_cont = psi4_true + contamination\n\n    # 4. Recovery Pipeline\n    # 4a. Windowing\n    win = windows.tukey(N, alpha=params['alpha_win'])\n    psi4_win = psi4_cont * win\n\n    # 4b. Integration (twice)\n    # The 'initial=0' argument ensures the output array has the same length N.\n    h_dot_0 = cumulative_trapezoid(psi4_win, x=t, initial=0)\n    h0 = cumulative_trapezoid(h_dot_0, x=t, initial=0)\n\n    # 4c. Detrending (removes linear trend from real and imag parts)\n    h0_detrend_real = detrend(h0.real, type='linear')\n    h0_detrend_imag = detrend(h0.imag, type='linear')\n    h0_detrend = h0_detrend_real + 1j * h0_detrend_imag\n\n    # 4d. High-pass filtering (zero-phase)\n    nyquist = 0.5 * fs\n    Wn = params['fc'] / nyquist\n    b, a = butter(params['n_order'], Wn, btype='highpass')\n    h_rec_real = filtfilt(b, a, h0_detrend.real)\n    h_rec_imag = filtfilt(b, a, h0_detrend.imag)\n    h_rec = h_rec_real + 1j * h_rec_imag\n\n    # 5. Calculate Quality Metric\n    # Extract polarizations: h = h_plus - i*h_cross\n    h_plus_true = h_true.real\n    h_cross_true = -h_true.imag\n    h_plus_rec = h_rec.real\n    h_cross_rec = -h_rec.imag\n\n    # RMS of true signals\n    rms_plus_true = np.sqrt(np.mean(h_plus_true**2))\n    rms_cross_true = np.sqrt(np.mean(h_cross_true**2))\n\n    # Relative RMS errors\n    if rms_plus_true > 0:\n        err_plus = np.sqrt(np.mean((h_plus_rec - h_plus_true)**2)) / rms_plus_true\n    else:\n        err_plus = 0.0\n\n    if rms_cross_true > 0:\n        err_cross = np.sqrt(np.mean((h_cross_rec - h_cross_true)**2)) / rms_cross_true\n    else:\n        err_cross = 0.0\n\n    return 0.5 * (err_plus + err_cross)\n\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: Chirp\n        {\n            'T': 4.0, 'fs': 2048,\n            'model': 'chirp',\n            'model_params': (30, 40, 1e-22, 0.2), # f0, alpha, A0, beta\n            'cont': (5e-24, 1e-24, 1e-23, 2), # c0, c1, sA, f_low\n            'alpha_win': 0.1, 'fc': 10, 'n_order': 4\n        },\n        # Case 2: Damped sinusoid\n        {\n            'T': 2.0, 'fs': 4096,\n            'model': 'damped_sinusoid',\n            'model_params': (150, 0.5, 1e-22), # f, tau, A0\n            'cont': (1e-24, -2e-24, 5e-25, 1), # c0, c1, sA, f_low\n            'alpha_win': 0.05, 'fc': 10, 'n_order': 4\n        },\n        # Case 3: Low-frequency boundary (chirp model with alpha=0, beta=0)\n        {\n            'T': 3.0, 'fs': 1024,\n            'model': 'chirp',\n            'model_params': (5, 0.0, 5e-22, 0.0), # f0, alpha, A0, beta\n            'cont': (5e-24, 2e-24, 2e-23, 0.5), # c0, c1, sA, f_low\n            'alpha_win': 0.1, 'fc': 2, 'n_order': 4\n        },\n        # Case 4: Short-duration segment (chirp model with alpha=0, beta=0)\n        {\n            'T': 0.5, 'fs': 1024,\n            'model': 'chirp',\n            'model_params': (50, 0.0, 2e-22, 0.0), # f0, alpha, A0, beta\n            'cont': (1e-24, 1e-24, 1e-23, 1), # c0, c1, sA, f_low\n            'alpha_win': 0.2, 'fc': 5, 'n_order': 4\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        error = process_case(case)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3481826"}, {"introduction": "No numerical simulation is perfect, and understanding the sources and magnitudes of error is crucial for using catalog waveforms in scientific analyses. This advanced practice guides you through the process of creating a complete error budget for a numerical relativity waveform, a critical step in assessing its fidelity. By systematically modeling, estimating, and propagating the primary sources of error—finite difference truncation, finite-radius extraction, and initial \"junk\" radiation—you will learn how to quantify the total modeling uncertainty in terms of the noise-weighted mismatch, the gold standard for waveform comparison in gravitational-wave astronomy.", "problem": "You are tasked with building a complete, runnable program that estimates and propagates error budgets for frequency-domain gravitational-wave strains from a numerical relativity waveform catalog. You will decompose the total modeling error into three contributions attributable to finite-difference truncation, finite-radius extraction/extrapolation, and initial-data transients (commonly called junk radiation). You must infer each contribution from multi-resolution and multi-radius data products and then propagate these contributions to the final mismatch using first-order error calculus. The analysis must be performed in the frequency domain with a fixed noise Power Spectral Density (PSD). \n\nBegin from the following core definitions and assumptions:\n\n- Numerical Relativity (NR) waveforms approximate the true strain through discrete spatial resolution and finite extraction radius. Let the true frequency-domain strain be denoted by $h_{\\mathrm{true}}(f)$, where $f$ is the frequency in hertz. The measured strains $h_{N,r}(f)$ at finite numerical resolution $N$ and finite extraction radius $r$ are modeled as small perturbations around $h_{\\mathrm{true}}(f)$.\n- The leading truncation error scales with the grid spacing $h \\sim 1/N$ as $h^p$ for some known convergence order $p$, so that the difference between two resolutions can be used to eliminate the unknown amplitude of the truncation error and infer the continuum limit at fixed $r$. \n- The finite-radius waveform can be modeled as a smooth function of $x=1/r$ that is analytic near $x=0$, enabling polynomial extrapolation to null infinity. \n- Junk radiation is modeled as an additive, low-frequency, windowed perturbation that is present in an “early” processed variant but absent in a “late” aggressively junk-suppressed variant, enabling its direct estimation by differencing the two.\n\nDefine the noise-weighted Hermitian inner product between two complex frequency-domain strains $a(f)$ and $b(f)$ as\n$$\n\\langle a, b \\rangle \\equiv 4\\,\\mathrm{Re}\\!\\left[\\sum_{k=0}^{K-1} \\frac{a(f_k)\\,b^*(f_k)}{S_n(f_k)}\\,\\Delta f\\right],\n$$\nwhere $S_n(f)$ is the one-sided noise Power Spectral Density (PSD), $f_k$ are uniformly spaced frequency samples with spacing $\\Delta f$, the star denotes complex conjugation, and $\\mathrm{Re}[\\cdot]$ extracts the real part. The squared norm is $\\|a\\|^2 \\equiv \\langle a,a\\rangle$. Assume that phases are measured in radians.\n\nFor each test case, you must:\n\n1) Construct a physically plausible “true” inspiral-dominated frequency-domain strain $h_{\\mathrm{true}}(f)$ using the stationary phase approximation amplitude and a leading-order phase,\n$$\nh_{\\mathrm{true}}(f) = A\\, f^{-7/6}\\,\\exp\\!\\bigl(i\\,\\phi(f)\\bigr), \\quad \\phi(f)=\\frac{3}{128}\\,(\\pi\\,M\\,f)^{-5/3},\n$$\nwith $A$ a constant amplitude and $M$ the total mass in seconds. Use the conversion $M = M_{\\odot}\\,T_{\\odot}$, with $T_{\\odot}=4.92549095\\times 10^{-6}\\,\\mathrm{s}$ per solar mass and $M_{\\odot}$ the total mass in solar masses provided in the test suite below. Take $A$ dimensionless and the gravitational-wave strain to be dimensionless. All phases are in radians. \n\n2) Generate synthetic catalog waveforms $h_{N,r}^{(\\mathrm{early})}(f)$ and $h_{N,r}^{(\\mathrm{late})}(f)$ as follows. For each resolution $N$ and extraction radius $r$, define the perturbative decomposition\n$$\nh_{N,r}^{(\\mathrm{ver})}(f) \\equiv h_{\\mathrm{true}}(f) + \\delta h_T(N,f) + \\delta h_E(r,f) + \\delta h_J^{(\\mathrm{ver})}(f),\n$$\nwhere “$\\mathrm{ver}$” is either “early” or “late”. The three contributions are defined by the synthetic model:\n- Truncation error: \n$$\n\\delta h_T(N,f) = h_{\\mathrm{true}}(f)\\,\\left(\\frac{1}{N}\\right)^{p}\\!\\left[c_T^{(A)}\\left(\\frac{f}{f_0}\\right)^{1/3} + i\\,c_T^{(\\phi)}\\left(\\frac{f}{f_0}\\right)^{1/2}\\right].\n$$\n- Finite-radius error:\n$$\n\\delta h_E(r,f) = h_{\\mathrm{true}}(f)\\,\\left(\\frac{b_1}{r} + \\frac{b_2}{r^2}\\right)\\!\\left[\\frac{1}{2}\\left(\\frac{f}{f_0}\\right)^{-1/3} + i\\,\\frac{1}{5}\\left(\\frac{f}{f_0}\\right)^{-1/2}\\right].\n$$\n- Junk-radiation term for the “early” and “late” variants:\n$$\n\\delta h_J^{(\\mathrm{early})}(f) = h_{\\mathrm{true}}(f)\\,J_0\\,\\exp\\!\\left(-\\left(\\frac{f}{f_j}\\right)^2\\right)\\,e^{i\\,\\psi_J}, \\quad \\delta h_J^{(\\mathrm{late})}(f)=0.\n$$\nHere $f_0$ is a reference frequency in hertz, $p$ is the convergence order of the finite-difference scheme, and $b_1$, $b_2$, $c_T^{(A)}$, $c_T^{(\\phi)}$, $J_0$, $f_j$, $\\psi_J$ are real constants provided in the test suite. \n\n3) Estimate each error contribution at the best-available data products:\n- Truncation: At the largest radius available, use the two finest resolutions and the scaling with $h^p$ to eliminate the unknown coefficient and infer the continuum-limit waveform at fixed $r$. Define the truncation error estimate at the finest resolution as the difference between the finest-resolution waveform and the inferred continuum-limit waveform. Perform this element-wise in frequency. \n- Extrapolation: At the finest resolution, fit the $r$-dependence of the complex waveform at each frequency as a low-order polynomial in $x=1/r$ and extrapolate to $x=0$. Estimate the extrapolation error at each frequency as the difference between the extrapolated values obtained from polynomial degrees $2$ and $1$. If fewer than $3$ radii are available, estimate the extrapolation error as the difference between the degree-$1$ extrapolation and the value at the largest radius. \n- Junk: At the finest resolution and largest radius, estimate the junk error as the difference between the “early” and “late” processed waveforms.\n\n4) Using the noise-weighted inner product, compute the first-order mismatch due to each contribution and combine them under the assumption of independence at first order:\n$$\nm_T \\equiv \\frac{1}{2}\\,\\frac{\\|\\delta h_T\\|^2}{\\|h_{\\mathrm{true}}\\|^2}, \\quad\nm_E \\equiv \\frac{1}{2}\\,\\frac{\\|\\delta h_E\\|^2}{\\|h_{\\mathrm{true}}\\|^2}, \\quad\nm_J \\equiv \\frac{1}{2}\\,\\frac{\\|\\delta h_J\\|^2}{\\|h_{\\mathrm{true}}\\|^2}, \\quad\nm_{\\mathrm{tot}} \\approx m_T + m_E + m_J.\n$$\nReport $m_{\\mathrm{tot}}$ for each test case.\n\nUse the following fixed frequency grid and PSD for all cases:\n- Frequencies: $f_k = f_{\\min} + k\\,\\Delta f$ for $k=0,\\dots,K-1$, with $f_{\\min} = 20\\,\\mathrm{Hz}$, $\\Delta f = 1\\,\\mathrm{Hz}$, and $f_{\\max} = 512\\,\\mathrm{Hz}$ inclusive.\n- One-sided PSD: \n$$\nS_n(f) = \\left(\\frac{f}{f_0}\\right)^{-4} + 2 + \\left(\\frac{f}{f_0}\\right)^2,\n$$\nwith $f_0=100\\,\\mathrm{Hz}$. Use this $S_n(f)$ in the inner product, and use $\\Delta f$ in the Riemann sum.\n\nTest Suite. For each test case $i\\in\\{1,2,3\\}$, use the following parameters:\n\n- Case $1$ (happy path):\n  - Total mass: $M_{\\odot}=60$.\n  - Convergence order: $p=4$.\n  - Resolutions: $N\\in\\{64,80,96\\}$.\n  - Radii: $r\\in\\{100,120,140\\}$.\n  - Truncation coefficients: $c_T^{(A)}=0.3$, $c_T^{(\\phi)}=0.1$.\n  - Extrapolation coefficients: $b_1=30$, $b_2=-500$.\n  - Junk parameters: $J_0=0.03$, $f_j=30\\,\\mathrm{Hz}$, $\\psi_J=0.7\\,\\mathrm{rad}$.\n\n- Case $2$ (lower-order convergence and stronger systematics):\n  - Total mass: $M_{\\odot}=50$.\n  - Convergence order: $p=2$.\n  - Resolutions: $N\\in\\{48,64,80\\}$.\n  - Radii: $r\\in\\{80,100,120\\}$.\n  - Truncation coefficients: $c_T^{(A)}=0.6$, $c_T^{(\\phi)}=0.2$.\n  - Extrapolation coefficients: $b_1=50$, $b_2=-800$.\n  - Junk parameters: $J_0=0.05$, $f_j=25\\,\\mathrm{Hz}$, $\\psi_J=1.1\\,\\mathrm{rad}$.\n\n- Case $3$ (edge case with two radii):\n  - Total mass: $M_{\\odot}=70$.\n  - Convergence order: $p=3$.\n  - Resolutions: $N\\in\\{72,84,96\\}$.\n  - Radii: $r\\in\\{120,180\\}$.\n  - Truncation coefficients: $c_T^{(A)}=0.25$, $c_T^{(\\phi)}=0.08$.\n  - Extrapolation coefficients: $b_1=20$, $b_2=-200$.\n  - Junk parameters: $J_0=0.02$, $f_j=35\\,\\mathrm{Hz}$, $\\psi_J=0.4\\,\\mathrm{rad}$.\n\nAdditional specifications and units:\n- Use $A=1$ in arbitrary dimensionless units for $h_{\\mathrm{true}}(f)$; all strains are dimensionless.\n- All frequencies are in hertz; all phases are in radians; the mismatch is dimensionless.\n- The final program must compute $m_{\\mathrm{tot}}$ for each test case in the test suite.\n\nRequired final output format:\nYour program should produce a single line of output containing the three total mismatches as a comma-separated Python list with no spaces, in the order of the test cases, for example $[m_1,m_2,m_3]$. The entries must be machine-readable floating-point numbers.", "solution": "The user wants to construct a program to estimate and propagate different sources of error in numerical relativity (NR) waveform modeling. The program needs to synthesize gravitational-wave strains with known errors, then apply standard analysis techniques to estimate these errors from the synthetic data, and finally compute the total modeling error budget.\n\nThe problem is scientifically sound, well-posed, and provides all necessary information to proceed. It is based on established concepts in gravitational wave data analysis and numerical relativity, such as the stationary phase approximation for inspiral waveforms, Richardson extrapolation for convergence analysis, polynomial extrapolation for finite-radius effects, and noise-weighted inner products for calculating signal-to-noise ratios and mismatches.\n\nThe solution will be implemented in Python using the `numpy` library for efficient numerical computations, following the steps outlined in the problem.\n\n**Step 1: Foundational Definitions**\n\nFirst, we define the necessary physical constants, the computational grid, and the noise Power Spectral Density (PSD).\nThe total mass $M$ in seconds is derived from the mass in solar units $M_{\\odot}$ via the conversion factor $T_{\\odot} = 4.92549095 \\times 10^{-6}\\,\\mathrm{s}/M_{\\odot}$.\nThe frequency grid $f_k$ is uniformly spaced from $f_{\\min} = 20\\,\\mathrm{Hz}$ to $f_{\\max} = 512\\,\\mathrm{Hz}$ with a step of $\\Delta f = 1\\,\\mathrm{Hz}$.\nThe one-sided noise PSD is given by the analytical formula:\n$$\nS_n(f) = \\left(\\frac{f}{f_0}\\right)^{-4} + 2 + \\left(\\frac{f}{f_0}\\right)^2, \\quad f_0 = 100\\,\\mathrm{Hz}.\n$$\nThe noise-weighted inner product $\\langle a,b \\rangle$ is defined, from which the squared norm $\\|a\\|^2 = \\langle a,a \\rangle$ is derived. For a complex signal $a(f)$, the squared norm simplifies to:\n$$\n\\|a\\|^2 = 4 \\sum_{k=0}^{K-1} \\frac{|a(f_k)|^2}{S_n(f_k)}\\,\\Delta f.\n$$\n\n**Step 2: Generation of Synthetic Waveforms**\n\nWe first construct the \"true\" waveform, $h_{\\mathrm{true}}(f)$, which serves as our ground truth. It is based on the stationary phase approximation for a non-spinning binary black hole inspiral:\n$$\nh_{\\mathrm{true}}(f) = A f^{-7/6}\\,\\exp\\!\\bigl(i\\,\\phi(f)\\bigr), \\quad \\text{with} \\quad \\phi(f)=\\frac{3}{128}\\,(\\pi M f)^{-5/3}.\n$$\nWe set the amplitude constant $A=1$.\n\nNext, we generate a catalog of synthetic NR waveforms, $h_{N,r}^{(\\mathrm{ver})}(f)$, for different numerical resolutions $N$ and extraction radii $r$. Each waveform is constructed as a sum of the true waveform and three distinct, additive error contributions:\n$$\nh_{N,r}^{(\\mathrm{ver})}(f) = h_{\\mathrm{true}}(f) + \\delta h_T(N,f) + \\delta h_E(r,f) + \\delta h_J^{(\\mathrm{ver})}(f).\n$$\nThe specific functional forms for the truncation error $\\delta h_T$, finite-radius error $\\delta h_E$, and junk radiation $\\delta h_J$ are provided in the problem statement. The junk radiation is only present in the \"early\" version of the waveform ($\\delta h_J^{(\\mathrm{late})}(f)=0$).\n\n**Step 3: Estimation of Error Contributions**\n\nWith the synthetic catalog generated, the next step is to estimate each error source using only the information available in the catalog, mimicking a real analysis scenario. For this, we use the \"late\" waveforms, which are free from junk radiation, as the basis for estimating truncation and extrapolation errors.\n\n- **Truncation Error Estimation ($\\widehat{\\delta h_T}$)**: The truncation error is estimated using Richardson extrapolation. At the largest available radius $r_{\\max}$, we take the two finest resolution waveforms, $h_{N_1,r_{\\max}}(f)$ and $h_{N_2,r_{\\max}}(f)$ where $N_2 > N_1$. Assuming the error scales as $(1/N)^p$, the continuum ($N \\to \\infty$) limit waveform $h_{\\infty,r_{\\max}}(f)$ can be estimated as:\n$$\nh_{\\infty,r_{\\max}}(f) = \\frac{h_{N_2,r_{\\max}}(f) N_2^p - h_{N_1,r_{\\max}}(f) N_1^p}{N_2^p - N_1^p}.\n$$\nThe truncation error at the finest resolution $N_2$ is then estimated as the difference between the $N_2$ waveform and this extrapolated continuum limit:\n$$\n\\widehat{\\delta h_T}(f) = h_{N_2,r_{\\max}}(f) - h_{\\infty,r_{\\max}}(f).\n$$\n\n- **Extrapolation Error Estimation ($\\widehat{\\delta h_E}$)**: The finite-radius error is estimated by fitting the waveform's dependence on $x=1/r$ with polynomials and extrapolating to $x=0$ (infinite radius). This is performed at the finest resolution $N_{\\max}$.\n    - If three or more radii are available, we perform a least-squares fit of the complex waveform data (at each frequency) to both a linear and a quadratic polynomial in $x$. The estimated error is the difference between the two extrapolated values at $x=0$:\n    $$\n    \\widehat{\\delta h_E}(f) = h_{\\mathrm{extrap, deg=2}}(f) - h_{\\mathrm{extrap, deg=1}}(f).\n    $$\n    This procedure will be implemented efficiently using `numpy.linalg.lstsq` on the Vandermonde matrix representation of the problem.\n    - If only two radii are available, we perform a linear fit. The error is estimated as the difference between the linearly extrapolated value and the waveform value at the largest available radius $r_{\\max}$:\n    $$\n    \\widehat{\\delta h_E}(f) = h_{\\mathrm{extrap, deg=1}}(f) - h_{N_{\\max},r_{\\max}}(f).\n    $$\n\n- **Junk Radiation Estimation ($\\widehat{\\delta h_J}$)**: This error is estimated directly by differencing the \"early\" and \"late\" waveforms at the highest quality available (finest resolution $N_{\\max}$ and largest radius $r_{\\max}$):\n$$\n\\widehat{\\delta h_J}(f) = h_{N_{\\max},r_{\\max}}^{(\\mathrm{early})}(f) - h_{N_{\\max},r_{\\max}}^{(\\mathrm{late})}(f).\n$$\n\n**Step 4: Mismatch Calculation and Error Propagation**\n\nFinally, we compute the mismatch contribution from each estimated error source. The mismatch $m_X$ for an error contribution $\\widehat{\\delta h_X}$ is defined as:\n$$\nm_X = \\frac{1}{2}\\frac{\\|\\widehat{\\delta h_X}\\|^2}{\\|h_{\\mathrm{true}}\\|^2}.\n$$\nThe total modeling mismatch, $m_{\\mathrm{tot}}$, is the sum of the individual contributions, assuming they are independent at first order:\n$$\nm_{\\mathrm{tot}} \\approx m_T + m_E + m_J.\n$$\nThis total mismatch $m_{\\mathrm{tot}}$ is computed for each test case specified in the problem. The final output will be a list of these values.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the gravitational wave error propagation problem.\n    It synthesizes waveforms with known errors, estimates these errors from the\n    synthetic data, and computes the total error budget as a mismatch.\n    \"\"\"\n    \n    # --- Global Constants and Setup ---\n    T_SOLAR_MASS = 4.92549095e-6  # seconds per solar mass\n    AMP = 1.0                     # Dimensionless amplitude for h_true\n    F_MIN = 20.0                  # Hz\n    F_MAX = 512.0                 # Hz\n    DF = 1.0                      # Hz\n    F0 = 100.0                    # Reference frequency in Hz\n    \n    freqs = np.arange(F_MIN, F_MAX + DF, DF)\n    psd = (freqs / F0)**(-4) + 2.0 + (freqs / F0)**2\n\n    # --- Helper Functions ---\n    def norm_sq(a, psd_vals, df):\n        \"\"\"Computes the squared noise-weighted norm of a waveform.\"\"\"\n        integrand = np.abs(a)**2 / psd_vals\n        return 4.0 * np.sum(integrand) * df\n\n    def calculate_h_true(f, M, A):\n        \"\"\"Computes the true inspiral-dominated waveform.\"\"\"\n        # Use a small epsilon to avoid division by zero if f=0, though not an issue here.\n        f_safe = np.maximum(f, 1e-9)\n        phase = (3.0 / 128.0) * (np.pi * M * f_safe)**(-5.0 / 3.0)\n        amplitude = A * f_safe**(-7.0 / 6.0)\n        return amplitude * np.exp(1j * phase)\n\n    def calculate_delta_h_T(h_true, f, N, p, cA, cphi, f0_ref):\n        \"\"\"Computes the synthetic truncation error perturbation.\"\"\"\n        factor = (1.0 / N)**p * (cA * (f / f0_ref)**(1.0/3.0) + 1j * cphi * (f / f0_ref)**(1.0/2.0))\n        return h_true * factor\n\n    def calculate_delta_h_E(h_true, f, r, b1, b2, f0_ref):\n        \"\"\"Computes the synthetic finite-radius error perturbation.\"\"\"\n        factor = (b1 / r + b2 / r**2) * (0.5 * (f / f0_ref)**(-1.0/3.0) + 1j * 0.2 * (f / f0_ref)**(-1.0/2.0))\n        return h_true * factor\n        \n    def calculate_delta_h_J_early(h_true, f, J0_val, fj_val, psi_J_val):\n        \"\"\"Computes the synthetic junk radiation perturbation.\"\"\"\n        factor = J0_val * np.exp(-(f / fj_val)**2) * np.exp(1j * psi_J_val)\n        return h_true * factor\n\n    def estimate_truncation_error(catalog, Ns, r_max, p):\n        \"\"\"Estimates truncation error using Richardson extrapolation.\"\"\"\n        sorted_Ns = sorted(Ns)\n        N2, N1 = float(sorted_Ns[-1]), float(sorted_Ns[-2])\n        \n        h2 = catalog[(N2, r_max, 'late')]\n        h1 = catalog[(N1, r_max, 'late')]\n        \n        N2_p = N2**p\n        N1_p = N1**p\n        h_inf = (h2 * N2_p - h1 * N1_p) / (N2_p - N1_p)\n        \n        return h2 - h_inf\n\n    def estimate_extrapolation_error(catalog, N_max, rs):\n        \"\"\"Estimates extrapolation error using polynomial fitting.\"\"\"\n        sorted_rs = sorted(rs)\n        x = 1.0 / np.array(sorted_rs)\n        h_data = np.array([catalog[(N_max, r, 'late')] for r in sorted_rs])\n        \n        if len(sorted_rs) >= 3:\n            V2 = np.vander(x, N=3, increasing=True) # increasing=True matches polyfit convention\n            coeffs2 = np.linalg.lstsq(V2, h_data, rcond=None)[0]\n            h_extrap_deg2 = coeffs2[0, :]\n\n            V1 = np.vander(x, N=2, increasing=True)\n            coeffs1 = np.linalg.lstsq(V1, h_data, rcond=None)[0]\n            h_extrap_deg1 = coeffs1[0, :]\n            \n            return h_extrap_deg2 - h_extrap_deg1\n        else: # Case with 2 radii\n            V1 = np.vander(x, N=2, increasing=True)\n            coeffs1 = np.linalg.lstsq(V1, h_data, rcond=None)[0]\n            h_extrap_deg1 = coeffs1[0, :]\n            \n            r_max = max(sorted_rs)\n            h_at_rmax = catalog[(N_max, r_max, 'late')]\n            return h_extrap_deg1 - h_at_rmax\n            \n    def estimate_junk_error(catalog, N_max, r_max):\n        \"\"\"Estimates junk radiation error by differencing waveforms.\"\"\"\n        h_early = catalog[(N_max, r_max, 'early')]\n        h_late = catalog[(N_max, r_max, 'late')]\n        return h_early - h_late\n\n    # --- Test Suite ---\n    test_cases = [\n        {\"M_solar\": 60.0,\"p\": 4.0,\"Ns\": [64,80,96],\"rs\": [100,120,140],\"cT_A\": 0.3,\"cT_phi\": 0.1,\"b1\": 30.0,\"b2\": -500.0,\"J0\": 0.03,\"fj\": 30.0,\"psi_J\": 0.7},\n        {\"M_solar\": 50.0,\"p\": 2.0,\"Ns\": [48,64,80],\"rs\": [80,100,120],\"cT_A\": 0.6,\"cT_phi\": 0.2,\"b1\": 50.0,\"b2\": -800.0,\"J0\": 0.05,\"fj\": 25.0,\"psi_J\": 1.1},\n        {\"M_solar\": 70.0,\"p\": 3.0,\"Ns\": [72,84,96],\"rs\": [120,180],\"cT_A\": 0.25,\"cT_phi\": 0.08,\"b1\": 20.0,\"b2\": -200.0,\"J0\": 0.02,\"fj\": 35.0,\"psi_J\": 0.4},\n    ]\n\n    results = []\n    # --- Main Loop ---\n    for case in test_cases:\n        M = case[\"M_solar\"] * T_SOLAR_MASS\n        p = case[\"p\"]\n        Ns = case[\"Ns\"]\n        rs = case[\"rs\"]\n        \n        # Generate true waveform and synthetic catalog\n        h_true = calculate_h_true(freqs, M, AMP)\n        \n        catalog = {}\n        for N_val in Ns:\n            delta_h_T = calculate_delta_h_T(h_true, freqs, N_val, p, case[\"cT_A\"], case[\"cT_phi\"], F0)\n            for r_val in rs:\n                delta_h_E = calculate_delta_h_E(h_true, freqs, r_val, case[\"b1\"], case[\"b2\"], F0)\n                delta_h_J = calculate_delta_h_J_early(h_true, freqs, case[\"J0\"], case[\"fj\"], case[\"psi_J\"])\n                \n                h_late = h_true + delta_h_T + delta_h_E\n                h_early = h_late + delta_h_J\n                \n                catalog[(float(N_val), float(r_val), 'late')] = h_late\n                catalog[(float(N_val), float(r_val), 'early')] = h_early\n\n        N_max = float(max(Ns))\n        r_max = float(max(rs))\n        \n        # Estimate error contributions\n        delta_h_T_hat = estimate_truncation_error(catalog, Ns, r_max, p)\n        delta_h_E_hat = estimate_extrapolation_error(catalog, N_max, rs)\n        delta_h_J_hat = estimate_junk_error(catalog, N_max, r_max)\n\n        # Calculate mismatches\n        norm_h_true_sq = norm_sq(h_true, psd, DF)\n        if norm_h_true_sq == 0: norm_h_true_sq = 1.0 # Avoid division by zero\n        \n        m_T = 0.5 * norm_sq(delta_h_T_hat, psd, DF) / norm_h_true_sq\n        m_E = 0.5 * norm_sq(delta_h_E_hat, psd, DF) / norm_h_true_sq\n        m_J = 0.5 * norm_sq(delta_h_J_hat, psd, DF) / norm_h_true_sq\n        \n        m_tot = m_T + m_E + m_J\n        results.append(m_tot)\n        \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3481762"}]}