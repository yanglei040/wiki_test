{"hands_on_practices": [{"introduction": "The Method of Lines (MoL) provides a powerful strategy for solving partial differential equations by first discretizing in space to create a system of ordinary differential equations (ODEs) in time. This exercise reveals the inner workings of this approach by combining a classical fourth-order Runge-Kutta (RK4) integrator with a centered-difference spatial discretization for the simple advection equation [@problem_id:3493026]. By deriving the complete, single-step update stencil, you will gain a concrete understanding of how the spatial and temporal operators intertwine and how the dimensionless Courant number, $\\lambda$, directly structures the final numerical scheme.", "problem": "In many hyperbolic formulations of the Einstein field equations used in numerical relativity, certain characteristic fields propagate approximately as advected quantities along preferred directions set by the gauge. As a simplified model for an outgoing characteristic associated with a linearized gravitational wave on a one-dimensional uniform spatial grid, consider a scalar field $h(t,x)$ satisfying the constant-coefficient advection equation $\\partial_{t} h + v \\,\\partial_{x} h = 0$, where $v$ is a positive constant speed. Using the Method of Lines (MOL), discretize space on a uniform grid $x_{i} = i\\,\\Delta x$ and define the grid function $u_{i}^{n} \\approx h(t^{n}, x_{i})$ at time levels $t^{n} = t^{0} + n\\,\\Delta t$. Approximate the spatial derivative with the centered-difference operator $D_{0}$ defined by $D_{0} u_{i} = \\big(u_{i+1} - u_{i-1}\\big)/(2\\,\\Delta x)$, so that the semi-discrete system reads $\\frac{d}{dt}\\,\\mathbf{u}(t) = -\\,v\\,D_{0}\\,\\mathbf{u}(t)$ on a sufficiently extended or periodic domain that makes all required stencil points well-defined.\n\nApply the classical fourth-order Runge-Kutta (RK) method to advance one time step from $t^{n}$ to $t^{n+1} = t^{n} + \\Delta t$. Starting from the fundamental advection law and the centered-difference semi-discretization, derive from first principles the four stage updates for the grid function $\\mathbf{u}^{n}$ and simplify the result to obtain the single-step update for each component $u_{i}^{n+1}$ expressed entirely in terms of $\\{u_{i+k}^{n}\\}_{k=-4}^{4}$ and the dimensionless Courant number $\\lambda = v\\,\\Delta t/\\Delta x$.\n\nProvide your final result as one closed-form analytic expression for $u_{i}^{n+1}$ in terms of $\\lambda$ and the neighboring values of $u^{n}$ on the RK4 stencil. No numerical evaluation or rounding is required, and no physical units should be included in the final expression.", "solution": "The user has provided a valid problem statement. The task is to derive the single-step update rule for a one-dimensional advection equation discretized using the Method of Lines (MoL) with a centered spatial difference and a classical fourth-order Runge-Kutta (RK4) time integrator.\n\nThe governing partial differential equation (PDE) is the constant-coefficient advection equation for a scalar field $h(t,x)$:\n$$\n\\partial_{t} h + v \\,\\partial_{x} h = 0\n$$\nwhere $v$ is a positive constant speed.\n\nThe problem specifies a semi-discretization using the Method of Lines (MoL) on a uniform grid $x_{i} = i\\,\\Delta x$. The spatial derivative $\\partial_x h$ is approximated by the second-order centered-difference operator $D_0$:\n$$\nD_{0} u_{i} = \\frac{u_{i+1} - u_{i-1}}{2\\,\\Delta x}\n$$\nwhere $u_i(t) \\approx h(t, x_i)$. This yields a system of ordinary differential equations (ODEs) for the grid functions $u_i(t)$:\n$$\n\\frac{d u_i}{dt} = -v D_0 u_i = -v \\frac{u_{i+1} - u_{i-1}}{2\\,\\Delta x}\n$$\nThis system is linear and can be written in vector form as $\\frac{d}{dt}\\mathbf{u}(t) = L\\mathbf{u}(t)$, where $L$ is a linear operator representing the right-hand side, $L = -v D_0$.\n\nThe classical fourth-order Runge-Kutta (RK4) method is used to advance the solution from time $t^n$ to $t^{n+1} = t^n + \\Delta t$. For a linear, time-independent ODE system $\\frac{d\\mathbf{u}}{dt} = L\\mathbf{u}$, the RK4 update formula is equivalent to the truncated Taylor series expansion of the matrix exponential operator $\\exp(\\Delta t L)$:\n$$\n\\mathbf{u}^{n+1} = \\left( I + \\Delta t L + \\frac{(\\Delta t L)^2}{2!} + \\frac{(\\Delta t L)^3}{3!} + \\frac{(\\Delta t L)^4}{4!} \\right) \\mathbf{u}^{n}\n$$\nwhere $I$ is the identity operator. Let's define the dimensionless Courant number $\\lambda = v\\,\\Delta t/\\Delta x$. We can express the operator $\\Delta t L$ in terms of $\\lambda$ and a purely geometric difference operator. Let $D_c$ be the central difference operator such that $D_c u_i = u_{i+1} - u_{i-1}$. Then,\n$$\n\\Delta t L = -v \\Delta t D_0 = -v \\Delta t \\frac{D_c}{2 \\Delta x} = -\\frac{v \\Delta t}{2 \\Delta x} D_c = -\\frac{\\lambda}{2} D_c\n$$\nLet's denote the operator $A = \\Delta t L = -\\frac{\\lambda}{2} D_c$. The update rule for a single grid point $u_i$ is:\n$$\nu_i^{n+1} = \\left( I + A + \\frac{A^2}{2} + \\frac{A^3}{6} + \\frac{A^4}{24} \\right) u_i^n\n$$\nTo find the explicit formula, we need to compute the action of the powers of the operator $A$ on $u_i^n$. This requires computing the powers of the difference operator $D_c$:\n\\begin{itemize}\n    \\item $A u_i^n = -\\frac{\\lambda}{2} D_c u_i^n = -\\frac{\\lambda}{2} (u_{i+1}^n - u_{i-1}^n)$\n    \\item $A^2 u_i^n = \\left(-\\frac{\\lambda}{2}\\right)^2 D_c^2 u_i^n = \\frac{\\lambda^2}{4} D_c(u_{i+1}^n - u_{i-1}^n) = \\frac{\\lambda^2}{4} \\left( (u_{i+2}^n - u_i^n) - (u_i^n - u_{i-2}^n) \\right) = \\frac{\\lambda^2}{4} (u_{i+2}^n - 2u_i^n + u_{i-2}^n)$\n    \\item $A^3 u_i^n = \\left(-\\frac{\\lambda}{2}\\right)^3 D_c^3 u_i^n = -\\frac{\\lambda^3}{8} D_c(u_{i+2}^n - 2u_i^n + u_{i-2}^n) = -\\frac{\\lambda^3}{8} (u_{i+3}^n - 3u_{i+1}^n + 3u_{i-1}^n - u_{i-3}^n)$\n    \\item $A^4 u_i^n = \\left(-\\frac{\\lambda}{2}\\right)^4 D_c^4 u_i^n = \\frac{\\lambda^4}{16} D_c(u_{i+3}^n - 3u_{i+1}^n + 3u_{i-1}^n - u_{i-3}^n) = \\frac{\\lambda^4}{16} (u_{i+4}^n - 4u_{i+2}^n + 6u_i^n - 4u_{i-2}^n + u_{i-4}^n)$\n\\end{itemize}\nNow we substitute these expressions back into the RK4 update formula:\n$$\nu_i^{n+1} = u_i^n + A u_i^n + \\frac{1}{2}A^2 u_i^n + \\frac{1}{6}A^3 u_i^n + \\frac{1}{24}A^4 u_i^n\n$$\n$$\n\\begin{aligned}\nu_i^{n+1} = u_i^n & - \\frac{\\lambda}{2} (u_{i+1}^n - u_{i-1}^n) \\\\\n& + \\frac{1}{2}\\frac{\\lambda^2}{4} (u_{i+2}^n - 2u_i^n + u_{i-2}^n) \\\\\n& - \\frac{1}{6}\\frac{\\lambda^3}{8} (u_{i+3}^n - 3u_{i+1}^n + 3u_{i-1}^n - u_{i-3}^n) \\\\\n& + \\frac{1}{24}\\frac{\\lambda^4}{16} (u_{i+4}^n - 4u_{i+2}^n + 6u_i^n - 4u_{i-2}^n + u_{i-4}^n)\n\\end{aligned}\n$$\nSimplifying the coefficients for each term:\n$$\n\\begin{aligned}\nu_i^{n+1} = u_i^n & - \\frac{\\lambda}{2} (u_{i+1}^n - u_{i-1}^n) \\\\\n& + \\frac{\\lambda^2}{8} (u_{i+2}^n - 2u_i^n + u_{i-2}^n) \\\\\n& - \\frac{\\lambda^3}{48} (u_{i+3}^n - 3u_{i+1}^n + 3u_{i-1}^n - u_{i-3}^n) \\\\\n& + \\frac{\\lambda^4}{384} (u_{i+4}^n - 4u_{i+2}^n + 6u_i^n - 4u_{i-2}^n + u_{i-4}^n)\n\\end{aligned}\n$$\nThe final step is to collect the coefficients for each grid point value $u_{i+k}^n$ for $k \\in \\{-4, -3, \\dots, 3, 4\\}$.\n\\begin{itemize}\n    \\item Coefficient of $u_{i+4}^n$: from the $\\lambda^4$ term, we get $\\frac{\\lambda^4}{384}$.\n    \\item Coefficient of $u_{i+3}^n$: from the $\\lambda^3$ term, we get $-\\frac{\\lambda^3}{48}$.\n    \\item Coefficient of $u_{i+2}^n$: from the $\\lambda^2$ and $\\lambda^4$ terms, we get $\\frac{\\lambda^2}{8} + \\frac{\\lambda^4}{384}(-4) = \\frac{\\lambda^2}{8} - \\frac{\\lambda^4}{96}$.\n    \\item Coefficient of $u_{i+1}^n$: from the $\\lambda$ and $\\lambda^3$ terms, we get $-\\frac{\\lambda}{2} - \\frac{\\lambda^3}{48}(-3) = -\\frac{\\lambda}{2} + \\frac{\\lambda^3}{16}$.\n    \\item Coefficient of $u_i^n$: from the initial term, $\\lambda^2$ and $\\lambda^4$ terms, we get $1 + \\frac{\\lambda^2}{8}(-2) + \\frac{\\lambda^4}{384}(6) = 1 - \\frac{\\lambda^2}{4} + \\frac{\\lambda^4}{64}$.\n    \\item Coefficient of $u_{i-1}^n$: from the $\\lambda$ and $\\lambda^3$ terms, we get $-\\frac{\\lambda}{2}(-1) - \\frac{\\lambda^3}{48}(3) = \\frac{\\lambda}{2} - \\frac{\\lambda^3}{16}$.\n    \\item Coefficient of $u_{i-2}^n$: from the $\\lambda^2$ and $\\lambda^4$ terms, we get $\\frac{\\lambda^2}{8}(1) + \\frac{\\lambda^4}{384}(-4) = \\frac{\\lambda^2}{8} - \\frac{\\lambda^4}{96}$.\n    \\item Coefficient of $u_{i-3}^n$: from the $\\lambda^3$ term, we get $-\\frac{\\lambda^3}{48}(-1) = \\frac{\\lambda^3}{48}$.\n    \\item Coefficient of $u_{i-4}^n$: from the $\\lambda^4$ term, we get $\\frac{\\lambda^4}{384}$.\n\\end{itemize}\nCombining these coefficients yields the final single-step update formula for $u_i^{n+1}$.", "answer": "$$\n\\boxed{u_i^{n+1} = \\left(1 - \\frac{\\lambda^2}{4} + \\frac{\\lambda^4}{64}\\right)u_i^n + \\left(-\\frac{\\lambda}{2} + \\frac{\\lambda^3}{16}\\right)u_{i+1}^n + \\left(\\frac{\\lambda}{2} - \\frac{\\lambda^3}{16}\\right)u_{i-1}^n + \\left(\\frac{\\lambda^2}{8} - \\frac{\\lambda^4}{96}\\right)(u_{i+2}^n + u_{i-2}^n) + \\left(-\\frac{\\lambda^3}{48}\\right)u_{i+3}^n + \\left(\\frac{\\lambda^3}{48}\\right)u_{i-3}^n + \\left(\\frac{\\lambda^4}{384}\\right)(u_{i+4}^n + u_{i-4}^n)}\n$$", "id": "3493026"}, {"introduction": "While discretizing the interior of a domain is a primary concern, the stability and accuracy of a numerical solution are often dictated by the proper treatment of boundary conditions. This practice introduces the modern, provably stable Summation-By-Parts (SBP) and Simultaneous Approximation Term (SAT) framework, a cornerstone of high-fidelity simulations in numerical relativity [@problem_id:3492982]. By performing a discrete energy analysis on a semi-discrete system, you will learn to derive the penalty parameter $\\tau$ that guarantees stability while enforcing the physical boundary data, a critical skill for developing robust and reliable codes.", "problem": "Consider the one-dimensional linear advection equation $u_{t} + a\\,u_{x} = 0$ with constant advection speed $a>0$ on the spatial interval $[0,L]$, where the inflow boundary is at $x=0$. In numerical relativity and gravitational waves, semi-discrete formulations obtained by the method of lines are integrated in time using explicit Runge–Kutta methods, and stability is ensured by constructing semi-discrete energy estimates with Summation-By-Parts (SBP) spatial operators and a Simultaneous Approximation Term (SAT) for boundary enforcement. \n\nLet $\\{x_{i}\\}_{i=0}^{N}$ be a grid on $[0,L]$. Let $D$ be a first-derivative SBP operator with a diagonal, symmetric, positive-definite norm matrix $H$, and let $B$ be the boundary matrix $B=\\mathrm{diag}(-1,0,\\dots,0,1)$. Assume the SBP property holds in the canonical form $H D = Q + \\frac{1}{2} B$, with $Q^{T}=-Q$, so that for any grid function $v$ one has $v^{T} H D v = \\frac{1}{2} v^{T} B v = \\frac{1}{2}\\left(v_{N}^{2}-v_{0}^{2}\\right)$. Consider the semi-discrete method-of-lines system with a SAT boundary term enforcing prescribed inflow data $g(t)$ at $x=0$:\n$$\nu_{t} = -a\\,D u \\;+\\; H^{-1} e_{0}\\,\\tau\\left(g(t) - u_{0}(t)\\right),\n$$\nwhere $e_{0}=(1,0,\\dots,0)^{T}$ selects the left boundary component, $u_{0}(t)$ is the discrete solution value at $x_{0}$, and $\\tau$ is a scalar SAT penalty coefficient.\n\nStarting from the SBP property and the definition of the discrete energy $\\|u\\|_{H}^{2} = u^{T} H u$, derive the semi-discrete energy balance for the above system and determine the choice of the penalty coefficient $\\tau$ that yields a discrete energy estimate of the form \n$$\n\\frac{1}{2}\\frac{d}{dt}\\|u\\|_{H}^{2} \\;\\le\\; C(g(t)) \\,-\\, D(u(t)),\n$$\nwith a nonnegative data-dependent term $C(g(t))$ and a nonnegative dissipative term $D(u(t))$, consistent with inflow at $x=0$ and outflow at $x=L$. Your answer must be the single, closed-form analytic expression for the penalty coefficient $\\tau$ in terms of $a$. Do not include units.", "solution": "The problem requires the derivation of the penalty coefficient $\\tau$ for a Simultaneous Approximation Term (SAT) that ensures the stability of a semi-discrete scheme for the linear advection equation. The stability will be established through the energy method, aiming for a specific form of the semi-discrete energy balance.\n\nThe starting point is the definition of the discrete energy, which is the squared $H$-norm of the solution vector $u(t) \\in \\mathbb{R}^{N+1}$:\n$$\n\\|u\\|_{H}^{2} = u^{T} H u\n$$\nTo find the energy balance, we differentiate this quantity with respect to time $t$. Given that the norm matrix $H$ is constant and symmetric ($H^{T}=H$), the time derivative is:\n$$\n\\frac{d}{dt}\\|u\\|_{H}^{2} = \\frac{d u^{T}}{dt} H u + u^{T} H \\frac{d u}{dt} = 2 u^{T} H \\frac{d u}{dt}\n$$\nThe problem provides the method-of-lines ordinary differential equation (ODE) system for the time evolution of the solution vector $u(t)$, which we denote as $u_{t}$:\n$$\nu_{t} = \\frac{d u}{dt} = -a\\,D u \\;+\\; H^{-1} e_{0}\\,\\tau\\left(g(t) - u_{0}(t)\\right)\n$$\nSubstituting this ODE system into the energy evolution equation gives:\n$$\n\\frac{d}{dt}\\|u\\|_{H}^{2} = 2 u^{T} H \\left( -a\\,D u \\;+\\; H^{-1} e_{0}\\,\\tau\\left(g(t) - u_{0}(t)\\right) \\right)\n$$\nWe can distribute the terms on the right-hand side:\n$$\n\\frac{d}{dt}\\|u\\|_{H}^{2} = -2a\\, u^{T} H D u \\;+\\; 2 \\tau\\, u^{T} H H^{-1} e_{0} \\left(g(t) - u_{0}(t)\\right)\n$$\nLet us analyze each of the two terms separately.\n\nFor the first term involving the spatial derivative operator $D$, we employ the given Summation-By-Parts (SBP) property, $v^{T} H D v = \\frac{1}{2}\\left(v_{N}^{2}-v_{0}^{2}\\right)$, which represents a discrete analogue of integration by parts. Applying this to our solution vector $u(t)$:\n$$\n-2a\\, u^{T} H D u = -2a \\left( \\frac{1}{2}\\left(u_{N}^{2}-u_{0}^{2}\\right) \\right) = -a\\left(u_{N}^{2}-u_{0}^{2}\\right) = a u_{0}^{2} - a u_{N}^{2}\n$$\nHere, $u_{0}$ and $u_{N}$ are the values of the solution at the boundaries $x_{0}=0$ and $x_{N}=L$, respectively.\n\nFor the second term, which represents the SAT penalty, we simplify the matrix-vector products. The product $H H^{-1}$ is the identity matrix. The vector $e_{0}=(1,0,\\dots,0)^{T}$ is defined such that for any vector $v$, the product $v^{T}e_{0}$ selects its first component, $v_{0}$. Thus, $u^{T} e_{0} = u_{0}$. The second term simplifies to:\n$$\n2 \\tau\\, u^{T} e_{0} \\left(g - u_{0}\\right) = 2 \\tau\\, u_{0} \\left(g - u_{0}\\right) = 2\\tau g u_{0} - 2\\tau u_{0}^{2}\n$$\nCombining the simplified expressions for both terms, we obtain the full energy rate equation:\n$$\n\\frac{d}{dt}\\|u\\|_{H}^{2} = \\left(a u_{0}^{2} - a u_{N}^{2}\\right) + \\left(2\\tau g u_{0} - 2\\tau u_{0}^{2}\\right)\n$$\nThe problem asks for an estimate on $\\frac{1}{2}\\frac{d}{dt}\\|u\\|_{H}^{2}$. Dividing by $2$ and collecting terms associated with the inflow boundary ($x=0$) and the outflow boundary ($x=L$) yields:\n$$\n\\frac{1}{2}\\frac{d}{dt}\\|u\\|_{H}^{2} = \\left(\\frac{a}{2} - \\tau\\right)u_{0}^{2} + \\tau g u_{0} - \\frac{a}{2} u_{N}^{2}\n$$\nWe need to determine $\\tau$ such that this expression takes the form $\\le C(g(t)) - D(u(t))$, where $C(g(t)) \\ge 0$ and $D(u(t)) \\ge 0$.\nThe term $-\\frac{a}{2} u_{N}^{2}$ corresponds to the outflow boundary at $x=L$. Since $a>0$, this term is non-positive, representing energy leaving the domain. It is inherently stabilizing and can be part of the non-negative dissipative term $D(u(t))$, namely as $D_{outflow}(u) = \\frac{a}{2}u_N^2 \\ge 0$.\n\nThe remaining terms are associated with the inflow boundary at $x=0$:\n$$\nT_{0} = \\left(\\frac{a}{2} - \\tau\\right)u_{0}^{2} + \\tau g u_{0}\n$$\nTo ensure stability, the terms quadratic in the solution (e.g., $u_0^2$) must not lead to energy growth. We can express $T_0$ in the desired form $C(g) - D(u)$ by completing the square with respect to $u_0$. For the resulting term quadratic in $u_0$ to be dissipative (i.e., non-positive), we must have $\\frac{a}{2} - \\tau \\le 0$, which implies $\\tau \\ge \\frac{a}{2}$. Assuming $\\tau > a/2$, we can write:\n$$\nT_{0} = -\\left(\\tau - \\frac{a}{2}\\right)\\left[u_{0}^{2} - \\frac{\\tau}{\\tau-\\frac{a}{2}} g u_{0}\\right]\n$$\nCompleting the square on the expression in the brackets gives:\n$$\nT_{0} = -\\left(\\tau - \\frac{a}{2}\\right)\\left[ \\left(u_{0} - \\frac{\\tau g}{2(\\tau-\\frac{a}{2})}\\right)^{2} - \\left(\\frac{\\tau g}{2(\\tau-\\frac{a}{2})}\\right)^{2} \\right] = \\frac{\\tau^{2}}{4(\\tau-\\frac{a}{2})}g^{2} - \\left(\\tau - \\frac{a}{2}\\right)\\left(u_{0} - \\frac{\\tau g}{2(\\tau-\\frac{a}{2})}\\right)^{2}\n$$\nThis form, $C(g) - D(u,g)$, provides a stable estimate for any $\\tau > a/2$. However, the problem asks for \"the\" choice of $\\tau$, implying a unique, canonical value. The physical purpose of the SAT term is to enforce the boundary condition $u(0,t)=g(t)$. A physically consistent penalty should therefore dissipate energy proportionally to the error between the numerical solution $u_0$ and the boundary data $g$, i.e., proportionally to $(u_0-g)^2$. The dissipative part of our expression for $T_0$ is proportional to $(u_0 - K g)^2$, where $K = \\frac{\\tau}{2(\\tau-\\frac{a}{2})}$. For physical consistency, we must require $K=1$.\n$$\n\\frac{\\tau}{2(\\tau-\\frac{a}{2})} = 1 \\implies \\tau = 2\\tau - a \\implies \\tau = a\n$$\nThis unique choice of $\\tau$ ensures that the SAT term penalizes the actual error at the boundary. This choice satisfies the stability condition $\\tau > a/2$, as $a>0$ implies $a > a/2$.\nLet us verify the resulting energy balance for $\\tau=a$. The inflow term $T_0$ becomes:\n$$\nT_0 = \\left(\\frac{a}{2} - a\\right)u_{0}^{2} + a g u_{0} = -\\frac{a}{2}u_{0}^{2} + a g u_{0} = -\\frac{a}{2}(u_0^2 - 2gu_0) = -\\frac{a}{2}((u_0-g)^2 - g^2) = \\frac{a}{2}g^2 - \\frac{a}{2}(u_0-g)^2\n$$\nThe complete semi-discrete energy balance is therefore:\n$$\n\\frac{1}{2}\\frac{d}{dt}\\|u\\|_{H}^{2} = \\frac{a}{2}g(t)^{2} - \\frac{a}{2}(u_{0}(t)-g(t))^{2} - \\frac{a}{2}u_{N}(t)^{2}\n$$\nThis expression perfectly matches the required form with $C(g(t)) = \\frac{a}{2}g(t)^{2} \\ge 0$ and $D(u(t)) = \\frac{a}{2}(u_{0}(t)-g(t))^{2} + \\frac{a}{2}u_{N}(t)^{2} \\ge 0$.\n\nThus, the correct penalty coefficient is $\\tau=a$.", "answer": "$$\n\\boxed{a}\n$$", "id": "3492982"}, {"introduction": "For long-term simulations like binary black hole inspirals, local stability and accuracy are necessary but not sufficient; the primary challenge becomes controlling the accumulation of phase error over millions of dynamical timescales. This hands-on coding exercise contrasts a standard, general-purpose Runge-Kutta method with a structure-preserving (symplectic) integrator designed to respect the Hamiltonian nature of orbital dynamics [@problem_id:3493030]. By implementing and comparing these methods, you will witness firsthand the superior long-term fidelity of symplectic integrators, providing a crucial, practical lesson on selecting the right tool for problems demanding high phase accuracy, as is essential for gravitational wave astronomy.", "problem": "Design and implement a complete and runnable program that quantifies cumulative orbital phase error induced by Runge–Kutta (RK) time integration in a Hamiltonian geodesic toy model and compares it against a time-symmetric symplectic integrator, with the goal of assessing long-time phase fidelity relevant to Gravitational Wave (GW) modeling in numerical relativity. The integrators must be applied in a Method of Lines (MoL) viewpoint, where the continuous-in-time evolution is performed by an RK scheme. The comparison must be grounded in first principles and must produce numerically verifiable outputs on a specified test suite.\n\nStart from the following fundamental base. Consider the Newtonian test-mass geodesic toy model for a bound equatorial orbit (a proxy for a circular geodesic in a fixed background) with the Hamiltonian\n$$\nH(r,p_r;\\phi,L) \\;=\\; \\frac{p_r^2}{2} \\;+\\; \\frac{L^2}{2\\,r^2} \\;-\\; \\frac{\\mu}{r},\n$$\nwhere $r$ is the radial coordinate, $p_r$ is the radial canonical momentum, $\\phi$ is the orbital phase, $L$ is the conserved angular momentum, and $\\mu$ is the gravitational parameter. The canonical Hamilton equations are\n$$\n\\begin{aligned}\n\\frac{dr}{dt} \\;&=\\; \\frac{\\partial H}{\\partial p_r} \\;=\\; p_r,\\\\\n\\frac{dp_r}{dt} \\;&=\\; -\\,\\frac{\\partial H}{\\partial r} \\;=\\; \\frac{L^2}{r^3} \\;-\\; \\frac{\\mu}{r^2},\\\\\n\\frac{d\\phi}{dt} \\;&=\\; \\frac{\\partial H}{\\partial L} \\;=\\; \\frac{L}{r^2},\\\\\n\\frac{dL}{dt} \\;&=\\; 0.\n\\end{aligned}\n$$\nFor a circular orbit with radius $r_0$, the exact circular frequency is\n$$\n\\omega \\;=\\; \\sqrt{\\frac{\\mu}{r_0^3}},\n$$\nand the exact phase after time $T$ is\n$$\n\\phi_{\\mathrm{exact}}(T) \\;=\\; \\omega\\,T,\n$$\nso that after an integer number of cycles $N$ the exact phase is $\\phi_{\\mathrm{exact}}(T)=2\\pi N$, where $T = \\frac{2\\pi N}{\\omega}$.\n\nTask requirements:\n\n- Implement two time integrators for the ordinary differential equation (ODE) system above:\n  1. An error-controlled embedded Runge–Kutta method with local error control (use a classical two-stage embedded pair, sometimes called Heun–Euler, where the Euler method of order $1$ is embedded in the trapezoidal RK method of order $2$). This realizes the Method of Lines (MoL) perspective by integrating the semidiscrete system in time with an RK integrator. The integrator must adapt its step size based on a scalar error norm using a relative tolerance `rtol`. To ensure that the assessment covers long-time accumulation, impose a hard cap on the step size $h_{\\max}$ so that the number of accepted steps is at least a prescribed target. The local-error accept/reject logic must be implemented.\n  2. A second-order time-symmetric symplectic scheme on the reduced $(r,p_r)$ subsystem with effective potential $V_{\\mathrm{eff}}(r)=\\frac{L^2}{2r^2}-\\frac{\\mu}{r}$, namely the Störmer–Verlet (also known as Velocity–Verlet) method:\n     - Half-kick: $p_r \\leftarrow p_r - \\frac{\\partial V_{\\mathrm{eff}}}{\\partial r}\\,\\frac{h}{2}$,\n     - Drift: $r \\leftarrow r + p_r\\,h$,\n     - Half-kick: $p_r \\leftarrow p_r - \\frac{\\partial V_{\\mathrm{eff}}}{\\partial r}\\,\\frac{h}{2}$.\n    The phase $\\phi$ must be advanced consistently during the drift using a second-order accurate quadrature over the step of length $h$, for example a Simpson-type update\n    $$\n    \\Delta\\phi \\;\\approx\\; \\frac{h\\,L}{6}\\left(\\frac{1}{r_{\\mathrm{before}}^2} + \\frac{4}{r_{\\mathrm{mid}}^2} + \\frac{1}{r_{\\mathrm{after}}^2}\\right),\n    $$\n    where $r_{\\mathrm{before}}$ and $r_{\\mathrm{after}}$ are the radii before and after the drift and $r_{\\mathrm{mid}}$ is the drift midpoint.\n\n- Use dimensionless units with $\\mu=1$ unless otherwise specified. All angles must be in radians. Report phase errors in radians. No other physical units are used.\n\n- Initial data must be set to the exact circular orbit conditions at $t=0$: $r(0)=r_0$, $p_r(0)=0$, $L=\\sqrt{\\mu r_0}$, and $\\phi(0)=0$.\n\n- For each test, integrate to $T=\\frac{2\\pi N}{\\omega}$ with $\\omega=\\sqrt{\\mu/r_0^3}$ and compute the absolute phase error\n  $$\n  \\Delta\\phi \\;=\\; \\min_{k\\in\\mathbb{Z}} \\left| \\phi_{\\mathrm{num}}(T) \\;-\\; \\phi_{\\mathrm{exact}}(T) \\;-\\; 2\\pi k \\right| \\;\\in\\; [0,\\pi],\n  $$\n  i.e., the smallest absolute difference modulo $2\\pi$. Compare the error against a target GW-inspired cumulative phase budget $\\Delta\\phi_{\\max}$, where you must use $\\Delta\\phi_{\\max}=0.1$.\n\n- The error-controlled RK must use a relative tolerance `rtol` and a hard cap $h_{\\max}$ on the time step. The symplectic method must use a fixed number of steps `n_symp` with step size $h=T/n_{\\mathrm{symp}}$.\n\nTest suite:\n\nProvide results for the following parameter sets as three test cases, each given as a tuple ($r_0$, $\\mu$, $N$, `rtol`, `target_steps_RK`, `n_symp`):\n\n- Case A (happy path): (10.0, 1.0, 200, $10^{-8}$, 300000, 262144),\n- Case B (tighter orbit, different tolerance): (1.0, 1.0, 500, $10^{-6}$, 200000, 131072),\n- Case C (long-time accumulation, over $10^6$ steps): (7.0, 1.0, 4000, $10^{-7}$, 1024000, 1048576).\n\nFor the error-controlled RK in each case, set the hard cap to $h_{\\max}=T/\\mathrm{target\\_steps}_{\\mathrm{RK}}$. For the symplectic method, set $h=T/n_{\\mathrm{symp}}$. In all cases, compute the absolute phase error $\\Delta\\phi$ at $t=T$ for both integrators and determine whether each error satisfies the GW phase budget $\\Delta\\phi \\le \\Delta\\phi_{\\max}$.\n\nFinal output specification:\n\n- Your program must produce a single line containing a list that aggregates results for all three test cases in the following order:\n  [$\\Delta\\phi_{\\mathrm{RK}}^{(A)}$,$\\Delta\\phi_{\\mathrm{SV}}^{(A)}$,$\\mathrm{ok}_{\\mathrm{RK}}^{(A)}$,$\\mathrm{ok}_{\\mathrm{SV}}^{(A)}$,$\\Delta\\phi_{\\mathrm{RK}}^{(B)}$,$\\Delta\\phi_{\\mathrm{SV}}^{(B)}$,$\\mathrm{ok}_{\\mathrm{RK}}^{(B)}$,$\\mathrm{ok}_{\\mathrm{SV}}^{(B)}$,$\\Delta\\phi_{\\mathrm{RK}}^{(C)}$,$\\Delta\\phi_{\\mathrm{SV}}^{(C)}$,$\\mathrm{ok}_{\\mathrm{RK}}^{(C)}$,$\\mathrm{ok}_{\\mathrm{SV}}^{(C)}$].\n- Each $\\Delta\\phi$ must be a floating-point number in radians, and each $\\mathrm{ok}$ must be a boolean indicating whether the corresponding method meets the phase budget $\\Delta\\phi_{\\max}=0.1$.\n- No other text must be printed.\n\nYour implementation must be fully self-contained, use no external input, and be scientifically sound and numerically consistent with the stated equations. The program must run using any modern Python environment, as long as it adheres to the specified constraints.", "solution": "The core of the problem is to implement and compare two numerical integrators for a Hamiltonian system describing a test-mass orbit. The system of ordinary differential equations (ODEs) to be solved is given by the state vector $\\mathbf{y} = [r, p_r, \\phi]^T$:\n$$\n\\frac{d\\mathbf{y}}{dt} = \\mathbf{f}(t, \\mathbf{y}) =\n\\begin{pmatrix}\np_r \\\\\nL^2/r^3 - \\mu/r^2 \\\\\nL/r^2\n\\end{pmatrix}\n$$\nThe parameters $L$ and $\\mu$ are constant throughout the integration. For each test case, we first compute the derived constants: angular momentum $L = \\sqrt{\\mu r_0}$, orbital frequency $\\omega = \\sqrt{\\mu/r_0^3}$, and total integration time $T = 2\\pi N / \\omega$.\n\n**Integrator 1: Adaptive Embedded Runge-Kutta RK2(1)**\nThis method advances the solution from time $t_n$ to $t_{n+1} = t_n + h$ using two estimates of the solution at the new time, one of order $p=2$ and another of order $p-1=1$. We use the Heun-Euler pair.\nLet $\\mathbf{y}_n$ be the state at time $t_n$. The steps are:\n$1$. Compute the first-order (Euler) stage:\n$$ \\mathbf{k}_1 = \\mathbf{f}(t_n, \\mathbf{y}_n) $$\n$2$. Compute the second stage:\n$$ \\mathbf{k}_2 = \\mathbf{f}(t_n + h, \\mathbf{y}_n + h \\mathbf{k}_1) $$\n$3$. The higher-order (order $2$, Heun's method) solution is:\n$$ \\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{h}{2}(\\mathbf{k}_1 + \\mathbf{k}_2) $$\n$4$. The lower-order (order $1$, Euler's method) solution is:\n$$ \\hat{\\mathbf{y}}_{n+1} = \\mathbf{y}_n + h \\mathbf{k}_1 $$\n$5$. The local error estimate is the difference between these two:\n$$ \\mathbf{E} = \\mathbf{y}_{n+1} - \\hat{\\mathbf{y}}_{n+1} = \\frac{h}{2}(\\mathbf{k}_2 - \\mathbf{k}_1) $$\n$6$. Step-size control: The step is accepted if a scalar norm of the error is within the specified tolerance. We use a relative error criterion on the dynamical variables $(r,p_r)$, as their accuracy governs the path of the orbit. Let $\\mathbf{E}_{dyn} = (E_r, E_{p_r})$. The error is controlled by requiring $\\Vert\\mathbf{E}_{dyn}\\Vert_2 < rtol \\cdot \\Vert(r_n, p_{r,n})\\Vert_2$.\nIf the step is accepted, the new step size $h_{\\text{new}}$ is calculated as:\n$$ h_{\\text{new}} = S \\cdot h_{\\text{old}} \\left( \\frac{rtol \\cdot \\Vert(r_n, p_{r,n})\\Vert_2}{\\Vert\\mathbf{E}_{dyn}\\Vert_2} \\right)^{1/2} $$\nwhere $S=0.9$ is a safety factor. If rejected, the step is retaken with this smaller $h_{\\text{new}}$. The step size is always capped at $h_{\\max}$.\n\n**Integrator 2: Symplectic Störmer-Verlet**\nThis method is applied to the separable Hamiltonian where $H = T(p_r) + V_{\\mathrm{eff}}(r)$. It uses a fixed step size $h = T / n_{\\mathrm{symp}}$. The force is $F(r) = - \\frac{dV_{\\mathrm{eff}}}{dr} = \\frac{L^2}{r^3} - \\frac{\\mu}{r^2}$. The update from state $(r_n, p_{r,n})$ to $(r_{n+1}, p_{r,n+1})$ is a kick-drift-kick sequence:\n$1$. First half-kick for momentum:\n$$ p_{r, n+1/2} = p_{r,n} + F(r_n) \\frac{h}{2} $$\n$2$. Full drift for position, using the half-step momentum:\n$$ r_{n+1} = r_n + p_{r, n+1/2} h $$\n$3$. Second half-kick for momentum:\n$$ p_{r, n+1} = p_{r, n+1/2} + F(r_{n+1}) \\frac{h}{2} $$\nThe phase $\\phi$ is integrated simultaneously using a second-order accurate Simpson's rule quadrature for $\\int_{t_n}^{t_{n+1}} \\frac{L}{r(t)^2} dt$. This requires the radius at the beginning, middle, and end of the step. We have $r_{\\mathrm{before}} = r_n$ and $r_{\\mathrm{after}} = r_{n+1}$. A consistent second-order estimate for the midpoint radius is obtained by a half-drift:\n$$ r_{\\mathrm{mid}} = r_n + p_{r, n+1/2} \\frac{h}{2} $$\nThe phase update is then:\n$$ \\phi_{n+1} = \\phi_n + \\frac{hL}{6} \\left( \\frac{1}{r_n^2} + \\frac{4}{r_{\\mathrm{mid}}^2} + \\frac{1}{r_{n+1}^2} \\right) $$\nThis scheme preserves the symplectic structure of the $(r, p_r)$ subsystem, which is known to provide excellent long-term conservation of energy for an appropriately chosen step size.\n\n**Final Phase Error Calculation**\nFor both methods, after integrating up to time $T$, we obtain a numerical phase $\\phi_{\\mathrm{num}}(T)$. The exact phase is $\\phi_{\\mathrm{exact}}(T) = \\omega T = 2\\pi N$. The phase error is the smallest difference on a circle, calculated as:\n$$\n\\Delta\\phi = |\\mathrm{mod}(\\phi_{\\mathrm{num}} - \\phi_{\\mathrm{exact}} + \\pi, 2\\pi) - \\pi|\n$$\nThis maps the raw difference into $[-\\pi, \\pi]$ and then takes the absolute value, ensuring the result is in $[0, \\pi]$ as required. This value is then compared to $\\Delta\\phi_{\\max}=0.1$ to determine if the phase fidelity budget is met.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Main solver function that executes the test suite and prints the final results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # (r0, mu, N, rtol, target_steps_RK, n_symp)\n    test_cases = [\n        (10.0, 1.0, 200, 1e-8, 300000, 262144),      # Case A\n        (1.0, 1.0, 500, 1e-6, 200000, 131072),       # Case B\n        (7.0, 1.0, 4000, 1e-7, 1024000, 1048576),    # Case C\n    ]\n\n    # Maximum allowed phase error for Gravitational Wave budget\n    delta_phi_max = 0.1\n    \n    results = []\n\n    for case in test_cases:\n        r0, mu, N, rtol, target_steps_rk, n_symp = case\n\n        # --- Calculate orbit constants ---\n        L = math.sqrt(mu * r0)\n        omega = math.sqrt(mu / r0**3)\n        T_final = (2.0 * math.pi * N) / omega\n        \n        # --- Initial Conditions ---\n        y0 = np.array([r0, 0.0, 0.0])  # [r, p_r, phi]\n\n        # --- Run RK Integrator ---\n        h_max_rk = T_final / target_steps_rk\n        phi_rk = integrate_rk_adaptive(y0, T_final, L, mu, rtol, h_max_rk)\n        \n        # --- Run Symplectic Integrator ---\n        phi_sv = integrate_symplectic(y0, T_final, n_symp, L, mu)\n\n        # --- Calculate Phase Errors ---\n        phi_exact = omega * T_final\n        \n        # Calculate phase error for RK, wrapped to [0, pi]\n        err_rk_raw = phi_rk - phi_exact\n        delta_phi_rk = abs( (err_rk_raw + math.pi) % (2.0 * math.pi) - math.pi )\n        \n        # Calculate phase error for Symplectic, wrapped to [0, pi]\n        err_sv_raw = phi_sv - phi_exact\n        delta_phi_sv = abs( (err_sv_raw + math.pi) % (2.0 * math.pi) - math.pi )\n\n        # --- Check against budget ---\n        ok_rk = (delta_phi_rk <= delta_phi_max)\n        ok_sv = (delta_phi_sv <= delta_phi_max)\n        \n        results.extend([delta_phi_rk, delta_phi_sv, ok_rk, ok_sv])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef get_rhs(y, L, mu):\n    \"\"\"Computes the right-hand side of the ODE system.\"\"\"\n    r, p_r, _ = y\n    dr_dt = p_r\n    dp_r_dt = (L**2 / r**3) - (mu / r**2)\n    dphi_dt = L / r**2\n    return np.array([dr_dt, dp_r_dt, dphi_dt])\n\n\ndef integrate_rk_adaptive(y0, T_final, L, mu, rtol, h_max):\n    \"\"\"\n    Integrates the ODE system using an adaptive RK2(1) embedded method (Heun-Euler).\n    \"\"\"\n    y = np.copy(y0)\n    t = 0.0\n    h = h_max  # Initial step size guess\n    safety_factor = 0.9\n    \n    while t < T_final:\n        if t + h > T_final:\n            h = T_final - t\n\n        while True:\n            # Embedded RK2(1) / Heun-Euler method\n            k1 = get_rhs(y, L, mu)\n            \n            # Use k1 to step forward to get y at t+h for k2\n            y_temp = y + h * k1\n            # Prevent r from becoming non-positive in a bad step\n            if y_temp[0] <= 0:\n                h *= 0.5\n                continue\n\n            k2 = get_rhs(y_temp, L, mu)\n            \n            # Higher-order (2nd) estimate\n            y_next = y + 0.5 * h * (k1 + k2)\n            \n            # Lower-order (1st) estimate is simply the Euler step\n            # Note: y_temp is the Euler step proposal\n            \n            # Estimate local error as the difference between the two\n            # We only control error on the dynamical variables r and p_r\n            error_est_vec = y_next - y_temp\n            error_norm = np.linalg.norm(error_est_vec[:2])\n\n            # Desired error based on relative tolerance\n            # Add a small absolute tolerance to prevent division by zero for p_r=0\n            scale = rtol * np.linalg.norm(y[:2]) + 1e-12 \n            \n            if error_norm < scale:\n                # Step is accepted\n                t += h\n                y = y_next\n                # Update next step size\n                if error_norm > 0:\n                    h_new = h * safety_factor * (scale / error_norm)**0.5\n                else: # Error is zero, can afford to increase step size\n                    h_new = h * 2.0\n                h = min(h_new, h_max)\n                break\n            else:\n                # Step is rejected, reduce step size and retry\n                h_new = h * safety_factor * (scale / error_norm)**0.5\n                h = max(h_new, 1e-9) # Prevent h from becoming too small\n                if t + h > T_final:\n                    h = T_final-t\n                    if h <= 0: # If we are too close to end, finish\n                        return y[2]\n\n\n    return y[2]\n\n\ndef get_force(r, L, mu):\n    \"\"\"Computes the radial force F(r) = -dV_eff/dr.\"\"\"\n    return (L**2 / r**3) - (mu / r**2)\n    \n\ndef integrate_symplectic(y0, T_final, n_steps, L, mu):\n    \"\"\"\n    Integrates the ODE system using a 2nd order Störmer-Verlet method\n    with a Simpson-rule quadrature for the phase.\n    \"\"\"\n    r, p_r, phi = y0\n    h = T_final / n_steps\n\n    for _ in range(n_steps):\n        r_before = r\n        \n        # First half-kick for momentum\n        p_mid = p_r + 0.5 * h * get_force(r, L, mu)\n        \n        # Calculate midpoint radius for phase integration\n        r_mid = r + 0.5 * h * p_mid\n\n        # Full drift for position\n        r_after = r + h * p_mid\n        \n        # Second half-kick for momentum\n        p_r = p_mid + 0.5 * h * get_force(r_after, L, mu)\n        r = r_after\n        \n        # Update phase using Simpson's rule\n        delta_phi = (h * L / 6.0) * (1.0 / r_before**2 + 4.0 / r_mid**2 + 1.0 / r_after**2)\n        phi += delta_phi\n\n    return phi\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3493030"}]}