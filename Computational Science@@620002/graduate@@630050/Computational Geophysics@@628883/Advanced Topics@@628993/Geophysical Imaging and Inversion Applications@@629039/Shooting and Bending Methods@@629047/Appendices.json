{"hands_on_practices": [{"introduction": "Our first practice focuses on the mathematical engine of the shooting method. We will formulate the ray tracing problem as a root-finding exercise and use Newton's method to solve it. This exercise is crucial for understanding how the abstract goal of hitting a receiver is translated into a concrete, iterative numerical algorithm. [@problem_id:3614395]", "problem": "Consider acoustic ray tracing in a two-dimensional, isotropic medium. One seeks to solve a two-point boundary value problem using the shooting method: choose an initial-parameter vector $\\boldsymbol{\\alpha}$ so that the ray launched from a source location $\\mathbf{x}_{s} \\in \\mathbb{R}^{2}$ reaches a receiver location $\\mathbf{x}_{r} \\in \\mathbb{R}^{2}$ at an arrival time $T$. Define the residual function $\\mathbf{F}(\\boldsymbol{\\alpha})$ by $\\mathbf{F}(\\boldsymbol{\\alpha})=\\mathbf{x}(\\boldsymbol{\\alpha},T)-\\mathbf{x}_{r}$, where $\\mathbf{x}(\\boldsymbol{\\alpha},t)$ is the solution of the ray Ordinary Differential Equation (ODE) parameterized by $\\boldsymbol{\\alpha}$ and evolved to time $t$. \n\n1. Starting from the fundamental kinematic description of rays in a homogeneous, isotropic medium of constant wavespeed $c_{0}>0$ (rays are straight lines traveling at speed $c_{0}$), construct explicitly the residual $\\mathbf{F}(\\boldsymbol{\\alpha})$ when $\\boldsymbol{\\alpha}=[\\theta,\\,T]^{\\top}$, where $\\theta$ is the takeoff angle from $\\mathbf{x}_{s}$ and $T$ is the travel time. Also derive the Jacobian matrix $\\nabla_{\\boldsymbol{\\alpha}}\\mathbf{F}(\\boldsymbol{\\alpha})$.\n\n2. Discuss the differentiability of $\\mathbf{F}$ with respect to $\\boldsymbol{\\alpha}$ and state conditions on the medium and the ray mapping required to ensure local quadratic convergence of Newton-type solvers applied to $\\mathbf{F}(\\boldsymbol{\\alpha})=\\mathbf{0}$.\n\n3. For the specific case with $c_{0}=3$ (in $\\mathrm{km/s}$), $\\mathbf{x}_{s}=(0,0)$ (in $\\mathrm{km}$), $\\mathbf{x}_{r}=(3,4)$ (in $\\mathrm{km}$), and the initial guess $\\boldsymbol{\\alpha}_{0}=[\\theta_{0},\\,T_{0}]^{\\top}=\\left[\\frac{\\pi}{4},\\,1.5\\right]^{\\top}$, perform one Newton iteration \n$$\n\\boldsymbol{\\alpha}_{1}=\\boldsymbol{\\alpha}_{0}-\\left(\\nabla_{\\boldsymbol{\\alpha}}\\mathbf{F}(\\boldsymbol{\\alpha}_{0})\\right)^{-1}\\mathbf{F}(\\boldsymbol{\\alpha}_{0}).\n$$\nReport $\\boldsymbol{\\alpha}_{1}$ as a $1\\times 2$ row matrix containing $\\theta_{1}$ (in radians) and $T_{1}$ (in seconds). Express your final answer in exact closed form (no numerical rounding).", "solution": "The problem statement has been evaluated and is deemed valid. It is scientifically grounded, well-posed, objective, and contains all necessary information to derive a unique solution.\n\n### Part 1: Construction of the Residual and Jacobian\n\nIn a two-dimensional, homogeneous, isotropic medium with constant wavespeed $c_{0}$, a ray originating from the source position $\\mathbf{x}_{s} = \\begin{pmatrix} x_s \\\\ z_s \\end{pmatrix}$ with a takeoff angle $\\theta$ travels along a straight line. The velocity vector is constant and given by $\\mathbf{v} = \\begin{pmatrix} c_{0} \\cos\\theta \\\\ c_{0} \\sin\\theta \\end{pmatrix}$. The position of the ray at time $t$ is therefore\n$$\n\\mathbf{x}(t) = \\mathbf{x}_{s} + t\\mathbf{v} = \\begin{pmatrix} x_s + t c_{0} \\cos\\theta \\\\ z_s + t c_{0} \\sin\\theta \\end{pmatrix}.\n$$\nThe problem defines the parameter vector as $\\boldsymbol{\\alpha} = [\\theta, T]^{\\top}$. The residual function $\\mathbf{F}(\\boldsymbol{\\alpha})$ is given by the mismatch between the ray's endpoint at the candidate travel time $T$ and the receiver location $\\mathbf{x}_{r} = \\begin{pmatrix} x_r \\\\ z_r \\end{pmatrix}$.\n$$\n\\mathbf{F}(\\boldsymbol{\\alpha}) = \\mathbf{x}(\\boldsymbol{\\alpha}, T) - \\mathbf{x}_{r}\n$$\nHere, the position function $\\mathbf{x}$ depends on $\\theta$ from $\\boldsymbol{\\alpha}$, and it is evaluated at time $T$, which is the second component of $\\boldsymbol{\\alpha}$. Substituting the expression for the ray path, we obtain the explicit form of the residual:\n$$\n\\mathbf{F}(\\theta, T) = \\begin{pmatrix} F_1(\\theta, T) \\\\ F_2(\\theta, T) \\end{pmatrix} = \\begin{pmatrix} x_s + T c_{0} \\cos\\theta - x_r \\\\ z_s + T c_{0} \\sin\\theta - z_r \\end{pmatrix}.\n$$\nThe Jacobian matrix, $\\nabla_{\\boldsymbol{\\alpha}}\\mathbf{F}(\\boldsymbol{\\alpha})$, is a $2 \\times 2$ matrix of the partial derivatives of $\\mathbf{F}$ with respect to the components of $\\boldsymbol{\\alpha} = [\\theta, T]^{\\top}$:\n$$\n\\nabla_{\\boldsymbol{\\alpha}}\\mathbf{F}(\\boldsymbol{\\alpha}) = J(\\theta, T) = \\begin{pmatrix} \\frac{\\partial F_1}{\\partial \\theta}  \\frac{\\partial F_1}{\\partial T} \\\\ \\frac{\\partial F_2}{\\partial \\theta}  \\frac{\\partial F_2}{\\partial T} \\end{pmatrix}.\n$$\nWe compute each partial derivative:\n$$\n\\frac{\\partial F_1}{\\partial \\theta} = \\frac{\\partial}{\\partial \\theta} (x_s + T c_{0} \\cos\\theta - x_r) = -T c_{0} \\sin\\theta\n$$\n$$\n\\frac{\\partial F_1}{\\partial T} = \\frac{\\partial}{\\partial T} (x_s + T c_{0} \\cos\\theta - x_r) = c_{0} \\cos\\theta\n$$\n$$\n\\frac{\\partial F_2}{\\partial \\theta} = \\frac{\\partial}{\\partial \\theta} (z_s + T c_{0} \\sin\\theta - z_r) = T c_{0} \\cos\\theta\n$$\n$$\n\\frac{\\partial F_2}{\\partial T} = \\frac{\\partial}{\\partial T} (z_s + T c_{0} \\sin\\theta - z_r) = c_{0} \\sin\\theta\n$$\nAssembling these components gives the Jacobian matrix:\n$$\n\\nabla_{\\boldsymbol{\\alpha}}\\mathbf{F}(\\boldsymbol{\\alpha}) = \\begin{pmatrix} -T c_{0} \\sin\\theta  c_{0} \\cos\\theta \\\\ T c_{0} \\cos\\theta  c_{0} \\sin\\theta \\end{pmatrix}.\n$$\n\n### Part 2: Differentiability and Convergence Conditions\n\nFor the homogeneous medium described, the components of the residual function $\\mathbf{F}(\\theta, T)$ are combinations of trigonometric functions ($\\sin\\theta$, $\\cos\\theta$) and linear functions of $T$. These are infinitely differentiable ($C^{\\infty}$) functions over their entire domain $\\mathbb{R}^2$. Therefore, $\\mathbf{F}$ is continuously differentiable with respect to $\\boldsymbol{\\alpha}$ to any order.\n\nThe convergence of Newton-type solvers to a solution $\\boldsymbol{\\alpha}^{*}$ of $\\mathbf{F}(\\boldsymbol{\\alpha})=\\mathbf{0}$ is typically quadratic if the following conditions are met in a neighborhood of $\\boldsymbol{\\alpha}^{*}$:\n1.  The function $\\mathbf{F}$ is twice continuously differentiable (i.e., $C^2$).\n2.  The Jacobian matrix $\\nabla_{\\boldsymbol{\\alpha}}\\mathbf{F}(\\boldsymbol{\\alpha}^{*})$ is non-singular (i.e., invertible).\n\nAs established, for the homogeneous medium, $\\mathbf{F}$ is $C^{\\infty}$, so the first condition is satisfied. To check the second condition, we compute the determinant of the Jacobian matrix:\n$$\n\\det(\\nabla_{\\boldsymbol{\\alpha}}\\mathbf{F}(\\boldsymbol{\\alpha})) = (-T c_{0} \\sin\\theta) (c_{0} \\sin\\theta) - (c_{0} \\cos\\theta) (T c_{0} \\cos\\theta)\n$$\n$$\n= -T c_{0}^2 \\sin^2\\theta - T c_{0}^2 \\cos^2\\theta = -T c_{0}^2 (\\sin^2\\theta + \\cos^2\\theta) = -T c_{0}^2.\n$$\nThe Jacobian is invertible if and only if its determinant is non-zero. Since the wavespeed $c_0  0$, we have $c_0^2  0$. Therefore, the Jacobian is non-singular provided that the travel time $T \\neq 0$. For any physically meaningful problem where the source and receiver are distinct ($\\mathbf{x}_s \\neq \\mathbf{x}_r$), the travel time must be positive ($T0$). Thus, for the homogeneous medium, the Jacobian is always invertible at the solution, and Newton's method will exhibit local quadratic convergence.\n\nFor a general heterogeneous, isotropic medium where the velocity $c(\\mathbf{x})$ varies with position, the ray path $\\mathbf{x}(\\boldsymbol{\\alpha}, t)$ is the solution of a system of ordinary differential equations (the ray equations). The differentiability of the ray path with respect to initial conditions (like $\\theta$) depends on the smoothness of the velocity field $c(\\mathbf{x})$. For $\\mathbf{F}$ to be $C^2$, the velocity field $c(\\mathbf{x})$ must be sufficiently smooth (e.g., $C^3$). Furthermore, the condition of an invertible Jacobian corresponds to the geometric condition that the receiver $\\mathbf{x}_r$ does not lie on a caustic of the ray family launched from $\\mathbf{x}_s$. At a caustic, infinitesimally close rays cross, leading to a singularity in the ray mapping and a singular Jacobian.\n\n### Part 3: Newton Iteration\n\nWe are given the specific values:\n- Wavespeed: $c_{0}=3$\n- Source: $\\mathbf{x}_{s}=(0,0)$\n- Receiver: $\\mathbf{x}_{r}=(3,4)$\n- Initial guess: $\\boldsymbol{\\alpha}_{0} = [\\theta_{0}, T_{0}]^{\\top} = \\left[\\frac{\\pi}{4}, 1.5\\right]^{\\top} = \\left[\\frac{\\pi}{4}, \\frac{3}{2}\\right]^{\\top}$\n\nThe Newton iteration is $\\boldsymbol{\\alpha}_{1} = \\boldsymbol{\\alpha}_{0} - (\\nabla_{\\boldsymbol{\\alpha}}\\mathbf{F}(\\boldsymbol{\\alpha}_{0}))^{-1}\\mathbf{F}(\\boldsymbol{\\alpha}_{0})$.\n\n**Step 1: Evaluate $\\mathbf{F}(\\boldsymbol{\\alpha}_{0})$**\nThe residual function is:\n$$\n\\mathbf{F}(\\theta, T) = \\begin{pmatrix} 3T\\cos\\theta - 3 \\\\ 3T\\sin\\theta - 4 \\end{pmatrix}\n$$\nAt $\\boldsymbol{\\alpha}_{0}=\\left[\\frac{\\pi}{4}, \\frac{3}{2}\\right]^{\\top}$, we have $\\cos(\\frac{\\pi}{4}) = \\frac{\\sqrt{2}}{2}$ and $\\sin(\\frac{\\pi}{4}) = \\frac{\\sqrt{2}}{2}$.\n$$\nF_1(\\boldsymbol{\\alpha}_{0}) = 3 \\left(\\frac{3}{2}\\right) \\cos\\left(\\frac{\\pi}{4}\\right) - 3 = \\frac{9}{2}\\frac{\\sqrt{2}}{2} - 3 = \\frac{9\\sqrt{2}}{4} - 3\n$$\n$$\nF_2(\\boldsymbol{\\alpha}_{0}) = 3 \\left(\\frac{3}{2}\\right) \\sin\\left(\\frac{\\pi}{4}\\right) - 4 = \\frac{9}{2}\\frac{\\sqrt{2}}{2} - 4 = \\frac{9\\sqrt{2}}{4} - 4\n$$\nSo, $\\mathbf{F}(\\boldsymbol{\\alpha}_{0}) = \\begin{pmatrix} \\frac{9\\sqrt{2}}{4} - 3 \\\\ \\frac{9\\sqrt{2}}{4} - 4 \\end{pmatrix}$.\n\n**Step 2: Evaluate the Jacobian $\\nabla_{\\boldsymbol{\\alpha}}\\mathbf{F}(\\boldsymbol{\\alpha}_{0})$**\nThe Jacobian is:\n$$\nJ(\\theta, T) = \\begin{pmatrix} -3T\\sin\\theta  3\\cos\\theta \\\\ 3T\\cos\\theta  3\\sin\\theta \\end{pmatrix}\n$$\nAt $\\boldsymbol{\\alpha}_{0}$:\n$$\nJ(\\boldsymbol{\\alpha}_{0}) = \\begin{pmatrix} -3\\left(\\frac{3}{2}\\right)\\sin\\left(\\frac{\\pi}{4}\\right)  3\\cos\\left(\\frac{\\pi}{4}\\right) \\\\ 3\\left(\\frac{3}{2}\\right)\\cos\\left(\\frac{\\pi}{4}\\right)  3\\sin\\left(\\frac{\\pi}{4}\\right) \\end{pmatrix} = \\begin{pmatrix} -\\frac{9}{2}\\frac{\\sqrt{2}}{2}  3\\frac{\\sqrt{2}}{2} \\\\ \\frac{9}{2}\\frac{\\sqrt{2}}{2}  3\\frac{\\sqrt{2}}{2} \\end{pmatrix} = \\begin{pmatrix} -\\frac{9\\sqrt{2}}{4}  \\frac{3\\sqrt{2}}{2} \\\\ \\frac{9\\sqrt{2}}{4}  \\frac{3\\sqrt{2}}{2} \\end{pmatrix}.\n$$\n\n**Step 3: Invert the Jacobian**\nThe determinant is $\\det(J(\\boldsymbol{\\alpha}_{0})) = -T_0 c_0^2 = -\\left(\\frac{3}{2}\\right)(3^2) = -\\frac{27}{2}$.\nThe inverse is:\n$$\nJ^{-1} = \\frac{1}{-\\frac{27}{2}} \\begin{pmatrix} \\frac{3\\sqrt{2}}{2}  -\\frac{3\\sqrt{2}}{2} \\\\ -\\frac{9\\sqrt{2}}{4}  -\\frac{9\\sqrt{2}}{4} \\end{pmatrix} = -\\frac{2}{27} \\begin{pmatrix} \\frac{3\\sqrt{2}}{2}  -\\frac{3\\sqrt{2}}{2} \\\\ -\\frac{9\\sqrt{2}}{4}  -\\frac{9\\sqrt{2}}{4} \\end{pmatrix} = \\begin{pmatrix} -\\frac{\\sqrt{2}}{9}  \\frac{\\sqrt{2}}{9} \\\\ \\frac{\\sqrt{2}}{6}  \\frac{\\sqrt{2}}{6} \\end{pmatrix}.\n$$\n\n**Step 4: Calculate the update $\\Delta \\boldsymbol{\\alpha}_{0} = J^{-1}\\mathbf{F}(\\boldsymbol{\\alpha}_{0})$**\n$$\n\\Delta \\boldsymbol{\\alpha}_{0} = \\begin{pmatrix} \\Delta\\theta_0 \\\\ \\Delta T_0 \\end{pmatrix} = \\begin{pmatrix} -\\frac{\\sqrt{2}}{9}  \\frac{\\sqrt{2}}{9} \\\\ \\frac{\\sqrt{2}}{6}  \\frac{\\sqrt{2}}{6} \\end{pmatrix} \\begin{pmatrix} \\frac{9\\sqrt{2}}{4} - 3 \\\\ \\frac{9\\sqrt{2}}{4} - 4 \\end{pmatrix}\n$$\nThe first component:\n$$\n\\Delta\\theta_0 = -\\frac{\\sqrt{2}}{9}\\left(\\frac{9\\sqrt{2}}{4} - 3\\right) + \\frac{\\sqrt{2}}{9}\\left(\\frac{9\\sqrt{2}}{4} - 4\\right) = \\frac{\\sqrt{2}}{9}\\left[-\\left(\\frac{9\\sqrt{2}}{4} - 3\\right) + \\left(\\frac{9\\sqrt{2}}{4} - 4\\right)\\right] = \\frac{\\sqrt{2}}{9}(3-4) = -\\frac{\\sqrt{2}}{9}.\n$$\nThe second component:\n$$\n\\Delta T_0 = \\frac{\\sqrt{2}}{6}\\left(\\frac{9\\sqrt{2}}{4} - 3\\right) + \\frac{\\sqrt{2}}{6}\\left(\\frac{9\\sqrt{2}}{4} - 4\\right) = \\frac{\\sqrt{2}}{6}\\left(2\\frac{9\\sqrt{2}}{4} - 7\\right) = \\frac{\\sqrt{2}}{6}\\left(\\frac{9\\sqrt{2}}{2} - 7\\right) = \\frac{9 \\cdot 2}{12} - \\frac{7\\sqrt{2}}{6} = \\frac{3}{2} - \\frac{7\\sqrt{2}}{6}.\n$$\n\n**Step 5: Compute the new estimate $\\boldsymbol{\\alpha}_{1}$**\n$$\n\\boldsymbol{\\alpha}_{1} = \\boldsymbol{\\alpha}_{0} - \\Delta \\boldsymbol{\\alpha}_{0} = \\begin{pmatrix} \\theta_0 \\\\ T_0 \\end{pmatrix} - \\begin{pmatrix} \\Delta\\theta_0 \\\\ \\Delta T_0 \\end{pmatrix}\n$$\n$$\n\\theta_1 = \\theta_0 - \\Delta\\theta_0 = \\frac{\\pi}{4} - \\left(-\\frac{\\sqrt{2}}{9}\\right) = \\frac{\\pi}{4} + \\frac{\\sqrt{2}}{9}\n$$\n$$\nT_1 = T_0 - \\Delta T_0 = \\frac{3}{2} - \\left(\\frac{3}{2} - \\frac{7\\sqrt{2}}{6}\\right) = \\frac{7\\sqrt{2}}{6}\n$$\nThe result of one Newton iteration is $\\boldsymbol{\\alpha}_{1} = \\left[\\frac{\\pi}{4} + \\frac{\\sqrt{2}}{9}, \\frac{7\\sqrt{2}}{6}\\right]^{\\top}$. The answer is requested as a $1\\times 2$ row matrix.", "answer": "$$\n\\boxed{\\begin{pmatrix} \\frac{\\pi}{4} + \\frac{\\sqrt{2}}{9}  \\frac{7\\sqrt{2}}{6} \\end{pmatrix}}\n$$", "id": "3614395"}, {"introduction": "Having explored the core iterative step, we now build a more complete simulation. This exercise tasks you with implementing a shooting method that can handle a fundamental feature of geological models: interfaces between different media. You will use event detection to pinpoint where a ray crosses an interface and apply Snell's law to correctly calculate its new path, tackling both refraction and total internal reflection. [@problem_id:3614361]", "problem": "Implement a ray-shooting integrator with interface handling by event detection, including automatic reflection/refraction state switching at a planar interface and momentum updates consistent with Snell’s law in three dimensions. Use a Hamiltonian ray framework specialized to isotropic, homogeneous media on each side of a single planar interface. Represent the ray state by position $\\mathbf{x}\\in\\mathbb{R}^3$ and a unit propagation direction $\\mathbf{u}\\in\\mathbb{S}^2$ evolved with respect to arc-length $s$ by the Ordinary Differential Equation (ODE) system $d\\mathbf{x}/ds=\\mathbf{u}$ and $d\\mathbf{u}/ds=\\mathbf{0}$ within each homogeneous region. Detect interface crossings by an event function $\\phi(\\mathbf{x})=\\mathbf{n}\\cdot(\\mathbf{x}-\\mathbf{x}_\\mathrm{int})$, where $\\mathbf{x}_\\mathrm{int}\\in\\mathbb{R}^3$ is a point on the interface plane and $\\mathbf{n}\\in\\mathbb{R}^3$ is the unit normal directed from medium $1$ into medium $2$. At $\\phi(\\mathbf{x})=0$, perform either a reflection or a refraction according to Snell’s law, and update the ray’s momentum (phase slowness vector) $\\mathbf{p}$ accordingly. Assume isotropic wave speeds $c_1$ and $c_2$ on the two sides of the interface. All distances must be expressed in meters (m), wave speeds in meters per second (m/s), and arc-length $s$ in meters (m). Any angle computations must be carried out in radians.\n\nFundamental base and constraints:\n- The ODE model within a homogeneous medium is $d\\mathbf{x}/ds=\\mathbf{u}$ and $d\\mathbf{u}/ds=\\mathbf{0}$, with $\\|\\mathbf{u}\\|=1$.\n- The phase slowness vector $\\mathbf{p}$ satisfies $\\|\\mathbf{p}\\|=1/c$, where $c$ is the local wave speed (m/s), and the group direction is parallel to $\\mathbf{u}$ with $\\mathbf{u}=c\\,\\mathbf{p}$.\n- At the interface, the tangential component of $\\mathbf{p}$ is continuous and the normal component is determined by the dispersion relation $\\|\\mathbf{p}\\|=1/c$ in the outgoing medium. Let $\\mathbf{p}_n=(\\mathbf{p}\\cdot\\mathbf{n})\\mathbf{n}$ and $\\mathbf{p}_t=\\mathbf{p}-\\mathbf{p}_n$. For reflection, $\\mathbf{p}'=\\mathbf{p}-2\\mathbf{p}_n$. For refraction from an incident medium with speed $c_\\mathrm{in}$ to a transmitted medium with speed $c_\\mathrm{out}$, set $\\mathbf{p}_t'=\\mathbf{p}_t$ and $$p_n'=\\sigma\\sqrt{\\frac{1}{c_\\mathrm{out}^2}-\\|\\mathbf{p}_t\\|^2},$$ where $\\sigma=+1$ if transmitting from medium $1$ to medium $2$ (i.e., increasing $\\phi$), and $\\sigma=-1$ if transmitting from medium $2$ to medium $1$ (i.e., decreasing $\\phi$). Total internal reflection occurs if $\\|\\mathbf{p}_t\\|\\frac{1}{c_\\mathrm{out}}$. In that case, use the reflection update. After updating $\\mathbf{p}$, update the unit direction by $\\mathbf{u}=c\\,\\mathbf{p}$ using the wave speed $c$ appropriate to the post-event medium.\n- Use event detection to locate $\\phi(\\mathbf{x})=0$. Upon an event, update the medium state and momentum/direction according to the rules above, then continue integration until the prescribed arc-length $s_{\\max}$ is reached.\n\nYour program must take no input and must implement the above integrator and event logic for the following test suite. The interface is the plane defined by $\\mathbf{x}_\\mathrm{int}=(0,0,0)\\,\\mathrm{m}$ and $\\mathbf{n}=(0,0,1)$, with medium $1$ defined by $\\phi(\\mathbf{x})0$ and medium $2$ by $\\phi(\\mathbf{x})0$. Use wave speeds $c_1$ and $c_2$ as specified per case. For each case, integrate from the given initial state $(\\mathbf{x}_0,\\mathbf{u}_0)$ up to arc-length $s_{\\max}$, applying event detection and interface updates as needed. For numerical stability, treat the near-critical refraction regime using a robust tolerance at the decision boundary.\n\nTest suite:\n- Case A (normal-incidence refraction, slow to fast): $\\mathbf{x}_0=(0,0,-100)\\,\\mathrm{m}$, $\\mathbf{u}_0=(0,0,1)$, $c_1=2000\\,\\mathrm{m/s}$, $c_2=4000\\,\\mathrm{m/s}$, $s_{\\max}=300\\,\\mathrm{m}$.\n- Case B (oblique refraction, slow to fast): $\\mathbf{x}_0=(0,0,-100)\\,\\mathrm{m}$, $\\mathbf{u}_0=\\frac{1}{\\sqrt{5}}(1,0,2)$, $c_1=2000\\,\\mathrm{m/s}$, $c_2=4000\\,\\mathrm{m/s}$, $s_{\\max}=300\\,\\mathrm{m}$.\n- Case C (total internal reflection, beyond critical, slow to fast): $\\mathbf{x}_0=(0,0,-100)\\,\\mathrm{m}$, $\\mathbf{u}_0=(\\sqrt{1-0.3^2},0,0.3)$, $c_1=2000\\,\\mathrm{m/s}$, $c_2=4000\\,\\mathrm{m/s}$, $s_{\\max}=300\\,\\mathrm{m}$.\n- Case D (near-critical refraction, slow to fast): $\\mathbf{x}_0=(0,0,-100)\\,\\mathrm{m}$, $\\mathbf{u}_0=\\big(0.499,0,\\sqrt{1-0.499^2}\\big)$, $c_1=2000\\,\\mathrm{m/s}$, $c_2=4000\\,\\mathrm{m/s}$, $s_{\\max}=300\\,\\mathrm{m}$.\n- Case E (oblique refraction, fast to slow): $\\mathbf{x}_0=(0,0,100)\\,\\mathrm{m}$, $\\mathbf{u}_0=(0.6,0,-0.8)$, $c_1=2000\\,\\mathrm{m/s}$, $c_2=4000\\,\\mathrm{m/s}$, $s_{\\max}=300\\,\\mathrm{m}$.\n\nFor each case, define and report an integer mode indicating the last interface operation encountered during the run up to $s_{\\max}$: mode $0$ if no interface was encountered, mode $1$ if the last interface operation was a refraction, and mode $2$ if the last interface operation was a reflection. The required program output is a single line containing a JSON-like array of results, one per case, with each case reported as a flat array of $7$ numbers:\n- $[\\text{mode}, x_\\mathrm{final}, y_\\mathrm{final}, z_\\mathrm{final}, p_{x,\\mathrm{final}}, p_{y,\\mathrm{final}}, p_{z,\\mathrm{final}}]$,\nwhere $\\mathbf{x}_\\mathrm{final}$ is the final position in meters and $\\mathbf{p}_\\mathrm{final}$ is the final momentum (slowness) vector in $\\mathrm{s/m}$ at $s=s_{\\max}$. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[r_1,r_2,r_3,r_4,r_5]$), where each $r_i$ is itself a bracketed, comma-separated list of $7$ floats with no additional whitespace.", "solution": "The user requests the implementation of a 3D ray-tracing algorithm for acoustic waves in a medium composed of two homogeneous, isotropic half-spaces separated by a planar interface. The algorithm must handle reflection and refraction at the interface according to Snell's law, including the case of total internal reflection (TIR).\n\n### Problem Validation\n\nFirst, the problem statement is validated against the required criteria.\n\n*   **Step 1: Extract Givens**\n    *   **Ray State**: Position $\\mathbf{x} \\in \\mathbb{R}^3$, unit direction vector $\\mathbf{u} \\in \\mathbb{S}^2$.\n    *   **ODE Model**: In each homogeneous region, the ray path evolves with arc-length $s$ according to $d\\mathbf{x}/ds=\\mathbf{u}$ and $d\\mathbf{u}/ds=\\mathbf{0}$.\n    *   **Momentum (Slowness) Vector**: $\\mathbf{p}$, with $\\|\\mathbf{p}\\| = 1/c$ where $c$ is the local wave speed. The group velocity direction is $\\mathbf{u} = c\\mathbf{p}$.\n    *   **Interface**: A plane defined by $\\mathbf{x}_{\\mathrm{int}} \\in \\mathbb{R}^3$ and unit normal $\\mathbf{n} \\in \\mathbb{R}^3$. The event function is $\\phi(\\mathbf{x})=\\mathbf{n}\\cdot(\\mathbf{x}-\\mathbf{x}_{\\mathrm{int}})=0$. Medium 1 is where $\\phi(\\mathbf{x})0$, Medium 2 is where $\\phi(\\mathbf{x})0$.\n    *   **Interface Physics (Snell's Law)**: Tangential slowness $\\mathbf{p}_t = \\mathbf{p} - (\\mathbf{p}\\cdot\\mathbf{n})\\mathbf{n}$ is continuous.\n        *   **Reflection**: $\\mathbf{p}' = \\mathbf{p} - 2(\\mathbf{p}\\cdot\\mathbf{n})\\mathbf{n}$.\n        *   **Refraction**: $\\mathbf{p}'_t = \\mathbf{p}_t$, and the new normal slowness is $p'_n = \\sigma \\sqrt{1/c_{\\mathrm{out}}^2 - \\|\\mathbf{p}_t\\|^2}$, where $\\sigma=+1$ for $1 \\to 2$ transmission and $\\sigma=-1$ for $2 \\to 1$.\n        *   **Total Internal Reflection (TIR)**: Occurs if $\\|\\mathbf{p}_t\\|  1/c_{\\mathrm{out}}$, in which case the reflection rule is used.\n    *   **Test Environment**: Interface is at $z=0$ ($\\mathbf{x}_{\\mathrm{int}}=(0,0,0), \\mathbf{n}=(0,0,1)$). Medium 1 for $z0$, Medium 2 for $z0$.\n    *   **Test Cases**: Five specific cases (A-E) are provided with initial conditions $(\\mathbf{x}_0, \\mathbf{u}_0)$, wave speeds $(c_1, c_2)$, and maximum arc-length $s_{\\max}$.\n    *   **Output**: For each case, report a mode integer (0 for no event, 1 for refraction, 2 for reflection) and the final state $(\\mathbf{x}_{\\mathrm{final}}, \\mathbf{p}_{\\mathrm{final}})$. The format is a JSON-like array of arrays.\n\n*   **Step 2: Validate Using Extracted Givens**\n    *   **Scientifically Grounded**: The problem is based on the well-established Hamiltonian formulation of ray theory in geometrical optics/acoustics and Snell's law. All physical and mathematical principles are standard and correct.\n    *   **Well-Posed**: The problem is an initial value problem for an ODE with well-defined event handling. All parameters and initial conditions are provided, ensuring a unique solution exists for each test case.\n    *   **Objective**: The problem is stated using precise, unambiguous mathematical language.\n    *   **Consistency**: The givens are self-consistent. The initial direction vectors $\\mathbf{u}_0$ for all test cases are correctly specified as unit vectors. The physics of reflection, refraction, and TIR are consistently described by the slowness vector formulation.\n\n*   **Step 3: Verdict and Action**\n    *   The problem is **valid**. It is a well-defined, scientifically sound problem in computational physics. A solution will be developed.\n\n### Algorithmic Design\n\nSince the medium is homogeneous between interface encounters, the ray paths are straight lines. This allows for an analytical \"integration\" of the ray path between events, which is more efficient and accurate than a numerical ODE solver for this specific problem.\n\nThe algorithm proceeds as follows for each test case:\n\n1.  **Initialization**:\n    *   The initial state is set: position $\\mathbf{x} \\leftarrow \\mathbf{x}_0$, direction $\\mathbf{u} \\leftarrow \\mathbf{u}_0$, and arc-length $s \\leftarrow 0$.\n    *   The initial `mode` is set to $0$ (no event).\n    *   The initial wave speed $c$ is determined from $\\mathbf{x}_0$.\n    *   The initial momentum vector is calculated as $\\mathbf{p} = \\mathbf{u}_0/c$.\n\n2.  **Integration Loop**: The algorithm iterates in a loop as long as the current arc-length $s$ is less than $s_{\\max}$.\n    *   **Event Prediction**: In each step, the algorithm calculates the arc-length `dist_to_event` required for the ray to reach the interface plane $z=0$. This is found by solving for the parameter $s'$ in the line equation $(\\mathbf{x} + s' \\mathbf{u}) \\cdot \\mathbf{n} = 0$, which gives $s' = -(\\mathbf{x} \\cdot \\mathbf{n}) / (\\mathbf{u} \\cdot \\mathbf{n})$. If $\\mathbf{u} \\cdot \\mathbf{n} = 0$, the ray is parallel to the interface and will not cross it. If $s' \\le 0$, the interface is behind the ray, so it will not be crossed.\n    *   **Path Segment Integration**:\n        *   If no event occurs before $s_{\\max}$ (i.e., `dist_to_event` is negative, infinite, or greater than the remaining arc-length $s_{\\max}-s$), the ray is propagated in a straight line to its final position at $s_{\\max}$. The loop then terminates.\n        *   If an event occurs, the ray is propagated to the interface. The state variables are updated: $\\mathbf{x} \\leftarrow \\mathbf{x} + \\text{dist\\_to\\_event} \\cdot \\mathbf{u}$ and $s \\leftarrow s + \\text{dist\\_to\\_event}$.\n\n    *   **Event Handling**: At the interface, the following steps are performed:\n        1.  The incident and outgoing wave speeds, $c_{\\mathrm{in}}$ and $c_{\\mathrm{out}}$, are identified based on the ray's current medium.\n        2.  The incident momentum $\\mathbf{p}$ is decomposed into its tangential ($\\mathbf{p}_t$) and normal ($\\mathbf{p}_n$) components relative to the interface normal $\\mathbf{n}$.\n        3.  The condition for total internal reflection is checked by evaluating the term under the square root in the refraction formula: $1/c_{\\mathrm{out}}^2 - \\|\\mathbf{p}_t\\|^2$. If this term is negative, TIR occurs.\n        4.  **Reflection**: If TIR occurs (or for a reflection event), the `mode` is set to $2$. The new momentum $\\mathbf{p}'$ is calculated by reversing the normal component: $\\mathbf{p}' = \\mathbf{p}_t - \\mathbf{p}_n = \\mathbf{p} - 2\\mathbf{p}_n$. The ray continues in the incident medium, so the new direction is $\\mathbf{u}' = c_{\\mathrm{in}}\\mathbf{p}'$.\n        5.  **Refraction**: If TIR does not occur, the `mode` is set to $1$. The new normal momentum component's magnitude is $p'_{n, \\text{mag}} = \\sqrt{1/c_{\\mathrm{out}}^2 - \\|\\mathbf{p}_t\\|^2}$. The sign $\\sigma$ is chosen to ensure the ray propagates into the new medium. The new momentum is $\\mathbf{p}' = \\mathbf{p}_t + \\sigma p'_{n, \\text{mag}}\\mathbf{n}$. The ray is now in the outgoing medium, so the new direction is $\\mathbf{u}' = c_{\\mathrm{out}}\\mathbf{p}'$.\n        6.  The state variables $\\mathbf{p}$ and $\\mathbf{u}$ are updated to their new values. The loop then continues to the next segment.\n\n3.  **Finalization**: After the loop terminates, the final values of `mode`, $\\mathbf{x}$, and $\\mathbf{p}$ constitute the result for the test case. This is repeated for all cases. The final output is formatted into a single-line JSON-style string as specified.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the ray tracing problem for all test cases.\n    \"\"\"\n    # The interface is the plane z=0.\n    interface_point = np.array([0.0, 0.0, 0.0])\n    interface_normal = np.array([0.0, 0.0, 1.0])\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (normal-incidence refraction, slow to fast)\n        {'x0': (0.0, 0.0, -100.0), 'u0': (0.0, 0.0, 1.0), \n         'c1': 2000.0, 'c2': 4000.0, 's_max': 300.0},\n        # Case B (oblique refraction, slow to fast)\n        {'x0': (0.0, 0.0, -100.0), 'u0': (1.0/np.sqrt(5), 0.0, 2.0/np.sqrt(5)), \n         'c1': 2000.0, 'c2': 4000.0, 's_max': 300.0},\n        # Case C (total internal reflection is possible, but ray does not reach interface)\n        {'x0': (0.0, 0.0, -100.0), 'u0': (np.sqrt(1 - 0.3**2), 0.0, 0.3), \n         'c1': 2000.0, 'c2': 4000.0, 's_max': 300.0},\n        # Case D (near-critical refraction, slow to fast)\n        {'x0': (0.0, 0.0, -100.0), 'u0': (0.499, 0.0, np.sqrt(1 - 0.499**2)), \n         'c1': 2000.0, 'c2': 4000.0, 's_max': 300.0},\n        # Case E (oblique refraction, fast to slow)\n        {'x0': (0.0, 0.0, 100.0), 'u0': (0.6, 0.0, -0.8), \n         'c1': 2000.0, 'c2': 4000.0, 's_max': 300.0},\n    ]\n\n    all_results = []\n    for case in test_cases:\n        result = trace_ray(\n            case['x0'], case['u0'], case['s_max'],\n            case['c1'], case['c2'],\n            interface_normal, interface_point\n        )\n        all_results.append(result)\n\n    # Format the output string precisely as required, without extra whitespace.\n    result_strings = []\n    for res in all_results:\n        # Format mode as int, others as floats using 'g' for general format.\n        formatted_res = [f\"{int(res[0])}\"] + [f\"{v:.15g}\" for v in res[1:]]\n        result_strings.append(f\"[{','.join(formatted_res)}]\")\n    \n    print(f\"[{','.join(result_strings)}]\")\n\ndef trace_ray(x0, u0, s_max, c1, c2, n, x_int):\n    \"\"\"\n    Implements a ray-shooting integrator with event detection at a planar interface.\n    The ray path is piecewise linear, so the integration is done analytically.\n    \n    Args:\n        x0 (tuple): Initial position vector.\n        u0 (tuple): Initial direction unit vector.\n        s_max (float): Maximum arc-length for integration.\n        c1 (float): Wave speed in medium 1 (phi  0).\n        c2 (float): Wave speed in medium 2 (phi  0).\n        n (np.ndarray): Interface normal vector.\n        x_int (np.ndarray): A point on the interface plane.\n\n    Returns:\n        list: A list containing [mode, x_final, y_final, z_final, \n                                p_x_final, p_y_final, p_z_final].\n    \"\"\"\n    x = np.array(x0, dtype=float)\n    u = np.array(u0, dtype=float)\n    s = 0.0\n    mode = 0  # 0: no event, 1: refraction, 2: reflection\n\n    # Determine initial medium and momentum p\n    phi = np.dot(n, x - x_int)\n    c_current = c1 if phi  0 else c2\n    p = u / c_current\n\n    while s  s_max:\n        phi = np.dot(n, x - x_int)\n        u_n_comp = np.dot(u, n)\n\n        # Determine incident and outgoing media properties based on current position\n        if phi  0: # In medium 1, moving toward medium 2\n            c_in = c1\n            c_out = c2\n        else: # In medium 2, moving toward medium 1\n            c_in = c2\n            c_out = c1\n\n        # Calculate distance to event (interface crossing)\n        dist_to_event = float('inf') if np.isclose(u_n_comp, 0) else -phi / u_n_comp\n        \n        s_rem = s_max - s\n\n        # A small tolerance avoids re-triggering an event immediately after one.\n        if dist_to_event = 1e-12 or dist_to_event >= s_rem:\n            # No event, or event is beyond s_max. Propagate to the end.\n            x += s_rem * u\n            s = s_max\n            break\n\n        # An event occurs.\n        # 1. Propagate to the interface\n        x += dist_to_event * u\n        s += dist_to_event\n        # Clamp position to the interface to prevent floating-point drift\n        x = x - np.dot(x - x_int, n) * n\n\n        # 2. Handle interface interaction\n        p_t = p - np.dot(p, n) * n\n        p_t_norm_sq = np.dot(p_t, p_t)\n        \n        sqrt_arg = 1.0/c_out**2 - p_t_norm_sq\n        \n        # Check for Total Internal Reflection (TIR)\n        if sqrt_arg  0:\n            mode = 2\n            p = p - 2.0 * np.dot(p, n) * n\n            u = c_in * p\n        else: # Refraction\n            mode = 1\n            sigma = np.sign(u_n_comp)\n            p_n_new_mag = sigma * np.sqrt(sqrt_arg)\n            p = p_t + p_n_new_mag * n\n            u = c_out * p\n\n    return [mode, x[0], x[1], x[2], p[0], p[1], p[2]]\n\nsolve()\n```", "id": "3614361"}, {"introduction": "We now shift our focus to bending methods, which optimize the entire ray path simultaneously. This practice delves into a critical aspect of these methods: the choice of path discretization and its impact on accuracy. By comparing a simple node-based representation with a smoother cubic spline, you will quantify the discretization bias and explore how errors in the optimization functional correlate with errors in the physical quantity of interest—the traveltime. [@problem_id:3614363]", "problem": "Consider two-dimensional isotropic ray propagation in a smoothly varying medium. The ray path between a source point and a receiver point minimizes the integral of slowness along the path according to Fermat’s principle. To quantify discretization bias introduced by different path representations commonly used in bending methods, your task is to compute the action and the traveltime under two path discretizations and then correlate the resulting action errors with the traveltime errors across a set of discretization levels.\n\nFundamental base: In isotropic media, the traveltime functional is the integral of slowness along arc length, and bending methods use a path action functional constructed from the slowness and a curvature penalty. Start from Fermat’s principle and the Euler–Lagrange variational conditions for path optimization in a medium with differentiable slowness.\n\nDefinitions and scenario setup:\n- Let the slowness field be defined over two-dimensional space by a smooth, strictly positive function $n(\\mathbf{x})$, with $\\mathbf{x} = (x,z)$. The medium is parameterized as an exponential slowness field\n$$\nn(x,z) = n_0 \\exp\\!\\big(a\\,x + b\\,z\\big),\n$$\nwhere $n_0$ is a positive constant with units seconds per meter, and $a$ and $b$ are constants with units inverse meters. This choice guarantees differentiability and positivity while yielding a constant spatial gradient of $\\ln n$.\n- Let the ray action for bending be defined as\n$$\nS[\\mathbf{x}(s)] = \\int_0^{s^\\star} \\Big(n(\\mathbf{x}(s)) + \\lambda\\,\\kappa(s)^2\\Big)\\,\\mathrm{d}s,\n$$\nwhere $s$ is arc length, $s^\\star$ is the total arc length from source to receiver, $\\lambda$ is a positive regularization parameter with units seconds times meters, and $\\kappa(s)$ is the curvature magnitude along the path with units inverse meters. The traveltime is\n$$\nT[\\mathbf{x}(s)] = \\int_0^{s^\\star} n(\\mathbf{x}(s))\\,\\mathrm{d}s.\n$$\n- The “true” ray path is the minimizer of the traveltime functional in the given medium. It must be computed by solving the appropriate boundary value problem derived from Fermat’s principle with the given $n(x,z)$.\n- Two path discretizations are to be compared:\n  1. Nodes (piecewise linear polyline): The path is represented by $N$ nodes equally spaced in arc length along the “true” ray, connected by straight segments. The discretized action is computed by summing segment contributions using a midpoint evaluation of slowness and adding a discrete curvature penalty based on turning angles at interior nodes.\n  2. Splines (cubic): A parametric cubic spline $\\mathbf{x}(u)$, $u\\in[0,U]$, is fit through the same $N$ nodes with natural boundary conditions. The action is computed by numerically integrating the slowness term along the spline and a curvature-squared term constructed from the parametric derivatives.\n\nUnits and angle specification:\n- All distances must be in meters (m).\n- Slowness must be in seconds per meter (s/m).\n- Traveltime and action must be in seconds (s).\n- All angles must be in radians.\n\nRequired computations:\n1. Compute the “true” ray path between the source and receiver by solving the boundary value problem implied by Fermat’s principle in the given medium; you may use a shooting method to find the initial ray direction and the total arc length $s^\\star$ that lands at the receiver.\n2. Compute the “true” traveltime $T_{\\mathrm{true}}$ and the “true” action $S_{\\mathrm{true}}$ (which includes curvature penalty) along the “true” path.\n3. For each discretization level $N$, construct the nodes by sampling the “true” path at $N$ equally spaced arc length positions. Then:\n   - For the node-based polyline:\n     - Approximate the traveltime $T_{\\mathrm{node}}(N)$ using the midpoint slowness times segment length along each straight segment.\n     - Approximate the curvature-squared integral by a sum over interior nodes using the squared turning angle divided by an appropriate local length scale, and add $\\lambda$ times this sum to $T_{\\mathrm{node}}(N)$ to obtain $S_{\\mathrm{node}}(N)$.\n   - For the cubic spline:\n     - Fit parametric cubic splines $x(u)$ and $z(u)$ through the nodes using chord length parameter $u$ with natural end conditions.\n     - Compute the traveltime $T_{\\mathrm{spline}}(N)$ by numerical quadrature of $n(\\mathbf{x}(u))\\,\\|\\mathrm{d}\\mathbf{x}/\\mathrm{d}u\\|$ over $u$.\n     - Compute the curvature-squared contribution by numerical quadrature using parametric derivatives and add $\\lambda$ times that to $T_{\\mathrm{spline}}(N)$ to obtain $S_{\\mathrm{spline}}(N)$.\n4. For each discretization level $N$, compute the signed errors relative to the “true” values:\n   - Action errors: $E_{S,\\mathrm{node}}(N) = S_{\\mathrm{node}}(N) - S_{\\mathrm{true}}$ and $E_{S,\\mathrm{spline}}(N) = S_{\\mathrm{spline}}(N) - S_{\\mathrm{true}}$.\n   - Traveltime errors: $E_{T,\\mathrm{node}}(N) = T_{\\mathrm{node}}(N) - T_{\\mathrm{true}}$ and $E_{T,\\mathrm{spline}}(N) = T_{\\mathrm{spline}}(N) - T_{\\mathrm{true}}$.\n5. Over the set of $N$ values in the test suite for a given case, compute the Pearson correlation coefficient between action errors and traveltime errors for the node discretization, and likewise for the spline discretization.\n\nTest suite:\nFor each case below, use $N \\in \\{\\,4,\\,8,\\,16,\\,32\\,\\}$.\n- Case $1$: $n_0 = 1/2000$ s/m, $a = 5\\times 10^{-4}$ m$^{-1}$, $b = 8\\times 10^{-4}$ m$^{-1}$, source $\\mathbf{S} = (0,0)$ m, receiver $\\mathbf{R} = (1500,500)$ m, $\\lambda = 10^{-3}$ s·m.\n- Case $2$: $n_0 = 1/2000$ s/m, $a = 1\\times 10^{-5}$ m$^{-1}$, $b = -1\\times 10^{-5}$ m$^{-1}$, source $\\mathbf{S} = (0,0)$ m, receiver $\\mathbf{R} = (1500,500)$ m, $\\lambda = 10^{-3}$ s·m.\n- Case $3$: $n_0 = 1/1800$ s/m, $a = 3\\times 10^{-3}$ m$^{-1}$, $b = 2\\times 10^{-3}$ m$^{-1}$, source $\\mathbf{S} = (0,0)$ m, receiver $\\mathbf{R} = (2000,700)$ m, $\\lambda = 10^{-3}$ s·m.\n- Case $4$: $n_0 = 1/2200$ s/m, $a = -1\\times 10^{-3}$ m$^{-1}$, $b = 2\\times 10^{-3}$ m$^{-1}$, source $\\mathbf{S} = (500,100)$ m, receiver $\\mathbf{R} = (2500,1500)$ m, $\\lambda = 10^{-3}$ s·m.\n\nFinal output specification:\n- For each case, produce two floats: the Pearson correlation coefficient for the node discretization and the Pearson correlation coefficient for the spline discretization, in that order.\n- Round each float to six decimal places.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered as\n$$\n[\\rho_{\\mathrm{node},1},\\rho_{\\mathrm{spline},1},\\rho_{\\mathrm{node},2},\\rho_{\\mathrm{spline},2},\\rho_{\\mathrm{node},3},\\rho_{\\mathrm{spline},3},\\rho_{\\mathrm{node},4},\\rho_{\\mathrm{spline},4}],\n$$\nwhere indices denote the case number.", "solution": "The problem requires an analysis of discretization errors for two common path representations in seismic ray bending methods. The core task is to compute the correlation between errors in traveltime and errors in a regularized action functional. This is performed by first determining the \"true\" ray path and its associated properties, then comparing them against approximations derived from a piecewise-linear (node-based) path and a cubic spline path.\n\n### 1. The \"True\" Ray Path from Fermat's Principle\n\nThe fundamental principle governing ray propagation in an isotropic medium is Fermat's principle, which states that the ray path is a stationary path of the traveltime functional:\n$$\nT[\\mathbf{x}(s)] = \\int_{\\mathbf{S}}^{\\mathbf{R}} n(\\mathbf{x}(s)) \\, \\mathrm{d}s\n$$\nwhere $n(\\mathbf{x})$ is the slowness field, $\\mathbf{x}(s)$ is the path parameterized by arc length $s$, and $\\mathbf{S}$ and $\\mathbf{R}$ are the source and receiver points, respectively. The path that minimizes this functional is found by solving the Euler-Lagrange equations. In ray theory, these are known as the ray equations:\n$$\n\\frac{d}{ds} \\left( n(\\mathbf{x}) \\frac{d\\mathbf{x}}{ds} \\right) = \\nabla n(\\mathbf{x})\n$$\nLet $\\mathbf{x}(s) = (x(s), z(s))$ and the tangent vector be $\\mathbf{t}(s) = \\frac{d\\mathbf{x}}{ds} = (t_x(s), t_z(s))$. The given slowness field is $n(x,z) = n_0 \\exp(ax+bz)$. The gradient of the slowness is $\\nabla n = (\\frac{\\partial n}{\\partial x}, \\frac{\\partial n}{\\partial z}) = (an, bn)$. The ray equations expand to a system of second-order ordinary differential equations (ODEs), which can be written as a system of first-order ODEs. Let the state vector be $\\mathbf{y}(s) = [x(s), z(s), t_x(s), t_z(s)]^T$. The system is:\n$$\n\\begin{cases}\n\\frac{dx}{ds} = t_x \\\\\n\\frac{dz}{ds} = t_z \\\\\n\\frac{dt_x}{ds} = a - (a t_x + b t_z) t_x \\\\\n\\frac{dt_z}{ds} = b - (a t_x + b t_z) t_z\n\\end{cases}\n$$\nThis system is subject to the boundary conditions $\\mathbf{x}(0) = \\mathbf{S}$ and $\\mathbf{x}(s^\\star) = \\mathbf{R}$, where $s^\\star$ is the total arc length, which is unknown. The initial tangent vector $\\mathbf{t}(0) = (\\cos \\theta_0, \\sin \\theta_0)$ depends on the unknown initial launch angle $\\theta_0$. This constitutes a boundary value problem (BVP).\n\nWe solve this BVP using a shooting method. We define an objective function that measures the mismatch at the receiver for a given launch angle $\\theta_0$ and total arc length $s^\\star$. We seek the roots of the vector function $\\mathbf{F}(\\theta_0, s^\\star) = \\mathbf{x}_{\\text{final}}(\\theta_0, s^\\star) - \\mathbf{R} = \\mathbf{0}$. This nonlinear system is solved using a numerical root-finding algorithm.\n\n### 2. Computation of True Traveltime and Action\n\nOnce the true path parameters $(\\theta_0, s^\\star)$ are found, we can compute the \"true\" traveltime $T_{\\mathrm{true}}$ and \"true\" action $S_{\\mathrm{true}}$ by integrating along this path. To do this efficiently, we augment the ODE system:\n$$\n\\begin{cases}\n\\frac{dT}{ds} = n(x(s), z(s)) \\\\\n\\frac{dS}{ds} = n(x(s), z(s)) + \\lambda \\kappa(s)^2\n\\end{cases}\n$$\nwith initial conditions $T(0)=0$ and $S(0)=0$. The curvature $\\kappa(s)$ is given by $\\kappa(s) = \\left\\| \\frac{d\\mathbf{t}}{ds} \\right\\|_2 = \\sqrt{(\\frac{dt_x}{ds})^2 + (\\frac{dt_z}{ds})^2}$. The derivatives $\\frac{dt_x}{ds}$ and $\\frac{dt_z}{ds}$ are known from the ray equations. We integrate this augmented $6$-component ODE system from $s=0$ to $s=s^\\star$ to obtain the true path and the values $T_{\\mathrm{true}} = T(s^\\star)$ and $S_{\\mathrm{true}} = S(s^\\star)$.\n\n### 3. Path Discretization and Approximate Quantities\n\nFor each discretization level $N$, we sample $N$ nodes $\\mathbf{x}_i$ for $i=0, \\dots, N-1$ from the true path at equally spaced arc lengths $s_i = i \\cdot s^\\star / (N-1)$.\n\n#### 3.1. Node-based (Piecewise Linear) Approximation\nThe path is represented by $N-1$ linear segments connecting consecutive nodes $\\{\\mathbf{x}_i\\}_{i=0}^{N-1}$.\n\n- **Traveltime $T_{\\mathrm{node}}(N)$**: We use a midpoint rule for each segment. For the segment between $\\mathbf{x}_i$ and $\\mathbf{x}_{i+1}$, the contribution is $n(\\mathbf{m}_i)L_i$, where $\\mathbf{m}_i = (\\mathbf{x}_i + \\mathbf{x}_{i+1})/2$ is the midpoint and $L_i = \\|\\mathbf{x}_{i+1} - \\mathbf{x}_i\\|_2$ is the segment length.\n$$\nT_{\\mathrm{node}}(N) = \\sum_{i=0}^{N-2} n\\left(\\frac{\\mathbf{x}_i + \\mathbf{x}_{i+1}}{2}\\right) \\|\\mathbf{x}_{i+1} - \\mathbf{x}_i\\|_2\n$$\n\n- **Action $S_{\\mathrm{node}}(N)$**: The action is the sum of the traveltime and the curvature penalty. The continuous integral $\\int \\kappa^2 ds$ is approximated by a discrete sum over the $N-2$ interior nodes. At each interior node $\\mathbf{x}_i$, the discrete curvature term is taken as the squared turning angle $\\phi_i^2$ divided by a local length scale $\\Delta s_i$. The turning angle $\\phi_i$ is the angle between the vector from $\\mathbf{x}_{i-1}$ to $\\mathbf{x}_i$ and the vector from $\\mathbf{x}_i$ to $\\mathbf{x}_{i+1}$. The length scale is the average of the two adjacent segment lengths, $\\Delta s_i = (L_{i-1} + L_i)/2$.\n$$\nS_{\\mathrm{node}}(N) = T_{\\mathrm{node}}(N) + \\lambda \\sum_{i=1}^{N-2} \\frac{\\phi_i^2}{(\\|\\mathbf{x}_i - \\mathbf{x}_{i-1}\\|_2 + \\|\\mathbf{x}_{i+1} - \\mathbf{x}_i\\|_2)/2}\n$$\n\n#### 3.2. Cubic Spline Approximation\nA parametric cubic spline $\\mathbf{x}(u)=(x(u), z(u))$ is fit through the $N$ nodes. The parameter $u$ is chosen to be the cumulative chord length: $u_0=0$ and $u_i = u_{i-1} + \\|\\mathbf{x}_i - \\mathbf{x}_{i-1}\\|_2$. Natural boundary conditions (zero second derivatives at endpoints) are used.\n\n- **Traveltime $T_{\\mathrm{spline}}(N)$**: This is computed by numerically integrating the slowness along the spline curve. The integrand involves the arc length element in the parameter $u$, $\\mathrm{d}s = \\|\\frac{\\mathrm{d}\\mathbf{x}}{\\mathrm{d}u}\\|_2 \\mathrm{d}u$.\n$$\nT_{\\mathrm{spline}}(N) = \\int_0^{u_{N-1}} n(x(u), z(u)) \\sqrt{\\left(\\frac{dx}{du}\\right)^2 + \\left(\\frac{dz}{du}\\right)^2} \\, \\mathrm{d}u\n$$\n\n- **Action $S_{\\mathrm{spline}}(N)$**: The curvature contribution is found by integrating $\\kappa(u)^2$ along the spline's arc length. The curvature of a parametric curve is $\\kappa(u) = |x'z'' - z'x''| / (x'^2+z'^2)^{3/2}$, where primes denote derivatives with respect to $u$.\n$$\nS_{\\mathrm{spline}}(N) = T_{\\mathrm{spline}}(N) + \\lambda \\int_0^{u_{N-1}} \\kappa(u)^2 \\left\\|\\frac{\\mathrm{d}\\mathbf{x}}{\\mathrm{d}u}\\right\\|_2 \\, \\mathrm{d}u = T_{\\mathrm{spline}}(N) + \\lambda \\int_0^{u_{N-1}} \\frac{(x'z''-z'x'')^2}{(x'^2+z'^2)^{5/2}} \\, \\mathrm{d}u\n$$\nBoth integrals for the spline approximation are evaluated using numerical quadrature.\n\n### 4. Error Analysis and Correlation\n\nFor each discretization level $N \\in \\{4, 8, 16, 32\\}$, we compute the signed errors for both the traveltime and the action functional relative to their true values:\n$$\nE_{T, \\text{method}}(N) = T_{\\text{method}}(N) - T_{\\mathrm{true}}\n$$\n$$\nE_{S, \\text{method}}(N) = S_{\\text{method}}(N) - S_{\\mathrm{true}}\n$$\nwhere 'method' is either 'node' or 'spline'. Finally, for each test case, we compute the Pearson correlation coefficient $\\rho$ between the vector of action errors $\\{E_{S,\\text{method}}(N)\\}_{N \\in \\{4,8,16,32\\}}$ and the vector of traveltime errors $\\{E_{T,\\text{method}}(N)\\}_{N \\in \\{4,8,16,32\\}}$. This yields one correlation coefficient for the node-based method and one for the spline-based method per test case.\n$$\n\\rho = \\frac{\\sum_{i=1}^4 (x_i - \\bar{x})(y_i - \\bar{y})}{\\sqrt{\\sum_{i=1}^4 (x_i - \\bar{x})^2} \\sqrt{\\sum_{i=1}^4 (y_i - \\bar{y})^2}}\n$$\nwhere $x_i$ and $y_i$ represent the errors for a given $N$. This process is repeated for all four test cases provided.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp, quad\nfrom scipy.interpolate import CubicSpline\nfrom scipy.optimize import root\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # Case 1\n        {'n0': 1/2000.0, 'a': 5e-4, 'b': 8e-4, 'S': (0.0, 0.0), 'R': (1500.0, 500.0), 'lambda_reg': 1e-3},\n        # Case 2\n        {'n0': 1/2000.0, 'a': 1e-5, 'b': -1e-5, 'S': (0.0, 0.0), 'R': (1500.0, 500.0), 'lambda_reg': 1e-3},\n        # Case 3\n        {'n0': 1/1800.0, 'a': 3e-3, 'b': 2e-3, 'S': (0.0, 0.0), 'R': (2000.0, 700.0), 'lambda_reg': 1e-3},\n        # Case 4\n        {'n0': 1/2200.0, 'a': -1e-3, 'b': 2e-3, 'S': (500.0, 100.0), 'R': (2500.0, 1500.0), 'lambda_reg': 1e-3},\n    ]\n\n    N_values = [4, 8, 16, 32]\n    all_results = []\n\n    for case_params in test_cases:\n        ro_node, ro_spline = solve_case(N_values=N_values, **case_params)\n        all_results.extend([ro_node, ro_spline])\n\n    # Format the final output as a comma-separated list of floats rounded to 6 decimal places.\n    formatted_results = [f\"{r:.6f}\" for r in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef solve_case(n0, a, b, S, R, lambda_reg, N_values):\n    \"\"\"\n    Solves a single test case: find true path, compute errors for each N, and find correlations.\n    \"\"\"\n    S, R = np.array(S), np.array(R)\n    \n    # 1. Compute the \"true\" ray path and properties\n    \n    def slowness(x, z):\n        return n0 * np.exp(a * x + b * z)\n\n    def ray_ode(s, y, a, b, n0, lambda_reg):\n        x, z, tx, tz, T, S_val = y\n        \n        # Ray equations\n        dtds_term = a * tx + b * tz\n        dtx_ds = a - dtds_term * tx\n        dtz_ds = b - dtds_term * tz\n        \n        # Current slowness\n        n_current = slowness(x, z)\n        \n        # Curvature squared\n        kappa_sq = dtx_ds**2 + dtz_ds**2\n        \n        # State derivatives\n        dx_ds = tx\n        dz_ds = tz\n        dT_ds = n_current\n        dS_ds = n_current + lambda_reg * kappa_sq\n        \n        return [dx_ds, dz_ds, dtx_ds, dtz_ds, dT_ds, dS_ds]\n\n    # Shooting method for BVP\n    def shooting_objective(vars):\n        theta0, s_star = vars\n        y0 = [S[0], S[1], np.cos(theta0), np.sin(theta0), 0.0, 0.0]\n        sol = solve_ivp(\n            ray_ode, [0, s_star], y0, \n            args=(a, b, n0, lambda_reg), \n            dense_output=True, rtol=1e-8, atol=1e-8\n        )\n        final_pos = sol.y[:2, -1]\n        return final_pos - R\n\n    # Initial guess for shooting\n    delta = R - S\n    s_star_guess = np.linalg.norm(delta)\n    theta0_guess = np.arctan2(delta[1], delta[0])\n    \n    sol_root = root(shooting_objective, [theta0_guess, s_star_guess], method='hybr', tol=1e-8)\n    theta0_true, s_star_true = sol_root.x\n\n    # Integrate one last time to get the true path and values\n    y0_true = [S[0], S[1], np.cos(theta0_true), np.sin(theta0_true), 0.0, 0.0]\n    \n    # Generate evaluation points for discretization\n    all_s_eval = {N: np.linspace(0, s_star_true, N) for N in N_values}\n    s_eval_points = np.unique(np.concatenate(list(all_s_eval.values())))\n    \n    sol_true = solve_ivp(\n        ray_ode, [0, s_star_true], y0_true, \n        args=(a, b, n0, lambda_reg),\n        t_eval=s_eval_points, dense_output=True, rtol=1e-9, atol=1e-9\n    )\n\n    T_true = sol_true.y[4, -1]\n    S_true = sol_true.y[5, -1]\n    \n    # A map from s_eval points to their solution indices\n    s_map = {s: i for i, s in enumerate(sol_true.t)}\n\n    # 2. Compute errors for each discretization level\n    errors_node = {'T': [], 'S': []}\n    errors_spline = {'T': [], 'S': []}\n    \n    for N in N_values:\n        # Get nodes from true path solution\n        node_indices = [s_map[s] for s in all_s_eval[N]]\n        nodes = sol_true.y[:2, node_indices].T\n        \n        # --- Node-based (polyline) calculation ---\n        segments = nodes[1:] - nodes[:-1]\n        lengths = np.linalg.norm(segments, axis=1)\n        midpoints = (nodes[:-1] + nodes[1:]) / 2\n        \n        T_node = np.sum(slowness(midpoints[:, 0], midpoints[:, 1]) * lengths)\n        \n        curv_term_node = 0.0\n        for i in range(1, N - 1):\n            v_in = nodes[i] - nodes[i-1]\n            v_out = nodes[i+1] - nodes[i]\n            len_in = np.linalg.norm(v_in)\n            len_out = np.linalg.norm(v_out)\n            \n            cos_phi = np.dot(v_in, v_out) / (len_in * len_out)\n            phi = np.arccos(np.clip(cos_phi, -1.0, 1.0))\n            \n            local_len = 0.5 * (len_in + len_out)\n            if local_len > 1e-9: # Avoid division by zero\n                curv_term_node += phi**2 / local_len\n        \n        S_node = T_node + lambda_reg * curv_term_node\n        \n        errors_node['T'].append(T_node - T_true)\n        errors_node['S'].append(S_node - S_true)\n\n        # --- Spline-based calculation ---\n        u = np.zeros(N)\n        u[1:] = np.cumsum(np.linalg.norm(nodes[1:] - nodes[:-1], axis=1))\n        \n        spline_x = CubicSpline(u, nodes[:, 0], bc_type='natural')\n        spline_z = CubicSpline(u, nodes[:, 1], bc_type='natural')\n\n        def spline_T_integrand(ui):\n            x, z = spline_x(ui), spline_z(ui)\n            dx, dz = spline_x(ui, 1), spline_z(ui, 1)\n            ds_du = np.sqrt(dx**2 + dz**2)\n            return slowness(x, z) * ds_du\n\n        def spline_S_curv_integrand(ui):\n            dx, dz = spline_x(ui, 1), spline_z(ui, 1)\n            ddx, ddz = spline_x(ui, 2), spline_z(ui, 2)\n            \n            num = dx * ddz - dz * ddx\n            den_sq = dx**2 + dz**2\n            \n            if den_sq  1e-12:\n                return 0.0\n            \n            return num**2 / den_sq**2.5\n\n        T_spline, _ = quad(spline_T_integrand, 0, u[-1], epsabs=1e-10, epsrel=1e-10)\n        curv_int_spline, _ = quad(spline_S_curv_integrand, 0, u[-1], epsabs=1e-10, epsrel=1e-10)\n        \n        S_spline = T_spline + lambda_reg * curv_int_spline\n        \n        errors_spline['T'].append(T_spline - T_true)\n        errors_spline['S'].append(S_spline - S_true)\n\n    # 3. Compute Pearson correlations\n    corr_node = np.corrcoef(errors_node['S'], errors_node['T'])[0, 1]\n    corr_spline = np.corrcoef(errors_spline['S'], errors_spline['T'])[0, 1]\n    \n    return corr_node, corr_spline\n\nsolve()\n```", "id": "3614363"}]}