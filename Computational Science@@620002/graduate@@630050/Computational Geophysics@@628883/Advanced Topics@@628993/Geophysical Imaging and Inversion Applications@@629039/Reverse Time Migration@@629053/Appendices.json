{"hands_on_practices": [{"introduction": "This first practice lays the groundwork for understanding Reverse Time Migration (RTM) by guiding you through the construction of a simple, yet complete, imaging workflow. You will implement a frequency-domain RTM using the Helmholtz equation and the single-scattering Born approximation, which form the basis for many wave-equation migration methods. This exercise [@problem_id:3613775] provides direct, hands-on experience with the fundamental steps of RTM: forward modeling the source wavefield, back-propagating the scattered data, and applying a cross-correlation imaging condition to form an image.", "problem": "Implement a frequency-domain Reverse Time Migration (RTM) imaging experiment for a two-dimensional constant-density acoustic medium using the single-frequency Helmholtz equation. Start from the constant-density acoustic wave equation and derive a frequency-domain formulation suitable for constructing a single-scatterer Born approximation. Use this to define a forward modeling operator for the background wavefield, a secondary source for the scattered field due to a localized perturbation in squared slowness, and an adjoint (back-propagation) operator for imaging by a correlation-type imaging condition.\n\nYour program must construct a computational grid, assemble the discrete Helmholtz operator with homogeneous Dirichlet boundary conditions and a small complex shift to emulate weak absorption, solve the forward and adjoint fields, compute the image for a single frequency, and then perform a multi-frequency stack to approximate the bandwidth and resolution of a time-domain image. The final output for each test case is a scalar metric that quantifies peak-to-sidelobe contrast at the known scatterer location.\n\nFoundational base and definitions:\n- The constant-density acoustic wave equation in physical space is given by\n$$\n\\frac{\\partial^2 p(\\mathbf{x},t)}{\\partial t^2} - v(\\mathbf{x})^2 \\nabla^2 p(\\mathbf{x},t) = s(\\mathbf{x},t),\n$$\nwhere $p$ is pressure, $v$ is wave speed in $\\mathrm{m/s}$, $\\nabla^2$ is the Laplacian, and $s$ is a source term.\n- Under a single-frequency time-harmonic ansatz $p(\\mathbf{x},t) = \\Re\\{u(\\mathbf{x},\\omega) e^{-i \\omega t}\\}$ with angular frequency $\\omega$ in $\\mathrm{rad/s}$, the field $u(\\mathbf{x},\\omega)$ satisfies the inhomogeneous Helmholtz equation\n$$\n\\left(\\nabla^2 + \\omega^2 m(\\mathbf{x})\\right) u(\\mathbf{x},\\omega) = q(\\mathbf{x},\\omega),\n$$\nwhere $m(\\mathbf{x}) = v(\\mathbf{x})^{-2}$ is squared slowness in $\\mathrm{s^2/m^2}$ and $q$ is the frequency-domain source.\n- For a small perturbation $\\delta m(\\mathbf{x})$ in squared slowness relative to a known background $m_0(\\mathbf{x})$, the first Born approximation yields the scattered field $u_s$ solving\n$$\n\\left(\\nabla^2 + \\omega^2 m_0(\\mathbf{x})\\right) u_s(\\mathbf{x},\\omega) = - \\omega^2 \\delta m(\\mathbf{x}) u_0(\\mathbf{x},\\omega),\n$$\nwhere $u_0$ is the background field solving\n$$\n\\left(\\nabla^2 + \\omega^2 m_0(\\mathbf{x})\\right) u_0(\\mathbf{x},\\omega) = q(\\mathbf{x},\\omega).\n$$\n\nDiscretization and numerical setup:\n- Work on a uniform Cartesian grid of size $N_x \\times N_z = 50 \\times 50$ with spacings $\\Delta x = \\Delta z = 10\\,\\mathrm{m}$. The computational domain has homogeneous Dirichlet boundary conditions (zero pressure on the boundary). To mimic weak absorption and reduce artificial reflections, use a complex shift in the mass term so that the discrete operator is\n$$\n\\mathbf{A}(\\omega) = \\mathbf{L} + \\omega^2 m_0 (1 - i \\eta)\\mathbf{I},\n$$\nwhere $\\mathbf{L}$ is the standard five-point discrete Laplacian with Dirichlet boundary treatment, $\\mathbf{I}$ is the identity, and $\\eta = 0.05$ is a dimensionless damping parameter.\n- Use a uniform background velocity $v_0 = 2000\\,\\mathrm{m/s}$, so that $m_0 = v_0^{-2}$ in $\\mathrm{s^2/m^2}$.\n- Place a single point source one grid cell below the surface at horizontal center. This is at index $(i_x,i_z) = (N_x/2, 1)$ using zero-based indexing in code. Model the source as a unit-amplitude Kronecker delta in the right-hand side $q$.\n- Place receivers along a horizontal line one grid cell below the surface at every grid column excluding the boundaries. That is, for $i_x \\in \\{1,2,\\dots,N_x-2\\}$ at $i_z = 1$.\n- Place a single localized squared-slowness perturbation at the domain center at index $(i_x,i_z) = (N_x/2, N_z/2)$ with amplitude\n$$\n\\delta m(\\mathbf{x}_\\star) = \\alpha m_0,\\quad \\alpha = 0.02,\n$$\nand zero elsewhere. This defines a single-scatterer Born model.\n\nForward modeling and imaging:\n- For a given frequency $f$ in $\\mathrm{Hz}$, compute $\\omega = 2\\pi f$. Solve for the background field $\\mathbf{u}_0$ from $\\mathbf{A}(\\omega)\\mathbf{u}_0 = \\mathbf{q}$.\n- Form the secondary source vector $\\mathbf{s}_\\mathrm{sc} = -\\omega^2\\,\\delta \\mathbf{m} \\odot \\mathbf{u}_0$, where $\\odot$ denotes pointwise multiplication and $\\delta \\mathbf{m}$ is the discretized perturbation field. Solve for the scattered field $\\mathbf{u}_s$ from $\\mathbf{A}(\\omega)\\mathbf{u}_s = \\mathbf{s}_\\mathrm{sc}$.\n- Extract the recorded data vector $\\mathbf{d}$ at receiver indices from $\\mathbf{u}_s$.\n- Back-propagate the data by solving $\\mathbf{A}(\\omega)\\boldsymbol{\\lambda} = \\mathbf{r}$, where $\\mathbf{r}$ is a vector of zeros with entries equal to the recorded data at the receiver locations (modeled as point injections).\n- Form the single-frequency image by the correlation-type imaging condition\n$$\n\\mathbf{I}_f = \\Re\\left\\{\\overline{\\mathbf{u}_0} \\odot \\boldsymbol{\\lambda}\\right\\}.\n$$\n\nMulti-frequency stacking:\n- For a list of frequencies $\\{f_k\\}$, compute $\\mathbf{I}_{f_k}$ for each $k$ and stack by simple summation\n$$\n\\mathbf{I}_\\mathrm{stack} = \\sum_k \\mathbf{I}_{f_k}.\n$$\n\nMetric for testable outputs:\n- Let $\\mathbf{x}_\\star$ denote the true scatterer grid index. Define the peak-to-sidelobe ratio at frequency $f$ as\n$$\nR(f) = \\frac{\\left|\\mathbf{I}_f(\\mathbf{x}_\\star)\\right|}{\\max_{\\mathbf{x} \\in \\Omega \\setminus \\mathcal{N}} \\left|\\mathbf{I}_f(\\mathbf{x})\\right| + \\varepsilon},\n$$\nwhere $\\Omega$ is the set of all grid points, $\\mathcal{N}$ is an exclusion neighborhood around $\\mathbf{x}_\\star$ of radius $r_\\mathrm{exc} = 3$ grid cells in the $\\ell_\\infty$ sense, and $\\varepsilon = 10^{-12}$ is a small stabilizer. For the multi-frequency stack, define $R_\\mathrm{stack}$ analogously by replacing $\\mathbf{I}_f$ with $\\mathbf{I}_\\mathrm{stack}$.\n\nUnits and numerical precision:\n- All physical inputs use the units stated above. The metric $R$ is dimensionless and must be reported as a floating-point number rounded to six digits after the decimal point.\n\nTest suite:\n- Use the following four test cases, each producing one scalar result:\n    - Case $1$ (single frequency): $f = 25\\,\\mathrm{Hz}$.\n    - Case $2$ (single frequency): $f = 35\\,\\mathrm{Hz}$.\n    - Case $3$ (multi-frequency stack): $f \\in \\{20\\,\\mathrm{Hz}, 25\\,\\mathrm{Hz}, 30\\,\\mathrm{Hz}, 35\\,\\mathrm{Hz}\\}$.\n    - Case $4$ (edge case, low frequency): $f = 10\\,\\mathrm{Hz}$.\n\nRequired final output format:\n- Your program should produce a single line of output containing the results for the four cases as a comma-separated list enclosed in square brackets, for example\n$[\\;r_1,r_2,r_3,r_4\\;]$,\nwhere $r_j$ are the four rounded floating-point metrics as specified above, with no additional text printed.", "solution": "We begin from the constant-density acoustic wave equation\n$$\n\\frac{\\partial^2 p(\\mathbf{x},t)}{\\partial t^2} - v(\\mathbf{x})^2 \\nabla^2 p(\\mathbf{x},t) = s(\\mathbf{x},t).\n$$\nFor time-harmonic fields at angular frequency $\\omega$ with the ansatz $p(\\mathbf{x},t) = \\Re\\{u(\\mathbf{x},\\omega) e^{-i \\omega t}\\}$, substitution yields\n$$\n(-\\omega^2) u(\\mathbf{x},\\omega) - v(\\mathbf{x})^2 \\nabla^2 u(\\mathbf{x},\\omega) = s_\\omega(\\mathbf{x}),\n$$\nor equivalently\n$$\n\\left(\\nabla^2 + \\omega^2 m(\\mathbf{x})\\right) u(\\mathbf{x},\\omega) = q(\\mathbf{x},\\omega),\n$$\nwith $m(\\mathbf{x}) = v(\\mathbf{x})^{-2}$ and $q(\\mathbf{x},\\omega) = v(\\mathbf{x})^{-2} s_\\omega(\\mathbf{x})$. In a medium expressed as a background plus a small perturbation, $m(\\mathbf{x}) = m_0(\\mathbf{x}) + \\delta m(\\mathbf{x})$ with $\\|\\delta m\\| \\ll \\|m_0\\|$, the background field $u_0$ and scattered field $u_s$ satisfy the pair of equations\n$$\n\\left(\\nabla^2 + \\omega^2 m_0\\right) u_0 = q,\\qquad\n\\left(\\nabla^2 + \\omega^2 m_0\\right) u_s = -\\omega^2 \\delta m\\, u_0,\n$$\nwhich is the first Born approximation. The right-hand side of the scattered equation plays the role of an equivalent source resulting from the perturbation interacting with the background field.\n\nFor Reverse Time Migration (RTM), one uses the adjoint of the modeling operator to back-propagate recorded data to the image space. In the frequency domain with real background $m_0$ and homogeneous boundary conditions, the Helmholtz operator is self-adjoint apart from boundary radiation conditions. Numerically, to mitigate spurious reflections from truncated domains, we add a small complex shift to emulate absorption, forming an operator\n$$\n\\mathbf{A}(\\omega) = \\mathbf{L} + \\omega^2 m_0 (1 - i \\eta)\\mathbf{I},\n$$\nwhere $\\mathbf{L}$ is the five-point discrete Laplacian, $\\mathbf{I}$ is the identity, and $\\eta > 0$ is small. This preserves a consistent adjoint action in the discrete setting. We discretize on a regular $N_x \\times N_z$ grid with spacings $\\Delta x$ and $\\Delta z$, and enforce homogeneous Dirichlet boundary conditions by replacing rows corresponding to boundary nodes with identity rows, which sets the boundary field to zero.\n\nGiven a single source at one grid cell below the surface and receivers along a shallow horizontal line, we proceed as follows for a given frequency $f$ with $\\omega = 2\\pi f$:\n1. Assemble $\\mathbf{A}(\\omega)$ from $\\mathbf{L}$ and the complex-shifted mass term $\\omega^2 m_0 (1 - i \\eta)$. The five-point Laplacian with Dirichlet boundaries uses the stencil\n$$\n\\left(\\mathbf{L} u\\right)_{i,j} = \\frac{u_{i+1,j} - 2 u_{i,j} + u_{i-1,j}}{\\Delta x^2} + \\frac{u_{i,j+1} - 2 u_{i,j} + u_{i,j-1}}{\\Delta z^2},\n$$\napplied only to interior nodes; boundary values are set to zero via identity rows.\n2. Solve for the background field $\\mathbf{A}(\\omega)\\mathbf{u}_0 = \\mathbf{q}$, with $\\mathbf{q}$ a unit-amplitude discrete delta at the source grid index.\n3. Construct the discrete Born source $\\mathbf{s}_\\mathrm{sc} = -\\omega^2 \\delta \\mathbf{m} \\odot \\mathbf{u}_0$ and solve $\\mathbf{A}(\\omega)\\mathbf{u}_s = \\mathbf{s}_\\mathrm{sc}$.\n4. Extract the data vector $\\mathbf{d}$ by sampling $\\mathbf{u}_s$ at the receiver locations.\n5. Back-propagate by injecting the recorded data at receiver positions: form $\\mathbf{r}$ which is zero everywhere except equals $\\mathbf{d}$ at receiver indices, and solve $\\mathbf{A}(\\omega)\\boldsymbol{\\lambda} = \\mathbf{r}$.\n6. Apply the correlation-type imaging condition\n$$\n\\mathbf{I}_f = \\Re\\{\\overline{\\mathbf{u}_0} \\odot \\boldsymbol{\\lambda}\\}.\n$$\n\nTo approximate the broadband character of time-domain imaging, perform multi-frequency stacking over a set of frequencies $\\{f_k\\}$ by summing the single-frequency images,\n$$\n\\mathbf{I}_\\mathrm{stack} = \\sum_k \\mathbf{I}_{f_k}.\n$$\nThis stacking reduces frequency-dependent sidelobes and improves resolution by constructive interference at the true scatterer location and partial cancellation elsewhere.\n\nFor quantitative assessment, we compute the peak-to-sidelobe ratio\n$$\nR(f) = \\frac{\\left|\\mathbf{I}_f(\\mathbf{x}_\\star)\\right|}{\\max_{\\mathbf{x}\\in \\Omega \\setminus \\mathcal{N}} \\left|\\mathbf{I}_f(\\mathbf{x})\\right| + \\varepsilon},\n$$\nwith an exclusion neighborhood $\\mathcal{N}$ of radius $r_\\mathrm{exc} = 3$ grid cells around the true location $\\mathbf{x}_\\star$, and a stabilizer $\\varepsilon = 10^{-12}$. The same formula defines $R_\\mathrm{stack}$ when $\\mathbf{I}_f$ is replaced by $\\mathbf{I}_\\mathrm{stack}$.\n\nAlgorithmic design choices and numerical considerations:\n- The homogeneous Dirichlet boundary condition and complex shift $\\eta = 0.05$ reduce non-physical boundary reflections while keeping the solver simple and robust. The grid spacing $\\Delta x = \\Delta z = 10\\,\\mathrm{m}$ and frequencies up to $f = 35\\,\\mathrm{Hz}$ yield at least several grid points per wavelength for $v_0 = 2000\\,\\mathrm{m/s}$, ensuring a reasonable discretization of the Helmholtz operator.\n- The Born perturbation amplitude $\\alpha = 0.02$ is small enough to be consistent with linearization while producing a measurable scattered signal.\n- The back-propagation right-hand side $\\mathbf{r}$ directly inserts the recorded pressure at receiver positions; because the operator is complex symmetric with a small absorption, this emulates the adjoint action needed for RTM.\n- The image is taken as the real part of the correlation $\\overline{\\mathbf{u}_0} \\odot \\boldsymbol{\\lambda}$ to remove phase ambiguity, consistent with conventional single-frequency imaging conditions.\n\nTest suite interpretation:\n- Case $1$ ($f = 25\\,\\mathrm{Hz}$) provides a mid-band single-frequency image with moderate resolution and contrast.\n- Case $2$ ($f = 35\\,\\mathrm{Hz}$) increases resolution; we expect an increased peak-to-sidelobe ratio due to shorter wavelength and better focusing.\n- Case $3$ (stack over $f \\in \\{20,25,30,35\\}\\,\\mathrm{Hz}$) approximates a broader bandwidth; we expect constructive summation at the true location with partial sidelobe cancellation, improving the ratio relative to most single-frequency cases.\n- Case $4$ ($f = 10\\,\\mathrm{Hz}$) represents a low-frequency, long-wavelength regime; we expect poorer resolution and thus a lower ratio.\n\nThe final program assembles the operator, computes the fields and images for the specified cases, evaluates the metric $R$, rounds each to six decimal places, and prints a single line in the required list format.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import csr_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef build_helmholtz_operator(nx, nz, dx, dz, m0, omega, eta):\n    \"\"\"\n    Build 2D Helmholtz operator with homogeneous Dirichlet boundary conditions\n    and a small complex shift (1 - i*eta) on the mass term.\n    \"\"\"\n    n = nx * nz\n    rows = []\n    cols = []\n    data = []\n    k2 = (omega ** 2) * m0 * (1.0 - 1j * eta)\n\n    inv_dx2 = 1.0 / (dx * dx)\n    inv_dz2 = 1.0 / (dz * dz)\n\n    def idx(ix, iz):\n        return iz * nx + ix\n\n    for iz in range(nz):\n        for ix in range(nx):\n            p = idx(ix, iz)\n            # Boundary nodes: enforce u = 0 by identity row\n            if ix == 0 or ix == nx - 1 or iz == 0 or iz == nz - 1:\n                rows.append(p); cols.append(p); data.append(1.0 + 0j)\n            else:\n                # Center\n                diag = -2.0 * inv_dx2 - 2.0 * inv_dz2 + k2\n                rows.append(p); cols.append(p); data.append(diag)\n                # Left neighbor\n                rows.append(p); cols.append(idx(ix - 1, iz)); data.append(inv_dx2)\n                # Right neighbor\n                rows.append(p); cols.append(idx(ix + 1, iz)); data.append(inv_dx2)\n                # Up neighbor\n                rows.append(p); cols.append(idx(ix, iz - 1)); data.append(inv_dz2)\n                # Down neighbor\n                rows.append(p); cols.append(idx(ix, iz + 1)); data.append(inv_dz2)\n\n    A = csr_matrix((np.array(data, dtype=np.complex128),\n                    (np.array(rows, dtype=np.int32), np.array(cols, dtype=np.int32))),\n                   shape=(n, n))\n    return A\n\ndef solve_field(A, rhs):\n    return spsolve(A, rhs)\n\ndef rtm_single_frequency(f_hz, nx, nz, dx, dz, v0, eta, alpha, src_ix, src_iz, rec_iz, scat_ix, scat_iz):\n    \"\"\"\n    Compute single-frequency RTM image and return the peak-to-sidelobe ratio at the true scatterer.\n    \"\"\"\n    omega = 2.0 * np.pi * f_hz\n    m0 = 1.0 / (v0 * v0)\n\n    # Build operator\n    A = build_helmholtz_operator(nx, nz, dx, dz, m0, omega, eta)\n\n    n = nx * nz\n    def lin(ix, iz):\n        return iz * nx + ix\n\n    # Source RHS\n    q = np.zeros(n, dtype=np.complex128)\n    q[lin(src_ix, src_iz)] = 1.0 + 0j\n\n    # Background field\n    u0 = solve_field(A, q)\n\n    # Born perturbation\n    dm = np.zeros(n, dtype=np.complex128)\n    dm[lin(scat_ix, scat_iz)] = alpha * m0\n\n    # Scattered field RHS\n    s_sc = - (omega ** 2) * dm * u0\n    us = solve_field(A, s_sc)\n\n    # Receivers along a horizontal line rec_iz at all interior ix\n    rec_ixs = list(range(1, nx - 1))\n    rec_ids = [lin(ix, rec_iz) for ix in rec_ixs]\n    d = us[rec_ids].copy()\n\n    # Back-propagation RHS: inject recorded data at receivers\n    r = np.zeros(n, dtype=np.complex128)\n    r[rec_ids] = d\n\n    lamb = solve_field(A, r)\n\n    # Imaging condition\n    I = np.real(np.conj(u0) * lamb)\n\n    # Peak-to-sidelobe ratio at true scatterer\n    I2d = I.reshape(nz, nx)\n    peak_val = abs(I2d[scat_iz, scat_ix])\n\n    # Exclude a neighborhood around the true location\n    r_exc = 3\n    mask = np.ones((nz, nx), dtype=bool)\n    i0 = max(0, scat_iz - r_exc)\n    i1 = min(nz, scat_iz + r_exc + 1)\n    j0 = max(0, scat_ix - r_exc)\n    j1 = min(nx, scat_ix + r_exc + 1)\n    mask[i0:i1, j0:j1] = False\n\n    side_max = np.max(np.abs(I2d[mask])) if np.any(mask) else 0.0\n    eps = 1e-12\n    ratio = peak_val / (side_max + eps)\n    return ratio, I2d\n\ndef rtm_stack_frequencies(f_list, nx, nz, dx, dz, v0, eta, alpha, src_ix, src_iz, rec_iz, scat_ix, scat_iz):\n    \"\"\"\n    Compute multi-frequency stacked RTM image and return the peak-to-sidelobe ratio at the true scatterer.\n    \"\"\"\n    I_stack = np.zeros((nz, nx), dtype=np.float64)\n    for f in f_list:\n        ratio, I2d = rtm_single_frequency(f, nx, nz, dx, dz, v0, eta, alpha,\n                                          src_ix, src_iz, rec_iz, scat_ix, scat_iz)\n        I_stack += I2d\n\n    peak_val = abs(I_stack[scat_iz, scat_ix])\n    r_exc = 3\n    mask = np.ones_like(I_stack, dtype=bool)\n    i0 = max(0, scat_iz - r_exc)\n    i1 = min(nz, scat_iz + r_exc + 1)\n    j0 = max(0, scat_ix - r_exc)\n    j1 = min(nx, scat_ix + r_exc + 1)\n    mask[i0:i1, j0:j1] = False\n\n    side_max = np.max(np.abs(I_stack[mask])) if np.any(mask) else 0.0\n    eps = 1e-12\n    ratio = peak_val / (side_max + eps)\n    return ratio\n\ndef solve():\n    # Grid and physical parameters\n    nx, nz = 50, 50\n    dx = dz = 10.0  # meters\n    v0 = 2000.0     # m/s\n    eta = 0.05      # dimensionless damping\n    alpha = 0.02    # relative perturbation in m0\n\n    # Geometry\n    src_ix = nx // 2\n    src_iz = 1\n    rec_iz = 1\n    scat_ix = nx // 2\n    scat_iz = nz // 2\n\n    # Test cases:\n    # 1: single frequency 25 Hz\n    # 2: single frequency 35 Hz\n    # 3: stack frequencies [20, 25, 30, 35] Hz\n    # 4: single frequency 10 Hz (low-frequency edge case)\n    test_cases = [\n        (\"single\", 25.0),\n        (\"single\", 35.0),\n        (\"stack\", [20.0, 25.0, 30.0, 35.0]),\n        (\"single\", 10.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        mode, val = case\n        if mode == \"single\":\n            ratio, _ = rtm_single_frequency(val, nx, nz, dx, dz, v0, eta, alpha,\n                                            src_ix, src_iz, rec_iz, scat_ix, scat_iz)\n            results.append(f\"{ratio:.6f}\")\n        elif mode == \"stack\":\n            ratio = rtm_stack_frequencies(val, nx, nz, dx, dz, v0, eta, alpha,\n                                          src_ix, src_iz, rec_iz, scat_ix, scat_iz)\n            results.append(f\"{ratio:.6f}\")\n        else:\n            # Should not occur\n            results.append(f\"{0.0:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3613775"}, {"introduction": "Building upon the basic imaging concept, this practice explores the challenge of imaging in realistic media where energy is lost due to intrinsic attenuation. You will investigate how viscoacoustic effects distort wavefield amplitude and phase, and compare the standard cross-correlation imaging condition with a deconvolution-based approach designed to compensate for these distortions. This quantitative comparison [@problem_id:3613786] demonstrates the critical difference between kinematic imaging (getting reflectors in the right place) and true-amplitude imaging (recovering correct reflectivity), a key step toward more quantitative seismic interpretation.", "problem": "You are asked to construct a quantitative comparison between two zero-lag imaging conditions used in Reverse Time Migration (RTM): the cross-correlation imaging condition and the deconvolution imaging condition, in a one-dimensional viscoacoustic medium with spatially varying attenuation. Your goal is to derive from first principles a reproducible algorithm that synthesizes data in a physically plausible way, implements both imaging conditions, aligns the reflection event in phase, and then quantifies amplitude and phase fidelity of the two imaging conditions as explicit functions of the inverse quality factor and the dominant frequency.\n\nStarting point and physical assumptions. Begin from the linearized acoustic wave equation with dissipation, and model the viscoacoustic loss using a constant quality factor (quality factor $Q$ is dimensionless) in the small-attenuation sense. Use a homogeneous background wave speed $v$ in $\\mathrm{m/s}$ and a two-layer attenuation model with spatially varying quality factors $Q_1$ and $Q_2$. Assume a single horizontal reflector at depth $z_r$ in $\\mathrm{m}$ with a real scalar reflectivity $r$, and a planar source-receiver configuration at the surface. The total two-way travel time is $t_0 = 2 z_r / v$. The source signature is a compactly supported Ricker wavelet with dominant frequency $f_0$ in $\\mathrm{Hz}$ and unit peak amplitude.\n\nViscoacoustic propagation model. Within the small-loss approximation for a constant-$Q$ medium, the plane-wave spectral amplitude decays exponentially with the product of angular frequency and an effective attenuation time, and causality implies a first-order dispersive phase correction that varies logarithmically with frequency. For a two-layer attenuation model where the first layer extends from $z=0$ to $z=z_{\\mathrm{int}}$ with quality factor $Q_1$ and the second extends from $z=z_{\\mathrm{int}}$ to $z=z_r$ with quality factor $Q_2$, construct the two-way attenuation and dispersion operators by adding the contributions of the two one-way segments in each layer and doubling the result for the round trip. Anchor the dispersive correction at a reference frequency equal to the dominant frequency $f_{\\mathrm{ref}} = f_0$ to avoid arbitrary absolute phase, and regularize the logarithm at very low frequency by clamping $|f|$ from below by a small fraction of $f_0$ to avoid the singularity at $f=0$. You must clearly justify the forms you implement based on linearization, plane-wave asymptotics, and the Kramers–Kronig causality relation.\n\nData synthesis. Generate the source wavelet in the time domain over a uniform sampling grid of duration $T$ and sampling interval $\\Delta t$ (use $T$ and $\\Delta t$ values that realistically capture a two-way time of order $t_0$ without time wraparound; specify your choices). Transform the wavelet into the frequency domain. Construct the frequency-domain data by multiplying the source spectrum by the two-way viscoacoustic propagation operator for the two-layer model and by the scalar reflectivity $r$. Ensure that your implementation is symmetric with respect to positive and negative frequencies so that the inverse transform yields a real-valued time series.\n\nImaging conditions. Implement two estimators of the reflectivity at the reflector location from the synthesized single-trace data and the known source spectrum:\n- Cross-correlation imaging condition: treat it as a matched-filter estimator in the frequency domain and normalize by the source energy to make the estimate dimensionless. Before spectral summation, align the reflection event in phase by removing the known non-dispersive two-way phase term corresponding to the propagation delay $t_0$ (the demodulation factor must use angles in radians).\n- Deconvolution imaging condition: treat it as a stabilized spectral division of the data by the source, averaged across the band. Implement a Tikhonov-type stabilization to avoid instability near spectral zeros of the source. Use the same demodulation of the non-dispersive phase as in cross-correlation, and explicitly include a well-posed normalization so the deconvolution estimate is also dimensionless.\n\nFidelity metrics. For each imaging condition, define two fidelity metrics:\n- Amplitude fidelity, defined as the ratio of the estimated reflectivity amplitude to the true reflectivity amplitude $r$, i.e., $| \\hat{r} | / r$ (dimensionless).\n- Phase error, defined as the principal value of the complex argument of the estimated reflectivity $\\arg(\\hat{r})$ in radians (angles must be in radians).\n\nYour program must implement the above steps and compute these two metrics for a set of test cases that explore variations in the inverse quality factor and the dominant frequency. Use the following fixed physical parameters for all cases: background speed $v = 2000$ in $\\mathrm{m/s}$, reflector depth $z_r = 1000$ in $\\mathrm{m}$, interface depth $z_{\\mathrm{int}} = 400$ in $\\mathrm{m}$, and reflectivity $r = 0.2$ (dimensionless). Use a total record length of $T = 8.192$ in $\\mathrm{s}$ and time sampling interval $\\Delta t = 0.001$ in $\\mathrm{s}$ for your discrete Fourier transforms.\n\nDefine the following test suite, each case specified by $(Q_1, Q_2, f_0)$:\n- Case $1$ (happy path, moderate loss): $(Q_1, Q_2, f_0) = (200, 100, 20)$.\n- Case $2$ (near lossless baseline): $(Q_1, Q_2, f_0) = (1000, 1000, 20)$.\n- Case $3$ (strong loss, higher band): $(Q_1, Q_2, f_0) = (40, 25, 30)$.\n- Case $4$ (moderate loss, low band edge): $(Q_1, Q_2, f_0) = (200, 100, 5)$.\n- Case $5$ (moderate loss, higher band edge): $(Q_1, Q_2, f_0) = (200, 100, 40)$.\n\nFor numerical stability in the deconvolution imaging condition, implement a stabilization parameter $\\epsilon$ defined as a small fraction of the peak source spectral energy, specifically $\\epsilon = 10^{-6} \\max_{\\omega} |S(\\omega)|^2$, where $S(\\omega)$ is the source spectrum and $\\omega$ is the angular frequency in $\\mathrm{rad/s}$. For the dispersive phase regularization, clamp $|f|$ below by $0.1 f_0$ inside any logarithm, where $f$ is the temporal frequency in $\\mathrm{Hz}$.\n\nRequired final output format. Your program should produce a single line of output containing the fidelity metrics for all cases as a single flat list of floating-point numbers, rounded to six decimal places, in the following order for each case: amplitude fidelity for cross-correlation, amplitude fidelity for deconvolution, phase error for cross-correlation (in radians), phase error for deconvolution (in radians). The overall output order must therefore be:\n$[\\mathrm{amp\\_cc}^{(1)}, \\mathrm{amp\\_dc}^{(1)}, \\mathrm{phi\\_cc}^{(1)}, \\mathrm{phi\\_dc}^{(1)}, \\ldots, \\mathrm{amp\\_cc}^{(5)}, \\mathrm{amp\\_dc}^{(5)}, \\mathrm{phi\\_cc}^{(5)}, \\mathrm{phi\\_dc}^{(5)}]$.\n\nAll distances must be in $\\mathrm{m}$, time in $\\mathrm{s}$, wave speed in $\\mathrm{m/s}$, and frequency in $\\mathrm{Hz}$. Angles must be in radians. The amplitude fidelity is dimensionless. The phase error must be expressed as a real number in radians (not degrees). The final output must be printed as a single line with a comma-separated list enclosed in square brackets, with no other text.", "solution": "The user requires a quantitative comparison of two zero-lag imaging conditions—cross-correlation and deconvolution—for Reverse Time Migration (RTM) in a one-dimensional, two-layer viscoacoustic medium. This involves deriving the theoretical framework from first principles, synthesizing the necessary seismic data, implementing the imaging conditions, and computing well-defined fidelity metrics. The solution will proceed by first establishing the physical model for wave propagation, then defining the data synthesis and imaging algorithms, and finally specifying the metrics for comparison.\n\n### 1. Viscoacoustic Wave Propagation Model\n\nWe begin with the linearized acoustic wave equation modified to include intrinsic attenuation. For a plane wave with angular frequency $\\omega$ propagating in a homogeneous medium with velocity $v$ and quality factor $Q$, the constant-$Q$ model is a standard and physically-grounded choice. Within the small-loss approximation ($Q \\gg 1$), the propagator describing the wave evolution over a distance $z$ can be derived from the Kramers-Kronig relations, which enforce causality. The propagator $G_{1way}$ for a one-way path is given in the frequency domain as the product of a non-dispersive travel time term, an attenuation term, and a dispersive phase term.\n\nThe complex wavenumber $k(\\omega)$ is approximated as:\n$$ k(\\omega) \\approx \\frac{\\omega}{v} - \\frac{i\\omega \\operatorname{sgn}(\\omega)}{2vQ} + \\frac{\\omega}{\\pi v Q} \\ln\\left|\\frac{\\omega}{\\omega_{\\text{ref}}}\\right| $$\nAssuming a time dependence of $e^{-i\\omega t}$, the propagator over a distance $z$ is $e^{ikz}$, which after substituting for $k(\\omega)$ and using $t(z) = z/v$ becomes:\n$$ G_{1way}(\\omega, z) = \\exp\\left(-\\frac{|\\omega| t(z)}{2Q}\\right) \\exp\\left(i\\frac{\\omega t(z)}{\\pi Q} \\ln\\left|\\frac{\\omega}{\\omega_{\\text{ref}}}\\right|\\right) \\exp\\left(i\\omega t(z)\\right) $$\nThe problem asks for a two-layer model with a reflector at depth $z_r$ and an interface at $z_{\\mathrm{int}}$. The wave travels down and back up, so the total two-way travel time in layer 1 (depth $0$ to $z_{\\mathrm{int}}$, quality factor $Q_1$) is $t_1 = 2z_{\\mathrm{int}}/v$, and in layer 2 (depth $z_{\\mathrm{int}}$ to $z_r$, quality factor $Q_2$) is $t_2 = 2(z_r - z_{\\mathrm{int}})/v$. The total non-dispersive two-way travel time is $t_0 = t_1 + t_2 = 2 z_r / v$.\n\nThe total two-way propagator $G(\\omega)$ is the product of the effects from each segment. We define an effective inverse Q-time, $\\tau_Q$, which consolidates the attenuation properties of the path:\n$$ \\tau_Q = \\frac{t_1}{Q_1} + \\frac{t_2}{Q_2} = \\frac{2z_{\\mathrm{int}}}{vQ_1} + \\frac{2(z_r-z_{\\mathrm{int}})}{vQ_2} $$\nThe full two-way propagator $G(\\omega)$ can then be expressed as:\n$$ G(\\omega) = G_{\\text{visco}}(\\omega) \\cdot e^{i\\omega t_0} $$\nHere, $e^{i\\omega t_0}$ is the non-dispersive phase shift corresponding to the travel time $t_0$. The term $G_{\\text{visco}}(\\omega)$ contains all attenuation and dispersion effects. The reference frequency is set to the source's dominant frequency, $f_{\\text{ref}} = f_0$ (or $\\omega_{\\text{ref}} = \\omega_0 = 2\\pi f_0$), to anchor the phase. To avoid the singularity at $\\omega=0$, the frequency in the logarithm is regularized.\n$$ G_{\\text{visco}}(\\omega) = \\exp\\left(-\\frac{|\\omega| \\tau_Q}{2}\\right) \\exp\\left(i\\frac{\\omega \\tau_Q}{\\pi} \\ln\\left(\\frac{\\max(|\\omega|, 0.1\\omega_0)}{\\omega_0}\\right)\\right) $$\nNote that the standard geophysical convention for $e^{-i\\omega t}$ leads to a complex phase term with a positive sign for dispersion. Following the forward model formulation and the problem description regarding phase correction, the analysis here uses a propagator that describes the impulse response, which requires a negative sign in the dispersive term to be consistent with time-domain causality as implemented by standard FFTs ($e^{-i\\omega t}$ forward transform).\n$$ G_{\\text{visco}}(\\omega) = \\underbrace{\\exp\\left(-\\frac{|\\omega|\\tau_Q}{2}\\right)}_{\\text{Attenuation}} \\cdot \\underbrace{\\exp\\left(-i\\frac{\\omega \\tau_Q}{\\pi} \\ln\\left(\\frac{\\max(|\\omega|, 0.1\\omega_0)}{\\omega_0}\\right)\\right)}_{\\text{Dispersion}} $$\nThis will be used for synthesizing the data.\n\n### 2. Data Synthesis\n\nThe source signature $s(t)$ is a Ricker wavelet with dominant frequency $f_0$ and unit peak amplitude, shifted by a time $t_s$ to be centered within the recording window:\n$$ s(t; f_0, t_s) = \\left[1 - 2\\left(\\pi f_0 (t-t_s)\\right)^2\\right] e^{-\\left(\\pi f_0 (t-t_s)\\right)^2} $$\nThe source spectrum $S(\\omega)$ is obtained by taking the Fast Fourier Transform (FFT) of the time-domain wavelet $s(t)$. The synthetic data $D(\\omega)$ recorded at the surface for a reflector with reflectivity $r$ is the product of the source spectrum and the two-way propagator:\n$$ D(\\omega) = r \\cdot G(\\omega) \\cdot S(\\omega) = r \\cdot G_{\\text{visco}}(\\omega) \\cdot e^{i\\omega t_0} \\cdot S(\\omega) $$\nTo ensure the inverse FFT yields a real-valued time series, the spectrum must exhibit Hermitian symmetry, i.e., $D(-\\omega) = D^*(\\omega)$, which is naturally satisfied by this construction if $S(\\omega)$ is from a real $s(t)$.\n\n### 3. Imaging Conditions\n\nThe goal is to obtain an estimate of the reflectivity, $\\hat{r}$, from the data $D(\\omega)$ and the source $S(\\omega)$. This is done at zero-lag, corresponding to the known reflector time $t_0$. The first step for both imaging conditions is to demodulate the data by removing the non-dispersive travel time phase, $e^{i\\omega t_0}$. (The problem states $e^{-i\\omega t_0}$ demodulation, which corresponds to correlation, but to recover the physical properties, we need to apply the inverse operator $e^{-i \\omega t_0}$ to $e^{+i\\omega t_0}$, so we multiply by $e^{-i\\omega t_0}$. As my derivation used $e^{+i\\omega t}$, I'll use phase conjugation, equivalent to a time reversal). Here, we align phases by multiplying with $e^{-i\\omega t_0}$:\n$$ D_{\\text{demod}}(\\omega) = D(\\omega) e^{-i\\omega t_0} = r \\cdot G_{\\text{visco}}(\\omega) \\cdot S(\\omega) $$\n\n**Cross-Correlation (CC) Imaging Condition:**\nThis condition is a matched filter. The estimate $\\hat{r}_{\\text{CC}}$ is obtained by correlating the demodulated data with the source spectrum and normalizing by the source energy to ensure a dimensionless result. In the frequency domain, this is:\n$$ \\hat{r}_{\\text{CC}} = \\frac{\\sum_{k} D_{\\text{demod}}(\\omega_k) S^*(\\omega_k)}{\\sum_{k} S(\\omega_k) S^*(\\omega_k)} = \\frac{\\sum_{k} r \\cdot G_{\\text{visco}}(\\omega_k) S(\\omega_k) S^*(\\omega_k)}{\\sum_{k} |S(\\omega_k)|^2} = r \\frac{\\sum_{k} |S(\\omega_k)|^2 G_{\\text{visco}}(\\omega_k)}{\\sum_{k} |S(\\omega_k)|^2} $$\nThis is a weighted average of the viscoacoustic propagator $G_{\\text{visco}}$, with the source power spectrum $|S(\\omega_k)|^2$ as the weight.\n\n**Deconvolution (DC) Imaging Condition:**\nThis condition attempts to invert for the source wavelet effect. A stabilized spectral division is used to avoid noise amplification at frequencies where the source energy is low. Using Tikhonov regularization, the estimated reflectivity $\\hat{r}_{\\text{DC}}$ is:\n$$ \\hat{r}_{\\text{DC}} = \\frac{\\sum_{k} \\frac{D_{\\text{demod}}(\\omega_k) S^*(\\omega_k)}{|S(\\omega_k)|^2 + \\epsilon}}{\\sum_{k} \\frac{S(\\omega_k) S^*(\\omega_k)}{|S(\\omega_k)|^2 + \\epsilon}} $$\nwhere $\\epsilon = 10^{-6} \\max_{\\omega} |S(\\omega)|^2$ is the stabilization parameter. Substituting the expression for $D_{\\text{demod}}(\\omega)$, we get:\n$$ \\hat{r}_{\\text{DC}} = r \\frac{\\sum_{k} \\frac{|S(\\omega_k)|^2}{|S(\\omega_k)|^2 + \\epsilon} G_{\\text{visco}}(\\omega_k)}{\\sum_{k} \\frac{|S(\\omega_k)|^2}{|S(\\omega_k)|^2 + \\epsilon}} $$\nThis is also a weighted average of $G_{\\text{visco}}$, but with weights that are approximately $1$ inside the source's passband and $0$ outside, providing a more direct estimate of the medium's response. The normalization ensures that if $G_{\\text{visco}}(\\omega) = 1$ (no attenuation or dispersion), then $\\hat{r}_{\\text{DC}} = r$.\n\n### 4. Fidelity Metrics\n\nTo quantify the performance of each imaging condition, we define two metrics:\n- **Amplitude Fidelity**: The ratio of the magnitude of the estimated reflectivity to the true reflectivity. It measures the accuracy of amplitude recovery.\n$$ \\text{Fidelity}_{\\text{amp}} = \\frac{|\\hat{r}|}{r} $$\n- **Phase Error**: The argument (phase angle) of the complex-valued estimated reflectivity. It measures the phase distortion introduced by the uncompensated viscoacoustic effects.\n$$ \\text{Error}_{\\text{phase}} = \\arg(\\hat{r}) \\quad [\\text{in radians}] $$\n\nThe algorithm will compute these four values ($\\text{Fidelity}_{\\text{amp, CC}}$, $\\text{Fidelity}_{\\text{amp, DC}}$, $\\text{Error}_{\\text{phase, CC}}$, $\\text{Error}_{\\text{phase, DC}}$) for each test case specified in the problem statement.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.fft import fft, ifft, fftfreq\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    \"\"\"\n    # Define the fixed physical and numerical parameters from the problem statement.\n    v = 2000.0  # m/s\n    z_r = 1000.0  # m\n    z_int = 400.0  # m\n    r_true = 0.2  # dimensionless reflectivity\n    T = 8.192  # s\n    dt = 0.001  # s\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (Q1, Q2, f0)\n        (200, 100, 20),  # Case 1: moderate loss\n        (1000, 1000, 20),# Case 2: near lossless baseline\n        (40, 25, 30),    # Case 3: strong loss, higher band\n        (200, 100, 5),   # Case 4: moderate loss, low band\n        (200, 100, 40),  # Case 5: moderate loss, higher band\n    ]\n\n    results = []\n\n    for case in test_cases:\n        Q1, Q2, f0 = case\n\n        # --- 1. Grid and Source Wavelet Setup ---\n        N = int(T / dt)\n        t = np.arange(N) * dt\n        freq = fftfreq(N, dt)\n        omega = 2 * np.pi * freq\n\n        # Generate Ricker wavelet in time domain with unit peak amplitude\n        # A time shift is used to center the wavelet away from t=0.\n        t_s = 0.5  # seconds, a fixed shift\n        x_arg = np.pi * f0 * (t - t_s)\n        source_t = (1.0 - 2.0 * x_arg**2) * np.exp(-x_arg**2)\n\n        # Transform source to frequency domain\n        source_w = fft(source_t)\n\n        # --- 2. Viscoacoustic Propagator Construction ---\n        # Travel times for the two-way path\n        t1 = 2.0 * z_int / v\n        t2 = 2.0 * (z_r - z_int) / v\n        t0 = t1 + t2 # Total two-way travel time\n\n        # Effective inverse Q-time\n        tau_Q = t1 / Q1 + t2 / Q2\n\n        # Angular frequencies for reference and regularization\n        w0 = 2.0 * np.pi * f0\n        w_reg = np.maximum(np.abs(omega), 0.1 * w0)\n\n        # Attenuation and dispersion operators\n        attenuation_op = np.exp(-np.abs(omega) * tau_Q / 2.0)\n        \n        # Consistent with exp(-iwt) Fourier convention, the causal dispersive phase term is exp(+i*phase)\n        # where phase is negative.\n        dispersion_op = np.exp(1j * (omega * tau_Q / np.pi) * np.log(w_reg / w0))\n\n        # Viscoacoustic part of the propagator (excluding travel time phase)\n        G_visco = attenuation_op * dispersion_op\n        \n        # --- 3. Data Synthesis ---\n        # The full propagator includes the non-dispersive travel time\n        # Using exp(-iwt) transform convention, propagator has exp(-iwt0) for a delay t0\n        full_propagator_w = G_visco * np.exp(-1j * omega * t0)\n        \n        # Synthesize data in frequency domain\n        data_w = r_true * full_propagator_w * source_w\n        \n        # --- 4. Imaging Conditions ---\n        # Demodulate data by removing the non-dispersive travel time phase\n        # This is multiplication by exp(+i*omega*t0)\n        data_demod_w = data_w * np.exp(1j * omega * t0)\n\n        # Cross-Correlation (CC) Imaging\n        # Numerator is the sum of D_demod * S*\n        # Denominator is the source energy (sum of S * S*)\n        num_cc = np.sum(data_demod_w * np.conj(source_w))\n        den_cc = np.sum(source_w * np.conj(source_w))\n        r_hat_cc = num_cc / den_cc\n\n        # Deconvolution (DC) Imaging\n        # Tikhonov regularization parameter\n        source_power = np.abs(source_w)**2\n        epsilon = 1e-6 * np.max(source_power)\n\n        # Numerator is stabilized deconvolution of D_demod by S\n        # Denominator is the normalization factor\n        num_dc = np.sum(data_demod_w * np.conj(source_w) / (source_power + epsilon))\n        den_dc = np.sum(source_power / (source_power + epsilon))\n        r_hat_dc = num_dc / den_dc\n        \n        # --- 5. Fidelity Metrics ---\n        # Amplitude fidelity: |r_hat| / r_true\n        amp_fidelity_cc = np.abs(r_hat_cc) / r_true\n        amp_fidelity_dc = np.abs(r_hat_dc) / r_true\n\n        # Phase error: arg(r_hat) in radians\n        phase_error_cc = np.angle(r_hat_cc)\n        phase_error_dc = np.angle(r_hat_dc)\n\n        # Append results for the current case, rounded to 6 decimal places\n        results.extend([\n            round(amp_fidelity_cc, 6),\n            round(amp_fidelity_dc, 6),\n            round(phase_error_cc, 6),\n            round(phase_error_dc, 6)\n        ])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3613786"}, {"introduction": "A standard RTM image represents the sum of all scattering angles at each location; this final practice shows how to decompose this image to reveal richer diagnostic information. You will construct angle-domain common image gathers (ADCIGs) by estimating local propagation directions from the source and receiver wavefields' phase gradients. This powerful technique [@problem_id:3613787] is not just a theoretical curiosity; it is a cornerstone of modern seismic processing for velocity model validation and for enabling pre-stack analyses like amplitude versus angle (AVA).", "problem": "Consider Reverse Time Migration (RTM) angle-domain common image gathers constructed from local plane-wave estimates. Assume a two-dimensional spatial grid with coordinates $x$ and $z$, and complex time-harmonic snapshots of the source wavefield $u_s(x,z)$ and receiver wavefield $u_r(x,z)$. The objective is to compute local wavenumber vectors and construct angle-domain energy gathers, then validate focusing for known incident configurations.\n\nFundamental base to use:\n- Acoustic wave propagation is described by the acoustic wave equation, which in the time-harmonic regime reduces to the Helmholtz equation. It admits plane-wave solutions for which the spatial phase gradient equals the local wavenumber vector.\n- The zero-lag cross-correlation imaging condition in Reverse Time Migration (RTM) relates reflectivity to the correlation of source and receiver wavefields.\n- Angle-domain common image gathers (ADCIG) are constructed by mapping local wavenumber pairs to scattering angles, which quantify the angle between the source and receiver local propagation directions.\n\nTasks:\n1. Given complex fields $u_s(x,z)$ and $u_r(x,z)$ defined on a uniform grid with $N_x$ samples along $x$ and $N_z$ samples along $z$, and spacings $\\Delta x$ and $\\Delta z$ (in meters), estimate the local wavenumber vectors $\\mathbf{k}_s(x,z)$ and $\\mathbf{k}_r(x,z)$ using the phase-gradient principle that relates the imaginary part of $\\nabla u / u$ to the phase gradient. Use central finite differences to approximate spatial gradients with step sizes $\\Delta x$ and $\\Delta z$.\n2. For each grid location where both $\\|\\mathbf{k}_s(x,z)\\|$ and $\\|\\mathbf{k}_r(x,z)\\|$ exceed a small threshold (to avoid division by near-zero values), map the pair $\\big(\\mathbf{k}_s(x,z), \\mathbf{k}_r(x,z)\\big)$ to an angle of scattering $\\theta(x,z)$ in radians in $[0,\\pi]$, defined as the angle between the two local wavenumber vectors. Construct an angle-domain energy histogram $E(\\theta)$ by accumulating a nonnegative weight $w(x,z)$ at the corresponding angle bin. Use $w(x,z) = |u_s(x,z)|\\,|u_r(x,z)|$ as the weight. The histogram must have $N_\\theta$ bins spanning $[0,\\pi]$ uniformly.\n3. For each specified test case, compute a focusing metric $F$ as the ratio of energy in the bin containing the known true scattering angle $\\theta_{\\text{true}}$ to the total energy across all bins. If no valid samples contribute to the histogram, define $F$ to be $0.0$. Express $\\theta$ in radians for all computations. The final outputs are dimensionless floats.\n4. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3]\").\n\nGrid and units:\n- Use a Cartesian grid with $N_x$ and $N_z$ samples, spacings $\\Delta x$ and $\\Delta z$ in meters.\n- Angles must be treated and reported internally in radians.\n\nTest suite:\nFor each test case, construct $u_s(x,z)$ and $u_r(x,z)$ as complex plane waves with known wavenumber directions, except where specified otherwise. Let $k_0$ be the common magnitude of the wavenumber vectors in radians per meter. Define angles $\\alpha_s$ and $\\alpha_r$ (in radians) for $\\mathbf{k}_s$ and $\\mathbf{k}_r$ relative to the $x$-axis, so that $\\mathbf{k}_s = k_0[\\cos(\\alpha_s),\\sin(\\alpha_s)]$ and $\\mathbf{k}_r = k_0[\\cos(\\alpha_r),\\sin(\\alpha_r)]$. Construct the wavefields as $u_s(x,z) = \\exp\\big(i(\\mathbf{k}_s \\cdot \\mathbf{x})\\big)$ and $u_r(x,z) = \\exp\\big(i(\\mathbf{k}_r \\cdot \\mathbf{x})\\big)$, where $\\mathbf{x} = [x,z]$. For the edge case, set $u_r(x,z)$ to a spatially constant field with zero phase variation, which makes $\\mathbf{k}_r = \\mathbf{0}$ everywhere.\n\n- Test case $1$ (happy path): $N_x = 64$, $N_z = 64$, $\\Delta x = 10\\,\\text{m}$, $\\Delta z = 10\\,\\text{m}$, $k_0 = 0.2\\,\\text{rad/m}$, $\\alpha_s = 0.0\\,\\text{rad}$, $\\alpha_r = 0.0\\,\\text{rad}$, $N_\\theta = 180$. The true angle is $\\theta_{\\text{true}} = 0.0\\,\\text{rad}$.\n- Test case $2$ (oblique, general): $N_x = 64$, $N_z = 64$, $\\Delta x = 10\\,\\text{m}$, $\\Delta z = 10\\,\\text{m}$, $k_0 = 0.4\\,\\text{rad/m}$, $\\alpha_s = 0.3\\,\\text{rad}$, $\\alpha_r = 1.1\\,\\text{rad}$, $N_\\theta = 180$. The true angle is $\\theta_{\\text{true}} = |\\alpha_r - \\alpha_s|\\,\\text{rad}$.\n- Test case $3$ (near-opposite directions): $N_x = 64$, $N_z = 64$, $\\Delta x = 10\\,\\text{m}$, $\\Delta z = 10\\,\\text{m}$, $k_0 = 0.5\\,\\text{rad/m}$, $\\alpha_s = 0.0\\,\\text{rad}$, $\\alpha_r = \\pi\\,\\text{rad}$, $N_\\theta = 180$. The true angle is $\\theta_{\\text{true}} = \\pi\\,\\text{rad}$.\n- Test case $4$ (edge case with invalid receiver wavenumber): $N_x = 64$, $N_z = 64$, $\\Delta x = 10\\,\\text{m}$, $\\Delta z = 10\\,\\text{m}$, $k_0 = 0.3\\,\\text{rad/m}$, $\\alpha_s = 0.7\\,\\text{rad}$, and $u_r(x,z)$ is spatially constant with no phase variation (so $\\mathbf{k}_r = \\mathbf{0}$). Use $N_\\theta = 180$. The expected focusing metric is $F = 0.0$ because no valid angle can be formed.\n\nAlgorithmic specifics:\n- Use central differences to compute $\\partial u/\\partial x$ and $\\partial u/\\partial z$.\n- Estimate local wavenumbers by $\\mathbf{k}(x,z) \\approx \\operatorname{Im}\\left(\\frac{\\nabla u(x,z)}{u(x,z)}\\right)$ applied componentwise.\n- Define a small threshold $\\varepsilon = 10^{-8}$ (in radians per meter) and exclude any grid points where $\\|\\mathbf{k}_s(x,z)\\| < \\varepsilon$ or $\\|\\mathbf{k}_r(x,z)\\| < \\varepsilon$.\n- The histogram weight must be $w(x,z) = |u_s(x,z)|\\,|u_r(x,z)|$.\n- The final output must be a single line of the form \"[F1,F2,F3,F4]\" where each $Fj$ is a float.\n\nYour program should implement the above and output the focusing metrics in the specified format as a comma-separated list enclosed in square brackets on a single line.", "solution": "The problem is deemed valid as it is scientifically grounded in the principles of wave propagation and computational geophysics, is mathematically well-posed, and is defined with objective, unambiguous criteria. It presents a clear, formalizable task based on established concepts such as Reverse Time Migration (RTM), the Helmholtz equation, and the estimation of local wavenumbers from wavefield phase gradients. The provided test cases, including one exploring spatial aliasing and another an edge case, are well-designed to test a robust implementation of the specified algorithm.\n\nThe solution proceeds by implementing the prescribed sequence of operations. The core of the problem rests on three main principles: estimation of local wavenumbers, mapping to scattering angles, and construction of an angle-domain histogram to derive a focusing metric.\n\n**1. Estimation of Local Wavenumber Vectors**\n\nFor a monochromatic acoustic wavefield described by a complex function $u(\\mathbf{x}) = A(\\mathbf{x}) e^{i\\phi(\\mathbf{x})}$, where $A(\\mathbf{x})$ is the amplitude and $\\phi(\\mathbf{x})$ is the phase at position $\\mathbf{x} = [x, z]$, the local wavenumber vector $\\mathbf{k}(\\mathbf{x})$ is defined as the gradient of the phase:\n$$\n\\mathbf{k}(\\mathbf{x}) = \\nabla \\phi(\\mathbf{x})\n$$\nThe gradient of the complex field is $\\nabla u = (\\nabla A) e^{i\\phi} + A (i\\nabla\\phi) e^{i\\phi}$. Dividing by $u$ gives:\n$$\n\\frac{\\nabla u}{u} = \\frac{\\nabla A}{A} + i \\nabla \\phi = \\frac{\\nabla A}{A} + i\\mathbf{k}\n$$\nBy taking the imaginary part of this expression, we can isolate the local wavenumber vector:\n$$\n\\mathbf{k}(\\mathbf{x}) = \\operatorname{Im}\\left(\\frac{\\nabla u(\\mathbf{x})}{u(\\mathbf{x})}\\right)\n$$\nThis principle is applied to both the source wavefield, $u_s(x,z)$, and the receiver wavefield, $u_r(x,z)$, to obtain their respective local wavenumber vector fields, $\\mathbf{k}_s(x,z)$ and $\\mathbf{k}_r(x,z)$.\n\nNumerically, the spatial grid is discrete, with spacings $\\Delta x$ and $\\Delta z$. The gradient $\\nabla u = [\\frac{\\partial u}{\\partial x}, \\frac{\\partial u}{\\partial z}]$ is approximated using a second-order accurate central finite difference scheme. For an interior grid point $(x_i, z_j)$, the derivatives are:\n$$\n\\frac{\\partial u}{\\partial x}(x_i, z_j) \\approx \\frac{u(x_{i+1}, z_j) - u(x_{i-1}, z_j)}{2\\Delta x}\n$$\n$$\n\\frac{\\partial u}{\\partial z}(x_i, z_j) \\approx \\frac{u(x_i, z_{j+1}) - u(x_i, z_{j-1})}{2\\Delta z}\n$$\nThis computation is performed across the entire grid for both $u_s$ and $u_r$.\n\n**2. Mapping Wavenumbers to Scattering Angles**\n\nAt each grid point $(x,z)$, the pair of local wavenumber vectors $(\\mathbf{k}_s, \\mathbf{k}_r)$ represents the local propagation directions of the source and receiver wavefields. The scattering angle, $\\theta(x,z)$, is the angle between these two vectors. It is computed using the dot product formula:\n$$\n\\theta(x,z) = \\arccos\\left(\\frac{\\mathbf{k}_s(x,z) \\cdot \\mathbf{k}_r(x,z)}{\\|\\mathbf{k}_s(x,z)\\| \\|\\mathbf{k}_r(x,z)\\|}\\right)\n$$\nThe result of the $\\arccos$ function is naturally in the required range $[0, \\pi]$. This calculation is only performed at grid locations deemed valid, i.e., where the magnitudes of both wavenumber vectors exceed a small threshold $\\varepsilon = 10^{-8}$. This condition prevents numerical instability from division by zero, which would occur in regions of zero or constant phase where the wavenumber is null.\n\n**3. Histogram Construction and Focusing Metric**\n\nAn angle-domain common image gather (ADCIG) is constructed as a histogram, $E(\\theta)$, which accumulates energy as a function of the scattering angle. The range $[0, \\pi]$ is divided into $N_\\theta$ uniform bins. For each valid grid point $(x,z)$, the computed scattering angle $\\theta(x,z)$ determines the bin, and a weight $w(x,z)$ is added to that bin's accumulator. The problem specifies the weight as:\n$$\nw(x,z) = |u_s(x,z)|\\,|u_r(x,z)|\n$$\nAfter processing all valid grid points, the total energy in the histogram is $E_{\\text{total}} = \\sum_{j=1}^{N_\\theta} E(\\theta_j)$.\n\nThe focusing metric, $F$, quantifies how well the energy is concentrated at the theoretically known true scattering angle, $\\theta_{\\text{true}}$. It is defined as the ratio of the energy in the specific bin that contains $\\theta_{\\text{true}}$ to the total energy in the histogram:\n$$\nF = \\frac{E(\\text{bin containing } \\theta_{\\text{true}})}{E_{\\text{total}}}\n$$\nIf the histogram is empty because no valid grid points were found (as in Test Case 4), both the numerator and denominator are zero, and $F$ is defined to be $0.0$.\n\nFor the test cases involving plane waves on a grid with spacing that violates the Nyquist sampling theorem (i.e., $k_{max} > \\pi/\\Delta$), the finite difference approximation of the gradient introduces numerical dispersion. The estimated wavenumber, $k_{\\text{est}} = \\frac{\\sin(k_{\\text{true}}\\Delta x)}{\\Delta x}$, will differ from the true wavenumber, $k_{\\text{true}}$. This leads to estimated scattering angles that deviate from $\\theta_{\\text{true}}$, resulting in a lower focusing metric $F$, correctly reflecting the performance degradation of the algorithm under such conditions. The implementation must strictly follow the specified algorithm, including these numerical effects.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_focusing_metric(\n    Nx, Nz, dx, dz, us_func, ur_func, N_theta, theta_true, k_thresh\n):\n    \"\"\"\n    Computes the focusing metric for angle-domain common image gathers.\n    \n    Args:\n        Nx (int): Number of grid points in x.\n        Nz (int): Number of grid points in z.\n        dx (float): Grid spacing in x (meters).\n        dz (float): Grid spacing in z (meters).\n        us_func (callable): Function to generate source wavefield u_s(x, z).\n        ur_func (callable): Function to generate receiver wavefield u_r(x, z).\n        N_theta (int): Number of angle bins for the histogram.\n        theta_true (float): True scattering angle (radians).\n        k_thresh (float): Threshold for wavenumber magnitude.\n\n    Returns:\n        float: The focusing metric F.\n    \"\"\"\n    # 1. Create grid and wavefields\n    x = np.arange(Nx) * dx\n    z = np.arange(Nz) * dz\n    xx, zz = np.meshgrid(x, z)\n\n    u_s = us_func(xx, zz)\n    u_r = ur_func(xx, zz)\n\n    # 2. Estimate local wavenumbers using phase-gradient\n    # np.gradient returns gradients along each axis. For a 2D array (Nz, Nx),\n    # it returns (grad_z, grad_x). The spacings must be provided in the same order (dz, dx).\n    grad_s_z, grad_s_x = np.gradient(u_s, dz, dx, edge_order=2)\n    grad_r_z, grad_r_x = np.gradient(u_r, dz, dx, edge_order=2)\n    \n    # Add a small epsilon to the denominator to avoid division by zero\n    # in case u_s or u_r is zero somewhere, although not for the given test cases.\n    denom_s = u_s + 1e-12\n    denom_r = u_r + 1e-12\n\n    k_s_x = np.imag(grad_s_x / denom_s)\n    k_s_z = np.imag(grad_s_z / denom_s)\n    \n    k_r_x = np.imag(grad_r_x / denom_r)\n    k_r_z = np.imag(grad_r_z / denom_r)\n\n    # 3. Filter points based on wavenumber magnitude\n    k_s_norm = np.sqrt(k_s_x**2 + k_s_z**2)\n    k_r_norm = np.sqrt(k_r_x**2 + k_r_z**2)\n    \n    valid_mask = (k_s_norm >= k_thresh)  (k_r_norm >= k_thresh)\n    \n    if not np.any(valid_mask):\n        return 0.0\n\n    # 4. Map valid wavenumbers to scattering angles\n    k_s_x_valid = k_s_x[valid_mask]\n    k_s_z_valid = k_s_z[valid_mask]\n    k_r_x_valid = k_r_x[valid_mask]\n    k_r_z_valid = k_r_z[valid_mask]\n\n    k_s_norm_valid = k_s_norm[valid_mask]\n    k_r_norm_valid = k_r_norm[valid_mask]\n    \n    dot_product = k_s_x_valid * k_r_x_valid + k_s_z_valid * k_r_z_valid\n    \n    # Clip argument to arccos to handle potential floating point inaccuracies\n    cos_theta = np.clip(dot_product / (k_s_norm_valid * k_r_norm_valid), -1.0, 1.0)\n    angles = np.arccos(cos_theta)\n    \n    # 5. Construct angle-domain energy histogram\n    weights = np.abs(u_s[valid_mask]) * np.abs(u_r[valid_mask])\n    \n    bin_edges = np.linspace(0, np.pi, N_theta + 1)\n    hist_E, _ = np.histogram(angles, bins=bin_edges, weights=weights)\n\n    total_E = np.sum(hist_E)\n    \n    if total_E == 0:\n        return 0.0\n\n    # 6. Compute focusing metric F\n    bin_width = np.pi / N_theta\n    # Calculate the index of the bin containing the true angle\n    # Handle the edge case where theta_true = pi\n    true_bin_index = int(theta_true / bin_width)\n    if true_bin_index >= N_theta:\n        true_bin_index = N_theta - 1\n        \n    E_true = hist_E[true_bin_index]\n    \n    F = E_true / total_E\n    \n    return F\n\ndef solve():\n    \"\"\"\n    Main solver function that runs all test cases and prints the results.\n    \"\"\"\n    def make_plane_wave(k0, alpha):\n        kx = k0 * np.cos(alpha)\n        kz = k0 * np.sin(alpha)\n        return lambda x, z: np.exp(1j * (kx * x + kz * z))\n\n    def make_constant_field():\n        return lambda x, z: np.ones_like(x, dtype=np.complex128)\n\n    test_cases = [\n        # Case 1: Happy path\n        {'Nx': 64, 'Nz': 64, 'dx': 10.0, 'dz': 10.0, 'k0': 0.2, 'alpha_s': 0.0, 'alpha_r': 0.0, 'N_theta': 180},\n        # Case 2: Oblique, general\n        {'Nx': 64, 'Nz': 64, 'dx': 10.0, 'dz': 10.0, 'k0': 0.4, 'alpha_s': 0.3, 'alpha_r': 1.1, 'N_theta': 180},\n        # Case 3: Near-opposite directions\n        {'Nx': 64, 'Nz': 64, 'dx': 10.0, 'dz': 10.0, 'k0': 0.5, 'alpha_s': 0.0, 'alpha_r': np.pi, 'N_theta': 180},\n        # Case 4: Edge case with invalid receiver wavenumber\n        {'Nx': 64, 'Nz': 64, 'dx': 10.0, 'dz': 10.0, 'k0': 0.3, 'alpha_s': 0.7, 'N_theta': 180},\n    ]\n\n    results = []\n    k_thresh = 1e-8\n\n    for i, params in enumerate(test_cases):\n        if i == 3: # Test Case 4\n            us_func = make_plane_wave(params['k0'], params['alpha_s'])\n            ur_func = make_constant_field()\n            # As per problem, kr is zero, so no valid angle can be formed. \n            # The manual calculation is not strictly needed as the code handles it.\n            theta_true = 0.0 # dummy value, not used for F=0 case\n        else:\n            us_func = make_plane_wave(params['k0'], params['alpha_s'])\n            ur_func = make_plane_wave(params['k0'], params['alpha_r'])\n            theta_true = np.abs(params['alpha_r'] - params['alpha_s'])\n        \n        F = compute_focusing_metric(\n            params['Nx'], params['Nz'], params['dx'], params['dz'],\n            us_func, ur_func, params['N_theta'], theta_true, k_thresh\n        )\n        results.append(F)\n\n    # The problem asks for float results, not string formatted. The `map(str, ...)` is fine for printing.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3613787"}]}