{"hands_on_practices": [{"introduction": "This first practice is a crucial step in computational science: code verification. By implementing a first-order solver for the Eikonal equation and performing a grid-refinement study, you will empirically confirm the theoretical first-order accuracy of the numerical scheme. This exercise is fundamental for validating any numerical method and building confidence in your solver's correctness [@problem_id:3591153].", "problem": "Consider the two-dimensional Eikonal equation for first-arrival travel time in isotropic media, given by the partial differential equation\n$$\\lvert \\nabla T(\\mathbf{x}) \\rvert = s,$$\nwhere $T(\\mathbf{x})$ is the travel-time field in seconds, $\\mathbf{x} = (x,y)$ is position in meters, and $s$ is the constant slowness with units of seconds per meter. On the rectangular domain $[0,1]\\times[0,1]$ measured in meters, consider a point source at the center located at $(x_s,y_s) = (0.5,0.5)$ meters with boundary condition $T(x_s,y_s) = 0$ seconds. For constant $s$, the analytical solution in the continuum is\n$$T(x,y) = s \\sqrt{(x-x_s)^2 + (y-y_s)^2}.$$\n\nYour task is to set up a grid-refinement study using a first-order monotone upwind discretization of the Eikonal equation and to compute the empirical convergence slope in a log–log plot of the error norm $\\lVert T_h - T \\rVert$ versus the grid spacing $h$ for several slowness values. Here $T_h$ denotes the numerical solution computed on a uniform Cartesian grid with spacing $h$ and $T$ denotes the analytical solution. Use a solver appropriate for first-order schemes (e.g., a Fast Marching Method or a Fast Sweeping Method) that is consistent with the monotone upwind discretization and yields a causal solution.\n\nFundamental base and requirements:\n- Use the definition of travel time in isotropic media governed by the Eikonal equation $\\lvert \\nabla T \\rvert = s$ with constant $s$ and Dirichlet data $T(x_s,y_s)=0$.\n- Use the well-tested first-order Godunov upwind discretization on a uniform grid of spacing $h$ meters. At a grid node $(i,j)$ with discrete neighbor values, the local update for the discrete travel time $T_{i,j}$ must be obtained by solving the quadratic equation that enforces the discrete Eikonal condition using the smallest upwind neighbors in the coordinate directions. Explicitly, if $a$ is the minimum of the two neighbors in the $x$-direction and $b$ is the minimum of the two neighbors in the $y$-direction, then the update $U$ solves\n$$\\left(\\max\\left(\\frac{U-a}{h},0\\right)\\right)^2 + \\left(\\max\\left(\\frac{U-b}{h},0\\right)\\right)^2 = s^2,$$\nwith the admissibility condition $U \\ge \\max(a,b)$. This yields the closed-form update\n$$\nU =\n\\begin{cases}\n\\min(a,b) + h s, & \\text{if } \\lvert a-b \\rvert \\ge h s, \\\\\n\\dfrac{a+b + \\sqrt{2(h s)^2 - (a-b)^2}}{2}, & \\text{otherwise}.\n\\end{cases}\n$$\n- The numerical solution must be computed in seconds. The grid spacing must be in meters. The slowness must be in seconds per meter.\n- To isolate the asymptotic order away from the point-source singularity, compute error norms excluding a small disk of radius $2h$ around the source. That is, only include nodes whose Euclidean distance from $(x_s,y_s)$ is strictly greater than $2h$.\n\nError norms and convergence slope:\n- For a given grid spacing $h$, compute the discrete $L^2$ error\n$$\\lVert T_h - T \\rVert_{2,h} = \\sqrt{ h^2 \\sum_{i,j} \\left(T_{i,j} - T(x_i,y_j)\\right)^2 },$$\nand the discrete $L^\\infty$ error\n$$\\lVert T_h - T \\rVert_{\\infty,h} = \\max_{i,j} \\lvert T_{i,j} - T(x_i,y_j)\\rvert,$$\nwhere the sums and maxima are taken over the grid nodes outside the exclusion disk of radius $2h$ centered at $(x_s,y_s)$.\n- For a set of grid spacings $\\{h_k\\}$, fit a straight line to the data $\\left(\\log_{10} h_k, \\log_{10} \\lVert T_h - T \\rVert\\right)$ using least squares to obtain the empirical slope for each norm. A first-order scheme is expected to produce a slope close to $1$.\n\nTest suite and final output:\n- Use the following slowness values in seconds per meter: $s \\in \\{0.75, 1.5, 3.0\\}$.\n- For each $s$, use uniform grids with $N \\in \\{33, 65, 129, 257\\}$ nodes per dimension. The grid spacing is $h = 1/(N-1)$ meters.\n- For each $s$, compute the empirical slope for the $L^2$ error and the $L^\\infty$ error based on the four grid levels.\n- Your program should produce a single line of output containing the six results as a comma-separated list enclosed in square brackets, in the order\n$$[\\text{slope}_{L^2}(s{=}0.75), \\text{slope}_{L^\\infty}(s{=}0.75), \\text{slope}_{L^2}(s{=}1.5), \\text{slope}_{L^\\infty}(s{=}1.5), \\text{slope}_{L^2}(s{=}3.0), \\text{slope}_{L^\\infty}(s{=}3.0)].$$\nAll numbers must be printed as decimal numbers (no units in the output line), rounded by the program as it deems appropriate. Internally, ensure all travel times are in seconds, all distances in meters, and all slowness values in seconds per meter.", "solution": "The problem requires a grid-refinement study to determine the empirical order of convergence for a first-order numerical solution to the two-dimensional Eikonal equation. The problem is scientifically and mathematically well-posed, providing all necessary components: the governing partial differential equation, a specific case with an analytical solution, the numerical discretization scheme, the error metrics, and the parameters for the study.\n\nThe physical problem is to find the first-arrival travel time $T(\\mathbf{x})$ of a wave expanding from a point source in a medium with constant slowness $s$. This is governed by the Eikonal equation, $\\lvert \\nabla T(\\mathbf{x}) \\rvert = s$, on the domain $\\mathbf{x} = (x,y) \\in [0,1] \\times [0,1]$ meters. Given a point source at $(x_s, y_s) = (0.5, 0.5)$ m, where the travel time is defined to be zero, $T(x_s, y_s) = 0$ s, the analytical solution in the continuum is $T(x,y) = s \\sqrt{(x-x_s)^2 + (y-y_s)^2}$ seconds.\n\nTo solve this equation numerically, we employ the specified first-order Godunov upwind finite-difference scheme. This scheme discretizes the domain into a uniform Cartesian grid with spacing $h$ and approximates the Eikonal equation at each grid node $(i,j)$. The travel time $T_{i,j}$ is updated based on the travel times of its upwind neighbors, i.e., the neighbors from which the wavefront arrives. The problem provides the correct closed-form solution for the updated travel time $U$ at a node, derived from the quadratic equation that results from the discretized gradient operator:\n$$\nU =\n\\begin{cases}\n\\min(a,b) + h s, & \\text{if } \\lvert a-b \\rvert \\ge h s, \\\\\n\\dfrac{a+b + \\sqrt{2(h s)^2 - (a-b)^2}}{2}, & \\text{otherwise},\n\\end{cases}\n$$\nwhere $a$ and $b$ are the minimum travel times among neighbors in the $x$ and $y$ directions, respectively. This non-linear system of equations requires a specialized solver.\n\nThe Fast Marching Method (FMM) is the chosen algorithm to solve the discretized system. FMM is an efficient, single-pass algorithm that correctly captures the viscosity solution by propagating the wavefront in order of increasing travel time, analogous to Dijkstra's algorithm on a graph. The method operates by maintaining three sets of grid points: `KNOWN` (points whose final travel time has been computed), `TRIAL` (a narrow band of points adjacent to the known region, representing the current wavefront), and `FAR` (all other points). A min-priority queue manages the `TRIAL` points. The algorithm proceeds iteratively:\n1. Initialize the travel time grid with $\\infty$, except for the source point $T(x_s, y_s) = 0$. Add the source point to the priority queue.\n2. While the priority queue is not empty, extract the `TRIAL` point with the minimum travel time.\n3. Move this point from the `TRIAL` set to the `KNOWN` set.\n4. For each neighbor of this newly `KNOWN` point, calculate a potential new travel time using the Godunov update formula. If this new time is less than the neighbor's current time, update the neighbor's time and add it to (or update its priority in) the queue.\n\nFor the convergence study, this FMM solver is executed for each specified slowness $s \\in \\{0.75, 1.5, 3.0\\}$ s/m over a sequence of four grids with $N \\in \\{33, 65, 129, 257\\}$ nodes per side. The grid spacing is $h = 1/(N-1)$ m. After computing the numerical solution $T_h$ on each grid, we calculate the error by comparing it to the analytical solution $T$. The discrete $L^2$ and $L^\\infty$ error norms are computed as specified:\n$$ \\lVert T_h - T \\rVert_{2,h} = \\sqrt{ h^2 \\sum_{i,j} \\left(T_{i,j} - T(x_i,y_j)\\right)^2 }, \\quad \\lVert T_h - T \\rVert_{\\infty,h} = \\max_{i,j} \\lvert T_{i,j} - T(x_i,y_j)\\rvert. $$\nCrucially, the summation and maximum are taken only over grid points outside a disk of radius $2h$ centered at the source. This excludes the region around the point-source singularity, where the analytical solution is not differentiable and the numerical error does not follow the asymptotic behavior of the scheme, thus allowing for a clean measurement of the convergence rate.\n\nFinally, for each slowness $s$ and each error norm, the empirical order of convergence is determined by the slope of a best-fit line to the four data points $(\\log_{10} h_k, \\log_{10} \\text{error}_k)$ using a linear least-squares regression. For a first-order scheme, this slope is expected to be close to $1$. The implementation will compute these six slopes and format them as the final output.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport heapq\n\ndef solve():\n    \"\"\"\n    Main function to perform the grid-refinement study and compute convergence slopes.\n    \"\"\"\n    \n    def godunov_update(a, b, h, s):\n        \"\"\"\n        Computes the travel time update using the first-order Godunov scheme.\n        a: min travel time in x-direction\n        b: min travel time in y-direction\n        h: grid spacing\n        s: slowness\n        \"\"\"\n        hs = h * s\n        # This handles the case where one or both of a, b are np.inf\n        # abs(np.inf - finite) is np.inf, correctly triggering the 1D update\n        if np.abs(a - b) >= hs:\n            return min(a, b) + hs\n        else:\n            # This case requires both a and b to be finite\n            term_under_sqrt = 2 * (hs**2) - (a - b)**2\n            # A numerically robust check to prevent sqrt of small negative number\n            if term_under_sqrt < 0:\n                return min(a, b) + hs\n            return (a + b + np.sqrt(term_under_sqrt)) / 2\n\n    def run_fmm(N, h, s):\n        \"\"\"\n        Solves the Eikonal equation using the Fast Marching Method.\n        \"\"\"\n        # Constants for node states\n        KNOWN = 2\n        TRIAL = 1\n        FAR = 0\n        \n        T = np.full((N, N), np.inf, dtype=np.float64)\n        states = np.full((N, N), FAR, dtype=np.int8)\n        \n        # Source setup\n        source_idx = (N - 1) // 2\n        isrc, jsrc = source_idx, source_idx\n        T[isrc, jsrc] = 0.0\n        \n        trial_heap = [(0.0, isrc, jsrc)]\n        \n        while trial_heap:\n            t, i, j = heapq.heappop(trial_heap)\n            \n            if states[i, j] == KNOWN:\n                continue\n                \n            states[i, j] = KNOWN\n            \n            # Update neighbors\n            for ni, nj in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]:\n                if not (0 <= ni < N and 0 <= nj < N):\n                    continue\n                \n                if states[ni, nj] == KNOWN:\n                    continue\n\n                t_x1 = T[ni - 1, nj] if ni > 0 else np.inf\n                t_x2 = T[ni + 1, nj] if ni < N - 1 else np.inf\n                a = min(t_x1, t_x2)\n\n                t_y1 = T[ni, nj - 1] if nj > 0 else np.inf\n                t_y2 = T[ni, nj + 1] if nj < N - 1 else np.inf\n                b = min(t_y1, t_y2)\n                \n                if a == np.inf and b == np.inf:\n                    continue\n\n                U = godunov_update(a, b, h, s)\n\n                if U < T[ni, nj]:\n                    T[ni, nj] = U\n                    states[ni, nj] = TRIAL\n                    heapq.heappush(trial_heap, (U, ni, nj))\n                    \n        return T\n\n    def calculate_analytical(N, h, s, source_pos):\n        \"\"\"\n        Computes the analytical solution on the grid.\n        \"\"\"\n        grid_coords = np.linspace(0.0, 1.0, N)\n        xx, yy = np.meshgrid(grid_coords, grid_coords, indexing='ij')\n        xs, ys = source_pos\n        T_exact = s * np.sqrt((xx - xs)**2 + (yy - ys)**2)\n        return T_exact\n\n    def calculate_errors(T_h, T_exact, N, h, source_pos):\n        \"\"\"\n        Computes L2 and Linf errors, excluding a disk of radius 2h around the source.\n        \"\"\"\n        exclusion_radius = 2.0 * h\n        xs, ys = source_pos\n        \n        sum_sq_err = 0.0\n        max_abs_err = 0.0\n        \n        grid_coords = np.linspace(0.0, 1.0, N)\n        \n        for i in range(N):\n            for j in range(N):\n                xi, yj = grid_coords[i], grid_coords[j]\n                dist_from_source = np.sqrt((xi - xs)**2 + (yj - ys)**2)\n                \n                if dist_from_source > exclusion_radius:\n                    abs_err = np.abs(T_h[i, j] - T_exact[i, j])\n                    sum_sq_err += abs_err**2\n                    if abs_err > max_abs_err:\n                        max_abs_err = abs_err\n        \n        l2_err = np.sqrt(h**2 * sum_sq_err)\n        linf_err = max_abs_err\n        \n        return l2_err, linf_err\n\n    # --- Main Execution Logic ---\n    s_values = [0.75, 1.5, 3.0]\n    N_values = [33, 65, 129, 257]\n    source_pos = (0.5, 0.5)\n    \n    all_slopes = []\n\n    for s in s_values:\n        log_h_vals = []\n        log_l2_errors = []\n        log_linf_errors = []\n\n        for N in N_values:\n            h = 1.0 / (N - 1)\n            \n            T_h = run_fmm(N, h, s)\n            T_exact = calculate_analytical(N, h, s, source_pos)\n            \n            l2_err, linf_err = calculate_errors(T_h, T_exact, N, h, source_pos)\n            \n            if l2_err > 0 and linf_err > 0:\n                log_h_vals.append(np.log10(h))\n                log_l2_errors.append(np.log10(l2_err))\n                log_linf_errors.append(np.log10(linf_err))\n\n        # Perform linear regression to find the slope (order of convergence)\n        # using numpy.polyfit for least-squares\n        if len(log_h_vals) > 1:\n            slope_l2 = np.polyfit(log_h_vals, log_l2_errors, 1)[0]\n            slope_linf = np.polyfit(log_h_vals, log_linf_errors, 1)[0]\n            all_slopes.extend([slope_l2, slope_linf])\n        else:\n            # Handle case where not enough data points were collected\n            all_slopes.extend([np.nan, np.nan])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_slopes))}]\")\n\nsolve()\n```", "id": "3591153"}, {"introduction": "Real-world geophysical problems often involve boundaries where waves reflect, such as the Earth's surface or subsurface interfaces. This practice moves beyond simple domains to explore how to accurately model these phenomena [@problem_id:3591123]. You will enhance a Fast Sweeping Method solver by incorporating the method-of-images to handle a specularly reflecting boundary, and quantify the significant improvement in accuracy that this physically-motivated technique provides.", "problem": "You are tasked with designing and implementing a boundary-aware numerical solver for high-frequency travel times governed by the Eikonal equation in a homogeneous isotropic medium, and to quantify the impact of a reflecting boundary on numerical accuracy near that boundary via a source extension using an image method. The fundamental base consists of the Eikonal equation and Hamilton-Jacobi theory for travel time, the method-of-images for specular reflection in homogeneous media, and the Godunov upwind discretization for first-order nonlinear partial differential equations. The domain is a two-dimensional rectangular grid with a reflecting boundary at the bottom side. The solver must be based on the Fast Sweeping Method, and the comparison must be made against a standard point-source initialization without boundary-aware source extension.\n\nStart from the Eikonal equation\n$$\n\\lvert \\nabla T(x,y) \\rvert \\,=\\, s(x,y),\n$$\nwhere $T(x,y)$ is the first-arrival travel time and $s(x,y)$ is the slowness field, $s(x,y) = 1/v(x,y)$, with $v(x,y)$ the wave speed. Assume a homogeneous isotropic medium where $v(x,y) \\equiv v_0$ is a constant, so $s(x,y) \\equiv s_0 = 1/v_0$. The domain is discretized on a uniform grid with spacing $h$ in both directions, and the computational indices are $i \\in \\{0,\\dots,N_x-1\\}$ and $j \\in \\{0,\\dots,N_y-1\\}$ with physical coordinates $x_i = i h$ and $y_j = j h$. The bottom boundary at $y = 0$ reflects specularly (Neumann-type behavior for rays), and a point source located at $(x_s,y_s)$ in the interior initiates the travel time field with $T(x_s,y_s) = 0$.\n\nImplement two numerical variants:\n- Variant A (standard point source): initialize with $T_{i_s,j_s} = 0$ at the source grid node $(i_s,j_s)$, and perform Fast Sweeping updates using one-sided stencils at the domain boundaries (no special boundary-aware source extension).\n- Variant B (boundary-aware source extension): use the method-of-images to construct a boundary-aware ghost layer immediately outside the bottom boundary ($j=-1$) with values $T_0(i)$ obtained from the image source located at $(x_s,-y_s)$. Specifically, define the ghost values at $(x_i,y_{-1}) = (i h,-h)$ by\n$$\nT_0(i) \\,=\\, \\frac{1}{v_0}\\sqrt{(x_i - x_s)^2 + (y_{-1} - (-y_s))^2} \\,=\\, \\frac{1}{v_0}\\sqrt{(x_i - x_s)^2 + (y_s - h)^2}.\n$$\nThese $T_0(i)$ are not Dirichlet boundary conditions on $y=0$, but are to be used as boundary-aware ghost values in the upwind stencil for nodes at $j=0$ when computing Fast Sweeping updates.\n\nFor reference, given the homogeneous medium and a source at $(x_s,y_s)$ inside the domain, the analytic first-arrival travel time at the bottom boundary is given by\n$$\nT^{\\text{true}}(x,0) \\,=\\, \\frac{1}{v_0}\\sqrt{(x - x_s)^2 + y_s^2}.\n$$\n\nDesign and implement a two-dimensional Fast Sweeping Method using the Godunov upwind discretization appropriate for the Eikonal equation on a Cartesian grid, with the bottom ghost layer incorporated only in Variant B. Use a constant slowness $s_0 = 1/v_0$ and uniform spacing $h$ in both directions. Your implementation must compute the numerical travel time field $T_{i,j}$ for both Variant A and Variant B, and then evaluate the maximum absolute error along the bottom boundary $j=0$ by comparing $T_{i,0}$ with the analytic boundary value $T^{\\text{true}}(x_i,0)$.\n\nPhysical units must be used consistently: wave speed $v_0$ in meters per second (m/s), grid spacing $h$ in meters (m), and travel times $T$ in seconds (s). Errors must be reported in seconds (s), and improvement factors must be dimensionless ratios.\n\nTest Suite:\n- Case $1$ (happy path near boundary): $N_x = N_y = 101$, $h = 10$ m, $v_0 = 2000$ m/s, source $(x_s,y_s) = (500\\,\\text{m}, 10\\,\\text{m})$ corresponding to $(i_s,j_s) = (50,1)$.\n- Case $2$ (boundary-aligned source): $N_x = N_y = 101$, $h = 10$ m, $v_0 = 2000$ m/s, source $(x_s,y_s) = (500\\,\\text{m}, 0\\,\\text{m})$ corresponding to $(i_s,j_s) = (50,0)$.\n- Case $3$ (far from boundary): $N_x = N_y = 101$, $h = 10$ m, $v_0 = 2000$ m/s, source $(x_s,y_s) = (500\\,\\text{m}, 300\\,\\text{m})$ corresponding to $(i_s,j_s) = (50,30)$.\n- Case $4$ (corner proximity): $N_x = N_y = 101$, $h = 10$ m, $v_0 = 2000$ m/s, source $(x_s,y_s) = (10\\,\\text{m}, 10\\,\\text{m})$ corresponding to $(i_s,j_s) = (1,1)$.\n\nFor each case, compute the maximum absolute error along the bottom boundary for Variant A and Variant B, denoted $E_{\\text{A}}$ and $E_{\\text{B}}$ in seconds. Then compute the improvement factor\n$$\n\\rho \\,=\\, \\frac{E_{\\text{A}}}{E_{\\text{B}}}.\n$$\n\nFinal Output Format:\nYour program should produce a single line of output containing the improvement factors for the four test cases as a comma-separated list enclosed in square brackets, with each value rounded to six decimal places (e.g., $\\left[\\rho_1,\\rho_2,\\rho_3,\\rho_4\\right]$). The output must be dimensionless.", "solution": "The problem requires the design and implementation of a numerical solver for the Eikonal equation in a two-dimensional homogeneous medium with a reflecting boundary. The core task is to compare two variants of a Fast Sweeping Method (FSM) solver: a standard implementation (Variant A) and one enhanced with a boundary-aware source extension using the method-of-images (Variant B). The goal is to quantify the improvement in accuracy near the reflecting boundary.\n\n### 1. The Eikonal Equation and Godunov Discretization\n\nThe first-arrival travel time $T(x,y)$ in a medium with slowness $s(x,y)$ is governed by the Eikonal equation:\n$$\n|\\nabla T(x,y)|^2 = s(x,y)^2\n$$\nIn a homogeneous medium with constant wave speed $v_0$, the slowness is also constant, $s(x,y) = s_0 = 1/v_0$. On a uniform Cartesian grid with spacing $h$, where $T_{i,j}$ denotes the travel time at $(x_i, y_j) = (ih, jh)$, the equation can be written as:\n$$\n\\left( \\frac{\\partial T}{\\partial x} \\right)^2 + \\left( \\frac{\\partial T}{\\partial y} \\right)^2 = s_0^2\n$$\nA stable numerical scheme is a Godunov-type upwind finite-difference method. For an update at node $(i,j)$, the spatial derivatives are approximated using only \"upwind\" information, i.e., from neighboring nodes that have smaller travel times and from which the wave is arriving. This leads to a local non-linear equation for a candidate update time $\\hat{T}_{i,j}$. Let $T_x = \\min(T_{i-1,j}, T_{i+1,j})$ and $T_y = \\min(T_{i,j-1}, T_{i,j+1})$ be the minimum travel times of neighbors in the $x$ and $y$ directions, respectively. The updated time $\\hat{T}_{i,j}$ must satisfy:\n$$\n\\left( \\frac{\\max(\\hat{T}_{i,j}-T_x, 0)}{h} \\right)^2 + \\left( \\frac{\\max(\\hat{T}_{i,j}-T_y, 0)}{h} \\right)^2 = s_0^2\n$$\nThis equation can be solved for $\\hat{T}_{i,j}$. A common and robust procedure is as follows:\nLet $t_{min} = \\min(T_x, T_y)$ and $t_{max} = \\max(T_x, T_y)$.\n1.  First, attempt a one-dimensional update using the neighbor with the minimum time: $\\hat{T}_{1D} = t_{min} + h s_0$.\n2.  If this update yields a time less than or equal to the other neighbor's time ($\\hat{T}_{1D} \\le t_{max}$), it is accepted. This corresponds to the case where the characteristic (ray path) arriving at $(i,j)$ is aligned primarily with one grid axis.\n3.  If $\\hat{T}_{1D} > t_{max}$, both neighbors contribute, and the update is determined by solving the full quadratic equation, which yields the two-dimensional update:\n    $$\n    \\hat{T}_{2D} = \\frac{t_{min} + t_{max} + \\sqrt{2(hs_0)^2 - (t_{max} - t_{min})^2}}{2}\n    $$\nThe new candidate time for node $(i,j)$ is $\\hat{T}$. The final value is updated via a Gauss-Seidel approach: $T_{i,j} \\leftarrow \\min(T_{i,j}, \\hat{T})$.\n\n### 2. The Fast Sweeping Method (FSM)\n\nFSM is an iterative algorithm that efficiently solves the discretized Eikonal equation. It leverages the Gauss-Seidel-like updates described above and systematically sweeps through the grid in different directions to correctly propagate information from the source.\nThe algorithm proceeds as follows:\n1.  **Initialization**: The travel time grid $T$ is initialized with $T_{i_s, j_s} = 0$ at the source location $(i_s, j_s)$ and $T=\\infty$ at all other grid points.\n2.  **Sweeping**: The method iterates through a set of four sweeps that cover all characteristic propagation directions:\n    - Sweep 1: $i = 0, \\dots, N_x-1$; $j = 0, \\dots, N_y-1$ (bottom-left to top-right)\n    - Sweep 2: $i = N_x-1, \\dots, 0$; $j = 0, \\dots, N_y-1$ (bottom-right to top-left)\n    - Sweep 3: $i = N_x-1, \\dots, 0$; $j = N_y-1, \\dots, 0$ (top-right to bottom-left)\n    - Sweep 4: $i = 0, \\dots, N_x-1$; $j = N_y-1, \\dots, 0$ (top-left to bottom-right)\n    In each sweep, every non-source grid point is updated using the Godunov scheme.\n3.  **Convergence**: The cycle of four sweeps is repeated until the travel time field $T$ converges, i.e., the maximum change in any $T_{i,j}$ between full cycles is below a small tolerance. For homogeneous media, convergence is typically achieved in only a few cycles.\n\n### 3. Boundary Condition Variants\n\nThe key difference between the two variants lies in the treatment of the bottom boundary at $y=0$ ($j=0$).\n\n**Variant A (Standard Point Source)**:\nAt the domain boundaries, standard one-sided finite differences are used. When updating a node on the bottom boundary, $(i,0)$, the upwind neighbor search for the $y$-direction considers only the interior neighbor $T_{i,1}$. The out-of-bounds neighbor $T_{i,-1}$ is effectively treated as having infinite travel time, so $T_y = T_{i,1}$. This is a simple but often inaccurate approximation of the boundary condition.\n\n**Variant B (Boundary-Aware Source Extension)**:\nThis variant uses the method-of-images to model the specularly reflecting boundary at $y=0$. For a source at $(x_s, y_s)$, an image source is placed at $(x_s, -y_s)$. This image source is used to define travel times on a layer of \"ghost\" nodes located at $y_{-1} = -h$. The travel time $T_0(i)$ at a ghost node $(x_i, y_{-1})$ is the time taken to travel from the image source to that ghost node:\n$$\nT_0(i) \\,=\\, \\frac{1}{v_0}\\sqrt{(x_i - x_s)^2 + (y_{-1} - (-y_s))^2} \\,=\\, \\frac{1}{v_0}\\sqrt{(x_i - x_s)^2 + (y_s - h)^2}\n$$\nWhen updating a node $(i,0)$ on the physical boundary, these ghost values are used in the upwind stencil. The minimum neighbor time in the $y$-direction becomes $T_y = \\min(T_0(i), T_{i,1})$. This provides the solver with accurate information from \"across\" the boundary, effectively enforcing the correct physics of reflection and yielding a more accurate numerical solution for the first-arrival time field near the boundary.\n\n### 4. Error Quantification\n\nTo assess the accuracy of each variant, the numerically computed travel times along the bottom boundary, $T_{i,0}$, are compared to the analytical solution. For a homogeneous medium, the first-arrival travel time at a point $(x,0)$ on the boundary from a source at $(x_s, y_s)$ is simply the direct path distance divided by the velocity:\n$$\nT^{\\text{true}}(x,0) \\,=\\, \\frac{1}{v_0}\\sqrt{(x - x_s)^2 + y_s^2}\n$$\nThe maximum absolute errors for Variant A ($E_{\\text{A}}$) and Variant B ($E_{\\text{B}}$) are calculated along this boundary. The improvement factor, $\\rho = E_{\\text{A}} / E_{\\text{B}}$, quantifies the performance gain of the boundary-aware method.", "answer": "```python\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Main solver to run test cases and compute improvement factors.\n    \"\"\"\n    test_cases = [\n        {'Nx': 101, 'Ny': 101, 'h': 10.0, 'v0': 2000.0, 'xs': 500.0, 'ys': 10.0},\n        {'Nx': 101, 'Ny': 101, 'h': 10.0, 'v0': 2000.0, 'xs': 500.0, 'ys': 0.0},\n        {'Nx': 101, 'Ny': 101, 'h': 10.0, 'v0': 2000.0, 'xs': 500.0, 'ys': 300.0},\n        {'Nx': 101, 'Ny': 101, 'h': 10.0, 'v0': 2000.0, 'xs': 10.0, 'ys': 10.0},\n    ]\n\n    improvement_factors = []\n\n    for case in test_cases:\n        Nx, Ny, h, v0 = case['Nx'], case['Ny'], case['h'], case['v0']\n        xs, ys = case['xs'], case['ys']\n        s0 = 1.0 / v0\n        ix_s = int(round(xs / h))\n        iy_s = int(round(ys / h))\n\n        def solve_for_T_at_node(i, j, T, T_ghost, h_s0):\n            \"\"\"Calculates the updated travel time at a single node.\"\"\"\n            # Get minimum travel times from neighbors\n            Tx_min = np.inf\n            if i > 0: Tx_min = min(Tx_min, T[i - 1, j])\n            if i < Nx - 1: Tx_min = min(Tx_min, T[i + 1, j])\n\n            Ty_min = np.inf\n            if j > 0:\n                Ty_min = min(Ty_min, T[i, j - 1])\n            elif T_ghost is not None:  # Variant B at j=0\n                Ty_min = min(Ty_min, T_ghost[i])\n\n            if j < Ny - 1: Ty_min = min(Ty_min, T[i, j + 1])\n\n            t_min = min(Tx_min, Ty_min)\n            if t_min == np.inf:\n                return np.inf\n\n            # Attempt 1D update\n            t_new = t_min + h_s0\n\n            # If 2D update is necessary and possible\n            t_max = max(Tx_min, Ty_min)\n            if t_max != np.inf and t_new > t_max:\n                discriminant = 2.0 * h_s0**2 - (t_max - t_min)**2\n                if discriminant >= 0:\n                    t_new = (t_min + t_max + np.sqrt(discriminant)) / 2.0\n            \n            return t_new\n\n        def run_fsm(variant):\n            \"\"\"Performs the Fast Sweeping Method for a given variant.\"\"\"\n            T = np.full((Nx, Ny), np.inf)\n            if 0 <= ix_s < Nx and 0 <= iy_s < Ny:\n                T[ix_s, iy_s] = 0.0\n\n            T_ghost = None\n            if variant == 'B':\n                y_ghost = -h\n                T_ghost = s0 * np.sqrt((np.arange(Nx) * h - xs)**2 + (ys - h)**2)\n\n            h_s0 = h * s0\n            \n            for _ in range(20):  # FSM converges quickly in homogeneous media\n                T_old = T.copy()\n                \n                # Sweep 1: i ->, j ->\n                for i in range(Nx):\n                    for j in range(Ny):\n                        if i == ix_s and j == iy_s: continue\n                        t_updated = solve_for_T_at_node(i, j, T, T_ghost, h_s0)\n                        T[i, j] = min(T[i, j], t_updated)\n                \n                # Sweep 2: i <-, j ->\n                for i in range(Nx - 1, -1, -1):\n                    for j in range(Ny):\n                        if i == ix_s and j == iy_s: continue\n                        t_updated = solve_for_T_at_node(i, j, T, T_ghost, h_s0)\n                        T[i, j] = min(T[i, j], t_updated)\n                \n                # Sweep 3: i <-, j <-\n                for i in range(Nx - 1, -1, -1):\n                    for j in range(Ny - 1, -1, -1):\n                        if i == ix_s and j == iy_s: continue\n                        t_updated = solve_for_T_at_node(i, j, T, T_ghost, h_s0)\n                        T[i, j] = min(T[i, j], t_updated)\n                \n                # Sweep 4: i ->, j <-\n                for i in range(Nx):\n                    for j in range(Ny - 1, -1, -1):\n                        if i == ix_s and j == iy_s: continue\n                        t_updated = solve_for_T_at_node(i, j, T, T_ghost, h_s0)\n                        T[i, j] = min(T[i, j], t_updated)\n                        \n                if np.max(np.abs(T - T_old)) < 1e-12:\n                    break\n            \n            return T\n\n        # Run both variants\n        T_A = run_fsm(variant='A')\n        T_B = run_fsm(variant='B')\n\n        # Calculate analytical solution and errors\n        x_coords = np.arange(Nx) * h\n        T_true_boundary = s0 * np.sqrt((x_coords - xs)**2 + ys**2)\n\n        error_A = np.max(np.abs(T_A[:, 0] - T_true_boundary))\n        error_B = np.max(np.abs(T_B[:, 0] - T_true_boundary))\n        \n        if error_B < 1e-15:\n            rho = 1.0 if error_A < 1e-15 else np.inf\n        else:\n            rho = error_A / error_B\n            \n        improvement_factors.append(rho)\n\n    print(f\"[{','.join([f'{r:.6f}' for r in improvement_factors])}]\")\n\nsolve()\n```", "id": "3591123"}, {"introduction": "While accuracy is essential, computational efficiency is equally critical, especially for large-scale models with complex, heterogeneous media. This advanced practice introduces a powerful technique to accelerate the convergence of the Fast Sweeping Method [@problem_id:3591166]. You will implement a multi-scale solver that uses coarse-grid solutions to provide a better initial guess for the fine grid, exploring how this dramatically reduces the iterations needed for challenging, oscillatory slowness fields.", "problem": "Consider the Eikonal equation arising from Fermat’s principle of stationary travel time in heterogeneous media, expressed as the Hamilton–Jacobi equation $$\\lVert \\nabla T(\\mathbf{x}) \\rVert = s(\\mathbf{x}),$$ where $T(\\mathbf{x})$ is the traveltime and $s(\\mathbf{x})$ is the spatially varying slowness (reciprocal of speed). On a uniform Cartesian grid over the domain $[0,1]\\times[0,1]$ with grid size $N$ and spacing $h = 1/(N-1)$, the continuous equation is approximated using a monotone upwind discretization, and solved by the Fast Sweeping Method (FSM), defined as alternating Gauss–Seidel sweeps along characteristic directions.\n\nYour task is to implement a multi-scale Fast Sweeping method that uses nested sweeps at coarser-to-finer resolutions to generate a good initial guess at the fine scale by prolongation (bilinear interpolation) of coarser solutions. You must then compare the iteration counts (number of full directional sweep cycles) required to reach a prescribed tolerance on the fine grid when using:\n- a single-scale baseline: FSM at the fine resolution starting from a naive initial guess, and\n- a multi-scale approach: FSM on a sequence of coarser grids to convergence, with prolongation to the fine grid as initial guess, followed by FSM sweeps on the fine grid.\n\nYou must also provide a principle-based argument explaining why alternating coarse-to-fine sweeps reduce iteration counts for oscillatory $s(\\mathbf{x})$ fields. Angles used inside trigonometric functions must be in radians. No physical units are required; treat all quantities as dimensionless.\n\nImplementation requirements:\n- Define the slowness field $s(x,y)$ for each problem instance as $$s(x,y) = 1 + a \\sin(2\\pi K x)\\sin(2\\pi K y),$$ with amplitude $a \\in [0,1)$ and integer spatial frequency $K \\ge 0$, evaluated on grid nodes $(x_i,y_j)$ with $x_i = i/(N-1)$ and $y_j = j/(N-1)$ for $i,j \\in \\{0,1,\\dots,N-1\\}$. The angle unit is radians.\n- Use a single point source located at the geometric center $(x_0,y_0) = (0.5,0.5)$, i.e., the closest grid node index $(i_0,j_0)$ to $(0.5,0.5)$ has boundary condition $T_{i_0,j_0}=0$, and all other nodes begin with a large initial traveltime value.\n- Implement the standard $4$ directional sweep cycle of the Fast Sweeping Method (FSM), using the monotone upwind local solver for the discrete Eikonal equation. A full cycle is the sequence of sweeps over index orders $(i\\uparrow,j\\uparrow)$, $(i\\downarrow,j\\uparrow)$, $(i\\uparrow,j\\downarrow)$, $(i\\downarrow,j\\downarrow)$.\n- Convergence criterion: after each full cycle, compute the maximum absolute change in $T$ over the grid; convergence is reached when this is less than the tolerance $\\varepsilon = 10^{-6}$. Cap the number of cycles at a sufficiently large maximum (e.g., $200$) to guarantee termination.\n- Multi-scale nested sweeps: for a given fine grid size $N$, construct a level list $[N_c^{(1)}, N_c^{(2)}, N]$ with $N_c^{(1)} = \\lfloor N/4 \\rfloor$ and $N_c^{(2)} = \\lfloor N/2 \\rfloor$, adjusted so that all levels are at least $8$ and strictly increasing. On each coarse level, solve the discrete problem to convergence; prolongate the coarse solution to the next finer level using bilinear interpolation; use the prolongated traveltime field as the initial guess for the FSM at that finer level. On the final fine level, count only the number of full cycles executed at that level.\n\nDiscrete local solver specification:\n- Let $T_{i,j}$ be the traveltime at grid node $(i,j)$, and define $$a_x = \\min(T_{i-1,j}, T_{i+1,j}), \\quad a_y = \\min(T_{i,j-1}, T_{i,j+1}),$$ using only available neighbors at boundaries. Let $u = \\min(a_x,a_y)$ and $v = \\max(a_x,a_y)$. Let $\\sigma = s_{i,j}$ and $h$ be the grid spacing. The monotone local update $\\tilde{T}$ that solves the discrete Eikonal equation at $(i,j)$ is computed as\n$$\n\\tilde{T} =\n\\begin{cases}\nu + h\\,\\sigma, & \\text{if } v - u \\ge h\\,\\sigma,\\\\[6pt]\n\\dfrac{u + v + \\sqrt{2(h\\,\\sigma)^2 - (v - u)^2}}{2}, & \\text{otherwise.}\n\\end{cases}\n$$\nThe Gauss–Seidel update sets $T_{i,j}\\leftarrow \\min(T_{i,j}, \\tilde{T})$, and $T_{i_0,j_0}=0$ is held fixed.\n\nTest suite:\n- Case $1$ (general oscillatory): $N=64$, $a=0.5$, $K=6$.\n- Case $2$ (constant slowness edge case): $N=64$, $a=0.0$, $K=0$.\n- Case $3$ (high-frequency oscillatory): $N=64$, $a=0.9$, $K=12$.\n- Case $4$ (small-grid boundary case): $N=16$, $a=0.8$, $K=3$.\n\nFor each case, compute:\n- the number of full cycles to converge on the fine grid for the baseline single-scale FSM, starting from a naive large initial guess;\n- the number of full cycles to converge on the fine grid for the multi-scale approach, starting from prolongation of coarser solutions;\n- the integer reduction $\\Delta = (\\text{baseline fine cycles}) - (\\text{multi-scale fine cycles})$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the four cases, i.e., $[\\Delta_1,\\Delta_2,\\Delta_3,\\Delta_4]$.", "solution": "The problem is scientifically and mathematically well-posed, describing a standard numerical experiment to compare single-scale and multi-scale Fast Sweeping Methods for the Eikonal equation. All parameters and procedures are sufficiently defined to allow for a unique and verifiable implementation. The underlying principles—the Eikonal equation, Fast Sweeping Method, and multi-scale acceleration—are all staples of computational science and geophysics. The problem is therefore deemed **valid**.\n\nThe core task is to compare the convergence rate, measured in the number of full sweep cycles, of a single-scale Fast Sweeping Method (FSM) versus a multi-scale FSM for solving the Eikonal equation, $\\lVert \\nabla T(\\mathbf{x}) \\rVert = s(\\mathbf{x})$. Here, $T(\\mathbf{x})$ is the traveltime field and $s(\\mathbf{x})$ is the slowness of the medium. The FSM is an iterative algorithm that resolves the traveltime field by performing Gauss-Seidel-like sweeps across the computational grid in alternating directions. The number of iterations required for convergence is highly dependent on the properties of the slowness field $s(\\mathbf{x})$.\n\nThe reason a multi-scale approach, employing coarse-to-fine nested sweeps, significantly reduces iteration counts for oscillatory slowness fields lies in the spectral properties of the FSM solver and the nature of the multiscale decomposition.\n\nAn iterative solver like the FSM can be analyzed in terms of how effectively it reduces error components of different spatial frequencies. The FSM, like other local iterative methods such as Gauss-Seidel, is highly effective at damping high-frequency (short-wavelength) components of the error. An error at a grid point $(i,j)$ is rapidly corrected using the up-to-date information from its immediate neighbors, which is made available within a single sweep cycle. This corresponds to resolving local details of the traveltime field.\n\nConversely, the FSM is inefficient at damping low-frequency (long-wavelength) error components. These errors represent global discrepancies in the solution, such as an underestimation of the traveltime across a large portion of the domain. Correcting such errors requires information to propagate from the source or boundaries across the entire grid. In the FSM, information propagates at a maximum rate of one grid cell per sweep in any given direction. Propagating a correction across a grid of size $N$ can therefore take on the order of $O(N)$ sweep cycles, leading to slow convergence.\n\nThis issue is exacerbated by an oscillatory slowness field, $s(x,y) = 1 + a \\sin(2\\pi K x)\\sin(2\\pi K y)$, especially for large amplitude $a$ and frequency $K$. The characteristics of the Eikonal equation, which represent the paths of information propagation (rays), become highly tortuous. They bend and refract at the interfaces of high and low slowness. A sweep progressing in one direction (e.g., increasing $i$ and $j$ indices) can only propagate information from \"upwind\" nodes (those with smaller $T$ values). If a characteristic path locally turns against the sweep direction, information flow stalls until a subsequent sweep in a more favorable direction occurs. For highly oscillatory media, this can lead to information being \"trapped\" or propagating very slowly, manifesting as a severe slowdown in the convergence of the low-frequency error components.\n\nThe multi-scale method directly addresses this fundamental weakness. The strategy is to solve the problem on a hierarchy of grids, from coarse to fine.\n\n$1$. **Efficient Global Propagation on Coarse Grids**: On a coarse grid, the fine-scale oscillations of the slowness field $s(\\mathbf{x})$ are not resolved; they are effectively averaged or filtered out. The slowness field on the coarse grid is a smoother, long-wavelength approximation of the true field. Consequently, the characteristics on the coarse grid are much straighter and less complex. The FSM can therefore solve for the traveltime field on this coarse grid very efficiently, rapidly establishing the global, long-wavelength structure of the solution across the entire domain.\n\n$2$. **High-Quality Initial Guess**: The solution obtained on a coarse grid is then prolongated (interpolated) to serve as an initial guess for the next finer grid. This initial guess is far superior to a naive guess (e.g., infinity everywhere). It already contains the correct global structure and long-range information of the traveltime field. The error between this initial guess and the true fine-grid solution is therefore primarily composed of high-frequency components, corresponding to the local details that were absent on the coarse grid.\n\n$3$. **Rapid Local Correction on Fine Grids**: When the FSM is initiated on the fine grid with this high-quality guess, its task is reduced to eliminating the remaining high-frequency error. As established, the FSM is exceptionally efficient at this task. It converges in a small number of cycles, as it only needs to perform local adjustments to account for the fine-scale oscillations in $s(\\mathbf{x})$.\n\nIn essence, the multi-scale method decouples the problem by scale. The computationally inexpensive coarse grids are used to efficiently resolve the slow-to-converge, low-frequency (global) error components. The computationally expensive fine grid is then only used for a few iterations to resolve the fast-to-converge, high-frequency (local) error components. This division of labor is why the number of iterations required on the final fine grid is drastically reduced, especially in challenging cases with oscillatory media. For the simple case of constant slowness, $a=0$, characteristics are straight lines and the baseline FSM is already very efficient, so the gains from the multi-scale approach are minimal.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.interpolate import RegularGridInterpolator\n\ndef get_levels(N):\n    \"\"\"\n    Constructs the list of grid sizes for the multi-scale method\n    based on the problem specification.\n    \"\"\"\n    levels = []\n    # Per the problem: \"construct a level list [Nc(1), Nc(2), N] with\n    # Nc(1) = floor(N/4) and Nc(2) = floor(N/2), adjusted so that all levels\n    # are at least 8 and strictly increasing.\"\n    potential_levels = [N // 4, N // 2, N]\n    \n    for level in potential_levels:\n        adjusted_level = max(level, 8)\n        # Add to list if it's the first level or strictly greater than the last\n        if not levels or adjusted_level > levels[-1]:\n            levels.append(adjusted_level)\n            \n    return levels\n\ndef run_fsm(N, a, K, initial_T=None, tol=1e-6, max_cycles=200):\n    \"\"\"\n    Executes the Fast Sweeping Method on a given grid.\n    \"\"\"\n    # Grid and slowness field setup\n    h = 1.0 / (N - 1) if N > 1 else 1.0\n    x = np.linspace(0.0, 1.0, N)\n    y = np.linspace(0.0, 1.0, N)\n    X, Y = np.meshgrid(x, y)\n    S = 1.0 + a * np.sin(2.0 * np.pi * K * X) * np.sin(2.0 * np.pi * K * Y)\n\n    # Initialize traveltime grid T\n    if initial_T is None:\n        T = np.full((N, N), np.inf, dtype=np.float64)\n    else:\n        T = initial_T.copy()\n        if T.shape != (N, N):\n            raise ValueError(\"Shape of initial_T does not match grid size N.\")\n\n    # Source point at grid center\n    i0 = (N - 1) // 2\n    j0 = (N - 1) // 2\n    T[i0, j0] = 0.0\n\n    for cycle in range(1, max_cycles + 1):\n        T_old = T.copy()\n\n        # Four sweep directions\n        sweep_orders = [\n            (range(N), range(N)),                          # i increasing, j increasing\n            (range(N - 1, -1, -1), range(N)),              # i decreasing, j increasing\n            (range(N), range(N - 1, -1, -1)),              # i increasing, j decreasing\n            (range(N - 1, -1, -1), range(N - 1, -1, -1)),  # i decreasing, j decreasing\n        ]\n\n        for i_order, j_order in sweep_orders:\n            for i in i_order:\n                for j in j_order:\n                    if i == i0 and j == j0:\n                        continue\n                    \n                    # Get neighbor traveltimes, handling boundaries\n                    t_im1 = T[i - 1, j] if i > 0 else np.inf\n                    t_ip1 = T[i + 1, j] if i < N - 1 else np.inf\n                    t_jm1 = T[i, j - 1] if j > 0 else np.inf\n                    t_jp1 = T[i, j + 1] if j < N - 1 else np.inf\n\n                    # Upwind values in x and y\n                    ax = min(t_im1, t_ip1)\n                    ay = min(t_jm1, t_jp1)\n\n                    if np.isinf(ax) and np.isinf(ay):\n                        continue\n\n                    # Local Eikonal solver\n                    u = min(ax, ay)\n                    v = max(ax, ay)\n                    \n                    sigma = S[i, j]\n                    h_sigma = h * sigma\n                    \n                    t_new = u + h_sigma\n                    # This condition also correctly handles v = inf\n                    if v - u < h_sigma:\n                        # Only use 2D solver if v is finite\n                        if not np.isinf(v):\n                            discriminant = 2.0 * h_sigma**2 - (v - u)**2\n                            if discriminant >= 0:\n                                t_new = (u + v + np.sqrt(discriminant)) / 2.0\n                    \n                    T[i, j] = min(T[i, j], t_new)\n\n        # Convergence check\n        max_change = np.max(np.abs(T - T_old))\n        if max_change < tol:\n            return cycle, T\n    \n    return max_cycles, T\n\ndef prolongate(T_coarse, N_fine):\n    \"\"\"\n    Prolongates a coarse grid solution to a finer grid using bilinear interpolation.\n    \"\"\"\n    Nc = T_coarse.shape[0]\n    coarse_coords = np.linspace(0.0, 1.0, Nc)\n    \n    # Scipy's RegularGridInterpolator is efficient for this\n    interp_func = RegularGridInterpolator(\n        (coarse_coords, coarse_coords), T_coarse, \n        method='linear', bounds_error=False, fill_value=np.inf\n    )\n    \n    fine_coords = np.linspace(0.0, 1.0, N_fine)\n    Xf, Yf = np.meshgrid(fine_coords, fine_coords)\n    \n    # The interpolator expects points as a (n_points, n_dims) array\n    points_fine = np.vstack([Yf.ravel(), Xf.ravel()]).T\n    \n    T_fine = interp_func(points_fine).reshape((N_fine, N_fine))\n    return T_fine\n\ndef solve():\n    test_cases = [\n        # (N, a, K)\n        (64, 0.5, 6),\n        (64, 0.0, 0),\n        (64, 0.9, 12),\n        (16, 0.8, 3),\n    ]\n\n    results = []\n    for N, a, K in test_cases:\n        # 1. Baseline single-scale FSM\n        cycles_baseline, _ = run_fsm(N, a, K)\n\n        # 2. Multi-scale FSM\n        levels = get_levels(N)\n        T_solution = None\n        cycles_multiscale_fine = -1 \n\n        for n_level in levels:\n            if T_solution is None:  # Coarsest grid starts from naive guess\n                initial_guess = None\n            else:\n                initial_guess = prolongate(T_solution, n_level)\n            \n            cycles, T_solution = run_fsm(n_level, a, K, initial_T=initial_guess)\n            \n            if n_level == N:  # We are on the final, fine grid\n                cycles_multiscale_fine = cycles\n        \n        # 3. Compute reduction in cycles\n        delta = cycles_baseline - cycles_multiscale_fine\n        results.append(delta)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3591166"}]}