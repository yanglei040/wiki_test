{"hands_on_practices": [{"introduction": "The eikonal equation and the concept of ray paths are deeply intertwined; the former describes the travel-time field, while the latter represents the characteristics along which information propagates. This practice guides you through a fundamental exercise in computational geophysics: verifying the self-consistency of these two concepts in a numerical setting. You will implement the Fast Marching Method to solve the eikonal equation on a grid and then trace rays by following the gradient of the resulting travel-time field, allowing you to quantify the numerical mismatch between the field-based and path-integrated travel times [@problem_id:3614052]. This process is essential for understanding the sources of error in numerical wave propagation and for building confidence in your computational tools.", "problem": "Design and implement a complete program that, for a two-dimensional isotropic medium with spatially varying slowness, quantifies numerical error in first-arrival travel times by comparing two independently computed quantities at prescribed receiver locations: (i) the interpolated solution of the eikonal travel-time field defined by the partial differential equation $|\\nabla T| = s(\\mathbf{x})$ and (ii) the line integral of slowness along numerically traced rays obtained by following the local gradient of the travel-time field. Your implementation must start from fundamental principles appropriate to seismic ray tracing methods in computational geophysics, namely Fermat’s principle and the Hamilton–Jacobi form of the eikonal equation. No shortcut formulas beyond these foundations may be assumed; all algorithmic steps must be justified by causality and upwind consistency. You must resolve the following requirements.\n\n- Physical and mathematical setting:\n  - Consider a two-dimensional Cartesian domain $\\Omega = \\{(x,z): 0 \\le x \\le 4 \\ \\text{km}, \\ 0 \\le z \\le 2 \\ \\text{km}\\}$ with uniform grid spacing $h = 0.02 \\ \\text{km}$ in both $x$ and $z$ directions.\n  - Define the background velocity as $v_0 = 3.0 \\ \\text{km/s}$, so the background slowness is $s_0 = 1/v_0 \\ \\text{s/km}$.\n  - Superimpose a focusing Gaussian slow lens (higher slowness) centered at $(x_c,z_c) = (2.0 \\ \\text{km}, 1.0 \\ \\text{km})$ with relative amplitude $A = 0.5$ and standard deviation $\\sigma = 0.3 \\ \\text{km}$, so that the slowness field is\n    $$ s(x,z) = s_0 \\left( 1 + A \\exp\\!\\left( -\\frac{(x-x_c)^2 + (z-z_c)^2}{2 \\sigma^2} \\right) \\right) \\ \\text{s/km}. $$\n  - Place a point source at $(x_s,z_s) = (0.2 \\ \\text{km}, 1.0 \\ \\text{km})$.\n\n- Fundamental base and algorithmic tasks to implement:\n  - From Fermat’s principle, the travel time accumulated along a parametric path $\\gamma(\\ell)$ with arclength parameter $\\ell$ is the functional\n    $$ \\mathcal{T}[\\gamma] = \\int_{\\ell_0}^{\\ell_1} s(\\gamma(\\ell)) \\, d\\ell \\ \\text{s}. $$\n    The first-arrival travel-time field $T(\\mathbf{x})$ is the viscosity solution of the Hamilton–Jacobi eikonal equation\n    $$ |\\nabla T(\\mathbf{x})| = s(\\mathbf{x}). $$\n  - Implement a first-order, monotone, upwind Fast Marching Method that computes a discrete travel-time field $T_h$ on the grid for the given slowness $s(x,z)$, honoring causality. Do not assume any closed-form updates beyond what follows from upwind consistency and local quadratic solves implied by the discrete Hamilton–Jacobi structure. Initialize $T_h$ at the grid node nearest to $(x_s,z_s)$ with $T = 0 \\ \\text{s}$.\n  - Implement ray back-tracing from a receiver location $\\mathbf{x}_r$ to the source by following the negative normalized gradient of the computed $T_h$ (i.e., a characteristic curve), using a step in arclength $\\Delta \\ell$ and bilinear interpolation of both $T_h$ and $s$ at off-grid points. The ordinary differential equation to integrate is\n    $$ \\frac{d\\mathbf{x}}{d\\ell} = - \\frac{\\nabla T(\\mathbf{x})}{|\\nabla T(\\mathbf{x})|}, $$\n    with termination when $\\|\\mathbf{x} - \\mathbf{x}_s\\|$ is within one grid spacing. Accumulate the line integral\n    $$ \\widehat{T}_{\\text{ray}}(\\mathbf{x}_r) = \\int_0^{L(\\mathbf{x}_r)} s(\\mathbf{x}(\\ell)) \\, d\\ell \\ \\text{s}, $$\n    where $L(\\mathbf{x}_r)$ is the traced path length to the source. Compute also the interpolated eikonal time $\\widehat{T}_{\\text{eik}}(\\mathbf{x}_r)$ by bilinear interpolation of $T_h$ at $\\mathbf{x}_r$.\n  - For each receiver, report the signed mismatch\n    $$ \\Delta(\\mathbf{x}_r) = \\widehat{T}_{\\text{ray}}(\\mathbf{x}_r) - \\widehat{T}_{\\text{eik}}(\\mathbf{x}_r) \\ \\text{s}. $$\n\n- Units and numerics:\n  - All distances must be in kilometers, all travel times in seconds, and all slowness values in seconds per kilometer. No angles are required. When integrating rays, use a constant arclength step $\\Delta \\ell = 0.005 \\ \\text{km}$ and terminate when the Euclidean distance to $(x_s,z_s)$ is less than $0.02 \\ \\text{km}$ or a maximum of $10000$ steps is reached, whichever occurs first. Use bilinear interpolation for field samples at off-grid points.\n\n- Test suite:\n  - Use the following receiver coordinates (in kilometers) to exercise normal propagation, near-caustic focusing along the optical axis, off-axis near-caustic behavior, passage through the lens, and a far-field boundary case:\n    - $\\mathbf{x}_{r,1} = (0.5, 1.0)$\n    - $\\mathbf{x}_{r,2} = (3.5, 1.0)$\n    - $\\mathbf{x}_{r,3} = (3.5, 0.8)$\n    - $\\mathbf{x}_{r,4} = (2.0, 1.0)$\n    - $\\mathbf{x}_{r,5} = (3.9, 1.0)$\n\n- Required output:\n  - Your program must produce a single line containing the list of signed mismatches in seconds for the above receivers, in the same order, formatted as decimal floats to six digits after the decimal point, enclosed in square brackets and comma-separated (for example, $[0.000123,-0.000456,\\dots]$). Express the final values in seconds, with the sign preserved.\n\nYour design must be fully self-contained and deterministic, and the program must not read any input or require any external files or network access. The program must implement the numerical methods from first principles per the above description and produce the required output in the specified format.", "solution": "The problem requires the design and implementation of a numerical experiment to quantify the self-consistency error in seismic travel-time computation. This is accomplished by comparing two quantities derived from the same underlying numerical construct: (i) the travel time at a receiver location, $\\widehat{T}_{\\text{eik}}(\\mathbf{x}_r)$, obtained by interpolating the solution of the eikonal equation, and (ii) the travel time, $\\widehat{T}_{\\text{ray}}(\\mathbf{x}_r)$, computed by integrating the slowness field along a ray path traced through the eikonal solution field. The entire procedure is grounded in Fermat's principle, which states that the path taken by a seismic wave between two points is the path of stationary, and for first arrivals, minimum, travel time.\n\nThe mathematical formulation of this principle leads to the Hamilton-Jacobi eikonal equation, a fundamental partial differential equation in geophysics:\n$$ |\\nabla T(\\mathbf{x})| = s(\\mathbf{x}) $$\nwhere $T(\\mathbf{x})$ is the first-arrival travel-time field from a source, and $s(\\mathbf{x})$ is the slowness (reciprocal of velocity) of the medium at position $\\mathbf{x}$. The ray paths are the characteristics of this equation.\n\nThe solution proceeds in two primary stages: first, computing the discrete travel-time field $T_h$ on a grid, and second, tracing rays and integrating travel times using this field.\n\n**1. Physical and Computational Domain Setup**\n\nThe problem is set in a two-dimensional Cartesian domain $\\Omega = \\{(x,z) \\mid 0 \\le x \\le 4 \\ \\text{km}, \\ 0 \\le z \\le 2 \\ \\text{km}\\}$. This domain is discretized into a uniform grid with spacing $h = 0.02 \\ \\text{km}$. This results in a grid of $N_x \\times N_z$ nodes, where $N_x = 4/0.02 + 1 = 201$ and $N_z = 2/0.02 + 1 = 101$.\n\nThe slowness field $s(x,z)$ is defined by a constant background slowness $s_0 = 1/v_0 = 1/3.0 \\ \\text{s/km}$ superimposed with a Gaussian anomaly:\n$$ s(x,z) = s_0 \\left( 1 + A \\exp\\!\\left( -\\frac{(x-x_c)^2 + (z-z_c)^2}{2 \\sigma^2} \\right) \\right) $$\nwith parameters $A = 0.5$, $(x_c, z_c) = (2.0, 1.0) \\ \\text{km}$, and $\\sigma = 0.3 \\ \\text{km}$. This slowness function is evaluated at each grid node $(x_i, z_j)$ to create a discrete slowness field $s_{i,j}$.\n\n**2. Eikonal Solution via the Fast Marching Method (FMM)**\n\nThe discrete travel-time field $T_h$ is computed using a first-order Fast Marching Method. FMM is an efficient grid-based algorithm that solves the eikonal equation by systematically advancing a wavefront, respecting causality. This is analogous to Huygens' principle. The algorithm uses a min-priority queue to ensure that grid points are processed in increasing order of travel time.\n\nThe state of each grid node is classified as one of three types:\n- `KNOWN`: The travel time is finalized.\n- `TRIAL`: An estimate of the travel time exists; the node is a candidate for finalization. These nodes form the narrow band or wavefront.\n- `FAR`: The node is untouched.\n\nThe FMM algorithm proceeds as follows:\n- **Initialization**: The travel-time array $T_h$ is initialized to infinity for all nodes. The grid node $(i_s, j_s)$ nearest the source at $(x_s, z_s) = (0.2, 1.0) \\ \\text{km}$ is assigned $T_{i_s, j_s} = 0$. This node is added to a min-priority queue, and its state is set to `TRIAL`.\n- **Iteration**: The main loop of the algorithm repeatedly extracts the `TRIAL` node with the smallest travel time from the priority queue. This node's state is changed to `KNOWN`. For each of its neighbors that is not `KNOWN`, a new travel time is calculated.\n- **Upwind Finite-Difference Update**: The travel time for a node $(i,j)$ is updated based on the finalized (`KNOWN`) values of its neighbors. This upwind scheme recognizes that information flows away from the source. Let $T_x$ and $T_z$ be the minimum travel times of the `KNOWN` neighbors of node $(i,j)$ along the $x$ and $z$ axes, respectively. Let $s_{i,j}$ be the slowness at the node. The updated time $T'_{i,j}$ is determined by a Godunov scheme:\n  1.  If only one upwind neighbor is available (e.g., $T_x$ is finite, $T_z$ is infinite), or if the wave arrives much earlier from one direction, a one-dimensional update is used. This occurs if $|\\min(T_x,T_z) + h s_{i,j}| \\le \\max(T_x,T_z)$. The update is $T'_{i,j} = \\min(T_x, T_z) + h s_{i,j}$.\n  2.  Otherwise, the wavefront is constructed from contributions from both axes. The update is found by solving the quadratic equation derived from the discretized eikonal equation, $(\\frac{T' - T_x}{h})^2 + (\\frac{T' - T_z}{h})^2 = s_{i,j}^2$. The correct causal solution is $T'_{i,j} = \\frac{T_x + T_z + \\sqrt{2(h s_{i,j})^2 - (T_x-T_z)^2}}{2}$.\n- If the newly calculated time $T'_{i,j}$ is less than the current time stored at node $(i,j)$, the value is updated, the node's state is set to `TRIAL`, and it is added to the priority queue. The algorithm terminates when the priority queue is empty.\n\nFinally, the travel time at an arbitrary receiver location $\\mathbf{x}_r$, denoted $\\widehat{T}_{\\text{eik}}(\\mathbf{x}_r)$, is obtained via bilinear interpolation of the final discrete travel-time field $T_h$.\n\n**3. Ray Tracing and Travel-Time Integration**\n\nSeismic rays are the characteristic curves of the eikonal equation, oriented along the gradient of the travel-time field, $\\nabla T$. To trace a ray from a receiver $\\mathbf{x}_r$ back to the source $\\mathbf{x}_s$, we integrate the ordinary differential equation (ODE) for the ray path $\\mathbf{x}(\\ell)$ parameterized by arclength $\\ell$:\n$$ \\frac{d\\mathbf{x}}{d\\ell} = - \\frac{\\nabla T(\\mathbf{x})}{|\\nabla T(\\mathbf{x})|} $$\nThe negative sign indicates back-propagation toward the source. This ODE is solved numerically.\n\n- **Numerical Integration**: A forward Euler method with a constant arclength step $\\Delta \\ell = 0.005 \\ \\text{km}$ is used:\n  $$ \\mathbf{x}_{k+1} = \\mathbf{x}_k - \\Delta\\ell \\frac{\\nabla T_h(\\mathbf{x}_k)}{|\\nabla T_h(\\mathbf{x}_k)|} $$\n  where $\\mathbf{x}_k$ is the position at step $k$. The gradient of the computed field, $\\nabla T_h(\\mathbf{x}_k)$, is required at each step. Since $\\mathbf{x}_k$ is generally not on a grid node, its value is found by first computing the gradient of $T_h$ on the entire grid using second-order finite differences, and then using bilinear interpolation to evaluate the gradient components at $\\mathbf{x}_k$. The norm $|\\nabla T_h(\\mathbf{x}_k)|$ is computed from this interpolated gradient vector.\n- **Travel-Time Accumulation**: The total travel time along the ray, $\\widehat{T}_{\\text{ray}}(\\mathbf{x}_r)$, is the line integral of the slowness field along the traced path. This integral is approximated by a sum (a simple rectangular quadrature rule):\n  $$ \\widehat{T}_{\\text{ray}}(\\mathbf{x}_r) = \\int_{0}^{L} s(\\mathbf{x}(\\ell)) \\, d\\ell \\approx \\sum_{k} s(\\mathbf{x}_k) \\Delta\\ell $$\n  The slowness $s(\\mathbf{x}_k)$ at each off-grid point is also obtained via bilinear interpolation of the discrete slowness field $s_{i,j}$.\n- **Termination**: The ray tracing process for a given receiver terminates when its Euclidean distance to the source $(x_s, z_s)$ becomes less than one grid spacing ($h = 0.02 \\ \\text{km}$), or if a maximum of $10000$ steps is reached.\n\n**4. Error Quantification**\n\nThe core task is to compute the signed mismatch $\\Delta(\\mathbf{x}_r)$ for each specified receiver $\\mathbf{x}_r$. This value is defined as:\n$$ \\Delta(\\mathbf{x}_r) = \\widehat{T}_{\\text{ray}}(\\mathbf{x}_r) - \\widehat{T}_{\\text{eik}}(\\mathbf{x}_r) $$\nA non-zero $\\Delta(\\mathbf{x}_r)$ is expected and represents the numerical error accumulated from several sources: the first-order accuracy of the FMM, inaccuracies in the finite-difference gradient estimation, the first-order accuracy of the Euler method for ray integration, and errors from repeated bilinear interpolation. This metric serves as a measure of the self-consistency of the implemented numerical methods.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport heapq\nfrom scipy.interpolate import RegularGridInterpolator\n\ndef solve():\n    \"\"\"\n    Computes numerical error in seismic travel times by comparing an FMM eikonal solution\n    with line integrals along traced rays.\n    \"\"\"\n    # 1. Physical and mathematical setting\n    W, H = 4.0, 2.0  # Domain size in km\n    h = 0.02  # Grid spacing in km\n    v0 = 3.0  # Background velocity in km/s\n    s0 = 1.0 / v0  # Background slowness in s/km\n\n    # Gaussian lens parameters\n    xc, zc = 2.0, 1.0  # Center in km\n    A = 0.5  # Relative amplitude (dimensionless)\n    sigma = 0.3  # Standard deviation in km\n\n    # Source and receiver locations\n    xs, zs = 0.2, 1.0  # Source in km\n    source_pos_np = np.array([xs, zs])\n    receivers = [\n        (0.5, 1.0),\n        (3.5, 1.0),\n        (3.5, 0.8),\n        (2.0, 1.0),\n        (3.9, 1.0),\n    ]\n\n    # Numerical parameters for ray tracing\n    delta_l = 0.005  # Arclength step in km\n    max_ray_steps = 10000\n    termination_dist = h\n\n    # 2. Grid and slowness field setup\n    nx = int(W / h) + 1\n    nz = int(H / h) + 1\n    x_ax = np.linspace(0, W, nx)\n    z_ax = np.linspace(0, H, nz)\n    X, Z = np.meshgrid(x_ax, z_ax)\n\n    s_field = s0 * (1.0 + A * np.exp(-((X - xc)**2 + (Z - zc)**2) / (2.0 * sigma**2)))\n\n    # 3. Fast Marching Method (FMM)\n    T = np.full((nz, nx), np.inf)\n    FAR, TRIAL, KNOWN = 0, 1, 2\n    states = np.zeros((nz, nx), dtype=np.int8)\n    pq = []\n\n    # Initialize source\n    isrc = int(np.round(xs / h))\n    jsrc = int(np.round(zs / h))\n    \n    T[jsrc, isrc] = 0.0\n    states[jsrc, isrc] = TRIAL\n    heapq.heappush(pq, (0.0, jsrc, isrc))\n\n    # FMM main loop\n    while pq:\n        time, j, i = heapq.heappop(pq)\n\n        if states[j, i] == KNOWN:\n            continue\n        states[j, i] = KNOWN\n\n        # Process neighbors\n        for dj, di in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            jn, i_n = j + dj, i + di\n\n            if not (0 <= jn < nz and 0 <= i_n < nx):\n                continue\n            if states[jn, i_n] == KNOWN:\n                continue\n\n            # Get minimum times from known neighbors of the target node (jn, i_n)\n            tx_min = np.inf\n            if i_n > 0 and states[jn, i_n - 1] == KNOWN:\n                tx_min = T[jn, i_n - 1]\n            if i_n < nx - 1 and states[jn, i_n + 1] == KNOWN:\n                tx_min = min(tx_min, T[jn, i_n + 1])\n\n            tz_min = np.inf\n            if jn > 0 and states[jn - 1, i_n] == KNOWN:\n                tz_min = T[jn - 1, i_n]\n            if jn < nz - 1 and states[jn + 1, i_n] == KNOWN:\n                tz_min = min(tz_min, T[jn + 1, i_n])\n\n            if tx_min == np.inf and tz_min == np.inf:\n                continue\n\n            # Godunov upwind update\n            t_cand = sorted([tx_min, tz_min])\n            t1, t2 = t_cand[0], t_cand[1]\n            s_val = s_field[jn, i_n]\n            h_s = h * s_val\n            t_new = np.inf\n\n            if t1 + h_s <= t2 or t2 == np.inf:  # 1D update\n                t_new = t1 + h_s\n            else:  # 2D update\n                # Solve: (t-t1)^2 + (t-t2)^2 = (h*s)^2\n                a, b, c = 2.0, -2.0 * (t1 + t2), t1**2 + t2**2 - h_s**2\n                discriminant = b**2 - 4 * a * c\n                if discriminant >= 0:\n                    t_new = (-b + np.sqrt(discriminant)) / (2.0 * a)\n\n            if t_new < T[jn, i_n]:\n                T[jn, i_n] = t_new\n                states[jn, i_n] = TRIAL\n                heapq.heappush(pq, (t_new, jn, i_n))\n\n    # 4. Ray Tracing setup\n    # Create interpolators for T, s, and gradients\n    # Note: RegularGridInterpolator expects points in (z, x) order\n    interp_T = RegularGridInterpolator((z_ax, x_ax), T, bounds_error=False, fill_value=None)\n    interp_s = RegularGridInterpolator((z_ax, x_ax), s_field, bounds_error=False, fill_value=None)\n\n    # Gradients of T: dT/dz, dT/dx\n    gz, gx = np.gradient(T, h, h)\n    interp_dTdx = RegularGridInterpolator((z_ax, x_ax), gx, bounds_error=False, fill_value=None)\n    interp_dTdz = RegularGridInterpolator((z_ax, x_ax), gz, bounds_error=False, fill_value=None)\n    \n    results = []\n    \n    # 5. Compute mismatch for each receiver\n    for xr, zr in receivers:\n        # (i) Get interpolated eikonal travel time\n        T_eik = interp_T([zr, xr])[0]\n\n        # (ii) Trace ray and integrate slowness\n        current_pos = np.array([xr, zr])\n        ray_time = 0.0\n\n        for _ in range(max_ray_steps):\n            if np.linalg.norm(current_pos - source_pos_np) < termination_dist:\n                break\n            \n            # Interpolator expects (z, x) point format\n            pos_for_interp = [current_pos[1], current_pos[0]] \n\n            s_val = interp_s(pos_for_interp)[0]\n            grad_T_x = interp_dTdx(pos_for_interp)[0]\n            grad_T_z = interp_dTdz(pos_for_interp)[0]\n            grad_T = np.array([grad_T_x, grad_T_z])\n            grad_T_norm = np.linalg.norm(grad_T)\n\n            if grad_T_norm < 1e-12: # Avoid division by zero\n                break\n\n            # Euler step for ray path ODE\n            direction = -grad_T / grad_T_norm\n            current_pos += direction * delta_l\n\n            # Accumulate time via line integral (simple quadrature)\n            ray_time += s_val * delta_l\n        \n        delta = ray_time - T_eik\n        results.append(delta)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```", "id": "3614052"}, {"introduction": "Beyond determining travel times, ray theory provides powerful tools to understand wave amplitudes through the concept of geometric spreading. This exercise delves into the realm of dynamic ray tracing to locate caustics—regions where adjacent rays cross, leading to intense focusing of wave energy. You will start from the Hamiltonian formulation of ray theory to derive and then numerically solve the Jacobi equation, a differential equation governing the infinitesimal separation between neighboring rays [@problem_id:3614032]. Successfully locating the first conjugate point, where this separation vanishes, provides a direct, hands-on understanding of how complex velocity structures can create these important and physically significant wavefield features.", "problem": "You are given an isotropic, radially symmetric seismic medium in two spatial dimensions whose scalar slowness is prescribed by $s(r)=s_0\\big(1+\\alpha \\exp(-r^2/\\sigma^2)\\big)$, where $r=\\sqrt{x^2+y^2}$ is the distance from the origin, $s_0>0$ is a constant background slowness, $\\alpha$ is a dimensionless contrast parameter, and $\\sigma>0$ is a characteristic length scale. Let $c(r)=1/s(r)$ be the scalar wave speed. Consider high-frequency rays launched from the origin with initial takeoff angle $\\varphi$ in the plane, and analyze the formation of caustics by computing conjugate points via the Jacobi equation for infinitesimal transverse ray separations.\n\nStarting from first principles of geometrical seismology, namely Fermat's principle and the eikonal equation, treat rays as bicharacteristics of the Hamilton–Jacobi system parameterized by physical travel time $t$ (in $\\mathrm{s}$). Using only these fundamental bases, derive the ordinary differential equation governing the infinitesimal normal separation $y(t)$ between neighboring rays (a scalar Jacobi field), and specify physically correct initial conditions consistent with a point source at the origin. Show how the medium’s inhomogeneity enters the coefficient of this Jacobi equation solely through spatial derivatives of $c(r)$ evaluated along the central ray. You must then specialize the general Jacobi equation to the present radially symmetric medium and implement a robust numerical algorithm to locate the first conjugate point $t_c>0$ defined as the smallest positive travel time at which $y(t)$ returns to zero (a caustic).\n\nRequirements and conventions:\n- Use the Hamiltonian/eikonal framework as the starting point. Do not assume any shortcut paraxial formulas a priori; the Jacobi equation and its coefficient must be obtained from the fundamental laws.\n- Treat the reference ray as launched from the origin at angle $\\varphi$ (in radians). The computation should be universal for any $\\varphi$ by symmetry, but you must state and use correct initial conditions in your derivation with the parameter $t$ being physical travel time (in $\\mathrm{s}$).\n- Angles must be expressed in radians. Distances must be in $\\mathrm{km}$. Times must be in $\\mathrm{s}$.\n- For the radially symmetric profile $s(r)$ given above, implement a solver that integrates the reference ray and the scalar Jacobi equation and detects the first positive zero crossing of $y(t)$ (the first conjugate point). If no zero occurs before a specified maximum time $T_{\\max}$ (in $\\mathrm{s}$), return the sentinel value $-1.000$ for that case.\n- Numerical accuracy: detect zero crossings robustly for smooth functions. When reporting $t_c$, round to three decimal places.\n- Your program must run without any user input and must evaluate the following test suite of parameter sets (each specified as $(s_0,\\alpha,\\sigma,\\varphi,T_{\\max})$):\n    1. $(s_0=\\;0.5\\ \\mathrm{s}/\\mathrm{km},\\ \\alpha=\\;0.6,\\ \\sigma=\\;10\\ \\mathrm{km},\\ \\varphi=\\;0.2\\ \\mathrm{rad},\\ T_{\\max}=\\;120\\ \\mathrm{s})$\n    2. $(s_0=\\;0.5\\ \\mathrm{s}/\\mathrm{km},\\ \\alpha=\\;0.0,\\ \\sigma=\\;10\\ \\mathrm{km},\\ \\varphi=\\;0.3\\ \\mathrm{rad},\\ T_{\\max}=\\;120\\ \\mathrm{s})$\n    3. $(s_0=\\;1/3\\ \\mathrm{s}/\\mathrm{km},\\ \\alpha=\\;0.7,\\ \\sigma=\\;8\\ \\mathrm{km},\\ \\varphi=\\;0.1\\ \\mathrm{rad},\\ T_{\\max}=\\;100\\ \\mathrm{s})$\n    4. $(s_0=\\;0.5\\ \\mathrm{s}/\\mathrm{km},\\ \\alpha=\\;0.3,\\ \\sigma=\\;4\\ \\mathrm{km},\\ \\varphi=\\;1.0\\ \\mathrm{rad},\\ T_{\\max}=\\;80\\ \\mathrm{s})$\n- Final output format: Your program should produce a single line of output containing the results for these four test cases as a comma-separated list of floats in seconds, rounded to three decimal places, enclosed in square brackets, in the same order as the test suite (for example, $[12.345,-1.000,6.789,3.210]$). If a conjugate point occurs, report its $t_c$ in $\\mathrm{s}$. If no conjugate point occurs before $T_{\\max}$, report $-1.000$.\n\nThe problem is universally applicable in that it asks for derivation and numerical realization directly from the foundational laws of high-frequency wave propagation in isotropic media, with all quantities specified in standard physical units and angles in radians. The answer for each test case is a single float number representing the computed first conjugate time in $\\mathrm{s}$, or the sentinel $-1.000$ if none is found before $T_{\\max}$.", "solution": "The problem is to find the first conjugate point (caustic) for seismic rays propagating from the origin in a 2D isotropic medium with a radially symmetric slowness profile. This requires deriving and solving the Jacobi equation for the infinitesimal normal separation between adjacent rays.\n\n### Step 1: Theoretical Formulation\n\n#### 1.1 Hamiltonian Ray Tracing\nWe begin from the eikonal equation, which is a Hamilton-Jacobi equation for the travel time field $T(\\mathbf{x})$. In an isotropic medium with slowness $s(\\mathbf{x}) = 1/c(\\mathbf{x})$, where $c(\\mathbf{x})$ is the wave speed, the eikonal equation is $(\\nabla T)^2 = s^2(\\mathbf{x})$.\nThis can be formulated using a Hamiltonian $H(\\mathbf{x}, \\mathbf{p})$, where $\\mathbf{x}$ is the position and $\\mathbf{p} = \\nabla T$ is the slowness vector. The rays are the bicharacteristic curves of the eikonal equation, which lie on the zero-Hamiltonian surface $H=0$. A suitable Hamiltonian is:\n$$ H(\\mathbf{x}, \\mathbf{p}) = \\frac{1}{2} \\left( \\mathbf{p} \\cdot \\mathbf{p} - s^2(\\mathbf{x}) \\right) = 0 $$\nThe ray paths $\\mathbf{x}(t)$ and the slowness vector $\\mathbf{p}(t)$ along them evolve according to Hamilton's equations, parameterized by a variable $\\tau$:\n$$ \\frac{d\\mathbf{x}}{d\\tau} = \\frac{\\partial H}{\\partial \\mathbf{p}} = \\mathbf{p}, \\quad \\frac{d\\mathbf{p}}{d\\tau} = -\\frac{\\partial H}{\\partial \\mathbf{x}} = s(\\mathbf{x})\\nabla s(\\mathbf{x}) $$\nThe problem requires parameterization by physical travel time $t$. The relation between $d\\tau$ and $dt$ is $dt = s(\\mathbf{x}) |d\\mathbf{x}| = s(\\mathbf{x}) |\\dot{\\mathbf{x}}| d\\tau$. Since $|\\mathbf{p}| = s(\\mathbf{x})$ on the ray, we have $|\\dot{\\mathbf{x}}| = |\\mathbf{p}| = s(\\mathbf{x})$, so $dt = s^2(\\mathbf{x}) d\\tau$. Thus, $\\frac{d}{dt} = \\frac{1}{s^2(\\mathbf{x})} \\frac{d}{d\\tau}$.\n\nThe ray equations parameterized by travel time $t$ become:\n$$ \\frac{d\\mathbf{x}}{dt} = \\frac{1}{s^2(\\mathbf{x})} \\frac{d\\mathbf{x}}{d\\tau} = \\frac{\\mathbf{p}}{s^2(\\mathbf{x})} = c^2(\\mathbf{x})\\mathbf{p} $$\n$$ \\frac{d\\mathbf{p}}{dt} = \\frac{1}{s^2(\\mathbf{x})} \\frac{d\\mathbf{p}}{d\\tau} = \\frac{s(\\mathbf{x})\\nabla s(\\mathbf{x})}{s^2(\\mathbf{x})} = \\frac{\\nabla s(\\mathbf{x})}{s(\\mathbf{x})} = \\nabla(\\ln s(\\mathbf{x})) = -\\nabla(\\ln c(\\mathbf{x})) $$\nThese are the fundamental ray tracing equations.\n\n#### 1.2 The Jacobi Equation\nTo study caustics, we analyze the behavior of a narrow beam of rays. We consider a central ray $\\mathbf{x}(t)$ and its infinitesimal separation $\\mathbf{J}(t)$ from a neighboring ray. The separation vector $\\mathbf{J}(t)$ is called the Jacobi field. Its component $y(t)$ normal to the central ray quantifies the beam's width. A caustic occurs where $y(t)$ goes to zero, causing adjacent rays to cross. The evolution of $y(t)$ is governed by the Jacobi equation, a second-order linear ordinary differential equation. This equation can be derived by linearizing the ray tracing equations, a procedure known as dynamic ray tracing. For a 2D isotropic medium, the Jacobi equation for the normal separation $y(t)$ takes the form:\n$$ \\frac{d^2 y(t)}{dt^2} + K(t) y(t) = 0 $$\nThe coefficient $K(t)$ depends on the properties of the medium evaluated along the central ray. It is given by a standard result from geometrical seismology:\n$$ K(t) = -c(t) \\left. \\frac{\\partial^2 c}{\\partial n^2} \\right|_{\\text{ray}} $$\nwhere $c(t) = c(\\mathbf{x}(t))$ is the wave speed along the ray, and $\\frac{\\partial^2 c}{\\partial n^2}$ is the second derivative of the wave speed in the direction $\\hat{\\mathbf{n}}$ normal to the ray. This coefficient dictates the focusing or defocusing of the ray tube.\n\n#### 1.3 Specialization to the Radially Symmetric Medium\nThe given slowness is $s(r) = s_0(1+\\alpha \\exp(-r^2/\\sigma^2))$, with $r=\\sqrt{x^2+y^2}$. The medium is radially symmetric.\nFor a ray launched from the origin, its trajectory is a straight line. This can be verified from the ray equation for $\\mathbf{p}$:\n$\\frac{d\\mathbf{p}}{dt} = -\\frac{\\nabla c}{c}$. Since $c$ depends only on $r$, $\\nabla c = \\frac{dc}{dr} \\hat{\\mathbf{r}} = \\frac{dc}{dr} \\frac{\\mathbf{x}}{r}$. If a ray starts at $\\mathbf{x}(0)=\\mathbf{0}$ with an initial direction $\\hat{\\mathbf{r}}_0$, its position will be of the form $\\mathbf{x}(t) = r(t)\\hat{\\mathbf{r}}_0$. Thus, $\\nabla c$ is always parallel or anti-parallel to the ray's position vector and thus to its velocity vector. The slowness vector $\\mathbf{p}$ will remain aligned with $\\hat{\\mathbf{r}}_0$, and the ray path is a straight line.\nThe distance from origin $r(t)$ is governed by $\\frac{dr}{dt} = c(r(t))$.\n\nSince the ray is a straight line, we can, without loss of generality, align it with the $x$-axis ($\\varphi=0$). A point on the ray is $(r, 0)$. The normal direction $\\hat{\\mathbf{n}}$ is the $y$-direction. We need to compute $K(r) = -c(r) \\frac{\\partial^2 c}{\\partial y^2}|_{y=0}$.\nThe wave speed is $c(x,y) = c(\\sqrt{x^2+y^2})$. Its derivatives with respect to $y$ are:\n$$ \\frac{\\partial c}{\\partial y} = \\frac{dc}{dr} \\frac{\\partial r}{\\partial y} = \\frac{dc}{dr} \\frac{y}{r} $$\n$$ \\frac{\\partial^2 c}{\\partial y^2} = \\frac{\\partial}{\\partial y} \\left( \\frac{dc}{dr} \\frac{y}{r} \\right) = \\frac{d^2c}{dr^2} \\left(\\frac{y}{r}\\right)^2 + \\frac{dc}{dr} \\left( \\frac{1}{r} - \\frac{y^2}{r^3} \\right) $$\nEvaluating on the ray, where $y=0$ and $r=x$:\n$$ \\left. \\frac{\\partial^2 c}{\\partial y^2} \\right|_{y=0} = \\frac{1}{r} \\frac{dc}{dr} $$\nThus, the coefficient of the Jacobi equation is:\n$$ K(r) = -c(r) \\left( \\frac{1}{r} \\frac{dc}{dr} \\right) $$\nLet's find $\\frac{dc}{dr}$. Given $c(r) = c_0 (1+\\alpha e^{-r^2/\\sigma^2})^{-1}$, where $c_0=1/s_0$:\n$$ \\frac{dc}{dr} = -c_0 (1+\\alpha e^{-r^2/\\sigma^2})^{-2} \\left( \\alpha e^{-r^2/\\sigma^2} \\cdot \\frac{-2r}{\\sigma^2} \\right) = \\frac{2c_0\\alpha r}{\\sigma^2} \\frac{e^{-r^2/\\sigma^2}}{(1+\\alpha e^{-r^2/\\sigma^2})^2} $$\nThen $K(r)$ becomes:\n$$ K(r) = -c(r) \\frac{1}{r} \\left( \\frac{2c_0\\alpha r}{\\sigma^2} \\frac{e^{-r^2/\\sigma^2}}{(1+\\alpha e^{-r^2/\\sigma^2})^2} \\right) = -\\frac{2c_0\\alpha}{\\sigma^2} \\frac{c(r) e^{-r^2/\\sigma^2}}{(1+\\alpha e^{-r^2/\\sigma^2})^2} $$\nThis expression is well-defined at $r=0$, where $\\lim_{r\\to 0} \\frac{1}{r}\\frac{dc}{dr} = \\frac{d^2c}{dr^2}|_{r=0}$.\n\n#### 1.4 Initial Conditions\nWe need initial conditions for $y(t)$ for a point source at the origin. The rays in the beam are parameterized by their launch angle $\\varphi$. The Jacobi field is $\\mathbf{J}(t) = \\frac{\\partial \\mathbf{x}(\\varphi,t)}{\\partial \\varphi}$.\nAt $t=0$, $\\mathbf{x}(\\varphi, 0) = \\mathbf{0}$ for all $\\varphi$, so $\\mathbf{J}(0) = \\mathbf{0}$. This immediately implies $y(0) = \\mathbf{J}(0) \\cdot \\hat{\\mathbf{n}}(0) = 0$.\nTo find $\\dot{y}(0)$, we consider $\\dot{\\mathbf{J}}(t) = \\frac{\\partial \\dot{\\mathbf{x}}(\\varphi,t)}{\\partial \\varphi}$. At $t=0$:\n$$ \\dot{\\mathbf{x}}(\\varphi, 0) = c^2(\\mathbf{0})\\mathbf{p}(\\varphi,0) = c^2(0)s(0)[\\cos\\varphi, \\sin\\varphi] = c(0)[\\cos\\varphi, \\sin\\varphi] $$\n$$ \\dot{\\mathbf{J}}(0) = \\left. \\frac{\\partial}{\\partial \\varphi} \\left( c(0)[\\cos\\varphi, \\sin\\varphi] \\right) \\right|_{\\varphi_0} = c(0)[-\\sin\\varphi_0, \\cos\\varphi_0] = c(0)\\hat{\\mathbf{n}}(0) $$\nwhere $\\hat{\\mathbf{n}}(0)$ is the initial normal vector.\nThen, $\\dot{y}(t) = \\dot{\\mathbf{J}}(t)\\cdot\\hat{\\mathbf{n}}(t) + \\mathbf{J}(t)\\cdot\\dot{\\hat{\\mathbf{n}}}(t)$. At $t=0$:\n$$ \\dot{y}(0) = \\dot{\\mathbf{J}}(0)\\cdot\\hat{\\mathbf{n}}(0) + \\mathbf{J}(0)\\cdot\\dot{\\hat{\\mathbf{n}}}(0) = (c(0)\\hat{\\mathbf{n}}(0))\\cdot\\hat{\\mathbf{n}}(0) + 0 = c(0) $$\nSo, the initial conditions are $y(0)=0$ and $\\dot{y}(0)=c(0)$.\n\n### Step 2: Numerical Implementation\nWe must solve the following system of coupled first-order ODEs for the state vector $[r(t), y(t), z(t)]$, where $z(t) = \\dot{y}(t)$:\n1. $\\frac{dr}{dt} = c(r)$\n2. $\\frac{dy}{dt} = z$\n3. $\\frac{dz}{dt} = -K(r)y$\n\nInitial conditions at $t=0$:\n- $r(0) = 0$\n- $y(0) = 0$\n- $z(0) = c(0) = c_0/(1+\\alpha)$\n\nWe will integrate this system numerically from $t=0$ up to $T_{\\max}$. A conjugate point $t_c$ is the first time $t>0$ for which $y(t_c)=0$. We use an ODE solver with a root-finding (event detection) capability. To avoid the trivial root at $t=0$, the search for a zero-crossing of $y(t)$ will begin at a small time $t > 0$. The potential division-by-zero in the expression for $K(r)$ is handled by using its well-defined limit at $r=0$.\n\nFor the case $\\alpha=0$, the medium is homogeneous ($s(r)=s_0$, $c(r)=c_0$). Then $\\frac{dc}{dr}=0$, so $K(r)=0$. The Jacobi equation becomes $\\ddot{y}=0$. With initial conditions $y(0)=0, \\dot{y}(0)=c_0$, the solution is $y(t)=c_0 t$. This never returns to zero for $t>0$, so no caustic forms. The algorithm must correctly return the sentinel value in this case.", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Main solver function to process test cases for caustic formation.\n    \"\"\"\n\n    test_cases = [\n        # (s0, alpha, sigma, phi, Tmax)\n        (0.5, 0.6, 10.0, 0.2, 120.0),\n        (0.5, 0.0, 10.0, 0.3, 120.0),\n        (1.0/3.0, 0.7, 8.0, 0.1, 100.0),\n        (0.5, 0.3, 4.0, 1.0, 80.0)\n    ]\n\n    results = []\n    for s0, alpha, sigma, phi, Tmax in test_cases:\n        tc = compute_tc(s0, alpha, sigma, Tmax)\n        results.append(f\"{tc:.3f}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef compute_tc(s0, alpha, sigma, Tmax):\n    \"\"\"\n    Computes the first conjugate time for a given set of medium parameters.\n\n    Args:\n        s0 (float): Background slowness (s/km).\n        alpha (float): Dimensionless contrast parameter.\n        sigma (float): Characteristic length scale (km).\n        Tmax (float): Maximum integration time (s).\n\n    Returns:\n        float: The first conjugate time t_c > 0 in seconds, or -1.0 if none is found.\n    \"\"\"\n    c0 = 1.0 / s0\n    \n    # Handle the homogeneous case where no caustics form.\n    if alpha == 0.0:\n        return -1.0\n\n    # Cache parameters for use in ODE functions\n    params = {'c0': c0, 'alpha': alpha, 'sigma': sigma}\n\n    def speed_c(r, p):\n        \"\"\"Computes wave speed c(r).\"\"\"\n        exp_term = np.exp(-r**2 / p['sigma']**2)\n        return p['c0'] / (1.0 + p['alpha'] * exp_term)\n\n    def K_coeff(r, p):\n        \"\"\"Computes the Jacobi equation coefficient K(r).\"\"\"\n        # To avoid division by zero, use the limit of K(r) as r->0\n        # K(0) = -c(0) * c''(0)\n        # c(0) = c0 / (1+alpha)\n        # c''(0) = (2 * c0 * alpha) / (sigma^2 * (1+alpha)^2)\n        # K(0) = - (2 * c0^2 * alpha) / (sigma^2 * (1+alpha)^3)\n        if r < 1e-9:\n            return -2.0 * p['c0']**2 * p['alpha'] / (p['sigma']**2 * (1.0 + p['alpha'])**3)\n\n        # For r > 0, K(r) = -c(r)/r * c'(r)\n        # c'(r) = (2*c0*alpha*r/sigma^2) * exp(-r^2/sigma^2) / (1+alpha*exp(-r^2/sigma^2))^2\n        exp_term = np.exp(-r**2 / p['sigma']**2)\n        c_r = p['c0'] / (1.0 + p['alpha'] * exp_term)\n        \n        # This is -c(r) * (c'(r)/r)\n        k_val = -(c_r) * (2.0 * p['c0'] * p['alpha'] / p['sigma']**2) * \\\n                exp_term / (1.0 + p['alpha'] * exp_term)**2\n        return k_val\n        \n\n    def ode_system(t, state, p):\n        \"\"\"\n        Defines the system of first-order ODEs for ray tracing and Jacobi field.\n        state[0]: r, distance from origin\n        state[1]: y, normal separation\n        state[2]: z = dy/dt\n        \"\"\"\n        r, y, z = state\n        \n        dr_dt = speed_c(r, p)\n        dy_dt = z\n        dz_dt = -K_coeff(r, p) * y\n        \n        return [dr_dt, dy_dt, dz_dt]\n\n    # Event function to find when y(t) = 0.\n    def caustic_event(t, state, p):\n        return state[1]  # Trigger when y=0\n    \n    caustic_event.terminal = True  # Stop integration at the first event\n    caustic_event.direction = 0  # Trigger on any zero crossing\n\n    # Initial conditions at t=0\n    r_init = 0.0\n    y_init = 0.0\n    c_at_0 = speed_c(0.0, params)\n    z_init = c_at_0\n    \n    # To find the first *positive* zero crossing, we start integration at a\n    # very small time t_start > 0.\n    t_start = 1e-8\n    \n    # Approximate initial state at t_start using Taylor expansion\n    # r(t_start) approx r(0) + dr/dt(0) * t_start = c(0) * t_start\n    # y(t_start) approx y(0) + dy/dt(0) * t_start = z(0) * t_start = c(0) * t_start\n    # z(t_start) approx z(0) + dz/dt(0) * t_start = c(0) - K(0)*y(0)*t_start = c(0)\n    r0 = c_at_0 * t_start\n    y0 = c_at_0 * t_start\n    z0 = c_at_0\n    initial_state = [r0, y0, z0]\n\n    sol = solve_ivp(\n        ode_system,\n        t_span=[t_start, Tmax],\n        y0=initial_state,\n        args=(params,),\n        events=caustic_event,\n        method='RK45',\n        dense_output=True,\n        rtol=1e-8,\n        atol=1e-8\n    )\n\n    # Check if a caustic was found\n    if sol.t_events[0].size > 0:\n        return sol.t_events[0][0]\n    else:\n        return -1.0\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3614032"}, {"introduction": "A cornerstone of applied seismology is the two-point boundary value problem: finding the specific ray or rays that connect a known source to a designated receiver. This practice challenges you to tackle this problem head-on by implementing and comparing two distinct numerical strategies. You will first develop a \"shooting\" method that uses derivative-free optimization to find the correct takeoff angle, and then a more sophisticated Newton's method that leverages variational equations to compute ray sensitivities and converge more efficiently [@problem_id:3614051]. Mastering these techniques provides a robust foundation for numerous applications, from seismic imaging and inversion to earthquake location.", "problem": "You are tasked with implementing and comparing two numerical strategies for solving a two-point seismic ray targeting problem in a two-dimensional, isotropic, smoothly varying velocity medium. The objective is to determine the source takeoff direction and travel time that cause a ray, governed by ray Ordinary Differential Equations (ODEs), to arrive at specified receiver locations. Your program must output a single list aggregating quantitative comparison metrics across multiple test cases.\n\nBegin from the following fundamental base in seismology and Hamiltonian mechanics:\n\n- Ray paths are stationary curves of traveltime according to Fermat's principle.\n- The Eikonal equation relates the traveltime field gradient to the slowness magnitude, and in an isotropic medium the Hamiltonian representation for rays can be employed.\n- In an isotropic medium with velocity field $c(\\mathbf{x})$, where $\\mathbf{x} = (x,z)$, the traveltime parameter $t$ can be used for ray parametrization. Define the horizontal and vertical components of the slowness vector as $p = \\partial T / \\partial x$ and $q = \\partial T / \\partial z$, respectively. Using a Hamiltonian $H(\\mathbf{x},\\mathbf{p}) = \\tfrac{1}{2} c(\\mathbf{x})^2 \\lVert \\mathbf{p} \\rVert^2 - \\tfrac{1}{2}$ with $\\mathbf{p} = (p,q)$, the Hamiltonian equations imply an ODE system for the state $\\mathbf{y} = (x,z,p,q)$ parameterized by traveltime $t$.\n\nYour tasks are:\n\n$1.$ Derive, from the above fundamental base and for a vertically stratified velocity $c(x,z) = c(z)$, the ray ODE system in the form $\\dfrac{d \\mathbf{y}}{dt} = \\mathbf{f}(\\mathbf{y})$ using the Hamiltonian equations with traveltime parametrization. Specialize your derivation to the linear velocity gradient model\n$$\nc(z) = c_0 + g z,\n$$\nwhere $c_0$ and $g$ are constants, $c_0 &gt; 0$, and $g \\ge 0$.\n\n$2.$ Derive the associated first-order variational (sensitivity) equations for the partial derivatives of the state with respect to the initial takeoff angle $\\theta$, where at the source depth $z = z_S$ the initial slowness vector has magnitude $1/c(z_S)$ and direction $\\theta$ measured in radians from the positive $x$-axis. Specifically, let $\\mathbf{y}_\\theta = \\partial \\mathbf{y} / \\partial \\theta$. Derive the linear time-varying system\n$$\n\\frac{d}{dt} \\mathbf{y}_\\theta = \\mathbf{A}(t) \\, \\mathbf{y}_\\theta,\n$$\nwhere $\\mathbf{A}(t) = \\dfrac{\\partial \\mathbf{f}}{\\partial \\mathbf{y}}\\big\\rvert_{\\mathbf{y}(t)}$, and provide the initial condition for $\\mathbf{y}_\\theta$ in terms of $\\theta$ and $c(z_S)$.\n\n$3.$ Implement two numerical strategies to target a receiver at position $\\mathbf{x}_R = (x_R, z_R)$ from a source at $\\mathbf{x}_S = (x_S, z_S)$:\n\n$3.1.$ Shooting method (derivative-free optimization): Formulate and numerically minimize the misfit\n$$\n\\Phi(\\theta, t_f) = \\left\\| \\mathbf{x}(\\theta, t_f) - \\mathbf{x}_R \\right\\|_2^2,\n$$\nwith respect to the takeoff angle $\\theta$ and final traveltime $t_f$, subject to the ray ODE constraints that map $(\\theta, t_f)$ to the final position $\\mathbf{x}(\\theta, t_f)$. Use a robust derivative-free method to find $(\\hat{\\theta}_{\\mathrm{shoot}}, \\hat{t}_{\\mathrm{shoot}})$ that approximately minimize $\\Phi$. Ensure that $t_f$ remains strictly positive during the search.\n\n$3.2.$ Two-point boundary Newton method: Pose the boundary-value problem as solving for $(\\theta, t_f)$ such that\n$$\n\\mathbf{F}(\\theta, t_f) = \\mathbf{x}(\\theta, t_f) - \\mathbf{x}_R = \\mathbf{0}.\n$$\nDerive and implement the Newton iteration\n$$\n\\begin{bmatrix}\n\\theta \\\\\nt_f\n\\end{bmatrix}_{k+1}\n=\n\\begin{bmatrix}\n\\theta \\\\\nt_f\n\\end{bmatrix}_{k}\n-\n\\mathbf{J}(\\theta_k, t_{f,k})^{-1}\n\\mathbf{F}(\\theta_k, t_{f,k}),\n$$\nwhere the Jacobian $\\mathbf{J} \\in \\mathbb{R}^{2 \\times 2}$ has columns $\\partial \\mathbf{x}/\\partial \\theta$ and $\\partial \\mathbf{x}/\\partial t_f$. Express the second column analytically in terms of the ray state at $t_f$ and compute the first column by integrating the variational equations from task $2$. Use a suitable step damping strategy if needed to ensure convergence.\n\n$4.$ Numerical implementation requirements:\n\n$4.1.$ Medium: Use the linear velocity model $c(z) = c_0 + g z$.\n\n$4.2.$ Units: Use meters for positions, meters per second for velocities, and seconds for time. The takeoff angle must be in radians.\n\n$4.3.$ Integration: Implement a fixed-step, explicit fourth-order Runge–Kutta method for both the ray ODE and the coupled variational equations. Ensure stability and accuracy by choosing a reasonable number of steps as a function of $t_f$.\n\n$4.4.$ Initial guesses: For both methods, use the straight-line geometric guess\n$$\n\\theta_0 = \\operatorname{atan2}(z_R - z_S, x_R - x_S), \\quad\nt_{0} = \\frac{\\sqrt{(x_R - x_S)^2 + (z_R - z_S)^2}}{\\bar{c}},\n$$\nwith $\\bar{c} = c_0 + g \\, (z_S + z_R)/2$.\n\n$5.$ Test suite and outputs:\n\nImplement your program to run the following three test cases and produce a single line of output containing a comma-separated list enclosed in square brackets with three floats per test case, in order. For each test case, produce:\n\n- The absolute difference in takeoff angles between the two methods, $|\\hat{\\theta}_{\\mathrm{shoot}} - \\hat{\\theta}_{\\mathrm{Newton}}|$ in radians.\n- The absolute difference in final traveltimes between the two methods, $|\\hat{t}_{\\mathrm{shoot}} - \\hat{t}_{\\mathrm{Newton}}|$ in seconds.\n- The final residual norm of the two-point boundary method, $\\left\\| \\mathbf{F}(\\hat{\\theta}_{\\mathrm{Newton}}, \\hat{t}_{\\mathrm{Newton}}) \\right\\|_2$ in meters.\n\nAggregate the results for all test cases into a single flat list in the order of the cases.\n\nUse the following test suite:\n\n- Case $1$ (happy path): $c_0 = 2000$ m/s, $g = 0.5$ s$^{-1}$, $\\mathbf{x}_S = (0, 0)$ m, $\\mathbf{x}_R = (3000, 1500)$ m.\n- Case $2$ (boundary case: constant velocity): $c_0 = 2000$ m/s, $g = 0.0$ s$^{-1}$, $\\mathbf{x}_S = (0, 0)$ m, $\\mathbf{x}_R = (4000, 1000)$ m.\n- Case $3$ (edge targeting with shallow depth and long range): $c_0 = 2000$ m/s, $g = 0.5$ s$^{-1}$, $\\mathbf{x}_S = (0, 0)$ m, $\\mathbf{x}_R = (6000, 500)$ m.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in this exact order:\n$[$case$1$ angle difference, case$1$ time difference, case$1$ residual, case$2$ angle difference, case$2$ time difference, case$2$ residual, case$3$ angle difference, case$3$ time difference, case$3$ residual$]$. All values must be floats in the units specified above. No additional output is permitted.", "solution": "We begin from the Eikonal equation in an isotropic medium, which in terms of the traveltime field $T(\\mathbf{x})$ states that $\\lVert \\nabla T \\rVert = 1/c(\\mathbf{x})$, where $c(\\mathbf{x})$ is the wavespeed. Introducing the slowness vector $\\mathbf{p} = \\nabla T$ with components $p = \\partial T / \\partial x$ and $q = \\partial T / \\partial z$, we adopt the Hamiltonian\n$$\nH(\\mathbf{x}, \\mathbf{p}) = \\frac{1}{2} c(\\mathbf{x})^2 \\lVert \\mathbf{p} \\rVert^2 - \\frac{1}{2},\n$$\nwhich enforces the Eikonal constraint $H = 0$ along physical rays. Parameterizing the ray by traveltime $t$, Hamilton's equations give\n$$\n\\frac{d \\mathbf{x}}{dt} = \\frac{\\partial H}{\\partial \\mathbf{p}}, \\qquad\n\\frac{d \\mathbf{p}}{dt} = - \\frac{\\partial H}{\\partial \\mathbf{x}}.\n$$\nWriting $\\mathbf{x} = (x,z)$ and $\\mathbf{p} = (p,q)$, we compute\n$$\n\\frac{dx}{dt} = \\frac{\\partial H}{\\partial p} = c(\\mathbf{x})^2 \\, p, \\qquad\n\\frac{dz}{dt} = \\frac{\\partial H}{\\partial q} = c(\\mathbf{x})^2 \\, q,\n$$\nand\n$$\n\\frac{dp}{dt} = - \\frac{\\partial H}{\\partial x} = - \\frac{1}{2} \\frac{\\partial (c^2)}{\\partial x} \\, (p^2 + q^2), \\qquad\n\\frac{dq}{dt} = - \\frac{\\partial H}{\\partial z} = - \\frac{1}{2} \\frac{\\partial (c^2)}{\\partial z} \\, (p^2 + q^2).\n$$\nFor a vertically stratified medium $c(\\mathbf{x}) = c(z)$, we have $\\partial (c^2)/\\partial x = 0$, hence\n$$\n\\frac{dp}{dt} = 0, \\qquad\n\\frac{dq}{dt} = - \\frac{1}{2} \\frac{d (c^2)}{dz} (p^2+q^2).\n$$\nSpecializing to the linear gradient model\n$$\nc(z) = c_0 + g z,\n$$\nwith $c_0 &gt; 0$ and $g \\ge 0$, we have\n$$\n\\frac{d (c^2)}{dz} = \\frac{d}{dz} \\big( (c_0 + g z)^2 \\big) = 2 (c_0 + g z) g = 2 c g.\n$$\nTherefore, the ray ODE system becomes\n$$\n\\frac{dx}{dt} = c^2 p, \\qquad\n\\frac{dz}{dt} = c^2 q, \\qquad\n\\frac{dp}{dt} = 0, \\qquad\n\\frac{dq}{dt} = - c g \\, (p^2 + q^2),\n$$\nwhere $c = c(z) = c_0 + g z$. Note that along rays $H = 0$ implies $c^2(p^2+q^2) = 1$, hence $p^2+q^2 = 1/c^2$, but we do not explicitly enforce this identity inside the ODE right-hand side to preserve a consistent variational formulation.\n\nInitial conditions at the source $\\mathbf{x}_S = (x_S, z_S)$ are defined from a takeoff angle $\\theta$ in radians measured from the positive $x$-axis. The initial slowness magnitude is $1/c(z_S)$, so\n$$\nx(0) = x_S, \\quad z(0) = z_S, \\quad p(0) = \\frac{\\cos \\theta}{c(z_S)}, \\quad q(0) = \\frac{\\sin \\theta}{c(z_S)}.\n$$\n\nFor the variational equations with respect to $\\theta$, let $\\mathbf{y} = (x,z,p,q)^\\top$ and $\\mathbf{y}_\\theta = \\partial \\mathbf{y}/\\partial \\theta$. The linearized dynamics are\n$$\n\\frac{d}{dt} \\mathbf{y}_\\theta = \\mathbf{A}(t) \\, \\mathbf{y}_\\theta,\n$$\nwhere $\\mathbf{A}(t) = \\partial \\mathbf{f} / \\partial \\mathbf{y}$ is the Jacobian matrix of the ray right-hand side evaluated along the ray. Denoting $c = c(z)$ and $c^2 = c^2(z)$,\n$$\n\\mathbf{f}(\\mathbf{y}) =\n\\begin{bmatrix}\nc^2 p \\\\\nc^2 q \\\\\n0 \\\\\n- \\tfrac{1}{2} \\, \\frac{d (c^2)}{dz} \\, (p^2 + q^2)\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nc^2 p \\\\\nc^2 q \\\\\n0 \\\\\n- c g \\, (p^2 + q^2)\n\\end{bmatrix}.\n$$\nThe Jacobian entries are computed via partial derivatives. Using $\\frac{d (c^2)}{dz} = 2 c g$ and $\\frac{d^2 (c^2)}{dz^2} = 2 g^2$, we obtain\n$$\n\\frac{\\partial f_1}{\\partial x} = 0, \\quad\n\\frac{\\partial f_1}{\\partial z} = \\frac{d (c^2)}{dz} \\, p = 2 c g \\, p, \\quad\n\\frac{\\partial f_1}{\\partial p} = c^2, \\quad\n\\frac{\\partial f_1}{\\partial q} = 0,\n$$\n$$\n\\frac{\\partial f_2}{\\partial x} = 0, \\quad\n\\frac{\\partial f_2}{\\partial z} = \\frac{d (c^2)}{dz} \\, q = 2 c g \\, q, \\quad\n\\frac{\\partial f_2}{\\partial p} = 0, \\quad\n\\frac{\\partial f_2}{\\partial q} = c^2,\n$$\n$$\n\\frac{\\partial f_3}{\\partial x} = 0, \\quad\n\\frac{\\partial f_3}{\\partial z} = 0, \\quad\n\\frac{\\partial f_3}{\\partial p} = 0, \\quad\n\\frac{\\partial f_3}{\\partial q} = 0,\n$$\n$$\n\\frac{\\partial f_4}{\\partial x} = 0, \\quad\n\\frac{\\partial f_4}{\\partial z} = - \\frac{1}{2} \\frac{d^2 (c^2)}{dz^2} (p^2 + q^2) = - g^2 (p^2 + q^2), \\quad\n\\frac{\\partial f_4}{\\partial p} = - \\frac{d (c^2)}{dz} \\, p = - 2 c g \\, p, \\quad\n\\frac{\\partial f_4}{\\partial q} = - \\frac{d (c^2)}{dz} \\, q = - 2 c g \\, q.\n$$\nThus $\\mathbf{A}(t)$ is the $4 \\times 4$ matrix with these entries filled in.\n\nThe initial condition for the variational state $\\mathbf{y}_\\theta$ follows by differentiating the initial state with respect to $\\theta$:\n$$\n\\left. \\frac{\\partial x}{\\partial \\theta} \\right|_{t=0} = 0, \\quad\n\\left. \\frac{\\partial z}{\\partial \\theta} \\right|_{t=0} = 0, \\quad\n\\left. \\frac{\\partial p}{\\partial \\theta} \\right|_{t=0} = - \\frac{\\sin \\theta}{c(z_S)}, \\quad\n\\left. \\frac{\\partial q}{\\partial \\theta} \\right|_{t=0} = \\frac{\\cos \\theta}{c(z_S)}.\n$$\n\nWe now outline the two numerical strategies.\n\nFor the shooting method, we define a misfit function\n$$\n\\Phi(\\theta, t_f) = \\left\\| \\mathbf{x}(\\theta, t_f) - \\mathbf{x}_R \\right\\|_2^2,\n$$\nwhere $\\mathbf{x}(\\theta, t_f)$ is obtained by integrating the ray ODE from $t = 0$ to $t = t_f$ with initial conditions set by $\\theta$. A derivative-free search over $(\\theta, t_f)$ is employed to minimize $\\Phi$, enforcing $t_f &gt; 0$ by penalization. Robustness is enhanced via a reasonable initial guess and bounds for $t_f$.\n\nFor the two-point boundary Newton method, we solve $\\mathbf{F}(\\theta, t_f) = \\mathbf{x}(\\theta, t_f) - \\mathbf{x}_R = \\mathbf{0}$. The Newton step is\n$$\n\\begin{bmatrix}\n\\delta \\theta \\\\\n\\delta t_f\n\\end{bmatrix}\n=\n\\mathbf{J}(\\theta, t_f)^{-1}\n\\left( - \\mathbf{F}(\\theta, t_f) \\right),\n$$\nwith updates $(\\theta, t_f) \\leftarrow (\\theta, t_f) + \\alpha \\, (\\delta \\theta, \\delta t_f)$ using a damping factor $\\alpha \\in (0,1]$ chosen by backtracking to decrease $\\lVert \\mathbf{F} \\rVert_2$. The Jacobian columns are\n$$\n\\frac{\\partial \\mathbf{x}}{\\partial \\theta} (t_f) = \\begin{bmatrix} \\partial x / \\partial \\theta \\\\ \\partial z / \\partial \\theta \\end{bmatrix}(t_f),\n\\quad\n\\frac{\\partial \\mathbf{x}}{\\partial t_f} (t_f) = \\frac{d \\mathbf{x}}{dt} (t_f) = \\begin{bmatrix} c(t_f)^2 p(t_f) \\\\ c(t_f)^2 q(t_f) \\end{bmatrix}.\n$$\nThe first column is computed by integrating the variational equations simultaneously with the ray ODE, starting from the initial condition given above. The second column is the ray velocity at time $t_f$.\n\nFor numerical integration, we apply a fixed-step, explicit fourth-order Runge–Kutta scheme to both the ray state and the variational state. Accuracy is controlled by selecting a number of steps proportional to $t_f$ and enforcing a minimum number of steps.\n\nWe adopt straight-line initial guesses\n$$\n\\theta_0 = \\operatorname{atan2}(z_R - z_S, x_R - x_S), \\quad\nt_0 = \\frac{\\sqrt{(x_R - x_S)^2 + (z_R - z_S)^2}}{\\bar{c}},\n\\quad \\bar{c} = c_0 + g \\, \\frac{z_S + z_R}{2},\n$$\nwhich are reasonable for smoothly varying media.\n\nThe output per test case consists of the absolute difference in angles $|\\hat{\\theta}_{\\mathrm{shoot}} - \\hat{\\theta}_{\\mathrm{Newton}}|$ (radians), the absolute difference in times $|\\hat{t}_{\\mathrm{shoot}} - \\hat{t}_{\\mathrm{Newton}}|$ (seconds), and the final Newton residual $\\lVert \\mathbf{F}(\\hat{\\theta}_{\\mathrm{Newton}}, \\hat{t}_{\\mathrm{Newton}}) \\rVert_2$ (meters). For the constant-velocity case with $g = 0$, the ray is a straight line; thus the two methods should agree to within numerical tolerance, yielding very small differences and residual.\n\nFinally, we implement the three test cases:\n\n- Case $1$: $c_0 = 2000$ m/s, $g = 0.5$ s$^{-1}$, $\\mathbf{x}_S = (0,0)$ m, $\\mathbf{x}_R = (3000,1500)$ m.\n- Case $2$: $c_0 = 2000$ m/s, $g = 0.0$ s$^{-1}$, $\\mathbf{x}_S = (0,0)$ m, $\\mathbf{x}_R = (4000,1000)$ m.\n- Case $3$: $c_0 = 2000$ m/s, $g = 0.5$ s$^{-1}$, $\\mathbf{x}_S = (0,0)$ m, $\\mathbf{x}_R = (6000,500)$ m.\n\nA robust implementation with adequate step resolution and damping in Newton updates produces small discrepancies between methods and near-zero residuals for all three cases. The program produces a single line with the $9$ floats aggregated in order as specified.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import minimize\n\n# Ray ODEs in 2D isotropic medium with linear vertical velocity gradient c(z) = c0 + g*z.\n# State y = [x, z, p, q], where p=Tx, q=Tz are slowness components. Parametrized by traveltime t.\n\ndef c_and_derivs(z, c0, g):\n    c = c0 + g * z\n    c2 = c * c\n    dc2_dz = 2.0 * c * g\n    d2c2_dz2 = 2.0 * g * g\n    return c, c2, dc2_dz, d2c2_dz2\n\ndef ray_rhs(y, c0, g):\n    x, z, p, q = y\n    c, c2, dc2_dz, _ = c_and_derivs(z, c0, g)\n    dxdt = c2 * p\n    dzdt = c2 * q\n    dpdt = 0.0\n    dqdt = -0.5 * dc2_dz * (p*p + q*q)  # = -c*g*(p^2+q^2)\n    return np.array([dxdt, dzdt, dpdt, dqdt], dtype=float)\n\ndef jacobian_A(y, c0, g):\n    # Jacobian of ray_rhs with respect to state y = [x,z,p,q]\n    x, z, p, q = y\n    c, c2, dc2_dz, d2c2_dz2 = c_and_derivs(z, c0, g)\n    # Initialize 4x4 zero matrix\n    A = np.zeros((4,4), dtype=float)\n    # df1/dz = (dc2/dz)*p, df1/dp = c2\n    A[0,1] = dc2_dz * p\n    A[0,2] = c2\n    # df2/dz = (dc2/dz)*q, df2/dq = c2\n    A[1,1] = dc2_dz * q\n    A[1,3] = c2\n    # df3 all zeros\n    # df4/dz = -0.5 * d2c2/dz2 * (p^2+q^2)\n    A[3,1] = -0.5 * d2c2_dz2 * (p*p + q*q)\n    # df4/dp = - (dc2/dz) * p\n    A[3,2] = - dc2_dz * p\n    # df4/dq = - (dc2/dz) * q\n    A[3,3] = - dc2_dz * q\n    return A\n\ndef rk4_step(y, dt, func, *fargs):\n    k1 = func(y, *fargs)\n    k2 = func(y + 0.5*dt*k1, *fargs)\n    k3 = func(y + 0.5*dt*k2, *fargs)\n    k4 = func(y + dt*k3, *fargs)\n    return y + (dt/6.0)*(k1 + 2*k2 + 2*k3 + k4)\n\ndef integrate_ray(theta, tf, c0, g, xS, zS, with_sensitivity=False):\n    # Initial conditions\n    cS = c0 + g * zS\n    p0 = np.cos(theta) / cS\n    q0 = np.sin(theta) / cS\n    y = np.array([xS, zS, p0, q0], dtype=float)\n\n    # Sensitivity initial condition dy/dtheta at t=0\n    if with_sensitivity:\n        dxdth = 0.0\n        dzdth = 0.0\n        dpdth = -np.sin(theta) / cS\n        dqdth =  np.cos(theta) / cS\n        Yth = np.array([dxdth, dzdth, dpdth, dqdth], dtype=float)\n    else:\n        Yth = None\n\n    # Time stepping\n    t_end = tf\n    # Ensure minimum steps for stability and accuracy\n    nsteps = max(400, int(np.ceil(200.0 * t_end))) if t_end > 0 else 400\n    dt = t_end / nsteps if nsteps > 0 else 0.0\n\n    if dt == 0.0:\n        if with_sensitivity:\n            return y, Yth\n        else:\n            return y\n\n    for _ in range(nsteps):\n        # Standard RK4 for state\n        y = rk4_step(y, dt, ray_rhs, c0, g)\n        if with_sensitivity:\n            # Variational equation: dYth/dt = A(t) * Yth\n            def var_rhs(Y, c0_, g_):\n                A = jacobian_A(y, c0_, g_)\n                return A @ Y\n            Yth = rk4_step(Yth, dt, var_rhs, c0, g)\n\n    if with_sensitivity:\n        return y, Yth\n    else:\n        return y\n\ndef straight_line_guess(xS, zS, xR, zR, c0, g):\n    dx = xR - xS\n    dz = zR - zS\n    theta0 = np.arctan2(dz, dx)\n    dist = np.hypot(dx, dz)\n    cbar = c0 + g * 0.5 * (zS + zR)\n    # Prevent division by zero\n    cbar = max(cbar, 1e-6)\n    t0 = dist / cbar\n    # Ensure positive time\n    t0 = max(t0, 1e-3)\n    return theta0, t0\n\ndef shooting_method(xS, zS, xR, zR, c0, g):\n    theta0, t0 = straight_line_guess(xS, zS, xR, zR, c0, g)\n\n    def phi(vars_):\n        th, tf = vars_\n        # Penalize non-positive time\n        if tf <= 0.0 or tf > 50.0:\n            return 1e20 + (abs(tf) + 1.0) * 1e20\n        y = integrate_ray(th, tf, c0, g, xS, zS, with_sensitivity=False)\n        xr, zr = y[0], y[1]\n        dx = xr - xR\n        dz = zr - zR\n        return dx*dx + dz*dz\n\n    x0 = np.array([theta0, t0], dtype=float)\n    res = minimize(phi, x0, method='Nelder-Mead', options=dict(maxiter=400, xatol=1e-8, fatol=1e-12, disp=False))\n    th_opt, tf_opt = res.x\n    # Clamp final time\n    tf_opt = max(tf_opt, 1e-6)\n    return th_opt, tf_opt\n\ndef newton_two_point(xS, zS, xR, zR, c0, g, max_iter=30, tol=1e-8):\n    theta, tf = straight_line_guess(xS, zS, xR, zR, c0, g)\n    # Newton iterations with backtracking\n    for _ in range(max_iter):\n        # Integrate ray and sensitivity\n        y, Yth = integrate_ray(theta, tf, c0, g, xS, zS, with_sensitivity=True)\n        x_tf, z_tf, p_tf, q_tf = y\n        # Residual F = x(tf) - xR, z(tf) - zR\n        F = np.array([x_tf - xR, z_tf - zR], dtype=float)\n        res_norm = np.linalg.norm(F)\n        if res_norm < tol:\n            return theta, tf, res_norm\n        # Jacobian columns\n        # Column 1: d x / d theta, d z / d theta from Yth\n        J_col1 = np.array([Yth[0], Yth[1]], dtype=float)\n        # Column 2: d x / d tf = dx/dt, d z / d tf = dz/dt\n        c_tf, c2_tf, _, _ = c_and_derivs(z_tf, c0, g)\n        J_col2 = np.array([c2_tf * p_tf, c2_tf * q_tf], dtype=float)\n        J = np.column_stack([J_col1, J_col2])\n\n        # Solve for Newton step via least squares (in case of near-singularity)\n        try:\n            delta, *_ = np.linalg.lstsq(J, -F, rcond=None)\n        except np.linalg.LinAlgError:\n            # Fallback small perturbation\n            delta = np.array([0.0, 0.0])\n\n        dtheta, dtf = delta\n\n        # Backtracking line search\n        alpha = 1.0\n        improved = False\n        for _ls in range(12):\n            th_try = theta + alpha * dtheta\n            tf_try = tf + alpha * dtf\n            if tf_try <= 0.0:\n                alpha *= 0.5\n                continue\n            y_try = integrate_ray(th_try, tf_try, c0, g, xS, zS, with_sensitivity=False)\n            F_try = np.array([y_try[0] - xR, y_try[1] - zR], dtype=float)\n            if np.linalg.norm(F_try) < res_norm:\n                theta = th_try\n                tf = tf_try\n                improved = True\n                break\n            alpha *= 0.5\n        if not improved:\n            # Could not improve; terminate\n            break\n    # Final residual\n    y = integrate_ray(theta, tf, c0, g, xS, zS, with_sensitivity=False)\n    F = np.array([y[0] - xR, y[1] - zR], dtype=float)\n    res_norm = np.linalg.norm(F)\n    return theta, tf, res_norm\n\ndef run_case(c0, g, xS, zS, xR, zR):\n    # Shooting method\n    th_shoot, tf_shoot = shooting_method(xS, zS, xR, zR, c0, g)\n    # Newton two-point boundary method\n    th_newt, tf_newt, res_newt = newton_two_point(xS, zS, xR, zR, c0, g)\n\n    dtheta = abs(th_shoot - th_newt)\n    dt = abs(tf_shoot - tf_newt)\n    return float(dtheta), float(dt), float(res_newt)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Case 1: c0=2000 m/s, g=0.5 s^-1, S=(0,0) m, R=(3000,1500) m\n    # Case 2: c0=2000 m/s, g=0.0 s^-1, S=(0,0) m, R=(4000,1000) m\n    # Case 3: c0=2000 m/s, g=0.5 s^-1, S=(0,0) m, R=(6000,500) m\n    test_cases = [\n        (2000.0, 0.5, 0.0, 0.0, 3000.0, 1500.0),\n        (2000.0, 0.0, 0.0, 0.0, 4000.0, 1000.0),\n        (2000.0, 0.5, 0.0, 0.0, 6000.0, 500.0),\n    ]\n\n    results = []\n    for c0, g, xS, zS, xR, zR in test_cases:\n        dtheta, dt, res = run_case(c0, g, xS, zS, xR, zR)\n        results.extend([dtheta, dt, res])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3614051"}]}