{"hands_on_practices": [{"introduction": "The reliability of any Full-Waveform Inversion (FWI) result is fundamentally limited by the accuracy of the underlying wave equation solver. When we discretize the continuous wave equation onto a numerical grid, we inevitably introduce errors, the most prominent of which is numerical dispersion. This exercise [@problem_id:3611622] provides essential hands-on practice in analyzing and quantifying this dispersion for an anisotropic wave equation, allowing you to derive the conditions needed to keep simulation errors below a specified tolerance. Mastering this analysis is a cornerstone of developing and validating high-fidelity wave propagation codes for FWI.", "problem": "Consider two-dimensional Vertical Transverse Isotropy (VTI) in the elliptical-anisotropy limit where the Thomsen parameters satisfy $\\delta = \\epsilon$. In this limit, the acoustic quasi-compressional (qP) wavefield $u(x,z,t)$ is governed by the constant-coefficient anisotropic acoustic wave equation\n$$\n\\frac{\\partial^{2} u}{\\partial t^{2}} \\;=\\; v_{x}^{2}\\,\\frac{\\partial^{2} u}{\\partial x^{2}} \\;+\\; v_{z}^{2}\\,\\frac{\\partial^{2} u}{\\partial z^{2}},\n$$\nwhere $v_{z} = v_{P0}$ is the vertical phase velocity and $v_{x} = v_{P0}\\sqrt{1+2\\epsilon}$ is the horizontal phase velocity. This model is widely used to design wave-equation solvers for multiparameter and anisotropic Full-Waveform Inversion (FWI).\n\nYou discretize this equation on a uniform square grid with spacing $\\Delta x = \\Delta z = h$ and a uniform time step $\\Delta t$, using second-order centered finite differences in both time and space. Let the time step be chosen to saturate the Courant–Friedrichs–Lewy (CFL) stability limit for this scheme. You will:\n\n1. Derive the discrete dispersion relation by substituting a plane-wave ansatz $u = \\exp\\!\\big(i(k_{x} x + k_{z} z - \\omega t)\\big)$ into the finite-difference scheme. Express the result in terms of $r_{x} = v_{x}\\Delta t/h$, $r_{z} = v_{z}\\Delta t/h$, $\\kappa_{x} = k_{x} h/2$, and $\\kappa_{z} = k_{z} h/2$.\n\n2. Using a small-wavenumber expansion (i.e., $|\\kappa_{x}| \\ll 1$, $|\\kappa_{z}| \\ll 1$), obtain the leading-order expression for the relative phase-velocity error $e(\\theta)$, where the propagation angle $\\theta \\in [0,\\pi/2]$ (radians) is defined by $k_{x} = k\\cos\\theta$ and $k_{z} = k\\sin\\theta$, and $k = \\sqrt{k_{x}^{2}+k_{z}^{2}}$. Your expression must make explicit the dependence on $h$, the maximum angular frequency $\\omega_{\\max}$ (equivalently, maximum frequency $f_{\\max} = \\omega_{\\max}/(2\\pi)$), and the anisotropic velocities $v_{x}$ and $v_{z}$.\n\n3. Under the CFL-saturating choice of $\\Delta t$ for the second-order finite-difference scheme, determine the maximum allowable grid spacing $h$ that guarantees the worst-case relative phase-velocity error over all $\\theta \\in [0,\\pi/2]$ does not exceed a prescribed tolerance $\\tau$. Provide a closed-form formula for $h$ as a function of $f_{\\max}$, $v_{x}$, $v_{z}$, and $\\tau$.\n\nFinally, consider the design parameters\n- $v_{P0} = 2500$ m/s,\n- $\\epsilon = 0.2$ (hence $\\delta = \\epsilon$),\n- $f_{\\max} = 30$ Hz,\n- tolerance $\\tau = 0.01$,\nand compute the numerical value of the maximum admissible grid spacing $h$ in meters. Round your answer to four significant figures. Express the final $h$ in meters.", "solution": "We begin from the constant-coefficient anisotropic acoustic wave equation\n$$\n\\frac{\\partial^{2} u}{\\partial t^{2}} \\;=\\; v_{x}^{2}\\,\\frac{\\partial^{2} u}{\\partial x^{2}} \\;+\\; v_{z}^{2}\\,\\frac{\\partial^{2} u}{\\partial z^{2}}.\n$$\nFor elliptical Vertical Transverse Isotropy (VTI) with $\\delta = \\epsilon$, the horizontal and vertical phase velocities satisfy $v_{x} = v_{P0}\\sqrt{1+2\\epsilon}$ and $v_{z} = v_{P0}$.\n\nWe discretize with second-order central differences in time and space on a uniform square grid $\\Delta x = \\Delta z = h$ and time step $\\Delta t$. The finite-difference (FD) scheme at grid point $(i,j)$ and time level $n$ is\n$$\n\\frac{u_{i,j}^{n+1} - 2 u_{i,j}^{n} + u_{i,j}^{n-1}}{\\Delta t^{2}}\n\\;=\\;\nv_{x}^{2}\\,\\frac{u_{i+1,j}^{n} - 2 u_{i,j}^{n} + u_{i-1,j}^{n}}{h^{2}}\n\\;+\\;\nv_{z}^{2}\\,\\frac{u_{i,j+1}^{n} - 2 u_{i,j}^{n} + u_{i,j-1}^{n}}{h^{2}}.\n$$\n\nDerivation of the discrete dispersion relation. Substitute a plane wave $u_{i,j}^{n} = \\exp\\!\\big(i(k_{x} i h + k_{z} j h - \\omega n \\Delta t)\\big)$ into the scheme. The standard algebra yields\n$$\n\\frac{\\exp(-i\\omega\\Delta t) - 2 + \\exp(i\\omega\\Delta t)}{\\Delta t^{2}}\n\\;=\\;\nv_{x}^{2}\\,\\frac{\\exp(i k_{x} h) - 2 + \\exp(-i k_{x} h)}{h^{2}}\n\\;+\\;\nv_{z}^{2}\\,\\frac{\\exp(i k_{z} h) - 2 + \\exp(-i k_{z} h)}{h^{2}}.\n$$\nUsing $\\exp(i\\phi) - 2 + \\exp(-i\\phi) = -4 \\sin^{2}(\\phi/2)$, we obtain\n$$\n\\frac{-4 \\sin^{2}(\\omega \\Delta t/2)}{\\Delta t^{2}}\n\\;=\\;\nv_{x}^{2}\\,\\frac{-4 \\sin^{2}(k_{x} h/2)}{h^{2}}\n\\;+\\;\nv_{z}^{2}\\,\\frac{-4 \\sin^{2}(k_{z} h/2)}{h^{2}}.\n$$\nCanceling the common factor $-4$ and defining $r_{x} = v_{x}\\Delta t/h$, $r_{z} = v_{z}\\Delta t/h$, $\\kappa_{x} = k_{x} h/2$, and $\\kappa_{z} = k_{z} h/2$, the discrete dispersion relation is\n$$\n\\sin^{2}\\!\\left(\\frac{\\omega \\Delta t}{2}\\right)\n\\;=\\;\nr_{x}^{2}\\,\\sin^{2}(\\kappa_{x})\n\\;+\\;\nr_{z}^{2}\\,\\sin^{2}(\\kappa_{z}).\n$$\n\nSmall-wavenumber expansion and phase-velocity error. For small $|\\kappa_{x}|,|\\kappa_{z}|$, use $\\sin(\\xi) = \\xi - \\xi^{3}/6 + \\mathcal{O}(\\xi^{5})$ to obtain\n$$\n\\sin^{2}\\!\\left(\\frac{\\omega \\Delta t}{2}\\right)\n=\n\\left(\\frac{\\omega \\Delta t}{2}\\right)^{2}\n- \\frac{1}{3}\\left(\\frac{\\omega \\Delta t}{2}\\right)^{4}\n+ \\mathcal{O}\\!\\left((\\omega \\Delta t)^{6}\\right),\n$$\n$$\n\\sin^{2}(\\kappa_{x})\n=\n\\kappa_{x}^{2} - \\frac{\\kappa_{x}^{4}}{3} + \\mathcal{O}(\\kappa_{x}^{6}),\n\\qquad\n\\sin^{2}(\\kappa_{z})\n=\n\\kappa_{z}^{2} - \\frac{\\kappa_{z}^{4}}{3} + \\mathcal{O}(\\kappa_{z}^{6}).\n$$\nLet $k = \\sqrt{k_{x}^{2} + k_{z}^{2}}$ and define the propagation angle $\\theta$ by $k_{x} = k \\cos\\theta$, $k_{z} = k \\sin\\theta$, with $\\theta \\in [0,\\pi/2]$. Define\n$$\nA(\\theta) = v_{x}^{2}\\cos^{2}\\theta + v_{z}^{2}\\sin^{2}\\theta,\n\\qquad\nB(\\theta) = v_{x}^{2}\\cos^{4}\\theta + v_{z}^{2}\\sin^{4}\\theta.\n$$\nMatching orders in the expanded dispersion relation gives the leading frequency correction\n$$\n\\omega^{2} = k^{2} A(\\theta) + \\delta(\\theta),\n\\qquad\n\\delta(\\theta) \\approx \\frac{\\Delta t^{2}}{12}\\,k^{4} A(\\theta)^{2} - \\frac{h^{2}}{12}\\,k^{4} B(\\theta),\n$$\nwhere we have neglected terms of higher than fourth order in $k$. The numerical phase velocity is $c_{\\mathrm{num}}(\\theta) = \\omega/k$. Expanding $\\omega = k \\sqrt{A + \\delta/k^{2}}$ to first order in $\\delta$ yields\n$$\nc_{\\mathrm{num}}(\\theta) \\approx \\sqrt{A(\\theta)}\\left[1 + \\frac{1}{2}\\frac{\\delta(\\theta)}{k^{2}A(\\theta)}\\right].\n$$\nHence the leading-order relative phase-velocity error $e(\\theta)$ is\n$$\ne(\\theta) \\equiv \\frac{c_{\\mathrm{num}}(\\theta) - \\sqrt{A(\\theta)}}{\\sqrt{A(\\theta)}}\n\\;\\approx\\;\n\\frac{1}{24}\\,k^{2}\\left[\\Delta t^{2} A(\\theta) - \\frac{h^{2} B(\\theta)}{A(\\theta)}\\right].\n$$\n\nCFL choice and worst-case error over angles. For the second-order scheme on a square grid, the Courant–Friedrichs–Lewy (CFL) stability limit is $r_{x}^{2} + r_{z}^{2} \\leq 1$, i.e.,\n$$\n\\frac{v_{x}^{2}\\Delta t^{2}}{h^{2}} + \\frac{v_{z}^{2}\\Delta t^{2}}{h^{2}} \\;\\leq\\; 1\n\\;\\;\\Rightarrow\\;\\;\n\\Delta t^{2} = \\frac{h^{2}}{v_{x}^{2} + v_{z}^{2}}\n$$\nwhen saturating the bound. Substituting this into the error expression gives\n$$\ne(\\theta) \\approx \\frac{1}{24}\\,k^{2} h^{2}\\left[\\frac{A(\\theta)}{v_{x}^{2} + v_{z}^{2}} - \\frac{B(\\theta)}{A(\\theta)}\\right].\n$$\nFor a given angular frequency $\\omega$ (or frequency $f$), the wavenumber is $k(\\theta) = \\omega/\\sqrt{A(\\theta)} = 2\\pi f/\\sqrt{A(\\theta)}$. Therefore,\n$$\ne(\\theta) \\approx \\frac{h^{2}}{24}\\left(\\frac{2\\pi f}{\\sqrt{A(\\theta)}}\\right)^{2}\n\\left[\\frac{A(\\theta)}{v_{x}^{2} + v_{z}^{2}} - \\frac{B(\\theta)}{A(\\theta)}\\right]\n=\n\\frac{h^{2}(2\\pi f)^{2}}{24}\\left[\\frac{1}{v_{x}^{2} + v_{z}^{2}} - \\frac{B(\\theta)}{A(\\theta)^{2}}\\right].\n$$\nDefine $S = v_{x}^{2} + v_{z}^{2}$ and\n$$\nQ(\\theta) = \\frac{B(\\theta)}{A(\\theta)^{2}}\n=\n\\frac{v_{x}^{2}\\cos^{4}\\theta + v_{z}^{2}\\sin^{4}\\theta}{\\big(v_{x}^{2}\\cos^{2}\\theta + v_{z}^{2}\\sin^{2}\\theta\\big)^{2}}.\n$$\nThen\n$$\ne(\\theta) \\approx \\frac{h^{2}(2\\pi f)^{2}}{24}\\,\\bigg[\\frac{1}{S} - Q(\\theta)\\bigg].\n$$\nTo guarantee $|e(\\theta)| \\le \\tau$ for all $\\theta \\in [0,\\pi/2]$ at $f = f_{\\max}$, we require\n$$\n\\frac{h^{2}(2\\pi f_{\\max})^{2}}{24}\\,\\sup_{\\theta \\in [0,\\pi/2]}\\bigg|\\,\\frac{1}{S} - Q(\\theta)\\,\\bigg| \\;\\le\\; \\tau.\n$$\nIt remains to compute $D \\equiv \\sup_{\\theta} |\\,1/S - Q(\\theta)\\,|$. Parameterize by $u = \\cos^{2}\\theta \\in [0,1]$, so\n$$\nA(u) = v_{x}^{2} u + v_{z}^{2} (1-u),\\qquad\nB(u) = v_{x}^{2} u^{2} + v_{z}^{2} (1-u)^{2},\\qquad\nQ(u) = \\frac{B(u)}{A(u)^{2}}.\n$$\nA straightforward derivative test shows that $Q(u)$ has a unique interior critical point at $u = 1/2$, with\n$$\nQ\\!\\left(\\tfrac{1}{2}\\right) = \\frac{1}{v_{x}^{2} + v_{z}^{2}} = \\frac{1}{S},\n$$\nand endpoint values $Q(0) = 1/v_{z}^{2}$ and $Q(1) = 1/v_{x}^{2}$. Therefore,\n$$\n\\inf_{\\theta} Q(\\theta) = \\frac{1}{S},\n\\qquad\n\\sup_{\\theta} Q(\\theta) = \\frac{1}{\\min(v_{x}^{2},v_{z}^{2})}.\n$$\nAssuming $v_{x} \\ge v_{z}$ (the typical case for positive $\\epsilon$), we have $\\sup_{\\theta} Q(\\theta) = 1/v_{z}^{2}$. Hence\n$$\n\\sup_{\\theta}\\bigg|\\,\\frac{1}{S} - Q(\\theta)\\,\\bigg|\n=\n\\max\\!\\left(\\frac{1}{S} - \\frac{1}{S},\\,\\frac{1}{v_{z}^{2}} - \\frac{1}{S}\\right)\n=\n\\frac{v_{x}^{2}}{v_{z}^{2}\\,S}.\n$$\nThus, the worst-case bound is attained at $\\theta = \\pi/2$ (vertical propagation), and the maximum admissible grid spacing satisfying $|e(\\theta)| \\le \\tau$ for all $\\theta$ is\n$$\nh_{\\max}\n=\n\\sqrt{\\frac{24\\,\\tau}{(2\\pi f_{\\max})^{2}}\\,\\frac{1}{D}}\n=\n\\sqrt{\\frac{24\\,\\tau}{(2\\pi f_{\\max})^{2}}\\,\\frac{v_{z}^{2}\\,S}{v_{x}^{2}}}\n=\n\\sqrt{\\frac{24\\,\\tau\\,v_{z}^{2}\\,(v_{x}^{2}+v_{z}^{2})}{(2\\pi f_{\\max})^{2}\\,v_{x}^{2}}}.\n$$\n\nNumerical evaluation. With the given values $v_{P0} = 2500$ m/s, $\\epsilon = 0.2$ (so $\\delta=\\epsilon$), we have\n$$\nv_{z} = v_{P0} = 2500,\\qquad\nv_{x} = v_{P0}\\sqrt{1+2\\epsilon} = 2500\\,\\sqrt{1.4},\n$$\nso\n$$\nv_{z}^{2} = 6.25\\times 10^{6},\\qquad\nv_{x}^{2} = 1.4\\,v_{z}^{2} = 8.75\\times 10^{6},\\qquad\nS = v_{x}^{2} + v_{z}^{2} = 1.5\\times 10^{7}.\n$$\nWith $f_{\\max} = 30$ and $\\tau = 0.01$, we obtain\n$$\nh_{\\max}\n=\n\\sqrt{\\frac{24\\,(0.01)\\,(6.25\\times 10^{6})\\,(1.5\\times 10^{7})}{\\big(2\\pi\\cdot 30\\big)^{2}\\,(8.75\\times 10^{6})}}.\n$$\nUsing the compact expression derived earlier,\n$$\nD = \\frac{v_{x}^{2}}{v_{z}^{2}\\,S}\n=\n\\frac{8.75\\times 10^{6}}{(6.25\\times 10^{6})(1.5\\times 10^{7})}\n=\n9.333333333\\times 10^{-8}.\n$$\nThus\n$$\nh_{\\max} = \\sqrt{\\frac{0.24}{(2\\pi\\cdot 30)^{2}\\,(9.333333333\\times 10^{-8})}}\n=\n\\sqrt{\\frac{0.24}{3600\\pi^{2}\\cdot 9.333333333\\times 10^{-8}}}\n\\approx \\sqrt{72.372274}\n\\approx 8.507.\n$$\nRounding to four significant figures and expressing in meters, the maximum admissible grid spacing is $8.507$ m.", "answer": "$$\\boxed{8.507}$$", "id": "3611622"}, {"introduction": "With an accurate forward model in hand, we can turn our attention to the inverse problem: estimating model parameters from data. A central challenge in multiparameter FWI is 'cross-talk,' where the effects of different physical parameters on the data are non-unique. This practice [@problem_id:3611639] offers a concrete look at this issue by asking you to linearize the travel time equation and build sensitivity kernels. You will investigate a classic ambiguity in seismic imaging—distinguishing the signature of anisotropy from that of an incorrect subsurface geometry—and use a least-squares inversion to see how these effects can be disentangled.", "problem": "Consider a two-dimensional, homogeneous, vertically transversely isotropic (VTI) acoustic medium with weak anisotropy and a single source located at depth $z_s$ and a set of receivers located at depth $z_r$. Assume that the medium has a background isotropic $P$-wave velocity $v_0$ and a single Thomsen anisotropy parameter $\\delta$ (delta). Under the high-frequency (ray-based) approximation, the phase arrival time $t$ between a source and a receiver is given by the line integral of the slowness along the ray path. For a homogeneous medium under straight-ray kinematics, the travel time reduces to a path-length scaling by an angle-dependent phase velocity.\n\nUse the weak-anisotropy approximation for the $P$-wave phase velocity in a VTI medium,\n$$\nv(\\theta,\\delta) \\approx v_0 \\left(1 + A(\\theta)\\,\\delta\\right),\n$$\nwhere $\\theta$ is the angle between the ray and the symmetry axis (vertical), and\n$$\nA(\\theta) = \\sin^2\\theta\\,\\cos^2\\theta = \\tfrac{1}{4}\\sin^2(2\\theta).\n$$\nLet the horizontal source-receiver offset be $x \\ge 0$, and denote $\\Delta x = x_r - x_s$ and $\\Delta z = z_r - z_s$. The straight-line path length is\n$$\n\\ell = \\sqrt{(\\Delta x)^2 + (\\Delta z)^2},\n$$\nand the angle with respect to the vertical is\n$$\n\\theta = \\operatorname{arctan2}\\left(|\\Delta x|,|\\Delta z|\\right).\n$$\nThe modeled travel time is\n$$\nt_{\\text{model}} = \\frac{\\ell_{\\text{model}}}{v(\\theta_{\\text{model}},\\delta_{\\text{model}})} = \\frac{\\ell_{\\text{model}}}{v_0\\left(1 + A(\\theta_{\\text{model}})\\,\\delta_{\\text{model}}\\right)}.\n$$\nThe true travel time is\n$$\nt_{\\text{true}} = \\frac{\\ell_{\\text{true}}}{v(\\theta_{\\text{true}},\\delta_{\\text{true}})} = \\frac{\\ell_{\\text{true}}}{v_0\\left(1 + A(\\theta_{\\text{true}})\\,\\delta_{\\text{true}}\\right)},\n$$\nwhere the true receiver depth includes a geometry error $\\Delta z_r$ such that $z_{r,\\text{true}} = z_{r,\\text{model}} + \\Delta z_r$, while the source depth is assumed known and fixed. The measurable phase residual is\n$$\n\\Delta t(x) = t_{\\text{true}}(x) - t_{\\text{model}}(x).\n$$\n\nThe task is to perform a linearized sensitivity analysis to attribute small phase residuals $\\Delta t(x)$ to errors in anisotropy versus geometry. Specifically, linearize the residual around the modeled parameters and express\n$$\n\\Delta t(x) \\approx K_\\delta(x)\\,\\Delta\\delta + K_{\\text{geo}}(x)\\,\\Delta z_r,\n$$\nwhere $\\Delta\\delta = \\delta_{\\text{true}} - \\delta_{\\text{model}}$ and $\\Delta z_r$ is the receiver depth error. Derive expressions for the sensitivity kernels $K_\\delta(x)$ and $K_{\\text{geo}}(x)$ based on the definitions above and the chain rule:\n- The anisotropy kernel $K_\\delta(x) = \\frac{\\partial t}{\\partial \\delta}\\big|_{\\text{model}}$ must be derived from the explicit dependence of $v(\\theta,\\delta)$ on $\\delta$.\n- The geometry kernel $K_{\\text{geo}}(x) = \\frac{\\partial t}{\\partial z_r}\\big|_{\\text{model}}$ must include both the path-length sensitivity through $\\ell$ and the anisotropy-induced angle sensitivity through $\\theta$. You must account for the derivatives\n$$\n\\frac{\\partial \\ell}{\\partial z_r} = \\frac{\\Delta z}{\\ell}, \\quad \\frac{\\partial \\theta}{\\partial z_r} = -\\frac{\\Delta x}{(\\Delta x)^2 + (\\Delta z)^2}, \\quad \\frac{\\partial A}{\\partial \\theta} = \\tfrac{1}{2}\\sin(4\\theta).\n$$\nWork in radians for angles.\n\nImplement a program that:\n1. Computes the modeled kernels $K_\\delta(x)$ and $K_{\\text{geo}}(x)$ at the modeled parameters for a provided set of offsets $x$.\n2. Generates synthetic \"measured\" phase residuals $\\Delta t(x)$ using the true parameters $(\\delta_{\\text{true}}, z_{r,\\text{true}})$ and the modeled parameters $(\\delta_{\\text{model}}, z_{r,\\text{model}})$.\n3. Solves for the least-squares estimates of $(\\Delta\\delta, \\Delta z_r)$ using the linear system formed by the kernels and the residuals.\n4. Reports, for each test case, the estimated anisotropy error $\\Delta\\delta$ (dimensionless), the estimated receiver depth error $\\Delta z_r$ (in meters), and the root-mean-square residual between the measured residuals and the linearized reconstruction (in seconds).\n\nAll distances must be in meters, velocities in meters per second, times in seconds, and angles in radians. Express all outputs in the specified units and as decimal numbers.\n\nTest suite:\n- Case A (general \"happy path\"): $v_0 = 3000$, $z_s = 0$, $z_{r,\\text{model}} = 1500$, $\\delta_{\\text{model}} = 0.07$, $\\delta_{\\text{true}} = 0.08$, $\\Delta z_{r,\\text{true}} = 4$, offsets $x \\in \\{200, 800, 1400, 2000\\}$.\n- Case B (geometry-only error): $v_0 = 3000$, $z_s = 0$, $z_{r,\\text{model}} = 1200$, $\\delta_{\\text{model}} = 0.06$, $\\delta_{\\text{true}} = 0.06$, $\\Delta z_{r,\\text{true}} = 10$, offsets $x \\in \\{0, 500, 1000, 2000\\}$.\n- Case C (anisotropy-only error): $v_0 = 2800$, $z_s = 0$, $z_{r,\\text{model}} = 1800$, $\\delta_{\\text{model}} = 0.05$, $\\delta_{\\text{true}} = 0.03$, $\\Delta z_{r,\\text{true}} = 0$, offsets $x \\in \\{300, 900, 1500, 2100\\}$.\n- Case D (edge-case coverage: near-vertical and near-horizontal mixes): $v_0 = 3200$, $z_s = 0$, $z_{r,\\text{model}} = 1000$, $\\delta_{\\text{model}} = 0.05$, $\\delta_{\\text{true}} = 0.06$, $\\Delta z_{r,\\text{true}} = -5$, offsets $x \\in \\{0, 100, 1000, 4000\\}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case contributes an inner list in the form $[\\Delta\\delta_{\\text{est}}, \\Delta z_{r,\\text{est}}, \\text{rms}]$. For example, the output format must be exactly like $[[a_1,b_1,c_1],[a_2,b_2,c_2],[a_3,b_3,c_3],[a_4,b_4,c_4]]$ with decimal numbers in seconds for the root-mean-square residual values and in meters for the geometry estimates.", "solution": "The objective is to find the sensitivity kernels $K_\\delta(x)$ and $K_{\\text{geo}}(x)$ for the linearized travel time residual equation:\n$$\n\\Delta t(x) \\approx K_\\delta(x)\\,\\Delta\\delta + K_{\\text{geo}}(x)\\,\\Delta z_r\n$$\nThis equation represents the first-order Taylor expansion of the travel time $t$ with respect to the parameters $\\delta$ and $z_r$ around a background model state $(\\delta_{\\text{model}}, z_{r, \\text{model}})$. The kernels are the partial derivatives of the travel time evaluated at this model state.\n\nThe travel time $t$ is given by:\n$$\nt(\\ell, \\theta, \\delta) = \\frac{\\ell}{v(\\theta, \\delta)} = \\frac{\\ell}{v_0(1 + A(\\theta)\\delta)}\n$$\nwhere $\\ell = \\sqrt{(\\Delta x)^2 + (\\Delta z)^2}$ and $\\theta = \\operatorname{arctan2}(|\\Delta x|, |\\Delta z|)$ are functions of the receiver depth $z_r$ (since $\\Delta z = z_r - z_s$), and $A(\\theta) = \\sin^2\\theta\\cos^2\\theta$. All quantities in the following derivations are evaluated at the model state, so we will omit the 'model' subscript for brevity until the final expressions.\n\n**1. Derivation of the Anisotropy Kernel $K_\\delta(x)$**\n\nThe anisotropy kernel is the partial derivative of the travel time with respect to the Thomsen parameter $\\delta$.\n$$\nK_\\delta(x) = \\frac{\\partial t}{\\partial \\delta} = \\frac{\\partial}{\\partial \\delta} \\left[ \\frac{\\ell}{v_0(1 + A(\\theta)\\delta)} \\right]\n$$\nTreating $\\ell$, $\\theta$, and $v_0$ as constants with respect to $\\delta$, we apply the chain rule:\n$$\n\\frac{\\partial t}{\\partial \\delta} = \\frac{\\ell}{v_0} \\cdot \\frac{\\partial}{\\partial \\delta} \\left( (1 + A(\\theta)\\delta)^{-1} \\right) = \\frac{\\ell}{v_0} \\left[ -1 \\cdot (1 + A(\\theta)\\delta)^{-2} \\cdot A(\\theta) \\right]\n$$\n$$\n\\frac{\\partial t}{\\partial \\delta} = -\\frac{\\ell A(\\theta)}{v_0(1 + A(\\theta)\\delta)^2}\n$$\nThis expression can be conveniently written in terms of the modeled travel time $t_{\\text{model}} = \\frac{\\ell_{\\text{model}}}{v_0(1 + A(\\theta_{\\text{model}})\\delta_{\\text{model}})}$.\n$$\nK_\\delta(x) = -\\left( \\frac{\\ell_{\\text{model}}}{v_0(1 + A(\\theta_{\\text{model}})\\delta_{\\text{model}})} \\right) \\frac{A(\\theta_{\\text{model}})}{1 + A(\\theta_{\\text{model}})\\delta_{\\text{model}}}\n$$\nThus, the final expression for the anisotropy kernel is:\n$$\nK_\\delta(x) = -\\frac{t_{\\text{model}} A(\\theta_{\\text{model}})}{1 + A(\\theta_{\\text{model}})\\delta_{\\text{model}}}\n$$\n\n**2. Derivation of the Geometry Kernel $K_{\\text{geo}}(x)$**\n\nThe geometry kernel is the partial derivative of the travel time with respect to the receiver depth $z_r$. The travel time $t$ depends on $z_r$ through both the path length $\\ell$ and the angle $\\theta$. We must use the chain rule.\n$$\nK_{\\text{geo}}(x) = \\frac{\\partial t}{\\partial z_r} = \\frac{\\partial}{\\partial z_r} \\left( \\frac{\\ell}{v} \\right)\n$$\nUsing the quotient rule:\n$$\n\\frac{\\partial t}{\\partial z_r} = \\frac{1}{v} \\frac{\\partial \\ell}{\\partial z_r} - \\frac{\\ell}{v^2} \\frac{\\partial v}{\\partial z_r}\n$$\nThe derivative of the velocity $v$ with respect to $z_r$ is also found via the chain rule, as $v$ depends on $z_r$ through $\\theta$:\n$$\n\\frac{\\partial v}{\\partial z_r} = \\frac{\\partial v}{\\partial \\theta} \\frac{\\partial \\theta}{\\partial z_r}\n$$\nFrom $v = v_0(1 + A(\\theta)\\delta)$, we have:\n$$\n\\frac{\\partial v}{\\partial \\theta} = v_0 \\delta \\frac{\\partial A}{\\partial \\theta}\n$$\nSubstituting this back gives:\n$$\n\\frac{\\partial v}{\\partial z_r} = v_0 \\delta \\frac{\\partial A}{\\partial \\theta} \\frac{\\partial \\theta}{\\partial z_r}\n$$\nNow we substitute this into the expression for $\\frac{\\partial t}{\\partial z_r}$:\n$$\n\\frac{\\partial t}{\\partial z_r} = \\frac{1}{v} \\frac{\\partial \\ell}{\\partial z_r} - \\frac{\\ell}{v^2} \\left( v_0 \\delta \\frac{\\partial A}{\\partial \\theta} \\frac{\\partial \\theta}{\\partial z_r} \\right)\n$$\nSubstitute $v = v_0(1 + A\\delta)$ and factor out common terms:\n$$\n\\frac{\\partial t}{\\partial z_r} = \\frac{1}{v} \\left( \\frac{\\partial \\ell}{\\partial z_r} - \\frac{\\ell v_0 \\delta}{v} \\frac{\\partial A}{\\partial \\theta} \\frac{\\partial \\theta}{\\partial z_r} \\right) = \\frac{1}{v} \\left( \\frac{\\partial \\ell}{\\partial z_r} - \\frac{\\ell \\delta}{1 + A\\delta} \\frac{\\partial A}{\\partial \\theta} \\frac{\\partial \\theta}{\\partial z_r} \\right)\n$$\nExpressing this in terms of the modeled travel time $t_{\\text{model}} = \\ell_{\\text{model}}/v_{\\text{model}}$:\n$$\nK_{\\text{geo}}(x) = t_{\\text{model}} \\left( \\frac{1}{\\ell_{\\text{model}}} \\frac{\\partial \\ell}{\\partial z_r} - \\frac{\\delta_{\\text{model}}}{1 + A\\delta_{\\text{model}}} \\frac{\\partial A}{\\partial \\theta} \\frac{\\partial \\theta}{\\partial z_r} \\right) \\Bigg|_{\\text{model}}\n$$\nWe now substitute the explicit partial derivatives provided in the problem statement, evaluated at the model parameters:\n- $\\frac{\\partial \\ell}{\\partial z_r} = \\frac{\\Delta z_{\\text{model}}}{\\ell_{\\text{model}}}$\n- $\\frac{\\partial \\theta}{\\partial z_r} = -\\frac{\\Delta x}{(\\Delta x)^2 + (\\Delta z_{\\text{model}})^2} = -\\frac{\\Delta x}{\\ell_{\\text{model}}^2}$\n- $\\frac{\\partial A}{\\partial \\theta} = \\frac{1}{2}\\sin(4\\theta_{\\text{model}})$\n\nPlugging these into the expression for $K_{\\text{geo}}(x)$:\n$$\nK_{\\text{geo}}(x) = t_{\\text{model}} \\left[ \\frac{1}{\\ell_{\\text{model}}} \\left( \\frac{\\Delta z_{\\text{model}}}{\\ell_{\\text{model}}} \\right) - \\frac{\\delta_{\\text{model}}}{1 + A\\delta_{\\text{model}}} \\left( \\frac{1}{2}\\sin(4\\theta_{\\text{model}}) \\right) \\left( -\\frac{\\Delta x}{\\ell_{\\text{model}}^2} \\right) \\right]\n$$\nSimplifying the expression by factoring out $\\frac{1}{\\ell_{\\text{model}}^2}$:\n$$\nK_{\\text{geo}}(x) = \\frac{t_{\\text{model}}}{\\ell_{\\text{model}}^2} \\left[ \\Delta z_{\\text{model}} + \\frac{\\delta_{\\text{model}} \\Delta x \\sin(4\\theta_{\\text{model}})}{2(1 + A(\\theta_{\\text{model}})\\delta_{\\text{model}})} \\right]\n$$\nThis is the final expression for the geometry kernel.\n\nWith these derived kernels, we can construct the linear system $\\mathbf{G} \\mathbf{m} = \\mathbf{d}$ for a set of $N$ offsets $\\{x_i\\}$:\n$$\n\\begin{pmatrix}\nK_\\delta(x_1) & K_{\\text{geo}}(x_1) \\\\\nK_\\delta(x_2) & K_{\\text{geo}}(x_2) \\\\\n\\vdots & \\vdots \\\\\nK_\\delta(x_N) & K_{\\text{geo}}(x_N)\n\\end{pmatrix}\n\\begin{pmatrix}\n\\Delta\\delta \\\\\n\\Delta z_r\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n\\Delta t(x_1) \\\\\n\\Delta t(x_2) \\\\\n\\vdots \\\\\n\\Delta t(x_N)\n\\end{pmatrix}\n$$\nThis system is solved for the model perturbation vector $\\mathbf{m} = [\\Delta\\delta_{\\text{est}}, \\Delta z_{r,\\text{est}}]^T$ using a least-squares algorithm. The root-mean-square (RMS) residual between the measured data $\\mathbf{d}$ and the linearized prediction $\\mathbf{G} \\mathbf{m}$ quantifies the goodness of fit of the linear approximation.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Performs linearized sensitivity analysis to estimate anisotropy and geometry errors\n    from seismic travel time residuals.\n    \"\"\"\n    test_cases = [\n        # Case A: general \"happy path\"\n        {\n            'v0': 3000.0, 'zs': 0.0, 'zr_model': 1500.0,\n            'delta_model': 0.07, 'delta_true': 0.08, 'dzr_true': 4.0,\n            'offsets': [200.0, 800.0, 1400.0, 2000.0]\n        },\n        # Case B: geometry-only error\n        {\n            'v0': 3000.0, 'zs': 0.0, 'zr_model': 1200.0,\n            'delta_model': 0.06, 'delta_true': 0.06, 'dzr_true': 10.0,\n            'offsets': [0.0, 500.0, 1000.0, 2000.0]\n        },\n        # Case C: anisotropy-only error\n        {\n            'v0': 2800.0, 'zs': 0.0, 'zr_model': 1800.0,\n            'delta_model': 0.05, 'delta_true': 0.03, 'dzr_true': 0.0,\n            'offsets': [300.0, 900.0, 1500.0, 2100.0]\n        },\n        # Case D: edge-case coverage\n        {\n            'v0': 3200.0, 'zs': 0.0, 'zr_model': 1000.0,\n            'delta_model': 0.05, 'delta_true': 0.06, 'dzr_true': -5.0,\n            'offsets': [0.0, 100.0, 1000.0, 4000.0]\n        }\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        v0 = case['v0']\n        zs = case['zs']\n        zr_model = case['zr_model']\n        delta_model = case['delta_model']\n        delta_true = case['delta_true']\n        dzr_true = case['dzr_true'] \n        offsets = case['offsets']\n\n        dt_measured = []\n        G_matrix_rows = []\n\n        for x in offsets:\n            dx = x\n\n            # Modeled parameters\n            dz_model = zr_model - zs\n            ell_model = np.sqrt(dx**2 + dz_model**2)\n            # Handle zero path length, though unlikely with problem constraints\n            if ell_model == 0:\n                ell_model = 1e-9\n            \n            theta_model = np.arctan2(dx, dz_model)\n            A_model = 0.25 * (np.sin(2 * theta_model)**2)\n            v_model = v0 * (1 + A_model * delta_model)\n            t_model = ell_model / v_model\n\n            # True parameters and \"measured\" data\n            zr_true_val = zr_model + dzr_true\n            dz_true = zr_true_val - zs\n            ell_true = np.sqrt(dx**2 + dz_true**2)\n            if ell_true == 0:\n                ell_true = 1e-9\n\n            theta_true = np.arctan2(dx, dz_true)\n            A_true = 0.25 * (np.sin(2 * theta_true)**2)\n            v_true = v0 * (1 + A_true * delta_true)\n            t_true = ell_true / v_true\n\n            # Measured residual\n            dt = t_true - t_model\n            dt_measured.append(dt)\n\n            # --- Calculate sensitivity kernels at model parameters ---\n            \n            # Anisotropy kernel K_delta\n            K_delta = - (t_model * A_model) / (1 + A_model * delta_model)\n\n            # Geometry kernel K_geo\n            term1 = dz_model\n            term2_num = delta_model * dx * np.sin(4 * theta_model)\n            term2_den = 2 * (1 + A_model * delta_model)\n            \n            K_geo = (t_model / ell_model**2) * (term1 + term2_num / term2_den)\n\n            G_matrix_rows.append([K_delta, K_geo])\n        \n        # Assemble matrices and solve the linear system\n        G = np.array(G_matrix_rows)\n        d = np.array(dt_measured)\n\n        # Solve G * m = d for m = [delta_delta, delta_zr] using least squares\n        m, residuals_sum_sq, _, _ = np.linalg.lstsq(G, d, rcond=None)\n        \n        d_delta_est, d_zr_est = m[0], m[1]\n        \n        # Calculate RMS residual\n        d_recon = G @ m\n        rms_residual = np.sqrt(np.mean((d - d_recon)**2))\n        \n        all_results.append([d_delta_est, d_zr_est, rms_residual])\n\n    # Format output as a string representation of a list of lists.\n    formatted_results = []\n    for res in all_results:\n        formatted_res = f\"[{res[0]},{res[1]},{res[2]}]\"\n        formatted_results.append(formatted_res)\n    final_output_str = f\"[{','.join(formatted_results)}]\"\n    \n    print(final_output_str)\n\nsolve()\n```", "id": "3611639"}, {"introduction": "Understanding parameter cross-talk, as explored in the previous exercise, naturally leads to a critical question in geophysics: how should we design our survey to minimize these ambiguities? The answer lies in optimal acquisition design, where we select source and receiver locations to maximize our ability to distinguish different model parameters. This advanced practice [@problem_id:3611578] puts you in the role of a survey designer, tasking you with determining the minimal set of azimuthal and offset measurements required to robustly resolve the stiffness parameters of an orthorhombic medium. By analyzing the condition number of the sensitivity matrix, you will gain practical insight into how data coverage directly controls inversion stability and uniqueness.", "problem": "You are given a linearized acquisition design problem for Full Waveform Inversion (FWI) in an orthorhombic medium. The physical starting point is the first-order Born approximation for small contrasts across a planar interface, under which the scattered wavefield is linear in the model perturbations and the observed azimuthal Amplitude Versus Offset (AVO) reflectivity can be represented as a linear combination of azimuthal harmonics. Orthorhombic symmetry implies an azimuthal dependence of the plane-wave P-wave reflectivity that can be expressed as a truncated series in even azimuthal orders. In the small-contrast limit, and for moderate incidence angles, it is standard to adopt a separable representation of basis functions in incidence angle and azimuth. The goal is to determine the minimum azimuthal and offset coverage required to robustly recover an orthorhombic contrast parameter vector by ensuring the sensitivity matrix is invertible and well-conditioned.\n\nMathematical setup:\n- Let the incidence angle be denoted by $\\theta$ and the azimuth by $\\phi$.\n- Let the parameter vector $\\mathbf{c} \\in \\mathbb{R}^{m}$ represent linear combinations of stiffness contrasts that project onto a chosen basis of radiation patterns. The predicted linearized reflectivity sample at a particular pair $(\\theta,\\phi)$ is a linear function of $\\mathbf{c}$.\n- Define a set of $m$ basis functions $\\{b_{k}(\\theta,\\phi)\\}_{k=1}^{m}$. Each basis function is constructed as the product of an incidence-angle factor and an azimuthal harmonic:\n  $$ b_{k}(\\theta,\\phi) = \\left[\\sin(\\theta)\\right]^{p_k} \\cdot t_k\\big(n_k \\phi\\big), $$\n  where $p_k \\in \\{0,2,4\\}$ is an integer power, $n_k \\in \\{0,2,4\\}$ is an azimuthal harmonic order, and $t_k$ is one of $\\{\\cos, \\sin, 1\\}$ with the convention that $t_k(0) \\equiv 1$ for the constant azimuthal term.\n- Stack $N$ measurements taken at selected pairs $\\{(\\theta_i,\\phi_j)\\}$ into a data vector $\\mathbf{r} \\in \\mathbb{R}^{N}$ and construct the sensitivity (Jacobian) matrix $\\mathbf{A} \\in \\mathbb{R}^{N \\times m}$ with entries:\n  $$ A_{\\ell k} = b_{k}(\\theta_{\\ell}, \\phi_{\\ell}), \\quad \\ell=1,\\dots,N, \\ k=1,\\dots,m, $$\n  where each row corresponds to a unique acquisition pair.\n- Recoverability of $\\mathbf{c}$ requires that $\\mathbf{A}$ be full column rank. Robust recovery further requires the condition number $\\kappa(\\mathbf{A}) = \\sigma_{\\max} / \\sigma_{\\min}$, where $\\sigma_{\\max}$ and $\\sigma_{\\min}$ are the largest and smallest singular values of $\\mathbf{A}$, to be below a specified threshold $\\kappa_{\\max}$.\n\nTask:\n- For each test case below, you will be given:\n  1. A set of candidate azimuths $\\{\\phi\\}$ in degrees.\n  2. A set of candidate incidence angles $\\{\\theta\\}$ in degrees.\n  3. A basis specification, that is, the list of tuples $(p_k, n_k, t_k)$ that define $b_k(\\theta,\\phi)$.\n  4. A condition number threshold $\\kappa_{\\max}$.\n- Your program must search over all subsets of the candidate azimuths and candidate incidence angles to find the lexicographically minimal pair $(N_{\\phi}, N_{\\theta})$ (first minimize $N_{\\phi}$, then $N_{\\theta}$) such that there exists a choice of $N_{\\phi}$ distinct azimuths and $N_{\\theta}$ distinct incidence angles for which:\n  1. The resulting design matrix $\\mathbf{A}$ has full column rank $m$.\n  2. The condition number satisfies $\\kappa(\\mathbf{A}) \\le \\kappa_{\\max}$.\n  3. The total number of measurements $N = N_{\\phi} \\cdot N_{\\theta}$ is at least $m$.\n- If multiple subsets achieve the same minimal $(N_{\\phi}, N_{\\theta})$, choose the one with the smallest condition number.\n- If no feasible subsets exist, output the boolean value false for that test case.\n- Angles are provided in degrees; all trigonometric computations must be performed in radians. There are no physical units in the final answers beyond angles, and the final outputs are dimensionless.\n- Treat $\\mathbf{A}$ as full rank if the number of singular values greater than $\\tau$ equals $m$, where:\n  $$ \\tau = 10^{-10}. $$\n\nOutput format:\n- For each test case, output either the boolean false if infeasible, or a list $[N_{\\phi}, N_{\\theta}, \\kappa_{\\star}]$, where $\\kappa_{\\star}$ is the minimum condition number achieved among the minimal-coverage solutions, rounded to three decimal places.\n- Your program should produce a single line of output containing the results for all test cases as a comma-separated list enclosed in square brackets. For example, an output for three test cases might look like:\n  $$ [[3,2,12.345],[4,1,8.765],false] $$\n\nTest suite:\n- Test Case 1 (single angle-order group, five azimuthal harmonics):\n  - Basis terms $\\{(p_k, n_k, t_k)\\}_{k=1}^{5}$:\n    $$ \\{(2,0,\\mathrm{const}),\\ (2,2,\\cos),\\ (2,2,\\sin),\\ (2,4,\\cos),\\ (2,4,\\sin)\\}. $$\n    This corresponds to $m=5$ unknowns.\n  - Candidate azimuths in degrees:\n    $$ \\{10, 40, 70, 100, 130, 160\\}. $$\n  - Candidate incidence angles in degrees:\n    $$ \\{15, 30, 45\\}. $$\n  - Threshold:\n    $$ \\kappa_{\\max} = 10^{3}. $$\n- Test Case 2 (two angle-order groups, four azimuthal harmonics):\n  - Basis terms $\\{(p_k, n_k, t_k)\\}_{k=1}^{8}$:\n    $$ \\{(2,0,\\mathrm{const}),\\ (2,2,\\cos),\\ (2,2,\\sin),\\ (2,4,\\cos),\\ (4,0,\\mathrm{const}),\\ (4,2,\\cos),\\ (4,2,\\sin),\\ (4,4,\\cos)\\}. $$\n    This corresponds to $m=8$ unknowns.\n  - Candidate azimuths in degrees:\n    $$ \\{15, 45, 75, 105, 135, 165\\}. $$\n  - Candidate incidence angles in degrees:\n    $$ \\{10, 20, 30, 40\\}. $$\n  - Threshold:\n    $$ \\kappa_{\\max} = 5 \\times 10^{3}. $$\n- Test Case 3 (degenerate azimuth pool to test infeasibility):\n  - Basis terms identical to Test Case 2 (thus $m=8$ unknowns).\n  - Candidate azimuths in degrees:\n    $$ \\{0, 90, 180, 270\\}. $$\n  - Candidate incidence angles in degrees:\n    $$ \\{15, 35\\}. $$\n  - Threshold:\n    $$ \\kappa_{\\max} = 10^{3}. $$\n\nYour program must implement the above logic, perform all trigonometric computations in radians, and produce a single line with the outputs for the three test cases as a list of results in the format described earlier. No additional input should be read. The return types must be either booleans or lists of integers and a float as specified. The final output line should look like:\n- A single list with three elements, one per test case, where each element is either false or a three-element list with the minimal counts and the corresponding minimal condition number rounded to three decimals.", "solution": "The solution to this discrete optimization problem involves a systematic search for the lexicographically minimal pair of measurement counts $(N_{\\phi}, N_{\\theta})$ that satisfies the problem's stability and robustness criteria. The search proceeds by iterating through possible numbers of azimuths $N_{\\phi}$ and incidence angles $N_{\\theta}$ in increasing order, starting from $(1, 1)$.\n\nFor each pair $(N_{\\phi}, N_{\\theta})$ such that the total number of measurements $N = N_{\\phi} \\cdot N_{\\theta}$ is at least $m$ (the number of basis functions), the algorithm checks all possible combinations of $N_{\\phi}$ azimuths and $N_{\\theta}$ incidence angles from their respective candidate pools. For each of these combinations, the following steps are performed:\n\n1.  **Construct the Sensitivity Matrix**: An $N \\times m$ matrix $\\mathbf{A}$ is constructed. Each row corresponds to a unique measurement pair $(\\theta_i, \\phi_j)$ from the chosen subsets, and each column corresponds to one of the $m$ basis functions $b_k(\\theta, \\phi)$. The entry $A_{ik}$ is the value of the $k$-th basis function evaluated at the $i$-th measurement pair. All trigonometric calculations are performed in radians.\n\n2.  **Analyze Matrix Properties**: The stability and invertibility of the matrix $\\mathbf{A}$ are analyzed using Singular Value Decomposition (SVD).\n    *   **Full Rank Check**: The numerical rank of $\\mathbf{A}$ is determined by counting its singular values that are greater than the tolerance $\\tau = 10^{-10}$. The matrix is considered to have full column rank if this count equals $m$.\n    *   **Condition Number Check**: If the matrix is full rank, its condition number $\\kappa(\\mathbf{A}) = \\sigma_{\\max} / \\sigma_{\\min}$ is calculated, where $\\sigma_{\\max}$ and $\\sigma_{\\min}$ are the largest and smallest singular values, respectively. This value is then checked against the given threshold: $\\kappa(\\mathbfA) \\le \\kappa_{\\max}$.\n\n3.  **Identify Optimal Solution**: If a combination of azimuths and angles satisfies both the rank and condition number criteria, it is marked as a valid design. The algorithm seeks the smallest condition number achieved for the current pair $(N_{\\phi}, N_{\\theta})$.\n\nThe first pair $(N_{\\phi}, N_{\\theta})$ for which at least one valid design is found is, by definition, the lexicographically minimal solution. The algorithm then reports this pair along with the minimum condition number found among its valid designs. If the search completes without finding any valid design, the problem is infeasible. For Test Case 3, the candidate azimuths $\\{0, 90, 180, 270\\}$ cause columns corresponding to sine terms (e.g., $\\sin(2\\phi), \\sin(4\\phi)$) to be identically zero, and columns for cosine terms to become linearly dependent, making it impossible to achieve full rank. Therefore, this case is expected to be infeasible.", "answer": "```python\nimport numpy as np\nimport itertools\n\ndef solve():\n    \"\"\"\n    Main function to solve the acquisition design problem for all test cases.\n    \"\"\"\n    \n    # Define the trigonometric functions based on the string identifiers\n    trig_funcs = {\n        'const': lambda x: np.ones_like(x),\n        'cos': np.cos,\n        'sin': np.sin\n    }\n\n    # Rank determination threshold\n    RANK_TOLERANCE = 1e-10\n\n    test_cases = [\n        {\n            \"basis\": [(2, 0, 'const'), (2, 2, 'cos'), (2, 2, 'sin'), (2, 4, 'cos'), (2, 4, 'sin')],\n            \"phis_deg\": [10, 40, 70, 100, 130, 160],\n            \"thetas_deg\": [15, 30, 45],\n            \"kappa_max\": 1e3\n        },\n        {\n            \"basis\": [(2, 0, 'const'), (2, 2, 'cos'), (2, 2, 'sin'), (2, 4, 'cos'), \n                      (4, 0, 'const'), (4, 2, 'cos'), (4, 2, 'sin'), (4, 4, 'cos')],\n            \"phis_deg\": [15, 45, 75, 105, 135, 165],\n            \"thetas_deg\": [10, 20, 30, 40],\n            \"kappa_max\": 5e3\n        },\n        {\n            \"basis\": [(2, 0, 'const'), (2, 2, 'cos'), (2, 2, 'sin'), (2, 4, 'cos'), \n                      (4, 0, 'const'), (4, 2, 'cos'), (4, 2, 'sin'), (4, 4, 'cos')],\n            \"phis_deg\": [0, 90, 180, 270],\n            \"thetas_deg\": [15, 35],\n            \"kappa_max\": 1e3\n        }\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        basis_spec = case[\"basis\"]\n        candidate_phis_rad = np.deg2rad(case[\"phis_deg\"])\n        candidate_thetas_rad = np.deg2rad(case[\"thetas_deg\"])\n        kappa_max = case[\"kappa_max\"]\n        \n        m = len(basis_spec)\n        num_candidate_phis = len(candidate_phis_rad)\n        num_candidate_thetas = len(candidate_thetas_rad)\n\n        best_result_for_case = None\n        found_solution = False\n\n        for n_phi in range(1, num_candidate_phis + 1):\n            for n_theta in range(1, num_candidate_thetas + 1):\n                if n_phi * n_theta < m:\n                    continue\n\n                min_kappa_for_size = float('inf')\n                is_feasible_at_this_size = False\n\n                phi_subsets = itertools.combinations(candidate_phis_rad, n_phi)\n                for phi_subset in phi_subsets:\n                    theta_subsets = itertools.combinations(candidate_thetas_rad, n_theta)\n                    for theta_subset in theta_subsets:\n                        \n                        N = n_phi * n_theta\n                        A = np.zeros((N, m))\n                        \n                        measurement_pairs = list(itertools.product(theta_subset, phi_subset))\n\n                        for k, (p, n, t_str) in enumerate(basis_spec):\n                            t_func = trig_funcs[t_str]\n                            for i, (theta_val, phi_val) in enumerate(measurement_pairs):\n                                angle_factor = np.sin(theta_val)**p\n                                azim_factor = t_func(n * phi_val)\n                                A[i, k] = angle_factor * azim_factor\n                        \n                        try:\n                            s = np.linalg.svd(A, compute_uv=False)\n                        except np.linalg.LinAlgError:\n                            continue\n\n                        # Check for full rank\n                        rank = np.sum(s > RANK_TOLERANCE)\n                        if rank == m:\n                            # Check condition number\n                            # s is sorted, so s[m-1] is the smallest of the first m values.\n                            if s[m - 1] > 0:\n                                kappa = s[0] / s[m - 1]\n                                if kappa <= kappa_max:\n                                    is_feasible_at_this_size = True\n                                    if kappa < min_kappa_for_size:\n                                        min_kappa_for_size = kappa\n                \n                if is_feasible_at_this_size:\n                    best_result_for_case = [n_phi, n_theta, min_kappa_for_size]\n                    found_solution = True\n                    break # Minimal n_theta found\n            \n            if found_solution:\n                break # Minimal n_phi found\n\n        if best_result_for_case:\n            all_results.append(best_result_for_case)\n        else:\n            all_results.append(False)\n\n    # Format the final output string exactly as specified\n    formatted_items = []\n    for res in all_results:\n        if isinstance(res, list):\n            # Use f-string formatting to ensure three decimal places\n            formatted_items.append(f\"[{res[0]},{res[1]},{res[2]:.3f}]\")\n        else: # boolean False\n            formatted_items.append(\"false\")\n    \n    final_output = f\"[{','.join(formatted_items)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "3611578"}]}