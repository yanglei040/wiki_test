{"hands_on_practices": [{"introduction": "Before we can model the Earth's subsurface, we must first correctly orient our seismic data. An incoming teleseismic wave arrives at a specific angle and direction, and this practice guides you through the fundamental geometry needed to transform raw three-component seismograms into a physically meaningful, ray-centered coordinate system. By deriving the relationship between the ray parameter, incidence angle, and the rotation matrix, you will build the foundational skill needed to isolate the converted shear-wave energy that receiver functions are designed to analyze [@problem_id:3613348].", "problem": "A teleseismic compressional-wave (P-wave) arrival is recorded at a three-component broadband station as part of a Receiver Function (RF) study. Assume the near-surface Earth beneath the station can be modeled locally as an isotropic homogeneous half-space with P-wave speed $\\alpha_{0}$. A plane wave with back-azimuth $\\phi$ (measured clockwise from geographic North toward the source) and ray parameter $p$ (horizontal slowness at the surface) impinges on the station. Adopt a right-handed station coordinate system with components $Z$ (positive upward), $N$ (positive geographic North), and $E$ (positive geographic East). Define the incidence angle $\\theta$ as the angle between the propagation direction and the local vertical.\n\nTasks:\n1) Starting from the kinematics of plane waves in an isotropic medium, the definition of slowness, and Snell’s law, derive a relation that connects the incidence angle $\\theta$ at the free surface to the surface P-wave speed $\\alpha_{0}$ and the ray parameter $p$. Do not invoke any specialized receiver-function formula; instead, begin from the definitions of phase slowness and its horizontal projection.\n\n2) Using your derived relation, compute the numerical value of $\\theta$ for the following parameters: $\\phi = 123.4^{\\circ}$, $p = 0.0862068966 \\,\\text{s/km}$, and $\\alpha_{0} = 5.8 \\,\\text{km/s}$. Express the angle in degrees. Round your answer to four significant figures.\n\n3) Using geometric projection of particle motion, write the orthonormal rotation that maps the data vector $[Z,N,E]^{\\mathsf{T}}$ into $[L,Q,T]^{\\mathsf{T}}$, where $L$ is the longitudinal (P) component aligned with the propagation direction, $Q$ is the radial shear component in the $Z$–$R$ plane, and $T$ is the transverse shear component orthogonal to that plane. Express your rotation as the composition of a horizontal rotation by $\\phi$ and a dip rotation by $\\theta$, and provide the resulting $3\\times 3$ matrix in terms of $\\phi$ and $\\theta$ only. Do not substitute numbers in this step.\n\nOnly the result from Task 2 will be graded for numerical correctness. The final answer must be a single number (the value of $\\theta$ in degrees) rounded to four significant figures, as specified.", "solution": "We begin from plane-wave kinematics in an isotropic homogeneous medium. A plane wave may be written in terms of its phase as $\\Phi(\\mathbf{x},t) = \\mathbf{k}\\cdot\\mathbf{x} - \\omega t$, with angular frequency $\\omega$ and wave vector $\\mathbf{k}$ satisfying the dispersion relation $|\\mathbf{k}| = \\omega/\\alpha_{0}$ for a compressional wave speed $\\alpha_{0}$. The phase slowness vector $\\mathbf{s}$ is defined by $\\mathbf{s} = \\nabla_{\\mathbf{k}}(\\Phi/\\omega)$ for constant phase, which in an isotropic medium reduces to the vector $\\mathbf{s}$ of magnitude $|\\mathbf{s}| = 1/\\alpha_{0}$ pointing along the propagation direction. The horizontal projection of the slowness vector, $\\mathbf{s}_{h}$, has magnitude equal to the horizontal slowness (ray parameter) $p$, that is,\n$$\np \\equiv |\\mathbf{s}_{h}| = |\\mathbf{s}|\\sin\\theta = \\frac{1}{\\alpha_{0}}\\sin\\theta,\n$$\nwhere $\\theta$ is the incidence angle measured from the vertical. This follows from the right-triangle formed by the slowness vector and its horizontal and vertical components: the horizontal component is $|\\mathbf{s}|\\sin\\theta$, and the vertical component is $|\\mathbf{s}|\\cos\\theta$.\n\nRearranging the above relation yields the desired expression connecting $\\theta$, $p$, and $\\alpha_{0}$:\n$$\n\\sin\\theta = \\alpha_{0} p,\\qquad \\theta = \\arcsin\\!\\big(\\alpha_{0} p\\big).\n$$\n\nNext, we evaluate $\\theta$ numerically for the given parameters. We have $\\alpha_{0} = 5.8 \\,\\text{km/s}$ and $p = 0.0862068966 \\,\\text{s/km}$. Their product is\n$$\n\\alpha_{0} p = \\big(5.8 \\,\\text{km/s}\\big)\\big(0.0862068966 \\,\\text{s/km}\\big) = 0.5,\n$$\nso\n$$\n\\theta = \\arcsin(0.5) = \\frac{\\pi}{6}\\ \\text{radians} = 30\\ \\text{degrees}.\n$$\nRounding to four significant figures and expressing in degrees gives $30.00$.\n\nFinally, we construct the rotation mapping $[Z,N,E]^{\\mathsf{T}}$ to $[L,Q,T]^{\\mathsf{T}}$. First, rotate the horizontal components into radial–transverse coordinates $[R,T]^{\\mathsf{T}}$ using the back-azimuth $\\phi$ (measured clockwise from North toward the source). With $Z$ positive upward, $R$ pointing horizontally toward the source, and $T$ completing a right-handed system, the horizontal rotation is\n$$\n\\begin{pmatrix} R \\\\ T \\end{pmatrix}\n=\n\\begin{pmatrix}\n\\cos\\phi  \\sin\\phi \\\\\n-\\sin\\phi  \\cos\\phi\n\\end{pmatrix}\n\\begin{pmatrix} N \\\\ E \\end{pmatrix}.\n$$\nNext, rotate in the $Z$–$R$ plane by the incidence angle $\\theta$ to obtain the longitudinal (P) component $L$ aligned with the propagation direction and the radial shear component $Q$ orthogonal to $L$ in that plane. For a Z-up system, this rotation is\n$$\n\\begin{pmatrix}\nL \\\\ Q \\\\ T\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n-\\cos\\theta  \\sin\\theta  0 \\\\\n\\sin\\theta  \\cos\\theta  0 \\\\\n0  0  1\n\\end{pmatrix}\n\\begin{pmatrix}\nZ \\\\ R \\\\ T\n\\end{pmatrix}.\n$$\nComposing these two rotations yields the single $3\\times 3$ matrix $\\mathbf{M}$ that maps $[Z,N,E]^{\\mathsf{T}}$ to $[L,Q,T]^{\\mathsf{T}}$:\n$$\n\\begin{pmatrix}\nL \\\\ Q \\\\ T\n\\end{pmatrix}\n=\n\\underbrace{\n\\begin{pmatrix}\n-\\cos\\theta  \\sin\\theta\\cos\\phi  \\sin\\theta\\sin\\phi \\\\\n\\sin\\theta  \\cos\\theta\\cos\\phi  \\cos\\theta\\sin\\phi \\\\\n0  -\\sin\\phi  \\cos\\phi\n\\end{pmatrix}\n}_{\\mathbf{M}(\\phi,\\theta)}\n\\begin{pmatrix}\nZ \\\\ N \\\\ E\n\\end{pmatrix}.\n$$\nThis $\\mathbf{M}(\\phi,\\theta)$ is orthonormal for all $\\phi$ and $\\theta$ under the stated sign conventions and coordinate definitions.\n\nOnly the numerical value of $\\theta$ is required as the final answer. From the computation above, the incidence angle is $30.00$ degrees to four significant figures.", "answer": "$$\\boxed{30.00}$$", "id": "3613348"}, {"introduction": "At the heart of receiver function analysis lies the ability to predict the seismic response of a given Earth structure. This comprehensive exercise challenges you to build a synthetic receiver function from first principles, starting with a layered crustal model and the physics of P-to-S wave conversion. By implementing the propagator matrix method to calculate wave amplitudes and travel times, you will gain a deep, practical understanding of how features like the Moho discontinuity generate the characteristic signals seen in receiver function data [@problem_id:3613361].", "problem": "You are tasked with building a complete, runnable program that forward-models Receiver Functions for a one-dimensional, isotropic, three-layer Earth model using plane-wave P–SV (compressional–shear vertical) theory, propagators, and spectral deconvolution. The goal is to compute the free-surface vertical and radial Green’s functions in the frequency domain across a specified target frequency band, and generate a time-domain Receiver Function through stabilized spectral deconvolution. The program must be self-contained and produce a single-line output aggregating the specified test-case metrics.\n\nFundamental base and modeling assumptions: work in a one-dimensional layered elastic medium with isotropic layers and plane-wave propagation at a fixed horizontal slowness $p$. Start from the elastodynamic potential formulation for P–SV waves and the plane-wave dispersion and polarization relations. Let $x$ denote the horizontal (radial) direction and $z$ the vertical direction (positive downward). For a given layer with compressional-wave speed $v_p$, shear-wave speed $v_s$, density $\\rho$, horizontal slowness $p$ (in s/m), and angular frequency $\\omega$ (in rad/s), define the vertical slownesses\n$$\nq_P = \\sqrt{\\frac{1}{v_p^2} - p^2}, \\quad q_S = \\sqrt{\\frac{1}{v_s^2} - p^2},\n$$\nand the wavenumbers $k_x = \\omega p$, $k_{zP} = \\omega q_P$, and $k_{zS} = \\omega q_S$. The Lamé parameters are $\\mu = \\rho v_s^2$ and $\\lambda = \\rho v_p^2 - 2\\mu$. Use time-harmonic convention $\\exp(i(k_x x + k_z z - \\omega t))$. The P-wave displacement is given by the gradient of the scalar potential $\\phi$, and the SV-wave displacement is given by the curl of the scalar potential $\\psi$ in two dimensions. At a plane $z=\\text{constant}$, the polarization relations for unit-amplitude plane waves are\n$$\n\\begin{aligned}\n\\text{P up (Pu):}  u_x = i k_x \\phi,\\quad u_z = - i k_{zP} \\phi,\\quad \\sigma_{xz} = + 2 \\mu k_x k_{zP}\\phi,\\quad \\sigma_{zz} = -\\left[\\lambda(k_x^2 + k_{zP}^2) + 2\\mu k_{zP}^2\\right]\\phi,\\\\\n\\text{P down (Pd):}  u_x = i k_x \\phi,\\quad u_z = + i k_{zP} \\phi,\\quad \\sigma_{xz} = - 2 \\mu k_x k_{zP}\\phi,\\quad \\sigma_{zz} = -\\left[\\lambda(k_x^2 + k_{zP}^2) + 2\\mu k_{zP}^2\\right]\\phi,\\\\\n\\text{SV up (Su):}  u_x = + i k_{zS} \\psi,\\quad u_z = + i k_x \\psi,\\quad \\sigma_{xz} = \\mu (k_{zS}^2 - k_x^2)\\psi,\\quad \\sigma_{zz} = + 2 \\mu k_x k_{zS}\\psi,\\\\\n\\text{SV down (Sd):}  u_x = - i k_{zS} \\psi,\\quad u_z = + i k_x \\psi,\\quad \\sigma_{xz} = \\mu (k_{zS}^2 - k_x^2)\\psi,\\quad \\sigma_{zz} = - 2 \\mu k_x k_{zS}\\psi.\n\\end{aligned}\n$$\nAt a material interface, continuity of displacement and traction yields a $4\\times 4$ linear system (Zoeppritz system) for the reflected and transmitted amplitudes. For an upgoing incident P-wave from the lower medium (medium 2) into the upper medium (medium 1), define unknowns $A_{rp}$ (reflected downgoing P in medium 2), $B_{rs}$ (reflected downgoing SV in medium 2), $A_{tp}$ (transmitted upgoing P in medium 1), and $B_{ts}$ (transmitted upgoing SV in medium 1). Introducing the shorthand $p$, $q_{Pj}$, $q_{Sj}$, $\\mu_j$, $\\lambda_j$, and $Z_{Pj} = \\lambda_j(p^2 + q_{Pj}^2) + 2\\mu_j q_{Pj}^2$ for medium $j$, the continuity equations can be assembled into\n$$\n\\mathbf{A}\n\\begin{bmatrix}\nA_{rp}\\\\ B_{rs}\\\\ A_{tp}\\\\ B_{ts}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\np\\\\ -q_{P2}\\\\ 2\\mu_2 p q_{P2}\\\\ -Z_{P2}\n\\end{bmatrix},\n$$\nwith the coefficient matrix\n$$\n\\mathbf{A} = \\begin{bmatrix}\n- p  + q_{S2}  + p  + q_{S1}\\\\\n- q_{P2}  - p  - q_{P1}  + p\\\\\n+ 2 \\mu_2 p q_{P2}  - \\mu_2(q_{S2}^2 - p^2)  + 2 \\mu_1 p q_{P1}  + \\mu_1(q_{S1}^2 - p^2)\\\\\n+ Z_{P2}  + 2 \\mu_2 p q_{S2}  - Z_{P1}  + 2 \\mu_1 p q_{S1}\n\\end{bmatrix}.\n$$\nSolving this system yields the transmission coefficients $T_{PP} \\equiv A_{tp}$ and $T_{PS} \\equiv B_{ts}$ for P incidence. For an upgoing incident SV-wave from the lower medium, one solves the same linear system with modified right-hand side corresponding to Su incidence,\n$$\n\\mathbf{A}\n\\begin{bmatrix}\nA_{rp}\\\\ B_{rs}\\\\ A_{tp}\\\\ B_{ts}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nq_{S2}\\\\ p\\\\ \\mu_2(q_{S2}^2 - p^2)\\\\ 2\\mu_2 p q_{S2}\n\\end{bmatrix},\n$$\nobtaining $T_{SS} \\equiv B_{ts}$ (and $T_{SP} \\equiv A_{tp}$, not used here).\n\nFirst-order single-scattering forward model using propagators: treat only first-order P-to-S conversions at each interface (Born approximation), neglect internal multiples. Let there be three layers (1, 2, 3) over a half-space (4). The upward propagator for transmission is the product of transmission coefficients. For P reaching interface $j$ (counted from top: $j=1$ is between layers 1 and 2, $j=2$ between 2 and 3, $j=3$ between 3 and 4), the P amplitude is the product of $T_{PP}$ coefficients across deeper interfaces: specifically,\n$$\nA^{(P)}_{\\text{to } j} = \\prod_{k=j+1}^{3} T_{PP}(k\\leftrightarrow k+1),\n$$\nwith the convention that an empty product equals $1$. At interface $j$, the P-to-S converted amplitude is $B_{ts}^{(j)} = T_{PS}(j\\leftrightarrow j+1)$. The upward S propagates to the surface through the upper interfaces with transmitted amplitude\n$$\nA^{(S)}_{\\text{to surface from } j} = \\prod_{k=1}^{j-1} T_{SS}(k\\leftrightarrow k+1).\n$$\nTherefore, the SV potential amplitude arriving at the surface from interface $j$ is\n$$\n\\Psi_j = A^{(P)}_{\\text{to } j} \\, B_{ts}^{(j)} \\, A^{(S)}_{\\text{to surface from } j}.\n$$\nThe direct P-wave vertical potential amplitude at the surface is\n$$\n\\Phi_{\\text{surf}} = \\prod_{k=1}^{3} T_{PP}(k\\leftrightarrow k+1).\n$$\nThe frequency-domain free-surface displacements (Green’s functions) are modeled as a superposition of these contributions with phase propagation via exponential propagators. Denote the top-layer parameters $(v_{p1}, v_{s1}, \\rho_1)$, their vertical slownesses $(q_{P1}, q_{S1})$, and the propagator phases. The vertical and radial components in the frequency domain are\n$$\n\\begin{aligned}\nZ(\\omega) = - i \\omega q_{P1}\\, \\Phi_{\\text{surf}} + \\sum_{j=1}^3 \\left[ i \\omega p \\, \\Psi_j \\, e^{- i \\omega\\, t_{PS}^{(j)}} \\right],\\\\\nR(\\omega) = + i \\omega p\\, \\Phi_{\\text{surf}} + \\sum_{j=1}^3 \\left[ i \\omega q_{S1} \\, \\Psi_j \\, e^{- i \\omega\\, t_{PS}^{(j)}} \\right],\n\\end{aligned}\n$$\nwhere the relative arrival times of P-to-S conversions (Receiver Function delays) for interface $j$ are computed by vertical slowness integrals\n$$\nt_{PS}^{(j)} = \\sum_{m=1}^{j} h_m \\left( q_{Sm} - q_{Pm} \\right),\n$$\nwith $h_m$ the thickness of layer $m$ in meters. Note that the direct P reference time is absorbed as a baseline $t=0$.\n\nSpectral deconvolution to obtain the Receiver Function: use stabilized spectral division with a water-level parameter $\\epsilon$ and a band-limiting window $W(\\omega)$ covering the target frequency band,\n$$\n\\text{RF}(\\omega) = \\frac{R(\\omega)\\, Z^*(\\omega)}{|Z(\\omega)|^2 + \\epsilon}\\, W(\\omega),\n$$\nand obtain the time-domain Receiver Function via the inverse Fast Fourier Transform of $\\text{RF}(\\omega)$. Choose $W(\\omega)$ as an ideal band-pass mask restricted to $[f_\\min, f_\\max]$ Hertz. The water-level $\\epsilon$ must be chosen as a small fraction of the maximum of $|Z(\\omega)|^2$ over the band to stabilize division.\n\nNumerical units and implementation requirements: use International System of Units (SI) consistently.\n- Lengths $h_m$ in meters (m).\n- Velocities $v_p, v_s$ in meters per second (m/s).\n- Densities $\\rho$ in kilograms per cubic meter (kg/m$^3$).\n- Slowness $p$ in seconds per meter (s/m).\n- Frequency $f$ in Hertz (Hz), angular frequency $\\omega = 2\\pi f$ in radians per second.\n- Time in seconds (s).\n- The output Receiver Function time series must be sampled at a specified rate and duration with zero padding as needed for efficient Fast Fourier Transform.\n\nTest suite and output specification:\nYou must implement the above forward model and deconvolution, and compute the Receiver Function time series for the following three test cases. For each case, extract the Receiver Function amplitude samples at the three predicted arrival times $t_{PS}^{(j)}$ for $j=1,2,3$ (use nearest-neighbor in the sampled time series). The program must aggregate these nine amplitudes into a single list.\n\nCommon numerical settings for all test cases:\n- Sampling interval $\\Delta t = 0.025$ s; total duration $T = 102.4$ s; use a Fast Fourier Transform length consistent with this duration.\n- Frequency band window $f_\\min = 0.05$ Hz, $f_\\max = 1.0$ Hz.\n- Water-level fraction $\\eta = 0.01$, i.e., $\\epsilon = \\eta \\max_{\\omega} |Z(\\omega)|^2$ within the band.\n\nDefine the three test cases, each specifying $(h_1,h_2,h_3)$, $(v_{p1},v_{s1},\\rho_1)$, $(v_{p2},v_{s2},\\rho_2)$, $(v_{p3},v_{s3},\\rho_3)$, $(v_{p4},v_{s4},\\rho_4)$ for the half-space, and $p$:\n1. Case A (general happy path):\n   - $h_1 = 20000$ m, $h_2 = 15000$ m, $h_3 = 25000$ m.\n   - Layer 1: $v_{p1} = 6000$ m/s, $v_{s1} = 3464$ m/s, $\\rho_1 = 2700$ kg/m$^3$.\n   - Layer 2: $v_{p2} = 6500$ m/s, $v_{s2} = 3750$ m/s, $\\rho_2 = 2800$ kg/m$^3$.\n   - Layer 3: $v_{p3} = 8000$ m/s, $v_{s3} = 4600$ m/s, $\\rho_3 = 3200$ kg/m$^3$.\n   - Half-space (4): $v_{p4} = 8200$ m/s, $v_{s4} = 4700$ m/s, $\\rho_4 = 3300$ kg/m$^3$.\n   - $p = 6.0 \\times 10^{-5}$ s/m.\n2. Case B (weak contrasts boundary case):\n   - $h_1 = 20000$ m, $h_2 = 15000$ m, $h_3 = 25000$ m.\n   - Layer 1: $v_{p1} = 6000$ m/s, $v_{s1} = 3464$ m/s, $\\rho_1 = 2700$ kg/m$^3$.\n   - Layer 2: $v_{p2} = 6000$ m/s, $v_{s2} = 3464$ m/s, $\\rho_2 = 2700$ kg/m$^3$.\n   - Layer 3: $v_{p3} = 6000$ m/s, $v_{s3} = 3464$ m/s, $\\rho_3 = 2700$ kg/m$^3$.\n   - Half-space (4): $v_{p4} = 6000$ m/s, $v_{s4} = 3464$ m/s, $\\rho_4 = 2700$ kg/m$^3$.\n   - $p = 6.0 \\times 10^{-5}$ s/m.\n3. Case C (near-critical slowness edge case):\n   - Same layers as Case A.\n   - $p = 1.2 \\times 10^{-4}$ s/m.\n\nYour program should produce a single line of output containing the nine Receiver Function amplitudes at the predicted arrival times for the three cases, ordered case-by-case and interface-by-interface as $[A^{(A)}_1,A^{(A)}_2,A^{(A)}_3,A^{(B)}_1,A^{(B)}_2,A^{(B)}_3,A^{(C)}_1,A^{(C)}_2,A^{(C)}_3]$, where $A^{(X)}_j$ denotes the Receiver Function amplitude (a float) at $t_{PS}^{(j)}$ for case $X$ and interface index $j$. The output must be a comma-separated Python list enclosed in square brackets (e.g., \"[0.123,-0.045,0.001,...]\"). Angles are not used; all quantities are expressed in SI units. The program must be executable as is with no external input or files and must rely only on the specified runtime environment. Ensure scientific realism and numerical self-consistency throughout.", "solution": "The user has provided a detailed problem statement for forward-modeling seismic receiver functions. The task is to implement a specific algorithm based on plane-wave P-SV theory in a 1D layered medium, solve for three distinct test cases, and output specific numerical results.\n\n### Step 1: Problem Validation\n\nFirst, we must meticulously validate the problem statement against the criteria of scientific soundness, well-posedness, and objectivity.\n\n#### Givens Extraction\n\nThe problem provides the following data and definitions:\n- **Model**: A 1D Earth model with three isotropic elastic layers over an isotropic elastic half-space.\n- **Physics**: Plane-wave P–SV propagation at a fixed horizontal slowness $p$, using a first-order single-scattering (Born) approximation, neglecting internal multiples.\n- **Core Equations**:\n    - Vertical slownesses: $q_P = \\sqrt{1/v_p^2 - p^2}$ and $q_S = \\sqrt{1/v_s^2 - p^2}$.\n    - Lamé parameters: $\\mu = \\rho v_s^2$ and $\\lambda = \\rho v_p^2 - 2\\mu$.\n    - A $4 \\times 4$ linear system (Zoeppritz equations) to find transmission coefficients ($T_{PP}$, $T_{PS}$, $T_{SS}$) at an interface for upgoing P and SV waves. The matrix $\\mathbf{A}$ and the right-hand side vectors for both P and SV incidence are explicitly defined.\n- **Forward Model Equations**:\n    - P-wave amplitude to interface $j$: $A^{(P)}_{\\text{to } j} = \\prod_{k=j+1}^{3} T_{PP}(k\\leftrightarrow k+1)$.\n    - S-wave amplitude to surface from $j$: $A^{(S)}_{\\text{to surface from } j} = \\prod_{k=1}^{j-1} T_{SS}(k\\leftrightarrow k+1)$.\n    - SV potential from conversion at $j$: $\\Psi_j = A^{(P)}_{\\text{to } j} \\, T_{PS}(j\\leftrightarrow j+1) \\, A^{(S)}_{\\text{to surface from } j}$.\n    - Direct P potential: $\\Phi_{\\text{surf}} = \\prod_{k=1}^{3} T_{PP}(k\\leftrightarrow k+1)$.\n- **Frequency Domain Displacements**: Explicit formulas for vertical ($Z(\\omega)$) and radial ($R(\\omega)$) components at the free surface are given:\n    $$Z(\\omega) = - i \\omega q_{P1}\\, \\Phi_{\\text{surf}} + \\sum_{j=1}^3 \\left[ i \\omega p \\, \\Psi_j \\, e^{- i \\omega\\, t_{PS}^{(j)}} \\right]$$\n    $$R(\\omega) = + i \\omega p\\, \\Phi_{\\text{surf}} + \\sum_{j=1}^3 \\left[ i \\omega q_{S1} \\, \\Psi_j \\, e^{- i \\omega\\, t_{PS}^{(j)}} \\right]$$\n- **Time Delay**: The P-to-S conversion delay time is $t_{PS}^{(j)} = \\sum_{m=1}^{j} h_m ( q_{Sm} - q_{Pm} )$.\n- **Deconvolution**: A stabilized spectral division is defined to compute the receiver function: $\\text{RF}(\\omega) = \\frac{R(\\omega)\\, Z^*(\\omega)}{|Z(\\omega)|^2 + \\epsilon}\\, W(\\omega)$, followed by an inverse Fourier transform.\n- **Numerical Parameters**: Common settings for all tests are specified: $\\Delta t = 0.025$ s, $T = 102.4$ s, $f_\\min = 0.05$ Hz, $f_\\max = 1.0$ Hz, and water-level fraction $\\eta = 0.01$.\n- **Test Cases**: Three distinct cases are defined with specific layer thicknesses ($h_m$), P-wave speeds ($v_p$), S-wave speeds ($v_s$), densities ($\\rho$), and horizontal slowness ($p$).\n\n#### Validation Assessment\n\n1.  **Scientific Grounding**: The problem is firmly rooted in the fundamental principles of elastodynamics and seismology. The use of potentials, plane-wave decomposition, Zoeppritz equations, propagator formalism, and spectral deconvolution constitutes the standard framework for this type of modeling (e.g., as detailed in Aki  Richards, \"Quantitative Seismology\"). The physical parameters given in the test cases are realistic for Earth's crust and upper mantle. The equations for wave polarization and the Zoeppritz system have been verified against standard formulations and are correct for the specified convention ($z$ positive downwards, time-harmonic factor $e^{-i\\omega t}$).\n\n2.  **Well-Posedness**: The problem is well-posed. It describes a deterministic forward modeling algorithm where a unique output is expected for a given set of inputs. All required parameters are specified. The inclusion of a water-level parameter ($\\epsilon$) in the deconvolution formula explicitly addresses the potential instability of spectral division, ensuring the numerical procedure is stable.\n\n3.  **Objectivity**: The problem is stated in precise, objective, and mathematical language. There are no subjective or ambiguous terms. The required calculations and output format are specified without ambiguity.\n\n4.  **Completeness and Consistency**: The problem statement is self-contained. While the formulas for $Z(\\omega)$ and $R(\\omega)$ represent a known simplification (they model the incident wavefield displacements just below the surface, omitting the free-surface transfer functions), they are explicitly given as part of the algorithm to be implemented. The task is to execute this specific recipe, not to derive the most complete physical model. Therefore, this simplification is a feature of the specified task, not a flaw. The problem is internally consistent.\n\n5.  **Plausibility**: The test cases are physically plausible. Case A is a standard model. Case B (no impedance contrast) provides a crucial sanity check, as it should yield zero-amplitude converted phases. Case C uses a high horizontal slowness that approaches, but does not exceed, the critical slownesses of the deeper layers, correctly setting up a test for near-critical angle behavior without introducing the complication of evanescent waves (imaginary vertical slownesses), which simplifies the implementation while still testing the robustness of the code.\n\n#### Verdict\n\nThe problem is **valid**. It is a well-defined, scientifically sound, and numerically complete specification for a computational geophysics task. We may proceed to the solution.\n\n### Step 2: Algorithmic Design and Solution\n\nThe solution will be implemented in Python using the NumPy library, following the defined algorithm. The implementation is structured into three main parts: a function to solve the Zoeppritz equations, a main function to compute the receiver function for a given case, and a top-level `solve` function to manage the test cases and final output.\n\n1.  **Zoeppritz Coefficient Calculation**: A function, `calculate_zoeppritz`, will be created to compute the transmission coefficients ($T_{PP}$, $T_{PS}$, $T_{SS}$) for a single interface.\n    -   **Inputs**: Properties of the upper (medium 1) and lower (medium 2) layers ($v_p, v_s, \\rho$) and the horizontal slowness $p$. The incident wave is from medium 2.\n    -   **Process**:\n        -   Calculate the vertical slowness for P and S waves in each medium: $q_P = \\sqrt{1/v_p^2 - p^2}$, $q_S = \\sqrt{1/v_s^2 - p^2}$. All calculations will use complex numbers to accommodate any potential (though not present in these test cases) evanescent waves.\n        -   Compute the Lamé parameters $\\mu$ and $\\lambda$, and the term $Z_P = \\lambda(p^2 + q_P^2) + 2\\mu q_P^2$.\n        -   Construct the $4 \\times 4$ complex matrix $\\mathbf{A}$ as specified.\n        -   Construct the right-hand side vectors $\\mathbf{b}_P$ and $\\mathbf{b}_S$ for incident P and SV waves, respectively.\n        -   Solve the linear systems $\\mathbf{A}\\mathbf{x}_P = \\mathbf{b}_P$ and $\\mathbf{A}\\mathbf{x}_S = \\mathbf{b}_S$ using `numpy.linalg.solve`.\n        -   Extract the required transmission coefficients: $T_{PP}$ and $T_{PS}$ from the solution $\\mathbf{x}_P$, and $T_{SS}$ from $\\mathbf{x}_S$.\n    -   **Output**: A tuple $(T_{PP}, T_{PS}, T_{SS})$.\n\n2.  **Receiver Function Computation**: A function, `compute_receiver_function`, will orchestrate the main computation for a single test case.\n    -   **Inputs**: The case-specific parameters ($h_m, v_{pm}, v_{sm}, \\rho_m, p$) and the global numerical settings ($\\Delta t, T, f_{\\min}, f_{\\max}, \\eta$).\n    -   **Process**:\n        -   First, compute frequency-independent quantities. This includes calculating all vertical slownesses ($q_{Pm}, q_{Sm}$) for each layer and the P-to-S differential travel times $t_{PS}^{(j)}$ for each interface $j=1,2,3$.\n        -   Call `calculate_zoeppritz` for each of the three interfaces ($1\\leftrightarrow2$, $2\\leftrightarrow3$, $3\\leftrightarrow4$) to obtain the necessary transmission coefficients.\n        -   Compute the frequency-independent potential amplitudes: $\\Phi_{\\text{surf}}$ and $\\Psi_j$ for $j=1,2,3$, using the specified product formulas.\n        -   Set up the FFT parameters: number of points $N = T/\\Delta t$, and the frequency vector `freqs`.\n        -   Iterate through the frequency vector. For each angular frequency $\\omega = 2\\pi f$, compute the complex values of the vertical ($Z(\\omega)$) and radial ($R(\\omega)$) Green's functions using the provided formulas.\n        -   After the frequency loop, perform the deconvolution. Define the band-pass window $W(\\omega)$. Calculate the water-level parameter $\\epsilon$ from the maximum of $|Z(\\omega)|^2$ within the specified band.\n        -   Compute the frequency-domain receiver function $\\text{RF}(\\omega)$.\n        -   Perform the inverse real FFT of $\\text{RF}(\\omega)$ to obtain the time-domain receiver function, `rf_time`.\n        -   For each interface $j=1,2,3$, find the sample index in `rf_time` corresponding to the time closest to $t_{PS}^{(j)}$.\n    -   **Output**: A list containing the three receiver function amplitudes at the predicted arrival times.\n\n3.  **Main Execution**: The `solve` function will define the parameters for all three test cases, call `compute_receiver_function` for each, aggregate the results into a single list of nine amplitudes, and print the final list in the specified format. The number of FFT points will be $N = 102.4 / 0.025 = 4096$.\n\nThis structured approach ensures that each logical step of the problem is modularly and correctly implemented, leading to a verifiable and accurate final answer.", "answer": "```python\nimport numpy as np\n\ndef calculate_zoeppritz(vp1, vs1, rho1, vp2, vs2, rho2, p):\n    \"\"\"\n    Solves the P-SV Zoeppritz equations for an upgoing wave from medium 2 to medium 1.\n\n    Args:\n        vp1, vs1, rho1: P-vel, S-vel, density of upper medium 1.\n        vp2, vs2, rho2: P-vel, S-vel, density of lower medium 2.\n        p (float): Horizontal slowness (ray parameter).\n\n    Returns:\n        (T_pp, T_ps, T_ss): Complex transmission coefficients.\n    \"\"\"\n    # Ensure all calculations are done with complex numbers for stability\n    p = complex(p)\n\n    # Vertical slownesses (q)\n    # Use (x + 0j)**0.5 to ensure complex result if argument is negative\n    qp1 = (1/vp1**2 - p**2 + 0j)**0.5\n    qs1 = (1/vs1**2 - p**2 + 0j)**0.5\n    qp2 = (1/vp2**2 - p**2 + 0j)**0.5\n    qs2 = (1/vs2**2 - p**2 + 0j)**0.5\n\n    # Lame parameters (mu, lambda)\n    mu1 = rho1 * vs1**2\n    mu2 = rho2 * vs2**2\n    lam1 = rho1 * vp1**2 - 2 * mu1\n    lam2 = rho2 * vp2**2 - 2 * mu2\n\n    # Zp terms\n    Zp1 = lam1 * (p**2 + qp1**2) + 2 * mu1 * qp1**2\n    Zp2 = lam2 * (p**2 + qp2**2) + 2 * mu2 * qp2**2\n    \n    # Construct the 4x4 coefficient matrix A\n    A = np.array([\n        [-p,       qs2,                          p,        qs1],\n        [-qp2,     -p,                           -qp1,     p],\n        [2*mu2*p*qp2, -mu2*(qs2**2 - p**2),     2*mu1*p*qp1, mu1*(qs1**2 - p**2)],\n        [Zp2,      2*mu2*p*qs2,                -Zp1,     2*mu1*p*qs1]\n    ], dtype=np.complex128)\n\n    # Right-hand side (RHS) for incident P-wave from medium 2\n    b_p = np.array([p, -qp2, 2*mu2*p*qp2, -Zp2], dtype=np.complex128)\n    \n    # Right-hand side (RHS) for incident SV-wave from medium 2\n    b_s = np.array([qs2, p, mu2*(qs2**2-p**2), 2*mu2*p*qs2], dtype=np.complex128)\n    \n    # Solve linear systems\n    x_p = np.linalg.solve(A, b_p)\n    x_s = np.linalg.solve(A, b_s)\n    \n    # Extract transmission coefficients\n    # x = [A_rp, B_rs, A_tp, B_ts]^T\n    T_pp = x_p[2] # A_tp\n    T_ps = x_p[3] # B_ts\n    T_ss = x_s[3] # B_ts (for incident SV)\n\n    return T_pp, T_ps, T_ss\n\ndef compute_receiver_function(h_layers, props, p, dt, T, f_min, f_max, eta):\n    \"\"\"\n    Computes the receiver function for a 3-layer model over a half-space.\n    \"\"\"\n    n_layers = len(h_layers) + 1\n    vps, vss, rhos = props\n\n    # FFT parameters\n    N = int(T / dt)\n    freqs = np.fft.rfftfreq(N, d=dt)\n    omegas = 2 * np.pi * freqs\n\n    # --- Frequency-independent calculations ---\n    # Vertical slownesses for all layers\n    qps = np.array([(1/vps[i]**2 - p**2 + 0j)**0.5 for i in range(n_layers)])\n    qss = np.array([(1/vss[i]**2 - p**2 + 0j)**0.5 for i in range(n_layers)])\n    \n    # P-to-S conversion delay times for each interface\n    t_ps = np.zeros(n_layers - 1)\n    if not np.isclose(qss[0], qps[0]): # Avoid NaN if q values are equal for 0-contrast\n        diff_slowness = qss - qps\n        for j in range(n_layers - 1): # j=0,1,2 for interfaces 1,2,3\n             t_ps[j] = np.sum(h_layers[:j+1] * diff_slowness[:j+1]).real\n\n    # Transmission coefficients for each interface (1-2, 2-3, 3-4)\n    T_coeffs = [calculate_zoeppritz(vps[i], vss[i], rhos[i], vps[i+1], vss[i+1], rhos[i+1], p) for i in range(n_layers-1)]\n    T_pps = np.array([c[0] for c in T_coeffs])\n    T_pss = np.array([c[1] for c in T_coeffs])\n    T_sss = np.array([c[2] for c in T_coeffs])\n    \n    # Potential amplitudes (frequency-independent)\n    # Phi_surf = Tpp(1-2) * Tpp(2-3) * Tpp(3-4)\n    Phi_surf = np.prod(T_pps)\n\n    # Psi_j for j=1,2,3\n    Psi = np.zeros(3, dtype=np.complex128)\n    # j=1 (interface 1-2): A(P)to1 * Tps(1-2) * A(S)from1\n    # A(P) = Tpp(2-3) * Tpp(3-4)\n    # A(S) = 1 (empty product)\n    Psi[0] = np.prod(T_pps[1:]) * T_pss[0] * 1.0\n    # j=2 (interface 2-3): A(P)to2 * Tps(2-3) * A(S)from2\n    # A(P) = Tpp(3-4)\n    # A(S) = Tss(1-2)\n    Psi[1] = T_pps[2] * T_pss[1] * T_sss[0]\n    # j=3 (interface 3-4): A(P)to3 * Tps(3-4) * A(S)from3\n    # A(P) = 1 (empty product)\n    # A(S) = Tss(1-2) * Tss(2-3)\n    Psi[2] = 1.0 * T_pss[2] * np.prod(T_sss[:2])\n\n    # --- Frequency-dependent calculations ---\n    Z_w = np.zeros_like(omegas, dtype=np.complex128)\n    R_w = np.zeros_like(omegas, dtype=np.complex128)\n    \n    # Direct P-wave contribution\n    Z_w += -1j * omegas * qps[0] * Phi_surf\n    R_w += 1j * omegas * p * Phi_surf\n    \n    # Sum of P-S converted wave contributions\n    for j in range(3): # interface j=1,2,3\n        phase_propagator = np.exp(-1j * omegas * t_ps[j])\n        # Vertical component from upgoing SV\n        Z_w += 1j * omegas * p * Psi[j] * phase_propagator\n        # Radial component from upgoing SV\n        R_w += 1j * omegas * qss[0] * Psi[j] * phase_propagator\n        \n    # --- Deconvolution ---\n    Z_w_conj = np.conj(Z_w)\n    Z_w_abs2 = np.abs(Z_w)**2\n    \n    # Window and water level\n    window = (freqs = f_min)  (freqs = f_max)\n    if np.any(window):\n        max_Z2_in_band = np.max(Z_w_abs2[window])\n        epsilon = eta * max_Z2_in_band\n    else:\n        epsilon = 1e-12 # Fallback for empty band\n\n    rf_freq = (R_w * Z_w_conj) / (Z_w_abs2 + epsilon)\n    rf_freq[~window] = 0.0 # Apply band-pass filter\n\n    # Inverse FFT to time domain\n    rf_time = np.fft.irfft(rf_freq, n=N)\n\n    # Extract amplitudes at predicted arrival times\n    time_axis = np.arange(N) * dt\n    amplitudes = []\n    for t_arrival in t_ps:\n        idx = np.argmin(np.abs(time_axis - t_arrival))\n        amplitudes.append(rf_time[idx])\n        \n    return amplitudes\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    # Common numerical settings\n    DT = 0.025\n    T_DUR = 102.4\n    F_MIN = 0.05\n    F_MAX = 1.0\n    ETA = 0.01\n\n    # Test cases definition\n    case_a_props = {\n        'h': np.array([20000.0, 15000.0, 25000.0]),\n        'vps': np.array([6000.0, 6500.0, 8000.0, 8200.0]),\n        'vss': np.array([3464.0, 3750.0, 4600.0, 4700.0]),\n        'rhos': np.array([2700.0, 2800.0, 3200.0, 3300.0]),\n        'p': 6.0e-5\n    }\n    \n    case_b_props = {\n        'h': np.array([20000.0, 15000.0, 25000.0]),\n        'vps': np.array([6000.0, 6000.0, 6000.0, 6000.0]),\n        'vss': np.array([3464.0, 3464.0, 3464.0, 3464.0]),\n        'rhos': np.array([2700.0, 2700.0, 2700.0, 2700.0]),\n        'p': 6.0e-5\n    }\n\n    case_c_props = {\n        'h': np.array([20000.0, 15000.0, 25000.0]),\n        'vps': np.array([6000.0, 6500.0, 8000.0, 8200.0]),\n        'vss': np.array([3464.0, 3750.0, 4600.0, 4700.0]),\n        'rhos': np.array([2700.0, 2800.0, 3200.0, 3300.0]),\n        'p': 1.2e-4\n    }\n\n    test_cases = [case_a_props, case_b_props, case_c_props]\n    \n    all_results = []\n    for case in test_cases:\n        props = (case['vps'], case['vss'], case['rhos'])\n        amplitudes = compute_receiver_function(\n            case['h'], props, case['p'], DT, T_DUR, F_MIN, F_MAX, ETA\n        )\n        all_results.extend(amplitudes)\n    \n    # Format output as a single-line list of floats\n    print(f\"[{','.join([f'{r:.6f}' for r in all_results])}]\")\n\nsolve()\n\n```", "id": "3613361"}, {"introduction": "While one-dimensional models are fundamental, the real Earth is complex and three-dimensional. This exercise explores the limitations of the 1D assumption by asking you to quantify its breakdown in the presence of a simple 2D structure—a dipping interface. By comparing the synthetic receiver function from a 1D model to one from a dipping model and calculating the misfit, you will develop a crucial intuition for how structural complexity impacts receiver function analysis and learn to critically assess the applicability of your models [@problem_id:3613341].", "problem": "You are to implement a self-contained forward modeling experiment to quantify the breakdown of the one-dimensional assumption in receiver function analysis by comparing synthetic receiver functions generated for a dipping single interface against those generated under a horizontally stratified one-dimensional assumption. The goal is to compute a scalar misfit between the two receiver functions for several test cases that vary the dip angle and the elastic contrast across the interface.\n\nStart from the following well-tested bases and core definitions:\n- A receiver function is the result of deconvolving the vertical component from the radial component of a teleseismic recording of a plane wave, thereby approximating the impulse response of the subsurface beneath the receiver to mode-converted waves. Denote the vertical component as $Z(t)$ and the radial component as $R(t)$. A stabilized frequency-domain deconvolution with a water-level can be used to compute a receiver function $\\mathcal{R}(t)$ by computing the Fourier transforms $\\mathcal{F}\\{Z(t)\\}(\\omega)$ and $\\mathcal{F}\\{R(t)\\}(\\omega)$, forming\n$$\n\\widehat{\\mathcal{R}}(\\omega) \\;=\\; \\frac{\\widehat{R}(\\omega)\\,\\widehat{Z}(\\omega)^{\\ast}}{\\left|\\widehat{Z}(\\omega)\\right|^{2} + \\epsilon\\,\\max_{\\omega'}\\left|\\widehat{Z}(\\omega')\\right|^{2}},\n$$\nand then applying the inverse Fourier transform. Here $\\epsilon$ is a small positive stabilization constant and ${}^{\\ast}$ denotes complex conjugation.\n- The incident teleseismic wave is modeled as a unit-amplitude compressional plane wave ($P$ wave) that generates a converted shear wave ($P\\!S$) at a single planar interface. The vertical component $Z(t)$ and radial component $R(t)$ are synthesized by convolving impulses with a source time function. Use a Ricker wavelet of central frequency $f_{0}$ as the source time function,\n$$\nw(t) \\;=\\; \\left(1 - 2\\pi^{2} f_{0}^{2} t^{2}\\right)\\,\\exp\\!\\left(-\\pi^{2} f_{0}^{2} t^{2}\\right).\n$$\n- For a one-dimensional horizontally stratified medium, the $P\\!S$ conversion time from a single interface at depth $z_{0}$ is the sum of down-going $P$ travel time and up-going $S$ travel time along straight rays in isotropic media,\n$$\nt_{P}^{\\text{down}} \\;=\\; \\frac{z_{0}}{V_{P1}\\,\\cos i_{P}}, \\qquad t_{S}^{\\text{up}} \\;=\\; \\frac{z_{0}}{V_{S1}\\,\\cos i_{S}},\n$$\nwith $\\sin i_{P} \\,=\\, p\\,V_{P1}$ and $\\sin i_{S} \\,=\\, p\\,V_{S1}$, where $p$ is the ray parameter (horizontal slowness) and $V_{P1}, V_{S1}$ are compressional and shear velocities in the upper half-space. The total one-dimensional $P\\!S$ time is $t_{PS}^{(1D)} \\,=\\, t_{P}^{\\text{down}} + t_{S}^{\\text{up}}$.\n- For a dipping planar interface described in two dimensions by $z \\,=\\, z_{0} + x \\tan\\alpha$ with dip angle $\\alpha$ (dip within the plane containing the source-receiver great-circle path), the geometric travel times must respect the intersection of the down-going $P$ ray with the plane and the up-going $S$ ray returning to the surface. For an incident $P$ ray with angle $i_{P}$ from the vertical in the upper medium, the intersection time and depth are determined by straight-ray kinematics,\n$$\nt_{P}^{\\text{down,dip}} \\;=\\; \\frac{z_{0}}{V_{P1}\\left(\\cos i_{P} - \\sin i_{P}\\,\\tan\\alpha\\right)}, \\qquad z_{c} \\;=\\; V_{P1}\\cos i_{P}\\,t_{P}^{\\text{down,dip}},\n$$\nand the up-going $S$ travel time back to the surface is\n$$\nt_{S}^{\\text{up,dip}} \\;=\\; \\frac{z_{c}}{V_{S1}\\,\\cos i_{S}},\n$$\nwith $i_{S}$ defined by $\\sin i_{S} \\,=\\, p\\,V_{S1}$ as in the one-dimensional case. The total dipping-interface conversion time is $t_{PS}^{(\\text{dip})} \\,=\\, t_{P}^{\\text{down,dip}} + t_{S}^{\\text{up,dip}}$, valid for $\\cos i_{P} - \\sin i_{P}\\,\\tan\\alpha \\,\\, 0$.\n- The $P\\!S$ converted amplitude on the radial component depends on the elastic contrast and the incidence angle at the interface. Use a small-contrast, plane-wave converted amplitude that depends on the shear impedance contrast, modulated by the obliquity factor,\n$$\nA_{PS}(\\theta) \\;=\\; \\left(\\frac{\\rho_{2} V_{S2} - \\rho_{1} V_{S1}}{\\rho_{2} V_{S2} + \\rho_{1} V_{S1}}\\right)\\,\\sin\\!\\left(2\\theta\\right),\n$$\nwhere $\\theta$ is the angle between the down-going $P$ ray and the interface normal. For the one-dimensional horizontal interface, $\\theta \\,=\\, i_{P}$. For the dipping interface, take $\\theta \\,=\\, i_{P} - \\alpha$ under the two-dimensional, along-dip incidence assumption.\n\nYour program must:\n1. Synthesize vertical and radial components for two cases for each test: a one-dimensional horizontal interface and a two-dimensional dipping interface with the same material properties. Use identical source wavelets $w(t)$ and sampling.\n   - For the vertical component, use $Z(t) \\,=\\, w(t)$ (unit-amplitude direct $P$ arrival at $t \\,=\\, 0$).\n   - For the radial component, use a single $P\\!S$ arrival at the corresponding $t_{PS}$ with amplitude $A_{PS}$, that is $R(t) \\,=\\, A_{PS}\\,w(t - t_{PS})$.\n2. Compute receiver functions by stabilized spectral division with a water-level parameter $\\epsilon$ as stated above.\n3. Normalize both the dipping and one-dimensional receiver functions over a fixed time window by their $\\ell_{2}$ norm,\n$$\n\\|\\mathcal{R}\\|_{2} \\;=\\; \\left(\\sum_{k} \\mathcal{R}(t_{k})^{2}\\right)^{1/2},\n$$\nover the specified time samples in the window. If both norms are smaller than a small threshold, define the misfit to be zero. Otherwise, compute the root-mean-square misfit between the normalized receiver functions over the window,\n$$\n\\Delta \\;=\\; \\left(\\frac{1}{N}\\sum_{k=1}^{N}\\left(\\frac{\\mathcal{R}_{\\text{dip}}(t_{k})}{\\|\\mathcal{R}_{\\text{dip}}\\|_{2}} - \\frac{\\mathcal{R}_{1D}(t_{k})}{\\|\\mathcal{R}_{1D}\\|_{2}}\\right)^{2}\\right)^{1/2}.\n$$\n4. Use the following constants across all tests unless otherwise stated:\n   - Upper-medium properties: $V_{P1} \\,=\\, 6.2$ km/s, $V_{S1} \\,=\\, 3.6$ km/s, $\\rho_{1} \\,=\\, 2.7$ g/cm$^{3}$.\n   - Interface reference depth: $z_{0} \\,=\\, 40$ km.\n   - Ray parameter: $p \\,=\\, 0.06$ s/km.\n   - Source wavelet central frequency: $f_{0} \\,=\\, 1.25$ Hz.\n   - Sampling interval: $\\Delta t \\,=\\, 0.05$ s.\n   - Record duration: $T \\,=\\, 60$ s.\n   - Water-level stabilization: $\\epsilon \\,=\\, 10^{-2}$ (dimensionless).\n   - Misfit evaluation time window: $[0,\\,30]$ s.\n   - Angles must be in degrees in inputs and converted to radians in internal calculations.\n5. For each test, the lower-medium properties are defined by fixed multipliers applied to the upper-medium values: $V_{P2} \\,=\\, \\lambda_{P}\\,V_{P1}$, $V_{S2} \\,=\\, \\lambda_{S}\\,V_{S1}$, $\\rho_{2} \\,=\\, \\lambda_{\\rho}\\,\\rho_{1}$.\n\nImplement the program with the following test suite (each test is a tuple $(\\alpha,\\lambda_{P},\\lambda_{S},\\lambda_{\\rho})$ where $\\alpha$ is the dip in degrees, and $\\lambda_{P}$, $\\lambda_{S}$, $\\lambda_{\\rho}$ are the multipliers described above):\n- Test A (happy path, moderate dip and contrast): $(15,\\,1.10,\\,1.20,\\,1.10)$.\n- Test B (boundary case, zero dip): $(0,\\,1.15,\\,1.20,\\,1.10)$.\n- Test C (strong contrast and higher dip): $(35,\\,1.30,\\,1.50,\\,1.20)$.\n- Test D (edge case, very small contrast): $(25,\\,1.02,\\,1.02,\\,1.01)$.\n\nYour program must compute the four misfits $\\Delta$ as floating-point numbers and print a single line with a comma-separated Python list of the results, rounded to six decimal places, for the tests in the order A, B, C, D. The final printed format must be exactly of the form\n\"[x1,x2,x3,x4]\"\nwith $x_{j}$ being the six-decimal representations of the respective $\\Delta$ values. All travel times must be computed in seconds, all velocities in km/s, depths in km, and angles provided in degrees must be converted internally to radians. No user input is required; the program must run as is and produce the single specified output line.", "solution": "The problem is valid. It is scientifically grounded in the principles of seismological wave propagation and receiver function analysis, is mathematically and computationally well-posed, and is defined with objective, unambiguous parameters and procedures. All required constants and formulas are provided, and the test cases are within the domain of validity for the physical approximations used. We will therefore proceed with a full solution.\n\nThe objective is to quantify the error introduced by a one-dimensional (1D) structural assumption when analyzing data from a dipping (2D) subsurface interface. This is accomplished by computing a root-mean-square (RMS) misfit ($\\Delta$) between a synthetic receiver function generated for a dipping interface ($\\mathcal{R}_{\\text{dip}}$) and one generated for a corresponding horizontal interface ($\\mathcal{R}_{1D}$). The core of the procedure involves synthesizing these two receiver functions for several test cases and then calculating their difference.\n\nThe computational workflow proceeds as follows for each test case $(\\alpha, \\lambda_{P}, \\lambda_{S}, \\lambda_{\\rho})$:\n\n1.  **Parameter Initialization**: We begin by defining the fixed physical and computational parameters. The upper-medium properties are $V_{P1} = 6.2 \\, \\text{km/s}$, $V_{S1} = 3.6 \\, \\text{km/s}$, and $\\rho_{1} = 2.7 \\, \\text{g/cm}^3$. The incident plane wave is characterized by a ray parameter $p = 0.06 \\, \\text{s/km}$. The reference depth of the interface is $z_0 = 40 \\, \\text{km}$. The dip angle $\\alpha$ and the property multipliers $(\\lambda_{P}, \\lambda_{S}, \\lambda_{\\rho})$ are taken from the specific test case. Angles are converted from degrees to radians for all trigonometric calculations.\n\n2.  **Wave Propagation Angles**: The incidence angle of the P-wave, $i_P$, and the take-off angle of the converted S-wave, $i_S$, are determined by Snell's law in its ray-parameter form:\n    $$ i_P = \\arcsin(p \\cdot V_{P1}) $$\n    $$ i_S = \\arcsin(p \\cdot V_{S1}) $$\n    These angles are constant for a given ray parameter and upper-medium velocity structure.\n\n3.  **Model Property Finalization**: The properties of the lower medium ($V_{P2}$, $V_{S2}$, $\\rho_2$) are calculated by applying the multipliers from the test case:\n    $$ V_{P2} = \\lambda_P V_{P1}, \\quad V_{S2} = \\lambda_S V_{S1}, \\quad \\rho_2 = \\lambda_\\rho \\rho_1 $$\n\n4.  **1D Model Calculations (Horizontal Interface)**:\n    -   **Travel Time**: The arrival time of the P-to-S converted phase ($Ps$) for a horizontal interface at depth $z_0$ is the sum of the travel time of the downgoing P-wave and the upcoming S-wave.\n        $$ t_{PS}^{(1D)} = \\frac{z_{0}}{V_{P1}\\cos i_{P}} + \\frac{z_{0}}{V_{S1}\\cos i_{S}} $$\n    -   **Amplitude**: The amplitude of the converted wave depends on the contrast in shear wave impedance and the incidence angle. For a horizontal interface, the angle between the incident ray and the interface normal is simply $i_P$.\n        $$ A_{PS}^{(1D)} = \\left(\\frac{\\rho_{2} V_{S2} - \\rho_{1} V_{S1}}{\\rho_{2} V_{S2} + \\rho_{1} V_{S1}}\\right) \\sin(2i_{P}) $$\n\n5.  **2D Model Calculations (Dipping Interface)**:\n    -   **Travel Time**: For an interface dipping at an angle $\\alpha$, the path lengths are altered. The travel time for the downgoing P-wave to the interface and the upcoming S-wave from the conversion point are given by the specified geometric formulas:\n        $$ t_{P}^{\\text{down,dip}} = \\frac{z_{0}}{V_{P1}(\\cos i_{P} - \\sin i_{P}\\tan\\alpha)} $$\n        The depth of the conversion point, $z_c$, is then found:\n        $$ z_c = V_{P1}\\cos i_{P} \\cdot t_{P}^{\\text{down,dip}} $$\n        This depth is used to calculate the travel time of the ascending S-wave:\n        $$ t_{S}^{\\text{up,dip}} = \\frac{z_c}{V_{S1}\\cos i_S} $$\n        The total $Ps$ arrival time for the dipping case is their sum:\n        $$ t_{PS}^{(\\text{dip})} = t_{P}^{\\text{down,dip}} + t_{S}^{\\text{up,dip}} $$\n    -   **Amplitude**: The obliquity factor in the amplitude calculation now depends on the angle between the incident ray and the normal to the *dipping* interface, which is $\\theta = i_P - \\alpha$.\n        $$ A_{PS}^{(\\text{dip})} = \\left(\\frac{\\rho_{2} V_{S2} - \\rho_{1} V_{S1}}{\\rho_{2} V_{S2} + \\rho_{1} V_{S1}}\\right) \\sin(2(i_P - \\alpha)) $$\n\n6.  **Waveform Synthesis**:\n    -   A time vector $t$ is created with a sampling interval $\\Delta t = 0.05 \\, \\text{s}$ over a duration $T = 60 \\, \\text{s}$.\n    -   The source wavelet is a Ricker wavelet with central frequency $f_0 = 1.25 \\, \\text{Hz}$: $w(t) = (1 - 2\\pi^2 f_0^2 t^2) \\exp(-\\pi^2 f_0^2 t^2)$.\n    -   The vertical component seismogram, representing the direct P-wave arrival, is synthesized as $Z(t) = w(t)$.\n    -   The radial component seismograms are synthesized by placing a scaled Ricker wavelet at the computed $Ps$ arrival times:\n        $$ R_{1D}(t) = A_{PS}^{(1D)} \\cdot w(t - t_{PS}^{(1D)}) $$\n        $$ R_{\\text{dip}}(t) = A_{PS}^{(\\text{dip})} \\cdot w(t - t_{PS}^{(\\text{dip)}) $$\n\n7.  **Receiver Function Computation**:\n    -   The synthesized seismograms $Z(t)$, $R_{1D}(t)$, and $R_{\\text{dip}}(t)$ are transformed into the frequency domain using the Fast Fourier Transform (FFT).\n    -   The receiver functions $\\mathcal{R}_{1D}(t)$ and $\\mathcal{R}_{\\text{dip}}(t)$ are computed via stabilized spectral division. The water-level $\\epsilon = 10^{-2}$ regularizes the deconvolution. For each model (1D and dip), the frequency-domain receiver function is:\n        $$ \\widehat{\\mathcal{R}}(\\omega) = \\frac{\\widehat{R}(\\omega)\\,\\widehat{Z}(\\omega)^{\\ast}}{|\\widehat{Z}(\\omega)|^{2} + \\epsilon \\cdot \\max_{\\omega'}| \\widehat{Z}(\\omega')|^{2}} $$\n    -   These are transformed back to the time domain using the inverse FFT. The real part of the result is retained.\n\n8.  **Misfit Calculation**:\n    -   The receiver functions are windowed to the interval $[0, 30] \\, \\text{s}$.\n    -   The $\\ell_{2}$ norm of each windowed receiver function, $\\|\\mathcal{R}\\|_2$, is computed.\n    -   A small threshold is used to check if both norms are effectively zero; if so, the misfit is $0$. Otherwise, each windowed trace is normalized by its norm.\n    -   The final misfit $\\Delta$ is the RMS difference between the two normalized receiver functions over the $N$ samples in the window:\n        $$ \\Delta = \\sqrt{\\frac{1}{N}\\sum_{k=1}^{N}\\left(\\frac{\\mathcal{R}_{\\text{dip}}(t_{k})}{\\|\\mathcal{R}_{\\text{dip}}\\|_{2}} - \\frac{\\mathcal{R}_{1D}(t_{k})}{\\|\\mathcal{R}_{1D}\\|_{2}}\\right)^{2}} $$\n\nThis entire procedure is encapsulated in a program that iterates through the provided test cases, calculates the misfit for each, and reports the results in the specified format.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the misfit between receiver functions for dipping and horizontal interfaces.\n    \"\"\"\n\n    # --- Define constants and test cases ---\n    VP1 = 6.2         # km/s\n    VS1 = 3.6         # km/s\n    RHO1 = 2.7        # g/cm^3\n    Z0 = 40.0         # km\n    P_RAY = 0.06      # s/km\n    F0 = 1.25         # Hz\n    DT = 0.05         # s\n    T_DUR = 60.0      # s\n    EPSILON = 1e-2    # Water-level\n    MISFIT_WIN_END = 30.0 # s\n    NORM_THRESHOLD = 1e-9 # Threshold for norm check\n\n    test_cases = [\n        # (alpha_deg, lambda_P, lambda_S, lambda_rho)\n        (15.0, 1.10, 1.20, 1.10),  # Test A\n        (0.0,  1.15, 1.20, 1.10),  # Test B\n        (35.0, 1.30, 1.50, 1.20),  # Test C\n        (25.0, 1.02, 1.02, 1.01),  # Test D\n    ]\n\n    # --- Pre-computation ---\n    # Time vector\n    t = np.arange(0, T_DUR, DT)\n    n_pts = len(t)\n    \n    # Misfit window indices\n    misfit_indices = np.where(t = MISFIT_WIN_END)[0]\n    n_misfit = len(misfit_indices)\n\n    # Ricker wavelet function\n    def ricker_wavelet(time, t_shift, f0):\n        t_prime = time - t_shift\n        pi2_f02_t2 = (np.pi * f0 * t_prime)**2\n        return (1.0 - 2.0 * pi2_f02_t2) * np.exp(-pi2_f02_t2)\n\n    # Vertical component Z(t) and its FFT (common for all tests)\n    z_t = ricker_wavelet(t, 0.0, F0)\n    z_fft = np.fft.fft(z_t)\n    z_power_spec = np.abs(z_fft)**2\n    water_level = EPSILON * np.max(z_power_spec)\n    \n    # Calculate common angles\n    i_p = np.arcsin(P_RAY * VP1)\n    i_s = np.arcsin(P_RAY * VS1)\n\n    # --- Main loop over test cases ---\n    results = []\n    for case in test_cases:\n        alpha_deg, lambda_p, lambda_s, lambda_rho = case\n        alpha_rad = np.deg2rad(alpha_deg)\n\n        # Lower-medium properties\n        vp2 = lambda_p * VP1\n        vs2 = lambda_s * VS1\n        rho2 = lambda_rho * RHO1\n\n        # --- 1D Model (Horizontal Interface) ---\n        t_ps_1d = (Z0 / (VP1 * np.cos(i_p))) + (Z0 / (VS1 * np.cos(i_s)))\n        \n        # Amplitude\n        shear_imp1 = RHO1 * VS1\n        shear_imp2 = rho2 * vs2\n        refl_coeff_part = (shear_imp2 - shear_imp1) / (shear_imp2 + shear_imp1)\n        a_ps_1d = refl_coeff_part * np.sin(2 * i_p)\n        \n        # Synthesize radial component R_1D(t)\n        r_1d_t = a_ps_1d * ricker_wavelet(t, t_ps_1d, F0)\n        \n        # --- 2D Model (Dipping Interface) ---\n        # Denominator check\n        denom = VP1 * (np.cos(i_p) - np.sin(i_p) * np.tan(alpha_rad))\n        if denom = 0: # Physical constraint\n             t_ps_dip = -1 # Invalid time\n        else:\n             t_p_down_dip = Z0 / (VP1 * (np.cos(i_p) - np.sin(i_p) * np.tan(alpha_rad)))\n             z_c = VP1 * np.cos(i_p) * t_p_down_dip\n             t_s_up_dip = z_c / (VS1 * np.cos(i_s))\n             t_ps_dip = t_p_down_dip + t_s_up_dip\n        \n        # Amplitude\n        theta = i_p - alpha_rad\n        a_ps_dip = refl_coeff_part * np.sin(2 * theta)\n\n        # Synthesize radial component R_dip(t)\n        r_dip_t = a_ps_dip * ricker_wavelet(t, t_ps_dip, F0)\n\n        # --- Receiver Function Calculation ---\n        # FFT of radial components\n        r_1d_fft = np.fft.fft(r_1d_t)\n        r_dip_fft = np.fft.fft(r_dip_t)\n\n        # Deconvolution\n        rf_1d_fft = (r_1d_fft * np.conj(z_fft)) / (z_power_spec + water_level)\n        rf_dip_fft = (r_dip_fft * np.conj(z_fft)) / (z_power_spec + water_level)\n\n        # Inverse FFT to time domain\n        rf_1d_t = np.fft.ifft(rf_1d_fft).real\n        rf_dip_t = np.fft.ifft(rf_dip_fft).real\n\n        # --- Misfit Calculation ---\n        # Window the receiver functions\n        rf_1d_win = rf_1d_t[misfit_indices]\n        rf_dip_win = rf_dip_t[misfit_indices]\n        \n        # Calculate l2 norms\n        norm_1d = np.linalg.norm(rf_1d_win)\n        norm_dip = np.linalg.norm(rf_dip_win)\n        \n        if norm_1d  NORM_THRESHOLD and norm_dip  NORM_THRESHOLD:\n            misfit = 0.0\n        else:\n            # Normalize\n            if norm_1d  NORM_THRESHOLD:\n                rf_1d_norm = rf_1d_win / norm_1d\n            else:\n                rf_1d_norm = np.zeros_like(rf_1d_win)\n                \n            if norm_dip  NORM_THRESHOLD:\n                rf_dip_norm = rf_dip_win / norm_dip\n            else:\n                rf_dip_norm = np.zeros_like(rf_dip_win)\n                \n            # RMS Misfit\n            misfit = np.sqrt(np.mean((rf_dip_norm - rf_1d_norm)**2))\n        \n        results.append(misfit)\n\n    # --- Format and print the final output ---\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```", "id": "3613341"}]}