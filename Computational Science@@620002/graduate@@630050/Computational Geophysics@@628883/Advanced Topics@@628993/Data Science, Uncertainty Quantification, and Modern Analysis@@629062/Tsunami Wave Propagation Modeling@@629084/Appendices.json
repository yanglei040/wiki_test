{"hands_on_practices": [{"introduction": "Understanding the fundamental behavior of tsunami waves begins with the linearized shallow-water equations. This practice invites you to solve these equations analytically for an idealized initial disturbance [@problem_id:3618013]. By applying d'Alembert's formula, you will directly observe how an initial uplift splits into two distinct wave packets that propagate in opposite directions, a core principle of linear wave theory.", "problem": "A one-dimensional (1D) tsunami wave train in the deep ocean can be approximated by the linear shallow-water equations for a horizontally uniform depth. Consider an idealized, infinite 1D domain with constant depth and no boundaries, where the free-surface displacement $\\,\\eta(x,t)\\,$ and the depth-averaged horizontal velocity $\\,u(x,t)\\,$ satisfy the linear shallow-water system\n$$\\eta_{t}(x,t)+h\\,u_{x}(x,t)=0,\\qquad u_{t}(x,t)+g\\,\\eta_{x}(x,t)=0,$$\nwith constant depth $\\,h\\,$ and gravitational acceleration $\\,g\\,$. The water is initially at rest and the surface has a localized uplift:\n$$\\eta(x,0)=\\eta_{0}(x)=A\\,\\exp\\!\\left(-\\frac{(x-x_{0})^{2}}{2\\,\\sigma^{2}}\\right),\\qquad u(x,0)=0.$$\nStarting from these equations, derive the governing equation for $\\,\\eta(x,t)\\,$ and obtain the appropriate propagation solution for $\\,\\eta(x,t)\\,$ consistent with the given initial conditions, expressed in closed form in terms of $\\,\\eta_{0}\\,$. Then, for the parameter values $\\,A=1.5\\,$ meters, $\\,x_{0}=0\\,$ meters, $\\,\\sigma=3.0\\times 10^{4}\\,$ meters, $\\,h=4.0\\times 10^{3}\\,$ meters, and $\\,g=9.81\\,$ meters per second squared, evaluate $\\,\\eta(x,t)\\,$ at $\\,x=1.0\\times 10^{5}\\,$ meters and $\\,t=6.0\\times 10^{2}\\,$ seconds. Express the final displacement in meters and round your answer to four significant figures.", "solution": "The problem is valid as it is scientifically grounded, well-posed, and objective. It describes a standard initial value problem for the linear shallow-water equations, a fundamental model in geophysical fluid dynamics. All parameters and conditions are physically realistic and mathematically consistent.\n\nThe governing equations for the free-surface displacement $\\eta(x,t)$ and the depth-averaged horizontal velocity $u(x,t)$ are the linear shallow-water equations:\n$$ \\eta_{t}(x,t)+h\\,u_{x}(x,t)=0 \\quad (1) $$\n$$ u_{t}(x,t)+g\\,\\eta_{x}(x,t)=0 \\quad (2) $$\nwhere $h$ is the constant depth and $g$ is the gravitational acceleration. The subscripts denote partial differentiation.\n\nTo derive a single governing equation for $\\eta(x,t)$, we differentiate equation $(1)$ with respect to $t$ and equation $(2)$ with respect to $x$:\n$$ \\eta_{tt}+h\\,u_{xt}=0 \\quad (3) $$\n$$ u_{tx}+g\\,\\eta_{xx}=0 \\quad (4) $$\nAssuming $\\eta$ and $u$ are sufficiently smooth, the mixed partial derivatives are equal (Clairaut's theorem), i.e., $u_{xt}=u_{tx}$. We can substitute $u_{xt}$ from $(4)$ into $(3)$:\n$$ \\eta_{tt} - g h\\,\\eta_{xx} = 0 $$\nThis is the one-dimensional linear wave equation for $\\eta(x,t)$:\n$$ \\eta_{tt} = c^{2}\\eta_{xx} $$\nwhere the wave propagation speed is $c=\\sqrt{gh}$.\n\nThe general solution to this wave equation is given by d'Alembert's formula:\n$$ \\eta(x,t) = \\frac{1}{2}\\left[\\eta(x-ct,0) + \\eta(x+ct,0)\\right] + \\frac{1}{2c}\\int_{x-ct}^{x+ct} \\eta_{t}(s,0) \\,ds $$\nWe are given the initial conditions:\n$$ \\eta(x,0) = \\eta_{0}(x) = A\\,\\exp\\!\\left(-\\frac{(x-x_{0})^{2}}{2\\,\\sigma^{2}}\\right) $$\n$$ u(x,0) = 0 $$\nTo use d'Alembert's formula, we need the initial condition for $\\eta_t(x,0)$. From equation $(1)$, we have $\\eta_{t} = -h\\,u_{x}$. At $t=0$:\n$$ \\eta_{t}(x,0) = -h\\,u_{x}(x,0) $$\nSince $u(x,0)=0$ for all $x$, its spatial derivative must also be zero: $u_{x}(x,0)=0$. Therefore, the second initial condition is $\\eta_{t}(x,0)=0$.\n\nSubstituting the initial conditions $\\eta(x,0)=\\eta_{0}(x)$ and $\\eta_{t}(x,0)=0$ into d'Alembert's formula, the integral term vanishes, and the solution simplifies to:\n$$ \\eta(x,t) = \\frac{1}{2}\\left[\\eta_{0}(x-ct) + \\eta_{0}(x+ct)\\right] $$\nThis solution describes the initial Gaussian profile splitting into two identical waves, each with half the initial amplitude, propagating in opposite directions at speed $c$.\n\nSubstituting the specific form of $\\eta_{0}(x)$:\n$$ \\eta(x,t) = \\frac{A}{2}\\left[\\exp\\!\\left(-\\frac{(x-ct-x_{0})^{2}}{2\\,\\sigma^{2}}\\right) + \\exp\\!\\left(-\\frac{(x+ct-x_{0})^{2}}{2\\,\\sigma^{2}}\\right)\\right] $$\nNow, we evaluate this expression for the given parameter values:\n$A=1.5$ m\n$x_{0}=0$ m\n$\\sigma=3.0\\times 10^{4}$ m\n$h=4.0\\times 10^{3}$ m\n$g=9.81$ m/s$^{2}$\n$x=1.0\\times 10^{5}$ m\n$t=6.0\\times 10^{2}$ s\n\nFirst, calculate the wave speed $c$:\n$$ c = \\sqrt{gh} = \\sqrt{(9.81\\,\\text{m/s}^2)(4.0\\times 10^{3}\\,\\text{m})} = \\sqrt{39240} \\approx 198.090888\\,\\text{m/s} $$\nNext, calculate the term $ct$:\n$$ ct \\approx (198.090888\\,\\text{m/s})(6.0\\times 10^{2}\\,\\text{s}) \\approx 118854.5329\\,\\text{m} $$\nThe denominator in the exponent is $2\\sigma^2$:\n$$ 2\\sigma^{2} = 2(3.0\\times 10^{4}\\,\\text{m})^{2} = 2(9.0\\times 10^{8}\\,\\text{m}^2) = 1.8\\times 10^{9}\\,\\text{m}^2 $$\nThe solution with $x_0=0$ is:\n$$ \\eta(x,t) = \\frac{1.5}{2}\\left[\\exp\\!\\left(-\\frac{(x-ct)^{2}}{2\\sigma^{2}}\\right) + \\exp\\!\\left(-\\frac{(x+ct)^{2}}{2\\sigma^{2}}\\right)\\right] $$\nNow, evaluate the arguments of the exponential functions:\nFor the first term (right-propagating wave):\n$$ x-ct \\approx (1.0\\times 10^{5} - 118854.5329)\\,\\text{m} = -18854.5329\\,\\text{m} $$\n$$ -\\frac{(x-ct)^{2}}{2\\sigma^{2}} \\approx -\\frac{(-18854.5329)^{2}}{1.8\\times 10^{9}} \\approx -0.1974963 $$\nFor the second term (left-propagating wave):\n$$ x+ct \\approx (1.0\\times 10^{5} + 118854.5329)\\,\\text{m} = 218854.5329\\,\\text{m} $$\n$$ -\\frac{(x+ct)^{2}}{2\\sigma^{2}} \\approx -\\frac{(218854.5329)^{2}}{1.8\\times 10^{9}} \\approx -26.60964 $$\nNow substitute these into the expression for $\\eta(x,t)$:\n$$ \\eta(1.0\\times 10^5, 6.0\\times 10^2) \\approx \\frac{1.5}{2}\\left[\\exp(-0.1974963) + \\exp(-26.60964)\\right] $$\n$$ \\eta(1.0\\times 10^5, 6.0\\times 10^2) \\approx 0.75\\left[0.8207914 + 2.77 \\times 10^{-12}\\right] $$\nThe second exponential term is negligible.\n$$ \\eta(1.0\\times 10^5, 6.0\\times 10^2) \\approx 0.75 \\times 0.8207914 \\approx 0.61559355\\,\\text{m} $$\nRounding to four significant figures, the displacement is $0.6156$ meters.", "answer": "$$ \\boxed{0.6156} $$", "id": "3618013"}, {"introduction": "A numerical model is only as reliable as its implementation is correct. This exercise introduces the Method of Manufactured Solutions (MMS), a rigorous and essential technique for code verification [@problem_id:3618014]. You will construct a known analytical solution, derive the corresponding source terms that force the governing equations, and then run your numerical simulation to confirm that it converges to the exact solution at the theoretically expected rate, thereby building confidence in your solver.", "problem": "Consider the one-dimensional linearized depth-averaged shallow water equations used for tsunami wave propagation around a state of rest over constant bathymetry. Let $x \\in [0,L]$ with periodic boundary conditions and time $t \\in [0,T]$. The unknowns are the free-surface elevation $\\eta(x,t)$ in meters and the depth-averaged horizontal velocity $u(x,t)$ in meters per second. The governing equations are\n$$\n\\eta_t + h_0 u_x = S_\\eta(x,t), \\qquad u_t + g \\eta_x = S_u(x,t),\n$$\nwhere $h_0$ is the constant still-water depth in meters, $g$ is gravitational acceleration in meters per second squared, and $S_\\eta,S_u$ are externally prescribed source terms. The domain is periodic in $x$.\n\nUse the method of manufactured solutions to verify the formal space–time order of accuracy of a numerical implementation. Specifically, you must:\n- Start from the conservation of mass and momentum in a depth-averaged layer, linearized about rest with constant depth, which yields the system above. This is the only starting point you may assume.\n- Choose smooth, spatially periodic manufactured fields $\\eta(x,t)$ and $u(x,t)$ and analytically derive source terms $S_\\eta(x,t)$ and $S_u(x,t)$ such that the chosen $\\eta(x,t)$ and $u(x,t)$ satisfy the forced system for all $x,t$.\n- Implement a solver using a second-order accurate central finite difference in space and a second-order Strong Stability Preserving Runge–Kutta (SSP-RK2) method in time. Use periodic boundary conditions. To compute time steps for stability, use a Courant–Friedrichs–Lewy condition based on the linear wave speed $c=\\sqrt{g h_0}$: choose $\\Delta t = \\text{CFL}\\, \\Delta x/c$ and adjust to land exactly at final time $T$ by using an integer number of steps.\n- For an alternative temporal-accuracy verification, implement a spectral derivative operator using the Fast Fourier Transform so that spatial discretization error is negligible.\n- For an alternative spatial-accuracy verification, implement a classical fourth-order Runge–Kutta method (RK4) in time with a $\\Delta t$ proportional to $\\Delta x$ so that temporal error is negligible compared to second-order spatial error.\n\nManufactured solution. You must use the following smooth manufactured solution on a periodic domain of length $L$:\n$$\n\\phi(x,t) = \\kappa x - \\omega t, \\qquad \\psi(x,t) = 2\\kappa x + \\omega t,\n$$\n$$\n\\eta(x,t) = A \\cos(\\phi(x,t)) + B \\sin(\\psi(x,t)), \\qquad u(x,t) = C \\sin(\\phi(x,t)) + D \\cos(\\psi(x,t)),\n$$\nwhere $A,B$ are in meters, $C,D$ are in meters per second, $\\kappa = 2\\pi m/L$ for an integer wavenumber $m$, and $\\omega$ is an angular frequency in radians per second. From the governing equations and these definitions, analytically derive $S_\\eta(x,t)$ and $S_u(x,t)$ in closed form using only differentiation and algebra.\n\nNumerical method. Your implementation must:\n- Discretize $x$ uniformly with $N$ points, $\\Delta x = L/N$, with periodic boundary conditions.\n- Use second-order central differences for $f_x$: $f_x[i] \\approx \\left(f[i+1]-f[i-1]\\right)/(2\\Delta x)$ for the combined space–time test.\n- Use a spectral derivative $f_x = \\mathcal{F}^{-1}\\{ i k \\,\\mathcal{F}\\{f\\}\\}$ (with $k$ the Fourier wavenumbers matching the periodic domain) for the temporal order test.\n- Advance in time using SSP-RK2 for the combined and temporal tests and use classical fourth-order Runge–Kutta for the purely spatial order test with $\\Delta t = C_t \\Delta x/c$ for a constant $C_t$.\n\nVerification protocol. For each test, compute the relative root-mean-square error at final time $t=T$:\n$$\nE = \\frac{\\sqrt{\\frac{1}{N}\\sum_{i=0}^{N-1}\\left[\\left(\\eta_i^{\\text{num}}-\\eta(x_i,T)\\right)^2 + \\left(u_i^{\\text{num}}-u(x_i,T)\\right)^2\\right]}}{\\sqrt{\\frac{1}{N}\\sum_{i=0}^{N-1}\\left[\\eta(x_i,T)^2 + u(x_i,T)^2\\right]}}.\n$$\nUse a refinement study with factor-of-two changes to estimate observed convergence orders as follows. Given errors $E_1$ and $E_2$ computed with resolutions $(\\Delta x_1,\\Delta t_1)$ and $(\\Delta x_2,\\Delta t_2)$ where $\\Delta x_2 = \\Delta x_1/2$ and $\\Delta t_2 = \\Delta t_1/2$ (or only $\\Delta t$ halved for the temporal test), compute the observed order\n$$\np = \\log_2\\left(\\frac{E_1}{E_2}\\right).\n$$\n\nPhysical constants and parameters. Use $g = 9.81$ in meters per second squared, $h_0 = 4000$ in meters, $L = 100000$ in meters, $m = 3$, $A = 0.5$ in meters, $B = 0.3$ in meters, $C = 0.2$ in meters per second, $D = 0.15$ in meters per second, and $\\omega = 0.01$ in radians per second. The initial condition must be set from the manufactured solution at $t=0$ and the source terms must be evaluated consistently in time at each stage of the chosen Runge–Kutta method.\n\nTest suite. Run the following three verifications:\n- Test $1$ (combined space–time order with SSP-RK2 and second-order central differences): use $N \\in \\{64, 128, 256\\}$, $\\text{CFL} = 0.2$, $T = 100$ in seconds. Estimate and report $p_{\\text{combined}}$ using the two finest grids $N=128$ and $N=256$.\n- Test $2$ (temporal order with SSP-RK2 and spectral derivative): use $N = 256$, $T = 100$ in seconds, and two time step counts $M \\in \\{250, 500\\}$ so that $\\Delta t = T/M$ with $\\Delta t_2 = \\Delta t_1/2$; estimate and report $p_{\\text{time}}$.\n- Test $3$ (spatial order with second-order central differences and RK4 in time): use $N \\in \\{64, 128, 256\\}$, $T = 100$ in seconds, and $\\Delta t = C_t \\Delta x/c$ with $C_t = 0.1$; estimate and report $p_{\\text{space}}$ using the two finest grids.\n\nFinal output format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order $[p_{\\text{combined}},p_{\\text{time}},p_{\\text{space}}]$. Each value must be a floating-point number rounded to three decimal places, with no additional text. All angles used in trigonometric functions are in radians. All lengths must be in meters and time in seconds. Express the final output as dimensionless convergence orders rounded to three decimals. Ensure that the program is entirely self-contained and requires no input.", "solution": "The problem provides a complete and well-posed description for a verification study of a numerical scheme for the linearized shallow water equations. It is scientifically sound, contains all necessary parameters, and outlines a clear procedure based on the method of manufactured solutions. The problem is therefore deemed valid.\n\nThe solution process involves three main stages:\n1.  Analytical derivation of the source terms required for the method of manufactured solutions.\n2.  Implementation of the numerical solver, including spatial discretization and temporal integration schemes.\n3.  Execution of the specified numerical experiments to measure the convergence orders.\n\n### 1. Analytical Derivation of Source Terms\n\nThe governing equations are the one-dimensional linearized shallow water equations on a periodic domain $x \\in [0,L]$:\n$$\n\\eta_t + h_0 u_x = S_\\eta(x,t)\n$$\n$$\nu_t + g \\eta_x = S_u(x,t)\n$$\nHere, $\\eta(x,t)$ is the free-surface elevation, $u(x,t)$ is the depth-averaged velocity, $h_0$ is the constant water depth, $g$ is gravitational acceleration, and $S_\\eta, S_u$ are source terms to be determined.\n\nThe problem specifies the following manufactured solutions:\n$$\n\\eta(x,t) = A \\cos(\\kappa x - \\omega t) + B \\sin(2\\kappa x + \\omega t)\n$$\n$$\nu(x,t) = C \\sin(\\kappa x - \\omega t) + D \\cos(2\\kappa x + \\omega t)\n$$\nwith $\\phi(x,t) = \\kappa x - \\omega t$ and $\\psi(x,t) = 2\\kappa x + \\omega t$. To find the source terms $S_\\eta$ and $S_u$ that make these expressions exact solutions, we first compute the necessary partial derivatives of $\\eta$ and $u$.\n\nThe partial derivatives with respect to time $t$ are:\n$$\n\\eta_t = \\frac{\\partial}{\\partial t} [A \\cos(\\phi) + B \\sin(\\psi)] = A(-\\sin(\\phi))(-\\omega) + B(\\cos(\\psi))(\\omega) = A\\omega \\sin(\\phi) + B\\omega \\cos(\\psi)\n$$\n$$\nu_t = \\frac{\\partial}{\\partial t} [C \\sin(\\phi) + D \\cos(\\psi)] = C(\\cos(\\phi))(-\\omega) + D(-\\sin(\\psi))(\\omega) = -C\\omega \\cos(\\phi) - D\\omega \\sin(\\psi)\n$$\n\nThe partial derivatives with respect to space $x$ are:\n$$\n\\eta_x = \\frac{\\partial}{\\partial x} [A \\cos(\\phi) + B \\sin(\\psi)] = A(-\\sin(\\phi))(\\kappa) + B(\\cos(\\psi))(2\\kappa) = -A\\kappa \\sin(\\phi) + 2B\\kappa \\cos(\\psi)\n$$\n$$\nu_x = \\frac{\\partial}{\\partial x} [C \\sin(\\phi) + D \\cos(\\psi)] = C(\\cos(\\phi))(\\kappa) + D(-\\sin(\\psi))(2\\kappa) = C\\kappa \\cos(\\phi) - 2D\\kappa \\sin(\\psi)\n$$\n\nSubstituting these derivatives into the governing equations allows us to solve for the source terms:\n$$\nS_\\eta(x,t) = \\eta_t + h_0 u_x = (A\\omega \\sin(\\phi) + B\\omega \\cos(\\psi)) + h_0(C\\kappa \\cos(\\phi) - 2D\\kappa \\sin(\\psi))\n$$\n$$\nS_u(x,t) = u_t + g \\eta_x = (-C\\omega \\cos(\\phi) - D\\omega \\sin(\\psi)) + g(-A\\kappa \\sin(\\phi) + 2B\\kappa \\cos(\\psi))\n$$\nRearranging these expressions gives the final analytical forms for the source terms, which will be implemented in the numerical code:\n$$\nS_\\eta(x,t) = A\\omega \\sin(\\kappa x - \\omega t) + h_0 C\\kappa \\cos(\\kappa x - \\omega t) + B\\omega \\cos(2\\kappa x + \\omega t) - 2h_0 D\\kappa \\sin(2\\kappa x + \\omega t)\n$$\n$$\nS_u(x,t) = -gA\\kappa \\sin(\\kappa x - \\omega t) - C\\omega \\cos(\\kappa x - \\omega t) + 2gB\\kappa \\cos(2\\kappa x + \\omega t) - D\\omega \\sin(2\\kappa x + \\omega t)\n$$\n\n### 2. Numerical Discretization\n\nThe spatial domain $x \\in [0,L]$ is discretized into $N$ points $x_i = i\\Delta x$ for $i=0, 1, ..., N-1$, with grid spacing $\\Delta x = L/N$. The state of the system at any time $t$ is represented by a vector $\\mathbf{U}(t) = [\\eta_0, \\dots, \\eta_{N-1}, u_0, \\dots, u_{N-1}]^T$. The governing equations are rewritten as a system of ordinary differential equations (ODEs):\n$$\n\\frac{d\\mathbf{U}}{dt} = \\mathbf{F}(t, \\mathbf{U}) = \\begin{pmatrix} -h_0 (\\boldsymbol{\\eta}_d)_x + \\mathbf{S}_\\eta(t) \\\\ -g (\\boldsymbol{u}_d)_x + \\mathbf{S}_u(t) \\end{pmatrix}\n$$\nwhere $(\\cdot)_x$ represents a spatial derivative operator and $\\mathbf{S}_\\eta, \\mathbf{S}_u$ are the source terms evaluated at the grid points. Two different spatial derivative operators are required.\n\n**Second-Order Central Differences**: For a periodic function $f$ on the grid, the derivative at point $x_i$ is approximated as:\n$$\nf_x(x_i) \\approx \\frac{f_{i+1} - f_{i-1}}{2\\Delta x}\n$$\nwhere indices are taken modulo $N$ to enforce periodicity. This method is second-order accurate, i.e., the error is $O(\\Delta x^2)$.\n\n**Spectral Derivative**: To achieve high spatial accuracy, a spectral method using the Fast Fourier Transform (FFT) is employed. The derivative is computed in Fourier space:\n$$\nf_x(x) = \\mathcal{F}^{-1}\\{ i k \\,\\mathcal{F}\\{f(x)\\}\\}\n$$\nwhere $\\mathcal{F}$ is the FFT, $\\mathcal{F}^{-1}$ is the inverse FFT, $i = \\sqrt{-1}$, and $k$ is the vector of wavenumbers corresponding to the discretized domain. This method is spectrally accurate, meaning its error decreases faster than any power of $\\Delta x$ for smooth functions.\n\n### 3. Temporal Integration\n\nThe ODE system is advanced in time using one of two specified Runge-Kutta methods.\n\n**SSP-RK2**: The second-order Strong Stability Preserving Runge-Kutta method (also known as Heun's method) is used for the combined space-time and purely temporal tests. For an ODE $y' = f(t,y)$, a single time step from $t_n$ to $t_{n+1} = t_n + \\Delta t$ is:\n1. $\\mathbf{U}^{(1)} = \\mathbf{U}_n + \\Delta t \\mathbf{F}(t_n, \\mathbf{U}_n)$\n2. $\\mathbf{U}_{n+1} = \\frac{1}{2}\\mathbf{U}_n + \\frac{1}{2}(\\mathbf{U}^{(1)} + \\Delta t \\mathbf{F}(t_{n+1}, \\mathbf{U}^{(1)}))$\nThis method is second-order accurate in time, with error $O(\\Delta t^2)$.\n\n**RK4**: The classical fourth-order Runge-Kutta method is used for the spatial accuracy test to ensure temporal errors are negligible compared to the second-order spatial errors. For $y' = f(t,y)$, one step is:\n1. $k_1 = \\mathbf{F}(t_n, \\mathbf{U}_n)$\n2. $k_2 = \\mathbf{F}(t_n + \\Delta t/2, \\mathbf{U}_n + \\Delta t/2 \\cdot k_1)$\n3. $k_3 = \\mathbf{F}(t_n + \\Delta t/2, \\mathbf{U}_n + \\Delta t/2 \\cdot k_2)$\n4. $k_4 = \\mathbf{F}(t_n + \\Delta t, \\mathbf{U}_n + \\Delta t \\cdot k_3)$\n5. $\\mathbf{U}_{n+1} = \\mathbf{U}_n + \\frac{\\Delta t}{6}(k_1 + 2k_2 + 2k_3 + k_4)$\nThis method has a temporal error of $O(\\Delta t^4)$.\n\n### 4. Verification Protocol\n\nFor each test, the numerical simulation is initialized with the manufactured solution at $t=0$ and run until the final time $T$. The error is computed using the relative root-mean-square norm:\n$$\nE = \\frac{\\sqrt{\\sum_{i=0}^{N-1}\\left[(\\eta_i^{\\text{num}}-\\eta(x_i,T))^2 + (u_i^{\\text{num}}-u(x_i,T))^2\\right]}}{\\sqrt{\\sum_{i=0}^{N-1}\\left[\\eta(x_i,T)^2 + u(x_i,T)^2\\right]}}\n$$\nThe observed order of convergence, $p$, is estimated from the errors $E_1$ and $E_2$ corresponding to two different resolutions (e.g., $\\Delta x_1$ and $\\Delta x_2 = \\Delta x_1/2$) using the formula:\n$$\np = \\log_2\\left(\\frac{E_1}{E_2}\\right)\n$$\n\nThe three required tests are:\n-   **Test 1 (Combined space-time order)**: Uses the second-order central difference scheme and the SSP-RK$2$ time integrator. The time step $\\Delta t$ is coupled to the grid spacing $\\Delta x$ via a fixed CFL number. Since both spatial and temporal methods are second-order, the expected convergence order is $p_{\\text{combined}} \\approx 2$.\n-   **Test 2 (Temporal order)**: Uses the highly accurate spectral derivative to make spatial discretization error negligible. Time is advanced with SSP-RK$2$. The test is run with a fixed spatial grid and two different time steps. The expected convergence order is $p_{\\text{time}} \\approx 2$, matching the order of the SSP-RK$2$ integrator.\n-   **Test 3 (Spatial order)**: Uses the second-order central difference scheme and the high-order RK$4$ time integrator. The time step is chosen to be proportional to $\\Delta x$, such that the fourth-order temporal error $O(\\Delta t^4) \\propto O(\\Delta x^4)$ is dominated by the second-order spatial error $O(\\Delta x^2)$. The expected convergence order is $p_{\\text{space}} \\approx 2$, matching the order of the central difference scheme.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import fft\n\ndef solve():\n    \"\"\"\n    Solves the problem by performing three verification tests for a numerical scheme\n    of the linearized shallow water equations using the method of manufactured solutions.\n    \"\"\"\n\n    # Physical constants and problem parameters\n    g = 9.81\n    h0 = 4000.0\n    L = 100000.0\n    m = 3\n    A = 0.5\n    B = 0.3\n    C = 0.2\n    D = 0.15\n    omega = 0.01\n    T_final = 100.0\n    \n    # Derived parameters\n    c = np.sqrt(g * h0)\n    kappa = 2.0 * np.pi * m / L\n\n    # --- Analytical Functions ---\n    def eta_manufactured(x, t):\n        phi = kappa * x - omega * t\n        psi = 2.0 * kappa * x + omega * t\n        return A * np.cos(phi) + B * np.sin(psi)\n\n    def u_manufactured(x, t):\n        phi = kappa * x - omega * t\n        psi = 2.0 * kappa * x + omega * t\n        return C * np.sin(phi) + D * np.cos(psi)\n\n    def source_eta(x, t):\n        phi = kappa * x - omega * t\n        psi = 2.0 * kappa * x + omega * t\n        term1 = A * omega * np.sin(phi)\n        term2 = h0 * C * kappa * np.cos(phi)\n        term3 = B * omega * np.cos(psi)\n        term4 = -2.0 * h0 * D * kappa * np.sin(psi)\n        return term1 + term2 + term3 + term4\n\n    def source_u(x, t):\n        phi = kappa * x - omega * t\n        psi = 2.0 * kappa * x + omega * t\n        term1 = -g * A * kappa * np.sin(phi)\n        term2 = -C * omega * np.cos(phi)\n        term3 = 2.0 * g * B * kappa * np.cos(psi)\n        term4 = -D * omega * np.sin(psi)\n        return term1 + term2 + term3 + term4\n\n    # --- Numerical Components ---\n    def central_diff_2nd(f, dx):\n        return (np.roll(f, -1) - np.roll(f, 1)) / (2.0 * dx)\n\n    def spectral_diff(f, dx):\n        N = len(f)\n        k_freq = fft.fftfreq(N, d=dx)\n        k = 2.0 * np.pi * k_freq\n        f_hat = fft.fft(f)\n        df_hat = 1j * k * f_hat\n        return fft.ifft(df_hat).real\n\n    def rhs(t, y, N, dx, derivative_op):\n        eta_num = y[:N]\n        u_num = y[N:]\n        x = np.linspace(0, L, N, endpoint=False)\n        \n        eta_x = derivative_op(eta_num, dx)\n        u_x = derivative_op(u_num, dx)\n        \n        d_eta_dt = -h0 * u_x + source_eta(x, t)\n        d_u_dt = -g * eta_x + source_u(x, t)\n        \n        return np.concatenate((d_eta_dt, d_u_dt))\n\n    def ssp_rk2_step(t, y, dt, N, dx, derivative_op):\n        y1 = y + dt * rhs(t, y, N, dx, derivative_op)\n        y_next = 0.5 * y + 0.5 * (y1 + dt * rhs(t + dt, y1, N, dx, derivative_op))\n        return y_next\n\n    def rk4_step(t, y, dt, N, dx, derivative_op):\n        k1 = rhs(t, y, N, dx, derivative_op)\n        k2 = rhs(t + 0.5 * dt, y + 0.5 * dt * k1, N, dx, derivative_op)\n        k3 = rhs(t + 0.5 * dt, y + 0.5 * dt * k2, N, dx, derivative_op)\n        k4 = rhs(t + dt, y + dt * k3, N, dx, derivative_op)\n        return y + (dt / 6.0) * (k1 + 2.0 * k2 + 2.0 * k3 + k4)\n\n    def calculate_error(eta_num, u_num, eta_exact, u_exact):\n        err_sq_sum = np.sum((eta_num - eta_exact)**2 + (u_num - u_exact)**2)\n        norm_sq_sum = np.sum(eta_exact**2 + u_exact**2)\n        return np.sqrt(err_sq_sum / norm_sq_sum)\n\n    def run_simulation(N, T, dt_calculator, time_stepper, derivative_op):\n        dx = L / N\n        x = np.linspace(0, L, N, endpoint=False)\n        \n        dt_candidate = dt_calculator(dx)\n        if dt_candidate > 0:\n            num_steps = int(np.ceil(T / dt_candidate))\n            dt = T / num_steps\n        else: # Temporal test where dt is fixed per run via negative signal\n            dt_fixed = -dt_candidate\n            num_steps = int(round(T / dt_fixed))\n            dt = T / num_steps\n        \n        eta_0 = eta_manufactured(x, 0.0)\n        u_0 = u_manufactured(x, 0.0)\n        y = np.concatenate((eta_0, u_0))\n        t = 0.0\n        \n        for _ in range(num_steps):\n            y = time_stepper(t, y, dt, N, dx, derivative_op)\n            t += dt\n            \n        eta_final_num = y[:N]\n        u_final_num = y[N:]\n        eta_final_exact = eta_manufactured(x, T)\n        u_final_exact = u_manufactured(x, T)\n        \n        return calculate_error(eta_final_num, u_final_num, eta_final_exact, u_final_exact)\n\n    # --- Verification Tests ---\n\n    # Test 1: Combined space-time order\n    cfl_1 = 0.2\n    dt_calc_1 = lambda dx: cfl_1 * dx / c\n    errors_1 = []\n    for N in [64, 128, 256]:\n        error = run_simulation(N, T_final, dt_calc_1, ssp_rk2_step, central_diff_2nd)\n        errors_1.append(error)\n    p_combined = np.log2(errors_1[-2] / errors_1[-1])\n\n    # Test 2: Temporal order\n    N_test2 = 256\n    errors_2 = []\n    for M in [250, 500]:\n        dt_fixed = T_final / M\n        dt_calc_2 = lambda dx: -dt_fixed\n        error = run_simulation(N_test2, T_final, dt_calc_2, ssp_rk2_step, spectral_diff)\n        errors_2.append(error)\n    p_time = np.log2(errors_2[0] / errors_2[1])\n    \n    # Test 3: Spatial order\n    cfl_3 = 0.1\n    dt_calc_3 = lambda dx: cfl_3 * dx / c\n    errors_3 = []\n    for N in [64, 128, 256]:\n        error = run_simulation(N, T_final, dt_calc_3, rk4_step, central_diff_2nd)\n        errors_3.append(error)\n    p_space = np.log2(errors_3[-2] / errors_3[-1])\n\n    # Final result printing\n    print(f\"[{p_combined:.3f},{p_time:.3f},{p_space:.3f}]\")\n\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3618014"}, {"introduction": "In real-world applications, we often use simplified models to invert complex observational data, a process that can introduce systematic errors. This practice tackles the sophisticated issue of modeling bias by deliberately avoiding 'inverse crime'—the act of using the same model for both data generation and inversion [@problem_id:3618072]. By generating synthetic data with a more physically realistic dispersive model and inverting it with the non-dispersive shallow-water equations, you will quantify the inherent bias and gain critical insight into the limitations of source inversion results.", "problem": "You are tasked with designing and implementing a program that quantifies modeling bias in tsunami wave propagation by avoiding inverse crime. Specifically, you must generate synthetic sea-surface elevation data using a weakly dispersive Boussinesq model and invert for an initial sea-surface displacement using the linearized Shallow-Water Equations (SWE), then compute an aggregate misfit norm across multiple observation stations.\n\nThe fundamental base for this problem is as follows. For linear long waves in constant depth, the linearized Shallow-Water Equations (SWE) reduce to the one-dimensional wave equation for the free-surface elevation $\\,\\eta(x,t)\\,$,\n$$\n\\eta_{tt}(x,t) \\;=\\; c^2\\,\\eta_{xx}(x,t),\n$$\nwhere $c = \\sqrt{g h}$ is the non-dispersive phase speed, $g$ is gravitational acceleration, and $h$ is uniform water depth. For a periodic domain and zero initial velocity, all spatial Fourier modes evolve as\n$$\n\\eta_k(x,t) \\;=\\; \\left[A_k \\cos(k x) + B_k \\sin(k x)\\right] \\cos\\!\\left(c\\,|k|\\,t\\right),\n$$\nwhere $A_k$ and $B_k$ are the Fourier cosine and sine coefficients of the initial displacement $\\eta_0(x) = \\eta(x,0)$, with $k$ the angular wavenumber.\n\nFor the weakly dispersive Boussinesq model, a commonly used linear dispersion relation modifies the SWE by reducing the angular frequency for higher wavenumbers. In this problem, the Boussinesq angular frequency is defined by\n$$\n\\omega_{\\mathrm{B}}^2(k) \\;=\\; \\frac{g h\\,k^2}{1 + \\frac{1}{3} h^2 k^2},\n$$\nwhich implies\n$$\n\\omega_{\\mathrm{B}}(k) \\;=\\; \\frac{c\\,|k|}{\\sqrt{1 + \\frac{1}{3} h^2 k^2}}.\n$$\nUnder zero initial velocity, the Boussinesq time evolution is then\n$$\n\\eta^{\\mathrm{true}}(x,t) \\;=\\; \\sum_{k} \\hat{\\eta}_0(k)\\,\\cos\\!\\left(\\omega_{\\mathrm{B}}(k)\\,t\\right)\\,e^{i k x},\n$$\nwhere $\\hat{\\eta}_0(k)$ are the complex Fourier coefficients of the true initial displacement $\\eta_0(x)$ in a periodic domain.\n\nYour program must proceed as follows:\n\n1. Domain and initial condition.\n   - Consider a one-dimensional periodic domain of length $L$ discretized with $N$ uniformly spaced points. Use angular wavenumbers $k_n = 2\\pi n/L$ for integer $n$ given by the discrete Fourier transform convention.\n   - Construct a physically plausible initial sea-surface displacement $\\eta_0(x)$ as a superposition of two Gaussian humps:\n     $$\n     \\eta_0(x) \\;=\\; A_1 \\exp\\!\\left(-\\frac{(x-x_1)^2}{2\\,\\sigma_1^2}\\right) \\;+\\; A_2 \\exp\\!\\left(-\\frac{(x-x_2)^2}{2\\,\\sigma_2^2}\\right),\n     $$\n     where $A_1$ and $A_2$ are amplitudes in meters, $x_1$ and $x_2$ are centers in meters, and $\\sigma_1$ and $\\sigma_2$ are standard deviations in meters.\n\n2. Data generation with the Boussinesq model.\n   - Define $S$ station positions $\\{x_s\\}_{s=1}^S$ aligned to grid points and a uniform time grid $\\{t_n\\}_{n=0}^{M-1}$ with time step $\\Delta t$.\n   - Generate synthetic “true” sea-surface elevation time series at stations, $\\eta^{\\mathrm{true}}(x_s,t_n)$, by evolving the initial condition with the Boussinesq dispersion relation as given above. Use discrete Fourier transforms to implement the periodic spectral evolution in time.\n\n3. Inversion with the Shallow-Water Equations (SWE).\n   - Invert the synthetic data to estimate a band-limited initial displacement using the linearized SWE model. Parametrize the estimated initial displacement in a truncated real Fourier series up to wavenumber index $K_{\\max}$:\n     $$\n     \\eta_0^{\\mathrm{inv}}(x) \\;=\\; a_0 \\;+\\; \\sum_{k=1}^{K_{\\max}} \\left[a_k \\cos\\!\\left(\\frac{2\\pi k}{L} x\\right) + b_k \\sin\\!\\left(\\frac{2\\pi k}{L} x\\right)\\right],\n     $$\n     with unknown real coefficients $\\{a_0, a_k, b_k\\}$.\n   - Under the SWE model and zero initial velocity, the predicted station time series are\n     $$\n     \\eta^{\\mathrm{SWE}}(x_s,t_n) \\;=\\; a_0 \\;+\\; \\sum_{k=1}^{K_{\\max}} \\left[a_k \\cos\\!\\left(\\frac{2\\pi k}{L} x_s\\right) + b_k \\sin\\!\\left(\\frac{2\\pi k}{L} x_s\\right)\\right] \\cos\\!\\left(c\\,\\frac{2\\pi k}{L}\\,t_n\\right).\n     $$\n   - Collect all station-time pairs into a linear least-squares system and solve for the coefficients $\\{a_0, a_k, b_k\\}$ that minimize the sum of squared differences between $\\eta^{\\mathrm{SWE}}(x_s,t_n)$ and $\\eta^{\\mathrm{true}}(x_s,t_n)$.\n\n4. Bias quantification.\n   - Define the aggregate bias norm across stations and times as the root-mean-square (RMS) difference\n     $$\n     \\|\\eta_{\\mathrm{true}} - \\eta_{\\mathrm{inv}}\\| \\;=\\; \\sqrt{\\frac{1}{S\\,M}\\sum_{s=1}^S \\sum_{n=0}^{M-1} \\left[\\eta^{\\mathrm{true}}(x_s,t_n) - \\eta^{\\mathrm{SWE}}(x_s,t_n)\\right]^2 }.\n     $$\n   - Express the bias norm in meters as a floating-point number.\n\nYour program should implement the above steps and evaluate the bias norm for the following three test cases. Each test case comprises physically meaningful parameters that vary the degree of dispersion and the inversion subspace to test different facets of the problem.\n\nTest Suite:\n- Case 1 (baseline, adequate bandwidth):\n  - $L = 200{,}000$ meters, $N = 1024$.\n  - $h = 4{,}000$ meters, $g = 9.81$ meters per second squared.\n  - Initial condition: $A_1 = 1.0$ meters, $x_1 = 50{,}000$ meters, $\\sigma_1 = 5{,}000$ meters; $A_2 = 0.5$ meters, $x_2 = 150{,}000$ meters, $\\sigma_2 = 8{,}000$ meters.\n  - Stations: $S = 5$ at $x_s \\in \\{20{,}000, 60{,}000, 100{,}000, 140{,}000, 180{,}000\\}$ meters.\n  - Time grid: $M = 256$, $\\Delta t = 2.0$ seconds.\n  - Truncation: $K_{\\max} = 16$.\n\n- Case 2 (underparameterized inversion subspace):\n  - Same as Case 1, except $K_{\\max} = 4$.\n\n- Case 3 (narrower source, deeper water, more samples):\n  - $L = 200{,}000$ meters, $N = 2048$.\n  - $h = 6{,}000$ meters, $g = 9.81$ meters per second squared.\n  - Initial condition: $A_1 = 1.0$ meters, $x_1 = 50{,}000$ meters, $\\sigma_1 = 2{,}000$ meters; $A_2 = 0.6$ meters, $x_2 = 150{,}000$ meters, $\\sigma_2 = 3{,}000$ meters.\n  - Stations: $S = 6$ at $x_s \\in \\{20{,}000, 50{,}000, 80{,}000, 110{,}000, 140{,}000, 170{,}000\\}$ meters.\n  - Time grid: $M = 400$, $\\Delta t = 1.5$ seconds.\n  - Truncation: $K_{\\max} = 24$.\n\nFinal Output Format:\n- Your program should produce a single line of output containing the three bias norms, each in meters, as a comma-separated list enclosed in square brackets (for example, “[result1,result2,result3]”), with each result expressed as a float. No additional text should be printed.\n\nAll physical quantities must be treated in their correct International System of Units (SI units). All angles in trigonometric functions are in radians. The bias norm must be reported in meters.", "solution": "The problem requires the quantification of modeling bias that arises when inverting synthetic tsunami data. The data are generated using a physically more complex, weakly dispersive Boussinesq model, while the inversion is performed using a simpler, non-dispersive linearized Shallow-Water Equations (SWE) model. This procedure, which avoids \"inverse crime\" (using the same model for data generation and inversion), provides a measure of the systematic error, or bias, inherent in the simpler inversion model. The solution is implemented by following a four-step process for each test case.\n\n### 1. Synthetic Data Generation: The Boussinesq Forward Model\n\nThe first step is to generate synthetic \"true\" sea-surface elevation data, $\\eta^{\\mathrm{true}}(x, t)$. This is achieved by numerically solving the Boussinesq model equations for a given initial sea-surface displacement, $\\eta_0(x)$.\n\nThe problem is defined on a one-dimensional periodic domain of length $L$, discretized into $N$ grid points $x_j = j L/N$ for $j = 0, 1, \\dots, N-1$. The initial condition $\\eta_0(x)$ is given as a superposition of two Gaussian functions:\n$$\n\\eta_0(x) = A_1 \\exp\\left(-\\frac{(x-x_1)^2}{2\\sigma_1^2}\\right) + A_2 \\exp\\left(-\\frac{(x-x_2)^2}{2\\sigma_2^2}\\right)\n$$\nThe evolution of the wavefield is most efficiently computed in the spectral domain using the Discrete Fourier Transform (DFT). First, the complex Fourier coefficients, $\\hat{\\eta}_0(k_n)$, of the initial condition $\\eta_0(x_j)$ are computed:\n$$\n\\hat{\\eta}_0(k_n) = \\mathcal{F}[\\eta_0(x)]\n$$\nwhere $\\mathcal{F}$ denotes the DFT, and $k_n = 2\\pi n/L$ are the angular wavenumbers corresponding to the discrete grid.\n\nThe Boussinesq model is characterized by its dispersion relation, which relates the angular frequency $\\omega_{\\mathrm{B}}$ to the wavenumber $k$:\n$$\n\\omega_{\\mathrm{B}}(k) = \\frac{c|k|}{\\sqrt{1 + \\frac{1}{3}h^2 k^2}}\n$$\nwhere $c = \\sqrt{gh}$ is the shallow-water wave speed, $g$ is the acceleration due to gravity, and $h$ is the water depth. For a zero initial velocity field, each Fourier mode evolves in time as $\\cos(\\omega_{\\mathrm{B}}(k)t)$. Thus, the Fourier coefficients at time $t$ are given by:\n$$\n\\hat{\\eta}(k, t) = \\hat{\\eta}_0(k) \\cos(\\omega_{\\mathrm{B}}(k)t)\n$$\nThe sea-surface elevation in physical space, $\\eta(x, t)$, is then recovered by applying the inverse DFT:\n$$\n\\eta^{\\mathrm{true}}(x, t) = \\mathcal{F}^{-1}[\\hat{\\eta}(k, t)]\n$$\nThis calculation is performed for each time step $t_n$ in the specified time grid $\\{t_n\\}_{n=0}^{M-1}$. The resulting wavefield is then sampled at the specified station locations $\\{x_s\\}_{s=1}^S$ to produce the synthetic time series data, which we denote as a data vector $\\mathbf{d}$ of length $S \\times M$.\n\n### 2. Inversion for Initial Conditions: The SWE Inverse Model\n\nThe second step is to use the generated data $\\mathbf{d}$ to infer the initial sea-surface displacement, but this time using the simpler linearized SWE model. The initial displacement is parameterized by a truncated real Fourier series with $1 + 2K_{\\max}$ unknown coefficients, $\\mathbf{m} = [a_0, a_1, b_1, \\dots, a_{K_{\\max}}, b_{K_{\\max}}]^T$:\n$$\n\\eta_0^{\\mathrm{inv}}(x) = a_0 + \\sum_{k=1}^{K_{\\max}} \\left[a_k \\cos\\left(\\frac{2\\pi k}{L} x\\right) + b_k \\sin\\left(\\frac{2\\pi k}{L} x\\right)\\right]\n$$\nUnder the SWE model, the dispersion relation is non-dispersive: $\\omega_{\\mathrm{SWE}}(k) = c|k|$. The time evolution of the parameterized initial condition at a station location $x_s$ and time $t_n$ is:\n$$\n\\eta^{\\mathrm{SWE}}(x_s, t_n) = a_0 + \\sum_{j=1}^{K_{\\max}} \\left[ a_j \\cos\\left(k_j x_s\\right) + b_j \\sin\\left(k_j x_s\\right) \\right] \\cos\\left(c k_j t_n\\right)\n$$\nwhere $k_j = 2\\pi j/L$. This equation establishes a linear relationship between the predicted data at all station-time pairs, $\\mathbf{d}_{\\mathrm{pred}}$, and the unknown model coefficients $\\mathbf{m}$:\n$$\n\\mathbf{d}_{\\mathrm{pred}} = \\mathbf{G}\\mathbf{m}\n$$\nHere, $\\mathbf{G}$ is the design matrix (or forward operator) of size $(S \\times M) \\times (1 + 2K_{\\max})$. Each row of $\\mathbf{G}$ corresponds to a specific station-time pair $(x_s, t_n)$, and its entries are the basis functions evaluated at that pair. Specifically, for a row corresponding to $(x_s, t_n)$:\n-   The first column (for coefficient $a_0$) is $1$.\n-   For $j=1, \\dots, K_{\\max}$, the column for $a_j$ is $\\cos(k_j x_s) \\cos(c k_j t_n)$.\n-   For $j=1, \\dots, K_{\\max}$, the column for $b_j$ is $\\sin(k_j x_s) \\cos(c k_j t_n)$.\n\n### 3. Solving the Linear System\n\nThe inverse problem consists of finding the model vector $\\mathbf{m}$ that best fits the synthetic data $\\mathbf{d}$. This is formulated as a linear least-squares problem:\n$$\n\\min_{\\mathbf{m}} \\|\\mathbf{G}\\mathbf{m} - \\mathbf{d}\\|_2^2\n$$\nwhere $\\|\\cdot\\|_2$ is the Euclidean norm. For the given test cases, the system is overdetermined ($S \\times M > 1 + 2K_{\\max}$), ensuring a stable and unique solution. The solution $\\mathbf{m}_{\\mathrm{inv}}$ is found using standard numerical linear algebra routines, such as those provided by `numpy.linalg.lstsq`.\n\n### 4. Quantifying the Modeling Bias\n\nThe modeling bias is the discrepancy between the \"true\" data and the best-fit data from the simpler model. The predicted data from the inverted coefficients is $\\mathbf{d}_{\\mathrm{inv}} = \\mathbf{G}\\mathbf{m}_{\\mathrm{inv}}$. The misfit is quantified by the root-mean-square (RMS) of the residuals, $r_i = d_i - d_{\\mathrm{inv},i}$:\n$$\n\\|\\eta_{\\mathrm{true}} - \\eta_{\\mathrm{inv}}\\| = \\sqrt{\\frac{1}{S M} \\sum_{i=1}^{S \\times M} (d_i - d_{\\mathrm{inv},i})^2}\n$$\nThis quantity is the square root of the mean of the squared residuals. The sum of squared residuals, $\\sum r_i^2$, is a direct output of the `numpy.linalg.lstsq` function, which allows for an efficient computation of the final bias norm in meters. The entire procedure is repeated for each of the three test cases provided.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_bias_norm(L, N, h, g, ic_params, station_locs, M, dt, K_max):\n    \"\"\"\n    Calculates the modeling bias norm for a single test case.\n\n    Args:\n        L (float): Length of the periodic domain in meters.\n        N (int): Number of grid points for spatial discretization.\n        h (float): Uniform water depth in meters.\n        g (float): Gravitational acceleration in m/s^2.\n        ic_params (tuple): Parameters for the initial condition (A1, x1, s1, A2, x2, s2).\n        station_locs (list): List of station locations in meters.\n        M (int): Number of time steps.\n        dt (float): Time step size in seconds.\n        K_max (int): Truncation wavenumber index for the inversion.\n\n    Returns:\n        float: The calculated aggregate bias norm in meters.\n    \"\"\"\n    # Unpack initial condition parameters\n    A1, x1, sigma1, A2, x2, sigma2 = ic_params\n    S = len(station_locs)\n\n    # Step 1: Define domain and construct initial condition\n    x_grid = np.linspace(0, L, N, endpoint=False)\n    eta0 = (A1 * np.exp(-(x_grid - x1)**2 / (2 * sigma1**2)) +\n            A2 * np.exp(-(x_grid - x2)**2 / (2 * sigma2**2)))\n\n    # Step 2: Generate \"true\" data using the Boussinesq model\n    eta0_hat = np.fft.fft(eta0)\n    k_vec = 2 * np.pi * np.fft.fftfreq(N, d=L / N)\n    \n    # Boussinesq angular frequency. This is numerically stable for k=0.\n    k_vec_sq = k_vec**2\n    omega_B_sq = (g * h * k_vec_sq) / (1 + (h**2 * k_vec_sq) / 3.0)\n    omega_B = np.sqrt(omega_B_sq)\n\n    t_grid = np.arange(M) * dt\n    \n    # Find grid indices for station locations\n    dx = L / N\n    station_indices = np.round(np.array(station_locs) / dx).astype(int)\n\n    eta_true_at_stations = np.zeros((S, M), dtype=float)\n    for i, tn in enumerate(t_grid):\n        # Evolve spectrum in time\n        eta_hat_t = eta0_hat * np.cos(omega_B * tn)\n        # Inverse FFT to get physical space solution\n        eta_t = np.fft.ifft(eta_hat_t).real\n        # Sample at station locations\n        eta_true_at_stations[:, i] = eta_t[station_indices]\n\n    # Step 3: Invert data using the Shallow-Water Equations (SWE) model\n    # 3a. Construct the linear system G*m = d\n    d_vec = eta_true_at_stations.flatten()\n    \n    num_data_points = S * M\n    num_model_params = 1 + 2 * K_max\n    \n    G = np.zeros((num_data_points, num_model_params))\n    \n    # Generate coordinate vectors for all (station, time) data points\n    t_coords = np.tile(t_grid, S)\n    x_coords = np.repeat(np.array(station_locs), M)\n    \n    # Column for a_0 (DC offset coefficient)\n    G[:, 0] = 1.0\n    \n    c = np.sqrt(g * h) # SWE phase speed\n\n    # Columns for a_k and b_k coefficients\n    for k_idx in range(1, K_max + 1):\n        wavenumber = 2 * np.pi * k_idx / L\n        \n        spatial_cos = np.cos(wavenumber * x_coords)\n        spatial_sin = np.sin(wavenumber * x_coords)\n        temporal_cos = np.cos(c * wavenumber * t_coords)\n        \n        # Column for a_k\n        G[:, 2 * k_idx - 1] = spatial_cos * temporal_cos\n        # Column for b_k\n        G[:, 2 * k_idx] = spatial_sin * temporal_cos\n        \n    # 3b. Solve the least-squares problem\n    _, residuals_sum_sq_array, _, _ = np.linalg.lstsq(G, d_vec, rcond=None)\n    \n    # Step 4: Quantify the modeling bias\n    if residuals_sum_sq_array.size > 0:\n        residuals_sum_sq = residuals_sum_sq_array[0]\n    else:\n        # Fallback for non-overdetermined systems (not expected here)\n        m_inv = np.linalg.lstsq(G, d_vec, rcond=None)[0]\n        d_pred = G @ m_inv\n        residuals_sum_sq = np.sum((d_vec - d_pred)**2)\n        \n    mean_squared_error = residuals_sum_sq / num_data_points\n    bias_norm = np.sqrt(mean_squared_error)\n    \n    return bias_norm\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (baseline, adequate bandwidth)\n        {\n            'L': 200000.0, 'N': 1024, 'h': 4000.0, 'g': 9.81,\n            'ic_params': (1.0, 50000.0, 5000.0, 0.5, 150000.0, 8000.0),\n            'station_locs': [20000.0, 60000.0, 100000.0, 140000.0, 180000.0],\n            'M': 256, 'dt': 2.0, 'K_max': 16\n        },\n        # Case 2 (underparameterized inversion subspace)\n        {\n            'L': 200000.0, 'N': 1024, 'h': 4000.0, 'g': 9.81,\n            'ic_params': (1.0, 50000.0, 5000.0, 0.5, 150000.0, 8000.0),\n            'station_locs': [20000.0, 60000.0, 100000.0, 140000.0, 180000.0],\n            'M': 256, 'dt': 2.0, 'K_max': 4\n        },\n        # Case 3 (narrower source, deeper water, more samples)\n        {\n            'L': 200000.0, 'N': 2048, 'h': 6000.0, 'g': 9.81,\n            'ic_params': (1.0, 50000.0, 2000.0, 0.6, 150000.0, 3000.0),\n            'station_locs': [20000.0, 50000.0, 80000.0, 110000.0, 140000.0, 170000.0],\n            'M': 400, 'dt': 1.5, 'K_max': 24\n        },\n    ]\n\n    results = []\n    for params in test_cases:\n        bias_norm = calculate_bias_norm(**params)\n        results.append(bias_norm)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3618072"}]}