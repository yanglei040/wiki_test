{"hands_on_practices": [{"introduction": "To model post-glacial rebound, we first must understand the fundamental physics of viscoelastic relaxation. This foundational exercise distills the process into its essential components, treating the Earth's mantle as a simple Maxwell viscoelastic half-space subjected to an instantaneous change in surface load. By deriving the time-dependent vertical displacement from first principles, you will gain a core understanding of the exponential relaxation behavior and its characteristic timescale, which underpins all more complex GIA models. [@problem_id:3610916]", "problem": "Consider post-glacial rebound modeled as the quasi-static vertical response of a Maxwell viscoelastic half-space representing the Earth's upper mantle to an instantaneous change in surface load at time $t=0$. Assume the mantle behaves as a linear Maxwell solid with shear viscosity $\\eta$ and shear modulus $\\mu$, and neglect inertial terms so that equilibrium is governed by force balance and compatibility. The removal or application of an ice load can be idealized as a uniform step change in surface pressure $p_{0}$, leading to a finite equilibrium vertical displacement $w_{\\infty}$ determined by isostatic balance. For a small perturbation about equilibrium, linear viscoelastic correspondence implies that the scalar misfit to equilibrium relaxes exponentially with a characteristic Maxwell time $\\tau$ that depends only on the mantle rheology.\n\nStarting from (i) quasi-static linear momentum balance, (ii) linear strain compatibility at the surface, and (iii) the Maxwell constitutive law relating deviatoric stress and strain rate, derive the scalar initial-value problem that governs the vertical displacement $w(t)$ at the surface following the step change in load at $t=0$, and obtain the displacement history $w(t)$ as a function of $t$, $\\eta$, $\\mu$, and $w_{\\infty}$. Then, using the parameters $\\eta = 1 \\times 10^{21} \\,\\mathrm{Pa\\,s}$, $\\mu = 7 \\times 10^{10} \\,\\mathrm{Pa}$, $w_{\\infty} = 10 \\,\\mathrm{m}$, and $t = 3000 \\,\\mathrm{yr}$, evaluate the displacement $w(t)$ numerically. Use the International System of Units for time ($\\mathrm{s}$), and round your final numerical answer to four significant figures. Express the final displacement in meters.", "solution": "The goal is to obtain the vertical displacement history $w(t)$ at the surface of a viscoelastic Maxwell half-space subjected to an instantaneous step change in surface pressure $p_{0}$ at $t=0$. We set up the problem using basic principles appropriate for quasi-static viscoelastic deformation.\n\nFirst, we recall the quasi-static linear momentum balance in the absence of inertia,\n$$\n\\nabla \\cdot \\boldsymbol{\\sigma} + \\rho \\boldsymbol{g} = \\boldsymbol{0},\n$$\nwhere $\\boldsymbol{\\sigma}$ is the Cauchy stress tensor, $\\rho$ is density, and $\\boldsymbol{g}$ is gravitational acceleration. At the free surface, a step change in applied surface pressure $p_{0}$ modifies the boundary traction instantaneously. The post-load vertical displacement $w(t)$ at the surface evolves as the mantle relaxes viscoelastically toward an isostatic equilibrium displacement $w_{\\infty}$ for which the net buoyant restoring force exactly balances the applied surface load change.\n\nTo model the viscoelastic response, we adopt the Maxwell constitutive law for deviatoric stress and strain. In one-dimensional scalar form appropriate for a single relaxation mode, the Maxwell relation between deviatoric stress $\\sigma$ and strain $\\epsilon$ can be written as\n$$\n\\dot{\\epsilon} = \\frac{\\dot{\\sigma}}{\\mu} + \\frac{\\sigma}{\\eta},\n$$\nwhere $\\mu$ is the elastic shear modulus, $\\eta$ is the shear viscosity, and overdots denote time derivatives. This is equivalent to the standard form for a Maxwell element (spring and dashpot in series) in terms of the relaxation of stress under imposed deformation.\n\nThe vertical displacement $w(t)$ at the surface arises from a combination of elastic shear deformation and viscous flow in the mantle. For a uniform axisymmetric response linearized about equilibrium, we can write the scalar misfit between the instantaneous displacement and its equilibrium counterpart as\n$$\n\\delta w(t) \\equiv w_{\\infty} - w(t).\n$$\nBecause $w_{\\infty}$ is the static displacement that balances the step load $p_{0}$ through isostatic restoring forces, $\\delta w$ is proportional to the deviatoric stress that remains to be relaxed. In a linear spring representation, we write\n$$\n\\sigma(t) = k \\,\\delta w(t),\n$$\nwhere $k$ is an effective scalar stiffness summarizing the geometric and elastic coupling in the half-space. The strain rate at the surface is proportional to the rate of change of displacement, $\\dot{\\epsilon} \\propto \\dot{w}$. Under the linearized one-mode approximation, we absorb geometric factors into $k$ so that the Maxwell law becomes a scalar evolution equation for $\\delta w(t)$.\n\nDifferentiating $\\sigma(t) = k \\,\\delta w(t)$ and substituting into the Maxwell relation yields\n$$\n\\dot{\\epsilon} = \\frac{k \\,\\dot{\\delta w}}{\\mu} + \\frac{k \\,\\delta w}{\\eta}.\n$$\nAt the surface, compatibility implies $\\dot{\\epsilon} \\propto -\\dot{\\delta w}$ because increasing $w$ reduces the misfit $\\delta w$. With proportionality constants absorbed into $k$ by linear rescaling, the evolution reduces to the canonical first-order relaxation equation for the misfit:\n$$\n\\dot{\\delta w}(t) = -\\frac{1}{\\tau} \\,\\delta w(t),\n$$\nwhere the characteristic Maxwell time is\n$$\n\\tau = \\frac{\\eta}{\\mu}.\n$$\nThis result can also be derived rigorously via the viscoelastic correspondence principle by replacing the elastic shear modulus in the elastic Green's function with the Maxwell relaxation modulus and taking the step-load limit; the outcome for a single Maxwell mode is exponential relaxation with time constant $\\tau$.\n\nSolving the initial-value problem $\\dot{\\delta w} = -\\delta w/\\tau$ with initial condition $\\delta w(0) = w_{\\infty} - w(0)$ and recognizing that the instantaneous elastic response at $t=0^{+}$ to a step load is bounded while the viscoelastic relaxation drives $w$ to $w_{\\infty}$, we obtain\n$$\n\\delta w(t) = \\delta w(0) \\,\\exp\\!\\left(-\\frac{t}{\\tau}\\right).\n$$\nFor a canonical step-load (or unload) experiment normalized so that the misfit at $t=0^{+}$ equals $w_{\\infty}$, the displacement history takes the standard form\n$$\nw(t) = w_{\\infty} \\left(1 - \\exp\\!\\left(-\\frac{t}{\\tau}\\right)\\right).\n$$\n\nWe now compute the numerical value of $w(t)$ for the given parameters. The Maxwell time is\n$$\n\\tau = \\frac{\\eta}{\\mu} = \\frac{1 \\times 10^{21} \\,\\mathrm{Pa\\,s}}{7 \\times 10^{10} \\,\\mathrm{Pa}} = \\frac{1}{7} \\times 10^{11} \\,\\mathrm{s} = 1.42857142857 \\times 10^{10} \\,\\mathrm{s}.\n$$\nThe time $t$ must be converted to seconds. One Julian year equals $365.25 \\times 24 \\times 3600 = 31{,}557{,}600 \\,\\mathrm{s}$. Therefore,\n$$\nt = 3000 \\,\\mathrm{yr} = 3000 \\times 31{,}557{,}600 \\,\\mathrm{s} = 9.46728 \\times 10^{10} \\,\\mathrm{s}.\n$$\nCompute the dimensionless ratio\n$$\n\\frac{t}{\\tau} = \\frac{9.46728 \\times 10^{10}}{1.42857142857 \\times 10^{10}} \\approx 6.627096.\n$$\nThen\n$$\n\\exp\\!\\left(-\\frac{t}{\\tau}\\right) = \\exp(-6.627096) \\approx 0.001324,\n$$\nand hence\n$$\nw(t) = 10 \\,\\mathrm{m} \\times \\left(1 - 0.001324\\right) \\approx 9.98676 \\,\\mathrm{m}.\n$$\nRounded to four significant figures, the displacement is\n$$\nw(t) \\approx 9.987 \\,\\mathrm{m}.\n$$", "answer": "$$\\boxed{9.987}$$", "id": "3610916"}, {"introduction": "Real-world glacial isostatic adjustment involves complex ice-load histories and the spherical geometry of the Earth, scenarios that demand a more general computational approach than simple analytical formulas. This practice introduces the powerful method of calculating viscoelastic response via the convolution of a load history with a pre-computed Green’s function. By implementing this numerical scheme for a time-dependent load represented in spherical harmonics, you will develop practical skills in a standard technique used in modern GIA modeling. [@problem_id:3611010]", "problem": "You are tasked with computing the instantaneous radial uplift displacement at a single station on the surface of a spherically symmetric, linear, viscoelastic Earth due to a time-dependent surface load represented by spherical harmonic coefficients. The goal is to rigorously derive and implement a numerical evaluation of the uplift at a specified observation time by convolving a tabulated degree-dependent load Green’s function with a piecewise-constant deglaciation history, and then projecting the harmonic coefficient onto the station location using real spherical harmonics. All angles must be handled in radians. All final displacement values must be expressed in meters.\n\nFoundational starting point. In a linear time-invariant physical system, the causal response to a source is a convolution. For spherical harmonic degree $l$ and order $m$, the radial displacement coefficient $u_{lm}(t)$ responds to a change in the load coefficient $\\hat{L}_{lm}(t)$ via the causal convolution with the degree-$l$ load Green’s function $G_l(t)$:\n$$\nu_{lm}(t) \\;=\\; \\int_{0}^{t} G_l(t - \\tau)\\, d\\hat{L}_{lm}(\\tau).\n$$\nFor a piecewise-constant load history, the measure $d\\hat{L}_{lm}(\\tau)$ reduces to a sum of step changes at the jump times, and therefore the integral reduces to a finite sum of step-response evaluations. The uplift at a station located at colatitude $\\theta$ and longitude $\\phi$ is obtained from spherical harmonic synthesis using real spherical harmonics. Restrict attention to zonal harmonics with $m=0$, for which the displacement contribution at a station is\n$$\nu(t,\\theta) \\;=\\; u_{l0}(t)\\, Y_{l0}(\\theta),\n$$\nwhere $Y_{l0}(\\theta)$ is the real zonal spherical harmonic of degree $l$, defined by\n$$\nY_{l0}(\\theta) \\;=\\; \\sqrt{\\frac{2l+1}{4\\pi}}\\;P_l(\\cos\\theta),\n$$\nand $P_l(x)$ is the Legendre polynomial of degree $l$ evaluated at $x=\\cos\\theta$. The spherical harmonic is dimensionless; the uplift $u(t,\\theta)$ is in meters when $u_{l0}(t)$ is in meters.\n\nNumerical evaluation mandate. You must compute $u_{l0}(T)$ at an observation time $T$ by summing the contributions of all load jumps up to $T$, each weighted by the tabulated step-response $G_l(\\Delta t)$ evaluated at the elapsed time since each jump, and then projecting onto the station via $Y_{l0}(\\theta)$. For a jump at time $t_k$ with magnitude $\\Delta \\hat{L}_{l0}(t_k)$, its contribution at $T$ is $\\Delta \\hat{L}_{l0}(t_k)\\,G_l(T - t_k)$. If $T - t_k$ is not a tabulated time, you must linearly interpolate $G_l$ between the nearest tabulated times. If $T - t_k$ exceeds the tabulated range, you must use the last tabulated value. If $T - t_k = 0$, use the first tabulated value. Angles must be treated in radians. The final output must be radial uplift in meters, expressed as floats.\n\nUnits and conventions. Time must be treated in kiloyears (kyr) for tabulation and interpolation of $G_l(t)$, angles must be in radians, and the displacement must be in meters. The load coefficient changes $\\Delta \\hat{L}_{l0}(t_k)$ are dimensionless normalized values. The tabulated $G_l(t)$ has units of meters per unit normalized load change.\n\nTest suite. Implement the computation for three independent test cases that collectively probe typical, interpolated, and boundary behaviors. In each case, you must:\n- Build the tabulated $G_l(t)$ on a uniform time grid from $t=0$ to $t=T$ with spacing $\\Delta t_G$ using the specified functional form and parameters.\n- Sum the jump contributions at the observation time $T$.\n- Multiply by $Y_{l0}(\\theta)$ evaluated at the specified station colatitude.\n\nYou must use the following three test cases:\n\n1. Case 1 (general two-step history, happy path):\n   - Degree $l$: $2$ and order $m=0$.\n   - Station colatitude: $45$ degrees (convert to radians).\n   - Observation time: $T = 10.0$ kyr.\n   - Load jumps: at $t_0 = 0.0$ kyr, $\\Delta \\hat{L}_{20}(t_0) = +1.0$; at $t_1 = 5.0$ kyr, $\\Delta \\hat{L}_{20}(t_1) = -1.0$.\n   - Tabulated step-response $G_2(t)$ is defined on $[0,T]$ with spacing $\\Delta t_G = 1.0$ kyr by\n     $$\n     G_2(t) \\;=\\; G_{\\infty} \\;-\\; \\left(G_{\\infty} - G_{0}\\right)\\exp\\!\\left(-\\frac{t}{\\tau}\\right),\n     $$\n     with $(G_{0},\\,G_{\\infty},\\,\\tau) = (0.4\\,\\text{m},\\,1.0\\,\\text{m},\\,3.0\\,\\text{kyr})$.\n\n2. Case 2 (coarse tabulation with interpolation, multiple negative jumps):\n   - Degree $l$: $2$ and order $m=0$.\n   - Station colatitude: $60$ degrees (convert to radians).\n   - Observation time: $T = 10.0$ kyr.\n   - Load jumps: at $t_0 = 2.0$ kyr, $\\Delta \\hat{L}_{20}(t_0) = -0.8$; at $t_1 = 4.0$ kyr, $\\Delta \\hat{L}_{20}(t_1) = -0.2$.\n   - Tabulated step-response $G_2(t)$ is defined on $[0,T]$ with spacing $\\Delta t_G = 2.0$ kyr by\n     $$\n     G_2(t) \\;=\\; G_{\\infty} \\;-\\; \\left(G_{\\infty} - G_{0}\\right)\\exp\\!\\left(-\\frac{t}{\\tau}\\right),\n     $$\n     with $(G_{0},\\,G_{\\infty},\\,\\tau) = (0.5\\,\\text{m},\\,1.1\\,\\text{m},\\,2.5\\,\\text{kyr})$.\n\n3. Case 3 (boundary case at observation time, constant response):\n   - Degree $l$: $1$ and order $m=0$.\n   - Station colatitude: $30$ degrees (convert to radians).\n   - Observation time: $T = 5.0$ kyr.\n   - Load jumps: at $t_0 = 5.0$ kyr, $\\Delta \\hat{L}_{10}(t_0) = +0.5$.\n   - Tabulated step-response $G_1(t)$ is defined on $[0,T]$ with spacing $\\Delta t_G = 1.0$ kyr by\n     $$\n     G_1(t) \\;=\\; G_{\\infty} \\;-\\; \\left(G_{\\infty} - G_{0}\\right)\\exp\\!\\left(-\\frac{t}{\\tau}\\right),\n     $$\n     with $(G_{0},\\,G_{\\infty},\\,\\tau) = (0.7\\,\\text{m},\\,0.7\\,\\text{m},\\,1.0\\,\\text{kyr})$, which yields a constant $G_1(t)=0.7$ m for all $t$.\n\nOutput specification. Your program should produce a single line of output containing the three case results as a comma-separated list enclosed in square brackets, in meters, each rounded to six decimal places, in the order Case 1, Case 2, Case 3. For example:\n\"[result_case1,result_case2,result_case3]\".", "solution": "The solution implements a numerical procedure that computes the radial uplift for each test case by following three main steps.\n\n**1. Tabulate the Green's Function**\n\nFor each degree $l$, observation time $T$, and grid spacing $\\Delta t_G$, a table of values for the Green's function $G_l(t)$ is constructed over the time interval $[0, T]$. The function, representing a single Maxwell relaxation mode, is given by:\n$$G_l(t) = G_{\\infty} - (G_{\\infty} - G_{0})\\exp(-t/\\tau)$$\nThe time grid is uniform, running from $t=0$ to $t=T$.\n\n**2. Compute the Harmonic Displacement Coefficient**\n\nThe harmonic displacement coefficient $u_{l0}(T)$ is calculated by summing the contributions from each specified load jump, based on the principle of linear superposition. For a jump $\\Delta \\hat{L}_{l0}(t_k)$ at time $t_k$, its contribution to the displacement at observation time $T$ is:\n$$\\text{Contribution}_k = \\Delta \\hat{L}_{l0}(t_k) \\cdot G_l(T - t_k)$$\nThe total harmonic coefficient is the sum of these contributions:\n$$u_{l0}(T) = \\sum_{k} \\text{Contribution}_k$$\nThe value of the Green's function $G_l(T - t_k)$ is obtained from the table generated in Step 1. The problem specifies a precise protocol: if the elapsed time $T - t_k$ does not fall exactly on a tabulated point, linear interpolation is used. If the elapsed time is outside the tabulated range, the nearest endpoint value is used (the first value for $t=0$, the last for $t>T$). This behavior is handled efficiently by standard numerical library functions like `numpy.interp`.\n\n**3. Project to Station Location**\n\nFinally, the physical radial uplift $u(T, \\theta)$ at the station's colatitude $\\theta$ is computed by multiplying the harmonic coefficient $u_{l0}(T)$ by the corresponding real zonal spherical harmonic $Y_{l0}(\\theta)$:\n$$u(T, \\theta) = u_{l0}(T) \\cdot Y_{l0}(\\theta)$$\nThe spherical harmonic is calculated using its definition, which involves the Legendre polynomial $P_l(\\cos\\theta)$:\n$$Y_{l0}(\\theta) = \\sqrt{\\frac{2l+1}{4\\pi}} P_l(\\cos\\theta)$$\nThis three-step procedure is applied to each test case to generate the final results.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import eval_legendre\n\ndef solve():\n    \"\"\"\n    Solves the post-glacial rebound problem for three test cases\n    and prints the results in the specified format.\n    \"\"\"\n\n    def calculate_uplift(l, theta_deg, T, load_jumps, G_params, dt_G):\n        \"\"\"\n        Computes the instantaneous radial uplift for a single test case.\n\n        Args:\n            l (int): Spherical harmonic degree.\n            theta_deg (float): Station colatitude in degrees.\n            T (float): Observation time in kyr.\n            load_jumps (list): A list of tuples (t_k, delta_L) representing\n                               load jumps at time t_k with magnitude delta_L.\n            G_params (tuple): A tuple (G0, G_inf, tau) for the Green's function.\n            dt_G (float): Time grid spacing for the Green's function table in kyr.\n\n        Returns:\n            float: The calculated radial uplift in meters.\n        \"\"\"\n        G0, G_inf, tau = G_params\n\n        # Convert station colatitude from degrees to radians for calculations.\n        theta_rad = np.deg2rad(theta_deg)\n\n        # Step 1: Build the tabulated Green's function G_l(t).\n        # The grid is uniform from t=0 to t=T. Using np.linspace is robust for\n        # ensuring the endpoint T is included.\n        # The number of points is int(T/dt_G) + 1. round() adds robustness for floating point arithmetic.\n        num_points = int(round(T / dt_G)) + 1\n        t_table = np.linspace(0.0, T, num_points)\n        \n        # Define the analytical Green's function.\n        def G_func(t):\n            # Handle the case where tau is zero or very small to prevent overflow,\n            # though not required by the test cases. G(t) is G_inf.\n            if tau <= 0:\n                if t == 0:\n                    return G0\n                else: \n                    return G_inf\n            # The standard exponential relaxation model.\n            return G_inf - (G_inf - G0) * np.exp(-t / tau)\n        \n        G_table = G_func(t_table)\n        \n        # Step 2: Calculate the harmonic displacement coefficient u_l0(T).\n        # This is the sum of contributions from each load jump, convolved with the Green's function.\n        u_l0_T = 0.0\n        for t_k, delta_L in load_jumps:\n            elapsed_time = T - t_k\n            \n            # Interpolate or extrapolate to find G_l(elapsed_time) from the table.\n            # np.interp handles all specified rules:\n            # - Linear interpolation for points within the table range.\n            # - Returns the first value (G_table[0]) for elapsed_time <= t_table[0]. \n            #   This covers the case elapsed_time = 0 as per the problem.\n            # - Returns the last value (G_table[-1]) for elapsed_time >= t_table[-1].\n            G_val = np.interp(elapsed_time, t_table, G_table)\n            \n            u_l0_T += delta_L * G_val\n            \n        # Step 3: Project to station location to get final uplift u(T, theta).\n        # Calculate the real zonal spherical harmonic Y_l0(theta).\n        x = np.cos(theta_rad)\n        P_l_x = eval_legendre(l, x)\n        Y_l0 = np.sqrt((2 * l + 1) / (4 * np.pi)) * P_l_x\n        \n        # The final uplift is the product of the harmonic coefficient and the spherical harmonic.\n        uplift = u_l0_T * Y_l0\n        \n        return uplift\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (general two-step history, happy path):\n        {\n            'l': 2, 'theta_deg': 45.0, 'T': 10.0,\n            'load_jumps': [(0.0, 1.0), (5.0, -1.0)],\n            'G_params': (0.4, 1.0, 3.0), 'dt_G': 1.0\n        },\n        # Case 2 (coarse tabulation, multiple negative jumps):\n        # Note: The elapsed times (8.0 and 6.0 kyr) fall on the grid points\n        # of the table [0, 2, 4, 6, 8, 10], so no interpolation is triggered.\n        # The code correctly handles this \"on-grid\" scenario.\n        {\n            'l': 2, 'theta_deg': 60.0, 'T': 10.0,\n            'load_jumps': [(2.0, -0.8), (4.0, -0.2)],\n            'G_params': (0.5, 1.1, 2.5), 'dt_G': 2.0\n        },\n        # Case 3 (boundary case at observation time, constant response):\n        # Note: The elapsed time is T - t_k = 5.0 - 5.0 = 0.0.\n        # The rule requires using the first tabulated value, which np.interp does correctly.\n        {\n            'l': 1, 'theta_deg': 30.0, 'T': 5.0,\n            'load_jumps': [(5.0, 0.5)],\n            'G_params': (0.7, 0.7, 1.0), 'dt_G': 1.0\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = calculate_uplift(**case)\n        # Format the result to six decimal places as a string.\n        results.append(f\"{result:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3611010"}, {"introduction": "While forward modeling predicts surface motion from a known Earth structure, a primary goal of computational geophysics is to solve the inverse problem: inferring Earth's internal properties from surface observations. This advanced practice challenges you to invert synthetic uplift data to determine the lithosphere's spatially varying elastic thickness, $T_e$. This exercise introduces you to essential inversion techniques, including model linearization and Tikhonov regularization, providing a glimpse into how geophysicists turn data into insights about our planet's structure and dynamics. [@problem_id:3610912]", "problem": "Consider a spherical cap region of the Earth's surface represented by local spherical coordinates $(\\theta,\\phi)$ and approximated as a planar patch over the scale of interest. The goal is to invert for a spatially varying elastic thickness field $T_e(\\theta,\\phi)$ of the lithosphere by exploiting observations of post-glacial uplift residuals and a mechanistic model that couples lithospheric flexure under ice loads with viscoelastic mantle flow. The physically relevant starting points are thin-plate flexure under transverse load and Maxwell viscoelastic relaxation in the mantle. The lithosphere is modeled as a thin elastic plate with flexural rigidity $D(\\theta,\\phi)$ and the mantle as a linear Maxwell material with viscosity $\\eta$ and shear modulus $\\mu$. The ice load is specified as a spatially varying surface pressure $q(\\theta,\\phi)$ over the patch.\n\nYou must derive, justify, and implement an inversion for a two-parameter, piecewise-constant representation of $T_e(\\theta,\\phi)$: region $\\Omega_A$ with unknown elastic thickness $T_e^A$ and region $\\Omega_B$ with unknown elastic thickness $T_e^B$. The partition is defined by a vertical meridian in the local planar approximation: the left half-plane is $\\Omega_A$ and the right half-plane is $\\Omega_B$. Assume the observed uplift residual field $u_{\\mathrm{obs}}(\\theta,\\phi)$ is collected at a single time $t$ after instantaneous deglaciation at $t=0$.\n\nStart from the following valid bases:\n- Thin-plate flexure under a transverse load: the governing equation for a plate of flexural rigidity $D$ and transverse load $q$ is\n$$\nD \\nabla^4 w = q,\n$$\nwhere $w(\\theta,\\phi)$ is the vertical deflection. For spatially varying $D(\\theta,\\phi)$, justify an appropriate approximation that connects the dominant spatial wavenumber of the load to deflection amplitude.\n- Maxwell viscoelastic mantle response: for a Maxwell material with viscosity $\\eta$ and shear modulus $\\mu$, the characteristic Maxwell time is\n$$\n\\tau = \\frac{\\eta}{\\mu}.\n$$\nUnder a step removal of load at $t=0$, the fraction of elastic recovery achieved by time $t$ is\n$$\nf(t) = 1 - e^{-t/\\tau}.\n$$\n\nYour inversion must be formulated in purely mathematical terms, producing a well-posed system for the two unknown parameters $T_e^A$ and $T_e^B$ and regularized to ensure stability. You must enforce physical positivity of the inferred parameters. Use the flexural rigidity definition for the lithosphere,\n$$\nD(\\theta,\\phi) = \\frac{E \\, T_e(\\theta,\\phi)^3}{12 \\left(1-\\nu^2\\right)},\n$$\nwhere $E$ is Young's modulus and $\\nu$ is Poisson's ratio. Clearly state any modeling approximation necessary to connect $q(\\theta,\\phi)$, $D(\\theta,\\phi)$, and $u_{\\mathrm{obs}}(\\theta,\\phi)$.\n\nYou must implement a complete program that constructs synthetic observations $u_{\\mathrm{obs}}(\\theta,\\phi)$ from known true values of $T_e^A$ and $T_e^B$, adds small Gaussian noise to emulate measurement and model error, and then performs the inversion to estimate $T_e^A$ and $T_e^B$. Use a square grid of size $N \\times N$ points with $N = 16$ over a local planar domain with Cartesian coordinates $(x,y) \\in [-1,1] \\times [-1,1]$ mapping the left half-plane $x  0$ to $\\Omega_A$ and the right half-plane $x \\ge 0$ to $\\Omega_B$. Use a spatially varying ice load defined by a Gaussian pressure hump centered at the origin,\n$$\nq(x,y) = p_0 \\exp\\left(-\\frac{x^2 + y^2}{2\\sigma^2}\\right),\n$$\nwith $p_0$ and $\\sigma$ specified below. Use a single dominant spatial wavenumber $k_0 = \\frac{2\\pi}{L}$ associated with an effective length scale $L$. All parameters must be physically plausible and consistent. Your inversion must incorporate Tikhonov regularization with parameter $\\lambda$ and must enforce non-negativity of the model parameters. The mathematical inversion you design must be derived from the bases above, not from pre-given shortcut formulas.\n\nPhysical and numerical units:\n- Express $T_e$ in $\\mathrm{km}$.\n- Express $q$ in $\\mathrm{Pa}$.\n- Express $u_{\\mathrm{obs}}$ in $\\mathrm{m}$.\n- Express time $t$ in $\\mathrm{s}$ internally; test inputs specify $t$ in $\\mathrm{yr}$, with $1\\,\\mathrm{yr} = 365.25 \\times 24 \\times 3600\\,\\mathrm{s}$.\n- All angles are not required in this local planar approximation.\n\nTest suite and parameters:\n- Common constants across all tests: $N = 16$, $E = 7.0 \\times 10^{10}\\,\\mathrm{Pa}$, $\\nu = 0.25$, $\\mu = 6.7 \\times 10^{10}\\,\\mathrm{Pa}$, $p_0 = 2.0 \\times 10^{7}\\,\\mathrm{Pa}$, $\\sigma = 0.40$ (dimensionless on the $[-1,1]$ grid), $\\lambda = 1.0 \\times 10^{-4}$.\n- Test case $1$ (general case):\n  - True values: $T_e^A = 40\\,\\mathrm{km}$, $T_e^B = 60\\,\\mathrm{km}$.\n  - Mantle viscosity: $\\eta = 1.0 \\times 10^{21}\\,\\mathrm{Pa\\,s}$.\n  - Observation time: $t = 2000\\,\\mathrm{yr}$.\n  - Effective length scale: $L = 200000\\,\\mathrm{m}$.\n  - Noise standard deviation added to $u_{\\mathrm{obs}}$: $0.002\\,\\mathrm{m}$.\n- Test case $2$ (boundary relaxation, equal thickness):\n  - True values: $T_e^A = 30\\,\\mathrm{km}$, $T_e^B = 30\\,\\mathrm{km}$.\n  - Mantle viscosity: $\\eta = 5.0 \\times 10^{22}\\,\\mathrm{Pa\\,s}$.\n  - Observation time: $t = 1000\\,\\mathrm{yr}$.\n  - Effective length scale: $L = 200000\\,\\mathrm{m}$.\n  - Noise standard deviation added to $u_{\\mathrm{obs}}$: $0.001\\,\\mathrm{m}$.\n- Test case $3$ (fast relaxation, strong contrast):\n  - True values: $T_e^A = 35\\,\\mathrm{km}$, $T_e^B = 80\\,\\mathrm{km}$.\n  - Mantle viscosity: $\\eta = 5.0 \\times 10^{20}\\,\\mathrm{Pa\\,s}$.\n  - Observation time: $t = 3000\\,\\mathrm{yr}$.\n  - Effective length scale: $L = 250000\\,\\mathrm{m}$.\n  - Noise standard deviation added to $u_{\\mathrm{obs}}$: $0.003\\,\\mathrm{m}$.\n\nRequired final output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must contain, in order, the estimated values $[T_e^A(\\mathrm{km}), T_e^B(\\mathrm{km})]$ for Test $1$, followed by Test $2$, followed by Test $3$, each rounded to two decimals, resulting in a flat list of $6$ floats, for example $[t_{1A},t_{1B},t_{2A},t_{2B},t_{3A},t_{3B}]$ where each $t_{ij}$ is in $\\mathrm{km}$ rounded to two decimals.", "solution": "**1. Derivation of the Forward Model**\n\nThe objective is to establish a mathematical relationship, the forward model, that predicts the observed uplift residual $u_{\\mathrm{obs}}(x,y)$ based on a given elastic thickness field $T_e(x,y)$ and other physical parameters.\n\nThe lithosphere is modeled as a thin elastic plate. Its initial static deflection, $w(x,y)$, under an ice load $q(x,y)$ is governed by the biharmonic equation of plate flexure:\n$$\n\\nabla \\cdot \\nabla (D(x,y) \\nabla^2 w(x,y)) - (1-\\nu) \\mathcal{L}(D,w) = q(x,y)\n$$\nwhere $D(x,y)$ is the spatially varying flexural rigidity and $\\mathcal{L}$ is a complex differential operator. For a constant $D$, this simplifies to $D \\nabla^4 w = q$. The problem statement gives this simplified form as a starting basis and acknowledges that $D$ is spatially varying. To make the problem tractable, we must employ a simplifying approximation as prompted.\n\nThe prompt requires justification for an approximation connecting the dominant spatial wavenumber of the load to the deflection. A common and physically reasonable approximation, particularly when the load's characteristic wavelength is smaller than the scale of variation in lithospheric properties, is the \"local response\" or \"local lithosphere\" approximation. This assumes that the deflection at a point $(x,y)$ is primarily determined by the local flexural rigidity $D(x,y)$. In the spectral domain, this is equivalent to assuming that the Fourier components of the deflection $W(\\mathbf{k})$ are related to the Fourier components of the load $Q(\\mathbf{k})$ by a local, position-dependent transfer function. For a dominant wavenumber $k_0 = 2\\pi/L$ representing the effective scale of the load, the $\\nabla^4$ operator can be approximated by a multiplication by $k_0^4$. This yields a local algebraic relationship:\n$$\nD(x,y) k_0^4 w(x,y) \\approx q(x,y)\n$$\nFrom this, we can express the initial elastic deflection $w(x,y)$ as:\n$$\nw(x,y) \\approx \\frac{q(x,y)}{D(x,y) k_0^4}\n$$\nThe flexural rigidity $D(x,y)$ is related to the elastic thickness $T_e(x,y)$ by:\n$$\nD(x,y) = \\frac{E \\, T_e(x,y)^3}{12 \\left(1-\\nu^2\\right)}\n$$\nwhere $E$ is Young's modulus and $\\nu$ is Poisson's ratio. Substituting this into the expression for $w(x,y)$:\n$$\nw(x,y) \\approx \\frac{q(x,y)}{k_0^4} \\left( \\frac{12(1-\\nu^2)}{E \\, T_e(x,y)^3} \\right)\n$$\nFollowing instantaneous deglaciation at $t=0$, the lithosphere rebounds due to viscoelastic flow in the mantle. The mantle is modeled as a Maxwell material, for which the characteristic relaxation time is $\\tau = \\eta/\\mu$, where $\\eta$ is viscosity and $\\mu$ is the shear modulus. The fraction of the total initial elastic deflection recovered by time $t$ is given as $f(t) = 1 - e^{-t/\\tau}$. The observed uplift residual $u(x,y,t)$ is this fraction of the initial deflection:\n$$\nu(x,y,t) = w(x,y) f(t) = w(x,y) \\left(1 - e^{-t/\\tau}\\right)\n$$\nCombining these equations yields the complete forward model:\n$$\nu(x,y,t) = \\frac{q(x,y)}{k_0^4} \\left( \\frac{12(1-\\nu^2)}{E} \\right) \\frac{1}{T_e(x,y)^3} \\left(1 - e^{-t/\\tau}\\right)\n$$\nThis equation predicts the uplift at any point $(x,y)$ and time $t$ given the local load, local elastic thickness, and mantle properties.\n\n**2. Formulation of the Inverse Problem**\n\nThe inverse problem aims to estimate the two unknown parameters, $T_e^A$ and $T_e^B$, from a grid of noisy uplift observations, $\\mathbf{d} = \\{u_{\\mathrm{obs}}(x_i, y_i)\\}$. The forward model is non-linear with respect to $T_e$. To formulate a linear inverse problem, we define a new set of model parameters:\n$$\nm_A = \\frac{1}{(T_e^A)^3} \\quad \\text{and} \\quad m_B = \\frac{1}{(T_e^B)^3}\n$$\nThe vector of unknown model parameters is $\\mathbf{m} = [m_A, m_B]^T$.\n\nLet's rewrite the forward model in terms of these new parameters. At each observation point $(x_i, y_i)$, the predicted uplift is:\n$$\nu_i = K_i \\cdot m(x_i)\n$$\nwhere $m(x_i)$ is either $m_A$ or $m_B$ depending on the region, and $K_i$ is a known coefficient encapsulating all other terms:\n$$\nK_i = \\frac{q(x_i,y_i)}{k_0^4} \\left( \\frac{12(1-\\nu^2)}{E} \\right) \\left(1 - e^{-t/\\tau}\\right)\n$$\nThis defines a system of linear equations for the $N^2$ observation points, which can be expressed in matrix form as $\\mathbf{d} = \\mathbf{G}\\mathbf{m}$.\nHere, $\\mathbf{d}$ is the $N^2 \\times 1$ vector of uplift observations, $\\mathbf{m}$ is the $2 \\times 1$ vector of unknown parameters $[m_A, m_B]^T$, and $\\mathbf{G}$ is the $N^2 \\times 2$ sensitivity matrix (or Jacobian).\n\nThe structure of $\\mathbf{G}$ is determined by the problem's spatial partitioning. Let $I_A$ be the set of grid indices where $x  0$ and $I_B$ be the set where $x \\ge 0$. The $i$-th row of $\\mathbf{G}$ is:\n- $[K_i, 0]$ if grid point $i \\in I_A$\n- $[0, K_i]$ if grid point $i \\in I_B$\n\n**3. Solution via Tikhonov Regularization**\n\nTo find a stable solution to the system $\\mathbf{d} \\approx \\mathbf{G}\\mathbf{m}$, we use Tikhonov regularization, which minimizes a combination of the data misfit and a penalty on the model norm. We seek to minimize the objective function $\\Phi(\\mathbf{m})$:\n$$\n\\Phi(\\mathbf{m}) = ||\\mathbf{G}\\mathbf{m} - \\mathbf{d}||_2^2 + \\lambda^2 ||\\mathbf{m}||_2^2\n$$\nwhere $\\lambda$ is the regularization parameter given in the problem statement. The solution that minimizes $\\Phi(\\mathbf{m})$ is given by the normal equations:\n$$\n\\mathbf{m}_{\\text{est}} = (\\mathbf{G}^T \\mathbf{G} + \\lambda^2 \\mathbf{I})^{-1} \\mathbf{G}^T \\mathbf{d}\n$$\nwhere $\\mathbf{I}$ is the $2 \\times 2$ identity matrix.\n\nLet's compute the matrices $\\mathbf{G}^T \\mathbf{G}$ and $\\mathbf{G}^T \\mathbf{d}$. Due to the orthogonal structure of the columns of $\\mathbf{G}$ (each grid point contributes to either $m_A$ or $m_B$, but not both), the matrix $\\mathbf{G}^T \\mathbf{G}$ is diagonal:\n$$\n\\mathbf{G}^T \\mathbf{G} = \\begin{pmatrix} \\sum_{i \\in I_A} K_i^2  0 \\\\ 0  \\sum_{i \\in I_B} K_i^2 \\end{pmatrix}\n$$\nThe vector $\\mathbf{G}^T \\mathbf{d}$ is:\n$$\n\\mathbf{G}^T \\mathbf{d} = \\begin{pmatrix} \\sum_{i \\in I_A} K_i d_i \\\\ \\sum_{i \\in I_B} K_i d_i \\end{pmatrix}\n$$\nThe regularized matrix to be inverted is:\n$$\n(\\mathbf{G}^T \\mathbf{G} + \\lambda^2 \\mathbf{I}) = \\begin{pmatrix} \\left(\\sum_{i \\in I_A} K_i^2\\right) + \\lambda^2  0 \\\\ 0  \\left(\\sum_{i \\in I_B} K_i^2\\right) + \\lambda^2 \\end{pmatrix}\n$$\nThe inversion is trivial, and the system decouples into two independent equations for $m_A$ and $m_B$:\n$$\nm_{A, \\text{est}} = \\frac{\\sum_{i \\in I_A} K_i d_i}{\\left(\\sum_{i \\in I_A} K_i^2\\right) + \\lambda^2}\n$$\n$$\nm_{B, \\text{est}} = \\frac{\\sum_{i \\in I_B} K_i d_i}{\\left(\\sum_{i \\in I_B} K_i^2\\right) + \\lambda^2}\n$$\nThe problem requires enforcing non-negativity of the physical parameters $T_e^A, T_e^B$. Since $T_e = m^{-1/3}$, this requires $m  0$. In our model, the load $q_i$ is non-negative, and thus the coefficient $K_i$ is non-negative. The observed uplift $d_i$ (representing physical uplift) will also be non-negative (plus small noise). Therefore, the numerators ($\\sum K_i d_i$) and denominators (sum of squares plus $\\lambda^2$) will be positive, naturally ensuring that $m_{A, \\text{est}}  0$ and $m_{B, \\text{est}}  0$. The non-negativity constraint is thus satisfied without further algorithmic complexity.\n\nFinally, the estimated elastic thickness values are recovered by back-transforming the estimated model parameters:\n$$\nT_{e, \\text{est}}^A = (m_{A, \\text{est}})^{-1/3} \\quad \\text{and} \\quad T_{e, \\text{est}}^B = (m_{B, \\text{est}})^{-1/3}\n$$\nThese values, calculated in SI units (meters), must be converted to kilometers for the final output.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the geophysical inversion problem for piecewise-constant elastic thickness.\n    \n    The function iterates through three test cases. For each case, it:\n    1. Sets up the physical model (grid, load, parameters).\n    2. Generates synthetic uplift data using the forward model derived from thin-plate\n       flexure and Maxwell viscoelasticity, based on the true elastic thickness values.\n       Gaussian noise is added to simulate observations.\n    3. Implements a Tikhonov-regularized linear inversion to estimate the two elastic\n       thickness parameters (TeA for x0, TeB for x=0). The inversion is based on\n       linearizing the problem by solving for m = 1/Te^3.\n    4. Converts the estimated parameters back to elastic thickness in kilometers.\n    5. Collects and formats the results as specified.\n    \"\"\"\n    \n    # Common constants\n    N = 16                                 # Grid size\n    E = 7.0e10                             # Young's modulus (Pa)\n    NU = 0.25                              # Poisson's ratio\n    MU = 6.7e10                            # Shear modulus (Pa)\n    P0 = 2.0e7                             # Peak ice load (Pa)\n    SIGMA = 0.40                           # Gaussian load width (dimensionless)\n    LAMBDA = 1.0e-4                        # Tikhonov regularization parameter\n    YR_TO_S = 365.25 * 24 * 3600           # Conversion from years to seconds\n\n    # Set up the computational grid\n    x_coords = np.linspace(-1.0, 1.0, N)\n    y_coords = np.linspace(-1.0, 1.0, N)\n    x, y = np.meshgrid(x_coords, y_coords)\n\n    # Define the ice load q(x,y)\n    q = P0 * np.exp(-(x**2 + y**2) / (2 * SIGMA**2))\n\n    # Test cases\n    test_cases = [\n        # (TeA_true_km, TeB_true_km, eta, t_yr, L_m, noise_std_m)\n        (40.0, 60.0, 1.0e21, 2000.0, 200000.0, 0.002),\n        (30.0, 30.0, 5.0e22, 1000.0, 200000.0, 0.001),\n        (35.0, 80.0, 5.0e20, 3000.0, 250000.0, 0.003),\n    ]\n\n    # For result reproducibility\n    np.random.seed(0)\n    \n    results = []\n    \n    for case in test_cases:\n        TeA_true_km, TeB_true_km, eta, t_yr, L_m, noise_std_m = case\n        \n        # --- 1. Forward Model: Generate synthetic data ---\n        \n        # Convert units to SI\n        TeA_true_m = TeA_true_km * 1000.0\n        TeB_true_m = TeB_true_km * 1000.0\n        t_s = t_yr * YR_TO_S\n\n        # Calculate model-dependent constants\n        k0 = (2 * np.pi) / L_m\n        tau = eta / MU\n        \n        # Create true Te field in meters\n        Te_true_field_m = np.full_like(x, TeB_true_m)\n        Te_true_field_m[x  0] = TeA_true_m\n        \n        # Calculate uplift using the forward model\n        # u = (q / (k0^4)) * (12*(1-nu^2)/E) * (1/Te^3) * (1 - exp(-t/tau))\n        C_flexure = (12 * (1 - NU**2)) / E\n        f_relax = 1.0 - np.exp(-t_s / tau)\n        \n        u_true = (q / (k0**4)) * C_flexure * (1.0 / Te_true_field_m**3) * f_relax\n\n        # Add Gaussian noise to create observed data\n        noise = np.random.normal(0, noise_std_m, (N, N))\n        u_obs = u_true + noise\n\n        # --- 2. Inverse Problem: Estimate TeA and TeB ---\n        \n        # Flatten grids to 1D vectors for easier processing\n        u_obs_flat = u_obs.flatten()\n        q_flat = q.flatten()\n        x_flat = x.flatten()\n        \n        # Identify points in region A (x  0) and region B (x = 0)\n        idx_A = np.where(x_flat  0)[0]\n        idx_B = np.where(x_flat = 0)[0]\n\n        # Calculate the coefficient K for the linearized model d = G*m\n        # K_i = (q_i / k0^4) * C_flexure * f_relax\n        K_flat = (q_flat / (k0**4)) * C_flexure * f_relax\n\n        d_A, d_B = u_obs_flat[idx_A], u_obs_flat[idx_B]\n        K_A, K_B = K_flat[idx_A], K_flat[idx_B]\n\n        # Calculate terms for the Tikhonov-regularized solution\n        # m_est = (G.T @ d) / (diag(G.T @ G) + lambda^2)\n        sum_K2_A = np.sum(K_A**2)\n        sum_K2_B = np.sum(K_B**2)\n        \n        sum_Kd_A = np.sum(K_A * d_A)\n        sum_Kd_B = np.sum(K_B * d_B)\n        \n        # Solve for the linearized parameters m_A and m_B\n        mA_est = sum_Kd_A / (sum_K2_A + LAMBDA**2)\n        mB_est = sum_Kd_B / (sum_K2_B + LAMBDA**2)\n        \n        # Back-transform to get physical parameters (Te) and convert to km\n        TeA_est_km = (mA_est**(-1/3)) / 1000.0\n        TeB_est_km = (mB_est**(-1/3)) / 1000.0\n        \n        results.extend([round(TeA_est_km, 2), round(TeB_est_km, 2)])\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3610912"}]}