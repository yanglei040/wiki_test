{"hands_on_practices": [{"introduction": "A powerful method for verifying the correctness of a numerical model is to check if it respects the fundamental physical laws it is meant to simulate. This practice leverages the reciprocity principle, a cornerstone of linear physical systems, which states that the response at a point $\\mathbf{x}_a$ due to a source at $\\mathbf{x}_b$ is identical to the response at $\\mathbf{x}_b$ from a source at $\\mathbf{x}_a$. By implementing a cell-centered finite volume scheme and testing this symmetry under various boundary conditions, you will gain hands-on experience in building a robust solver and develop a deep appreciation for how the symmetry of the discrete operator ensures this physical law is upheld [@problem_id:3614531].", "problem": "Consider steady single-phase groundwater flow of an incompressible fluid in a saturated porous medium occupying the unit square domain $\\Omega = [0,1]\\times[0,1]$. Let $h(x,y)$ denote hydraulic head in meters and let the hydraulic conductivity tensor be diagonal with components $k_x(x,y)$ and $k_y(x,y)$ in meters per second. The governing equation in strong form is the partial differential equation $-\\nabla\\cdot(\\mathbf{K}\\nabla h)=q$ in $\\Omega$, where $\\mathbf{K}=\\mathrm{diag}(k_x,k_y)$ and $q$ is a volumetric source term per unit area in m/s. Boundary conditions on $\\partial\\Omega$ are specified as linear types that may include Dirichlet (prescribed head), Neumann (prescribed normal flux), or leaky Robin (linear head-to-flux relation against an external head). You will verify numerically the reciprocity of the head response, namely that for two interior points $\\mathbf{x}_a$ and $\\mathbf{x}_b$ in $\\Omega$, the Green’s function symmetry condition $h(\\mathbf{x}_a;\\delta(\\mathbf{x}-\\mathbf{x}_b))=h(\\mathbf{x}_b;\\delta(\\mathbf{x}-\\mathbf{x}_a))$ holds to within numerical tolerance under various discretizations and boundary mixes.\n\nStarting from fundamental conservation of mass and Darcy’s law, discretize the governing equation on a uniform Cartesian mesh with $N_x \\times N_y$ rectangular control volumes using a conservative cell-centered scheme. Represent the point source $\\delta(\\mathbf{x}-\\mathbf{x}_0)$ as a unit source distributed over the single control volume that contains $\\mathbf{x}_0$, so that the integrated source over that control volume equals $Q=1$ in units of cubic meters per second per unit thickness. Implement two choices of face conductivity averaging for the two-point flux approximation across interior faces: harmonic averaging and arithmetic averaging. For boundary faces, implement:\n- Dirichlet: prescribed head $h_D$ in meters.\n- Neumann: prescribed outward normal flux density $q_n$ in meters per second; the integrated flux across a boundary face of length $\\ell$ is $q_n\\,\\ell$.\n- Leaky Robin: $-(\\mathbf{K}\\nabla h)\\cdot \\mathbf{n} = \\lambda (h - h_{\\mathrm{ext}})$ on the boundary with outward unit normal $\\mathbf{n}$, where $\\lambda$ is a leakance coefficient in reciprocal seconds and $h_{\\mathrm{ext}}$ is an external head in meters. The integrated flux across a boundary face of length $\\ell$ is $\\lambda \\,\\ell\\,(h - h_{\\mathrm{ext}})$.\n\nYour program must, for each test case, assemble and solve the resulting linear system for the head field twice: once with a unit source at $\\mathbf{x}_b$ and once with a unit source at $\\mathbf{x}_a$. Let $h^b$ be the solution associated with the source at $\\mathbf{x}_b$ and $h^a$ be the solution associated with the source at $\\mathbf{x}_a$. Extract the head values $h^b(\\mathbf{x}_a)$ and $h^a(\\mathbf{x}_b)$ by sampling at the indices of the control volumes containing $\\mathbf{x}_a$ and $\\mathbf{x}_b$, respectively, and compute the absolute reciprocity residual $r = \\left|h^b(\\mathbf{x}_a) - h^a(\\mathbf{x}_b)\\right|$ in meters.\n\nPhysical units: All heads must be in meters, flux densities in meters per second, conductivity in meters per second, and leakance in reciprocal seconds. The final outputs required below are residuals $r$ and must be expressed in meters.\n\nTest suite. Your code must evaluate and report the reciprocity residual for each of the following test cases. In each case, the domain is $[0,1]\\times[0,1]$ in meters, the total source strength is $Q=1$ in cubic meters per second per unit thickness (implemented by $q=Q/(\\Delta x \\Delta y)$ at the single source cell), and the sampling points are strictly interior. The face conductivity averaging “mode” is either “harmonic” or “arithmetic”.\n\n- Test case $1$ (coarse, isotropic, mixed Dirichlet–Neumann):\n  - Grid: $N_x = 16$, $N_y = 16$.\n  - Conductivity: $k_x(x,y)=1$, $k_y(x,y)=1$ (constant).\n  - Boundary conditions: left Dirichlet $h=1$, right Dirichlet $h=0$, top Neumann $q_n=0$, bottom Neumann $q_n=0$.\n  - Averaging mode: harmonic.\n  - Points: $\\mathbf{x}_a=(0.31,0.61)$, $\\mathbf{x}_b=(0.73,0.42)$.\n\n- Test case $2$ (refined, isotropic, same boundary mix):\n  - Grid: $N_x = 64$, $N_y = 64$.\n  - Conductivity: $k_x(x,y)=1$, $k_y(x,y)=1$.\n  - Boundary conditions: left Dirichlet $h=1$, right Dirichlet $h=0$, top Neumann $q_n=0$, bottom Neumann $q_n=0$.\n  - Averaging mode: harmonic.\n  - Points: $\\mathbf{x}_a=(0.29,0.77)$, $\\mathbf{x}_b=(0.61,0.38)$.\n\n- Test case $3$ (aligned anisotropy, mixed Dirichlet–Neumann):\n  - Grid: $N_x = 40$, $N_y = 40$.\n  - Conductivity: $k_x(x,y)=10$, $k_y(x,y)=1$ (constants).\n  - Boundary conditions: left Dirichlet $h=1$, right Dirichlet $h=0$, top Neumann $q_n=0$, bottom Neumann $q_n=0$.\n  - Averaging mode: harmonic.\n  - Points: $\\mathbf{x}_a=(0.27,0.71)$, $\\mathbf{x}_b=(0.66,0.33)$.\n\n- Test case $4$ (isotropic with leaky Robin, mixed):\n  - Grid: $N_x = 40$, $N_y = 40$.\n  - Conductivity: $k_x(x,y)=1$, $k_y(x,y)=1$ (constants).\n  - Boundary conditions: left Dirichlet $h=1$, right Dirichlet $h=0$, bottom Neumann $q_n=0$, top Robin with $\\lambda=5$ and $h_{\\mathrm{ext}}=0.25$.\n  - Averaging mode: harmonic.\n  - Points: $\\mathbf{x}_a=(0.35,0.55)$, $\\mathbf{x}_b=(0.62,0.41)$.\n\n- Test case $5$ (heterogeneous inclusion, isotropic outside, arithmetic averaging):\n  - Grid: $N_x = 40$, $N_y = 40$.\n  - Conductivity: $k_x(x,y)=k_y(x,y)=20$ inside the inclusion box $[0.4,0.6]\\times[0.4,0.6]$, and $k_x(x,y)=k_y(x,y)=1$ elsewhere.\n  - Boundary conditions: left Dirichlet $h=1$, right Dirichlet $h=0$, top Neumann $q_n=0$, bottom Neumann $q_n=0$.\n  - Averaging mode: arithmetic.\n  - Points: $\\mathbf{x}_a=(0.37,0.63)$, $\\mathbf{x}_b=(0.74,0.29)$.\n\nFinal output format. Your program should produce a single line of output containing the reciprocity residuals for the five test cases, expressed in meters, as a comma-separated Python-style list in one line, for example $[r_1,r_2,r_3,r_4,r_5]$ where each $r_i$ is a floating-point number in meters. No additional text must be printed. The solution must be self-contained and must not read input or files or access a network.", "solution": "The problem requires the numerical verification of the reciprocity principle for steady-state single-phase groundwater flow in a two-dimensional domain. The governing equation is a second-order elliptic partial differential equation (PDE), which is derived from the principle of mass conservation and Darcy's law. We will discretize this equation using a cell-centered finite volume method and solve the resulting linear system to find the hydraulic head distribution.\n\nThe principle of conservation of mass for a steady, incompressible flow in a porous medium is expressed as:\n$$ -\\nabla \\cdot \\mathbf{v} = q $$\nwhere $\\mathbf{v}$ is the Darcy velocity or specific discharge vector (in m/s), and $q$ is the volumetric source/sink term per unit volume (in s⁻¹). We consider a 2D problem, effectively integrating over a unit thickness, so the governing equation is posed on a 2D domain $\\Omega$.\n\nDarcy's law relates the specific discharge to the hydraulic head $h$ (in m):\n$$ \\mathbf{v} = -\\mathbf{K} \\nabla h $$\nwhere $\\mathbf{K}$ is the hydraulic conductivity tensor (in m/s). For this problem, $\\mathbf{K}$ is a diagonal tensor, $\\mathbf{K} = \\mathrm{diag}(k_x, k_y)$.\n\nSubstituting Darcy's law into the conservation equation yields the governing PDE in strong form:\n$$ -\\nabla \\cdot (\\mathbf{K} \\nabla h) = q' $$\nwhere we use $q'$ to represent the source term per unit area (in m/s). Integrating this over the area of a control volume $V_{i,j}$ (a grid cell) gives:\n$$ \\int_{V_{i,j}} -\\nabla \\cdot (\\mathbf{K} \\nabla h) \\, dA = \\int_{V_{i,j}} q' \\, dA $$\nApplying the divergence theorem to the left-hand side converts the area integral into a line integral over the boundary $\\partial V_{i,j}$ of the control volume:\n$$ -\\oint_{\\partial V_{i,j}} (\\mathbf{K} \\nabla h) \\cdot \\mathbf{n} \\, dL = Q_{i,j} $$\nwhere $\\mathbf{n}$ is the outward-pointing unit normal vector to the boundary of the control volume, and $Q_{i,j} = \\int_{V_{i,j}} q' \\, dA$ is the total source/sink rate from the cell (in m²/s, which is m³/s per meter of thickness, consistent with the problem statement's $Q=1$). A point source $\\delta(\\mathbf{x}-\\mathbf{x}_0)$ is modeled by setting $Q_{i_0,j_0}=1$ for the cell $(i_0,j_0)$ containing $\\mathbf{x}_0$, and $Q_{i,j}=0$ for all other cells.\n\nThe domain $\\Omega=[0,1]\\times[0,1]$ is discretized into a uniform Cartesian grid of $N_x \\times N_y$ cells. Each cell $(i,j)$ has dimensions $\\Delta x = 1/N_x$ and $\\Delta y = 1/N_y$. The hydraulic head $h_{i,j}$ is defined at the center of the cell. The integral equation is approximated by summing the fluxes across the four faces of the cell. The flux out of cell $(i,j)$ across its right face (the interface with cell $(i+1,j)$) is approximated using a two-point flux approximation (TPFA):\n$$ F_{i+1/2, j} \\approx - K_{x, i+1/2, j} \\frac{h_{i+1,j} - h_{i,j}}{\\Delta x} \\Delta y = T_{i+1/2, j} (h_{i,j} - h_{i+1,j}) $$\nwhere $T_{i+1/2, j} = K_{x, i+1/2, j} \\frac{\\Delta y}{\\Delta x}$ is the transmissivity across the face. $K_{x, i+1/2, j}$ is an effective hydraulic conductivity at the face, computed by averaging the conductivities of the adjacent cells, $k_{x,i,j}$ and $k_{x,i+1,j}$. The problem specifies two averaging methods:\n-   Harmonic average: $K_{x, i+1/2, j} = \\frac{2 k_{x,i,j} k_{x,i+1,j}}{k_{x,i,j} + k_{x,i+1,j}}$\n-   Arithmetic average: $K_{x, i+1/2, j} = \\frac{k_{x,i,j} + k_{x,i+1,j}}{2}$\nSimilar expressions hold for the other three faces. The discretized equation for an interior cell $(i,j)$ is a sum of the fluxes out of the cell, which must equal the net source from the cell:\n$$ T_{i+1/2, j}(h_{i,j}-h_{i+1,j}) + T_{i-1/2, j}(h_{i,j}-h_{i-1,j}) + T_{i, j+1/2}(h_{i,j}-h_{i,j+1}) + T_{i, j-1/2}(h_{i,j}-h_{i,j-1}) = Q_{i,j} $$\nThis can be rearranged into a linear equation relating $h_{i,j}$ to its four neighbors.\n\nFor cells on the boundary of the domain $\\Omega$, one or more of these flux terms are replaced by a boundary condition. Let's consider a cell $(0,j)$ on the left boundary ($x=0$):\n-   Dirichlet condition ($h=h_D$): The flux across the boundary face is approximated as being driven by the difference between the cell-center head $h_{0,j}$ and the boundary head $h_D$ over a distance of $\\Delta x/2$. The flux out of the cell is $F_{out,L} = \\frac{k_{x,0,j} \\Delta y}{\\Delta x/2}(h_{0,j}-h_D)$. This modifies the linear equation by adding a term to the main diagonal of the system matrix and a known value to the right-hand side vector.\n-   Neumann condition (prescribed outward flux $q_n$): The outward flux through the face is simply $q_n \\Delta y$. The linear equation is modified by subtracting this known flux from the right-hand side. For a no-flow condition ($q_n=0$), this term is zero.\n-   Robin condition ($-(\\mathbf{K}\\nabla h)\\cdot \\mathbf{n} = \\lambda (h - h_{\\mathrm{ext}})$): The outward flux density is $\\lambda(h-h_{\\text{ext}})$. Approximating $h$ at the boundary by the cell-center head $h_{0,j}$, the outward flux is $\\lambda \\Delta y (h_{0,j}-h_{\\text{ext}})$. This modifies both the diagonal of the system matrix and the right-hand side vector.\n\nAssembling the equations for all $N=N_x N_y$ cells results in a large, sparse linear system of the form $\\mathbf{A} \\mathbf{h} = \\mathbf{b}$, where $\\mathbf{h}$ is the vector of unknown cell-center heads. The coefficient matrix $\\mathbf{A}$ is constructed based on the transmissivities and boundary conditions, while the vector $\\mathbf{b}$ contains the source terms and boundary condition values. Both harmonic and arithmetic averaging on a uniform grid, combined with the given boundary condition types, result in a symmetric matrix $\\mathbf{A}$.\n\nThe reciprocity principle states that the head at point $\\mathbf{x}_a$ due to a source at $\\mathbf{x}_b$ is equal to the head at $\\mathbf{x}_b$ due to a source at $\\mathbf{x}_a$. In the discrete system, this translates to $h_{k_a}^b = h_{k_b}^a$, where $k_a$ and $k_b$ are the indices for the cells containing $\\mathbf{x}_a$ and $\\mathbf{x}_b$. This property, $h_{k_a}^b = (\\mathbf{A}^{-1}\\mathbf{b}^b)_{k_a}$ and $h_{k_b}^a = (\\mathbf{A}^{-1}\\mathbf{b}^a)_{k_b}$, holds if the inverse matrix $\\mathbf{A}^{-1}$ is symmetric. Since the matrix $\\mathbf{A}$ is symmetric, its inverse is also symmetric. Therefore, the reciprocity should hold to within the limits of floating-point precision.\n\nThe algorithm proceeds as follows for each test case:\n1.  Define the grid, hydraulic conductivity field, and boundary conditions.\n2.  Construct the system matrix $\\mathbf{A}$ and a base right-hand side vector $\\mathbf{b}_{BC}$ containing only boundary condition contributions.\n3.  First solve for a source at $\\mathbf{x}_b$:\n    a. Determine the cell index $k_b$ for point $\\mathbf{x}_b$.\n    b. Create the full RHS vector $\\mathbf{b}^b = \\mathbf{b}_{BC}$, and add the source term $Q=1$ at index $k_b$.\n    c. Solve the system $\\mathbf{A} \\mathbf{h}^b = \\mathbf{b}^b$ for the head field $\\mathbf{h}^b$.\n    d. Determine the cell index $k_a$ for point $\\mathbf{x}_a$ and extract the head $h^b(\\mathbf{x}_a) = h^b_{k_a}$.\n4.  Then solve for a source at $\\mathbf{x}_a$:\n    a. Create the RHS vector $\\mathbf{b}^a = \\mathbf{b}_{BC}$, and add the source term $Q=1$ at index $k_a$.\n    b. Solve the system $\\mathbf{A} \\mathbf{h}^a = \\mathbf{b}^a$ for the head field $\\mathbf{h}^a$.\n    c. Extract the head $h^a(\\mathbf{x}_b) = h^a_{k_b}$.\n5.  Compute the absolute reciprocity residual $r = |h^b(\\mathbf{x}_a) - h^a(\\mathbf{x}_b)|$.\n\nThis procedure is repeated for all five test cases provided. The construction of the matrix $\\mathbf{A}$ and vector $\\mathbf{b}$ is performed by iterating through all cell faces to compute transmissivities and then through boundary cells to incorporate boundary terms. A sparse linear solver is used for efficiency.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import coo_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef solve():\n    \"\"\"\n    Main function to run the groundwater flow simulation for all test cases\n    and report the reciprocity residuals.\n    \"\"\"\n    \n    test_cases = [\n        # Test case 1\n        {'Nx': 16, 'Ny': 16, 'k_field': {'type': 'constant', 'kx': 1.0, 'ky': 1.0},\n         'bcs': {'left': ('dirichlet', 1.0), 'right': ('dirichlet', 0.0), 'top': ('neumann', 0.0), 'bottom': ('neumann', 0.0)},\n         'avg_mode': 'harmonic', 'xa': (0.31, 0.61), 'xb': (0.73, 0.42)},\n        # Test case 2\n        {'Nx': 64, 'Ny': 64, 'k_field': {'type': 'constant', 'kx': 1.0, 'ky': 1.0},\n         'bcs': {'left': ('dirichlet', 1.0), 'right': ('dirichlet', 0.0), 'top': ('neumann', 0.0), 'bottom': ('neumann', 0.0)},\n         'avg_mode': 'harmonic', 'xa': (0.29, 0.77), 'xb': (0.61, 0.38)},\n        # Test case 3\n        {'Nx': 40, 'Ny': 40, 'k_field': {'type': 'constant', 'kx': 10.0, 'ky': 1.0},\n         'bcs': {'left': ('dirichlet', 1.0), 'right': ('dirichlet', 0.0), 'top': ('neumann', 0.0), 'bottom': ('neumann', 0.0)},\n         'avg_mode': 'harmonic', 'xa': (0.27, 0.71), 'xb': (0.66, 0.33)},\n        # Test case 4\n        {'Nx': 40, 'Ny': 40, 'k_field': {'type': 'constant', 'kx': 1.0, 'ky': 1.0},\n         'bcs': {'left': ('dirichlet', 1.0), 'right': ('dirichlet', 0.0), 'top': ('robin', 5.0, 0.25), 'bottom': ('neumann', 0.0)},\n         'avg_mode': 'harmonic', 'xa': (0.35, 0.55), 'xb': (0.62, 0.41)},\n        # Test case 5\n        {'Nx': 40, 'Ny': 40, 'k_field': {'type': 'inclusion', 'kx_out': 1.0, 'ky_out': 1.0, 'kx_in': 20.0, 'ky_in': 20.0, 'box': [0.4, 0.6, 0.4, 0.6]},\n         'bcs': {'left': ('dirichlet', 1.0), 'right': ('dirichlet', 0.0), 'top': ('neumann', 0.0), 'bottom': ('neumann', 0.0)},\n         'avg_mode': 'arithmetic', 'xa': (0.37, 0.63), 'xb': (0.74, 0.29)},\n    ]\n\n    results = [_run_case(case) for case in test_cases]\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef _run_case(params):\n    \"\"\"\n    Solves a single test case for the reciprocity residual.\n    \"\"\"\n    Nx, Ny = params['Nx'], params['Ny']\n    domain_size = (1.0, 1.0)\n    dx, dy = domain_size[0] / Nx, domain_size[1] / Ny\n    N = Nx * Ny\n\n    # Create hydraulic conductivity fields\n    k_field_params = params['k_field']\n    kx_vals = np.full((Ny, Nx), k_field_params['kx']) if 'kx' in k_field_params else np.full((Ny, Nx), k_field_params['kx_out'])\n    ky_vals = np.full((Ny, Nx), k_field_params['ky']) if 'ky' in k_field_params else np.full((Ny, Nx), k_field_params['ky_out'])\n\n    if k_field_params['type'] == 'inclusion':\n        x_coords = (np.arange(Nx) + 0.5) * dx\n        y_coords = (np.arange(Ny) + 0.5) * dy\n        xv, yv = np.meshgrid(x_coords, y_coords)\n        box = k_field_params['box']\n        mask = (xv >= box[0])  (xv = box[1])  (yv >= box[2])  (yv = box[3])\n        kx_vals[mask] = k_field_params['kx_in']\n        ky_vals[mask] = k_field_params['ky_in']\n\n    # Get cell indices for points a and b\n    xa, xb = params['xa'], params['xb']\n    ia, ja = int(xa[0] / dx), int(xa[1] / dy)\n    ib, jb = int(xb[0] / dx), int(xb[1] / dy)\n    ka = ia + ja * Nx\n    kb = ib + jb * Nx\n\n    # Assemble the system matrix A and RHS vector b for boundary conditions\n    row, col, data = [], [], []\n    b = np.zeros(N)\n\n    # Face averaging function\n    if params['avg_mode'] == 'harmonic':\n        def avg(k1, k2):\n            return 2 * k1 * k2 / (k1 + k2)\n    else: # arithmetic\n        def avg(k1, k2):\n            return 0.5 * (k1 + k2)\n\n    # Interior faces\n    # Horizontal faces\n    for j in range(Ny):\n        for i in range(Nx - 1):\n            k1, k2 = i + j * Nx, (i + 1) + j * Nx\n            K_face = avg(kx_vals[j, i], kx_vals[j, i + 1])\n            T = K_face * dy / dx\n            row.extend([k1, k2, k1, k2]); col.extend([k1, k2, k2, k1]); data.extend([T, T, -T, -T])\n    \n    # Vertical faces\n    for j in range(Ny - 1):\n        for i in range(Nx):\n            k1, k2 = i + j * Nx, i + (j + 1) * Nx\n            K_face = avg(ky_vals[j, i], ky_vals[j + 1, i])\n            T = K_face * dx / dy\n            row.extend([k1, k2, k1, k2]); col.extend([k1, k2, k2, k1]); data.extend([T, T, -T, -T])\n\n    # Boundary conditions\n    bcs = params['bcs']\n    # Left (x=0) and Right (x=1)\n    for j in range(Ny):\n        # Left\n        k = 0 + j * Nx\n        bc_type, *bc_vals = bcs['left']\n        if bc_type == 'dirichlet':\n            hD = bc_vals[0]\n            T_L = kx_vals[j, 0] * dy / (0.5 * dx)\n            row.append(k); col.append(k); data.append(T_L)\n            b[k] += T_L * hD\n        elif bc_type == 'neumann':\n            qn = bc_vals[0]\n            b[k] -= qn * dy\n        # Right\n        k = (Nx - 1) + j * Nx\n        bc_type, *bc_vals = bcs['right']\n        if bc_type == 'dirichlet':\n            hD = bc_vals[0]\n            T_R = kx_vals[j, Nx - 1] * dy / (0.5 * dx)\n            row.append(k); col.append(k); data.append(T_R)\n            b[k] += T_R * hD\n        elif bc_type == 'neumann':\n            qn = bc_vals[0]\n            b[k] -= qn * dy\n\n    # Bottom (y=0) and Top (y=1)\n    for i in range(Nx):\n        # Bottom\n        k = i + 0 * Nx\n        bc_type, *bc_vals = bcs['bottom']\n        if bc_type == 'dirichlet':\n            hD = bc_vals[0]\n            T_B = ky_vals[0, i] * dx / (0.5 * dy)\n            row.append(k); col.append(k); data.append(T_B)\n            b[k] += T_B * hD\n        elif bc_type == 'neumann':\n            qn = bc_vals[0]\n            b[k] -= qn * dx\n            \n        # Top\n        k = i + (Ny - 1) * Nx\n        bc_type, *bc_vals = bcs['top']\n        if bc_type == 'dirichlet':\n            hD = bc_vals[0]\n            T_T = ky_vals[Ny - 1, i] * dx / (0.5 * dy)\n            row.append(k); col.append(k); data.append(T_T)\n            b[k] += T_T * hD\n        elif bc_type == 'neumann':\n            qn = bc_vals[0]\n            b[k] -= qn * dx\n        elif bc_type == 'robin':\n            lam, h_ext = bc_vals\n            T_Robin = lam * dx\n            row.append(k); col.append(k); data.append(T_Robin)\n            b[k] += T_Robin * h_ext\n            \n    A = coo_matrix((data, (row, col)), shape=(N, N)).tocsc()\n\n    # Solve for source at b, measure at a\n    b_b = np.copy(b)\n    b_b[kb] += 1.0 # Source term Q=1\n    h_b = spsolve(A, b_b)\n    h_at_a_from_b = h_b[ka]\n\n    # Solve for source at a, measure at b\n    b_a = np.copy(b)\n    b_a[ka] += 1.0 # Source term Q=1\n    h_a = spsolve(A, b_a)\n    h_at_b_from_a = h_a[kb]\n\n    return abs(h_at_a_from_b - h_at_b_from_a)\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3614531"}, {"introduction": "Geological formations are rarely homogeneous, and sharp contrasts in hydraulic conductivity ($K$) pose a significant challenge for numerical simulators. This exercise confronts this issue directly by modeling flow through a high-contrast 'checkerboard' conductivity field, a classic and demanding test case in computational geophysics. You will compare the performance of finite difference and finite element methods, and critically, investigate the impact of using harmonic versus arithmetic averaging for inter-cell conductivity, revealing why the choice of averaging is fundamental to obtaining physically meaningful results in heterogeneous media [@problem_id:3614550].", "problem": "You are to investigate, by first-principles derivation and controlled computation, how a checkerboard spatial variability of hydraulic conductivity affects the accuracy of two classical discretizations of steady single-phase groundwater flow: a cell-centered two-point flux finite difference (often equivalent to a finite volume on a Cartesian mesh) and a conforming linear finite element method on triangles. You must quantify the impact of conductivity averaging and mesh alignment on solution quality, and demonstrate a remedy.\n\nFundamental base. Start from the law of mass conservation and Darcy’s law. In a saturated, single-phase, incompressible medium, mass conservation in the absence of volumetric storage reads $$\\nabla \\cdot \\boldsymbol{q} = s,$$ where $\\boldsymbol{q}$ is the specific discharge (Darcy flux) in m/s and $s$ is a volumetric source term per unit area in m/s that is positive for injection. Darcy’s law for isotropic media gives $$\\boldsymbol{q} = -K(\\boldsymbol{x}) \\nabla h,$$ where $K(\\boldsymbol{x})$ is hydraulic conductivity in $\\mathrm{m}/\\mathrm{s}$ and $h$ is hydraulic head in $\\mathrm{m}$. Combining both yields the second-order elliptic boundary value problem in divergence form $$-\\nabla \\cdot \\left( K(\\boldsymbol{x}) \\nabla h(\\boldsymbol{x}) \\right) = s(\\boldsymbol{x}).$$ For this problem, set the source term to zero, $$s(\\boldsymbol{x}) = 0,$$ and impose Dirichlet boundary conditions $$h(\\boldsymbol{x}) = h_D(\\boldsymbol{x}) \\text{ on } \\partial \\Omega,$$ with a prescribed boundary head $h_D$.\n\nDomain and boundary data. Let the domain be the unit square $$\\Omega = [0,1] \\times [0,1] \\text{ in } \\mathrm{m},$$ with Dirichlet boundary condition $$h_D(x,y) = 1 - x \\text{ in } \\mathrm{m}.$$ This boundary condition enforces a horizontal hydraulic gradient from left to right.\n\nHydraulic conductivity field. Define a “checkerboard” hydraulic conductivity as a piecewise constant, square-tiled field with two values $K_{\\mathrm{high}}$ and $K_{\\mathrm{low}}$ alternating in both $x$ and $y$. Partition $[0,1]$ into $m_c$ equal intervals in each direction; each square tile thus has side length $$\\ell = 1/m_c \\text{ in } \\mathrm{m}.$$ For a given offset $(\\delta_x,\\delta_y)$ with $0 \\le \\delta_x,\\delta_y  \\ell$, define $$\\tilde{x} = (x + \\delta_x) \\bmod 1, \\quad \\tilde{y} = (y + \\delta_y) \\bmod 1,$$ and tile indices $$i = \\left\\lfloor m_c \\tilde{x} \\right\\rfloor, \\quad j = \\left\\lfloor m_c \\tilde{y} \\right\\rfloor.$$ Then set $$K(x,y) = \\begin{cases} K_{\\mathrm{high}},  \\text{if } (i + j) \\bmod 2 = 0, \\\\ K_{\\mathrm{low}},  \\text{if } (i + j) \\bmod 2 = 1. \\end{cases}$$\n\nDiscretizations to compare.\n\n- Cell-centered two-point flux finite difference. Consider a uniform Cartesian grid with $N_x$ by $N_y$ rectangular cells, each of size $$\\Delta x = 1/N_x, \\quad \\Delta y = 1/N_y \\text{ in } \\mathrm{m}.$$ Unknowns are cell-centered heads $h_{i,j}$ for $i = 0,\\dots,N_x-1$, $j=0,\\dots,N_y-1$. Fluxes across faces use two-point transmissibilities with face hydraulic conductivity $K_f$ computed by either arithmetic average $$K_f^{\\mathrm{arith}} = \\frac{1}{2}\\left(K_L + K_R\\right)$$ or harmonic average $$K_f^{\\mathrm{harm}} = \\left(\\frac{1}{2}\\left(\\frac{1}{K_L} + \\frac{1}{K_R}\\right)\\right)^{-1},$$ where $K_L$ and $K_R$ are the conductivities of the two adjacent cells. Boundary faces use one-sided transmissibilities consistent with a half-cell distance ($\\Delta x/2$ or $\\Delta y/2$) and the cell’s own conductivity. Dirichlet boundary conditions $h_D$ are incorporated into the right-hand side via face transmissibilities. This yields a sparse linear system $$\\mathbf{A}_{\\mathrm{FD}} \\mathbf{h}_{\\mathrm{FD}} = \\mathbf{b}_{\\mathrm{FD}}.$$\n\n- Conforming linear finite element method on a right-triangle mesh. Subdivide a uniform $(N_x \\times N_y)$ grid of squares into $2N_x N_y$ right triangles by the fixed diagonal. Let $P_1$ basis functions be defined at vertices (nodes). The stiffness matrix is assembled elementwise from $$a(u,v) = \\int_{\\Omega} K \\nabla u \\cdot \\nabla v \\, \\mathrm{d}\\Omega,$$ approximating $K$ by its value at the element centroid. Apply Dirichlet conditions strongly by overwriting boundary rows and right-hand side with $h_D$ values. This yields $$\\mathbf{A}_{\\mathrm{FE}} \\mathbf{h}_{\\mathrm{FE}} = \\mathbf{b}_{\\mathrm{FE}}.$$\n\nReference solution. Since a closed-form solution is not available for discontinuous $K$, define as a reference a fine-mesh finite element solution on a uniform $(N_x^{\\mathrm{ref}} \\times N_y^{\\mathrm{ref}})$ grid with $N_x^{\\mathrm{ref}}$ and $N_y^{\\mathrm{ref}}$ integer multiples of the coarse $N_x$ and $N_y$.\n\nError metrics. For any discrete field $\\hat{h}$ and a reference field $h^{\\mathrm{ref}}$, define the discrete approximation to the continuous $\\mathrm{L}^2$ error norm by a Riemann sum. For the cell-centered finite difference unknowns at cell centers $(x_{i+1/2},y_{j+1/2})$ with uniform area $\\Delta x \\Delta y$, define $$E_{\\mathrm{FD}} = \\left( \\sum_{i=0}^{N_x-1} \\sum_{j=0}^{N_y-1} \\left( \\hat{h}_{i,j} - h^{\\mathrm{ref}}(x_{i+1/2}, y_{j+1/2}) \\right)^2 \\, \\Delta x \\Delta y \\right)^{1/2} \\text{ in } \\mathrm{m}.$$ For the finite element nodal unknowns at nodes $(x_p,y_p)$, approximate $$E_{\\mathrm{FE}} = \\left( \\sum_{p=1}^{N_{\\mathrm{nodes}}} \\left( \\hat{h}_p - h^{\\mathrm{ref}}(x_p, y_p) \\right)^2 \\, w \\right)^{1/2} \\text{ in } \\mathrm{m},$$ with uniform nodal weight $$w = \\frac{|\\Omega|}{N_{\\mathrm{nodes}}} = \\frac{1}{N_{\\mathrm{nodes}}} \\text{ in } \\mathrm{m}^2.$$\n\nTests. Use the following parameterized tests, each with the same coarse grid and reference grid:\n\n- Coarse grid for both finite difference and finite element: $$N_x = N_y = 16.$$\n- Reference finite element grid: $$N_x^{\\mathrm{ref}} = N_y^{\\mathrm{ref}} = 64.$$\n- Checkerboard tiling count: $$m_c = 8.$$\n\nThree tests are to be run:\n\n- Test A (aligned, high contrast): $$K_{\\mathrm{high}} = 10^{-3} \\text{ in } \\mathrm{m}/\\mathrm{s}, \\quad K_{\\mathrm{low}} = 10^{-6} \\text{ in } \\mathrm{m}/\\mathrm{s}, \\quad (\\delta_x,\\delta_y) = (0,0).$$\n- Test B (misaligned, high contrast): $$K_{\\mathrm{high}} = 10^{-3} \\text{ in } \\mathrm{m}/\\mathrm{s}, \\quad K_{\\mathrm{low}} = 10^{-6} \\text{ in } \\mathrm{m}/\\mathrm{s}, \\quad (\\delta_x,\\delta_y) = \\left(\\frac{1}{2 m_c}, 0\\right).$$\n- Test C (aligned, low contrast): $$K_{\\mathrm{high}} = 10^{-4} \\text{ in } \\mathrm{m}/\\mathrm{s}, \\quad K_{\\mathrm{low}} = 10^{-5} \\text{ in } \\mathrm{m}/\\mathrm{s}, \\quad (\\delta_x,\\delta_y) = (0,0).$$\n\nFor each test, compute three errors:\n\n- $$E_{\\mathrm{FD}}^{\\mathrm{arith}}$$ using the arithmetic face conductivity in the finite difference method,\n- $$E_{\\mathrm{FD}}^{\\mathrm{harm}}$$ using the harmonic face conductivity in the finite difference method,\n- $$E_{\\mathrm{FE}}$$ for the coarse finite element solution.\n\nFinal output format. Your program must produce a single line containing a Python-style list of $9$ floating-point numbers in meters, ordered as $$\\left[ E_{\\mathrm{FD}}^{\\mathrm{arith}}(\\text{A}), E_{\\mathrm{FD}}^{\\mathrm{harm}}(\\text{A}), E_{\\mathrm{FE}}(\\text{A}), E_{\\mathrm{FD}}^{\\mathrm{arith}}(\\text{B}), E_{\\mathrm{FD}}^{\\mathrm{harm}}(\\text{B}), E_{\\mathrm{FE}}(\\text{B}), E_{\\mathrm{FD}}^{\\mathrm{arith}}(\\text{C}), E_{\\mathrm{FD}}^{\\mathrm{harm}}(\\text{C}), E_{\\mathrm{FE}}(\\text{C}) \\right],$$ without additional text. All reported values must be in $\\mathrm{m}$.\n\nYour program must be a complete, runnable implementation that constructs the two discretizations, assembles and solves the resulting linear systems, constructs the reference finite element solution, evaluates the reference at required locations, computes the $\\mathrm{L}^2$ errors as specified, and prints the list in the exact required format. No user input is permitted; all parameters are fixed as stated above.", "solution": "The user has provided a well-posed problem in computational geophysics, specifically concerning the numerical simulation of single-phase groundwater flow. The task requires a comparison of two standard discretization schemes—a cell-centered finite difference (FD) method and a conforming linear finite element (FE) method—in the presence of a discontinuous, checkerboard-patterned hydraulic conductivity field $K(\\boldsymbol{x})$. The core of the problem lies in quantifying the numerical error introduced by the discretization of the elliptic operator $-\\nabla \\cdot (K \\nabla h)$ when $K$ is discontinuous, and how different numerical treatments affect the accuracy.\n\nThe problem is valid as it is scientifically grounded in the principles of mass conservation and Darcy's law, is mathematically well-posed, and all parameters and conditions are explicitly defined. We will proceed with a full solution.\n\nThe solution methodology involves the following principled steps:\n1.  **Reference Solution**: A highly accurate numerical solution is required to serve as a proxy for the true analytical solution, which is unavailable. We will compute this reference solution using the finite element method on a fine grid ($N_x^{\\mathrm{ref}} = N_y^{\\mathrm{ref}} = 64$), as specified. The resulting piecewise linear field, $h^{\\mathrm{ref}}$, can be evaluated at any point in the domain via barycentric interpolation. We will use `scipy.interpolate.LinearNDInterpolator` for this purpose.\n\n2.  **Finite Element (FE) Implementation**: We will implement a standard $P_1$ conforming finite element method. The domain $\\Omega = [0,1]^2$ is meshed by first creating a grid of $N_x \\times N_y$ squares and then subdividing each square into two right triangles using a consistent diagonal.\n    -   The weak form of the governing equation, $-\\nabla \\cdot (K \\nabla h) = 0$, is $a(h, v) = 0$ for all valid test functions $v$, where the bilinear form is $a(u,v) = \\int_{\\Omega} K(\\boldsymbol{x}) \\nabla u \\cdot \\nabla v \\, d\\Omega$.\n    -   The discrete problem is $\\mathbf{A}_{\\mathrm{FE}} \\mathbf{h}_{\\mathrm{FE}} = \\mathbf{b}_{\\mathrm{FE}}$. The stiffness matrix $\\mathbf{A}_{\\mathrm{FE}}$ is assembled by looping over each triangular element $e$, computing the local $3 \\times 3$ stiffness matrix $\\mathbf{A}_e$, and adding its entries to the global matrix.\n    -   The entries of the local stiffness matrix are given by $(\\mathbf{A}_e)_{ij} = \\int_e K_e \\nabla \\phi_i \\cdot \\nabla \\phi_j \\, d\\Omega$, where $\\phi_i$ are the linear basis functions. Since $\\nabla \\phi_i$ are constant on each element, this simplifies to $(\\mathbf{A}_e)_{ij} = K_e (\\nabla \\phi_i \\cdot \\nabla \\phi_j) \\mathrm{Area}(e)$. As per the problem, the conductivity $K_e$ is approximated as constant over the element, using its value at the element's centroid.\n    -   Dirichlet boundary conditions, $h(\\boldsymbol{x}) = 1-x$, are applied \"strongly\" by directly modifying the rows of $\\mathbf{A}_{\\mathrm{FE}}$ and the corresponding entries of $\\mathbf{b}_{\\mathrm{FE}}$ for all boundary nodes.\n\n3.  **Finite Difference (FD) Implementation**: A cell-centered, two-point flux approximation finite difference scheme is implemented on a uniform $N_x \\times N_y$ Cartesian grid.\n    -   Integrating the governing equation over a control volume (a cell) $(i,j)$ of size $\\Delta x \\times \\Delta y$ and applying the divergence theorem yields $\\int_{\\partial C_{ij}} \\boldsymbol{q} \\cdot \\boldsymbol{n} \\, dS = 0$. This states that the net flux across the cell boundaries is zero.\n    -   The flux across each of the four faces is approximated using a two-point stencil. For example, the flux across the east face between cell $(i,j)$ and $(i+1,j)$ is $q_E \\approx - K_f \\frac{h_{i+1,j} - h_{i,j}}{\\Delta x}$, where $h_{i,j}$ is the head at the center of cell $(i,j)$ and $K_f$ is the hydraulic conductivity at the face.\n    -   The critical choice is the method for averaging the conductivities of the adjacent cells, $K_L$ and $K_R$, to obtain $K_f$. We will implement two methods:\n        -   **Arithmetic mean**: $K_f^{\\mathrm{arith}} = \\frac{1}{2}(K_L + K_R)$. This is known to be inaccurate for high-contrast media.\n        -   **Harmonic mean**: $K_f^{\\mathrm{harm}} = \\left(\\frac{1}{2}\\left(\\frac{1}{K_L} + \\frac{1}{K_R}\\right)\\right)^{-1}$. This is derived from considering flow through two layers in series and is known to be the correct effective conductivity for one-dimensional flow perpendicular to layers. It is generally more accurate for discontinuous $K$.\n    -   For boundary faces, a one-sided transmissibility is used, incorporating the known Dirichlet head values into the right-hand side vector $\\mathbf{b}_{\\mathrm{FD}}$. The distance from the cell center to the boundary is $\\Delta x/2$ or $\\Delta y/2$.\n    -   The resulting system of linear equations is $\\mathbf{A}_{\\mathrm{FD}} \\mathbf{h}_{\\mathrm{FD}} = \\mathbf{b}_{\\mathrm{FD}}$.\n\n4.  **Error Calculation**: The accuracy of each approximate solution ($\\hat{h}$) is measured against the reference solution ($h^{\\mathrm{ref}}$) using the specified discrete $\\mathrm{L}^2$ error norms.\n    -   For FD: $E_{\\mathrm{FD}} = \\left( \\sum_{i,j} (\\hat{h}_{i,j} - h^{\\mathrm{ref}}(x_{i+1/2}, y_{j+1/2}))^2 \\Delta x \\Delta y \\right)^{1/2}$.\n    -   For FE: $E_{\\mathrm{FE}} = \\left( \\sum_{p} (\\hat{h}_p - h^{\\mathrm{ref}}(x_p, y_p))^2 / N_{\\mathrm{nodes}} \\right)^{1/2}$.\n\n5.  **Test Execution**: The three specified test cases (A, B, C) are executed. These cases vary the conductivity contrast and the alignment of the discretization grid with the checkerboard conductivity field. The alignment is particularly important for FD, as misaligning the grid such that cell faces coincide with jumps in $K$ is expected to highlight the difference between arithmetic and harmonic averaging. The nine resulting error values will be collected and presented. For numerical stability and efficiency, all linear systems are constructed as sparse matrices using `scipy.sparse` and solved with `scipy.sparse.linalg.spsolve`.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import lil_matrix\nfrom scipy.sparse.linalg import spsolve\nfrom scipy.interpolate import LinearNDInterpolator\n\ndef get_K(coords, mc, K_high, K_low, delta_x, delta_y):\n    \"\"\"\n    Computes hydraulic conductivity K for a checkerboard field.\n    \n    Args:\n        coords (np.ndarray): (N, 2) array of (x, y) coordinates.\n        mc (int): Number of checkerboard tiles in each dimension.\n        K_high (float): High conductivity value.\n        K_low (float): Low conductivity value.\n        delta_x (float): Offset in x-direction.\n        delta_y (float): Offset in y-direction.\n\n    Returns:\n        np.ndarray: (N,) array of conductivity values.\n    \"\"\"\n    x_shifted = (coords[:, 0] + delta_x) % 1.0\n    y_shifted = (coords[:, 1] + delta_y) % 1.0\n    \n    i = np.floor(mc * x_shifted).astype(int)\n    j = np.floor(mc * y_shifted).astype(int)\n    \n    k_values = np.where((i + j) % 2 == 0, K_high, K_low)\n    return k_values\n\ndef solve_fe(Nx, Ny, mc, K_high, K_low, delta_x, delta_y):\n    \"\"\"\n    Solves the groundwater flow equation using the Finite Element method\n    on a grid of right triangles.\n    \"\"\"\n    num_nodes = (Nx + 1) * (Ny + 1)\n    \n    # Generate node coordinates\n    x_nodes = np.linspace(0, 1, Nx + 1)\n    y_nodes = np.linspace(0, 1, Ny + 1)\n    xv, yv = np.meshgrid(x_nodes, y_nodes)\n    node_coords = np.vstack([xv.ravel(), yv.ravel()]).T\n\n    A = lil_matrix((num_nodes, num_nodes))\n    b = np.zeros(num_nodes)\n\n    # Assemble stiffness matrix\n    for i in range(Nx):\n        for j in range(Ny):\n            # Global indices of the four nodes of the square cell (i,j)\n            n0 = j * (Nx + 1) + i       # bottom-left\n            n1 = j * (Nx + 1) + (i + 1) # bottom-right\n            n2 = (j + 1) * (Nx + 1) + (i + 1) # top-right\n            n3 = (j + 1) * (Nx + 1) + i # top-left\n            \n            triangles = [(n0, n1, n2), (n0, n2, n3)]\n\n            for tri_nodes in triangles:\n                v_coords = node_coords[list(tri_nodes)]\n                centroid = np.mean(v_coords, axis=0)\n                K_e = get_K(np.array([centroid]), mc, K_high, K_low, delta_x, delta_y)[0]\n\n                (x1, y1), (x2, y2), (x3, y3) = v_coords\n                area = 0.5 * np.abs(x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2))\n                \n                b_coeffs = np.array([y2 - y3, y3 - y1, y1 - y2]) / (2 * area)\n                c_coeffs = np.array([x3 - x2, x1 - x3, x2 - x1]) / (2 * area)\n                \n                # Local stiffness matrix\n                Ke_local = np.zeros((3, 3))\n                for r in range(3):\n                    for c in range(3):\n                        Ke_local[r,c] = (b_coeffs[r] * b_coeffs[c] + c_coeffs[r] * c_coeffs[c])\n                Ke_local *= K_e * area\n\n                for r in range(3):\n                    for c in range(3):\n                        A[tri_nodes[r], tri_nodes[c]] += Ke_local[r, c]\n\n    # Apply Dirichlet boundary conditions strongly\n    boundary_nodes = [p for p in range(num_nodes) if node_coords[p,0] == 0 or node_coords[p,0] == 1 or node_coords[p,1] == 0 or node_coords[p,1] == 1]\n    \n    for p in boundary_nodes:\n        h_D = 1.0 - node_coords[p, 0]\n        A[p, :] = 0\n        A[p, p] = 1.0\n        b[p] = h_D\n\n    h = spsolve(A.tocsr(), b)\n    return h, node_coords\n\ndef solve_fd(Nx, Ny, mc, K_high, K_low, delta_x, delta_y, avg_method):\n    \"\"\"\n    Solves the groundwater flow equation using a cell-centered Finite Difference method.\n    \"\"\"\n    dx, dy = 1.0 / Nx, 1.0 / Ny\n    num_unknowns = Nx * Ny\n    A = lil_matrix((num_unknowns, num_unknowns))\n    b = np.zeros(num_unknowns)\n\n    x_centers = np.linspace(dx/2, 1-dx/2, Nx)\n    y_centers = np.linspace(dy/2, 1-dy/2, Ny)\n    cx, cy = np.meshgrid(x_centers, y_centers)\n    cell_coords = np.vstack([cx.ravel(), cy.ravel()]).T\n    K_cells_flat = get_K(cell_coords, mc, K_high, K_low, delta_x, delta_y)\n    K_cells = K_cells_flat.reshape((Ny, Nx)).T\n\n    avg_func = (lambda K1, K2: 0.5 * (K1 + K2)) if avg_method == 'arith' else (lambda K1, K2: 2.0 / (1.0/K1 + 1.0/K2))\n    \n    for i in range(Nx):\n        for j in range(Ny):\n            k = i * Ny + j\n            K_ij = K_cells[i,j]\n            \n            # East face\n            if i  Nx - 1:\n                T_E = avg_func(K_ij, K_cells[i+1, j]) * dy / dx\n                A[k, k] += T_E; A[k, (i+1)*Ny + j] -= T_E\n            else:\n                T_E = K_ij / (dx / 2.0) * dy\n                A[k, k] += T_E; b[k] += T_E * (1.0 - (i+1)*dx)\n            # West face\n            if i > 0:\n                T_W = avg_func(K_ij, K_cells[i-1, j]) * dy / dx\n                A[k, k] += T_W; A[k, (i-1)*Ny + j] -= T_W\n            else:\n                T_W = K_ij / (dx / 2.0) * dy\n                A[k, k] += T_W; b[k] += T_W * (1.0 - 0.0)\n            # North face\n            if j  Ny - 1:\n                T_N = avg_func(K_ij, K_cells[i, j+1]) * dx / dy\n                A[k, k] += T_N; A[k, i*Ny + j + 1] -= T_N\n            else:\n                T_N = K_ij / (dy / 2.0) * dx\n                A[k, k] += T_N; b[k] += T_N * (1.0 - (i+0.5)*dx)\n            # South face\n            if j > 0:\n                T_S = avg_func(K_ij, K_cells[i, j-1]) * dx / dy\n                A[k, k] += T_S; A[k, i*Ny + j - 1] -= T_S\n            else:\n                T_S = K_ij / (dy / 2.0) * dx\n                A[k, k] += T_S; b[k] += T_S * (1.0 - (i+0.5)*dx)\n\n    h = spsolve(A.tocsr(), b)\n    return h, cell_coords.reshape(Nx, Ny, 2).transpose(1,0,2).reshape(Nx*Ny, 2)\n\n\ndef compute_errors_for_case(Nx, Ny, Nx_ref, Ny_ref, mc, K_high, K_low, delta_x, delta_y):\n    \"\"\"\n    Orchestrates the computation of errors for one test case.\n    \"\"\"\n    h_ref, ref_node_coords = solve_fe(Nx_ref, Ny_ref, mc, K_high, K_low, delta_x, delta_y)\n    ref_interpolator = LinearNDInterpolator(ref_node_coords, h_ref)\n    \n    errors = []\n\n    # FD errors\n    h_fd_arith, fd_coords = solve_fd(Nx, Ny, mc, K_high, K_low, delta_x, delta_y, 'arith')\n    h_fd_harm, _ = solve_fd(Nx, Ny, mc, K_high, K_low, delta_x, delta_y, 'harm')\n    h_ref_at_centers = ref_interpolator(fd_coords)\n    dx, dy = 1.0/Nx, 1.0/Ny\n    errors.append(np.sqrt(np.sum((h_fd_arith - h_ref_at_centers)**2) * dx * dy))\n    errors.append(np.sqrt(np.sum((h_fd_harm - h_ref_at_centers)**2) * dx * dy))\n    \n    # FE error\n    h_fe, fe_node_coords = solve_fe(Nx, Ny, mc, K_high, K_low, delta_x, delta_y)\n    h_ref_at_nodes = ref_interpolator(fe_node_coords)\n    num_nodes = (Nx + 1) * (Ny + 1)\n    weight = 1.0 / num_nodes\n    errors.append(np.sqrt(np.sum((h_fe - h_ref_at_nodes)**2) * weight))\n    \n    return errors\n\ndef solve():\n    \"\"\"Main function to run all test cases and print results.\"\"\"\n    # Define common parameters for all tests.\n    test_params = {\n        'Nx': 16, 'Ny': 16,\n        'Nx_ref': 64, 'Ny_ref': 64,\n        'mc': 8,\n    }\n\n    # Define the three specific test cases.\n    test_cases = [\n        # Test A: aligned, high contrast\n        {'K_high': 1e-3, 'K_low': 1e-6, 'delta_x': 0.0, 'delta_y': 0.0},\n        # Test B: misaligned, high contrast\n        {'K_high': 1e-3, 'K_low': 1e-6, 'delta_x': 1.0 / (2 * test_params['mc']), 'delta_y': 0.0},\n        # Test C: aligned, low contrast\n        {'K_high': 1e-4, 'K_low': 1e-5, 'delta_x': 0.0, 'delta_y': 0.0}\n    ]\n\n    results = []\n    for case_config in test_cases:\n        # Combine common params with case-specific params\n        current_params = {**test_params, **case_config}\n        case_errors = compute_errors_for_case(**current_params)\n        results.extend(case_errors)\n\n    # Format the final output as specified.\n    print(f\"[{','.join(f'{r:.6e}' for r in results)}]\")\n\nsolve()\n```", "id": "3614550"}, {"introduction": "While the previous exercise handled heterogeneity between grid cells, this practice delves deeper into the Finite Element Method (FEM) to address property variations *within* a single element. The accuracy of the FEM stiffness matrix hinges on the precise calculation of integrals involving a spatially variable conductivity $K(\\mathbf{x})$. You will explore this by implementing and comparing different numerical quadrature rules to approximate these integrals, providing crucial insight into the trade-offs between accuracy and computational cost, and the sources of error in advanced FEM simulations [@problem_id:3614565].", "problem": "Consider single-phase groundwater flow governed by Darcy's law and mass conservation. Let $h(\\mathbf{x})$ denote hydraulic head and let hydraulic conductivity $K(\\mathbf{x})$ vary spatially within a two-dimensional triangular finite element. The governing steady equation under saturated, single-phase conditions is $\\nabla \\cdot \\left( K(\\mathbf{x}) \\nabla h(\\mathbf{x}) \\right) = 0$. In the linear continuous Galerkin Finite Element Method (FEM), the local stiffness contribution for a triangle $T$ has entries $A_{ij} = \\int_T K(\\mathbf{x}) \\nabla N_i(\\mathbf{x}) \\cdot \\nabla N_j(\\mathbf{x}) \\,\\mathrm{d}A$, where $N_i$ are the linear basis functions. Because $\\nabla N_i$ are constant on a linear triangle, the accuracy of $A_{ij}$ for heterogeneous $K(\\mathbf{x})$ depends on how accurately $\\int_T K(\\mathbf{x}) \\,\\mathrm{d}A$ is computed.\n\nYour task is to implement numerical quadrature for triangles to approximate $\\int_T K(\\mathbf{x}) \\,\\mathrm{d}A$ using:\n- a $1$-point Gaussian quadrature rule (the centroid rule) exact for polynomials of total degree $1$,\n- a $3$-point Gaussian quadrature rule exact for polynomials of total degree $2$,\nand to estimate the error introduced by using each rule relative to a high-order reference quadrature (a $7$-point Dunavant rule, exact for polynomials of total degree up to $5$).\n\nStarting from fundamental principles, use the affine mapping and barycentric coordinates to construct quadrature points and weights on a physical triangle with vertices $\\left( x_1, y_1 \\right)$, $\\left( x_2, y_2 \\right)$, and $\\left( x_3, y_3 \\right)$. The integral over $T$ of a function $f(\\mathbf{x})$ is approximated by $\\int_T f(\\mathbf{x}) \\,\\mathrm{d}A \\approx \\sum_{q=1}^{n_q} w_q f(\\mathbf{x}_q)$, where the weights $w_q$ must sum to the physical area of the triangle and the points $\\mathbf{x}_q$ are the images of barycentric quadrature nodes under the affine map. The area of the triangle must be computed using $|T| = \\frac{1}{2} \\left| (x_2 - x_1)(y_3 - y_1) - (x_3 - x_1)(y_2 - y_1) \\right|$ in $\\mathrm{m}^2$.\n\nDefine the area-averaged conductivity $\\overline{K}_T = \\frac{1}{|T|} \\int_T K(\\mathbf{x}) \\,\\mathrm{d}A$ (units $\\mathrm{m/s}$). For each test case below, compute $\\overline{K}_T$ using the $1$-point rule, the $3$-point rule, and the $7$-point Dunavant rule (used as the reference). Report the absolute errors of the $1$-point and $3$-point rules relative to the $7$-point rule:\n$$\nE_{1} = \\left| \\overline{K}_T^{(1)} - \\overline{K}_T^{(7)} \\right|, \\quad\nE_{3} = \\left| \\overline{K}_T^{(3)} - \\overline{K}_T^{(7)} \\right|,\n$$\nexpressed in $\\mathrm{m/s}$.\n\nUse the following test suite, where coordinates are in $\\mathrm{m}$ and hydraulic conductivity is in $\\mathrm{m/s}$:\n\n- Test Case $1$ (equilateral triangle, linear conductivity):\n  - Triangle vertices: $\\left(0, 0\\right)$, $\\left(1, 0\\right)$, $\\left(0.5, \\frac{\\sqrt{3}}{2}\\right)$.\n  - Conductivity: $K(x,y) = 10^{-4} + 2 \\cdot 10^{-5} \\, x - 10^{-5} \\, y$.\n\n- Test Case $2$ (skinny right triangle, quadratic conductivity):\n  - Triangle vertices: $\\left(0, 0\\right)$, $\\left(2, 0\\right)$, $\\left(0, 0.2\\right)$.\n  - Conductivity: $K(x,y) = 10^{-4} + 2 \\cdot 10^{-5} \\, x + 3 \\cdot 10^{-5} \\, y + 10^{-5} \\, x^2 - 10^{-5} \\, x y + 5 \\cdot 10^{-6} \\, y^2$.\n\n- Test Case $3$ (scalene triangle, exponential heterogeneity):\n  - Triangle vertices: $\\left(0, 0\\right)$, $\\left(1.5, 0.5\\right)$, $\\left(0.2, 2.0\\right)$.\n  - Conductivity: $K(x,y) = 10^{-5} \\exp\\left( 0.2 \\, x + 0.2 \\, y \\right)$.\n\n- Test Case $4$ (highly stretched triangle, cubic heterogeneity):\n  - Triangle vertices: $\\left(0, 0\\right)$, $\\left(100, 0\\right)$, $\\left(100, 0.001\\right)$.\n  - Conductivity: $K(x,y) = 10^{-5} \\left( 1 + 10^{-6} \\, x^3 + 10^{-6} \\, y^3 \\right)$.\n\nYour program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order\n$\\left[ E_{1}^{(1)}, E_{3}^{(1)}, E_{1}^{(2)}, E_{3}^{(2)}, E_{1}^{(3)}, E_{3}^{(3)}, E_{1}^{(4)}, E_{3}^{(4)} \\right]$,\nwhere $E_{1}^{(k)}$ and $E_{3}^{(k)}$ are the errors for test case $k$. All values must be reported in $\\mathrm{m/s}$. No other text should be printed.", "solution": "The problem requires the implementation of numerical quadrature schemes on triangular domains to compute the area-averaged hydraulic conductivity, $\\overline{K}_T$. We will compare the accuracy of a $1$-point and a $3$-point Gaussian quadrature rule against a high-order $7$-point Dunavant rule, which serves as the reference solution. The analysis is performed for four test cases, each with a different triangle geometry and hydraulic conductivity function $K(\\mathbf{x})$.\n\nOur methodology is grounded in the principles of the Finite Element Method (FEM), specifically the use of an affine map from a reference element to a physical element. We use barycentric coordinates on a reference simplex, which allows for a general and elegant formulation of quadrature rules applicable to any triangle in physical space.\n\nFirst, we define the affine mapping. Let a physical triangle $T$ in the $(x, y)$ Cartesian plane be defined by its vertices $\\mathbf{x}_1 = (x_1, y_1)$, $\\mathbf{x}_2 = (x_2, y_2)$, and $\\mathbf{x}_3 = (x_3, y_3)$. Any point $\\mathbf{x} = (x, y)$ inside $T$ can be expressed as a linear combination of the vertices using barycentric coordinates $(\\lambda_1, \\lambda_2, \\lambda_3)$, where $\\lambda_i \\ge 0$ and $\\sum_{i=1}^3 \\lambda_i = 1$:\n$$\n\\mathbf{x}(\\lambda_1, \\lambda_2, \\lambda_3) = \\lambda_1 \\mathbf{x}_1 + \\lambda_2 \\mathbf{x}_2 + \\lambda_3 \\mathbf{x}_3\n$$\nThis constitutes the affine map from the barycentric coordinate space to the physical coordinate space.\n\nThe integral of a function $f(\\mathbf{x})$ over the physical triangle $T$ can be transformed into an integral over a reference element $T_{ref}$. The change of variables introduces the determinant of the Jacobian of the affine map, which is constant for a triangle and equals $2|T|$, where $|T|$ is the area of the physical triangle. A numerical quadrature rule approximates this integral as a weighted sum of function evaluations at specific quadrature points:\n$$\n\\int_T f(\\mathbf{x}) \\, \\mathrm{d}A \\approx \\sum_{q=1}^{n_q} w_q f(\\mathbf{x}_q)\n$$\nHere, $n_q$ is the number of quadrature points, $\\mathbf{x}_q$ are the quadrature points in physical coordinates, and $w_q$ are the corresponding weights. The problem specifies that the sum of the weights must equal the area of the triangle, $\\sum_{q=1}^{n_q} w_q = |T|$. The physical quadrature points $\\mathbf{x}_q$ are obtained by applying the affine map to the reference quadrature points given in barycentric coordinates, $\\hat{\\boldsymbol{\\lambda}}_q = (\\lambda_{1,q}, \\lambda_{2,q}, \\lambda_{3,q})$:\n$$\n\\mathbf{x}_q = \\lambda_{1,q} \\mathbf{x}_1 + \\lambda_{2,q} \\mathbf{x}_2 + \\lambda_{3,q} \\mathbf{x}_3\n$$\nThe weights $w_q$ are related to the standard normalized weights $\\hat{w}_q$ (which sum to $1$) by $w_q = \\hat{w}_q |T|$.\n\nThe area of the triangle $T$ is computed using the formula:\n$$\n|T| = \\frac{1}{2} \\left| (x_2 - x_1)(y_3 - y_1) - (x_3 - x_1)(y_2 - y_1) \\right|\n$$\n\nThe target quantity is the area-averaged hydraulic conductivity, $\\overline{K}_T$:\n$$\n\\overline{K}_T = \\frac{1}{|T|} \\int_T K(\\mathbf{x}) \\, \\mathrm{d}A \\approx \\frac{1}{|T|} \\sum_{q=1}^{n_q} w_q K(\\mathbf{x}_q) = \\sum_{q=1}^{n_q} \\hat{w}_q K(\\mathbf{x}_q)\n$$\nThis shows that $\\overline{K}_T$ can be computed by evaluating $K$ at the physical quadrature points and summing the results, weighted by the normalized quadrature weights $\\hat{w}_q$.\n\nWe will use the following quadrature rules, specified by their barycentric coordinates $\\hat{\\boldsymbol{\\lambda}}_q$ and normalized weights $\\hat{w}_q$:\n\n1.  **$1$-Point Rule (Centroid, exact for linear polynomials):**\n    - Point $1$: $\\hat{\\boldsymbol{\\lambda}}_1 = (\\frac{1}{3}, \\frac{1}{3}, \\frac{1}{3})$\n    - Weight $1$: $\\hat{w}_1 = 1$\n\n2.  **$3$-Point Rule (Symmetric, exact for quadratic polynomials):**\n    - Point $1$: $\\hat{\\boldsymbol{\\lambda}}_1 = (\\frac{2}{3}, \\frac{1}{6}, \\frac{1}{6})$\n    - Point $2$: $\\hat{\\boldsymbol{\\lambda}}_2 = (\\frac{1}{6}, \\frac{2}{3}, \\frac{1}{6})$\n    - Point $3$: $\\hat{\\boldsymbol{\\lambda}}_3 = (\\frac{1}{6}, \\frac{1}{6}, \\frac{2}{3})$\n    - Weights: $\\hat{w}_1 = \\hat{w}_2 = \\hat{w}_3 = \\frac{1}{3}$\n\n3.  **$7$-Point Dunavant Rule (Symmetric, exact for quintic polynomials):** This serves as our high-fidelity reference.\n    - Point $1$ (center): $\\hat{\\boldsymbol{\\lambda}}_1 = (\\frac{1}{3}, \\frac{1}{3}, \\frac{1}{3})$; $\\hat{w}_1 = 0.225$\n    - Points $2,3,4$ (cyclic permutations of $(a, b, b)$):\n        - $\\hat{\\boldsymbol{\\lambda}}_2 = (a, b, b)$, $\\hat{\\boldsymbol{\\lambda}}_3 = (b, a, b)$, $\\hat{\\boldsymbol{\\lambda}}_4 = (b, b, a)$\n        - with $a = 0.797426985353087$, $b = 0.1012865073234565$\n        - Weights: $\\hat{w}_2 = \\hat{w}_3 = \\hat{w}_4 = 0.125939180544827$\n    - Points $5,6,7$ (cyclic permutations of $(c, d, d)$):\n        - $\\hat{\\boldsymbol{\\lambda}}_5 = (c, d, d)$, $\\hat{\\boldsymbol{\\lambda}}_6 = (d, c, d)$, $\\hat{\\boldsymbol{\\lambda}}_7 = (d, d, c)$\n        - with $c = 0.108103018168070$, $d = 0.445948490915965$\n        - Weights: $\\hat{w}_5 = \\hat{w}_6 = \\hat{w}_7 = 0.132394152788506$\n\nFor each test case, we compute $\\overline{K}_T^{(1)}$, $\\overline{K}_T^{(3)}$, and $\\overline{K}_T^{(7)}$ using the rules above. The absolute errors are then calculated as:\n$$\nE_{1} = \\left| \\overline{K}_T^{(1)} - \\overline{K}_T^{(7)} \\right| \\quad \\text{and} \\quad E_{3} = \\left| \\overline{K}_T^{(3)} - \\overline{K}_T^{(7)} \\right|\n$$\nThe procedure will be systematically applied to each of the four test cases provided.\n\n- For Test Case $1$, $K(x,y)$ is a linear function. A $1$-point Gaussian rule is exact for polynomials of degree up to $2(1)-1=1$. A $3$-point rule is exact for degree $2$. The $7$-point rule is exact for degree $5$. Thus, all three rules are expected to integrate the linear function exactly, leading to $E_1 \\approx 0$ and $E_3 \\approx 0$.\n- For Test Case $2$, $K(x,y)$ is quadratic. The $3$-point rule is exact for quadratic polynomials, as is the $7$-point reference rule. Therefore, we expect $E_3 \\approx 0$. The $1$-point rule is not exact for quadratics, so we expect $E_1  0$.\n- For Test Cases $3$ and $4$, the conductivity functions are non-polynomial (exponential and cubic, respectively). None of the rules are guaranteed to be exact. We expect non-zero errors for both $E_1$ and $E_3$, likely demonstrating the higher accuracy of the $3$-point rule over the $1$-point rule.\n\nThe implementation will follow this logic to compute the sequence of error values for the final output.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef get_quadrature_rule(n_points):\n    \"\"\"\n    Provides barycentric coordinates and normalized weights for triangular quadrature.\n\n    Args:\n        n_points (int): The number of points in the quadrature rule (1, 3, or 7).\n\n    Returns:\n        tuple: A tuple containing:\n            - np.ndarray: An array of barycentric coordinates for the points.\n            - np.ndarray: An array of corresponding normalized weights.\n    \"\"\"\n    if n_points == 1:\n        # 1-point rule (centroid), exact for polynomials of degree 1.\n        points = np.array([[1/3, 1/3, 1/3]])\n        weights = np.array([1.0])\n    elif n_points == 3:\n        # 3-point rule, exact for polynomials of degree 2.\n        points = np.array([\n            [2/3, 1/6, 1/6],\n            [1/6, 2/3, 1/6],\n            [1/6, 1/6, 2/3]\n        ])\n        weights = np.array([1/3, 1/3, 1/3])\n    elif n_points == 7:\n        # 7-point Dunavant rule (T2 5-1), exact for polynomials of degree 5.\n        a = 0.797426985353087\n        b = 0.1012865073234565\n        c = 0.108103018168070\n        d = 0.445948490915965\n        \n        points = np.array([\n            [1/3, 1/3, 1/3],  # Center point\n            [a, b, b],      # Group 1\n            [b, a, b],\n            [b, b, a],\n            [c, d, d],      # Group 2\n            [d, c, d],\n            [d, d, c]\n        ])\n        \n        w1 = 0.225\n        w2 = 0.125939180544827\n        w3 = 0.132394152788506\n        \n        weights = np.array([w1, w2, w2, w2, w3, w3, w3])\n    else:\n        raise ValueError(\"Only 1, 3, and 7-point rules are supported.\")\n        \n    return points, weights\n\ndef compute_avg_k(vertices, K_func, n_points):\n    \"\"\"\n    Computes the area-averaged hydraulic conductivity using a specified quadrature rule.\n    \n    Args:\n        vertices (np.ndarray): A 3x2 array of triangle vertex coordinates.\n        K_func (callable): The hydraulic conductivity function K(x, y).\n        n_points (int): The number of points for the quadrature rule.\n\n    Returns:\n        float: The computed area-averaged hydraulic conductivity.\n    \"\"\"\n    bary_coords, norm_weights = get_quadrature_rule(n_points)\n    \n    # Map barycentric coordinates to physical coordinates\n    # x_q = lambda_1*x_1 + lambda_2*x_2 + lambda_3*x_3\n    # y_q = lambda_1*y_1 + lambda_2*y_2 + lambda_3*y_3\n    # This can be done with a matrix-vector product: phys_coords = bary_coords @ vertices\n    phys_coords = bary_coords @ vertices\n    \n    # Evaluate K at each physical quadrature point\n    k_values = K_func(phys_coords[:, 0], phys_coords[:, 1])\n    \n    # Compute the weighted average using normalized weights\n    avg_k = np.sum(norm_weights * k_values)\n    \n    return avg_k\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    \"\"\"\n    test_cases = [\n        # Test Case 1: Equilateral triangle, linear conductivity\n        {\n            \"vertices\": np.array([[0, 0], [1, 0], [0.5, np.sqrt(3)/2]]),\n            \"K_func\": lambda x, y: 1e-4 + 2e-5 * x - 1e-5 * y\n        },\n        # Test Case 2: Skinny right triangle, quadratic conductivity\n        {\n            \"vertices\": np.array([[0, 0], [2, 0], [0, 0.2]]),\n            \"K_func\": lambda x, y: 1e-4 + 2e-5*x + 3e-5*y + 1e-5*x**2 - 1e-5*x*y + 5e-6*y**2\n        },\n        # Test Case 3: Scalene triangle, exponential heterogeneity\n        {\n            \"vertices\": np.array([[0, 0], [1.5, 0.5], [0.2, 2.0]]),\n            \"K_func\": lambda x, y: 1e-5 * np.exp(0.2 * x + 0.2 * y)\n        },\n        # Test Case 4: Highly stretched triangle, cubic heterogeneity\n        {\n            \"vertices\": np.array([[0, 0], [100, 0], [100, 0.001]]),\n            \"K_func\": lambda x, y: 1e-5 * (1 + 1e-6 * x**3 + 1e-6 * y**3)\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        vertices = case[\"vertices\"]\n        K_func = case[\"K_func\"]\n\n        # Compute area-averaged K for 1, 3, and 7-point rules\n        K_avg_1 = compute_avg_k(vertices, K_func, 1)\n        K_avg_3 = compute_avg_k(vertices, K_func, 3)\n        K_avg_7 = compute_avg_k(vertices, K_func, 7) # Reference\n\n        # Calculate absolute errors\n        E1 = abs(K_avg_1 - K_avg_7)\n        E3 = abs(K_avg_3 - K_avg_7)\n        \n        results.extend([E1, E3])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3614565"}]}