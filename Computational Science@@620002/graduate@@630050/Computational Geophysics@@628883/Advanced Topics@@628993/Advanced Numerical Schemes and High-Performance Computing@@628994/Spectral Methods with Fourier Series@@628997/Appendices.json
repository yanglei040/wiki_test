{"hands_on_practices": [{"introduction": "One of the most powerful features of spectral methods is their ability to compute spatial derivatives to very high accuracy. The key principle is that the differential operator $\\frac{d}{dx}$ in physical space transforms into a simple algebraic multiplication by $ik$ in Fourier space, where $i$ is the imaginary unit and $k$ is the wavenumber. This practice provides a fundamental, hands-on implementation of spectral differentiation using the Fast Fourier Transform (FFT), allowing you to explore its exceptional accuracy and analyze the numerical error as grid resolution changes [@problem_id:3614982].", "problem": "You are asked to formulate, implement, and validate a spectral differentiation procedure for a periodic function within the context of computational geophysics. Consider the function $f(x) = \\sin(3x) + 0.1\\cos(9x)$ defined on the interval $[0, 2\\pi]$, interpreted with $x$ measured in radians. The objective is to compute the numerical derivative of $f(x)$ using a spectral method based on Fourier series and to quantify the numerical error as the number of grid points $N$ varies, using double-precision arithmetic.\n\nBegin from the fundamental definition of the Fourier series of a $2\\pi$-periodic function and the relationship between spatial differentiation and its counterpart in the frequency domain derived from that definition. Your implementation must use the discrete formulation consistent with equally spaced samples on $[0, 2\\pi]$ and must rely on the Discrete Fourier Transform (DFT) evaluated via the Fast Fourier Transform (FFT), where FFT stands for Fast Fourier Transform. You must ensure that the procedure respects the periodic boundary conditions and is coherent with the Fourier series interpretation of a periodic grid.\n\nFor each chosen $N$, sample the function $f(x)$ at $N$ equally spaced points on $[0, 2\\pi)$, apply spectral differentiation as implied by the Fourier series framework, and compare the computed derivative to the exact derivative of $f(x)$ evaluated on the same grid. The exact derivative is to be evaluated analytically from first principles. Quantify the error using both the normalized $L^{2}$ error and the $L^{\\infty}$ error at the grid points. The normalized $L^{2}$ error must be defined as $\\sqrt{\\frac{1}{N}\\sum_{j=0}^{N-1} \\left(e_j\\right)^2}$, where $e_j$ is the pointwise error at the $j$-th grid point; the $L^{\\infty}$ error must be defined as $\\max_{0 \\leq j \\leq N-1} |e_j|$. Both errors are dimensionless.\n\nWork strictly in double precision, treating real and complex quantities accordingly. The angle unit must be radians throughout. Your program must implement the algorithm and produce a single line of output summarizing the results for a fixed test suite of $N$ values chosen to probe different numerical regimes, including under-resolved cases, boundary cases at the highest resolved frequency, and well-resolved cases.\n\nUse the following test suite for $N$: $N \\in \\{8, 16, 18, 32, 64, 128\\}$. For each $N$ in this set, compute and report a triple $[N, E_{2}, E_{\\infty}]$, where $E_{2}$ is the normalized $L^{2}$ error and $E_{\\infty}$ is the $L^{\\infty}$ error. Your program should produce a single line of output containing the list of these triples as a comma-separated list enclosed in square brackets, for example, $[[8, E_{2}, E_{\\infty}], [16, E_{2}, E_{\\infty}], \\dots]$, with numeric values in standard decimal notation. No physical units are involved because the quantities are dimensionless, and angles are in radians by construction.", "solution": "The target in spectral differentiation is to exploit the structure of periodic functions under Fourier series. A $2\\pi$-periodic function $f(x)$ admits a Fourier series representation\n$$\nf(x) = \\sum_{k=-\\infty}^{\\infty} \\hat{f}_k e^{i k x},\n$$\nwhere $\\hat{f}_k$ are the Fourier coefficients. Differentiation in physical space translates to a simple algebraic operation in the frequency domain. Differentiating term-by-term yields\n$$\n\\frac{d f}{d x}(x) = \\sum_{k=-\\infty}^{\\infty} i k \\hat{f}_k e^{i k x}.\n$$\nTherefore, if one can compute $\\hat{f}_k$, the derivative is recovered by multiplying each coefficient by $i k$ and performing the inverse transform.\n\nOn a discrete grid, we sample at $N$ equally spaced points on $[0, 2\\pi)$,\n$$\nx_j = \\frac{2\\pi j}{N}, \\quad j = 0, 1, \\dots, N-1,\n$$\nand form samples $f_j = f(x_j)$. The Discrete Fourier Transform (DFT) relates the samples to discrete spectral coefficients. Using the convention implemented by the Fast Fourier Transform (FFT), the forward transform computes\n$$\nF_n = \\sum_{j=0}^{N-1} f_j e^{-2\\pi i j n / N}, \\quad n = 0, 1, \\dots, N-1,\n$$\nand the inverse transform reconstructs\n$$\nf_j = \\frac{1}{N} \\sum_{n=0}^{N-1} F_n e^{2\\pi i j n / N}.\n$$\nFor functions of the form $f(x) = \\sum_k \\hat{f}_k e^{i k x}$ sampled at $x_j = 2\\pi j/N$, the discrete coefficients $F_n$ align with the continuous-series coefficients up to normalization that is consistent with the above DFT definition. The discrete wave numbers $k$ are represented by integers mapped to indices via the array returned by the frequency function that encodes the ordering\n$$\nk \\in \\{0, 1, 2, \\dots, \\lfloor\\frac{N}{2}\\rfloor, -\\lceil\\frac{N}{2}\\rceil, \\dots, -2, -1\\}.\n$$\nWith this mapping, spectral differentiation proceeds as follows:\n1. Compute the DFT $F_n$ of the sampled function $f_j$.\n2. Form the integer wave-number array $k_n$ matching the DFT ordering.\n3. Compute the spectral derivative coefficients $G_n = i k_n F_n$.\n4. Apply the inverse DFT to $G_n$ to obtain the derivative samples at the grid points,\n$$\n\\left(\\frac{d f}{d x}\\right)_j = \\frac{1}{N} \\sum_{n=0}^{N-1} G_n e^{2\\pi i j n / N}.\n$$\nBecause the exact function is band-limited to modes $k=\\pm 3$ and $k=\\pm 9$, the spectral differentiation reproduces the derivative exactly when those modes are representable on the grid without aliasing. For even $N$ such that $N/2 \\geq 9$, the $k=\\pm 9$ modes are included; however, at $N=18$ the $k=9$ mode corresponds to the Nyquist frequency. On the grid $x_j = 2\\pi j / 18$, the term $-0.9\\sin(9x_j)$ vanishes identically since $\\sin(9 \\cdot 2\\pi j / 18) = \\sin(\\pi j) = 0$, which is consistent with the discrete representation: the derivative contribution from the Nyquist cosine mode produces zero samples in physical space on that grid.\n\nThe exact derivative is computed analytically by the elementary differentiation rules,\n$$\n\\frac{d f}{d x}(x) = 3\\cos(3x) - 0.9\\sin(9x).\n$$\nWe quantify the error by comparing the spectral derivative samples to the exact ones at the grid points. For each $N$, define the pointwise error $e_j = \\left(\\frac{d f}{d x}\\right)_{\\text{spectral}}(x_j) - \\left(\\frac{d f}{d x}\\right)_{\\text{exact}}(x_j)$. We report two measures:\n1. The normalized $L^{2}$ error,\n$$\nE_2 = \\sqrt{\\frac{1}{N}\\sum_{j=0}^{N-1} e_j^2},\n$$\nwhich is a discrete approximation to the $L^2$ norm per unit interval length.\n2. The $L^{\\infty}$ error,\n$$\nE_{\\infty} = \\max_{0 \\leq j \\leq N-1} |e_j|.\n$$\nThese errors are dimensionless because $f(x)$ and its derivative are dimensionless real-valued functions of a dimensionless angle variable $x$ in radians.\n\nAlgorithmically, the steps are:\n- For each $N$ in the test suite $\\{8, 16, 18, 32, 64, 128\\}$, construct the grid $x_j$ and samples $f_j$ in double precision.\n- Compute the DFT of $f_j$ using the Fast Fourier Transform (FFT).\n- Create integer wave numbers matching the FFT ordering using the frequency generator, scale to integer wavenumbers, and multiply the spectral coefficients by $i k$ to obtain the spectral derivative coefficients.\n- Invert the transform to obtain the derivative samples and take the real part to remove any residual imaginary numerical noise.\n- Construct the exact derivative samples and compute $E_2$ and $E_{\\infty}$.\n- Aggregate the results in the specified output format as $[N, E_2, E_{\\infty}]$ for each $N$.\n\nThis approach adheres to the fundamental Fourier series framework and directly connects the mathematical property of differentiation in Fourier space to an efficient computational realization via the Fast Fourier Transform. It avoids extraneous approximations and, for sufficiently large $N$, yields errors that approach the round-off level in double precision, illustrating spectral accuracy for smooth periodic functions.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef spectral_derivative_on_grid(N):\n    \"\"\"\n    Compute the spectral derivative of f(x) = sin(3x) + 0.1*cos(9x) on [0, 2*pi)\n    using N equispaced points, and return the normalized L2 and Linfty errors\n    versus the exact derivative at the grid points. All computations are\n    performed in double precision.\n    \"\"\"\n    # Double-precision grids and values\n    x = (2.0 * np.pi) * np.arange(N, dtype=np.float64) / np.float64(N)\n    f = np.sin(3.0 * x, dtype=np.float64) + 0.1 * np.cos(9.0 * x, dtype=np.float64)\n\n    # Exact derivative at grid points\n    exact_df = 3.0 * np.cos(3.0 * x, dtype=np.float64) - 0.9 * np.sin(9.0 * x, dtype=np.float64)\n\n    # Compute FFT of f\n    F = np.fft.fft(f.astype(np.float64))\n\n    # Integer wavenumbers consistent with numpy FFT ordering\n    # fftfreq returns frequencies in cycles per sample; multiplying by N gives integer k.\n    k = np.fft.fftfreq(N, d=1.0) * N  # array of ints in float dtype: [0,1,...,N/2-1,-N/2,...,-1]\n    k = k.astype(np.float64)\n\n    # Spectral derivative coefficients: G = i * k * F\n    G = (1j * k) * F\n\n    # Inverse FFT to get derivative samples in physical space\n    df_spec = np.fft.ifft(G)\n\n    # Due to numerical round-off, df_spec may have tiny imaginary parts; take real part\n    df_spec_real = np.real(df_spec).astype(np.float64)\n\n    # Compute errors\n    err = df_spec_real - exact_df\n    # Normalized L2 error: sqrt(mean(err^2))\n    E2 = float(np.sqrt(np.mean(err * err)))\n    # Linfty error: max absolute error\n    Einf = float(np.max(np.abs(err)))\n\n    return E2, Einf\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [8, 16, 18, 32, 64, 128]\n\n    results = []\n    for N in test_cases:\n        E2, Einf = spectral_derivative_on_grid(N)\n        results.append([int(N), E2, Einf])\n\n    # Final print statement in the exact required format.\n    # Single line output: list of triples [N, E2, Einf] as comma-separated list in brackets.\n    print(f\"[{','.join(str(item) for item in results)}]\")\n\nsolve()\n```", "id": "3614982"}, {"introduction": "While linear operations like differentiation are straightforward, applying spectral methods to nonlinear problems, which are ubiquitous in geophysics, introduces a critical challenge: aliasing. When functions are multiplied directly on a discrete grid, the resulting high-frequency components can be incorrectly \"aliased\" as lower-frequency modes, introducing significant error. This exercise makes the abstract concept of aliasing tangible by contrasting a correct, dealiased spectral calculation with a naive point-wise product, allowing you to directly compute and understand the resulting aliasing bias [@problem_id:3615024].", "problem": "You are given a periodic domain and two real-valued functions represented by finite Fourier series. Your task is to compute the integral of the product of these functions using two distinct methods and quantify the aliasing-induced bias. The base is the definition of the Fourier series on a periodic domain, the definition of convolution in spectral space, and the quadrature of periodic functions on a uniform grid.\n\nConsider a one-dimensional periodic domain of length $2\\pi$ with spatial coordinate $x \\in [0,2\\pi)$ expressed in radians. Let $f(x)$ and $g(x)$ be real-valued functions with finite Fourier series written in the trigonometric basis,\n$$\nf(x) = a_0^{(f)} + \\sum_{k=1}^{K_f} \\left(a_k^{(f)}\\cos(kx) + b_k^{(f)}\\sin(kx)\\right), \\quad\ng(x) = a_0^{(g)} + \\sum_{k=1}^{K_g} \\left(a_k^{(g)}\\cos(kx) + b_k^{(g)}\\sin(kx)\\right).\n$$\nThe goal is to compute the integral of the product $h(x) = f(x)g(x)$ over $[0,2\\pi)$, denoted by\n$$\nI = \\int_{0}^{2\\pi} h(x)\\,dx,\n$$\nusing two methods:\n\n1. A spectral-space method based on the convolution of Fourier series that is dealiased. This computation must be derived from Fourier series principles and must return the correct integral without aliasing when the Fourier coefficients are known and finite.\n\n2. A direct quadrature method on a uniform grid of $N$ points using the trapezoidal rule (which equals the uniform average times the domain length for periodic functions sampled on an equispaced grid). This method will be susceptible to aliasing when the grid does not resolve the highest frequency content.\n\nYou should implement both methods and compute the bias as the difference between the direct quadrature integral and the dealiased spectral convolution integral,\n$$\n\\Delta I = I_{\\text{direct}} - I_{\\text{dealiased}}.\n$$\nYour program must carry out these computations for each test case in the suite below. Angles must be interpreted in radians. Output must be a list of floating-point numbers, one per test case, representing $\\Delta I$ for that case.\n\nTest Suite (each case specifies the grid size $N$, and the coefficients of $f$ and $g$):\n\n- Case 1 (well-resolved, general case): $N=64$,\n  $f(x) = 0 + 1.0\\cdot\\cos(5x) + 0.4\\cdot\\sin(7x)$,\n  $g(x) = 0 + 1.2\\cdot\\cos(5x) - 0.1\\cdot\\sin(7x)$.\n\n- Case 2 (Nyquist boundary condition): $N=32$,\n  $f(x) = 0 + 1.0\\cdot\\cos(16x)$,\n  $g(x) = 0 + 1.0\\cdot\\cos(16x)$.\n\n- Case 3 (significant aliasing-induced bias due to frequency collision under sampling): $N=32$,\n  $f(x) = 0 + 1.0\\cdot\\cos(18x)$,\n  $g(x) = 0 + 1.0\\cdot\\cos(14x)$.\n\n- Case 4 (multi-mode aliasing scenario): $N=24$,\n  $f(x) = 0 + 1.0\\cdot\\cos(17x) + 0.5\\cdot\\sin(5x)$,\n  $g(x) = 0 + 1.3\\cdot\\cos(7x) + 0.5\\cdot\\sin(17x)$.\n\n- Case 5 (well-resolved multi-mode case): $N=48$,\n  $f(x) = 0 + 0.8\\cdot\\cos(20x) - 0.5\\cdot\\sin(22x)$,\n  $g(x) = 0 + 0.8\\cdot\\cos(20x) - 0.5\\cdot\\sin(22x)$.\n\nRequired algorithmic details to implement:\n\n- For the dealiased spectral-space calculation, derive the expression for the zero-wavenumber (mean) mode of the convolution of the Fourier series of $f(x)$ and $g(x)$ and use it to compute $I_{\\text{dealiased}}$. You must proceed from the basic Fourier series definitions and convolution in spectral space, ensuring no aliasing influences the result when the series are finite.\n\n- For the direct quadrature calculation, sample the functions at $N$ equispaced points $x_n = \\frac{2\\pi n}{N}$ for $n = 0,1,\\dots,N-1$ and compute $I_{\\text{direct}}$ as the product average times $2\\pi$:\n$$\nI_{\\text{direct}} = \\left(\\frac{1}{N}\\sum_{n=0}^{N-1} f(x_n)g(x_n)\\right) \\cdot 2\\pi.\n$$\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4,result5]\"). Each entry must be the floating-point value of $\\Delta I$ for the corresponding case. No physical units are required because the domain length is $2\\pi$ in radians, and the integrals are dimensionless in this setup.", "solution": "The problem requires the computation of the integral of a product of two functions, $h(x) = f(x)g(x)$, over a periodic domain $[0, 2\\pi)$. This integral, denoted by $I = \\int_{0}^{2\\pi} h(x)\\,dx$, is to be calculated using two different methods: a dealiased spectral-space method and a direct quadrature method on a uniform grid. The bias between these two methods, $\\Delta I = I_{\\text{direct}} - I_{\\text{dealiased}}$, is the quantity to be reported.\n\nThe validation of the problem statement confirms that it is scientifically grounded, well-posed, and objective. It is a standard problem in numerical analysis and spectral methods, with all necessary data and definitions provided.\n\nThe solution proceeds by first deriving the expressions for the integral based on the two specified methods.\n\n**Method 1: Dealiased Spectral-Space Integral ($I_{\\text{dealiased}}$)**\n\nThis method computes the exact integral of the product of two functions with finite Fourier series. The integral of a periodic function over its domain is directly proportional to its mean value, which corresponds to the zero-wavenumber ($k=0$) coefficient of its Fourier series.\n\nLet the Fourier series of $h(x)$ be expressed in complex form as $h(x) = \\sum_{k=-\\infty}^{\\infty} c_k^{(h)} e^{ikx}$. The coefficient for $k=0$ is given by $c_0^{(h)} = \\frac{1}{2\\pi} \\int_{0}^{2\\pi} h(x) e^{-i(0)x} dx = \\frac{1}{2\\pi}I$. Therefore, the exact integral is $I = 2\\pi c_0^{(h)}$.\n\nThe functions $f(x)$ and $g(x)$ are given in a real trigonometric basis:\n$$\nf(x) = a_0^{(f)} + \\sum_{k=1}^{K_f} \\left(a_k^{(f)}\\cos(kx) + b_k^{(f)}\\sin(kx)\\right)\n$$\nand similarly for $g(x)$. The integral $I = \\int_{0}^{2\\pi} f(x)g(x) dx$ can be computed by substituting these series and using the orthogonality relations of trigonometric functions over the interval $[0, 2\\pi)$:\n$$\n\\int_{0}^{2\\pi}\\cos(kx)\\cos(jx)dx = \\pi\\delta_{kj} \\quad (k,j > 0)\n$$\n$$\n\\int_{0}^{2\\pi}\\sin(kx)\\sin(jx)dx = \\pi\\delta_{kj} \\quad (k,j > 0)\n$$\n$$\n\\int_{0}^{2\\pi}\\cos(kx)\\sin(jx)dx = 0\n$$\n$$\n\\int_{0}^{2\\pi}\\cos(kx)dx = 0, \\quad \\int_{0}^{2\\pi}\\sin(kx)dx = 0 \\quad (k > 0)\n$$\n$$\n\\int_{0}^{2\\pi} 1 \\cdot 1 \\, dx = 2\\pi\n$$\nWhen computing the integral of the product $f(x)g(x)$, the only terms that yield non-zero results are the product of the constant terms and products of trigonometric functions of the same type and same wavenumber. This leads to:\n$$\nI_{\\text{dealiased}} = \\int_{0}^{2\\pi} (a_0^{(f)})(a_0^{(g)}) dx + \\sum_{k=1}^{\\infty} \\int_{0}^{2\\pi} (a_k^{(f)}\\cos(kx))(a_k^{(g)}\\cos(kx)) dx + \\sum_{k=1}^{\\infty} \\int_{0}^{2\\pi} (b_k^{(f)}\\sin(kx))(b_k^{(g)}\\sin(kx)) dx\n$$\nUsing the orthogonality relations, this simplifies to:\n$$\nI_{\\text{dealiased}} = 2\\pi a_0^{(f)} a_0^{(g)} + \\sum_{k=1}^{\\infty} \\pi(a_k^{(f)} a_k^{(g)} + b_k^{(f)} b_k^{(g)})\n$$\nSince the input series are finite, this sum is also finite. This formula is exact and free of aliasing, hence it is the \"dealiased\" result.\n\n**Method 2: Direct Quadrature Integral ($I_{\\text{direct}}$)**\n\nThis method approximates the integral using the trapezoidal rule on a uniform grid of $N$ points, $x_n = \\frac{2\\pi n}{N}$ for $n = 0, 1, \\dots, N-1$. For periodic functions, this is equivalent to averaging the function values on the grid and multiplying by the domain length:\n$$\nI_{\\text{direct}} = \\frac{2\\pi}{N} \\sum_{n=0}^{N-1} h(x_n) = \\frac{2\\pi}{N} \\sum_{n=0}^{N-1} f(x_n)g(x_n)\n$$\nThis numerical quadrature is susceptible to aliasing. The product function $h(x)$ contains wavenumbers up to $K_f + K_g$. If this maximum wavenumber exceeds the Nyquist wavenumber of the grid, $k_{Nyquist} = N/2$, then higher-frequency components are misrepresented as lower-frequency components.\n\nThe discrete sum computed by the quadrature rule is exactly equal to the integral of the aliased function as seen by the grid. The aliasing relationship states that the discrete Fourier transform coefficients, $\\hat{h}_k$, of the sampled signal $h(x_n)$ are related to the continuous Fourier series coefficients, $c_k^{(h)}$, by the formula $\\hat{h}_k = N \\sum_{m=-\\infty}^{\\infty} c_{k+mN}^{(h)}$.\n\nThe direct integral is related to the $k=0$ component of the DFT: $I_{\\text{direct}} = \\frac{2\\pi}{N} \\hat{h}_0$. Substituting the aliasing formula for $\\hat{h}_0$:\n$$\nI_{\\text{direct}} = \\frac{2\\pi}{N} \\left( N \\sum_{m=-\\infty}^{\\infty} c_{mN}^{(h)} \\right) = 2\\pi \\sum_{m=-\\infty}^{\\infty} c_{mN}^{(h)}\n$$\n$$\nI_{\\text{direct}} = 2\\pi (c_0^{(h)} + c_N^{(h)} + c_{-N}^{(h)} + c_{2N}^{(h)} + c_{-2N}^{(h)} + \\dots)\n$$\n\n**Aliasing-Induced Bias ($\\Delta I$)**\n\nThe bias is the difference between the two computed integrals:\n$$\n\\Delta I = I_{\\text{direct}} - I_{\\text{dealiased}}\n$$\nSubstituting the expressions derived above:\n$$\n\\Delta I = \\left( 2\\pi \\sum_{m=-\\infty}^{\\infty} c_{mN}^{(h)} \\right) - (2\\pi c_0^{(h)}) = 2\\pi \\sum_{m \\neq 0} c_{mN}^{(h)}\n$$\nSince $h(x)$ is real, its Fourier coefficients satisfy $c_{-k}^{(h)} = (c_k^{(h)})^*$, so the bias can be written as:\n$$\n\\Delta I = 2\\pi \\sum_{m=1}^{\\infty} (c_{mN}^{(h)} + c_{-mN}^{(h)}) = 4\\pi \\sum_{m=1}^{\\infty} \\text{Re}(c_{mN}^{(h)})\n$$\nThis shows that a non-zero bias occurs if and only if the product function $h(x)$ has spectral power at wavenumbers that are non-zero multiples of the grid size $N$. These components alias directly to the zero-wavenumber (mean) component, thus corrupting the estimate of the integral. If the maximum wavenumber in $h(x)$ is less than $N$, then $c_{mN}^{(h)}=0$ for all $m \\geq 1$, resulting in zero bias.\n\nThe algorithm to solve the problem is as follows:\n1. For each test case, define the Fourier coefficients $(a_k, b_k)$ for functions $f(x)$ and $g(x)$.\n2. Implement a function to calculate $I_{\\text{dealiased}}$ using the derived formula based on coefficient products.\n3. Implement a function that synthesizes the functions $f(x)$ and $g(x)$, samples their product $h(x)$ on the specified grid of $N$ points, and computes $I_{\\text{direct}}$ using the trapezoidal rule sum.\n4. Calculate the difference $\\Delta I = I_{\\text{direct}} - I_{\\text{dealiased}}$ for each case.\n5. Collect and output the results.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the aliasing-induced bias in the integral of a product of two\n    functions for a suite of test cases.\n    \"\"\"\n\n    # Test suite definition: (N, f_coeffs_spec, g_coeffs_spec)\n    # f_coeffs_spec is a list of tuples (type, k, value)\n    # where type is 'a' for cos coefficient or 'b' for sin coefficient.\n    test_cases = [\n        # Case 1: Well-resolved case\n        (64, [('a', 5, 1.0), ('b', 7, 0.4)], [('a', 5, 1.2), ('b', 7, -0.1)]),\n        # Case 2: Nyquist boundary condition\n        (32, [('a', 16, 1.0)], [('a', 16, 1.0)]),\n        # Case 3: Significant aliasing-induced bias\n        (32, [('a', 18, 1.0)], [('a', 14, 1.0)]),\n        # Case 4: Multi-mode aliasing scenario\n        (24, [('a', 17, 1.0), ('b', 5, 0.5)], [('a', 7, 1.3), ('b', 17, 0.5)]),\n        # Case 5: Well-resolved multi-mode case (with aliasing but no bias)\n        (48, [('a', 20, 0.8), ('b', 22, -0.5)], [('a', 20, 0.8), ('b', 22, -0.5)]),\n    ]\n\n    results = []\n    for N, f_spec, g_spec in test_cases:\n        \n        def parse_spec_to_coeffs(spec):\n            \"\"\"Parses coefficient specifications into a dictionary structure.\"\"\"\n            coeffs = {\"a0\": 0.0, \"ak\": {}, \"bk\": {}}\n            for typ, k, val in spec:\n                if typ == 'a' and k != 0:\n                    coeffs[\"ak\"][k] = val\n                elif typ == 'b' and k != 0:\n                    coeffs[\"bk\"][k] = val\n                elif typ == 'a' and k == 0:\n                    coeffs[\"a0\"] = val\n            return coeffs\n\n        f_coeffs = parse_spec_to_coeffs(f_spec)\n        g_coeffs = parse_spec_to_coeffs(g_spec)\n\n        def build_func_from_coeffs(coeffs):\n            \"\"\"Builds a callable Python function from a coefficient dictionary.\"\"\"\n            a0 = coeffs.get(\"a0\", 0.0)\n            ak_coeffs = coeffs.get(\"ak\", {})\n            bk_coeffs = coeffs.get(\"bk\", {})\n            \n            def func(x):\n                val = a0\n                for k, a_k in ak_coeffs.items():\n                    val += a_k * np.cos(k * x)\n                for k, b_k in bk_coeffs.items():\n                    val += b_k * np.sin(k * x)\n                return val\n            return func\n\n        f_func = build_func_from_coeffs(f_coeffs)\n        g_func = build_func_from_coeffs(g_coeffs)\n\n        # Method 1: Dealiased Spectral-Space Integral\n        def calculate_I_dealiased(f_c, g_c):\n            # I_dealiased = 2*pi*a0_f*a0_g + pi * sum(ak_f*ak_g + bk_f*bk_g)\n            a0_f = f_c.get(\"a0\", 0.0)\n            a0_g = g_c.get(\"a0\", 0.0)\n            \n            integral = 2.0 * np.pi * a0_f * a0_g\n            \n            sum_term = 0.0\n            all_k = set(f_c[\"ak\"].keys()) | set(f_c[\"bk\"].keys()) | \\\n                    set(g_c[\"ak\"].keys()) | set(g_c[\"bk\"].keys())\n            \n            for k in all_k:\n                ak_f = f_c[\"ak\"].get(k, 0.0)\n                bk_f = f_c[\"bk\"].get(k, 0.0)\n                ak_g = g_c[\"ak\"].get(k, 0.0)\n                bk_g = g_c[\"bk\"].get(k, 0.0)\n                sum_term += ak_f * ak_g + bk_f * bk_g\n                \n            integral += np.pi * sum_term\n            return integral\n\n        I_dealiased = calculate_I_dealiased(f_coeffs, g_coeffs)\n        \n        # Method 2: Direct Quadrature Integral\n        def calculate_I_direct(func_f, func_g, num_points):\n            # Grid points: x_n = 2*pi*n/N for n = 0,...,N-1\n            x_grid = np.linspace(0.0, 2.0 * np.pi, num_points, endpoint=False)\n            \n            f_vals = func_f(x_grid)\n            g_vals = func_g(x_grid)\n            h_vals = f_vals * g_vals\n            \n            # Trapezoidal rule for periodic function\n            integral = (2.0 * np.pi / num_points) * np.sum(h_vals)\n            return integral\n\n        I_direct = calculate_I_direct(f_func, g_func, N)\n\n        # Compute the bias\n        delta_I = I_direct - I_dealiased\n        results.append(delta_I)\n\n    # Format the final output string exactly as required\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3615024"}, {"introduction": "The remarkable efficiency of spectral methods stems from their convergence properties, a concept known as \"spectral accuracy.\" For smooth, periodic functions, the magnitude of the Fourier coefficients decays faster than any polynomial power of the wavenumber, meaning very few modes are needed to achieve a highly accurate representation. This practice delves into the theoretical heart of this phenomenon by analyzing the truncation error for a classic analytic function, $u(x) = \\exp(\\beta \\cos(x))$, whose Fourier coefficients are analytically known in terms of special functions, providing a clear demonstration of this rapid convergence [@problem_id:3615049].", "problem": "Consider the $2\\pi$-periodic function $u(x) = \\exp\\!\\big(\\beta \\cos(x)\\big)$ with real parameter $\\beta \\ge 0$, where all angles are measured in radians. Work within the complex Fourier series convention on the interval $[0,2\\pi)$: the complex Fourier coefficients are defined by $\\,\\hat{u}_k = \\frac{1}{2\\pi} \\int_{0}^{2\\pi} u(x) e^{-ikx} \\, dx\\,$ for all integer $k \\in \\mathbb{Z}$. The squared $L^2$ truncation error of the degree-$N$ Fourier approximation is defined by\n$$\nE_N(\\beta) = \\sum_{|k|>N} \\big|\\hat{u}_k\\big|^2,\n$$\nwhere the $L^2$ norm is induced by the inner product $\\langle f,g\\rangle = \\frac{1}{2\\pi}\\int_0^{2\\pi} f(x)\\,\\overline{g(x)}\\,dx$. Starting from fundamental definitions, use the orthogonality of complex exponentials, the definition of complex Fourier coefficients, and well-tested properties of special functions to derive an analytic closed-form expression for the Fourier coefficients $\\,\\hat{u}_k\\,$ and for the total energy $\\,\\frac{1}{2\\pi}\\int_0^{2\\pi}\\big|u(x)\\big|^2\\,dx\\,$. Using these, express $E_N(\\beta)$ in terms of a finite sum and a single term depending only on $\\beta$, and provide a principled argument for its $N$-dependence, including an explanation of how the decay rate depends on $\\beta$ for large $N$ in the sense of an effective rate observed at finite $N$.\n\nYour task is to implement a program that computes $E_N(\\beta)$ for each test case listed below. You must use real-valued arithmetic, and any angles must be treated in radians. The final answers must be real numbers (floats) with full double-precision as produced by standard numerical libraries; no unit conversion is required beyond ensuring angles are in radians.\n\nTest suite:\n- Case 1: $\\beta = 0.0$, $N = 0$.\n- Case 2: $\\beta = 0.5$, $N = 0$.\n- Case 3: $\\beta = 0.5$, $N = 5$.\n- Case 4: $\\beta = 2.0$, $N = 10$.\n- Case 5: $\\beta = 5.0$, $N = 5$.\n- Case 6: $\\beta = 5.0$, $N = 20$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4,result5,result6]\"), in the order of the test cases above, where each result is the computed value of $E_N(\\beta)$ for that case. No other text should be printed.", "solution": "The problem asks for the derivation and computation of the squared $L^2$ truncation error for the Fourier series of the function $u(x) = \\exp(\\beta \\cos(x))$. We begin by validating the problem statement.\n\n### Step 1: Extract Givens\n- **Function**: $u(x) = \\exp(\\beta \\cos(x))$, a $2\\pi$-periodic function.\n- **Parameter**: $\\beta \\ge 0$ is a real parameter.\n- **Domain**: The interval $[0, 2\\pi)$.\n- **Complex Fourier Coefficients**: $\\hat{u}_k = \\frac{1}{2\\pi} \\int_{0}^{2\\pi} u(x) e^{-ikx} \\, dx$ for $k \\in \\mathbb{Z}$.\n- **Squared $L^2$ Truncation Error**: $E_N(\\beta) = \\sum_{|k|>N} |\\hat{u}_k|^2$.\n- **$L^2$ Norm and Inner Product**: $\\langle f,g\\rangle = \\frac{1}{2\\pi}\\int_0^{2\\pi} f(x)\\,\\overline{g(x)}\\,dx$. The squared norm is $\\|f\\|_{L^2}^2 = \\langle f,f \\rangle$.\n- **Task**: Derive a closed-form expression for $E_N(\\beta)$ and implement a program to compute it for specified test cases.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is scientifically and mathematically sound. It involves standard concepts from Fourier analysis applied to a well-behaved (analytic, periodic) function. The quantities to be computed are well-defined. The use of special functions (modified Bessel functions) is a standard technique in this context. The problem is self-contained, objective, and well-posed. There are no contradictions, ambiguities, or violations of scientific principles.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. We proceed with the solution.\n\n### Derivation of the Truncation Error Formula\n\nThe solution is based on Parseval's theorem, which relates the total energy of a function to the sum of the squared magnitudes of its Fourier coefficients. For the given normalization, Parseval's theorem states:\n$$\n\\frac{1}{2\\pi} \\int_{0}^{2\\pi} |u(x)|^2 dx = \\sum_{k=-\\infty}^{\\infty} |\\hat{u}_k|^2\n$$\nThe right-hand side is the total energy distributed among the Fourier modes. We can split this sum at the truncation index $N$:\n$$\n\\sum_{k=-\\infty}^{\\infty} |\\hat{u}_k|^2 = \\sum_{k=-N}^{N} |\\hat{u}_k|^2 + \\sum_{|k|>N} |\\hat{u}_k|^2\n$$\nBy definition, the second term on the right-hand side is the squared $L^2$ truncation error, $E_N(\\beta)$. Therefore, we can express the error as:\n$$\nE_N(\\beta) = \\left( \\frac{1}{2\\pi} \\int_{0}^{2\\pi} |u(x)|^2 dx \\right) - \\left( \\sum_{k=-N}^{N} |\\hat{u}_k|^2 \\right)\n$$\nTo obtain a computable expression for $E_N(\\beta)$, we must find closed-form expressions for the integral (the total energy) and the Fourier coefficients $\\hat{u}_k$.\n\n**1. Total Energy Term**\n\nThe total energy is given by the integral $\\frac{1}{2\\pi} \\int_{0}^{2\\pi} |u(x)|^2 dx$. Since $\\beta$ is real, $\\cos(x)$ is real, and the exponential of a real number is real and positive. Thus, $u(x)$ is a real-valued function.\n$$\n|u(x)|^2 = u(x)^2 = \\left( \\exp(\\beta \\cos(x)) \\right)^2 = \\exp(2\\beta \\cos(x))\n$$\nThe integral becomes:\n$$\n\\text{Total Energy} = \\frac{1}{2\\pi} \\int_{0}^{2\\pi} \\exp(2\\beta \\cos(x)) dx\n$$\nThis integral is a standard integral representation of the modified Bessel function of the first kind of order zero, $I_0(z)$, which is defined as:\n$$\nI_0(z) = \\frac{1}{\\pi} \\int_{0}^{\\pi} e^{z \\cos(\\theta)} d\\theta\n$$\nSince the integrand $\\exp(z \\cos(x))$ is an even function and $2\\pi$-periodic, we have $\\int_{0}^{2\\pi} \\dots dx = 2 \\int_{0}^{\\pi} \\dots dx$. Therefore:\n$$\n\\frac{1}{2\\pi} \\int_{0}^{2\\pi} \\exp(z \\cos(x)) dx = \\frac{1}{2\\pi} \\cdot 2 \\int_{0}^{\\pi} \\exp(z \\cos(x)) dx = \\frac{1}{\\pi} \\int_{0}^{\\pi} \\exp(z \\cos(x)) dx = I_0(z)\n$$\nBy setting $z = 2\\beta$, we find that the total energy is $I_0(2\\beta)$.\n\n**2. Fourier Coefficients $\\hat{u}_k$**\n\nThe Fourier coefficients are defined as $\\hat{u}_k = \\frac{1}{2\\pi} \\int_{0}^{2\\pi} \\exp(\\beta \\cos(x)) e^{-ikx} dx$.\nUsing Euler's formula, $e^{-ikx} = \\cos(kx) - i\\sin(kx)$, the integral becomes:\n$$\n\\hat{u}_k = \\frac{1}{2\\pi} \\int_{0}^{2\\pi} \\exp(\\beta \\cos(x)) \\cos(kx) dx - \\frac{i}{2\\pi} \\int_{0}^{2\\pi} \\exp(\\beta \\cos(x)) \\sin(kx) dx\n$$\nThe function $\\exp(\\beta \\cos(x))$ is an even function of $x$. The product of an even function and an odd function ($\\sin(kx)$) is odd. The integral of an odd periodic function over a symmetric interval of length $2\\pi$ (like $[-\\pi, \\pi]$, and by extension $[0, 2\\pi]$) is zero. Thus, the imaginary part of $\\hat{u}_k$ vanishes.\n$$\n\\hat{u}_k = \\frac{1}{2\\pi} \\int_{0}^{2\\pi} \\exp(\\beta \\cos(x)) \\cos(kx) dx\n$$\nThe integrand is an even function, so we can again write $\\int_{0}^{2\\pi} \\dots dx = 2 \\int_{0}^{\\pi} \\dots dx$:\n$$\n\\hat{u}_k = \\frac{1}{\\pi} \\int_{0}^{\\pi} \\exp(\\beta \\cos(x)) \\cos(kx) dx\n$$\nThis is the integral representation of the modified Bessel function of the first kind of order $k$, $I_k(\\beta)$.\nThus, $\\hat{u}_k = I_k(\\beta)$. Since $u(x)$ is real and even, its Fourier coefficients must be real and even with respect to the index $k$, which is consistent with the property $I_k(\\beta) = I_{-k}(\\beta)$ for integer $k$.\n\n**3. Final Expression for $E_N(\\beta)$**\n\nSubstituting these results back into our expression for the truncation error:\n$$\nE_N(\\beta) = I_0(2\\beta) - \\sum_{k=-N}^{N} |I_k(\\beta)|^2\n$$\nSince $I_k(\\beta)$ is real, $|I_k(\\beta)|^2 = (I_k(\\beta))^2$. We can expand the sum:\n$$\n\\sum_{k=-N}^{N} (I_k(\\beta))^2 = (I_{-N}(\\beta))^2 + \\dots + (I_{-1}(\\beta))^2 + (I_0(\\beta))^2 + (I_1(\\beta))^2 + \\dots + (I_N(\\beta))^2\n$$\nUsing the symmetry $I_{-k}(\\beta) = I_k(\\beta)$, the sum becomes:\n$$\n\\sum_{k=-N}^{N} (I_k(\\beta))^2 = (I_0(\\beta))^2 + 2 \\sum_{k=1}^{N} (I_k(\\beta))^2\n$$\nThis gives the final, closed-form expression for the truncation error suitable for computation:\n$$\nE_N(\\beta) = I_0(2\\beta) - \\left( (I_0(\\beta))^2 + 2 \\sum_{k=1}^{N} (I_k(\\beta))^2 \\right)\n$$\n\n**4. Argument for N-dependence and Decay Rate**\n\nThe function $u(x) = \\exp(\\beta\\cos(x))$ is analytic on the entire real line. A fundamental theorem of Fourier analysis states that the Fourier coefficients of a function that is analytic in a strip $\\{z \\in \\mathbb{C} : |\\text{Im}(z)| < a\\}$ decay exponentially, i.e., $|\\hat{u}_k| = O(e^{-a|k|})$. In our case, $u(z) = \\exp(\\beta\\cos(z))$ is entire, meaning it is analytic on the whole complex plane, which implies its Fourier coefficients decay faster than any exponential, a phenomenon known as spectral decay.\n\nThe asymptotic behavior of the modified Bessel functions for large order $k$ and fixed $\\beta$ is given by:\n$$\nI_k(\\beta) \\sim \\frac{1}{\\sqrt{2\\pi k}} \\left( \\frac{e\\beta}{2k} \\right)^k \\quad \\text{as } k \\to \\infty\n$$\nThe squared truncation error $E_N(\\beta) = \\sum_{|k|>N} |I_k(\\beta)|^2$ is dominated by the first term outside the sum, i.e., for $|k|=N+1$. Therefore, the error decays approximately as:\n$$\nE_N(\\beta) \\approx 2 |I_{N+1}(\\beta)|^2 \\sim 2 \\left( \\frac{1}{\\sqrt{2\\pi (N+1)}} \\left( \\frac{e\\beta}{2(N+1)} \\right)^{N+1} \\right)^2 = \\frac{1}{\\pi(N+1)} \\left( \\frac{e\\beta}{2(N+1)} \\right)^{2(N+1)}\n$$\nThis demonstrates super-geometric (or spectral) convergence. For a fixed $\\beta$, as $N$ increases, the term $(\\frac{1}{N+1})^{2(N+1)}$ ensures extremely rapid decay.\n\nThe parameter $\\beta$ controls the \"peakedness\" of the function $u(x)$.\n- For small $\\beta$, $u(x) \\approx 1 + \\beta\\cos(x)$, which is smooth and slowly varying. The energy is concentrated in low-frequency modes ($I_0, I_1$), and the coefficients $I_k(\\beta)$ for $k>1$ become very small very quickly. The truncation error is small even for small $N$.\n- For large $\\beta$, $u(x)$ becomes sharply peaked around $x=0$ and very small elsewhere. Representing such a sharp feature requires significant contributions from many high-frequency modes. The coefficients $I_k(\\beta)$ remain non-negligible for a wider range of $k$ before the asymptotic decay takes over. Consequently, for a fixed $N$, the truncation error $E_N(\\beta)$ will be larger for larger $\\beta$. The \"effective\" decay rate observed at finite $N$ is slower for large $\\beta$ because the asymptotic regime where decay is rapid is pushed to higher values of $N$.", "answer": "```python\nimport numpy as np\nfrom scipy.special import i0, iv\n\ndef solve():\n    \"\"\"\n    Computes the L2 truncation error for the Fourier series of exp(beta*cos(x)).\n    \n    The squared L2 truncation error is given by:\n    E_N(beta) = ||u||^2 - sum_{k=-N to N} |u_k|^2\n    \n    Using properties of modified Bessel functions, this can be shown to be:\n    E_N(beta) = I_0(2*beta) - (I_0(beta)^2 + 2 * sum_{k=1 to N} I_k(beta)^2)\n    where I_k is the modified Bessel function of the first kind of order k.\n    \"\"\"\n    \n    # Test cases from the problem statement\n    # Each case is a tuple (beta, N)\n    test_cases = [\n        (0.0, 0),\n        (0.5, 0),\n        (0.5, 5),\n        (2.0, 10),\n        (5.0, 5),\n        (5.0, 20),\n    ]\n\n    results = []\n    for beta, N in test_cases:\n        # Calculate the total energy term: I_0(2*beta)\n        total_energy = i0(2.0 * beta)\n\n        # Calculate the sum of squared coefficients for |k| <= N\n        # Start with the k=0 term: I_0(beta)^2\n        sum_sq_coeffs = i0(beta)**2\n\n        # Add the terms for k = 1 to N.\n        # The sum is 2 * sum_{k=1 to N} I_k(beta)^2 due to symmetry I_{-k} = I_k\n        if N > 0:\n            # Generate array of orders k from 1 to N\n            k_values = np.arange(1, N + 1)\n            # Calculate I_k(beta) for all k in k_values\n            bessel_coeffs = iv(k_values, beta)\n            # Sum the squares and multiply by 2\n            sum_sq_coeffs += 2.0 * np.sum(bessel_coeffs**2)\n            \n        # The truncation error is the difference\n        error = total_energy - sum_sq_coeffs\n        results.append(error)\n\n    # Format the final output string as specified\n    # The results are expected to be floating-point numbers.\n    output_str = \"[\" + \",\".join(map(str, results)) + \"]\"\n    print(output_str)\n\n# Run the solver\nsolve()\n\n```", "id": "3615049"}]}