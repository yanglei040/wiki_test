{"hands_on_practices": [{"introduction": "Accurately modeling wave propagation is fundamental in geophysics, from seismic imaging to global circulation models. This first exercise provides a foundational analysis of how different numerical schemes handle simple wave transport. By comparing a classical high-order scheme with one specifically optimized for low dispersion, you will gain practical insight into the trade-offs between formal mathematical accuracy and the practical fidelity of wave simulation across different length scales [@problem_id:3581900].", "problem": "Consider the one-dimensional linear advection equation $u_t + c\\,u_x = 0$ with constant speed $c  0$ on a uniform grid with spacing $\\Delta x$ and periodic boundary conditions. Let the Courant number be defined as $\\nu = c\\,\\Delta t/\\Delta x$. You will compare two spatial discretizations for the first derivative $u_x$ coupled to the same explicit time integrator, and quantify their numerical dispersion (phase error) and numerical dissipation (amplitude error) across the non-dimensional wavenumber band $k\\Delta x \\in [0,\\pi]$. All angles must be expressed in radians.\n\nBase the analysis on the following principles and well-tested formulas:\n\n- Fourier mode analysis: for a Fourier mode $u_j^n \\propto \\exp(i j \\xi)$ with $\\xi = k\\Delta x \\in [0,\\pi]$, any linear time-stepping scheme applied to the discretized spatial operator yields a per-step complex amplification factor $G(\\xi)$ such that $u^{n+1} = G(\\xi) u^n$.\n- For the exact partial differential equation, the per-step exact amplification factor is $\\exp(-i \\nu \\xi)$.\n- For a semi-discrete method-of-lines with a finite-difference approximation of $u_x$ on a symmetric stencil, the discrete spatial Fourier symbol is $i\\,\\kappa(\\xi)/\\Delta x$, where $\\kappa(\\xi)$ is the modified wavenumber of the stencil. For an antisymmetric, $(2M+1)$-point central stencil with weights $\\{b_m\\}_{m=1}^M$ defined by\n$$\n(D u)_j \\approx \\frac{1}{\\Delta x}\\sum_{m=1}^M b_m\\left(u_{j+m} - u_{j-m}\\right),\n$$\nthe modified wavenumber is\n$$\n\\kappa(\\xi) = 2\\sum_{m=1}^M b_m \\sin(m\\xi).\n$$\n- For explicit classical fourth-order Runge–Kutta (RK4), whose stability function is\n$$\nR(z) = 1 + z + \\frac{z^2}{2} + \\frac{z^3}{6} + \\frac{z^4}{24},\n$$\nthe numerical amplification factor of the fully discrete scheme is $G(\\xi) = R\\!\\left(-i\\,\\nu\\,\\kappa(\\xi)\\right)$.\n\nYou will study two seven-point stencils ($M=3$), both coupled to the same RK4 time integrator at $\\nu = 0.5$:\n\n- Classical sixth-order central difference (on a $7$-point symmetric stencil):\n$$\nb_1 = \\frac{45}{60} = 0.75,\\quad b_2 = -\\frac{9}{60} = -0.15,\\quad b_3 = \\frac{1}{60}.\n$$\n- An optimized low-dispersion, non-compact, explicit $7$-point stencil with coefficients designed to reduce dispersion error over a wide band (a well-known choice in the literature of Dispersion-Relation-Preserving schemes):\n$$\nb_1 = 0.770882380518225,\\quad b_2 = -0.166705904414580,\\quad b_3 = 0.020843142770311.\n$$\n\nFor each stencil, define the per-step phase error and amplitude error as functions of $\\xi$ by\n$$\ne_{\\mathrm{phase}}(\\xi) = \\operatorname{wrap}_{(-\\pi,\\pi]}\\!\\left(\\arg(G(\\xi)) + \\nu\\,\\xi\\right),\n\\qquad\ne_{\\mathrm{amp}}(\\xi) = \\left|\\;|G(\\xi)| - 1\\;\\right|,\n$$\nwhere $\\arg(\\cdot)$ is the principal argument and $\\operatorname{wrap}_{(-\\pi,\\pi]}(\\theta)$ wraps any real angle $\\theta$ into $(-\\pi,\\pi]$ by adding or subtracting integer multiples of $2\\pi$.\n\nDefine a combined per-step error magnitude\n$$\nE(\\xi) = \\sqrt{e_{\\mathrm{phase}}(\\xi)^2 + e_{\\mathrm{amp}}(\\xi)^2}.\n$$\n\nYour program must, for $\\nu = 0.5$ and a uniform grid of $N = 10001$ points in $\\xi \\in [0,\\pi]$ inclusive, compute the following quantities:\n\n- Test case 1 (float): the smallest $\\xi^\\star \\in (0,\\pi]$ at which the optimized stencil achieves strictly smaller combined error than the classical stencil, i.e., the smallest sampled $\\xi$ such that $E_{\\mathrm{opt}}(\\xi)  E_{\\mathrm{classical}}(\\xi)$. If no such $\\xi$ exists on the grid, return $\\mathrm{NaN}$.\n- Test case 2 (boolean): at $\\xi = \\pi/2$, does the optimized stencil have strictly smaller absolute phase error than the classical stencil? Return $True$ if $\\left|e_{\\mathrm{phase,opt}}(\\pi/2)\\right|  \\left|e_{\\mathrm{phase,classic}}(\\pi/2)\\right|$, otherwise $False$.\n- Test case 3 (boolean): at $\\xi = 0$, do both stencils have amplitude error below a tolerance of $10^{-12}$? Return $True$ if $\\left|e_{\\mathrm{amp,opt}}(0)\\right| \\le 10^{-12}$ and $\\left|e_{\\mathrm{amp,classic}}(0)\\right| \\le 10^{-12}$, otherwise $False$.\n- Test case 4 (float): the maximum absolute amplitude error of the classical stencil over $\\xi \\in [0,\\pi]$, i.e., $\\max_{\\xi} \\left|e_{\\mathrm{amp,classic}}(\\xi)\\right|$.\n- Test case 5 (float): the maximum absolute amplitude error of the optimized stencil over $\\xi \\in [0,\\pi]$, i.e., $\\max_{\\xi} \\left|e_{\\mathrm{amp,opt}}(\\xi)\\right|$.\n\nAngle quantities must be in radians. All floating-point outputs must be rounded to six decimal places.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order specified above, for the five test cases:\n$[\\xi^\\star, \\text{bool\\_at\\_}\\pi/2, \\text{bool\\_at\\_}0, \\max e_{\\mathrm{amp,classic}}, \\max e_{\\mathrm{amp,opt}}]$.", "solution": "The problem requires a comparative analysis of two numerical schemes for the one-dimensional linear advection equation:\n$$\n\\frac{\\partial u}{\\partial t} + c \\frac{\\partial u}{\\partial x} = 0\n$$\nwhere $u(x,t)$ is the transported quantity and $c  0$ is the constant wave speed. The analysis is performed in the Fourier domain for a uniform spatial grid with spacing $\\Delta x$ and a constant time step $\\Delta t$. The key parameter is the Courant number, defined as $\\nu = c\\Delta t / \\Delta x$.\n\nWe analyze the behavior of the schemes on a single Fourier mode, $u_j^n = \\hat{u}^n(k) e^{i(k x_j)} = \\hat{u}^n(\\xi) e^{ij\\xi}$, where $x_j = j\\Delta x$ and $\\xi = k\\Delta x$ is the non-dimensional wavenumber. The exact solution evolves this mode over one time step $\\Delta t$ as:\n$$\nu(x, t+\\Delta t) = u(x-c\\Delta t, t) \\implies \\hat{u}^{n+1} = \\hat{u}^n e^{-ikc\\Delta t} = \\hat{u}^n e^{-i\\nu\\xi}\n$$\nThe term $G_{\\text{exact}}(\\xi) = e^{-i\\nu\\xi}$ is the exact amplification factor. It has a magnitude of $|G_{\\text{exact}}(\\xi)| = 1$, indicating no amplitude change, and a phase of $\\phi_{\\text{exact}}(\\xi) = -\\nu\\xi$.\n\nA numerical scheme approximates this evolution by $u_j^{n+1} = \\mathcal{L}(u^n)_j$, which in the Fourier domain becomes $\\hat{u}^{n+1} = G(\\xi) \\hat{u}^n$. The complex quantity $G(\\xi)$ is the numerical amplification factor of the fully discrete scheme.\n\nThe method of lines first discretizes the spatial derivative $\\frac{\\partial u}{\\partial x}$, yielding a system of ordinary differential equations (ODEs). For a general $(2M+1)$-point antisymmetric central difference scheme, this is:\n$$\n\\frac{du_j}{dt} = -c (D u)_j = -\\frac{c}{\\Delta x} \\sum_{m=1}^M b_m(u_{j+m} - u_{j-m})\n$$\nApplying this operator to the Fourier mode $e^{ij\\xi}$ gives:\n$$\nD e^{ij\\xi} = \\frac{1}{\\Delta x} \\sum_{m=1}^M b_m(e^{i(j+m)\\xi} - e^{i(j-m)\\xi}) = \\frac{e^{ij\\xi}}{\\Delta x} \\sum_{m=1}^M b_m(e^{im\\xi} - e^{-im\\xi}) = \\frac{e^{ij\\xi}}{\\Delta x} \\left( 2i \\sum_{m=1}^M b_m \\sin(m\\xi) \\right)\n$$\nThis defines the Fourier symbol of the spatial operator as $i\\kappa(\\xi)/\\Delta x$, where $\\kappa(\\xi)$ is the modified wavenumber:\n$$\n\\kappa(\\xi) = 2\\sum_{m=1}^M b_m \\sin(m\\xi)\n$$\nThe semi-discrete system of ODEs in Fourier space is therefore $\\frac{d\\hat{u}}{dt} = -c \\frac{i\\kappa(\\xi)}{\\Delta x} \\hat{u}$.\n\nFor the two seven-point stencils ($M=3$) under consideration:\n- **Classical Sixth-Order:** With coefficients $b_1 = 45/60$, $b_2 = -9/60$, $b_3 = 1/60$, the modified wavenumber is:\n$$\n\\kappa_{\\text{classic}}(\\xi) = 2\\left(\\frac{45}{60}\\sin(\\xi) - \\frac{9}{60}\\sin(2\\xi) + \\frac{1}{60}\\sin(3\\xi)\\right)\n$$\n- **Optimized Low-Dispersion:** With coefficients $b_1 = 0.770882380518225$, $b_2 = -0.166705904414580$, $b_3 = 0.020843142770311$, the modified wavenumber is:\n$$\n\\kappa_{\\text{opt}}(\\xi) = 2(b_1\\sin(\\xi) + b_2\\sin(2\\xi) + b_3\\sin(3\\xi))\n$$\n\nThe semi-discrete ODE system $\\frac{d\\hat{u}}{dt} = \\lambda \\hat{u}$, where $\\lambda = -ic\\kappa(\\xi)/\\Delta x$, is integrated forward in time using the explicit fourth-order Runge-Kutta (RK4) method. The amplification factor for a single RK4 step on $y'=\\lambda y$ is given by its stability function, $R(z)$, where $z = \\lambda \\Delta t$.\n$$\nz = \\left(-i\\frac{c\\kappa(\\xi)}{\\Delta x}\\right) \\Delta t = -i \\left(\\frac{c\\Delta t}{\\Delta x}\\right) \\kappa(\\xi) = -i\\nu\\kappa(\\xi)\n$$\nThe numerical amplification factor for the fully discrete scheme is thus $G(\\xi) = R(-i\\nu\\kappa(\\xi))$, where $R(z)$ is the RK4 polynomial:\n$$\nR(z) = 1 + z + \\frac{z^2}{2} + \\frac{z^3}{6} + \\frac{z^4}{24}\n$$\n\nNumerical errors are quantified by comparing the numerical amplification factor $G(\\xi)$ to the exact one $G_{\\text{exact}}(\\xi)$.\n- The **phase error** measures the difference in phase speeds. The numerical phase is $\\phi_{\\text{num}}(\\xi) = \\arg(G(\\xi))$. The per-step phase error is the difference between the numerical and exact phases, wrapped to the interval $(-\\pi, \\pi]$:\n$$\ne_{\\text{phase}}(\\xi) = \\operatorname{wrap}_{(-\\pi,\\pi]}\\!\\left(\\phi_{\\text{num}}(\\xi) - \\phi_{\\text{exact}}(\\xi)\\right) = \\operatorname{wrap}_{(-\\pi,\\pi]}\\!\\left(\\arg(G(\\xi)) + \\nu\\xi\\right)\n$$\nA non-zero phase error causes numerical dispersion, where waves of different wavenumbers travel at incorrect speeds relative to each other.\n- The **amplitude error** measures the change in a mode's amplitude per step. The numerical amplitude is $|G(\\xi)|$. The per-step amplitude error is:\n$$\ne_{\\text{amp}}(\\xi) = \\left|\\;|G(\\xi)| - 1\\;\\right|\n$$\nA non-zero amplitude error corresponds to numerical dissipation (if $|G(\\xi)|  1$) or instability (if $|G(\\xi)|  1$). For a stable scheme, this error represents undesired damping.\n- The **combined error** provides a single metric for the overall error magnitude:\n$$\nE(\\xi) = \\sqrt{e_{\\mathrm{phase}}(\\xi)^2 + e_{\\mathrm{amp}}(\\xi)^2}\n$$\n\nThe solution is obtained by executing the following steps for the given Courant number $\\nu=0.5$:\n1.  Define a discrete grid of $N=10001$ wavenumbers $\\xi_j$ uniformly spaced in $[0, \\pi]$.\n2.  For each stencil (classical and optimized), perform the following:\n    a.  Compute the modified wavenumber vector $\\kappa(\\xi_j)$ using its respective coefficients.\n    b.  Compute the complex vector $z(\\xi_j) = -i\\nu\\kappa(\\xi_j)$.\n    c.  Evaluate the RK4 stability polynomial $G(\\xi_j) = R(z(\\xi_j))$.\n    d.  Calculate the phase error vector $e_{\\text{phase}}(\\xi_j)$, ensuring angles are correctly wrapped into $(-\\pi, \\pi]$.\n    e.  Calculate the amplitude error vector $e_{\\text{amp}}(\\xi_j)$.\n    f.  Calculate the combined error vector $E(\\xi_j)$.\n3.  Using the computed error vectors for both stencils, answer the five test questions:\n    - **Test 1**: Find the first index $j  0$ where $E_{\\text{opt}}(\\xi_j)  E_{\\text{classic}}(\\xi_j)$ and report the corresponding $\\xi_j$.\n    - **Test 2**: At the grid point closest to $\\xi=\\pi/2$, compare the absolute values of the phase errors.\n    - **Test 3**: At $\\xi_0=0$, check if the amplitude errors for both stencils are below the tolerance $10^{-12}$. This is expected from theory, as $\\kappa(0) = 0 \\implies G(0) = 1 \\implies e_{\\text{amp}}(0) = 0$.\n    - **Test 4  5**: Find the maximum value of the amplitude error vectors over the entire domain $[0, \\pi]$ for each stencil.\n4.  Format the final results as a comma-separated list according to the specified format rules.\n\nThis procedure provides a rigorous, quantitative comparison of the dispersion and dissipation properties of the two spatial discretization schemes when coupled with an RK4 time integrator.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Analyzes and compares two finite-difference schemes for the 1D linear\n    advection equation by computing their numerical dispersion and dissipation\n    errors.\n    \"\"\"\n    # Define problem parameters and test cases from the problem statement.\n    nu = 0.5\n    N = 10001\n    b_classic = [45.0 / 60.0, -9.0 / 60.0, 1.0 / 60.0]\n    b_opt = [0.770882380518225, -0.166705904414580, 0.020843142770311]\n    \n    # Create the non-dimensional wavenumber grid\n    xi = np.linspace(0, np.pi, N, endpoint=True)\n\n    def get_errors(b_coeffs, nu_val, xi_grid):\n        \"\"\"\n        Calculates error metrics for a given stencil and Courant number.\n        \"\"\"\n        # Calculate the modified wavenumber kappa(xi)\n        # kappa(xi) = 2 * sum_{m=1}^{3} b_m * sin(m*xi)\n        kappa = (2 * b_coeffs[0] * np.sin(1 * xi_grid) +\n                 2 * b_coeffs[1] * np.sin(2 * xi_grid) +\n                 2 * b_coeffs[2] * np.sin(3 * xi_grid))\n        \n        # Argument for the RK4 stability function\n        z = -1j * nu_val * kappa\n        \n        # Numerical amplification factor G(xi) from RK4 stability function R(z)\n        # R(z) = 1 + z + z^2/2 + z^3/6 + z^4/24\n        G = 1 + z + z**2 / 2.0 + z**3 / 6.0 + z**4 / 24.0\n\n        # Calculate phase error, e_phase = wrap(arg(G) + nu*xi)\n        e_phase_raw = np.angle(G) + nu_val * xi_grid\n        \n        # Wrap the phase error to the interval (-pi, pi]\n        # The formula is theta - 2*pi*floor((theta+pi)/(2*pi))\n        e_phase = e_phase_raw - 2 * np.pi * np.floor((e_phase_raw + np.pi) / (2 * np.pi))\n\n        # Calculate amplitude error, e_amp = ||G| - 1|\n        e_amp = np.abs(np.abs(G) - 1.0)\n        \n        # Calculate combined error magnitude E\n        E = np.sqrt(e_phase**2 + e_amp**2)\n\n        return e_phase, e_amp, E\n\n    # Calculate errors for both stencils\n    e_phase_c, e_amp_c, E_c = get_errors(b_classic, nu, xi)\n    e_phase_o, e_amp_o, E_o = get_errors(b_opt, nu, xi)\n\n    # --- Test Cases ---\n\n    # Test case 1: Smallest xi_star in (0, pi] where E_opt  E_classic\n    # We search in the slice [1:] to exclude xi=0\n    indices = np.where(E_o[1:]  E_c[1:])[0]\n    if len(indices)  0:\n        # Add 1 to the index to map it back to the original `xi` array\n        first_index = indices[0] + 1\n        xi_star = xi[first_index]\n    else:\n        xi_star = np.nan\n\n    # Test case 2: At xi = pi/2, is |e_phase_opt|  |e_phase_classic|?\n    idx_pi_2 = np.argmin(np.abs(xi - np.pi / 2.0))\n    is_opt_better_phase = np.abs(e_phase_o[idx_pi_2])  np.abs(e_phase_c[idx_pi_2])\n\n    # Test case 3: At xi = 0, do both stencils have amplitude error = 1e-12?\n    # At xi=0, kappa=0, z=0, G=1, so e_amp should be 0. We check for numerical precision.\n    is_amp_zero_at_origin = (e_amp_c[0] = 1e-12) and (e_amp_o[0] = 1e-12)\n\n    # Test case 4: Maximum absolute amplitude error of the classical stencil\n    max_amp_c = np.max(e_amp_c)\n\n    # Test case 5: Maximum absolute amplitude error of the optimized stencil\n    max_amp_o = np.max(e_amp_o)\n\n    # --- Final Output Formatting ---\n    results = [\n        xi_star,\n        is_opt_better_phase,\n        is_amp_zero_at_origin,\n        max_amp_c,\n        max_amp_o\n    ]\n\n    def format_item(item):\n        \"\"\"Formats a result item according to the problem specification.\"\"\"\n        if isinstance(item, (bool, np.bool_)):\n            return str(item)\n        if isinstance(item, (float, np.floating)):\n            if np.isnan(item):\n                return 'NaN'\n            return f\"{item:.6f}\"\n        return str(item)\n\n    formatted_results = [format_item(r) for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3581900"}, {"introduction": "While linear schemes are useful, many geophysical phenomena involve sharp fronts or discontinuities, such as in contaminant transport or shock waves, where linear methods produce unphysical oscillations. This practice introduces the concept of non-linear flux limiters, a powerful technique to ensure solutions remain physically realistic and sharp. You will implement and compare several common limiters, learning how to control numerical errors in simulations of advection-dominated problems [@problem_id:3581892].", "problem": "You are tasked with analyzing the dispersion and diffusion characteristics of three Total Variation Diminishing (TVD) flux limiters when applied to a semi-discrete Monotonic Upstream-centered Scheme for Conservation Laws (MUSCL) spatial discretization of the one-dimensional linear advection equation. The goal is to numerically estimate the effective modified wavenumber and to decide which limiter yields the lowest phase error for a small-amplitude sinusoidal wave.\n\nStart from the one-dimensional linear advection equation, which is a fundamental balance law in geophysical fluid dynamics,\n$$\n\\frac{\\partial u}{\\partial t} + a \\frac{\\partial u}{\\partial x} = 0,\n$$\nwhere $u(x,t)$ is the advected scalar field, $a$ is the constant advection speed, and $x$ denotes position. Consider a semi-discrete finite volume formulation on a uniform periodic grid with $N$ points, spacing $\\Delta x = L/N$ on a domain of length $L$.\n\nOn a uniform grid, denote cell-centered values $u_i$ and numerical fluxes $F_{i+1/2}$. For positive advection speed $a0$, define the MUSCL left state at the interface $x_{i+1/2}$ by\n$$\nu_{i+1/2}^{-} = u_i + \\frac{1}{2}\\,\\phi(r_i)\\,(u_i - u_{i-1}),\n$$\nwhere $\\phi(r)$ is a flux limiter function and $r_i$ is the smoothness ratio,\n$$\nr_i = \\frac{u_i - u_{i-1}}{u_{i+1} - u_i + \\varepsilon},\n$$\nwith small $\\varepsilon  0$ to avoid division by zero. The numerical flux is\n$$\nF_{i+1/2} = a\\,u_{i+1/2}^{-},\n$$\nand the semi-discrete operator is\n$$\n\\left(\\mathcal{L}u\\right)_i = -\\frac{F_{i+1/2} - F_{i-1/2}}{\\Delta x}.\n$$\n\nYou will compare three limiter functions:\n- Minmod limiter:\n$$\n\\phi_{\\text{minmod}}(r) = \\max\\!\\left(0,\\,\\min\\!\\left(1,\\,r\\right)\\right).\n$$\n- Superbee limiter:\n$$\n\\phi_{\\text{superbee}}(r) = \\max\\!\\left(0,\\,\\min\\!\\left(2r,\\,1\\right),\\,\\min\\!\\left(r,\\,2\\right)\\right).\n$$\n- Monotonized Central limiter (MC):\n$$\n\\phi_{\\text{MC}}(r) = \\max\\!\\left(0,\\,\\min\\!\\left(\\frac{1+r}{2},\\,2,\\,2r\\right)\\right).\n$$\n\nDefine a small-amplitude sinusoidal initial field\n$$\nu_i = A\\,\\sin\\!\\left(2\\pi\\,\\frac{m\\,i}{N}\\right),\n$$\nfor integer wavenumber index $m$ on the periodic grid. Let the physical wavenumber be\n$$\nk = \\frac{2\\pi m}{L}\\quad\\text{(in radians per meter)}.\n$$\n\nTo assess the effective modified wavenumber, compute the discrete Fourier transform of $u$ and the semi-discrete operator $\\mathcal{L}u$. Let $\\widehat{u}(k)$ and $\\widehat{\\mathcal{L}u}(k)$ denote the discrete Fourier coefficients at index $m$. The exact continuous operator gives $\\widehat{\\mathcal{L}u}(k) / \\widehat{u}(k) = -a\\, i\\, k$. Use this identity to define a numerical estimate of the effective modified wavenumber:\n$$\nk_{\\text{eff}} = -\\frac{\\operatorname{Im}\\!\\left(\\widehat{\\mathcal{L}u}(k) / \\widehat{u}(k)\\right)}{a}\\quad\\text{(in radians per meter)}.\n$$\n\nDefine the phase error for the spatial operator as the relative deviation of $k_{\\text{eff}}$ from the true $k$:\n$$\nE_{\\text{phase}} = \\frac{\\left|k_{\\text{eff}} - k\\right|}{k}\\quad\\text{(dimensionless)}.\n$$\n\nImplement the above for each limiter, for a set of test cases described below. For each test case, compute the three values $k_{\\text{eff}}$ (in radians per meter) and the index of the limiter with the smallest phase error. Use the following index convention: $0$ for minmod, $1$ for superbee, $2$ for MC.\n\nYour program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case contributes a sub-list of four numbers in the order $[k_{\\text{eff,minmod}},k_{\\text{eff,superbee}},k_{\\text{eff,MC}},\\text{best}]$, with $k_{\\text{eff}}$ values in radians per meter and the best limiter expressed as an integer. For example: \"[[...,...,...,...],[...,...,...,...],...]\".\n\nUse the following test suite, with all quantities in the indicated units:\n- Case $1$: $N=512$, $L=1$ meter, $a=1$ meter per second, $m=8$, $A=10^{-3}$.\n- Case $2$: $N=512$, $L=1$ meter, $a=1$ meter per second, $m=1$, $A=10^{-6}$.\n- Case $3$: $N=512$, $L=1$ meter, $a=1$ meter per second, $m=64$, $A=10^{-3}$.\n- Case $4$: $N=1024$, $L=1$ meter, $a=1$ meter per second, $m=100$, $A=10^{-3}$.\n\nEnsure periodic boundary conditions are enforced in your discretization. Your program must be self-contained, must not read any input, and must use the runtime environment specified. All $k_{\\text{eff}}$ values must be expressed in radians per meter, and the final output must follow the exact format described above.", "solution": "The problem presented is a valid and well-posed exercise in computational geophysics, specifically in the analysis of numerical methods for conservation laws. It requires the implementation and comparison of a semi-discrete Monotonic Upstream-centered Scheme for Conservation Laws (MUSCL) using three different Total Variation Diminishing (TVD) flux limiters. The analysis is based on the concept of a modified wavenumber, a standard technique for quantifying the numerical dispersion and diffusion errors of a finite difference or finite volume scheme. All parameters and definitions are provided, and the task is scientifically sound, objective, and computationally feasible. We may therefore proceed with a full solution.\n\nThe core of the problem is to assess how accurately a numerical scheme approximates the spatial derivative operator for a single Fourier mode. The one-dimensional linear advection equation,\n$$\n\\frac{\\partial u}{\\partial t} + a \\frac{\\partial u}{\\partial x} = 0,\n$$\ndescribes the transport of a scalar quantity $u(x,t)$ at a constant speed $a$. In the Fourier domain, the spatial derivative operator $\\frac{\\partial}{\\partial x}$ corresponds to multiplication by $i k$, where $k$ is the wavenumber and $i = \\sqrt{-1}$. Thus, the Fourier transform of the spatial part of the equation, $-a \\frac{\\partial u}{\\partial x}$, is $-a(ik)\\widehat{u}(k)$. A numerical scheme will approximate this operation, but with some error. The scheme's action in the Fourier domain can be described by a complex factor, from which we can extract an effective, or modified, wavenumber that the scheme effectively \"sees.\"\n\nThe problem specifies a semi-discrete finite volume scheme on a uniform periodic grid with $N$ cells of width $\\Delta x = L/N$. The rate of change of the cell-averaged value $u_i$ is given by the divergence of the numerical flux $F$:\n$$\n\\frac{du_i}{dt} = \\left(\\mathcal{L}u\\right)_i = -\\frac{F_{i+1/2} - F_{i-1/2}}{\\Delta x}.\n$$\nHere, A second-order accurate spatial discretization is achieved using the MUSCL-Hancock method. Since the advection speed $a$ is positive, we only need to reconstruct the state at the \"left\" of the interface $x_{i+1/2}$, which we denote $u_{i+1/2}^{-}$. The numerical flux is then simply $F_{i+1/2} = a u_{i+1/2}^{-}$. The MUSCL reconstruction is given by:\n$$\nu_{i+1/2}^{-} = u_i + \\frac{1}{2}\\,\\phi(r_i)\\,(u_i - u_{i-1}).\n$$\nThis formula represents a linear interpolation from the cell center $x_i$ to the interface $x_{i+1/2}$, where the slope is taken from the upwind side $(u_i - u_{i-1})$ and is modified by a flux limiter function, $\\phi(r_i)$. The limiter's purpose is to prevent spurious oscillations (to be TVD) by adjusting the slope based on the local smoothness of the solution, which is measured by the ratio of consecutive gradients:\n$$\nr_i = \\frac{u_i - u_{i-1}}{u_{i+1} - u_i + \\varepsilon}.\n$$\nA small parameter $\\varepsilon$ is added to prevent division by zero in regions of zero gradient. We will compare three well-known flux limiter functions:\n1.  **Minmod**: $\\phi_{\\text{minmod}}(r) = \\max\\!\\left(0,\\,\\min\\!\\left(1,\\,r\\right)\\right)$. This is the most dissipative of the three.\n2.  **Superbee**: $\\phi_{\\text{superbee}}(r) = \\max\\!\\left(0,\\,\\min\\!\\left(2r,\\,1\\right),\\,\\min\\!\\left(r,\\,2\\right)\\right)$. This is a highly compressive limiter.\n3.  **Monotonized Central (MC)**: $\\phi_{\\text{MC}}(r) = \\max\\!\\left(0,\\,\\min\\!\\left(\\frac{1+r}{2},\\,2,\\,2r\\right)\\right)$. This limiter provides a balance between dissipativity and compressiveness.\n\nTo analyze the scheme's properties, we apply the discrete operator $\\mathcal{L}$ to a single sinusoidal mode with a small amplitude, $u_i = A\\,\\sin(k x_i)$, where $x_i = i\\Delta x$ and $k = 2\\pi m / L$. We then compute the Discrete Fourier Transform (DFT) of both the input field $u$ and the resulting field $\\mathcal{L}u$. Let $\\widehat{u}(k)$ and $\\widehat{\\mathcal{L}u}(k)$ be the complex DFT coefficients corresponding to the wavenumber index $m$. The ratio of these coefficients, $Z(k) = \\widehat{\\mathcal{L}u}(k) / \\widehat{u}(k)$, is the transfer function of the discrete operator $\\mathcal{L}$ for this specific mode.\n\nFor the exact continuous operator, this ratio is $-aik$. For the numerical operator, the ratio will be a complex number, $Z(k) = -a(\\alpha_{\\text{num}}(k) + i k_{\\text{eff}}(k))$. The real part, $\\alpha_{\\text{num}}$, represents numerical diffusion (amplitude error), and the imaginary part, $k_{\\text{eff}}$, is the effective or modified wavenumber that governs the phase speed of the numerical solution. Deviation of $k_{\\text{eff}}$ from the true wavenumber $k$ results in numerical dispersion (phase error). Following the problem's definition, we estimate the effective wavenumber as:\n$$\nk_{\\text{eff}} = -\\frac{\\operatorname{Im}\\!\\left(\\widehat{\\mathcal{L}u}(k) / \\widehat{u}(k)\\right)}{a}.\n$$\nThe phase error is then quantified by the relative deviation from the true wavenumber:\n$$\nE_{\\text{phase}} = \\frac{\\left|k_{\\text{eff}} - k\\right|}{k}.\n$$\n\nThe overall algorithm for each test case is as follows:\n1.  Initialize grid parameters ($N$, $L$, $\\Delta x$) and physical parameters ($a$, $m$, $A$).\n2.  Generate the discrete initial field $u$ as a sine wave.\n3.  For each of the three specified limiter functions:\n    a. Calculate the smoothness ratio vector $r$ from $u$, ensuring periodic boundary conditions are handled for the stencil points $u_{i-1}$ and $u_{i+1}$. This is conveniently achieved using array-rolling operations.\n    b. Apply the limiter function $\\phi(r)$ element-wise.\n    c. Assemble the MUSCL left-state reconstruction $u_{i+1/2}^{-}$ and the flux $F_{i+1/2}$.\n    d. Compute the semi-discrete operator vector $\\mathcal{L}u$ using the flux divergence, again with periodic boundary conditions.\n    e. Compute the DFTs of $u$ and $\\mathcal{L}u$ to obtain the coefficients $\\widehat{u}[m]$ and $\\widehat{\\mathcal{L}u}[m]$.\n    f. Calculate $k_{\\text{eff}}$ and the corresponding $E_{\\text{phase}}$.\n4.  Compare the three phase error values and determine the index of the limiter ($0$ for minmod, $1$ for superbee, $2$ for MC) that yields the minimum error.\n5.  Collect the three $k_{\\text{eff}}$ values and the index of the best limiter into a result list for the test case.\n\nThis procedure, repeated for all test cases, will provide a quantitative comparison of the dispersive properties of the chosen numerical schemes. A smaller phase error indicates that the scheme is better at propagating waves of that particular wavenumber with the correct phase speed.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef phi_minmod(r):\n    \"\"\"Minmod flux limiter function.\"\"\"\n    return np.maximum(0, np.minimum(1, r))\n\ndef phi_superbee(r):\n    \"\"\"Superbee flux limiter function.\n    \n    Formula: max(0, min(2r, 1), min(r, 2))\n    \"\"\"\n    term2 = np.minimum(2 * r, 1)\n    term3 = np.minimum(r, 2)\n    # Implement max of three arguments using nested binary max\n    return np.maximum(0, np.maximum(term2, term3))\n\ndef phi_mc(r):\n    \"\"\"Monotonized Central (MC) flux limiter function.\n    \n    Formula: max(0, min((1+r)/2, 2, 2r))\n    \"\"\"\n    # Safely implement min of three arguments using nested binary min\n    min_val = np.minimum((1 + r) / 2.0, 2.0)\n    min_val = np.minimum(min_val, 2 * r)\n    return np.maximum(0, min_val)\n\ndef apply_op_L(u, a, dx, limiter_func):\n    \"\"\"\n    Applies the semi-discrete MUSCL operator L to a field u.\n    \"\"\"\n    N = len(u)\n    # Small constant to prevent division by zero in the smoothness ratio r.\n    epsilon = 1e-15 \n\n    # Use np.roll to efficiently handle periodic boundary conditions.\n    u_prev = np.roll(u, 1)\n    u_next = np.roll(u, -1)\n\n    # Numerator of r_i: u_i - u_{i-1}\n    du_backward = u - u_prev\n    # Denominator of r_i: u_{i+1} - u_i\n    du_forward = u_next - u\n\n    # Calculate the smoothness ratio r_i vector.\n    # The small epsilon handles cases where du_forward is near zero.\n    r = du_backward / (du_forward + epsilon)\n\n    # Apply the chosen flux limiter function.\n    phi_r = limiter_func(r)\n\n    # Compute the left state at interface i+1/2 using MUSCL reconstruction.\n    # u_{i+1/2}^- = u_i + 0.5 * phi(r_i) * (u_i - u_{i-1})\n    u_left = u + 0.5 * phi_r * du_backward\n\n    # For a0, the numerical flux is F_{i+1/2} = a * u_{i+1/2}^-.\n    F_iph = a * u_left\n\n    # Get the flux at interface i-1/2 by rolling the flux array.\n    F_imh = np.roll(F_iph, 1)\n\n    # Compute the semi-discrete operator (Lu)_i = -(F_{i+1/2} - F_{i-1/2}) / dx.\n    Lu = -(F_iph - F_imh) / dx\n    \n    return Lu\n\ndef solve():\n    \"\"\"\n    Main function to run the analysis for all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # (N, L, a, m, A)\n        (512, 1.0, 1.0, 8, 1e-3),\n        (512, 1.0, 1.0, 1, 1e-6),\n        (512, 1.0, 1.0, 64, 1e-3),\n        (1024, 1.0, 1.0, 100, 1e-3),\n    ]\n\n    limiters = [phi_minmod, phi_superbee, phi_mc]\n\n    all_results = []\n\n    for N, L, a, m, A in test_cases:\n        dx = L / N\n        \n        # Create the initial sinusoidal field u_i = A*sin(2*pi*m*i/N).\n        i_indices = np.arange(N)\n        u = A * np.sin(2 * np.pi * m * i_indices / N)\n\n        # Calculate the true physical wavenumber k.\n        k_true = 2 * np.pi * m / L\n\n        k_effs = []\n        phase_errors = []\n\n        # Compute the DFT of the initial condition. We only need this once.\n        u_hat = np.fft.fft(u)\n        \n        # Check if the spectral amplitude is non-zero to avoid division by zero.\n        if np.abs(u_hat[m])  1e-15:\n            # This case should not happen with the given initial condition.\n            # Handle gracefully if it does.\n            raise ValueError(f\"Zero amplitude at wavenumber m={m}\")\n\n        for limiter_func in limiters:\n            # Apply the semi-discrete operator L to the field u.\n            Lu = apply_op_L(u, a, dx, limiter_func)\n            \n            # Compute the DFT of the resulting field Lu.\n            Lu_hat = np.fft.fft(Lu)\n            \n            # Calculate the complex ratio Z(k) = Lu_hat[m] / u_hat[m].\n            ratio = Lu_hat[m] / u_hat[m]\n            \n            # Estimate the effective modified wavenumber k_eff = -Im(Z(k)) / a.\n            k_eff = -np.imag(ratio) / a\n            k_effs.append(k_eff)\n            \n            # Calculate the phase error.\n            phase_error = np.abs(k_eff - k_true) / k_true if k_true != 0 else np.abs(k_eff)\n            phase_errors.append(phase_error)\n\n        # Find the index of the limiter with the smallest phase error.\n        best_limiter_index = int(np.argmin(phase_errors))\n\n        # Assemble the results [k_eff_minmod, k_eff_superbee, k_eff_mc, best_idx].\n        case_result = k_effs + [best_limiter_index]\n        all_results.append(case_result)\n\n    # Format the final output string as specified: [[...],[...],...]\n    def format_list(lst):\n        # Format a single list of numbers into a string \"[v1,v2,v3,...]\".\n        return f\"[{','.join(f'{v:.15g}' if not isinstance(v, int) else str(v) for v in lst)}]\"\n\n    final_output = f\"[{','.join(map(format_list, all_results))}]\"\n    print(final_output)\n\nsolve()\n```", "id": "3581892"}, {"introduction": "This final practice bridges the gap between numerical methods and their application to physically dispersive systems, like the propagation of seismic surface waves. Using the Euler-Bernoulli beam equation as an analogue for lithospheric flexure, you will analyze how well different numerical discretizations capture the system's true frequency spectrum. This exercise highlights the critical importance of accurately resolving the dispersion relation to correctly model the behavior of complex geophysical structures [@problem_id:3581957].", "problem": "You are to construct a computational benchmark for dispersive normal modes using a one-dimensional Euler–Bernoulli flexural wave model, which is a standard proxy in computational geophysics for lithospheric flexure and other thin-plate phenomena. The goal is to quantify and control numerical dispersion and diffusion by comparing discrete-mode eigenfrequencies against exact analytical values for a thin elastic beam.\n\nConsider the initial-boundary-value problem governed by the linear Euler–Bernoulli beam equation\n$$\nu_{tt}(x,t) + c_b^2\\,u_{xxxx}(x,t) = 0,\\quad x\\in[0,L],\\ t\\ge 0,\n$$\nwith simply supported boundary conditions\n$$\nu(0,t) = 0,\\quad u(L,t) = 0,\\quad u_{xx}(0,t) = 0,\\quad u_{xx}(L,t) = 0.\n$$\nHere, $u(x,t)$ is the transverse displacement, $L$ is the beam length, and $c_b$ is the flexural wave speed parameter with units of $\\mathrm{m^2/s}$ so that angular frequency has units of $\\mathrm{rad/s}$. The normal-mode solution ansatz $u(x,t) = \\phi_n(x)\\cos(\\omega_n t)$ yields the eigenvalue problem\n$$\n\\phi_n^{(4)}(x) = \\kappa_n^4\\,\\phi_n(x),\\quad \\phi_n(0) = 0,\\ \\phi_n(L)=0,\\ \\phi_n''(0)=0,\\ \\phi_n''(L)=0,\n$$\nwhose exact eigenfunctions are $\\phi_n(x) = \\sin\\!\\left(\\frac{n\\pi x}{L}\\right)$ with exact wavenumbers $k_n = \\frac{n\\pi}{L}$ for integer modes $n\\ge 1$. The exact angular eigenfrequencies are\n$$\n\\omega_n^{\\mathrm{exact}} = c_b\\,k_n^2 = c_b\\,\\left(\\frac{n\\pi}{L}\\right)^2.\n$$\n\nDiscretize the spatial domain with $N$ interior points and uniform spacing $h = \\frac{L}{N+1}$, enforcing the Dirichlet boundary values $u(0,t)=u(L,t)=0$ at the endpoints. Consider two finite-difference discretizations for the second derivative operator $u_{xx}$ on the interior grid, both represented as symmetric Toeplitz matrices acting on the vector of interior values and implicitly using boundary values $u=0$ outside the interior stencil:\n\n- Second-order accurate three-point stencil with coefficients $\\frac{1}{h^2}\\{1,-2,1\\}$ at offsets $\\{-1,0,1\\}$.\n- Fourth-order accurate five-point stencil with coefficients $\\frac{1}{h^2}\\left\\{-\\frac{1}{12},\\frac{4}{3},-\\frac{5}{2},\\frac{4}{3},-\\frac{1}{12}\\right\\}$ at offsets $\\{-2,-1,0,1,2\\}$.\n\nLet $\\theta_n = \\frac{n\\pi}{N+1}$. For the discrete sine eigenvector $v^{(n)}_j = \\sin(j\\theta_n)$, $j=1,\\dots,N$, the corresponding discrete second-derivative eigenvalues for these Toeplitz stencils are\n$$\n\\lambda^{(2)}(\\theta) = \\frac{-2 + 2\\cos\\theta}{h^2} = -\\frac{4\\sin^2(\\theta/2)}{h^2},\n$$\nand\n$$\n\\lambda^{(4)}(\\theta) = \\frac{-\\frac{5}{2} + \\frac{8}{3}\\cos\\theta - \\frac{1}{6}\\cos(2\\theta)}{h^2}.\n$$\nThe discrete fourth-derivative eigenvalues are modeled by $\\mu(\\theta) = \\left(\\lambda(\\theta)\\right)^2$, and the corresponding semi-discrete angular frequencies satisfy\n$$\n\\omega_n^{\\mathrm{num}} = c_b\\,\\left|\\lambda(\\theta_n)\\right|.\n$$\n\nTo explore control of numerical dispersion and diffusion, augment the spatial operator with a scale-selective smoothing (filter) that reduces high-wavenumber content, represented in modal form by a multiplicative attenuation\n$$\n\\lambda_{\\sigma}(\\theta) = \\left(1 - \\sigma\\,\\varphi(\\theta)\\right)\\lambda(\\theta),\\quad \\varphi(\\theta) = \\sin^6\\!\\left(\\frac{\\theta}{2}\\right),\n$$\nwith filter strength $\\sigma\\in[0,1]$. This mimics spectral vanishing viscosity, primarily acting near the grid Nyquist wavenumber. The filtered discrete frequency is modeled as\n$$\n\\omega_{n,\\sigma}^{\\mathrm{num}} = c_b\\,\\left|\\lambda_{\\sigma}(\\theta_n)\\right|.\n$$\n\nFor each test configuration and mode index set $\\mathcal{M}$, define the relative error for mode $n\\in \\mathcal{M}$ as\n$$\n\\varepsilon_n = \\frac{\\left|\\omega_{n,\\sigma}^{\\mathrm{num}} - \\omega_n^{\\mathrm{exact}}\\right|}{\\omega_n^{\\mathrm{exact}}},\n$$\nand declare the configuration a pass if $\\max_{n\\in\\mathcal{M}} \\varepsilon_n \\le \\mathrm{tol}$.\n\nYour task is to write a complete program that:\n- Implements the second-order and fourth-order discrete second-derivative eigenvalues $\\lambda^{(2)}(\\theta)$ and $\\lambda^{(4)}(\\theta)$.\n- Computes the exact and numerical angular eigenfrequencies for specified modes $n$ using the formulas above, with optional filter strength $\\sigma$.\n- Evaluates pass/fail booleans for a given tolerance by comparing relative errors for all modes in a test set.\n\nPhysical units requirement: interpret $L$ in $\\mathrm{m}$, $c_b$ in $\\mathrm{m^2/s}$, and angular frequencies in $\\mathrm{rad/s}$. However, the program’s final outputs are booleans, which are dimensionless.\n\nTest Suite:\nProvide results for the following parameter sets, covering accuracy order effects, grid resolution impacts, and filter influences. For each case, the mode set is given by a list of positive integers; the maximum relative error over the list is compared to the tolerance.\n\n- Case $1$: $L=1.0$, $c_b=1.0$, $N=63$, scheme $=$ fourth-order, $\\sigma=0.0$, modes $\\mathcal{M}=[1,2,3,10]$, tolerance $\\mathrm{tol}=2\\times 10^{-3}$.\n- Case $2$: $L=1.0$, $c_b=1.0$, $N=31$, scheme $=$ second-order, $\\sigma=0.0$, modes $\\mathcal{M}=[1,2,3,10]$, tolerance $\\mathrm{tol}=1\\times 10^{-2}$.\n- Case $3$: $L=1.0$, $c_b=1.0$, $N=47$, scheme $=$ fourth-order, $\\sigma=0.0$, modes $\\mathcal{M}=[1,2,3,10]$, tolerance $\\mathrm{tol}=3\\times 10^{-3}$.\n- Case $4$: $L=1.0$, $c_b=1.0$, $N=31$, scheme $=$ second-order, $\\sigma=0.2$, modes $\\mathcal{M}=[10,12,14]$, tolerance $\\mathrm{tol}=7\\times 10^{-2}$.\n- Case $5$: $L=1.0$, $c_b=1.0$, $N=127$, scheme $=$ second-order, $\\sigma=0.0$, modes $\\mathcal{M}=[1,2,3]$, tolerance $\\mathrm{tol}=1\\times 10^{-3}$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered as above, for example [result_1,result_2,result_3,result_4,result_5], where each result_i is either True or False. The program must not read any input and must compute these results internally.", "solution": "The problem statement has been meticulously validated and is determined to be sound. It is scientifically grounded in the principles of solid mechanics and numerical analysis, specifically using the Euler–Bernoulli beam equation as a model for flexural waves and analyzing the properties of finite difference schemes. The problem is well-posed, providing all necessary equations, parameters, and a clear objective for each test case. The language is precise and unambiguous. Therefore, a complete solution is provided below.\n\nThe core of this problem lies in comparing the analytical dispersion relation of a continuous physical system with the numerical dispersion relation of its discrete approximation.\n\nThe physical system is a one-dimensional elastic beam whose transverse displacement $u(x,t)$ is governed by the Euler–Bernoulli equation:\n$$\n\\frac{\\partial^2 u}{\\partial t^2} + c_b^2 \\frac{\\partial^4 u}{\\partial x^4} = 0\n$$\nHere, $c_b$ is the flexural wave speed parameter. For simply supported boundary conditions on a domain $x \\in [0, L]$, the solution can be expressed as a superposition of normal modes. The ansatz $u(x,t) = \\phi_n(x) \\cos(\\omega_n t)$ separates the problem into a spatial eigenvalue problem for the mode shapes $\\phi_n(x)$ and their corresponding angular eigenfrequencies $\\omega_n$. The exact mode shapes are given as $\\phi_n(x) = \\sin(k_n x)$ with wavenumbers $k_n = n\\pi/L$ for integer modes $n \\ge 1$. Substituting this into the governing equation yields the exact dispersion relation:\n$$\n\\omega_n^{\\mathrm{exact}} = c_b k_n^2 = c_b \\left(\\frac{n\\pi}{L}\\right)^2\n$$\nThis relation is dispersive, meaning the phase velocity $v_p = \\omega_n/k_n = c_b k_n$ depends on the wavenumber, so waves of different lengths travel at different speeds.\n\nWhen the spatial domain is discretized with $N$ interior points and spacing $h = L/(N+1)$, the continuous derivatives are replaced by finite difference operators. For the simply supported boundary conditions specified, the eigenvectors of the resulting discrete operators are discrete sine functions, $v_j^{(n)} = \\sin(j \\theta_n)$, where $j=1,\\dots,N$ is the grid point index and $\\theta_n = n\\pi/(N+1) = k_n h$ is the dimensionless wavenumber.\n\nThe key step in this analysis is that applying a finite difference operator to a discrete sine eigenvector is equivalent to multiplying the eigenvector by a scalar eigenvalue. This scalar, denoted $\\lambda(\\theta_n)$ for the second-derivative operator, is a function of the dimensionless wavenumber $\\theta_n$. The continuous second derivative operator $\\frac{\\partial^2}{\\partial x^2}$ has eigenvalues $-k_n^2$. The accuracy of a finite difference scheme is determined by how well its eigenvalue $\\lambda(\\theta_n)$ approximates $-k_n^2 = -(\\theta_n/h)^2$.\n\nThe problem specifies two schemes for the second derivative:\n1.  A second-order accurate scheme with eigenvalue $\\lambda^{(2)}(\\theta) = \\frac{-2 + 2\\cos\\theta}{h^2}$.\n2.  A fourth-order accurate scheme with eigenvalue $\\lambda^{(4)}(\\theta) = \\frac{1}{h^2}\\left(-\\frac{5}{2} + \\frac{8}{3}\\cos\\theta - \\frac{1}{6}\\cos(2\\theta)\\right)$.\n\nThe problem models the fourth-derivative operator as the square of the second-derivative operator. Consequently, the semi-discrete governing equation leads to a numerical dispersion relation by replacing the analytical $k_n^2$ with its numerical counterpart, which is effectively $-\\lambda(\\theta_n)$. Thus, the numerical frequency is computed as:\n$$\n\\omega_n^{\\mathrm{num}} = c_b \\left|-\\lambda(\\theta_n)\\right| = c_b \\left|\\lambda(\\theta_n)\\right|\n$$\nThe absolute value is used because the provided eigenvalues $\\lambda(\\theta_n)$ are non-positive. The deviation of $\\omega_n^{\\mathrm{num}}$ from $\\omega_n^{\\mathrm{exact}}$ is known as numerical dispersion.\n\nTo control high-frequency numerical artifacts, a spectral filter is introduced. This filter modifies the operator's eigenvalue via multiplication:\n$$\n\\lambda_{\\sigma}(\\theta) = \\left(1 - \\sigma\\,\\varphi(\\theta)\\right)\\lambda(\\theta)\n$$\nwhere $\\sigma$ is the filter strength and $\\varphi(\\theta) = \\sin^6(\\theta/2)$ is a function that selectively targets high wavenumbers (i.e., $\\theta$ approaching $\\pi$). This added term introduces numerical diffusion, which damps high-frequency components. The filtered numerical frequency is then:\n$$\n\\omega_{n,\\sigma}^{\\mathrm{num}} = c_b \\left|\\lambda_{\\sigma}(\\theta_n)\\right|\n$$\nThe procedure is to evaluate, for each test configuration, the maximum relative error over a specified set of modes $\\mathcal{M}$:\n$$\n\\varepsilon_{\\mathrm{max}} = \\max_{n\\in\\mathcal{M}} \\left( \\frac{\\left|\\omega_{n,\\sigma}^{\\mathrm{num}} - \\omega_n^{\\mathrm{exact}}\\right|}{\\omega_n^{\\mathrm{exact}}} \\right)\n$$\nThe configuration is declared a \"pass\" ($\\mathrm{True}$) if this maximum error does not exceed a given tolerance $\\mathrm{tol}$, and a \"fail\" ($\\mathrm{False}$) otherwise. The implementation will systematically apply these formulas to each test case.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the computational benchmark problem for dispersive normal modes.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"L\": 1.0, \"cb\": 1.0, \"N\": 63, \"scheme\": \"fourth-order\", \"sigma\": 0.0,\n            \"modes\": [1, 2, 3, 10], \"tol\": 2e-3, \"case_id\": 1\n        },\n        {\n            \"L\": 1.0, \"cb\": 1.0, \"N\": 31, \"scheme\": \"second-order\", \"sigma\": 0.0,\n            \"modes\": [1, 2, 3, 10], \"tol\": 1e-2, \"case_id\": 2\n        },\n        {\n            \"L\": 1.0, \"cb\": 1.0, \"N\": 47, \"scheme\": \"fourth-order\", \"sigma\": 0.0,\n            \"modes\": [1, 2, 3, 10], \"tol\": 3e-3, \"case_id\": 3\n        },\n        {\n            \"L\": 1.0, \"cb\": 1.0, \"N\": 31, \"scheme\": \"second-order\", \"sigma\": 0.2,\n            \"modes\": [10, 12, 14], \"tol\": 7e-2, \"case_id\": 4\n        },\n        {\n            \"L\": 1.0, \"cb\": 1.0, \"N\": 127, \"scheme\": \"second-order\", \"sigma\": 0.0,\n            \"modes\": [1, 2, 3], \"tol\": 1e-3, \"case_id\": 5\n        },\n    ]\n\n    results = []\n\n    for case in test_cases:\n        L = case[\"L\"]\n        cb = case[\"cb\"]\n        N = case[\"N\"]\n        scheme = case[\"scheme\"]\n        sigma = case[\"sigma\"]\n        modes = case[\"modes\"]\n        tol = case[\"tol\"]\n\n        h = L / (N + 1)\n        \n        max_relative_error = 0.0\n\n        for n in modes:\n            # Calculate the exact angular eigenfrequency\n            kn = n * np.pi / L\n            omega_exact = cb * kn**2\n\n            # Calculate the dimensionless wavenumber\n            theta_n = n * np.pi / (N + 1)\n\n            # Calculate the unfiltered discrete second-derivative eigenvalue\n            if scheme == \"second-order\":\n                lambda_theta = (-2.0 + 2.0 * np.cos(theta_n)) / h**2\n            elif scheme == \"fourth-order\":\n                lambda_theta = (\n                    -2.5 + (8.0/3.0) * np.cos(theta_n) - (1.0/6.0) * np.cos(2.0 * theta_n)\n                ) / h**2\n            else:\n                raise ValueError(f\"Unknown scheme: {scheme}\")\n\n            # Apply the filter if sigma is non-zero\n            if sigma  0:\n                phi_theta = np.sin(theta_n / 2.0)**6\n                lambda_sigma_theta = (1.0 - sigma * phi_theta) * lambda_theta\n            else:\n                lambda_sigma_theta = lambda_theta\n            \n            # Calculate the numerical angular eigenfrequency\n            omega_num = cb * np.abs(lambda_sigma_theta)\n\n            # Calculate the relative error for the current mode\n            relative_error = np.abs(omega_num - omega_exact) / omega_exact\n            \n            if relative_error  max_relative_error:\n                max_relative_error = relative_error\n\n        # Check if the configuration passes the tolerance test\n        pass_fail = max_relative_error = tol\n        results.append(pass_fail)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3581957"}]}