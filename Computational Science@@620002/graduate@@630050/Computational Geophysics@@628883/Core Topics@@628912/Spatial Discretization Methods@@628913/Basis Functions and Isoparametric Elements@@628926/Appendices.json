{"hands_on_practices": [{"introduction": "A cornerstone of the finite element method is the evaluation of integrals over each element's domain to form system matrices, such as the mass or stiffness matrix. Since these integrals are rarely solvable in closed form for general cases, numerical quadrature is essential. This first exercise provides a fundamental check on your understanding of this process by asking you to determine the minimum quadrature order needed to *exactly* integrate the mass matrix for a bilinear ($Q_1$) element under idealized conditions ([@problem_id:3577235]). Mastering this connection between basis function polynomial degree and quadrature accuracy is the first step toward building robust and reliable computational models.", "problem": "In a finite element analysis for computational geophysics, consider a quadrilateral isoparametric element with bilinear ($Q_1$) basis functions defined on the reference square $[-1,1] \\times [-1,1]$. The consistent mass matrix entries on a single element are given by\n$$\nM_{ij} = \\int_{\\Omega_e} \\rho \\, N_i(\\boldsymbol{x}) \\, N_j(\\boldsymbol{x}) \\, \\mathrm{d}\\Omega,\n$$\nwhere $\\rho$ is the element density, $\\Omega_e$ is the physical element, and $N_i$ are the $Q_1$ shape functions. The element uses an isoparametric mapping from the reference coordinates $(\\xi,\\eta) \\in [-1,1]^2$ to the physical coordinates $\\boldsymbol{x}(\\xi,\\eta)$ such that the Jacobian determinant $|J|$ is constant on the element (that is, the isoparametric mapping is affine). Assume $\\rho$ is constant within the element.\n\nThe element integrals are evaluated using tensor-product Gauss–Legendre (Gauss–Legendre (GL)) quadrature of order $n$ in each parametric direction on $[-1,1]^2$. Determine the minimum order $n$ in each direction required to integrate the consistent mass matrix entries $M_{ij}$ exactly for all node pairs $(i,j)$ of the $Q_1$ element under the given assumptions. Provide your answer as a single integer. No rounding is required, and no units are needed.", "solution": "The problem requires determining the minimum order $n$ of tensor-product Gauss–Legendre (GL) quadrature required for the exact integration of the consistent mass matrix entries $M_{ij}$ for a quadrilateral isoparametric element using bilinear ($Q_1$) basis functions.\n\nThe expression for the consistent mass matrix entry is given as:\n$$\nM_{ij} = \\int_{\\Omega_e} \\rho \\, N_i(\\boldsymbol{x}) \\, N_j(\\boldsymbol{x}) \\, \\mathrm{d}\\Omega\n$$\nwhere $\\rho$ is the density, $\\Omega_e$ is the physical element domain, and $N_i(\\boldsymbol{x})$ are the shape functions in physical coordinates.\n\nThe problem states that an isoparametric mapping is used. This means the same basis functions used to interpolate the field variable are used to map the geometry from the reference element to the physical element. The integral is transformed from the physical domain $\\Omega_e$ to the reference domain, which is the square $[-1,1] \\times [-1,1]$ in $(\\xi, \\eta)$ coordinates. The transformation involves the determinant of the Jacobian matrix, $|J|$, of the mapping $\\boldsymbol{x}(\\xi, \\eta)$:\n$$\n\\mathrm{d}\\Omega = |J| \\, \\mathrm{d}\\xi \\, \\mathrm{d}\\eta\n$$\nFor an isoparametric element, the shape functions are naturally defined in the reference coordinates, so $N_i(\\boldsymbol{x}) = N_i(\\xi, \\eta)$. Substituting these into the mass matrix formula gives:\n$$\nM_{ij} = \\int_{-1}^{1} \\int_{-1}^{1} \\rho \\, N_i(\\xi, \\eta) \\, N_j(\\xi, \\eta) \\, |J| \\, \\mathrm{d}\\xi \\, \\mathrm{d}\\eta\n$$\nThe problem specifies two crucial simplifications:\n$1$. The density $\\rho$ is constant within the element.\n$2$. The Jacobian determinant $|J|$ is constant on the element. This implies the geometric mapping is affine, which is the case for rectangular or parallelogram-shaped physical elements.\n\nSince $\\rho$ and $|J|$ are constants, they can be factored out of the integral:\n$$\nM_{ij} = \\rho |J| \\int_{-1}^{1} \\int_{-1}^{1} N_i(\\xi, \\eta) \\, N_j(\\xi, \\eta) \\, \\mathrm{d}\\xi \\, \\mathrm{d}\\eta\n$$\nTo determine the required quadrature order, we must analyze the polynomial degree of the integrand, $I(\\xi, \\eta) = N_i(\\xi, \\eta) N_j(\\xi, \\eta)$.\n\nThe basis functions for a $4$-node bilinear quadrilateral element ($Q_1$) are given by:\n$$\nN_k(\\xi, \\eta) = \\frac{1}{4}(1 + \\xi_k \\xi)(1 + \\eta_k \\eta) \\quad \\text{for } k=1,2,3,4\n$$\nwhere $(\\xi_k, \\eta_k)$ are the coordinates of the nodes in the reference square: $(-1,-1)$, $(1,-1)$, $(1,1)$, and $(-1,1)$. Each basis function $N_k$ is a polynomial of degree $1$ in $\\xi$ and degree $1$ in $\\eta$. The general form is $N_k(\\xi, \\eta) = a_0 + a_1\\xi + a_2\\eta + a_3\\xi\\eta$.\n\nThe integrand is the product of two such functions, $N_i(\\xi, \\eta)$ and $N_j(\\xi, \\eta)$. The product of two polynomials that are linear in $\\xi$ results in a polynomial that is quadratic in $\\xi$. Similarly, the product of two polynomials that are linear in $\\eta$ results in a polynomial that is quadratic in $\\eta$.\nLet's verify this for a generic product:\n$$\nN_i(\\xi, \\eta) N_j(\\xi, \\eta) = \\left[\\frac{1}{4}(1 + \\xi_i \\xi)(1 + \\eta_i \\eta)\\right] \\left[\\frac{1}{4}(1 + \\xi_j \\xi)(1 + \\eta_j \\eta)\\right]\n$$\n$$\n= \\frac{1}{16} [(1 + \\xi_i \\xi)(1 + \\xi_j \\xi)] [(1 + \\eta_i \\eta)(1 + \\eta_j \\eta)]\n$$\nThe term involving $\\xi$ is $(1 + \\xi_i \\xi)(1 + \\xi_j \\xi) = 1 + (\\xi_i + \\xi_j)\\xi + (\\xi_i \\xi_j)\\xi^2$. Since $\\xi_k = \\pm 1$, the coefficient $\\xi_i \\xi_j$ is either $1$ or $-1$. Thus, the highest power of $\\xi$ in the integrand is $\\xi^2$.\nThe term involving $\\eta$ is $(1 + \\eta_i \\eta)(1 + \\eta_j \\eta) = 1 + (\\eta_i + \\eta_j)\\eta + (\\eta_i \\eta_j)\\eta^2$. Similarly, the highest power of $\\eta$ in the integrand is $\\eta^2$.\n\nTherefore, the integrand, $N_i(\\xi, \\eta) N_j(\\xi, \\eta)$, is a polynomial of maximum degree $2$ in $\\xi$ and maximum degree $2$ in $\\eta$, for any pair of nodes $(i,j)$.\n\nThe problem states that a tensor-product Gauss–Legendre quadrature of order $n$ in each direction is used. This means an $n$-point GL rule is applied for integration with respect to $\\xi$, and an $n$-point GL rule is applied for integration with respect to $\\eta$.\nA one-dimensional Gauss–Legendre quadrature with $n$ points (of order $n$) can integrate any polynomial of degree up to $2n-1$ exactly.\n\nFor the double integral to be exact, the quadrature rule must be exact for each dimension independently.\nTo exactly integrate the polynomial in the $\\xi$ direction, which has a maximum degree of $p_\\xi = 2$, the order $n$ must satisfy:\n$$\n2n - 1 \\ge p_\\xi\n$$\n$$\n2n - 1 \\ge 2\n$$\n$$\n2n \\ge 3\n$$\n$$\nn \\ge 1.5\n$$\nSince $n$ must be an integer representing the number of quadrature points, the minimum integer value for $n$ is $2$.\n\nThe same logic applies to the $\\eta$ direction, as the maximum polynomial degree $p_\\eta$ is also $2$. This also yields $n \\ge 1.5$, so the minimum integer $n$ is $2$.\nTherefore, a minimum order of $n=2$ in each direction is required. This corresponds to a $2 \\times 2$ Gauss quadrature rule on the reference element, which will integrate the mass matrix exactly under the given assumptions of constant $\\rho$ and constant $|J|$.", "answer": "$$\\boxed{2}$$", "id": "3577235"}, {"introduction": "As we move to higher-order elements to capture more complex physical behavior, the choice of basis functions becomes critical. This exercise challenges you to construct the popular 8-node \"serendipity\" quadratic element and analyze its underlying polynomial structure ([@problem_id:3577185]). You will discover that, despite its efficiency, this element omits a key term from the full biquadratic polynomial space. Understanding the practical implications of this omission, particularly for bending-dominated problems common in geophysics like lithospheric flexure, is crucial for making informed decisions about element selection in your own research.", "problem": "Consider the reference quadrilateral element in the parametric plane with coordinates $(\\xi,\\eta) \\in [-1,1] \\times [-1,1]$. Let the isoparametric mapping be defined by the same shape functions used for interpolation of the field variable, and let the interpolation be nodal with $8$ nodes: the four corners at $(\\xi,\\eta) = (\\pm 1,\\pm 1)$ and the four mid-edge points at $(\\xi,\\eta) = (0,\\pm 1)$ and $(\\xi,\\eta) = (\\pm 1,0)$. The $8$-node serendipity quadrilateral employs Lagrange-type basis functions $\\{N_i(\\xi,\\eta)\\}_{i=1}^{8}$ that satisfy the Kronecker-delta property at these nodes and are quadratic along each edge.\n\nStarting from the definitions of isoparametric interpolation and nodal Lagrange completeness, construct the $8$-node serendipity basis functions $\\{N_i(\\xi,\\eta)\\}_{i=1}^{8}$ by enforcing the nodal interpolation conditions and polynomial edge completeness. Use the requirement that, when restricted to any element edge, the interpolation space reproduces all univariate polynomials of degree up to $2$ in the edge parameter. Then, by analyzing the polynomial reproduction properties of the resulting basis and the structure of the biquadratic space $Q_2 = \\operatorname{span}\\{\\xi^i \\eta^j : 0 \\le i \\le 2,\\ 0 \\le j \\le 2\\}$, determine the unique monomial in $Q_2$ that is not contained in the span of the $8$-node serendipity basis functions. Finally, discuss the implications of this omission for bending-dominated problems in computational geophysics, where plate- or shell-like behavior leads to accuracy requirements governed by curvature fields and the associated energy norms.\n\nYour final answer must be the single omitted monomial written as a closed-form analytic expression in $(\\xi,\\eta)$. No numerical rounding is required.", "solution": "The problem is first validated to ensure it is scientifically sound, well-posed, and objective.\n\n### Step 1: Extract Givens\n- **Domain**: A reference quadrilateral element in the parametric plane with coordinates $(\\xi, \\eta) \\in [-1, 1] \\times [-1, 1]$.\n- **Element**: An $8$-node serendipity quadrilateral.\n- **Nodes**: $8$ nodes located at the four corners $(\\pm 1, \\pm 1)$ and four mid-edge points $(0, \\pm 1)$ and $(\\pm 1, 0)$.\n- **Basis Functions**: A set of Lagrange-type basis functions $\\{N_i(\\xi, \\eta)\\}_{i=1}^{8}$ satisfying the Kronecker-delta property, $N_i(\\xi_j, \\eta_j) = \\delta_{ij}$, where $(\\xi_j, \\eta_j)$ are the coordinates of the $j$-th node.\n- **Interpolation properties**: The basis functions are quadratic along each edge, meaning their restriction to an edge spans the space of univariate quadratic polynomials.\n- **Task**:\n    1. Construct the basis functions $\\{N_i(\\xi, \\eta)\\}_{i=1}^{8}$.\n    2. Analyze the polynomial reproduction properties of the basis.\n    3. Identify the unique monomial in the biquadratic space $Q_2 = \\operatorname{span}\\{\\xi^i \\eta^j : 0 \\le i \\le 2, 0 \\le j \\le 2\\}$ that is not in the span of $\\{N_i\\}$.\n    4. Discuss the implications of this omission for bending-dominated problems in computational geophysics.\n\n### Step 2: Validate Using Extracted Givens\nThe problem statement is a standard exercise in the theory of the Finite Element Method (FEM). All concepts—isoparametric mapping, reference elements, serendipity basis functions, polynomial completeness, and the biquadratic polynomial space $Q_2$—are well-defined and fundamental to computational mechanics and its application in fields like computational geophysics. The problem is self-contained, with all necessary information provided for the construction and analysis. There are no scientific inaccuracies, contradictions, or ambiguities. The link to computational geophysics is appropriate, as plate and shell bending analysis is a common application in that field.\n\n### Step 3: Verdict and Action\nThe problem is deemed **valid**. A complete solution will be provided.\n\n### Solution Construction\n\nThe solution proceeds in three stages as required by the problem: (1) construction of the basis functions, (2) analysis of the polynomial space they span to find the omitted monomial, and (3) discussion of the implications.\n\n**1. Construction of the 8-Node Serendipity Basis Functions**\n\nThe basis functions $\\{N_i(\\xi, \\eta)\\}_{i=1}^{8}$ must satisfy the Lagrange property $N_i(\\xi_j, \\eta_j) = \\delta_{ij}$. The standard construction for serendipity elements combines products of linear and quadratic polynomials to achieve this property. We will group the nodes into corner nodes and mid-edge nodes.\n\nLet the node numbering be as follows:\n- Corner nodes: $1: (-1, -1)$, $2: (1, -1)$, $3: (1, 1)$, $4: (-1, 1)$.\n- Mid-edge nodes: $5: (0, -1)$, $6: (1, 0)$, $7: (0, 1)$, $8: (-1, 0)$.\n\n**For a corner node $i$ at $(\\xi_i, \\eta_i)$ where $\\xi_i, \\eta_i \\in \\{-1, 1\\}$:**\nThe basis function is constructed as a product of three terms. The first two, $\\frac{1}{4}(1 + \\xi_i\\xi)(1 + \\eta_i\\eta)$, form the bilinear basis function for a $4$-node quadrilateral. This term is $1$ at node $i$ and $0$ at all other corner nodes. A linear correction term is added to make the function zero at the adjacent mid-edge nodes. The general form is:\n$$N_i(\\xi, \\eta) = \\frac{1}{4}(1 + \\xi_i\\xi)(1 + \\eta_i\\eta)(\\xi_i\\xi + \\eta_i\\eta - 1)$$\nFor example, for node $1$ at $(\\xi_1, \\eta_1) = (-1, -1)$:\n$$N_1(\\xi, \\eta) = \\frac{1}{4}(1 - \\xi)(1 - \\eta)(-\\xi - \\eta - 1)$$\n\n**For a mid-edge node $i$ at $(\\xi_i, \\eta_i)$:**\nThese functions are constructed using a quadratic term in one direction and a linear term in the other.\n- If the node is on a horizontal edge, $\\eta_i = \\pm 1$ and $\\xi_i = 0$. The function must be zero on the opposite edge (at $\\eta = -\\eta_i$) and at the other nodes on the same edge. This is achieved with the form:\n$$N_i(\\xi, \\eta) = \\frac{1}{2}(1 - \\xi^2)(1 + \\eta_i\\eta)$$\nFor example, for node $5$ at $(\\xi_5, \\eta_5) = (0, -1)$:\n$$N_5(\\xi, \\eta) = \\frac{1}{2}(1 - \\xi^2)(1 - \\eta)$$\n- If the node is on a vertical edge, $\\xi_i = \\pm 1$ and $\\eta_i = 0$. Similarly, the form is:\n$$N_i(\\xi, \\eta) = \\frac{1}{2}(1 - \\eta^2)(1 + \\xi_i\\xi)$$\nFor example, for node $6$ at $(\\xi_6, \\eta_6) = (1, 0)$:\n$$N_6(\\xi, \\eta) = \\frac{1}{2}(1 - \\eta^2)(1 + \\xi)$$\n\nThese functions satisfy the Kronecker-delta property at all $8$ nodes and are quadratic along each edge, fulfilling the problem's requirements. For instance, on the edge $\\eta = -1$, the non-zero basis functions are $N_1(\\xi, -1) = \\frac{1}{2}\\xi(\\xi-1)$, $N_2(\\xi, -1) = \\frac{1}{2}\\xi(1+\\xi)$, and $N_5(\\xi, -1) = 1-\\xi^2$. These are the three standard 1D quadratic Lagrange basis functions for nodes at $\\xi = -1, 1, 0$, and they span the space of quadratic polynomials in $\\xi$.\n\n**2. Analysis of the Polynomial Space and Identification of the Omitted Monomial**\n\nThe space spanned by the basis functions, $S_2 = \\operatorname{span}\\{N_i(\\xi, \\eta)\\}_{i=1}^{8}$, is an $8$-dimensional subspace of the full biquadratic space $Q_2 = \\operatorname{span}\\{\\xi^i \\eta^j : 0 \\le i, j \\le 2\\}$. The space $Q_2$ has dimension $3 \\times 3 = 9$. We must identify which monomial from the basis of $Q_2$, which is $\\{1, \\xi, \\eta, \\xi^2, \\xi\\eta, \\eta^2, \\xi^2\\eta, \\xi\\eta^2, \\xi^2\\eta^2\\}$, is not included in $S_2$.\n\nWe can test if a given polynomial function $f(\\xi, \\eta)$ lies in $S_2$ by using the interpolation property. If $f \\in S_2$, then it must be exactly represented by its nodal interpolant:\n$$f(\\xi, \\eta) = \\sum_{i=1}^{8} f(\\xi_i, \\eta_i) N_i(\\xi, \\eta)$$\nLet's test the monomials that form the basis of $Q_2$:\n- $f=1$: $\\sum N_i = 1$ (Partition of unity). This holds for these basis functions.\n- $f=\\xi$: $\\xi = \\sum \\xi_i N_i = -N_1+N_2+N_3-N_4+N_6-N_8$. So $\\xi \\in S_2$.\n- $f=\\eta$: $\\eta = \\sum \\eta_i N_i = -N_1-N_2+N_3+N_4-N_5+N_7$. So $\\eta \\in S_2$.\n- $f=\\xi\\eta$: $\\xi\\eta = \\sum \\xi_i\\eta_i N_i = N_1-N_2+N_3-N_4$. So $\\xi\\eta \\in S_2$.\n- $f=\\xi^2$: $\\xi^2 = \\sum \\xi_i^2 N_i = N_1+N_2+N_3+N_4+N_6+N_8$. So $\\xi^2 \\in S_2$.\n- $f=\\eta^2$: $\\eta^2 = \\sum \\eta_i^2 N_i = N_1+N_2+N_3+N_4+N_5+N_7$. So $\\eta^2 \\in S_2$.\n- $f=\\xi^2\\eta$: $\\xi^2\\eta = \\sum \\xi_i^2\\eta_i N_i = -N_1-N_2+N_3+N_4$. So $\\xi^2\\eta \\in S_2$.\n- $f=\\xi\\eta^2$: $\\xi\\eta^2 = \\sum \\xi_i\\eta_i^2 N_i = -N_1+N_2+N_3-N_4$. So $\\xi\\eta^2 \\in S_2$.\n\nThe span of the serendipity basis functions contains the $8$ monomials $\\{1, \\xi, \\eta, \\xi^2, \\xi\\eta, \\eta^2, \\xi^2\\eta, \\xi\\eta^2\\}$.\nNow consider the final monomial from the basis of $Q_2$, which is $f = \\xi^2\\eta^2$. Let's attempt to represent it.\n$$f(\\xi_i, \\eta_i) = \\xi_i^2\\eta_i^2$$\nFor all corner nodes $(\\pm 1, \\pm 1)$, $f(\\xi_i, \\eta_i) = (\\pm 1)^2(\\pm 1)^2 = 1$.\nFor all mid-edge nodes, at least one of $\\xi_i$ or $\\eta_i$ is $0$, so $f(\\xi_i, \\eta_i) = 0$.\nThe nodal interpolant would be:\n$$f_{interp}(\\xi, \\eta) = \\sum_{i=1}^4 N_i(\\xi, \\eta)$$\nLet's sum the four corner node basis functions:\n$N_1+N_2+N_3+N_4 = \\frac{1}{4} \\sum_{i=1}^4 (1 + \\xi_i\\xi)(1 + \\eta_i\\eta)(\\xi_i\\xi + \\eta_i\\eta - 1)$\nA more direct way is to inspect the polynomial terms in the basis functions themselves.\nFor corner nodes: $N_i \\propto (1 + \\xi_i\\xi)(1 + \\eta_i\\eta)(\\xi_i\\xi + \\eta_i\\eta - 1)$. The highest order terms are of the form $\\xi^2\\eta$ and $\\xi\\eta^2$.\nFor mid-edge nodes: $N_i$ can be of the form $(1-\\xi^2)(1+\\eta_i\\eta)$ or $(1-\\eta^2)(1+\\xi_i\\xi)$. The highest order terms are $\\xi^2\\eta$ and $\\xi\\eta^2$.\nNone of the $8$ basis functions $N_i(\\xi, \\eta)$ contain the term $\\xi^2\\eta^2$. Therefore, no linear combination of these basis functions can produce the monomial $\\xi^2\\eta^2$.\n\nThe unique monomial in $Q_2$ that is not contained in the span of the $8$-node serendipity basis functions is $\\xi^2\\eta^2$.\n\n**3. Implications for Bending-Dominated Problems in Computational Geophysics**\n\nBending-dominated problems, such as the flexure of tectonic plates (lithosphere) or ice shelves under loading, are frequently modeled using plate and shell theories. The accuracy of finite element solutions for these problems is critically dependent on the element's ability to represent the bending energy, which is a function of the curvatures (second derivatives) of the displacement field.\n\nThe polynomial completeness of an element dictates its convergence properties. The $8$-node serendipity element is complete up to degree $2$ (it contains the full space $P_2$), guaranteeing a certain order of convergence. However, it is not complete for the biquadratic space $Q_2$, as it lacks the $\\xi^2\\eta^2$ term. This omission has significant consequences.\n\nThe $\\xi^2\\eta^2$ mode corresponds to a non-uniform twisting or warping deformation. Its second derivatives are:\n$$\\frac{\\partial^2}{\\partial \\xi^2}(\\xi^2\\eta^2) = 2\\eta^2$$\n$$\\frac{\\partial^2}{\\partial \\eta^2}(\\xi^2\\eta^2) = 2\\xi^2$$\n$$\\frac{\\partial^2}{\\partial \\xi \\partial \\eta}(\\xi^2\\eta^2) = 4\\xi\\eta$$\nThe inability of the serendipity element to represent this term means it cannot model states of deformation that involve quadratically varying normal curvatures or linearly varying twisting curvature, even on the undistorted reference element.\n\nIn the context of thin plate and shell analysis (e.g., using Mindlin-Reissner theory), this deficiency often leads to a numerical pathology known as **shear locking**. As the plate becomes thin, the transverse shear strains must approach zero. However, an element that cannot accurately represent the required bending modes (like pure twisting) may generate spurious, non-zero shear strains to compensate. This artificially stiffens the element's response, leading to a significant underestimation of displacements and inaccurate stress predictions. This is particularly problematic in geophysical models where predicting the magnitude of flexural subsidence or the state of stress in the lithosphere is paramount for understanding geological processes.\n\nFor example, a state of constant twist, which is a fundamental bending mode, requires the displacement field to contain terms that produce a constant $\\frac{\\partial^2 w}{\\partial x \\partial y}$. The serendipity element can only represent a constant state of twist if the element sides are parallel to the coordinate axes (where the Jacobian of the mapping is constant). For a generally distorted element, the element struggles to represent even this basic mode, leading to locking.\n\nIn contrast, the $9$-node Lagrange element, whose basis spans the full $Q_2$ space (including $\\xi^2\\eta^2$), can represent this mode correctly and generally performs much better for bending problems, exhibiting less susceptibility to shear locking. Consequently, for high-fidelity analysis of plate-like structures in geophysics where bending and twisting are important, the $9$-node element is often preferred, or specialized \"locking-free\" formulations must be employed for the $8$-node element. The choice impacts the reliability of predictions for phenomena like lithospheric flexure under volcanic loads or the response of ice shelves to ocean forcing.", "answer": "$$\\boxed{\\xi^2\\eta^2}$$", "id": "3577185"}, {"introduction": "Theory and analytical exercises provide the foundation, but computational experiments are where we truly probe the limits of our numerical methods. In practice, finite element meshes are rarely composed of perfect cubes; they are often distorted to fit complex geological structures. This final, hands-on coding practice challenges you to numerically investigate the impact of geometric distortion on integration accuracy for high-order elements ([@problem_id:3577183]). By correlating integration error with a measure of Jacobian variation, you will gain a practical, quantitative understanding of a primary source of error in advanced geophysical simulations.", "problem": "Let the reference hexahedron be the cube $[-1,1]^3$ in the parametric coordinates $(\\xi,\\eta,\\zeta)$. Consider an isoparametric tri-quadratic mapping that warps this reference cube into a physical hexahedron according to\n$$\nx(\\xi,\\eta,\\zeta) = \\xi + \\frac{\\alpha}{2}\\,\\xi\\,\\eta,\\quad\ny(\\xi,\\eta,\\zeta) = \\eta + \\frac{\\alpha}{2}\\,\\eta\\,\\zeta,\\quad\nz(\\xi,\\eta,\\zeta) = \\zeta + \\frac{\\alpha}{2}\\,\\xi\\,\\zeta,\n$$\nwhere $\\alpha \\ge 0$ is a scalar warp amplitude that controls the departure from an affine map. The Jacobian matrix of this mapping is\n$$\nJ(\\xi,\\eta,\\zeta) = \\begin{bmatrix}\n\\frac{\\partial x}{\\partial \\xi} & \\frac{\\partial x}{\\partial \\eta} & \\frac{\\partial x}{\\partial \\zeta} \\\\\n\\frac{\\partial y}{\\partial \\xi} & \\frac{\\partial y}{\\partial \\eta} & \\frac{\\partial y}{\\partial \\zeta} \\\\\n\\frac{\\partial z}{\\partial \\xi} & \\frac{\\partial z}{\\partial \\eta} & \\frac{\\partial z}{\\partial \\zeta}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n1 + \\frac{\\alpha}{2}\\eta & \\frac{\\alpha}{2}\\xi & 0 \\\\\n0 & 1 + \\frac{\\alpha}{2}\\zeta & \\frac{\\alpha}{2}\\eta \\\\\n\\frac{\\alpha}{2}\\zeta & 0 & 1 + \\frac{\\alpha}{2}\\xi\n\\end{bmatrix},\n$$\nand its determinant is\n$$\n\\det J(\\xi,\\eta,\\zeta) = \\left(1+\\frac{\\alpha}{2}\\eta\\right)\\left(1+\\frac{\\alpha}{2}\\zeta\\right)\\left(1+\\frac{\\alpha}{2}\\xi\\right) + \\left(\\frac{\\alpha}{2}\\xi\\right)\\left(\\frac{\\alpha}{2}\\eta\\right)\\left(\\frac{\\alpha}{2}\\zeta\\right).\n$$\nLet the test integrand be the smooth function\n$$\ng(x,y,z) = \\exp\\!\\left(0.3\\,x + 0.2\\,y - 0.1\\,z\\right) + \\sin\\!\\left(2.1\\,x\\right)\\,\\cos\\!\\left(1.7\\,y\\right)\\,\\sinh\\!\\left(0.5\\,z\\right).\n$$\nThe physical-volume integral of interest is defined by the change-of-variables formula\n$$\nI(\\alpha) = \\iiint_{[-1,1]^3} g\\!\\left(x(\\xi,\\eta,\\zeta),\\,y(\\xi,\\eta,\\zeta),\\,z(\\xi,\\eta,\\zeta)\\right)\\,\\left|\\det J(\\xi,\\eta,\\zeta)\\right|\\,d\\xi\\,d\\eta\\,d\\zeta.\n$$\nYou will approximate $I(\\alpha)$ using a tensor-product Gauss–Lobatto–Legendre (GLL) quadrature with $N$ nodes per coordinate. In one dimension, for a given $N \\ge 3$, the GLL nodes $\\{ \\xi_i \\}_{i=1}^N$ consist of the endpoints $\\xi_1=-1$, $\\xi_N=1$ and the $N-2$ interior roots of the derivative of the Legendre polynomial $P_{N-1}(\\xi)$, with corresponding weights $\\{ w_i \\}_{i=1}^N$ given by\n$$\nw_i = \\frac{2}{N(N-1)\\,[P_{N-1}(\\xi_i)]^2}.\n$$\nThe three-dimensional GLL approximation is the tensor product of the one-dimensional rule:\n$$\nI_{GLL}(N,\\alpha) = \\sum_{i=1}^N \\sum_{j=1}^N \\sum_{k=1}^N w_i\\,w_j\\,w_k \\; g\\!\\left(x(\\xi_i,\\eta_j,\\zeta_k),\\, y(\\xi_i,\\eta_j,\\zeta_k),\\, z(\\xi_i,\\eta_j,\\zeta_k)\\right)\\,\\left|\\det J(\\xi_i,\\eta_j,\\zeta_k)\\right|.\n$$\nTo assess accuracy, a high-fidelity reference $I_{\\text{ref}}(\\alpha)$ is obtained using a tensor-product Gauss–Legendre (GL) quadrature with $M=30$ nodes per coordinate:\n$$\nI_{\\text{ref}}(\\alpha) \\approx \\sum_{p=1}^{M} \\sum_{q=1}^{M} \\sum_{r=1}^{M} \\omega_p\\,\\omega_q\\,\\omega_r \\; g\\!\\left(x(\\hat{\\xi}_p,\\hat{\\eta}_q,\\hat{\\zeta}_r),\\, y(\\hat{\\xi}_p,\\hat{\\eta}_q,\\hat{\\zeta}_r),\\, z(\\hat{\\xi}_p,\\hat{\\eta}_q,\\hat{\\zeta}_r)\\right)\\,\\left|\\det J(\\hat{\\xi}_p,\\hat{\\eta}_q,\\hat{\\zeta}_r)\\right|,\n$$\nwhere $\\{(\\hat{\\xi}_p,\\omega_p)\\}$, $\\{(\\hat{\\eta}_q,\\omega_q)\\}$, $\\{(\\hat{\\zeta}_r,\\omega_r)\\}$ are the one-dimensional GL nodes and weights on $[-1,1]$.\n\nDefine the relative error\n$$\ne(N,\\alpha) = \\frac{\\left|I_{GLL}(N,\\alpha) - I_{\\text{ref}}(\\alpha)\\right|}{\\left|I_{\\text{ref}}(\\alpha)\\right|}.\n$$\nDefine a dimensionless measure of Jacobian variation at the GLL quadrature sampling points as the coefficient of variation\n$$\nV(N,\\alpha) = \\frac{\\operatorname{std}\\left(\\left\\{\\left|\\det J(\\xi_i,\\eta_j,\\zeta_k)\\right|\\right\\}_{i,j,k=1}^N\\right)}{\\operatorname{mean}\\left(\\left\\{\\left|\\det J(\\xi_i,\\eta_j,\\zeta_k)\\right|\\right\\}_{i,j,k=1}^N\\right)}.\n$$\nYour task is to implement a program that, for a test suite of $(N,\\alpha)$ pairs, computes the list of relative errors $e(N,\\alpha)$ and the Pearson correlation coefficient between $e(N,\\alpha)$ and $V(N,\\alpha)$ across the entire test suite. Use the following test suite:\n- Case 1: $N=3$, $\\alpha=0.0$.\n- Case 2: $N=9$, $\\alpha=0.0$.\n- Case 3: $N=5$, $\\alpha=0.3$.\n- Case 4: $N=5$, $\\alpha=0.6$.\n- Case 5: $N=11$, $\\alpha=0.3$.\n- Case 6: $N=11$, $\\alpha=0.6$.\n- Case 7: $N=7$, $\\alpha=0.45$.\n- Case 8: $N=13$, $\\alpha=0.2$.\n\nAlgorithm and constraints:\n1. Construct the GLL one-dimensional nodes and weights exactly as defined above from the derivative roots of $P_{N-1}(\\xi)$ and the weight formula.\n2. Construct the GL one-dimensional nodes and weights using a standard Gauss–Legendre rule with $M=30$ points per coordinate.\n3. Evaluate $I_{GLL}(N,\\alpha)$ and $I_{\\text{ref}}(\\alpha)$ via tensor-product quadrature in the reference coordinates, using the mapping and $|\\det J|$ as the change-of-variables weight.\n4. Compute $e(N,\\alpha)$ and $V(N,\\alpha)$ as defined above for each test case.\n5. Compute the Pearson correlation coefficient between the vectors $\\{e(N,\\alpha)\\}$ and $\\{V(N,\\alpha)\\}$ across all eight test cases. If either vector has zero standard deviation, define the correlation to be $0$.\n\nThere are no physical units in this problem; all quantities are dimensionless. Angles are in radians. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets: the first eight entries are the floating-point relative errors $e(N,\\alpha)$ for the eight cases listed in the given order, and the final ninth entry is the floating-point correlation coefficient. To ensure deterministic evaluation, print all floating-point numbers in scientific notation with twelve significant digits (for example, $1.23456789012\\mathrm{e}{-06}$). For example, the output format must be\n$$\n[\\text{e1},\\text{e2},\\text{e3},\\text{e4},\\text{e5},\\text{e6},\\text{e7},\\text{e8},\\text{corr}],\n$$\nwhere each placeholder is replaced by the corresponding computed number in scientific notation with twelve significant digits.", "solution": "The problem statement has been validated and is determined to be a well-posed, scientifically grounded problem in numerical analysis, specifically within the context of the finite element method or spectral element method used in computational geophysics and other engineering disciplines. The problem is self-contained, with all necessary mathematical definitions, parameters, and algorithms specified. The mapping, Jacobian, and integrand are all standard, well-behaved functions for the given parameters. The Jacobian determinant is confirmed to be positive for the given range of `\\alpha`, ensuring the isoparametric mapping is valid (i.e., invertible and orientation-preserving).\n\nThe solution proceeds by implementing the specified algorithms in a step-by-step manner.\n\n1.  **Quadrature Rule Generation**:\n    *   **Gauss–Lobatto–Legendre (GLL) Quadrature**: A function is created to generate the $N$ nodes $\\{\\xi_i\\}$ and weights $\\{w_i\\}$ for one-dimensional GLL quadrature on the interval $[-1, 1]$. As specified, the nodes consist of the endpoints $-1$ and $1$, and the $N-2$ roots of the first derivative of the Legendre polynomial of degree $N-1$, $P'_{N-1}(\\xi)$. The `scipy.special.legendre` function a convenient tool, returning a polynomial object whose `deriv()` and `roots` methods allow for a direct and robust computation of these interior nodes. The corresponding weights $\\{w_i\\}$ are then calculated using the provided formula: $w_i = \\frac{2}{N(N-1)\\,[P_{N-1}(\\xi_i)]^2}$.\n    *   **Gauss–Legendre (GL) Quadrature**: The high-fidelity reference integral requires a standard Gauss-Legendre quadrature rule. The `scipy.special.roots_legendre` function is used to generate the $M=30$ nodes and weights for this purpose.\n\n2.  **Problem-Specific Functions**:\n    *   The isoparametric mapping functions $x(\\xi,\\eta,\\zeta)$, $y(\\xi,\\eta,\\zeta)$, and $z(\\xi,\\eta,\\zeta)$ are implemented directly from their definitions.\n    *   The Jacobian determinant, $\\det J(\\xi,\\eta,\\zeta)$, is implemented using the provided closed-form expression.\n    *   The test integrand, $g(x,y,z)$, is implemented as defined, using standard mathematical functions from the `numpy` library.\n\n3.  **Numerical Integration**:\n    *   A core function performs the three-dimensional tensor-product quadrature. To avoid computationally prohibitive nested Python loops, this function is vectorized using `numpy.meshgrid` to generate coordinates for all $N^3$ (for GLL) or $M^3$ (for GL) quadrature points simultaneously.\n    *   The integral $I(\\alpha)$ is computed by evaluating the integrand $g(x,y,z)$ and the Jacobian determinant $|\\det J|$ at each of these points in the reference domain, weighting the results by the product of the corresponding 1D quadrature weights ($w_i w_j w_k$), and summing them up. This single function is used to calculate both $I_{GLL}(N,\\alpha)$ (using GLL nodes/weights) and $I_{\\text{ref}}(\\alpha)$ (using GL nodes/weights).\n\n4.  **Analysis and Final Computation**:\n    *   **Error and Variation**: For each $(N, \\alpha)$ pair in the test suite, the relative error $e(N, \\alpha)$ is computed using its definition, $e = |I_{GLL} - I_{\\text{ref}}| / |I_{\\text{ref}}|$. The Jacobian variation $V(N, \\alpha)$, defined as the coefficient of variation (standard deviation divided by the mean) of $|\\det J|$ over the GLL quadrature points, is also computed. This calculation is also vectorized for efficiency.\n    *   **Correlation**: After iterating through all test cases, the Pearson correlation coefficient between the collected list of errors $\\{e(N,\\alpha)\\}$ and the list of variations $\\{V(N,\\alpha)\\}$ is calculated using `numpy.corrcoef`. As specified, the correlation is explicitly set to $0$ if either list has a standard deviation of zero.\n    *   **Output Formatting**: The final results, comprising the eight error values and the single correlation coefficient, are formatted into a string. Each number is represented in scientific notation with twelve significant digits (`.11e` format specifier) and presented as a single-line, comma-separated list enclosed in square brackets.\n\nThis structured approach ensures that all requirements of the problem are met precisely and efficiently. To avoid recomputing the expensive reference integral for test cases that share the same `\\alpha`, the results for $I_{\\text{ref}}(\\alpha)$ are cached (memoized).", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import legendre, roots_legendre\n\ndef solve():\n    \"\"\"\n    Computes numerical integration errors and their correlation with Jacobian variation\n    for a warped hexahedral element.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (3, 0.0),\n        (9, 0.0),\n        (5, 0.3),\n        (5, 0.6),\n        (11, 0.3),\n        (11, 0.6),\n        (7, 0.45),\n        (13, 0.2),\n    ]\n\n    def gll_nodes_weights(N):\n        \"\"\"\n        Computes 1D Gauss-Lobatto-Legendre quadrature nodes and weights.\n        \"\"\"\n        if N < 3:\n            raise ValueError(\"N must be >= 3 as per problem statement.\")\n\n        # Interior nodes are roots of the derivative of P_{N-1}(x).\n        p_nm1 = legendre(N - 1)\n        p_nm1_deriv = p_nm1.deriv()\n        interior_nodes = p_nm1_deriv.roots\n        \n        # Combine with endpoints and sort.\n        nodes = np.concatenate(([-1.0], np.sort(interior_nodes), [1.0]))\n        \n        # Calculate weights based on the formula.\n        vals_p_nm1 = p_nm1(nodes)\n        weights = 2.0 / (N * (N - 1) * vals_p_nm1**2)\n        \n        return nodes, weights\n\n    def mapping(xi, eta, zeta, alpha):\n        \"\"\"Isoparametric mapping from reference to physical coordinates.\"\"\"\n        x = xi + (alpha / 2.0) * xi * eta\n        y = eta + (alpha / 2.0) * eta * zeta\n        z = zeta + (alpha / 2.0) * xi * zeta\n        return x, y, z\n\n    def det_J(xi, eta, zeta, alpha):\n        \"\"\"Determinant of the Jacobian matrix of the mapping.\"\"\"\n        a = alpha / 2.0\n        term1 = (1.0 + a * eta) * (1.0 + a * zeta) * (1.0 + a * xi)\n        term2 = (a * xi) * (a * eta) * (a * zeta)\n        return term1 + term2\n\n    def g_func(x, y, z):\n        \"\"\"Test integrand function g(x, y, z).\"\"\"\n        term1 = np.exp(0.3 * x + 0.2 * y - 0.1 * z)\n        term2 = np.sin(2.1 * x) * np.cos(1.7 * y) * np.sinh(0.5 * z)\n        return term1 + term2\n\n    def integrate_3d(nodes, weights, alpha):\n        \"\"\"\n        Performs 3D tensor-product quadrature. Vectorized for efficiency.\n        \"\"\"\n        # Create 3D grids of nodes and weights. 'ij' indexing ensures\n        # the tensor product sum is computed correctly.\n        XI, ETA, ZETA = np.meshgrid(nodes, nodes, nodes, indexing='ij')\n        WX, WY, WZ = np.meshgrid(weights, weights, weights, indexing='ij')\n\n        # Apply mapping to grid points\n        X, Y, Z = mapping(XI, ETA, ZETA, alpha)\n        \n        # Evaluate Jacobian determinant and integrand at all points\n        DETJ_vals = np.abs(det_J(XI, ETA, ZETA, alpha))\n        G_vals = g_func(X, Y, Z)\n        \n        # Compute the integral by summing weighted values\n        integrand_at_points = WX * WY * WZ * G_vals * DETJ_vals\n        integral_val = np.sum(integrand_at_points)\n\n        return integral_val\n\n    def calculate_V(nodes, alpha):\n        \"\"\"\n        Computes the Jacobian variation V(N, alpha).\n        \"\"\"\n        # Create a 3D grid of nodes.\n        XI, ETA, ZETA = np.meshgrid(nodes, nodes, nodes, indexing='ij')\n        \n        # Evaluate |det J| at all grid points\n        DETJ_vals = np.abs(det_J(XI, ETA, ZETA, alpha))\n        \n        mean_detj = np.mean(DETJ_vals)\n        std_detj = np.std(DETJ_vals)\n        \n        if mean_detj == 0:\n            return 0.0\n            \n        return std_detj / mean_detj\n\n    # Main logic\n    M = 30\n    gl_nodes_ref, gl_weights_ref = roots_legendre(M)\n\n    e_values = []\n    v_values = []\n    \n    # Memoization cache for the reference integral to avoid re-computation.\n    ref_integral_cache = {}\n\n    for N, alpha in test_cases:\n        # Calculate reference integral (or retrieve from cache)\n        if alpha not in ref_integral_cache:\n            I_ref = integrate_3d(gl_nodes_ref, gl_weights_ref, alpha)\n            ref_integral_cache[alpha] = I_ref\n        I_ref = ref_integral_cache[alpha]\n\n        # Get GLL nodes and weights for the current case\n        gll_nodes, gll_weights = gll_nodes_weights(N)\n        \n        # Calculate GLL integral\n        I_gll = integrate_3d(gll_nodes, gll_weights, alpha)\n        \n        # Calculate relative error e(N, alpha)\n        if np.abs(I_ref) == 0:\n            # Handle potential division by zero, though unlikely here.\n            error = 0.0 if np.abs(I_gll) == 0 else np.inf\n        else:\n            error = np.abs(I_gll - I_ref) / np.abs(I_ref)\n        e_values.append(error)\n        \n        # Calculate Jacobian variation V(N, alpha)\n        v = calculate_V(gll_nodes, alpha)\n        v_values.append(v)\n        \n    # Compute Pearson correlation coefficient\n    e_vec = np.array(e_values)\n    v_vec = np.array(v_values)\n    \n    corr = 0.0\n    # Per problem, if either std is zero, correlation is 0.\n    if np.std(e_vec) > 1e-15 and np.std(v_vec) > 1e-15:\n        corr_matrix = np.corrcoef(e_vec, v_vec)\n        corr = corr_matrix[0, 1]\n\n    # Combine results and format for output\n    final_results = e_values + [corr]\n    # Format to scientific notation with 12 significant digits (1 before, 11 after decimal)\n    formatted_results = [f\"{x:.11e}\" for x in final_results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3577183"}]}