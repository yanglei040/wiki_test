{"hands_on_practices": [{"introduction": "A cornerstone of the finite element method is the treatment of natural boundary conditions, such as prescribed fluxes in heat transfer or tractions in solid mechanics. These conditions arise directly from the integration-by-parts step in deriving the weak form and are incorporated into the system's load vector. This first practice provides a foundational, hands-on exercise in assembling this boundary load vector, focusing on the numerical quadrature required for the boundary integrals and addressing the practical complication of discontinuous flux data often encountered in geophysical models [@problem_id:3578899].", "problem": "Consider the scalar diffusion model in two spatial dimensions on the unit square domain $\\Omega = [0,1] \\times [0,1]$, governed by the partial differential equation\n$$\n- \\nabla \\cdot \\left( k \\nabla u \\right) = f \\quad \\text{in } \\Omega,\n$$\nwith mixed boundary conditions: Dirichlet boundary condition $u = u_D$ on $\\Gamma_D$ and Neumann boundary condition $k \\nabla u \\cdot \\mathbf{n} = g$ on $\\Gamma_N$, where $\\Gamma_D \\cup \\Gamma_N = \\partial \\Omega$ and $\\Gamma_D \\cap \\Gamma_N = \\varnothing$. In the weak formulation, after applying integration by parts and imposing the Neumann condition, the right-hand side boundary contribution for the test function $v$ is\n$$\n\\int_{\\Gamma_N} g \\, v \\, ds.\n$$\nWhen using the Finite Element Method (FEM) with piecewise linear Lagrange basis functions $\\{ \\phi_i \\}$ over a triangulation of $\\Omega$, the discrete Neumann load vector entries are\n$$\nr_i = \\int_{\\Gamma_N} g \\, \\phi_i \\, ds.\n$$\nYour task is to derive from first principles how to compute the discrete Neumann load vector entries $r_i$ by evaluating the above boundary integral using an appropriate boundary quadrature, and to implement a program that assembles these entries for a structured triangular mesh. You must address the treatment of piecewise constant flux $g$ that is discontinuous along $\\Gamma_N$.\n\nAssume the following scenario:\n- The domain is the unit square $\\Omega = [0,1] \\times [0,1]$.\n- Use a uniform, structured triangular mesh obtained by subdividing the square into $N_x \\times N_y$ rectangles and splitting each rectangle into two right triangles along the diagonal. Let $(x_i, y_j) = \\left( \\frac{i}{N_x}, \\frac{j}{N_y} \\right)$ denote the grid points for $i = 0, 1, \\dots, N_x$ and $j = 0, 1, \\dots, N_y$.\n- Let the Neumann boundary be the right edge $\\Gamma_N = \\{ (x,y) \\in \\partial \\Omega \\mid x = 1, \\, y \\in [0,1] \\}$.\n- The flux is piecewise constant along $\\Gamma_N$: \n$$\ng(y) = \n\\begin{cases}\ng_{\\text{low}}, & y < y_\\star, \\\\\ng_{\\text{up}}, & y \\ge y_\\star.\n\\end{cases}\n$$\n- On each boundary edge $e = [(1, y_1), (1, y_2)]$ with $y_1 < y_2$, restrict the linear basis functions associated with the edge endpoints to the edge. The contributions to $r_i$ and $r_j$ from the edge are computed by integrating $g(y) \\, \\phi_i(y)$ and $g(y) \\, \\phi_j(y)$ along the edge. Use a one-point Gaussian quadrature (midpoint rule) on each subsegment where $g$ is constant. If $y_\\star$ lies strictly inside the edge, split the edge at $y_\\star$ and apply the midpoint quadrature on each subsegment with its corresponding constant value of $g$.\n\nIn this setting, the restriction of the piecewise linear basis functions to a straight boundary edge is linear in the edge parameter $y$ (since $x$ is fixed at $x = 1$). For an edge with endpoints $y_1 < y_2$, the edge length is $L = y_2 - y_1$, and the restrictions satisfy\n$$\n\\phi_i(y) = \\frac{y_2 - y}{L}, \n\\quad\n\\phi_j(y) = \\frac{y - y_1}{L},\n\\quad \\text{for } y \\in [y_1, y_2].\n$$\nFor piecewise constant $g$ on a subinterval $[a,b] \\subset [y_1,y_2]$, using the midpoint rule with midpoint $y_m = \\frac{a+b}{2}$, the contribution to the load entries from this subsegment is\n$$\n\\Delta r_i = g \\, \\phi_i(y_m) \\, (b - a),\n\\quad\n\\Delta r_j = g \\, \\phi_j(y_m) \\, (b - a),\n$$\nwhich is exact because the integrands are products of a constant $g$ and a linear function $\\phi$, and the midpoint rule integrates linear functions exactly.\n\nYou must implement a program that, for each given test case, constructs the mesh metadata required to traverse the Neumann boundary edges, applies the above quadrature with edge splitting at $y_\\star$ when necessary, assembles the global Neumann load vector $r$, and returns the entries of $r$ associated with the boundary nodes on $\\Gamma_N$ ordered by ascending $y$.\n\nNo physical units are required in this computation; treat all quantities as dimensionless.\n\nTest Suite:\nProvide your program to handle the following three test cases, each specified as a tuple $(N_x, N_y, g_{\\text{low}}, g_{\\text{up}}, y_\\star)$:\n1. $(2, 4, 5.0, 11.0, 0.35)$: A moderate mesh with $y_\\star$ strictly inside one boundary edge, testing edge splitting and accumulation.\n2. $(3, 2, 7.0, 13.0, 0.5)$: The discontinuity occurs exactly at a boundary node, testing the no-split case with endpoint alignment.\n3. $(4, 4, 4.0, 4.0, 0.2)$: Uniform flux with no effective discontinuity, testing the constant $g$ case.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each item corresponds to one test case and is itself a list of the boundary-node Neumann load entries ordered by ascending $y$. For example, your output must be of the form\n$$\n[\\text{case1\\_list},\\text{case2\\_list},\\text{case3\\_list}]\n$$\nwith each $\\text{caseX\\_list}$ displayed as a Python-style list of floating point numbers.", "solution": "The problem is well-posed, scientifically grounded, and provides a complete and consistent set of givens. It describes a standard numerical procedure in the Finite Element Method (FEM) for assembling the load vector corresponding to a Neumann boundary condition with a piecewise-constant flux. The instructions for numerical quadrature are precise and appropriate for the functions being integrated. Therefore, the problem is valid, and we proceed with the solution.\n\nThe objective is to compute the entries of the Neumann boundary load vector, $r$, for a scalar diffusion problem. For each node $i$ in the finite element mesh, the corresponding entry $r_i$ is given by the integral of the prescribed flux $g$ multiplied by the basis function $\\phi_i$ over the Neumann portion of the boundary, $\\Gamma_N$:\n$$\nr_i = \\int_{\\Gamma_N} g \\, \\phi_i \\, ds.\n$$\nIn this problem, the domain is the unit square $\\Omega = [0,1] \\times [0,1]$, and the Neumann boundary is its right-hand edge, $\\Gamma_N = \\{ (1, y) \\mid y \\in [0,1] \\}$. The mesh on this boundary consists of $N_y$ straight line segments (edges), connecting $N_y+1$ nodes located at coordinates $(1, y_j)$ where $y_j = j/N_y$ for $j=0, 1, \\dots, N_y$.\n\nThe global integral for $r_i$ is assembled from contributions from each edge on $\\Gamma_N$. A basis function $\\phi_i$ is non-zero only on edges connected to node $i$. Since we are using piecewise linear Lagrange basis functions, $\\phi_i$ is non-zero only for the node $i$ itself and its immediate neighbors. For a node $j$ on the boundary $\\Gamma_N$, its basis function $\\phi_j$ is non-zero on the two edges adjacent to it (or one edge, if it is an endpoint of the domain). The integral for a specific entry $r_j$ can thus be written as a sum of integrals over the edges adjacent to node $j$:\n$$\nr_j = \\sum_{e \\in \\text{edges adjacent to node } j} \\int_e g \\, \\phi_j \\, ds.\n$$\nLet us consider a single edge $e_k$ on $\\Gamma_N$, connecting node $j$ at $(1, y_j)$ to node $j+1$ at $(1, y_{j+1})$. The length of this edge is $L = y_{j+1} - y_j = 1/N_y$. The basis functions associated with nodes $j$ and $j+1$, when restricted to this edge, are linear functions of the coordinate $y$:\n$$\n\\phi_j(y) = \\frac{y_{j+1} - y}{L}, \\quad \\phi_{j+1}(y) = \\frac{y - y_j}{L}, \\quad \\text{for } y \\in [y_j, y_{j+1}].\n$$\nThe contributions from this edge to the load vector entries $r_j$ and $r_{j+1}$ are:\n$$\n\\Delta r_j = \\int_{y_j}^{y_{j+1}} g(y) \\phi_j(y) dy, \\quad \\Delta r_{j+1} = \\int_{y_j}^{y_{j+1}} g(y) \\phi_{j+1}(y) dy.\n$$\nThe flux $g(y)$ is piecewise constant, with a discontinuity at $y=y_\\star$:\n$$\ng(y) = \n\\begin{cases}\ng_{\\text{low}}, & y < y_\\star, \\\\\ng_{\\text{up}}, & y \\ge y_\\star.\n\\end{cases}\n$$\nTo evaluate the integrals, we must consider if the discontinuity point $y_\\star$ falls within the integration interval $[y_j, y_{j+1}]$.\n\n**Case 1: No Edge Split ($y_\\star \\le y_j$ or $y_\\star \\ge y_{j+1}$)**\nIf the discontinuity is not strictly inside the edge, $g(y)$ is constant over the interval $(y_j, y_{j+1})$. The value of this constant, $g_{\\text{edge}}$, is determined by evaluating $g(y)$ at any point within the interval, such as the midpoint $y_m = (y_j+y_{j+1})/2$. The problem specifies using a one-point Gaussian quadrature (midpoint rule) for the integral. This rule approximates the integral of a function $f(y)$ over an interval $[a,b]$ as $f((a+b)/2) \\cdot (b-a)$. For an integrand that is the product of a constant and a linear function, this rule is exact.\nThe contributions are:\n$$\n\\Delta r_j = g_{\\text{edge}} \\, \\phi_j(y_m) \\, L = g_{\\text{edge}} \\cdot \\left(\\frac{y_{j+1} - y_m}{L}\\right) \\cdot L = g_{\\text{edge}} \\left(\\frac{L/2}{L}\\right) L = \\frac{g_{\\text{edge}} L}{2}.\n$$\n$$\n\\Delta r_{j+1} = g_{\\text{edge}} \\, \\phi_{j+1}(y_m) \\, L = g_{\\text{edge}} \\cdot \\left(\\frac{y_m - y_j}{L}\\right) \\cdot L = g_{\\text{edge}} \\left(\\frac{L/2}{L}\\right) L = \\frac{g_{\\text{edge}} L}{2}.\n$$\nThis corresponds to distributing the total flux on the edge, $g_{\\text{edge}} L$, equally between the two nodes.\n\n**Case 2: Edge Split ($y_j < y_\\star < y_{j+1}$)**\nIf the discontinuity lies strictly within the edge, the integral is split into two parts:\n$$\n\\int_{y_j}^{y_{j+1}} (\\cdot) dy = \\int_{y_j}^{y_\\star} (\\cdot) dy + \\int_{y_\\star}^{y_{j+1}} (\\cdot) dy.\n$$\nWe apply the midpoint rule to each sub-integral.\n\nOn the subsegment $[y_j, y_\\star]$:\nThe flux is $g=g_{\\text{low}}$. The segment length is $L_1 = y_\\star - y_j$. The midpoint is $y_{m1} = (y_j + y_\\star)/2$. The contributions are:\n$$\n\\Delta r_{j,1} = g_{\\text{low}} \\cdot \\phi_j(y_{m1}) \\cdot L_1, \\quad \\Delta r_{j+1,1} = g_{\\text{low}} \\cdot \\phi_{j+1}(y_{m1}) \\cdot L_1.\n$$\n\nOn the subsegment $[y_\\star, y_{j+1}]$:\nThe flux is $g=g_{\\text{up}}$. The segment length is $L_2 = y_{j+1} - y_\\star$. The midpoint is $y_{m2} = (y_\\star + y_{j+1})/2$. The contributions are:\n$$\n\\Delta r_{j,2} = g_{\\text{up}} \\cdot \\phi_j(y_{m2}) \\cdot L_2, \\quad \\Delta r_{j+1,2} = g_{\\text{up}} \\cdot \\phi_{j+1}(y_{m2}) \\cdot L_2.\n$$\n\nThe total contribution to the load vector entries from this split edge is the sum of the contributions from the subsegments:\n$$\n\\Delta r_j = \\Delta r_{j,1} + \\Delta r_{j,2}, \\quad \\Delta r_{j+1} = \\Delta r_{j+1,1} + \\Delta r_{j+1,2}.\n$$\nThe global load vector for the $N_y+1$ nodes on $\\Gamma_N$ is assembled by initializing it to zero, then iterating through each of the $N_y$ edges, calculating the edge contributions ($\\Delta r_j$, $\\Delta r_{j+1}$), and adding them to the corresponding entries of the global vector. An interior node $j$ receives contributions from two edges, $[y_{j-1}, y_j]$ and $[y_j, y_{j+1}]$, while the endpoint nodes $j=0$ and $j=N_y$ receive contributions from only one edge each.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef assemble_neumann_load_vector(Ny, g_low, g_up, y_star):\n    \"\"\"\n    Assembles the Neumann load vector for the right boundary of the unit square.\n\n    Args:\n        Ny (int): The number of subdivisions in the y-direction.\n        g_low (float): The flux value for y < y_star.\n        g_up (float): The flux value for y >= y_star.\n        y_star (float): The y-coordinate of the flux discontinuity.\n\n    Returns:\n        list: A list of the load vector entries for the nodes on the Neumann boundary,\n              ordered by increasing y-coordinate.\n    \"\"\"\n    # Generate the y-coordinates of the nodes on the Neumann boundary.\n    # There are Ny+1 nodes, from y=0 to y=1.\n    y_nodes = np.linspace(0.0, 1.0, Ny + 1)\n    \n    # Initialize the load vector for the Ny+1 boundary nodes.\n    r_boundary = np.zeros(Ny + 1)\n    \n    # The length of each edge on the uniform mesh.\n    L_total = 1.0 / Ny\n\n    # Iterate over each of the Ny edges on the Neumann boundary.\n    # The j-th edge connects node j and node j+1.\n    for j in range(Ny):\n        y1 = y_nodes[j]\n        y2 = y_nodes[j+1]\n\n        # Define the restricted linear basis functions for the current edge [y1, y2].\n        # phi_node_j is the basis function for the node at y1.\n        # phi_node_j1 is the basis function for the node at y2.\n        phi_node_j = lambda y: (y2 - y) / L_total\n        phi_node_j1 = lambda y: (y - y1) / L_total\n\n        #\n        # Validate if the discontinuity y_star lies strictly inside the current edge.\n        #\n        if y1  y_star  y2:\n            # Case 1: Split the edge into two subsegments for integration.\n            \n            # Subsegment 1: [y1, y_star] where g(y) = g_low\n            g1 = g_low\n            L_seg1 = y_star - y1\n            y_m1 = (y1 + y_star) / 2.0\n            \n            # Use midpoint rule: g * phi(midpoint) * length\n            dr_j_seg1 = g1 * phi_node_j(y_m1) * L_seg1\n            dr_j1_seg1 = g1 * phi_node_j1(y_m1) * L_seg1\n            \n            # Subsegment 2: [y_star, y2] where g(y) = g_up\n            g2 = g_up\n            L_seg2 = y2 - y_star\n            y_m2 = (y_star + y2) / 2.0\n            \n            # Use midpoint rule: g * phi(midpoint) * length\n            dr_j_seg2 = g2 * phi_node_j(y_m2) * L_seg2\n            dr_j1_seg2 = g2 * phi_node_j1(y_m2) * L_seg2\n            \n            # Accumulate the total contributions from this split edge.\n            r_boundary[j] += dr_j_seg1 + dr_j_seg2\n            r_boundary[j+1] += dr_j1_seg1 + dr_j1_seg2\n\n        else:\n            # Case 2: No split. The flux g(y) is constant across the edge.\n            # Determine the constant value of g by checking the midpoint.\n            y_mid = (y1 + y2) / 2.0\n            if y_mid  y_star:\n                g_edge = g_low\n            else:\n                g_edge = g_up\n            \n            # The midpoint rule on the full edge is exact and simplifies to\n            # distributing half of the total edge flux to each node.\n            # Basis function values at the midpoint are both 0.5.\n            # dr = g_edge * 0.5 * L_total\n            dr = g_edge * L_total / 2.0\n            \n            # Accumulate contributions.\n            r_boundary[j] += dr\n            r_boundary[j+1] += dr\n\n    return list(r_boundary)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (Nx, Ny, g_low, g_up, y_star)\n        (2, 4, 5.0, 11.0, 0.35),\n        (3, 2, 7.0, 13.0, 0.5),\n        (4, 4, 4.0, 4.0, 0.2),\n    ]\n\n    results = []\n    for case in test_cases:\n        # The parameter Nx is specified but not needed for this boundary calculation.\n        Nx_val, Ny_val, g_low_val, g_up_val, y_star_val = case\n        \n        # Calculate the load vector for the current test case.\n        result_vector = assemble_neumann_load_vector(Ny_val, g_low_val, g_up_val, y_star_val)\n        \n        # Append the string representation of the list to the results.\n        results.append(str(result_vector))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3578899"}, {"introduction": "While the first exercise demonstrates boundary integration on a simple, grid-aligned domain, most real-world geophysical problems involve complex geometries and unstructured meshes. This requires a more general framework, the isoparametric mapping, which transforms arbitrarily shaped physical elements to a standard reference element. This practice delves into the theoretical machinery of this transformation, guiding you to derive how boundary integrals and normal vectors are handled under this mapping, a crucial skill for developing robust finite element codes for realistic applications [@problem_id:3578897].", "problem": "Consider a two-dimensional scalar diffusion problem in the Finite Element Method (FEM), where a natural (Neumann-type) boundary condition enters the weak form via boundary integrals of the form $\\int_{\\Gamma_{e}} g \\, \\phi \\, ds$, with $g$ a prescribed boundary flux and $\\phi$ a test or shape function. Use the isoparametric formulation on a quadrilateral element with a mapping $\\boldsymbol{x}(\\xi,\\eta)$ from the reference square $[-1,1] \\times [-1,1]$ to the physical element, where $\\xi$ and $\\eta$ are the reference coordinates. The Jacobian matrix of the mapping is $\\boldsymbol{J}(\\xi,\\eta) = \\begin{bmatrix} \\partial x / \\partial \\xi  \\partial x / \\partial \\eta \\\\ \\partial y / \\partial \\xi  \\partial y / \\partial \\eta \\end{bmatrix}$, and the contravariant base vectors are $\\boldsymbol{a}_{\\xi} = \\partial \\boldsymbol{x}/\\partial \\xi$ and $\\boldsymbol{a}_{\\eta} = \\partial \\boldsymbol{x}/\\partial \\eta$.\n\nTasks:\n1) Starting from the change-of-variables theorem for line integrals and the definition of the isoparametric mapping, derive an expression that maps $\\int_{\\Gamma_{e}} g \\, \\phi \\, ds$ on a single element edge $\\Gamma_{e}$ to an integral over the corresponding reference edge $\\widehat{\\Gamma}$, explicitly identifying the one-dimensional metric factor in terms of $\\boldsymbol{a}_{\\xi}$ or $\\boldsymbol{a}_{\\eta}$ as appropriate.\n\n2) For a general straight or curved edge parameterized by fixing either $\\xi = \\xi^{\\star}$ or $\\eta = \\eta^{\\star}$, explain how to compute the unit outward normal $\\boldsymbol{n}$ along the physical edge in terms of $\\boldsymbol{a}_{\\xi}$ and $\\boldsymbol{a}_{\\eta}$. Your answer should use only quantities derived from the isoparametric mapping and should clarify the orientation choice.\n\n3) Now specialize to a bilinear quadrilateral element with nodes at physical coordinates $(x_{1},y_{1}) = (0,0)$, $(x_{2},y_{2}) = (2,0)$, $(x_{3},y_{3}) = (2,1)$, and $(x_{4},y_{4}) = (0,1)$, with the standard bilinear shape functions on $[-1,1] \\times [-1,1]$. Consider the top edge, which corresponds to $\\eta = 1$ and has outward normal in the $+y$ direction. Let the boundary flux be the nondimensional function $g(x,y) = x$, and take $\\phi$ to be the shape function associated with node $3$. Using your derived mapping, evaluate the boundary integral\n$$\nI \\equiv \\int_{\\Gamma_{e}} g \\, \\phi \\, ds\n$$\nexactly. Assume that all quantities have been nondimensionalized; report the value as a pure number. Provide the exact value (no rounding).", "solution": "The problem statement is a well-posed exercise in the application of the isoparametric finite element method to boundary integrals. It is scientifically grounded in the principles of vector calculus and numerical analysis, and its components are self-contained and logically consistent. No flaws are identified. We proceed with the solution.\n\nThe problem is divided into three parts. We will address each sequentially.\n\n### Part 1: Mapping of the Boundary Integral\n\nWe begin with the boundary integral over a physical element edge, $\\Gamma_e$:\n$$\n\\int_{\\Gamma_{e}} g \\, \\phi \\, ds\n$$\nwhere $g$ is a prescribed function, $\\phi$ is a test or shape function, and $ds$ is the differential arclength in the physical domain $\\boldsymbol{x} = (x, y)$.\n\nThe core of the isoparametric formulation is the mapping from a reference element, typically a square $\\widehat{\\Omega} = [-1,1] \\times [-1,1]$ with coordinates $(\\xi, \\eta)$, to the physical element. The mapping is given by:\n$$\n\\boldsymbol{x}(\\xi, \\eta) = \\sum_{i} N_i(\\xi, \\eta) \\boldsymbol{x}_i\n$$\nwhere $N_i$ are the shape functions defined on the reference element and $\\boldsymbol{x}_i$ are the physical coordinates of the element's nodes.\n\nAn edge $\\Gamma_e$ of the physical element corresponds to an edge $\\widehat{\\Gamma}$ of the reference square, where one of the reference coordinates is held constant. Let us consider an edge where $\\eta = \\eta^{\\star} = \\text{constant}$ (e.g., $\\eta^{\\star} = \\pm 1$). Along this edge, the physical coordinates depend only on $\\xi$: $\\boldsymbol{x} = \\boldsymbol{x}(\\xi, \\eta^{\\star})$. The variable $\\xi$ acts as a parameter along the curve $\\Gamma_e$, typically varying from $-1$ to $1$.\n\nThe differential arclength $ds$ is related to the differential change in the parameter $\\xi$ by the change-of-variables theorem for line integrals:\n$$\nds = \\left\\| \\frac{d\\boldsymbol{x}}{d\\xi} \\right\\| d\\xi\n$$\nThe vector $\\frac{d\\boldsymbol{x}}{d\\xi}$ is the tangent vector to the curve $\\Gamma_e$. Since $\\eta$ is constant, this derivative is precisely the partial derivative with respect to $\\xi$, which is defined as the contravariant base vector $\\boldsymbol{a}_{\\xi}$:\n$$\n\\frac{d\\boldsymbol{x}}{d\\xi} = \\frac{\\partial \\boldsymbol{x}}{\\partial \\xi}(\\xi, \\eta^{\\star}) = \\boldsymbol{a}_{\\xi}(\\xi, \\eta^{\\star})\n$$\nTherefore, the differential arclength is:\n$$\nds = \\| \\boldsymbol{a}_{\\xi} \\| d\\xi\n$$\nThe term $\\| \\boldsymbol{a}_{\\xi} \\|$ is the one-dimensional metric factor, or Jacobian of the transformation, for this edge.\n\nBy substituting this into the original integral and transforming the functions $g$ and $\\phi$ to the reference coordinates, we obtain the mapped integral. The integration limits for $\\xi$ along a standard reference edge are from $-1$ to $1$.\n$$\n\\int_{\\Gamma_{e}} g(\\boldsymbol{x}) \\, \\phi(\\boldsymbol{x}) \\, ds = \\int_{-1}^{1} g(\\boldsymbol{x}(\\xi, \\eta^{\\star})) \\, \\phi(\\boldsymbol{x}(\\xi, \\eta^{\\star})) \\, \\| \\boldsymbol{a}_{\\xi}(\\xi, \\eta^{\\star}) \\| \\, d\\xi\n$$\nAnalogously, for an edge where $\\xi = \\xi^{\\star} = \\text{constant}$, the parameter is $\\eta$, the tangent vector is $\\boldsymbol{a}_{\\eta} = \\frac{\\partial \\boldsymbol{x}}{\\partial \\eta}$, and the differential arclength is $ds = \\| \\boldsymbol{a}_{\\eta} \\| d\\eta$. The integral becomes:\n$$\n\\int_{\\Gamma_{e}} g(\\boldsymbol{x}) \\, \\phi(\\boldsymbol{x}) \\, ds = \\int_{-1}^{1} g(\\boldsymbol{x}(\\xi^{\\star}, \\eta)) \\, \\phi(\\boldsymbol{x}(\\xi^{\\star}, \\eta)) \\, \\| \\boldsymbol{a}_{\\eta}(\\xi^{\\star}, \\eta) \\| \\, d\\eta\n$$\nIn summary, the integral is mapped to the reference edge $\\widehat{\\Gamma}$ (e.g., the interval $[-1,1]$) by introducing a one-dimensional metric factor. This factor is the magnitude of the contravariant base vector tangent to the edge, which is $\\| \\boldsymbol{a}_{\\xi} \\|$ for edges of constant $\\eta$, and $\\| \\boldsymbol{a}_{\\eta} \\|$ for edges of constant $\\xi$.\n\n### Part 2: Computation of the Outward Normal Vector\n\nLet us determine the unit outward normal vector $\\boldsymbol{n}$ to an edge of the physical element. This requires establishing a convention for the \"outward\" direction. The standard convention assumes a mapping with a positive Jacobian determinant, $\\det(\\boldsymbol{J})  0$, which preserves orientation. This means a counter-clockwise traversal of the reference square's boundary maps to a counter-clockwise traversal of the physical element's boundary.\n\nConsider an edge parameterized by a constant $\\eta = \\eta^{\\star}$. The tangent vector, as established, is $\\boldsymbol{t} = \\boldsymbol{a}_{\\xi} = (\\frac{\\partial x}{\\partial \\xi}, \\frac{\\partial y}{\\partial \\xi})$. In a two-dimensional Cartesian system, a vector normal to $\\boldsymbol{t}$ can be found by rotating it by $\\pm 90^{\\circ}$. One such normal vector is $\\boldsymbol{v} = (-\\frac{\\partial y}{\\partial \\xi}, \\frac{\\partial x}{\\partial \\xi})$. Note that $\\|\\boldsymbol{v}\\| = \\|\\boldsymbol{a}_{\\xi}\\|$.\n\nTo determine if $\\boldsymbol{v}$ is directed inward or outward, we compare its direction to the direction of the other coordinate, $\\eta$. The vector $\\boldsymbol{a}_{\\eta} = (\\frac{\\partial x}{\\partial \\eta}, \\frac{\\partial y}{\\partial \\eta})$ points in the direction of increasing $\\eta$. We compute the dot product:\n$$\n\\boldsymbol{v} \\cdot \\boldsymbol{a}_{\\eta} = \\left(-\\frac{\\partial y}{\\partial \\xi}\\right)\\left(\\frac{\\partial x}{\\partial \\eta}\\right) + \\left(\\frac{\\partial x}{\\partial \\xi}\\right)\\left(\\frac{\\partial y}{\\partial \\eta}\\right) = \\frac{\\partial x}{\\partial \\xi}\\frac{\\partial y}{\\partial \\eta} - \\frac{\\partial x}{\\partial \\eta}\\frac{\\partial y}{\\partial \\xi} = \\det(\\boldsymbol{J})\n$$\nSince we assume $\\det(\\boldsymbol{J})  0$, the vector $\\boldsymbol{v}$ has a positive projection onto $\\boldsymbol{a}_{\\eta}$, meaning it points in the general direction of increasing $\\eta$.\n- For the \"top\" edge ($\\eta^{\\star} = 1$), the outward direction is the direction of increasing $\\eta$. Thus, $\\boldsymbol{v}$ is an outward normal vector. The unit outward normal is $\\boldsymbol{n} = \\boldsymbol{v} / \\|\\boldsymbol{v}\\| = \\frac{1}{\\|\\boldsymbol{a}_{\\xi}\\|} (-\\frac{\\partial y}{\\partial \\xi}, \\frac{\\partial x}{\\partial \\xi})$.\n- For the \"bottom\" edge ($\\eta^{\\star} = -1$), the outward direction is the direction of decreasing $\\eta$. Thus, $\\boldsymbol{v}$ is an inward normal vector. The unit outward normal is $\\boldsymbol{n} = -\\boldsymbol{v} / \\|\\boldsymbol{v}\\| = -\\frac{1}{\\|\\boldsymbol{a}_{\\xi}\\|} (-\\frac{\\partial y}{\\partial \\xi}, \\frac{\\partial x}{\\partial \\xi})$.\n\nA similar analysis applies to edges with constant $\\xi = \\xi^{\\star}$. The tangent is $\\boldsymbol{t}' = \\boldsymbol{a}_{\\eta}$, and a normal is $\\boldsymbol{v}' = (-\\frac{\\partial y}{\\partial \\eta}, \\frac{\\partial x}{\\partial \\eta})$. The dot product with $\\boldsymbol{a}_{\\xi}$ is $\\boldsymbol{v}' \\cdot \\boldsymbol{a}_{\\xi} = -\\det(\\boldsymbol{J})$. Since this is negative, $\\boldsymbol{v}'$ points opposite to the direction of increasing $\\xi$.\n- For the \"right\" edge ($\\xi^{\\star} = 1$), $\\boldsymbol{v}'$ is inward. The unit outward normal is $\\boldsymbol{n} = -\\boldsymbol{v}' / \\|\\boldsymbol{v}'\\| = \\frac{1}{\\|\\boldsymbol{a}_{\\eta}\\|} (\\frac{\\partial y}{\\partial \\eta}, -\\frac{\\partial x}{\\partial \\eta})$.\n- For the \"left\" edge ($\\xi^{\\star} = -1$), $\\boldsymbol{v}'$ is outward. The unit outward normal is $\\boldsymbol{n} = \\boldsymbol{v}' / \\|\\boldsymbol{v}'\\| = \\frac{1}{\\|\\boldsymbol{a}_{\\eta}\\|} (-\\frac{\\partial y}{\\partial \\eta}, \\frac{\\partial x}{\\partial \\eta})$.\n\n### Part 3: Evaluation of the Specific Integral\n\nWe are given a bilinear quadrilateral with nodes at $\\boldsymbol{x}_1=(0,0)$, $\\boldsymbol{x}_2=(2,0)$, $\\boldsymbol{x}_3=(2,1)$, and $\\boldsymbol{x}_4=(0,1)$. The standard bilinear shape functions $N_i(\\xi, \\eta)$ map the reference square nodes $(-1,-1), (1,-1), (1,1), (-1,1)$ to the physical nodes $1,2,3,4$ respectively. The isoparametric mapping $\\boldsymbol{x}(\\xi, \\eta) = \\sum_{i=1}^4 N_i(\\xi, \\eta) \\boldsymbol{x}_i$ is:\n$$\nx(\\xi, \\eta) = \\frac{1}{4}(1+\\xi)(1-\\eta)x_2 + \\frac{1}{4}(1+\\xi)(1+\\eta)x_3 = \\frac{1}{4}(1+\\xi)(1-\\eta)(2) + \\frac{1}{4}(1+\\xi)(1+\\eta)(2) = \\frac{1}{2}(1+\\xi)[(1-\\eta)+(1+\\eta)] = 1+\\xi\n$$\n$$\ny(\\xi, \\eta) = \\frac{1}{4}(1+\\xi)(1+\\eta)y_3 + \\frac{1}{4}(1-\\xi)(1+\\eta)y_4 = \\frac{1}{4}(1+\\xi)(1+\\eta)(1) + \\frac{1}{4}(1-\\xi)(1+\\eta)(1) = \\frac{1}{4}(1+\\eta)[(1+\\xi)+(1-\\xi)] = \\frac{1}{2}(1+\\eta)\n$$\nThis linear mapping transforms the reference square $[-1,1]\\times[-1,1]$ to the physical rectangle $[0,2]\\times[0,1]$.\n\nThe integral $I = \\int_{\\Gamma_{e}} g \\, \\phi \\, ds$ is to be evaluated on the top edge, which corresponds to $\\eta=1$. On this edge, the parameter is $\\xi$, which ranges from $-1$ (node 4) to $1$ (node 3). We use the formula from Part 1.\n\nFirst, we determine the integrand $g \\phi$ in reference coordinates.\n- The boundary flux is $g(x,y) = x$. On the edge $\\eta=1$, $x=1+\\xi$. So, $g = 1+\\xi$.\n- The shape function $\\phi$ is for node $3$, so $\\phi = N_3(\\xi,\\eta) = \\frac{1}{4}(1+\\xi)(1+\\eta)$. On the edge $\\eta=1$, this becomes $\\phi = \\frac{1}{4}(1+\\xi)(1+1) = \\frac{1}{2}(1+\\xi)$.\n\nNext, we calculate the one-dimensional metric factor $\\| \\boldsymbol{a}_{\\xi} \\|$.\n$$\n\\boldsymbol{a}_{\\xi} = \\frac{\\partial \\boldsymbol{x}}{\\partial \\xi} = \\left(\\frac{\\partial}{\\partial \\xi}(1+\\xi), \\frac{\\partial}{\\partial \\xi}\\left(\\frac{1}{2}(1+\\eta)\\right)\\right) = (1, 0)\n$$\nThe magnitude is constant:\n$$\n\\| \\boldsymbol{a}_{\\xi} \\| = \\sqrt{1^2 + 0^2} = 1\n$$\nThis is expected, as $ds$ on a horizontal line is simply $dx$, and from the mapping $dx=d\\xi$.\n\nNow, we assemble and evaluate the integral over the reference edge, where $\\xi$ runs from $-1$ to $1$:\n$$\nI = \\int_{-1}^{1} g(\\xi, 1) \\, \\phi(\\xi, 1) \\, \\| \\boldsymbol{a}_{\\xi}(\\xi, 1) \\| \\, d\\xi\n$$\n$$\nI = \\int_{-1}^{1} (1+\\xi) \\left( \\frac{1}{2}(1+\\xi) \\right) (1) \\, d\\xi = \\frac{1}{2} \\int_{-1}^{1} (1+\\xi)^2 \\, d\\xi\n$$\n$$\nI = \\frac{1}{2} \\int_{-1}^{1} (1 + 2\\xi + \\xi^2) \\, d\\xi\n$$\nWe integrate term-by-term:\n$$\nI = \\frac{1}{2} \\left[ \\xi + \\xi^2 + \\frac{\\xi^3}{3} \\right]_{-1}^{1}\n$$\n$$\nI = \\frac{1}{2} \\left( \\left( 1 + (1)^2 + \\frac{(1)^3}{3} \\right) - \\left( -1 + (-1)^2 + \\frac{(-1)^3}{3} \\right) \\right)\n$$\n$$\nI = \\frac{1}{2} \\left( \\left( 1 + 1 + \\frac{1}{3} \\right) - \\left( -1 + 1 - \\frac{1}{3} \\right) \\right)\n$$\n$$\nI = \\frac{1}{2} \\left( \\left( 2 + \\frac{1}{3} \\right) - \\left( -\\frac{1}{3} \\right) \\right) = \\frac{1}{2} \\left( \\frac{7}{3} + \\frac{1}{3} \\right) = \\frac{1}{2} \\left( \\frac{8}{3} \\right)\n$$\n$$\nI = \\frac{4}{3}\n$$\nThe value of the boundary integral is exactly $\\frac{4}{3}$.", "answer": "$$\\boxed{\\frac{4}{3}}$$", "id": "3578897"}, {"introduction": "Many problems in computational geophysics, such as modeling tectonic plates or analyzing seismic sources, involve bodies that are not fixed in space, leading to traction-free boundaries. Standard finite element formulations for such problems are ill-posed due to unconstrained rigid-body motions, resulting in a singular stiffness matrix. This advanced practice introduces a powerful and general method to resolve this issue by enforcing integral constraints using Lagrange multipliers, demonstrating how to stabilize the system and obtain a unique solution by augmenting the standard linear system into a saddle-point problem [@problem_id:3578906].", "problem": "Consider the two-dimensional, small-strain, isotropic, linear elasticity boundary value problem on a simply connected domain $\\Omega \\subset \\mathbb{R}^2$ with outward unit normal $\\mathbf{n}$ and a traction-free boundary $\\partial \\Omega$. In the absence of essential (Dirichlet) conditions, the weak form of static equilibrium enforces that for any kinematically admissible virtual displacement $\\mathbf{v}$, the bilinear form and linear form satisfy\n$$\n\\int_{\\Omega} \\boldsymbol{\\varepsilon}(\\mathbf{u}) : \\mathbb{C} : \\boldsymbol{\\varepsilon}(\\mathbf{v}) \\, d\\Omega \\;=\\; \\int_{\\Omega} \\mathbf{f} \\cdot \\mathbf{v} \\, d\\Omega \\;+\\; \\int_{\\partial \\Omega} \\mathbf{t} \\cdot \\mathbf{v} \\, ds,\n$$\nwhere $\\mathbf{u}$ is the displacement, $\\boldsymbol{\\varepsilon}(\\mathbf{u})$ is the symmetric gradient of $\\mathbf{u}$, $\\mathbb{C}$ is the fourth-order elasticity tensor, $\\mathbf{f}$ is the body force density, and $\\mathbf{t}$ is the boundary traction. With traction-free boundaries (i.e., $\\mathbf{t} = \\mathbf{0}$ on $\\partial \\Omega$), the continuous problem admits non-unique solutions due to rigid-body modes. In computational geophysics, when traction-free boundaries are prevalent, uniqueness can be restored by enforcing boundary-integrated constraints that remove rigid-body modes via Lagrange multipliers. Specifically, consider boundary-integrated constraints that enforce zero average displacement along the boundary and optionally zero average rigid rotation about a chosen point $(x_c, y_c)$:\n$$\n\\int_{\\partial \\Omega} u_x \\, ds \\;=\\; 0, \\quad \\int_{\\partial \\Omega} u_y \\, ds \\;=\\; 0, \\quad \\int_{\\partial \\Omega} \\big((x - x_c) u_y - (y - y_c) u_x\\big) \\, ds \\;=\\; 0.\n$$\nDiscretize $\\Omega = [0,1] \\times [0,1]$ using first-order (linear) triangular finite elements on a structured grid with $N_x$ cells in the $x$-direction and $N_y$ cells in the $y$-direction, with nodes at a uniform lattice of $(N_x+1)\\times(N_y+1)$ points. For the constitutive model in plane strain,\n$$\n\\mathbb{C} = \\begin{bmatrix}\n\\lambda + 2\\mu  \\lambda  0 \\\\\n\\lambda  \\lambda + 2\\mu  0 \\\\\n0  0  \\mu\n\\end{bmatrix},\n$$\nwhere $\\mu = \\dfrac{E}{2(1+\\nu)}$ and $\\lambda = \\dfrac{E \\nu}{(1+\\nu)(1-2\\nu)}$, with Young’s modulus $E$ and Poisson’s ratio $\\nu$. Assemble the global stiffness matrix $\\mathbf{K}$ and force vector $\\mathbf{f}$ by the standard finite element method using piecewise-linear shape functions and a single-point quadrature at each element centroid for the body force. Model a uniform body force $\\mathbf{f} = (0, -b)$ in the domain.\n\nEnforce the boundary-integrated constraints using Lagrange multipliers by constructing a rectangular constraint matrix $\\mathbf{B}$ whose rows correspond to the linear functionals\n$$\nc_x(\\mathbf{u}) = \\int_{\\partial \\Omega} u_x \\, ds, \\quad c_y(\\mathbf{u}) = \\int_{\\partial \\Omega} u_y \\, ds, \\quad c_r(\\mathbf{u}) = \\int_{\\partial \\Omega} \\big((x - x_c) u_y - (y - y_c) u_x\\big) \\, ds.\n$$\nDiscretize these boundary integrals consistently with the finite element space by approximating, for each nodal degree of freedom associated with a boundary node $i$ at coordinates $(x_i,y_i)$, the contributions\n$$\n\\int_{\\partial \\Omega} N_i \\, ds \\approx w_i, \\quad \\int_{\\partial \\Omega} (x - x_c) N_i \\, ds \\approx w_i (x_i - x_c), \\quad \\int_{\\partial \\Omega} (y - y_c) N_i \\, ds \\approx w_i (y_i - y_c),\n$$\nwhere $N_i$ is the nodal shape function and $w_i$ is the lumped boundary weight obtained by summing, for each boundary edge of length $L_e$ incident to node $i$, the contribution $L_e/2$. Let the Lagrange multipliers be collected in $\\boldsymbol{\\lambda}$. The resulting discrete saddle-point system is\n$$\n\\begin{bmatrix}\n\\mathbf{K}  \\mathbf{B}^{\\top} \\\\\n\\mathbf{B}  \\mathbf{0}\n\\end{bmatrix}\n\\begin{bmatrix}\n\\mathbf{u} \\\\ \\boldsymbol{\\lambda}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\mathbf{f} \\\\ \\mathbf{0}\n\\end{bmatrix}.\n$$\n\nYour task is to implement a complete program that:\n- Generates the mesh and assembles $\\mathbf{K}$ and $\\mathbf{f}$ using the above definitions for plane strain with linear triangular elements.\n- Builds the boundary-integrated constraint matrix $\\mathbf{B}$ for the following two configurations:\n  - Translation-only constraints: enforce $c_x(\\mathbf{u})=0$ and $c_y(\\mathbf{u})=0$ (two constraints).\n  - Translation-and-rotation constraints: enforce $c_x(\\mathbf{u})=0$, $c_y(\\mathbf{u})=0$, and $c_r(\\mathbf{u})=0$ with $(x_c,y_c)=(\\tfrac{1}{2},\\tfrac{1}{2})$ (three constraints).\n- For translation-only constraints, do not attempt to solve the saddle-point system. Instead, evaluate the smallest absolute eigenvalue of the symmetric saddle-point matrix to diagnose the unresolved rigid-body rotation mode.\n- For translation-and-rotation constraints, solve the saddle-point system for the displacement vector $\\mathbf{u}$.\n\nAll quantities are nondimensionalized; report pure numbers without physical units.\n\nTest Suite:\nUse the following four test cases on $\\Omega=[0,1]\\times[0,1]$ with $N_x = 2$, $N_y = 2$, $b = 1$ and $(x_c,y_c)=(\\tfrac{1}{2},\\tfrac{1}{2})$.\n- Test case $1$: $E=1.0$, $\\nu=0.25$, translation-only constraints. Output the smallest absolute eigenvalue of the saddle-point matrix as a floating-point number.\n- Test case $2$: $E=1.0$, $\\nu=0.25$, translation-and-rotation constraints. Output the Euclidean norm $\\|\\mathbf{u}\\|_2$ as a floating-point number.\n- Test case $3$: $E=2.0$, $\\nu=0.25$, translation-and-rotation constraints. Output the Euclidean norm $\\|\\mathbf{u}\\|_2$ as a floating-point number.\n- Test case $4$: $E=1.0$, $\\nu=0.49$, translation-and-rotation constraints. Output the Euclidean norm $\\|\\mathbf{u}\\|_2$ as a floating-point number.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets in the order of the test suite, for example $[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4]$. Each entry must be a floating-point number. No other text should be printed.", "solution": "The problem is subjected to validation against the established criteria.\n\n### Step 1: Extract Givens\n- **Governing Equations**: Two-dimensional, small-strain, isotropic, linear elasticity.\n- **Domain**: $\\Omega = [0,1] \\times [0,1]$.\n- **Boundary Conditions**: Traction-free on $\\partial \\Omega$, i.e., $\\mathbf{t} = \\mathbf{0}$.\n- **Weak Form**: $\\int_{\\Omega} \\boldsymbol{\\varepsilon}(\\mathbf{u}) : \\mathbb{C} : \\boldsymbol{\\varepsilon}(\\mathbf{v}) \\, d\\Omega = \\int_{\\Omega} \\mathbf{f} \\cdot \\mathbf{v} \\, d\\Omega$.\n- **Body Force**: Uniform, $\\mathbf{f} = (0, -b)$.\n- **Discretization**:\n    - First-order (linear) triangular finite elements.\n    - Structured grid with $N_x$ and $N_y$ cells.\n    - $(N_x+1)\\times(N_y+1)$ nodal points.\n- **Constitutive Model (Plane Strain)**: $\\mathbf{C} = \\begin{bmatrix} \\lambda + 2\\mu  \\lambda  0 \\\\ \\lambda  \\lambda + 2\\mu  0 \\\\ 0  0  \\mu \\end{bmatrix}$, with Lamé parameters $\\lambda = \\frac{E \\nu}{(1+\\nu)(1-2\\nu)}$ and $\\mu = \\frac{E}{2(1+\\nu)}$.\n- **Numerical Integration**: Single-point quadrature at element centroid for the body force term.\n- **Constraints**:\n    - Translation: $\\int_{\\partial \\Omega} u_x \\, ds = 0$ and $\\int_{\\partial \\Omega} u_y \\, ds = 0$.\n    - Rotation: $\\int_{\\partial \\Omega} \\big((x - x_c) u_y - (y - y_c) u_x\\big) \\, ds = 0$.\n- **Discrete Constraints**:\n    - The boundary integrals are approximated using lumped boundary weights $w_i$, where $w_i$ is the sum of half-lengths of boundary edges incident to node $i$.\n- **System of Equations**: A saddle-point system $\\begin{bmatrix} \\mathbf{K}  \\mathbf{B}^{\\top} \\\\ \\mathbf{B}  \\mathbf{0} \\end{bmatrix} \\begin{bmatrix} \\mathbf{u} \\\\ \\boldsymbol{\\lambda} \\end{bmatrix} = \\begin{bmatrix} \\mathbf{f} \\\\ \\mathbf{0} \\end{bmatrix}$.\n- **Test Suite Parameters**: $N_x = 2$, $N_y = 2$, $b = 1$, $(x_c,y_c)=(\\tfrac{1}{2},\\tfrac{1}{2})$.\n    - Case 1: $E=1.0$, $\\nu=0.25$, translation-only constraints. Task: Find smallest absolute eigenvalue of the saddle-point matrix.\n    - Case 2: $E=1.0$, $\\nu=0.25$, translation-and-rotation constraints. Task: Find $\\|\\mathbf{u}\\|_2$.\n    - Case 3: $E=2.0$, $\\nu=0.25$, translation-and-rotation constraints. Task: Find $\\|\\mathbf{u}\\|_2$.\n    - Case 4: $E=1.0$, $\\nu=0.49$, translation-and-rotation constraints. Task: Find $\\|\\mathbf{u}\\|_2$.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded**: The problem is based on the standard theory of linear elasticity and its numerical solution via the finite element method (FEM). The use of Lagrange multipliers to enforce integral constraints on a floating body is a well-established and correct technique in computational mechanics. All provided equations and definitions are standard. The problem is scientifically sound.\n- **Well-Posed**: The initial boundary value problem with purely Neumann (traction) conditions is correctly identified as being ill-posed due to rigid-body modes. The core of the problem is to enforce well-posedness by adding constraints. For translation-only constraints, the problem correctly anticipates an unresolved rotational mode and asks for its diagnosis via an eigenvalue analysis, which is a meaningful task. For translation-and-rotation constraints, the problem becomes well-posed, admitting a unique solution. The parameters, including $\\nu=0.49$, are within valid physical and numerical ranges.\n- **Objective**: The problem is stated using precise, unambiguous mathematical and engineering terminology. The tasks are quantitative and free of subjectivity.\n- **Conclusion**: The problem does not violate any of the invalidity criteria. It is a complete, consistent, and scientifically sound problem in computational mechanics.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. A solution will be provided.\n\nThe solution to this problem requires a standard implementation of the two-dimensional finite element method for linear elasticity. The process is as follows:\n\n**1. Mesh Generation**\nThe domain $\\Omega = [0,1] \\times [0,1]$ is discretized into a structured grid of $N_x \\times N_y$ cells. With $N_x=2$ and $N_y=2$, we have $4$ square cells. Each square cell is subdivided into two first-order triangular elements, resulting in a total of $N_{el} = 2 N_x N_y = 8$ elements. The number of nodes is $N_{nodes} = (N_x+1)(N_y+1) = 9$. The coordinates of node $k$, indexed from $0$ to $8$, are generated. Each node has two degrees of freedom (DOFs), $u_x$ and $u_y$, leading to a total of $N_{dof} = 2 N_{nodes} = 18$ DOFs in the system.\n\n**2. FEM Assembly: Stiffness Matrix and Force Vector**\nThe global stiffness matrix $\\mathbf{K}$ and force vector $\\mathbf{f}$ are assembled by iterating over all elements. For each triangular element $e$ with area $A_e$:\n\n- **Element Stiffness Matrix $\\mathbf{k}_e$**: The element stiffness matrix is given by the integral $\\mathbf{k}_e = \\int_{A_e} \\mathbf{B}_e^\\top \\mathbf{C} \\mathbf{B}_e \\, dA$. For a linear triangular element, the strain-displacement matrix $\\mathbf{B}_e$ is constant over the element. Thus, the integral simplifies to $\\mathbf{k}_e = A_e \\mathbf{B}_e^\\top \\mathbf{C} \\mathbf{B}_e$.\n    - The material constitutive matrix $\\mathbf{C}$ for plane strain is defined using Young's modulus $E$ and Poisson's ratio $\\nu$:\n    $$ \\mathbf{C} = \\begin{bmatrix} \\lambda + 2\\mu  \\lambda  0 \\\\ \\lambda  \\lambda + 2\\mu  0 \\\\ 0  0  \\mu \\end{bmatrix}, \\quad \\mu = \\frac{E}{2(1+\\nu)}, \\quad \\lambda = \\frac{E \\nu}{(1+\\nu)(1-2\\nu)} $$\n    - The strain-displacement matrix $\\mathbf{B}_e$ maps the $6$ nodal displacements of the element to the $3$ components of strain $(\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy})^\\top$. It is derived from the spatial derivatives of the linear shape functions $N_i$:\n    $$ \\mathbf{B}_e = \\begin{bmatrix} \\frac{\\partial N_1}{\\partial x}  0  \\frac{\\partial N_2}{\\partial x}  0  \\frac{\\partial N_3}{\\partial x}  0 \\\\ 0  \\frac{\\partial N_1}{\\partial y}  0  \\frac{\\partial N_2}{\\partial y}  0  \\frac{\\partial N_3}{\\partial y} \\\\ \\frac{\\partial N_1}{\\partial y}  \\frac{\\partial N_1}{\\partial x}  \\frac{\\partial N_2}{\\partial y}  \\frac{\\partial N_2}{\\partial x}  \\frac{\\partial N_3}{\\partial y}  \\frac{\\partial N_3}{\\partial x} \\end{bmatrix} $$\n\n- **Element Force Vector $\\mathbf{f}_e$**: The element force vector from the body force $\\mathbf{f}_b = (0, -b)^\\top$ is $\\mathbf{f}_e = \\int_{A_e} \\mathbf{N}_e^\\top \\mathbf{f}_b \\, dA$, where $\\mathbf{N}_e$ is the matrix of shape functions. Using single-point quadrature at the element centroid, where $N_1=N_2=N_3=1/3$, this simplifies to $\\mathbf{f}_e = A_e \\mathbf{N}_e(\\text{centroid})^\\top \\mathbf{f}_b$. This distributes the total element force $(0, -b A_e)$ equally among the three nodes.\n\nThe element matrices $\\mathbf{k}_e$ and vectors $\\mathbf{f}_e$ are then assembled into the global system $\\mathbf{K}$ and $\\mathbf{f}$ based on the DOF connectivity of each element.\n\n**3. Constraint Matrix Construction**\nThe constraint matrix $\\mathbf{B}$ implements the boundary-integrated constraints.\nFirst, we identify boundary nodes and compute their lumped weights $w_i$. For a node $i$ on the boundary, $w_i = \\sum_{e \\in E_i} L_e/2$, where $E_i$ is the set of boundary edges incident to node $i$ and $L_e$ is the length of edge $e$. For the specified $2 \\times 2$ grid, the side lengths are $0.5$, and every boundary node has an associated weight $w_i = 0.5$.\n\nThe rows of $\\mathbf{B}$ correspond to the discretized constraints:\n- **Translation in $x$**: The constraint $\\sum_{i \\in \\partial\\Omega} w_i u_{ix} = 0$ corresponds to a row in $\\mathbf{B}$ where the entry for the $x$-DOF of each boundary node $i$ is $w_i$.\n- **Translation in $y$**: The constraint $\\sum_{i \\in \\partial\\Omega} w_i u_{iy} = 0$ corresponds to a row where the entry for the $y$-DOF of each boundary node $i$ is $w_i$.\n- **Rotation**: The constraint $\\sum_{i \\in \\partial\\Omega} (w_i (x_i-x_c) u_{iy} - w_i (y_i-y_c) u_{ix}) = 0$ corresponds to a row where, for each boundary node $i$, the entry for the $x$-DOF is $-w_i(y_i-y_c)$ and for the $y$-DOF is $w_i(x_i-x_c)$.\n\n**4. Solving the Saddle-Point System**\nThe full system is constructed as a symmetric saddle-point matrix $\\mathbf{M}$ and a corresponding right-hand-side vector $\\mathbf{RHS}$:\n$$ \\mathbf{M} = \\begin{bmatrix} \\mathbf{K}  \\mathbf{B}^{\\top} \\\\ \\mathbf{B}  \\mathbf{0} \\end{bmatrix}, \\quad \\mathbf{RHS} = \\begin{bmatrix} \\mathbf{f} \\\\ \\mathbf{0} \\end{bmatrix} $$\n- **Test Case 1 (Translation-only constraints)**: The matrix $\\mathbf{B}$ is $2 \\times 18$. The resulting matrix $\\mathbf{M}$ is singular due to the unconstrained rigid-body rotation. The singularity is diagnosed by computing the eigenvalues of the symmetric matrix $\\mathbf{M}$ and finding the smallest one in absolute value, which is expected to be numerically close to zero.\n- **Test Cases 2, 3, 4 (Translation-and-rotation constraints)**: The matrix $\\mathbf{B}$ is $3 \\times 18$. With all three rigid-body modes constrained, $\\mathbf{M}$ is non-singular. The linear system $\\mathbf{M} \\mathbf{x} = \\mathbf{RHS}$ is solved for the solution vector $\\mathbf{x} = [\\mathbf{u}^\\top, \\boldsymbol{\\lambda}^\\top]^\\top$. The displacement vector $\\mathbf{u}$ is extracted from the first $N_{dof}$ components of $\\mathbf{x}$, and its Euclidean norm $\\|\\mathbf{u}\\|_2$ is computed.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the elasticity problem for all test cases.\n    \"\"\"\n    test_cases = [\n        {'E': 1.0, 'nu': 0.25, 'constraints': 'translation'},\n        {'E': 1.0, 'nu': 0.25, 'constraints': 'translation_rotation'},\n        {'E': 2.0, 'nu': 0.25, 'constraints': 'translation_rotation'},\n        {'E': 1.0, 'nu': 0.49, 'constraints': 'translation_rotation'}\n    ]\n\n    results = []\n    for params in test_cases:\n        E = params['E']\n        nu = params['nu']\n        constraint_type = params['constraints']\n\n        # Shared parameters\n        Nx, Ny = 2, 2\n        b = 1.0\n        xc, yc = 0.5, 0.5\n        \n        # 1. Generate Mesh\n        nodes, elements = generate_mesh(Nx, Ny)\n        n_nodes = len(nodes)\n        n_dofs = 2 * n_nodes\n\n        # 2. Assemble Stiffness Matrix and Force Vector\n        K, f = assemble_stiffness_and_force(nodes, elements, E, nu, b)\n\n        # 3. Assemble Constraint Matrix\n        B = assemble_constraint_matrix(nodes, Nx, Ny, constraint_type, xc, yc)\n        n_constraints = B.shape[0]\n\n        # 4. Form and solve the saddle-point system\n        M = np.zeros((n_dofs + n_constraints, n_dofs + n_constraints))\n        M[0:n_dofs, 0:n_dofs] = K\n        M[0:n_dofs, n_dofs:] = B.T\n        M[n_dofs:, 0:n_dofs] = B\n        \n        if constraint_type == 'translation':\n            # For translation-only, find the smallest absolute eigenvalue\n            eigenvalues = np.linalg.eigvalsh(M)\n            result = np.min(np.abs(eigenvalues))\n        else:\n            # For full constraints, solve the system\n            RHS = np.zeros(n_dofs + n_constraints)\n            RHS[0:n_dofs] = f\n            \n            # Solve for displacements and Lagrange multipliers\n            solution = np.linalg.solve(M, RHS)\n            u = solution[0:n_dofs]\n            result = np.linalg.norm(u)\n        \n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef generate_mesh(Nx, Ny):\n    \"\"\"Generates node coordinates and element connectivity for a structured triangular mesh.\"\"\"\n    n_nodes = (Nx + 1) * (Ny + 1)\n    nodes = np.zeros((n_nodes, 2))\n    for j in range(Ny + 1):\n        for i in range(Nx + 1):\n            node_idx = i + j * (Nx + 1)\n            nodes[node_idx] = [i / Nx, j / Ny]\n    \n    n_elements = 2 * Nx * Ny\n    elements = np.zeros((n_elements, 3), dtype=int)\n    el_idx = 0\n    for j in range(Ny):\n        for i in range(Nx):\n            # Node indices of the square cell\n            n1 = i + j * (Nx + 1)\n            n2 = (i + 1) + j * (Nx + 1)\n            n3 = i + (j + 1) * (Nx + 1)\n            n4 = (i + 1) + (j + 1) * (Nx + 1)\n            \n            # Create two triangles from the cell\n            elements[el_idx] = [n1, n2, n3]\n            elements[el_idx + 1] = [n4, n3, n2]\n            el_idx += 2\n    return nodes, elements\n\ndef assemble_stiffness_and_force(nodes, elements, E, nu, b):\n    \"\"\"Assembles the global stiffness matrix K and force vector f.\"\"\"\n    n_nodes = len(nodes)\n    n_dofs = 2 * n_nodes\n    K = np.zeros((n_dofs, n_dofs))\n    f = np.zeros(n_dofs)\n\n    # Material properties (plane strain)\n    mu = E / (2 * (1 + nu))\n    lmbda = E * nu / ((1 + nu) * (1 - 2 * nu))\n    C = np.array([[lmbda + 2 * mu, lmbda, 0],\n                  [lmbda, lmbda + 2 * mu, 0],\n                  [0, 0, mu]])\n\n    for el_nodes in elements:\n        # Element node coordinates\n        coords = nodes[el_nodes]\n        x1, y1 = coords[0]\n        x2, y2 = coords[1]\n        x3, y3 = coords[2]\n\n        # Element area\n        area = 0.5 * np.abs(x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2))\n\n        # Strain-displacement matrix B\n        # B = [B1, B2, B3] where Bi is 3x2\n        # dN/dx, dN/dy for linear triangle\n        # dNi/dx = (1/2A) * (y_j - y_k)\n        # dNi/dy = (1/2A) * (x_k - x_j)\n        y23, y31, y12 = y2 - y3, y3 - y1, y1 - y2\n        x32, x13, x21 = x3 - x2, x1 - x3, x2 - x1\n        \n        B_mat = (1 / (2 * area)) * np.array([\n            [y23, 0,   y31, 0,   y12, 0  ],\n            [0,   x32, 0,   x13, 0,   x21],\n            [x32, y23, x13, y31, x21, y12]\n        ])\n\n        # Element stiffness matrix\n        ke = area * B_mat.T @ C @ B_mat\n        \n        # Element force vector (body force)\n        fe = np.array([0, -b * area / 3, 0, -b * area / 3, 0, -b * area / 3])\n\n        # Assemble into global matrices\n        dof_indices = []\n        for node_idx in el_nodes:\n            dof_indices.extend([2 * node_idx, 2 * node_idx + 1])\n        \n        for i in range(6):\n            f[dof_indices[i]] += fe[i]\n            for j in range(6):\n                K[dof_indices[i], dof_indices[j]] += ke[i, j]\n                \n    return K, f\n\ndef assemble_constraint_matrix(nodes, Nx, Ny, constraint_type, xc, yc):\n    \"\"\"Assembles the Lagrange multiplier constraint matrix B.\"\"\"\n    n_nodes = len(nodes)\n    n_dofs = 2 * n_nodes\n    \n    # Identify boundary nodes and calculate weights\n    boundary_nodes = set()\n    weights = np.zeros(n_nodes)\n    hx = 1.0 / Nx\n    hy = 1.0 / Ny\n\n    # Bottom and Top edges\n    for i in range(Nx):\n        n1 = i; boundary_nodes.add(n1)\n        n2 = i+1; boundary_nodes.add(n2)\n        weights[n1] += hx / 2\n        weights[n2] += hx / 2\n        \n        n1 = i + Ny*(Nx+1); boundary_nodes.add(n1)\n        n2 = i+1 + Ny*(Nx+1); boundary_nodes.add(n2)\n        weights[n1] += hx / 2\n        weights[n2] += hx / 2\n\n    # Left and Right edges\n    for j in range(Ny):\n        n1 = j*(Nx+1); boundary_nodes.add(n1)\n        n2 = (j+1)*(Nx+1); boundary_nodes.add(n2)\n        weights[n1] += hy / 2\n        weights[n2] += hy / 2\n\n        n1 = (Nx) + j*(Nx+1); boundary_nodes.add(n1)\n        n2 = (Nx) + (j+1)*(Nx+1); boundary_nodes.add(n2)\n        weights[n1] += hy / 2\n        weights[n2] += hy / 2\n        \n    sorted_boundary_nodes = sorted(list(boundary_nodes))\n\n    if constraint_type == 'translation':\n        n_constraints = 2\n        B = np.zeros((n_constraints, n_dofs))\n        for i in sorted_boundary_nodes:\n            w_i = weights[i]\n            # Constraint for sum(u_x) = 0\n            B[0, 2 * i] = w_i\n            # Constraint for sum(u_y) = 0\n            B[1, 2 * i + 1] = w_i\n    else: # translation_rotation\n        n_constraints = 3\n        B = np.zeros((n_constraints, n_dofs))\n        for i in sorted_boundary_nodes:\n            w_i = weights[i]\n            x_i, y_i = nodes[i]\n            # Constraint for sum(u_x) = 0\n            B[0, 2 * i] = w_i\n            # Constraint for sum(u_y) = 0\n            B[1, 2 * i + 1] = w_i\n            # Constraint for sum((x-xc)uy - (y-yc)ux) = 0\n            B[2, 2 * i] = -w_i * (y_i - yc) # u_x component\n            B[2, 2 * i + 1] = w_i * (x_i - xc) # u_y component\n    \n    return B\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3578906"}]}