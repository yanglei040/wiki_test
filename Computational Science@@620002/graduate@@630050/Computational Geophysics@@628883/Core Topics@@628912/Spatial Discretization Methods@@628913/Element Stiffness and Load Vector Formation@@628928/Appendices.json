{"hands_on_practices": [{"introduction": "Before tackling complex geophysical simulations, it's essential to confirm that our assembled global stiffness matrix, $\\mathbf{K}$, correctly represents fundamental physical laws. The most basic of these is that rigid body motions—translations and rotations of the entire body—should induce no internal strain, and therefore no resisting forces. This exercise [@problem_id:3588944] provides a hands-on method to verify this principle by checking if the product of the stiffness matrix and a rigid body mode vector, $\\mathbf{r}$, is the zero vector ($\\mathbf{K}\\mathbf{r} = \\mathbf{0}$). You will also explore the critical implication of this property for the solvability of the system $\\mathbf{K}\\mathbf{u}=\\mathbf{f}$, reinforcing a foundational concept for building any robust finite element code.", "problem": "Consider a two-dimensional small-strain, linear elastic solid in a nondimensional setting, discretized by the Finite Element Method (FEM) using constant-strain three-node triangles. The constitutive behavior is linear isotropic elasticity under plane stress. The unknown displacement field is denoted by the vector $\\mathbf{u}$ collecting all nodal displacements in the order $\\left[u_{x1}, u_{y1}, u_{x2}, u_{y2}, \\dots \\right]^{\\top}$. The assembled global stiffness matrix is $\\mathbf{K}$ and the global load vector is $\\mathbf{f}$. The rigid body modes are the three displacement patterns corresponding to two translations and one in-plane rotation.\n\nFundamental base to be used:\n- The Principle of Virtual Work: for any virtual displacement $\\delta \\mathbf{u}$, the internal virtual work equals the external virtual work, i.e., $\\int_{\\Omega} \\boldsymbol{\\sigma} : \\delta \\boldsymbol{\\varepsilon} \\, \\mathrm{d}\\Omega = \\int_{\\Omega} \\mathbf{b} \\cdot \\delta \\mathbf{u} \\, \\mathrm{d}\\Omega + \\int_{\\Gamma_{t}} \\bar{\\mathbf{t}} \\cdot \\delta \\mathbf{u} \\, \\mathrm{d}\\Gamma$, which, upon finite element discretization, yields $\\delta \\mathbf{u}^{\\top} \\mathbf{K} \\mathbf{u} = \\delta \\mathbf{u}^{\\top} \\mathbf{f}$.\n- Linear kinematics: $\\boldsymbol{\\varepsilon} = \\mathbf{B} \\mathbf{u}_{e}$ for each element with constant strain-displacement matrix $\\mathbf{B}$.\n- Linear isotropic elasticity under plane stress: $\\boldsymbol{\\sigma} = \\mathbf{D} \\, \\boldsymbol{\\varepsilon}$ with $\\mathbf{D} = \\dfrac{E}{1-\\nu^{2}} \\begin{bmatrix} 1 & \\nu & 0 \\\\ \\nu & 1 & 0 \\\\ 0 & 0 & \\dfrac{1-\\nu}{2} \\end{bmatrix}$, where $E$ is Young's modulus and $\\nu$ is Poisson's ratio.\n- Element stiffness matrix for a constant-strain triangle (thickness $t$): $\\mathbf{K}_{e} = t \\, A_{e} \\, \\mathbf{B}^{\\top} \\mathbf{D} \\mathbf{B}$, where $A_{e}$ is the triangle area and $\\mathbf{B}$ is computed from nodal coordinates by standard constant-strain triangle formulas.\n\nTasks:\n1. Assemble the global stiffness matrix $\\mathbf{K}$ for a unit square domain $\\Omega = [0,1] \\times [0,1]$ discretized into two linear triangular elements with nodes at $(0,0)$, $(1,0)$, $(1,1)$, $(0,1)$ and elements $\\{(0,0),(1,0),(1,1)\\}$ and $\\{(0,0),(1,1),(0,1)\\}$. Use plane stress with thickness $t = 1$. All quantities are nondimensional, so no physical units are required in the output.\n2. Construct the three rigid body mode vectors $\\mathbf{r}_{1}$, $\\mathbf{r}_{2}$, $\\mathbf{r}_{3}$ of size $2N$ corresponding to: translation in $x$ ($\\mathbf{r}_{1}$ has $u_{xi} = 1$, $u_{yi} = 0$ for all nodes), translation in $y$ ($\\mathbf{r}_{2}$ has $u_{xi} = 0$, $u_{yi} = 1$), and unit rotation about the origin ($\\mathbf{r}_{3}$ has $u_{xi} = -y_{i}$ and $u_{yi} = x_{i}$ at node $i$).\n3. Verify the rigid body modes by computing $\\|\\mathbf{K} \\mathbf{r}_{j}\\|_{2}$ for $j \\in \\{1,2,3\\}$ for each assembled $\\mathbf{K}$, and report these norms as floats. In exact arithmetic and correct assembly, $\\mathbf{K} \\mathbf{r}_{j} = \\mathbf{0}$.\n4. Show that any load vector $\\mathbf{f}$ orthogonal to all rigid body modes (i.e., $\\mathbf{r}_{j}^{\\top} \\mathbf{f} = 0$ for $j \\in \\{1,2,3\\}$) yields a solvable system $\\mathbf{K} \\mathbf{u} = \\mathbf{f}$ in the sense that there exists at least one solution. Numerically verify solvability by computing the minimum-norm solution $\\mathbf{u} = \\mathbf{K}^{+} \\mathbf{f}$, where $\\mathbf{K}^{+}$ is the Moore–Penrose pseudoinverse, and report the residual norm $\\|\\mathbf{K}\\mathbf{u} - \\mathbf{f}\\|_{2}$ as a float.\n5. Design a load vector $\\mathbf{f}$ that erroneously excites constrained (rigid body) modes, meaning it is not orthogonal to the rigid body mode subspace. Detect this by computing the magnitude of the projection of $\\mathbf{f}$ onto the span of $\\{\\mathbf{r}_{1}, \\mathbf{r}_{2}, \\mathbf{r}_{3}\\}$ and reporting this magnitude as a float, and also report a boolean flag indicating detection, defined as true if this magnitude exceeds a tolerance $\\varepsilon = 10^{-10}$ and false otherwise.\n\nUse the following test suite of parameter values and loads:\n- Test case $\\#1$: $E = 2$, $\\nu = 0.25$, $t = 1$. Load $\\mathbf{f}$ is self-equilibrated and orthogonal to rigid modes: apply $+1$ in the $x$-direction at node $(1,0)$ and $-1$ in the $x$-direction at node $(0,0)$, zeros elsewhere.\n- Test case $\\#2$: $E = 1$, $\\nu = 0$, $t = 1$. Load $\\mathbf{f}$ is a deterministic random vector projected to be orthogonal to all rigid modes.\n- Test case $\\#3$: $E = 2$, $\\nu = 0.25$, $t = 1$. Load $\\mathbf{f}$ is a uniform downward nodal load: $-1$ in the $y$-direction at every node, zeros in the $x$-direction.\n\nFor each test case, produce the following outputs in order:\n- The three floats $\\|\\mathbf{K} \\mathbf{r}_{1}\\|_{2}$, $\\|\\mathbf{K} \\mathbf{r}_{2}\\|_{2}$, $\\|\\mathbf{K} \\mathbf{r}_{3}\\|_{2}$.\n- The float residual norm $\\|\\mathbf{K}\\mathbf{u} - \\mathbf{f}\\|_{2}$ using $\\mathbf{u} = \\mathbf{K}^{+} \\mathbf{f}$.\n- The float magnitude of the projection of $\\mathbf{f}$ onto the rigid body mode subspace.\n- The boolean detection flag defined as true if the projection magnitude exceeds $\\varepsilon = 10^{-10}$ and false otherwise.\n\nFinal output format:\nYour program should produce a single line of output containing the concatenated results for all three test cases as a comma-separated list enclosed in square brackets, i.e., $\\left[ \\text{case1\\_n1}, \\text{case1\\_n2}, \\text{case1\\_n3}, \\text{case1\\_res}, \\text{case1\\_proj}, \\text{case1\\_flag}, \\text{case2\\_n1}, \\dots, \\text{case3\\_flag} \\right]$. All numbers must be printed as raw decimal values without units, and the booleans as either true or false in the programming language's native boolean literal form.", "solution": "The problem presented is valid. It is a well-posed and scientifically grounded exercise in computational solid mechanics using the Finite Element Method (FEM). All necessary data, including geometry, material properties, and loading conditions, are provided, and the tasks are consistent with established principles of linear elasticity and numerical linear algebra. The problem is free from contradictions, ambiguities, and factual errors.\n\nThe solution proceeds by first establishing the theoretical framework for a constant-strain triangle (CST) element under plane stress conditions. Subsequently, the global stiffness matrix for the specified two-element mesh is assembled. The rigid body modes are constructed and verified. Finally, for each test case, the system's solvability is assessed by utilizing the Moore-Penrose pseudoinverse and by projecting the load vector onto the subspace of rigid body modes.\n\n**1. Element Formulation**\n\nFor a $3$-node triangular element in a $2$D plane stress state, the relationship between the constant strain vector $\\boldsymbol{\\varepsilon} = [\\varepsilon_x, \\varepsilon_y, \\gamma_{xy}]^\\top$ and the vector of nodal displacements $\\mathbf{u}_e = [u_{x1}, u_{y1}, u_{x2}, u_{y2}, u_{x3}, u_{y3}]^\\top$ is given by $\\boldsymbol{\\varepsilon} = \\mathbf{B} \\mathbf{u}_e$. The strain-displacement matrix $\\mathbf{B}$ for an element with nodal coordinates $(x_1, y_1)$, $(x_2, y_2)$, and $(x_3, y_3)$ is:\n$$\n\\mathbf{B} = \\frac{1}{2A_e}\n\\begin{bmatrix}\ny_2 - y_3 & 0 & y_3 - y_1 & 0 & y_1 - y_2 & 0 \\\\\n0 & x_3 - x_2 & 0 & x_1 - x_3 & 0 & x_2 - x_1 \\\\\nx_3 - x_2 & y_2 - y_3 & x_1 - x_3 & y_3 - y_1 & x_2 - x_1 & y_1 - y_2\n\\end{bmatrix}\n$$\nwhere $A_e$ is the element area.\n\nThe constitutive relation for linear isotropic elasticity under plane stress is $\\boldsymbol{\\sigma} = \\mathbf{D} \\boldsymbol{\\varepsilon}$, with the elasticity matrix $\\mathbf{D}$ given by:\n$$\n\\mathbf{D} = \\frac{E}{1-\\nu^2}\n\\begin{bmatrix}\n1 & \\nu & 0 \\\\\n\\nu & 1 & 0 \\\\\n0 & 0 & \\frac{1-\\nu}{2}\n\\end{bmatrix}\n$$\nwhere $E$ is Young's modulus and $\\nu$ is Poisson's ratio.\n\nThe element stiffness matrix $\\mathbf{K}_e$ of size $6 \\times 6$ is derived from the principle of virtual work and is calculated as:\n$$\n\\mathbf{K}_e = t A_e \\mathbf{B}^\\top \\mathbf{D} \\mathbf{B}\n$$\nwhere $t$ is the element thickness, given as $t=1$.\n\n**2. Global Stiffness Matrix Assembly**\n\nThe system consists of $N=4$ nodes, resulting in $2N = 8$ global degrees of freedom (DOFs), ordered as $\\mathbf{u} = [u_{x0}, u_{y0}, u_{x1}, u_{y1}, u_{x2}, u_{y2}, u_{x3}, u_{y3}]^\\top$. The nodal coordinates are specified as node $0:(0,0)$, node $1:(1,0)$, node $2:(1,1)$, and node $3:(0,1)$. The mesh consists of two elements:\n- Element $1$: nodes $(0, 1, 2)$. Its DOFs map to global DOFs $(0, 1, 2, 3, 4, 5)$.\n- Element $2$: nodes $(0, 2, 3)$. Its DOFs map to global DOFs $(0, 1, 4, 5, 6, 7)$.\n\nFor each element, we compute its $6 \\times 6$ stiffness matrix $\\mathbf{K}_e$. The $8 \\times 8$ global stiffness matrix $\\mathbf{K}$ is assembled by summing the contributions from each element's matrix into the corresponding global DOF locations.\n\n**3. Rigid Body Modes**\n\nFor a structure without boundary conditions (a \"floating\" structure), the global stiffness matrix $\\mathbf{K}$ is singular. Its null space is spanned by the rigid body modes (RBMs). For a $2$D system, there are $3$ RBMs: two translations and one in-plane rotation. These are represented by vectors in the $8$-dimensional space of nodal displacements.\n- Translation in $x$: $\\mathbf{r}_1 = [1, 0, 1, 0, 1, 0, 1, 0]^\\top$.\n- Translation in $y$: $\\mathbf{r}_2 = [0, 1, 0, 1, 0, 1, 0, 1]^\\top$.\n- Rotation about the origin $(0,0)$: The displacement at node $i$ with coordinates $(x_i, y_i)$ is $(u_{xi}, u_{yi}) = (-y_i, x_i)$. This gives $\\mathbf{r}_3 = [0, 0, 0, 1, -1, 1, -1, 0]^\\top$.\n\nA key property is that rigid body motions produce no strain, and thus no internal forces. Mathematically, this means $\\mathbf{K}\\mathbf{r}_j = \\mathbf{0}$ for $j=1, 2, 3$. This is verified by computing the L2-norm $\\|\\mathbf{K}\\mathbf{r}_j\\|_2$, which must be zero up to numerical precision.\n\n**4. System Solvability and Load Vector Analysis**\n\nThe linear system $\\mathbf{K}\\mathbf{u} = \\mathbf{f}$ has a solution if and only if the load vector $\\mathbf{f}$ is in the column space (range) of $\\mathbf{K}$. Since $\\mathbf{K}$ is symmetric, its range is the orthogonal complement of its null space. Therefore, a solution exists if and only if $\\mathbf{f}$ is orthogonal to every vector in the null space, i.e., $\\mathbf{r}_j^\\top \\mathbf{f} = 0$ for $j=1, 2, 3$. Such a load vector is self-equilibrated.\n\nIf this condition holds, the system has infinitely many solutions of the form $\\mathbf{u}_p + \\mathbf{u}_h$, where $\\mathbf{u}_p$ is a particular solution and $\\mathbf{u}_h$ is any linear combination of the RBMs. The Moore-Penrose pseudoinverse $\\mathbf{K}^{+}$ provides the unique minimum-norm solution, $\\mathbf{u} = \\mathbf{K}^{+}\\mathbf{f}$. The residual norm $\\|\\mathbf{K}\\mathbf{u} - \\mathbf{f}\\|_2$ will be zero (within tolerance) if $\\mathbf{f}$ is in the range of $\\mathbf{K}$.\n\nIf $\\mathbf{f}$ is not orthogonal to the RBMs, it has a component in the null space of $\\mathbf{K}^\\top = \\mathbf{K}$, and thus is not in the range of $\\mathbf{K}$. In this case, no exact solution exists. The pseudoinverse still gives the minimum-norm least-squares solution, which minimizes $\\|\\mathbf{K}\\mathbf{u} - \\mathbf{f}\\|_2$, but this minimum norm will be non-zero.\n\nTo detect if $\\mathbf{f}$ excites rigid body modes, we project it onto the subspace spanned by $\\{\\mathbf{r}_1, \\mathbf{r}_2, \\mathbf{r}_3\\}$. First, we form an orthonormal basis for this subspace, for instance, by applying the QR decomposition to the matrix $\\mathbf{R} = [\\mathbf{r}_1, \\mathbf{r}_2, \\mathbf{r}_3]$ to get a matrix $\\mathbf{Q}$ with orthonormal columns. The projection of $\\mathbf{f}$ onto this subspace is $\\mathbf{f}_{proj} = \\mathbf{Q}\\mathbf{Q}^\\top \\mathbf{f}$. The magnitude of this projection is $\\|\\mathbf{f}_{proj}\\|_2 = \\|\\mathbf{Q}^\\top \\mathbf{f}\\|_2$. If this magnitude exceeds a small tolerance $\\varepsilon=10^{-10}$, the load is not properly equilibrated and excites rigid body motion.\n\nThe algorithm proceeds by implementing these steps for each test case provided.\n- For Test Case $\\#1$, the load is self-equilibrated, and the projection magnitude should be near zero.\n- For Test Case $\\#2$, the load is constructed to be orthogonal to the RBMs, so its projection magnitude will also be near zero.\n- For Test Case $\\#3$, the load represents a net downward force, so it is not self-equilibrated. Its projection onto the RBM subspace will be non-zero, and the residual norm of the least-squares solution will also be non-zero.", "answer": "```python\nimport numpy as np\nimport scipy.linalg\n\ndef solve():\n    \"\"\"\n    Solves a set of finite element analysis problems for a 2D elastic solid.\n    \"\"\"\n\n    # --- Nodal and Element Definitions ---\n    nodes = np.array([\n        [0.0, 0.0],  # Node 0\n        [1.0, 0.0],  # Node 1\n        [1.0, 1.0],  # Node 2\n        [0.0, 1.0],  # Node 3\n    ])\n    elements = [\n        [0, 1, 2],\n        [0, 2, 3]\n    ]\n    num_nodes = len(nodes)\n    num_dofs = 2 * num_nodes\n    thickness = 1.0\n\n    # --- Test Case Definitions ---\n    test_cases = [\n        {'E': 2.0, 'nu': 0.25, 'load_type': 'equilibrated'},\n        {'E': 1.0, 'nu': 0.0, 'load_type': 'projected_random'},\n        {'E': 2.0, 'nu': 0.25, 'load_type': 'uniform_downward'},\n    ]\n\n    all_results = []\n    \n    # --- Rigid Body Modes ---\n    r1 = np.tile([1.0, 0.0], num_nodes)  # x-translation\n    r2 = np.tile([0.0, 1.0], num_nodes)  # y-translation\n    r3 = np.zeros(num_dofs)  # rotation about origin\n    for i in range(num_nodes):\n        x, y = nodes[i]\n        r3[2 * i] = -y\n        r3[2 * i + 1] = x\n    \n    R = np.vstack([r1, r2, r3]).T\n    Q_rbm, _ = np.linalg.qr(R) # Orthonormal basis for RBM space\n\n    for case in test_cases:\n        E = case['E']\n        nu = case['nu']\n\n        # --- Assemble Global Stiffness Matrix K ---\n        K = np.zeros((num_dofs, num_dofs))\n        # Constitutive matrix D for plane stress\n        c = E / (1.0 - nu**2)\n        D = c * np.array([\n            [1.0, nu, 0.0],\n            [nu, 1.0, 0.0],\n            [0.0, 0.0, (1.0 - nu) / 2.0]\n        ])\n\n        for el_nodes in elements:\n            # Element coordinates\n            n1_coords, n2_coords, n3_coords = nodes[el_nodes]\n            x1, y1 = n1_coords\n            x2, y2 = n2_coords\n            x3, y3 = n3_coords\n\n            # Element area\n            area = 0.5 * np.linalg.det(np.array([[1, x1, y1], [1, x2, y2], [1, x3, y3]]))\n            \n            # B matrix\n            b1 = y2 - y3\n            b2 = y3 - y1\n            b3 = y1 - y2\n            c1 = x3 - x2\n            c2 = x1 - x3\n            c3 = x2 - x1\n            \n            B = (1.0 / (2.0 * area)) * np.array([\n                [b1, 0, b2, 0, b3, 0],\n                [0, c1, 0, c2, 0, c3],\n                [c1, b1, c2, b2, c3, b3]\n            ])\n\n            # Element stiffness matrix\n            Ke = thickness * area * (B.T @ D @ B)\n\n            # Assemble into global K\n            dofs = np.array([2*n for n in el_nodes for _ in range(2)]) + np.array([0,1]*len(el_nodes))\n            K[np.ix_(dofs, dofs)] += Ke\n\n        # --- Task 3: Verify Rigid Body Modes ---\n        norm_Kr1 = np.linalg.norm(K @ r1)\n        norm_Kr2 = np.linalg.norm(K @ r2)\n        norm_Kr3 = np.linalg.norm(K @ r3)\n        \n        # --- Define Load Vector f ---\n        f = np.zeros(num_dofs)\n        if case['load_type'] == 'equilibrated':\n            f[2 * 1 + 0] = 1.0  # +1 in x-dir at node 1 (1,0)\n            f[2 * 0 + 0] = -1.0 # -1 in x-dir at node 0 (0,0)\n        elif case['load_type'] == 'projected_random':\n            rng = np.random.default_rng(seed=1234) # Deterministic random\n            f_rand = rng.random(num_dofs)\n            # Project f_rand onto orthogonal complement of RBM space\n            f = f_rand - Q_rbm @ (Q_rbm.T @ f_rand)\n        elif case['load_type'] == 'uniform_downward':\n            for i in range(num_nodes):\n                f[2 * i + 1] = -1.0\n\n        # --- Task 4: Compute Minimum-Norm Solution and Residual ---\n        K_pinv = scipy.linalg.pinv(K)\n        u = K_pinv @ f\n        residual_norm = np.linalg.norm(K @ u - f)\n\n        # --- Task 5: Detect Load Projection on RBM Space ---\n        proj_mag = np.linalg.norm(Q_rbm.T @ f)\n        detection_flag = proj_mag > 1e-10\n        \n        # --- Collect Results for This Case ---\n        case_results = [\n            norm_Kr1,\n            norm_Kr2,\n            norm_Kr3,\n            residual_norm,\n            proj_mag,\n            str(detection_flag).lower()\n        ]\n        all_results.extend(case_results)\n\n    # --- Final Print ---\n    # Ensure raw float values are printed without scientific notation for small numbers\n    formatted_results = [f\"{x:.15e}\" if isinstance(x, float) else x for x in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3588944"}, {"introduction": "After verifying the fundamental algebraic properties of the stiffness matrix, the next step is to test the complete force balance formulation in a physically meaningful static equilibrium. In geophysics, the state of hydrostatic balance, where the downward pull of gravity is perfectly counteracted by an upward pressure-gradient force, serves as a fundamental benchmark. This practice [@problem_id:3588957] guides you through the assembly of all force vectors involved: the consistent gravity load $\\mathbf{f}_g$, the internal forces from a hydrostatic initial stress $\\mathbf{f}_{\\sigma_0}$, and the consistent boundary tractions $\\mathbf{f}_t$. Confirming that these forces sum to zero for a stratified earth model is a comprehensive test of your load vector implementation, especially the numerical integration over complex, layered media.", "problem": "Consider a two-dimensional vertical rectangular domain $\\Omega = [0,W] \\times [0,H]$ representing a geophysical column in plane strain with out-of-plane unit thickness. Let the vertical coordinate be $z$ measured positive downward, with the top boundary at $z=0$ and the bottom boundary at $z=H$. The material is linear elastic, homogeneous, and isotropic with Young's modulus $E$ and Poisson's ratio $\\nu$. The gravitational acceleration is $\\mathbf{g} = (0,g)$, with $g$ strictly positive and expressed in $\\mathrm{m/s^2}$. The mass density is layered, depending only on $z$, as a piecewise constant function $\\rho(z)$ defined by horizontal layers.\n\nAssume small-strain kinematics, Cauchy stress symmetry, and static equilibrium (no inertia). Starting from the linear momentum balance and the weak form of equilibrium for an arbitrary admissible virtual displacement field, derive the finite element expressions needed to:\n- Form the consistent body-force element load vector associated with gravity for a bilinear quadrilateral (four-node) element, using standard bilinear shape functions and exact area integration via suitable Gauss quadrature.\n- Form the element internal nodal force vector associated with an imposed initial stress field. The initial stress field is hydrostatic (isotropic), $\\boldsymbol{\\sigma}_0(z) = -p(z)\\,\\mathbf{I}$, with pressure $p(z)$ satisfying $dp/dz = \\rho(z)\\,g$ and $p(H)=0$. Explicitly construct $p(z)$ from the given layered $\\rho(z)$.\n- Include the boundary traction contributions consistent with the hydrostatic initial stress, i.e., $\\mathbf{t}(z) = \\boldsymbol{\\sigma}_0(z)\\,\\mathbf{n}$ on each boundary segment with outward unit normal $\\mathbf{n}$.\n\nDefine the finite element mesh by partitioning $\\Omega$ into $N_x \\times N_z$ axis-aligned bilinear quadrilateral elements, each with the standard four-node parametrization in the parent coordinates $(\\xi,\\eta)\\in[-1,1]^2$. Use plane strain with unit thickness. Assemble the global vectors:\n- The gravity load vector $\\mathbf{f}_g$ by integrating the body force $\\rho(z)\\,\\mathbf{g}$ against the shape functions over the domain.\n- The initial-stress internal force vector $\\mathbf{f}_{\\sigma_0}$ by integrating the strain-displacement matrix transpose times $\\boldsymbol{\\sigma}_0$ over the domain.\n- The boundary traction vector $\\mathbf{f}_t$ by integrating the hydrostatic tractions along all domain boundaries.\n\nUsing the assembled vectors, test hydrostatic balance at zero displacement $\\mathbf{u}_0 = \\mathbf{0}$. In the consistent weak form, equilibrium at $\\mathbf{u}_0=\\mathbf{0}$ requires the global residual\n$$\n\\mathbf{r}(\\mathbf{u}_0) = \\mathbf{f}_{\\sigma_0} - \\mathbf{f}_g - \\mathbf{f}_t\n$$\nto be the zero vector if the hydrostatic initial stress and gravity are in exact balance. Compute the infinity norm (maximum absolute component) of $\\mathbf{r}(\\mathbf{u}_0)$ for each test case.\n\nYou must implement the complete calculation with the following requirements:\n- Use exact mass density layering in the integrals. If any element spans across a layer interface, subdivide its vertical integration into subregions aligned with the density layers and apply Gauss quadrature in each subregion.\n- Use bilinear quadrilateral elements and two-point Gauss quadrature in each parametric direction for area integrals, and two-point Gauss quadrature for the one-dimensional edge integrals.\n- Adopt plane strain with out-of-plane unit thickness.\n- Express gravitational acceleration in $\\mathrm{m/s^2}$, elastic moduli in $\\mathrm{Pa}$, dimensions in $\\mathrm{m}$, densities in $\\mathrm{kg/m^3}$, and forces in $\\mathrm{N}$. Report the residual norm in $\\mathrm{N}$.\n\nTest Suite:\nFor each of the three parameter sets below, assemble $\\mathbf{f}_g$, $\\mathbf{f}_{\\sigma_0}$, and $\\mathbf{f}_t$, compute $\\|\\mathbf{r}(\\mathbf{u}_0)\\|_\\infty$, and output the three results as a single line in the specified final format.\n\n- Case A (uniform layer, happy path):\n  - $W = 100\\,\\mathrm{m}$, $H = 1000\\,\\mathrm{m}$, $N_x = 2$, $N_z = 2$.\n  - $E = 3.0 \\times 10^{10}\\,\\mathrm{Pa}$, $\\nu = 0.25$, $g = 9.81\\,\\mathrm{m/s^2}$.\n  - Layers: one layer $[0,1000]$ with $\\rho = 2200\\,\\mathrm{kg/m^3}$.\n\n- Case B (two layers, non-aligned element interfaces):\n  - $W = 80\\,\\mathrm{m}$, $H = 900\\,\\mathrm{m}$, $N_x = 3$, $N_z = 3$.\n  - $E = 2.5 \\times 10^{10}\\,\\mathrm{Pa}$, $\\nu = 0.30$, $g = 9.81\\,\\mathrm{m/s^2}$.\n  - Layers: $[0,500]$ with $\\rho = 2000\\,\\mathrm{kg/m^3}$ and $[500,900]$ with $\\rho = 2500\\,\\mathrm{kg/m^3}$.\n\n- Case C (thin low-density layer, edge case):\n  - $W = 120\\,\\mathrm{m}$, $H = 1000\\,\\mathrm{m}$, $N_x = 4$, $N_z = 5$.\n  - $E = 3.5 \\times 10^{10}\\,\\mathrm{Pa}$, $\\nu = 0.20$, $g = 9.81\\,\\mathrm{m/s^2}$.\n  - Layers: $[0,300]$ with $\\rho = 1800\\,\\mathrm{kg/m^3}$, $[300,305]$ with $\\rho = 100\\,\\mathrm{kg/m^3}$, $[305,1000]$ with $\\rho = 2600\\,\\mathrm{kg/m^3}$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the three residual norms rounded by the default string conversion, as a comma-separated list enclosed in square brackets (e.g., \"[resultA,resultB,resultC]\"), where each result is a float representing $\\|\\mathbf{r}(\\mathbf{u}_0)\\|_\\infty$ in $\\mathrm{N}$ for the corresponding case.", "solution": "The problem requires the validation of hydrostatic balance for a two-dimensional geophysical column using the finite element method. The state of equilibrium at zero displacement is verified by computing the residual force vector $\\mathbf{r}(\\mathbf{u}_0)$, which must be a zero vector for an exact solution. The problem specifies a particular numerical implementation using bilinear quadrilateral elements and Gauss quadrature, for which we expect the residual to be small but non-zero due to approximation errors.\n\nThe residual vector is defined as $\\mathbf{r}(\\mathbf{u}_0) = \\mathbf{f}_{\\sigma_0} - \\mathbf{f}_g - \\mathbf{f}_t$, where $\\mathbf{f}_g$ is the gravity load vector, $\\mathbf{f}_{\\sigma_0}$ is the internal force vector from the initial hydrostatic stress, and $\\mathbf{f}_t$ is the boundary traction vector consistent with the initial stress. We will formulate and compute each of these vectors.\n\n### 1. Theoretical Framework\n\n**Discretization**: The domain $\\Omega = [0,W] \\times [0,H]$ is discretized into a grid of $N_x \\times N_z$ bilinear quadrilateral elements. For an element $e$, the geometry and displacement field are interpolated from nodal values using an isoparametric mapping from a parent element $(\\xi, \\eta) \\in [-1,1]^2$. We adopt a standard counter-clockwise node numbering (1-2-3-4) for the physical element, starting from the top-left corner, and map it to the parent element's standard node order (bottom-left, bottom-right, top-right, top-left), which gives a positive Jacobian determinant $\\det(\\mathbf{J}) = w_e h_e / 4$, where $w_e$ and $h_e$ are the element width and height.\n\n**Hydrostatic Pressure**: The initial stress is hydrostatic, $\\boldsymbol{\\sigma}_0(z) = -p(z)\\mathbf{I}$, where $p(z)$ is the pressure. Given the condition $dp/dz = \\rho(z)g$ and $p(H)=0$, the pressure at any depth $z$ is the weight of the material column below it:\n$$\np(z) = \\int_z^H \\rho(s) g \\, ds\n$$\nSince the density $\\rho(z)$ is piecewise constant, $p(z)$ is a continuous, piecewise linear function of $z$.\n\n**Weak Form of Equilibrium**: The principle of virtual work, evaluated at zero displacement ($\\mathbf{u}=\\mathbf{0}$, thus $\\boldsymbol{\\sigma}=\\boldsymbol{\\sigma}_0$), states that the internal forces must balance the external forces:\n$$\n\\int_{\\Omega} \\mathbf{B}^T \\boldsymbol{\\sigma}_0 \\, d\\Omega = \\int_{\\Omega} \\mathbf{N}^T \\mathbf{b} \\, d\\Omega + \\int_{\\partial\\Omega} \\mathbf{N}^T \\mathbf{t} \\, d\\Gamma\n$$\nwhere $\\mathbf{N}$ is the matrix of shape functions, $\\mathbf{B}$ is the strain-displacement matrix, $\\mathbf{b}=[0, \\rho(z)g]^T$ is the body force, and $\\mathbf{t}$ are the boundary tractions. The three terms correspond to $\\mathbf{f}_{\\sigma_0}$, $\\mathbf{f}_g$, and $\\mathbf{f}_t$, respectively. While these terms are equal in the continuous sense with exact integration, their numerical evaluation with finite-precision quadrature will introduce discrepancies.\n\n### 2. Element Force Vector Formulation\n\nWe now formulate the element-level vectors for assembly. All integrals are performed using the specified quadrature rules. The key challenge lies in handling elements that cross boundaries between density layers. For such elements, the vertical integration over $\\eta \\in [-1, 1]$ is split into sub-intervals, and Gauss quadrature is applied to each.\n\n**A. Gravity Load Vector ($\\mathbf{f}_g^e$)**:\nThe $z$-component of the gravity force on local node $i$ of an element is:\n$$\nf_{giz}^e = \\int_{\\Omega_e} N_i(x,z) \\rho(z) g \\, d\\Omega = g \\int_{-1}^1\\int_{-1}^1 N_i(\\xi, \\eta) \\rho(z(\\eta)) \\det(\\mathbf{J}) \\, d\\xi d\\eta\n$$\nFor a bilinear element, integrating analytically with respect to $\\xi$ simplifies this to:\n$$\nf_{giz}^e = g \\frac{w_e h_e}{8} \\int_{-1}^1 (1 + \\eta_i \\eta) \\rho(z(\\eta)) \\, d\\eta\n$$\nwhere $(\\xi_i, \\eta_i)$ are the parent coordinates of node $i$. The remaining 1D integral is evaluated numerically.\n\n**B. Initial Stress Force Vector ($\\mathbf{f}_{\\sigma_0}^e$)**:\nThe internal force from initial stress on node $i$ is:\n$$\n\\mathbf{f}_{\\sigma_0,i}^e = \\int_{\\Omega_e} \\mathbf{B}_i^T \\boldsymbol{\\sigma}_0(z) \\, d\\Omega = \\int_{\\Omega_e} \\begin{bmatrix} -p(z) \\frac{\\partial N_i}{\\partial x} \\\\ -p(z) \\frac{\\partial N_i}{\\partial z} \\end{bmatrix} d\\Omega\n$$\nUsing the isoparametric mapping and integrating analytically over $\\xi$ yields:\n$$\nf_{\\sigma_0,ix}^e = -\\frac{\\xi_i h_e}{4} \\int_{-1}^1 (1 + \\eta_i \\eta) p(z(\\eta)) \\, d\\eta\n$$\n$$\nf_{\\sigma_0,iz}^e = -\\frac{\\eta_i w_e}{4} \\int_{-1}^1 p(z(\\eta)) \\, d\\eta\n$$\nThese 1D integrals are computed numerically. The integrands are products of linear ($N_i$) and piecewise linear ($p(z)$) functions, resulting in piecewise quadratics, for which 2-point Gauss quadrature is not exact.\n\n**C. Boundary Traction Vector ($\\mathbf{f}_t^e$)**:\nTractions $\\mathbf{t} = \\boldsymbol{\\sigma}_0\\mathbf{n} = -p(z)\\mathbf{n}$ are applied to the domain boundaries.\n-   **Top boundary ($z=0$):** $\\mathbf{n}=(0,-1)$, so $\\mathbf{t}=(0, p(0))$. This contributes to the $z$-component of nodal forces.\n-   **Left boundary ($x=0$):** $\\mathbf{n}=(-1,0)$, so $\\mathbf{t}=(p(z), 0)$. This contributes to the $x$-component.\n-   **Right boundary ($x=W$):** $\\mathbf{n}=(1,0)$, so $\\mathbf{t}=(-p(z), 0)$. This also contributes to the $x$-component.\n-   **Bottom boundary ($z=H$):** $p(H)=0$, so $\\mathbf{t}=\\mathbf{0}$.\nFor an element edge on a vertical boundary, the force on a node $j$ on that edge is computed via a 1D integral, e.g., on the left boundary:\n$$\nf_{tx,j}^e = \\int_{z_{edge,1}}^{z_{edge,2}} N_j^{\\text{1D}}(z) p(z) \\, dz = \\frac{h_e}{2} \\int_{-1}^1 N_j^{\\text{1D}}(\\eta) p(z(\\eta)) \\, d\\eta\n$$\nThis 1D integral, involving a piecewise quadratic integrand, is also evaluated with 2-point Gauss quadrature (split at layer boundaries), which introduces numerical error.\n\n### 3. Implementation Details\n\nThe implementation iterates through each element, computes the three element-level force vectors ($\\mathbf{f}_g^e, \\mathbf{f}_{\\sigma_0}^e, \\mathbf{f}_t^e$), and assembles them into global vectors. The core of the computation is a robust 1D integration function that handles layered media by subdividing the integration domain and applying 2-point Gauss quadrature on each sub-interval. Finally, the global residual $\\mathbf{r}$ is calculated, and its infinity norm $\\|\\mathbf{r}\\|_\\infty$ is reported. The non-zero result quantifies the inconsistency introduced by approximating integrals of quadratic or higher-order polynomials with 2-point Gauss quadrature.", "answer": "```python\nimport numpy as np\n\n# Global constants for 2-point Gauss quadrature\nGAUSS_POINTS = np.array([-1.0 / np.sqrt(3.0), 1.0 / np.sqrt(3.0)])\nGAUSS_WEIGHTS = np.array([1.0, 1.0])\n\ndef solve():\n    \"\"\"\n    Main driver function to process all test cases defined in the problem.\n    \"\"\"\n    test_cases = [\n        # Case A: Uniform layer, happy path\n        {\n            \"W\": 100.0, \"H\": 1000.0, \"Nx\": 2, \"Nz\": 2, \"g\": 9.81,\n            \"layers\": [(0.0, 1000.0, 2200.0)],\n        },\n        # Case B: Two layers, non-aligned element interfaces\n        {\n            \"W\": 80.0, \"H\": 900.0, \"Nx\": 3, \"Nz\": 3, \"g\": 9.81,\n            \"layers\": [(0.0, 500.0, 2000.0), (500.0, 900.0, 2500.0)],\n        },\n        # Case C: Thin low-density layer, edge case\n        {\n            \"W\": 120.0, \"H\": 1000.0, \"Nx\": 4, \"Nz\": 5, \"g\": 9.81,\n            \"layers\": [\n                (0.0, 300.0, 1800.0),\n                (300.0, 305.0, 100.0),\n                (305.0, 1000.0, 2600.0),\n            ],\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        residual_norm = compute_residual(**case)\n        results.append(residual_norm)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef create_pressure_function(H, g, layers):\n    \"\"\"\n    Creates a callable function p(z) for the hydrostatic pressure.\n    The pressure is pre-calculated at layer interfaces for efficiency.\n    \"\"\"\n    p_at_interface = {H: 0.0}\n    # Integrate from bottom to top\n    for i in range(len(layers) - 1, -1, -1):\n        z_start, z_end, rho = layers[i]\n        layer_overburden = rho * g * (z_end - z_start)\n        p_at_interface[z_start] = p_at_interface.get(z_end, 0.0) + layer_overburden\n\n    def p(z):\n        if z >= H: return 0.0\n        # Find the layer containing z\n        for z_start, z_end, rho in layers:\n            if z_start = z  z_end:\n                # Pressure is from layers below plus contribution from within the layer\n                return p_at_interface.get(z_end, 0.0) + rho * g * (z_end - z)\n        return 0.0  # Should be reached only for z=H\n\n    return p\n\ndef integrate_1d_layered(integrand_func, z_min, z_max, layers):\n    \"\"\"\n    Numerically integrates a 1D function over [z_min, z_max], splitting at layer boundaries.\n    The integration is transformed to parent coordinates eta in [-1, 1].\n    \"\"\"\n    h_e = z_max - z_min\n    z_c = z_min + h_e / 2.0\n    \n    eta_splits = [-1.0, 1.0]\n    for z_start, _, _ in layers:\n        if z_min  z_start  z_max:\n            eta_split = (z_start - z_c) / (h_e / 2.0)\n            eta_splits.append(eta_split)\n    eta_splits = sorted(list(set(eta_splits)))\n\n    total_integral = 0.0\n    for i in range(len(eta_splits) - 1):\n        eta_a, eta_b = eta_splits[i], eta_splits[i+1]\n        \n        # Map [eta_a, eta_b] to [-1, 1] for Gauss quadrature\n        transform = lambda zeta: 0.5 * (eta_b - eta_a) * zeta + 0.5 * (eta_a + eta_b)\n        jacobian_1d = 0.5 * (eta_b - eta_a)\n        \n        integral_piece = 0.0\n        for k in range(len(GAUSS_POINTS)):\n            eta_val = transform(GAUSS_POINTS[k])\n            z_val = z_c + (h_e / 2.0) * eta_val\n            integrand_val = integrand_func(eta_val, z_val)\n            integral_piece += GAUSS_WEIGHTS[k] * integrand_val\n        \n        total_integral += jacobian_1d * integral_piece\n        \n    return total_integral\n\ndef compute_element_vectors(x_min, z_min, w_e, h_e, g, layers, p_func, H, W, ix, iz, Nx, Nz):\n    \"\"\"\n    Computes and returns element-level force vectors fg, f_sigma0, and f_t.\n    \"\"\"\n    fg_e_z = np.zeros(4)\n    f_sigma0_e = np.zeros(8)\n    ft_e = np.zeros(8)\n\n    # Parent coords for local nodes 0,1,2,3: (BL, BR, TR, TL) is not used.\n    # We use a mapping from physical to parent that is consistent for all nodes.\n    # z = z_c + eta * h_e/2. z_min maps to eta=-1. z_max maps to eta=1.\n    # x = x_c + xi * w_e/2. x_min maps to xi=-1. x_max maps to xi=1.\n    # My local nodes (0,1,2,3) correspond to (TL, TR, BR, BL) of physical element.\n    # TL: (x_min, z_min) -> (xi=-1, eta=-1)\n    # TR: (x_max, z_min) -> (xi=1, eta=-1)\n    # BR: (x_max, z_max) -> (xi=1, eta=1)\n    # BL: (x_min, z_max) -> (xi=-1, eta=1)\n    xi_eta_nodes = np.array([[-1, -1], [1, -1], [1, 1], [-1, 1]]) # Local node coords\n\n    def get_rho(z):\n        if z >= H: return layers[-1][2]\n        for z_start, z_end, rho_val in layers:\n            if z_start = z = z_end:\n                 return rho_val\n        raise ValueError(f\"Density not found for z={z}\")\n\n    # ===== 1. Gravity Load Vector f_g (z-components only) =====\n    for i in range(4):\n        _, eta_i = xi_eta_nodes[i]\n        def integrand_fg(eta, z): return g * get_rho(z) * (1.0 + eta_i * eta)\n        integral_val = integrate_1d_layered(integrand_fg, z_min, z_min + h_e, layers)\n        fg_e_z[i] = (w_e * h_e / 8.0) * integral_val\n\n    # ===== 2. Initial Stress Vector f_sigma0 =====\n    for i in range(4):\n        xi_i, eta_i = xi_eta_nodes[i]\n        # X-component\n        def integrand_x(eta, z): return (1.0 + eta_i * eta) * p_func(z)\n        integral_x = integrate_1d_layered(integrand_x, z_min, z_min + h_e, layers)\n        f_sigma0_e[2 * i] = - (xi_i * h_e / 4.0) * integral_x\n        \n        # Z-component\n        def integrand_z(eta, z): return p_func(z)\n        integral_z = integrate_1d_layered(integrand_z, z_min, z_min + h_e, layers)\n        f_sigma0_e[2 * i + 1] = - (eta_i * w_e / 4.0) * integral_z\n\n    # ===== 3. Boundary Traction Vector f_t =====\n    if iz == 0:  # Top boundary (z=0)\n        p0 = p_func(0.0)\n        # nodes 0 (TL) and 1 (TR) are on top edge (eta=-1)\n        ft_e[2*0 + 1] += p0 * w_e / 2.0\n        ft_e[2*1 + 1] += p0 * w_e / 2.0\n\n    if ix == 0:  # Left boundary (x=0)\n        # nodes 0 (TL) and 3 (BL) are on left edge (xi=-1)\n        def integrand_l(eta, z): return p_func(z)\n        integral_val = (h_e/2.0) * integrate_1d_layered(integrand_l, z_min, z_min+h_e, layers)\n        # 1D shape functions for edge xi=-1 are N_TL = 0.5(1-eta), N_BL = 0.5(1+eta)\n        ft_e[2*0] += 0.5 * integral_val # Node 0 (TL) x-comp\n        ft_e[2*3] += 0.5 * integral_val # Node 3 (BL) x-comp\n        \n    if ix == Nx - 1:  # Right boundary (x=W)\n        # nodes 1 (TR) and 2 (BR) are on right edge (xi=1)\n        def integrand_r(eta, z): return -p_func(z)\n        integral_val = (h_e/2.0) * integrate_1d_layered(integrand_r, z_min, z_min+h_e, layers)\n        # 1D shape functions for edge xi=1 are N_TR = 0.5(1-eta), N_BR = 0.5(1+eta)\n        ft_e[2*1] += 0.5 * integral_val # Node 1 (TR) x-comp\n        ft_e[2*2] += 0.5 * integral_val # Node 2 (BR) x-comp\n\n    return fg_e_z, f_sigma0_e, ft_e\n\ndef compute_residual(W, H, Nx, Nz, g, layers):\n    \"\"\"\n    Assembles global vectors and computes the infinity norm of the residual.\n    \"\"\"\n    dx, dz = W / Nx, H / Nz\n    num_nodes_x, num_nodes_z = Nx + 1, Nz + 1\n    num_dofs = 2 * num_nodes_x * num_nodes_z\n\n    f_g, f_sigma0, f_t = np.zeros(num_dofs), np.zeros(num_dofs), np.zeros(num_dofs)\n    p_func = create_pressure_function(H, g, layers)\n\n    for iz in range(Nz):\n        for ix in range(Nx):\n            x_min, z_min = ix * dx, iz * dz\n            \n            fg_e_z, f_sigma0_e, ft_e = compute_element_vectors(\n                x_min, z_min, dx, dz, g, layers, p_func, H, W, ix, iz, Nx, Nz)\n            \n            # Node indices (top-left, top-right, bottom-right, bottom-left) for element (ix, iz)\n            node_indices = [\n                iz * num_nodes_x + ix,         # 0: TL\n                iz * num_nodes_x + ix + 1,     # 1: TR\n                (iz + 1) * num_nodes_x + ix + 1, # 2: BR\n                (iz + 1) * num_nodes_x + ix,     # 3: BL\n            ]\n            \n            # Assemble\n            for i in range(4): # Loop over local nodes\n                glob_idx = node_indices[i]\n                dof_x, dof_z = 2 * glob_idx, 2 * glob_idx + 1\n\n                f_g[dof_z] += fg_e_z[i]\n                \n                f_sigma0[dof_x] += f_sigma0_e[2 * i]\n                f_sigma0[dof_z] += f_sigma0_e[2 * i + 1]\n                \n                f_t[dof_x] += ft_e[2 * i]\n                f_t[dof_z] += ft_e[2 * i + 1]\n\n    residual = f_sigma0 - f_g - f_t\n    return np.max(np.abs(residual))\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3588957"}, {"introduction": "Standard finite element formulations can become overly stiff, or \"lock,\" when modeling the behavior of nearly incompressible materials, a common situation in geodynamic problems like mantle convection. A widely used remedy is reduced integration, but this can introduce non-physical, zero-energy deformations known as \"hourglass modes,\" which compromise solution accuracy. This advanced practice [@problem_id:3588945] delves into this issue, challenging you to implement a reduced-integration scheme and then design a stabilization term to suppress the resulting spurious modes. By analyzing the eigenvalue spectrum of the resulting matrices, you will gain direct insight into the effects of locking and stabilization, mastering a sophisticated technique required for high-fidelity geophysical modeling.", "problem": "Consider two-dimensional small-strain, linear elasticity under plane strain for a single isoparametric bilinear quadrilateral element with four nodes. The displacement field is interpolated by bilinear shape functions, and the material is nearly incompressible, characterized by a Poisson ratio close to $0.5$. The fundamental starting point is the principle of virtual work and the associated strain-displacement and constitutive relations. You must reason from these foundations to formulate the element stiffness and load vector, examine the effect of reduced integration on the element stiffness, and design a divergence-based stabilization that preserves load consistency.\n\nThe fundamental base to use is as follows:\n- The principle of virtual work: for any admissible virtual displacement field, the internal virtual work equals the external virtual work.\n- The small-strain kinematics: the infinitesimal strain tensor is the symmetric gradient of displacement.\n- The linear elastic constitutive law under plane strain.\n- The isoparametric bilinear interpolation and standard Gaussian quadrature for numerical integration.\n\nWork in the following setting:\n- Geometry: a single bilinear quadrilateral element with nodes at physical coordinates $(x,y)$ given by $\\{(0,0),(1,0),(1,1),(0,1)\\}$ in meters. Use unit thickness in the out-of-plane direction. The element domain is denoted by $\\Omega_e$ and its area is $|\\Omega_e|$.\n- Displacements: nodal displacement vector $d_e \\in \\mathbb{R}^8$ ordered as $[u_{1x},u_{1y},u_{2x},u_{2y},u_{3x},u_{3y},u_{4x},u_{4y}]^T$ in meters.\n- Material: Young’s modulus $E$ in Pascals, Poisson’s ratio $\\nu$ (dimensionless), with plane strain constitutive matrix implied by these parameters.\n- Body force: constant vector $b = (b_x,b_y)$ in Newtons per cubic meter.\n- Quadrature: use reduced integration with a single Gauss point at the element center for the reduced integration stiffness, and standard $2 \\times 2$ Gauss integration for full integration and for the stabilization term.\n- Stabilization design parameter: a positive scalar $\\tau$ chosen in proportion to the shear modulus to regularize zero-energy modes without polluting the incompressible limit.\n\nTasks to complete:\n1) Starting from the principle of virtual work and small-strain kinematics, derive the element’s reduced-integration stiffness matrix $K_e^{\\text{red}}$ obtained by evaluating the bilinear form at the single Gauss point at the element center. Ensure to construct the strain-displacement matrix $B(\\xi,\\eta)$ at the Gauss point using the isoparametric mapping and the bilinear shape functions, and the plane strain constitutive matrix $C(E,\\nu)$.\n2) Using the same foundational starting point, derive a divergence-based stabilization matrix of the form\n$$\nK_{\\text{stab}} = \\tau \\int_{\\Omega_e} H^T H \\, d\\Omega,\n$$\nwhere $H$ maps nodal displacements to the displacement divergence, that is, for nodal displacements $d_e$ the divergence of the interpolated displacement is $(\\nabla \\cdot u_h) = H d_e$. Express $H$ at a quadrature point in terms of spatial derivatives of the bilinear shape functions, and evaluate $K_{\\text{stab}}$ using standard $2 \\times 2$ Gauss integration. Specify a choice of $\\tau$ in terms of fundamental material and geometric scales that is dimensionally consistent and does not degrade the nearly incompressible limit.\n3) From the principle of virtual work’s external work term with constant body force, derive the consistent nodal body force vector\n$$\nf_e = \\int_{\\Omega_e} N^T b \\, d\\Omega,\n$$\nwhere $N$ is the matrix of bilinear shape functions mapping nodal displacements to the field. Evaluate this using standard $2 \\times 2$ Gauss integration and verify analytically what this integral must equal for a constant $b$ on this element with unit thickness and area $|\\Omega_e|$.\n4) Explain, from first principles, why adding $K_{\\text{stab}}$ does not require any modification of the consistent body force vector to preserve load consistency for constant body forces, and why the stabilization should not introduce spurious work for rigid body motions.\n5) Numerically investigate the effect of reduced integration and the proposed stabilization on the stiffness matrix’s spectrum, including the dimension of its nullspace and its conditioning once the rigid body modes are removed.\n\nImplement a program that carries out the above for the following test suite. Use the specified physical units: meters for length, Pascals for Young’s modulus, and Newtons per cubic meter for body force. Angles are not involved. When a numerical tolerance is needed for deciding if an eigenvalue is effectively zero, use a relative threshold where values below $10^{-8}$ times the largest magnitude eigenvalue are regarded as zero.\n\nParameter values and test suite:\n- Element node coordinates: $(0,0)$, $(1,0)$, $(1,1)$, $(0,1)$ in meters. Unit thickness.\n- Material parameters: $E = 10^6$ Pascals, $\\nu = 0.4999$ (dimensionless).\n- Stabilization scaling: choose $\\tau = \\beta \\, \\mu$, where $\\mu$ is the shear modulus implied by $(E,\\nu)$ under plane strain. Use $\\beta = 1/3$ (dimensionless).\n- Body force for load consistency check: $b = (3.2,-1.7)$ Newtons per cubic meter.\n\nYour program must:\n- Assemble and store the following element matrices:\n  - $K_e^{\\text{red}}$ using one-point reduced integration at the element center.\n  - $K_e^{\\text{full}}$ using standard $2 \\times 2$ Gauss integration.\n  - $K_{\\text{stab}}$ using standard $2 \\times 2$ Gauss integration with the chosen $\\tau$.\n  - $K_e^{\\text{tot}} = K_e^{\\text{red}} + K_{\\text{stab}}$.\n- Compute the consistent body force vector $f_e$ using $2 \\times 2$ Gauss integration, and compare it to the analytic value implied by a constant $b$ over $\\Omega_e$.\n- Compute the following quantitative outputs:\n  1) An integer equal to the number of eigenvalues of $K_e^{\\text{red}}$ that are below the effective-zero threshold (the nullity).\n  2) An integer equal to the number of eigenvalues of $K_e^{\\text{tot}}$ that are below the effective-zero threshold.\n  3) A float equal to the maximum absolute component-wise difference between the numerically integrated $f_e$ and the analytic $f_e$ for the constant body force $b$.\n  4) A boolean indicating whether the sum of the nodal force components in $f_e$ equals the total body force over the element, that is, whether $\\sum_i (f_{e,ix}, f_{e,iy})$ equals $(b_x |\\Omega_e|, b_y |\\Omega_e|)$ within the same numerical tolerance.\n  5) A float equal to $\\log_{10}$ of the condition number of $K_e^{\\text{full}}$ restricted to its positive spectrum (largest positive eigenvalue divided by the smallest positive eigenvalue).\n  6) A float equal to $\\log_{10}$ of the condition number of $K_e^{\\text{tot}}$ restricted to its positive spectrum.\n\nFinal output format:\n- Your program should produce a single line of output containing the results aggregated as a comma-separated list enclosed in square brackets, in the order given above. For example, produce an output of the form $[r_1,r_2,r_3,r_4,r_5,r_6]$ where $r_1$ and $r_2$ are integers, $r_3$, $r_5$, and $r_6$ are floats, and $r_4$ is a boolean.", "solution": "The problem requires a comprehensive derivation and numerical implementation for a single 4-node quadrilateral finite element under plane strain, focusing on the challenges of near-incompressibility. I will proceed by first establishing the theoretical framework and then detailing the specific derivations and analyses requested.\n\n### 1. Theoretical Foundation: Principle of Virtual Work and Finite Element Discretization\n\nThe foundation of the finite element method for solid mechanics is the principle of virtual work. For a body occupying a domain $V$ with boundary $\\Gamma$, in equilibrium under body forces $b$ and surface tractions $\\bar{t}$, the principle states that the internal virtual work equals the external virtual work for any kinematically admissible virtual displacement field $\\delta u$:\n$$\n\\delta W_{\\text{int}} = \\delta W_{\\text{ext}}\n$$\n$$\n\\int_V \\delta\\varepsilon^T \\sigma \\, dV = \\int_V \\delta u^T b \\, dV + \\int_{\\Gamma_t} \\delta u^T \\bar{t} \\, d\\Gamma\n$$\nHere, $\\sigma$ is the Cauchy stress tensor and $\\varepsilon$ is the infinitesimal strain tensor, both in Voigt notation. The virtual strain is $\\delta\\varepsilon$. For small-strain linear elasticity, the constitutive relation is $\\sigma = C \\varepsilon$, and the strain-displacement relation is $\\varepsilon = \\mathcal{L}u$, where $\\mathcal{L}$ is a differential operator.\n\nIn the finite element method, the domain is discretized into elements. Within an element $\\Omega_e$ (with volume $V_e$), the displacement field $u$ and its variation $\\delta u$ are interpolated from nodal values, $d_e$ and $\\delta d_e$, using a matrix of shape functions $N$:\n$$\nu(x) = N(x) d_e \\quad \\text{and} \\quad \\delta u(x) = N(x) \\delta d_e\n$$\nThe strain is then related to nodal displacements via the strain-displacement matrix $B$, which contains spatial derivatives of the shape functions:\n$$\n\\varepsilon(x) = B(x) d_e \\quad \\text{and} \\quad \\delta\\varepsilon(x) = B(x) \\delta d_e\n$$\nSubstituting these into the virtual work equation for a single element (neglecting surface tractions for this problem) yields:\n$$\n\\int_{V_e} (B \\delta d_e)^T C (B d_e) \\, dV = \\int_{V_e} (N \\delta d_e)^T b \\, dV\n$$\nSince $\\delta d_e$ is arbitrary, this leads to the element system of equations $K_e d_e = f_e$, where the element stiffness matrix $K_e$ and consistent nodal force vector $f_e$ are:\n$$\nK_e = \\int_{V_e} B^T C B \\, dV \\quad \\text{and} \\quad f_e = \\int_{V_e} N^T b \\, dV\n$$\nFor a two-dimensional problem with unit thickness $t=1$, the volume integral $dV$ becomes an area integral $d\\Omega$. The integration is performed numerically over a reference element domain $(\\xi, \\eta) \\in [-1, 1]^2$ using Gaussian quadrature:\n$$\nK_e = \\int_{-1}^1 \\int_{-1}^1 B(\\xi, \\eta)^T C B(\\xi, \\eta) \\det(J(\\xi, \\eta)) \\, t \\, d\\xi d\\eta\n$$\nwhere $J$ is the Jacobian of the isoparametric mapping from reference to physical coordinates.\n\n### 2. Isoparametric Bilinear Element\n\nThe element has nodes at $\\{(0,0), (1,0), (1,1), (0,1)\\}$. The mapping from reference coordinates $(\\xi, \\eta)$ to physical coordinates $(x,y)$ is $x(\\xi, \\eta) = \\sum_i N_i(\\xi, \\eta) x_i$ and $y(\\xi, \\eta) = \\sum_i N_i(\\xi, \\eta) y_i$. For the given nodes, this results in the affine mapping $x = \\frac{1}{2}(1+\\xi)$ and $y = \\frac{1}{2}(1+\\eta)$. The Jacobian matrix of this mapping is constant:\n$$\nJ = \\begin{pmatrix} \\partial x / \\partial \\xi  \\partial y / \\partial \\xi \\\\ \\partial x / \\partial \\eta  \\partial y / \\partial \\eta \\end{pmatrix} = \\begin{pmatrix} 1/2  0 \\\\ 0  1/2 \\end{pmatrix}\n$$\nIts determinant is $\\det(J) = 1/4$. The spatial derivatives of a shape function $N_i$ are found using the inverse Jacobian: $\\begin{pmatrix} N_{i,x} \\\\ N_{i,y} \\end{pmatrix} = J^{-1} \\begin{pmatrix} N_{i,\\xi} \\\\ N_{i,\\eta} \\end{pmatrix}$.\n\n### 3. Task 1: Reduced-Integration Stiffness Matrix $K_e^{\\text{red}}$\n\nThe stiffness matrix is $K_e = \\int_{\\Omega_e} B^T C B \\, d\\Omega$. The plane strain constitutive matrix $C$ is given by:\n$$\nC = \\frac{E}{(1+\\nu)(1-2\\nu)} \\begin{pmatrix} 1-\\nu  \\nu  0 \\\\ \\nu  1-\\nu  0 \\\\ 0  0  \\frac{1-2\\nu}{2} \\end{pmatrix}\n$$\nThe strain-displacement matrix $B(\\xi, \\eta)$ is a $3 \\times 8$ matrix constructed from the spatial derivatives of the shape functions. For node $i$, the corresponding columns are $B_i = [ \\begin{smallmatrix} N_{i,x}  0 \\\\ 0  N_{i,y} \\\\ N_{i,y}  N_{i,x} \\end{smallmatrix} ]$.\n\nReduced integration uses a single Gauss point at the element center $(\\xi, \\eta) = (0, 0)$ with weight $w=4$ (for the $[-1,1]^2$ domain). The stiffness matrix integral simplifies to a single evaluation:\n$$\nK_e^{\\text{red}} = \\left. B^T C B \\right|_{(\\xi, \\eta)=(0,0)} \\cdot |\\Omega_e|\n$$\nwhere $|\\Omega_e| = \\int_{-1}^1\\int_{-1}^1 \\det(J) \\, d\\xi d\\eta = 1/4 \\cdot 4 = 1$. At $(\\xi, \\eta) = (0,0)$, the matrix of spatial derivatives of all shape functions needed for B is:\n$$\n\\left[ \\{N_{i,x}\\}_{i=1}^4, \\{N_{i,y}\\}_{i=1}^4 \\right]_{(0,0)} = \\frac{1}{2}\\begin{bmatrix} -1  1  1  -1 \\\\ -1  -1  1  1 \\end{bmatrix}\n$$\nThis defines $B(0,0)$, which is then used with the material matrix $C$ to compute $K_e^{\\text{red}}$.\n\n### 4. Task 2: Divergence-Based Stabilization Matrix $K_{\\text{stab}}$\n\nTo counteract the spurious zero-energy (\"hourglass\") modes introduced by reduced integration, a stabilization term is added to the virtual work formulation:\n$$\n\\delta W_{\\text{stab}} = \\int_{V_e} \\tau (\\nabla \\cdot \\delta u_h) (\\nabla \\cdot u_h) \\, dV\n$$\nThe divergence of the interpolated displacement field $u_h$ is $\\nabla \\cdot u_h = \\sum_i (N_{i,x} u_{ix} + N_{i,y} u_{iy})$. This can be written as $(\\nabla \\cdot u_h) = H d_e$, where $H$ is the $1 \\times 8$ row vector:\n$$\nH(\\xi, \\eta) = [N_{1,x}, N_{1,y}, N_{2,x}, N_{2,y}, N_{3,x}, N_{3,y}, N_{4,x}, N_{4,y}]\n$$\nThe stabilization matrix is thus:\n$$\nK_{\\text{stab}} = \\int_{V_e} \\tau H^T H \\, dV = \\tau \\int_{\\Omega_e} H^T H \\, t \\, d\\Omega\n$$\nThis integral is evaluated using standard $2 \\times 2$ Gaussian quadrature.\n\nThe stabilization parameter $\\tau$ is specified as $\\tau = \\beta \\mu$. Given $\\beta=1/3$ and shear modulus $\\mu = E/(2(1+\\nu))$, this yields a dimensionally consistent parameter with units of pressure (Pascals), which is appropriate for this formulation.\n\n### 5. Task 3: Consistent Body Force Vector $f_e$\n\nThe consistent nodal force vector arises from the external virtual work of the body force $b=(b_x, b_y)$:\n$$\nf_e = \\int_{V_e} N^T b \\, dV = t \\int_{\\Omega_e} N^T b \\, d\\Omega\n$$\nwhere $N$ is the $2 \\times 8$ matrix of shape functions. For a constant body force $b$, the integral for the force on node $i$, $f_{ei} = b \\cdot t \\int_{\\Omega_e} N_i \\, d\\Omega$, can be evaluated analytically. The integral of a single bilinear shape function over the element area is $\\int_{\\Omega_e} N_i d\\Omega = |\\Omega_e|/4$. Thus, for the unit square element ($|\\Omega_e|=1, t=1$), each node receives an equal share of the total force: $f_{ei} = b/4$. The total force vector is $f_e = [b_x/4, b_y/4, \\dots, b_x/4, b_y/4]^T$. The $2 \\times 2$ quadrature is sufficient to integrate the linear shape functions exactly, so the numerical result is expected to match the analytical one to machine precision.\n\n### 6. Task 4: Load Consistency and Rigid Body Motions\n\nThe stabilization term is added to the internal virtual work, modifying the stiffness part of the equilibrium equations. The external virtual work term, from which the load vector $f_e$ is derived, remains unchanged. This separation ensures that the stabilization, which is an internal penalty, does not alter the representation of the external physical load. Thus, no modification to $f_e$ is required to maintain load consistency.\n\nA valid stabilization must not penalize rigid body motions, which are strain-free deformations. The two-dimensional rigid body motions (2 translations, 1 rotation) all have zero divergence ($\\nabla \\cdot u_{RBM} = 0$). Since the stabilization term is proportional to $(\\nabla \\cdot u_h)^2$, it is identically zero for any rigid body motion. Consequently, the matrix $K_{\\text{stab}}$ does not apply any spurious forces or energy penalty to these modes, correctly leaving them in the nullspace of the element stiffness matrix. This is proven by noting that if $d_{RBM}$ is a nodal vector for a rigid body motion, then $H d_{RBM} = 0$, and thus $K_{stab} d_{RBM} = (\\tau \\int H^T H d\\Omega)d_{RBM} = 0$.\n\n### 7. Task 5: Numerical Investigation Plan\n\nThe provided Python code will computationally execute the prior theoretical steps. It will:\n1.  Assemble the fully integrated stiffness matrix $K_e^{\\text{full}}$, the reduced-integration matrix $K_e^{\\text{red}}$, and the stabilization matrix $K_{\\text{stab}}$.\n2.  Form the final stabilized stiffness matrix $K_e^{\\text{tot}} = K_e^{\\text{red}} + K_{\\text{stab}}$.\n3.  Compute the consistent load vector $f_e$.\n4.  Perform eigenvalue analysis on $K_e^{\\text{red}}$ and $K_e^{\\text{tot}}$ to determine their nullities. We expect a nullity of $5$ for $K_e^{\\text{red}}$ (3 rigid body modes + 2 hourglass modes) and $3$ for $K_e^{\\text{tot}}$ (stabilization removes hourglass modes).\n5.  Calculate the condition numbers of the positive-definite parts of $K_e^{\\text{full}}$ and $K_e^{\\text{tot}}$. We expect $K_e^{\\text{full}}$ to be ill-conditioned due to volumetric locking, while $K_e^{\\text{tot}}$ should be significantly better conditioned.\n6.  Verify the accuracy of the computed load vector $f_e$ against its analytical value and check the conservation of total force.\n\nThe results of this numerical study will provide quantitative insight into the effects of reduced integration and stabilization on element performance in the near-incompressible limit.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the FEM problem for a single bilinear quadrilateral element as specified.\n    \"\"\"\n    # Parameter values and test suite\n    E = 1.0e6  # Young's modulus in Pascals\n    nu = 0.4999  # Poisson's ratio (dimensionless)\n    b_vec = np.array([3.2, -1.7])  # Body force in N/m^3\n    beta = 1.0 / 3.0  # Stabilization coefficient\n    \n    # Element Geometry\n    # node_coords = np.array([[0.0, 0.0], [1.0, 0.0], [1.0, 1.0], [0.0, 1.0]])\n    thickness = 1.0  # Unit thickness in meters\n    area = 1.0  # Area in square meters\n\n    # Material properties\n    # Plane strain constitutive matrix\n    C_factor = E / ((1.0 + nu) * (1.0 - 2.0 * nu))\n    C = C_factor * np.array([\n        [1.0 - nu, nu, 0.0],\n        [nu, 1.0 - nu, 0.0],\n        [0.0, 0.0, (1.0 - 2.0 * nu) / 2.0]\n    ])\n    \n    # Shear modulus and stabilization parameter\n    mu = E / (2.0 * (1.0 + nu))\n    tau = beta * mu\n\n    # Quadrature rules\n    # 2x2 Gauss Quadrature for [-1, 1] x [-1, 1]\n    gp_val = 1.0 / np.sqrt(3.0)\n    gauss_pts_2x2 = [(-gp_val, -gp_val), (gp_val, -gp_val),\n                     (gp_val, gp_val), (-gp_val, gp_val)]\n    gauss_w_2x2 = [1.0, 1.0, 1.0, 1.0]\n\n    # Shape functions and their derivatives in the reference element\n    def get_shape_info(xi, eta):\n        N = 0.25 * np.array([(1 - xi) * (1 - eta),\n                             (1 + xi) * (1 - eta),\n                             (1 + xi) * (1 + eta),\n                             (1 - xi) * (1 + eta)])\n        \n        dNdxi = 0.25 * np.array([-(1 - eta), (1 - eta), (1 + eta), -(1 + eta)])\n        dNdeta = 0.25 * np.array([-(1 - xi), -(1 + xi), (1 + xi), (1 - xi)])\n        \n        return N, dNdxi, dNdeta\n\n    # Jacobian is constant for this specific geometry (unit square)\n    # Mapping: x = 0.5*(1+xi), y = 0.5*(1+eta)\n    J = np.array([[0.5, 0.0], [0.0, 0.5]])\n    detJ = np.linalg.det(J)\n    invJ = np.linalg.inv(J)\n\n    def get_B_and_H_matrices(dNdxi, dNdeta):\n        B = np.zeros((3, 8))\n        H = np.zeros(8)\n        for i in range(4):\n            dNd_phys = invJ @ np.array([dNdxi[i], dNdeta[i]])\n            dNdx_i, dNdy_i = dNd_phys[0], dNd_phys[1]\n            \n            # Strain-displacement matrix B for node i\n            B[0, 2 * i] = dNdx_i\n            B[1, 2 * i + 1] = dNdy_i\n            B[2, 2 * i] = dNdy_i\n            B[2, 2 * i + 1] = dNdx_i\n            \n            # Divergence operator H for node i\n            H[2 * i] = dNdx_i\n            H[2 * i + 1] = dNdy_i\n            \n        return B, H\n\n    # Assemble K_full, K_stab, and f_e using 2x2 quadrature\n    K_full = np.zeros((8, 8))\n    K_stab = np.zeros((8, 8))\n    f_e = np.zeros(8)\n\n    for i in range(len(gauss_pts_2x2)):\n        xi, eta = gauss_pts_2x2[i]\n        w = gauss_w_2x2[i]\n        \n        N, dNdxi, dNdeta = get_shape_info(xi, eta)\n        B, H = get_B_and_H_matrices(dNdxi, dNdeta)\n        \n        K_full += B.T @ C @ B * detJ * w * thickness\n        K_stab += tau * np.outer(H, H) * detJ * w * thickness\n        \n        # Consistent load vector contribution\n        N_mat = np.zeros((2, 8))\n        for j in range(4):\n            N_mat[0, 2 * j] = N[j]\n            N_mat[1, 2 * j + 1] = N[j]\n        f_e += N_mat.T @ b_vec * detJ * w * thickness\n\n    # Assemble K_red using 1-point quadrature\n    xi_red, eta_red = 0.0, 0.0\n    _, dNdxi_red, dNdeta_red = get_shape_info(xi_red, eta_red)\n    B_red, _ = get_B_and_H_matrices(dNdxi_red, dNdeta_red)\n    K_red = B_red.T @ C @ B_red * area * thickness\n\n    # Total stabilized stiffness matrix\n    K_tot = K_red + K_stab\n    \n    # --- Perform Numerical Analysis ---\n\n    # 1. Nullity of K_red\n    e_vals_red = np.linalg.eigvalsh(K_red)\n    lambda_max_red = np.max(np.abs(e_vals_red))\n    tol_red = 1e-8 * lambda_max_red if lambda_max_red > 1e-15 else 1e-8\n    nullity_red = np.sum(np.abs(e_vals_red)  tol_red)\n    \n    # 2. Nullity of K_tot\n    e_vals_tot = np.linalg.eigvalsh(K_tot)\n    lambda_max_tot = np.max(np.abs(e_vals_tot))\n    tol_tot = 1e-8 * lambda_max_tot if lambda_max_tot > 1e-15 else 1e-8\n    nullity_tot = np.sum(np.abs(e_vals_tot)  tol_tot)\n\n    # 3. Maximum absolute difference in force vector\n    f_analytic = np.tile(b_vec * area * thickness / 4.0, 4)\n    f_diff = np.max(np.abs(f_e - f_analytic))\n\n    # 4. Consistency of total nodal force\n    sum_f_num = np.array([np.sum(f_e[0::2]), np.sum(f_e[1::2])])\n    sum_f_analytic = b_vec * area * thickness\n    is_consistent = np.allclose(sum_f_num, sum_f_analytic, rtol=1e-8, atol=1e-9)\n\n    # Helper for condition number calculation\n    def get_log10_cond(matrix, tol_factor=1e-8):\n        e_vals = np.linalg.eigvalsh(matrix)\n        lambda_max = np.max(e_vals)\n        tol = tol_factor * lambda_max if lambda_max > 1e-15 else tol_factor\n        positive_eigs = e_vals[e_vals > tol]\n        if len(positive_eigs) == 0:\n            return np.inf\n        return np.log10(np.max(positive_eigs) / np.min(positive_eigs))\n\n    # 5. Log10 condition number of K_full\n    cond_full_log10 = get_log10_cond(K_full)\n    \n    # 6. Log10 condition number of K_tot\n    cond_tot_log10 = get_log10_cond(K_tot)\n\n    # --- Format and Print Final Output ---\n    results = [\n        int(nullity_red), \n        int(nullity_tot), \n        float(f_diff), \n        bool(is_consistent), \n        float(cond_full_log10), \n        float(cond_tot_log10)\n    ]\n    \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3588945"}]}