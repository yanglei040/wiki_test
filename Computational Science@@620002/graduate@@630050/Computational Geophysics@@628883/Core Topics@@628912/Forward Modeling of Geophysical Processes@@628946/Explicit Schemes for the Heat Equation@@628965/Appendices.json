{"hands_on_practices": [{"introduction": "A robust numerical scheme should not only be stable and convergent but also preserve fundamental physical properties of the governing equation. This first exercise focuses on the Maximum Principle, a core property of the heat equation, which dictates that temperature extremes must occur at the initial time or on the boundaries. Through this practice [@problem_id:3229680], you will numerically investigate how well different time-stepping schemes capture this principle, gaining invaluable intuition about numerical artifacts like spurious oscillations and the critical difference between unconditional stability and unconditional monotonicity.", "problem": "Consider the one-dimensional heat equation on the spatial interval $[0,1]$ with homogeneous Dirichlet boundary conditions and a nonnegative initial condition. The mathematical model is the parabolic partial differential equation\n$$\nu_t(x,t) = \\alpha\\,u_{xx}(x,t), \\quad x \\in (0,1), \\; t \\ge 0,\n$$\nwith boundary conditions $u(0,t)=0$ and $u(1,t)=0$, and initial condition $u(x,0)=u_0(x) \\ge 0$. The heat equation is a canonical diffusion model, and its Maximum Principle states that, under these conditions and in the absence of sources, the solution $u(x,t)$ remains bounded between the minimum and maximum of the initial and boundary data for all future times. In particular, if $u_0(x) \\ge 0$ and the boundaries are zero, then $u(x,t) \\ge 0$ and $\\max_x u(x,t) \\le \\max_x u_0(x)$ for all $t \\ge 0$.\n\nYour task is to verify this property numerically using finite difference methods and to identify a scenario where a commonly used scheme violates a discrete analogue of the Maximum Principle. You must work from first principles of numerical approximation: start from the governing equation and the definitions of spatial and temporal finite differences, derive consistent time-stepping schemes, and implement them for a discrete grid with zero Dirichlet boundaries. Do not use closed-form solutions of the heat equation.\n\nSet the diffusion coefficient to $\\alpha=1$. Use a uniform spatial grid with $M$ interior points, indexed $i=1,2,\\dots,M$, with grid spacing $h=\\frac{1}{M+1}$ and grid points $x_i = i h$. Impose the boundary conditions $u_0=0$ at $x=0$ and $u_{M+1}=0$ at $x=1$ at all times. Use a discrete initial condition that is nonnegative and localized: set $u_i(0) = 1$ at the central interior index $i=\\lfloor (M+1)/2 \\rfloor$ and $u_i(0) = 0$ for all other interior indices $i$. This is a purely discrete analogue of a unit spike and is nonnegative everywhere. Evolve the solution using each scheme for a specified number of time steps $N_t$ with time step $\\Delta t$ determined by the dimensionless ratio $r = \\alpha \\Delta t / h^2$ through $\\Delta t = r\\,h^2/\\alpha$.\n\nFrom the definitions of forward, backward, and centered finite differences in time, and centered finite differences in space, derive and implement the following classes of time-stepping methods for the heat equation:\n- An explicit forward-time, centered-space method (often called Forward Euler or Forward-Time Centered-Space), constructed by approximating $u_t$ with a forward difference and $u_{xx}$ with the standard centered second difference.\n- An implicit backward-time, centered-space method (often called Backward Euler), constructed by approximating $u_t$ with a backward difference and $u_{xx}$ with the standard centered second difference, both evaluated at the new time.\n- A trapezoidal-in-time method (often called Crank–Nicolson), constructed by combining centered space with the trapezoidal rule in time, so that the spatial second difference is averaged between the old and new time levels.\n\nImplement homogeneous Dirichlet boundaries at each time step by enforcing $u_0^n = 0$ and $u_{M+1}^n=0$ and evolving only the $M$ interior unknowns. For implicit methods, set up and solve the resulting tridiagonal linear systems exactly (no iterative approximations).\n\nNumerically check a discrete Maximum Principle at every time level $n = 1, 2, \\dots, N_t$ for the interior solution vector $u^n \\in \\mathbb{R}^M$. Since the boundary values are zero and the initial condition is nonnegative with maximum $1$ at a single interior point, verify the following inequalities at each time level:\n$$\n\\min_{1 \\le i \\le M} u_i^n \\ge 0, \\qquad \\max_{1 \\le i \\le M} u_i^n \\le 1.\n$$\nUse a numerical tolerance of $10^{-10}$ to account for round-off: treat values below $-10^{-10}$ as negative and values above $1+10^{-10}$ as exceeding the initial maximum.\n\nDesign a program that, for each specified test case, returns a Boolean value indicating whether both bounds are satisfied at all time levels for the chosen scheme and parameters. Aggregate the Booleans for all test cases into a single line as specified below.\n\nTest Suite. Use the following five test cases to probe different behaviors:\n1. Explicit forward-time, centered-space with $M=50$, $r=0.4$, $N_t=200$ (a commonly stable and monotone regime).\n2. Explicit forward-time, centered-space with $M=50$, $r=0.6$, $N_t=20$ (a regime known to be unstable in the classical sense).\n3. Implicit backward-time, centered-space with $M=50$, $r=5.0$, $N_t=1$ (large time step, but implicit).\n4. Crank–Nicolson with $M=50$, $r=5.0$, $N_t=1$ (large time step, trapezoidal in time).\n5. Explicit forward-time, centered-space with $M=50$, $r=0.5$, $N_t=200$ (borderline case often discussed for monotonicity).\n\nFinal Output Format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[{\\tt result1},{\\tt result2},{\\tt result3},{\\tt result4},{\\tt result5}]$), where each ${\\tt result}$ is either ${\\tt True}$ or ${\\tt False}$ depending on whether the discrete Maximum Principle holds for that test case.", "solution": "The problem requires the derivation and implementation of three finite difference schemes for the one-dimensional heat equation, $u_t(x,t) = \\alpha\\,u_{xx}(x,t)$, on the domain $x \\in [0,1]$ with homogeneous Dirichlet boundary conditions $u(0,t)=u(1,t)=0$ and a non-negative initial condition $u(x,0)=u_0(x)$. We are asked to numerically verify a discrete analogue of the Maximum Principle for these schemes under specified conditions.\n\nWe discretize the spatial domain with $M$ interior points, $x_i = i h$ for $i=1, \\dots, M$, where the grid spacing is $h=1/(M+1)$. The boundary points are $x_0=0$ and $x_{M+1}=1$. The time domain is discretized with steps of size $\\Delta t$, such that $t^n = n \\Delta t$. A numerical solution $u_i^n$ approximates the true solution $u(x_i, t^n)$.\n\nThe standard second-order centered difference approximation for the spatial derivative is:\n$$\nu_{xx}(x_i, t) \\approx \\frac{u(x_{i-1}, t) - 2u(x_i, t) + u(x_{i+1}, t)}{h^2}\n$$\nWe will combine this with different approximations for the time derivative $u_t$ to derive the required schemes. The dimensionless parameter $r = \\alpha \\Delta t / h^2$ will be used, with $\\alpha=1$ as specified.\n\n**1. Explicit Forward-Time, Centered-Space (FTCS) Method**\n\nThis scheme uses a forward difference for the time derivative, evaluated at time level $n$, and the centered difference for the space derivative, also at time level $n$.\n$$\n\\frac{u_i^{n+1} - u_i^n}{\\Delta t} = \\alpha \\frac{u_{i+1}^n - 2u_i^n + u_{i-1}^n}{h^2}\n$$\nRearranging for the unknown $u_i^{n+1}$ gives the explicit update formula:\n$$\nu_i^{n+1} = u_i^n + \\frac{\\alpha \\Delta t}{h^2} (u_{i+1}^n - 2u_i^n + u_{i-1}^n)\n$$\nSubstituting $r=\\alpha \\Delta t/h^2$, we have:\n$$\nu_i^{n+1} = u_i^n + r(u_{i+1}^n - 2u_i^n + u_{i-1}^n) = r u_{i-1}^n + (1-2r)u_i^n + r u_{i+1}^n\n$$\nThis update is applied to all interior points $i=1, \\dots, M$. The boundary conditions $u_0^{n+1}=0$ and $u_{M+1}^{n+1}=0$ are used for the updates of $u_1^{n+1}$ and $u_M^{n+1}$. For the discrete maximum principle to hold (specifically non-negativity), all coefficients in the update stencil must be non-negative. This requires $1-2r \\ge 0$, which implies $r \\le 1/2$. If this condition is met, the scheme is guaranteed to be monotone.\n\n**2. Implicit Backward-Time, Centered-Space (BTCS) Method**\n\nThis scheme uses a backward difference for the time derivative, which involves evaluating the spatial derivative at the new time level $n+1$.\n$$\n\\frac{u_i^{n+1} - u_i^n}{\\Delta t} = \\alpha \\frac{u_{i+1}^{n+1} - 2u_i^{n+1} + u_{i-1}^{n+1}}{h^2}\n$$\nRearranging to group the unknown terms at level $n+1$ on the left-hand side yields a system of linear equations:\n$$\n-r u_{i-1}^{n+1} + (1+2r)u_i^{n+1} - r u_{i+1}^{n+1} = u_i^n\n$$\nThis equation holds for each interior point $i=1, \\dots, M$. Incorporating the boundary conditions $u_0^{n+1}=0$ and $u_{M+1}^{n+1}=0$, we obtain an $M \\times M$ tridiagonal linear system $A U^{n+1} = U^n$, where $U^n = [u_1^n, \\dots, u_M^n]^T$ is the vector of interior solutions at time $n$. The matrix $A$ has $(1+2r)$ on its main diagonal and $-r$ on its sub- and super-diagonals. This system must be solved at each time step. Since the matrix $A$ is strictly diagonally dominant for any $r>0$, it is invertible, and the scheme is unconditionally stable. Furthermore, $A$ is an M-matrix, meaning its inverse $A^{-1}$ contains only non-negative entries. Consequently, if $U^n \\ge 0$, then $U^{n+1} = A^{-1}U^n \\ge 0$, so the scheme is unconditionally monotone.\n\n**3. Crank-Nicolson Method**\n\nThis method is derived by applying the trapezoidal rule in time. The time derivative is approximated at the midpoint $t^{n+1/2}$, and the spatial derivative is averaged over time levels $n$ and $n+1$.\n$$\n\\frac{u_i^{n+1} - u_i^n}{\\Delta t} = \\frac{\\alpha}{2} \\left( \\frac{u_{i+1}^n - 2u_i^n + u_{i-1}^n}{h^2} + \\frac{u_{i+1}^{n+1} - 2u_i^{n+1} + u_{i-1}^{n+1}}{h^2} \\right)\n$$\nMultiplying by $\\Delta t$ and using $r = \\alpha \\Delta t/h^2$, we group knowns and unknowns:\n$$\n-\\frac{r}{2} u_{i-1}^{n+1} + (1+r)u_i^{n+1} - \\frac{r}{2} u_{i+1}^{n+1} = \\frac{r}{2} u_{i-1}^{n} + (1-r)u_i^n + \\frac{r}{2} u_{i+1}^{n}\n$$\nThis is an implicit scheme of the form $A U^{n+1} = B U^n$. The matrix $A$ is tridiagonal with $(1+r)$ on the main diagonal and $-r/2$ on the off-diagonals. The matrix $B$ is tridiagonal with $(1-r)$ on the main diagonal and $r/2$ on the off-diagonals. Like BTCS, this scheme is unconditionally stable for any $r>0$. However, its monotonicity is conditional. For the non-negativity property to be preserved, the matrix $B$ must map non-negative vectors to non-negative vectors. This requires all entries of $B$ to be non-negative, which imposes the condition $1-r \\ge 0$, or $r \\le 1$. In this problem, we will test a case with $r>1$, where small oscillations and a violation of non-negativity are expected, particularly for non-smooth initial data like the discrete spike used here.\n\n**Implementation**\n\nFor the implicit methods (BTCS and Crank-Nicolson), the tridiagonal linear systems are solved using the Thomas algorithm (TDMA), an efficient O(M) direct solver based on Gaussian elimination. The simulation for each test case proceeds for $N_t$ time steps. At each step $n=1, \\dots, N_t$, after computing the new solution vector $U^n$, we check if it satisfies the discrete Maximum Principle:\n$$\n\\min_{1 \\le i \\le M} u_i^n \\ge -10^{-10} \\quad \\text{and} \\quad \\max_{1 \\le i \\le M} u_i^n \\le 1 + 10^{-10}\n$$\nIf a violation occurs at any time step, the check for that test case fails.\n\n**Numerical Validation**\n\nWe execute this procedure for the five test cases provided.\n1.  **FTCS, $r=0.4$**: Since $r = 0.4 \\le 0.5$, the scheme is monotone. The Maximum Principle should hold.\n2.  **FTCS, $r=0.6$**: Since $r = 0.6 > 0.5$, the scheme is unstable. The solution is expected to grow and oscillate, violating the Maximum Principle.\n3.  **BTCS, $r=5.0$**: The scheme is unconditionally monotone. The Maximum Principle should hold regardless of the large value of $r$.\n4.  **Crank-Nicolson, $r=5.0$**: The scheme is stable but not monotone for $r>1$. With the sharp initial spike, oscillations are expected, leading to negative values and a violation of the Maximum Principle.\n5.  **FTCS, $r=0.5$**: This is the borderline case for monotonicity. The coefficients are non-negative, so the Maximum Principle should hold.\nThe program will compute a Boolean result for each case based on these numerical experiments.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_tridiagonal(a, b, c, d):\n    \"\"\"\n    Solves a tridiagonal system of equations Ax=d.\n    a: sub-diagonal (length n-1)\n    b: main diagonal (length n)\n    c: super-diagonal (length n-1)\n    d: right-hand side vector (length n)\n    \"\"\"\n    n = len(d)\n    if n == 0:\n        return np.array([])\n    \n    # Create copies to avoid modifying input arrays\n    c_prime = np.zeros(n - 1)\n    d_prime = np.zeros(n)\n    x = np.zeros(n)\n\n    # Forward elimination\n    if n == 1:\n        x[0] = d[0] / b[0]\n        return x\n    \n    c_prime[0] = c[0] / b[0]\n    d_prime[0] = d[0] / b[0]\n    for i in range(1, n - 1):\n        m = b[i] - a[i - 1] * c_prime[i - 1]\n        c_prime[i] = c[i] / m\n        d_prime[i] = (d[i] - a[i - 1] * d_prime[i - 1]) / m\n    \n    m_last = b[n - 1] - a[n - 2] * c_prime[n - 2]\n    d_prime[n - 1] = (d[n - 1] - a[n - 2] * d_prime[n - 2]) / m_last\n\n    # Back substitution\n    x[n - 1] = d_prime[n - 1]\n    for i in range(n - 2, -1, -1):\n        x[i] = d_prime[i] - c_prime[i] * x[i + 1]\n        \n    return x\n\ndef run_simulation(scheme, M, r, Nt):\n    \"\"\"\n    Runs the simulation for a given scheme and parameters.\n    Returns True if the discrete Maximum Principle holds, False otherwise.\n    \"\"\"\n    alpha = 1.0\n    h = 1.0 / (M + 1)\n    \n    # Initialize solution vector for interior points\n    u = np.zeros(M)\n    center_idx = int((M + 1) / 2) - 1\n    u[center_idx] = 1.0\n\n    tolerance = 1e-10\n\n    # Pre-calculate diagonals for implicit methods if needed\n    if scheme == 'BTCS':\n        diag_b = np.full(M, 1.0 + 2.0 * r)\n        diag_a = np.full(M - 1, -r)\n        diag_c = np.full(M - 1, -r)\n    elif scheme == 'CN':\n        # Matrix A (LHS)\n        diag_A_b = np.full(M, 1.0 + r)\n        diag_A_ac = np.full(M - 1, -r / 2.0)\n        # Matrix B (RHS)\n        diag_B_b = 1.0 - r\n        diag_B_ac = r / 2.0\n\n    for _ in range(Nt):\n        if scheme == 'FTCS':\n            u_old = np.copy(u)\n            for i in range(M):\n                u_left = u_old[i-1] if i > 0 else 0.0\n                u_right = u_old[i+1] if i  M-1 else 0.0\n                u[i] = u_old[i] + r * (u_left - 2.0 * u_old[i] + u_right)\n\n        elif scheme == 'BTCS':\n            u = solve_tridiagonal(diag_a, diag_b, diag_c, u)\n\n        elif scheme == 'CN':\n            # Calculate RHS vector d = B * u\n            d = np.zeros(M)\n            for i in range(M):\n                u_left = u[i-1] if i > 0 else 0.0\n                u_right = u[i+1] if i  M-1 else 0.0\n                d[i] = diag_B_ac * u_left + diag_B_b * u[i] + diag_B_ac * u_right\n            u = solve_tridiagonal(diag_A_ac, diag_A_b, diag_A_ac, d)\n\n        # Check discrete Maximum Principle\n        min_u = np.min(u)\n        max_u = np.max(u)\n\n        if min_u  -tolerance or max_u > 1.0 + tolerance:\n            return False\n    \n    return True\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (scheme, M, r, Nt)\n        ('FTCS', 50, 0.4, 200),\n        ('FTCS', 50, 0.6, 20),\n        ('BTCS', 50, 5.0, 1),\n        ('CN', 50, 5.0, 1),\n        ('FTCS', 50, 0.5, 200),\n    ]\n\n    results = []\n    for case in test_cases:\n        scheme, M, r, Nt = case\n        result = run_simulation(scheme, M, r, Nt)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3229680"}, {"introduction": "After exploring the qualitative behavior of a scheme, it is essential to quantitatively verify its implementation and theoretical accuracy. This practice introduces the Method of Manufactured Solutions (MMS), a cornerstone of modern code verification, where an exact solution is prescribed and used to test a numerical solver [@problem_id:3590474]. By implementing a 2D explicit heat equation solver and comparing your results against a known analytical solution, you will perform a rigorous convergence study to confirm that the scheme achieves its expected first-order accuracy in time and second-order accuracy in space.", "problem": "Consider the two-dimensional heat equation with a constant thermal diffusivity $\\,\\kappa\\,$ on the unit square domain $\\,\\Omega = [0,1]\\times[0,1]\\,$ and a smooth source term $\\,s(\\mathbf{x},t)\\,$,\n$$\n\\frac{\\partial u}{\\partial t}(\\mathbf{x},t) \\;=\\; \\kappa \\,\\Delta u(\\mathbf{x},t) \\;+\\; s(\\mathbf{x},t), \\qquad \\mathbf{x}=(x,y)\\in\\Omega,\\; t\\in[0,T],\n$$\nsubject to homogeneous Dirichlet boundary conditions $\\,u(\\mathbf{x},t)=0\\,$ for $\\,\\mathbf{x}\\in\\partial\\Omega\\,$ and a specified initial condition $\\,u(\\mathbf{x},0)=u_0(\\mathbf{x})\\,$. Use the method of manufactured solutions to construct a smooth, nontrivial function $\\,u(\\mathbf{x},t)\\,$ and deduce the corresponding source term $\\,s(\\mathbf{x},t)\\,$ such that the manufactured $\\,u(\\mathbf{x},t)\\,$ exactly satisfies the partial differential equation and boundary conditions. Then design and implement a fully explicit forward Euler in time and centered differences in space scheme for this problem, derive and enforce its stability restriction, and numerically verify the observed convergence rates in time and space.\n\nYour manufactured solution must be\n$$\nu(x,y,t) \\;=\\; e^{t}\\,\\sin(2\\pi x)\\,\\sin(2\\pi y),\n$$\non $\\,\\Omega\\,$ and for $\\,t\\in[0,T]\\,$. Starting from the governing equation and the chosen $\\,u(x,y,t)\\,$, compute the source term $\\,s(x,y,t)\\,$ required to make $\\,u\\,$ satisfy the equation. Use the homogeneous Dirichlet boundary values induced by $\\,u\\,$ and the initial condition $\\,u(x,y,0)\\,$. Discretize $\\,\\Omega\\,$ using a uniform Cartesian grid with $\\,N_x+1\\,$ points in $\\,x\\,$ and $\\,N_y+1\\,$ points in $\\,y\\,$ (including boundaries), with spacings $\\,\\Delta x=1/N_x\\,$ and $\\,\\Delta y=1/N_y\\,$. Let $\\,u_{i,j}^n\\,$ denote the numerical approximation at grid index $\\,i,j\\,$ and time level $\\,t^n\\,$.\n\nYour explicit scheme must update interior grid points $\\,i=1,\\dots,N_x-1\\,$ and $\\,j=1,\\dots,N_y-1\\,$ according to\n$$\nu_{i,j}^{n+1} \\;=\\; u_{i,j}^{n} \\;+\\; \\Delta t \\left\\{ \\kappa\\left(\\frac{u_{i+1,j}^{n}-2u_{i,j}^{n}+u_{i-1,j}^{n}}{\\Delta x^2} \\;+\\; \\frac{u_{i,j+1}^{n}-2u_{i,j}^{n}+u_{i,j-1}^{n}}{\\Delta y^2}\\right) \\;+\\; s(x_i,y_j,t^n) \\right\\},\n$$\nwith boundary values set to zero at each time level. Use the Courant-Friedrichs-Lewy (CFL) stability restriction for the two-dimensional explicit scheme,\n$$\n\\Delta t \\;\\le\\; \\frac{1}{2\\,\\kappa\\left(\\frac{1}{\\Delta x^2}+\\frac{1}{\\Delta y^2}\\right)},\n$$\nand, for $\\,\\Delta x=\\Delta y\\,$, this simplifies to $\\,\\Delta t \\le \\frac{\\Delta x^2}{4\\kappa}\\,$.\n\nDefine the discrete $\\,L^2\\,$ error at final time $\\,T\\,$ by\n$$\nE \\;=\\; \\left(\\sum_{i=0}^{N_x}\\sum_{j=0}^{N_y} \\left(u_{i,j}^{N_t} - u(x_i,y_j,T)\\right)^2 \\,\\Delta x\\,\\Delta y \\right)^{1/2},\n$$\nwhere $\\,N_t\\,$ denotes the final time index such that $\\,N_t\\,\\Delta t \\approx T\\,$. Use $\\,\\Delta t\\,$ adjusted so that the time grid lands exactly at $\\,T\\,$, i.e., $\\,\\Delta t_{\\mathrm{eff}} = T/N_t\\,$ with integer $\\,N_t\\,$ and $\\,\\Delta t_{\\mathrm{eff}} \\le \\Delta t\\,$.\n\nNumerically estimate the temporal convergence rate $\\,p_t\\,$ by fixing a fine spatial grid and computing errors $\\,E(\\Delta t_k)\\,$ for a sequence of time steps $\\,\\Delta t_k\\,$ related by successive halving. Estimate $\\,p_t\\,$ from the slope of $\\,\\log E\\,$ versus $\\,\\log \\Delta t\\,$. Similarly, estimate the spatial convergence rate $\\,p_x\\,$ by fixing a stable time step (consistent with the CFL condition) and computing errors $\\,E(\\Delta x_\\ell)\\,$ for spatial grids with $\\,\\Delta x_\\ell\\,$ related by successive halving, estimating $\\,p_x\\,$ from the slope of $\\,\\log E\\,$ versus $\\,\\log \\Delta x\\,$.\n\nTest Suite:\n- Case A (temporal convergence, happy path): $\\,\\kappa=0.1\\,$, $\\,N_x=N_y=64\\,$, $\\,T=0.1\\,$, and $\\,\\Delta t\\,$ values $\\,\\Delta t_0=0.8\\,\\Delta t_{\\mathrm{CFL}}\\,$, $\\,\\Delta t_1=\\Delta t_0/2\\,$, $\\,\\Delta t_2=\\Delta t_1/2\\,$ where $\\,\\Delta t_{\\mathrm{CFL}}=\\Delta x^2/(4\\kappa)\\,$. Report the measured $\\,p_t\\,$.\n- Case B (spatial convergence, happy path): $\\,\\kappa=0.1\\,$, $\\,T=0.1\\,$, grids with $\\,N_x=N_y\\in\\{20,40,80\\}\\,$ and, for each grid, take $\\,\\Delta t=0.4\\,\\Delta t_{\\mathrm{CFL}}\\,$. Report the measured $\\,p_x\\,$.\n- Case C (temporal convergence at the stability boundary, edge case): $\\,\\kappa=0.1\\,$, $\\,N_x=N_y=50\\,$, $\\,T=0.05\\,$, and $\\,\\Delta t\\,$ values $\\,\\Delta t_0=\\Delta t_{\\mathrm{CFL}}\\,$, $\\,\\Delta t_1=\\Delta t_0/2\\,$, $\\,\\Delta t_2=\\Delta t_1/2\\,$. Report the measured $\\,p_t\\,$.\n\nYour program must:\n- Compute $\\,s(x,y,t)\\,$ from the manufactured $\\,u(x,y,t)\\,$ and the heat equation.\n- Implement the explicit scheme with homogeneous Dirichlet boundaries and the CFL restriction.\n- For each case, estimate the convergence rate by linear regression on the pairs $\\,(\\log \\Delta t_k, \\log E_k)\\,$ or $\\,(\\log \\Delta x_\\ell, \\log E_\\ell)\\,$ as appropriate.\n- Produce a single line of output containing the three results, rounded to three decimal places, as a comma-separated list enclosed in square brackets, in the order $[p_t^{\\mathrm{A}},p_x^{\\mathrm{B}},p_t^{\\mathrm{C}}]$. No physical units are required because the quantities are dimensionless.\n\nThe final outputs for all provided test cases must be floats. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3]\").", "solution": "We start from the governing two-dimensional heat equation with constant thermal diffusivity $\\,\\kappa\\,$,\n$$\n\\frac{\\partial u}{\\partial t} \\;=\\; \\kappa \\,\\Delta u \\;+\\; s,\n$$\non the unit square domain $\\,\\Omega=[0,1]\\times[0,1]\\,$ with homogeneous Dirichlet boundary conditions, i.e., $\\,u|_{\\partial\\Omega}=0\\,$, and a prescribed initial condition. In the method of manufactured solutions, we choose a smooth function $\\,u(x,y,t)\\,$ and deduce the source term $\\,s(x,y,t)\\,$ such that the chosen $\\,u\\,$ satisfies the equation and boundary conditions exactly. This allows us to assess the numerical method’s convergence properties by comparing the numerical solution against the exact manufactured solution.\n\nWe choose\n$$\nu(x,y,t) \\;=\\; e^{t}\\,\\sin(2\\pi x)\\,\\sin(2\\pi y).\n$$\nThis function satisfies the homogeneous Dirichlet boundary conditions because $\\,\\sin(2\\pi x)=0\\,$ on $\\,x=0\\,$ and $\\,x=1\\,$, and similarly $\\,\\sin(2\\pi y)=0\\,$ on $\\,y=0\\,$ and $\\,y=1\\,$, so $\\,u=0\\,$ on $\\,\\partial\\Omega\\,$ for all $\\,t\\,$. Its initial condition is $\\,u(x,y,0)=\\sin(2\\pi x)\\sin(2\\pi y)\\,$.\n\nTo compute the source term $\\,s\\,$, we use the definitions of the time derivative and Laplacian:\n$$\n\\frac{\\partial u}{\\partial t} \\;=\\; e^{t}\\,\\sin(2\\pi x)\\,\\sin(2\\pi y) \\;=\\; u,\n$$\nand\n$$\n\\Delta u \\;=\\; \\frac{\\partial^2 u}{\\partial x^2} \\;+\\; \\frac{\\partial^2 u}{\\partial y^2}\n\\;=\\; -\\,(2\\pi)^2\\,e^{t}\\,\\sin(2\\pi x)\\,\\sin(2\\pi y) \\;-\\; (2\\pi)^2\\,e^{t}\\,\\sin(2\\pi x)\\,\\sin(2\\pi y)\n\\;=\\; -\\,8\\pi^2\\,u.\n$$\nSubstituting into the heat equation gives\n$$\nu_t \\;=\\; \\kappa\\,\\Delta u \\;+\\; s \\;\\;\\Rightarrow\\;\\; s \\;=\\; u_t \\;-\\; \\kappa\\,\\Delta u \\;=\\; u \\;-\\; \\kappa\\,(-8\\pi^2\\,u) \\;=\\; \\left(1+8\\pi^2\\kappa\\right)\\,u.\n$$\nThus, the forcing term is\n$$\ns(x,y,t) \\;=\\; \\left(1+8\\pi^2\\kappa\\right)\\,e^{t}\\,\\sin(2\\pi x)\\,\\sin(2\\pi y).\n$$\n\nWe discretize the spatial domain with a uniform Cartesian grid:\n$$\nx_i \\;=\\; i\\,\\Delta x,\\quad i=0,\\dots,N_x,\\qquad \\Delta x \\;=\\; \\frac{1}{N_x},\n$$\n$$\ny_j \\;=\\; j\\,\\Delta y,\\quad j=0,\\dots,N_y,\\qquad \\Delta y \\;=\\; \\frac{1}{N_y}.\n$$\nLet $\\,u_{i,j}^n\\,$ denote the numerical approximation to $\\,u(x_i,y_j,t^n)\\,$ at time level $\\,t^n=n\\,\\Delta t\\,$. The explicit forward Euler in time and second-order centered differences in space scheme for interior points $\\,i=1,\\dots,N_x-1\\,$ and $\\,j=1,\\dots,N_y-1\\,$ is\n$$\nu_{i,j}^{n+1} \\;=\\; u_{i,j}^{n} \\;+\\; \\Delta t \\left\\{ \\kappa\\left(\\frac{u_{i+1,j}^{n}-2u_{i,j}^{n}+u_{i-1,j}^{n}}{\\Delta x^2} \\;+\\; \\frac{u_{i,j+1}^{n}-2u_{i,j}^{n}+u_{i,j-1}^{n}}{\\Delta y^2}\\right) \\;+\\; s(x_i,y_j,t^n) \\right\\},\n$$\nwith boundary values $\\,u_{0,j}^n=u_{N_x,j}^n=u_{i,0}^n=u_{i,N_y}^n=0\\,$ for all $\\,n\\,$. This scheme is first order accurate in time and second order accurate in space, under appropriate smoothness assumptions on $\\,u\\,$.\n\nFor stability, the Courant-Friedrichs-Lewy (CFL) restriction for the two-dimensional explicit diffusion scheme with constant $\\,\\kappa\\,$ is\n$$\n\\Delta t \\;\\le\\; \\frac{1}{2\\,\\kappa\\left(\\frac{1}{\\Delta x^2}+\\frac{1}{\\Delta y^2}\\right)}.\n$$\nIn the special case $\\,\\Delta x=\\Delta y\\,$, this simplifies to\n$$\n\\Delta t \\;\\le\\; \\frac{\\Delta x^2}{4\\,\\kappa}.\n$$\nWe enforce this restriction by computing a candidate $\\,\\Delta t\\,$ and then adjusting with $\\,\\Delta t_{\\mathrm{eff}}=T/N_t\\,$ where $\\,N_t=\\left\\lceil T/\\Delta t\\right\\rceil\\,$ so that the time grid lands exactly at $\\,T\\,$ while maintaining stability.\n\nTo quantify numerical error at final time $\\,T\\,$, we use the discrete $\\,L^2\\,$ norm,\n$$\nE \\;=\\; \\left(\\sum_{i=0}^{N_x}\\sum_{j=0}^{N_y} \\left(u_{i,j}^{N_t} - u(x_i,y_j,T)\\right)^2 \\,\\Delta x\\,\\Delta y \\right)^{1/2}.\n$$\nThe observed temporal convergence rate $\\,p_t\\,$ is estimated by computing errors $\\,E_k=E(\\Delta t_k)\\,$ on a fixed fine grid for time step sizes $\\,\\Delta t_k\\,$ related by successive halving, and performing a linear regression of $\\,\\log E_k\\,$ versus $\\,\\log \\Delta t_k\\,$. Similarly, the observed spatial convergence rate $\\,p_x\\,$ is estimated by computing errors $\\,E_\\ell=E(\\Delta x_\\ell)\\,$ at a fixed stable time step for grids with $\\,\\Delta x_\\ell\\,$ halved successively, and performing a linear regression of $\\,\\log E_\\ell\\,$ versus $\\,\\log \\Delta x_\\ell\\,$. Since the scheme is first order in time and second order in space, we expect $\\,p_t\\approx 1\\,$ and $\\,p_x\\approx 2\\,$.\n\nAlgorithmic steps for each test case:\n1. Set $\\,\\kappa\\,$, $\\,T\\,$, and the grid sizes $\\,N_x,N_y\\,$.\n2. Compute $\\,\\Delta x=1/N_x\\,$ and $\\,\\Delta y=1/N_y\\,$; form grids $\\,x_i\\,$ and $\\,y_j\\,$ and the manufactured initial condition $\\,u(x,y,0)\\,$.\n3. Choose candidate $\\,\\Delta t\\,$ values consistent with the CFL restriction. For temporal studies, use $\\,\\Delta t\\,$ sequences related by halving. For spatial studies, adjust $\\,\\Delta t\\,$ per grid via a fixed fraction of the CFL limit to remain stable and reasonably efficient.\n4. For each $\\,\\Delta t\\,$, set $\\,N_t=\\lceil T/\\Delta t\\rceil\\,$ and use $\\,\\Delta t_{\\mathrm{eff}}=T/N_t\\,$ to exactly reach $\\,T\\,$. Advance the explicit scheme for $\\,N_t\\,$ steps:\n   - At each step $\\,n\\,$, evaluate $\\,s(x_i,y_j,t^n)\\,$ from the manufactured solution and update interior points using the explicit formula; enforce boundary values $\\,u=0\\,$.\n5. At final time $\\,T\\,$, compute the discrete $\\,L^2\\,$ error $\\,E\\,$ against the exact $\\,u(x,y,T)\\,$.\n6. Assemble errors versus $\\,\\Delta t\\,$ or $\\,\\Delta x\\,$ and estimate $\\,p_t\\,$ or $\\,p_x\\,$ via linear regression on $\\,(\\log \\Delta t,\\log E)\\,$ or $\\,(\\log \\Delta x,\\log E)\\,$.\n7. Report the measured rates rounded to three decimal places.\n\nTest Suite specifics:\n- Case A: $\\,\\kappa=0.1\\,$, $\\,N_x=N_y=64\\,$, $\\,T=0.1\\,$; time step sequence $\\,\\Delta t_0=0.8\\,\\Delta x^2/(4\\kappa)\\,$, $\\,\\Delta t_1=\\Delta t_0/2\\,$, $\\,\\Delta t_2=\\Delta t_1/2\\,$; estimate $\\,p_t\\,$.\n- Case B: $\\,\\kappa=0.1\\,$, $\\,T=0.1\\,$; grids $\\,N_x=N_y\\in\\{20,40,80\\}\\,$; for each, set $\\,\\Delta t=0.4\\,\\Delta x^2/(4\\kappa)\\,$; estimate $\\,p_x\\,$.\n- Case C: $\\,\\kappa=0.1\\,$, $\\,N_x=N_y=50\\,$, $\\,T=0.05\\,$; time step sequence $\\,\\Delta t_0=\\Delta x^2/(4\\kappa)\\,$, $\\,\\Delta t_1=\\Delta t_0/2\\,$, $\\,\\Delta t_2=\\Delta t_1/2\\,$; estimate $\\,p_t\\,$.\n\nThe final program output must be a single line containing $\\,\\left[p_t^{\\mathrm{A}},p_x^{\\mathrm{B}},p_t^{\\mathrm{C}}\\right]\\,$ as a comma-separated list enclosed in square brackets, with each number rounded to three decimal places. No physical units are required since the measured rates are dimensionless.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef manufactured_u(x, y, t):\n    \"\"\"Exact manufactured solution u(x,y,t) = exp(t) * sin(2πx) * sin(2πy).\"\"\"\n    return np.exp(t) * np.sin(2.0 * np.pi * x) * np.sin(2.0 * np.pi * y)\n\ndef source_s(x, y, t, kappa):\n    \"\"\"Source term s = (1 + 8π^2 κ) * u(x,y,t).\"\"\"\n    return (1.0 + 8.0 * (np.pi ** 2) * kappa) * manufactured_u(x, y, t)\n\ndef explicit_heat_2d(kappa, Nx, Ny, T, dt_candidate):\n    \"\"\"\n    Solve the forced heat equation using an explicit scheme on [0,1]x[0,1] with Dirichlet 0 BCs.\n    Uses dt_eff = T / Nt with Nt = ceil(T / dt_candidate) to land exactly at T.\n    Returns the discrete L2 error at time T with respect to the manufactured solution.\n    \"\"\"\n    Lx, Ly = 1.0, 1.0\n    dx = Lx / Nx\n    dy = Ly / Ny\n\n    # CFL time step limit for explicit scheme in 2D with dx=1/Nx, dy=1/Ny:\n    dt_cfl = 1.0 / (2.0 * kappa * (1.0 / dx**2 + 1.0 / dy**2))\n    # Ensure candidate dt is not larger than CFL limit\n    dt = min(dt_candidate, dt_cfl)\n    Nt = int(np.ceil(T / dt))\n    dt_eff = T / Nt  # adjust to land exactly at T, maintains stability since dt_eff = dt\n\n    # Grids\n    x = np.linspace(0.0, Lx, Nx + 1)\n    y = np.linspace(0.0, Ly, Ny + 1)\n    X, Y = np.meshgrid(x, y, indexing='ij')\n\n    # Initial condition from manufactured solution at t=0\n    u = manufactured_u(X, Y, 0.0)\n\n    # Enforce boundary conditions (Dirichlet zero) explicitly: they are already zero by construction,\n    # but we maintain the boundary to zero at each time step.\n    u[0, :] = 0.0\n    u[-1, :] = 0.0\n    u[:, 0] = 0.0\n    u[:, -1] = 0.0\n\n    # Time stepping\n    t = 0.0\n    inv_dx2 = 1.0 / dx**2\n    inv_dy2 = 1.0 / dy**2\n    for n in range(Nt):\n        # Source term evaluated at current time\n        s = source_s(X, Y, t, kappa)\n\n        # Compute Laplacian with centered differences on interior points\n        # Vectorized update for interior\n        u_center = u[1:-1, 1:-1]\n        lap = (u[2:, 1:-1] - 2.0 * u_center + u[:-2, 1:-1]) * inv_dx2 \\\n            + (u[1:-1, 2:] - 2.0 * u_center + u[1:-1, :-2]) * inv_dy2\n\n        # Update interior\n        u[1:-1, 1:-1] = u_center + dt_eff * (kappa * lap + s[1:-1, 1:-1])\n\n        # Enforce boundary zeros each step\n        u[0, :] = 0.0\n        u[-1, :] = 0.0\n        u[:, 0] = 0.0\n        u[:, -1] = 0.0\n\n        t += dt_eff\n\n    # Exact solution at final time\n    u_exact_T = manufactured_u(X, Y, T)\n\n    # Discrete L2 error over the whole grid\n    err = u - u_exact_T\n    E = np.sqrt(np.sum(err**2) * dx * dy)\n    return E, dx, dy, dt_eff\n\ndef estimate_rate(xs, Es):\n    \"\"\"\n    Estimate convergence rate by linear regression of log(Es) vs log(xs).\n    xs: array of step sizes (Δt or Δx)\n    Es: corresponding errors\n    Returns slope (rate)\n    \"\"\"\n    logx = np.log(xs)\n    logE = np.log(Es)\n    # Fit logE = a + p * logx; p is slope (rate)\n    p, a = np.polyfit(logx, logE, 1)\n    return p\n\ndef case_temporal_convergence(kappa, Nx, Ny, T, dt0, num_levels=3):\n    \"\"\"\n    Measure temporal convergence rate by halving dt on a fixed grid.\n    \"\"\"\n    dts = [dt0 / (2**i) for i in range(num_levels)]\n    errors = []\n    dts_eff_list = []\n    for dt in dts:\n        E, _, _, dt_eff = explicit_heat_2d(kappa, Nx, Ny, T, dt)\n        errors.append(E)\n        dts_eff_list.append(dt_eff)\n\n    rate = estimate_rate(np.array(dts_eff_list), np.array(errors))\n    return rate\n\ndef case_spatial_convergence(kappa, Ns, T, dt_fraction=0.4):\n    \"\"\"\n    Measure spatial convergence rate by halving Δx with dt set as a fixed fraction of the CFL limit.\n    Ns: list of N values for Nx=Ny.\n    \"\"\"\n    dxs = []\n    errors = []\n    for N in Ns:\n        # For each N, set dt = dt_fraction * dt_cfl\n        dx = 1.0 / N\n        dy = dx\n        dt_cfl = 1.0 / (2.0 * kappa * (1.0 / dx**2 + 1.0 / dy**2))\n        dt = dt_fraction * dt_cfl\n        E, _, _, _ = explicit_heat_2d(kappa, N, N, T, dt)\n        dxs.append(dx)\n        errors.append(E)\n    rate = estimate_rate(np.array(dxs), np.array(errors))\n    return rate\n\ndef solve():\n    # Define the test cases from the problem statement.\n\n    # Case A: Temporal convergence, happy path\n    kappa_A = 0.1\n    Nx_A = Ny_A = 64\n    T_A = 0.1\n    dx_A = 1.0 / Nx_A\n    dt_cfl_A = dx_A**2 / (4.0 * kappa_A)  # for dx=dy\n    dt0_A = 0.8 * dt_cfl_A\n    p_t_A = case_temporal_convergence(kappa_A, Nx_A, Ny_A, T_A, dt0_A, num_levels=3)\n\n    # Case B: Spatial convergence, happy path\n    kappa_B = 0.1\n    T_B = 0.1\n    Ns_B = [20, 40, 80]\n    p_x_B = case_spatial_convergence(kappa_B, Ns_B, T_B, dt_fraction=0.4)\n\n    # Case C: Temporal convergence at the stability boundary, edge case\n    kappa_C = 0.1\n    Nx_C = Ny_C = 50\n    T_C = 0.05\n    dx_C = 1.0 / Nx_C\n    dt_cfl_C = dx_C**2 / (4.0 * kappa_C)\n    dt0_C = dt_cfl_C\n    p_t_C = case_temporal_convergence(kappa_C, Nx_C, Ny_C, T_C, dt0_C, num_levels=3)\n\n    results = [p_t_A, p_x_B, p_t_C]\n\n    # Final print statement in the exact required format (rounded to three decimals).\n    print(f\"[{','.join(f'{r:.3f}' for r in results)}]\")\n\nsolve()\n```", "id": "3590474"}, {"introduction": "Real-world geophysical phenomena often involve multiple interacting physical processes. This final practice advances from pure diffusion to the more complex advection-diffusion equation, a model central to problems like thermal evolution in subduction zones [@problem_id:3590410]. You will learn to use operator splitting, a powerful technique for combining simpler numerical methods, to build a solver that handles both advection and diffusion. This exercise will challenge you to derive combined stability constraints and to numerically quantify the splitting error, comparing the first-order Lie splitting with the second-order Strang splitting to see the practical benefits of higher-order composition methods.", "problem": "Consider the one-dimensional advection–diffusion form of the heat equation with constant coefficients,\n$$\n\\frac{\\partial T}{\\partial t} + u \\frac{\\partial T}{\\partial x} = \\kappa \\frac{\\partial^2 T}{\\partial x^2},\n$$\nposed on a periodic domain of length $L$ with uniform grid spacing $\\Delta x$ and time step $\\Delta t$. Here $T(x,t)$ is temperature, $u$ is a uniform solid velocity (solid advection of heat), and $\\kappa$ is thermal diffusivity. This setting is a simplified surrogate for the along-slab thermal evolution in a subduction zone, capturing the interplay between solid-state advection and thermal diffusion.\n\nYou must design an explicit operator-splitting time integrator that combines:\n- an explicit first-order upwind scheme for the advection substep, and\n- an explicit forward Euler central-difference scheme for the diffusion substep,\n\nwith periodic boundaries. Implement two splitting variants:\n- Lie splitting: in each full time step, apply advection for $\\Delta t$ followed by diffusion for $\\Delta t$,\n- Strang splitting: in each full time step, apply advection for $\\Delta t/2$, diffusion for $\\Delta t$, and advection for $\\Delta t/2$.\n\nDerive, from first principles, the combined Courant–Friedrichs–Lewy (CFL) stability constraints for this explicit composition. Quantify the splitting error by comparing the numerical solutions to the exact solution of the constant-coefficient advection–diffusion equation on a periodic domain, evaluated via the discrete Fourier transform. For a grid with $N$ points, grid spacing $\\Delta x = L/N$, discrete wavenumbers $k_n = 2\\pi n/L$ with $n \\in \\{0,1,\\dots,N-1\\}$ mapped to signed frequencies, and initial condition $\\widehat{T}(k_n,0)$, the exact spectral solution is given by\n$$\n\\widehat{T}(k_n,t) = \\widehat{T}(k_n,0)\\,\\exp\\!\\big(-\\kappa k_n^2 t\\big)\\,\\exp\\!\\big(-\\mathrm{i} k_n u t\\big),\n$$\nand the physical-space solution is obtained by inverse transform. Use this exact solution to compute relative $\\ell^2$ errors.\n\nAdopt the initial condition\n$$\nT(x,0) = \\cos\\!\\Big(\\frac{2\\pi x}{L}\\Big) + \\frac{1}{2}\\cos\\!\\Big(\\frac{4\\pi x}{L} + \\phi\\Big),\n$$\nwith phase $\\phi = 0.3$ in radians. Angles must be in radians.\n\nDefine the nondimensional parameters\n$$\nr = \\frac{|u|\\,\\Delta t}{\\Delta x}, \\qquad \\mu = \\frac{\\kappa\\,\\Delta t}{\\Delta x^2}.\n$$\n\nYour program must:\n1. Implement Lie and Strang splitting integrators with periodic boundaries, using the explicit first-order upwind advection substep and explicit forward Euler diffusion substep.\n2. Compute the exact reference solution at a specified final time $t_{\\mathrm{end}}$ using the spectral formula above.\n3. Compute the relative $\\ell^2$ error\n$$\nE = \\frac{\\|T_{\\mathrm{num}}(\\cdot,t_{\\mathrm{end}}) - T_{\\mathrm{exact}}(\\cdot,t_{\\mathrm{end}})\\|_2}{\\|T_{\\mathrm{exact}}(\\cdot,t_{\\mathrm{end}})\\|_2}.\n$$\n4. Estimate the observed order of accuracy in time for each splitting by comparing errors at $\\Delta t$ and $\\Delta t/2$ for the same $t_{\\mathrm{end}}$:\n$$\np = \\frac{\\log\\big(E(\\Delta t)/E(\\Delta t/2)\\big)}{\\log(2)}.\n$$\n5. Compute the combined stability-limited time step $\\Delta t_{\\max}$ implied by your derived constraints. Express any time quantities in seconds.\n\nUse the following test suite of parameter sets. All lengths must be in meters, time in seconds, velocity in meters per second, diffusivity in square meters per second, and the phase $\\phi$ in radians.\n\n- Test Case A (convergence exponents under diffusion-limited constraint):\n  - $L = 10{,}000$, $\\Delta x = 50$, $\\kappa = 10^{-6}$, $u = 0.05/31557600$, $\\phi = 0.3$.\n  - Let $\\Delta t_{\\max}$ be the combined stability-limited time step you derive.\n  - Set $\\Delta t = 0.4\\,\\Delta t_{\\max}$, $\\Delta t/2$ as the refined step, and $t_{\\mathrm{end}} = 100\\,\\Delta t$.\n  - Compute $p_{\\mathrm{Lie}}$ and $p_{\\mathrm{Strang}}$ as defined above.\n\n- Test Case B (near-boundary stability metrics under advection-limited constraint):\n  - $L = 200{,}000$, $\\Delta x = 1{,}000$, $\\kappa = 10^{-6}$, $u = 0.08/31557600$, $\\phi = 0.3$.\n  - Compute $\\Delta t_{\\max}$ in seconds from the combined constraints.\n  - Use $\\Delta t = 0.99\\,\\Delta t_{\\max}$ and evaluate $r$ and $\\mu$.\n  - Report $\\Delta t_{\\max}$ (in seconds), $r$, $\\mu$, and a boolean $S$ that is true if and only if $r \\le 1$ and $\\mu \\le 1/2$.\n\n- Test Case C (splitting error ratio at a moderate step):\n  - $L = 10{,}000$, $\\Delta x = 50$, $\\kappa = 10^{-6}$, $u = 0.05/31557600$, $\\phi = 0.3$.\n  - Compute $\\Delta t_{\\max}$; use $\\Delta t = 0.2\\,\\Delta t_{\\max}$ and $t_{\\mathrm{end}} = 100\\,\\Delta t$.\n  - Compute the ratio $R = E_{\\mathrm{Strang}}/E_{\\mathrm{Lie}}$ at the same $\\Delta t$.\n\nFinal output format:\n- Your program should produce a single line containing a comma-separated list enclosed in square brackets with the following entries in order:\n  - $p_{\\mathrm{Lie}}$ for Test Case A,\n  - $p_{\\mathrm{Strang}}$ for Test Case A,\n  - $\\Delta t_{\\max}$ for Test Case B (in seconds),\n  - $r$ for Test Case B,\n  - $\\mu$ for Test Case B,\n  - $S$ for Test Case B (a boolean),\n  - $R$ for Test Case C.\nFor example: \"[pLieA,pStrangA,dtmaxB,rB,muB,SB,Rc]\".", "solution": "We start from the one-dimensional advection–diffusion heat equation with constant coefficients,\n$$\n\\frac{\\partial T}{\\partial t} + u \\frac{\\partial T}{\\partial x} = \\kappa \\frac{\\partial^2 T}{\\partial x^2},\n$$\non a periodic domain of length $L$. The operator-splitting approach uses the decomposition into an advection operator $A$ and a diffusion operator $D$,\n$$\nA[T] = -u \\frac{\\partial T}{\\partial x}, \\qquad D[T] = \\kappa \\frac{\\partial^2 T}{\\partial x^2},\n$$\nso that the full generator is $L = A + D$.\n\nStability constraints are derived from Von Neumann analysis applied to the discrete substeps. For the advection substep, we choose an explicit first-order upwind scheme. On a uniform grid with spacing $\\Delta x$ and time step $\\Delta t$, when $u \\ge 0$ the update reads\n$$\nT_i^{n+1} = T_i^n - r\\,(T_i^n - T_{i-1}^n), \\quad r = \\frac{u\\,\\Delta t}{\\Delta x},\n$$\nwith periodic indexing. The amplification factor for a Fourier mode $e^{\\mathrm{i} k i \\Delta x}$ is\n$$\ng_A(k) = 1 - r\\,(1 - e^{-\\mathrm{i} k \\Delta x}).\n$$\nA standard result for the upwind scheme is that stability requires\n$$\n|g_A(k)| \\le 1 \\quad \\text{for all } k \\quad \\Longleftrightarrow \\quad 0 \\le r \\le 1,\n$$\nand by symmetry for $u \\le 0$ one requires $0 \\le |r| \\le 1$. Thus the advection CFL constraint is\n$$\nr = \\frac{|u|\\,\\Delta t}{\\Delta x} \\le 1 \\quad \\Longleftrightarrow \\quad \\Delta t \\le \\frac{\\Delta x}{|u|}.\n$$\n\nFor the diffusion substep, we use an explicit forward Euler central-difference scheme,\n$$\nT_i^{n+1} = T_i^n + \\mu\\,\\big(T_{i+1}^n - 2 T_i^n + T_{i-1}^n\\big), \\quad \\mu = \\frac{\\kappa\\,\\Delta t}{\\Delta x^2}.\n$$\nIts Fourier amplification factor is\n$$\ng_D(k) = 1 - 4\\mu \\sin^2\\!\\Big(\\frac{k \\Delta x}{2}\\Big).\n$$\nStability requires $|g_D(k)| \\le 1$ for all $k$, which holds if and only if\n$$\n0 \\le \\mu \\le \\frac{1}{2} \\quad \\Longleftrightarrow \\quad \\Delta t \\le \\frac{\\Delta x^2}{2\\kappa}.\n$$\n\nBecause we explicitly compose the substeps within each full time step, a sufficient combined stability condition is that both substeps be individually stable. Therefore the combined time-step constraint is\n$$\n\\Delta t \\le \\min\\!\\left(\\frac{\\Delta x}{|u|}, \\frac{\\Delta x^2}{2\\kappa}\\right) \\equiv \\Delta t_{\\max}.\n$$\n\nWe next justify the splitting-error orders. The exact solution operator over one time step is the semigroup $e^{\\Delta t (A+D)}$. Lie splitting applies $e^{\\Delta t A}$ followed by $e^{\\Delta t D}$, which can be related to the exact operator via the Baker–Campbell–Hausdorff (BCH) formula:\n$$\ne^{\\Delta t A} e^{\\Delta t D} = e^{\\Delta t (A+D) + \\frac{\\Delta t^2}{2}[A,D] + \\mathcal{O}(\\Delta t^3)},\n$$\nwhere $[A,D] = AD - DA$ is the commutator. As $[A,D] \\ne 0$ for $u \\ne 0$ and $\\kappa \\ne 0$, the local error per time step is $\\mathcal{O}(\\Delta t^2)$ and the global error after $t_{\\mathrm{end}}/\\Delta t$ steps accumulates to $\\mathcal{O}(\\Delta t)$. Thus Lie splitting is first order in time. Strang splitting uses the symmetric composition $e^{\\frac{\\Delta t}{2} A} e^{\\Delta t D} e^{\\frac{\\Delta t}{2} A}$, for which the BCH expansion yields cancellation of the leading commutator term and\n$$\ne^{\\frac{\\Delta t}{2} A} e^{\\Delta t D} e^{\\frac{\\Delta t}{2} A} = e^{\\Delta t (A+D) + \\mathcal{O}(\\Delta t^3)}.\n$$\nHence the local error is $\\mathcal{O}(\\Delta t^3)$ and the global error is $\\mathcal{O}(\\Delta t^2)$, i.e., second order in time.\n\nTo quantify the error, we compare to the exact periodic solution available spectrally. Let $N = L/\\Delta x$ and discrete wavenumbers $k_n = 2\\pi n/L$, with $n \\in \\{0,1,\\dots,N-1\\}$ mapped to signed frequencies using the standard discrete Fourier transform convention. If $\\widehat{T}(k_n,0)$ is the discrete Fourier transform of $T(\\cdot,0)$, then the exact evolution is\n$$\n\\widehat{T}(k_n,t) = \\widehat{T}(k_n,0)\\,\\exp\\!\\big(-\\kappa k_n^2 t\\big)\\,\\exp\\!\\big(-\\mathrm{i} k_n u t\\big),\n$$\nand the exact $T(\\cdot,t)$ is the inverse transform. Relative $\\ell^2$ errors use\n$$\nE = \\frac{\\|T_{\\mathrm{num}} - T_{\\mathrm{exact}}\\|_2}{\\|T_{\\mathrm{exact}}\\|_2},\n$$\nand the observed order is estimated by\n$$\np = \\frac{\\log\\big(E(\\Delta t)/E(\\Delta t/2)\\big)}{\\log 2}.\n$$\n\nAlgorithmic design for the program:\n- Construct the uniform grid $x_j = j\\,\\Delta x$ for $j = 0,1,\\dots,N-1$ with periodicity.\n- Initialize $T(x,0) = \\cos(2\\pi x/L) + \\frac{1}{2}\\cos(4\\pi x/L + \\phi)$ with $\\phi = 0.3$ (radians).\n- Define the explicit upwind advection substep. For $u \\ge 0$,\n$$\nT_j^{\\star} = T_j - r\\,(T_j - T_{j-1}), \\quad r = \\frac{u\\Delta t}{\\Delta x},\n$$\nand for $u  0$,\n$$\nT_j^{\\star} = T_j - r\\,(T_{j+1} - T_j), \\quad r = \\frac{u\\Delta t}{\\Delta x},\n$$\nwith periodic indexing for $j \\pm 1$.\n- Define the explicit forward Euler diffusion substep,\n$$\nT_j^{\\mathrm{new}} = T_j^{\\star} + \\mu\\,(T_{j+1}^{\\star} - 2 T_j^{\\star} + T_{j-1}^{\\star}), \\quad \\mu = \\frac{\\kappa \\Delta t}{\\Delta x^2}.\n$$\n- Compose substeps as per Lie and Strang for a chosen $\\Delta t$ and number of steps $n = t_{\\mathrm{end}}/\\Delta t$.\n- Compute the exact solution at $t_{\\mathrm{end}}$ using the discrete Fourier transform formula above.\n- Compute relative $\\ell^2$ errors and observed orders.\n- For stability metrics, compute $r$ and $\\mu$ for the chosen $\\Delta t$ and return whether $r \\le 1$ and $\\mu \\le 1/2$.\n\nWe apply this to the three specified test cases:\n\n- Test Case A:\n  - $L = 10{,}000$, $\\Delta x = 50$, $\\kappa = 10^{-6}$, $u = 0.05/31557600$, $\\phi = 0.3$.\n  - $\\Delta t_{\\max} = \\min\\!\\big(\\Delta x/|u|,\\ \\Delta x^2/(2\\kappa)\\big)$.\n  - Use $\\Delta t = 0.4\\,\\Delta t_{\\max}$, $t_{\\mathrm{end}} = 100\\,\\Delta t$.\n  - Compute $p_{\\mathrm{Lie}}$ and $p_{\\mathrm{Strang}}$.\n\n- Test Case B:\n  - $L = 200{,}000$, $\\Delta x = 1{,}000$, $\\kappa = 10^{-6}$, $u = 0.08/31557600$, $\\phi = 0.3$.\n  - Compute $\\Delta t_{\\max}$, then with $\\Delta t = 0.99\\,\\Delta t_{\\max}$ report $\\Delta t_{\\max}$, $r$, $\\mu$, and $S = (r \\le 1)\\wedge(\\mu \\le 1/2)$.\n\n- Test Case C:\n  - $L = 10{,}000$, $\\Delta x = 50$, $\\kappa = 10^{-6}$, $u = 0.05/31557600$, $\\phi = 0.3$.\n  - With $\\Delta t = 0.2\\,\\Delta t_{\\max}$ and $t_{\\mathrm{end}} = 100\\,\\Delta t$, compute $R = E_{\\mathrm{Strang}}/E_{\\mathrm{Lie}}$.\n\nAll time quantities must be expressed in seconds. The final printed output must be a single line in the format\n$$\n[\\ p_{\\mathrm{Lie}}^{(A)},\\ p_{\\mathrm{Strang}}^{(A)},\\ \\Delta t_{\\max}^{(B)},\\ r^{(B)},\\ \\mu^{(B)},\\ S^{(B)},\\ R^{(C)}\\ ].\n$$", "answer": "```python\nimport numpy as np\n\ndef upwind_advection_step(T, u, dx, dt):\n    \"\"\"First-order upwind advection with periodic boundaries.\"\"\"\n    r = u * dt / dx\n    if u >= 0.0:\n        return T - r * (T - np.roll(T, 1))\n    else:\n        return T - r * (np.roll(T, -1) - T)\n\ndef diffusion_step(T, kappa, dx, dt):\n    \"\"\"Explicit forward Euler diffusion (FTCS) with periodic boundaries.\"\"\"\n    mu = kappa * dt / (dx * dx)\n    return T + mu * (np.roll(T, -1) - 2.0 * T + np.roll(T, 1))\n\ndef lie_splitting(T0, u, kappa, dx, dt, nsteps):\n    \"\"\"Advance by nsteps of Lie splitting: A(dt) then D(dt).\"\"\"\n    T = T0.copy()\n    for _ in range(nsteps):\n        T = upwind_advection_step(T, u, dx, dt)\n        T = diffusion_step(T, kappa, dx, dt)\n    return T\n\ndef strang_splitting(T0, u, kappa, dx, dt, nsteps):\n    \"\"\"Advance by nsteps of Strang splitting: A(dt/2), D(dt), A(dt/2).\"\"\"\n    T = T0.copy()\n    half_dt = 0.5 * dt\n    for _ in range(nsteps):\n        T = upwind_advection_step(T, u, dx, half_dt)\n        T = diffusion_step(T, kappa, dx, dt)\n        T = upwind_advection_step(T, u, dx, half_dt)\n    return T\n\ndef exact_solution_fft(T0, u, kappa, L, dx, t):\n    \"\"\"Exact periodic solution via discrete Fourier transform.\"\"\"\n    N = T0.size\n    # Wavenumbers in radians per meter\n    k = 2.0 * np.pi * np.fft.fftfreq(N, d=dx)\n    T0_hat = np.fft.fft(T0)\n    phase = np.exp(-(kappa * (k ** 2)) * t) * np.exp(-1j * k * u * t)\n    T_hat_t = T0_hat * phase\n    T_t = np.fft.ifft(T_hat_t).real\n    return T_t\n\ndef initial_condition(x, L, phi):\n    \"\"\"Initial condition: cos(2π x/L) + 0.5 cos(4π x/L + phi).\"\"\"\n    return np.cos(2.0 * np.pi * x / L) + 0.5 * np.cos(4.0 * np.pi * x / L + phi)\n\ndef rel_l2_error(a, b):\n    denom = np.linalg.norm(b)\n    if denom == 0.0:\n        return np.inf\n    return np.linalg.norm(a - b) / denom\n\ndef combined_dt_max(dx, u, kappa):\n    \"\"\"Combined explicit stability limit: min(dx/|u|, dx^2/(2*kappa)).\"\"\"\n    adv = np.inf if u == 0.0 else dx / abs(u)\n    diff = (dx * dx) / (2.0 * kappa)\n    return min(adv, diff)\n\ndef observed_order(errors_dt, errors_dt2):\n    \"\"\"Compute observed order p = log(E(dt)/E(dt/2))/log(2).\"\"\"\n    if errors_dt == 0.0 or errors_dt2 == 0.0:\n        return np.nan\n    return np.log(errors_dt / errors_dt2) / np.log(2.0)\n\ndef run_test_case_A():\n    # Parameters\n    L = 10000.0\n    dx = 50.0\n    kappa = 1e-6\n    seconds_per_year = 365.25 * 24.0 * 3600.0\n    u = 0.05 / seconds_per_year  # 0.05 m/yr in m/s\n    phi = 0.3\n    N = int(round(L / dx))\n    x = np.arange(N) * dx\n    T0 = initial_condition(x, L, phi)\n\n    dt_max = combined_dt_max(dx, u, kappa)\n    dt = 0.4 * dt_max\n    dt2 = 0.5 * dt\n    nsteps = 100\n    tend = nsteps * dt\n\n    # Lie splitting errors at dt and dt/2\n    T_lie_dt = lie_splitting(T0, u, kappa, dx, dt, nsteps)\n    T_exact = exact_solution_fft(T0, u, kappa, L, dx, tend)\n    E_lie_dt = rel_l2_error(T_lie_dt, T_exact)\n\n    nsteps2 = int(round(tend / dt2))\n    T_lie_dt2 = lie_splitting(T0, u, kappa, dx, dt2, nsteps2)\n    E_lie_dt2 = rel_l2_error(T_lie_dt2, T_exact)\n\n    p_lie = observed_order(E_lie_dt, E_lie_dt2)\n\n    # Strang splitting errors at dt and dt/2\n    T_strang_dt = strang_splitting(T0, u, kappa, dx, dt, nsteps)\n    E_strang_dt = rel_l2_error(T_strang_dt, T_exact)\n\n    T_strang_dt2 = strang_splitting(T0, u, kappa, dx, dt2, nsteps2)\n    E_strang_dt2 = rel_l2_error(T_strang_dt2, T_exact)\n\n    p_strang = observed_order(E_strang_dt, E_strang_dt2)\n\n    return float(p_lie), float(p_strang)\n\ndef run_test_case_B():\n    L = 200000.0\n    dx = 1000.0\n    kappa = 1e-6\n    seconds_per_year = 365.25 * 24.0 * 3600.0\n    u = 0.08 / seconds_per_year  # 0.08 m/yr in m/s\n\n    dt_max = combined_dt_max(dx, u, kappa)\n    dt = 0.99 * dt_max\n    r = abs(u) * dt / dx\n    mu = kappa * dt / (dx * dx)\n    stable = (r = 1.0) and (mu = 0.5)\n    return float(dt_max), float(r), float(mu), bool(stable)\n\ndef run_test_case_C():\n    L = 10000.0\n    dx = 50.0\n    kappa = 1e-6\n    seconds_per_year = 365.25 * 24.0 * 3600.0\n    u = 0.05 / seconds_per_year  # 0.05 m/yr in m/s\n    phi = 0.3\n    N = int(round(L / dx))\n    x = np.arange(N) * dx\n    T0 = initial_condition(x, L, phi)\n\n    dt_max = combined_dt_max(dx, u, kappa)\n    dt = 0.2 * dt_max\n    nsteps = 100\n    tend = nsteps * dt\n\n    T_exact = exact_solution_fft(T0, u, kappa, L, dx, tend)\n\n    T_lie = lie_splitting(T0, u, kappa, dx, dt, nsteps)\n    E_lie = rel_l2_error(T_lie, T_exact)\n\n    T_strang = strang_splitting(T0, u, kappa, dx, dt, nsteps)\n    E_strang = rel_l2_error(T_strang, T_exact)\n\n    R = E_strang / E_lie if E_lie != 0.0 else np.nan\n    return float(R)\n\ndef solve():\n    # Run all test cases and aggregate results in the specified order.\n    p_lie_A, p_strang_A = run_test_case_A()\n    dtmax_B, r_B, mu_B, S_B = run_test_case_B()\n    R_C = run_test_case_C()\n\n    results = [p_lie_A, p_strang_A, dtmax_B, r_B, mu_B, S_B, R_C]\n    \n    # Format boolean as 'True' or 'False'\n    formatted_results = []\n    for r in results:\n        if isinstance(r, bool):\n            formatted_results.append(str(r))\n        else:\n            formatted_results.append(str(r))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3590410"}]}