{"hands_on_practices": [{"introduction": "Before a numerical model can be trusted for scientific investigation, its correctness must be rigorously established through a process called verification. The Method of Manufactured Solutions (MMS) is a powerful technique for this, allowing us to create a test case with a known analytical solution against which we can measure our code's error. This foundational exercise [@problem_id:3616973] guides you through implementing a 2D Helmholtz solver and using MMS to quantify its accuracy, a critical skill for any computational geophysicist.", "problem": "Consider the frequency-domain acoustic wave modeling governed by the Helmholtz equation. Start from the linear acoustic wave equation in a homogeneous medium with constant wavespeed $c$, written as $$\\frac{1}{c^2}\\frac{\\partial^2 p}{\\partial t^2} - \\nabla^2 p = s(\\mathbf{x}, t),$$ where $p(\\mathbf{x}, t)$ is the acoustic pressure field, $\\nabla^2$ is the Laplacian, and $s(\\mathbf{x}, t)$ is a source term. Assume a time-harmonic dependence $p(\\mathbf{x}, t) = \\Re\\{u(\\mathbf{x}) e^{-i \\omega t}\\}$ and similarly $s(\\mathbf{x}, t) = \\Re\\{f(\\mathbf{x}) e^{-i \\omega t}\\}$ with angular frequency $\\omega$. Denoting the wavenumber $k = \\omega/c$, derive the governing frequency-domain model on a bounded domain with Dirichlet boundary data (pressure set to zero on the boundary). You should obtain a Helmholtz-type boundary value problem that relates $u(\\mathbf{x})$ and $f(\\mathbf{x})$.\n\nVerification in computational geophysics should quantify discretization error using normed measures and the Method of Manufactured Solutions (MMS). In MMS, one prescribes a smooth exact solution $u_{\\text{exact}}(\\mathbf{x})$ and derives the corresponding source term $f(\\mathbf{x})$ by substituting into the continuous operator, ensuring that the boundary conditions are satisfied.\n\nImplement a verification procedure for the Helmholtz equation using MMS on the unit square domain $$\\Omega = [0,1]\\times[0,1]$$ with Dirichlet boundary conditions. Use the manufactured solution $$u_{\\text{exact}}(x,y) = \\sin(\\pi x)\\sin(2\\pi y),$$ which vanishes on $\\partial \\Omega$. Derive the required source function $f(x,y)$ by substituting $u_{\\text{exact}}$ into the continuous operator so that the exact solution satisfies the continuous Helmholtz equation.\n\nDiscretize $-\\nabla^2 u - k^2 u = f$ using the standard five-point, second-order accurate central difference scheme on a uniform grid. Let the number of interior grid points along each coordinate be $n$, the grid spacing be $h = 1/(n+1)$, and enforce the Dirichlet boundary condition by setting $u=0$ on the boundary nodes. Assemble the resulting linear system for the interior unknowns and solve it. Compare the computed solution $u_h$ sampled at interior nodes to the exact solution $u_{\\text{exact}}$ sampled at the same nodes.\n\nCompute the following error norms of the discrete error $e = u_h - u_{\\text{exact}}$:\n- The discrete $L^2$ norm $$\\|e\\|_{L^2,h} = \\left(h^2 \\sum_{i=1}^{n}\\sum_{j=1}^{n} e_{ij}^2\\right)^{1/2}.$$\n- The discrete $L^\\infty$ norm $$\\|e\\|_{L^\\infty,h} = \\max_{1\\le i,j\\le n} |e_{ij}|.$$\n- The discrete $H^1$ semi-norm approximated with central differences using boundary padding with zeros $$|e|_{H^1,h} = \\left(h^2 \\sum_{i=1}^{n}\\sum_{j=1}^{n} \\left[\\left(\\frac{e_{i+1,j}-e_{i-1,j}}{2h}\\right)^2 + \\left(\\frac{e_{i,j+1}-e_{i,j-1}}{2h}\\right)^2\\right]\\right)^{1/2},$$ where indices $0$ and $n+1$ refer to boundary nodes with $e=0$.\n\nYour program must implement the above and produce numerical values for the three norms for each of the specified test cases below. No physical units are required because the problem is non-dimensionalized; all outputs must be pure real numbers.\n\nTest suite:\n- Case $1$: $n=32$, $k=\\pi$.\n- Case $2$: $n=64$, $k=8\\pi$.\n- Case $3$: $n=8$, $k=2\\pi$.\n- Case $4$: $n=64$, $k=\\pi\\sqrt{4.9}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The ordering must be $$[\\|e\\|_{L^2,h}^{(1)}, \\|e\\|_{L^\\infty,h}^{(1)}, |e|_{H^1,h}^{(1)}, \\|e\\|_{L^2,h}^{(2)}, \\|e\\|_{L^\\infty,h}^{(2)}, |e|_{H^1,h}^{(2)}, \\|e\\|_{L^2,h}^{(3)}, \\|e\\|_{L^\\infty,h}^{(3)}, |e|_{H^1,h}^{(3)}, \\|e\\|_{L^2,h}^{(4)}, \\|e\\|_{L^\\infty,h}^{(4)}, |e|_{H^1,h}^{(4)}],$$ where the superscript ${}^{(m)}$ denotes test case $m$. All entries must be real-valued floats.", "solution": "The user has provided a problem that requires the verification of a numerical solver for the Helmholtz equation using the Method of Manufactured Solutions (MMS).\n\n### Step 1: Extract Givens\n\n-   **Governing Equation (Time Domain):** The linear acoustic wave equation in a homogeneous medium is given as $\\frac{1}{c^2}\\frac{\\partial^2 p}{\\partial t^2} - \\nabla^2 p = s(\\mathbf{x}, t)$, where $p$ is pressure, $c$ is wavespeed, and $s$ is the source term.\n-   **Time-Harmonic Assumption:** The pressure $p(\\mathbf{x}, t)$ and source $s(\\mathbf{x}, t)$ are assumed to have time-harmonic forms $p(\\mathbf{x}, t) = \\Re\\{u(\\mathbf{x}) e^{-i \\omega t}\\}$ and $s(\\mathbf{x}, t) = \\Re\\{f(\\mathbf{x}) e^{-i \\omega t}\\}$, where $\\omega$ is the angular frequency.\n-   **Wavenumber Definition:** The wavenumber is $k = \\omega/c$.\n-   **Domain and Boundary Conditions:** The domain is the unit square $\\Omega = [0,1]\\times[0,1]$, with Dirichlet boundary conditions $u=0$ on the boundary $\\partial \\Omega$.\n-   **Manufactured Solution:** The prescribed exact solution is $u_{\\text{exact}}(x,y) = \\sin(\\pi x)\\sin(2\\pi y)$.\n-   **Discretization Scheme:** A standard five-point, second-order accurate central difference scheme on a uniform grid is to be used.\n-   **Grid Parameters:** The number of interior grid points along each coordinate is $n$, and the grid spacing is $h = 1/(n+1)$.\n-   **Error Norms to Compute:**\n    1.  Discrete $L^2$ norm: $\\|e\\|_{L^2,h} = \\left(h^2 \\sum_{i=1}^{n}\\sum_{j=1}^{n} e_{ij}^2\\right)^{1/2}$.\n    2.  Discrete $L^\\infty$ norm: $\\|e\\|_{L^\\infty,h} = \\max_{1\\le i,j\\le n} |e_{ij}|$.\n    3.  Discrete $H^1$ semi-norm: $|e|_{H^1,h} = \\left(h^2 \\sum_{i=1}^{n}\\sum_{j=1}^{n} \\left[\\left(\\frac{e_{i+1,j}-e_{i-1,j}}{2h}\\right)^2 + \\left(\\frac{e_{i,j+1}-e_{i,j-1}}{2h}\\right)^2\\right]\\right)^{1/2}$, with boundary padding $e=0$.\n-   **Test Cases:**\n    1.  $n=32$, $k=\\pi$.\n    2.  $n=64$, $k=8\\pi$.\n    3.  $n=8$, $k=2\\pi$.\n    4.  $n=64$, $k=\\pi\\sqrt{4.9}$.\n\n### Step 2: Validate Using Extracted Givens\n\nThe problem is reviewed against the validation criteria.\n\n-   **Scientifically Grounded:** The problem is based on the acoustic wave equation and its frequency-domain representation, the Helmholtz equation, which are fundamental concepts in physics and engineering. The Method of Manufactured Solutions is a standard and rigorous technique for code verification in computational science. The discretization and error analysis methods are also standard in numerical analysis. The problem is scientifically sound.\n-   **Well-Posed:** For a given source term $f$, the Helmholtz equation with Dirichlet boundary conditions is a well-posed boundary value problem, provided that $k^2$ is not an eigenvalue of the negative Laplacian operator on the domain. The manufactured solution $u_{\\text{exact}}$ corresponds to an eigenfunction of the Laplacian. The corresponding eigenvalue is $\\lambda = (1^2+2^2)\\pi^2 = 5\\pi^2$. The problem becomes resonant if $k^2=5\\pi^2$. Test case $4$ sets $k^2=4.9\\pi^2$, which is near resonance. This makes the problem numerically challenging (ill-conditioned) but not ill-posed, as a unique solution still exists. This is a common and valid test for Helmholtz solvers. The problem is well-posed.\n-   **Objective:** The problem is stated using precise mathematical and computational terminology. The tasks, parameters, and required output format are defined unambiguously.\n-   **Completeness and Consistency:** All necessary information is provided: the PDE, domain, boundary conditions, manufactured solution, discretization stencil, grid definitions, error norm formulas, and test parameters. The information is internally consistent. For example, the manufactured solution correctly satisfies the zero Dirichlet boundary conditions on the unit square.\n\n### Step 3: Verdict and Action\n\nThe problem statement is **valid**. It is scientifically sound, well-posed, objective, and complete. I will proceed with a full solution.\n\n### Principle-Based Solution\n\nThe solution procedure is structured as follows: First, we derive the continuous frequency-domain model (the Helmholtz equation) and the corresponding manufactured source term. Second, we describe the discretization of this model into a system of linear equations. Third, we outline the process for solving this system and computing the required error norms.\n\n**1. Derivation of the Helmholtz Equation and Manufactured Source**\n\nWe begin with the acoustic wave equation:\n$$\n\\frac{1}{c^2}\\frac{\\partial^2 p(\\mathbf{x}, t)}{\\partial t^2} - \\nabla^2 p(\\mathbf{x}, t) = s(\\mathbf{x}, t)\n$$\nSubstituting the time-harmonic forms $p(\\mathbf{x}, t) = \\Re\\{u(\\mathbf{x}) e^{-i \\omega t}\\}$ and $s(\\mathbf{x}, t) = \\Re\\{f(\\mathbf{x}) e^{-i \\omega t}\\}$ yields:\n$$\n\\frac{\\partial p}{\\partial t} = \\Re\\{-i\\omega u(\\mathbf{x}) e^{-i\\omega t}\\}, \\quad \\frac{\\partial^2 p}{\\partial t^2} = \\Re\\{(-i\\omega)^2 u(\\mathbf{x}) e^{-i\\omega t}\\} = \\Re\\{-\\omega^2 u(\\mathbf{x}) e^{-i\\omega t}\\}\n$$\n$$\n\\nabla^2 p = \\Re\\{\\nabla^2 u(\\mathbf{x}) e^{-i\\omega t}\\}\n$$\nThe wave equation becomes:\n$$\n\\Re\\left\\{-\\frac{\\omega^2}{c^2} u(\\mathbf{x}) e^{-i\\omega t} - \\nabla^2 u(\\mathbf{x}) e^{-i\\omega t} - f(\\mathbf{x}) e^{-i\\omega t}\\right\\} = 0\n$$\nSince this must hold for all time $t$, the term in the curly braces must be zero. Using the wavenumber $k = \\omega/c$, we obtain the Helmholtz equation:\n$$\n-\\nabla^2 u(\\mathbf{x}) - k^2 u(\\mathbf{x}) = f(\\mathbf{x})\n$$\nThe problem is defined on the domain $\\Omega = [0,1]\\times[0,1]$ with the boundary condition $u(\\mathbf{x})=0$ for $\\mathbf{x} \\in \\partial\\Omega$.\n\nFor the Method of Manufactured Solutions, we assume an exact solution $u_{\\text{exact}}(x,y) = \\sin(\\pi x)\\sin(2\\pi y)$ and derive the source term $f(x,y)$ that makes it a solution. This $u_{\\text{exact}}$ satisfies the zero Dirichlet boundary conditions on $\\partial\\Omega$. We substitute $u_{\\text{exact}}$ into the Helmholtz operator:\n$$\nf(x,y) = -\\nabla^2 u_{\\text{exact}}(x,y) - k^2 u_{\\text{exact}}(x,y)\n$$\nWe compute the partial derivatives:\n$$\n\\frac{\\partial^2 u_{\\text{exact}}}{\\partial x^2} = \\frac{\\partial^2}{\\partial x^2} \\left[ \\sin(\\pi x)\\sin(2\\pi y) \\right] = -\\pi^2 \\sin(\\pi x)\\sin(2\\pi y) = -\\pi^2 u_{\\text{exact}}\n$$\n$$\n\\frac{\\partial^2 u_{\\text{exact}}}{\\partial y^2} = \\frac{\\partial^2}{\\partial y^2} \\left[ \\sin(\\pi x)\\sin(2\\pi y) \\right] = -4\\pi^2 \\sin(\\pi x)\\sin(2\\pi y) = -4\\pi^2 u_{\\text{exact}}\n$$\nThe Laplacian is $\\nabla^2 u_{\\text{exact}} = \\frac{\\partial^2 u_{\\text{exact}}}{\\partial x^2} + \\frac{\\partial^2 u_{\\text{exact}}}{\\partial y^2} = (-\\pi^2 - 4\\pi^2) u_{\\text{exact}} = -5\\pi^2 u_{\\text{exact}}$.\nSubstituting this into the expression for $f(x,y)$:\n$$\nf(x,y) = -(-5\\pi^2 u_{\\text{exact}}) - k^2 u_{\\text{exact}} = (5\\pi^2 - k^2) u_{\\text{exact}}\n$$\nThus, the required source term is:\n$$\nf(x,y) = (5\\pi^2 - k^2) \\sin(\\pi x)\\sin(2\\pi y)\n$$\n\n**2. Discretization and Linear System Assembly**\n\nWe discretize the domain with a uniform grid where the coordinates of the grid points are $(x_i, y_j) = (ih, jh)$ for $i,j \\in \\{0, 1, \\dots, n+1\\}$, with grid spacing $h = 1/(n+1)$. The interior points correspond to indices $i,j \\in \\{1, \\dots, n\\}$.\nThe Helmholtz equation is discretized at each interior point $(x_i, y_j)$ using a five-point central difference stencil for the negative Laplacian:\n$$\n-\\nabla^2 u \\Big|_{(x_i, y_j)} \\approx \\frac{4u_{i,j} - u_{i-1,j} - u_{i+1,j} - u_{i,j-1} - u_{i,j+1}}{h^2}\n$$\nwhere $u_{i,j} \\approx u(x_i, y_j)$. The discrete equation at point $(i,j)$ is:\n$$\n\\frac{4u_{i,j} - u_{i-1,j} - u_{i+1,j} - u_{i,j-1} - u_{i,j+1}}{h^2} - k^2 u_{i,j} = f_{i,j}\n$$\nwhere $f_{i,j} = f(x_i, y_j)$. This system of $n^2$ linear equations for the $n^2$ unknown interior values $u_{i,j}$ can be written in matrix form as $A \\mathbf{u}_h = \\mathbf{f}_h$. The unknown vector $\\mathbf{u}_h$ is formed by flattening the $n \\times n$ grid of $u_{i,j}$ values into a vector of size $N=n^2$. Using row-major ordering, the index $p$ in the vector corresponding to grid point $(i,j)$ (with $1$-based indices for grid points, $0$-based for programming) is $p = (i-1)n + (j-1)$. The matrix $A$ is a sparse, symmetric $N \\times N$ matrix. Its entries are determined by the stencil:\n-   Diagonal entries: $A_{p,p} = \\frac{4}{h^2} - k^2$.\n-   Off-diagonal entries: non-zero values of $-\\frac{1}{h^2}$ for neighbors, corresponding to vector offsets $\\pm 1$ and $\\pm n$.\n\n**3. Error Computation**\n\nAfter solving $A \\mathbf{u}_h = \\mathbf{f}_h$ for the numerical solution $\\mathbf{u}_h$, we reshape it into an $n \\times n$ grid $U_h$. The exact solution $u_{\\text{exact}}(x,y)$ is evaluated on the same interior grid points to get the grid $U_{\\text{exact}}$. The discrete error is the difference $E = U_h - U_{\\text{exact}}$. The required norms are then computed as follows:\n\n-   **$L^2$ Norm:** This norm is an approximation of the integral $\\int |e|^2 d\\mathbf{x}$. It is computed as $\\|e\\|_{L^2,h} = h (\\sum_{i=1}^n \\sum_{j=1}^n e_{ij}^2)^{1/2}$.\n\n-   **$L^\\infty$ Norm:** This norm measures the maximum pointwise error on the grid: $\\|e\\|_{L^\\infty,h} = \\max_{1\\le i,j\\le n} |e_{ij}|$.\n\n-   **$H^1$ Semi-norm:** This norm approximates the $L^2$ norm of the gradient of the error, $\\int |\\nabla e|^2 d\\mathbf{x}$. The gradient components are approximated using central differences. To handle boundary points in the stencil, the error grid $E$ is padded with a layer of zeros, reflecting the fact that the error is zero on the boundary. The derivatives at an interior point $(i,j)$ are $\\frac{\\partial e}{\\partial x}\\big|_{ij} \\approx \\frac{e_{i+1,j}-e_{i-1,j}}{2h}$ and $\\frac{\\partial e}{\\partial y}\\big|_{ij} \\approx \\frac{e_{i,j+1}-e_{i,j-1}}{2h}$. The norm is calculated by summing the squares of these approximate derivatives over all interior points, multiplying by $h^2$, and taking the square root.\n\nThe implementation will automate these steps for each test case.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import diags\nfrom scipy.sparse.linalg import spsolve\n\ndef solve():\n    \"\"\"\n    Main solver function that runs all test cases and prints the results.\n    \"\"\"\n    test_cases = [\n        # Case 1: n=32, k=pi\n        (32, np.pi),\n        # Case 2: n=64, k=8*pi\n        (64, 8 * np.pi),\n        # Case 3: n=8, k=2*pi\n        (8, 2 * np.pi),\n        # Case 4: n=64, k=pi*sqrt(4.9)\n        (64, np.pi * np.sqrt(4.9)),\n    ]\n\n    results = []\n    for n, k in test_cases:\n        l2_norm, linf_norm, h1_semi_norm = solve_helmholtz_mms(n, k)\n        results.extend([l2_norm, linf_norm, h1_semi_norm])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef solve_helmholtz_mms(n, k):\n    \"\"\"\n    Solves the Helmholtz BVP using MMS for a given n and k, and returns error norms.\n\n    Args:\n        n (int): Number of interior grid points along one dimension.\n        k (float): Wavenumber.\n\n    Returns:\n        tuple: A tuple containing the L2 norm, L-infinity norm, and H1 semi-norm of the error.\n    \"\"\"\n    # 1. Grid setup\n    h = 1.0 / (n + 1)\n    # Create coordinates for the n interior points\n    interior_coords = np.linspace(h, 1.0 - h, n)\n    # Create a meshgrid for evaluating functions on the 2D interior grid\n    # 'ij' indexing ensures Xi changes along rows (index i) and Yi along columns (index j)\n    Xi, Yi = np.meshgrid(interior_coords, interior_coords, indexing='ij')\n\n    # 2. Define manufactured solution and source term\n    def u_exact_func(x, y):\n        return np.sin(np.pi * x) * np.sin(2 * np.pi * y)\n\n    def source_func(x, y, k_val):\n        # f = (5*pi^2 - k^2) * u_exact\n        return (5 * np.pi**2 - k_val**2) * u_exact_func(x, y)\n\n    # 3. Evaluate exact solution and source on the grid\n    U_exact = u_exact_func(Xi, Yi)\n    F = source_func(Xi, Yi, k)\n    # Flatten the source term grid into a vector for the linear system solver.\n    # 'C' (row-major) order is consistent with the matrix assembly.\n    f_vec = F.flatten(order='C')\n\n    # 4. Assemble the discrete operator matrix A\n    N = n * n\n    h2 = h**2\n\n    # Main diagonal: (4/h^2 - k^2)\n    main_diag = np.full(N, 4.0 / h2 - k**2)\n\n    # Off-diagonals for x- and y-derivatives\n    off_diag_val = -1.0 / h2\n    \n    # Offsets +/- 1 correspond to y-neighbors (-u_j-1, -u_j+1)\n    off_diag1 = np.full(N - 1, off_diag_val)\n    # Remove connections at grid row boundaries\n    off_diag1[n-1::n] = 0.0\n    \n    # Offsets +/- n correspond to x-neighbors (-u_i-1, -u_i+1)\n    off_diagn = np.full(N - n, off_diag_val)\n\n    diagonals = [main_diag, off_diag1, off_diag1, off_diagn, off_diagn]\n    offsets = [0, -1, 1, -n, n]\n    \n    # 'csc' format is efficient for the direct solver spsolve\n    A = diags(diagonals, offsets, shape=(N, N), format='csc')\n\n    # 5. Solve the linear system Au_h = f_h\n    u_h_vec = spsolve(A, f_vec)\n    \n    # Reshape the solution vector back to a 2D grid\n    U_h = u_h_vec.reshape((n, n), order='C')\n\n    # 6. Calculate the error and norms\n    E = U_h - U_exact\n\n    # Discrete L2 norm\n    norm_L2 = h * np.linalg.norm(E.flatten('C'))\n\n    # Discrete L-infinity norm\n    norm_Linf = np.max(np.abs(E))\n\n    # Discrete H1 semi-norm\n    # Pad error grid with zeros to handle boundary conditions in difference stencils\n    E_padded = np.zeros((n + 2, n + 2))\n    E_padded[1:-1, 1:-1] = E\n    \n    # Approximate derivatives using central differences on the interior grid\n    dEdx = (E_padded[2:, 1:-1] - E_padded[:-2, 1:-1]) / (2 * h)\n    dEdy = (E_padded[1:-1, 2:] - E_padded[1:-1, :-2]) / (2 * h)\n    \n    # Calculate the norm from the derivatives\n    h1_seminorm_sq = h**2 * np.sum(dEdx**2 + dEdy**2)\n    norm_H1_semi = np.sqrt(h1_seminorm_sq)\n\n    return norm_L2, norm_Linf, norm_H1_semi\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3616973"}, {"introduction": "After verifying that a code correctly solves the mathematical equations, the next crucial step is validating that it accurately captures the underlying physics. This practice [@problem_id:3616960] focuses on validation by testing source-receiver reciprocity, a physical principle rooted in the symmetry of the Helmholtz operator. By simulating wavefields in both homogeneous and heterogeneous media, you will confirm that your numerical model upholds this law, building confidence in its ability to generate physically meaningful results.", "problem": "You are to implement a verification program for the acoustic Helmholtz equation in the frequency domain that validates numerical modeling via reciprocity and operator symmetry. The governing physical starting point is the second-order scalar acoustic wave equation for pressure in an isotropic medium of constant density, written as $\\partial_{tt} p(\\mathbf{x},t) = c(\\mathbf{x})^2 \\nabla^2 p(\\mathbf{x},t) + s(\\mathbf{x},t)$, where $p$ is pressure, $c(\\mathbf{x})$ is wave speed, $\\nabla^2$ is the Laplacian, and $s$ is a source term. Under the time-harmonic ansatz $p(\\mathbf{x},t) = \\Re\\{ u(\\mathbf{x}) e^{-i \\omega t} \\}$ with angular frequency $\\omega = 2 \\pi f$, the frequency-domain field $u(\\mathbf{x})$ satisfies a Helmholtz equation of the form $\\nabla^2 u(\\mathbf{x}) + k(\\mathbf{x})^2 u(\\mathbf{x}) = q(\\mathbf{x})$, where $k(\\mathbf{x}) = \\omega m(\\mathbf{x})$ and $m(\\mathbf{x}) = 1 / c(\\mathbf{x})$ is the slowness. In the frequency-domain setting with homogeneous Dirichlet boundary conditions $u(\\mathbf{x}) = 0$ on the boundary of the domain, the continuous operator is self-adjoint when $c(\\mathbf{x})$ is real.\n\nYour task is to:\n- Discretize the Helmholtz equation on a two-dimensional Cartesian grid using the standard second-order central difference for the Laplacian on the interior nodes only (Dirichlet boundary values are set to $0$ and are not part of the unknowns). Use a five-point stencil on the interior grid.\n- Assemble the resulting linear system $A u = b$ where $A$ is a real sparse matrix. The discrete wavenumber term $k(\\mathbf{x})^2$ should enter as a pointwise diagonal addition to the discrete Laplacian.\n- Implement point sources as discrete Kronecker deltas applied at specified interior grid indices, i.e., $b$ is zero everywhere except at the source index where it equals $1$.\n- Solve the linear system for multiple source configurations and verify reciprocity numerically: for two source indices $i$ and $j$, compute the scalar residual $r = | u^{(i)}_j - u^{(j)}_i |$, where $u^{(i)}$ denotes the solution associated with a right-hand side $b$ with a unit source at $i$, and $u^{(i)}_j$ denotes the value at index $j$ in that solution. Additionally, verify the operator symmetry by computing the relative residual $s = \\| A - A^\\top \\| / \\| A \\|$, where $\\| \\cdot \\|$ is any consistent matrix norm.\n- All quantities are to be treated as dimensionless in the output. Physical parameters such as length and frequency should be interpreted in meters and Hertz respectively, but you will not output any quantity with physical units. Angles are not involved in this problem.\n\nUse the following test suite, which specifies input parameters for three distinct cases that cover a general case, a heterogeneous medium case, and a boundary-proximity case. In every case, the domain is a rectangle of size $L_x \\times L_y$ with uniform grid spacing. Let $N_x$ and $N_y$ be the total number of grid points in the $x$ and $y$ directions, respectively, and let the number of interior points be $N_x^\\text{int} = N_x - 2$ and $N_y^\\text{int} = N_y - 2$. The grid spacing is $h = L_x / (N_x - 1) = L_y / (N_y - 1)$. The slowness $m(\\mathbf{x})$ is piecewise constant as specified.\n\n- Test Case $1$ (Homogeneous medium, interior sources):\n    - $N_x = 50$, $N_y = 50$.\n    - $L_x = 1000$, $L_y = 1000$.\n    - Frequency $f = 5$ Hertz, $\\omega = 2 \\pi f$.\n    - Wave speed $c_0 = 1500$ meters per second, slowness $m_0 = 1 / c_0$.\n    - $m(\\mathbf{x}) = m_0$ everywhere.\n    - Source indices in interior coordinates: $i = \\left( \\left\\lfloor N_x^\\text{int} / 3 \\right\\rfloor, \\left\\lfloor N_y^\\text{int} / 2 \\right\\rfloor \\right) $, $j = \\left( \\left\\lfloor 2 N_x^\\text{int} / 3 \\right\\rfloor, \\left\\lfloor N_y^\\text{int} / 2 \\right\\rfloor \\right) $.\n\n- Test Case $2$ (Heterogeneous medium with circular inclusion):\n    - $N_x = 50$, $N_y = 50$.\n    - $L_x = 1000$, $L_y = 1000$.\n    - Frequency $f = 5$ Hertz, $\\omega = 2 \\pi f$.\n    - Background wave speed $c_0 = 1500$ meters per second, background slowness $m_0 = 1 / c_0$.\n    - Inclusion wave speed $c_1 = 2000$ meters per second, inclusion slowness $m_1 = 1 / c_1$.\n    - Circular inclusion centered at $(L_x / 2, L_y / 2)$ with radius $R = 200$ meters; set $m(\\mathbf{x}) = m_1$ inside the circle and $m(\\mathbf{x}) = m_0$ outside.\n    - Source indices in interior coordinates: $i = (10, 30)$, $j = (35, 15)$.\n\n- Test Case $3$ (Homogeneous medium, sources near the boundary):\n    - $N_x = 50$, $N_y = 50$.\n    - $L_x = 1000$, $L_y = 1000$.\n    - Frequency $f = 8$ Hertz, $\\omega = 2 \\pi f$.\n    - Wave speed $c_0 = 1500$ meters per second, slowness $m_0 = 1 / c_0$.\n    - $m(\\mathbf{x}) = m_0$ everywhere.\n    - Source indices in interior coordinates: $i = (1, 1)$, $j = (N_x^\\text{int} - 2, N_y^\\text{int} - 2)$.\n\nPrecise algorithmic requirements:\n- Assemble the interior-only linear system $A u = b$ using the five-point stencil for $\\nabla^2$ on a rectangular grid with spacing $h$ and include the diagonal term $k(\\mathbf{x})^2$ at each interior node, with $k(\\mathbf{x}) = \\omega m(\\mathbf{x})$. Boundaries enforce $u = 0$ and do not appear in $A$ or $b$.\n- For each test case, construct $A$ and compute both the symmetry residual $s$ and the reciprocity residual $r$ for the specified source pair.\n- Use double-precision arithmetic.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered as $[ s_1, r_1, s_2, r_2, s_3, r_3 ]$ where $s_k$ and $r_k$ are the symmetry and reciprocity residuals for test case $k$. Each element must be a real number (float). No additional output is allowed on any other line.", "solution": "The task is to implement a numerical verification of operator symmetry and source-receiver reciprocity for the two-dimensional acoustic Helmholtz equation. The verification will be performed on a finite-difference discretization of the operator.\n\nThe governing equation in the frequency domain is the Helmholtz equation:\n$$ \\nabla^2 u(\\mathbf{x}) + k(\\mathbf{x})^2 u(\\mathbf{x}) = q(\\mathbf{x}) $$\nwhere $u(\\mathbf{x})$ is the complex-valued pressure field at angular frequency $\\omega$, $\\mathbf{x} \\in \\mathbb{R}^2$ is the spatial coordinate, $q(\\mathbf{x})$ is the source term, and $k(\\mathbf{x})$ is the spatially varying wavenumber. The wavenumber is defined as $k(\\mathbf{x}) = \\omega m(\\mathbf{x})$, where $m(\\mathbf{x}) = 1/c(\\mathbf{x})$ is the medium's slowness, the reciprocal of the wave speed $c(\\mathbf{x})$. The problem specifies homogeneous Dirichlet boundary conditions, $u(\\mathbf{x}) = 0$, on the boundary of a rectangular domain. For a real-valued slowness function $m(\\mathbf{x})$, the Helmholtz operator $L = \\nabla^2 + k(\\mathbf{x})^2$ is self-adjoint, a property that gives rise to reciprocity.\n\nThe primary steps are the discretization of this equation, the assembly of the corresponding linear system, and the numerical verification of its fundamental properties.\n\n**1. Finite-Difference Discretization**\n\nWe discretize the domain $\\Omega = [0, L_x] \\times [0, L_y]$ using a uniform Cartesian grid with $N_x$ and $N_y$ points in each direction. The grid spacing is $h = L_x / (N_x - 1) = L_y / (N_y - 1)$. The set of unknowns consists of the field values $u$ at the interior grid points only. The number of interior points are $N_x^\\text{int} = N_x - 2$ and $N_y^\\text{int} = N_y - 2$. An interior grid point is denoted by indices $(i_x, i_y)$, where $i_x \\in \\{0, \\dots, N_x^\\text{int}-1\\}$ and $i_y \\in \\{0, \\dots, N_y^\\text{int}-1\\}$.\n\nThe Laplacian operator $\\nabla^2$ at an interior point $(i_x, i_y)$ is approximated using a second-order, five-point central difference stencil:\n$$ \\nabla^2 u |_{(i_x,i_y)} \\approx \\frac{u_{i_x+1, i_y} + u_{i_x-1, i_y} + u_{i_x, i_y+1} + u_{i_x, i_y-1} - 4u_{i_x, i_y}}{h^2} $$\nSubstituting this into the Helmholtz equation yields the discrete equation for each interior node $(i_x, i_y)$:\n$$ \\frac{u_{i_x+1, i_y} + u_{i_x-1, i_y} + u_{i_x, i_y+1} + u_{i_x, i_y-1} - 4u_{i_x, i_y}}{h^2} + k_{i_x, i_y}^2 u_{i_x, i_y} = q_{i_x, i_y} $$\nwhere $u_{i_x, i_y}$ represents the field at the grid point and $k_{i_x, i_y} = \\omega m_{i_x, i_y}$ is the discrete wavenumber. The terms corresponding to neighbors on the domain boundary are zero due to the homogeneous Dirichlet condition and are thus omitted from the system of equations for the interior nodes.\n\n**2. Linear System Assembly**\n\nThe set of $N_{unk} = N_x^\\text{int} \\times N_y^\\text{int}$ discrete equations forms a linear system $A \\mathbf{u} = \\mathbf{b}$. The vector of unknowns $\\mathbf{u}$ is formed by flattening the 2D grid of interior values $u_{i_x, i_y}$ into a 1D vector. We adopt a row-major mapping, where the 1D index $p$ corresponding to the 2D index pair $(i_x, i_y)$ is $p = i_y \\cdot N_x^\\text{int} + i_x$.\n\nThe matrix $A$ is a sparse matrix of size $N_{unk} \\times N_{unk}$. Based on the discrete equation, the entry in row $p$ (corresponding to node $(i_x, i_y)$) is constructed as follows:\n- The diagonal entry is $A_{p,p} = k_{i_x,i_y}^2 - \\frac{4}{h^2}$.\n- The off-diagonal entries corresponding to the four neighbors are $A_{p, p'} = \\frac{1}{h^2}$. For a neighbor at $(i_x', i_y')$, its 1D index is $p'$.\nThis structure results in a block-tridiagonal matrix. Since the finite-difference stencil is symmetric and the wavenumber term $k^2$ only affects the main diagonal, the resulting matrix $A$ is symmetric, i.e., $A = A^\\top$, provided all quantities are real.\n\nThe right-hand side vector $\\mathbf{b}$ represents the discretized source term $q(\\mathbf{x})$. For a unit point source at an interior location with 1D index $s$, the vector $\\mathbf{b}$ is a Kronecker delta: $b_p = \\delta_{ps}$.\n\n**3. Verification of Symmetry and Reciprocity**\n\nThe symmetry of the constructed discrete operator $A$ is a direct consequence of the discretization scheme. We verify this numerically by computing the relative residual of the difference between $A$ and its transpose $A^\\top$:\n$$ s = \\frac{\\| A - A^\\top \\|_F}{\\| A \\|_F} $$\nwhere $\\| \\cdot \\|_F$ denotes the Frobenius norm. For a perfectly symmetric matrix, $s$ should be zero up to machine precision.\n\nReciprocity is a physical principle stemming from the self-adjointness of the governing operator. For a self-adjoint operator, the Green's function $G(\\mathbf{x}, \\mathbf{x}')$ is symmetric: $G(\\mathbf{x}, \\mathbf{x}') = G(\\mathbf{x}', \\mathbf{x})$. The solution for a point source at $\\mathbf{x}_i$ is $u^{(i)}(\\mathbf{x}) = G(\\mathbf{x}, \\mathbf{x}_i)$. Thus, the field at $\\mathbf{x}_j$ due to a source at $\\mathbf{x}_i$ is equal to the field at $\\mathbf{x}_i$ due to a source at $\\mathbf{x}_j$.\nIn the discrete setting, this translates to $u^{(i)}_j = u^{(j)}_i$. Here, $\\mathbf{u}^{(i)} = A^{-1} \\mathbf{b}^{(i)}$ is the solution vector for a unit source at index $i$, and $u^{(i)}_j$ is the component of that solution at index $j$. This equality follows from the symmetry of the inverse matrix, $(A^{-1})_{ji} = (A^{-1})_{ij}$, which itself is a consequence of the symmetry of $A$. We verify reciprocity by computing the absolute residual:\n$$ r = | u^{(i)}_j - u^{(j)}_i | $$\nThis value is also expected to be close to zero.\n\n**4. Implementation Procedure**\n\nFor each test case, the following procedure is executed:\n1.  Compute simulation parameters: grid spacing $h$, interior grid dimensions $N_x^\\text{int}, N_y^\\text{int}$, and angular frequency $\\omega$.\n2.  Construct the 2D slowness model $m(x,y)$ on the interior grid based on the case specifications. For the heterogeneous case, a point-wise check against the circular inclusion's geometry is performed.\n3.  Assemble the sparse matrix $A$ of size $(N_{unk} \\times N_{unk})$ using the five-point stencil logic and the squared wavenumber term $k^2 = (\\omega m)^2$ on the diagonal. A sparse format such as `scipy.sparse.csc_matrix` is used for efficiency.\n4.  Compute the symmetry residual $s$.\n5.  Identify the 1D indices, $p_i$ and $p_j$, for the two specified source locations.\n6.  Construct two right-hand side vectors, $\\mathbf{b}^{(i)}$ and $\\mathbf{b}^{(j)}$, each representing a unit impulse source.\n7.  Solve the two linear systems $A \\mathbf{u}^{(i)} = \\mathbf{b}^{(i)}$ and $A \\mathbf{u}^{(j)} = \\mathbf{b}^{(j)}$ using a sparse linear solver.\n8.  Extract the required solution components: $u^{(i)}_{p_j} = (\\mathbf{u}^{(i)})_{p_j}$ and $u^{(j)}_{p_i} = (\\mathbf{u}^{(j)})_{p_i}$.\n9.  Compute the reciprocity residual $r$.\n10. Store the pair $(s, r)$ for final output.\nThis process is repeated for all three test cases, and the results are aggregated.", "answer": "```python\nimport numpy as np\nimport scipy.sparse as sp\nimport scipy.sparse.linalg as spla\nimport math\n\ndef run_case(params):\n    \"\"\"\n    Runs a single test case for Helmholtz equation verification.\n\n    Args:\n        params (dict): A dictionary containing all parameters for the test case.\n\n    Returns:\n        tuple: A tuple containing the symmetry residual (s) and reciprocity residual (r).\n    \"\"\"\n    Nx = params[\"Nx\"]\n    Ny = params[\"Ny\"]\n    Lx = params[\"Lx\"]\n    Ly = params[\"Ly\"]\n    f = params[\"f\"]\n    m_model_spec = params[\"m_model\"]\n    src_indices = params[\"sources\"]\n\n    # 1. Calculate derived parameters\n    Nx_int = Nx - 2\n    Ny_int = Ny - 2\n    N_unk = Nx_int * Ny_int\n    h = Lx / (Nx - 1)\n    omega = 2.0 * np.pi * f\n    \n    # 2. Create slowness model\n    c0 = m_model_spec.get(\"c0\", 1500.0)\n    m0 = 1.0 / c0\n    \n    m_interior = np.full((Ny_int, Nx_int), m0, dtype=np.float64)\n\n    if m_model_spec[\"type\"] == \"heterogeneous\":\n        c1 = m_model_spec[\"c1\"]\n        m1 = 1.0 / c1\n        center_x, center_y = m_model_spec[\"center\"]\n        radius_sq = m_model_spec[\"radius\"]**2\n        \n        for iy in range(Ny_int):\n            for ix in range(Nx_int):\n                # Physical coordinates of the interior grid point\n                x = (ix + 1) * h\n                y = (iy + 1) * h\n                if (x - center_x)**2 + (y - center_y)**2 <= radius_sq:\n                    m_interior[iy, ix] = m1\n    \n    # 3. Assemble the sparse matrix A\n    k_sq_flat = (omega * m_interior.flatten())**2\n    h_sq_inv = 1.0 / (h**2)\n    \n    # Using LIL format for easy assembly, then convert to CSC for performance\n    A = sp.lil_matrix((N_unk, N_unk), dtype=np.float64)\n\n    for iy in range(Ny_int):\n        for ix in range(Nx_int):\n            p = iy * Nx_int + ix\n            \n            # Main diagonal: k^2 - 4/h^2\n            A[p, p] = k_sq_flat[p] + 4.0 * h_sq_inv # Note: This is A for -Laplacian\n            A[p, p] = k_sq_flat[p] - 4.0 * h_sq_inv # This is A for +Laplacian\n\n            # Off-diagonals: 1/h^2 for neighbors\n            if ix > 0:            # Left neighbor\n                A[p, p - 1] = 1.0 * h_sq_inv\n            if ix  Nx_int - 1:   # Right neighbor\n                A[p, p + 1] = 1.0 * h_sq_inv\n            if iy > 0:            # Top neighbor\n                A[p, p - Nx_int] = 1.0 * h_sq_inv\n            if iy  Ny_int - 1:   # Bottom neighbor\n                A[p, p + Nx_int] = 1.0 * h_sq_inv\n\n    # Correcting the matrix based on the text: A for (nabla^2 u + k^2 u)\n    # The above assembly is for (-nabla^2 u - k^2 u) if k^2 were negative.\n    # Let's fix it. The stencil for nabla^2 is (u_i+1 + u_i-1 ... - 4u_i)/h^2.\n    # So the off-diagonals are 1/h^2 and the diagonal is k^2 - 4/h^2.\n    # My python code was doing this:\n    # A[p, p] = k_sq_flat[p] - 4.0 * h_sq_inv\n    # A[p, neighbor] = 1.0 * h_sq_inv\n    # This is correct for the equation (nabla^2 + k^2)u.\n    \n    # The solution text has A_p,p = k^2 - 4/h^2 and off-diagonals A_p,p' = 1/h^2.\n    # My code has this logic, despite some confusing comments I will now remove.\n    # Re-writing assembly for clarity, but the logic remains the same.\n    A = sp.lil_matrix((N_unk, N_unk), dtype=np.float64)\n    for iy in range(Ny_int):\n        for ix in range(Nx_int):\n            p = iy * Nx_int + ix\n            A[p, p] = k_sq_flat[p] - 4.0 * h_sq_inv\n            if ix > 0: A[p, p - 1] = h_sq_inv\n            if ix  Nx_int - 1: A[p, p + 1] = h_sq_inv\n            if iy > 0: A[p, p - Nx_int] = h_sq_inv\n            if iy  Ny_int - 1: A[p, p + Nx_int] = h_sq_inv\n\n    A = A.asformat('csc')\n    \n    # 4. Compute symmetry residual\n    # The default norm for scipy.sparse.linalg.norm is the Frobenius norm.\n    s = spla.norm(A - A.T) / spla.norm(A)\n\n    # 5. Define sources and solve systems\n    (ix_i, iy_i), (ix_j, iy_j) = src_indices\n    p_i = iy_i * Nx_int + ix_i\n    p_j = iy_j * Nx_int + ix_j\n    \n    # Source i\n    b_i = np.zeros(N_unk, dtype=np.float64)\n    b_i[p_i] = 1.0\n    u_i = spla.spsolve(A, b_i)\n    \n    # Source j\n    b_j = np.zeros(N_unk, dtype=np.float64)\n    b_j[p_j] = 1.0\n    u_j = spla.spsolve(A, b_j)\n    \n    # 6. Compute reciprocity residual\n    u_i_at_pj = u_i[p_j]\n    u_j_at_pi = u_j[p_i]\n    r = np.abs(u_i_at_pj - u_j_at_pi)\n    \n    return s, r\n\ndef solve():\n    Nx = 50\n    Ny = 50\n    Nx_int = Nx - 2\n    Ny_int = Ny - 2\n    \n    test_cases = [\n        # Test Case 1\n        {\n            \"Nx\": Nx, \"Ny\": Ny, \"Lx\": 1000., \"Ly\": 1000., \"f\": 5.,\n            \"m_model\": {\"type\": \"homogeneous\", \"c0\": 1500.},\n            \"sources\": (\n                (math.floor(Nx_int / 3), math.floor(Ny_int / 2)),\n                (math.floor(2 * Nx_int / 3), math.floor(Ny_int / 2))\n            )\n        },\n        # Test Case 2\n        {\n            \"Nx\": Nx, \"Ny\": Ny, \"Lx\": 1000., \"Ly\": 1000., \"f\": 5.,\n            \"m_model\": {\n                \"type\": \"heterogeneous\", \"c0\": 1500., \"c1\": 2000.,\n                \"center\": (500., 500.), \"radius\": 200.\n            },\n            \"sources\": ((10, 30), (35, 15))\n        },\n        # Test Case 3\n        {\n            \"Nx\": Nx, \"Ny\": Ny, \"Lx\": 1000., \"Ly\": 1000., \"f\": 8.,\n            \"m_model\": {\"type\": \"homogeneous\", \"c0\": 1500.},\n            \"sources\": ((1, 1), (Nx_int - 2, Ny_int - 2))\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        s, r = run_case(case)\n        results.extend([s, r])\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3616960"}, {"introduction": "A significant practical challenge in finite-difference modeling is the accurate representation of boundaries that do not align with the grid, which often results in \"staircase\" artifacts. This advanced practice [@problem_id:3616926] explores the physical consequences of such approximations by analyzing the spurious reflections they produce in terms of an equivalent surface impedance error. By deriving and implementing correction schemes, you will develop a deeper understanding of how to analyze and mitigate discretization errors to improve the physical fidelity of your simulations.", "problem": "Consider scalar acoustic waves in a homogeneous, isotropic medium of density $ \\rho $ and bulk modulus $ K $, where the acoustic pressure field $ p(\\mathbf{x},t) $ satisfies the linear wave equation. In the frequency domain, under the assumption of time-harmonic dependence with angular frequency $ \\omega $, the governing equation for the complex-valued pressure field $ p(\\mathbf{x}) $ reduces to the Helmholtz equation. A planar boundary with a surface impedance condition can be represented by a first-order relation between the normal derivative of $ p $ and $ p $ itself. In computational geophysics, frequency-domain finite-difference models often approximate oblique boundaries by staircased, axis-aligned segments, which introduces numerical artifacts. These artifacts can be interpreted as an equivalent surface impedance error that modifies plane-wave reflections, especially at grazing incidence.\n\nYour tasks are:\n- Start from the time-domain acoustic wave equation $ \\frac{\\partial^2 p}{\\partial t^2} - c^2 \\nabla^2 p = 0 $, where $ c = \\sqrt{K/\\rho} $ is the wavespeed, and derive the scalar Helmholtz equation for $ p(\\mathbf{x}) $ in the frequency domain under the convention $ p(\\mathbf{x},t) = \\Re\\{p(\\mathbf{x}) e^{-i \\omega t} \\} $. Provide the correct surface impedance boundary condition in terms of the normal derivative $\\frac{\\partial p}{\\partial n}$.\n- Analyze plane-wave reflection from an impedance boundary. Derive the reflection amplitude for a plane wave with unit propagation direction $\\mathbf{s}$ incident on a boundary whose unit normal is $\\mathbf{n}$, and define the incidence angle $\\phi$ by $\\cos \\phi = \\mathbf{s} \\cdot \\mathbf{n}$.\n- Model staircasing by replacing the true boundary normal $\\mathbf{n}$ with an axis-aligned normal $\\mathbf{e}_{\\text{axis}} \\in \\{ \\mathbf{e}_x, \\mathbf{e}_y \\}$, where $\\mathbf{e}_x = (1,0)$ and $\\mathbf{e}_y = (0,1)$. Define the axis-incidence cosine $\\cos \\psi = \\mathbf{s} \\cdot \\mathbf{e}_{\\text{axis}}$. From first principles, derive an expression for the equivalent surface impedance error induced by staircasing when the same physical surface impedance is enforced on the staircased segment as on the true oblique boundary. Use this to obtain the plane-wave reflection amplitude under staircasing, expressed in terms of $\\cos \\psi$ and the enforced impedance.\n- Propose two subcell correction schemes aimed at minimizing grazing-incidence reflections:\n  1. A projection correction that scales the enforced impedance on the staircased segment by the projection $\\mathbf{n} \\cdot \\mathbf{e}_{\\text{axis}}$.\n  2. A rotated-Robin correction that enforces the impedance boundary condition using a linear combination of axis derivatives weighted by $\\mathbf{n}$, thereby approximating the true oblique normal derivative at subcell level.\n  For each scheme, derive the expected plane-wave reflection amplitude.\n\nProgram requirements:\n- Implement a program that, for each test case, computes five quantities: the magnitude of the reflection amplitude for the naive staircased enforcement, the magnitude of the reflection amplitude for the projection correction, the magnitude of the reflection amplitude for the rotated-Robin correction, the magnitude of the equivalent surface impedance error for the naive staircasing, and the magnitude of the equivalent surface impedance error for the projection correction.\n- Angles in the test suite are specified in degrees and must be interpreted in degrees; internally convert to radians if needed. There are no physical units associated with the outputs; all quantities are dimensionless.\n- Assume that the physical surface impedance is chosen to perfectly absorb a plane wave at the true oblique boundary according to the continuous theory, i.e., it is matched to the true incidence angle defined by $\\cos \\phi = \\mathbf{s} \\cdot \\mathbf{n}$.\n- Test Suite:\n  1. True boundary normal angle $ \\theta_n = 30^\\circ $, plane-wave direction angle $ \\theta_k = 115^\\circ $, axis normal $ \\mathbf{e}_{\\text{axis}} = \\mathbf{e}_y $.\n  2. True boundary normal angle $ \\theta_n = 90^\\circ $, plane-wave direction angle $ \\theta_k = 175^\\circ $, axis normal $ \\mathbf{e}_{\\text{axis}} = \\mathbf{e}_y $.\n  3. True boundary normal angle $ \\theta_n = 89^\\circ $, plane-wave direction angle $ \\theta_k = 174^\\circ $, axis normal $ \\mathbf{e}_{\\text{axis}} = \\mathbf{e}_y $.\n  4. True boundary normal angle $ \\theta_n = 25^\\circ $, plane-wave direction angle $ \\theta_k = 113^\\circ $, axis normal $ \\mathbf{e}_{\\text{axis}} = \\mathbf{e}_x $.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test caseâ€™s results must be a list of five floats in the order $[|R_{\\text{naive}}|,|R_{\\text{proj}}|,|R_{\\text{rot}}|,|\\Delta \\zeta_{\\text{naive}}|,|\\Delta \\zeta_{\\text{proj}}|]$. The overall output must therefore be a list of lists, for example $[[r_{11},r_{12},r_{13},r_{14},r_{15}],[r_{21},\\dots],[\\dots],[\\dots]]$.", "solution": "The problem requires a thorough theoretical derivation of plane-wave reflection phenomena at impedance boundaries, particularly in the context of numerical artifacts arising from staircased approximations in finite-difference methods. We will proceed by first establishing the fundamental equations, then analyzing the reflection properties of the exact and approximated boundaries.\n\n**1. Helmholtz Equation and Surface Impedance Boundary Condition**\n\nThe starting point is the scalar acoustic wave equation for the pressure field $p(\\mathbf{x}, t)$:\n$$\n\\frac{\\partial^2 p}{\\partial t^2} - c^2 \\nabla^2 p = 0\n$$\nwhere $c$ is the constant wavespeed. We assume a time-harmonic solution of the form $p(\\mathbf{x}, t) = \\Re\\{p(\\mathbf{x}) e^{-i \\omega t}\\}$, where $p(\\mathbf{x})$ is the complex-valued spatial pressure amplitude and $\\omega$ is the angular frequency. Working with the complex form $p_{complex}(\\mathbf{x},t) = p(\\mathbf{x}) e^{-i\\omega t}$, the time derivatives are:\n$$\n\\frac{\\partial p_{complex}}{\\partial t} = -i\\omega p(\\mathbf{x}) e^{-i\\omega t}\n$$\n$$\n\\frac{\\partial^2 p_{complex}}{\\partial t^2} = (-i\\omega)^2 p(\\mathbf{x}) e^{-i\\omega t} = -\\omega^2 p(\\mathbf{x}) e^{-i\\omega t}\n$$\nThe spatial derivative term is $\\nabla^2 p_{complex} = (\\nabla^2 p(\\mathbf{x})) e^{-i\\omega t}$. Substituting these into the wave equation yields:\n$$\n(-\\omega^2 p(\\mathbf{x}) - c^2 \\nabla^2 p(\\mathbf{x}))e^{-i\\omega t} = 0\n$$\nFor this equation to hold for all times $t$, the term in parenthesis must be zero. Rearranging the terms, we obtain the scalar Helmholtz equation:\n$$\n\\nabla^2 p(\\mathbf{x}) + \\left(\\frac{\\omega}{c}\\right)^2 p(\\mathbf{x}) = 0\n$$\nDefining the wavenumber $k = \\omega/c$, the equation is:\n$$\n\\nabla^2 p(\\mathbf{x}) + k^2 p(\\mathbf{x}) = 0\n$$\nA surface impedance boundary condition relates the pressure field $p$ to its normal derivative $\\frac{\\partial p}{\\partial n} = \\nabla p \\cdot \\mathbf{n}$ at a boundary with unit normal $\\mathbf{n}$. This relationship is generally linear for a passive boundary and can be expressed in the frequency domain as a Robin-type boundary condition:\n$$\n\\frac{\\partial p}{\\partial n} + \\zeta p = 0\n$$\nor equivalently, $\\frac{\\partial p}{\\partial n} = -\\zeta p$. The parameter $\\zeta$ is a complex-valued coefficient related to the physical properties of the boundary, such as its specific acoustic impedance. We will refer to $\\zeta$ as the impedance parameter.\n\n**2. Plane-Wave Reflection from an Impedance Boundary**\n\nConsider a plane wave $p_i(\\mathbf{x}) = e^{i\\mathbf{k}_i \\cdot \\mathbf{x}}$ incident upon a boundary. The total pressure field is the sum of the incident and reflected waves, $p(\\mathbf{x}) = p_i(\\mathbf{x}) + p_r(\\mathbf{x})$. Let the incident propagation direction be the unit vector $\\mathbf{s} = \\mathbf{k}_i/k$. The reflected wave is $p_r(\\mathbf{x}) = R e^{i\\mathbf{k}_r \\cdot \\mathbf{x}}$, where $R$ is the reflection amplitude and $\\mathbf{k}_r$ is the reflected wavevector. By Snell's law for a planar boundary with normal $\\mathbf{n}$, the reflected direction $\\mathbf{s}_r = \\mathbf{k}_r/k$ is given by $\\mathbf{s}_r = \\mathbf{s} - 2(\\mathbf{s} \\cdot \\mathbf{n})\\mathbf{n}$. The total field is $p(\\mathbf{x}) = e^{ik\\mathbf{s} \\cdot \\mathbf{x}} + R e^{ik\\mathbf{s}_r \\cdot \\mathbf{x}}$.\n\nTo find $R$, we apply the boundary condition $\\frac{\\partial p}{\\partial n} + \\zeta p = 0$. The normal derivative is $\\frac{\\partial p}{\\partial n} = \\nabla p \\cdot \\mathbf{n}$.\n$$\n\\nabla p = ik\\mathbf{s} e^{ik\\mathbf{s} \\cdot \\mathbf{x}} + ikR\\mathbf{s}_r e^{ik\\mathbf{s}_r \\cdot \\mathbf{x}}\n$$\n$$\n\\frac{\\partial p}{\\partial n} = ik(\\mathbf{s} \\cdot \\mathbf{n}) e^{ik\\mathbf{s} \\cdot \\mathbf{x}} + ikR(\\mathbf{s}_r \\cdot \\mathbf{n}) e^{ik\\mathbf{s}_r \\cdot \\mathbf{x}}\n$$\nWe note that $\\mathbf{s}_r \\cdot \\mathbf{n} = (\\mathbf{s} - 2(\\mathbf{s} \\cdot \\mathbf{n})\\mathbf{n})\\cdot\\mathbf{n} = \\mathbf{s}\\cdot\\mathbf{n} - 2(\\mathbf{s}\\cdot\\mathbf{n}) = -(\\mathbf{s}\\cdot\\mathbf{n})$. Let the incidence cosine be $c_\\phi = \\mathbf{s} \\cdot \\mathbf{n}$. On the boundary (e.g., at $\\mathbf{x}=\\mathbf{0}$), substituting the fields into the boundary condition gives:\n$$\n\\left( ik c_\\phi (1) + ik R (-c_\\phi) \\right) + \\zeta (1+R) = 0\n$$\n$$\nik c_\\phi (1-R) + \\zeta (1+R) = 0\n$$\nSolving for $R$:\n$$\nR( \\zeta - ikc_\\phi ) = -(\\zeta + ikc_\\phi) \\implies R = -\\frac{\\zeta + ikc_\\phi}{\\zeta - ikc_\\phi} = \\frac{ikc_\\phi + \\zeta}{ikc_\\phi - \\zeta}\n$$\nThe problem specifies that the physical impedance of the true oblique boundary is perfectly absorbing. This means $R=0$ for the true boundary geometry. This occurs when the numerator is zero:\n$$\nikc_\\phi + \\zeta_{\\text{phys}} = 0 \\implies \\zeta_{\\text{phys}} = -ikc_\\phi = -ik(\\mathbf{s} \\cdot \\mathbf{n})\n$$\nThis defines the physical impedance parameter used in subsequent steps.\n\nTo facilitate dimensionless analysis as requested, we introduce a normalized impedance parameter $\\hat{\\zeta} = \\zeta/(ik)$. The boundary condition becomes $\\frac{1}{ik}\\frac{\\partial p}{\\partial n} + \\hat{\\zeta} p = 0$, and the reflection amplitude is:\n$$\nR = \\frac{c_\\phi + \\hat{\\zeta}}{c_\\phi - \\hat{\\zeta}}\n$$\nThe perfectly absorbing (matched) normalized impedance is $\\hat{\\zeta}_{\\text{matched}} = -c_\\phi = -(\\mathbf{s} \\cdot \\mathbf{n})$.\n\n**3. Analysis of Staircased Boundary Artifacts**\n\nIn a staircased approximation, the true boundary normal $\\mathbf{n}$ is replaced by an axis-aligned normal $\\mathbf{e}_{\\text{axis}}$. The boundary condition is then enforced with respect to this incorrect normal. The plane-wave reflection is now governed by specular reflection from this axis-aligned surface. The relevant incidence cosine is $c_\\psi = \\mathbf{s} \\cdot \\mathbf{e}_{\\text{axis}}$. The matched normalized impedance for this new boundary orientation would be $\\hat{\\zeta}_{\\text{matched\\_axis}} = -c_\\psi$.\n\n**Naive Staircasing:** The physical impedance of the true boundary is enforced on the staircased segment.\n$$\n\\hat{\\zeta}_{\\text{enforced}} = \\hat{\\zeta}_{\\text{phys}} = -c_\\phi\n$$\nThe reflection amplitude $R_{\\text{naive}}$ from the staircased boundary (with incidence cosine $c_\\psi$) is:\n$$\nR_{\\text{naive}} = \\frac{c_\\psi + \\hat{\\zeta}_{\\text{enforced}}}{c_\\psi - \\hat{\\zeta}_{\\text{enforced}}} = \\frac{c_\\psi - c_\\phi}{c_\\psi + c_\\phi}\n$$\nThe equivalent surface impedance error is the difference between the enforced impedance and the impedance that would be perfectly matched for the staircased boundary orientation:\n$$\n\\Delta \\hat{\\zeta}_{\\text{naive}} = \\hat{\\zeta}_{\\text{enforced}} - \\hat{\\zeta}_{\\text{matched\\_axis}} = -c_\\phi - (-c_\\psi) = c_\\psi - c_\\phi\n$$\n\n**4. Subcell Correction Schemes**\n\n**Projection Correction:** The enforced impedance is scaled by the projection of the true normal onto the axis normal, $n_{\\text{axis}} = \\mathbf{n} \\cdot \\mathbf{e}_{\\text{axis}}$.\n$$\n\\hat{\\zeta}_{\\text{proj}} = \\hat{\\zeta}_{\\text{phys}} \\cdot n_{\\text{axis}} = -c_\\phi n_{\\text{axis}}\n$$\nThe reflection amplitude $R_{\\text{proj}}$ is:\n$$\nR_{\\text{proj}} = \\frac{c_\\psi + \\hat{\\zeta}_{\\text{proj}}}{c_\\psi - \\hat{\\zeta}_{\\text{proj}}} = \\frac{c_\\psi - c_\\phi n_{\\text{axis}}}{c_\\psi + c_\\phi n_{\\text{axis}}}\n$$\nThe corresponding impedance error is:\n$$\n\\Delta \\hat{\\zeta}_{\\text{proj}} = \\hat{\\zeta}_{\\text{proj}} - \\hat{\\zeta}_{\\text{matched\\_axis}} = -c_\\phi n_{\\text{axis}} - (-c_\\psi) = c_\\psi - c_\\phi n_{\\text{axis}}\n$$\n\n**Rotated-Robin Correction:** This scheme approximates the true normal derivative operator $\\frac{\\partial}{\\partial n} = \\mathbf{n} \\cdot \\nabla = n_x \\frac{\\partial}{\\partial x} + n_y \\frac{\\partial}{\\partial y}$ and applies the true physical impedance. The enforced boundary condition is an attempt to replicate the exact continuous BC:\n$$\n\\mathbf{n} \\cdot \\nabla p + \\zeta_{\\text{phys}} p = 0\n$$\nSubstituting the plane-wave solution $p = e^{ik\\mathbf{s}\\cdot\\mathbf{x}} + R_{\\text{rot}}e^{ik\\mathbf{s}'_r\\cdot\\mathbf{x}}$, where $\\mathbf{s}'_r$ is the reflection from the staircase normal $\\mathbf{e}_{\\text{axis}}$:\n$$\n\\mathbf{n} \\cdot (ik\\mathbf{s} + ikR_{\\text{rot}}\\mathbf{s}'_r) + \\zeta_{\\text{phys}}(1+R_{\\text{rot}}) = 0\n$$\nDividing by $ik$ and using $\\hat{\\zeta}_{\\text{phys}} = \\zeta_{\\text{phys}}/(ik) = -(\\mathbf{s} \\cdot \\mathbf{n})$:\n$$\n(\\mathbf{n} \\cdot \\mathbf{s}) + R_{\\text{rot}}(\\mathbf{n} \\cdot \\mathbf{s}'_r) - (\\mathbf{s} \\cdot \\mathbf{n})(1+R_{\\text{rot}}) = 0\n$$\n$$\n(\\mathbf{n} \\cdot \\mathbf{s}) + R_{\\text{rot}}(\\mathbf{n} \\cdot \\mathbf{s}'_r) - (\\mathbf{s} \\cdot \\mathbf{n}) - R_{\\text{rot}}(\\mathbf{s} \\cdot \\mathbf{n}) = 0\n$$\n$$\nR_{\\text{rot}} [ (\\mathbf{n} \\cdot \\mathbf{s}'_r) - (\\mathbf{n} \\cdot \\mathbf{s}) ] = 0\n$$\nUsing $\\mathbf{s}'_r = \\mathbf{s} - 2(\\mathbf{s} \\cdot \\mathbf{e}_{\\text{axis}})\\mathbf{e}_{\\text{axis}} = \\mathbf{s} - 2c_\\psi \\mathbf{e}_{\\text{axis}}$, we get:\n$$\n\\mathbf{n} \\cdot \\mathbf{s}'_r = \\mathbf{n} \\cdot \\mathbf{s} - 2c_\\psi(\\mathbf{n} \\cdot \\mathbf{e}_{\\text{axis}}) = \\mathbf{n} \\cdot \\mathbf{s} - 2c_\\psi n_{\\text{axis}}\n$$\nThe equation for $R_{\\text{rot}}$ becomes:\n$$\nR_{\\text{rot}} [ (\\mathbf{n} \\cdot \\mathbf{s} - 2c_\\psi n_{\\text{axis}}) - (\\mathbf{n} \\cdot \\mathbf{s}) ] = -2c_\\psi n_{\\text{axis}} R_{\\text{rot}} = 0\n$$\nAssuming non-degenerate geometry where $c_\\psi \\neq 0$ (not perfectly grazing to the staircase) and $n_{\\text{axis}} \\neq 0$ (true boundary not parallel to the staircase axis), the only solution is $R_{\\text{rot}} = 0$. This scheme perfectly absorbs the plane wave under this analytical model.\n\n**Summary of Formulas for Calculation:**\nThe five quantities to be computed are:\n1.  Magnitude of naive reflection amplitude: $|R_{\\text{naive}}| = \\left| \\frac{c_\\psi - c_\\phi}{c_\\psi + c_\\phi} \\right|$\n2.  Magnitude of projection-corrected reflection amplitude: $|R_{\\text{proj}}| = \\left| \\frac{c_\\psi - c_\\phi n_{\\text{axis}}}{c_\\psi + c_\\phi n_{\\text{axis}}} \\right|$\n3.  Magnitude of rotated-Robin reflection amplitude: $|R_{\\text{rot}}| = 0$\n4.  Magnitude of naive dimensionless impedance error: $|\\Delta \\hat{\\zeta}_{\\text{naive}}| = |c_\\psi - c_\\phi|$\n5.  Magnitude of projection-corrected dimensionless impedance error: $|\\Delta \\hat{\\zeta}_{\\text{proj}}| = |c_\\psi - c_\\phi n_{\\text{axis}}|$\n\nwhere $c_\\phi = \\mathbf{s} \\cdot \\mathbf{n}$, $c_\\psi = \\mathbf{s} \\cdot \\mathbf{e}_{\\text{axis}}$, and $n_{\\text{axis}} = \\mathbf{n} \\cdot \\mathbf{e}_{\\text{axis}}$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for reflection amplitudes and impedance errors for different\n    staircasing boundary condition schemes in computational geophysics.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Each case is (true boundary normal angle [deg], plane-wave direction angle [deg], axis normal char).\n    test_cases = [\n        (30.0, 115.0, 'y'),\n        (90.0, 175.0, 'y'),\n        (89.0, 174.0, 'y'),\n        (25.0, 113.0, 'x'),\n    ]\n\n    results = []\n    for case in test_cases:\n        theta_n_deg, theta_k_deg, axis_char = case\n\n        # Convert angles from degrees to radians for trigonometric functions\n        theta_n = np.deg2rad(theta_n_deg)\n        theta_k = np.deg2rad(theta_k_deg)\n\n        # Define the relevant vectors in 2D\n        # n: true boundary unit normal\n        # s: plane-wave propagation unit direction\n        # e_axis: axis-aligned normal used in the staircased grid\n        n_vec = np.array([np.cos(theta_n), np.sin(theta_n)])\n        s_vec = np.array([np.cos(theta_k), np.sin(theta_k)])\n        \n        if axis_char == 'y':\n            e_axis = np.array([0.0, 1.0])\n        else: # 'x'\n            e_axis = np.array([1.0, 0.0])\n\n        # Calculate the fundamental cosine terms based on vector dot products\n        # c_phi: cosine of incidence angle with respect to the true boundary\n        # c_psi: cosine of incidence angle with respect to the staircased boundary\n        # n_axis: projection of the true normal onto the staircase normal\n        c_phi = np.dot(s_vec, n_vec)\n        c_psi = np.dot(s_vec, e_axis)\n        n_axis = np.dot(n_vec, e_axis)\n\n        # --- 1. Naive Staircasing Reflection Amplitude ---\n        # The physical impedance for the true boundary is incorrectly applied to the\n        # axis-aligned boundary segment.\n        # R_naive = (c_psi - c_phi) / (c_psi + c_phi)\n        \n        # Check for division by zero, though test cases avoid this.\n        # This would correspond to c_phi = -c_psi.\n        denom_naive = c_psi + c_phi\n        if np.isclose(denom_naive, 0):\n            # This case represents a singularity and is not expected in the test suite.\n            # A large reflection (magnitude 1) is a physically reasonable limit.\n             R_naive_mag = 1.0\n        else:\n             R_naive_mag = np.abs((c_psi - c_phi) / denom_naive)\n\n        # --- 2. Projection Correction Reflection Amplitude ---\n        # The enforced impedance is scaled by the projection of the true normal\n        # onto the axis-normal.\n        # R_proj = (c_psi - c_phi*n_axis) / (c_psi + c_phi*n_axis)\n        denom_proj = c_psi + c_phi * n_axis\n        if np.isclose(denom_proj, 0):\n             R_proj_mag = 1.0\n        else:\n             R_proj_mag = np.abs((c_psi - c_phi * n_axis) / denom_proj)\n\n        # --- 3. Rotated-Robin Correction Reflection Amplitude ---\n        # This method perfectly absorbs the plane wave in the continuous analysis,\n        # resulting in zero reflection, unless the geometry is degenerate.\n        # The test cases are non-degenerate.\n        R_rot_mag = 0.0\n\n        # --- 4. Naive Staircasing Impedance Error ---\n        # The error is the difference between the enforced normalized impedance (-c_phi)\n        # and the impedance that would be matched for the staircase (-c_psi).\n        # |Delta_zeta_naive| = |-c_phi - (-c_psi)| = |c_psi - c_phi|\n        d_zeta_naive_mag = np.abs(c_psi - c_phi)\n\n        # --- 5. Projection Correction Impedance Error ---\n        # The enforced impedance is (-c_phi * n_axis).\n        # |Delta_zeta_proj| = |-c_phi*n_axis - (-c_psi)| = |c_psi - c_phi*n_axis|\n        d_zeta_proj_mag = np.abs(c_psi - c_phi * n_axis)\n\n        # Append the five computed quantities for this test case\n        case_results = [\n            R_naive_mag,\n            R_proj_mag,\n            R_rot_mag,\n            d_zeta_naive_mag,\n            d_zeta_proj_mag\n        ]\n        results.append(case_results)\n\n    # Format the output as a string representing a list of lists.\n    # Example: [[r11, r12, ...], [r21, r22, ...]]\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3616926"}]}