{"hands_on_practices": [{"introduction": "A cornerstone of computational modeling is the ability to validate numerical approximations against known analytical solutions. This practice provides a foundational experience in this process by building a simple voxel-based forward model of a sphere and comparing its output to the exact gravitational field, which is known from first principles. By systematically varying the voxel size and observation point, you will gain direct insight into how discretization error behaves and how it impacts model accuracy [@problem_id:3597417].", "problem": "Consider a spherically symmetric, homogeneous body with radius $R$ and density contrast $\\Delta \\rho$ embedded in a uniform background. Let the gravitational constant be $G$ in the International System of Units (SI). The vertical component of gravitational acceleration at an observation point located on the vertical axis at height $h$ above the sphere center is denoted $g_z(h)$, with the sign convention that $g_z$ is positive downward. Your task is to validate a voxel-based forward model for $g_z$ against the analytic anomaly of the homogeneous sphere by quantifying the absolute error as a function of voxel size and observation height $h$.\n\nStarting from Newton's law of universal gravitation and the definition of gravitational acceleration due to a continuous mass distribution, derive the analytic expression for $g_z(h)$ for a homogeneous sphere. Then design an algorithm that approximates the sphere by a set of identical cubic voxels of side length $\\Delta$, with constant density contrast $\\Delta \\rho$. Each voxel is represented by a point mass located at its center, and the total $g_z$ is obtained by summing the contributions from all voxels whose centers lie inside the sphere. The contribution of a voxel of volume $\\Delta^3$ and mass $\\Delta \\rho \\Delta^3$ at position $(x_i,y_i,z_i)$ to $g_z$ at the observation point $(0,0,h)$ is computed from first principles, without invoking shortcut formulas. Use only the laws and definitions required for forward modeling in gravity.\n\nYou will implement the following for validation:\n1. Compute the analytic $g_z(h)$ for a homogeneous sphere of radius $R$ and density contrast $\\Delta \\rho$.\n2. Compute the voxel-based $g_z^{\\mathrm{vox}}(h,\\Delta)$ by discretizing the sphere with voxels of side length $\\Delta$ as described above.\n3. Compute the absolute error $E(h,\\Delta) = \\left| g_z^{\\mathrm{vox}}(h,\\Delta) - g_z(h) \\right|$.\n4. Report $E(h,\\Delta)$ in microgal (µGal), where $1~\\mathrm{microgal} = 10^{-8}~\\mathrm{m/s^2}$.\n\nUse the following fixed physical parameters, which are realistic and scientifically sound:\n- Gravitational constant $G = 6.67430 \\times 10^{-11}~\\mathrm{m^3\\,kg^{-1}\\,s^{-2}}$,\n- Sphere radius $R = 1000~\\mathrm{m}$,\n- Density contrast $\\Delta \\rho = 400~\\mathrm{kg/m^3}$.\n\nThe observation point is always at $(0,0,h)$, and the sphere center is at the origin. Construct the voxel centers on a regular grid that covers the bounding cube of the sphere, $[-R,R] \\times [-R,R] \\times [-R,R]$, with spacing $\\Delta$ and centers at $-R + \\Delta/2, -R + 3\\Delta/2, \\ldots, R - \\Delta/2$ along each axis. Include a voxel in the sum if and only if its center lies inside the sphere, that is, if $x_i^2 + y_i^2 + z_i^2 \\le R^2$.\n\nExpress all errors $E(h,\\Delta)$ in microgal (µGal) as real-valued floats. Angles do not appear in this problem, so no angle unit is required.\n\nTest Suite:\nCompute and report $E(h,\\Delta)$ for the following four cases, chosen to exercise different regimes:\n- Case 1 (inside field, moderately coarse voxels): $\\Delta = 500~\\mathrm{m}$, $h = 500~\\mathrm{m}$.\n- Case 2 (boundary, medium voxels): $\\Delta = 250~\\mathrm{m}$, $h = 1000~\\mathrm{m}$.\n- Case 3 (far field, fine voxels): $\\Delta = 100~\\mathrm{m}$, $h = 5000~\\mathrm{m}$.\n- Case 4 (boundary, very coarse voxels): $\\Delta = 1000~\\mathrm{m}$, $h = 1000~\\mathrm{m}$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the four absolute errors $[E(h,\\Delta)]$ in the order of the cases above, as a comma-separated list enclosed in square brackets, for example, \"[e1,e2,e3,e4]\". Each entry should be a float in microgal (µGal).", "solution": "The problem statement is subjected to validation before proceeding to a solution.\n\n### Step 1: Extract Givens\n- **Body:** Spherically symmetric, homogeneous body.\n- **Parameters:** Radius $R$, density contrast $\\Delta \\rho$, gravitational constant $G$.\n- **Observation Geometry:** Observation point at $(0,0,h)$ on the vertical axis above the sphere's center, which is at the origin $(0,0,0)$.\n- **Measured Quantity:** Vertical component of gravitational acceleration, $g_z(h)$, with positive defined as downward.\n- **Task:** Validate a voxel-based forward model for $g_z$ against the analytic solution by quantifying the absolute error $E(h,\\Delta) = \\left| g_z^{\\mathrm{vox}}(h,\\Delta) - g_z(h) \\right|$.\n- **Analytic Model:** Derive the expression for $g_z(h)$ for the homogeneous sphere from first principles.\n- **Numerical Model:** Approximate the sphere with identical cubic voxels of side length $\\Delta$ and constant density contrast $\\Delta \\rho$. Each voxel is treated as a point mass at its center. The total $g_z^{\\mathrm{vox}}$ is the sum of contributions from all voxels whose centers lie inside the sphere ($x_i^2 + y_i^2 + z_i^2 \\le R^2$). The contribution of each voxel must be derived from first principles.\n- **Voxel Grid:** The voxel centers are on a regular grid covering the cube $[-R,R] \\times [-R,R] \\times [-R,R]$ with spacing $\\Delta$. The coordinates of the centers along each axis are $-R + \\Delta/2, -R + 3\\Delta/2, \\ldots, R - \\Delta/2$.\n- **Constants:**\n    - Gravitational constant: $G = 6.67430 \\times 10^{-11}~\\mathrm{m^3\\,kg^{-1}\\,s^{-2}}$.\n    - Sphere radius: $R = 1000~\\mathrm{m}$.\n    - Density contrast: $\\Delta \\rho = 400~\\mathrm{kg/m^3}$.\n- **Unit Conversion:** Report error $E(h, \\Delta)$ in microgal (µGal), where $1~\\mathrm{µGal} = 10^{-8}~\\mathrm{m/s^2}$.\n- **Test Suite:**\n    - Case 1: $\\Delta = 500~\\mathrm{m}$, $h = 500~\\mathrm{m}$.\n    - Case 2: $\\Delta = 250~\\mathrm{m}$, $h = 1000~\\mathrm{m}$.\n    - Case 3: $\\Delta = 100~\\mathrm{m}$, $h = 5000~\\mathrm{m}$.\n    - Case 4: $\\Delta = 1000~\\mathrm{m}$, $h = 1000~\\mathrm{m}$.\n- **Output Format:** A list of four floating-point error values in microgal, formatted as `[e1,e2,e3,e4]`.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded:** The problem is a classic exercise in potential field geophysics, based on Newton's law of universal gravitation. All physical principles, constants ($G, R, \\Delta\\rho$), and units are scientifically sound and realistic.\n- **Well-Posed:** The problem provides a complete set of parameters and a clear, unambiguous procedure to calculate both an analytic and a numerical solution. A unique and meaningful result (the discretization error) exists for each test case.\n- **Objective:** The problem is stated in precise, quantitative, and objective language, free of any subjectivity or ambiguity.\n- **Flaw Checklist:**\n    1.  **Scientific/Factual Unsoundness:** None. The problem is based on fundamental physics.\n    2.  **Non-Formalizable/Irrelevant:** None. This is a core topic in computational geophysics.\n    3.  **Incomplete/Contradictory:** None. All necessary information is provided, and there are no contradictions. The specification of the voxel grid is complete and consistent with the test cases.\n    4.  **Unrealistic/Infeasible:** None. The physical parameters are realistic, and the required computations are feasible.\n    5.  **Ill-Posed/Poorly Structured:** None. The problem structure is clear, and the solution is well-defined.\n    6.  **Pseudo-Profound/Trivial:** None. The problem involves a non-trivial comparison between an analytic solution and a numerical approximation, which is a standard and meaningful task in science and engineering.\n    7.  **Outside Scientific Verifiability:** None. The results are fully verifiable by calculation.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. A solution will be provided.\n\n### Principle-Based Solution Design\n\nThe solution requires two main components: the derivation of the analytic gravitational anomaly of a sphere and the implementation of a numerical approximation using a voxel-based model.\n\n#### 1. Analytic Solution for $g_z(h)$\nThe gravitational field of a spherically symmetric mass distribution can be determined using the shell theorem, a direct consequence of integrating Newton's law of gravitation. The theorem has two parts relevant to this problem:\n1.  The gravitational force exerted by the sphere on a particle outside the sphere is the same as if the entire mass of the sphere were concentrated at its center.\n2.  The gravitational force exerted by a spherical shell on a particle inside the shell is zero.\n\nLet the sphere have radius $R$ and a uniform density contrast $\\Delta \\rho$. The total anomalous mass is $M = \\Delta \\rho \\cdot V = \\Delta \\rho \\left( \\frac{4}{3}\\pi R^3 \\right)$. The observation point is at a height $h$ on the z-axis, so its coordinates are $(0, 0, h)$.\n\nCase A: Observation point outside the sphere ($h \\ge R$)\nAccording to the shell theorem, the sphere acts as a point mass $M$ located at the origin. The gravitational force on a test mass $m_t$ at $(0, 0, h)$ is directed towards the origin. The acceleration vector is $\\vec{g} = -\\frac{GM}{h^2} \\hat{k}$, where $\\hat{k}$ is the unit vector in the $+z$ direction. The vertical component is $g_z = \\vec{g} \\cdot \\hat{k} = -\\frac{GM}{h^2}$. The problem defines $g_z$ to be positive downward, so we take the magnitude of the downward component:\n$$ g_z(h) = \\frac{GM}{h^2} = \\frac{G}{h^2} \\left( \\Delta \\rho \\frac{4}{3}\\pi R^3 \\right) = \\frac{4}{3}\\pi G \\Delta \\rho \\frac{R^3}{h^2} \\quad \\text{for } h \\ge R $$\n\nCase B: Observation point inside the sphere ($h < R$)\nAt a distance $h$ from the center, the outer shell of mass (from radius $h$ to $R$) exerts no net force. The gravitational attraction is due only to the inner sphere of radius $h$. The mass of this inner sphere is $M_{\\text{inner}} = \\Delta \\rho \\left( \\frac{4}{3}\\pi h^3 \\right)$. Applying the first part of the shell theorem to this inner mass, the gravitational acceleration is:\n$$ g_z(h) = \\frac{G M_{\\text{inner}}}{h^2} = \\frac{G}{h^2} \\left( \\Delta \\rho \\frac{4}{3}\\pi h^3 \\right) = \\frac{4}{3}\\pi G \\Delta \\rho h \\quad \\text{for } h < R $$\n\nCombining both cases, the analytic solution is:\n$$ g_z(h) = \\begin{cases} \\frac{4}{3}\\pi G \\Delta \\rho h & \\text{if } h < R \\\\ \\frac{4}{3}\\pi G \\Delta \\rho \\frac{R^3}{h^2} & \\text{if } h \\ge R \\end{cases} $$\n\n#### 2. Voxel-Based Numerical Solution $g_z^{\\mathrm{vox}}(h, \\Delta)$\nThe sphere is discretized into a set of cubic voxels. Each voxel is treated as a point mass located at its center.\nLet a voxel have side length $\\Delta$. Its volume is $V_{\\mathrm{vox}} = \\Delta^3$, and its mass is $m_{\\mathrm{vox}} = \\Delta \\rho \\Delta^3$.\nConsider a single voxel with its center at position $\\vec{r}_i = (x_i, y_i, z_i)$. The observation point is at $\\vec{r}_{\\mathrm{obs}} = (0, 0, h)$. The vector displacement from the voxel to the observation point is $\\vec{d} = \\vec{r}_{\\mathrm{obs}} - \\vec{r}_i = (-x_i, -y_i, h-z_i)$. The distance is $d = |\\vec{d}| = \\sqrt{x_i^2 + y_i^2 + (h-z_i)^2}$.\n\nAccording to Newton's law of universal gravitation, the gravitational force exerted by this voxel on a test mass $m_t$ at the observation point is attractive, i.e., directed from $\\vec{r}_{\\mathrm{obs}}$ towards $\\vec{r}_i$. The force vector is:\n$$ \\vec{F}_i = - \\frac{G m_{\\mathrm{vox}} m_t}{d^2} \\hat{d} = - \\frac{G m_{\\mathrm{vox}} m_t}{d^3} \\vec{d} = \\frac{G m_{\\mathrm{vox}} m_t}{d^3} (-\\vec{d}) = \\frac{G m_{\\mathrm{vox}} m_t}{d^3} (x_i, y_i, z_i-h) $$\nThe acceleration contribution from this voxel is $\\vec{g}_i = \\vec{F}_i / m_t = \\frac{G m_{\\mathrm{vox}}}{d^3} (x_i, y_i, z_i-h)$.\nThe vertical ($z$) component of this acceleration is $g_{z,i} = \\frac{G m_{\\mathrm{vox}} (z_i - h)}{d^3}$.\nAs per the problem's sign convention (positive downward), we seek the component of acceleration in the $-z$ direction. This is $-g_{z,i}$:\n$$ g_{z,i}^{\\text{downward}} = - \\frac{G m_{\\mathrm{vox}} (z_i - h)}{d^3} = \\frac{G m_{\\mathrm{vox}} (h - z_i)}{(x_i^2 + y_i^2 + (h-z_i)^2)^{3/2}} $$\nThe total vertical gravity anomaly from the voxel model is the sum of contributions from all voxels whose centers $(x_i, y_i, z_i)$ satisfy the inclusion condition $x_i^2 + y_i^2 + z_i^2 \\le R^2$:\n$$ g_z^{\\mathrm{vox}}(h, \\Delta) = \\sum_{i,j,k \\text{ s.t. } x_{ijk}^2 + y_{ijk}^2 + z_{ijk}^2 \\le R^2} \\frac{G (\\Delta\\rho \\Delta^3) (h - z_{ijk})}{\\left( x_{ijk}^2 + y_{ijk}^2 + (h-z_{ijk})^2 \\right)^{3/2}} $$\nThe voxel center coordinates $(x_{ijk}, y_{ijk}, z_{ijk})$ are generated on a grid as specified. For an axis, the coordinates are $c_n = -R + (n+0.5)\\Delta$ for $n \\in \\{0, 1, ..., N-1\\}$ where $N = 2R/\\Delta$.\n\n#### 3. Error Calculation\nThe absolute error, $E(h, \\Delta)$, is calculated in SI units ($\\mathrm{m/s^2}$) and then converted to microgals (µGal).\n$$ E(h, \\Delta) [\\mathrm{m/s^2}] = \\left| g_z^{\\mathrm{vox}}(h, \\Delta) - g_z(h) \\right| $$\n$$ E(h, \\Delta) [\\mathrm{µGal}] = E(h, \\Delta) [\\mathrm{m/s^2}] \\times 10^8 $$\n\nThe algorithm will iterate through the four test cases, performing these calculations for each and reporting the final error in the specified format.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the absolute error between analytic and voxel-based gravity models\n    for a homogeneous sphere for a suite of test cases.\n    \"\"\"\n    # Define physical constants and model parameters\n    G = 6.67430e-11  # m^3 kg^-1 s^-2\n    R = 1000.0  # m\n    DELTA_RHO = 400.0  # kg/m^3\n    \n    # Unit conversion factor from m/s^2 to microgal\n    M_S2_TO_UGAL = 1e8\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (delta_m, h_m)\n    test_cases = [\n        (500.0, 500.0),    # Case 1\n        (250.0, 1000.0),   # Case 2\n        (100.0, 5000.0),   # Case 3\n        (1000.0, 1000.0)   # Case 4\n    ]\n\n    results = []\n    for delta, h in test_cases:\n        # --- 1. Compute the analytic gravity anomaly g_z(h) ---\n        if h  R:\n            # Inside the sphere: g_z = (4/3) * pi * G * delta_rho * h\n            g_z_analytic = (4.0/3.0) * np.pi * G * DELTA_RHO * h\n        else: # h >= R\n            # Outside or on the surface of the sphere: g_z = G * M / h^2\n            # M = delta_rho * (4/3) * pi * R^3\n            g_z_analytic = (4.0/3.0) * np.pi * G * DELTA_RHO * (R**3 / h**2)\n\n        # --- 2. Compute the voxel-based gravity anomaly g_z^vox(h, delta) ---\n        \n        # Number of voxels along one dimension of the bounding box\n        # Per problem spec, 2R/delta is an integer for all test cases\n        N = int(2 * R / delta)\n        \n        # Generate 1D array of voxel center coordinates for one axis\n        coords_1d = -R + (np.arange(N) + 0.5) * delta\n        \n        # Create 3D grid of voxel center coordinates (x, y, z)\n        x_grid, y_grid, z_grid = np.meshgrid(coords_1d, coords_1d, coords_1d, indexing='ij')\n\n        # Calculate the squared distance of each voxel center from the origin\n        dist_sq_from_origin = x_grid**2 + y_grid**2 + z_grid**2\n        \n        # Create a boolean mask for voxels whose centers are inside the sphere\n        inside_sphere_mask = dist_sq_from_origin = R**2\n\n        # Filter the coordinates to get only those inside the sphere\n        x_inside = x_grid[inside_sphere_mask]\n        y_inside = y_grid[inside_sphere_mask]\n        z_inside = z_grid[inside_sphere_mask]\n        \n        # If no voxel centers are inside the sphere (e.g., very coarse grid),\n        # the voxel contribution is zero.\n        if x_inside.size == 0:\n            g_z_vox = 0.0\n        else:\n            # Mass of a single voxel\n            m_vox = DELTA_RHO * delta**3\n    \n            # Calculate the squared distance from each included voxel to the observation point (0, 0, h)\n            dist_sq_from_obs = x_inside**2 + y_inside**2 + (h - z_inside)**2\n            dist_from_obs = np.sqrt(dist_sq_from_obs)\n\n            # Calculate the downward vertical gravity contribution from each voxel\n            # g_z_i = G * m_vox * (h - z_i) / d^3\n            # Note: dist_from_obs is guaranteed to be non-zero as per analysis in the thought process.\n            g_z_contributions = G * m_vox * (h - z_inside) / (dist_from_obs**3)\n    \n            # Sum the contributions from all voxels\n            g_z_vox = np.sum(g_z_contributions)\n\n        # --- 3. Compute the absolute error E(h, delta) ---\n        error_si = np.abs(g_z_vox - g_z_analytic)\n        \n        # Convert error to microgal (µGal)\n        error_ugal = error_si * M_S2_TO_UGAL\n        \n        results.append(error_ugal)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3597417"}, {"introduction": "Real geological structures are rarely simple, isolated bodies; we model them as a collection of many simpler shapes, relying on the principle of superposition. This exercise moves beyond a single body to explore the practical implications of summing the gravitational contributions from multiple sources [@problem_id:3597400]. You will not only verify the linearity of gravity anomalies but also confront a crucial challenge in computational science: the loss of precision from floating-point arithmetic, which you will learn to mitigate using a compensated summation algorithm.", "problem": "Design and implement a complete, runnable program that constructs a numerical test harness to verify the linear superposition of gravity anomalies and to quantify floating-point summation error. Work strictly from first principles: start from Newton’s law of gravitation and the shell theorem, implement the vertical component of gravitational acceleration due to multiple uniform-density spheres, and then build tests that (i) confirm linearity numerically and (ii) measure accumulation error from different summation orders.\n\nUse the following fundamental base:\n- Newton’s law of gravitation: a point mass of mass $M$ located at position $\\mathbf{r}_\\mathrm{c}$ produces acceleration at position $\\mathbf{r}_0$ equal to $\\mathbf{g}(\\mathbf{r}_0) = G M \\dfrac{\\mathbf{r}_\\mathrm{c}-\\mathbf{r}_0}{\\lVert \\mathbf{r}_\\mathrm{c} - \\mathbf{r}_0 \\rVert^3}$, where $G$ is the gravitational constant.\n- Shell theorem: for a uniform solid sphere of radius $a$ and mass $M$, the external field ($R \\ge a$) is identical to that of a point mass at the center, and the internal field ($R  a$) is linear in the distance $R$ from the center, with $\\mathbf{g} = - G M \\dfrac{\\mathbf{r}_0-\\mathbf{r}_\\mathrm{c}}{a^3}$.\n- Mass of a uniform sphere: $M = \\dfrac{4}{3}\\pi a^3 \\rho$, where $\\rho$ is the density (interpreted here as density contrast).\n\nAdopt a right-handed coordinate system with $x$ pointing east, $y$ pointing north, and $z$ positive upward. The vertical component of gravity is to be reported positive downward, as is conventional in geophysical practice. From the fundamental base above, the vertical component at $\\mathbf{r}_0 = (x_0,y_0,z_0)$ due to a uniform sphere centered at $\\mathbf{r}_\\mathrm{c} = (x_\\mathrm{c},y_\\mathrm{c},z_\\mathrm{c})$ with radius $a$ and density $\\rho$ is\n- define $\\Delta x = x_0 - x_\\mathrm{c}$, $\\Delta y = y_0 - y_\\mathrm{c}$, $\\Delta z = z_0 - z_\\mathrm{c}$, and $R = \\sqrt{(\\Delta x)^2 + (\\Delta y)^2 + (\\Delta z)^2}$;\n- define $M = \\dfrac{4}{3}\\pi a^3 \\rho$;\n- define the downward-positive vertical component as $$g_z^\\downarrow = G M \\Delta z \\times \\begin{cases} R^{-3},  R \\ge a, \\\\ a^{-3},  R  a. \\end{cases}$$\n\nUse the International System of Units (SI). Set the gravitational constant to $G = 6.67430\\times 10^{-11}\\,\\mathrm{m}^3\\,\\mathrm{kg}^{-1}\\,\\mathrm{s}^{-2}$. All lengths must be in $\\mathrm{m}$, density in $\\mathrm{kg/m^3}$, and the program must report gravity differences in microgal (microgalileo), where $1\\,\\mathrm{microgal} = 10^{-8}\\,\\mathrm{m/s^2}$, and total gravity values in the same unit when needed.\n\nImplement three summation strategies over per-sphere contributions $\\{g_{z,i}^\\downarrow\\}_{i=1}^N$:\n- Naive forward summation (left-to-right).\n- Naive summation with reordering by absolute value, ascending and descending.\n- Compensated summation using Kahan’s algorithm.\n\nFor each test case below, compute:\n- `d_order`: the absolute difference, in microgal, between naive sums taken in ascending and descending order of $|g_{z,i}^\\downarrow|$;\n- `d_naive_kahan`: the absolute difference, in microgal, between the naive forward sum (original body order) and the Kahan-compensated sum;\n- A linearity check boolean, computed by partitioning the set of bodies into two specified groups $A$ and $B$, computing $S_A$ and $S_B$ by Kahan-compensated summation within each group, and then testing whether $| (S_A + S_B) - S_{\\mathrm{all}} | \\le \\tau$, where $S_{\\mathrm{all}}$ is the Kahan-compensated sum over all bodies and $\\tau = 0.1\\,\\mathrm{microgal}$.\n\nTest suite and parameters. For all cases, the observation point is $\\mathbf{r}_0 = (0,0,0)\\,\\mathrm{m}$ and the program must compute and report the quantities defined above. Each sphere is specified by a tuple $(x_\\mathrm{c}, y_\\mathrm{c}, z_\\mathrm{c}, a, \\rho)$ with units $(\\mathrm{m},\\mathrm{m},\\mathrm{m},\\mathrm{m},\\mathrm{kg/m^3})$. Negative $\\rho$ values represent negative density contrast and are physically admissible in the context of anomalies.\n\n- Case 1 (balanced, non-overlapping, moderate contrasts; “happy path”):\n  - Bodies (eight spheres):\n    - $(+1500, 0, -1500, 300, +350)$,\n    - $(-1500, 0, -1500, 300, +350)$,\n    - $(0, +1500, -1500, 300, +350)$,\n    - $(0, -1500, -1500, 300, +350)$,\n    - $(+1200, +1200, -2200, 250, +200)$,\n    - $(-1200, +1200, -2200, 250, +200)$,\n    - $(+1200, -1200, -2200, 250, +200)$,\n    - $(-1200, -1200, -2200, 250, +200)$.\n  - Partition for linearity check: group $A$ is the first four spheres listed; group $B$ is the last four spheres.\n\n- Case 2 (strong cancellation; alternating contrasts):\n  - Bodies: for $k \\in \\{1,2,\\dots,10\\}$ define two spheres at the same depth,\n    - $(+500k, 0, -2000, 400, +400)$,\n    - $(-500k, 0, -2000, 400, -400)$.\n    This yields $20$ spheres total.\n  - Partition: group $A$ is all spheres with $\\rho > 0$, group $B$ is all spheres with $\\rho  0$.\n\n- Case 3 (extreme dynamic range; one dominant near source plus many weak far sources):\n  - Bodies:\n    - One dominant sphere: $(0, 0, -1200, 800, +500)$.\n    - Two rings of small spheres with alternating sign contrasts:\n      - Ring 1: radius $R_1 = 10000$, depth $z = -8000$, radius $a = 50$, density magnitude $|\\rho| = 100$, angles $\\theta_k = k \\times 15^\\circ$ for $k \\in \\{0,1,\\dots,23\\}$. For each $k$, place a sphere at $(R_1 \\cos\\theta_k, R_1 \\sin\\theta_k, -8000, 50, \\rho_k)$ with $\\rho_k = (+100)$ for even $k$ and $\\rho_k = (-100)$ for odd $k$.\n      - Ring 2: radius $R_2 = 15000$, depth $z = -10000$, radius $a = 50$, density magnitude $|\\rho| = 100$, angles $\\phi_k = k \\times 15^\\circ$ for $k \\in \\{0,1,\\dots,23\\}$. For each $k$, place a sphere at $(R_2 \\cos\\phi_k, R_2 \\sin\\phi_k, -10000, 50, \\rho'_k)$ with $\\rho'_k = (-100)$ for even $k$ and $\\rho'_k = (+100)$ for odd $k$.\n  - Partition: group $A$ is the single dominant sphere; group $B$ is all the small-ring spheres.\n\nComputational requirements:\n- Use $G = 6.67430 \\times 10^{-11}$ in SI units.\n- Treat all computations in double precision.\n- For the three metrics in each case, express differences in microgal. The linearity check must use the tolerance $\\tau = 0.1$ microgal exactly.\n- The program must run with no input and no external files and produce a single line of output containing the results as a comma-separated list of three entries (one for each case), where each entry is itself a list of the three values `[d_order, d_naive_kahan, linearity_ok]`. For example, a syntactically correct output has the form $[[x_1,y_1,b_1],[x_2,y_2,b_2],[x_3,y_3,b_3]]$ with the three $b_i$ being either $\\mathrm{True}$ or $\\mathrm{False}$. All $x_i$ and $y_i$ must be floats representing microgal values.", "solution": "The problem requires the design and implementation of a numerical test harness in Python to validate the principle of linear superposition for gravity anomalies and to quantify floating-point summation errors. This involves modeling the vertical gravitational acceleration from multiple spherical bodies, implementing various summation algorithms, and running a suite of defined test cases. The solution is developed from first principles as specified.\n\n### 1. Gravitational Model Formulation\n\nThe foundation of the model is Newton's universal law of gravitation and the shell theorem. We are interested in the vertical component of the gravitational acceleration, $g_z^\\downarrow$, at an observation point $\\mathbf{r}_0 = (x_0, y_0, z_0)$ due to a collection of uniform spheres. The coordinate system is defined with the $z$-axis positive upwards. Following geophysical convention, we define $g_z^\\downarrow$ as positive downwards.\n\nFor a single sphere with radius $a$, density contrast $\\rho$, and center at $\\mathbf{r}_\\mathrm{c} = (x_\\mathrm{c}, y_\\mathrm{c}, z_\\mathrm{c})$, the mass is given by $M = \\frac{4}{3}\\pi a^3 \\rho$. The vector from the sphere's center to the observation point is $\\mathbf{r}_0 - \\mathbf{r}_\\mathrm{c} = (\\Delta x, \\Delta y, \\Delta z)$. The distance is $R = \\lVert \\mathbf{r}_0 - \\mathbf{r}_\\mathrm{c} \\rVert$.\n\nThe gravitational acceleration vector, $\\mathbf{g}$, is given by $\\mathbf{g} = G M \\frac{\\mathbf{r}_\\mathrm{c} - \\mathbf{r}_0}{R^3}$ for an external point ($R \\ge a$) and $\\mathbf{g} = G M \\frac{\\mathbf{r}_\\mathrm{c} - \\mathbf{r}_0}{a^3}$ for an internal point ($R  a$). The vertical ($z$) component of this vector is $g_z = G M \\frac{z_\\mathrm{c} - z_0}{R^3} = -G M \\frac{\\Delta z}{R^3}$ for the external case. The downward-positive component is thus $g_z^\\downarrow = -g_z = G M \\frac{\\Delta z}{R^3}$. A similar derivation for the internal case yields $g_z^\\downarrow = G M \\frac{\\Delta z}{a^3}$. These expressions are combined into a single function:\n$$g_z^\\downarrow = G M \\Delta z \\times \\begin{cases} R^{-3},  R \\ge a, \\\\ a^{-3},  R  a. \\end{cases}$$\nThis formula is implemented in a function `calculate_gz_down` which takes a sphere's properties and the observation point coordinates, returning the vertical gravity anomaly in SI units ($\\mathrm{m/s^2}$). The gravitational constant is set to $G = 6.67430\\times 10^{-11}\\,\\mathrm{m}^3\\,\\mathrm{kg}^{-1}\\,\\mathrm{s}^{-2}$.\n\n### 2. Summation Algorithms and Error Quantification\n\nThe total gravity anomaly is the sum of contributions from all spheres, $g_{z, \\mathrm{total}}^\\downarrow = \\sum_{i=1}^N g_{z,i}^\\downarrow$. Due to the finite precision of floating-point arithmetic, the result of this summation can depend on the order of operations. The problem requires implementing and comparing three summation strategies.\n\n1.  **Naive Summation**: This is a direct left-to-right summation of the individual gravity values $\\{g_{z,i}^\\downarrow\\}$. This is implemented for three different orderings:\n    a.  The original order in which the spherical bodies are defined (`naive_sum` on the initial list).\n    b.  Ascending order of absolute magnitude, i.e., summing from the smallest $|g_{z,i}^\\downarrow|$ to the largest.\n    c.  Descending order of absolute magnitude.\n    The difference between the ascending and descending sums, $d_\\mathrm{order} = |S_{\\mathrm{asc}} - S_{\\mathrm{desc}}|$, quantifies the order-dependence of naive summation.\n\n2.  **Kahan Compensated Summation**: This is a well-known algorithm that significantly reduces numerical error in sums of floating-point numbers. It maintains a running compensation variable, $c$, to accumulate the low-order bits that are lost in each addition. The algorithm for summing a sequence of values $v_i$ is as follows:\n    - Initialize sum $s = 0$ and compensation $c = 0$.\n    - For each value $v_i$:\n        - $y = v_i - c$\n        - $t = s + y$\n        - $c = (t - s) - y$\n        - $s = t$\n    - The final result is $s$.\n    This is implemented in a function `kahan_sum`. The difference between the naive forward sum and the Kahan sum, $d_\\mathrm{naive\\_kahan} = |S_{\\mathrm{forward}} - S_{\\mathrm{Kahan}}|$, measures the error of the simplest summation method against a more accurate one.\n\n### 3. Linearity Verification\n\nThe principle of superposition states that the total field from multiple sources is the sum of the fields from each individual source. In our context, this means that if the set of all bodies is partitioned into two disjoint subsets, $A$ and $B$, the total anomaly should be the sum of the anomalies from each subset: $S_{\\mathrm{all}} = S_A + S_B$. While this is true analytically, floating-point errors can cause a discrepancy.\n\nThe linearity check is designed to test this numerically. Using the highly accurate Kahan summation for all calculations, we compute the sum over all bodies, $S_{\\mathrm{all}}$, as well as the sums for the specified groups A and B, $S_A$ and $S_B$. The check passes if the absolute difference is within a specified tolerance $\\tau = 0.1\\,\\mathrm{microgal}$:\n$$| (S_A + S_B) - S_{\\mathrm{all}} | \\le \\tau$$\nA boolean result, `linearity_ok`, is reported. This test primarily verifies the correctness of the partitioning and summation logic, as Kahan summation is expected to be sufficiently accurate for this identity to hold to high precision.\n\n### 4. Implementation Structure\n\nA main `solve` function orchestrates the process. It defines the parameters for the three test cases, including programmatic generation of sphere locations for Cases 2 and 3. For each case, a `process_case` function is called, which:\n1.  Calculates the individual $g_{z,i}^\\downarrow$ values for all spheres at the observation point $\\mathbf{r}_0 = (0,0,0)$.\n2.  Computes the sums using the various methods (`naive_sum` on different orderings, `kahan_sum`).\n3.  Calculates the required metrics: $d_\\mathrm{order}$ and $d_\\mathrm{naive\\_kahan}$.\n4.  Performs the linearity check based on the specified partitioning.\n5.  Converts final difference values from SI units to microgal ($1\\,\\mathrm{microgal} = 10^{-8}\\,\\mathrm{m/s^2}$) by multiplying by $10^8$.\n6.  Returns the three results as a list: $[d_\\mathrm{order}, d_\\mathrm{naive\\_kahan}, \\mathrm{linearity\\_ok}]$.\n\nFinally, the `solve` function collects the results from all test cases and prints them in the specified single-line format.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Main function to run the test harness for gravity anomaly calculations.\n    \"\"\"\n\n    # --- Constants and Unit Conversions ---\n    G = 6.67430e-11  # Gravitational constant in SI units (m^3 kg^-1 s^-2)\n    MKS_TO_MICROGAL = 1e8  # Conversion factor from m/s^2 to microgal\n    LINEARITY_TOLERANCE_MICROGAL = 0.1  # Tolerance for linearity check\n\n    # --- Core Calculation and Summation Functions ---\n\n    def calculate_gz_down(sphere, r0):\n        \"\"\"\n        Calculates the downward-positive vertical gravity component from a single sphere.\n        \n        Args:\n            sphere (tuple): (xc, yc, zc, a, rho) for the sphere.\n            r0 (tuple): (x0, y0, z0) for the observation point.\n\n        Returns:\n            float: The gravity anomaly gz_down in m/s^2.\n        \"\"\"\n        xc, yc, zc, a, rho = sphere\n        x0, y0, z0 = r0\n        \n        delta_x = x0 - xc\n        delta_y = y0 - yc\n        delta_z = z0 - zc\n        \n        R2 = delta_x**2 + delta_y**2 + delta_z**2\n        \n        if R2 == 0:\n            # Observation point is at the center of the sphere.\n            # Gravitational acceleration is zero by symmetry.\n            return 0.0\n\n        R = math.sqrt(R2)\n        mass = (4.0 / 3.0) * np.pi * (a**3) * rho\n        \n        if R >= a:\n            # External field\n            factor = R**(-3)\n        else:\n            # Internal field\n            factor = a**(-3)\n            \n        gz_down = G * mass * delta_z * factor\n        return gz_down\n\n    def naive_sum(values):\n        \"\"\"Naive left-to-right summation.\"\"\"\n        s = 0.0\n        for val in values:\n            s += val\n        return s\n\n    def kahan_sum(values):\n        \"\"\"Compensated summation using Kahan's algorithm.\"\"\"\n        s = 0.0\n        c = 0.0  # A running compensation for lost low-order bits.\n        for val in values:\n            y = val - c\n            t = s + y\n            c = (t - s) - y\n            s = t\n        return s\n\n    def process_case(spheres, partition):\n        \"\"\"\n        Processes a single test case to compute the required metrics.\n        \"\"\"\n        r0 = (0.0, 0.0, 0.0)\n        \n        # Step 1: Calculate individual gravity contributions in SI units (m/s^2)\n        gz_values = [calculate_gz_down(s, r0) for s in spheres]\n        \n        # Step 2: Perform Summations\n        s_naive_forward = naive_sum(gz_values)\n        \n        gz_sorted_asc = sorted(gz_values, key=abs)\n        s_asc = naive_sum(gz_sorted_asc)\n        \n        gz_sorted_desc = sorted(gz_values, key=abs, reverse=True)\n        s_desc = naive_sum(gz_sorted_desc)\n        \n        s_kahan_all = kahan_sum(gz_values)\n        \n        # Step 3: Calculate difference metrics\n        d_order = abs(s_asc - s_desc) * MKS_TO_MICROGAL\n        d_naive_kahan = abs(s_naive_forward - s_kahan_all) * MKS_TO_MICROGAL\n        \n        # Step 4: Linearity Check\n        group_A_indices, group_B_indices = partition\n        gz_group_A = [gz_values[i] for i in group_A_indices]\n        gz_group_B = [gz_values[i] for i in group_B_indices]\n        \n        s_kahan_A = kahan_sum(gz_group_A)\n        s_kahan_B = kahan_sum(gz_group_B)\n        \n        linearity_error = abs((s_kahan_A + s_kahan_B) - s_kahan_all) * MKS_TO_MICROGAL\n        linearity_ok = linearity_error = LINEARITY_TOLERANCE_MICROGAL\n        \n        return [d_order, d_naive_kahan, linearity_ok]\n    \n    # --- Define Test Cases ---\n\n    # Case 1: Balanced, non-overlapping, moderate contrasts\n    spheres_case1 = [\n        (1500.0, 0.0, -1500.0, 300.0, 350.0),\n        (-1500.0, 0.0, -1500.0, 300.0, 350.0),\n        (0.0, 1500.0, -1500.0, 300.0, 350.0),\n        (0.0, -1500.0, -1500.0, 300.0, 350.0),\n        (1200.0, 1200.0, -2200.0, 250.0, 200.0),\n        (-1200.0, 1200.0, -2200.0, 250.0, 200.0),\n        (1200.0, -1200.0, -2200.0, 250.0, 200.0),\n        (-1200.0, -1200.0, -2200.0, 250.0, 200.0),\n    ]\n    partition_case1 = (range(4), range(4, 8))\n\n    # Case 2: Strong cancellation; alternating contrasts\n    spheres_case2 = []\n    group_A_indices_c2, group_B_indices_c2 = [], []\n    for k in range(1, 11):\n        spheres_case2.append((500.0 * k, 0.0, -2000.0, 400.0, 400.0))\n        group_A_indices_c2.append(len(spheres_case2) - 1)\n        spheres_case2.append((-500.0 * k, 0.0, -2000.0, 400.0, -400.0))\n        group_B_indices_c2.append(len(spheres_case2) - 1)\n    partition_case2 = (group_A_indices_c2, group_B_indices_c2)\n\n    # Case 3: Extreme dynamic range\n    spheres_case3 = []\n    # Dominant sphere\n    spheres_case3.append((0.0, 0.0, -1200.0, 800.0, 500.0))\n    # Ring 1\n    R1, z1, a1, rho_mag1 = 10000.0, -8000.0, 50.0, 100.0\n    for k in range(24):\n        theta = k * np.pi / 12.0\n        xc, yc = R1 * np.cos(theta), R1 * np.sin(theta)\n        rho = rho_mag1 if k % 2 == 0 else -rho_mag1\n        spheres_case3.append((xc, yc, z1, a1, rho))\n    # Ring 2\n    R2, z2, a2, rho_mag2 = 15000.0, -10000.0, 50.0, 100.0\n    for k in range(24):\n        phi = k * np.pi / 12.0\n        xc, yc = R2 * np.cos(phi), R2 * np.sin(phi)\n        rho = -rho_mag2 if k % 2 == 0 else rho_mag2\n        spheres_case3.append((xc, yc, z2, a2, rho))\n    partition_case3 = ([0], range(1, 49))\n\n    test_cases = [\n        (spheres_case1, partition_case1),\n        (spheres_case2, partition_case2),\n        (spheres_case3, partition_case3),\n    ]\n\n    # --- Run Tests and Collect Results ---\n    results = [process_case(spheres, partition) for spheres, partition in test_cases]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3597400"}, {"introduction": "While direct summation in the space domain is intuitive, many powerful geophysical operators are most efficiently implemented in the frequency domain. This practice guides you through the derivation and implementation of one of the most fundamental potential-field operators: upward continuation [@problem_id:3597422]. By applying the Fast Fourier Transform (FFT), you will see firsthand how moving an observation plane upwards acts as a natural low-pass filter, attenuating short-wavelength anomalies more strongly than long-wavelength ones, a key concept in data processing and interpretation.", "problem": "A two-dimensional surface gravity anomaly field is a harmonic function above the observation plane when the field arises from subsurface mass distributions that are entirely below the plane. Starting from Newtonian gravitation and the property that the gravitational potential satisfies Laplace's equation in source-free regions, derive the upward continuation operator in the horizontal wavenumber domain for the gravity anomaly field. Then implement the operator and quantify how the upward continuation attenuates different horizontal wavelengths. Do not use any pre-derived formula for upward continuation; instead derive it from the governing equations.\n\nAssume the following fundamental base:\n- Newton's law of gravitation: the gravitational potential $\\Phi(\\mathbf{r})$ due to mass density $\\rho(\\mathbf{r}')$ satisfies Poisson's equation $\\nabla^2 \\Phi(\\mathbf{r}) = 4 \\pi G \\rho(\\mathbf{r})$, where $G$ is the gravitational constant and $\\mathbf{r}$ is position.\n- In regions with no sources, the gravitational potential satisfies Laplace's equation $\\nabla^2 \\Phi(\\mathbf{r}) = 0$.\n- The gravity anomaly measured on a horizontal plane is related to spatial derivatives of the potential and inherits the harmonic property above the plane.\n\nFrom these principles, show that each horizontal Fourier mode of the field attenuates with height and derive the functional dependence on the horizontal wavenumber magnitude.\n\nAlgorithmic task:\n1. Construct a synthetic two-dimensional gravity anomaly field `g(x,y)` on a rectangular grid that is periodic in $x$ and independent of $y$ but defined on the full two-dimensional grid. The field is a sum of cosine components with wavelengths $\\lambda \\in \\{2000\\,\\mathrm{m}, 4000\\,\\mathrm{m}, 8000\\,\\mathrm{m}, 10000\\,\\mathrm{m}, 20000\\,\\mathrm{m}, 40000\\,\\mathrm{m}\\}$, each with unit amplitude. The grid parameters are:\n   - Number of samples in $x$: $N_x = 320$.\n   - Number of samples in $y$: $N_y = 128$.\n   - Sampling interval in $x$: $\\Delta x = 500\\,\\mathrm{m}$.\n   - Sampling interval in $y$: $\\Delta y = 500\\,\\mathrm{m}$.\n   Consequently, the domain lengths are $L_x = N_x \\Delta x = 160000\\,\\mathrm{m}$ and $L_y = N_y \\Delta y = 64000\\,\\mathrm{m}$. Use cosine components $\\cos\\left(2\\pi x / \\lambda\\right)$ so that each wavelength fits an integer number of cycles in the domain $L_x$.\n2. Compute the two-dimensional Fast Fourier Transform (FFT; Fast Fourier Transform) of `g(x,y)`, where $\\mathbf{k} = (k_x, k_y)$ and $k_x = 2\\pi f_x$, $k_y = 2\\pi f_y$, with $f_x$ and $f_y$ being spatial frequencies in cycles per meter from the discrete Fourier transform frequency grids.\n3. Derive and implement the upward continuation operator in the wavenumber domain based on the solution of Laplace's equation for each Fourier mode. Apply the operator to the spectrum to obtain the spectrum at height $h$ above the original observation plane. Then compute the inverse FFT to obtain the upward continued field `g_h(x,y)` if needed.\n4. For specified test heights and target wavelengths, compute the attenuation factor for each wavelength as the ratio of spectral amplitudes at the corresponding horizontal wavenumber before and after upward continuation. For a target wavelength $\\lambda$, identify the corresponding $k_x$ bin index $m = L_x / \\lambda$ (an integer) and use the pair of spectral coefficients at $(k_x = +2\\pi m / L_x, k_y = 0)$ and $(k_x = -2\\pi m / L_x, k_y = 0)$. The attenuation factor for a wavelength is defined as the ratio of the sum of magnitudes of these two coefficients after upward continuation to the sum before upward continuation. This ratio is dimensionless.\n5. Express all heights in meters. The final attenuation values are dimensionless floats.\n\nTest suite:\n- Case A (general case): height $h = 2000\\,\\mathrm{m}$, wavelengths $\\lambda = [10000\\,\\mathrm{m}, 20000\\,\\mathrm{m}, 40000\\,\\mathrm{m}]$.\n- Case B (edge case near higher wavenumbers): height $h = 500\\,\\mathrm{m}$, wavelengths $\\lambda = [2000\\,\\mathrm{m}, 4000\\,\\mathrm{m}, 8000\\,\\mathrm{m}]$.\n- Case C (boundary condition): height $h = 0\\,\\mathrm{m}$, wavelengths $\\lambda = [10000\\,\\mathrm{m}, 20000\\,\\mathrm{m}, 40000\\,\\mathrm{m}]$.\n- Case D (strong attenuation): height $h = 20000\\,\\mathrm{m}$, wavelengths $\\lambda = [10000\\,\\mathrm{m}, 20000\\,\\mathrm{m}, 40000\\,\\mathrm{m}]$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to one test case and is itself a list of floats for the attenuation factors of the wavelengths in that case. For example, the output must look like: \"[[a1,a2,a3],[b1,b2,b3],[c1,c2,c3],[d1,d2,d3]]\" with no additional text.", "solution": "The supplied problem is assessed to be valid. It is scientifically grounded in the principles of potential field theory, is well-posed with a clearly defined objective and complete set of parameters, and uses objective, formal language. It represents a standard problem in computational geophysics.\n\n### Derivation of the Upward Continuation Operator\n\nThe derivation begins from the fundamental principles of Newtonian gravitation.\n\n1.  **Governing Equation**: The problem states that a surface gravity anomaly field, originating from subsurface mass distributions, is a harmonic function in the source-free region above the sources. Let the gravity anomaly field be denoted by $g(x, y, z)$. The observation plane is at $z=0$, and the upward direction is positive $z$. In the source-free half-space $z \\ge 0$, $g$ satisfies Laplace's equation:\n    $$ \\nabla^2 g(x, y, z) = \\frac{\\partial^2 g}{\\partial x^2} + \\frac{\\partial^2 g}{\\partial y^2} + \\frac{\\partial^2 g}{\\partial z^2} = 0 $$\n\n2.  **Fourier Transform Method**: We can solve this linear partial differential equation by applying a two-dimensional Fourier transform with respect to the horizontal spatial variables $x$ and $y$. Let $\\hat{g}(k_x, k_y, z)$ be the Fourier transform of $g(x, y, z)$:\n    $$ \\hat{g}(k_x, k_y, z) = \\mathcal{F}_{xy}[g(x, y, z)] = \\int_{-\\infty}^{\\infty} \\int_{-\\infty}^{\\infty} g(x, y, z) e^{-i(k_x x + k_y y)} dx dy $$\n    where $k_x$ and $k_y$ are the angular wavenumbers in the $x$ and $y$ directions, respectively. The properties of the Fourier transform state that differentiation with respect to a spatial variable becomes multiplication by the corresponding imaginary wavenumber in the Fourier domain:\n    $$ \\mathcal{F}_{xy}\\left[\\frac{\\partial^2 g}{\\partial x^2}\\right] = (i k_x)^2 \\hat{g} = -k_x^2 \\hat{g} $$\n    $$ \\mathcal{F}_{xy}\\left[\\frac{\\partial^2 g}{\\partial y^2}\\right] = (i k_y)^2 \\hat{g} = -k_y^2 \\hat{g} $$\n    The derivative with respect to $z$ is unaffected by the horizontal transform. Applying the Fourier transform to Laplace's equation yields:\n    $$ -k_x^2 \\hat{g}(k_x, k_y, z) - k_y^2 \\hat{g}(k_x, k_y, z) + \\frac{\\partial^2 \\hat{g}(k_x, k_y, z)}{\\partial z^2} = 0 $$\n\n3.  **Ordinary Differential Equation**: This simplifies the partial differential equation into an ordinary differential equation (ODE) in the variable $z$ for each wavenumber pair $(k_x, k_y)$:\n    $$ \\frac{d^2 \\hat{g}}{dz^2} = (k_x^2 + k_y^2) \\hat{g} $$\n    Let $k_r = \\sqrt{k_x^2 + k_y^2}$ be the magnitude of the horizontal wavenumber vector. The ODE becomes:\n    $$ \\frac{d^2 \\hat{g}}{dz^2} = k_r^2 \\hat{g} $$\n\n4.  **General Solution**: The general solution to this second-order linear ODE is:\n    $$ \\hat{g}(k_x, k_y, z) = A(k_x, k_y) e^{k_r z} + B(k_x, k_y) e^{-k_r z} $$\n    where $A$ and $B$ are coefficients that depend on the wavenumbers and are determined by boundary conditions.\n\n5.  **Boundary Conditions**:\n    a.  The gravitational field must remain finite and decay to zero as one moves infinitely far away from the sources. Therefore, we require that $g(x, y, z)$ is bounded as $z \\to \\infty$. In the wavenumber domain, this means $\\hat{g}(k_x, k_y, z)$ must also be bounded. Since $k_r = \\sqrt{k_x^2 + k_y^2} \\ge 0$, the term $e^{k_r z}$ grows unboundedly with $z$ for any $k_r > 0$. To satisfy the physical boundary condition, its coefficient must be zero: $A(k_x, k_y) = 0$. This leaves:\n    $$ \\hat{g}(k_x, k_y, z) = B(k_x, k_y) e^{-k_r z} $$\n    b.  At the observation plane $z=0$, the field is $g(x, y, 0)$, and its Fourier transform is $\\hat{g}(k_x, k_y, 0)$. Let us denote this known spectrum as $G(k_x, k_y)$. Setting $z=0$ in our solution:\n    $$ \\hat{g}(k_x, k_y, 0) = B(k_x, k_y) e^0 = B(k_x, k_y) $$\n    Thus, the coefficient $B$ is simply the Fourier spectrum of the gravity anomaly at the surface, $G(k_x, k_y)$.\n\n6.  **Upward Continuation Operator**: Substituting $B$ back into the solution, we obtain the spectrum of the field at any height $h > 0$:\n    $$ \\hat{g}(k_x, k_y, h) \\equiv G_h(k_x, k_y) = G(k_x, k_y) e^{-k_r h} = G(k_x, k_y) e^{-\\sqrt{k_x^2 + k_y^2} h} $$\n    The operator that transforms the spectrum at $z=0$ to the spectrum at $z=h$ is the **upward continuation operator** in the wavenumber domain:\n    $$ U(k_x, k_y, h) = e^{-k_r h} = e^{-\\sqrt{k_x^2 + k_y^2} h} $$\n\n7.  **Interpretation and Attenuation**: The operator $U$ is a real-valued exponential function that depends on the height $h$ and the radial wavenumber $k_r$. Since $h>0$ and $k_r \\ge 0$, the value of the operator is always between $0$ and $1$. It acts as a low-pass filter. For high wavenumbers (short wavelengths, corresponding to small, sharp features), $k_r$ is large, and the exponential term $e^{-k_r h}$ becomes very small, heavily attenuating these components. For low wavenumbers (long wavelengths, corresponding to large, broad features), $k_r$ is small, and $e^{-k_r h}$ is close to $1$, so these components are only weakly attenuated. The attenuation factor for a given wavenumber is the ratio of the amplitudes before and after continuation:\n    $$ \\text{Attenuation Factor} = \\frac{|G_h(k_x, k_y)|}{|G(k_x, ky)|} = \\frac{|G(k_x, k_y) e^{-k_r h}|}{|G(k_x, k_y)|} = |e^{-k_r h}| = e^{-k_r h} $$\n\n### Algorithmic Implementation\n\nThe algorithmic task involves numerically implementing this principle.\n\n1.  **Field Synthesis**: A $2$D gravity anomaly field $g(x,y)$ is synthesized on a grid of size $N_x \\times N_y$ with sampling intervals $\\Delta x, \\Delta y$. The field is a sum of cosine functions of specified wavelengths $\\lambda$, periodic in $x$ and constant in $y$.\n    $$ g(x,y) = \\sum_{\\lambda} \\cos\\left(\\frac{2\\pi x}{\\lambda}\\right) $$\n\n2.  **FFT**: The $2$D Fast Fourier Transform (FFT) of this field, $G(k_x, k_y)$, is computed using `numpy.fft.fft2`.\n\n3.  **Operator Construction**: The corresponding $2$D grids of angular wavenumbers, $k_x$ and $k_y$, are constructed from the discrete frequencies provided by `numpy.fft.fftfreq`. From these, the radial wavenumber grid $k_r = \\sqrt{k_x^2 + k_y^2}$ is computed. The upward continuation operator $U(k_x, k_y, h) = e^{-k_r h}$ is then constructed for a given height $h$.\n\n4.  **Application and Analysis**: The operator is applied to the spectrum $G(k_x, k_y)$ via element-wise multiplication to yield the upward-continued spectrum $G_h(k_x, k_y) = G(k_x, k_y) \\cdot U(k_x, k_y, h)$.\n\n5.  **Attenuation Calculation**: For each target wavelength $\\lambda$, the corresponding discrete wavenumber index $m = L_x / \\lambda$ is found. Since the input signal is a real sum of cosines, its spectrum is conjugate symmetric, with energy concentrated at positive and negative frequency pairs. The attenuation factor is computed as defined in the problem: the ratio of the sum of spectral coefficient magnitudes at $(k_x(\\pm m), k_y(0))$ after and before continuation.\n    $$ \\text{Attenuation}(\\lambda) = \\frac{|\\hat{g}_h(m,0)| + |\\hat{g}_h(N_x-m,0)|}{|\\hat{g}(m,0)| + |\\hat{g}(N_x-m,0)|} $$\n    This procedure is repeated for all test cases. For the case $h=0$, the operator is unity, and the attenuation factor is $1.0$, as expected.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and applies the upward continuation operator for a gravity anomaly field.\n    \"\"\"\n\n    #\n    # Part 1: Define grid and synthetic gravity field\n    #\n    Nx = 320         # Number of samples in x\n    Ny = 128         # Number of samples in y\n    dx = 500.0       # Sampling interval in x (m)\n    dy = 500.0       # Sampling interval in y (m)\n    Lx = Nx * dx     # Domain length in x (m)\n\n    # Wavelengths for the synthetic signal\n    signal_lambdas = [2000.0, 4000.0, 8000.0, 10000.0, 20000.0, 40000.0]\n\n    # Create the 1D x-coordinate vector\n    x = np.arange(Nx) * dx\n\n    # Create the 1D signal as a sum of cosine components\n    g_1d = np.zeros(Nx, dtype=float)\n    for lam in signal_lambdas:\n        g_1d += np.cos(2 * np.pi * x / lam)\n\n    # Tile the 1D signal to create the 2D field g(x,y)\n    g_xy = np.tile(g_1d, (Ny, 1))\n\n    #\n    # Part 2: Compute the 2D Fast Fourier Transform of the field\n    #\n    G_k = np.fft.fft2(g_xy)\n\n    #\n    # Part 3: Construct wavenumber grids for the operator\n    #\n    # Spatial frequencies (cycles/meter)\n    fx = np.fft.fftfreq(Nx, dx)\n    fy = np.fft.fftfreq(Ny, dy)\n\n    # Angular wavenumbers (radians/meter)\n    kx = 2 * np.pi * fx\n    ky = 2 * np.pi * fy\n\n    # Create 2D wavenumber grids\n    kxx, kyy = np.meshgrid(kx, ky)\n\n    # Radial wavenumber grid\n    kr = np.sqrt(kxx**2 + kyy**2)\n\n    #\n    # Part 4  5: Process test cases and compute attenuation factors\n    #\n    test_cases = [\n        # Case A: h=2000, lambdas=[10000, 20000, 40000]\n        (2000.0, [10000.0, 20000.0, 40000.0]),\n        # Case B: h=500, lambdas=[2000, 4000, 8000]\n        (500.0, [2000.0, 4000.0, 8000.0]),\n        # Case C: h=0, lambdas=[10000, 20000, 40000]\n        (0.0, [10000.0, 20000.0, 40000.0]),\n        # Case D: h=20000, lambdas=[10000, 20000, 40000]\n        (20000.0, [10000.0, 20000.0, 40000.0]),\n    ]\n\n    all_results = []\n\n    for h, target_lambdas in test_cases:\n        # Construct the upward continuation operator for the current height h\n        upward_continuation_operator = np.exp(-kr * h)\n\n        # Apply the operator to get the upward-continued spectrum\n        Gh_k = G_k * upward_continuation_operator\n\n        case_results = []\n        for lam in target_lambdas:\n            # The problem guarantees Lx / lam is an integer\n            m = int(round(Lx / lam))\n\n            # Indices for kx = +2*pi/lambda and kx = -2*pi/lambda\n            idx_pos_k = m\n            idx_neg_k = Nx - m\n\n            # The field is y-independent, so spectral energy is on the ky=0 axis (index 0)\n            ky_idx = 0\n\n            # Get the sum of magnitudes of the two spectral coefficients before continuation\n            sum_mag_before = np.abs(G_k[ky_idx, idx_pos_k]) + np.abs(G_k[ky_idx, idx_neg_k])\n\n            # Get the sum of magnitudes of the two spectral coefficients after continuation\n            sum_mag_after = np.abs(Gh_k[ky_idx, idx_pos_k]) + np.abs(Gh_k[ky_idx, idx_neg_k])\n\n            # The attenuation factor is the ratio of these sums.\n            # A check for sum_mag_before being near zero is good practice, but not\n            # strictly necessary here as the input signal guarantees energy at these wavelengths.\n            if sum_mag_before  1e-9:\n                attenuation = 1.0 if h == 0.0 else 0.0\n            else:\n                attenuation = sum_mag_after / sum_mag_before\n            \n            case_results.append(attenuation)\n\n        all_results.append(case_results)\n\n    # The final print statement must produce a single-line string representation\n    # of the list of lists, with no spaces.\n    print(str(all_results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "3597422"}]}