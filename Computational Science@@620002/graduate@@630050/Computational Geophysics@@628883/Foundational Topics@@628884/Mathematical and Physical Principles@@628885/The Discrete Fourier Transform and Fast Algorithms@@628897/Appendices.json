{"hands_on_practices": [{"introduction": "Accelerating convolution using the Fast Fourier Transform (FFT) is a cornerstone of computational geophysics, essential for operations like seismic modeling and filtering. This efficiency, however, relies on a crucial detail: the Discrete Fourier Transform (DFT) computes a circular convolution, not the linear convolution typically required by physical models. This practice moves beyond simply stating the zero-padding rule and challenges you to quantitatively explore the consequences of violating it, by directly calculating the time-domain aliasing (or 'wrap-around') artifacts that corrupt the result [@problem_id:3616396].", "problem": "In exploration seismology, the recorded trace is often modeled as the linear convolution of a band-limited source wavelet and a sparse reflectivity series. Frequency-domain implementations accelerate this operation using the Discrete Fourier Transform (DFT), computed by the Fast Fourier Transform (FFT). When the DFT length is insufficient relative to the total convolution length, the inverse DFT produces a circular convolution, causing time-domain wrap-around artifacts that corrupt early samples.\n\nConsider a finite source wavelet $w[n]$ and reflectivity series $r[n]$, indexed by $n \\in \\{0,1,2,\\dots\\}$ and zero outside their stated support. Let $w[n]$ have length $L=4$ with samples\n$$\nw[0]=2,\\quad w[1]=-1,\\quad w[2]=3,\\quad w[3]=1,\n$$\nand let $r[n]$ have length $M=5$ with samples\n$$\nr[0]=1,\\quad r[1]=-2,\\quad r[2]=0,\\quad r[3]=1,\\quad r[4]=2.\n$$\nDefine the linear convolution $y[n] = \\sum_{m=0}^{L-1} w[m]\\,r[n-m]$ for $n=0,1,\\dots,L+M-2$ with the convention that $r[n]=0$ for $n<0$ or $n>M-1$. Suppose we compute the convolution via frequency-domain multiplication using an $N$-point Discrete Fourier Transform (DFT) with $N=6$ (i.e., both $w[n]$ and $r[n]$ are zero-padded to length $N=6$, multiplied in the DFT domain, and then inverse transformed), yielding the $N$-point circular convolution $y^{(N)}[n]$, $n=0,1,\\dots,5$.\n\nStarting from the definition of the Discrete Fourier Transform (DFT) and its inverse, and the definition of linear convolution, determine quantitatively which time-domain samples of $y^{(N)}[n]$ are contaminated by wrap-around artifacts and compute their values. Report the contaminated sample values of $y^{(N)}[n]$ in order of increasing sample index as a single vector. No rounding is required. Use zero-based indexing throughout and assume sequences are real-valued.", "solution": "The problem requires the identification and calculation of time-domain samples from a circular convolution that are contaminated by wrap-around artifacts. This occurs when implementing linear convolution using the Discrete Fourier Transform (DFT) with a transform length $N$ that is insufficient to hold the full result of the linear convolution.\n\nFirst, we state the definitions and given data. The source wavelet, $w[n]$, is a sequence of length $L=4$ with values:\n$$\nw[0]=2, \\quad w[1]=-1, \\quad w[2]=3, \\quad w[3]=1\n$$\nThe reflectivity series, $r[n]$, is a sequence of length $M=5$ with values:\n$$\nr[0]=1, \\quad r[1]=-2, \\quad r[2]=0, \\quad r[3]=1, \\quad r[4]=2\n$$\nBoth sequences are zero for all other indices $n$.\n\nThe linear convolution, $y[n]$, of these two sequences is defined as:\n$$\ny[n] = (w * r)[n] = \\sum_{m=-\\infty}^{\\infty} w[m] r[n-m]\n$$\nFor finite-duration causal sequences, this becomes $y[n] = \\sum_{m=0}^{L-1} w[m] r[n-m]$. The resulting sequence $y[n]$ is non-zero over a support of length $L+M-1$. In this case, the length of $y[n]$ is $4+5-1 = 8$. The non-zero samples are for indices $n \\in \\{0, 1, \\dots, 7\\}$.\n\nThe problem states that the convolution is computed via an $N$-point DFT, with $N=6$. This involves zero-padding $w[n]$ and $r[n]$ to length $N=6$, computing their respective $N$-point DFTs, multiplying the DFTs, and performing an $N$-point inverse DFT. This procedure produces the $N$-point circular convolution of the padded sequences, which we denote as $y^{(N)}[n]$ or $y^{(6)}[n]$.\n\nThe relationship between the linear convolution $y[n]$ and the circular convolution $y^{(N)}[n]$ is given by the time-domain aliasing formula:\n$$\ny^{(N)}[n] = \\sum_{k=-\\infty}^{\\infty} y[n+kN]\n$$\nfor $n=0, 1, \\dots, N-1$. Here, $N=6$. This formula shows that the circular convolution is a sum of the linear convolution and its shifted (aliased) copies.\n\nA sample $y^{(N)}[n]$ is considered \"contaminated\" or affected by wrap-around if it is not equal to the corresponding linear convolution sample $y[n]$. This occurs when at least one term $y[n+kN]$ is non-zero for $k \\neq 0$. For a linear convolution $y[n]$ of length $L+M-1=8$, and a DFT length $N=6$, the samples of $y[n]$ with indices $n \\geq N$ will wrap around. In this case, the samples $y[6]$ and $y[7]$ will alias.\n\nThe sample $y[6]$ corresponds to $n=0$ and $k=1$ in the summation, since $0+1 \\cdot 6 = 6$. Thus, $y[6]$ will be added to $y[0]$, contaminating the circular convolution sample $y^{(6)}[0]$.\nThe sample $y[7]$ corresponds to $n=1$ and $k=1$ in the summation, since $1+1 \\cdot 6 = 7$. Thus, $y[7]$ will be added to $y[1]$, contaminating the circular convolution sample $y^{(6)}[1]$.\nFor indices $n \\in \\{2, 3, 4, 5\\}$, the term $y[n+k \\cdot 6]$ is non-zero only for $k=0$, because $y[n]$ is zero for $n \\geq 8$. Therefore, the samples $y^{(6)}[2]$ through $y^{(6)}[5]$ are uncontaminated and equal to their linear convolution counterparts.\n\nThe contaminated samples are at indices $n=0$ and $n=1$. To find their values, we must first compute the required samples of the linear convolution $y[n]$.\nThe linear convolution sequence $y[n]$ is calculated as follows:\n$y[0] = w[0]r[0] = (2)(1) = 2$\n$y[1] = w[0]r[1] + w[1]r[0] = (2)(-2) + (-1)(1) = -4 - 1 = -5$\n$y[2] = w[0]r[2] + w[1]r[1] + w[2]r[0] = (2)(0) + (-1)(-2) + (3)(1) = 0 + 2 + 3 = 5$\n$y[3] = w[0]r[3] + w[1]r[2] + w[2]r[1] + w[3]r[0] = (2)(1) + (-1)(0) + (3)(-2) + (1)(1) = 2 - 6 + 1 = -3$\n$y[4] = w[0]r[4] + w[1]r[3] + w[2]r[2] + w[3]r[1] = (2)(2) + (-1)(1) + (3)(0) + (1)(-2) = 4 - 1 - 2 = 1$\n$y[5] = w[1]r[4] + w[2]r[3] + w[3]r[2] = (-1)(2) + (3)(1) + (1)(0) = -2 + 3 = 1$\n$y[6] = w[2]r[4] + w[3]r[3] = (3)(2) + (1)(1) = 6 + 1 = 7$\n$y[7] = w[3]r[4] = (1)(2) = 2$\n\nNow we can calculate the values of the contaminated samples of the circular convolution $y^{(6)}[n]$.\nFor $n=0$:\n$$\ny^{(6)}[0] = \\sum_{k=-\\infty}^{\\infty} y[0+6k] = \\dots + y[-6] + y[0] + y[6] + y[12] + \\dots\n$$\nSince $y[n]$ is non-zero only for $n \\in \\{0, \\dots, 7\\}$, this sum reduces to:\n$$\ny^{(6)}[0] = y[0] + y[6] = 2 + 7 = 9\n$$\nFor $n=1$:\n$$\ny^{(6)}[1] = \\sum_{k=-\\infty}^{\\infty} y[1+6k] = \\dots + y[-5] + y[1] + y[7] + y[13] + \\dots\n$$\nThis sum reduces to:\n$$\ny^{(6)}[1] = y[1] + y[7] = -5 + 2 = -3\n$$\nThe contaminated samples are $y^{(6)}[0]=9$ and $y^{(6)}[1]=-3$. The problem asks for these values as a single vector in order of increasing index.", "answer": "$$\n\\boxed{\\begin{pmatrix} 9 & -3 \\end{pmatrix}}\n$$", "id": "3616396"}, {"introduction": "When we analyze a finite-duration signal, the DFT provides only a sampled view of its true, continuous spectrum—an effect often called the 'picket-fence' effect. This practice explores the important phenomenon of spectral leakage, where the energy of a sinusoid whose frequency falls between DFT bins is spread across the entire spectrum. By combining theoretical derivation with numerical implementation, you will gain a first-principles understanding of how to interpret DFT outputs and recognize the inherent limitations imposed by finite-time windowing [@problem_id:2443816].", "problem": "Consider the discrete-time complex sinusoid and its Discrete Fourier Transform (DFT) under a rectangular time window. Use the following fundamental bases: (i) the definition of the DFT as a finite sum over samples, and (ii) the geometric-series identity for summing complex exponentials. Define the sampled signal as $x[n] = A \\exp\\left(j \\left(2\\pi \\frac{f_0}{F_s} n + \\varphi\\right)\\right)$ for integer $n$ with $0 \\le n \\le N-1$, amplitude $A > 0$, sampling frequency $F_s$ in hertz, and phase $\\varphi$ in radians. The DFT index set is $k \\in \\{0,1,\\dots,N-1\\}$, with DFT bin center frequencies $f_k = \\frac{k}{N} F_s$. The DFT is $X[k] = \\sum_{n=0}^{N-1} x[n] \\exp\\left(-j 2\\pi \\frac{k}{N} n\\right)$. The Fast Fourier Transform (FFT) is an algorithm to compute this DFT exactly with fewer arithmetic operations. Angles must be in radians.\n\nYour tasks are:\n1) Starting from the DFT definition and the geometric-series sum, derive an expression for the DFT magnitude $|X[k]|$ of the rectangularly windowed complex sinusoid when the sinusoid’s frequency $f_0$ does not land on a DFT bin. Specialize your result to the case $f_0$ is exactly halfway between two adjacent bins, i.e., $f_0 = \\left(k_0 + \\frac{1}{2}\\right)\\frac{F_s}{N}$ for some integer $k_0$. From this, derive a closed-form expression for the “scalloping ratio” $\\rho_{\\mathrm{theory}}$, defined as the ratio between the largest DFT-bin magnitude $|X[k]|$ at this half-bin offset and the on-bin magnitude $|X[k_0]|$ that would occur if $f_0$ were exactly $f_{k_0}$. Express $\\rho_{\\mathrm{theory}}$ as a function of $N$ only.\n2) Implement a program that, for each specified test case below, constructs $x[n]$ with $f_0$ exactly halfway between bins $k_0$ and $k_0+1$, computes the DFT using both a direct $O(N^2)$ summation and a Fast Fourier Transform, and evaluates:\n   a) the measured scalloping ratio $\\rho_{\\mathrm{meas}} = \\frac{\\max_k |X[k]|}{A N}$,\n   b) the absolute error $|\\rho_{\\mathrm{meas}} - \\rho_{\\mathrm{theory}}|$,\n   c) the two-bin symmetry error, defined as $\\left|\\frac{|X[k_0]|}{|X[k_0+1]|} - 1\\right|$, and\n   d) the infinity-norm difference between the direct DFT and the FFT, normalized by $A N$, i.e., $\\frac{\\max_k |X_{\\mathrm{direct}}[k] - X_{\\mathrm{FFT}}[k]|}{A N}$.\nYou must compute the DFT using both methods and report the requested scalars.\n\nScientific realism requirement: Your derivation for $\\rho_{\\mathrm{theory}}$ must begin with the DFT definition and the finite geometric-series identity. Do not invoke any specialized window-transform “result” without showing how it follows from those bases. All angles must be in radians. No other physical units appear in the outputs. All outputs are dimensionless real numbers.\n\nTest suite: Use the following four parameter sets $(N, F_s, k_0, A, \\varphi)$:\n- Case 1: ($N=64, F_s=8000, k_0=10, A=1.0, \\varphi=0.3$)\n- Case 2: ($N=63, F_s=1000, k_0=7, A=2.0, \\varphi=1.2$)\n- Case 3: ($N=8, F_s=128, k_0=0, A=0.5, \\varphi=0.0$)\n- Case 4: ($N=1024, F_s=44100, k_0=123, A=1.0, \\varphi=2.3$)\n\nFor each case, construct $f_0 = \\left(k_0 + \\frac{1}{2}\\right)\\frac{F_s}{N}$, generate $x[n]$ for $0 \\le n \\le N-1$, and compute $X[k]$ via both methods.\n\nFinal output format: Your program should produce a single line of output containing the results aggregated across the four cases as a flat, comma-separated list enclosed in square brackets. For each case in the order listed above, append the three scalars in this order: the absolute scalloping-ratio error $|\\rho_{\\mathrm{meas}} - \\rho_{\\mathrm{theory}}|$, the two-bin symmetry error $\\left|\\frac{|X[k_0]|}{|X[k_0+1]|} - 1\\right|$, and the normalized DFT-versus-FFT infinity-norm difference $\\frac{\\max_k |X_{\\mathrm{direct}}[k] - X_{\\mathrm{FFT}}[k]|}{A N}$. Thus, the program must print a single list with $12$ floating-point numbers.", "solution": "The problem statement is critically validated and deemed to be sound. It is scientifically grounded in the principles of digital signal processing, well-posed with clear definitions and objectives, and free of any ambiguity or contradiction. We may therefore proceed with a formal solution.\n\nThe solution is presented in two parts as required: first, a theoretical derivation of the scalloping ratio, and second, an explanation of the numerical implementation to verify this theory and compute related error metrics.\n\n**Part 1: Derivation of the Theoretical Scalloping Ratio $\\rho_{\\mathrm{theory}}$**\n\nThe derivation starts from the definition of the Discrete Fourier Transform (DFT). The signal is a complex sinusoid sampled over a finite interval, which constitutes an implicit rectangular window.\n\nThe discrete-time signal is defined as $x[n] = A \\exp\\left(j \\left(2\\pi \\frac{f_0}{F_s} n + \\varphi\\right)\\right)$ for $n \\in \\{0, 1, \\dots, N-1\\}$.\nThe DFT, $X[k]$, is defined as:\n$$X[k] = \\sum_{n=0}^{N-1} x[n] \\exp\\left(-j 2\\pi \\frac{kn}{N}\\right)$$\nSubstituting the expression for $x[n]$:\n$$X[k] = \\sum_{n=0}^{N-1} A e^{j\\varphi} \\exp\\left(j 2\\pi \\frac{f_0}{F_s} n\\right) \\exp\\left(-j 2\\pi \\frac{kn}{N}\\right)$$\nWe can factor out the constant term $A e^{j\\varphi}$ and combine the exponentials:\n$$X[k] = A e^{j\\varphi} \\sum_{n=0}^{N-1} \\left[\\exp\\left(j 2\\pi \\left(\\frac{f_0}{F_s} - \\frac{k}{N}\\right)\\right)\\right]^n$$\nThis is a finite geometric series of the form $\\sum_{n=0}^{N-1} r^n$, where the common ratio is $r = \\exp\\left(j 2\\pi \\left(\\frac{f_0}{F_s} - \\frac{k}{N}\\right)\\right)$. Using the identity for the sum of a geometric series, $\\sum_{n=0}^{N-1} r^n = \\frac{1-r^N}{1-r}$, which holds for $r \\neq 1$:\n$$X[k] = A e^{j\\varphi} \\frac{1 - \\exp\\left(j 2\\pi \\left(\\frac{f_0}{F_s} - \\frac{k}{N}\\right) N\\right)}{1 - \\exp\\left(j 2\\pi \\left(\\frac{f_0}{F_s} - \\frac{k}{N}\\right)\\right)} = A e^{j\\varphi} \\frac{1 - \\exp\\left(j 2\\pi \\left(\\frac{Nf_0}{F_s} - k\\right)\\right)}{1 - \\exp\\left(j \\frac{2\\pi}{N} \\left(\\frac{Nf_0}{F_s} - k\\right)\\right)}$$\nTo find the magnitude $|X[k]|$, we use the identity $|1 - e^{j\\theta}| = |e^{j\\theta/2}(e^{-j\\theta/2} - e^{j\\theta/2})| = |-2j e^{j\\theta/2}\\sin(\\theta/2)| = 2|\\sin(\\theta/2)|$. Applying this to the numerator and denominator:\n$$|X[k]| = |A e^{j\\varphi}| \\left|\\frac{2\\sin\\left(\\pi \\left(\\frac{Nf_0}{F_s} - k\\right)\\right)}{2\\sin\\left(\\frac{\\pi}{N} \\left(\\frac{Nf_0}{F_s} - k\\right)\\right)}\\right| = A \\left| \\frac{\\sin\\left(\\pi \\left(\\frac{Nf_0}{F_s} - k\\right)\\right)}{\\sin\\left(\\frac{\\pi}{N} \\left(\\frac{Nf_0}{F_s} - k\\right)\\right)} \\right|$$\nThis is the general expression for the magnitude spectrum. Now, we specialize to the case where the frequency $f_0$ is exactly halfway between two adjacent DFT bins, $k_0$ and $k_0+1$: $f_0 = \\left(k_0 + \\frac{1}{2}\\right)\\frac{F_s}{N}$.\nThe term $\\frac{Nf_0}{F_s} - k$ becomes $k_0 + \\frac{1}{2} - k$.\nThe argument of the sine in the numerator is $\\pi \\left(k_0 - k + \\frac{1}{2}\\right)$. Since $k_0-k$ is an integer, let it be $m$. The argument is $m\\pi + \\frac{\\pi}{2}$. The sine of this angle is $\\sin(m\\pi + \\frac{\\pi}{2}) = \\cos(m\\pi) = (-1)^m$. Thus, its magnitude is always $1$.\nThe expression for the magnitude simplifies to:\n$$|X[k]| = \\frac{A}{\\left|\\sin\\left(\\frac{\\pi}{N} \\left(k_0 - k + \\frac{1}{2}\\right)\\right)\\right|}$$\nThe scalloping ratio $\\rho_{\\mathrm{theory}}$ compares the largest DFT magnitude at this half-bin offset to the on-bin magnitude. The on-bin magnitude is the value of $|X[k_0]|$ if the signal frequency were exactly on a bin, i.e., $f_0 = f_{k_0} = k_0\\frac{F_s}{N}$. In this on-bin case, the ratio $r$ for $k=k_0$ becomes $1$, and the geometric sum evaluates to $N$. The DFT is $X[k_0] = A e^{j\\varphi} N$, so the reference magnitude is $|X[k_0]|_{\\mathrm{on-bin}} = AN$.\n\nFor the half-bin case, the largest magnitude, $\\max_k |X[k]|$, occurs when the denominator $\\left|\\sin\\left(\\frac{\\pi}{N} \\left(k_0 - k + \\frac{1}{2}\\right)\\right)\\right|$ is minimized. This happens when the argument is closest to $0$. This occurs for $k = k_0$ and $k = k_0+1$.\nFor $k=k_0$, the argument is $\\frac{\\pi}{2N}$.\nFor $k=k_0+1$, the argument is $-\\frac{\\pi}{2N}$.\nIn both cases, the denominator's magnitude is $\\sin\\left(\\frac{\\pi}{2N}\\right)$ (assuming $N \\ge 2$, so the argument is in $(0, \\pi/2)$).\nThe largest DFT bin magnitude is therefore $\\max_k |X[k]| = \\frac{A}{\\sin\\left(\\frac{\\pi}{2N}\\right)}$.\n\nFinally, the theoretical scalloping ratio is the ratio of these two magnitudes:\n$$\\rho_{\\mathrm{theory}} = \\frac{\\max_k |X[k]|_{\\mathrm{half-bin}}}{|X[k_0]|_{\\mathrm{on-bin}}} = \\frac{A / \\sin\\left(\\frac{\\pi}{2N}\\right)}{AN} = \\frac{1}{N \\sin\\left(\\frac{\\pi}{2N}\\right)}$$\nThis is the required closed-form expression for $\\rho_{\\mathrm{theory}}$ as a function of $N$ only. For large $N$, using the approximation $\\sin(x) \\approx x$ for small $x$, we find $\\rho_{\\mathrm{theory}} \\approx \\frac{1}{N(\\pi/2N)} = \\frac{2}{\\pi} \\approx 0.6366$, which is the classic scalloping loss figure for a rectangular window.\n\n**Part 2: Numerical Implementation**\n\nThe provided program implements the computations specified in the problem statement for four test cases.\nFor each case $(N, F_s, k_0, A, \\varphi)$:\n$1$. The signal frequency $f_0$ is set to $f_0 = (k_0 + 0.5) \\frac{F_s}{N}$.\n$2$. The complex-valued signal $x[n]$ is generated for $n \\in \\{0, 1, \\dots, N-1\\}$.\n$3$. The DFT is computed using two methods:\n    a) A direct summation with $O(N^2)$ complexity, implemented via a matrix-vector product $X_{\\mathrm{direct}} = \\mathbf{W}x$, where $\\mathbf{W}$ is the $N \\times N$ DFT matrix with entries $W_{kn} = \\exp(-j2\\pi kn/N)$.\n    b) The Fast Fourier Transform (FFT) algorithm, using `numpy.fft.fft`, which computes the same DFT with $O(N \\log N)$ complexity.\n$4$. The following quantities are calculated:\n    a) The measured scalloping ratio $\\rho_{\\mathrm{meas}} = \\frac{\\max_k |X_{\\mathrm{FFT}}[k]|}{AN}$. We use the FFT result as it is the standard computational tool.\n    b) The absolute error $|\\rho_{\\mathrm{meas}} - \\rho_{\\mathrm{theory}}|$, which quantifies the agreement between our derived theory and the numerical computation. This should be close to machine precision.\n    c) The two-bin symmetry error $\\left|\\frac{|X_{\\mathrm{FFT}}[k_0]|}{|X_{\\mathrm{FFT}}[k_0+1]|} - 1\\right|$. Our derivation shows these two magnitudes should be identical, so this error measures the numerical symmetry of the computed spectrum.\n    d) The normalized infinity-norm difference $\\frac{\\max_k |X_{\\mathrm{direct}}[k] - X_{\\mathrm{FFT}}[k]|}{A N}$. This metric quantifies the numerical discrepancy between the two DFT computation methods, which arises from different orderings of floating-point operations and resultant round-off error accumulation.\n\nThe program then aggregates these three scalar error metrics for each of the four test cases into a single flat list of $12$ values for the final output.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the DFT scalloping loss problem for a set of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple is (N, Fs, k0, A, phi)\n    test_cases = [\n        (64, 8000.0, 10, 1.0, 0.3),\n        (63, 1000.0, 7, 2.0, 1.2),\n        (8, 128.0, 0, 0.5, 0.0),\n        (1024, 44100.0, 123, 1.0, 2.3),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        N, Fs, k0, A, phi = case\n\n        # 1. Construct signal\n        # Frequency is exactly halfway between bin k0 and k0+1\n        f0 = (k0 + 0.5) * Fs / N\n        n = np.arange(N)\n        # Complex sinusoid signal x[n]\n        x_n = A * np.exp(1j * (2 * np.pi * f0 / Fs * n + phi))\n\n        # 2. Compute DFT via direct O(N^2) summation\n        # Create the DFT matrix W\n        k = np.arange(N)\n        k_n_prod = np.outer(k, n)\n        W_matrix = np.exp(-1j * 2 * np.pi * k_n_prod / N)\n        # Compute DFT as a matrix-vector product\n        X_direct = W_matrix @ x_n\n\n        # 3. Compute DFT via FFT\n        X_fft = np.fft.fft(x_n)\n\n        # 4. Calculate the required metrics\n        \n        # a) Scalloping ratio error\n        # Theoretical scalloping ratio\n        # The argument of sin is small, so guard against N=0 (not in tests)\n        if N > 0:\n            rho_theory = 1.0 / (N * np.sin(np.pi / (2.0 * N)))\n        else:\n            rho_theory = 1.0 # Trivial case\n            \n        # Measured scalloping ratio using FFT results\n        max_mag_X_fft = np.max(np.abs(X_fft))\n        rho_meas = max_mag_X_fft / (A * N)\n        \n        # Absolute scalloping-ratio error\n        scalloping_ratio_error = np.abs(rho_meas - rho_theory)\n\n        # b) Two-bin symmetry error\n        # Magnitudes at bin k0 and k0+1 should be equal\n        mag_X_k0 = np.abs(X_fft[k0])\n        # The DFT is periodic, k0+1 is safe as k0  N-1 in all test cases.\n        mag_X_k0_plus_1 = np.abs(X_fft[k0 + 1])\n        \n        if mag_X_k0_plus_1 == 0:\n            # Avoid division by zero, though not expected here\n            symmetry_error = np.inf if mag_X_k0 != 0 else 0\n        else:\n            symmetry_error = np.abs(mag_X_k0 / mag_X_k0_plus_1 - 1.0)\n            \n        # c) Normalized difference between direct DFT and FFT\n        # Infinity norm of the difference vector\n        norm_inf_diff = np.max(np.abs(X_direct - X_fft)) / (A * N)\n        \n        # Append results for the current case\n        results.extend([scalloping_ratio_error, symmetry_error, norm_inf_diff])\n\n    # Final print statement in the exact required format.\n    # The format specifier ensures standard floating point representation.\n    print(f\"[{','.join(f'{r:.17e}' for r in results)}]\")\n\nsolve()\n```", "id": "2443816"}, {"introduction": "Building upon the challenge of off-bin frequencies and spectral leakage, this practice demonstrates a powerful technique to achieve high-precision frequency estimates. By correctly understanding zero-padding as a method for interpolating the underlying Discrete-Time Fourier Transform (DTFT), you will implement a quadratic fitting method to locate a spectral peak with sub-bin accuracy. This exercise provides a vital skill for any application, from microseismic analysis to harmonic noise removal, where quantitative accuracy is paramount [@problem_id:3616424].", "problem": "Consider a length-$N$ discrete-time complex sinusoid $x[n]$ with unit amplitude and fixed phase, whose normalized digital frequency corresponds to $m+0.3$ Discrete Fourier Transform (DFT) bins, where $m$ is an integer. By definition, the $k$-th DFT bin corresponds to the angular frequency $2\\pi k/N$ radians per sample. The base principles are: (i) the Discrete Fourier Transform (DFT) is a uniform sampling of the Discrete-Time Fourier Transform (DTFT) on the discrete frequency grid $2\\pi k/N$, and (ii) zero-padding a time-domain sequence to length $LN$ computes DFT samples on a denser frequency grid while leaving the underlying DTFT unchanged. You will quantify the effect of zero-padding on interpolated spectral peak localization by comparing $N$-point and $2N$-point DFT-based peak estimates for the same finite-duration sinusoid.\n\nTasks:\n1. Signal model and synthesis. For each test case $(N,m)$, synthesize the length-$N$ complex exponential\n$$\nx[n] = \\exp\\left(j\\left(2\\pi \\frac{m+0.3}{N} n + \\phi\\right)\\right), \\quad n=0,1,\\ldots,N-1,\n$$\nwith fixed phase $\\phi = \\pi/7$ (radians) and unit amplitude. Here $j$ denotes the imaginary unit.\n\n2. Spectral estimation with and without zero-padding. Compute the following:\n- An $N$-point DFT of $x[n]$ using a Fast Fourier Transform (FFT) algorithm, and determine the index $\\hat{k}$ of the maximum magnitude bin. Using only the magnitudes of the three bins at indices $\\hat{k}-1$, $\\hat{k}$, and $\\hat{k}+1$ (with circular wrap-around modulo $N$), fit a quadratic to estimate a sub-bin offset $\\delta \\in [-0.5,0.5]$ of the true maximum relative to $\\hat{k}$. The resulting interpolated peak location in $N$-bin units is $\\hat{\\kappa}_N = \\hat{k} + \\delta$. Report $\\hat{\\kappa}_N$ modulo $N$ so that $\\hat{\\kappa}_N \\in [0,N)$.\n- A $2N$-point DFT of the same $x[n]$ by zero-padding $x[n]$ with $N$ trailing zeros to length $2N$, again determining the index $\\hat{k}_{2N}$ of the maximum magnitude bin and computing a quadratic sub-bin offset $\\delta_{2N}$ using the three neighboring magnitudes at indices $\\hat{k}_{2N}-1$, $\\hat{k}_{2N}$, and $\\hat{k}_{2N}+1$ (with circular wrap-around modulo $2N$). Convert the resulting interpolated peak location to the original $N$-bin units: $\\hat{\\kappa}_{2N} = \\left(\\hat{k}_{2N} + \\delta_{2N}\\right)/2$, and report $\\hat{\\kappa}_{2N}$ modulo $N$ so that $\\hat{\\kappa}_{2N} \\in [0,N)$.\n\n3. Error quantification. For each method, compute the absolute error in $N$-bin units relative to the known true bin location $k_{\\text{true}} = m+0.3$:\n$$\ne_N = \\left|\\hat{\\kappa}_N - (m+0.3)\\right|, \\quad e_{2N} = \\left|\\hat{\\kappa}_{2N} - (m+0.3)\\right|.\n$$\n\n4. Numerical and algorithmic bases. You must:\n- Use the Discrete Fourier Transform (DFT) and a Fast Fourier Transform (FFT) algorithm to compute it.\n- Implement the quadratic peak interpolation by fitting a parabola to three points around the discrete maximum in the magnitude spectrum. Do not use any external peak-fitting utilities.\n\n5. Test suite. Use the following five test cases to exercise different regimes:\n- Case $1$: $N=64$, $m=10$ (general case).\n- Case $2$: $N=64$, $m=0$ (near direct current).\n- Case $3$: $N=64$, $m=31$ (near Nyquist for even $N$).\n- Case $4$: $N=257$, $m=100$ (non-power-of-two, large $N$).\n- Case $5$: $N=15$, $m=7$ (small odd $N$).\n\n6. Output specification. For each test case, your program must return a list of four floats:\n$$\n\\left[\\hat{\\kappa}_N, \\hat{\\kappa}_{2N}, e_N, e_{2N}\\right],\n$$\nrounded to $10^{-6}$ in $N$-bin units. Aggregate the five per-case lists into a single list in the same order as above. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example `[[...,...,...,...],[...,...,...,...],[...,...,...,...],[...,...,...,...],[...,...,...,...]]`.", "solution": "The problem requires an analysis of spectral peak estimation accuracy for a complex sinusoid using the Discrete Fourier Transform (DFT). We compare the performance of a standard $N$-point DFT with a $2N$-point DFT obtained by zero-padding the signal. The core of the estimation is a quadratic interpolation of the DFT magnitude spectrum around its peak.\n\nThe process for each test case $(N, m)$ is as follows:\n\n1.  **Signal Synthesis**: First, we construct the discrete-time complex sinusoidal signal $x[n]$ of length $N$. The signal is defined by the equation:\n    $$\n    x[n] = \\exp\\left(j\\left(2\\pi \\frac{k_{\\text{true}}}{N} n + \\phi\\right)\\right), \\quad n=0,1,\\ldots,N-1\n    $$\n    where $j$ is the imaginary unit, the phase is $\\phi = \\pi/7$, and the true normalized frequency is $k_{\\text{true}} = m+0.3$ bins. The time index vector is $n = [0, 1, \\ldots, N-1]$.\n\n2.  **$N$-Point DFT Analysis**:\n    -   We compute the $N$-point DFT of $x[n]$, denoted as $X[k]$, using a Fast Fourier Transform (FFT) algorithm.\n    -   We find the index $\\hat{k}$ corresponding to the maximum magnitude of the DFT spectrum: $\\hat{k} = \\arg\\max_k |X[k]|$.\n    -   To refine this estimate, we perform quadratic interpolation. This involves fitting a parabola to three points from the magnitude spectrum: $(\\hat{k}-1, |X[\\hat{k}-1]|)$, $(\\hat{k}, |X[\\hat{k}]|)$, and $(\\hat{k}+1, |X[\\hat{k}+1]|)$. The indices are handled with circular wrap-around, i.e., index $i$ is taken as $i \\pmod N$.\n    -   Let the three magnitude values be $y_{-1} = |X[(\\hat{k}-1) \\pmod N]|$, $y_0 = |X[\\hat{k}]|$, and $y_{1} = |X[(\\hat{k}+1) \\pmod N]|$. We find the vertex of the parabola passing through points $(-1, y_{-1})$, $(0, y_0)$, and $(1, y_{1})$. The horizontal coordinate of the vertex gives the sub-bin offset $\\delta$. The formula for $\\delta$ is:\n    $$\n    \\delta = \\frac{y_{-1} - y_{1}}{2(y_{-1} - 2y_0 + y_{1})}\n    $$\n    This offset $\\delta$ should be in the range $[-0.5, 0.5]$ since $\\hat{k}$ is the bin with maximum magnitude.\n    -   The interpolated peak location in $N$-bin units is $\\hat{\\kappa}_N = \\hat{k} + \\delta$. We apply a modulo $N$ operation as a safeguard to ensure the result is in $[0, N)$: $\\hat{\\kappa}_N = (\\hat{k} + \\delta) \\pmod N$.\n\n3.  **$2N$-Point DFT Analysis (with Zero-Padding)**:\n    -   The principle of zero-padding is that it provides a denser sampling of the signal's underlying Discrete-Time Fourier Transform (DTFT) without altering its shape. We create a new signal $x_{\\text{pad}}[n]$ of length $2N$ by appending $N$ zeros to the original signal $x[n]$.\n    -   We compute the $2N$-point DFT of $x_{\\text{pad}}[n]$, denoted $X_{2N}[k]$, using an FFT.\n    -   Similar to the $N$-point case, we find the peak magnitude bin index $\\hat{k}_{2N} = \\arg\\max_k |X_{2N}[k]|$.\n    -   We apply the same quadratic interpolation formula using the magnitudes at indices $(\\hat{k}_{2N}-1) \\pmod{2N}$, $\\hat{k}_{2N}$, and $(\\hat{k}_{2N}+1) \\pmod{2N}$ to find a sub-bin offset $\\delta_{2N}$.\n    -   The interpolated peak location in $2N$-bin units is $\\hat{k}_{2N} + \\delta_{2N}$. To compare this with the $N$-point estimate and the true frequency, we must convert it back to the original $N$-bin unit system by dividing by $2$:\n    $$\n    \\hat{\\kappa}_{2N} = \\frac{\\hat{k}_{2N} + \\delta_{2N}}{2}\n    $$\n    Again, we ensure the result is in $[0, N)$ by applying a modulo $N$ operation.\n\n4.  **Error Quantification**:\n    -   For both estimation methods, we compute the absolute error with respect to the known true frequency $k_{\\text{true}} = m+0.3$.\n    -   The errors are given by:\n    $$\n    e_N = |\\hat{\\kappa}_N - k_{\\text{true}}|\n    $$\n    $$\n    e_{2N} = |\\hat{\\kappa}_{2N} - k_{\\text{true}}|\n    $$\n    The results from these calculations will demonstrate that zero-padding (i.e., denser sampling of the DTFT) generally improves the accuracy of the quadratic interpolation frequency estimator.\n\n5.  **Implementation for Test Cases**: This entire procedure is applied to each of the five $(N, m)$ test cases. The final results, $[\\hat{\\kappa}_N, \\hat{\\kappa}_{2N}, e_N, e_{2N}]$, are collected for each case, rounded to $10^{-6}$, and formatted into a single list of lists as specified.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of estimating a sinusoid's frequency using DFT\n    with and without zero-padding, and quantifies the estimation error.\n    \"\"\"\n    \n    # Test cases as specified in the problem statement: (N, m)\n    test_cases = [\n        (64, 10),\n        (64, 0),\n        (64, 31),\n        (257, 100),\n        (15, 7),\n    ]\n\n    results = []\n\n    # Fixed phase for the sinusoid\n    phi = np.pi / 7.0\n\n    for N, m in test_cases:\n        # 1. Signal model and synthesis\n        k_true = m + 0.3\n        n = np.arange(N)\n        # Angular frequency in radians per sample\n        omega = 2.0 * np.pi * k_true / N\n        # Synthesize complex exponential signal\n        x_n = np.exp(1j * (omega * n + phi))\n\n        # 2. Spectral estimation without zero-padding (N-point DFT)\n        X_N = np.fft.fft(x_n)\n        X_N_mag = np.abs(X_N)\n        k_hat = int(np.argmax(X_N_mag))\n\n        # Quadratic interpolation for N-point DFT\n        # Get magnitudes of the peak and its immediate neighbors\n        y_m1 = X_N_mag[(k_hat - 1) % N]\n        y_0 = X_N_mag[k_hat]\n        y_p1 = X_N_mag[(k_hat + 1) % N]\n\n        # Parabola vertex formula for sub-bin offset delta\n        denominator_N = 2.0 * (y_m1 - 2.0 * y_0 + y_p1)\n        if np.isclose(denominator_N, 0):\n            delta_N = 0.0\n        else:\n            delta_N = (y_m1 - y_p1) / denominator_N\n        \n        # Interpolated peak location in N-bin units\n        kappa_hat_N = (k_hat + delta_N) % N\n\n        # 3. Spectral estimation with zero-padding (2N-point DFT)\n        # Pad the signal with N zeros to get a length 2N signal\n        x_padded = np.pad(x_n, (0, N), 'constant')\n        \n        X_2N = np.fft.fft(x_padded)\n        X_2N_mag = np.abs(X_2N)\n        k_hat_2N = int(np.argmax(X_2N_mag))\n        \n        # Quadratic interpolation for 2N-point DFT\n        y_m1_2N = X_2N_mag[(k_hat_2N - 1) % (2 * N)]\n        y_0_2N = X_2N_mag[k_hat_2N]\n        y_p1_2N = X_2N_mag[(k_hat_2N + 1) % (2 * N)]\n\n        denominator_2N = 2.0 * (y_m1_2N - 2.0 * y_0_2N + y_p1_2N)\n        if np.isclose(denominator_2N, 0):\n            delta_2N = 0.0\n        else:\n            delta_2N = (y_m1_2N - y_p1_2N) / denominator_2N\n        \n        # Interpolated peak location, converted back to N-bin units\n        kappa_hat_2N = ((k_hat_2N + delta_2N) / 2.0) % N\n\n        # 4. Error quantification\n        e_N = np.abs(kappa_hat_N - k_true)\n        e_2N = np.abs(kappa_hat_2N - k_true)\n\n        # 6. Output specification: round and collect results\n        case_result = [\n            round(kappa_hat_N, 6),\n            round(kappa_hat_2N, 6),\n            round(e_N, 6),\n            round(e_2N, 6)\n        ]\n        results.append(case_result)\n\n    # Format the final output string exactly as required\n    output_str = f\"[{','.join(map(str, results))}]\"\n    print(output_str)\n\nsolve()\n```", "id": "3616424"}]}