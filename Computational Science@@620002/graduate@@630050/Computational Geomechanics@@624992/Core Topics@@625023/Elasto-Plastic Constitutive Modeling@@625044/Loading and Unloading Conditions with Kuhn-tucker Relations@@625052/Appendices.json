{"hands_on_practices": [{"introduction": "The theoretical elegance of the Kuhn-Tucker conditions meets the practical realities of numerical computation at the loading/unloading switch. This practice guides you through implementing the core logic of a stress update algorithm: the 'elastic predictor' step and the subsequent decision to perform a 'plastic corrector'. By comparing a strict, Karush-Kuhn-Tucker (KKT)-consistent criterion ($f(\\sigma^{\\text{tr}}) > 0$) with a common tolerance-based approach, you will directly quantify how seemingly small implementation details can affect the accuracy of a simulation [@problem_id:3539935].", "problem": "Consider small-strain, rate-independent, one-dimensional elastoplasticity with linear isotropic elasticity and ideal (perfect) plasticity. Let Young's modulus be denoted by $E$ and the tensile yield stress by $\\sigma_{y}$. The body is subjected to a single strain increment from a stress-free and plastic-strain-free state. The elastoplastic model is defined by:\n- Elastic law: $\\sigma = E\\left(\\varepsilon - \\varepsilon^{p}\\right)$, where $\\sigma$ is the Cauchy stress, $\\varepsilon$ is the total strain, and $\\varepsilon^{p}$ is the plastic strain.\n- Yield function: $f(\\sigma) = \\lvert \\sigma \\rvert - \\sigma_{y} \\le 0$.\n- Karush-Kuhn-Tucker (KKT) conditions: $\\dot{\\lambda} \\ge 0$, $f(\\sigma) \\le 0$, and $\\dot{\\lambda}\\, f(\\sigma) = 0$; together with the associated flow rule $\\dot{\\varepsilon}^{p} = \\dot{\\lambda}\\, \\partial f / \\partial \\sigma$.\n- Elastic trial state (predictor): $\\sigma^{\\text{tr}} = E\\left(\\varepsilon - \\varepsilon^{p}_{n}\\right)$, with $\\varepsilon^{p}_{n}$ the plastic strain at the start of the increment.\n\nA stress update algorithm must decide whether the step is elastic/unloading (stay on the elastic branch with $\\dot{\\lambda}=0$) or plastic/loading (perform a return mapping to enforce $f(\\sigma)=0$). In exact theory, the branch selection is governed by the KKT conditions and the consistency principle. In numerical implementations, a scalar tolerance is often introduced that can blur the boundary between elastic and plastic classification.\n\nYour task is to implement and compare two branch-selection strategies for a single increment:\n- Strategy $\\mathcal{S}_{1}$ (KKT-consistent): classify the step as plastic if and only if $f(\\sigma^{\\text{tr}}) > 0$; otherwise classify as elastic/unloading.\n- Strategy $\\mathcal{S}_{2}$ (tolerance-blurred): fix a tolerance $\\eta > 0$ and classify the step as plastic if and only if $f(\\sigma^{\\text{tr}}) > -\\eta$; otherwise classify as elastic/unloading.\n\nFor either strategy, if the step is classified as elastic/unloading, take the updated stress equal to the trial stress, $\\sigma = \\sigma^{\\text{tr}}$. If the step is classified as plastic/loading, perform a radial (in one-dimension, sign-preserving) return to the yield surface, that is, set $\\sigma = \\operatorname{sign}(\\sigma^{\\text{tr}})\\, \\sigma_{y}$. The exact solution for the one-dimensional ideal plasticity update is given by the projection of the trial stress onto the admissible set, i.e., $\\sigma^{\\star} = \\operatorname{sign}(\\sigma^{\\text{tr}})\\, \\min\\left(\\lvert \\sigma^{\\text{tr}} \\rvert, \\sigma_{y}\\right)$.\n\nImplement a program that, for the parameter values and test strains below, computes for each test case:\n- a boolean indicating whether $\\mathcal{S}_{1}$ classifies the step as elastic/unloading,\n- a boolean indicating whether $\\mathcal{S}_{2}$ classifies the step as elastic/unloading,\n- the absolute error in the stress update for $\\mathcal{S}_{1}$ relative to the exact solution, expressed in Pascals,\n- the absolute error in the stress update for $\\mathcal{S}_{2}$ relative to the exact solution, expressed in Pascals.\n\nUse the following data and units:\n- Young's modulus $E = 30 \\times 10^{9}$ Pascal,\n- yield stress $\\sigma_{y} = 50 \\times 10^{6}$ Pascal,\n- tolerance $\\eta = 0.5 \\times 10^{6}$ Pascal,\n- initial stress $\\sigma_{n} = 0$ Pascal and initial plastic strain $\\varepsilon^{p}_{n} = 0$ (dimensionless),\n- total strain increment applied in a single step equals the final total strain $\\varepsilon$ (dimensionless).\n\nTest suite (three distinct cases to probe different facets of branch selection and update accuracy):\n- Case A (strictly inside the yield surface): $\\varepsilon_{A} = \\dfrac{\\sigma_{y} - 0.25 \\times 10^{6}}{E}$, for which $f(\\sigma^{\\text{tr}}) = -0.25 \\times 10^{6}$ Pascal.\n- Case B (exactly on the yield surface): $\\varepsilon_{B} = \\dfrac{\\sigma_{y}}{E}$, for which $f(\\sigma^{\\text{tr}}) = 0$ Pascal.\n- Case C (slightly outside the yield surface): $\\varepsilon_{C} = \\dfrac{\\sigma_{y} + 0.1 \\times 10^{6}}{E}$, for which $f(\\sigma^{\\text{tr}}) = +0.1 \\times 10^{6}$ Pascal.\n\nFor each case, compute the four outputs in the order listed above. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets; the list must contain one sublist per test case, with each sublist formatted as $[\\text{bool}, \\text{bool}, \\text{float}, \\text{float}]$. For example, the global output format is $[[b_{A1}, b_{A2}, e_{A1}, e_{A2}], [b_{B1}, b_{B2}, e_{B1}, e_{B2}], [b_{C1}, b_{C2}, e_{C1}, e_{C2}]]$, where the booleans denote elastic/unloading classification and the floats are absolute errors in Pascal.", "solution": "The problem is validated as self-contained, scientifically grounded, and well-posed. It pertains to a standard procedure in computational plasticity. All required data and definitions are provided.\n\nThe objective is to compare two distinct numerical strategies, $\\mathcal{S}_{1}$ and $\\mathcal{S}_{2}$, for classifying a material's response as elastic or plastic within a one-dimensional, rate-independent, ideal elastoplasticity framework. The comparison is based on the accuracy of the final stress state relative to the exact analytical solution for a single load increment. The model starts from a stress-free and plastic-strain-free state, i.e., $\\sigma_{n} = 0$ and $\\varepsilon^{p}_{n} = 0$.\n\nThe core of the problem lies in the elastic trial step. The trial stress, $\\sigma^{\\text{tr}}$, is computed assuming a purely elastic increment:\n$$ \\sigma^{\\text{tr}} = E(\\varepsilon - \\varepsilon^{p}_{n}) $$\nGiven the initial condition $\\varepsilon^{p}_{n} = 0$, this simplifies to:\n$$ \\sigma^{\\text{tr}} = E\\varepsilon $$\nwhere $\\varepsilon$ is the total strain applied in the single step. The yield function, $f(\\sigma) = \\lvert \\sigma \\rvert - \\sigma_{y}$, is then evaluated at this trial stress, $f(\\sigma^{\\text{tr}})$, to decide on the subsequent step.\n\nThe material parameters are given as:\n- Young's modulus, $E = 30 \\times 10^{9} \\text{ Pa}$\n- Yield stress, $\\sigma_{y} = 50 \\times 10^{6} \\text{ Pa}$\n- Numerical tolerance, $\\eta = 0.5 \\times 10^{6} \\text{ Pa}$\n\nThe two strategies for branch selection are:\n- Strategy $\\mathcal{S}_{1}$ (KKT-consistent): The state is classified as elastic/unloading if $f(\\sigma^{\\text{tr}}) \\le 0$, and plastic otherwise ($f(\\sigma^{\\text{tr}}) > 0$). This directly corresponds to the Karush-Kuhn-Tucker (KKT) conditions where plasticity is activated ($\\dot{\\lambda} > 0$) only if the yield condition is violated ($f(\\sigma) > 0$).\n- Strategy $\\mathcal{S}_{2}$ (tolerance-blurred): The state is classified as elastic/unloading if $f(\\sigma^{\\text{tr}}) \\le -\\eta$, and plastic otherwise ($f(\\sigma^{\\text{tr}}) > -\\eta$). This introduces a numerical tolerance, $\\eta$, that effectively expands the plastic loading region into a part of the elastic domain where the trial stress is close to the yield surface.\n\nThe stress update is performed based on the classification:\n- If elastic/unloading, the final stress is the trial stress: $\\sigma = \\sigma^{\\text{tr}}$.\n- If plastic/loading, the final stress is returned to the yield surface: $\\sigma = \\operatorname{sign}(\\sigma^{\\text{tr}}) \\sigma_{y}$.\n\nThe exact analytical solution, $\\sigma^{\\star}$, provides the benchmark for accuracy. It is the projection of the trial stress onto the admissible elastic domain $[-\\sigma_{y}, \\sigma_{y}]$:\n$$ \\sigma^{\\star} = \\operatorname{sign}(\\sigma^{\\text{tr}}) \\min(\\lvert \\sigma^{\\text{tr}} \\rvert, \\sigma_{y}) $$\n\nWe analyze the three test cases provided.\n\n**Case A: Strictly within the yield surface**\nThe total strain is $\\varepsilon_{A} = \\dfrac{\\sigma_{y} - 0.25 \\times 10^{6}}{E}$.\n1.  **Trial State**:\n    The trial stress is $\\sigma^{\\text{tr}}_{A} = E \\varepsilon_{A} = \\sigma_{y} - 0.25 \\times 10^{6} = 50 \\times 10^{6} - 0.25 \\times 10^{6} = 49.75 \\times 10^{6} \\text{ Pa}$.\n    The yield function value is $f(\\sigma^{\\text{tr}}_{A}) = \\lvert \\sigma^{\\text{tr}}_{A} \\rvert - \\sigma_{y} = 49.75 \\times 10^{6} - 50 \\times 10^{6} = -0.25 \\times 10^{6} \\text{ Pa}$.\n\n2.  **Strategy $\\mathcal{S}_{1}$**:\n    The condition for elastic/unloading is $f(\\sigma^{\\text{tr}}_{A}) \\le 0$. Since $-0.25 \\times 10^{6} \\le 0$, the step is classified as **elastic/unloading**.\n    The updated stress is $\\sigma_{\\mathcal{S}_{1}} = \\sigma^{\\text{tr}}_{A} = 49.75 \\times 10^{6} \\text{ Pa}$.\n\n3.  **Strategy $\\mathcal{S}_{2}$**:\n    The condition for elastic/unloading is $f(\\sigma^{\\text{tr}}_{A}) \\le -\\eta$. Here, $-0.25 \\times 10^{6} \\le -0.5 \\times 10^{6}$ is false. Therefore, the step is classified as **plastic**.\n    The updated stress is $\\sigma_{\\mathcal{S}_{2}} = \\operatorname{sign}(\\sigma^{\\text{tr}}_{A}) \\sigma_{y} = 1 \\times 50 \\times 10^{6} = 50 \\times 10^{6} \\text{ Pa}$.\n\n4.  **Exact Solution  Errors**:\n    The exact solution is $\\sigma^{\\star}_{A} = \\operatorname{sign}(\\sigma^{\\text{tr}}_{A}) \\min(\\lvert 49.75 \\times 10^{6} \\rvert, 50 \\times 10^{6}) = 49.75 \\times 10^{6} \\text{ Pa}$.\n    The absolute error for $\\mathcal{S}_{1}$ is $e_{A1} = \\lvert \\sigma_{\\mathcal{S}_{1}} - \\sigma^{\\star}_{A} \\rvert = \\lvert 49.75 \\times 10^{6} - 49.75 \\times 10^{6} \\rvert = 0 \\text{ Pa}$.\n    The absolute error for $\\mathcal{S}_{2}$ is $e_{A2} = \\lvert \\sigma_{\\mathcal{S}_{2}} - \\sigma^{\\star}_{A} \\rvert = \\lvert 50 \\times 10^{6} - 49.75 \\times 10^{6} \\rvert = 0.25 \\times 10^{6} \\text{ Pa}$.\n\n5.  **Outputs for Case A**: $[\\text{True}, \\text{False}, 0.0, 250000.0]$\n\n**Case B: Exactly on the yield surface**\nThe total strain is $\\varepsilon_{B} = \\dfrac{\\sigma_{y}}{E}$.\n1.  **Trial State**:\n    The trial stress is $\\sigma^{\\text{tr}}_{B} = E \\varepsilon_{B} = \\sigma_{y} = 50 \\times 10^{6} \\text{ Pa}$.\n    The yield function value is $f(\\sigma^{\\text{tr}}_{B}) = \\lvert \\sigma^{\\text{tr}}_{B} \\rvert - \\sigma_{y} = 50 \\times 10^{6} - 50 \\times 10^{6} = 0 \\text{ Pa}$.\n\n2.  **Strategy $\\mathcal{S}_{1}$**:\n    The condition $f(\\sigma^{\\text{tr}}_{B}) \\le 0$ is met ($0 \\le 0$). The step is classified as **elastic/unloading**.\n    The updated stress is $\\sigma_{\\mathcal{S}_{1}} = \\sigma^{\\text{tr}}_{B} = 50 \\times 10^{6} \\text{ Pa}$.\n\n3.  **Strategy $\\mathcal{S}_{2}$**:\n    The condition $f(\\sigma^{\\text{tr}}_{B}) \\le -\\eta$ ($0 \\le -0.5 \\times 10^{6}$) is false. The step is classified as **plastic**.\n    The updated stress is $\\sigma_{\\mathcal{S}_{2}} = \\operatorname{sign}(\\sigma^{\\text{tr}}_{B}) \\sigma_{y} = 1 \\times 50 \\times 10^{6} = 50 \\times 10^{6} \\text{ Pa}$.\n\n4.  **Exact Solution  Errors**:\n    The exact solution is $\\sigma^{\\star}_{B} = \\operatorname{sign}(\\sigma^{\\text{tr}}_{B}) \\min(\\lvert 50 \\times 10^{6} \\rvert, 50 \\times 10^{6}) = 50 \\times 10^{6} \\text{ Pa}$.\n    The absolute error for $\\mathcal{S}_{1}$ is $e_{B1} = \\lvert \\sigma_{\\mathcal{S}_{1}} - \\sigma^{\\star}_{B} \\rvert = \\lvert 50 \\times 10^{6} - 50 \\times 10^{6} \\rvert = 0 \\text{ Pa}$.\n    The absolute error for $\\mathcal{S}_{2}$ is $e_{B2} = \\lvert \\sigma_{\\mathcal{S}_{2}} - \\sigma^{\\star}_{B} \\rvert = \\lvert 50 \\times 10^{6} - 50 \\times 10^{6} \\rvert = 0 \\text{ Pa}$.\n\n5.  **Outputs for Case B**: $[\\text{True}, \\text{False}, 0.0, 0.0]$\n\n**Case C: Strictly outside the yield surface**\nThe total strain is $\\varepsilon_{C} = \\dfrac{\\sigma_{y} + 0.1 \\times 10^{6}}{E}$.\n1.  **Trial State**:\n    The trial stress is $\\sigma^{\\text{tr}}_{C} = E \\varepsilon_{C} = \\sigma_{y} + 0.1 \\times 10^{6} = 50 \\times 10^{6} + 0.1 \\times 10^{6} = 50.1 \\times 10^{6} \\text{ Pa}$.\n    The yield function value is $f(\\sigma^{\\text{tr}}_{C}) = \\lvert \\sigma^{\\text{tr}}_{C} \\rvert - \\sigma_{y} = 50.1 \\times 10^{6} - 50 \\times 10^{6} = 0.1 \\times 10^{6} \\text{ Pa}$.\n\n2.  **Strategy $\\mathcal{S}_{1}$**:\n    The condition $f(\\sigma^{\\text{tr}}_{C}) \\le 0$ ($0.1 \\times 10^{6} \\le 0$) is false. The step is classified as **plastic**.\n    The updated stress is $\\sigma_{\\mathcal{S}_{1}} = \\operatorname{sign}(\\sigma^{\\text{tr}}_{C}) \\sigma_{y} = 1 \\times 50 \\times 10^{6} = 50 \\times 10^{6} \\text{ Pa}$.\n\n3.  **Strategy $\\mathcal{S}_{2}$**:\n    The condition $f(\\sigma^{\\text{tr}}_{C}) \\le -\\eta$ ($0.1 \\times 10^{6} \\le -0.5 \\times 10^{6}$) is false. The step is classified as **plastic**.\n    The updated stress is $\\sigma_{\\mathcal{S}_{2}} = \\operatorname{sign}(\\sigma^{\\text{tr}}_{C}) \\sigma_{y} = 1 \\times 50 \\times 10^{6} = 50 \\times 10^{6} \\text{ Pa}$.\n\n4.  **Exact Solution  Errors**:\n    The exact solution is $\\sigma^{\\star}_{C} = \\operatorname{sign}(\\sigma^{\\text{tr}}_{C}) \\min(\\lvert 50.1 \\times 10^{6} \\rvert, 50 \\times 10^{6}) = 50 \\times 10^{6} \\text{ Pa}$.\n    The absolute error for $\\mathcal{S}_{1}$ is $e_{C1} = \\lvert \\sigma_{\\mathcal{S}_{1}} - \\sigma^{\\star}_{C} \\rvert = \\lvert 50 \\times 10^{6} - 50 \\times 10^{6} \\rvert = 0 \\text{ Pa}$.\n    The absolute error for $\\mathcal{S}_{2}$ is $e_{C2} = \\lvert \\sigma_{\\mathcal{S}_{2}} - \\sigma^{\\star}_{C} \\rvert = \\lvert 50 \\times 10^{6} - 50 \\times 10^{6} \\rvert = 0 \\text{ Pa}$.\n\n5.  **Outputs for Case C**: $[\\text{False}, \\text{False}, 0.0, 0.0]$\n\nIn summary, the tolerance-based strategy $\\mathcal{S}_{2}$ incorrectly classifies states that are elastic but close to the yield surface (Cases A and B) as plastic. This leads to an erroneous stress update in Case A, where the trial stress is inside the yield surface. The KKT-consistent strategy $\\mathcal{S}_{1}$ provides the correct classification and perfectly accurate stress update for all three cases.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and compares two branch-selection strategies for a 1D\n    elastoplastic model.\n    \"\"\"\n    \n    # Define physical and numerical parameters\n    E = 30.0 * 10**9       # Young's modulus in Pascals\n    sigma_y = 50.0 * 10**6 # Yield stress in Pascals\n    eta = 0.5 * 10**6      # Numerical tolerance in Pascals\n\n    # Define test cases based on the given strain definitions\n    # Case A: Strictly inside the yield surface\n    # Case B: Exactly on the yield surface\n    # Case C: Slightly outside the yield surface\n    test_strains = [\n        (sigma_y - 0.25 * 10**6) / E, # Case A\n        sigma_y / E,                   # Case B\n        (sigma_y + 0.1 * 10**6) / E      # Case C\n    ]\n\n    all_results = []\n    for eps in test_strains:\n        # Calculate the elastic trial stress and the yield function value\n        sigma_tr = E * eps\n        f_sigma_tr = abs(sigma_tr) - sigma_y\n\n        # --- Strategy S1 (KKT-consistent) ---\n        # Classify step: elastic if f(sigma_tr) = 0\n        is_elastic_s1 = (f_sigma_tr = 0)\n        \n        # Update stress according to S1 classification\n        if is_elastic_s1:\n            sigma_s1 = sigma_tr\n        else:  # Plastic step\n            sigma_s1 = np.sign(sigma_tr) * sigma_y\n\n        # --- Strategy S2 (tolerance-blurred) ---\n        # Classify step: elastic if f(sigma_tr) = -eta\n        is_elastic_s2 = (f_sigma_tr = -eta)\n\n        # Update stress according to S2 classification\n        if is_elastic_s2:\n            sigma_s2 = sigma_tr\n        else:  # Plastic step\n            sigma_s2 = np.sign(sigma_tr) * sigma_y\n\n        # --- Exact Solution ---\n        # The exact solution is the projection of the trial stress onto the\n        # admissible stress interval [-sigma_y, sigma_y].\n        sigma_star = np.sign(sigma_tr) * min(abs(sigma_tr), sigma_y)\n\n        # --- Calculate Absolute Errors ---\n        error_s1 = abs(sigma_s1 - sigma_star)\n        error_s2 = abs(sigma_s2 - sigma_star)\n\n        # Store the four required outputs for this case\n        case_results = [is_elastic_s1, is_elastic_s2, float(error_s1), float(error_s2)]\n        all_results.append(case_results)\n\n    # Format the final output string to match the required format:\n    # [[bool,bool,float,float],[bool,bool,float,float],[bool,bool,float,float]]\n    # with no spaces within the inner lists.\n    sublist_strs = []\n    for res in all_results:\n        # res[0] and res[1] are booleans (True/False)\n        # res[2] and res[3] are floats\n        sublist_strs.append(f\"[{res[0]},{res[1]},{res[2]},{res[3]}]\")\n\n    final_output = f\"[{','.join(sublist_strs)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "3539935"}, {"introduction": "While numerical tolerances are unavoidable, a naive, fixed tolerance can lead to significant errors, especially in stiff geomaterials where small strain increments produce large stress changes. This exercise [@problem_id:3539952] moves beyond simple thresholds to a more robust and physically-grounded check for plastic loading. You will implement a classification scheme that uses not only the value of the yield function but also the direction of the stress increment, introducing scaled tolerances that intelligently adapt to the problem's physics and prevent false plastic activation.", "problem": "Consider a small-strain, rate-independent perfect plasticity model for geomaterials with a smooth yield function $f(\\boldsymbol{\\sigma}, \\boldsymbol{\\alpha}) \\le 0$, where $\\boldsymbol{\\sigma}$ is the Cauchy stress tensor and $\\boldsymbol{\\alpha}$ is a vector of internal variables. The plastic flow is governed by the Karush-Kuhn-Tucker (KKT) relations: $f \\le 0$, $\\dot{\\lambda} \\ge 0$, and $\\dot{\\lambda} f = 0$, where $\\dot{\\lambda}$ is the plastic multiplier rate. In computational implementations, numerical tolerances are introduced to decide between elastic unloading and plastic loading when $f$ is close to zero. A purely threshold-based test $f \\le \\tau$ may falsely activate plastic loading in very stiff soils due to large stress increments and floating-point noise.\n\nStarting from the fundamental definitions and laws of incremental elastoplasticity under small strain, and expressing all quantities in megapascals (MPa), design a robust complementarity-based classification that, for a trial state with yield residual $f_{\\mathrm{tr}}$ and stress increment $\\Delta\\boldsymbol{\\sigma}$, distinguishes between loading and unloading using the directional derivative of the yield function along the stress path. Use the gradient $\\mathbf{n} = \\partial f / \\partial \\boldsymbol{\\sigma}$ evaluated at the trial state to compute the consistency indicator $d_f = \\mathbf{n}^{\\mathsf{T}} \\Delta\\boldsymbol{\\sigma}$, and implement scaled numerical tolerances that are physically meaningful under stiff response.\n\nYour robust classification must use two scaled tolerances:\n- A yield-residual tolerance $T_f = \\tau_{\\mathrm{abs}} + \\tau_{\\mathrm{rel}} \\lVert \\mathbf{n} \\rVert_2 \\lVert \\Delta\\boldsymbol{\\sigma} \\rVert_2$, with $\\tau_{\\mathrm{abs}$} in MPa and $\\tau_{\\mathrm{rel}}$ dimensionless.\n- A consistency tolerance $T_c = \\tau_{\\mathrm{dir}} \\lVert \\mathbf{n} \\rVert_2 \\lVert \\Delta\\boldsymbol{\\sigma} \\rVert_2$, with $\\tau_{\\mathrm{dir}}$ dimensionless.\n\nClassify as follows:\n- Declare loading if $f_{\\mathrm{tr}} > T_f$ and $d_f \\ge T_c$.\n- Declare unloading if $f_{\\mathrm{tr}} \\le T_f$ and $d_f \\le -T_c$.\n- Declare neutral if neither condition holds.\n\nAdditionally, define a naive classification that declares loading if and only if $f_{\\mathrm{tr}} > \\tau_{\\mathrm{abs}}$; otherwise declare unloading. Report the number of false activations as the count of cases where the naive test declares loading but the robust classification declares unloading.\n\nImplement a program that applies these rules to the following test suite. All stresses and stress increments are in MPa; angles are not used. The gradient $\\mathbf{n}$ is dimensionless and provided as a vector in a reduced stress space where the dot product with $\\Delta\\boldsymbol{\\sigma}$ is well-defined. Each test case is given as a tuple $(f_{\\mathrm{tr}}, \\mathbf{n}, \\Delta\\boldsymbol{\\sigma}, \\tau_{\\mathrm{abs}}, \\tau_{\\mathrm{rel}}, \\tau_{\\mathrm{dir}})$:\n\n- Case $1$ (happy path unloading): $f_{\\mathrm{tr}} = -5.0$, $\\mathbf{n} = [1.0, 0.0, 0.0]$, $\\Delta\\boldsymbol{\\sigma} = [-2.0, 0.0, 0.0]$, $\\tau_{\\mathrm{abs}} = 0.001$, $\\tau_{\\mathrm{rel}} = 0.01$, $\\tau_{\\mathrm{dir}} = 0.005$.\n- Case $2$ (near-yield, negative direction): $f_{\\mathrm{tr}} = 0.0005$, $\\mathbf{n} = [0.6, 0.8, 0.0]$, $\\Delta\\boldsymbol{\\sigma} = [-0.002, 0.0, 0.0]$, $\\tau_{\\mathrm{abs}} = 0.001$, $\\tau_{\\mathrm{rel}} = 0.1$, $\\tau_{\\mathrm{dir}} = 0.05$.\n- Case $3$ (clear loading): $f_{\\mathrm{tr}} = 0.2$, $\\mathbf{n} = [1.0, 0.0, 0.0]$, $\\Delta\\boldsymbol{\\sigma} = [0.5, 0.0, 0.0]$, $\\tau_{\\mathrm{abs}} = 0.001$, $\\tau_{\\mathrm{rel}} = 0.01$, $\\tau_{\\mathrm{dir}} = 0.001$.\n- Case $4$ (boundary neutral): $f_{\\mathrm{tr}} = 0.0007$, $\\mathbf{n} = [1.0, 0.0, 0.0]$, $\\Delta\\boldsymbol{\\sigma} = [0.002, 0.0, 0.0]$, $\\tau_{\\mathrm{abs}} = 0.001$, $\\tau_{\\mathrm{rel}} = 0.1$, $\\tau_{\\mathrm{dir}} = 0.1$.\n- Case $5$ (stiff soil, large increment): $f_{\\mathrm{tr}} = 0.001$, $\\mathbf{n} = [1.0, 0.0, 0.0]$, $\\Delta\\boldsymbol{\\sigma} = [-500.0, 0.0, 0.0]$, $\\tau_{\\mathrm{abs}} = 0.0001$, $\\tau_{\\mathrm{rel}} = 0.0001$, $\\tau_{\\mathrm{dir}} = 0.0001$.\n\nFor each case, output the robust classification as integers in the order $[0, 1, 2]$ corresponding to unloading, loading, neutral, respectively. Then append a final integer equal to the number of false activations by the naive test relative to the robust classification across all cases.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[r1,r2,r3,r4,r5,count]\"), where $r_i$ is the robust classification for case $i$. The output must be exactly one line, with no additional text.", "solution": "The problem requires the design and implementation of a robust numerical algorithm to classify the state of an elastoplastic material as loading, unloading, or neutral, based on a trial stress state. This is a fundamental task in the computational solution of boundary value problems in geomechanics and solid mechanics. Before presenting the specific calculations, we shall establish the underlying theoretical principles.\n\nIn small-strain elastoplasticity, the total strain rate $\\dot{\\boldsymbol{\\epsilon}}$ is additively decomposed into an elastic part $\\dot{\\boldsymbol{\\epsilon}}^e$ and a plastic part $\\dot{\\boldsymbol{\\epsilon}}^p$:\n$$\n\\dot{\\boldsymbol{\\epsilon}} = \\dot{\\boldsymbol{\\epsilon}}^e + \\dot{\\boldsymbol{\\epsilon}}^p\n$$\nThe stress rate $\\dot{\\boldsymbol{\\sigma}}$ is related to the elastic strain rate by the generalized Hooke's law, $\\dot{\\boldsymbol{\\sigma}} = \\mathbf{C} : \\dot{\\boldsymbol{\\epsilon}}^e$, where $\\mathbf{C}$ is the fourth-order elasticity tensor. The material's elastic domain is defined by a yield function $f(\\boldsymbol{\\sigma}, \\boldsymbol{\\alpha}) \\le 0$, where $\\boldsymbol{\\sigma}$ is the Cauchy stress tensor and $\\boldsymbol{\\alpha}$ represents a set of internal state variables (e.g., hardening parameters). For the specified case of perfect plasticity, $\\boldsymbol{\\alpha}$ is constant. A state is elastic if $f  0$ and plastic if $f=0$. States where $f > 0$ are inadmissible.\n\nThe evolution of plastic strain is governed by a flow rule, typically of the form $\\dot{\\boldsymbol{\\epsilon}}^p = \\dot{\\lambda} \\mathbf{r}(\\boldsymbol{\\sigma}, \\boldsymbol{\\alpha})$, where $\\dot{\\lambda}$ is the non-negative plastic multiplier rate and $\\mathbf{r}$ is the plastic flow direction, often derived from the yield function (an associative flow rule assumes $\\mathbf{r} = \\partial f / \\partial \\boldsymbol{\\sigma}$).\n\nThe core of rate-independent plasticity is captured by the Karush-Kuhn-Tucker (KKT) complementarity conditions:\n$$\nf \\le 0, \\quad \\dot{\\lambda} \\ge 0, \\quad \\dot{\\lambda} f = 0\n$$\nThese conditions state that plastic flow ($\\dot{\\lambda} > 0$) can only occur when the stress state is on the yield surface ($f=0$). If the stress state is strictly within the elastic domain ($f  0$), no plastic flow occurs ($\\dot{\\lambda} = 0$).\n\nIn a computational, time-stepping analysis (e.g., using the Finite Element Method), we evaluate these conditions incrementally. At the beginning of a time step, we assume the entire strain increment $\\Delta\\boldsymbol{\\epsilon}$ is elastic. This gives a \"trial\" stress state $\\boldsymbol{\\sigma}_{\\mathrm{tr}} = \\boldsymbol{\\sigma}_{\\mathrm{prev}} + \\mathbf{C} : \\Delta\\boldsymbol{\\epsilon}$. We then compute the trial yield residual, $f_{\\mathrm{tr}} = f(\\boldsymbol{\\sigma}_{\\mathrm{tr}})$.\n- If $f_{\\mathrm{tr}} \\le 0$, the assumption was correct, the step is elastic, and the final stress is $\\boldsymbol{\\sigma}_{\\mathrm{tr}}$.\n- If $f_{\\mathrm{tr}} > 0$, the trial state is inadmissible. The material has yielded, and a portion of the strain increment must be plastic. A return-mapping algorithm must be used to find the final stress state on the yield surface.\n\nThe critical decision is to distinguish between genuine plastic loading and numerical artifacts. A simple check $f_{\\mathrm{tr}} > \\tau$ (where $\\tau$ is a small tolerance) can be unreliable. For instance, in stiff materials, a large elastic stress increment $\\Delta\\boldsymbol{\\sigma} = \\mathbf{C} : \\Delta\\boldsymbol{\\epsilon}$ may cause a state that should be unloading from a near-yield condition to exhibit a small positive $f_{\\mathrm{tr}}$ due to the finite step size and floating-point arithmetic. This motivates a more robust check based on the direction of the stress increment relative to the yield surface.\n\nDuring plastic flow, the state must remain on the yield surface, which implies the consistency condition $\\dot{f}=0$. By the chain rule:\n$$\n\\dot{f} = \\frac{\\partial f}{\\partial \\boldsymbol{\\sigma}} : \\dot{\\boldsymbol{\\sigma}} + \\frac{\\partial f}{\\partial \\boldsymbol{\\alpha}} \\cdot \\dot{\\boldsymbol{\\alpha}} = 0\n$$\nFor perfect plasticity, the second term vanishes. Defining the gradient $\\mathbf{n} = \\partial f / \\partial \\boldsymbol{\\sigma}$ (the normal to the yield surface), the condition for continued plastic loading becomes $\\mathbf{n} : \\dot{\\boldsymbol{\\sigma}} = 0$. In a discrete setting, we approximate this by checking the sign of the consistency indicator $d_f = \\mathbf{n}^{\\mathsf{T}} \\Delta\\boldsymbol{\\sigma}_{\\mathrm{tr}}$, where $\\Delta\\boldsymbol{\\sigma}_{\\mathrm{tr}}$ is the trial stress increment.\n- $d_f > 0$: The trial stress increment points \"outward\" from the yield surface, indicating loading.\n- $d_f  0$: The trial stress increment points \"inward,\" indicating unloading.\n- $d_f = 0$: The increment is tangential, indicating neutral loading.\n\nThe proposed robust classification combines the check on the yield residual $f_{\\mathrm{tr}}$ with the directional check $d_f$. Crucially, it uses scaled tolerances that adapt to the magnitude of the stress increment and the sensitivity of the yield function.\nThe yield-residual tolerance is $T_f = \\tau_{\\mathrm{abs}} + \\tau_{\\mathrm{rel}} \\lVert \\mathbf{n} \\rVert_2 \\lVert \\Delta\\boldsymbol{\\sigma} \\rVert_2$. The absolute part $\\tau_{\\mathrm{abs}}$ sets a minimum threshold, while the relative part scales with the product of the norms of the gradient and the stress increment, making the tolerance larger for larger increments, which is physically justified.\nThe consistency tolerance is $T_c = \\tau_{\\mathrm{dir}} \\lVert \\mathbf{n} \\rVert_2 \\lVert \\Delta\\boldsymbol{\\sigma} \\rVert_2$. This establishes a \"dead zone\" around neutral loading to prevent spurious switching between loading and unloading due to numerical noise.\n\nThe classifications are defined as:\n- **Loading (1)**: $f_{\\mathrm{tr}} > T_f$ and $d_f \\ge T_c$. The state is significantly outside the yield surface and moving further away.\n- **Unloading (0)**: $f_{\\mathrm{tr}} \\le T_f$ and $d_f \\le -T_c$. The state is inside or close to the yield surface and moving inward.\n- **Neutral (2)**: Neither of the above. This includes states near the boundary where the direction is not clearly loading or unloading.\n\nThe naive classification is simply:\n- **Loading**: $f_{\\mathrm{tr}} > \\tau_{\\mathrm{abs}}$\n- **Unloading**: $f_{\\mathrm{tr}} \\le \\tau_{\\mathrm{abs}}$\n\nWe now apply these rules to the given test cases. All stress-like quantities ($f_{\\mathrm{tr}}$, $\\Delta\\boldsymbol{\\sigma}$, $\\tau_{\\mathrm{abs}}$, $d_f$, $T_f$, $T_c$) are in units of MPa.\n\n**Case 1:**\n- Given: $f_{\\mathrm{tr}} = -5.0$, $\\mathbf{n} = [1.0, 0.0, 0.0]$, $\\Delta\\boldsymbol{\\sigma} = [-2.0, 0.0, 0.0]$, $\\tau_{\\mathrm{abs}} = 0.001$, $\\tau_{\\mathrm{rel}} = 0.01$, $\\tau_{\\mathrm{dir}} = 0.005$.\n- Calculations:\n  - $\\lVert \\mathbf{n} \\rVert_2 = 1.0$, $\\lVert \\Delta\\boldsymbol{\\sigma} \\rVert_2 = 2.0$.\n  - $d_f = \\mathbf{n}^{\\mathsf{T}} \\Delta\\boldsymbol{\\sigma} = 1.0 \\times (-2.0) = -2.0$.\n  - $T_f = 0.001 + 0.01 \\times 1.0 \\times 2.0 = 0.021$.\n  - $T_c = 0.005 \\times 1.0 \\times 2.0 = 0.01$.\n- Robust: $f_{\\mathrm{tr}} = -5.0 \\le T_f = 0.021$ and $d_f = -2.0 \\le -T_c = -0.01$. This satisfies the unloading condition. Result: **Unloading (0)**.\n- Naive: $f_{\\mathrm{tr}} = -5.0 \\le \\tau_{\\mathrm{abs}} = 0.001$. Result: Unloading.\n- False Activation: No.\n\n**Case 2:**\n- Given: $f_{\\mathrm{tr}} = 0.0005$, $\\mathbf{n} = [0.6, 0.8, 0.0]$, $\\Delta\\boldsymbol{\\sigma} = [-0.002, 0.0, 0.0]$, $\\tau_{\\mathrm{abs}} = 0.001$, $\\tau_{\\mathrm{rel}} = 0.1$, $\\tau_{\\mathrm{dir}} = 0.05$.\n- Calculations:\n  - $\\lVert \\mathbf{n} \\rVert_2 = \\sqrt{0.6^2 + 0.8^2} = 1.0$, $\\lVert \\Delta\\boldsymbol{\\sigma} \\rVert_2 = 0.002$.\n  - $d_f = 0.6 \\times (-0.002) = -0.0012$.\n  - $T_f = 0.001 + 0.1 \\times 1.0 \\times 0.002 = 0.0012$.\n  - $T_c = 0.05 \\times 1.0 \\times 0.002 = 0.0001$.\n- Robust: $f_{\\mathrm{tr}} = 0.0005 \\le T_f = 0.0012$ and $d_f = -0.0012 \\le -T_c = -0.0001$. This satisfies the unloading condition. Result: **Unloading (0)**.\n- Naive: $f_{\\mathrm{tr}} = 0.0005 \\le \\tau_{\\mathrm{abs}} = 0.001$. Result: Unloading.\n- False Activation: No.\n\n**Case 3:**\n- Given: $f_{\\mathrm{tr}} = 0.2$, $\\mathbf{n} = [1.0, 0.0, 0.0]$, $\\Delta\\boldsymbol{\\sigma} = [0.5, 0.0, 0.0]$, $\\tau_{\\mathrm{abs}} = 0.001$, $\\tau_{\\mathrm{rel}} = 0.01$, $\\tau_{\\mathrm{dir}} = 0.001$.\n- Calculations:\n  - $\\lVert \\mathbf{n} \\rVert_2 = 1.0$, $\\lVert \\Delta\\boldsymbol{\\sigma} \\rVert_2 = 0.5$.\n  - $d_f = 1.0 \\times 0.5 = 0.5$.\n  - $T_f = 0.001 + 0.01 \\times 1.0 \\times 0.5 = 0.006$.\n  - $T_c = 0.001 \\times 1.0 \\times 0.5 = 0.0005$.\n- Robust: $f_{\\mathrm{tr}} = 0.2 > T_f = 0.006$ and $d_f = 0.5 \\ge T_c = 0.0005$. This satisfies the loading condition. Result: **Loading (1)**.\n- Naive: $f_{\\mathrm{tr}} = 0.2 > \\tau_{\\mathrm{abs}} = 0.001$. Result: Loading.\n- False Activation: No.\n\n**Case 4:**\n- Given: $f_{\\mathrm{tr}} = 0.0007$, $\\mathbf{n} = [1.0, 0.0, 0.0]$, $\\Delta\\boldsymbol{\\sigma} = [0.002, 0.0, 0.0]$, $\\tau_{\\mathrm{abs}} = 0.001$, $\\tau_{\\mathrm{rel}} = 0.1$, $\\tau_{\\mathrm{dir}} = 0.1$.\n- Calculations:\n  - $\\lVert \\mathbf{n} \\rVert_2 = 1.0$, $\\lVert \\Delta\\boldsymbol{\\sigma} \\rVert_2 = 0.002$.\n  - $d_f = 1.0 \\times 0.002 = 0.002$.\n  - $T_f = 0.001 + 0.1 \\times 1.0 \\times 0.002 = 0.0012$.\n  - $T_c = 0.1 \\times 1.0 \\times 0.002 = 0.0002$.\n- Robust:\n  - Loading condition check: $f_{\\mathrm{tr}} = 0.0007 > T_f = 0.0012$ is false.\n  - Unloading condition check: $d_f = 0.002 \\le -T_c = -0.0002$ is false.\n  - Since neither condition is met, the state is neutral. Result: **Neutral (2)**.\n- Naive: $f_{\\mathrm{tr}} = 0.0007 \\le \\tau_{\\mathrm{abs}} = 0.001$. Result: Unloading.\n- False Activation: No.\n\n**Case 5:**\n- Given: $f_{\\mathrm{tr}} = 0.001$, $\\mathbf{n} = [1.0, 0.0, 0.0]$, $\\Delta\\boldsymbol{\\sigma} = [-500.0, 0.0, 0.0]$, $\\tau_{\\mathrm{abs}} = 0.0001$, $\\tau_{\\mathrm{rel}} = 0.0001$, $\\tau_{\\mathrm{dir}} = 0.0001$.\n- Calculations:\n  - $\\lVert \\mathbf{n} \\rVert_2 = 1.0$, $\\lVert \\Delta\\boldsymbol{\\sigma} \\rVert_2 = 500.0$.\n  - $d_f = 1.0 \\times (-500.0) = -500.0$.\n  - $T_f = 0.0001 + 0.0001 \\times 1.0 \\times 500.0 = 0.0001 + 0.05 = 0.0501$.\n  - $T_c = 0.0001 \\times 1.0 \\times 500.0 = 0.05$.\n- Robust: $f_{\\mathrm{tr}} = 0.001 \\le T_f = 0.0501$ and $d_f = -500.0 \\le -T_c = -0.05$. This satisfies the unloading condition. Result: **Unloading (0)**.\n- Naive: $f_{\\mathrm{tr}} = 0.001 > \\tau_{\\mathrm{abs}} = 0.0001$. Result: Loading.\n- False Activation: **Yes**. The naive test declares loading, but the robust test declares unloading. This is the exact scenario the robust method is designed to prevent.\n\n**Summary:**\nThe robust classification results for cases $1$ through $5$ are: Unloading (0), Unloading (0), Loading (1), Neutral (2), and Unloading (0).\nThere is one case of false activation (Case 5).\nThe final output vector is therefore $[0, 0, 1, 2, 0, 1]$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Applies robust and naive loading/unloading classification rules to a suite of test cases\n    in computational plasticity and reports the results including false activations.\n    \"\"\"\n    # Test cases are given as a tuple (f_tr, n, delta_sigma, tau_abs, tau_rel, tau_dir)\n    # where n and delta_sigma are provided as lists and will be converted to numpy arrays.\n    test_cases = [\n        # Case 1 (happy path unloading)\n        (\n            -5.0,\n            [1.0, 0.0, 0.0],\n            [-2.0, 0.0, 0.0],\n            0.001,\n            0.01,\n            0.005\n        ),\n        # Case 2 (near-yield, negative direction)\n        (\n            0.0005,\n            [0.6, 0.8, 0.0],\n            [-0.002, 0.0, 0.0],\n            0.001,\n            0.1,\n            0.05\n        ),\n        # Case 3 (clear loading)\n        (\n            0.2,\n            [1.0, 0.0, 0.0],\n            [0.5, 0.0, 0.0],\n            0.001,\n            0.01,\n            0.001\n        ),\n        # Case 4 (boundary neutral)\n        (\n            0.0007,\n            [1.0, 0.0, 0.0],\n            [0.002, 0.0, 0.0],\n            0.001,\n            0.1,\n            0.1\n        ),\n        # Case 5 (stiff soil, large increment)\n        (\n            0.001,\n            [1.0, 0.0, 0.0],\n            [-500.0, 0.0, 0.0],\n            0.0001,\n            0.0001,\n            0.0001\n        ),\n    ]\n\n    results = []\n    false_activations = 0\n\n    # Classification to integer mapping\n    # 0: unloading, 1: loading, 2: neutral\n    UNLOADING = 0\n    LOADING = 1\n    NEUTRAL = 2\n\n    for case in test_cases:\n        f_tr, n_list, delta_sigma_list, tau_abs, tau_rel, tau_dir = case\n        \n        n = np.array(n_list)\n        delta_sigma = np.array(delta_sigma_list)\n\n        # Naive classification\n        is_naive_loading = f_tr > tau_abs\n        \n        # Robust classification calculations\n        norm_n = np.linalg.norm(n)\n        norm_delta_sigma = np.linalg.norm(delta_sigma)\n        \n        d_f = np.dot(n, delta_sigma)\n        \n        T_f = tau_abs + tau_rel * norm_n * norm_delta_sigma\n        T_c = tau_dir * norm_n * norm_delta_sigma\n        \n        # Apply robust classification rules\n        robust_class = NEUTRAL # Default to neutral\n        \n        is_robust_loading = (f_tr > T_f) and (d_f >= T_c)\n        is_robust_unloading = (f_tr = T_f) and (d_f = -T_c)\n        \n        if is_robust_loading:\n            robust_class = LOADING\n        elif is_robust_unloading:\n            robust_class = UNLOADING\n        \n        results.append(robust_class)\n\n        # Check for false activation\n        # A false activation occurs when the naive test declares loading, but the robust test declares unloading.\n        if is_naive_loading and (robust_class == UNLOADING):\n            false_activations += 1\n\n    # Append the total count of false activations to the results list\n    results.append(false_activations)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3539952"}, {"introduction": "The Kuhn-Tucker relations are more than just a binary switch for plasticity; they provide a rich framework for analyzing complex material behavior at the yield limit. This practice [@problem_id:3539963] shifts the focus from implementation details to conceptual interpretation by exploring the subtle case of 'neutral unloading'. You will derive the conditions under which a material point at yield can deform elastically and then construct numerical stress paths to verify this behavior, building a deeper intuition for the interplay between stress rates, strain rates, and the yield surface geometry.", "problem": "Consider an isotropic, rate-independent, pressure-sensitive plasticity model used in computational geomechanics with the Drucker–Prager yield function $f(\\boldsymbol{\\sigma},\\kappa) = q + \\alpha p - \\kappa$, where $p = \\tfrac{1}{3}\\,\\mathrm{tr}(\\boldsymbol{\\sigma})$ is the mean stress, $q = \\sqrt{\\tfrac{3}{2}}\\,\\|\\mathbf{s}\\|$ is the second deviatoric stress invariant with $\\mathbf{s} = \\boldsymbol{\\sigma} - p\\mathbf{I}$ the deviatoric stress tensor, $\\alpha > 0$ is a friction parameter, and $\\kappa$ is an isotropic hardening variable. The evolution of $\\kappa$ is assumed to be $\\dot{\\kappa} = H \\dot{\\lambda}$, where $\\dot{\\lambda} \\ge 0$ is the plastic multiplier rate and $H \\ge 0$ is a hardening modulus. The plasticity model satisfies the Karush–Kuhn–Tucker (KKT) conditions: $f \\le 0$, $\\dot{\\lambda} \\ge 0$, and $\\dot{\\lambda} f = 0$, together with the consistency condition for plastic loading: if $\\dot{\\lambda} > 0$ then $f = 0$ and $\\dot{f} = 0$.\n\nAssume small strains and isotropic linear elasticity with bulk modulus $K > 0$ and shear modulus $G > 0$, so that the elastic stress rate is related to the strain rate by $\\dot{\\boldsymbol{\\sigma}} = 2G\\,\\dot{\\boldsymbol{e}} + \\lambda_{\\mathrm{L}}\\,\\mathrm{tr}(\\dot{\\boldsymbol{e}})\\,\\mathbf{I}$, where $\\dot{\\boldsymbol{e}}$ is the strain-rate tensor, $\\lambda_{\\mathrm{L}}$ is the first Lamé parameter, and the volumetric strain rate is $\\dot{\\epsilon}_{v} = \\mathrm{tr}(\\dot{\\boldsymbol{e}})$. Under isotropy, the invariant rates satisfy $\\dot{p} = K\\,\\dot{\\epsilon}_{v}$ and, if the deviatoric strain rate is aligned with the deviatoric stress direction, $\\dot{q} = 2G\\,\\dot{\\gamma}$, where $\\dot{\\gamma} = \\sqrt{\\tfrac{2}{3}}\\|\\dot{\\boldsymbol{e}}_{\\mathrm{dev}}\\|$ is the equivalent shear strain rate and $\\dot{\\boldsymbol{e}}_{\\mathrm{dev}}$ is the deviatoric part of $\\dot{\\boldsymbol{e}}$.\n\nYour tasks:\n\n1. Derive, from first principles using the above definitions and the KKT relations, the conditions under which unloading at yield occurs with no plastic strain increment (neutral unloading). Specifically, starting from $f = q + \\alpha p - \\kappa$ and $\\dot{\\kappa} = H\\dot{\\lambda}$, show that at a point where $f = 0$, if $\\dot{\\lambda} = 0$ then the requirement for neutral unloading is $\\dot{f}  0$. Express $\\dot{f}$ in terms of the elastic invariant rates $\\dot{p}$ and $\\dot{q}$, and then in terms of the strain-rate invariants $\\dot{\\epsilon}_{v}$ and $\\dot{\\gamma}$ via $K$ and $G$. State the inequality that must be satisfied by $(\\dot{\\epsilon}_{v},\\dot{\\gamma})$ for neutral unloading at yield.\n\n2. Prove that, under isotropic linear elasticity, any chosen pair $(\\dot{p},\\dot{q})$ consistent with the above invariant relations can be realized by suitable choices of $(\\dot{\\epsilon}_{v},\\dot{\\gamma})$ and give the constructive mappings $\\dot{p} = K \\dot{\\epsilon}_{v}$ and $\\dot{q} = 2G \\dot{\\gamma}$. Explain why this mapping is sufficient to construct stress paths that satisfy the neutral unloading condition without invoking plastic flow.\n\n3. Construct numerical stress paths to realize the neutral unloading scenario and to test edge cases. For each path, take constant rates $(\\dot{\\epsilon}_{v},\\dot{\\gamma})$ over a time step $\\Delta t > 0$ and $N \\in \\mathbb{N}$ steps. Starting from an initial state at yield defined by $(p_{0},q_{0},\\kappa)$ with $q_{0} + \\alpha p_{0} - \\kappa = 0$, evolve $(p,q)$ elastically according to\n$$\np_{n+1} = p_{n} + K\\,\\dot{\\epsilon}_{v}\\,\\Delta t,\\qquad\nq_{n+1} = q_{n} + 2G\\,\\dot{\\gamma}\\,\\Delta t,\n$$\nwhile keeping $\\dot{\\lambda} = 0$ and thus $\\kappa$ constant. For each path, verify the KKT unloading conditions: $f_{0} = 0$, $\\dot{\\lambda} = 0$, and $\\dot{f}  0$ at the initial step, and check that $f_{n} \\le 0$ for all steps $n = 1,\\dots,N$.\n\nImplement a complete program that computes the above for the following test suite of parameter values (all stresses in $\\mathrm{MPa}$, moduli in $\\mathrm{MPa}$, strain rates in $\\mathrm{s}^{-1}$, time in $\\mathrm{s}$):\n\n- Test $1$ (neutral unloading via mean stress decrease):\n  - $\\alpha = 0.2$, $K = 15000$, $G = 10000$, $\\kappa = 60$, $p_{0} = 100$, $q_{0} = 60 - 0.2 \\cdot 100 = 40$, $\\Delta t = 0.1$, $N = 10$, $\\dot{\\epsilon}_{v} = -5 \\times 10^{-6}$, $\\dot{\\gamma} = 0$.\n- Test $2$ (boundary case with $\\dot{f} = 0$):\n  - $\\alpha = 0.3$, $K = 12000$, $G = 8000$, $\\kappa = 50$, $p_{0} = 100$, $q_{0} = 50 - 0.3 \\cdot 100 = 20$, $\\Delta t = 0.1$, $N = 10$, $\\dot{\\epsilon}_{v} = -1 \\times 10^{-6}$, $\\dot{\\gamma} = \\left(-\\frac{\\alpha K}{2G}\\right)\\dot{\\epsilon}_{v}$.\n- Test $3$ (loading, violates unloading with $\\dot{f} > 0$):\n  - $\\alpha = 0.2$, $K = 15000$, $G = 10000$, $\\kappa = 60$, $p_{0} = 100$, $q_{0} = 40$, $\\Delta t = 0.1$, $N = 10$, $\\dot{\\epsilon}_{v} = 1 \\times 10^{-6}$, $\\dot{\\gamma} = 1 \\times 10^{-6}$.\n- Test $4$ (neutral unloading via simultaneous $p$ and $q$ decrease):\n  - $\\alpha = 0.4$, $K = 20000$, $G = 12000$, $\\kappa = 100$, $p_{0} = 150$, $q_{0} = 100 - 0.4 \\cdot 150 = 40$, $\\Delta t = 0.1$, $N = 10$, $\\dot{\\epsilon}_{v} = -2 \\times 10^{-6}$, $\\dot{\\gamma} = -1 \\times 10^{-6}$.\n- Test $5$ (not at yield initially, $f_{0}  0$):\n  - $\\alpha = 0.25$, $K = 18000$, $G = 9000$, $\\kappa = 75$, $p_{0} = 100$, $q_{0} = 30$ (so $f_{0} = 30 + 0.25 \\cdot 100 - 75 = -20$), $\\Delta t = 0.1$, $N = 10$, $\\dot{\\epsilon}_{v} = -1 \\times 10^{-6}$, $\\dot{\\gamma} = -1 \\times 10^{-6}$.\n\nYour program must, for each test, return a boolean indicating whether the neutral unloading at yield conditions are satisfied, defined precisely as:\n- $|f_{0}| \\le \\varepsilon$ with tolerance $\\varepsilon = 10^{-9}$,\n- $\\dot{\\lambda} = 0$ by construction,\n- $\\dot{f} = \\dot{q} + \\alpha \\dot{p} = 2G\\,\\dot{\\gamma} + \\alpha K\\,\\dot{\\epsilon}_{v}  0$,\n- and $f_{n} \\le \\varepsilon$ for all steps $n = 1,\\dots,N$.\n\nFinal output format: Your program should produce a single line containing the results as a comma-separated list enclosed in square brackets (for example, $\\left[\\mathrm{result1},\\mathrm{result2},\\mathrm{result3},\\mathrm{result4},\\mathrm{result5}\\right]$), where each $\\mathrm{result}$ is either $\\mathrm{True}$ or $\\mathrm{False}$.", "solution": "The problem posed is a well-defined exercise in computational plasticity, specifically exploring the loading/unloading conditions for a Drucker–Prager yield criterion within the framework of isotropic elastoplasticity. The given definitions, principles, and numerical tasks are scientifically sound, self-contained, and consistent with established theories in continuum mechanics and computational geomechanics. Therefore, the problem is deemed valid and a full solution is provided below.\n\nThe solution is divided into three parts, corresponding to the tasks outlined in the problem statement.\n\n### Part 1: Derivation of the Neutral Unloading Condition\n\nThe state of the material is described by the Drucker–Prager yield function, $f$, defined as:\n$$\nf(\\boldsymbol{\\sigma}, \\kappa) = q + \\alpha p - \\kappa\n$$\nHere, $p$ is the mean stress, $q$ is the von Mises equivalent stress, $\\alpha > 0$ is a material parameter related to internal friction, and $\\kappa$ is an isotropic hardening variable. The material is in a plastic state if $f=0$ and in an elastic state if $f0$. The condition $f>0$ is inadmissible.\n\nThe Karush–Kuhn–Tucker (KKT) conditions govern the plastic flow and are given as:\n$$\nf \\le 0, \\quad \\dot{\\lambda} \\ge 0, \\quad \\dot{\\lambda} f = 0\n$$\nwhere $\\dot{\\lambda}$ is the rate of the plastic multiplier. The condition $\\dot{\\lambda} f = 0$ is the complementary slackness condition, which implies that plastic flow ($\\dot{\\lambda} > 0$) can only occur when the material is at yield ($f=0$).\n\n\"Neutral unloading at yield\" signifies a process starting from a state on the yield surface ($f=0$) where the material deforms elastically, meaning there is no increment of plastic strain. This corresponds to the case where the plastic multiplier rate is zero, $\\dot{\\lambda}=0$.\n\nThe evolution of the hardening variable is given by $\\dot{\\kappa} = H \\dot{\\lambda}$, where $H \\ge 0$ is the hardening modulus. If $\\dot{\\lambda}=0$, it directly follows that $\\dot{\\kappa}=0$. This means that during elastic unloading, the yield surface remains fixed in stress space.\n\nTo determine the condition for such an unloading path, we evaluate the rate of change of the yield function, $\\dot{f}$. Using the chain rule:\n$$\n\\dot{f} = \\dot{q} + \\alpha \\dot{p} - \\dot{\\kappa}\n$$\nSince we are considering a purely elastic response, we set $\\dot{\\lambda}=0$, which implies $\\dot{\\kappa}=0$. The rate of the yield function, often called the elastic trial rate, becomes:\n$$\n\\dot{f} = \\dot{q} + \\alpha \\dot{p}\n$$\nFor the state to move from the yield surface ($f=0$) into the elastic domain ($f0$), the rate of change of $f$ must be negative. Thus, the condition for neutral unloading is:\n$$\n\\dot{f}  0 \\implies \\dot{q} + \\alpha \\dot{p}  0\n$$\nThe case $\\dot{f}=0$ is termed neutral loading, where the stress state evolves along the yield surface without inducing plastic flow. The problem requires a strict inequality for unloading.\n\nNext, we express this condition in terms of strain-rate invariants. The problem states that for isotropic linear elasticity, the rates of the stress invariants are related to the rates of the strain invariants by:\n$$\n\\dot{p} = K \\dot{\\epsilon}_v\n$$\n$$\n\\dot{q} = 2G \\dot{\\gamma}\n$$\nwhere $K$ is the bulk modulus, $G$ is the shear modulus, $\\dot{\\epsilon}_v = \\mathrm{tr}(\\dot{\\boldsymbol{e}})$ is the volumetric strain rate, and $\\dot{\\gamma} = \\sqrt{\\frac{2}{3}} \\|\\dot{\\boldsymbol{e}}_{\\mathrm{dev}}\\|$ is the equivalent shear strain rate.\n\nSubstituting these elastic relationships into the inequality for $\\dot{f}$:\n$$\n(2G \\dot{\\gamma}) + \\alpha (K \\dot{\\epsilon}_v)  0\n$$\nThis is the final inequality that the pair of strain-rate invariants $(\\dot{\\epsilon}_v, \\dot{\\gamma})$ must satisfy for neutral unloading to occur from a state at yield.\n\n### Part 2: Sufficiency of the Strain-Rate to Stress-Rate Mapping\n\nThis part requires demonstrating that any desired elastic path for $(\\dot{p}, \\dot{q})$ that satisfies the unloading condition can be achieved by an appropriate choice of strain rates $(\\dot{\\epsilon}_v, \\dot{\\gamma})$.\n\nThe condition for neutral unloading, $\\dot{q} + \\alpha \\dot{p}  0$, defines a half-plane in the $(\\dot{p}, \\dot{q})$ stress-rate space. Any stress-rate vector $(\\dot{p}, \\dot{q})$ that originates from a point on the yield line $q + \\alpha p - \\kappa = 0$ and points into the elastic region $q + \\alpha p - \\kappa  0$ will satisfy this condition.\n\nThe problem provides the constitutive relations for isotropic elasticity in terms of invariants:\n$$\n\\dot{p} = K \\dot{\\epsilon}_v \\quad \\text{and} \\quad \\dot{q} = 2G \\dot{\\gamma}\n$$\nGiven that the material moduli $K$ and $G$ are strictly positive constants ($K>0, G>0$), these equations establish an invertible linear transformation between the strain-rate space $(\\dot{\\epsilon}_v, \\dot{\\gamma})$ and the elastic stress-rate space $(\\dot{p}, \\dot{q})$.\n\nThe inverse mapping is:\n$$\n\\dot{\\epsilon}_v = \\frac{1}{K} \\dot{p} \\quad \\text{and} \\quad \\dot{\\gamma} = \\frac{1}{2G} \\dot{q}\n$$\nThis demonstrates that for any desired elastic stress-rate vector $(\\dot{p}_{\\text{target}}, \\dot{q}_{\\text{target}})$, we can uniquely determine the strain-rate vector $(\\dot{\\epsilon}_v, \\dot{\\gamma})$ required to produce it. Since we can choose any real-valued pair $(\\dot{p}_{\\text{target}}, \\dot{q}_{\\text{target}})$ that satisfies the unloading condition $\\dot{q}_{\\text{target}} + \\alpha \\dot{p}_{\\text{target}}  0$, we can always construct a corresponding strain-rate history $(\\dot{\\epsilon}_v(t), \\dot{\\gamma}(t))$ that generates this stress path elastically.\n\nTherefore, the mapping is sufficient to construct any stress path satisfying the neutral unloading condition without invoking plastic flow ($\\dot{\\lambda}=0$). The ability to control $\\dot{\\epsilon}_v$ and $\\dot{\\gamma}$ independently provides full control over the elastic evolution of $p$ and $q$.\n\n### Part 3: Numerical Implementation and Verification\n\nThe final task is to implement a numerical procedure to simulate stress paths for several test cases and verify if they satisfy the conditions for neutral unloading at yield. A constant strain-rate vector $(\\dot{\\epsilon}_v, \\dot{\\gamma})$ is applied over a duration of $N \\Delta t$.\n\nThe state variables $(p, q)$ are evolved using a forward Euler integration scheme, which is exact for constant rates:\n$$\np_{n+1} = p_{n} + \\dot{p} \\Delta t = p_{n} + K \\dot{\\epsilon}_v \\Delta t\n$$\n$$\nq_{n+1} = q_{n} + \\dot{q} \\Delta t = q_{n} + 2G \\dot{\\gamma} \\Delta t\n$$\nSince the process is assumed elastic, $\\dot{\\lambda}=0$, and the hardening parameter $\\kappa$ remains constant throughout the simulation, $\\kappa_n = \\kappa_0$.\n\nFor each test case, the verification of \"neutral unloading at yield\" requires checking four distinct conditions:\n1.  **Initial Yield Condition:** The initial state $(p_0, q_0)$ must lie on the yield surface. This is checked by evaluating $f_0 = q_0 + \\alpha p_0 - \\kappa_0$ and verifying that $|f_0| \\le \\varepsilon$ for a small tolerance $\\varepsilon=10^{-9}$.\n2.  **No Plastic Flow:** The plastic multiplier rate is zero by construction ($\\dot{\\lambda}=0$). This is an assumption of the simulation path.\n3.  **Unloading Rate Condition:** The elastic trial stress rate must point into the elastic domain. This is checked by verifying that $\\dot{f} = 2G\\dot{\\gamma} + \\alpha K\\dot{\\epsilon}_v  0$.\n4.  **Path Admissibility:** The entire stress path must remain within or on the yield surface. This is checked by ensuring that at every subsequent step $n=1, \\dots, N$, the yield function $f_n = q_n + \\alpha p_n - \\kappa_0$ satisfies $f_n \\le \\varepsilon$.\n\nA test case is considered to satisfy the conditions only if all four criteria are met. The Python program in the `answer` section implements this logic for the specified test suite.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the computational geomechanics problem by verifying neutral unloading\n    conditions for a set of test cases.\n    \"\"\"\n\n    # Define the tolerance for floating point comparisons\n    TOLERANCE = 1e-9\n\n    def check_unloading_conditions(alpha, K, G, kappa, p0, q0, dt, N, eps_v_dot, gamma_dot):\n        \"\"\"\n        Checks if the neutral unloading at yield conditions are satisfied for a given test case.\n\n        The conditions are:\n        1. The initial state is on the yield surface: |f_0| = tolerance.\n        2. The plastic multiplier rate is zero by construction (lambda_dot = 0).\n        3. The elastic trial stress rate indicates unloading: f_dot  0.\n        4. The stress path remains within the elastic domain: f_n = tolerance for all n.\n\n        Args:\n            alpha (float): Friction parameter.\n            K (float): Bulk modulus.\n            G (float): Shear modulus.\n            kappa (float): Isotropic hardening variable.\n            p0 (float): Initial mean stress.\n            q0 (float): Initial deviatoric stress.\n            dt (float): Time step.\n            N (int): Number of steps.\n            eps_v_dot (float): Volumetric strain rate.\n            gamma_dot (float): Equivalent shear strain rate.\n\n        Returns:\n            bool: True if all conditions are met, False otherwise.\n        \"\"\"\n        # 1. Check initial yield condition\n        f0 = q0 + alpha * p0 - kappa\n        if not (abs(f0) = TOLERANCE):\n            return False\n\n        # 2. lambda_dot = 0 is assumed by construction for the elastic path.\n\n        # 3. Check unloading rate condition\n        f_dot = 2 * G * gamma_dot + alpha * K * eps_v_dot\n        if not (f_dot  0):\n            return False\n\n        # 4. Check if the path remains admissible (elastic)\n        p_current = p0\n        q_current = q0\n        \n        p_dot = K * eps_v_dot\n        q_dot = 2 * G * gamma_dot\n\n        for _ in range(N):\n            p_current += p_dot * dt\n            q_current += q_dot * dt\n            \n            f_current = q_current + alpha * p_current - kappa\n            \n            # The state must remain on or inside the yield surface.\n            # q_current must be non-negative by definition.\n            if f_current > TOLERANCE or q_current  0:\n                return False\n        \n        # If all checks pass\n        return True\n\n    # Test cases from the problem statement\n    test_cases = [\n        # Test 1 (neutral unloading via mean stress decrease)\n        {\n            'alpha': 0.2, 'K': 15000, 'G': 10000, 'kappa': 60,\n            'p0': 100, 'q0': 40, 'dt': 0.1, 'N': 10,\n            'eps_v_dot': -5e-6, 'gamma_dot': 0\n        },\n        # Test 2 (boundary case with f_dot = 0)\n        {\n            'alpha': 0.3, 'K': 12000, 'G': 8000, 'kappa': 50,\n            'p0': 100, 'q0': 20, 'dt': 0.1, 'N': 10,\n            'eps_v_dot': -1e-6, \n            'gamma_dot': (-0.3 * 12000 / (2 * 8000)) * (-1e-6)\n        },\n        # Test 3 (loading, violates unloading with f_dot > 0)\n        {\n            'alpha': 0.2, 'K': 15000, 'G': 10000, 'kappa': 60,\n            'p0': 100, 'q0': 40, 'dt': 0.1, 'N': 10,\n            'eps_v_dot': 1e-6, 'gamma_dot': 1e-6\n        },\n        # Test 4 (neutral unloading via simultaneous p and q decrease)\n        {\n            'alpha': 0.4, 'K': 20000, 'G': 12000, 'kappa': 100,\n            'p0': 150, 'q0': 40, 'dt': 0.1, 'N': 10,\n            'eps_v_dot': -2e-6, 'gamma_dot': -1e-6\n        },\n        # Test 5 (not at yield initially, f_0  0)\n        {\n            'alpha': 0.25, 'K': 18000, 'G': 9000, 'kappa': 75,\n            'p0': 100, 'q0': 30, 'dt': 0.1, 'N': 10,\n            'eps_v_dot': -1e-6, 'gamma_dot': -1e-6\n        }\n    ]\n\n    results = []\n    for params in test_cases:\n        # Unpack parameters and call the checking function\n        result = check_unloading_conditions(\n            params['alpha'], params['K'], params['G'], params['kappa'],\n            params['p0'], params['q0'], params['dt'], params['N'],\n            params['eps_v_dot'], params['gamma_dot']\n        )\n        results.append(result)\n\n    # Format and print the final output as a single-line string\n    print(f\"[{','.join(str(r).capitalize() for r in results)}]\")\n\nsolve()\n```", "id": "3539963"}]}