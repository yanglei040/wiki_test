{"hands_on_practices": [{"introduction": "The heart of any elastoplastic finite element code is the constitutive driver, where the material's rate equations are integrated. For computational robustness and efficiency, implicit integration schemes are standard, which in turn require an iterative local solution. This exercise [@problem_id:3529165] provides direct experience with this core task by having you derive and implement the essential components for a local Newton-Raphson solver: the scalar residual equation and, crucially, the consistent algorithmic tangent. By working with a sophisticated Armstrong-Frederick nonlinear kinematic hardening model, you will master the procedure that ensures quadratic convergence in large-scale simulations involving complex cyclic loading.", "problem": "Consider a single material point undergoing small-strain simple shear under undrained conditions in a soil modeled by von Mises (J2) elastoplasticity with nonlinear kinematic hardening of Armstrong–Frederick type, within a bounding surface framework in which the kinematic hardening saturates through dynamic recovery. The undrained condition implies zero volumetric strain increment, so only the shear response evolves during loading. The objective is to derive, implement, and test the consistent algorithmic tangent for a backward Euler integration of the constitutive equations.\n\nThe fundamental base consists of the following well-tested definitions and laws:\n- Small-strain additivity: $d\\boldsymbol{\\varepsilon} = d\\boldsymbol{\\varepsilon}^{e} + d\\boldsymbol{\\varepsilon}^{p}$.\n- Linear isotropic elasticity for deviatoric response: $\\boldsymbol{s} = 2 G \\boldsymbol{\\varepsilon}^{e}_{\\text{dev}}$, where $G$ is the shear modulus.\n- Von Mises (J2) yield function with kinematic shift: $f = \\sqrt{\\dfrac{3}{2}} \\left\\| \\boldsymbol{s} - \\boldsymbol{\\alpha} \\right\\| - \\sigma_{y}$, where $\\sigma_{y}$ is the current yield stress (taken as constant for this problem), $\\boldsymbol{s}$ is the deviatoric stress tensor, and $\\boldsymbol{\\alpha}$ is the backstress tensor.\n- Associated flow: $d\\boldsymbol{\\varepsilon}^{p}_{\\text{dev}} = d p \\, \\dfrac{\\partial f}{\\partial \\boldsymbol{\\sigma}} = d p \\, \\sqrt{\\dfrac{3}{2}} \\, \\dfrac{\\boldsymbol{s} - \\boldsymbol{\\alpha}}{\\left\\| \\boldsymbol{s} - \\boldsymbol{\\alpha} \\right\\|}$, with plastic multiplier $d p \\ge 0$.\n- Armstrong–Frederick nonlinear kinematic hardening: $d\\boldsymbol{\\alpha} = c \\, d\\boldsymbol{\\varepsilon}^{p}_{\\text{dev}} - \\gamma \\, \\boldsymbol{\\alpha} \\, d p$, with $c$ a kinematic hardening modulus and $\\gamma$ a dynamic recovery parameter controlling saturation (these parameters are constants).\n- Bounding surface interpretation here is through the saturation of $\\boldsymbol{\\alpha}$ under the dynamic recovery term, which bounds the translation of the yield surface.\n\nRestrict the response to simple shear with only the $\\boldsymbol{12}$ component nonzero, and assume all quantities remain colinear in this one-dimensional deviatoric subspace. Let the engineering shear strain be $\\gamma$ and the shear stress be $\\tau$, so $\\tau = G \\gamma^{e}$ with $\\gamma^{e} = \\gamma - \\gamma^{p}$. Let the backstress component be $a = \\alpha_{12}$. The J2 equivalent norm in simple shear gives $\\sqrt{\\dfrac{3}{2}} \\left\\| \\boldsymbol{s} - \\boldsymbol{\\alpha} \\right\\| = \\sqrt{3} \\, \\left| \\tau - a \\right|$.\n\nUse a backward Euler (implicit) corrector at each strain increment $d \\gamma$:\n- Trial stress: $\\tau_{\\text{tr}} = \\tau_{\\text{prev}} + G \\, d \\gamma$.\n- Plastic flow under backward Euler and associated flow in simple shear produces $d \\gamma^{p} = \\sqrt{3} \\, d p \\, \\operatorname{sign}(\\tau - a)$ at the end of the increment.\n- Armstrong–Frederick update in simple shear with backward Euler: $a_{\\text{new}} = \\dfrac{a_{\\text{prev}} + c \\, \\sqrt{\\dfrac{3}{4}} \\, d p \\, \\operatorname{sign}(\\tau_{\\text{new}} - a_{\\text{new}})}{1 + \\gamma \\, d p}$.\n- Stress corrector: $\\tau_{\\text{new}} = \\tau_{\\text{tr}} - G \\, \\sqrt{3} \\, d p \\, \\operatorname{sign}(\\tau_{\\text{new}} - a_{\\text{new}})$.\n- Consistency: $\\sqrt{3} \\, \\left| \\tau_{\\text{new}} - a_{\\text{new}} \\right| = \\sigma_{y}$.\n\nTask 1. Starting from the above fundamental base and using the backward Euler discretization in the one-dimensional simple shear subspace, derive a scalar nonlinear residual equation for the plastic multiplier increment $d p$ that enforces the consistency condition, expressed only in terms of known quantities at the start of the increment ($\\tau_{\\text{prev}}$, $a_{\\text{prev}}$), the trial stress $\\tau_{\\text{tr}}$, and material parameters ($G$, $\\sigma_{y}$, $c$, $\\gamma$). Then, derive the Newton update formula for $d p$ by computing the derivative of the residual with respect to $d p$.\n\nTask 2. From the same backward Euler integration, derive the consistent algorithmic shear tangent $C_{\\text{alg}} = \\dfrac{d \\tau_{\\text{new}}}{d \\gamma}$ that linearizes the stress response with respect to the strain increment within the chosen integration scheme. Express $C_{\\text{alg}}$ in terms of $G$, $c$, $\\gamma$, $a_{\\text{prev}}$, and the converged $d p$ of the increment.\n\nTask 3. Implement a program that performs the following for a set of strain increments:\n- Applies each shear strain increment $d \\gamma$ in sequence.\n- At each increment, computes $\\tau_{\\text{tr}}$, tests for elasticity using the trial yield function $f_{\\text{tr}} = \\sqrt{3} \\, \\left| \\tau_{\\text{tr}} - a_{\\text{prev}} \\right| - \\sigma_{y}$. If $f_{\\text{tr}} \\le 0$, the step is elastic and no Newton iteration is needed; set $d p = 0$, $\\tau_{\\text{new}} = \\tau_{\\text{tr}}$, $a_{\\text{new}} = a_{\\text{prev}}$, and $C_{\\text{alg}} = G$.\n- If $f_{\\text{tr}}  0$, solve for $d p$ using Newton’s method on the derived residual. Use a numerically reasonable initial guess derived from the linear kinematic hardening case (with $\\gamma = 0$), clamp $d p \\ge 0$, and employ a tolerance $\\epsilon = 10^{-10}$ for the residual norm with a maximum of $50$ iterations. Update $\\tau_{\\text{new}}$, $a_{\\text{new}}$, and compute $C_{\\text{alg}}$ from Task $2$.\n- Track the number of Newton iterations required at each increment.\n\nYour program should assess Newton convergence under severe undrained softening cycles by reporting, for each test case, the maximum number of Newton iterations observed over all increments as an integer. All stresses must be in kilopascals (kPa), strains are dimensionless, and angles do not appear. No physical quantity is requested in the final output; only iteration counts are required.\n\nTest Suite. Use the following four test cases, each defined by a tuple $(G, \\sigma_{y}, c, \\gamma, \\text{increments})$ with $G$ in $\\text{kPa}$, $\\sigma_{y}$ in $\\text{kPa}$, $c$ in $\\text{kPa}$, $\\gamma$ in $\\text{(strain)}^{-1}$, and strain increments dimensionless:\n- Case $1$ (general cyclic loading): $(G = 50000, \\sigma_{y} = 100, c = 15000, \\gamma = 80, \\text{increments} = [0.002, 0.002, -0.004, 0.004, -0.004, 0.004])$.\n- Case $2$ (severe softening due to strong dynamic recovery): $(G = 30000, \\sigma_{y} = 60, c = 5000, \\gamma = 600, \\text{increments} = [0.004, -0.008, 0.008, -0.008, 0.008])$.\n- Case $3$ (near-elastic regime with very small increments): $(G = 40000, \\sigma_{y} = 200, c = 10000, \\gamma = 50, \\text{increments} = [0.0005, -0.0005, 0.0005, -0.0005])$.\n- Case $4$ (boundary case near yield with reversal): $(G = 35000, \\sigma_{y} = 80, c = 8000, \\gamma = 200, \\text{increments} = [0.0012, 0.0012, -0.0024])$.\n\nFinal Output Format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the cases listed above. For example, if the maximum Newton iteration counts over the increments are $n_{1}$, $n_{2}$, $n_{3}$, and $n_{4}$, your program must output exactly: $[n_{1},n_{2},n_{3},n_{4}]$.", "solution": "The user-provided problem requires the derivation and implementation of a backward Euler return mapping algorithm for a one-dimensional simple shear von Mises elastoplastic model with nonlinear Armstrong–Frederick kinematic hardening. The solution is presented in three parts, corresponding to the tasks specified in the problem statement.\n\n### Task 1: Derivation of the Residual Equation and Newton Update\n\nThe objective is to find the plastic multiplier increment, denoted as $dp$, that ensures the state at the end of an increment (the 'new' state) satisfies the yield condition, also known as the consistency condition. This is achieved by formulating a residual equation $R(dp) = 0$ which is solved numerically, typically using Newton's method.\n\nLet the state variables at the beginning of the increment be the shear stress $\\tau_{\\text{prev}}$ and the backstress $a_{\\text{prev}}$. The increment is driven by a total shear strain increment $d\\gamma$.\n\n**1. Trial State:**\nFirst, an elastic trial state is computed assuming the entire strain increment $d\\gamma$ is elastic.\nThe trial stress $\\tau_{\\text{tr}}$ is:\n$$ \\tau_{\\text{tr}} = \\tau_{\\text{prev}} + G \\, d\\gamma $$\nThe backstress remains unchanged in the trial step: $a_{\\text{tr}} = a_{\\text{prev}}$.\n\n**2. Yield Check:**\nPlasticity occurs if the trial state lies outside the yield surface. The yield function in simple shear is $f = \\sqrt{3} |\\tau - a| - \\sigma_y$. The trial yield function is:\n$$ f_{\\text{tr}} = \\sqrt{3} |\\tau_{\\text{tr}} - a_{\\text{prev}}| - \\sigma_y $$\nIf $f_{\\text{tr}} \\le 0$, the step is elastic. The final state is the trial state, and $dp=0$. If $f_{\\text{tr}}  0$, a plastic correction is required.\n\n**3. Plastic Corrector (Return Mapping):**\nThe final state $(\\tau_{\\text{new}}, a_{\\text{new}})$ must satisfy the constitutive equations and the consistency condition, all discretized using the backward Euler scheme.\nThe flow direction is determined by the sign of the relative stress. We assume this sign remains constant and is given by the trial state:\n$$ S = \\operatorname{sign}(\\tau_{\\text{tr}} - a_{\\text{prev}}) $$\nThe update equations are given as:\n$$ \\tau_{\\text{new}} = \\tau_{\\text{tr}} - G \\, d\\gamma^p $$\n$$ a_{\\text{new}} = \\frac{a_{\\text{prev}} + c \\, d\\varepsilon_{12}^p - \\gamma \\, a_{\\text{prev}} \\, dp}{1 + \\gamma \\, dp} \\quad \\text{is not how it's stated. Let's use the provided equations.}$$\nUsing the provided backward Euler update rules:\n$$ \\tau_{\\text{new}} = \\tau_{\\text{tr}} - G \\sqrt{3} \\, dp \\, S $$\n$$ a_{\\text{new}} = \\frac{a_{\\text{prev}} + c (\\sqrt{3}/2) \\, dp \\, S}{1 + \\gamma \\, dp} $$\nThe consistency condition at the end of the step requires:\n$$ \\sqrt{3} |\\tau_{\\text{new}} - a_{\\text{new}}| = \\sigma_y $$\nAssuming the sign $S$ is preserved, this becomes:\n$$ \\tau_{\\text{new}} - a_{\\text{new}} = S \\frac{\\sigma_y}{\\sqrt{3}} $$\nNow, substitute the expressions for $\\tau_{\\text{new}}$ and $a_{\\text{new}}$ into the consistency condition:\n$$ \\left( \\tau_{\\text{tr}} - G \\sqrt{3} \\, dp \\, S \\right) - \\left( \\frac{a_{\\text{prev}} + c (\\sqrt{3}/2) \\, dp \\, S}{1 + \\gamma \\, dp} \\right) = S \\frac{\\sigma_y}{\\sqrt{3}} $$\nTo form the residual equation, we group all terms on one side. Let's define the relative stress at the trial state as $\\xi_{\\text{tr}} = \\tau_{\\text{tr}} - a_{\\text{prev}}$. Note that $S = \\operatorname{sign}(\\xi_{\\text{tr}})$, so $S \\xi_{\\text{tr}} = |\\xi_{\\text{tr}}|$.\nMultiplying the equation by $S$ (since $S^2=1$):\n$$ S\\tau_{\\text{tr}} - G \\sqrt{3} \\, dp - \\left( \\frac{S a_{\\text{prev}} + c (\\sqrt{3}/2) \\, dp}{1 + \\gamma \\, dp} \\right) = \\frac{\\sigma_y}{\\sqrt{3}} $$\n$$ S\\tau_{\\text{tr}} - S a_{\\text{prev}} - G \\sqrt{3} \\, dp - \\left( \\frac{S a_{\\text{prev}} + c (\\sqrt{3}/2) \\, dp}{1 + \\gamma \\, dp} \\right) + S a_{\\text{prev}} = \\frac{\\sigma_y}{\\sqrt{3}} $$\n$$ S(\\tau_{\\text{tr}} - a_{\\text{prev}}) - G \\sqrt{3} \\, dp - \\frac{S a_{\\text{prev}} (1+\\gamma dp) + c (\\sqrt{3}/2) dp - S a_{\\text{prev}}(1+\\gamma dp)}{1+\\gamma dp} = \\frac{\\sigma_y}{\\sqrt{3}} $$\n$$ |\\tau_{\\text{tr}} - a_{\\text{prev}}| - G \\sqrt{3} \\, dp - \\frac{S a_{\\text{prev}}(1+\\gamma dp) - S a_{\\text{prev}} + c (\\sqrt{3}/2) dp}{1+\\gamma dp} = \\frac{\\sigma_y}{\\sqrt{3}} $$\nThis is becoming complicated. Let's use the relative stress $\\xi = \\tau - a$.\nThe consistency condition is $\\xi_{\\text{new}} = S\\sigma_y/\\sqrt{3}$. Let's express $\\xi_{\\text{new}}$ as a function of $dp$:\n$$ \\xi_{\\text{new}} = \\tau_{\\text{new}} - a_{\\text{new}} = (\\tau_{\\text{tr}} - G\\sqrt{3} S dp) - \\frac{a_{\\text{prev}} + c(\\sqrt{3}/2)S dp}{1+\\gamma dp} $$\n$$ \\xi_{\\text{new}} = \\tau_{\\text{tr}} - a_{\\text{prev}} + a_{\\text{prev}} - G\\sqrt{3}S dp - \\frac{a_{\\text{prev}} + c(\\sqrt{3}/2)S dp}{1+\\gamma dp} $$\n$$ \\xi_{\\text{new}} = \\xi_{\\text{tr}} - G\\sqrt{3}S dp + \\frac{a_{\\text{prev}}(1+\\gamma dp) - (a_{\\text{prev}} + c(\\sqrt{3}/2)S dp)}{1+\\gamma dp} $$\n$$ \\xi_{\\text{new}} = \\xi_{\\text{tr}} - G\\sqrt{3}S dp + \\frac{a_{\\text{prev}}\\gamma dp - c(\\sqrt{3}/2)S dp}{1+\\gamma dp} $$\nSetting $\\xi_{\\text{new}} = S\\sigma_y/\\sqrt{3}$ and multiplying by $S$:\n$$ \\frac{\\sigma_y}{\\sqrt{3}} = S\\xi_{\\text{tr}} - G\\sqrt{3} dp + \\frac{S a_{\\text{prev}}\\gamma dp - c(\\sqrt{3}/2) dp}{1+\\gamma dp} $$\n$$ \\frac{\\sigma_y}{\\sqrt{3}} = |\\tau_{\\text{tr}} - a_{\\text{prev}}| - G\\sqrt{3} dp - \\frac{(c\\sqrt{3}/2 - S a_{\\text{prev}}\\gamma) dp}{1+\\gamma dp} $$\nThe residual equation $R(dp) = 0$ is therefore:\n$$ R(dp) = |\\tau_{\\text{tr}} - a_{\\text{prev}}| - \\frac{\\sigma_y}{\\sqrt{3}} - G\\sqrt{3} dp - \\frac{(c\\sqrt{3}/2 - S a_{\\text{prev}}\\gamma) dp}{1+\\gamma dp} = 0 $$\nNote that $f_{\\text{tr}}/\\sqrt{3} = |\\tau_{\\text{tr}} - a_{\\text{prev}}| - \\sigma_y/\\sqrt{3}$. So the residual can be written as:\n$$ R(dp) = \\frac{f_{\\text{tr}}}{\\sqrt{3}} - \\left( G\\sqrt{3} + \\frac{c\\sqrt{3}/2 - S a_{\\text{prev}}\\gamma}{1+\\gamma dp} \\right) dp = 0 $$\n\n**4. Newton Update Formula:**\nTo solve $R(dp)=0$ using Newton's method, we need the derivative of $R$ with respect to $dp$, denoted $R'(dp)$.\nLet the term $K = c\\sqrt{3}/2 - S a_{\\text{prev}}\\gamma$.\n$$ R(dp) = \\frac{f_{\\text{tr}}}{\\sqrt{3}} - G\\sqrt{3} dp - K \\frac{dp}{1+\\gamma dp} $$\n$$ R'(dp) = \\frac{d R}{d(dp)} = -G\\sqrt{3} - K \\frac{d}{d(dp)}\\left( \\frac{dp}{1+\\gamma dp} \\right) $$\nUsing the quotient rule, $\\frac{d}{dx}(\\frac{u}{v}) = \\frac{u'v-uv'}{v^2}$:\n$$ \\frac{d}{d(dp)}\\left( \\frac{dp}{1+\\gamma dp} \\right) = \\frac{1(1+\\gamma dp) - dp(\\gamma)}{(1+\\gamma dp)^2} = \\frac{1}{(1+\\gamma dp)^2} $$\nSo, the derivative of the residual is:\n$$ R'(dp) = -G\\sqrt{3} - \\frac{K}{(1+\\gamma dp)^2} = - \\left( G\\sqrt{3} + \\frac{c\\sqrt{3}/2 - S a_{\\text{prev}}\\gamma}{(1+\\gamma dp)^2} \\right) $$\nThe Newton-Raphson update for $dp$ at iteration $k$ is:\n$$ dp_{k+1} = dp_k - \\frac{R(dp_k)}{R'(dp_k)} $$\n\n### Task 2: Derivation of the Consistent Algorithmic Tangent\n\nThe consistent algorithmic tangent $C_{\\text{alg}}$ is the derivative of the updated stress $\\tau_{\\text{new}}$ with respect to the total strain increment $d\\gamma$.\n$$ C_{\\text{alg}} = \\frac{d\\tau_{\\text{new}}}{d(d\\gamma)} $$\nWe have $\\tau_{\\text{new}} = \\tau_{\\text{prev}} + G d\\gamma - G\\sqrt{3}S\\,dp$. Differentiating with respect to $d\\gamma$:\n$$ C_{\\text{alg}} = G - G\\sqrt{3}S \\frac{d(dp)}{d(d\\gamma)} $$\nHere, $S = \\operatorname{sign}(\\tau_{\\text{prev}} + G d\\gamma - a_{\\text{prev}})$ is treated as constant within the increment after the trial step determines the loading direction. The plastic multiplier $dp$ is an implicit function of $d\\gamma$ through the residual equation $R(dp, d\\gamma) = 0$. We use implicit differentiation on $R=0$:\n$$ dR = \\frac{\\partial R}{\\partial(dp)} d(dp) + \\frac{\\partial R}{\\partial(d\\gamma)} d(d\\gamma) = 0 $$\nThis gives $\\frac{d(dp)}{d(d\\gamma)} = - \\left( \\frac{\\partial R}{\\partial(dp)} \\right)^{-1} \\frac{\\partial R}{\\partial(d\\gamma)}$.\nWe already found $\\frac{\\partial R}{\\partial(dp)} = R'(dp)$. Now we find $\\frac{\\partial R}{\\partial(d\\gamma)}$:\n$$ \\frac{\\partial R}{\\partial(d\\gamma)} = \\frac{\\partial}{\\partial(d\\gamma)}\\left( |\\tau_{\\text{prev}} + G d\\gamma - a_{\\text{prev}}| - \\frac{\\sigma_y}{\\sqrt{3}} - \\dots \\right) = \\frac{\\partial}{\\partial(d\\gamma)}\\left( S(\\tau_{\\text{prev}} + G d\\gamma - a_{\\text{prev}}) \\right) = SG $$\nTherefore:\n$$ \\frac{d(dp)}{d(d\\gamma)} = - \\frac{SG}{R'(dp)} = \\frac{SG}{G\\sqrt{3} + \\frac{c\\sqrt{3}/2 - S a_{\\text{prev}}\\gamma}{(1+\\gamma dp)^2}} $$\nSubstituting this back into the expression for $C_{\\text{alg}}$:\n$$ C_{\\text{alg}} = G - G\\sqrt{3}S \\left( \\frac{SG}{G\\sqrt{3} + \\frac{c\\sqrt{3}/2 - S a_{\\text{prev}}\\gamma}{(1+\\gamma dp)^2}} \\right) $$\nSince $S^2=1$:\n$$ C_{\\text{alg}} = G - \\frac{G^2\\sqrt{3}}{G\\sqrt{3} + \\frac{c\\sqrt{3}/2 - S a_{\\text{prev}}\\gamma}{(1+\\gamma dp)^2}} $$\nThis can be rearranged into a more compact form:\n$$ C_{\\text{alg}} = G \\left( 1 - \\frac{G\\sqrt{3}}{G\\sqrt{3} + \\frac{c\\sqrt{3}/2 - S a_{\\text{prev}}\\gamma}{(1+\\gamma dp)^2}} \\right) = G \\frac{\\frac{c\\sqrt{3}/2 - S a_{\\text{prev}}\\gamma}{(1+\\gamma dp)^2}}{G\\sqrt{3} + \\frac{c\\sqrt{3}/2 - S a_{\\text{prev}}\\gamma}{(1+\\gamma dp)^2}} $$\n$$ C_{\\text{alg}} = \\frac{G (c\\sqrt{3}/2 - S a_{\\text{prev}}\\gamma)}{G\\sqrt{3}(1+\\gamma dp)^2 + c\\sqrt{3}/2 - S a_{\\text{prev}}\\gamma} $$\nThis expression for $C_{\\text{alg}}$ uses the converged value of $dp$ for the increment. For an elastic step ($dp=0$), the expression must reduce to $G$. In the plastic case, $S$ and $a_{\\text{prev}}$ are knowns, so the expression is fully defined. If $dp=0$, then $S$ is irrelevant as the numerator of the derivative of dp would conceptually be zero. The elastic tangent is simply $G$.\n\n### Task 3: Implementation\nThe derived equations are implemented in a Python program. The main logic follows these steps for each strain increment:\n1. Compute trial stress $\\tau_{\\text{tr}}$ and trial yield function $f_{\\text{tr}}$.\n2. If $f_{\\text{tr}} \\le 0$, the step is elastic. Update $\\tau_{\\text{new}} = \\tau_{\\text{tr}}$, $a_{\\text{new}} = a_{\\text{prev}}$. The number of Newton iterations is $0$.\n3. If $f_{\\text{tr}}  0$, the step is plastic.\n    a. Determine the sign $S = \\operatorname{sign}(\\tau_{\\text{tr}} - a_{\\text{prev}})$.\n    b. Calculate an initial guess for $dp$ from the linear hardening case ($\\gamma=0$): $dp_0 = f_{\\text{tr}} / (3G + 1.5c)$.\n    c. Start the Newton-Raphson loop to solve $R(dp) = 0$ for $dp$, using the residual $R(dp)$ and its derivative $R'(dp)$ derived in Task 1.\n    d. Clamp $dp \\ge 0$ at each iteration.\n    e. Stop when $|R(dp)|$ is below a tolerance $(\\epsilon=10^{-10})$ or max iterations ($50$) is reached.\n    f. Count the number of iterations.\n    g. Update $\\tau_{\\text{new}}$ and $a_{\\text{new}}$ using the converged $dp$.\n4. Track the maximum number of Newton iterations over all increments for each test case.\n5. Report the list of maximum iteration counts.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Test cases defined as (G, sigma_y, c, gamma, increments)\n    # G in kPa, sigma_y in kPa, c in kPa, gamma dimensionless, increments dimensionless\n    test_cases = [\n        # Case 1: general cyclic loading\n        (50000.0, 100.0, 15000.0, 80.0, [0.002, 0.002, -0.004, 0.004, -0.004, 0.004]),\n        # Case 2: severe softening due to strong dynamic recovery\n        (30000.0, 60.0, 5000.0, 600.0, [0.004, -0.008, 0.008, -0.008, 0.008]),\n        # Case 3: near-elastic regime with very small increments\n        (40000.0, 200.0, 10000.0, 50.0, [0.0005, -0.0005, 0.0005, -0.0005]),\n        # Case 4: boundary case near yield with reversal\n        (35000.0, 80.0, 8000.0, 200.0, [0.0012, 0.0012, -0.0024]),\n    ]\n\n    results = []\n    for params in test_cases:\n        max_iters = run_simulation(*params)\n        results.append(max_iters)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_simulation(G, sigma_y, c, gamma, increments):\n    \"\"\"\n    Performs the elastoplastic simulation for a single test case.\n\n    Args:\n        G (float): Shear modulus.\n        sigma_y (float): Yield stress.\n        c (float): Kinematic hardening modulus.\n        gamma (float): Dynamic recovery parameter.\n        increments (list of float): Sequence of shear strain increments.\n\n    Returns:\n        int: The maximum number of Newton iterations over all increments.\n    \"\"\"\n    tau_prev = 0.0\n    a_prev = 0.0\n    max_newton_iterations = 0\n    sqrt3 = np.sqrt(3.0)\n\n    for d_gamma in increments:\n        # --- ELASTIC PREDICTOR ---\n        tau_tr = tau_prev + G * d_gamma\n        xi_tr = tau_tr - a_prev\n\n        # Trial yield function\n        # A small tolerance is used for the elastic check to handle floating point inaccuracies\n        f_tr = sqrt3 * np.abs(xi_tr) - sigma_y\n\n        if f_tr = 1e-12:\n            # Elastic step\n            tau_new = tau_tr\n            a_new = a_prev\n            current_iterations = 0\n        else:\n            # --- PLASTIC CORRECTOR ---\n            S = np.sign(xi_tr)\n            \n            # Initial guess for dp from the linear hardening case (gamma = 0)\n            dp0_denom = 3.0 * G + 1.5 * c\n            dp = f_tr / dp0_denom if dp0_denom > 1e-12 else 0.0\n            \n            # Clamp initial guess to be non-negative\n            dp = max(0.0, dp)\n\n            # Newton-Raphson iteration for plastic multiplier dp\n            tol = 1e-10\n            max_iter_newton = 50\n            current_iterations = 0\n\n            for i in range(max_iter_newton):\n                current_iterations += 1\n                \n                # Pre-calculate hardening-recovery term for residual and derivative\n                K = c * sqrt3 / 2.0 - S * a_prev * gamma\n                \n                # Check for unstable denominator, though dp should be non-negative\n                denom = 1.0 + gamma * dp\n                if denom  1e-9: # Avoid division by zero/small number\n                    dp = 0.0 # Revert to a safe value\n                    denom = 1.0\n\n                # Residual function R(dp)\n                # R(dp) = f_tr/sqrt(3) - [G*sqrt(3) + K/(1+gamma*dp)]*dp\n                residual = f_tr / sqrt3 - sqrt3 * G * dp - K * dp / denom\n                \n                if np.abs(residual)  tol:\n                    break\n\n                # Derivative of the residual R'(dp)\n                residual_prime = -sqrt3 * G - K / (denom**2)\n\n                if np.abs(residual_prime)  1e-12:\n                    # Jacobian is singular, break to avoid division by zero\n                    # This may indicate convergence issues, but the algorithm will proceed with the last dp.\n                    break\n                \n                # Newton update\n                dp_update = -residual / residual_prime\n                dp += dp_update\n                \n                # Clamp dp to be non-negative. This handles cases of elastic unloading\n                # detected during the iterative correction.\n                dp = max(0.0, dp)\n            \n            # --- Update state variables ---\n            tau_new = tau_tr - G * sqrt3 * dp * S\n            a_new = (a_prev + c * sqrt3 / 2.0 * dp * S) / (1.0 + gamma * dp)\n\n        if current_iterations > max_newton_iterations:\n            max_newton_iterations = current_iterations\n        \n        # update for next increment\n        tau_prev = tau_new\n        a_prev = a_new\n        \n    return max_newton_iterations\n\n# Execute the simulation and print the results.\nsolve()\n```", "id": "3529165"}, {"introduction": "A critical challenge in modeling geomaterials is that standard continuum models with strain-softening exhibit pathological mesh sensitivity, where failure localizes into a zone of vanishing width and the predicted energy dissipation incorrectly tends to zero upon mesh refinement. This practice [@problem_id:3529154] addresses this issue head-on by exploring the crack-band model, a powerful and widely-used regularization technique. You will learn to restore mesh objectivity by explicitly linking the material's constitutive softening law to the finite element size and the material's fracture energy, $G_f$, ensuring that the simulated structural response correctly dissipates a physically meaningful amount of energy regardless of the discretization.", "problem": "You are given a uniaxial tension model of a notched specimen represented by a one-dimensional series system: an elastic bar segment in series with a crack-band finite element that undergoes softening. The elastic segment has Young’s modulus $E$, cross-sectional area $A$, and length $L_r = L_{\\text{tot}} - h$, where $L_{\\text{tot}}$ is the total specimen length and $h$ is the characteristic element length of the crack-band. The crack-band element follows a softening law $\\sigma(\\varepsilon_p)$ as a function of the equivalent plastic strain $\\varepsilon_p$, and the corresponding cohesive traction-separation law $T(w)$ is linked by $w = h \\, \\varepsilon_p$ and $T(w) = \\sigma(\\varepsilon_p)$. The tensile strength is $f_t$ and the target mode-I fracture energy is $G_f$.\n\nFundamental base:\n- The crack-band energy equivalence states that the energy dissipated per unit area is equal to the material fracture energy. In a continuum element of characteristic length $h$, the requirement is\n$$\n\\int_{0}^{\\varepsilon_{p,\\text{end}}} \\sigma(\\varepsilon_p) \\, d\\varepsilon_p = \\frac{G_f}{h}.\n$$\n- The traction-separation law $T(w)$ of the crack-band element must satisfy\n$$\n\\int_{0}^{w_{\\text{end}}} T(w) \\, dw = G_f,\n$$\nwith $w = h \\, \\varepsilon_p$ and $T(w) = \\sigma(\\varepsilon_p)$.\n- For an elastic segment of length $L_r$ in series with a cohesive element, under an applied end displacement $\\Delta$, the equilibrium relations are\n$$\nF = A \\, T(w), \\quad \\Delta = \\frac{L_r}{E A} \\, F + w,\n$$\nwith elastic loading up to yielding at $\\Delta_y = \\frac{f_t L_r}{E}$ and $F_y = f_t A$.\n\nYour tasks:\n1. Calibrate the softening law $\\sigma(\\varepsilon_p)$ for two forms so that the crack-band energy equivalence holds:\n   - Linear softening: $\\sigma(\\varepsilon_p) = f_t \\, \\max\\!\\left(1 - \\frac{\\varepsilon_p}{\\varepsilon_f}, 0\\right)$ for $0 \\le \\varepsilon_p \\le \\varepsilon_f$.\n   - Exponential softening: $\\sigma(\\varepsilon_p) = f_t \\, \\exp\\!\\left(-\\frac{\\varepsilon_p}{\\varepsilon_c}\\right)$ for $0 \\le \\varepsilon_p  \\infty$.\n   Derive the calibration parameters $\\varepsilon_f$ and $\\varepsilon_c$ from the fundamental base without using shortcut formulas.\n\n2. Using the calibrated $T(w)$, verify mesh objectivity in the notched specimen model by comparing the total external work to complete failure for two different crack-band element sizes $h$ in each test case. The total external work should equal the fracture energy dissipated across the crack area, which is $A \\, G_f$ in Joules. Compute the total work by combining elastic loading to $\\Delta_y$ and post-yield softening. The elastic segment unloading and the cohesive softening may exhibit snap-back; therefore, your computation must be robust to non-monotonic force–displacement behavior and must not rely on inverting $\\Delta(w)$.\n\n3. Numerically verify the calibration by computing $\\int \\sigma(\\varepsilon_p) \\, d\\varepsilon_p$ for each $h$ and comparing it against $\\frac{G_f}{h}$. Also compute the total external work to failure and compare it against $A \\, G_f$ for each $h$.\n\nUnits and numerical requirements:\n- Use International System of Units (SI): $E$ in Pascal (Pa), $A$ in square meters ($\\mathrm{m}^2$), $L_{\\text{tot}}$, $L_r$, and $h$ in meters ($\\mathrm{m}$), $f_t$ in Pascal (Pa), $G_f$ in Joules per square meter ($\\mathrm{J/m^2}$), $w$ in meters ($\\mathrm{m}$), $\\varepsilon_p$ dimensionless, $\\Delta$ in meters ($\\mathrm{m}$), $F$ in Newtons (N), and total external work in Joules (J).\n- When reporting discrepancies, express them as decimal fractions (unitless), not with a percentage sign. For example, report $0.001$ to mean a discrepancy of $0.1\\%$.\n- Your program should compute, for each test case, the maximum of the four relative errors: two from the softening-law area checks (one for each $h$) and two from the mesh-objectivity work checks (one for each $h$).\n\nTest suite:\n- Test case $1$ (linear softening, happy path):\n  - $E = 30 \\times 10^9$ Pa, $f_t = 3 \\times 10^6$ Pa, $G_f = 120$ $\\mathrm{J/m^2}$, $A = 5 \\times 10^{-3}$ $\\mathrm{m^2}$, $L_{\\text{tot}} = 1$ $\\mathrm{m}$, $h_1 = 0.02$ $\\mathrm{m}$, $h_2 = 0.10$ $\\mathrm{m}$.\n- Test case $2$ (exponential softening, happy path):\n  - $E = 30 \\times 10^9$ Pa, $f_t = 3 \\times 10^6$ Pa, $G_f = 120$ $\\mathrm{J/m^2}$, $A = 5 \\times 10^{-3}$ $\\mathrm{m^2}$, $L_{\\text{tot}} = 1$ $\\mathrm{m}$, $h_1 = 0.02$ $\\mathrm{m}$, $h_2 = 0.10$ $\\mathrm{m}$.\n- Test case $3$ (linear softening, boundary element sizes):\n  - $E = 20 \\times 10^9$ Pa, $f_t = 2 \\times 10^6$ Pa, $G_f = 80$ $\\mathrm{J/m^2}$, $A = 1 \\times 10^{-3}$ $\\mathrm{m^2}$, $L_{\\text{tot}} = 0.2$ $\\mathrm{m}$, $h_1 = 0.001$ $\\mathrm{m}$, $h_2 = 0.05$ $\\mathrm{m}$.\n\nAlgorithmic guidance:\n- For linear softening, the cohesive law is $T(w) = f_t \\left(1 - \\frac{w}{w_f}\\right)$ for $0 \\le w \\le w_f$ with $w_f = h \\, \\varepsilon_f$. For exponential softening, $T(w) = f_t \\exp\\!\\left(-\\frac{w}{w_c}\\right)$ for $w \\ge 0$ with $w_c = h \\, \\varepsilon_c$.\n- Compute pre-yield elastic work as $W_{\\text{el}} = \\frac{1}{2} \\frac{F_y^2}{k_r}$ with $F_y = f_t A$ and $k_r = \\frac{E A}{L_r}$.\n- Compute post-yield work by parameterizing with $w$ and integrating $F(w) \\, \\frac{d\\Delta}{dw}$ over $w$, where $F(w) = A \\, T(w)$ and $\\frac{d\\Delta}{dw} = 1 + \\frac{L_r}{E} \\frac{dT}{dw}$. For linear softening, integrate over $w \\in [0, w_f]$. For exponential softening, integrate over $w \\in [0, w_{\\text{end}}]$ with $w_{\\text{end}}$ sufficiently large (for example $w_{\\text{end}} = 12 \\, w_c$) and verify that the tail contribution is negligible.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, \"[result1,result2,result3]\"), where each result is the maximum relative error for the corresponding test case computed as described above.", "solution": "The problem statement is valid. It is scientifically grounded in the principles of computational fracture mechanics, specifically the crack-band model. All parameters, definitions, and constraints are provided, forming a well-posed and self-contained problem. The numerical values are physically realistic for quasi-brittle materials like concrete. The tasks are clearly defined and computationally feasible. We will proceed with a full solution.\n\nThe solution involves three main parts: first, the analytical calibration of the parameters for the linear and exponential softening laws based on the fracture energy criterion. Second, the formulation of the total external work required for failure, including an analytical proof of mesh objectivity. Third, a description of the numerical procedure to verify these findings.\n\n### 1. Calibration of Softening Laws\n\nThe fundamental principle for calibration is the crack-band energy equivalence, which states that the energy dissipated per unit volume within the element, integrated over the plastic strain history, must equal the fracture energy $G_f$ normalized by the characteristic element length $h$:\n$$\n\\int_{0}^{\\varepsilon_{p,\\text{end}}} \\sigma(\\varepsilon_p) \\, d\\varepsilon_p = \\frac{G_f}{h}\n$$\nHere, $\\sigma(\\varepsilon_p)$ is the softening stress as a function of the equivalent plastic strain $\\varepsilon_p$.\n\n#### 1.1. Linear Softening Law\nThe linear softening law is given by:\n$$\n\\sigma(\\varepsilon_p) = f_t \\, \\left(1 - \\frac{\\varepsilon_p}{\\varepsilon_f}\\right), \\quad \\text{for} \\quad 0 \\le \\varepsilon_p \\le \\varepsilon_f\n$$\nwhere $f_t$ is the tensile strength and $\\varepsilon_f$ is the ultimate plastic strain at which stress reduces to zero. We substitute this into the energy equivalence integral:\n$$\n\\int_{0}^{\\varepsilon_f} f_t \\left(1 - \\frac{\\varepsilon_p}{\\varepsilon_f}\\right) \\, d\\varepsilon_p = f_t \\left[\\varepsilon_p - \\frac{\\varepsilon_p^2}{2\\varepsilon_f}\\right]_{0}^{\\varepsilon_f} = f_t \\left(\\varepsilon_f - \\frac{\\varepsilon_f^2}{2\\varepsilon_f}\\right) = \\frac{1}{2} f_t \\varepsilon_f\n$$\nEquating this to the required dissipated energy density:\n$$\n\\frac{1}{2} f_t \\varepsilon_f = \\frac{G_f}{h}\n$$\nSolving for the calibration parameter $\\varepsilon_f$ yields:\n$$\n\\varepsilon_f = \\frac{2 G_f}{h f_t}\n$$\n\n#### 1.2. Exponential Softening Law\nThe exponential softening law is given by:\n$$\n\\sigma(\\varepsilon_p) = f_t \\, \\exp\\!\\left(-\\frac{\\varepsilon_p}{\\varepsilon_c}\\right), \\quad \\text{for} \\quad \\varepsilon_p \\ge 0\n$$\nwhere $\\varepsilon_c$ is a characteristic plastic strain. The plastic strain theoretically extends to infinity, so $\\varepsilon_{p,\\text{end}} = \\infty$. The energy equivalence integral is:\n$$\n\\int_{0}^{\\infty} f_t \\exp\\!\\left(-\\frac{\\varepsilon_p}{\\varepsilon_c}\\right) \\, d\\varepsilon_p = f_t \\left[-\\varepsilon_c \\exp\\!\\left(-\\frac{\\varepsilon_p}{\\varepsilon_c}\\right)\\right]_{0}^{\\infty} = f_t \\left(0 - (-\\varepsilon_c)\\right) = f_t \\varepsilon_c\n$$\nEquating this to the target energy density:\n$$\nf_t \\varepsilon_c = \\frac{G_f}{h}\n$$\nSolving for the calibration parameter $\\varepsilon_c$ gives:\n$$\n\\varepsilon_c = \\frac{G_f}{h f_t}\n$$\n\nA crucial consequence of this energy-based calibration is that the characteristic crack opening, $w = h \\varepsilon_p$, becomes independent of the mesh size $h$. For linear softening, the final crack opening is $w_f = h \\varepsilon_f = h \\frac{2G_f}{h f_t} = \\frac{2G_f}{f_t}$. For exponential softening, the characteristic crack opening is $w_c = h \\varepsilon_c = h \\frac{G_f}{h f_t} = \\frac{G_f}{f_t}$. This materializes the fracture energy $G_f$ as a property of a cohesive crack, independent of the numerical discretization $h$.\n\n### 2. Mesh Objectivity and Total Work Calculation\n\nMesh-objectivity requires that the total energy dissipated to cause failure of the structure is a constant material property, independent of the mesh size $h$. For this uniaxial specimen, the total consumed energy must equal the fracture energy $G_f$ multiplied by the crack area $A$, i.e., $A G_f$. We verify this by calculating the total external work $W_{\\text{total}}$ done on the system from initial loading to complete failure.\n\nThe total work is the sum of the work done during the initial elastic loading phase, $W_{\\text{el}}$, and the work done during the post-yield softening phase, $W_{\\text{post-yield}}$.\n$$\nW_{\\text{total}} = W_{\\text{el}} + W_{\\text{post-yield}}\n$$\n\n#### 2.1. Elastic Work ($W_{\\text{el}}$)\nThe system loads elastically until the force reaches the yield force $F_y = f_t A$. During this phase, the crack opening $w$ is zero, and the total displacement $\\Delta$ is due solely to the elastic deformation of the bar of length $L_r$.\n$$\n\\Delta = \\frac{L_r}{E A} F\n$$\nAt yield, the displacement is $\\Delta_y = \\frac{L_r}{E A} F_y = \\frac{L_r f_t}{E}$. The work done is the area of the force-displacement triangle:\n$$\nW_{\\text{el}} = \\frac{1}{2} F_y \\Delta_y = \\frac{1}{2} (f_t A) \\left( \\frac{L_r f_t}{E} \\right) = \\frac{A L_r f_t^2}{2E}\n$$\n\n#### 2.2. Post-Yield Work ($W_{\\text{post-yield}}$)\nAfter yielding, the crack opening $w$ increases from $0$ while the force $F$ decreases according to the softening law. The total displacement is given by $\\Delta(w) = \\frac{L_r}{EA}F(w) + w$. The force is $F(w) = A T(w)$, where $T(w) = \\sigma(w/h)$ is the cohesive traction. The external work is given by the integral $\\int F d\\Delta$. To handle potential snap-back (non-monotonic $\\Delta$), we parameterize the integral with respect to the crack opening $w$:\n$$\nd\\Delta = \\frac{d\\Delta}{dw} dw = \\left(1 + \\frac{L_r}{EA} \\frac{dF}{dw}\\right) dw = \\left(1 + \\frac{L_r}{E} \\frac{dT}{dw}\\right) dw\n$$\nThe post-yield work is then:\n$$\nW_{\\text{post-yield}} = \\int_{w=0}^{w=w_{\\text{end}}} F(w) \\, d\\Delta = \\int_{0}^{w_{\\text{end}}} A T(w) \\left(1 + \\frac{L_r}{E} \\frac{dT}{dw}\\right) dw\n$$\n$$\nW_{\\text{post-yield}} = A \\int_{0}^{w_{\\text{end}}} T(w) dw + \\frac{A L_r}{E} \\int_{0}^{w_{\\text{end}}} T(w) \\frac{dT}{dw} dw\n$$\nThe first term, $A \\int T(w) dw$, is by definition the total fracture energy $A G_f$. The second integral can be solved by recognizing that $T(w) dT = \\frac{1}{2} d(T^2)$:\n$$\n\\int_{w=0}^{w=w_{\\text{end}}} T(w) \\frac{dT}{dw} dw = \\int_{T(0)}^{T(w_{\\text{end}})} T dT = \\frac{1}{2} [T^2]_{T=f_t}^{T=0} = -\\frac{1}{2} f_t^2\n$$\nThis holds for any softening law where $T(0)=f_t$ and $T(w_{\\text{end}})=0$. Substituting back:\n$$\nW_{\\text{post-yield}} = A G_f + \\frac{A L_r}{E} \\left(-\\frac{1}{2} f_t^2\\right) = A G_f - \\frac{A L_r f_t^2}{2E}\n$$\n\n#### 2.3. Total Work and Mesh Objectivity\nCombining the elastic and post-yield work components provides the total work:\n$$\nW_{\\text{total}} = W_{\\text{el}} + W_{\\text{post-yield}} = \\left(\\frac{A L_r f_t^2}{2E}\\right) + \\left(A G_f - \\frac{A L_r f_t^2}{2E}\\right) = A G_f\n$$\nThis analytical result proves that the total external work required to fail the specimen is exactly $A G_f$, regardless of the element size $h$ (which is embedded in $L_r = L_{\\text{tot}}-h$), the elastic modulus $E$, or the specific form of the energy-calibrated softening law. This confirms that the crack-band model formulation is mesh-objective.\n\n### 3. Numerical Verification Procedure\n\nThe numerical implementation will verify the analytical findings. For each test case and for each value of $h \\in \\{h_1, h_2\\}$, the following quantities will be computed.\n\n1.  **Softening Law Area Check**:\n    - The calibration parameter ($\\varepsilon_f$ or $\\varepsilon_c$) is computed.\n    - The integral $\\int \\sigma(\\varepsilon_p) d\\varepsilon_p$ is numerically evaluated using `scipy.integrate.quad`. For the exponential case, the integration is performed up to $\\varepsilon_{p,\\text{end}} = 12 \\varepsilon_c$.\n    - The numerical result is compared to the theoretical target $G_f/h$, and the relative error is calculated as $| \\text{numerical} - \\text{target} | / \\text{target}$.\n\n2.  **Total Work Check**:\n    - The elastic work $W_{\\text{el}}$ is calculated using the analytical formula.\n    - The post-yield work integrand, $F(w)(d\\Delta/dw)$, is defined.\n    - $W_{\\text{post-yield}}$ is computed by numerically integrating this function with respect to $w$ from $0$ to $w_{\\text{end}}$ ($w_f$ for linear, $12w_c$ for exponential).\n    - The total numerical work $W_{\\text{total,num}} = W_{\\text{el}} + W_{\\text{post-yield,num}}$ is computed.\n    - This result is compared to the theoretical target $A G_f$, and the relative error is calculated.\n\nFinally, for each test case, the maximum of the four computed relative errors (area check for $h_1, h_2$ and work check for $h_1, h_2$) is reported. Due to the exactness of the analytical solution, these errors are expected to be very small, arising only from numerical quadrature precision and floating-point arithmetic.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import integrate\n\ndef solve():\n    \"\"\"\n    Solves the computational geomechanics problem for all test cases.\n    \"\"\"\n    test_cases = [\n        # Test case 1: linear softening, happy path\n        {\n            'type': 'linear',\n            'E': 30e9, 'ft': 3e6, 'Gf': 120.0, 'A': 5e-3, 'L_tot': 1.0, \n            'h_values': [0.02, 0.10]\n        },\n        # Test case 2: exponential softening, happy path\n        {\n            'type': 'exponential',\n            'E': 30e9, 'ft': 3e6, 'Gf': 120.0, 'A': 5e-3, 'L_tot': 1.0, \n            'h_values': [0.02, 0.10]\n        },\n        # Test case 3: linear softening, boundary element sizes\n        {\n            'type': 'linear',\n            'E': 20e9, 'ft': 2e6, 'Gf': 80.0, 'A': 1e-3, 'L_tot': 0.2, \n            'h_values': [0.001, 0.05]\n        }\n    ]\n\n    results = []\n\n    for case_params in test_cases:\n        case_errors = []\n        softening_type = case_params['type']\n        E = case_params['E']\n        ft = case_params['ft']\n        Gf = case_params['Gf']\n        A = case_params['A']\n        L_tot = case_params['L_tot']\n        h_values = case_params['h_values']\n\n        for h in h_values:\n            L_r = L_tot - h\n\n            # 1. Calibrate and perform area check\n            if softening_type == 'linear':\n                # Calibration\n                eps_f = (2 * Gf) / (h * ft)\n                w_f = h * eps_f\n\n                # Area check\n                sigma_func = lambda eps_p: ft * (1 - eps_p / eps_f)\n                area_num, _ = integrate.quad(sigma_func, 0, eps_f)\n                \n                # Post-yield work calculation\n                T_func = lambda w: ft * (1 - w / w_f)\n                dTdw_func = lambda w: -ft / w_f\n                w_end = w_f\n            \n            elif softening_type == 'exponential':\n                # Calibration\n                eps_c = Gf / (h * ft)\n                w_c = h * eps_c\n\n                # Area check (truncated)\n                eps_end_factor = 12.0\n                eps_end = eps_end_factor * eps_c\n                sigma_func = lambda eps_p: ft * np.exp(-eps_p / eps_c)\n                area_num, _ = integrate.quad(sigma_func, 0, eps_end)\n\n                # Post-yield work calculation\n                T_func = lambda w: ft * np.exp(-w / w_c)\n                dTdw_func = lambda w: (-ft / w_c) * np.exp(-w / w_c)\n                w_end = eps_end_factor * w_c\n\n            area_target = Gf / h\n            rel_err_area = abs(area_num - area_target) / area_target\n            case_errors.append(rel_err_area)\n            \n            # 2. Compute total work and perform check\n            # Elastic work\n            W_el = (A * L_r * ft**2) / (2 * E)\n\n            # Post-yield work integrand: F(w) * d(Delta)/dw\n            work_integrand = lambda w: (A * T_func(w)) * (1 + (L_r / E) * dTdw_func(w))\n            \n            # Integrate to get post-yield work\n            W_post_yield_num, _ = integrate.quad(work_integrand, 0, w_end)\n            \n            W_total_num = W_el + W_post_yield_num\n            \n            # Target total work\n            W_target = A * Gf\n            \n            rel_err_work = abs(W_total_num - W_target) / W_target\n            case_errors.append(rel_err_work)\n\n        results.append(max(case_errors))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```", "id": "3529154"}, {"introduction": "A constitutive model is only as powerful as its parameters are realistic. This practice [@problem_id:3529103] advances from model implementation to the crucial task of model calibration, demonstrating how to connect the abstract parameters of a softening law to physically observable quantities like shear band orientation and material strength. You will construct a Bayesian inference framework, a state-of-the-art probabilistic method that systematically combines prior knowledge of parameters with experimental data to determine their most likely values and, just as importantly, quantify their uncertainty. This exercise offers a rigorous approach to learning from data, enabling the development of truly predictive geomechanical models.", "problem": "Consider a frictional geomaterial described within the small-strain elastoplastic framework using a Mohr–Coulomb strength criterion and a nonassociated flow rule. Let the internal friction angle degrade with an accumulated equivalent plastic shear strain, denoted by $\\kappa$, according to a smooth softening law $\\phi(\\kappa)$. You are tasked with constructing a Bayesian inference setup for the softening parameters using observations from a single element-level test and a measured shear band orientation. Your program must compute the natural logarithm of the posterior density for a set of candidate parameter vectors, given the data and modeling assumptions described below, and output the results for all test cases in a single line as a comma-separated list enclosed in square brackets.\n\nUse the following modeling assumptions, rooted in standard, well-tested facts in computational geomechanics:\n- The Mohr–Coulomb strength condition links the mobilized peak and critical shear strengths to the internal friction angle and cohesion under a known constant normal stress.\n- The shear band orientation at the onset of localization in a nonassociated frictional material depends on both the friction angle and the dilation angle at that state under plane strain conditions, as predicted by small-perturbation bifurcation or slip-line analyses.\n- The dilation angle at a given state is proportional to the friction angle at that state.\n\nFrom these bases, derive appropriate predictive relations for the following observables:\n- The peak shear strength under a constant normal stress $\\sigma_n$ and cohesion $c$.\n- The critical shear strength under the same $\\sigma_n$ and $c$.\n- The shear band orientation angle relative to the major principal stress direction at onset of localization, expressed in degrees.\n- The internal friction angle at a specified accumulated equivalent plastic shear strain $\\kappa_m$.\n\nParameterization and priors:\n- Let $\\phi(\\kappa)$ be parameterized by an exponential softening law with parameters $\\phi_0$ (peak friction angle, in degrees), $\\phi_c$ (critical friction angle, in degrees), and $k_s$ (positive softening strain scale, dimensionless), and let the dilation angle satisfy $\\psi(\\kappa) = \\beta \\, \\phi(\\kappa)$, where $\\beta \\in [0,1]$ is a nonassociativity parameter. Assume the shear band orientation is controlled by the onset state, which you may take to be at $\\kappa \\approx 0$.\n- Assume independent priors:\n  - $\\phi_0 \\sim \\mathcal{N}(\\mu_{\\phi_0}, \\sigma_{\\phi_0}^2)$ with $\\mu_{\\phi_0} = 35$ degrees and $\\sigma_{\\phi_0} = 5$ degrees.\n  - $\\phi_c \\sim \\mathcal{N}(\\mu_{\\phi_c}, \\sigma_{\\phi_c}^2)$ with $\\mu_{\\phi_c} = 30$ degrees and $\\sigma_{\\phi_c} = 5$ degrees.\n  - $k_s \\sim \\text{LogNormal}(\\mu_{\\ln k_s}, \\sigma_{\\ln k_s}^2)$ with $\\mu_{\\ln k_s} = \\ln(0.2)$ and $\\sigma_{\\ln k_s} = 0.5$.\n  - $\\beta \\sim \\text{Beta}(a_\\beta, b_\\beta)$ with $a_\\beta = 2$ and $b_\\beta = 2$.\n- Enforce the physical constraints $\\phi_0 \\ge \\phi_c \\ge 0$, $k_s  0$, and $\\beta \\in [0,1]$. If any constraint is violated, the logarithm of the posterior density must be $-\\infty$.\n\nData and likelihood:\n- Given a single dataset with known constant normal stress $\\sigma_n$ and cohesion $c$, and observed quantities for peak shear strength, critical shear strength, shear band orientation angle, and friction angle at $\\kappa_m$, assume independent Gaussian measurement errors for each observable with known standard deviations.\n- The dataset is:\n  - Normal stress $\\sigma_n = 100$ kilopascal.\n  - Cohesion $c = 2$ kilopascal.\n  - Accumulated equivalent plastic shear strain at which a friction angle measurement is available: $\\kappa_m = 0.1$ (dimensionless).\n  - Observed peak shear strength $\\tau_p^{\\text{obs}} = 72.0$ kilopascal with standard deviation $\\sigma_{\\tau} = 1.0$ kilopascal.\n  - Observed critical shear strength $\\tau_c^{\\text{obs}} = 62.1$ kilopascal with standard deviation $\\sigma_{\\tau} = 1.0$ kilopascal.\n  - Observed shear band orientation $\\theta_{\\text{sb}}^{\\text{obs}} = 55.5$ degrees with standard deviation $\\sigma_{\\theta} = 1.5$ degrees.\n  - Observed friction angle at $\\kappa_m$: $\\phi^{\\text{obs}}(\\kappa_m) = 33.43$ degrees with standard deviation $\\sigma_{\\phi} = 0.5$ degrees.\n- Construct the total log-likelihood as the sum of the natural logarithms of the four independent Gaussian densities for the differences between predictions and observations.\n\nTasks:\n- Starting from the stated fundamental bases, derive predictive relations for the four observables in terms of $(\\phi_0, \\phi_c, k_s, \\beta)$, $\\sigma_n$, $c$, and $\\kappa_m$.\n- Construct the log-prior using the independent priors specified.\n- Construct the log-posterior as the sum of the log-likelihood and the log-prior, subject to the physical constraints.\n\nTest suite:\n- Evaluate the log-posterior, in natural logarithm units, for each of the following four parameter vectors, with angles in degrees:\n  - Case A: $(\\phi_0, \\phi_c, k_s, \\beta) = (35.0, 31.0, 0.2, 0.2)$.\n  - Case B: $(\\phi_0, \\phi_c, k_s, \\beta) = (35.0, 31.0, 0.2, 0.8)$.\n  - Case C: $(\\phi_0, \\phi_c, k_s, \\beta) = (33.0, 33.0, 0.2, 0.2)$.\n  - Case D: $(\\phi_0, \\phi_c, k_s, \\beta) = (36.0, 28.0, 0.05, 0.1)$.\n\nUnits and output:\n- All angles must be treated in degrees, and all stresses in kilopascal. When trigonometric functions are applied, ensure correct conversion between degrees and radians.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order $\\text{[Case A, Case B, Case C, Case D]}$. Each entry must be a floating-point number representing the log-posterior value for that case in natural logarithm units.\n\nNo user input is required; all numerical values are provided above and must be hard-coded in your program. The program must be fully deterministic and self-contained.", "solution": "The objective is to compute the natural logarithm of the posterior probability density, denoted as $\\ln p(\\boldsymbol{\\theta} | \\mathbf{d})$, for a set of parameter vectors $\\boldsymbol{\\theta} = (\\phi_0, \\phi_c, k_s, \\beta)$, given a dataset of observations $\\mathbf{d}$. The parameters describe a strain-softening Mohr-Coulomb material.\n\nAccording to Bayes' theorem, the posterior probability is proportional to the product of the likelihood and the prior: $p(\\boldsymbol{\\theta} | \\mathbf{d}) \\propto p(\\mathbf{d} | \\boldsymbol{\\theta}) p(\\boldsymbol{\\theta})$. In logarithmic form, this is expressed as:\n$$\n\\ln p(\\boldsymbol{\\theta} | \\mathbf{d}) = \\ln p(\\mathbf{d} | \\boldsymbol{\\theta}) + \\ln p(\\boldsymbol{\\theta}) + C\n$$\nwhere $\\ln p(\\mathbf{d} | \\boldsymbol{\\theta})$ is the log-likelihood, $\\ln p(\\boldsymbol{\\theta})$ is the log-prior, and $C$ is a normalization constant that does not depend on $\\boldsymbol{\\theta}$ and can be ignored for the purpose of evaluating the unnormalized log-posterior. The calculation is subject to physical constraints on the parameters. If any constraint is violated, the log-posterior is defined to be $-\\infty$.\n\nFirst, we derive the predictive models for the observables based on the physics of the problem. All angular quantities ($\\phi$, $\\psi$, $\\theta$) are provided in degrees but must be converted to radians for trigonometric calculations. Let $\\phi_0$, $\\phi_c$, and $\\phi(\\kappa)$ be the friction angles in radians corresponding to the input peak, critical, and current friction angles in degrees.\n\nThe exponential softening law for the internal friction angle, $\\phi$, as a function of the accumulated equivalent plastic shear strain, $\\kappa$, is given by:\n$$\n\\phi(\\kappa) = \\phi_c + (\\phi_0 - \\phi_c) e^{-\\kappa/k_s}\n$$\nThe dilation angle, $\\psi(\\kappa)$, is related to the friction angle by the nonassociativity parameter $\\beta$:\n$$\n\\psi(\\kappa) = \\beta \\, \\phi(\\kappa)\n$$\n\nThe four observables are predicted as follows:\n1.  **Peak Shear Strength ($\\tau_p^{\\text{pred}}$)**: This occurs at the onset of plastic straining, $\\kappa=0$, where the friction angle is at its peak, $\\phi(0) = \\phi_0$. The Mohr-Coulomb strength criterion for a material with constant cohesion $c$ and under a constant normal stress $\\sigma_n$ gives:\n    $$\n    \\tau_p^{\\text{pred}} = c + \\sigma_n \\tan(\\phi_0)\n    $$\n2.  **Critical Shear Strength ($\\tau_c^{\\text{pred}}$)**: This corresponds to the residual strength at large strains, as $\\kappa \\to \\infty$. In this limit, the friction angle becomes $\\phi(\\infty) = \\phi_c$. The critical shear strength is thus:\n    $$\n    \\tau_c^{\\text{pred}} = c + \\sigma_n \\tan(\\phi_c)\n    $$\n3.  **Shear Band Orientation ($\\theta_{\\text{sb}}^{\\text{pred}}$)**: The orientation is determined at the onset of localization, which is taken to be at $\\kappa \\approx 0$. For a nonassociated material under plane strain, classical bifurcation theory predicts the shear band orientation $\\theta$ with respect to the major principal stress direction as:\n    $$\n    \\theta = \\frac{\\pi}{4} + \\frac{\\phi + \\psi}{4}\n    $$\n    At $\\kappa=0$, we have $\\phi = \\phi_0$ and $\\psi = \\psi(0) = \\beta \\phi_0$. The predicted orientation in radians is $\\theta_{\\text{sb,rad}}^{\\text{pred}} = \\frac{\\pi}{4} + \\frac{\\phi_0(1+\\beta)}{4}$. For comparison with the observed data in degrees, this is converted:\n    $$\n    \\theta_{\\text{sb}}^{\\text{pred}} = \\left( \\frac{\\pi}{4} + \\frac{\\phi_0(1+\\beta)}{4} \\right) \\frac{180}{\\pi}\n    $$\n4.  **Friction Angle at $\\kappa_m$ ($\\phi^{\\text{pred}}(\\kappa_m)$)**: This is a direct evaluation of the softening law at the specified strain $\\kappa_m = 0.1$. The prediction in radians is $\\phi_{\\text{rad}}^{\\text{pred}}(\\kappa_m) = \\phi_c + (\\phi_0 - \\phi_c) e^{-\\kappa_m/k_s}$. This is converted to degrees:\n    $$\n    \\phi^{\\text{pred}}(\\kappa_m) = \\left( \\phi_c + (\\phi_0 - \\phi_c) e^{-\\kappa_m/k_s} \\right) \\frac{180}{\\pi}\n    $$\n\nNext, we define the log-prior, $\\ln p(\\boldsymbol{\\theta})$. The parameters are assumed to be a priori independent, so the total log-prior is the sum of the individual log-priors:\n$$\n\\ln p(\\boldsymbol{\\theta}) = \\ln p(\\phi_0) + \\ln p(\\phi_c) + \\ln p(k_s) + \\ln p(\\beta)\n$$\nThe distributions are specified as:\n- $\\phi_0 \\sim \\mathcal{N}(\\mu_{\\phi_0}, \\sigma_{\\phi_0}^2)$ with $\\mu_{\\phi_0} = 35^\\circ$ and $\\sigma_{\\phi_0} = 5^\\circ$.\n- $\\phi_c \\sim \\mathcal{N}(\\mu_{\\phi_c}, \\sigma_{\\phi_c}^2)$ with $\\mu_{\\phi_c} = 30^\\circ$ and $\\sigma_{\\phi_c} = 5^\\circ$.\n- $k_s \\sim \\text{LogNormal}(\\mu_{\\ln k_s}, \\sigma_{\\ln k_s}^2)$ with $\\mu_{\\ln k_s} = \\ln(0.2)$ and $\\sigma_{\\ln k_s} = 0.5$.\n- $\\beta \\sim \\text{Beta}(a_\\beta, b_\\beta)$ with $a_\\beta = 2$ and $b_\\beta = 2$.\nThe log-prior is calculated by summing the log-probability density functions of these distributions evaluated at the given parameter values.\n\nThen, we construct the log-likelihood, $\\ln p(\\mathbf{d} | \\boldsymbol{\\theta})$. The measurement errors for the four observables are assumed to be independent and Gaussian. The total log-likelihood is the sum of the log-likelihoods for each observation:\n$$\n\\ln p(\\mathbf{d} | \\boldsymbol{\\theta}) = \\sum_{i=1}^{4} \\ln p(d_i | \\boldsymbol{\\theta})\n$$\nFor each observable $i$, with observation $d_i$, prediction $y_i(\\boldsymbol{\\theta})$, and measurement standard deviation $\\sigma_i$, the log-likelihood term is:\n$$\n\\ln p(d_i | \\boldsymbol{\\theta}) = -\\frac{1}{2} \\ln(2\\pi\\sigma_i^2) - \\frac{(d_i - y_i(\\boldsymbol{\\theta}))^2}{2\\sigma_i^2}\n$$\nThe specific observations and their uncertainties are:\n- $\\tau_p^{\\text{obs}} = 72.0$ kPa, $\\sigma_{\\tau} = 1.0$ kPa.\n- $\\tau_c^{\\text{obs}} = 62.1$ kPa, $\\sigma_{\\tau} = 1.0$ kPa.\n- $\\theta_{\\text{sb}}^{\\text{obs}} = 55.5^\\circ$, $\\sigma_{\\theta} = 1.5^\\circ$.\n- $\\phi^{\\text{obs}}(\\kappa_m) = 33.43^\\circ$, $\\sigma_{\\phi} = 0.5^\\circ$.\n\nFinally, the log-posterior is the sum of the log-prior and the log-likelihood. This entire calculation is conditional on the parameter vector satisfying the physical constraints: $\\phi_0 \\ge \\phi_c \\ge 0$, $k_s  0$, and $\\beta \\in [0,1]$. If these are not met, $\\ln p(\\boldsymbol{\\theta} | \\mathbf{d}) = -\\infty$. The following program implements this logic to evaluate the log-posterior for the specified test cases.", "answer": "```python\nimport numpy as np\nfrom scipy.stats import norm, lognorm, beta\n\ndef solve():\n    \"\"\"\n    Main function to compute and print the log-posterior values for the test cases.\n    \"\"\"\n\n    # --- Priors Configuration ---\n    # Mean and std dev for peak friction angle phi_0 (degrees)\n    mu_phi0, sigma_phi0 = 35.0, 5.0\n    # Mean and std dev for critical friction angle phi_c (degrees)\n    mu_phic, sigma_phic = 30.0, 5.0\n    # Parameters for lognormal distribution of k_s\n    # (mu and sigma of the underlying normal distribution for log(k_s))\n    mu_ln_ks, sigma_ln_ks = np.log(0.2), 0.5\n    # Shape parameters for Beta distribution of beta\n    a_beta, b_beta = 2.0, 2.0\n\n    # --- Data and Model Configuration ---\n    # Constant normal stress (kPa) and cohesion (kPa)\n    sigma_n, c = 100.0, 2.0\n    # Accumulated plastic strain for friction angle measurement\n    kappa_m = 0.1\n\n    # Observed data\n    tau_p_obs = 72.0  # Peak shear strength (kPa)\n    tau_c_obs = 62.1  # Critical shear strength (kPa)\n    theta_sb_obs = 55.5  # Shear band orientation (degrees)\n    phi_km_obs = 33.43  # Friction angle at kappa_m (degrees)\n\n    # Standard deviations of measurement errors\n    sigma_tau = 1.0  # For shear strengths (kPa)\n    sigma_theta = 1.5  # For orientation (degrees)\n    sigma_phi = 0.5  # For friction angle (degrees)\n\n    # --- Test Cases ---\n    # Parameter vectors (phi0_deg, phic_deg, ks, beta)\n    test_cases = [\n        (35.0, 31.0, 0.2, 0.2),  # Case A\n        (35.0, 31.0, 0.2, 0.8),  # Case B\n        (33.0, 33.0, 0.2, 0.2),  # Case C\n        (36.0, 28.0, 0.05, 0.1), # Case D\n    ]\n\n    def calculate_log_posterior(params):\n        \"\"\"\n        Calculates the natural logarithm of the posterior density for a given parameter vector.\n        \"\"\"\n        phi0_deg, phic_deg, ks, b = params\n\n        # 1. Check physical constraints\n        if not (phi0_deg >= phic_deg and phic_deg >= 0 and ks > 0 and 0 = b = 1):\n            return -np.inf\n\n        # 2. Calculate Log-Prior\n        log_prior_phi0 = norm.logpdf(phi0_deg, loc=mu_phi0, scale=sigma_phi0)\n        log_prior_phic = norm.logpdf(phic_deg, loc=mu_phic, scale=sigma_phic)\n        # scipy.stats.lognorm is parameterized by s=sigma and scale=exp(mu) for log(X)\n        log_prior_ks = lognorm.logpdf(ks, s=sigma_ln_ks, scale=np.exp(mu_ln_ks))\n        log_prior_beta = beta.logpdf(b, a=a_beta, b=b_beta)\n        \n        # Handle edge cases where logpdf can be -inf (e.g., beta at 0 or 1)\n        if any(np.isneginf([log_prior_phi0, log_prior_phic, log_prior_ks, log_prior_beta])):\n            return -np.inf\n            \n        total_log_prior = log_prior_phi0 + log_prior_phic + log_prior_ks + log_prior_beta\n\n        # 3. Calculate Model Predictions\n        # Convert angles from degrees to radians for calculations\n        phi0_rad = np.deg2rad(phi0_deg)\n        phic_rad = np.deg2rad(phic_deg)\n\n        # Peak shear strength\n        tau_p_pred = c + sigma_n * np.tan(phi0_rad)\n\n        # Critical shear strength\n        tau_c_pred = c + sigma_n * np.tan(phic_rad)\n\n        # Shear band orientation (result in degrees)\n        theta_sb_pred_rad = (np.pi / 4) + (phi0_rad * (1 + b)) / 4\n        theta_sb_pred = np.rad2deg(theta_sb_pred_rad)\n\n        # Friction angle at kappa_m (result in degrees)\n        phi_km_pred_rad = phic_rad + (phi0_rad - phic_rad) * np.exp(-kappa_m / ks)\n        phi_km_pred = np.rad2deg(phi_km_pred_rad)\n\n        # 4. Calculate Log-Likelihood\n        log_like_tau_p = norm.logpdf(tau_p_obs, loc=tau_p_pred, scale=sigma_tau)\n        log_like_tau_c = norm.logpdf(tau_c_obs, loc=tau_c_pred, scale=sigma_tau)\n        log_like_theta = norm.logpdf(theta_sb_obs, loc=theta_sb_pred, scale=sigma_theta)\n        log_like_phi_km = norm.logpdf(phi_km_obs, loc=phi_km_pred, scale=sigma_phi)\n\n        total_log_likelihood = log_like_tau_p + log_like_tau_c + log_like_theta + log_like_phi_km\n\n        # 5. Calculate Log-Posterior = Log-Prior + Log-Likelihood\n        log_posterior = total_log_prior + total_log_likelihood\n        \n        return log_posterior\n\n    results = [calculate_log_posterior(case) for case in test_cases]\n\n    # Format and print the final output\n    print(f\"[{','.join([f'{r:.8f}' for r in results])}]\")\n\nsolve()\n```", "id": "3529103"}]}