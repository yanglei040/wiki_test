{"hands_on_practices": [{"introduction": "The correct implementation of boundary loads is fundamental to any reliable finite element analysis. This practice delves into the application of Neumann (traction) boundary conditions by implementing a \"patch test,\" a critical verification tool that ensures an element formulation can reproduce constant stress states exactly [@problem_id:3504177]. You will compare the theoretically sound \"consistent\" traction vector with a simplified \"lumped\" vector, providing direct insight into the numerical accuracy of different load application schemes.", "problem": "You are asked to implement, from first principles, the assembly of boundary traction (Neumann) load vectors for a uniform traction on the boundary of a single isoparametric bilinear quadrilateral element (denoted as $\\text{Q4}$) in plane strain linear elasticity, and to compare the so-called consistent versus lumped edge traction vectors in their ability to reproduce a constant stress patch test in the sense of the principle of virtual work.\n\nBase your reasoning solely on the following fundamental and widely accepted facts:\n- The small-strain linear elasticity kinematics and constitutive law: the engineering strain vector $\\boldsymbol{\\varepsilon} = [\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy}]^{\\mathsf{T}}$ is related to the displacement field $\\boldsymbol{u} = [u, v]^{\\mathsf{T}}$ by $\\varepsilon_{xx} = \\partial u / \\partial x$, $\\varepsilon_{yy} = \\partial v / \\partial y$, and $\\gamma_{xy} = \\partial u / \\partial y + \\partial v / \\partial x$, and the Cauchy stress vector $\\boldsymbol{\\sigma} = [\\sigma_{xx}, \\sigma_{yy}, \\sigma_{xy}]^{\\mathsf{T}}$ is related to $\\boldsymbol{\\varepsilon}$ by a symmetric, positive-definite fourth-order tensor (for isotropic materials in plane strain, this specializes to the well-known matrix using Lamé parameters).\n- The standard Galerkin finite element method (Finite Element Method (FEM)) with isoparametric bilinear quadrilateral shape functions, exact $2 \\times 2$ Gaussian quadrature for stiffness integration, and exact $2$-point Gaussian quadrature for straight-edge line integrals of degree at most linear.\n- The principle of virtual work: for any admissible virtual displacement field, the internal virtual work balances the external virtual work, which, in the discrete setting, implies that for an exactly representable linear displacement field producing a constant stress state, the global internal nodal force vector $\\boldsymbol{f}_{\\mathrm{int}} = \\boldsymbol{K}\\boldsymbol{u}$ should match the assembled Neumann load vector $\\boldsymbol{f}_{\\mathrm{N}}$ if the latter is computed consistently.\n\nConstruct the following numerical experiment:\n- Consider a single rectangular element occupying $\\Omega = [0, L_x] \\times [0, L_y]$ with unit thickness $t = 1$. Use plane strain isotropic linear elasticity with Young’s modulus $E$ (in Pascal) and Poisson’s ratio $\\nu$ (dimensionless). The element nodes are ordered counterclockwise starting at the bottom-left corner, and the edges are the four straight sides of the rectangle.\n- Choose a target constant Cauchy stress vector $\\boldsymbol{\\sigma}_0 = [\\sigma_{xx}^0, \\sigma_{yy}^0, \\sigma_{xy}^0]^{\\mathsf{T}}$ (in Pascal), and compute the corresponding constant engineering strain vector $\\boldsymbol{\\varepsilon}_0$ by inverting the plane-strain constitutive matrix. From $\\boldsymbol{\\varepsilon}_0$, define the exact linear displacement field\n$$\nu(x,y) = \\varepsilon_{xx}^0 x + \\tfrac{1}{2}\\gamma_{xy}^0 y, \\quad\nv(x,y) = \\tfrac{1}{2}\\gamma_{xy}^0 x + \\varepsilon_{yy}^0 y\n$$\n  with zero rigid-body components. Evaluate the nodal displacement vector $\\boldsymbol{u}$ by sampling $\\boldsymbol{u}(x,y)$ at the element’s node coordinates.\n- Assemble the element stiffness matrix $\\boldsymbol{K}_e$ with exact $2 \\times 2$ Gaussian quadrature and the standard $\\text{Q4}$ strain-displacement matrix $\\boldsymbol{B}(\\xi,\\eta)$; then assemble the global stiffness $\\boldsymbol{K}$ (here, it coincides with $\\boldsymbol{K}_e$).\n- Assemble two versions of the global Neumann traction load vector over the entire boundary $\\partial\\Omega$ for the boundary traction field $\\boldsymbol{t} = \\boldsymbol{\\sigma}_0 \\boldsymbol{n}$, where $\\boldsymbol{n}$ is the outward unit normal:\n  1. The consistent version $\\boldsymbol{f}_{\\mathrm{N}}^{\\mathrm{cons}}$, computed by exact line integration of $\\boldsymbol{N}^{\\mathsf{T}}\\boldsymbol{t}$ using the element shape functions restricted to each edge and two-point Gaussian quadrature on every straight edge.\n  2. The lumped version $\\boldsymbol{f}_{\\mathrm{N}}^{\\mathrm{lump}}$, computed by first integrating the total edge force $\\int_{\\Gamma_e} \\boldsymbol{t}\\, \\mathrm{d}s$ on each boundary edge $\\Gamma_e$ and then distributing it equally to the two edge nodes (each node on the edge receives exactly one half of the total edge force).\n- Without solving any equilibrium system, evaluate the internal force vector $\\boldsymbol{f}_{\\mathrm{int}} = \\boldsymbol{K}\\boldsymbol{u}$ and the residuals\n$$\n\\boldsymbol{r}_{\\mathrm{cons}} = \\boldsymbol{K}\\boldsymbol{u} - \\boldsymbol{f}_{\\mathrm{N}}^{\\mathrm{cons}}, \\quad\n\\boldsymbol{r}_{\\mathrm{lump}} = \\boldsymbol{K}\\boldsymbol{u} - \\boldsymbol{f}_{\\mathrm{N}}^{\\mathrm{lump}}\n$$\n  Report the relative Euclidean norms\n$$\ne_{\\mathrm{cons}} = \\dfrac{\\|\\boldsymbol{r}_{\\mathrm{cons}}\\|_2}{\\|\\boldsymbol{f}_{\\mathrm{N}}^{\\mathrm{cons}}\\|_2}, \\quad\ne_{\\mathrm{lump}} = \\dfrac{\\|\\boldsymbol{r}_{\\mathrm{lump}}\\|_2}{\\|\\boldsymbol{f}_{\\mathrm{N}}^{\\mathrm{cons}}\\|_2}\n$$\n  These are dimensionless numbers. A value of $e_{\\mathrm{cons}}$ near machine precision indicates a passed constant-stress patch test, whereas $e_{\\mathrm{lump}}$ quantifies the error introduced by lumping.\n\nImplement the above for the following test suite of parameter sets, all in plane strain with unit thickness:\n- Test $1$: $E = 1000$, $\\nu = 0.25$, $L_x = 2.0$, $L_y = 1.0$, $\\boldsymbol{\\sigma}_0 = [5.0, 0.0, 0.0]^{\\mathsf{T}}$.\n- Test $2$: $E = 1000$, $\\nu = 0.25$, $L_x = 1.5$, $L_y = 0.8$, $\\boldsymbol{\\sigma}_0 = [0.0, 0.0, 4.0]^{\\mathsf{T}}$.\n- Test $3$: $E = 1000$, $\\nu = 0.25$, $L_x = 3.0$, $L_y = 0.5$, $\\boldsymbol{\\sigma}_0 = [2.0, -1.0, 3.0]^{\\mathsf{T}}$.\n\nAll moduli are in Pascal and all lengths are in meters. The outputs $e_{\\mathrm{cons}}$ and $e_{\\mathrm{lump}}$ are dimensionless and must be reported as decimal numbers.\n\nYour program should produce a single line of output containing the results as a comma-separated list of lists, where each inner list corresponds to one test in order and has the format `[e_cons, e_lump]`. For example, the output must look like\n`[[e_1_cons, e_1_lump],[e_2_cons, e_2_lump],[e_3_cons, e_3_lump]]`\nwith each `e` given as a floating-point decimal in standard notation. No additional text should be printed.", "solution": "## Problem Validation\n\n### Step 1: Extract Givens\n- **Element Type**: Isoparametric bilinear quadrilateral ($\\text{Q4}$) in plane strain.\n- **Element Geometry**: A single rectangular element occupying $\\Omega = [0, L_x] \\times [0, L_y]$ with unit thickness $t = 1$.\n- **Node Ordering**: Counterclockwise starting at the bottom-left corner $(0,0)$.\n- **Material Model**: Isotropic linear elasticity with Young’s modulus $E$ and Poisson’s ratio $\\nu$.\n- **Target State**: A constant Cauchy stress vector $\\boldsymbol{\\sigma}_0 = [\\sigma_{xx}^0, \\sigma_{yy}^0, \\sigma_{xy}^0]^{\\mathsf{T}}$.\n- **Exact Displacement Field**: The displacement field corresponding to $\\boldsymbol{\\sigma}_0$ (via the constant strain $\\boldsymbol{\\varepsilon}_0$) is given by $u(x,y) = \\varepsilon_{xx}^0 x + \\tfrac{1}{2}\\gamma_{xy}^0 y$ and $v(x,y) = \\tfrac{1}{2}\\gamma_{xy}^0 x + \\varepsilon_{yy}^0 y$.\n- **Nodal Displacements**: The vector $\\boldsymbol{u}$ is obtained by evaluating the exact displacement field at the four element nodes.\n- **Stiffness Matrix Assembly**: The element stiffness matrix $\\boldsymbol{K}_e$ is assembled using exact $2 \\times 2$ Gaussian quadrature. The global stiffness $\\boldsymbol{K}$ is identical to $\\boldsymbol{K}_e$.\n- **Boundary Traction**: The traction on the boundary $\\partial\\Omega$ is $\\boldsymbol{t} = \\boldsymbol{\\sigma}_0 \\boldsymbol{n}$, where $\\boldsymbol{n}$ is the outward unit normal.\n- **Consistent Load Vector ($\\boldsymbol{f}_{\\mathrm{N}}^{\\mathrm{cons}}$)**: Computed by integrating $\\boldsymbol{N}^{\\mathsf{T}}\\boldsymbol{t}$ over each edge using two-point Gaussian quadrature.\n- **Lumped Load Vector ($\\boldsymbol{f}_{\\mathrm{N}}^{\\mathrm{lump}}$)**: Computed by integrating the total force on each edge and distributing it equally (50/50) to the two edge nodes.\n- **Residuals**: $\\boldsymbol{r}_{\\mathrm{cons}} = \\boldsymbol{K}\\boldsymbol{u} - \\boldsymbol{f}_{\\mathrm{N}}^{\\mathrm{cons}}$ and $\\boldsymbol{r}_{\\mathrm{lump}} = \\boldsymbol{K}\\boldsymbol{u} - \\boldsymbol{f}_{\\mathrm{N}}^{\\mathrm{lump}}$.\n- **Error Metrics**: Relative Euclidean norms $e_{\\mathrm{cons}} = \\dfrac{\\|\\boldsymbol{r}_{\\mathrm{cons}}\\|_2}{\\|\\boldsymbol{f}_{\\mathrm{N}}^{\\mathrm{cons}}\\|_2}$ and $e_{\\mathrm{lump}} = \\dfrac{\\|\\boldsymbol{r}_{\\mathrm{lump}}\\|_2}{\\|\\boldsymbol{f}_{\\mathrm{N}}^{\\mathrm{cons}}\\|_2}$.\n- **Test Cases**:\n    1. $E = 1000$ Pa, $\\nu = 0.25$, $L_x = 2.0$ m, $L_y = 1.0$ m, $\\boldsymbol{\\sigma}_0 = [5.0, 0.0, 0.0]^{\\mathsf{T}}$ Pa.\n    2. $E = 1000$ Pa, $\\nu = 0.25$, $L_x = 1.5$ m, $L_y = 0.8$ m, $\\boldsymbol{\\sigma}_0 = [0.0, 0.0, 4.0]^{\\mathsf{T}}$ Pa.\n    3. $E = 1000$ Pa, $\\nu = 0.25$, $L_x = 3.0$ m, $L_y = 0.5$ m, $\\boldsymbol{\\sigma}_0 = [2.0, -1.0, 3.0]^{\\mathsf{T}}$ Pa.\n\n### Step 2: Validate Using Extracted Givens\n1.  **Scientifically Grounded**: The problem is based entirely on the foundational principles of the Finite Element Method (FEM) in solid mechanics. Linear elasticity, isoparametric elements, Gaussian quadrature, the principle of virtual work, and the patch test are all standard, well-established concepts. The equations provided are correct representations of these principles.\n2.  **Well-Posed**: The problem describes a deterministic numerical experiment. All required inputs and procedures are specified, leading to a unique numerical result for the requested error metrics.\n3.  **Objective**: The problem is stated in precise, formal, and unbiased technical language.\n4.  **Complete and Consistent**: All necessary parameters, boundary conditions, and numerical procedures are fully specified. There are no contradictions in the setup.\n5.  **Realistic and Feasible**: The parameters are physically plausible. The numerical procedure is standard and computationally feasible.\n\n### Step 3: Verdict and Action\nThe problem is valid. It constitutes a standard verification exercise in computational mechanics. A complete solution will be provided.\n\n## Solution\n\nThe objective is to perform a patch test on a single rectangular bilinear quadrilateral ($\\text{Q4}$) element to compare consistent and lumped Neumann load vectors. The core of the patch test is to verify that for a displacement field that the element can exactly represent, the internally generated nodal forces balance the externally applied nodal forces.\n\n### Theoretical Foundation\nThe principle of virtual work, in its discretized FEM form, states that the internal nodal force vector, $\\boldsymbol{f}_{\\mathrm{int}}$, must balance the external nodal force vector, $\\boldsymbol{f}_{\\mathrm{ext}}$, for the system to be in equilibrium. That is, $\\boldsymbol{f}_{\\mathrm{int}} = \\boldsymbol{f}_{\\mathrm{ext}}$.\nThe internal forces are calculated from the element stresses as $\\boldsymbol{f}_{\\mathrm{int}} = \\int_{\\Omega_e} \\boldsymbol{B}^{\\mathsf{T}}\\boldsymbol{\\sigma} \\, \\mathrm{d}V$, which is equivalent to $\\boldsymbol{f}_{\\mathrm{int}} = \\boldsymbol{K}\\boldsymbol{u}$ if the stress state $\\boldsymbol{\\sigma}$ is that induced by the nodal displacements $\\boldsymbol{u}$. The external forces due to boundary tractions are given by $\\boldsymbol{f}_{\\mathrm{N}} = \\int_{\\partial\\Omega_e} \\boldsymbol{N}^{\\mathsf{T}}\\boldsymbol{t} \\, \\mathrm{d}S$. A correctly formulated element must satisfy $\\boldsymbol{K}\\boldsymbol{u} = \\boldsymbol{f}_{\\mathrm{N}}$ when $\\boldsymbol{u}$ corresponds to a constant stress state and $\\boldsymbol{f}_{\\mathrm{N}}$ is computed consistently.\n\nA key aspect of this problem is the ability of the $\\text{Q4}$ element to reproduce the target state. The displacement field $u(x,y), v(x,y)$ corresponding to a constant strain (and thus constant stress) is linear in $x$ and $y$. A general bilinear isoparametric element can exactly represent any function of the form $f(x,y) = c_1 + c_2x + c_3y + c_4xy$. The target displacement field is purely linear, a subset of what the element can represent. Therefore, a rectangular $\\text{Q4}$ element can exactly interpolate the displacement field corresponding to any constant stress state. Furthermore, for a rectangular element, the element formulation correctly reproduces a constant strain state throughout the element domain, not just at the nodes.\n\nThe comparison hinges on two methods for computing the load vector $\\boldsymbol{f}_{\\mathrm{N}}$:\n\n1.  **Consistent Load Vector ($\\boldsymbol{f}_{\\mathrm{N}}^{\\mathrm{cons}}$)**: This vector is derived directly from the principle of virtual work by using the same shape functions for the force interpolation as for the displacement interpolation. The integral $\\int_{\\partial\\Omega} \\boldsymbol{N}^{\\mathsf{T}}\\boldsymbol{t} \\, \\mathrm{d}S$ is evaluated along each edge. For a straight edge and a constant traction vector $\\boldsymbol{t}$, the integral of the linear shape functions using a $2$-point Gaussian quadrature is exact and results in distributing the total edge force equally between the two nodes of the edge.\n\n2.  **Lumped Load Vector ($\\boldsymbol{f}_{\\mathrm{N}}^{\\mathrm{lump}}$)**: This is a simplified, ad-hoc method. The problem defines it as taking the total force on an edge, $\\boldsymbol{F}_{edge} = \\int_{\\Gamma_e} \\boldsymbol{t} \\, \\mathrm{d}S$, and allocating half to each of the two nodes on that edge.\n\nFor the specific case of a straight edge, linear ($\\text{Q4}$) shape functions, and a constant traction vector $\\boldsymbol{t}$ (which is the case here, since $\\boldsymbol{\\sigma}_0$ is constant and the element is a rectangle), the consistent load vector calculation yields the exact same 50/50 force distribution as the specified lumping scheme. Therefore, we predict that $\\boldsymbol{f}_{\\mathrm{N}}^{\\mathrm{cons}} = \\boldsymbol{f}_{\\mathrm{N}}^{\\mathrm{lump}}$ and consequently, the errors $e_{\\mathrm{cons}}$ and $e_{\\mathrm{lump}}$ should both be near machine precision, indicating that both methods pass the patch test under these idealized conditions. The error would arise for non-constant traction, curved boundaries, or higher-order elements.\n\n### Algorithmic Implementation Steps\n\n1.  **Setup**: For each test case, define the material properties ($E, \\nu$), geometry ($L_x, L_y$), and target stress ($\\boldsymbol{\\sigma}_0$). Set the thickness $t=1$. Define the physical coordinates of the four nodes.\n\n2.  **Constitutive Matrix**: Compute the $3 \\times 3$ plane strain constitutive matrix $\\boldsymbol{D}$.\n    $$ \\boldsymbol{D} = \\frac{E}{(1+\\nu)(1-2\\nu)} \\begin{bmatrix} 1-\\nu & \\nu & 0 \\\\ \\nu & 1-\\nu & 0 \\\\ 0 & 0 & \\frac{1-2\\nu}{2} \\end{bmatrix} $$\n\n3.  **Nodal Displacements**: Calculate the target constant strain vector $\\boldsymbol{\\varepsilon}_0 = \\boldsymbol{D}^{-1}\\boldsymbol{\\sigma}_0$. Use $\\boldsymbol{\\varepsilon}_0$ to find the nodal displacement vector $\\boldsymbol{u}$ by sampling the exact linear displacement field at the four node coordinates.\n\n4.  **Stiffness Matrix ($\\boldsymbol{K}$)**: Assemble the $8 \\times 8$ element stiffness matrix by numerically integrating $\\boldsymbol{B}^{\\mathsf{T}}\\boldsymbol{D}\\boldsymbol{B}$ over the element area using $2 \\times 2$ Gaussian quadrature. The strain-displacement matrix $\\boldsymbol{B}(\\xi, \\eta)$ is a function of the parent coordinates $(\\xi, \\eta)$ and is derived from the spatial derivatives of the shape functions. For a rectangular element, the Jacobian of the isoparametric mapping is constant, simplifying the calculation.\n    $$ \\boldsymbol{K}_e = \\int_{-1}^{1}\\int_{-1}^{1} \\boldsymbol{B}(\\xi,\\eta)^{\\mathsf{T}} \\boldsymbol{D} \\boldsymbol{B}(\\xi,\\eta) \\, t \\, \\det(\\boldsymbol{J}) \\, \\mathrm{d}\\xi \\mathrm{d}\\eta $$\n\n5.  **Internal Forces**: Compute the internal nodal force vector $\\boldsymbol{f}_{\\mathrm{int}} = \\boldsymbol{K}\\boldsymbol{u}$.\n\n6.  **Load Vectors**:\n    *   **Consistent ($\\boldsymbol{f}_{\\mathrm{N}}^{\\mathrm{cons}}$)**: Assemble by summing the contributions from each of the four boundary edges. For each edge, integrate $\\boldsymbol{N}^{\\mathsf{T}}\\boldsymbol{t}$ using a $2$-point Gaussian quadrature line integral. The traction $\\boldsymbol{t}$ is constant along each edge.\n    *   **Lumped ($\\boldsymbol{f}_{\\mathrm{N}}^{\\mathrm{lump}}$)**: Assemble by summing contributions from each edge. For each edge, calculate the total force vector and add half of it to the degrees of freedom of each of the two nodes on that edge.\n\n7.  **Error Calculation**: Compute the residuals $\\boldsymbol{r}_{\\mathrm{cons}}$ and $\\boldsymbol{r}_{\\mathrm{lump}}$ and their relative norms $e_{\\mathrm{cons}}$ and $e_{\\mathrm{lump}}$ as specified in the problem.\n\nThe following Python program implements this procedure for the given test suite.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a patch test for a single Q4 element to compare consistent\n    and lumped Neumann boundary load vectors.\n    \"\"\"\n    test_cases = [\n        # (E, nu, Lx, Ly, sigma0)\n        (1000.0, 0.25, 2.0, 1.0, np.array([5.0, 0.0, 0.0])),\n        (1000.0, 0.25, 1.5, 0.8, np.array([0.0, 0.0, 4.0])),\n        (1000.0, 0.25, 3.0, 0.5, np.array([2.0, -1.0, 3.0])),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_patch_test(case)\n        results.append(result)\n\n    # Format the flot numbers in the output string representation\n    formatted_results = []\n    for res_pair in results:\n        formatted_pair = f'[{res_pair[0]:.17e}, {res_pair[1]:.17e}]'\n        formatted_results.append(formatted_pair)\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\ndef run_patch_test(test_case):\n    \"\"\"\n    Executes the patch test logic for a single parameter set.\n    \"\"\"\n    E, nu, Lx, Ly, sigma0 = test_case\n    t = 1.0  # Unit thickness\n\n    # 1. Material and Geometry Setup\n    node_coords = np.array([\n        [0.0, 0.0],\n        [Lx, 0.0],\n        [Lx, Ly],\n        [0.0, Ly]\n    ])\n\n    # 2. Constitutive Matrix (D) for Plane Strain\n    factor = E / ((1.0 + nu) * (1.0 - 2.0 * nu))\n    D = factor * np.array([\n        [1.0 - nu, nu, 0.0],\n        [nu, 1.0 - nu, 0.0],\n        [0.0, 0.0, (1.0 - 2.0 * nu) / 2.0]\n    ])\n\n    # 3. Target Strain and Nodal Displacements\n    D_inv = np.linalg.inv(D)\n    eps0 = D_inv @ sigma0\n    eps_xx, eps_yy, gam_xy = eps0\n\n    u_nodes = np.zeros(8)\n    for i in range(4):\n        x, y = node_coords[i]\n        u_nodes[2 * i] = eps_xx * x + 0.5 * gam_xy * y\n        u_nodes[2 * i + 1] = 0.5 * gam_xy * x + eps_yy * y\n\n    # 4. Stiffness Matrix Assembly (K)\n    K = np.zeros((8, 8))\n    detJ = (Lx / 2.0) * (Ly / 2.0)\n    \n    gauss_points = [-1.0 / np.sqrt(3.0), 1.0 / np.sqrt(3.0)]\n    weights = [1.0, 1.0]\n    parent_coords = np.array([[-1., -1.], [1., -1.], [1., 1.], [-1., 1.]])\n\n    for i, xi in enumerate(gauss_points):\n        for j, eta in enumerate(gauss_points):\n            B = np.zeros((3, 8))\n            for n in range(4):\n                xi_n, eta_n = parent_coords[n]\n                dN_dxi = 0.25 * xi_n * (1.0 + eta_n * eta)\n                dN_deta = 0.25 * eta_n * (1.0 + xi_n * xi)\n                dN_dx = (2.0 / Lx) * dN_dxi\n                dN_dy = (2.0 / Ly) * dN_deta\n                \n                B[0, 2 * n] = dN_dx\n                B[1, 2 * n + 1] = dN_dy\n                B[2, 2 * n] = dN_dy\n                B[2, 2 * n + 1] = dN_dx\n            \n            K += B.T @ D @ B * detJ * weights[i] * weights[j] * t\n\n    # 5. Internal Force Vector\n    f_int = K @ u_nodes\n\n    # 6. Neumann Load Vector Assembly\n    f_cons = np.zeros(8)\n    f_lump = np.zeros(8)\n    sigma_mat = np.array([[sigma0[0], sigma0[2]], [sigma0[2], sigma0[1]]])\n    \n    edges = [\n        (0, 1, np.array([0.0, -1.0]), Lx), # Bottom\n        (1, 2, np.array([1.0, 0.0]), Ly),  # Right\n        (2, 3, np.array([0.0, 1.0]), Lx),  # Top\n        (3, 0, np.array([-1.0, 0.0]), Ly)  # Left\n    ]\n\n    for n1_idx, n2_idx, normal, length in edges:\n        traction = sigma_mat @ normal\n        total_force_edge = traction * length * t\n        \n        # Lumped vector\n        f_lump[2 * n1_idx: 2 * n1_idx + 2] += 0.5 * total_force_edge\n        f_lump[2 * n2_idx: 2 * n2_idx + 2] += 0.5 * total_force_edge\n\n        # Consistent vector (using 2-point Gauss quadrature on edge)\n        detJ_line = length / 2.0\n        for k, s in enumerate(gauss_points): # s is local coord on edge [-1, 1]\n            wk = weights[k]\n            N1_edge = 0.5 * (1.0 - s)\n            N2_edge = 0.5 * (1.0 + s)\n            \n            # Add contribution to node 1 of the edge\n            f_cons[2 * n1_idx: 2 * n1_idx + 2] += (N1_edge * traction) * detJ_line * wk * t\n            # Add contribution to node 2 of the edge\n            f_cons[2 * n2_idx: 2 * n2_idx + 2] += (N2_edge * traction) * detJ_line * wk * t\n            \n    # 7. Residual and Error Calculation\n    r_cons = f_int - f_cons\n    r_lump = f_int - f_lump\n\n    norm_f_cons = np.linalg.norm(f_cons)\n    \n    if norm_f_cons < 1e-15:\n        e_cons = np.linalg.norm(r_cons)\n        e_lump = np.linalg.norm(r_lump)\n    else:\n        e_cons = np.linalg.norm(r_cons) / norm_f_cons\n        e_lump = np.linalg.norm(r_lump) / norm_f_cons\n\n    return [e_cons, e_lump]\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3504177"}, {"introduction": "While Neumann conditions are handled naturally by the weak form, Dirichlet (displacement) conditions require special enforcement techniques. This exercise introduces the penalty method, an intuitive and widely used approach that approximates a fixed displacement by adding a \"stiff spring\" to the constrained degree of freedom [@problem_id:3504185]. Through this implementation, you will investigate the crucial relationship between the penalty parameter, mesh refinement, and solution accuracy, a key practical skill in computational mechanics.", "problem": "A one-dimensional linearly elastic bar occupies the interval $[0,L]$ with constant cross-sectional area $A$ and Young's modulus $E$. The unknown axial displacement field is $u(x)$. The strong form of equilibrium for a body-force-free bar is $ \\dfrac{d}{dx}\\left(EA \\dfrac{du}{dx}\\right)=0 $ for $x\\in(0,L)$, with a Dirichlet boundary condition prescribed at $x=0$ as $u(0)=\\bar u$ and a Neumann boundary condition prescribed at $x=L$ as $EA\\,u'(L)=\\bar N$. Starting from the Principle of Virtual Work (PVW) and basic finite element interpolation with linear shape functions, derive the weak form that incorporates the Dirichlet boundary condition via the penalty method and the Neumann boundary condition in its natural form. Carefully justify the scaling of the penalty parameter with mesh size.\n\nImplement a program that assembles the global stiffness matrix and load vector for a uniform mesh of $N$ linear elements on $[0,L]$, imposes $u(0)=\\bar u$ via a penalty term with penalty parameter $\\beta$, imposes the traction at $x=L$ as a natural boundary term, and solves the resulting linear system for the nodal displacements. For the penalty parameter, use the mesh-dependent scaling $\\beta=\\alpha\\,EA/h$, where $h=L/N$ and $\\alpha>0$ is a dimensionless tuning parameter. For each test case, compute the absolute boundary displacement error $e_0=\\lvert u_h(0)-\\bar u\\rvert$ in meters, where $u_h(0)$ is the finite element approximation at $x=0$.\n\nUse the following physically and numerically realistic parameters common in computational geomechanics: $E=50\\times 10^6$ pascals, $A=1.0$ square meters, $L=10.0$ meters, $\\bar N=1.0\\times 10^5$ newtons, and $\\bar u=0.0$ meters. These values correspond to a stiff geomaterial bar with a moderate axial end load, and the exact analytical solution under these boundary conditions is $u(x)=\\dfrac{\\bar N}{EA}\\,x$, which satisfies $u(0)=0$ and $EA\\,u'(L)=\\bar N$.\n\nThe program must evaluate the following test suite of $(\\alpha,N)$ pairs to assess both penalty magnitude and mesh refinement effects:\n- $(\\alpha,N)=\\left(10^{-2},5\\right)$,\n- $(\\alpha,N)=\\left(10^{-2},20\\right)$,\n- $(\\alpha,N)=\\left(10^{-2},80\\right)$,\n- $(\\alpha,N)=\\left(10^{0},5\\right)$,\n- $(\\alpha,N)=\\left(10^{0},20\\right)$,\n- $(\\alpha,N)=\\left(10^{0},80\\right)$,\n- $(\\alpha,N)=\\left(10^{2},5\\right)$,\n- $(\\alpha,N)=\\left(10^{2},20\\right)$,\n- $(\\alpha,N)=\\left(10^{2},80\\right)$.\n\nFor each test case, compute and return the single scalar $e_0$ in meters. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[\\text{result}_1,\\text{result}_2,\\dots,\\text{result}_9]$). All displacement errors must be expressed in meters (m) as floating-point numbers on this single output line in the specified order of the test suite.", "solution": "The problem statement is complete, scientifically sound, and well-posed. It presents a standard problem in one-dimensional computational solid mechanics, requiring the derivation and implementation of the finite element method for a linearly elastic bar with mixed boundary conditions. The physical parameters and numerical methods are standard and appropriate for the field of computational geomechanics. We may therefore proceed with the solution.\n\nThe solution begins with the Principle of Virtual Work (PVW), which provides the integral-based weak form of the equilibrium problem. For a one-dimensional bar in the absence of body forces, the PVW states that the internal virtual work must equal the external virtual work for any kinematically admissible virtual displacement field $\\delta u(x)$.\n\nThe internal virtual work is the integral of the virtual strain energy density over the domain:\n$$ \\delta W_{int} = \\int_{0}^{L} \\sigma(x) \\delta\\epsilon(x) A \\,dx $$\nHere, $\\sigma(x)$ is the axial stress, $\\delta\\epsilon(x)$ is the virtual axial strain, and $A$ is the constant cross-sectional area. The domain is the interval $[0, L]$.\n\nThe external virtual work is the work done by applied external forces through the virtual displacements. In this problem, the only external force is the point load $\\bar N$ applied at $x=L$. Therefore, the external virtual work is:\n$$ \\delta W_{ext} = \\bar N \\delta u(L) $$\n\nThe constitutive relation for linear elasticity is $\\sigma(x) = E \\epsilon(x)$, where $E$ is Young's modulus. The strain-displacement kinematic relation is $\\epsilon(x) = \\dfrac{du}{dx}$. The virtual strain is similarly related to the virtual displacement: $\\delta\\epsilon(x) = \\dfrac{d(\\delta u)}{dx}$.\n\nSubstituting these relations into the PVW statement ($\\delta W_{int} = \\delta W_{ext}$) yields the weak form of the equilibrium equation:\nFind $u(x)$ such that $u(0)=\\bar u$ and for all admissible virtual displacements $\\delta u(x)$ (where $\\delta u(0) = 0$ in a classical Galerkin formulation):\n$$ \\int_{0}^{L} EA \\dfrac{du}{dx} \\dfrac{d(\\delta u)}{dx} \\,dx = \\bar N \\delta u(L) $$\nThis equation is the foundation for our finite element formulation. The Neumann boundary condition $EA u'(L) = \\bar N$ is incorporated naturally into the weak form as a work term on the right-hand side, which is why it is termed a natural boundary condition. The Dirichlet boundary condition $u(0)=\\bar u$ is an essential boundary condition that must be imposed separately.\n\nTo solve this problem numerically, we employ the finite element method. The domain $[0,L]$ is discretized into $N$ linear elements of equal length $h = L/N$. The total number of nodes is $n_{nodes} = N+1$. Within each element $e$, spanning from global coordinates $x_i$ to $x_{i+1}$, the displacement field $u^{(e)}(x)$ is approximated using linear shape functions $N_i(x)$ and nodal displacements $d_i$:\n$$ u^{(e)}(x) = N_i(x) d_i + N_{i+1}(x) d_{i+1} $$\nSimilarly, the virtual displacement is approximated as:\n$$ \\delta u^{(e)}(x) = N_i(x) \\delta d_i + N_{i+1}(x) \\delta d_{i+1} $$\nThe strain within the element is found by differentiating the displacement approximation:\n$$ \\dfrac{du^{(e)}}{dx} = \\dfrac{dN_i}{dx} d_i + \\dfrac{dN_{i+1}}{dx} d_{i+1} = \\dfrac{1}{h} \\begin{bmatrix} -1 & 1 \\end{bmatrix} \\begin{Bmatrix} d_i \\\\ d_{i+1} \\end{Bmatrix} = \\mathbf{B}^{(e)} \\mathbf{d}^{(e)} $$\nHere, $\\mathbf{B}^{(e)}$ is the strain-displacement matrix for the element.\n\nThe weak form integral is computed as a sum over all elements. For a single element $e$, the contribution to the internal virtual work is:\n$$ (\\delta\\mathbf{d}^{(e)})^T \\left( \\int_{x_i}^{x_{i+1}} (\\mathbf{B}^{(e)})^T EA \\mathbf{B}^{(e)} \\,dx \\right) \\mathbf{d}^{(e)} = (\\delta\\mathbf{d}^{(e)})^T \\mathbf{k}^{(e)} \\mathbf{d}^{(e)} $$\nThe term $\\mathbf{k}^{(e)}$ is the element stiffness matrix. Since $\\mathbf{B}^{(e)}$, $E$, and $A$ are constant within the element, the integral is straightforward:\n$$ \\mathbf{k}^{(e)} = \\int_{0}^{h} \\left(\\dfrac{EA}{h^2} \\begin{bmatrix} 1 & -1 \\\\ -1 & 1 \\end{bmatrix}\\right) dx' = \\dfrac{EA}{h} \\begin{bmatrix} 1 & -1 \\\\ -1 & 1 \\end{bmatrix} $$\nThe element stiffness matrices are assembled into a global $(N+1) \\times (N+1)$ stiffness matrix $\\mathbf{K}$. The global system of equations before imposing boundary conditions is $\\mathbf{K}\\mathbf{d} = \\mathbf{F}$, where $\\mathbf{d}$ is the vector of global nodal displacements and $\\mathbf{F}$ is the global force vector. The natural boundary condition at $x=L$ (node $N$) contributes $\\bar N$ to the $N$-th component of $\\mathbf{F}$.\n\nThe Dirichlet condition $u(0)=\\bar u$, or $d_0=\\bar u$, is imposed using the penalty method. This method modifies the total potential energy $\\Pi$ of the system by adding a penalty term:\n$$ \\Pi_{pen} = \\Pi + \\dfrac{1}{2} \\beta (u(0) - \\bar u)^2 = \\dfrac{1}{2} \\int_{0}^{L} EA \\left(\\dfrac{du}{dx}\\right)^2 dx - \\bar N u(L) + \\dfrac{1}{2} \\beta (u(0) - \\bar u)^2 $$\nwhere $\\beta \\gg 0$ is the penalty parameter. Taking the variation of $\\Pi_{pen}$ and setting it to zero ($\\delta \\Pi_{pen}=0$) gives the modified weak form:\n$$ \\int_{0}^{L} EA \\dfrac{du}{dx} \\dfrac{d(\\delta u)}{dx} \\,dx + \\beta (u(0)-\\bar u)\\delta u(0) = \\bar N \\delta u(L) $$\nIn the discrete system, this modification affects the equations for node $0$:\n$$ (\\mathbf{K}\\mathbf{d})_0 + \\beta (d_0 - \\bar u) = F_0 $$\nThis is implemented by adding $\\beta$ to the diagonal stiffness term $K_{0,0}$ and adding $\\beta \\bar u$ to the force term $F_0$. The modified system of equations $\\mathbf{K}_{pen}\\mathbf{d} = \\mathbf{F}_{pen}$ is:\n$$ K_{0,0} \\rightarrow K_{0,0} + \\beta $$\n$$ F_0 \\rightarrow F_0 + \\beta\\bar u $$\nThe problem specifies the scaling for the penalty parameter as $\\beta = \\alpha \\dfrac{EA}{h}$. The physical stiffness at node $0$ is dominated by the contribution from the first element, $K_{0,0} = \\dfrac{EA}{h}$. The modified stiffness term becomes $K'_{0,0} = \\dfrac{EA}{h} + \\alpha \\dfrac{EA}{h} = (1+\\alpha)\\dfrac{EA}{h}$. This scaling ensures that the ratio of the penalty stiffness to the physical stiffness is given by the dimensionless parameter $\\alpha$. It makes the choice of the penalty strength independent of mesh size $h$. For the method to be effective, $\\alpha$ should be large enough (e.g., $\\alpha \\gg 1$) to enforce the constraint accurately, but not so large as to cause numerical ill-conditioning of the matrix $\\mathbf{K}_{pen}$.\n\nThe algorithm to be implemented is as follows:\n1.  For each test case $(\\alpha, N)$, define the mesh parameters: $h=L/N$ and $n_{nodes}=N+1$.\n2.  Calculate the penalty parameter $\\beta = \\alpha\\,EA/h$.\n3.  Initialize the global stiffness matrix $\\mathbf{K}$ of size $(N+1) \\times (N+1)$ and the global force vector $\\mathbf{F}$ of size $(N+1)$ to zeros.\n4.  Compute the element stiffness matrix $\\mathbf{k}^{(e)} = \\dfrac{EA}{h} \\begin{bmatrix} 1 & -1 \\\\ -1 & 1 \\end{bmatrix}$.\n5.  Assemble $\\mathbf{K}$ by iterating through all $N$ elements and adding their contributions to the global matrix.\n6.  Apply the natural boundary condition by setting the last component of the force vector, $F_N = \\bar N$.\n7.  Apply the penalty Dirichlet boundary condition by modifying the first row/column of the system: $K_{0,0} \\leftarrow K_{0,0} + \\beta$ and $F_0 \\leftarrow F_0 + \\beta\\bar u$.\n8.  Solve the linear system $\\mathbf{K}\\mathbf{d} = \\mathbf{F}$ for the nodal displacement vector $\\mathbf{d}$.\n9.  Calculate the boundary displacement error $e_0 = |d_0 - \\bar u|$. Since $\\bar u=0.0$, this is simply $e_0 = |d_0|$.\n10. Store the result and repeat for all test cases.\n\nLet's specify the parameters for computation:\n- Young's Modulus: $E = 50 \\times 10^6$ Pa\n- Cross-sectional Area: $A = 1.0$ m$^2$\n- Bar Length: $L = 10.0$ m\n- Prescribed Displacement: $\\bar u = 0.0$ m\n- Prescribed Force: $\\bar N = 1.0 \\times 10^5$ N\n- Test Suite: $(\\alpha, N)$ pairs are $\\left(10^{-2},5\\right)$, $\\left(10^{-2},20\\right)$, $\\left(10^{-2},80\\right)$, $\\left(10^{0},5\\right)$, $\\left(10^{0},20\\right)$, $\\left(10^{0},80\\right)$, $\\left(10^{2},5\\right)$, $\\left(10^{2},20\\right)$, and $\\left(10^{2},80\\right)$.\nThe computation will yield nine values for the error $e_0$, which will be reported in the specified format. The analytical solution for the exact displacement $u(x) = \\dfrac{\\bar N}{EA}x$ confirms that $u(0)=0$, so any non-zero value of $u_h(0)$ is due to the approximation error of the penalty method.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No scipy needed, numpy.linalg.solve is sufficient.\n\ndef solve():\n    \"\"\"\n    Solves the 1D elastic bar problem using the Finite Element Method \n    with penalty imposition of Dirichlet boundary conditions.\n    \"\"\"\n\n    # Define physical and material parameters from the problem statement\n    E = 50.0e6  # Young's modulus in Pascals (Pa)\n    A = 1.0     # Cross-sectional area in square meters (m^2)\n    L = 10.0    # Length of the bar in meters (m)\n    N_bar = 1.0e5 # Applied axial force at x=L in Newtons (N)\n    u_bar = 0.0   # Prescribed displacement at x=0 in meters (m)\n\n    # Define the test suite of (alpha, N) pairs\n    test_cases = [\n        (1e-2, 5),\n        (1e-2, 20),\n        (1e-2, 80),\n        (1e0, 5),\n        (1e0, 20),\n        (1e0, 80),\n        (1e2, 5),\n        (1e2, 20),\n        (1e2, 80),\n    ]\n\n    results = []\n    for alpha, N in test_cases:\n        # 1. Preprocessing and Mesh Definition\n        h = L / N                  # Element length\n        num_nodes = N + 1          # Number of nodes\n        \n        # 2. Calculate Penalty Parameter\n        # As per the problem, beta = alpha * E * A / h\n        beta = alpha * E * A / h\n\n        # 3. Element Stiffness Matrix Calculation\n        # For a 1D linear bar element, k_e = (EA/h) * [[1, -1], [-1, 1]]\n        elem_stiffness = (E * A / h) * np.array([[1.0, -1.0], [-1.0, 1.0]])\n\n        # 4. Assembly of Global Stiffness Matrix and Force Vector\n        # Initialize global matrix and vector with zeros\n        K = np.zeros((num_nodes, num_nodes))\n        F = np.zeros(num_nodes)\n\n        # Assemble the stiffness matrix by looping through elements\n        for i in range(N):\n            # Global indices for the element connecting nodes i and i+1\n            g_indices = [i, i + 1]\n            # Add element stiffness contribution to the global matrix\n            K[np.ix_(g_indices, g_indices)] += elem_stiffness\n\n        # 5. Application of Boundary Conditions\n        # a) Natural Boundary Condition (Neumann)\n        # Add the point load N_bar to the last node's force component.\n        F[N] += N_bar\n\n        # b) Essential Boundary Condition (Dirichlet) via Penalty Method\n        # Modify the stiffness and force for the constrained DOF (node 0)\n        # K_00 = K_00 + beta\n        K[0, 0] += beta\n        # F_0 = F_0 + beta * u_bar\n        F[0] += beta * u_bar\n\n        # 6. Solve the Linear System\n        # Solve Kd = F for the nodal displacement vector d\n        d = np.linalg.solve(K, F)\n\n        # 7. Post-processing: Calculate Error\n        # The FEA displacement at x=0 is the first component of the solution vector.\n        u_h_at_0 = d[0]\n        # Calculate the absolute boundary displacement error.\n        e0 = abs(u_h_at_0 - u_bar)\n\n        results.append(e0)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3504185"}, {"introduction": "Building on the basic penalty method, this advanced practice explores more sophisticated and rigorous techniques for enforcing Dirichlet boundary conditions. You will implement and compare the penalty method, the Lagrange multiplier method, and Nitsche’s method within the context of a 1D consolidation problem [@problem_id:3504268]. By evaluating each method based on a physically meaningful metric—the global conservation of mass—you will gain a deeper understanding of their relative accuracy, stability, and theoretical underpinnings.", "problem": "Consider one-dimensional small-strain Biot consolidation in a rigid skeleton limit, so that the fluid pressure field is governed by a diffusion-type Partial Differential Equation (PDE) derived from fluid mass balance and Darcy’s law. Let the spatial domain be $x \\in [0,L]$, with $L$ in meters. The governing equation for the fluid pressure $p(x,t)$ is\n$$\nS \\, \\frac{\\partial p}{\\partial t}(x,t) - \\frac{\\partial}{\\partial x}\\!\\left( K \\, \\frac{\\partial p}{\\partial x}(x,t) \\right) = 0,\n$$\nwhere $S$ is the storativity (with unit $\\mathrm{Pa}^{-1}$) and $K = k/\\mu$ is the hydraulic diffusivity factor (permeability divided by dynamic viscosity, with unit $\\mathrm{m}^2/(\\mathrm{Pa}\\cdot\\mathrm{s})$). The initial condition is uniform $p(x,0) = p_0$ with $p_0$ in pascals. The left boundary $x=0$ is no-flow (homogeneous Neumann), and the right boundary $x=L$ is drained (Dirichlet), i.e., $p(L,t)=0$. The drained boundary is to be imposed by one of three weak-enforcement strategies: penalty, Lagrange multiplier, and Nitsche’s method.\n\nStarting from the weak form obtained by multiplying the PDE by a test function $w(x)$ and integrating over the domain $[0,L]$,\n$$\n\\int_0^L S \\, w \\, \\frac{\\partial p}{\\partial t} \\, dx + \\int_0^L K \\, \\frac{\\partial w}{\\partial x} \\, \\frac{\\partial p}{\\partial x} \\, dx - w(0) \\, q_N(0,t) - w(L) \\, q_N(L,t) = 0,\n$$\nwith $q_N(x,t)$ denoting the prescribed normal flux, derive a semi-discrete spatial approximation using the Finite Element Method (FEM) with linear (two-node) elements, uniform mesh of $N_e$ elements and $N_n=N_e+1$ nodes, and piecewise linear trial and test functions on each element. Use backward Euler time integration with constant time step $\\Delta t$ to obtain a fully discrete system at each time step. Enforce the drained boundary condition $p(L,t)=0$ by each of the following methods:\n\n1) Penalty method: Add a boundary penalty term proportional to $(p(L,t) - p_D)$ with $p_D=0$, scaled by a dimensionless stabilization parameter $\\gamma_p$ as $\\gamma_p \\, K/h$, where $h$ is the element size of the last element adjacent to $x=L$.\n\n2) Lagrange multiplier method: Impose the constraint $p(L,t)=p_D$ by augmenting the discrete system with a constraint equation using a Lagrange multiplier. Optionally use an augmented Lagrangian regularization adding $\\beta \\, K/h$ on the diagonal of the drained boundary degree of freedom, where $\\beta$ is a dimensionless stabilization parameter (set $\\beta=0$ for the pure Lagrange multiplier and $\\beta>0$ for the augmented variant).\n\n3) Nitsche’s method: Use the symmetric Nitsche formulation on the drained boundary with stabilization parameter $\\gamma_N$ (dimensionless), adding the consistent terms\n$$\n- \\int_{\\Gamma_D} w \\, (n \\cdot K \\nabla p) \\, ds - \\int_{\\Gamma_D} (n \\cdot K \\nabla w) \\, (p - p_D) \\, ds\n$$\nand a penalty term\n$$\n\\int_{\\Gamma_D} \\gamma_N \\, \\frac{K}{h} \\, w \\, (p - p_D) \\, ds,\n$$\nwhere $n$ is the outward unit normal and $\\Gamma_D=\\{x=L\\}$ in one dimension.\n\nLet the physical parameters be $L = 1\\,\\mathrm{m}$, $S = 1.0\\times 10^{-9}\\,\\mathrm{Pa}^{-1}$, $K = 1.0\\times 10^{-6}\\,\\mathrm{m}^2/(\\mathrm{Pa}\\cdot\\mathrm{s})$, $p_0 = 1.0\\times 10^{5}\\,\\mathrm{Pa}$, and a uniform mesh with $N_e = 40$ so that $h = L/N_e$. Use backward Euler with $\\Delta t = 10\\,\\mathrm{s}$ for a final time $T = 1000\\,\\mathrm{s}$ (i.e., $N_t = T/\\Delta t$ steps).\n\nDefine the total fluid content per unit cross-sectional area at time $t$ as\n$$\nM(t) = S \\int_0^L p(x,t)\\, dx,\n$$\nwhich in the finite element discretization equals $M(t) \\approx \\mathbf{1}^\\top \\mathbf{M}\\, \\mathbf{p}(t)$, where $\\mathbf{M}$ is the consistent mass matrix and $\\mathbf{p}(t)$ is the vector of nodal pressures. Define the outward flux at the drained boundary by Darcy’s law as\n$$\nq_\\mathrm{out}(t) = - K \\, \\frac{\\partial p}{\\partial x}(L,t),\n$$\nand approximate it at each time step by the gradient over the last element as\n$$\nq_\\mathrm{out}(t_n) \\approx K \\, \\frac{p_{N_n-2}(t_n) - p_{N_n-1}(t_n)}{h}.\n$$\nDefine the cumulative discharged fluid content per unit area up to time $T$ as\n$$\nQ(T) = \\sum_{n=1}^{N_t} q_\\mathrm{out}(t_n)\\, \\Delta t.\n$$\nBy global mass conservation, in the absence of sources and with zero flux at $x=0$, the conservation identity is\n$$\nM(T) - M(0) + Q(T) = 0.\n$$\nDefine the mass conservation error as\n$$\n\\Delta m = \\left| M(T) - M(0) + Q(T) \\right|,\n$$\nwith unit meters (fluid content per unit cross-sectional area). Implement and compare the three boundary enforcement strategies by computing $\\Delta m$ for a set of stabilization parameters. Treat $p_D=0$.\n\nYour program must solve the discrete system for each of the following test cases:\n- Penalty method with $\\gamma_p = 0.1$, $\\gamma_p = 10.0$, and $\\gamma_p = 1000.0$.\n- Nitsche’s method with $\\gamma_N = 1.0$, $\\gamma_N = 10.0$, and $\\gamma_N = 100.0$.\n- Lagrange multiplier method with augmented parameter $\\beta = 0.0$ (pure Lagrange multiplier) and $\\beta = 10.0$.\n\nFor each test case, compute and return $\\Delta m$ in meters. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[0.00123,0.00045, \\ldots ]$). All numerical values must be in meters, expressed as floating-point decimal numbers in base-10 notation.", "solution": "The user wants to solve a 1D consolidation problem and compare three different methods for weakly enforcing a Dirichlet boundary condition. I will first validate the problem statement.\n\n### Step 1: Extract Givens\n- **Governing PDE**: $S \\, \\frac{\\partial p}{\\partial t}(x,t) - \\frac{\\partial}{\\partial x}\\!\\left( K \\, \\frac{\\partial p}{\\partial x}(x,t) \\right) = 0$ for $x \\in [0,L]$.\n- **Parameters**: Storativity $S$, hydraulic diffusivity factor $K$.\n- **Initial Condition**: $p(x,0) = p_0$.\n- **Boundary Conditions**: Homogeneous Neumann at $x=0$ (no-flow), Dirichlet at $x=L$ ($p(L,t)=p_D=0$).\n- **Weak Form**: $\\int_0^L S \\, w \\, \\frac{\\partial p}{\\partial t} \\, dx + \\int_0^L K \\, \\frac{\\partial w}{\\partial x} \\, \\frac{\\partial p}{\\partial x} \\, dx - w(0) \\, q_N(0,t) - w(L) \\, q_N(L,t) = 0$.\n- **Discretization**: Linear two-node finite elements ($N_e$ elements, $N_n=N_e+1$ nodes), uniform mesh size $h=L/N_e$. Backward Euler time integration with step $\\Delta t$.\n- **Physical/Numerical Constants**: $L = 1\\,\\mathrm{m}$, $S = 1.0\\times 10^{-9}\\,\\mathrm{Pa}^{-1}$, $K = 1.0\\times 10^{-6}\\,\\mathrm{m}^2/(\\mathrm{Pa}\\cdot\\mathrm{s})$, $p_0 = 1.0\\times 10^{5}\\,\\mathrm{Pa}$, $N_e = 40$, $h = L/N_e$, $\\Delta t = 10\\,\\mathrm{s}$, $T = 1000\\,\\mathrm{s}$.\n- **Boundary Condition Enforcement Methods**:\n    1.  **Penalty**: Add penalty term $\\gamma_p \\, K/h \\, (p(L,t) - p_D)$.\n    2.  **Lagrange Multiplier**: Augment system with constraint $p(L,t)=p_D$ and optional regularization $\\beta \\, K/h$.\n    3.  **Symmetric Nitsche**: Add terms $- \\int_{\\Gamma_D} w \\, (n \\cdot K \\nabla p) \\, ds - \\int_{\\Gamma_D} (n \\cdot K \\nabla w) \\, (p - p_D) \\, ds + \\int_{\\Gamma_D} \\gamma_N \\, \\frac{K}{h} \\, w \\, (p - p_D) \\, ds$.\n- **Analysis Quantities**:\n    -   Total fluid content: $M(t) = S \\int_0^L p(x,t)\\, dx \\approx \\mathbf{1}^\\top \\mathbf{M}\\, \\mathbf{p}(t)$.\n    -   Outward flux: $q_\\mathrm{out}(t) = - K \\, \\frac{\\partial p}{\\partial x}(L,t) \\approx K \\, (p_{N_n-2}(t_n) - p_{N_n-1}(t_n))/h$.\n    -   Cumulative discharge: $Q(T) = \\sum_{n=1}^{N_t} q_\\mathrm{out}(t_n)\\, \\Delta t$.\n    -   Mass conservation error: $\\Delta m = \\left| M(T) - M(0) + Q(T) \\right|$.\n- **Test Cases**:\n    -   Penalty: $\\gamma_p \\in \\{0.1, 10.0, 1000.0\\}$.\n    -   Nitsche: $\\gamma_N \\in \\{1.0, 10.0, 100.0\\}$.\n    -   Lagrange Multiplier: $\\beta \\in \\{0.0, 10.0\\}$.\n\n### Step 2: Validate Using Extracted Givens\n1.  **Scientifically Grounded**: The problem describes 1D fluid diffusion in a porous medium, a cornerstone of geomechanics and hydrology, based on mass conservation and Darcy's law. All models and methods are standard in computational mechanics. The setup is scientifically valid.\n2.  **Well-Posed**: The problem is a well-posed initial-boundary value problem for a parabolic PDE. The numerical formulation is standard and leads to a solvable system of linear equations at each time step.\n3.  **Objective**: All terms are defined with mathematical precision. No subjective language is used.\n4.  **Scientific or Factual Unsoundness**: None. The physics, mathematics, and numerical methods are correct.\n5.  **Non-Formalizable or Irrelevant**: The problem is highly formalizable and directly relevant to the specified topic.\n6.  **Incomplete or Contradictory Setup**: The problem is fully specified. The definition of the discrete total fluid content $M(t) \\approx \\mathbf{1}^\\top \\mathbf{M}\\, \\mathbf{p}(t)$ is correct because for a test function $w(x)=1 = \\sum_i N_i(x)$, the corresponding vector of nodal weights is $\\mathbf{w}=\\mathbf{1}$, and the integral $\\int S w p \\,dx$ becomes $\\mathbf{w}^\\top \\mathbf{M} \\mathbf{p} = \\mathbf{1}^\\top \\mathbf{M} \\mathbf{p}$. The flux approximation is a valid finite difference over the last element. All definitions are consistent.\n7.  **Unrealistic or Infeasible**: The physical parameters are plausible for materials like sand or silt. The numerical parameters define a numerically stable simulation (the backward-Euler scheme is unconditionally stable).\n8.  **Ill-Posed or Poorly Structured**: Not ill-posed. The structure is clear and logical.\n9.  **Pseudo-Profound, Trivial, or Tautological**: The problem is a substantive exercise in numerical analysis, comparing the practical performance of different established numerical techniques.\n10. **Outside Scientific Verifiability**: The results are numerically computable and verifiable.\n\n### Step 3: Verdict and Action\nThe problem is valid. I will proceed with the solution derivation.\n\nThe governing PDE for the fluid pressure $p(x,t)$ is a diffusion equation:\n$$S \\, \\frac{\\partial p}{\\partial t} - \\frac{\\partial}{\\partial x}\\!\\left( K \\, \\frac{\\partial p}{\\partial x} \\right) = 0$$\nWe begin by deriving the semi-discrete finite element approximation. Multiplying by a test function $w(x)$ and integrating over the domain $[0,L]$ yields the weak form. After integration by parts of the second term, we have:\n$$\\int_0^L S \\, w \\, \\frac{\\partial p}{\\partial t} \\, dx + \\int_0^L K \\, \\frac{\\partial w}{\\partial x} \\, \\frac{\\partial p}{\\partial x} \\, dx - \\left[ w K \\frac{\\partial p}{\\partial x} \\right]_0^L = 0$$\nThe boundary term can be written in terms of the Darcy flux $q(x,t) = -K \\frac{\\partial p}{\\partial x}(x,t)$. The weak form becomes:\n$$\\int_0^L S \\, w \\, \\frac{\\partial p}{\\partial t} \\, dx + \\int_0^L K \\, \\frac{\\partial w}{\\partial x} \\, \\frac{\\partial p}{\\partial x} \\, dx + w(L)q(L,t) - w(0)q(0,t) = 0$$\nThe no-flow condition at $x=0$ implies $q(0,t)=0$. The condition at $x=L$ will be handled by the various weak enforcement methods.\n\nWe discretize the spatial domain with $N_e$ linear finite elements of uniform size $h = L/N_e$, having $N_n = N_e+1$ nodes. We approximate the pressure field as $p(x,t) \\approx \\sum_{j=0}^{N_n-1} p_j(t) N_j(x)$, where $p_j(t)$ are the nodal pressure values and $N_j(x)$ are the piecewise linear basis functions. Using the Galerkin method, the test function $w(x)$ is chosen from the same basis, $w(x) = N_i(x)$. This leads to a system of ordinary differential equations:\n$$\\mathbf{M} \\frac{d\\mathbf{p}}{dt} + \\mathbf{K} \\mathbf{p} = \\mathbf{f}$$\nwhere $\\mathbf{p}$ is the vector of nodal pressures, and the matrices are assembled from element contributions:\n-   Consistent Mass Matrix: $\\mathbf{M}_{ij} = \\int_0^L S N_i(x) N_j(x) \\, dx$. For a linear element, $\\mathbf{M}^e = \\frac{S h}{6} \\begin{pmatrix} 2 & 1 \\\\ 1 & 2 \\end{pmatrix}$.\n-   Stiffness Matrix: $\\mathbf{K}_{ij} = \\int_0^L K N_i'(x) N_j'(x) \\, dx$. For a linear element, $\\mathbf{K}^e = \\frac{K}{h} \\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix}$.\n-   Force Vector $\\mathbf{f}$: arises from boundary terms. For now, $f_i(t) = -w(L)q(L,t)|_{w=N_i}$, which is non-zero only for $i=N_n-1$.\n\nApplying the backward Euler scheme for time integration, $\\frac{d\\mathbf{p}}{dt} \\approx \\frac{\\mathbf{p}^{n+1} - \\mathbf{p}^n}{\\Delta t}$, we obtain a fully discrete system to be solved at each time step $n+1$:\n$$(\\mathbf{M} + \\Delta t \\mathbf{K}) \\mathbf{p}^{n+1} = \\mathbf{M} \\mathbf{p}^n + \\Delta t \\mathbf{f}^{n+1}$$\nwhere $\\mathbf{p}^{n+1}$ is the unknown pressure vector at time $t_{n+1}$. The boundary condition $p(L,t) = p_D=0$ is imposed on the node $i=N_n-1$.\n\n**1. Penalty Method**\nThe Dirichlet constraint is enforced approximately by adding a penalty term to the weak form, which can be interpreted as a Robin-type boundary condition where the flux is proportional to the constraint violation: $q(L,t) \\approx \\alpha (p(L,t) - p_D)$. The penalty parameter is given as $\\alpha = \\gamma_p K/h$. The force vector contribution is $f_{N_n-1}^{n+1} = -q(L,t_{n+1}) \\approx -\\alpha (p_{N_n-1}^{n+1} - p_D)$. With $p_D=0$, the system becomes:\n$$(\\mathbf{M} + \\Delta t \\mathbf{K}) \\mathbf{p}^{n+1} + \\Delta t \\alpha \\begin{pmatrix} 0 \\\\ \\vdots \\\\ 0 \\\\ 1 \\end{pmatrix} p_{N_n-1}^{n+1} = \\mathbf{M} \\mathbf{p}^n$$\nThis is equivalent to modifying the system matrix $\\mathbf{A} = \\mathbf{M} + \\Delta t \\mathbf{K}$ by adding a term to its last diagonal entry:\n$$A_{N_n-1, N_n-1} \\rightarrow A_{N_n-1, N_n-1} + \\Delta t \\, \\gamma_p \\frac{K}{h}$$\nThe right-hand side vector is $\\mathbf{b} = \\mathbf{M} \\mathbf{p}^n$. We solve $(\\mathbf{A}_{mod}) \\mathbf{p}^{n+1} = \\mathbf{b}$.\n\n**2. Lagrange Multiplier Method**\nThis method introduces a new unknown, the Lagrange multiplier $\\lambda$, which represents the reaction flux at the boundary, $\\lambda \\approx q(L,t)$. The system is augmented by the exact constraint equation $p_{N_n-1}^{n+1} = p_D = 0$. The force vector becomes $\\mathbf{f}^{n+1} = [0, \\dots, 0, -\\lambda^{n+1}]^\\top$. The full system at step $n+1$ combines the discretized PDE and the constraint:\n$$ \\begin{cases} (\\mathbf{M} + \\Delta t \\mathbf{K}) \\mathbf{p}^{n+1} + \\Delta t \\lambda^{n+1} \\mathbf{c} = \\mathbf{M} \\mathbf{p}^n \\\\ \\mathbf{c}^\\top \\mathbf{p}^{n+1} = p_D \\end{cases} $$\nwhere $\\mathbf{c}$ is a vector with $1$ at index $N_n-1$ and $0$ elsewhere. This forms an $(N_n+1) \\times (N_n+1)$ saddle-point system:\n$$ \\begin{pmatrix} \\mathbf{M} + \\Delta t \\mathbf{K} & \\Delta t \\, \\mathbf{c} \\\\ \\mathbf{c}^\\top & 0 \\end{pmatrix} \\begin{pmatrix} \\mathbf{p}^{n+1} \\\\ \\lambda^{n+1} \\end{pmatrix} = \\begin{pmatrix} \\mathbf{M} \\mathbf{p}^n \\\\ p_D \\end{pmatrix} $$\nThe augmented variant adds a stabilization term $\\beta K/h$ to the diagonal entry of the primary degree of freedom, $p_{N_n-1}$. This modifies the $(N_n-1, N_n-1)$ entry of the top-left block of the system matrix:\n$$(\\mathbf{M} + \\Delta t \\mathbf{K})_{N_n-1, N_n-1} \\rightarrow (\\mathbf{M} + \\Delta t \\mathbf{K})_{N_n-1, N_n-1} + \\Delta t \\beta \\frac{K}{h}$$\nFor the pure Lagrange multiplier method, $\\beta=0$. Since $p_D=0$, the last entry of the right-hand side vector is $0$.\n\n**3. Nitsche’s Method**\nThe symmetric Nitsche method modifies the weak form by replacing the natural boundary term $w(L)q(L,t)$ with three terms that weakly enforce the Dirichlet condition. The final weak form is:\n$$\\int_0^L S w \\dot{p}\\,dx + \\int_0^L K w'p'\\,dx - [K p' w]_L - [K w'(p-p_D)]_L + [\\gamma_N \\frac{K}{h}w(p-p_D)]_L = 0$$\nThe three boundary terms contribute to the stiffness matrix $\\mathbf{K}$ and the load vector $\\mathbf{f}$. Discretizing these terms gives rise to modifications of the stiffness matrix entries corresponding to the boundary nodes ($N_n-2$ and $N_n-1$). The total contribution to be added to the standard stiffness matrix, for the sub-block corresponding to these two nodes, is:\n$$ \\mathbf{K}^N = \\frac{K}{h} \\begin{pmatrix} 0 & 1 \\\\ 1 & \\gamma_N-2 \\end{pmatrix} $$\nThe total system stiffness matrix $\\mathbf{K}_{Nitsche}$ is $\\mathbf{K}_{std} + \\mathbf{K}^N$. This results in specific modifications. The standard stiffness matrix block for nodes $(N_n-2, N_n-1)$ is $\\frac{K}{h}\\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix}$. Adding $\\mathbf{K}^N$ modifies the coupling:\n$$ (\\mathbf{K}_{Nitsche})_{N_n-2, N_n-1} = (\\mathbf{K}_{Nitsche})_{N_n-1, N_n-2} = -K/h + K/h = 0 $$\n$$ (\\mathbf{K}_{Nitsche})_{N_n-1, N_n-1} = K/h + (\\gamma_N - 2)K/h = (\\gamma_N - 1)K/h $$\nThe terms involving $p_D$ contribute to the load vector, but since $p_D=0$, this contribution vanishes. The system to solve is $(\\mathbf{M} + \\Delta t \\mathbf{K}_{Nitsche})\\mathbf{p}^{n+1} = \\mathbf{M} \\mathbf{p}^n$.\n\n**Mass Conservation Error**\nThe mass conservation error $\\Delta m = | M(T) - M(0) + Q(T) |$ is computed to assess the accuracy of each method.\n-   The initial fluid content is $M(0) = S \\int_0^L p_0 \\, dx = S p_0 L$.\n-   The final fluid content is calculated from the final pressure vector $\\mathbf{p}(T)$: $M(T) \\approx \\mathbf{1}^\\top \\mathbf{M} \\mathbf{p}(T)$.\n-   The cumulative outflow $Q(T)$ is the sum of outflows at each time step, $Q(T) = \\sum_{n=1}^{N_t} q_\\mathrm{out}(t_n)\\, \\Delta t$, where the outflow flux is approximated from the solution as $q_\\mathrm{out}(t_n) \\approx K (p_{N_n-2}(t_n) - p_{N_n-1}(t_n))/h$.\n\nThe implementation will simulate the pressure evolution up to $T=1000\\,\\mathrm{s}$ for each of the $8$ test cases and compute the corresponding $\\Delta m$.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D consolidation problem using FEM with different\n    weak boundary condition enforcement methods and calculates the\n    mass conservation error for each.\n    \"\"\"\n\n    # Physical and numerical parameters from the problem statement\n    L = 1.0  # m\n    S = 1.0e-9  # Pa^-1\n    K = 1.0e-6  # m^2/(Pa*s)\n    p0 = 1.0e5  # Pa\n    Ne = 40  # Number of elements\n    h = L / Ne  # Element size\n    Nn = Ne + 1  # Number of nodes\n    T = 1000.0  # s\n    dt = 10.0  # s\n    Nt = int(T / dt)  # Number of time steps\n    pD = 0.0 # Prescribed pressure at drained boundary\n\n    # Test cases from the problem statement\n    test_cases = [\n        ('penalty', 0.1),\n        ('penalty', 10.0),\n        ('penalty', 1000.0),\n        ('nitsche', 1.0),\n        ('nitsche', 10.0),\n        ('nitsche', 100.0),\n        ('lagrange', 0.0),\n        ('lagrange', 10.0),\n    ]\n\n    results = []\n\n    # Assemble global mass (M) and stiffness (K) matrices\n    M = np.zeros((Nn, Nn))\n    K_std = np.zeros((Nn, Nn))\n\n    # Element-level matrices\n    m_e = (S * h / 6.0) * np.array([[2.0, 1.0], [1.0, 2.0]])\n    k_e = (K / h) * np.array([[1.0, -1.0], [-1.0, 1.0]])\n\n    for e in range(Ne):\n        # Global indices for the element's nodes\n        i, j = e, e + 1\n        # Add element contributions to global matrices\n        M[np.ix_([i, j], [i, j])] += m_e\n        K_std[np.ix_([i, j], [i, j])] += k_e\n\n    # Calculate initial mass M(0)\n    M0 = S * p0 * L\n\n    for method, param in test_cases:\n        p = np.full(Nn, p0) # Initial condition p(x,0) = p0\n        Q_T = 0.0 # Cumulative discharged fluid\n\n        for _ in range(Nt):\n            # Form the basic system Ax=b where A = M + dt*K and b = M*p_prev\n            # Make copies to avoid modifying the base matrices\n            K_eff = K_std.copy()\n            \n            # Right-hand side is the same for all methods\n            b_sys = M @ p\n            \n            if method == 'penalty':\n                gamma_p = param\n                A_sys = M + dt * K_eff\n                A_sys[Nn - 1, Nn - 1] += dt * gamma_p * K / h\n                p = np.linalg.solve(A_sys, b_sys)\n\n            elif method == 'nitsche':\n                gamma_N = param\n                # Modify the standard stiffness matrix for Nitsche's method\n                K_eff[Nn - 2, Nn - 1] = 0.0\n                K_eff[Nn - 1, Nn - 2] = 0.0\n                K_eff[Nn - 1, Nn - 1] = (gamma_N - 1.0) * K / h\n                A_sys = M + dt * K_eff\n                p = np.linalg.solve(A_sys, b_sys)\n\n            elif method == 'lagrange':\n                beta = param\n                A = M + dt * K_eff\n                # Add augmentation term if beta > 0\n                if beta > 0:\n                    A[Nn - 1, Nn - 1] += dt * beta * K / h\n                \n                # Assemble augmented system matrix\n                A_aug = np.zeros((Nn + 1, Nn + 1))\n                A_aug[:Nn, :Nn] = A\n                A_aug[Nn - 1, Nn] = dt # This is +dt because we moved lambda from RHS to LHS\n                A_aug[Nn, Nn - 1] = 1.0\n\n                # Note on the sign convention for lambda:\n                # The PDE weak form is M p_dot + K p = f, where f_i = -integral(N_i * q_n).\n                # At the boundary, f_{Nn-1} = -q(L,\n                # t) = lambda.\n                # So the equation is (M+dt*K)p^{n+1} = M p^n + dt*f^{n+1}.\n                # (M+dt*K)p^{n+1} - dt*lambda^{n+1}*c = M p^n\n                # So A_aug[Nn - 1, Nn] needs to be -dt. Let's correct this.\n                A_aug[Nn - 1, Nn] = -dt\n\n                # Assemble augmented RHS vector\n                b_aug = np.zeros(Nn + 1)\n                b_aug[:Nn] = b_sys\n                b_aug[Nn] = pD\n                \n                sol = np.linalg.solve(A_aug, b_aug)\n                p = sol[:Nn]\n            \n            # Calculate outflow flux for the current time step\n            q_out = K * (p[Nn - 2] - p[Nn - 1]) / h\n            # Accumulate total outflow\n            Q_T += q_out * dt\n        \n        # Calculate final mass M(T)\n        MT = np.ones(Nn) @ M @ p\n        \n        # Calculate mass conservation error\n        delta_m = abs(MT - M0 + Q_T)\n        results.append(delta_m)\n\n    # Print results in the required format\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\nsolve()\n```", "id": "3504268"}]}