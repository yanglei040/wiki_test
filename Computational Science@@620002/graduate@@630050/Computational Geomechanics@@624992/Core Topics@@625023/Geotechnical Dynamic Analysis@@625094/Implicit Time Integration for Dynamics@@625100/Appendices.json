{"hands_on_practices": [{"introduction": "Before implementing any numerical integrator, it is crucial to understand its fundamental properties. This first practice focuses on accuracy, guiding you through a classic local truncation error analysis for the Newmark-$\\beta$ family of methods [@problem_id:3532505]. By applying Taylor series expansions to the governing kinematic relations, you will derive the error terms as a function of the time step $\\Delta t$ and the parameters $\\beta$ and $\\gamma$. This foundational exercise is invaluable for revealing how these parameters control the method's order of accuracy and for identifying special cases with superior performance.", "problem": "In computational geomechanics, consider a single degree of freedom (DOF) component of a semi-discrete soil dynamics model, where the kinematics satisfy $u^{\\prime}(t)=v(t)$ and $v^{\\prime}(t)=a(t)$. The Newmark family of time integrators with parameters $\\beta$ and $\\gamma$ updates displacement, velocity, and acceleration on a uniform time grid $t_{n}$ with step size $\\Delta t>0$ via the standard kinematic relations\n$$\nu_{n+1}=u_{n}+\\Delta t\\,v_{n}+\\Delta t^{2}\\left(\\frac{1}{2}-\\beta\\right)a_{n}+\\Delta t^{2}\\beta\\,a_{n+1},\\qquad\nv_{n+1}=v_{n}+\\Delta t\\left((1-\\gamma)a_{n}+\\gamma\\,a_{n+1}\\right),\n$$\nwhere $u_{n}\\equiv u(t_{n})$, $v_{n}\\equiv v(t_{n})$, and $a_{n}\\equiv a(t_{n})$. Define the algorithmic acceleration $a_{n+1}^{\\text{alg}}$ induced by the displacement update as the value obtained by algebraically solving the displacement relation for $a_{n+1}$:\n$$\na_{n+1}^{\\text{alg}}=\\frac{1}{\\beta\\,\\Delta t^{2}}\\left(u_{n+1}-u_{n}-\\Delta t\\,v_{n}\\right)-\\frac{\\frac{1}{2}-\\beta}{\\beta}\\,a_{n}.\n$$\n\nAssume the exact displacement over one step is a fourth-degree polynomial in time about $t_{n}$,\n$$\nu(t_{n}+\\tau)=u_{n}+v_{n}\\,\\tau+\\frac{1}{2}a_{n}\\,\\tau^{2}+\\frac{1}{6}j_{n}\\,\\tau^{3}+\\frac{1}{24}s_{n}\\,\\tau^{4},\n$$\nwhere $j_{n}\\equiv u^{(3)}(t_{n})$ (jerk) and $s_{n}\\equiv u^{(4)}(t_{n})$ (snap) are constants over the time step. Let $u_{n+1}^{\\text{exact}}=u(t_{n}+\\Delta t)$, $v_{n+1}^{\\text{exact}}=v(t_{n}+\\Delta t)$, and $a_{n+1}^{\\text{exact}}=a(t_{n}+\\Delta t)$.\n\n1. Using only the kinematic identities $u^{\\prime}=v$ and $v^{\\prime}=a$, expand $u_{n+1}^{\\text{exact}}$, $v_{n+1}^{\\text{exact}}$, and $a_{n+1}^{\\text{exact}}$ in Taylor series about $t_{n}$ through the first nonzero terms that will control the local truncation error.\n2. Insert these expansions into the Newmark kinematic updates to obtain the one-step local errors $E_{u}=u_{n+1}^{\\text{NM}}-u_{n+1}^{\\text{exact}}$, $E_{v}=v_{n+1}^{\\text{NM}}-v_{n+1}^{\\text{exact}}$, and $E_{a}=a_{n+1}^{\\text{alg}}-a_{n+1}^{\\text{exact}}$ as asymptotic series in $\\Delta t$, keeping the first nonzero term in each.\n3. From these expressions, verify the order conditions relating $\\beta$ and $\\gamma$, and determine the unique pair $(\\beta,\\gamma)$ for which the Newmark update is exact over one step for any cubic-in-time displacement $u(t)$ (that is, when $s_{n}=0$ but $j_{n}$ may be nonzero), simultaneously in $u_{n+1}$, $v_{n+1}$, and $a_{n+1}$.\n\nProvide your final answer as the pair $(\\beta,\\gamma)$ in a single row vector using the $\\mathrm{pmatrix}$ format, with no units and no rounding.", "solution": "The problem statement is a valid exercise in the analysis of numerical integrators for ordinary differential equations, specifically the Newmark-$\\beta$ method as applied in computational dynamics. It is scientifically grounded, well-posed, and objective. All necessary information is provided, and the tasks are clearly defined.\n\nThe solution proceeds in three parts as requested by the problem statement.\n\n### Part 1: Taylor Series Expansions of Exact Solutions\n\nWe are given the exact displacement over the time step $[t_n, t_{n+1}]$ as a fourth-degree polynomial in time increment $\\tau = t - t_n$:\n$$u(t_{n}+\\tau)=u_{n}+v_{n}\\,\\tau+\\frac{1}{2}a_{n}\\,\\tau^{2}+\\frac{1}{6}j_{n}\\,\\tau^{3}+\\frac{1}{24}s_{n}\\,\\tau^{4}$$\nwhere $u_n=u(t_n)$, $v_n=u'(t_n)$, $a_n=u''(t_n)$, $j_n=u^{(3)}(t_n)$, and $s_n=u^{(4)}(t_n)$.\n\nUsing the kinematic identities $v(t) = u'(t)$ and $a(t) = v'(t)$, we differentiate the expression for $u(t_n+\\tau)$ with respect to $\\tau$ to find the velocity and acceleration.\n\nThe velocity is:\n$$v(t_{n}+\\tau) = \\frac{d}{d\\tau}u(t_{n}+\\tau) = v_{n}+a_{n}\\,\\tau+\\frac{1}{2}j_{n}\\,\\tau^{2}+\\frac{1}{6}s_{n}\\,\\tau^{3}$$\n\nThe acceleration is:\n$$a(t_{n}+\\tau) = \\frac{d}{d\\tau}v(t_{n}+\\tau) = a_{n}+j_{n}\\,\\tau+\\frac{1}{2}s_{n}\\,\\tau^{2}$$\n\nTo find the exact values at the end of the time step, we set $\\tau = \\Delta t$:\n$u_{n+1}^{\\text{exact}} = u(t_{n}+\\Delta t) = u_{n}+v_{n}\\,\\Delta t+\\frac{1}{2}a_{n}\\,\\Delta t^{2}+\\frac{1}{6}j_{n}\\,\\Delta t^{3}+\\frac{1}{24}s_{n}\\,\\Delta t^{4}$\n$v_{n+1}^{\\text{exact}} = v(t_{n}+\\Delta t) = v_{n}+a_{n}\\,\\Delta t+\\frac{1}{2}j_{n}\\,\\Delta t^{2}+\\frac{1}{6}s_{n}\\,\\Delta t^{3}$\n$a_{n+1}^{\\text{exact}} = a(t_{n}+\\Delta t) = a_{n}+j_{n}\\,\\Delta t+\\frac{1}{2}s_{n}\\,\\Delta t^{2}$\n\n### Part 2: Local Truncation Errors\n\nThe local truncation error is the error committed in a single step, assuming all values at the beginning of the step ($u_n$, $v_n$, $a_n$) are exact. To find this error for the Newmark updates, we substitute the exact acceleration $a_{n+1}^{\\text{exact}}$ into the scheme's equations.\n\n**Displacement Error ($E_u$)**\nThe Newmark displacement update is:\n$$u_{n+1}^{\\text{NM}}=u_{n}+\\Delta t\\,v_{n}+\\Delta t^{2}\\left(\\frac{1}{2}-\\beta\\right)a_{n}+\\Delta t^{2}\\beta\\,a_{n+1}$$\nSubstituting $a_{n+1}^{\\text{exact}}$ for $a_{n+1}$:\n$$u_{n+1}^{\\text{NM}}=u_{n}+\\Delta t\\,v_{n}+\\Delta t^{2}\\left(\\frac{1}{2}-\\beta\\right)a_{n}+\\Delta t^{2}\\beta\\left(a_{n}+j_{n}\\,\\Delta t+\\frac{1}{2}s_{n}\\,\\Delta t^{2}\\right)$$\n$$u_{n+1}^{\\text{NM}}=u_{n}+\\Delta t\\,v_{n}+\\left(\\frac{1}{2}-\\beta+\\beta\\right)a_{n}\\,\\Delta t^{2}+\\beta\\,j_{n}\\,\\Delta t^{3}+\\frac{1}{2}\\beta\\,s_{n}\\,\\Delta t^{4}$$\n$$u_{n+1}^{\\text{NM}}=u_{n}+\\Delta t\\,v_{n}+\\frac{1}{2}a_{n}\\,\\Delta t^{2}+\\beta\\,j_{n}\\,\\Delta t^{3}+\\frac{1}{2}\\beta\\,s_{n}\\,\\Delta t^{4}$$\nThe local error $E_u = u_{n+1}^{\\text{NM}} - u_{n+1}^{\\text{exact}}$ is:\n$$E_{u} = \\left(u_{n}+\\Delta t\\,v_{n}+\\frac{1}{2}a_{n}\\,\\Delta t^{2}+\\beta\\,j_{n}\\,\\Delta t^{3}+\\frac{1}{2}\\beta\\,s_{n}\\,\\Delta t^{4}\\right) - \\left(u_{n}+v_{n}\\,\\Delta t+\\frac{1}{2}a_{n}\\,\\Delta t^{2}+\\frac{1}{6}j_{n}\\,\\Delta t^{3}+\\frac{1}{24}s_{n}\\,\\Delta t^{4}\\right)$$\n$$E_{u} = \\left(\\beta - \\frac{1}{6}\\right)j_{n}\\,\\Delta t^{3} + \\left(\\frac{1}{2}\\beta - \\frac{1}{24}\\right)s_{n}\\,\\Delta t^{4}$$\nThe first nonzero term, assuming $j_n \\neq 0$, is $E_{u} \\approx \\left(\\beta - \\frac{1}{6}\\right)j_{n}\\,\\Delta t^{3}$.\n\n**Velocity Error ($E_v$)**\nThe Newmark velocity update is:\n$$v_{n+1}^{\\text{NM}}=v_{n}+\\Delta t\\left((1-\\gamma)a_{n}+\\gamma\\,a_{n+1}\\right)$$\nSubstituting $a_{n+1}^{\\text{exact}}$ for $a_{n+1}$:\n$$v_{n+1}^{\\text{NM}}=v_{n}+\\Delta t\\left((1-\\gamma)a_{n}+\\gamma\\left(a_{n}+j_{n}\\,\\Delta t+\\frac{1}{2}s_{n}\\,\\Delta t^{2}\\right)\\right)$$\n$$v_{n+1}^{\\text{NM}}=v_{n}+\\left(1-\\gamma+\\gamma\\right)a_{n}\\,\\Delta t+\\gamma\\,j_{n}\\,\\Delta t^{2}+\\frac{1}{2}\\gamma\\,s_{n}\\,\\Delta t^{3}$$\n$$v_{n+1}^{\\text{NM}}=v_{n}+a_{n}\\,\\Delta t+\\gamma\\,j_{n}\\,\\Delta t^{2}+\\frac{1}{2}\\gamma\\,s_{n}\\,\\Delta t^{3}$$\nThe local error $E_v = v_{n+1}^{\\text{NM}} - v_{n+1}^{\\text{exact}}$ is:\n$$E_{v} = \\left(v_{n}+a_{n}\\,\\Delta t+\\gamma\\,j_{n}\\,\\Delta t^{2}+\\frac{1}{2}\\gamma\\,s_{n}\\,\\Delta t^{3}\\right) - \\left(v_{n}+a_{n}\\,\\Delta t+\\frac{1}{2}j_{n}\\,\\Delta t^{2}+\\frac{1}{6}s_{n}\\,\\Delta t^{3}\\right)$$\n$$E_{v} = \\left(\\gamma - \\frac{1}{2}\\right)j_{n}\\,\\Delta t^{2} + \\left(\\frac{1}{2}\\gamma - \\frac{1}{6}\\right)s_{n}\\,\\Delta t^{3}$$\nThe first nonzero term, assuming $j_n \\neq 0$, is $E_{v} \\approx \\left(\\gamma - \\frac{1}{2}\\right)j_{n}\\,\\Delta t^{2}$.\n\n**Acceleration Error ($E_a$)**\nThe algorithmic acceleration $a_{n+1}^{\\text{alg}}$ is defined by inserting the displacement $u_{n+1}$ into the rearranged displacement update formula. To find its local error, we insert the exact displacement $u_{n+1}^{\\text{exact}}$:\n$$a_{n+1}^{\\text{alg}}=\\frac{1}{\\beta\\,\\Delta t^{2}}\\left(u_{n+1}^{\\text{exact}}-u_{n}-\\Delta t\\,v_{n}\\right)-\\frac{\\frac{1}{2}-\\beta}{\\beta}\\,a_{n}$$\nFrom the expansion of $u_{n+1}^{\\text{exact}}$, we have:\n$$u_{n+1}^{\\text{exact}}-u_{n}-\\Delta t\\,v_{n} = \\frac{1}{2}a_{n}\\,\\Delta t^{2}+\\frac{1}{6}j_{n}\\,\\Delta t^{3}+\\frac{1}{24}s_{n}\\,\\Delta t^{4}$$\nSubstituting this into the expression for $a_{n+1}^{\\text{alg}}$:\n$$a_{n+1}^{\\text{alg}}=\\frac{1}{\\beta\\,\\Delta t^{2}}\\left(\\frac{1}{2}a_{n}\\,\\Delta t^{2}+\\frac{1}{6}j_{n}\\,\\Delta t^{3}+\\frac{1}{24}s_{n}\\,\\Delta t^{4}\\right) - \\left(\\frac{1}{2\\beta}-1\\right)a_n$$\n$$a_{n+1}^{\\text{alg}}=\\frac{a_{n}}{2\\beta}+\\frac{j_{n}}{6\\beta}\\Delta t+\\frac{s_{n}}{24\\beta}\\Delta t^{2} - \\frac{a_{n}}{2\\beta} + a_n$$\n$$a_{n+1}^{\\text{alg}}=a_{n} + \\frac{1}{6\\beta}j_{n}\\,\\Delta t + \\frac{1}{24\\beta}s_{n}\\,\\Delta t^{2}$$\nThe local error $E_a = a_{n+1}^{\\text{alg}} - a_{n+1}^{\\text{exact}}$ is:\n$$E_{a} = \\left(a_{n} + \\frac{1}{6\\beta}j_{n}\\,\\Delta t + \\frac{1}{24\\beta}s_{n}\\,\\Delta t^{2}\\right) - \\left(a_{n}+j_{n}\\,\\Delta t+\\frac{1}{2}s_{n}\\,\\Delta t^{2}\\right)$$\n$$E_{a} = \\left(\\frac{1}{6\\beta}-1\\right)j_{n}\\,\\Delta t + \\left(\\frac{1}{24\\beta}-\\frac{1}{2}\\right)s_{n}\\,\\Delta t^{2}$$\nThe first nonzero term, assuming $j_n \\neq 0$, is $E_{a} \\approx \\left(\\frac{1}{6\\beta}-1\\right)j_{n}\\,\\Delta t$.\n\n### Part 3: Order Conditions for Exactness with Cubic Displacement\n\nThe problem requires the method to be exact for any cubic-in-time displacement. A cubic polynomial $u(t)$ has a fourth derivative that is identically zero, i.e., $u^{(4)}(t) = s(t) = 0$. In our notation, this means $s_n=0$. For the method to be \"exact\", the local truncation errors $E_u$, $E_v$, and $E_a$ must all be zero when $s_n=0$.\n\nSetting $s_n=0$ in the error expressions gives:\n$$E_{u} = \\left(\\beta - \\frac{1}{6}\\right)j_{n}\\,\\Delta t^{3}$$\n$$E_{v} = \\left(\\gamma - \\frac{1}{2}\\right)j_{n}\\,\\Delta t^{2}$$\n$$E_{a} = \\left(\\frac{1}{6\\beta}-1\\right)j_{n}\\,\\Delta t$$\n\nFor these errors to be zero for any cubic displacement (i.e., for any constant $j_n \\neq 0$), the coefficients of $j_n$ in each expression must be zero.\n\n1.  For $E_u=0$:\n    $$\\beta - \\frac{1}{6} = 0 \\implies \\beta = \\frac{1}{6}$$\n2.  For $E_v=0$:\n    $$\\gamma - \\frac{1}{2} = 0 \\implies \\gamma = \\frac{1}{2}$$\n3.  For $E_a=0$ (assuming $\\beta \\neq 0$):\n    $$\\frac{1}{6\\beta} - 1 = 0 \\implies 1 = 6\\beta \\implies \\beta = \\frac{1}{6}$$\n\nThe condition on $\\beta$ is consistent between the displacement and acceleration error analyses. To satisfy all three conditions for exactness simultaneously, we must have $\\beta = \\frac{1}{6}$ and $\\gamma = \\frac{1}{2}$. This pair of parameters corresponds to the \"linear acceleration method\", which is known to be exact for systems where acceleration varies linearly with time (which is the case for a cubic displacement).\n\nThe unique pair $(\\beta, \\gamma)$ is therefore $\\left(\\frac{1}{6}, \\frac{1}{2}\\right)$.", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{1}{6} & \\frac{1}{2}\n\\end{pmatrix}\n}\n$$", "id": "3532505"}, {"introduction": "While accuracy governs the error in a single step, stability governs whether errors grow or decay over a long simulation. This computational practice shifts focus from single-step analysis to the long-term behavior of a multi-degree-of-freedom system, a common scenario in geomechanics [@problem_id:3532530]. You will implement a finite element model and use the conditionally stable linear acceleration method to observe numerical blow-up when the time step exceeds the theoretical stability limit. This exercise provides a tangible demonstration of stability theory and highlights the practical impact of modeling choices, such as using a consistent versus a lumped mass matrix, on the simulation's stability.", "problem": "Consider the undamped axial vibration of a one-dimensional layered soil column, modeled as a finite element chain of two-node linear bar elements with spatially varying stiffness to form a stiff–soft–stiff sandwich. The motion is governed by the semidiscrete equations of motion $M \\ddot{u}(t) + K u(t) = 0$, where $M$ is the mass matrix, $K$ is the stiffness matrix, and $u(t)$ is the nodal displacement vector. The column has fixed base at its bottom node and a free top. Your task is to demonstrate conditional stability of the Newmark linear acceleration method by constructing a counterexample in which the high-frequency modes blow up when the time step exceeds a numerically determined stability threshold, and to diagnose the role of using a consistent mass matrix versus a lumped mass matrix in the instability.\n\nYou must proceed from first principles to build the model and algorithm:\n\n1. Start from Newton’s Second Law and the definition of kinematic relations $v(t) = \\frac{du}{dt}$ and $a(t) = \\frac{dv}{dt}$ to write the semidiscrete equations $M \\ddot{u}(t) + K u(t) = 0$ for axial vibration of a bar discretized by linear finite elements. Use the two-node element stiffness $k_e = \\frac{E A}{L_e}\\begin{bmatrix}1 & -1 \\\\ -1 & 1\\end{bmatrix}$ and the consistent element mass $m_e^{\\mathrm{cons}} = \\frac{\\rho A L_e}{6}\\begin{bmatrix}2 & 1 \\\\ 1 & 2\\end{bmatrix}$, and the lumped element mass $m_e^{\\mathrm{lump}} = \\frac{\\rho A L_e}{2}\\begin{bmatrix}1 & 0 \\\\ 0 & 1\\end{bmatrix}$.\n\n2. Discretize the soil column of total length $L_{\\mathrm{tot}} = 12\\,\\mathrm{m}$ into $N_e = 30$ equal elements of length $L_e = \\frac{L_{\\mathrm{tot}}}{N_e}\\,\\mathrm{m}$. The cross-sectional area is $A = 1\\,\\mathrm{m}^2$. The mass density is $\\rho = 2000\\,\\mathrm{kg/m^3}$ in all layers. The Young’s modulus is $E = 10\\times 10^9\\,\\mathrm{Pa}$ in the bottom stiff layer from $z \\in [0\\,\\mathrm{m},4\\,\\mathrm{m}]$, $E = 10\\times 10^6\\,\\mathrm{Pa}$ in the middle soft layer from $z \\in (4\\,\\mathrm{m},8\\,\\mathrm{m}]$, and $E = 10\\times 10^9\\,\\mathrm{Pa}$ in the top stiff layer from $z \\in (8\\,\\mathrm{m},12\\,\\mathrm{m}]$. Impose a fixed base at $z=0$ (zero displacement at the first node) and a free top at $z=12\\,\\mathrm{m}$.\n\n3. Implement the implicit Newmark-$\\beta$ method with the linear acceleration parameters $\\beta = \\frac{1}{6}$ and $\\gamma = \\frac{1}{2}$. Derive the discrete predictor–corrector relations from the kinematic definitions and enforce dynamic equilibrium at the new time using $M \\, a_{n+1} + K \\, u_{n+1} = 0$ (no external forces). Formulate and implement the algorithm that, given $(u_n, v_n, a_n)$ at time $t_n$, computes $(u_{n+1}, v_{n+1}, a_{n+1})$ at $t_{n+1} = t_n + \\Delta t$.\n\n4. Analyze the single-degree-of-freedom case with natural frequency $\\omega$ by deriving a two-dimensional amplification mapping for the dimensionless state vector $\\begin{bmatrix}u_n \\\\ \\Delta t\\, v_n\\end{bmatrix}$, parameterized by the dimensionless step $h = \\omega \\Delta t$, for the given $\\beta$ and $\\gamma$. Determine numerically the largest $h_{\\mathrm{lim}}$ such that the spectral radius of the amplification matrix does not exceed $1$; this defines the conditional stability threshold of the linear acceleration Newmark method. From this, compute the corresponding critical time step $\\Delta t_{\\mathrm{lim}} = \\frac{h_{\\mathrm{lim}}}{\\omega_{\\max}}$ for a multi-degree-of-freedom system, where $\\omega_{\\max}$ is the largest natural frequency obtained from the generalized eigenproblem $K \\phi = \\omega^2 M \\phi$. This step must be carried out separately for the consistent mass and the lumped mass models, because $\\omega_{\\max}$ depends on $M$.\n\n5. Initialize the system at $t=0$ with the highest-frequency mode of the chosen mass model, scaled to unit $M$-norm: set $u_0 = \\phi_{\\max}/\\sqrt{\\phi_{\\max}^\\top M \\phi_{\\max}}$, $v_0 = 0$, and $a_0$ from dynamic equilibrium $M a_0 + K u_0 = 0$. Integrate for $N_{\\mathrm{steps}} = 300$ steps. Define the $M$-norm amplitude growth ratio $R = \\max_{0\\le n \\le N_{\\mathrm{steps}}}\\frac{\\|u_n\\|_{M}}{\\|u_0\\|_{M}}$, where $\\|u\\|_{M} = \\sqrt{u^\\top M u}$.\n\n6. Construct a test suite with three non-dimensional multipliers $c \\in \\{0.8, 1.0, 1.2\\}$ specifying the time step as $\\Delta t = c \\, \\Delta t_{\\mathrm{lim}}$ for each mass model (consistent and lumped, computed separately). For each $c$:\n   - Case A: consistent mass matrix.\n   - Case B: lumped mass matrix.\n   For each case, declare “blow-up” (boolean $true$) if $R \\ge 10$ and “no blow-up” (boolean $false$) otherwise.\n\n7. Physical units: report all lengths in $\\mathrm{m}$, density in $\\mathrm{kg/m^3}$, modulus in $\\mathrm{Pa}$, and time in $\\mathrm{s}$. The final output consists only of booleans, so no unit annotation is needed on the output values.\n\n8. Final output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must contain three entries, one per $c$ value, and each entry must itself be a two-element list $[b_{\\mathrm{cons}}, b_{\\mathrm{lump}}]$ with booleans for the consistent and lumped mass cases, respectively. For example, a valid output format is $[[true,false],[false,false],[true,true]]$.\n\nYour program must implement all necessary steps, assemble the finite element model, compute the stability threshold from the single-degree-of-freedom amplification matrix, run the Newmark integration for the multi-degree-of-freedom system for the specified cases, and output the results in the exact format specified above.", "solution": "The problem requires a demonstration of the conditional stability of the Newmark-$\\beta$ method for linear acceleration by constructing a computational counterexample. We model the axial vibration of a one-dimensional layered soil column using the finite element method. The stability will be tested by exciting the system with its highest frequency mode and observing the behavior for time steps below, at, and above the theoretical stability limit. The analysis will be performed for both consistent and lumped mass matrix formulations.\n\nThe governing equation for the undamped free vibration of the semidiscretized system is given by:\n$$\nM \\ddot{u}(t) + K u(t) = 0\n$$\nwhere $M$ is the global mass matrix, $K$ is the global stiffness matrix, and $u(t)$ is the vector of nodal displacements. $\\ddot{u}(t)$ is the nodal acceleration vector.\n\nFirst, we construct the finite element model. The soil column of total length $L_{\\mathrm{tot}} = 12\\,\\mathrm{m}$ is discretized into $N_e = 30$ two-node linear bar elements, each of length $L_e = L_{\\mathrm{tot}} / N_e = 0.4\\,\\mathrm{m}$. This results in $N_n = N_e + 1 = 31$ nodes. The cross-sectional area is $A = 1\\,\\mathrm{m}^2$ and the mass density is $\\rho = 2000\\,\\mathrm{kg/m^3}$ throughout the column. The Young's modulus, $E$, varies with depth $z$.\nFor each element, we determine its material property based on its position. An element is considered to be in a layer if its midpoint falls within that layer's boundaries. The stiffness distribution is:\n-   Stiff layer ($E = 10 \\times 10^9\\,\\mathrm{Pa}$): $z \\in [0\\,\\mathrm{m}, 4\\,\\mathrm{m}]$, corresponding to elements $1$ through $10$.\n-   Soft layer ($E = 10 \\times 10^6\\,\\mathrm{Pa}$): $z \\in (4\\,\\mathrm{m}, 8\\,\\mathrm{m}]$, corresponding to elements $11$ through $20$.\n-   Stiff layer ($E = 10 \\times 10^9\\,\\mathrm{Pa}$): $z \\in (8\\,\\mathrm{m}, 12\\,\\mathrm{m}]$, corresponding to elements $21$ through $30$.\n\nThe element stiffness matrix $k_e$ is given by:\n$$\nk_e = \\frac{EA}{L_e} \\begin{bmatrix} 1 & -1 \\\\ -1 & 1 \\end{bmatrix}\n$$\nTwo different element mass matrices are considered: the consistent mass matrix, $m_e^{\\mathrm{cons}}$, and the lumped (diagonal) mass matrix, $m_e^{\\mathrm{lump}}$.\n$$\nm_e^{\\mathrm{cons}} = \\frac{\\rho A L_e}{6} \\begin{bmatrix} 2 & 1 \\\\ 1 & 2 \\end{bmatrix} \\quad \\text{and} \\quad m_e^{\\mathrm{lump}} = \\frac{\\rho A L_e}{2} \\begin{bmatrix} 1 & 0 \\\\ 0 & 1 \\end{bmatrix}\n$$\nThe global matrices $K$ and $M$ (for both consistent and lumped cases) are assembled by summing the contributions from all $N_e = 30$ elements. The system is fixed at the base ($z=0$), which corresponds to setting the displacement of the first node to zero ($u_1=0$). This boundary condition is enforced by removing the first row and column from the global matrices, resulting in reduced matrices of size $30 \\times 30$.\n\nNext, we address the time integration using the Newmark-$\\beta$ method. The specified parameters for the linear acceleration method are $\\beta = 1/6$ and $\\gamma = 1/2$. The update rules for displacement $u$ and velocity $v$ from time step $n$ to $n+1$ are:\n$$\nu_{n+1} = u_n + \\Delta t \\, v_n + (\\Delta t)^2 \\left[ \\left(\\frac{1}{2} - \\beta\\right) a_n + \\beta a_{n+1} \\right]\n$$\n$$\nv_{n+1} = v_n + \\Delta t \\left[ (1-\\gamma) a_n + \\gamma a_{n+1} \\right]\n$$\nTo find the unknown acceleration $a_{n+1}$, we enforce the equation of motion at time $t_{n+1}$: $M a_{n+1} + K u_{n+1} = 0$. Substituting the expression for $u_{n+1}$ into this equation yields a linear system for $a_{n+1}$:\n$$\n\\left( M + \\beta (\\Delta t)^2 K \\right) a_{n+1} = -K \\left[ u_n + \\Delta t \\, v_n + (\\Delta t)^2 \\left( \\frac{1}{2} - \\beta \\right) a_n \\right]\n$$\nThis system is solved at each time step to find $a_{n+1}$, after which $u_{n+1}$ and $v_{n+1}$ are computed via the update rules.\n\nThe stability of this method is conditional. For a single-degree-of-freedom (SDOF) system with natural frequency $\\omega$, the stability is governed by the spectral radius of the amplification matrix, which maps the state vector from one time step to the next. For the linear acceleration method ($\\beta=1/6, \\gamma=1/2$), the method is unconditionally stable in terms of amplitude decay (it has no numerical damping), but the spectral radius can exceed $1$ for large time steps, leading to numerical instability. The stability limit occurs at a dimensionless time step $h = \\omega \\Delta t$. The eigenvalues of the amplification matrix remain on the unit circle for $h^2 \\le 12$. For $h^2 > 12$, one eigenvalue becomes real and its magnitude exceeds $1$, causing exponential growth. Thus, the stability limit is $h_{\\text{lim}} = \\sqrt{12}$.\n\nFor a multi-degree-of-freedom (MDOF) system, the stability is governed by the highest natural frequency of the system, $\\omega_{\\max}$. The critical time step is given by:\n$$\n\\Delta t_{\\mathrm{lim}} = \\frac{h_{\\mathrm{lim}}}{\\omega_{\\max}} = \\frac{\\sqrt{12}}{\\omega_{\\max}}\n$$\n$\\omega_{\\max}$ is found by solving the generalized eigenvalue problem $K \\phi = \\omega^2 M \\phi$. Since $\\omega_{\\max}$ depends on the mass matrix $M$, we must compute $\\Delta t_{\\mathrm{lim}}$ separately for the consistent and lumped mass formulations. Generally, the consistent mass matrix leads to a higher $\\omega_{\\max}$ and consequently a more restrictive (smaller) $\\Delta t_{\\mathrm{lim}}$ compared to the lumped mass matrix.\n\nTo demonstrate the instability, we initialize the system with its highest frequency mode, where the instability is most pronounced. The initial displacement is set to the corresponding eigenvector $\\phi_{\\max}$, scaled to have a unit $M$-norm: $u_0 = \\phi_{\\max} / \\sqrt{\\phi_{\\max}^\\top M \\phi_{\\max}}$. The initial velocity is zero, $v_0 = 0$. The initial acceleration is obtained from the equation of motion: $a_0 = -M^{-1}K u_0 = -\\omega_{\\max}^2 u_0$. The system is then integrated for $N_{\\mathrm{steps}} = 300$ steps using time steps $\\Delta t = c \\cdot \\Delta t_{\\mathrm{lim}}$ with multipliers $c \\in \\{0.8, 1.0, 1.2\\}$.\n\nThe amplitude growth is monitored using the ratio $R = \\max_{0\\le n \\le N_{\\mathrm{steps}}}\\frac{\\|u_n\\|_{M}}{\\|u_0\\|_{M}}$. Since $\\|u_0\\|_{M}=1$, this simplifies to $R = \\max_{0\\le n \\le N_{\\mathrm{steps}}}\\|u_n\\|_{M}$. A \"blow-up\" is declared if $R \\ge 10$. For $c \\le 1.0$, the method is stable and we expect $R \\approx 1$. For $c > 1.0$, the method is unstable, and we anticipate exponential growth leading to $R \\ge 10$. The following program implements this entire procedure.", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef solve():\n    \"\"\"\n    Solves the problem of demonstrating conditional stability of the Newmark-beta method\n    for a 1D layered soil column.\n    \"\"\"\n\n    # 1. Define physical and numerical parameters\n    L_TOT = 12.0  # m\n    N_E = 30\n    L_E = L_TOT / N_E  # m\n    A = 1.0  # m^2\n    RHO = 2000.0  # kg/m^3\n    E_STIFF = 10e9  # Pa\n    E_SOFT = 10e6  # Pa\n    N_NODES = N_E + 1\n    N_DOF = N_NODES - 1  # After applying fixed base BC\n\n    NEWMARK_BETA = 1/6\n    NEWMARK_GAMMA = 1/2\n    N_STEPS = 300\n    BLOWUP_RATIO = 10.0\n    C_MULTIPLIERS = [0.8, 1.0, 1.2]\n\n    # Stability limit for linear acceleration method (h_lim = omega * dt_lim)\n    H_LIM = np.sqrt(12.0)\n\n    # 2. Assemble FEM matrices\n    K_global = np.zeros((N_NODES, N_NODES))\n    M_cons_global = np.zeros((N_NODES, N_NODES))\n    M_lump_global = np.zeros((N_NODES, N_NODES))\n\n    # Element mass matrices (constant for all elements)\n    m_e_cons = (RHO * A * L_E / 6.0) * np.array([[2, 1], [1, 2]])\n    m_e_lump = (RHO * A * L_E / 2.0) * np.array([[1, 0], [0, 1]])\n\n    for i in range(N_E):\n        # Determine Young's modulus based on element midpoint\n        midpoint_z = (i + 0.5) * L_E\n        if 4.0 < midpoint_z <= 8.0:\n            E = E_SOFT\n        else:\n            E = E_STIFF\n\n        # Element stiffness matrix\n        k_e = (E * A / L_E) * np.array([[1, -1], [-1, 1]])\n\n        # Assemble into global matrices\n        nodes = np.array([i, i + 1])\n        K_global[np.ix_(nodes, nodes)] += k_e\n        M_cons_global[np.ix_(nodes, nodes)] += m_e_cons\n        M_lump_global[np.ix_(nodes, nodes)] += m_e_lump\n\n    # 3. Apply boundary condition (fixed base at z=0, node 0)\n    K = K_global[1:, 1:]\n    M_cons = M_cons_global[1:, 1:]\n    M_lump = M_lump_global[1:, 1:]\n\n    mass_matrices = {\n        'consistent': M_cons,\n        'lumped': M_lump\n    }\n\n    final_results = []\n\n    for c in C_MULTIPLIERS:\n        case_results = []\n        for mass_type in ['consistent', 'lumped']:\n            M = mass_matrices[mass_type]\n\n            # 4. Solve generalized eigenvalue problem for max frequency and mode\n            eigvals, eigvecs = eigh(K, M)\n            omega_sq_max = np.max(eigvals)\n            omega_max = np.sqrt(omega_sq_max)\n            phi_max = eigvecs[:, np.argmax(eigvals)]\n\n            # 5. Set time step and initial conditions\n            dt_lim = H_LIM / omega_max\n            dt = c * dt_lim\n\n            # ICs: a) Normalize highest mode to unit M-norm\n            m_norm_phi_max = np.sqrt(phi_max.T @ M @ phi_max)\n            u = phi_max / m_norm_phi_max\n            # ICs: b) Zero velocity, c) Eqm acceleration\n            v = np.zeros(N_DOF)\n            a = -omega_sq_max * u\n\n            # 6. Perform Newmark time integration\n            max_m_norm = 1.0  # Initial norm is 1.0\n\n            # Pre-compute effective stiffness matrix\n            K_eff = M + NEWMARK_BETA * dt**2 * K\n            K_eff_inv = np.linalg.inv(K_eff)\n\n            for _ in range(N_STEPS):\n                # Solve for new acceleration\n                f_eff = -K @ (u + dt * v + (0.5 - NEWMARK_BETA) * dt**2 * a)\n                a_new = K_eff_inv @ f_eff\n                \n                # Update displacement and velocity\n                u_new = u + dt * v + dt**2 * ((0.5 - NEWMARK_BETA) * a + NEWMARK_BETA * a_new)\n                v_new = v + dt * ((1.0 - NEWMARK_GAMMA) * a + NEWMARK_GAMMA * a_new)\n\n                u, v, a = u_new, v_new, a_new\n\n                # Calculate M-norm and update maximum\n                current_m_norm = np.sqrt(u.T @ M @ u)\n                if current_m_norm > max_m_norm:\n                    max_m_norm = current_m_norm\n\n            # 7. Check for blow-up and record result\n            is_blowup = max_m_norm >= BLOWUP_RATIO\n            case_results.append(is_blowup)\n        \n        final_results.append(case_results)\n\n    # 8. Format and print the final output\n    output_str = ','.join([f\"[{str(sub[0]).lower()},{str(sub[1]).lower()}]\" for sub in final_results])\n    print(f\"[{output_str}]\")\n\n\nsolve()\n\n```", "id": "3532530"}, {"introduction": "A robust engineering design must account for the inherent uncertainty in physical parameters. This advanced practice moves beyond a single deterministic simulation to explore how uncertainty in a model's mass, stiffness, and damping parameters propagates to the final result [@problem_id:3532506]. You will implement a sensitivity analysis using the Direct Differentiation Method (DDM), a powerful technique for calculating the gradient of the system's response. This exercise provides the foundation for uncertainty quantification, enabling you to estimate the variability in a system's dynamic behavior and support more resilient designs in geomechanics.", "problem": "A single-degree-of-freedom linear geomechanical oscillator with base acceleration is governed by the second law of motion\n$$\nM \\, \\ddot{u}(t) + C \\, \\dot{u}(t) + K \\, u(t) = f(t),\n$$\nwhere $M$ is the mass, $C$ is the viscous damping coefficient, $K$ is the stiffness, $u(t)$ is the relative displacement, $\\dot{u}(t)$ is the velocity, $\\ddot{u}(t)$ is the acceleration, and $f(t)$ is the external force. For a single-degree-of-freedom base-excited system, take\n$$\nf(t) = - M \\, a_g(t),\n$$\nwhere $a_g(t)$ is the prescribed ground acceleration. Consider an implicit Newmark-$\\beta$ time integration with parameters $\\beta$ and $\\gamma$, uniform time step $\\Delta t$, and initial conditions $u(0)=0$, $\\dot{u}(0)=0$. Use the consistent initial acceleration $\\ddot{u}(0) = \\big(f(0) - C \\, \\dot{u}(0) - K \\, u(0)\\big) / M$.\n\nThe baseline physical parameters are\n$$\nM_0 = 1000 \\,\\, \\text{kg}, \\quad K_0 = 10^7 \\,\\, \\text{N/m}, \\quad \\zeta_0 = 0.05,\n$$\nand define a baseline damping coefficient by\n$$\nC_0 = 2 \\, \\zeta_0 \\, \\sqrt{K_0 \\, M_0}.\n$$\nIntroduce parametric uncertainty and design scaling through three dimensionless scalars $a_m$, $a_c$, and $a_k$ so that\n$$\nM = a_m \\, M_0, \\quad C = a_c \\, C_0, \\quad K = a_k \\, K_0.\n$$\nThe ground acceleration is prescribed as\n$$\na_g(t) = 0.5 \\, g \\, \\sin(2\\pi f \\, t),\n$$\nwith $g = 9.81 \\,\\, \\text{m/s}^2$ and $f = 5 \\,\\, \\text{Hz}$. Use a uniform time step $\\Delta t = 0.001 \\,\\, \\text{s}$ and total duration $T = 1.0 \\,\\, \\text{s}$.\n\nTask:\n1. Starting from the fundamental definitions of the implicit Newmark-$\\beta$ method and the equation of motion, derive the discrete equilibrium update at each time step and the associated effective system required to compute $u_{n+1}$, $\\dot{u}_{n+1}$, and $\\ddot{u}_{n+1}$ from $u_n$, $\\dot{u}_n$, and $\\ddot{u}_n$.\n2. By applying the chain rule to the fully discrete equations, derive a first-order sensitivity recursion that propagates the gradients of the displacement response with respect to the parameters $(\\beta, \\gamma, a_m, a_c, a_k)$ through time. Ensure that the sensitivity initial conditions are consistent with the given initial conditions and forcing.\n3. Define a scalar response functional as the displacement at the final time,\n$$\nJ(\\beta, \\gamma, a_m, a_c, a_k) = u_N,\n$$\nwhere $N = T / \\Delta t$ is the number of time steps. Derive the expressions needed to compute the gradient $\\nabla J = \\left[\\frac{\\partial J}{\\partial \\beta}, \\frac{\\partial J}{\\partial \\gamma}, \\frac{\\partial J}{\\partial a_m}, \\frac{\\partial J}{\\partial a_c}, \\frac{\\partial J}{\\partial a_k}\\right]$ via the sensitivity recursion.\n4. Suppose the parameter uncertainties in $(a_m, a_c, a_k)$ are independent and characterized by known standard deviations $(\\sigma_{a_m}, \\sigma_{a_c}, \\sigma_{a_k})$. Using a first-order linearization, estimate the standard deviation of the response functional,\n$$\n\\sigma_J \\approx \\sqrt{\\left(\\frac{\\partial J}{\\partial a_m}\\right)^2 \\sigma_{a_m}^2 + \\left(\\frac{\\partial J}{\\partial a_c}\\right)^2 \\sigma_{a_c}^2 + \\left(\\frac{\\partial J}{\\partial a_k}\\right)^2 \\sigma_{a_k}^2 }.\n$$\n\nImplement a complete, runnable program that for each test case below computes and reports:\n- The final displacement $J$ in meters,\n- The gradient components $\\frac{\\partial J}{\\partial \\beta}$, $\\frac{\\partial J}{\\partial \\gamma}$, $\\frac{\\partial J}{\\partial a_m}$, $\\frac{\\partial J}{\\partial a_c}$, $\\frac{\\partial J}{\\partial a_k}$ (all in meters, since the parameters are dimensionless),\n- The estimated standard deviation $\\sigma_J$ in meters.\n\nAll displacements and derived quantities must be expressed in meters. Angles, if any arise in your implementation, must be in radians. Do not use a percentage sign; any fractional quantities must be reported as decimals.\n\nTest suite (three cases):\n- Case A (average acceleration with baseline scaling): $(\\beta, \\gamma, a_m, a_c, a_k, \\sigma_{a_m}, \\sigma_{a_c}, \\sigma_{a_k}) = \\left(0.25, 0.5, 1.0, 1.0, 1.0, 0.05, 0.05, 0.05\\right)$.\n- Case B (linear acceleration variant with reduced damping scaling): $(\\beta, \\gamma, a_m, a_c, a_k, \\sigma_{a_m}, \\sigma_{a_c}, \\sigma_{a_k}) = \\left(\\frac{1}{6}, 0.5, 1.0, 0.2, 1.0, 0.1, 0.05, 0.05\\right)$.\n- Case C (non-classical parameter set and increased stiffness and mass scaling): $(\\beta, \\gamma, a_m, a_c, a_k, \\sigma_{a_m}, \\sigma_{a_c}, \\sigma_{a_k}) = \\left(0.3, 0.6, 1.2, 1.0, 1.5, 0.02, 0.02, 0.02\\right)$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case contributes a sublist of seven floating-point numbers in the following order:\n$$\n\\left[ J, \\, \\frac{\\partial J}{\\partial \\beta}, \\, \\frac{\\partial J}{\\partial \\gamma}, \\, \\frac{\\partial J}{\\partial a_m}, \\, \\frac{\\partial J}{\\partial a_c}, \\, \\frac{\\partial J}{\\partial a_k}, \\, \\sigma_J \\right].\n$$\nThus the overall output must be\n$$\n\\big[ [\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot], [\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot], [\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot] \\big].\n$$", "solution": "The problem requires the derivation and implementation of a direct differentiation sensitivity analysis for a single-degree-of-freedom (SDOF) linear oscillator subjected to base excitation, integrated in time using the implicit Newmark-$\\beta$ method. The final goal is to compute the displacement at the final time, its gradient with respect to system and numerical parameters, and a first-order estimate of the response standard deviation.\n\nThe governing equation of motion is:\n$$\nM \\ddot{u}(t) + C \\dot{u}(t) + K u(t) = f(t)\n$$\nwhere the forcing term due to base acceleration $a_g(t)$ is $f(t) = -M a_g(t)$. The initial conditions are $u(0)=0$ and $\\dot{u}(0)=0$. The consistent initial acceleration is $\\ddot{u}(0) = (f(0) - C\\dot{u}(0) - K u(0))/M$. Given $f(t) = -M \\cdot 0.5g \\sin(2\\pi f t)$, $f(0)=0$, which leads to $\\ddot{u}(0)=0$. The initial state is thus $(u_0, \\dot{u}_0, \\ddot{u}_0)=(0,0,0)$.\n\nThe parameters of the system are defined by scaling factors $(a_m, a_c, a_k)$ applied to baseline values $(M_0, C_0, K_0)$.\n$M = a_m M_0$, $C = a_c C_0$, $K = a_k K_0$.\n\nLet $\\mathbf{p} = (\\beta, \\gamma, a_m, a_c, a_k)$ be the vector of parameters for the sensitivity analysis.\n\n### Task 1: Discrete Equilibrium Update (Newmark-$\\beta$ Method)\n\nThe implicit Newmark-$\\beta$ method defines the displacement $u_{n+1}$ and velocity $\\dot{u}_{n+1}$ at time step $t_{n+1} = t_n + \\Delta t$ based on the state at $t_n$ and the acceleration at $t_{n+1}$, $\\ddot{u}_{n+1}$:\n$$\nu_{n+1} = u_n + \\Delta t \\dot{u}_n + \\left(\\frac{1}{2} - \\beta\\right) \\Delta t^2 \\ddot{u}_n + \\beta \\Delta t^2 \\ddot{u}_{n+1} \\\\\n\\dot{u}_{n+1} = \\dot{u}_n + (1 - \\gamma) \\Delta t \\ddot{u}_n + \\gamma \\Delta t \\ddot{u}_{n+1}\n$$\nThe equation of motion must hold at time $t_{n+1}$:\n$$\nM \\ddot{u}_{n+1} + C \\dot{u}_{n+1} + K u_{n+1} = f_{n+1}\n$$\nTo solve for the unknowns at step $n+1$, we first express $\\ddot{u}_{n+1}$ and $\\dot{u}_{n+1}$ in terms of the unknown displacement $u_{n+1}$ and known quantities from step $n$. From the first Newmark equation, we isolate $\\ddot{u}_{n+1}$:\n$$\n\\ddot{u}_{n+1} = \\frac{1}{\\beta \\Delta t^2} (u_{n+1} - u_n) - \\frac{1}{\\beta \\Delta t} \\dot{u}_n - \\left(\\frac{1}{2\\beta} - 1\\right) \\ddot{u}_n\n$$\nSubstituting this into the velocity update equation gives $\\dot{u}_{n+1}$ in terms of $u_{n+1}$:\n$$\n\\dot{u}_{n+1} = \\frac{\\gamma}{\\beta \\Delta t} (u_{n+1} - u_n) + \\left(1 - \\frac{\\gamma}{\\beta}\\right) \\dot{u}_n + \\Delta t \\left(1 - \\frac{\\gamma}{2\\beta}\\right) \\ddot{u}_n\n$$\nNow, substituting the expressions for $\\ddot{u}_{n+1}$ and $\\dot{u}_{n+1}$ into the equation of motion yields a linear system for the single unknown $u_{n+1}$:\n$$\n\\left(K + \\frac{\\gamma}{\\beta \\Delta t} C + \\frac{1}{\\beta \\Delta t^2} M\\right) u_{n+1} = f_{n+1} + M\\left(\\dots\\right) + C\\left(\\dots\\right)\n$$\nThis is the discrete equilibrium update, which can be written in the form of an effective system:\n$$\n\\hat{K} u_{n+1} = \\hat{f}_{n+1}\n$$\nThe effective stiffness, $\\hat{K}$, is:\n$$\n\\hat{K} = K + \\frac{\\gamma}{\\beta \\Delta t} C + \\frac{1}{\\beta \\Delta t^2} M\n$$\nThe effective force, $\\hat{f}_{n+1}$, aggregates the external force at $t_{n+1}$ and all terms depending on the state at $t_n$:\n$$\n\\hat{f}_{n+1} = f_{n+1} + M \\left[ \\frac{1}{\\beta \\Delta t^2} u_n + \\frac{1}{\\beta \\Delta t} \\dot{u}_n + \\left(\\frac{1}{2\\beta} - 1\\right) \\ddot{u}_n \\right] + C \\left[ \\frac{\\gamma}{\\beta \\Delta t} u_n + \\left(\\frac{\\gamma}{\\beta} - 1\\right) \\dot{u}_n + \\Delta t \\left(\\frac{\\gamma}{2\\beta} - 1\\right) \\ddot{u}_n \\right]\n$$\nThe solution proceeds by first solving for $u_{n+1} = \\hat{K}^{-1} \\hat{f}_{n+1}$, and then updating $\\ddot{u}_{n+1}$ and $\\dot{u}_{n+1}$ using the relations derived above.\n\n### Task 2: First-Order Sensitivity Recursion\n\nWe use the Direct Differentiation Method (DDM) to find the sensitivity of the response with respect to a generic parameter $p \\in \\mathbf{p}$. This involves differentiating the discrete system of equations with respect to $p$. Let $(\\cdot)^{,p}$ denote the derivative $\\frac{\\partial (\\cdot)}{\\partial p}$.\n\nDifferentiating the effective system $\\hat{K} u_{n+1} = \\hat{f}_{n+1}$ with respect to $p$ yields:\n$$\n\\hat{K}^{,p} u_{n+1} + \\hat{K} u_{n+1}^{,p} = \\hat{f}_{n+1}^{,p}\n$$\nRearranging to solve for the displacement sensitivity $u_{n+1}^{,p}$:\n$$\n\\hat{K} u_{n+1}^{,p} = \\hat{f}_{n+1}^{,p} - \\hat{K}^{,p} u_{n+1}\n$$\nThe same effective stiffness operator $\\hat{K}$ from the primary analysis is used to solve for the displacement sensitivity. The right-hand side is a pseudo-force for the sensitivity problem, which depends on the primary solution $(u_{n+1})$ and the sensitivities from the previous step $(u_n^{,p}, \\dot{u}_n^{,p}, \\ddot{u}_n^{,p})$.\n\nOnce $u_{n+1}^{,p}$ is computed, the velocity and acceleration sensitivities are updated by differentiating their respective update formulas:\n$$\n\\ddot{u}_{n+1}^{,p} = \\frac{\\partial}{\\partial p} \\left[ \\frac{1}{\\beta \\Delta t^2} (u_{n+1} - u_n) - \\frac{1}{\\beta \\Delta t} \\dot{u}_n - \\left(\\frac{1}{2\\beta} - 1\\right) \\ddot{u}_n \\right]\n$$\n$$\n\\dot{u}_{n+1}^{,p} = \\frac{\\partial}{\\partial p} \\left[ \\dot{u}_n + (1 - \\gamma) \\Delta t \\ddot{u}_n + \\gamma \\Delta t \\ddot{u}_{n+1} \\right]\n$$\nExpanding these gives explicit update rules. For example, for $\\ddot{u}_{n+1}^{,p}$:\n$$\n\\ddot{u}_{n+1}^{,p} = \\frac{\\partial c_0}{\\partial p}(u_{n+1}-u_n) + c_0(u_{n+1}^{,p} - u_n^{,p}) - \\frac{\\partial c_2}{\\partial p}\\dot{u}_n - c_2\\dot{u}_{n}^{,p} - \\frac{\\partial c_3}{\\partial p}\\ddot{u}_n - c_3\\ddot{u}_{n}^{,p}\n$$\nwhere $c_0=\\frac{1}{\\beta\\Delta t^2}$, $c_2=\\frac{1}{\\beta\\Delta t}$, and $c_3=\\frac{1}{2\\beta}-1$.\n\nThe initial conditions for the sensitivities are found by differentiating the primary initial conditions:\n$u_0 = 0 \\implies u_0^{,p} = 0$.\n$\\dot{u}_0 = 0 \\implies \\dot{u}_0^{,p} = 0$.\n$\\ddot{u}_0 = 0 \\implies \\ddot{u}_0^{,p} = 0$.\nThe sensitivity analysis starts from a zero state and is driven by the pseudo-force term at each step.\n\nThe overall algorithm is as follows:\nFor each time step $n=0, 1, \\dots, N-1$:\n1. Solve the primary system: compute $\\hat{K}$ and $\\hat{f}_{n+1}$, solve for $u_{n+1}$, then update $\\dot{u}_{n+1}$ and $\\ddot{u}_{n+1}$.\n2. For each parameter $p \\in \\mathbf{p}$:\n    a. Compute the sensitivity pseudo-force $F_{sens} = \\hat{f}_{n+1}^{,p} - \\hat{K}^{,p} u_{n+1}$. This force includes terms from the direct differentiation of parameters at step $n+1$ and terms that propagate the sensitivities from step $n$.\n    b. Solve for the displacement sensitivity: $u_{n+1}^{,p} = \\hat{K}^{-1} F_{sens}$.\n    c. Update the velocity and acceleration sensitivities, $\\dot{u}_{n+1}^{,p}$ and $\\ddot{u}_{n+1}^{,p}$, using their differentiated update formulas.\n\n### Task 3: Gradient of Response Functional\n\nThe scalar response functional is the displacement at the final time:\n$$\nJ(\\mathbf{p}) = u_N, \\quad \\text{where } N = T / \\Delta t\n$$\nThe gradient of this functional, $\\nabla J$, is a vector whose components are the partial derivatives of $J$ with respect to each parameter in $\\mathbf{p}$:\n$$\n\\nabla J = \\left[ \\frac{\\partial J}{\\partial p_1}, \\frac{\\partial J}{\\partial p_2}, \\dots \\right] = \\left[ \\frac{\\partial u_N}{\\partial p_1}, \\frac{\\partial u_N}{\\partial p_2}, \\dots \\right]\n$$\nThe components of the gradient are precisely the displacement sensitivities $u_N^{,p_i}$ computed at the final time step $N$. The sensitivity analysis directly yields the required gradient vector.\n$$\n\\nabla J = \\left[u_N^{,\\beta}, \\, u_N^{,\\gamma}, \\, u_N^{,a_m}, \\, u_N^{,a_c}, \\, u_N^{,a_k}\\right]\n$$\n\n### Task 4: Uncertainty Propagation\n\nGiven that the uncertainties in the scaling parameters $(a_m, a_c, a_k)$ are independent and characterized by standard deviations $(\\sigma_{a_m}, \\sigma_{a_c}, \\sigma_{a_k})$, we can estimate the standard deviation of the response functional, $\\sigma_J$, using a first-order Taylor series expansion of $J$ about the mean values of the parameters. The variance of $J$, $\\sigma_J^2$, is approximated by:\n$$\n\\sigma_J^2 \\approx \\sum_{i} \\sum_{j} \\frac{\\partial J}{\\partial p_i} \\frac{\\partial J}{\\partial p_j} \\text{Cov}(p_i, p_j)\n$$\nSince the parameters $a_m, a_c, a_k$ are assumed to be independent, their covariances are zero, i.e., $\\text{Cov}(a_i, a_j) = 0$ for $i \\neq j$. The variance simplifies to:\n$$\n\\sigma_J^2 \\approx \\left(\\frac{\\partial J}{\\partial a_m}\\right)^2 \\sigma_{a_m}^2 + \\left(\\frac{\\partial J}{\\partial a_c}\\right)^2 \\sigma_{a_c}^2 + \\left(\\frac{\\partial J}{\\partial a_k}\\right)^2 \\sigma_{a_k}^2\n$$\nThe estimated standard deviation of the response is the square root of this variance:\n$$\n\\sigma_J \\approx \\sqrt{\\left(\\frac{\\partial J}{\\partial a_m}\\right)^2 \\sigma_{a_m}^2 + \\left(\\frac{\\partial J}{\\partial a_c}\\right)^2 \\sigma_{a_c}^2 + \\left(\\frac{\\partial J}{\\partial a_k}\\right)^2 \\sigma_{a_k}^2 }\n$$\nThe required partial derivatives are the components of the gradient $\\nabla J$ calculated in Task 3.", "answer": "```python\nimport numpy as np\n\ndef run_analysis(params):\n    \"\"\"\n    Performs the Newmark-beta time integration and sensitivity analysis\n    for a single-degree-of-freedom system.\n    \"\"\"\n    beta, gamma, a_m, a_c, a_k, sigma_am, sigma_ac, sigma_ak = params\n\n    # Baseline physical parameters\n    M0 = 1000.0  # kg\n    K0 = 1.0e7   # N/m\n    zeta0 = 0.05 # damping ratio\n    C0 = 2.0 * zeta0 * np.sqrt(K0 * M0)\n\n    # Scaled parameters\n    M = a_m * M0\n    C = a_c * C0\n    K = a_k * K0\n\n    # Ground motion parameters\n    g = 9.81  # m/s^2\n    f_exc = 5.0  # Hz\n    omega_exc = 2.0 * np.pi * f_exc\n\n    def ag(t):\n        return 0.5 * g * np.sin(omega_exc * t)\n\n    def force(t, M_val):\n        return -M_val * ag(t)\n\n    # Time integration parameters\n    dt = 0.001  # s\n    T_total = 1.0  # s\n    N_steps = int(T_total / dt)\n    t_space = np.linspace(0, T_total, N_steps + 1)\n\n    # State vectors (displacement, velocity, acceleration)\n    u = np.zeros(N_steps + 1)\n    u_dot = np.zeros(N_steps + 1)\n    u_ddot = np.zeros(N_steps + 1)\n    \n    # Initial conditions are all zero\n    # u[0], u_dot[0], u_ddot[0] are already 0.0\n\n    # Sensitivity state vectors\n    # Parameters for sensitivity: [beta, gamma, am, ac, ak]\n    param_keys = ['beta', 'gamma', 'am', 'ac', 'ak']\n    num_params = len(param_keys)\n    \n    # Derivatives of u, u_dot, u_ddot w.r.t. parameters\n    du_dp = np.zeros((N_steps + 1, num_params))\n    dudot_dp = np.zeros((N_steps + 1, num_params))\n    duddot_dp = np.zeros((N_steps + 1, num_params))\n\n    # Newmark constants and their derivatives\n    c0 = 1.0 / (beta * dt**2)\n    c1 = gamma / (beta * dt)\n    c2 = 1.0 / (beta * dt)\n    c3 = 1.0 / (2.0 * beta) - 1.0\n    c4 = gamma / beta - 1.0\n    c5 = dt * (gamma / (2.0 * beta) - 1.0)\n\n    dc_dp = {\n        'beta': [\n            -c0 / beta, # dc0/dbeta\n            -c1 / beta, # dc1/dbeta\n            -c2 / beta, # dc2/dbeta\n            -1.0 / (2.0 * beta**2), # dc3/dbeta\n            -gamma / beta**2, # dc4/dbeta\n            -dt * gamma / (2.0 * beta**2) # dc5/dbeta\n        ],\n        'gamma': [0, c2, 0, 0, 1.0 / beta, dt / (2.0 * beta)]\n    }\n\n    # Effective stiffness for the primary analysis\n    K_hat = K + c1 * C + c0 * M\n    inv_K_hat = 1.0 / K_hat\n\n    # Time stepping loop\n    for n in range(N_steps):\n        # --- Primary Analysis ---\n        f_next = force(t_space[n+1], M)\n        \n        A_n = c0 * u[n] + c2 * u_dot[n] + c3 * u_ddot[n]\n        B_n = c1 * u[n] + c4 * u_dot[n] + c5 * u_ddot[n]\n        \n        f_hat = f_next + M * A_n + C * B_n\n        \n        u[n+1] = inv_K_hat * f_hat\n        u_ddot[n+1] = c0 * (u[n+1] - u[n]) - c2 * u_dot[n] - c3 * u_ddot[n]\n        u_dot[n+1] = u_dot[n] + (1.0 - gamma) * dt * u_ddot[n] + gamma * dt * u_ddot[n+1]\n\n        # --- Sensitivity Analysis ---\n        for j, p_key in enumerate(param_keys):\n            # Derivatives of M, C, K, f w.r.t parameter p\n            dM_dp, dC_dp, dK_dp, df_dp = 0, 0, 0, 0\n            if p_key == 'am':\n                dM_dp = M0\n                df_dp = -M0 * ag(t_space[n+1])\n            elif p_key == 'ac':\n                dC_dp = C0\n            elif p_key == 'ak':\n                dK_dp = K0\n\n            # Derivatives of Newmark constants w.r.t. p\n            dc0_dp, dc1_dp, dc2_dp, dc3_dp, dc4_dp, dc5_dp = (0,)*6\n            if p_key in dc_dp:\n                dc0_dp, dc1_dp, dc2_dp, dc3_dp, dc4_dp, dc5_dp = dc_dp[p_key]\n                \n            # Derivative of effective stiffness\n            dKhat_dp = dK_dp + dc1_dp * C + c1 * dC_dp + dc0_dp * M + c0 * dM_dp\n\n            # Compute RHS for sensitivity equation: f_sens = df_hat/dp - dK_hat/dp * u_n+1\n            \n            # Terms propagating sensitivities from step n\n            propagated_A = c0 * du_dp[n, j] + c2 * dudot_dp[n, j] + c3 * duddot_dp[n, j]\n            propagated_B = c1 * du_dp[n, j] + c4 * dudot_dp[n, j] + c5 * duddot_dp[n, j]\n            \n            # Terms from direct differentiation\n            direct_A = dc0_dp * u[n] + dc2_dp * u_dot[n] + dc3_dp * u_ddot[n]\n            direct_B = dc1_dp * u[n] + dc4_dp * u_dot[n] + dc5_dp * u_ddot[n]\n            \n            dfhat_dp = (df_dp + dM_dp * A_n + M * (direct_A + propagated_A) +\n                        dC_dp * B_n + C * (direct_B + propagated_B))\n            \n            f_sens = dfhat_dp - dKhat_dp * u[n+1]\n            \n            # Solve for displacement sensitivity\n            du_dp[n+1, j] = inv_K_hat * f_sens\n            \n            # Update acceleration and velocity sensitivities\n            d_gamma_dp = 1.0 if p_key == 'gamma' else 0.0\n            \n            duddot_dp[n+1, j] = (dc0_dp * (u[n+1] - u[n]) + \n                                 c0 * (du_dp[n+1, j] - du_dp[n, j]) -\n                                 dc2_dp * u_dot[n] - c2 * dudot_dp[n, j] -\n                                 dc3_dp * u_ddot[n] - c3 * duddot_dp[n, j])\n            \n            dudot_dp[n+1, j] = (dudot_dp[n, j] - \n                                d_gamma_dp * dt * u_ddot[n] + (1.0 - gamma) * dt * duddot_dp[n, j] +\n                                d_gamma_dp * dt * u_ddot[n+1] + gamma * dt * duddot_dp[n+1, j])\n\n    # Final displacement\n    J = u[-1]\n    \n    # Gradient of J\n    grad_J = du_dp[-1, :] # [dJ/dbeta, dJ/dgamma, dJ/dam, dJ/dac, dJ/dak]\n    \n    # Standard deviation of J\n    dJ_dam = grad_J[2]\n    dJ_dac = grad_J[3]\n    dJ_dak = grad_J[4]\n    \n    sigma_J_sq = (dJ_dam**2 * sigma_am**2 + \n                  dJ_dac**2 * sigma_ac**2 + \n                  dJ_dak**2 * sigma_ak**2)\n    sigma_J = np.sqrt(sigma_J_sq)\n    \n    return [J, *grad_J, sigma_J]\n\ndef solve():\n    test_cases = [\n        (0.25, 0.5, 1.0, 1.0, 1.0, 0.05, 0.05, 0.05),\n        (1.0/6.0, 0.5, 1.0, 0.2, 1.0, 0.1, 0.05, 0.05),\n        (0.3, 0.6, 1.2, 1.0, 1.5, 0.02, 0.02, 0.02),\n    ]\n\n    results = []\n    for case in test_cases:\n        case_results = run_analysis(case)\n        results.append(f\"[{','.join(f'{x:.6e}' for x in case_results)}]\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3532506"}]}