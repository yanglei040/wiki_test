{"hands_on_practices": [{"introduction": "A critical issue in local continuum damage models is their pathological mesh dependency when strain softening is present, where damage localizes into a zone of zero width. This practice [@problem_id:3510328] addresses this fundamental problem by introducing a gradient-enhanced damage formulation. By deriving and numerically solving the governing equations, you will gain hands-on experience with regularization techniques and directly investigate how an internal length scale, $l$, restores well-posedness by controlling the width of the damage zone.", "problem": "Consider a one-dimensional bar occupying the interval $x \\in [0,L]$ under monotonically increasing tension. The scalar damage variable $D(x)$ satisfies $D(x) \\in [0,1]$, where $D(x) = 0$ denotes undamaged material and $D(x) = 1$ denotes fully damaged material. In a regularized gradient damage framework, the quasi-static steady state of $D(x)$ is obtained by minimizing a quadratic energy functional that penalizes gradients of $D(x)$ to introduce an internal length scale. Let the prescribed energy release rate field be $Y(x)$ and the material strength parameter be $Y_c > 0$. Define the normalized driving term $s(x)$ by\n$$\ns(x) = \\min\\left\\{1,\\ \\frac{Y(x)}{Y_c}\\right\\}.\n$$\nAdopt the regularized energy functional\n$$\n\\Pi[D] = \\int_{0}^{L} \\left( \\frac{1}{2}\\left(D(x) - s(x)\\right)^2 + \\frac{l^2}{2}\\left(\\frac{dD}{dx}(x)\\right)^2 \\right)\\, dx,\n$$\nwhere $l > 0$ is the internal length parameter that controls the width of the damage localization zone.\n\nYour tasks are:\n- Starting from the above functional and using the calculus of variations, derive the necessary condition for stationarity of $\\Pi[D]$ under arbitrary admissible variations of $D(x)$, and obtain both the governing differential equation for $D(x)$ and the natural boundary conditions on $[0,L]$.\n- For a given $Y(x)$, solve the derived steady-state equation numerically to obtain $D(x)$ and quantify the characteristic width of the localization zone as the full width at half maximum (FWHM) of $D(x)$, i.e., the distance between the two points where $D(x)$ equals one-half of its maximum value. If the half-maximum level is not crossed within the domain, define the FWHM to be $L$.\n- Implement a uniform finite-difference scheme on a grid of $N$ nodes with $N = 1001$ uniformly spaced points over $[0,L]$. Use the natural boundary conditions that arise from the variational derivation.\n- Use the following test suite, in which the prescribed energy release rate is a centered Gaussian:\n$$\nY(x) = Y_{\\max}\\, \\exp\\!\\left(-\\frac{(x - L/2)^2}{2\\,a^2}\\right),\n$$\nwith $L = 1$, $Y_c = 1$, and with $(Y_{\\max}, a, l)$ taking the following combinations:\n    - Test $1$: $Y_{\\max} = 1.5$, $a = 0.06$, $l = 0.02$.\n    - Test $2$: $Y_{\\max} = 1.5$, $a = 0.06$, $l = 0.005$.\n    - Test $3$: $Y_{\\max} = 1.5$, $a = 0.06$, $l = 0.08$.\n    - Test $4$: $Y_{\\max} = 0.9$, $a = 0.06$, $l = 0.02$.\n- For each test, compute the damage profile $D(x)$ and the FWHM of $D(x)$. Report the normalized FWHM $\\tilde{w} = \\mathrm{FWHM}/L$ (dimensionless, no physical units), rounded to six decimal places.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of Tests $1$ through $4$. For example, the output should look like\n$[r_1,r_2,r_3,r_4]$,\nwhere each $r_i$ is the normalized FWHM for Test $i$, rounded to six decimal places.", "solution": "The problem asks for the derivation of the governing equation for a scalar damage variable $D(x)$ from a given energy functional, a numerical solution of the resulting boundary value problem, and the calculation of the full width at half maximum (FWHM) for several test cases.\n\n### Part 1: Variational Derivation\n\nThe analysis begins with the provided energy functional $\\Pi[D]$, which is defined over the domain $x \\in [0,L]$:\n$$\n\\Pi[D] = \\int_{0}^{L} \\mathcal{L}\\left(x, D(x), D'(x)\\right) \\, dx\n$$\nwhere $D'(x) = \\frac{dD}{dx}(x)$ and the Lagrangian density $\\mathcal{L}$ is given by:\n$$\n\\mathcal{L}\\left(x, D, D'\\right) = \\frac{1}{2}\\left(D(x) - s(x)\\right)^2 + \\frac{l^2}{2}\\left(D'(x)\\right)^2\n$$\nHere, $s(x) = \\min\\left\\{1, Y(x)/Y_c\\right\\}$ is the normalized driving term, and $l > 0$ is the internal length parameter.\n\nTo find the steady-state damage profile $D(x)$, we seek the function that minimizes this energy functional. The necessary condition for stationarity of $\\Pi[D]$ is that its first variation, $\\delta \\Pi$, must vanish for any arbitrary admissible variation $\\delta D(x)$. The first variation is given by:\n$$\n\\delta \\Pi = \\int_{0}^{L} \\left( \\frac{\\partial \\mathcal{L}}{\\partial D} \\delta D + \\frac{\\partial \\mathcal{L}}{\\partial D'} \\delta D' \\right) \\, dx = 0\n$$\nThe partial derivatives of the Lagrangian $\\mathcal{L}$ with respect to $D$ and $D'$ are:\n$$\n\\frac{\\partial \\mathcal{L}}{\\partial D} = D(x) - s(x)\n$$\n$$\n\\frac{\\partial \\mathcal{L}}{\\partial D'} = l^2 D'(x)\n$$\nSubstituting these into the expression for $\\delta \\Pi$ yields:\n$$\n\\delta \\Pi = \\int_{0}^{L} \\left( \\left(D(x) - s(x)\\right) \\delta D(x) + l^2 D'(x) \\delta D'(x) \\right) \\, dx = 0\n$$\nTo eliminate $\\delta D'$, we integrate the second term by parts, where $\\int u \\, dv = [uv] - \\int v \\, du$. Let $u = l^2 D'(x)$ and $dv = \\delta D'(x) \\, dx$, so that $du = l^2 D''(x) \\, dx$ and $v = \\delta D(x)$. This gives:\n$$\n\\int_{0}^{L} l^2 D'(x) \\delta D'(x) \\, dx = \\left[ l^2 D'(x) \\delta D(x) \\right]_{0}^{L} - \\int_{0}^{L} l^2 D''(x) \\delta D(x) \\, dx\n$$\nSubstituting this back into the expression for $\\delta \\Pi$:\n$$\n\\delta \\Pi = \\int_{0}^{L} \\left( D(x) - s(x) - l^2 D''(x) \\right) \\delta D(x) \\, dx + \\left[ l^2 D'(x) \\delta D(x) \\right]_{0}^{L} = 0\n$$\nThis equation must hold for all admissible variations $\\delta D(x)$. By the fundamental lemma of calculus of variations, for the integral term to be zero for any $\\delta D(x)$ in the open interval $(0, L)$, the integrand multiplying $\\delta D(x)$ must be zero. This yields the Euler-Lagrange equation, which is the governing differential equation for $D(x)$:\n$$\nD(x) - s(x) - l^2 D''(x) = 0\n$$\nRearranging gives a linear, second-order ordinary differential equation (a form of the Helmholtz equation):\n$$\n-l^2 \\frac{d^2D}{dx^2} + D(x) = s(x)\n$$\nFurthermore, the boundary term must also vanish:\n$$\n\\left[ l^2 D'(x) \\delta D(x) \\right]_{0}^{L} = l^2 D'(L) \\delta D(L) - l^2 D'(0) \\delta D(0) = 0\n$$\nSince no specific values for $D(0)$ and $D(L)$ are prescribed (i.e., no essential boundary conditions are imposed), the variations $\\delta D(0)$ and $\\delta D(L)$ are arbitrary. For the boundary term to be zero, their coefficients must be zero. This provides the **natural boundary conditions**:\n$$\n\\frac{dD}{dx}(0) = 0 \\quad \\text{and} \\quad \\frac{dD}{dx}(L) = 0\n$$\nThese are homogeneous Neumann boundary conditions, implying that the damage gradient is zero at the ends of the bar.\n\n### Part 2: Numerical Implementation Strategy\n\nThe derived boundary value problem is solved numerically using a finite-difference method on a uniform grid.\n\n**Discretization:**\nThe domain $[0,L]$ is discretized into $N$ equally spaced nodes $x_i = i \\cdot \\Delta x$ for $i=0, 1, \\dots, N-1$, where the grid spacing is $\\Delta x = L/(N-1)$. Let $D_i = D(x_i)$ and $s_i = s(x_i)$.\n\n**Finite-Difference Approximation:**\nThe second derivative $D''(x)$ at an interior node $x_i$ ($1 \\le i \\le N-2$) is approximated using a second-order central difference scheme:\n$$\n\\frac{d^2D}{dx^2}(x_i) \\approx \\frac{D_{i-1} - 2D_i + D_{i+1}}{(\\Delta x)^2}\n$$\nSubstituting this into the governing ODE gives the discretized equation for an interior node:\n$$\n-l^2 \\left( \\frac{D_{i-1} - 2D_i + D_{i+1}}{(\\Delta x)^2} \\right) + D_i = s_i\n$$\nRearranging a bit, we get:\n$$\n\\left(-\\frac{l^2}{(\\Delta x)^2}\\right) D_{i-1} + \\left(1 + \\frac{2l^2}{(\\Delta x)^2}\\right) D_i + \\left(-\\frac{l^2}{(\\Delta x)^2}\\right) D_{i+1} = s_i\n$$\n\n**Boundary Conditions:**\nThe Neumann boundary conditions $D'(0)=0$ and $D'(L)=0$ are handled using ghost points and central differences to maintain second-order accuracy.\nAt the left boundary ($x_0=0$), $D'(0) \\approx \\frac{D_1 - D_{-1}}{2\\Delta x} = 0$, which implies $D_{-1} = D_1$. Applying the discretized ODE at $i=0$ and substituting $D_{-1}=D_1$:\n$$\n\\left(1 + \\frac{2l^2}{(\\Delta x)^2}\\right) D_0 + \\left(-\\frac{2l^2}{(\\Delta x)^2}\\right) D_1 = s_0\n$$\nAt the right boundary ($x_{N-1}=L$), $D'(L) \\approx \\frac{D_N - D_{N-2}}{2\\Delta x} = 0$, which implies $D_N = D_{N-2}$. Applying the discretized ODE at $i=N-1$ and substituting $D_N=D_{N-2}$:\n$$\n\\left(-\\frac{2l^2}{(\\Delta x)^2}\\right) D_{N-2} + \\left(1 + \\frac{2l^2}{(\\Delta x)^2}\\right) D_{N-1} = s_{N-1}\n$$\n\n**Linear System:**\nThese equations form a system of $N$ linear algebraic equations in the $N$ unknowns $D_0, D_1, \\dots, D_{N-1}$, which can be written in matrix form as $\\mathbf{A}\\mathbf{D} = \\mathbf{s}$. The matrix $\\mathbf{A}$ is a symmetric, tridiagonal matrix with modified entries in the first and last rows to account for the boundary conditions. This system can be solved using standard linear algebra routines.\n\n### Part 3: FWHM Calculation\n\nOnce the discrete solution vector $\\mathbf{D}$ is obtained, the FWHM is calculated as follows:\n1.  Find the maximum damage value, $D_{\\max} = \\max_i(D_i)$.\n2.  Calculate the half-maximum value, $D_{\\text{half}} = D_{\\max} / 2$.\n3.  As per the problem statement, if the damage profile does not cross the $D_{\\text{half}}$ level (which occurs if $D_0 \\ge D_{\\text{half}}$), the FWHM is defined as $L$.\n4.  Otherwise, find the two locations $x_{\\text{left}}$ and $x_{\\text{right}}$ where $D(x) = D_{\\text{half}}$. This is done by finding the grid indices $k$ where the sign of $(D_k - D_{\\text{half}})$ changes. Two such crossings are expected due to the symmetric nature of the problem.\n5.  Linear interpolation is used between the adjacent grid points at each crossing to find $x_{\\text{left}}$ and $x_{\\text{right}}$ with sub-grid accuracy. For a crossing between $x_k$ and $x_{k+1}$:\n    $$\n    x_{\\text{cross}} = x_k + \\Delta x \\frac{D_{\\text{half}} - D_k}{D_{k+1} - D_k}\n    $$\n6.  The FWHM is then computed as $\\mathrm{FWHM} = x_{\\text{right}} - x_{\\text{left}}$.\n7.  Finally, the normalized FWHM is $\\tilde{w} = \\mathrm{FWHM}/L$.\n\nThis procedure is applied to each test case to compute the required values.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the gradient-damage problem for a 1D bar and computes the FWHM of the damage profile.\n    \"\"\"\n    # Define the common parameters and test cases from the problem statement.\n    L = 1.0\n    Y_c = 1.0\n    N = 1001\n\n    test_cases = [\n        # (Y_max, a, l)\n        (1.5, 0.06, 0.02),   # Test 1\n        (1.5, 0.06, 0.005),  # Test 2\n        (1.5, 0.06, 0.08),   # Test 3\n        (0.9, 0.06, 0.02),   # Test 4\n    ]\n\n    results = []\n\n    # Discretize the domain\n    dx = L / (N - 1)\n    x = np.linspace(0.0, L, N)\n\n    for Y_max, a, l in test_cases:\n        # 1. Calculate the normalized driving term s(x)\n        Y = Y_max * np.exp(-(x - L/2)**2 / (2 * a**2))\n        s = np.minimum(1.0, Y / Y_c)\n\n        # 2. Set up the linear system of equations AD = s for the finite difference scheme\n        A = np.zeros((N, N))\n        \n        # Coefficients from the discretized ODE\n        c1 = -l**2 / dx**2\n        c2 = 1.0 - 2.0 * c1\n\n        # Assemble the matrix A\n        # Diagonal elements\n        main_diag = np.full(N, c2)\n        off_diag = np.full(N - 1, c1)\n        \n        A += np.diag(main_diag)\n        A += np.diag(off_diag, k=1)\n        A += np.diag(off_diag, k=-1)\n\n        # Apply natural boundary conditions (D'=0) by modifying the first and last rows\n        # D'_0 = 0 - D_{-1} = D_1\n        A[0, 1] = 2.0 * c1\n        # D'_{N-1} = 0 - D_N = D_{N-2}\n        A[N - 1, N - 2] = 2.0 * c1\n        \n        # 3. Solve the linear system for the damage profile D\n        D = np.linalg.solve(A, s)\n\n        # 4. Calculate the Full Width at Half Maximum (FWHM)\n        D_max = np.max(D)\n        D_half = D_max / 2.0\n        \n        # Check for the edge case where the half-maximum level is not crossed\n        if D[0] = D_half:\n            fwhm = L\n        else:\n            # Find indices where the profile crosses the half-maximum level\n            # These are the indices k where the sign of (D - D_half) changes between k and k+1\n            cross_indices = np.where(np.diff(np.sign(D - D_half)) != 0)[0]\n            \n            if len(cross_indices)  2:\n                # Should not happen for the given symmetric profiles unless D_max is close to D at boundary\n                fwhm = L\n            else:\n                # Left crossing\n                k_left = cross_indices[0]\n                # Linear interpolation for x_left\n                x_left = x[k_left] + dx * (D_half - D[k_left]) / (D[k_left + 1] - D[k_left])\n                \n                # Right crossing\n                k_right = cross_indices[-1] # Use last found crossing\n                # Linear interpolation for x_right\n                x_right = x[k_right] + dx * (D_half - D[k_right]) / (D[k_right + 1] - D[k_right])\n                \n                fwhm = x_right - x_left\n        \n        # Normalize FWHM and round to six decimal places\n        normalized_fwhm = round(fwhm / L, 6)\n        results.append(normalized_fwhm)\n\n    # Format the final output as a comma-separated list in brackets\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3510328"}, {"introduction": "Moving from diffuse continuum damage to discrete failure, this exercise explores how damage mechanics can be applied to model interfaces and fractures, a common scenario in geomaterials. A key challenge is capturing the asymmetric response between tension and compression, as damage should not grow under pure compressive states. This practice [@problem_id:3510324] guides you through implementing a cohesive zone model that incorporates this feature and ensures energetic consistency by linking the constitutive law to measurable mixed-mode fracture energies via the well-established Benzeggagh-Kenane (BK) law.", "problem": "Consider an interface damage formulation for geomaterials at small displacements that uses a tensile–compressive split to prevent damage growth under compression and enables mixed-mode fracture. Let the unknowns be the scalar damage variable $d \\in [0,1]$, the normal separation $\\delta_n$ (positive in tension), and the tangential separation $\\delta_s$. The interface free energy per unit area is postulated as\n$$\n\\psi(\\delta_n,\\delta_s,d) = (1-d)\\,\\frac{k}{2}\\left(\\langle \\delta_n \\rangle_{+}^{2} + \\delta_s^{2}\\right) + \\frac{k}{2}\\,\\langle \\delta_n \\rangle_{-}^{2},\n$$\nwhere $k>0$ is an elastic penalty stiffness, and $\\langle x \\rangle_{+}=\\max(x,0)$ and $\\langle x \\rangle_{-}=\\min(x,0)$ are the Macaulay brackets. The interface tractions follow from the energetic conjugacy $\\mathbf{t} = \\partial \\psi/\\partial \\boldsymbol{\\delta}$ with $\\boldsymbol{\\delta}=(\\delta_n,\\delta_s)$. Damage is driven by the monotonically non-decreasing history variable $r(t) = \\max_{\\tau \\le t}\\,\\delta_{\\mathrm{eq}}(\\tau)$, where the effective separation is\n$$\n\\delta_{\\mathrm{eq}} = \\sqrt{\\langle \\delta_n \\rangle_{+}^{2} + \\delta_s^{2}}.\n$$\nDamage initiates when $\\delta_{\\mathrm{eq}} = \\delta_0$ with $\\delta_0 = t_0/k$, where $t_0$ is a prescribed peak effective traction. Beyond initiation, adopt linear softening in the effective separation such that $d=0$ at $\\delta_{\\mathrm{eq}}=\\delta_0$ and $d=1$ at $\\delta_{\\mathrm{eq}}=\\delta_f(\\varphi)$, where $\\delta_f(\\varphi)$ is chosen to match a mixed-mode fracture energy $G_c(\\varphi)$ through\n$$\n\\delta_f(\\varphi) = \\frac{2\\,G_c(\\varphi)}{t_0}.\n$$\nAssume the mixed-mode fracture resistance follows the well-tested Benzeggagh–Kenane (BK) law\n$$\nG_c(\\varphi) = G_{Ic} + \\big(G_{IIc} - G_{Ic}\\big)\\,\\varphi^{\\eta},\n$$\nwhere $G_{Ic}$ and $G_{IIc}$ are the critical energy release rates in pure Mode I (opening) and pure Mode II (shear), respectively, $\\eta \\ge 1$ is an exponent, and the mode mixity parameter $\\varphi \\in [0,1]$ is defined at damage initiation as the fraction of recoverable elastic energy stored in shear relative to the total recoverable elastic energy, namely\n$$\n\\varphi = \\frac{\\delta_s^2}{\\langle \\delta_n \\rangle_{+}^{2} + \\delta_s^2}\\Bigg|_{\\delta_{\\mathrm{eq}}=\\delta_0}.\n$$\n\nTasks:\n1) Starting from the free energy $\\psi$, derive the traction–separation relations for the interface. Then, using the effective separation $\\delta_{\\mathrm{eq}}$ and the linear softening assumption, prove that under proportional loading paths with fixed ratio $\\delta_s/\\langle \\delta_n \\rangle_{+}$ in tension, the total work of separation dissipated up to complete failure equals $G_c(\\varphi)$ as defined by the Benzeggagh–Kenane law. Explain why pure compression with $\\delta_s=0$ cannot trigger damage evolution.\n\n2) Using your derivation, implement an algorithm that, given material parameters and a loading path, evaluates:\n- The predicted dissipated work of separation to failure $G_{\\text{pred}}$ along a proportional path in which the ratio $\\delta_s/\\langle \\delta_n \\rangle_{+}$ is constant in tension. Compare $G_{\\text{pred}}$ against the target $G_c(\\varphi)$ built from the same parameters, and report the ratio $G_{\\text{pred}}/G_c(\\varphi)$ (dimensionless).\n- A damage initiation check under a single-step displacement jump $(\\delta_n,\\delta_s)$ by testing $\\delta_{\\mathrm{eq}} \\ge \\delta_0$ and returning a boolean.\n\n3) Use the following physically plausible parameter values in the International System of Units (SI) and test suite:\n- Elastic penalty stiffness $k = 1.0 \\times 10^{12}$ N/m$^3$.\n- Peak effective traction $t_0 = 3.0 \\times 10^{6}$ N/m$^2$.\n- Mode I fracture energy $G_{Ic} = 150.0$ N/m.\n- Mode II fracture energy $G_{IIc} = 600.0$ N/m.\n- Benzeggagh–Kenane exponent $\\eta = 1.5$.\n\nEvaluate the following five cases:\n- Case A (pure Mode I): proportional loading with $\\delta_s/\\langle \\delta_n \\rangle_{+} = 0$ in tension. Output the float $G_{\\text{pred}}/G_c$.\n- Case B (pure Mode II): proportional loading with $\\langle \\delta_n \\rangle_{+} = 0$ and $\\delta_s > 0$. Output the float $G_{\\text{pred}}/G_c$.\n- Case C (mixed-mode): proportional loading with $\\delta_s/\\langle \\delta_n \\rangle_{+} = 1$ in tension. Output the float $G_{\\text{pred}}/G_c$.\n- Case D (compression only): single-step jump $\\delta_n = -1.0\\times 10^{-5}$ m, $\\delta_s = 0.0$ m. Output a boolean indicating damage initiation.\n- Case E (compression with shear above threshold): single-step jump $\\delta_n = -1.0\\times 10^{-5}$ m, $\\delta_s = 4.0\\times 10^{-6}$ m. Output a boolean indicating damage initiation.\n\nNumerical and unit instructions:\n- Express all internal computations in SI units (N/m for energies, N/m$^2$ for tractions, m for separations).\n- The outputs for Cases A–C must be dimensionless floats rounded to six decimal places.\n- The outputs for Cases D–E must be booleans.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order [Case A, Case B, Case C, Case D, Case E]. For example: \"[1.000000,1.000000,1.000000,False,True]\".", "solution": "**Part 1: Theoretical Derivations**\n\nThis problem describes a cohesive zone model for an interface, a widely used tool in computational fracture mechanics. We will first derive the constitutive relations for the interface tractions, then verify the model's energetic consistency by proving that the work of separation matches the prescribed fracture energy, and finally explain the model's behavior under pure compression.\n\n**Derivation of Traction–Separation Relations**\n\nThe interface tractions $\\mathbf{t} = (t_n, t_s)$ are thermodynamically conjugate to the separation vector $\\boldsymbol{\\delta}=(\\delta_n, \\delta_s)$ and are derived from the free energy potential $\\psi$ as $\\mathbf{t} = \\partial \\psi/\\partial \\boldsymbol{\\delta}$. The free energy density is given by:\n$$\n\\psi(\\delta_n,\\delta_s,d) = (1-d)\\,\\frac{k}{2}\\left(\\langle \\delta_n \\rangle_{+}^{2} + \\delta_s^{2}\\right) + \\frac{k}{2}\\,\\langle \\delta_n \\rangle_{-}^{2}\n$$\nwhere $k$ is the elastic penalty stiffness, $d$ is the damage variable, and $\\langle \\cdot \\rangle_+, \\langle \\cdot \\rangle_-$ are the Macaulay brackets.\n\nThe normal traction $t_n$ is the partial derivative of $\\psi$ with respect to $\\delta_n$:\n$$\nt_n = \\frac{\\partial\\psi}{\\partial\\delta_n} = (1-d)\\,\\frac{k}{2}\\,\\frac{\\partial}{\\partial\\delta_n}(\\langle \\delta_n \\rangle_{+}^{2}) + \\frac{k}{2}\\,\\frac{\\partial}{\\partial\\delta_n}(\\langle \\delta_n \\rangle_{-}^{2})\n$$\nThe derivatives of the squared Macaulay brackets are $\\frac{d}{dx}\\langle x \\rangle_+^2 = 2\\langle x \\rangle_+$ and $\\frac{d}{dx}\\langle x \\rangle_-^2 = 2\\langle x \\rangle_-$. Applying these yields:\n$$\nt_n = (1-d)\\,k\\,\\langle \\delta_n \\rangle_{+} + k\\,\\langle \\delta_n \\rangle_{-}\n$$\nThis relation captures the asymmetric response: for tensile opening ($\\delta_n > 0$), $\\langle \\delta_n \\rangle_{+} = \\delta_n$ and $\\langle \\delta_n \\rangle_{-} = 0$, so $t_n = (1-d)k\\delta_n$. For compression ($\\delta_n  0$), $\\langle \\delta_n \\rangle_{+} = 0$ and $\\langle \\delta_n \\rangle_{-} = \\delta_n$, so $t_n = k\\delta_n$. The compressive stiffness is independent of damage, which is a key feature for geomaterials.\n\nThe tangential (shear) traction $t_s$ is the partial derivative of $\\psi$ with respect to $\\delta_s$:\n$$\nt_s = \\frac{\\partial\\psi}{\\partial\\delta_s} = (1-d)\\,\\frac{k}{2}\\,(2\\delta_s) = (1-d)\\,k\\,\\delta_s\n$$\nThe shear stiffness $(1-d)k$ degrades with damage, regardless of the sign of the normal separation.\n\n**Work of Separation under Proportional Loading**\n\nThe work of separation, or fracture energy, is the total work done by the tractions to completely separate the interface. For a loading process from an intact state ($\\boldsymbol{\\delta}=\\mathbf{0}$) to a fully failed state, this work is given by the path integral $W = \\int_{\\text{path}} \\mathbf{t} \\cdot d\\boldsymbol{\\delta}$. Under complete failure, the stored elastic energy is assumed to be zero (for tensile paths), so the total work equals the dissipated energy.\n\nWe consider a proportional tensile loading path, where the ratio $\\delta_s/\\langle \\delta_n \\rangle_{+}$ is constant. Since we are in tension, $\\delta_n > 0$, so $\\langle \\delta_n \\rangle_+ = \\delta_n$. Let $\\delta_s = \\beta \\delta_n$ for a constant $\\beta \\ge 0$. The infinitesimal separation vector is $d\\boldsymbol{\\delta} = (d\\delta_n, d\\delta_s) = (d\\delta_n, \\beta d\\delta_n)$. The mode mixity parameter $\\varphi$ is constant along this path:\n$$\n\\varphi = \\frac{\\delta_s^2}{\\delta_n^2 + \\delta_s^2} = \\frac{(\\beta\\delta_n)^2}{\\delta_n^2 + (\\beta\\delta_n)^2} = \\frac{\\beta^2}{1+\\beta^2}\n$$\nThe effective separation $\\delta_{\\mathrm{eq}} = \\sqrt{\\delta_n^2 + \\delta_s^2} = \\sqrt{\\delta_n^2 + \\beta^2\\delta_n^2} = \\delta_n\\sqrt{1+\\beta^2}$. Thus, we can express $\\delta_n$ and $\\delta_s$ in terms of $\\delta_{\\mathrm{eq}}$:\n$$\n\\delta_n = \\frac{\\delta_{\\mathrm{eq}}}{\\sqrt{1+\\beta^2}}, \\quad \\delta_s = \\frac{\\beta \\delta_{\\mathrm{eq}}}{\\sqrt{1+\\beta^2}}\n$$\nThe traction components for this tensile path are $t_n = (1-d)k\\delta_n$ and $t_s = (1-d)k\\delta_s$. The work increment is:\n\\begin{align*}\ndW = t_n d\\delta_n + t_s d\\delta_s \\\\\n= (1-d)k\\delta_n\\,d\\delta_n + (1-d)k\\delta_s\\,d\\delta_s \\\\\n= (1-d)k\\, \\frac{1}{2} d(\\delta_n^2 + \\delta_s^2) \\\\\n= (1-d)k\\, \\frac{1}{2} d(\\delta_{\\mathrm{eq}}^2) = (1-d)k\\,\\delta_{\\mathrm{eq}}\\,d\\delta_{\\mathrm{eq}}\n\\end{align*}\nLet's define an effective traction $t_{\\mathrm{eq}} = (1-d)k\\delta_{\\mathrm{eq}}$. Then $dW = t_{\\mathrm{eq}} d\\delta_{\\mathrm{eq}}$. The total work of separation, which we aim to show equals $G_c(\\varphi)$, is the integral of $dW$ over the entire process, which corresponds to $\\delta_{\\mathrm{eq}}$ increasing from $0$ to the final separation $\\delta_f$.\n$$\nG_{\\text{pred}} = \\int_0^{\\delta_f} t_{\\mathrm{eq}}(\\delta_{\\mathrm{eq}})\\,d\\delta_{\\mathrm{eq}}\n$$\nThe problem specifies a loading response that is linearly elastic up to a peak effective traction $t_0$ at $\\delta_{\\mathrm{eq}}=\\delta_0=t_0/k$, followed by linear softening to zero traction at $\\delta_{\\mathrm{eq}}=\\delta_f$.\nThe effective traction-separation law is therefore:\n$$\nt_{\\mathrm{eq}}(\\delta_{\\mathrm{eq}}) =\n\\begin{cases}\nk\\,\\delta_{\\mathrm{eq}}  \\text{if } 0 \\le \\delta_{\\mathrm{eq}} \\le \\delta_0 \\\\\nt_0 \\left( \\frac{\\delta_f - \\delta_{\\mathrm{eq}}}{\\delta_f - \\delta_0} \\right)  \\text{if } \\delta_0  \\delta_{\\mathrm{eq}} \\le \\delta_f \\\\\n0  \\text{if } \\delta_{\\mathrm{eq}}  \\delta_f\n\\end{cases}\n$$\nThe work $G_{\\text{pred}}$ is the area under this $t_{\\mathrm{eq}}-\\delta_{\\mathrm{eq}}$ curve. This area is composed of a triangle for the elastic part and a triangle for the softening part:\n$$\nG_{\\text{pred}} = \\underbrace{\\frac{1}{2}\\,\\delta_0\\,t_0}_{\\text{elastic}} + \\underbrace{\\frac{1}{2}\\,(\\delta_f - \\delta_0)\\,t_0}_{\\text{softening}} = \\frac{1}{2}\\,t_0\\,(\\delta_0 + \\delta_f - \\delta_0) = \\frac{1}{2}\\,t_0\\,\\delta_f\n$$\nThe formulation is designed to be energetically consistent by defining the final separation $\\delta_f$ in terms of the target fracture energy $G_c(\\varphi)$ as:\n$$\n\\delta_f(\\varphi) = \\frac{2\\,G_c(\\varphi)}{t_0}\n$$\nSubstituting this definition into our expression for the predicted work of separation gives:\n$$\nG_{\\text{pred}} = \\frac{1}{2}\\,t_0 \\left( \\frac{2\\,G_c(\\varphi)}{t_0} \\right) = G_c(\\varphi)\n$$\nThis proves that the work of separation dissipated by the model under proportional tensile loading is, by construction, exactly equal to the mixed-mode fracture energy $G_c(\\varphi)$ prescribed by the Benzeggagh–Kenane law.\n\n**Damage Behavior under Pure Compression**\n\nWe must explain why pure compression with $\\delta_s=0$ does not trigger damage evolution. Damage evolution is governed by the history variable $r(t) = \\max_{\\tau \\le t}\\,\\delta_{\\mathrm{eq}}(\\tau)$, with damage initiating when $r(t)$ first reaches the threshold $\\delta_0 > 0$.\n\nConsider a state of pure compression with no shear: $\\delta_n  0$ and $\\delta_s = 0$. The effective separation $\\delta_{\\mathrm{eq}}$ is calculated as:\n$$\n\\delta_{\\mathrm{eq}} = \\sqrt{\\langle \\delta_n \\rangle_{+}^{2} + \\delta_s^{2}} = \\sqrt{(\\max(\\delta_n, 0))^2 + 0^2} = \\sqrt{0^2 + 0} = 0\n$$\nSince $\\delta_{\\mathrm{eq}}$ is always $0$ under such loading, the history variable $r(t)$ also remains $0$. The condition for damage initiation is $\\delta_{\\mathrm{eq}} \\ge \\delta_0$. Given that $\\delta_0 = t_0/k  0$, the condition $0 \\ge \\delta_0$ can never be satisfied. Consequently, damage is never initiated, and the damage variable $d$ remains at its initial value of $0$. The interface only deforms elastically in compression, which is a physically realistic behavior for many geomaterials.\n\n**Part 2: Algorithm Implementation**\n\nThe algorithm will implement the derived relationships to evaluate the five specified cases. For cases A-C, we will compute the mode mixity $\\varphi$, then calculate both the target fracture energy $G_c(\\varphi)$ and the predicted work of separation $G_{\\text{pred}} = \\frac{1}{2}t_0\\delta_f(\\varphi)$, and finally their ratio. For cases D-E, we will compute $\\delta_{\\mathrm{eq}}$ for the given displacement jump and compare it with the initiation threshold $\\delta_0$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the continuum damage mechanics problem for geomaterials.\n\n    The solution involves two main tasks:\n    1. Calculating the ratio of predicted work of separation to the target\n       fracture energy for three proportional loading cases (Mode I, Mode II, Mixed-Mode).\n    2. Performing a damage initiation check for two single-step displacement jump cases.\n    \"\"\"\n\n    # 1. Define material parameters and constants in SI units\n    k = 1.0e12  # Elastic penalty stiffness (N/m^3)\n    t0 = 3.0e6    # Peak effective traction (N/m^2)\n    G_Ic = 150.0  # Mode I fracture energy (N/m)\n    G_IIc = 600.0 # Mode II fracture energy (N/m)\n    eta = 1.5     # Benzeggagh-Kenane exponent (dimensionless)\n\n    # 2. Define test cases\n    # Cases A, B, C specify proportional loading paths. The key parameter is the\n    # mode mixity phi, which is determined by the ratio of shear to normal separation.\n    # Cases D, E specify single displacement jumps (dn, ds).\n    test_cases = [\n        {'type': 'proportional', 'id': 'A', 'phi': 0.0}, # Pure Mode I: ds/dn+ = 0 - phi = 0\n        {'type': 'proportional', 'id': 'B', 'phi': 1.0}, # Pure Mode II: dn+ = 0 - phi = 1\n        {'type': 'proportional', 'id': 'C', 'phi': 0.5}, # Mixed-Mode: ds/dn+ = 1 - phi = 1^2/(1^2+1^2) = 0.5\n        {'type': 'initiation_check', 'id': 'D', 'delta_n': -1.0e-5, 'delta_s': 0.0},\n        {'type': 'initiation_check', 'id': 'E', 'delta_n': -1.0e-5, 'delta_s': 4.0e-6},\n    ]\n\n    # 3. Calculate derived constants\n    # Damage initiation threshold for effective separation\n    delta_0 = t0 / k\n\n    results = []\n\n    # 4. Process each test case\n    for case in test_cases:\n        if case['type'] == 'proportional':\n            # This part handles Cases A, B, and C.\n            phi = case['phi']\n\n            # Calculate target mixed-mode fracture energy using the Benzeggagh-Kenane (BK) law\n            G_c = G_Ic + (G_IIc - G_Ic) * (phi**eta)\n\n            # Calculate the final separation at complete failure for the given mode mixity.\n            # This is defined by the model to ensure energetic consistency.\n            delta_f = (2 * G_c) / t0\n\n            # Calculate the predicted work of separation (G_pred).\n            # As proven in the derivation, this is the area under the triangular\n            # effective traction-separation curve.\n            G_pred = 0.5 * t0 * delta_f\n\n            # The ratio G_pred / G_c should be exactly 1 by construction.\n            # This serves as a verification of the model's implementation.\n            ratio = G_pred / G_c\n            results.append(f\"{ratio:.6f}\")\n\n        elif case['type'] == 'initiation_check':\n            # This part handles Cases D and E.\n            delta_n = case['delta_n']\n            delta_s = case['delta_s']\n\n            # Use Macaulay bracket for the positive part of the normal separation\n            # x+ = max(x, 0)\n            delta_n_pos = max(delta_n, 0.0)\n\n            # Calculate the effective separation for the given displacement jump\n            delta_eq = np.sqrt(delta_n_pos**2 + delta_s**2)\n\n            # Damage initiates if the effective separation meets or exceeds the threshold\n            initiates = delta_eq = delta_0\n            results.append(str(initiates))\n\n    # 5. Format and print the final output as a single-line string\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3510324"}, {"introduction": "Implementing damage models within dynamic simulations presents unique numerical challenges, especially concerning stability and the enforcement of physical constraints. This practice [@problem_id:3510336] simplifies the system to a single-degree-of-freedom oscillator to isolate and focus on the core issues of time integration for softening systems. You will implement a robust explicit time-stepping scheme and a crucial \"return-mapping-like\" projection algorithm to ensure the damage variable remains within its physical bounds of $[0, 1]$, providing essential skills for developing stable and accurate dynamic analysis tools.", "problem": "Consider a single-degree-of-freedom one-dimensional oscillator representing a small segment of a geomaterial with stiffness degraded by a scalar damage variable. Let the displacement be $x(t)$, the velocity be $v(t)$, the mass be $m$, the undamaged linear stiffness be $k_0$, and the linear viscous damping be $c$. The scalar damage variable $D(t)$ is dimensionless and represents stiffness degradation such that the effective stiffness is $k(D) = (1 - D)\\,k_0$. The governing equation of motion is derived from Newton's Second Law as\n$$\nm\\,\\ddot{x}(t) + c\\,\\dot{x}(t) + k(D(t))\\,x(t) = 0,\n$$\nwith initial conditions $x(0) = x_0$ and $v(0) = v_0$. The damage driving force is taken as the undamaged spring strain energy,\n$$\nY(t) = \\frac{1}{2}\\,k_0\\,x(t)^2,\n$$\nand the damage evolution is given by the ordinary differential equation\n$$\n\\dot{D}(t) = \\alpha\\,\\max\\big(0,\\,Y(t) - Y_0\\big)\\,\\big(1 - D(t)\\big)^p,\n$$\nwhere $\\alpha$ is a material parameter with units of $(\\text{second} \\cdot \\text{joule})^{-1}$, $Y_0$ is a threshold energy in joules, and $p > 0$ is an exponent controlling the saturation rate as $D \\to 1$. The damage must remain bounded in the physically admissible interval $0 \\le D \\le 1$.\n\nYour task is to implement an explicit time-stepping algorithm over a fixed time horizon using a velocity-Verlet-like scheme adapted to viscous damping, together with a return-mapping-like projection of the damage update to enforce $0 \\le D \\le 1$. At each time step $t_n \\to t_{n+1} = t_n + \\Delta t$, do the following:\n1. Use the current state $(x_n, v_n, D_n)$ to compute the acceleration $a_n = \\ddot{x}_n$ from the equation of motion with stiffness $k(D_n)$.\n2. Update the velocity to a half-step $v_{n+\\frac{1}{2}} = v_n + \\frac{\\Delta t}{2}\\,a_n$.\n3. Predict the next displacement $x_{n+1} = x_n + \\Delta t\\,v_{n+\\frac{1}{2}}$.\n4. Compute a trial damage update using explicit Euler with the updated displacement in the driving force,\n$$\nD_{n+1}^{\\text{trial}} = D_n + \\Delta t\\,\\alpha\\,\\max\\Big(0,\\,\\frac{1}{2}k_0\\,x_{n+1}^2 - Y_0\\Big)\\,\\big(1 - D_n\\big)^p.\n$$\n5. Enforce bounds through a return-mapping-like nearest-point projection onto the admissible set $[0,1]$,\n$$\nD_{n+1} = \\begin{cases}\n0  \\text{if } D_{n+1}^{\\text{trial}}  0,\\\\\nD_{n+1}^{\\text{trial}}  \\text{if } 0 \\le D_{n+1}^{\\text{trial}} \\le 1,\\\\\n1  \\text{if } D_{n+1}^{\\text{trial}}  1,\n\\end{cases}\n$$\nand set the effective stiffness $k_{n+1} = (1 - D_{n+1})\\,k_0$.\n6. Finalize the velocity using an implicit correction consistent with the damping force at $t_{n+1}$ that preserves linearity of the update. With $a_{n+1} = -\\frac{c}{m}\\,v_{n+1} - \\frac{k_{n+1}}{m}\\,x_{n+1}$, solve\n$$\nv_{n+1} = v_{n+\\frac{1}{2}} + \\frac{\\Delta t}{2}\\,a_{n+1}\n$$\nfor $v_{n+1}$ to obtain\n$$\nv_{n+1} = \\frac{v_{n+\\frac{1}{2}} - \\frac{\\Delta t}{2}\\,\\frac{k_{n+1}}{m}\\,x_{n+1}}{1 + \\frac{\\Delta t}{2}\\,\\frac{c}{m}}.\n$$\n\nThe damping $c$ must be selected from a specified damping ratio $\\zeta$ using the undamaged natural frequency $\\omega_0 = \\sqrt{k_0/m}$ as $c = 2\\,m\\,\\zeta\\,\\omega_0$. You must simulate the system for a given total time $T$, uniform time step $\\Delta t$, and specified parameters. At the end of the simulation, quantify the following:\n- The boundedness of the dynamics as a boolean $\\mathsf{stable}$, defined as true if and only if the maximum absolute displacement over the simulation satisfies $\\max_n |x_n| \\le X_{\\text{lim}}$, the maximum absolute velocity satisfies $\\max_n |v_n| \\le V_{\\text{lim}}$, and no numerical NaN or infinity occurred.\n- The enforcement of damage bounds as a boolean $\\mathsf{in\\_bounds}$, defined as true if and only if $D_n \\in [0,1]$ for all time steps.\n- The final damage $D_{\\text{final}} = D_N$ as a float, where $N$ is the last time index.\n- The maximum absolute displacement $\\max_n |x_n|$ as a float in meters.\n\nAll quantities involving physical units must be expressed using the following units: mass in kilograms (kg), stiffness in newtons per meter (N/m), damping in newton-seconds per meter (N·s/m), time in seconds (s), displacements in meters (m), velocities in meters per second (m/s), energy in joules (J), and the damage parameter $\\alpha$ in $(\\text{second} \\cdot \\text{joule})^{-1}$. Angles are not used in this problem.\n\nImplement the algorithm and evaluate the following test suite, which covers a general case, a near-boundary large time step, and an extreme large time step with rapid damage evolution:\n\n- Test Case 1 (general stable regime):\n    - $m = 1000\\,\\text{kg}$, $k_0 = 1.0\\times 10^7\\,\\text{N/m}$, $\\zeta = 0.02$, $\\Delta t = 0.005\\,\\text{s}$, $T = 1.0\\,\\text{s}$.\n    - $\\alpha = 1.0\\times 10^{-7}\\,(\\text{s}\\cdot\\text{J})^{-1}$, $Y_0 = 5000\\,\\text{J}$, $p = 1.0$.\n    - $x_0 = 0.05\\,\\text{m}$, $v_0 = 0.0\\,\\text{m/s}$.\n    - Boundedness thresholds: $X_{\\text{lim}} = 0.5\\,\\text{m}$, $V_{\\text{lim}} = 2.0\\,\\text{m/s}$.\n\n- Test Case 2 (near stability limit for undamaged stiffness):\n    - $m = 1000\\,\\text{kg}$, $k_0 = 1.0\\times 10^7\\,\\text{N/m}$, $\\zeta = 0.01$, $\\Delta t = 0.019\\,\\text{s}$, $T = 1.0\\,\\text{s}$.\n    - $\\alpha = 5.0\\times 10^{-7}\\,(\\text{s}\\cdot\\text{J})^{-1}$, $Y_0 = 2000\\,\\text{J}$, $p = 1.0$.\n    - $x_0 = 0.05\\,\\text{m}$, $v_0 = 0.0\\,\\text{m/s}$.\n    - Boundedness thresholds: $X_{\\text{lim}} = 0.5\\,\\text{m}$, $V_{\\text{lim}} = 5.0\\,\\text{m/s}$.\n\n- Test Case 3 (extreme large time step with rapid damage):\n    - $m = 1000\\,\\text{kg}$, $k_0 = 1.0\\times 10^7\\,\\text{N/m}$, $\\zeta = 0.20$, $\\Delta t = 0.050\\,\\text{s}$, $T = 1.0\\,\\text{s}$.\n    - $\\alpha = 5.0\\times 10^{-5}\\,(\\text{s}\\cdot\\text{J})^{-1}$, $Y_0 = 1000\\,\\text{J}$, $p = 1.0$.\n    - $x_0 = 0.10\\,\\text{m}$, $v_0 = 0.0\\,\\text{m/s}$.\n    - Boundedness thresholds: $X_{\\text{lim}} = 1.0\\,\\text{m}$, $V_{\\text{lim}} = 10.0\\,\\text{m/s}$.\n\nYour program should produce a single line of output containing the aggregated results from all test cases as a comma-separated list enclosed in square brackets. Each test case contributes four entries in the order $[\\mathsf{stable},\\mathsf{in\\_bounds},D_{\\text{final}},\\max |x|]$, so the final output line must have twelve entries, ordered by the test cases as listed. For example, the output format must be\n$$\n[\\mathsf{stable}_1,\\mathsf{in\\_bounds}_1,D_{\\text{final},1},\\max |x|_1,\\mathsf{stable}_2,\\mathsf{in\\_bounds}_2,D_{\\text{final},2},\\max |x|_2,\\mathsf{stable}_3,\\mathsf{in\\_bounds}_3,D_{\\text{final},3},\\max |x|_3].\n$$", "solution": "The derivation starts from a fundamental base: Newton's Second Law of Motion and the internal variable concept in continuum damage mechanics. The one-dimensional equation of motion for a mass-spring-damper system with damage-degraded stiffness is\n$$\nm\\,\\ddot{x}(t) + c\\,\\dot{x}(t) + k(D(t))\\,x(t) = 0,\n$$\nwith $k(D) = (1 - D)\\,k_0$, where the damage variable $D \\in [0,1]$ reduces the stored stiffness. The internal variable $D$ evolves in time according to a rate equation driven by a thermodynamically consistent measure of strain energy. For concreteness and to maintain scientific realism, we adopt the undamaged spring energy $Y(t) = \\frac{1}{2}k_0 x(t)^2$ and the damage rate\n$$\n\\dot{D}(t) = \\alpha\\,\\max\\big(0,\\,Y(t) - Y_0\\big)\\,\\big(1 - D(t)\\big)^p,\n$$\nwhich ensures $\\dot{D}(t) \\ge 0$ whenever the stored energy exceeds the threshold $Y_0$, and provides saturation as $D \\to 1$ through the $(1-D)^p$ factor.\n\nTo construct an algorithm suited to dynamic simulations and testing stability under large time steps, we employ a velocity-Verlet-like scheme adapted for viscous damping. The classical velocity Verlet update for conservative systems is symplectic and second-order accurate. In the presence of velocity-proportional damping, we modify the final velocity update by solving a one-step linear equation, thereby preserving the explicit nature while accounting for damping at the end of the step.\n\nDenote $t_n = n\\,\\Delta t$ and the discrete states $(x_n, v_n, D_n)$. The acceleration at step $n$ is\n$$\na_n = \\ddot{x}_n = -\\frac{c}{m}\\,v_n - \\frac{k(D_n)}{m}\\,x_n.\n$$\nThe velocity half-step update is\n$$\nv_{n+\\frac{1}{2}} = v_n + \\frac{\\Delta t}{2}\\,a_n.\n$$\nThe displacement update is\n$$\nx_{n+1} = x_n + \\Delta t\\,v_{n+\\frac{1}{2}}.\n$$\nThe damage update uses explicit Euler with the updated displacement in the driving force to reduce numerical lag:\n$$\nD_{n+1}^{\\text{trial}} = D_n + \\Delta t\\,\\alpha\\,\\max\\Big(0,\\,\\frac{1}{2}k_0\\,x_{n+1}^2 - Y_0\\Big)\\,\\big(1 - D_n\\big)^p.\n$$\nBecause the admissible set for the damage variable is the closed interval $[0,1]$, we enforce bounds via a return-mapping-like projection onto this convex set, defined as the nearest-point projection in the Euclidean norm:\n$$\nD_{n+1} = \\Pi_{[0,1]}\\big(D_{n+1}^{\\text{trial}}\\big) = \\min\\big(1,\\,\\max(0,\\,D_{n+1}^{\\text{trial}})\\big).\n$$\nThis projection is consistent with standard practices in inelasticity for enforcing constraints (similar in philosophy to return mapping in plasticity), and ensures that $D$ remains within physical bounds.\n\nWith the updated damage, set the effective stiffness for the next acceleration evaluation:\n$$\nk_{n+1} = (1 - D_{n+1})\\,k_0.\n$$\nFor the final velocity, we recognize that the acceleration at $t_{n+1}$ depends on $v_{n+1}$ due to damping:\n$$\na_{n+1} = -\\frac{c}{m}\\,v_{n+1} - \\frac{k_{n+1}}{m}\\,x_{n+1}.\n$$\nThe velocity update formula is\n$$\nv_{n+1} = v_{n+\\frac{1}{2}} + \\frac{\\Delta t}{2}\\,a_{n+1}.\n$$\nSubstituting $a_{n+1}$ and solving for $v_{n+1}$ yields a scalar linear equation:\n$$\nv_{n+1} + \\frac{\\Delta t}{2}\\frac{c}{m}v_{n+1} = v_{n+\\frac{1}{2}} - \\frac{\\Delta t}{2}\\frac{k_{n+1}}{m}x_{n+1}.\n$$\nTherefore,\n$$\nv_{n+1} = \\frac{v_{n+\\frac{1}{2}} - \\frac{\\Delta t}{2}\\frac{k_{n+1}}{m}x_{n+1}}{1 + \\frac{\\Delta t}{2}\\frac{c}{m}}.\n$$\nThis closed-form update retains explicitness while incorporating the damping consistently at the end of the step.\n\nThe damping coefficient is specified via the damping ratio using the undamaged natural frequency,\n$$\n\\omega_0 = \\sqrt{\\frac{k_0}{m}}, \\quad c = 2\\,m\\,\\zeta\\,\\omega_0.\n$$\nThe stability of explicit schemes for linear undamped oscillators is traditionally constrained by $\\Delta t \\le \\frac{2}{\\omega_0}$; here, we deliberately test scenarios near and beyond that limit to observe boundedness under damping and damage-induced stiffness degradation. Because damage reduces stiffness, the instantaneous natural frequency may decrease in time, potentially relaxing the stability condition after sufficient damage develops. However, the early-time response still depends on the undamaged stiffness. Therefore, the selected test cases include:\n- A small time step well within the stability bound;\n- A large time step near the critical bound for the undamaged system;\n- An extreme large time step exceeding the bound, tempered by significant damping and rapid damage evolution.\n\nAlgorithmic checks ensure numerical robustness. The boundedness boolean $\\mathsf{stable}$ is defined to be true if the displacement and velocity amplitudes do not exceed specified thresholds and if no NaN or infinity appears in the simulation. The $\\mathsf{in\\_bounds}$ boolean confirms $D_n \\in [0,1]$ at all steps, guaranteed by the projection but still verified numerically with a small tolerance. The final damage and maximum absolute displacement are recorded as floats.\n\nImplementation steps:\n1. For each test case, read parameters $(m, k_0, \\zeta, \\Delta t, T, \\alpha, Y_0, p, x_0, v_0, X_{\\text{lim}}, V_{\\text{lim}})$.\n2. Compute $\\omega_0 = \\sqrt{k_0/m}$ and $c = 2\\,m\\,\\zeta\\,\\omega_0$.\n3. Initialize $(x, v, D) = (x_0, v_0, 0)$ and maxima $(x_{\\max}, v_{\\max})$.\n4. Loop over $N = \\lfloor T/\\Delta t \\rfloor$ steps using the described update scheme.\n5. Track maxima and check boundedness and damage bounds.\n6. Aggregate results per test case into $[\\mathsf{stable}, \\mathsf{in\\_bounds}, D_{\\text{final}}, x_{\\max}]$.\n7. Print all results from the test suite in a single list as specified.\n\nScientific realism and unit consistency are ensured by using physical units throughout, adopting a plausible damage evolution law, and selecting parameters that reflect typical geomaterial stiffness and mass scales. The projection ensures the physical constraint $0 \\le D \\le 1$ even under aggressive time stepping, while the damping and damage interact to influence stability. The test suite includes a general case, a near-boundary case, and an extreme case to provide coverage for different dynamical regimes.\n\nThe final program adheres to the required output format by printing a single line composed of the concatenated results from the three test cases, each contributing four entries in the prescribed order.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef simulate_case(m, k0, zeta, dt, T, alpha, Y0, p, x0, v0, X_lim, V_lim):\n    \"\"\"\n    Simulate the damage-degrading oscillator using a velocity-Verlet-like scheme with damping\n    and a return-mapping-like projection for the damage variable.\n    \"\"\"\n    # Undamaged natural frequency and damping\n    omega0 = np.sqrt(k0 / m)\n    c = 2.0 * m * zeta * omega0\n\n    # Initial conditions\n    x = float(x0)\n    v = float(v0)\n    D = 0.0  # start undamaged\n\n    # Tracking maxima and flags\n    max_abs_x = abs(x)\n    max_abs_v = abs(v)\n    in_bounds = True\n    finite_values = True\n\n    # Number of time steps\n    n_steps = int(np.floor(T / dt))\n\n    # Time-stepping loop\n    for _ in range(n_steps):\n        # Effective stiffness at current step\n        k_eff_n = (1.0 - D) * k0\n\n        # Acceleration at current step\n        a_n = -(c / m) * v - (k_eff_n / m) * x\n\n        # Velocity half-step\n        v_half = v + 0.5 * dt * a_n\n\n        # Displacement update\n        x_new = x + dt * v_half\n\n        # Damage trial update using explicit Euler and undamaged energy at x_new\n        Y_new = 0.5 * k0 * (x_new ** 2)\n        damage_rate = alpha * max(0.0, Y_new - Y0) * ((1.0 - D) ** p)\n        D_trial = D + dt * damage_rate\n\n        # Return-mapping-like projection onto [0, 1]\n        D_new = min(1.0, max(0.0, D_trial))\n\n        # Effective stiffness for next step\n        k_eff_np1 = (1.0 - D_new) * k0\n\n        # Finalize velocity with damping-consistent correction:\n        # v_{n+1} = (v_half - (dt/2)*(k_eff/m)*x_new) / (1 + (dt/2)*(c/m))\n        denom = 1.0 + 0.5 * dt * (c / m)\n        v_new = (v_half - 0.5 * dt * (k_eff_np1 / m) * x_new) / denom\n\n        # Update state\n        x, v, D = x_new, v_new, D_new\n\n        # Track maxima\n        ax = abs(x)\n        av = abs(v)\n        if ax  max_abs_x:\n            max_abs_x = ax\n        if av  max_abs_v:\n            max_abs_v = av\n\n        # Check bounds and finiteness with tolerance\n        if not (D = -1e-12 and D = 1.0 + 1e-12):\n            in_bounds = False\n        if not (np.isfinite(x) and np.isfinite(v) and np.isfinite(D)):\n            finite_values = False\n            break  # stop early if numerical failure\n\n    # Stability check against provided limits and finiteness\n    stable = (max_abs_x = X_lim) and (max_abs_v = V_lim) and finite_values\n\n    return stable, in_bounds, D, max_abs_x\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case 1\n        {\n            \"m\": 1000.0, \"k0\": 1.0e7, \"zeta\": 0.02, \"dt\": 0.005, \"T\": 1.0,\n            \"alpha\": 1.0e-7, \"Y0\": 5000.0, \"p\": 1.0,\n            \"x0\": 0.05, \"v0\": 0.0,\n            \"X_lim\": 0.5, \"V_lim\": 2.0\n        },\n        # Test Case 2\n        {\n            \"m\": 1000.0, \"k0\": 1.0e7, \"zeta\": 0.01, \"dt\": 0.019, \"T\": 1.0,\n            \"alpha\": 5.0e-7, \"Y0\": 2000.0, \"p\": 1.0,\n            \"x0\": 0.05, \"v0\": 0.0,\n            \"X_lim\": 0.5, \"V_lim\": 5.0\n        },\n        # Test Case 3\n        {\n            \"m\": 1000.0, \"k0\": 1.0e7, \"zeta\": 0.20, \"dt\": 0.050, \"T\": 1.0,\n            \"alpha\": 5.0e-5, \"Y0\": 1000.0, \"p\": 1.0,\n            \"x0\": 0.10, \"v0\": 0.0,\n            \"X_lim\": 1.0, \"V_lim\": 10.0\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        stable, in_bounds, D_final, max_abs_x = simulate_case(\n            m=case[\"m\"], k0=case[\"k0\"], zeta=case[\"zeta\"],\n            dt=case[\"dt\"], T=case[\"T\"],\n            alpha=case[\"alpha\"], Y0=case[\"Y0\"], p=case[\"p\"],\n            x0=case[\"x0\"], v0=case[\"v0\"],\n            X_lim=case[\"X_lim\"], V_lim=case[\"V_lim\"]\n        )\n        # Append in the specified order: [stable, in_bounds, D_final, max_abs_x]\n        results.extend([stable, in_bounds, D_final, max_abs_x])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3510336"}]}