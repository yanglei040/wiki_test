{"hands_on_practices": [{"introduction": "Before any forces can be calculated, the geometry of contact must be precisely defined. This practice [@problem_id:3534212] drills the fundamental kinematic calculations at the heart of computational contact mechanics. By performing a closest point projection, you will learn to compute the normal gap $g_n$ and tangential gap vector $\\boldsymbol{g}_t$, which are the essential measures of separation and potential slip between two surfaces.", "problem": "A pair of discretized surfaces in three-dimensional space are represented by two linear triangular surface elements in the Finite Element Method (FEM). The first triangle is designated the master surface and the second the slave surface. Each triangle is defined by three nodes with initial positions and known nodal displacements, and both surfaces undergo small deformations over a single time step. Use the standard isoparametric interpolation for linear triangles and the definition of the centroidal Gauss point in area (barycentric) coordinates. The master triangle nodes are ordered $\\boldsymbol{X}_{M1} \\rightarrow \\boldsymbol{X}_{M2} \\rightarrow \\boldsymbol{X}_{M3}$ to define the outward unit normal by the right-hand rule.\n\nGiven the initial coordinates and displacements:\n- Master triangle initial nodal coordinates: $\\boldsymbol{X}_{M1} = (0,\\,0,\\,0)$, $\\boldsymbol{X}_{M2} = (1,\\,0,\\,0)$, $\\boldsymbol{X}_{M3} = (0,\\,1,\\,0.1)$.\n- Master triangle nodal displacements: $\\boldsymbol{u}_{M1} = (0,\\,0,\\,0)$, $\\boldsymbol{u}_{M2} = (0,\\,0,\\,0.02)$, $\\boldsymbol{u}_{M3} = (0,\\,0,\\,0)$.\n- Slave triangle initial nodal coordinates: $\\boldsymbol{X}_{S1} = (0.2,\\,0.2,\\,0.15)$, $\\boldsymbol{X}_{S2} = (1.05,\\,0.1,\\,0.12)$, $\\boldsymbol{X}_{S3} = (0.1,\\,0.9,\\,0.25)$.\n- Slave triangle nodal displacements: $\\boldsymbol{u}_{S1} = (0.01,\\,-0.005,\\,-0.02)$, $\\boldsymbol{u}_{S2} = (0,\\,0,\\,-0.03)$, $\\boldsymbol{u}_{S3} = (-0.005,\\,0.005,\\,-0.01)$.\n\nAssume small strains and compute all quantities in the current (deformed) configuration. At the slave triangle’s centroidal Gauss point with barycentric coordinates $(\\frac{1}{3},\\,\\frac{1}{3},\\,\\frac{1}{3})$, perform a closest point projection onto the current master triangle. Using first principles of interface contact kinematics:\n1. Construct the current coordinates of the slave Gauss point from the deformed slave nodes.\n2. Construct the current outward unit normal of the master triangle from its deformed nodes.\n3. Compute the orthogonal closest point projection of the slave Gauss point onto the master triangle’s plane, and verify that the projected point lies inside the triangle by barycentric coordinates.\n4. From the relative position vector $\\boldsymbol{g} = \\boldsymbol{x}_{S}^{\\text{GP}} - \\boldsymbol{x}_{M}^{\\text{proj}}$, extract the normal gap $g_n$ and the tangential gap vector $\\boldsymbol{g}_t$ by decomposing $\\boldsymbol{g}$ into normal and tangential components with respect to the master surface at the projection point. Use the sign convention that $g_n  0$ indicates separation along the outward normal of the master surface and $g_n  0$ indicates penetration.\n\nRound your final numerical values to four significant figures. Express $g_n$ and each component of $\\boldsymbol{g}_t$ in meters. Provide the final answer as a single row matrix containing $g_n$ followed by the three Cartesian components of $\\boldsymbol{g}_t$ in the global coordinate frame.", "solution": "The problem is first validated to ensure it is scientifically grounded, well-posed, and all necessary information is provided.\n\n### Step 1: Extract Givens\n- Master triangle initial nodal coordinates: $\\boldsymbol{X}_{M1} = (0,\\,0,\\,0)$, $\\boldsymbol{X}_{M2} = (1,\\,0,\\,0)$, $\\boldsymbol{X}_{M3} = (0,\\,1,\\,0.1)$.\n- Master triangle nodal displacements: $\\boldsymbol{u}_{M1} = (0,\\,0,\\,0)$, $\\boldsymbol{u}_{M2} = (0,\\,0,\\,0.02)$, $\\boldsymbol{u}_{M3} = (0,\\,0,\\,0)$.\n- Slave triangle initial nodal coordinates: $\\boldsymbol{X}_{S1} = (0.2,\\,0.2,\\,0.15)$, $\\boldsymbol{X}_{S2} = (1.05,\\,0.1,\\,0.12)$, $\\boldsymbol{X}_{S3} = (0.1,\\,0.9,\\,0.25)$.\n- Slave triangle nodal displacements: $\\boldsymbol{u}_{S1} = (0.01,\\,-0.005,\\,-0.02)$, $\\boldsymbol{u}_{S2} = (0,\\,0,\\,-0.03)$, $\\boldsymbol{u}_{S3} = (-0.005,\\,0.005,\\,-0.01)$.\n- Slave point: Centroidal Gauss point with barycentric coordinates $(\\frac{1}{3},\\,\\frac{1}{3},\\,\\frac{1}{3})$.\n- Master normal orientation: Defined by the ordering $\\boldsymbol{X}_{M1} \\rightarrow \\boldsymbol{X}_{M2} \\rightarrow \\boldsymbol{X}_{M3}$ and the right-hand rule.\n- Kinematic assumption: Small deformations, calculations in the current configuration.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded:** The problem uses standard concepts from computational contact mechanics within the Finite Element Method (FEM), such as isoparametric interpolation, master-slave contact pairs, and closest point projection for gap calculation. These are established and fundamental principles.\n- **Well-Posed:** All necessary data (nodal coordinates and displacements) are provided. The tasks are clearly defined and lead to a unique, computable solution.\n- **Objective:** The problem is stated in precise, quantitative terms without subjective or ambiguous language.\n- **Conclusion:** The problem is deemed valid as it is self-contained, consistent, and grounded in established scientific principles of computational mechanics.\n\n### Solution Derivation\nThe solution proceeds by following the four steps outlined in the problem statement. First, we compute the nodal coordinates in the current (deformed) configuration. The current coordinate vector $\\boldsymbol{x}$ is the sum of the initial coordinate vector $\\boldsymbol{X}$ and the displacement vector $\\boldsymbol{u}$, i.e., $\\boldsymbol{x} = \\boldsymbol{X} + \\boldsymbol{u}$.\n\nDeformed master node coordinates:\n$\\boldsymbol{x}_{M1} = \\boldsymbol{X}_{M1} + \\boldsymbol{u}_{M1} = (0,\\,0,\\,0) + (0,\\,0,\\,0) = (0,\\,0,\\,0)$\n$\\boldsymbol{x}_{M2} = \\boldsymbol{X}_{M2} + \\boldsymbol{u}_{M2} = (1,\\,0,\\,0) + (0,\\,0,\\,0.02) = (1,\\,0,\\,0.02)$\n$\\boldsymbol{x}_{M3} = \\boldsymbol{X}_{M3} + \\boldsymbol{u}_{M3} = (0,\\,1,\\,0.1) + (0,\\,0,\\,0) = (0,\\,1,\\,0.1)$\n\nDeformed slave node coordinates:\n$\\boldsymbol{x}_{S1} = \\boldsymbol{X}_{S1} + \\boldsymbol{u}_{S1} = (0.2,\\,0.2,\\,0.15) + (0.01,\\,-0.005,\\,-0.02) = (0.21,\\,0.195,\\,0.13)$\n$\\boldsymbol{x}_{S2} = \\boldsymbol{X}_{S2} + \\boldsymbol{u}_{S2} = (1.05,\\,0.1,\\,0.12) + (0,\\,0,\\,-0.03) = (1.05,\\,0.1,\\,0.09)$\n$\\boldsymbol{x}_{S3} = \\boldsymbol{X}_{S3} + \\boldsymbol{u}_{S3} = (0.1,\\,0.9,\\,0.25) + (-0.005,\\,0.005,\\,-0.01) = (0.095,\\,0.905,\\,0.24)$\n\n**1. Construct the current coordinates of the slave Gauss point ($\\boldsymbol{x}_{S}^{\\text{GP}}$)**\nThe position of the centroidal Gauss point is the average of the nodal coordinates, corresponding to barycentric coordinates $(\\xi_1, \\xi_2, \\xi_3) = (\\frac{1}{3},\\,\\frac{1}{3},\\,\\frac{1}{3})$.\n$$ \\boldsymbol{x}_{S}^{\\text{GP}} = \\frac{1}{3}\\boldsymbol{x}_{S1} + \\frac{1}{3}\\boldsymbol{x}_{S2} + \\frac{1}{3}\\boldsymbol{x}_{S3} = \\frac{1}{3}(\\boldsymbol{x}_{S1} + \\boldsymbol{x}_{S2} + \\boldsymbol{x}_{S3}) $$\n$$ \\boldsymbol{x}_{S}^{\\text{GP}} = \\frac{1}{3} \\left( (0.21+1.05+0.095),\\,(0.195+0.1+0.905),\\,(0.13+0.09+0.24) \\right) $$\n$$ \\boldsymbol{x}_{S}^{\\text{GP}} = \\frac{1}{3} (1.355,\\,1.2,\\,0.46) = (0.45166\\dots,\\,0.4,\\,0.15333\\dots) $$\n\n**2. Construct the current outward unit normal of the master triangle ($\\boldsymbol{n}$)**\nThe normal vector $\\boldsymbol{N}$ is found from the cross product of two edge vectors originating from a common node, consistent with the right-hand rule. We use edge vectors $\\boldsymbol{v}_{12} = \\boldsymbol{x}_{M2}-\\boldsymbol{x}_{M1}$ and $\\boldsymbol{v}_{13} = \\boldsymbol{x}_{M3}-\\boldsymbol{x}_{M1}$.\n$$ \\boldsymbol{v}_{12} = (1,\\,0,\\,0.02) - (0,\\,0,\\,0) = (1,\\,0,\\,0.02) $$\n$$ \\boldsymbol{v}_{13} = (0,\\,1,\\,0.1) - (0,\\,0,\\,0) = (0,\\,1,\\,0.1) $$\n$$ \\boldsymbol{N} = \\boldsymbol{v}_{12} \\times \\boldsymbol{v}_{13} = \\begin{vmatrix} \\boldsymbol{i}  \\boldsymbol{j}  \\boldsymbol{k} \\\\ 1  0  0.02 \\\\ 0  1  0.1 \\end{vmatrix} = (-0.02, -0.1, 1) $$\nThe magnitude of the normal vector is:\n$$ ||\\boldsymbol{N}|| = \\sqrt{(-0.02)^2 + (-0.1)^2 + 1^2} = \\sqrt{0.0004 + 0.01 + 1} = \\sqrt{1.0104} \\approx 1.0051865 $$\nThe unit normal vector $\\boldsymbol{n}$ is:\n$$ \\boldsymbol{n} = \\frac{\\boldsymbol{N}}{||\\boldsymbol{N}||} = \\frac{1}{\\sqrt{1.0104}}(-0.02,\\,-0.1,\\,1) \\approx (-0.01990,\\, -0.09949,\\, 0.99494) $$\n\n**3. Compute the orthogonal closest point projection ($\\boldsymbol{x}_{M}^{\\text{proj}}$) and verify**\nThe master surface is a plane defined by $\\boldsymbol{n} \\cdot (\\boldsymbol{x} - \\boldsymbol{x}_{M1}) = 0$. Since $\\boldsymbol{x}_{M1} = (0,0,0)$, the plane equation is $\\boldsymbol{n} \\cdot \\boldsymbol{x} = 0$.\nThe projected point $\\boldsymbol{x}_{M}^{\\text{proj}}$ is found by moving from $\\boldsymbol{x}_{S}^{\\text{GP}}$ along the direction $-\\boldsymbol{n}$ by a distance equal to the orthogonal separation $d = (\\boldsymbol{x}_{S}^{\\text{GP}} - \\boldsymbol{x}_{M1}) \\cdot \\boldsymbol{n}$.\n$$ d = \\boldsymbol{x}_{S}^{\\text{GP}} \\cdot \\boldsymbol{n} = \\frac{1}{3}(1.355,\\,1.2,\\,0.46) \\cdot \\frac{1}{\\sqrt{1.0104}}(-0.02,\\,-0.1,\\,1) $$\n$$ d = \\frac{1}{3\\sqrt{1.0104}} \\left(1.355(-0.02) + 1.2(-0.1) + 0.46(1) \\right) $$\n$$ d = \\frac{1}{3\\sqrt{1.0104}} (-0.0271 - 0.12 + 0.46) = \\frac{0.3129}{3\\sqrt{1.0104}} = \\frac{0.1043}{\\sqrt{1.0104}} \\approx 0.103762 $$\nThe projected point is $\\boldsymbol{x}_{M}^{\\text{proj}} = \\boldsymbol{x}_{S}^{\\text{GP}} - d \\boldsymbol{n}$.\n$$ \\boldsymbol{x}_{M}^{\\text{proj}} \\approx (0.451667,\\,0.4,\\,0.153333) - 0.103762 \\cdot (-0.01990,\\, -0.09949,\\, 0.99494) $$\n$$ \\boldsymbol{x}_{M}^{\\text{proj}} \\approx (0.451667+0.002065,\\, 0.4+0.010323,\\, 0.153333-0.103234) $$\n$$ \\boldsymbol{x}_{M}^{\\text{proj}} \\approx (0.45373,\\, 0.41032,\\, 0.05010) $$\nTo verify this point is inside the master triangle, we find its barycentric coordinates $(\\xi_1, \\xi_2, \\xi_3)$ such that $\\boldsymbol{x}_{M}^{\\text{proj}} = \\xi_1\\boldsymbol{x}_{M1} + \\xi_2\\boldsymbol{x}_{M2} + \\xi_3\\boldsymbol{x}_{M3}$ and $\\xi_1+\\xi_2+\\xi_3=1$.\nSince $\\boldsymbol{x}_{M1} = (0,0,0)$, this simplifies to $\\boldsymbol{x}_{M}^{\\text{proj}} = \\xi_2\\boldsymbol{x}_{M2} + \\xi_3\\boldsymbol{x}_{M3}$.\n$$ (0.45373,\\, 0.41032,\\, 0.05010) = \\xi_2(1,\\,0,\\,0.02) + \\xi_3(0,\\,1,\\,0.1) $$\nFrom the $x$ and $y$ components:\n$\\xi_2 = 0.45373$\n$\\xi_3 = 0.41032$\nThen $\\xi_1 = 1 - \\xi_2 - \\xi_3 = 1 - 0.45373 - 0.41032 = 0.13595$.\nSince $\\xi_1, \\xi_2, \\xi_3$ are all positive and sum to $1$, the projected point lies within the master triangle. The verification is successful.\n\n**4. Compute the normal gap ($g_n$) and tangential gap vector ($\\boldsymbol{g}_t$)**\nThe relative position vector (gap vector) is $\\boldsymbol{g} = \\boldsymbol{x}_{S}^{\\text{GP}} - \\boldsymbol{x}_{M}^{\\text{proj}}$. Based on the definition of orthogonal projection, this vector is by construction parallel to the normal vector $\\boldsymbol{n}$, with its length equal to the distance $d$.\n$$ \\boldsymbol{g} = d \\boldsymbol{n} $$\nThe normal gap $g_n$ is the component of $\\boldsymbol{g}$ along $\\boldsymbol{n}$. With the sign convention that $g_n  0$ for separation, this is:\n$$ g_n = \\boldsymbol{g} \\cdot \\boldsymbol{n} = (d \\boldsymbol{n}) \\cdot \\boldsymbol{n} = d (\\boldsymbol{n} \\cdot \\boldsymbol{n}) = d $$\n$$ g_n = d \\approx 0.103762 $$\nRounding to four significant figures, $g_n = 0.1038$ m. Since $g_n  0$, the surfaces are separated at this point.\n\nThe tangential gap vector $\\boldsymbol{g}_t$ is the component of $\\boldsymbol{g}$ in the plane of the master surface. It is obtained by subtracting the normal component from $\\boldsymbol{g}$:\n$$ \\boldsymbol{g}_t = \\boldsymbol{g} - g_n \\boldsymbol{n} $$\nSubstituting $\\boldsymbol{g} = d \\boldsymbol{n}$ and $g_n = d$:\n$$ \\boldsymbol{g}_t = d \\boldsymbol{n} - d \\boldsymbol{n} = \\boldsymbol{0} $$\nThe tangential gap vector is zero because the projection was defined as being orthogonal to the master surface. Therefore, the vector from the slave point to its projection has no tangential component by definition.\nThe components of the tangential gap vector are $\\boldsymbol{g}_t = (g_{tx}, g_{ty}, g_{tz}) = (0, 0, 0)$.\n\nFinal values rounded to four significant figures:\n$g_n = 0.1038$\n$\\boldsymbol{g}_t = (0, 0, 0)$\nExpressing these as a single row matrix $[g_n, g_{tx}, g_{ty}, g_{tz}]$:\n$[0.1038,\\, 0,\\, 0,\\, 0]$.\nNote that the problem asks to round the final numerical values, so the $0$ components remain exactly $0$.", "answer": "$$ \\boxed{ \\begin{pmatrix} 0.1038  0  0  0 \\end{pmatrix} } $$", "id": "3534212"}, {"introduction": "Once contact is established, we must model the frictional forces that resist tangential motion. This exercise [@problem_id:3534224] introduces the radial return algorithm, a fundamental predictor-corrector scheme for enforcing the Coulomb friction law. By implementing this algorithm, you will gain practical skills in handling the stick-slip transition and computing the plastic slip, a core task in simulating frictional systems.", "problem": "Consider a planar frictional contact interface in computational geomechanics, in which the normal traction $p_n$ is taken as positive in compression. The tangential traction is represented by the two-dimensional vector $\\boldsymbol{\\tau} \\in \\mathbb{R}^2$. The frictional strength is modeled by the classical Coulomb law with friction coefficient $\\mu \\ge 0$, which implies the admissible set is defined by the yield function\n$$\n\\phi(\\boldsymbol{\\tau},p_n) = \\|\\boldsymbol{\\tau}\\| - \\mu\\,p_n \\le 0,\n$$\nwhere $\\|\\cdot\\|$ denotes the Euclidean norm. The interface is regularized by a tangential penalty stiffness $k_t  0$ (units: pascal per meter) so that the purely elastic predictor provides a trial tangential traction $\\boldsymbol{\\tau}^{\\text{trial}} \\in \\mathbb{R}^2$ (units: pascal). If sliding occurs, introduce a plastic slip increment vector $\\Delta \\boldsymbol{\\xi} \\in \\mathbb{R}^2$ (units: meter) to correct the trial state to one satisfying the friction law.\n\nStarting from first principles of the frictional admissible set $\\phi(\\boldsymbol{\\tau},p_n) \\le 0$, the Karush–Kuhn–Tucker (KKT) conditions for contact and friction, and the penalty-based elastic predictor, implement the radial return algorithm that maps the trial tangential traction $\\boldsymbol{\\tau}^{\\text{trial}}$ to the return-mapped tangential traction $\\boldsymbol{\\tau}$ and the plastic slip increment $\\Delta \\boldsymbol{\\xi}$. Your implementation must respect the following physically consistent cases:\n- If $p_n \\le 0$ (open contact), set $\\boldsymbol{\\tau} = \\boldsymbol{0}$ and $\\Delta \\boldsymbol{\\xi} = \\boldsymbol{0}$.\n- If $p_n  0$ and $\\phi(\\boldsymbol{\\tau}^{\\text{trial}},p_n) \\le 0$ (stick), set $\\boldsymbol{\\tau} = \\boldsymbol{\\tau}^{\\text{trial}}$ and $\\Delta \\boldsymbol{\\xi} = \\boldsymbol{0}$.\n- If $p_n  0$ and $\\phi(\\boldsymbol{\\tau}^{\\text{trial}},p_n)  0$ (sliding), perform a radial return such that the final traction satisfies $\\|\\boldsymbol{\\tau}\\| = \\mu\\,p_n$ and is colinear with $\\boldsymbol{\\tau}^{\\text{trial}}$, and compute the corresponding plastic slip increment that is consistent with the tangential penalty stiffness $k_t$.\n\nAll quantities in the algorithm must be handled in the following units:\n- Normal traction $p_n$ in pascal (Pa).\n- Tangential traction vectors $\\boldsymbol{\\tau}^{\\text{trial}}$ and $\\boldsymbol{\\tau}$ in pascal (Pa).\n- Tangential penalty stiffness $k_t$ in pascal per meter (Pa/m).\n- Plastic slip increment $\\Delta \\boldsymbol{\\xi}$ in meter (m).\n\nUse the following test suite comprising seven cases, each given as $(p_n,\\mu,\\boldsymbol{\\tau}^{\\text{trial}},k_t)$:\n1. $p_n = 1.0\\times 10^5$ Pa, $\\mu = 0.3$, $\\boldsymbol{\\tau}^{\\text{trial}} = [5.0\\times 10^4,\\,6.0\\times 10^4]$ Pa, $k_t = 1.0\\times 10^9$ Pa/m.\n2. $p_n = 2.0\\times 10^5$ Pa, $\\mu = 0.5$, $\\boldsymbol{\\tau}^{\\text{trial}} = [5.0\\times 10^4,\\,6.0\\times 10^4]$ Pa, $k_t = 1.0\\times 10^9$ Pa/m.\n3. $p_n = 2.6034\\times 10^5$ Pa, $\\mu = 0.3$, $\\boldsymbol{\\tau}^{\\text{trial}} = [5.0\\times 10^4,\\,6.0\\times 10^4]$ Pa, $k_t = 1.0\\times 10^9$ Pa/m.\n4. $p_n = 1.0\\times 10^5$ Pa, $\\mu = 0.0$, $\\boldsymbol{\\tau}^{\\text{trial}} = [1.0\\times 10^4,\\,0.0]$ Pa, $k_t = 1.0\\times 10^8$ Pa/m.\n5. $p_n = -1.0\\times 10^4$ Pa, $\\mu = 0.3$, $\\boldsymbol{\\tau}^{\\text{trial}} = [2.0\\times 10^4,\\,0.0]$ Pa, $k_t = 1.0\\times 10^9$ Pa/m.\n6. $p_n = 5.0\\times 10^4$ Pa, $\\mu = 0.6$, $\\boldsymbol{\\tau}^{\\text{trial}} = [0.0,\\,0.0]$ Pa, $k_t = 1.0\\times 10^9$ Pa/m.\n7. $p_n = 1.0\\times 10^5$ Pa, $\\mu = 0.3$, $\\boldsymbol{\\tau}^{\\text{trial}} = [5.0\\times 10^4,\\,6.0\\times 10^4]$ Pa, $k_t = 1.0\\times 10^{12}$ Pa/m.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each result must be a list of four real numbers $[\\tau_x,\\tau_y,\\Delta \\xi_x,\\Delta \\xi_y]$, where $[\\tau_x,\\tau_y]$ is the return-mapped tangential traction (in pascal) and $[\\Delta \\xi_x,\\Delta \\xi_y]$ is the plastic slip increment (in meter) for the corresponding case. For example, the final output format must be of the form\n$$\n[\\,[\\tau_x^{(1)},\\tau_y^{(1)},\\Delta \\xi_x^{(1)},\\Delta \\xi_y^{(1)}],\\,[\\tau_x^{(2)},\\tau_y^{(2)},\\Delta \\xi_x^{(2)},\\Delta \\xi_y^{(2)}],\\,\\dots\\,].\n$$", "solution": "The starting point is the friction admissibility condition from the Coulomb law, expressed by the yield function\n$$\n\\phi(\\boldsymbol{\\tau},p_n) = \\|\\boldsymbol{\\tau}\\| - \\mu\\,p_n \\le 0,\n$$\nwith $\\mu \\ge 0$ and $p_n$ taken positive in compression. The Karush–Kuhn–Tucker (KKT) structure for friction indicates three regimes: open contact ($p_n \\le 0$), stick ($p_n  0$ and $\\phi \\le 0$), and sliding ($p_n  0$ and $\\phi = 0$ with nonzero slip increment). In a penalty-based discretization, a purely elastic predictor delivers a trial traction $\\boldsymbol{\\tau}^{\\text{trial}}$ resulting from a trial slip increment through the tangential stiffness $k_t$. If the trial state violates $\\phi \\le 0$, a plastic correction is applied.\n\nIn the open-contact regime where $p_n \\le 0$, no compressive normal traction can be sustained and tangential traction must vanish:\n$$\n\\boldsymbol{\\tau} = \\boldsymbol{0}, \\quad \\Delta \\boldsymbol{\\xi} = \\boldsymbol{0}.\n$$\n\nIn the stick regime for $p_n  0$ and $\\phi(\\boldsymbol{\\tau}^{\\text{trial}},p_n) \\le 0$, the trial state is admissible, meaning no plastic slip increment is needed:\n$$\n\\boldsymbol{\\tau} = \\boldsymbol{\\tau}^{\\text{trial}}, \\quad \\Delta \\boldsymbol{\\xi} = \\boldsymbol{0}.\n$$\n\nIn the sliding regime for $p_n  0$ and $\\phi(\\boldsymbol{\\tau}^{\\text{trial}},p_n)  0$, the return mapping seeks a corrected traction that lies on the friction boundary, is colinear with the trial traction, and is consistent with the penalty stiffness. Denote the unit direction of the trial traction by\n$$\n\\boldsymbol{m} = \\frac{\\boldsymbol{\\tau}^{\\text{trial}}}{\\|\\boldsymbol{\\tau}^{\\text{trial}}\\|}.\n$$\nThe radial return enforces colinearity and boundary admissibility by\n$$\n\\boldsymbol{\\tau} = \\mu\\,p_n\\,\\boldsymbol{m}.\n$$\nTo compute the plastic slip increment, we use the penalty relation that the plastic correction reduces the trial traction:\n$$\n\\boldsymbol{\\tau} = \\boldsymbol{\\tau}^{\\text{trial}} - k_t\\,\\Delta \\boldsymbol{\\xi}.\n$$\nUnder radial return, take $\\Delta \\boldsymbol{\\xi}$ aligned with $\\boldsymbol{m}$ as $\\Delta \\boldsymbol{\\xi} = \\Delta \\gamma\\,\\boldsymbol{m}$, where $\\Delta \\gamma$ is a scalar with units of meter. Projecting the penalty relation onto $\\boldsymbol{m}$ yields\n$$\n\\mu\\,p_n = \\|\\boldsymbol{\\tau}^{\\text{trial}}\\| - k_t\\,\\Delta \\gamma \\quad \\Rightarrow \\quad \\Delta \\gamma = \\frac{\\|\\boldsymbol{\\tau}^{\\text{trial}}\\| - \\mu\\,p_n}{k_t}.\n$$\nTherefore, the plastic slip increment vector is\n$$\n\\Delta \\boldsymbol{\\xi} = \\Delta \\gamma\\,\\boldsymbol{m} = \\frac{\\|\\boldsymbol{\\tau}^{\\text{trial}}\\| - \\mu\\,p_n}{k_t}\\,\\frac{\\boldsymbol{\\tau}^{\\text{trial}}}{\\|\\boldsymbol{\\tau}^{\\text{trial}}\\|}.\n$$\nThis expression is physically consistent: when $\\mu = 0$ and $p_n  0$, the return-mapped traction vanishes and the slip increment magnitude reduces to $\\|\\boldsymbol{\\tau}^{\\text{trial}}\\|/k_t$ in the direction of $\\boldsymbol{\\tau}^{\\text{trial}}$; when $\\phi(\\boldsymbol{\\tau}^{\\text{trial}},p_n) = 0$ exactly, $\\Delta \\gamma = 0$ and $\\boldsymbol{\\tau} = \\boldsymbol{\\tau}^{\\text{trial}}$ as a boundary stick state; when $\\boldsymbol{\\tau}^{\\text{trial}} = \\boldsymbol{0}$, both the traction and the slip increment are zero.\n\nAlgorithmic steps to implement for each test case $(p_n,\\mu,\\boldsymbol{\\tau}^{\\text{trial}},k_t)$ are:\n1. Compute $s = \\|\\boldsymbol{\\tau}^{\\text{trial}}\\|$.\n2. If $p_n \\le 0$, set $\\boldsymbol{\\tau} = \\boldsymbol{0}$ and $\\Delta \\boldsymbol{\\xi} = \\boldsymbol{0}$.\n3. Else, compute $\\phi^{\\text{trial}} = s - \\mu\\,p_n$.\n4. If $\\phi^{\\text{trial}} \\le 0$, set $\\boldsymbol{\\tau} = \\boldsymbol{\\tau}^{\\text{trial}}$ and $\\Delta \\boldsymbol{\\xi} = \\boldsymbol{0}$.\n5. If $\\phi^{\\text{trial}}  0$, set $\\boldsymbol{m} = \\boldsymbol{\\tau}^{\\text{trial}}/s$, $\\boldsymbol{\\tau} = \\mu\\,p_n\\,\\boldsymbol{m}$, and $\\Delta \\boldsymbol{\\xi} = \\left(\\phi^{\\text{trial}}/k_t\\right)\\,\\boldsymbol{m}$.\n\nApplying the above to the specified test suite yields, for each case, the ordered list $[\\tau_x,\\tau_y,\\Delta \\xi_x,\\Delta \\xi_y]$ with $\\boldsymbol{\\tau}$ in pascal and $\\Delta \\boldsymbol{\\xi}$ in meter, which the program outputs as a single line containing the list of these lists for all seven cases.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef radial_return(p_n: float, mu: float, kt: float, tau_trial: np.ndarray):\n    \"\"\"\n    Perform radial return mapping for planar Coulomb friction with tangential penalty stiffness.\n\n    Parameters\n    ----------\n    p_n : float\n        Normal traction (Pa), positive in compression.\n    mu : float\n        Friction coefficient (dimensionless).\n    kt : float\n        Tangential penalty stiffness (Pa/m).\n    tau_trial : np.ndarray\n        Trial tangential traction vector (Pa), shape (2,).\n\n    Returns\n    -------\n    tau : np.ndarray\n        Return-mapped tangential traction vector (Pa), shape (2,).\n    dxi : np.ndarray\n        Plastic slip increment vector (m), shape (2,).\n    \"\"\"\n    # Ensure tau_trial is a numpy array\n    t_trial = np.asarray(tau_trial, dtype=float)\n    s = np.linalg.norm(t_trial)\n\n    # Open contact: no traction, no slip increment\n    if p_n = 0.0:\n        return np.array([0.0, 0.0], dtype=float), np.array([0.0, 0.0], dtype=float)\n\n    # Trial yield function\n    phi_trial = s - mu * p_n\n\n    # Stick: admissible trial state\n    if phi_trial = 0.0 or s == 0.0:\n        return t_trial.copy(), np.array([0.0, 0.0], dtype=float)\n\n    # Sliding: radial return to yield surface\n    m = t_trial / s  # unit direction\n    tau = (mu * p_n) * m\n    # Plastic consistency parameter magnitude\n    delta_gamma = phi_trial / kt\n    dxi = delta_gamma * m\n    return tau, dxi\n\ndef solve():\n    # Define the test cases from the problem statement: (p_n, mu, tau_trial, k_t)\n    test_cases = [\n        (1.0e5, 0.3, np.array([5.0e4, 6.0e4]), 1.0e9),\n        (2.0e5, 0.5, np.array([5.0e4, 6.0e4]), 1.0e9),\n        (2.6034e5, 0.3, np.array([5.0e4, 6.0e4]), 1.0e9),\n        (1.0e5, 0.0, np.array([1.0e4, 0.0]), 1.0e8),\n        (-1.0e4, 0.3, np.array([2.0e4, 0.0]), 1.0e9),\n        (5.0e4, 0.6, np.array([0.0, 0.0]), 1.0e9),\n        (1.0e5, 0.3, np.array([5.0e4, 6.0e4]), 1.0e12),\n    ]\n\n    results = []\n    for p_n, mu, tau_trial, kt in test_cases:\n        tau, dxi = radial_return(p_n, mu, kt, tau_trial)\n        # Prepare list [tau_x, tau_y, dxi_x, dxi_y]\n        result = [float(tau[0]), float(tau[1]), float(dxi[0]), float(dxi[1])]\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # Single line: list of lists\n    def fmt(x):\n        # Use default str for floats; ensure no extraneous spaces\n        return str(x)\n\n    inner = []\n    for r in results:\n        inner.append(f\"[{','.join(fmt(x) for x in r)}]\")\n    print(f\"[{','.join(inner)}]\")\n\nsolve()\n```", "id": "3534224"}, {"introduction": "Real geological joints often exhibit more complex behavior than simple friction, such as dilating (opening) during shear. This advanced practice [@problem_id:3534255] extends the return-mapping concept to a full interface plasticity model that includes shear-normal coupling. By implementing and comparing associative ($\\psi = \\phi$) and non-associative ($\\psi \\lt \\phi$) flow rules, you will explore the critical role of the dilation angle $\\psi$ in predicting the behavior of rock joints and faults.", "problem": "You are to implement a small-strain, rate-independent, perfectly plastic interface constitutive update and use it to compare associative plasticity, where the plastic flow potential equals the yield function, and non-associative plasticity, where the plastic flow potential differs from the yield function, in terms of dilative joint response under triaxial compression. The educational context is computational geomechanics focusing on interface and contact mechanics fundamentals. The implementation must be a complete, runnable program.\n\nAssume a frictional joint modeled as an interface element with elastic normal stiffness $K_n$ and elastic shear stiffness $K_s$, relating tractions to elastic parts of displacement jumps. Let the shear traction be $ \\tau $ and the normal traction be $ \\sigma_n $, both defined as positive in the directions of positive shear and compression, respectively. Let the total shear displacement jump be $ \\delta_s $ and the total normal displacement jump be $ \\delta_n $. Let the plastic parts be $ \\delta_s^p $ and $ \\delta_n^p $. The elastic parts are then $ \\delta_s - \\delta_s^p $ and $ \\delta_n - \\delta_n^p $.\n\nUse the widely accepted frictional yield function\n$$ f = \\tau - \\mu \\, \\sigma_n, $$\nwhere $ \\mu = \\tan \\phi $ with $ \\phi $ the friction angle. Use the plastic flow potential\n$$ g = \\tau - \\tan \\psi \\, \\sigma_n, $$\nwhere $ \\psi $ is the dilation angle. Associative plasticity corresponds to $ \\psi = \\phi $, and non-associative plasticity corresponds to $ \\psi \\neq \\phi $.\n\nAdopt the following fundamental definitions and principles as the base:\n- The elastic traction-displacement relations: $ \\tau = K_s \\, (\\delta_s - \\delta_s^p) $ and $ \\sigma_n = K_n \\, (\\delta_n - \\delta_n^p) $.\n- The standard rate-independent plasticity conditions (Kuhn-Tucker conditions): $ f \\le 0 $, $ \\dot{\\lambda} \\ge 0 $, and $ \\dot{\\lambda} \\, f = 0 $, where $ \\dot{\\lambda} $ is the plastic multiplier rate.\n- The normality rule for the plastic flow defined by $ g $, giving plastic increments proportional to the gradient of $ g $: $ \\Delta \\delta_s^p = \\Delta \\lambda \\, \\frac{\\partial g}{\\partial \\tau} $ and $ \\Delta \\delta_n^p = \\Delta \\lambda \\, \\frac{\\partial g}{\\partial \\sigma_n} $.\n- For small increments, $ \\frac{\\partial g}{\\partial \\tau} = 1 $ and $ \\frac{\\partial g}{\\partial \\sigma_n} = - \\tan \\psi $.\n\nConsider a discrete incremental loading consisting of a finite sequence of prescribed displacement jump increments $ (\\Delta \\delta_s, \\Delta \\delta_n) $. At each increment, perform an elastic trial, check the yield condition, and if $ f  0 $, enforce plastic consistency using the flow potential to correct the state. Assume the joint remains in compression throughout the tests, and neglect separation; do not enforce tension cut-off in this problem.\n\nYour tasks are:\n1. Starting strictly from the fundamental base given above (without introducing any shortcut formulas), derive the algorithmic expression for the plastic correction needed to return the state to the yield surface when the elastic trial state violates $ f \\le 0 $. Show how to obtain the plastic multiplier increment $ \\Delta \\lambda $ and the corresponding updates of $ \\delta_s^p $ and $ \\delta_n^p $ that achieve $ f = 0 $ after correction.\n2. Implement a robust incremental update that, for each loading increment,\n   - Updates $ \\delta_s $ and $ \\delta_n $,\n   - Forms the elastic trial tractions,\n   - Checks the yield function,\n   - Performs associative or non-associative plastic correction as needed,\n   - Outputs the final shear traction $ \\tau $ and the accumulated plastic normal opening magnitude, defined as $ \\max(0, -\\delta_n^p) $, where a negative $ \\delta_n^p $ represents dilative opening in this sign convention.\n\nAngles must be provided in degrees but internally converted to radians for trigonometric functions. Express shear traction in Pascals and plastic normal opening magnitude in meters. All outputs must be floats in International System of Units (SI).\n\nUse the following test suite, each test defined by $ (K_s, K_n, \\phi, \\psi, \\text{increments}) $ with increments given as a list of three or fewer pairs $ (\\Delta \\delta_s, \\Delta \\delta_n) $ in meters:\n\n- Test 1 (associative, dilative, happy path): $ K_s = 5.0 \\times 10^9 $, $ K_n = 6.0 \\times 10^9 $, $ \\phi = 30^\\circ $, $ \\psi = 30^\\circ $, increments $ [(1.0 \\times 10^{-5}, \\; 3.0 \\times 10^{-6}), (1.0 \\times 10^{-5}, \\; 3.0 \\times 10^{-6}), (1.0 \\times 10^{-5}, \\; 3.0 \\times 10^{-6})] $.\n- Test 2 (non-associative, reduced dilation): $ K_s = 5.0 \\times 10^9 $, $ K_n = 6.0 \\times 10^9 $, $ \\phi = 30^\\circ $, $ \\psi = 10^\\circ $, increments $ [(1.0 \\times 10^{-5}, \\; 3.0 \\times 10^{-6}), (1.0 \\times 10^{-5}, \\; 3.0 \\times 10^{-6}), (1.0 \\times 10^{-5}, \\; 3.0 \\times 10^{-6})] $.\n- Test 3 (elastic regime, no yield): $ K_s = 2.0 \\times 10^9 $, $ K_n = 6.0 \\times 10^9 $, $ \\phi = 35^\\circ $, $ \\psi = 30^\\circ $, increments $ [(2.0 \\times 10^{-6}, \\; 3.0 \\times 10^{-6}), (2.0 \\times 10^{-6}, \\; 3.0 \\times 10^{-6}), (2.0 \\times 10^{-6}, \\; 3.0 \\times 10^{-6})] $.\n- Test 4 (associative, near-critical algorithmic denominator): $ K_s = 1.107 \\times 10^9 $, $ K_n = 5.0 \\times 10^9 $, $ \\phi = 25^\\circ $, $ \\psi = 25^\\circ $, increments $ [(2.0 \\times 10^{-5}, \\; 4.0 \\times 10^{-6}), (2.0 \\times 10^{-5}, \\; 4.0 \\times 10^{-6})] $.\n- Test 5 (non-associative, zero dilation boundary): $ K_s = 5.0 \\times 10^9 $, $ K_n = 6.0 \\times 10^9 $, $ \\phi = 30^\\circ $, $ \\psi = 0^\\circ $, increments $ [(1.0 \\times 10^{-5}, \\; 3.0 \\times 10^{-6}), (1.0 \\times 10^{-5}, \\; 3.0 \\times 10^{-6}), (1.0 \\times 10^{-5}, \\; 3.0 \\times 10^{-6})] $.\n\nFor each test, compute after the final increment:\n- The accumulated plastic normal opening magnitude $ \\max(0, -\\delta_n^p) $ in meters.\n- The final shear traction $ \\tau $ in Pascals.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case result is a two-element list $ [\\text{opening\\_m}, \\text{tau\\_Pa}] $. For example, the output format must be like $ [[o_1,t_1],[o_2,t_2],\\dots] $ with all values as floats and no additional text.", "solution": "The problem requires the derivation and implementation of a constitutive update algorithm for a frictional interface exhibiting rate-independent, perfectly plastic behavior. The core of the task is to correctly apply the return-mapping algorithm for a given yield function and flow potential, and to compare the outcomes for associative and non-associative plasticity, specifically concerning shear-induced dilation.\n\nThe problem is governed by a set of fundamental principles from continuum plasticity theory, applied to an interface element. Let the state at the beginning of an increment be known. This includes the total displacement jumps, $(\\delta_s, \\delta_n)$, and the accumulated plastic displacement jumps, $(\\delta_s^p, \\delta_n^p)$. The corresponding tractions are $\\tau = K_s(\\delta_s - \\delta_s^p)$ and $\\sigma_n = K_n(\\delta_n - \\delta_n^p)$. We are given a prescribed displacement increment, $(\\Delta \\delta_s, \\Delta \\delta_n)$.\n\nThe update procedure follows a standard predictor-corrector scheme.\n\nFirst, the total displacement jumps are updated to their values at the end of the increment:\n$$ \\delta_{s, \\text{new}} = \\delta_{s, \\text{old}} + \\Delta \\delta_s $$\n$$ \\delta_{n, \\text{new}} = \\delta_{n, \\text{old}} + \\Delta \\delta_n $$\n\nNext, an elastic trial state is computed. This predictor step assumes the entire increment is elastic. The plastic variables are held constant, and trial tractions are calculated:\n$$ \\delta_{s, \\text{new}}^{p, \\text{trial}} = \\delta_{s, \\text{old}}^p $$\n$$ \\delta_{n, \\text{new}}^{p, \\text{trial}} = \\delta_{n, \\text{old}}^p $$\n$$ \\tau^{\\text{trial}} = K_s (\\delta_{s, \\text{new}} - \\delta_{s, \\text{old}}^p) $$\n$$ \\sigma_n^{\\text{trial}} = K_n (\\delta_{n, \\text{new}} - \\delta_{n, \\text{old}}^p) $$\n\nThe trial state is then checked against the yield condition. The yield function is given as $f = \\tau - \\mu \\sigma_n$, where $\\mu = \\tan\\phi$. We evaluate $f$ at the trial state:\n$$ f^{\\text{trial}} = \\tau^{\\text{trial}} - \\mu \\sigma_n^{\\text{trial}} $$\nIf $f^{\\text{trial}} \\le 0$, the elastic assumption is valid. The trial state is the final state for the increment. The plastic multiplier increment is $\\Delta\\lambda = 0$, and the plastic displacement jumps do not change.\n\nIf $f^{\\text{trial}}  0$, the interface has yielded, and a plastic correction is necessary. The final state must lie on the yield surface, i.e., $f_{\\text{new}} = 0$. This is the consistency condition. The plastic flow is governed by the flow potential $g = \\tau - \\tan\\psi \\sigma_n$ and the normality rule. The increments in plastic displacement jumps are:\n$$ \\Delta\\delta_s^p = \\Delta\\lambda \\frac{\\partial g}{\\partial \\tau} = \\Delta\\lambda (1) = \\Delta\\lambda $$\n$$ \\Delta\\delta_n^p = \\Delta\\lambda \\frac{\\partial g}{\\partial \\sigma_n} = \\Delta\\lambda (-\\tan\\psi) = -\\Delta\\lambda \\tan\\psi $$\nwhere $\\Delta\\lambda  0$ is the plastic multiplier increment. The updated plastic displacements are:\n$$ \\delta_{s, \\text{new}}^p = \\delta_{s, \\text{old}}^p + \\Delta\\delta_s^p $$\n$$ \\delta_{n, \\text{new}}^p = \\delta_{n, \\text{old}}^p + \\Delta\\delta_n^p $$\n\nThe final tractions at the end of the increment are related to the trial tractions and the plastic correction:\n$$ \\tau_{\\text{new}} = K_s(\\delta_{s, \\text{new}} - \\delta_{s, \\text{new}}^p) = K_s(\\delta_{s, \\text{new}} - \\delta_{s, \\text{old}}^p - \\Delta\\delta_s^p) = \\tau^{\\text{trial}} - K_s \\Delta\\delta_s^p $$\n$$ \\sigma_{n, \\text{new}} = K_n(\\delta_{n, \\text{new}} - \\delta_{n, \\text{new}}^p) = K_n(\\delta_{n, \\text{new}} - \\delta_{n, \\text{old}}^p - \\Delta\\delta_n^p) = \\sigma_n^{\\text{trial}} - K_n \\Delta\\delta_n^p $$\nSubstituting the expressions for the plastic increments:\n$$ \\tau_{\\text{new}} = \\tau^{\\text{trial}} - K_s \\Delta\\lambda $$\n$$ \\sigma_{n, \\text{new}} = \\sigma_n^{\\text{trial}} - K_n (-\\Delta\\lambda \\tan\\psi) = \\sigma_n^{\\text{trial}} + K_n \\Delta\\lambda \\tan\\psi $$\nThese equations describe the return path from the trial state back to the yield surface. The final state must satisfy the consistency condition $f_{\\text{new}} = 0$:\n$$ f_{\\text{new}} = \\tau_{\\text{new}} - \\mu \\sigma_{n, \\text{new}} = 0 $$\nSubstituting the expressions for $\\tau_{\\text{new}}$ and $\\sigma_{n, \\text{new}}$:\n$$ (\\tau^{\\text{trial}} - K_s \\Delta\\lambda) - \\mu (\\sigma_n^{\\text{trial}} + K_n \\Delta\\lambda \\tan\\psi) = 0 $$\nThis equation can be rearranged to solve for the unknown plastic multiplier increment $\\Delta\\lambda$.\n$$ \\tau^{\\text{trial}} - \\mu \\sigma_n^{\\text{trial}} = K_s \\Delta\\lambda + \\mu K_n \\Delta\\lambda \\tan\\psi $$\nThe left-hand side is precisely the value of the yield function at the trial state, $f^{\\text{trial}}$. Factoring out $\\Delta\\lambda$ on the right-hand side gives:\n$$ f^{\\text{trial}} = \\Delta\\lambda (K_s + \\mu K_n \\tan\\psi) $$\nFrom this, we derive the final expression for the plastic multiplier increment:\n$$ \\Delta\\lambda = \\frac{f^{\\text{trial}}}{K_s + \\mu K_n \\tan\\psi} = \\frac{\\tau^{\\text{trial}} - (\\tan\\phi) \\sigma_n^{\\text{trial}}}{K_s + (\\tan\\phi) K_n (\\tan\\psi)} $$\nSince $f^{\\text{trial}}  0$ and the denominator, representing a combination of elastic stiffnesses, is positive for all physically relevant material parameters ($K_s  0, K_n  0, \\phi \\ge 0, \\psi \\ge 0$), it is guaranteed that $\\Delta\\lambda  0$, consistent with the Kuhn-Tucker conditions for plastic loading.\n\nOnce $\\Delta\\lambda$ is computed, the state is fully updated. The plastic displacement increments are calculated, added to the previous accumulated values, and the final tractions are computed using the elastic law with the updated plastic displacements. This completes the constitutive update for one increment.\n\nThe implementation will consist of a loop over the prescribed increments for each test case. Inside the loop, this exact predictor-corrector algorithm is executed. Initial conditions for all tests are zero displacements, zero plastic displacements, and zero tractions. The program will track the evolution of $\\delta_s^p$ and $\\delta_n^p$ over the loading path. Dilation, or plastic opening of the joint, corresponds to a negative value of $\\delta_n^p$ under our sign convention (positive normal displacement is compression), so the opening magnitude is given by $-\\delta_n^p$. The final outputs for each test case are the accumulated plastic opening magnitude, $\\max(0, -\\delta_n^p)$, and the final shear traction, $\\tau$, after all increments have been processed.", "answer": "```python\nimport numpy as np\nimport json\n\ndef solve():\n    \"\"\"\n    Solves the interface plasticity problem for a suite of test cases.\n    \"\"\"\n\n    test_cases = [\n        # Test 1 (associative, dilative, happy path)\n        (5.0e9, 6.0e9, 30.0, 30.0, [(1.0e-5, 3.0e-6), (1.0e-5, 3.0e-6), (1.0e-5, 3.0e-6)]),\n        # Test 2 (non-associative, reduced dilation)\n        (5.0e9, 6.0e9, 30.0, 10.0, [(1.0e-5, 3.0e-6), (1.0e-5, 3.0e-6), (1.0e-5, 3.0e-6)]),\n        # Test 3 (elastic regime, no yield)\n        (2.0e9, 6.0e9, 35.0, 30.0, [(2.0e-6, 3.0e-6), (2.0e-6, 3.0e-6), (2.0e-6, 3.0e-6)]),\n        # Test 4 (associative, near-critical algorithmic denominator)\n        (1.107e9, 5.0e9, 25.0, 25.0, [(2.0e-5, 4.0e-6), (2.0e-5, 4.0e-6)]),\n        # Test 5 (non-associative, zero dilation boundary)\n        (5.0e9, 6.0e9, 30.0, 0.0, [(1.0e-5, 3.0e-6), (1.0e-5, 3.0e-6), (1.0e-5, 3.0e-6)]),\n    ]\n\n    results = []\n    for case in test_cases:\n        opening, tau = run_simulation(*case)\n        results.append([opening, tau])\n\n    # Format the final output string to match the required format '[[o1,t1],[o2,t2],...]'\n    # Using json.dumps is a reliable way to get this format, but as it's not standard lib, we'll build it.\n    # An alternative is str(results).replace(' ', '')\n    output_str = str(results).replace(\" \", \"\")\n    print(output_str)\n\n\ndef run_simulation(Ks, Kn, phi_deg, psi_deg, increments):\n    \"\"\"\n    Performs the incremental analysis for a single test case.\n\n    Args:\n        Ks (float): Shear stiffness (Pa/m).\n        Kn (float): Normal stiffness (Pa/m).\n        phi_deg (float): Friction angle (degrees).\n        psi_deg (float): Dilation angle (degrees).\n        increments (list of tuples): List of (d_delta_s, d_delta_n) increments.\n\n    Returns:\n        tuple: (accumulated plastic normal opening in m, final shear traction in Pa).\n    \"\"\"\n    # Convert angles to radians\n    phi = np.deg2rad(phi_deg)\n    psi = np.deg2rad(psi_deg)\n    \n    # Pre-calculate trigonometric values\n    tan_phi = np.tan(phi)\n    tan_psi = np.tan(psi)\n    \n    # Initialize state variables\n    delta_s = 0.0  # Total shear displacement jump\n    delta_n = 0.0  # Total normal displacement jump\n    delta_s_p = 0.0  # Plastic shear displacement jump\n    delta_n_p = 0.0  # Plastic normal displacement jump\n\n    for d_delta_s, d_delta_n in increments:\n        # Update total displacement jumps\n        delta_s += d_delta_s\n        delta_n += d_delta_n\n        \n        # --- Elastic Trial ---\n        tau_trial = Ks * (delta_s - delta_s_p)\n        sigma_n_trial = Kn * (delta_n - delta_n_p)\n        \n        # --- Yield Check ---\n        f_trial = tau_trial - tan_phi * sigma_n_trial\n        \n        if f_trial  0:\n            # --- Plastic Corrector ---\n            denominator = Ks + tan_phi * Kn * tan_psi\n            delta_lambda = f_trial / denominator\n            \n            # --- Update Plastic State ---\n            d_delta_s_p = delta_lambda\n            d_delta_n_p = -delta_lambda * tan_psi\n            \n            delta_s_p += d_delta_s_p\n            delta_n_p += d_delta_n_p\n\n    # After all increments, calculate final tractions and outputs\n    final_tau = Ks * (delta_s - delta_s_p)\n    # The normal displacement jump delta_n is positive in compression.\n    # Plastic dilation (opening) corresponds to a negative delta_n_p.\n    # The magnitude of opening is therefore -delta_n_p.\n    final_opening = max(0.0, -delta_n_p)\n\n    return final_opening, final_tau\n\nsolve()\n```", "id": "3534255"}]}