{"hands_on_practices": [{"introduction": "Before a finite element can be trusted in complex simulations, it must be rigorously verified against known solutions. This fundamental practice guides you through the implementation of the essential components of a linear elastic zero-thickness interface element—the internal force vector and the tangent stiffness matrix. By performing a suite of standard verification tests, you will build confidence in your implementation and gain a deeper understanding of the element's kinematic and constitutive behavior, ensuring its correctness and robustness [@problem_id:3571998].", "problem": "Consider a zero-thickness interface element in two spatial dimensions that connects two coincident line segments. The interface element has two geometrical nodes, with each geometrical node duplicated to represent the kinematics on the minus and plus sides. Thus the element has four nodes in total and eight displacement degrees of freedom, ordered as node $1$ (minus side), node $2$ (minus side), node $3$ (plus side), and node $4$ (plus side), each with global displacement components in the $x$ and $y$ directions. The element is straight, of length $L$, with a constant unit tangent vector $\\mathbf{t}$ aligned with the element and a unit normal vector $\\mathbf{n}$ pointing from the minus side to the plus side. The orientation is defined by an angle $\\theta$ (in radians) such that the global tangent vector is $\\mathbf{t} = [\\cos \\theta, \\sin \\theta]^{\\top}$ and the global normal vector is $\\mathbf{n} = [-\\sin \\theta, \\cos \\theta]^{\\top}$. The local-to-global rotation matrix is the $2 \\times 2$ matrix $\\mathbf{R} = [\\mathbf{n}\\ \\mathbf{t}]$ whose columns are $\\mathbf{n}$ and $\\mathbf{t}$. The mapping from global to local coordinates is given by $\\mathbf{R}^{\\top}$. Assume small displacements.\n\nThe interface traction-separation law is linear elastic and uncoupled in the local normal and tangential directions. Let the local displacement jump vector be $\\boldsymbol{\\delta} = [\\delta_{n}, \\delta_{t}]^{\\top}$, with $\\delta_{n}$ the opening (positive in tension along $\\mathbf{n}$) and $\\delta_{t}$ the sliding (positive along $\\mathbf{t}$). The local traction vector is $\\mathbf{t}^{\\text{loc}} = [t_{n}, t_{t}]^{\\top}$. The constitutive relation is\n$$\n\\mathbf{t}^{\\text{loc}} = \\mathbf{C}\\ \\boldsymbol{\\delta}, \\quad \\mathbf{C} = \\begin{bmatrix} k_{n} & 0 \\\\ 0 & k_{t} \\end{bmatrix},\n$$\nwhere $k_{n} \\ge 0$ and $k_{t} \\ge 0$ are the normal and tangential stiffness parameters (nondimensional for this problem).\n\nLet $\\xi \\in [-1, 1]$ denote the isoparametric coordinate along the interface. Use linear shape functions $N_{1}(\\xi) = \\frac{1 - \\xi}{2}$ and $N_{2}(\\xi) = \\frac{1 + \\xi}{2}$. At any point $\\xi$, the local displacement jump is obtained from the nodal global displacements by\n$$\n\\boldsymbol{\\delta}(\\xi) = \\mathbf{R}^{\\top} \\sum_{i=1}^{2} N_{i}(\\xi) \\left( \\mathbf{u}^{+}_{i} - \\mathbf{u}^{-}_{i} \\right),\n$$\nwhere $\\mathbf{u}^{-}_{i}$ and $\\mathbf{u}^{+}_{i}$ are the global displacement vectors at the minus and plus side duplicates of geometrical node $i$.\n\nStarting from the principle of virtual work for interfaces and basic finite element interpolation,\n$$\n\\delta W_{\\text{int}} = \\int_{\\Gamma} \\delta \\boldsymbol{\\delta}^{\\top} \\mathbf{t}^{\\text{loc}}\\ \\mathrm{d}\\Gamma, \\quad \\mathbf{t}^{\\text{loc}} = \\mathbf{C}\\ \\boldsymbol{\\delta},\n$$\nderive the algebraic expressions for the element residual vector $\\mathbf{r}_{e}$ and the consistent tangent stiffness matrix $\\mathbf{K}_{e}$ using one-point Gauss quadrature at $\\xi = 0$ with weight $w = 2$ and the exact Jacobian $J = L/2$. Specifically, use the mapping\n$$\n\\boldsymbol{\\delta}(0) = \\mathbf{B}\\ \\boldsymbol{u}_{e}, \\quad \\mathbf{B} = \\begin{bmatrix} -\\tfrac{1}{2}\\mathbf{R}^{\\top} & -\\tfrac{1}{2}\\mathbf{R}^{\\top} & \\tfrac{1}{2}\\mathbf{R}^{\\top} & \\tfrac{1}{2}\\mathbf{R}^{\\top} \\end{bmatrix},\n$$\nwhere $\\boldsymbol{u}_{e} \\in \\mathbb{R}^{8}$ stacks the global displacements of the four nodes in the order $\\{1x, 1y, 2x, 2y, 3x, 3y, 4x, 4y\\}$. From first principles, express $\\mathbf{r}_{e}$ and $\\mathbf{K}_{e}$ in terms of $L$, $\\mathbf{B}$, and $\\mathbf{C}$, and explain why the element stiffness is positive semidefinite.\n\nThen, implement a program that computes $\\mathbf{r}_{e}$ and $\\mathbf{K}_{e}$ for a given set of parameters and nodal displacements and uses them to verify and benchmark the element through the following test suite. Use nondimensional quantities; no physical units are required. All angles must be in radians.\n\nTest suite parameter sets:\n\n- Test $1$ (analytical force distribution under uniform local gap):\n  - $L = 2$, $\\theta = 0$, $k_{n} = 1000$, $k_{t} = 500$.\n  - Prescribe a uniform local gap by setting $\\mathbf{u}^{-}_{1} = \\mathbf{u}^{-}_{2} = \\mathbf{0}$ and $\\mathbf{u}^{+}_{1} = \\mathbf{u}^{+}_{2} = \\mathbf{R}\\ [\\delta_{n}, \\delta_{t}]^{\\top}$ with $\\delta_{n} = 0.01$ and $\\delta_{t} = -0.02$.\n  - Compute the element internal force vector $\\mathbf{r}_{e}$ and compare it to the exact nodal force pattern implied by the balance of linear momentum and the constitutive law for a uniform local traction. Report the relative error as a float.\n\n- Test $2$ (stiffness symmetry check):\n  - $L = 1.3$, $\\theta = 0.37$, $k_{n} = 800$, $k_{t} = 1200$.\n  - Use $\\mathbf{u}^{-}_{1} = \\mathbf{u}^{-}_{2} = \\mathbf{0}$ and $\\mathbf{u}^{+}_{1} = \\mathbf{u}^{+}_{2} = \\mathbf{R}\\ [0.013, -0.007]^{\\top}$.\n  - Compute $\\mathbf{K}_{e}$ and report the relative symmetry defect $\\|\\mathbf{K}_{e} - \\mathbf{K}_{e}^{\\top}\\|_{F} / \\|\\mathbf{K}_{e}\\|_{F}$ as a float.\n\n- Test $3$ (frame invariance under rotation):\n  - $L = 2$, $\\theta_{0} = 0$, $\\theta_{1} = \\pi/3$, $k_{n} = 900$, $k_{t} = 300$.\n  - Use the same uniform local gap vector $[\\delta_{n}, \\delta_{t}]^{\\top} = [0.02, 0.01]^{\\top}$ for both orientations by setting $\\mathbf{u}^{-}_{i} = \\mathbf{0}$ and $\\mathbf{u}^{+}_{i} = \\mathbf{R}(\\theta)\\ [\\delta_{n}, \\delta_{t}]^{\\top}$ for each $\\theta \\in \\{\\theta_{0}, \\theta_{1}\\}$.\n  - Compute $\\mathbf{r}_{e}(\\theta_{0})$ and $\\mathbf{r}_{e}(\\theta_{1})$. Let $\\mathbf{T} = \\mathbf{R}(\\theta_{1})\\ \\mathbf{R}(\\theta_{0})^{\\top}$ and $\\mathbf{Q} = \\mathrm{diag}(\\mathbf{T}, \\mathbf{T}, \\mathbf{T}, \\mathbf{T})$. Report the relative difference $\\|\\mathbf{r}_{e}(\\theta_{1}) - \\mathbf{Q}\\ \\mathbf{r}_{e}(\\theta_{0})\\|_{2} / \\|\\mathbf{r}_{e}(\\theta_{1})\\|_{2}$ as a float.\n\n- Test $4$ (edge case with zero tangential stiffness):\n  - $L = 3$, $\\theta = 0.5$, $k_{n} = 700$, $k_{t} = 0$.\n  - Use a pure sliding gap with $\\delta_{n} = 0$ and $\\delta_{t} = 0.05$, by setting $\\mathbf{u}^{-}_{i} = \\mathbf{0}$ and $\\mathbf{u}^{+}_{i} = \\mathbf{R}\\ [0, 0.05]^{\\top}$.\n  - Compute $\\mathbf{r}_{e}$ and report its Euclidean norm $\\|\\mathbf{r}_{e}\\|_{2}$ as a float.\n\n- Test $5$ (positive semidefiniteness benchmark):\n  - $L = 1$, $\\theta = 0.2$, $k_{n} = 1000$, $k_{t} = 500$.\n  - Compute the eigenvalues of $\\mathbf{K}_{e}$ and report the minimum eigenvalue as a float.\n\nFinal output format specification: Your program should produce a single line of output containing the results of the five tests as a comma-separated list enclosed in square brackets (e.g., $[r_{1}, r_{2}, r_{3}, r_{4}, r_{5}]$), where each $r_{i}$ is the requested float for test $i$ in the order above. No other output should be produced. Angles must be in radians. Use nondimensional numbers throughout. All computations must be carried out using the definitions and derivations above starting from the principle of virtual work and linear momentum balance. Your implementation must be entirely self-contained, require no input, and must use the one-point Gauss quadrature with the exact Jacobian as specified.", "solution": "The problem requires the derivation and implementation of a four-node, two-dimensional, zero-thickness interface element. The solution proceeds in two stages: first, a theoretical derivation of the element's residual vector $\\mathbf{r}_e$ and tangent stiffness matrix $\\mathbf{K}_e$ from first principles; second, the implementation of these formulas in a program to perform a series of verification tests.\n\n### Derivation of Element Formulation\n\nThe formulation is based on the principle of virtual work for interfaces:\n$$\n\\delta W_{\\text{int}} = \\int_{\\Gamma} \\delta \\boldsymbol{\\delta}^{\\top} \\mathbf{t}^{\\text{loc}}\\ \\mathrm{d}\\Gamma = \\delta \\mathbf{u}_e^{\\top} \\mathbf{r}_e\n$$\nwhere $\\delta W_{\\text{int}}$ is the internal virtual work, $\\Gamma$ is the interface surface, $\\boldsymbol{\\delta}$ is the local displacement jump vector, $\\mathbf{t}^{\\text{loc}}$ is the local traction vector, $\\delta \\mathbf{u}_e$ is the vector of virtual nodal displacements, and $\\mathbf{r}_e$ is the element residual (internal force) vector.\n\nThe problem specifies a linear constitutive law, $\\mathbf{t}^{\\text{loc}} = \\mathbf{C} \\boldsymbol{\\delta}$, and provides a specific mapping from the element's global nodal displacements $\\boldsymbol{u}_e \\in \\mathbb{R}^8$ to the local displacement jump $\\boldsymbol{\\delta} \\in \\mathbb{R}^2$ at the element's center (isoparametric coordinate $\\xi=0$):\n$$\n\\boldsymbol{\\delta}(0) = \\mathbf{B}\\ \\boldsymbol{u}_{e}\n$$\nwhere $\\mathbf{B}$ is the $2 \\times 8$ strain-displacement matrix:\n$$\n\\mathbf{B} = \\begin{bmatrix} -\\tfrac{1}{2}\\mathbf{R}^{\\top} & -\\tfrac{1}{2}\\mathbf{R}^{\\top} & \\tfrac{1}{2}\\mathbf{R}^{\\top} & \\tfrac{1}{2}\\mathbf{R}^{\\top} \\end{bmatrix}\n$$\nHere, $\\mathbf{R}$ is the $2 \\times 2$ local-to-global coordinate transformation matrix. The variation of the displacement jump is likewise $\\delta\\boldsymbol{\\delta}(0) = \\mathbf{B}\\ \\delta\\boldsymbol{u}_{e}$.\n\nThe integral over the element length $L$ is evaluated using one-point Gauss quadrature. The integration point is at $\\xi=0$, the weight is $w=2$, and the Jacobian of the mapping from the isoparametric domain $[-1, 1]$ to the physical domain $[0, L]$ is $J = L/2$. The differential element of length is $\\mathrm{d}\\Gamma = J \\mathrm{d}\\xi$.\n$$\n\\int_{\\Gamma} (\\cdot)\\ \\mathrm{d}\\Gamma = \\int_{-1}^{1} (\\cdot) J \\mathrm{d}\\xi \\approx (\\cdot)|_{\\xi=0} \\cdot J \\cdot w = (\\cdot)|_{\\xi=0} \\cdot (L/2) \\cdot 2 = (\\cdot)|_{\\xi=0} \\cdot L\n$$\nSubstituting the discretized quantities into the virtual work principle:\n$$\n\\delta W_{\\text{int}} \\approx \\left[ \\delta \\boldsymbol{\\delta}(0)^{\\top} \\mathbf{t}^{\\text{loc}}(0) \\right] L\n$$\n$$\n\\delta \\mathbf{u}_e^{\\top} \\mathbf{r}_e = \\left[ (\\mathbf{B} \\delta \\mathbf{u}_e)^{\\top} (\\mathbf{C} \\mathbf{B} \\mathbf{u}_e) \\right] L\n$$\n$$\n\\delta \\mathbf{u}_e^{\\top} \\mathbf{r}_e = \\left[ \\delta \\mathbf{u}_e^{\\top} \\mathbf{B}^{\\top} \\mathbf{C} \\mathbf{B} \\mathbf{u}_e \\right] L = \\delta \\mathbf{u}_e^{\\top} \\left( L \\mathbf{B}^{\\top} \\mathbf{C} \\mathbf{B} \\mathbf{u}_e \\right)\n$$\nSince this equality must hold for any arbitrary virtual displacement $\\delta \\mathbf{u}_e$, we can identify the residual vector $\\mathbf{r}_e$:\n$$\n\\mathbf{r}_e = L \\mathbf{B}^{\\top} \\mathbf{C} \\mathbf{B} \\mathbf{u}_e\n$$\nThe consistent tangent stiffness matrix $\\mathbf{K}_e$ is defined as the derivative of the residual vector with respect to the nodal displacements $\\boldsymbol{u}_e$:\n$$\n\\mathbf{K}_e = \\frac{\\partial \\mathbf{r}_e}{\\partial \\boldsymbol{u}_e} = \\frac{\\partial}{\\partial \\boldsymbol{u}_e} \\left( L \\mathbf{B}^{\\top} \\mathbf{C} \\mathbf{B} \\mathbf{u}_e \\right)\n$$\nFor this linear problem, the derivative is simply:\n$$\n\\mathbf{K}_e = L \\mathbf{B}^{\\top} \\mathbf{C} \\mathbf{B}\n$$\nNotably, this implies $\\mathbf{r}_e = \\mathbf{K}_e \\mathbf{u}_e$, which is characteristic of a linear system.\n\n### Positive Semidefiniteness of $\\mathbf{K}_e$\nThe stiffness matrix $\\mathbf{K}_e$ must be positive semidefinite, which corresponds to the physical requirement that straining the element requires non-negative energy. To demonstrate this, we examine the quadratic form $\\mathbf{v}^{\\top} \\mathbf{K}_e \\mathbf{v}$ for an arbitrary displacement vector $\\mathbf{v} \\in \\mathbb{R}^8$.\n$$\n\\mathbf{v}^{\\top} \\mathbf{K}_e \\mathbf{v} = \\mathbf{v}^{\\top} (L \\mathbf{B}^{\\top} \\mathbf{C} \\mathbf{B}) \\mathbf{v} = L (\\mathbf{Bv})^{\\top} \\mathbf{C} (\\mathbf{Bv})\n$$\nLet $\\mathbf{w} = \\mathbf{Bv}$. This $2 \\times 1$ vector $\\mathbf{w} = [w_n, w_t]^\\top$ represents the local displacement jump corresponding to the nodal displacements $\\mathbf{v}$. The quadratic form becomes:\n$$\n\\mathbf{v}^{\\top} \\mathbf{K}_e \\mathbf{v} = L \\mathbf{w}^{\\top} \\mathbf{C} \\mathbf{w} = L \\begin{bmatrix} w_n & w_t \\end{bmatrix} \\begin{bmatrix} k_n & 0 \\\\ 0 & k_t \\end{bmatrix} \\begin{bmatrix} w_n \\\\ w_t \\end{bmatrix} = L (k_n w_n^2 + k_t w_t^2)\n$$\nGiven that element length $L > 0$ and the stiffness parameters $k_n, k_t \\ge 0$, the term $L (k_n w_n^2 + k_t w_t^2)$ is always non-negative. Thus, $\\mathbf{v}^{\\top} \\mathbf{K}_e \\mathbf{v} \\ge 0$, proving that $\\mathbf{K}_e$ is positive semidefinite. The matrix is not positive definite because non-zero displacement vectors $\\mathbf{v}$ corresponding to rigid-body motions result in zero jump ($\\mathbf{w}=\\mathbf{0}$) and thus zero strain energy. These vectors form the null space of $\\mathbf{K}_e$, leading to zero eigenvalues.\n\n### Implementation and Verification\nThe derived formulas for $\\mathbf{r}_e$ and $\\mathbf{K}_e$ are implemented in Python. The program constructs the necessary matrices ($\\mathbf{R}, \\mathbf{C}, \\mathbf{B}$) and then computes $\\mathbf{K}_e$ and $\\mathbf{r}_e$. This core computation is then applied to the five test cases specified in the problem statement.\n\n- **Test 1 (Analytical Force Distribution):** A uniform gap is applied. The computed internal force vector $\\mathbf{r}_e$ is compared to an analytically derived force vector based on static equilibrium. The one-point quadrature is exact for this case, so the relative error is expected to be near machine precision.\n- **Test 2 (Stiffness Symmetry Check):** The stiffness matrix $\\mathbf{K}_e = L \\mathbf{B}^\\top \\mathbf{C} \\mathbf{B}$ is symmetric by construction because the constitutive matrix $\\mathbf{C}$ is symmetric. The test numerically confirms this by computing the relative symmetry defect, which should be close to zero.\n- **Test 3 (Frame Invariance):** This test verifies objectivity. The internal force vector is computed for two different element orientations but the same physical deformation. The force vector in the second orientation, $\\mathbf{r}_e(\\theta_1)$, must be equivalent to the rotated force vector from the first orientation, $\\mathbf{Q} \\mathbf{r}_e(\\theta_0)$. The relative difference is computed and is expected to be near zero.\n- **Test 4 (Zero Tangential Stiffness):** A pure sliding deformation is applied with $k_t=0$. In this case, the constitutive law yields zero traction ($\\mathbf{t}^{\\text{loc}}=\\mathbf{0}$), since the normal opening $\\delta_n$ is zero. Consequently, the internal force vector $\\mathbf{r}_e$ must be zero. The test confirms this by computing the norm of $\\mathbf{r}_e$.\n- **Test 5 (Positive Semidefiniteness):** The eigenvalues of $\\mathbf{K}_e$ are computed. As proven earlier, the matrix is positive semidefinite, meaning all eigenvalues must be non-negative. Due to the existence of rigid-body modes, the matrix has a null space. The rank of $\\mathbf{K}_e$ is at most $2$, so for an $8 \\times 8$ matrix, at least $6$ eigenvalues must be zero. The test reports the minimum eigenvalue, which is expected to be zero (within floating-point tolerance).", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_element_properties(L, theta, kn, kt):\n    \"\"\"\n    Computes matrices required for the interface element.\n    :param L: Length of the element\n    :param theta: Orientation angle in radians\n    :param kn: Normal stiffness\n    :param kt: Tangential stiffness\n    :return: R, C, B, Ke matrices\n    \"\"\"\n    c, s = np.cos(theta), np.sin(theta)\n    # Local-to-global rotation matrix\n    R = np.array([[-s, c], [c, s]])\n    \n    # Constitutive matrix\n    C = np.array([[kn, 0], [0, kt]])\n    \n    # B matrix for one-point quadrature, relates global u_e to local delta\n    # B has shape (2, 8)\n    B_block = 0.5 * R.T\n    B = np.hstack([-B_block, -B_block, B_block, B_block])\n    \n    # Stiffness matrix Ke = L * B.T @ C @ B\n    Ke = L * (B.T @ C @ B)\n    \n    return R, C, B, Ke\n\ndef test1():\n    \"\"\"Analytical force distribution under uniform local gap.\"\"\"\n    L, theta, kn, kt = 2.0, 0.0, 1000.0, 500.0\n    delta_local = np.array([0.01, -0.02])\n    \n    R, C, B, Ke = compute_element_properties(L, theta, kn, kt)\n    \n    # Define prescribed nodal displacements\n    u_plus_global = R @ delta_local\n    u_e = np.zeros(8)\n    u_e[4:6] = u_plus_global  # Node 3 (+ side)\n    u_e[6:8] = u_plus_global  # Node 4 (+ side)\n    \n    # Compute residual vector from implementation\n    r_e_computed = Ke @ u_e\n    \n    # Analytical verification\n    t_loc = C @ delta_local\n    # Formula r_e = L * B.T @ t_loc\n    r_e_exact = L * (B.T @ t_loc)\n\n    norm_exact = np.linalg.norm(r_e_exact)\n    if norm_exact == 0:\n        return 0.0 if np.linalg.norm(r_e_computed) == 0 else 1.0\n    \n    relative_error = np.linalg.norm(r_e_computed - r_e_exact) / norm_exact\n    return relative_error\n\ndef test2():\n    \"\"\"Stiffness symmetry check.\"\"\"\n    L, theta, kn, kt = 1.3, 0.37, 800.0, 1200.0\n    \n    R, C, B, Ke = compute_element_properties(L, theta, kn, kt)\n    \n    norm_Ke = np.linalg.norm(Ke, 'fro')\n    if norm_Ke == 0:\n        return 0.0\n        \n    symmetry_defect = np.linalg.norm(Ke - Ke.T, 'fro') / norm_Ke\n    return symmetry_defect\n\ndef test3():\n    \"\"\"Frame invariance under rotation.\"\"\"\n    L, kn, kt = 2.0, 900.0, 300.0\n    theta0, theta1 = 0.0, np.pi/3.0\n    delta_local = np.array([0.02, 0.01])\n\n    # Case 0: theta = theta0\n    R0, C0, B0, Ke0 = compute_element_properties(L, theta0, kn, kt)\n    u_plus0 = R0 @ delta_local\n    u_e0 = np.zeros(8)\n    u_e0[4:6], u_e0[6:8] = u_plus0, u_plus0\n    r_e0 = Ke0 @ u_e0\n\n    # Case 1: theta = theta1\n    R1, C1, B1, Ke1 = compute_element_properties(L, theta1, kn, kt)\n    u_plus1 = R1 @ delta_local\n    u_e1 = np.zeros(8)\n    u_e1[4:6], u_e1[6:8] = u_plus1, u_plus1\n    r_e1 = Ke1 @ u_e1\n\n    # Transformation matrices\n    T = R1 @ R0.T\n    Q = np.kron(np.eye(4), T)\n    \n    r_e0_rotated = Q @ r_e0\n    \n    norm_r1 = np.linalg.norm(r_e1)\n    if norm_r1 == 0:\n        return 0.0 if np.linalg.norm(r_e0_rotated) == 0 else 1.0\n        \n    relative_diff = np.linalg.norm(r_e1 - r_e0_rotated) / norm_r1\n    return relative_diff\n\ndef test4():\n    \"\"\"Edge case with zero tangential stiffness.\"\"\"\n    L, theta, kn, kt = 3.0, 0.5, 700.0, 0.0\n    delta_local = np.array([0.0, 0.05])\n\n    R, C, B, Ke = compute_element_properties(L, theta, kn, kt)\n    \n    u_plus = R @ delta_local\n    u_e = np.zeros(8)\n    u_e[4:6], u_e[6:8] = u_plus, u_plus\n    \n    r_e = Ke @ u_e\n    return np.linalg.norm(r_e)\n\ndef test5():\n    \"\"\"Positive semidefiniteness benchmark.\"\"\"\n    L, theta, kn, kt = 1.0, 0.2, 1000.0, 500.0\n    \n    R, C, B, Ke = compute_element_properties(L, theta, kn, kt)\n    \n    eigenvalues = np.linalg.eigvalsh(Ke)\n    return np.min(eigenvalues)\n\ndef solve():\n    \"\"\"\n    Executes the test suite for the zero-thickness interface element.\n    \"\"\"\n    test_cases = [\n        test1,\n        test2,\n        test3,\n        test4,\n        test5\n    ]\n\n    results = []\n    for test_func in test_cases:\n        result = test_func()\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # High precision is used to show values are close to zero.\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```", "id": "3571998"}, {"introduction": "A zero-thickness interface is a powerful idealization, but its abstract stiffness parameters must be grounded in physical reality to be meaningful. This exercise bridges the gap between the discrete interface model and its continuum counterpart, a thin layer of material, by deriving the exact equivalence conditions for their mechanical response. This practice is essential for understanding how to calibrate interface parameters from material properties to accurately represent real-world joints, faults, or bonded layers in a computationally efficient manner [@problem_id:3572014].", "problem": "A developer must implement a rigorous comparison between a zero-thickness interface model and two continuum idealizations (a finite-thickness elastic layer and a smeared band model) within the setting of small-strain, linear elastic, isotropic materials. The target is to verify, by derivation and computation, the conditions under which the zero-thickness interface model reproduces the traction and the energy response of the finite-thickness layer, and to quantify the deviation introduced by a smeared band model. The comparison must be carried out for mixed-mode (normal and shear) kinematics and tractions. The context is computational geomechanics, and the focus is on the constitutive equivalence and discrepancy of zero-thickness interface elements when measured against continuum representations.\n\nStarting point for the derivation must be: the balance of power and the principle of virtual work for interfaces and continua, the small-strain kinematic relations, and Hooke’s law for isotropic linear elasticity. The interface kinematics are defined by the displacement jump vector $\\boldsymbol{\\delta} = [\\delta_n,\\delta_s]^T$, whose work-conjugate traction vector is $\\boldsymbol{t} = [t_n,t_s]^T$. The finite-thickness layer is a continuum of thickness $h$ and unit interfacial area, with normal strain $\\varepsilon_n$ and shear strain $\\gamma_s$ defined by through-thickness gradients of displacement. The smeared band model represents a damage or localization band of thickness $h_{\\mathrm{sm}}$ with elastic moduli $E_{\\mathrm{sm}}$ and $G_{\\mathrm{sm}}$ (with $G_{\\mathrm{sm}}$ obtained from Young’s modulus and Poisson’s ratio via isotropic elasticity), uniformly distributing the displacement jump $\\boldsymbol{\\delta}$ over $h_{\\mathrm{sm}}$.\n\nYour tasks are:\n- Derive, from first principles, the exact conditions under which the traction and energy per unit area of a zero-thickness interface with a symmetric, mode-diagonal stiffness matrix $\\boldsymbol{K}=\\mathrm{diag}(K_n,K_s)$ are identical to those of a finite-thickness elastic layer. Then, formalize the smeared band expressions for traction and energy per unit area, and explain how they differ when $h_{\\mathrm{sm}}\\neq h$ or when the smeared moduli deviate from the values implied by equivalence.\n- Implement a program that, for a given test suite of material and geometric parameters, computes:\n    1. The shear modulus $G$ from Young’s modulus $E$ and Poisson’s ratio $\\nu$ using isotropic linear elasticity.\n    2. The zero-thickness interface tractions $\\boldsymbol{t}^{\\mathrm{zt}}$ and energy per unit area $w^{\\mathrm{zt}}$ from $\\boldsymbol{\\delta}$ and $\\boldsymbol{K}$.\n    3. The finite-thickness layer tractions $\\boldsymbol{t}^{\\mathrm{ft}}$ and energy per unit area $w^{\\mathrm{ft}}$ from $E$, $G$, $h$, and $\\boldsymbol{\\delta}$.\n    4. The smeared band tractions $\\boldsymbol{t}^{\\mathrm{sm}}$ and energy per unit area $w^{\\mathrm{sm}}$ from $E_{\\mathrm{sm}}$, $G_{\\mathrm{sm}}$, $h_{\\mathrm{sm}}$, and $\\boldsymbol{\\delta}$.\n    5. The relative error in traction magnitude and the relative error in energy per unit area between the smeared band model and the zero-thickness interface model, defined as\n       $$e_t=\\frac{\\left\\|\\boldsymbol{t}^{\\mathrm{sm}}\\right\\|_2-\\left\\|\\boldsymbol{t}^{\\mathrm{zt}}\\right\\|_2}{\\max\\left(\\left\\|\\boldsymbol{t}^{\\mathrm{zt}}\\right\\|_2,\\varepsilon\\right)},\\quad e_w=\\frac{w^{\\mathrm{sm}}-w^{\\mathrm{zt}}}{\\max\\left(w^{\\mathrm{zt}},\\varepsilon\\right)},$$\n       where $\\varepsilon$ is a small positive number used only to avoid division by zero, and $\\|\\cdot\\|_2$ denotes the Euclidean norm.\n\nUnits and numerical specifications:\n- Young’s modulus $E$ must be given in pascals ($\\mathrm{Pa}$).\n- Poisson’s ratio $\\nu$ is dimensionless.\n- Thicknesses $h$ and $h_{\\mathrm{sm}}$ must be given in meters ($\\mathrm{m}$).\n- Displacement jumps $\\delta_n$ and $\\delta_s$ must be given in meters ($\\mathrm{m}$).\n- Tractions are in pascals ($\\mathrm{Pa}$), and energy per unit area is in joules per square meter ($\\mathrm{J}/\\mathrm{m}^2$).\n- Angles are not involved in this problem.\n\nTest suite:\n- Case $1$: $E=30\\times 10^9\\,\\mathrm{Pa}$, $\\nu=0.25$, $h=1.0\\times 10^{-2}\\,\\mathrm{m}$, $\\delta_n=1.0\\times 10^{-4}\\,\\mathrm{m}$, $\\delta_s=2.0\\times 10^{-4}\\,\\mathrm{m}$, $h_{\\mathrm{sm}}=2.0\\times 10^{-2}\\,\\mathrm{m}$, $E_{\\mathrm{sm}}=E$, $\\nu_{\\mathrm{sm}}=\\nu$.\n- Case $2$: $E=35\\times 10^9\\,\\mathrm{Pa}$, $\\nu=0.30$, $h=5.0\\times 10^{-3}\\,\\mathrm{m}$, $\\delta_n=0.0\\,\\mathrm{m}$, $\\delta_s=3.0\\times 10^{-4}\\,\\mathrm{m}$, $h_{\\mathrm{sm}}=1.0\\times 10^{-2}\\,\\mathrm{m}$, $E_{\\mathrm{sm}}=E\\cdot h_{\\mathrm{sm}}/h$, $\\nu_{\\mathrm{sm}}=\\nu$.\n- Case $3$: $E=20\\times 10^9\\,\\mathrm{Pa}$, $\\nu=0.20$, $h=1.0\\times 10^{-6}\\,\\mathrm{m}$, $\\delta_n=1.0\\times 10^{-5}\\,\\mathrm{m}$, $\\delta_s=0.0\\,\\mathrm{m}$, $h_{\\mathrm{sm}}=1.0\\times 10^{-3}\\,\\mathrm{m}$, $E_{\\mathrm{sm}}=E$, $\\nu_{\\mathrm{sm}}=\\nu$.\n- Case $4$: $E=50\\times 10^9\\,\\mathrm{Pa}$, $\\nu=0.33$, $h=2.5\\times 10^{-2}\\,\\mathrm{m}$, $\\delta_n=-2.0\\times 10^{-4}\\,\\mathrm{m}$, $\\delta_s=1.0\\times 10^{-4}\\,\\mathrm{m}$, $h_{\\mathrm{sm}}=2.5\\times 10^{-2}\\,\\mathrm{m}$, $E_{\\mathrm{sm}}=0.5\\,E$, $\\nu_{\\mathrm{sm}}=\\nu$.\n\nFinal output specification:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered as $[e_t^{(1)},e_w^{(1)},e_t^{(2)},e_w^{(2)},e_t^{(3)},e_w^{(3)},e_t^{(4)},e_w^{(4)}]$, where superscripts denote the test case index. Each $e_t^{(i)}$ and $e_w^{(i)}$ must be a floating-point number.", "solution": "The problem requires a derivation of the equivalence conditions between a zero-thickness interface model and a finite-thickness elastic layer model, and a subsequent comparison with a smeared band model. This will be followed by a computational implementation to quantify the discrepancies for a given set of parameters.\n\nThe analysis is grounded in the principles of continuum mechanics for small-strain, linear elastic, isotropic materials. We consider a local coordinate system with the $n$-axis normal to the interface/layer and the $s$-axis tangential to it in the direction of shear.\n\n**1. Finite-Thickness Layer Model (ft)**\n\nWe consider a thin, continuous layer of material with thickness $h$, Young's modulus $E$, and Poisson's ratio $\\nu$. The layer has a unit area. A relative displacement, or jump, $\\boldsymbol{\\delta} = [\\delta_n, \\delta_s]^T$ is imposed across its thickness. Assuming this jump is distributed uniformly through the thickness, we can define the average engineering strains within the layer as:\n$$ \\varepsilon_n = \\frac{\\delta_n}{h} \\quad \\text{and} \\quad \\gamma_s = \\frac{\\delta_s}{h} $$\nTo relate these strains to tractions, we must assume a stress state. For a thin layer embedded within a larger continuum, it is standard practice in geomechanics to assume a state of uniaxial strain, where the layer is constrained from deforming parallel to its plane. That is, the strains in the directions parallel to the interface are zero.\n\nFor an isotropic linear elastic material, the shear stress $\\tau_s$ is related to the shear strain $\\gamma_s$ via the shear modulus $G$:\n$$ t_s^{\\mathrm{ft}} = \\tau_s = G \\gamma_s = G \\frac{\\delta_s}{h} $$\nwhere the shear modulus $G$ is given by\n$$ G = \\frac{E}{2(1+\\nu)} $$\nThe normal stress $\\sigma_n$ under uniaxial strain conditions (i.e., $\\varepsilon_s = \\varepsilon_t = 0$ in a 3D context) is related to the normal strain $\\varepsilon_n$ via the P-wave modulus (or constrained modulus) $M$:\n$$ t_n^{\\mathrm{ft}} = \\sigma_n = M \\varepsilon_n = M \\frac{\\delta_n}{h} $$\nwhere the P-wave modulus $M$ is given by:\n$$ M = \\frac{E(1-\\nu)}{(1+\\nu)(1-2\\nu)} $$\nCombining these, the traction vector for the finite-thickness layer is:\n$$ \\boldsymbol{t}^{\\mathrm{ft}} = \\begin{bmatrix} t_n^{\\mathrm{ft}} \\\\ t_s^{\\mathrm{ft}} \\end{bmatrix} = \\begin{bmatrix} (M/h) \\delta_n \\\\ (G/h) \\delta_s \\end{bmatrix} $$\nThe elastic strain energy stored per unit area, $w^{\\mathrm{ft}}$, is the work done by the tractions. For a linear system, this is given by $w = \\frac{1}{2} \\boldsymbol{t}^T \\boldsymbol{\\delta}$. The energy can also be found by integrating the strain energy density $U = \\frac{1}{2}(\\sigma_n \\varepsilon_n + \\tau_s \\gamma_s)$ over the thickness $h$:\n$$ w^{\\mathrm{ft}} = \\int_0^h U \\,dz = \\frac{1}{2} (\\sigma_n \\varepsilon_n + \\tau_s \\gamma_s) h = \\frac{1}{2} \\left( \\left(M \\frac{\\delta_n}{h}\\right) \\frac{\\delta_n}{h} + \\left(G \\frac{\\delta_s}{h}\\right) \\frac{\\delta_s}{h} \\right) h $$\n$$ w^{\\mathrm{ft}} = \\frac{1}{2} \\left( \\frac{M}{h} \\delta_n^2 + \\frac{G}{h} \\delta_s^2 \\right) $$\n\n**2. Zero-Thickness Interface Model (zt)**\n\nThis model relates the traction vector $\\boldsymbol{t}^{\\mathrm{zt}}$ directly to the displacement jump vector $\\boldsymbol{\\delta}$ through a constitutive stiffness matrix $\\boldsymbol{K}$.\n$$ \\boldsymbol{t}^{\\mathrm{zt}} = \\boldsymbol{K} \\boldsymbol{\\delta} $$\nGiven that the stiffness matrix is symmetric and diagonal, $\\boldsymbol{K} = \\mathrm{diag}(K_n, K_s)$, the tractions are:\n$$ t_n^{\\mathrm{zt}} = K_n \\delta_n \\quad \\text{and} \\quad t_s^{\\mathrm{zt}} = K_s \\delta_s $$\nThe elastic energy stored per unit area, $w^{\\mathrm{zt}}$, is:\n$$ w^{\\mathrm{zt}} = \\frac{1}{2} \\boldsymbol{t}^{\\mathrm{zt} T} \\boldsymbol{\\delta} = \\frac{1}{2} (\\boldsymbol{K} \\boldsymbol{\\delta})^T \\boldsymbol{\\delta} = \\frac{1}{2} (K_n \\delta_n^2 + K_s \\delta_s^2) $$\n\n**3. Equivalence Conditions (zt vs. ft)**\n\nFor the zero-thickness interface model to be equivalent to the finite-thickness layer model, their responses must be identical for any given displacement jump $\\boldsymbol{\\delta}$. This requires equating their respective tractions and stored energies.\n\nEquating the traction vectors, $\\boldsymbol{t}^{\\mathrm{zt}} = \\boldsymbol{t}^{\\mathrm{ft}}$:\n$$ K_n \\delta_n = \\frac{M}{h} \\delta_n \\implies K_n = \\frac{M}{h} = \\frac{E(1-\\nu)}{h(1+\\nu)(1-2\\nu)} $$\n$$ K_s \\delta_s = \\frac{G}{h} \\delta_s \\implies K_s = \\frac{G}{h} = \\frac{E}{2h(1+\\nu)} $$\nThese are the exact conditions for the interface stiffnesses $K_n$ and $K_s$ to reproduce the mechanical behavior of a finite-thickness elastic layer of thickness $h$, modulus $E$, and Poisson's ratio $\\nu$, under the assumption of uniaxial strain. Substituting these stiffness values into the energy expression for $w^{\\mathrm{zt}}$ demonstrates that the energy $w^{\\mathrm{ft}}$ is also matched. For the remainder of this analysis, the zero-thickness model will use these stiffness values, establishing it as the benchmark.\n\n**4. Smeared Band Model (sm)**\n\nThe smeared band model is mathematically identical in form to the finite-thickness layer model, but it is applied over a conceptual \"smeared\" thickness $h_{\\mathrm{sm}}$ with potentially different material properties $E_{\\mathrm{sm}}$ and $\\nu_{\\mathrm{sm}}$. The purpose is often to regularize localization phenomena in numerical simulations.\n\nThe strains are defined over the smeared thickness:\n$$ \\varepsilon_n^{\\mathrm{sm}} = \\frac{\\delta_n}{h_{\\mathrm{sm}}} \\quad \\text{and} \\quad \\gamma_s^{\\mathrm{sm}} = \\frac{\\delta_s}{h_{\\mathrm{sm}}} $$\nThe tractions are derived similarly, using the smeared material properties $G_{\\mathrm{sm}}$ and $M_{\\mathrm{sm}}$:\n$$ G_{\\mathrm{sm}} = \\frac{E_{\\mathrm{sm}}}{2(1+\\nu_{\\mathrm{sm}})} \\quad \\text{and} \\quad M_{\\mathrm{sm}} = \\frac{E_{\\mathrm{sm}}(1-\\nu_{\\mathrm{sm}})}{(1+\\nu_{\\mathrm{sm}})(1-2\\nu_{\\mathrm{sm}})} $$\n$$ t_n^{\\mathrm{sm}} = \\frac{M_{\\mathrm{sm}}}{h_{\\mathrm{sm}}} \\delta_n \\quad \\text{and} \\quad t_s^{\\mathrm{sm}} = \\frac{G_{\\mathrm{sm}}}{h_{\\mathrm{sm}}} \\delta_s $$\nThe traction vector is $\\boldsymbol{t}^{\\mathrm{sm}} = [t_n^{\\mathrm{sm}}, t_s^{\\mathrm{sm}}]^T$.\nThe energy per unit area is:\n$$ w^{\\mathrm{sm}} = \\frac{1}{2} \\left( \\frac{M_{\\mathrm{sm}}}{h_{\\mathrm{sm}}} \\delta_n^2 + \\frac{G_{\\mathrm{sm}}}{h_{\\mathrm{sm}}} \\delta_s^2 \\right) $$\n\n**5. Discrepancy Analysis (sm vs. zt)**\n\nThe smeared model's response deviates from the benchmark zero-thickness (or finite-thickness) model whenever its effective stiffnesses differ. The effective stiffnesses for the smeared model are $K_n^{\\mathrm{sm}} = M_{\\mathrm{sm}}/h_{\\mathrm{sm}}$ and $K_s^{\\mathrm{sm}} = G_{\\mathrm{sm}}/h_{\\mathrm{sm}}$.\n\nDiscrepancy arises if $K_n^{\\mathrm{sm}} \\neq K_n$ or $K_s^{\\mathrm{sm}} \\neq K_s$. This occurs if the parameters $(h_{\\mathrm{sm}}, E_{\\mathrm{sm}}, \\nu_{\\mathrm{sm}})$ are not chosen to match the reference stiffnesses $(K_n, K_s) = (M/h, G/h)$. For instance, if $E_{\\mathrm{sm}} = E$ and $\\nu_{\\mathrm{sm}} = \\nu$, but $h_{\\mathrm{sm}} \\neq h$, the effective stiffnesses will be scaled by a factor of $h/h_{\\mathrm{sm}}$. This will lead to an incorrect prediction of tractions and energy.\n\nA special case arises when the smeared parameters are chosen to preserve the stiffness of the original physical layer. This is known as stiffness-equivalent smearing. If we set $\\nu_{\\mathrm{sm}}=\\nu$ and scale the Young's modulus as $E_{\\mathrm{sm}} = E (h_{\\mathrm{sm}}/h)$, we find:\n$$ K_s^{\\mathrm{sm}} = \\frac{G_{\\mathrm{sm}}}{h_{\\mathrm{sm}}} = \\frac{E_{\\mathrm{sm}}}{2(1+\\nu_{\\mathrm{sm}})h_{\\mathrm{sm}}} = \\frac{E(h_{\\mathrm{sm}}/h)}{2(1+\\nu)h_{\\mathrm{sm}}} = \\frac{G}{h} = K_s $$\n$$ K_n^{\\mathrm{sm}} = \\frac{M_{\\mathrm{sm}}}{h_{\\mathrm{sm}}} = \\frac{E_{\\mathrm{sm}}(1-\\nu_{\\mathrm{sm}})}{h_{\\mathrm{sm}}(1+\\nu_{\\mathrm{sm}})(1-2\\nu_{\\mathrm{sm}})} = \\frac{E(h_{\\mathrm{sm}}/h)(1-\\nu)}{h_{\\mathrm{sm}}(1+\\nu)(1-2\\nu)} = \\frac{M}{h} = K_n $$\nIn this specific case, the smeared band model exactly reproduces the response of the reference models, and the errors $e_t$ and $e_w$ will be zero. Any other choice for the smeared parameters will introduce a quantifiable modeling error.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the relative errors in traction and energy for a smeared band model\n    compared to a benchmark zero-thickness interface model.\n    \"\"\"\n    # Small number to prevent division by zero in error calculations\n    epsilon = 1e-12\n\n    # Test suite with material and geometric parameters for 4 cases.\n    test_cases = [\n        {\n            \"E\": 30e9, \"nu\": 0.25, \"h\": 1.0e-2, \n            \"delta_n\": 1.0e-4, \"delta_s\": 2.0e-4,\n            \"h_sm\": 2.0e-2, \"E_sm_def\": \"E\", \"nu_sm\": 0.25\n        },\n        {\n            \"E\": 35e9, \"nu\": 0.30, \"h\": 5.0e-3, \n            \"delta_n\": 0.0, \"delta_s\": 3.0e-4,\n            \"h_sm\": 1.0e-2, \"E_sm_def\": \"E*h_sm/h\", \"nu_sm\": 0.30\n        },\n        {\n            \"E\": 20e9, \"nu\": 0.20, \"h\": 1.0e-6, \n            \"delta_n\": 1.0e-5, \"delta_s\": 0.0,\n            \"h_sm\": 1.0e-3, \"E_sm_def\": \"E\", \"nu_sm\": 0.20\n        },\n        {\n            \"E\": 50e9, \"nu\": 0.33, \"h\": 2.5e-2, \n            \"delta_n\": -2.0e-4, \"delta_s\": 1.0e-4,\n            \"h_sm\": 2.5e-2, \"E_sm_def\": \"0.5*E\", \"nu_sm\": 0.33\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        # Extract parameters for the current case\n        E, nu, h = case[\"E\"], case[\"nu\"], case[\"h\"]\n        delta_n, delta_s = case[\"delta_n\"], case[\"delta_s\"]\n        h_sm, nu_sm = case[\"h_sm\"], case[\"nu_sm\"]\n\n        # 1. Calculations for the reference zero-thickness model (zt)\n        # This model is equivalent to the finite-thickness layer model.\n        \n        # Calculate material properties for the reference layer\n        G = E / (2 * (1 + nu))\n        # Handle potential singularity for nu=0.5, though not in test cases\n        if abs(1 - 2 * nu)  epsilon:\n            # For incompressible material, M is infinite.\n            # In a real scenario, this would need special handling.\n            # For this problem, test cases avoid this.\n            M = float('inf')\n        else:\n            M = E * (1 - nu) / ((1 + nu) * (1 - 2 * nu))\n            \n        # Calculate reference interface stiffnesses\n        K_n = M / h\n        K_s = G / h\n\n        # Calculate tractions for the zero-thickness model\n        t_n_zt = K_n * delta_n\n        t_s_zt = K_s * delta_s\n        t_zt = np.array([t_n_zt, t_s_zt])\n\n        # Calculate energy per unit area for the zero-thickness model\n        w_zt = 0.5 * (K_n * delta_n**2 + K_s * delta_s**2)\n\n        # 2. Calculations for the smeared band model (sm)\n\n        # Determine E_sm based on its definition for the case\n        if case[\"E_sm_def\"] == \"E\":\n            E_sm = E\n        elif case[\"E_sm_def\"] == \"E*h_sm/h\":\n            E_sm = E * h_sm / h\n        elif case[\"E_sm_def\"] == \"0.5*E\":\n            E_sm = 0.5 * E\n        else:\n            raise ValueError(f\"Unknown E_sm definition: {case['E_sm_def']}\")\n\n        # Calculate material properties for the smeared band\n        G_sm = E_sm / (2 * (1 + nu_sm))\n        if abs(1 - 2 * nu_sm)  epsilon:\n             M_sm = float('inf')\n        else:\n             M_sm = E_sm * (1 - nu_sm) / ((1 + nu_sm) * (1 - 2 * nu_sm))\n\n        # Calculate tractions for the smeared band model\n        t_n_sm = (M_sm / h_sm) * delta_n\n        t_s_sm = (G_sm / h_sm) * delta_s\n        t_sm = np.array([t_n_sm, t_s_sm])\n\n        # Calculate energy per unit area for the smeared band model\n        w_sm = 0.5 * ((M_sm / h_sm) * delta_n**2 + (G_sm / h_sm) * delta_s**2)\n\n        # 3. Calculate relative errors\n        \n        # Traction error\n        norm_t_zt = np.linalg.norm(t_zt)\n        norm_t_sm = np.linalg.norm(t_sm)\n        e_t = (norm_t_sm - norm_t_zt) / max(norm_t_zt, epsilon)\n        \n        # Energy error\n        e_w = (w_sm - w_zt) / max(w_zt, epsilon)\n\n        results.extend([e_t, e_w])\n\n    # Format the final output string as specified\n    print(f\"[{','.join(f'{r:.12f}' for r in results)}]\")\n\nsolve()\n```", "id": "3572014"}, {"introduction": "Modeling fracture and decohesion requires capturing non-linear material softening, a process central to modern computational mechanics. This advanced practice challenges you to implement a coupled, mixed-mode cohesive damage model, a cornerstone of fracture simulation. You will derive and use the consistent algorithmic tangent required for a robust Newton-Raphson solver, tackling the complexities of history-dependent damage evolution and the potential for numerical instabilities like snap-back that arise in softening systems [@problem_id:3571995].", "problem": "Consider a single integration point of a zero-thickness interface element governed by a coupled mixed-mode cohesive damage model. The goal is to derive a consistent algorithmic tangent operator for the constitutive update and to assess Newton–Raphson convergence under cyclic shear that traverses softening with potential snap-back. Assume small deformations and rate-independent damage regularized by a smooth evolution law.\n\nThe interface free energy density per unit area is defined as\n$$\n\\psi(\\boldsymbol{\\delta}, d) = \\tfrac{1}{2}\\,(1-d)\\,\\boldsymbol{\\delta}^{\\mathsf{T}}\\,\\mathbf{K}\\,\\boldsymbol{\\delta},\n$$\nwhere $\\boldsymbol{\\delta} = \\begin{bmatrix}\\delta_n  \\delta_t\\end{bmatrix}^{\\mathsf{T}}$ collects the displacement jumps in the normal and tangential directions (with $\\delta_n$ positive in opening), $d \\in [0,1)$ is a scalar damage variable, and $\\mathbf{K} \\in \\mathbb{R}^{2\\times 2}$ is a symmetric positive-definite elastic stiffness matrix with coupling,\n$$\n\\mathbf{K} = \\begin{bmatrix} K_n  K_{nt} \\\\ K_{nt}  K_t \\end{bmatrix},\\quad K_{nt} = \\alpha\\,\\sqrt{K_n\\,K_t},\\quad |\\alpha|  1.\n$$\nTractions follow from energy conjugacy:\n$$\n\\mathbf{t}(\\boldsymbol{\\delta}, d) = \\frac{\\partial \\psi}{\\partial \\boldsymbol{\\delta}} = (1-d)\\,\\mathbf{K}\\,\\boldsymbol{\\delta},\\quad \\mathbf{t} = \\begin{bmatrix} t_n \\\\ t_t \\end{bmatrix}.\n$$\n\nMixed-mode damage is driven by the equivalent separation\n$$\nq(\\boldsymbol{\\delta}) = \\sqrt{\\boldsymbol{\\delta}^{\\mathsf{T}}\\,\\mathbf{M}\\,\\boldsymbol{\\delta}},\\quad \\mathbf{M} = \\begin{bmatrix} \\delta_{n,c}^{-2}  \\rho\\,(\\delta_{n,c}\\,\\delta_{t,c})^{-1} \\\\ \\rho\\,(\\delta_{n,c}\\,\\delta_{t,c})^{-1}  \\gamma\\,\\delta_{t,c}^{-2} \\end{bmatrix},\n$$\nwith $\\gamma \\ge 0$ and $|\\rho|  1$ chosen such that $\\mathbf{M}$ is positive definite. The history variable $\\kappa$ enforces irreversibility by\n$$\n\\kappa = \\max\\{\\kappa_{\\text{prev}},\\,q(\\boldsymbol{\\delta})\\},\n$$\nsubject to the standard Kuhn–Tucker conditions for rate-independent damage. The smooth damage evolution law is\n$$\nd(\\kappa) = \\begin{cases}\n0,  \\kappa \\le \\kappa_0,\\\\\n1 - \\dfrac{\\kappa_0}{\\kappa}\\,\\exp\\!\\Big(-\\dfrac{\\kappa - \\kappa_0}{S}\\Big),  \\kappa  \\kappa_0,\n\\end{cases}\n$$\nwith threshold $\\kappa_0  0$ and softening scale $S  0$ (both dimensionless because $\\kappa$ is dimensionless). This law is strictly increasing in $\\kappa$ and $d \\to 1$ as $\\kappa \\to \\infty$. For physical realism, all separations $\\delta_n$ and $\\delta_t$ are expressed in meters, and all tractions $t_n$ and $t_t$ are expressed in Pascals.\n\nTask A (derivation): Starting from the free energy definition, derive the consistent algorithmic tangent matrix\n$$\n\\mathbf{C} := \\frac{\\partial \\mathbf{t}}{\\partial \\boldsymbol{\\delta}} \\in \\mathbb{R}^{2\\times 2}\n$$\nthat is exact for the local constitutive Newton–Raphson update at fixed $\\kappa_{\\text{prev}}$. Your derivation must use only the chain rule, the definition of $q(\\boldsymbol{\\delta})$, the history update $\\kappa = \\max\\{\\kappa_{\\text{prev}}, q\\}$, and the given $d(\\kappa)$.\n\nTask B (algorithm design): Consider a scalar equilibrium at the material point under force control in shear with fixed normal opening $\\delta_n$:\n$$\nR(\\delta_t) = t_t(\\delta_n, \\delta_t) - T_{\\text{ext}} = 0,\n$$\nwhere $T_{\\text{ext}}$ is the externally prescribed shear traction in Pascals. Formulate a Newton–Raphson iteration with the residual $R(\\delta_t)$ and the Jacobian\n$$\nJ(\\delta_t) = \\frac{\\mathrm{d} R}{\\mathrm{d} \\delta_t} = \\mathbf{e}_t^{\\mathsf{T}}\\,\\mathbf{C}(\\boldsymbol{\\delta})\\,\\mathbf{e}_t,\\quad \\mathbf{e}_t = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix},\n$$\nwhile consistently updating the history variable $\\kappa$ within each residual evaluation. State a stopping criterion based on the absolute residual in Pascals.\n\nTask C (implementation and tests): Implement a program that, for each test case listed below, marches over a sequence of load increments and performs the scalar Newton–Raphson solve for $\\delta_t$ at each increment using the consistent algorithmic tangent from Task A. Count how many increments converge within a maximum number of iterations. For a non-converged increment, keep the previous converged state as the starting guess for the next increment without updating $\\kappa$. The program must output a single line that aggregates the convergence counts for all test cases as a comma-separated list enclosed in square brackets.\n\nUse the following fixed material parameters and units:\n- $K_n = 5.0 \\times 10^{12}\\,\\text{Pa/m}$, $K_t = 2.0 \\times 10^{12}\\,\\text{Pa/m}$, $\\alpha$ as specified per test, so $K_{nt} = \\alpha\\,\\sqrt{K_n K_t}$.\n- Characteristic lengths: $\\delta_{n,c} = 5.0 \\times 10^{-6}\\,\\text{m}$, $\\delta_{t,c} = 5.0 \\times 10^{-6}\\,\\text{m}$, $\\gamma$ and $\\rho$ as specified per test.\n- Damage parameters: $\\kappa_0 = 1.0$ (dimensionless), $S = 0.25$ (dimensionless).\n- The initial history variable is $\\kappa_{\\text{prev}} = 0$.\n\nDefine the peak shear traction under pure shear onset as\n$$\nT_{\\text{peak}} = \\frac{K_t\\,\\kappa_0\\,\\delta_{t,c}}{\\sqrt{\\gamma}} \\quad \\text{(Pascals)}.\n$$\n\nConstruct the following test suite, where $N$ is the number of load steps, the external traction is ramped linearly per phase, and the solver tolerance and iteration cap are fixed across tests:\n- Test $1$ (happy path monotonic below peak, pure shear): $\\delta_n = 0$, $\\alpha = 0.2$, $\\gamma = 1.0$, $\\rho = 0.0$, $T_{\\max} = 0.8\\,T_{\\text{peak}}$, monotonic ramp from $0$ to $T_{\\max}$ in $N = 50$ steps.\n- Test $2$ (monotonic beyond peak, pure shear): $\\delta_n = 0$, $\\alpha = 0.2$, $\\gamma = 1.0$, $\\rho = 0.0$, $T_{\\max} = 1.2\\,T_{\\text{peak}}$, monotonic ramp from $0$ to $T_{\\max}$ in $N = 50$ steps.\n- Test $3$ (cyclic beyond peak, pure shear): $\\delta_n = 0$, $\\alpha = 0.2$, $\\gamma = 1.0$, $\\rho = 0.0$, $T_{\\max} = 1.1\\,T_{\\text{peak}}$, ramp from $0$ to $T_{\\max}$ in $N/2$ steps, then to $-T_{\\max}$ in $N$ steps, and back to $0$ in $N/2$ steps with $N = 60$ total steps for the full cycle.\n- Test $4$ (mixed-mode coupling with opening): $\\delta_n = 2.0 \\times 10^{-6}\\,\\text{m}$ (constant), $\\alpha = 0.6$, $\\gamma = 1.0$, $\\rho = 0.3$ (ensuring a positive-definite $\\mathbf{M}$), $T_{\\max} = 0.9\\,T_{\\text{peak}}$, monotonic ramp from $0$ to $T_{\\max}$ in $N = 50$ steps.\n\nNumerical settings for all tests:\n- Newton tolerance: declare convergence when $|R(\\delta_t)| \\le 1.0 \\times 10^{3}\\,\\text{Pa}$.\n- Maximum iterations per increment: $30$.\n- Initial guess for the first increment: $\\delta_t^{(0)} = 0$.\n- Initial history: $\\kappa = 0$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4\\right]$), where each $\\text{result}_i$ is an integer equal to the number of converged increments for the corresponding test case in the order listed above.", "solution": "The problem is assessed to be valid. It is scientifically grounded in the principles of continuum damage mechanics and computational methods, specifically concerning cohesive zone models. The problem is well-posed, with all necessary parameters and conditions provided. While a minor ambiguity exists in the description of the cyclic load path for Test 3, it can be resolved through a reasonable and self-consistent interpretation, as detailed below. The problem is a non-trivial exercise in deriving and implementing a constitutive model with a consistent tangent operator, and analyzing its numerical behavior under challenging loading conditions, including softening and potential instabilities.\n\nThe solution is structured into three parts, corresponding to the tasks in the problem statement.\n\n### Task A: Derivation of the Consistent Algorithmic Tangent\n\nThe goal is to derive the consistent algorithmic tangent matrix $\\mathbf{C} := \\dfrac{\\partial \\mathbf{t}}{\\partial \\boldsymbol{\\delta}}$. The traction vector is given by $\\mathbf{t} = (1-d)\\,\\mathbf{K}\\,\\boldsymbol{\\delta}$.\nApplying the product rule for differentiation with respect to the displacement jump vector $\\boldsymbol{\\delta}$ yields:\n$$\n\\mathbf{C} = \\frac{\\partial \\mathbf{t}}{\\partial \\boldsymbol{\\delta}} = (1-d)\\,\\mathbf{K} - \\frac{\\partial d}{\\partial \\boldsymbol{\\delta}} \\otimes (\\mathbf{K}\\,\\boldsymbol{\\delta})\n$$\nwhere $\\otimes$ denotes the outer product, such that for two vectors $\\mathbf{a}$ and $\\mathbf{b}$, $(\\mathbf{a} \\otimes \\mathbf{b})_{ij} = a_i b_j$. Thus, the expression can be written in matrix form as $\\mathbf{C} = (1-d)\\,\\mathbf{K} - (\\mathbf{K}\\,\\boldsymbol{\\delta})\\left(\\dfrac{\\partial d}{\\partial \\boldsymbol{\\delta}}\\right)^{\\mathsf{T}}$.\n\nThe next step is to find the derivative of the damage variable, $\\dfrac{\\partial d}{\\partial \\boldsymbol{\\delta}}$. The damage $d$ is a function of the history variable $\\kappa$, which in turn depends on $\\boldsymbol{\\delta}$. Using the chain rule:\n$$\n\\frac{\\partial d}{\\partial \\boldsymbol{\\delta}} = \\frac{\\mathrm{d}d}{\\mathrm{d}\\kappa} \\frac{\\partial \\kappa}{\\partial \\boldsymbol{\\delta}}\n$$\n\nThe update rule for the history variable $\\kappa$ is governed by the Karush-Kuhn-Tucker (KKT) conditions for rate-independent plasticity/damage, which partition the response into two regimes:\n\n**1. Elastic Loading/Unloading:**\nThis case occurs when the current equivalent separation $q(\\boldsymbol{\\delta})$ does not exceed the previously stored maximum, i.e., $q(\\boldsymbol{\\delta}) \\le \\kappa_{\\text{prev}}$. In this regime, $\\kappa = \\kappa_{\\text{prev}}$, which is a constant with respect to the current trial displacement $\\boldsymbol{\\delta}$.\nTherefore, $\\dfrac{\\partial \\kappa}{\\partial \\boldsymbol{\\delta}} = \\mathbf{0}$, which implies $\\dfrac{\\partial d}{\\partial \\boldsymbol{\\delta}} = \\mathbf{0}$. The tangent matrix simplifies to the damaged elastic stiffness:\n$$\n\\mathbf{C}_{\\text{elastic}} = (1-d)\\,\\mathbf{K} \\quad \\text{where } d = d(\\kappa_{\\text{prev}})\n$$\nThis is a symmetric matrix.\n\n**2. Damage Loading:**\nThis case occurs when $q(\\boldsymbol{\\delta})  \\kappa_{\\text{prev}}$. The history variable is actively updated, $\\kappa = q(\\boldsymbol{\\delta})$. We must compute both terms in the chain rule expression.\n\nFirst, $\\dfrac{\\partial \\kappa}{\\partial \\boldsymbol{\\delta}} = \\dfrac{\\partial q}{\\partial \\boldsymbol{\\delta}}$. Given $q(\\boldsymbol{\\delta}) = \\sqrt{\\boldsymbol{\\delta}^{\\mathsf{T}}\\,\\mathbf{M}\\,\\boldsymbol{\\delta}}$, we can differentiate $q^2 = \\boldsymbol{\\delta}^{\\mathsf{T}}\\,\\mathbf{M}\\,\\boldsymbol{\\delta}$.\n$$\n2q\\,\\frac{\\partial q}{\\partial \\boldsymbol{\\delta}} = 2\\,\\mathbf{M}\\,\\boldsymbol{\\delta} \\implies \\frac{\\partial q}{\\partial \\boldsymbol{\\delta}} = \\frac{1}{q}\\,\\mathbf{M}\\,\\boldsymbol{\\delta}\n$$\nSince $\\kappa = q$ during loading, we have $\\dfrac{\\partial \\kappa}{\\partial \\boldsymbol{\\delta}} = \\dfrac{1}{\\kappa}\\,\\mathbf{M}\\,\\boldsymbol{\\delta}$.\n\nSecond, we need the derivative of the damage evolution law, $d'(\\kappa) = \\dfrac{\\mathrm{d}d}{\\mathrm{d}\\kappa}$. For $\\kappa  \\kappa_0$:\n$$\nd(\\kappa) = 1 - \\frac{\\kappa_0}{\\kappa}\\,\\exp\\!\\left(-\\frac{\\kappa - \\kappa_0}{S}\\right)\n$$\nDifferentiating with respect to $\\kappa$:\n$$\nd'(\\kappa) = -\\left[ \\left(-\\frac{\\kappa_0}{\\kappa^2}\\right)\\exp\\!\\left(-\\frac{\\kappa - \\kappa_0}{S}\\right) + \\frac{\\kappa_0}{\\kappa}\\exp\\!\\left(-\\frac{\\kappa - \\kappa_0}{S}\\right)\\left(-\\frac{1}{S}\\right) \\right]\n= \\frac{\\kappa_0}{\\kappa^2}\\exp\\!\\left(-\\dots\\right) + \\frac{\\kappa_0}{\\kappa S}\\exp\\!\\left(-\\dots\\right)\n$$\nFactoring out the term $(1 - d(\\kappa)) = \\frac{\\kappa_0}{\\kappa}\\exp(-\\dots)$:\n$$\nd'(\\kappa) = \\frac{1-d(\\kappa)}{\\kappa} + \\frac{1-d(\\kappa)}{S} = (1-d(\\kappa))\\left(\\frac{1}{\\kappa} + \\frac{1}{S}\\right)\n$$\nFor $\\kappa \\le \\kappa_0$, $d(\\kappa)=0$ and $d'(\\kappa)=0$.\n\nCombining these results for the damage loading case ($\\kappa = q(\\boldsymbol{\\delta})  \\kappa_{\\text{prev}}$):\n$$\n\\frac{\\partial d}{\\partial \\boldsymbol{\\delta}} = d'(\\kappa) \\frac{1}{\\kappa}\\,\\mathbf{M}\\,\\boldsymbol{\\delta}\n$$\nSubstituting this back into the expression for $\\mathbf{C}$:\n$$\n\\mathbf{C}_{\\text{loading}} = (1-d)\\,\\mathbf{K} - (\\mathbf{K}\\,\\boldsymbol{\\delta}) \\left(d'(\\kappa) \\frac{1}{\\kappa}\\,\\mathbf{M}\\,\\boldsymbol{\\delta}\\right)^{\\mathsf{T}} = (1-d)\\,\\mathbf{K} - \\frac{d'(\\kappa)}{\\kappa} (\\mathbf{K}\\,\\boldsymbol{\\delta}) \\otimes (\\mathbf{M}\\,\\boldsymbol{\\delta})\n$$\nThis tangent is generally non-symmetric because the outer product term $(\\mathbf{K}\\,\\boldsymbol{\\delta})(\\mathbf{M}\\,\\boldsymbol{\\delta})^{\\mathsf{T}}$ is not symmetric. If damage is not active ($\\kappa \\le \\kappa_0$), then $d=0$ and $d'=0$, so $\\mathbf{C} = \\mathbf{K}$.\n\n### Task B: Newton-Raphson Formulation\n\nWe aim to solve the scalar equilibrium equation $R(\\delta_t) = 0$ for $\\delta_t$ at a fixed normal opening $\\delta_n$ and external shear traction $T_{\\text{ext}}$.\n$$\nR(\\delta_t) = t_t(\\delta_n, \\delta_t) - T_{\\text{ext}}\n$$\nwhere $t_t = \\mathbf{e}_t^{\\mathsf{T}}\\,\\mathbf{t}(\\boldsymbol{\\delta})$ with $\\mathbf{e}_t = \\begin{bmatrix}01\\end{bmatrix}^{\\mathsf{T}}$ and $\\boldsymbol{\\delta} = \\begin{bmatrix}\\delta_n  \\delta_t\\end{bmatrix}^{\\mathsf{T}}$. The Newton-Raphson iterative scheme for an iteration $k$ is:\n$$\n\\delta_t^{(k+1)} = \\delta_t^{(k)} - \\frac{R(\\delta_t^{(k)})}{J(\\delta_t^{(k)})}\n$$\nThe Jacobian $J(\\delta_t)$ is the derivative of the residual with respect to $\\delta_t$:\n$$\nJ(\\delta_t) = \\frac{\\mathrm{d} R}{\\mathrm{d} \\delta_t} = \\frac{\\mathrm{d} t_t}{\\mathrm{d} \\delta_t}\n$$\nUsing the chain rule, and noting that $\\dfrac{\\partial \\boldsymbol{\\delta}}{\\partial \\delta_t} = \\mathbf{e}_t$:\n$$\nJ(\\delta_t) = \\frac{\\partial t_t}{\\partial \\boldsymbol{\\delta}} \\frac{\\partial \\boldsymbol{\\delta}}{\\partial \\delta_t} = \\mathbf{e}_t^{\\mathsf{T}} \\frac{\\partial \\mathbf{t}}{\\partial \\boldsymbol{\\delta}} \\mathbf{e}_t = \\mathbf{e}_t^{\\mathsf{T}}\\,\\mathbf{C}\\,\\mathbf{e}_t = C_{22}\n$$\nThe Jacobian is the $(2,2)$ component of the consistent tangent matrix $\\mathbf{C}$ derived in Task A.\n\nThe algorithm for a single load increment with target traction $T_{\\text{ext}}$ is:\n1. Initialize iteration $k=0$ and guess $\\delta_t^{(0)}$ (from the previous converged step). The history $\\kappa_{\\text{prev}}$ is also taken from the previous converged state.\n2. **Loop** for $k = 0, 1, \\dots, \\text{max_iter}-1$:\n   a. Form the displacement jump vector $\\boldsymbol{\\delta}^{(k)} = [\\delta_n, \\delta_t^{(k)}]^{\\mathsf{T}}$.\n   b. Evaluate state: Compute $q^{(k)} = q(\\boldsymbol{\\delta}^{(k)})$, update $\\kappa^{(k)} = \\max\\{\\kappa_{\\text{prev}}, q^{(k)}\\}$, and find $d^{(k)} = d(\\kappa^{(k)})$.\n   c. Compute residual: $\\mathbf{t}^{(k)} = (1-d^{(k)})\\,\\mathbf{K}\\,\\boldsymbol{\\delta}^{(k)}$, and $R^{(k)} = t_t^{(k)} - T_{\\text{ext}}$.\n   d. Check for convergence: If $|R^{(k)}| \\le 1.0 \\times 10^3\\,\\text{Pa}$, the increment has converged. Break the loop.\n   e. Compute Jacobian: Evaluate $\\mathbf{C}^{(k)}$ based on whether loading or unloading is active at state $\\boldsymbol{\\delta}^{(k)}$, and take $J^{(k)} = C_{22}^{(k)}$.\n   f. Update: $\\delta_t^{(k+1)} = \\delta_t^{(k)} - R^{(k)}/J^{(k)}$.\n3. If converged, update the global state variables for the next increment: $\\delta_t^{\\text{next\\_guess}} \\gets \\delta_t^{(k+1)}$ and $\\kappa_{\\text{prev}} \\gets \\kappa^{(k)}$.\n4. If not converged, the state is not updated, and the previous converged state is used again as the starting point for the next load increment.\n\n### Task C: Implementation and Test Case Analysis\n\nThe algorithm is implemented in Python. A central function manages the Newton-Raphson iterations for each load step. The load history for each test case is pre-computed.\n\n- **Test 1**: Monotonic loading in pure shear up to $0.8\\,T_{\\text{peak}}$. Since the load remains below the peak traction, the model is always in a stable, hardening regime. Thus, all $50$ increments are expected to converge without issue.\n\n- **Test 2**: Monotonic loading in pure shear up to $1.2\\,T_{\\text{peak}}$. The model exhibits softening after reaching $T_{\\text{peak}}$. In a force-controlled setting, no equilibrium solution exists for $T_{\\text{ext}}  T_{\\text{peak}}$. The increments will converge only as long as $T_{\\text{ext},i} \\le T_{\\text{peak}}$. With $T_{\\text{ext},i} = \\frac{i}{50} \\times 1.2\\,T_{\\text{peak}}$, this condition holds for $i \\le 50/1.2 \\approx 41.67$. Therefore, increments $1$ through $41$ are expected to converge, while the rest fail. The expected count is $41$.\n\n- **Test 3**: Cyclic loading in pure shear, with amplitude $1.1\\,T_{\\text{peak}}$. The load path is interpreted from the problem specification and code to be 15 steps from 0 to $1.1\\,T_{\\text{peak}}$, 30 steps from $1.1\\,T_{\\text{peak}}$ to $-1.1\\,T_{\\text{peak}}$, and 15 steps from $-1.1\\,T_{\\text{peak}}$ back to 0, for a total of 60 steps.\n    - Phase 1 ($0 \\to 1.1\\,T_{\\text{peak}}$): Steps fail when $T_{\\text{ext}}  T_{\\text{peak}}$. This occurs for steps $14$ and $15$. Converged: $13$.\n    - Phase 2 ($1.1\\,T_{\\text{peak}} \\to -1.1\\,T_{\\text{peak}}$): The initial steps also have $|T_{\\text{ext}}|  T_{\\text{peak}}$ and fail. Convergence begins at step $17$ (when $|T_{\\text{ext}}|$ drops below $T_{\\text{peak}}$) and ends at step $43$ (just before $|T_{\\text{ext}}|$ exceeds $T_{\\text{peak}}$ on the negative side). Converged: $27$.\n    - Phase 3 ($-1.1\\,T_{\\text{peak}} \\to 0$): Similarly, convergence starts at step $47$ once $|T_{\\text{ext}}|$ drops below $T_{\\text{peak}}$. All subsequent steps converge. Converged: $14$.\n    Total converged increments: $13 + 27 + 14 = 54$.\n\n- **Test 4**: Mixed-mode loading with a constant normal opening. The maximum applied shear traction is $0.9\\,T_{\\text{peak}}$. Although mixed-mode conditions alter the detailed response, the applied load is well within the stable regime and does not approach the mixed-mode limit traction. Therefore, robust convergence is expected for all $50$ increments.\n\nThe program calculates and confirms these expected outcomes.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and implements a cohesive damage model to solve four test cases.\n    The main function orchestrates the setup and execution of each test,\n    collecting the number of converged increments as the result.\n    \"\"\"\n    \n    # Define fixed material parameters and numerical settings\n    Kn = 5.0e12  # Pa/m\n    Kt = 2.0e12  # Pa/m\n    delta_n_char = 5.0e-6  # m\n    delta_t_char = 5.0e-6  # m\n    kappa_0 = 1.0  # dimensionless\n    S = 0.25  # dimensionless\n    \n    TOL = 1.0e3  # Pa\n    MAX_ITER = 30\n    \n    # Test case definitions\n    test_cases_params = [\n        # Test 1: Monotonic below peak, pure shear\n        {'delta_n': 0.0, 'alpha': 0.2, 'gamma': 1.0, 'rho': 0.0, 'T_max_factor': 0.8, 'path_spec': [ (1.0, 50) ]},\n        # Test 2: Monotonic beyond peak, pure shear\n        {'delta_n': 0.0, 'alpha': 0.2, 'gamma': 1.0, 'rho': 0.0, 'T_max_factor': 1.2, 'path_spec': [ (1.0, 50) ]},\n        # Test 3: Cyclic beyond peak, pure shear (15 up, 30 reverse, 15 unload)\n        {'delta_n': 0.0, 'alpha': 0.2, 'gamma': 1.0, 'rho': 0.0, 'T_max_factor': 1.1, 'path_spec': [ (1.0, 15), (-1.0, 30), (0.0, 15) ]},\n        # Test 4: Mixed-mode with opening\n        {'delta_n': 2.0e-6, 'alpha': 0.6, 'gamma': 1.0, 'rho': 0.3, 'T_max_factor': 0.9, 'path_spec': [ (1.0, 50) ]},\n    ]\n\n    results = []\n\n    for params in test_cases_params:\n        # Unpack parameters and set up matrices\n        delta_n = params['delta_n']\n        alpha = params['alpha']\n        gamma = params['gamma']\n        rho = params['rho']\n        \n        K_nt = alpha * np.sqrt(Kn * Kt)\n        K = np.array([[Kn, K_nt], [K_nt, Kt]])\n\n        M = np.array([\n            [1.0 / delta_n_char**2, rho / (delta_n_char * delta_t_char)],\n            [rho / (delta_n_char * delta_t_char), gamma / delta_t_char**2]\n        ])\n\n        # Generate load path\n        T_peak = (Kt * kappa_0 * delta_t_char) / np.sqrt(gamma);\n        T_max = params['T_max_factor'] * T_peak\n        \n        load_path = []\n        T_current = 0.0\n        for T_target_factor, num_steps in params['path_spec']:\n            T_target = T_target_factor * T_max\n            # For the cyclic case, T_target can be 0.0, but a factor is needed. Let's adjust target.\n            if T_target_factor == 0.0: T_target = 0.0\n\n            T_vals = np.linspace(T_current, T_target, num_steps + 1)[1:]\n            load_path.extend(T_vals)\n            T_current = T_target\n\n        # Initialize state variables\n        kappa_prev = 0.0\n        delta_t_converged = 0.0\n        converged_count = 0\n\n        # Loop over load increments\n        for t_ext in load_path:\n            delta_t = delta_t_converged  # Initial guess is the last converged state\n            converged = False\n            \n            for _ in range(MAX_ITER):\n                delta = np.array([delta_n, delta_t])\n                \n                q_squared = delta.T @ M @ delta\n                q = np.sqrt(q_squared) if q_squared > 1e-30 else 0.0\n\n                kappa = max(kappa_prev, q)\n                \n                # Compute damage and derivative\n                if kappa = kappa_0:\n                    d = 0.0\n                else:\n                    d = 1.0 - (kappa_0 / kappa) * np.exp(-(kappa - kappa_0) / S)\n                \n                t = (1.0 - d) * (K @ delta)\n                R = t[1] - t_ext\n                \n                if abs(R) = TOL:\n                    converged = True\n                    break\n\n                # Compute Jacobian J = C[1,1]\n                is_loading = (q > kappa_prev) and (q > 1e-12)\n\n                if not is_loading:\n                    J = (1.0 - d) * K[1, 1]\n                else: # Damage loading\n                    if kappa = kappa_0:\n                        J = K[1, 1]\n                    else:\n                        d_prime = (1.0 - d) * (1.0 / kappa + 1.0 / S) if kappa > 0 else 0.0\n                        Kd = K @ delta\n                        Md = M @ delta\n                        J = (1.0 - d) * K[1, 1] - (d_prime / kappa) * Kd[1] * Md[1]\n\n                if abs(J)  1e-9: # Singular Jacobian\n                    break\n\n                delta_t -= R / J\n            \n            # Post-increment processing\n            if converged:\n                converged_count += 1\n                delta_t_converged = delta_t\n                \n                # Update history variable based on final converged state\n                delta_final = np.array([delta_n, delta_t_converged])\n                q_final_sq = delta_final.T @ M @ delta_final\n                q_final = np.sqrt(q_final_sq) if q_final_sq > 0 else 0.0\n                kappa_prev = max(kappa_prev, q_final)\n            # else: per problem, state is not updated, guess for next step remains the same.\n\n        results.append(converged_count)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3571995"}]}