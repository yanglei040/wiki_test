{"hands_on_practices": [{"introduction": "The Strength Reduction Method (SRM) involves factoring down the soil's shear strength parameters, cohesion ($c'$) and friction angle ($\\phi'$). While reducing cohesion is straightforward, the standard practice for the frictional component is to reduce $\\tan\\phi'$, not the angle $\\phi'$ directly. This practice explores the precise mathematical nature of this reduction, revealing a critical non-linear relationship between the factor of safety and the resulting friction angle [@problem_id:3560645]. Understanding this subtlety is fundamental to correctly interpreting SRM results from any numerical model.", "problem": "Consider a homogeneous, isotropic slope analyzed using the Shear Strength Reduction (SSR) procedure within the Finite Element Method (FEM). The soil obeys the Mohr–Coulomb failure criterion with effective cohesion $c'$ and effective friction angle $\\phi'$, so that the mobilized shear strength on a plane with effective normal stress $\\sigma_n'$ is given by $\\tau = c' + \\sigma_n' \\tan\\phi'$. In SSR, the strength parameters are systematically reduced by a trial Factor of Safety $F_s > 1$ until global failure within the numerical model is detected. The standard SSR scaling applies $c' \\mapsto c_r' = c'/F_s$ and $\\tan\\phi' \\mapsto \\tan\\phi_r' = \\tan\\phi'/F_s$.\n\nStarting from the Mohr–Coulomb failure condition and the SSR scaling stated above, derive a single reduced friction angle $\\phi_r$ such that the reduced stress–strength relation can be written in the same functional form as the original, namely $\\tau_r = c_r' + \\sigma_n' \\tan\\phi_r$. Express $\\phi_r$ explicitly as a closed-form analytic expression in terms of $\\phi'$ and $F_s$, and specify the angle in radians.\n\nThen, using first-principles properties of the tangent and arctangent functions, analyze how $\\phi_r$ depends on $F_s$ for two regimes:\n- small angles $0 < \\phi' \\ll 1$ (in radians), and\n- moderate-to-large angles, for example $\\phi'$ in the range $0.5 \\lesssim \\phi' \\lesssim \\pi/3$.\n\nIn your analysis, justify the limiting behavior and sensitivity of $\\phi_r$ to $F_s$ by appropriate series expansions and monotonicity arguments. Do not assume or cite any pre-derived strength reduction formulas beyond the Mohr–Coulomb criterion and the SSR scaling stated. Provide the final answer as the requested closed-form analytic expression for $\\phi_r$ in radians. No rounding is required.", "solution": "The problem requires the derivation of the reduced friction angle in the context of the Shear Strength Reduction (SSR) method and an analysis of its properties. The problem is scientifically grounded, well-posed, and objective, and therefore deemed valid.\n\nThe analysis begins with the Mohr–Coulomb failure criterion for the soil's shear strength, $\\tau$. The effective shear strength is given by the sum of a cohesive component and a frictional component. For a given plane with effective normal stress $\\sigma_n'$, the shear strength is:\n$$\n\\tau = c' + \\sigma_n' \\tan\\phi'\n$$\nHere, $c'$ is the effective cohesion and $\\phi'$ is the effective angle of internal friction.\n\nThe Shear Strength Reduction (SSR) method involves finding a factor of safety, denoted $F_s$, which when applied to the soil's strength parameters, brings the soil mass to a state of limit equilibrium (i.e., failure). The problem specifies the standard SSR scaling for the Mohr–Coulomb parameters: the cohesion $c'$ and the tangent of the friction angle $\\tan\\phi'$ are both reduced by the factor $F_s$.\n\nLet the reduced strength parameters be denoted $c_r'$ and $\\phi_r$. According to the problem statement, the new, reduced cohesion is:\n$$\nc_r' = \\frac{c'}{F_s}\n$$\nThe problem states that the reduction is also applied to the tangent of the friction angle. This means that the tangent of the new, reduced friction angle, $\\tan\\phi_r$, is defined by scaling the original tangent of the friction angle:\n$$\n\\tan\\phi_r = \\frac{\\tan\\phi'}{F_s}\n$$\nThe resulting reduced shear strength, $\\tau_r$, which represents the mobilized shear strength at the point of failure, is written in the same functional form as the original criterion but with the reduced parameters:\n$$\n\\tau_r = c_r' + \\sigma_n' \\tan\\phi_r\n$$\nThe question asks for a closed-form analytic expression for the reduced friction angle $\\phi_r$ in terms of the original friction angle $\\phi'$ and the factor of safety $F_s$. From the definition of the scaling for the frictional component, we can directly solve for $\\phi_r$. Since $\\phi_r$ is the angle whose tangent is $\\frac{\\tan\\phi'}{F_s}$, we can express $\\phi_r$ using the arctangent function. Assuming that the angles $\\phi'$ and $\\phi_r$ are in the principal range $(-\\pi/2, \\pi/2)$, which is physically required for friction angles, we have:\n$$\n\\phi_r = \\arctan\\left(\\frac{\\tan\\phi'}{F_s}\\right)\n$$\nThis is the required closed-form expression for the reduced friction angle in radians.\n\nNext, we analyze the dependence of $\\phi_r$ on $F_s$ for two different regimes of $\\phi'$.\n\nCase 1: Small angles ($0 < \\phi' \\ll 1$ in radians)\n\nFor small angles $x$, the Maclaurin series for $\\tan(x)$ and $\\arctan(y)$ are:\n$$\n\\tan(x) = x + \\frac{x^3}{3} + O(x^5)\n$$\n$$\n\\arctan(y) = y - \\frac{y^3}{3} + O(y^5)\n$$\nGiven $\\phi'$ is small, we can approximate $\\tan\\phi'$:\n$$\n\\tan\\phi' \\approx \\phi'\n$$\nThe argument of the arctangent function in our expression for $\\phi_r$ becomes $\\frac{\\tan\\phi'}{F_s} \\approx \\frac{\\phi'}{F_s}$. Since $F_s > 1$, this argument is also small. Therefore, the reduced angle $\\phi_r$ is also small, which allows us to use the small-angle approximation for the arctangent function:\n$$\n\\phi_r = \\arctan\\left(\\frac{\\tan\\phi'}{F_s}\\right) \\approx \\frac{\\tan\\phi'}{F_s} \\approx \\frac{\\phi'}{F_s}\n$$\nThis shows that for small friction angles, the reduced angle $\\phi_r$ is approximately equal to the original angle $\\phi'$ scaled down by the factor of safety $F_s$. The relationship is nearly linear.\n\nTo be more rigorous, let us expand the expression for $\\phi_r$ in powers of $\\phi'$. Let $x = \\phi'$.\n$$\n\\frac{\\tan(x)}{F_s} = \\frac{x + x^3/3 + O(x^5)}{F_s} = \\frac{x}{F_s} + \\frac{x^3}{3F_s} + O(x^5)\n$$\nNow, we substitute this into the series for $\\arctan(y)$, with $y = \\frac{\\tan(x)}{F_s}$:\n$$\n\\phi_r = \\left(\\frac{x}{F_s} + \\frac{x^3}{3F_s}\\right) - \\frac{1}{3}\\left(\\frac{x}{F_s}\\right)^3 + O(x^5)\n$$\n$$\n\\phi_r = \\frac{x}{F_s} + \\left(\\frac{1}{3F_s} - \\frac{1}{3F_s^3}\\right)x^3 + O(x^5)\n$$\nSubstituting $x = \\phi'$ back gives:\n$$\n\\phi_r = \\frac{\\phi'}{F_s} + \\frac{F_s^2 - 1}{3F_s^3}(\\phi')^3 + O((\\phi')^5)\n$$\nSince $F_s > 1$, the coefficient of the $(\\phi')^3$ term, $\\frac{F_s^2 - 1}{3F_s^3}$, is positive. This rigorously demonstrates that $\\phi_r$ is slightly larger than the linear approximation $\\phi'/F_s$. This means that the standard SSR scaling of $\\tan\\phi'$ results in a less severe reduction of the friction angle itself compared to a hypothetical direct scaling of the angle, $\\phi' \\mapsto \\phi'/F_s$.\n\nCase 2: Moderate-to-large angles ($0.5 \\lesssim \\phi' \\lesssim \\pi/3$)\n\nIn this range, the small-angle approximations are no longer valid, and the relationship $\\phi_r = \\arctan\\left(\\frac{\\tan\\phi'}{F_s}\\right)$ is highly non-linear. To analyze the sensitivity of $\\phi_r$ to $F_s$, we examine the partial derivative $\\frac{\\partial\\phi_r}{\\partial F_s}$. Using the chain rule for differentiation, where $u = \\frac{\\tan\\phi'}{F_s}$:\n$$\n\\frac{\\partial\\phi_r}{\\partial F_s} = \\frac{\\partial}{\\partial F_s} \\arctan(u) = \\frac{1}{1+u^2} \\frac{\\partial u}{\\partial F_s}\n$$\nThe derivative of $u$ with respect to $F_s$ is:\n$$\n\\frac{\\partial u}{\\partial F_s} = \\tan\\phi' \\left(-\\frac{1}{F_s^2}\\right) = -\\frac{\\tan\\phi'}{F_s^2}\n$$\nSubstituting this back, we obtain:\n$$\n\\frac{\\partial\\phi_r}{\\partial F_s} = \\frac{1}{1 + \\left(\\frac{\\tan\\phi'}{F_s}\\right)^2} \\left(-\\frac{\\tan\\phi'}{F_s^2}\\right) = -\\frac{\\tan\\phi'}{F_s^2 + (\\tan\\phi')^2}\n$$\nSince $\\phi' \\in (0, \\pi/2)$, $\\tan\\phi' > 0$. As $F_s > 1$, the denominator is always positive. Therefore, $\\frac{\\partial\\phi_r}{\\partial F_s} < 0$, which confirms that $\\phi_r$ is a monotonically decreasing function of $F_s$. This is physically intuitive: a larger factor of safety requires a greater reduction in strength, hence a smaller reduced friction angle.\n\nThe non-linearity of the reduction can be further demonstrated by proving the inequality $\\phi_r > \\phi'/F_s$ for all $\\phi' \\in (0, \\pi/2)$ and $F_s > 1$. Let us define two functions of a variable $x$: $f(x) = \\arctan\\left(\\frac{\\tan x}{F_s}\\right)$ and $g(x) = \\frac{x}{F_s}$. We note that $f(0) = g(0) = 0$. Now we compare their derivatives:\n$$\ng'(x) = \\frac{1}{F_s}\n$$\n$$\nf'(x) = \\frac{d}{dx}\\arctan\\left(\\frac{\\tan x}{F_s}\\right) = \\frac{1}{1+\\left(\\frac{\\tan x}{F_s}\\right)^2} \\cdot \\frac{\\sec^2 x}{F_s} = \\frac{F_s \\sec^2 x}{F_s^2 + \\tan^2 x}\n$$\nWe want to check if $f'(x) > g'(x)$:\n$$\n\\frac{F_s \\sec^2 x}{F_s^2 + \\tan^2 x} > \\frac{1}{F_s}\n$$\n$$\nF_s^2 \\sec^2 x > F_s^2 + \\tan^2 x\n$$\nUsing the identity $\\sec^2 x = 1 + \\tan^2 x$:\n$$\nF_s^2 (1 + \\tan^2 x) > F_s^2 + \\tan^2 x\n$$\n$$\nF_s^2 + F_s^2 \\tan^2 x > F_s^2 + \\tan^2 x\n$$\n$$\n(F_s^2 - 1) \\tan^2 x > 0\n$$\nSince $F_s > 1$, $F_s^2 - 1 > 0$. For $x \\in (0, \\pi/2)$, $\\tan^2 x > 0$. Thus, the inequality holds. Because $f(0) = g(0)$ and $f'(x) > g'(x)$ for $x > 0$, it follows from the Mean Value Theorem that $f(x) > g(x)$ for all $x > 0$. Substituting $x = \\phi'$, we have definitively shown that:\n$$\n\\arctan\\left(\\frac{\\tan\\phi'}{F_s}\\right) > \\frac{\\phi'}{F_s}\n$$\nThis inequality confirms that the standard SSR scaling method is less conservative (i.e., results in a higher reduced friction angle) than a direct scaling of the angle $\\phi'$ itself. The deviation from linearity, $\\phi_r - \\phi'/F_s$, increases as $\\phi'$ moves from the small-angle regime to the moderate-to-large angle regime. This non-linear behavior is an intrinsic property of the Mohr–Coulomb criterion and the standard SSR scaling procedure.", "answer": "$$\\boxed{\\arctan\\left(\\frac{\\tan\\phi'}{F_s}\\right)}$$", "id": "3560645"}, {"introduction": "In computational analysis, the critical Strength Reduction Factor ($F_s$) is not solved for directly but is found through an iterative search. This exercise demystifies this process by having you implement the core algorithm used in sophisticated software: an adaptive search to bracket the failure point, followed by a refinement to pinpoint its value accurately [@problem_id:3560694]. By applying this to a classic infinite slope model, you will gain hands-on insight into the numerical heart of the SRM and build an appreciation for the logic of automated stability assessment.", "problem": "Design and implement a complete, runnable program that computes, for each of several prescribed slope configurations, the critical strength reduction factor $F_s^\\star$ that triggers failure in a Strength Reduction Method (SRM) analysis with adaptive step-size control and rigorous bracketing of the collapse multiplier. The analysis must be grounded in the following fundamental base.\n\nFundamental base:\n- Equilibrium of forces requires that internal mobilized shear traction balances external driving shear demand.\n- The Mohr–Coulomb shear strength in effective stress terms is $ \\tau_\\mathrm{s} = c' + \\sigma_n' \\tan \\phi'$, where $c'$ is the effective cohesion and $\\phi'$ is the effective internal friction angle.\n- In the strength reduction approach, strength parameters are reduced by the factor of safety $F_s$, i.e., $c'_r = c'/F_s$ and $\\tan \\phi'_r = \\tan \\phi'/F_s$.\n- For a dry infinite slope at depth $z$, the driving shear stress and normal stress on a plane parallel to the slope surface are, respectively, $ \\tau_\\mathrm{d}(z) = \\gamma z \\sin\\beta \\cos\\beta$ and $ \\sigma_n(z) = \\gamma z \\cos^2 \\beta$, where $\\gamma$ is the unit weight and $\\beta$ is the slope angle. Here, take $z = H$ (characteristic depth equal to slope height $H$). Angles must be provided in degrees and converted to radians for computation.\n- Failure is indicated when no solution of the nonlinear equilibrium can be found that satisfies admissibility with the reduced strength, i.e., when the mobilized shear traction required by equilibrium exceeds the reduced strength.\n\nYou must formulate the computational problem in purely mathematical terms as follows.\n\n1) Nonlinear equilibrium problem per trial $F_s$:\n- Introduce a scalar slip displacement $w \\ge 0$ at a representative interface with elastic stiffness $k_t$ (per unit area) obeying an elastoplastic law with a Mohr–Coulomb cap:\n  - Elastic trial traction: $t_\\mathrm{trial} = k_t w$.\n  - Yield strength with reduction: $t_\\mathrm{y}(F_s) = c'/F_s + \\sigma_n \\tan\\phi'/F_s$.\n  - Admissible traction: $t(w;F_s) = \\min\\{t_\\mathrm{trial}, t_\\mathrm{y}(F_s)\\}$.\n- The equilibrium residual is $r(w;F_s) = t(w;F_s) - \\tau_\\mathrm{d}$, where $\\tau_\\mathrm{d} = \\gamma H \\sin\\beta \\cos\\beta$ and $\\sigma_n = \\gamma H \\cos^2 \\beta$.\n- For a given $F_s$, solve the nonlinear equation $r(w;F_s)=0$ for $w \\ge 0$. Declare “failure” for that $F_s$ if no $w$ satisfies $r(w;F_s)=0$ (i.e., if $\\tau_\\mathrm{d} > t_\\mathrm{y}(F_s)$). Angles must be interpreted in radians during computation. Stresses must be computed consistently in $\\mathrm{kPa}$, with $\\gamma$ in $\\mathrm{kN/m^3}$ and $H$ in $\\mathrm{m}$, so that $\\gamma H$ yields $\\mathrm{kPa}$.\n\n2) Outer algorithm: adaptive step-size control and bracketing of $F_s^\\star$:\n- Start from $F_s = 1$.\n- Increase $F_s$ iteratively with an adaptive step size $\\Delta F_s$ based on the signed stability margin $g(F_s) = t_\\mathrm{y}(F_s) - \\tau_\\mathrm{d}$:\n  - If $g(F_s) \\ge 0$, the system is stable at this $F_s$; increase $F_s$ by a positive step. Make $\\Delta F_s$ larger when $g(F_s)$ is strongly positive and smaller when $g(F_s)$ is near zero, subject to lower and upper bounds for numerical robustness.\n  - If $g(F_s) &lt; 0$, the system is unstable at this $F_s$; you have bracketed the collapse multiplier. Record the last stable $F_s$ as the lower bound and the current unstable $F_s$ as the upper bound.\n- If the initial configuration at $F_s = 1$ is already unstable, adaptively reduce $F_s$ (e.g., by halving) until stability is achieved to obtain a lower bound, thereby bracketing $F_s^\\star$ from below.\n- Once a bracket $[F_s^\\mathrm{L}, F_s^\\mathrm{U}]$ is identified with $g(F_s^\\mathrm{L}) \\ge 0$ and $g(F_s^\\mathrm{U}) &lt; 0$, refine $F_s^\\star$ by bisection on $g(F_s)$ until a tolerance criterion is satisfied. Use a convergence tolerance of $10^{-8}$ on $F_s$.\n- The final reported $F_s^\\star$ is the smallest $F_s$ such that the nonlinear equilibrium fails (collapse multiplier for strength reduction), i.e., the root of $g(F_s) = 0$ found by bracketing and bisection.\n\n3) Numerical requirements:\n- All angles in the input are in degrees and must be converted to radians for computation.\n- Use $k_t = 10^3\\,\\mathrm{kPa}$ as the interface elastic stiffness per unit area. This parameter ensures a well-defined elastic predictor in the equilibrium solver; the final $F_s^\\star$ must not depend on $k_t$ because the failure indicator is governed by admissibility.\n- Implement robust adaptive step size control with safeguards: enforce $\\Delta F_s \\in [10^{-2}, 2]$ and a maximum of $10^4$ outer iterations to guarantee termination.\n\nTest suite:\nProvide $F_s^\\star$ for the following four cases. Use $H$ in $\\mathrm{m}$, $\\gamma$ in $\\mathrm{kN/m^3}$, $c'$ in $\\mathrm{kPa}$, and angles in degrees. Report the final answers as dimensionless floats. The program must compute all four, in order, and print the final results on a single line as a comma-separated list enclosed in square brackets, with each value rounded to exactly six digits after the decimal point.\n\n- Case A (general stable case):\n  - $\\gamma = 20\\,\\mathrm{kN/m^3}$,\n  - $H = 10\\,\\mathrm{m}$,\n  - $\\beta = 30^\\circ$,\n  - $c' = 5\\,\\mathrm{kPa}$,\n  - $\\phi' = 30^\\circ$.\n- Case B (initially unstable at $F_s=1$):\n  - $\\gamma = 18\\,\\mathrm{kN/m^3}$,\n  - $H = 12\\,\\mathrm{m}$,\n  - $\\beta = 35^\\circ$,\n  - $c' = 0\\,\\mathrm{kPa}$,\n  - $\\phi' = 28^\\circ$.\n- Case C (stable with larger collapse multiplier):\n  - $\\gamma = 18\\,\\mathrm{kN/m^3}$,\n  - $H = 5\\,\\mathrm{m}$,\n  - $\\beta = 25^\\circ$,\n  - $c' = 2\\,\\mathrm{kPa}$,\n  - $\\phi' = 35^\\circ$.\n- Case D (boundary case):\n  - $\\gamma = 21\\,\\mathrm{kN/m^3}$,\n  - $H = 8\\,\\mathrm{m}$,\n  - $\\beta = 26^\\circ$,\n  - $c' = 0\\,\\mathrm{kPa}$,\n  - $\\phi' = 26^\\circ$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[x_1,x_2,x_3,x_4]$), with each $x_i$ rounded to exactly six digits after the decimal point. Each output entry is the computed $F_s^\\star$ for the corresponding case, and it is dimensionless. No other text must be printed.", "solution": "The problem is assessed to be valid. It is scientifically grounded in the principles of soil mechanics, well-posed, and provides a complete and consistent set of requirements for a numerical solution. The problem asks for the design and implementation of an algorithm to find the critical strength reduction factor, $F_s^\\star$, for several infinite slope configurations. Although the problem can be solved analytically, the core task is to implement the specified numerical scheme involving an adaptive search and bisection, which is a common and practical task in computational engineering.\n\nThe solution proceeds as follows: First, the governing physical and mathematical equations are established. Second, the specified numerical algorithm for locating the critical factor of safety is detailed. Finally, this algorithm is implemented in a Python program to solve the given test cases.\n\n**1. Theoretical Formulation**\n\nThe stability of an infinite, dry, cohesionless-frictional slope is analyzed. The fundamental inputs are the soil's unit weight $\\gamma$, the slope height $H$ (at which stresses are evaluated), the slope angle $\\beta$, the effective cohesion $c'$, and the effective angle of internal friction $\\phi'$.\n\nFor a point at depth $H$ on a potential failure plane parallel to the slope surface, the driving shear stress $\\tau_\\mathrm{d}$ and the normal stress $\\sigma_n$ are given by:\n$$\n\\tau_\\mathrm{d} = \\gamma H \\sin\\beta \\cos\\beta\n$$\n$$\n\\sigma_n = \\gamma H \\cos^2\\beta\n$$\nThe problem specifies a dry slope, so effective normal stress $\\sigma_n'$ is equal to the total normal stress $\\sigma_n$. The available shear strength of the soil is described by the Mohr-Coulomb failure criterion:\n$$\n\\tau_s = c' + \\sigma_n \\tan\\phi'\n$$\nThe Strength Reduction Method (SRM) involves finding a factor of safety, $F_s$, by which the strength parameters must be divided to bring the slope to a state of limit equilibrium. The reduced strength parameters, $c'_r$ and $\\phi'_r$, are:\n$$\nc'_r = \\frac{c'}{F_s}\n$$\n$$\n\\tan\\phi'_r = \\frac{\\tan\\phi'}{F_s}\n$$\nThe reduced shear strength, denoted as $t_y(F_s)$, is therefore:\n$$\nt_y(F_s) = \\frac{c'}{F_s} + \\sigma_n \\frac{\\tan\\phi'}{F_s} = \\frac{c' + \\sigma_n \\tan\\phi'}{F_s}\n$$\nThe problem introduces a fictitious elastoplastic interface model to formalize the equilibrium condition. However, the failure condition simplifies to the moment when the driving shear stress exceeds the available reduced strength. A state of equilibrium is possible only if $\\tau_\\mathrm{d} \\le t_y(F_s)$. The critical state, or failure, occurs at the smallest value of $F_s$, denoted $F_s^\\star$, for which equilibrium cannot be maintained. This corresponds to the limit equilibrium condition $\\tau_\\mathrm{d} = t_y(F_s^\\star)$.\n\nTo facilitate a numerical search, we define a stability margin function, $g(F_s)$:\n$$\ng(F_s) = t_y(F_s) - \\tau_\\mathrm{d} = \\frac{c' + \\sigma_n \\tan\\phi'}{F_s} - \\tau_\\mathrm{d}\n$$\n- If $g(F_s) > 0$, the slope is stable for the given $F_s$.\n- If $g(F_s) < 0$, the slope is unstable for the given $F_s$.\n- If $g(F_s) = 0$, the slope is at the limit of equilibrium.\n\nThe problem is thus reduced to finding the root of the equation $g(F_s) = 0$. Solving for $F_s$ gives the analytical solution for the factor of safety:\n$$\nF_s^\\star = \\frac{c' + \\sigma_n \\tan\\phi'}{\\tau_\\mathrm{d}} = \\frac{c' + \\gamma H \\cos^2\\beta \\tan\\phi'}{\\gamma H \\sin\\beta \\cos\\beta} = \\frac{c'}{\\gamma H \\sin\\beta \\cos\\beta} + \\frac{\\tan\\phi'}{\\tan\\beta}\n$$\nWhile this analytical formula exists and can be used for verification, the problem requires implementing a specific numerical algorithm to find $F_s^\\star$.\n\n**2. Algorithmic Design**\n\nThe core of the task is to implement a root-finding algorithm for $g(F_s)=0$ that follows the prescribed three-phase process: adaptive bracketing search, bisection refinement, and final reporting. All angles must be converted from degrees to radians for trigonometric calculations.\n\n**Phase 1: Bracketing Search**\nThe goal is to find a lower bound $F_s^\\mathrm{L}$ and an upper bound $F_s^\\mathrm{U}$ such that $g(F_s^\\mathrm{L}) \\ge 0$ and $g(F_s^\\mathrm{U}) < 0$. The search starts at $F_s=1$.\n\n- **Case 1: Initially Stable Slope ($g(1) \\ge 0$)**\n  The initial value $F_s=1$ serves as the lower bound, $F_s^\\mathrm{L} = 1$. We must search for an upper bound by iteratively increasing $F_s$.\n  An adaptive step-size rule is employed. The step $\\Delta F_s$ should decrease as $g(F_s)$ approaches zero. A suitable rule, based on the normalized stability margin, is:\n  $$\n  \\Delta F_s = \\alpha \\cdot F_s \\cdot \\frac{g(F_s)}{\\tau_\\mathrm{d}}\n  $$\n  where $\\alpha$ is a damping factor (e.g., $\\alpha=0.5$). To ensure robustness and progress, this step is clipped to a prescribed range $[\\Delta F_{s, \\min}, \\Delta F_{s, \\max}]$, which are given as $[10^{-2}, 2]$. The iteration proceeds as $F_{s, i+1} = F_{s, i} + \\Delta F_s$ until $g(F_{s, i+1}) < 0$. At this point, $F_s^\\U = F_{s, i+1}$ and the bracket is established.\n\n- **Case 2: Initially Unstable Slope ($g(1) < 0$)**\n  The initial value $F_s=1$ serves as the upper bound, $F_s^\\mathrm{U} = 1$. We must search for a lower bound by iteratively decreasing $F_s$. As suggested, a simple and robust method is to repeatedly halve $F_s$, i.e., $F_{s, i+1} = F_{s, i} / 2$, until $g(F_{s, i+1}) \\ge 0$. At this point, $F_s^\\mathrm{L} = F_{s, i+1}$ and the bracket is established.\n\nA maximum number of iterations ($10^4$) is used as a safeguard against an infinite loop in this phase.\n\n**Phase 2: Bisection Refinement**\nOnce the bracket $[F_s^\\mathrm{L}, F_s^\\mathrm{U}]$ is found, the bisection method is applied to refine the root $F_s^\\star$ with high precision. The algorithm is as follows:\n1. Calculate the midpoint: $F_s^\\mathrm{mid} = (F_s^\\mathrm{L} + F_s^\\mathrm{U}) / 2$.\n2. Evaluate the stability margin at the midpoint, $g(F_s^\\mathrm{mid})$.\n3. Update the bracket:\n   - If $g(F_s^\\mathrm{mid}) \\ge 0$, the root is in the upper half, so set $F_s^\\mathrm{L} = F_s^\\mathrm{mid}$.\n   - If $g(F_s^\\mathrm{mid})< 0$, the root is in the lower half, so set $F_s^\\mathrm{U} = F_s^\\mathrm{mid}$.\n4. Repeat steps 1-3 until the width of the bracket, $(F_s^\\mathrm{U} - F_s^\\mathrm{L})$, is smaller than the specified tolerance of $10^{-8}$.\n\n**Phase 3: Final Result**\nThe final estimate for the critical factor of safety, $F_s^\\star$, is taken as the midpoint of the final bracket, $(F_s^\\mathrm{L} + F_s^\\mathrm{U}) / 2$. This value is then formatted as required for output.\n\nThis comprehensive algorithm ensures a robust and accurate determination of $F_s^\\star$ according to the problem's specifications.", "answer": "```python\nimport numpy as np\n\ndef compute_fs_star(gamma, H, beta_deg, c_prime, phi_prime_deg):\n    \"\"\"\n    Computes the critical strength reduction factor (Fs_star) for an infinite slope.\n\n    The function implements a numerical scheme involving an adaptive search to\n    bracket the solution, followed by bisection to refine it to a high tolerance.\n\n    Args:\n        gamma (float): Unit weight of the soil (kN/m^3).\n        H (float): Characteristic depth/height (m).\n        beta_deg (float): Slope angle (degrees).\n        c_prime (float): Effective cohesion (kPa).\n        phi_prime_deg (float): Effective internal friction angle (degrees).\n\n    Returns:\n        float: The computed critical strength reduction factor, Fs_star.\n    \"\"\"\n    # Numerical parameters and tolerances from the problem statement\n    TOL = 1e-8\n    MAX_ITER_OUTER = 10000\n    MIN_DFs = 0.01\n    MAX_DFs = 2.0\n    # k_t is not needed for the simplified failure condition g(Fs)=0\n\n    # Convert angles from degrees to radians for computation\n    beta_rad = np.deg2rad(beta_deg)\n    phi_rad = np.deg2rad(phi_prime_deg)\n\n    # Calculate driving shear stress (tau_d) and normal stress (sigma_n)\n    tau_d = gamma * H * np.sin(beta_rad) * np.cos(beta_rad)\n    sigma_n = gamma * H * np.cos(beta_rad)**2\n    \n    # Handle the edge case where tau_d is zero or negative (e.g., beta >= 90 deg)\n    # The analytical Fs would be infinite. The numerical search might fail.\n    # For this problem's context, tau_d will be positive.\n    if tau_d <= 0:\n        return np.inf # Practically stable for any Fs\n\n    # Define the stability margin function g(Fs)\n    # g(Fs) = t_y(Fs) - tau_d\n    strength_term = c_prime + sigma_n * np.tan(phi_rad)\n    \n    # If the strength term is zero or negative, the slope is unconditionally unstable\n    if strength_term <= 0:\n        return 0.0\n        \n    g = lambda Fs: strength_term / Fs - tau_d\n\n    # --- Phase 1: Bracketing Search ---\n    fs_lower = None\n    fs_upper = None\n    \n    fs_current = 1.0\n    margin = g(fs_current)\n\n    if margin >= 0:  # Initially stable case (g(1) >= 0)\n        fs_lower = fs_current\n        # Search for an upper bound by increasing Fs\n        for _ in range(MAX_ITER_OUTER):\n            # Adaptive step size calculation\n            # Proportional to the normalized margin, damped by a factor 0.5\n            # This makes the step larger when far from failure, smaller when close\n            if tau_d > 0:\n                delta_fs_calc = 0.5 * fs_current * (g(fs_current) / tau_d)\n            else: # Should not happen with valid inputs\n                delta_fs_calc = MIN_DFs\n            \n            delta_fs = np.clip(delta_fs_calc, MIN_DFs, MAX_DFs)\n            \n            fs_next = fs_current + delta_fs\n            margin_next = g(fs_next)\n\n            if margin_next < 0:\n                fs_upper = fs_next\n                break\n            else:\n                fs_current = fs_next\n        else: # Loop finished without finding an upper bound\n            raise RuntimeError(\"Bracketing failed: could not find an upper bound.\")\n\n    else:  # Initially unstable case (g(1) < 0)\n        fs_upper = fs_current\n        # Search for a lower bound by decreasing Fs (halving)\n        for _ in range(MAX_ITER_OUTER):\n            fs_next = fs_current / 2.0\n            margin_next = g(fs_next)\n            \n            if margin_next >= 0:\n                fs_lower = fs_next\n                break\n            else:\n                fs_current = fs_next\n        else: # Loop finished without finding a lower bound\n             raise RuntimeError(\"Bracketing failed: could not find a lower bound.\")\n\n    if fs_lower is None or fs_upper is None:\n        raise RuntimeError(\"Bracketing failed unexpectedly.\")\n\n    # --- Phase 2: Bisection Refinement ---\n    while (fs_upper - fs_lower) > TOL:\n        fs_mid = (fs_lower + fs_upper) / 2.0\n        if fs_mid == fs_lower or fs_mid == fs_upper: # Reached precision limit\n            break\n        \n        margin_mid = g(fs_mid)\n\n        if margin_mid >= 0:\n            fs_lower = fs_mid\n        else:\n            fs_upper = fs_mid\n            \n    # --- Phase 3: Final Result ---\n    fs_star = (fs_lower + fs_upper) / 2.0\n    return fs_star\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Test cases as defined in the problem statement\n    test_cases = [\n        # Case A (general stable case)\n        {'gamma': 20.0, 'H': 10.0, 'beta_deg': 30.0, 'c_prime': 5.0, 'phi_prime_deg': 30.0},\n        # Case B (initially unstable at Fs=1)\n        {'gamma': 18.0, 'H': 12.0, 'beta_deg': 35.0, 'c_prime': 0.0, 'phi_prime_deg': 28.0},\n        # Case C (stable with larger collapse multiplier)\n        {'gamma': 18.0, 'H': 5.0, 'beta_deg': 25.0, 'c_prime': 2.0, 'phi_prime_deg': 35.0},\n        # Case D (boundary case)\n        {'gamma': 21.0, 'H': 8.0, 'beta_deg': 26.0, 'c_prime': 0.0, 'phi_prime_deg': 26.0},\n    ]\n\n    results = []\n    for case in test_cases:\n        fs_star = compute_fs_star(**case)\n        results.append(fs_star)\n\n    # Format the final output according to the specified format\n    # Comma-separated list, in brackets, with each value rounded to 6 decimal places.\n    print(f\"[{','.join(f'{x:.6f}' for x in results)}]\")\n\nsolve()\n```", "id": "3560694"}, {"introduction": "The choice of a constitutive model can significantly influence the results of a stability analysis. This advanced practice compares the ubiquitous Mohr-Coulomb (MC) criterion with its common computational approximation, the Drucker-Prager (DP) model [@problem_id:3560689]. By implementing a fitting procedure and calculating the resulting factor of safety for both, you will quantify the error introduced by the DP model's inability to capture the full range of soil behavior, specifically its dependence on the Lode angle, a key concept in three-dimensional stress analysis.", "problem": "You must write a complete and runnable program that compares the predicted Strength Reduction Factor (SRF) from the Drucker–Prager (DP) and Mohr–Coulomb (MC) models when the DP model is fitted to the MC model using triaxial compression and triaxial extension meridians. The procedure must be rooted in valid mechanics and computational geomechanics principles. The program must implement the following, using the physical units and angle units specified, and must return the requested numerical outputs in the specified final format.\n\nThe fundamental base for the derivation is as follows. Let $p$ denote the mean stress and $q$ denote the second deviatoric invariant measure defined by $q = \\sqrt{3 J_2}$, both in the compression-positive sign convention. For the Mohr–Coulomb (MC) model with cohesion $c$ and friction angle $\\phi$, the triaxial compression (TXC) and triaxial extension (TXE) meridians in the $p$–$q$ space are well-established and given by linear relations:\n$$\nq_{\\mathrm{MC,TXC}}(p;c,\\phi) = M_c(\\phi)\\, p + K_c(c,\\phi),\n\\quad\nq_{\\mathrm{MC,TXE}}(p;c,\\phi) = M_e(\\phi)\\, p + K_e(c,\\phi),\n$$\nwhere\n$$\nM_c(\\phi) = \\frac{6 \\sin\\phi}{3 - \\sin\\phi}, \\quad K_c(c,\\phi) = \\frac{6 c \\cos\\phi}{3 - \\sin\\phi},\n$$\n$$\nM_e(\\phi) = \\frac{6 \\sin\\phi}{3 + \\sin\\phi}, \\quad K_e(c,\\phi) = \\frac{6 c \\cos\\phi}{3 + \\sin\\phi}.\n$$\nThese meridians represent the $p$–$q$ yield loci for the MC model at the extreme Lode angles (Lode angle defined as $\\theta$), corresponding to axisymmetric triaxial compression ($\\theta = -\\pi/6$) and axisymmetric triaxial extension ($\\theta = +\\pi/6$). The Lode angle quantifies the influence of the third invariant and the ordering of principal stresses; the MC model exhibits Lode angle dependence, while the DP model does not.\n\nThe Drucker–Prager (DP) model defines a single linear meridian in the $p$–$q$ plane,\n$$\nq_{\\mathrm{DP}}(p;\\,c,\\phi) = M_{\\mathrm{DP}}(c,\\phi)\\, p + K_{\\mathrm{DP}}(c,\\phi),\n$$\nthat is independent of the Lode angle. To make DP comparable to MC, you must fit the DP meridian to the MC TXC and TXE meridians by minimizing the sum of squared meridian deviations over a prescribed mean stress interval. Concretely, for a fitting interval $p \\in [0, P_{\\mathrm{fit}}]$, define the aggregate dataset consisting of points on both MC meridians,\n$$\n\\{(p_i, q_{\\mathrm{MC,TXC}}(p_i;c,\\phi))\\}_{i=1}^{N} \\cup \\{(p_i, q_{\\mathrm{MC,TXE}}(p_i;c,\\phi))\\}_{i=1}^{N},\n$$\nwith $p_i$ uniformly spaced over $[0, P_{\\mathrm{fit}}]$, and determine the single linear DP meridian $q = M_{\\mathrm{DP}}\\, p + K_{\\mathrm{DP}}$ that minimizes the total squared residuals across the combined dataset. This is a standard linear regression problem; the optimal $M_{\\mathrm{DP}}$ and $K_{\\mathrm{DP}}$ are the slope and intercept of the least-squares line fitted to the aggregated points.\n\nFor Strength Reduction in the context of Slope Stability by Strength Reduction Method (SRM), the Strength Reduction Factor (SRF) $S$ is applied to reduce the MC shear strength parameters as follows:\n$$\nc_R(S) = \\frac{c}{S}, \\quad \\tan\\phi_R(S) = \\frac{\\tan\\phi}{S}, \\quad \\phi_R(S) = \\arctan\\!\\left(\\frac{\\tan\\phi}{S}\\right).\n$$\nAfter reduction, the MC meridians become\n$$\nq_{\\mathrm{MC,TXC}}(p;c_R,\\phi_R) = M_c(\\phi_R)\\, p + K_c(c_R,\\phi_R), \\quad\nq_{\\mathrm{MC,TXE}}(p;c_R,\\phi_R) = M_e(\\phi_R)\\, p + K_e(c_R,\\phi_R),\n$$\nwhile the DP meridian used for comparison is re-fitted at the reduced parameters according to the same least-squares procedure over $[0, P_{\\mathrm{fit}}]$, yielding\n$$\nq_{\\mathrm{DP}}(p;c_R,\\phi_R) = M_{\\mathrm{DP}}(c_R,\\phi_R)\\, p + K_{\\mathrm{DP}}(c_R,\\phi_R).\n$$\n\nGiven a demanded deviatoric stress level $q_d$ at a specified mean stress $p$ and Lode angle $\\theta$, the predicted SRF for MC, denoted $S_{\\mathrm{MC}}$, is the solution to\n$$\nq_{\\mathrm{MC}}(p;\\, c_R(S_{\\mathrm{MC}}), \\phi_R(S_{\\mathrm{MC}}), \\theta) = q_d,\n$$\nwhere $q_{\\mathrm{MC}}(p;\\cdot,\\cdot,\\theta)$ is the corresponding MC meridian at $\\theta = -\\pi/6$ (TXC) or $\\theta = +\\pi/6$ (TXE) chosen by the test case. Similarly, the predicted SRF for DP, denoted $S_{\\mathrm{DP}}$, is the solution to\n$$\nq_{\\mathrm{DP}}(p;\\, c_R(S_{\\mathrm{DP}}), \\phi_R(S_{\\mathrm{DP}})) = q_d.\n$$\nYou must compute the relative SRF error due to Lode angle effects as\n$$\nE = \\frac{S_{\\mathrm{DP}}}{S_{\\mathrm{MC}}} - 1.\n$$\n\nAngle unit specification: All angles in the input and internal calculations must be in degrees, except when evaluating trigonometric functions where conversion to radians is necessary. Physical unit specification: All stresses ($p$, $q$, $c$) must be treated in kilopascals (kPa). Your program must produce $E$ as a float for each test case.\n\nTo ensure scientific realism and testability, use the following test suite and assume compression-positive convention for stress invariants:\n\n- Test Case $1$ (happy path, triaxial compression):\n  - $c = 20$ kPa,\n  - $\\phi = 35$ degrees,\n  - $p = 150$ kPa,\n  - $\\theta = -30$ degrees (triaxial compression),\n  - $q_d = 220$ kPa,\n  - $P_{\\mathrm{fit}} = 150$ kPa.\n\n- Test Case $2$ (happy path, triaxial extension):\n  - $c = 20$ kPa,\n  - $\\phi = 35$ degrees,\n  - $p = 150$ kPa,\n  - $\\theta = +30$ degrees (triaxial extension),\n  - $q_d = 160$ kPa,\n  - $P_{\\mathrm{fit}} = 150$ kPa.\n\n- Test Case $3$ (lower strength, cohesion-friction mix, triaxial compression):\n  - $c = 5$ kPa,\n  - $\\phi = 20$ degrees,\n  - $p = 50$ kPa,\n  - $\\theta = -30$ degrees,\n  - $q_d = 40$ kPa,\n  - $P_{\\mathrm{fit}} = 50$ kPa.\n\n- Test Case $4$ (boundary case, zero cohesion, high friction, triaxial extension):\n  - $c = 0$ kPa,\n  - $\\phi = 45$ degrees,\n  - $p = 100$ kPa,\n  - $\\theta = +30$ degrees,\n  - $q_d = 90$ kPa,\n  - $P_{\\mathrm{fit}} = 100$ kPa.\n\nFor each test case, you must:\n- Fit the DP meridian to the combined MC TXC and MC TXE meridians over $p \\in [0, P_{\\mathrm{fit}}]$ using least squares, at the reduced parameters determined by the unknown SRF $S$.\n- Solve for $S_{\\mathrm{MC}}$ and $S_{\\mathrm{DP}}$ separately using a numerical root-finding procedure that ensures monotonic bracketing and convergence.\n- Compute the relative SRF error $E = S_{\\mathrm{DP}}/S_{\\mathrm{MC}} - 1$.\n\nFinal output format requirement: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for the above four test cases, in the order $[E_1,E_2,E_3,E_4]$. For example, the output must be of the form $[x_1,x_2,x_3,x_4]$ where each $x_i$ is a float. No additional text may be printed.", "solution": "The problem has been validated and is deemed **valid**. It is scientifically grounded in the principles of continuum mechanics and computational geomechanics, specifically regarding the Mohr-Coulomb (MC) and Drucker–Prager (DP) yield criteria. The problem is well-posed, objective, and provides all necessary data and definitions for a unique solution.\n\nThe solution is implemented by following these steps:\n\n1.  **Mohr-Coulomb (MC) Meridians**: The problem defines the MC yield condition in the $p$-$q$ stress invariant space, where $p$ is the mean stress and $q$ is the deviatoric stress measure $q=\\sqrt{3J_2}$. The yield loci for axisymmetric triaxial compression (TXC, Lode angle $\\theta = -30^\\circ$) and triaxial extension (TXE, Lode angle $\\theta = +30^\\circ$) are given by:\n    $$\n    q_{\\mathrm{MC,TXC}}(p;c,\\phi) = M_c(\\phi)\\, p + K_c(c,\\phi)\n    $$\n    $$\n    q_{\\mathrm{MC,TXE}}(p;c,\\phi) = M_e(\\phi)\\, p + K_e(c,\\phi)\n    $$\n    The parameters are functions of the material's cohesion $c$ and internal friction angle $\\phi$:\n    $$\n    M_c(\\phi) = \\frac{6 \\sin\\phi}{3 - \\sin\\phi}, \\quad K_c(c,\\phi) = \\frac{6 c \\cos\\phi}{3 - \\sin\\phi}\n    $$\n    $$\n    M_e(\\phi) = \\frac{6 \\sin\\phi}{3 + \\sin\\phi}, \\quad K_e(c,\\phi) = \\frac{6 c \\cos\\phi}{3 + \\sin\\phi}\n    $$\n    All angle inputs $\\phi$ are in degrees and are converted to radians for trigonometric calculations.\n\n2.  **Drucker-Prager (DP) Meridian Fitting**: The DP model is a Lode angle-independent (conical) yield surface, represented by a single line in the $p$-$q$ plane:\n    $$\n    q_{\\mathrm{DP}}(p;\\,M_{\\mathrm{DP}},K_{\\mathrm{DP}}) = M_{\\mathrm{DP}}\\, p + K_{\\mathrm{DP}}\n    $$\n    To relate DP to MC, its parameters $M_{\\mathrm{DP}}$ and $K_{\\mathrm{DP}}$ are determined by a least-squares fit to the two MC meridians over a mean stress interval $p \\in [0, P_{\\mathrm{fit}}]$. The objective is to minimize the integrated sum of squared residuals:\n    $$\n    J(M_{\\mathrm{DP}}, K_{\\mathrm{DP}}) = \\int_{0}^{P_{\\mathrm{fit}}} \\left[ (q_{\\mathrm{DP}} - q_{\\mathrm{MC,TXC}})^2 + (q_{\\mathrm{DP}} - q_{\\mathrm{MC,TXE}})^2 \\right] dp\n    $$\n    Minimizing $J$ with respect to $M_{\\mathrm{DP}}$ and $K_{\\mathrm{DP}}$ by setting the partial derivatives to zero, $\\frac{\\partial J}{\\partial M_{\\mathrm{DP}}} = 0$ and $\\frac{\\partial J}{\\partial K_{\\mathrm{DP}}} = 0$, yields a system of linear equations for the optimal parameters. The solution to this system is elegantly simple:\n    $$\n    M_{\\mathrm{DP}} = \\frac{M_c(\\phi) + M_e(\\phi)}{2}\n    $$\n    $$\n    K_{\\mathrm{DP}} = \\frac{K_c(c,\\phi) + K_e(c,\\phi)}{2}\n    $$\n    This result shows that the best-fit DP meridian is the average of the MC compression and extension meridians. Crucially, the optimal parameters $M_{\\mathrm{DP}}$ and $K_{\\mathrm{DP}}$ are independent of the fitting interval endpoint $P_{\\mathrm{fit}}$, which is thus a contextual parameter rather than a computational one in this specific formulation.\n\n3.  **Strength Reduction Method (SRM)**: The core of SRM is the progressive reduction of the material's shear strength parameters by a Strength Reduction Factor, $S$:\n    $$\n    c_R(S) = \\frac{c}{S}, \\quad \\phi_R(S) = \\arctan\\left(\\frac{\\tan\\phi}{S}\\right)\n    $$\n    The predicted SRF for a given stress state $(p, q_d, \\theta)$ is the value of $S$ for which the reduced-strength yield surface passes exactly through that stress point.\n\n4.  **Solving for SRF**: We must find the SRF values, $S_{\\mathrm{MC}}$ and $S_{\\mathrm{DP}}$, by solving two separate non-linear equations.\n    -   For the MC model, the specific meridian (TXC or TXE) is chosen based on the Lode angle $\\theta$. The equation to solve for $S_{\\mathrm{MC}}$ is:\n        $$\n        f_{\\mathrm{MC}}(S) = q_{\\mathrm{MC}}(p; c_R(S), \\phi_R(S), \\theta) - q_d = 0\n        $$\n    -   For the fitted DP model, the equation to solve for $S_{\\mathrm{DP}}$ is:\n        $$\n        f_{\\mathrm{DP}}(S) = q_{\\mathrm{DP}}(p; c_R(S), \\phi_R(S)) - q_d = 0\n        $$\n        where the parameters $M_{\\mathrm{DP}}$ and $K_{\\mathrm{DP}}$ are themselves functions of the reduced strength parameters $c_R(S)$ and $\\phi_R(S)$.\n\n5.  **Numerical Solution and Error Calculation**: The functions $f_{\\mathrm{MC}}(S)$ and $f_{\\mathrm{DP}}(S)$ are monotonically decreasing with $S$ for $S>0$. This property guarantees a unique root and allows for the use of a robust numerical root-finding algorithm. Brent's method (`scipy.optimize.brentq`) is employed, which requires bracketing the root. A suitable bracket $[a, b]$ is one where $f(a)$ and $f(b)$ have opposite signs. Given the monotonic nature, a wide bracket such as $[0.1, 20]$ is sufficient to find the solution for standard geotechnical problems. After solving for $S_{\\mathrm{MC}}$ and $S_{\\mathrm{DP}}$, the relative error $E$ is computed as:\n    $$\n    E = \\frac{S_{\\mathrm{DP}}}{S_{\\mathrm{MC}}} - 1\n    $$\nThis error quantifies the discrepancy in the predicted factor of safety when a Lode-angle-dependent model (MC) is approximated by a Lode-angle-independent one (DP) fitted in this manner.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Implements the full validation and solution logic as required.\n    \"\"\"\n\n    # --- Physics / Constitutive Model Functions ---\n    def get_mc_meridian_params(c, phi_deg):\n        \"\"\"\n        Calculates the parameters for Mohr-Coulomb triaxial compression (TXC)\n        and triaxial extension (TXE) meridians in p-q space.\n\n        Args:\n            c (float): Cohesion in kPa.\n            phi_deg (float): Friction angle in degrees.\n\n        Returns:\n            tuple: A tuple (M_c, K_c, M_e, K_e) of meridian parameters.\n        \"\"\"\n        phi_rad = np.deg2rad(phi_deg)\n        sin_phi = np.sin(phi_rad)\n        cos_phi = np.cos(phi_rad)\n        \n        den_c = 3.0 - sin_phi\n        den_e = 3.0 + sin_phi\n        \n        # Avoid division by zero if phi is exactly 90 degrees\n        if np.isclose(den_c, 0):\n            den_c = 1e-12\n        \n        # TXC parameters\n        M_c = (6.0 * sin_phi) / den_c\n        K_c = (6.0 * c * cos_phi) / den_c\n        \n        # TXE parameters\n        M_e = (6.0 * sin_phi) / den_e\n        K_e = (6.0 * c * cos_phi) / den_e\n        \n        return M_c, K_c, M_e, K_e\n\n    # --- Core SRF Functions ---\n    def get_reduced_strength(c, phi_deg, S):\n        \"\"\"\n        Applies the Strength Reduction Factor (SRF) S to the strength parameters.\n        \n        Args:\n            c (float): Original cohesion.\n            phi_deg (float): Original friction angle in degrees.\n            S (float): Strength Reduction Factor.\n\n        Returns:\n            tuple: A tuple (c_R, phi_R_deg) of reduced strength parameters.\n        \"\"\"\n        if S <= 0:\n            return np.inf, 90.0\n        \n        c_R = c / S\n        \n        if np.isclose(phi_deg, 0.0):\n            phi_R_deg = 0.0\n        else:\n            tan_phi = np.tan(np.deg2rad(phi_deg))\n            phi_R_deg = np.rad2deg(np.arctan(tan_phi / S))\n            \n        return c_R, phi_R_deg\n\n    def calculate_srf_error(c, phi_deg, p, q_d, theta_deg):\n        \"\"\"\n        Solves for S_mc and S_dp, then computes the relative error E.\n        The P_fit parameter is noted to be redundant for the calculation itself.\n        \"\"\"\n        \n        # Objective function for Mohr-Coulomb SRF.\n        # This is the residual: q_yield(S) - q_d\n        def f_mc(S):\n            c_R, phi_R_deg = get_reduced_strength(c, phi_deg, S)\n            M_c, K_c, M_e, K_e = get_mc_meridian_params(c_R, phi_R_deg)\n            \n            if theta_deg < 0:  # Triaxial Compression\n                q_yield = M_c * p + K_c\n            else:  # Triaxial Extension\n                q_yield = M_e * p + K_e\n            \n            return q_yield - q_d\n            \n        # Objective function for Drucker-Prager SRF.\n        def f_dp(S):\n            c_R, phi_R_deg = get_reduced_strength(c, phi_deg, S)\n            M_c, K_c, M_e, K_e = get_mc_meridian_params(c_R, phi_R_deg)\n            \n            # DP parameters are the average of MC TXC and TXE parameters\n            M_dp = (M_c + M_e) / 2.0\n            K_dp = (K_c + K_e) / 2.0\n            \n            q_yield = M_dp * p + K_dp\n            \n            return q_yield - q_d\n\n        # A robust bracket for the root-finding algorithm.\n        # f(S) is monotonic, so a root is guaranteed if a solution exists.\n        s_min, s_max = 0.1, 50.0\n\n        try:\n             s_mc = brentq(f_mc, s_min, s_max, xtol=1e-9, rtol=1e-9)\n             s_dp = brentq(f_dp, s_min, s_max, xtol=1e-9, rtol=1e-9)\n        except ValueError:\n            # This would occur if the root is not bracketed, indicating an\n            # issue with the problem spec (e.g., q_d outside physical limits).\n            # For the given test cases, this should not happen.\n            return np.nan\n\n        error = s_dp / s_mc - 1.0\n        return error\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (c [kPa], phi [deg], p [kPa], theta [deg], q_d [kPa], P_fit [kPa])\n        (20.0, 35.0, 150.0, -30.0, 220.0, 150.0),\n        (20.0, 35.0, 150.0, 30.0, 160.0, 150.0),\n        (5.0, 20.0, 50.0, -30.0, 40.0, 50.0),\n        (0.0, 45.0, 100.0, 30.0, 90.0, 100.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        c, phi, p, theta, q_d, _ = case # P_fit is unused in the calculation\n        result = calculate_srf_error(c, phi, p, q_d, theta)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3560689"}]}