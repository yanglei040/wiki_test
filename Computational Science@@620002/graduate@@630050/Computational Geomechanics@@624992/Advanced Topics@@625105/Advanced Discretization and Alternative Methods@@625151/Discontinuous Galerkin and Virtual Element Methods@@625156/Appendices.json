{"hands_on_practices": [{"introduction": "A crucial first step in evaluating any numerical method for wave propagation problems is to perform a dispersion analysis. This exercise provides hands-on practice with this fundamental technique, comparing how the choice of numerical flux in a Discontinuous Galerkin scheme affects the propagation of waves [@problem_id:3518428]. By deriving the numerical phase speed, you will gain insight into the accuracy and dissipative properties of central versus upwind fluxes, which is essential for building robust simulation tools for elastodynamics.", "problem": "Consider small-amplitude longitudinal waves in a homogeneous, one-dimensional elastic bar governed by the first-order symmetric hyperbolic form of linear elastodynamics:\n- Momentum balance: $\\rho\\, v_{t} = \\sigma_{x}$,\n- Kinematics and constitutive law: $\\sigma_{t} = E\\, v_{x}$,\nwhere $v(x,t)$ is the particle velocity, $\\sigma(x,t)$ is the axial stress, $\\rho$ is the mass density, and $E$ is Young’s modulus. The wave speed is $c = \\sqrt{E/\\rho}$. Write the system as $q_{t} + B\\, q_{x} = 0$ with $q = \\begin{pmatrix} v \\\\ \\sigma \\end{pmatrix}$ and $B = \\begin{pmatrix} 0 & -\\rho^{-1} \\\\ -E & 0 \\end{pmatrix}$.\n\nDiscretize the spatial domain with a uniform mesh of size $h$ and periodic boundary conditions. Use a discontinuous Galerkin (DG) method with polynomial degree $k=0$ (piecewise constants in each cell). Let $I_{j}$ denote the $j$-th cell, and let $q_{j}(t)$ be the cell-average of $q$ over $I_{j}$. The semi-discrete DG scheme reads\n$$\nh\\, \\frac{d q_{j}}{dt} + \\widehat{f}\\!\\left(q_{j}^{-}, q_{j+1}^{+}\\right) - \\widehat{f}\\!\\left(q_{j-1}^{-}, q_{j}^{+}\\right) = 0,\n$$\nwhere the numerical flux $\\widehat{f}$ approximates the physical flux $f(q) = B\\, q$ at cell interfaces. Consider two standard choices:\n- Central flux: $\\widehat{f}_{\\mathrm{c}}(q^{-},q^{+}) = \\tfrac{1}{2}\\, B\\, (q^{-} + q^{+})$,\n- Upwind (exact Riemann) flux: $\\widehat{f}_{\\mathrm{u}}(q^{-},q^{+}) = B^{+} q^{-} + B^{-} q^{+}$, where $B = R \\Lambda R^{-1}$ is the eigendecomposition with $\\Lambda = \\mathrm{diag}(\\lambda_{1}, \\lambda_{2}) = \\mathrm{diag}(c,-c)$ and $B^{\\pm} = R\\, \\Lambda^{\\pm} R^{-1}$, $\\Lambda^{+} = \\mathrm{diag}(c,0)$, $\\Lambda^{-} = \\mathrm{diag}(0,-c)$.\n\nAssume a Bloch wave ansatz $q_{j}(t) = \\widehat{q}\\, \\exp\\!\\left( \\mathrm{i}\\, j\\, \\theta - \\mathrm{i}\\, \\omega\\, t \\right)$ with nondimensional wavenumber $\\theta = \\kappa h$, where $\\kappa$ is the physical wavenumber. For each flux choice, compute the semi-discrete numerical dispersion relation $\\omega(\\theta)$ and then define the normalized numerical phase speed as\n$$\n\\frac{c_{\\mathrm{p, num}}}{c} = \\frac{|\\Re(\\omega(\\theta))|}{c\\, \\kappa} = \\frac{h\\, |\\Re(\\omega(\\theta))|}{c\\, \\theta}.\n$$\n\nPerform a Taylor expansion of $\\dfrac{c_{\\mathrm{p, num}}}{c}$ about $\\theta = 0$ of the form\n$$\n\\frac{c_{\\mathrm{p, num}}}{c} = 1 - \\alpha\\, \\theta^{2} + \\mathcal{O}(\\theta^{4}),\n$$\nand determine the coefficient $\\alpha$ for:\n- the central flux, and\n- the upwind flux.\n\nGive your final answer as a single row matrix containing the two exact coefficients $\\alpha$ (central first, upwind second). No rounding is required.", "solution": "We begin from the first-order symmetric hyperbolic system for a homogeneous one-dimensional elastic bar:\n$$\nq_{t} + B\\, q_{x} = 0, \\quad q = \\begin{pmatrix} v \\\\ \\sigma \\end{pmatrix}, \\quad B = \\begin{pmatrix} 0 & -\\rho^{-1} \\\\ -E & 0 \\end{pmatrix}.\n$$\nThe eigenvalues of $B$ are $\\lambda_{1} = c$ and $\\lambda_{2} = -c$, where $c = \\sqrt{E/\\rho}$. This can be verified by computing $\\det(\\lambda I - B) = \\lambda^{2} - E/\\rho = \\lambda^{2} - c^{2}$, so $\\lambda = \\pm c$.\n\nWe discretize the spatial domain into a uniform mesh of cells $\\{I_{j}\\}$ of size $h$. Using a discontinuous Galerkin method with polynomial degree $k=0$ (piecewise constants per cell) and periodic boundary conditions, the semi-discrete balance over cell $I_{j}$ with test function equal to the constant $1$ yields\n$$\nh\\, \\frac{d q_{j}}{dt} + \\widehat{f}\\!\\left(q_{j}^{-}, q_{j+1}^{+}\\right) - \\widehat{f}\\!\\left(q_{j-1}^{-}, q_{j}^{+}\\right) = 0,\n$$\nwhere $\\widehat{f}$ is the numerical flux approximating $f(q) = B q$ at interfaces $x_{j \\pm 1/2}$, and superscripts $-$ and $+$ denote traces from the left and right, respectively. For $k=0$, $q_{j}^{-} = q_{j}^{+} = q_{j}$.\n\nWe adopt a Bloch wave ansatz:\n$$\nq_{j}(t) = \\widehat{q}\\, \\exp\\!\\left(\\mathrm{i}\\, j\\, \\theta - \\mathrm{i}\\, \\omega\\, t\\right), \\quad \\theta = \\kappa h,\n$$\nso that $q_{j+1} = e^{\\mathrm{i}\\theta}\\, q_{j}$ and $q_{j-1} = e^{-\\mathrm{i}\\theta}\\, q_{j}$. Substituting this ansatz into the semi-discrete scheme yields the algebraic eigenproblem that defines the numerical dispersion relation $\\omega(\\theta)$ for each flux choice.\n\nCentral flux. For the central flux,\n$$\n\\widehat{f}_{\\mathrm{c}}(q_{j}, q_{j+1}) = \\tfrac{1}{2}\\, B\\, (q_{j} + q_{j+1}) = \\tfrac{1}{2}\\, B\\, (1 + e^{\\mathrm{i}\\theta})\\, q_{j},\n$$\nand\n$$\n\\widehat{f}_{\\mathrm{c}}(q_{j-1}, q_{j}) = \\tfrac{1}{2}\\, B\\, (q_{j-1} + q_{j}) = \\tfrac{1}{2}\\, B\\, (e^{-\\mathrm{i}\\theta} + 1)\\, q_{j}.\n$$\nTherefore,\n$$\nh\\, \\frac{d q_{j}}{dt} + \\tfrac{1}{2}\\, B\\, \\big[(1 + e^{\\mathrm{i}\\theta}) - (e^{-\\mathrm{i}\\theta} + 1)\\big]\\, q_{j} = 0\n\\;\\;\\Longrightarrow\\;\\;\n- \\mathrm{i}\\, \\omega\\, h\\, q_{j} + \\mathrm{i}\\, B\\, \\sin\\theta\\, q_{j} = 0.\n$$\nThus the eigenvalues of the discrete spatial operator are those of $B$ multiplied by $\\sin\\theta$, and the numerical dispersion relation is\n$$\n\\omega_{\\mathrm{c}}(\\theta) = \\pm \\frac{c}{h}\\, \\sin\\theta.\n$$\nThe normalized numerical phase speed is\n$$\n\\frac{c_{\\mathrm{p, num}}}{c} = \\frac{|\\Re(\\omega_{\\mathrm{c}})|}{c\\, \\kappa} = \\frac{(c/h)\\, |\\sin\\theta|}{c\\, \\kappa} = \\frac{\\sin\\theta}{\\theta},\n$$\nwhere we used $\\kappa = \\theta/h$ and consider $0 \\le \\theta \\le \\pi$ so that $\\sin\\theta \\ge 0$. Expanding for small $\\theta$,\n$$\n\\sin\\theta = \\theta - \\frac{\\theta^{3}}{3!} + \\frac{\\theta^{5}}{5!} - \\cdots,\n$$\nyields\n$$\n\\frac{c_{\\mathrm{p, num}}}{c} = \\frac{\\sin\\theta}{\\theta} = 1 - \\frac{\\theta^{2}}{3!} + \\frac{\\theta^{4}}{5!} - \\cdots = 1 - \\frac{1}{6}\\, \\theta^{2} + \\mathcal{O}(\\theta^{4}).\n$$\nTherefore, for the central flux, $\\alpha_{\\mathrm{c}} = \\frac{1}{6}$.\n\nUpwind flux. For the upwind (exact Riemann) flux, write $B = R \\Lambda R^{-1}$ with $\\Lambda = \\mathrm{diag}(c,-c)$ and define $B^{\\pm} = R \\Lambda^{\\pm} R^{-1}$, where $\\Lambda^{+} = \\mathrm{diag}(c,0)$ and $\\Lambda^{-} = \\mathrm{diag}(0,-c)$. Then\n$$\n\\widehat{f}_{\\mathrm{u}}(q_{j}, q_{j+1}) = B^{+} q_{j} + B^{-} q_{j+1} = \\big(B^{+} + B^{-} e^{\\mathrm{i}\\theta}\\big)\\, q_{j},\n$$\nand\n$$\n\\widehat{f}_{\\mathrm{u}}(q_{j-1}, q_{j}) = B^{+} q_{j-1} + B^{-} q_{j} = \\big(B^{+} e^{-\\mathrm{i}\\theta} + B^{-}\\big)\\, q_{j}.\n$$\nHence the semi-discrete equation becomes\n$$\n- \\mathrm{i}\\, \\omega\\, h\\, q_{j} + \\Big[B^{+}\\big(1 - e^{-\\mathrm{i}\\theta}\\big) + B^{-}\\big(e^{\\mathrm{i}\\theta} - 1\\big)\\Big]\\, q_{j} = 0.\n$$\nDiagonalize in characteristic variables $w = R^{-1} q$, so that the above reduces to two uncoupled scalar relations for the right- and left-going characteristic fields $w_{+}$ and $w_{-}$:\n- For the $+$ field with speed $+c$:\n$$\n- \\mathrm{i}\\, \\omega\\, h + c \\big(1 - e^{-\\mathrm{i}\\theta}\\big) = 0\n\\;\\;\\Longrightarrow\\;\\;\n\\omega_{+}(\\theta) = \\mathrm{i}\\, \\frac{c}{h}\\, \\big(1 - e^{-\\mathrm{i}\\theta}\\big) = - \\frac{c}{h}\\, \\sin\\theta + \\mathrm{i}\\, \\frac{c}{h}\\, \\big(1 - \\cos\\theta\\big).\n$$\n- For the $-$ field with speed $-c$:\n$$\n- \\mathrm{i}\\, \\omega\\, h - c \\big(e^{\\mathrm{i}\\theta} - 1\\big) = 0\n\\;\\;\\Longrightarrow\\;\\;\n\\omega_{-}(\\theta) = - \\mathrm{i}\\, \\frac{c}{h}\\, \\big(e^{\\mathrm{i}\\theta} - 1\\big) = \\frac{c}{h}\\, \\sin\\theta + \\mathrm{i}\\, \\frac{c}{h}\\, \\big(1 - \\cos\\theta\\big).\n$$\nBoth branches share the same real part magnitude,\n$$\n|\\Re(\\omega_{\\mathrm{u}}(\\theta))| = \\frac{c}{h}\\, \\sin\\theta,\n$$\nand possess nonnegative imaginary part $\\Im(\\omega_{\\mathrm{u}}(\\theta)) = \\frac{c}{h}\\, (1 - \\cos\\theta)$, reflecting numerical dissipation. The normalized numerical phase speed, defined via the real part, is therefore identical in magnitude to the central-flux case:\n$$\n\\frac{c_{\\mathrm{p, num}}}{c} = \\frac{h\\, |\\Re(\\omega_{\\mathrm{u}}(\\theta))|}{c\\, \\theta} = \\frac{\\sin\\theta}{\\theta} = 1 - \\frac{1}{6}\\, \\theta^{2} + \\mathcal{O}(\\theta^{4}).\n$$\nTherefore, for the upwind flux, $\\alpha_{\\mathrm{u}} = \\frac{1}{6}$.\n\nConclusion. For the piecewise-constant ($k=0$) discontinuous Galerkin discretization of the one-dimensional elastic bar with uniform mesh size $h$, both the central and upwind numerical fluxes yield the same leading-order dispersion error coefficient in the small-$\\theta$ expansion of the normalized phase speed,\n$$\n\\frac{c_{\\mathrm{p, num}}}{c} = 1 - \\alpha\\, \\theta^{2} + \\mathcal{O}(\\theta^{4}), \\quad \\alpha_{\\mathrm{c}} = \\alpha_{\\mathrm{u}} = \\frac{1}{6}.\n$$\nThe upwind flux additionally introduces numerical dissipation through the nonzero imaginary part of $\\omega(\\theta)$, but this does not alter the leading-order dispersion coefficient derived from the real part.", "answer": "$$\\boxed{\\begin{pmatrix} \\frac{1}{6} & \\frac{1}{6} \\end{pmatrix}}$$", "id": "3518428"}, {"introduction": "The ability to handle complex, non-conforming geometries is a key advantage of the Virtual Element Method (VEM), making it particularly well-suited for geomechanical problems involving fractures. This practice moves from abstract theory to concrete application by guiding you through the implementation of a VEM stiffness matrix and its coupling with a cohesive interface element to model a discrete fracture [@problem_id:3518433]. Completing this exercise will build practical skills in coding VEM from its core principles and applying it to a physically relevant scenario.", "problem": "Consider a two-dimensional scalar anti-plane shear model for a homogeneous, isotropic rock domain where the out-of-plane displacement field is denoted by $u$. The elastic energy in the absence of fractures is represented by the bilinear form on the Sobolev space $H^1(\\Omega)$,\n$$\na(u,v) = \\int_{\\Omega} \\mu \\, \\nabla u \\cdot \\nabla v \\, d\\Omega,\n$$\nwhere $\\mu$ is a positive shear modulus taken as a dimensionless constant for normalization. A fracture is treated as a lower-dimensional interface $\\Gamma$ over which displacement may be discontinuous. A cohesive energy penalizes the jump $[u]$ across $\\Gamma$, leading to an additional bilinear form\n$$\nc(u,v) = \\int_{\\Gamma} \\kappa \\, [u] \\,[v] \\, ds,\n$$\nwhere $\\kappa \\ge 0$ is a dimensionless interface stiffness parameter and $[u]$ denotes the jump in $u$ from the left side of $\\Gamma$ to the right side. This setup is compatible with a Discontinuous Galerkin (DG) representation for the interface and a Virtual Element Method (VEM) representation in the bulk.\n\nUse the lowest-order Virtual Element Method (VEM) on polygonal elements to discretize the bulk bilinear form. For each polygonal element $E$ with $N$ vertices $\\{\\boldsymbol{x}_i\\}_{i=1}^N$ in counterclockwise order and area $|E|$, define the consistent VEM stiffness contribution\n$$\n\\boldsymbol{K}^{\\text{cons}}_E = |E| \\, \\boldsymbol{G}_E^\\top \\boldsymbol{G}_E,\n$$\nwhere the $2 \\times N$ matrix $\\boldsymbol{G}_E$ has columns\n$$\n\\boldsymbol{g}_i = \\frac{1}{|E|} \\left( \\frac{1}{2} \\left( \\ell_{i-1} \\boldsymbol{n}_{i-1} + \\ell_i \\boldsymbol{n}_i \\right) \\right), \\quad i=1,\\dots,N,\n$$\nwith $\\ell_i$ the length of edge $i$ and $\\boldsymbol{n}_i$ its outward unit normal (indices modulo $N$). Augment the consistent term with a stabilization that controls the non-polynomial component of the VEM space. Let $\\boldsymbol{R}_E$ be the $N \\times 2$ matrix whose $i$-th row is $\\boldsymbol{x}_i - \\boldsymbol{x}_c$, where $\\boldsymbol{x}_c$ is the centroid of $E$, and let $\\boldsymbol{1}$ be the $N$-vector of ones. Define\n$$\n\\boldsymbol{c}_E = \\frac{1}{N} \\boldsymbol{R}_E^\\top \\boldsymbol{1}, \\quad \\boldsymbol{P}_E = \\frac{1}{N} \\boldsymbol{1}\\boldsymbol{1}^\\top + \\left( \\boldsymbol{R}_E - \\boldsymbol{1}\\boldsymbol{c}_E^\\top \\right) \\boldsymbol{G}_E.\n$$\nUsing a positive stabilization parameter $\\tau_E$, the VEM stabilization is\n$$\n\\boldsymbol{K}^{\\text{stab}}_E = \\tau_E \\, (\\boldsymbol{I} - \\boldsymbol{P}_E)^\\top (\\boldsymbol{I} - \\boldsymbol{P}_E),\n$$\nand the element stiffness is\n$$\n\\boldsymbol{K}_E = \\boldsymbol{K}^{\\text{cons}}_E + \\boldsymbol{K}^{\\text{stab}}_E.\n$$\n\nRepresent the fracture as a polyline $\\Gamma$ that coincides with the common edge between two adjacent polygonal elements, and discretize $c(u,v)$ using a symmetric interior penalty jump functional consistent with linear shape functions along the interface. For a single straight interface segment of length $L$ with two nodes per side, and local nodal jump vector ordering $[u_{L,1}, u_{L,2}, u_{R,1}, u_{R,2}]$, the interface element stiffness is\n$$\n\\boldsymbol{K}_\\Gamma = \\kappa L \\begin{bmatrix}\n\\frac{1}{3} & \\frac{1}{6} & -\\frac{1}{3} & -\\frac{1}{6} \\\\\n\\frac{1}{6} & \\frac{1}{3} & -\\frac{1}{6} & -\\frac{1}{3} \\\\\n-\\frac{1}{3} & -\\frac{1}{6} & \\frac{1}{3} & \\frac{1}{6} \\\\\n-\\frac{1}{6} & -\\frac{1}{3} & \\frac{1}{6} & \\frac{1}{3}\n\\end{bmatrix}.\n$$\n\nConstruct a unit square domain $[0,1] \\times [0,1]$ partitioned into two convex quadrilaterals:\n- Left element $E_L$ with vertices $(0,0), (0.5,0), (0.5,1), (0,1)$ in counterclockwise order.\n- Right element $E_R$ with vertices $(0.5,0), (1,0), (1,1), (0.5,1)$ in counterclockwise order.\n\nTreat the common vertical edge at $x=0.5$ as the fracture interface $\\Gamma$. To allow a displacement jump across $\\Gamma$, do not merge the degrees of freedom (DOFs) at the interface between the two elements when assembling the global matrix; instead, keep separate DOFs per side and couple them only through $\\boldsymbol{K}_\\Gamma$.\n\nImpose homogeneous Dirichlet boundary conditions $u=0$ on the external boundary vertices at $x=0$ and $x=1$ (namely, $(0,0), (0,1), (1,0), (1,1)$), by eliminating the corresponding DOFs from the global system. All quantities are dimensionless.\n\nImplement a program that:\n1. Constructs $\\boldsymbol{K}_{E_L}$ and $\\boldsymbol{K}_{E_R}$ via the VEM formulas above for order-one VEM using the given polygonal geometries.\n2. Assembles the global stiffness matrix with separate DOFs on the fracture interface and adds the interface contribution $\\boldsymbol{K}_\\Gamma$ with the ordering $[u_{L, \\text{bottom}}, u_{L, \\text{top}}, u_{R, \\text{bottom}}, u_{R, \\text{top}}]$ corresponding to the nodes $(0.5,0), (0.5,1)$ on each side.\n3. Applies homogeneous Dirichlet boundary conditions by eliminating the boundary DOFs.\n4. Computes the largest eigenvalue of the resulting symmetric positive-definite matrix for each test case.\n\nTest suite:\n- Case 1: $\\kappa = 0.0$, $\\tau_E = 1.0$ for both elements.\n- Case 2: $\\kappa = 10^3$, $\\tau_E = 1.0$ for both elements.\n- Case 3: $\\kappa = 10^6$, $\\tau_E = 1.0$ for both elements.\n- Case 4: $\\kappa = 10^3$, $\\tau_E = 10.0$ for both elements.\n\nYour program should produce a single line of output containing the largest eigenvalues for the four cases as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4]\"). Express all outputs as dimensionless floating-point numbers without units.", "solution": "The problem statement is found to be valid following a meticulous review. It describes a well-posed problem in computational geomechanics, grounded in established principles of elasticity and numerical methods (Virtual Element Method and Discontinuous Galerkin method). The provided formulas, including the interface stiffness matrix $\\boldsymbol{K}_\\Gamma$, and geometric setup are consistent and complete, enabling a unique solution. The shear modulus $\\mu$ is taken as $\\mu=1$ as implied by the normalization statement and the provided VEM stiffness formula.\n\nThe overall approach is to first construct the local stiffness matrices for the two rectangular elements, $E_L$ and $E_R$, using the specified Virtual Element Method (VEM) formulation. Concurrently, the interface stiffness matrix $\\boldsymbol{K}_\\Gamma$ is constructed. These local matrices are then assembled into a global stiffness matrix. Finally, homogeneous Dirichlet boundary conditions are applied by eliminating the degrees of freedom (DOFs) on the external boundary, and the largest eigenvalue of the resulting reduced system matrix is computed.\n\n**1. Discretization and Degrees of Freedom**\n\nThe domain $\\Omega = [0,1] \\times [0,1]$ is partitioned into two rectangular elements:\n- $E_L$: vertices $\\{(0,0), (0.5,0), (0.5,1), (0,1)\\}$\n- $E_R$: vertices $\\{(0.5,0), (1,0), (1,1), (0.5,1)\\}$\n\nDue to the fracture, DOFs on the interface $\\Gamma$ at $x=0.5$ are duplicated. A global numbering system for all $8$ DOFs is established:\n1. $u_1$ at $(0,0)$\n2. $u_2$ at $(0,1)$\n3. $u_3$ at $(0.5,0)$ on element $E_L$ (left side of fracture)\n4. $u_4$ at $(0.5,1)$ on element $E_L$ (left side of fracture)\n5. $u_5$ at $(0.5,0)$ on element $E_R$ (right side of fracture)\n6. $u_6$ at $(0.5,1)$ on element $E_R$ (right side of fracture)\n7. $u_7$ at $(1,0)$\n8. $u_8$ at $(1,1)$\n\nThe local-to-global DOF mapping for element $E_L$ (vertices $(0,0), (0.5,0), (0.5,1), (0,1)$) is $\\{1, 2, 3, 4\\} \\to \\{1, 3, 4, 2\\}$.\nFor element $E_R$ (vertices $(0.5,0), (1,0), (1,1), (0.5,1)$), the mapping is $\\{1, 2, 3, 4\\} \\to \\{5, 7, 8, 6\\}$.\n\n**2. VEM Element Stiffness Matrix Calculation**\n\nWe compute the stiffness matrix $\\boldsymbol{K}_E$ for a representative element, $E_L$. Both elements $E_L$ and $E_R$ are congruent rectangles, so their local stiffness matrices are identical.\n\nFor $E_L$, the vertices are $\\boldsymbol{x}_1=(0,0), \\boldsymbol{x}_2=(0.5,0), \\boldsymbol{x}_3=(0.5,1), \\boldsymbol{x}_4=(0,1)$.\nThe number of vertices is $N=4$. The area is $|E_L| = 0.5 \\times 1 = 0.5$. The centroid is $\\boldsymbol{x}_c = (0.25, 0.5)$.\n\nThe edge lengths and outward normals are:\n- Edge 1: $\\ell_1 = 0.5, \\boldsymbol{n}_1 = (0, -1)$\n- Edge 2: $\\ell_2 = 1.0, \\boldsymbol{n}_2 = (1, 0)$\n- Edge 3: $\\ell_3 = 0.5, \\boldsymbol{n}_3 = (0, 1)$\n- Edge 4: $\\ell_4 = 1.0, \\boldsymbol{n}_4 = (-1, 0)$\n\nThe matrix $\\boldsymbol{G}_E$ has columns $\\boldsymbol{g}_i = \\frac{1}{2|E|} (\\ell_{i-1} \\boldsymbol{n}_{i-1} + \\ell_i \\boldsymbol{n}_i)$. With $|E_L| = 0.5$, the pre-factor $\\frac{1}{2|E_L|}$ is $1$.\n- $\\boldsymbol{g}_1 = \\ell_4\\boldsymbol{n}_4 + \\ell_1\\boldsymbol{n}_1 = 1(-1,0) + 0.5(0,-1) = (-1, -0.5)$\n- $\\boldsymbol{g}_2 = \\ell_1\\boldsymbol{n}_1 + \\ell_2\\boldsymbol{n}_2 = 0.5(0,-1) + 1(1,0) = (1, -0.5)$\n- $\\boldsymbol{g}_3 = \\ell_2\\boldsymbol{n}_2 + \\ell_3\\boldsymbol{n}_3 = 1(1,0) + 0.5(0,1) = (1, 0.5)$\n- $\\boldsymbol{g}_4 = \\ell_3\\boldsymbol{n}_3 + \\ell_4\\boldsymbol{n}_4 = 0.5(0,1) + 1(-1,0) = (-1, 0.5)$\nSo, $\\boldsymbol{G}_{E_L} = \\begin{pmatrix} -1 & 1 & 1 & -1 \\\\ -0.5 & -0.5 & 0.5 & 0.5 \\end{pmatrix}$.\n\nThe consistent stiffness matrix is $\\boldsymbol{K}^{\\text{cons}}_E = |E| \\boldsymbol{G}_E^\\top \\boldsymbol{G}_E$:\n$$ \\boldsymbol{K}^{\\text{cons}}_{E_L} = 0.5 \\begin{pmatrix} -1 & -0.5 \\\\ 1 & -0.5 \\\\ 1 & 0.5 \\\\ -1 & 0.5 \\end{pmatrix} \\begin{pmatrix} -1 & 1 & 1 & -1 \\\\ -0.5 & -0.5 & 0.5 & 0.5 \\end{pmatrix} = \\begin{pmatrix} 0.625 & -0.375 & -0.625 & 0.375 \\\\ -0.375 & 0.625 & 0.375 & -0.625 \\\\ -0.625 & 0.375 & 0.625 & -0.375 \\\\ 0.375 & -0.625 & -0.375 & 0.625 \\end{pmatrix} $$\n\nFor stabilization, we compute the projection matrix $\\boldsymbol{P}_E$.\nThe matrix of centered coordinates is $\\boldsymbol{R}_{E_L} = \\begin{pmatrix} -0.25 & -0.5 \\\\ 0.25 & -0.5 \\\\ 0.25 & 0.5 \\\\ -0.25 & 0.5 \\end{pmatrix}$.\nFor a centrosymmetric polygon, $\\boldsymbol{c}_E = \\frac{1}{N}\\boldsymbol{R}_E^\\top\\boldsymbol{1} = \\boldsymbol{0}$.\nThus, $\\boldsymbol{P}_E = \\frac{1}{N} \\boldsymbol{1}\\boldsymbol{1}^\\top + \\boldsymbol{R}_E \\boldsymbol{G}_E$.\n$$ \\boldsymbol{P}_{E_L} = \\frac{1}{4}\\begin{pmatrix} 1 & 1 & 1 & 1 \\\\ 1 & 1 & 1 & 1 \\\\ 1 & 1 & 1 & 1 \\\\ 1 & 1 & 1 & 1 \\end{pmatrix} + \\begin{pmatrix} 0.5 & 0 & -0.5 & 0 \\\\ 0 & 0.5 & 0 & -0.5 \\\\ -0.5 & 0 & 0.5 & 0 \\\\ 0 & -0.5 & 0 & 0.5 \\end{pmatrix} = \\begin{pmatrix} 0.75 & 0.25 & -0.25 & 0.25 \\\\ 0.25 & 0.75 & 0.25 & -0.25 \\\\ -0.25 & 0.25 & 0.75 & 0.25 \\\\ 0.25 & -0.25 & 0.25 & 0.75 \\end{pmatrix} $$\nThe stabilization matrix is $\\boldsymbol{K}^{\\text{stab}}_E = \\tau_E (\\boldsymbol{I} - \\boldsymbol{P}_E)^\\top (\\boldsymbol{I} - \\boldsymbol{P}_E)$.\n$$ \\boldsymbol{I} - \\boldsymbol{P}_{E_L} = \\begin{pmatrix} 0.25 & -0.25 & 0.25 & -0.25 \\\\ -0.25 & 0.25 & -0.25 & 0.25 \\\\ 0.25 & -0.25 & 0.25 & -0.25 \\\\ -0.25 & 0.25 & -0.25 & 0.25 \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ -1 \\\\ 1 \\\\ -1 \\end{pmatrix} \\begin{pmatrix} 0.25 & -0.25 & 0.25 & -0.25 \\end{pmatrix} $$\n$$ \\boldsymbol{K}^{\\text{stab}}_{E_L} = \\tau_E \\begin{pmatrix} 0.25 \\\\ -0.25 \\\\ 0.25 \\\\ -0.25 \\end{pmatrix} (4) \\begin{pmatrix} 0.25 & -0.25 & 0.25 & -0.25 \\end{pmatrix} = \\tau_E \\begin{pmatrix} 0.25 & -0.25 & 0.25 & -0.25 \\\\ -0.25 & 0.25 & -0.25 & 0.25 \\\\ 0.25 & -0.25 & 0.25 & -0.25 \\\\ -0.25 & 0.25 & -0.25 & 0.25 \\end{pmatrix} $$\nThe total element stiffness is $\\boldsymbol{K}_E = \\boldsymbol{K}^{\\text{cons}}_E + \\boldsymbol{K}^{\\text{stab}}_E$.\n\n**3. Interface Stiffness Matrix**\n\nThe fracture $\\Gamma$ has length $L=1$. The DOFs involved are $\\{u_3, u_4, u_5, u_6\\}$, corresponding to $\\{u_{L, \\text{bottom}}, u_{L, \\text{top}}, u_{R, \\text{bottom}}, u_{R, \\text{top}}\\}$. The interface stiffness matrix is:\n$$ \\boldsymbol{K}_\\Gamma = \\kappa (1) \\begin{bmatrix}\n\\frac{1}{3} & \\frac{1}{6} & -\\frac{1}{3} & -\\frac{1}{6} \\\\\n\\frac{1}{6} & \\frac{1}{3} & -\\frac{1}{6} & -\\frac{1}{3} \\\\\n-\\frac{1}{3} & -\\frac{1}{6} & \\frac{1}{3} & \\frac{1}{6} \\\\\n-\\frac{1}{6} & -\\frac{1}{3} & \\frac{1}{6} & \\frac{1}{3}\n\\end{bmatrix} $$\n\n**4. Assembly and Boundary Conditions**\n\nThe global $8 \\times 8$ stiffness matrix is assembled. The homogeneous Dirichlet boundary conditions on DOFs $\\{1, 2, 7, 8\\}$ mean these rows and columns are eliminated. The problem reduces to an eigenvalue problem on the $4 \\times 4$ submatrix corresponding to the free DOFs $\\{3, 4, 5, 6\\}$. This matrix, $\\boldsymbol{K}_{final}$, is obtained by summing the contributions from $E_L$, $E_R$, and $\\Gamma$ for these DOFs.\n\n- The submatrix from $E_L$ affecting DOFs $\\{3,4\\}$ corresponds to local nodes $\\{2,3\\}$ of $\\boldsymbol{K}_{E_L}$.\n- The submatrix from $E_R$ affecting DOFs $\\{5,6\\}$ corresponds to local nodes $\\{1,4\\}$ of $\\boldsymbol{K}_{E_R}$.\n- $\\boldsymbol{K}_\\Gamma$ couples all four DOFs.\n\nLet $\\boldsymbol{A}$ be the $2 \\times 2$ contribution from one bulk element to the interface DOFs. Due to symmetry, this matrix is the same for both elements.\nFor $E_L$, we extract the submatrix for local nodes {2,3}. For $E_R$, for local nodes {1,4}. In both cases, the resulting matrix is:\n$$ \\boldsymbol{A} = \\begin{pmatrix} 0.625+0.25\\tau_E & 0.375-0.25\\tau_E \\\\ 0.375-0.25\\tau_E & 0.625+0.25\\tau_E \\end{pmatrix} $$\nLet $\\boldsymbol{B} = \\kappa \\begin{pmatrix} 1/3 & 1/6 \\\\ 1/6 & 1/3 \\end{pmatrix}$. Then $\\boldsymbol{K}_\\Gamma = \\begin{pmatrix} \\boldsymbol{B} & -\\boldsymbol{B} \\\\ -\\boldsymbol{B} & \\boldsymbol{B} \\end{pmatrix}$.\nThe final $4 \\times 4$ matrix is $\\boldsymbol{K}_{final} = \\begin{pmatrix} \\boldsymbol{A} & \\boldsymbol{0} \\\\ \\boldsymbol{0} & \\boldsymbol{A} \\end{pmatrix} + \\boldsymbol{K}_\\Gamma = \\begin{pmatrix} \\boldsymbol{A}+\\boldsymbol{B} & -\\boldsymbol{B} \\\\ -\\boldsymbol{B} & \\boldsymbol{A}+\\boldsymbol{B} \\end{pmatrix}$.\n\n**5. Eigenvalue Analysis**\n\nThe eigenvalues of this block-circulant matrix are the eigenvalues of $(\\boldsymbol{A}+\\boldsymbol{B}) - \\boldsymbol{B} = \\boldsymbol{A}$ and $(\\boldsymbol{A}+\\boldsymbol{B}) + \\boldsymbol{B} = \\boldsymbol{A}+2\\boldsymbol{B}$.\n\nEigenvalues of $\\boldsymbol{A}$: A $2 \\times 2$ matrix of the form $\\begin{pmatrix} a & b \\\\ b & a \\end{pmatrix}$ has eigenvalues $a+b$ and $a-b$.\n- $\\lambda_1(\\boldsymbol{A}) = (0.625+0.25\\tau_E) + (0.375-0.25\\tau_E) = 1.0$\n- $\\lambda_2(\\boldsymbol{A}) = (0.625+0.25\\tau_E) - (0.375-0.25\\tau_E) = 0.25 + 0.5\\tau_E$\n\nEigenvalues of $\\boldsymbol{A}+2\\boldsymbol{B}$: This matrix has the same structure.\n- $\\lambda_1(\\boldsymbol{A}+2\\boldsymbol{B}) = (a+2\\kappa/3) + (b+2\\kappa/6) = (a+b) + 2\\kappa(1/3+1/6) = 1.0 + \\kappa$\n- $\\lambda_2(\\boldsymbol{A}+2\\boldsymbol{B}) = (a+2\\kappa/3) - (b+2\\kappa/6) = (a-b) + 2\\kappa(1/3-1/6) = 0.25 + 0.5\\tau_E + \\kappa/3$\n\nThe four eigenvalues of $\\boldsymbol{K}_{final}$ are $\\{1.0, \\quad 0.25+0.5\\tau_E, \\quad 1.0+\\kappa, \\quad 0.25+0.5\\tau_E+\\kappa/3 \\}$.\nThe largest eigenvalue is $\\lambda_{\\max} = \\max(1.0+\\kappa, 0.25+0.5\\tau_E+\\kappa/3)$.\n\n**6. Calculation for Test Cases**\n\n- **Case 1:** $\\kappa = 0.0$, $\\tau_E = 1.0$.\n$\\lambda_{\\max} = \\max(1.0+0, 0.25+0.5(1)+0) = \\max(1.0, 0.75) = 1.0$.\n\n- **Case 2:** $\\kappa = 10^3$, $\\tau_E = 1.0$.\n$\\lambda_{\\max} = \\max(1.0+1000, 0.25+0.5(1)+1000/3) = \\max(1001, 0.75+333.33...) = 1001.0$.\n\n- **Case 3:** $\\kappa = 10^6$, $\\tau_E = 1.0$.\n$\\lambda_{\\max} = \\max(1.0+10^6, 0.25+0.5(1)+10^6/3) = \\max(1000001, 0.75+333333.33...) = 1000001.0$.\n\n- **Case 4:** $\\kappa = 10^3$, $\\tau_E = 10.0$.\n$\\lambda_{\\max} = \\max(1.0+1000, 0.25+0.5(10)+1000/3) = \\max(1001, 5.25+333.33...) = 1001.0$.\n\nThese analytical results will be confirmed by the numerical implementation.", "answer": "```python\nimport numpy as np\n\ndef compute_polygon_properties(vertices):\n    \"\"\"Computes area and centroid of a polygon.\"\"\"\n    N = len(vertices)\n    x = vertices[:, 0]\n    y = vertices[:, 1]\n    \n    # Shoelace formula for area\n    area = 0.5 * np.abs(np.dot(x, np.roll(y, -1)) - np.dot(y, np.roll(x, -1)))\n    \n    # Formula for centroid\n    # This calculation is for the general polygon, robust for this problem.\n    sum_val_x = 0\n    sum_val_y = 0\n    for i in range(N):\n        xi, yi = vertices[i]\n        xi1, yi1 = vertices[(i + 1) % N]\n        cross_prod = xi * yi1 - xi1 * yi\n        sum_val_x += (xi + xi1) * cross_prod\n        sum_val_y += (yi + yi1) * cross_prod\n    \n    centroid_x = sum_val_x / (6 * area)\n    centroid_y = sum_val_y / (6 * area)\n    \n    return area, np.array([centroid_x, centroid_y])\n\ndef compute_vem_stiffness(vertices, tau):\n    \"\"\"\n    Computes the lowest-order VEM stiffness matrix for a polygonal element.\n    \"\"\"\n    N = len(vertices)\n    area, centroid = compute_polygon_properties(vertices)\n\n    # Compute edge lengths and normals\n    edges = np.roll(vertices, -1, axis=0) - vertices\n    edge_lengths = np.linalg.norm(edges, axis=1)\n    normals = np.array([edges[:, 1], -edges[:, 0]]).T / edge_lengths[:, np.newaxis]\n\n    # Compute G matrix\n    G = np.zeros((2, N))\n    for i in range(N):\n        i_prev = (i - 1 + N) % N\n        term1 = edge_lengths[i_prev] * normals[i_prev, :]\n        term2 = edge_lengths[i] * normals[i, :]\n        G[:, i] = (1.0 / (2.0 * area)) * (term1 + term2)\n\n    # Consistent stiffness matrix\n    K_cons = area * (G.T @ G)\n    \n    # Stabilization stiffness matrix\n    ones_N = np.ones((N, 1))\n    R = vertices - centroid\n    c = (1.0 / N) * (R.T @ ones_N)\n    \n    # Projector P\n    P = (1.0 / N) * (ones_N @ ones_N.T) + (R - ones_N @ c.T) @ G\n    \n    # Stabilization matrix\n    I = np.identity(N)\n    K_stab = tau * ((I - P).T @ (I - P))\n    \n    return K_cons + K_stab\n\ndef compute_interface_stiffness(kappa, L):\n    \"\"\"\n    Computes the symmetric interior penalty interface stiffness matrix.\n    Note: The problem statement has a typo in the (4,4) entry (3/3). \n    The correct value is 1/3, which is used here for symmetry.\n    \"\"\"\n    M_local = L * np.array([\n        [1/3, 1/6],\n        [1/6, 1/3]\n    ])\n    K_gamma = kappa * np.block([\n        [ M_local, -M_local],\n        [-M_local,  M_local]\n    ])\n    return K_gamma\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    \"\"\"\n    test_cases = [\n        (0.0, 1.0),\n        (10**3, 1.0),\n        (10**6, 1.0),\n        (10**3, 10.0),\n    ]\n\n    # Define geometry and DOF mappings\n    vertices_L = np.array([[0.0, 0.0], [0.5, 0.0], [0.5, 1.0], [0.0, 1.0]])\n    vertices_R = np.array([[0.5, 0.0], [1.0, 0.0], [1.0, 1.0], [0.5, 1.0]])\n    \n    # 0-based indices for assembly\n    # Global DOFs: [0,1,2,3,4,5,6,7] for nodes (0,0), (0,1), (0.5,0)L, (0.5,1)L, (0.5,0)R, (0.5,1)R, (1,0), (1,1)\n    map_L = [0, 2, 3, 1] \n    map_R = [4, 6, 7, 5]\n    \n    # Fracture DOFs: [u_L_bottom, u_L_top, u_R_bottom, u_R_top]\n    # Mapped to global indices [2, 3, 4, 5]\n    map_gamma = [2, 3, 4, 5]\n    \n    # Boundary DOFs to eliminate: (0,0), (0,1), (1,0), (1,1)\n    # Corresponding global indices: [0, 1, 6, 7]\n    free_dofs = [2, 3, 4, 5]\n    \n    fracture_length = 1.0\n\n    results = []\n    for kappa, tau in test_cases:\n        \n        # 1. Compute element stiffness matrices\n        K_L = compute_vem_stiffness(vertices_L, tau)\n        K_R = compute_vem_stiffness(vertices_R, tau)\n\n        # 2. Assemble global stiffness matrix (bulk part)\n        K_global = np.zeros((8, 8))\n        \n        # Assemble K_L\n        for i in range(4):\n            for j in range(4):\n                K_global[map_L[i], map_L[j]] += K_L[i, j]\n        \n        # Assemble K_R\n        for i in range(4):\n            for j in range(4):\n                K_global[map_R[i], map_R[j]] += K_R[i, j]\n\n        # 3. Add interface contribution\n        K_gamma = compute_interface_stiffness(kappa, fracture_length)\n        for i in range(4):\n            for j in range(4):\n                K_global[map_gamma[i], map_gamma[j]] += K_gamma[i, j]\n                \n        # 4. Apply homogeneous Dirichlet BCs by extraction\n        K_final = K_global[np.ix_(free_dofs, free_dofs)]\n        \n        # 5. Compute the largest eigenvalue\n        # eigvalsh is for symmetric matrices and is more efficient\n        eigenvalues = np.linalg.eigvalsh(K_final)\n        largest_eigenvalue = np.max(eigenvalues)\n        results.append(largest_eigenvalue)\n\n    print(f\"[{','.join(f'{r:.7f}' for r in results)}]\")\n\nsolve()\n\n```", "id": "3518433"}, {"introduction": "The practical success of DG and VEM for large-scale simulations hinges on computationally efficient assembly strategies that are amenable to parallelization. This exercise delves into the engine of a modern solver: the face-based parallel assembly using static condensation [@problem_id:3518426]. You will derive the cell-local Schur complement system from first principles and design the data structures and logic needed for a scalable implementation, a vital skill for developing high-performance computational geomechanics software.", "problem": "Develop a complete, runnable program that implements a face-based parallel assembly strategy suitable for Discontinuous Galerkin (DG) and Virtual Element Method (VEM) discretizations on unstructured polygonal meshes, within the scope of computational geomechanics for scalar diffusion. Start from fundamental balance laws and constitutive relations to derive a cell-local elimination (local solve) that produces a Schur complement on face traces, and design data structures to support face-based communication across partitions. The target problem is the steady diffusion model representing Darcy flow in porous media, stated as follows: find a scalar potential $u$ such that $-\\nabla \\cdot (\\kappa \\nabla u) = 0$ in a polygonal domain with Dirichlet boundary data prescribed on the boundary. All quantities are non-dimensional, so report dimensionless values.\n\nYou must implement:\n- A face-based hybrid assembly where unknowns are traces on interior faces (one scalar per face). Boundary faces have prescribed Dirichlet values and are eliminated locally.\n- For each polygonal cell $E$, a local static condensation that eliminates the cell-interior unknown in favor of face traces, yielding a cell-local Schur complement that contributes to the global face system. Use a transmissibility model consistent with a first-order virtual element or mimetic discretization: for a cell $E$ with scalar conductivity $\\kappa_E$, face set $\\mathcal{F}(E)$, face lengths $\\lvert f \\rvert$, and distances $d_{E,f}$ from the cell centroid to face $f$, the face-to-cell flux contributions use the coefficient $T_{E,f} = \\kappa_E \\, \\lvert f \\rvert / d_{E,f}$.\n- A parallel assembly simulation: partition the set of cells among multiple partitions, assemble each partition’s contributions independently using only local cell and face information, and then sum the contributions into a global system. Communication is face-based: interior faces shared by cells in different partitions require summation of their contributions.\n- A serial assembly that assembles the same global system in one pass.\n- Solve the global linear system for the interior face trace unknowns for both serial and parallel assemblies, and compare.\n\nDesign data structures that explicitly encode:\n- A global list of faces with tuples of adjacent cell indices $(c_L, c_R)$, where $-1$ denotes the boundary, face length $\\lvert f \\rvert$, a Boolean flag indicating Dirichlet boundary condition if $c_R = -1$, and the associated Dirichlet value $g$ if a boundary condition is present.\n- A global list of cells with conductivity $\\kappa_E$, a list of incident face indices, and the corresponding list of distances $d_{E,f}$ to each incident face.\n\nDerivation constraints:\n- Start from conservation of mass and Darcy’s law for scalar flow in a porous medium with conductivity $\\kappa$, i.e., $\\boldsymbol{q} = -\\kappa \\nabla u$ and $\\nabla \\cdot \\boldsymbol{q} = 0$.\n- Use a lowest-order virtual element or mimetic finite difference principle to define per-cell transmissibilities $T_{E,f}$ consistent with local flux balances across faces.\n- Derive a cell-local condensed relation (Schur complement) on face traces by eliminating the cell-averaged unknown $u_E$, without using any shortcut formulas or pre-derived expressions not obtained from these principles.\n- Ensure the final assembled global system is symmetric positive definite under the given data.\n\nTest suite:\nImplement your program to run the following three test cases. In all cases, quantities are non-dimensional. Each test case defines faces and cells as described above.\n\n- Test case A (happy path, multi-cell interior communication): Unit square discretized into four equal square cells with side length $0.5$. Faces on the outer boundary are Dirichlet with values: left boundary $g = 1.0$, right boundary $g = 0.0$, bottom boundary $g = 0.0$, top boundary $g = 0.0$. Interior faces have no Dirichlet data. All cell conductivities $\\kappa_E = 1.0$. For each cell, distances to its faces are $0.25$, and all face lengths are $0.5$. The faces and cells are:\n  - Faces: \n    - $f_0$: $(0, -1)$, length $0.5$, Dirichlet $1.0$ \n    - $f_1$: $(0, -1)$, length $0.5$, Dirichlet $0.0$ \n    - $f_2$: $(0, 1)$, length $0.5$, interior \n    - $f_3$: $(0, 2)$, length $0.5$, interior \n    - $f_4$: $(1, -1)$, length $0.5$, Dirichlet $0.0$ \n    - $f_5$: $(1, -1)$, length $0.5$, Dirichlet $0.0$ \n    - $f_6$: $(1, 3)$, length $0.5$, interior \n    - $f_7$: $(2, -1)$, length $0.5$, Dirichlet $1.0$ \n    - $f_8$: $(2, 3)$, length $0.5$, interior \n    - $f_9$: $(2, -1)$, length $0.5$, Dirichlet $0.0$ \n    - $f_{10}$: $(3, -1)$, length $0.5$, Dirichlet $0.0$ \n    - $f_{11}$: $(3, -1)$, length $0.5$, Dirichlet $0.0$\n  - Cells:\n    - Cell $0$: $\\kappa=1.0$, faces $[0, 1, 2, 3]$, distances $[0.25, 0.25, 0.25, 0.25]$\n    - Cell $1$: $\\kappa=1.0$, faces $[2, 4, 5, 6]$, distances $[0.25, 0.25, 0.25, 0.25]$\n    - Cell $2$: $\\kappa=1.0$, faces $[7, 3, 8, 9]$, distances $[0.25, 0.25, 0.25, 0.25]$\n    - Cell $3$: $\\kappa=1.0$, faces $[8, 6, 11, 10]$, distances $[0.25, 0.25, 0.25, 0.25]$\n  - Partition of cells into two partitions for parallel assembly: Partition $0$ has cells $[0, 3]$; Partition $1$ has cells $[1, 2]$.\n\n- Test case B (boundary-dominated edge case): Single square cell with side length $1.0$; all four faces are Dirichlet with values: left $1.0$, right $0.0$, bottom $0.0$, top $0.0$. Conductivity $\\kappa = 1.0$. Face lengths are $1.0$, distances to faces are $0.5$. There are no interior faces, hence there are no unknowns in the global system. Partitioning: a single partition containing the only cell.\n\n- Test case C (ill-conditioning edge case with skew geometry and conductivity contrast): Two adjacent cells sharing a short interior face. Cell $0$ has conductivity $\\kappa = 2.5$, faces with lengths $[1.0, 1.0, 0.2, 1.0]$ and distances $[0.5, 0.5, 0.05, 0.5]$, where the third face is the short interior face. Boundary Dirichlet values on its three boundary faces are $[1.0, 0.0, 0.0]$ in the same order as the boundary faces. Cell $1$ has conductivity $\\kappa = 0.5$, faces with lengths $[0.2, 1.5, 1.0, 1.0]$ and distances $[0.02, 0.7, 0.6, 0.8]$, where the first face is the shared short interior face, and the remaining faces have Dirichlet values $[0.0, 0.0, 0.0]$. The shared interior face is the only unknown. Partitioning: two partitions, each containing one cell.\n\nOutput requirements:\n- For each test case, compute three quantities:\n  1. The Frobenius norm of the difference between the serially assembled global matrix and the parallel-assembled global matrix (a non-negative float).\n  2. The infinity norm of the difference between the corresponding serial and parallel solutions for the interior face traces (a non-negative float; if there are no unknowns, use $0.0$).\n  3. The $2$-norm condition number of the assembled global matrix for the interior face unknowns (a positive float; if there are no unknowns, use $1.0$).\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order $[\\text{A\\_mat\\_diff}, \\text{A\\_sol\\_diff}, \\text{A\\_cond}, \\text{B\\_mat\\_diff}, \\text{B\\_sol\\_diff}, \\text{B\\_cond}, \\text{C\\_mat\\_diff}, \\text{C\\_sol\\_diff}, \\text{C\\_cond}]$.\n\nAll computations are dimensionless. Angles and percentages are not applicable. No user input is required; the program must run \"as is.\"", "solution": "The user requests the development of a program to simulate a face-based parallel assembly for a scalar diffusion problem, based on a discretization akin to a lowest-order Virtual Element Method (VEM) or Mimetic Finite Difference (MFD) method. The core of the task is to derive and implement the cell-local static condensation (Schur complement) and correctly assemble these local contributions into a global system of equations for the unknown potential values on the interior faces of the mesh.\n\n### Derivation from First Principles\n\nThe governing physics is the steady-state diffusion equation, representing Darcy flow, in a domain $\\Omega$:\n$$-\\nabla \\cdot \\boldsymbol{q} = 0 \\quad \\text{in } \\Omega$$\nwhere the flux $\\boldsymbol{q}$ is given by Darcy's law:\n$$\\boldsymbol{q} = -\\kappa \\nabla u$$\nHere, $u$ is the scalar potential and $\\kappa$ is the material conductivity.\n\nWe begin by applying the conservation law to a single polygonal cell (or element) $E$. Integrating the governing equation over $E$ and applying the divergence theorem yields an integral statement of flux conservation:\n$$-\\int_E \\nabla \\cdot \\boldsymbol{q} \\, dV = 0 \\implies \\int_{\\partial E} \\boldsymbol{q} \\cdot \\boldsymbol{n}_E \\, dS = 0$$\nwhere $\\partial E$ is the boundary of the cell and $\\boldsymbol{n}_E$ is the outward-pointing unit normal vector field on $\\partial E$.\n\nThe boundary $\\partial E$ is composed of a set of flat faces, denoted $\\mathcal{F}(E)$. The integral can thus be written as a sum over these faces:\n$$\\sum_{f \\in \\mathcal{F}(E)} \\int_f \\boldsymbol{q} \\cdot \\boldsymbol{n}_{E,f} \\, dS = 0$$\nwhere $\\boldsymbol{n}_{E,f}$ is the outward normal of cell $E$ on face $f$. Let $Q_{E,f}^{\\text{out}} = \\int_f \\boldsymbol{q} \\cdot \\boldsymbol{n}_{E,f} \\, dS$ be the total flux leaving cell $E$ through face $f$. The discrete conservation law for cell $E$ is:\n$$\\sum_{f \\in \\mathcal{F}(E)} Q_{E,f}^{\\text{out}} = 0$$\n\nTo proceed, we need a discrete approximation for the flux $Q_{E,f}^{\\text{out}}$. The problem specifies a lowest-order approximation scheme where each cell $E$ has a single unknown potential $u_E$ (the cell-averaged potential) and each face $f$ has a single unknown potential $u_f$ (the face-averaged potential). The flux leaving cell $E$ through face $f$ is approximated as proportional to the potential difference between the cell center and the face:\n$$Q_{E,f}^{\\text{out}} \\approx T_{E,f} (u_E - u_f)$$\nThe coefficient $T_{E,f}$ is the transmissibility, given as $T_{E,f} = \\kappa_E |f| / d_{E,f}$, where $\\kappa_E$ is the cell's conductivity, $|f|$ is the length of face $f$, and $d_{E,f}$ is the normal distance from the cell centroid to the face.\n\nSubstituting this flux approximation into the discrete conservation law for cell $E$:\n$$\\sum_{f \\in \\mathcal{F}(E)} T_{E,f} (u_E - u_f) = 0$$\nThis equation allows us to perform the requested static condensation. We eliminate the cell-interior unknown $u_E$ by expressing it in terms of the face potentials $\\{u_f\\}_{f \\in \\mathcal{F}(E)}$:\n$$u_E \\sum_{f \\in \\mathcal{F}(E)} T_{E,f} = \\sum_{f \\in \\mathcal{F}(E)} T_{E,f} u_f \\implies u_E = \\frac{\\sum_{f \\in \\mathcal{F}(E)} T_{E,f} u_f}{\\sum_{g \\in \\mathcal{F}(E)} T_{E,g}}$$\nLet $T_E^{\\text{tot}} = \\sum_{g \\in \\mathcal{F}(E)} T_{E,g}$. Then $u_E = \\frac{1}{T_E^{\\text{tot}}} \\sum_{f \\in \\mathcal{F}(E)} T_{E,f} u_f$.\n\nNow, we substitute this expression for $u_E$ back into the flux approximation to obtain a direct relationship between the outgoing fluxes from cell $E$ and the potentials on its faces. For a face $f_i \\in \\mathcal{F}(E)$:\n$$Q_{E,f_i}^{\\text{out}} = T_{E,f_i} (u_E - u_{f_i}) = T_{E,f_i} \\left( \\frac{1}{T_E^{\\text{tot}}} \\sum_{f_j \\in \\mathcal{F}(E)} T_{E,f_j} u_{f_j} - u_{f_i} \\right)$$\n$$Q_{E,f_i}^{\\text{out}} = \\sum_{f_j \\in \\mathcal{F}(E)} \\left( \\frac{T_{E,f_i} T_{E,f_j}}{T_E^{\\text{tot}}} - T_{E,f_i}\\delta_{ij} \\right) u_{f_j}$$\nwhere $\\delta_{ij}$ is the Kronecker delta. This defines the Dirichlet-to-Neumann map for cell $E$, which relates face potentials (Dirichlet data) to face fluxes (Neumann data). This is represented by a matrix $K_E$ whose entries are $(K_E)_{ij} = \\frac{T_{E,f_i} T_{E,f_j}}{T_E^{\\text{tot}}} - T_{E,f_i}\\delta_{ij}$. The vector of outgoing fluxes $\\boldsymbol{Q}_E^{\\text{out}}$ is related to the vector of face potentials $\\boldsymbol{u}_E^{\\text{faces}}$ by $\\boldsymbol{Q}_E^{\\text{out}} = K_E \\boldsymbol{u}_E^{\\text{faces}}$. This matrix $K_E$ is the local Schur complement. It is symmetric and negative semi-definite.\n\n### Global Assembly\n\nThe global system of equations is formed by enforcing flux continuity across all interior faces. For an interior face $f_k$ shared by two cells, $E_L$ and $E_R$, the flux leaving $E_L$ through $f_k$ must be equal and opposite to the flux leaving $E_R$ through $f_k$. That is, $Q_{E_L, f_k}^{\\text{out}} = -Q_{E_R, f_k}^{\\text{out}}$, which gives the assembly condition:\n$$Q_{E_L, f_k}^{\\text{out}} + Q_{E_R, f_k}^{\\text{out}} = 0$$\nIn general, for any interior face $f_k$, the sum of outgoing fluxes from all adjacent cells must be zero: $\\sum_{E \\sim f_k} Q_{E, f_k}^{\\text{out}} = 0$.\n\nSubstituting the Schur complement relation:\n$$\\sum_{E \\sim f_k} \\left( \\sum_{f_j \\in \\mathcal{F}(E)} (K_E)_{kj} u_{f_j} \\right) = 0$$\nThis expression leads to assembling the global matrix from local contributions. However, since each $K_E$ is negative semi-definite, the resulting global matrix will also be negative semi-definite, whereas a standard stiffness matrix for this problem is positive definite. To resolve this, we define a local stiffness contribution matrix $S_E = -K_E$. The entries of $S_E$ are:\n$$(S_E)_{ij} = T_{E,f_i}\\delta_{ij} - \\frac{T_{E,f_i} T_{E,f_j}}{T_E^{\\text{tot}}}$$\nThis matrix $S_E$ is positive semi-definite. Our assembly equation can be rewritten with $S_E$:\n$$\\sum_{E \\sim f_k} \\left( -\\sum_{f_j \\in \\mathcal{F}(E)} (S_E)_{kj} u_{f_j} \\right) = 0 \\implies \\sum_{E \\sim f_k} \\left( \\sum_{f_j \\in \\mathcal{F}(E)} (S_E)_{kj} u_{f_j} \\right) = 0$$\n\nThe final global linear system $A \\boldsymbol{u}_{\\text{int}} = \\boldsymbol{b}$ for the vector of unknown interior face potentials $\\boldsymbol{u}_{\\text{int}}$ is assembled as follows. The global stiffness matrix $A$ is constructed by summing the contributions from all cell-local stiffness matrices $S_E$:\n$$A_{kl} = \\sum_{\\text{cells } E} (S_E)_{kl}$$\nwhere $k$ and $l$ are global indices of interior faces, and $(S_E)_{kl}$ is the entry of the local matrix corresponding to that pair of faces (and is zero if cell $E$ does not contain both faces).\n\nDirichlet boundary conditions are incorporated into the right-hand-side vector $\\boldsymbol{b}$. When a face $f_j$ is a boundary face, its potential $u_{f_j}$ is a known value $g_j$. The term $(S_E)_{kj} u_{f_j} = (S_E)_{kj} g_j$ from the sum is moved to the right-hand side. For each interior face equation for $f_k$:\n$$\\sum_{f_l \\text{ interior}} A_{kl} u_l = -\\sum_{\\text{cells } E} \\sum_{f_j \\in \\mathcal{F}(E) \\text{ boundary}} (S_E)_{kj} g_j$$\nHence, the entry $b_k$ of the global right-hand-side vector is:\n$$b_k = -\\sum_{\\text{cells } E} \\sum_{f_j \\in \\mathcal{F}(E) \\text{ boundary}} (S_E)_{kj} g_j$$\n\n### Parallel Assembly Strategy\n\nThe face-based assembly is naturally parallel. The set of cells is partitioned among processors. Each processor computes the stiffness matrices $S_E$ for its assigned cells. It then assembles these local contributions into a local version of the global matrix $A_p$ and vector $\\boldsymbol{b}_p$. Since a face can be shared by cells on different processors, the final global system is obtained by summing the contributions from all processors: $A = \\sum_p A_p$ and $\\boldsymbol{b} = \\sum_p \\boldsymbol{b}_p$. This summation represents the communication step. The simulation will construct $A$ and $\\boldsymbol{b}$ serially (one partition) and in parallel (multiple partitions) and verify they are identical.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to define, process, and report results for all test cases.\n    \"\"\"\n    # Test Case A: 4-cell square mesh, demonstrating interior face communication.\n    test_case_A = {\n        \"faces\": [\n            {\"adj_cells\": (0, -1), \"length\": 0.5, \"is_dirichlet\": True, \"dirichlet_val\": 1.0},  # f0\n            {\"adj_cells\": (0, -1), \"length\": 0.5, \"is_dirichlet\": True, \"dirichlet_val\": 0.0},  # f1\n            {\"adj_cells\": (0, 1), \"length\": 0.5, \"is_dirichlet\": False, \"dirichlet_val\": None}, # f2 (interior)\n            {\"adj_cells\": (0, 2), \"length\": 0.5, \"is_dirichlet\": False, \"dirichlet_val\": None}, # f3 (interior)\n            {\"adj_cells\": (1, -1), \"length\": 0.5, \"is_dirichlet\": True, \"dirichlet_val\": 0.0},  # f4\n            {\"adj_cells\": (1, -1), \"length\": 0.5, \"is_dirichlet\": True, \"dirichlet_val\": 0.0},  # f5\n            {\"adj_cells\": (1, 3), \"length\": 0.5, \"is_dirichlet\": False, \"dirichlet_val\": None}, # f6 (interior)\n            {\"adj_cells\": (2, -1), \"length\": 0.5, \"is_dirichlet\": True, \"dirichlet_val\": 1.0},  # f7\n            {\"adj_cells\": (2, 3), \"length\": 0.5, \"is_dirichlet\": False, \"dirichlet_val\": None}, # f8 (interior)\n            {\"adj_cells\": (2, -1), \"length\": 0.5, \"is_dirichlet\": True, \"dirichlet_val\": 0.0},  # f9\n            {\"adj_cells\": (3, -1), \"length\": 0.5, \"is_dirichlet\": True, \"dirichlet_val\": 0.0},  # f10\n            {\"adj_cells\": (3, -1), \"length\": 0.5, \"is_dirichlet\": True, \"dirichlet_val\": 0.0},  # f11\n        ],\n        \"cells\": [\n            {\"kappa\": 1.0, \"face_indices\": [0, 1, 2, 3], \"face_distances\": [0.25, 0.25, 0.25, 0.25]}, # c0\n            {\"kappa\": 1.0, \"face_indices\": [2, 4, 5, 6], \"face_distances\": [0.25, 0.25, 0.25, 0.25]}, # c1\n            {\"kappa\": 1.0, \"face_indices\": [7, 3, 8, 9], \"face_distances\": [0.25, 0.25, 0.25, 0.25]}, # c2\n            {\"kappa\": 1.0, \"face_indices\": [8, 6, 11, 10], \"face_distances\": [0.25, 0.25, 0.25, 0.25]},# c3\n        ],\n        \"partitions\": [[0, 3], [1, 2]],\n    }\n\n    # Test Case B: Single cell with all Dirichlet boundaries (no unknowns).\n    test_case_B = {\n        \"faces\": [\n            {\"adj_cells\": (0, -1), \"length\": 1.0, \"is_dirichlet\": True, \"dirichlet_val\": 1.0},\n            {\"adj_cells\": (0, -1), \"length\": 1.0, \"is_dirichlet\": True, \"dirichlet_val\": 0.0},\n            {\"adj_cells\": (0, -1), \"length\": 1.0, \"is_dirichlet\": True, \"dirichlet_val\": 0.0},\n            {\"adj_cells\": (0, -1), \"length\": 1.0, \"is_dirichlet\": True, \"dirichlet_val\": 0.0},\n        ],\n        \"cells\": [{\"kappa\": 1.0, \"face_indices\": [0, 1, 2, 3], \"face_distances\": [0.5, 0.5, 0.5, 0.5]}],\n        \"partitions\": [[0]],\n    }\n\n    # Test Case C: Two cells with conductivity contrast and skewed geometry.\n    test_case_C = {\n        \"faces\": [\n            {\"adj_cells\": (0, -1), \"length\": 1.0, \"is_dirichlet\": True, \"dirichlet_val\": 1.0},  # f0\n            {\"adj_cells\": (0, -1), \"length\": 1.0, \"is_dirichlet\": True, \"dirichlet_val\": 0.0},  # f1\n            {\"adj_cells\": (0, 1), \"length\": 0.2, \"is_dirichlet\": False, \"dirichlet_val\": None}, # f2 (interior)\n            {\"adj_cells\": (0, -1), \"length\": 1.0, \"is_dirichlet\": True, \"dirichlet_val\": 0.0},  # f3\n            {\"adj_cells\": (1, -1), \"length\": 1.5, \"is_dirichlet\": True, \"dirichlet_val\": 0.0},  # f4\n            {\"adj_cells\": (1, -1), \"length\": 1.0, \"is_dirichlet\": True, \"dirichlet_val\": 0.0},  # f5\n            {\"adj_cells\": (1, -1), \"length\": 1.0, \"is_dirichlet\": True, \"dirichlet_val\": 0.0},  # f6\n        ],\n        \"cells\": [\n            {\"kappa\": 2.5, \"face_indices\": [0, 1, 2, 3], \"face_distances\": [0.5, 0.5, 0.05, 0.5]},\n            {\"kappa\": 0.5, \"face_indices\": [2, 4, 5, 6], \"face_distances\": [0.02, 0.7, 0.6, 0.8]},\n        ],\n        \"partitions\": [[0], [1]],\n    }\n    \n    test_cases_data = [test_case_A, test_case_B, test_case_C]\n    \n    final_results = []\n    for test_data in test_cases_data:\n        results = process_case(test_data)\n        final_results.extend(results)\n\n    print(f\"[{','.join(f'{r:.15e}' for r in final_results)}]\")\n\ndef process_case(test_data):\n    \"\"\"\n    Runs a single test case: performs serial and parallel assembly, solves, and computes metrics.\n    \"\"\"\n    faces = test_data[\"faces\"]\n    cells = test_data[\"cells\"]\n    partitions = test_data[\"partitions\"]\n\n    interior_face_indices = [i for i, f in enumerate(faces) if not f[\"is_dirichlet\"]]\n    num_unknowns = len(interior_face_indices)\n    interior_face_map = {face_idx: i for i, face_idx in enumerate(interior_face_indices)}\n\n    # Handle case with no unknowns as per problem specification.\n    if num_unknowns == 0:\n        return [0.0, 0.0, 1.0]\n\n    # Serial Assembly: all cells in one partition.\n    serial_partition = list(range(len(cells)))\n    A_serial, b_serial = assemble_partition(serial_partition, faces, cells, num_unknowns, interior_face_map)\n\n    # Parallel Assembly Simulation: Sum contributions from each partition.\n    A_parallel = np.zeros_like(A_serial)\n    b_parallel = np.zeros_like(b_serial)\n    for partition_cells in partitions:\n        A_part, b_part = assemble_partition(partition_cells, faces, cells, num_unknowns, interior_face_map)\n        A_parallel += A_part\n        b_parallel += b_part\n    \n    # Solve linear systems for interior face potentials.\n    sol_serial = np.linalg.solve(A_serial, b_serial)\n    sol_parallel = np.linalg.solve(A_parallel, b_parallel)\n\n    # Compute required metrics.\n    mat_diff = np.linalg.norm(A_serial - A_parallel, 'fro')\n    sol_diff = np.linalg.norm(sol_serial - sol_parallel, np.inf) if num_unknowns > 0 else 0.0\n    cond_num = np.linalg.cond(A_serial, 2) if num_unknowns > 0 else 1.0\n\n    return [mat_diff, sol_diff, cond_num]\n\ndef assemble_partition(partition_cells, faces, cells, num_unknowns, interior_face_map):\n    \"\"\"\n    Assembles the stiffness matrix and RHS vector for a given partition of cells.\n    \"\"\"\n    A_part = np.zeros((num_unknowns, num_unknowns))\n    b_part = np.zeros(num_unknowns)\n\n    for cell_idx in partition_cells:\n        cell = cells[cell_idx]\n        \n        # 1. Calculate local transmissibilities for faces of the current cell.\n        local_face_indices = cell[\"face_indices\"]\n        num_local_faces = len(local_face_indices)\n        T = np.zeros(num_local_faces)\n        for i, face_idx in enumerate(local_face_indices):\n            T[i] = cell[\"kappa\"] * faces[face_idx][\"length\"] / cell[\"face_distances\"][i]\n        \n        T_tot = np.sum(T)\n\n        if T_tot == 0:  # Avoid division by zero for degenerate cells\n            continue\n\n        # 2. Form local stiffness matrix (contribution to the Schur complement system).\n        # S_ij = T_i * delta_ij - (T_i * T_j) / T_tot\n        S_local = np.diag(T) - np.outer(T, T) / T_tot\n\n        # 3. Assemble local contributions into the partition's global matrix and vector.\n        for i in range(num_local_faces):\n            glob_idx_i = local_face_indices[i]\n            \n            # Check if the row 'i' corresponds to an interior face (an unknown).\n            if not faces[glob_idx_i][\"is_dirichlet\"]:\n                unknown_idx_i = interior_face_map[glob_idx_i]\n\n                for j in range(num_local_faces):\n                    glob_idx_j = local_face_indices[j]\n                    \n                    s_ij = S_local[i, j]\n\n                    if not faces[glob_idx_j][\"is_dirichlet\"]:\n                        # Column 'j' corresponds to an interior face. Add to stiffness matrix.\n                        unknown_idx_j = interior_face_map[glob_idx_j]\n                        A_part[unknown_idx_i, unknown_idx_j] += s_ij\n                    else:\n                        # Column 'j' corresponds to a Dirichlet face. Add to RHS vector.\n                        dirichlet_val = faces[glob_idx_j][\"dirichlet_val\"]\n                        b_part[unknown_idx_i] -= s_ij * dirichlet_val\n\n    return A_part, b_part\n\n# Execute the main function.\nsolve()\n```", "id": "3518426"}]}