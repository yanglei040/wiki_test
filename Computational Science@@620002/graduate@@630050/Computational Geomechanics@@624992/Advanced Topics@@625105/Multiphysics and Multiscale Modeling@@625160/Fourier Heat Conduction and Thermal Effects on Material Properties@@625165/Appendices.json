{"hands_on_practices": [{"introduction": "The journey into computational analysis often begins with a firm grasp of underlying analytical solutions. This first practice establishes a fundamental understanding of heat conduction by deriving the temperature profile in a simplified, one-dimensional scenario. By solving the steady-state heat equation with internal heat generation from first principles [@problem_id:3525671], you will build crucial intuition for how boundary conditions and heat sources interact, providing a valuable benchmark for the more complex numerical models that follow.", "problem": "A homogeneous soil layer of thickness $L$ occupies the domain $x \\in [0,L]$ and is laterally insulated so that heat flow is strictly one-dimensional ($1$D) along the $x$-axis. The soil exhibits a constant thermal conductivity $k$ and experiences a spatially uniform volumetric heat generation rate $q$ that is positive when it adds heat to the soil. The layer is in a steady state with prescribed temperatures at its ends: $T(0)=T_{0}$ and $T(L)=T_{L}$. Starting from the local conservation of energy and Fourier’s law of heat conduction, derive the closed-form expression for the steady-state temperature field $T(x)$ for $x \\in [0,L]$ under these conditions. Clearly state any assumptions required for the derivation. Express your final answer as a single closed-form analytic expression for $T(x)$. No numerical evaluation is required.", "solution": "The problem statement is first validated against the required criteria.\n\n### Step 1: Extract Givens\n- A homogeneous soil layer of thickness $L$ occupies the domain $x \\in [0,L]$.\n- Heat flow is one-dimensional ($1$D) along the $x$-axis (laterally insulated).\n- Thermal conductivity $k$ is constant.\n- A spatially uniform volumetric heat generation rate is present, denoted by $q$.\n- The system is in a steady state.\n- Prescribed boundary conditions: $T(0)=T_{0}$ and $T(L)=T_{L}$.\n- The derivation must start from the local conservation of energy and Fourier’s law of heat conduction.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientific Grounding**: The problem is a classical application of the principles of heat transfer, specifically the steady-state heat equation with a source term. This is a fundamental concept in physics and engineering, including geomechanics. The premises are scientifically sound.\n- **Well-Posedness**: The problem describes a second-order ordinary differential equation with two specified boundary conditions (Dirichlet conditions). This structure ensures that a unique and stable solution exists.\n- **Objectivity**: The problem is stated using clear, precise, and standard terminology from mathematics and physics. All parameters ($L, k, q, T_{0}, T_{L}$) are formally defined.\n- **Completeness and Consistency**: The problem is self-contained. It provides the governing physical laws to start from, the domain, the boundary conditions, and the material properties. There are no missing data or contradictory constraints.\n- **Realism**: The assumptions (one-dimensional flow, constant properties, uniform generation) are standard idealizations used to obtain an analytical solution for many practical scenarios, such as heat flow in the ground near a buried cable or a radioactive waste canister. The setup is physically plausible.\n\n### Step 3: Verdict and Action\nThe problem is valid as it is scientifically grounded, well-posed, objective, and self-contained. A rigorous solution can and will be derived.\n\n### Derivation of the Temperature Field\n\nThe derivation begins with the principle of local conservation of energy for a steady-state system. Consider a differential control volume of length $dx$ and cross-sectional area $A$ within the domain $x \\in [0,L]$. In steady state, the rate of energy accumulation is zero. The energy balance equation is:\n\n(Rate of energy conducted in at $x$) - (Rate of energy conducted out at $x+dx$) + (Rate of energy generated within the volume) = $0$\n\nLet $j(x)$ be the heat flux (energy per unit area per unit time) in the positive $x$-direction. The energy balance can be written as:\n$$A j(x) - A j(x+dx) + q (A \\, dx) = 0$$\nwhere $q$ is the volumetric heat generation rate. Dividing by the volume $A \\, dx$ gives:\n$$-\\frac{j(x+dx) - j(x)}{dx} + q = 0$$\nTaking the limit as $dx \\to 0$, we obtain the differential form of the energy conservation equation in one dimension:\n$$-\\frac{dj}{dx} + q = 0$$\n\nNext, we introduce Fourier's law of heat conduction, which relates the heat flux $j(x)$ to the local temperature gradient $\\frac{dT}{dx}$:\n$$j(x) = -k \\frac{dT}{dx}$$\nwhere $k$ is the thermal conductivity of the material. The negative sign signifies that heat flows down the temperature gradient (from hot to cold).\n\nSubstituting Fourier's law into the energy conservation equation yields:\n$$-\\frac{d}{dx}\\left(-k \\frac{dT}{dx}\\right) + q = 0$$\n$$\\frac{d}{dx}\\left(k \\frac{dT}{dx}\\right) + q = 0$$\n\nThe problem states that the thermal conductivity $k$ is constant. Therefore, it can be taken outside the derivative:\n$$k \\frac{d^2T}{dx^2} + q = 0$$\n\nThis is the governing second-order ordinary differential equation for the steady-state temperature field $T(x)$. We can rewrite it as:\n$$\\frac{d^2T}{dx^2} = -\\frac{q}{k}$$\n\nTo find the temperature distribution $T(x)$, we integrate this equation twice with respect to $x$. The first integration gives:\n$$\\frac{dT}{dx} = -\\frac{q}{k}x + C_1$$\nwhere $C_1$ is the first constant of integration.\n\nIntegrating a second time yields the general solution for the temperature field:\n$$T(x) = -\\frac{q}{2k}x^2 + C_1 x + C_2$$\nwhere $C_2$ is the second constant of integration.\n\nThe constants $C_1$ and $C_2$ are determined by applying the given boundary conditions: $T(0) = T_0$ and $T(L) = T_L$.\n\nApplying the first boundary condition at $x=0$:\n$$T(0) = -\\frac{q}{2k}(0)^2 + C_1(0) + C_2 = T_0$$\nThis immediately yields $C_2 = T_0$.\n\nThe solution now becomes:\n$$T(x) = -\\frac{q}{2k}x^2 + C_1 x + T_0$$\n\nApplying the second boundary condition at $x=L$:\n$$T(L) = -\\frac{q}{2k}L^2 + C_1 L + T_0 = T_L$$\n\nWe now solve for the constant $C_1$:\n$$C_1 L = T_L - T_0 + \\frac{qL^2}{2k}$$\n$$C_1 = \\frac{T_L - T_0}{L} + \\frac{qL}{2k}$$\n\nFinally, we substitute the expressions for $C_1$ and $C_2$ back into the general solution for $T(x)$ to obtain the specific solution for this problem:\n$$T(x) = -\\frac{q}{2k}x^2 + \\left(\\frac{T_L - T_0}{L} + \\frac{qL}{2k}\\right)x + T_0$$\n\nThis expression can be rearranged to better reveal its physical meaning. We can separate the terms independent of heat generation from those that depend on it:\n$$T(x) = T_0 + \\left(\\frac{T_L - T_0}{L}\\right)x - \\frac{q}{2k}x^2 + \\frac{qL}{2k}x$$\nGrouping the terms related to $q$ gives the final closed-form expression:\n$$T(x) = T_0 + (T_L - T_0)\\frac{x}{L} + \\frac{q}{2k}(Lx - x^2)$$\nThis solution shows that the temperature profile is a superposition of a linear profile (the solution for $q=0$) and a parabolic profile due to the internal heat generation. The assumptions required for this derivation are explicitly stated in the problem: steady-state conditions, one-dimensional heat flow, and constant material properties ($k$).", "answer": "$$\\boxed{T(x) = T_{0} + \\left(T_{L} - T_{0}\\right) \\frac{x}{L} + \\frac{q}{2k} \\left(Lx - x^{2}\\right)}$$", "id": "3525671"}, {"introduction": "While analytical models provide essential insight, most real-world geomechanical problems involve complex geometries and material properties that change with temperature, rendering analytical solutions intractable. This practice transitions from theory to computation by guiding you through the development of a finite element solver for the nonlinear heat equation with temperature-dependent properties like $k(T)$ and $c(T)$ [@problem_id:3525705]. You will derive and implement the residual and consistent Jacobian matrix, fundamental components of the Newton-Raphson method used to solve such nonlinear systems, a cornerstone skill in computational mechanics.", "problem": "Consider a one-dimensional homogeneous bar of length $L$ with spatial coordinate $x \\in [0,L]$. Let $T(x,t)$ denote the absolute temperature field in Kelvin. Assume the following foundational principles: (i) energy conservation in a continuum without mechanical work input, and (ii) Fourier’s law of heat conduction. Specifically, the energy balance for a differential control volume implies that the rate of change of internal energy equals the net conductive heat influx plus volumetric heat sources. Fourier’s law states that the conductive heat flux is proportional to the negative temperature gradient. Under these assumptions, the governing equation is the nonlinear heat conduction equation with temperature-dependent thermal conductivity and specific heat:\n$$\n\\rho\\,c(T)\\,\\frac{\\partial T}{\\partial t} \\;=\\; \\nabla\\cdot\\!\\left(k(T)\\,\\nabla T\\right) \\;+\\; Q(x,t),\n$$\nwhere $\\rho$ is the mass density in $\\mathrm{kg/m^3}$, $c(T)$ is the specific heat capacity in $\\mathrm{J/(kg\\cdot K)}$, $k(T)$ is the thermal conductivity in $\\mathrm{W/(m\\cdot K)}$, and $Q$ is a volumetric heat source in $\\mathrm{W/m^3}$. In one spatial dimension, the divergence reduces to partial differentiation with respect to $x$. Impose Dirichlet boundary conditions $T(0,t)=T_0$ and $T(L,t)=T_L$ in Kelvin and take an initial temperature field $T(x,0)=T^n(x)$.\n\nDiscretize the domain using a standard two-node linear finite element basis over $N_e$ equal-length elements, yielding $N_n=N_e+1$ nodes. Let $\\{N_i(x)\\}_{i=1}^{N_n}$ be the global shape functions. Use an implicit backward Euler method for time discretization from time level $t^n$ to $t^{n+1}=t^n+\\Delta t$, where $\\Delta t$ is the time step in seconds. Denote the nodal temperatures at $t^n$ by $\\{T_i^n\\}$ and at $t^{n+1}$ by $\\{T_i^{n+1}\\}$. Derive the finite element residual vector $\\mathbf{R}(\\mathbf{T}^{n+1})$ and the consistent Jacobian matrix $\\mathbf{J}(\\mathbf{T}^{n+1}) = \\frac{\\partial \\mathbf{R}}{\\partial \\mathbf{T}^{n+1}}$ needed for a Newton method at $t^{n+1}$.\n\nThe required derivation must start from the above governing equation and Fourier’s law and proceed through the weak form, spatial finite element discretization, and backward Euler time discretization. The result must explicitly display the integral expressions for the residual components $R_i$ and the Jacobian entries $J_{ij}$, including the contributions from the temperature dependence $c(T)$ and $k(T)$ via their derivatives with respect to $T$. Do not use shortcut formulas; derive each term from the stated fundamental laws.\n\nFor computational verification, implement a program that assembles the residual and the consistent Jacobian for a single time step at the initial Newton iterate $\\mathbf{T}^{n+1,(0)}=\\mathbf{T}^n$ using two-point Gaussian quadrature per element. Enforce Dirichlet boundary conditions by replacing the residual at boundary nodes with $R_i=T_i^{n+1}-T_{\\text{bc},i}$ and the Jacobian row with the identity at those nodes. Then compute a finite-difference Jacobian using centered differences to numerically approximate $\\frac{\\partial \\mathbf{R}}{\\partial \\mathbf{T}^{n+1}}$ and compare it against the analytically assembled consistent Jacobian.\n\nYour program must evaluate the following three dimensionless metrics per test case:\n1. A dimensionless residual magnitude defined as\n$$\n\\eta_R \\;=\\; \\frac{\\|\\mathbf{R}\\|_2}{\\|\\mathbf{R}\\|_1 + 10^{-16}},\n$$\n2. A dimensionless Jacobian magnitude defined as\n$$\n\\eta_J \\;=\\; \\frac{\\|\\mathbf{J}\\|_F}{\\|\\mathbf{J}\\|_1 + 10^{-16}},\n$$\n3. A dimensionless Jacobian consistency error defined as\n$$\n\\delta_J \\;=\\; \\frac{\\max_{i,j}\\left|J^{\\text{cons}}_{ij}-J^{\\text{FD}}_{ij}\\right|}{\\max_{i,j}\\left|J^{\\text{FD}}_{ij}\\right| + 10^{-16}},\n$$\nwhere $\\|\\cdot\\|_2$ is the Euclidean norm, $\\|\\cdot\\|_1$ is the sum of absolute values, and $\\|\\cdot\\|_F$ is the Frobenius norm.\n\nUse the following test suite, each with specified physical and numerical parameters. All prescribed temperatures are given in Kelvin, lengths in meters, density in $\\mathrm{kg/m^3}$, time in seconds, thermal conductivity in $\\mathrm{W/(m\\cdot K)}$, specific heat in $\\mathrm{J/(kg\\cdot K)}$, and source in $\\mathrm{W/m^3}$. The functions $c(T)$ and $k(T)$ are:\n$$\nc(T) \\;=\\; c_0 + c_1\\,T,\\quad k(T) \\;=\\; k_0\\,\\exp\\!\\left( b \\,(T - T_{\\text{ref}})\\right).\n$$\nThe derivatives are $c'(T)=c_1$ and $k'(T)=b\\,k(T)$.\n\n- Test Case A (general nonlinear, happy path):\n    - $L=1.0$, $N_e=10$, $\\rho=2200$, $c_0=900$, $c_1=0.5$, $k_0=2.0$, $b=0.01$, $T_{\\text{ref}}=300$, $\\Delta t=10.0$,\n    - $T_0=300.0$, $T_L=330.0$, $Q=0.0$,\n    - Initial field $T^n(x)$ is linear from $T_0$ to $T_L$.\n\n- Test Case B (linear material, boundary condition equilibrium):\n    - $L=1.0$, $N_e=6$, $\\rho=2000$, $c_0=800$, $c_1=0.0$, $k_0=2.5$, $b=0.0$, $T_{\\text{ref}}=300$, $\\Delta t=5.0$,\n    - $T_0=300.0$, $T_L=300.0$, $Q=0.0$,\n    - Initial field $T^n(x)=300.0$ uniform.\n\n- Test Case C (stronger nonlinearity and internal heating):\n    - $L=2.0$, $N_e=20$, $\\rho=2500$, $c_0=900$, $c_1=0.3$, $k_0=1.5$, $b=0.02$, $T_{\\text{ref}}=300$, $\\Delta t=0.5$,\n    - $T_0=310.0$, $T_L=390.0$, $Q=5.0\\times 10^{4}$,\n    - Initial field $T^n(x)$ is linear from $T_0$ to $T_L$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each test case contributing a list of its three dimensionless metrics in the order $[\\eta_R,\\eta_J,\\delta_J]$. For example, the output format must be like:\n$$\n[\\,[\\eta_R^{(A)},\\eta_J^{(A)},\\delta_J^{(A)}],\\,[\\eta_R^{(B)},\\eta_J^{(B)},\\delta_J^{(B)}],\\,[\\eta_R^{(C)},\\eta_J^{(C)},\\delta_J^{(C)}]\\,].\n$$\nNo physical units are required in the output because the metrics are dimensionless by construction.", "solution": "The user-provided problem is assessed to be valid. It is scientifically sound, well-posed, objective, and complete. It represents a standard problem in the field of computational heat transfer, requiring the derivation and implementation of a finite element solution for the nonlinear heat equation.\n\nThe solution process involves the following steps:\n1.  Derivation of the weak form of the governing partial differential equation (PDE) using the Galerkin method.\n2.  Application of spatial discretization using two-node linear finite elements.\n3.  Application of temporal discretization using the implicit backward Euler method, leading to a system of nonlinear algebraic equations.\n4.  Formulation of the residual vector $\\mathbf{R}$ and the consistent Jacobian matrix $\\mathbf{J}$ required for a Newton-Raphson iterative solver.\n5.  Numerical implementation of the assembly of $\\mathbf{R}$ and $\\mathbf{J}$ using Gaussian quadrature, and comparison with a finite-difference approximation of the Jacobian to verify the analytical derivation.\n\n**Step 1: Weak Form Derivation**\n\nThe governing PDE for one-dimensional nonlinear heat conduction is:\n$$\n\\rho\\,c(T)\\,\\frac{\\partial T}{\\partial t} \\;=\\; \\frac{\\partial}{\\partial x}\\!\\left(k(T)\\,\\frac{\\partial T}{\\partial x}\\right) \\;+\\; Q(x,t)\n$$\nTo derive the weak form, we multiply the PDE by an arbitrary test function $w(x)$ and integrate over the spatial domain $\\Omega = [0, L]$. The test function $w(x)$ is required to be zero at boundaries where Dirichlet conditions are specified.\n$$\n\\int_{0}^{L} w(x) \\left[ \\rho\\,c(T)\\,\\frac{\\partial T}{\\partial t} - \\frac{\\partial}{\\partial x}\\!\\left(k(T)\\,\\frac{\\partial T}{\\partial x}\\right) - Q(x,t) \\right] dx = 0\n$$\nWe apply integration by parts to the second term (the divergence term) to reduce the order of the spatial derivative:\n$$\n-\\int_{0}^{L} w(x) \\frac{\\partial}{\\partial x}\\!\\left(k(T)\\,\\frac{\\partial T}{\\partial x}\\right) dx = \\int_{0}^{L} \\frac{\\partial w}{\\partial x} k(T)\\,\\frac{\\partial T}{\\partial x} dx - \\left[ w(x) k(T)\\,\\frac{\\partial T}{\\partial x} \\right]_{0}^{L}\n$$\nThe boundary term $\\left[ w(x) k(T)\\,\\frac{\\partial T}{\\partial x} \\right]_{0}^{L}$ vanishes because the test functions $w(x)$ associated with internal (non-Dirichlet) nodes are zero at the boundaries $x=0$ and $x=L$. For the boundary nodes themselves, the corresponding equations will be replaced by the Dirichlet conditions, so this term does not contribute to the final system for the unknown nodal temperatures.\n\nSubstituting this back, the weak form of the equation is:\n$$\n\\int_{0}^{L} w(x) \\rho\\,c(T)\\,\\frac{\\partial T}{\\partial t} dx + \\int_{0}^{L} \\frac{\\partial w}{\\partial x} k(T)\\,\\frac{\\partial T}{\\partial x} dx = \\int_{0}^{L} w(x) Q(x,t) dx\n$$\nThis equation must hold for all valid test functions $w(x)$.\n\n**Step 2: Finite Element Spatial Discretization**\n\nThe domain $[0, L]$ is discretized into $N_e$ elements, giving $N_n = N_e+1$ nodes. The temperature field $T(x,t)$ is approximated using the finite element basis functions $\\{N_j(x)\\}_{j=1}^{N_n}$:\n$$\nT(x,t) \\approx T_h(x,t) = \\sum_{j=1}^{N_n} T_j(t) N_j(x)\n$$\nwhere $T_j(t)$ are the unknown nodal temperatures. In the Galerkin method, the test function $w(x)$ is chosen from the same set of basis functions, $w(x) = N_i(x)$ for $i=1, \\dots, N_n$.\n\nSubstituting the approximation $T_h(x,t)$ and $w(x) = N_i(x)$ into the weak form yields a system of ordinary differential equations:\n$$\n\\sum_{j=1}^{N_n} \\left( \\int_{0}^{L} N_i \\rho c(T_h) N_j dx \\right) \\frac{dT_j}{dt} + \\sum_{j=1}^{N_n} \\left( \\int_{0}^{L} \\frac{dN_i}{dx} k(T_h) \\frac{dN_j}{dx} dx \\right) T_j = \\int_{0}^{L} N_i Q dx\n$$\nfor each $i=1, \\dots, N_n$.\n\n**Step 3: Backward Euler Temporal Discretization**\n\nWe discretize in time from $t^n$ to $t^{n+1}=t^n+\\Delta t$. The backward Euler method approximates the time derivative at $t^{n+1}$ as:\n$$\n\\frac{dT_j}{dt} \\approx \\frac{T_j^{n+1} - T_j^n}{\\Delta t}\n$$\nAll other terms are also evaluated at time $t^{n+1}$. This leads to a system of nonlinear algebraic equations for the unknown nodal temperatures $\\mathbf{T}^{n+1} = \\{T_j^{n+1}\\}_{j=1}^{N_n}$.\nThe discrete system for each node $i$ is:\n$$\n\\int_{0}^{L} N_i \\rho c(T_h^{n+1}) \\frac{T_h^{n+1}-T_h^n}{\\Delta t} dx + \\int_{0}^{L} \\frac{dN_i}{dx} k(T_h^{n+1}) \\frac{\\partial T_h^{n+1}}{\\partial x} dx - \\int_{0}^{L} N_i Q^{n+1} dx = 0\n$$\nwhere $T_h^{n+1}(x) = \\sum_j T_j^{n+1} N_j(x)$ and $T_h^n(x) = \\sum_j T_j^n N_j(x)$.\n\n**Step 4: Residual and Jacobian Derivation**\n\nThe system of equations from Step 3 must be solved for $\\mathbf{T}^{n+1}$ using an iterative method like Newton-Raphson. This requires defining the residual vector $\\mathbf{R}(\\mathbf{T}^{n+1})$ and the Jacobian matrix $\\mathbf{J}(\\mathbf{T}^{n+1})$.\n\nThe $i$-th component of the residual vector, $R_i$, is defined as the left-hand side of the discretized weak form:\n$$\nR_i(\\mathbf{T}^{n+1}) = \\int_{0}^{L} \\!\\! \\left[ N_i \\rho c(T_h^{n+1}) \\frac{T_h^{n+1}-T_h^n}{\\Delta t} + \\frac{dN_i}{dx} k(T_h^{n+1}) \\frac{\\partial T_h^{n+1}}{\\partial x} - N_i Q^{n+1} \\right] dx\n$$\nThe Jacobian matrix components are defined by $J_{ij} = \\frac{\\partial R_i}{\\partial T_j^{n+1}}$. We differentiate $R_i$ with respect to an arbitrary nodal temperature $T_j^{n+1}$. Note that $\\frac{\\partial T_h^{n+1}}{\\partial T_j^{n+1}} = N_j(x)$ and $\\frac{\\partial}{\\partial T_j^{n+1}}\\left(\\frac{\\partial T_h^{n+1}}{\\partial x}\\right) = \\frac{dN_j}{dx}$.\n\nLet's differentiate $R_i$ term by term.\n1.  Contribution from the transient term:\n    $$\n    \\frac{\\partial}{\\partial T_j^{n+1}} \\int_{0}^{L} N_i \\rho c(T_h^{n+1}) \\frac{T_h^{n+1}-T_h^n}{\\Delta t} dx = \\int_{0}^{L} \\frac{N_i \\rho}{\\Delta t} \\left[ \\frac{\\partial c(T_h^{n+1})}{\\partial T_j^{n+1}}(T_h^{n+1}-T_h^n) + c(T_h^{n+1})\\frac{\\partial T_h^{n+1}}{\\partial T_j^{n+1}} \\right] dx\n    $$\n    Using the chain rule, $\\frac{\\partial c(T_h^{n+1})}{\\partial T_j^{n+1}} = c'(T_h^{n+1}) \\frac{\\partial T_h^{n+1}}{\\partial T_j^{n+1}} = c'(T_h^{n+1})N_j$. This gives:\n    $$\n    J_{ij}^{\\text{tran}} = \\int_{0}^{L} \\frac{\\rho}{\\Delta t} N_i N_j \\left[ c(T_h^{n+1}) + c'(T_h^{n+1})(T_h^{n+1}-T_h^n) \\right] dx\n    $$\n\n2.  Contribution from the conduction term:\n    $$\n    \\frac{\\partial}{\\partial T_j^{n+1}} \\int_{0}^{L} \\frac{dN_i}{dx} k(T_h^{n+1}) \\frac{\\partial T_h^{n+1}}{\\partial x} dx = \\int_{0}^{L} \\frac{dN_i}{dx} \\left[ \\frac{\\partial k(T_h^{n+1})}{\\partial T_j^{n+1}}\\frac{\\partial T_h^{n+1}}{\\partial x} + k(T_h^{n+1})\\frac{\\partial}{\\partial T_j^{n+1}}\\left(\\frac{\\partial T_h^{n+1}}{\\partial x}\\right) \\right] dx\n    $$\n    Using the chain rule, $\\frac{\\partial k(T_h^{n+1})}{\\partial T_j^{n+1}} = k'(T_h^{n+1}) N_j$. This gives:\n    $$\n    J_{ij}^{\\text{cond}} = \\int_{0}^{L} \\frac{dN_i}{dx} \\left[ k'(T_h^{n+1}) N_j \\frac{\\partial T_h^{n+1}}{\\partial x} + k(T_h^{n+1}) \\frac{dN_j}{dx} \\right] dx\n    $$\n\n3.  Contribution from the heat source term (assuming $Q$ is independent of $T$):\n    $$\n    J_{ij}^{\\text{source}} = \\frac{\\partial}{\\partial T_j^{n+1}} \\left( -\\int_0^L N_i Q^{n+1} dx \\right) = 0\n    $$\n\nCombining these contributions, the full expression for the Jacobian entry $J_{ij}$ is:\n$$\nJ_{ij}(\\mathbf{T}^{n+1}) = \\int_{0}^{L} \\frac{\\rho}{\\Delta t} N_i N_j \\left[ c(T_h^{n+1}) + c'(T_h^{n+1})(T_h^{n+1}-T_h^n) \\right] dx + \\int_{0}^{L} \\left[ \\frac{dN_i}{dx} k(T_h^{n+1}) \\frac{dN_j}{dx} + \\frac{dN_i}{dx} k'(T_h^{n+1}) N_j \\frac{\\partial T_h^{n+1}}{\\partial x} \\right] dx\n$$\n\n**Step 5: Numerical Implementation**\n\nThe integrals for $R_i$ and $J_{ij}$ are evaluated numerically using two-point Gaussian quadrature over each element. The process involves looping through each element, computing its local contributions to the global residual vector and Jacobian matrix at each Gauss point, and then assembling these contributions into the global system. For a two-node linear element of length $h_e$, the shape functions in local coordinates $\\xi \\in [-1,1]$ are $N_1(\\xi) = (1-\\xi)/2$ and $N_2(\\xi) = (1+\\xi)/2$, and their derivatives with respect to $x$ are $\\frac{dN_1}{dx} = -1/h_e$ and $\\frac{dN_2}{dx} = 1/h_e$.\n\nAfter assembly of the full physical residual $\\mathbf{R}^{\\text{phys}}$ and Jacobian $\\mathbf{J}^{\\text{phys}}$, the Dirichlet boundary conditions $T(0,t)=T_0$ and $T(L,t)=T_L$ are enforced. For a boundary node $i$ (e.g., $i=1$ or $i=N_n$), the corresponding residual equation is replaced by $R_i = T_i^{n+1} - T_{\\text{bc},i}$, and the Jacobian row is modified to be $J_{i,j} = \\delta_{ij}$ (i.e., $1$ on the diagonal and $0$ elsewhere).\n\nThe problem requires a single computation at the first Newton iterate, where the state $\\mathbf{T}^{n+1}$ is taken as the initial guess $\\mathbf{T}^{n+1,(0)} = \\mathbf{T}^n$. Thus, all quantities ($R_i$, $J_{ij}$) are evaluated using $T_h^{n+1} = T_h^n$. This simplifies the Jacobian terms, as $T_h^{n+1}-T_h^n = 0$.\n\nA finite-difference Jacobian, $\\mathbf{J}^{\\text{FD}}$, is computed to verify the analytical Jacobian, $\\mathbf{J}^{\\text{cons}}$. Using a centered-difference scheme:\n$$\nJ^{\\text{FD}}_{ij} \\approx \\frac{R_i(\\mathbf{T}^n + \\epsilon \\mathbf{e}_j) - R_i(\\mathbf{T}^n - \\epsilon \\mathbf{e}_j)}{2\\epsilon}\n$$\nwhere $\\mathbf{e}_j$ is a standard basis vector and $\\epsilon$ is a small perturbation. The residual function $R_i(\\cdot)$ used here must include the boundary condition enforcement step to ensure consistency with $\\mathbf{J}^{\\text{cons}}$. The code below implements this logic to compute the required dimensionless metrics.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function to run test cases and print results.\n    \"\"\"\n    \n    test_cases = [\n        {\n            # Test Case A (general nonlinear, happy path)\n            'L': 1.0, 'Ne': 10, 'rho': 2200.0, 'c0': 900.0, 'c1': 0.5,\n            'k0': 2.0, 'b': 0.01, 'T_ref': 300.0, 'Dt': 10.0, 'Q': 0.0,\n            'T0': 300.0, 'TL': 330.0,\n        },\n        {\n            # Test Case B (linear material, boundary condition equilibrium)\n            'L': 1.0, 'Ne': 6, 'rho': 2000.0, 'c0': 800.0, 'c1': 0.0,\n            'k0': 2.5, 'b': 0.0, 'T_ref': 300.0, 'Dt': 5.0, 'Q': 0.0,\n            'T0': 300.0, 'TL': 300.0,\n        },\n        {\n            # Test Case C (stronger nonlinearity and internal heating)\n            'L': 2.0, 'Ne': 20, 'rho': 2500.0, 'c0': 900.0, 'c1': 0.3,\n            'k0': 1.5, 'b': 0.02, 'T_ref': 300.0, 'Dt': 0.5, 'Q': 5.0e4,\n            'T0': 310.0, 'TL': 390.0,\n        }\n    ]\n\n    all_results = []\n    for params in test_cases:\n        # Unpack parameters\n        L, Ne, rho, c0, c1, k0, b, T_ref, Dt, Q, T0, TL = (\n            params['L'], params['Ne'], params['rho'], params['c0'], params['c1'],\n            params['k0'], params['b'], params['T_ref'], params['Dt'], params['Q'],\n            params['T0'], params['TL']\n        )\n\n        # Define material property functions\n        c = lambda T: c0 + c1 * T\n        c_prime = lambda T: c1\n        k = lambda T: k0 * np.exp(b * (T - T_ref))\n        k_prime = lambda T: b * k(T)\n\n        # Setup mesh and initial conditions\n        Nn = Ne + 1\n        nodes = np.linspace(0, L, Nn)\n        \n        # Initial temperature field T^n(x)\n        if np.isclose(T0, TL) and params['b']==0.0 and params['c1']==0.0: # Test case B specific\n            T_n = np.full(Nn, T0)\n        else: # Linear profile for A and C\n            T_n = T0 + (TL - T0) * nodes / L\n\n        # The calculation is for the first Newton step, so T^{n+1,(0)} = T^n\n        T_eval = T_n.copy()\n\n        # Assemble analytical residual and jacobian\n        R_cons, J_cons = assemble_system(T_eval, T_n, Ne, L, rho, Dt, c, c_prime, k, k_prime, Q, T0, TL)\n\n        # Assemble finite-difference jacobian for verification\n        J_fd = assemble_fd_jacobian(T_eval, T_n, Ne, L, rho, Dt, c, c_prime, k, k_prime, Q, T0, TL)\n\n        # Compute dimensionless metrics\n        eps_norm = 1e-16\n        \n        # Metric 1: Residual magnitude\n        norm_R_2 = np.linalg.norm(R_cons, 2)\n        norm_R_1 = np.linalg.norm(R_cons, 1)\n        eta_R = norm_R_2 / (norm_R_1 + eps_norm)\n\n        # Metric 2: Jacobian magnitude\n        norm_J_F = np.linalg.norm(J_cons, 'fro')\n        norm_J_1 = np.sum(np.abs(J_cons))\n        eta_J = norm_J_F / (norm_J_1 + eps_norm)\n\n        # Metric 3: Jacobian consistency error\n        J_diff_abs = np.abs(J_cons - J_fd)\n        J_fd_abs = np.abs(J_fd)\n        delta_J = np.max(J_diff_abs) / (np.max(J_fd_abs) + eps_norm)\n\n        all_results.append(f\"[{eta_R},{eta_J},{delta_J}]\")\n\n    print(f\"[{','.join(all_results)}]\")\n\ndef assemble_system(T_eval, T_n, Ne, L, rho, Dt, c_fun, c_prime_fun, k_fun, k_prime_fun, Q, T0, TL):\n    \"\"\"Assembles the consistent Jacobian and residual vector.\"\"\"\n    Nn = Ne + 1\n    h = L / Ne\n    R = np.zeros(Nn)\n    J = np.zeros((Nn, Nn))\n\n    # 2-point Gaussian quadrature\n    gp = 1.0 / np.sqrt(3.0)\n    gauss_points = [-gp, gp]\n    gauss_weights = [1.0, 1.0]\n\n    for e in range(Ne):\n        node_indices = [e, e + 1]\n        T_e_eval = T_eval[node_indices]\n        T_e_n = T_n[node_indices]\n        \n        r_e = np.zeros(2)\n        j_e = np.zeros((2, 2))\n\n        for xi, w in zip(gauss_points, gauss_weights):\n            N = np.array([(1 - xi) / 2, (1 + xi) / 2])\n            B = np.array([-1 / h, 1 / h])\n            \n            T_gp_eval = N @ T_e_eval\n            T_gp_n = N @ T_e_n\n            T_grad_gp_eval = B @ T_e_eval\n            \n            c_val = c_fun(T_gp_eval)\n            cp_val = c_prime_fun(T_gp_eval)\n            k_val = k_fun(T_gp_eval)\n            kp_val = k_prime_fun(T_gp_eval)\n            \n            dV = (h / 2) * w\n\n            # Residual assembly\n            term_tran_R = N * rho * c_val * (T_gp_eval - T_gp_n) / Dt\n            term_cond_R = B * k_val * T_grad_gp_eval\n            term_src_R = -N * Q\n            r_e += (term_tran_R + term_cond_R + term_src_R) * dV\n            \n            # Jacobian assembly\n            # Because T_eval = T_n, (T_gp_eval - T_gp_n) is zero.\n            term_tran_J = (rho / Dt) * np.outer(N, N) * (c_val + cp_val * (T_gp_eval - T_gp_n))\n            term_cond_J1 = k_val * np.outer(B, B)\n            term_cond_J2 = kp_val * T_grad_gp_eval * np.outer(B, N)\n            \n            j_e += (term_tran_J + term_cond_J1 + term_cond_J2) * dV\n        \n        np.add.at(R, node_indices, r_e)\n        J[np.ix_(node_indices, node_indices)] += j_e\n        \n    # Apply Dirichlet boundary conditions\n    # Node 0\n    R[0] = T_eval[0] - T0\n    J[0, :] = 0.0\n    J[0, 0] = 1.0\n\n    # Last Node\n    R[-1] = T_eval[-1] - TL\n    J[-1, :] = 0.0\n    J[-1, -1] = 1.0\n    \n    return R, J\n\ndef get_residual(T, T_n, Ne, L, rho, Dt, c_fun, c_prime_fun, k_fun, k_prime_fun, Q, T0, TL):\n    \"\"\"Helper function to compute residual vector for a given temperature vector T.\"\"\"\n    R, _ = assemble_system(T, T_n, Ne, L, rho, Dt, c_fun, c_prime_fun, k_fun, k_prime_fun, Q, T0, TL)\n    return R\n\ndef assemble_fd_jacobian(T_eval, T_n, Ne, L, rho, Dt, c_fun, c_prime_fun, k_fun, k_prime_fun, Q, T0, TL):\n    \"\"\"Assembles the Jacobian matrix using centered finite differences.\"\"\"\n    Nn = Ne + 1\n    J_fd = np.zeros((Nn, Nn))\n    epsilon = 1e-8\n\n    for j in range(Nn):\n        T_plus = T_eval.copy()\n        T_plus[j] += epsilon\n        \n        T_minus = T_eval.copy()\n        T_minus[j] -= epsilon\n\n        R_plus = get_residual(T_plus, T_n, Ne, L, rho, Dt, c_fun, c_prime_fun, k_fun, k_prime_fun, Q, T0, TL)\n        R_minus = get_residual(T_minus, T_n, Ne, L, rho, Dt, c_fun, c_prime_fun, k_fun, k_prime_fun, Q, T0, TL)\n        \n        J_fd[:, j] = (R_plus - R_minus) / (2 * epsilon)\n        \n    return J_fd\n\nif __name__ == '__main__':\n    solve()\n\n```", "id": "3525705"}, {"introduction": "The ultimate goal in many geomechanical analyses is to understand how thermal processes affect the mechanical stability of the ground. This final practice focuses on this critical link by implementing a thermo-elasto-plastic constitutive model at a single material point [@problem_id:3525679]. You will see how a temperature change, computed using methods like those in the previous exercises, can cause thermal softening and induce plastic deformation, and you will learn to implement the necessary return-mapping algorithm and derive the consistent tangent moduli for a fully coupled simulation.", "problem": "A small-strain thermo-elasto-plastic constitutive update is required at a material point in a geomechanical body where Fourier heat conduction governs the temperature and the yield behavior follows the Drucker–Prager (DP) model. The material is isotropic and linearly elastic in the elastic domain with bulk modulus $K$ and shear modulus $G$. The plasticity is associative with the Drucker–Prager yield function $f(\\boldsymbol{\\sigma},T) = \\sqrt{J_2(\\boldsymbol{\\sigma})} + a\\,I_1(\\boldsymbol{\\sigma}) - c(T)$, where $a$ is a given friction parameter, $I_1(\\boldsymbol{\\sigma})$ is the first invariant of the Cauchy stress tensor $\\boldsymbol{\\sigma}$, and $J_2(\\boldsymbol{\\sigma})$ is the second invariant of the deviatoric stress tensor. The cohesion depends on temperature $T$ as $c(T) = c_0 - b\\,(T - T_0)$, with constants $c_0$, $b$, and $T_0$. Thermal expansion is isotropic with coefficient $\\alpha_T$, so that the thermal strain increment is $\\Delta \\boldsymbol{\\varepsilon}_{\\mathrm{th}} = \\alpha_T\\,\\Delta T\\,\\boldsymbol{I}$, where $\\boldsymbol{I}$ is the identity tensor and $\\Delta T = T^{n+1}-T^n$.\n\nThe temperature evolution is governed by Fourier heat conduction with constant density $\\rho$, constant specific heat $c_p$, constant thermal conductivity $k_{\\mathrm{th}}$, and a uniform volumetric heat source $r$. At a material point with known temperature Laplacian $\\nabla^2 T$ at time $t^n$, a single forward-Euler time update of the temperature is\n$$\nT^{n+1} = T^n + \\Delta t \\left( \\frac{k_{\\mathrm{th}}}{\\rho c_p}\\,\\nabla^2 T^n + \\frac{r}{\\rho c_p} \\right),\n$$\nwhere $\\Delta t$ is the time step.\n\nAt the same material point, over this time step, a total small strain increment $\\Delta \\boldsymbol{\\varepsilon}$ is prescribed. The stress update follows a standard elastic predictor/plastic corrector (return-mapping) scheme for the Drucker–Prager model. The goal is to construct:\n- the updated Cauchy stress $\\boldsymbol{\\sigma}^{n+1}$,\n- the plastic consistency increment $\\Delta \\lambda$,\n- the consistent algorithmic mechanical tangent $\\mathbb{C}_{\\mathrm{ep}} = \\partial \\boldsymbol{\\sigma}^{n+1}/\\partial \\boldsymbol{\\varepsilon}^{n+1}$ at fixed $T^{n+1}$,\n- and the thermo-mechanical coupling tensor $\\partial \\boldsymbol{\\sigma}^{n+1}/\\partial T^{n+1}$ at fixed $\\boldsymbol{\\varepsilon}^{n+1}$,\nstarting only from fundamental definitions and laws. You must treat the deviatoric and volumetric parts exactly and ensure the algorithmic tangent is consistent with the return mapping. Assume associative flow and perfect plasticity with no strain hardening other than the temperature-dependent cohesion $c(T)$.\n\nImplement a program that performs this update for the following fixed material and thermal parameters and three test cases. All stresses and moduli must be treated in megapascal (MPa); temperatures must be treated in kelvin (K); time in seconds (s); density in kilograms per cubic meter (kg/m$^3$); specific heat in joules per kilogram per kelvin (J/(kg·K)); conductivity in watts per meter per kelvin (W/(m·K)); and the heat source in watts per cubic meter (W/m$^3$).\n\nMaterial and thermal constants (shared across all test cases):\n- $K = 20000$ MPa, $G = 12000$ MPa, $a = 0.1$, $c_0 = 20$ MPa, $b = 0.2$ MPa/K, $T_0 = 293$ K, $\\alpha_T = 1\\times 10^{-5}$ K$^{-1}$.\n- $\\rho = 2200$ kg/m$^3$, $c_p = 800$ J/(kg·K), $k_{\\mathrm{th}} = 2$ W/(m·K).\n- Previous-step stress is zero, $\\boldsymbol{\\sigma}^n = \\boldsymbol{0}$, and the previous temperature is $T^n = 293$ K for all cases.\n\nTest suite (each case specifies the time-step data and the prescribed total strain increment $\\Delta \\boldsymbol{\\varepsilon}$):\n- Case $1$ (nominally elastic): $\\Delta t = 60$ s, $\\nabla^2 T^n = 0$ K/m$^2$, $r = 0$ W/m$^3$, and $\\Delta \\boldsymbol{\\varepsilon} = \\mathrm{diag}(1\\times 10^{-5},\\,1\\times 10^{-5},\\,1\\times 10^{-5})$.\n- Case $2$ (mechanically driven plasticity): $\\Delta t = 60$ s, $\\nabla^2 T^n = 0$ K/m$^2$, $r = 0$ W/m$^3$, and $\\Delta \\boldsymbol{\\varepsilon} = \\mathrm{diag}(1\\times 10^{-3},\\,-5\\times 10^{-4},\\,-5\\times 10^{-4})$.\n- Case $3$ (temperature-induced softening to plasticity): $\\Delta t = 3600$ s, $\\nabla^2 T^n = 0$ K/m$^2$, $r = \\rho c_p \\times 50 / 3600$ W/m$^3$, and $\\Delta \\boldsymbol{\\varepsilon} = \\mathrm{diag}(5\\times 10^{-4},\\,-2.5\\times 10^{-4},\\,-2.5\\times 10^{-4})$.\n\nFor each case, your program must:\n- Compute $T^{n+1}$ via the Fourier update above.\n- Perform the return mapping to obtain $\\boldsymbol{\\sigma}^{n+1}$ and the plastic consistency increment $\\Delta \\lambda$ from first principles, including thermal strain $\\Delta \\boldsymbol{\\varepsilon}_{\\mathrm{th}}$ constructed from $\\Delta T$.\n- Construct the consistent algorithmic mechanical tangent $\\mathbb{C}_{\\mathrm{ep}}$ at fixed $T^{n+1}$.\n- Construct the thermo-mechanical coupling tensor $\\partial \\boldsymbol{\\sigma}^{n+1}/\\partial T^{n+1}$ at fixed $\\boldsymbol{\\varepsilon}^{n+1}$.\n\nTo make the results testable and succinct, for each case output a list with the following four quantities:\n- A plasticity indicator as an integer, where $1$ means plastic correction occurs and $0$ means elastic.\n- The plastic consistency increment $\\Delta \\lambda$ (dimensionless), rounded to six decimal places.\n- The algorithmic bulk modulus $K_{\\mathrm{alg}} = \\frac{1}{9}\\,\\boldsymbol{I}:\\mathbb{C}_{\\mathrm{ep}}:\\boldsymbol{I}$ in MPa, rounded to six decimal places.\n- The Frobenius norm of the thermo-mechanical coupling tensor $\\left\\|\\partial \\boldsymbol{\\sigma}^{n+1}/\\partial T^{n+1}\\right\\|_F$ in MPa/K, rounded to six decimal places.\n\nYour program should produce a single line of output containing the results as a comma-separated list of these per-case lists, enclosed in square brackets (e.g., \"[[case1_list],[case2_list],[case3_list]]\").", "solution": "The problem requires the implementation of a small-strain thermo-elasto-plastic constitutive update at a material point. The thermal behavior is governed by Fourier heat conduction, and the mechanical behavior follows the associative Drucker-Prager (DP) model with temperature-dependent cohesion. We must derive the updated stress $\\boldsymbol{\\sigma}^{n+1}$, plastic multiplier increment $\\Delta\\lambda$, the consistent algorithmic mechanical tangent $\\mathbb{C}_{\\mathrm{ep}}$, and the thermo-mechanical coupling tensor $\\partial \\boldsymbol{\\sigma}^{n+1}/\\partial T^{n+1}$.\n\nThe solution proceeds in several steps: ($1$) updating the temperature, ($2$) performing an elastic-predictor/plastic-corrector stress update, and ($3$) deriving the required tangent moduli and coupling tensors from the update algorithm.\n\n### 1. Preliminaries: Constitutive Relations\n\nThe total strain increment $\\Delta \\boldsymbol{\\varepsilon}$ is additively decomposed into elastic, plastic, and thermal parts:\n$$\n\\Delta \\boldsymbol{\\varepsilon} = \\Delta \\boldsymbol{\\varepsilon}_{\\mathrm{e}} + \\Delta \\boldsymbol{\\varepsilon}_{\\mathrm{p}} + \\Delta \\boldsymbol{\\varepsilon}_{\\mathrm{th}}\n$$\nThe linear isotropic elastic stress-strain relation is given by Hooke's law:\n$$\n\\boldsymbol{\\sigma} = \\mathbb{C} : \\boldsymbol{\\varepsilon}_{\\mathrm{e}} = (3K \\mathbb{P}_{\\mathrm{vol}} + 2G \\mathbb{P}_{\\mathrm{dev}}) : \\boldsymbol{\\varepsilon}_{\\mathrm{e}}\n$$\nwhere $K$ and $G$ are the bulk and shear moduli, and $\\mathbb{P}_{\\mathrm{vol}} = \\frac{1}{3}\\boldsymbol{I} \\otimes \\boldsymbol{I}$ and $\\mathbb{P}_{\\mathrm{dev}} = \\mathbb{I} - \\mathbb{P}_{\\mathrm{vol}}$ are the fourth-order volumetric and deviatoric projection tensors, respectively. $\\boldsymbol{I}$ is the second-order identity tensor and $\\mathbb{I}$ is the fourth-order symmetric identity tensor.\n\nThe thermal strain increment is isotropic:\n$$\n\\Delta \\boldsymbol{\\varepsilon}_{\\mathrm{th}} = \\alpha_T \\Delta T \\boldsymbol{I}\n$$\nwhere $\\alpha_T$ is the coefficient of thermal expansion and $\\Delta T = T^{n+1} - T^n$.\n\nThe Drucker-Prager yield function is:\n$$\nf(\\boldsymbol{\\sigma}, T) = \\sqrt{J_2(\\boldsymbol{\\sigma})} + a \\, I_1(\\boldsymbol{\\sigma}) - c(T) \\le 0\n$$\nwhere $I_1(\\boldsymbol{\\sigma}) = \\mathrm{tr}(\\boldsymbol{\\sigma})$ is the first invariant of the stress tensor, $J_2(\\boldsymbol{\\sigma}) = \\frac{1}{2}\\boldsymbol{s}:\\boldsymbol{s}$ is the second invariant of the deviatoric stress tensor $\\boldsymbol{s} = \\boldsymbol{\\sigma} - \\frac{1}{3}I_1(\\boldsymbol{\\sigma})\\boldsymbol{I}$, $a$ is the friction parameter, and $c(T)$ is the temperature-dependent cohesion:\n$$\nc(T) = c_0 - b(T - T_0)\n$$\nPlastic flow is associative, meaning the plastic strain increment is normal to the yield surface:\n$$\n\\Delta \\boldsymbol{\\varepsilon}_{\\mathrm{p}} = \\Delta\\lambda \\frac{\\partial f}{\\partial \\boldsymbol{\\sigma}} = \\Delta\\lambda \\boldsymbol{N}\n$$\nwhere $\\Delta\\lambda \\ge 0$ is the plastic multiplier increment and $\\boldsymbol{N} = \\frac{\\partial f}{\\partial \\boldsymbol{\\sigma}}$ is the flow direction. $\\boldsymbol{N} = \\frac{\\boldsymbol{s}}{2\\sqrt{J_2}} + a\\boldsymbol{I}$.\n\n### 2. Temperature Update\n\nThe temperature at the new time step $t^{n+1}$ is computed using a single forward-Euler step:\n$$\nT^{n+1} = T^n + \\Delta t \\left( \\frac{k_{\\mathrm{th}}}{\\rho c_p}\\,\\nabla^2 T^n + \\frac{r}{\\rho c_p} \\right)\n$$\nThis updated temperature $T^{n+1}$ is used for the subsequent mechanical update. $\\Delta T = T^{n+1}-T^n$.\n\n### 3. Stress Update: Elastic Predictor-Plastic Corrector\n\nGiven the state $(\\boldsymbol{\\sigma}^n, T^n)$ at time $t^n$ and the prescribed total strain increment $\\Delta\\boldsymbol{\\varepsilon}$ over $\\Delta t$, the new state $(\\boldsymbol{\\sigma}^{n+1}, T^{n+1})$ is found.\n\n#### 3.1. Elastic Predictor\nFirst, we assume the entire mechanical strain increment is elastic. The trial stress $\\boldsymbol{\\sigma}^{\\mathrm{trial}}$ is computed based on this assumption:\n$$\n\\boldsymbol{\\sigma}^{\\mathrm{trial}} = \\boldsymbol{\\sigma}^n + \\mathbb{C} : (\\Delta \\boldsymbol{\\varepsilon} - \\Delta \\boldsymbol{\\varepsilon}_{\\mathrm{th}}) = \\boldsymbol{\\sigma}^n + \\mathbb{C} : (\\Delta \\boldsymbol{\\varepsilon} - \\alpha_T \\Delta T \\boldsymbol{I})\n$$\nSince $\\boldsymbol{\\sigma}^n=\\boldsymbol{0}$, we can write the invariants of the trial stress as:\n$$\nI_1^{\\mathrm{trial}} = I_1(\\boldsymbol{\\sigma}^{\\mathrm{trial}}) = 3K(\\mathrm{tr}(\\Delta\\boldsymbol{\\varepsilon}) - 3\\alpha_T \\Delta T)\n$$\n$$\n\\boldsymbol{s}^{\\mathrm{trial}} = \\boldsymbol{s}_{\\boldsymbol{\\sigma}^{\\mathrm{trial}}} = 2G\\,\\boldsymbol{e}\n$$\nwhere $\\boldsymbol{e} = \\Delta\\boldsymbol{\\varepsilon} - \\frac{1}{3}\\mathrm{tr}(\\Delta\\boldsymbol{\\varepsilon})\\boldsymbol{I}$ is the deviatoric part of the total strain increment.\n\n#### 3.2. Yield Check\nWe evaluate the yield function at the trial state and the new temperature $T^{n+1}$:\n$$\nf^{\\mathrm{trial}} = f(\\boldsymbol{\\sigma}^{\\mathrm{trial}}, T^{n+1}) = \\sqrt{J_2(\\boldsymbol{s}^{\\mathrm{trial}})} + a\\, I_1^{\\mathrm{trial}} - c(T^{n+1})\n$$\nIf $f^{\\mathrm{trial}} \\le 0$, the assumption was correct. The step is elastic. The final stress is $\\boldsymbol{\\sigma}^{n+1} = \\boldsymbol{\\sigma}^{\\mathrm{trial}}$ and the plastic increment is $\\Delta\\lambda = 0$.\n\n#### 3.3. Plastic Corrector (Return Mapping)\nIf $f^{\\mathrm{trial}} > 0$, the trial state is outside the yield surface, indicating plastic deformation. The stress state must be \"returned\" to the yield surface. The final stress $\\boldsymbol{\\sigma}^{n+1}$ is related to the trial stress by:\n$$\n\\boldsymbol{\\sigma}^{n+1} = \\boldsymbol{\\sigma}^{\\mathrm{trial}} - \\mathbb{C} : \\Delta\\boldsymbol{\\varepsilon}_{\\mathrm{p}} = \\boldsymbol{\\sigma}^{\\mathrm{trial}} - \\Delta\\lambda \\, \\mathbb{C} : \\boldsymbol{N}^{n+1}\n$$\nwhere $\\boldsymbol{N}^{n+1}$ is evaluated at the final state $\\boldsymbol{\\sigma}^{n+1}$. For the DP model, this system can be solved explicitly. The return mapping leads to the following explicit formula for the plastic multiplier:\n$$\n\\Delta\\lambda = \\frac{f^{\\mathrm{trial}}}{G + 9Ka^2}\n$$\nOnce $\\Delta\\lambda$ is known, the final stress state is computed by correcting the trial state:\n$$\nI_1^{n+1} = I_1^{\\mathrm{trial}} - 9Ka \\Delta\\lambda\n$$\n$$\n\\boldsymbol{s}^{n+1} = \\left(1 - \\frac{\\Delta\\lambda G}{\\sqrt{J_2^{\\mathrm{trial}}}}\\right)\\boldsymbol{s}^{\\mathrm{trial}}\n$$\nThe final stress tensor is then $\\boldsymbol{\\sigma}^{n+1} = \\boldsymbol{s}^{n+1} + \\frac{1}{3}I_1^{n+1}\\boldsymbol{I}$.\n\n### 4. Algorithmic Consistent Tangents\n\n#### 4.1. Mechanical Tangent and Algorithmic Bulk Modulus\nThe consistent algorithmic tangent $\\mathbb{C}_{\\mathrm{ep}} = \\partial\\boldsymbol{\\sigma}^{n+1}/\\partial\\boldsymbol{\\varepsilon}^{n+1}$ is obtained by exact linearization of the update algorithm.\n- **Elastic Case ($f^{\\mathrm{trial}} \\le 0$):**\n  $\\boldsymbol{\\sigma}^{n+1} = \\boldsymbol{\\sigma}^{\\mathrm{trial}} = \\boldsymbol{\\sigma}^n + \\mathbb{C}:(\\Delta\\boldsymbol{\\varepsilon}-\\Delta\\boldsymbol{\\varepsilon}_{\\mathrm{th}})$. At fixed $T^{n+1}$, $\\Delta\\boldsymbol{\\varepsilon}_{\\mathrm{th}}$ is constant.\n  $$ \\mathbb{C}_{\\mathrm{ep}} = \\frac{\\partial \\boldsymbol{\\sigma}^{\\mathrm{trial}}}{\\partial (\\Delta\\boldsymbol{\\varepsilon})} = \\mathbb{C} $$\n- **Plastic Case ($f^{\\mathrm{trial}} > 0$):**\n  The derivation is more involved, but yields a known symmetric fourth-order tensor. We are interested in the algorithmic bulk modulus $K_{\\mathrm{alg}} = \\frac{1}{9}\\boldsymbol{I}:\\mathbb{C}_{\\mathrm{ep}}:\\boldsymbol{I}$. Applying this to the full expression for $\\mathbb{C}_{\\mathrm{ep}}$ gives:\n  $$ K_{\\mathrm{alg}} = K \\left( \\frac{G}{G + 9Ka^2} \\right) $$\nFor the elastic case, this framework is consistent, as letting $\\Delta\\lambda \\to 0$ (or viewing the plastic case as a general form), the denominator term disappears, one might think, but the formula for $K_{alg}$ is a property of the plastic tangent, not a continuous function of $\\Delta \\lambda$. In the elastic case, $K_{\\mathrm{alg}} = K$.\n\n#### 4.2. Thermo-Mechanical Coupling Tensor\nThe thermo-mechanical coupling tensor is $\\boldsymbol{h} = \\partial\\boldsymbol{\\sigma}^{n+1}/\\partial T^{n+1}$ at fixed total strain increment $\\Delta\\boldsymbol{\\varepsilon}$.\n- **Elastic Case ($f^{\\mathrm{trial}} \\le 0$):**\n  $\\boldsymbol{\\sigma}^{n+1} = \\boldsymbol{\\sigma}^n + \\mathbb{C}:(\\Delta\\boldsymbol{\\varepsilon} - \\alpha_T(T^{n+1}-T^n)\\boldsymbol{I})$.\n  $$ \\boldsymbol{h}_{\\mathrm{el}} = \\frac{\\partial \\boldsymbol{\\sigma}^{n+1}}{\\partial T^{n+1}} = -\\mathbb{C}:(\\alpha_T \\boldsymbol{I}) = -3K\\alpha_T\\boldsymbol{I} $$\n  The Frobenius norm is $\\| \\boldsymbol{h}_{\\mathrm{el}} \\|_F = \\sqrt{(-3K\\alpha_T)^2 \\times 3} = 3\\sqrt{3} K\\alpha_T$.\n- **Plastic Case ($f^{\\mathrm{trial}} > 0$):**\n  We differentiate the plastic update equations with respect to $T^{n+1}$. The trial stress depends on $T^{n+1}$ via thermal strain, and the yield condition depends on it via cohesion $c(T^{n+1})$.\n  $$ \\frac{\\partial I_1^{\\mathrm{trial}}}{\\partial T^{n+1}} = -9K\\alpha_T, \\quad \\frac{\\partial \\boldsymbol{s}^{\\mathrm{trial}}}{\\partial T^{n+1}} = \\boldsymbol{0}, \\quad \\frac{\\partial c(T^{n+1})}{\\partial T^{n+1}} = -b $$\n  This leads to the derivative of the plastic multiplier:\n  $$ \\frac{\\partial \\Delta\\lambda}{\\partial T^{n+1}} = \\frac{1}{G+9Ka^2} \\left( a \\frac{\\partial I_1^{\\mathrm{trial}}}{\\partial T^{n+1}} - \\frac{\\partial c}{\\partial T^{n+1}} \\right) = \\frac{b - 9Ka\\alpha_T}{G+9Ka^2} $$\n  Differentiating the final stress components and calculating the Frobenius norm gives:\n  $$ \\| \\boldsymbol{h}_{\\mathrm{pl}} \\|_F = \\frac{1}{G+9Ka^2} \\sqrt{2G^2(b - 9Ka\\alpha_T)^2 + 27K^2(G\\alpha_T + ab)^2} $$\n\n### 5. Summary of Formulas for Implementation\n\nFor each test case:\n1.  Compute $T^{n+1}$ and $\\Delta T$.\n2.  Compute trial stress invariants $I_1^{\\mathrm{trial}}$, $\\boldsymbol{s}^{\\mathrm{trial}}$, and $\\sqrt{J_2^{\\mathrm{trial}}}$.\n3.  Compute current cohesion $c(T^{n+1})$.\n4.  Compute $f^{\\mathrm{trial}} = \\sqrt{J_2^{\\mathrm{trial}}} + a I_1^{\\mathrm{trial}} - c(T^{n+1})$.\n5.  If $f^{\\mathrm{trial}} \\le 0$:\n    - Plasticity indicator: $0$.\n    - $\\Delta\\lambda = 0$.\n    - $K_{\\mathrm{alg}} = K$.\n    - $\\|\\boldsymbol{h}\\|_F = 3\\sqrt{3}K\\alpha_T$.\n6.  If $f^{\\mathrm{trial}} > 0$:\n    - Plasticity indicator: $1$.\n    - Let $H=G+9Ka^2$.\n    - $\\Delta\\lambda = f^{\\mathrm{trial}} / H$.\n    - $K_{\\mathrm{alg}} = K(G/H)$.\n    - $\\|\\boldsymbol{h}\\|_F = \\frac{1}{H}\\sqrt{2G^2(b-9Ka\\alpha_T)^2 + 27K^2(G\\alpha_T+ab)^2}$.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Performs a thermo-elasto-plastic constitutive update for three test cases.\n    \"\"\"\n    # Material and thermal constants\n    K = 20000.0  # MPa\n    G = 12000.0  # MPa\n    a = 0.1\n    c0 = 20.0   # MPa\n    b = 0.2     # MPa/K\n    T0 = 293.0  # K\n    alpha_T = 1.0e-5  # K^-1\n    rho = 2200.0  # kg/m^3\n    cp = 800.0    # J/(kg.K)\n    k_th = 2.0    # W/(m.K)\n\n    # Initial conditions (shared)\n    sigma_n = np.zeros((3, 3))\n    T_n = 293.0  # K\n\n    test_cases = [\n        # Case 1 (nominally elastic)\n        (60.0, 0.0, 0.0, np.diag([1e-5, 1e-5, 1e-5])),\n        # Case 2 (mechanically driven plasticity)\n        (60.0, 0.0, 0.0, np.diag([1e-3, -5e-4, -5e-4])),\n        # Case 3 (temperature-induced softening to plasticity)\n        (3600.0, 0.0, rho * cp * 50.0 / 3600.0, np.diag([5e-4, -2.5e-4, -2.5e-4])),\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        delta_t, lap_T_n, r, delta_eps = case\n\n        # 1. Temperature Update\n        T_n_plus_1 = T_n + delta_t * ((k_th / (rho * cp)) * lap_T_n + r / (rho * cp))\n        delta_T = T_n_plus_1 - T_n\n        \n        # 2. Elastic Predictor\n        delta_eps_v = np.trace(delta_eps)\n        delta_e = delta_eps - (delta_eps_v / 3.0) * np.eye(3)\n        \n        # Since sigma_n is zero\n        I1_trial = 3.0 * K * (delta_eps_v - 3.0 * alpha_T * delta_T)\n        s_trial = 2.0 * G * delta_e\n        \n        # 3. Yield Check\n        J2_trial = 0.5 * np.sum(s_trial * s_trial)\n        sqrt_J2_trial = np.sqrt(J2_trial)\n        \n        c_n_plus_1 = c0 - b * (T_n_plus_1 - T0)\n        \n        f_trial = sqrt_J2_trial + a * I1_trial - c_n_plus_1\n        \n        if f_trial = 0:\n            # Elastic case\n            plasticity_indicator = 0\n            delta_lambda = 0.0\n            K_alg = K\n            h_norm_F = 3.0 * np.sqrt(3.0) * K * alpha_T\n        else:\n            # Plastic case\n            plasticity_indicator = 1\n            H = G + 9.0 * K * a**2\n            delta_lambda = f_trial / H\n            \n            K_alg = K * (G / H)\n            \n            # Thermo-mechanical coupling tensor norm\n            term1 = 2.0 * G**2 * (b - 9.0 * K * a * alpha_T)**2\n            term2 = 27.0 * K**2 * (G * alpha_T + a * b)**2\n            h_norm_F = (1.0 / H) * np.sqrt(term1 + term2)\n            \n        all_results.append([\n            plasticity_indicator,\n            delta_lambda,\n            K_alg,\n            h_norm_F\n        ])\n\n    # Format output\n    case_strings = []\n    for res in all_results:\n        s = f\"[{res[0]},{res[1]:.6f},{res[2]:.6f},{res[3]:.6f}]\"\n        case_strings.append(s)\n    \n    final_output_str = f\"[{','.join(case_strings)}]\"\n    print(final_output_str)\n\nsolve()\n```", "id": "3525679"}]}