{"hands_on_practices": [{"introduction": "The Principle of Virtual Work (PVW) provides an elegant and powerful integral statement of equilibrium. This first practice offers a direct, tangible verification of this fundamental principle, moving it from abstract theory to concrete calculation [@problem_id:3565498]. By explicitly computing both the internal and external virtual work for a system in a known state of geostatic equilibrium, you will confirm their equality and build a deeper intuition for how the weak form holistically captures the balance of forces.", "problem": "Consider a two-dimensional plane-strain soil element of unit thickness with rectangular domain $\\Omega = \\{(x,y) \\,|\\, 0 \\le x \\le L,\\; 0 \\le y \\le H\\}$, subject to gravity. The Cauchy stress tensor field $\\boldsymbol{\\sigma}(x,y)$ is given in components by\n$$\\sigma_{xx}(x,y) = K_{0}\\,\\gamma\\,y,\\qquad \\sigma_{yy}(x,y) = \\gamma\\,y,\\qquad \\sigma_{xy}(x,y) = 0,$$\nwhere $\\gamma$ is the soil unit weight and $K_{0}$ is the lateral earth pressure coefficient at rest. The body force per unit volume is $\\boldsymbol{b} = (0,-\\gamma)$, and there are no prescribed tractions on the boundary. Let the virtual displacement field $\\delta\\boldsymbol{u}(x,y)$ vanish on the boundary $\\partial\\Omega$ and be defined by\n$$\\delta u_{x}(x,y) = A\\,x(L-x)\\,y(H-y),\\qquad \\delta u_{y}(x,y) = B\\,x(L-x)\\,y(H-y),$$\nwith constants $A$ and $B$. Using the Principle of Virtual Work (PVW), compute the internal virtual work\n$$W_{\\mathrm{int}} = \\int_{\\Omega}\\boldsymbol{\\sigma}:\\delta\\boldsymbol{\\varepsilon}\\,\\mathrm{d}\\Omega,$$\nwhere $\\delta\\boldsymbol{\\varepsilon} = \\tfrac{1}{2}\\left(\\nabla\\,\\delta\\boldsymbol{u} + (\\nabla\\,\\delta\\boldsymbol{u})^{\\top}\\right)$ is the virtual strain tensor, and verify its equality to the external virtual work under equilibrium. Take the numerical values $L = 2\\,\\mathrm{m}$, $H = 3\\,\\mathrm{m}$, $\\gamma = 18\\,\\mathrm{kN/m^{3}}$, $K_{0} = 0.5$, $A = 1.0\\times 10^{-3}\\,\\mathrm{m^{-3}}$, and $B = 1.0\\times 10^{-3}\\,\\mathrm{m^{-3}}$. Report the common value of the internal and external virtual work as a single number. Express your final answer in $\\mathrm{kN\\cdot m}$ and round your answer to four significant figures.", "solution": "The starting point is the strong form of equilibrium for a quasi-static, small-strain, plane-strain continuum,\n$$\\nabla\\cdot\\boldsymbol{\\sigma} + \\boldsymbol{b} = \\boldsymbol{0}\\quad \\text{in } \\Omega,$$\nwith boundary conditions $\\boldsymbol{t} = \\boldsymbol{\\sigma}\\,\\boldsymbol{n}$ on any traction boundary $\\Gamma_{t}$ and kinematic (essential) conditions on $\\Gamma_{u}$, where the virtual displacement field $\\delta\\boldsymbol{u}$ satisfies $\\delta\\boldsymbol{u} = \\boldsymbol{0}$ on $\\Gamma_{u}$.\n\nMultiplying the strong form by an arbitrary, kinematically admissible virtual displacement $\\delta\\boldsymbol{u}$ and integrating over $\\Omega$ gives\n$$\\int_{\\Omega}(\\nabla\\cdot\\boldsymbol{\\sigma})\\cdot\\delta\\boldsymbol{u}\\,\\mathrm{d}\\Omega + \\int_{\\Omega}\\boldsymbol{b}\\cdot\\delta\\boldsymbol{u}\\,\\mathrm{d}\\Omega = 0.$$\nUsing the divergence theorem on the first term,\n$$\\int_{\\Omega}(\\nabla\\cdot\\boldsymbol{\\sigma})\\cdot\\delta\\boldsymbol{u}\\,\\mathrm{d}\\Omega = \\int_{\\partial\\Omega} (\\boldsymbol{\\sigma}\\boldsymbol{n})\\cdot\\delta\\boldsymbol{u}\\,\\mathrm{d}\\Gamma - \\int_{\\Omega} \\boldsymbol{\\sigma}:\\nabla\\delta\\boldsymbol{u}\\,\\mathrm{d}\\Omega.$$\nSymmetrizing $\\nabla\\delta\\boldsymbol{u}$ and using the symmetry of $\\boldsymbol{\\sigma}$ yields\n$$\\int_{\\Omega} \\boldsymbol{\\sigma}:\\nabla\\delta\\boldsymbol{u}\\,\\mathrm{d}\\Omega = \\int_{\\Omega} \\boldsymbol{\\sigma}:\\delta\\boldsymbol{\\varepsilon}\\,\\mathrm{d}\\Omega,$$\nwhere $\\delta\\boldsymbol{\\varepsilon} = \\tfrac{1}{2}\\left(\\nabla\\delta\\boldsymbol{u} + (\\nabla\\delta\\boldsymbol{u})^{\\top}\\right)$. Therefore, the Principle of Virtual Work (PVW) reads\n$$\\int_{\\Omega}\\boldsymbol{\\sigma}:\\delta\\boldsymbol{\\varepsilon}\\,\\mathrm{d}\\Omega = \\int_{\\Omega}\\boldsymbol{b}\\cdot\\delta\\boldsymbol{u}\\,\\mathrm{d}\\Omega + \\int_{\\partial\\Omega} \\boldsymbol{t}\\cdot\\delta\\boldsymbol{u}\\,\\mathrm{d}\\Gamma.$$\nIn the present problem, the virtual displacement vanishes on the entire boundary $\\partial\\Omega$, so the boundary integral is zero. Under equilibrium ($\\nabla\\cdot\\boldsymbol{\\sigma} + \\boldsymbol{b} = \\boldsymbol{0}$), the internal virtual work equals the body-force virtual work:\n$$W_{\\mathrm{int}} = \\int_{\\Omega}\\boldsymbol{\\sigma}:\\delta\\boldsymbol{\\varepsilon}\\,\\mathrm{d}\\Omega = \\int_{\\Omega}\\boldsymbol{b}\\cdot\\delta\\boldsymbol{u}\\,\\mathrm{d}\\Omega.$$\n\nWe now compute both sides explicitly and verify the equality.\n\nFirst, compute the virtual strains from the given virtual displacements:\n\n$$\n\\delta u_{x}(x,y) = A\\,x(L-x)\\,y(H-y),\\qquad\n\\delta u_{y}(x,y) = B\\,x(L-x)\\,y(H-y).\n$$\n\nGradients are\n\n$$\n\\frac{\\partial\\,\\delta u_{x}}{\\partial x} = A\\,(L-2x)\\,y(H-y),\\qquad\n\\frac{\\partial\\,\\delta u_{x}}{\\partial y} = A\\,x(L-x)\\,(H-2y),\n$$\n\n\n$$\n\\frac{\\partial\\,\\delta u_{y}}{\\partial x} = B\\,(L-2x)\\,y(H-y),\\qquad\n\\frac{\\partial\\,\\delta u_{y}}{\\partial y} = B\\,x(L-x)\\,(H-2y).\n$$\n\nThe nonzero components of the virtual strain tensor are\n\n$$\n\\delta\\varepsilon_{xx} = \\frac{\\partial\\,\\delta u_{x}}{\\partial x} = A\\,(L-2x)\\,y(H-y),\n$$\n\n\n$$\n\\delta\\varepsilon_{yy} = \\frac{\\partial\\,\\delta u_{y}}{\\partial y} = B\\,x(L-x)\\,(H-2y),\n$$\n\n\n$$\n\\delta\\varepsilon_{xy} = \\frac{1}{2}\\left(\\frac{\\partial\\,\\delta u_{x}}{\\partial y} + \\frac{\\partial\\,\\delta u_{y}}{\\partial x}\\right) = \\frac{1}{2}\\left(A\\,x(L-x)\\,(H-2y) + B\\,(L-2x)\\,y(H-y)\\right).\n$$\n\nSince $\\sigma_{xy} = 0$, only $\\sigma_{xx}\\,\\delta\\varepsilon_{xx}$ and $\\sigma_{yy}\\,\\delta\\varepsilon_{yy}$ contribute to $\\boldsymbol{\\sigma}:\\delta\\boldsymbol{\\varepsilon}$:\n\n$$\n\\boldsymbol{\\sigma}:\\delta\\boldsymbol{\\varepsilon} = \\sigma_{xx}\\,\\delta\\varepsilon_{xx} + \\sigma_{yy}\\,\\delta\\varepsilon_{yy} = K_{0}\\gamma y\\cdot A\\,(L-2x)\\,y(H-y) + \\gamma y\\cdot B\\,x(L-x)\\,(H-2y).\n$$\n\nTherefore,\n\n$$\nW_{\\mathrm{int}} = \\int_{0}^{L}\\int_{0}^{H}\\left(K_{0}\\gamma A\\,(L-2x)\\,y^{2}(H-y) + \\gamma B\\,x(L-x)\\,y(H-2y)\\right)\\,\\mathrm{d}y\\,\\mathrm{d}x.\n$$\n\nObserve that the first term factors into $\\int_{0}^{L}(L-2x)\\,\\mathrm{d}x$ times a $y$-integral. Compute\n\n$$\n\\int_{0}^{L}(L-2x)\\,\\mathrm{d}x = \\left[Lx - x^{2}\\right]_{0}^{L} = L^{2} - L^{2} = 0,\n$$\n\nso the entire first term vanishes upon integration. Hence\n\n$$\nW_{\\mathrm{int}} = \\gamma B\\left(\\int_{0}^{L}x(L-x)\\,\\mathrm{d}x\\right)\\left(\\int_{0}^{H}y(H-2y)\\,\\mathrm{d}y\\right).\n$$\n\nCompute these one-dimensional integrals:\n\n$$\n\\int_{0}^{L}x(L-x)\\,\\mathrm{d}x = \\int_{0}^{L}(Lx - x^{2})\\,\\mathrm{d}x = \\left[\\frac{L}{2}x^{2} - \\frac{1}{3}x^{3}\\right]_{0}^{L} = \\left(\\frac{L^{3}}{2} - \\frac{L^{3}}{3}\\right) = \\frac{L^{3}}{6},\n$$\n\n\n$$\n\\int_{0}^{H}y(H-2y)\\,\\mathrm{d}y = \\int_{0}^{H}(Hy - 2y^{2})\\,\\mathrm{d}y = \\left[\\frac{H}{2}y^{2} - \\frac{2}{3}y^{3}\\right]_{0}^{H} = \\left(\\frac{H^{3}}{2} - \\frac{2H^{3}}{3}\\right) = -\\frac{H^{3}}{6}.\n$$\n\nTherefore,\n\n$$\nW_{\\mathrm{int}} = \\gamma B\\left(\\frac{L^{3}}{6}\\right)\\left(-\\frac{H^{3}}{6}\\right) = -\\,\\frac{\\gamma B\\,L^{3}H^{3}}{36}.\n$$\n\n\nNext, compute the external virtual work associated with the body force (the boundary term is zero because $\\delta\\boldsymbol{u}=\\boldsymbol{0}$ on $\\partial\\Omega$):\n\n$$\nW_{\\mathrm{ext}} = \\int_{\\Omega}\\boldsymbol{b}\\cdot\\delta\\boldsymbol{u}\\,\\mathrm{d}\\Omega = \\int_{0}^{L}\\int_{0}^{H}(0,-\\gamma)\\cdot(\\delta u_{x},\\delta u_{y})\\,\\mathrm{d}y\\,\\mathrm{d}x = -\\gamma\\int_{0}^{L}\\int_{0}^{H}\\delta u_{y}\\,\\mathrm{d}y\\,\\mathrm{d}x.\n$$\n\nSubstitute $\\delta u_{y}(x,y) = B\\,x(L-x)\\,y(H-y)$:\n\n$$\nW_{\\mathrm{ext}} = -\\gamma B\\left(\\int_{0}^{L}x(L-x)\\,\\mathrm{d}x\\right)\\left(\\int_{0}^{H}y(H-y)\\,\\mathrm{d}y\\right).\n$$\n\nWe already have $\\int_{0}^{L}x(L-x)\\,\\mathrm{d}x = \\frac{L^{3}}{6}$. Now compute\n\n$$\n\\int_{0}^{H}y(H-y)\\,\\mathrm{d}y = \\int_{0}^{H}(Hy - y^{2})\\,\\mathrm{d}y = \\left[\\frac{H}{2}y^{2} - \\frac{1}{3}y^{3}\\right]_{0}^{H} = \\left(\\frac{H^{3}}{2} - \\frac{H^{3}}{3}\\right) = \\frac{H^{3}}{6}.\n$$\n\nThus,\n\n$$\nW_{\\mathrm{ext}} = -\\gamma B\\left(\\frac{L^{3}}{6}\\right)\\left(\\frac{H^{3}}{6}\\right) = -\\,\\frac{\\gamma B\\,L^{3}H^{3}}{36}.\n$$\n\nWe have shown $W_{\\mathrm{int}} = W_{\\mathrm{ext}}$ in closed form, as required by the Principle of Virtual Work under equilibrium.\n\nFinally, insert the given numerical values $L = 2\\,\\mathrm{m}$, $H = 3\\,\\mathrm{m}$, $\\gamma = 18\\,\\mathrm{kN/m^{3}}$, $B = 1.0\\times 10^{-3}\\,\\mathrm{m^{-3}}$:\n\n$$\nL^{3} = 8,\\qquad H^{3} = 27,\\qquad \\frac{L^{3}H^{3}}{36} = \\frac{8\\cdot 27}{36} = \\frac{216}{36} = 6.\n$$\n\nTherefore,\n\n$$\nW_{\\mathrm{int}} = W_{\\mathrm{ext}} = -\\,\\frac{\\gamma B\\,L^{3}H^{3}}{36} = -\\,18\\,\\mathrm{kN/m^{3}}\\times 1.0\\times 10^{-3}\\,\\mathrm{m^{-3}}\\times 6 = -0.108\\,\\mathrm{kN\\cdot m}.\n$$\n\nRounded to four significant figures and expressed in $\\mathrm{kN\\cdot m}$, the common value is $-0.1080\\,\\mathrm{kN\\cdot m}$.", "answer": "$$\\boxed{-0.1080}$$", "id": "3565498"}, {"introduction": "The true power of the weak form is realized when it serves as the foundation for numerical techniques like the Finite Element Method (FEM). This practice guides you through the essential process of translating the continuous weak form into the discrete algebraic equations that are the heart of computational analysis [@problem_id:3565463]. You will derive and implement the procedures for calculating element nodal force vectors, which are the fundamental building blocks for assembling and solving complex geomechanical problems.", "problem": "Consider a two-dimensional small-strain, quasi-static, linear elastic solid in plane strain. Let the displacement field be denoted by $\\mathbf{u}$, the Cauchy stress by $\\boldsymbol{\\sigma}$, the small-strain tensor by $\\boldsymbol{\\varepsilon}$, the body force per unit volume by $\\mathbf{b}$, and the prescribed traction on a portion of the Neumann boundary by $\\bar{\\mathbf{t}}$. Assume the domain is discretized into linear triangular finite elements with constant thickness, and that within each element the displacement is interpolated by nodal shape functions. Use the Principle of Virtual Work to derive the weak form from the strong form of linear momentum balance and obtain, at the element level, the consistent internal nodal force vector and the consistent external nodal force vector. The external force vector must include both body-force and traction contributions on the portion of the boundary where tractions are prescribed.\n\nYour derivation must start from the strong form of equilibrium, the definition of small strain, and the kinematic interpolation of displacements with shape functions (no further shortcut formulas are permitted in your derivation). You must clearly indicate the constitutive relation for plane strain using the Lamé parameters. Adopt the following vector conventions: the strain vector is $[\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy}]^T$ with $\\gamma_{xy} = 2 \\varepsilon_{xy}$, and the stress vector is $[\\sigma_{xx}, \\sigma_{yy}, \\tau_{xy}]^T$. Nodal degrees of freedom are ordered as $[u_{1x}, u_{1y}, u_{2x}, u_{2y}, u_{3x}, u_{3y}]^T$. Within each element, assume the nodes are listed in counterclockwise order. All lengths are in meters, forces in Newtons, stresses in Pascals, densities in kilograms per cubic meter, and accelerations in meters per second squared. Report all nodal force components in Newtons. Angles, if any, must be in radians.\n\nThen, implement a program that, given the geometric, material, kinematic, and loading data for an element, computes:\n- the element internal nodal force vector, and\n- the element external nodal force vector including body force and traction contributions on the specified traction edge(s).\n\nUse exact integration appropriate to linear triangular elements. For a traction applied uniformly along an element edge between node $i$ and node $j$, the consistent nodal contributions arise from integrating the edge shape functions against the uniform traction.\n\nFor the purpose of verification, use the following test suite of three elements. For each case, produce two lists of length $6$ (internal and external nodal force vectors), each rounded to $6$ decimal places, ordered as $[F_{1x}, F_{1y}, F_{2x}, F_{2y}, F_{3x}, F_{3y}]$, and expressed in Newtons.\n\n- Case $1$ (general case with body force and one traction edge):\n  - Nodal coordinates (meters): node $1$: $(0, 0)$, node $2$: $(2, 0)$, node $3$: $(0, 1)$.\n  - Thickness: $1$ m.\n  - Material: Young’s modulus $E = 3.0 \\times 10^{7}$ Pa, Poisson’s ratio $\\nu = 0.30$ (plane strain).\n  - Nodal displacements (meters): $[0.0, 0.0, 0.001, 0.0, 0.0, 0.0005]$.\n  - Density: $\\rho = 1800$ kg/m$^{3}$; gravity $g = 9.81$ m/s$^{2}$; body force $\\mathbf{b} = [0, -\\rho g]$ N/m$^{3}$.\n  - Traction: uniform traction $\\bar{\\mathbf{t}} = [5000, 0]$ N/m applied along the edge from node $2$ to node $3$.\n\n- Case $2$ (zero displacement, only body force, no traction):\n  - Nodal coordinates (meters): node $1$: $(0, 0)$, node $2$: $(1, 0)$, node $3$: $(0, 1)$.\n  - Thickness: $0.5$ m.\n  - Material: Young’s modulus $E = 5.0 \\times 10^{7}$ Pa, Poisson’s ratio $\\nu = 0.25$ (plane strain).\n  - Nodal displacements (meters): $[0.0, 0.0, 0.0, 0.0, 0.0, 0.0]$.\n  - Body force $\\mathbf{b} = [1000, -500]$ N/m$^{3}$.\n  - No traction.\n\n- Case $3$ (no body force, one traction edge, nontrivial geometry and displacements):\n  - Nodal coordinates (meters): node $1$: $(1, 1)$, node $2$: $(3, 1)$, node $3$: $(2, 2.5)$.\n  - Thickness: $1.2$ m.\n  - Material: Young’s modulus $E = 1.0 \\times 10^{7}$ Pa, Poisson’s ratio $\\nu = 0.35$ (plane strain).\n  - Nodal displacements (meters): $[0.0002, -0.0001, 0.0004, 0.0, 0.0003, 0.0002]$.\n  - Body force $\\mathbf{b} = [0, 0]$ N/m$^{3}$.\n  - Traction: uniform traction $\\bar{\\mathbf{t}} = [0, 2000]$ N/m applied along the edge from node $1$ to node $2$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must contain three items, one per case. Each item is a list of two lists: the first is the internal force vector, the second is the external force vector. The numbers must be rounded to $6$ decimal places. For example: \n  - $[\\,[ [\\dots], [\\dots] ],\\; [ [\\dots], [\\dots] ],\\; [ [\\dots], [\\dots] ]\\,]$.", "solution": "The problem requires the derivation of the element-level internal and external nodal force vectors for a two-dimensional linear elastic solid in a state of plane strain, discretized by linear triangular finite elements. The derivation must originate from the strong form of the equilibrium equations and employ the Principle of Virtual Work. Subsequently, a computational implementation is required to calculate these vectors for specified test cases.\n\nThe derivation proceeds as follows.\n\n**1. Strong Form of Equilibrium and Boundary Conditions**\nThe strong form of the quasi-static linear momentum balance, or equilibrium equation, for a continuous body occupying a domain $\\Omega$ is given by:\n$$ \\nabla \\cdot \\boldsymbol{\\sigma} + \\mathbf{b} = \\mathbf{0} \\quad \\text{in } \\Omega $$\nHere, $\\boldsymbol{\\sigma}$ is the Cauchy stress tensor and $\\mathbf{b}$ is the body force vector per unit volume. The domain's boundary $\\Gamma$ is partitioned into a Dirichlet boundary $\\Gamma_u$ where displacements $\\bar{\\mathbf{u}}$ are prescribed, and a Neumann boundary $\\Gamma_t$ where tractions $\\bar{\\mathbf{t}}$ are prescribed.\n$$ \\mathbf{u} = \\bar{\\mathbf{u}} \\quad \\text{on } \\Gamma_u $$\n$$ \\boldsymbol{\\sigma} \\cdot \\mathbf{n} = \\bar{\\mathbf{t}} \\quad \\text{on } \\Gamma_t $$\nwhere $\\mathbf{n}$ is the outward unit normal to the boundary $\\Gamma$.\n\n**2. Principle of Virtual Work and the Weak Form**\nThe Principle of Virtual Work provides the basis for the weak form. We introduce a kinematically admissible virtual displacement field $\\delta\\mathbf{u}$, which is an arbitrary function that is sufficiently smooth and satisfies the homogeneous essential boundary condition, i.e., $\\delta\\mathbf{u} = \\mathbf{0}$ on $\\Gamma_u$.\n\nWe multiply the equilibrium equation by $\\delta\\mathbf{u}$ and integrate over the domain $\\Omega$:\n$$ \\int_{\\Omega} (\\nabla \\cdot \\boldsymbol{\\sigma} + \\mathbf{b}) \\cdot \\delta\\mathbf{u} \\, dV = 0 $$\nExpanding the terms yields:\n$$ \\int_{\\Omega} (\\nabla \\cdot \\boldsymbol{\\sigma}) \\cdot \\delta\\mathbf{u} \\, dV + \\int_{\\Omega} \\mathbf{b} \\cdot \\delta\\mathbf{u} \\, dV = 0 $$\nApplying the product rule for divergence, we have $\\nabla \\cdot (\\boldsymbol{\\sigma}^T \\cdot \\delta\\mathbf{u}) = (\\nabla \\cdot \\boldsymbol{\\sigma}) \\cdot \\delta\\mathbf{u} + \\boldsymbol{\\sigma} : \\nabla(\\delta\\mathbf{u})$. Since the Cauchy stress tensor is symmetric ($\\boldsymbol{\\sigma} = \\boldsymbol{\\sigma}^T$), this becomes $\\nabla \\cdot (\\boldsymbol{\\sigma} \\cdot \\delta\\mathbf{u}) = (\\nabla \\cdot \\boldsymbol{\\sigma}) \\cdot \\delta\\mathbf{u} + \\boldsymbol{\\sigma} : \\nabla(\\delta\\mathbf{u})$.\nRearranging and integrating gives:\n$$ \\int_{\\Omega} (\\nabla \\cdot \\boldsymbol{\\sigma}) \\cdot \\delta\\mathbf{u} \\, dV = \\int_{\\Omega} \\nabla \\cdot (\\boldsymbol{\\sigma} \\cdot \\delta\\mathbf{u}) \\, dV - \\int_{\\Omega} \\boldsymbol{\\sigma} : \\nabla(\\delta\\mathbf{u}) \\, dV $$\nApplying the divergence theorem to the first term on the right-hand side:\n$$ \\int_{\\Omega} \\nabla \\cdot (\\boldsymbol{\\sigma} \\cdot \\delta\\mathbf{u}) \\, dV = \\int_{\\Gamma} (\\boldsymbol{\\sigma} \\cdot \\delta\\mathbf{u}) \\cdot \\mathbf{n} \\, dS = \\int_{\\Gamma} (\\boldsymbol{\\sigma} \\cdot \\mathbf{n}) \\cdot \\delta\\mathbf{u} \\, dS $$\nThe virtual strain tensor $\\delta\\boldsymbol{\\varepsilon}$ is defined as the symmetric part of the gradient of the virtual displacement: $\\delta\\boldsymbol{\\varepsilon} = \\frac{1}{2}(\\nabla(\\delta\\mathbf{u}) + (\\nabla(\\delta\\mathbf{u}))^T)$. Due to the symmetry of $\\boldsymbol{\\sigma}$, the double dot product $\\boldsymbol{\\sigma} : \\nabla(\\delta\\mathbf{u})$ is equal to $\\boldsymbol{\\sigma} : \\delta\\boldsymbol{\\varepsilon}$.\nSubstituting these back into the original integrated equation gives:\n$$ \\int_{\\Gamma} (\\boldsymbol{\\sigma} \\cdot \\mathbf{n}) \\cdot \\delta\\mathbf{u} \\, dS - \\int_{\\Omega} \\boldsymbol{\\sigma} : \\delta\\boldsymbol{\\varepsilon} \\, dV + \\int_{\\Omega} \\mathbf{b} \\cdot \\delta\\mathbf{u} \\, dV = 0 $$\nThe boundary integral is split over $\\Gamma_u$ and $\\Gamma_t$. Since $\\delta\\mathbf{u} = \\mathbf{0}$ on $\\Gamma_u$, the integral over $\\Gamma_u$ vanishes. On $\\Gamma_t$, we have $\\boldsymbol{\\sigma} \\cdot \\mathbf{n} = \\bar{\\mathbf{t}}$. The equation becomes:\n$$ \\int_{\\Omega} \\boldsymbol{\\sigma} : \\delta\\boldsymbol{\\varepsilon} \\, dV = \\int_{\\Omega} \\mathbf{b} \\cdot \\delta\\mathbf{u} \\, dV + \\int_{\\Gamma_t} \\bar{\\mathbf{t}} \\cdot \\delta\\mathbf{u} \\, dS $$\nThis is the weak form of the equilibrium equation, also known as the statement of the Principle of Virtual Work: the internal virtual work (left-hand side) equals the external virtual work (right-hand side) for any admissible virtual displacement.\n\n**3. Finite Element Discretization**\nThe domain $\\Omega$ is discretized into non-overlapping finite elements $\\Omega^e$. The weak form holds for the entire domain, and thus for the sum over all elements. We now focus on a single linear triangular element, $\\Omega^e$.\n\nWithin an element, the displacement field $\\mathbf{u}$ is approximated by interpolating the nodal displacements $\\mathbf{d}^e$ using shape functions $N_i(x,y)$:\n$$ \\mathbf{u}(x,y) = \\begin{bmatrix} u_x(x,y) \\\\ u_y(x,y) \\end{bmatrix} = \\sum_{i=1}^{3} N_i(x,y) \\begin{bmatrix} u_{ix} \\\\ u_{iy} \\end{bmatrix} $$\nThis can be written in matrix form as $\\mathbf{u} = \\mathbf{N} \\mathbf{d}^e$, where $\\mathbf{N}$ is the shape function matrix and $\\mathbf{d}^e$ is the element nodal displacement vector:\n$$ \\mathbf{N} = \\begin{bmatrix} N_1 & 0 & N_2 & 0 & N_3 & 0 \\\\ 0 & N_1 & 0 & N_2 & 0 & N_3 \\end{bmatrix} $$\n$$ \\mathbf{d}^e = [u_{1x}, u_{1y}, u_{2x}, u_{2y}, u_{3x}, u_{3y}]^T $$\nThe virtual displacement is similarly interpolated: $\\delta\\mathbf{u} = \\mathbf{N} \\delta\\mathbf{d}^e$.\n\nThe small-strain vector, using the specified convention $\\boldsymbol{\\varepsilon}_{\\text{voigt}} = [\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy}]^T$, is obtained by applying the strain-displacement operator $\\mathbf{L}$:\n$$ \\boldsymbol{\\varepsilon}_{\\text{voigt}} = \\begin{bmatrix} \\varepsilon_{xx} \\\\ \\varepsilon_{yy} \\\\ \\gamma_{xy} \\end{bmatrix} = \\begin{bmatrix} \\partial/\\partial x & 0 \\\\ 0 & \\partial/\\partial y \\\\ \\partial/\\partial y & \\partial/\\partial x \\end{bmatrix} \\begin{bmatrix} u_x \\\\ u_y \\end{bmatrix} = \\mathbf{L}\\mathbf{u} $$\nSubstituting the displacement interpolation, we get $\\boldsymbol{\\varepsilon}_{\\text{voigt}} = \\mathbf{L}(\\mathbf{N} \\mathbf{d}^e) = (\\mathbf{L}\\mathbf{N}) \\mathbf{d}^e = \\mathbf{B} \\mathbf{d}^e$. The matrix $\\mathbf{B}$ is the strain-displacement matrix:\n$$ \\mathbf{B} = \\mathbf{L}\\mathbf{N} = \\begin{bmatrix} \\frac{\\partial N_1}{\\partial x} & 0 & \\frac{\\partial N_2}{\\partial x} & 0 & \\frac{\\partial N_3}{\\partial x} & 0 \\\\ 0 & \\frac{\\partial N_1}{\\partial y} & 0 & \\frac{\\partial N_2}{\\partial y} & 0 & \\frac{\\partial N_3}{\\partial y} \\\\ \\frac{\\partial N_1}{\\partial y} & \\frac{\\partial N_1}{\\partial x} & \\frac{\\partial N_2}{\\partial y} & \\frac{\\partial N_2}{\\partial x} & \\frac{\\partial N_3}{\\partial y} & \\frac{\\partial N_3}{\\partial x} \\end{bmatrix} $$\nFor a linear triangular element, the shape functions $N_i(x,y)$ are linear in coordinates, so their derivatives are constant. Consequently, the $\\mathbf{B}$ matrix is constant throughout the element. The shape functions are $N_i(x,y) = \\frac{1}{2A}(a_i + b_i x + c_i y)$, where $A$ is the element area, and $a_i = x_j y_k - x_k y_j$, $b_i = y_j - y_k$, $c_i = x_k - x_j$ for a cyclic permutation $(i,j,k)$ of $(1,2,3)$. The derivatives are $\\frac{\\partial N_i}{\\partial x} = \\frac{b_i}{2A}$ and $\\frac{\\partial N_i}{\\partial y} = \\frac{c_i}{2A}$. The area is $A = \\frac{1}{2} \\det \\begin{pmatrix} 1 & x_1 & y_1 \\\\ 1 & x_2 & y_2 \\\\ 1 & x_3 & y_3 \\end{pmatrix}$.\nThe virtual strain is $\\delta\\boldsymbol{\\varepsilon}_{\\text{voigt}} = \\mathbf{B} \\delta\\mathbf{d}^e$.\n\n**4. Constitutive Relation**\nFor a linear elastic isotropic material under plane strain conditions, the stress-strain relationship $\\boldsymbol{\\sigma}_{\\text{voigt}} = \\mathbf{D} \\boldsymbol{\\varepsilon}_{\\text{voigt}}$ is defined by the elasticity matrix $\\mathbf{D}$. Using the Lamé parameters $\\lambda$ and $\\mu$ (shear modulus), the matrix is:\n$$ \\mathbf{D} = \\begin{bmatrix} \\lambda+2\\mu & \\lambda & 0 \\\\ \\lambda & \\lambda+2\\mu & 0 \\\\ 0 & 0 & \\mu \\end{bmatrix} $$\nThe Lamé parameters are related to Young's modulus $E$ and Poisson's ratio $\\nu$ by:\n$$ \\lambda = \\frac{E\\nu}{(1+\\nu)(1-2\\nu)}, \\quad \\mu = G = \\frac{E}{2(1+\\nu)} $$\n\n**5. Element Nodal Force Vectors**\nThe weak form can be expressed in terms of vector-matrix products as $\\int_{\\Omega} (\\delta\\boldsymbol{\\varepsilon}_{\\text{voigt}})^T \\boldsymbol{\\sigma}_{\\text{voigt}} \\, dV = \\int_{\\Omega} (\\delta\\mathbf{u})^T \\mathbf{b} \\, dV + \\int_{\\Gamma_t} (\\delta\\mathbf{u})^T \\bar{\\mathbf{t}} \\, dS$.\nSubstituting the FEM approximations for a single element $\\Omega^e$:\n$$ \\int_{\\Omega^e} (\\mathbf{B} \\delta\\mathbf{d}^e)^T \\boldsymbol{\\sigma}_{\\text{voigt}} \\, dV = \\int_{\\Omega^e} (\\mathbf{N} \\delta\\mathbf{d}^e)^T \\mathbf{b} \\, dV + \\int_{\\Gamma_t^e} (\\mathbf{N} \\delta\\mathbf{d}^e)^T \\bar{\\mathbf{t}} \\, dS $$\n$$ (\\delta\\mathbf{d}^e)^T \\int_{\\Omega^e} \\mathbf{B}^T \\boldsymbol{\\sigma}_{\\text{voigt}} \\, dV = (\\delta\\mathbf{d}^e)^T \\left( \\int_{\\Omega^e} \\mathbf{N}^T \\mathbf{b} \\, dV + \\int_{\\Gamma_t^e} \\mathbf{N}^T \\bar{\\mathbf{t}} \\, dS \\right) $$\nSince this equation must hold for any arbitrary virtual nodal displacement $\\delta\\mathbf{d}^e$, we can equate the vector coefficients. This defines the internal and external nodal force vectors.\n\nThe **internal nodal force vector** $\\mathbf{f}_{\\text{int}}^e$ is defined from the internal virtual work:\n$$ \\mathbf{f}_{\\text{int}}^e = \\int_{\\Omega^e} \\mathbf{B}^T \\boldsymbol{\\sigma}_{\\text{voigt}} \\, dV $$\nFor a linear triangular element with constant thickness $h$, the integrand is constant over the element area $A$. The integral simplifies to:\n$$ \\mathbf{f}_{\\text{int}}^e = \\mathbf{B}^T \\boldsymbol{\\sigma}_{\\text{voigt}} A h $$\nwhere $\\boldsymbol{\\sigma}_{\\text{voigt}} = \\mathbf{D} \\boldsymbol{\\varepsilon}_{\\text{voigt}} = \\mathbf{D} \\mathbf{B} \\mathbf{d}^e$.\n\nThe **external nodal force vector** $\\mathbf{f}_{\\text{ext}}^e$ is defined from the external virtual work and consists of contributions from body forces and surface tractions:\n$$ \\mathbf{f}_{\\text{ext}}^e = \\mathbf{f}_{\\text{body}}^e + \\mathbf{f}_{\\text{traction}}^e $$\nThe **body force vector** $\\mathbf{f}_{\\text{body}}^e$ is:\n$$ \\mathbf{f}_{\\text{body}}^e = \\int_{\\Omega^e} \\mathbf{N}^T \\mathbf{b} \\, dV = h \\int_{A^e} \\mathbf{N}^T \\mathbf{b} \\, dA $$\nAssuming a constant body force $\\mathbf{b} = [b_x, b_y]^T$, and using the identity $\\int_A N_i \\, dA = A/3$, the integral yields:\n$$ \\mathbf{f}_{\\text{body}}^e = \\frac{A h}{3} [b_x, b_y, b_x, b_y, b_x, b_y]^T $$\nThis shows that the total body force on the element, $\\mathbf{b} A h$, is distributed equally among the three nodes.\n\nThe **traction force vector** $\\mathbf{f}_{\\text{traction}}^e$ is:\n$$ \\mathbf{f}_{\\text{traction}}^e = \\int_{\\Gamma_t^e} \\mathbf{N}^T \\bar{\\mathbf{t}} \\, dS $$\nFor a uniform traction $\\bar{\\mathbf{t}} = [\\bar{t}_x, \\bar{t}_y]^T$ applied over an element edge from node $i$ to node $j$ of length $L_{ij}$, the integral becomes:\n$$ \\mathbf{f}_{\\text{traction}}^e = h \\int_{L_{ij}} \\mathbf{N}^T \\bar{\\mathbf{t}} \\, dL $$\nOn this edge, only shape functions $N_i$ and $N_j$ are non-zero. The nodal force contribution for a generic node $k$ is $\\mathbf{f}_k = h \\bar{\\mathbf{t}} \\int_{L_{ij}} N_k \\, dL$.\nThe integral of a linear shape function over its corresponding edge (from $1$ to $0$) is $\\int_{L_{ij}} N_i \\, dL = L_{ij}/2$ and $\\int_{L_{ij}} N_j \\, dL = L_{ij}/2$. Therefore, the total traction force $\\bar{\\mathbf{t}} L_{ij} h$ on the edge is distributed equally to the two nodes on that edge. The force contributions are:\n$$ \\mathbf{f}_i = \\frac{L_{ij} h}{2} \\begin{bmatrix} \\bar{t}_x \\\\ \\bar{t}_y \\end{bmatrix}, \\quad \\mathbf{f}_j = \\frac{L_{ij} h}{2} \\begin{bmatrix} \\bar{t}_x \\\\ \\bar{t}_y \\end{bmatrix} $$\nThe element traction vector $\\mathbf{f}_{\\text{traction}}^e$ is assembled by placing these contributions into the appropriate positions corresponding to the degrees of freedom of nodes $i$ and $j$.\n\nThis concludes the required derivations. The implementation will follow these final formulae.", "answer": "```python\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Main function to process test cases and print results.\n    \"\"\"\n    test_cases = [\n        {\n            \"nodes\": np.array([[0.0, 0.0], [2.0, 0.0], [0.0, 1.0]]),\n            \"thickness\": 1.0,\n            \"E\": 3.0e7,\n            \"nu\": 0.30,\n            \"displacements\": np.array([0.0, 0.0, 0.001, 0.0, 0.0, 0.0005]),\n            \"body_force_density\": 1800.0,\n            \"gravity\": 9.81,\n            \"body_force_vector\": None, # Will be calculated from density\n            \"traction\": {\"edge_nodes\": (2, 3), \"vector\": np.array([5000.0, 0.0])}\n        },\n        {\n            \"nodes\": np.array([[0.0, 0.0], [1.0, 0.0], [0.0, 1.0]]),\n            \"thickness\": 0.5,\n            \"E\": 5.0e7,\n            \"nu\": 0.25,\n            \"displacements\": np.array([0.0, 0.0, 0.0, 0.0, 0.0, 0.0]),\n            \"body_force_density\": None,\n            \"gravity\": None,\n            \"body_force_vector\": np.array([1000.0, -500.0]),\n            \"traction\": None\n        },\n        {\n            \"nodes\": np.array([[1.0, 1.0], [3.0, 1.0], [2.0, 2.5]]),\n            \"thickness\": 1.2,\n            \"E\": 1.0e7,\n            \"nu\": 0.35,\n            \"displacements\": np.array([0.0002, -0.0001, 0.0004, 0.0, 0.0003, 0.0002]),\n            \"body_force_density\": None,\n            \"gravity\": None,\n            \"body_force_vector\": np.array([0.0, 0.0]),\n            \"traction\": {\"edge_nodes\": (1, 2), \"vector\": np.array([0.0, 2000.0])}\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        f_int, f_ext = calculate_forces(case)\n        results.append([\n            [round(x, 6) for x in f_int],\n            [round(x, 6) for x in f_ext]\n        ])\n\n    # Custom formatting to match the precise output string requirement\n    case_strings = []\n    for res_pair in results:\n        f_int_str = f\"[{','.join(f'{x:.6f}' for x in res_pair[0])}]\"\n        f_ext_str = f\"[{','.join(f'{x:.6f}' for x in res_pair[1])}]\"\n        case_strings.append(f\"[{f_int_str},{f_ext_str}]\")\n    \n    final_output_str = f\"[{','.join(case_strings)}]\"\n    print(final_output_str.replace(\" \", \"\"))\n\n\ndef calculate_forces(case):\n    \"\"\"\n    Calculates the internal and external nodal force vectors for a single linear triangular element.\n\n    Args:\n        case (dict): A dictionary containing all the parameters for the element.\n\n    Returns:\n        tuple[np.ndarray, np.ndarray]: A tuple containing the internal force vector\n                                       and the external force vector.\n    \"\"\"\n    nodes = case[\"nodes\"]\n    h = case[\"thickness\"]\n    E = case[\"E\"]\n    nu = case[\"nu\"]\n    d = case[\"displacements\"]\n\n    # 1. Geometric properties and B matrix\n    (x1, y1), (x2, y2), (x3, y3) = nodes[0], nodes[1], nodes[2]\n    \n    # Area of the triangle\n    # For counterclockwise nodes, this is positive\n    area = 0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2))\n\n    b1, b2, b3 = y2 - y3, y3 - y1, y1 - y2\n    c1, c2, c3 = x3 - x2, x1 - x3, x2 - x1\n\n    # Strain-displacement matrix (B)\n    B = (1 / (2 * area)) * np.array([\n        [b1, 0, b2, 0, b3, 0],\n        [0, c1, 0, c2, 0, c3],\n        [c1, b1, c2, b2, c3, b3]\n    ])\n\n    # 2. Constitutive relation (D matrix for plane strain)\n    # Lamé parameters\n    lame_lambda = (E * nu) / ((1 + nu) * (1 - 2 * nu))\n    lame_mu = E / (2 * (1 + nu))  # Also shear modulus G\n\n    D = np.array([\n        [lame_lambda + 2 * lame_mu, lame_lambda, 0],\n        [lame_lambda, lame_lambda + 2 * lame_mu, 0],\n        [0, 0, lame_mu]\n    ])\n\n    # 3. Internal Nodal Force Vector (f_int)\n    if np.all(d == 0):\n        f_int = np.zeros(6)\n    else:\n        # Strain vector (epsilon)\n        epsilon = B @ d\n        # Stress vector (sigma)\n        sigma = D @ epsilon\n        # Internal force vector\n        f_int = B.T @ sigma * area * h\n\n    # 4. External Nodal Force Vector (f_ext)\n    f_ext = np.zeros(6)\n\n    # Body force contribution\n    if case[\"body_force_vector\"] is not None:\n        b = case[\"body_force_vector\"]\n    elif case[\"body_force_density\"] is not None:\n        b = np.array([0.0, -case[\"body_force_density\"] * case[\"gravity\"]])\n    else:\n        b = np.array([0.0, 0.0])\n\n    if not np.all(b == 0):\n        f_body_per_node = (area * h / 3.0) * b\n        for i in range(3):\n            f_ext[2*i : 2*i+2] += f_body_per_node\n\n    # Traction force contribution\n    if case[\"traction\"] is not None:\n        traction_data = case[\"traction\"]\n        node_i_idx, node_j_idx = traction_data[\"edge_nodes\"]\n        t_bar = traction_data[\"vector\"]\n\n        # Node indices are 1-based in problem, convert to 0-based for array access\n        node_i = nodes[node_i_idx - 1]\n        node_j = nodes[node_j_idx - 1]\n        \n        edge_length = math.sqrt((node_i[0] - node_j[0])**2 + (node_i[1] - node_j[1])**2)\n        \n        f_traction_per_node = (edge_length * h / 2.0) * t_bar\n        \n        f_ext[2*(node_i_idx-1) : 2*(node_i_idx-1)+2] += f_traction_per_node\n        f_ext[2*(node_j_idx-1) : 2*(node_j_idx-1)+2] += f_traction_per_node\n        \n    return f_int.flatten(), f_ext.flatten()\n\n\nsolve()\n\n```", "id": "3565463"}, {"introduction": "A correct finite element implementation must satisfy basic consistency requirements to ensure that it converges to the correct physical solution as the mesh is refined. The patch test is a fundamental benchmark that verifies an element's ability to exactly reproduce a constant strain state, a necessary condition for convergence [@problem_id:3565514]. In this exercise, you will implement this critical test, connecting your understanding of the discretized weak form to the core principles of accuracy and reliability in computational mechanics.", "problem": "Consider the two-dimensional small-strain linear elasticity problem for a homogeneous, isotropic geomaterial under plane strain conditions on a polygonal domain $\\Omega \\subset \\mathbb{R}^2$ with boundary $\\Gamma$. Let $\\boldsymbol{u} = [u,v]^\\mathsf{T}$ denote the displacement field, $\\boldsymbol{\\varepsilon} = [\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy}]^\\mathsf{T}$ the engineering strain vector, and $\\boldsymbol{\\sigma} = [\\sigma_{xx}, \\sigma_{yy}, \\tau_{xy}]^\\mathsf{T}$ the stress vector. The material is characterized by Young's modulus $E$ and Poisson's ratio $\\nu$. Body forces are absent (i.e., $\\boldsymbol{b} = \\boldsymbol{0}$). The strong form consists of the equilibrium equation within $\\Omega$, the kinematic relation, and the constitutive law, together with appropriate boundary conditions on $\\Gamma$. Using the Principle of Virtual Work (PVW), the weak form is obtained by taking virtual displacements $\\delta \\boldsymbol{u}$ compatible with essential boundary conditions, leading to internal virtual work balancing external virtual work.\n\nYou must construct a program that, starting from the weak form and using linear triangular finite elements, implements a patch test to verify exact reproduction of constant strain states. The patch test prescribes a linear displacement field of the form\n$u(x,y) = a_0 + a_1 x + a_2 y$ and $v(x,y) = b_0 + b_1 x + b_2 y$,\nwhich induces a constant strain state $\\boldsymbol{\\varepsilon}^\\text{exact}$ everywhere in $\\Omega$. The program must assemble the global stiffness matrix derived from the weak form, enforce essential boundary conditions, solve for nodal displacements, and compute the finite element strains per element. The key test is to quantify the discrepancy between the computed element strains and the exact constant strain $\\boldsymbol{\\varepsilon}^\\text{exact}$, with the expectation that the discrepancy is zero up to numerical round-off for correctly implemented linear triangular elements.\n\nYour implementation must follow these requirements:\n\n- Start from the equilibrium equation $\\nabla \\cdot \\boldsymbol{\\sigma} + \\boldsymbol{b} = \\boldsymbol{0}$, the small-strain kinematics, and linear elastic constitutive relations under plane strain. Derive the weak form using the Principle of Virtual Work, and from it, derive the element stiffness contributions for linear triangular elements (three-node triangles) and the global assembly process. Do not write shortcut formulas in the problem statement; they must be derived in the solution.\n- For each linear triangular element, use the appropriate shape functions and the corresponding constant strain-displacement matrix to obtain a constant strain per element. Assemble the global stiffness matrix $\\boldsymbol{K}$ and the global force vector $\\boldsymbol{f}$, apply essential boundary conditions via displacement constraints consistent with the prescribed linear field at specified boundary nodes, and solve $\\boldsymbol{K} \\boldsymbol{u} = \\boldsymbol{f}$.\n- Compute, for each element, the finite element strain $\\boldsymbol{\\varepsilon}^\\text{FE}$ from the solved nodal displacements and compare it to $\\boldsymbol{\\varepsilon}^\\text{exact}$ induced by the prescribed linear field. Use the maximum absolute component-wise strain error over all elements as the scalar error metric: $\\max_{e \\in \\text{elements}} \\left( \\max \\left| \\boldsymbol{\\varepsilon}^\\text{FE}_e - \\boldsymbol{\\varepsilon}^\\text{exact} \\right| \\right)$, expressed as a floating-point number without physical units (dimensionless).\n- Additionally, include an edge test that demonstrates the necessity of removing rigid body modes by detecting a singular system when no essential boundary conditions are applied. In that case, return a boolean indicating singularity detection.\n\nTest Suite Specification:\n\nImplement the following four test cases. For each case, the material parameters $(E,\\nu)$, the nodal coordinates, the element connectivity, the set of nodes with prescribed displacements, and the linear displacement coefficients $(a_0,a_1,a_2,b_0,b_1,b_2)$ are specified. Angles do not appear; no angle unit is required. All outputs are dimensionless.\n\n- Case $1$ (happy path, square patch):\n  - Material: $E=1000$, $\\nu=0.25$.\n  - Nodes: index $0:(0,0)$, $1:(1,0)$, $2:(1,1)$, $3:(0,1)$.\n  - Elements (triangles, each as $(n_1,n_2,n_3)$): $(0,1,2)$ and $(0,2,3)$.\n  - Essential boundary nodes: $\\{0,1,2,3\\}$ (both $u$ and $v$ constrained to the linear field).\n  - Linear field coefficients: $a_0=0$, $a_1=0.01$, $a_2=0.02$, $b_0=0$, $b_1=-0.03$, $b_2=0.04$.\n  - Output: the maximum absolute strain error as a floating-point number.\n\n- Case $2$ (skewed patch, near-incompressibility):\n  - Material: $E=2000$, $\\nu=0.49$.\n  - Nodes: index $0:(0,0)$, $1:(1.2,0.1)$, $2:(1.0,1.1)$, $3:(-0.1,0.9)$.\n  - Elements: $(0,1,2)$ and $(0,2,3)$.\n  - Essential boundary nodes: $\\{0,1,2,3\\}$.\n  - Linear field coefficients: $a_0=0$, $a_1=0.01$, $a_2=0.02$, $b_0=0$, $b_1=-0.03$, $b_2=0.04$.\n  - Output: the maximum absolute strain error as a floating-point number.\n\n- Case $3$ (patch with interior node and four triangles):\n  - Material: $E=500$, $\\nu=0.30$.\n  - Nodes: index $0:(0,0)$, $1:(1,0)$, $2:(1,1)$, $3:(0,1)$, $4:(0.5,0.5)$.\n  - Elements: $(0,1,4)$, $(1,2,4)$, $(2,3,4)$, $(3,0,4)$.\n  - Essential boundary nodes: $\\{0,1,2,3\\}$.\n  - Linear field coefficients: $a_0=0$, $a_1=0.02$, $a_2=-0.01$, $b_0=0$, $b_1=0.015$, $b_2=0.005$.\n  - Output: the maximum absolute strain error as a floating-point number.\n\n- Case $4$ (edge case, no constraints: detect singular system):\n  - Material: $E=1000$, $\\nu=0.25$.\n  - Nodes and elements identical to Case $1$.\n  - Essential boundary nodes: empty set.\n  - Linear field coefficients: $a_0=0$, $a_1=0.01$, $a_2=0.02$, $b_0=0$, $b_1=-0.03$, $b_2=0.04$.\n  - Output: a boolean indicating whether the global linear system is singular.\n\nFinal Output Format:\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the four test cases. For example, if the first three cases produce floating-point strain errors and the fourth produces a boolean, the output must be of the form $[\\text{float}_1,\\text{float}_2,\\text{float}_3,\\text{boolean}_4]$ with no spaces.", "solution": "We start from the foundational equations of small-strain linear elasticity. In the absence of body forces, equilibrium in the domain $\\Omega$ is given by $\\nabla \\cdot \\boldsymbol{\\sigma} = \\boldsymbol{0}$. The small-strain kinematics relate the displacement field $\\boldsymbol{u}=[u,v]^\\mathsf{T}$ to the engineering strain vector $\\boldsymbol{\\varepsilon}=[\\varepsilon_{xx},\\varepsilon_{yy},\\gamma_{xy}]^\\mathsf{T}$ through\n$$\n\\varepsilon_{xx} = \\frac{\\partial u}{\\partial x}, \\quad \\varepsilon_{yy} = \\frac{\\partial v}{\\partial y}, \\quad \\gamma_{xy} = \\frac{\\partial u}{\\partial y} + \\frac{\\partial v}{\\partial x}.\n$$\nUnder plane strain with an isotropic material, the constitutive law is linear elastic:\n$$\n\\boldsymbol{\\sigma} = \\boldsymbol{D} \\, \\boldsymbol{\\varepsilon},\n$$\nwhere for plane strain the stiffness matrix $\\boldsymbol{D}$ is\n$$\n\\boldsymbol{D} = \n\\begin{bmatrix}\n\\lambda + 2\\mu & \\lambda & 0 \\\\\n\\lambda & \\lambda + 2\\mu & 0 \\\\\n0 & 0 & \\mu\n\\end{bmatrix}, \\quad\n\\lambda = \\frac{E \\nu}{(1+\\nu)(1-2\\nu)}, \\quad\n\\mu = \\frac{E}{2(1+\\nu)}.\n$$\nThe Principle of Virtual Work (PVW) states that, for all virtual displacements $\\delta \\boldsymbol{u}$ compatible with essential boundary conditions,\n$$\n\\int_{\\Omega} \\boldsymbol{\\varepsilon}(\\delta \\boldsymbol{u})^\\mathsf{T} \\boldsymbol{\\sigma} \\, \\mathrm{d}\\Omega = \\int_{\\Omega} \\delta \\boldsymbol{u}^\\mathsf{T} \\boldsymbol{b} \\, \\mathrm{d}\\Omega + \\int_{\\Gamma_t} \\delta \\boldsymbol{u}^\\mathsf{T} \\boldsymbol{t} \\, \\mathrm{d}\\Gamma,\n$$\nwhere $\\Gamma_t$ is the part of the boundary with prescribed tractions $\\boldsymbol{t}$ and $\\boldsymbol{b}=\\boldsymbol{0}$ here. Substituting the constitutive law and the kinematic relations, and introducing a finite element approximation $\\boldsymbol{u}^h$ with nodal degrees of freedom yields the discrete system\n$$\n\\boldsymbol{K} \\boldsymbol{u} = \\boldsymbol{f},\n$$\nwith the global stiffness matrix $\\boldsymbol{K}$ assembled from element stiffness contributions and $\\boldsymbol{f}$ containing consistent external forces (which are zero in our patch tests with purely essential boundary conditions).\n\nFor a linear triangular element with three nodes, the displacement field within an element is interpolated as\n$$\nu(x,y) = \\sum_{i=1}^{3} N_i(x,y) u_i, \\quad v(x,y) = \\sum_{i=1}^{3} N_i(x,y) v_i,\n$$\nwhere $N_i$ are linear shape functions. For such an element, the strain-displacement relation reduces to a constant matrix $\\boldsymbol{B}$ per element:\n$$\n\\boldsymbol{\\varepsilon} = \\boldsymbol{B} \\boldsymbol{d}_e, \\quad \\boldsymbol{d}_e = [u_1,v_1,u_2,v_2,u_3,v_3]^\\mathsf{T},\n$$\nwith\n$$\n\\boldsymbol{B} = \n\\begin{bmatrix}\n\\frac{\\partial N_1}{\\partial x} & 0 & \\frac{\\partial N_2}{\\partial x} & 0 & \\frac{\\partial N_3}{\\partial x} & 0 \\\\\n0 & \\frac{\\partial N_1}{\\partial y} & 0 & \\frac{\\partial N_2}{\\partial y} & 0 & \\frac{\\partial N_3}{\\partial y} \\\\\n\\frac{\\partial N_1}{\\partial y} & \\frac{\\partial N_1}{\\partial x} & \\frac{\\partial N_2}{\\partial y} & \\frac{\\partial N_2}{\\partial x} & \\frac{\\partial N_3}{\\partial y} & \\frac{\\partial N_3}{\\partial x}\n\\end{bmatrix}.\n$$\nThe derivatives of the linear shape functions are constant within the element and computed from the nodal coordinates $(x_i,y_i)$ as follows. Define the signed area of the triangle\n$$\nA = \\frac{1}{2}\\left( x_2 y_3 - x_3 y_2 - x_1 y_3 + x_3 y_1 + x_1 y_2 - x_2 y_1 \\right).\n$$\nThen the coefficients\n$$\nb_1 = y_2 - y_3,\\quad c_1 = x_3 - x_2, \\quad\nb_2 = y_3 - y_1,\\quad c_2 = x_1 - x_3, \\quad\nb_3 = y_1 - y_2,\\quad c_3 = x_2 - x_1,\n$$\nyield the constant derivatives\n$$\n\\frac{\\partial N_i}{\\partial x} = \\frac{b_i}{2A}, \\quad \\frac{\\partial N_i}{\\partial y} = \\frac{c_i}{2A}, \\quad i=1,2,3.\n$$\nThe element stiffness matrix is obtained directly from PVW:\n$$\n\\boldsymbol{K}_e = \\int_{\\Omega_e} \\boldsymbol{B}^\\mathsf{T} \\boldsymbol{D} \\boldsymbol{B} \\, \\mathrm{d}\\Omega = \\boldsymbol{B}^\\mathsf{T} \\boldsymbol{D} \\boldsymbol{B} \\, A,\n$$\nbecause $\\boldsymbol{B}$ is constant over the element. The global stiffness matrix $\\boldsymbol{K}$ is assembled by summing $\\boldsymbol{K}_e$ into the appropriate positions corresponding to the element's nodal degrees of freedom.\n\nEssential boundary conditions are imposed by prescribing nodal displacements at selected nodes according to the linear field\n$$\nu(x,y) = a_0 + a_1 x + a_2 y, \\quad v(x,y) = b_0 + b_1 x + b_2 y,\n$$\nwhich induces the exact constant strain\n$$\n\\boldsymbol{\\varepsilon}^\\text{exact} = \\begin{bmatrix} a_1 \\\\ b_2 \\\\ a_2 + b_1 \\end{bmatrix}.\n$$\nEnforcement of essential boundary conditions is performed by directly setting the corresponding rows and columns of $\\boldsymbol{K}$ to enforce $\\boldsymbol{u} = \\boldsymbol{u}^\\text{prescribed}$ at those degrees of freedom, typically by replacing the row by a unit row and the right-hand side entry by the prescribed displacement.\n\nOnce the linear system is solved for $\\boldsymbol{u}$, the finite element strain in each element is computed by\n$$\n\\boldsymbol{\\varepsilon}^\\text{FE}_e = \\boldsymbol{B}_e \\boldsymbol{d}_e,\n$$\nand compared to $\\boldsymbol{\\varepsilon}^\\text{exact}$. The patch test metric is the maximum absolute difference over all elements and components:\n$$\n\\text{error} = \\max_{e} \\left( \\max_{j \\in \\{xx,yy,xy\\}} \\left| \\boldsymbol{\\varepsilon}^\\text{FE}_{e,j} - \\boldsymbol{\\varepsilon}^\\text{exact}_{j} \\right| \\right).\n$$\nFor linear triangular elements, exact reproduction of a constant strain state is expected, so the error should be at the level of machine precision for correctly implemented formulations.\n\nFor the singular system detection (edge case), when no essential boundary conditions are enforced and no body forces or tractions are present, the global stiffness matrix $\\boldsymbol{K}$ is singular due to rigid body modes (two translations and one rotation in two dimensions). Solving $\\boldsymbol{K} \\boldsymbol{u} = \\boldsymbol{0}$ will fail due to singularity, which we detect and return a boolean flag indicating singularity.\n\nAlgorithmic steps implemented in the program:\n\n- Construct node coordinates and element connectivity for each test case.\n- Assemble the global stiffness matrix using $\\boldsymbol{K}_e = \\boldsymbol{B}^\\mathsf{T}\\boldsymbol{D}\\boldsymbol{B} A$ for each element.\n- Compute the prescribed displacements at essential boundary nodes via the linear field and enforce them by modifying $\\boldsymbol{K}$ and $\\boldsymbol{f}$.\n- Solve the linear system; if singular, catch the exception and return the singularity indicator.\n- Compute $\\boldsymbol{\\varepsilon}^\\text{FE}_e$ for all elements and the error metric against $\\boldsymbol{\\varepsilon}^\\text{exact}$.\n- Aggregate results for all test cases and print in the specified single-line format.\n\nThis procedure directly embodies the weak form derived from the Principle of Virtual Work and tests the polynomial completeness property of linear triangular elements in reproducing constant strain states.", "answer": "```python\nimport numpy as np\n\ndef plane_strain_D(E, nu):\n    # Lamé parameters for plane strain\n    lam = E * nu / ((1 + nu) * (1 - 2 * nu))\n    mu = E / (2 * (1 + nu))\n    D = np.array([\n        [lam + 2 * mu, lam, 0.0],\n        [lam, lam + 2 * mu, 0.0],\n        [0.0, 0.0, mu]\n    ])\n    return D\n\ndef tri_B_and_area(coords):\n    # coords: array of shape (3,2) with node coordinates [(x1,y1),(x2,y2),(x3,y3)]\n    x1, y1 = coords[0]\n    x2, y2 = coords[1]\n    x3, y3 = coords[2]\n    A = 0.5 * (x2 * y3 - x3 * y2 - x1 * y3 + x3 * y1 + x1 * y2 - x2 * y1)\n    if A == 0.0:\n        raise ValueError(\"Degenerate triangle with zero area.\")\n    b1 = y2 - y3\n    c1 = x3 - x2\n    b2 = y3 - y1\n    c2 = x1 - x3\n    b3 = y1 - y2\n    c3 = x2 - x1\n    dN1dx = b1 / (2.0 * A); dN1dy = c1 / (2.0 * A)\n    dN2dx = b2 / (2.0 * A); dN2dy = c2 / (2.0 * A)\n    dN3dx = b3 / (2.0 * A); dN3dy = c3 / (2.0 * A)\n    B = np.array([\n        [dN1dx, 0.0,    dN2dx, 0.0,    dN3dx, 0.0],\n        [0.0,    dN1dy, 0.0,    dN2dy, 0.0,    dN3dy],\n        [dN1dy, dN1dx, dN2dy, dN2dx, dN3dy, dN3dx]\n    ])\n    return B, abs(A)\n\ndef assemble_global_K(nodes, elements, E, nu):\n    n_nodes = len(nodes)\n    ndof = 2 * n_nodes\n    K = np.zeros((ndof, ndof))\n    D = plane_strain_D(E, nu)\n    for elem in elements:\n        coords = np.array([nodes[elem[0]], nodes[elem[1]], nodes[elem[2]]], dtype=float)\n        B, A = tri_B_and_area(coords)\n        Ke = B.T @ D @ B * A\n        # Scatter into global K\n        dofs = []\n        for n in elem:\n            dofs.extend([2 * n, 2 * n + 1])\n        dofs = np.array(dofs, dtype=int)\n        K[np.ix_(dofs, dofs)] += Ke\n    return K\n\ndef apply_dirichlet(K, f, nodes, bc_nodes, coeffs):\n    # coeffs: (a0,a1,a2,b0,b1,b2)\n    a0, a1, a2, b0, b1, b2 = coeffs\n    ndof = K.shape[0]\n    u_prescribed = np.zeros(ndof)\n    for n in bc_nodes:\n        x, y = nodes[n]\n        u_val = a0 + a1 * x + a2 * y\n        v_val = b0 + b1 * x + b2 * y\n        u_prescribed[2 * n] = u_val\n        u_prescribed[2 * n + 1] = v_val\n    # Enforce Dirichlet by row/column modification\n    for n in bc_nodes:\n        for comp in [0, 1]:\n            dof = 2 * n + comp\n            # Zero row and column, set diagonal to 1\n            K[dof, :] = 0.0\n            K[:, dof] = 0.0\n            K[dof, dof] = 1.0\n            f[dof] = u_prescribed[dof]\n    return K, f\n\ndef solve_system(K, f):\n    try:\n        u = np.linalg.solve(K, f)\n        return u, False  # not singular\n    except np.linalg.LinAlgError:\n        return None, True  # singular system\n\ndef element_strain(B, elem_nodes, u):\n    # Extract element dofs\n    dofs = []\n    for n in elem_nodes:\n        dofs.extend([2 * n, 2 * n + 1])\n    dofs = np.array(dofs, dtype=int)\n    de = u[dofs]\n    eps = B @ de\n    return eps\n\ndef exact_strain_from_coeffs(coeffs):\n    a0, a1, a2, b0, b1, b2 = coeffs\n    eps_exact = np.array([a1, b2, a2 + b1], dtype=float)\n    return eps_exact\n\ndef patch_test_error(nodes, elements, E, nu, bc_nodes, coeffs):\n    n_nodes = len(nodes)\n    ndof = 2 * n_nodes\n    K = assemble_global_K(nodes, elements, E, nu)\n    f = np.zeros(ndof)\n    if len(bc_nodes) > 0:\n        K_mod, f_mod = apply_dirichlet(K.copy(), f.copy(), nodes, bc_nodes, coeffs)\n        u, singular = solve_system(K_mod, f_mod)\n        if singular:\n            return True  # Should not happen with essential BCs; mark singular\n        # Compute strains and error\n        eps_exact = exact_strain_from_coeffs(coeffs)\n        max_err = 0.0\n        for elem in elements:\n            coords = np.array([nodes[elem[0]], nodes[elem[1]], nodes[elem[2]]], dtype=float)\n            B, A = tri_B_and_area(coords)\n            eps_fe = element_strain(B, elem, u)\n            err_comp = np.abs(eps_fe - eps_exact)\n            max_err = max(max_err, np.max(err_comp))\n        return float(max_err)\n    else:\n        # No essential BCs: expect singular system\n        u, singular = solve_system(K, f)\n        return bool(singular)\n\ndef solve():\n    # Define test cases as specified in the problem statement.\n    # Case 1\n    nodes1 = [\n        (0.0, 0.0),\n        (1.0, 0.0),\n        (1.0, 1.0),\n        (0.0, 1.0)\n    ]\n    elements1 = [\n        (0, 1, 2),\n        (0, 2, 3)\n    ]\n    E1, nu1 = 1000.0, 0.25\n    bc_nodes1 = [0, 1, 2, 3]\n    coeffs1 = (0.0, 0.01, 0.02, 0.0, -0.03, 0.04)\n\n    # Case 2\n    nodes2 = [\n        (0.0, 0.0),\n        (1.2, 0.1),\n        (1.0, 1.1),\n        (-0.1, 0.9)\n    ]\n    elements2 = [\n        (0, 1, 2),\n        (0, 2, 3)\n    ]\n    E2, nu2 = 2000.0, 0.49\n    bc_nodes2 = [0, 1, 2, 3]\n    coeffs2 = (0.0, 0.01, 0.02, 0.0, -0.03, 0.04)\n\n    # Case 3\n    nodes3 = [\n        (0.0, 0.0),\n        (1.0, 0.0),\n        (1.0, 1.0),\n        (0.0, 1.0),\n        (0.5, 0.5)\n    ]\n    elements3 = [\n        (0, 1, 4),\n        (1, 2, 4),\n        (2, 3, 4),\n        (3, 0, 4)\n    ]\n    E3, nu3 = 500.0, 0.30\n    bc_nodes3 = [0, 1, 2, 3]\n    coeffs3 = (0.0, 0.02, -0.01, 0.0, 0.015, 0.005)\n\n    # Case 4 (singular system)\n    nodes4 = nodes1\n    elements4 = elements1\n    E4, nu4 = 1000.0, 0.25\n    bc_nodes4 = []\n    coeffs4 = (0.0, 0.01, 0.02, 0.0, -0.03, 0.04)\n\n    test_cases = [\n        (nodes1, elements1, E1, nu1, bc_nodes1, coeffs1),\n        (nodes2, elements2, E2, nu2, bc_nodes2, coeffs2),\n        (nodes3, elements3, E3, nu3, bc_nodes3, coeffs3),\n        (nodes4, elements4, E4, nu4, bc_nodes4, coeffs4),\n    ]\n\n    results = []\n    for nodes, elements, E, nu, bc_nodes, coeffs in test_cases:\n        result = patch_test_error(nodes, elements, E, nu, bc_nodes, coeffs)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3565514"}]}