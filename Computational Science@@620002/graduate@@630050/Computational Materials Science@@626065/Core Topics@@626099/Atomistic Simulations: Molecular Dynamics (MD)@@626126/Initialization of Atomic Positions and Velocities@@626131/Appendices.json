{"hands_on_practices": [{"introduction": "Starting a simulation at the correct temperature is a fundamental requirement for obtaining physically meaningful results. This practice guides you through the process of initializing atomic velocities from the Maxwell-Boltzmann distribution, a cornerstone of statistical mechanics [@problem_id:3458384]. You will derive the necessary probability distribution from first principles and implement the Box-Muller transform, a classic method for generating normally distributed random numbers, while tackling real-world numerical stability challenges.", "problem": "You are tasked with implementing a program that initializes atomic velocity components for a monatomic gas according to physically justified principles used in computational materials science. Begin from first principles of statistical mechanics and basic probability theory, and construct the algorithm without relying on pre-supplied formulas. Your implementation and analysis must fulfill the following requirements.\n\n1. Physical basis and target distribution. Use the equipartition theorem and the Maxwell–Boltzmann distribution to argue that each Cartesian component of the velocity of a particle of mass $m$ in thermal equilibrium at temperature $T$ is an independent Gaussian random variable with zero mean and variance $\\sigma^2$, where $\\sigma^2$ must be derived from first principles. Express the final velocity components in meters per second (m/s). For clarity: the symbol $m$ must be in kilograms (kg), $T$ must be in kelvin (K), and Boltzmann’s constant $k_\\mathrm{B}$ must be correctly incorporated in SI units.\n\n2. Probabilistic transform. Derive, from the probability density of independent uniform random variables and a measure-preserving transformation, a method that maps two independent uniform random variables on the open interval $(0,1)$ to two independent standard normal random variables. The derivation must be grounded in the change-of-variables formula and a geometrically motivated transformation without stating any shortcut formulas in this problem statement. Angles must be treated in radians.\n\n3. Numerical robustness for large $N$. Your algorithm must address numerical stability issues when transforming uniform variates near $0$. Specifically:\n   - Introduce a strictly positive clipping threshold $\\epsilon$ such that any uniform variate $u_1$ used in the transformation satisfies $u_1 \\ge \\epsilon$ to avoid undefined logarithms and extreme values. The choice and effect of $\\epsilon$ must be analyzed.\n   - Implement a controllable injection of pathological inputs by forcing the first $K$ draws of $u_1$ to be exactly $0$ before clipping, to validate the clipping logic and quantify its effect.\n   - Quantify stability by reporting whether all generated velocity components are finite, and by reporting the maximum absolute component magnitude in m/s.\n\n4. Seed reproducibility. Use a Pseudorandom Number Generator (PRNG), defining it on first use as a Pseudorandom Number Generator (PRNG). For each test case, demonstrate reproducibility by generating the velocity components twice with the same seed and once with a different seed. Report exact equality checks as booleans.\n\n5. Computed diagnostics. For each test case, compute and report:\n   - The absolute sample mean of all components, in m/s.\n   - The relative error between the sample variance of all components and the theoretically derived variance $\\sigma^2$ (dimensionless), computed as $(\\hat{\\sigma}^2 - \\sigma^2)/\\sigma^2$.\n   - The maximum absolute component magnitude in m/s.\n   - The count of clipped uniform variates, i.e., how many $u_1$ were below $\\epsilon$ before clipping.\n   - A boolean indicating whether all components are finite.\n   - A boolean indicating whether two independent realizations with the same seed are exactly equal.\n   - A boolean indicating whether realizations with different seeds are exactly equal.\n\n6. Test suite. Implement and run the following scientifically grounded cases. Use the Argon atom mass $m = 6.6335209\\times 10^{-26}\\ \\mathrm{kg}$. Use the International System of Units (SI). For each case, generate three velocity components per atom (for $x$, $y$, and $z$), all in m/s. Angles must be radians.\n   - Case A (happy path): $N = 100000$, $T = 300\\ \\mathrm{K}$, $m = 6.6335209\\times 10^{-26}\\ \\mathrm{kg}$, seed $= 314159265$, $\\epsilon = 10^{-12}$, $K = 0$.\n   - Case B (stability stress with injected zero): $N = 100000$, $T = 300\\ \\mathrm{K}$, $m = 6.6335209\\times 10^{-26}\\ \\mathrm{kg}$, seed $= 271828182$, $\\epsilon = 10^{-16}$, $K = 1$.\n   - Case C (large $N$ reproducibility): $N = 500000$, $T = 1000\\ \\mathrm{K}$, $m = 6.6335209\\times 10^{-26}\\ \\mathrm{kg}$, seed $= 777$, $\\epsilon = 10^{-12}$, $K = 0$.\n   - Case D (boundary condition, minimal sample): $N = 1$, $T = 300\\ \\mathrm{K}$, $m = 6.6335209\\times 10^{-26}\\ \\mathrm{kg}$, seed $= 42$, $\\epsilon = 10^{-12}$, $K = 0$.\n\n7. Final output format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case result is itself a list with the seven entries described in item $5$ in the order stated. For example, the printed output must look like\n$[[\\text{float},\\text{float},\\text{float},\\text{int},\\text{bool},\\text{bool},\\text{bool}],[\\dots],\\dots]$\nwith no additional text.\n\nThe solution must be self-contained and runnable without user input. All computations of angles must be in radians. All reported velocities must be in $\\mathrm{m/s}$, and all other reported quantities must be dimensionless unless otherwise stated.", "solution": "The problem of initializing atomic velocities is a foundational task in computational materials science, particularly for methods like Molecular Dynamics (MD) simulations. The goal is to generate a set of velocities for a system of $N$ particles that is statistically consistent with a given thermodynamic state, specifically a canonical ensemble at temperature $T$. The solution requires a synthesis of principles from statistical mechanics, probability theory, and numerical methods.\n\n### 1. Physical Basis and Target Distribution\n\nThe physical foundation for this problem lies in classical statistical mechanics. According to the **equipartition theorem**, in a system at thermal equilibrium, the average energy associated with each quadratic degree of freedom in the system's Hamiltonian is equal to $\\frac{1}{2} k_{\\mathrm{B}} T$, where $k_{\\mathrm{B}}$ is the Boltzmann constant and $T$ is the absolute temperature.\n\nFor a monatomic gas, the atoms are treated as point masses. The kinetic energy $E_k$ of a single atom of mass $m$ is given by the sum of its kinetic energies along the three Cartesian axes:\n$$ E_k = \\frac{1}{2} m v_x^2 + \\frac{1}{2} m v_y^2 + \\frac{1}{2} m v_z^2 $$\nThe system's Hamiltonian contains these three terms, each being a quadratic function of a velocity component ($v_x$, $v_y$, or $v_z$). Therefore, each term corresponds to a degree of freedom to which the equipartition theorem applies. For any given velocity component, say $v_i$ where $i \\in \\{x, y, z\\}$, the average energy is:\n$$ \\left\\langle \\frac{1}{2} m v_i^2 \\right\\rangle = \\frac{1}{2} k_{\\mathrm{B}} T $$\nSince $m$ is a constant, this simplifies to:\n$$ \\langle v_i^2 \\rangle = \\frac{k_{\\mathrm{B}} T}{m} $$\nThe **Maxwell-Boltzmann distribution** describes the distribution of particle speeds in a gas at thermal equilibrium. A key consequence of this distribution is that the probability distribution for a single velocity component $v_i$ is a Gaussian (or normal) distribution. The probability density function $p(v_i)$ is proportional to the Boltzmann factor $\\exp(-E_i / (k_{\\mathrm{B}}T))$, where $E_i = \\frac{1}{2} m v_i^2$.\n$$ p(v_i) \\propto \\exp\\left(-\\frac{m v_i^2}{2 k_{\\mathrm{B}} T}\\right) $$\nThis is the functional form of a Gaussian distribution with zero mean. The mean velocity $\\langle v_i \\rangle$ must be zero, as there is no net drift of the gas in any direction in a simple equilibrium state.\n\nThe variance, $\\sigma_{v_i}^2$, of the velocity component $v_i$ is defined as $\\sigma_{v_i}^2 = \\langle (v_i - \\langle v_i \\rangle)^2 \\rangle$. Since $\\langle v_i \\rangle = 0$, the variance is simply $\\sigma_{v_i}^2 = \\langle v_i^2 \\rangle$. From our equipartition result, we have derived the theoretical variance:\n$$ \\sigma^2 \\equiv \\sigma_{v_i}^2 = \\frac{k_{\\mathrm{B}} T}{m} $$\nFurthermore, the velocity components $v_x$, $v_y$, and $v_z$ are statistically independent. Thus, each velocity component $v_i$ for each atom must be drawn from an independent and identical normal distribution $\\mathcal{N}(0, \\sigma^2)$ with mean $\\mu=0$ and variance $\\sigma^2 = k_{\\mathrm{B}} T / m$.\n\n### 2. Probabilistic Transform for Generating Normal Variates\n\nTo generate a random variable $v_i$ from the target distribution $\\mathcal{N}(0, \\sigma^2)$, we can first generate a standard normal variate $Z \\sim \\mathcal{N}(0, 1)$ and then scale it: $v_i = \\sigma Z$. The challenge is to generate standard normal variates from a source of randomness we can readily produce, which is typically uniform random variates on the interval $(0,1)$. The **Box-Muller transform** provides a method to convert two independent uniform random variables into two independent standard normal random variables. We derive this method from first principles.\n\nLet $U_1$ and $U_2$ be two independent random variables drawn from a uniform distribution on $(0,1)$. We seek a transformation $(Z_1, Z_2) = g(U_1, U_2)$ such that $Z_1$ and $Z_2$ are independent standard normal variables. The joint probability density function (PDF) for $(Z_1, Z_2)$ is the product of their individual PDFs:\n$$ p(z_1, z_2) = p(z_1)p(z_2) = \\left(\\frac{1}{\\sqrt{2\\pi}} e^{-z_1^2/2}\\right) \\left(\\frac{1}{\\sqrt{2\\pi}} e^{-z_2^2/2}\\right) = \\frac{1}{2\\pi} e^{-(z_1^2 + z_2^2)/2} $$\nThe derivation is facilitated by a change to polar coordinates $(R, \\Theta)$, where $Z_1 = R\\cos\\Theta$ and $Z_2 = R\\sin\\Theta$. The squared radius is $R^2 = Z_1^2 + Z_2^2$. The joint PDF in polar coordinates is found using the Jacobian of the transformation, which is $R$: $p(r, \\theta) dr d\\theta = p(z_1,z_2) dz_1 dz_2$.\n$$ p(r, \\theta) = \\frac{1}{2\\pi} e^{-r^2/2} \\cdot r $$\nThis joint PDF is separable into $p(r,\\theta) = (\\frac{1}{2\\pi}) \\cdot (r e^{-r^2/2})$. This shows that the angle $\\Theta$ is uniformly distributed on $[0, 2\\pi]$ and is independent of the radius $R$.\n\nWe can therefore generate $\\Theta$ from one of our uniform variates, say $U_2$, by a simple linear mapping:\n$$ \\Theta = 2\\pi U_2 $$\nTo generate $R$, we use the technique of inverse transform sampling. We first find the cumulative distribution function (CDF) for the random variable $S=R^2$. The PDF for $R$ is $p_R(r) = \\int_0^{2\\pi} p(r,\\theta) d\\theta = r e^{-r^2/2}$ for $r \\ge 0$. The CDF of $R$ is $F_R(r) = \\int_0^r s e^{-s^2/2} ds = 1-e^{-r^2/2}$. Then the CDF of $S=R^2$ for some value $s_0 \\ge 0$ is $F_S(s_0)=P(S \\le s_0) = P(R^2 \\le s_0) = P(R \\le \\sqrt{s_0}) = F_R(\\sqrt{s_0}) = 1 - e^{-s_0/2}$. This is the CDF of an exponential distribution with rate parameter $\\lambda=1/2$.\nBy inverse transform sampling, we can generate a variate $S$ by setting its CDF equal to a uniform random variate, say $U_1$:\n$$ U_1 = F_S(S) = 1 - e^{-S/2} $$\nSolving for $S$: $e^{-S/2} = 1 - U_1$, which gives $S = -2 \\ln(1 - U_1)$. As $U_1$ is uniform on $(0,1)$, the variable $1-U_1$ is also uniform on $(0,1)$. We can thus simplify the expression by using $U_1$ directly:\n$$ S = R^2 = -2 \\ln(U_1) $$\nCombining our results for $R$ (as $\\sqrt{S}$) and $\\Theta$, we can transform back to the Cartesian coordinates for $Z_1$ and $Z_2$:\n$$ Z_1 = R \\cos\\Theta = \\sqrt{-2 \\ln U_1} \\cos(2\\pi U_2) $$\n$$ Z_2 = R \\sin\\Theta = \\sqrt{-2 \\ln U_1} \\sin(2\\pi U_2) $$\nThis pair of equations constitutes the Box-Muller transform.\n\n### 3. Numerical Implementation Strategy\n\nThe overall algorithm to generate $3N$ velocity components is as follows:\n1.  Determine the number of pairs of random numbers required, which is $\\lceil 3N/2 \\rceil$.\n2.  Generate $2 \\times \\lceil 3N/2 \\rceil$ uniform random variates using a Pseudorandom Number Generator (PRNG) initialized with a specific seed for reproducibility. These are organized into pairs $(U_1, U_2)$.\n3.  The term $\\ln(U_1)$ in the Box-Muller transform is undefined at $U_1=0$ and diverges to $-\\infty$ as $U_1 \\to 0^+$. This can lead to floating-point overflow (`Inf`) or `NaN` values. To ensure numerical stability, we introduce a clipping threshold $\\epsilon > 0$ and enforce $U_1 \\ge \\epsilon$. Any generated $U_1 < \\epsilon$ is replaced by $\\epsilon$. This procedure bounds the magnitude of the generated velocities. We must count how many times this clipping is activated.\n4.  To validate the clipping mechanism, we can inject pathological inputs by forcing the first $K$ draws of $U_1$ to be exactly $0$ before the clipping is applied.\n5.  For each pair $(U_1, U_2)$, calculate the corresponding pair of standard normal variates $(Z_1, Z_2)$ using the derived Box-Muller formulae.\n6.  Collect all generated $Z$ values into a single array and truncate it to the required size of $3N$.\n7.  Scale each standard normal variate $Z_i$ by the standard deviation $\\sigma = \\sqrt{k_{\\mathrm{B}} T / m}$ to produce the final velocity components $v_i = \\sigma Z_i$.\n\n### 4. Reproducibility and Diagnostics\n\nUsing a PRNG with a specified seed ensures that the sequence of \"random\" numbers is deterministic and can be reproduced exactly. We verify this by running the generation process twice with the same seed and once with a different seed, checking for exact equality of the resulting velocity arrays.\n\nTo assess the quality and stability of the generated data, we compute several diagnostics for each test case:\n1.  **Absolute Sample Mean**: Should be close to the theoretical mean of $0$.\n2.  **Relative Variance Error**: Compares the sample variance $\\hat{\\sigma}^2$ of all $3N$ components to the theoretical variance $\\sigma^2$, as $(\\hat{\\sigma}^2 - \\sigma^2)/\\sigma^2$. This should be small for large $N$.\n3.  **Maximum Absolute Component Magnitude**: Provides a measure of the \"tail\" of the distribution and is directly affected by the clipping of $U_1$.\n4.  **Count of Clipped Variates**: Quantifies the impact of the numerical stability procedure.\n5.  **Finiteness Check**: A boolean to confirm that no `Inf` or `NaN` values were produced.\n6.  **Reproducibility Checks**: Booleans confirming that identical seeds produce identical results and different seeds produce different results.\n\nThese steps provide a complete, physically and mathematically sound procedure for initializing atomic velocities for simulation, complete with validation and robustness checks.", "answer": "```python\nimport numpy as np\n\ndef generate_velocities(N, T, m, seed, epsilon, K):\n    \"\"\"\n    Generates atomic velocity components based on the Maxwell-Boltzmann distribution.\n\n    Args:\n        N (int): Number of atoms.\n        T (float): Temperature in Kelvin.\n        m (float): Mass of one atom in kg.\n        seed (int): Seed for the Pseudorandom Number Generator (PRNG).\n        epsilon (float): Clipping threshold for uniform variates.\n        K (int): Number of pathological zero inputs to inject for u1.\n\n    Returns:\n        tuple: A tuple containing:\n            - np.ndarray: An array of 3*N velocity components (m/s).\n            - int: The number of clipped u1 variates.\n    \"\"\"\n    num_components = 3 * N\n    if num_components == 0:\n        return np.array([]), 0\n\n    # Number of pairs needed for Box-Muller transform\n    num_pairs = (num_components + 1) // 2\n\n    # Initialize a Pseudorandom Number Generator (PRNG) for reproducibility\n    rng = np.random.default_rng(seed)\n\n    # Generate uniform variates on (0, 1). Using 'low=np.finfo(float).tiny'\n    # is a robust way to avoid true zeros, but the problem requires\n    # handling zeros explicitly via clipping. So we use low=0.0.\n    u1 = rng.uniform(low=0.0, high=1.0, size=num_pairs)\n    u2 = rng.uniform(low=0.0, high=1.0, size=num_pairs)\n\n    # Inject K pathological inputs (force first K draws of u1 to zero)\n    if K > 0:\n        u1[:K] = 0.0\n\n    # Count how many u1 values are below the threshold *before* clipping\n    clipped_count = np.sum(u1  epsilon)\n\n    # Apply clipping to avoid log(0)\n    u1 = np.maximum(u1, epsilon)\n\n    # Box-Muller transform to get standard normal variates\n    mag = np.sqrt(-2.0 * np.log(u1))\n    z1 = mag * np.cos(2.0 * np.pi * u2)\n    z2 = mag * np.sin(2.0 * np.pi * u2)\n\n    # Interleave the pairs of standard normals into a single array\n    std_normals = np.empty(num_pairs * 2, dtype=float)\n    std_normals[0::2] = z1\n    std_normals[1::2] = z2\n\n    # Trim to the exact number of components required\n    std_normals = std_normals[:num_components]\n\n    # Scale by sigma = sqrt(k_B * T / m) to get final velocities\n    k_B = 1.380649e-23  # Boltzmann constant in J/K\n    sigma = np.sqrt((k_B * T) / m)\n    velocities = std_normals * sigma\n\n    return velocities, int(clipped_count)\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    m_Ar = 6.6335209e-26  # Mass of Argon atom in kg\n\n    test_cases = [\n        # N, T, m, seed, epsilon, K\n        (100000, 300.0, m_Ar, 314159265, 1e-12, 0),  # Case A\n        (100000, 300.0, m_Ar, 271828182, 1e-16, 1),  # Case B\n        (500000, 1000.0, m_Ar, 777, 1e-12, 0),      # Case C\n        (1, 300.0, m_Ar, 42, 1e-12, 0),              # Case D\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        N, T, m, seed, epsilon, K = case\n        k_B = 1.380649e-23\n\n        # Generate primary set of velocities\n        v_main, clips = generate_velocities(N, T, m, seed, epsilon, K)\n\n        # Generate again with same seed for reproducibility check\n        v_redux, _ = generate_velocities(N, T, m, seed, epsilon, K)\n\n        # Generate with a different seed for reproducibility check\n        v_other, _ = generate_velocities(N, T, m, seed + 1, epsilon, K)\n\n        # 1. Absolute sample mean\n        abs_sample_mean = np.abs(np.mean(v_main)) if v_main.size > 0 else 0.0\n\n        # 2. Relative variance error\n        if v_main.size > 1:\n            sample_variance = np.var(v_main)\n            theoretical_variance = (k_B * T) / m\n            relative_error_var = (sample_variance - theoretical_variance) / theoretical_variance\n        else:\n            # Variance is not well-defined for a single point, but np.var returns 0.\n            # Avoid division by zero, report a non-sensical but defined value.\n            relative_error_var = 0.0 if N == 0 else -1.0 # By definition, a single point sample has 0 variance. \n\n        # 3. Maximum absolute component magnitude\n        max_abs_mag = np.max(np.abs(v_main)) if v_main.size > 0 else 0.0\n        \n        # 4. Count of clipped uniform variates\n        clipped_count = clips\n\n        # 5. Boolean indicating if all components are finite\n        all_finite = np.all(np.isfinite(v_main))\n\n        # 6. Boolean for same-seed equality\n        same_seed_equal = np.array_equal(v_main, v_redux)\n\n        # 7. Boolean for different-seed equality\n        diff_seed_equal = np.array_equal(v_main, v_other)\n        \n        case_results = [\n            abs_sample_mean,\n            relative_error_var,\n            max_abs_mag,\n            clipped_count,\n            all_finite,\n            same_seed_equal,\n            diff_seed_equal\n        ]\n        all_results.append(case_results)\n\n    # Format the final output string exactly as required\n    case_strings = []\n    for res_list in all_results:\n        # Convert each item to its string representation\n        # For booleans, Python's str() produces 'True'/'False' which needs to be lowercase.\n        str_items = [str(item).lower() if isinstance(item, bool) else str(item) for item in res_list]\n        case_strings.append(f\"[{','.join(str_items)}]\")\n    \n    final_output = f\"[{','.join(case_strings)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "3458384"}, {"introduction": "Beyond velocities, creating a valid starting configuration of atomic positions is critical, especially for disordered systems like liquids or amorphous solids. This exercise introduces the Random Sequential Addition (RSA) algorithm, a common method for generating such structures while respecting physical constraints like atomic size [@problem_id:3458396]. You will implement this technique with practical considerations for computational efficiency and packing limits, culminating in a complete initialization of both positions and velocities for an amorphous material.", "problem": "You are asked to design and implement a principled algorithm to initialize atomic positions and velocities for a monatomic amorphous structure in a periodic cubic box using Random Sequential Addition (RSA) with a hard-core exclusion radius. Your program must, for each test case, attempt to place a prescribed number of atoms while enforcing a strict minimum center-to-center distance and then initialize velocities consistent with a target thermodynamic temperature.\n\nThe fundamental base to use includes: Newton’s laws of motion, the definition of velocity as $v = dx/dt$, the equipartition theorem stating that the average kinetic energy per quadratic degree of freedom equals $\\tfrac{1}{2} k_{\\mathrm{B}} T$, and well-established physical facts about Maxwell–Boltzmann statistics and RSA saturation coverage. You must derive all formulas you use from these.\n\nDefinitions and requirements:\n\n- The system is a cubic box of side length $L$ with periodic boundary conditions. All lengths must be expressed in meters (m).\n- The target mass density is $\\rho_{\\mathrm{m}}$ (in $\\mathrm{kg/m^3}$). The atomic mass is $m_{\\mathrm{u}}$ (in unified atomic mass units), and the conversion is $m = m_{\\mathrm{u}} \\, m_{u}$ with $m_{u} = 1.66053906660 \\times 10^{-27} \\,\\mathrm{kg}$.\n- The number of atoms $N$ is computed from the box volume $V = L^3$ and the mass density by $N = \\mathrm{round}\\!\\left(\\dfrac{\\rho_{\\mathrm{m}} V}{m}\\right)$, an integer.\n- Positions are initialized by RSA: propose a random position uniformly in $[0,L)^3$ and accept it if its minimum-image distance (using periodic boundary conditions) to every previously accepted atom is at least the hard-core exclusion parameter $r_0$ (in meters), otherwise reject and try again. You may impose a per-atom attempt limit.\n- The program must use the minimal image convention: for any displacement component $\\Delta x$, apply $\\Delta x \\leftarrow \\Delta x - L \\,\\mathrm{round}(\\Delta x/L)$ to enforce periodicity before computing Euclidean distance.\n- Velocities are initialized from the Maxwell–Boltzmann distribution at temperature $T$ (in kelvins) for monatomic particles of mass $m$, i.e., each Cartesian component is independently normally distributed with zero mean and variance $\\sigma^2 = k_{\\mathrm{B}} T / m$, where $k_{\\mathrm{B}} = 1.380649 \\times 10^{-23}\\,\\mathrm{J/K}$. Enforce zero net momentum by subtracting the center-of-mass velocity, then rescale velocities to match the target temperature exactly using the equipartition theorem on the available degrees of freedom.\n- The instantaneous temperature after removing the center-of-mass motion is computed as\n$$\nT_{\\mathrm{inst}} = \\frac{2 K}{f k_{\\mathrm{B}}}, \\quad K = \\sum_{i=1}^{N} \\frac{1}{2} m \\lVert \\mathbf{v}_i \\rVert^2, \\quad f = 3N-3.\n$$\nRescale all velocities by a uniform scalar factor so that $T_{\\mathrm{inst}}$ equals the target $T$; report the absolute temperature error $|T_{\\mathrm{inst}} - T|$ after rescaling in kelvins.\n- The packing fraction is defined by treating each atom as a hard sphere of radius $r_0/2$, hence the single-sphere volume is $v_{\\mathrm{s}}(r_0) = \\dfrac{\\pi}{6} r_0^3$. The packing fraction realized by any given configuration is\n$$\n\\phi = \\frac{N \\, v_{\\mathrm{s}}(r_0)}{V}.\n$$\nExpress all packing fractions as dimensionless floats.\n- Quantify the expected packing fraction as a function of $r_0$ starting from the number density $\\rho = N/V$ and the hard-core exclusion model. In the infinite-system RSA limit for identical spheres in three dimensions, the saturation packing fraction is well-established to be approximately $\\phi_{\\mathrm{sat}} \\approx 0.382$. Therefore, for any given $r_0$, define the expected packing fraction function\n$$\n\\phi_{\\mathrm{exp}}(r_0) = \\min\\!\\left( \\rho \\, v_{\\mathrm{s}}(r_0), \\, \\phi_{\\mathrm{sat}} \\right).\n$$\nAlso define the corresponding saturation number capacity\n$$\nN_{\\max}(r_0) = \\left\\lfloor \\frac{\\phi_{\\mathrm{sat}} V}{v_{\\mathrm{s}}(r_0)} \\right\\rfloor,\n$$\nwhich must be used to determine feasibility before attempting RSA: if $N  N_{\\max}(r_0)$, the placement is infeasible in principle for RSA and your algorithm must return failure without attempting placements.\n\nYour program must do the following for each test case:\n\n1. Given inputs $L$, $\\rho_{\\mathrm{m}}$, $m_{\\mathrm{u}}$, $r_0$, $T$, and an integer maximum number of RSA trials per atom, compute $N$ and check feasibility using $N_{\\max}(r_0)$ as above.\n2. If feasible, attempt RSA with periodic boundary conditions using a spatial cell-list acceleration strategy to ensure practical performance. If all $N$ atoms are placed within the trial budget, report success; otherwise report failure.\n3. Initialize velocities at temperature $T$ as described, enforce zero center-of-mass momentum, rescale to target temperature based on the equipartition theorem, and compute the absolute temperature error $|T_{\\mathrm{inst}}-T|$ (in kelvins) after rescaling.\n4. Compute the achieved packing fraction $\\phi$ if placement succeeded; if not, report $\\phi = -1.0$.\n5. Compute the expected packing fraction $\\phi_{\\mathrm{exp}}(r_0)$ defined above.\n\nUse the following fixed random seed for reproducibility: $s = 2025$.\n\nTest suite:\n\nProvide results for the following three cases, all using International System of Units (SI). All constants and results must be in the specified units:\n\n- Case A (happy path):\n  - $L = 1.5 \\times 10^{-9} \\,\\mathrm{m}$,\n  - $\\rho_{\\mathrm{m}} = 2700 \\,\\mathrm{kg/m^3}$,\n  - $m_{\\mathrm{u}} = 26.9815385$,\n  - $r_0 = 2.2 \\times 10^{-10} \\,\\mathrm{m}$,\n  - $T = 300 \\,\\mathrm{K}$,\n  - trials per atom $= 5000$.\n- Case B (near saturation but feasible):\n  - $L = 1.5 \\times 10^{-9} \\,\\mathrm{m}$,\n  - $\\rho_{\\mathrm{m}} = 2700 \\,\\mathrm{kg/m^3}$,\n  - $m_{\\mathrm{u}} = 26.9815385$,\n  - $r_0 = 2.25 \\times 10^{-10} \\,\\mathrm{m}$,\n  - $T = 300 \\,\\mathrm{K}$,\n  - trials per atom $= 15000$.\n- Case C (infeasible by RSA saturation bound):\n  - $L = 1.5 \\times 10^{-9} \\,\\mathrm{m}$,\n  - $\\rho_{\\mathrm{m}} = 2700 \\,\\mathrm{kg/m^3}$,\n  - $m_{\\mathrm{u}} = 26.9815385$,\n  - $r_0 = 2.35 \\times 10^{-10} \\,\\mathrm{m}$,\n  - $T = 300 \\,\\mathrm{K}$,\n  - trials per atom $= 2000$.\n\nFinal output format:\n\nYour program should produce a single line of output containing a list of three results, one per test case, with no spaces. Each test case result must itself be a list of four entries in the order:\n- success indicator as $1$ (success) or $0$ (failure),\n- achieved packing fraction $\\phi$ as a float rounded to six decimal places (use $-1.000000$ on failure),\n- expected packing fraction $\\phi_{\\mathrm{exp}}$ as a float rounded to six decimal places,\n- absolute temperature error $|T_{\\mathrm{inst}}-T|$ in kelvins, rounded to six decimal places.\n\nFor example, the overall format must be like\n$[\\,[1,0.123456,0.120000,0.000000],[\\dots],[\\dots]\\,]$\nwith your three computed entries substituted.", "solution": "The problem requires the design and implementation of an algorithm to initialize the positions and velocities for a simulation of a monatomic amorphous structure within a periodic cubic domain. The process involves multiple steps grounded in computational physics and statistical mechanics, which are detailed below.\n\nFirst, we determine the fundamental parameters of the system. Given the side length of the cubic box $L$, the volume is $V = L^3$. The mass of a single atom, $m$, is calculated from its mass in unified atomic mass units, $m_{\\mathrm{u}}$, using the conversion factor $m_{u}$, such that $m = m_{\\mathrm{u}} m_{u}$. With the target mass density $\\rho_{\\mathrm{m}}$, the total mass in the box is $\\rho_{\\mathrm{m}} V$. The number of atoms, $N$, is then determined by taking the nearest integer to the ratio of the total mass to the single-atom mass:\n$$\nN = \\mathrm{round}\\!\\left(\\frac{\\rho_{\\mathrm{m}} V}{m}\\right)\n$$\n\nThe second step is to generate atomic positions using Random Sequential Addition (RSA). This is an iterative process where atoms are added one by one into the volume. A candidate position $\\mathbf{r}_{\\mathrm{new}}$ is generated from a uniform random distribution within the box, i.e., each coordinate $x, y, z$ is in $[0, L)$. This position is accepted only if the new atom does not overlap with any previously placed atoms. The non-overlap condition is enforced by a hard-core exclusion radius $r_0$, meaning the center-to-center distance between any two atoms must be at least $r_0$. Since the system has periodic boundary conditions (PBC), this distance must be calculated using the minimum image convention (MIC). For any two position vectors $\\mathbf{r}_i$ and $\\mathbf{r}_j$, their displacement vector is $\\Delta\\mathbf{r} = \\mathbf{r}_i - \\mathbf{r}_j$. The MIC adjusts each component of this vector, e.g., $\\Delta x$, as $\\Delta x_{\\mathrm{mic}} = \\Delta x - L \\cdot \\mathrm{round}(\\Delta x / L)$. The squared distance is then $d^2 = \\Delta x_{\\mathrm{mic}}^2 + \\Delta y_{\\mathrm{mic}}^2 + \\Delta z_{\\mathrm{mic}}^2$. The new position is accepted if $d \\ge r_0$ for all previously placed atoms.\n\nA brute-force distance check for each new atom against all existing atoms is computationally expensive, with a complexity of $O(N^2)$. To accelerate this, a cell list data structure is employed. The simulation box is partitioned into a grid of smaller cubic cells, where the side length of each cell is at least $r_0$. To check a candidate position, we only need to compute distances to atoms in its own cell and the 26 neighboring cells. This reduces the search complexity to $O(N)$.\n\nRSA cannot achieve arbitrarily high packing densities. For identical spheres in three dimensions, there is a theoretical saturation packing fraction, $\\phi_{\\mathrm{sat}} \\approx 0.382$. Before attempting placement, we perform a feasibility check. The volume of a single hard sphere is $v_{\\mathrm{s}}(r_0) = \\frac{\\pi}{6} r_0^3$. The maximum number of atoms that can be placed via RSA, $N_{\\max}$, is limited by this saturation density:\n$$\nN_{\\max}(r_0) = \\left\\lfloor \\frac{\\phi_{\\mathrm{sat}} V}{v_{\\mathrm{s}}(r_0)} \\right\\rfloor\n$$\nIf the target number of atoms $N$ exceeds $N_{\\max}(r_0)$, the placement is deemed infeasible a priori. If placement is attempted and fails (due to exceeding a finite number of trials per atom), or if it is deemed infeasible, the achieved packing fraction $\\phi$ is reported as $-1.0$. If successful, $\\phi$ is calculated as the total volume of all atoms divided by the box volume:\n$$\n\\phi = \\frac{N v_{\\mathrm{s}}(r_0)}{V}\n$$\nThe expected packing fraction, $\\phi_{\\mathrm{exp}}(r_0)$, is defined as the smaller of the packing fraction implied by the target number density $\\rho = N/V$ and the saturation limit: $\\phi_{\\mathrm{exp}}(r_0) = \\min(\\rho v_{\\mathrm{s}}(r_0), \\phi_{\\mathrm{sat}})$.\n\nThird, upon successful placement of all $N$ atoms, their initial velocities are assigned. According to the equipartition theorem in statistical mechanics for a system in thermal equilibrium at temperature $T$, each quadratic degree of freedom has an average energy of $\\frac{1}{2} k_{\\mathrm{B}} T$. For a monatomic particle, there are three translational degrees of freedom. This implies that each velocity component ($v_x, v_y, v_z$) follows a Gaussian (normal) distribution with a mean of zero and a variance of $\\sigma^2 = k_{\\mathrm{B}} T / m$. We generate $3N$ random numbers from this distribution to create an initial set of velocities $\\{\\mathbf{v}_i\\}$.\n\nTo ensure the system as a whole has no net drift (i.e., total momentum is conserved at zero), the center-of-mass velocity, $\\mathbf{v}_{\\mathrm{CM}} = \\frac{1}{N} \\sum_{i=1}^N \\mathbf{v}_i$, is computed and subtracted from each atom's velocity: $\\mathbf{v}'_i = \\mathbf{v}_i - \\mathbf{v}_{\\mathrm{CM}}$. This constraint removes $3$ degrees of freedom from the system, leaving $f = 3N-3$ independent degrees of freedom.\n\nFinally, the velocities are rescaled to ensure the instantaneous temperature of the system exactly matches the target temperature $T$. The instantaneous temperature, $T_{\\mathrm{inst}}$, is defined via the total kinetic energy $K$:\n$$\nK = \\sum_{i=1}^{N} \\frac{1}{2} m \\lVert \\mathbf{v}'_i \\rVert^2, \\quad T_{\\mathrm{inst}} = \\frac{2 K}{f k_{\\mathrm{B}}}\n$$\nDue to the statistical nature of the initial velocity generation, $T_{\\mathrm{inst}}$ will be close to but not exactly $T$. To correct this, all velocity vectors are scaled by a factor $\\lambda = \\sqrt{T / T_{\\mathrm{inst}}}$. The final velocities are $\\mathbf{v}''_i = \\lambda \\mathbf{v}'_i$. By construction, the temperature calculated from these rescaled velocities will be exactly $T$, and the absolute error $|T_{\\mathrm{final}} - T|$ should be non-zero only due to floating-point precision limitations.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation setup for all test cases and print results.\n    \"\"\"\n    # Define physical constants\n    M_U = 1.66053906660e-27  # Unified atomic mass unit in kg\n    K_B = 1.380649e-23       # Boltzmann constant in J/K\n    PHI_SAT = 0.382          # RSA saturation packing fraction for 3D spheres\n    \n    # Global random number generator for reproducibility\n    RNG = np.random.default_rng(2025)\n\n    test_cases = [\n        # Case A (happy path)\n        {'L': 1.5e-9, 'rho_m': 2700, 'm_u': 26.9815385, 'r_0': 2.2e-10, 'T': 300, 'trials_per_atom': 5000},\n        # Case B (near saturation)\n        {'L': 1.5e-9, 'rho_m': 2700, 'm_u': 26.9815385, 'r_0': 2.25e-10, 'T': 300, 'trials_per_atom': 15000},\n        # Case C (infeasible)\n        {'L': 1.5e-9, 'rho_m': 2700, 'm_u': 26.9815385, 'r_0': 2.35e-10, 'T': 300, 'trials_per_atom': 2000},\n    ]\n\n    def solve_case(L, rho_m, m_u, r_0, T, trials_per_atom):\n        \"\"\"\n        Solves a single test case for atomic position and velocity initialization.\n        \"\"\"\n        # 1. Calculate system parameters\n        V = L**3\n        m = m_u * M_U\n        N = int(round((rho_m * V) / m))\n        v_s = (np.pi / 6) * r_0**3\n        r_0_sq = r_0**2\n\n        # 2. Feasibility check and expected packing fraction\n        phi_exp = min((N / V) * v_s, PHI_SAT)\n        if v_s > 0:\n            N_max = np.floor((PHI_SAT * V) / v_s)\n        else:\n            N_max = float('inf')\n\n        if N > N_max:\n            return 0, -1.0, phi_exp, 0.0\n\n        # 3. RSA Position Initialization with Cell-List Acceleration\n        positions = np.zeros((N, 3))\n        \n        # If N=0, placement is trivially successful\n        if N == 0:\n             return 1, 0.0, phi_exp, 0.0\n\n        n_cells = int(np.floor(L / r_0))\n        if n_cells  1: # r_0 >= L, can't place more than 1 atom\n            if N > 1:\n                return 0, -1.0, phi_exp, 0.0\n            else: # N=1, this will succeed on first try, no neighbors to check\n                positions[0] = RNG.uniform(0, L, size=3)\n                success = 1\n                phi_achieved = (N * v_s) / V\n                # continue to velocity initialization\n        else: # Standard RSA with cell list\n            cell_size = L / n_cells\n            cells = {}\n            success = 0\n            \n            for i in range(N):\n                placed_atom = False\n                for _ in range(trials_per_atom):\n                    pos_new = RNG.uniform(0, L, size=3)\n                    cell_coords = tuple(np.floor(pos_new / cell_size).astype(int))\n                    \n                    conflict = False\n                    for di in [-1, 0, 1]:\n                        for dj in [-1, 0, 1]:\n                            for dk in [-1, 0, 1]:\n                                nc_x = (cell_coords[0] + di + n_cells) % n_cells\n                                nc_y = (cell_coords[1] + dj + n_cells) % n_cells\n                                nc_z = (cell_coords[2] + dk + n_cells) % n_cells\n                                neighbor_cell = (nc_x, nc_y, nc_z)\n                                \n                                if neighbor_cell in cells:\n                                    for other_idx in cells[neighbor_cell]:\n                                        delta = pos_new - positions[other_idx]\n                                        delta -= L * np.round(delta / L)\n                                        dist_sq = np.sum(delta**2)\n                                        if dist_sq  r_0_sq:\n                                            conflict = True\n                                            break\n                                if conflict: break\n                            if conflict: break\n                        if conflict: break\n                    \n                    if not conflict:\n                        positions[i] = pos_new\n                        if cell_coords not in cells:\n                            cells[cell_coords] = []\n                        cells[cell_coords].append(i)\n                        placed_atom = True\n                        break\n                \n                if not placed_atom:\n                    return 0, -1.0, phi_exp, 0.0\n\n            success = 1\n            phi_achieved = (N * v_s) / V\n\n        # 4. Velocity Initialization\n        if N > 1:\n            sigma_v = np.sqrt(K_B * T / m)\n            velocities = RNG.normal(loc=0.0, scale=sigma_v, size=(N, 3))\n            \n            # Remove CoM velocity\n            v_com = np.mean(velocities, axis=0)\n            velocities -= v_com\n\n            # Rescale to target temperature\n            f = 3 * N - 3\n            K_current = 0.5 * m * np.sum(velocities**2)\n            \n            # T_inst can be zero if all velocities happen to be zero after CoM removal\n            if K_current  1e-30:\n                T_inst = 0.0\n            else:\n                T_inst = (2 * K_current) / (f * K_B)\n            \n            if T_inst > 1e-15:\n                scaling_factor = np.sqrt(T / T_inst)\n                velocities *= scaling_factor\n            \n            # Final temperature check\n            K_final = 0.5 * m * np.sum(velocities**2)\n            T_final = (2 * K_final) / (f * K_B)\n            temp_err = abs(T_final - T)\n        else:\n            temp_err = 0.0 # No kinetic energy to scale for N=1 \n\n        return success, phi_achieved, phi_exp, temp_err\n\n    all_results = []\n    for case_params in test_cases:\n        res_tuple = solve_case(\n            L=case_params['L'],\n            rho_m=case_params['rho_m'],\n            m_u=case_params['m_u'],\n            r_0=case_params['r_0'],\n            T=case_params['T'],\n            trials_per_atom=case_params['trials_per_atom']\n        )\n        all_results.append(res_tuple)\n    \n    # Format the final output string exactly as required\n    result_strings = []\n    for res in all_results:\n        success, phi, phi_exp, temp_err = res\n        result_strings.append(f\"[{success},{phi:.6f},{phi_exp:.6f},{temp_err:.6f}]\")\n        \n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```", "id": "3458396"}, {"introduction": "To study many real-world material behaviors, we must create initial structures that contain specific crystalline defects. This advanced practice demonstrates how to construct an edge dislocation dipole, a key defect in understanding plastic deformation, within a crystalline lattice [@problem_id:3458312]. By applying principles from continuum elasticity theory and carefully handling periodic boundary conditions, you will master a sophisticated workflow for preparing systems to simulate mechanical properties.", "problem": "Consider a two-dimensional initialization of a monatomic crystalline solid containing an edge dislocation dipole, suitable for Molecular Dynamics (MD) or Monte Carlo (MC) simulations. Use the Volterra construction in isotropic linear elasticity under plane strain to derive the displacement field for a single edge dislocation with Burgers vector along the horizontal axis. Then superpose two such fields with opposite Burgers vectors to obtain a dipole compatible with periodic boundary conditions in two dimensions. Map an initially ideal square lattice to the elastically displaced positions, remove atoms within a small core radius, and assign velocities consistent with a Maxwell–Boltzmann distribution at a target temperature while enforcing zero total linear momentum.\n\nYour program must implement the following, starting only from fundamental laws and definitions:\n\n1) Geometry and lattice initialization:\n- Work in two spatial dimensions with a rectangular periodic box of side lengths $L_x$ and $L_y$ (expressed in angstroms). Construct an ideal square lattice of lattice spacing $a$ (in angstroms) inside the box using all lattice points $\\{(i a, j a)\\}$ with $i \\in \\mathbb{Z}$ and $j \\in \\mathbb{Z}$ such that $0 \\le i a  L_x$ and $0 \\le j a  L_y$. All positions must be in angstroms.\n- Place two dislocation cores at positions $(x_1, y_1)$ and $(x_2, y_2)$ with Burgers vectors $+b \\,\\hat{\\mathbf{x}}$ and $-b \\,\\hat{\\mathbf{x}}$, respectively, where $b$ is the Burgers vector magnitude expressed in angstroms.\n\n2) Displacement field by Volterra construction:\n- Using isotropic linear elasticity under plane strain, derive the two-dimensional displacement field $\\mathbf{u}(x,y)$ for a single edge dislocation with Burgers vector magnitude $b$ along the $x$-direction and Poisson ratio $\\nu$. Your derivation must start from the governing equations of linear elasticity and the Volterra cut prescription and proceed to a closed-form expression for $\\mathbf{u}(x,y)$.\n- Use superposition to obtain the total displacement $\\mathbf{u}_{\\text{tot}}(x,y)$ for the dislocation dipole by summing the contributions from the two dislocations. Distances must be computed under periodic boundary conditions by applying the minimum image convention in both directions to the relative coordinate $(x-x_c, y-y_c)$ to the core at $(x_c,y_c)$ before evaluating the displacement.\n- To regularize the logarithmic and $1/r$ singularities, remove any atom whose minimum-image distance to either dislocation core is less than a core cutoff radius $r_c$ (in angstroms). This removal models the nonlinear core region.\n\n3) Periodicity and wrapping:\n- After displacing all remaining atoms by $\\mathbf{u}_{\\text{tot}}(x,y)$, wrap positions back into the periodic box $[0,L_x) \\times [0,L_y)$ using modulo operations, in angstroms.\n\n4) Velocity initialization:\n- Assign initial velocities $(v_x, v_y)$ to all remaining atoms from a two-dimensional Maxwell–Boltzmann distribution at target temperature $T$ (in kelvin) for particles of mass $m$ (in atomic mass units). Convert $m$ to kilograms using the conversion $1$ atomic mass unit $= 1.66053906660 \\times 10^{-27}$ kilogram. Use the Boltzmann constant $k_{\\mathrm{B}} = 1.380649 \\times 10^{-23}$ joule per kelvin. Define temperature from kinetic energy using the equipartition theorem in two dimensions.\n- Enforce zero total linear momentum by subtracting the center-of-mass velocity from all particle velocities and then rescale the velocities so that the instantaneous kinetic temperature equals exactly $T$ (in kelvin), to within floating-point tolerance. Use radians for any angles.\n\n5) Diagnostics to output:\nFor each test case described below, compute and return the following four quantities:\n- The integer number of atoms $N$ remaining after core removal.\n- The absolute temperature error $\\Delta T$ in kelvin, defined as the absolute difference between the instantaneous kinetic temperature computed from the final velocities and the target $T$.\n- The magnitude of the center-of-mass speed $|\\mathbf{v}_{\\mathrm{COM}}|$ in meters per second after enforcing zero total momentum and rescaling.\n- The minimum interatomic distance $d_{\\min}$ in angstroms computed under periodic boundary conditions using the minimum image convention.\n\n6) Randomness and reproducibility:\n- Use a pseudorandom number generator seeded with the integer $2025$ so that the results are reproducible.\n\n7) Test suite:\nImplement exactly the following three test cases. In each case, place the two dislocations at $(x_1, y_1) = (L_x/4, \\, L_y/2)$ with Burgers vector $+b \\,\\hat{\\mathbf{x}}$ and $(x_2, y_2) = (3 L_x/4, \\, L_y/2)$ with Burgers vector $-b \\,\\hat{\\mathbf{x}}$. Use the minimum image convention for all relative vectors. Report results in the units specified above.\n\n- Case A:\n  - $L_x = 200$ angstroms, $L_y = 200$ angstroms.\n  - $a = 2.5$ angstroms.\n  - $b = a$.\n  - $\\nu = 0.33$.\n  - $r_c = 5.0$ angstroms.\n  - $T = 300$ kelvin.\n  - $m = 58.6934$ atomic mass units.\n\n- Case B:\n  - $L_x = 120$ angstroms, $L_y = 100$ angstroms.\n  - $a = 2.86$ angstroms.\n  - $b = a$.\n  - $\\nu = 0.28$.\n  - $r_c = 4.29$ angstroms.\n  - $T = 1000$ kelvin.\n  - $m = 55.845$ atomic mass units.\n\n- Case C:\n  - $L_x = 80$ angstroms, $L_y = 80$ angstroms.\n  - $a = 4.05$ angstroms.\n  - $b = a$.\n  - $\\nu = 0.49$.\n  - $r_c = 4.86$ angstroms.\n  - $T = 10$ kelvin.\n  - $m = 26.9815$ atomic mass units.\n\n8) Final output format:\n- Your program should produce a single line of output containing a JSON-like nested list of results for all three cases, in the order [Case A, Case B, Case C]. Each inner list must contain exactly four entries in the order $[N, \\Delta T, |\\mathbf{v}_{\\mathrm{COM}}|, d_{\\min}]$. The integer $N$ should be printed as an integer. All floating-point values must be rounded to six decimal places. For example, a valid output shape is\n  - $[[N_A,\\Delta T_A,|\\mathbf{v}_{\\mathrm{COM},A}|,d_{\\min,A}],[N_B,\\Delta T_B,|\\mathbf{v}_{\\mathrm{COM},B}|,d_{\\min,B}],[N_C,\\Delta T_C,|\\mathbf{v}_{\\mathrm{COM},C}|,d_{\\min,C}]]$,\nprinted as a single line with no additional text.\n\nAll computations must be performed in the specified units: positions in angstroms, velocities in meters per second, temperature in kelvin, mass in kilograms, and the Boltzmann constant as given. Angles are in radians. Use natural logarithms. The program must be self-contained and accept no user input. The use of the minimum image convention is required whenever a relative vector under periodic boundary conditions is needed.", "solution": "We begin from linear elasticity under plane strain for an isotropic solid. Denote by $x$ and $y$ the in-plane coordinates, the displacement field by $\\mathbf{u} = (u_x, u_y)$, the elastic constants by the shear modulus $\\mu$ and Poisson ratio $\\nu$, and the Burgers vector for an edge dislocation oriented along the $x$-axis by $\\mathbf{b} = b \\,\\hat{\\mathbf{x}}$. In the Volterra construction, an edge dislocation is introduced by making a cut in the medium, imposing a discontinuity equal to $\\mathbf{b}$ across the cut, and requiring mechanical equilibrium governed by the Navier–Cauchy equations for linear elasticity. Under plane strain, the governing equations for the displacement field are\n$$\n\\mu \\nabla^2 \\mathbf{u} + (\\lambda + \\mu) \\nabla (\\nabla \\cdot \\mathbf{u}) = \\mathbf{0},\n$$\nwhere $\\lambda = \\frac{2\\mu \\nu}{1-2\\nu}$ is the first Lamé constant, and the strain energy density is quadratic in the small strain tensor $\\varepsilon_{ij} = \\frac{1}{2}(\\partial_i u_j + \\partial_j u_i)$. The Volterra prescription imposes that the closed line integral of $\\nabla \\mathbf{u}$ around a loop enclosing the dislocation core equals the Burgers vector:\n$$\n\\oint_C \\nabla \\mathbf{u} \\cdot d\\mathbf{\\ell} = \\mathbf{b}.\n$$\nThe classical solution for a single straight edge dislocation (line along the out-of-plane direction) in an infinite medium under plane strain is derived using an Airy stress function $\\Phi(x,y)$ that satisfies the biharmonic equation $\\nabla^4 \\Phi = 0$, with boundary conditions enforcing the displacement discontinuity across the cut and vanishing traction at infinity. Matching these conditions yields the stress field, which integrates to the displacement field up to rigid-body translations. The resulting displacement for a dislocation with Burgers vector $\\mathbf{b} = b\\,\\hat{\\mathbf{x}}$ located at the origin is\n$$\nu_x(x,y) = \\frac{b}{2\\pi} \\left[ \\arctan\\!\\left(\\frac{y}{x}\\right) + \\frac{x\\,y}{2(1-\\nu)\\,(x^2 + y^2)} \\right],\n$$\n$$\nu_y(x,y) = \\frac{b}{2\\pi} \\left[ -\\frac{1-2\\nu}{4(1-\\nu)} \\ln\\!\\left(x^2 + y^2\\right) + \\frac{y^2 - x^2}{4(1-\\nu)\\,(x^2 + y^2)} \\right].\n$$\nThese expressions are well tested and follow from integrating the stress components derived from the Airy stress function for an edge dislocation. The logarithmic term in $u_y$ is defined up to an additive constant corresponding to a rigid translation, which has no physical effect on relative positions.\n\nFor a dislocation located at $(x_c, y_c)$, we replace $(x,y)$ by $(x-x_c, y-y_c)$. Under linear elasticity, superposition applies. Therefore, a dislocation dipole with cores at $(x_1,y_1)$ and $(x_2,y_2)$ and Burgers vectors $+b\\,\\hat{\\mathbf{x}}$ and $-b\\,\\hat{\\mathbf{x}}$ respectively yields the total displacement\n$$\n\\mathbf{u}_{\\text{tot}}(x,y) = \\mathbf{u}^{(+b)}(x-x_1, y-y_1) + \\mathbf{u}^{(-b)}(x-x_2, y-y_2),\n$$\nwhere $\\mathbf{u}^{(-b)}$ is obtained from the same formula with $b \\to -b$. To enforce periodic boundary conditions in a rectangular box with lengths $L_x$ and $L_y$, we evaluate the relative vectors $(x-x_c, y-y_c)$ using the minimum image convention:\n$$\n\\Delta x = (x - x_c) - L_x \\,\\mathrm{round}\\!\\left(\\frac{x-x_c}{L_x}\\right), \\quad \\Delta y = (y - y_c) - L_y \\,\\mathrm{round}\\!\\left(\\frac{y-y_c}{L_y}\\right),\n$$\nand then substitute $(\\Delta x, \\Delta y)$ into the displacement formula.\n\nThe elastic field is singular at the core; accordingly, we remove any atom whose minimum-image distance $r = \\sqrt{(\\Delta x)^2 + (\\Delta y)^2}$ to either core is less than a cutoff radius $r_c$. This models the nonlinear core and regularizes the logarithm and $1/r$ terms.\n\nAlgorithmically, we proceed as follows for each test case:\n- Construct the ideal square lattice with spacing $a$ by enumerating all $i,j$ such that $0 \\le i a  L_x$ and $0 \\le j a  L_y$, producing positions $\\mathbf{r} = (x,y)$ in angstroms.\n- Compute the minimum-image relative vectors $(\\Delta x_1, \\Delta y_1)$ to $(x_1,y_1)$ and $(\\Delta x_2, \\Delta y_2)$ to $(x_2,y_2)$, compute distances $r_1$ and $r_2$, and keep only atoms with $r_1 \\ge r_c$ and $r_2 \\ge r_c$.\n- For the remaining atoms, compute $\\mathbf{u}^{(+b)}(\\Delta x_1, \\Delta y_1)$ and $\\mathbf{u}^{(-b)}(\\Delta x_2, \\Delta y_2)$ using the formulas above and sum to obtain $\\mathbf{u}_{\\text{tot}}$. Update positions $\\mathbf{r}' = \\mathbf{r} + \\mathbf{u}_{\\text{tot}}$, and wrap each component modulo $L_x$ and $L_y$ to enforce periodicity.\n- Initialize velocities from a two-dimensional Maxwell–Boltzmann distribution at temperature $T$. For a single component, the variance is $\\sigma^2 = k_{\\mathrm{B}} T / m$, so draw $v_x$ and $v_y$ independently from a normal distribution with zero mean and standard deviation $\\sigma = \\sqrt{k_{\\mathrm{B}} T / m}$ (with $m$ in kilograms). Subtract the center-of-mass velocity $\\mathbf{v}_{\\mathrm{COM}}$ to enforce zero total momentum. Compute the instantaneous kinetic temperature from equipartition in two dimensions:\n$$\nT_{\\text{inst}} = \\frac{K}{k_{\\mathrm{B}} (N-1)}, \\quad \\text{where } K=\\frac{1}{2}m \\sum_{i=1}^{N} \\lVert\\mathbf{v}_i\\rVert^2,\n$$\nand rescale velocities by the factor $\\alpha = \\sqrt{T/T_{\\text{inst}}}$ so that the final instantaneous temperature equals $T$ up to floating-point tolerance. After rescaling, recompute $\\mathbf{v}_{\\mathrm{COM}}$.\n- Compute diagnostics: $N$ is the number of remaining atoms; $\\Delta T = |T_{\\text{inst}} - T|$ in kelvin; $|\\mathbf{v}_{\\mathrm{COM}}| = \\sqrt{(\\overline{v_x})^2 + (\\overline{v_y})^2}$ in meters per second; and the minimum interatomic distance $d_{\\min}$ under periodic boundary conditions. The minimum distance is computed efficiently by building a periodic $k$-dimensional tree on the final positions with box size $(L_x, L_y)$ and querying the second nearest neighbor for each point (the first being the point itself), then taking the minimum over all particles.\n\nAll test parameters are expressed in angstroms for lengths, kelvin for temperature, and atomic mass units for input mass values, with conversion to kilograms using $1$ atomic mass unit $= 1.66053906660 \\times 10^{-27}$ kilogram. The Boltzmann constant is $k_{\\mathrm{B}} = 1.380649 \\times 10^{-23}$ joule per kelvin. Angles are in radians, logarithms are natural. The random number generator is seeded with $2025$ for reproducibility.\n\nFinally, the program aggregates the diagnostics for the three specified cases in the order [Case A, Case B, Case C] and prints a single line containing a nested list of the four diagnostics in the order $[N, \\Delta T, |\\mathbf{v}_{\\mathrm{COM}}|, d_{\\min}]$ for each case. The integer $N$ is printed as an integer, and the floating-point values are rounded to six decimal places before printing.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.spatial import cKDTree\n\n# Physical constants\nKB = 1.380649e-23  # Boltzmann constant in J/K\nAMU_TO_KG = 1.66053906660e-27  # kg per atomic mass unit\n\ndef min_image(delta, boxlen):\n    \"\"\"Apply the minimum image convention to a coordinate difference.\"\"\"\n    return delta - np.round(delta / boxlen) * boxlen\n\ndef displacement_edge(dx, dy, b, nu):\n    \"\"\"\n    Displacement field (ux, uy) for an edge dislocation with Burgers vector b along +x,\n    isotropic elasticity, plane strain. Inputs dx, dy are arrays of relative coordinates\n    (minimum-image) to the dislocation core. Units: dx,dy,b in Angstrom. Returns ux,uy in Angstrom.\n    \"\"\"\n    r2 = dx*dx + dy*dy\n    # Avoid division by zero: caller must mask out core (r2 >= rc^2)\n    # Use numpy.errstate to manage warnings for logs of small values if any remain.\n    with np.errstate(divide='ignore', invalid='ignore'):\n        ux = (b/(2.0*np.pi)) * (np.arctan2(dy, dx) + (dx*dy) / (2.0*(1.0-nu)*r2))\n        uy = (b/(2.0*np.pi)) * (-(1.0-2.0*nu)/(4.0*(1.0-nu)) * 0.5 * np.log(r2) + (dy*dy - dx*dx)/(4.0*(1.0-nu)*r2))\n    return ux, uy\n\ndef build_square_lattice(Lx, Ly, a):\n    \"\"\"\n    Build a 2D square lattice in [0,Lx) x [0,Ly) with spacing a.\n    Returns positions as an (N,2) array in Angstrom.\n    \"\"\"\n    nx = int(np.floor(Lx / a))\n    ny = int(np.floor(Ly / a))\n    xs = a * np.arange(nx, dtype=float)\n    ys = a * np.arange(ny, dtype=float)\n    X, Y = np.meshgrid(xs, ys, indexing='xy')\n    pos = np.column_stack((X.ravel(), Y.ravel()))\n    return pos\n\ndef apply_dipole_displacement(positions, Lx, Ly, x1, y1, x2, y2, b, nu, rc):\n    \"\"\"\n    Apply dislocation dipole displacement field to positions.\n    Remove atoms within rc of either core. Wrap positions into the box.\n    Returns displaced positions (N',2), mask of kept atoms (N,), and indices of kept atoms.\n    \"\"\"\n    # Relative vectors to core 1\n    dx1 = min_image(positions[:, 0] - x1, Lx)\n    dy1 = min_image(positions[:, 1] - y1, Ly)\n    r1 = np.sqrt(dx1*dx1 + dy1*dy1)\n    # Relative vectors to core 2\n    dx2 = min_image(positions[:, 0] - x2, Lx)\n    dy2 = min_image(positions[:, 1] - y2, Ly)\n    r2 = np.sqrt(dx2*dx2 + dy2*dy2)\n    # Mask out core regions\n    mask = (r1 >= rc)  (r2 >= rc)\n    kept_idx = np.nonzero(mask)[0]\n    pos_kept = positions[mask].copy()\n    # Compute displacements for kept atoms\n    dx1_k = dx1[mask]; dy1_k = dy1[mask]\n    dx2_k = dx2[mask]; dy2_k = dy2[mask]\n    # Displacement from +b at core1\n    ux1, uy1 = displacement_edge(dx1_k, dy1_k, b, nu)\n    # Displacement from -b at core2 (flip sign of b)\n    ux2, uy2 = displacement_edge(dx2_k, dy2_k, -b, nu)\n    ux_tot = ux1 + ux2\n    uy_tot = uy1 + uy2\n    # Apply and wrap\n    pos_kept[:, 0] = (pos_kept[:, 0] + ux_tot) % Lx\n    pos_kept[:, 1] = (pos_kept[:, 1] + uy_tot) % Ly\n    return pos_kept, mask, kept_idx\n\ndef initialize_velocities(N, T, mass_amu, rng):\n    \"\"\"\n    Initialize 2D velocities from Maxwell-Boltzmann at temperature T (K) for mass mass_amu (amu).\n    Enforce zero COM and rescale to exact T. Returns velocities (N,2) in m/s.\n    \"\"\"\n    if N == 0:\n        return np.empty((0, 2))\n\n    m = mass_amu * AMU_TO_KG\n    sigma = np.sqrt(KB * T / m)\n    v = rng.normal(loc=0.0, scale=sigma, size=(N, 2))\n    # Remove COM velocity\n    v_mean = v.mean(axis=0)\n    v -= v_mean\n    # Compute instantaneous temperature and rescale\n    v2_sum = np.sum(v**2)\n    \n    if N > 1:\n        # Degrees of freedom for a 2D system with CoM velocity removed\n        f = 2.0 * N - 2.0\n        T_inst = (m * v2_sum) / (f * KB)\n    else: # For N=1, v is zero after CoM removal\n        T_inst = 0.0\n\n    if T_inst > 1e-15:\n        alpha = np.sqrt(T / T_inst)\n        v *= alpha\n    return v\n\ndef compute_temperature(v, mass_amu):\n    \"\"\"Compute kinetic temperature in 2D from velocities v (N,2), mass in amu. Returns K.\"\"\"\n    N = v.shape[0]\n    if N = 1:\n        return np.nan\n    m = mass_amu * AMU_TO_KG\n    v2_sum = np.sum(v**2)\n    # Correct degrees of freedom for 2D system after CoM velocity removal\n    f = 2.0 * N - 2.0\n    T_inst = (m * v2_sum) / (f * KB)\n    return T_inst\n\ndef min_pair_distance_periodic(positions, Lx, Ly):\n    \"\"\"\n    Compute minimum pairwise distance under periodic boundary conditions using cKDTree.\n    Returns the minimal distance (float). If N  2, returns nan.\n    \"\"\"\n    N = positions.shape[0]\n    if N  2:\n        return float('nan')\n    tree = cKDTree(positions, boxsize=[Lx, Ly])\n    # Query the distance to the 2 nearest neighbors; the first is the point itself (0.0)\n    dists, idxs = tree.query(positions, k=2, workers=1)\n    # Exclude self (0 distance), take second neighbor distance\n    second = dists[:, 1]\n    return float(np.min(second))\n\ndef run_case(Lx, Ly, a, b, nu, rc, T, mass_amu, rng):\n    \"\"\"\n    Run a single test case with given parameters.\n    Returns tuple: (N, delta_T, v_com_mag, dmin)\n    \"\"\"\n    # Build lattice\n    positions = build_square_lattice(Lx, Ly, a)\n    # Dislocation cores positions\n    x1, y1 = Lx/4.0, Ly/2.0\n    x2, y2 = 3.0*Lx/4.0, Ly/2.0\n    # Apply displacement and remove cores\n    pos_disp, mask, kept_idx = apply_dipole_displacement(positions, Lx, Ly, x1, y1, x2, y2, b, nu, rc)\n    N = pos_disp.shape[0]\n    # Initialize velocities\n    v = initialize_velocities(N, T, mass_amu, rng)\n    # After initialization, enforce COM subtraction and exact T again for safety\n    v -= v.mean(axis=0)\n    T_inst = compute_temperature(v, mass_amu)\n    if np.isfinite(T_inst) and T_inst > 0:\n        v *= np.sqrt(T / T_inst)\n    # Diagnostics\n    T_final = compute_temperature(v, mass_amu)\n    delta_T = abs(T_final - T) if np.isfinite(T_final) else (0.0 if N = 1 else float('nan'))\n    v_com = np.linalg.norm(v.mean(axis=0))\n    dmin = min_pair_distance_periodic(pos_disp, Lx, Ly)\n    return N, delta_T, v_com, dmin\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Units: Angstrom for Lx,Ly,a,b,rc. T in K. mass in amu.\n    test_cases = [\n        # Case A\n        {\n            \"Lx\": 200.0, \"Ly\": 200.0, \"a\": 2.5, \"b\": 2.5,\n            \"nu\": 0.33, \"rc\": 5.0, \"T\": 300.0, \"mass_amu\": 58.6934\n        },\n        # Case B\n        {\n            \"Lx\": 120.0, \"Ly\": 100.0, \"a\": 2.86, \"b\": 2.86,\n            \"nu\": 0.28, \"rc\": 4.29, \"T\": 1000.0, \"mass_amu\": 55.845\n        },\n        # Case C\n        {\n            \"Lx\": 80.0, \"Ly\": 80.0, \"a\": 4.05, \"b\": 4.05,\n            \"nu\": 0.49, \"rc\": 4.86, \"T\": 10.0, \"mass_amu\": 26.9815\n        },\n    ]\n\n    rng = np.random.default_rng(2025)\n\n    results = []\n    for params in test_cases:\n        # The displacement formula for uy contains ln(r^2), which is 2*ln(r). \n        # The classical formula uses ln(r). The original code had an extra 0.5 factor.\n        # Let's check the formula again. u_y ~ - (1-2v)/4(1-v) * ln(x^2+y^2). It's ln(r^2). The code has 0.5*ln(r2). It's correct.\n        \n        # The run_case function had a bug in the delta_T calculation for N=1\n        # The returned value for dmin and delta_T can be nan.\n        N, dT, vcom, dmin = run_case(\n            Lx=params[\"Lx\"], Ly=params[\"Ly\"], a=params[\"a\"], b=params[\"b\"],\n            nu=params[\"nu\"], rc=params[\"rc\"], T=params[\"T\"], mass_amu=params[\"mass_amu\"],\n            rng=rng\n        )\n        if np.isnan(dmin): dmin = -1.0 # Use a placeholder for printing\n        if np.isnan(dT): dT = -1.0 # Use a placeholder for printing\n        results.append((N, dT, vcom, dmin))\n\n    # Format output: nested list [[N, dT, vcom, dmin], ...] with floats rounded to 6 decimals\n    def fmt_case(case):\n        N, dT, vcom, dmin = case\n        dT_val = dT if dT >= 0 else 0.0 # Print 0.0 for nan/placeholder cases\n        dmin_val = dmin if dmin >= 0 else 0.0\n        return f\"[{N},{dT_val:.6f},{vcom:.6f},{dmin_val:.6f}]\"\n\n    out = \"[\" + \",\".join(fmt_case(c) for c in results) + \"]\"\n    print(out)\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3458312"}]}