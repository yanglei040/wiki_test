{"hands_on_practices": [{"introduction": "The efficiency of the Particle Mesh Ewald (PME) method hinges on the Ewald screening parameter, $\\alpha$, which orchestrates the delicate balance between real-space and reciprocal-space computational work. This practice delves into the heart of this trade-off by tasking you with deriving the analytical sensitivity of particle forces to changes in $\\alpha$. By implementing and verifying your derivation, and then developing an adaptive strategy to find an optimal $\\alpha$ for different charge distributions, you will gain a profound, practical understanding of this critical parameter [@problem_id:3473558].", "problem": "You are given a three-dimensional periodic simulation cell of side length $L$, volume $V = L^3$, and a set of $M$ point charges with charges $\\{q_i\\}_{i=1}^M$ at positions $\\{\\mathbf{r}_i\\}_{i=1}^M$, all in reduced, dimensionless units. Consider the reciprocal-space part of the Ewald decomposition for the electrostatic field using a Gaussian screening parameter $\\alpha > 0$. Let the reciprocal lattice vectors be $\\mathbf{k} = \\frac{2\\pi}{L} \\mathbf{n}$ for integer triplets $\\mathbf{n} \\in \\mathbb{Z}^3 \\setminus \\{\\mathbf{0}\\}$. The Fourier-space charge density is denoted $\\rho(\\mathbf{k})$ and is assumed to satisfy $\\rho(-\\mathbf{k}) = \\rho(\\mathbf{k})$ so that fields are real. Assume that the reciprocal-space electric field at position $\\mathbf{r}$ due to the mode amplitudes $\\rho(\\mathbf{k})$ is given by the standard Ewald-screened Fourier representation, summed over a truncated set of modes $\\{\\mathbf{k} : 0  \\lVert \\mathbf{k} \\rVert \\le k_c\\}$, where $k_c > 0$ is a reciprocal cutoff. The forces on the particles are $\\mathbf{F}_i = q_i \\mathbf{E}(\\mathbf{r}_i)$.\n\nStarting from these definitions and the core principle that the Ewald splitting introduces a Gaussian factor $\\exp\\left(-\\lVert \\mathbf{k} \\rVert^2 / (4 \\alpha^2)\\right)$ on each reciprocal mode, complete the following tasks:\n\n1. Derive from first principles the expression for the reciprocal-space electric field $\\mathbf{E}(\\mathbf{r})$ and then derive the sensitivity of the forces with respect to the screening parameter, $\\partial \\mathbf{F}_i / \\partial \\alpha$, in terms of $\\rho(\\mathbf{k})$, $\\alpha$, and trigonometric functions of $\\mathbf{k} \\cdot \\mathbf{r}_i$. Your derivation must begin with the Fourier representation of the screened potential and proceed by taking spatial gradients and differentiating with respect to $\\alpha$.\n\n2. Propose an adaptive strategy for choosing $\\alpha(t)$ based on the instantaneous spectrum of $\\rho(\\mathbf{k})$. Your strategy must balance a model of real-space truncation error and reciprocal-space truncation error. Use a discrete scalar objective $J(\\alpha)$ that increases with either truncation error and specify how to choose $\\alpha$ that minimizes $J(\\alpha)$.\n\n3. Implement a program that:\n   - Constructs a cubic box with $L = 6.0$ and volume $V = L^3$.\n   - Uses reciprocal vectors $\\mathbf{k} = \\frac{2\\pi}{L} \\mathbf{n}$ with integer components $n_x, n_y, n_z$ in the range $-N_{\\text{outer}} \\le n_\\mu \\le N_{\\text{outer}}$ excluding $\\mathbf{n} = \\mathbf{0}$, with $N_{\\text{outer}} = 6$. Define the reciprocal cutoff by $N_c = 3$ so that $k_c = \\frac{2\\pi}{L} N_c$, and define the outer evaluation limit $k_{\\text{outer}} = \\frac{2\\pi}{L} N_{\\text{outer}}$.\n   - Defines four particle positions and charges:\n     - $\\mathbf{r}_1 = (0.7, 1.3, 2.9)$, $q_1 = 1.0$.\n     - $\\mathbf{r}_2 = (2.2, 4.5, 1.1)$, $q_2 = -1.5$.\n     - $\\mathbf{r}_3 = (5.1, 0.4, 3.8)$, $q_3 = 0.7$.\n     - $\\mathbf{r}_4 = (1.9, 3.3, 5.5)$, $q_4 = -0.6$.\n   - Uses the following four spectra for $\\rho(\\mathbf{k})$ as functions of $\\lVert \\mathbf{k} \\rVert$, each defined for all modes with $0  \\lVert \\mathbf{k} \\rVert \\le k_{\\text{outer}}$, and with $\\rho(-\\mathbf{k}) = \\rho(\\mathbf{k})$:\n     1. White spectrum: $\\rho(\\mathbf{k}) = 1$.\n     2. Low-$k$ dominated: $\\rho(\\mathbf{k}) = \\exp\\left(-(\\lVert \\mathbf{k} \\rVert / k_0)^2\\right)$ with $k_0 = 0.5\\, k_c$.\n     3. High-$k$ dominated: $\\rho(\\mathbf{k}) = \\left(\\lVert \\mathbf{k} \\rVert / k_c\\right)^2 \\exp\\left(-\\left(\\lVert \\mathbf{k} \\rVert - 1.5\\, k_c\\right)^2 / \\sigma^2\\right)$ with $\\sigma = 0.3\\, k_c$.\n     4. Single-mode: $\\rho(\\mathbf{k}) = 1$ if $\\lVert \\mathbf{k} \\rVert$ equals the smallest nonzero magnitude (within a tolerance of $10^{-8}$), and $\\rho(\\mathbf{k}) = 0$ otherwise.\n   - For a fixed $\\alpha_0 = 1.0$ and a symmetric finite-difference step $\\delta\\alpha = 10^{-4}$, computes for each spectrum:\n     - The analytic $\\partial \\mathbf{F}_i / \\partial \\alpha$ for all particles using only modes with $0  \\lVert \\mathbf{k} \\rVert \\le k_c$.\n     - A central-difference approximation $\\left(\\mathbf{F}_i(\\alpha_0 + \\delta\\alpha) - \\mathbf{F}_i(\\alpha_0 - \\delta\\alpha)\\right) / (2 \\delta\\alpha)$ for the same force definition.\n     - The root-mean-square error (a single scalar) between the analytic and finite-difference sensitivities, aggregated over all particles and Cartesian components.\n   - Implements your adaptive $\\alpha$ selection by minimizing the scalar objective\n     $$J(\\alpha) = \\left[\\operatorname{erfc}(\\alpha r_c)\\right]^2 + \\sum_{\\lVert \\mathbf{k} \\rVert > k_c}^{\\lVert \\mathbf{k} \\rVert \\le k_{\\text{outer}}} \\left[\\rho(\\mathbf{k}) \\exp\\left(-\\frac{\\lVert \\mathbf{k} \\rVert^2}{2 \\alpha^2}\\right)\\right]^2,$$\n     where $r_c = 2.0$ and $\\operatorname{erfc}$ is the complementary error function. Use a uniform grid search over $\\alpha \\in [0.4, 2.0]$ with at least $200$ points to find $\\alpha^\\star$ that minimizes $J(\\alpha)$, for each spectrum separately.\n   - Outputs a single line containing the results as a comma-separated list enclosed in square brackets. The list must contain $8$ floats in the following order: for each spectrum in the order given (white, low-$k$, high-$k$, single-mode), the root-mean-square error followed by the recommended $\\alpha^\\star$. For example, the output format is $[e_1,\\alpha^\\star_1,e_2,\\alpha^\\star_2,e_3,\\alpha^\\star_3,e_4,\\alpha^\\star_4]$.\n\nScientific and numerical requirements:\n- All quantities are dimensionless.\n- Trigonometric functions must be in radians.\n- The implementation must be self-contained and must not require any input.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[0.001,1.234,0.002,1.111,0.003,0.987,0.0001,1.543]$).", "solution": "The problem statement is found to be valid upon critical examination. It is scientifically grounded in the principles of computational physics, specifically the Ewald summation method for periodic electrostatic interactions. The problem is well-posed, objective, and provides all necessary data and constraints for a unique and meaningful solution. While it contains a non-standard formulation for an error-optimization objective function, this is interpreted as a given modeling choice and does not constitute a fundamental flaw.\n\nThe solution is divided into three parts as requested: a theoretical derivation, the formulation of an adaptive strategy, and a numerical implementation.\n\n### 1. Derivation of Reciprocal-Space Field and Force Sensitivity\n\nThe derivation begins with the Fourier representation of the electrostatic potential and proceeds to the electric field and its sensitivity to the Ewald screening parameter $\\alpha$.\n\n**1.1. Reciprocal-Space Electric Field $\\mathbf{E}(\\mathbf{r})$**\n\nThe electrostatic potential $\\phi(\\mathbf{r})$ in a periodic system can be represented by a Fourier series. The reciprocal-space component $\\phi_{\\text{rec}}(\\mathbf{r})$ accounts for the long-range part of the potential, screened by a Gaussian charge distribution. For a system of volume $V = L^3$, the potential is given by:\n$$\n\\phi_{\\text{rec}}(\\mathbf{r}) = \\frac{1}{V} \\sum_{\\mathbf{k} \\ne \\mathbf{0}} \\hat{\\phi}_{\\text{rec}}(\\mathbf{k}) e^{i \\mathbf{k} \\cdot \\mathbf{r}}\n$$\nwhere $\\mathbf{k} = \\frac{2\\pi}{L}\\mathbf{n}$ are the reciprocal lattice vectors for integer triplets $\\mathbf{n}$.\n\nThe Fourier coefficients $\\hat{\\phi}_{\\text{rec}}(\\mathbf{k})$ are obtained from solving the screened Poisson equation in Fourier space. The solution includes the standard Ewald screening factor, $\\exp(-\\lVert \\mathbf{k} \\rVert^2 / (4\\alpha^2))$. For a Fourier-space charge density $\\rho(\\mathbf{k})$, the coefficients are:\n$$\n\\hat{\\phi}_{\\text{rec}}(\\mathbf{k}) = C \\frac{\\rho(\\mathbf{k})}{\\lVert \\mathbf{k} \\rVert^2} \\exp\\left(-\\frac{\\lVert \\mathbf{k} \\rVert^2}{4 \\alpha^2}\\right)\n$$\nIn dimensionless units, it is common to set the prefactor constant $C=1$. (In Gaussian units, $C=4\\pi$.) The problem specifies $\\rho(\\mathbf{k})$ is real and satisfies $\\rho(-\\mathbf{k}) = \\rho(\\mathbf{k})$. This implies that the imaginary (sine) components of $e^{i\\mathbf{k}\\cdot\\mathbf{r}}$ will cancel out when summed over symmetric pairs $(\\mathbf{k}, -\\mathbf{k})$, leaving a purely real potential represented by a cosine series.\n$$\n\\phi_{\\text{rec}}(\\mathbf{r}) = \\frac{1}{V} \\sum_{\\mathbf{k} \\ne \\mathbf{0}} \\frac{\\rho(\\mathbf{k})}{\\lVert \\mathbf{k} \\rVert^2} \\exp\\left(-\\frac{\\lVert \\mathbf{k} \\rVert^2}{4 \\alpha^2}\\right) \\cos(\\mathbf{k} \\cdot \\mathbf{r})\n$$\nThe electric field $\\mathbf{E}(\\mathbf{r})$ is the negative gradient of the potential, $\\mathbf{E}(\\mathbf{r}) = -\\nabla \\phi_{\\text{rec}}(\\mathbf{r})$. Applying the gradient operator:\n$$\n\\mathbf{E}(\\mathbf{r}) = -\\nabla \\left[ \\frac{1}{V} \\sum_{\\mathbf{k} \\ne \\mathbf{0}} \\frac{\\rho(\\mathbf{k})}{\\lVert \\mathbf{k} \\rVert^2} \\exp\\left(-\\frac{\\lVert \\mathbf{k} \\rVert^2}{4 \\alpha^2}\\right) \\cos(\\mathbf{k} \\cdot \\mathbf{r}) \\right]\n$$\nThe gradient of the cosine term is $\\nabla \\cos(\\mathbf{k} \\cdot \\mathbf{r}) = -\\mathbf{k} \\sin(\\mathbf{k} \\cdot \\mathbf{r})$. This yields the expression for the electric field, summed over the truncated set of modes $0  \\lVert \\mathbf{k} \\rVert \\le k_c$:\n$$\n\\mathbf{E}(\\mathbf{r}) = \\frac{1}{V} \\sum_{0  \\lVert \\mathbf{k} \\rVert \\le k_c} \\frac{\\rho(\\mathbf{k}) \\mathbf{k}}{\\lVert \\mathbf{k} \\rVert^2} \\exp\\left(-\\frac{\\lVert \\mathbf{k} \\rVert^2}{4 \\alpha^2}\\right) \\sin(\\mathbf{k} \\cdot \\mathbf{r})\n$$\n\n**1.2. Force Sensitivity $\\partial \\mathbf{F}_i / \\partial \\alpha$**\n\nThe electrostatic force on particle $i$ is $\\mathbf{F}_i = q_i \\mathbf{E}(\\mathbf{r}_i)$. The sensitivity of this force with respect to the screening parameter $\\alpha$ is found by taking the partial derivative $\\partial \\mathbf{F}_i / \\partial \\alpha$:\n$$\n\\frac{\\partial \\mathbf{F}_i}{\\partial \\alpha} = q_i \\frac{\\partial \\mathbf{E}(\\mathbf{r}_i; \\alpha)}{\\partial \\alpha}\n$$\nWe differentiate the expression for $\\mathbf{E}(\\mathbf{r})$ with respect to $\\alpha$. The only term dependent on $\\alpha$ is the exponential factor. Using the chain rule:\n$$\n\\frac{\\partial}{\\partial \\alpha} \\exp\\left(-\\frac{\\lVert \\mathbf{k} \\rVert^2}{4 \\alpha^2}\\right) = \\exp\\left(-\\frac{\\lVert \\mathbf{k} \\rVert^2}{4 \\alpha^2}\\right) \\cdot \\frac{\\partial}{\\partial \\alpha}\\left(-\\frac{\\lVert \\mathbf{k} \\rVert^2}{4} \\alpha^{-2}\\right) = \\exp\\left(-\\frac{\\lVert \\mathbf{k} \\rVert^2}{4 \\alpha^2}\\right) \\cdot \\left(\\frac{\\lVert \\mathbf{k} \\rVert^2}{2 \\alpha^3}\\right)\n$$\nSubstituting this into the expression for $\\partial \\mathbf{E} / \\partial \\alpha$:\n$$\n\\frac{\\partial \\mathbf{E}(\\mathbf{r}; \\alpha)}{\\partial \\alpha} = \\frac{1}{V} \\sum_{0  \\lVert \\mathbf{k} \\rVert \\le k_c} \\frac{\\rho(\\mathbf{k}) \\mathbf{k}}{\\lVert \\mathbf{k} \\rVert^2} \\left[ \\frac{\\lVert \\mathbf{k} \\rVert^2}{2 \\alpha^3} \\exp\\left(-\\frac{\\lVert \\mathbf{k} \\rVert^2}{4 \\alpha^2}\\right) \\right] \\sin(\\mathbf{k} \\cdot \\mathbf{r})\n$$\nThe $\\lVert \\mathbf{k} \\rVert^2$ terms in the numerator and denominator cancel, leading to the simplified expression for the field sensitivity:\n$$\n\\frac{\\partial \\mathbf{E}(\\mathbf{r}; \\alpha)}{\\partial \\alpha} = \\frac{1}{2V\\alpha^3} \\sum_{0  \\lVert \\mathbf{k} \\rVert \\le k_c} \\rho(\\mathbf{k}) \\mathbf{k} \\exp\\left(-\\frac{\\lVert \\mathbf{k} \\rVert^2}{4 \\alpha^2}\\right) \\sin(\\mathbf{k} \\cdot \\mathbf{r})\n$$\nFinally, the force sensitivity for particle $i$ is:\n$$\n\\frac{\\partial \\mathbf{F}_i}{\\partial \\alpha} = \\frac{q_i}{2V\\alpha^3} \\sum_{0  \\lVert \\mathbf{k} \\rVert \\le k_c} \\rho(\\mathbf{k}) \\mathbf{k} \\exp\\left(-\\frac{\\lVert \\mathbf{k} \\rVert^2}{4 \\alpha^2}\\right) \\sin(\\mathbf{k} \\cdot \\mathbf{r}_i)\n$$\n\n### 2. Adaptive Strategy for Selecting $\\alpha$\n\nThe choice of $\\alpha$ represents a trade-off: a large $\\alpha$ concentrates the screening charge narrowly, leading to rapid decay in real space (low real-space error) but slow decay in reciprocal space (high reciprocal-space error). Conversely, a small $\\alpha$ yields low reciprocal-space error but high real-space error. An optimal $\\alpha$ balances these two competing error sources.\n\nThe problem provides a specific objective function $J(\\alpha)$ that models this trade-off:\n$$\nJ(\\alpha) = \\underbrace{\\left[\\operatorname{erfc}(\\alpha r_c)\\right]^2}_{J_{\\text{real}}(\\alpha)} + \\underbrace{\\sum_{\\lVert \\mathbf{k} \\rVert > k_c}^{\\lVert \\mathbf{k} \\rVert \\le k_{\\text{outer}}} \\left[\\rho(\\mathbf{k}) \\exp\\left(-\\frac{\\lVert \\mathbf{k} \\rVert^2}{2 \\alpha^2}\\right)\\right]^2}_{J_{\\text{rec}}(\\alpha)}\n$$\n-   The first term, $J_{\\text{real}}(\\alpha)$, models the real-space truncation error. The complementary error function $\\operatorname{erfc}(x)$ is a monotonically decreasing function. Thus, $J_{\\text{real}}(\\alpha)$ decreases as $\\alpha$ increases, penalizing small $\\alpha$ values.\n-   The second term, $J_{\\text{rec}}(\\alpha)$, models the reciprocal-space truncation error by summing the squared magnitudes of the first neglected terms. The exponential factor $\\exp(-\\lVert \\mathbf{k} \\rVert^2 / (2 \\alpha^2))$ increases as $\\alpha$ increases (for a fixed $\\mathbf{k}$), meaning $J_{\\text{rec}}(\\alpha)$ is a monotonically increasing function of $\\alpha$. It penalizes large $\\alpha$ values.\n\nThe adaptive strategy is to find the value of $\\alpha$, denoted $\\alpha^\\star$, that minimizes the total error model $J(\\alpha)$. Since $J(\\alpha)$ is a sum of a decreasing and an increasing function, it is expected to have a unique minimum. The proposed strategy is a numerical grid search:\n1.  Define a discrete grid of candidate $\\alpha$ values over the specified interval $\\alpha \\in [0.4, 2.0]$.\n2.  For each $\\alpha$ on the grid, evaluate $J(\\alpha)$ using the given system parameters ($r_c$, $k_c$, $k_{\\text{outer}}$) and the instantaneous charge spectrum $\\rho(\\mathbf{k})$.\n3.  Identify the value $\\alpha^\\star$ from the grid that yields the minimum value of $J(\\alpha)$.\n\nThis $\\alpha^\\star$ represents the optimal choice for the given charge configuration, balancing the estimated real and reciprocal space errors according to the provided model.\n\n### 3. Implementation\n\nThe following section provides the Python code that implements the calculations as specified. It computes the root-mean-square error between the analytically derived force sensitivity and a finite-difference approximation. It also performs the grid search to find the optimal $\\alpha^\\star$ for four different charge density spectra.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import erfc\n\ndef solve():\n    \"\"\"\n    Solves the particle mesh Ewald-related problem, including force sensitivity\n    analysis and adaptive alpha parameter selection.\n    \"\"\"\n    # Define system parameters and constants as per the problem statement\n    L = 6.0\n    V = L**3\n    N_outer = 6\n    N_c = 3\n    k_c = 2 * np.pi / L * N_c\n    k_outer = 2 * np.pi / L * N_outer\n    \n    # Define particle properties: positions and charges\n    positions = np.array([\n        [0.7, 1.3, 2.9],\n        [2.2, 4.5, 1.1],\n        [5.1, 0.4, 3.8],\n        [1.9, 3.3, 5.5]\n    ])\n    charges = np.array([1.0, -1.5, 0.7, -0.6])\n    \n    # Generate reciprocal lattice vectors\n    n_range = np.arange(-N_outer, N_outer + 1)\n    nx, ny, nz = np.meshgrid(n_range, n_range, n_range, indexing='ij')\n    n_vecs = np.stack((nx.ravel(), ny.ravel(), nz.ravel()), axis=1)\n    \n    # Exclude the n=(0,0,0) vector\n    mask_zero = np.all(n_vecs == 0, axis=1)\n    n_vecs = n_vecs[~mask_zero]\n    \n    k_vecs = (2 * np.pi / L) * n_vecs\n    k_mags = np.linalg.norm(k_vecs, axis=1)\n\n    # Define the charge density spectra\n    spectra_names = ['white', 'low-k', 'high-k', 'single-mode']\n    k0 = 0.5 * k_c\n    sigma = 0.3 * k_c\n    \n    # Smallest nonzero k-magnitude for the single-mode spectrum\n    k_min = np.min(k_mags[k_mags > 1e-9])\n\n    def get_rho(k_magnitudes, spectrum_name):\n        if spectrum_name == 'white':\n            return np.ones_like(k_magnitudes)\n        elif spectrum_name == 'low-k':\n            return np.exp(-(k_magnitudes / k0)**2)\n        elif spectrum_name == 'high-k':\n            return (k_magnitudes / k_c)**2 * np.exp(-((k_magnitudes - 1.5 * k_c) / sigma)**2)\n        elif spectrum_name == 'single-mode':\n            return np.isclose(k_magnitudes, k_min, atol=1e-8).astype(float)\n        else:\n            raise ValueError(f\"Unknown spectrum name: {spectrum_name}\")\n\n    results = []\n    \n    # Iterate through each spectrum to perform calculations\n    for name in spectra_names:\n        # Generate the full spectrum of rho(k) up to k_outer\n        rho_k_full = get_rho(k_mags, name)\n        \n        # --- Task 1: Sensitivity Calculation and RMSE ---\n        alpha0 = 1.0\n        delta_alpha = 1e-4\n\n        # Filter k-vectors for force calculation (0  ||k|| = k_c)\n        mask_force = k_mags = k_c\n        k_vecs_force = k_vecs[mask_force]\n        k_mags_force = k_mags[mask_force]\n        rho_k_force = rho_k_full[mask_force]\n\n        def calculate_forces(alpha, k_v, k_m, rho_k, pos, chg, vol):\n            forces = np.zeros_like(pos)\n            prefactor = 1.0 / vol\n            for i in range(len(chg)):\n                dotprods = k_v @ pos[i]\n                sins = np.sin(dotprods)\n                \n                k_m_sq_inv = np.zeros_like(k_m)\n                valid_k = k_m > 1e-9\n                k_m_sq_inv[valid_k] = 1.0 / k_m[valid_k]**2\n\n                exp_term = np.exp(-k_m**2 / (4 * alpha**2))\n                common_factor = rho_k * k_m_sq_inv * exp_term * sins\n                force_sum = np.sum(common_factor[:, np.newaxis] * k_v, axis=0)\n                forces[i, :] = chg[i] * prefactor * force_sum\n            return forces\n\n        def calculate_force_deriv_analytic(alpha, k_v, k_m, rho_k, pos, chg, vol):\n            derivs = np.zeros_like(pos)\n            prefactor = 1.0 / (2 * vol * alpha**3)\n            for i in range(len(chg)):\n                dotprods = k_v @ pos[i]\n                sins = np.sin(dotprods)\n                exp_term = np.exp(-k_m**2 / (4 * alpha**2))\n                common_factor = rho_k * exp_term * sins\n                deriv_sum = np.sum(common_factor[:, np.newaxis] * k_v, axis=0)\n                derivs[i, :] = chg[i] * prefactor * deriv_sum\n            return derivs\n        \n        F_analytic = calculate_force_deriv_analytic(alpha0, k_vecs_force, k_mags_force, rho_k_force, positions, charges, V)\n        \n        F_plus = calculate_forces(alpha0 + delta_alpha, k_vecs_force, k_mags_force, rho_k_force, positions, charges, V)\n        F_minus = calculate_forces(alpha0 - delta_alpha, k_vecs_force, k_mags_force, rho_k_force, positions, charges, V)\n        F_numeric = (F_plus - F_minus) / (2 * delta_alpha)\n        \n        rmse = np.sqrt(np.mean((F_analytic - F_numeric)**2))\n        results.append(rmse)\n\n        # --- Task 2: Adaptive alpha selection ---\n        r_c = 2.0\n        alpha_grid = np.linspace(0.4, 2.0, 201)\n\n        # Filter k-vectors for J_rec calculation (k_c  ||k|| = k_outer)\n        mask_J = (k_mags > k_c)  (k_mags = k_outer)\n        k_mags_J = k_mags[mask_J]\n        rho_k_J = rho_k_full[mask_J]\n        \n        J_values = np.zeros_like(alpha_grid)\n        for j, alpha_val in enumerate(alpha_grid):\n            J_real = erfc(alpha_val * r_c)**2\n            exp_term = np.exp(-k_mags_J**2 / (2 * alpha_val**2))\n            terms = rho_k_J * exp_term\n            J_rec = np.sum(terms**2)\n            J_values[j] = J_real + J_rec\n        \n        alpha_star = alpha_grid[np.argmin(J_values)]\n        results.append(alpha_star)\n\n    # Format and print the final output as a single-line comma-separated list\n    print(f\"[{','.join(f'{x:.8f}' for x in results)}]\")\n\nsolve()\n```", "id": "3473558"}, {"introduction": "While standard PME offers a dramatic speedup, its performance can be further enhanced by moving beyond a single grid. This exercise challenges you to design and evaluate a more advanced \"twin-grid\" PME scheme, where the reciprocal-space calculation is split between a coarse grid for long wavelengths and a fine grid for intermediate ones. You will learn to construct and analyze the spectral filters that make this partition possible, providing a hands-on introduction to a frontier of fast electrostatic algorithm design [@problem_id:3473525].", "problem": "You are tasked with designing and evaluating a two-grid spectral splitting for the Particle Mesh Ewald method, formally known as the Particle Mesh Ewald (PME) technique, in a three-dimensional periodic cubic cell. The twin-grid design uses a coarse mesh to capture long-wavelength content and a fine mesh to capture intermediate wavelengths, leaving short wavelengths to be handled by the real-space part of the Ewald decomposition. Your program must construct smooth, radial filters in reciprocal space for the coarse and fine grids, denoted by $F_c(\\mathbf{k})$ and $F_f(\\mathbf{k})$, respectively, and quantitatively analyze two properties: minimal spectral overlap and stable force response.\n\nFundamental base:\n- The electrostatic potential $\\phi(\\mathbf{r})$ in a periodic cubic box of side length $L$ obeys Poisson’s equation $\\nabla^2 \\phi(\\mathbf{r}) = - \\rho(\\mathbf{r}) / \\varepsilon_0$ for charge density $\\rho(\\mathbf{r})$. Under Ewald decomposition, the reciprocal-space Green’s function for the damped Coulomb interaction is given by $G(\\mathbf{k}) = \\dfrac{4\\pi}{\\lVert \\mathbf{k} \\rVert^2} \\exp\\!\\left(-\\dfrac{\\lVert \\mathbf{k} \\rVert^2}{4 \\alpha^2}\\right)$, where $\\alpha$ is the Ewald screening parameter and $\\mathbf{k}$ is the reciprocal vector. The PME approach replaces continuous $\\rho(\\mathbf{r})$ by charges interpolated onto a mesh using a compact assignment kernel whose Fourier transform suppresses high-frequency modes.\n- For a uniform mesh with spacing $\\Delta x$, dimension-by-dimension cardinal $m$-th order B-spline assignment gives a separable Fourier attenuation factor. In reciprocal space, the attenuation per Cartesian component $k_d$ is $\\operatorname{sinc}\\!\\left(\\dfrac{k_d \\Delta x}{2}\\right)^m$, where $\\operatorname{sinc}(x) = \\dfrac{\\sin(x)}{x}$, and the three-dimensional factor is the product over $d \\in \\{x,y,z\\}$.\n\nDesign task:\n- Consider a cubic box with side length $L = 1$ in arbitrary length units (dimensionless). Let the coarse grid have $N_c$ points per side, spacing $\\Delta x_c = \\dfrac{L}{N_c}$, and the fine grid have $N_f$ points per side, spacing $\\Delta x_f = \\dfrac{L}{N_f}$. Define the fine-grid component Nyquist wavenumber $k_{\\text{Ny},f} = \\pi N_f / L$. You will construct $F_c(\\mathbf{k})$ and $F_f(\\mathbf{k})$ as smooth radial functions of $\\lVert \\mathbf{k} \\rVert$, using raised-cosine windows to form one low-pass ($F_c$) and one band-pass ($F_f$) filter:\n    - The coarse filter $F_c$ is a radial low-pass with transition centered at $k_c$ and half-width $\\delta_c$, defined by a raised-cosine transition function $W(x)$ that equals $1$ at $x \\le -1$, $0$ at $x \\ge +1$, and smoothly interpolates via $$W(x) = \\dfrac{1}{2}\\left(1 + \\cos(\\pi x)\\right)$$ for $x \\in [-1,1]$. Use $F_c(\\mathbf{k}) = W\\!\\left(\\dfrac{\\lVert \\mathbf{k} \\rVert - k_c}{\\delta_c}\\right)$.\n    - The fine filter $F_f$ is the product of a high-pass complement to the coarse transition and a high-frequency roll-off low-pass centered at $k_f$ with half-width $\\delta_f$: $F_f(\\mathbf{k}) = \\left(1 - W\\!\\left(\\dfrac{\\lVert \\mathbf{k} \\rVert - k_c}{\\delta_c}\\right)\\right) \\cdot W\\!\\left(\\dfrac{\\lVert \\mathbf{k} \\rVert - k_f}{\\delta_f}\\right)$. Here $k_c = \\gamma_c\\, k_{\\text{Ny},f}$ and $k_f = \\gamma_f\\, k_{\\text{Ny},f}$ for given dimensionless fractions $\\gamma_c$ and $\\gamma_f$, and $\\delta_c = \\eta_c\\, k_{\\text{Ny},f}$, $\\delta_f = \\eta_f\\, k_{\\text{Ny},f}$.\n- Charge assignment onto each mesh uses a cardinal B-spline of order $m_c$ for the coarse grid and $m_f$ for the fine grid. The corresponding three-dimensional attenuation factors are $S_c(\\mathbf{k}) = \\prod_{d\\in\\{x,y,z\\}} \\operatorname{sinc}\\!\\left(\\dfrac{k_d \\Delta x_c}{2}\\right)^{m_c}$ and $S_f(\\mathbf{k}) = \\prod_{d\\in\\{x,y,z\\}} \\operatorname{sinc}\\!\\left(\\dfrac{k_d \\Delta x_f}{2}\\right)^{m_f}$.\n- The combined reciprocal-space transfer function (potential per unit charge) of the twin-grid PME is $T(\\mathbf{k}) = G(\\mathbf{k}) \\left(F_c(\\mathbf{k}) S_c(\\mathbf{k}) + F_f(\\mathbf{k}) S_f(\\mathbf{k})\\right)$. The force amplitude per mode scales as $\\lVert \\mathbf{k} \\rVert \\, T(\\mathbf{k})$.\n\nProgram requirements:\n- Work on the discrete reciprocal lattice induced by the fine grid: let each component $k_d = \\dfrac{2\\pi n_d}{L}$ with $n_d \\in \\{-\\lfloor \\dfrac{N_f}{2}\\rfloor, \\ldots, \\lfloor \\dfrac{N_f}{2}\\rfloor\\}$. Exclude the $\\mathbf{k} = \\mathbf{0}$ mode from any denominator or maximum calculation to avoid singularities.\n- Compute the following quantitative metrics:\n    $1.$ Minimal overlap: $O = \\text{mean}_{\\mathbf{k}} \\left(F_c(\\mathbf{k})^2 F_f(\\mathbf{k})^2\\right)$ over the discrete lattice.\n    $2.$ Partition-of-unity deviation in the usable band: $E_{\\text{PU}} = \\max_{\\mathbf{k}} \\left|F_c(\\mathbf{k}) + F_f(\\mathbf{k}) - 1\\right|$ evaluated only for modes with $\\lVert \\mathbf{k} \\rVert \\le k_f - \\delta_f$ and $\\mathbf{k} \\ne \\mathbf{0}$.\n    $3.$ Force stability ratio: $R = \\dfrac{\\max_{\\mathbf{k}} \\left(\\lVert \\mathbf{k} \\rVert \\, T(\\mathbf{k})\\right)}{\\max_{\\mathbf{k}} \\left(\\lVert \\mathbf{k} \\rVert \\, G(\\mathbf{k})\\right)}$, again over $\\mathbf{k} \\ne \\mathbf{0}$, which should not exceed unity by a significant margin for stability.\n- Use dimensionless units throughout with $L = 1$, and express all outputs as dimensionless floats. Angles, if used, must be in radians.\n\nTest suite:\nProvide results for the following three parameter sets, where $\\alpha$ is in inverse-length units but dimensionless because $L = 1$:\n- Case $1$ (general case): $\\alpha = 3.5$, $N_c = 16$, $N_f = 64$, $m_c = 4$, $m_f = 6$, $\\gamma_c = 0.30$, $\\eta_c = 0.05$, $\\gamma_f = 0.85$, $\\eta_f = 0.05$.\n- Case $2$ (high overlap boundary): $\\alpha = 3.5$, $N_c = 16$, $N_f = 64$, $m_c = 4$, $m_f = 6$, $\\gamma_c = 0.30$, $\\eta_c = 0.20$, $\\gamma_f = 0.85$, $\\eta_f = 0.05$.\n- Case $3$ (extremely coarse coarse-grid edge case): $\\alpha = 3.0$, $N_c = 8$, $N_f = 64$, $m_c = 3$, $m_f = 6$, $\\gamma_c = 0.15$, $\\eta_c = 0.05$, $\\gamma_f = 0.90$, $\\eta_f = 0.05$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with the three metrics flattened across the three cases in order. For example, it should print $[O_1,E_{\\text{PU},1},R_1,O_2,E_{\\text{PU},2},R_2,O_3,E_{\\text{PU},3},R_3]$ as dimensionless floats.", "solution": "The problem posed is a valid and well-defined task in the field of computational materials science, specifically concerning the analysis of a twin-grid spectral splitting scheme for the Particle Mesh Ewald (PME) method. All required physical constants, mathematical definitions, and numerical parameters are provided, and the problem is scientifically grounded, objective, and internally consistent. We can therefore proceed with a full solution.\n\nThe objective is to design and evaluate a two-grid PME spectral splitting scheme by constructing smooth radial filters for a coarse and a fine grid, and then quantifying their performance based on spectral overlap, partition-of-unity deviation, and force response stability. The analysis will be performed on a discrete reciprocal lattice for three specific sets of parameters.\n\nThe foundation of the PME method is the Ewald decomposition of the Coulomb interaction, which splits the problem into a short-range real-space part and a long-range reciprocal-space part. The reciprocal-space contribution is calculated by solving Poisson's equation on a grid. The potential $\\phi(\\mathbf{r})$ is related to the charge density $\\rho(\\mathbf{r})$ by $\\nabla^2 \\phi(\\mathbf{r}) = - \\rho(\\mathbf{r}) / \\varepsilon_0$. In reciprocal space, this becomes $\\lVert \\mathbf{k} \\rVert^2 \\hat{\\phi}(\\mathbf{k}) = \\hat{\\rho}(\\mathbf{k}) / \\varepsilon_0$. The Ewald trick introduces a screening charge distribution, leading to a damped real-space potential and a modified reciprocal-space potential. The reciprocal-space Green's function for this damped interaction is given as:\n$$\nG(\\mathbf{k}) = \\dfrac{4\\pi}{\\lVert \\mathbf{k} \\rVert^2} \\exp\\!\\left(-\\dfrac{\\lVert \\mathbf{k} \\rVert^2}{4 \\alpha^2}\\right)\n$$\nwhere $\\mathbf{k}$ is the reciprocal-space vector and $\\alpha$ is the Ewald screening parameter.\n\nOur analysis is performed in a dimensionless cubic periodic box of side length $L=1$. The reciprocal lattice vectors are defined on a grid corresponding to a fine mesh of $N_f \\times N_f \\times N_f$ points. The components of a reciprocal vector $\\mathbf{k}$ are given by $k_d = \\frac{2\\pi n_d}{L}$ for $d \\in \\{x,y,z\\}$, where the integers $n_d$ range from $-\\lfloor N_f/2 \\rfloor$ to $\\lfloor N_f/2 \\rfloor$. The magnitude is $\\lVert \\mathbf{k} \\rVert = \\sqrt{k_x^2 + k_y^2 + k_z^2}$. The special case $\\mathbf{k}=\\mathbf{0}$ corresponds to the overall system charge neutrality and is excluded from calculations involving division by $\\lVert \\mathbf{k} \\rVert$ or from maxima of singular quantities.\n\nThe twin-grid approach uses two spectral filters, $F_c(\\mathbf{k})$ for the coarse grid and $F_f(\\mathbf{k})$ for the fine grid, to partition the reciprocal-space calculation. These filters are constructed using a raised-cosine window function, $W(x)$, defined as:\n$$\nW(x) =\n\\begin{cases}\n1  x \\le -1 \\\\\n\\frac{1}{2} (1 + \\cos(\\pi x))  -1  x  1 \\\\\n0  x \\ge 1\n\\end{cases}\n$$\nThe coarse filter $F_c(\\mathbf{k})$ is a low-pass filter, and the fine filter $F_f(\\mathbf{k})$ is a band-pass filter. Their definitions are:\n$$\nF_c(\\mathbf{k}) = W\\!\\left(\\dfrac{\\lVert \\mathbf{k} \\rVert - k_c}{\\delta_c}\\right)\n$$\n$$\nF_f(\\mathbf{k}) = \\left(1 - W\\!\\left(\\dfrac{\\lVert \\mathbf{k} \\rVert - k_c}{\\delta_c}\\right)\\right) \\cdot W\\!\\left(\\dfrac{\\lVert \\mathbf{k} \\rVert - k_f}{\\delta_f}\\right)\n$$\nThe transition centers $k_c, k_f$ and half-widths $\\delta_c, \\delta_f$ are defined relative to the fine-grid Nyquist frequency, $k_{\\text{Ny},f} = \\pi N_f/L$:\n$k_c = \\gamma_c k_{\\text{Ny},f}$, $\\delta_c = \\eta_c k_{\\text{Ny},f}$, $k_f = \\gamma_f k_{\\text{Ny},f}$, and $\\delta_f = \\eta_f k_{\\text{Ny},f}$.\n\nThe PME method interpolates particle charges onto the grids using an assignment function, typically a cardinal B-spline of order $m$. This process introduces a Fourier-space attenuation factor, $S(\\mathbf{k})$. For the coarse and fine grids with spacings $\\Delta x_c = L/N_c$ and $\\Delta x_f = L/N_f$, and spline orders $m_c$ and $m_f$, these factors are:\n$$\nS_c(\\mathbf{k}) = \\prod_{d\\in\\{x,y,z\\}} \\left( \\operatorname{sinc}\\!\\left(\\dfrac{k_d \\Delta x_c}{2}\\right) \\right)^{m_c}\n$$\n$$\nS_f(\\mathbf{k}) = \\prod_{d\\in\\{x,y,z\\}} \\left( \\operatorname{sinc}\\!\\left(\\dfrac{k_d \\Delta x_f}{2}\\right) \\right)^{m_f}\n$$\nwhere the problem specifies $\\operatorname{sinc}(x) = \\sin(x)/x$.\n\nThe total reciprocal-space transfer function $T(\\mathbf{k})$ for the twin-grid scheme combines these elements:\n$$\nT(\\mathbf{k}) = G(\\mathbf{k}) \\left( F_c(\\mathbf{k}) S_c(\\mathbf{k}) + F_f(\\mathbf{k}) S_f(\\mathbf{k}) \\right)\n$$\nWe will now compute the three specified metrics for each parameter set.\n\n1.  **Minimal Overlap, $O$**: This metric quantifies the degree to which the two filters are simultaneously non-zero, which can lead to redundant computations. It is calculated as the mean-square product of the filter functions over the entire discrete reciprocal lattice.\n    $$\n    O = \\text{mean}_{\\mathbf{k}} \\left(F_c(\\mathbf{k})^2 F_f(\\mathbf{k})^2\\right)\n    $$\n2.  **Partition-of-Unity Deviation, $E_{\\text{PU}}$**: In the intended operational band of wavenumbers, the filters should ideally sum to one, i.e., $F_c(\\mathbf{k}) + F_f(\\mathbf{k}) = 1$, to ensure that all spectral content is captured exactly once. We assess the maximum deviation from this ideal within the band defined by $\\lVert \\mathbf{k} \\rVert \\le k_f - \\delta_f$.\n    $$\n    E_{\\text{PU}} = \\max_{\\mathbf{k}, \\lVert \\mathbf{k} \\rVert \\le k_f - \\delta_f, \\mathbf{k} \\ne \\mathbf{0}} \\left| F_c(\\mathbf{k}) + F_f(\\mathbf{k}) - 1 \\right|\n    $$\n    By construction, inside this band, the term $W((\\lVert \\mathbf{k} \\rVert - k_f)/\\delta_f)$ is exactly $1$, which makes $F_f(\\mathbf{k}) = 1 - F_c(\\mathbf{k})$. Thus, $F_c(\\mathbf{k})+F_f(\\mathbf{k})=1$ analytically, and $E_{\\text{PU}}$ should be zero up to floating-point precision.\n\n3.  **Force Stability Ratio, $R$**: The force on a particle is related to the gradient of the potential, which in reciprocal space corresponds to multiplication by $i\\mathbf{k}$. The magnitude of the force contribution from mode $\\mathbf{k}$ scales with $\\lVert \\mathbf{k} \\rVert T(\\mathbf{k})$. A stable numerical scheme should not excessively amplify high-frequency modes compared to the baseline damped interaction $G(\\mathbf{k})$. The ratio $R$ compares the maximum force amplitude of the PME scheme to that of the pure damped interaction.\n    $$\n    R = \\dfrac{\\max_{\\mathbf{k} \\ne \\mathbf{0}} \\left(\\lVert \\mathbf{k} \\rVert \\, T(\\mathbf{k})\\right)}{\\max_{\\mathbf{k} \\ne \\mathbf{0}} \\left(\\lVert \\mathbf{k} \\rVert \\, G(\\mathbf{k})\\right)}\n    $$\n    A value of $R$ close to $1$ is desirable.\n\nThe following program implements these calculations for the three specified test cases, constructing the reciprocal lattice and all intermediate functions as multi-dimensional arrays for efficient computation.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the PME two-grid spectral splitting problem for the given test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (alpha, Nc, Nf, mc, mf, gamma_c, eta_c, gamma_f, eta_f)\n        (3.5, 16, 64, 4, 6, 0.30, 0.05, 0.85, 0.05), # Case 1\n        (3.5, 16, 64, 4, 6, 0.30, 0.20, 0.85, 0.05), # Case 2\n        (3.0, 8, 64, 3, 6, 0.15, 0.05, 0.90, 0.05),  # Case 3\n    ]\n\n    results = []\n\n    def my_sinc(x):\n        \"\"\"Custom sinc(x) = sin(x)/x, as defined in the problem.\"\"\"\n        x = np.asanyarray(x)\n        y = np.ones_like(x, dtype=float)\n        # Numerically stable for x -> 0, where sinc(x) -> 1\n        nonzero_mask = x != 0\n        y[nonzero_mask] = np.sin(x[nonzero_mask]) / x[nonzero_mask]\n        return y\n\n    def raised_cosine_window(x):\n        \"\"\"Raised-cosine window function W(x).\"\"\"\n        x = np.asanyarray(x)\n        y = np.zeros_like(x, dtype=float)\n        \n        cond1 = x = -1\n        cond3 = x >= 1\n        cond2 = ~cond1  ~cond3 # -1  x  1\n        \n        y[cond1] = 1.0\n        y[cond2] = 0.5 * (1.0 + np.cos(np.pi * x[cond2]))\n        # y[cond3] is already 0.0\n        \n        return y\n\n    for case in test_cases:\n        alpha, N_c, N_f, m_c, m_f, gamma_c, eta_c, gamma_f, eta_f = case\n        \n        L = 1.0\n        \n        # Grid spacings\n        delta_xc = L / N_c\n        delta_xf = L / N_f\n        \n        # Reciprocal space parameters\n        k_ny_f = np.pi * N_f / L\n        k_c = gamma_c * k_ny_f\n        delta_c = eta_c * k_ny_f\n        k_f = gamma_f * k_ny_f\n        delta_f = eta_f * k_ny_f\n        \n        # Create reciprocal lattice\n        n_range = np.arange(-np.floor(N_f / 2), np.floor(N_f / 2) + 1)\n        nx, ny, nz = np.meshgrid(n_range, n_range, n_range, indexing='ij')\n        \n        kx = 2.0 * np.pi * nx / L\n        ky = 2.0 * np.pi * ny / L\n        kz = 2.0 * np.pi * nz / L\n        \n        k_norm = np.sqrt(kx**2 + ky**2 + kz**2)\n        k_norm_sq = k_norm**2\n        \n        # Mask for k=0 mode\n        k_is_not_zero = k_norm != 0\n        \n        # --- Component Functions ---\n        \n        # Green's function G(k)\n        G_k = np.zeros_like(k_norm)\n        G_k[k_is_not_zero] = (4.0 * np.pi / k_norm_sq[k_is_not_zero]) * \\\n                           np.exp(-k_norm_sq[k_is_not_zero] / (4.0 * alpha**2))\n        \n        # Filters Fc(k) and Ff(k)\n        arg_c = np.zeros_like(k_norm)\n        arg_c[delta_c != 0] = (k_norm[delta_c != 0] - k_c) / delta_c\n        F_c = raised_cosine_window(arg_c)\n        \n        arg_f = np.zeros_like(k_norm)\n        arg_f[delta_f != 0] = (k_norm[delta_f != 0] - k_f) / delta_f\n        F_f = (1.0 - F_c) * raised_cosine_window(arg_f)\n        \n        # Spline attenuation factors Sc(k) and Sf(k)\n        Sc_kx = my_sinc(kx * delta_xc / 2.0)**m_c\n        Sc_ky = my_sinc(ky * delta_xc / 2.0)**m_c\n        Sc_kz = my_sinc(kz * delta_xc / 2.0)**m_c\n        S_c = Sc_kx * Sc_ky * Sc_kz\n        \n        Sf_kx = my_sinc(kx * delta_xf / 2.0)**m_f\n        Sf_ky = my_sinc(ky * delta_xf / 2.0)**m_f\n        Sf_kz = my_sinc(kz * delta_xf / 2.0)**m_f\n        S_f = Sf_kx * Sf_ky * Sf_kz\n        \n        # --- Metrics Calculation ---\n        \n        # 1. Minimal overlap O\n        overlap = np.mean(F_c**2 * F_f**2)\n        results.append(overlap)\n        \n        # 2. Partition-of-unity deviation E_PU\n        pu_mask = (k_norm = (k_f - delta_f))  k_is_not_zero\n        if np.any(pu_mask):\n            pu_dev = np.max(np.abs(F_c[pu_mask] + F_f[pu_mask] - 1.0))\n        else:\n            pu_dev = 0.0 # No points in the evaluation domain\n        results.append(pu_dev)\n        \n        # 3. Force stability ratio R\n        T_k = G_k * (F_c * S_c + F_f * S_f)\n        \n        force_T = k_norm * T_k\n        force_G = k_norm * G_k\n        \n        max_force_T = np.max(force_T[k_is_not_zero])\n        max_force_G = np.max(force_G[k_is_not_zero])\n        \n        force_ratio = max_force_T / max_force_G if max_force_G != 0 else 0.0\n        results.append(force_ratio)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3473525"}, {"introduction": "An algorithm's theoretical elegance is only useful if it performs well in practice, and predicting this performance is a cornerstone of computational science. This final practice moves from algorithmic mechanics to performance engineering, a vital skill for conducting large-scale simulations. You will build and calibrate a parametric performance model for PME on a parallel computer, learning to connect the algorithm's scaling behavior to real-world execution time and forecast the resources needed for massive calculations [@problem_id:3473535].", "problem": "You are tasked with deriving, implementing, and calibrating a parametric performance model for the Particle Mesh Ewald (PME) method using a three-dimensional Fast Fourier Transform (FFT) with pencil decomposition over a distributed-memory parallel machine. The goal is to start from first principles about algorithmic work and communication in the PME pipeline and construct a model with three basis terms representing short-range particle operations, grid-space computations, and inter-rank communication due to global transposes. You must then estimate the unknown scalar coefficients using provided microbenchmark measurements and use the calibrated model to predict execution times for new parameter sets.\n\nAssume the following scientifically grounded base for Particle Mesh Ewald (PME):\n\n- Short-range and charge-assignment operations scale linearly with the number of particles, written as $N$, driven by constant work per particle under fixed cutoff and interpolation order. This motivates a basis term proportional to $N$.\n- The three-dimensional Fast Fourier Transform (FFT) on a cubic grid of linear size $m$ performs approximately $\\mathcal{O}(m^3 \\log m)$ arithmetic operations, motivating a basis term proportional to $m^3 \\log m$, where $\\log$ denotes the natural logarithm.\n- Under pencil decomposition across $P$ processes (Message Passing Interface (MPI) ranks), two global transposes are required. The number of partners per transpose grows like $\\sqrt{P}$, and the total data per rank exchanged scales like $m^3/P$. Motivated by this, define a dimensionless normalized communication function\n$$\n\\mathrm{comm}(P,m) =\n\\begin{cases}\n0,  P = 1, \\\\\n2\\left(\\sqrt{P}-1 + \\dfrac{m^3}{P}\\right),  P > 1,\n\\end{cases}\n$$\nwhich bundles latency-like and bandwidth-like contributions into a single unitless quantity that captures the dominant scaling in $P$ and $m$. This term serves as a communication basis to be converted to seconds via an unknown scalar.\n\nYour task is to:\n1. From the above foundations, express the total PME time as a linear combination of three basis terms corresponding to $N$, $m^3 \\log m$, and $\\mathrm{comm}(P,m)$, with three unknown scalar coefficients that must be determined from data.\n2. Fit these coefficients using the provided microbenchmark measurements and a linear least squares method.\n3. Predict execution times for a given test suite of $(N,m,P)$ values using the fitted model.\n\nAll times must be expressed in seconds. Angles are not involved in this problem.\n\nYou are provided microbenchmark measurements consisting of tuples $(N,m,P,T_{\\mathrm{meas}})$, where $T_{\\mathrm{meas}}$ is the measured total wall-clock time in seconds:\n- $(200000, 64, 1, 0.114523)$\n- $(200000, 96, 1, 0.409523)$\n- $(500000, 64, 1, 0.122000)$\n- $(1000000, 128, 1, 1.044748)$\n- $(200000, 64, 16, 0.154130)$\n- $(500000, 96, 16, 0.550020)$\n- $(1000000, 128, 16, 1.358830)$\n- $(200000, 128, 64, 1.103410)$\n- $(1000000, 64, 64, 0.144448)$\n- $(500000, 128, 4, 2.291540)$\n- $(0, 96, 16, 0.537020)$\n- $(800000, 96, 4, 0.955767)$\n\nCalibrate the model coefficients using these measurements and then produce predictions for the following test suite of parameter values $(N,m,P)$:\n- $(700000, 96, 16)$\n- $(1000000, 128, 64)$\n- $(200000, 64, 1)$\n- $(500000, 128, 4)$\n- $(1000000, 64, 64)$\n\nYour program should produce a single line of output containing the predicted times for the above five test cases, as a comma-separated list enclosed in square brackets, with each number rounded to six decimal places, for example, $[t_1,t_2,t_3,t_4,t_5]$ where each $t_i$ is in seconds.\n\nClarifications and constraints:\n- Use the natural logarithm for $\\log$.\n- Treat $N$ and $m$ as positive integers, and $P$ as a positive integer representing the number of parallel ranks.\n- The communication basis $\\mathrm{comm}(P,m)$ is dimensionless by construction and must be converted to seconds via the fitted scalar coefficient.\n- The fit must be performed via linear least squares using the input microbenchmark measurements.\n- The runtime predictions for the test suite must be in seconds and rounded to six decimal places.", "solution": "The problem requires the construction and calibration of a parametric performance model for the Particle Mesh Ewald (PME) method. The total execution time, $T$, is to be modeled as a linear combination of three basis functions representing distinct computational kernels: particle-based work, grid-based work, and inter-process communication.\n\nThe model is given by the following linear equation:\n$$\nT_{\\text{pred}}(N, m, P) = c_N f_N(N) + c_m f_m(m) + c_P f_P(P, m)\n$$\nwhere $N$ is the number of particles, $m$ is the linear size of the FFT grid, and $P$ is the number of parallel processes. The coefficients $c_N$, $c_m$, and $c_P$ are unknown scalar constants that represent the time cost per unit of work for each respective basis function.\n\nBased on the problem statement, the basis functions are defined as:\n$1$. **Particle term**: The work for short-range interactions and charge assignment scales linearly with the number of particles, $N$. Thus, the first basis function is $f_N(N) = N$.\n$2$. **Grid term**: The work for the $3$D Fast Fourier Transform (FFT) on an $m \\times m \\times m$ grid is proportional to $m^3 \\log m$. Thus, the second basis function is $f_m(m) = m^3 \\log m$, where $\\log$ is the natural logarithm.\n$3$. **Communication term**: The communication overhead for the parallel FFT is modeled by the provided dimensionless function, $\\mathrm{comm}(P, m)$. Thus, the third basis function is $f_P(P, m) = \\mathrm{comm}(P, m)$, defined as:\n$$\n\\mathrm{comm}(P,m) =\n\\begin{cases}\n0,  \\text{if } P = 1, \\\\\n2\\left(\\sqrt{P}-1 + \\dfrac{m^3}{P}\\right),  \\text{if } P > 1.\n\\end{cases}\n$$\n\nThe full performance model is therefore:\n$$\nT_{\\text{pred}}(N, m, P) = c_N N + c_m (m^3 \\log m) + c_P \\mathrm{comm}(P, m)\n$$\nOur goal is to determine the coefficients $c_N$, $c_m$, and $c_P$ using a set of experimental measurements. We are given $k=12$ microbenchmark measurements, each a tuple $(N_i, m_i, P_i, T_{\\text{meas},i})$ for $i=1, \\dots, 12$. For each measurement, we can write an instance of the model equation:\n$$\nT_{\\text{meas},i} \\approx c_N N_i + c_m (m_i^3 \\log m_i) + c_P \\mathrm{comm}(P_i, m_i)\n$$\nThis forms a system of linear equations, which can be expressed in matrix form as $\\mathbf{y} \\approx \\mathbf{A}\\mathbf{c}$, where:\n- $\\mathbf{y}$ is a $12 \\times 1$ column vector of the measured times $T_{\\text{meas},i}$.\n- $\\mathbf{c}$ is the $3 \\times 1$ column vector of unknown coefficients we seek to find: $\\mathbf{c} = [c_N, c_m, c_P]^T$.\n- $\\mathbf{A}$ is the $12 \\times 3$ design matrix, where each row $i$ consists of the values of the basis functions for the $i$-th measurement:\n$$\n\\mathbf{A}_{i,:} = \\begin{bmatrix} N_i  m_i^3 \\log m_i  \\mathrm{comm}(P_i, m_i) \\end{bmatrix}\n$$\nSince we have more measurements ($12$) than unknown coefficients ($3$), the system is overdetermined. The best-fit solution for $\\mathbf{c}$ is found by minimizing the sum of the squares of the residuals, $r_i = T_{\\text{meas},i} - T_{\\text{pred},i}$. This is a standard linear least squares problem. The solution $\\mathbf{c}$ that minimizes the Euclidean norm of the residual vector, $\\|\\mathbf{y} - \\mathbf{A}\\mathbf{c}\\|_2$, is given by the solution to the normal equations:\n$$\n\\mathbf{A}^T \\mathbf{A} \\mathbf{c} = \\mathbf{A}^T \\mathbf{y}\n$$\nAssuming $\\mathbf{A}^T \\mathbf{A}$ is invertible, the solution is $\\mathbf{c} = (\\mathbf{A}^T \\mathbf{A})^{-1} \\mathbf{A}^T \\mathbf{y}$. Computationally, this is solved efficiently and robustly using methods like QR decomposition, as implemented in libraries such as NumPy.\n\nThe procedure is as follows:\n$1$. Construct the $12 \\times 3$ design matrix $\\mathbf{A}$ and the $12 \\times 1$ vector of measurements $\\mathbf{y}$ from the provided microbenchmark data.\n$2$. Solve the linear least squares system $\\mathbf{A}\\mathbf{c} \\approx \\mathbf{y}$ for the coefficient vector $\\mathbf{c} = [c_N, c_m, c_P]^T$.\n$3$. With the calibrated coefficients, the performance model is fully specified.\n$4$. For each of the $5$ parameter sets in the test suite, $(N_j, m_j, P_j)$, calculate a prediction vector $\\mathbf{a}_j = [N_j, m_j^3 \\log m_j, \\mathrm{comm}(P_j, m_j)]$.\n$5$. The predicted time is the dot product $T_{\\text{pred}, j} = \\mathbf{a}_j \\cdot \\mathbf{c}$. These predictions are then collected and formatted as the final result.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives, calibrates, and applies a parametric performance model for PME.\n    \n    The model is T_pred = c_N*N + c_m*(m^3*log(m)) + c_P*comm(P,m).\n    The coefficients [c_N, c_m, c_P] are found by a linear least squares fit\n    to the provided microbenchmark data. The calibrated model is then used to\n    predict execution times for a new set of test cases.\n    \"\"\"\n    \n    # Define the custom communication basis function.\n    def comm_func(P, m):\n        \"\"\"\n        Calculates the dimensionless communication cost.\n        \"\"\"\n        if P == 1:\n            return 0.0\n        # The problem statement defines P as a positive integer.\n        # So P > 1 is the only other case.\n        return 2.0 * (np.sqrt(P) - 1.0 + float(m**3) / P)\n\n    # Microbenchmark measurements: (N, m, P, T_meas)\n    benchmarks = [\n        (200000, 64, 1, 0.114523),\n        (200000, 96, 1, 0.409523),\n        (500000, 64, 1, 0.122000),\n        (1000000, 128, 1, 1.044748),\n        (200000, 64, 16, 0.154130),\n        (500000, 96, 16, 0.550020),\n        (1000000, 128, 16, 1.358830),\n        (200000, 128, 64, 1.103410),\n        (1000000, 64, 64, 0.144448),\n        (500000, 128, 4, 2.291540),\n        (0, 96, 16, 0.537020),\n        (800000, 96, 4, 0.955767),\n    ]\n\n    num_benchmarks = len(benchmarks)\n    # The model has 3 basis functions, so the design matrix has 3 columns.\n    num_coeffs = 3\n    \n    # A is the design matrix, y is the vector of measured times.\n    A = np.zeros((num_benchmarks, num_coeffs))\n    y = np.zeros(num_benchmarks)\n\n    for i, (N, m, P, T_meas) in enumerate(benchmarks):\n        # Basis function 1: N\n        f_N = float(N)\n        # Basis function 2: m^3 * log(m)\n        f_m = float(m**3) * np.log(m) if m > 0 else 0.0\n        # Basis function 3: comm(P, m)\n        f_P = comm_func(P, m)\n        \n        A[i, :] = [f_N, f_m, f_P]\n        y[i] = T_meas\n\n    # Solve the linear least squares problem A*c = y for coefficients c.\n    coeffs, residuals, rank, s = np.linalg.lstsq(A, y, rcond=None)\n    c_N, c_m, c_P = coeffs\n\n    # Test suite for predictions: (N, m, P)\n    test_cases = [\n        (700000, 96, 16),\n        (1000000, 128, 64),\n        (200000, 64, 1),\n        (500000, 128, 4),\n        (1000000, 64, 64),\n    ]\n\n    predictions = []\n    for N_test, m_test, P_test in test_cases:\n        # Construct the feature vector for the test case.\n        f_N_test = float(N_test)\n        f_m_test = float(m_test**3) * np.log(m_test) if m_test > 0 else 0.0\n        f_P_test = comm_func(P_test, m_test)\n        \n        feature_vector = np.array([f_N_test, f_m_test, f_P_test])\n        \n        # Predict the time using the calibrated model.\n        T_pred = np.dot(feature_vector, coeffs)\n        predictions.append(T_pred)\n\n    # Format the final output string as specified.\n    # Each number must be rounded to six decimal places.\n    # Using \"{:.6f}\".format() handles this requirement correctly.\n    formatted_results = [f\"{t:.6f}\" for t in predictions]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3473535"}]}