{"hands_on_practices": [{"introduction": "In practical molecular dynamics simulations, constraints are often applied, such as removing the system's overall center-of-mass motion to prevent drift. This practice explores the crucial consequences of such constraints, which reduce the number of independent degrees of freedom, $g$, available to the system. You will derive how this modification affects both the instantaneous temperature estimator and the parameterization of a dynamic thermostat like Nosé–Hoover, ensuring the thermostat's response frequency remains consistent [@problem_id:3496428].", "problem": "A three-dimensional Molecular Dynamics (MD) simulation of $N$ identical atoms is performed in a periodic cell at target temperature $T_{0}$. The instantaneous kinetic energy is defined by $K = \\sum_{i=1}^{N} \\frac{1}{2} m v_{i}^{2}$, and temperature is estimated from kinetic energy via the equipartition principle. The simulation removes the net Center-of-Mass (COM) motion by subtracting the instantaneous COM velocity from all atomic velocities at each time step. Assume there are no other holonomic constraints.\n\nStarting from first principles and core definitions only, perform the following:\n\n1. Derive how the removal of the COM motion modifies the temperature estimator based on kinetic energy, explicitly showing the resulting degrees of freedom and the estimator’s dependence on them. Demonstrate, for fixed instantaneous kinetic energy $K$, the factor by which the estimator changes when three translational degrees of freedom are removed.\n\n2. Consider a single-variable Nosé–Hoover (NH) thermostat. The NH friction variable $\\xi$ with mass parameter $Q$ couples to the momenta through the extended equations of motion. Linearize the coupled kinetic energy–thermostat dynamics about equilibrium and derive the small-amplitude relaxation frequency $\\omega$ of kinetic energy fluctuations in terms of $g$, $k_{B}$, $T_{0}$, and $Q$, where $g$ is the number of active quadratic degrees of freedom. Using this relation, determine how $Q$ must be adjusted when $g$ is reduced by removal of COM motion in order to preserve the same relaxation timescale. Express the adjusted $Q$ symbolically in terms of the reduced degrees of freedom, $k_{B}$, $T_{0}$, and a chosen timescale parameter.\n\n3. Apply your result to a system with $N = 1000$ atoms at $T_{0} = 300\\,\\mathrm{K}$, with COM motion removed, and choose a target small-amplitude relaxation timescale $\\tau = 0.5\\,\\mathrm{ps}$ to be preserved before and after COM removal. Compute the adjusted Nosé–Hoover mass parameter $Q'$ that achieves the same $\\tau$ after COM removal. Express the final value of $Q'$ in $\\mathrm{J\\,ps^{2}}$ and round your answer to four significant figures.\n\nIn your reasoning you may reference Newton’s laws, the definition of kinetic energy, and the equipartition theorem. You must not assume any thermostat-specific shortcut formulas without deriving them from these bases. The final answer should be the single numerical value of $Q'$ in $\\mathrm{J\\,ps^{2}}$, rounded to four significant figures.", "solution": "The problem is validated as scientifically grounded, well-posed, and objective. It consists of standard derivations and applications in computational statistical mechanics.\n\nThe solution is presented in three parts as requested by the problem statement.\n\nPart 1: Derivation of the modified temperature estimator.\n\nThe equipartition theorem states that for a system in thermal equilibrium at temperature $T_{0}$, the average energy associated with each independent quadratic degree of freedom in the Hamiltonian is $\\frac{1}{2} k_{B} T_{0}$, where $k_{B}$ is the Boltzmann constant. In a Molecular Dynamics (MD) simulation, the instantaneous temperature $T$ is estimated by extending this principle to the instantaneous kinetic energy $K$. If the system possesses $g$ kinetic degrees of freedom, the instantaneous temperature $T$ is defined by the relation:\n$$K = \\frac{g}{2} k_{B} T$$\nFrom this, the temperature estimator is:\n$$T = \\frac{2K}{g k_{B}}$$\nFor a system of $N$ point-like atoms moving in $3$-dimensional space, each atom has $3$ translational degrees of freedom corresponding to its velocity components $(v_{ix}, v_{iy}, v_{iz})$. The total number of such degrees of freedom is $g = 3N$. The total kinetic energy is $K = \\sum_{i=1}^{N} \\frac{1}{2} m v_{i}^{2}$. The standard temperature estimator is thus:\n$$T = \\frac{2K}{3N k_{B}}$$\nWhen the net Center-of-Mass (COM) motion is removed, a constraint is imposed on the system's velocities. The COM velocity is defined as $\\mathbf{V}_{\\text{COM}} = \\frac{\\sum_{i=1}^{N} m \\mathbf{v}_{i}}{\\sum_{i=1}^{N} m} = \\frac{1}{N} \\sum_{i=1}^{N} \\mathbf{v}_{i}$. Removing COM motion means enforcing $\\mathbf{V}_{\\text{COM}} = \\mathbf{0}$ at all times. This introduces three linear constraints on the velocities of the atoms:\n$$\\sum_{i=1}^{N} v_{ix} = 0, \\quad \\sum_{i=1}^{N} v_{iy} = 0, \\quad \\sum_{i=1}^{N} v_{iz} = 0$$\nThese constraints reduce the number of independent velocity components. The original $3N$ degrees of freedom are reduced by $3$. The new number of active degrees of freedom, denoted $g'$, is:\n$$g' = 3N - 3$$\nThe kinetic energy $K$ of the system is now computed from velocities that satisfy these constraints. The temperature estimator must be adjusted to reflect the change in the number of degrees of freedom. The new estimator, $T'$, is:\n$$T' = \\frac{2K}{g' k_{B}} = \\frac{2K}{(3N-3)k_{B}}$$\nTo find the factor by which the estimator changes for a fixed value of instantaneous kinetic energy $K$, we compute the ratio of the new estimator $T'$ to the old one $T$:\n$$\\frac{T'}{T} = \\frac{\\frac{2K}{(3N-3)k_{B}}}{\\frac{2K}{3N k_{B}}} = \\frac{3N}{3N-3} = \\frac{3N}{3(N-1)} = \\frac{N}{N-1}$$\nThus, for a given kinetic energy $K$, removing the COM motion increases the estimated temperature by a factor of $\\frac{N}{N-1}$.\n\nPart 2: Nosé–Hoover dynamics and thermostat parameter adjustment.\n\nThe Nosé–Hoover (NH) thermostat couples the physical system to a thermal reservoir through an extended phase-space variable, the friction coefficient $\\xi$. The equations of motion for the atomic momenta $\\mathbf{p}_{i}$ and the thermostat variable $\\xi$ are:\n$$\\dot{\\mathbf{p}}_{i} = \\mathbf{F}_{i} - \\xi \\mathbf{p}_{i}$$\n$$\\dot{\\xi} = \\frac{1}{Q} \\left( \\sum_{i=1}^{N} \\frac{p_{i}^{2}}{m} - g k_{B} T_{0} \\right) = \\frac{1}{Q} (2K - g k_{B} T_{0})$$\nHere, $Q$ is the \"mass\" parameter of the thermostat, which determines the timescale of temperature fluctuations, and $g$ is the number of active degrees of freedom.\n\nTo analyze the dynamics of kinetic energy fluctuations, we first derive the equation of motion for $K = \\sum_{i=1}^{N} \\frac{p_{i}^{2}}{2m}$:\n$$\\dot{K} = \\frac{d}{dt} \\sum_{i=1}^{N} \\frac{\\mathbf{p}_{i} \\cdot \\mathbf{p}_{i}}{2m} = \\sum_{i=1}^{N} \\frac{\\mathbf{p}_{i} \\cdot \\dot{\\mathbf{p}}_{i}}{m} = \\sum_{i=1}^{N} \\frac{\\mathbf{p}_{i} \\cdot (\\mathbf{F}_{i} - \\xi \\mathbf{p}_{i})}{m}$$\n$$\\dot{K} = \\sum_{i=1}^{N} \\mathbf{v}_{i} \\cdot \\mathbf{F}_{i} - \\xi \\sum_{i=1}^{N} \\frac{p_{i}^{2}}{m} = \\sum_{i=1}^{N} \\mathbf{v}_{i} \\cdot \\mathbf{F}_{i} - 2\\xi K$$\nWe define a fluctuating term $\\Gamma(t) = \\sum_{i=1}^{N} \\mathbf{v}_{i} \\cdot \\mathbf{F}_{i}$, representing energy exchange with the potential energy landscape. The coupled dynamics of $K$ and $\\xi$ are:\n$$ \\begin{cases} \\dot{K} = \\Gamma(t) - 2\\xi K \\\\ \\dot{\\xi} = \\frac{1}{Q} (2K - g k_{B} T_{0}) \\end{cases} $$\nWe linearize these equations around the equilibrium state, which is characterized by $\\langle \\xi \\rangle = 0$ and $\\langle K \\rangle = K_{0} = \\frac{g}{2} k_{B} T_{0}$. We introduce small deviations $\\delta K = K - K_{0}$ and $\\delta \\xi = \\xi - 0$. The linearized equations become:\n$$ \\begin{cases} \\delta\\dot{K} \\approx \\Gamma(t) - 2 K_{0} \\delta\\xi \\\\ \\delta\\dot{\\xi} \\approx \\frac{1}{Q} (2(K_{0}+\\delta K) - g k_{B} T_{0}) = \\frac{2 \\delta K}{Q} \\end{cases} $$\nDifferentiating the first equation with respect to time and substituting the second gives an equation for $\\delta K$:\n$$\\delta\\ddot{K} \\approx \\dot{\\Gamma}(t) - 2K_{0}\\delta\\dot{\\xi} = \\dot{\\Gamma}(t) - 2K_{0} \\left( \\frac{2\\delta K}{Q} \\right)$$\n$$\\delta\\ddot{K} + \\left( \\frac{4K_{0}}{Q} \\right) \\delta K = \\dot{\\Gamma}(t)$$\nThis is the equation of a driven harmonic oscillator. The natural frequency of small-amplitude kinetic energy fluctuations, $\\omega$, is given by:\n$$\\omega^{2} = \\frac{4K_{0}}{Q} = \\frac{4}{Q} \\left( \\frac{g}{2} k_{B} T_{0} \\right) = \\frac{2g k_{B} T_{0}}{Q}$$\nSo, the relaxation frequency is $\\omega = \\sqrt{\\frac{2g k_{B} T_{0}}{Q}}$. The relaxation timescale is $\\tau = \\frac{2\\pi}{\\omega}$.\nTo preserve the same relaxation timescale $\\tau$ (and thus the same frequency $\\omega$) when the number of degrees of freedom changes from $g$ to $g'$, the ratio $\\frac{g}{Q}$ must remain constant:\n$$\\frac{g}{Q} = \\frac{g'}{Q'} \\implies Q' = Q \\frac{g'}{g}$$\nThis shows that the thermostat mass $Q$ must be scaled proportionally to the number of degrees of freedom to maintain a constant response frequency.\nTo express the adjusted mass $Q'$ in terms of the desired timescale $\\tau$, we rearrange the frequency equation:\n$$Q' = \\frac{2g' k_{B} T_{0}}{\\omega^{2}}$$\nSubstituting $\\omega = \\frac{2\\pi}{\\tau}$, we obtain:\n$$Q' = \\frac{2g' k_{B} T_{0}}{(2\\pi/\\tau)^{2}} = \\frac{g' k_{B} T_{0} \\tau^{2}}{2\\pi^{2}}$$\nThis provides the symbolic expression for the adjusted mass parameter $Q'$ that achieves the target timescale $\\tau$ for a system with $g'$ degrees of freedom.\n\nPart 3: Numerical calculation of the adjusted thermostat mass $Q'$.\n\nThe problem specifies a system with $N = 1000$ atoms at a target temperature of $T_{0} = 300\\,\\mathrm{K}$. The COM motion is removed. The desired relaxation timescale is $\\tau = 0.5\\,\\mathrm{ps}$.\n\nFirst, we calculate the number of active degrees of freedom, $g'$:\n$$g' = 3N - 3 = 3(1000) - 3 = 2997$$\nNext, we use the derived formula for $Q'$ with the given parameters and constants:\n$$Q' = \\frac{g' k_{B} T_{0} \\tau^{2}}{2\\pi^{2}}$$\nThe physical constants are:\n$k_{B} = 1.380649 \\times 10^{-23}\\,\\mathrm{J/K}$\nThe parameters are:\n$g' = 2997$\n$T_{0} = 300\\,\\mathrm{K}$\n$\\tau = 0.5\\,\\mathrm{ps}$\n\nWe now substitute these values into the expression for $Q'$. The units must be handled correctly to yield the final answer in $\\mathrm{J\\,ps^{2}}$.\n$$Q' = \\frac{(2997) \\times (1.380649 \\times 10^{-23}\\,\\mathrm{J/K}) \\times (300\\,\\mathrm{K}) \\times (0.5\\,\\mathrm{ps})^{2}}{2\\pi^{2}}$$\n$$Q' = \\frac{2997 \\times (1.380649 \\times 10^{-23}) \\times 300 \\times 0.25}{2\\pi^{2}} \\,\\mathrm{J\\,ps^{2}}$$\nThe term $k_{B} T_{0}$ is $(1.380649 \\times 10^{-23}\\,\\mathrm{J/K}) \\times (300\\,\\mathrm{K}) = 4.141947 \\times 10^{-21}\\,\\mathrm{J}$.\nThe numerator becomes:\n$$ \\text{Numerator} = 2997 \\times (4.141947 \\times 10^{-21}\\,\\mathrm{J}) \\times (0.25\\,\\mathrm{ps}^{2}) \\approx 3.1032178 \\times 10^{-18}\\,\\mathrm{J\\,ps^{2}} $$\nThe denominator is:\n$$ \\text{Denominator} = 2\\pi^{2} \\approx 19.7392088 $$\nPerforming the division:\n$$ Q' \\approx \\frac{3.1032178 \\times 10^{-18}}{19.7392088} \\,\\mathrm{J\\,ps^{2}} \\approx 1.572101 \\times 10^{-19}\\,\\mathrm{J\\,ps^{2}} $$\nRounding the result to four significant figures as requested:\n$$ Q' \\approx 1.572 \\times 10^{-19}\\,\\mathrm{J\\,ps^{2}} $$\nThis is the adjusted Nosé–Hoover mass parameter required to achieve the desired relaxation timescale.", "answer": "$$\\boxed{1.572 \\times 10^{-19}}$$", "id": "3496428"}, {"introduction": "The accuracy of a simulation depends not only on the physical models but also on their numerical implementation. This exercise delves into the subtle yet significant discretization biases that arise from coupling a thermostat with a symplectic integrator [@problem_id:3496490]. By implementing and comparing different operator-splitting schemes for the Berendsen thermostat, you will directly measure and quantify how the choice of algorithm affects the sampled temperature, highlighting a critical aspect of simulation fidelity.", "problem": "You are asked to quantify the discretization-induced bias in the sampled kinetic temperature generated by deterministic velocity rescaling of the Berendsen thermostat when it is combined with a symplectic integrator. Work in a setting where the configuration space is a direct product of independent one-dimensional harmonic oscillators, so that the system dynamics are governed by Newton's second law, $m \\, d^2 x_i / dt^2 = - k \\, x_i$, with $i = 1, \\dots, N$. Use the following fundamental definitions and models as the base of your derivation and implementation:\n\n- Dynamics: For each degree of freedom $i$, the equations of motion are $m \\, \\dot{v}_i = - k \\, x_i$ and $\\dot{x}_i = v_i$. The symplectic time discretization to be used for the Hamiltonian part is the standard velocity Verlet method.\n- Kinetic temperature: For $N$ degrees of freedom, the instantaneous kinetic temperature is $T(t) = \\frac{2K(t)}{k_B N}$, where $K(t) = \\sum_{i=1}^N \\frac{1}{2} m v_i(t)^2$ is the instantaneous kinetic energy and $k_B$ is the Boltzmann constant.\n- Berendsen thermostat model: The Berendsen thermostat enforces exponential relaxation of the kinetic energy via the continuous model $\\frac{dK}{dt} = \\frac{K_0 - K}{\\tau}$, where $K_0 = \\frac{1}{2} N k_B T_0$ is the target kinetic energy for target temperature $T_0$ and $\\tau$ is a thermostat relaxation time constant. Implement the deterministic velocity-rescaling step that is consistent, to first order in the time increment, with this relaxation model.\n\nYour task is to derive and implement three operator-splitting orders that interleave the Hamiltonian velocity Verlet step with the Berendsen rescaling step:\n\n- Order A ($\\mathrm{S\\text{-}VV}$): Apply a full thermostat rescaling step over the time increment $\\Delta t$ first, then apply one full velocity Verlet step.\n- Order B ($\\mathrm{VV\\text{-}S}$): Apply one full velocity Verlet step first, then apply a full thermostat rescaling step over the time increment $\\Delta t$.\n- Order C ($\\mathrm{S/2\\text{-}VV\\text{-}S/2}$): Apply a half thermostat rescaling step over $\\Delta t/2$, then a full velocity Verlet step, then a half thermostat rescaling step over $\\Delta t/2$.\n\nUse reduced units throughout with $m = 1$, $k = 1$, and $k_B = 1$, so that the natural angular frequency is $\\omega = \\sqrt{k/m} = 1$. The target temperature is $T_0 = 1$, the thermostat relaxation time is $\\tau = 2$, and the number of degrees of freedom is $N = 256$ (that is, $256$ independent oscillators). The initial conditions for each test case must be generated deterministically using a fixed pseudorandom seed so that results are reproducible: choose a seed of $2025$ for a normal distribution with mean $0$ and standard deviation $\\sqrt{T_0/k}$ for positions and $\\sqrt{T_0/m}$ for velocities.\n\nFor each simulation, proceed as follows:\n\n- Use $N_{\\mathrm{burn}} = 2000$ burn-in steps to remove transients.\n- Then run $N_{\\mathrm{meas}} = 10000$ additional steps while accumulating the running average of the instantaneous kinetic temperature $T_n = \\frac{1}{N}\\sum_{i=1}^N v_i(n\\Delta t)^2$ at each step $n$.\n- The discretization-induced bias for a given test case is the difference between the time-averaged sampled temperature and the target: $b = \\langle T \\rangle - T_0$.\n\nImplement the following three-step-size test suite to probe both small-step and near-stability regimes for $\\omega = 1$ (velocity Verlet is linearly stable for $\\Delta t  2/\\omega$):\n\n- $\\Delta t = 0.05$ with each of the three operator orders $\\mathrm{S\\text{-}VV}$, $\\mathrm{VV\\text{-}S}$, and $\\mathrm{S/2\\text{-}VV\\text{-}S/2}$.\n- $\\Delta t = 0.5$ with each of the three operator orders.\n- $\\Delta t = 1.5$ with each of the three operator orders.\n\nThe required final output is a single line containing the nine biases, one for each test case in the order listed above, rounded to six decimal places, reported in the reduced temperature unit defined by $k_B = 1$. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, \"[b1,b2,...,b9]\"), where each $b_j$ is a floating-point number formatted with six digits after the decimal point.\n\nNo empirical or literature formulas for the bias are allowed; your derivation must start from Newton's laws, the definition of kinetic temperature, the continuous Berendsen relaxation equation for $K(t)$, and the velocity Verlet integrator. You must specify clearly how the velocity rescaling factor is obtained from the Berendsen relaxation model and how it is incorporated in each operator order. All computations must use the reduced units described above, and all reported biases must be expressed in the same reduced temperature unit.", "solution": "The problem requires the calculation of the discretization-induced bias in the kinetic temperature sampled from a system of independent harmonic oscillators thermostatted by a Berendsen thermostat, integrated using different operator-splitting schemes.\n\nFirst, the physical system and numerical methods are defined based on the provided parameters and equations. The system consists of $N$ independent one-dimensional harmonic oscillators. The dynamics of each oscillator $i$ are governed by Newton's second law:\n$$m \\frac{d^2 x_i}{dt^2} = -k x_i$$\nThis corresponds to a set of first-order ordinary differential equations for position $x_i$ and velocity $v_i$:\n$$ \\dot{x}_i = v_i \\quad , \\quad \\dot{v}_i = -\\frac{k}{m} x_i $$\nThe problem specifies reduced units where mass $m=1$, spring constant $k=1$, and Boltzmann constant $k_B=1$. In these units, the natural angular frequency is $\\omega = \\sqrt{k/m} = 1$, and the equations of motion simplify to $\\dot{x}_i = v_i$ and $\\dot{v}_i = -x_i$.\n\nThe instantaneous kinetic temperature $T$ for the system of $N$ degrees of freedom is defined as $T = \\frac{2K}{k_B N}$, where $K = \\sum_{i=1}^N \\frac{1}{2} m v_i^2$ is the total kinetic energy. In the specified reduced units, this becomes:\n$$ T = \\frac{1}{N} \\sum_{i=1}^N v_i^2 $$\n\nThe numerical integration of the Hamiltonian part of the motion (i.e., Newton's laws without the thermostat) is performed using the standard velocity Verlet algorithm. For a time step $\\Delta t$, the position $\\mathbf{x}$ and velocity $\\mathbf{v}$ vectors (each of dimension $N$) are updated from step $n$ to $n+1$ as follows:\n1.  Compute the acceleration at step $n$: $\\mathbf{a}_n = -\\frac{k}{m} \\mathbf{x}_n = -\\mathbf{x}_n$.\n2.  Update velocities by a half step: $\\mathbf{v}_{n+1/2} = \\mathbf{v}_n + \\mathbf{a}_n \\frac{\\Delta t}{2}$.\n3.  Update positions by a full step: $\\mathbf{x}_{n+1} = \\mathbf{x}_n + \\mathbf{v}_{n+1/2} \\Delta t$.\n4.  Compute the acceleration at step $n+1$: $\\mathbf{a}_{n+1} = -\\frac{k}{m} \\mathbf{x}_{n+1} = -\\mathbf{x}_{n+1}$.\n5.  Update velocities by the final half step: $\\mathbf{v}_{n+1} = \\mathbf{v}_{n+1/2} + \\mathbf{a}_{n+1} \\frac{\\Delta t}{2}$.\n\nThe system is coupled to a Berendsen thermostat, which enforces an exponential relaxation of the kinetic energy $K$ towards a target value $K_0$ corresponding to a target temperature $T_0$. The continuous model is:\n$$ \\frac{dK}{dt} = \\frac{K_0 - K}{\\tau} $$\nwhere $\\tau$ is the thermostat relaxation time. In the discrete velocity-rescaling implementation, the velocities are scaled at each step by a factor $\\lambda$, such that $\\mathbf{v} \\rightarrow \\lambda \\mathbf{v}$. This implies the kinetic energy is scaled as $K \\rightarrow \\lambda^2 K$.\nTo find $\\lambda$, we discretize the continuous model using a forward Euler approximation over a time interval $\\delta t$:\n$$ K(t+\\delta t) \\approx K(t) + \\frac{\\delta t}{\\tau} (K_0 - K(t)) $$\nSetting the rescaled kinetic energy $\\lambda^2 K(t)$ equal to the target $K(t+\\delta t)$, we get:\n$$ \\lambda^2 K(t) = K(t) \\left[ 1 + \\frac{\\delta t}{\\tau} \\left(\\frac{K_0}{K(t)} - 1\\right) \\right] $$\nSolving for $\\lambda$ and using the relation $T/T_0 = K/K_0$ gives the scaling factor:\n$$ \\lambda = \\sqrt{1 + \\frac{\\delta t}{\\tau} \\left(\\frac{T_0}{T} - 1\\right)} $$\nwhere $T$ is the instantaneous temperature before rescaling.\n\nWe now define the three operator-splitting schemes for combining the velocity Verlet (VV) step over a time increment $\\Delta t$ and the Berendsen scaling (S) step. Let the state at step $n$ be $(\\mathbf{x}_n, \\mathbf{v}_n)$.\n\nOrder A ($\\mathrm{S\\text{-}VV}$):\n1.  Compute the instantaneous temperature $T_n = \\frac{1}{N} \\sum_i v_{i,n}^2$.\n2.  Compute the scaling factor for a full step $\\Delta t$: $\\lambda_A = \\sqrt{1 + \\frac{\\Delta t}{\\tau} \\left(\\frac{T_0}{T_n} - 1\\right)}$.\n3.  Apply the thermostat: $\\mathbf{v}'_n = \\lambda_A \\mathbf{v}_n$.\n4.  Apply a full velocity Verlet step using $(\\mathbf{x}_n, \\mathbf{v}'_n)$ as input to obtain $(\\mathbf{x}_{n+1}, \\mathbf{v}_{n+1})$.\n\nOrder B ($\\mathrm{VV\\text{-}S}$):\n1.  Apply a full velocity Verlet step using $(\\mathbf{x}_n, \\mathbf{v}_n)$ as input to obtain an intermediate state $(\\mathbf{x}_{n+1}, \\mathbf{v}^*_{n+1})$.\n2.  Compute the intermediate temperature $T^*_{n+1} = \\frac{1}{N} \\sum_i (v^*_{i,n+1})^2$.\n3.  Compute the scaling factor for a full step $\\Delta t$: $\\lambda_B = \\sqrt{1 + \\frac{\\Delta t}{\\tau} \\left(\\frac{T_0}{T^*_{n+1}} - 1\\right)}$.\n4.  Apply the thermostat: $\\mathbf{v}_{n+1} = \\lambda_B \\mathbf{v}^*_{n+1}$. The positions $\\mathbf{x}_{n+1}$ are unchanged.\n\nOrder C ($\\mathrm{S/2\\text{-}VV\\text{-}S/2}$): This is a symmetric Trotter-Strang splitting scheme.\n1.  First half-step scaling: Compute $T_n = \\frac{1}{N} \\sum_i v_{i,n}^2$, then the scaling factor $\\lambda_{C1} = \\sqrt{1 + \\frac{\\Delta t/2}{\\tau} \\left(\\frac{T_0}{T_n} - 1\\right)}$. Apply the scaling: $\\mathbf{v}'_n = \\lambda_{C1} \\mathbf{v}_n$.\n2.  Apply a full velocity Verlet step using $(\\mathbf{x}_n, \\mathbf{v}'_n)$ as input to obtain an intermediate state $(\\mathbf{x}_{n+1}, \\mathbf{v}^*_{n+1})$.\n3.  Second half-step scaling: Compute $T^*_{n+1} = \\frac{1}{N} \\sum_i (v^*_{i,n+1})^2$, then the scaling factor $\\lambda_{C2} = \\sqrt{1 + \\frac{\\Delta t/2}{\\tau} \\left(\\frac{T_0}{T^*_{n+1}} - 1\\right)}$. Apply the scaling: $\\mathbf{v}_{n+1} = \\lambda_{C2} \\mathbf{v}^*_{n+1}$. The positions $\\mathbf{x}_{n+1}$ are unchanged.\n\nThe numerical experiment is conducted as follows. Initial positions and velocities for the $N=256$ oscillators are drawn from normal distributions with mean $0$ and standard deviations $\\sigma_x = \\sqrt{T_0/k}=1$ and $\\sigma_v = \\sqrt{T_0/m}=1$, respectively, using a fixed random seed for reproducibility. For each test case (a combination of $\\Delta t \\in \\{0.05, 0.5, 1.5\\}$ and splitting order A, B, or C), the system is evolved starting from the same initial state. The simulation runs for $N_{\\mathrm{burn}} = 2000$ steps for thermal equilibration. Then, for the next $N_{\\mathrm{meas}} = 10000$ steps, the instantaneous temperature is calculated at each step and accumulated. The time-averaged temperature $\\langle T \\rangle$ is the mean of these $N_{\\mathrm{meas}}$ values. The final reported quantity is the bias, $b = \\langle T \\rangle - T_0$, where the target temperature $T_0=1$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(dt, order, N, T0, tau, N_burn, N_meas, x_initial, v_initial):\n    \"\"\"\n    Runs a single simulation for a given set of parameters.\n\n    Args:\n        dt (float): Time step.\n        order (str): Operator splitting order ('A', 'B', or 'C').\n        N (int): Number of degrees of freedom.\n        T0 (float): Target temperature.\n        tau (float): Berendsen thermostat relaxation time.\n        N_burn (int): Number of burn-in steps.\n        N_meas (int): Number of measurement steps.\n        x_initial (np.ndarray): Initial positions.\n        v_initial (np.ndarray): Initial velocities.\n\n    Returns:\n        float: The calculated temperature bias.\n    \"\"\"\n    x = x_initial.copy()\n    v = v_initial.copy()\n\n    # Reduced units: m=1, k=1\n    m = 1.0\n    k = 1.0\n\n    def step_A(x, v, dt, T0, tau, N):\n        # S-VV Order\n        # 1. Thermostat step (S)\n        inst_temp = (v @ v) / N\n        if inst_temp > 0:\n            scale_factor = np.sqrt(1.0 + (dt / tau) * (T0 / inst_temp - 1.0))\n            v = v * scale_factor\n\n        # 2. Velocity Verlet step (VV)\n        a = -k * x / m\n        v_half = v + a * (dt / 2.0)\n        x_new = x + v_half * dt\n        a_new = -k * x_new / m\n        v_new = v_half + a_new * (dt / 2.0)\n        return x_new, v_new\n\n    def step_B(x, v, dt, T0, tau, N):\n        # VV-S Order\n        # 1. Velocity Verlet step (VV)\n        a = -k * x / m\n        v_half = v + a * (dt / 2.0)\n        x_new = x + v_half * dt\n        a_new = -k * x_new / m\n        v_intermediate = v_half + a_new * (dt / 2.0)\n        \n        # 2. Thermostat step (S)\n        inst_temp_intermediate = (v_intermediate @ v_intermediate) / N\n        if inst_temp_intermediate > 0:\n            scale_factor = np.sqrt(1.0 + (dt / tau) * (T0 / inst_temp_intermediate - 1.0))\n            v_new = v_intermediate * scale_factor\n        else:\n            v_new = v_intermediate\n        return x_new, v_new\n\n    def step_C(x, v, dt, T0, tau, N):\n        # S/2-VV-S/2 Order\n        # 1. First half thermostat step (S/2)\n        dt_half = dt / 2.0\n        inst_temp = (v @ v) / N\n        if inst_temp > 0:\n            scale_factor1 = np.sqrt(1.0 + (dt_half / tau) * (T0 / inst_temp - 1.0))\n            v = v * scale_factor1\n\n        # 2. Full Velocity Verlet step (VV)\n        a = -k * x / m\n        v_half = v + a * (dt / 2.0)\n        x_new = x + v_half * dt\n        a_new = -k * x_new / m\n        v_intermediate = v_half + a_new * (dt / 2.0)\n\n        # 3. Second half thermostat step (S/2)\n        inst_temp_intermediate = (v_intermediate @ v_intermediate) / N\n        if inst_temp_intermediate > 0:\n            scale_factor2 = np.sqrt(1.0 + (dt_half / tau) * (T0 / inst_temp_intermediate - 1.0))\n            v_new = v_intermediate * scale_factor2\n        else:\n            v_new = v_intermediate\n        return x_new, v_new\n\n    # Select the stepping function\n    if order == 'A':\n        step_func = step_A\n    elif order == 'B':\n        step_func = step_B\n    else: # order == 'C'\n        step_func = step_C\n\n    # Burn-in phase\n    for _ in range(N_burn):\n        x, v = step_func(x, v, dt, T0, tau, N)\n\n    # Measurement phase\n    total_temp = 0.0\n    for _ in range(N_meas):\n        x, v = step_func(x, v, dt, T0, tau, N)\n        inst_temp = (v @ v) / N\n        total_temp += inst_temp\n    \n    avg_temp = total_temp / N_meas\n    bias = avg_temp - T0\n    return bias\n\ndef solve():\n    # Define parameters from the problem statement\n    N = 256\n    T0 = 1.0\n    tau = 2.0\n    N_burn = 2000\n    N_meas = 10000\n    seed = 2025\n    \n    # Reduced units\n    m = 1.0\n    k = 1.0\n\n    # Generate initial conditions deterministically\n    rng = np.random.default_rng(seed)\n    # std_dev for positions from 1/2 k x^2> = 1/2 kB T0\n    std_x = np.sqrt(T0 / k) \n    # std_dev for velocities from 1/2 m v^2> = 1/2 kB T0\n    std_v = np.sqrt(T0 / m)\n    \n    x_initial = rng.normal(loc=0.0, scale=std_x, size=N)\n    v_initial = rng.normal(loc=0.0, scale=std_v, size=N)\n\n    # Define the test cases\n    test_cases = [\n        (0.05, 'A'), (0.05, 'B'), (0.05, 'C'),\n        (0.5, 'A'), (0.5, 'B'), (0.5, 'C'),\n        (1.5, 'A'), (1.5, 'B'), (1.5, 'C')\n    ]\n\n    results = []\n    for dt, order in test_cases:\n        bias = run_simulation(dt, order, N, T0, tau, N_burn, N_meas, x_initial, v_initial)\n        results.append(f\"{bias:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3496490"}, {"introduction": "A thermostat's primary role in equilibrium simulations is to generate a trajectory that correctly samples the canonical ensemble. This principle, known as the ergodic hypothesis, can be difficult to satisfy in systems with high energy barriers separating distinct conformational states. This advanced numerical experiment challenges you to test the ergodicity of a Nosé–Hoover chain thermostat by simulating a particle in a multi-well potential and rigorously comparing the observed residence times against the theoretical Boltzmann probabilities [@problem_id:3496461].", "problem": "Design and implement a complete, self-contained numerical experiment to assess whether a Nosé–Hoover chain sampler is effectively ergodic for a one-dimensional particle evolving in a triple-well potential by comparing empirical residence-time-based occupation fractions of wells to the corresponding Boltzmann weights. Your program must implement time integration of deterministic dynamics using the Nosé–Hoover chain thermostat, compute residence times in predefined wells, evaluate the theoretical Boltzmann probabilities by numerical quadrature, and decide pass or fail for specified test cases based on a quantitative discrepancy metric.\n\nAll simulations are in reduced, dimensionless units. Set the particle mass to $m = 1$ and Boltzmann’s constant to $k_{\\mathrm{B}} = 1$. The potential energy is\n$$\nV(x) = \\frac{x^{6}}{6} - \\frac{a}{4}\\,x^{4} + \\frac{b}{2}\\,x^{2},\n$$\nwith parameters $a = 5$ and $b = 4$. For these parameters, the nearest local maxima to the origin occur at $x = \\pm 1$, and the potential has three wells: the left well $(-\\infty,-1)$, the center well $[-1,1]$, and the right well $(1,\\infty)$.\n\nImplement a Nosé–Hoover chain of length $M$ that controls the kinetic temperature at a target temperature $T$. Use a single physical coordinate $x$ and velocity $v = \\dot{x}$. Let $\\xi_{j}$ denote the $j$-th thermostat variable and $Q_{j}$ the corresponding thermostat mass. The equations of motion to integrate are the standard Nosé–Hoover chain ordinary differential equations for a single degree of freedom:\n- $\\dot{x} = v$,\n- $\\dot{v} = \\frac{F(x)}{m} - \\xi_{1}\\,v$, where $F(x) = -\\frac{d V}{d x}$,\n- For $j = 1$: $\\dot{\\xi}_{1} = \\frac{m v^{2} - k_{\\mathrm{B}} T}{Q_{1}} - \\xi_{2}\\,\\xi_{1}$ if $M \\ge 2$, and $\\dot{\\xi}_{1} = \\frac{m v^{2} - k_{\\mathrm{B}} T}{Q_{1}}$ if $M = 1$,\n- For $j = 2,\\dots,M-1$: $\\dot{\\xi}_{j} = \\frac{Q_{j-1}\\,\\xi_{j-1}^{2} - k_{\\mathrm{B}} T}{Q_{j}} - \\xi_{j+1}\\,\\xi_{j}$,\n- For $j = M$: $\\dot{\\xi}_{M} = \\frac{Q_{M-1}\\,\\xi_{M-1}^{2} - k_{\\mathrm{B}} T}{Q_{M}}$.\n\nChoose thermostat masses according to $Q_{j} = k_{\\mathrm{B}} T\\,\\tau^{2}$ for all $j \\in \\{1,\\dots,M\\}$, where $\\tau$ is a user-specified thermostat time scale. Use a fixed time step $\\Delta t$ and a fixed-step explicit integrator of your choice to numerically integrate the above system. Your numerical experiment must:\n- Simulate for a total of $N_{\\text{steps}}$ steps with time step $\\Delta t$,\n- Discard an initial burn-in of $N_{\\text{burn}}$ steps from all statistics,\n- Compute residence time distributions by segmenting the trajectory into maximal contiguous segments within each well and recording each segment’s duration in time units of $\\Delta t$,\n- Compute the empirical occupation fraction vector $\\hat{\\boldsymbol{p}} = (\\hat{p}_{\\mathrm{L}}, \\hat{p}_{\\mathrm{C}}, \\hat{p}_{\\mathrm{R}})$ as the fraction of post-burn-in simulation time spent in each of the three wells,\n- Compute the theoretical Boltzmann probabilities $\\boldsymbol{p}^{\\star} = (p_{\\mathrm{L}}^{\\star}, p_{\\mathrm{C}}^{\\star}, p_{\\mathrm{R}}^{\\star})$ via\n$$\np_{\\mathrm{L}}^{\\star} = \\frac{1}{Z}\\int_{-\\infty}^{-1} e^{-\\beta V(x)}\\,dx,\\quad\np_{\\mathrm{C}}^{\\star} = \\frac{1}{Z}\\int_{-1}^{1} e^{-\\beta V(x)}\\,dx,\\quad\np_{\\mathrm{R}}^{\\star} = \\frac{1}{Z}\\int_{1}^{\\infty} e^{-\\beta V(x)}\\,dx,\n$$\nwith $\\beta = 1/(k_{\\mathrm{B}} T)$ and the partition function $Z$ equal to the sum of the three integrals; evaluate the integrals numerically to high accuracy,\n- Compute the total variation discrepancy\n$$\nD_{\\mathrm{TV}}(\\hat{\\boldsymbol{p}}, \\boldsymbol{p}^{\\star}) = \\frac{1}{2}\\sum_{w \\in \\{\\mathrm{L},\\mathrm{C},\\mathrm{R}\\}} \\left|\\hat{p}_{w} - p_{w}^{\\star}\\right|.\n$$\n\nA test case is judged “pass” if $D_{\\mathrm{TV}}(\\hat{\\boldsymbol{p}}, \\boldsymbol{p}^{\\star}) \\le \\varepsilon$, where $\\varepsilon$ is a supplied tolerance for that case. Otherwise it is “fail.” Use the following test suite, where each tuple is $(T, M, \\Delta t, N_{\\text{steps}}, N_{\\text{burn}}, \\tau, \\varepsilon)$:\n- Case $1$: $(0.5, 3, 0.002, 60000, 5000, 0.2, 0.12)$,\n- Case $2$: $(0.1, 3, 0.002, 40000, 5000, 0.2, 0.20)$,\n- Case $3$: $(0.5, 1, 0.002, 40000, 5000, 0.2, 0.12)$,\n- Case $4$: $(0.5, 5, 0.002, 80000, 5000, 0.2, 0.10)$.\n\nInitialization requirements:\n- Set initial position to $x(0) = 0$,\n- Draw initial velocity from a zero-mean Gaussian with variance $k_{\\mathrm{B}} T / m$ using a fixed random seed so results are deterministic,\n- Initialize all thermostat variables to $\\xi_{j}(0) = 0$.\n\nAll quantities are dimensionless. Your program must compute, for each test case, a boolean indicating pass (true) or fail (false) according to the criterion above. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., “[true,false,true,true]”), preserving Python boolean capitalization (“True” and “False”). No angles or percentages are requested. The final output must be exactly in this format with no extra text.", "solution": "The problem requires the design and implementation of a numerical experiment to evaluate the ergodic sampling efficiency of a Nosé–Hoover chain thermostat. The system under consideration is a one-dimensional particle of mass $m=1$ moving in a symmetric triple-well potential given by\n$$\nV(x) = \\frac{x^{6}}{6} - \\frac{a}{4}\\,x^{4} + \\frac{b}{2}\\,x^{2}\n$$\nwith parameters $a=5$ and $b=4$. The Boltzmann constant is set to $k_{\\mathrm{B}}=1$. The assessment of ergodicity is performed by comparing the empirical occupation fractions of the potential wells, obtained from a long molecular dynamics trajectory, to the theoretical probabilities derived from the Boltzmann distribution.\n\nFirst, we define the physical system. The force acting on the particle is the negative gradient of the potential:\n$$\nF(x) = -\\frac{dV(x)}{dx} = -\\left(x^{5} - ax^{3} + bx\\right) = -x^{5} + 5x^{3} - 4x.\n$$\nThe system's temperature is controlled by a Nosé–Hoover chain of length $M$. The state of the full system is described by the particle's position $x$, its velocity $v$, and the $M$ thermostat variables $\\xi_{1}, \\xi_{2}, \\dots, \\xi_{M}$. The equations of motion for this extended system are a set of coupled first-order ordinary differential equations (ODEs):\n\\begin{align*}\n\\dot{x} = v \\\\\n\\dot{v} = \\frac{F(x)}{m} - \\xi_{1} v \\\\\n\\dot{\\xi}_{1} = \\frac{1}{Q_{1}}(m v^{2} - k_{\\mathrm{B}} T) - \\begin{cases} 0  \\text{if } M=1 \\\\ \\xi_{2} \\xi_{1}  \\text{if } M \\ge 2 \\end{cases} \\\\\n\\dot{\\xi}_{j} = \\frac{1}{Q_{j}}(Q_{j-1} \\xi_{j-1}^{2} - k_{\\mathrm{B}} T) - \\xi_{j+1} \\xi_{j}, \\quad \\text{for } j=2, \\dots, M-1 \\\\\n\\dot{\\xi}_{M} = \\frac{1}{Q_{M}}(Q_{M-1} \\xi_{M-1}^{2} - k_{\\mathrm{B}} T), \\quad \\text{for } M \\ge 2\n\\end{align*}\nwhere $T$ is the target temperature, and $Q_j$ are the thermostat \"masses\", set to $Q_j = k_{\\mathrm{B}} T \\tau^2$ for a given time scale parameter $\\tau$. This chain of thermostats is designed to generate canonical ensemble dynamics. The first thermostat variable $\\xi_1$ directly couples to the physical particle's kinetic energy, while the subsequent variables $\\xi_2, \\ldots, \\xi_M$ form a chain that thermostats the preceding variable, which helps suppress oscillations and improves the exploration of phase space, a known issue with the simple Nosé-Hoover thermostat ($M=1$).\n\nTo solve these ODEs numerically, a robust integration scheme is required. While symplectic integrators like the Martyna-Tuckerman-Klein algorithm are common, for this problem, we select the fourth-order Runge-Kutta (RK4) method. RK4 is a general-purpose, explicit, and highly accurate integrator suitable for a well-behaved system of ODEs over a finite time interval. Although not symplectic, its high order minimizes energy drift per step, and the thermostat's action is designed to correct for any such drift to maintain the target temperature over the long term. The state vector is $Y = (x, v, \\xi_1, \\dots, \\xi_M)$, and the integration proceeds by iteratively applying the RK4 update rule.\n\nThe core of the experiment is to test the ergodic hypothesis, which states that for an ergodic system, the time average of an observable is equal to its ensemble average. Here, the observable is the particle's location relative to the three potential wells: the left well $W_L = (-\\infty, -1)$, the center well $W_C = [-1, 1]$, and the right well $W_R = (1, \\infty)$.\nThe empirical occupation fraction for a well $w \\in \\{\\mathrm{L}, \\mathrm{C}, \\mathrm{R}\\}$, denoted $\\hat{p}_w$, is computed as the fraction of simulation time (after an initial burn-in period of $N_{\\text{burn}}$ steps) that the particle spends in that well.\n$$\n\\hat{p}_{w} = \\frac{\\text{Number of post-burn-in steps in well } w}{\\text{Total number of post-burn-in steps}}\n$$\nThe theoretical probabilities, $p_w^{\\star}$, are derived from the canonical ensemble's Boltzmann distribution. The probability of finding the particle in a region is proportional to the integral of the Boltzmann factor, $e^{-\\beta V(x)}$, over that region, where $\\beta = 1/(k_{\\mathrm{B}} T)$. The probabilities are:\n$$\np_{w}^{\\star} = \\frac{1}{Z} \\int_{x \\in W_w} e^{-\\beta V(x)} dx\n$$\nwhere $Z = \\int_{-\\infty}^{\\infty} e^{-\\beta V(x)} dx$ is the partition function, ensuring normalization ($\\sum_w p_w^{\\star} = 1$). Due to the complexity of $V(x)$, these integrals are computed numerically to high precision using a standard quadrature method, such as the one provided by `scipy.integrate.quad`.\n\nFinally, the discrepancy between the simulated and theoretical distributions is quantified using the total variation distance:\n$$\nD_{\\mathrm{TV}}(\\hat{\\boldsymbol{p}}, \\boldsymbol{p}^{\\star}) = \\frac{1}{2}\\sum_{w \\in \\{\\mathrm{L},\\mathrm{C},\\mathrm{R}\\}} \\left|\\hat{p}_{w} - p_{w}^{\\star}\\right|.\n$$\nA test case is considered a \"pass\" if this discrepancy is less than or equal to a given tolerance $\\varepsilon$, indicating that the simulation has sampled the configuration space in a manner consistent with the target canonical ensemble. The entire procedure is deterministic, including the initial velocity draw, by fixing the random number generator's seed.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\n\n# language: Python\n# version: 3.12\n# libraries:\n#   name: numpy, version: 1.23.5\n#   name: scipy, version: 1.11.4\n\ndef solve():\n    \"\"\"\n    Main function to run the series of numerical experiments.\n    \"\"\"\n    # Define test cases: (T, M, dt, N_steps, N_burn, tau, epsilon)\n    test_cases = [\n        (0.5, 3, 0.002, 60000, 5000, 0.2, 0.12),\n        (0.1, 3, 0.002, 40000, 5000, 0.2, 0.20),\n        (0.5, 1, 0.002, 40000, 5000, 0.2, 0.12),\n        (0.5, 5, 0.002, 80000, 5000, 0.2, 0.10),\n    ]\n\n    # Global parameters\n    m = 1.0\n    k_B = 1.0\n    a = 5.0\n    b = 4.0\n    \n    # Use a fixed seed for reproducibility as requested\n    np.random.seed(12345)\n\n    def V(x):\n        \"\"\"Potential energy function V(x).\"\"\"\n        return (x**6 / 6.0) - (a / 4.0) * x**4 + (b / 2.0) * x**2\n\n    def F(x):\n        \"\"\"Force function F(x) = -dV/dx.\"\"\"\n        return -(x**5 - a * x**3 + b * x)\n\n    def calculate_theoretical_probabilities(T):\n        \"\"\"\n        Computes theoretical well probabilities using numerical quadrature.\n        \"\"\"\n        beta = 1.0 / (k_B * T)\n        integrand = lambda x: np.exp(-beta * V(x))\n\n        I_L, _ = quad(integrand, -np.inf, -1.0)\n        I_C, _ = quad(integrand, -1.0, 1.0)\n        I_R, _ = quad(integrand, 1.0, np.inf)\n\n        Z = I_L + I_C + I_R\n        return np.array([I_L / Z, I_C / Z, I_R / Z])\n\n    def get_derivatives(state, T, M, Q, m_val):\n        \"\"\"\n        Computes the time derivatives of the state vector [x, v, xi_1, ..., xi_M].\n        \"\"\"\n        x, v = state[0], state[1]\n        xi = state[2:]\n        \n        derivs = np.zeros_like(state)\n        \n        # d_x/dt\n        derivs[0] = v\n        # d_v/dt\n        derivs[1] = F(x) / m_val - xi[0] * v\n        \n        # d_xi/dt\n        if M == 1:\n            g1 = m_val * v**2 - k_B * T\n            derivs[2] = g1 / Q[0]\n        else: # M >= 2\n            # j = 1\n            g1 = m_val * v**2 - k_B * T\n            derivs[2] = g1 / Q[0] - xi[1] * xi[0]\n            \n            # j = 2 to M-1\n            for j in range(1, M - 1):\n                gj_plus_1 = Q[j - 1] * xi[j - 1]**2 - k_B * T\n                derivs[j + 2] = gj_plus_1 / Q[j] - xi[j + 1] * xi[j]\n                \n            # j = M\n            gM = Q[M - 2] * xi[M - 2]**2 - k_B * T\n            derivs[M + 1] = gM / Q[M - 1]\n            \n        return derivs\n\n    def run_simulation(T, M, dt, N_steps, N_burn, tau):\n        \"\"\"\n        Runs a single MD simulation with a Nosé-Hoover chain thermostat.\n        \"\"\"\n        # Initial conditions\n        x0 = 0.0\n        v0 = np.random.normal(loc=0.0, scale=np.sqrt(k_B * T / m))\n        xi0 = np.zeros(M)\n        \n        state = np.concatenate(([x0, v0], xi0))\n        \n        Q_vals = np.full(M, k_B * T * tau**2)\n        \n        residence_counts = np.zeros(3) # [Left, Center, Right]\n\n        for step in range(N_steps):\n            # RK4 integrator\n            k1 = dt * get_derivatives(state, T, M, Q_vals, m)\n            k2 = dt * get_derivatives(state + 0.5 * k1, T, M, Q_vals, m)\n            k3 = dt * get_derivatives(state + 0.5 * k2, T, M, Q_vals, m)\n            k4 = dt * get_derivatives(state + k3, T, M, Q_vals, m)\n            state += (k1 + 2 * k2 + 2 * k3 + k4) / 6.0\n            \n            if step >= N_burn:\n                x_pos = state[0]\n                if x_pos  -1.0:\n                    residence_counts[0] += 1\n                elif x_pos > 1.0:\n                    residence_counts[2] += 1\n                else:\n                    residence_counts[1] += 1\n        \n        total_production_steps = N_steps - N_burn\n        if total_production_steps > 0:\n            p_hat = residence_counts / total_production_steps\n        else:\n            p_hat = np.array([0.0, 0.0, 0.0])\n            \n        return p_hat\n\n    results = []\n    for T, M, dt, N_steps, N_burn, tau, epsilon in test_cases:\n        p_star = calculate_theoretical_probabilities(T)\n        p_hat = run_simulation(T, M, dt, N_steps, N_burn, tau)\n        \n        D_TV = 0.5 * np.sum(np.abs(p_hat - p_star))\n        \n        pass_fail = D_TV = epsilon\n        results.append(pass_fail)\n\n    # Format the final output as specified\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3496461"}]}