{"hands_on_practices": [{"introduction": "The most direct information contained in the radial distribution function, $g(r)$, is the spatial arrangement of neighboring particles. This exercise provides a foundational hands-on experience by having you calculate the coordination number, which quantifies the average number of neighbors within a given distance. You will start from first principles to derive the integral connecting $g(r)$ to the coordination number, solidifying the physical interpretation of its peaks and valleys [@problem_id:3483596].", "problem": "You are given a synthetic, physically plausible oxygen-oxygen radial distribution function (RDF) for liquid water and asked to compute the cumulative coordination number $n(r)$, also known as the hydration number up to a cutoff distance $r$. The coordination number $n(r)$ is the average number of oxygen neighbors within distance $r$ of a reference oxygen in a homogeneous isotropic liquid. Your task is to derive the computation of $n(r)$ from first principles using the definition of the RDF, implement an algorithm to evaluate it numerically on a uniform spatial grid, and quantify how the hydration number depends on the choice of the cutoff at the first minimum of $g(r)$.\n\nFundamental base and physical context:\n- Consider a homogeneous isotropic fluid with oxygen number density $\\rho$ expressed in $\\mathrm{nm}^{-3}$.\n- The radial distribution function (RDF) $g(r)$ of oxygen-oxygen (O-O) correlations is defined in statistical mechanics as the ratio of the local number density at a distance $r$ from a tagged oxygen to the bulk number density, without providing any computational shortcuts.\n- In a homogeneous isotropic fluid, the expected number of oxygen atoms in a spherical shell between $r$ and $r + dr$ around a tagged oxygen can be obtained from first principles using the shell volume and the RDF, and the cumulative coordination number $n(r)$ is obtained by summing (integrating) these shell contributions from $0$ to $r$.\n\nScientific and numerical setup:\n- Use liquid water at temperature near ambient and mass density $1\\,\\mathrm{g/cm^3}$, treated as one oxygen per molecule.\n- Compute the oxygen number density $\\rho$ in $\\mathrm{nm}^{-3}$ from first principles using the molar mass of water $M = 0.018\\,\\mathrm{kg/mol}$, mass density $\\rho_{\\mathrm{mass}} = 1000\\,\\mathrm{kg/m^3}$, and the Avogadro constant $N_{\\mathrm{A}} = 6.02214076\\times 10^{23}\\,\\mathrm{mol^{-1}}$. Convert $\\mathrm{m^3}$ to $\\mathrm{nm^3}$ using $1\\,\\mathrm{m^3} = 10^{27}\\,\\mathrm{nm^3}$. The numerical value of $\\rho$ must be computed by your program, not hard-coded.\n- Define a uniform radial grid $r$ from $0$ to $r_{\\max}$ with spacing $\\Delta r$ in nanometers, where $r_{\\max} = 1.0\\,\\mathrm{nm}$ and $\\Delta r = 0.0005\\,\\mathrm{nm}$. Angles are not involved in this problem, so no angular units are required.\n- Define a synthetic O-O RDF $g_{\\mathrm{OO}}(r)$ that exhibits realistic liquid water structure: a strong first peak near $r \\approx 0.275\\,\\mathrm{nm}$, a first minimum near $r \\approx 0.33\\,\\mathrm{nm}$ with $g(r) < 1$, a weaker second peak near $r \\approx 0.45\\,\\mathrm{nm}$, and $g(r) \\to 1$ as $r$ increases. Use the following analytic form for $g_{\\mathrm{OO}}(r)$, all distances in nanometers:\n$$\ng_{\\mathrm{OO}}(r) = s(r)\\left(1 + A_1 \\exp\\!\\left(-\\frac{(r - r_1)^2}{2\\sigma_1^2}\\right) - B_1 \\exp\\!\\left(-\\frac{(r - r_{\\min})^2}{2\\sigma_{\\min}^2}\\right) + A_2 \\exp\\!\\left(-\\frac{(r - r_2)^2}{2\\sigma_2^2}\\right)\\right),\n$$\n$$\ns(r) = 1 - \\exp\\!\\left(-\\left(\\frac{r}{r_0}\\right)^6\\right),\n$$\nwith the parameters\n$$\nr_0 = 0.23,\\quad A_1 = 2.8,\\quad r_1 = 0.275,\\quad \\sigma_1 = 0.010,\\quad B_1 = 0.15,\\quad r_{\\min} = 0.33,\\quad \\sigma_{\\min} = 0.012,\\quad A_2 = 0.20,\\quad r_2 = 0.45,\\quad \\sigma_2 = 0.020.\n$$\n- Ensure $g_{\\mathrm{OO}}(r) \\ge 0$ by clipping negative values to zero if they occur numerically.\n\nDerivation requirement:\n- Starting from the definition of $g(r)$ and the concept of spherical shells in three dimensions, derive how to compute the expected number of oxygen neighbors within a distance $r$, expressed as $n(r)$, without directly stating the target formula in the problem statement. The derivation must begin with the shell volume and the meaning of $g(r)$ as a ratio of local to bulk number density.\n\nAlgorithmic tasks:\n1. Generate the uniform grid $r$ and evaluate $g_{\\mathrm{OO}}(r)$ on this grid.\n2. Identify the first local maximum (the first peak) of $g_{\\mathrm{OO}}(r)$ in the interval $r \\in [0.24, 0.35]$; then find the first local minimum after that peak in the interval up to $0.50\\,\\mathrm{nm}$. Let the location of the first minimum be $r_{\\mathrm{min,found}}$ (in nanometers).\n3. Compute the hydration number $n(R)$ for four cutoff distances $R$, all in nanometers:\n   - $R_1 = 0.000$ (boundary case),\n   - $R_2 = r_{\\mathrm{min,found}} - \\Delta$ (edge case below the minimum),\n   - $R_3 = r_{\\mathrm{min,found}}$ (the minimum itself),\n   - $R_4 = r_{\\mathrm{min,found}} + \\Delta$ (edge case above the minimum),\n   with $\\Delta = 0.005\\,\\mathrm{nm}$.\n4. Perform numerical integration on the grid to obtain $n(R)$ for each cutoff using a consistent quadrature rule.\n5. Express each $n(R)$ as a float rounded to three decimal places. The hydration number is dimensionless and should be reported without units.\n\nTest suite and final output format:\n- Use the specified four cutoff distances $R_1$, $R_2$, $R_3$, and $R_4$ as the test suite.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order $[n(R_1), n(R_2), n(R_3), n(R_4)]$, for example, in the format $[x_1,x_2,x_3,x_4]$ where each $x_i$ is rounded to three decimal places.", "solution": "The derivation of the cumulative coordination number, $n(r)$, from first principles is a foundational exercise in the statistical mechanics of liquids.\n\n**Derivation of the Coordination Number**\n\nWe begin by considering a homogeneous and isotropic fluid characterized by a bulk number density $\\rho$. This density represents the average number of particles (in this case, oxygen atoms) per unit volume.\n\nThe radial distribution function, $g(r)$, provides a measure of how the local density deviates from the bulk density at a distance $r$ from an arbitrary reference particle. By definition, the local number density at a distance $r$, which we can write as $\\rho(r)$, is related to the bulk density $\\rho$ by:\n$$\n\\rho(r) = \\rho g(r)\n$$\nTo find the total number of particles within a certain radius of the reference particle, one must integrate the local density over the volume of interest. It is most convenient to perform this integration by considering infinitesimally thin spherical shells centered on the reference particle. A spherical shell at a radius $r'$ with a differential thickness $dr'$ has a volume $dV$ given by:\n$$\ndV = 4\\pi (r')^2 dr'\n$$\nThe number of particles, $dN$, within this elemental shell is the product of the local number density at that radius, $\\rho(r')$, and the volume of the shell, $dV$:\n$$\ndN = \\rho(r') dV = \\rho g(r') \\left( 4\\pi (r')^2 dr' \\right)\n$$\nRearranging the terms, we obtain the differential number of particles in the shell as a function of radius:\n$$\ndN(r') = 4\\pi \\rho (r')^2 g(r') dr'\n$$\nThe cumulative coordination number, $n(r)$, is defined as the average total number of particles found within a sphere of radius $r$ centered on the reference particle. To obtain $n(r)$, we must sum (integrate) the number of particles $dN(r')$ in all such concentric shells from a radius of $0$ up to the cutoff radius $r$.\n$$\nn(r) = \\int_0^r dN(r') = \\int_0^r 4\\pi \\rho (r')^2 g(r') dr'\n$$\nThis integral is the fundamental relationship connecting the radial distribution function $g(r)$ to the coordination number $n(r)$. To compute $n(r)$ numerically, we will evaluate this definite integral.\n\n**Algorithmic Implementation**\n\nThe solution proceeds through the following computational steps.\n\n1.  **System Parameter Calculation**: The number density $\\rho$ of oxygen atoms in liquid water is computed from the given macroscopic properties. The mass density is $\\rho_{\\mathrm{mass}} = 1000\\,\\mathrm{kg/m^3}$, the molar mass of water is $M = 0.018\\,\\mathrm{kg/mol}$, and Avogadro's constant is $N_{\\mathrm{A}} = 6.02214076\\times 10^{23}\\,\\mathrm{mol^{-1}}$. The number of molecules per cubic meter is given by $(\\rho_{\\mathrm{mass}}/M) \\times N_{\\mathrm{A}}$. Since there is one oxygen atom per water molecule, this is also the oxygen number density. To convert this to units of $\\mathrm{nm}^{-3}$, we use the conversion factor $1\\,\\mathrm{m^3} = 10^{27}\\,\\mathrm{nm^3}$.\n    $$\n    \\rho = \\frac{\\rho_{\\mathrm{mass}}}{M} N_{\\mathrm{A}} \\frac{1\\,\\mathrm{m^3}}{10^{27}\\,\\mathrm{nm^3}} = \\frac{1000\\,\\mathrm{kg/m^3}}{0.018\\,\\mathrm{kg/mol}} \\times (6.02214076\\times 10^{23}\\,\\mathrm{mol^{-1}}) \\times 10^{-27}\\,\\mathrm{m^3/nm^3}\n    $$\n    This calculation is performed numerically in the implementation.\n\n2.  **Grid and Function Generation**: A uniform radial grid is established for the variable $r$, ranging from $r = 0\\,\\mathrm{nm}$ to $r_{\\max} = 1.0\\,\\mathrm{nm}$ with a step size of $\\Delta r = 0.0005\\,\\mathrm{nm}$. On this grid, we evaluate the synthetic oxygen-oxygen radial distribution function $g_{\\mathrm{OO}}(r)$ using the provided analytical formula and parameters:\n    $$\n    g_{\\mathrm{OO}}(r) = s(r)\\left(1 + A_1 \\exp\\!\\left(-\\frac{(r - r_1)^2}{2\\sigma_1^2}\\right) - B_1 \\exp\\!\\left(-\\frac{(r - r_{\\min})^2}{2\\sigma_{\\min}^2}\\right) + A_2 \\exp\\!\\left(-\\frac{(r - r_2)^2}{2\\sigma_2^2}\\right)\\right)\n    $$\n    where $s(r) = 1 - \\exp\\!\\left(-\\left(\\frac{r}{r_0}\\right)^6\\right)$. The parameters are $r_0 = 0.23$, $A_1 = 2.8$, $r_1 = 0.275$, $\\sigma_1 = 0.010$, $B_1 = 0.15$, $r_{\\min} = 0.33$, $\\sigma_{\\min} = 0.012$, $A_2 = 0.20$, $r_2 = 0.45$, and $\\sigma_2 = 0.020$, all with distances in nanometers. Any numerically resulting negative value of $g_{\\mathrm{OO}}(r)$ is clipped to $0$.\n\n3.  **Location of the First Minimum**: To determine the standard cutoff for the first hydration shell, we must locate the first minimum of $g_{\\mathrm{OO}}(r)$. The algorithm first identifies the position of the first peak by finding the maximum value of $g_{\\mathrm{OO}}(r)$ in the specified radial interval $r \\in [0.24, 0.35]\\,\\mathrm{nm}$. Subsequently, it searches for the minimum value of $g_{\\mathrm{OO}}(r)$ in the range starting from the position of the first peak up to $r = 0.50\\,\\mathrm{nm}$. The radial position of this minimum is denoted $r_{\\mathrm{min,found}}$. Due to the discrete nature of the grid, this position will correspond to one of the grid points.\n\n4.  **Numerical Integration**: The coordination number $n(R)$ for a given cutoff radius $R$ is computed by numerically evaluating the integral derived above. The integrand is $f(r) = 4\\pi \\rho r^2 g_{\\mathrm{OO}}(r)$. We use the trapezoidal rule for numerical quadrature, which is well-suited for a function evaluated on a fine, uniform grid. The integral is computed as:\n    $$\n    n(R) = \\int_0^R 4\\pi \\rho r^2 g_{\\mathrm{OO}}(r) dr \\approx \\sum_{i=1}^{N_R} \\frac{f(r_i) + f(r_{i-1})}{2} (r_i - r_{i-1})\n    $$\n    where the grid points $r_i$ run from $r_0=0$ to $r_{N_R} = R$. This is implemented efficiently using a library function for trapezoidal integration.\n\n5.  **Evaluation at Specified Cutoff Distances**: The final task is to calculate $n(R)$ for four specific cutoff distances:\n    *   $R_1 = 0.000\\,\\mathrm{nm}$.\n    *   $R_2 = r_{\\mathrm{min,found}} - \\Delta$, where $\\Delta = 0.005\\,\\mathrm{nm}$.\n    *   $R_3 = r_{\\mathrm{min,found}}$.\n    *   $R_4 = r_{\\mathrm{min,found}} + \\Delta$.\n    The coordination number for $R_1=0$ is analytically $0$. For the other cutoffs, the numerical integration is performed up to the grid index corresponding to each $R_k$. The resulting values are then rounded to three decimal places. The parameter $\\Delta = 0.005\\,\\mathrm{nm}$ corresponds to exactly $10$ grid steps ($10 \\times 0.0005\\,\\mathrm{nm}$), ensuring that $R_2$ and $R_4$ also fall perfectly on grid points, simplifying the integration procedure.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the cumulative coordination number for a synthetic O-O RDF of liquid water\n    at four specified cutoff distances.\n    \"\"\"\n    #\n    # Define physical constants and problem parameters\n    #\n    M_WATER = 0.018  # Molar mass of water in kg/mol\n    RHO_MASS = 1000.0  # Mass density of water in kg/m^3\n    N_A = 6.02214076e23  # Avogadro constant in mol^-1\n    M3_TO_NM3 = 1e27  # Conversion factor for m^3 to nm^3\n\n    # Parameters for the synthetic g_OO(r) function (all distances in nm)\n    R0 = 0.23\n    A1 = 2.8\n    R1 = 0.275\n    SIGMA1 = 0.010\n    B1 = 0.15\n    R_MIN_PARAM = 0.33\n    SIGMA_MIN = 0.012\n    A2 = 0.20\n    R2 = 0.45\n    SIGMA2 = 0.020\n\n    # Numerical grid parameters (in nm)\n    R_MAX = 1.0\n    DR = 0.0005\n\n    # Test case parameters (in nm)\n    DELTA = 0.005\n    R1_cutoff = 0.000\n\n    #\n    # Step 1: Calculate oxygen number density rho in nm^-3\n    #\n    # Number of molecules per cubic meter\n    n_per_m3 = (RHO_MASS / M_WATER) * N_A\n    # Convert to number of molecules per cubic nanometer\n    rho = n_per_m3 / M3_TO_NM3\n\n    #\n    # Step 2: Generate the radial grid and evaluate g_OO(r)\n    #\n    r_grid = np.arange(0, R_MAX + DR / 2, DR)\n\n    def g_oo(r):\n        \"\"\"Calculates the synthetic O-O radial distribution function.\"\"\"\n        s_r = 1.0 - np.exp(-((r / R0)**6))\n        \n        term1 = A1 * np.exp(-((r - R1)**2) / (2.0 * SIGMA1**2))\n        term2 = -B1 * np.exp(-((r - R_MIN_PARAM)**2) / (2.0 * SIGMA_MIN**2))\n        term3 = A2 * np.exp(-((r - R2)**2) / (2.0 * SIGMA2**2))\n        \n        g = s_r * (1.0 + term1 + term2 + term3)\n        \n        return np.maximum(g, 0.0)  # Clip negative values to zero\n\n    g_values = g_oo(r_grid)\n\n    #\n    # Step 3: Find the first minimum of g_OO(r) after the first peak\n    #\n    # Find the index of the first peak in the interval [0.24, 0.35] nm\n    peak_search_start_idx = int(round(0.24 / DR))\n    peak_search_end_idx = int(round(0.35 / DR))\n    peak_idx_relative = np.argmax(\n        g_values[peak_search_start_idx:peak_search_end_idx + 1]\n    )\n    peak_idx = peak_search_start_idx + peak_idx_relative\n    \n    # Find the first minimum in the interval [r_peak, 0.50] nm\n    min_search_start_idx = peak_idx\n    min_search_end_idx = int(round(0.50 / DR))\n    min_idx_relative = np.argmin(\n        g_values[min_search_start_idx:min_search_end_idx + 1]\n    )\n    min_idx = min_search_start_idx + min_idx_relative\n    r_min_found = r_grid[min_idx]\n\n    #\n    # Step 4  5: Define cutoffs and compute coordination numbers via numerical integration\n    #\n    R2_cutoff = r_min_found - DELTA\n    R3_cutoff = r_min_found\n    R4_cutoff = r_min_found + DELTA\n\n    cutoffs = [R1_cutoff, R2_cutoff, R3_cutoff, R4_cutoff]\n    \n    # Pre-calculate the integrand for the coordination number\n    integrand = 4.0 * np.pi * rho * r_grid**2 * g_values\n    \n    coordination_numbers = []\n    \n    for R_c in cutoffs:\n        if R_c == 0.0:\n            n_r = 0.0\n        else:\n            # Find the grid index corresponding to the cutoff radius.\n            # `round` handles potential float precision issues, ensuring an exact integer index\n            # as all cutoffs are designed to fall on grid points.\n            cutoff_idx = int(round(R_c / DR))\n            \n            # Integrate from r=0 up to the cutoff index using the trapezoidal rule\n            n_r = np.trapz(\n                integrand[:cutoff_idx + 1],\n                r_grid[:cutoff_idx + 1]\n            )\n        \n        # Round the result to three decimal places as required\n        coordination_numbers.append(round(n_r, 3))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, coordination_numbers))}]\")\n\nsolve()\n```", "id": "3483596"}, {"introduction": "Beyond describing local structure, $g(r)$ is a key ingredient for calculating macroscopic thermodynamic properties. This practice demonstrates this connection by using the virial equation of state, which links microscopic forces, the average particle distribution $g(r)$, and the bulk pressure $P$. You will apply the virial theorem to derive this important relationship and then implement it numerically to compute the pressure of a simple fluid from its structure [@problem_id:3483653].", "problem": "You will derive and implement an equation of state for a classical, homogeneous, isotropic fluid with pairwise additive interactions using the statistical mechanical virial route. Begin from the virial theorem in classical mechanics and the definition of the radial distribution function. Derive the pressure of a uniform fluid in terms of the number density, the temperature, the radial distribution function, and the radial derivative of the pair potential. Then, implement a numerical procedure to evaluate the pressure using a synthetic but physically plausible radial distribution function and assess the sensitivity of the pressure to the quality of short-range sampling in the radial distribution function.\n\nFundamental base for derivation: use the classical virial theorem and the definition of the radial distribution function. Specifically use: the virial theorem for a system with pairwise central forces, the number density $\\rho = N/V$, the Boltzmann constant $k_B$, the temperature $T$, central force $\\mathbf{F}(r) = -U'(r)\\,\\hat{\\mathbf{r}}$, isotropy to reduce the tensorial virial to a scalar integral, and the pair correlation encoded by the radial distribution function $g(r)$.\n\nModel system and units: use the Lennard–Jones pair potential with reduced units. In reduced Lennard–Jones units, set the energy scale $\\varepsilon = 1$, the length scale $\\sigma = 1$, and the Boltzmann constant $k_B = 1$. The pressure must be reported in reduced Lennard–Jones units of energy per volume, that is, in $\\varepsilon/\\sigma^3$. Physical parameters: use number density $\\rho = 0.85$ and temperature $T = 1.10$.\n\nSynthetic radial distribution function: to evaluate sensitivity to sampling, generate $g(r)$ from a smooth, physically plausible analytic form that suppresses the hard-core region and exhibits damped oscillations approaching unity. Use\n$$\nS(r) = \\tfrac{1}{2}\\left[1 + \\tanh\\!\\left(\\frac{r - r_c}{w}\\right)\\right],\\quad r_c = 0.95,\\quad w = 0.02,\n$$\nand\n$$\ng_{\\text{raw}}(r) = 1 + A\\,e^{-\\alpha\\,(r - r_1)}\\sin\\!\\big(\\beta\\,(r - r_1)\\big),\\quad A = 1.50,\\ \\alpha = 1.80,\\ \\beta = 7.00,\\ r_1 = 1.10,\n$$\nthen define\n$$\ng(r) = S(r)\\,\\max\\!\\big(0,\\,g_{\\text{raw}}(r)\\big).\n$$\nThis $g(r)$ is nonnegative, vanishes in the core region, exhibits a first peak near $r \\approx r_1$, and decays to unity with damped oscillations, consistent with a simple fluid.\n\nPair potential and derivative: in reduced units, the Lennard–Jones potential is\n$$\nU(r) = 4\\left[\\left(\\frac{1}{r}\\right)^{12} - \\left(\\frac{1}{r}\\right)^{6}\\right],\n$$\nand its radial derivative is\n$$\nU'(r) = 4\\left[-12\\,r^{-13} + 6\\,r^{-7}\\right].\n$$\n\nNumerical evaluation strategy: use numerical quadrature on a radial grid $\\{r_i\\}$ to approximate the virial integral. Because the grids below may be nonuniform, use a composite trapezoidal rule on the discrete set of points to approximate $\\int g(r)\\,r^3\\,U'(r)\\,dr$. Apply a physically motivated long-range tail correction by assuming $g(r)\\to 1$ for large $r$ and integrating $r^3 U'(r)$ analytically from the largest grid radius $r_{\\max}$ to infinity. In reduced Lennard–Jones units, the exact tail integral is\n$$\n\\int_{r_{\\max}}^{\\infty} r^3 U'(r)\\,dr = 8\\,r_{\\max}^{-3} - \\frac{16}{3}\\,r_{\\max}^{-9}.\n$$\n\nReference pressure: construct a high-quality reference by evaluating the pressure on a uniform, fine grid with $r_{\\min} = 0.30$, $r_{\\max} = 6.00$, and $\\Delta r_{\\text{ref}} = 0.001$, including the same long-range tail correction. Use this reference pressure to compute absolute errors for the test cases below.\n\nSensitivity metric: for each test case, compute the absolute difference between the pressure obtained on the test grid and the reference pressure. Report both the pressure and this absolute error.\n\nTest suite: evaluate the pressure for the following five sampling scenarios to assess sensitivity to short-range sampling quality:\n- Case $1$ (uniform fine): $r_{\\min} = 0.30$, $r_{\\max} = 5.00$, $\\Delta r = 0.002$.\n- Case $2$ (uniform coarse): $r_{\\min} = 0.30$, $r_{\\max} = 5.00$, $\\Delta r = 0.020$.\n- Case $3$ (biased coarse short-range, fine long-range): coarse segment $[0.30, 1.20)$ with $\\Delta r = 0.050$, fine segment $[1.20, 5.00]$ with $\\Delta r = 0.005$.\n- Case $4$ (truncated core region): grid starts at $r_{\\min} = 1.00$ with $\\Delta r = 0.005$ up to $r_{\\max} = 5.00$; assume $g(r) = 0$ for $r  r_{\\min}$, which emphasizes sensitivity to missing short-range structure.\n- Case $5$ (fine short-range, coarse long-range): fine segment $[0.30, 2.00)$ with $\\Delta r = 0.002$, coarse segment $[2.00, 5.00]$ with $\\Delta r = 0.050$.\n\nAlgorithmic requirements:\n- Derive the pressure expression from the virial theorem and the radial distribution function definition for an isotropic fluid with pairwise additive forces, without assuming the final target integral form at the outset.\n- For each grid, compute the discrete integral using the composite trapezoidal rule on $\\{r_i\\}$:\n  approximate $\\int_{r_{\\min}}^{r_{\\max}} g(r)\\,r^3\\,U'(r)\\,dr$ by $\\sum_i w_i\\,g(r_i)\\,r_i^3\\,U'(r_i)$ with trapezoidal weights $w_i$ based on neighboring spacings.\n- Apply the long-range tail correction $\\int_{r_{\\max}}^{\\infty} r^3 U'(r)\\,dr$ with $g(r)\\to 1$ as given above.\n- Compute the pressure and the absolute error relative to the reference for each case.\n- Express all pressures in $\\varepsilon/\\sigma^3$ and round to $6$ decimal places in the final output.\n\nFinal output format: your program should produce a single line of output containing the results as a comma-separated list of lists, where each inner list contains the pressure and the absolute error for one test case, both as floats rounded to six decimal places, in the order of cases $1$ through $5$. For example, the format must be\n$$\n\\big[ [p_1,e_1], [p_2,e_2], [p_3,e_3], [p_4,e_4], [p_5,e_5] \\big].\n$$", "solution": "The problem requires the derivation of the virial equation of state for pressure in a classical, isotropic fluid and its numerical implementation for a model system. The derivation must begin from the classical virial theorem and the definition of the radial distribution function.\n\n### Derivation of the Virial Pressure Equation\n\nThe classical virial theorem relates the time-average of the kinetic energy of a system to the time-average of the virial of the total force acting on the particles. For a system of $N$ particles with positions $\\mathbf{r}_i$ and momenta $\\mathbf{p}_i$, the theorem states:\n$$\n\\left\\langle \\sum_{i=1}^N \\frac{\\mathbf{p}_i^2}{m_i} \\right\\rangle = - \\left\\langle \\sum_{i=1}^N \\mathbf{r}_i \\cdot \\mathbf{F}_i^{\\text{tot}} \\right\\rangle\n$$\nwhere $\\langle \\cdot \\rangle$ denotes a time average (equivalent to an ensemble average for an ergodic system in equilibrium) and $\\mathbf{F}_i^{\\text{tot}}$ is the total force on particle $i$.\n\nThe left-hand side is twice the average total kinetic energy, $\\langle 2K \\rangle$. By the principle of equipartition of energy for a system in thermal equilibrium at temperature $T$, the average kinetic energy is $\\langle K \\rangle = \\frac{3}{2}N k_B T$, where $k_B$ is the Boltzmann constant. Thus, the left side of the virial theorem is $3N k_B T$.\n\nThe total force $\\mathbf{F}_i^{\\text{tot}}$ on particle $i$ is the sum of external forces, $\\mathbf{F}_i^{\\text{ext}}$, exerted by the container walls, and internal forces, $\\mathbf{F}_i^{\\text{int}}$, from other particles in the system. The virial of the force can be split accordingly:\n$$\n\\sum_{i=1}^N \\mathbf{r}_i \\cdot \\mathbf{F}_i^{\\text{tot}} = \\sum_{i=1}^N \\mathbf{r}_i \\cdot \\mathbf{F}_i^{\\text{ext}} + \\sum_{i=1}^N \\mathbf{r}_i \\cdot \\mathbf{F}_i^{\\text{int}}\n$$\nThe external force term relates to the macroscopic pressure $P$. The force exerted by the walls on the fluid is $-P \\oint_S d\\mathbf{S}$, where the integral is over the container surface $S$. The virial of this force is $\\sum_i \\mathbf{r}_i \\cdot \\mathbf{F}_i^{\\text{ext}} = -P \\oint_S \\mathbf{r} \\cdot d\\mathbf{S}$. Using the divergence theorem, $\\oint_S \\mathbf{r} \\cdot d\\mathbf{S} = \\int_V (\\nabla \\cdot \\mathbf{r}) dV = \\int_V 3 dV = 3V$. Therefore, the external force virial is $-3PV$.\n\nThe internal force term is due to pairwise interactions. Assuming pairwise additive central forces, the force on particle $i$ is $\\mathbf{F}_i^{\\text{int}} = \\sum_{j \\neq i} \\mathbf{F}_{ij}$, where $\\mathbf{F}_{ij}$ is the force on particle $i$ from particle $j$. The internal virial is:\n$$\n\\mathcal{W}_{\\text{int}} = \\sum_{i=1}^N \\mathbf{r}_i \\cdot \\left( \\sum_{j \\neq i} \\mathbf{F}_{ij} \\right) = \\sum_{i \\neq j} \\mathbf{r}_i \\cdot \\mathbf{F}_{ij}\n$$\nThis sum can be rewritten by grouping pairs $(i, j)$:\n$$\n\\mathcal{W}_{\\text{int}} = \\sum_{i  j} (\\mathbf{r}_i \\cdot \\mathbf{F}_{ij} + \\mathbf{r}_j \\cdot \\mathbf{F}_{ji})\n$$\nBy Newton's third law, $\\mathbf{F}_{ji} = -\\mathbf{F}_{ij}$. Let $\\mathbf{r}_{ij} = \\mathbf{r}_i - \\mathbf{r}_j$.\n$$\n\\mathcal{W}_{\\text{int}} = \\sum_{i  j} (\\mathbf{r}_i - \\mathbf{r}_j) \\cdot \\mathbf{F}_{ij} = \\sum_{i  j} \\mathbf{r}_{ij} \\cdot \\mathbf{F}_{ij}\n$$\nThe force is central, derived from a pair potential $U(r)$, so $\\mathbf{F}_{ij} = -\\frac{dU(r_{ij})}{dr_{ij}} \\hat{\\mathbf{r}}_{ij}$, where $r_{ij} = |\\mathbf{r}_{ij}|$ and $\\hat{\\mathbf{r}}_{ij} = \\mathbf{r}_{ij}/r_{ij}$. The dot product becomes:\n$$\n\\mathbf{r}_{ij} \\cdot \\mathbf{F}_{ij} = r_{ij} \\left(-\\frac{dU(r_{ij})}{dr_{ij}}\\right) = -r_{ij} U'(r_{ij})\n$$\nSubstituting these results into the virial theorem:\n$$\n3N k_B T = - \\left( -3PV + \\left\\langle \\sum_{ij} -r_{ij} U'(r_{ij}) \\right\\rangle \\right) = 3PV - \\left\\langle \\sum_{ij} -r_{ij} U'(r_{ij}) \\right\\rangle\n$$\nRearranging for the pressure $P$ gives:\n$$\nP = \\frac{N k_B T}{V} + \\frac{1}{3V} \\left\\langle \\sum_{ij} -r_{ij} U'(r_{ij}) \\right\\rangle\n$$\nThe first term, $N k_B T / V = \\rho k_B T$ (where $\\rho = N/V$ is the number density), is the ideal gas pressure. The second term is the correction due to intermolecular interactions.\n\nTo evaluate the ensemble average $\\langle \\dots \\rangle$, we introduce the radial distribution function, $g(r)$. For a homogeneous and isotropic fluid, the average number of particles in a spherical shell of radius $r$ and thickness $dr$ around any given particle is $\\rho g(r) 4\\pi r^2 dr$. The number of pairs in the system is approximately $N^2/2$. The average of the interaction virial sum is obtained by integrating the contribution from pairs at all separations:\n$$\n\\left\\langle \\sum_{ij} -r_{ij} U'(r_{ij}) \\right\\rangle = \\int_0^\\infty -r U'(r) dN_p(r) = \\frac{1}{2}N \\rho \\int_0^\\infty (-r U'(r)) g(r) 4\\pi r^2 dr\n$$\n$$\n= -2\\pi N \\rho \\int_0^\\infty r^3 U'(r) g(r) dr\n$$\nSubstituting this back into the pressure equation:\n$$\nP = \\rho k_B T + \\frac{1}{3V} \\left( -2\\pi N \\rho \\int_0^\\infty r^3 U'(r) g(r) dr \\right)\n$$\nUsing $\\rho = N/V$, we arrive at the final virial equation of state:\n$$\nP = \\rho k_B T - \\frac{2\\pi \\rho^2}{3} \\int_0^\\infty r^3 U'(r) g(r) dr\n$$\nIn the reduced Lennard-Jones units specified ($\\varepsilon=1$, $\\sigma=1$, $k_B=1$), the equation simplifies to:\n$$\nP = \\rho T - \\frac{2\\pi \\rho^2}{3} \\int_0^\\infty r^3 U'(r) g(r) dr\n$$\nThis equation provides the pressure $P$ in units of $\\varepsilon/\\sigma^3$ based on the density $\\rho$, temperature $T$, the radial distribution function $g(r)$, and the derivative of the pair potential $U'(r)$.\n\n### Numerical Implementation Strategy\n\nThe implementation will calculate the pressure using the derived formula for a set of given parameters and grid configurations.\n1.  **Define Constants and Functions**: Implement functions for the Lennard-Jones potential derivative $U'(r)$ and the synthetic radial distribution function $g(r)$ as specified. Define the global parameters $\\rho=0.85$ and $T=1.10$.\n2.  **Pressure Calculation Function**: Create a function `calculate_pressure(r_grid, rho, T)` that takes a radial grid and physical parameters.\n3.  **Numerical Integration**: Inside this function, the integral term $I = \\int_0^\\infty r^3 U'(r) g(r) dr$ is approximated. The integral is split into a numerical part over the grid range $[r_{\\min}, r_{\\max}]$ and an analytical long-range tail correction for $[r_{\\max}, \\infty)$.\n    - The integrand $f(r) = r^3 U'(r) g(r)$ is evaluated at each point on `r_grid`.\n    - The numerical integral $I_{\\text{num}} = \\int_{r_{\\min}}^{r_{\\max}} f(r) dr$ is computed using the composite trapezoidal rule, which is suitable for both uniform and non-uniform grids. NumPy's `trapz(y, x)` function implements this. For Case 4, where the grid starts at $r_{\\min}=1.00$, the problem states to assume $g(r)=0$ for $rr_{\\min}$; thus, the integral from $0$ to $r_{\\min}$ is zero, and the calculation correctly starts from the provided grid.\n    - The tail correction $I_{\\text{tail}} = \\int_{r_{\\max}}^{\\infty} r^3 U'(r) dr$ assumes $g(r) \\to 1$ for $r  r_{\\max}$. The problem provides its analytical solution: $I_{\\text{tail}} = 8 r_{\\max}^{-3} - \\frac{16}{3} r_{\\max}^{-9}$.\n4.  **Reference and Test Cases**:\n    - First, a high-quality reference pressure $P_{\\text{ref}}$ is computed on a fine, uniform grid ($r \\in [0.30, 6.00], \\Delta r=0.001$).\n    - Then, for each of the five test cases, a corresponding grid is generated. This includes uniform grids of varying coarseness and non-uniform grids constructed by concatenating segments.\n    - The pressure $P_{\\text{case}}$ is calculated for each test grid.\n    - The absolute error is computed as $e = |P_{\\text{case}} - P_{\\text{ref}}|$.\n5.  **Output Formatting**: The final results, a list of $[P_{\\text{case}}, e]$ pairs, are formatted into the specified string format with values rounded to six decimal places.\n\nThis structured approach ensures that the pressure is calculated according to the derived physical principles and specified numerical methods, allowing for a systematic assessment of the sensitivity to grid sampling quality.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and implements the virial equation of state to calculate the pressure\n    of a Lennard-Jones fluid and assesses its sensitivity to the quality of\n    radial distribution function sampling.\n    \"\"\"\n    \n    # Physical parameters in reduced Lennard-Jones units\n    RHO = 0.85  # Number density\n    T_ = 1.10   # Temperature\n\n    # Parameters for the synthetic radial distribution function g(r)\n    G_R_PARAMS = {\n        'rc': 0.95, 'w': 0.02,\n        'A': 1.50, 'alpha': 1.80, 'beta': 7.00, 'r1': 1.10\n    }\n\n    def g_r(r: np.ndarray) - np.ndarray:\n        \"\"\"\n        Computes the synthetic, physically plausible radial distribution function g(r).\n        \n        Args:\n            r: A NumPy array of radial distances.\n            \n        Returns:\n            A NumPy array of g(r) values.\n        \"\"\"\n        p = G_R_PARAMS\n        s_r = 0.5 * (1.0 + np.tanh((r - p['rc']) / p['w']))\n        g_raw = 1.0 + p['A'] * np.exp(-p['alpha'] * (r - p['r1'])) * np.sin(p['beta'] * (r - p['r1']))\n        g_raw_non_negative = np.maximum(0.0, g_raw)\n        return s_r * g_raw_non_negative\n\n    def dU_lj_dr(r: np.ndarray) - np.ndarray:\n        \"\"\"\n        Computes the radial derivative of the Lennard-Jones potential, U'(r).\n        \n        Args:\n            r: A NumPy array of radial distances.\n            \n        Returns:\n            A NumPy array of dU/dr values.\n        \"\"\"\n        r_inv = 1.0 / r\n        r_inv7 = r_inv**7\n        r_inv13 = r_inv**13\n        return 4.0 * (-12.0 * r_inv13 + 6.0 * r_inv7)\n\n    def tail_correction(r_max: float) - float:\n        \"\"\"\n        Computes the analytical tail correction for the virial integral, assuming g(r)=1.\n        \n        Args:\n            r_max: The cutoff radius of the numerical integration.\n            \n        Returns:\n            The value of the integral from r_max to infinity.\n        \"\"\"\n        r_max_inv3 = r_max**-3\n        r_max_inv9 = r_max**-9\n        return 8.0 * r_max_inv3 - (16.0 / 3.0) * r_max_inv9\n\n    def calculate_pressure(r_grid: np.ndarray, rho: float, T: float) - float:\n        \"\"\"\n        Calculates the pressure using the virial equation for a given radial grid.\n        \n        Args:\n            r_grid: The NumPy array of radial grid points.\n            rho: The number density.\n            T: The temperature.\n            \n        Returns:\n            The calculated pressure.\n        \"\"\"\n        if r_grid.size == 0:\n            # Handle empty grid case (e.g., truncated region with r_min > r_max)\n            # The numerical part of the integral is zero.\n            # But we need a valid r_max for tail correction. This case shouldn't happen with given inputs.\n            # For Case 4, grid starts at 1.0, so this is not empty.\n            numerical_integral = 0.0\n            tail_integral = 0.0 # Or based on r_min, depends on problem def.\n        else:\n            g_vals = g_r(r_grid)\n            dU_vals = dU_lj_dr(r_grid)\n            \n            integrand = g_vals * dU_vals * (r_grid**3)\n            \n            # Use composite trapezoidal rule for (potentially) non-uniform grids\n            numerical_integral = np.trapz(integrand, x=r_grid)\n            \n            r_max = r_grid[-1]\n            tail_integral = tail_correction(r_max)\n        \n        total_integral = numerical_integral + tail_integral\n        \n        # Virial pressure equation\n        pressure = rho * T - (2.0 * np.pi * rho**2 / 3.0) * total_integral\n        return pressure\n\n    # --- Reference Calculation ---\n    r_ref = np.arange(0.30, 6.00 + 0.001 / 2, 0.001)\n    p_ref = calculate_pressure(r_ref, RHO, T_)\n    \n    # --- Test Suite ---\n    # Case 1: Uniform fine grid\n    case1_grid = np.arange(0.30, 5.00 + 0.002 / 2, 0.002)\n    \n    # Case 2: Uniform coarse grid\n    case2_grid = np.arange(0.30, 5.00 + 0.020 / 2, 0.020)\n\n    # Case 3: Mixed coarse short-range, fine long-range\n    case3_grid_p1 = np.arange(0.30, 1.20, 0.050)\n    case3_grid_p2 = np.arange(1.20, 5.00 + 0.005 / 2, 0.005)\n    case3_grid = np.concatenate((case3_grid_p1, case3_grid_p2))\n\n    # Case 4: Truncated core region\n    case4_grid = np.arange(1.00, 5.00 + 0.005 / 2, 0.005)\n\n    # Case 5: Mixed fine short-range, coarse long-range\n    case5_grid_p1 = np.arange(0.30, 2.00, 0.002)\n    case5_grid_p2 = np.arange(2.00, 5.00 + 0.050 / 2, 0.050)\n    case5_grid = np.concatenate((case5_grid_p1, case5_grid_p2))\n\n    test_grids = [case1_grid, case2_grid, case3_grid, case4_grid, case5_grid]\n    \n    results = []\n    for grid in test_grids:\n        p_case = calculate_pressure(grid, RHO, T_)\n        error = abs(p_case - p_ref)\n        results.append([round(p_case, 6), round(error, 6)])\n\n    # Format output as a string representation of a list of lists.\n    # The str() of a list adds spaces, matching the visual style of the example output.\n    # Joining these string representations with a comma produces the final format.\n    # Example: str([1.23, 4.56]) -> '[1.23, 4.56]'\n    # ','.join(['[1.23, 4.56]', '[7.89, 0.12]']) -> '[1.23, 4.56],[7.89, 0.12]'\n    # Final output: '[[1.23, 4.56],[7.89, 0.12]]'\n    final_output_str = f\"[{','.join(map(str, results))}]\"\n\n    print(final_output_str)\n\nsolve()\n```", "id": "3483653"}, {"introduction": "In many advanced modeling scenarios, we face an \"inverse problem\": given a desired structure, represented by a target $g_{\\mathrm{t}}(r)$, what interaction potential $u(r)$ will reproduce it? This practice introduces you to Iterative Boltzmann Inversion (IBI), a powerful technique for solving this problem and developing coarse-grained force fields. You will implement the IBI algorithm, using the potential of mean force approximation as a link between potential and structure, to systematically refine a potential that matches a target distribution [@problem_id:3483642].", "problem": "You are given the task of reconstructing an isotropic coarse-grained pair potential $u(r)$ from a target radial distribution function $g_{\\mathrm{t}}(r)$ for a simple liquid under reduced Lennard-Jones units (dimensionless). You will use Iterative Boltzmann Inversion (IBI), derived from the potential of mean force approximation, and evaluate convergence using both the radial distribution function $g(r)$ and the static structure factor $S(k)$. The program you write must be deterministic, fully self-contained, and run without any external input.\n\nFundamental base and definitions:\n- The radial distribution function $g(r)$ is defined as the ratio of the local pair density at separation $r$ to the ideal-gas reference density, for an isotropic homogeneous fluid at number density $\\rho$.\n- The total correlation function is $h(r) = g(r) - 1$.\n- The static structure factor $S(k)$ for isotropic systems is given by the three-dimensional Fourier transform of $h(r)$:\n$$\nS(k) = 1 + \\rho \\int_{0}^{\\infty} 4\\pi r^{2} h(r) \\frac{\\sin(kr)}{kr} \\, dr,\n$$\nwhere $k$ is the wave number and $\\sin(kr)/(kr)$ is the spherical Bessel function of order zero.\n- In the low-density limit, a well-tested and widely used approximation for the mapping from the pair potential to the radial distribution function is the potential of mean force approximation:\n$$\ng(r) \\approx \\exp\\!\\big(-\\beta u(r)\\big),\n$$\nwhere $\\beta = 1/(k_{\\mathrm{B}} T)$, $k_{\\mathrm{B}}$ is the Boltzmann constant, and $T$ is the absolute temperature. In reduced Lennard-Jones units, set $k_{\\mathrm{B}} = 1$, so $\\beta = 1/T$.\n\nIBI update rule and convergence assessment:\n- Starting from an initial guess $u^{(0)}(r)$, the Iterative Boltzmann Inversion (IBI) update with damping parameter $\\alpha \\in (0,1]$ is:\n$$\nu^{(n+1)}(r) = u^{(n)}(r) + \\alpha \\, \\frac{1}{\\beta} \\ln \\left( \\frac{g^{(n)}(r)}{g_{\\mathrm{t}}(r)} \\right),\n$$\nwhere $g^{(n)}(r)$ is the $g(r)$ predicted by the current potential $u^{(n)}(r)$ under the potential of mean force approximation $g^{(n)}(r)=\\exp\\!\\big(-\\beta u^{(n)}(r)\\big)$. The target structure factor is computed from $g_{\\mathrm{t}}(r)$ as\n$$\nS_{\\mathrm{t}}(k) = 1 + \\rho \\int_{0}^{\\infty} 4\\pi r^{2} \\left(g_{\\mathrm{t}}(r) - 1\\right) \\frac{\\sin(kr)}{kr} \\, dr.\n$$\nAt each iteration, you must compute $g^{(n)}(r)$ and $S^{(n)}(k)$ from $u^{(n)}(r)$. Convergence is declared when both the maximum absolute deviation in $g(r)$ over the discretized grid and the maximum absolute deviation in $S(k)$ over a set of wave numbers are below specified tolerances:\n$$\n\\|g^{(n)} - g_{\\mathrm{t}}\\|_{\\infty}  \\varepsilon_{g}, \\quad \\|S^{(n)} - S_{\\mathrm{t}}\\|_{\\infty}  \\varepsilon_{S}.\n$$\n\nDiscretization and numerical requirements:\n- Use a uniform radial grid $r \\in [r_{\\min}, r_{\\max}]$ with spacing $\\Delta r$. You must evaluate the integral for $S(k)$ numerically using the trapezoidal rule. For the spherical Bessel factor at $k=0$, use the limit $\\sin(kr)/(kr) \\to 1$ as $k \\to 0$.\n- To avoid numerical underflow or division by zero in logarithms, ensure $g(r)$ and $g_{\\mathrm{t}}(r)$ are strictly positive by clipping to a small positive lower bound where necessary.\n- All quantities are expressed in reduced Lennard-Jones units with $\\sigma = 1$, $\\epsilon = 1$, and $k_{\\mathrm{B}} = 1$, so all results are dimensionless.\n\nTarget data generation for testing:\n- The unknown ground-truth pair potential $u_{\\text{true}}(r)$ is the Weeks–Chandler–Andersen (WCA) repulsive potential:\n$$\nu_{\\text{true}}(r) =\n\\begin{cases}\n4\\epsilon \\left[\\left(\\dfrac{\\sigma}{r}\\right)^{12} - \\left(\\dfrac{\\sigma}{r}\\right)^{6}\\right] + \\epsilon,  r  r_{\\mathrm{m}}, \\\\\n0,  r \\ge r_{\\mathrm{m}},\n\\end{cases}\n$$\nwith $r_{\\mathrm{m}} = 2^{1/6}\\sigma$, $\\sigma = 1$, and $\\epsilon = 1$. The clean target radial distribution is $g_{\\mathrm{clean}}(r) = \\exp(-\\beta u_{\\text{true}}(r))$. For noisy cases, define $g_{\\mathrm{t}}(r) = \\max\\{g_{\\min}, g_{\\mathrm{clean}}(r) \\cdot (1 + \\eta(r))\\}$, where $\\eta(r)$ are independent Gaussian random variates with zero mean and specified standard deviation, and $g_{\\min}$ is a small positive lower bound.\n\nDiscretization parameters to use:\n- Radial grid: $r_{\\min} = 0.25$, $r_{\\max} = 4.00$, $\\Delta r = 0.005$.\n- Wave numbers: use the set $k \\in \\{0.0, 2.0, 5.0, 10.0\\}$.\n\nAlgorithmic tasks to implement:\n1. Construct the radial grid and evaluate $u_{\\text{true}}(r)$ and the clean $g_{\\mathrm{clean}}(r)$.\n2. For each test case, optionally add multiplicative noise to $g_{\\mathrm{clean}}(r)$ to obtain $g_{\\mathrm{t}}(r)$, ensuring positivity by clipping to $g_{\\min} = 10^{-12}$.\n3. Compute $S_{\\mathrm{t}}(k)$ from $g_{\\mathrm{t}}(r)$ using the numerical integral:\n$$\nS_{\\mathrm{t}}(k) \\approx 1 + \\rho \\int_{r_{\\min}}^{r_{\\max}} 4\\pi r^{2} \\left(g_{\\mathrm{t}}(r) - 1\\right) \\frac{\\sin(kr)}{kr} \\, dr,\n$$\nevaluated with the trapezoidal rule on the grid.\n4. Initialize $u^{(0)}(r) = 0$ for all $r$ and iterate the IBI update with damping parameter $\\alpha$ up to a maximum of $N_{\\max}$ iterations, using $g^{(n)}(r) = \\exp(-\\beta u^{(n)}(r))$ as the forward model. After each update, evaluate $g^{(n)}(r)$ and $S^{(n)}(k)$ and check the convergence criteria.\n5. For each test case, output a boolean indicating whether convergence was achieved within the maximum number of iterations.\n\nTest suite:\nYou must run your implementation on the following four test cases. For all cases, use $r_{\\min} = 0.25$, $r_{\\max} = 4.00$, $\\Delta r = 0.005$, $k \\in \\{0.0, 2.0, 5.0, 10.0\\}$, $\\sigma = 1$, $\\epsilon = 1$, and $g_{\\min} = 10^{-12}$.\n- Case A (happy path, exact mapping, undamped): $\\rho = 0.05$, $T = 1.0$ (so $\\beta = 1.0$), $\\alpha = 1.0$, $N_{\\max} = 5$, $\\varepsilon_{g} = 10^{-6}$, $\\varepsilon_{S} = 10^{-6}$, noise standard deviation $= 0.0$.\n- Case B (damped update, moderate density): $\\rho = 0.10$, $T = 1.0$, $\\alpha = 0.5$, $N_{\\max} = 50$, $\\varepsilon_{g} = 10^{-4}$, $\\varepsilon_{S} = 10^{-4}$, noise standard deviation $= 0.0$.\n- Case C (zero-density boundary for structure factor): $\\rho = 0.00$, $T = 1.0$, $\\alpha = 0.7$, $N_{\\max} = 5$, $\\varepsilon_{g} = 10^{-6}$, $\\varepsilon_{S} = 10^{-12}$, noise standard deviation $= 0.0$.\n- Case D (noisy target, strong damping, many iterations): $\\rho = 0.05$, $T = 1.0$, $\\alpha = 0.2$, $N_{\\max} = 200$, $\\varepsilon_{g} = 10^{-2}$, $\\varepsilon_{S} = 10^{-3}$, noise standard deviation $= 10^{-2}$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the test cases above, for example, \"[True,True,False,True]\". Each entry must be the boolean indicating whether the IBI converged within $N_{\\max}$ iterations under the specified tolerances for both $g(r)$ and $S(k)$.", "solution": "The problem presented is a well-posed and scientifically grounded exercise in computational materials science, specifically in the domain of coarse-grained modeling. It asks for the implementation of the Iterative Boltzmann Inversion (IBI) method to determine a pair potential $u(r)$ that reproduces a target radial distribution function $g_{\\mathrm{t}}(r)$. The problem simplifies the standard IBI procedure by replacing the computationally expensive molecular simulation step with a direct analytical relationship derived from the potential of mean force (PMF) approximation, $g(r) \\approx \\exp(-\\beta u(r))$. This turns the task into a deterministic numerical analysis problem, which is ideal for a self-contained programming challenge. The validation process, as per the specified protocol, confirms that the problem is complete, consistent, and solvable. We may therefore proceed with a detailed solution.\n\nThe core of the task is to implement an iterative algorithm. We begin by establishing the mathematical and numerical framework.\n\n**1. Discretization and Target Functions**\n\nAll functions of the radial separation $r$ must be discretized for numerical computation. We define a uniform grid of $N_r$ points, $\\{r_i\\}$, from $r_{\\min} = 0.25$ to $r_{\\max} = 4.00$ with a spacing of $\\Delta r = 0.005$. Similarly, the structure factor $S(k)$ will be evaluated at a discrete set of wave numbers, $k \\in \\{0.0, 2.0, 5.0, 10.0\\}$.\n\nThe ground-truth potential, from which the target data originates, is the Weeks–Chandler–Andersen (WCA) potential. In the specified reduced units ($\\sigma=1, \\epsilon=1$), this is:\n$$\nu_{\\text{true}}(r) =\n\\begin{cases}\n4 \\left(r^{-12} - r^{-6}\\right) + 1,  r  2^{1/6} \\\\\n0,  r \\ge 2^{1/6}\n\\end{cases}\n$$\nThe target radial distribution function, $g_{\\mathrm{t}}(r)$, is derived from this potential. For noiseless cases, it is given by the PMF approximation, $g_{\\mathrm{t}}(r) = \\exp(-\\beta u_{\\text{true}}(r))$, where $\\beta = 1/T$. For the noisy case, multiplicative Gaussian noise is introduced: $g_{\\mathrm{t}}(r) = g_{\\mathrm{clean}}(r) \\cdot (1 + \\eta(r))$, where $\\eta(r)$ is a random variate. To prevent numerical issues, $g_{\\mathrm{t}}(r)$ is clipped to a minimum value of $g_{\\min} = 10^{-12}$.\n\nFrom $g_{\\mathrm{t}}(r)$, we compute the target static structure factor, $S_{\\mathrm{t}}(k)$. The governing equation is the Fourier transform of the total correlation function, $h(r) = g(r) - 1$:\n$$\nS_{\\mathrm{t}}(k) = 1 + \\rho \\int_{r_{\\min}}^{r_{\\max}} 4\\pi r^{2} \\left(g_{\\mathrm{t}}(r) - 1\\right) \\frac{\\sin(kr)}{kr} \\, dr\n$$\nThe integral is truncated at $r_{\\max}$. It will be computed numerically using the trapezoidal rule, which approximates the integral of a function $f(x)$ discretized on a grid $\\{x_i\\}$ with spacing $\\Delta x$ as $\\Delta x \\left( \\frac{f(x_0)+f(x_N)}{2} + \\sum_{i=1}^{N-1} f(x_i) \\right)$. The spherical Bessel function term, $\\sin(kr)/(kr)$, requires special handling at $k=0$, where its limit is $1$.\n\n**2. Iterative Boltzmann Inversion (IBI) Algorithm**\n\nThe IBI algorithm iteratively refines a guess for the potential, $u^{(n)}(r)$, to match the target structure. The update rule is:\n$$\nu^{(n+1)}(r) = u^{(n)}(r) + \\alpha \\, \\frac{1}{\\beta} \\ln \\left( \\frac{g^{(n)}(r)}{g_{\\mathrm{t}}(r)} \\right)\n$$\nHere, $g^{(n)}(r)$ is the RDF produced by the potential $u^{(n)}(r)$. The crucial simplification in this problem is the use of the PMF approximation as the forward model: $g^{(n)}(r) = \\exp(-\\beta u^{(n)}(r))$. Substituting this into the update rule yields a direct recurrence relation for the potential:\n$$\nu^{(n+1)}(r) = u^{(n)}(r) + \\alpha \\frac{1}{\\beta} \\ln \\left( \\frac{\\exp(-\\beta u^{(n)}(r))}{g_{\\mathrm{t}}(r)} \\right)\n$$\n$$\nu^{(n+1)}(r) = u^{(n)}(r) + \\frac{\\alpha}{\\beta} \\left( -\\beta u^{(n)}(r) - \\ln(g_{\\mathrm{t}}(r)) \\right)\n$$\n$$\nu^{(n+1)}(r) = (1-\\alpha)u^{(n)}(r) - \\frac{\\alpha}{\\beta} \\ln(g_{\\mathrm{t}}(r))\n$$\nThis simplified form is what will be implemented. The iteration starts with an initial guess $u^{(0)}(r) = 0$.\n\n**3. The Iteration and Convergence Loop**\n\nFor each test case, the algorithm proceeds as follows:\n1.  Initialize the potential array $u^{(0)}(r)$ to all zeros.\n2.  Begin a loop for iterations $n$ from $0$ to $N_{\\max}-1$.\n3.  Inside the loop, first compute the current structural properties from $u^{(n)}(r)$:\n    -   $g^{(n)}(r) = \\exp(-\\beta u^{(n)}(r))$. A small positive clip, $g_{\\min}$, is applied for robustness.\n    -   $S^{(n)}(k)$ is computed from $g^{(n)}(r)$ using the same numerical integration procedure as for $S_{\\mathrm{t}}(k)$.\n4.  Check for convergence by calculating the maximum absolute deviations:\n    -   $\\|g^{(n)} - g_{\\mathrm{t}}\\|_{\\infty} = \\max_i |g^{(n)}(r_i) - g_{\\mathrm{t}}(r_i)|$\n    -   $\\|S^{(n)} - S_{\\mathrm{t}}\\|_{\\infty} = \\max_j |S^{(n)}(k_j) - S_{\\mathrm{t}}(k_j)|$\n5.  If both deviations are below their respective tolerances, $\\|g^{(n)} - g_{\\mathrm{t}}\\|_{\\infty}  \\varepsilon_{g}$ and $\\|S^{(n)} - S_{\\mathrm{t}}\\|_{\\infty}  \\varepsilon_{S}$, the process has converged. We record this outcome and terminate the loop for the current test case.\n6.  If not converged, update the potential to $u^{(n+1)}(r)$ using the derived recurrence relation.\n7.  If the loop completes all $N_{\\max}$ iterations without meeting the convergence criteria, the process is considered not converged for that test case.\n\nThis structured, principle-based approach ensures that all aspects of the problem statement are addressed correctly and implemented in a verifiable manner. The final program will encapsulate this logic, executing it for each of the four specified test cases and reporting the convergence outcome.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the IBI simulation for all test cases and print results.\n    \"\"\"\n\n    # Test cases as specified in the problem statement.\n    test_cases = [\n        # Case A: happy path, exact mapping, undamped\n        {'rho': 0.05, 'T': 1.0, 'alpha': 1.0, 'N_max': 5, 'eps_g': 1e-6, 'eps_S': 1e-6, 'noise_std': 0.0, 'case_id': 'A'},\n        # Case B: damped update, moderate density\n        {'rho': 0.10, 'T': 1.0, 'alpha': 0.5, 'N_max': 50, 'eps_g': 1e-4, 'eps_S': 1e-4, 'noise_std': 0.0, 'case_id': 'B'},\n        # Case C: zero-density boundary for structure factor\n        {'rho': 0.00, 'T': 1.0, 'alpha': 0.7, 'N_max': 5, 'eps_g': 1e-6, 'eps_S': 1e-12, 'noise_std': 0.0, 'case_id': 'C'},\n        # Case D: noisy target, strong damping, many iterations\n        {'rho': 0.05, 'T': 1.0, 'alpha': 0.2, 'N_max': 200, 'eps_g': 1e-2, 'eps_S': 1e-3, 'noise_std': 1e-2, 'case_id': 'D'},\n    ]\n\n    results = []\n    # Seed the random number generator for deterministic noise in Case D\n    np.random.seed(0)\n\n    for params in test_cases:\n        converged = run_ibi_simulation(**params)\n        results.append(converged)\n\n    # Format and print the final output as specified.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef wca_potential(r, sigma=1.0, epsilon=1.0):\n    \"\"\"\n    Calculates the Weeks-Chandler-Andersen (WCA) potential.\n    \"\"\"\n    r_m = 2**(1/6) * sigma\n    u = np.zeros_like(r)\n    mask = r  r_m\n    r_inv6 = (sigma / r[mask])**6\n    u[mask] = 4 * epsilon * (r_inv6**2 - r_inv6) + epsilon\n    return u\n\ndef sinc_unnormalized(x):\n    \"\"\"\n    Computes the unnormalized sinc function sin(x)/x.\n    Handles the case x=0 where the limit is 1.\n    \"\"\"\n    x = np.asanyarray(x)\n    return np.divide(np.sin(x), x, out=np.ones_like(x, dtype=float), where=x != 0)\n\ndef calculate_S_k(g, r, k_values, rho):\n    \"\"\"\n    Calculates the static structure factor S(k) from g(r) via numerical integration.\n    \"\"\"\n    h = g - 1\n    S = np.zeros_like(k_values, dtype=float)\n    for i, k in enumerate(k_values):\n        integrand = 4 * np.pi * r**2 * h * sinc_unnormalized(k * r)\n        integral = np.trapz(integrand, r)\n        S[i] = 1 + rho * integral\n    return S\n\ndef run_ibi_simulation(rho, T, alpha, N_max, eps_g, eps_S, noise_std, case_id):\n    \"\"\"\n    Runs a single Iterative Boltzmann Inversion simulation for a given set of parameters.\n    \"\"\"\n    # Universal constants and grid setup\n    sigma = 1.0\n    epsilon = 1.0\n    g_min = 1e-12\n    r_min, r_max, dr = 0.25, 4.00, 0.005\n    r_grid = np.arange(r_min, r_max + dr / 2, dr)\n    k_values = np.array([0.0, 2.0, 5.0, 10.0])\n    beta = 1.0 / T\n\n    # 1. Generate target data\n    u_true = wca_potential(r_grid, sigma, epsilon)\n    g_clean = np.exp(-beta * u_true)\n\n    if noise_std  0:\n        noise = np.random.normal(0, noise_std, size=r_grid.shape)\n        g_target = g_clean * (1 + noise)\n    else:\n        g_target = g_clean\n\n    g_target = np.maximum(g_min, g_target)\n\n    # 2. Compute target structure factor\n    S_target = calculate_S_k(g_target, r_grid, k_values, rho)\n    \n    # Pre-calculate term for the IBI update for efficiency\n    log_g_target = np.log(g_target)\n    \n    # 3. IBI iteration\n    u_n = np.zeros_like(r_grid)\n    converged = False\n\n    for _ in range(N_max):\n        # Calculate current g(r) and S(k) from u_n\n        g_n = np.maximum(g_min, np.exp(-beta * u_n))\n        S_n = calculate_S_k(g_n, r_grid, k_values, rho)\n\n        # Check for convergence\n        dev_g = np.max(np.abs(g_n - g_target))\n        dev_S = np.max(np.abs(S_n - S_target))\n\n        if dev_g  eps_g and dev_S  eps_S:\n            converged = True\n            break\n        \n        # IBI update step using the simplified analytical form\n        u_n = (1 - alpha) * u_n - (alpha / beta) * log_g_target\n    \n    return converged\n\nif __name__ == \"__main__\":\n    solve()\n\n```", "id": "3483642"}]}