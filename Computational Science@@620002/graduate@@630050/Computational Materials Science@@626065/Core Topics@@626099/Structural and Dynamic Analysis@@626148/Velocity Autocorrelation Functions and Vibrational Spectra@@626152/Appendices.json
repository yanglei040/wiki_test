{"hands_on_practices": [{"introduction": "This exercise builds a foundational understanding of the velocity autocorrelation function (VACF) by analyzing the damped harmonic oscillator, an exactly solvable model. By deriving the VACF and its corresponding power spectrum from the Langevin equation, you will directly observe how a microscopic damping parameter translates into a macroscopic spectral line shape. This practice provides a crucial theoretical bridge between the underlying dynamics of a particle and the vibrational spectrum it produces. [@problem_id:3501925]", "problem": "Consider a single classical particle of unit mass undergoing damped harmonic motion in contact with a thermal bath at absolute temperature $T$. Its displacement $x(t)$ satisfies the linear stochastic differential equation\n$$\n\\ddot{x}(t)+2\\gamma\\,\\dot{x}(t)+\\omega_{0}^{2}\\,x(t)=\\eta(t),\n$$\nwhere $\\gamma>0$ is the damping coefficient, $\\omega_{0}>0$ is the bare harmonic frequency, and $\\eta(t)$ is a stationary zero-mean Gaussian white noise representing the thermal bath. Assume the fluctuation-dissipation relation holds in equilibrium, so that the noise autocorrelation function is\n$$\n\\langle \\eta(t)\\,\\eta(t')\\rangle = 4\\,\\gamma\\,k_{B}\\,T\\,\\delta(t-t'),\n$$\nwith $k_{B}$ the Boltzmann constant and $\\delta(t)$ the Dirac delta function. Define the velocity $v(t)\\equiv \\dot{x}(t)$, the velocity autocorrelation function (VACF) $C_{v}(t)\\equiv \\langle v(t)\\,v(0)\\rangle$, and its two-sided power spectrum $S_{vv}(\\omega)\\equiv \\int_{-\\infty}^{\\infty} C_{v}(t) \\exp(-i\\omega t)\\,dt$. Use the Fourier transform convention\n$$\nf(\\omega)=\\int_{-\\infty}^{\\infty} f(t)\\exp(-i\\omega t)\\,dt,\\qquad f(t)=\\frac{1}{2\\pi}\\int_{-\\infty}^{\\infty} f(\\omega)\\exp(i\\omega t)\\,d\\omega.\n$$\nStarting only from these definitions and the given equation of motion, and assuming the underdamped regime $0<\\gamma<\\omega_{0}$, do the following:\n\n1. Derive a closed-form expression for $C_{v}(t)$ in equilibrium for all real $t$.\n2. Derive a closed-form expression for the velocity power spectrum $S_{vv}(\\omega)$ in terms of $\\gamma$, $\\omega_{0}$, $k_{B}$, $T$, and $\\omega$.\n3. Using your spectral result, identify the line shape in the vicinity of $\\omega\\approx \\omega_{0}$, determine its half-width at half-maximum in angular-frequency units, and explain how $\\gamma$ encodes the strength of anharmonic scattering in a solid through spectral broadening and the associated vibrational lifetime.\n\nYour final boxed answer must be the closed-form analytic expression you obtain for $S_{vv}(\\omega)$, expressed as a function of $\\omega$, $\\gamma$, $\\omega_{0}$, $k_{B}$, and $T$. Do not include any units in the boxed expression. No numerical evaluation or rounding is required.", "solution": "The problem as stated is a standard, well-posed problem in statistical physics and is therefore deemed **valid**. We may proceed with the solution.\n\nThe problem requires a three-part derivation concerning a damped harmonic oscillator described by the Langevin equation. We will first derive the velocity power spectrum $S_{vv}(\\omega)$, then the velocity autocorrelation function (VACF) $C_{v}(t)$, and finally analyze the spectral line shape.\n\n**Part 2: Derivation of the Velocity Power Spectrum $S_{vv}(\\omega)$**\n\nWe begin by applying the specified Fourier transform to the Langevin equation of motion:\n$$\n\\ddot{x}(t) + 2\\gamma\\dot{x}(t) + \\omega_0^2 x(t) = \\eta(t)\n$$\nUsing the convention that the Fourier transform of a time derivative $\\dot{f}(t)$ is $i\\omega f(\\omega)$, the equation in the frequency domain becomes:\n$$\n(-\\omega^2 + 2i\\gamma\\omega + \\omega_0^2) x(\\omega) = \\eta(\\omega)\n$$\nwhere $x(\\omega)$ and $\\eta(\\omega)$ are the Fourier transforms of $x(t)$ and $\\eta(t)$, respectively. We can solve for $x(\\omega)$:\n$$\nx(\\omega) = \\frac{\\eta(\\omega)}{\\omega_0^2 - \\omega^2 + 2i\\gamma\\omega}\n$$\nThe velocity $v(t)$ is defined as $v(t) = \\dot{x}(t)$. Its Fourier transform is $v(\\omega) = i\\omega x(\\omega)$. Substituting the expression for $x(\\omega)$ yields:\n$$\nv(\\omega) = \\frac{i\\omega}{\\omega_0^2 - \\omega^2 + 2i\\gamma\\omega} \\eta(\\omega)\n$$\nThis relation is of the form $v(\\omega) = \\chi_v(\\omega) \\eta(\\omega)$, where $\\chi_v(\\omega)$ is the velocity response function:\n$$\n\\chi_v(\\omega) = \\frac{i\\omega}{\\omega_0^2 - \\omega^2 + 2i\\gamma\\omega}\n$$\nAccording to the Wiener-Khinchin theorem and linear response theory, the power spectrum of the output signal, $S_{vv}(\\omega)$, is related to the power spectrum of the input noise, $S_{\\eta\\eta}(\\omega)$, by the squared modulus of the response function:\n$$\nS_{vv}(\\omega) = |\\chi_v(\\omega)|^2 S_{\\eta\\eta}(\\omega)\n$$\nThe noise power spectrum $S_{\\eta\\eta}(\\omega)$ is the Fourier transform of the noise autocorrelation function $\\langle \\eta(t)\\eta(0) \\rangle$. Given $\\langle \\eta(t)\\eta(t') \\rangle = 4\\gamma k_B T \\delta(t-t')$, we have:\n$$\nS_{\\eta\\eta}(\\omega) = \\int_{-\\infty}^{\\infty} e^{-i\\omega t} \\langle \\eta(t)\\eta(0) \\rangle dt = \\int_{-\\infty}^{\\infty} e^{-i\\omega t} \\left(4\\gamma k_B T \\delta(t)\\right) dt = 4\\gamma k_B T\n$$\nNow, we calculate the squared modulus of the response function:\n$$\n|\\chi_v(\\omega)|^2 = \\left| \\frac{i\\omega}{\\omega_0^2 - \\omega^2 + 2i\\gamma\\omega} \\right|^2 = \\frac{|i\\omega|^2}{|\\omega_0^2 - \\omega^2 + 2i\\gamma\\omega|^2} = \\frac{\\omega^2}{(\\omega_0^2 - \\omega^2)^2 + (2\\gamma\\omega)^2} = \\frac{\\omega^2}{(\\omega_0^2 - \\omega^2)^2 + 4\\gamma^2\\omega^2}\n$$\nSubstituting these results back into the equation for $S_{vv}(\\omega)$, we obtain the final expression for the velocity power spectrum:\n$$\nS_{vv}(\\omega) = \\frac{4\\gamma k_B T \\omega^2}{(\\omega_0^2 - \\omega^2)^2 + 4\\gamma^2\\omega^2}\n$$\n\n**Part 1: Derivation of the Velocity Autocorrelation Function $C_v(t)$**\n\nThe VACF, $C_v(t)$, is the inverse Fourier transform of $S_{vv}(\\omega)$. However, we can also derive it using the regression hypothesis, which states that the time-evolution of the equilibrium correlation function mimics the relaxation of an induced macroscopic disturbance. For $t>0$, $C_v(t) = \\langle v(t)v(0) \\rangle$ is found by solving the homogeneous equation of motion for $v(t)$ with initial conditions averaged over the equilibrium ensemble. For this system, this means $\\langle v(0)^2 \\rangle = k_B T$ (from equipartition, with mass $m=1$) and $\\langle x(0)v(0) \\rangle = 0$. We thus solve the homogeneous equation $\\ddot{x} + 2\\gamma\\dot{x} + \\omega_0^2 x = 0$ with initial conditions $x(0)=0$ and $v(0)=v_0$.\n\nThe characteristic equation is $r^2+2\\gamma r+\\omega_0^2=0$, with roots $r=-\\gamma \\pm i\\omega_1$, where $\\omega_1 \\equiv \\sqrt{\\omega_0^2 - \\gamma^2}$ is real in the underdamped regime ($0 < \\gamma < \\omega_0$). The solution for $x(t)$ that satisfies $x(0)=0$ is $x(t) = B e^{-\\gamma t}\\sin(\\omega_1 t)$. The corresponding velocity is $v(t) = \\dot{x}(t) = B e^{-\\gamma t}(-\\gamma \\sin(\\omega_1 t) + \\omega_1 \\cos(\\omega_1 t))$. The condition $v(0)=v_0$ gives $v_0 = B\\omega_1$, so $B = v_0/\\omega_1$. The subsequent velocity is:\n$$\nv(t) = v_0 e^{-\\gamma t}\\left(\\cos(\\omega_1 t) - \\frac{\\gamma}{\\omega_1}\\sin(\\omega_1 t)\\right)\n$$\nTo find $C_v(t)$, we replace $v_0^2$ with its thermal average $\\langle v(0)^2 \\rangle = k_B T$:\n$$\nC_v(t) = k_B T e^{-\\gamma t}\\left(\\cos(\\omega_1 t) - \\frac{\\gamma}{\\omega_1}\\sin(\\omega_1 t)\\right), \\quad \\text{for } t > 0\n$$\nSince $C_v(t)$ is an even function of time, we generalize for all real $t$ using the absolute value $|t|$:\n$$\nC_v(t) = k_B T e^{-\\gamma|t|}\\left(\\cos(\\omega_1 t) - \\frac{\\gamma}{\\omega_1}\\sin(\\omega_1 |t|)\\right)\n$$\n\n**Part 3: Spectral Line Shape Analysis**\n\nTo analyze the line shape of $S_{vv}(\\omega)$ near the resonance $\\omega \\approx \\omega_0$, we make the near-resonance approximation. We rewrite the denominator term $\\omega_0^2 - \\omega^2 = (\\omega_0-\\omega)(\\omega_0+\\omega)$ and approximate $\\omega_0+\\omega \\approx 2\\omega_0$. The numerator term $\\omega^2$ is approximated as $\\omega_0^2$.\n$$\nS_{vv}(\\omega) \\approx \\frac{4\\gamma k_B T \\omega_0^2}{((\\omega_0-\\omega)2\\omega_0)^2 + 4\\gamma^2\\omega_0^2} = \\frac{4\\gamma k_B T \\omega_0^2}{4\\omega_0^2(\\omega-\\omega_0)^2 + 4\\gamma^2\\omega_0^2} = \\frac{k_B T \\gamma}{(\\omega-\\omega_0)^2 + \\gamma^2}\n$$\nThis expression describes a Lorentzian line shape centered at $\\omega_0$. Its peak value (at $\\omega = \\omega_0$) is $S_{peak} = k_B T / \\gamma$. The half-width at half-maximum (HWHM) is the displacement $|\\omega-\\omega_0|$ where the value is $S_{peak}/2$.\n$$\n\\frac{k_B T \\gamma}{(\\omega-\\omega_0)^2 + \\gamma^2} = \\frac{1}{2}\\frac{k_B T}{\\gamma} \\implies 2\\gamma^2 = (\\omega-\\omega_0)^2 + \\gamma^2 \\implies |\\omega-\\omega_0| = \\gamma\n$$\nThe HWHM is $\\gamma$.\n\nIn the context of solid-state physics, this model connects microscopic scattering to a macroscopic observable. The phonons (quantized lattice vibrations) in a perfect harmonic crystal have infinite lifetimes. Anharmonic terms in the interatomic potential cause phonon-phonon scattering, which limits their lifetimes. The damping coefficient $\\gamma$ in the Langevin model represents the strength of this anharmonic scattering. The derived spectral broadening (HWHM = $\\gamma$) is a direct consequence of these scattering events. The vibrational lifetime $\\tau$ is the decay constant of the VACF, $\\tau = 1/\\gamma$. The full width at half-maximum (FWHM = $2\\gamma$) of the spectral peak is thus inversely proportional to the vibrational lifetime, $FWHM = 2/\\tau$. Therefore, stronger anharmonicity (larger $\\gamma$) causes a shorter lifetime and a broader peak in the measured vibrational spectrum.", "answer": "$$\n\\boxed{\\frac{4\\gamma k_{B} T \\omega^{2}}{\\left(\\omega_{0}^{2} - \\omega^{2}\\right)^{2} + 4\\gamma^{2}\\omega^{2}}}\n$$", "id": "3501925"}, {"introduction": "Moving from pure theory to a key practical application, this exercise guides you in calculating the self-diffusion coefficient $D$ via the Green-Kubo relation. A central challenge in computational physics is that simulations produce data of finite length, leading to a truncated VACF. You will learn a standard technique to overcome this by fitting a physically-motivated functional form to the tail of the VACF and analytically extrapolating its contribution to the integral, a skill essential for obtaining accurate transport properties. [@problem_id:3501959]", "problem": "You are given truncated numerical samples of the velocity autocorrelation function (VACF) from Molecular Dynamics (MD) simulations. The VACF is defined as the ensemble average $C_v(t) = \\langle \\mathbf{v}(t)\\cdot \\mathbf{v}(0) \\rangle$, where $\\mathbf{v}(t)$ is the particle velocity at time $t$. Your task is to design and implement an estimator for the self-diffusion coefficient $D$ that accounts for the missing long-time tail by fitting a physically motivated functional form to the accessible tail segment and analytically extrapolating the contribution beyond the truncation time.\n\nThe estimator must be built on first principles and legitimate, broadly accepted definitions in computational materials science. It must use a physically motivated tail model, such as the Kohlrausch–Williams–Watts (KWW) stretched exponential $C_{\\mathrm{tail}}(t) = A \\exp\\!\\big(-(t/\\tau)^{\\beta}\\big)$, with parameters $A$, $\\tau$, and $\\beta$ constrained to physically meaningful domains. The model justification must rely on physical reasoning about relaxation processes and vibrational spectra, not on rote formula memorization.\n\nImplement the estimator under the following requirements:\n- Use the truncated discrete VACF samples $\\{C_v(t_n)\\}_{n=0}^{N}$ with uniform sampling interval $\\Delta t$ and truncation time $t_{\\max}$, and treat the VACF as a scalar correlation of the full velocity vector $\\mathbf{v}(t)$ in three spatial dimensions.\n- Integrate the available VACF numerically over $[0,t_{\\max}]$ and add an analytic extrapolation of the remainder $\\int_{t_{\\max}}^{\\infty} C_{\\mathrm{tail}}(t)\\,\\mathrm{d}t$ based on a fit to the accessible tail segment. Constrain the fit parameters to $A \\ge 0$, $\\tau > 0$, and $0 < \\beta \\le 1$, and ensure the estimator is robust when the fit is ill-posed (e.g., too few tail points), in which case default the tail contribution to zero.\n- Express all final reported diffusion coefficients $D$ in $\\mathrm{m^2/s}$.\n\nDesign for testability as follows. Your program must construct the VACF test data internally using physically plausible synthetic models, without reading any external input. Use Boltzmann’s constant $k_{\\mathrm{B}} = 1.380649\\times 10^{-23}\\,\\mathrm{J/K}$, temperature $T = 300\\,\\mathrm{K}$, and particle mass $m = 1.0\\times 10^{-24}\\,\\mathrm{kg}$, so that the initial VACF level is $C_0 = 3 k_{\\mathrm{B}} T / m$.\n\nProvide a test suite with three cases:\n- Case $A$ (general, “happy path”): A stretched-exponential VACF $C_v(t) = C_0 \\exp\\!\\big(-(t/\\tau)^{\\beta}\\big)$ sampled with $\\Delta t = 2.0\\times 10^{-14}\\,\\mathrm{s}$ up to $t_{\\max} = 4.0\\times 10^{-12}\\,\\mathrm{s}$, with parameters $\\tau = 1.5\\times 10^{-12}\\,\\mathrm{s}$ and $\\beta = 0.65$ and additive zero-mean Gaussian noise with standard deviation equal to $0.01$ times the noiseless $C_v(t)$ at each $t$.\n- Case $B$ (boundary, short truncation): Same functional form as Case $A$ but sampled with $\\Delta t = 1.0\\times 10^{-14}\\,\\mathrm{s}$ up to $t_{\\max} = 3.0\\times 10^{-13}\\,\\mathrm{s}$, and noise at $0.05$ relative level.\n- Case $C$ (edge, two-component relaxation with vibrational oscillations): A sum of a long-time stretched-exponential tail and a short-time damped vibrational oscillation,\n  $$C_v(t) = f_{\\mathrm{kww}} C_0 \\exp\\!\\big(-(t/\\tau_{\\mathrm{long}})^{\\beta_{\\mathrm{long}}}\\big) + f_{\\mathrm{osc}} C_0 \\cos(\\omega t)\\exp\\!\\big(-t/\\tau_{\\mathrm{osc}}\\big),$$\n  with $f_{\\mathrm{kww}} = 0.5$, $f_{\\mathrm{osc}} = 0.5$, $\\tau_{\\mathrm{long}} = 2.0\\times 10^{-12}\\,\\mathrm{s}$, $\\beta_{\\mathrm{long}} = 0.60$, $\\omega = 2\\pi\\times 1.0\\times 10^{12}\\,\\mathrm{rad/s}$, and $\\tau_{\\mathrm{osc}} = 4.0\\times 10^{-13}\\,\\mathrm{s}$, sampled with $\\Delta t = 2.0\\times 10^{-14}\\,\\mathrm{s}$ up to $t_{\\max} = 5.0\\times 10^{-12}\\,\\mathrm{s}$, with noise at $0.02$ relative level.\n\nYour program should fit the stretched-exponential tail using the last portion of the truncated data (choose a fraction of the last available times so that the fit targets the long-time decay), compute the numerical integral of the truncated VACF over $[0,t_{\\max}]$, add the analytic tail integral, and convert to the diffusion coefficient in three dimensions. All floating-point outputs must be reported in $\\mathrm{m^2/s}$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the diffusion estimates for the three cases as a comma-separated list enclosed in square brackets, for example $[d_A,d_B,d_C]$, where $d_A$, $d_B$, and $d_C$ are decimal floating-point numbers in $\\mathrm{m^2/s}$ printed in scientific notation with six digits after the decimal point.", "solution": "The problem is valid. It is scientifically grounded in the principles of statistical mechanics, specifically the Green-Kubo relations for transport coefficients. The problem is well-posed, objective, and provides a complete set of parameters and constraints for constructing a unique and verifiable solution.\n\nThe self-diffusion coefficient, $D$, of a particle in a three-dimensional system is fundamentally linked to the time correlation of its velocity fluctuations. This relationship is formally expressed by the Green-Kubo formula:\n$$\nD = \\frac{1}{3} \\int_{0}^{\\infty} C_v(t) \\, \\mathrm{d}t\n$$\nwhere $C_v(t)$ is the velocity autocorrelation function (VACF), defined as the ensemble average $C_v(t) = \\langle \\mathbf{v}(t) \\cdot \\mathbf{v}(0) \\rangle$. The factor of $\\frac{1}{3}$ arises from considering diffusion in three isotropic spatial dimensions. The initial value of the VACF, $C_v(0) = \\langle |\\mathbf{v}(0)|^2 \\rangle$, is determined by the equipartition theorem, which states that the average kinetic energy is $\\frac{3}{2} k_{\\mathrm{B}} T$. This gives $C_v(0) = \\frac{3 k_{\\mathrm{B}} T}{m}$, where $k_{\\mathrm{B}}$ is Boltzmann's constant, $T$ is the absolute temperature, and $m$ is the particle mass.\n\nMolecular Dynamics (MD) simulations provide the VACF as a discrete time series $\\{C_v(t_n)\\}$ sampled at intervals $\\Delta t$ up to a finite truncation time $t_{\\max}$. The primary challenge is that the integral for $D$ extends to infinity, whereas the data is truncated. A naive approach of integrating only up to $t_{\\max}$ systematically underestimates $D$ by neglecting the contribution from the long-time tail of the correlation function.\n\nTo address this, we partition the integral into two parts:\n$$\n\\int_{0}^{\\infty} C_v(t) \\, \\mathrm{d}t = \\int_{0}^{t_{\\max}} C_v(t) \\, \\mathrm{d}t + \\int_{t_{\\max}}^{\\infty} C_v(t) \\, \\mathrm{d}t\n$$\nThe first term, the integral over the known data range $[0, t_{\\max}]$, can be computed numerically. Given the uniformly sampled data, the trapezoidal rule is a suitable and accurate method:\n$$\nI_{\\text{num}} = \\int_{0}^{t_{\\max}} C_v(t) \\, \\mathrm{d}t \\approx \\Delta t \\left( \\frac{C_v(t_0) + C_v(t_N)}{2} + \\sum_{n=1}^{N-1} C_v(t_n) \\right)\n$$\nwhere $t_n = n \\Delta t$ and $t_N = t_{\\max}$.\n\nThe second term, the integral from $t_{\\max}$ to infinity, requires a model for the asymptotic decay of the VACF. In many complex and disordered systems, such as supercooled liquids or glasses, relaxation processes do not follow a simple exponential decay. Instead, they exhibit a distribution of relaxation timescales, which is well-captured by the Kohlrausch–Williams–Watts (KWW) or \"stretched exponential\" function. This is a physically motivated choice for the tail behavior:\n$$\nC_{\\text{tail}}(t) = A \\exp\\left(-\\left(\\frac{t}{\\tau}\\right)^{\\beta}\\right)\n$$\nThe parameters of this model are the amplitude $A$, a characteristic relaxation time $\\tau$, and a stretching exponent $\\beta$. The constraints are $A \\ge 0$, $\\tau > 0$, and $0 < \\beta \\le 1$. The case $\\beta=1$ corresponds to a simple exponential (Debye) relaxation, while smaller values of $\\beta$ indicate a broader distribution of relaxation rates.\n\nThe estimator proceeds as follows:\n1.  A fraction of the data at the end of the time series (the accessible tail) is selected.\n2.  A non-linear least-squares fitting procedure is used to determine the optimal parameters $(A, \\tau, \\beta)$ that best fit the KWW model to this segment of the VACF data, subject to the physical constraints.\n3.  If this fit is successful, the integral of the tail contribution, $I_{\\text{tail}}$, is calculated analytically using the fitted parameters:\n    $$\n    I_{\\text{tail}} = \\int_{t_{\\max}}^{\\infty} A \\exp\\left(-\\left(\\frac{t}{\\tau}\\right)^{\\beta}\\right) \\, \\mathrm{d}t\n    $$\n    To solve this integral, we perform a change of variables. Let $u = (t/\\tau)^{\\beta}$. Then $t = \\tau u^{1/\\beta}$ and $\\mathrm{d}t = \\frac{\\tau}{\\beta} u^{(1/\\beta)-1} \\mathrm{d}u$. The lower limit of integration becomes $u_{\\min} = (t_{\\max}/\\tau)^{\\beta}$. The integral transforms to:\n    $$\n    I_{\\text{tail}} = A \\int_{(t_{\\max}/\\tau)^{\\beta}}^{\\infty} e^{-u} \\left(\\frac{\\tau}{\\beta} u^{(1/\\beta)-1}\\right) \\, \\mathrm{d}u = \\frac{A\\tau}{\\beta} \\int_{(t_{\\max}/\\tau)^{\\beta}}^{\\infty} u^{(1/\\beta)-1} e^{-u} \\, \\mathrm{d}u\n    $$\n    This integral is the definition of the upper incomplete gamma function, $\\Gamma(s, x) = \\int_x^{\\infty} t^{s-1} e^{-t} \\, \\mathrm{d}t$. With $s = 1/\\beta$ and $x = (t_{\\max}/\\tau)^{\\beta}$, the analytical result is:\n    $$\n    I_{\\text{tail}} = \\frac{A\\tau}{\\beta} \\Gamma\\left(\\frac{1}{\\beta}, \\left(\\frac{t_{\\max}}{\\tau}\\right)^{\\beta}\\right)\n    $$\n4.  The total integral is the sum $I_{\\text{total}} = I_{\\text{num}} + I_{\\text{tail}}$.\n5.  The final estimate for the diffusion coefficient is $D = \\frac{1}{3} I_{\\text{total}}$.\n6.  For robustness, if the fitting procedure fails (e.g., due to insufficient data in the tail segment or poor convergence), the tail contribution $I_{\\text{tail}}$ is set to zero. This ensures the estimator always returns a value, albeit a potentially less accurate one, corresponding to a simple truncation of the integral.\n\nThe implementation will synthesize VACF data for three test cases, apply this estimation procedure to each, and report the resulting diffusion coefficients. The synthetic data includes realistic features such as noise and multi-component relaxation to test the robustness and applicability of the method.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import curve_fit\nfrom scipy.special import gamma, gammaincc\n\ndef solve():\n    \"\"\"\n    Calculates the self-diffusion coefficient from synthetic VACF data.\n    The estimator combines numerical integration of the available data with an\n    analytical extrapolation of the long-time tail, modeled as a\n    Kohlrausch-Williams-Watts (KWW) stretched exponential function.\n    \"\"\"\n\n    k_B = 1.380649e-23  # Boltzmann constant in J/K\n\n    test_cases = [\n        {\n            \"name\": \"Case A\",\n            \"T\": 300.0,\n            \"m\": 1.0e-24,\n            \"dt\": 2.0e-14,\n            \"t_max\": 4.0e-12,\n            \"noise_level\": 0.01,\n            \"model_type\": \"kww\",\n            \"params\": {\"tau\": 1.5e-12, \"beta\": 0.65},\n        },\n        {\n            \"name\": \"Case B\",\n            \"T\": 300.0,\n            \"m\": 1.0e-24,\n            \"dt\": 1.0e-14,\n            \"t_max\": 3.0e-13,\n            \"noise_level\": 0.05,\n            \"model_type\": \"kww\",\n            \"params\": {\"tau\": 1.5e-12, \"beta\": 0.65},\n        },\n        {\n            \"name\": \"Case C\",\n            \"T\": 300.0,\n            \"m\": 1.0e-24,\n            \"dt\": 2.0e-14,\n            \"t_max\": 5.0e-12,\n            \"noise_level\": 0.02,\n            \"model_type\": \"kww_osc\",\n            \"params\": {\n                \"f_kww\": 0.5,\n                \"f_osc\": 0.5,\n                \"tau_long\": 2.0e-12,\n                \"beta_long\": 0.60,\n                \"omega\": 2.0 * np.pi * 1.0e12,\n                \"tau_osc\": 4.0e-13,\n            },\n        },\n    ]\n\n    results = []\n    rng = np.random.default_rng(seed=42)  # For reproducible noise\n\n    for case in test_cases:\n        # 1. Generate synthetic VACF data\n        T, m, dt, t_max = case[\"T\"], case[\"m\"], case[\"dt\"], case[\"t_max\"]\n        C0 = 3.0 * k_B * T / m\n        t_array = np.arange(0, t_max + dt / 2.0, dt)\n        \n        if case[\"model_type\"] == \"kww\":\n            p = case[\"params\"]\n            vacf_noiseless = C0 * np.exp(-((t_array / p[\"tau\"]) ** p[\"beta\"]))\n        elif case[\"model_type\"] == \"kww_osc\":\n            p = case[\"params\"]\n            kww_part = p[\"f_kww\"] * C0 * np.exp(-((t_array / p[\"tau_long\"]) ** p[\"beta_long\"]))\n            osc_part = p[\"f_osc\"] * C0 * np.cos(p[\"omega\"] * t_array) * np.exp(-t_array / p[\"tau_osc\"])\n            vacf_noiseless = kww_part + osc_part\n        \n        noise = rng.normal(loc=0.0, scale=case[\"noise_level\"] * np.abs(vacf_noiseless))\n        vacf_samples = vacf_noiseless + noise\n\n        # 2. Numerical integration of the available VACF\n        numerical_integral = np.trapz(vacf_samples, x=t_array)\n\n        # 3. Fit the tail and calculate the analytical tail integral\n        tail_integral = 0.0\n        \n        # Select the last 40% of the data for fitting the tail\n        tail_fraction = 0.40\n        tail_start_index = int((1.0 - tail_fraction) * len(t_array))\n        \n        # Ensure there are enough points to fit (more than number of parameters)\n        if len(t_array) - tail_start_index > 3:\n            t_tail = t_array[tail_start_index:]\n            vacf_tail = vacf_samples[tail_start_index:]\n\n            def kww_func(t, A, tau, beta):\n                return A * np.exp(-((t / tau) ** beta))\n\n            # Bounds for the fitting parameters\n            bounds = ([0, 1e-16, 1e-6], [np.inf, np.inf, 1.0])\n            \n            # Initial guess for the parameters\n            A_guess = vacf_tail[0] if vacf_tail[0] > 0 else 1.0\n            tau_guess = t_max\n            beta_guess = 0.7\n            p0 = [A_guess, tau_guess, beta_guess]\n            \n            try:\n                popt, _ = curve_fit(kww_func, t_tail, vacf_tail, p0=p0, bounds=bounds, maxfev=5000)\n                A_fit, tau_fit, beta_fit = popt\n\n                # 4. Calculate the analytical integral of the fitted tail\n                # Integral from t_max to infinity of A*exp(-(t/tau)^beta) dt\n                s = 1.0 / beta_fit\n                x = (t_max / tau_fit) ** beta_fit\n                \n                # tail_integral = (A_fit * tau_fit / beta_fit) * Gamma(s, x)\n                # scipy.special.gammaincc(s,x) is Gamma(s,x)/Gamma(s)\n                tail_integral = (A_fit * tau_fit / beta_fit) * gamma(s) * gammaincc(s, x)\n                \n                # Ensure physical result (integral must be non-negative)\n                if tail_integral  0:\n                    tail_integral = 0.0\n\n            except RuntimeError:\n                # If fit fails, the tail contribution is zero\n                tail_integral = 0.0\n        \n        # 5. Calculate the total diffusion coefficient\n        total_integral = numerical_integral + tail_integral\n        D = (1.0 / 3.0) * total_integral\n        results.append(D)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join([f'{d:.6e}' for d in results])}]\")\n\nsolve()\n```", "id": "3501959"}, {"introduction": "This final computational practice delves into a critical and subtle aspect of spectral analysis: the choice of input data. You will investigate two common methods for obtaining the vibrational density of states (VDOS), one starting from the displacement autocorrelation function and the other from the velocity autocorrelation function. By testing these estimators against synthetic data containing realistic challenges like drift and diffusive motion, you will discover the superior robustness of the velocity-based method and learn to identify potential low-frequency artifacts in your spectra. [@problem_id:3501987]", "problem": "You are asked to design and implement a complete and runnable program that, starting from fundamental definitions of kinematics and stationary stochastic processes, constructs and compares two estimators of the vibrational density of states using velocity and displacement autocorrelation functions. Your implementation must be entirely self-contained and deterministic.\n\nThe fundamental base you must use is the following. The displacement of a degree of freedom is a function of time denoted by $u(t)$, and its velocity is defined by the time derivative $v(t) = \\frac{du(t)}{dt}$. For any wide-sense stationary real-valued time series $x(t)$ with zero mean, the autocorrelation function is $C_{xx}(\\tau) = \\mathbb{E}[x(t)x(t+\\tau)]$, and the Wiener–Khinchin theorem states that the power spectral density is the Fourier transform of the autocorrelation function. You must begin your derivation and design from these statements only, without using shortcut formulas.\n\nYour program must do the following for the specified test suite.\n\n- Construct discrete-time synthetic trajectories for $u(t)$ and $v(t)$ on a uniform grid $t_n = n\\,\\Delta t$ for $n \\in \\{0,1,\\dots,N-1\\}$, with additive independent Gaussian measurement noise, using the specified random seed for reproducibility. For harmonic content, use a finite sum of cosine modes in displacement with fixed amplitudes and phases to be generated deterministically from the seed. The corresponding noise-free velocity must be the exact time derivative of the noise-free displacement. Then add the specified measurement noise independently to the displacement and velocity time series. When a linear drift slope in displacement is specified, add $d\\,t_n$ to $u(t_n)$ and the corresponding constant term $d$ to $v(t_n)$ before adding measurement noise.\n- For each of $u$ and $v$, compute the discrete sample autocorrelation function $\\hat{C}_{xx}[k]$ using mean subtraction and unbiased normalization, where $k$ is the discrete lag in samples. Apply a Hann window to the autocorrelation sequence to mitigate truncation artifacts. Compute the one-sided discrete-time Fourier transform of the windowed autocorrelation to obtain a nonnegative spectrum sampled at angular frequencies $\\omega_k = \\frac{2\\pi k}{N \\Delta t}$ for $k \\in \\{0,1,\\dots,\\lfloor N/2 \\rfloor\\}$.\n- Using only the relation between $u$ and $v$ implied by $v = du/dt$ and the Wiener–Khinchin theorem (do not use any other heuristic shortcuts), construct two nonnegative vibrational density of states estimators on positive angular frequencies: one based on velocity autocorrelation and one based on displacement autocorrelation. Restrict to $\\omega  0$ and normalize each estimator so that its Riemann sum over positive angular frequencies equals $1$ using the angular frequency bin width $\\Delta\\omega = \\frac{2\\pi}{N \\Delta t}$. Your normalization must be explicit and internal to your program.\n- For each test case, compute the following quantitative metrics:\n  1. The absolute difference between the dominant angular frequencies (locations of the maxima) of the two normalized estimators, expressed in $\\mathrm{rad/ps}$ and rounded to three decimals.\n  2. The ratio of the low-frequency leakage defined as the normalized integrated density over the interval $\\omega \\in [0,\\omega_c]$ computed from the displacement-based estimator divided by that from the velocity-based estimator, rounded to three decimals. Use the angular frequency threshold $\\omega_c$ given in each case and integrate by a discrete Riemann sum with spacing $\\Delta\\omega$.\n  3. For the case explicitly involving nonstationary motion without true vibrational content, return a boolean indicating whether the low-frequency leakage from the displacement-based estimator is strictly greater than five times that from the velocity-based estimator.\n\nSpecifications common to all test cases:\n\n- Use time step $\\Delta t = 0.001\\,\\mathrm{ps}$, total number of samples $N = 16384$, and random seed $12345$ for any stochastic component.\n- Phases for the harmonic modes must be generated deterministically from the seed in a way that does not introduce bias between the two estimators.\n- Before computing autocorrelations, subtract the sample mean from each time series independently.\n- Use an unbiased autocorrelation normalization where lag $k$ is divided by the number of overlapping samples $N-k$.\n- Apply a Hann window $w[k] = \\tfrac{1}{2}\\left(1 - \\cos\\left(\\tfrac{2\\pi k}{N-1}\\right)\\right)$ to the autocorrelation sequence prior to the discrete Fourier transform.\n- For normalization of the estimators, integrate only over strictly positive angular frequencies (exclude $\\omega=0$) and ensure the Riemann sum over that positive set equals $1$.\n\nTest suite:\n\n- Case A (single sharp mode, low noise, no drift): Use one harmonic mode with angular frequency $\\omega_0 = 4.0\\,\\mathrm{rad/ps}$ and amplitude $A_0 = 0.10\\,\\mathrm{nm}$ in displacement. No drift. Gaussian measurement noise standard deviations $\\sigma_u = 0.001\\,\\mathrm{nm}$ for displacement and $\\sigma_v = 0.001\\,\\mathrm{nm/ps}$ for velocity. Use low-frequency threshold $\\omega_c = 0.5\\,\\mathrm{rad/ps}$. Output the absolute dominant frequency difference as a float in $\\mathrm{rad/ps}$ rounded to three decimals.\n- Case B (two modes with linear drift): Use two harmonic modes with angular frequencies $\\omega_1 = 1.0\\,\\mathrm{rad/ps}$ and $\\omega_2 = 8.0\\,\\mathrm{rad/ps}$ and amplitudes $A_1 = 0.08\\,\\mathrm{nm}$ and $A_2 = 0.05\\,\\mathrm{nm}$ in displacement. Add a linear drift slope $d = 0.01\\,\\mathrm{nm/ps}$ in displacement (and the corresponding constant drift in velocity) before adding measurement noise. Gaussian measurement noise standard deviations $\\sigma_u = 0.002\\,\\mathrm{nm}$ and $\\sigma_v = 0.002\\,\\mathrm{nm/ps}$. Use low-frequency threshold $\\omega_c = 0.5\\,\\mathrm{rad/ps}$. Output the ratio of low-frequency leakage (displacement-based divided by velocity-based) as a float rounded to three decimals.\n- Case C (Brownian-like nonstationary displacement): Generate a velocity time series as independent Gaussian samples with zero mean and standard deviation $\\sigma_v = 0.02\\,\\mathrm{nm/ps}$, then construct displacement by cumulative time integration $u(t_{n+1}) = u(t_n) + v(t_n)\\,\\Delta t$, starting from $u(0)=0$. Add Gaussian measurement noise with standard deviations $\\sigma_u = 0.002\\,\\mathrm{nm}$ to displacement and $\\sigma_v^{\\text{meas}} = 0.002\\,\\mathrm{nm/ps}$ to velocity. Use low-frequency threshold $\\omega_c = 0.5\\,\\mathrm{rad/ps}$. Output a boolean indicating whether the low-frequency leakage from the displacement-based estimator exceeds five times that from the velocity-based estimator.\n\nFinal output format:\n\n- Your program should produce a single line of output containing the results of Case A, Case B, and Case C, as a comma-separated list enclosed in square brackets, with the first two entries being the rounded floats as specified above and the third entry being the boolean. For example, an output with placeholders would look like [$x,y,z$] where $x$ and $y$ are floats with three decimals and $z$ is either True or False.\n\nAll physical units must be adhered to as specified, with angular frequency in $\\mathrm{rad/ps}$ and displacement in $\\mathrm{nm}$, and any boolean must be returned in canonical programming language boolean form. No external input is allowed; all parameters and random seeds are fixed by this specification.", "solution": "The problem is assessed to be valid as it is scientifically grounded, well-posed, objective, and internally consistent. It presents a well-defined computational task in signal processing and statistical physics without any logical or factual flaws.\n\nHerein, we present a complete solution derived from first principles as required. The objective is to construct and compare two estimators for the vibrational density of states (VDOS), one based on the velocity autocorrelation function (VACF) and the other on the displacement autocorrelation function (DACF).\n\n**1. Theoretical Foundation: From Kinematics to Spectral Relations**\n\nThe problem begins with the fundamental kinematic relationship between displacement $u(t)$ and velocity $v(t)$:\n$$ v(t) = \\frac{du(t)}{dt} $$\nFor a wide-sense stationary stochastic process $x(t)$ with zero mean, the autocorrelation function is defined as $C_{xx}(\\tau) = \\mathbb{E}[x(t)x(t+\\tau)]$, where $\\mathbb{E}[\\cdot]$ denotes the expectation operator. We seek the relationship between the displacement autocorrelation $C_{uu}(\\tau)$ and the velocity autocorrelation $C_{vv}(\\tau)$.\n\nFirst, let us relate the cross-correlation $C_{vu}(\\tau) = \\mathbb{E}[v(t)u(t+\\tau)]$ to $C_{uu}(\\tau)$. Using the definition of velocity:\n$$ C_{vu}(\\tau) = \\mathbb{E}\\left[ \\frac{du(t)}{dt} u(t+\\tau) \\right] $$\nFor stationary processes, a key property is $\\mathbb{E}[A'(t)B(t+\\tau)] = -\\frac{d}{d\\tau} \\mathbb{E}[A(t)B(t+\\tau)]$. Applying this property yields:\n$$ C_{vu}(\\tau) = -\\frac{d}{d\\tau} \\mathbb{E}[u(t)u(t+\\tau)] = -\\frac{dC_{uu}(\\tau)}{d\\tau} $$\nNext, we express $C_{vv}(\\tau)$ in terms of a cross-correlation. Using the property $\\mathbb{E}[A(t)B'(t+\\tau)] = \\frac{d}{d\\tau}\\mathbb{E}[A(t)B(t+\\tau)]$:\n$$ C_{vv}(\\tau) = \\mathbb{E}[v(t)v(t+\\tau)] = \\mathbb{E}\\left[v(t)\\frac{du(t+\\tau)}{d(t+\\tau)}\\right] = \\frac{d}{d\\tau}\\mathbb{E}[v(t)u(t+\\tau)] = \\frac{dC_{vu}(\\tau)}{d\\tau} $$\nSubstituting the expression for $C_{vu}(\\tau)$, we arrive at the fundamental relationship between the two autocorrelation functions:\n$$ C_{vv}(\\tau) = \\frac{d}{d\\tau} \\left( -\\frac{dC_{uu}(\\tau)}{d\\tau} \\right) = -\\frac{d^2 C_{uu}(\\tau)}{d\\tau^2} $$\nThe Wiener–Khinchin theorem states that the power spectral density (PSD), $S_{xx}(\\omega)$, is the Fourier transform of the autocorrelation function, $S_{xx}(\\omega) = \\mathcal{F}[C_{xx}(\\tau)](\\omega)$. The Fourier transform of an $n$-th derivative is given by $\\mathcal{F}[f^{(n)}(\\tau)](\\omega) = (i\\omega)^n \\mathcal{F}[f(\\tau)](\\omega)$. Applying this to our relationship for the ACFs:\n$$ S_{vv}(\\omega) = \\mathcal{F}[C_{vv}(\\tau)] = \\mathcal{F}\\left[-\\frac{d^2 C_{uu}(\\tau)}{d\\tau^2}\\right] = -(i\\omega)^2 \\mathcal{F}[C_{uu}(\\tau)] = -(-\\omega^2) S_{uu}(\\omega) $$\nThis yields the central equation in the frequency domain:\n$$ S_{vv}(\\omega) = \\omega^2 S_{uu}(\\omega) $$\n\n**2. Vibrational Density of States (VDOS) Estimators**\n\nIn statistical mechanics, the vibrational density of states, $g(\\omega)$, describes the distribution of vibrational modes by frequency. The total kinetic energy is related to the sum of squared velocities of the system's degrees of freedom. Consequently, the VDOS is naturally defined as being proportional to the power spectrum of velocity fluctuations.\n\nThe velocity-based VDOS estimator, $g_v(\\omega)$, is therefore taken to be proportional to the velocity power spectrum:\n$$ g_v(\\omega) \\propto S_{vv}(\\omega) $$\nUsing the derived spectral relationship, we can construct an analogous estimator from displacement data. To obtain the VDOS, we must first compute the velocity spectrum from the displacement spectrum, which involves multiplication by $\\omega^2$. Thus, the displacement-based VDOS estimator, $g_u(\\omega)$, is defined as:\n$$ g_u(\\omega) \\propto \\omega^2 S_{uu}(\\omega) $$\nThese two estimators, $g_v(\\omega)$ and $g_u(\\omega)$, should theoretically be identical for a perfectly stationary process. However, in practice, they respond differently to noise, finite sample effects, and non-stationarities like drift or diffusion, which is what this problem investigates.\n\n**3. Computational Algorithm**\n\nThe implementation proceeds by following a discrete signal processing pipeline for each specified test case.\n\n**3.1. Data Generation**\nFor each case, synthetic time series for displacement, $u(t_n)$, and velocity, $v(t_n)$, are generated on a grid $t_n = n\\Delta t$ for $n \\in \\{0, \\dots, N-1\\}$.\n- **Harmonic Content (Cases A, B):** A sum of cosine functions for displacement and their analytical time derivatives for velocity are constructed. Random phases, generated deterministically from the specified seed, are used for each mode.\n- **Diffusive Content (Case C):** A velocity time series is generated as discrete Gaussian white noise. The displacement is then obtained by a cumulative discrete integration, $u(t_{n+1}) = u(t_n) + v(t_n)\\Delta t$, mimicking a random walk (Brownian motion).\n- **Drift and Noise:** A linear drift is added to the clean displacement and a constant drift to the velocity trajectories where specified. Finally, independent Gaussian measurement noise is added to both time series.\n\n**3.2. Signal Processing Pipeline**\nFor each time series ($u$ and $v$):\n1.  **Mean Subtraction:** The sample mean is subtracted from the time series to satisfy the zero-mean assumption for ACF calculation.\n2.  **Autocorrelation Function:** The unbiased sample autocorrelation function $\\hat{C}_{xx}[k]$ for discrete lags $k \\in \\{0, \\dots, N-1\\}$ is computed. This is defined as $\\hat{C}_{xx}[k] = \\frac{1}{N-k} \\sum_{n=0}^{N-1-k} x'_{n}x'_{n+k}$, where $x'$ is the mean-subtracted series. An efficient FFT-based algorithm as provided by `scipy.signal.correlate` is used for this computation.\n3.  **Windowing:** A Hann window $w[k] = \\tfrac{1}{2}\\left(1 - \\cos\\left(\\tfrac{2\\pi k}{N-1}\\right)\\right)$ is applied to the full length of the computed ACF, $\\hat{C}^{\\text{win}}_{xx}[k] = \\hat{C}_{xx}[k] \\cdot w[k]$, to reduce spectral leakage from signal truncation.\n4.  **Power Spectral Density:** The one-sided PSD, $\\hat{S}_{xx}(\\omega_j)$, is computed from the windowed ACF. This is implemented by taking the real part of the one-sided Discrete Fourier Transform (`rfft`) of the windowed ACF sequence. Any small negative values resulting from numerical imprecision are clipped to zero to ensure a non-negative spectrum.\n\n**3.3. VDOS Construction and Normalization**\nThe unnormalized discrete VDOS estimators are constructed as:\n$$ \\hat{g}_v[\\omega_j] = \\hat{S}_{vv}[\\omega_j] \\quad \\text{and} \\quad \\hat{g}_u[\\omega_j] = \\omega_j^2 \\hat{S}_{uu}[\\omega_j] $$\nwhere $\\omega_j = \\frac{2\\pi j}{N \\Delta t}$ are the discrete angular frequencies. Each estimator is then normalized such that its Riemann sum over strictly positive frequencies ($\\omega_j  0$) equals one. The normalization constant $K$ is the inverse of the sum: $K = \\left( \\sum_{j=1}^{\\lfloor N/2 \\rfloor} \\hat{g}[\\omega_j] \\Delta\\omega \\right)^{-1}$, where $\\Delta\\omega = \\frac{2\\pi}{N \\Delta t}$. The normalized VDOS is $g_{\\text{norm}}[\\omega_j] = K \\cdot \\hat{g}[\\omega_j]$.\n\n**4. Metrics Calculation**\nThe final step is to compute the specified metrics from the normalized VDOS estimators $g_u$ and $g_v$:\n- **Metric A (Dominant Frequency Difference):** The angular frequency $\\omega_{\\max}$ corresponding to the maximum value of each VDOS (for $\\omega  0$) is found. The absolute difference $|\\omega_{\\max,u} - \\omega_{\\max,v}|$ is computed.\n- **Metric B (Low-Frequency Leakage Ratio):** The integrated density is computed for each estimator over the interval $\\omega \\in [0, \\omega_c]$ via a discrete Riemann sum. The ratio of the displacement-based integral to the velocity-based integral is then calculated.\n- **Metric C (Nonstationary Leakage Check):** For the Brownian motion case, the same leakage integrals are computed. A boolean value is returned indicating whether the leakage from the displacement-based estimator is strictly greater than five times that from the velocity-based estimator. This metric highlights the superior robustness of the VACF-based method in handling non-stationary diffusive motion, which manifests as severe low-frequency artifacts in the DACF-based approach.\n\nThis rigorous, principle-based procedure ensures that the comparison between the two estimators is performed on a solid theoretical and computational footing.", "answer": "```python\nimport numpy as np\nfrom scipy.signal import correlate\nfrom scipy.fft import rfft, rfftfreq\n\ndef solve():\n    \"\"\"\n    Constructs and compares two estimators of the vibrational density of states\n    using velocity and displacement autocorrelation functions, based on synthetic data.\n    \"\"\"\n    # --- Common Specifications ---\n    DT = 0.001  # time step in ps\n    N = 16384     # number of samples\n    SEED = 12345\n    RNG = np.random.default_rng(SEED)\n\n    # --- Test Suite Parameters ---\n    test_cases_params = [\n        {\n            \"case\": \"A\",\n            \"modes\": [(4.0, 0.10)],  # (omega_rad_ps, amplitude_nm)\n            \"drift_slope\": 0.0,\n            \"sigma_u\": 0.001,\n            \"sigma_v\": 0.001,\n            \"omega_c\": 0.5,\n        },\n        {\n            \"case\": \"B\",\n            \"modes\": [(1.0, 0.08), (8.0, 0.05)],\n            \"drift_slope\": 0.01,\n            \"sigma_u\": 0.002,\n            \"sigma_v\": 0.002,\n            \"omega_c\": 0.5,\n        },\n        {\n            \"case\": \"C\",\n            \"is_brownian\": True,\n            \"brownian_sigma_v\": 0.02, # For generating the core signal\n            \"drift_slope\": 0.0,\n            \"sigma_u\": 0.002, # Measurement noise on u\n            \"sigma_v\": 0.002, # Measurement noise on v\n            \"omega_c\": 0.5,\n        },\n    ]\n\n    results = []\n\n    def analyze_case(params):\n        \"\"\"\n        Performs the full analysis pipeline for a single test case.\n        \"\"\"\n        # Time array\n        t = np.arange(N) * DT\n\n        # --- 1. Generate Synthetic Trajectories ---\n        u_clean = np.zeros(N, dtype=np.float64)\n        v_clean = np.zeros(N, dtype=np.float64)\n\n        if params.get(\"is_brownian\", False):\n            # Case C: Brownian-like motion\n            v_clean = RNG.normal(loc=0.0, scale=params[\"brownian_sigma_v\"], size=N)\n            u_clean = np.cumsum(v_clean) * DT\n        else:\n            # Cases A, B: Harmonic modes\n            num_modes = len(params[\"modes\"])\n            phases = RNG.uniform(0, 2 * np.pi, size=num_modes)\n            for i, (omega, amplitude) in enumerate(params[\"modes\"]):\n                phi = phases[i]\n                u_clean += amplitude * np.cos(omega * t + phi)\n                v_clean += -amplitude * omega * np.sin(omega * t + phi)\n        \n        # Add linear drift if specified\n        drift = params[\"drift_slope\"]\n        if drift != 0.0:\n            u_clean += drift * t\n            v_clean += drift\n            \n        # Add independent Gaussian measurement noise\n        u_noisy = u_clean + RNG.normal(loc=0.0, scale=params[\"sigma_u\"], size=N)\n        v_noisy = v_clean + RNG.normal(loc=0.0, scale=params[\"sigma_v\"], size=N)\n\n        # --- 2. Compute Power Spectral Density (PSD) ---\n        def get_psd(series):\n            # i. Mean subtraction\n            series_mean_sub = series - np.mean(series)\n            \n            # ii. Unbiased Autocorrelation Function (ACF)\n            unscaled_acf = correlate(series_mean_sub, series_mean_sub, mode='full', method='fft')[N - 1:]\n            normalization_factors = N - np.arange(N)\n            acf = unscaled_acf / normalization_factors\n            \n            # iii. Hann Windowing\n            hann_window = 0.5 * (1 - np.cos(2 * np.pi * np.arange(N) / (N - 1)))\n            wacf = acf * hann_window\n            \n            # iv. PSD from FFT of windowed ACF\n            psd = np.real(rfft(wacf))\n            psd[psd  0] = 0  # Ensure non-negativity\n            \n            return psd\n\n        S_uu = get_psd(u_noisy)\n        S_vv = get_psd(v_noisy)\n        \n        # Frequency axis (angular)\n        omega = 2 * np.pi * rfftfreq(N, d=DT)\n        \n        # --- 3. Construct and Normalize VDOS Estimators ---\n        g_u_unnorm = (omega**2) * S_uu\n        g_v_unnorm = S_vv\n\n        # Normalization over strictly positive frequencies (omega > 0)\n        d_omega = omega[1] - omega[0]\n        \n        norm_u_integral = np.sum(g_u_unnorm[1:]) * d_omega\n        g_u = g_u_unnorm / norm_u_integral if norm_u_integral > 0 else np.zeros_like(g_u_unnorm)\n\n        norm_v_integral = np.sum(g_v_unnorm[1:]) * d_omega\n        g_v = g_v_unnorm / norm_v_integral if norm_v_integral > 0 else np.zeros_like(g_v_unnorm)\n\n        # --- 4. Compute and Return Required Metrics ---\n        if params[\"case\"] == \"A\":\n            # argmax on omega > 0 part of the spectrum\n            idx_max_u = np.argmax(g_u[1:]) + 1\n            idx_max_v = np.argmax(g_v[1:]) + 1\n            freq_diff = abs(omega[idx_max_u] - omega[idx_max_v])\n            return round(freq_diff, 3)\n        \n        elif params[\"case\"] in [\"B\", \"C\"]:\n            omega_c = params[\"omega_c\"]\n            # Find index corresponding to omega_c\n            idx_c = np.searchsorted(omega, omega_c, side='right')\n            # Riemann sum for leakage integral over [0, omega_c]\n            leakage_u = np.sum(g_u[0:idx_c]) * d_omega\n            leakage_v = np.sum(g_v[0:idx_c]) * d_omega\n\n            if params[\"case\"] == \"B\":\n                # Handle potential division by zero\n                ratio = leakage_u / leakage_v if leakage_v != 0 else np.inf\n                return round(ratio, 3)\n            else: # Case C\n                return leakage_u > 5 * leakage_v\n\n    for params in test_cases_params:\n        results.append(analyze_case(params))\n\n    # --- Final Output Formatting ---\n    print(f\"[{results[0]},{results[1]},{results[2]}]\")\n\nsolve()\n```", "id": "3501987"}]}