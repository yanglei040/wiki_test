{"hands_on_practices": [{"introduction": "The Hellmann-Feynman theorem is a cornerstone of computational materials science, providing an analytical expression for forces on atoms and the macroscopic stress tensor. This practice grounds the theory by tasking you with deriving the force on a nucleus in a simple quantum system directly from the Schrödinger equation, and subsequently verifying your result against a numerical finite-difference calculation [@problem_id:3456489]. This exercise reinforces the connection between the analytical theorem and its numerical implementation, a critical skill for developing and validating simulation codes.", "problem": "You are given a parameter-dependent quantum-mechanical model and a simple hyperelastic model. Your goal is to derive expressions for analytic forces and stress from first principles, and verify them numerically by finite differences. All quantities are dimensionless.\n\nTask A (Hellmann-Feynman force verification):\n- Consider a one-electron, two-level system with a real symmetric Hamiltonian $H(R)$ that depends on a scalar nuclear coordinate $R$. The Hamiltonian in an orthonormal basis is\n$$\nH(R) = \\begin{pmatrix}\n\\varepsilon_1 & V(R) \\\\\nV(R) & \\varepsilon_2\n\\end{pmatrix},\n\\quad\nV(R) = t \\, e^{-\\alpha R},\n$$\nwhere $\\varepsilon_1$, $\\varepsilon_2$, $t$, and $\\alpha$ are constants, and $R \\ge 0$. Let $E(R)$ denote the ground-state energy (the smallest eigenvalue of $H(R)$), and let $\\lvert \\psi(R)\\rangle$ be its normalized eigenvector.\n- Starting only from the time-independent Schrödinger equation $H(R)\\lvert \\psi(R)\\rangle = E(R)\\lvert \\psi(R)\\rangle$, the normalization condition $\\langle \\psi(R)\\vert \\psi(R)\\rangle = 1$, and the definition of force as the negative derivative of the total energy with respect to $R$, derive an analytic expression for the force $F_{\\mathrm{analytic}}(R)$ acting along $R$ when the electronic state is stationary with respect to $H(R)$. Your derivation must rely on the stationarity of the electronic state and basic differentiation rules, without assuming any pre-quoted target formula.\n- Implement a numerical verification by central finite differences. Define\n$$\nF_{\\mathrm{FD}}(R; h) \\equiv -\\frac{E(R+h) - E(R-h)}{2h},\n$$\nfor a given small step size $h>0$.\n- For each specified test case, compute the absolute error\n$$\n\\Delta F \\equiv \\left| F_{\\mathrm{analytic}}(R) - F_{\\mathrm{FD}}(R; h) \\right|.\n$$\n\nTask B (stress from energy–strain relation):\n- Consider a cubic cell of volume $\\Omega$ containing a single pair interaction whose energy depends only on the scalar separation $r$ between two sites:\n$$\nE_{\\mathrm{pair}}(r) = \\frac{1}{2} k \\left(r - r_0\\right)^2,\n$$\nwith constants $k>0$ and $r_0 \\ge 0$. Subject the cell to a small isotropic infinitesimal strain of amplitude $\\varepsilon$, so that the separation transforms as $r \\mapsto r'(\\varepsilon) = (1+\\varepsilon)\\,r$, and the cell volume becomes $\\Omega'(\\varepsilon) = (1+\\varepsilon)^3 \\Omega$. Assume small-strain thermodynamics in which the Cauchy stress tensor $\\sigma_{ij}$ satisfies\n$$\n\\frac{\\partial E}{\\partial \\varepsilon_{ij}}\\bigg\\rvert_{\\varepsilon=0} = \\Omega\\, \\sigma_{ij},\n$$\nwhere $\\varepsilon_{ij}$ is the small-strain tensor. For isotropic strain, $\\varepsilon_{ij} = \\varepsilon\\, \\delta_{ij}$, the Cauchy stress is hydrostatic with $\\sigma_{ij} = s\\,\\delta_{ij}$, and\n$$\n\\frac{\\partial E}{\\partial \\varepsilon}\\bigg\\rvert_{\\varepsilon=0} = \\Omega\\, \\mathrm{tr}\\,\\sigma = 3\\,\\Omega\\, s.\n$$\n- Starting from these definitions, derive an analytic expression $s_{\\mathrm{analytic}}$ for the hydrostatic Cauchy stress magnitude $s$ in terms of $k$, $r$, $r_0$, and $\\Omega$.\n- Implement a numerical verification by symmetric finite differences with respect to $\\varepsilon$:\n$$\ns_{\\mathrm{FD}}(\\varepsilon; \\delta) \\equiv \\frac{1}{3\\Omega}\\,\\frac{E_{\\mathrm{pair}}(r'(+\\delta)) - E_{\\mathrm{pair}}(r'(-\\delta))}{2\\delta},\n$$\nwhere $r'(\\pm\\delta) = (1\\pm\\delta)\\,r$ and $\\delta>0$ is small. For each specified test case, compute the absolute error\n$$\n\\Delta s \\equiv \\left| s_{\\mathrm{analytic}} - s_{\\mathrm{FD}}(\\varepsilon; \\delta) \\right|.\n$$\n\nImplementation requirements:\n- Use double-precision floating point arithmetic.\n- For eigenproblems, use a numerically stable routine to obtain the smallest eigenvalue and a normalized eigenvector.\n- Use the central finite-difference formulas exactly as given above.\n\nUnits:\n- All quantities are dimensionless; no physical units are used in this problem.\n\nTest suite:\n- Task A (forces). For each tuple $(\\varepsilon_1, \\varepsilon_2, t, \\alpha, R, h)$, compute $\\Delta F$.\n  - Case A$1$: $(0, 1, 2, 0.7, 1.5, 10^{-5})$.\n  - Case A$2$: $(-0.5, 0.8, 1.2, 1.1, 0.3, 10^{-6})$.\n  - Case A$3$: $(0.3, 0.31, 0.05, 2.5, 2.0, 10^{-7})$.\n  - Case A$4$: $(5, -4, 10, 0.2, 3.0, 10^{-6})$.\n- Task B (stress). For each tuple $(k, r_0, r, \\Omega, \\delta)$, compute $\\Delta s$.\n  - Case B$1$: $(4, 1, 1.2, 10, 10^{-6})$.\n  - Case B$2$: $(2, 2, 2, 3, 10^{-6})$.\n  - Case B$3$: $(100, 1, 1.1, 1, 10^{-7})$.\n\nRequired final output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must contain the absolute errors in the following order: $\\left[\\Delta F_{\\mathrm{A1}}, \\Delta F_{\\mathrm{A2}}, \\Delta F_{\\mathrm{A3}}, \\Delta F_{\\mathrm{A4}}, \\Delta s_{\\mathrm{B1}}, \\Delta s_{\\mathrm{B2}}, \\Delta s_{\\mathrm{B3}}\\right]$.", "solution": "The problem is valid as it is scientifically sound, self-contained, and well-posed, representing a standard exercise in computational materials science. It consists of two independent tasks: A) verification of the Hellmann-Feynman force for a two-level quantum system, and B) verification of the hydrostatic stress for a simple pair-interaction model. Both tasks require an analytical derivation from first principles followed by a numerical implementation and verification.\n\n**Task A: Hellmann-Feynman Force Derivation**\n\nThe force $F(R)$ acting along a nuclear coordinate $R$ is defined as the negative gradient of the total energy $E(R)$ with respect to that coordinate:\n$$\nF(R) = -\\frac{dE(R)}{dR}.\n$$\nThe energy $E(R)$ is the ground-state eigenvalue of the position-dependent Hamiltonian $H(R)$. For a normalized eigenstate $\\lvert \\psi(R) \\rangle$ corresponding to the eigenvalue $E(R)$, the energy can be expressed as the expectation value:\n$$\nE(R) = \\langle \\psi(R) \\vert H(R) \\vert \\psi(R) \\rangle.\n$$\nDifferentiating this expression for $E(R)$ with respect to $R$ using the product rule gives:\n$$\n\\frac{dE}{dR} = \\left( \\frac{d}{dR} \\langle \\psi(R) \\vert \\right) H(R) \\vert \\psi(R) \\rangle + \\left\\langle \\psi(R) \\left\\vert \\frac{dH(R)}{dR} \\right\\vert \\psi(R) \\right\\rangle + \\left\\langle \\psi(R) \\vert H(R) \\left( \\frac{d}{dR} \\vert \\psi(R) \\rangle \\right) \\right).\n$$\nThe problem asks the derivation to rely on the stationarity of the electronic state, which means $\\lvert \\psi(R) \\rangle$ is an eigenstate of $H(R)$. Since $H(R)$ is Hermitian, we have $H(R) \\vert \\psi(R) \\rangle = E(R) \\vert \\psi(R) \\rangle$ and, by taking the conjugate transpose, $\\langle \\psi(R) \\vert H(R) = E(R) \\langle \\psi(R) \\vert$. Substituting these into the first and third terms yields:\n$$\n\\frac{dE}{dR} = E(R) \\left( \\frac{d}{dR} \\langle \\psi(R) \\vert \\right) \\vert \\psi(R) \\rangle + \\left\\langle \\psi(R) \\left\\vert \\frac{dH(R)}{dR} \\right\\vert \\psi(R) \\right\\rangle + E(R) \\left\\langle \\psi(R) \\vert \\left( \\frac{d}{dR} \\vert \\psi(R) \\rangle \\right) \\right).\n$$\nFactoring out the scalar energy $E(R)$:\n$$\n\\frac{dE}{dR} = \\left\\langle \\psi(R) \\left\\vert \\frac{dH(R)}{dR} \\right\\vert \\psi(R) \\right\\rangle + E(R) \\left[ \\left( \\frac{d}{dR} \\langle \\psi(R) \\vert \\right) \\vert \\psi(R) \\rangle + \\left\\langle \\psi(R) \\vert \\left( \\frac{d}{dR} \\vert \\psi(R) \\rangle \\right) \\right) \\right].\n$$\nThe term in the square brackets is the derivative of the normalization condition, $\\langle \\psi(R) \\vert \\psi(R) \\rangle = 1$:\n$$\n\\frac{d}{dR} \\langle \\psi(R) \\vert \\psi(R) \\rangle = \\frac{d}{dR}(1) = 0.\n$$\nTherefore, the second part of the expression for $\\frac{dE}{dR}$ vanishes, leaving the Hellmann-Feynman theorem:\n$$\n\\frac{dE}{dR} = \\left\\langle \\psi(R) \\left\\vert \\frac{dH(R)}{dR} \\right\\vert \\psi(R) \\right\\rangle.\n$$\nThe analytic force is thus:\n$$\nF_{\\mathrm{analytic}}(R) = - \\left\\langle \\psi(R) \\left\\vert \\frac{dH(R)}{dR} \\right\\vert \\psi(R) \\right\\rangle.\n$$\nFor the given Hamiltonian $H(R) = \\begin{pmatrix} \\varepsilon_1 & V(R) \\\\ V(R) & \\varepsilon_2 \\end{pmatrix}$ with $V(R) = t e^{-\\alpha R}$, its derivative with respect to $R$ is:\n$$\n\\frac{dH(R)}{dR} = \\begin{pmatrix} 0 & \\frac{dV}{dR} \\\\ \\frac{dV}{dR} & 0 \\end{pmatrix} = \\begin{pmatrix} 0 & -\\alpha t e^{-\\alpha R} \\\\ -\\alpha t e^{-\\alpha R} & 0 \\end{pmatrix}.\n$$\nThis expression is used to evaluate $F_{\\mathrm{analytic}}(R)$ by first finding the ground-state eigenvector $\\lvert \\psi(R) \\rangle$ of $H(R)$ and then computing the expectation value. For the numerical verification, the ground-state energy $E(R)$ is computed at $R+h$ and $R-h$ to evaluate the central difference formula $F_{\\mathrm{FD}}(R;h) = -\\frac{E(R+h) - E(R-h)}{2h}$. The absolute error $\\Delta F = |F_{\\mathrm{analytic}}(R) - F_{\\mathrm{FD}}(R;h)|$ is subsequently calculated.\n\n**Task B: Hydrostatic Stress Derivation**\n\nThe energy of the pair interaction depends on the separation $r$. Under an isotropic strain of amplitude $\\varepsilon$, the separation transforms as $r \\mapsto r'(\\varepsilon) = (1+\\varepsilon)r$. The energy as a function of strain is:\n$$\nE(\\varepsilon) = E_{\\mathrm{pair}}(r'(\\varepsilon)) = \\frac{1}{2} k \\left((1+\\varepsilon)r - r_0\\right)^2.\n$$\nThe problem provides the relationship between the hydrostatic stress magnitude $s$ and the derivative of energy with respect to strain, evaluated at zero strain ($\\varepsilon=0$):\n$$\ns = \\frac{1}{3\\Omega} \\frac{\\partial E}{\\partial \\varepsilon}\\bigg\\rvert_{\\varepsilon=0}.\n$$\nFirst, we compute the derivative of $E(\\varepsilon)$ with respect to $\\varepsilon$ using the chain rule:\n$$\n\\frac{\\partial E}{\\partial \\varepsilon} = \\frac{\\partial}{\\partial \\varepsilon} \\left[\\frac{1}{2} k \\left((1+\\varepsilon)r - r_0\\right)^2 \\right] = k \\left( (1+\\varepsilon)r - r_0 \\right) \\cdot \\frac{\\partial}{\\partial \\varepsilon}\\left( (1+\\varepsilon)r - r_0 \\right) = k r \\left( (1+\\varepsilon)r - r_0 \\right).\n$$\nNext, we evaluate this derivative at $\\varepsilon=0$:\n$$\n\\frac{\\partial E}{\\partial \\varepsilon}\\bigg\\rvert_{\\varepsilon=0} = k r \\left( (1+0)r - r_0 \\right) = k r (r-r_0).\n$$\nSubstituting this result into the expression for stress yields the analytic formula:\n$$\ns_{\\mathrm{analytic}} = \\frac{k r (r - r_0)}{3\\Omega}.\n$$\nFor numerical verification, the finite difference formula $s_{\\mathrm{FD}} = \\frac{1}{3\\Omega}\\,\\frac{E_{\\mathrm{pair}}(r'(+\\delta)) - E_{\\mathrm{pair}}(r'(-\\delta))}{2\\delta}$ is used to approximate this derivative. The absolute error $\\Delta s = |s_{\\mathrm{analytic}} - s_{\\mathrm{FD}}|$ is then computed.\n\nThe implementation uses `numpy.linalg.eigh` for the stable solution of the eigenproblem in Task A and double-precision floating-point arithmetic for all calculations, as required.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the two-part problem:\n    A) Verification of the Hellmann-Feynman force.\n    B) Verification of the hydrostatic stress from an energy-strain relation.\n    The function computes and prints the absolute errors as specified.\n    \"\"\"\n\n    # Test cases defined in the problem statement.\n    test_cases_A = [\n        # (e1, e2, t, alpha, R, h)\n        (0.0, 1.0, 2.0, 0.7, 1.5, 1e-5),\n        (-0.5, 0.8, 1.2, 1.1, 0.3, 1e-6),\n        (0.3, 0.31, 0.05, 2.5, 2.0, 1e-7),\n        (5.0, -4.0, 10.0, 0.2, 3.0, 1e-6),\n    ]\n\n    test_cases_B = [\n        # (k, r0, r, Omega, delta)\n        (4.0, 1.0, 1.2, 10.0, 1e-6),\n        (2.0, 2.0, 2.0, 3.0, 1e-6),\n        (100.0, 1.0, 1.1, 1.0, 1e-7),\n    ]\n\n    results = []\n\n    # --- Task A: Hellmann-Feynman Force Verification ---\n    def get_ground_state(R_val, e1, e2, t, alpha):\n        \"\"\"\n        Constructs the Hamiltonian H(R_val) and computes its ground state\n        (lowest eigenvalue and corresponding normalized eigenvector).\n        All calculations use double-precision floating-point numbers.\n        \"\"\"\n        V_val = t * np.exp(-alpha * R_val)\n        H = np.array([[e1, V_val], [V_val, e2]], dtype=np.float64)\n        # np.linalg.eigh is a stable solver for Hermitian matrices.\n        # It returns eigenvalues in ascending order and corresponding eigenvectors.\n        eigenvalues, eigenvectors = np.linalg.eigh(H)\n        return eigenvalues[0], eigenvectors[:, 0]\n\n    for e1, e2, t, alpha, R, h in test_cases_A:\n        # Numerical force via central finite differences.\n        E_plus_h, _ = get_ground_state(R + h, e1, e2, t, alpha)\n        E_minus_h, _ = get_ground_state(R - h, e1, e2, t, alpha)\n        F_FD = -(E_plus_h - E_minus_h) / (2.0 * h)\n\n        # Analytic force via Hellmann-Feynman theorem.\n        _, psi_R = get_ground_state(R, e1, e2, t, alpha)\n        V_R = t * np.exp(-alpha * R)\n        \n        # Derivative of the Hamiltonian matrix: dH/dR.\n        dH_dR = np.array([[0.0, -alpha * V_R], \n                          [-alpha * V_R, 0.0]], dtype=np.float64)\n        \n        # F_analytic = - <psi|dH/dR|psi> = - psi.T @ dH/dR @ psi\n        # For 1D numpy arrays, @ is the dot product.\n        F_analytic = - (psi_R @ dH_dR @ psi_R)\n\n        # Compute the absolute error.\n        delta_F = np.abs(F_analytic - F_FD)\n        results.append(delta_F)\n\n    # --- Task B: Stress from Energy–Strain Relation Verification ---\n    def E_pair(r_val, k, r0):\n        \"\"\"Calculates the pair interaction energy.\"\"\"\n        return 0.5 * k * (r_val - r0)**2\n\n    for k, r0, r, Omega, delta in test_cases_B:\n        # Numerical stress via symmetric finite differences.\n        r_plus = r * (1.0 + delta)\n        r_minus = r * (1.0 - delta)\n        \n        E_plus = E_pair(r_plus, k, r0)\n        E_minus = E_pair(r_minus, k, r0)\n        \n        # Using the finite-difference formula provided in the problem.\n        s_FD = (1.0 / (3.0 * Omega)) * (E_plus - E_minus) / (2.0 * delta)\n\n        # Analytic stress derived from the energy-strain relation.\n        s_analytic = (k * r * (r - r0)) / (3.0 * Omega)\n\n        # Compute the absolute error.\n        delta_s = np.abs(s_analytic - s_FD)\n        results.append(delta_s)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3456489"}, {"introduction": "A crucial consequence of the Hellmann-Feynman theorem is that forces derived from a total energy must be conservative, satisfying the relationship $\\mathbf{F} = -\\nabla E$. This practice moves from theoretical derivation to practical validation, equipping you with robust numerical methods to diagnose inconsistencies in a given force field [@problem_id:3456500]. By implementing both local gradient comparisons and path-integral checks, you will learn to identify non-conservative errors that can corrupt simulation results, such as energy drift in molecular dynamics.", "problem": "Write a program that implements quantitative, path-based energy-force consistency checks for two-dimensional systems in computational materials science. The checks must verify that the implemented force field is consistent with the negative gradient of the potential energy, and that the force field is integrable along a straight line, which together expose violations of the Hellmann-Feynman forces and stress consistency.\n\nStart from the following fundamental base:\n- For a conservative system with potential energy function $E(\\mathbf{R})$, the force on coordinate component $I$ is $\\mathbf{F}_I(\\mathbf{R}) = -\\partial E(\\mathbf{R})/\\partial R_I$.\n- The line integral of the force along a path $\\mathbf{R}(s)$ satisfies the gradient theorem: $\\int_{s_0}^{s_1} \\mathbf{F}(\\mathbf{R}(s)) \\cdot \\frac{d\\mathbf{R}}{ds} \\, ds = -\\left[E(\\mathbf{R}(s_1)) - E(\\mathbf{R}(s_0))\\right]$ for any conservative $\\mathbf{F}(\\mathbf{R}) = -\\nabla E(\\mathbf{R})$.\n- The Hellmann-Feynman theorem (HF) states that when the electronic state is at a stationary point with respect to variational parameters in the Born-Oppenheimer approximation, the force equals the negative derivative of the total energy with respect to nuclear coordinates, ensuring conservativity in the absence of Pulay terms or when the basis is complete.\n\nYour program must implement two numerical checks:\n1) A local energy-force consistency check at a point $\\mathbf{R}_0 \\in \\mathbb{R}^2$ using a central finite-difference estimate of $\\nabla E(\\mathbf{R}_0)$ and comparing with the implemented force $\\mathbf{F}_{\\mathrm{impl}}(\\mathbf{R}_0)$ via the normed discrepancy\n$$\n\\varepsilon_{\\mathrm{grad}} = \\frac{\\left\\|\\mathbf{F}_{\\mathrm{impl}}(\\mathbf{R}_0) + \\nabla E(\\mathbf{R}_0)\\right\\|_2}{\\max\\left(1, \\left\\|\\nabla E(\\mathbf{R}_0)\\right\\|_2\\right)}.\n$$\nUse the central difference formula per coordinate $i$,\n$$\n\\frac{\\partial E}{\\partial R_i}(\\mathbf{R}_0) \\approx \\frac{E(\\mathbf{R}_0 + h \\,\\mathbf{e}_i) - E(\\mathbf{R}_0 - h \\,\\mathbf{e}_i)}{2h},\n$$\nwith step size $h = 10^{-6}$.\n\n2) A line-search integrability check along a straight path parameterized as $\\mathbf{R}(s) = \\mathbf{R}_0 + s\\,\\mathbf{v}$ for $s \\in [0,L]$, comparing the energy difference $\\Delta E = E(\\mathbf{R}_0 + L\\,\\mathbf{v}) - E(\\mathbf{R}_0)$ with the negative of the work\n$$\nW = \\int_{0}^{L} \\mathbf{F}_{\\mathrm{impl}}(\\mathbf{R}_0 + s\\,\\mathbf{v}) \\cdot \\mathbf{v}\\, ds,\n$$\nvia the normed discrepancy\n$$\n\\varepsilon_{\\mathrm{line}} = \\frac{\\left| \\Delta E + W \\right|}{\\max\\left(1, \\left|\\Delta E\\right|\\right)}.\n$$\nEvaluate the integral using the composite Simpson rule with an even number of subintervals $N = 8192$.\n\nA test case passes if and only if both $\\varepsilon_{\\mathrm{grad}}  \\tau_{\\mathrm{grad}}$ and $\\varepsilon_{\\mathrm{line}}  \\tau_{\\mathrm{line}}$, with tolerances $\\tau_{\\mathrm{grad}} = 10^{-5}$ and $\\tau_{\\mathrm{line}} = 10^{-5}$. All quantities are dimensionless; no physical units are required.\n\nImplement the following five test cases. In each case, define the scalar energy $E(x,y)$ and the implemented force $\\mathbf{F}_{\\mathrm{impl}}(x,y)$, along with the starting point $\\mathbf{R}_0 = (x_0,y_0)$, direction vector $\\mathbf{v} = (v_x, v_y)$, and path length $L$.\n\n- Case $1$ (quadratic, consistent):\n  - $E(\\mathbf{R}) = \\tfrac{1}{2} k \\left\\|\\mathbf{R} - \\mathbf{R}_{\\mathrm{eq}}\\right\\|_2^2$ with $k = 2.5$ and $\\mathbf{R}_{\\mathrm{eq}} = (0.2,-0.1)$.\n  - $\\mathbf{F}_{\\mathrm{impl}}(\\mathbf{R}) = -k \\left(\\mathbf{R} - \\mathbf{R}_{\\mathrm{eq}}\\right)$.\n  - $\\mathbf{R}_0 = (0.4, 0.3)$, $\\mathbf{v} = (0.1, -0.2)$, $L = 0.5$.\n\n- Case $2$ (quadratic, non-conservative bug):\n  - Same $E(\\mathbf{R})$ and parameters as Case $1$.\n  - $\\mathbf{F}_{\\mathrm{impl}}(\\mathbf{R}) = -k \\left(\\mathbf{R} - \\mathbf{R}_{\\mathrm{eq}}\\right) + \\alpha\\,(-y, x)$ with $\\alpha = 0.05$ and $\\mathbf{R} = (x,y)$.\n  - $\\mathbf{R}_0 = (0.4, 0.3)$, $\\mathbf{v} = (0.1, 0.1)$, $L = 0.4$.\n\n- Case $3$ (anharmonic, consistent):\n  - $E(x,y) = \\tfrac{1}{4} a x^4 + \\tfrac{1}{2} b y^2 + c x y$ with $a = 1.2$, $b = 4.0$, $c = 0.7$.\n  - $\\mathbf{F}_{\\mathrm{impl}}(x,y) = \\left(-a x^3 - c y, -b y - c x\\right)$.\n  - $\\mathbf{R}_0 = (0.6, -0.25)$, $\\mathbf{v} = (-0.15, 0.3)$, $L = 0.3$.\n\n- Case $4$ (Lennard-Jones-like, directional bug):\n  - Define $r = \\sqrt{x^2 + y^2}$, and $E(x,y) = 4 \\varepsilon\\left[\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^6\\right]$ with $\\varepsilon = 1.0$, $\\sigma = 1.2$.\n  - Let $\\frac{dE}{dr} = 4 \\varepsilon\\left(-12 \\frac{\\sigma^{12}}{r^{13}} + 6 \\frac{\\sigma^6}{r^7}\\right)$. A correct conservative force is $\\mathbf{F}_{\\mathrm{true}} = -\\frac{dE}{dr}\\,\\frac{(x,y)}{r}$. The implemented force is buggy: $\\mathbf{F}_{\\mathrm{impl}}(x,y) = -\\frac{dE}{dr}\\,(1,1)$.\n  - $\\mathbf{R}_0 = (1.5, 0.8)$, $\\mathbf{v} = (0.05, -0.02)$, $L = 0.1$.\n\n- Case $5$ (linear potential, consistent):\n  - $E(x,y) = p_x x + p_y y$ with $p_x = -1.0$, $p_y = 2.5$.\n  - $\\mathbf{F}_{\\mathrm{impl}}(x,y) = -\\nabla E = (1.0, -2.5)$.\n  - $\\mathbf{R}_0 = (-0.2, 0.2)$, $\\mathbf{v} = (0.3, 0.4)$, $L = 0.2$.\n\nProgram requirements:\n- Implement the two numerical checks exactly as specified, using $h = 10^{-6}$ and $N = 8192$.\n- For each case, compute the boolean result indicating whether both checks pass.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4,result5]\"), where each result is the literal boolean token True or False.\n\nDesign the implementation to be robust for the provided test suite. All values are dimensionless; no additional unit conversions are required.", "solution": "The user has provided a scientifically and mathematically well-posed problem. The task is to implement two numerical checks to verify the consistency between a potential energy function $E(\\mathbf{R})$ and its corresponding force field $\\mathbf{F}_{\\mathrm{impl}}(\\mathbf{R})$ for several two-dimensional systems. This verification is fundamental in computational materials science, where the accuracy of simulated atomic forces is paramount. The Hellmann-Feynman theorem provides the quantum mechanical basis for the existence of such a conservative potential, stating that for a system in an electronic eigenstate, the force on a nucleus is precisely the negative gradient of the total energy with respect to the nuclear coordinates, $\\mathbf{F} = -\\nabla E(\\mathbf{R})$, provided the basis set is complete or position-independent. Violations of this relationship, often due to approximations or implementation errors (bugs), lead to non-conservative dynamics, causing issues like energy drift in microcanonical simulations. The problem requires the implementation of these checks and their application to five distinct test cases, some of which are designed to be consistent while others contain deliberate bugs that should be detected.\n\nThe solution will be structured as follows:\n1.  A primary function, `check_consistency`, that encapsulates the logic for both the local gradient check and the line integral check.\n2.  Implementation of the specific energy and force functions for each of the five test cases. These functions will be designed to be vectorized using NumPy for efficient computation, especially for the line integral evaluation.\n3.  A main orchestrator that defines the parameters for each test case, calls `check_consistency`, and formats the boolean results for output.\n\n### 1. Local Energy-Force Consistency Check\n\nThis check verifies the relationship $\\mathbf{F} = -\\nabla E$ at a single point $\\mathbf{R}_0$. The implemented force $\\mathbf{F}_{\\mathrm{impl}}(\\mathbf{R}_0)$ is compared against a numerical estimate of the true conservative force, which is the negative gradient of the energy, $-\\nabla E(\\mathbf{R}_0)$. The gradient is computed using a second-order central finite difference formula for each component $i$:\n$$\n\\frac{\\partial E}{\\partial R_i}(\\mathbf{R}_0) \\approx \\frac{E(\\mathbf{R}_0 + h \\,\\mathbf{e}_i) - E(\\mathbf{R}_0 - h \\,\\mathbf{e}_i)}{2h}\n$$\nHere, $\\mathbf{e}_i$ is the unit vector in the $i$-th direction and $h = 10^{-6}$ is the finite difference step size. The discrepancy is quantified by the normalized error metric $\\varepsilon_{\\mathrm{grad}}$:\n$$\n\\varepsilon_{\\mathrm{grad}} = \\frac{\\left\\|\\mathbf{F}_{\\mathrm{impl}}(\\mathbf{R}_0) + \\nabla E(\\mathbf{R}_0)\\right\\|_2}{\\max\\left(1, \\left\\|\\nabla E(\\mathbf{R}_0)\\right\\|_2\\right)}\n$$\nThe check passes if $\\varepsilon_{\\mathrm{grad}}$ is below a specified tolerance $\\tau_{\\mathrm{grad}} = 10^{-5}$. The denominator $\\max(1, \\dots)$ regularizes the error, preventing division by zero or amplification of numerical noise when the force is small.\n\n### 2. Line-Search Integrability Check\n\nThis check verifies the path-independence of the work done by the force, a hallmark of a conservative field. According to the gradient theorem, the work done by a conservative force $\\mathbf{F}=-\\nabla E$ along a path from $\\mathbf{R}_A$ to $\\mathbf{R}_B$ is equal to the negative of the change in potential energy, $W = E(\\mathbf{R}_A) - E(\\mathbf{R}_B)$, or $\\Delta E + W = 0$. We test this property along a straight line path $\\mathbf{R}(s) = \\mathbf{R}_0 + s\\,\\mathbf{v}$ for $s \\in [0,L]$. The work is calculated by the line integral:\n$$\nW = \\int_{0}^{L} \\mathbf{F}_{\\mathrm{impl}}(\\mathbf{R}(s)) \\cdot \\mathbf{v}\\, ds\n$$\nThis integral is computed numerically using the composite Simpson's rule with $N=8192$ subintervals. For an integrand $g(s)$ evaluated at $N+1$ points $s_i = i(L/N)$, the formula is:\n$$\n\\int_0^L g(s) ds \\approx \\frac{L/N}{3} \\left[g(s_0) + 4\\sum_{j=1}^{N/2} g(s_{2j-1}) + 2\\sum_{j=1}^{N/2-1} g(s_{2j}) + g(s_N)\\right]\n$$\nThe discrepancy is measured by $\\varepsilon_{\\mathrm{line}}$:\n$$\n\\varepsilon_{\\mathrm{line}} = \\frac{\\left| \\Delta E + W \\right|}{\\max\\left(1, \\left|\\Delta E\\right|\\right)}\n$$\nwhere $\\Delta E = E(\\mathbf{R}(L)) - E(\\mathbf{R}(0))$. The check passes if $\\varepsilon_{\\mathrm{line}}  \\tau_{\\mathrm{line}} = 10^{-5}$. This test is more global than the gradient check and can detect non-conservative curl components in the force field that might be missed by a local check at a high-symmetry point.\n\n### 3. Implementation and Vectorization\n\nThe test cases involve various potential forms (quadratic, anharmonic, Lennard-Jones-like, linear). To efficiently evaluate the line integral, the energy $E(\\mathbf{R})$ and force $\\mathbf{F}_{\\mathrm{impl}}(\\mathbf{R})$ functions are implemented to support vectorization. They are designed to accept either a single coordinate vector of shape $(2,)$ or an array of $M$ coordinate vectors of shape $(M, 2)$. This allows for the simultaneous evaluation of the integrand at all $N+1$ points required by Simpson's rule, significantly improving performance over a simple loop. Array-aware NumPy functions like `np.einsum`, `np.linalg.norm` with an `axis` argument, and careful broadcasting are used to achieve this.\n\nThe final program will define these functions for each of the five cases, pass them along with their respective parameters to the unified `check_consistency` routine, collect the boolean outcomes, and print them in the specified format. The outcomes are expected to be `True` for consistent cases (1, 3, 5) and `False` for buggy cases (2, 4), which serves as a validation of the implementation itself.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the energy-force consistency checks for all test cases.\n    \"\"\"\n\n    def check_consistency(E, F_impl, R0, v, L):\n        \"\"\"\n        Performs both gradient and line integral consistency checks for a given potential.\n\n        Args:\n            E (callable): Energy function E(R). Must be vectorized.\n            F_impl (callable): Implemented force function F_impl(R). Must be vectorized.\n            R0 (np.ndarray): Starting point of the path, shape (2,).\n            v (np.ndarray): Direction vector of the path, shape (2,).\n            L (float): Length of the path.\n\n        Returns:\n            bool: True if both checks pass, False otherwise.\n        \"\"\"\n        h = 1e-6\n        tau_grad = 1e-5\n        N = 8192\n        tau_line = 1e-5\n\n        # 1. Local energy-force consistency (gradient) check\n        # using central finite-difference\n        grad_E_num = np.array([\n            (E(R0 + np.array([h, 0.0])) - E(R0 - np.array([h, 0.0]))) / (2 * h),\n            (E(R0 + np.array([0.0, h])) - E(R0 - np.array([0.0, h]))) / (2 * h)\n        ])\n        \n        F_impl_R0 = F_impl(R0)\n        \n        numerator_grad = np.linalg.norm(F_impl_R0 + grad_E_num)\n        denominator_grad = max(1.0, np.linalg.norm(grad_E_num))\n        eps_grad = numerator_grad / denominator_grad\n        \n        grad_pass = eps_grad  tau_grad\n\n        # 2. Line-search integrability check\n        R_start = R0\n        R_end = R0 + L * v\n        delta_E = E(R_end) - E(R_start)\n        \n        # Numerically integrate W = integral(F_impl(R(s)) . v ds) from s=0 to L\n        # using composite Simpson's rule with N subintervals.\n        s_values = np.linspace(0.0, L, N + 1)\n        \n        # Vectorized evaluation of the integrand g(s) = F_impl(R(s)) . v\n        # R_path is an (N+1, 2) array of positions along the path\n        R_path = R0 + s_values[:, np.newaxis] * v\n        \n        # F_path is an (N+1, 2) array of forces.\n        F_path = F_impl(R_path)\n        \n        # integrand_values is an (N+1,) array\n        integrand_values = np.einsum('ij,j-i', F_path, v)\n        \n        # Composite Simpson's rule:\n        W = (L / N / 3.0) * (\n            integrand_values[0] + \n            4 * np.sum(integrand_values[1:-1:2]) + \n            2 * np.sum(integrand_values[2:-1:2]) + \n            integrand_values[-1]\n        )\n        \n        numerator_line = np.abs(delta_E + W)\n        denominator_line = max(1.0, np.abs(delta_E))\n        eps_line = numerator_line / denominator_line\n        \n        line_pass = eps_line  tau_line\n\n        return grad_pass and line_pass\n\n    # --- Define Test Cases ---\n    # The E and F functions are vectorized to handle single (2,) vectors\n    # and batches of vectors (M, 2).\n\n    # Case 1 (quadratic, consistent)\n    k1 = 2.5\n    Req1 = np.array([0.2, -0.1])\n    E1 = lambda R: 0.5 * k1 * np.einsum('...i,...i-...', R - Req1, R - Req1)\n    F1 = lambda R: -k1 * (R - Req1)\n\n    # Case 2 (quadratic, non-conservative bug)\n    k2 = 2.5\n    Req2 = np.array([0.2, -0.1])\n    alpha2 = 0.05\n    E2 = lambda R: 0.5 * k2 * np.einsum('...i,...i-...', R - Req2, R - Req2)\n    def F2(R):\n        F_cons = -k2 * (R - Req2)\n        x, y = R[..., 0], R[..., 1]\n        F_noncons = alpha2 * np.stack([-y, x], axis=-1)\n        return F_cons + F_noncons\n\n    # Case 3 (anharmonic, consistent)\n    a3, b3, c3 = 1.2, 4.0, 0.7\n    def E3(R):\n        x, y = R[..., 0], R[..., 1]\n        return 0.25 * a3 * x**4 + 0.5 * b3 * y**2 + c3 * x * y\n    def F3(R):\n        x, y = R[..., 0], R[..., 1]\n        Fx = -a3 * x**3 - c3 * y\n        Fy = -b3 * y - c3 * x\n        return np.stack([Fx, Fy], axis=-1)\n\n    # Case 4 (Lennard-Jones-like, directional bug)\n    eps4, sigma4 = 1.0, 1.2\n    def E4(R):\n        r = np.linalg.norm(R, axis=-1)\n        # Add a small epsilon to avoid division by zero at the origin, though not strictly needed for this problem's paths.\n        r = np.maximum(r, 1e-12)\n        s_over_r = sigma4 / r\n        return 4 * eps4 * (s_over_r**12 - s_over_r**6)\n    def F4(R):\n        axis = -1 if R.ndim  1 else None\n        keepdims = R.ndim  1\n        r = np.linalg.norm(R, axis=axis, keepdims=keepdims)\n        r = np.maximum(r, 1e-12)\n        dE_dr = 4 * eps4 * (-12 * sigma4**12 / r**13 + 6 * sigma4**6 / r**7)\n        return -dE_dr * np.array([1.0, 1.0])\n\n    # Case 5 (linear potential, consistent)\n    p_vec5 = np.array([-1.0, 2.5])\n    E5 = lambda R: np.einsum('...i,i-...', R, p_vec5)\n    F_const5 = -p_vec5\n    def F5(R):\n        if R.ndim == 1:\n            return F_const5\n        else:\n            return np.tile(F_const5, (R.shape[0], 1))\n            \n    test_cases_data = [\n        {\"E\": E1, \"F_impl\": F1, \"R0\": np.array([0.4, 0.3]), \"v\": np.array([0.1, -0.2]), \"L\": 0.5},\n        {\"E\": E2, \"F_impl\": F2, \"R0\": np.array([0.4, 0.3]), \"v\": np.array([0.1, 0.1]), \"L\": 0.4},\n        {\"E\": E3, \"F_impl\": F3, \"R0\": np.array([0.6, -0.25]), \"v\": np.array([-0.15, 0.3]), \"L\": 0.3},\n        {\"E\": E4, \"F_impl\": F4, \"R0\": np.array([1.5, 0.8]), \"v\": np.array([0.05, -0.02]), \"L\": 0.1},\n        {\"E\": E5, \"F_impl\": F5, \"R0\": np.array([-0.2, 0.2]), \"v\": np.array([0.3, 0.4]), \"L\": 0.2},\n    ]\n\n    results = []\n    for case in test_cases_data:\n        result = check_consistency(case[\"E\"], case[\"F_impl\"], case[\"R0\"], case[\"v\"], case[\"L\"])\n        results.append(result)\n        \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3456500"}, {"introduction": "Beyond being conservative, physically meaningful forces must respect the fundamental symmetries of space, namely translational and rotational invariance. These symmetries dictate that the total force and total torque on an isolated system must vanish—constraints known as the acoustic sum rule and the zero-torque condition. This exercise introduces an advanced post-processing technique to enforce these physical laws on numerically computed forces, which may contain small errors that violate these symmetries [@problem_id:3456501]. You will implement a projection operator to map a set of noisy forces onto the physically valid subspace, a crucial step for ensuring the integrity of subsequent calculations like phonon dispersion relations.", "problem": "You are given a set of atomic positions and noisy Hellmann-Feynman forces for several systems. In computational materials science, the invariance of the total energy under rigid translation and rotation implies that the physically consistent forces must satisfy two linear constraints simultaneously: the acoustic sum rule and the zero-torque condition. From first principles, the invariance of the total energy under an infinitesimal rigid translation $\\delta \\mathbf{r}_I = \\mathbf{t}$ for all atoms implies $\\sum_I \\mathbf{F}_I = \\mathbf{0}$. Similarly, invariance under an infinitesimal rigid rotation $\\delta \\mathbf{r}_I = \\boldsymbol{\\omega} \\times (\\mathbf{r}_I - \\mathbf{r}_0)$ implies $\\sum_I (\\mathbf{r}_I - \\mathbf{r}_0) \\times \\mathbf{F}_I = \\mathbf{0}$ for any chosen origin $\\mathbf{r}_0$. A scientifically sound post-processing approach is to find the closest set of forces to the given noisy forces that satisfies these linear constraints.\n\nStarting only from these fundamental invariances and linear algebra, derive and implement an algorithm that, for a given system with $N$ atoms and their positions $\\{\\mathbf{r}_I\\}_{I=1}^N$ in $\\text{\\AA}$ and forces $\\{\\mathbf{F}_I\\}_{I=1}^N$ in $\\text{eV}/\\text{\\AA}$, constructs a linear projector that maps the noisy force vector to the unique closest vector (in the Euclidean norm) that satisfies both $\\sum_I \\mathbf{F}_I = \\mathbf{0}$ and $\\sum_I (\\mathbf{r}_I - \\mathbf{r}_0) \\times \\mathbf{F}_I = \\mathbf{0}$. Use the geometric centroid $\\mathbf{r}_0 = \\frac{1}{N}\\sum_I \\mathbf{r}_I$ as the origin for the torque constraint. For numerical robustness and physical unit consistency when aggregating constraint violations, scale the torque constraints by $1/\\ell$, where $\\ell = \\sqrt{\\frac{1}{N}\\sum_I \\|\\mathbf{r}_I - \\mathbf{r}_0\\|^2}$ is the root-mean-square distance in $\\text{\\AA}$. This ensures that the aggregated constraint vector has unit $\\text{eV}/\\text{\\AA}$.\n\nDefine the $3N$-vector of forces as $\\mathbf{f} = [\\mathbf{F}_1^\\top,\\dots,\\mathbf{F}_N^\\top]^\\top$ and construct a $6 \\times 3N$ constraint matrix $\\mathbf{A}$ that enforces the three components of $\\sum_I \\mathbf{F}_I = \\mathbf{0}$ and the three components of $\\sum_I \\frac{1}{\\ell}(\\mathbf{r}_I - \\mathbf{r}_0) \\times \\mathbf{F}_I = \\mathbf{0}$ as linear equations in $\\mathbf{f}$. Then compute the orthogonal projection of $\\mathbf{f}$ onto the null space of $\\mathbf{A}$. In degenerate geometries where $\\ell \\approx 0$ or the constraint rows are linearly dependent, your algorithm must remain stable by using a Moore-Penrose pseudoinverse. Your program must produce, for each test case, an evaluation list containing:\n- the pre-projection violation norm $\\|\\mathbf{A}\\mathbf{f}\\|_2$ in $\\text{eV}/\\text{\\AA}$,\n- the post-projection violation norm $\\|\\mathbf{A}\\mathbf{f}^\\star\\|_2$ in $\\text{eV}/\\text{\\AA}$, where $\\mathbf{f}^\\star$ is the cleaned force vector,\n- the correction norm $\\|\\mathbf{f}^\\star - \\mathbf{f}\\|_2$ in $\\text{eV}/\\text{\\AA}$,\n- the numerical rank of $\\mathbf{A}$ as an integer.\n\nAll angles must be treated in radians conceptually, but no explicit angle quantities are part of the input or output. The final output format must be a single line containing a comma-separated list of these per-case evaluation lists, with no spaces, enclosed in square brackets, for example, $[[a_1,b_1,c_1,d_1],[a_2,b_2,c_2,d_2],\\dots]$.\n\nUse the following test suite, which includes a general case, a constraint-satisfying case, a degenerate geometry, and a near-colinear arrangement. For each case, positions are given in $\\text{\\AA}$ and forces are given in $\\text{eV}/\\text{\\AA}$:\n\n- Case $1$ (general noisy triatomic):\n  - Positions: $\\left[(0.0,0.0,0.0),(1.5,-0.2,0.3),(-0.7,0.6,-0.1)\\right]$\n  - Forces: $\\left[(0.21,-0.12,0.03),(-0.09,0.04,-0.11),(-0.08,0.12,0.07)\\right]$\n- Case $2$ (already consistent tetra-atomic):\n  - Positions: $\\left[(0.0,0.0,0.0),(1.0,0.0,0.0),(0.0,1.0,0.0),(0.0,0.0,1.0)\\right]$\n  - Forces: $\\left[(-2.0,1.0,1.0),(2.0,0.0,0.0),(0.0,-1.0,0.0),(0.0,0.0,-1.0)\\right]$\n- Case $3$ (degenerate geometry; all atoms at the origin):\n  - Positions: $\\left[(0.0,0.0,0.0),(0.0,0.0,0.0),(0.0,0.0,0.0)\\right]$\n  - Forces: $\\left[(0.3,-0.1,0.2),(0.05,0.08,-0.05),(-0.2,0.04,0.01)\\right]$\n- Case $4$ (near-colinear penta-atomic):\n  - Positions: $\\left[(0.0,0.0,0.0),(0.5,0.02,-0.01),(1.0,-0.03,0.0),(1.5,0.01,0.02),(2.0,-0.02,-0.01)\\right]$\n  - Forces: $\\left[(0.12,-0.05,0.03),(-0.07,0.04,-0.02),(0.09,0.02,0.01),(-0.03,-0.01,0.05),(0.04,0.0,-0.08)\\right]$\n\nYour program must implement the projector, apply it to each case, and compute the four evaluation quantities per case as described. Express all three norms in $\\text{eV}/\\text{\\AA}$ and the rank as an integer. The final printed output must be a single line containing the per-case evaluation lists, comma-separated, enclosed in square brackets, with no spaces.", "solution": "The posed problem is to find a set of atomic forces, $\\mathbf{f}^\\star$, that is closest in the Euclidean sense to a given set of noisy forces, $\\mathbf{f}$, while strictly satisfying the physical constraints of translation and rotation invariance. These constraints manifest as the acoustic sum rule (ASR) and the zero-torque condition (ZTC). This is a classic constrained optimization problem, which can be elegantly solved using orthogonal projection.\n\nThe problem can be stated mathematically as:\n$$\n\\underset{\\mathbf{f}^\\star}{\\text{minimize}} \\quad \\frac{1}{2} \\|\\mathbf{f}^\\star - \\mathbf{f}\\|_2^2 \\\\\n\\text{subject to} \\quad \\mathbf{A}\\mathbf{f}^\\star = \\mathbf{0}\n$$\nHere, $\\mathbf{f}$ is the $3N$-dimensional vector of concatenated noisy atomic forces, $\\mathbf{f} = [\\mathbf{F}_1^\\top, \\dots, \\mathbf{F}_N^\\top]^\\top$, for a system of $N$ atoms. The matrix $\\mathbf{A}$ is a $6 \\times 3N$ matrix that encodes the six linear constraints (three for ASR, three for ZTC). The solution $\\mathbf{f}^\\star$ is the orthogonal projection of the initial vector $\\mathbf{f}$ onto the null space of the matrix $\\mathbf{A}$, denoted $\\text{Null}(\\mathbf{A})$. This subspace contains all force vectors that satisfy the physical constraints.\n\nThe projector onto the null space is given by $\\mathbf{P}_{\\text{null}} = \\mathbf{I} - \\mathbf{A}^\\dagger \\mathbf{A}$, where $\\mathbf{I}$ is the $3N \\times 3N$ identity matrix and $\\mathbf{A}^\\dagger$ is the Moore-Penrose pseudoinverse of $\\mathbf{A}$. The corrected force vector is thus $\\mathbf{f}^\\star = \\mathbf{P}_{\\text{null}}\\mathbf{f}$. A direct computation involving the $3N \\times 3N$ projector matrix is inefficient. A more stable and efficient algorithm is derived by noting that the correction vector, $\\delta\\mathbf{f} = \\mathbf{f} - \\mathbf{f}^\\star$, is the projection of $\\mathbf{f}$ onto the row space of $\\mathbf{A}$. This projection can be written as $\\delta\\mathbf{f} = \\mathbf{A}^\\top \\boldsymbol{\\lambda}$, where $\\boldsymbol{\\lambda} \\in \\mathbb{R}^6$ is a vector of Lagrange multipliers. Solving for $\\boldsymbol{\\lambda}$ via the normal equations yields $\\boldsymbol{\\lambda} = (\\mathbf{A}\\mathbf{A}^\\top)^\\dagger (\\mathbf{A}\\mathbf{f})$. The corrected force vector is then:\n$$\n\\mathbf{f}^\\star = \\mathbf{f} - \\delta\\mathbf{f} = \\mathbf{f} - \\mathbf{A}^\\top(\\mathbf{A}\\mathbf{A}^\\top)^\\dagger(\\mathbf{A}\\mathbf{f})\n$$\nThis approach requires the pseudoinverse of a much smaller $6 \\times 6$ matrix, $\\mathbf{A}\\mathbf{A}^\\top$, ensuring numerical robustness and efficiency.\n\nThe construction of the constraint matrix $\\mathbf{A}$ is a critical step. It is built from $N$ concatenated $6 \\times 3$ blocks, $\\mathbf{A} = [\\mathbf{A}_1, \\mathbf{A}_2, \\dots, \\mathbf{A}_N]$, where each block $\\mathbf{A}_I$ pertains to atom $I$.\n\nThe first $3$ rows of $\\mathbf{A}$ enforce the ASR, $\\sum_I \\mathbf{F}_I = \\mathbf{0}$. The contribution of each atom's force vector $\\mathbf{F}_I$ to this sum is linear and unweighted. Therefore, the top $3 \\times 3$ sub-block of each $\\mathbf{A}_I$ is the identity matrix, $\\mathbf{I}_3$.\n\nThe last $3$ rows enforce the scaled ZTC, $\\sum_I \\frac{1}{\\ell}(\\mathbf{r}_I - \\mathbf{r}_0) \\times \\mathbf{F}_I = \\mathbf{0}$. Here, $\\mathbf{r}_0 = \\frac{1}{N}\\sum_J \\mathbf{r}_J$ is the geometric centroid and $\\ell = \\sqrt{\\frac{1}{N}\\sum_J \\|\\mathbf{r}_J - \\mathbf{r}_0\\|^2}$ is the root-mean-square distance, which provides a characteristic length scale for the system. Let $\\Delta\\mathbf{r}_I = \\mathbf{r}_I - \\mathbf{r}_0$. The cross product can be written using a skew-symmetric matrix, $[\\Delta\\mathbf{r}_I]_\\times$, such that $\\Delta\\mathbf{r}_I \\times \\mathbf{F}_I = [\\Delta\\mathbf{r}_I]_\\times \\mathbf{F}_I$.\n$$\n[\\Delta\\mathbf{r}_I]_\\times = \\begin{pmatrix} 0  -\\Delta z_I  \\Delta y_I \\\\ \\Delta z_I  0  -\\Delta x_I \\\\ -\\Delta y_I  \\Delta x_I  0 \\end{pmatrix}\n$$\nThe bottom $3 \\times 3$ sub-block of $\\mathbf{A}_I$ is therefore $\\frac{1}{\\ell}[\\Delta\\mathbf{r}_I]_\\times$. The full block for atom $I$ is $\\mathbf{A}_I = \\begin{pmatrix} \\mathbf{I}_3 \\\\ \\frac{1}{\\ell} [\\Delta\\mathbf{r}_I]_{\\times} \\end{pmatrix}$.\n\nThe algorithm must robustly handle degenerate geometries. If all atoms are at the same position, $\\ell = 0$. The ZTC is trivially satisfied, and the corresponding rows in $\\mathbf{A}$ must be zero to reflect this. The implementation checks if $\\ell$ is below a numerical tolerance and if so, the ZTC rows are not constructed. In cases of near-colinear atomic arrangements, the ZTC rows become nearly linearly dependent. The use of the Moore-Penrose pseudoinverse, as provided by `numpy.linalg.pinv`, correctly handles this by working with the numerical rank of the matrix, ensuring a stable and accurate projection.\n\nThe implementation calculates four evaluation metrics:\n1.  Pre-projection violation norm, $\\|\\mathbf{A}\\mathbf{f}\\|_2$: The norm of the constraint violations for the initial noisy forces.\n2.  Post-projection violation norm, $\\|\\mathbf{A}\\mathbf{f}^\\star\\|_2$: The norm of the violations for the cleaned forces, which should be numerically close to $0$.\n3.  Correction norm, $\\|\\mathbf{f}^\\star - \\mathbf{f}\\|_2$: The magnitude of the change applied to the forces.\n4.  The numerical rank of $\\mathbf{A}$: An integer indicating the number of linearly independent constraints, determined using a singular value decomposition-based method.\n\nThis procedure provides a physically sound and numerically stable method to \"clean\" noisy ab initio forces, ensuring they conform to fundamental symmetries.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and implements an algorithm to project noisy Hellmann-Feynman forces\n    onto the subspace of physically consistent forces satisfying the acoustic sum\n    rule and zero-torque condition.\n    \"\"\"\n    test_cases = [\n        {\n            \"positions\": np.array([[0.0, 0.0, 0.0], [1.5, -0.2, 0.3], [-0.7, 0.6, -0.1]]),\n            \"forces\": np.array([[0.21, -0.12, 0.03], [-0.09, 0.04, -0.11], [-0.08, 0.12, 0.07]]),\n        },\n        {\n            \"positions\": np.array([[0.0, 0.0, 0.0], [1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]),\n            \"forces\": np.array([[-2.0, 1.0, 1.0], [2.0, 0.0, 0.0], [0.0, -1.0, 0.0], [0.0, 0.0, -1.0]]),\n        },\n        {\n            \"positions\": np.array([[0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0]]),\n            \"forces\": np.array([[0.3, -0.1, 0.2], [0.05, 0.08, -0.05], [-0.2, 0.04, 0.01]]),\n        },\n        {\n            \"positions\": np.array([[0.0, 0.0, 0.0], [0.5, 0.02, -0.01], [1.0, -0.03, 0.0], [1.5, 0.01, 0.02], [2.0, -0.02, -0.01]]),\n            \"forces\": np.array([[0.12, -0.05, 0.03], [-0.07, 0.04, -0.02], [0.09, 0.02, 0.01], [-0.03, -0.01, 0.05], [0.04, 0.0, -0.08]]),\n        }\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        positions = case[\"positions\"]\n        forces = case[\"forces\"]\n        \n        N = positions.shape[0]\n        dim = positions.shape[1]\n        \n        # Flatten force vector\n        f = forces.flatten()\n        \n        # 1. Calculate geometric centroid and RMS distance\n        r0 = np.mean(positions, axis=0)\n        delta_r = positions - r0\n        ell_sq = np.mean(np.sum(delta_r**2, axis=1))\n        \n        # Use a small tolerance for ell\n        ell = np.sqrt(ell_sq) if ell_sq  1e-12 else 0.0\n        \n        # 2. Construct the 6x3N constraint matrix A\n        A = np.zeros((2 * dim, N * dim))\n        \n        for i in range(N):\n            # Acoustic Sum Rule part (ASR)\n            A[0:dim, i*dim:(i+1)*dim] = np.identity(dim)\n            \n            # Zero-Torque Condition part (ZTC)\n            if ell  1e-9:\n                dr = delta_r[i]\n                # Skew-symmetric matrix for cross product\n                skew_matrix = np.array([\n                    [0, -dr[2], dr[1]],\n                    [dr[2], 0, -dr[0]],\n                    [-dr[1], dr[0], 0]\n                ])\n                A[dim:2*dim, i*dim:(i+1)*dim] = (1.0 / ell) * skew_matrix\n\n        # 3. Calculate pre-projection violation\n        pre_violation = A @ f\n        pre_violation_norm = np.linalg.norm(pre_violation)\n        \n        # 4. Compute the projector and apply it\n        # Efficient method: f_star = f - A.T @ pinv(A @ A.T) @ (A @ f)\n        G = A @ A.T  # 6x6 matrix\n        G_pinv = np.linalg.pinv(G)\n        \n        # Correction vector\n        delta_f = A.T @ G_pinv @ pre_violation\n        f_star = f - delta_f\n        \n        # 5. Calculate post-projection violation\n        post_violation = A @ f_star\n        post_violation_norm = np.linalg.norm(post_violation)\n        \n        # 6. Calculate correction norm\n        correction_norm = np.linalg.norm(delta_f)\n        \n        # 7. Calculate numerical rank of A\n        rank_A = np.linalg.matrix_rank(A)\n        \n        all_results.append([\n            pre_violation_norm,\n            post_violation_norm,\n            correction_norm,\n            rank_A\n        ])\n\n    # Format the final output string as requested\n    print(str(all_results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "3456501"}]}