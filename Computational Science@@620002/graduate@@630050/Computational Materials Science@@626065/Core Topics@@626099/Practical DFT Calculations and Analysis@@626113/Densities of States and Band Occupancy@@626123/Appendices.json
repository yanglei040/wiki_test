{"hands_on_practices": [{"introduction": "The shape of the density of states (DOS), $g(E)$, is a foundational property of a material that dictates many of its electronic characteristics, and it depends critically on the system's dimensionality. This practice explores the classic power-law relationships for the DOS near a parabolic band edge in one, two, and three dimensions. By numerically verifying that $g(E)$ is proportional to $(E-E_c)^{-1/2}$, constant, and $(E-E_c)^{1/2}$ for 1D, 2D, and 3D systems, respectively, you will build a concrete understanding of how dimensionality shapes the electronic landscape and gain hands-on experience with k-space integration [@problem_id:3443154].", "problem": "Consider a single isotropic parabolic conduction band in dimension $d\\in\\{1,2,3\\}$ with dispersion $E(\\mathbf{k}) = E_c + \\alpha \\|\\mathbf{k}\\|^2$, where $E_c$ is the conduction band minimum energy and $\\alpha0$ is a constant. Work in nondimensional units where $E_c=0$ and $\\alpha=1$, so that $E(\\mathbf{k}) = \\|\\mathbf{k}\\|^2$. In these units, energies are dimensionless and temperature is represented by $\\theta = k_{\\mathrm{B}} T$ in the same dimensionless energy units. The Density of States (DOS) $g(E)$ and the electron concentration $n(T)$ are defined as follows.\n\nFundamental base:\n- The Density of States (DOS) is defined by $g(E) = \\int \\delta(E - E(\\mathbf{k}))\\, d^d\\mathbf{k}$.\n- The electron concentration is defined by $n(T) = \\int_{0}^{\\infty} g(E)\\, f(E;E_f,\\theta)\\, dE$, where $f(E;E_f,\\theta) = \\frac{1}{1+\\exp\\left(\\frac{E - E_f}{\\theta}\\right)}$ is the Fermi–Dirac distribution, $E_f$ is the Fermi level, and $\\theta$ is the dimensionless thermal energy.\n\nYour task is to numerically verify the dimensionality dependence of $g(E)$ near the band edge and analyze the consequence for $n(T)$ near the band edge. Specifically:\n\n1. For each $d\\in\\{1,2,3\\}$, estimate the power-law exponent $\\alpha_d$ such that $g(E)\\propto (E - E_c)^{\\alpha_d}$ in the low-energy window $E\\in[E_{\\min},E_{\\max}]$. Use $E_{\\min}=10^{-6}$ and $E_{\\max}=5\\times 10^{-2}$. Compute $g(E)$ numerically by transforming to hyperspherical coordinates and discretizing the radial coordinate on a uniform grid $r\\in[r_{\\min},r_{\\max}]$ with $r_{\\min}=10^{-4}$ and $r_{\\max}=2.0$. Fit the slope of $\\ln g(E)$ versus $\\ln(E-E_c)$ over the specified energy window to obtain $\\alpha_d$. Return the three estimated exponents as floats rounded to three decimal places.\n\n2. For each $d\\in\\{1,2,3\\}$, analyze the temperature dependence of $n(T)$ near the band edge when $E_f=E_c$. Use the same radial discretization as in part 1 to compute $n(T)$ via the $k$-space integral (i.e., by integrating the occupancy over $d$-dimensional $k$-space measure) for three temperatures $\\theta\\in\\{0.005,0.01,0.02\\}$. Fit a slope $\\beta_d$ from $\\ln n$ versus $\\ln \\theta$ to characterize the power-law dependence $n(T)\\propto \\theta^{\\beta_d}$ at the band edge. Return the three estimated slopes $\\beta_d$ as floats rounded to three decimal places.\n\n3. For each $d\\in\\{1,2,3\\}$, set $E_f=E_c-\\Delta$ with $\\Delta=0.2$ and estimate the effective activation energy from the temperature dependence of $n(T)$ at low temperatures. Compute $n(T)$ for two temperatures $\\theta_1=0.005$ and $\\theta_2=0.01$ using the $k$-space integral. Estimate $\\Delta_d$ from the finite-difference approximation\n$$\n\\Delta_d \\approx -\\frac{\\ln n(\\theta_2)-\\ln n(\\theta_1)}{\\frac{1}{\\theta_2}-\\frac{1}{\\theta_1}}.\n$$\nReturn the three estimated activation energies $\\Delta_d$ as floats rounded to three decimal places.\n\nImplementation requirements:\n- Use only nondimensional units. No physical units are required.\n- Angles do not appear; no angle unit specification is needed.\n- For the integrals in parts 2 and 3, compute $n(T)$ using the $k$-space measure with the radial integral $\\int_0^{r_{\\max}} r^{d-1} f(r^2;E_f,\\theta)\\, dr$ discretized on the same uniform grid $r\\in[r_{\\min},r_{\\max}]$ with $r_{\\min}=10^{-4}$ and $r_{\\max}=2.0$. Use a numerically stable integration rule.\n- Design your program to be fully self-contained with no external input.\n\nTest suite:\n- DOS exponent estimation: dimensions $d=1,2,3$ with the specified energy window and radial grid to obtain $\\alpha_1,\\alpha_2,\\alpha_3$.\n- Temperature scaling at the edge: dimensions $d=1,2,3$ with $E_f=E_c$ and temperatures $\\theta=\\{0.005,0.01,0.02\\}$ to obtain $\\beta_1,\\beta_2,\\beta_3$.\n- Activation energy estimation: dimensions $d=1,2,3$ with $E_f=E_c-\\Delta$, $\\Delta=0.2$, and temperatures $\\theta_1=0.005$, $\\theta_2=0.01$ to obtain $\\Delta_1,\\Delta_2,\\Delta_3$.\n\nFinal output format:\nYour program should produce a single line of output containing nine results as a comma-separated list enclosed in square brackets:\n$[\\alpha_1,\\alpha_2,\\alpha_3,\\beta_1,\\beta_2,\\beta_3,\\Delta_1,\\Delta_2,\\Delta_3]$,\nwhere each entry is a float rounded to three decimal places.", "solution": "The problem requires a numerical investigation of the density of states (DOS) and electron concentration for a simplified model of a semiconductor conduction band. The analysis will be performed for dimensions $d \\in \\{1, 2, 3\\}$. The problem is scientifically well-posed and provides all necessary parameters for a numerical solution. The solution is developed in three parts as specified.\n\n### Part 1: Density of States (DOS) Exponent $\\alpha_d$\n\nThe energy dispersion relation is given in nondimensional units as $E(\\mathbf{k}) = \\|\\mathbf{k}\\|^2$. Let's use $k$ to denote the magnitude of the wavevector $\\|\\mathbf{k}\\|$, so $E(k) = k^2$. The Density of States $g(E)$ is defined such that $g(E)dE$ gives the number of states in the energy interval $[E, E+dE]$. The total number of states up to an energy $E$, known as the integrated DOS $\\mathcal{N}(E)$, is proportional to the volume of the $d$-dimensional hypersphere in $k$-space with radius $k=\\sqrt{E}$. The volume of a $d$-sphere of radius $k$ is proportional to $k^d$.\n\nTherefore, the integrated DOS is:\n$$\n\\mathcal{N}(E) \\propto k^d = (E^{1/2})^d = E^{d/2}\n$$\nThe DOS is the derivative of the integrated DOS with respect to energy:\n$$\ng(E) = \\frac{d\\mathcal{N}(E)}{dE} \\propto \\frac{d}{dE}(E^{d/2}) = \\frac{d}{2} E^{d/2 - 1}\n$$\nThis predicts the power-law relationship $g(E) \\propto E^{\\alpha_d}$, where the theoretical exponent is $\\alpha_d = \\frac{d}{2} - 1$. The expected values are $\\alpha_1 = -0.5$, $\\alpha_2 = 0$, and $\\alpha_3 = 0.5$.\n\nTo verify this numerically as requested, we discretize the radial coordinate $k$ (denoted as $r$ in the problem) on a uniform grid. The number of states $\\Delta\\mathcal{N}$ in a thin shell between radii $k_1$ and $k_2$ is proportional to the volume of that shell, $\\Delta\\mathcal{N} \\propto k_2^d - k_1^d$. The corresponding energy interval is $\\Delta E = k_2^2 - k_1^2$. The DOS at the midpoint energy $E \\approx (k_1^2+k_2^2)/2$ can be approximated by the finite difference:\n$$\ng(E) \\approx \\frac{\\Delta\\mathcal{N}}{\\Delta E} \\propto \\frac{k_2^d - k_1^d}{k_2^2 - k_1^2}\n$$\nWe compute these values over the specified radial grid. Then, we fit a line to the logarithm of the computed DOS versus the logarithm of energy, $\\ln g(E)$ vs. $\\ln E$. The slope of this line provides a numerical estimate for the exponent $\\alpha_d$.\n\n### Part 2: Temperature Scaling at the Band Edge ($\\beta_d$)\n\nThe electron concentration $n(T)$ is given by the integral of the product of the DOS and the Fermi-Dirac distribution $f(E;E_f,\\theta)$ over all energies.\n$$\nn(T) = \\int_0^\\infty g(E) f(E; E_f, \\theta) dE\n$$\nThis integral can be transformed into an integral over $k$-space:\n$$\nn(T) = \\int f(E(\\mathbf{k});E_f,\\theta) \\, d^d\\mathbf{k}\n$$\nSwitching to hyperspherical coordinates, where the volume element is $d^d\\mathbf{k} \\propto k^{d-1}dk$, the expression for $n(T)$ becomes (up to a constant prefactor):\n$$\nn(T) \\propto \\int_0^\\infty k^{d-1} f(k^2; E_f, \\theta) dk\n$$\nIn this part, we set the Fermi level to the band minimum, $E_f=E_c=0$. The integral is computed numerically using the trapezoidal rule on the specified discrete radial grid $r \\in [r_{\\min}, r_{\\max}]$. We compute $n(T)$ for three temperatures $\\theta \\in \\{0.005, 0.01, 0.02\\}$. The power-law dependence $n(T) \\propto \\theta^{\\beta_d}$ is determined by fitting a line to $\\ln n(T)$ versus $\\ln \\theta$. The slope of this line is the desired exponent $\\beta_d$.\n\n### Part 3: Activation Energy Estimation ($\\Delta_d$)\n\nThis part investigates the low-temperature behavior when the Fermi level is inside the band gap, $E_f = E_c - \\Delta = -0.2$. In this non-degenerate limit, where $(E-E_f) \\gg \\theta$, the Fermi-Dirac distribution can be approximated by the Maxwell-Boltzmann distribution:\n$$\nf(E; E_f, \\theta) \\approx \\exp\\left(-\\frac{E-E_f}{\\theta}\\right) = \\exp\\left(\\frac{E_f}{\\theta}\\right)\\exp\\left(-\\frac{E}{\\theta}\\right)\n$$\nSubstituting this into the integral for $n(T)$ gives a temperature dependence dominated by an Arrhenius-like term:\n$$\nn(T) \\propto \\exp\\left(\\frac{E_f}{\\theta}\\right) \\propto \\exp\\left(-\\frac{\\Delta}{\\theta}\\right)\n$$\nAn Arrhenius plot of $\\ln n(T)$ versus $1/\\theta$ would yield a line with slope $-\\Delta$. The problem specifies a two-point finite-difference formula to estimate this slope, which is equivalent to calculating the slope between two points on the Arrhenius plot:\n$$\n\\Delta_d \\approx -\\frac{\\ln n(\\theta_2)-\\ln n(\\theta_1)}{\\frac{1}{\\theta_2}-\\frac{1}{\\theta_1}}\n$$\nWe compute $n(T)$ for $\\theta_1=0.005$ and $\\theta_2=0.01$ using the same numerical integration method as in Part 2, and then apply the formula to find the estimated activation energy $\\Delta_d$ for each dimension.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the three-part problem to determine dimensionality-dependent\n    properties of a parabolic band model. The results are collected and\n    printed in the specified format.\n    \"\"\"\n\n    # --- Global numerical parameters ---\n    r_min = 1e-4\n    r_max = 2.0\n    # A high number of points ensures accuracy for both finite difference and integration.\n    num_r_points = 500000 \n\n    # --- Result storage ---\n    all_results = []\n\n    # =================================================================\n    # Part 1: Estimate DOS power-law exponent alpha_d\n    # =================================================================\n    E_min_fit = 1e-6\n    E_max_fit = 5e-2\n    \n    # Generate a fine, uniform radial grid in k-space (denoted as r)\n    r = np.linspace(r_min, r_max, num_r_points)\n    r_inner = r[:-1]\n    r_outer = r[1:]\n    \n    # Energy grid corresponding to the midpoints of the r-grid shells\n    E_mid = (r_outer**2 + r_inner**2) / 2.0\n    \n    # Energy width of each shell\n    dE = r_outer**2 - r_inner**2\n    \n    with np.errstate(divide='ignore', invalid='ignore'):\n        for d in [1, 2, 3]:\n            # Number of states in a k-space shell is proportional to its volume.\n            # Volume of a hyperspherical shell is proportional to (k_outer^d - k_inner^d).\n            dN = r_outer**d - r_inner**d\n            \n            # DOS N(E) is d(NumStates)/dE, approximated by finite differences.\n            N_E = dN / dE\n            \n            # For d=2, dN is proportional to (r_outer^2 - r_inner^2), so N_E is a constant.\n            # Handle this case explicitly to avoid potential floating point issues.\n            if d == 2:\n                N_E = np.ones_like(E_mid)\n\n            # Filter data to the specified energy fitting window\n            fit_mask = (E_mid = E_min_fit)  (E_mid = E_max_fit)\n            E_fit = E_mid[fit_mask]\n            N_fit = N_E[fit_mask]\n\n            # Perform linear regression on log-log data to find the exponent\n            log_E = np.log(E_fit)\n            log_N = np.log(N_fit)\n            \n            # np.polyfit(x, y, 1) returns [slope, intercept]\n            alpha_d, _ = np.polyfit(log_E, log_N, 1)\n            all_results.append(alpha_d)\n\n    # =================================================================\n    # Part 2: Estimate temperature scaling exponent beta_d\n    # =================================================================\n    thetas_beta = np.array([0.005, 0.01, 0.02])\n    E_f_beta = 0.0  # Fermi level at the band edge\n\n    for d in [1, 2, 3]:\n        n_vals = []\n        for theta in thetas_beta:\n            # Integrand: k^(d-1) * f(E(k); E_f, theta)\n            exp_arg = (r**2 - E_f_beta) / theta\n            fermi_dirac = 1.0 / (1.0 + np.exp(exp_arg))\n            integrand = r**(d-1) * fermi_dirac\n            \n            # Numerically integrate using the trapezoidal rule\n            n_val = np.trapz(integrand, r)\n            n_vals.append(n_val)\n        \n        # Perform linear regression on log-log data\n        log_n = np.log(n_vals)\n        log_theta = np.log(thetas_beta)\n        \n        beta_d, _ = np.polyfit(log_theta, log_n, 1)\n        all_results.append(beta_d)\n\n    # =================================================================\n    # Part 3: Estimate activation energy Delta_d\n    # =================================================================\n    E_f_delta = -0.2\n    theta1_delta = 0.005\n    theta2_delta = 0.01\n\n    for d in [1, 2, 3]:\n        # Calculate n(theta1)\n        exp_arg1 = (r**2 - E_f_delta) / theta1_delta\n        fermi_dirac1 = 1.0 / (1.0 + np.exp(exp_arg1))\n        integrand1 = r**(d-1) * fermi_dirac1\n        n1 = np.trapz(integrand1, r)\n        \n        # Calculate n(theta2)\n        exp_arg2 = (r**2 - E_f_delta) / theta2_delta\n        fermi_dirac2 = 1.0 / (1.0 + np.exp(exp_arg2))\n        integrand2 = r**(d-1) * fermi_dirac2\n        n2 = np.trapz(integrand2, r)\n        \n        # Apply the finite-difference formula for activation energy\n        delta_d = -(np.log(n2) - np.log(n1)) / (1.0/theta2_delta - 1.0/theta1_delta)\n        all_results.append(delta_d)\n    \n    # --- Final Output ---\n    # Format the results to three decimal places as required by the problem statement\n    formatted_results = [f\"{x:.3f}\" for x in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3443154"}, {"introduction": "A core task in any electronic structure calculation is to determine the chemical potential, $\\mu$, that corresponds to the known number of electrons in the system at a given temperature. This exercise guides you through implementing a robust numerical solver to find the value of $\\mu$ that satisfies the electron number constraint $N_e = \\int g(E) f(E, \\mu, T) dE$. Mastering this self-consistent procedure is essential for simulating metals or doped semiconductors and for understanding how band filling is handled in real-world density functional theory codes [@problem_id:3443117].", "problem": "Implement a finite-temperature chemical potential solver that adjusts the chemical potential $\\,\\mu\\,$ to satisfy the electron number constraint\n$$\nN_e(\\mu,T) \\;=\\; \\int_{-\\infty}^{+\\infty} g(E)\\, f(E,\\mu,T)\\, dE \\,,\n$$\nwhere $\\,g(E)\\,$ is the electronic density of states and $\\,f(E,\\mu,T)\\,$ is the Fermi–Dirac distribution. Your implementation must be grounded in a tight-binding model and use discrete $\\,k$-point sampling to approximate the integral in a computationally realistic manner.\n\nUse the following physically realistic and self-consistent setup, which is standard in computational materials science electronic-structure workflows:\n- One-dimensional monatomic chain with one $\\,s\\,$-like orbital per unit cell and nearest-neighbor hopping parameter $\\,t = 1.0\\,\\mathrm{eV}\\,$, lattice constant $\\,a = 1.0\\,\\mathrm{\\AA}\\,$, and spin degeneracy $\\,g_s = 2$.\n- The single-band tight-binding dispersion is\n$$\nE(k) \\;=\\; -2t \\cos(ka)\\,,\n$$\nwith the Brillouin zone $\\,k \\in [-\\pi/a,\\pi/a)\\,$. This produces a single band with energy range $\\,E \\in [-2t,2t]$.\n- The Fermi–Dirac distribution at finite temperature $\\,T\\,$ is\n$$\nf(E,\\mu,T) \\;=\\; \\frac{1}{1 + \\exp\\!\\big( \\frac{E-\\mu}{k_{\\mathrm{B}} T} \\big)}\\,,\n$$\nwhere $\\,k_{\\mathrm{B}}\\,$ is the Boltzmann constant in electronvolts per kelvin.\n- The discrete $\\,k$-point approximation to the electron number per unit cell is\n$$\nN_e(\\mu,T;N_k) \\;=\\; \\frac{g_s}{N_k}\\,\\sum_{j=1}^{N_k} f\\!\\big(E(k_j),\\mu,T\\big)\\,,\n$$\nwhere $\\,\\{k_j\\}\\,$ are $\\,N_k\\,$ uniformly spaced $\\,k$ points over the Brillouin zone. This replaces the continuum density-of-states integral by a Riemann sum over sampled band energies, consistent with modern density functional theory (DFT) implementations.\n\nYour task:\n1. Implement a robust, monotonic root-finding procedure for $\\,\\mu\\,$ at given $\\,T\\,$ and target electron number $\\,N_e^{\\mathrm{target}}\\,$ that solves\n$$\nF(\\mu) \\;=\\; N_e(\\mu,T;N_k) - N_e^{\\mathrm{target}} \\;=\\; 0\\,.\n$$\nUse the fact that $\\,F(\\mu)\\,$ is strictly increasing in $\\,\\mu\\,$ at finite $\\,T\\,$ to design a bracketed solver. Your method must be numerically stable for temperatures as low as $\\,10\\,\\mathrm{K}\\,$ and as high as $\\,1500\\,\\mathrm{K}\\,$ and must handle occupancies near band edges. The Boltzmann constant must be $\\,k_{\\mathrm{B}} = 8.617333262\\times 10^{-5}\\,\\mathrm{eV/K}\\,$.\n2. Analyze convergence with respect to $\\,k$-point sampling by comparing each computed chemical potential to a high-resolution reference computed for the same temperature and target electron number using a dense grid $\\,N_k^{\\mathrm{ref}}\\,$. In all calculations, express energies (including $\\,\\mu\\,$) in $\\mathrm{eV}$ and temperatures in $\\mathrm{K}$. Your program must internally compute the dense-grid reference with $\\,N_k^{\\mathrm{ref}} = 20001\\,$ for the same model.\n\nInput specification:\n- There is no external input. You must hard-code the model and the test suite below.\n\nTest suite:\nCompute, for each case, the converged chemical potential $\\,\\mu\\,$ (in $\\,\\mathrm{eV}\\,$) using the specified $\\,N_k\\,$, temperature $\\,T\\,$, and target electron number $\\,N_e^{\\mathrm{target}}\\,$, and also compute the absolute deviation from the dense-grid reference $\\,\\mu_{\\mathrm{ref}}\\,$ (in $\\,\\mathrm{eV}\\,$):\n- Case $\\,1\\,$ (general, symmetric band, half-filling): $\\,N_k = 31\\,$, $\\,T = 300\\,\\mathrm{K}\\,$, $\\,N_e^{\\mathrm{target}} = 1.0\\,$.\n- Case $\\,2\\,$ (coarse grid impact): $\\,N_k = 11\\,$, $\\,T = 300\\,\\mathrm{K}\\,$, $\\,N_e^{\\mathrm{target}} = 1.0\\,$.\n- Case $\\,3\\,$ (finer grid): $\\,N_k = 201\\,$, $\\,T = 300\\,\\mathrm{K}\\,$, $\\,N_e^{\\mathrm{target}} = 1.0\\,$.\n- Case $\\,4\\,$ (band-edge, low $\\,T\\,$, low filling): $\\,N_k = 401\\,$, $\\,T = 10\\,\\mathrm{K}\\,$, $\\,N_e^{\\mathrm{target}} = 0.1\\,$.\n- Case $\\,5\\,$ (high $\\,T\\,$, near top of band): $\\,N_k = 201\\,$, $\\,T = 1500\\,\\mathrm{K}\\,$, $\\,N_e^{\\mathrm{target}} = 1.9\\,$.\n\nFinal output specification:\n- Your program should produce a single line of output containing a comma-separated list enclosed in square brackets with, for each case in order, two floating-point numbers: $\\mu$ in $\\mathrm{eV}$ and the absolute deviation $\\lvert \\mu - \\mu_{\\mathrm{ref}} \\rvert$ in $\\mathrm{eV}$. Thus the final output must be a flat list with $\\,10\\,$ numbers:\n$$\n[\\mu_1, \\Delta\\mu_1, \\mu_2, \\Delta\\mu_2, \\mu_3, \\Delta\\mu_3, \\mu_4, \\Delta\\mu_4, \\mu_5, \\Delta\\mu_5]\\,,\n$$\nwhere $\\,\\Delta\\mu_i = \\lvert \\mu_i - \\mu_{\\mathrm{ref},i} \\rvert\\,$. All energies must be in $\\,\\mathrm{eV}\\,$ and temperatures in $\\,\\mathrm{K}\\,$. Angles in $\\,k$-space are dimensionless because $\\,a = 1.0\\,\\mathrm{\\AA}\\,$ is used to nondimensionalize $\\,ka\\,$. All numerical values in the output must be floating-point numbers.", "solution": "This problem addresses a core computational task in electronic structure theory: determining the chemical potential $\\mu$ (or Fermi level) that yields a specific total number of electrons $N_e^{\\mathrm{target}}$ at a given temperature $T$. This procedure is essential for modeling systems with a fixed electron count, such as doped semiconductors or metals.\n\n**1. The Physical Model and Electron Counting**\nWe use a one-dimensional tight-binding model with energy dispersion $E(k) = -2t \\cos(ka)$. In a computational context, the integral over the Brillouin zone to find the total electron number is approximated by a discrete sum over a uniform grid of $N_k$ wavevectors, $\\{k_j\\}$:\n$$N_e(\\mu,T) \\;=\\; \\frac{g_s}{N_k}\\,\\sum_{j=1}^{N_k} f(E(k_j),\\mu,T)$$\nwhere $g_s=2$ is the spin degeneracy and $f$ is the Fermi-Dirac distribution. This function, $N_e(\\mu, T)$, represents the calculated number of electrons for a given chemical potential $\\mu$.\n\n**2. The Root-Finding Problem**\nOur goal is to find the value of $\\mu$ for which the calculated electron number equals the target number. This can be formulated as a root-finding problem for the function:\n$$F(\\mu) = N_e(\\mu, T) - N_e^{\\mathrm{target}} = 0$$\nFor any finite temperature $T>0$, the Fermi-Dirac function $f(E, \\mu, T)$ is a strictly increasing function of $\\mu$. Consequently, $N_e(\\mu, T)$ and $F(\\mu)$ are also strictly monotonic. This property makes the problem ideally suited for a robust, bracketed root-finding algorithm like Brent's method.\n\n**3. Numerical Implementation**\nThe algorithm first computes the band energies $E(k_j)$ for the specified $k$-point grid. Then, it uses a root-finding solver (e.g., from `scipy.optimize`) to find the $\\mu$ that solves $F(\\mu) = 0$. A safe search interval (bracket) for $\\mu$ can be established based on the minimum and maximum energies of the band, ensuring that the solver finds the unique physical solution. The accuracy of the computed $\\mu$ depends on the density of the $k$-point grid, $N_k$, which is explored by comparing results from coarse grids to a result from a very dense reference grid.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import root_scalar\n\ndef solve():\n    \"\"\"\n    Solves for the chemical potential in a 1D tight-binding model for various test cases\n    and computes the deviation from a high-resolution reference calculation.\n    \"\"\"\n    # Model and physical constants\n    T_PARAM = 1.0  # Hopping parameter in eV\n    A_PARAM = 1.0  # Lattice constant in Angstrom\n    GS = 2.0       # Spin degeneracy\n    KB = 8.617333262e-5  # Boltzmann constant in eV/K\n    NK_REF = 20001 # Number of k-points for reference calculation\n\n    # Test suite from the problem statement\n    test_cases = [\n        # (Nk, T in K, Ne_target)\n        (31, 300.0, 1.0),\n        (11, 300.0, 1.0),\n        (201, 300.0, 1.0),\n        (401, 10.0, 0.1),\n        (201, 1500.0, 1.9),\n    ]\n\n    results = []\n\n    def calculate_energies(Nk, t, a):\n        \"\"\"\n        Calculates the single-particle energy eigenvalues for a given k-point grid.\n        The grid is uniform in the 1st Brillouin Zone k in [-pi/a, pi/a).\n        \"\"\"\n        k_points = np.linspace(-np.pi / a, np.pi / a, Nk, endpoint=False)\n        energies = -2.0 * t * np.cos(k_points * a)\n        return energies\n\n    def calculate_Ne(mu, T, energies, gs, kB):\n        \"\"\"\n        Calculates the number of electrons per unit cell for a given chemical potential and temperature\n        using the discrete k-point summation.\n        \"\"\"\n        if T = 1e-9: # Treat very low T as T=0 to avoid numerical issues\n            return gs * np.sum(energies  mu) / len(energies)\n        \n        kBT = kB * T\n        # The argument of the exponential can be large, but numpy handles it robustly.\n        # np.exp will overflow to `inf` for large positive arguments, which correctly\n        # yields a Fermi-Dirac value of 0.\n        arg = (energies - mu) / kBT\n        fermi_dirac = 1.0 / (1.0 + np.exp(arg))\n        \n        # Total electron number is the mean occupancy multiplied by spin degeneracy\n        return gs * np.mean(fermi_dirac)\n        \n    def find_chemical_potential(T, Ne_target, energies, gs, kB):\n        \"\"\"\n        Solves for the chemical potential mu using a robust root-finding algorithm.\n        \"\"\"\n        # Define the objective function F(mu) = N_e(mu) - N_e_target, whose root we seek.\n        objective_func = lambda mu: calculate_Ne(mu, T, energies, gs, kB) - Ne_target\n        \n        # Establish a safe bracket for the root search. The energy band is [-2t, 2t].\n        # A wider bracket, extended by a thermal margin, ensures robustness.\n        E_min, E_max = np.min(energies), np.max(energies)\n        margin = max(2.0, 20.0 * kB * T) # Generous margin\n        bracket = [E_min - margin, E_max + margin]\n        \n        # Use scipy's `root_scalar` with the brentq method for robust and efficient\n        # bracketed root-finding.\n        try:\n            solution = root_scalar(objective_func, bracket=bracket, method='brentq')\n            return solution.root\n        except ValueError:\n            # This should not happen for this well-posed problem, but is good practice.\n            return np.nan # Error indicator\n            \n    # --- Main processing loop ---\n    for Nk, T, Ne_target in test_cases:\n        \n        # --- 1. Reference Calculation ---\n        energies_ref = calculate_energies(NK_REF, T_PARAM, A_PARAM)\n        mu_ref = find_chemical_potential(T, Ne_target, energies_ref, GS, KB)\n        \n        # --- 2. Test Case Calculation ---\n        energies_case = calculate_energies(Nk, T_PARAM, A_PARAM)\n        mu_case = find_chemical_potential(T, Ne_target, energies_case, GS, KB)\n        \n        # --- 3. Compute Deviation ---\n        # The deviation measures the error due to the coarser k-point grid.\n        delta_mu = abs(mu_case - mu_ref)\n        \n        # --- 4. Store Results ---\n        results.extend([mu_case, delta_mu])\n\n    # Final print statement in the exact required format.\n    # Format to 12 decimal places for sufficient precision.\n    print(f\"[{','.join(f'{x:.12f}' for x in results)}]\")\n\nsolve()\n```", "id": "3443117"}, {"introduction": "While the total density of states is crucial, we often need to understand which atomic orbitals contribute to the electronic states at different energies. This requires calculating a projected density of states (PDOS), a task that holds a subtle but critical pitfall when using the non-orthogonal basis sets common in quantum chemistry and physics. This advanced practice demonstrates how a naive projection can lead to unphysical results, such as violating electron number conservation, and has you implement the mathematically rigorous Löwdin orthogonalization to obtain a physically meaningful PDOS—a vital skill for correctly interpreting electronic structure calculations [@problem_id:3443144].", "problem": "Consider a finite-basis electronic structure model of a crystalline solid in the non-relativistic, single-particle approximation where the system is represented by a Hermitian Hamiltonian matrix $H$ expressed in a set of localized atomic orbitals and a symmetric positive definite overlap matrix $S$ that encodes the non-orthogonality of the basis. The generalized eigenvalue problem is\n$$\nH \\mathbf{c}_n = E_n\\, S \\mathbf{c}_n,\n$$\nwith eigenvalues $E_n$ and eigenvectors $\\mathbf{c}_n$. In a non-orthogonal basis, the naive projection of a state onto a particular orbital index $\\alpha$ by using the Euclidean component $|c_{n,\\alpha}|^2$ does not define a proper projector and can produce unphysical partial densities of states (Partial Density of States (PDOS)), including violations of sum rules for integrated occupancies. A mathematically consistent way to construct orbital projections is to form a symmetric orthonormalized basis using the Löwdin transformation, defined by the matrix square root $S^{1/2}$ and its inverse $S^{-1/2}$, and then project in the orthonormalized basis.\n\nFundamental definitions and facts to use:\n- The total density of states is defined spectrally by delta distributions at the eigenvalues: $g(E) = \\sum_n \\delta(E - E_n)$.\n- The Fermi–Dirac distribution is $f(E) = \\frac{1}{1 + \\exp\\!\\left(\\frac{E - E_F}{k_{\\mathrm{B}} T}\\right)}$, with Boltzmann constant $k_{\\mathrm{B}}$ expressed in electronvolts per Kelvin.\n- The total band occupancy (number of electrons in this spin channel) at temperature $T$ and Fermi level $E_F$ is $N_{\\mathrm{e}} = \\sum_n f(E_n)$.\n- In an orthonormal basis, projecting a normalized state onto orbital $\\alpha$ by $|u_{n,\\alpha}|^2$ gives a proper resolution of identity over orbitals and satisfies $\\sum_{\\alpha} |u_{n,\\alpha}|^2 = 1$ for each $n$.\n\nYour task is to implement two PDOS-based occupancy integrals for each orbital index $\\alpha$:\n1. A naive non-orthogonal PDOS integral using the raw coefficients $c_{n,\\alpha}$ from the generalized eigenvectors:\n$$\nN_{\\alpha}^{\\mathrm{naive}} = \\sum_{n} \\left| c_{n,\\alpha} \\right|^2\\, f(E_n).\n$$\n2. A Löwdin-orthogonalized PDOS integral using projections in the symmetric orthonormalized basis:\n$$\nN_{\\alpha}^{\\mathrm{L}} = \\sum_{n} \\left| d_{n,\\alpha} \\right|^2\\, f(E_n),\n\\quad \\text{where} \\quad \\mathbf{d}_n = S^{1/2} \\mathbf{c}_n.\n$$\nThen, for each test case, compute two diagnostics to quantify the physicality of the PDOS projections:\n- The occupancy sum rule error for the naive projection, defined by\n$$\n\\Delta_{\\mathrm{naive}} = \\left(\\sum_{\\alpha} N_{\\alpha}^{\\mathrm{naive}}\\right) - N_{\\mathrm{e}} \\quad \\text{(in electrons)}.\n$$\n- The occupancy sum rule error for the Löwdin-orthogonalized projection, defined by\n$$\n\\Delta_{\\mathrm{L}} = \\left(\\sum_{\\alpha} N_{\\alpha}^{\\mathrm{L}}\\right) - N_{\\mathrm{e}} \\quad \\text{(in electrons)}.\n$$\nAlso compute, for each test case, the maximum absolute orbital-wise deviation between the naive and Löwdin occupancies:\n$$\n\\Delta_{\\max} = \\max_{\\alpha} \\left| N_{\\alpha}^{\\mathrm{naive}} - N_{\\alpha}^{\\mathrm{L}} \\right| \\quad \\text{(in electrons)}.\n$$\n\nUse the following constants and units:\n- Energies $E$, $E_F$ and matrix elements of $H$ are in electronvolts (eV).\n- Temperature $T$ is in Kelvin (K).\n- The Boltzmann constant $k_{\\mathrm{B}} = 8.617333262145 \\times 10^{-5}\\ \\mathrm{eV/K}$.\n- Occupancies and errors must be reported in electrons (dimensionless count), as floats.\n\nNumerical implementation requirements:\n- Obtain $(E_n, \\mathbf{c}_n)$ by solving the generalized Hermitian eigenproblem $H \\mathbf{c}_n = E_n S \\mathbf{c}_n$ with $S$ symmetric positive definite. Choose the eigenvectors such that they satisfy the $S$-metric normalization $\\mathbf{c}_n^{\\dagger} S \\mathbf{c}_m = \\delta_{nm}$.\n- Construct $S^{1/2}$ via the spectral decomposition $S = U \\Lambda U^{\\top}$ with $\\Lambda$ positive diagonal, and set $S^{1/2} = U \\Lambda^{1/2} U^{\\top}$.\n- Evaluate $f(E_n)$ using the Fermi–Dirac distribution. Carefully handle extreme arguments to avoid floating-point overflow by using a numerically stable implementation of the logistic function.\n- For each orbital index $\\alpha$, compute $N_{\\alpha}^{\\mathrm{naive}}$ and $N_{\\alpha}^{\\mathrm{L}}$, then compute $\\Delta_{\\mathrm{naive}}$, $\\Delta_{\\mathrm{L}}$, and $\\Delta_{\\max}$.\n\nTest suite:\n- Case 1 (identity overlap, baseline consistency): \n  $$\n  H = \\begin{bmatrix} 0.0  -1.0 \\\\ -1.0  0.5 \\end{bmatrix}\\ \\mathrm{eV},\\quad\n  S = \\begin{bmatrix} 1.0  0.0 \\\\ 0.0  1.0 \\end{bmatrix},\\quad\n  E_F = 0.0\\ \\mathrm{eV},\\quad T = 300\\ \\mathrm{K}.\n  $$\n- Case 2 (moderate non-orthogonality): \n  $$\n  H = \\begin{bmatrix} 0.0  -1.0 \\\\ -1.0  0.5 \\end{bmatrix}\\ \\mathrm{eV},\\quad\n  S = \\begin{bmatrix} 1.0  0.3 \\\\ 0.3  1.0 \\end{bmatrix},\\quad\n  E_F = 0.0\\ \\mathrm{eV},\\quad T = 300\\ \\mathrm{K}.\n  $$\n- Case 3 (three-orbital chain with strong nearest-neighbor overlap): \n  $$\n  H = \\begin{bmatrix}\n  0.0  -1.0  0.0 \\\\\n  -1.0  0.3  -1.0 \\\\\n  0.0  -1.0  0.6\n  \\end{bmatrix}\\ \\mathrm{eV},\\quad\n  S = \\begin{bmatrix}\n  1.0  0.6  0.0 \\\\\n  0.6  1.0  0.6 \\\\\n  0.0  0.6  1.0\n  \\end{bmatrix},\\quad\n  E_F = 0.2\\ \\mathrm{eV},\\quad T = 1000\\ \\mathrm{K}.\n  $$\n- Case 4 (near-singular two-orbital overlap): \n  $$\n  H = \\begin{bmatrix} 0.2  -0.4 \\\\ -0.4  -0.1 \\end{bmatrix}\\ \\mathrm{eV},\\quad\n  S = \\begin{bmatrix} 1.0  0.9 \\\\ 0.9  1.0 \\end{bmatrix},\\quad\n  E_F = 0.1\\ \\mathrm{eV},\\quad T = 1\\ \\mathrm{K}.\n  $$\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For each test case, output three floats in this order: $\\Delta_{\\mathrm{naive}}$, $\\Delta_{\\mathrm{L}}$, and $\\Delta_{\\max}$. Concatenate the results for all four test cases into a single flat list. For example, the output must have the form\n$$\n[\\Delta_{\\mathrm{naive}}^{(1)},\\Delta_{\\mathrm{L}}^{(1)},\\Delta_{\\max}^{(1)},\\Delta_{\\mathrm{naive}}^{(2)},\\Delta_{\\mathrm{L}}^{(2)},\\Delta_{\\max}^{(2)},\\Delta_{\\mathrm{naive}}^{(3)},\\Delta_{\\mathrm{L}}^{(3)},\\Delta_{\\max}^{(3)},\\Delta_{\\mathrm{naive}}^{(4)},\\Delta_{\\mathrm{L}}^{(4)},\\Delta_{\\max}^{(4)}].\n$$\nAll entries must be floats representing electrons.", "solution": "The problem requires an analysis and comparison of two distinct methods for computing orbital-projected electronic occupancies within a finite, non-orthogonal basis set model of a crystalline solid. This task is fundamental in computational materials science for interpreting the results of electronic structure calculations, for example, by assigning a number of electrons to a specific atom or orbital. The core of the problem lies in the mathematical subtlety of defining projections in a non-orthogonal vector space.\n\nWe begin with the generalized eigenvalue problem which describes the stationary states of a single-particle system in a basis of localized atomic orbitals $|\\phi_{\\alpha}\\rangle$:\n$$\nH \\mathbf{c}_n = E_n S \\mathbf{c}_n\n$$\nHere, $H$ is the Hamiltonian matrix with elements $H_{\\alpha\\beta} = \\langle \\phi_{\\alpha} | \\hat{H} | \\phi_{\\beta} \\rangle$, $S$ is the overlap matrix with elements $S_{\\alpha\\beta} = \\langle \\phi_{\\alpha} | \\phi_{\\beta} \\rangle$, $E_n$ are the energy eigenvalues, and $\\mathbf{c}_n$ are the eigenvectors containing the coefficients that express the $n$-th eigenstate $|\\psi_n\\rangle$ as a linear combination of the basis orbitals: $|\\psi_n\\rangle = \\sum_{\\alpha} c_{n,\\alpha} |\\phi_{\\alpha}\\rangle$. The matrices $H$ and $S$ are Hermitian; since they are given as real, they are symmetric. The basis set non-orthogonality implies that $S_{\\alpha\\beta}$ is not generally a Kronecker delta $\\delta_{\\alpha\\beta}$, and $S$ is not the identity matrix $I$. $S$ is, however, symmetric and positive definite. The eigenvectors are chosen to be normalized with respect to the $S$-metric, meaning $\\mathbf{c}_n^\\dagger S \\mathbf{c}_m = \\delta_{nm}$.\n\nThe total number of electrons in the system (for a single spin channel) at a finite temperature $T$ and a given Fermi level $E_F$ is determined by summing the occupation of each energy level $E_n$. The occupation is given by the Fermi-Dirac distribution, $f(E)$:\n$$\nf(E) = \\frac{1}{1 + \\exp\\!\\left(\\frac{E - E_F}{k_{\\mathrm{B}} T}\\right)}\n$$\nwhere $k_{\\mathrm{B}}$ is the Boltzmann constant. The total number of electrons is thus:\n$$\nN_{\\mathrm{e}} = \\sum_n f(E_n)\n$$\nA physically meaningful decomposition of $N_{\\mathrm{e}}$ into contributions from each orbital $\\alpha$, denoted $N_{\\alpha}$, must satisfy the sum rule $\\sum_{\\alpha} N_{\\alpha} = N_{\\mathrm{e}}$.\n\nThe problem presents two ways to calculate these orbital occupancies, $N_{\\alpha}$.\n\n1.  The **\"naive\" projection**: This approach incorrectly treats the coefficients $c_{n,\\alpha}$ as if they belonged to an orthonormal basis. The projected occupancy is defined as:\n    $$\n    N_{\\alpha}^{\\mathrm{naive}} = \\sum_{n} \\left| c_{n,\\alpha} \\right|^2\\, f(E_n)\n    $$\n    The sum of these naive occupancies over all orbitals is $\\sum_{\\alpha} N_{\\alpha}^{\\mathrm{naive}} = \\sum_n f(E_n) (\\mathbf{c}_n^\\dagger \\mathbf{c}_n)$. Since $\\mathbf{c}_n^\\dagger S \\mathbf{c}_n = 1$, and $S \\neq I$, it is generally true that $\\mathbf{c}_n^\\dagger \\mathbf{c}_n \\neq 1$. Consequently, the sum rule is violated: $\\sum_{\\alpha} N_{\\alpha}^{\\mathrm{naive}} \\neq N_{\\mathrm{e}}$.\n\n2.  The **Löwdin-orthogonalized projection**: This is a mathematically rigorous method. It begins by transforming the non-orthogonal basis $\\{|\\phi_{\\alpha}\\rangle\\}$ into an orthonormal basis $\\{|\\chi_{\\alpha}\\rangle\\}$ via the Löwdin symmetric orthogonalization procedure. The transformation matrix is the inverse square root of the overlap matrix, $S^{-1/2}$. An eigenstate $|\\psi_n\\rangle$ can be expressed in this new basis as $|\\psi_n\\rangle = \\sum_\\alpha d_{n,\\alpha} |\\chi_\\alpha\\rangle$. The new coefficients $\\mathbf{d}_n$ are related to the original coefficients $\\mathbf{c}_n$ by the transformation $\\mathbf{d}_n = S^{1/2} \\mathbf{c}_n$. Because the $\\{|\\chi_\\alpha\\rangle\\}$ basis is orthonormal, a projection onto orbital $\\alpha$ is given by $|d_{n,\\alpha}|^2$, and these projections correctly sum to unity: $\\sum_\\alpha |d_{n,\\alpha}|^2 = 1$ for each eigenstate $n$. The proof is direct:\n    $$\n    \\sum_{\\alpha} |d_{n,\\alpha}|^2 = \\mathbf{d}_n^\\dagger \\mathbf{d}_n = (S^{1/2}\\mathbf{c}_n)^\\dagger(S^{1/2}\\mathbf{c}_n) = \\mathbf{c}_n^\\dagger (S^{1/2})^\\dagger S^{1/2} \\mathbf{c}_n = \\mathbf{c}_n^\\dagger S \\mathbf{c}_n = 1\n    $$\n    where the last step uses the $S$-normalization of the eigenvectors $\\mathbf{c}_n$. The Löwdin occupancy is therefore defined as:\n    $$\n    N_{\\alpha}^{\\mathrm{L}} = \\sum_{n} \\left| d_{n,\\alpha} \\right|^2\\, f(E_n)\n    $$\n    Summing this over all orbitals yields:\n    $$\n    \\sum_{\\alpha} N_{\\alpha}^{\\mathrm{L}} = \\sum_{\\alpha} \\sum_n |d_{n,\\alpha}|^2 f(E_n) = \\sum_n f(E_n) \\left(\\sum_{\\alpha} |d_{n,\\alpha}|^2\\right) = \\sum_n f(E_n) \\cdot 1 = N_{\\mathrm{e}}\n    $$\n    Thus, the Löwdin projection method rigorously satisfies the electron number sum rule. The error $\\Delta_{\\mathrm{L}} = (\\sum_{\\alpha} N_{\\alpha}^{\\mathrm{L}}) - N_{\\mathrm{e}}$ should be zero, up to numerical floating-point precision. The naive error, $\\Delta_{\\mathrm{naive}}$, is expected to be non-zero when $S \\neq I$.\n\nThe numerical implementation will proceed as follows for each test case:\n1.  **Solve the generalized eigenproblem**: Given matrices $H$ and $S$, solve $H \\mathbf{c}_n = E_n S \\mathbf{c}_n$ to obtain eigenvalues $E_n$ and $S$-normalized eigenvectors $\\mathbf{c}_n$. This will be accomplished using `scipy.linalg.eigh`.\n2.  **Compute the matrix square root $S^{1/2}$**: This is done via spectral decomposition of $S$. First, diagonalize $S$ as $S = U \\Lambda U^{\\top}$, where $U$ is the orthogonal matrix of eigenvectors and $\\Lambda$ is the diagonal matrix of eigenvalues. Then, $S^{1/2}$ is constructed as $S^{1/2} = U \\Lambda^{1/2} U^{\\top}$, where $\\Lambda^{1/2}$ is a diagonal matrix whose entries are the square roots of the eigenvalues of $S$.\n3.  **Evaluate the Fermi-Dirac distribution**: For each eigenvalue $E_n$, compute the occupation factor $f(E_n)$ using the given $E_F$, $T$, and $k_B$. A numerically stable implementation is essential to avoid floating-point overflow when the exponent $(E_n - E_F)/(k_B T)$ is large.\n4.  **Compute occupancies**:\n    -   Calculate the total electron number $N_{\\mathrm{e}} = \\sum_n f(E_n)$.\n    -   Compute the matrix of naive projection weights, $W^{\\mathrm{naive}}_{n\\alpha} = |c_{n,\\alpha}|^2$. The naive orbital occupancies are then $N_{\\alpha}^{\\mathrm{naive}} = \\sum_n W^{\\mathrm{naive}}_{n\\alpha} f(E_n)$.\n    -   Transform the eigenvectors: $\\mathbf{d}_n = S^{1/2} \\mathbf{c}_n$.\n    -   Compute the matrix of Löwdin projection weights, $W^{\\mathrm{L}}_{n\\alpha} = |d_{n,\\alpha}|^2$. The Löwdin occupancies are $N_{\\alpha}^{\\mathrm{L}} = \\sum_n W^{\\mathrm{L}}_{n\\alpha} f(E_n)$.\n5.  **Calculate diagnostics**:\n    -   $\\Delta_{\\mathrm{naive}} = \\left(\\sum_{\\alpha} N_{\\alpha}^{\\mathrm{naive}}\\right) - N_{\\mathrm{e}}$.\n    -   $\\Delta_{\\mathrm{L}} = \\left(\\sum_{\\alpha} N_{\\alpha}^{\\mathrm{L}}\\right) - N_{\\mathrm{e}}$.\n    -   $\\Delta_{\\max} = \\max_{\\alpha} \\left| N_{\\alpha}^{\\mathrm{naive}} - N_{\\alpha}^{\\mathrm{L}} \\right|$.\n\nThis procedure will be applied to each test case to quantify the error of the naive projection and the difference between the two schemes, which is expected to grow as the non-orthogonality (i.e., the off-diagonal elements of $S$) increases.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh\nfrom scipy.special import expit\n\ndef solve():\n    \"\"\"\n    Solves the problem for all test cases and prints the results.\n    \"\"\"\n    \n    # Define the Boltzmann constant in eV/K.\n    k_B = 8.617333262145e-5\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (identity overlap)\n        {\n            \"H\": np.array([[0.0, -1.0], [-1.0, 0.5]]),\n            \"S\": np.array([[1.0, 0.0], [0.0, 1.0]]),\n            \"E_F\": 0.0,\n            \"T\": 300.0\n        },\n        # Case 2 (moderate non-orthogonality)\n        {\n            \"H\": np.array([[0.0, -1.0], [-1.0, 0.5]]),\n            \"S\": np.array([[1.0, 0.3], [0.3, 1.0]]),\n            \"E_F\": 0.0,\n            \"T\": 300.0\n        },\n        # Case 3 (three-orbital chain with strong overlap)\n        {\n            \"H\": np.array([[0.0, -1.0, 0.0], [-1.0, 0.3, -1.0], [0.0, -1.0, 0.6]]),\n            \"S\": np.array([[1.0, 0.6, 0.0], [0.6, 1.0, 0.6], [0.0, 0.6, 1.0]]),\n            \"E_F\": 0.2,\n            \"T\": 1000.0\n        },\n        # Case 4 (near-singular two-orbital overlap)\n        {\n            \"H\": np.array([[0.2, -0.4], [-0.4, -0.1]]),\n            \"S\": np.array([[1.0, 0.9], [0.9, 1.0]]),\n            \"E_F\": 0.1,\n            \"T\": 1.0\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        H = case[\"H\"]\n        S = case[\"S\"]\n        E_F = case[\"E_F\"]\n        T = case[\"T\"]\n\n        # Step 1: Solve the generalized eigenvalue problem Hc = ESc\n        # scipy.linalg.eigh returns S-normalized eigenvectors.\n        # Eigenvectors are returned as columns of C.\n        E_n, C = eigh(H, S)\n\n        # Step 2: Construct the matrix square root S^(1/2)\n        # S is real symmetric, so its eigenvectors are real and U.T = U_inv.\n        s_eigvals, U = np.linalg.eigh(S)\n        # Check for positive definiteness\n        if np.any(s_eigvals = 0):\n            # This should not happen for the given valid problem cases.\n            raise ValueError(\"Overlap matrix S is not positive definite.\")\n        s_sqrt_eigvals = np.sqrt(s_eigvals)\n        S_sqrt = U @ np.diag(s_sqrt_eigvals) @ U.T\n\n        # Step 3: Evaluate the Fermi-Dirac distribution for each energy level\n        # f(E) = 1 / (1 + exp((E - E_F) / (k_B * T)))\n        # We use scipy.special.expit(x) = 1 / (1 + exp(-x))\n        # So f(E) corresponds to expit(-x) where x = (E - E_F) / (k_B * T)\n        if T > 0:\n            beta = 1.0 / (k_B * T)\n            x = beta * (E_n - E_F)\n            f_E_n = expit(-x)\n        else: # Zero temperature limit (step function)\n            f_E_n = np.where(E_n  E_F, 1.0, 0.0)\n            f_E_n[E_n == E_F] = 0.5 # Convention for equality\n\n        # Step 4: Compute occupancies\n        \n        # Total electron count\n        N_e = np.sum(f_E_n)\n\n        # The eigenvectors C are arranged column-wise.\n        # c_{n,alpha} is C[alpha, n].\n        # The sum is over n (axis=1 for row-wise operations).\n        c_n_alpha_sq = np.abs(C)**2\n        N_alpha_naive = np.sum(c_n_alpha_sq * f_E_n, axis=1)\n\n        # Transform coefficients to the Löwdin basis: d = S^(1/2) * c\n        D = S_sqrt @ C\n        d_n_alpha_sq = np.abs(D)**2\n        N_alpha_L = np.sum(d_n_alpha_sq * f_E_n, axis=1)\n\n        # Step 5: Calculate diagnostics\n\n        # Sum of naive projected occupancies\n        sum_N_alpha_naive = np.sum(N_alpha_naive)\n        \n        # Sum of Löwdin projected occupancies\n        sum_N_alpha_L = np.sum(N_alpha_L)\n\n        # Occupancy sum rule errors\n        delta_naive = sum_N_alpha_naive - N_e\n        delta_L = sum_N_alpha_L - N_e\n\n        # Maximum absolute orbital-wise deviation\n        delta_max = np.max(np.abs(N_alpha_naive - N_alpha_L))\n\n        results.extend([delta_naive, delta_L, delta_max])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3443144"}]}