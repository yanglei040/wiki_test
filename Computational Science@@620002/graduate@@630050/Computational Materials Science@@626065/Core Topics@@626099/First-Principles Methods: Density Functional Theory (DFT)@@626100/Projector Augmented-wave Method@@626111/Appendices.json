{"hands_on_practices": [{"introduction": "The core of the Projector Augmented-Wave method is the transformation between the smooth, computationally efficient pseudo-wavefunctions and the complex, all-electron wavefunctions near the atomic nuclei. This transformation is mediated by projecting the Bloch states onto a set of localized, atom-centered projector functions. This exercise [@problem_id:3480864] provides direct, hands-on practice in implementing this fundamental operation, requiring you to derive and compute the overlap integrals that form the basis of the PAW formalism and assemble the resulting occupation matrices.", "problem": "You are asked to implement, from first principles, the projection of a single plane-wave Bloch state onto atom-centered projector functions within the Projector Augmented-Wave (PAW) method, and then assemble the corresponding occupation matrices for each atom in the unit cell. The Projector Augmented-Wave (PAW) method uses atom-centered projectors $p_{a,i}(\\mathbf{r})$ localized around each atom indexed by $a$, where $i$ enumerates a finite set of angular-momentum-resolved projectors $(l,m)$ for that atom. Given a wave vector $\\mathbf{k}$ and one or more plane-wave states characterized by reciprocal lattice vectors $\\mathbf{G}_{n}$, the Bloch wave vectors are $\\mathbf{K}_{n} = \\mathbf{k} + \\mathbf{G}_{n}$. The overlap amplitudes $c_{a,i,n}$ for atom $a$, projector $i$, and band index $n$ are defined by the integral $c_{a,i,n} = \\int_{\\mathbb{R}^{3}} p_{a,i}^{*}(\\mathbf{r} - \\mathbf{R}_{a}) \\exp\\left(i \\mathbf{K}_{n} \\cdot \\mathbf{r}\\right) \\,\\mathrm{d}^{3}\\mathbf{r}$, and the atom-resolved occupation matrix is $D^{a}_{ij} = \\sum_{n} f_{n} \\, c_{a,i,n} \\, c_{a,j,n}^{*}$, where $f_{n}$ is the occupation of band $n$. You must compute and report the real parts $\\operatorname{Re} D^{a}_{ij}$ for all atoms and their projectors.\n\nBase your derivation and implementation on the following scientifically standard and well-tested elements:\n- The definition of a plane-wave Bloch state $\\exp\\left(i \\mathbf{K}\\cdot\\mathbf{r}\\right)$.\n- The orthonormality of spherical harmonics $Y_{l}^{m}(\\hat{\\mathbf{r}})$ on the unit sphere.\n- The expansion of a plane wave in spherical harmonics and spherical Bessel functions, together with the properties of spherical Bessel functions $j_{l}(x)$.\n- The construction of localized projector shapes using angular-momentum channels with Gaussian radial envelopes.\n\nUse the following physically consistent and self-contained specification for the projector functions. For each atom $a$ and a projector defined by angular momentum indices $(l,m)$, use\n$$\np_{a,lm}(\\mathbf{r}) = N_{l} \\, r^{l} \\, \\exp\\!\\left(-\\left(\\frac{r}{\\sigma_{a}}\\right)^{2}\\right) \\, Y_{l}^{m}(\\hat{\\mathbf{r}}),\n$$\nwhere $r = \\lVert \\mathbf{r} \\rVert$, $\\hat{\\mathbf{r}} = \\mathbf{r}/r$, and $N_{l}$ is a normalization constant chosen such that\n$$\n\\int_{0}^{\\infty}\\!\\int_{\\Omega} \\left|p_{a,lm}(\\mathbf{r})\\right|^{2} r^{2} \\,\\mathrm{d}\\Omega \\,\\mathrm{d}r = 1,\n$$\nwith $\\mathrm{d}\\Omega$ the solid angle element and $\\sigma_{a} > 0$ a radial width parameter for atom $a$. The normalization for $N_{l}$ must be derived from this condition.\n\nYour implementation must:\n1. Derive the overlap amplitude $c_{a,lm,n}$ from first principles using the spherical harmonic expansion of the plane wave and the orthogonality of spherical harmonics, reducing the three-dimensional integral to a one-dimensional radial integral involving the spherical Bessel function $j_{l}(x)$ and the radial envelope $r^{l}\\exp\\!\\left(-\\left(\\frac{r}{\\sigma_{a}}\\right)^{2}\\right)$.\n2. Implement a numerically stable evaluation of the radial integral. If $\\lVert \\mathbf{K}_{n} \\rVert = 0$, handle the limiting case correctly and avoid undefined angular quantities. When $\\lVert \\mathbf{K}_{n} \\rVert > 0$, compute the required spherical harmonic factor using the direction of $\\mathbf{K}_{n}$.\n3. Assemble the occupation matrices $D^{a}_{ij}$ for each atom and return their real parts $\\operatorname{Re} D^{a}_{ij}$.\n\nAngles must be in radians. Positions are to be treated in angstroms ($\\mathrm{\\AA}$), wave vectors in inverse angstroms ($\\mathrm{\\AA}^{-1}$), and the final occupation matrix elements are dimensionless. Your program must produce numerical outputs as floating-point numbers.\n\nTest Suite Specification:\nUse the following three test cases. In all cases, the unit cell is simple cubic with lattice constant $a = 5.0\\,\\mathrm{\\AA}$. There are two atoms per unit cell:\n- Atom $0$ at $\\mathbf{R}_{0} = (0.0,\\,0.0,\\,0.0)\\,\\mathrm{\\AA}$ with $\\sigma_{0} = 0.8\\,\\mathrm{\\AA}$.\n- Atom $1$ at $\\mathbf{R}_{1} = \\left(\\frac{a}{2},\\,\\frac{a}{2},\\,\\frac{a}{2}\\right)\\,\\mathrm{\\AA}$ with $\\sigma_{1} = 0.8\\,\\mathrm{\\AA}$.\n\nFor each atom, define four projectors with indices $(l,m)$ given by $(0,0)$, $(1,-1)$, $(1,0)$, $(1,1)$, in that fixed ordering.\n\nLet $G_{x} = \\frac{2\\pi}{a}\\,\\mathrm{\\AA}^{-1}$ and $G_{z} = \\frac{2\\pi}{a}\\,\\mathrm{\\AA}^{-1}$.\n\n- Case $1$ (general case): $\\mathbf{k} = (0.2,\\,0.0,\\,0.1)\\,\\mathrm{\\AA}^{-1}$, two bands with $(\\mathbf{G}_{0},f_{0}) = ((0,0,0)\\,\\mathrm{\\AA}^{-1},\\,1.0)$ and $(\\mathbf{G}_{1},f_{1}) = ((G_{x},0,0)\\,\\mathrm{\\AA}^{-1},\\,0.5)$.\n- Case $2$ (boundary $\\Gamma$ point): $\\mathbf{k} = (0.0,\\,0.0,\\,0.0)\\,\\mathrm{\\AA}^{-1}$, one band with $(\\mathbf{G}_{0},f_{0}) = ((0,0,0)\\,\\mathrm{\\AA}^{-1},\\,1.0)$.\n- Case $3$ (directional edge case): $\\mathbf{k} = (0.0,\\,0.0,\\,0.5)\\,\\mathrm{\\AA}^{-1}$, two bands with $(\\mathbf{G}_{0},f_{0}) = ((0,0,0)\\,\\mathrm{\\AA}^{-1},\\,0.3)$ and $(\\mathbf{G}_{1},f_{1}) = ((0,0,-G_{z})\\,\\mathrm{\\AA}^{-1},\\,0.3)$.\n\nOutput Specification:\nFor each test case in the above order, and for each atom $a$ in the order $a=0$ then $a=1$, form the real part of the $4\\times 4$ matrix $D^{a}_{ij}$ using the projectors in the fixed order $(0,0)$, $(1,-1)$, $(1,0)$, $(1,1)$. Flatten each matrix in row-major order to a length-$16$ list of floating-point numbers. Concatenate the lists for atom $0$ and atom $1$, then concatenate across the three test cases. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, $[x_{1},x_{2},\\dots,x_{96}]$, where $96$ is the total number of floating-point entries ($3$ cases $\\times$ $2$ atoms $\\times$ $16$ entries per matrix).\n\nYour program must be self-contained, require no user input, and be runnable as is. It must compute the occupation matrices using the described approach and return the specified output format. All numerical values in the output are unitless and must be represented as floating-point numbers.", "solution": "We begin with the standardized definitions that underpin the Projector Augmented-Wave (PAW) method. For each atom $a$ located at position $\\mathbf{R}_{a}$, we have a set of projector functions $p_{a,lm}(\\mathbf{r})$ defined over real space, with angular momentum indices $(l,m)$. The plane-wave Bloch state with wave vector $\\mathbf{K}$ is given by $\\exp\\left(i \\mathbf{K}\\cdot\\mathbf{r}\\right)$. The projection coefficients $c_{a,lm}$ of the plane wave onto the projector functions centered at $\\mathbf{R}_{a}$ are defined by the integral\n$$\nc_{a,lm}(\\mathbf{K}) = \\int_{\\mathbb{R}^{3}} p_{a,lm}^{*}(\\mathbf{r}-\\mathbf{R}_{a}) \\, \\exp\\left(i \\mathbf{K}\\cdot\\mathbf{r}\\right) \\,\\mathrm{d}^{3}\\mathbf{r}.\n$$\nA change of variables $\\mathbf{r} = \\mathbf{R}_{a} + \\mathbf{r}_{a}$ yields\n$$\nc_{a,lm}(\\mathbf{K}) = \\exp\\left(i \\mathbf{K}\\cdot\\mathbf{R}_{a}\\right) \\int_{\\mathbb{R}^{3}} p_{a,lm}^{*}(\\mathbf{r}_{a}) \\, \\exp\\left(i \\mathbf{K}\\cdot\\mathbf{r}_{a}\\right) \\,\\mathrm{d}^{3}\\mathbf{r}_{a}.\n$$\nWe specify the projector functions as\n$$\np_{a,lm}(\\mathbf{r}) = N_{l} \\, r^{l} \\, \\exp\\!\\left(-\\left(\\frac{r}{\\sigma_{a}}\\right)^{2}\\right) \\, Y_{l}^{m}(\\hat{\\mathbf{r}}),\n$$\nwhere $r = \\lVert \\mathbf{r} \\rVert$ and $\\hat{\\mathbf{r}} = \\mathbf{r}/r$. The normalization constant $N_{l}$ is chosen such that\n$$\n\\int_{0}^{\\infty}\\!\\int_{\\Omega} \\left|p_{a,lm}(\\mathbf{r})\\right|^{2} r^{2} \\,\\mathrm{d}\\Omega \\,\\mathrm{d}r = 1.\n$$\nSince $\\int_{\\Omega} \\left|Y_{l}^{m}(\\hat{\\mathbf{r}})\\right|^{2} \\,\\mathrm{d}\\Omega = 1$, the normalization reduces to\n$$\nN_{l}^{2} \\int_{0}^{\\infty} r^{2+2l} \\exp\\!\\left(-2\\left(\\frac{r}{\\sigma_{a}}\\right)^{2}\\right)\\,\\mathrm{d}r = 1.\n$$\nLetting $\\alpha = \\frac{2}{\\sigma_{a}^{2}}$, we use the standard integral $\\int_{0}^{\\infty} r^{n} e^{-\\alpha r^{2}} \\,\\mathrm{d}r = \\frac{1}{2} \\alpha^{-(n+1)/2} \\Gamma\\!\\left(\\frac{n+1}{2}\\right)$ for $n > -1$, yielding\n$$\nN_{l} = \\left[\\frac{1}{2} \\left(\\frac{2}{\\sigma_{a}^{2}}\\right)^{-\\frac{3+2l}{2}} \\Gamma\\!\\left(\\frac{3+2l}{2}\\right)\\right]^{-1/2}.\n$$\n\nTo evaluate the overlap integral, we invoke the spherical harmonic expansion of the plane wave, a well-tested formula in scattering theory:\n$$\n\\exp\\left(i \\mathbf{K}\\cdot\\mathbf{r}\\right) = 4\\pi \\sum_{l'=0}^{\\infty}\\sum_{m'=-l'}^{l'} i^{\\,l'} j_{l'}(K r) Y_{l'}^{m'}(\\hat{\\mathbf{r}}) Y_{l'}^{m'*}(\\hat{\\mathbf{K}}),\n$$\nwhere $K = \\lVert \\mathbf{K} \\rVert$, $j_{l}(x)$ are the spherical Bessel functions and $Y_{l}^{m}$ are the spherical harmonics. Using the orthonormality of $Y_{l}^{m}$, the angular integrals collapse, giving\n$$\n\\int_{\\mathbb{R}^{3}} p_{a,lm}^{*}(\\mathbf{r}) \\exp\\left(i \\mathbf{K}\\cdot\\mathbf{r}\\right) \\,\\mathrm{d}^{3}\\mathbf{r} = 4\\pi \\, i^{\\,l} \\, Y_{l}^{m*}(\\hat{\\mathbf{K}}) \\, N_{l} \\int_{0}^{\\infty} r^{2+l} \\exp\\!\\left(-\\left(\\frac{r}{\\sigma_{a}}\\right)^{2}\\right) \\, j_{l}(K r) \\,\\mathrm{d}r.\n$$\nTherefore,\n$$\nc_{a,lm}(\\mathbf{K}) = \\exp\\left(i \\mathbf{K}\\cdot\\mathbf{R}_{a}\\right) \\, 4\\pi \\, i^{\\,l} \\, Y_{l}^{m*}(\\hat{\\mathbf{K}}) \\, N_{l} \\, I_{l}(K;\\sigma_{a}),\n$$\nwith the radial integral\n$$\nI_{l}(K;\\sigma) = \\int_{0}^{\\infty} r^{2+l} \\exp\\!\\left(-\\left(\\frac{r}{\\sigma}\\right)^{2}\\right) j_{l}(K r) \\,\\mathrm{d}r.\n$$\n\nSpecial case when $K=0$: we have $\\exp\\left(i \\mathbf{K}\\cdot\\mathbf{r}\\right) = 1$, and the integral becomes\n$$\nc_{a,lm}(\\mathbf{0}) = \\int p_{a,lm}^{*}(\\mathbf{r}) \\,\\mathrm{d}^{3}\\mathbf{r} = N_{l} \\int_{0}^{\\infty} r^{2+l} \\exp\\!\\left(-\\left(\\frac{r}{\\sigma_{a}}\\right)^{2}\\right) \\,\\mathrm{d}r \\int_{\\Omega} Y_{l}^{m*}(\\hat{\\mathbf{r}}) \\,\\mathrm{d}\\Omega.\n$$\nUsing $\\int_{\\Omega} Y_{l}^{m}(\\hat{\\mathbf{r}}) \\,\\mathrm{d}\\Omega = \\sqrt{4\\pi} \\, \\delta_{l0} \\delta_{m0}$ and $j_{0}(0) = 1$ with $j_{l}(0) = 0$ for $l>0$, we find\n$$\nc_{a,00}(\\mathbf{0}) = \\sqrt{4\\pi} \\, N_{0} \\int_{0}^{\\infty} r^{2} \\exp\\!\\left(-\\left(\\frac{r}{\\sigma_{a}}\\right)^{2}\\right) \\,\\mathrm{d}r,\n$$\nand $c_{a,lm}(\\mathbf{0}) = 0$ for $l>0$. The radial integral for $l=0$ at $K=0$ evaluates to\n$$\n\\int_{0}^{\\infty} r^{2} \\exp\\!\\left(-\\left(\\frac{r}{\\sigma}\\right)^{2}\\right) \\,\\mathrm{d}r = \\sigma^{3} \\int_{0}^{\\infty} u^{2} e^{-u^{2}} \\,\\mathrm{d}u = \\sigma^{3} \\frac{\\sqrt{\\pi}}{4}.\n$$\n\nOccupation matrices: given bands indexed by $n$ with occupations $f_{n}$ and wave vectors $\\mathbf{K}_{n}$, we form\n$$\nD^{a}_{ij} = \\sum_{n} f_{n} \\, c_{a,i}(\\mathbf{K}_{n}) \\, c_{a,j}^{*}(\\mathbf{K}_{n}),\n$$\nwhich is Hermitian by construction. We are asked to report $\\operatorname{Re} D^{a}_{ij}$.\n\nAlgorithmic implementation details:\n1. Compute $N_{l}$ for each projector angular momentum $l$ and atom width $\\sigma_{a}$ using the gamma function formula above.\n2. For each band wave vector $\\mathbf{K}_{n}$:\n   - If $K_{n} = \\lVert \\mathbf{K}_{n} \\rVert$ is larger than a small threshold (for example $10^{-12}$), compute the polar angles $(\\theta,\\phi)$ from $\\hat{\\mathbf{K}}_{n} = \\mathbf{K}_{n}/K_{n}$ using $\\theta = \\arccos(K_{z}/K)$ and $\\phi = \\operatorname{atan2}(K_{y},K_{x})$. Evaluate $Y_{l}^{m}(\\hat{\\mathbf{K}})$ and its complex conjugate, and compute the radial integral $I_{l}(K;\\sigma)$ numerically by one-dimensional quadrature. A practical upper limit is $r_{\\max} = 12\\,\\sigma$, since the Gaussian envelope suppresses larger radii. Use a high-accuracy quadrature routine and spherical Bessel $j_{l}$.\n   - If $K_{n}$ is below threshold, use the special-case formulas: only the $(l=0,m=0)$ projector has non-zero overlap, as shown above, and $c_{a,00}(\\mathbf{0})$ is computed analytically. All $l>0$ channels yield zero overlap in the limit.\n   - Multiply by the phase factor $\\exp\\left(i \\mathbf{K}_{n}\\cdot \\mathbf{R}_{a}\\right)$ and the constant prefactors to obtain $c_{a,lm,n}$.\n3. Assemble $D^{a}_{ij}$ by summing $f_{n} c_{a,i,n} c_{a,j,n}^{*}$ over all bands $n$.\n4. Extract and report $\\operatorname{Re} D^{a}_{ij}$, flattening each $4\\times 4$ matrix in row-major order.\n\nUnits and numerical considerations:\n- Positions $\\mathbf{R}_{a}$ are in $\\mathrm{\\AA}$, wave vectors $\\mathbf{K}_{n}$ are in $\\mathrm{\\AA}^{-1}$, angles are in radians, and the final occupation matrix elements are dimensionless.\n- The spherical harmonics are evaluated using the Condon–Shortley phase convention, consistent with standard scientific libraries.\n- Numerical quadrature should use absolute and relative tolerances to ensure stable radial integrals. The Gaussian decay makes the integrals well-conditioned; limiting the integration to $[0,12\\sigma]$ suffices.\n\nTest suite execution:\n- Case $1$ uses $\\mathbf{k} = (0.2,\\,0.0,\\,0.1)\\,\\mathrm{\\AA}^{-1}$ and bands at $\\mathbf{G}_{0}=(0,0,0)\\,\\mathrm{\\AA}^{-1}$ with $f_{0}=1.0$, and $\\mathbf{G}_{1}=(2\\pi/a,0,0)\\,\\mathrm{\\AA}^{-1}$ with $f_{1}=0.5$.\n- Case $2$ uses the $\\Gamma$ point $\\mathbf{k}=(0,0,0)\\,\\mathrm{\\AA}^{-1}$ and a single band $\\mathbf{G}_{0}=(0,0,0)\\,\\mathrm{\\AA}^{-1}$ with $f_{0}=1.0$; only $l=0$ contributes.\n- Case $3$ uses $\\mathbf{k}=(0,0,0.5)\\,\\mathrm{\\AA}^{-1}$ and bands $\\mathbf{G}_{0}=(0,0,0)\\,\\mathrm{\\AA}^{-1}$ and $\\mathbf{G}_{1}=(0,0,-2\\pi/a)\\,\\mathrm{\\AA}^{-1}$ with occupations $f_{0}=0.3$ and $f_{1}=0.3$, probing directional sensitivity of $Y_{l}^{m}(\\hat{\\mathbf{K}})$.\n\nThe output must be a single comma-separated list enclosed in square brackets, concatenating the flattened real parts of $D^{a}_{ij}$ for atoms $a=0$ and $a=1$ for each case, in the specified order, resulting in $96$ floating-point entries. The program must be self-contained and produce this single line of output when run.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom math import sqrt, pi, acos, atan2, isclose, gamma\nfrom scipy.special import sph_harm, spherical_jn\nfrom scipy.integrate import quad\n\ndef normalization_Nl(l: int, sigma: float) -> float:\n    \"\"\"\n    Compute the normalization constant N_l for the projector radial function:\n    p_{lm}(r) = N_l * r^l * exp(-(r/sigma)^2) * Y_l^m(Ω),\n    such that ∫ |p|^2 r^2 dr dΩ = 1.\n\n    N_l^2 ∫_0^∞ r^{2+2l} exp(-2 (r/sigma)^2) dr = 1\n    Using ∫_0^∞ r^n e^{-α r^2} dr = (1/2) α^{-(n+1)/2} Γ((n+1)/2)\n    with α = 2/sigma^2, n = 2 + 2l.\n    \"\"\"\n    alpha = 2.0 / (sigma**2)\n    n = 2 + 2*l\n    integral = 0.5 * (alpha ** (-(n + 1) / 2.0)) * gamma((n + 1) / 2.0)\n    Nl = 1.0 / sqrt(integral)\n    return Nl\n\ndef K_angles(Kvec: np.ndarray):\n    \"\"\"\n    Compute spherical angles (theta, phi) for direction of Kvec.\n    theta in [0, π], phi in [-π, π].\n    \"\"\"\n    Knorm = np.linalg.norm(Kvec)\n    if Knorm < 1e-14:\n        # Undefined direction; caller should handle K=0 separately.\n        return None, None, 0.0\n    kx, ky, kz = Kvec\n    theta = np.arccos(kz / Knorm)\n    phi = np.arctan2(ky, kx)\n    return theta, phi, Knorm\n\ndef radial_integral_Il(l: int, K: float, sigma: float) -> float:\n    \"\"\"\n    Compute I_l(K; sigma) = ∫_0^∞ r^{2+l} exp(-(r/sigma)^2) j_l(K r) dr\n    Numerically via quadrature over [0, Rmax], where Rmax = 12*sigma.\n    Special-case: if K == 0, then j_0(0) = 1 and j_l(0) = 0 for l>0.\n    \"\"\"\n    if K < 1e-14:\n        if l == 0:\n            # Analytic integral: ∫ r^2 exp(-(r/sigma)^2) dr = sigma^3 * sqrt(pi)/4\n            return (sigma**3) * (sqrt(pi) / 4.0)\n        else:\n            return 0.0\n    Rmax = 12.0 * sigma\n    # Integrand for quadrature\n    def integrand(r):\n        return (r**(2 + l)) * np.exp(-(r/sigma)**2) * spherical_jn(l, K * r)\n    val, err = quad(integrand, 0.0, Rmax, epsabs=1e-10, epsrel=1e-10, limit=200)\n    return val\n\ndef overlap_coefficient(atom_R: np.ndarray, l: int, m: int, sigma: float, Kvec: np.ndarray, Nl: float) -> complex:\n    \"\"\"\n    Compute c_{a,lm}(K) = e^{i K·R_a} * 4π * i^l * Y_l^m*(K̂) * N_l * I_l(K; sigma)\n    with appropriate handling of K=0 special case.\n    \"\"\"\n    theta, phi, Knorm = K_angles(Kvec)\n    phase = np.exp(1j * np.dot(Kvec, atom_R))\n    if Knorm < 1e-14:\n        # Special-case: only l=0,m=0 contributes\n        if l == 0 and m == 0:\n            I0 = radial_integral_Il(0, 0.0, sigma)\n            # Angular integral gives √(4π)\n            return phase * (sqrt(4.0 * pi) * Nl * I0)\n        else:\n            return 0.0 + 0.0j\n    # Directional spherical harmonic factor Y_l^m*(K̂)\n    Ylm = sph_harm(m, l, phi, theta)  # sph_harm returns Y_l^m(φ, θ)\n    Ylm_conj = np.conj(Ylm)\n    Il = radial_integral_Il(l, Knorm, sigma)\n    coeff = phase * (4.0 * pi) * ((1j) ** l) * Ylm_conj * Nl * Il\n    return coeff\n\ndef build_D_matrix_for_atom(atom_R: np.ndarray, sigma: float, projectors: list, bands: list) -> np.ndarray:\n    \"\"\"\n    Build D^a_{ij} for one atom.\n    projectors: list of (l, m) pairs in fixed order.\n    bands: list of dicts {'K': np.array, 'f': float}\n    Returns real part of 4x4 D matrix as numpy array.\n    \"\"\"\n    # Precompute N_l per l value to avoid repeated normalization\n    unique_ls = sorted(set([l for (l, m) in projectors]))\n    Nl_map = {l: normalization_Nl(l, sigma) for l in unique_ls}\n    # Compute overlaps c_i,n for each projector i and band n\n    num_proj = len(projectors)\n    num_bands = len(bands)\n    c = np.zeros((num_proj, num_bands), dtype=np.complex128)\n    for i, (l, m) in enumerate(projectors):\n        Nl = Nl_map[l]\n        for n, band in enumerate(bands):\n            Kvec = band['K']\n            c[i, n] = overlap_coefficient(atom_R, l, m, sigma, Kvec, Nl)\n    # Assemble D_ij = sum_n f_n c_i,n c_j,n^*\n    D = np.zeros((num_proj, num_proj), dtype=np.complex128)\n    for n, band in enumerate(bands):\n        f = band['f']\n        cn = c[:, n].reshape((num_proj, 1))\n        D += f * (cn @ np.conj(cn).T)\n    return D.real\n\ndef solve():\n    # Define lattice and atoms\n    a = 5.0  # Angstrom\n    Gx = 2.0 * pi / a  # 1/Angstrom\n    Gz = 2.0 * pi / a  # 1/Angstrom\n\n    atoms = [\n        {'R': np.array([0.0, 0.0, 0.0]), 'sigma': 0.8},\n        {'R': np.array([a/2.0, a/2.0, a/2.0]), 'sigma': 0.8},\n    ]\n\n    # Projectors: fixed order (0,0), (1,-1), (1,0), (1,1)\n    projectors = [(0, 0), (1, -1), (1, 0), (1, 1)]\n\n    # Test cases definition\n    test_cases = [\n        # Case 1: general case\n        {\n            'k': np.array([0.2, 0.0, 0.1]),\n            'bands': [\n                {'G': np.array([0.0, 0.0, 0.0]), 'f': 1.0},\n                {'G': np.array([Gx, 0.0, 0.0]), 'f': 0.5},\n            ],\n        },\n        # Case 2: Gamma point\n        {\n            'k': np.array([0.0, 0.0, 0.0]),\n            'bands': [\n                {'G': np.array([0.0, 0.0, 0.0]), 'f': 1.0},\n            ],\n        },\n        # Case 3: directional edge case\n        {\n            'k': np.array([0.0, 0.0, 0.5]),\n            'bands': [\n                {'G': np.array([0.0, 0.0, 0.0]), 'f': 0.3},\n                {'G': np.array([0.0, 0.0, -Gz]), 'f': 0.3},\n            ],\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        k = case['k']\n        # Form bands as K = k + G\n        bands = []\n        for b in case['bands']:\n            K = k + b['G']\n            bands.append({'K': K, 'f': b['f']})\n        # Compute D matrices for each atom and flatten real parts\n        for atom in atoms:\n            D_real = build_D_matrix_for_atom(atom['R'], atom['sigma'], projectors, bands)\n            # Flatten row-major\n            flat = D_real.flatten(order='C')\n            # Append to results\n            results.extend(flat.tolist())\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3480864"}, {"introduction": "Beyond the basic framework, the accuracy of PAW calculations for many materials, especially those with magnetic properties, depends on subtle but important refinements. One of the most significant is the Non-Linear Core Correction (NLCC), which accounts for the overlap between core and valence electron densities in the exchange-correlation functional. This practice [@problem_id:3480885] uses a focused, site-centered model to isolate and quantify the impact of NLCC, allowing you to directly observe how it enhances the local magnetic moment in a typical transition-metal oxide.", "problem": "Consider a simplified, spherically symmetric site-centered model for a transition-metal atom in a $3d$ oxide within the Projector Augmented-Wave (PAW) formalism. The objective is to quantify how the Non-Linear Core Correction (NLCC) in a Local Spin Density Approximation (LSDA) affects the local magnetic moment by including core-valence overlap in the exchange-correlation functional argument, $n_{\\text{val}}+n_{\\text{core}}$. Assume atomic units throughout and report magnetic moments in Bohr magnetons per site.\n\nFundamental base and assumptions:\n- Density Functional Theory (DFT) in the Kohn-Sham formalism defines spin-resolved exchange-correlation potentials as functional derivatives of the exchange-correlation energy density with respect to spin densities. In the Local Spin Density Approximation (LSDA) for exchange only, the spin-resolved exchange energy density is\n$$\\varepsilon_{x}\\left(n_{\\uparrow},n_{\\downarrow}\\right) = -\\frac{3}{4}\\left(\\frac{3}{\\pi}\\right)^{1/3}\\left(n_{\\uparrow}^{4/3}+n_{\\downarrow}^{4/3}\\right),$$\nwhich yields the spin-resolved exchange potentials\n$$v_{x,\\sigma}(r) = \\frac{\\partial \\varepsilon_x}{\\partial n_{\\sigma}} = -\\left(\\frac{3}{\\pi}\\right)^{1/3} n_{\\sigma}(r)^{1/3}, \\quad \\sigma \\in \\{\\uparrow,\\downarrow\\}.$$\n- The PAW Non-Linear Core Correction (NLCC) modifies the exchange-correlation potentials by evaluating them on the total spin-resolved density that includes a non-spin-polarized core contribution, namely $n_{\\text{core},\\uparrow}(r)=n_{\\text{core},\\downarrow}(r)=\\frac{1}{2}n_{\\text{core}}(r)$. Without NLCC, the potentials are evaluated on the valence spin densities only.\n- The local exchange-correlation magnetic field is defined as\n$$B_{xc}(r) = v_{x,\\uparrow}(r) - v_{x,\\downarrow}(r),$$\nand the NLCC-induced change in this field is expected to influence the on-site magnetic moment via a local linear response described by a site susceptibility.\n\nSite-centered model:\n- The spherically averaged valence spin densities are modeled as\n$$n_{\\text{val},\\uparrow}(r) = A_{\\uparrow}\\, r^{2}\\, e^{-\\alpha r}, \\quad n_{\\text{val},\\downarrow}(r) = A_{\\downarrow}\\, r^{2}\\, e^{-\\alpha r},$$\nwith $A_{\\uparrow}>0$, $A_{\\downarrow}>0$, and $\\alpha>0$.\n- The spherically averaged core density is modeled as\n$$n_{\\text{core}}(r) = A_{c}\\, e^{-\\beta r^{2}},$$\nwith $A_{c}>0$ and $\\beta>0$. The core is assumed non-spin-polarized so that $n_{\\text{core},\\uparrow}(r)=n_{\\text{core},\\downarrow}(r)=\\frac{1}{2}n_{\\text{core}}(r)$.\n- Consider a PAW augmentation sphere of radius $R>0$ centered on the atom.\n\nTasks:\n1. Compute the baseline local magnetic moment without NLCC, $m_{0}$, defined as the integral of the valence spin density difference over the augmentation sphere,\n$$m_{0} = \\int_{|\\mathbf{r}|<R} \\left[n_{\\text{val},\\uparrow}(r) - n_{\\text{val},\\downarrow}(r)\\right]\\, d^{3}r,$$\nexpressed in Bohr magnetons per site. Use the spherically symmetric volume element and evaluate the integral exactly or numerically, ensuring scientific correctness and numerical stability.\n2. Compute the volume-averaged exchange-correlation magnetic field within the sphere, both without NLCC and with NLCC, respectively,\n$$\\langle B_{xc}^{\\text{noNLCC}} \\rangle = \\frac{1}{V}\\int_{|\\mathbf{r}|<R} \\left[v_{x,\\uparrow}\\big(n_{\\text{val},\\uparrow}(r)\\big) - v_{x,\\downarrow}\\big(n_{\\text{val},\\downarrow}(r)\\big)\\right]\\, d^{3}r,$$\n$$\\langle B_{xc}^{\\text{NLCC}} \\rangle = \\frac{1}{V}\\int_{|\\mathbf{r}|<R} \\left[v_{x,\\uparrow}\\big(n_{\\text{val},\\uparrow}(r)+\\tfrac{1}{2}n_{\\text{core}}(r)\\big) - v_{x,\\downarrow}\\big(n_{\\text{val},\\downarrow}(r)+\\tfrac{1}{2}n_{\\text{core}}(r)\\big)\\right]\\, d^{3}r,$$\nwhere $V=\\frac{4}{3}\\pi R^{3}$.\n3. Given a site susceptibility $\\chi_{\\text{site}}$ (assumed constant) that relates the average exchange-correlation field change to the induced moment change via\n$$\\Delta m = \\chi_{\\text{site}} \\left(\\langle B_{xc}^{\\text{NLCC}} \\rangle - \\langle B_{xc}^{\\text{noNLCC}} \\rangle\\right),$$\ncompute the NLCC-corrected moment $m_{\\text{corr}} = m_{0} + \\Delta m$ and report the NLCC-induced change $\\Delta m$.\n\nAngle units are not applicable. All quantities are in atomic units; report the magnetic moments in Bohr magnetons per site.\n\nTest suite:\nProvide results for the following four parameter sets, which exercise different regimes of core-valence overlap and spin polarization. Each test case is a tuple $(\\alpha, A_{\\uparrow}, A_{\\downarrow}, A_{c}, \\beta, R, \\chi_{\\text{site}})$, with all parameters in atomic units:\n- Case 1 (moderate overlap, substantial spin polarization): $(4.0,\\, 1.00,\\, 0.60,\\, 60.0,\\, 50.0,\\, 1.20,\\, 0.50)$.\n- Case 2 (minimal overlap, small spin polarization): $(4.5,\\, 0.80,\\, 0.70,\\, 20.0,\\, 100.0,\\, 1.00,\\, 0.40)$.\n- Case 3 (large overlap, strong spin polarization): $(3.5,\\, 0.90,\\, 0.40,\\, 100.0,\\, 10.0,\\, 1.50,\\, 0.60)$.\n- Case 4 (boundary case, nearly zero spin polarization): $(5.0,\\, 0.70,\\, 0.69,\\, 70.0,\\, 30.0,\\, 1.20,\\, 0.50)$.\n\nRequired final output format:\nYour program should produce a single line of output containing the NLCC-induced moment changes $\\Delta m$ for all four cases as a comma-separated list enclosed in square brackets, with each float rounded to six decimal places, for example, \"[x1,x2,x3,x4]\". The unit for each entry is Bohr magnetons per site.", "solution": "The problem is valid as it is scientifically grounded in Density Functional Theory, mathematically well-posed, and all necessary parameters and definitions are provided. The objective is to compute the change in the local magnetic moment, $\\Delta m$, induced by the Non-Linear Core Correction (NLCC) within a simplified PAW model. The calculation proceeds in several steps. All quantities are in atomic units, and the final magnetic moment is reported in Bohr magnetons, for which the numerical value is the same in atomic units.\n\nThe NLCC-induced change in magnetic moment, $\\Delta m$, is given by a linear response model:\n$$ \\Delta m = \\chi_{\\text{site}} \\left(\\langle B_{xc}^{\\text{NLCC}} \\rangle - \\langle B_{xc}^{\\text{noNLCC}} \\rangle\\right) $$\nwhere $\\chi_{\\text{site}}$ is the site susceptibility and $\\langle B_{xc} \\rangle$ denotes the volume-averaged exchange-correlation magnetic field within the PAW augmentation sphere of radius $R$. The key task is to compute the average fields with and without NLCC.\n\nThe volume average of a spherically symmetric field $f(r)$ over a sphere of radius $R$ and volume $V = \\frac{4}{3}\\pi R^3$ is given by:\n$$ \\langle f \\rangle = \\frac{1}{V} \\int_{|\\mathbf{r}|<R} f(r) \\, d^3r = \\frac{1}{V} \\int_0^R f(r) \\, 4\\pi r^2 \\, dr = \\frac{3}{R^3} \\int_0^R f(r) \\, r^2 \\, dr $$\n\nThe exchange-correlation magnetic field is defined as $B_{xc}(r) = v_{x,\\uparrow}(r) - v_{x,\\downarrow}(r)$. Using the provided LSDA exchange potential, $v_{x,\\sigma}(n_\\sigma) = C_x n_\\sigma^{1/3}$ with $C_x = -(3/\\pi)^{1/3}$, we have:\n$$ B_{xc}(r) = C_x \\left( n_{\\uparrow}(r)^{1/3} - n_{\\downarrow}(r)^{1/3} \\right) $$\nThe spin densities $n_{\\uparrow}(r)$ and $n_{\\downarrow}(r)$ depend on whether NLCC is applied.\n\n**1. Calculation of $\\langle B_{xc}^{\\text{noNLCC}} \\rangle$**\n\nWithout NLCC, the potential is evaluated on the valence spin densities only: $n_{\\sigma}(r) = n_{\\text{val},\\sigma}(r) = A_{\\sigma} r^2 e^{-\\alpha r}$.\nThe magnetic field is:\n$$ B_{xc}^{\\text{noNLCC}}(r) = C_x \\left[ (A_{\\uparrow} r^2 e^{-\\alpha r})^{1/3} - (A_{\\downarrow} r^2 e^{-\\alpha r})^{1/3} \\right] $$\nThis expression simplifies to:\n$$ B_{xc}^{\\text{noNLCC}}(r) = C_x (A_{\\uparrow}^{1/3} - A_{\\downarrow}^{1/3}) r^{2/3} e^{-\\alpha r/3} $$\nThe volume average is then calculated by integrating this field. The integrand for the volume integral is $4\\pi r^2 B_{xc}^{\\text{noNLCC}}(r)$:\n$$ \\langle B_{xc}^{\\text{noNLCC}} \\rangle = \\frac{4\\pi C_x (A_{\\uparrow}^{1/3} - A_{\\downarrow}^{1/3})}{V} \\int_0^R r^{2/3} e^{-\\alpha r/3} \\cdot r^2 \\, dr $$\n$$ \\langle B_{xc}^{\\text{noNLCC}} \\rangle = \\frac{3 C_x (A_{\\uparrow}^{1/3} - A_{\\downarrow}^{1/3})}{R^3} \\int_0^R r^{8/3} e^{-\\alpha r/3} \\, dr $$\nThis definite integral is computed numerically for each parameter set.\n\n**2. Calculation of $\\langle B_{xc}^{\\text{NLCC}} \\rangle$**\n\nWith NLCC, the potential is evaluated on the total spin densities, which include the core density: $n_{\\sigma}(r) = n_{\\text{val},\\sigma}(r) + \\frac{1}{2} n_{\\text{core}}(r)$. Using the provided models for valence and core densities:\n$$ n_{\\sigma}(r) = A_{\\sigma} r^2 e^{-\\alpha r} + \\frac{A_c}{2} e^{-\\beta r^2} $$\nThe magnetic field is:\n$$ B_{xc}^{\\text{NLCC}}(r) = C_x \\left[ \\left(A_{\\uparrow} r^2 e^{-\\alpha r} + \\frac{A_c}{2} e^{-\\beta r^2}\\right)^{1/3} - \\left(A_{\\downarrow} r^2 e^{-\\alpha r} + \\frac{A_c}{2} e^{-\\beta r^2}\\right)^{1/3} \\right] $$\nThis expression does not simplify. The volume average requires numerical integration of the full expression:\n$$ \\langle B_{xc}^{\\text{NLCC}} \\rangle = \\frac{1}{V} \\int_0^R B_{xc}^{\\text{NLCC}}(r) \\, 4\\pi r^2 \\, dr $$\n\n**3. Algorithmic Implementation**\n\nFor each test case defined by the tuple $(\\alpha, A_{\\uparrow}, A_{\\downarrow}, A_{c}, \\beta, R, \\chi_{\\text{site}})$, the algorithm proceeds as follows:\n- The constant $C_x$ and the sphere volume $V$ are computed.\n- The integral for $\\langle B_{xc}^{\\text{noNLCC}} \\rangle$ is evaluated using a numerical quadrature method. The integrand is a smooth, well-behaved function proportional to $r^{8/3}$ near the origin, which is handled correctly by standard integration routines.\n- The integral for $\\langle B_{xc}^{\\text{NLCC}} \\rangle$ is also evaluated using numerical quadrature. The integrand involves point-wise calculation of the total densities. The integrand is proportional to $r^2$ near the origin and is well-behaved.\n- The change in the average field, $\\Delta \\langle B_{xc} \\rangle = \\langle B_{xc}^{\\text{NLCC}} \\rangle - \\langle B_{xc}^{\\text{noNLCC}} \\rangle$, is calculated.\n- Finally, the induced moment change is found via $\\Delta m = \\chi_{\\text{site}} \\Delta \\langle B_{xc} \\rangle$.\n\nThis procedure is repeated for all four test cases, and the resulting values of $\\Delta m$ are collected and formatted as required. The calculation shows that $\\Delta m$ is always positive, indicating that the NLCC enhances the local magnetic moment, which is consistent with the physics of exchange interactions.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Computes the NLCC-induced change in magnetic moment for four test cases\n    based on a simplified PAW model.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (alpha, A_up, A_down, A_c, beta, R, chi_site)\n        (4.0, 1.00, 0.60, 60.0, 50.0, 1.20, 0.50),  # Case 1\n        (4.5, 0.80, 0.70, 20.0, 100.0, 1.00, 0.40), # Case 2\n        (3.5, 0.90, 0.40, 100.0, 10.0, 1.50, 0.60), # Case 3\n        (5.0, 0.70, 0.69, 70.0, 30.0, 1.20, 0.50)   # Case 4\n    ]\n\n    results = []\n    \n    # Pre-calculate the LSDA exchange constant C_x = -(3/pi)^(1/3)\n    C_x = -(3.0 / np.pi)**(1.0/3.0)\n\n    for case in test_cases:\n        alpha, A_up, A_down, A_c, beta, R, chi_site = case\n        \n        # Volume of the augmentation sphere\n        V = (4.0 / 3.0) * np.pi * R**3\n\n        # --- Calculate <B_xc^noNLCC> ---\n        # The integral can be simplified algebraically, which is more robust\n        # and efficient than calculating the densities point-wise.\n        # B_xc_noNLCC(r) = C_x * (A_up^(1/3) - A_down^(1/3)) * r^(2/3) * exp(-alpha*r/3)\n        # The integrand for the volume integral is 4*pi*r^2 * B_xc(r)\n        \n        # This factor is constant with respect to the integration variable r\n        const_factor_noNLCC = 4.0 * np.pi * C_x * (A_up**(1.0/3.0) - A_down**(1.0/3.0))\n        \n        def integrand_noNLCC(r):\n            return const_factor_noNLCC * r**(8.0/3.0) * np.exp(-alpha * r / 3.0)\n\n        integral_noNLCC, _ = quad(integrand_noNLCC, 0, R)\n        avg_B_noNLCC = integral_noNLCC / V\n\n        # --- Calculate <B_xc^NLCC> ---\n        # For the NLCC case, we must compute the total densities point-wise\n        # as the expression does not simplify.\n        def n_val_up(r):\n            return A_up * r**2 * np.exp(-alpha * r)\n\n        def n_val_down(r):\n            return A_down * r**2 * np.exp(-alpha * r)\n\n        def n_core(r):\n            return A_c * np.exp(-beta * r**2)\n            \n        def integrand_NLCC(r):\n            n_half_core = 0.5 * n_core(r)\n            \n            n_tot_up = n_val_up(r) + n_half_core\n            n_tot_down = n_val_down(r) + n_half_core\n            \n            # The B_xc field is C_x * (n_up^(1/3) - n_down^(1/3))\n            # The integrand for the volume integral is 4*pi*r^2 * B_xc(r)\n            b_xc_nlcc_val = C_x * (n_tot_up**(1.0/3.0) - n_tot_down**(1.0/3.0))\n            return b_xc_nlcc_val * 4.0 * np.pi * r**2\n\n        integral_NLCC, _ = quad(integrand_NLCC, 0, R)\n        avg_B_NLCC = integral_NLCC / V\n\n        # --- Calculate delta_m ---\n        delta_B_xc = avg_B_NLCC - avg_B_noNLCC\n        delta_m = chi_site * delta_B_xc\n        \n        results.append(delta_m)\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3480885"}, {"introduction": "The projector functions and augmentation spheres that define a PAW dataset are not arbitrary; they are the result of a careful optimization process designed to maximize accuracy and transferability. This exercise [@problem_id:3480862] offers a glimpse into this construction process by focusing on the automated optimization of the augmentation radius, $r_c$. By applying the Hellmann-Feynman theorem to a model of the PAW energy, you will calculate the energy gradient $\\frac{\\partial E}{\\partial r_c}$ and use it to drive a gradient-based search for an optimal radius, a key step in generating robust PAW datasets.", "problem": "Consider the Projector Augmented-Wave (PAW) method in Kohn–Sham Density Functional Theory (DFT). The PAW total energy can be decomposed into a smooth pseudo part plus on-site augmentation corrections confined to atomic augmentation regions. For a single, spherically symmetric augmentation region around an atom, approximate the on-site augmentation contribution by the radial functional\n$$\nE(r_c) = \\int_{0}^{\\infty} 4\\pi r^2 \\, w(r; r_c) \\, F(r) \\, dr + C,\n$$\nwhere $r_c$ is the augmentation radius, $w(r; r_c)$ is a switching function that is approximately $1$ inside the augmentation region and $0$ outside, $F(r)$ is a spherically symmetric energy-density surrogate for the augmentation correction, and $C$ is a constant independent of $r_c$. The switching function is chosen to be differentiable and parameterized by a sharpness parameter $a$,\n$$\nw(r; r_c) = \\frac{1}{1 + \\exp\\!\\left(\\frac{r - r_c}{a}\\right)}.\n$$\nUse the following spherically symmetric model for the augmentation energy-density surrogate,\n$$\nF(r) = \\Delta n(r)\\, u(r),\n$$\nwith\n$$\n\\Delta n(r) = n_{\\mathrm{AE}}(r) - n_{\\mathrm{PS}}(r),\n$$\n$$\nn_{\\mathrm{AE}}(r) = \\frac{N_e \\alpha^3}{\\pi} \\exp(-2\\alpha r),\n$$\n$$\nn_{\\mathrm{PS}}(r) = n_{\\mathrm{AE}}(r)\\left[1 - \\exp\\!\\left(-\\left(\\frac{r}{\\sigma}\\right)^{m}\\right)\\right],\n$$\nand the effective local kernel\n$$\nu(r) = -\\frac{Z_{\\mathrm{eff}}}{r}.\n$$\nHere $N_e$ is the number of valence electrons represented in the augmentation, $\\alpha$ is a hydrogenic decay parameter, $\\sigma$ is a pseudo-smoothing length scale, $m$ is an even positive integer controlling smoothness, and $Z_{\\mathrm{eff}}$ is an effective nuclear charge. All radial quantities are in Bohr and energies in Hartree.\n\nStarting from the Kohn–Sham energy functional and the PAW decomposition, and invoking the principle of differentiation under the integral sign and the Hellmann–Feynman theorem, derive an expression for the derivative\n$$\n\\frac{\\partial E}{\\partial r_c} = \\int_{0}^{\\infty} 4\\pi r^2 \\, F(r) \\, \\frac{\\partial w(r; r_c)}{\\partial r_c} \\, dr,\n$$\nwith explicit form for $\\partial w/\\partial r_c$. Then, implement a program that:\n- Computes $\\partial E/\\partial r_c$ for given parameters using the explicit integral above, in Hartree per Bohr.\n- Uses this derivative to perform a projected gradient update\n$$\nr_c^{(k+1)} = \\mathrm{Proj}_{[r_{\\min}, r_{\\max}]}\\left(r_c^{(k)} - \\eta \\, \\frac{\\partial E}{\\partial r_c}\\bigg|_{r_c^{(k)}}\\right),\n$$\nto guide automated selection of $r_c$ during dataset optimization, where $\\eta$ is a step size with units Bohr$^2$/Hartree, and $\\mathrm{Proj}_{[r_{\\min}, r_{\\max}]}$ denotes projection onto the interval $[r_{\\min}, r_{\\max}]$. Iterate until $\\left|\\partial E/\\partial r_c\\right| < \\mathrm{tol}$ or a maximum number of iterations is reached. Report the derivative at the initial $r_c$ and the final selected $r_c$.\n\nYour program must implement the integral for $\\partial E/\\partial r_c$ using numerical quadrature on $r \\in [0, R_{\\mathrm{max}}]$ with sufficiently large $R_{\\mathrm{max}}$ to capture the exponential tail, and use the explicit analytic derivative of $w(r; r_c)$ with respect to $r_c$. Use atomic units throughout. Express the final derivative in Hartree per Bohr and $r_c$ in Bohr as plain floating-point numbers.\n\nTest Suite:\nFor each test case, compute the derivative at the initial $r_c$ and the selected $r_c$ after the automated procedure. The parameters are:\n1. Case A (happy path): $r_c^{(0)} = 1.0$ Bohr, $Z_{\\mathrm{eff}} = 6.0$, $\\alpha = 6.0$, $N_e = 4$, $\\sigma = 0.6$ Bohr, $m = 4$, $a = 0.05$ Bohr, $r_{\\min} = 0.5$ Bohr, $r_{\\max} = 2.0$ Bohr, $\\eta = 0.02$ Bohr$^2$/Hartree, $\\mathrm{tol} = 1\\times 10^{-8}$ Hartree/Bohr, $\\mathrm{max\\_steps} = 25$.\n2. Case B (small-radius edge): $r_c^{(0)} = 0.3$ Bohr, $Z_{\\mathrm{eff}} = 8.0$, $\\alpha = 7.0$, $N_e = 6$, $\\sigma = 0.5$ Bohr, $m = 6$, $a = 0.02$ Bohr, $r_{\\min} = 0.2$ Bohr, $r_{\\max} = 1.5$ Bohr, $\\eta = 0.01$ Bohr$^2$/Hartree, $\\mathrm{tol} = 1\\times 10^{-8}$ Hartree/Bohr, $\\mathrm{max\\_steps} = 30$.\n3. Case C (large-radius edge): $r_c^{(0)} = 2.5$ Bohr, $Z_{\\mathrm{eff}} = 4.0$, $\\alpha = 4.0$, $N_e = 2$, $\\sigma = 0.8$ Bohr, $m = 4$, $a = 0.1$ Bohr, $r_{\\min} = 1.0$ Bohr, $r_{\\max} = 3.0$ Bohr, $\\eta = 0.05$ Bohr$^2$/Hartree, $\\mathrm{tol} = 1\\times 10^{-8}$ Hartree/Bohr, $\\mathrm{max\\_steps} = 20$.\n4. Case D (coarse switching function): $r_c^{(0)} = 1.2$ Bohr, $Z_{\\mathrm{eff}} = 10.0$, $\\alpha = 9.0$, $N_e = 8$, $\\sigma = 0.4$ Bohr, $m = 8$, $a = 0.3$ Bohr, $r_{\\min} = 0.4$ Bohr, $r_{\\max} = 2.5$ Bohr, $\\eta = 0.015$ Bohr$^2$/Hartree, $\\mathrm{tol} = 1\\times 10^{-8}$ Hartree/Bohr, $\\mathrm{max\\_steps} = 40$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order\n$$\n\\left[\\frac{\\partial E}{\\partial r_c}\\Big|_{\\text{Case A, } r_c^{(0)}}, \\, r_c^{\\text{selected, A}}, \\, \\frac{\\partial E}{\\partial r_c}\\Big|_{\\text{Case B, } r_c^{(0)}}, \\, r_c^{\\text{selected, B}}, \\, \\frac{\\partial E}{\\partial r_c}\\Big|_{\\text{Case C, } r_c^{(0)}}, \\, r_c^{\\text{selected, C}}, \\, \\frac{\\partial E}{\\partial r_c}\\Big|_{\\text{Case D, } r_c^{(0)}}, \\, r_c^{\\text{selected, D}}\\right].\n$$\nAll derivatives must be expressed in Hartree per Bohr and all radii in Bohr as floating-point numbers.", "solution": "The problem requires the derivation and implementation of a procedure to optimize the augmentation radius, $r_c$, within a simplified model of the Projector Augmented-Wave (PAW) method. The optimization is guided by the gradient of a model energy functional, $\\partial E/\\partial r_c$.\n\nThe first step is to derive an explicit expression for this gradient. The model for the on-site augmentation energy is given as:\n$$\nE(r_c) = \\int_{0}^{\\infty} 4\\pi r^2 \\, w(r; r_c) \\, F(r) \\, dr + C\n$$\nHere, the energy-density surrogate $F(r)$ and the constant $C$ are independent of the augmentation radius $r_c$. The switching function $w(r; r_c)$ is the sole source of $r_c$ dependence inside the integral. We can therefore apply the Leibniz integral rule (differentiation under the integral sign) to find the derivative of $E$ with respect to $r_c$:\n$$\n\\frac{\\partial E}{\\partial r_c} = \\frac{\\partial}{\\partial r_c} \\left( \\int_{0}^{\\infty} 4\\pi r^2 \\, w(r; r_c) \\, F(r) \\, dr + C \\right) = \\int_{0}^{\\infty} 4\\pi r^2 \\, F(r) \\, \\frac{\\partial w(r; r_c)}{\\partial r_c} \\, dr\n$$\nThis confirms the expression provided in the problem statement, which is a direct consequence of the Hellmann–Feynman theorem applied to the parameter $r_c$.\n\nNext, we must find the explicit form of the partial derivative of the switching function, $\\partial w/\\partial r_c$. The switching function is given by:\n$$\nw(r; r_c) = \\frac{1}{1 + \\exp\\left(\\frac{r - r_c}{a}\\right)}\n$$\nUsing the chain rule, we differentiate with respect to $r_c$:\n$$\n\\frac{\\partial w(r; r_c)}{\\partial r_c} = -\\left(1 + \\exp\\left(\\frac{r - r_c}{a}\\right)\\right)^{-2} \\cdot \\exp\\left(\\frac{r - r_c}{a}\\right) \\cdot \\frac{\\partial}{\\partial r_c}\\left(\\frac{r - r_c}{a}\\right)\n$$\n$$\n\\frac{\\partial w(r; r_c)}{\\partial r_c} = -\\frac{\\exp\\left(\\frac{r - r_c}{a}\\right)}{\\left(1 + \\exp\\left(\\frac{r - r_c}{a}\\right)\\right)^2} \\cdot \\left(-\\frac{1}{a}\\right) = \\frac{1}{a} \\frac{\\exp\\left(\\frac{r - r_c}{a}\\right)}{\\left(1 + \\exp\\left(\\frac{r - r_c}{a}\\right)\\right)^2}\n$$\nThis expression is related to the derivative of the logistic function and can be rewritten in a more numerically stable form using the hyperbolic cosine. Letting $x = (r - r_c)/a$, we have $\\exp(x)/(1+\\exp(x))^2 = 1/(4 \\cosh^2(x/2))$. Thus:\n$$\n\\frac{\\partial w(r; r_c)}{\\partial r_c} = \\frac{1}{a} \\frac{1}{4\\cosh^2\\left(\\frac{r - r_c}{2a}\\right)}\n$$\nThis form avoids potential floating-point overflows that can occur with the exponential form when $r-r_c$ is large.\n\nNow we assemble the complete integrand for $\\partial E/\\partial r_c$. The integrand is $4\\pi r^2 F(r) \\frac{\\partial w}{\\partial r_c}$. We substitute the given expressions for $F(r) = \\Delta n(r) u(r)$:\n\\begin{align*}\n\\Delta n(r) &= n_{\\mathrm{AE}}(r) - n_{\\mathrm{PS}}(r) \\\\\n&= \\left(\\frac{N_e \\alpha^3}{\\pi} e^{-2\\alpha r}\\right) - \\left(\\frac{N_e \\alpha^3}{\\pi} e^{-2\\alpha r}\\right)\\left[1 - e^{-\\left(\\frac{r}{\\sigma}\\right)^{m}}\\right] \\\\\n&= \\frac{N_e \\alpha^3}{\\pi} e^{-2\\alpha r} e^{-\\left(\\frac{r}{\\sigma}\\right)^{m}}\n\\end{align*}\nAnd $u(r) = -Z_{\\mathrm{eff}}/r$. The term $4\\pi r^2 F(r)$ becomes:\n$$\n4\\pi r^2 F(r) = 4\\pi r^2 \\left( \\frac{N_e \\alpha^3}{\\pi} e^{-2\\alpha r - (r/\\sigma)^m} \\right) \\left( -\\frac{Z_{\\mathrm{eff}}}{r} \\right) = -4 N_e \\alpha^3 Z_{\\mathrm{eff}} \\, r \\, e^{-2\\alpha r - (r/\\sigma)^m}\n$$\nThe full integrand is finally:\n$$\nI(r; r_c) = \\left( -4 N_e \\alpha^3 Z_{\\mathrm{eff}} \\, r \\, e^{-2\\alpha r - (r/\\sigma)^m} \\right) \\left( \\frac{1}{a} \\frac{1}{4\\cosh^2\\left(\\frac{r - r_c}{2a}\\right)} \\right)\n$$\nAn important observation is that for all $r > 0$, every term in the integrand has a fixed sign: $Z_{\\mathrm{eff}} > 0$, $N_e > 0$, $\\alpha > 0$, $a > 0$, the exponential and hyperbolic functions are positive. The only negative sign is the explicit one from $u(r)$. Therefore, the integrand $I(r; r_c)$ is strictly negative for all $r > 0$, which implies that the integral $\\partial E/\\partial r_c$ is also strictly negative for any choice of parameters. This means the model energy $E(r_c)$ is a monotonically decreasing function of $r_c$.\n\nThe optimization procedure is a projected gradient-descent update:\n$$\nr_c^{(k+1)} = \\mathrm{Proj}_{[r_{\\min}, r_{\\max}]}\\left(r_c^{(k)} - \\eta \\, \\frac{\\partial E}{\\partial r_c}\\bigg|_{r_c^{(k)}}\\right)\n$$\nSince $\\partial E/\\partial r_c < 0$ and the step size $\\eta > 0$, the term $-\\eta \\, \\partial E/\\partial r_c$ is always positive. Consequently, the optimization algorithm will always increase the value of $r_c$ at each step. The iterative process will terminate under one of three conditions:\n1. The maximum number of iterations, $\\mathrm{max\\_steps}$, is reached.\n2. The magnitude of the gradient, $|\\partial E/\\partial r_c|$, falls below the tolerance, $\\mathrm{tol}$. Given the monotonic nature of $E(r_c)$ in this model, this condition is unlikely to be met unless the gradient magnitude is fortuitously small.\n3. The iteration converges to a fixed point, which occurs if $r_c$ stops changing. This happens if the gradient becomes negligible (as in condition 2) or if $r_c$ reaches a boundary of the projection interval $[r_{\\min}, r_{\\max}]$ and the gradient vector points outward, causing the projection operation to cancel the update. Given that $r_c$ always increases, this will happen if $r_c$ reaches $r_{\\max}$.\n\nThe implementation will consist of three main parts:\n1. A function to compute the integrand, $I(r; r_c)$, using numerically stable forms.\n2. A function to compute the derivative, $\\partial E/\\partial r_c$, by numerically integrating $I(r; r_c)$ from $r=0$ to $r=\\infty$ using a standard quadrature routine such as `scipy.integrate.quad`.\n3. An optimization function that implements the projected gradient descent loop, calling the derivative function at each step, and managing the stopping conditions. This function will calculate the derivative at the initial $r_c^{(0)}$ and return it along with the final, selected $r_c$.\nThe main program will iterate through the provided test cases, call the optimization routine for each, and format the results as specified.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Main solver function to run all test cases and print the final result.\n    \"\"\"\n    test_cases = [\n        # Case A: happy path\n        {'rc0': 1.0, 'Z_eff': 6.0, 'alpha': 6.0, 'Ne': 4, 'sigma': 0.6, 'm': 4, 'a': 0.05,\n         'rmin': 0.5, 'rmax': 2.0, 'eta': 0.02, 'tol': 1e-8, 'max_steps': 25},\n        # Case B: small-radius edge\n        {'rc0': 0.3, 'Z_eff': 8.0, 'alpha': 7.0, 'Ne': 6, 'sigma': 0.5, 'm': 6, 'a': 0.02,\n         'rmin': 0.2, 'rmax': 1.5, 'eta': 0.01, 'tol': 1e-8, 'max_steps': 30},\n        # Case C: large-radius edge\n        {'rc0': 2.5, 'Z_eff': 4.0, 'alpha': 4.0, 'Ne': 2, 'sigma': 0.8, 'm': 4, 'a': 0.1,\n         'rmin': 1.0, 'rmax': 3.0, 'eta': 0.05, 'tol': 1e-8, 'max_steps': 20},\n        # Case D: coarse switching function\n        {'rc0': 1.2, 'Z_eff': 10.0, 'alpha': 9.0, 'Ne': 8, 'sigma': 0.4, 'm': 8, 'a': 0.3,\n         'rmin': 0.4, 'rmax': 2.5, 'eta': 0.015, 'tol': 1e-8, 'max_steps': 40},\n    ]\n\n    results = []\n    for case in test_cases:\n        initial_derivative, final_rc = optimize_rc(case)\n        results.append(initial_derivative)\n        results.append(final_rc)\n    \n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef integrand_func(r, rc, Z_eff, alpha, Ne, sigma, m, a):\n    \"\"\"\n    Computes the integrand for the dE/drc calculation.\n    Integrand = 4*pi*r^2 * F(r) * d(w)/d(rc)\n    \"\"\"\n    # This term combines 4*pi*r^2 and F(r) = Delta_n(r) * u(r)\n    # The exponent can become very large and negative, causing underflow to 0, which is correct.\n    # We add a check to handle this gracefully.\n    try:\n        exp_arg_density = -2.0 * alpha * r - (r / sigma)**m\n    except OverflowError:\n        exp_arg_density = -np.inf\n        \n    if exp_arg_density < -700.0:  # np.exp(-709) is ~1e-308\n        term_F_part = 0.0\n    else:\n        term_F_part = r * np.exp(exp_arg_density)\n    \n    term_F = -4.0 * Ne * alpha**3 * Z_eff * term_F_part\n\n    # This term is d(w)/d(rc) = (1/a) * 1 / (4 * cosh^2((r-rc)/(2a)))\n    # This form is numerically stable.\n    x = (r - rc) / (2.0 * a)\n    \n    # cosh(x) overflows for |x| > ~710. Use asymptotic behavior to prevent this.\n    if abs(x) > 300.0: # Safe cutoff\n        # For large |x|, 1/(4*cosh^2(x)) -> exp(-2*|x|)\n        term_dw_drc_part = np.exp(-2.0 * abs(x))\n    else:\n        cosh_x = np.cosh(x)\n        term_dw_drc_part = 1.0 / (4.0 * cosh_x**2)\n    \n    term_dw_drc = (1.0 / a) * term_dw_drc_part\n\n    return term_F * term_dw_drc\n\ndef calculate_derivative(rc, params):\n    \"\"\"\n    Calculates dE/drc by numerically integrating the integrand.\n    \"\"\"\n    integral_val, _ = quad(\n        integrand_func, 0, np.inf,\n        args=(\n            rc, params['Z_eff'], params['alpha'], params['Ne'], \n            params['sigma'], params['m'], params['a']\n        )\n    )\n    return integral_val\n\ndef optimize_rc(params):\n    \"\"\"\n    Performs projected gradient descent to find the optimal rc.\n    \"\"\"\n    rc = params['rc0']\n    rmin, rmax = params['rmin'], params['rmax']\n    eta, tol, max_steps = params['eta'], params['tol'], params['max_steps']\n\n    # Calculate and store the derivative at the initial rc\n    initial_derivative = calculate_derivative(rc, params)\n\n    for _ in range(max_steps):\n        dE_drc = calculate_derivative(rc, params)\n\n        # Stop if the gradient magnitude is below the tolerance\n        if abs(dE_drc) < tol:\n            break\n\n        # Perform gradient update step\n        rc_new = rc - eta * dE_drc\n\n        # Project the new rc onto the allowed interval [rmin, rmax]\n        rc_proj = max(rmin, min(rmax, rc_new))\n        \n        # Stop if rc has converged to a fixed point (interior or boundary)\n        if np.isclose(rc_proj, rc):\n            rc = rc_proj\n            break\n            \n        rc = rc_proj\n\n    return initial_derivative, rc\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3480862"}]}