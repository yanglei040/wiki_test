{"hands_on_practices": [{"introduction": "The starting point for predicting phase stability is at zero temperature ($T=0$), where entropy plays no role and the problem simplifies to pure energy minimization. This exercise uses formation energies, typically obtained from first-principles calculations, to construct the ground-state phase diagram for a binary system. The stability of compounds and mixtures is determined by the lower convex hull of the formation energy $E_f$ versus composition $x$, a fundamental geometric construction that provides a powerful and intuitive method for identifying stable phases. This practice solidifies the connection between quantum mechanical energy calculations and macroscopic thermodynamic stability, forming the bedrock of ab initio phase diagram prediction. [@problem_id:3474911]", "problem": "You are given formation energies at zero temperature for ordered binary compounds computed from first-principles electronic structure calculations. For a binary system, composition is represented by the atomic fraction of component $B$, denoted $x \\in [0,1]$, and the formation energy per atom of an ordered configuration at composition $x$ is denoted $E_f(x)$, measured in electronvolts per atom. At zero temperature ($T = 0$), thermodynamic stability is determined by minimizing the energy. A mixture of two phases at compositions $x_1$ and $x_2$ can realize any overall composition $x = \\lambda x_1 + (1-\\lambda)x_2$, with $0 \\le \\lambda \\le 1$, and has energy $E_{\\text{mix}}(x) = \\lambda E_f(x_1) + (1-\\lambda) E_f(x_2)$, assuming ideal phase separation and no interaction energy between phases in a two-phase mixture. A single-phase ordered compound at composition $x$ is stable if and only if it lies on the lower convex envelope of the set $\\{(x_i, E_f(x_i))\\}$, meaning that $E_f(x)$ cannot be lowered by decomposing into a mixture of other phases. The lower convex envelope is the lower convex hull in the two-dimensional plane where the horizontal axis is $x$ and the vertical axis is $E_f$.\n\nStarting from these thermodynamic and geometric principles, construct the lower convex hull of $E_f$ versus $x$ for each provided test set. Then, for each hull, identify:\n- The breakpoints (hull vertices) at compositions $x_i$ and their energies $E_f(x_i)$, both expressed in their appropriate units ($x$ is dimensionless as a fraction of component $B$, and energies must be expressed in electronvolts per atom).\n- The interior stable ordered compounds (those vertices strictly within $0 < x < 1$).\n- The two-phase composition intervals $(x_{\\text{low}}, x_{\\text{high}})$ between successive hull vertices where any composition in the open interval decomposes into the two endpoint phases. Report each interval as a pair $[x_{\\text{low}}, x_{\\text{high}}]$ of floats.\n- For each two-phase facet (tie-line) connecting successive hull vertices $(x_i, E_f(x_i))$ and $(x_{i+1}, E_f(x_{i+1}))$, compute:\n  1. The facet slope $m = \\dfrac{E_f(x_{i+1}) - E_f(x_i)}{x_{i+1} - x_i}$, reported in electronvolts per atom per composition fraction.\n  2. A unit normal vector $\\hat{\\boldsymbol{n}}$ to the facet in the $(x, E_f)$-plane, oriented such that its energy component is negative (i.e., the second component of $\\hat{\\boldsymbol{n}}$ is $< 0$). For an edge vector $\\boldsymbol{v} = (x_{i+1} - x_i, E_f(x_{i+1}) - E_f(x_i))$ with $x_{i+1} > x_i$, define the (non-normalized) normal as $\\boldsymbol{n} = (E_f(x_{i+1}) - E_f(x_i), -(x_{i+1} - x_i))$, and obtain the unit normal by $\\hat{\\boldsymbol{n}} = \\frac{\\boldsymbol{n}}{\\lVert \\boldsymbol{n} \\rVert}$, where $\\lVert \\cdot \\rVert$ is the Euclidean norm.\n\nUse only the fundamental geometric operations implied by convexity and the definitions above; do not assume any specialized hull routines. If the dataset contains repeated compositions, you must keep the lowest energy among duplicates at the same composition. If $x=0$ and $x=1$ are not present, you must include the pure-element endpoints at $x=0$ and $x=1$ with $E_f(0)=0$ and $E_f(1)=0$ in electronvolts per atom, since formation energies are defined relative to the pure elements.\n\nYour program must implement the following for each test case:\n1. Construct the lower convex hull of the points $(x_i, E_f(x_i))$.\n2. Return:\n   - The list of breakpoint compositions $[x_0, x_1, \\dots, x_k]$ on the hull, in increasing order.\n   - The list of breakpoint energies $[E_f(x_0), E_f(x_1), \\dots, E_f(x_k)]$ in electronvolts per atom, aligned with the breakpoint compositions.\n   - The list of interior stable ordered compounds $[x_j]$ with $0 < x_j < 1$.\n   - The list of two-phase intervals $[[x_0, x_1], [x_1, x_2], \\dots, [x_{k-1}, x_k]]$.\n   - The list of unit facet normals $[[n_x^{(0)}, n_E^{(0)}], \\dots, [n_x^{(k-1)}, n_E^{(k-1)}]]$.\n   - The list of facet slopes $[m_0, m_1, \\dots, m_{k-1}]$ in electronvolts per atom per composition fraction.\n\nPhysical units:\n- Energies must be reported in electronvolts per atom.\n- Slopes must be reported in electronvolts per atom per composition fraction.\n- Compositions are dimensionless fractions in $[0,1]$.\n\nAngle units are not involved. No percentages should be used; compositions must be decimal fractions.\n\nTest suite:\n- Case A (happy path, multiple interior candidates):\n  - $x = [\\,0.0,\\,0.25,\\,0.33,\\,0.5,\\,0.66,\\,0.75,\\,1.0\\,]$\n  - $E_f = [\\,0.0,\\,-0.08,\\,-0.15,\\,-0.12,\\,-0.14,\\,-0.09,\\,0.0\\,]$ in electronvolts per atom\n- Case B (boundary condition with a point on a tie-line):\n  - $x = [\\,0.0,\\,0.4,\\,0.6,\\,1.0\\,]$\n  - $E_f = [\\,0.0,\\,-0.05,\\,-0.075,\\,0.0\\,]$ in electronvolts per atom\n- Case C (duplicate composition, keep lowest energy):\n  - $x = [\\,0.0,\\,0.5,\\,0.5,\\,1.0\\,]$\n  - $E_f = [\\,0.0,\\,-0.10,\\,-0.12,\\,0.0\\,]$ in electronvolts per atom\n- Case D (central deep minimum, symmetric shallow minima near ends):\n  - $x = [\\,0.0,\\,0.2,\\,0.5,\\,0.8,\\,1.0\\,]$\n  - $E_f = [\\,0.0,\\,-0.02,\\,-0.14,\\,-0.02,\\,0.0\\,]$ in electronvolts per atom\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case result shall be a list of six items in the order specified above. The entire output shall be represented in JavaScript Object Notation (JSON) with no spaces, for example:\n\"[caseA_result,caseB_result,caseC_result,caseD_result]\".", "solution": "The problem requires the construction of the lower convex hull for a set of points representing the formation energy $E_f$ versus composition $x$ for a binary system at zero temperature, $T=0$. From this hull, several thermodynamic and geometric properties must be extracted. The solution approach is grounded in the fundamental principles of thermodynamic stability and computational geometry.\n\nAt $T=0$, the Gibbs free energy of a system is equal to its internal energy. For a binary alloy, the stable state at a given overall composition is the one that minimizes the total energy per atom. A single-phase ordered compound with composition $x_i$ and formation energy $E_f(x_i)$ is thermodynamically stable if and only if its corresponding point $(x_i, E_f(x_i))$ lies on the lower convex envelope of all possible configurations $\\{ (x_j, E_f(x_j)) \\}$. Any composition $x$ that falls between two stable compounds on the hull, say at $x_i$ and $x_{i+1}$, will decompose into a two-phase mixture of these compounds. The energy of such a mixture lies on the straight line segment, or tie-line, connecting the points $(x_i, E_f(x_i))$ and $(x_{i+1}, E_f(x_{i+1}))$. This geometric construction is known as the convex hull of the formation energies.\n\nThe algorithm to solve this problem is implemented in three stages: data preprocessing, lower convex hull construction, and extraction of physical quantities.\n\n**Step 1: Data Preprocessing**\n\nFirst, the input data, consisting of compositions $x$ and formation energies $E_f$, must be prepared for the hull-finding algorithm.\n1.  **Duplicate Compositions**: The problem states that if multiple energy values exist for the same composition, only the point with the lowest energy is thermodynamically relevant. We enforce this by using a dictionary to ensure only the minimum energy for each unique composition is retained.\n2.  **Endpoints**: The formation energy $E_f$ is defined relative to the pure elements, so the points $(0, 0)$ and $(1, 0)$ must be included in our set of points.\n3.  **Sorting**: The set of unique points is then sorted in ascending order based on the composition $x$. This is a prerequisite for the Monotone Chain algorithm. Let the sorted points be $p_0, p_1, \\dots, p_{N-1}$.\n\n**Step 2: Lower Convex Hull Construction**\n\nWe implement the Monotone Chain algorithm (also known as Andrew's algorithm), adapted to find only the lower convex hull. This algorithm iterates through the sorted points and builds the hull incrementally using an orientation test based on the 2D cross-product. For three points $p_1=(x_1, y_1)$, $p_2=(x_2, y_2)$, and $p_3=(x_3, y_3)$, the cross-product is:\n$$ \\text{cross\\_product}(p_1, p_2, p_3) = (x_2 - x_1)(y_3 - y_1) - (y_2 - y_1)(x_3 - x_1) $$\nA positive sign indicates a \"left turn\" (concave up), which is what a lower hull is made of. The algorithm maintains a stack of hull vertices. For each new point, we pop points from the stack if they form a \"right turn\" or are collinear with the new point (i.e., cross-product $\\le 0$). This correctly identifies the vertices of the hull.\n\n**Step 3: Extraction of Physical Quantities**\n\nOnce the list of hull vertices, $\\{ (x_0, E_f(x_0)), \\dots, (x_k, E_f(x_k)) \\}$, is determined, we derive the required properties:\n1.  **Breakpoints and Energies**: These are the coordinates of the vertices in the final `lower_hull` list.\n2.  **Interior Stable Compounds**: These are the hull vertices with compositions $x_i$ such that $0 < x_i < 1$.\n3.  **Two-Phase Intervals**: Each edge of the hull corresponds to a two-phase interval $[x_i, x_{i+1}]$ between successive vertices.\n4.  **Facet Slopes and Normals**: For each edge (tie-line) connecting successive vertices, we compute the slope and normal. Let the edge vector be $\\boldsymbol{v} = (\\Delta x, \\Delta E)$.\n    -   **Slope ($m$)**: $m = \\Delta E / \\Delta x$.\n    -   **Unit Normal Vector ($\\hat{\\boldsymbol{n}}$)**: A normal vector is given by $\\boldsymbol{n} = (\\Delta E, -\\Delta x)$. Its second component is negative as required. The unit normal is found by dividing $\\boldsymbol{n}$ by its Euclidean norm:\n        $$ \\hat{\\boldsymbol{n}} = \\frac{\\boldsymbol{n}}{\\lVert \\boldsymbol{n} \\rVert} = \\frac{(\\Delta E, -\\Delta x)}{\\sqrt{(\\Delta E)^2 + (-\\Delta x)^2}} $$\nThis procedure robustly solves the problem by combining data sanitization, a classic geometric algorithm, and physics-based calculations.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport json\n\ndef solve():\n    \"\"\"\n    Main solver function that processes all test cases and prints the final result.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"x\": [0.0, 0.25, 0.33, 0.5, 0.66, 0.75, 1.0],\n            \"E_f\": [0.0, -0.08, -0.15, -0.12, -0.14, -0.09, 0.0]\n        },\n        {\n            \"x\": [0.0, 0.4, 0.6, 1.0],\n            \"E_f\": [0.0, -0.05, -0.075, 0.0]\n        },\n        {\n            \"x\": [0.0, 0.5, 0.5, 1.0],\n            \"E_f\": [0.0, -0.10, -0.12, 0.0]\n        },\n        {\n            \"x\": [0.0, 0.2, 0.5, 0.8, 1.0],\n            \"E_f\": [0.0, -0.02, -0.14, -0.02, 0.0]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        case_result = compute_phase_diagram(case[\"x\"], case[\"E_f\"])\n        results.append(json.dumps(case_result, separators=(',', ':')))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef compute_phase_diagram(compositions, energies):\n    \"\"\"\n    Computes the lower convex hull and derives thermodynamic properties for a single binary system.\n\n    Args:\n        compositions (list[float]): List of atomic fractions of component B.\n        energies (list[float]): List of formation energies in eV/atom.\n\n    Returns:\n        list: A list containing six lists:\n              1. Breakpoint compositions on the hull.\n              2. Breakpoint energies on the hull.\n              3. Compositions of interior stable compounds.\n              4. Two-phase composition intervals.\n              5. Unit normal vectors for each facet.\n              6. Slopes for each facet.\n    \"\"\"\n    \n    # Step 1: Data Preprocessing\n    points_map = {}\n    for x, e in zip(compositions, energies):\n        if x in points_map:\n            points_map[x] = min(points_map[x], e)\n        else:\n            points_map[x] = e\n            \n    # Ensure endpoints are present with Ef=0\n    points_map[0.0] = min(points_map.get(0.0, 0.0), 0.0)\n    points_map[1.0] = min(points_map.get(1.0, 0.0), 0.0)\n\n    # Sort points by composition\n    sorted_points = sorted(points_map.items())\n\n    # Step 2: Lower Convex Hull Construction (Monotone Chain)\n    def cross_product(p1, p2, p3):\n        # (x2-x1)*(y3-y1) - (y2-y1)*(x3-x1)\n        return (p2[0] - p1[0]) * (p3[1] - p1[1]) - (p2[1] - p1[1]) * (p3[0] - p1[0])\n\n    lower_hull = []\n    # Using a small tolerance for floating point comparisons\n    epsilon = 1e-9\n\n    for p in sorted_points:\n        # Pop points that create a right turn or are collinear\n        while len(lower_hull) >= 2 and cross_product(lower_hull[-2], lower_hull[-1], p) <= epsilon:\n            lower_hull.pop()\n        lower_hull.append(p)\n\n    # Step 3: Extraction of Physical Quantities\n    hull_x = [p[0] for p in lower_hull]\n    hull_e = [p[1] for p in lower_hull]\n\n    interior_stable_x = [x for x in hull_x if 0 < x < 1]\n    \n    two_phase_intervals = []\n    facet_normals = []\n    facet_slopes = []\n\n    for i in range(len(lower_hull) - 1):\n        p1 = lower_hull[i]\n        p2 = lower_hull[i+1]\n        \n        # Two-phase interval\n        two_phase_intervals.append([p1[0], p2[0]])\n\n        # Facet slope and normal\n        dx = p2[0] - p1[0]\n        de = p2[1] - p1[1]\n\n        if abs(dx) < epsilon: # Should not happen with pre-processing\n            continue\n            \n        # Slope\n        slope = de / dx\n        facet_slopes.append(slope)\n\n        # Normal vector n = (dE, -dx)\n        # The second component, -dx, is guaranteed negative since dx > 0\n        norm_magnitude = np.sqrt(de**2 + (-dx)**2)\n        if norm_magnitude < epsilon:\n            unit_normal = [0.0, 0.0] # Should not happen for distinct points\n        else:\n            unit_normal = [de / norm_magnitude, -dx / norm_magnitude]\n        facet_normals.append(unit_normal)\n        \n    return [hull_x, hull_e, interior_stable_x, two_phase_intervals, facet_normals, facet_slopes]\n\n\nif __name__ == '__main__':\n    solve()\n\n```", "id": "3474911"}, {"introduction": "Building upon the zero-temperature foundation, we introduce the crucial effects of temperature and entropy, which govern phase stability at finite temperatures. This requires minimizing the Gibbs free energy, using more sophisticated thermodynamic models that can describe complex phases. This exercise employs the CALPHAD (Calculation of Phase Diagrams) approach, where you will minimize the total Gibbs energy of a system containing both a disordered solution phase and an ordered intermetallic phase. By implementing this constrained numerical optimization, you will gain hands-on experience with the engine of modern computational thermodynamics and learn how to directly compute equilibrium phase fractions and compositions. [@problem_id:3474861]", "problem": "You are given a binary alloy system with components $A$ and $B$ that can exist in two phases at fixed pressure: a disordered substitutional solution phase (denoted as $D$) and an ordered phase with two crystallographically distinct sublattices (denoted as $O$). Assume the thermodynamic equilibrium at fixed temperature $T$ and overall composition $\\bar{x}_B$ is obtained by minimizing the total molar Gibbs energy with respect to the phase fractions and internal compositions subject to mass balance. The goal is to compute an isopleth along specified temperatures by solving this constrained minimization problem at each $T$. The program you write must implement the following physically grounded definitions and compute the requested outputs.\n\nFundamental base and definitions:\n- At constant temperature $T$ and pressure $p$, the equilibrium state of a multicomponent, multiphase system minimizes the total molar Gibbs energy $G$ subject to conservation of mass. This follows from the second law of thermodynamics and the definition of the Gibbs energy as $G = H - T S$, where $H$ is enthalpy and $S$ is entropy.\n- For the disordered substitutional phase $D$ (with random mixing on a single lattice), the molar Gibbs energy as a function of the mole fraction $x_B$ and temperature $T$ is given by\n$$\nG^{D}(x_B, T) = x_A G_A^0(T) + x_B G_B^0(T) + R T \\left( x_A \\ln x_A + x_B \\ln x_B \\right) + x_A x_B \\sum_{k=0}^{1} L_k(T) \\left( x_A - x_B \\right)^k,\n$$\nwhere $x_A = 1 - x_B$, $R$ is the universal gas constant, $G_A^0(T)$ and $G_B^0(T)$ are the reference Gibbs energies of the pure components in phase $D$, and $L_k(T)$ are the Redlich-Kister interaction coefficients. In this problem, take\n$$\nG_A^0(T) = 0, \\quad G_B^0(T) = 0,\n$$\n$$\nL_0(T) = 12000 - 5 T \\quad \\text{J/mol}, \\qquad L_1(T) = 2000 - 1.5 T \\quad \\text{J/mol},\n$$\nwith $T$ in Kelvin and $R = 8.314462618$ J/(mol K). The logarithms are natural logarithms.\n\n- For the ordered phase $O$, assume two sublattices $\\alpha$ and $\\beta$, each of multiplicity $1$ per formula unit. Let $y_B^\\alpha$ and $y_B^\\beta$ denote the site fractions of $B$ on sublattices $\\alpha$ and $\\beta$, and $y_A^\\alpha = 1 - y_B^\\alpha$, $y_A^\\beta = 1 - y_B^\\beta$. The molar Gibbs energy for $O$ is given by the Compound Energy Formalism as\n$$\nG^{O}(y_B^\\alpha, y_B^\\beta, T) = \\sum_{i \\in \\{A,B\\}} \\sum_{j \\in \\{A,B\\}} y_i^\\alpha y_j^\\beta \\, G_{i:j}(T) + R T \\left[ y_A^\\alpha \\ln y_A^\\alpha + y_B^\\alpha \\ln y_B^\\alpha + y_A^\\beta \\ln y_A^\\beta + y_B^\\beta \\ln y_B^\\beta \\right],\n$$\nwhere the endmember Gibbs energies are\n$$\nG_{A:B}(T) = -8000 + 1.5 T \\quad \\text{J/mol}, \\quad G_{B:A}(T) = -8000 + 1.5 T \\quad \\text{J/mol},\n$$\n$$\nG_{A:A}(T) = 6000 + 0.5 T \\quad \\text{J/mol}, \\quad G_{B:B}(T) = 6000 + 0.5 T \\quad \\text{J/mol}.\n$$\nThe overall $B$ composition of the ordered phase is\n$$\nx_B^{O} = \\frac{y_B^\\alpha + y_B^\\beta}{2}.\n$$\n\n- Let $f_O$ be the molar phase fraction of the ordered phase ($O$) and $f_D = 1 - f_O$ be the molar phase fraction of the disordered phase ($D$). The overall $B$ composition constraint is\n$$\nf_D \\, x_B^{D} + f_O \\, x_B^{O} = \\bar{x}_B,\n$$\nwith $x_B^{D} \\in (0,1)$ and $y_B^\\alpha, y_B^\\beta \\in (0,1)$. The total molar Gibbs energy to be minimized is\n$$\nG_{\\text{tot}} = f_D \\, G^{D}(x_B^{D}, T) + f_O \\, G^{O}(y_B^\\alpha, y_B^\\beta, T),\n$$\nsubject to $f_O \\in [0,1]$ and the mass balance equality above.\n\nComputational requirements:\n- For each test case $(T, \\bar{x}_B)$, compute the equilibrium by minimizing $G_{\\text{tot}}$ with respect to $f_O$, $x_B^{D}$, $y_B^\\alpha$, and $y_B^\\beta$, subject to the stated bounds and the composition equality constraint. All energies are in $\\text{J/mol}$ and temperature is in $\\text{K}$. Your algorithm must be fully deterministic and must not require any user input.\n- To ensure numerical stability of logarithms near $0$ and $1$, you must handle the domain safely in your implementation (for example, by internally clipping to an $\\varepsilon$ neighborhood).\n- The final quantity to report for each test case is the equilibrium ordered phase fraction $f_O^\\star$ as a float.\n\nTest suite:\n- Use the following four test cases, each a pair $(T, \\bar{x}_B)$ with $T$ in $\\text{K}$ and $\\bar{x}_B$ dimensionless:\n    1. $(800, 0.5)$\n    2. $(1000, 0.5)$\n    3. $(1400, 0.5)$\n    4. $(1000, 0.3)$\n\nFinal output specification:\n- Your program should produce a single line of output containing the equilibrium ordered phase fractions for the four test cases, in the same order as listed, as a comma-separated list enclosed in square brackets. Each number must be rounded to six decimal places, with no spaces. For example, an output of the form $[0.123456,0.654321,0.000000,1.000000]$ satisfies the format requirement.", "solution": "The problem requires calculating the equilibrium state of a binary alloy by minimizing the total Gibbs energy. This is a classic problem in computational thermodynamics (CALPHAD). The equilibrium state is found by solving a constrained nonlinear optimization problem based on the second law of thermodynamics.\n\nThe objective is to find the set of variables—phase fraction of the ordered phase ($f_O$), composition of the disordered phase ($x_B^D$), and site fractions of the ordered phase ($y_B^\\alpha, y_B^\\beta$)—that minimizes the total molar Gibbs energy of the system:\n$$\nG_{\\text{tot}} = (1 - f_O) G^D(x_B^D, T) + f_O G^O(y_B^\\alpha, y_B^\\beta, T)\n$$\nThis minimization is performed subject to a mass balance constraint that conserves the overall composition $\\bar{x}_B$:\n$$\n(1 - f_O) x_B^D + f_O \\left( \\frac{y_B^\\alpha + y_B^\\beta}{2} \\right) = \\bar{x}_B\n$$\nThe variables are also bounded by physical limits (e.g., $f_O \\in [0, 1]$). The Gibbs energy functions, $G^D$ and $G^O$, are standard CALPHAD models (Redlich-Kister and Compound Energy Formalism, respectively).\n\nThe computational strategy is as follows:\n1.  **Numerical Optimization**: The problem is implemented using `scipy.optimize.minimize` with the `SLSQP` algorithm, which is well-suited for problems with both equality and boundary constraints.\n2.  **Objective Function and Constraints**: The total Gibbs energy and mass balance equations are implemented as Python functions that the optimizer can evaluate.\n3.  **Numerical Stability**: The logarithmic terms in the Gibbs energy models require special handling to avoid errors at compositions near 0 or 1. Input values to logarithms are clipped to a small interval $[\\varepsilon, 1-\\varepsilon]$.\n4.  **Global Minimum Search**: The Gibbs energy surface can be non-convex, possessing multiple local minima. To find the true global minimum representing thermodynamic equilibrium, the optimization is run multiple times from a diverse set of physically motivated initial guesses (e.g., pure disordered phase, pure ordered phase, and various two-phase mixtures). The result corresponding to the lowest final Gibbs energy is selected as the correct solution.\n\nThis robust optimization procedure ensures a deterministic and accurate calculation of the equilibrium phase fraction for each test case.", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    \"\"\"\n    Calculates the equilibrium phase fractions for a binary alloy system\n    by minimizing the total Gibbs free energy.\n    \"\"\"\n    R = 8.314462618  # Universal gas constant in J/(mol K)\n    EPS = 1e-9       # Small number for numerical stability of logarithms\n\n    test_cases = [\n        (800.0, 0.5),\n        (1000.0, 0.5),\n        (1400.0, 0.5),\n        (1000.0, 0.3)\n    ]\n\n    final_results = []\n\n    for T, xB_bar in test_cases:\n        # Define Gibbs energy functions as closures over temperature T\n        def G_D_func(xB):\n            \"\"\"Molar Gibbs energy of the disordered phase.\"\"\"\n            L0 = 12000.0 - 5.0 * T\n            L1 = 2000.0 - 1.5 * T\n            \n            xA = 1.0 - xB\n            \n            # Clip for log stability\n            xB_c = np.clip(xB, EPS, 1.0 - EPS)\n            xA_c = 1.0 - xB_c\n            \n            G_ideal = R * T * (xA_c * np.log(xA_c) + xB_c * np.log(xB_c))\n            G_excess = xA * xB * (L0 + L1 * (xA - xB))\n            \n            return G_ideal + G_excess\n\n        def G_O_func(y_vec):\n            \"\"\"Molar Gibbs energy of the ordered phase.\"\"\"\n            yBa, yBb = y_vec\n            yAa = 1.0 - yBa\n            yAb = 1.0 - yBb\n            \n            G_AA = 6000.0 + 0.5 * T\n            G_BB = 6000.0 + 0.5 * T\n            G_AB = -8000.0 + 1.5 * T\n            G_BA = -8000.0 + 1.5 * T\n            \n            G_endmembers = yAa * yAb * G_AA + yAa * yBb * G_AB + yBa * yAb * G_BA + yBa * yBb * G_BB\n            \n            # Clip for log stability\n            yAa_c = np.clip(yAa, EPS, 1.0 - EPS)\n            yBa_c = np.clip(yBa, EPS, 1.0 - EPS)\n            yAb_c = np.clip(yAb, EPS, 1.0 - EPS)\n            yBb_c = np.clip(yBb, EPS, 1.0 - EPS)\n            \n            G_entropy = R * T * (yAa_c * np.log(yAa_c) + yBa_c * np.log(yBa_c) + \\\n                                 yAb_c * np.log(yAb_c) + yBb_c * np.log(yBb_c))\n            \n            return G_endmembers + G_entropy\n\n        def get_eq_ordered_site_fracs(x_O):\n            \"\"\"Finds equilibrium site fractions for ordered phase at composition x_O.\"\"\"\n            def obj_G_O(y):\n                return G_O_func(y)\n\n            cons_O = {'type': 'eq', 'fun': lambda y: 0.5 * (y[0] + y[1]) - x_O}\n            bounds_O = ((EPS, 1.0 - EPS), (EPS, 1.0 - EPS))\n            \n            # Start from disordered and ordered initial guesses\n            y0_disordered = [x_O, x_O]\n            y0_ordered1 = [np.clip(x_O - 0.45, EPS, 1-EPS), np.clip(x_O + 0.45, EPS, 1-EPS)]\n            y0_ordered2 = [np.clip(x_O + 0.45, EPS, 1-EPS), np.clip(x_O - 0.45, EPS, 1-EPS)]\n            \n            best_res_O = None\n            for y0 in [y0_disordered, y0_ordered1, y0_ordered2]:\n                res = minimize(obj_G_O, y0, method='SLSQP', bounds=bounds_O, constraints=cons_O)\n                if res.success:\n                    if best_res_O is None or res.fun < best_res_O.fun:\n                        best_res_O = res\n            \n            return best_res_O.x if best_res_O else np.array([x_O, x_O])\n\n        def objective(v):\n            \"\"\"Total Gibbs energy of the two-phase system.\"\"\"\n            fO, xBD, yBa, yBb = v\n            fD = 1.0 - fO\n            \n            term_D = 0.0\n            if fD > EPS:\n                term_D = fD * G_D_func(xBD)\n                \n            term_O = 0.0\n            if fO > EPS:\n                term_O = fO * G_O_func([yBa, yBb])\n                \n            return term_D + term_O\n\n        def constraint(v):\n            \"\"\"Mass balance constraint.\"\"\"\n            fO, xBD, yBa, yBb = v\n            xBO = 0.5 * (yBa + yBb)\n            return (1.0 - fO) * xBD + fO * xBO - xB_bar\n\n        bounds = ((0.0, 1.0), (EPS, 1.0 - EPS), (EPS, 1.0 - EPS), (EPS, 1.0 - EPS))\n        cons = {'type': 'eq', 'fun': constraint}\n\n        # Generate a diverse set of initial guesses\n        x0_list = []\n        # 1. Pure disordered phase\n        x0_list.append([0.0, xB_bar, xB_bar, xB_bar])\n        # 2. Pure ordered phase (with internal equilibrium)\n        y_eq = get_eq_ordered_site_fracs(xB_bar)\n        x0_list.append([1.0, xB_bar, y_eq[0], y_eq[1]])\n        # 3. Two-phase mixture, D(A-rich) + O(ordered-stoich)\n        x0_list.append([0.5, 0.1, 0.01, 0.99])\n        # 4. Two-phase mixture, D(B-rich) + O(ordered-stoich)\n        x0_list.append([0.5, 0.9, 0.99, 0.01])\n        \n        best_res = None\n\n        for x0 in x0_list:\n            res = minimize(objective, x0, method='SLSQP', bounds=bounds, constraints=cons)\n            if res.success:\n                if best_res is None or res.fun < best_res.fun:\n                    best_res = res\n        \n        if best_res is not None:\n            final_fO = best_res.x[0]\n        else:\n            final_fO = np.nan # Should not happen with this setup\n\n        final_results.append(final_fO)\n\n    formatted_results = [\"{:.6f}\".format(r) for r in final_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3474861"}, {"introduction": "Phase diagrams map regions of global thermodynamic equilibrium, but they don't tell the whole story about phase separation kinetics. The mechanism of transformation is governed by the local curvature of the free energy surface, which determines whether a phase is locally stable, metastable, or unstable. This practice delves into local stability by analyzing the Hessian matrix of the Gibbs free energy, $\\mathbf{H}_{ij} = \\frac{\\partial^2 G}{\\partial x_i \\partial x_j}$, for a ternary system. By identifying where this matrix ceases to be positive definite, you will calculate the spinodal boundary, which is crucial for understanding decomposition pathways like spinodal decomposition versus nucleation and growth. [@problem_id:3474922]", "problem": "You will write a complete, runnable program that implements a principled computation of spinodal boundaries in a ternary mixture at constant temperature and pressure by analyzing the loss of positive definiteness of the composition-constrained Hessian of the nondimensional molar Gibbs free energy. The fundamental base is the thermodynamic stability condition: at fixed temperature and pressure, local stability of a mixture requires that the second variation of the Gibbs free energy be positive for all allowed composition variations. For a ternary system with compositions $\\mathbf{x}=(x_1,x_2,x_3)$, the mass conservation constraint imposes $x_1+x_2+x_3=1$, and a convenient independent coordinate choice is $(x_1,x_2)$ with $x_3=1-x_1-x_2$, where $0<x_i<1$. The nondimensional molar Gibbs free energy for a regular solution model may be written as\n$$\ng(\\mathbf{x})=\\sum_{i=1}^{3} x_i \\ln x_i + \\sum_{1\\le i<j\\le 3} \\chi_{ij}\\, x_i x_j,\n$$\nwhere $\\chi_{ij}$ are dimensionless symmetric pair interaction parameters. The $2\\times 2$ reduced Hessian $\\mathbf{H}(x_1,x_2)$ is defined as the matrix of second partial derivatives of $g$ with respect to $(x_1,x_2)$ after eliminating $x_3$ via $x_3=1-x_1-x_2$. A composition is locally stable if and only if $\\mathbf{H}(x_1,x_2)$ is positive definite. The spinodal boundary is the locus where the smallest eigenvalue of $\\mathbf{H}(x_1,x_2)$ vanishes, and the spinodal region is where this smallest eigenvalue is strictly negative. All quantities in this problem are dimensionless.\n\nYour program must:\n- Derive the explicit $2\\times 2$ Hessian $\\mathbf{H}(x_1,x_2)$ starting from the above definition of $g(\\mathbf{x})$ and the constraint $x_3=1-x_1-x_2$.\n- For each specified test case, discretize the interior of the composition triangle by a uniform grid of resolution $N$, meaning you consider points on the set $\\{(x_1,x_2): x_1=i/N,\\, x_2=j/N,\\, i,j\\in\\mathbb{Z}_{\\ge 0},\\, i+j\\le N\\}$ and exclude points with any $x_i$ less than a small cutoff $\\delta$ to avoid the singularity of $\\ln x_i$. Use $\\delta=10^{-6}$.\n- At each interior grid point, compute the smallest eigenvalue of $\\mathbf{H}(x_1,x_2)$ and classify the point as unstable if this smallest eigenvalue is strictly less than $0$ within a numerical tolerance $\\tau=10^{-10}$, that is, if the smallest eigenvalue is less than $-\\tau$.\n- For each test case, compute two quantities:\n  1. The fraction of interior grid points classified as unstable, as a float in $[0,1]$, rounded to $6$ decimals.\n  2. A boolean indicating whether the equimolar composition $x_1=x_2=x_3=1/3$ is unstable.\n- Aggregate the results for all test cases into a single line of output containing a list of pairs, where each pair is of the form $[f,b]$ with $f$ the rounded float and $b$ the boolean, for the three test cases in order.\n\nTest suite:\n- Test case $1$ (happy path, stable regime): $(\\chi_{12},\\chi_{13},\\chi_{23})=(0.5,0.5,0.5)$, $N=120$.\n- Test case $2$ (symmetric, strongly interacting, unstable interior): $(\\chi_{12},\\chi_{13},\\chi_{23})=(3.5,3.5,3.5)$, $N=120$.\n- Test case $3$ (asymmetric interactions, mixed stability): $(\\chi_{12},\\chi_{13},\\chi_{23})=(2.8,0.8,3.2)$, $N=100$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each element itself a two-element list in the order of the test suite. For example, the output must look like $[[f_1,b_1],[f_2,b_2],[f_3,b_3]]$ with $f_k$ rounded to $6$ decimals and $b_k$ a boolean literal.", "solution": "The problem requires identifying the unstable region within a ternary mixture's composition space. The solution is based on the thermodynamic principle that a system at constant temperature and pressure is locally stable only if its Gibbs free energy is convex with respect to composition fluctuations. The spinodal boundary is the limit of this local stability.\n\nMathematically, this stability criterion means the Hessian matrix of the Gibbs free energy, with respect to independent composition variables, must be positive definite. For the given ternary system ($x_1+x_2+x_3=1$), we express the molar Gibbs energy $g$ as a function of two independent variables, $x_1$ and $x_2$. The $2 \\times 2$ reduced Hessian matrix $\\mathbf{H}(x_1,x_2)$ is derived by taking the second partial derivatives of this function. Its elements are:\n$$\nH_{11} = \\frac{\\partial^2 g}{\\partial x_1^2} = \\frac{1}{x_1} + \\frac{1}{x_3} - 2\\chi_{13}\n$$\n$$\nH_{22} = \\frac{\\partial^2 g}{\\partial x_2^2} = \\frac{1}{x_2} + \\frac{1}{x_3} - 2\\chi_{23}\n$$\n$$\nH_{12} = H_{21} = \\frac{\\partial^2 g}{\\partial x_1 \\partial x_2} = \\frac{1}{x_3} + \\chi_{12} - \\chi_{13} - \\chi_{23}\n$$\nwhere $x_3 = 1 - x_1 - x_2$. The system is unstable where $\\mathbf{H}$ is not positive definite, which occurs when its smallest eigenvalue is negative.\n\nThe algorithmic implementation follows these steps:\n1.  **Grid Discretization**: A uniform grid of points $(x_1, x_2)$ is generated over the composition triangle at the specified resolution $N$. Points near the boundaries are excluded to avoid numerical singularities.\n2.  **Stability Analysis**: At each valid grid point, the Hessian matrix $\\mathbf{H}$ is constructed using the derived formulas.\n3.  **Eigenvalue Calculation**: The eigenvalues of the symmetric matrix $\\mathbf{H}$ are computed. A point is classified as unstable if the smallest eigenvalue is less than a small negative tolerance ($\\lambda_{min}  -\\tau$).\n4.  **Result Aggregation**: The fraction of unstable points across the grid is calculated. A separate calculation is performed at the equimolar composition ($x_1=x_2=x_3=1/3$) to determine its stability. The results are collected and formatted as specified.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes spinodal boundaries for a ternary mixture based on the regular solution model.\n    \"\"\"\n    \n    test_cases = [\n        {'chi_params': (0.5, 0.5, 0.5), 'N': 120},  # Case 1\n        {'chi_params': (3.5, 3.5, 3.5), 'N': 120},  # Case 2\n        {'chi_params': (2.8, 0.8, 3.2), 'N': 100},  # Case 3\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        chi_params = case['chi_params']\n        N = case['N']\n        \n        # Calculate properties for the current test case\n        result = calculate_spinodal_properties(chi_params, N)\n        results.append(result)\n\n    # Format the final output string as per requirements\n    # e.g., [[f1,b1],[f2,b2],[f3,b3]] with lowercase booleans\n    formatted_results = []\n    for f_val, b_val in results:\n        # Round the float to 6 decimal places\n        f_val_rounded = round(f_val, 6)\n        # Convert boolean to lowercase string 'true' or 'false'\n        b_val_str = str(b_val).lower()\n        formatted_results.append(f\"[{f_val_rounded},{b_val_str}]\")\n\n    print(f\"[{','.join(formatted_results)}]\")\n\n\ndef calculate_spinodal_properties(chi_params, N):\n    \"\"\"\n    Calculates the fraction of unstable points on a grid and checks stability at the equimolar point.\n\n    Args:\n        chi_params (tuple): A tuple of (chi_12, chi_13, chi_23).\n        N (int): The grid resolution.\n\n    Returns:\n        list: A list containing [unstable_fraction, is_equimolar_unstable].\n    \"\"\"\n    chi12, chi13, chi23 = chi_params\n    delta = 1e-6\n    tau = 1e-10\n\n    unstable_count = 0\n    total_points = 0\n\n    # Discretize the composition triangle and evaluate stability at each point\n    for i in range(N + 1):\n        for j in range(N - i + 1):\n            x1 = i / N\n            x2 = j / N\n            x3 = 1.0 - x1 - x2\n\n            # Exclude points near the boundary as per the cutoff delta\n            if x1  delta or x2  delta or x3  delta:\n                continue\n\n            total_points += 1\n\n            # Compute the Hessian matrix elements\n            H11 = 1/x1 + 1/x3 - 2 * chi13\n            H22 = 1/x2 + 1/x3 - 2 * chi23\n            H12 = 1/x3 + chi12 - chi13 - chi23\n            \n            H = np.array([[H11, H12], [H12, H22]])\n\n            # Compute eigenvalues and check for instability\n            min_eig = np.linalg.eigvalsh(H)[0]\n            if min_eig  -tau:\n                unstable_count += 1\n    \n    fraction_unstable = 0.0\n    if total_points  0:\n        fraction_unstable = unstable_count / total_points\n\n    # Separately evaluate stability at the equimolar composition\n    x_eq = 1.0 / 3.0\n    H11_eq = 1/x_eq + 1/x_eq - 2 * chi13\n    H22_eq = 1/x_eq + 1/x_eq - 2 * chi23\n    H12_eq = 1/x_eq + chi12 - chi13 - chi23\n    \n    H_eq = np.array([[H11_eq, H12_eq], [H12_eq, H22_eq]])\n    \n    min_eig_eq = np.linalg.eigvalsh(H_eq)[0]\n    is_equimolar_unstable = min_eig_eq  -tau\n    \n    return [fraction_unstable, is_equimolar_unstable]\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3474922"}]}