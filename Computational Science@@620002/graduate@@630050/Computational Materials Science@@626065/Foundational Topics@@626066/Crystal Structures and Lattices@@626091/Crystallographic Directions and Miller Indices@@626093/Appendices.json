{"hands_on_practices": [{"introduction": "Before we can analyze specific crystallographic planes, we must first be able to enumerate them efficiently. Due to the inherent symmetry of a crystal lattice, many planes with different Miller indices are physically indistinguishable. This practice guides you through the development of a robust algorithm to identify the unique, symmetrically distinct plane families, preventing redundant calculations and forming the basis for systematic studies of material properties like surface energy [@problem_id:3442333].", "problem": "You are given a direct Bravais lattice in three dimensions specified by a basis matrix $\\mathbf{A} \\in \\mathbb{R}^{3 \\times 3}$ whose columns are the direct lattice basis vectors in a fixed Cartesian coordinate system, and a set of point-group operations given as rotation matrices $\\{\\mathbf{R}_i\\}$ with $\\mathbf{R}_i \\in \\mathrm{SO}(3)$ acting on Cartesian vectors. A plane family in the lattice is specified by a Miller index triplet $\\mathbf{h} = (h,k,l) \\in \\mathbb{Z}^3 \\setminus \\{\\mathbf{0}\\}$ reduced to coprime integers. The corresponding reciprocal lattice basis is defined by the standard reciprocal basis formula from solid-state physics,\n$$\n\\mathbf{B}^{\\ast} = 2\\pi\\,\\mathbf{A}^{-\\mathsf{T}},\n$$\nso that a plane normal in reciprocal space is $\\mathbf{G}(\\mathbf{h}) = \\mathbf{B}^{\\ast}\\,\\mathbf{h}$. Two Miller triplets $\\mathbf{h}$ and $\\mathbf{h}'$ are considered equivalent if there exists a point-group rotation $\\mathbf{R}$ such that their reciprocal normals are related by an undirected equivalence,\n$$\n\\mathbf{G}(\\mathbf{h}') \\propto \\pm\\,\\mathbf{R}\\,\\mathbf{G}(\\mathbf{h}),\n$$\nthat is, the orientations of the normals are the same up to symmetry and overall sign, which reflects that a crystallographic plane does not have an orientation arrow. Equivalently, using $\\mathbf{h}' = \\mathbf{M}(\\mathbf{R})\\,\\mathbf{h}$ with\n$$\n\\mathbf{M}(\\mathbf{R}) \\equiv \\left(\\mathbf{B}^{\\ast}\\right)^{-1}\\,\\mathbf{R}\\,\\mathbf{B}^{\\ast} = \\mathbf{A}^{\\mathsf{T}}\\,\\mathbf{R}\\,\\mathbf{A}^{-\\mathsf{T}},\n$$\ntwo Miller triplets $\\mathbf{h}$ and $\\mathbf{h}'$ are equivalent if $\\mathbf{h}'$ lies in the orbit generated by integer unimodular transformations $\\{\\mathbf{M}(\\mathbf{R}_i)\\}$ and overall sign change. Assume all provided point-group rotations are true symmetries of the lattice, so that each $\\mathbf{M}(\\mathbf{R}_i)$ is an integer unimodular matrix.\n\nYour task is to design and implement an algorithm that enumerates all distinct plane families up to a maximum index norm bound by leveraging the reciprocal lattice representation and point-group symmetry to avoid duplicates. The index norm bound is defined as a Euclidean bound on Miller indices,\n$$\n\\|\\mathbf{h}\\|_2 \\equiv \\sqrt{h^2 + k^2 + l^2} \\le H,\n$$\nfor a given positive integer $H$. Only primitive Miller indices (that is, with $\\gcd(|h|,|k|,|l|)=1$) are to be considered. Two triplets that differ by an overall integer factor represent the same family and must be treated as duplicates.\n\nDefine a canonical representative for each equivalence class as follows. For any candidate integer triplet $\\mathbf{v} = (v_1,v_2,v_3)$, first apply sign normalization: if the first nonzero component of $\\mathbf{v}$ is negative, replace $\\mathbf{v}$ by $-\\mathbf{v}$; otherwise leave $\\mathbf{v}$ unchanged. Among all sign-normalized images obtained by applying every symmetry $\\mathbf{M}(\\mathbf{R}_i)$ to a given primitive $\\mathbf{h}$, select the lexicographically smallest triplet (comparing $v_1$ first, then $v_2$, then $v_3$) as the canonical representative for the equivalence class that contains $\\mathbf{h}$.\n\nYour program must implement the following, starting only from the fundamental definitions above.\n\n- Construct $\\mathbf{B}^{\\ast}$ from $\\mathbf{A}$ and use it to derive $\\mathbf{M}(\\mathbf{R}) = \\mathbf{A}^{\\mathsf{T}}\\,\\mathbf{R}\\,\\mathbf{A}^{-\\mathsf{T}}$.\n- Enumerate all primitive Miller triplets $\\mathbf{h} \\in \\mathbb{Z}^3 \\setminus \\{\\mathbf{0}\\}$ with $\\|\\mathbf{h}\\|_2 \\le H$.\n- For each $\\mathbf{h}$, compute its equivalence orbit under the group generated by $\\{\\mathbf{M}(\\mathbf{R}_i)\\}$ and the undirected sign equivalence, and insert only one canonical representative per equivalence class into the output set.\n- Sort the final set of canonical representatives in lexicographic order.\n\nScientific realism constraints and units: There are no physical units required in the final answer. The angles used to construct rotation matrices must be specified and interpreted in degrees.\n\nTest suite. Your program must execute on the following three test cases and aggregate the outputs.\n\n- Test case $1$ (happy path, high symmetry): Direct lattice $\\mathbf{A} = \\mathrm{diag}(1.0,1.0,1.0)$. Point group is the full proper rotational symmetry group of the cube (the octahedral group), that is, all $3 \\times 3$ orthogonal matrices with integer entries and determinant $+1$; construct this set algorithmically by enumerating all axis permutations and sign choices that yield determinant $+1$. Use index norm bound $H=2$.\n- Test case $2$ (anisotropic but symmetric): Direct lattice $\\mathbf{A} = \\mathrm{diag}(1.0,1.0,1.5)$. Point group is the proper rotational dihedral group about the $z$-axis with fourfold symmetry, generated by a rotation $\\mathbf{R}_z$ by $90^{\\circ}$ about the $z$-axis and a rotation $\\mathbf{R}_x$ by $180^{\\circ}$ about the $x$-axis, both given in degrees. Build the full group by closure under matrix multiplication. Use index norm bound $H=2$.\n- Test case $3$ (edge case, no symmetry): Direct lattice\n$$\n\\mathbf{A} = \\begin{bmatrix}\n1.0 & 0.3 & 0.2\\\\\n0.0 & 1.1 & 0.4\\\\\n0.0 & 0.0 & 0.9\n\\end{bmatrix}.\n$$\nPoint group contains only the identity rotation. Use index norm bound $H=1$.\n\nFinal output format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to one test case in order and is itself a lexicographically sorted list of canonical representatives, each representative being a list $[h,k,l]$ of integers. For example, a valid overall format is\n$[[[h_{11},k_{11},l_{11}],\\dots],[[h_{21},k_{21},l_{21}],\\dots],[[h_{31},k_{31},l_{31}],\\dots]]$\nwith no additional text. All angles mentioned must be interpreted in degrees, and all answers are pure integers; no physical units are required.", "solution": "The user wants to find the canonical representatives of crystallographic plane families for different lattice symmetries and norm bounds.\n\n### Principle-Based Design\n\nThe problem requires enumerating unique families of crystallographic planes, represented by their Miller indices $\\mathbf{h} = (h,k,l)$, under the equivalence defined by the lattice's point-group symmetry. Two Miller indices are equivalent if their corresponding reciprocal lattice vectors are related by a point-group rotation, up to a sign. This physical equivalence translates into a mathematical transformation on the Miller indices themselves.\n\nThe core of the algorithm will be structured around these principles:\n\n1.  **Reciprocal Space and Symmetry Transformation**: A crystallographic plane is defined by a normal vector in reciprocal space. A reciprocal lattice vector $\\mathbf{G}$ corresponding to Miller indices $\\mathbf{h} = (h,k,l)$ is given by $\\mathbf{G}(\\mathbf{h}) = \\mathbf{B}^{\\ast}\\,\\mathbf{h}$, where $\\mathbf{B}^{\\ast}$ is the reciprocal lattice basis. The basis $\\mathbf{B}^{\\ast}$ is related to the direct lattice basis $\\mathbf{A}$ by $\\mathbf{B}^{\\ast} = 2\\pi (\\mathbf{A}^{-1})^{\\mathsf{T}}$. A symmetry operation in real space, represented by a rotation matrix $\\mathbf{R}$, transforms the Miller indices $\\mathbf{h}$ to an equivalent set $\\mathbf{h}'$. The transformation rule for these co-variant indices is $\\mathbf{h}' = \\mathbf{M}(\\mathbf{R})\\,\\mathbf{h}$, where the transformation matrix $\\mathbf{M}(\\mathbf{R})$ is derived as $\\mathbf{M}(\\mathbf{R}) = (\\mathbf{B}^{\\ast})^{-1} \\mathbf{R} \\mathbf{B}^{\\ast}$. Substituting the definition of $\\mathbf{B}^{\\ast}$, and ignoring the scalar factor $2\\pi$ which cancels out, we get $\\mathbf{M}(\\mathbf{R}) = \\mathbf{A}^{\\mathsf{T}} \\mathbf{R} (\\mathbf{A}^{\\mathsf{T}})^{-1}$. This is the formula provided in the problem statement. For any point-group symmetry $\\mathbf{R}$ of the lattice, this matrix $\\mathbf{M}(\\mathbf{R})$ must be an integer matrix with determinant $\\pm 1$ (unimodular), ensuring that it maps integer triplets to integer triplets.\n\n2.  **Equivalence Classes and Orbits**: The set of all Miller indices equivalent to a given $\\mathbf{h}$ forms an equivalence class, or an orbit. This orbit is generated by applying all symmetry transformation matrices $\\{\\mathbf{M}(\\mathbf{R}_i)\\}$ and considering sign changes (as planes are undirected, $(h,k,l)$ and $(-h,-k,-l)$ are equivalent). The task is to find one unique representative for each such orbit.\n\n3.  **Canonical Representative**: A canonical representative is defined to uniquely identify each equivalence class. The problem specifies a two-step procedure:\n    a. **Sign Normalization**: Any triplet $\\mathbf{v}$ is normalized by flipping its sign if its first non-zero component is negative. This ensures that equivalent pairs $\\{\\mathbf{v}, -\\mathbf{v}\\}$ map to a single normalized form.\n    b. **Lexicographical Minimum**: For a given primitive Miller index triplet $\\mathbf{h}$, we generate its full orbit. We then sign-normalize every triplet in the orbit. The canonical representative for the family of $\\mathbf{h}$ is the lexicographically smallest triplet among all these normalized forms.\n\n4.  **Enumeration Algorithm**: The overall algorithm is an enumeration followed by a reduction to canonical forms.\n    a. **Generate Candidates**: Systematically generate all primitive integer triplets $\\mathbf{h}=(h,k,l)$ within the specified Euclidean norm bound, $\\|\\mathbf{h}\\|_2 \\le H$. A triplet is primitive if $\\gcd(|h|,|k|,|l|) = 1$.\n    b. **Identify Unique Families**: For each primitive candidate $\\mathbf{h}$, we compute its canonical representative. To avoid redundant computations, we maintain a set of already processed triplets. If a candidate $\\mathbf{h}$ has not been processed, we compute its full orbit, find its canonical representative, add this representative to our final result set, and mark all triplets in the orbit as processed.\n    c. **Final Output**: The collected set of unique canonical representatives is converted to a list and sorted lexicographically to produce the final result.\n\n### Implementation Steps\n\nThe implementation will address each test case by following these steps:\n\n1.  **Group Generation**: For each test case, the corresponding set of point-group rotation matrices $\\{\\mathbf{R}_i\\}$ is generated.\n    -   *Case 1 (Cubic)*: The octahedral group $O$ consists of all $24$ signed permutation matrices with determinant $+1$. These are generated algorithmically.\n    -   *Case 2 (Tetragonal)*: The dihedral group $D_4$ is generated by taking the closure of the given generators ($R_z(90^\\circ)$ and $R_x(180^\\circ)$) under matrix multiplication.\n    -   *Case 3 (Triclinic)*: The group is trivial, containing only the identity matrix.\n\n2.  **Symmetry Matrix Calculation**: For each rotation $\\mathbf{R}_i$, the corresponding Miller index transformation matrix $\\mathbf{M}(\\mathbf{R}_i) = \\mathbf{A}^{\\mathsf{T}}\\mathbf{R}_i(\\mathbf{A}^{-1})^{\\mathsf{T}}$ is computed. Since the computation involves floating-point arithmetic but the result must be an integer matrix, the elements of the computed $\\mathbf{M}$ are rounded to the nearest integer.\n\n3.  **Enumeration and Reduction**: The main loop iterates through integers $h, k, l$ from $-H$ to $H$.\n    -   It filters out triplets that are outside the norm bound, the zero vector, non-primitive triplets, and any triplet that has already been accounted for.\n    -   For a new primitive triplet, it computes the full orbit $\\{\\pm \\mathbf{M}(\\mathbf{R}_i)\\mathbf{h}\\}$, determines the canonical representative by finding the lexicographical minimum of the sign-normalized orbit members, and adds it to the results. All members of the orbit are then marked as processed.\n\n4.  **Sorting and Formatting**: The final set of canonical representatives is sorted and formatted into the specified string representation.\n\nThis systematic approach guarantees that every possible plane family up to the norm limit is considered exactly once, and the representative for each family is chosen according to the precise rules given in the problem.", "answer": "```python\nimport numpy as np\nimport math\nimport itertools\n\ndef gcd_three(a: int, b: int, c: int) -> int:\n    \"\"\"Computes the greatest common divisor of three integers.\"\"\"\n    return math.gcd(math.gcd(abs(a), abs(b)), abs(c))\n\ndef generate_cubic_group() -> list[np.ndarray]:\n    \"\"\"\n    Generates the 24 rotation matrices of the proper cubic point group (Octahedral group O).\n    These are the 3x3 signed permutation matrices with determinant +1.\n    \"\"\"\n    matrices = []\n    identity = np.identity(3, dtype=int)\n    for p in itertools.permutations([0, 1, 2]):\n        for s in itertools.product([1, -1], repeat=3):\n            R = np.zeros((3, 3), dtype=int)\n            R[:, 0] = s[0] * identity[:, p[0]]\n            R[:, 1] = s[1] * identity[:, p[1]]\n            R[:, 2] = s[2] * identity[:, p[2]]\n            if int(round(np.linalg.det(R))) == 1:\n                matrices.append(R)\n    return matrices\n\ndef generate_d4_group() -> list[np.ndarray]:\n    \"\"\"\n    Generates the 8 rotation matrices of the D4 point group by closure.\n    Generators are a 90-degree rotation about z and a 180-degree rotation about x.\n    \"\"\"\n    theta_z = np.deg2rad(90)\n    Rz = np.array([\n        [np.cos(theta_z), -np.sin(theta_z), 0],\n        [np.sin(theta_z), np.cos(theta_z), 0],\n        [0, 0, 1]\n    ])\n    theta_x = np.deg2rad(180)\n    Rx = np.array([\n        [1, 0, 0],\n        [0, np.cos(theta_x), -np.sin(theta_x)],\n        [0, np.sin(theta_x), np.cos(theta_x)]\n    ])\n\n    Rz_int = np.round(Rz).astype(int)\n    Rx_int = np.round(Rx).astype(int)\n    \n    group_tuples = {tuple(map(tuple, np.identity(3, dtype=int)))}\n    generators = [Rz_int, Rx_int]\n    \n    while True:\n        current_size = len(group_tuples)\n        new_ops = set()\n        for op1_tup in group_tuples:\n            op1 = np.array(op1_tup)\n            for gen in generators:\n                new_op = np.dot(op1, gen)\n                new_ops.add(tuple(map(tuple, new_op)))\n        group_tuples.update(new_ops)\n        if len(group_tuples) == current_size:\n            break\n\n    return [np.array(m) for m in group_tuples]\n\ndef find_canonical_representatives(A: np.ndarray, R_matrices: list[np.ndarray], H: int) -> list[list[int]]:\n    \"\"\"\n    Enumerates canonical representatives for Miller indices up to norm H for a given\n    lattice A and point group rotations R_matrices.\n    \"\"\"\n    try:\n        A_inv_T = np.linalg.inv(A).T\n    except np.linalg.LinAlgError:\n        return []\n\n    M_matrices = [np.round(A.T @ R @ A_inv_T).astype(int) for R in R_matrices]\n\n    canonical_reps = set()\n    processed_hkls = set()\n    \n    H_sq = H**2\n    for h in range(-H, H + 1):\n        for k in range(-H, H + 1):\n            for l in range(-H, H + 1):\n                if h**2 + k**2 + l**2 > H_sq:\n                    continue\n                \n                hkl_tuple = (h, k, l)\n\n                if hkl_tuple in processed_hkls or hkl_tuple == (0, 0, 0):\n                    continue\n\n                if gcd_three(h, k, l) != 1:\n                    continue\n                \n                hkl_vec = np.array(hkl_tuple)\n                \n                orbit = set()\n                for M in M_matrices:\n                    orbit.add(tuple(M @ hkl_vec))\n                \n                full_orbit_signed = set()\n                for v in orbit:\n                    full_orbit_signed.add(v)\n                    full_orbit_signed.add(tuple(-x for x in v))\n                \n                orbit_normalized = set()\n                for v_tuple in full_orbit_signed:\n                    v_list = list(v_tuple)\n                    \n                    first_nonzero_idx = -1\n                    for i in range(3):\n                        if v_list[i] != 0:\n                            first_nonzero_idx = i\n                            break\n                    \n                    if first_nonzero_idx != -1 and v_list[first_nonzero_idx] < 0:\n                        v_tuple_norm = tuple(-x for x in v_list)\n                    else:\n                        v_tuple_norm = v_tuple\n                    orbit_normalized.add(v_tuple_norm)\n                \n                canonical_rep = min(orbit_normalized)\n                canonical_reps.add(canonical_rep)\n                \n                processed_hkls.update(full_orbit_signed)\n\n    return sorted([list(rep) for rep in canonical_reps])\n\ndef solve():\n    \"\"\"\n    Executes the three test cases and prints the results in the specified format.\n    \"\"\"\n    test_cases = [\n        {\n            \"A\": np.identity(3),\n            \"R_matrices\": generate_cubic_group(),\n            \"H\": 2\n        },\n        {\n            \"A\": np.diag([1.0, 1.0, 1.5]),\n            \"R_matrices\": generate_d4_group(),\n            \"H\": 2\n        },\n        {\n            \"A\": np.array([[1.0, 0.3, 0.2], [0.0, 1.1, 0.4], [0.0, 0.0, 0.9]]),\n            \"R_matrices\": [np.identity(3, dtype=int)],\n            \"H\": 1\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        reps = find_canonical_representatives(case[\"A\"], case[\"R_matrices\"], case[\"H\"])\n        results.append(reps)\n\n    # Format output string without using external libraries like json\n    result_str = str(results).replace(\" \", \"\")\n    print(result_str)\n\nsolve()\n```", "id": "3442333"}, {"introduction": "From the abstract world of symmetry, we now turn to the practical task of interpreting experimental data. When analyzing diffraction patterns, each peak is assigned a Miller index, but is this assignment physically sound? This hands-on exercise challenges you to implement a critical consistency check, validating proposed indices against two independent and fundamental constraints: the geometric spacing derived from the lattice metric and the systematic extinctions imposed by lattice centering [@problem_id:3442267].", "problem": "You are tasked with implementing a consistency check for indexing diffraction peaks in a crystalline material. The check must simultaneously enforce two independent constraints grounded in first principles: (i) the structure factor extinction rules implied by lattice centering, and (ii) the metric-derived spacings from the crystal lattice geometry. Your program must verify, for each provided test case, whether all assigned peaks satisfy both constraints within a specified absolute tolerance.\n\nFundamental base and definitions:\n- A Bravais lattice is characterized by its direct lattice parameters $a$, $b$, $c$ (in $\\mathrm{\\AA}$) and interaxial angles $\\alpha$, $\\beta$, $\\gamma$ (in degrees).\n- The direct lattice metric tensor $G$ is defined by $G_{ij} = \\mathbf{a}_i \\cdot \\mathbf{a}_j$ for the basis vectors $\\mathbf{a}_1$, $\\mathbf{a}_2$, $\\mathbf{a}_3$, and for a general triclinic lattice can be written as\n$$\nG = \\begin{bmatrix}\na^2 & ab\\cos\\gamma & ac\\cos\\beta \\\\\nab\\cos\\gamma & b^2 & bc\\cos\\alpha \\\\\nac\\cos\\beta & bc\\cos\\alpha & c^2\n\\end{bmatrix}.\n$$\n- The reciprocal lattice metric tensor $G^\\star$ satisfies $G^\\star = G^{-1}$.\n- For a Miller index $\\mathbf{H} = (h,k,l)$, the spacing $d$ of the lattice planes is related to the reciprocal metric via\n$$\n\\frac{1}{d^2} = \\mathbf{H}^\\mathsf{T} \\, G^\\star \\, \\mathbf{H}.\n$$\n- Lattice centering imposes systematic extinction conditions on reflections via the structure factor. For the following Bravais lattice centerings, the necessary conditions for a reflection $(h,k,l)$ to be allowed (non-zero structure factor) are:\n  1. Primitive (P): all $(h,k,l) \\neq (0,0,0)$ are allowed.\n  2. Body-centered (I): $h + k + l$ must be even.\n  3. Face-centered (F): $h$, $k$, and $l$ must be all even or all odd.\n  4. Base-centered (C): $h + k$ must be even.\nThese rules arise from summing phase factors $\\exp\\!\\left(2\\pi i\\, \\mathbf{H}\\cdot\\mathbf{t}\\right)$ over centering translations $\\mathbf{t}$ and require the integer parity constraints indicated.\n\nConsistency check specification:\n- Given a set of assigned peaks, each defined by a measured spacing $d_{\\text{meas}}$ (in $\\mathrm{\\AA}$) and a Miller index triplet $(h,k,l)$, the assignment is consistent if and only if for every peak:\n  1. The extinction rule for the given centering is satisfied by $(h,k,l)$, and $(h,k,l)\\neq (0,0,0)$.\n  2. The metric-derived spacing $d_{\\text{pred}}$ computed from $G^\\star$ satisfies $\\left| d_{\\text{pred}} - d_{\\text{meas}} \\right| \\le \\Delta$, where $\\Delta$ is the provided absolute tolerance (in $\\mathrm{\\AA}$).\nIf any peak fails either condition, the entire test case is marked inconsistent.\n\nAngle unit requirement: all angles $\\alpha$, $\\beta$, $\\gamma$ are provided in degrees and must be handled as degrees.\n\nPhysical unit requirement: all lengths $a$, $b$, $c$, and spacings $d_{\\text{meas}}$ must be handled in $\\mathrm{\\AA}$.\n\nYour program must implement the above logic and evaluate the following test suite. Each test case is provided as a tuple of lattice parameters, centering type, tolerance, and the list of peaks. For each test case, output a boolean indicating whether all assigned peaks are simultaneously consistent with extinction rules and metric-derived spacings within tolerance.\n\nTest suite:\n1. Face-Centered Cubic (FCC) cubic lattice: $a = 3.6\\,\\mathrm{\\AA}$, $b = 3.6\\,\\mathrm{\\AA}$, $c = 3.6\\,\\mathrm{\\AA}$, $\\alpha = 90^\\circ$, $\\beta = 90^\\circ$, $\\gamma = 90^\\circ$, centering type \"F\", tolerance $\\Delta = 0.001\\,\\mathrm{\\AA}$. Peaks:\n   - $d_{\\text{meas}} = 2.07846\\,\\mathrm{\\AA}$ with $(h,k,l) = (1,1,1)$,\n   - $d_{\\text{meas}} = 1.7998\\,\\mathrm{\\AA}$ with $(h,k,l) = (2,0,0)$,\n   - $d_{\\text{meas}} = 1.2728\\,\\mathrm{\\AA}$ with $(h,k,l) = (2,2,0)$.\n2. Body-Centered Cubic (BCC) cubic lattice: $a = 3.0\\,\\mathrm{\\AA}$, $b = 3.0\\,\\mathrm{\\AA}$, $c = 3.0\\,\\mathrm{\\AA}$, $\\alpha = 90^\\circ$, $\\beta = 90^\\circ$, $\\gamma = 90^\\circ$, centering type \"I\", tolerance $\\Delta = 0.002\\,\\mathrm{\\AA}$. Peaks:\n   - $d_{\\text{meas}} = 3.0\\,\\mathrm{\\AA}$ with $(h,k,l) = (1,0,0)$,\n   - $d_{\\text{meas}} = 2.1213\\,\\mathrm{\\AA}$ with $(h,k,l) = (1,1,0)$.\n3. Primitive triclinic lattice: $a = 4.2\\,\\mathrm{\\AA}$, $b = 5.1\\,\\mathrm{\\AA}$, $c = 6.0\\,\\mathrm{\\AA}$, $\\alpha = 94^\\circ$, $\\beta = 102^\\circ$, $\\gamma = 88^\\circ$, centering type \"P\", tolerance $\\Delta = 0.001\\,\\mathrm{\\AA}$. Peaks:\n   - $d_{\\text{meas}} = 2.40\\,\\mathrm{\\AA}$ with $(h,k,l) = (1,0,1)$,\n   - $d_{\\text{meas}} = 2.85\\,\\mathrm{\\AA}$ with $(h,k,l) = (0,1,1)$.\n4. Base-Centered Orthorhombic (C-centered) lattice: $a = 4.0\\,\\mathrm{\\AA}$, $b = 6.0\\,\\mathrm{\\AA}$, $c = 5.0\\,\\mathrm{\\AA}$, $\\alpha = 90^\\circ$, $\\beta = 90^\\circ$, $\\gamma = 90^\\circ$, centering type \"C\", tolerance $\\Delta = 0.002\\,\\mathrm{\\AA}$. Peaks:\n   - $d_{\\text{meas}} = 2.000\\,\\mathrm{\\AA}$ with $(h,k,l) = (2,0,0)$,\n   - $d_{\\text{meas}} = 3.324\\,\\mathrm{\\AA}$ with $(h,k,l) = (1,1,0)$,\n   - $d_{\\text{meas}} = 3.121\\,\\mathrm{\\AA}$ with $(h,k,l) = (1,0,1)$.\n5. Primitive tetragonal lattice: $a = 3.9\\,\\mathrm{\\AA}$, $b = 3.9\\,\\mathrm{\\AA}$, $c = 5.2\\,\\mathrm{\\AA}$, $\\alpha = 90^\\circ$, $\\beta = 90^\\circ$, $\\gamma = 90^\\circ$, centering type \"P\", tolerance $\\Delta = 0.0006\\,\\mathrm{\\AA}$. Peaks:\n   - $d_{\\text{meas}} = 1.8916\\,\\mathrm{\\AA}$ with $(h,k,l) = (1,1,2)$.\n6. Primitive cubic lattice with an invalid index: $a = 4.0\\,\\mathrm{\\AA}$, $b = 4.0\\,\\mathrm{\\AA}$, $c = 4.0\\,\\mathrm{\\AA}$, $\\alpha = 90^\\circ$, $\\beta = 90^\\circ$, $\\gamma = 90^\\circ$, centering type \"P\", tolerance $\\Delta = 0.01\\,\\mathrm{\\AA}$. Peaks:\n   - $d_{\\text{meas}} = 1.000\\,\\mathrm{\\AA}$ with $(h,k,l) = (0,0,0)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[r_1,r_2,\\dots,r_6]$ where each $r_i$ is a boolean). No other text should be printed.", "solution": "The problem requires the validation of assigned diffraction peaks against a set of crystallographic parameters. For each given test case, which includes lattice parameters, a Bravais centering type, a tolerance, and a list of measured peaks, we must determine if all peaks are simultaneously consistent with two fundamental constraints: geometric (metric) constraints and structure factor extinction rules. A test case is deemed consistent if and only if every assigned peak satisfies both constraints.\n\nThe validation process for each test case proceeds as follows. A test case is defined by the direct lattice parameters $a$, $b$, $c$, the interaxial angles $\\alpha$, $\\beta$, $\\gamma$, the centering type (P, I, F, or C), an absolute tolerance $\\Delta$, and a list of peaks. Each peak is specified by its measured interplanar spacing $d_{\\text{meas}}$ and its assigned Miller index $\\mathbf{H} = (h,k,l)$.\n\nFirst, we address the metric constraint. The geometry of the crystal lattice is fully described by the direct lattice metric tensor, $G$. For a general triclinic system, $G$ is a $3 \\times 3$ symmetric matrix whose elements are $G_{ij} = \\mathbf{a}_i \\cdot \\mathbf{a}_j$, where $\\mathbf{a}_i$ are the direct lattice basis vectors. In terms of the given lattice parameters, $G$ is constructed as:\n$$\nG = \\begin{bmatrix}\na^2 & ab\\cos\\gamma & ac\\cos\\beta \\\\\nab\\cos\\gamma & b^2 & bc\\cos\\alpha \\\\\nac\\cos\\beta & bc\\cos\\alpha & c^2\n\\end{bmatrix}\n$$\nThe calculation of the trigonometric functions $\\cos\\alpha$, $\\cos\\beta$, and $\\cos\\gamma$ requires converting the input angles from degrees to radians, as standard mathematical libraries operate in radians.\n\nThe interplanar spacing $d$ for a set of planes with Miller index $\\mathbf{H}=(h,k,l)$ is most conveniently calculated in reciprocal space. The reciprocal lattice metric tensor, $G^\\star$, is the inverse of the direct lattice metric tensor, i.e., $G^\\star = G^{-1}$. The squared reciprocal-space distance to the point $(h,k,l)$ is given by the quadratic form $Q = \\mathbf{H}^\\mathsf{T} G^\\star \\mathbf{H}$. This quantity is equal to the reciprocal of the squared interplanar spacing:\n$$\n\\frac{1}{d^2} = Q = \\mathbf{H}^\\mathsf{T} G^\\star \\mathbf{H}\n$$\nFrom this, we can compute the predicted interplanar spacing, $d_{\\text{pred}}$, for any given Miller index $\\mathbf{H}$:\n$$\nd_{\\text{pred}} = \\frac{1}{\\sqrt{\\mathbf{H}^\\mathsf{T} G^\\star \\mathbf{H}}}\n$$\nThe metric consistency for a single peak is then checked by comparing $d_{\\text{pred}}$ to the experimentally measured value $d_{\\text{meas}}$. The peak is considered metrically consistent if the absolute difference is within the specified tolerance $\\Delta$:\n$$\n|d_{\\text{pred}} - d_{\\text{meas}}| \\le \\Delta\n$$\n\nSecond, we address the structure factor extinction rules. These rules dictate which reflections $(h,k,l)$ are systematically absent (i.e., have zero intensity) due to destructive interference caused by the centering vectors in the unit cell. A reflection is considered \"allowed\" if it does not violate these rules. The rules for the specified Bravais centering types are:\n-   **Primitive (P)**: All Miller indices $(h,k,l) \\neq (0,0,0)$ are allowed.\n-   **Body-centered (I)**: The sum of the indices $h+k+l$ must be an even number.\n-   **Face-centered (F)**: The indices $h$, $k$, and $l$ must be either all even or all odd (i.e., of the same parity).\n-   **Base-centered (C)**: The sum of the first two indices $h+k$ must be an even number.\n\nThe overall validation algorithm for a single test case involves iterating through each of its assigned peaks. For each peak $(d_{\\text{meas}}, \\mathbf{H}=(h,k,l))$:\n1.  Verify that the Miller index is non-trivial, i.e., $\\mathbf{H} \\neq (0,0,0)$. The $(0,0,0)$ index corresponds to the transmitted beam, not a diffraction peak, and is thus invalid.\n2.  Check if the index $\\mathbf{H}$ satisfies the extinction rule for the given centering type.\n3.  Calculate $d_{\\text{pred}}$ using the metric tensor method described above and verify that $|d_{\\text{pred}} - d_{\\text{meas}}| \\le \\Delta$.\n\nIf any peak in the list fails any of these three checks, the entire test case is immediately declared inconsistent. If all peaks in the list pass all checks, the test case is declared consistent. This procedure is applied to each of the test cases provided in the suite to generate the final sequence of boolean results.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef is_consistent(case_data):\n    \"\"\"\n    Validates a set of diffraction peaks against crystallographic constraints.\n    \n    Args:\n        case_data (tuple): A tuple containing lattice parameters, centering, \n                           tolerance, and a list of peaks.\n    \n    Returns:\n        bool: True if all peaks are consistent, False otherwise.\n    \"\"\"\n    a, b, c, alpha_deg, beta_deg, gamma_deg, centering, tolerance, peaks = case_data\n\n    # Convert angles from degrees to radians for trigonometric functions\n    alpha, beta, gamma = np.deg2rad([alpha_deg, beta_deg, gamma_deg])\n\n    # Calculate cosines of the angles\n    cos_a, cos_b, cos_g = np.cos(alpha), np.cos(beta), np.cos(gamma)\n\n    # Construct the direct lattice metric tensor G\n    G = np.array([\n        [a**2, a*b*cos_g, a*c*cos_b],\n        [a*b*cos_g, b**2, b*c*cos_a],\n        [a*c*cos_b, b*c*cos_a, c**2]\n    ])\n\n    # Calculate the reciprocal lattice metric tensor G* by inverting G\n    # A singular matrix would indicate linearly dependent lattice vectors,\n    # which is physically unrealistic for a 3D lattice.\n    try:\n        G_star = np.linalg.inv(G)\n    except np.linalg.LinAlgError:\n        # This case is unlikely with valid lattice parameters but is a robust check.\n        return False\n\n    for peak in peaks:\n        d_meas, hkl = peak\n        h, k, l = hkl\n        H = np.array(hkl, dtype=np.float64)\n\n        # 1. Check for non-zero Miller index\n        if h == 0 and k == 0 and l == 0:\n            return False\n\n        # 2. Check extinction rules based on centering type\n        is_allowed = False\n        if centering == 'P':\n            is_allowed = True\n        elif centering == 'I': # Body-centered\n            if (h + k + l) % 2 == 0:\n                is_allowed = True\n        elif centering == 'F': # Face-centered\n            # Parities must be all even or all odd\n            parities = [h % 2, k % 2, l % 2]\n            if sum(parities) == 0 or sum(parities) == 3:\n                is_allowed = True\n        elif centering == 'C': # Base-centered\n            if (h + k) % 2 == 0:\n                is_allowed = True\n        \n        if not is_allowed:\n            return False\n\n        # 3. Check metric-derived spacing against measured spacing\n        # Calculate 1/d^2 = H^T * G* * H\n        inv_d_sq = H.T @ G_star @ H\n        \n        # Avoid division by zero if H is (0,0,0), though already checked.\n        if inv_d_sq <= 0:\n             return False # Physically impossible spacing\n\n        d_pred = 1.0 / np.sqrt(inv_d_sq)\n\n        if abs(d_pred - d_meas) > tolerance:\n            return False\n            \n    # If all peaks pass all checks, the case is consistent\n    return True\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        (3.6, 3.6, 3.6, 90.0, 90.0, 90.0, \"F\", 0.001, [\n            (2.07846, (1, 1, 1)), (1.7998, (2, 0, 0)), (1.2728, (2, 2, 0))]),\n        (3.0, 3.0, 3.0, 90.0, 90.0, 90.0, \"I\", 0.002, [\n            (3.0, (1, 0, 0)), (2.1213, (1, 1, 0))]),\n        (4.2, 5.1, 6.0, 94.0, 102.0, 88.0, \"P\", 0.001, [\n            (2.40, (1, 0, 1)), (2.85, (0, 1, 1))]),\n        (4.0, 6.0, 5.0, 90.0, 90.0, 90.0, \"C\", 0.002, [\n            (2.000, (2, 0, 0)), (3.324, (1, 1, 0)), (3.121, (1, 0, 1))]),\n        (3.9, 3.9, 5.2, 90.0, 90.0, 90.0, \"P\", 0.0006, [\n            (1.8916, (1, 1, 2))]),\n        (4.0, 4.0, 4.0, 90.0, 90.0, 90.0, \"P\", 0.01, [\n            (1.000, (0, 0, 0))])\n    ]\n\n    results = []\n    for case in test_cases:\n        result = is_consistent(case)\n        results.append(result)\n\n    # Format output as a comma-separated list of booleans in brackets.\n    # The str() of a boolean is 'True' or 'False' (with capital T/F), which\n    # is a valid representation. JSON standard uses lowercase. The problem\n    # does not specify case, so default Python str() is acceptable.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3442267"}, {"introduction": "Having learned to generate unique planes and verify experimental assignments, we now tackle the ultimate challenge: discovery. In real experiments, data is imperfect and contains noise and outliers, making the identification of crystallographic planes an inverse problem. This final practice requires you to build a sophisticated inference engine, using robust statistical methods to deduce the correct Miller indices from a set of noisy plane normal measurements, a task at the heart of automated crystallographic analysis [@problem_id:3442251].", "problem": "You are given a finite set of measured unit normal directions in three-dimensional Cartesian coordinates and a reciprocal lattice basis that defines the crystallographic relationship between Miller indices and plane normals. The fundamental base consists of the definitions of reciprocal lattice vectors and Miller indices, and the geometric relationship that the plane with Miller indices $(hkl)$ has a normal direction parallel to the reciprocal lattice vector $\\mathbf{G} = h \\mathbf{b}_1 + k \\mathbf{b}_2 + l \\mathbf{b}_3$, where $\\mathbf{b}_1$, $\\mathbf{b}_2$, and $\\mathbf{b}_3$ are the reciprocal lattice basis vectors satisfying $\\mathbf{b}_i \\cdot \\mathbf{a}_j = 2\\pi \\delta_{ij}$ with $\\mathbf{a}_j$ the direct lattice basis. The observable plane normal direction in Cartesian coordinates is collinear with $\\mathbf{G}$, and its orientation is invariant under the sign flip $\\mathbf{G} \\mapsto -\\mathbf{G}$.\n\nYour task is to write a complete, runnable program that infers the coprime integer Miller indices $(h,k,l) \\in \\mathbb{Z}^3$ of a crystallographic plane from measured unit normal directions $\\{\\hat{\\mathbf{n}}_i\\}_{i=1}^N$, robustly handling outliers. The inference must be based on minimizing a robust aggregate of angular deviations between the measured directions and the direction of the candidate reciprocal vector $\\hat{\\mathbf{G}} = \\mathbf{G}/\\|\\mathbf{G}\\|$. The angular deviation for each measurement is defined by the angle in radians\n$$\n\\varphi_i = \\arccos\\big(|\\hat{\\mathbf{n}}_i \\cdot \\hat{\\mathbf{G}}|\\big),\n$$\nwhich enforces invariance with respect to the sign of $\\hat{\\mathbf{G}}$. Robustness must be achieved by aggregating the deviations using the Huber loss function with parameter $\\delta > 0$,\n$$\n\\rho_\\delta(\\varphi) = \\begin{cases}\n\\frac{1}{2}\\varphi^2, & |\\varphi| \\le \\delta,\\\\\n\\delta\\left(|\\varphi| - \\frac{1}{2}\\delta\\right), & |\\varphi| > \\delta,\n\\end{cases}\n$$\noptionally after trimming the largest fraction $\\tau \\in [0,1)$ of $\\{\\varphi_i\\}$ to reject outliers. The objective to be minimized is the trimmed sum of Huber losses over the remaining angles.\n\nThe integral constraints are:\n- $(h,k,l) \\in \\mathbb{Z}^3$,\n- $(h,k,l) \\neq (0,0,0)$,\n- $\\gcd(|h|,|k|,|l|) = 1$ (coprime integer constraint),\n- $|h|,|k|,|l| \\le H_{\\max}$ for a given bound $H_{\\max} \\in \\mathbb{N}$.\n\nSince general-purpose mixed-integer solvers are not to be used, the program must perform an exact enumeration of candidates within the bound $H_{\\max}$ and select the minimizer of the robust objective. In case of ties in the objective value, apply deterministic tie-breaking in the following order: \n- prefer the candidate with smaller $\\|\\mathbf{G}\\|$, \n- then prefer the candidate whose first nonzero index is positive (canonical sign convention), \n- then prefer the lexicographically smaller tuple of absolute values $(|h|,|k|,|l|)$, \n- and finally prefer the lexicographically smaller signed tuple $(h,k,l)$ under the canonical sign convention.\n\nAll angles must be computed in radians. The final answers for each test case must be expressed as integer triples $[h,k,l]$.\n\nImplement the program to solve the following test suite, using the specified parameters and data exactly as provided. For each case, the reciprocal basis matrix $\\mathbf{B} \\in \\mathbb{R}^{3 \\times 3}$ is given by its columns $\\mathbf{b}_1,\\mathbf{b}_2,\\mathbf{b}_3$, and the measured unit normals are listed explicitly. The units of $\\mathbf{B}$ are inverse length, but only directions are used in the objective.\n\n- Test Case $1$ (simple cubic, target near $(1,1,0)$):\n  - $\\mathbf{B} = \\begin{bmatrix} 1 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{bmatrix}$.\n  - Measured normals $\\{\\hat{\\mathbf{n}}_i\\}$:\n    - $\\hat{\\mathbf{n}}_1 = (0.71, 0.70, 0.00)$,\n    - $\\hat{\\mathbf{n}}_2 = (0.69, 0.72, 0.02)$,\n    - $\\hat{\\mathbf{n}}_3 = (0.73, 0.68, -0.01)$,\n    - $\\hat{\\mathbf{n}}_4 = (-0.71, -0.70, 0.00)$,\n    - $\\hat{\\mathbf{n}}_5 = (0.00, 0.00, 1.00)$,\n    - $\\hat{\\mathbf{n}}_6 = (0.70, 0.71, 0.00)$.\n  - Robust parameters: $\\delta = 0.10$, $\\tau = 0.17$, $H_{\\max} = 3$.\n\n- Test Case $2$ (simple cubic, target near $(1,1,1)$):\n  - $\\mathbf{B} = \\begin{bmatrix} 1 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{bmatrix}$.\n  - Measured normals $\\{\\hat{\\mathbf{n}}_i\\}$:\n    - $\\hat{\\mathbf{n}}_1 = (0.58, 0.58, 0.58)$,\n    - $\\hat{\\mathbf{n}}_2 = (0.60, 0.61, 0.51)$,\n    - $\\hat{\\mathbf{n}}_3 = (0.55, 0.56, 0.65)$,\n    - $\\hat{\\mathbf{n}}_4 = (-0.58, -0.58, -0.58)$,\n    - $\\hat{\\mathbf{n}}_5 = (1.00, 0.00, 0.00)$.\n  - Robust parameters: $\\delta = 0.10$, $\\tau = 0.20$, $H_{\\max} = 3$.\n\n- Test Case $3$ (orthorhombic reciprocal basis, target near $(2,1,1)$):\n  - $\\mathbf{B} = \\begin{bmatrix} \\frac{1}{3} & 0 & 0 \\\\ 0 & \\frac{1}{4} & 0 \\\\ 0 & 0 & \\frac{1}{5} \\end{bmatrix}$ (columns are $\\left(\\frac{1}{3},0,0\\right)$, $\\left(0,\\frac{1}{4},0\\right)$, $\\left(0,0,\\frac{1}{5}\\right)$).\n  - Measured normals $\\{\\hat{\\mathbf{n}}_i\\}$:\n    - $\\hat{\\mathbf{n}}_1 = (0.90, 0.34, 0.27)$,\n    - $\\hat{\\mathbf{n}}_2 = (0.89, 0.35, 0.29)$,\n    - $\\hat{\\mathbf{n}}_3 = (0.92, 0.33, 0.26)$,\n    - $\\hat{\\mathbf{n}}_4 = (-0.90, -0.34, -0.27)$,\n    - $\\hat{\\mathbf{n}}_5 = (0.00, 1.00, 0.00)$.\n  - Robust parameters: $\\delta = 0.10$, $\\tau = 0.20$, $H_{\\max} = 4$.\n\n- Test Case $4$ (boundary with zeros in indices, target near $(0,0,1)$):\n  - $\\mathbf{B} = \\begin{bmatrix} 1 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{bmatrix}$.\n  - Measured normals $\\{\\hat{\\mathbf{n}}_i\\}$:\n    - $\\hat{\\mathbf{n}}_1 = (0.00, 0.01, 0.9999)$,\n    - $\\hat{\\mathbf{n}}_2 = (-0.01, 0.00, 0.9998)$,\n    - $\\hat{\\mathbf{n}}_3 = (0.02, -0.01, 0.9997)$,\n    - $\\hat{\\mathbf{n}}_4 = (1.00, 0.00, 0.00)$,\n    - $\\hat{\\mathbf{n}}_5 = (0.00, 1.00, 0.00)$.\n  - Robust parameters: $\\delta = 0.10$, $\\tau = 0.40$, $H_{\\max} = 2$.\n\nYour program must implement the exact enumeration of candidates, the robust objective calculation in radians, trimming by $\\tau$, and the specified tie-breaking. The final output must be a single line containing a comma-separated list of the inferred index triples for the four test cases, enclosed in square brackets, for example $[\\,[h_1,k_1,l_1],\\,[h_2,k_2,l_2],\\,[h_3,k_3,l_3],\\,[h_4,k_4,l_4]\\,]$. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets in the exact format:\n$$\n[[h_1,k_1,l_1],[h_2,k_2,l_2],[h_3,k_3,l_3],[h_4,k_4,l_4]].\n$$", "solution": "The task is to identify the most likely Miller indices $(h,k,l)$ for a set of measured plane normals by performing a constrained optimization over a discrete search space. The methodology involves three main components: candidate generation, objective function evaluation, and a systematic search with deterministic tie-breaking.\n\n**1. Candidate Generation and Constraints**\n\nThe solution space consists of integer triples $(h,k,l)$. An exhaustive search is performed for all candidates satisfying $|h| \\le H_{\\max}$, $|k| \\le H_{\\max}$, and $|l| \\le H_{\\max}$. Each generated candidate $(h,k,l)$ is validated against two primary crystallographic constraints:\n*   **Non-triviality**: The indices must not be the zero vector, i.e., $(h,k,l) \\neq (0,0,0)$.\n*   **Coprimality**: The indices must be coprime, i.e., $\\gcd(|h|,|k|,|l|) = 1$. This ensures that the indices represent a unique plane family and are in their lowest integer form. The greatest common divisor is computed as $\\gcd(\\text{abs}(h), \\gcd(\\text{abs}(k), \\text{abs}(l)))$.\n\n**2. Objective Function Evaluation**\n\nFor each valid candidate $(h,k,l)$, a robust objective value is computed to quantify its agreement with the measured data $\\{\\hat{\\mathbf{n}}_i\\}_{i=1}^N$. This process involves several steps:\n*   **Reciprocal Vector Calculation**: The corresponding reciprocal lattice vector $\\mathbf{G}$ is calculated using the provided reciprocal basis matrix $\\mathbf{B} = [\\mathbf{b}_1 | \\mathbf{b}_2 | \\mathbf{b}_3]$. Letting $\\mathbf{m} = [h,k,l]^T$, the vector is found via matrix-vector multiplication: $\\mathbf{G} = \\mathbf{B} \\mathbf{m}$.\n*   **Angular Deviation**: The vector $\\mathbf{G}$ is normalized to obtain the unit direction $\\hat{\\mathbf{G}} = \\mathbf{G}/\\|\\mathbf{G}\\|$. The angular deviation $\\varphi_i$ for each measured normal $\\hat{\\mathbf{n}}_i$ is computed as $\\varphi_i = \\arccos(|\\hat{\\mathbf{n}}_i \\cdot \\hat{\\mathbf{G}}|)$. The use of the absolute value $|\\cdot|$ correctly accounts for the physical equivalence of a plane normal and its opposite direction.\n*   **Robust Aggregation**: To mitigate the effect of outliers, a two-stage robust aggregation is performed.\n    1.  **Trimming**: The set of $N$ computed angles $\\{\\varphi_i\\}$ is sorted, and the largest $\\lfloor \\tau N \\rfloor$ angles are discarded, where $\\tau$ is the trimming fraction.\n    2.  **Huber Loss**: For each of the remaining angles $\\varphi$, the Huber loss $\\rho_\\delta(\\varphi)$ is calculated. This function behaves quadratically for small deviations ($|\\varphi| \\le \\delta$), penalizing them lightly, and linearly for large deviations ($|\\varphi| > \\delta$), reducing the influence of residual errors.\n*   **Total Objective**: The final objective value for the candidate $(h,k,l)$ is the sum of the Huber losses over the set of trimmed angles.\n\n**3. Optimization and Tie-Breaking**\n\nThe algorithm iterates through all valid candidates, calculating the objective value for each. It maintains a record of the \"best\" candidate found thus far. A new candidate replaces the current best if it has a strictly lower objective value. In the event of a tie in the objective value, a multi-stage, deterministic tie-breaking procedure is invoked to ensure a unique solution:\n\n1.  **Vector Norm**: The candidate with the smaller reciprocal vector norm, $\\|\\mathbf{G}\\|$, is preferred. This favors planes with larger interplanar spacing, a common physical preference.\n2.  **Canonical Sign**: If a tie persists, the candidate whose first non-zero index (reading from $h$ to $k$ to $l$) is positive is chosen.\n3.  **Absolute Lexicographical Order**: If still tied, the candidates' absolute indices $(|h|,|k|,|l|)$ are compared lexicographically. The one that is smaller is preferred.\n4.  **Signed Lexicographical Order**: As a final tie-breaker, the signed indices $(h,k,l)$ are compared lexicographically. The smaller tuple is chosen.\n\nThis structured search and tie-breaking protocol guarantees the identification of a single, optimal set of Miller indices for each test case provided.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Main function to define and solve the test cases for Miller index inference.\n    \"\"\"\n    test_cases = [\n        # Test Case 1\n        {\n            \"B\": np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]]),\n            \"normals\": np.array([\n                [0.71, 0.70, 0.00],\n                [0.69, 0.72, 0.02],\n                [0.73, 0.68, -0.01],\n                [-0.71, -0.70, 0.00],\n                [0.00, 0.00, 1.00],\n                [0.70, 0.71, 0.00]\n            ]),\n            \"delta\": 0.10,\n            \"tau\": 0.17,\n            \"H_max\": 3\n        },\n        # Test Case 2\n        {\n            \"B\": np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]]),\n            \"normals\": np.array([\n                [0.58, 0.58, 0.58],\n                [0.60, 0.61, 0.51],\n                [0.55, 0.56, 0.65],\n                [-0.58, -0.58, -0.58],\n                [1.00, 0.00, 0.00]\n            ]),\n            \"delta\": 0.10,\n            \"tau\": 0.20,\n            \"H_max\": 3\n        },\n        # Test Case 3\n        {\n            \"B\": np.array([[1/3, 0, 0], [0, 1/4, 0], [0, 0, 1/5]]),\n            \"normals\": np.array([\n                [0.90, 0.34, 0.27],\n                [0.89, 0.35, 0.29],\n                [0.92, 0.33, 0.26],\n                [-0.90, -0.34, -0.27],\n                [0.00, 1.00, 0.00]\n            ]),\n            \"delta\": 0.10,\n            \"tau\": 0.20,\n            \"H_max\": 4\n        },\n        # Test Case 4\n        {\n            \"B\": np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]]),\n            \"normals\": np.array([\n                [0.00, 0.01, 0.9999],\n                [-0.01, 0.00, 0.9998],\n                [0.02, -0.01, 0.9997],\n                [1.00, 0.00, 0.00],\n                [0.00, 1.00, 0.00]\n            ]),\n            \"delta\": 0.10,\n            \"tau\": 0.40,\n            \"H_max\": 2\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # Before passing normals, ensure they are unit vectors\n        norm_of_normals = np.linalg.norm(case[\"normals\"], axis=1, keepdims=True)\n        # Avoid division by zero for zero vectors, though not expected here\n        norm_of_normals[norm_of_normals == 0] = 1.0\n        unit_normals = case[\"normals\"] / norm_of_normals\n        \n        best_hkl = find_best_hkl(case[\"B\"], unit_normals, case[\"delta\"], case[\"tau\"], case[\"H_max\"])\n        results.append(list(best_hkl))\n    \n    # Format output precisely as requested: [[h1,k1,l1],[h2,k2,l2],...]\n    inner_results_str = [f\"[{h},{k},{l}]\" for h, k, l in results]\n    print(f\"[{','.join(inner_results_str)}]\")\n\n\ndef huber_loss(phi, delta):\n    \"\"\"Calculates the Huber loss for a given angle phi and parameter delta.\"\"\"\n    if abs(phi) <= delta:\n        return 0.5 * phi**2\n    else:\n        return delta * (abs(phi) - 0.5 * delta)\n\ndef first_nonzero_is_positive(h, k, l):\n    \"\"\"Checks if the first non-zero element of (h,k,l) is positive.\"\"\"\n    if h > 0: return True\n    if h < 0: return False\n    if k > 0: return True\n    if k < 0: return False\n    if l > 0: return True\n    # l < 0 is the only remaining case, as (0,0,0) is excluded\n    return False\n\ndef find_best_hkl(B, normals, delta, tau, H_max):\n    \"\"\"\n    Finds the best Miller indices (h,k,l) by minimizing the robust objective function.\n    \"\"\"\n    best_candidate = {\n        \"hkl\": None,\n        \"objective\": float('inf'),\n        \"norm_G\": float('inf'),\n    }\n\n    n_normals = normals.shape[0]\n    num_to_trim = int(math.floor(tau * n_normals))\n\n    for h in range(-H_max, H_max + 1):\n        for k in range(-H_max, H_max + 1):\n            for l in range(-H_max, H_max + 1):\n                \n                # Constraint 1: Not (0,0,0)\n                if h == 0 and k == 0 and l == 0:\n                    continue\n                \n                # Constraint 2: Coprime\n                if math.gcd(abs(h), math.gcd(abs(k), abs(l))) != 1:\n                    continue\n                \n                hkl_vec = np.array([h, k, l])\n                \n                # Calculate objective\n                G = B @ hkl_vec\n                norm_G = np.linalg.norm(G)\n                \n                if norm_G == 0: # Should not happen with valid B and non-zero hkl\n                    continue\n                \n                G_hat = G / norm_G\n                \n                dot_products = np.abs(normals @ G_hat)\n                # Clamp to avoid domain errors with arccos due to float precision\n                dot_products = np.clip(dot_products, -1.0, 1.0)\n                angles = np.arccos(dot_products)\n                \n                sorted_angles = np.sort(angles)\n                \n                if num_to_trim > 0:\n                    trimmed_angles = sorted_angles[:-num_to_trim]\n                else:\n                    trimmed_angles = sorted_angles\n                \n                objective = sum(huber_loss(phi, delta) for phi in trimmed_angles)\n                \n                # Comparison and tie-breaking\n                is_better = False\n                if objective < best_candidate[\"objective\"]:\n                    is_better = True\n                elif objective == best_candidate[\"objective\"]:\n                    if norm_G < best_candidate[\"norm_G\"]:\n                        is_better = True\n                    elif norm_G == best_candidate[\"norm_G\"]:\n                        new_is_pos = first_nonzero_is_positive(h, k, l)\n                        best_is_pos = first_nonzero_is_positive(*best_candidate[\"hkl\"])\n                        if new_is_pos and not best_is_pos:\n                            is_better = True\n                        elif new_is_pos == best_is_pos:\n                            abs_new = (abs(h), abs(k), abs(l))\n                            abs_best = tuple(abs(x) for x in best_candidate[\"hkl\"])\n                            if abs_new < abs_best:\n                                is_better = True\n                            elif abs_new == abs_best:\n                                if hkl_vec.tolist() < best_candidate[\"hkl\"]:\n                                    is_better = True\n\n                if is_better:\n                    best_candidate[\"hkl\"] = [h, k, l]\n                    best_candidate[\"objective\"] = objective\n                    best_candidate[\"norm_G\"] = norm_G\n                    \n    return tuple(best_candidate[\"hkl\"])\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3442251"}]}