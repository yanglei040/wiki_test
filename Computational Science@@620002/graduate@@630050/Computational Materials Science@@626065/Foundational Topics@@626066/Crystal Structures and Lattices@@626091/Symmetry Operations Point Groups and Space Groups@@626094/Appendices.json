{"hands_on_practices": [{"introduction": "The foundation of crystallography lies in understanding how the geometric shape of a unit cell dictates its symmetry. This exercise challenges you to work backwards from a set of lattice parameters to deduce the crystal system and Bravais lattice, reinforcing the fundamental connection between metric constraints and symmetry. By constructing the primitive vectors and calculating the cell volume from first principles [@problem_id:3491341], you will solidify your grasp of the essential geometry that underpins all crystal structures.", "problem": "A crystalline solid has lattice parameters $(a,b,c,\\alpha,\\beta,\\gamma)$ satisfying $a=b\\neq c$, $\\alpha=\\beta=90^{\\circ}$, and $\\gamma=120^{\\circ}$, where all angles are given in degrees. Starting from the core definitions of Bravais lattices, crystal systems, conventional versus primitive cells, and the geometric definition of a unit cell volume as the volume of a parallelepiped spanned by translation vectors, do the following:\n\n- Use the metric constraints to determine the crystal system and Bravais lattice type from first principles.\n- Identify whether the conventional cell for this Bravais lattice is primitive or centered, and justify your choice using symmetry and metric arguments.\n- Construct a set of primitive translation vectors in a right-handed Cartesian frame with the $c$ axis along $\\hat{\\mathbf{z}}$ and the basal plane spanned by $\\hat{\\mathbf{x}}$ and $\\hat{\\mathbf{y}}$, consistent with the given metric constraints.\n- Using only the geometric definition of volume via the scalar triple product, derive the primitive cell volume $V_{p}$ from your primitive translation vectors and simplify the result.\n\nProvide, as your final answer, the exact value of the dimensionless ratio $V_{p}/(a^{2}c)$. Do not approximate your answer; give it in exact closed form. No units are required for this dimensionless ratio. The final answer must be a single expression.", "solution": "The analysis of the problem statement begins with the validation of its premises and constraints. The given lattice parameters are $(a,b,c,\\alpha,\\beta,\\gamma)$ with the constraints $a=b\\neq c$, $\\alpha=\\beta=90^{\\circ}$, and $\\gamma=120^{\\circ}$. These constraints are self-consistent and correspond to the definition of a standard crystal system in crystallography. The problem is scientifically grounded, well-posed, and objective, with all information required for a unique solution provided. Therefore, the problem is valid, and we may proceed with the solution.\n\nThe first task is to determine the crystal system and Bravais lattice type from the given metric constraints. Crystal systems are classified based on the minimum symmetry required to describe the lattice geometry, which is reflected in the constraints on the conventional unit cell axes and angles. The given constraints are $a=b \\neq c$, $\\alpha=\\beta=90^{\\circ}$, and $\\gamma=120^{\\circ}$. The presence of a unique axis (the $c$-axis, since $c \\neq a, b$) perpendicular to a basal plane (since $\\alpha = \\beta = 90^{\\circ}$) where the two-dimensional lattice has two equal axes with a non-$90^{\\circ}$ angle ($a=b, \\gamma=120^{\\circ}$) is characteristic of the hexagonal crystal system. A hexagonal lattice possesses a single axis of either 6-fold or 3-fold rotational symmetry. The specific angle $\\gamma=120^{\\circ}$ implies the presence of a 6-fold or 3-fold axis, which is the defining symmetry element for the hexagonal family. The provided constraints define the conventional cell of the **Hexagonal** crystal system. For the hexagonal system, there is only one Bravais lattice: the **Hexagonal Primitive** lattice, denoted by the symbol P.\n\nThe second task is to identify whether the conventional cell for this Bravais lattice is primitive or centered. A primitive cell contains exactly one lattice point. The conventional cell for the hexagonal Bravais lattice has lattice points only at its corners. By convention, the lattice points at the corners of a unit cell are shared among the $8$ cells that meet at that corner, so each of the $8$ corners contributes $1/8$ of a lattice point to the cell. Thus, the total number of lattice points per conventional hexagonal cell is $8 \\times (1/8) = 1$. Since the conventional cell contains precisely one lattice point, it is, by definition, a **primitive** cell. No centering vectors are needed to describe the lattice. It is important to distinguish this from the rhombohedral lattice, which can be described by a non-primitive (centered) hexagonal cell. However, the problem statement's constraints directly define the primitive hexagonal Bravais lattice.\n\nThe third task is to construct a set of primitive translation vectors. Since the conventional cell is primitive, we can use its lattice vectors. We will define a right-handed Cartesian coordinate system as specified, with the $c$-axis along $\\hat{\\mathbf{z}}$. The primitive translation vectors are denoted as $\\mathbf{a}_1, \\mathbf{a}_2, \\mathbf{a}_3$.\nTheir magnitudes are $|\\mathbf{a}_1|=a$, $|\\mathbf{a}_2|=b=a$, and $|\\mathbf{a}_3|=c$.\nThe angles between them are $\\angle(\\mathbf{a}_2, \\mathbf{a}_3) = \\alpha = 90^{\\circ}$, $\\angle(\\mathbf{a}_1, \\mathbf{a}_3) = \\beta = 90^{\\circ}$, and $\\angle(\\mathbf{a}_1, \\mathbf{a}_2) = \\gamma = 120^{\\circ}$.\n\nWe set up the vectors in Cartesian coordinates $(x,y,z)$:\n1.  Let the vector $\\mathbf{a}_3$ be aligned with the Cartesian $\\hat{\\mathbf{z}}$ axis:\n    $$ \\mathbf{a}_3 = (0, 0, c) $$\n2.  Since $\\alpha = \\beta = 90^{\\circ}$, both $\\mathbf{a}_1$ and $\\mathbf{a}_2$ must lie in the $xy$-plane. We align $\\mathbf{a}_1$ with the Cartesian $\\hat{\\mathbf{x}}$ axis:\n    $$ \\mathbf{a}_1 = (a, 0, 0) $$\n3.  The vector $\\mathbf{a}_2$ must have a magnitude of $a$ and make an angle of $\\gamma=120^{\\circ}$ with $\\mathbf{a}_1$. Its components in the $xy$-plane are:\n    $$ \\mathbf{a}_2 = (a \\cos(120^{\\circ}), a \\sin(120^{\\circ}), 0) $$\n    Using the trigonometric values $\\cos(120^{\\circ}) = -1/2$ and $\\sin(120^{\\circ}) = \\sqrt{3}/2$, we obtain:\n    $$ \\mathbf{a}_2 = \\left(-\\frac{a}{2}, \\frac{a\\sqrt{3}}{2}, 0\\right) $$\nThe resulting set of primitive translation vectors is:\n$$ \\mathbf{a}_1 = (a, 0, 0) $$\n$$ \\mathbf{a}_2 = \\left(-\\frac{a}{2}, \\frac{a\\sqrt{3}}{2}, 0\\right) $$\n$$ \\mathbf{a}_3 = (0, 0, c) $$\n\nThe fourth task is to derive the primitive cell volume, $V_p$, using the scalar triple product of these vectors. The volume is given by $V_p = |\\mathbf{a}_1 \\cdot (\\mathbf{a}_2 \\times \\mathbf{a}_3)|$, which can be computed as the absolute value of the determinant of the matrix whose rows are the vector components.\n$$ V_p = \\left| \\det \\begin{pmatrix} a & 0 & 0 \\\\ -a/2 & a\\sqrt{3}/2 & 0 \\\\ 0 & 0 & c \\end{pmatrix} \\right| $$\nWe can expand the determinant along the first row:\n$$ V_p = \\left| a \\det \\begin{pmatrix} a\\sqrt{3}/2 & 0 \\\\ 0 & c \\end{pmatrix} - 0 + 0 \\right| $$\n$$ V_p = \\left| a \\left( \\left(\\frac{a\\sqrt{3}}{2}\\right)(c) - (0)(0) \\right) \\right| $$\n$$ V_p = \\left| a \\left( \\frac{a c \\sqrt{3}}{2} \\right) \\right| = \\frac{\\sqrt{3}}{2} a^2 c $$\nThe volume is positive, confirming that the constructed vector set is right-handed. The primitive cell volume is $V_p = \\frac{\\sqrt{3}}{2} a^2 c$.\n\nFinally, we are asked to provide the exact value of the dimensionless ratio $V_p / (a^2 c)$.\n$$ \\frac{V_p}{a^2 c} = \\frac{\\frac{\\sqrt{3}}{2} a^2 c}{a^2 c} $$\nThe terms $a^2$ and $c$ cancel, leaving the simplified expression.\n$$ \\frac{V_p}{a^2 c} = \\frac{\\sqrt{3}}{2} $$\nThis is the final dimensionless ratio in exact closed form.", "answer": "$$\\boxed{\\frac{\\sqrt{3}}{2}}$$", "id": "3491341"}, {"introduction": "Once the lattice framework is defined, space group theory provides a powerful toolkit for populating it with atoms. This practice focuses on Wyckoff positions, which act as symmetry-constrained blueprints for generating entire crystal structures from a small number of symmetrically independent atoms. By implementing a structure generator for simple space groups [@problem_id:3491353], you will gain direct experience with how symmetry dramatically reduces the number of degrees of freedom required to describe a periodic solid.", "problem": "You are asked to implement a complete and runnable program that constructs a minimal, verifiable pipeline around symmetry operations, Wyckoff positions, and degrees-of-freedom counting in crystalline space groups. The program must operate purely on fractional atomic coordinates in the unit cube and use only a small, explicitly specified subset of space groups. The program must be deterministic and self-contained.\n\nFundamental base and definitions to use:\n- A space group acts on fractional coordinates $\\mathbf{r} \\in [0,1)^3$ by affine maps $(R,\\boldsymbol{\\tau})$ with $R \\in \\mathbb{Z}^{3 \\times 3}$ and $\\boldsymbol{\\tau} \\in \\mathbb{R}^3$, via $\\mathbf{r} \\mapsto R \\mathbf{r} + \\boldsymbol{\\tau}$ modulo lattice translations. Coordinates are always reduced modulo $1$ componentwise.\n- A Wyckoff position is an orbit of a point under the action of the space group, with multiplicity $m$ equal to the number of points in the orbit inside a primitive unit cell for a generic representative of that orbit.\n- The site-symmetry group of a point $\\mathbf{r}$ is the subgroup of space-group operations that leave $\\mathbf{r}$ invariant modulo a lattice vector. For a general Wyckoff position, the site-symmetry group is trivial and has order $1$; for a special Wyckoff position, the site-symmetry group has order greater than $1$.\n- The number of independent positional parameters $p$ for a Wyckoff position is the dimension of the free parameters needed to specify a symmetrically independent representative of that position within the unit cell.\n- Without symmetry, $m$ atoms would have $3 m$ positional degrees of freedom. Under symmetry, only $p$ independent parameters remain. The reduction in independent positional degrees of freedom is therefore $\\Delta = 3 m - p$.\n\nSpace groups and Wyckoff data you must implement:\n- Space group $G = 1$ (symbol $P1$):\n  - Symmetry operations: only the identity $R = I_3$, $\\boldsymbol{\\tau} = (0,0,0)$.\n  - Wyckoff positions:\n    - Letter $\\mathrm{a}$: multiplicity $m = 1$, site symmetry $1$, parameterization $(x,y,z)$ with $p = 3$.\n- Space group $G = 2$ (symbol $P\\bar{1}$):\n  - Symmetry operations: identity and inversion about the origin, i.e., $(R,\\boldsymbol{\\tau}) \\in \\{(I_3,(0,0,0)), (-I_3,(0,0,0))\\}$.\n  - Wyckoff positions:\n    - Letter $\\mathrm{a}$: multiplicity $m = 1$, coordinates $(0,0,0)$, site symmetry $\\bar{1}$, $p = 0$.\n    - Letter $\\mathrm{b}$: multiplicity $m = 1$, coordinates $(\\tfrac{1}{2}, \\tfrac{1}{2}, \\tfrac{1}{2})$, site symmetry $\\bar{1}$, $p = 0$.\n    - Letter $\\mathrm{i}$ (general): multiplicity $m = 2$, parameterization $(x,y,z)$ and $(-x,-y,-z)$ modulo $1$, $p = 3$.\n\nTasks your program must perform:\n- Enumerate all Wyckoff positions for a given $G \\in \\{1,2\\}$ by returning their letters, multiplicities $m$, site symmetries, and the number $p$ of independent positional parameters.\n- For a specific Wyckoff letter, generate a structure by:\n  - Sampling the $p$ free parameters uniformly in $[0,1)$ using a fixed seed when requested, or using explicitly supplied parameters when provided.\n  - Applying all symmetry operations of $G$ to the independent representative to generate all equivalent fractional coordinates in $[0,1)$ that constitute the orbit (deduplicate modulo $1$ within a numerical tolerance).\n- Quantify the reduction in positional degrees of freedom as $\\Delta = 3m - p$ for that Wyckoff position.\n- Verify group-closure consistency for the generated structure: every symmetry operation applied to every generated atomic position must map to a position that coincides (modulo $1$ within a tolerance) with one of the generated positions. Report a boolean indicating whether this check passes.\n\nAngle units and physical units are not applicable because all coordinates are fractional and dimensionless.\n\nTest suite and required outputs:\nUse the following five test cases, each described by a tuple $(G, \\text{letter}, \\text{seed}, \\text{params})$ where $\\text{seed}$ is used only when $\\text{params}$ is not provided. For each test case, your program must compute and collect the result as a list $[m, p, \\Delta, \\text{invariant}]$:\n- Case $1$: $(G = 1, \\text{letter} = \\mathrm{a}, \\text{seed} = 42, \\text{params} = \\text{None})$.\n- Case $2$: $(G = 2, \\text{letter} = \\mathrm{i}, \\text{seed} = 123, \\text{params} = \\text{None})$.\n- Case $3$: $(G = 2, \\text{letter} = \\mathrm{a}, \\text{seed} = \\text{None}, \\text{params} = \\text{None})$.\n- Case $4$: $(G = 2, \\text{letter} = \\mathrm{b}, \\text{seed} = \\text{None}, \\text{params} = \\text{None})$.\n- Case $5$: $(G = 2, \\text{letter} = \\mathrm{i}, \\text{seed} = \\text{None}, \\text{params} = (\\tfrac{1}{2}, 0.3, 0))$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case contributes a list $[m,p,\\Delta,\\text{invariant}]$, so the final output must look like\n  [$[m_1,p_1,\\Delta_1,\\text{invariant}_1]$, $[m_2,p_2,\\Delta_2,\\text{invariant}_2]$, $[m_3,p_3,\\Delta_3,\\text{invariant}_3]$, $[m_4,p_4,\\Delta_4,\\text{invariant}_4]$, $[m_5,p_5,\\Delta_5,\\text{invariant}_5]$]\nwith no extra text. Booleans must be reported in the programming language’s native boolean literals. All integers must be exact, and no floating-point values other than those required for internal checks should appear in the final output.", "solution": "The problem requires the implementation of a computational pipeline to handle crystallographic symmetry operations for a specific subset of space groups, namely $G=1$ ($P1$) and $G=2$ ($P\\bar{1}$). The tasks involve generating atomic coordinates for given Wyckoff positions, calculating the reduction in configurational degrees of freedom, and verifying the closure property of the space group operations on the generated structures. The solution is predicated on the principles of group theory as applied to crystallography.\n\nFirst, we must establish a formal representation for the space group data. A space group operation is an affine transformation $(\\boldsymbol{R}, \\boldsymbol{\\tau})$ acting on a fractional coordinate vector $\\mathbf{r} \\in [0,1)^3$. The transformation is given by $\\mathbf{r}' = \\boldsymbol{R}\\mathbf{r} + \\boldsymbol{\\tau}$, where results are taken modulo lattice translations (i.e., component-wise modulo $1$). The rotational part $\\boldsymbol{R}$ is a $3 \\times 3$ integer matrix, and the translational part $\\boldsymbol{\\tau}$ is a $3 \\times 1$ real vector.\n\nThe specific data provided in the problem statement will be encoded in a structured format accessible to the program.\nFor space group $G=1$ ($P1$), there is only one symmetry operation: the identity $(\\boldsymbol{I}, \\mathbf{0})$, where $\\boldsymbol{I}$ is the $3 \\times 3$ identity matrix and $\\mathbf{0}$ is the zero vector.\nFor space group $G=2$ ($P\\bar{1}$), there are two operations: the identity $(\\boldsymbol{I}, \\mathbf{0})$ and inversion through the origin $(-\\boldsymbol{I}, \\mathbf{0})$.\n\nThe Wyckoff positions for each group are also defined. A Wyckoff position is an orbit of points under the group's symmetry operations. It is characterized by its multiplicity $m$, site symmetry, and the number of independent parameters $p$ needed to define a representative point of the orbit.\n- For $G=1$, the single Wyckoff position $1a$ has $m=1$ and $p=3$, with a representative point parameterized as $(x, y, z)$.\n- For $G=2$, there are three specified Wyckoff positions:\n    - $2a$: A special position with multiplicity $m=1$ and $p=0$. The representative point is fixed at $(0,0,0)$.\n    - $2b$: Another special position with $m=1$ and $p=0$, with representative at $(\\frac{1}{2}, \\frac{1}{2}, \\frac{1}{2})$.\n    - $2i$: The general position with $m=2$ and $p=3$, with a representative parameterized as $(x, y, z)$.\n\nThe core of the algorithm proceeds on a case-by-case basis as specified by the test suite. For each test case defined by a tuple $(G, \\text{letter}, \\text{seed}, \\text{params})$, we perform the following steps:\n\n1.  **Retrieve Wyckoff and Symmetry Data**: Based on the given space group number $G$ and Wyckoff letter, we retrieve the corresponding multiplicity $m$, number of parameters $p$, and the set of symmetry operations $\\{(\\boldsymbol{R}_i, \\boldsymbol{\\tau}_i)\\}$.\n\n2.  **Generate Representative Point**: A single representative coordinate vector $\\mathbf{r}_{rep}$ is established.\n    - If the input `params` tuple is provided, its values are used.\n    - If `params` is not provided, we check the number of parameters $p$. If $p>0$, we generate $p$ pseudo-random numbers in the interval $[0,1)$ using a random number generator seeded with the given `seed`. These numbers form the coordinates of $\\mathbf{r}_{rep}$.\n    - If $p=0$, the Wyckoff position is special, and $\\mathbf{r}_{rep}$ is set to its pre-defined fixed coordinates.\n\n3.  **Generate Crystal Structure (Orbit Generation)**: The full set of symmetrically equivalent points (the orbit) is generated by applying every symmetry operation $(\\boldsymbol{R}_i, \\boldsymbol{\\tau}_i)$ to the representative point $\\mathbf{r}_{rep}$. Each resulting vector $\\mathbf{r}'_i = \\boldsymbol{R}_i \\mathbf{r}_{rep} + \\boldsymbol{\\tau}_i$ is reduced modulo $1$ component-wise. A numerically robust way to perform this reduction on a vector $\\mathbf{v}$ is $\\mathbf{v} - \\lfloor \\mathbf{v} \\rfloor$.\n    A crucial step is to collect only the unique positions. Due to floating-point arithmetic, a simple equality check is insufficient. Two vectors $\\mathbf{v}_1$ and $\\mathbf{v}_2$ are considered equivalent if their difference, wrapped into the primary unit cell, is close to the zero vector. That is, if $\\|\\mathbf{v}_1 - \\mathbf{v}_2 - \\text{round}(\\mathbf{v}_1 - \\mathbf{v}_2)\\| < \\epsilon$ for a small tolerance $\\epsilon$. We will use a tolerance of $\\epsilon = 10^{-6}$. The collection of unique points forms the crystal structure.\n\n4.  **Calculate Reduction in Degrees of Freedom**: The reduction in positional degrees of freedom, $\\Delta$, is calculated using the formula $\\Delta = 3m - p$. Here, $m$ is the multiplicity of the Wyckoff position (for a generic representative), not necessarily the number of points in the generated orbit, which might be smaller if the chosen parameters for $\\mathbf{r}_{rep}$ accidentally fall on a higher-symmetry site. The values for $m$ and $p$ are taken directly from the problem's definition for the specified Wyckoff letter.\n\n5.  **Verify Group Closure Consistency**: This is a fundamental check to ensure the generated structure is a valid orbit. The property of group closure implies that applying any group operation to any point already in the orbit must result in another point that is also in the orbit.\n    We implement this check by iterating through every generated position $\\mathbf{p}$ in the structure and every symmetry operation $(\\boldsymbol{R}_j, \\boldsymbol{\\tau}_j)$ in the space group. For each pair, we compute the transformed point $\\mathbf{p}' = \\boldsymbol{R}_j \\mathbf{p} + \\boldsymbol{\\tau}_j$ (modulo $1$). We then verify if this $\\mathbf{p}'$ is equivalent (within the numerical tolerance $\\epsilon$) to at least one of the points in the originally generated set of positions. If this holds true for all pairs, the structure is invariant, and a boolean flag is set to `True`. If even one check fails, the flag is set to `False`.\n\nFinally, for each test case, the computed values $[m, p, \\Delta, \\text{invariant}]$ are collected. The final output is a list of these results, formatted precisely as requested.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the crystallography problem by processing a series of test cases\n    involving space groups, Wyckoff positions, and symmetry operations.\n    \"\"\"\n    \n    # Define a numerical tolerance for floating-point comparisons.\n    TOL = 1e-6\n\n    # Define the space group and Wyckoff position data.\n    SPACE_GROUP_DATA = {\n        1: { # P1\n            \"ops\": [\n                (np.identity(3, dtype=int), np.array([0.0, 0.0, 0.0]))\n            ],\n            \"wyckoff\": {\n                \"a\": {\"m\": 1, \"p\": 3, \"coords\": None, \"site_sym\": \"1\"}\n            }\n        },\n        2: { # P-1\n            \"ops\": [\n                (np.identity(3, dtype=int), np.array([0.0, 0.0, 0.0])),\n                (-np.identity(3, dtype=int), np.array([0.0, 0.0, 0.0]))\n            ],\n            \"wyckoff\": {\n                \"a\": {\"m\": 1, \"p\": 0, \"coords\": np.array([0.0, 0.0, 0.0]), \"site_sym\": \"-1\"},\n                \"b\": {\"m\": 1, \"p\": 0, \"coords\": np.array([0.5, 0.5, 0.5]), \"site_sym\": \"-1\"},\n                \"i\": {\"m\": 2, \"p\": 3, \"coords\": None, \"site_sym\": \"1\"}\n            }\n        }\n    }\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (1, \"a\", 42, None),\n        (2, \"i\", 123, None),\n        (2, \"a\", None, None),\n        (2, \"b\", None, None),\n        (2, \"i\", None, (0.5, 0.3, 0.0)),\n    ]\n\n    # Helper function to apply modulo 1 reduction to fractional coordinates.\n    def reduce_modulo_1(vec):\n        return vec - np.floor(vec)\n\n    # Helper function to check if two vectors are close, considering periodic boundaries.\n    def are_close(v1, v2):\n        diff = v1 - v2\n        periodic_diff = diff - np.round(diff)\n        return np.linalg.norm(periodic_diff) < TOL\n\n    # Helper function to format a list into the required string format without spaces.\n    def format_list(lst):\n        # Manually format boolean to be lowercase 'true'/'false' for Python\n        # but the prompt asks for language native literals. Python's is True/False\n        # so this is more robust.\n        str_list = []\n        for item in lst:\n            if isinstance(item, bool):\n                str_list.append(str(item))\n            else:\n                str_list.append(str(item))\n        return f\"[{','.join(str_list)}]\"\n\n    results = []\n    for G, letter, seed, params in test_cases:\n        # 1. Retrieve data\n        group_info = SPACE_GROUP_DATA[G]\n        wyckoff_info = group_info[\"wyckoff\"][letter]\n        ops = group_info[\"ops\"]\n        m, p = wyckoff_info[\"m\"], wyckoff_info[\"p\"]\n\n        # 2. Generate representative point\n        r_rep = None\n        if params is not None:\n            r_rep = np.array(params)\n        elif p > 0:\n            rng = np.random.default_rng(seed=seed)\n            r_rep = rng.random(p)\n        else: # p == 0\n            r_rep = wyckoff_info[\"coords\"]\n\n        # 3. Generate orbit\n        positions = []\n        for R, tau in ops:\n            new_pos = reduce_modulo_1(R @ r_rep + tau)\n            \n            # Add to list only if not already present (within tolerance)\n            is_new = True\n            for pos in positions:\n                if are_close(new_pos, pos):\n                    is_new = False\n                    break\n            if is_new:\n                positions.append(new_pos)\n\n        # 4. Calculate reduction in degrees of freedom\n        delta = 3 * m - p\n\n        # 5. Verify group closure consistency\n        is_invariant = True\n        if not positions: # Handle cases with no positions, though not expected here\n             is_invariant = True\n        else:\n            for R, tau in ops:\n                for p_initial in positions:\n                    p_final = reduce_modulo_1(R @ p_initial + tau)\n                    \n                    # Check if p_final is in the set of positions\n                    found_match = False\n                    for p_target in positions:\n                        if are_close(p_final, p_target):\n                            found_match = True\n                            break\n                    \n                    if not found_match:\n                        is_invariant = False\n                        break\n                if not is_invariant:\n                    break\n        \n        results.append([m, p, delta, is_invariant])\n\n    # Final print statement in the exact required format.\n    final_output_str = f\"[{','.join(format_list(r) for r in results)}]\"\n    print(final_output_str)\n\nsolve()\n```", "id": "3491353"}, {"introduction": "The influence of symmetry extends from real space into reciprocal space, the domain where electronic and vibrational properties are analyzed. This exercise explores how the point group of a crystal can be used to identify the irreducible Brillouin zone (IBZ), the unique wedge of reciprocal space that contains all necessary information for property calculations. By implementing a k-point reduction algorithm for a hexagonal lattice [@problem_id:3491394], you will tackle a core task in computational materials science that enables efficient and accurate simulations.", "problem": "You are tasked with implementing a program that reduces a set of wavevectors in reciprocal space to their irreducible representatives under the symmetry of a non-symmorphic hexagonal space group, specifically the group with Hermann–Mauguin symbol $P6_3/mmc$. The goal is to compute the irreducible Brillouin zone (IBZ) representatives and the orders of the little co-groups for specified test cases. Your implementation must correctly handle the equivalence induced by screw and glide operations in a non-symmorphic group by recognizing that space group operations may map a wavevector $\\mathbf{k}$ to $\\mathbf{k} + \\mathbf{G}$, where $\\mathbf{G}$ is a reciprocal lattice vector. Angles must be treated in radians, and vectors must be handled in Cartesian coordinates when applying rotations while the equivalence modulo reciprocal lattice vectors must be enforced in fractional (reduced) coordinates relative to the reciprocal basis.\n\nUse the following scientifically grounded bases:\n- Bloch’s theorem states that a crystalline Hamiltonian admits eigenstates labeled by the wavevector $\\mathbf{k}$ in reciprocal space, with equivalence under addition of reciprocal lattice vectors: $\\mathbf{k} \\sim \\mathbf{k} + \\mathbf{G}$.\n- A space group operation is represented by a Seitz operator $(R \\mid \\mathbf{t})$, with $R$ a rotation or roto-inversion matrix and $\\mathbf{t}$ a (possibly fractional) translation vector. For the purpose of classifying $\\mathbf{k}$-points into equivalence classes, only the rotational part $R$ determines the mapping of $\\mathbf{k}$ as a point in reciprocal space, but the presence of a fractional translation $\\mathbf{t}$ in non-symmorphic operations necessitates consistent reduction of $R\\,\\mathbf{k}$ modulo reciprocal lattice vectors, since the action on Bloch waves yields phase factors $\\exp(-i\\,\\mathbf{k}\\cdot\\mathbf{t})$ that do not alter the equivalence class of $\\mathbf{k}$ as a vector.\n- The irreducible Brillouin zone is defined as a set of representatives from equivalence classes of $\\mathbf{k}$ under the point group actions, with the equivalence relation $\\mathbf{k} \\equiv R\\,\\mathbf{k} + \\mathbf{G}$ for some reciprocal lattice vector $\\mathbf{G}$.\n- The reciprocal lattice basis $\\{ \\mathbf{b}_1, \\mathbf{b}_2, \\mathbf{b}_3 \\}$ is constructed from the direct lattice basis $\\{ \\mathbf{a}_1, \\mathbf{a}_2, \\mathbf{a}_3 \\}$ via the relation $$B = 2\\pi\\,A^{-T},$$ where $A$ is the $3\\times 3$ matrix whose columns are $\\mathbf{a}_1$, $\\mathbf{a}_2$, and $\\mathbf{a}_3$, and $B$ is the $3\\times 3$ matrix whose columns are $\\mathbf{b}_1$, $\\mathbf{b}_2$, and $\\mathbf{b}_3$.\n\nImplementation requirements:\n- Work with a hexagonal lattice defined by direct basis vectors $\\mathbf{a}_1 = (a, 0, 0)$, $\\mathbf{a}_2 = \\left(\\frac{a}{2}, \\frac{\\sqrt{3}\\,a}{2}, 0\\right)$, and $\\mathbf{a}_3 = (0, 0, c)$, with lattice parameters $a$ and $c$ given in the test suite.\n- Construct the full set of $24$ Cartesian rotation matrices corresponding to the hexagonal point group $D_{6h}$ by combining the $12$ proper rotations of the dihedral group $D_6$ (which include rotations about the $z$-axis by angles $0$, $\\pm \\frac{\\pi}{3}$, $\\pm \\frac{2\\pi}{3}$, and $\\pi$, and rotations by $\\pi$ about six axes lying in the basal plane at angles $\\phi = 0$, $\\frac{\\pi}{6}$, $\\frac{\\pi}{3}$, $\\frac{\\pi}{2}$, $\\frac{2\\pi}{3}$, and $\\frac{5\\pi}{6}$) with inversion (multiplication by $-I$) to obtain the $24$ elements of $D_{6h} = D_6 \\times C_i$.\n- Apply each rotation $R$ to a wavevector $\\mathbf{k}$ in Cartesian coordinates, convert back to fractional (reduced) coordinates with respect to the reciprocal basis, and reduce to the principal domain by mapping fractional components to the interval $[-\\frac{1}{2}, \\frac{1}{2})$ using $$h_i \\mapsto \\left((h_i + \\tfrac{1}{2}) \\bmod 1\\right) - \\tfrac{1}{2},$$ where $h_i$ denotes the fractional coordinate components of $\\mathbf{k}$ with respect to the reciprocal basis.\n- Implement the equivalence relation between two fractional coordinate vectors $\\mathbf{h}$ and $\\mathbf{h}'$ as equality modulo integer shifts: they are equivalent if there exists $\\mathbf{n} \\in \\mathbb{Z}^3$ such that $\\mathbf{h} - \\mathbf{h}' - \\mathbf{n}$ is numerically zero within a prescribed tolerance. This enforces $\\mathbf{k} \\equiv \\mathbf{k} + \\mathbf{G}$ consistency.\n- For each input wavevector $\\mathbf{k}$, compute its orbit (the “star”) under all group operations and choose a canonical representative of its equivalence class, for example the lexicographically minimal fractional vector after rounding to a fixed number of decimals, to define the irreducible representative.\n- For a wavevector $\\mathbf{k}$, compute the order of its little co-group (the stabilizer) as the number of group operations $R$ such that $R\\,\\mathbf{k} \\equiv \\mathbf{k}$ modulo reciprocal lattice vectors. Note: the translational parts of non-symmorphic operations do not move $\\mathbf{k}$ as a point in reciprocal space; however, their presence in $P6_3/mmc$ implies that the reduction $R\\,\\mathbf{k}$ to the chosen principal domain must always be performed modulo reciprocal lattice vectors, especially at boundaries like $k_z = \\pm \\tfrac{1}{2}$, where operations such as horizontal mirror effectively map $k_z \\to -k_z$ and require addition of a reciprocal lattice vector to return to the principal domain.\n\nAngle units must be in radians. Fractional coordinates of $\\mathbf{k}$ must be defined with respect to the reciprocal basis and are dimensionless.\n\nTest suite and outputs:\n- Use lattice parameters $a = 2.5$ and $c = 4.1$.\n- Test Case $1$ (general “happy path” reduction): Reduce the following list of fractional wavevectors to their IBZ representatives under $D_{6h}$ and return the number of unique irreducible representatives as an integer:\n  $$\\left[\\,(0,0,0),\\ (0,0,0.5),\\ \\left(\\tfrac{1}{3},\\tfrac{1}{3},0\\right),\\ \\left(\\tfrac{1}{3},\\tfrac{1}{3},0.5\\right),\\ (0.5,0,0),\\ (0.25,0.25,0.1),\\ (-0.44,0.22,-0.49),\\ (0.17,-0.21,0.3),\\ (0.12,0.07,0.5),\\ (0.11,-0.11,-0.5),\\ \\left(-\\tfrac{1}{3},-\\tfrac{1}{3},0\\right),\\ (0.5,-0.5,0)\\,\\right].$$\n- Test Case $2$ (high-symmetry boundary condition): Compute the size of the little co-group for the wavevector $\\mathbf{k} = (0,0,0)$ (the $\\Gamma$ point) and return it as an integer.\n- Test Case $3$ (significant edge case with non-symmorphic handling): Compute the size of the little co-group for the wavevector $\\mathbf{k} = \\left(\\tfrac{1}{3}, \\tfrac{1}{3}, \\tfrac{1}{2}\\right)$ (on the $k_z = \\tfrac{1}{2}$ boundary plane at the $H$ point) and return it as an integer.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the test cases described above. For example, it should print exactly one line like\n$$[\\text{result}_1,\\text{result}_2,\\text{result}_3],$$\nwhere $\\text{result}_1$, $\\text{result}_2$, and $\\text{result}_3$ are integers corresponding to the three test cases above.", "solution": "The user problem is to implement a program to reduce wavevectors ($\\mathbf{k}$-points) in a hexagonal lattice to their irreducible representatives under the symmetry of the non-symmorphic space group $P6_3/mmc$. This involves two main tasks: finding the number of unique irreducible Brillouin zone (IBZ) representatives for a given list of $\\mathbf{k}$-points, and computing the order of the little co-group for specific high-symmetry $\\mathbf{k}$-points.\n\n### Step 0: Problem Validation\n\nThe problem statement has been validated against the required criteria.\n\n1.  **Extract Givens**:\n    -   Space Group: $P6_3/mmc$ (non-symmorphic hexagonal).\n    -   Point Group: $D_{6h}$ (24 rotational operations).\n    -   Direct Lattice Basis: $\\mathbf{a}_1 = (a, 0, 0)$, $\\mathbf{a}_2 = (a/2, \\sqrt{3}a/2, 0)$, $\\mathbf{a}_3 = (0, 0, c)$.\n    -   Reciprocal Lattice Basis: Derived via $B = 2\\pi (A^{-T})$, where $A$ and $B$ are matrices whose columns are the direct and reciprocal basis vectors, respectively.\n    -   $\\mathbf{k}$-point Equivalence: $\\mathbf{k} \\equiv R\\mathbf{k} + \\mathbf{G}$, where $R$ is a point group rotation and $\\mathbf{G}$ is a reciprocal lattice vector.\n    -   Principal Domain for Fractional Coordinates $\\mathbf{h}$: $h_i \\in [-\\frac{1}{2}, \\frac{1}{2})$. The reduction rule is $h_i \\mapsto ((h_i + 0.5) \\pmod 1) - 0.5$.\n    -   IBZ Representative: The lexicographically minimal vector in the orbit (star) of $\\mathbf{k}$.\n    -   Little Co-group: The set of rotations $R$ such that $R\\mathbf{k} \\equiv \\mathbf{k} \\pmod{\\mathbf{G}}$.\n    -   Lattice Parameters: $a = 2.5$, $c = 4.1$.\n    -   Test Cases: (1) Count unique IBZ representatives from a list of 12 fractional k-vectors. (2) Compute little co-group order for $\\mathbf{k}=(0,0,0)$. (3) Compute little co-group order for $\\mathbf{k}=(1/3, 1/3, 1/2)$.\n\n2.  **Validate Using Extracted Givens**:\n    -   **Scientifically Grounded**: The problem is based on fundamental, well-established principles of solid-state physics and crystallography, including Bloch's theorem, space group theory, and reciprocal space analysis. The properties of the $P6_3/mmc$ space group and the required calculations are standard in computational materials science.\n    -   **Well-Posed**: The problem is clearly defined with all necessary inputs, definitions, and constraints. The objective for each test case is specific and allows for a unique, computable solution.\n    -   **Objective**: The problem is stated in precise, formal language, free from subjectivity or ambiguity.\n    -   **Conclusion**: The problem is scientifically sound, well-posed, objective, and complete. No invalidating flaws are present.\n\n### Step 1: Theoretical Framework and Algorithmic Design\n\nThe solution will be developed by first establishing the mathematical framework for coordinate systems and transformations, then generating the required symmetry operations, and finally implementing the algorithms for reduction and analysis.\n\n#### 1. Lattice and Coordinate Transformations\nThe direct lattice vectors are given in Cartesian coordinates. They form the columns of the matrix $A$:\n$$\nA = \\begin{pmatrix} a & a/2 & 0 \\\\ 0 & \\sqrt{3}a/2 & 0 \\\\ 0 & 0 & c \\end{pmatrix}\n$$\nThe reciprocal lattice basis vectors, forming the columns of matrix $B$, are derived from $A$ using the standard relation $B = 2\\pi(A^{-1})^T = 2\\pi(A^T)^{-1}$.\n$$\nA^T = \\begin{pmatrix} a & 0 & 0 \\\\ a/2 & \\sqrt{3}a/2 & 0 \\\\ 0 & 0 & c \\end{pmatrix} \\quad\\implies\\quad (A^T)^{-1} = \\begin{pmatrix} 1/a & 0 & 0 \\\\ -1/(\\sqrt{3}a) & 2/(\\sqrt{3}a) & 0 \\\\ 0 & 0 & 1/c \\end{pmatrix}\n$$\nThus, the reciprocal lattice matrix is:\n$$\nB = 2\\pi \\begin{pmatrix} 1/a & 0 & 0 \\\\ -1/(\\sqrt{3}a) & 2/(\\sqrt{3}a) & 0 \\\\ 0 & 0 & 1/c \\end{pmatrix}\n$$\nA wavevector $\\mathbf{k}$ can be expressed in Cartesian coordinates or in fractional (reduced) coordinates $\\mathbf{h}=(h_1, h_2, h_3)$ with respect to the reciprocal basis:\n-   Fractional to Cartesian: $\\mathbf{k}_{\\text{cart}} = B \\mathbf{h}$\n-   Cartesian to Fractional: $\\mathbf{h} = B^{-1} \\mathbf{k}_{\\text{cart}}$. The inverse matrix $B^{-1}$ is conveniently found as $B^{-1} = \\frac{1}{2\\pi}A^T$.\n\n#### 2. Point Group Symmetry Operations\nThe point group of $P6_3/mmc$ is $D_{6h}$, which has $24$ symmetry operations. These can be generated from the dihedral group $D_6$ and inversion. The group $D_6$ itself can be generated by a six-fold rotation $C_6$ about the $z$-axis and a two-fold rotation $C_2$ about the $x$-axis.\nThe $24$ Cartesian rotation matrices $\\{R_i\\}$ will be generated as follows:\n1.  Generate the 6 matrices for the cyclic group $C_6$ corresponding to rotations about the $z$-axis by angles $\\theta = k\\pi/3$ for $k \\in \\{0, 1, ..., 5\\}$.\n2.  Generate 6 additional matrices by composing the $C_6$ operations with a $C_2$ rotation about the $x$-axis, forming the 12 operations of $D_6$.\n3.  Generate the final 12 matrices by taking the product of the first 12 with the inversion matrix $-I$.\n\n#### 3. $\\mathbf{k}$-point Reduction and Equivalence\nThe core of the problem is applying the symmetry operations and handling the equivalence relation $\\mathbf{k} \\equiv R\\mathbf{k} + \\mathbf{G}$. This is implemented via the following steps:\n1.  A given $\\mathbf{k}$-point, in fractional coordinates $\\mathbf{h}$, is transformed to Cartesian coordinates: $\\mathbf{k}_{\\text{cart}} = B \\mathbf{h}$.\n2.  A symmetry operation is applied: $\\mathbf{k}'_{\\text{cart}} = R \\mathbf{k}_{\\text{cart}}$.\n3.  The result is transformed back to fractional coordinates: $\\mathbf{h}' = B^{-1} \\mathbf{k}'_{\\text{cart}}$.\n4.  The fractional vector $\\mathbf{h}'$ is reduced to the principal domain $[-\\frac{1}{2}, \\frac{1}{2})$ component-wise using the rule $x \\mapsto ((x + 0.5) \\pmod 1) - 0.5$. This step implicitly handles the addition of a reciprocal lattice vector $\\mathbf{G}$, as a shift by an integer in fractional coordinates is equivalent to adding a $\\mathbf{G}$ vector.\n\n#### 4. IBZ Representative and Little Co-group\n-   **IBZ Representative**: For a given $\\mathbf{k}$-point, its orbit (or \"star\") is the set of all unique $\\mathbf{k}$-points obtained by applying all $24$ symmetry operations and reducing to the principal domain. The canonical IBZ representative is defined as the lexicographically smallest vector within this orbit.\n-   **Little Co-group Order**: For a given $\\mathbf{k}$-point, its little co-group is the subgroup of point group operations that map $\\mathbf{k}$ to an equivalent point ($\\mathbf{k} \\equiv R\\mathbf{k} \\pmod{\\mathbf{G}}$). The order is simply the count of such operations. To compute this, we first reduce the input $\\mathbf{k}$ to its representation in the principal domain, $\\mathbf{h}_{\\text{red}}$. Then, we apply each of the $24$ operations $R_i$ and check if the resulting reduced vector is numerically identical to $\\mathbf{h}_{\\text{red}}$.\n\n### Step 2: Implementation Details\n\nThe program will be structured as follows:\n-   A `solve` function encapsulates the entire logic.\n-   Constants `a` and `c`, and a numerical tolerance `TOL` are defined.\n-   The lattice matrices $A$, $B$, and $B^{-1}$ are constructed.\n-   The 24 rotation matrices for $D_{6h}$ are pre-computed.\n-   Helper functions are implemented for:\n    -   `reduce_k_vector`: reducing a fractional vector to the principal domain.\n    -   `get_ibz_representative`: finding the canonical representative for a given k-point.\n    -   `get_little_co_group_order`: computing the size of the stabilizer group.\n-   The three test cases are processed in sequence using these helper functions.\n-   The final results are formatted and printed as a single line.\n\nThis structured approach ensures correctness by separating the distinct logical components: lattice geometry, group theory, and the reduction algorithms. Numerical stability is maintained by using a tolerance for floating-point comparisons.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of reducing wavevectors to their irreducible representatives\n    for the P6_3/mmc space group and computing little co-group orders.\n    \"\"\"\n    \n    # Define constants and tolerance\n    a = 2.5\n    c = 4.1\n    TOL = 1e-6\n\n    # --- Step 1: Setup Lattice and Coordinate Transformations ---\n    sqrt3 = np.sqrt(3)\n\n    # Direct lattice matrix A (columns are a1, a2, a3 in Cartesian)\n    A = np.array([\n        [a, a / 2.0, 0],\n        [0, sqrt3 * a / 2.0, 0],\n        [0, 0, c]\n    ])\n\n    # Reciprocal lattice matrix B = 2*pi*(A^T)^-1\n    # B_inv = (1/(2*pi)) * A^T\n    A_T = A.T\n    B_inv = (1.0 / (2.0 * np.pi)) * A_T\n    B = np.linalg.inv(B_inv)\n\n    # --- Step 2: Generate Point Group Symmetry Operations ---\n    def generate_d6h_rotations():\n        \"\"\"Generates the 24 Cartesian rotation matrices for the D6h point group.\"\"\"\n        rots = []\n        # Generate D6 ops first\n        d6_ops = []\n        # C6-subgroup part (rotations about z)\n        c6_z_ops = []\n        for i in range(6):\n            angle = i * np.pi / 3.0\n            cos_a, sin_a = np.cos(angle), np.sin(angle)\n            c6_z_ops.append(np.array([\n                [cos_a, -sin_a, 0],\n                [sin_a, cos_a, 0],\n                [0, 0, 1]\n            ]))\n        \n        d6_ops.extend(c6_z_ops)\n        \n        # C2 part (rotations about axes in xy-plane)\n        # These are generated by combining C6_z ops with a C2_x op\n        c2x_op = np.array([[1, 0, 0], [0, -1, 0], [0, 0, -1]])\n        for op in c6_z_ops:\n            d6_ops.append(op @ c2x_op)\n\n        # Generate D6h by adding inversion\n        for op in d6_ops:\n            rots.append(op)\n            rots.append(-op)\n\n        # Remove potential duplicates due to floating point arithmetic\n        unique_rots = []\n        for r in rots:\n            is_unique = True\n            for ur in unique_rots:\n                if np.allclose(r, ur, atol=TOL):\n                    is_unique = False\n                    break\n            if is_unique:\n                unique_rots.append(r)\n        return unique_rots\n\n    rotations = generate_d6h_rotations()\n\n    # --- Step 3: k-point Reduction and Analysis Functions ---\n    def reduce_k_vector(h_frac):\n        \"\"\"Reduces a fractional k-vector to the principal domain [-0.5, 0.5).\"\"\"\n        return np.mod(h_frac + 0.5, 1.0) - 0.5\n\n    def get_star(h_frac, reduced=True):\n        \"\"\"Computes the star (orbit) of a k-vector.\"\"\"\n        if reduced:\n            h_frac = reduce_k_vector(h_frac)\n        \n        k_cart = B @ h_frac\n        \n        star_h_frac = []\n        for R in rotations:\n            k_rot_cart = R @ k_cart\n            h_rot_frac = B_inv @ k_rot_cart\n            star_h_frac.append(reduce_k_vector(h_rot_frac))\n        \n        # Make the list unique\n        unique_star = []\n        for h in star_h_frac:\n            is_unique = True\n            for uh in unique_star:\n                if np.allclose(h, uh, atol=TOL):\n                    is_unique = False\n                    break\n            if is_unique:\n                unique_star.append(h)\n\n        return unique_star\n\n    def get_ibz_representative(h_frac):\n        \"\"\"Finds the canonical IBZ representative (lexicographically smallest).\"\"\"\n        star = get_star(h_frac)\n        # Round for stable lexicographical sort\n        star_rounded = [np.round(h, 8) for h in star]\n        # Sort based on tuple representation\n        lex_min_rep = min(star_rounded, key=lambda v: tuple(v))\n        return lex_min_rep\n\n    def get_little_co_group_order(h_frac):\n        \"\"\"Computes the order of the little co-group (stabilizer).\"\"\"\n        h_start = reduce_k_vector(h_frac)\n        k_start_cart = B @ h_start\n        count = 0\n        for R in rotations:\n            k_rot_cart = R @ k_start_cart\n            h_rot_frac = B_inv @ k_rot_cart\n            h_rot_reduced = reduce_k_vector(h_rot_frac)\n            if np.allclose(h_rot_reduced, h_start, atol=TOL):\n                count += 1\n        return count\n\n    # --- Step 4: Execute Test Cases ---\n    results = []\n\n    # Test Case 1: Number of unique IBZ representatives\n    test_k_vectors_frac = [\n        (0, 0, 0), (0, 0, 0.5), (1/3, 1/3, 0), (1/3, 1/3, 0.5), (0.5, 0, 0),\n        (0.25, 0.25, 0.1), (-0.44, 0.22, -0.49), (0.17, -0.21, 0.3),\n        (0.12, 0.07, 0.5), (0.11, -0.11, -0.5), (-1/3, -1/3, 0), (0.5, -0.5, 0)\n    ]\n    ibz_reps = set()\n    for h_tuple in test_k_vectors_frac:\n        h_frac = np.array(h_tuple)\n        rep = get_ibz_representative(h_frac)\n        # Convert to tuple for hashability in the set\n        ibz_reps.add(tuple(np.round(rep, 8)))\n\n    results.append(len(ibz_reps))\n\n    # Test Case 2: Little co-group order of Gamma point (0,0,0)\n    k_gamma = np.array([0.0, 0.0, 0.0])\n    results.append(get_little_co_group_order(k_gamma))\n\n    # Test Case 3: Little co-group order of H point (1/3, 1/3, 1/2)\n    k_h = np.array([1/3, 1/3, 1/2])\n    results.append(get_little_co_group_order(k_h))\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3491394"}]}