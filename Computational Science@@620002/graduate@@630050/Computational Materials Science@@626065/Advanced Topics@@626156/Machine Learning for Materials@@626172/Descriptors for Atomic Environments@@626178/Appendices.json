{"hands_on_practices": [{"introduction": "Many modern descriptors, such as the Smooth Overlap of Atomic Positions (SOAP), rely on expanding the local atomic density in a basis set. The construction of the radial part of this basis is a critical first step. This practice focuses on building a set of orthonormal radial basis functions, emphasizing the use of the Modified Gram-Schmidt procedure and the physically-motivated inner product that includes an $r^2$ weighting term arising from the volume element in spherical coordinates [@problem_id:3443968]. Mastering this foundational technique is essential for correctly implementing and customizing a wide range of advanced atom-centered descriptors.", "problem": "You are tasked with constructing and orthonormalizing a radial basis suitable for Smooth Overlap of Atomic Positions (SOAP) and related Atom-Centered Symmetry Functions (ACSF) descriptors in computational materials science. The radial component of the three-dimensional spherical integration introduces a natural weight, and a smooth cutoff function is required for finite support and differentiability at a cutoff radius. The problem is to build a finite set of basis functions, orthonormalize them under the physically motivated inner product, and verify their orthonormality numerically.\n\nStart from the following fundamental definitions and requirements:\n- In spherical coordinates, the volume element is $dV = r^2 \\sin(\\theta)\\,dr\\,d\\theta\\,d\\phi$. For purely radial functions $u(r)$ and $v(r)$, the physically motivated inner product on $[0,r_c]$ is\n$$\\langle u, v \\rangle = \\int_{0}^{r_c} r^2\\,u(r)\\,v(r)\\,dr.$$\n- A smooth cutoff function $f_c(r)$ ensures compact support and differentiability of descriptors at $r=r_c$. Use\n$$f_c(r) = \\begin{cases}\n\\frac{1}{2}\\left(\\cos\\left(\\pi \\frac{r}{r_c}\\right) + 1\\right), & 0 \\le r \\le r_c,\\\\\n0, & r > r_c.\n\\end{cases}$$\n- Consider the unnormalized radial basis family\n$$b_n(r) = r^{n-1}\\,e^{-\\alpha r^2}\\,f_c(r), \\quad n=1,2,\\ldots,n_{\\max},$$\nwhere $\\alpha>0$ is a decay parameter and $n_{\\max}\\in\\mathbb{N}$ controls the number of basis functions.\n- Construct an orthonormal set $\\{\\psi_n(r)\\}_{n=1}^{n_{\\max}}$ from $\\{b_n(r)\\}$ using the Modified Gram–Schmidt procedure with respect to the inner product $\\langle\\cdot,\\cdot\\rangle$ defined above, so that\n$$\\langle \\psi_i, \\psi_j \\rangle = \\delta_{ij}.$$\n\nNumerical implementation requirements:\n- Treat the radial coordinate $r$ as dimensionless. All outputs are dimensionless floats.\n- Approximate integrals using the composite Simpson rule on a uniform grid of $N$ points over $[0,r_c]$, where $N$ is odd so that the number of subintervals $N-1$ is even. Let the grid spacing be $\\Delta r = r_c/(N-1)$, and the grid be $r_k = k\\,\\Delta r$ for $k=0,1,\\ldots,N-1$.\n- Implement the Modified Gram–Schmidt orthonormalization numerically with the inner product\n$$\\langle u, v \\rangle \\approx \\int_{0}^{r_c} r^2\\,u(r)\\,v(r)\\,dr,$$\nevaluated by Simpson’s rule on the discrete grid.\n\nVerification metric:\n- After orthonormalization, compute the overlap matrix $S$ with entries $S_{ij} = \\langle \\psi_i, \\psi_j \\rangle$. From $S$, compute two error metrics:\n    1. The maximum diagonal deviation $$E_{\\mathrm{diag}} = \\max_{i} \\left| S_{ii} - 1 \\right|$$.\n    2. The maximum off-diagonal magnitude $$E_{\\mathrm{off}} = \\max_{i\\ne j} \\left| S_{ij} \\right|$$.\n- For each test case, output the pair $[E_{\\mathrm{diag}}, E_{\\mathrm{off}}]$.\n\nTest suite:\nEvaluate your implementation on the following parameter sets. All quantities are dimensionless.\n1. Case A (happy path): $n_{\\max} = 4$, $\\alpha = 1.0$, $r_c = 5.0$, $N = 2001$.\n2. Case B (broad functions): $n_{\\max} = 6$, $\\alpha = 0.1$, $r_c = 6.0$, $N = 2001$.\n3. Case C (narrow functions): $n_{\\max} = 3$, $\\alpha = 3.0$, $r_c = 3.0$, $N = 1001$.\n4. Case D (coarse integration grid boundary test): $n_{\\max} = 5$, $\\alpha = 0.5$, $r_c = 5.0$, $N = 301$.\n5. Case E (many functions in short range): $n_{\\max} = 8$, $\\alpha = 2.0$, $r_c = 2.5$, $N = 2001$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to one test case and is itself a two-element list of floats $[E_{\\mathrm{diag}},E_{\\mathrm{off}}]$. For example: $[[e_{1,\\mathrm{diag}},e_{1,\\mathrm{off}}],[e_{2,\\mathrm{diag}},e_{2,\\mathrm{off}}],\\ldots]$.", "solution": "The problem requires the construction and numerical verification of an orthonormal radial basis set, a common task in the development of atom-centered descriptors for computational materials science, such as the Smooth Overlap of Atomic Positions (SOAP) formalism. The solution involves implementing a numerical orthonormalization procedure for a given family of functions with respect to a non-standard inner product. The methodology proceeds in five principal steps: 1) discretization of the radial coordinate, 2) implementation of the weighted inner product via numerical integration, 3) generation of the initial non-orthogonal basis functions, 4) application of the Modified Gram-Schmidt algorithm to obtain an orthonormal basis, and 5) verification of the result by computing the overlap matrix and its deviation from the identity matrix.\n\nFirst, we represent the continuous radial functions on a discrete grid. For a given cutoff radius $r_c$ and number of points $N$, we define a uniform grid $r_k = k \\cdot \\Delta r$ for $k=0, 1, \\ldots, N-1$, where the grid spacing is $\\Delta r = r_c / (N-1)$. A function $u(r)$ is thus represented by a vector of its values $[u(r_0), u(r_1), \\ldots, u(r_{N-1})]$ on this grid.\n\nSecond, the specified inner product for two radial functions $u(r)$ and $v(r)$ is given by $\\langle u, v \\rangle = \\int_{0}^{r_c} r^2\\,u(r)\\,v(r)\\,dr$. The term $r^2$ arises from the Jacobian of the transformation from Cartesian to spherical coordinates, representing the volume of a spherical shell. We approximate this integral numerically using the composite Simpson's rule, which is well-suited for smooth integrands on a uniform grid. Given the vectors representing $u(r)$ and $v(r)$ on the grid, we first form a vector for the integrand $I(r_k) = r_k^2 u(r_k) v(r_k)$, and then apply the Simpson's rule integration routine over the grid points $\\{r_k\\}$ to compute the value of the integral.\n\nThird, we generate the initial set of basis functions, $\\{b_n(r)\\}_{n=1}^{n_{\\max}}$. The family is defined as\n$$b_n(r) = r^{n-1}\\,e^{-\\alpha r^2}\\,f_c(r),$$\nwhere $n=1,2,\\ldots,n_{\\max}$. Each function is a product of three components: a polynomial term $r^{n-1}$, a Gaussian decay term $e^{-\\alpha r^2}$ controlled by the parameter $\\alpha > 0$, and a smooth cosine-based cutoff function $f_c(r)$. The cutoff function,\n$$f_c(r) = \\frac{1}{2}\\left(\\cos\\left(\\pi \\frac{r}{r_c}\\right) + 1\\right) \\quad \\text{for } 0 \\le r \\le r_c,$$\nensures that each basis function and its derivative smoothly go to zero at the cutoff radius $r_c$, a critical property for constructing continuously differentiable energy models. For each $n$ from $1$ to $n_{\\max}$, we evaluate $b_n(r)$ on the radial grid to produce a set of $n_{\\max}$ vectors.\n\nFourth, we orthonormalize this basis set using the Modified Gram-Schmidt (MGS) procedure. This iterative algorithm is numerically more stable than the classical Gram-Schmidt method, particularly when the initial vectors are nearly linearly dependent, as can be the case for these basis functions. Let the initial set of vectors (representing the functions $\\{b_n\\}$) be $\\{v_1, v_2, \\ldots, v_{n_{\\max}}\\}$. The MGS algorithm generates the orthonormal set $\\{q_1, q_2, \\ldots, q_{n_{\\max}}\\}$ as follows:\nFor $i = 1, \\ldots, n_{\\max}$:\n1.  Normalize the current vector: $q_i = v_i / \\sqrt{\\langle v_i, v_i \\rangle}$.\n2.  For all subsequent vectors $j = i+1, \\ldots, n_{\\max}$, remove the component parallel to $q_i$: $v_j \\leftarrow v_j - \\langle q_i, v_j \\rangle q_i$.\nThe resulting set of vectors $\\{q_i\\}$ represents the orthonormal basis functions $\\{\\psi_n\\}$.\n\nFifth, to verify the numerical accuracy of the orthonormalization, we compute the $n_{\\max} \\times n_{\\max}$ overlap matrix $S$ with entries $S_{ij} = \\langle \\psi_i, \\psi_j \\rangle$. For a perfectly orthonormal set, this matrix would be the identity matrix, i.e., $S_{ij} = \\delta_{ij}$. We quantify the deviation from this ideal using two metrics:\n1.  The maximum diagonal deviation: $E_{\\mathrm{diag}} = \\max_{i} | S_{ii} - 1 |$.\n2.  The maximum off-diagonal magnitude: $E_{\\mathrm{off}} = \\max_{i \\ne j} | S_{ij} |$.\nThese error metrics measure the quality of the normalization and the mutual orthogonality of the computed basis functions, respectively. The entire procedure is encapsulated in a program that iterates through the provided test cases, calculates these two error metrics for each, and reports the results.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import simpson\n\ndef solve():\n    \"\"\"\n    Constructs and orthonormalizes a radial basis set for atom-centered descriptors,\n    then verifies the orthonormality for several test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case A: n_max, alpha, r_c, N\n        (4, 1.0, 5.0, 2001),\n        # Case B\n        (6, 0.1, 6.0, 2001),\n        # Case C\n        (3, 3.0, 3.0, 1001),\n        # Case D\n        (5, 0.5, 5.0, 301),\n        # Case E\n        (8, 2.0, 2.5, 2001),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        n_max, alpha, r_c, N = case\n\n        # Step 1: Define the radial grid\n        # N must be odd for Simpson's rule with an even number of intervals.\n        if N % 2 == 0:\n            N += 1\n        r_grid = np.linspace(0, r_c, N)\n\n        # Step 2: Define the inner product function\n        def inner_product(u, v, grid):\n            \"\"\"\n            Calculates the inner product <u, v> = integral(r^2 * u(r) * v(r) dr)\n            using Simpson's rule. u and v are vectors of function values on the grid.\n            \"\"\"\n            integrand = (grid**2) * u * v\n            return simpson(integrand, x=grid)\n\n        # Step 3: Generate the initial non-orthogonal basis b_n(r)\n        # Cutoff function f_c(r)\n        fc = 0.5 * (np.cos(np.pi * r_grid / r_c) + 1.0)\n        \n        # Basis functions b_n(r) = r^(n-1) * exp(-alpha * r^2) * f_c(r)\n        basis_b = []\n        for n in range(1, n_max + 1):\n            # Use np.power to handle 0**(1-1) = 0**0 = 1 correctly\n            vec = np.power(r_grid, n - 1) * np.exp(-alpha * r_grid**2) * fc\n            basis_b.append(vec)\n\n        # Step 4: Orthonormalize the basis using Modified Gram-Schmidt (MGS)\n        orthonormal_psi = [None] * n_max\n        temp_basis = list(basis_b) # Work on a copy\n\n        for i in range(n_max):\n            # Normalize the current vector\n            norm_val = np.sqrt(inner_product(temp_basis[i], temp_basis[i], r_grid))\n            \n            # The basis should be linearly independent.\n            # A very small norm indicates a problem.\n            if norm_val < 1e-15:\n                # This should not happen for the given problems, but is good practice.\n                # In a real scenario, one might raise an error or handle it.\n                # For this problem, we assume it's fine.\n                q_i = np.zeros_like(temp_basis[i])\n            else:\n                q_i = temp_basis[i] / norm_val\n            \n            orthonormal_psi[i] = q_i\n            \n            # Orthogonalize all subsequent vectors against the new orthonormal vector q_i\n            for j in range(i + 1, n_max):\n                projection_coeff = inner_product(q_i, temp_basis[j], r_grid)\n                temp_basis[j] = temp_basis[j] - projection_coeff * q_i\n\n        # Step 5: Verify orthonormality by computing the overlap matrix S_ij = <psi_i, psi_j>\n        overlap_matrix = np.zeros((n_max, n_max))\n        for i in range(n_max):\n            for j in range(i, n_max):\n                val = inner_product(orthonormal_psi[i], orthonormal_psi[j], r_grid)\n                overlap_matrix[i, j] = val\n                overlap_matrix[j, i] = val # Matrix is symmetric\n\n        # Step 6: Compute the error metrics\n        # Maximum diagonal deviation from 1\n        diag_elements = np.diag(overlap_matrix)\n        E_diag = np.max(np.abs(diag_elements - 1.0))\n        \n        # Maximum off-diagonal magnitude\n        # Create a copy and set diagonal to a value that won't be picked by max()\n        off_diag_matrix = overlap_matrix.copy()\n        np.fill_diagonal(off_diag_matrix, 0.0) \n        E_off = np.max(np.abs(off_diag_matrix))\n        \n        results.append([E_diag, E_off])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3443968"}, {"introduction": "A powerful descriptor must be sensitive enough to distinguish between structurally different atomic environments, even when they appear similar from a simple radial perspective. Simple pair-distance distributions are often insufficient for this task. This exercise challenges you to design pairs of atomic environments that share identical radial distributions but are structurally distinct, and then determine the minimal angular resolution, represented by the spherical harmonic order $l$, required for a SOAP-like descriptor to tell them apart [@problem_id:3443973]. This practice offers deep insight into the descriptive power of angular information and justifies the inclusion of higher-order correlations in robust structural fingerprints.", "problem": "You are tasked with constructing and analyzing two three-dimensional local atomic environments that have identical pair distributions but are not superimposable by any rigid rotation or reflection. The goal is to determine the minimal angular resolution, expressed as the smallest nonnegative integer $l_{\\max}$, required by a rotationally invariant descriptor based on the Smooth Overlap of Atomic Positions (SOAP) to distinguish the environments. The target descriptor must be built directly from the angular decomposition of the neighbor distribution and must be rotationally invariant at each angular order $l$.\n\nThe fundamental base for this task is the following:\n- The pair distribution around a central atom, denoted by $g(r)$, depends only on the multiset of neighbor distances to the central atom and discards all angular information.\n- The spherical harmonics form an orthonormal basis on the unit sphere, indexed by $(l,m)$ with $l \\in \\{0,1,2,\\dots\\}$ and $m \\in \\{-l,-l+1,\\dots,l\\}$.\n- Rotational invariance is obtained by aggregating the angular mode magnitudes in a way that does not depend on orientation; specifically, summing across $m$ at fixed $l$ yields rotationally invariant quantities.\n\nYou must implement a program that, for each test case provided below, performs the following steps:\n- Construct two local environments around a central atom as finite sets of neighbor vectors. Each neighbor vector is a three-dimensional Cartesian vector indicating the neighbor position relative to the central atom. All angles must be handled in radians.\n- Ensure both environments in the pair have the same pair distribution $g(r)$ by using identical multisets of neighbor radii in each environment, so that only angular information differs.\n- Adopt the zero-width limit of the standard SOAP atomic density (so that each neighbor contributes as a direction point on the unit sphere) and use an orthonormal radial channeling scheme consistent with partitioning the radius into shells. Use piecewise-constant, mutually orthogonal radial channels over the specified shells to separate contributions from different radii; in the single-shell cases, there is exactly one shell. For multi-shell cases, define two shells by a splitting radius as specified.\n- For a chosen nonnegative search limit $L_{\\text{search}}$, compute a rotationally invariant descriptor at each angular order $l \\in \\{0,1,\\dots,L_{\\text{search}}\\}$ by projecting the neighbor directions within each radial shell onto spherical harmonics and aggregating magnitudes across $m$ to form rotationally invariant quantities for each $l$. For multi-shell cases, include cross-channel correlations between shells to form the descriptor at each $l$.\n- Determine the minimal $l_{\\max} \\in \\{0,1,\\dots,L_{\\text{search}}\\}$ at which the two environments’ descriptors differ beyond a fixed numerical tolerance, or return $-1$ if no difference is detected for any $l \\le L_{\\text{search}}$.\n\nYour program must implement the above using:\n- Spherical harmonics evaluated with arguments in radians.\n- A numerical tolerance of $10^{-12}$ to decide equality between descriptors.\n- The search limit $L_{\\text{search}} = 12$.\n\nDesign the environments in the following test suite. In all cases, neighbor radii carry no physical units and are pure numbers, and all angular quantities are in radians.\n\n- Test case $1$ (single shell): Environment $\\mathcal{A}_1$ has $4$ neighbors at radius $1$, positioned at the vertices of a regular tetrahedron inscribed in the unit sphere (use the four directions $(\\pm 1,\\pm 1,\\pm 1)/\\sqrt{3}$ with an even number of minus signs). Environment $\\mathcal{B}_1$ has $4$ neighbors at radius $1$, positioned in the equatorial plane at directions $(1,0,0)$, $(-1,0,0)$, $(0,1,0)$, $(0,-1,0)$. Both have the same $g(r)$ since all neighbor radii are $1$.\n- Test case $2$ (single shell): Environment $\\mathcal{A}_2$ has $6$ neighbors at radius $1$ at directions $(\\pm 1,0,0)$, $(0,\\pm 1,0)$, $(0,0,\\pm 1)$ (an octahedral arrangement). Environment $\\mathcal{B}_2$ has $6$ neighbors at radius $1$ arranged uniformly on the equatorial circle with azimuthal angles $0$, $\\pi/3$, $2\\pi/3$, $\\pi$, $4\\pi/3$, $5\\pi/3$ and polar angle $\\pi/2$. Both have the same $g(r)$ since all neighbor radii are $1$.\n- Test case $3$ (single shell): Environment $\\mathcal{A}_3$ is identical to $\\mathcal{A}_1$. Environment $\\mathcal{B}_3$ is obtained by rotating $\\mathcal{A}_1$ by an angle $0.37$ around the $z$-axis. These two are isomorphic by rotation, so their rotationally invariant descriptors should coincide for all $l$.\n- Test case $4$ (two shells): Environment $\\mathcal{A}_4$ has $5$ neighbors with radii $\\{1,1,1.5,1.5,1.5\\}$. Place the two neighbors at radius $1$ along $(0,0,1)$ and $(0,0,-1)$. Place the three neighbors at radius $1.5$ in the equatorial plane at azimuths $0$, $2\\pi/3$, $4\\pi/3$ with polar angle $\\pi/2$. Environment $\\mathcal{B}_4$ has the same multiset of radii $\\{1,1,1.5,1.5,1.5\\}$, with the two neighbors at radius $1$ also along $(0,0,1)$ and $(0,0,-1)$, but the three neighbors at radius $1.5$ arranged off the equatorial plane at a common polar angle $1.0$ and azimuths $0$, $2\\pi/3$, $4\\pi/3$. Use a two-shell radial scheme with splitting radius $1.25$ so that radius $1$ belongs to the inner shell and radius $1.5$ belongs to the outer shell.\n\nFor each test case, search $l$ from $0$ to $L_{\\text{search}}$ and report the minimal $l_{\\max}$ at which the rotationally invariant descriptor of the two environments differs beyond the tolerance, or $-1$ if no difference is detected within the search. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[\\text{result1},\\text{result2},\\text{result3},\\text{result4}]$), where each entry is an integer in $\\{-1,0,1,\\dots,12\\}$.", "solution": "The problem requires the determination of the minimal angular resolution, denoted by the integer $l_{\\max}$, for a rotationally invariant descriptor to distinguish between pairs of three-dimensional local atomic environments. These environments are constructed to have identical pair distributions but differing higher-order (angular) correlations. The descriptor is based on the Smooth Overlap of Atomic Positions (SOAP) formalism, simplified to the zero-width limit for atomic neighbors.\n\n### Mathematical Framework\nA local atomic environment is defined by a set of neighbor position vectors $\\{\\vec{r}_i\\}$ relative to a central atom. The atomic neighbor density $\\rho(\\vec{r})$ is a sum of Dirac delta functions centered at each neighbor's position:\n$$\n\\rho(\\vec{r}) = \\sum_i \\delta(\\vec{r} - \\vec{r}_i)\n$$\nThis density is expanded in a basis of spherical harmonics $Y_{lm}(\\hat{r})$ for the angular part and a radial basis $g_n(r)$ for the radial part. The problem specifies a simplified radial scheme where neighbors are partitioned into disjoint shells. The expansion coefficients for the density within a specific shell $n$ are given by:\n$$\nc_{nlm} = \\int \\rho(\\vec{r}) g_n(r) Y_{lm}^*(\\hat{r}) d\\vec{r}\n$$\nWith the delta-function density and a partitioning scheme where $g_n(r)$ is effectively an indicator function for shell $n$, this integral simplifies to a sum over the neighbors $\\{i\\}$ belonging to that shell, which we denote by the set $I_n$:\n$$\nc_{nlm} = \\sum_{i \\in I_n} Y_{lm}^*(\\theta_i, \\phi_i)\n$$\nwhere $(\\theta_i, \\phi_i)$ are the polar and azimuthal angles of the neighbor vector $\\vec{r}_i$. The spherical harmonics $Y_{lm}(\\theta, \\phi)$ are evaluated using the standard physics convention, with $\\theta \\in [0, \\pi]$ and $\\phi \\in [0, 2\\pi)$.\n\n### Rotationally Invariant Descriptor\nTo achieve rotational invariance, we construct the power spectrum from the expansion coefficients. For a given angular momentum channel $l$, the power spectrum components are formed by coupling coefficients from two radial shells, $n_1$ and $n_2$, and summing over the magnetic quantum number $m$:\n$$\np_{n_1 n_2 l} = \\sum_{m=-l}^{l} c_{n_1 l m}^* c_{n_2 l m}\n$$\nThese quantities are invariant under rigid rotation of the atomic environment. The collection of these values for a given $l$ constitutes the descriptor at that angular order.\n\n-   **Single-Shell Case**: We have only one shell ($n_1=n_2=1$). The descriptor at order $l$ is the scalar value $p_{11l} = \\sum_{m=-l}^{l} |c_{1lm}|^2$.\n-   **Two-Shell Case**: For two shells ($n \\in \\{1, 2\\}$), the descriptor at order $l$ must include all auto-correlations ($p_{11l}, p_{22l}$) and cross-correlations ($p_{12l}, p_{21l}$). Since $p_{21l} = p_{12l}^*$, the distinct information for a given $l$ is captured by the vector of real numbers $(p_{11l}, p_{22l}, \\text{Re}(p_{12l}), \\text{Im}(p_{12l}))$.\n\n### Algorithm for Finding $l_{\\max}$\nFor each pair of environments, $\\mathcal{A}$ and $\\mathcal{B}$, we search for the smallest non-negative integer $l_{\\max}$ at which their descriptors differ.\n\n1.  For each angular order $l$ from $0$ to $L_{\\text{search}} = 12$:\n    a.  Compute the descriptor vector for environment $\\mathcal{A}$, denoted $D_l^{(\\mathcal{A})}$.\n    b.  Compute the descriptor vector for environment $\\mathcal{B}$, denoted $D_l^{(\\mathcal{B})}$.\n    c.  If the Euclidean distance $\\|D_l^{(\\mathcal{A})} - D_l^{(\\mathcal{B})}\\| > 10^{-12}$, then $l$ is the minimal distinguishing angular order. We set $l_{\\max} = l$ and terminate the search for this pair.\n2.  If the loop completes without finding any difference, the environments are indistinguishable up to $L_{\\text{search}}$. In this case, we set $l_{\\max} = -1$.\n\n### Analysis of Test Cases\n\n-   **Test Case 1**: A regular tetrahedron ($\\mathcal{A}_1$, symmetry group $T_d$) versus a square planar arrangement ($\\mathcal{B}_1$, symmetry $D_{4h}$). Due to its high symmetry, the tetrahedral environment's multipole moments for $l=1$ (dipole) and $l=2$ (quadrupole) are zero. The square planar structure, being less symmetric, possesses a non-zero quadrupole moment. Thus, their power spectra will be $p_{11,2}^{(\\mathcal{A}_1)} = 0$ but $p_{11,2}^{(\\mathcal{B}_1)} \\neq 0$. The expected result is $l_{\\max}=2$.\n\n-   **Test Case 2**: An octahedron ($\\mathcal{A}_2$, symmetry $O_h$) versus a planar regular hexagon ($\\mathcal{B}_2$, symmetry $D_{6h}$). Both structures have inversion symmetry, causing all odd-$l$ components of the power spectrum to vanish. The octahedral geometry is highly symmetric, and its first non-zero multipole moment occurs at $l=4$. The planar hexagon has a non-zero quadrupole moment ($l=2$). Therefore, we expect $p_{11,2}^{(\\mathcal{A}_2)} = 0$ and $p_{11,2}^{(\\mathcal{B}_2)} \\neq 0$, leading to $l_{\\max}=2$.\n\n-   **Test Case 3**: A regular tetrahedron ($\\mathcal{A}_3$) versus the same tetrahedron rotated by $0.37$ radians ($\\mathcal{B}_3$). The descriptor is designed to be rotationally invariant. Thus, the descriptors for $\\mathcal{A}_3$ and $\\mathcal{B}_3$ should be identical for all $l$ within numerical precision. The expected result is $l_{\\max}=-1$.\n\n-   **Test Case 4**: A two-shell environment with $D_{3h}$ symmetry ($\\mathcal{A}_4$) versus one with $C_{3v}$ symmetry ($\\mathcal{B}_4$). The inner shell is identical in both environments. The outer shell of $\\mathcal{A}_4$ consists of three atoms in the equatorial plane, whose vector sum is zero, leading to a zero dipole moment ($c_{2,1,m}^{(\\mathcal{A}_4)}=0$). The outer shell of $\\mathcal{B}_4$ has its three atoms at a polar angle of $1.0$ radian, resulting in a net non-zero vector sum along the $z$-axis. This implies a non-zero dipole moment ($c_{2,1,0}^{(\\mathcal{B}_4)} \\neq 0$). Consequently, the power spectrum term $p_{22,1}$ will be zero for $\\mathcal{A}_4$ but non-zero for $\\mathcal{B}_4$. The environments are expected to be distinguished at $l=1$.", "answer": "```python\n# The complete and runnable Python 3 code.\n# Execution environment: python 3.12, numpy 1.23.5, scipy 1.11.4\nimport numpy as np\nfrom scipy.special import sph_harm\n\ndef cart_to_sph(vecs):\n    \"\"\"Converts Cartesian coordinates to spherical coordinates (r, theta, phi).\"\"\"\n    r = np.linalg.norm(vecs, axis=1)\n    # Handle the case of the origin to avoid division by zero\n    theta = np.zeros_like(r)\n    phi = np.zeros_like(r)\n    non_zero_r_mask = r > 1e-15\n    \n    # Polar angle theta from z-axis\n    theta[non_zero_r_mask] = np.arccos(vecs[non_zero_r_mask, 2] / r[non_zero_r_mask])\n    \n    # Azimuthal angle phi from x-axis in xy-plane\n    phi[non_zero_r_mask] = np.arctan2(vecs[non_zero_r_mask, 1], vecs[non_zero_r_mask, 0])\n    return r, theta, phi\n\ndef compute_descriptors_for_l(env_points_by_shell, l_val, n_shells):\n    \"\"\"\n    Computes the descriptor vector for a single l value.\n    'env_points_by_shell' is a list of (thetas, phis) tuples, one for each shell.\n    \"\"\"\n    # Compute c_nlm coefficients for each shell\n    c_lms_per_shell = []\n    for thetas, phis in env_points_by_shell:\n        c_lm = np.zeros(2 * l_val + 1, dtype=np.complex128)\n        if thetas.size > 0:\n            for m_idx, m_val in enumerate(range(-l_val, l_val + 1)):\n                # scipy.special.sph_harm(m, l, phi, theta)\n                ylm_vals = sph_harm(m_val, l_val, phis, thetas)\n                c_lm[m_idx] = np.sum(np.conj(ylm_vals))\n        c_lms_per_shell.append(c_lm)\n\n    # Compute power spectrum components p_n1n2l\n    if n_shells == 1:\n        c1 = c_lms_per_shell[0]\n        p11l = np.sum(np.conj(c1) * c1).real\n        return np.array([p11l])\n    elif n_shells == 2:\n        c1 = c_lms_per_shell[0]\n        c2 = c_lms_per_shell[1]\n        p11l = np.sum(np.conj(c1) * c1).real\n        p22l = np.sum(np.conj(c2) * c2).real\n        p12l = np.sum(np.conj(c1) * c2)\n        return np.array([p11l, p22l, p12l.real, p12l.imag])\n    return np.array([])\n\ndef find_lmax(env_a_pts, env_b_pts, l_search, n_shells=1, split_radius=None, tol=1e-12):\n    \"\"\"\n    Finds the minimal l_max at which two environments' descriptors differ.\n    \"\"\"\n    \n    # Partition neighbors into shells and get spherical coords\n    def get_spherical_coords_by_shell(points):\n        coords_by_shell = []\n        if n_shells == 1:\n            if points.shape[0] > 0:\n                _, thetas, phis = cart_to_sph(points)\n                coords_by_shell.append((thetas, phis))\n            else:\n                 coords_by_shell.append((np.array([]), np.array([])))\n        elif n_shells == 2:\n            radii = np.linalg.norm(points, axis=1)\n            shell1_pts = points[radii < split_radius]\n            shell2_pts = points[radii >= split_radius]\n            for shell_pts in [shell1_pts, shell2_pts]:\n                if shell_pts.shape[0] > 0:\n                    _, thetas, phis = cart_to_sph(shell_pts)\n                    coords_by_shell.append((thetas, phis))\n                else:\n                    coords_by_shell.append((np.array([]), np.array([])))\n        return coords_by_shell\n\n    sph_coords_a = get_spherical_coords_by_shell(env_a_pts)\n    sph_coords_b = get_spherical_coords_by_shell(env_b_pts)\n\n    for l_val in range(l_search + 1):\n        desc_a = compute_descriptors_for_l(sph_coords_a, l_val, n_shells)\n        desc_b = compute_descriptors_for_l(sph_coords_b, l_val, n_shells)\n        \n        diff = np.linalg.norm(desc_a - desc_b)\n        \n        if diff > tol:\n            return l_val\n    \n    return -1\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, run the analysis, and print results.\n    \"\"\"\n    L_SEARCH = 12\n\n    # Test Case 1: Tetrahedron vs. Square Planar\n    a1_pts = np.array([[1, 1, 1], [1, -1, -1], [-1, 1, -1], [-1, -1, 1]]) / np.sqrt(3)\n    b1_pts = np.array([[1, 0, 0], [-1, 0, 0], [0, 1, 0], [0, -1, 0]], dtype=float)\n\n    # Test Case 2: Octahedron vs. Planar Hexagon\n    a2_pts = np.array([[1,0,0],[-1,0,0],[0,1,0],[0,-1,0],[0,0,1],[0,0,-1]], dtype=float)\n    b2_phis = np.arange(6) * np.pi / 3\n    b2_pts = np.array([[np.cos(phi), np.sin(phi), 0] for phi in b2_phis])\n\n    # Test Case 3: Tetrahedron vs. Rotated Tetrahedron\n    a3_pts = a1_pts.copy()\n    angle = 0.37\n    rot_matrix = np.array([\n        [np.cos(angle), -np.sin(angle), 0],\n        [np.sin(angle),  np.cos(angle), 0],\n        [0, 0, 1]\n    ])\n    b3_pts = a3_pts @ rot_matrix.T\n\n    # Test Case 4: Two-shell D3h vs. C3v-like\n    a4_shell1 = np.array([[0, 0, 1.0], [0, 0, -1.0]]) * 1.0\n    a4_phis = np.arange(3) * 2 * np.pi / 3\n    a4_shell2 = np.array([[np.cos(phi), np.sin(phi), 0] for phi in a4_phis]) * 1.5\n    a4_pts = np.vstack([a4_shell1, a4_shell2])\n    \n    b4_shell1 = np.array([[0, 0, 1.0], [0, 0, -1.0]]) * 1.0\n    b4_theta = 1.0\n    b4_phis = np.arange(3) * 2 * np.pi / 3\n    b4_shell2 = np.array([\n        [np.sin(b4_theta) * np.cos(phi), np.sin(b4_theta) * np.sin(phi), np.cos(b4_theta)]\n        for phi in b4_phis\n    ]) * 1.5\n    b4_pts = np.vstack([b4_shell1, b4_shell2])\n\n    test_cases = [\n        (a1_pts, b1_pts, 1, None),\n        (a2_pts, b2_pts, 1, None),\n        (a3_pts, b3_pts, 1, None),\n        (a4_pts, b4_pts, 2, 1.25)\n    ]\n    \n    results = []\n    for a_pts, b_pts, n_shells, split_radius in test_cases:\n        lmax = find_lmax(a_pts, b_pts, L_SEARCH, n_shells=n_shells, split_radius=split_radius)\n        results.append(lmax)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3443973"}, {"introduction": "When descriptors form the basis of machine-learned interatomic potentials, their analytical properties directly impact the physical realism and numerical stability of molecular dynamics (MD) simulations. A crucial aspect is the continuity of the forces, which are the negative gradient of the potential energy. This practice explores the profound connection between the mathematical smoothness of the cutoff function, $f_c(r)$, and the continuity of the forces it produces [@problem_id:3443993]. By analyzing the descriptor's derivative at the cutoff radius, you will discover why a sufficiently smooth cutoff is not merely an aesthetic choice but a prerequisite for developing stable, energy-conserving potentials for MD.", "problem": "Consider an atom-centered radial descriptor used in machine-learned interatomic potentials, defined as $G(r) = \\phi(r)\\,f_c(r)$, where $r$ is the scalar interatomic distance between a central atom and a neighbor, $\\phi(r)$ is a smooth radial basis, and $f_c(r)$ is a cutoff function that enforces locality by tapering contributions to zero at a finite cutoff distance $r_c$. This construction is standard in Atom-Centered Symmetry Functions (ACSF) and is also analogous to localized kernels used in Smooth Overlap of Atomic Positions (SOAP).\n\nAssume the radial basis is the Gaussian $\\phi(r) = \\exp\\!\\left(-\\eta\\,(r - R_s)^2\\right)$, with parameters $\\eta > 0$ and $R_s \\ge 0$. The cutoff function $f_c(r)$ is chosen from three classes, each of different smoothness at the cutoff $r = r_c$:\n\n1. $C^0$-continuous linear taper:\n   $$ f_c^{(0)}(r) = \\begin{cases} 1 - \\dfrac{r}{r_c}, & 0 \\le r < r_c, \\\\ 0, & r \\ge r_c. \\end{cases} $$\n   This function is continuous with $f_c^{(0)}(r_c)=0$, but its first derivative is discontinuous at $r_c$.\n\n2. $C^1$-continuous cosine taper:\n   $$ f_c^{(1)}(r) = \\begin{cases} \\dfrac{1}{2}\\left[1 + \\cos\\!\\left(\\dfrac{\\pi\\,r}{r_c}\\right)\\right], & 0 \\le r \\le r_c, \\\\ 0, & r \\ge r_c. \\end{cases} $$\n   This function and its first derivative are continuous at $r_c$, with $f_c^{(1)}(r_c)=0$ and $\\dfrac{d}{dr}f_c^{(1)}(r_c)=0$.\n\n3. $C^\\infty$-smooth compactly supported bump:\n   $$ f_c^{(\\infty)}(r) = \\begin{cases} \\exp\\!\\left(-\\dfrac{r^2}{r_c^2 - r^2}\\right), & 0 \\le r < r_c, \\\\ 0, & r \\ge r_c. \\end{cases} $$\n   This function is infinitely differentiable, with $f_c^{(\\infty)}(r_c)=0$ and all derivatives at the cutoff equal to zero from the left; from the right it is identically zero.\n\nStarting from the basic rules of single-variable calculus (including the product rule and chain rule), derive analytic expressions for the left and right limits of the radial derivative $\\dfrac{\\partial G}{\\partial r}$ at $r=r_c$ for each choice of $f_c(r) \\in \\{f_c^{(0)}, f_c^{(1)}, f_c^{(\\infty)}\\}$. Explicitly quantify the discontinuity in the derivative by the jump magnitude\n$$\\Delta\\left(\\frac{\\partial G}{\\partial r}\\right)\\Big|_{r_c} \\equiv \\left|\\lim_{r \\to r_c^-} \\frac{\\partial G}{\\partial r} - \\lim_{r \\to r_c^+} \\frac{\\partial G}{\\partial r}\\right|.$$\n\nTo connect the derivative discontinuity to Molecular Dynamics (MD) stability, consider a simple energy mapping $E(G) = a\\,G$ with a constant coefficient $a$ (set $a=1$ for normalization). The radial force projection is $F_r = -\\dfrac{\\partial E}{\\partial r} = -\\dfrac{\\partial G}{\\partial r}$. Use the jump magnitude in $\\dfrac{\\partial G}{\\partial r}$ as a force-noise proxy at $r_c$, and define a stability criterion: the MD is deemed stable for a given cutoff choice if $\\Delta\\!\\left(\\dfrac{\\partial G}{\\partial r}\\right)\\big|_{r_c} \\le T$, where $T$ is a prescribed threshold provided per test case.\n\nYour program must implement these derivations and compute, for each provided test case, the jump magnitudes for all three cutoff classes and the corresponding stability booleans under the given threshold. All quantities are dimensionless in this problem.\n\nTest suite parameters are tuples $(\\eta, R_s, r_c, T)$:\n\n- Case 1 (general, nontrivial overlap near cutoff): $(\\eta=2.0, R_s=4.5, r_c=5.0, T=0.05)$.\n- Case 2 (basis center far from cutoff, strong decay): $(\\eta=10.0, R_s=0.0, r_c=5.0, T=10^{-8})$.\n- Case 3 (basis centered at cutoff, small $r_c$): $(\\eta=0.5, R_s=1.0, r_c=1.0, T=0.5)$.\n- Case 4 (basis centered at cutoff, larger $r_c$): $(\\eta=1.0, R_s=8.0, r_c=8.0, T=0.2)$.\n\nFinal output format requirement: Your program should produce a single line of output containing a list of lists, where each inner list corresponds to one test case and is ordered as\n$$[\\Delta_0,\\ \\Delta_1,\\ \\Delta_\\infty,\\ \\text{stable}_0,\\ \\text{stable}_1,\\ \\text{stable}_\\infty]$$\nwith $\\Delta_0$, $\\Delta_1$, $\\Delta_\\infty$ being the jump magnitudes for $f_c^{(0)}$, $f_c^{(1)}$, $f_c^{(\\infty)}$, respectively, and $\\text{stable}_\\ast$ being boolean values satisfying the criterion with the given $T$. The printed single line must have the exact Python list formatting, for example:\n$$[[0.1,0.0,0.0,False,True,True],[\\dots]].$$", "solution": "The problem requires the derivation and calculation of the discontinuity in the first derivative of a radial descriptor function, $G(r)$, at a cutoff radius $r_c$. This discontinuity is used to assess the numerical stability of a corresponding simplified force model in a molecular dynamics simulation.\n\nThe radial descriptor is given by the product $G(r) = \\phi(r) f_c(r)$, where the radial basis is a Gaussian function $\\phi(r) = \\exp(-\\eta(r - R_s)^2)$ and $f_c(r)$ is one of three specified cutoff functions.\n\nFirst, we derive the general expression for the derivative of $G(r)$ with respect to the interatomic distance $r$. Using the product rule for differentiation, we have:\n$$ \\frac{\\partial G}{\\partial r} = \\frac{\\partial}{\\partial r} \\left[ \\phi(r) f_c(r) \\right] = \\frac{\\partial \\phi}{\\partial r} f_c(r) + \\phi(r) \\frac{\\partial f_c}{\\partial r} $$\nThe derivative of the Gaussian basis function $\\phi(r)$ is found using the chain rule:\n$$ \\frac{\\partial \\phi}{\\partial r} = \\frac{d}{dr} \\left( -\\eta(r-R_s)^2 \\right) \\cdot \\exp\\!\\left(-\\eta(r - R_s)^2\\right) = -2\\eta(r-R_s) \\exp\\!\\left(-\\eta(r - R_s)^2\\right) $$\nLet's denote $\\phi'(r) \\equiv \\frac{\\partial \\phi}{\\partial r}$ and $f_c'(r) \\equiv \\frac{\\partial f_c}{\\partial r}$. The derivative of the descriptor is then:\n$$ \\frac{\\partial G}{\\partial r} = \\phi'(r) f_c(r) + \\phi(r) f_c'(r) $$\nThe discontinuity, or jump magnitude, in this derivative at $r=r_c$ is defined as:\n$$ \\Delta\\left(\\dfrac{\\partial G}{\\partial r}\\right)\\Big|_{r_c} = \\left|\\lim_{r \\to r_c^-} \\dfrac{\\partial G}{\\partial r} - \\lim_{r \\to r_c^+} \\dfrac{\\partial G}{\\partial r}\\right| $$\nWe must evaluate the left and right-hand limits for each case.\n\nFor all three cutoff functions, $f_c(r) = 0$ for $r \\ge r_c$. This implies that for $r > r_c$, $f_c(r)$ is a constant function, and its derivative $f_c'(r)$ is also $0$. Consequently, for $r > r_c$, the descriptor $G(r) = \\phi(r) \\cdot 0 = 0$, and its derivative $\\frac{\\partial G}{\\partial r}$ is also $0$. Therefore, the right-hand limit is universally zero:\n$$ \\lim_{r \\to r_c^+} \\dfrac{\\partial G}{\\partial r} = \\lim_{r \\to r_c^+} 0 = 0 $$\nThe jump magnitude simplifies to the absolute value of the left-hand limit:\n$$ \\Delta\\left(\\dfrac{\\partial G}{\\partial r}\\right)\\Big|_{r_c} = \\left|\\lim_{r \\to r_c^-} \\dfrac{\\partial G}{\\partial r}\\right| $$\nWe now proceed to compute this limit for each of the three cutoff functions.\n\n1.  **$C^0$-continuous linear taper, $f_c^{(0)}(r)$**:\n    For $0 \\le r < r_c$, we have $f_c^{(0)}(r) = 1 - \\frac{r}{r_c}$ and its derivative is $f_c^{(0)'}(r) = -\\frac{1}{r_c}$.\n    The derivative of the descriptor for $r < r_c$ is:\n    $$ \\frac{\\partial G^{(0)}}{\\partial r} = \\phi'(r) \\left(1 - \\frac{r}{r_c}\\right) + \\phi(r) \\left(-\\frac{1}{r_c}\\right) $$\n    We take the limit as $r \\to r_c^-$. Since $\\phi(r)$ and $\\phi'(r)$ are continuous functions, we can substitute $r=r_c$:\n    $$ \\lim_{r \\to r_c^-} \\frac{\\partial G^{(0)}}{\\partial r} = \\phi'(r_c) \\left(1 - \\frac{r_c}{r_c}\\right) - \\frac{\\phi(r_c)}{r_c} = \\phi'(r_c) \\cdot 0 - \\frac{\\phi(r_c)}{r_c} = -\\frac{\\phi(r_c)}{r_c} $$\n    The jump magnitude, $\\Delta_0$, is:\n    $$ \\Delta_0 = \\left|-\\frac{\\phi(r_c)}{r_c}\\right| = \\frac{\\phi(r_c)}{r_c} = \\frac{\\exp(-\\eta(r_c-R_s)^2)}{r_c} $$\n    The derivative is discontinuous because although $\\lim_{r \\to r_c^-} f_c^{(0)}(r) = 0$, its derivative $\\lim_{r \\to r_c^-} f_c^{(0)'}(r) = -1/r_c$ is non-zero, creating a discontinuity in the second term of the product rule expansion.\n\n2.  **$C^1$-continuous cosine taper, $f_c^{(1)}(r)$**:\n    For $0 \\le r \\le r_c$, we have $f_c^{(1)}(r) = \\frac{1}{2}\\left[1 + \\cos\\left(\\frac{\\pi r}{r_c}\\right)\\right]$. Its derivative is $f_c^{(1)'}(r) = -\\frac{\\pi}{2r_c}\\sin\\left(\\frac{\\pi r}{r_c}\\right)$.\n    The derivative of the descriptor for $r \\le r_c$ is:\n    $$ \\frac{\\partial G^{(1)}}{\\partial r} = \\phi'(r) \\cdot \\frac{1}{2}\\left[1 + \\cos\\left(\\frac{\\pi r}{r_c}\\right)\\right] - \\phi(r) \\cdot \\frac{\\pi}{2r_c}\\sin\\left(\\frac{\\pi r}{r_c}\\right) $$\n    Taking the limit as $r \\to r_c^-$:\n    $$ \\lim_{r \\to r_c^-} \\frac{\\partial G^{(1)}}{\\partial r} = \\phi'(r_c) \\cdot \\frac{1}{2}\\left[1 + \\cos(\\pi)\\right] - \\phi(r_c) \\cdot \\frac{\\pi}{2r_c}\\sin(\\pi) $$\n    $$ = \\phi'(r_c) \\cdot \\frac{1}{2}\\left[1 - 1\\right] - \\phi(r_c) \\cdot \\frac{\\pi}{2r_c} \\cdot 0 = \\phi'(r_c) \\cdot 0 - \\phi(r_c) \\cdot 0 = 0 $$\n    The jump magnitude, $\\Delta_1$, is:\n    $$ \\Delta_1 = |0 - 0| = 0 $$\n    The derivative is continuous, as expected for a product of a smooth function $\\phi(r)$ and a $C^1$-continuous function $f_c^{(1)}(r)$ where both the function and its first derivative vanish at $r_c$.\n\n3.  **$C^\\infty$-smooth compactly supported bump, $f_c^{(\\infty)}(r)$**:\n    For $0 \\le r < r_c$, $f_c^{(\\infty)}(r) = \\exp\\left(-\\frac{r^2}{r_c^2 - r^2}\\right)$. This function is constructed to be infinitely differentiable on its domain and to have all derivatives equal to zero at $r=r_c$ from the left.\n    Let's confirm this for the first derivative. For $r < r_c$, $f_c^{(\\infty)'}(r) =  f_c^{(\\infty)}(r) \\left( -\\frac{2rr_c^2}{(r_c^2 - r^2)^2} \\right)$.\n    The limit of this expression as $r \\to r_c^-$ is dominated by the exponential term, which goes to zero faster than any polynomial term diverges. Thus, $\\lim_{r \\to r_c^-} f_c^{(\\infty)}(r) = 0$ and $\\lim_{r \\to r_c^-} f_c^{(\\infty)'}(r) = 0$.\n    The derivative of the descriptor for $r < r_c$ is:\n    $$ \\frac{\\partial G^{(\\infty)}}{\\partial r} = \\phi'(r) f_c^{(\\infty)}(r) + \\phi(r) f_c^{(\\infty)'}(r) $$\n    Taking the limit as $r \\to r_c^-$:\n    $$ \\lim_{r \\to r_c^-} \\frac{\\partial G^{(\\infty)}}{\\partial r} = \\phi'(r_c) \\cdot \\lim_{r \\to r_c^-} f_c^{(\\infty)}(r) + \\phi(r_c) \\cdot \\lim_{r \\to r_c^-} f_c^{(\\infty)'}(r) $$\n    $$ = \\phi'(r_c) \\cdot 0 + \\phi(r_c) \\cdot 0 = 0 $$\n    The jump magnitude, $\\Delta_\\infty$, is:\n    $$ \\Delta_\\infty = |0 - 0| = 0 $$\n    The derivative is continuous, as expected for a product involving a $C^\\infty$ function.\n\nIn summary, the formulas for the jump magnitudes are:\n-   $\\Delta_0 = \\frac{1}{r_c} \\exp(-\\eta(r_c-R_s)^2)$\n-   $\\Delta_1 = 0$\n-   $\\Delta_\\infty = 0$\n\nThe stability criterion for each cutoff choice is determined by comparing its jump magnitude to the threshold $T$. The simulation is stable if $\\Delta \\le T$. For the $C^1$ and $C^\\infty$ cutoffs, the jump is always zero, so they will always satisfy the stability criterion for any non-negative threshold $T$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the derivative discontinuity for different cutoff functions\n    and assesses the stability for several test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (eta, Rs, rc, T)\n    test_cases = [\n        (2.0, 4.5, 5.0, 0.05),\n        (10.0, 0.0, 5.0, 1e-8),\n        (0.5, 1.0, 1.0, 0.5),\n        (1.0, 8.0, 8.0, 0.2),\n    ]\n\n    results = []\n    for case in test_cases:\n        eta, Rs, rc, T = case\n\n        # --- Calculate jump magnitudes ---\n\n        # Case 0: C^0-continuous linear taper\n        # Formula: Delta_0 = exp(-eta * (rc - Rs)^2) / rc\n        phi_rc = np.exp(-eta * (rc - Rs)**2)\n        delta_0 = phi_rc / rc\n        \n        # Case 1: C^1-continuous cosine taper\n        # Formula: Delta_1 = 0\n        delta_1 = 0.0\n        \n        # Case 2: C^infinity-smooth bump function\n        # Formula: Delta_inf = 0\n        delta_inf = 0.0\n\n        # --- Apply stability criterion ---\n        # Stability is True if Delta <= T\n        stable_0 = delta_0 <= T\n        stable_1 = delta_1 <= T\n        stable_inf = delta_inf <= T\n\n        # Append the list of results for this case\n        case_result = [delta_0, delta_1, delta_inf, stable_0, stable_1, stable_inf]\n        results.append(case_result)\n\n    # --- Format the final output string ---\n    # The output format must exactly match \"[[val,val,...],[val,val,...]]\"\n    # with no spaces after commas. Python's default str() on lists adds spaces,\n    # so we manually construct the string to meet the requirement.\n    \n    # Collect string representations of each inner list\n    output_parts = []\n    for res_list in results:\n        # res_list contains: [float, float, float, bool, bool, bool]\n        # Convert each element to its string representation\n        # Note: str(True) is \"True\", str(False) is \"False\"\n        list_items_as_strings = [\n            f\"{res_list[0]}\",\n            f\"{res_list[1]}\",\n            f\"{res_list[2]}\",\n            str(res_list[3]),\n            str(res_list[4]),\n            str(res_list[5]),\n        ]\n        \n        # Join items with comma and wrap in brackets for this case\n        inner_list_str = f\"[{','.join(list_items_as_strings)}]\"\n        output_parts.append(inner_list_str)\n\n    # Join the string representations of all cases with a comma\n    # and wrap in outer brackets to form the final string\n    final_output_string = f\"[{','.join(output_parts)}]\"\n\n    print(final_output_string)\n\nsolve()\n```", "id": "3443993"}]}