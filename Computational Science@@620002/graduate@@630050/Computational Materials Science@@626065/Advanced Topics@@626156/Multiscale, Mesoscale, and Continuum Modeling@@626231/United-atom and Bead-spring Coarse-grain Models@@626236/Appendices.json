{"hands_on_practices": [{"introduction": "Before attempting to fit a coarse-grained potential to reference data, a fundamental question must be answered: can the model's parameters be uniquely determined from the data? This exercise introduces local sensitivity analysis as a rigorous method to probe this question. By calculating how an observable—in this case, the radial distribution function—changes with respect to each model parameter, you will learn to identify cases of \"structural unidentifiability,\" where the model is over-parameterized for the given data, a critical concept in robust model development [@problem_id:3500725].", "problem": "You are given a coarse-grained United-Atom (UA) model for a simple fluid, where the nonbonded interaction is represented by a Lennard–Jones pair potential truncated at a finite cutoff without shifting. In the zero-density approximation of classical liquid-state theory, the radial distribution function (RDF) $g(r)$ is related to the pair potential $u(r)$ via the Boltzmann factor. Your task is to perform a local sensitivity analysis of $g(r)$ with respect to the model parameters and to determine which parameters are structurally unidentifiable given specific data. Work entirely in reduced Lennard–Jones units and treat all computations as dimensionless.\n\nFundamental base:\n- The zero-density relation between the radial distribution function and the pair potential is $g(r) = \\exp(-\\beta\\,u(r))$, where $\\beta = 1/(k_{\\mathrm{B}} T)$ is the inverse thermal energy, $k_{\\mathrm{B}}$ is the Boltzmann constant, and $T$ is the absolute temperature.\n- The truncated (not shifted) Lennard–Jones potential is\n$$\nu(r;\\,\\varepsilon,\\sigma,r_{\\mathrm{c}}) =\n\\begin{cases}\n4\\,\\varepsilon\\left[\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^{6}\\right],  \\text{if } r  r_{\\mathrm{c}} \\\\\n0,  \\text{if } r \\ge r_{\\mathrm{c}}\n\\end{cases}\n$$\nwith parameters $\\theta = (\\varepsilon,\\sigma)$ representing the energy scale $\\varepsilon$ and the length scale $\\sigma$, and cutoff $r_{\\mathrm{c}}$.\n- Local sensitivities of $g(r)$ with respect to parameters $\\theta_k$ are defined as the partial derivatives $\\frac{\\partial g(r)}{\\partial \\theta_k}$ evaluated at specified $(\\varepsilon,\\sigma,\\beta,r_{\\mathrm{c}})$ and $r$ values.\n\nDesign a program that, for each provided test case:\n1. Computes the local sensitivity matrix $J \\in \\mathbb{R}^{N_r \\times N_\\theta}$ with entries $J_{ik} = \\left.\\frac{\\partial g(r_i)}{\\partial \\theta_k}\\right|_{\\theta}$ for $N_r$ supplied radial separations $\\{r_i\\}$ and $N_\\theta = 2$ parameters $\\theta = (\\varepsilon,\\sigma)$.\n2. Assesses local structural identifiability of parameters by testing the column rank of $J$. A parameter is structurally unidentifiable given the data if its sensitivity column lies in the linear span of the other columns, implying loss of unique local estimability. You must use a numerically stable rank-revealing method to determine the numerical rank and a column subset that spans the column space.\n3. Returns, for each test case, the list of zero-based indices of structurally unidentifiable parameters in increasing order. Use the convention that the parameter ordering is $\\theta_0 = \\varepsilon$ and $\\theta_1 = \\sigma$.\n\nImplementation requirements:\n- Use the fundamental base only. Derive the expressions for $\\frac{\\partial g(r)}{\\partial \\varepsilon}$ and $\\frac{\\partial g(r)}{\\partial \\sigma}$ from the definitions above, using standard calculus (e.g., the chain rule) where needed.\n- Treat all lengths $r$, $\\sigma$, and $r_{\\mathrm{c}}$ in reduced units of $\\sigma$, and treat the energy scale $\\varepsilon$ as the reduced energy unit. Work with specified dimensionless values of $\\beta$ as provided for each test case. The outputs are pure indices and therefore unitless.\n- For the rank assessment, use a robust numerical tolerance. Determine the numerical rank via singular values, using a relative threshold that scales with the largest singular value and machine precision. To attribute unidentifiability to specific parameters, use a rank-revealing column permutation and report those columns outside a maximal independent set as unidentifiable.\n\nTest suite:\nFor each test case below, the model parameters are $(\\varepsilon,\\sigma)$, the inverse thermal energy is $\\beta$, the cutoff is $r_{\\mathrm{c}}$, and the measured pair separations are the list of $r$ values. All numbers are in reduced, dimensionless units.\n- Test case $1$ (general coverage, within-cutoff data):\n  - $(\\varepsilon,\\sigma) = (1.0, 1.0)$, $\\beta = 1.0$, $r_{\\mathrm{c}} = 2.5$, $r = [0.95, 1.00, 1.10, 1.50, 2.00, 2.49]$.\n- Test case $2$ (boundary condition, all data beyond cutoff):\n  - $(\\varepsilon,\\sigma) = (1.0, 1.0)$, $\\beta = 1.0$, $r_{\\mathrm{c}} = 2.5$, $r = [2.60, 3.00]$.\n- Test case $3$ (edge case, single point at $r = \\sigma$):\n  - $(\\varepsilon,\\sigma) = (1.0, 1.0)$, $\\beta = 1.0$, $r_{\\mathrm{c}} = 2.5$, $r = [1.00]$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to one test case and is itself a list of integers giving the unidentifiable parameter indices in increasing order. For example, a valid overall output with three test cases looks like\n`[[],[0,1],[0]]`,\nmeaning that in the first case no parameters are unidentifiable, in the second case both parameters are unidentifiable, and in the third case only parameter index $0$ is unidentifiable.\n\nYour output must exactly match this structure for the provided test suite.", "solution": "The problem statement is scientifically grounded, well-posed, and objective. It presents a standard task in computational modeling: local sensitivity and identifiability analysis. All necessary physical relations, mathematical definitions, and numerical data are provided and are internally consistent. The problem is valid and a solution can be duly constructed.\n\nThe core of the problem is to assess the local structural identifiability of the Lennard-Jones parameters $\\theta = (\\varepsilon, \\sigma)$ by analyzing the sensitivity of an observable, the radial distribution function $g(r)$, to changes in these parameters.\n\nFirst, we establish the analytical form of the sensitivities. The observable $g(r)$ is related to the pair potential $u(r)$ at a given inverse temperature $\\beta = 1/(k_{\\mathrm{B}} T)$ by the zero-density approximation:\n$$\ng(r) = \\exp(-\\beta\\,u(r))\n$$\nThe truncated Lennard-Jones (LJ) potential is given by:\n$$\nu(r; \\varepsilon, \\sigma, r_{\\mathrm{c}}) =\n\\begin{cases}\n4\\,\\varepsilon\\left[\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^{6}\\right],  \\text{if } r  r_{\\mathrm{c}} \\\\\n0,  \\text{if } r \\ge r_{\\mathrm{c}}\n\\end{cases}\n$$\nThe parameters for sensitivity analysis are $\\theta_0 = \\varepsilon$ and $\\theta_1 = \\sigma$. The local sensitivity of $g(r)$ with respect to a parameter $\\theta_k$ is its partial derivative, $\\frac{\\partial g(r)}{\\partial \\theta_k}$. Using the chain rule, we have:\n$$\n\\frac{\\partial g(r)}{\\partial \\theta_k} = \\frac{\\partial}{\\partial \\theta_k} \\exp(-\\beta\\,u(r)) = \\exp(-\\beta\\,u(r)) \\cdot (-\\beta) \\frac{\\partial u(r)}{\\partial \\theta_k} = -\\beta\\,g(r)\\,\\frac{\\partial u(r)}{\\partial \\theta_k}\n$$\nWe must now derive the partial derivatives of the potential $u(r)$ with respect to $\\varepsilon$ and $\\sigma$.\n\nFor $r \\ge r_{\\mathrm{c}}$, $u(r)=0$ and is independent of $\\varepsilon$ and $\\sigma$. Thus, for $r \\ge r_{\\mathrm{c}}$:\n$$\n\\frac{\\partial u(r)}{\\partial \\varepsilon} = 0 \\quad \\text{and} \\quad \\frac{\\partial u(r)}{\\partial \\sigma} = 0\n$$\nThis implies that $\\frac{\\partial g(r)}{\\partial \\varepsilon} = 0$ and $\\frac{\\partial g(r)}{\\partial \\sigma} = 0$ for $r \\ge r_{\\mathrm{c}}$.\n\nFor $r  r_{\\mathrm{c}}$, we compute the derivatives of the LJ expression.\nThe sensitivity with respect to the energy parameter $\\varepsilon$ is:\n$$\n\\frac{\\partial u(r)}{\\partial \\varepsilon} = \\frac{\\partial}{\\partial \\varepsilon} \\left( 4\\,\\varepsilon\\left[\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^{6}\\right] \\right) = 4\\left[\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^{6}\\right] = \\frac{u(r)}{\\varepsilon}\n$$\nThe sensitivity of $g(r)$ with respect to $\\varepsilon$ is therefore:\n$$\n\\frac{\\partial g(r)}{\\partial \\varepsilon} = -\\beta\\,g(r) \\frac{u(r)}{\\varepsilon}\n$$\nThe sensitivity with respect to the length parameter $\\sigma$ is:\n$$\n\\frac{\\partial u(r)}{\\partial \\sigma} = \\frac{\\partial}{\\partial \\sigma} \\left( 4\\,\\varepsilon\\left[ \\sigma^{12}r^{-12} - \\sigma^{6}r^{-6} \\right] \\right) = 4\\,\\varepsilon \\left[ 12\\sigma^{11}r^{-12} - 6\\sigma^{5}r^{-6} \\right]\n$$\nThis can be rewritten by factoring out terms involving $\\sigma$:\n$$\n\\frac{\\partial u(r)}{\\partial \\sigma} = 4\\,\\varepsilon \\frac{6}{\\sigma} \\left[ 2\\frac{\\sigma^{12}}{r^{12}} - \\frac{\\sigma^{6}}{r^{6}} \\right] = \\frac{24\\varepsilon}{\\sigma}\\left[2\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^{6}\\right]\n$$\nThe sensitivity of $g(r)$ with respect to $\\sigma$ is therefore:\n$$\n\\frac{\\partial g(r)}{\\partial \\sigma} = -\\beta\\,g(r) \\left( \\frac{24\\varepsilon}{\\sigma}\\left[2\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^{6}\\right] \\right)\n$$\nThe sensitivity matrix (or Jacobian) $J$ is an $N_r \\times 2$ matrix, where $N_r$ is the number of radial data points. Its columns are the sensitivity vectors for $\\varepsilon$ and $\\sigma$, evaluated at each point $r_i$:\n$$\nJ = \\begin{pmatrix}\n\\frac{\\partial g(r_1)}{\\partial \\varepsilon}  \\frac{\\partial g(r_1)}{\\partial \\sigma} \\\\\n\\frac{\\partial g(r_2)}{\\partial \\varepsilon}  \\frac{\\partial g(r_2)}{\\partial \\sigma} \\\\\n\\vdots  \\vdots \\\\\n\\frac{\\partial g(r_{N_r})}{\\partial \\varepsilon}  \\frac{\\partial g(r_{N_r})}{\\partial \\sigma}\n\\end{pmatrix}\n$$\nLocal structural unidentifiability occurs when the parameters cannot be uniquely determined from a local analysis of the available data. Mathematically, this corresponds to linear dependence among the columns of the sensitivity matrix $J$. If the columns are linearly dependent, the rank of $J$ is less than the number of parameters, $\\text{rank}(J)  N_\\theta = 2$.\n\nTo assess this, we employ a rank-revealing QR decomposition with column pivoting, a numerically robust method. This decomposition factors $J$ as $J P = Q R$, where $P$ is a permutation matrix (represented by a vector of column indices $p$), $Q$ is an orthogonal matrix, and $R$ is an upper trapezoidal matrix whose diagonal elements $|R_{kk}|$ are non-increasing. The permutation $p$ rearranges the columns of $J$ to bring the most linearly independent columns to the front.\n\nThe numerical rank, $k$, is the number of diagonal elements of $R$ that are significantly greater than zero. A standard tolerance $\\tau$ for this check is scaled by the magnitude of the largest diagonal element and machine precision: $\\tau = |R_{00}| \\cdot \\max(N_r, N_\\theta) \\cdot \\epsilon_{\\text{machine}}$. The rank is the count of $|R_{ii}| > \\tau$.\n\nThe permutation vector $p$ directly informs identifiability. The first $k$ indices in $p$, i.e., $p[0], \\dots, p[k-1]$, correspond to the parameters that form a maximal linearly independent set. The remaining $N_\\theta - k$ indices, $p[k], \\dots, p[N_\\theta-1]$, correspond to parameters whose sensitivities are in the linear span of the first $k$. These are the structurally unidentifiable parameters. The final step is to collect these indices and sort them in ascending order.\n\nThe algorithm is as follows for each test case:\n1.  Given $(\\varepsilon, \\sigma, \\beta, r_c)$ and a set of $N_r$ radial points $\\{r_i\\}$, construct the $N_r \\times 2$ sensitivity matrix $J$. For each $r_i$, compute the two sensitivity values using the derived expressions, checking if $r_i  r_c$.\n2.  Perform rank-revealing QR decomposition on $J$ to obtain $R$ and the column permutation vector $p$.\n3.  Calculate the numerical rank $k$ of $J$ by counting the diagonal elements of $R$ that exceed a defined tolerance.\n4.  The indices of the unidentifiable parameters are given by the last $2-k$ elements of $p$.\n5.  Sort these indices and return the resulting list.\nThis procedure is applied to each of the three provided test cases.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import qr\n\ndef solve():\n    \"\"\"\n    Performs local sensitivity and identifiability analysis for a truncated\n    Lennard-Jones potential model.\n    \"\"\"\n    # Test suite from the problem statement.\n    # Each case is a tuple: (epsilon, sigma, beta, r_cutoff, r_values_list)\n    test_cases = [\n        (1.0, 1.0, 1.0, 2.5, [0.95, 1.00, 1.10, 1.50, 2.00, 2.49]),\n        (1.0, 1.0, 1.0, 2.5, [2.60, 3.00]),\n        (1.0, 1.0, 1.0, 2.5, [1.00]),\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        eps, sig, beta, r_c, r_values = case\n        \n        num_r = len(r_values)\n        num_params = 2  # Parameter ordering is [epsilon, sigma]\n\n        # If there are no data points, all parameters are unidentifiable.\n        if num_r == 0:\n            all_results.append([0, 1])\n            continue\n\n        # Initialize the sensitivity (Jacobian) matrix J\n        J = np.zeros((num_r, num_params))\n\n        for i, r in enumerate(r_values):\n            # The sensitivity is non-zero only if r is within the cutoff\n            if r  r_c:\n                # Avoid division by zero, though not present in test cases\n                if r == 0.0 or eps == 0.0 or sig == 0.0:\n                    J[i, :] = 0.0\n                    continue\n\n                # Calculate intermediate terms\n                # sr = sigma / r\n                sr = sig / r\n                # sr^6\n                sr6 = sr**6\n                # sr^12\n                sr12 = sr6**2\n                \n                # Calculate the LJ potential u(r)\n                u_val = 4.0 * eps * (sr12 - sr6)\n                \n                # Calculate the RDF g(r)\n                g_val = np.exp(-beta * u_val)\n                \n                # Sensitivity w.r.t. epsilon (parameter 0)\n                # d(u)/d(epsilon) = u / epsilon\n                du_deps = u_val / eps\n                dg_deps = -beta * g_val * du_deps\n                J[i, 0] = dg_deps\n                \n                # Sensitivity w.r.t. sigma (parameter 1)\n                # d(u)/d(sigma) = (24*eps/sig) * (2*sr^12 - sr^6)\n                du_dsig = (24.0 * eps / sig) * (2.0 * sr12 - sr6)\n                dg_dsig = -beta * g_val * du_dsig\n                J[i, 1] = dg_dsig\n\n            else: # r >= r_c\n                # Potential and its derivatives are zero\n                J[i, 0] = 0.0\n                J[i, 1] = 0.0\n\n        # Assess local structural identifiability using rank-revealing QR\n        if np.allclose(J, 0):\n            # If J is a zero matrix, its rank is 0. All params are unidentifiable.\n            rank = 0\n            # Permutation vector is just the original order.\n            p = np.arange(num_params)\n        else:\n            Q, R, p = qr(J, pivoting=True)\n            \n            # Determine numerical rank from the diagonal of R\n            diag_R = np.abs(np.diag(R))\n            \n            # Tolerance for rank determination, scaled by the largest diagonal\n            # element of R and machine precision.\n            tol = diag_R[0] * max(J.shape) * np.finfo(J.dtype).eps\n            \n            rank = np.sum(diag_R > tol)\n\n        # Indices of unidentifiable parameters are from the tail of the permutation vector\n        unidentifiable_indices = sorted(p[rank:])\n        all_results.append(unidentifiable_indices)\n\n    # Format the final output string as specified\n    output_str = '[' + ','.join([str(res) for res in all_results]) + ']'\n    output_str = output_str.replace(\" \", \"\") # Remove spaces for exact format match\n    print(output_str)\n\nsolve()\n```", "id": "3500725"}, {"introduction": "A central challenge in coarse-graining is ensuring that a model is transferable—that is, a potential parameterized to reproduce one property (like structure) can also predict other properties (like pressure). This practice explores the common scenario where a structure-based potential, derived via Iterative Boltzmann Inversion (IBI), fails to reproduce the correct system pressure. You will implement a standard pressure correction scheme, providing a hands-on understanding of the compromises inherent in coarse-grained force field development and the methods used to create more thermodynamically consistent models [@problem_id:3500714].", "problem": "Consider a one-component coarse-grained fluid representing either a United-Atom mapping or a Bead-Spring polymer model, where effective interactions between coarse-grained sites are represented by a spherically symmetric pair potential $U(r)$. In this problem, you will examine whether Iterative Boltzmann Inversion (IBI) reproduces both the radial distribution function $g(r)$ and the thermodynamic pressure $p$, and you will implement a pressure correction of the form $\\Delta U(r) \\propto r$ to remedy any mismatch. Work in Lennard-Jones reduced units: length in units of $σ$, energy in units of $ε$, temperature in units of $ε/k_B$, and pressure in units of $ε/σ^3$. All outputs must be computed and reported in these reduced units.\n\nUse the following foundational bases:\n- Statistical mechanics in the canonical ensemble gives the low-density closure $g(r) \\approx \\exp(-β U(r))$, with $β = 1/(k_B T)$ and $k_B = 1$ in reduced units.\n- The virial theorem for an isotropic pair potential gives the pressure\n$$\np = ρ T - \\frac{2π}{3} ρ^2 \\int_0^{∞} g(r)\\, r^3 \\frac{dU(r)}{dr}\\, dr,\n$$\nwhere $ρ$ is the number density and $T$ is the temperature.\n- The Lennard-Jones (LJ) potential is $U_{\\mathrm{LJ}}(r) = 4 ε \\left[ \\left(\\frac{σ}{r}\\right)^{12} - \\left(\\frac{σ}{r}\\right)^6 \\right]$, and its radial derivative is $\\frac{dU_{\\mathrm{LJ}}}{dr} = 4 ε \\left[ -12 \\frac{σ^{12}}{r^{13}} + 6 \\frac{σ^6}{r^7} \\right]$. In reduced units, take $ε=1$ and $σ=1$.\n\nTarget model and observables:\n- Define a truncated-and-shifted target potential $U_{\\mathrm{true}}(r)$ as $U_{\\mathrm{true}}(r) = U_{\\mathrm{LJ}}(r) - U_{\\mathrm{LJ}}(r_c^{\\mathrm{true}})$ for $r \\le r_c^{\\mathrm{true}}$ and $U_{\\mathrm{true}}(r) = 0$ for $r  r_c^{\\mathrm{true}}$.\n- Define the target radial distribution function $g_{\\mathrm{target}}(r)$ using the low-density closure $g_{\\mathrm{target}}(r) = \\exp(-β U_{\\mathrm{true}}(r))$.\n- Define the target pressure $p_{\\mathrm{target}}$ using the virial expression with $U_{\\mathrm{true}}(r)$ and $g_{\\mathrm{target}}(r)$ integrated up to $r_c^{\\mathrm{true}}$.\n\nIBI-only model:\n- Define the IBI-only coarse-grained potential on $[0, r_c^{\\mathrm{cg}}]$ by $U_{\\mathrm{IBI}}(r) = -T \\ln g_{\\mathrm{target}}(r)$, i.e., by exactly matching $g(r)$ via the low-density closure on the coarse-grained cutoff domain.\n- Compute the IBI-only pressure $p_{\\mathrm{IBI}}$ using the virial expression integrated up to $r_c^{\\mathrm{cg}}$.\n\nPressure correction:\n- Implement a linear pressure correction $\\Delta U(r) = a\\, r$ for $r \\le r_c^{\\mathrm{cg}}$ and $\\Delta U(r) = 0$ for $r  r_c^{\\mathrm{cg}}$, and define $U_{\\mathrm{corr}}(r) = U_{\\mathrm{IBI}}(r) + a r$ on $[0, r_c^{\\mathrm{cg}}]$.\n- Use the virial identity to choose $a$ such that the corrected pressure $p_{\\mathrm{corr}}$ matches $p_{\\mathrm{target}}$. Under the low-density closure $g(r) \\approx \\exp(-β U(r))$ and within the coarse-grained domain, the linear correction changes the virial integral by\n$$\n\\Delta p = -\\frac{2π}{3} ρ^2 a \\int_0^{r_c^{\\mathrm{cg}}} g(r)\\, r^3\\, dr,\n$$\nwhich yields the coefficient\n$$\na = -\\frac{p_{\\mathrm{target}} - p_{\\mathrm{IBI}}}{\\frac{2π}{3} ρ^2 \\int_0^{r_c^{\\mathrm{cg}}} g(r)\\, r^3\\, dr}.\n$$\n\nNumerical implementation details:\n- Discretize $r$ on a uniform grid from $r_{\\min}$ to the relevant cutoff, with $r_{\\min}  0$ to avoid the singularity at $r=0$. Use $r_{\\min} = 0.80$ and a grid size sufficient to ensure stable quadrature. Use the trapezoidal rule to approximate integrals.\n- Always set $k_B = 1$ in reduced units.\n- Use $g(r) = \\exp(-β U(r))$ wherever $g$ appears.\n\nEvaluation metrics:\n- Structure metric: Compute the root-mean-square deviation of $g(r)$ between the model and target on $[r_{\\min}, r_c^{\\mathrm{cg}}]$,\n$$\n\\mathrm{RMS}_g = \\sqrt{ \\frac{1}{N} \\sum_{i=1}^N \\left( g_{\\mathrm{model}}(r_i) - g_{\\mathrm{target}}(r_i) \\right)^2 },\n$$\nand require $\\mathrm{RMS}_g \\le 0.03$.\n- Pressure metric: Compute $|p_{\\mathrm{model}} - p_{\\mathrm{target}}|$ and require it to be $\\le 0.01$.\n- For the IBI-only model, $g_{\\mathrm{model}}(r)$ is $g_{\\mathrm{target}}(r)$ on $[r_{\\min}, r_c^{\\mathrm{cg}}]$; for the pressure-corrected model, $g_{\\mathrm{model}}(r) = \\exp(-β U_{\\mathrm{corr}}(r))$.\n\nYour program must:\n- For each test case, compute two booleans: one indicating whether IBI-only simultaneously matches both $g(r)$ and $p$ within the tolerances, and one indicating whether the pressure-corrected model simultaneously matches both $g(r)$ and $p$ within the tolerances.\n- Aggregate the booleans for all test cases into a single flat list and print them on one line in the exact format specified below.\n\nTest suite and parameters (all in reduced units):\n- Test case $1$ (happy path, cutoff mismatch): $T = 1.0$, $ρ = 0.2$, $r_c^{\\mathrm{true}} = 3.0$, $r_c^{\\mathrm{cg}} = 2.0$.\n- Test case $2$ (boundary, very low density): $T = 1.0$, $ρ = 0.01$, $r_c^{\\mathrm{true}} = 3.0$, $r_c^{\\mathrm{cg}} = 2.0$.\n- Test case $3$ (edge case, no cutoff mismatch): $T = 1.0$, $ρ = 0.2$, $r_c^{\\mathrm{true}} = 2.0$, $r_c^{\\mathrm{cg}} = 2.0$.\n\nFinal output format:\n- Your program should produce a single line of output containing the six boolean results as a comma-separated list enclosed in square brackets, ordered as `[case1 IBI-only result, case1 corrected result, case2 IBI-only result, case2 corrected result, case3 IBI-only result, case3 corrected result]`. For example, `[True,False,True,True,False,True]`.", "solution": "The problem requires an analysis of two coarse-graining strategies, Iterative Boltzmann Inversion (IBI) and a pressure-corrected variant, to determine if they can simultaneously reproduce the structure and pressure of a target system. The target system is a fluid whose particles interact via a truncated-and-shifted Lennard-Jones (LJ) potential, and its properties are determined within the low-density approximation where the radial distribution function $g(r)$ is given by the Boltzmann factor of the pair potential $U(r)$.\n\nThe analysis is performed in Lennard-Jones reduced units, where energy is in units of $ε$, length in units of $σ$, temperature $T$ in units of $ε/k_B$, and pressure $p$ in units of $ε/σ^3$. The constants are set to $ε=1$, $σ=1$, and the Boltzmann constant $k_B=1$. The relationship between the potential, structure, and temperature is thus $g(r) \\approx \\exp(-U(r)/T)$.\n\nThe pressure $p$ is calculated using the virial theorem for a spherically symmetric pair potential:\n$$\np = ρ T - \\frac{2π}{3} ρ^2 \\int_0^{∞} g(r)\\, r^3 \\frac{dU(r)}{dr}\\, dr\n$$\nwhere $ρ$ is the number density. Numerically, integrals are performed from a minimum distance $r_{\\min} = 0.80$ to the relevant cutoff radius using the trapezoidal rule, to avoid the singularity at $r=0$.\n\nThe step-by-step procedure for each test case is as follows:\n\n1.  **Define the Target System**:\n    The foundational Lennard-Jones potential is $U_{\\mathrm{LJ}}(r) = 4(r^{-12} - r^{-6})$.\n    The target system is defined by a truncated-and-shifted potential $U_{\\mathrm{true}}(r)$ with a cutoff $r_c^{\\mathrm{true}}$:\n    $$\n    U_{\\mathrm{true}}(r) = \\begin{cases} U_{\\mathrm{LJ}}(r) - U_{\\mathrm{LJ}}(r_c^{\\mathrm{true}})  \\text{if } r \\le r_c^{\\mathrm{true}} \\\\ 0  \\text{if } r  r_c^{\\mathrm{true}} \\end{cases}\n    $$\n    The target structure is given by the low-density closure, $g_{\\mathrm{target}}(r) = \\exp(-U_{\\mathrm{true}}(r)/T)$.\n    The target pressure, $p_{\\mathrm{target}}$, is calculated using the virial expression with $U_{\\mathrm{true}}(r)$ and $g_{\\mathrm{target}}(r)$, integrating up to $r_c^{\\mathrm{true}}$. The derivative $\\frac{dU_{\\mathrm{true}}}{dr}$ is equal to $\\frac{dU_{\\mathrm{LJ}}}{dr}$ for $r \\le r_c^{\\mathrm{true}}$ and $0$ otherwise.\n\n2.  **Analyze the IBI-Only Model**:\n    The IBI method aims to reproduce a target structure, $g_{\\mathrm{target}}(r)$. In its simplest, non-iterative form, the potential $U_{\\mathrm{IBI}}(r)$ is obtained by inverting the Boltzmann relation on the coarse-grained domain $[0, r_c^{\\mathrm{cg}}]$:\n    $$\n    U_{\\mathrm{IBI}}(r) = -T \\ln(g_{\\mathrm{target}}(r)) \\quad \\text{for } r \\le r_c^{\\mathrm{cg}}\n    $$\n    Given $g_{\\mathrm{target}}(r) = \\exp(-U_{\\mathrm{true}}(r)/T)$, it follows that $U_{\\mathrm{IBI}}(r) = U_{\\mathrm{true}}(r)$ for all $r \\le r_c^{\\mathrm{cg}}$. By this construction, the RDF of the IBI model, $g_{\\mathrm{IBI}}(r) = \\exp(-U_{\\mathrm{IBI}}(r)/T)$, is identical to $g_{\\mathrm{target}}(r)$ on the domain $[0, r_c^{\\mathrm{cg}}]$. Consequently, the structure-matching metric, $\\mathrm{RMS}_g$, is identically zero for the IBI model.\n    The pressure of the IBI model, $p_{\\mathrm{IBI}}$, is calculated using the virial theorem with $U_{\\mathrm{IBI}}(r)$ and $g_{\\mathrm{IBI}}(r)$, integrating up to the coarse-grained cutoff $r_c^{\\mathrm{cg}}$.\n    The IBI-only model is considered successful if $|p_{\\mathrm{IBI}} - p_{\\mathrm{target}}| \\le 0.01$. The structure metric is met by definition.\n\n3.  **Analyze the Pressure-Corrected Model**:\n    When $p_{\\mathrm{IBI}}$ does not match $p_{\\mathrm{target}}$, a correction term is added to the potential. Here, a linear correction $\\Delta U(r) = a\\,r$ is used for $r \\le r_c^{\\mathrm{cg}}$. The corrected potential is $U_{\\mathrm{corr}}(r) = U_{\\mathrm{IBI}}(r) + a\\,r$.\n    The coefficient $a$ is determined by approximating the required pressure change. The change in the virial contribution due to $\\Delta U(r)$ is approximated as $\\Delta p \\approx -\\frac{2π}{3} ρ^2 \\int_0^{r_c^{\\mathrm{cg}}} g_{\\mathrm{target}}(r)\\, r^3 \\frac{d(\\Delta U(r))}{dr}\\, dr$. Setting $\\Delta p = p_{\\mathrm{target}} - p_{\\mathrm{IBI}}$ and using $\\frac{d(\\Delta U(r))}{dr} = a$, we solve for $a$:\n    $$\n    a = -\\frac{p_{\\mathrm{target}} - p_{\\mathrm{IBI}}}{\\frac{2π}{3} ρ^2 \\int_0^{r_c^{\\mathrm{cg}}} g_{\\mathrm{target}}(r)\\, r^3\\, dr}\n    $$\n    This one-shot correction defines the new potential $U_{\\mathrm{corr}}(r)$. The corresponding new structure is $g_{\\mathrm{corr}}(r) = \\exp(-U_{\\mathrm{corr}}(r)/T)$. The corrected pressure, $p_{\\mathrm{corr}}$, is calculated from the virial theorem using $U_{\\mathrm{corr}}(r)$ and $g_{\\mathrm{corr}}(r)$, integrating up to $r_c^{\\mathrm{cg}}$.\n    The corrected model is successful if it satisfies two conditions simultaneously:\n    a. Structure match: $\\mathrm{RMS}_g = \\sqrt{ \\frac{1}{N} \\sum_{i=1}^N \\left( g_{\\mathrm{corr}}(r_i) - g_{\\mathrm{target}}(r_i) \\right)^2 } \\le 0.03$ on the domain $[r_{\\min}, r_c^{\\mathrm{cg}}]$.\n    b. Pressure match: $|p_{\\mathrm{corr}} - p_{\\mathrm{target}}| \\le 0.01$.\n\nThis procedure is applied to each test case to generate the required boolean evaluation results.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import trapezoid\n\ndef solve():\n    \"\"\"\n    Solves the coarse-graining problem for the specified test cases.\n\n    This function implements the IBI and pressure-correction models for a coarse-grained\n    fluid. It evaluates whether each model can simultaneously reproduce the target\n    structure (radial distribution function) and pressure within given tolerances.\n    \"\"\"\n    \n    # Define problem constants and tolerances\n    r_min = 0.80\n    rms_g_tol = 0.03\n    p_tol = 0.01\n    \n    # In reduced units, epsilon, sigma, and k_B are 1.\n    epsilon = 1.0\n    sigma = 1.0\n    k_B = 1.0\n    \n    # Define a numerical grid. The maximum r_c_true is 3.0, so this range is sufficient.\n    num_points = 4001 # A fine grid for stable quadrature\n    r_grid = np.linspace(r_min, 3.0, num_points)\n\n    # Define the Lennard-Jones potential and its derivative in reduced units\n    def U_lj(r):\n        r_inv = sigma / r\n        r_inv6 = r_inv**6\n        return 4.0 * epsilon * (r_inv6**2 - r_inv6)\n\n    def dU_lj_dr(r):\n        r_inv = sigma / r\n        r_inv7 = r_inv**7\n        r_inv13 = r_inv**13\n        return 4.0 * epsilon * (-12.0 * r_inv13 / sigma + 6.0 * r_inv7 / sigma)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (T, ρ, r_c^true, r_c^cg)\n        (1.0, 0.2, 3.0, 2.0),\n        (1.0, 0.01, 3.0, 2.0),\n        (1.0, 0.2, 2.0, 2.0),\n    ]\n\n    results = []\n    \n    for T, rho, r_c_true, r_c_cg in test_cases:\n        beta = 1.0 / (k_B * T)\n        \n        # --- 1. Target Model Calculation ---\n        \n        # Define the truncated-and-shifted target potential U_true(r)\n        U_lj_at_rc_true = U_lj(r_c_true)\n        U_true = np.where(r_grid = r_c_true, U_lj(r_grid) - U_lj_at_rc_true, 0.0)\n        \n        # Define the target radial distribution function g_target(r)\n        g_target = np.exp(-beta * U_true)\n        \n        # Define the derivative of the target potential\n        dU_true_dr = np.where(r_grid = r_c_true, dU_lj_dr(r_grid), 0.0)\n        \n        # Calculate the target pressure p_target\n        integrand_target = g_target * r_grid**3 * dU_true_dr\n        mask_true = r_grid = r_c_true\n        integral_target = trapezoid(integrand_target[mask_true], r_grid[mask_true])\n        p_target = rho * T - (2.0 * np.pi / 3.0) * rho**2 * integral_target\n        \n        # --- 2. IBI-Only Model Calculation  Evaluation ---\n        \n        # By definition, U_ibi(r) = U_true(r) and g_ibi(r) = g_target(r) for r = r_c_cg.\n        # Thus, the RMS_g for the IBI-only model is 0 and always meets the criterion.\n        rms_g_ibi_ok = True\n        \n        # Calculate the IBI-only pressure p_ibi\n        dU_ibi_dr = np.where(r_grid = r_c_cg, dU_lj_dr(r_grid), 0.0)\n        integrand_ibi = g_target * r_grid**3 * dU_ibi_dr\n        mask_cg = r_grid = r_c_cg\n        integral_ibi = trapezoid(integrand_ibi[mask_cg], r_grid[mask_cg])\n        p_ibi = rho * T - (2.0 * np.pi / 3.0) * rho**2 * integral_ibi\n        \n        # Evaluate if p_ibi meets the pressure criterion\n        p_ibi_ok = abs(p_ibi - p_target) = p_tol\n        results.append(rms_g_ibi_ok and p_ibi_ok)\n\n        # --- 3. Pressure-Corrected Model Calculation  Evaluation ---\n        \n        # Calculate the pressure correction coefficient 'a'\n        p_diff = p_target - p_ibi\n        integrand_a_denom = g_target[mask_cg] * r_grid[mask_cg]**3\n        integral_a_denom = trapezoid(integrand_a_denom, r_grid[mask_cg])\n        \n        denom_const = (2.0 * np.pi / 3.0) * rho**2\n        if abs(denom_const * integral_a_denom)  1e-15:\n            a = 0.0\n        else:\n            a = -p_diff / (denom_const * integral_a_denom)\n            \n        # Define the corrected potential and its corresponding RDF\n        U_corr = np.where(mask_cg, U_true + a * r_grid, 0.0)\n        g_corr = np.exp(-beta * U_corr)\n        \n        # Evaluate structure metric for the corrected model\n        g_corr_on_cg = g_corr[mask_cg]\n        g_target_on_cg = g_target[mask_cg]\n        rms_g_corr = np.sqrt(np.mean((g_corr_on_cg - g_target_on_cg)**2))\n        rms_g_corr_ok = rms_g_corr = rms_g_tol\n        \n        # Evaluate pressure metric for the corrected model\n        dU_corr_dr = np.where(mask_cg, dU_lj_dr(r_grid) + a, 0.0)\n        integrand_corr = g_corr * r_grid**3 * dU_corr_dr\n        integral_corr = trapezoid(integrand_corr[mask_cg], r_grid[mask_cg])\n        p_corr = rho * T - (2.0 * np.pi / 3.0) * rho**2 * integral_corr\n        p_corr_ok = abs(p_corr - p_target) = p_tol\n        \n        results.append(rms_g_corr_ok and p_corr_ok)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3500714"}, {"introduction": "While coarse-grained simulations allow us to access longer time and length scales, we often need to return to an atomistic representation for detailed analysis. This \"backmapping\" process is non-trivial and can introduce systematic biases that distort the underlying structural ensemble. This exercise guides you through building a stochastic backmapping procedure for a dihedral angle, allowing you to quantitatively measure the resulting structural bias using Kullback-Leibler divergence and assess its impact on calculated free energy differences, a crucial skill for any multi-scale modeler [@problem_id:3500691].", "problem": "You are tasked with formalizing and quantifying how stochastic backmapping from coarse-grained bead-spring representations to atomistic or united-atom structures introduces structural bias in dihedral angle distributions, and how this bias affects free energy differences between predefined macrostates. Consider a single torsional degree of freedom represented by a dihedral angle $\\varphi \\in [-\\pi,\\pi)$ on the unit circle. The system has an atomistic (united-atom) target torsional potential $U_{\\mathrm{AT}}(\\varphi)$ and a simplified coarse-grained bead-spring torsional potential $U_{\\mathrm{CG}}(\\varphi)$. Stochastic backmapping constructs atomistic dihedral angles from the coarse-grained angle distribution via a wrapped Gaussian kernel, introducing a tunable bias.\n\nFundamental base:\n- The Boltzmann distribution for a torsional coordinate at absolute temperature $T$ is $p(\\varphi) = Z^{-1} \\exp(-\\beta U(\\varphi))$ where $\\beta = 1/(R T)$, $R$ is the ideal gas constant in $\\mathrm{kJ\\,mol^{-1}\\,K^{-1}}$, and $Z = \\int_{-\\pi}^{\\pi} \\exp(-\\beta U(\\varphi))\\,d\\varphi$ is the partition function.\n- The free energy of a macrostate $M \\subset [-\\pi,\\pi)$ is $F_M = - R T \\ln Z_M$ with $Z_M = \\int_M p(\\varphi)\\,d\\varphi$, and the free energy difference between two macrostates $A$ and $B$ is $\\Delta F = F_B - F_A = -R T \\ln\\left(\\frac{Z_B}{Z_A}\\right)$.\n- A stochastic backmapping kernel on a circle is modeled by a wrapped normal distribution. For a given mean bias $b$ and standard deviation $\\sigma$, the kernel is\n$$\nW(\\Delta\\varphi; b, \\sigma) = \\sum_{k=-\\infty}^{\\infty} \\frac{1}{\\sqrt{2\\pi}\\sigma} \\exp\\left(-\\frac{(\\Delta\\varphi - b + 2\\pi k)^2}{2\\sigma^2}\\right),\n$$\nwhich ensures $\\int_{-\\pi}^{\\pi} W(\\Delta\\varphi; b, \\sigma)\\,d\\Delta\\varphi = 1$.\n- Macrostates are defined by angle intervals: $A$ (cis-like) is $\\{\\varphi : |\\varphi| \\le \\varphi_c\\}$ and $B$ (trans-like) is $\\{\\varphi : \\min(|\\varphi - \\pi|, |\\varphi + \\pi|) \\le \\varphi_c\\}$.\n\nYour program must implement the following, strictly using the definitions above and numerical quadrature on a uniform grid over $[-\\pi,\\pi)$:\n\n1. Construct the atomistic target potential\n$$\nU_{\\mathrm{AT}}(\\varphi) = k_1(1 - \\cos\\varphi) + k_3(1 - \\cos(3\\varphi)),\n$$\nand the coarse-grained potential\n$$\nU_{\\mathrm{CG}}(\\varphi) = k_{\\mathrm{CG}}(1 - \\cos\\varphi),\n$$\nwith all $k$ parameters in $\\mathrm{kJ\\,mol^{-1}}$.\n\n2. Compute the normalized atomistic torsional probability density $P_{\\mathrm{AT}}(\\varphi) \\propto \\exp(-\\beta U_{\\mathrm{AT}}(\\varphi))$ and the normalized coarse-grained torsional density $P_{\\mathrm{CG}}(\\varphi) \\propto \\exp(-\\beta U_{\\mathrm{CG}}(\\varphi))$ on a uniform grid.\n\n3. Define the wrapped Gaussian kernel $W(\\Delta\\varphi; b, \\sigma)$ on the grid and compute the stochastically backmapped (biased) atomistic reconstruction density by circular convolution\n$$\nQ(\\varphi) = \\int_{-\\pi}^{\\pi} P_{\\mathrm{CG}}(\\psi)\\, W(\\varphi - \\psi; b, \\sigma)\\, d\\psi,\n$$\nnormalized so that $\\int_{-\\pi}^{\\pi} Q(\\varphi)\\,d\\varphi = 1$.\n\n4. Compute three free energy differences:\n   - The true atomistic $\\Delta F_{\\mathrm{true}} = -R T \\ln\\left(\\frac{\\int_B P_{\\mathrm{AT}}(\\varphi)\\,d\\varphi}{\\int_A P_{\\mathrm{AT}}(\\varphi)\\,d\\varphi}\\right)$.\n   - The measured from biased reconstruction $\\Delta F_{\\mathrm{meas}} = -R T \\ln\\left(\\frac{\\int_B Q(\\varphi)\\,d\\varphi}{\\int_A Q(\\varphi)\\,d\\varphi}\\right)$.\n   - An approximate reweighting estimate that uses the ratio of atomistic to coarse-grained Boltzmann weights,\n$$\nw(\\varphi) = \\frac{P_{\\mathrm{AT}}(\\varphi)}{P_{\\mathrm{CG}}(\\varphi)},\n$$\nto define\n$$\n\\Delta F_{\\mathrm{rw}} = -R T \\ln\\left(\\frac{\\int_B w(\\varphi)\\, Q(\\varphi)\\, d\\varphi}{\\int_A w(\\varphi)\\, Q(\\varphi)\\, d\\varphi}\\right).\n$$\n\n5. Quantify the structural bias using the Kullback–Leibler divergence (relative entropy)\n$$\nD_{\\mathrm{KL}}(Q\\Vert P_{\\mathrm{AT}}) = \\int_{-\\pi}^{\\pi} Q(\\varphi)\\, \\ln\\left(\\frac{Q(\\varphi)}{P_{\\mathrm{AT}}(\\varphi)}\\right)\\, d\\varphi.\n$$\n\nImplementation notes:\n- Use a uniform $N$-point grid over $[-\\pi,\\pi)$ with $N$ sufficiently large to accurately resolve the integrals; use the trapezoidal rule equivalent to a Riemann sum on the uniform grid. Circular convolution must respect periodic boundary conditions; implement it via the discrete Fourier transform for efficiency or direct circular summation. Ensure all densities are normalized.\n- To maintain numerical stability, when forming ratios $\\frac{P_{\\mathrm{AT}}(\\varphi)}{P_{\\mathrm{CG}}(\\varphi)}$ and logarithms in $D_{\\mathrm{KL}}$, add a small positive constant $\\varepsilon$ to denominators and densities to avoid division by zero and undefined logarithms, while keeping $\\varepsilon$ negligible compared to unity.\n- All free energies must be expressed in $\\mathrm{kJ\\,mol^{-1}}$ and computed using $R = 8.314462618 \\times 10^{-3} \\, \\mathrm{kJ\\,mol^{-1}\\,K^{-1}}$. Angles are in radians.\n\nTest suite:\nFor each parameter set $(T, k_1, k_3, k_{\\mathrm{CG}}, b, \\sigma, \\varphi_c)$ below, compute $[D_{\\mathrm{KL}}(Q\\Vert P_{\\mathrm{AT}}), \\Delta F_{\\mathrm{meas}}, \\Delta F_{\\mathrm{rw}}, \\Delta F_{\\mathrm{true}}]$ with free energies in $\\mathrm{kJ\\,mol^{-1}}$, and aggregate results as specified.\n\n- Case 1 (baseline, mild noise, no bias): $T = 300$, $k_1 = 2.5$, $k_3 = 1.0$, $k_{\\mathrm{CG}} = 2.0$, $b = 0.0$, $\\sigma = 0.2$, $\\varphi_c = 0.3$.\n- Case 2 (positive mean bias, moderate noise): $T = 300$, $k_1 = 2.5$, $k_3 = 1.0$, $k_{\\mathrm{CG}} = 1.5$, $b = 0.4$, $\\sigma = 0.3$, $\\varphi_c = 0.3$.\n- Case 3 (negative mean bias, larger noise): $T = 300$, $k_1 = 2.5$, $k_3 = 1.0$, $k_{\\mathrm{CG}} = 2.5$, $b = -0.6$, $\\sigma = 0.5$, $\\varphi_c = 0.3$.\n- Case 4 (strong smoothing, small macrostate width): $T = 300$, $k_1 = 2.5$, $k_3 = 1.0$, $k_{\\mathrm{CG}} = 2.0$, $b = 0.0$, $\\sigma = 1.0$, $\\varphi_c = 0.1$.\n- Case 5 (higher temperature, moderate bias): $T = 500$, $k_1 = 2.5$, $k_3 = 1.0$, $k_{\\mathrm{CG}} = 2.0$, $b = 0.2$, $\\sigma = 0.4$, $\\varphi_c = 0.3$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is itself a comma-separated list in square brackets corresponding to one test case in the same order as given above. For example,\n`[ [$d_1$, $f^{\\mathrm{meas}}_1$, $f^{\\mathrm{rw}}_1$, $f^{\\mathrm{true}}_1$], [$d_2$, $f^{\\mathrm{meas}}_2$, $f^{\\mathrm{rw}}_2$, $f^{\\mathrm{true}}_2$], ... ]`,\nwith all numbers in floating-point representation and free energies in $\\mathrm{kJ\\,mol^{-1}}$.", "solution": "The solution requires the numerical computation of several quantities derived from statistical mechanics to quantify the bias introduced by a stochastic backmapping procedure. The overall procedure is as follows.\n\n1.  **Discretization**: The continuous domain for the dihedral angle, $\\varphi \\in [-\\pi, \\pi)$, is discretized into a uniform grid of $N$ points. A large $N$ (e.g., 4096) ensures accuracy in the numerical integrations. The grid spacing is $\\Delta\\varphi = 2\\pi/N$. For periodic functions on this grid, the trapezoidal rule for integration simplifies to a sum over all grid points multiplied by $\\Delta\\varphi$.\n\n2.  **Probability Densities**: For each test case's parameters, the atomistic potential $U_{\\mathrm{AT}}(\\varphi)$ and coarse-grained potential $U_{\\mathrm{CG}}(\\varphi)$ are evaluated on the grid. Using the given temperature $T$ and gas constant $R$, the inverse thermal energy $\\beta = 1/(RT)$ is calculated. The unnormalized Boltzmann probability densities, $p'(\\varphi) = \\exp(-\\beta U(\\varphi))$, are computed for both models. These are then normalized by dividing by their respective partition functions, $Z = \\int p'(\\varphi) d\\varphi$, to yield the final probability densities $P_{\\mathrm{AT}}(\\varphi)$ and $P_{\\mathrm{CG}}(\\varphi)$.\n\n3.  **Backmapped Density $Q(\\varphi)$**:\n    -   The wrapped normal kernel, $W(\\varphi; b, \\sigma)$, is constructed on the grid. Its definition involves an infinite sum, which must be truncated for computation. A summation over integers $k$ from -5 to 5 is sufficient for the given range of $\\sigma$. The resulting kernel is normalized to ensure its integral is unity.\n    -   The backmapped density $Q(\\varphi)$ is obtained via the circular convolution of the coarse-grained density $P_{\\mathrm{CG}}(\\varphi)$ with the kernel $W(\\varphi; b, \\sigma)$. This is most efficiently computed using the Fast Fourier Transform (FFT) based on the convolution theorem: $Q = \\text{IDFT}(\\text{DFT}(P_{\\mathrm{CG}}) \\cdot \\text{DFT}(W)) \\cdot \\Delta\\varphi$, where IDFT and DFT are the inverse and forward discrete Fourier transforms. The resulting density $Q(\\varphi)$ is also normalized.\n\n4.  **Free Energy and KL Divergence Calculation**:\n    -   **Macrostates**: The regions for macrostates $A$ (cis-like) and $B$ (trans-like) are identified on the grid using the boundary angle $\\varphi_c$.\n    -   **Free Energies**: The probability of occupying each macrostate is found by integrating the relevant probability density ($P_{\\mathrm{AT}}$ for true, $Q$ for measured) over its region. For example, $Z_A = \\int_A P(\\varphi) d\\varphi$. The free energy difference is then computed using the formula $\\Delta F = -RT\\ln(Z_B/Z_A)$. A small constant $\\varepsilon$ is added inside the logarithm to prevent numerical errors.\n    -   **Reweighted Free Energy**: For $\\Delta F_{\\mathrm{rw}}$, a reweighting factor $w(\\varphi) = P_{\\mathrm{AT}}(\\varphi) / (P_{\\mathrm{CG}}(\\varphi) + \\varepsilon)$ is first calculated. The integrated probabilities for states $A$ and $B$ are then computed from the reweighted distribution $w(\\varphi)Q(\\varphi)$. $\\Delta F_{\\mathrm{rw}}$ is found using these values in the free energy formula.\n    -   **KL Divergence**: The Kullback-Leibler divergence, $D_{\\mathrm{KL}}(Q\\Vert P_{\\mathrm{AT}})$, is calculated by numerically integrating the expression $Q(\\varphi)\\ln((Q(\\varphi)+\\varepsilon)/(P_{\\mathrm{AT}}(\\varphi)+\\varepsilon))$ over the entire grid.\n\nThis numerical procedure is executed for each set of test parameters to generate the required list of observables.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    It iterates through each parameter set, computes the specified quantities,\n    and prints the formatted results.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (T, k1, k3, k_CG, b, sigma, phi_c)\n        (300.0, 2.5, 1.0, 2.0, 0.0, 0.2, 0.3),\n        (300.0, 2.5, 1.0, 1.5, 0.4, 0.3, 0.3),\n        (300.0, 2.5, 1.0, 2.5, -0.6, 0.5, 0.3),\n        (300.0, 2.5, 1.0, 2.0, 0.0, 1.0, 0.1),\n        (500.0, 2.5, 1.0, 2.0, 0.2, 0.4, 0.3),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = _calculate_observables(case)\n        results.append(result)\n\n    # Format the final output string as a list of lists.\n    # Each sublist is a comma-separated string of numbers.\n    # The final string is a comma-separated list of these sublists.\n    sub_lists_as_strings = []\n    for res in results:\n        sub_list_str = f\"[{','.join([f'{x:.6f}' for x in res])}]\"\n        sub_lists_as_strings.append(sub_list_str)\n    \n    final_output = f\"[{','.join(sub_lists_as_strings)}]\"\n    print(final_output)\n\ndef _wrapped_normal(delta_phi, b, sigma, n_points):\n    \"\"\"\n    Computes the wrapped normal distribution on a grid.\n    The infinite sum is truncated to k in [-5, 5].\n    \"\"\"\n    # Truncation range for the sum\n    k_range = np.arange(-5, 6)\n    \n    # Use broadcasting for efficient computation over the grid and k-range\n    # delta_phi shape: (n_points,) -> (n_points, 1)\n    # k_range shape: (11,) -> (1, 11)\n    numerator = -(delta_phi[:, None] - b + 2.0 * np.pi * k_range[None, :])**2\n    denominator = 2.0 * sigma**2\n    gaussians = np.exp(numerator / denominator)\n    \n    # Sum over the k-dimension\n    summed_gaussians = np.sum(gaussians, axis=1)\n    prefactor = 1.0 / (np.sqrt(2.0 * np.pi) * sigma)\n    \n    return prefactor * summed_gaussians\n\ndef _calculate_observables(params):\n    \"\"\"\n    Performs the full calculation for a single parameter set.\n    \"\"\"\n    T, k1, k3, k_CG, b, sigma, phi_c = params\n    \n    # Constants and numerical parameters\n    R = 8.314462618e-3  # kJ mol^-1 K^-1\n    N = 4096              # Number of grid points\n    epsilon = 1e-16       # Small constant for numerical stability\n\n    beta = 1.0 / (R * T)\n\n    # 1. Discretize the domain\n    phi = np.linspace(-np.pi, np.pi, N, endpoint=False)\n    d_phi = 2.0 * np.pi / N\n\n    # 2. Compute potentials and probability densities\n    # Atomistic (AT) model\n    U_at = k1 * (1.0 - np.cos(phi)) + k3 * (1.0 - np.cos(3.0 * phi))\n    boltz_at = np.exp(-beta * U_at)\n    Z_at_total = np.sum(boltz_at) * d_phi\n    P_at = boltz_at / Z_at_total\n\n    # Coarse-grained (CG) model\n    U_cg = k_CG * (1.0 - np.cos(phi))\n    boltz_cg = np.exp(-beta * U_cg)\n    Z_cg_total = np.sum(boltz_cg) * d_phi\n    P_cg = boltz_cg / Z_cg_total\n\n    # 3. Compute backmapped density Q via circular convolution\n    W_kernel = _wrapped_normal(phi, b, sigma, N)\n    # Ensure kernel is normalized on the discrete grid\n    W_kernel /= (np.sum(W_kernel) * d_phi)\n\n    # FFT-based circular convolution\n    Q_unnormalized = np.real(np.fft.ifft(np.fft.fft(P_cg) * np.fft.fft(W_kernel)))\n    Q = Q_unnormalized * d_phi\n    # Re-normalize Q to be safe against minor numerical drift\n    Q /= (np.sum(Q) * d_phi)\n\n    # 4. Define macrostates and compute integrals for free energies\n    mask_A = np.abs(phi) = phi_c\n    mask_B = np.abs(phi) >= np.pi - phi_c\n\n    # For Delta F_true (from P_at)\n    prob_A_at = np.sum(P_at[mask_A]) * d_phi\n    prob_B_at = np.sum(P_at[mask_B]) * d_phi\n    \n    # For Delta F_meas (from Q)\n    prob_A_q = np.sum(Q[mask_A]) * d_phi\n    prob_B_q = np.sum(Q[mask_B]) * d_phi\n    \n    # For Delta F_rw (reweighting)\n    w = P_at / (P_cg + epsilon)\n    prob_A_rw = np.sum(w[mask_A] * Q[mask_A]) * d_phi\n    prob_B_rw = np.sum(w[mask_B] * Q[mask_B]) * d_phi\n\n    # Compute free energy differences\n    delta_F_true = -R * T * np.log((prob_B_at + epsilon) / (prob_A_at + epsilon))\n    delta_F_meas = -R * T * np.log((prob_B_q + epsilon) / (prob_A_q + epsilon))\n    delta_F_rw = -R * T * np.log((prob_B_rw + epsilon) / (prob_A_rw + epsilon))\n\n    # 5. Compute Kullback-Leibler divergence\n    integrand_kl = Q * np.log((Q + epsilon) / (P_at + epsilon))\n    D_kl = np.sum(integrand_kl) * d_phi\n\n    return [D_kl, delta_F_meas, delta_F_rw, delta_F_true]\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3500691"}]}