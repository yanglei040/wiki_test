{"hands_on_practices": [{"introduction": "Before embarking on a complex quantum simulation, a crucial first step is to estimate the required computational resources. This practice provides a foundational exercise in understanding how the problem size scales with the physical parameters of a material. By calculating the number of spin-orbitals (qubits) and the number of terms in the Hamiltonian for a general crystalline solid, you will gain direct insight into the formidable polynomial scaling that motivates the development of more advanced, efficient simulation techniques [@problem_id:3481650].", "problem": "Consider setting up a Variational Quantum Eigensolver (VQE) calculation for an interacting electron model of a crystalline solid represented in a localized orbital basis suitable for second quantization. The crystal has $N$ identical unit cells and $M$ localized spatial orbitals per unit cell. Assume spin degeneracy with no spin polarization so that each spatial orbital admits two spin states. You model the electrons with the standard second-quantized electronic Hamiltonian that includes all one-electron and two-electron terms over all spin-orbitals. Assume long-range Coulomb interactions are unscreened so that no two-electron integral vanishes by distance truncation, and do not exploit any point-group or translational symmetry to eliminate terms. You intend to use a fermion-to-qubit mapping in which each spin-orbital is mapped to one qubit.\n\nUnder these assumptions, do the following from first principles:\n- Determine the total number of spin-orbitals as a function of $N$ and $M$.\n- Define the Hamiltonian “size” as the total count of distinct operator monomials appearing in the second-quantized Hamiltonian prior to any mapping (i.e., the total number of index combinations in the one-body and two-body sums). Compute the leading-order dependence of this count on $N$ and $M$ by keeping only the highest-degree polynomial term in $N$ and $M$.\n\nExpress your final result as a row matrix with two entries $\\big[$total number of spin-orbitals, leading-order Hamiltonian term count in $N$ and $M\\big]$. No units are required. Provide exact expressions; no rounding is needed.", "solution": "The problem statement has been evaluated and is determined to be valid. It is scientifically grounded, well-posed, objective, and self-contained. The assumptions, such as neglecting symmetries and considering all potential interaction terms, are clearly stated for the purpose of a theoretical scaling analysis. We may therefore proceed with the derivation.\n\nThe problem asks for two quantities derived from a second-quantized description of an interacting electron model for a crystalline solid: the total number of spin-orbitals and the leading-order scaling of the number of terms in the electronic Hamiltonian.\n\n**1. Total Number of Spin-Orbitals**\n\nThe system is a crystalline solid comprising $N$ identical unit cells. Each unit cell contains $M$ localized spatial orbitals.\nThe total number of spatial orbitals in the crystal is the product of the number of unit cells and the number of spatial orbitals per cell.\nLet $N_{orb}$ be the total number of spatial orbitals.\n$$N_{orb} = N \\times M$$\nThe problem states to assume spin degeneracy, meaning each spatial orbital can be occupied by an electron with either spin-up ($\\sigma = +\\frac{1}{2}$, denoted $\\alpha$) or spin-down ($\\sigma = -\\frac{1}{2}$, denoted $\\beta$). Therefore, each spatial orbital gives rise to two distinct spin-orbitals.\nLet $N_{so}$ be the total number of spin-orbitals. This is the size of the basis set for the one-particle Fock space.\n$$N_{so} = N_{orb} \\times 2 = 2NM$$\nThis is the first required quantity.\n\n**2. Leading-Order Hamiltonian Term Count**\n\nThe general second-quantized electronic Hamiltonian for a system of interacting electrons is given by the sum of a one-body term and a two-body term:\n$$H = H_1 + H_2 = \\sum_{p,q=1}^{N_{so}} h_{pq} a_p^\\dagger a_q + \\frac{1}{2} \\sum_{p,q,r,s=1}^{N_{so}} v_{pqrs} a_p^\\dagger a_q^\\dagger a_r a_s$$\nwhere the indices $p, q, r, s$ run over all $N_{so}$ spin-orbitals. The term $a_p^\\dagger$ is the creation operator for an electron in spin-orbital $p$, and $a_q$ is the annihilation operator for an electron in spin-orbital $q$. The coefficients $h_{pq}$ are the one-electron integrals, and $v_{pqrs}$ are the two-electron integrals.\n\nThe problem defines the \"Hamiltonian size\" specifically as \"the total count of distinct operator monomials appearing in the second-quantized Hamiltonian prior to any mapping (i.e., the total number of index combinations in the one-body and two-body sums)\". We must adhere strictly to this definition. The problem also instructs not to exploit any symmetries to eliminate terms. This implies we should count the number of terms in the sums as written, without considering relations between coefficients (e.g., $h_{pq} = h_{qp}^*$) or operator strings (e.g., $a_p^\\dagger a_q^\\dagger = -a_q^\\dagger a_p^\\dagger$) that would typically be used to reduce the number of unique terms.\n\n**One-Body Term Count:**\nThe one-body part of the Hamiltonian is $H_1 = \\sum_{p,q=1}^{N_{so}} h_{pq} a_p^\\dagger a_q$.\nAccording to the problem's definition, we must count the number of index combinations for the pair $(p, q)$. Since both indices $p$ and $q$ run independently from $1$ to $N_{so}$, the total number of combinations is:\n$$ \\text{Count}_1 = N_{so} \\times N_{so} = N_{so}^2 $$\n\n**Two-Body Term Count:**\nThe two-body part of the Hamiltonian is $H_2 = \\frac{1}{2} \\sum_{p,q,r,s=1}^{N_{so}} v_{pqrs} a_p^\\dagger a_q^\\dagger a_r a_s$.\nWe count the number of index combinations for the 4-tuple $(p, q, r, s)$. Each of the four indices runs independently from $1$ to $N_{so}$. The total number of combinations is:\n$$ \\text{Count}_2 = N_{so} \\times N_{so} \\times N_{so} \\times N_{so} = N_{so}^4 $$\nThe prefactor of $\\frac{1}{2}$ in the Hamiltonian expression is a convention and does not affect the count of index combinations over which the sum is performed.\n\n**Total Count and Leading-Order Dependence:**\nThe total count of Hamiltonian terms, as defined, is the sum of the one-body and two-body counts:\n$$ \\text{Total Count} = \\text{Count}_1 + \\text{Count}_2 = N_{so}^2 + N_{so}^4 $$\nThe problem asks for the leading-order dependence of this count on $N$ and $M$. This corresponds to the term with the highest total power of $N$ and $M$. We substitute $N_{so} = 2NM$:\n$$ \\text{Total Count} = (2NM)^2 + (2NM)^4 = 4N^2M^2 + 16N^4M^4 $$\nThe term $4N^2M^2$ has a total degree of $2+2=4$. The term $16N^4M^4$ has a total degree of $4+4=8$. The leading-order term is therefore the one with the highest degree, which is $16N^4M^4$.\n\nThus, the leading-order dependence of the Hamiltonian term count on $N$ and $M$ is $16N^4M^4$.\n\n**Final Result Expression:**\nThe problem requires the final result to be expressed as a row matrix containing two entries: [total number of spin-orbitals, leading-order Hamiltonian term count in $N$ and $M$].\nThe two entries are $2NM$ and $16N^4M^4$.", "answer": "$$\n\\boxed{\\begin{pmatrix} 2NM & 16N^{4}M^{4} \\end{pmatrix}}\n$$", "id": "3481650"}, {"introduction": "Having appreciated the steep scaling of quantum simulations, we now turn to a powerful strategy for reducing this complexity: exploiting symmetry. Many materials of interest, such as crystals, possess translational symmetry, which can be leveraged to simplify the problem dramatically [@problem_id:3481667]. This hands-on exercise guides you through the process of transforming a periodic Hamiltonian from real space to momentum space, demonstrating the significant reduction in qubit requirements and making the simulation more tractable for near-term quantum devices.", "problem": "Design and implement a complete, runnable program that formalizes a Variational Quantum Eigensolver (VQE) workflow for a one-dimensional periodic hydrogen chain by exploiting translational symmetry. Begin from the following first-principles base and core definitions.\n\nConsider a one-dimensional periodic chain of hydrogen atoms with $N$ unit cells, lattice constant $a$, one valence orbital per site, and spin degeneracy two. In second quantization with periodic boundary conditions (site indices modulo $N$), the tight-binding electronic Hamiltonian with on-site energy $\\epsilon$ and nearest-neighbor hopping amplitude $t$ is\n$$\nH \\;=\\; \\sum_{j=0}^{N-1} \\sum_{\\sigma \\in \\{\\uparrow,\\downarrow\\}} \\epsilon \\, \\hat{n}_{j,\\sigma} \\;-\\; t \\sum_{j=0}^{N-1} \\sum_{\\sigma \\in \\{\\uparrow,\\downarrow\\}} \\left( \\hat{c}_{j,\\sigma}^\\dagger \\hat{c}_{j+1,\\sigma} \\;+\\; \\hat{c}_{j+1,\\sigma}^\\dagger \\hat{c}_{j,\\sigma} \\right),\n$$\nwhere $\\hat{c}_{j,\\sigma}^\\dagger$ creates a spin-$\\sigma$ electron on site $j$ and $\\hat{n}_{j,\\sigma} = \\hat{c}_{j,\\sigma}^\\dagger \\hat{c}_{j,\\sigma}$. Define Bloch-adapted creation operators via the discrete Fourier transform (Bloch's theorem),\n$$\n\\hat{c}_{k,\\sigma}^\\dagger \\;=\\; \\frac{1}{\\sqrt{N}} \\sum_{j=0}^{N-1} e^{i k R_j} \\, \\hat{c}_{j,\\sigma}^\\dagger, \\quad R_j = j a, \\quad k_m = \\frac{2\\pi}{N a} m, \\; m \\in \\{0,1,\\dots,N-1\\}.\n$$\nUsing only the above base, derive the $k$-space Hamiltonian and show that it decomposes into independent crystal momentum sectors,\n$$\nH \\;=\\; \\sum_{k} \\sum_{\\sigma \\in \\{\\uparrow,\\downarrow\\}} E(k) \\, \\hat{n}_{k,\\sigma}, \\qquad E(k) = \\epsilon - 2 t \\cos(k a),\n$$\nwhere the cosine argument is in radians. For a Variational Quantum Eigensolver (VQE), one can simulate each $k$-sector separately by mapping fermionic number operators to qubits. Under the Jordan–Wigner (JW) transformation, each spin-orbital maps to one qubit, and the number operator maps as $\\hat{n} \\mapsto \\tfrac{1}{2} (I - Z)$. Therefore, the per-$k$ qubit requirement for this model is $Q_k = 2$ (one qubit per spin), while a naive real-space mapping without $k$-sector decomposition uses $Q_{\\text{full}} = 2 N$ qubits. Define the qubit savings due to $k$-tapering as $S = Q_{\\text{full}} - Q_k$ and the savings ratio as $r = S / Q_{\\text{full}}$.\n\nYour program must:\n- Construct the discrete crystal momentum grid $k_m = \\tfrac{2\\pi}{N a} m$ for each test case and compute the corresponding band energies $E(k_m) = \\epsilon - 2 t \\cos(k_m a)$, using radians for the cosine function.\n- Compute $Q_{\\text{full}} = 2 N$, $Q_k = 2$, $S = Q_{\\text{full}} - Q_k$, and $r = S/Q_{\\text{full}}$.\n- Report, for each test case, the minimum and maximum of the discrete band energies over the allowed $k$ values, denoted $E_{\\min}$ and $E_{\\max}$, respectively, expressed in electronvolts (eV).\n- Express all energies in electronvolts (eV), and use radians for all angles. Round $r$, $E_{\\min}$, and $E_{\\max}$ to six decimal places in the final output.\n\nTest Suite:\nProvide results for the following parameter sets $(N, a, \\epsilon, t)$, with $a$ in angstroms and $(\\epsilon, t)$ in electronvolts:\n- Case $1$: $(N, a, \\epsilon, t) = (8, 1.0, -0.3, 1.5)$.\n- Case $2$: $(N, a, \\epsilon, t) = (3, 1.4, 0.0, 1.0)$.\n- Case $3$ (boundary, zero hopping): $(N, a, \\epsilon, t) = (4, 1.2, -0.5, 0.0)$.\n- Case $4$ (larger system): $(N, a, \\epsilon, t) = (16, 0.74, -0.1, 2.0)$.\n\nFinal Output Format:\nYour program should produce a single line of output containing a list of per-case results. Each per-case result must be a list of the form $[Q_{\\text{full}}, Q_k, S, r, E_{\\min}, E_{\\max}]$, where $Q_{\\text{full}}$, $Q_k$, and $S$ are integers, and $r$, $E_{\\min}$, $E_{\\max}$ are decimal numbers rounded to six decimal places. Aggregate these per-case lists into one outer list, and print it as a single line, for example:\n$[[Q_{\\text{full}},Q_k,S,r,E_{\\min},E_{\\max}],\\dots]$.", "solution": "The problem has been validated and is deemed sound. It is scientifically grounded in the principles of solid-state physics and quantum computation, is well-posed with a complete set of definitions and parameters, and is expressed in objective, formal language. We may therefore proceed with a full solution.\n\nThe problem requires the analysis of a simplified one-dimensional periodic chain of hydrogen atoms, focusing on the computational resource savings in a Variational Quantum Eigensolver (VQE) context when translational symmetry is exploited. The core of the task is to derive the Hamiltonian in momentum space ($k$-space) and then use it to compute properties of the energy band structure for several parameter sets.\n\nFirst, we derive the $k$-space representation of the Hamiltonian from the given real-space (tight-binding) formulation. The real-space Hamiltonian is given by:\n$$ H \\;=\\; \\sum_{j=0}^{N-1} \\sum_{\\sigma \\in \\{\\uparrow,\\downarrow\\}} \\epsilon \\, \\hat{n}_{j,\\sigma} \\;-\\; t \\sum_{j=0}^{N-1} \\sum_{\\sigma \\in \\{\\uparrow,\\downarrow\\}} \\left( \\hat{c}_{j,\\sigma}^\\dagger \\hat{c}_{j+1,\\sigma} \\;+\\; \\hat{c}_{j+1,\\sigma}^\\dagger \\hat{c}_{j,\\sigma} \\right) $$\nHere, $j$ indexes the $N$ sites in the chain, $\\sigma$ is the spin, $\\epsilon$ is the on-site energy, and $t$ is the nearest-neighbor hopping amplitude. The operators $\\hat{c}_{j,\\sigma}^\\dagger$ and $\\hat{c}_{j,\\sigma}$ are the fermionic creation and annihilation operators for a spin-$\\sigma$ electron at site $j$, and $\\hat{n}_{j,\\sigma} = \\hat{c}_{j,\\sigma}^\\dagger \\hat{c}_{j,\\sigma}$ is the number operator.\n\nTo diagonalize this Hamiltonian, we apply a discrete Fourier transform to the fermionic operators, which is equivalent to moving to a basis of Bloch waves due to the system's translational symmetry. The Bloch-adapted creation operator is defined as:\n$$ \\hat{c}_{k,\\sigma}^\\dagger \\;=\\; \\frac{1}{\\sqrt{N}} \\sum_{j=0}^{N-1} e^{i k R_j} \\, \\hat{c}_{j,\\sigma}^\\dagger $$\nwhere $R_j = j a$ is the position of site $j$ and $k$ belongs to the discrete set of allowed crystal momenta in the first Brillouin zone, $k_m = \\frac{2\\pi m}{Na}$ for $m \\in \\{0, 1, \\dots, N-1\\}$. The inverse transform is:\n$$ \\hat{c}_{j,\\sigma}^\\dagger \\;=\\; \\frac{1}{\\sqrt{N}} \\sum_{k} e^{-i k R_j} \\, \\hat{c}_{k,\\sigma}^\\dagger, \\qquad \\hat{c}_{j,\\sigma} \\;=\\; \\frac{1}{\\sqrt{N}} \\sum_{k'} e^{i k' R_j} \\, \\hat{c}_{k',\\sigma} $$\n\nWe now substitute these into the Hamiltonian, term by term.\nThe on-site energy term becomes:\n$$ \\sum_{j,\\sigma} \\epsilon \\, \\hat{c}_{j,\\sigma}^\\dagger \\hat{c}_{j,\\sigma} \\;=\\; \\sum_{j,\\sigma} \\epsilon \\left( \\frac{1}{\\sqrt{N}} \\sum_{k} e^{-i k R_j} \\hat{c}_{k,\\sigma}^\\dagger \\right) \\left( \\frac{1}{\\sqrt{N}} \\sum_{k'} e^{i k' R_j} \\hat{c}_{k',\\sigma} \\right) $$\n$$ \\;=\\; \\frac{\\epsilon}{N} \\sum_{k,k',\\sigma} \\hat{c}_{k,\\sigma}^\\dagger \\hat{c}_{k',\\sigma} \\sum_{j=0}^{N-1} e^{i(k'-k)R_j} $$\nThe sum over $j$ is a geometric series that evaluates to $N \\delta_{k,k'}$. This orthogonality relation simplifies the expression:\n$$ \\frac{\\epsilon}{N} \\sum_{k,k',\\sigma} \\hat{c}_{k,\\sigma}^\\dagger \\hat{c}_{k',\\sigma} (N \\delta_{k,k'}) \\;=\\; \\sum_{k,\\sigma} \\epsilon \\, \\hat{c}_{k,\\sigma}^\\dagger \\hat{c}_{k,\\sigma} \\;=\\; \\sum_{k,\\sigma} \\epsilon \\, \\hat{n}_{k,\\sigma} $$\nThe on-site term is diagonal in the $k$-basis.\n\nNext, we transform the hopping term. Consider the first part, $\\sum_{j,\\sigma} \\hat{c}_{j,\\sigma}^\\dagger \\hat{c}_{j+1,\\sigma}$:\n$$ \\sum_{j,\\sigma} \\left( \\frac{1}{\\sqrt{N}} \\sum_{k} e^{-i k R_j} \\hat{c}_{k,\\sigma}^\\dagger \\right) \\left( \\frac{1}{\\sqrt{N}} \\sum_{k'} e^{i k' R_{j+1}} \\hat{c}_{k',\\sigma} \\right) $$\nUsing $R_{j+1} = R_j + a$, this becomes:\n$$ \\frac{1}{N} \\sum_{k,k',\\sigma} \\hat{c}_{k,\\sigma}^\\dagger \\hat{c}_{k',\\sigma} e^{i k' a} \\sum_{j=0}^{N-1} e^{i(k'-k)R_j} \\;=\\; \\frac{1}{N} \\sum_{k,k',\\sigma} \\hat{c}_{k,\\sigma}^\\dagger \\hat{c}_{k',\\sigma} e^{i k' a} (N \\delta_{k,k'}) \\;=\\; \\sum_{k,\\sigma} e^{i k a} \\hat{n}_{k,\\sigma} $$\nThe hermitian conjugate term, $\\sum_{j,\\sigma} \\hat{c}_{j+1,\\sigma}^\\dagger \\hat{c}_{j,\\sigma}$, yields $\\sum_{k,\\sigma} e^{-i k a} \\hat{n}_{k,\\sigma}$.\n\nCombining all terms, the full Hamiltonian is:\n$$ H \\;=\\; \\sum_{k,\\sigma} \\epsilon \\, \\hat{n}_{k,\\sigma} - t \\sum_{k,\\sigma} (e^{i k a} + e^{-i k a}) \\hat{n}_{k,\\sigma} \\;=\\; \\sum_{k,\\sigma} (\\epsilon - 2t \\cos(ka)) \\hat{n}_{k,\\sigma} $$\nThis confirms the block-diagonal structure of the Hamiltonian in momentum space:\n$$ H \\;=\\; \\sum_{k} \\sum_{\\sigma \\in \\{\\uparrow,\\downarrow\\}} E(k) \\, \\hat{n}_{k,\\sigma}, \\qquad \\text{with } E(k) = \\epsilon - 2 t \\cos(k a) $$\nThis derivation validates the energy dispersion relation provided. Each $k$-sector is independent. In a VQE simulation, instead of simulating the full $2N$-qubit system, we can simulate each $k$-sector individually. For each $k$, there are two spin-orbitals ($\\uparrow$ and $\\downarrow$), which map to $Q_k=2$ qubits. This provides a significant saving in qubit resources compared to the $Q_{\\text{full}} = 2N$ qubits required for a naive real-space simulation.\n\nThe computational procedure is as follows:\nFor each test case $(N, a, \\epsilon, t)$:\n1.  Calculate the qubit count for the full system, $Q_{\\text{full}} = 2N$, and for a single $k$-sector, $Q_k = 2$.\n2.  Compute the absolute qubit savings, $S = Q_{\\text{full}} - Q_k = 2N - 2$, and the savings ratio, $r = S / Q_{\\text{full}} = 1 - 1/N$.\n3.  Generate the discrete grid of crystal momenta $k_m = \\frac{2\\pi m}{Na}$ for $m = 0, 1, \\dots, N-1$.\n4.  For each $k_m$ on this grid, calculate the energy $E(k_m) = \\epsilon - 2t\\cos(k_m a)$. Note that the argument of the cosine function is $k_m a = \\frac{2\\pi m}{N}$, which is independent of the lattice constant $a$.\n5.  Determine the minimum and maximum values of this set of energies, $E_{\\min} = \\min_{m} E(k_m)$ and $E_{\\max} = \\max_{m} E(k_m)$.\n6.  Round the values of $r$, $E_{\\min}$, and $E_{\\max}$ to six decimal places.\n7.  Aggregate the results $[Q_{\\text{full}}, Q_k, S, r, E_{\\min}, E_{\\max}]$ for each test case into a final list.\n\nThe extrema of the energy band $E(k) = \\epsilon - 2t \\cos(ka)$ depend on the extrema of the cosine term over the discrete $k$-grid.\n- For $t>0$, $E(k)$ is minimized when $\\cos(ka)$ is maximized. The maximum value is $\\cos(0) = 1$ (for $m=0$), yielding $E_{\\min} = \\epsilon - 2t$.\n- For $t>0$, $E(k)$ is maximized when $\\cos(ka)$ is minimized. The minimum value of $\\cos(\\frac{2\\pi m}{N})$ over the grid determines $E_{\\max}$. If $N$ is even, the minimum is $\\cos(\\pi) = -1$, yielding $E_{\\max} = \\epsilon + 2t$. If $N$ is odd, the minimum is $\\cos(\\frac{2\\pi \\lfloor N/2 \\rfloor}{N})$.\nIf $t=0$, the band is flat, and $E(k) = \\epsilon$ for all $k$, so $E_{\\min} = E_{\\max} = \\epsilon$.\nThe implementation will numerically compute all energies and find the minimum and maximum directly, which is robust for all cases.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy is not required for this problem.\n\ndef solve():\n    \"\"\"\n    Computes VQE-related properties for a 1D periodic hydrogen chain\n    for a given set of test cases, leveraging translational symmetry.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Format: (N, a, epsilon, t)\n    # N: number of unit cells (integer)\n    # a: lattice constant in angstroms (float)\n    # epsilon: on-site energy in eV (float)\n    # t: nearest-neighbor hopping amplitude in eV (float)\n    test_cases = [\n        (8, 1.0, -0.3, 1.5),\n        (3, 1.4, 0.0, 1.0),\n        (4, 1.2, -0.5, 0.0),\n        (16, 0.74, -0.1, 2.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, a, epsilon, t = case\n\n        # --- Qubit Resource Calculation ---\n        # Qubits for full real-space simulation\n        Q_full = 2 * N\n        # Qubits for a single k-sector simulation\n        Q_k = 2\n        # Qubit savings\n        S = Q_full - Q_k\n        # Savings ratio\n        if N > 0:\n            r = S / Q_full\n        else:\n            r = 0.0 # Avoid division by zero, though N > 0 is implied.\n\n        # --- Energy Band Calculation ---\n        # m ranges from 0 to N-1\n        m_values = np.arange(N)\n        \n        # The argument for the cosine function is k*a = (2*pi*m / (N*a)) * a = 2*pi*m / N\n        # The lattice constant 'a' cancels out.\n        cos_args = 2 * np.pi * m_values / N\n        \n        # Calculate energies for all k-points\n        # E(k) = epsilon - 2*t*cos(k*a)\n        energies = epsilon - 2 * t * np.cos(cos_args)\n        \n        # Find the minimum and maximum of the discrete band energies\n        E_min = np.min(energies)\n        E_max = np.max(energies)\n\n        # --- Rounding and Formatting ---\n        # Round r, E_min, E_max to six decimal places as required.\n        r_rounded = round(r, 6)\n        E_min_rounded = round(E_min, 6)\n        E_max_rounded = round(E_max, 6)\n\n        # Append the list of results for the current case\n        case_result = [Q_full, Q_k, S, r_rounded, E_min_rounded, E_max_rounded]\n        results.append(case_result)\n\n    # Final print statement in the exact required format.\n    # The string representation of a list of lists in Python matches the desired output.\n    # Using join and map to construct the string representation as per the template.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3481667"}, {"introduction": "Once a Hamiltonian is mapped to a manageable number of qubits, the next practical challenge is to measure its expectation value efficiently. A quantum computer can only measure a subset of Pauli operators simultaneously, meaning a naive approach would require an enormous number of circuit executions. This exercise [@problem_id:3481711] tackles this measurement problem head-on by having you implement a grouping strategy based on qubit-wise commutativity, a cornerstone of modern VQE software, to minimize the total number of measurements and thus the overall runtime.", "problem": "You are tasked with designing and analyzing a measurement strategy for estimating the ground-state energy expectation of an extended Hubbard Hamiltonian within the framework of the Variational Quantum Eigensolver (VQE), using qubit-wise commuting measurement grouping via graph coloring. You must implement an algorithmic approach that starts from standard second-quantized fermionic definitions and the Jordan–Wigner transformation, builds a conflict graph of Pauli strings under the qubit-wise commuting criterion, colors that graph to form measurement groups, and then derives an optimal-shot allocation across these groups to meet a specified energy precision target. Your final program must compute and output the total shot cost for multiple test cases.\n\nFundamental base:\nConsider a one-dimensional chain of length $L$ with spinful electrons. Let $t$ denote the hopping amplitude, $U$ the on-site interaction strength, and $V$ the nearest-neighbor density–density interaction strength. The extended Hubbard Hamiltonian in second quantization is\n$$\nH = -t \\sum_{i=0}^{L-2} \\sum_{\\sigma \\in \\{\\uparrow,\\downarrow\\}} \\left( a_{i,\\sigma}^{\\dagger} a_{i+1,\\sigma} + a_{i+1,\\sigma}^{\\dagger} a_{i,\\sigma} \\right)\n+ U \\sum_{i=0}^{L-1} n_{i,\\uparrow} n_{i,\\downarrow}\n+ V \\sum_{i=0}^{L-2} \\sum_{\\sigma,\\sigma' \\in \\{\\uparrow,\\downarrow\\}} n_{i,\\sigma} n_{i+1,\\sigma'} ,\n$$\nwhere $a_{i,\\sigma}^{\\dagger}$ and $a_{i,\\sigma}$ are fermionic creation and annihilation operators, and $n_{i,\\sigma} = a_{i,\\sigma}^{\\dagger} a_{i,\\sigma}$ is the number operator.\n\nMapping to qubits:\nAdopt the Jordan–Wigner transformation with a fixed orbital ordering by site and spin, where each site $i \\in \\{0,\\dots,L-1\\}$ has two orbitals: spin-up and spin-down. The total number of qubits is $N_q = 2L$, and the orbital-to-qubit index mapping is\n$$\np(i,\\sigma) = \\begin{cases}\n2i & \\text{for } \\sigma = \\uparrow,\\\\\n2i+1 & \\text{for } \\sigma = \\downarrow.\n\\end{cases}\n$$\nThe Jordan–Wigner mapping uses the following well-tested identities:\n$$\na_p = \\left( \\prod_{q=0}^{p-1} Z_q \\right) \\frac{X_p + i Y_p}{2}, \\quad\na_p^{\\dagger} = \\left( \\prod_{q=0}^{p-1} Z_q \\right) \\frac{X_p - i Y_p}{2}, \\quad\nn_p = a_p^{\\dagger} a_p = \\frac{1 - Z_p}{2}.\n$$\nFor nearest-neighbor hopping with $p<q$, one obtains\n$$\na_p^{\\dagger} a_q + a_q^{\\dagger} a_p = \\frac{1}{2}\\left( X_p \\left( \\prod_{r=p+1}^{q-1} Z_r \\right) X_q + Y_p \\left( \\prod_{r=p+1}^{q-1} Z_r \\right) Y_q \\right),\n$$\nso that the corresponding Pauli strings for hopping carry coefficients $-t/2$. The interaction terms expand via $n_p n_q = \\frac{1}{4}\\left(1 - Z_p - Z_q + Z_p Z_q\\right)$, yielding diagonal Pauli strings in the $Z$ basis with coefficients proportional to $U/4$ or $V/4$. The constant terms (the identity operator) are known exactly and have zero measurement variance; they are excluded from the shot-cost calculation.\n\nMeasurement grouping via qubit-wise commutativity:\nRepresent the Hamiltonian as $H = \\sum_{i} c_i P_i$, where each $P_i$ is a tensor product of single-qubit Pauli operators in $\\{I,X,Y,Z\\}$. Two Pauli strings $P$ and $Q$ are said to be qubit-wise commuting (QWC) if for every qubit index $k$, either $P_k = I$, or $Q_k = I$, or $P_k = Q_k$. This criterion ensures a shared product measurement basis can be chosen that simultaneously measures all strings in a group. Build a conflict graph whose vertices correspond to the non-identity Pauli strings derived from $H$, and whose edges connect pairs that are not QWC. Color this graph using a greedy coloring strategy (ordering vertices by descending degree), and take each color class as one measurement group.\n\nShot-cost estimation for target energy precision:\nAssume the energy estimator is formed by independently sampling each measurement group $G_k$ for $N_k$ shots and aggregating unbiased estimates of $\\langle P_i \\rangle$. A conservative and widely used bound for the single-shot variance of the weighted sum within a group is\n$$\nV_k \\le \\sum_{i \\in G_k} c_i^2,\n$$\nwhich follows from $\\mathrm{Var}(P_i) \\le 1$ for Pauli observables with outcomes in $\\{-1,+1\\}$ and bounding covariances. Under the constraint\n$$\n\\sum_{k} \\frac{V_k}{N_k} \\le \\epsilon^2,\n$$\nthe total number of shots $S = \\sum_k N_k$ is minimized by the optimal allocation\n$$\nN_k = \\sqrt{\\lambda V_k}, \\quad \\sqrt{\\lambda} = \\frac{\\sum_{j} \\sqrt{V_j}}{\\epsilon^2},\n$$\nyielding the minimal total shot cost\n$$\nS_{\\min} = \\frac{\\left( \\sum_{k} \\sqrt{V_k} \\right)^2}{\\epsilon^2}.\n$$\nYou must report the integer shot cost by applying the ceiling function to $S_{\\min}$, and return $0$ if there are no non-identity Pauli strings.\n\nAlgorithmic requirements:\nStarting from $L$, $t$, $U$, $V$, and $\\epsilon$, implement the Jordan–Wigner mapping as specified to generate all non-identity Pauli strings and their real coefficients $c_i$ for the given Hamiltonian. Merge identical Pauli strings by summing coefficients. Construct the conflict graph under the QWC criterion, color it greedily, compute $V_k = \\sum_{i \\in G_k} c_i^2$ for each color group, and then compute $S = \\lceil ( \\sum_k \\sqrt{V_k} )^2 / \\epsilon^2 \\rceil$. If the Hamiltonian reduces to a constant (no non-identity strings), return $0$ shots.\n\nAngle units are not involved in this problem. There are no physical unit conversions; all quantities are dimensionless.\n\nTest suite:\nCompute the total shot costs for the following parameter sets:\n$1.$ $L=2$, $t=1.0$, $U=4.0$, $V=1.0$, $\\epsilon=0.01$.\n$2.$ $L=3$, $t=1.0$, $U=0.0$, $V=0.0$, $\\epsilon=0.02$.\n$3.$ $L=1$, $t=0.0$, $U=3.0$, $V=0.0$, $\\epsilon=0.001$.\n$4.$ $L=4$, $t=0.5$, $U=2.0$, $V=0.5$, $\\epsilon=0.005$.\n$5.$ $L=2$, $t=0.0$, $U=0.0$, $V=0.0$, $\\epsilon=0.01$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $\\left[\\text{result1},\\text{result2},\\text{result3}\\right]$). Each result must be the integer total shot count for the corresponding test case, in the same order as listed above.", "solution": "The user-provided problem is a well-defined task in computational quantum physics, specifically concerning the resource estimation for running a Variational Quantum Eigensolver (VQE) algorithm on an extended Hubbard model. The problem statement is scientifically sound, internally consistent, and provides all necessary information to construct a unique, algorithmic solution. It is therefore deemed a valid problem.\n\nThe solution proceeds systematically through the following steps:\n1.  **Hamiltonian Construction via Jordan-Wigner Transformation**: The second-quantized extended Hubbard Hamiltonian is transformed into a qubit Hamiltonian, which is a sum of multi-qubit Pauli operators (Pauli strings) with real coefficients.\n2.  **Conflict Graph Generation**: A conflict graph is constructed based on the qubit-wise commutativity (QWC) criterion. The vertices of this graph are the non-identity Pauli strings from the Hamiltonian. An edge connects two vertices if the corresponding Pauli strings are not QWC.\n3.  **Greedy Graph Coloring**: The conflict graph is colored using a greedy algorithm. Vertices are ordered by decreasing degree to prioritize coloring the most constrained Pauli strings first. Each color class forms a measurement group, as all Pauli strings within it are mutually QWC.\n4.  **Optimal Shot Allocation and Cost Calculation**: For each measurement group, a variance upper bound is calculated. Using these variances and the target energy precision $\\epsilon$, the optimal shot distribution is determined to minimize the total number of measurements (shots). The total shot cost is then calculated and rounded up to the nearest integer.\n\nWe detail these steps below.\n\n### 1. Qubit Hamiltonian Formulation\n\nThe extended Hubbard Hamiltonian is given by:\n$$\nH = -t \\sum_{i=0}^{L-2} \\sum_{\\sigma \\in \\{\\uparrow,\\downarrow\\}} \\left( a_{i,\\sigma}^{\\dagger} a_{i+1,\\sigma} + a_{i+1,\\sigma}^{\\dagger} a_{i,\\sigma} \\right)\n+ U \\sum_{i=0}^{L-1} n_{i,\\uparrow} n_{i,\\downarrow}\n+ V \\sum_{i=0}^{L-2} \\sum_{\\sigma,\\sigma' \\in \\{\\uparrow,\\downarrow\\}} n_{i,\\sigma} n_{i+1,\\sigma'}\n$$\nThe system has $L$ sites, and with spin, this corresponds to $2L$ spin-orbitals. Using the specified Jordan-Wigner (JW) mapping, we map these $2L$ orbitals to $N_q = 2L$ qubits. The qubit index $p$ for a spin-orbital at site $i$ with spin $\\sigma$ is $p(i,\\sigma) = 2i$ for $\\sigma=\\uparrow$ and $p(i,\\sigma) = 2i+1$ for $\\sigma=\\downarrow$.\n\nThe JW transformation rules provided are applied to each term of $H$:\n\n- **Hopping Term ($t$)**: For each site $i \\in [0, L-2]$ and spin $\\sigma$, we have a term $-t(a_{i,\\sigma}^{\\dagger} a_{i+1,\\sigma} + h.c.)$. Let $p = p(i,\\sigma)$ and $q = p(i+1,\\sigma)$. The JW transformation yields:\n$$\na_p^{\\dagger} a_q + a_q^{\\dagger} a_p = \\frac{1}{2}\\left( X_p \\left( \\prod_{r=p+1}^{q-1} Z_r \\right) X_q + Y_p \\left( \\prod_{r=p+1}^{q-1} Z_r \\right) Y_q \\right)\n$$\nEach of these two Pauli strings receives a coefficient of $-t/2$.\n\n- **On-site Interaction Term ($U$)**: For each site $i \\in [0, L-1]$, we have $U n_{i,\\uparrow} n_{i,\\downarrow}$. Let $p = p(i,\\uparrow)=2i$ and $q = p(i,\\downarrow)=2i+1$. The number operator is $n_k = (1-Z_k)/2$. The product becomes:\n$$\nU n_p n_q = U \\frac{1 - Z_p}{2} \\frac{1 - Z_q}{2} = \\frac{U}{4} (I - Z_p - Z_q + Z_p Z_q)\n$$\nThis contributes three non-identity Pauli strings: $Z_p$ with coefficient $-U/4$, $Z_q$ with coefficient $-U/4$, and $Z_p Z_q$ with coefficient $U/4$. The identity term $I$ is excluded from the measurement analysis as its expectation value is known exactly and has zero variance.\n\n- **Nearest-Neighbor Interaction Term ($V$)**: For each site $i \\in [0, L-2]$, we have $V \\sum_{\\sigma,\\sigma'} n_{i,\\sigma} n_{i+1,\\sigma'}$. This term can be rewritten as $V(n_{i,\\uparrow}+n_{i,\\downarrow})(n_{i+1,\\uparrow}+n_{i+1,\\downarrow})$. Let $p_0=2i, p_1=2i+1, q_0=2(i+1), q_1=2(i+1)+1$. The term is $V(n_{p_0}+n_{p_1})(n_{q_0}+n_{q_1})$. Expanding this using $n_k=(1-Z_k)/2$ leads to numerous Pauli-Z terms. A systematic expansion results in:\n    - single-qubit terms $Z_k$ for $k \\in \\{p_0, p_1, q_0, q_1\\}$, each with coefficient $-V/2$.\n    - two-qubit terms $Z_{p_\\alpha}Z_{q_\\beta}$ for $\\alpha,\\beta \\in \\{0,1\\}$, each with coefficient $V/4$.\nThese terms are generated for each $i$ and aggregated. Identical Pauli strings arising from different physical terms have their coefficients summed.\n\n### 2. Measurement Grouping via Graph Coloring\n\nThe resulting qubit Hamiltonian is $H = \\sum_j c_j P_j$. To estimate $\\langle H \\rangle$, we need to measure each $\\langle P_j \\rangle$. We group the Pauli strings $P_j$ to reduce the number of distinct measurement settings.\n\n- **Qubit-Wise Commutativity (QWC)**: Two Pauli strings $P_A$ and $P_B$ are QWC if, for every qubit position $k$, their respective single-qubit operators $P_{A,k}$ and $P_{B,k}$ commute. This is satisfied if at least one of them is the identity $I$, or if they are the same operator ($P_{A,k} = P_{B,k}$). For distinct non-identity operators, $\\{X,Y,Z\\}$, any pair does not commute. Thus, the condition simplifies: $P_A$ and $P_B$ are QWC if there is no position $k$ where $P_{A,k} \\neq I$, $P_{B,k} \\neq I$, and $P_{A,k} \\neq P_{B,k}$.\n\n- **Conflict Graph**: We build a graph where each vertex represents a non-identity Pauli string $P_j$. An edge is placed between two vertices if their corresponding Pauli strings are *not* QWC.\n\n- **Greedy Coloring**: A greedy coloring algorithm is applied to find a valid vertex coloring of the conflict graph.\n    1. The vertices (Pauli strings) are sorted in descending order of their degree in the conflict graph. Ties are broken by the initial index of the Pauli string.\n    2. We iterate through the sorted vertices. For each vertex $v$, we assign the smallest non-negative integer color that has not been used by any of its already-colored neighbors.\n    3. All vertices assigned the same color form a measurement group. By construction, all Pauli strings in a group are mutually QWC.\n\n### 3. Shot-Cost Estimation\n\nThe total variance of the energy estimate is the sum of the variances for each group: $\\mathrm{Var}(\\langle H \\rangle) = \\sum_k \\mathrm{Var}(\\hat{E}_k)$, where $\\hat{E}_k$ is the energy estimate from group $G_k$. For $N_k$ shots, $\\mathrm{Var}(\\hat{E}_k) = \\sigma_k^2/N_k$, where $\\sigma_k^2$ is the single-shot variance for the group. The problem provides a conservative bound:\n$$\n\\sigma_k^2 \\le V_k = \\sum_{j \\in G_k} c_j^2\n$$\nThe total variance must be less than or equal to the square of the target precision, $\\epsilon^2$:\n$$\n\\sum_k \\frac{V_k}{N_k} \\le \\epsilon^2\n$$\nTo minimize the total shot cost $S = \\sum_k N_k$ subject to this constraint, we use Lagrange multipliers, which gives the optimal allocation:\n$$\nN_k = \\frac{\\sqrt{V_k} \\sum_j \\sqrt{V_j}}{\\epsilon^2}\n$$\nThe minimum total shot cost $S_{\\min}$ is then:\n$$\nS_{\\min} = \\sum_k N_k = \\frac{\\left( \\sum_j \\sqrt{V_j} \\right) \\left( \\sum_k \\sqrt{V_k} \\right)}{\\epsilon^2} = \\frac{\\left( \\sum_k \\sqrt{V_k} \\right)^2}{\\epsilon^2}\n$$\nThe final shot count is the smallest integer greater than or equal to $S_{\\min}$, which is $\\lceil S_{\\min} \\rceil$. If the Hamiltonian contains no non-identity terms (i.e., it is a constant), the shot cost is $0$.\n\nThe implementation of this entire procedure is provided in the final answer code block.", "answer": "```python\nimport numpy as np\nfrom collections import defaultdict\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    \"\"\"\n\n    # Pauli operators are represented by integers: 0:I, 1:X, 2:Y, 3:Z\n    PAULI_I, PAULI_X, PAULI_Y, PAULI_Z = 0, 1, 2, 3\n\n    def build_hamiltonian(L, t, U, V):\n        \"\"\"\n        Constructs the qubit Hamiltonian as a dictionary of {Pauli_tuple: coefficient}.\n        \"\"\"\n        if L == 0:\n            return {}\n            \n        num_qubits = 2 * L\n        hamiltonian = defaultdict(float)\n\n        def add_pauli(p_str, coeff):\n            hamiltonian[p_str] += coeff\n        \n        # Helper to create a Pauli string from a dict of {qubit_idx: operator}\n        def create_pauli(op_dict):\n            p_list = [PAULI_I] * num_qubits\n            for q_idx, op in op_dict.items():\n                p_list[q_idx] = op\n            return tuple(p_list)\n\n        # 1. Hopping term (-t)\n        if t != 0.0:\n            for i in range(L - 1):\n                for sigma in range(2):  # 0 for up, 1 for down\n                    p = 2 * i + sigma\n                    q = 2 * (i + 1) + sigma\n                    \n                    z_chain = {r: PAULI_Z for r in range(p + 1, q)}\n                    \n                    # X_p ... Z ... X_q term\n                    op_dict_x = z_chain.copy()\n                    op_dict_x[p] = PAULI_X\n                    op_dict_x[q] = PAULI_X\n                    add_pauli(create_pauli(op_dict_x), -t / 2.0)\n                    \n                    # Y_p ... Z ... Y_q term\n                    op_dict_y = z_chain.copy()\n                    op_dict_y[p] = PAULI_Y\n                    op_dict_y[q] = PAULI_Y\n                    add_pauli(create_pauli(op_dict_y), -t / 2.0)\n\n        # 2. On-site interaction term (U)\n        if U != 0.0:\n            for i in range(L):\n                p_up = 2 * i\n                p_down = 2 * i + 1\n                \n                # -U/4 * Z_p\n                add_pauli(create_pauli({p_up: PAULI_Z}), -U / 4.0)\n                # -U/4 * Z_q\n                add_pauli(create_pauli({p_down: PAULI_Z}), -U / 4.0)\n                # +U/4 * Z_p * Z_q\n                add_pauli(create_pauli({p_up: PAULI_Z, p_down: PAULI_Z}), U / 4.0)\n\n        # 3. Nearest-neighbor interaction term (V)\n        if V != 0.0:\n            for i in range(L - 1):\n                # (n_i,up + n_i,down) * (n_i+1,up + n_i+1,down)\n                # n_i,s = (1 - Z_p(i,s))/2\n                # Sum over sigma, sigma' of n_i,s * n_i+1,s'\n                qubits_i = [2 * i, 2 * i + 1]\n                qubits_i1 = [2 * (i + 1), 2 * (i + 1) + 1]\n                \n                for p in qubits_i:\n                    for q in qubits_i1:\n                        # V * n_p * n_q = V/4 * (1 - Zp - Zq + ZpZq)\n                        add_pauli(create_pauli({p: PAULI_Z}), -V / 4.0)\n                        add_pauli(create_pauli({q: PAULI_Z}), -V / 4.0)\n                        add_pauli(create_pauli({p: PAULI_Z, q: PAULI_Z}), V / 4.0)\n        \n        # Clean up terms with coefficients close to zero\n        final_hamiltonian = {p: c for p, c in hamiltonian.items() if not np.isclose(c, 0)}\n        return final_hamiltonian\n\n    def are_qwc(p1, p2):\n        \"\"\"Checks if two Pauli strings are qubit-wise commuting.\"\"\"\n        for op1, op2 in zip(p1, p2):\n            if op1 != PAULI_I and op2 != PAULI_I and op1 != op2:\n                return False\n        return True\n\n    def calculate_shot_cost(L, t, U, V, epsilon):\n        \"\"\"\n        Performs the full calculation pipeline for a single test case.\n        \"\"\"\n        hamiltonian = build_hamiltonian(L, t, U, V)\n        \n        if not hamiltonian:\n            return 0\n        \n        pauli_list = list(hamiltonian.keys())\n        coeffs = list(hamiltonian.values())\n        num_paulis = len(pauli_list)\n\n        # Build conflict graph\n        adj = [[] for _ in range(num_paulis)]\n        degrees = [0] * num_paulis\n        for i in range(num_paulis):\n            for j in range(i + 1, num_paulis):\n                if not are_qwc(pauli_list[i], pauli_list[j]):\n                    adj[i].append(j)\n                    adj[j].append(i)\n                    degrees[i] += 1\n                    degrees[j] += 1\n        \n        # Greedy coloring\n        # Order vertices by decreasing degree (stable sort breaks ties by original index)\n        sorted_vertices = sorted(range(num_paulis), key=lambda i: degrees[i], reverse=True)\n        \n        colors = [-1] * num_paulis\n        num_colors = 0\n        \n        for i in sorted_vertices:\n            neighbor_colors = {colors[j] for j in adj[i] if colors[j] != -1}\n            \n            c = 0\n            while True:\n                if c not in neighbor_colors:\n                    # Check if this vertex is QWC with all other vertices of this color\n                    is_compatible = True\n                    for j in range(num_paulis):\n                        if colors[j] == c:\n                            if not are_qwc(pauli_list[i], pauli_list[j]):\n                                is_compatible = False\n                                break\n                    if is_compatible:\n                        colors[i] = c\n                        if c + 1 > num_colors:\n                            num_colors = c + 1\n                        break\n                c += 1\n\n        # Calculate group variances (V_k)\n        group_variances = [0.0] * num_colors\n        for i in range(num_paulis):\n            color = colors[i]\n            group_variances[color] += coeffs[i]**2\n        \n        # Calculate total shot cost\n        sum_sqrt_V = sum(np.sqrt(v) for v in group_variances if v > 0)\n        s_min = (sum_sqrt_V**2) / (epsilon**2)\n        \n        return int(np.ceil(s_min))\n\n    test_cases = [\n        (2, 1.0, 4.0, 1.0, 0.01),\n        (3, 1.0, 0.0, 0.0, 0.02),\n        (1, 0.0, 3.0, 0.0, 0.001),\n        (4, 0.5, 2.0, 0.5, 0.005),\n        (2, 0.0, 0.0, 0.0, 0.01),\n    ]\n\n    results = []\n    for L, t, U, V, epsilon in test_cases:\n        result = calculate_shot_cost(L, t, U, V, epsilon)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3481711"}]}