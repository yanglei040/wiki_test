{"hands_on_practices": [{"introduction": "A critical first step in setting up any cosmological simulation is choosing the initial redshift $z_i$. This choice is not arbitrary; it must guarantee that the perturbative theory used to generate the initial conditions is well within its regime of validity. The following exercise [@problem_id:3468236] guides you through deriving the criteria for selecting an appropriate $z_i$, ensuring that initial particle displacements are small and that higher-order corrections from Lagrangian Perturbation Theory (LPT) remain subdominant.", "problem": "You are preparing constrained initial conditions for a cosmological $N$-body simulation of the local universe, where the displacement field is reconstructed from observed peculiar velocities via a Wiener filter and augmented with small-scale modes. To ensure reliable initialization, the starting redshift $z_i$ must be chosen so that two requirements are simultaneously satisfied at the beginning of the simulation.\n\nBase the analysis on Lagrangian Perturbation Theory (LPT), which models the comoving mapping from Lagrangian coordinates $\\boldsymbol{q}$ to Eulerian coordinates $\\boldsymbol{x}$ at scale factor $a$ as a perturbative series in the displacement field, with first-order (Zel’dovich) and second-order corrections characterized by growth factors. Assume the early-time expansion is well described by an Einstein–de Sitter (EdS) universe, normalized such that the first-order growth factor is $D_1(1)=1$, and the second-order growth factor is $D_2(1)=-\\frac{3}{7}$ (standard EdS normalization). Define the Root Mean Square (RMS) over the simulation volume.\n\nImpose the following two criteria at $a_i$, the scale factor corresponding to the starting redshift $z_i$:\n\n1. The maximum first-order (1LPT) particle displacement at $a_i$ is a small fraction of the grid spacing, i.e.,\n$$\n|D_1(a_i)|\\, s_{\\max} \\le \\epsilon\\, \\Delta,\n$$\nwhere $s_{\\max}$ is the maximum magnitude of the reconstructed 1LPT displacement field at $z=0$, $\\Delta$ is the comoving grid spacing, and $\\epsilon$ is a chosen fraction.\n\n2. The RMS amplitude of the second-order (2LPT) correction at $a_i$ is subdominant to the RMS amplitude of the 1LPT term,\n$$\n|D_2(a_i)|\\, \\sigma_t \\le \\eta\\, |D_1(a_i)|\\, \\sigma_s,\n$$\nwhere $\\sigma_s$ and $\\sigma_t$ are the RMS magnitudes of the 1LPT and 2LPT displacement fields at $z=0$, respectively, and $\\eta$ is a chosen small number quantifying the desired subdominance at start.\n\nAssume EdS growth at early times and adopt the standard EdS scalings for $D_1(a)$ and $D_2(a)$ with the above normalization. Derive, from first principles, a closed-form expression for the minimal $z_i$ that simultaneously satisfies both criteria. Then evaluate the expression using the following scientifically plausible parameters for a local-universe constrained setup:\n- Grid spacing $\\Delta = 0.5 \\, h^{-1}\\,\\mathrm{Mpc}$,\n- Fraction $\\epsilon = 0.2$,\n- Maximum 1LPT displacement at $z=0$, $s_{\\max} = 5.0 \\, h^{-1}\\,\\mathrm{Mpc}$,\n- RMS 1LPT displacement at $z=0$, $\\sigma_s = 1.5 \\, h^{-1}\\,\\mathrm{Mpc}$,\n- RMS 2LPT displacement at $z=0$, $\\sigma_t = 3.0 \\, h^{-1}\\,\\mathrm{Mpc}$,\n- Subdominance parameter $\\eta = 0.1$.\n\nExpress the final answer as the dimensionless number $z_i$ rounded to three significant figures. No units should be included in the final answer.", "solution": "The problem statement is assessed to be valid. It is scientifically grounded in standard cosmological perturbation theory, well-posed with a clear objective and sufficient data, and free from internal contradictions or ambiguities. The parameters provided are physically plausible for simulations of the local universe.\n\nThe goal is to determine the minimal starting redshift $z_i$ for an $N$-body simulation, which corresponds to the maximal starting scale factor $a_i = (1+z_i)^{-1}$, such that two criteria are simultaneously met. The analysis is based on an Einstein–de Sitter (EdS) model for the early universe.\n\nIn an EdS universe, the first-order (1LPT) and second-order (2LPT) growth factors scale with the scale factor $a$ as $D_1(a) \\propto a$ and $D_2(a) \\propto a^2$. The problem provides the normalization at the present day ($z=0$, corresponding to $a=1$): $D_1(1)=1$ and $D_2(1)=-3/7$. Using this normalization, we can write the explicit expressions for the growth factors at any scale factor $a$:\n$$\nD_1(a) = D_1(1) \\left(\\frac{a}{1}\\right) = a\n$$\n$$\nD_2(a) = D_2(1) \\left(\\frac{a}{1}\\right)^2 = -\\frac{3}{7}a^2\n$$\nThe absolute values of these growth factors at the initial scale factor $a_i$ are therefore:\n$$\n|D_1(a_i)| = a_i\n$$\n$$\n|D_2(a_i)| = \\left|-\\frac{3}{7}a_i^2\\right| = \\frac{3}{7}a_i^2\n$$\nsince $a_i$ is positive.\n\nWe now apply the two criteria at the initial scale factor $a_i$.\n\n**Criterion 1: Maximum 1LPT displacement**\nThe first criterion limits the maximum particle displacement at the start of the simulation:\n$$\n|D_1(a_i)|\\, s_{\\max} \\le \\epsilon\\, \\Delta\n$$\nSubstituting $|D_1(a_i)| = a_i$, we get:\n$$\na_i\\, s_{\\max} \\le \\epsilon\\, \\Delta\n$$\nThis imposes an upper bound on the initial scale factor $a_i$:\n$$\na_i \\le \\frac{\\epsilon \\Delta}{s_{\\max}}\n$$\n\n**Criterion 2: Subdominance of 2LPT correction**\nThe second criterion ensures that the second-order correction to the displacement field is subdominant to the first-order term in an RMS sense:\n$$\n|D_2(a_i)|\\, \\sigma_t \\le \\eta\\, |D_1(a_i)|\\, \\sigma_s\n$$\nSubstituting the expressions for $|D_1(a_i)|$ and $|D_2(a_i)|$:\n$$\n\\left(\\frac{3}{7}a_i^2\\right) \\sigma_t \\le \\eta\\, a_i\\, \\sigma_s\n$$\nSince $a_i > 0$, we can divide both sides by $a_i$ without changing the inequality direction:\n$$\n\\frac{3}{7}a_i\\, \\sigma_t \\le \\eta\\, \\sigma_s\n$$\nThis yields a second upper bound on $a_i$:\n$$\na_i \\le \\frac{7 \\eta \\sigma_s}{3 \\sigma_t}\n$$\n\n**Combined Constraint and Minimal Redshift**\nFor the simulation to be validly initialized, both criteria must be satisfied simultaneously. This means $a_i$ must be less than or equal to both derived upper bounds. The most restrictive constraint determines the maximum allowable value for $a_i$:\n$$\na_{i, \\text{max}} = \\min\\left(\\frac{\\epsilon \\Delta}{s_{\\max}}, \\frac{7 \\eta \\sigma_s}{3 \\sigma_t}\\right)\n$$\nThe relationship between redshift $z$ and scale factor $a$ is $z = a^{-1} - 1$. This is a monotonically decreasing function. Therefore, the minimal starting redshift $z_i$ corresponds to the maximal starting scale factor $a_{i, \\text{max}}$.\n$$\nz_i = \\frac{1}{a_{i, \\text{max}}} - 1 = \\frac{1}{\\min\\left(\\frac{\\epsilon \\Delta}{s_{\\max}}, \\frac{7 \\eta \\sigma_s}{3 \\sigma_t}\\right)} - 1\n$$\nThis expression can be rewritten using the property that $1/\\min(x,y) = \\max(1/x, 1/y)$:\n$$\nz_i = \\max\\left(\\frac{s_{\\max}}{\\epsilon \\Delta}, \\frac{3 \\sigma_t}{7 \\eta \\sigma_s}\\right) - 1\n$$\nThis is the desired closed-form expression for the minimal starting redshift $z_i$.\n\n**Numerical Evaluation**\nWe now substitute the given parameter values into this expression. The parameters are:\n- $\\Delta = 0.5 \\, h^{-1}\\,\\mathrm{Mpc}$\n- $\\epsilon = 0.2$\n- $s_{\\max} = 5.0 \\, h^{-1}\\,\\mathrm{Mpc}$\n- $\\sigma_s = 1.5 \\, h^{-1}\\,\\mathrm{Mpc}$\n- $\\sigma_t = 3.0 \\, h^{-1}\\,\\mathrm{Mpc}$\n- $\\eta = 0.1$\n\nAll length units ($h^{-1}\\,\\mathrm{Mpc}$) cancel out in the ratios, leaving dimensionless quantities as required.\nLet's evaluate the two arguments of the $\\max$ function.\n\nFirst argument (from Criterion 1):\n$$\n\\frac{s_{\\max}}{\\epsilon \\Delta} = \\frac{5.0}{0.2 \\times 0.5} = \\frac{5.0}{0.1} = 50\n$$\n\nSecond argument (from Criterion 2):\n$$\n\\frac{3 \\sigma_t}{7 \\eta \\sigma_s} = \\frac{3 \\times 3.0}{7 \\times 0.1 \\times 1.5} = \\frac{9.0}{1.05} = \\frac{900}{105} = \\frac{180}{21} = \\frac{60}{7} \\approx 8.5714\n$$\n\nWe now take the maximum of these two values:\n$$\n\\max\\left(50, \\frac{60}{7}\\right) = 50\n$$\nThe first criterion is the more restrictive one. Therefore, the minimum value for $1+z_i$ is $50$.\nThe minimal starting redshift is:\n$$\nz_i = 50 - 1 = 49\n$$\nThe problem requires the answer to be rounded to three significant figures. The exact value is $49$. Expressed with three significant figures, this is $49.0$.", "answer": "$$\n\\boxed{49.0}\n$$", "id": "3468236"}, {"introduction": "At the heart of generating constrained initial conditions lies the ability to translate observational data, such as galaxy peculiar velocities, into a corresponding initial density field. This is typically accomplished using linear operators constructed from cosmological covariance matrices. This hands-on coding exercise [@problem_id:3468238] focuses on implementing the cross-covariance operator $\\mathbf{S}\\mathbf{C}^{\\top}$ which links observed radial velocities to the underlying density field, a task performed efficiently in Fourier space using Fast Fourier Transforms (FFTs).", "problem": "Consider a statistically homogeneous and isotropic Gaussian initial density contrast field $\\delta(\\mathbf{x})$ in a periodic cubic box of side length $L$ discretized on a uniform $\\mathbb{Z}^3$ grid with $N^3$ points. In the linear regime of cosmological perturbation theory, the peculiar velocity field $\\mathbf{v}(\\mathbf{x})$ is related to $\\delta(\\mathbf{x})$ through the continuity equation. Under the plane-parallel approximation with a fixed line-of-sight direction aligned with the $\\hat{\\mathbf{z}}$ axis, the observational response operator $\\mathbf{C}$ maps $\\mathbf{v}(\\mathbf{x})$ to the radial velocity scalar field $v_r(\\mathbf{x})$ via $v_r(\\mathbf{x}) = \\hat{\\mathbf{z}} \\cdot \\mathbf{v}(\\mathbf{x})$. Let the growth prefactor $g$ denote the combination $g \\equiv a f H$, where $a$ is the scale factor, $f$ is the logarithmic growth rate, and $H$ is the Hubble parameter, all evaluated at a single epoch.\n\nAssume linear theory, periodic boundary conditions, and Fast Fourier Transform (FFT) conventions consistent with the discrete Fourier transform implemented by numerical libraries. In Fourier space, the relation between the peculiar velocity and the density contrast is well-tested at large scales and can be written as $\\mathbf{v}(\\mathbf{k}) = g \\, i \\, \\frac{\\mathbf{k}}{k^2} \\, \\delta(\\mathbf{k})$, where $\\mathbf{k}$ is the wavevector, $k = \\|\\mathbf{k}\\|$, and $i$ is the imaginary unit. The signal covariance of the density field is diagonal in Fourier space with power spectrum $P(k)$, so that $S(\\mathbf{k}) = P(k)$. The cross-covariance operator $\\mathbf{S}\\mathbf{C}^{\\top}$ acting on a real-space radial velocity field $d(\\mathbf{x})$ can be implemented as a convolution whose Fourier-space kernel is proportional to $i \\mathbf{k}/k^2$ multiplied by the power spectrum. Using the plane-parallel approximation $\\hat{\\mathbf{r}} = \\hat{\\mathbf{z}}$, the relevant scalar kernel becomes\n$$\nK(\\mathbf{k}) = g \\, P(k) \\left(-i\\right)\\,\\frac{k_z}{k^2},\n$$\nwith the convention $K(\\mathbf{k} = \\mathbf{0}) = 0$ to avoid singularity at zero wavenumber.\n\nStarting from the fundamental base that includes:\n- The continuity equation and linear theory relation $\\mathbf{v}(\\mathbf{k}) = g \\, i \\, \\frac{\\mathbf{k}}{k^2} \\, \\delta(\\mathbf{k})$.\n- Statistical homogeneity and isotropy with a diagonal signal covariance $S(\\mathbf{k}) = P(k)$.\n- The definition of the observational response $\\mathbf{C}$ via $v_r(\\mathbf{x}) = \\hat{\\mathbf{z}} \\cdot \\mathbf{v}(\\mathbf{x})$.\n\nDerive and implement an algorithm that constructs and applies $\\mathbf{S}\\mathbf{C}^{\\top}$ to a given real-space radial velocity field $d(\\mathbf{x})$ on the grid using FFTs. Your implementation must:\n- Use discrete wavenumbers computed as $k_\\alpha = \\frac{2\\pi}{L} n_\\alpha$ with $n_\\alpha \\in \\{-\\lfloor N/2 \\rfloor, \\dots, \\lfloor (N-1)/2 \\rfloor\\}$ for $\\alpha \\in \\{x,y,z\\}$, consistent with standard FFT frequency conventions.\n- Set the kernel $K(\\mathbf{k})$ to zero whenever $k^2 = 0$.\n- Use an isotropic power spectrum model $P(k) = A \\exp\\left[-\\left(\\frac{k}{k_c}\\right)^2\\right]$, where $A$ and $k_c$ are constants.\n\nDefine the following test suite of input parameter sets and fields (all quantities are dimensionless in this problem; do not attach physical units):\n- Test case $1$: $N=32$, $L=200$, $g=1$, $A=1$, $k_c=0.05$. The input field is $d(\\mathbf{x}) = \\sin\\left(\\frac{2\\pi}{L} z\\right)$, independent of $x$ and $y$.\n- Test case $2$: $N=32$, $L=200$, $g=1$, $A=1$, $k_c=0.05$. The input field is identically zero, $d(\\mathbf{x}) = 0$.\n- Test case $3$: $N=32$, $L=200$, $g=1$, $A=1$, $k_c=0.05$. The input field is $d(\\mathbf{x}) = \\sin\\left(\\frac{2\\pi}{L} x\\right)$, independent of $y$ and $z$.\n- Test case $4$: $N=32$, $L=200$, $g=1$, $A=1$, $k_c=0.05$. The input field is a single grid-cell impulse at the origin index, $d(\\mathbf{x}) = 1$ at $(0,0,0)$ and $d(\\mathbf{x}) = 0$ elsewhere.\n\nFor each test case, compute the real-space output field $\\delta_{\\text{out}}(\\mathbf{x}) = \\left(\\mathbf{S}\\mathbf{C}^{\\top}\\right) d(\\mathbf{x})$ by:\n- Forward FFT of $d(\\mathbf{x})$ to obtain $D(\\mathbf{k})$.\n- Multiplying by the kernel to obtain $\\Delta(\\mathbf{k}) = K(\\mathbf{k}) D(\\mathbf{k})$.\n- Inverse FFT to real space, taking the real part, to obtain $\\delta_{\\text{out}}(\\mathbf{x})$.\n\nFor each test case, report a single scalar result equal to the root-mean-square amplitude of $\\delta_{\\text{out}}(\\mathbf{x})$, defined as\n$$\n\\mathrm{RMS} = \\sqrt{\\frac{1}{N^3} \\sum_{\\mathbf{x}} \\left[\\delta_{\\text{out}}(\\mathbf{x})\\right]^2 }.\n$$\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the test cases $1$ through $4$, for example, $\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4\\right]$. No physical units are required; all outputs are pure numbers.", "solution": "The problem statement has been critically examined and is determined to be valid. It is scientifically grounded within the framework of linear cosmological perturbation theory, mathematically well-posed, and provides a complete and consistent set of parameters and instructions for a numerical implementation. The problem is objective and free of ambiguity. I will now proceed with a complete solution.\n\n### Theoretical Foundation and Algorithmic Design\n\nThe problem requires the implementation of a linear operator, $\\mathbf{S}\\mathbf{C}^{\\top}$, that acts on a real-space radial velocity field, $d(\\mathbf{x})$, to produce a real-space density field, $\\delta_{\\text{out}}(\\mathbf{x})$. This operation is fundamental in the context of generating constrained initial conditions for cosmological simulations, where one wishes to construct a density field that is consistent with observational data (e.g., radial velocities of galaxies). The operator $\\mathbf{S}\\mathbf{C}^{\\top}$ represents the cross-covariance between the signal we wish to estimate (the density field $\\delta$) and the observable quantity (the radial velocity field $v_r$).\n\nLet us formally derive the structure of this operator.\nThe signal is the density contrast field, $\\delta(\\mathbf{x})$.\nThe peculiar velocity field, $\\mathbf{v}(\\mathbf{x})$, is related to the density field in the linear regime via the continuity equation. In Fourier space, this relationship is given as:\n$$\n\\mathbf{v}(\\mathbf{k}) = g \\, i \\, \\frac{\\mathbf{k}}{k^2} \\, \\delta(\\mathbf{k})\n$$\nwhere $\\mathbf{k}$ is the wavevector, $k = \\|\\mathbf{k}\\|$, $i$ is the imaginary unit, and $g$ is the growth prefactor.\n\nThe observational response operator, $\\mathbf{C}$, maps the vector velocity field to a scalar radial velocity field. Under the plane-parallel approximation with the line-of-sight aligned with the $\\hat{\\mathbf{z}}$ axis, this is a simple projection:\n$$\nv_r(\\mathbf{x}) = \\mathbf{C}[\\mathbf{v}(\\mathbf{x})] = \\hat{\\mathbf{z}} \\cdot \\mathbf{v}(\\mathbf{x})\n$$\nIn Fourier space, this projection becomes:\n$$\nv_r(\\mathbf{k}) = \\hat{\\mathbf{z}} \\cdot \\mathbf{v}(\\mathbf{k}) = \\hat{\\mathbf{z}} \\cdot \\left( g \\, i \\, \\frac{\\mathbf{k}}{k^2} \\, \\delta(\\mathbf{k}) \\right) = g \\, i \\, \\frac{k_z}{k^2} \\, \\delta(\\mathbf{k})\n$$\nThis equation links the Fourier modes of the observable $v_r$ to the Fourier modes of the underlying signal $\\delta$.\n\nThe operator $\\mathbf{S}\\mathbf{C}^{\\top}$ is the cross-covariance between the signal $\\delta$ and the data $v_r$, denoted $\\langle \\delta v_r^\\top \\rangle$. For statistically homogeneous fields, it is most convenient to work in Fourier space. The action of a convolution operator in real space is equivalent to multiplication in Fourier space. The kernel of this multiplication is the cross-power spectrum between the two fields.\n\nLet's compute the cross-power spectrum, which is the Fourier transform of the cross-covariance operator. We define the cross-power spectrum $P_{\\delta, v_r}(\\mathbf{k})$ via the relation $\\langle \\delta(\\mathbf{k}) v_r^*(\\mathbf{k'}) \\rangle = \\delta_{\\mathbf{k},\\mathbf{k'}} P_{\\delta, v_r}(\\mathbf{k})$ (up to volume factors, for discrete Fourier transforms).\nUsing the relation for $v_r(\\mathbf{k})$, we get:\n$$\nv_r^*(\\mathbf{k}) = \\left( g \\, i \\, \\frac{k_z}{k^2} \\, \\delta(\\mathbf{k}) \\right)^* = g \\, (-i) \\, \\frac{k_z}{k^2} \\, \\delta^*(\\mathbf{k})\n$$\nThe expectation value becomes:\n$$\n\\langle \\delta(\\mathbf{k}) v_r^*(\\mathbf{k}) \\rangle = \\left\\langle \\delta(\\mathbf{k}) \\left( g \\, (-i) \\, \\frac{k_z}{k^2} \\, \\delta^*(\\mathbf{k}) \\right) \\right\\rangle = g \\, (-i) \\, \\frac{k_z}{k^2} \\langle \\delta(\\mathbf{k}) \\delta^*(\\mathbf{k}) \\rangle\n$$\nThe term $\\langle \\delta(\\mathbf{k}) \\delta^*(\\mathbf{k}) \\rangle$ is the power spectrum of the density field, which is given as $S(\\mathbf{k}) = P(k)$. Therefore, the cross-power spectrum kernel is:\n$$\nK(\\mathbf{k}) \\equiv P_{\\delta, v_r}(\\mathbf{k}) = g \\, P(k) \\, (-i) \\, \\frac{k_z}{k^2}\n$$\nThis matches the kernel provided in the problem statement. The operation $\\delta_{\\text{out}} = (\\mathbf{S}\\mathbf{C}^{\\top}) d$ is a convolution in real space. By the convolution theorem, its Fourier transform $\\Delta_{\\text{out}}(\\mathbf{k})$ is the product of the Fourier transform of the kernel, $K(\\mathbf{k})$, and the Fourier transform of the input data, $D(\\mathbf{k})$.\n\nThe algorithm to compute $\\delta_{\\text{out}}(\\mathbf{x})$ is therefore:\n1.  **Construct the k-space grid**: The discrete wavevectors $\\mathbf{k} = (k_x, k_y, k_z)$ are defined on a $N \\times N \\times N$ grid. The components $k_\\alpha$ for $\\alpha \\in \\{x,y,z\\}$ are given by $k_\\alpha = 2\\pi f_\\alpha$, where $f_\\alpha$ are the discrete frequencies from a Fast Fourier Transform (FFT) routine. For a grid of size $N$ and physical length $L$, the frequencies are obtained via `numpy.fft.fftfreq(N, d=L/N)`, where $d=L/N$ is the real-space grid spacing.\n2.  **Construct the Fourier Kernel**: Using the k-space grid, we compute the kernel $K(\\mathbf{k})$ at each point. This involves calculating $k^2 = k_x^2+k_y^2+k_z^2$, $k = \\sqrt{k^2}$, the power spectrum $P(k) = A \\exp[-(k/k_c)^2]$, and finally $K(\\mathbf{k})$. The singularity at $\\mathbf{k}=\\mathbf{0}$ (i.e., $k^2=0$) is handled by setting $K(\\mathbf{0})=\\mathbf{0}$ as specified.\n3.  **Define the Input Field**: For each test case, the real-space input data field $d(\\mathbf{x})$ is constructed on a $N \\times N \\times N$ grid.\n4.  **Apply the Operator**:\n    a.  Compute the discrete Fourier transform of the input data: $D(\\mathbf{k}) = \\text{FFT}[d(\\mathbf{x})]$. Standard libraries implement this as `numpy.fft.fftn`.\n    b.  Multiply the transformed data by the kernel: $\\Delta_{\\text{out}}(\\mathbf{k}) = K(\\mathbf{k}) \\cdot D(\\mathbf{k})$.\n    c.  Compute the inverse Fourier transform to obtain the result in real space: $\\delta_{\\text{out}}(\\mathbf{x}) = \\text{IFFT}[\\Delta_{\\text{out}}(\\mathbf{k})]$. This is implemented by `numpy.fft.ifftn`. The result should be a real field up to numerical precision, as can be proven by the symmetry property $K(-\\mathbf{k}) = K^*(\\mathbf{k})$. We take the real part of the result to discard any small imaginary components arising from floating-point inaccuracies.\n5.  **Calculate the RMS**: The final requested output is the root-mean-square (RMS) amplitude of the resulting field $\\delta_{\\text{out}}(\\mathbf{x})$, defined as $\\mathrm{RMS} = \\sqrt{\\frac{1}{N^3} \\sum_{\\mathbf{x}} [\\delta_{\\text{out}}(\\mathbf{x})]^2}$. This is equivalent to `numpy.sqrt(numpy.mean(numpy.square(output_field)))`.\n\nThis procedure is implemented for each of the four test cases provided.\n- **Case 1**: $d(\\mathbf{x}) = \\sin(\\frac{2\\pi}{L} z)$. The input is a single plane wave along the line of sight. Its Fourier transform has power only at wavevectors $\\mathbf{k}=(0,0, \\pm 2\\pi/L)$. Since $k_z \\neq 0$ for these modes, the kernel $K(\\mathbf{k})$ is non-zero, and we expect a non-zero output.\n- **Case 2**: $d(\\mathbf{x}) = 0$. This is a linearity check. The FFT of zero is zero, so the output must be zero.\n- **Case 3**: $d(\\mathbf{x}) = \\sin(\\frac{2\\pi}{L} x)$. The input is a plane wave perpendicular to the line of sight. Its Fourier transform has power only at $\\mathbf{k}=(\\pm 2\\pi/L, 0, 0)$. For these modes, $k_z=0$, which makes the kernel $K(\\mathbf{k})=0$. The output must be zero, demonstrating that modes with no radial component do not source density fluctuations in this model.\n- **Case 4**: $d(\\mathbf{x})$ is a delta function at the origin. Its Fourier transform is constant, $D(\\mathbf{k})=1$. The output field is therefore the real-space representation of the kernel itself, $\\delta_{\\text{out}}(\\mathbf{x}) = \\text{IFFT}[K(\\mathbf{k})]$. This tests the response to a point-like source.\n\nThe implementation will follow this logic precisely.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef apply_sc_transpose(d_field, N, L, g, A, k_c):\n    \"\"\"\n    Constructs and applies the operator S*C^T to a real-space field.\n\n    Args:\n        d_field (np.ndarray): The input real-space 3D field d(x).\n        N (int): Grid dimension.\n        L (float): Box side length.\n        g (float): Growth prefactor.\n        A (float): Power spectrum amplitude.\n        k_c (float): Power spectrum characteristic scale.\n\n    Returns:\n        np.ndarray: The output real-space 3D field delta_out(x).\n    \"\"\"\n    # 1. Construct the k-space grid\n    # The sample spacing in real space is dx = L/N.\n    # The frequencies from fftfreq are in cycles per unit distance.\n    # Wavenumbers k are 2*pi times the frequency.\n    freq = np.fft.fftfreq(N, d=L / N)\n    k_vals = 2.0 * np.pi * freq\n    \n    # Create a 3D grid of wavevectors (kx, ky, kz)\n    # 'ij' indexing ensures the axes correspond to (z, y, x) if we consider\n    # numpy array indices [i, j, k] as mapping to (z, y, x).\n    # d_field is (N,N,N), numpy default is Z,Y,X access.\n    # We want kz to align with the first axis, ky with the second, kx with the third.\n    # np.meshgrid with 'ij' will make kz vary along axis 0.\n    kz, ky, kx = np.meshgrid(k_vals, k_vals, k_vals, indexing='ij')\n\n    # 2. Construct the Fourier Kernel K(k)\n    k_sq = kx**2 + ky**2 + kz**2\n\n    # Avoid division by zero warnings for k=0.\n    # Create a mask for non-zero k vectors.\n    k_sq_nonzero = k_sq > 0\n    k = np.zeros_like(k_sq)\n    k[k_sq_nonzero] = np.sqrt(k_sq[k_sq_nonzero])\n\n    # Power spectrum P(k) = A * exp(-(k/k_c)^2)\n    P_k = A * np.exp(- (k / k_c)**2)\n\n    # Kernel K(k) = g * P(k) * (-i) * k_z / k^2\n    Kernel = np.zeros_like(k_sq, dtype=np.complex128)\n    \n    # Apply kernel formula only where k_sq is not zero\n    Kernel[k_sq_nonzero] = g * P_k[k_sq_nonzero] * (-1j) * kz[k_sq_nonzero] / k_sq[k_sq_nonzero]\n    \n    # The problem specifies K(k=0) = 0, which is handled by the masking.\n\n    # 3. Apply the operator using FFTs\n    # a. Forward FFT of d(x)\n    D_k = np.fft.fftn(d_field)\n    \n    # b. Multiply by the kernel\n    Delta_out_k = Kernel * D_k\n    \n    # c. Inverse FFT to get delta_out(x)\n    delta_out = np.fft.ifftn(Delta_out_k)\n    \n    # The result should be real. Take the real part to discard numerical noise.\n    return np.real(delta_out)\n\ndef solve():\n    \"\"\"\n    Main solver function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        {'N': 32, 'L': 200, 'g': 1, 'A': 1, 'k_c': 0.05, 'id': 1},\n        {'N': 32, 'L': 200, 'g': 1, 'A': 1, 'k_c': 0.05, 'id': 2},\n        {'N': 32, 'L': 200, 'g': 1, 'A': 1, 'k_c': 0.05, 'id': 3},\n        {'N': 32, 'L': 200, 'g': 1, 'A': 1, 'k_c': 0.05, 'id': 4},\n    ]\n\n    results = []\n    \n    for params in test_cases:\n        N = params['N']\n        L = params['L']\n        \n        # Create the grid coordinates for defining input fields\n        coords = np.arange(N) * (L / N)\n        z, y, x = np.meshgrid(coords, coords, coords, indexing='ij')\n\n        # Define the input field d(x) for each test case\n        d_field = np.zeros((N, N, N), dtype=float)\n        case_id = params['id']\n        \n        if case_id == 1:\n            # d(x) = sin(2*pi/L * z)\n            d_field = np.sin(2 * np.pi / L * z)\n        elif case_id == 2:\n            # d(x) = 0\n            d_field = np.zeros((N, N, N), dtype=float)\n        elif case_id == 3:\n            # d(x) = sin(2*pi/L * x)\n            d_field = np.sin(2 * np.pi / L * x)\n        elif case_id == 4:\n            # d(x) is an impulse at the origin index (0,0,0)\n            d_field[0, 0, 0] = 1.0\n\n        # Apply the operator to get the output field\n        delta_out = apply_sc_transpose(d_field, N, L, params['g'], params['A'], params['k_c'])\n        \n        # Calculate the RMS amplitude of the output field\n        # RMS = sqrt(  delta_out^2 > )\n        rms_val = np.sqrt(np.mean(np.square(delta_out)))\n        \n        results.append(rms_val)\n\n    # Format and print the final results\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\nsolve()\n```", "id": "3468238"}, {"introduction": "While forward modeling generates evolved structures from initial conditions, the inverse problem—reconstructing initial conditions from late-time observations—is equally fundamental and offers deep insights into cosmic evolution. This practice [@problem_id:3468288] delves into this challenge by implementing the Reverse Zeldovich Approximation (RZA) to infer initial Lagrangian displacements from final Eulerian positions. You will not only implement the algorithm but also perform a sensitivity analysis to understand how errors in the assumed cosmological model, such as neglecting non-linear corrections, propagate into the reconstruction.", "problem": "You are tasked with implementing the reverse Zeldovich approximation in a periodic cubic domain to infer the initial Lagrangian displacements from observed Eulerian galaxy positions, and to test the sensitivity of the inference to the assumed linear growth factor and to the inclusion of second-order corrections. Work entirely within the framework of Newtonian gravity in an expanding universe with comoving coordinates and periodic boundary conditions. All quantities must be treated in three spatial dimensions, and all spatial coordinates must be expressed in units of megaparsecs divided by the Hubble parameter, specifically in $\\mathrm{Mpc}/h$. The angle unit does not apply here.\n\nStart from the following foundational base:\n\n- The Zeldovich approximation (ZA) is the first-order solution of Lagrangian perturbation theory (LPT). The Eulerian position $\\mathbf{x}$ of a mass element labeled by its Lagrangian coordinate $\\mathbf{q}$ at scale factor $a$ is written as\n$$\n\\mathbf{x}(\\mathbf{q}, a) = \\mathbf{q} + \\mathbf{\\Psi}(\\mathbf{q}, a),\n$$\nwhere the displacement field admits a perturbative expansion\n$$\n\\mathbf{\\Psi}(\\mathbf{q}, a) = D(a)\\,\\mathbf{\\Psi}^{(1)}(\\mathbf{q}) + D_2(a)\\,\\mathbf{\\Psi}^{(2)}(\\mathbf{q}) + \\cdots,\n$$\nwith $D(a)$ the linear growth factor and $D_2(a)$ the second-order growth factor. In an Einstein–de Sitter background, one has $D_2(a) = -\\frac{3}{7}D(a)^2$.\n\n- The first-order displacement is curl-free and related to the linear density contrast via a scalar potential $\\phi^{(1)}(\\mathbf{q})$ satisfying\n$$\n\\nabla^2 \\phi^{(1)}(\\mathbf{q}) = \\delta^{(1)}(\\mathbf{q}), \\quad \\mathbf{\\Psi}^{(1)}(\\mathbf{q}) = -\\nabla \\phi^{(1)}(\\mathbf{q}),\n$$\nwhere $\\delta^{(1)}(\\mathbf{q})$ is the linear density contrast. In Fourier space with wavevector $\\mathbf{k}$, this implies\n$$\n\\tilde{\\mathbf{\\Psi}}^{(1)}(\\mathbf{k}) = i\\,\\frac{\\mathbf{k}}{k^2}\\,\\tilde{\\delta}^{(1)}(\\mathbf{k}),\n$$\nfor $k \\equiv \\|\\mathbf{k}\\| \\neq 0$, and $\\tilde{\\cdot}$ denotes the Fourier transform.\n\n- The second-order displacement can be expressed via a second-order potential $\\phi^{(2)}(\\mathbf{q})$ satisfying\n$$\n\\nabla^2 \\phi^{(2)}(\\mathbf{q}) = S_2(\\mathbf{q}),\n$$\nwhere the quadratic source is built from derivatives of $\\phi^{(1)}$ as\n$$\nS_2(\\mathbf{q}) = \\sum_{ij} \\left[ \\phi^{(1)}_{,ii}(\\mathbf{q})\\,\\phi^{(1)}_{,jj}(\\mathbf{q}) - \\left(\\phi^{(1)}_{,ij}(\\mathbf{q})\\right)^2 \\right],\n$$\nand\n$$\n\\mathbf{\\Psi}^{(2)}(\\mathbf{q}) = -\\nabla \\phi^{(2)}(\\mathbf{q}).\n$$\n\nImplement the following computational experiment in a cubic periodic box of side length $L$ with $N^3$ grid points representing equal-mass tracers:\n\n1. Construct a synthetic linear density field $\\delta^{(1)}(\\mathbf{q})$ in the box as a superposition of two orthogonal single-mode cosine waves:\n$$\n\\delta^{(1)}(\\mathbf{q}) = A\\left[\\cos\\left(\\mathbf{k}_1\\cdot \\mathbf{q}\\right) + \\cos\\left(\\mathbf{k}_2\\cdot \\mathbf{q}\\right)\\right],\n$$\nwith $\\mathbf{k}_1 = \\frac{2\\pi}{L}(1,0,0)$, $\\mathbf{k}_2 = \\frac{2pi}{L}(0,1,0)$, and amplitude $A$. Using Fourier methods, compute $\\mathbf{\\Psi}^{(1)}(\\mathbf{q})$ and $\\mathbf{\\Psi}^{(2)}(\\mathbf{q})$ under periodic boundary conditions.\n\n2. Perform forward evolution to Eulerian positions at scale factor $a$:\n$$\n\\mathbf{x}(\\mathbf{q}, a) = \\mathbf{q} + D_{\\mathrm{true}}(a)\\,\\mathbf{\\Psi}^{(1)}(\\mathbf{q}) + D_{2,\\mathrm{true}}(a)\\,\\mathbf{\\Psi}^{(2)}(\\mathbf{q}),\n$$\nwith $D_{2,\\mathrm{true}}(a) = -\\frac{3}{7}\\left(D_{\\mathrm{true}}(a)\\right)^2$ if second-order evolution is included, and $D_{2,\\mathrm{true}}(a)=0$ otherwise. Treat the positions $\\mathbf{x}$ as observed.\n\n3. Implement reverse Zeldovich estimation of the initial displacement by assuming values $D_{\\mathrm{assumed}}(a)$ and optionally subtracting a second-order term with $D_{2,\\mathrm{assumed}}(a)$:\n- Naive reverse ZA (ignoring second order):\n$$\n\\hat{\\mathbf{\\Psi}}^{(1)}(\\mathbf{q}) = \\frac{\\mathbf{x}(\\mathbf{q}, a) - \\mathbf{q}}{D_{\\mathrm{assumed}}(a)}.\n$$\n- Second-order corrected reverse ZA:\n$$\n\\hat{\\mathbf{\\Psi}}^{(1)}(\\mathbf{q}) = \\frac{\\mathbf{x}(\\mathbf{q}, a) - \\mathbf{q} - D_{2,\\mathrm{assumed}}(a)\\,\\mathbf{\\Psi}^{(2)}(\\mathbf{q})}{D_{\\mathrm{assumed}}(a)}.\n$$\n\n4. Quantify the inference quality for each test case using the root-mean-square relative error between the inferred $\\hat{\\mathbf{\\Psi}}^{(1)}(\\mathbf{q})$ and the true $\\mathbf{\\Psi}^{(1)}(\\mathbf{q})$ over all $N^3$ tracers:\n$$\n\\varepsilon = \\frac{\\left[\\frac{1}{N^3}\\sum_{\\mathbf{q}}\\left\\|\\hat{\\mathbf{\\Psi}}^{(1)}(\\mathbf{q}) - \\mathbf{\\Psi}^{(1)}(\\mathbf{q})\\right\\|^2\\right]^{1/2}}{\\left[\\frac{1}{N^3}\\sum_{\\mathbf{q}}\\left\\|\\mathbf{\\Psi}^{(1)}(\\mathbf{q})\\right\\|^2\\right]^{1/2}}.\n$$\n\nUse a cubic box of side length $L = 100\\,\\mathrm{Mpc}/h$ with $N = 32$ grid points per dimension. Evaluate the following test suite, each defined by the tuple $(A, D_{\\mathrm{true}}, \\mathrm{include\\_2LPT}, D_{\\mathrm{assumed}}, \\mathrm{subtract\\_2LPT}, D_{2,\\mathrm{assumed}})$:\n\n- Test $1$: $(0.05, 1.0, \\mathrm{True}, 1.0, \\mathrm{False}, -\\frac{3}{7}\\cdot 1.0^2)$.\n- Test $2$: $(0.05, 1.0, \\mathrm{True}, 0.9, \\mathrm{False}, -\\frac{3}{7}\\cdot 0.9^2)$.\n- Test $3$: $(0.05, 1.0, \\mathrm{True}, 1.0, \\mathrm{True}, -\\frac{3}{7}\\cdot 1.0^2)$.\n- Test $4$: $(10^{-4}, 1.0, \\mathrm{True}, 1.0, \\mathrm{False}, -\\frac{3}{7}\\cdot 1.0^2)$.\n- Test $5$: $(0.2, 1.0, \\mathrm{False}, 1.0, \\mathrm{False}, 0.0)$.\n\nFor each test, compute $\\varepsilon$ as defined above. Your program should produce a single line of output containing the five $\\varepsilon$ values as a comma-separated list enclosed in square brackets, for example, $\\left[\\varepsilon_1,\\varepsilon_2,\\varepsilon_3,\\varepsilon_4,\\varepsilon_5\\right]$. All spatial quantities and the box size must be in $\\mathrm{Mpc}/h$, and the errors are dimensionless floats. No additional text should be printed.", "solution": "The user-provided problem is a valid, well-posed computational physics problem grounded in standard cosmological perturbation theory. It requires the implementation and testing of the reverse Zeldovich approximation for reconstructing initial cosmic displacement fields. The provided parameters and equations are self-contained, scientifically correct, and sufficient for deriving a unique numerical solution. We now proceed with the step-by-step derivation and implementation plan.\n\nThe core of the problem is to solve a set of Poisson-like equations on a three-dimensional periodic grid using Fourier methods and to evaluate the accuracy of a reconstruction scheme based on this framework.\n\n### 1. Discretization and Fourier Space Representation\nWe operate on a cubic grid of side length $L$ with $N^3$ points. The Lagrangian coordinates $\\mathbf{q}$ occupy the grid nodes. We can represent any scalar or vector field on this grid, for instance, a generic field $f(\\mathbf{q})$. The discrete Fourier transform (DFT) and its inverse are defined as:\n$$\n\\tilde{f}(\\mathbf{k}) = \\sum_{\\mathbf{q}} f(\\mathbf{q}) e^{-i\\mathbf{k}\\cdot\\mathbf{q}}\n$$\n$$\nf(\\mathbf{q}) = \\frac{1}{N^3} \\sum_{\\mathbf{k}} \\tilde{f}(\\mathbf{k}) e^{i\\mathbf{k}\\cdot\\mathbf{q}}\n$$\nThe wavevectors $\\mathbf{k}$ also form a grid in Fourier space. For a grid point indexed by integers $(n_x, n_y, n_z) \\in [0, N-1]^3$, the physical coordinates are $q_i = n_i \\frac{L}{N}$. The corresponding wavevector components are $k_i = m_i \\frac{2\\pi}{L}$, where the integer frequency indices $m_i$ are typically arranged in the order $\\{0, 1, \\dots, N/2-1, -N/2, \\dots, -1\\}$.\n\nCrucially, differential operators become algebraic in Fourier space. The gradient and Laplacian operators transform as:\n$$\n\\widetilde{\\nabla f}(\\mathbf{k}) = i\\mathbf{k} \\tilde{f}(\\mathbf{k}), \\quad \\widetilde{\\nabla^2 f}(\\mathbf{k}) = -k^2 \\tilde{f}(\\mathbf{k})\n$$\nwhere $k^2 = \\|\\mathbf{k}\\|^2 = k_x^2 + k_y^2 + k_z^2$. This allows us to solve Poisson's equation $\\nabla^2 \\phi = \\rho$ by simple division in Fourier space: $\\tilde{\\phi}(\\mathbf{k}) = -\\frac{1}{k^2} \\tilde{\\rho}(\\mathbf{k})$, with special handling for the $k=0$ mode.\n\n### 2. Construction of the True Displacement Fields\n\n#### 2.1. First-Order Field $\\mathbf{\\Psi}^{(1)}$\nThe process begins by defining the linear density contrast $\\delta^{(1)}(\\mathbf{q})$. Instead of constructing it in real space and then transforming, it is more direct to construct its Fourier transform $\\tilde{\\delta}^{(1)}(\\mathbf{k})$. The given density field is:\n$$\n\\delta^{(1)}(\\mathbf{q}) = A\\left[\\cos\\left(\\mathbf{k}_1\\cdot \\mathbf{q}\\right) + \\cos\\left(\\mathbf{k}_2\\cdot \\mathbf{q}\\right)\\right]\n$$\nwith fundamental modes $\\mathbf{k}_1 = \\frac{2\\pi}{L}(1,0,0)$ and $\\mathbf{k}_2 = \\frac{2\\pi}{L}(0,1,0)$. The discrete Fourier transform of a cosine term $\\cos(\\mathbf{k}_j \\cdot \\mathbf{q})$ on an $N^3$ grid has two non-zero components at wavevectors $\\pm\\mathbf{k}_j$. Thus, $\\tilde{\\delta}^{(1)}(\\mathbf{k})$ is non-zero only at four specific wavevectors: $\\pm \\mathbf{k}_1$ and $\\pm \\mathbf{k}_2$. The amplitude of each of these delta functions in Fourier space is $\\frac{A N^3}{2}$.\n\nFrom the relation $\\tilde{\\mathbf{\\Psi}}^{(1)}(\\mathbf{k}) = i\\,\\frac{\\mathbf{k}}{k^2}\\,\\tilde{\\delta}^{(1)}(\\mathbf{k})$, we calculate the three components of the displacement field in Fourier space. For $k=0$, $\\tilde{\\delta}^{(1)}(\\mathbf{0})=0$ as the mean density fluctuation is zero, so we set $\\tilde{\\mathbf{\\Psi}}^{(1)}(\\mathbf{0})=\\mathbf{0}$. Finally, we perform an inverse DFT on each component to obtain the real-space field $\\mathbf{\\Psi}^{(1)}(\\mathbf{q})$.\n\n#### 2.2. Second-Order Field $\\mathbf{\\Psi}^{(2)}$\nThe computation of $\\mathbf{\\Psi}^{(2)}$ is more involved.\n1.  **First-Order Potential $\\phi^{(1)}$**: We first find the potential $\\phi^{(1)}$ from $\\nabla^2 \\phi^{(1)} = \\delta^{(1)}$. In Fourier space, this is $\\tilde{\\phi}^{(1)}(\\mathbf{k}) = -\\frac{1}{k^2} \\tilde{\\delta}^{(1)}(\\mathbf{k})$. The $k=0$ mode $\\tilde{\\phi}^{(1)}(\\mathbf{0})$ is set to zero.\n\n2.  **Derivatives of $\\phi^{(1)}$**: The second-order source term $S_2(\\mathbf{q})$ requires the six unique second derivatives of $\\phi^{(1)}$, i.e., $\\phi^{(1)}_{,ij} \\equiv \\frac{\\partial^2 \\phi^{(1)}}{\\partial q_i \\partial q_j}$. These are computed efficiently using Fourier transforms:\n    $$\n    \\phi^{(1)}_{,ij}(\\mathbf{q}) = \\mathcal{F}^{-1}\\left[ (i k_i)(i k_j) \\tilde{\\phi}^{(1)}(\\mathbf{k}) \\right] = \\mathcal{F}^{-1}\\left[ -k_i k_j \\tilde{\\phi}^{(1)}(\\mathbf{k}) \\right]\n    $$\n    where $\\mathcal{F}^{-1}$ denotes the inverse DFT. We compute each of the six fields ($\\phi^{(1)}_{,xx}, \\phi^{(1)}_{,yy}, \\phi^{(1)}_{,zz}, \\phi^{(1)}_{,xy}, \\phi^{(1)}_{,xz}, \\phi^{(1)}_{,yz}$) this way.\n\n3.  **Source Term $S_2$**: In real space, we construct the source term $S_2(\\mathbf{q})$ from the computed derivatives:\n    $$\n    S_2(\\mathbf{q}) = \\left[\\phi^{(1)}_{,xx}\\phi^{(1)}_{,yy} - (\\phi^{(1)}_{,xy})^2\\right] + \\left[\\phi^{(1)}_{,xx}\\phi^{(1)}_{,zz} - (\\phi^{(1)}_{,xz})^2\\right] + \\left[\\phi^{(1)}_{,yy}\\phi^{(1)}_{,zz} - (\\phi^{(1)}_{,yz})^2\\right]\n    $$\n\n4.  **Solving for $\\mathbf{\\Psi}^{(2)}$**: With $S_2(\\mathbf{q})$ known, we solve for $\\mathbf{\\Psi}^{(2)}(\\mathbf{q})$ in the same manner as for $\\mathbf{\\Psi}^{(1)}$. We have $\\nabla^2 \\phi^{(2)} = S_2$ and $\\mathbf{\\Psi}^{(2)} = -\\nabla \\phi^{(2)}$, which leads to $\\tilde{\\mathbf{\\Psi}}^{(2)}(\\mathbf{k}) = i\\,\\frac{\\mathbf{k}}{k^2}\\,\\tilde{S}_2(\\mathbf{k})$. We compute $\\tilde{S}_2(\\mathbf{k})$ via a forward DFT of $S_2(\\mathbf{q})$, then calculate the components of $\\tilde{\\mathbf{\\Psi}}^{(2)}(\\mathbf{k})$, and finally perform an inverse DFT to obtain $\\mathbf{\\Psi}^{(2)}(\\mathbf{q})$. The $k=0$ mode $\\tilde{\\mathbf{\\Psi}}^{(2)}(\\mathbf{0})$ is set to zero, which is justified as this mode represents a uniform translation of the entire grid, which is physically irrelevant.\n\n### 3. Forward Evolution and Reverse Estimation\n\nFor each test case, we perform the following steps using the pre-computed fields $\\mathbf{\\Psi}^{(1)}$ and $\\mathbf{\\Psi}^{(2)}$ (which depend on the amplitude $A$).\n\n1.  **Forward Evolution**: We compute the \"observed\" Eulerian positions $\\mathbf{x}(\\mathbf{q})$ from the true Lagrangian positions $\\mathbf{q}$ (our grid points) using the parameters $D_{\\mathrm{true}}$ and `include_2LPT`:\n    $$\n    D_{2,\\mathrm{true}} = \\begin{cases} - (3/7) D_{\\mathrm{true}}^2  \\text{if include\\_2LPT is True} \\\\ 0  \\text{if include\\_2LPT is False} \\end{cases}\n    $$\n    $$\n    \\mathbf{x}(\\mathbf{q}) = \\mathbf{q} + D_{\\mathrm{true}}\\,\\mathbf{\\Psi}^{(1)}(\\mathbf{q}) + D_{2,\\mathrm{true}}\\,\\mathbf{\\Psi}^{(2)}(\\mathbf{q})\n    $$\n\n2.  **Reverse Estimation**: We then infer the initial displacement field, $\\hat{\\mathbf{\\Psi}}^{(1)}(\\mathbf{q})$, from the \"data\" ($\\mathbf{x}$ and $\\mathbf{q}$) and the assumed model parameters. The problem is simplified by assuming $\\mathbf{q}$ is known.\n    -   If `subtract_2LPT` is `False`, we use the naive reverse Zeldovich approximation:\n        $$\n        \\hat{\\mathbf{\\Psi}}^{(1)}(\\mathbf{q}) = \\frac{\\mathbf{x}(\\mathbf{q}) - \\mathbf{q}}{D_{\\mathrm{assumed}}}\n        $$\n    -   If `subtract_2LPT` is `True`, we use the second-order corrected formula, which requires the true $\\mathbf{\\Psi}^{(2)}$ field and the assumed second-order growth factor $D_{2,\\mathrm{assumed}}$:\n        $$\n        \\hat{\\mathbf{\\Psi}}^{(1)}(\\mathbf{q}) = \\frac{\\mathbf{x}(\\mathbf{q}) - \\mathbf{q} - D_{2,\\mathrm{assumed}}\\,\\mathbf{\\Psi}^{(2)}(\\mathbf{q})}{D_{\\mathrm{assumed}}}\n        $$\n\n### 4. Error Quantification\nThe quality of the reconstruction is measured by the relative root-mean-square (RMS) error $\\varepsilon$:\n$$\n\\varepsilon = \\frac{\\left[\\frac{1}{N^3}\\sum_{\\mathbf{q}}\\left\\|\\hat{\\mathbf{\\Psi}}^{(1)}(\\mathbf{q}) - \\mathbf{\\Psi}^{(1)}(\\mathbf{q})\\right\\|^2\\right]^{1/2}}{\\left[\\frac{1}{N^3}\\sum_{\\mathbf{q}}\\left\\|\\mathbf{\\Psi}^{(1)}(\\mathbf{q})\\right\\|^2\\right]^{1/2}} = \\sqrt{\\frac{\\sum_{\\mathbf{q}}\\|\\Delta \\mathbf{\\Psi}(\\mathbf{q})\\|^2}{\\sum_{\\mathbf{q}}\\|\\mathbf{\\Psi}^{(1)}(\\mathbf{q})\\|^2}}\n$$\nwhere $\\Delta \\mathbf{\\Psi}(\\mathbf{q}) = \\hat{\\mathbf{\\Psi}}^{(1)}(\\mathbf{q}) - \\mathbf{\\Psi}^{(1)}(\\mathbf{q})$, and the sum is over all $N^3$ grid points. This metric compares the RMS magnitude of the error vector to the RMS magnitude of the true displacement vector.\n\nThe test cases are designed to probe different sources of error: Test 1 demonstrates the error from neglecting the second-order term, Test 2 from an incorrect growth factor, Test 3 is a control case with a perfect model (expecting $\\varepsilon \\approx 0$), Test 4 shows behavior at very low amplitude (linear regime), and Test 5 is a baseline first-order-only scenario.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Implements the reverse Zeldovich approximation experiment as specified.\n    \"\"\"\n    L = 100.0  # Box size in Mpc/h\n    N = 32     # Grid points per dimension\n\n    # Define test cases:\n    # (A, D_true, include_2LPT, D_assumed, subtract_2LPT, D2_assumed)\n    test_cases = [\n        (0.05, 1.0, True, 1.0, False, -3.0/7.0 * 1.0**2),\n        (0.05, 1.0, True, 0.9, False, -3.0/7.0 * 0.9**2),\n        (0.05, 1.0, True, 1.0, True, -3.0/7.0 * 1.0**2),\n        (1e-4, 1.0, True, 1.0, False, -3.0/7.0 * 1.0**2),\n        (0.2, 1.0, False, 1.0, False, 0.0),\n    ]\n\n    # --- Setup Grids ---\n    # Real space grid coordinates (Lagrangian)\n    q_coords_1d = np.arange(N) * (L / N)\n    q_grid = np.array(np.meshgrid(q_coords_1d, q_coords_1d, q_coords_1d, indexing='ij'))\n\n    # Fourier space grid of wavevectors\n    k_vals = 2 * np.pi * np.fft.fftfreq(N, d=L/N)\n    k_grid = np.array(np.meshgrid(k_vals, k_vals, k_vals, indexing='ij'))\n    k_sq = np.sum(k_grid**2, axis=0)\n\n    # For safe division, set k=0 component of k_sq to 1 (it will be zeroed out later)\n    inv_k_sq_safe = np.copy(k_sq)\n    center = (0, 0, 0)\n    \n    if k_sq[center] == 0:\n        inv_k_sq_safe[center] = 1.0\n    inv_k_sq_safe = 1.0 / inv_k_sq_safe\n    if k_sq[center] == 0:\n        inv_k_sq_safe[center] = 0.0\n\n    results = []\n    computed_fields = {} # Cache fields based on amplitude A\n\n    for case in test_cases:\n        A, D_true, include_2LPT, D_assumed, subtract_2LPT, D2_assumed = case\n\n        if A not in computed_fields:\n            # --- 1. Construct True Fields ---\n            \n            # 1a. Linear density field in Fourier space\n            delta_k = np.zeros((N, N, N), dtype=np.complex128)\n            # Factor of N**3 comes from numpy's FFT normalization convention\n            val = A * (N**3) / 2.0\n            delta_k[0, 1, 0] = val # k_y = 2*pi/L\n            delta_k[0, N-1, 0] = val # k_y = -2*pi/L\n            delta_k[0, 0, 1] = val # k_x = 2*pi/L. Note: Python meshgrid and user spec may have swapped axes\n            delta_k[0, 0, N-1] = val # k_x = -2*pi/L. The problem states k1=(1,0,0), k2=(0,1,0), which maps to indices (0,0,1) and (0,1,0) for numpy's (z,y,x) k-grid.\n\n            # Re-check problem spec: k1=(1,0,0), k2=(0,1,0). With numpy's default (z,y,x) axis order for 3D arrays,\n            # and 'ij' indexing for meshgrid (kz, ky, kx), kx corresponds to index 2, ky to 1, kz to 0.\n            # So k_1 = (2pi/L, 0, 0) is at index (0,0,1) and k_2 = (0, 2pi/L, 0) is at index (0,1,0).\n            delta_k = np.zeros((N, N, N), dtype=np.complex128)\n            delta_k[0, 0, 1] = val\n            delta_k[0, 0, N-1] = val\n            delta_k[0, 1, 0] = val\n            delta_k[0, N-1, 0] = val\n\n            # 1b. First-order displacement field Psi^(1)\n            psi1_k_x = 1j * k_grid[2] * inv_k_sq_safe * delta_k\n            psi1_k_y = 1j * k_grid[1] * inv_k_sq_safe * delta_k\n            psi1_k_z = 1j * k_grid[0] * inv_k_sq_safe * delta_k\n            \n            psi1_x = np.real(np.fft.ifftn(psi1_k_x))\n            psi1_y = np.real(np.fft.ifftn(psi1_k_y))\n            psi1_z = np.real(np.fft.ifftn(psi1_k_z))\n            psi1 = np.array([psi1_z, psi1_y, psi1_x]) # Assembling in (x,y,z) order to match problem spec\n\n            # 1c. Second-order displacement field Psi^(2)\n            # Find first-order potential phi^(1)\n            phi1_k = -inv_k_sq_safe * delta_k\n            \n            # Find second derivatives of phi^(1)\n            phi1_xx = np.real(np.fft.ifftn(-k_grid[2] * k_grid[2] * phi1_k))\n            phi1_yy = np.real(np.fft.ifftn(-k_grid[1] * k_grid[1] * phi1_k))\n            phi1_zz = np.real(np.fft.ifftn(-k_grid[0] * k_grid[0] * phi1_k))\n            phi1_xy = np.real(np.fft.ifftn(-k_grid[2] * k_grid[1] * phi1_k))\n            phi1_xz = np.real(np.fft.ifftn(-k_grid[2] * k_grid[0] * phi1_k))\n            phi1_yz = np.real(np.fft.ifftn(-k_grid[1] * k_grid[0] * phi1_k))\n\n            # Compute source term S2\n            S2 = ((phi1_xx * phi1_yy) - phi1_xy**2 +\n                  (phi1_xx * phi1_zz) - phi1_xz**2 +\n                  (phi1_yy * phi1_zz) - phi1_yz**2)\n            \n            # Solve for Psi^(2)\n            S2_k = np.fft.fftn(S2)\n            psi2_k_x = 1j * k_grid[2] * inv_k_sq_safe * S2_k\n            psi2_k_y = 1j * k_grid[1] * inv_k_sq_safe * S2_k\n            psi2_k_z = 1j * k_grid[0] * inv_k_sq_safe * S2_k\n            \n            psi2_x = np.real(np.fft.ifftn(psi2_k_x))\n            psi2_y = np.real(np.fft.ifftn(psi2_k_y))\n            psi2_z = np.real(np.fft.ifftn(psi2_k_z))\n            psi2 = np.array([psi2_z, psi2_y, psi2_x])\n\n            # The Lagrangian coordinate grid is in (z,y,x) order from meshgrid, let's make it (x,y,z) for clarity\n            q_grid_xyz = np.array([q_grid[2], q_grid[1], q_grid[0]])\n\n            computed_fields[A] = (psi1, psi2, q_grid_xyz)\n        \n        psi1, psi2, q_grid_xyz = computed_fields[A]\n\n        # --- 2. Forward Evolution ---\n        D2_true = -3.0/7.0 * D_true**2 if include_2LPT else 0.0\n        x_pos = q_grid_xyz + D_true * psi1 + D2_true * psi2\n\n        # --- 3. Reverse Estimation ---\n        if not subtract_2LPT: # Naive reverse ZA\n            psi1_hat = (x_pos - q_grid_xyz) / D_assumed\n        else: # Second-order corrected\n            psi1_hat = (x_pos - q_grid_xyz - D2_assumed * psi2) / D_assumed\n\n        # --- 4. Quantify Error ---\n        error_vec = psi1_hat - psi1\n        numerator_sq_sum = np.sum(error_vec**2)\n        denominator_sq_sum = np.sum(psi1**2)\n        \n        if denominator_sq_sum == 0:\n            epsilon = 0.0 if numerator_sq_sum == 0 else np.inf\n        else:\n            epsilon = np.sqrt(numerator_sq_sum / denominator_sq_sum)\n        \n        results.append(epsilon)\n\n    # --- Final Output ---\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\nsolve()\n```", "id": "3468288"}]}