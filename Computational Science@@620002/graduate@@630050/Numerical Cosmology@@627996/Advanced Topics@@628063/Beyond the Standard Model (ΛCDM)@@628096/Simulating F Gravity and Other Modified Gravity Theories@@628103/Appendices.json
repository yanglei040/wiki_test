{"hands_on_practices": [{"introduction": "The journey from a continuous physical theory to a computational simulation begins with discretization. We must translate the language of differential equations into a system of algebraic equations that a computer can solve. This exercise takes you through the foundational first step for any grid-based code: deriving the finite-difference approximation for a differential operator from first principles. By working through the Taylor expansion to construct the standard 7-point stencil for the Laplacian, you will gain a concrete understanding of how continuous space is mapped to a discrete grid and the origin of truncation errors, a critical concept for assessing numerical accuracy [@problem_id:3487331].", "problem": "Consider the quasi-static, sub-horizon limit of a modified gravity theory of the type $f(R)$, in which the scalar field $f_{R}$ obeys an elliptic partial differential equation (PDE) that couples to the matter density contrast. In comoving Cartesian coordinates $\\boldsymbol{x}=(x,y,z)$ with scale factor $a$, the equation takes the form\n$$\n\\nabla^{2} f_{R}(\\boldsymbol{x}) \\;=\\; \\frac{a^{2}}{3}\\Big[\\,\\delta R\\big(f_{R}(\\boldsymbol{x})\\big) \\;-\\; 8\\pi G\\,\\delta\\rho(\\boldsymbol{x})\\,\\Big],\n$$\nwhere $\\delta R\\big(f_{R}\\big)$ denotes the perturbation of the Ricci scalar as a local functional of $f_{R}$, $G$ is the Newtonian gravitational constant, and $\\delta\\rho$ is the matter density perturbation.\n\nYou will discretize this equation on a uniform, three-dimensional Cartesian mesh representing a single cosmological time slice with fixed $a$. Let the grid be defined by points $\\boldsymbol{x}_{i,j,k}=(x_{i},y_{j},z_{k})$ with uniform spacing $\\Delta x=\\Delta y=\\Delta z=h$, and let $f_{R\\,i,j,k}$ denote the value of $f_{R}$ at the grid point $(i,j,k)$. Similarly, define $\\delta\\rho_{i,j,k}$ and evaluate $\\delta R$ locally as $\\delta R\\!\\big(f_{R\\,i,j,k}\\big)$.\n\nStarting from the definition of the Laplacian operator in Cartesian coordinates and the Taylor expansion of a smooth function on a uniform grid, derive a second-order accurate, central finite-difference stencil for the Laplacian $\\nabla^{2} f_{R}$ at an interior grid point $(i,j,k)$. Use only the foundational definitions of derivatives and Taylor expansions to establish the order of accuracy of your stencil. Then write the discrete version of the elliptic equation at $(i,j,k)$ using your Laplacian approximation and the local evaluations of $\\delta R$ and $\\delta\\rho$.\n\nYour final answer must be the single, closed-form analytic expression that gives the second-order accurate finite-difference stencil for $\\nabla^{2} f_{R}$ at $(i,j,k)$. No units are required. Do not round; give the exact symbolic expression.", "solution": "The starting point is the definition of the Laplacian operator in Cartesian coordinates,\n$$\n\\nabla^{2} f_{R} \\;=\\; \\frac{\\partial^{2} f_{R}}{\\partial x^{2}} \\;+\\; \\frac{\\partial^{2} f_{R}}{\\partial y^{2}} \\;+\\; \\frac{\\partial^{2} f_{R}}{\\partial z^{2}}.\n$$\nOn a uniform grid with spacing $h$ in each direction, we construct second-order accurate approximations to each second derivative by using the central finite-difference formula derived from the Taylor expansion.\n\nConsider a one-dimensional smooth function $g$ defined on uniform points $x_{i}=x_{0}+i h$. The Taylor expansions about $x_{i}$ are\n\\begin{align*}\ng(x_{i}+h) = g(x_{i}) \\;+\\; h\\,g'(x_{i}) \\;+\\; \\frac{h^{2}}{2}\\,g''(x_{i}) \\;+\\; \\frac{h^{3}}{6}\\,g^{(3)}(x_{i}) \\;+\\; \\frac{h^{4}}{24}\\,g^{(4)}(\\xi_{+}), \\\\\ng(x_{i}-h) = g(x_{i}) \\;-\\; h\\,g'(x_{i}) \\;+\\; \\frac{h^{2}}{2}\\,g''(x_{i}) \\;-\\; \\frac{h^{3}}{6}\\,g^{(3)}(x_{i}) \\;+\\; \\frac{h^{4}}{24}\\,g^{(4)}(\\xi_{-}),\n\\end{align*}\nfor some $\\xi_{+}$ and $\\xi_{-}$ in the intervals $(x_{i},x_{i}+h)$ and $(x_{i}-h,x_{i})$, respectively. Adding these two expansions and subtracting $2 g(x_{i})$ yields\n$$\ng(x_{i}+h) - 2 g(x_{i}) + g(x_{i}-h) \\;=\\; h^{2} g''(x_{i}) \\;+\\; \\frac{h^{4}}{12}\\,g^{(4)}(\\xi),\n$$\nfor some $\\xi$ between $x_{i}-h$ and $x_{i}+h$. Dividing by $h^{2}$ gives the central difference approximation for the second derivative,\n$$\n\\frac{g(x_{i}+h) - 2 g(x_{i}) + g(x_{i}-h)}{h^{2}} \\;=\\; g''(x_{i}) \\;+\\; \\mathcal{O}\\!\\left(h^{2}\\right).\n$$\nThis shows the central second difference is second-order accurate.\n\nApply this construction to $f_{R}$ in each Cartesian direction independently. Denote $f_{R\\,i,j,k} \\equiv f_{R}(x_{i},y_{j},z_{k})$. Then\n\\begin{align*}\n\\frac{\\partial^{2} f_{R}}{\\partial x^{2}}\\bigg|_{(i,j,k)} \\approx \\frac{f_{R\\,i+1,j,k} - 2 f_{R\\,i,j,k} + f_{R\\,i-1,j,k}}{h^{2}}, \\\\\n\\frac{\\partial^{2} f_{R}}{\\partial y^{2}}\\bigg|_{(i,j,k)} \\approx \\frac{f_{R\\,i,j+1,k} - 2 f_{R\\,i,j,k} + f_{R\\,i,j-1,k}}{h^{2}}, \\\\\n\\frac{\\partial^{2} f_{R}}{\\partial z^{2}}\\bigg|_{(i,j,k)} \\approx \\frac{f_{R\\,i,j,k+1} - 2 f_{R\\,i,j,k} + f_{R\\,i,j,k-1}}{h^{2}}.\n\\end{align*}\nSumming the three approximations produces the standard second-order accurate seven-point finite-difference stencil for the Laplacian on a uniform Cartesian grid:\n$$\n\\nabla^{2} f_{R}\\big|_{(i,j,k)} \\;\\approx\\; \\frac{f_{R\\,i+1,j,k} + f_{R\\,i-1,j,k} + f_{R\\,i,j+1,k} + f_{R\\,i,j-1,k} + f_{R\\,i,j,k+1} + f_{R\\,i,j,k-1} - 6 f_{R\\,i,j,k}}{h^{2}},\n$$\nwith truncation error $\\mathcal{O}\\!\\left(h^{2}\\right)$ inherited from the one-dimensional second derivative approximations.\n\nTo discretize the elliptic scalar field equation, one evaluates the right-hand side locally at $(i,j,k)$, using the functional dependence $\\delta R\\!\\big(f_{R\\,i,j,k}\\big)$ and the sampled density contrast $\\delta\\rho_{i,j,k}$. The resulting discrete equation at an interior grid point is\n$$\n\\frac{f_{R\\,i+1,j,k} + f_{R\\,i-1,j,k} + f_{R\\,i,j+1,k} + f_{R\\,i,j-1,k} + f_{R\\,i,j,k+1} + f_{R\\,i,j,k-1} - 6 f_{R\\,i,j,k}}{h^{2}}\n\\;=\\;\n\\frac{a^{2}}{3}\\Big[\\,\\delta R\\!\\big(f_{R\\,i,j,k}\\big) \\;-\\; 8\\pi G\\,\\delta\\rho_{i,j,k}\\,\\Big],\n$$\nwhich is second-order accurate in $h$ for smooth $f_{R}$.\n\nThe requested final expression, the second-order accurate finite-difference stencil for $\\nabla^{2} f_{R}$ at $(i,j,k)$, is the numerator divided by $h^{2}$ shown above.", "answer": "$$\\boxed{\\frac{f_{R\\,i+1,j,k}+f_{R\\,i-1,j,k}+f_{R\\,i,j+1,k}+f_{R\\,i,j-1,k}+f_{R\\,i,j,k+1}+f_{R\\,i,j,k-1}-6 f_{R\\,i,j,k}}{h^{2}}}$$", "id": "3487331"}, {"introduction": "After writing a solver, the most crucial question is: \"Is it correct?\" This practice introduces the indispensable process of code validation by testing your numerical solution against a known analytic truth. You will implement a Fourier-space spectral solver for the Helmholtz equation, which describes the scalar field in linearized $f(R)$ gravity, and compare its output to the classic Yukawa potential sourced by a point mass. This task not only hones your skills in implementing efficient spectral methods but also teaches the rigorous methodology of quantifying numerical error, a procedure essential for developing trust in any scientific code [@problem_id:3487375].", "problem": "You are tasked with validating a numerical solver for the modified gravity Helmholtz-type field equation that arises in linearized $f(R)$ gravity when the scalar degree of freedom has a finite Compton wavelength. Starting from fundamental physical principles and well-tested numerical facts, the goal is to compare a Fourier-space solver for the static field equation of a point-source in a periodic cubic domain to the known analytic Yukawa-type solution and quantify deviations as grid resolution is varied.\n\nBegin from the following base:\n- The modified gravitational potential in linearized $f(R)$ gravity is mediated by a scalar mode with a mass parameter $m$ that produces screened, Yukawa-type behavior. In the static, weak-field limit with non-relativistic sources, the scalar potential obeys a modified Poisson equation of Helmholtz form, which is a linear Partial Differential Equation (PDE).\n- The three-dimensional Fast Fourier Transform (FFT) on a uniform grid converts spatial convolution and differential operators into algebraic operations in wave number space, enabling spectral solvers for linear PDEs on periodic domains.\n- The Green’s function for the three-dimensional Helmholtz operator characterizes the analytic point-mass response and has Yukawa-like radial decay.\n\nConstruct a complete program that:\n1. Solves the static linear PDE on a cubic, periodic box of side length $L$ using a uniform grid with $N$ points per dimension. Assume dimensionless units with $G=1$ (Newton’s gravitational constant), total point mass $M=1$, and box size $L=1$.\n2. Approximates the point source at the box center by a narrow, normalized three-dimensional Gaussian density with standard deviation $\\sigma$ chosen proportional to the grid spacing so that $\\sigma = \\alpha \\, \\Delta x$, where $\\Delta x = L/N$ and $\\alpha$ is a fixed constant. Normalize the Gaussian to ensure that the discrete integral over the box equals $M$ to machine precision. The Gaussian regularization is necessary to avoid aliasing and to make the discrete FFT-based solver stable.\n3. Uses a spectral Helmholtz solver: transform the density $\\rho(\\mathbf{x})$ to wave number space, apply the algebraic Helmholtz kernel, and transform back to configuration space to obtain the potential $\\Phi(\\mathbf{x})$ on the grid. Use the angular wave number components $k_x$, $k_y$, $k_z$, constructed from the FFT frequency conventions for a periodic box of side $L$, and apply the appropriate discrete kernel factor of the Helmholtz operator.\n4. Compares the numerical potential $\\Phi(\\mathbf{x})$ to the analytic Yukawa-like point-mass potential for the same $m$ at grid points with radii $r$ in a shell $r \\in [r_{\\min}, r_{\\max}]$, where $r_{\\min} = 2 \\Delta x$ and $r_{\\max} = L/4$. This excludes the singular core and minimizes contamination from periodic images, while providing a fair measure of solver quality within the box. Correct for the physically irrelevant constant offset by fitting and subtracting the best constant that minimizes the squared difference on the comparison shell.\n5. Computes a single scalar deviation metric per test case: the relative root-mean-square (RMS) error\n$$\n\\varepsilon_{\\mathrm{RMS}} = \\sqrt{\\frac{\\sum_{i \\in \\mathcal{S}} \\left(\\Phi_{\\mathrm{num}}(\\mathbf{x}_i) - c^\\star - \\Phi_{\\mathrm{an}}(r_i)\\right)^2}{\\sum_{i \\in \\mathcal{S}} \\left(\\Phi_{\\mathrm{an}}(r_i)\\right)^2}},\n$$\nwhere $\\mathcal{S}$ denotes the set of grid points with $r_i \\in [r_{\\min}, r_{\\max}]$, $\\Phi_{\\mathrm{num}}$ is the numerical solution, $\\Phi_{\\mathrm{an}}$ is the analytic Yukawa-like solution for a point mass, $r_i$ is the radial distance to the source, and $c^\\star$ is the constant offset chosen to minimize the numerator. Report $\\varepsilon_{\\mathrm{RMS}}$ rounded to $6$ decimal places.\n\nUse the following test suite of parameter values to probe accuracy across resolution and Yukawa range:\n- Case $1$ (coarse resolution, moderate range): $(N, m) = (16, 10)$.\n- Case $2$ (baseline resolution, moderate range): $(N, m) = (32, 10)$.\n- Case $3$ (high resolution, moderate range): $(N, m) = (64, 10)$.\n- Case $4$ (very high resolution, moderate range): $(N, m) = (128, 10)$.\n- Case $5$ (baseline resolution, short range): $(N, m) = (64, 50)$.\n- Case $6$ (baseline resolution, longer range): $(N, m) = (32, 5)$.\n\nAll quantities are in dimensionless units with $L=1$, $G=1$, $M=1$, and angles, if any, are not used. The Gaussian width factor should be fixed to $\\alpha = 0.5$ for all cases.\n\nYour program should produce a single line of output containing the six $\\varepsilon_{\\mathrm{RMS}}$ results in the order of the cases above as a comma-separated list enclosed in square brackets (e.g., $[\\varepsilon_1,\\varepsilon_2,\\varepsilon_3,\\varepsilon_4,\\varepsilon_5,\\varepsilon_6]$), with each $\\varepsilon_i$ rounded to $6$ decimal places.", "solution": "The problem requires the validation of a numerical spectral solver for the static, linear field equation in a modified theory of gravity ($f(R)$ gravity). This involves solving the Helmholtz equation on a periodic cubic domain with a regularized point source and comparing the numerical result to the known analytic solution. The comparison is quantified by the relative root-mean-square error over a specified region of the domain.\n\n### 1. Underlying Physical Model and Governing Equation\n\nIn the weak-field, static limit, a class of $f(R)$ modified gravity theories introduces a scalar degree of freedom that modifies the standard Newtonian gravitational potential. This scalar field is massive, with a mass parameter denoted by $m$. Its presence leads to a screening mechanism where the gravitational interaction reverts to the standard Newtonian form at short distances but is suppressed at distances larger than the scalar's Compton wavelength, $\\lambda_C \\sim 1/m$.\n\nThe combined gravitational potential, $\\Phi(\\mathbf{x})$, sourced by a non-relativistic mass density $\\rho(\\mathbf{x})$, is described by a modified Poisson equation of the Helmholtz type:\n$$\n(\\nabla^2 - m^2) \\Phi(\\mathbf{x}) = 4\\pi G \\rho(\\mathbf{x})\n$$\nwhere $\\nabla^2$ is the Laplace operator and $G$ is the gravitational constant. For this problem, we work in dimensionless units where the box size is $L=1$, the total mass is $M=1$, and Newton's constant is $G=1$. The equation becomes:\n$$\n(\\nabla^2 - m^2) \\Phi(\\mathbf{x}) = 4\\pi \\rho(\\mathbf{x})\n$$\nFor a point mass $M$ located at the origin, i.e., $\\rho(\\mathbf{x}) = M \\delta(\\mathbf{x})$, the analytic solution to this equation in an infinite domain is the Yukawa potential:\n$$\n\\Phi_{\\mathrm{an}}(r) = - \\frac{G M e^{-mr}}{r}\n$$\nwhere $r = |\\mathbf{x}|$ is the radial distance from the source. With our choice of units ($G=1$, $M=1$), this simplifies to:\n$$\n\\Phi_{\\mathrm{an}}(r) = - \\frac{e^{-mr}}{r}\n$$\nThis analytic solution serves as the benchmark against which our numerical solution will be compared.\n\n### 2. Numerical Solution via Spectral Method\n\nWe solve the Helmholtz equation on a periodic cubic domain of side length $L=1$, discretized into a uniform grid of $N \\times N \\times N$ points. The grid spacing is $\\Delta x = L/N$. The periodicity of the domain makes the Fourier spectral method an exceptionally efficient and accurate choice.\n\nThe method leverages the convolution theorem and the differentiation property of the Fourier Transform. The Fourier transform of the Laplacian operator is $\\mathcal{F}[\\nabla^2 f(\\mathbf{x})] = -k^2 \\tilde{f}(\\mathbf{k})$, where $\\tilde{f}(\\mathbf{k})$ is the Fourier transform of $f(\\mathbf{x})$ and $k=|\\mathbf{k}|$ is the magnitude of the wave vector $\\mathbf{k}$. Applying the Fourier transform to the Helmholtz equation converts the partial differential equation into a simple algebraic equation in wave number space:\n$$\n(-k^2 - m^2) \\tilde{\\Phi}(\\mathbf{k}) = 4\\pi \\tilde{\\rho}(\\mathbf{k})\n$$\nHere, $\\tilde{\\Phi}(\\mathbf{k})$ and $\\tilde{\\rho}(\\mathbf{k})$ are the discrete Fourier transforms of the potential and density fields on the grid, respectively. We can solve directly for the potential in Fourier space:\n$$\n\\tilde{\\Phi}(\\mathbf{k}) = - \\frac{4\\pi \\tilde{\\rho}(\\mathbf{k})}{k^2 + m^2}\n$$\nThis expression is the Helmholtz kernel applied in Fourier space. Since all test cases have $m > 0$, the denominator $k^2+m^2$ is strictly positive for all real wave vectors $\\mathbf{k}$, so the operation is well-defined for all modes, including the $k=0$ (DC) mode.\n\nThe numerical solution $\\Phi_{\\mathrm{num}}(\\mathbf{x})$ in configuration space is then recovered by performing an inverse Fourier transform on $\\tilde{\\Phi}(\\mathbf{k})$.\n\n### 3. Implementation Details\n\n**Source Regularization**: A true point mass, represented by a Dirac delta function $\\delta(\\mathbf{x})$, is singular and cannot be represented on a discrete grid without aliasing errors. We regularize the source by modeling it as a narrow, three-dimensional Gaussian function centered at the origin of the coordinate system:\n$$\n\\rho(\\mathbf{x}) = A \\exp\\left(-\\frac{r^2}{2\\sigma^2}\\right)\n$$\nThe standard deviation $\\sigma$ is chosen to be a fraction of the grid spacing, $\\sigma = \\alpha \\Delta x$, with $\\alpha = 0.5$. The normalization constant $A$ is set such that the discrete integral over the box equals the total mass $M=1$: $\\sum_{i,j,k} \\rho(\\mathbf{x}_{ijk}) (\\Delta x)^3 = M$.\n\n**Computational Workflow**:\n1.  **Grid Setup**: A three-dimensional coordinate grid is constructed, centered at the origin. Let the coordinates for one dimension be $x_i = (-L/2 + i \\cdot \\Delta x)$ for $i=0, \\dots, N-1$.\n2.  **Density Field**: The normalized Gaussian density $\\rho(\\mathbf{x})$ is computed on this centered grid.\n3.  **Forward FFT**: For use with standard FFT algorithms, the centered grid data $\\rho(\\mathbf{x})$ is shifted using `ifftshift` to place the origin at the array index $(0,0,0)$. The 3D Fast Fourier Transform (`fftn`) is then applied to obtain $\\tilde{\\rho}(\\mathbf{k})$.\n4.  **Wave Vector Grid**: A corresponding grid of wave vectors $\\mathbf{k}=(k_x, k_y, k_z)$ is generated using the `fftfreq` function, which produces wave numbers in the order expected by the FFT algorithm: $k_i = 2\\pi f_i$, where $f_i$ are the spatial frequencies.\n5.  **Kernel Application**: The algebraic Helmholtz kernel is applied element-wise to $\\tilde{\\rho}(\\mathbf{k})$ to compute $\\tilde{\\Phi}(\\mathbf{k})$.\n6.  **Inverse FFT**: The inverse 3D FFT (`ifftn`) is applied to $\\tilde{\\Phi}(\\mathbf{k})$ to obtain the potential in configuration space (in FFT order).\n7.  **Final Potential**: The result is shifted back to the centered representation using `fftshift`, and the real part is taken to yield the numerical potential $\\Phi_{\\mathrm{num}}(\\mathbf{x})$.\n\n### 4. Error Analysis and Validation Metric\n\nThe accuracy of the numerical solver is assessed by comparing $\\Phi_{\\mathrm{num}}$ to the analytic solution $\\Phi_{\\mathrm{an}}$.\n\n**Comparison Region**: The comparison is restricted to a spherical shell $\\mathcal{S}$ defined by radii $r \\in [r_{\\min}, r_{\\max}]$, where $r_{\\min} = 2\\Delta x$ and $r_{\\max} = L/4$. This choice serves two purposes:\n-   Excluding $r  2\\Delta x$ avoids the region near the source where the Gaussian regularization causes the numerical potential to deviate significantly from the singular $1/r$ behavior of the true point-mass solution.\n-   Excluding $r > L/4$ minimizes contamination from periodic images of the source, which are inherent to the periodic boundary conditions of the solver but absent in the infinite-domain analytic formula.\n\n**Offset Correction**: The $k=0$ mode of the potential, which represents the average value over the box, has no physical consequence as only potential gradients are observable. The numerical and analytic solutions may differ by an arbitrary constant offset. To ensure a fair comparison, we calculate and subtract the optimal constant offset $c^\\star$ that minimizes the mean-squared error between the two solutions on the shell $\\mathcal{S}$. This is simply the mean of the difference:\n$$\nc^\\star = \\frac{1}{|\\mathcal{S}|} \\sum_{i \\in \\mathcal{S}} \\left( \\Phi_{\\mathrm{num}}(\\mathbf{x}_i) - \\Phi_{\\mathrm{an}}(r_i) \\right)\n$$\nwhere $|\\mathcal{S}|$ is the number of grid points in the shell.\n\n**Error Metric**: The final accuracy is quantified by the relative root-mean-square (RMS) error, $\\varepsilon_{\\mathrm{RMS}}$, defined as:\n$$\n\\varepsilon_{\\mathrm{RMS}} = \\sqrt{\\frac{\\sum_{i \\in \\mathcal{S}} \\left(\\Phi_{\\mathrm{num}}(\\mathbf{x}_i) - c^\\star - \\Phi_{\\mathrm{an}}(r_i)\\right)^2}{\\sum_{i \\in \\mathcal{S}} \\left(\\Phi_{\\mathrm{an}}(r_i)\\right)^2}}\n$$\nThis metric provides a normalized measure of the deviation of the numerical solution from the true physical behavior, after accounting for the physically irrelevant constant offset. A smaller $\\varepsilon_{\\mathrm{RMS}}$ indicates a more accurate solver.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        (16, 10),  # Case 1\n        (32, 10),  # Case 2\n        (64, 10),  # Case 3\n        (128, 10), # Case 4\n        (64, 50),  # Case 5\n        (32, 5),   # Case 6\n    ]\n\n    results = []\n    for N, m in test_cases:\n        epsilon_rms = run_simulation(N, m)\n        results.append(round(epsilon_rms, 6))\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_simulation(N, m):\n    \"\"\"\n    Performs a single simulation for a given grid resolution N and mass parameter m.\n\n    Args:\n        N (int): Number of grid points per dimension.\n        m (float): Mass parameter for the Yukawa potential.\n\n    Returns:\n        float: The calculated relative RMS error epsilon_RMS.\n    \"\"\"\n    # --- 1. Define Constants and Grid Parameters ---\n    L = 1.0  # Box size\n    M = 1.0  # Total mass\n    G = 1.0  # Gravitational constant\n    alpha = 0.5  # Gaussian width factor\n\n    dx = L / N  # Grid spacing\n    sigma = alpha * dx  # Gaussian standard deviation\n\n    # --- 2. Create Centered Coordinate Grid ---\n    # Create monotonic coordinates from -L/2 to L/2\n    x_1d = -L/2 + np.arange(N) * dx\n    xg, yg, zg = np.meshgrid(x_1d, x_1d, x_1d, indexing='ij')\n\n    # Calculate radial distance from the center (0,0,0) for each grid point\n    r = np.sqrt(xg**2 + yg**2 + zg**2)\n\n    # --- 3. Create Regularized Source Density ---\n    # Centered Gaussian density profile\n    rho = np.exp(-r**2 / (2 * sigma**2))\n\n    # Normalize so that the discrete integral sum(rho_ijk * dx^3) equals M\n    rho_sum = np.sum(rho)\n    rho *= M / (rho_sum * dx**3)\n\n    # --- 4. Spectral Solver ---\n    # Shift the centered density to be compatible with FFT (origin at index 0)\n    rho_fft_ordered = np.fft.ifftshift(rho)\n\n    # Fourier transform the density\n    rho_k = np.fft.fftn(rho_fft_ordered)\n\n    # Create the grid of wave numbers (k)\n    k_vals = 2 * np.pi * np.fft.fftfreq(N, d=dx)\n    kx, ky, kz = np.meshgrid(k_vals, k_vals, k_vals, indexing='ij')\n    k_squared = kx**2 + ky**2 + kz**2\n\n    # Apply the Helmholtz kernel in Fourier space\n    # phi_k = -4 * pi * G * rho_k / (k^2 + m^2)\n    # Since m > 0, the denominator is never zero.\n    phi_k = -4 * np.pi * G * rho_k / (k_squared + m**2)\n    \n    # Inverse Fourier transform to get the potential in configuration space\n    phi_fft_ordered = np.fft.ifftn(phi_k)\n\n    # Shift the result back to a centered representation and take the real part\n    phi_num = np.fft.fftshift(phi_fft_ordered).real\n\n    # --- 5. Error Calculation ---\n    # Define the comparison shell\n    r_min = 2 * dx\n    r_max = L / 4\n    shell_mask = (r >= r_min)  (r = r_max)\n\n    # Select numerical solution and radial distances within the shell\n    phi_num_shell = phi_num[shell_mask]\n    r_shell = r[shell_mask]\n\n    # Calculate analytic Yukawa solution on the shell\n    # phi_an = -G * M * exp(-m*r) / r\n    # r_shell is guaranteed to be non-zero due to r_min > 0\n    phi_an_shell = -G * M * np.exp(-m * r_shell) / r_shell\n\n    # Calculate the best-fit constant offset c_star\n    diff = phi_num_shell - phi_an_shell\n    c_star = np.mean(diff)\n\n    # Calculate the numerator and denominator for the relative RMS error\n    numerator = np.sum((phi_num_shell - c_star - phi_an_shell)**2)\n    denominator = np.sum(phi_an_shell**2)\n    \n    # Calculate final error metric, avoiding division by zero\n    if denominator == 0:\n        epsilon_rms = 0.0 if numerator == 0 else np.inf\n    else:\n        epsilon_rms = np.sqrt(numerator / denominator)\n\n    return epsilon_rms\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3487375"}, {"introduction": "A numerically accurate solution is not necessarily a physically correct one. High-quality simulations must also respect the fundamental principles and internal consistencies of the physical theory being modeled. This hands-on practice guides you through the development of a suite of essential diagnostic tools to verify the physical integrity of your simulation's output. By implementing checks for residual errors, conservation laws, and the Bianchi identity, you will learn how to build a robust verification pipeline. Furthermore, this exercise culminates in testing one of the most critical physical requirements for any viable theory of modified gravity: the seamless recovery of General Relativity in the appropriate limit [@problem_id:3487398].", "problem": "Develop a complete program that, on a one-dimensional periodic domain, verifies solution quality and consistency checks for a quasi-static scalar degree of freedom in a simple toy model of modified gravity of the $f(R)$ type, and demonstrates numerical recovery of the General Relativity (GR) limit as $f_{R0} \\to 0$. The program must be self-contained and produce a single line of output in the specified format.\n\nYou must start from the following well-tested quasi-static, sub-horizon limit field content for $f(R)$-like models in the Newtonian gauge. Let $a$ denote the scale factor, $G$ the Newtonian gravitational constant, $\\delta \\rho$ the comoving matter density perturbation, $\\delta f_R$ the scalaron perturbation, and $\\Phi$ and $\\Psi$ the two Bardeen potentials:\n- The scalaron (Helmholtz-type) equation:\n$$\n\\left(\\nabla^2 - a^2 m^2(a)\\right)\\, \\delta f_R \\;=\\; \\frac{a^2}{3}\\, \\delta \\rho \\, .\n$$\n- The modified Poisson equation:\n$$\n\\nabla^2 \\Psi \\;=\\; 4 \\pi G a^2 \\, \\delta \\rho \\;-\\; \\frac{1}{2}\\, \\nabla^2 \\delta f_R \\, .\n$$\n- The gravitational slip relation:\n$$\n\\Phi - \\Psi \\;=\\; \\delta f_R \\, .\n$$\nFrom these, the lensing combination satisfies the Bianchi-identity-level consistency condition:\n$$\n\\nabla^2(\\Phi + \\Psi) \\;=\\; 8 \\pi G a^2 \\, \\delta \\rho \\, .\n$$\n\nAdopt a one-dimensional periodic box of length $L$, with a uniform grid of $N$ points, and use the Fast Fourier Transform (FFT) to solve the elliptic equations spectrally. Work at a single epoch with $a = 1$ and adopt units with $4 \\pi G a^2 = 1$ so that the standard General Relativity Poisson equation reads $\\nabla^2 \\Psi_{\\mathrm{GR}} = \\delta \\rho$. Use a single-mode matter perturbation with zero mean:\n$$\n\\delta \\rho(x) \\;=\\; A \\, \\sin(k_{\\star} x) \\, ,\n$$\nwith $k_{\\star} = 2\\pi / L$ and amplitude $A$. Use $N$ large enough to resolve the sinusoid. Solve for $\\delta f_R$ and $\\Psi$ spectrally with periodic boundary conditions by algebraic division in Fourier space, taking care of the $k=0$ mode so that fields remain mean-zero.\n\nTo parameterize the $f(R)$ model in a way that has the correct qualitative General Relativity limit, use a toy yet scientifically plausible effective mass scaling,\n$$\nm(a) \\;=\\; \\frac{H_0}{\\sqrt{|f_{R0}|}} \\, a^{-3/2} \\, ,\n$$\nand set $H_0 = 1$ in the chosen units so that at $a=1$ one has $m = 1/\\sqrt{|f_{R0}|}$. This captures the fact that $|f_{R0}| \\to 0$ implies a large scalaron mass and the recovery of the General Relativity limit with $\\delta f_R \\to 0$.\n\nImplement the following quantitative diagnostics, each expressed as a dimensionless number:\n1. Residual norms for the scalaron and the modified Poisson equations. Define the residuals in real space as\n$$\n\\mathcal{R}_f \\equiv \\nabla^2 \\delta f_R - a^2 m^2 \\delta f_R - \\frac{a^2}{3} \\delta \\rho \\, ,\n\\quad\n\\mathcal{R}_P \\equiv \\nabla^2 \\Psi - 4 \\pi G a^2 \\delta \\rho + \\frac{1}{2} \\nabla^2 \\delta f_R \\, .\n$$\nReport normalized root-mean-square (RMS) norms,\n$$\n\\|\\mathcal{R}_f\\| \\equiv \\frac{\\sqrt{\\langle \\mathcal{R}_f^2 \\rangle}}{\\sqrt{\\left\\langle \\left(\\frac{a^2}{3}\\delta \\rho \\right)^2 \\right\\rangle}} \\, ,\n\\quad\n\\|\\mathcal{R}_P\\| \\equiv \\frac{\\sqrt{\\langle \\mathcal{R}_P^2 \\rangle}}{\\sqrt{\\langle (4\\pi G a^2 \\delta \\rho)^2 \\rangle}} \\, ,\n$$\nwhere $\\langle \\cdot \\rangle$ denotes the average over the periodic domain.\n\n2. An energy-like invariant check for the scalaron equation. Define\n$$\nQ \\equiv \\int_0^L \\left[ (\\partial_x \\delta f_R)^2 + a^2 m^2 (\\delta f_R)^2 \\right] \\, dx \\, ,\n\\qquad\nS \\equiv \\int_0^L \\left( \\frac{a^2}{3} \\delta \\rho \\, \\delta f_R \\right) \\, dx \\, .\n$$\nUsing periodic boundary conditions, the field equation implies the balance condition $Q + S = 0$. Report the dimensionless deviation\n$$\n\\mathcal{E}_{\\mathrm{bal}} \\equiv \\frac{|Q + S|}{|Q| + |S|} \\, .\n$$\n\n3. A Bianchi-identity-level lensing consistency check using the derived lensing equation,\n$$\n\\mathcal{R}_L \\equiv \\nabla^2(\\Phi + \\Psi) - 8 \\pi G a^2 \\delta \\rho \\, ,\n\\quad\n\\|\\mathcal{R}_L\\| \\equiv \\frac{\\sqrt{\\langle \\mathcal{R}_L^2 \\rangle}}{\\sqrt{\\langle (8 \\pi G a^2 \\delta \\rho)^2 \\rangle}} \\, .\n$$\n\n4. General Relativity recovery error,\n$$\n\\mathcal{E}_{\\mathrm{GR}} \\equiv \\frac{\\sqrt{\\left\\langle \\left( \\nabla^2 \\Psi - 4 \\pi G a^2 \\delta \\rho \\right)^2 \\right\\rangle}}{\\sqrt{\\langle (4 \\pi G a^2 \\delta \\rho)^2 \\rangle}} \\, ,\n$$\nwhich must approach $0$ as $f_{R0} \\to 0$.\n\nAll fields should be evaluated on the discrete grid by spectral differentiation: compute discrete Fourier modes $k_n = 2\\pi n/L$ with integer $n$ on the grid, form algebraic solutions mode-by-mode, and inverse-transform to real space. Treat the $k=0$ mode carefully to avoid division by $0$.\n\nUse the following test suite, with periodic box length $L = 2\\pi$, grid size $N = 256$, amplitude $A = 1$, scale factor $a = 1$, and $4\\pi G a^2 = 1$:\n- Case $1$: $f_{R0} = -10^{-4}$.\n- Case $2$: $f_{R0} = -10^{-6}$.\n- Case $3$: $f_{R0} = -10^{-8}$.\n- Case $4$: $f_{R0} = -10^{-12}$.\n\nFor each case, solve for $\\delta f_R$, $\\Psi$, and $\\Phi$, compute the four diagnostics $\\|\\mathcal{R}_f\\|$, $\\|\\mathcal{R}_P\\|$, $\\|\\mathcal{R}_L\\|$, $\\mathcal{E}_{\\mathrm{bal}}$, and $\\mathcal{E}_{\\mathrm{GR}}$, and aggregate the results as a single flat list in the order\n$$\n\\left[ \\|\\mathcal{R}_f\\|_1, \\|\\mathcal{R}_P\\|_1, \\|\\mathcal{R}_L\\|_1, \\mathcal{E}_{\\mathrm{bal},1}, \\mathcal{E}_{\\mathrm{GR},1}, \\ldots, \\|\\mathcal{R}_f\\|_4, \\|\\mathcal{R}_P\\|_4, \\|\\mathcal{R}_L\\|_4, \\mathcal{E}_{\\mathrm{bal},4}, \\mathcal{E}_{\\mathrm{GR},4} \\right] \\, .\n$$\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[r1,r2,r3,...]\"). All reported quantities are dimensionless floats. Angles do not appear, so no angle unit is required. No physical units must be reported in the output; the adopted unit system is internal to the computation and the diagnostics are dimensionless by construction.\n\nDesign the algorithm so that it is numerically stable and exploits the spectral diagonalization of the Laplacian. Ensure that the residual norms are small compared to $1$ at finite $|f_{R0}|$ and that $\\mathcal{E}_{\\mathrm{GR}}$ decreases as $|f_{R0}|$ decreases, illustrating numerical recovery of the General Relativity limit.", "solution": "The problem requires the numerical solution of a system of coupled linear elliptic partial differential equations that describe a scalar degree of freedom in a toy model of $f(R)$ modified gravity. The solution is to be performed on a one-dimensional periodic domain, and its quality must be verified using a suite of quantitative diagnostics. A key objective is to demonstrate the numerical recovery of the General Relativity (GR) limit.\n\nThe fundamental principle guiding the solution is the use of a spectral method based on the Fast Fourier Transform (FFT). This approach is ideally suited for solving linear partial differential equations with constant coefficients on a periodic domain. The reason is that the complex exponential functions, which form the basis of the Fourier series, are eigenfunctions of the differentiation operator. Consequently, the Fourier transform diagonalizes the Laplacian operator, $\\nabla^2 = d^2/dx^2$. For a function $g(x)$ with Fourier transform $\\hat{g}(k)$, the transform of its second derivative is given by the simple algebraic relation $\\widehat{\\nabla^2 g}(k) = (ik)^2 \\hat{g}(k) = -k^2 \\hat{g}(k)$, where $k$ is the wavenumber. This property transforms the differential equations into a set of independent algebraic equations for each Fourier mode $k$, which can be solved trivially.\n\nLet us outline the systematic procedure.\n\nFirst, we establish the computational domain and discretization. We use a uniform grid of $N$ points $x_j = j (L/N)$ for $j = 0, 1, \\ldots, N-1$ on a periodic domain of length $L$. The corresponding discrete Fourier wavenumbers are given by $k_n = (2\\pi/L)n$ for integers $n$ appropriately arranged for the FFT algorithm. We use the `numpy.fft.fftfreq` utility to generate these wavenumbers in the standard order. The problem specifies the physical parameters: scale factor $a=1$, box length $L=2\\pi$, grid size $N=256$, and amplitude of the matter perturbation $A=1$. A system of units is adopted where $4\\pi G a^2 = 1$ and $H_0 = 1$. The matter perturbation is a single sinusoidal mode, $\\delta \\rho(x) = A \\sin(k_{\\star} x)$, with $k_{\\star} = 2\\pi/L = 1$. This source term has zero mean, so its $k=0$ Fourier mode is zero.\n\nThe solution proceeds by solving the given equations in Fourier space.\n\n1.  **Solve the Scalaron Equation:**\n    The governing equation for the scalaron perturbation, $\\delta f_R$, is a Helmholtz-type equation:\n    $$ \\left(\\nabla^2 - a^2 m^2\\right)\\, \\delta f_R \\;=\\; \\frac{a^2}{3}\\, \\delta \\rho $$\n    In Fourier space, this becomes:\n    $$ \\left(-k^2 - a^2 m^2\\right)\\, \\widehat{\\delta f_R}(k) \\;=\\; \\frac{a^2}{3}\\, \\widehat{\\delta \\rho}(k) $$\n    where $\\widehat{\\delta f_R}$ and $\\widehat{\\delta \\rho}$ are the Fourier transforms of $\\delta f_R$ and $\\delta \\rho$, respectively. The mass parameter $m$ is given by $m = H_0/\\sqrt{|f_{R0}|} \\, a^{-3/2}$, which simplifies to $m^2 = 1/|f_{R0}|$ with the given parameters. The algebraic solution for the Fourier modes of the scalaron is:\n    $$ \\widehat{\\delta f_R}(k) \\;=\\; -\\frac{(a^2/3) \\widehat{\\delta \\rho}(k)}{k^2 + a^2 m^2} $$\n    Since $\\widehat{\\delta \\rho}(k=0) = 0$, the $k=0$ mode $\\widehat{\\delta f_R}(k=0)$ is also zero, ensuring $\\delta f_R$ has zero mean. The real-space field $\\delta f_R(x)$ is recovered by applying the inverse FFT.\n\n2.  **Solve the Modified Poisson Equation:**\n    The equation for the gravitational potential $\\Psi$ is:\n    $$ \\nabla^2 \\Psi \\;=\\; 4 \\pi G a^2 \\, \\delta \\rho \\;-\\; \\frac{1}{2}\\, \\nabla^2 \\delta f_R $$\n    Transforming to Fourier space yields:\n    $$ -k^2 \\hat{\\Psi}(k) \\;=\\; (4 \\pi G a^2) \\, \\widehat{\\delta \\rho}(k) \\;-\\; \\frac{1}{2}\\,(-k^2 \\widehat{\\delta f_R}(k)) $$\n    $$ \\hat{\\Psi}(k) \\;=\\; -\\frac{4 \\pi G a^2}{k^2} \\, \\widehat{\\delta \\rho}(k) \\;-\\; \\frac{1}{2}\\, \\widehat{\\delta f_R}(k) $$\n    For modes where $k \\neq 0$, this equation is directly solvable. For the $k=0$ mode, the first term is of the form $0/0$. We resolve this ambiguity by imposing the physical condition that the potential has zero mean, which implies $\\hat{\\Psi}(k=0)=0$. The real-space potential $\\Psi(x)$ is then found via inverse FFT.\n\n3.  **Compute the Second Potential $\\Phi$:**\n    The second Bardeen potential, $\\Phi$, is determined by the gravitational slip relation:\n    $$ \\Phi(x) \\;=\\; \\Psi(x) + \\delta f_R(x) $$\n    This is a simple addition of the two fields already computed in real space.\n\nWith the fields $\\delta f_R$, $\\Psi$, and $\\Phi$ determined, we compute the four required diagnostics. To ensure high accuracy and avoid introducing finite-difference errors, all spatial derivatives required for the diagnostics are also computed spectrally (i.e., by multiplication in Fourier space followed by an inverse FFT). All averages $\\langle \\cdot \\rangle$ are computed as means over the grid points, and integrals $\\int_0^L (\\cdot) dx$ are computed as the mean value multiplied by the domain length $L$.\n\n1.  **Residual Norms $\\|\\mathcal{R}_f\\|$ and $\\|\\mathcal{R}_P\\|$**: These checks verify that the numerical solution satisfies the original differential equations to high precision. The residuals $\\mathcal{R}_f$ and $\\mathcal{R}_P$ are computed in real space using spectrally-calculated derivatives. Since the solution method is based on satisfying these equations algebraically in Fourier space, the residuals should be zero up to floating-point precision. Their normalized RMS norms test the self-consistency of the numerical solver.\n\n2.  **Energy Balance $\\mathcal{E}_{\\mathrm{bal}}$**: This diagnostic verifies a conservation-like law derived from the scalaron equation. By multiplying the scalaron equation by $\\delta f_R$ and integrating over the periodic domain (using integration by parts), one derives the identity $Q+S=0$, where $Q$ and $S$ are the specified integrals. The dimensionless ratio $\\mathcal{E}_{\\mathrm{bal}} = |Q+S|/(|Q|+|S|)$ should be close to zero, reflecting the accuracy of both the field solution and the numerical integration.\n\n3.  **Lensing Consistency $\\|\\mathcal{R}_L\\|$**: This check verifies a fundamental identity, $\\nabla^2(\\Phi + \\Psi) = 8 \\pi G a^2 \\delta \\rho$, which is a direct consequence of the underlying field equations. Similar to the other residual norms, $\\|\\mathcal{R}_L\\|$ should be near machine epsilon, providing a strong test of the inter-consistency of the full solved system.\n\n4.  **GR Recovery Error $\\mathcal{E}_{\\mathrm{GR}}$**: This crucial diagnostic quantifies the deviation of the computed potential $\\Psi$ from the solution expected in standard General Relativity, where $\\nabla^2 \\Psi_{\\mathrm{GR}} = 4 \\pi G a^2 \\delta \\rho$. The error $\\mathcal{E}_{\\mathrm{GR}}$ is the normalized RMS of the GR residual, $\\nabla^2 \\Psi - 4\\pi G a^2 \\delta \\rho$. From the modified Poisson equation, this residual equals $-\\frac{1}{2}\\nabla^2\\delta f_R$. In the limit $|f_{R0}| \\to 0$, the scalaron mass $m \\to \\infty$, which suppresses the scalaron field, $\\delta f_R \\to 0$. Consequently, $\\mathcal{E}_{\\mathrm{GR}}$ is expected to approach $0$, demonstrating a successful recovery of the GR limit.\n\nThe implementation iterates through the specified values of $f_{R0}$, from $-10^{-4}$ to $-10^{-12}$, computing these five diagnostics for each case and aggregating the results into a single list for output.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom numpy.fft import fft, ifft, fftfreq\n\ndef solve():\n    \"\"\"\n    Solves the f(R) toy model equations and computes diagnostics for a suite of test cases.\n    \"\"\"\n\n    def solve_case(f_R0, L, N, A, G_eff, H0, a):\n        \"\"\"\n        Computes the solution and diagnostics for a single f(R) parameter case.\n        \"\"\"\n        # 1. Setup grid and constants\n        x = np.linspace(0, L, N, endpoint=False)\n        dx = L / N\n        k = 2 * np.pi * fftfreq(N, d=dx)\n\n        # 2. Define source term and its Fourier transform\n        k_star = 2 * np.pi / L\n        delta_rho = A * np.sin(k_star * x)\n        delta_rho_k = fft(delta_rho)\n\n        # 3. Model parameters\n        a_sq = a**2\n        m_sq = H0**2 / np.abs(f_R0) * a**(-3)\n        \n        # 4. Solve for the scalaron field delta_fR\n        # The equation in Fourier space is: (-k^2 - a^2*m^2) * delta_fR_k = (a^2/3) * delta_rho_k\n        denominator_fR = k**2 + a_sq * m_sq\n        delta_fR_k = -((a_sq / 3.0) * delta_rho_k) / denominator_fR\n        \n        # k=0 mode of delta_rho_k is zero (up to machine precision) for a pure sine wave,\n        # and the denominator is non-zero, so delta_fR_k[0] is correctly ~0.\n        delta_fR = ifft(delta_fR_k).real\n\n        # 5. Solve for the gravitational potential Psi\n        # The equation in Fourier space is: -k^2 * Psi_k = G_eff * delta_rho_k + 0.5 * k^2 * delta_fR_k\n        # This simplifies to: Psi_k = - (G_eff * delta_rho_k / k^2) - 0.5 * delta_fR_k\n        Psi_k = np.zeros_like(k, dtype=np.complex128)\n        k_nonzero_mask = k != 0\n        \n        # For k != 0, solve algebraically.\n        Psi_k[k_nonzero_mask] = - (G_eff * delta_rho_k[k_nonzero_mask]) / k[k_nonzero_mask]**2 - 0.5 * delta_fR_k[k_nonzero_mask]\n        \n        # Psi_k[0] remains 0, enforcing a zero mean for the potential.\n        Psi = ifft(Psi_k).real\n\n        # 6. Compute the second potential Phi\n        Phi = Psi + delta_fR\n\n        # 7. Compute diagnostics\n        \n        # Helper functions for spectral derivatives and norms\n        def laplacian(field_real):\n            field_k = fft(field_real)\n            lap_field_k = -k**2 * field_k\n            return ifft(lap_field_k).real\n\n        def grad(field_real):\n            field_k = fft(field_real)\n            grad_field_k = 1j * k * field_k\n            return ifft(grad_field_k).real\n\n        def rms(field):\n            return np.sqrt(np.mean(field**2))\n\n        # Diagnostic 1: Residual Norms\n        lap_delta_fR = laplacian(delta_fR)\n        R_f = lap_delta_fR - a_sq * m_sq * delta_fR - (a_sq / 3.0) * delta_rho\n        norm_source_f = rms((a_sq / 3.0) * delta_rho)\n        norm_R_f = rms(R_f) / norm_source_f if norm_source_f > 0 else 0.0\n\n        lap_Psi = laplacian(Psi)\n        R_P = lap_Psi - G_eff * delta_rho + 0.5 * lap_delta_fR\n        norm_source_P = rms(G_eff * delta_rho)\n        norm_R_P = rms(R_P) / norm_source_P if norm_source_P > 0 else 0.0\n\n        # Diagnostic 2: Energy Balance\n        grad_delta_fR = grad(delta_fR)\n        integrand_Q = grad_delta_fR**2 + a_sq * m_sq * delta_fR**2\n        Q = np.sum(integrand_Q) * dx\n        \n        integrand_S = (a_sq / 3.0) * delta_rho * delta_fR\n        S = np.sum(integrand_S) * dx\n        \n        denominator_E_bal = np.abs(Q) + np.abs(S)\n        E_bal = np.abs(Q + S) / denominator_E_bal if denominator_E_bal > 0 else 0.0\n\n        # Diagnostic 3: Lensing Consistency\n        Phi_plus_Psi = Phi + Psi\n        lap_Phi_plus_Psi = laplacian(Phi_plus_Psi)\n        R_L = lap_Phi_plus_Psi - 2.0 * G_eff * delta_rho\n        norm_source_L = rms(2.0 * G_eff * delta_rho)\n        norm_R_L = rms(R_L) / norm_source_L if norm_source_L > 0 else 0.0\n        \n        # Diagnostic 4: GR Recovery Error\n        R_GR = lap_Psi - G_eff * delta_rho\n        E_GR = rms(R_GR) / norm_source_P if norm_source_P > 0 else 0.0\n\n        return [norm_R_f, norm_R_P, norm_R_L, E_bal, E_GR]\n\n\n    # Define the test cases from the problem statement.\n    L = 2 * np.pi\n    N = 256\n    A = 1.0\n    a = 1.0\n    G_eff = 1.0  # Corresponds to 4*pi*G*a^2 = 1\n    H0 = 1.0\n    \n    test_cases = [\n        -1e-4,\n        -1e-6,\n        -1e-8,\n        -1e-12,\n    ]\n\n    results = []\n    for f_R0 in test_cases:\n        case_results = solve_case(f_R0, L, N, A, G_eff, H0, a)\n        results.extend(case_results)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3487398"}]}