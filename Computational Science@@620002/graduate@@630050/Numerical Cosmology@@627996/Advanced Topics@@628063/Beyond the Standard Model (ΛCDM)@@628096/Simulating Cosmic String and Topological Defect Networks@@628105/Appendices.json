{"hands_on_practices": [{"introduction": "Before writing a single line of code for evolving cosmic string networks, it is essential to understand the conditions that ensure the numerical stability of the simulation. This practice guides you through the derivation of the Courant–Friedrichs–Lewy (CFL) condition for a standard finite-difference scheme used in field theory simulations. By applying von Neumann stability analysis, you will determine the maximum permissible time step $\\Delta t$ relative to the spatial grid spacing $\\Delta x$, a crucial parameter for preventing the exponential growth of numerical errors [@problem_id:3487032].", "problem": "In numerical cosmology simulations of cosmic string and topological defect networks, the Abelian–Higgs model is evolved on a three-dimensional cubic lattice using explicit time integration. Consider the principal (hyperbolic) part of the linearized field dynamics in natural units, where the relativistic signal speed equals $c=1$. In temporal gauge, small fluctuations of either the scalar (Higgs) field or the spatial gauge components are governed by a linear wave-like equation of the form $u_{tt} = \\nabla^{2} u$ for the purposes of analyzing the propagation and stability of the discretization. The evolution is implemented with a staggered leapfrog scheme in time: the field $u$ is stored at integer time levels $t^{n} = n\\,\\Delta t$, and its conjugate momentum (or velocity) is stored at half time levels $t^{n+1/2} = \\left(n+\\frac{1}{2}\\right)\\Delta t$, on a uniform cubic lattice with spacing $\\Delta x$ in all three spatial directions. The spatial operator is discretized by the second-order centered finite-difference Laplacian\n$$\n\\nabla^{2}_{d} u_{i,j,k} = \\frac{u_{i+1,j,k} - 2 u_{i,j,k} + u_{i-1,j,k}}{\\Delta x^{2}} + \\frac{u_{i,j+1,k} - 2 u_{i,j,k} + u_{i,j-1,k}}{\\Delta x^{2}} + \\frac{u_{i,j,k+1} - 2 u_{i,j,k} + u_{i,j,k-1}}{\\Delta x^{2}} \\, ,\n$$\nand the time update, when written solely in terms of $u$, has the standard second-order centered form\n$$\nu^{n+1}_{i,j,k} - 2\\,u^{n}_{i,j,k} + u^{n-1}_{i,j,k} = \\Delta t^{2}\\,\\nabla^{2}_{d} u^{n}_{i,j,k} \\, .\n$$\nUsing von Neumann (Fourier) stability analysis applied to the above discrete scheme in three spatial dimensions, derive the Courant–Friedrichs–Lewy (CFL) condition in terms of the ratio $\\sigma \\equiv \\Delta t / \\Delta x$ under the assumption $c=1$. Take the most restrictive bound that ensures stability for all lattice Fourier modes. Then, assuming a safety factor $s = \\frac{1}{2}$ to mitigate numerical pathologies near defect cores and high-curvature regions, provide:\n1) the exact supremum of the admissible ratio $\\Delta t / \\Delta x$ implied by the CFL condition for this three-dimensional scheme, and\n2) the corresponding conservative safe choice $s \\times (\\Delta t / \\Delta x)_{\\text{max}}$.\nReport both of these as exact analytical expressions. No rounding is required, and the quantities are dimensionless. Your final answers must be given as exact expressions without units.", "solution": "The problem requires the derivation of the Courant–Friedrichs–Lewy (CFL) stability condition for a second-order finite-difference scheme applied to the three-dimensional linear wave equation, $u_{tt} = \\nabla^{2} u$. The method specified is the von Neumann (or Fourier) stability analysis.\n\nThe discrete scheme is given by:\n$$\n\\frac{u^{n+1}_{i,j,k} - 2\\,u^{n}_{i,j,k} + u^{n-1}_{i,j,k}}{\\Delta t^{2}} = \\nabla^{2}_{d} u^{n}_{i,j,k}\n$$\nwhere $\\Delta t$ is the time step, and $u^{n}_{i,j,k}$ denotes the field $u$ at time $t^n = n\\,\\Delta t$ and spatial lattice point $(i\\,\\Delta x, j\\,\\Delta x, k\\,\\Delta x)$. The discrete Laplacian operator $\\nabla^{2}_{d}$ is defined as:\n$$\n\\nabla^{2}_{d} u_{i,j,k} = \\frac{u_{i+1,j,k} - 2 u_{i,j,k} + u_{i-1,j,k}}{\\Delta x^{2}} + \\frac{u_{i,j+1,k} - 2 u_{i,j,k} + u_{i,j-1,k}}{\\Delta x^{2}} + \\frac{u_{i,j,k+1} - 2 u_{i,j,k} + u_{i,j,k-1}}{\\Delta x^{2}}\n$$\nIn von Neumann analysis, we examine the behavior of a single Fourier mode on the lattice. We propose a solution of the form:\n$$\nu^{n}_{i,j,k} = G^{n}(\\vec{k}) \\exp\\left[i(k_x i \\Delta x + k_y j \\Delta x + k_z k \\Delta x)\\right]\n$$\nwhere $\\vec{k} = (k_x, k_y, k_z)$ is the wave vector of the mode, $i$ is the imaginary unit, and $G(\\vec{k})$ is the amplification factor per time step. For the scheme to be stable, the magnitude of the amplification factor must satisfy $|G(\\vec{k})| \\le 1$ for all possible wave vectors $\\vec{k}$.\n\nFirst, we apply the discrete Laplacian operator $\\nabla^{2}_{d}$ to this Fourier mode. Consider the term for the $x$-direction:\n\\begin{align*}\n\\frac{u^{n}_{i+1,j,k} - 2 u^{n}_{i,j,k} + u^{n}_{i-1,j,k}}{\\Delta x^{2}} &= \\frac{G^n}{\\Delta x^2} \\left( \\exp[i(k_x(i+1)\\Delta x + \\dots)] - 2\\exp[i(k_x i\\Delta x + \\dots)] + \\exp[i(k_x(i-1)\\Delta x + \\dots)] \\right) \\\\\n&= \\frac{u^{n}_{i,j,k}}{\\Delta x^2} \\left( \\exp[i k_x \\Delta x] - 2 + \\exp[-i k_x \\Delta x] \\right) \\\\\n&= \\frac{u^{n}_{i,j,k}}{\\Delta x^2} \\left( 2 \\cos(k_x \\Delta x) - 2 \\right) \\\\\n&= -\\frac{2 u^{n}_{i,j,k}}{\\Delta x^2} \\left( 1 - \\cos(k_x \\Delta x) \\right)\n\\end{align*}\nUsing the half-angle identity $1 - \\cos(\\theta) = 2 \\sin^2(\\theta/2)$, this becomes:\n$$\n-\\frac{4 u^{n}_{i,j,k}}{\\Delta x^2} \\sin^2\\left(\\frac{k_x \\Delta x}{2}\\right)\n$$\nApplying this to all three spatial directions, the action of the full discrete Laplacian on the Fourier mode is:\n$$\n\\nabla^{2}_{d} u^{n}_{i,j,k} = -\\frac{4 u^{n}_{i,j,k}}{\\Delta x^2} \\left[ \\sin^2\\left(\\frac{k_x \\Delta x}{2}\\right) + \\sin^2\\left(\\frac{k_y \\Delta x}{2}\\right) + \\sin^2\\left(\\frac{k_z \\Delta x}{2}\\right) \\right]\n$$\nNow, we substitute the Fourier mode ansatz into the full discretized wave equation:\n$$\n\\frac{G^{n+1} - 2G^n + G^{n-1}}{G^n} \\frac{u^{n}_{i,j,k}}{\\Delta t^2} = \\frac{\\nabla^{2}_{d} u^{n}_{i,j,k}}{u^{n}_{i,j,k}} u^{n}_{i,j,k}\n$$\nDividing by $u^{n}_{i,j,k}$ and multiplying by $\\Delta t^2$ and $G^n$, we get:\n$$\nG^{n+1} - 2G^n + G^{n-1} = \\Delta t^2 \\left( -\\frac{4 G^n}{\\Delta x^2} \\left[ \\sin^2\\left(\\frac{k_x \\Delta x}{2}\\right) + \\sin^2\\left(\\frac{k_y \\Delta x}{2}\\right) + \\sin^2\\left(\\frac{k_z \\Delta x}{2}\\right) \\right] \\right)\n$$\nDividing by $G^{n-1}$ leads to the characteristic equation for the amplification factor $G$:\n$$\nG^2 - 2G + 1 = -4 G \\frac{\\Delta t^2}{\\Delta x^2} \\left[ \\sin^2\\left(\\frac{k_x \\Delta x}{2}\\right) + \\sin^2\\left(\\frac{k_y \\Delta x}{2}\\right) + \\sin^2\\left(\\frac{k_z \\Delta x}{2}\\right) \\right]\n$$\nLet $\\sigma = \\Delta t / \\Delta x$ be the Courant ratio and define the term $S_k$:\n$$\nS_k = \\sin^2\\left(\\frac{k_x \\Delta x}{2}\\right) + \\sin^2\\left(\\frac{k_y \\Delta x}{2}\\right) + \\sin^2\\left(\\frac{k_z \\Delta x}{2}\\right)\n$$\nThe characteristic equation is a quadratic equation in $G$:\n$$\nG^2 - 2(1 - 2\\sigma^2 S_k)G + 1 = 0\n$$\nThe roots are given by $G = \\frac{-b \\pm \\sqrt{b^2-4ac}}{2a}$:\n$$\nG = (1 - 2\\sigma^2 S_k) \\pm \\sqrt{(1 - 2\\sigma^2 S_k)^2 - 1}\n$$\nFor stability, we require $|G| \\le 1$. If the discriminant is positive, $(1 - 2\\sigma^2 S_k)^2 > 1$, the roots are real, and one root will have magnitude greater than $1$, leading to instability. Therefore, for stability, the discriminant must be non-positive:\n$$\n(1 - 2\\sigma^2 S_k)^2 - 1 \\le 0 \\implies (1 - 2\\sigma^2 S_k)^2 \\le 1\n$$\nThis is equivalent to:\n$$\n-1 \\le 1 - 2\\sigma^2 S_k \\le 1\n$$\nThe right-hand inequality, $1 - 2\\sigma^2 S_k \\le 1$, implies $-2\\sigma^2 S_k \\le 0$, which is always true since $\\sigma^2 \\ge 0$ and $S_k \\ge 0$.\nThe left-hand inequality gives the stability condition:\n$$\n-1 \\le 1 - 2\\sigma^2 S_k \\implies 2\\sigma^2 S_k \\le 2 \\implies \\sigma^2 S_k \\le 1\n$$\nWhen this condition holds, the roots are complex conjugates of the form $G = A \\pm i B$, with $|G|^2 = A^2+B^2 = (1 - 2\\sigma^2 S_k)^2 + (1-(1 - 2\\sigma^2 S_k)^2) = 1$. Thus, $|G|=1$, which corresponds to a stable, non-dissipative scheme.\n\nTo ensure stability for all possible modes, this condition must hold for the maximum possible value of $S_k$. The lattice wave vectors $k_x, k_y, k_z$ are defined within the first Brillouin zone, typically $-\\frac{\\pi}{\\Delta x} \\le k_{x,y,z} \\le \\frac{\\pi}{\\Delta x}$. The arguments of the sine-squared functions, e.g., $\\frac{k_x \\Delta x}{2}$, therefore range from $-\\frac{\\pi}{2}$ to $\\frac{\\pi}{2}$. The function $\\sin^2(\\theta)$ is maximized at $\\theta = \\pm \\frac{\\pi}{2}$, where its value is $1$. The maximum value of $S_k$ is attained when each term is maximized, which corresponds to the highest frequency \"checkerboard\" modes (e.g., $k_x = k_y = k_z = \\pi/\\Delta x$):\n$$\nS_{k, \\text{max}} = \\sin^2\\left(\\frac{\\pi}{2}\\right) + \\sin^2\\left(\\frac{\\pi}{2}\\right) + \\sin^2\\left(\\frac{\\pi}{2}\\right) = 1 + 1 + 1 = 3\n$$\nSubstituting this maximum value into the stability condition gives the most restrictive constraint on $\\sigma$:\n$$\n\\sigma^2 S_{k, \\text{max}} \\le 1 \\implies 3\\sigma^2 \\le 1 \\implies \\sigma^2 \\le \\frac{1}{3}\n$$\nSince $\\sigma = \\Delta t/\\Delta x \\ge 0$, we have:\n$$\n\\sigma \\le \\frac{1}{\\sqrt{3}}\n$$\nThis is the CFL condition for this scheme in three dimensions.\n\n1) The exact supremum of the admissible ratio $\\Delta t / \\Delta x$ is the maximum value allowed by this inequality:\n$$\n\\left(\\frac{\\Delta t}{\\Delta x}\\right)_{\\text{max}} = \\frac{1}{\\sqrt{3}}\n$$\n2) The conservative safe choice is calculated by multiplying this supremum by the given safety factor $s = \\frac{1}{2}$:\n$$\ns \\times \\left(\\frac{\\Delta t}{\\Delta x}\\right)_{\\text{max}} = \\frac{1}{2} \\times \\frac{1}{\\sqrt{3}} = \\frac{1}{2\\sqrt{3}}\n$$\nBoth quantities are dimensionless, as required.", "answer": "$$\n\\boxed{\\begin{pmatrix} \\frac{1}{\\sqrt{3}} & \\frac{1}{2\\sqrt{3}} \\end{pmatrix}}\n$$", "id": "3487032"}, {"introduction": "A cornerstone of scientific computing is the rigorous verification of your numerical code. This exercise introduces the fundamental practice of convergence testing, where a simulation's output is compared against a known analytic solution to confirm that the code achieves its theoretical order of accuracy. By implementing a simple leapfrog solver for the 1D wave equation—the backbone of Nambu–Goto string dynamics—you will learn how to measure the convergence rate and gain confidence in your numerical tools before applying them to more complex problems [@problem_id:3486951].", "problem": "Design and implement a self-contained numerical convergence test for a straight moving string solution in the Nambu–Goto system under conformal gauge, using a one-dimensional linear wave equation as the reduced worldsheet dynamics. The objective is to demonstrate the formal order of accuracy of a standard explicit second-order finite-difference scheme by measuring the observed convergence rate against an analytic traveling-wave solution. All angles must be interpreted in radians, and all quantities are dimensionless.\n\nStart from the following established base. The Nambu–Goto action for a string with tension $\\mu$ is given by $S = -\\mu \\int d^{2}\\xi \\, \\sqrt{-\\gamma}$, where $\\gamma$ is the determinant of the induced worldsheet metric. In conformal gauge, the transverse degrees of freedom of a straight string satisfy the linear wave equation\n$$\n\\partial_{tt} x(\\sigma, t) - \\partial_{\\sigma \\sigma} x(\\sigma, t) = 0,\n$$\nwith waves propagating at unit speed. A left-moving mode on a periodic domain $\\sigma \\in [0, 2\\pi)$ is exactly solved by\n$$\nx(\\sigma, t) = A \\sin\\!\\big(k(\\sigma - t)\\big),\n$$\nfor amplitude $A$ and integer wavenumber $k$. The initial conditions at $t=0$ are $x(\\sigma, 0) = A \\sin(k \\sigma)$ and $\\partial_t x(\\sigma, 0) = -A k \\cos(k \\sigma)$.\n\nImplement the following numerical method and convergence assessment:\n- Discretize the spatial domain with $N$ uniform points and grid spacing $\\Delta \\sigma = 2\\pi/N$ under periodic boundary conditions.\n- Use the Courant–Friedrichs–Lewy (CFL) number $\\mathcal{C} = \\Delta t/\\Delta \\sigma$ with $\\mathcal{C} \\le 1$ and set $\\Delta t = \\mathcal{C} \\Delta \\sigma$.\n- Evolve in time using second-order centered finite differences in space and the explicit leapfrog update for the wave equation:\n  - Construct the first time level with a second-order accurate Taylor expansion using the equation of motion $\\partial_{tt} x = \\partial_{\\sigma \\sigma} x$:\n    $$\n    x^{1} = x^{0} + \\Delta t \\, v^{0} + \\tfrac{1}{2}\\Delta t^{2} \\, \\partial_{\\sigma \\sigma} x^{0},\n    $$\n    where $x^{0}$ is the initial field and $v^{0} = \\partial_t x(\\sigma,0)$.\n  - For subsequent steps, use\n    $$\n    x^{n+1}_i = 2 x^{n}_i - x^{n-1}_i + \\mathcal{C}^{2} \\left(x^{n}_{i+1} - 2 x^{n}_i + x^{n}_{i-1}\\right),\n    $$\n    with periodic indexing.\n- Evolve to a final time $T$. If $T / \\Delta t$ is not an integer, take an integer number of steps $n_{\\mathrm{steps}} = \\mathrm{round}(T/\\Delta t)$ and compare against the analytic solution at $t_{\\mathrm{final}} = n_{\\mathrm{steps}} \\Delta t$.\n- Measure the relative $\\ell^{2}$ error at the final time,\n  $$\n  E(N) = \\frac{\\left(\\sum_{i=0}^{N-1} \\left[x^{\\mathrm{num}}(\\sigma_i,t_{\\mathrm{final}}) - x^{\\mathrm{exact}}(\\sigma_i,t_{\\mathrm{final}})\\right]^{2} \\Delta \\sigma \\right)^{1/2}}{\\left(\\sum_{i=0}^{N-1} \\left[x^{\\mathrm{exact}}(\\sigma_i,t_{\\mathrm{final}})\\right]^{2} \\Delta \\sigma \\right)^{1/2}},\n  $$\n  where $\\sigma_i = i \\, \\Delta \\sigma$.\n- For a triplet of resolutions $N, 2N, 4N$ with fixed $\\mathcal{C}$, estimate the observed order of accuracy by\n  $$\n  p_{12} = \\frac{\\log\\!\\big(E(N)/E(2N)\\big)}{\\log(2)}, \\quad\n  p_{23} = \\frac{\\log\\!\\big(E(2N)/E(4N)\\big)}{\\log(2)}, \\quad\n  p = \\tfrac{1}{2}\\left(p_{12} + p_{23}\\right).\n  $$\n\nImplement a program that performs the above procedure and returns the measured orders $p$ for the following test suite. Each test case specifies a triplet of resolutions and parameters $(\\mathcal{C}, A, k, T)$:\n- Test case $1$ (happy path): $N \\in \\{64, 128, 256\\}$, $\\mathcal{C} = 0.90$, $A = 0.10$, $k = 3$, $T = 1.00$.\n- Test case $2$ (short-wavelength edge): $N \\in \\{128, 256, 512\\}$, $\\mathcal{C} = 0.90$, $A = 0.10$, $k = 16$, $T = 1.00$.\n- Test case $3$ (near-CFL boundary): $N \\in \\{32, 64, 128\\}$, $\\mathcal{C} = 0.99$, $A = 0.10$, $k = 3$, $T = 1.00$.\n\nYour program must:\n- Compute the observed order $p$ for each test case as defined above.\n- Produce a single line of output containing the three results in a comma-separated list enclosed in square brackets, for example $[p_{1},p_{2},p_{3}]$. Each value must be a floating-point number in decimal notation.\n\nAngles must be in radians. All outputs are unitless real numbers. The final numeric outputs must be floats. The program must not require any user input or external files.", "solution": "The problem is well-posed and represents a standard exercise in numerical analysis applied to computational physics. It asks for a convergence test of a second-order finite-difference scheme for the one-dimensional linear wave equation, which serves as a model for the dynamics of a straight cosmic string in the Nambu-Goto formalism under the conformal gauge.\n\nThe governing partial differential equation (PDE) for the transverse displacement $x(\\sigma, t)$ is the linear wave equation:\n$$\n\\frac{\\partial^2 x}{\\partial t^2} - \\frac{\\partial^2 x}{\\partial \\sigma^2} = 0\n$$\nThe domain is periodic in the spatial coordinate $\\sigma$, with $\\sigma \\in [0, 2\\pi)$. The problem specifies an exact traveling-wave solution, a left-moving mode with amplitude $A$ and integer wavenumber $k$:\n$$\nx_{\\mathrm{exact}}(\\sigma, t) = A \\sin(k(\\sigma - t))\n$$\nFrom this, we derive the initial conditions at time $t=0$:\n$$\nx(\\sigma, 0) = x^0(\\sigma) = A \\sin(k \\sigma)\n$$\n$$\n\\frac{\\partial x}{\\partial t}(\\sigma, 0) = v^0(\\sigma) = -A k \\cos(k \\sigma)\n$$\n\nTo solve this system numerically, we discretize the spatio-temporal domain. The spatial domain $[0, 2\\pi)$ is discretized into $N$ uniform grid points $\\sigma_i = i \\Delta \\sigma$ for $i=0, 1, \\dots, N-1$, where the grid spacing is $\\Delta \\sigma = 2\\pi/N$. Time is discretized in steps of $\\Delta t$, such that $t^n = n \\Delta t$. The time step is related to the spatial step via the Courant–Friedrichs–Lewy (CFL) number, $\\mathcal{C} = \\Delta t / \\Delta \\sigma$. For stability of the explicit scheme, we require $\\mathcal{C} \\le 1$. The numerical solution at grid point $(\\sigma_i, t^n)$ is denoted by $x_i^n$.\n\nThe specified numerical method is the explicit second-order leapfrog scheme. The second-order partial derivatives are approximated using centered finite differences:\n$$\n\\frac{\\partial^2 x}{\\partial t^2}\\bigg|_i^n \\approx \\frac{x_i^{n+1} - 2x_i^n + x_i^{n-1}}{(\\Delta t)^2}\n$$\n$$\n\\frac{\\partial^2 x}{\\partial \\sigma^2}\\bigg|_i^n \\approx \\frac{x_{i+1}^n - 2x_i^n + x_{i-1}^n}{(\\Delta \\sigma)^2}\n$$\nSubstituting these into the wave equation and rearranging for $x_i^{n+1}$ yields the update rule for $n \\ge 1$:\n$$\nx_i^{n+1} = 2x_i^n - x_i^{n-1} + \\left(\\frac{\\Delta t}{\\Delta \\sigma}\\right)^2 (x_{i+1}^n - 2x_i^n + x_{i-1}^n)\n$$\n$$\nx_i^{n+1} = 2x_i^n - x_i^{n-1} + \\mathcal{C}^2 (x_{i+1}^n - 2x_i^n + x_{i-1}^n)\n$$\nThe indices $i+1$ and $i-1$ are handled periodically, e.g., $x_{N}^n = x_0^n$ and $x_{-1}^n = x_{N-1}^n$.\n\nThis scheme is a three-level method, requiring data from two previous time steps ($n$ and $n-1$) to compute the next ($n+1$). This poses a problem for the first time step, as we only have initial data at $t=0$ (level $n=0$). We must construct the solution at $t^1 = \\Delta t$ using a different method that is at least second-order accurate to preserve the overall accuracy of the scheme. A second-order Taylor expansion in time around $t=0$ is used:\n$$\nx(\\sigma, \\Delta t) \\approx x(\\sigma, 0) + \\Delta t \\frac{\\partial x}{\\partial t}(\\sigma, 0) + \\frac{(\\Delta t)^2}{2} \\frac{\\partial^2 x}{\\partial t^2}(\\sigma, 0)\n$$\nUsing the equation of motion itself, $\\partial_{tt}x = \\partial_{\\sigma\\sigma}x$, we can replace the time derivative with a spatial one:\n$$\nx_i^1 \\approx x_i^0 + \\Delta t \\, v_i^0 + \\frac{(\\Delta t)^2}{2} \\frac{\\partial^2 x}{\\partial \\sigma^2}\\bigg|_i^0\n$$\nDiscretizing the spatial derivative gives the formula for the first time step:\n$$\nx_i^1 = x_i^0 + \\Delta t \\, v_i^0 + \\frac{(\\Delta t)^2}{2} \\left( \\frac{x_{i+1}^0 - 2x_i^0 + x_{i-1}^0}{(\\Delta \\sigma)^2} \\right) = x_i^0 + \\Delta t \\, v_i^0 + \\frac{\\mathcal{C}^2}{2} (x_{i+1}^0 - 2x_i^0 + x_{i-1}^0)\n$$\nThe simulation proceeds by setting up $x^0$ and $v^0$, computing $x^1$ using the formula above, and then iterating the main leapfrog update rule for the required number of steps, $n_{\\mathrm{steps}} = \\mathrm{round}(T/\\Delta t)$.\n\nTo assess the accuracy, we compare the final numerical solution $x^{\\mathrm{num}}(\\sigma_i, t_{\\mathrm{final}})$ with the exact solution $x^{\\mathrm{exact}}(\\sigma_i, t_{\\mathrm{final}})$ at the final time $t_{\\mathrm{final}} = n_{\\mathrm{steps}} \\Delta t$. The error is quantified by the discrete relative $\\ell^2$ norm:\n$$\nE(N) = \\frac{\\|\\boldsymbol{x}^{\\mathrm{num}} - \\boldsymbol{x}^{\\mathrm{exact}}\\|_{\\ell^2}}{\\|\\boldsymbol{x}^{\\mathrm{exact}}\\|_{\\ell^2}} = \\frac{\\left(\\sum_{i=0}^{N-1} (x_i^{\\mathrm{num}} - x_i^{\\mathrm{exact}})^2 \\Delta \\sigma \\right)^{1/2}}{\\left(\\sum_{i=0}^{N-1} (x_i^{\\mathrm{exact}})^2 \\Delta \\sigma \\right)^{1/2}}\n$$\nFor a numerical method of order $p$, the error is expected to scale with the grid spacing as $E \\propto (\\Delta \\sigma)^p$. Since $\\Delta \\sigma \\propto 1/N$, we have $E(N) \\propto N^{-p}$. If we run simulations at two resolutions, $N_1$ and $N_2$, the ratio of their errors is:\n$$\n\\frac{E(N_1)}{E(N_2)} \\approx \\frac{C N_1^{-p}}{C N_2^{-p}} = \\left(\\frac{N_2}{N_1}\\right)^p\n$$\nSolving for $p$ gives $p \\approx \\log(E(N_1)/E(N_2))/\\log(N_2/N_1)$. For the specific case where $N_2 = 2N_1$, this simplifies to:\n$$\np \\approx \\frac{\\log(E(N)/E(2N))}{\\log(2)}\n$$\nThe problem asks to compute this quantity for two pairs of resolutions, $(N, 2N)$ and $(2N, 4N)$, and then average the results to obtain a more robust estimate of the observed order of accuracy, $p$. Since the finite-difference scheme is second-order in both space and time, we expect the observed order $p$ to be close to $2$.\n\nThe implementation will consist of a primary function that, for each test case, orchestrates three simulations at resolutions $N$, $2N$, and $4N$. It will collect the corresponding errors $E(N)$, $E(2N)$, and $E(4N)$, and then compute the final averaged order of accuracy $p$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(N, C, A, k, T):\n    \"\"\"\n    Performs a single simulation of the 1D wave equation and returns the relative l2 error.\n\n    Args:\n        N (int): Number of spatial grid points.\n        C (float): Courant-Friedrichs-Lewy (CFL) number.\n        A (float): Amplitude of the initial wave.\n        k (int): Wavenumber of the initial wave.\n        T (float): Target final time.\n\n    Returns:\n        float: The relative l2 error at the final time.\n    \"\"\"\n    # 1. Setup Grid and Parameters\n    ds = 2.0 * np.pi / N\n    dt = C * ds\n    \n    # Calculate number of steps and the final time\n    n_steps = int(round(T / dt))\n    t_final = n_steps * dt\n\n    sigma = np.linspace(0, 2 * np.pi, N, endpoint=False)\n\n    # 2. Initial Conditions\n    x0 = A * np.sin(k * sigma)\n    v0 = -A * k * np.cos(k * sigma)\n\n    # 3. First Time Step (using Taylor expansion)\n    # The term d2x/ds2 is approximated with a centered finite difference.\n    # np.roll is used for periodic boundary conditions.\n    d2x_ds2_0 = (np.roll(x0, -1) - 2 * x0 + np.roll(x0, 1)) / (ds**2)\n    x1 = x0 + dt * v0 + 0.5 * dt**2 * d2x_ds2_0\n\n    # 4. Time Evolution (Leapfrog)\n    x_prev = x0\n    x_curr = x1\n    C_squared = C**2\n    for _ in range(1, n_steps):\n        # The stencil for the second spatial derivative\n        laplacian_curr = np.roll(x_curr, -1) - 2 * x_curr + np.roll(x_curr, 1)\n        \n        # Leapfrog update rule\n        x_next = 2 * x_curr - x_prev + C_squared * laplacian_curr\n        \n        # Update for next iteration\n        x_prev = x_curr\n        x_curr = x_next\n    \n    # x_curr is now the numerical solution at t_final\n    x_num = x_curr\n\n    # 5. Error Calculation\n    x_exact = A * np.sin(k * (sigma - t_final))\n\n    # Calculate numerator of the relative l2 error\n    error_norm = np.sqrt(np.sum((x_num - x_exact)**2 * ds))\n    \n    # Calculate denominator of the relative l2 error\n    exact_norm = np.sqrt(np.sum(x_exact**2 * ds))\n\n    # Avoid division by zero if the exact solution is zero everywhere\n    if exact_norm == 0.0:\n        return 0.0 if error_norm == 0.0 else np.inf\n\n    return error_norm / exact_norm\n\ndef calculate_convergence_order(N_tuple, C, A, k, T):\n    \"\"\"\n    Calculates the observed order of accuracy for a given set of parameters.\n\n    Args:\n        N_tuple (tuple): A triplet of resolutions (N, 2N, 4N).\n        C (float): CFL number.\n        A (float): Amplitude.\n        k (int): Wavenumber.\n        T (float): Final time.\n\n    Returns:\n        float: The averaged observed order of accuracy p.\n    \"\"\"\n    N1, N2, N3 = N_tuple\n\n    # Run simulations for the three resolutions\n    E1 = run_simulation(N1, C, A, k, T)\n    E2 = run_simulation(N2, C, A, k, T)\n    E3 = run_simulation(N3, C, A, k, T)\n\n    # Prevent log(0) or division by zero errors\n    if E1 <= 0 or E2 <= 0 or E3 <= 0:\n        return np.nan\n\n    # Calculate convergence orders\n    p12 = np.log(E1 / E2) / np.log(2)\n    p23 = np.log(E2 / E3) / np.log(2)\n\n    # Average the two estimates\n    p_avg = 0.5 * (p12 + p23)\n    \n    return p_avg\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # ((Resolutions), (C, A, k, T))\n        ((64, 128, 256), (0.90, 0.10, 3, 1.00)),   # Test case 1\n        ((128, 256, 512), (0.90, 0.10, 16, 1.00)),  # Test case 2\n        ((32, 64, 128), (0.99, 0.10, 3, 1.00)),    # Test case 3\n    ]\n\n    results = []\n    for case in test_cases:\n        N_tuple, params = case\n        C, A, k, T = params\n        \n        # Main logic to calculate the result for one case goes here.\n        p = calculate_convergence_order(N_tuple, C, A, k, T)\n        results.append(p)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3486951"}, {"introduction": "Moving beyond simple test problems, this practice tackles the implementation of a full-fledged simulation for Nambu–Goto strings, an effective description of cosmic string dynamics. You will employ the elegant mover-field formalism, which recasts the complex string equations of motion into simple advection equations, greatly simplifying the numerical evolution. A key focus is the preservation of the string's physical constraints at the discrete level, a vital technique for ensuring the long-term fidelity and physical realism of the simulation [@problem_id:3487046].", "problem": "Consider a relativistic string in flat Minkowski spacetime described by the Nambu–Goto (NG) action in conformal temporal gauge, where the worldsheet coordinates are chosen such that the time coordinate equals the laboratory time. In this gauge, the spatial embedding of the string is a function $\\mathbf{x}(\\sigma,t) \\in \\mathbb{R}^3$ with $\\sigma$ a periodic coordinate along the string. The orthonormal gauge constraints are\n$$\n\\dot{\\mathbf{x}}(\\sigma,t)\\cdot \\mathbf{x}'(\\sigma,t)=0,\\quad \\|\\dot{\\mathbf{x}}(\\sigma,t)\\|^2+\\|\\mathbf{x}'(\\sigma,t)\\|^2=1,\n$$\nwhere overdots and primes denote partial derivatives with respect to $t$ and $\\sigma$, respectively. In these units, the speed of light is $c=1$ and all quantities are dimensionless.\n\nUnder these conditions, the NG equations of motion reduce to the linear wave equation for $\\mathbf{x}(\\sigma,t)$,\n$$\n\\frac{\\partial^2 \\mathbf{x}}{\\partial t^2}-\\frac{\\partial^2 \\mathbf{x}}{\\partial \\sigma^2}=0,\n$$\nsupplemented by the gauge constraints above. It is convenient to define left- and right-moving unit vector fields\n$$\n\\mathbf{a}'(\\sigma,t)=\\mathbf{x}'(\\sigma,t)-\\dot{\\mathbf{x}}(\\sigma,t),\\qquad \\mathbf{b}'(\\sigma,t)=\\mathbf{x}'(\\sigma,t)+\\dot{\\mathbf{x}}(\\sigma,t),\n$$\nwhich satisfy the advection equations\n$$\n\\partial_t \\mathbf{a}'+\\partial_\\sigma \\mathbf{a}'=0,\\qquad \\partial_t \\mathbf{b}'-\\partial_\\sigma \\mathbf{b}'=0,\n$$\nand the unit-norm conditions $\\|\\mathbf{a}'\\|=\\|\\mathbf{b}'\\|=1$. From these, one recovers\n$$\n\\mathbf{x}'=\\frac{1}{2}(\\mathbf{a}'+\\mathbf{b}'),\\qquad \\dot{\\mathbf{x}}=\\frac{1}{2}(\\mathbf{b}'-\\mathbf{a}').\n$$\n\nTask. Construct a complete, second-order accurate finite-difference time-domain scheme that advances the discrete fields $\\mathbf{a}'$ and $\\mathbf{b}'$ on a periodic one-dimensional grid in $\\sigma$ using a consistent time step, such that:\n- the updates are second-order accurate in both space and time,\n- the orthonormal gauge constraints are preserved to round-off at each grid point by design,\n- numerical dispersion of waves on the string is minimized by an appropriate choice of the Courant–Friedrichs–Lewy (CFL) number.\n\nTo accomplish this, implement the following design, each step justified from first principles:\n1. Use the exact advection form for $\\mathbf{a}'$ and $\\mathbf{b}'$, employing a second-order scheme for linear advection with wave speeds $+1$ and $-1$, respectively. Let $\\Delta \\sigma$ be the grid spacing, $\\Delta t$ the time step, and $\\lambda=\\Delta t/\\Delta \\sigma$ the Courant number. The scheme must be stable for $|\\lambda|\\le 1$ and reduce to an exact shift (hence non-dispersive) when $\\lambda=1$.\n2. Enforce the unit-norm conditions $\\|\\mathbf{a}'\\|=\\|\\mathbf{b}'\\|=1$ after each update at every grid point to machine precision, thereby preserving the orthonormal gauge constraints for $\\mathbf{x}'$ and $\\dot{\\mathbf{x}}$.\n3. Recover $\\mathbf{x}'$ and $\\dot{\\mathbf{x}}$ from $\\mathbf{a}'$ and $\\mathbf{b}'$ via $\\mathbf{x}'=(\\mathbf{a}'+\\mathbf{b}')/2$ and $\\dot{\\mathbf{x}}=(\\mathbf{b}'-\\mathbf{a}')/2$. Update $\\mathbf{x}$ with a second-order accurate time integrator from $\\dot{\\mathbf{x}}$, for example the trapezoidal rule, under periodic boundary conditions in $\\sigma$.\n4. Initialize a periodic string with a single Fourier mode on $\\mathbf{a}'$ and $\\mathbf{b}'$ that exactly satisfies the constraints at $t=0$:\n   $$\n   \\mathbf{a}'(\\sigma,0)=\\big(\\cos(m\\sigma),\\ \\sin(m\\sigma),\\ 0\\big),\\qquad\n   \\mathbf{b}'(\\sigma,0)=\\big(\\cos(m\\sigma),\\ -\\sin(m\\sigma),\\ 0\\big),\n   $$\n   with integer wavenumber $m$, domain length $L=2\\pi$, and $\\sigma\\in[0,L)$ discretized uniformly.\n5. Construct the initial $\\mathbf{x}(\\sigma,0)$ by integrating $\\mathbf{x}'(\\sigma,0)$ along $\\sigma$ with periodic boundary conditions and zero-mean position.\n\nYour program must run three independent test cases with different parameters $(N,m,\\lambda,\\text{steps})$, where $N$ is the number of grid points and $\\text{steps}$ is the number of time steps. For each test case, simulate until time $T=\\text{steps}\\times \\Delta t$ and compute the following four diagnostic metrics:\n- $E_{\\text{orth}}=\\max_i |\\dot{\\mathbf{x}}_i\\cdot \\mathbf{x}'_i|$,\n- $E_{\\text{norm}}=\\max_i \\big|\\|\\dot{\\mathbf{x}}_i\\|^2+\\|\\mathbf{x}'_i\\|^2-1\\big|$,\n- $E_{\\text{phase}}=\\big|\\Delta \\phi_{\\text{num}}-(-mT)\\big|$, where $\\Delta \\phi_{\\text{num}}$ is the measured phase shift of the $m$-th Fourier mode of the $y$-component of $\\mathbf{a}'$ between $t=0$ and $t=T$; report the phase in radians,\n- $E_{\\text{closure}}=\\left\\|\\sum_i \\mathbf{x}'_i\\,\\Delta \\sigma\\right\\|$, the periodic closure error of the discrete loop at final time.\n\nAll four diagnostics must be returned as floating-point numbers. To minimize numerical dispersion of waves on the string, ensure that one of your test cases uses $\\lambda=1$.\n\nTest suite. Use the following three test cases:\n- Case A (happy path, non-dispersive): $N=128$, $m=3$, $\\lambda=1$, $\\text{steps}=64$.\n- Case B (sub-Courant, dispersive): $N=128$, $m=5$, $\\lambda=0.8$, $\\text{steps}=40$.\n- Case C (coarse grid, exact shift): $N=16$, $m=2$, $\\lambda=1$, $\\text{steps}=16$.\n\nFor each case, set $L=2\\pi$, $\\Delta \\sigma=L/N$, $\\Delta t=\\lambda \\Delta \\sigma$, and use periodic boundary conditions. Angles must be in radians. There are no physical units beyond the dimensionless choice stated above.\n\nFinal output format. Your program should produce a single line of output containing the $12$ floating-point results in the order\n$$\n[E_{\\text{orth}}^{(A)},E_{\\text{norm}}^{(A)},E_{\\text{phase}}^{(A)},E_{\\text{closure}}^{(A)},E_{\\text{orth}}^{(B)},E_{\\text{norm}}^{(B)},E_{\\text{phase}}^{(B)},E_{\\text{closure}}^{(B)},E_{\\text{orth}}^{(C)},E_{\\text{norm}}^{(C)},E_{\\text{phase}}^{(C)},E_{\\text{closure}}^{(C)}],\n$$\nrounded to a reasonable number of significant digits and printed as a comma-separated list enclosed in square brackets, conforming to the example pattern $[r_1,r_2,\\ldots,r_{12}]$.", "solution": "The user's request is a well-posed problem in numerical physics, requiring the implementation of a finite-difference time-domain (FDTD) simulation of a relativistic Nambu-Goto string in the conformal gauge. The problem is scientifically sound, contains all necessary information, and specifies a clear set of tasks and deliverables. It is therefore deemed **valid**.\n\nThe solution involves constructing a numerical scheme that evolves the string's configuration over time, based on the provided equations and initial conditions. The core of the problem lies in the evolution of two auxiliary vector fields, the left- and right-movers $\\mathbf{a}'(\\sigma,t)$ and $\\mathbf{b}'(\\sigma,t)$, which simplify the underlying physics into a pair of advection equations.\n\nHere is a step-by-step design of the required algorithm, following the principles outlined in the problem statement.\n\n### 1. Second-Order Advection Scheme\n\nThe evolution of the string is governed by the advection of the right-moving field $\\mathbf{a}'$ and the left-moving field $\\mathbf{b}'$. Their governing equations are:\n$$\n\\frac{\\partial \\mathbf{a}'}{\\partial t} + \\frac{\\partial \\mathbf{a}'}{\\partial \\sigma} = 0 \\quad (\\text{wave speed } c=+1)\n$$\n$$\n\\frac{\\partial \\mathbf{b}'}{\\partial t} - \\frac{\\partial \\mathbf{b}'}{\\partial \\sigma} = 0 \\quad (\\text{wave speed } c=-1)\n$$\nThese are linear advection equations of the form $\\partial_t \\mathbf{u} + c \\partial_\\sigma \\mathbf{u} = 0$. We require a numerical scheme that is second-order accurate in both time ($\\Delta t$) and space ($\\Delta \\sigma$) and becomes exact when the Courant number $\\lambda = \\Delta t/\\Delta \\sigma = 1$. The Lax-Wendroff scheme fulfills these criteria.\n\nTo derive it, we perform a Taylor expansion of $\\mathbf{u}(\\sigma, t+\\Delta t)$ to second order:\n$$\n\\mathbf{u}(\\sigma, t+\\Delta t) \\approx \\mathbf{u}(\\sigma, t) + \\Delta t \\frac{\\partial \\mathbf{u}}{\\partial t} + \\frac{(\\Delta t)^2}{2} \\frac{\\partial^2 \\mathbf{u}}{\\partial t^2}\n$$\nUsing the advection equation, we can express the time derivatives in terms of spatial derivatives:\n$$\n\\frac{\\partial \\mathbf{u}}{\\partial t} = -c \\frac{\\partial \\mathbf{u}}{\\partial \\sigma}\n$$\n$$\n\\frac{\\partial^2 \\mathbf{u}}{\\partial t^2} = \\frac{\\partial}{\\partial t}\\left(-c \\frac{\\partial \\mathbf{u}}{\\partial \\sigma}\\right) = -c \\frac{\\partial}{\\partial \\sigma}\\left(\\frac{\\partial \\mathbf{u}}{\\partial t}\\right) = -c \\frac{\\partial}{\\partial \\sigma}\\left(-c \\frac{\\partial \\mathbf{u}}{\\partial \\sigma}\\right) = c^2 \\frac{\\partial^2 \\mathbf{u}}{\\partial \\sigma^2}\n$$\nSubstituting these back into the Taylor expansion gives:\n$$\n\\mathbf{u}(\\sigma, t+\\Delta t) \\approx \\mathbf{u}(\\sigma, t) - c\\Delta t \\frac{\\partial \\mathbf{u}}{\\partial \\sigma} + \\frac{c^2(\\Delta t)^2}{2} \\frac{\\partial^2 \\mathbf{u}}{\\partial \\sigma^2}\n$$\nWe discretize the spatial derivatives using second-order central differences. For a grid function $\\mathbf{u}_i^n \\approx \\mathbf{u}(i\\Delta\\sigma, n\\Delta t)$:\n$$\n\\frac{\\partial \\mathbf{u}}{\\partial \\sigma} \\approx \\frac{\\mathbf{u}_{i+1}^n - \\mathbf{u}_{i-1}^n}{2\\Delta\\sigma}\n$$\n$$\n\\frac{\\partial^2 \\mathbf{u}}{\\partial \\sigma^2} \\approx \\frac{\\mathbf{u}_{i+1}^n - 2\\mathbf{u}_i^n + \\mathbf{u}_{i-1}^n}{(\\Delta \\sigma)^2}\n$$\nLetting $\\nu = c\\lambda = c\\Delta t/\\Delta\\sigma$, the update rule becomes:\n$$\n\\mathbf{u}_i^{n+1} = \\mathbf{u}_i^n - \\frac{\\nu}{2}(\\mathbf{u}_{i+1}^n - \\mathbf{u}_{i-1}^n) + \\frac{\\nu^2}{2}(\\mathbf{u}_{i+1}^n - 2\\mathbf{u}_i^n + \\mathbf{u}_{i-1}^n)\n$$\nFor periodic boundary conditions, the indices $i\\pm1$ are handled using modular arithmetic, which is efficiently implemented via `numpy.roll`.\n- For $\\mathbf{a}'$, $c=+1$, so we use $\\nu = \\lambda$.\n- For $\\mathbf{b}'$, $c=-1$, so we use $\\nu = -\\lambda$.\n\nWhen $\\lambda=1$, for $\\mathbf{a}'$ ($\\nu=1$), the scheme reduces to $\\mathbf{u}_i^{n+1} = \\mathbf{u}_{i-1}^n$, an exact shift to the right. For $\\mathbf{b}'$ ($\\nu=-1$), it reduces to $\\mathbf{u}_i^{n+1} = \\mathbf{u}_{i+1}^n$, an exact shift to the left. This non-dispersive property at the CFL limit is a key requirement.\n\n### 2. Preservation of Gauge Constraints\n\nThe orthonormal gauge constraints are:\n$$\n\\dot{\\mathbf{x}}\\cdot \\mathbf{x}'=0, \\qquad \\|\\dot{\\mathbf{x}}\\|^2+\\|\\mathbf{x}'\\|^2=1\n$$\nIn terms of the mover fields, these are equivalent to ensuring that $\\|\\mathbf{a}'\\|=1$ and $\\|\\mathbf{b}'\\|=1$.\n$$\n\\dot{\\mathbf{x}}\\cdot \\mathbf{x}' = \\frac{1}{4}(\\mathbf{b}'-\\mathbf{a}')\\cdot(\\mathbf{a}'+\\mathbf{b}') = \\frac{1}{4}(\\|\\mathbf{b}'\\|^2 - \\|\\mathbf{a}'\\|^2)\n$$\n$$\n\\|\\dot{\\mathbf{x}}\\|^2+\\|\\mathbf{x}'\\|^2 = \\frac{1}{4}\\|\\mathbf{b}'-\\mathbf{a}'\\|^2 + \\frac{1}{4}\\|\\mathbf{a}'+\\mathbf{b}'\\|^2 = \\frac{1}{2}(\\|\\mathbf{a}'\\|^2 + \\|\\mathbf{b}'\\|^2)\n$$\nThe Lax-Wendroff scheme does not intrinsically preserve the norm of the vectors. Therefore, after each time step update of $\\mathbf{a}'$ and $\\mathbf{b}'$, we must explicitly re-normalize them at every grid point $i$:\n$$\n(\\mathbf{a}'_i)_{\\text{renormalized}} = \\frac{\\mathbf{a}'_i}{\\|\\mathbf{a}'_i\\|}, \\qquad (\\mathbf{b}'_i)_{\\text{renormalized}} = \\frac{\\mathbf{b}'_i}{\\|\\mathbf{b}'_i\\|}\n$$\nThis procedure enforces the unit-norm conditions to machine precision, thereby ensuring the gauge constraints are satisfied by design.\n\n### 3. Recovering and Integrating the String Position $\\mathbf{x}$\n\nAt each time step $n+1$, after evolving and re-normalizing $\\mathbf{a}'^{n+1}$ and $\\mathbf{b}'^{n+1}$, we recover the string's tangent and velocity vectors:\n$$\n\\mathbf{x}'^{n+1} = \\frac{1}{2}(\\mathbf{a}'^{n+1} + \\mathbf{b}'^{n+1}), \\qquad \\dot{\\mathbf{x}}^{n+1} = \\frac{1}{2}(\\mathbf{b}'^{n+1} - \\mathbf{a}'^{n+1})\n$$\nTo update the string's position $\\mathbf{x}$, we must integrate $\\dot{\\mathbf{x}}$ in time. The problem suggests the trapezoidal rule, a second-order accurate method:\n$$\n\\mathbf{x}^{n+1} = \\mathbf{x}^n + \\frac{\\Delta t}{2}(\\dot{\\mathbf{x}}^n + \\dot{\\mathbf{x}}^{n+1})\n$$\nThis requires storing the velocity vector from the previous time step, $\\dot{\\mathbf{x}}^n$.\n\n### 4. Initial Conditions for Mover Fields\n\nThe initial conditions are specified on a discrete grid $\\sigma_i = i\\Delta\\sigma$ for $i \\in \\{0, \\dots, N-1\\}$ with $\\Delta\\sigma = L/N = 2\\pi/N$:\n$$\n\\mathbf{a}'_i(t=0) = (\\cos(m\\sigma_i), \\sin(m\\sigma_i), 0)\n$$\n$$\n\\mathbf{b}'_i(t=0) = (\\cos(m\\sigma_i), -\\sin(m\\sigma_i), 0)\n$$\nwhere $m$ is an integer wavenumber. These initial fields already satisfy the unit-norm condition, as $\\|\\mathbf{a}'_i(0)\\|=\\|\\mathbf{b}'_i(0)\\|=1$ for all $i$.\n\n### 5. Initial String Position $\\mathbf{x}(\\sigma,0)$\n\nTo find the initial position $\\mathbf{x}(\\sigma,0)$, we must integrate the initial tangent vector $\\mathbf{x}'(\\sigma,0)$ under the constraints of periodicity and zero mean.\nFirst, we find $\\mathbf{x}'(\\sigma,0)$:\n$$\n\\mathbf{x}'(\\sigma,0) = \\frac{1}{2}(\\mathbf{a}'(\\sigma,0) + \\mathbf{b}'(\\sigma,0)) = (\\cos(m\\sigma), 0, 0)\n$$\nIntegrating $\\mathbf{x}'(\\sigma,0)$ with respect to $\\sigma$ to obtain $\\mathbf{x}(\\sigma,0)$ is best performed in Fourier space to naturally handle periodic boundary conditions and the zero-mean constraint. The procedure is as follows:\n1.  Compute the Discrete Fourier Transform (DFT) of the discrete field $\\mathbf{x}'_i(0)$.\n2.  In Fourier space, integration corresponds to division by $ik_{\\text{eff}}$, where $k_{\\text{eff}}$ is the effective wavenumber for each mode. The $k=0$ (DC) mode, which represents the mean, is set to zero to satisfy the zero-mean constraint.\n3.  Compute the Inverse DFT of the result to obtain $\\mathbf{x}_i(0)$ in real space.\nThis yields the analytical solution $\\mathbf{x}(\\sigma_i,0) = (\\frac{1}{m}\\sin(m\\sigma_i), 0, 0)$ up to discretization error, satisfying all requirements.\n\n### Diagnostic Metrics\n\nThe simulation is run for a specified number of steps, and four diagnostic quantities are computed:\n- $E_{\\text{orth}}$ and $E_{\\text{norm}}$ measure how well the gauge constraints are preserved. Due to the explicit re-normalization step, these errors should be close to machine epsilon.\n- $E_{\\text{closure}}$ measures the failure of the string loop to close, which should be minimal for a consistent numerical integration. It is calculated as the norm of the sum of tangent vectors over the loop: $\\|\\sum_i \\mathbf{x}'_i \\Delta\\sigma\\|$.\n- $E_{\\text{phase}}$ measures the numerical dispersion. The analytical phase shift for the $m$-th mode of $\\mathbf{a}'_y$ over a time $T$ is $-mT$. We measure the numerical phase shift $\\Delta\\phi_{\\text{num}}$ by accumulating the phase change of the $m$-th Fourier mode at each time step. This avoids issues with phase wrapping. The error is then $|\\Delta\\phi_{\\text{num}} - (-mT)|$. For the non-dispersive cases where $\\lambda=1$, this error should be near zero.\n\nThis comprehensive design provides a robust and accurate method to solve the posed problem.", "answer": "```python\nimport numpy as np\nfrom scipy import fft\n\ndef run_simulation(N, m, lambda_cfl, steps):\n    \"\"\"\n    Runs a single simulation of a relativistic string.\n\n    Args:\n        N (int): Number of grid points.\n        m (int): Wavenumber for the initial condition.\n        lambda_cfl (float): Courant number (dt/ds).\n        steps (int): Number of time steps to simulate.\n\n    Returns:\n        tuple: A tuple containing the four diagnostic metrics:\n               (E_orth, E_norm, E_phase, E_closure).\n    \"\"\"\n    # 1. Setup grid and parameters\n    L = 2.0 * np.pi\n    delta_sigma = L / N\n    delta_t = lambda_cfl * delta_sigma\n    T = steps * delta_t\n    sigma_grid = np.linspace(0, L, N, endpoint=False)\n\n    # 2. Initial conditions\n    # Initialize a' and b' (mover fields)\n    a_prime = np.zeros((N, 3))\n    b_prime = np.zeros((N, 3))\n    a_prime[:, 0] = np.cos(m * sigma_grid)\n    a_prime[:, 1] = np.sin(m * sigma_grid)\n    b_prime[:, 0] = np.cos(m * sigma_grid)\n    b_prime[:, 1] = -np.sin(m * sigma_grid)\n\n    # Initialize x' and x_dot from a' and b'\n    x_prime = 0.5 * (a_prime + b_prime)\n    x_dot = 0.5 * (b_prime - a_prime)\n\n    # Initialize x by integrating x' in Fourier space\n    # This correctly handles periodic BCs and zero-mean constraint\n    k_freq = fft.fftfreq(N, d=delta_sigma)\n    k_wavenum = 2 * np.pi * k_freq\n    \n    x_prime_fft = fft.fft(x_prime, axis=0)\n    x_fft = np.zeros_like(x_prime_fft, dtype=np.complex128)\n    \n    # Integrate by dividing by i*k, handling k=0 separately\n    nonzero_k_mask = k_wavenum != 0\n    # Add new axis to broadcast k_wavenum over the 3 vector components\n    k_broadcast = k_wavenum[nonzero_k_mask, np.newaxis]\n    x_fft[nonzero_k_mask] = x_prime_fft[nonzero_k_mask] / (1j * k_broadcast)\n    \n    x = fft.ifft(x_fft, axis=0).real\n\n    # 3. Phase calculation setup\n    total_phase_shift = 0.0\n    # Get the m-th Fourier component of the y-component of a_prime\n    ay_fft_m_old = fft.fft(a_prime[:, 1])[m]\n\n    # 4. Time evolution loop\n    for _ in range(steps):\n        # Store previous state for trapezoidal rule\n        x_dot_old = x_dot\n\n        # Evolve a' (c=+1) using Lax-Wendroff\n        nu_a = lambda_cfl\n        a_prime_rolled_p1 = np.roll(a_prime, -1, axis=0) # i+1\n        a_prime_rolled_m1 = np.roll(a_prime, 1, axis=0)  # i-1\n        a_prime_new = (a_prime \n                       - 0.5 * nu_a * (a_prime_rolled_p1 - a_prime_rolled_m1)\n                       + 0.5 * nu_a**2 * (a_prime_rolled_p1 - 2 * a_prime + a_prime_rolled_m1))\n\n        # Evolve b' (c=-1) using Lax-Wendroff\n        nu_b = -lambda_cfl\n        b_prime_rolled_p1 = np.roll(b_prime, -1, axis=0) # i+1\n        b_prime_rolled_m1 = np.roll(b_prime, 1, axis=0)  # i-1\n        b_prime_new = (b_prime\n                       - 0.5 * nu_b * (b_prime_rolled_p1 - b_prime_rolled_m1)\n                       + 0.5 * nu_b**2 * (b_prime_rolled_p1 - 2 * b_prime + b_prime_rolled_m1))\n        \n        # Enforce unit-norm constraint by re-normalizing\n        norm_a = np.linalg.norm(a_prime_new, axis=1, keepdims=True)\n        a_prime = a_prime_new / norm_a\n        norm_b = np.linalg.norm(b_prime_new, axis=1, keepdims=True)\n        b_prime = b_prime_new / norm_b\n\n        # Update physical fields x' and x_dot\n        x_prime = 0.5 * (a_prime + b_prime)\n        x_dot = 0.5 * (b_prime - a_prime)\n\n        # Update position x using trapezoidal rule\n        x = x + 0.5 * delta_t * (x_dot_old + x_dot)\n        \n        # Accumulate phase shift for diagnostic\n        ay_fft_m_new = fft.fft(a_prime[:, 1])[m]\n        # Calculate phase increment from one step to the next\n        phase_increment = np.angle(ay_fft_m_new * np.conj(ay_fft_m_old))\n        total_phase_shift += phase_increment\n        ay_fft_m_old = ay_fft_m_new\n\n    # 5. Compute final diagnostics\n    # Orthogonality error\n    E_orth = np.max(np.abs(np.sum(x_dot * x_prime, axis=1)))\n\n    # Normalization error\n    norm_sq_sum = np.sum(x_dot**2, axis=1) + np.sum(x_prime**2, axis=1)\n    E_norm = np.max(np.abs(norm_sq_sum - 1.0))\n\n    # Phase error\n    analytical_phase_shift = -m * T\n    E_phase = np.abs(total_phase_shift - analytical_phase_shift)\n\n    # Closure error\n    closure_vector = np.sum(x_prime, axis=0) * delta_sigma\n    E_closure = np.linalg.norm(closure_vector)\n\n    return E_orth, E_norm, E_phase, E_closure\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (happy path, non-dispersive)\n        (128, 3, 1.0, 64),\n        # Case B (sub-Courant, dispersive)\n        (128, 5, 0.8, 40),\n        # Case C (coarse grid, exact shift)\n        (16, 2, 1.0, 16),\n    ]\n\n    results = []\n    for case_params in test_cases:\n        N, m, lambda_cfl, steps = case_params\n        case_results = run_simulation(N, m, lambda_cfl, steps)\n        results.extend(case_results)\n\n    # Final print statement in the exact required format.\n    # The format string ensures a reasonable number of digits are displayed.\n    print(f\"[{','.join(f'{r:.8e}' for r in results)}]\")\n\nsolve()\n```", "id": "3487046"}]}