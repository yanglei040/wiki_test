{"hands_on_practices": [{"introduction": "Before applying a numerical method to complex physical problems, it is crucial to verify its accuracy on simpler, controlled test cases. This practice involves implementing the line-of-sight integral for Cosmic Microwave Background (CMB) anisotropies and validating the numerical quadrature routine against known analytic solutions. By using idealized source functions that permit exact or asymptotic results, you can build confidence in your integrator and understand its performance in different regimes, such as for highly oscillatory or sharply peaked integrands [@problem_id:3478222].", "problem": "Consider the Cosmic Microwave Background (CMB) line-of-sight representation for temperature and polarization multipoles. In the line-of-sight method, the multipole transfer function $\\,\\Theta_\\ell(k)\\,$ for a given wavenumber $\\,k\\,$ and multipole index $\\,\\ell\\,$ is expressed as an integral over conformal time $\\,\\eta\\,$,\n$$\n\\Theta_\\ell(k) \\;=\\; \\int_{0}^{\\eta_0} S(k,\\eta)\\, j_\\ell\\!\\left(k\\,(\\eta_0-\\eta)\\right)\\, d\\eta,\n$$\nwhere $\\,\\eta_0\\,$ is the present-day conformal time, $\\,S(k,\\eta)\\,$ is an analytic source term, and $\\,j_\\ell(x)\\,$ is the spherical Bessel function of the first kind of order $\\,\\ell\\,$.\n\nStarting from the above widely used and well-tested line-of-sight integral formulation in numerical cosmology and standard properties of distributions and special functions, implement a benchmark to assess oscillatory integration accuracy. The benchmark should be built on analytic sources $\\,S(k,\\eta)\\,$ for which the integral either has a closed-form expression or reduces to known transforms of spherical Bessel functions. The goal is to validate numerical convergence against known results and quantify accuracy for progressively more oscillatory integrals and sharply peaked sources.\n\nYou must implement the following analytic sources and associated expected values:\n\n1. A uniform source $\\,S_U(k,\\eta) = C\\,$ with constant amplitude $\\,C\\,$ over $\\,\\eta\\in[0,\\eta_0]\\,$. For $\\,\\ell=0\\,$, the integral reduces, after the change of variables $\\,x=k(\\eta_0-\\eta)\\,$, to a known integral of $\\,j_0(x)=\\sin(x)/x\\,$:\n$$\n\\Theta_0^{U}(k) \\;=\\; \\frac{C}{k}\\,\\int_{0}^{k\\eta_0} j_0(x)\\,dx \\;=\\; \\frac{C}{k}\\,\\mathrm{Si}(k\\eta_0),\n$$\nwhere $\\,\\mathrm{Si}(x) = \\int_0^x \\frac{\\sin t}{t}\\,dt\\,$ is the sine integral. Use this closed form to compute the expected value.\n\n2. A narrow Gaussian source that approximates a Dirac delta distribution,\n$$\nS_G(k,\\eta) \\;=\\; \\frac{A}{\\sqrt{2\\pi}\\,\\sigma}\\,\\exp\\!\\left(-\\frac{(\\eta-\\eta_s)^2}{2\\sigma^2}\\right),\n$$\nwith amplitude $\\,A\\,$, center $\\,\\eta_s\\,$, and width $\\,\\sigma\\,$. For $\\,\\sigma\\to 0\\,$ and $\\,\\eta_s\\in(0,\\eta_0)\\,$, the integral converges to\n$$\n\\Theta_\\ell^{G}(k) \\;\\to\\; A\\, j_\\ell\\!\\left(k(\\eta_0-\\eta_s)\\right),\n$$\nby the standard property of mollifiers approximating the Dirac delta.\n\n3. A derivative-of-Gaussian source that approximates the derivative of the Dirac delta distribution,\n$$\nS_{G'}(k,\\eta) \\;=\\; B\\,\\frac{d}{d\\eta}\\!\\left[\\frac{1}{\\sqrt{2\\pi}\\,\\sigma}\\,\\exp\\!\\left(-\\frac{(\\eta-\\eta_s)^2}{2\\sigma^2}\\right)\\right]\n\\;=\\; -\\,B\\,\\frac{\\eta-\\eta_s}{\\sqrt{2\\pi}\\,\\sigma^3}\\,\\exp\\!\\left(-\\frac{(\\eta-\\eta_s)^2}{2\\sigma^2}\\right),\n$$\nwith amplitude $\\,B\\,$. Using the distribution identity $\\,\\int \\delta'(\\eta-\\eta_s) f(\\eta)\\,d\\eta = -f'(\\eta_s)\\,$ and the chain rule $\\,\\frac{d}{d\\eta} j_\\ell(k(\\eta_0-\\eta))=-k\\,j_\\ell'(k(\\eta_0-\\eta))\\,$, for $\\,\\sigma\\to 0\\,$ the integral converges to\n$$\n\\Theta_\\ell^{G'}(k) \\;\\to\\; B\\,k\\, j_\\ell'\\!\\left(k(\\eta_0-\\eta_s)\\right),\n$$\nwhere $\\,j_\\ell'(x)\\,$ denotes the derivative of the spherical Bessel function with respect to its argument.\n\nImplement a program that:\n- Numerically evaluates $\\,\\Theta_\\ell(k)\\,$ for the above sources using direct quadrature of the line-of-sight integral.\n- Computes the corresponding analytic or asymptotic expected values as specified.\n- Reports the relative error defined by\n$$\n\\epsilon_{\\mathrm{rel}} \\;=\\; \\frac{\\left|\\Theta_\\ell^{\\mathrm{num}}(k) - \\Theta_\\ell^{\\mathrm{exp}}(k)\\right|}{\\max\\!\\left(\\left|\\Theta_\\ell^{\\mathrm{exp}}(k)\\right|,\\,10^{-12}\\right)}.\n$$\n\nAll variables are dimensionless; no physical units are required. Angles, if any, should be treated in radians.\n\nYour test suite must include the following parameter sets to exercise different regimes:\n- Uniform source, happy path: $\\,(\\ell=0,\\,k=15.0,\\,\\eta_0=2.0,\\,C=1.0)\\,$.\n- Uniform source, strongly oscillatory: $\\,(\\ell=0,\\,k=80.0,\\,\\eta_0=1.5,\\,C=0.7)\\,$.\n- Gaussian source, approach to Dirac delta (moderately narrow): $\\,(\\ell=2,\\,k=25.0,\\,\\eta_0=1.0,\\,A=1.0,\\,\\eta_s=0.5,\\,\\sigma=0.2)\\,$.\n- Gaussian source, approach to Dirac delta (narrower): $\\,(\\ell=2,\\,k=25.0,\\,\\eta_0=1.0,\\,A=1.0,\\,\\eta_s=0.5,\\,\\sigma=0.1)\\,$.\n- Gaussian source, approach to Dirac delta (very narrow): $\\,(\\ell=2,\\,k=25.0,\\,\\eta_0=1.0,\\,A=1.0,\\,\\eta_s=0.5,\\,\\sigma=0.05)\\,$.\n- Derivative-of-Gaussian source, approach to $\\,\\delta'\\,$ (moderately narrow): $\\,(\\ell=3,\\,k=20.0,\\,\\eta_0=1.2,\\,B=0.8,\\,\\eta_s=0.6,\\,\\sigma=0.2)\\,$.\n- Derivative-of-Gaussian source, approach to $\\,\\delta'\\,$ (narrower): $\\,(\\ell=3,\\,k=20.0,\\,\\eta_0=1.2,\\,B=0.8,\\,\\eta_s=0.6,\\,\\sigma=0.1)\\,$.\n- Gaussian source near a boundary to test truncation effects: $\\,(\\ell=0,\\,k=30.0,\\,\\eta_0=1.0,\\,A=1.0,\\,\\eta_s=0.1,\\,\\sigma=0.05)\\,$.\n\nYour program should produce a single line of output containing the eight relative errors, in the order listed above, as a comma-separated list enclosed in square brackets (e.g., \"[e1,e2,e3,e4,e5,e6,e7,e8]\").", "solution": "The user wants to validate and solve a problem from numerical cosmology.\n\n### Step 1: Extract Givens\n\nThe problem provides the following definitions, formulas, and data:\n\n1.  **Line-of-Sight Integral:**\n    $$\n    \\Theta_\\ell(k) \\;=\\; \\int_{0}^{\\eta_0} S(k,\\eta)\\, j_\\ell\\!\\left(k\\,(\\eta_0-\\eta)\\right)\\, d\\eta\n    $$\n2.  **Uniform Source $\\,S_U\\,$ and Expected Value $\\,\\Theta_0^U\\,$:**\n    -   Source: $\\,S_U(k,\\eta) = C\\,$ for $\\,\\eta\\in[0,\\eta_0]\\,$.\n    -   Expected Value for $\\,\\ell=0\\,$: $\\,\\Theta_0^{U}(k) = \\frac{C}{k}\\,\\mathrm{Si}(k\\eta_0)\\,$, where $\\,\\mathrm{Si}(x) = \\int_0^x \\frac{\\sin t}{t}\\,dt\\,$.\n\n3.  **Gaussian Source $\\,S_G\\,$ and Asymptotic Value $\\,\\Theta_\\ell^G\\,$:**\n    -   Source: $\\,S_G(k,\\eta) = \\frac{A}{\\sqrt{2\\pi}\\,\\sigma}\\,\\exp\\!\\left(-\\frac{(\\eta-\\eta_s)^2}{2\\sigma^2}\\right)\\,$.\n    -   Asymptotic Value for $\\,\\sigma\\to 0\\,$: $\\,\\Theta_\\ell^{G}(k) \\to A\\, j_\\ell\\!\\left(k(\\eta_0-\\eta_s)\\right)\\,$.\n\n4.  **Derivative-of-Gaussian Source $\\,S_{G'}\\,$ and Asymptotic Value $\\,\\Theta_\\ell^{G'}\\,$:**\n    -   Source: $\\,S_{G'}(k,\\eta) = -\\,B\\,\\frac{\\eta-\\eta_s}{\\sqrt{2\\pi}\\,\\sigma^3}\\,\\exp\\!\\left(-\\frac{(\\eta-\\eta_s)^2}{2\\sigma^2}\\right)\\,$.\n    -   Asymptotic Value for $\\,\\sigma\\to 0\\,$: $\\,\\Theta_\\ell^{G'}(k) \\to B\\,k\\, j_\\ell'\\!\\left(k(\\eta_0-\\eta_s)\\right)\\,$.\n\n5.  **Relative Error Definition:**\n    $$\n    \\epsilon_{\\mathrm{rel}} \\;=\\; \\frac{\\left|\\Theta_\\ell^{\\mathrm{num}}(k) - \\Theta_\\ell^{\\mathrm{exp}}(k)\\right|}{\\max\\!\\left(\\left|\\Theta_\\ell^{\\mathrm{exp}}(k)\\right|,\\,10^{-12}\\right)}\n    $$\n\n6.  **Test Cases (8 total):**\n    -   Case 1 (Uniform): $\\,(\\ell=0,\\,k=15.0,\\,\\eta_0=2.0,\\,C=1.0)\\,$\n    -   Case 2 (Uniform): $\\,(\\ell=0,\\,k=80.0,\\,\\eta_0=1.5,\\,C=0.7)\\,$\n    -   Case 3 (Gaussian): $\\,(\\ell=2,\\,k=25.0,\\,\\eta_0=1.0,\\,A=1.0,\\,\\eta_s=0.5,\\,\\sigma=0.2)\\,$\n    -   Case 4 (Gaussian): $\\,(\\ell=2,\\,k=25.0,\\,\\eta_0=1.0,\\,A=1.0,\\,\\eta_s=0.5,\\,\\sigma=0.1)\\,$\n    -   Case 5 (Gaussian): $\\,(\\ell=2,\\,k=25.0,\\,\\eta_0=1.0,\\,A=1.0,\\,\\eta_s=0.5,\\,\\sigma=0.05)\\,$\n    -   Case 6 (Derivative-of-Gaussian): $\\,(\\ell=3,\\,k=20.0,\\,\\eta_0=1.2,\\,B=0.8,\\,\\eta_s=0.6,\\,\\sigma=0.2)\\,$\n    -   Case 7 (Derivative-of-Gaussian): $\\,(\\ell=3,\\,k=20.0,\\,\\eta_0=1.2,\\,B=0.8,\\,\\eta_s=0.6,\\,\\sigma=0.1)\\,$\n    -   Case 8 (Gaussian): $\\,(\\ell=0,\\,k=30.0,\\,\\eta_0=1.0,\\,A=1.0,\\,\\eta_s=0.1,\\,\\sigma=0.05)\\,$\n\n### Step 2: Validate Using Extracted Givens\n\nThe problem is subjected to a rigorous validation check:\n\n-   **Scientifically Grounded:** The problem is based on the line-of-sight integration method, a cornerstone of modern numerical cosmology for computing CMB anisotropies. The integral form of $\\,\\Theta_\\ell(k)\\,$ is standard. The use of analytic source functions to create benchmarks for numerical codes is a common and valid practice in computational science. The specific analytic and asymptotic limits given are correct:\n    -   The integral of $\\,j_0(x)\\,$ is indeed the sine integral $\\,\\mathrm{Si}(x)\\,$.\n    -   A narrow Gaussian function serves as a standard approximation (a mollifier) for the Dirac delta distribution, $\\,\\delta(\\eta-\\eta_s)\\,$, and the limit $\\,\\sigma \\to 0\\,$ correctly recovers the sifting property of the delta function.\n    -   The derivative of a narrow Gaussian approximates the derivative of the Dirac delta, $\\,\\delta'(\\eta-\\eta_s)\\,$, and the stated result correctly uses the integration property $\\,\\int f(x)\\delta'(x-x_s)dx = -f'(x_s)\\,$.\n    The mathematical and physical underpinnings are sound.\n\n-   **Well-Posed:** The problem is well-posed. It requests a comparison between a numerically computed value and a well-defined analytical or asymptotic expression. All parameters required for both computations are explicitly provided for each of the eight test cases. The definition of relative error is unambiguous and includes a safeguard against division by zero or very small numbers, which is a sign of a well-structured numerical problem.\n\n-   **Objective:** The problem statement is entirely objective, expressed in the precise language of mathematics and physics. It is free of ambiguity, subjective claims, or opinions.\n\nBased on this analysis, the problem does not exhibit any of the flaws listed in the validation criteria. It is scientifically sound, formally specified, complete, and objective.\n\n### Step 3: Verdict and Action\n\nThe problem is **valid**. A solution will be provided.\n\nThe objective is to compute the line-of-sight integral $\\,\\Theta_\\ell(k)\\,$ numerically for several test cases and compare the result with a corresponding analytic or asymptotic formula by calculating the relative error. This serves as a benchmark for the accuracy of numerical integration techniques for the types of oscillatory and sharply-peaked functions encountered in CMB physics.\n\nThe core of the solution is a numerical quadrature algorithm. A suitable choice from standard scientific libraries is the `scipy.integrate.quad` function, which implements an adaptive quadrature scheme capable of handling a wide variety of integrands, including the oscillatory ones relevant here. For each test case, the solution involves the following steps: defining the integrand, performing the numerical integration, calculating the expected value, and computing the relative error.\n\nFirst, we define Python functions for the three source terms $\\,S_U(k,\\eta)\\,$, $\\,S_G(k,\\eta)\\,$, and $\\,S_{G'}(k,\\eta)\\,$, directly transcribing their mathematical definitions.\n\nFor the numerical evaluation, $\\,\\Theta_\\ell^{\\mathrm{num}}(k)\\,$, we construct the integrand function, which is the product of the appropriate source function $\\,S(k,\\eta)\\,$ and the spherical Bessel function $\\,j_\\ell(k(\\eta_0-\\eta))\\,$. The `scipy.special.spherical_jn` function provides the values of $\\,j_\\ell(x)\\,$. We then pass this integrand to `scipy.integrate.quad` with the integration limits $\\,[0, \\eta_0]\\,$. For the strongly oscillatory case (Case 2, with $\\,k\\eta_0=120\\,$), it is prudent to increase the `limit` parameter of `quad` to allow for a larger number of subintervals to resolve the oscillations accurately.\n\nNext, we implement the functions to calculate the expected values, $\\,\\Theta_\\ell^{\\mathrm{exp}}(k)\\,$.\n1.  For the uniform source with $\\,\\ell=0\\,$, the expected value $\\,\\Theta_0^U(k)\\,$ is computed using the sine integral function, provided by `scipy.special.sici`, which returns a tuple containing the sine and cosine integrals; we use the first element.\n2.  For the Gaussian source, the asymptotic value $\\,\\Theta_\\ell^G(k)\\,$ is calculated using `scipy.special.spherical_jn` evaluated at the argument $\\,k(\\eta_0-\\eta_s)\\,$. This approximation's accuracy improves as the width $\\,\\sigma\\,$ decreases, as demonstrated by test cases 3, 4, and 5. Test case 8 explores the impact of truncating the Gaussian source by placing its peak near an integration boundary.\n3.  For the derivative-of-Gaussian source, the asymptotic value $\\,\\Theta_\\ell^{G'}(k)\\,$ requires the derivative of the spherical Bessel function, $\\,j_\\ell'(x)\\,$. This is conveniently obtained by calling `scipy.special.spherical_jn` with the optional argument `derivative=True`.\n\nFinally, for each test case, the numerical result $\\,\\Theta_\\ell^{\\mathrm{num}}(k)\\,$ and the expected value $\\,\\Theta_\\ell^{\\mathrm{exp}}(k)\\,$ are used to compute the relative error $\\,\\epsilon_{\\mathrm{rel}}\\,$ according to the specified formula. The denominator's `max` function prevents numerical instability if $\\,\\Theta_\\ell^{\\mathrm{exp}}(k)\\,$ is close to zero. The calculated errors for all eight cases are collected and formatted into the required output string.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\nfrom scipy.special import sici, spherical_jn\n\ndef solve():\n    \"\"\"\n    Numerically evaluates the CMB line-of-sight integral for various analytic\n    source functions and computes the relative error against known\n    analytic or asymptotic solutions.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # 1. Uniform source, happy path\n        {'type': 'U', 'params': {'ell': 0, 'k': 15.0, 'eta0': 2.0, 'C': 1.0}},\n        # 2. Uniform source, strongly oscillatory\n        {'type': 'U', 'params': {'ell': 0, 'k': 80.0, 'eta0': 1.5, 'C': 0.7}},\n        # 3. Gaussian source, moderately narrow\n        {'type': 'G', 'params': {'ell': 2, 'k': 25.0, 'eta0': 1.0, 'A': 1.0, 'eta_s': 0.5, 'sigma': 0.2}},\n        # 4. Gaussian source, narrower\n        {'type': 'G', 'params': {'ell': 2, 'k': 25.0, 'eta0': 1.0, 'A': 1.0, 'eta_s': 0.5, 'sigma': 0.1}},\n        # 5. Gaussian source, very narrow\n        {'type': 'G', 'params': {'ell': 2, 'k': 25.0, 'eta0': 1.0, 'A': 1.0, 'eta_s': 0.5, 'sigma': 0.05}},\n        # 6. Derivative-of-Gaussian source, moderately narrow\n        {'type': 'Gp', 'params': {'ell': 3, 'k': 20.0, 'eta0': 1.2, 'B': 0.8, 'eta_s': 0.6, 'sigma': 0.2}},\n        # 7. Derivative-of-Gaussian source, narrower\n        {'type': 'Gp', 'params': {'ell': 3, 'k': 20.0, 'eta0': 1.2, 'B': 0.8, 'eta_s': 0.6, 'sigma': 0.1}},\n        # 8. Gaussian source, near boundary\n        {'type': 'G', 'params': {'ell': 0, 'k': 30.0, 'eta0': 1.0, 'A': 1.0, 'eta_s': 0.1, 'sigma': 0.05}},\n    ]\n\n    results = []\n\n    for case in test_cases:\n        p = case['params']\n        \n        # 1. Set up the integrand for numerical integration\n        integrand = None\n        if case['type'] == 'U':\n            ell, k, eta0, C = p['ell'], p['k'], p['eta0'], p['C']\n            source_func = lambda eta: C\n            integrand = lambda eta: source_func(eta) * spherical_jn(ell, k * (eta0 - eta))\n        \n        elif case['type'] == 'G':\n            ell, k, eta0, A, eta_s, sigma = p['ell'], p['k'], p['eta0'], p['A'], p['eta_s'], p['sigma']\n            norm = 1.0 / (np.sqrt(2 * np.pi) * sigma)\n            source_func = lambda eta: A * norm * np.exp(-(eta - eta_s)**2 / (2 * sigma**2))\n            integrand = lambda eta: source_func(eta) * spherical_jn(ell, k * (eta0 - eta))\n        \n        elif case['type'] == 'Gp':\n            ell, k, eta0, B, eta_s, sigma = p['ell'], p['k'], p['eta0'], p['B'], p['eta_s'], p['sigma']\n            norm_cubed = 1.0 / (np.sqrt(2 * np.pi) * sigma**3)\n            source_func = lambda eta: -B * (eta - eta_s) * norm_cubed * np.exp(-(eta - eta_s)**2 / (2 * sigma**2))\n            integrand = lambda eta: source_func(eta) * spherical_jn(ell, k * (eta0 - eta))\n\n        # 2. Perform the numerical integration\n        # For the highly oscillatory case, increase the subdivision limit\n        quad_limit = 50\n        if case['type'] == 'U' and p['k'] * p['eta0'] > 100:\n            quad_limit = 200\n        \n        theta_num = quad(integrand, 0, p['eta0'], limit=quad_limit)[0]\n\n        # 3. Calculate the expected (analytic or asymptotic) value\n        theta_exp = 0.0\n        if case['type'] == 'U':\n            k, eta0, C = p['k'], p['eta0'], p['C']\n            # The formula is specified for ell=0\n            if p['ell'] == 0:\n                theta_exp = C / k * sici(k * eta0)[0]\n        \n        elif case['type'] == 'G':\n            ell, k, eta0, A, eta_s = p['ell'], p['k'], p['eta0'], p['A'], p['eta_s']\n            theta_exp = A * spherical_jn(ell, k * (eta0 - eta_s))\n        \n        elif case['type'] == 'Gp':\n            ell, k, eta0, B, eta_s = p['ell'], p['k'], p['eta0'], p['B'], p['eta_s']\n            theta_exp = B * k * spherical_jn(ell, k * (eta0 - eta_s), derivative=True)\n            \n        # 4. Calculate the relative error\n        denominator = np.max([np.abs(theta_exp), 1e-12])\n        rel_err = np.abs(theta_num - theta_exp) / denominator\n        results.append(rel_err)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3478222"}, {"introduction": "A key prediction of the standard cosmological model is that primordial scalar perturbations generate only Electric-type ($E$-mode) polarization, with no Magnetic-type ($B$-mode) component. This exercise demonstrates how to use the line-of-sight integration framework as a powerful diagnostic tool for your numerical code. You will first construct a pure $E$-mode polarization map and then deliberately introduce a toy anisotropic scattering kernel that breaks the underlying symmetry of Thomson scattering. By measuring the resulting spurious $B$-mode power, you can test the integrity of a polarization analysis pipeline and gain intuition for how $E$-$B$ mixing arises from physical or instrumental effects [@problem_id:3478286].", "problem": "Consider a flat-sky model for the Cosmic Microwave Background (CMB) polarization in numerical cosmology, focusing on line-of-sight (LOS) integration. In the standard isotropic Thomson scattering, scalar perturbations generate only Electric-type (E) polarization modes and no Magnetic-type (B) modes. To diagnose numerical code correctness, we will introduce a toy anisotropic scattering kernel with a preferred direction that deliberately breaks azimuthal symmetry and can generate spurious B-modes through LOS integration.\n\nYou must implement a complete program that constructs a baseline pure E-mode polarization pattern from a single plane-wave scalar perturbation on a square angular patch, and then applies a LOS-integrated anisotropic kernel that induces a uniform polarization rotation depending on the misalignment between the plane-wave direction and the preferred direction. From this rotated pattern, you must compute the E and B modes and quantify the spurious B-mode generation.\n\nThe program must adhere to the following specifications:\n\n- Use the flat-sky approximation on a square angular patch of side length $L$ in radians discretized on an $N \\times N$ grid. Angles must be in radians.\n- Start from a single-mode scalar perturbation that generates a baseline pure E-mode polarization pattern. Construct the baseline Stokes parameters $Q(\\boldsymbol{\\theta})$ and $U(\\boldsymbol{\\theta})$ maps from a Fourier-space E-mode field with nonzero amplitude only at a single wavevector $\\boldsymbol{k}_0$ and its negative $-\\boldsymbol{k}_0$ so that the real-space maps are real. The resulting baseline must be E-only (i.e., B-mode vanishes up to numerical precision).\n- Introduce a toy anisotropic scattering kernel that produces a uniform Stokes rotation by an angle $\\alpha$ across the map, defined by an LOS integral of a normalized visibility function with a preferred direction dependence. The visibility function along LOS comoving distance $0 \\le \\chi \\le 1$ is a normalized Gaussian\n$$\ng(\\chi) = \\frac{1}{\\sqrt{2\\pi}\\,\\sigma}\\exp\\left(-\\frac{(\\chi-\\chi_\\star)^2}{2\\sigma^2}\\right),\n$$\nwith center $\\chi_\\star = 0.5$ and width $\\sigma > 0$. The anisotropy parameter $\\varepsilon$ controls the kernel strength, and the preferred direction makes an angle $\\varphi_p$ with respect to the $x$-axis. Let the plane-wave mode direction be $\\varphi_k$. The uniform rotation angle is\n$$\n\\alpha = \\varepsilon\\,\\left(\\int_{0}^{1} g(\\chi)\\,d\\chi\\right)\\,\\sin\\left(2(\\varphi_k-\\varphi_p)\\right).\n$$\n- After computing $\\alpha$ via numerical LOS integration (not by analytic evaluation), apply the uniform polarization rotation to the baseline $Q$ and $U$ maps to obtain rotated maps $Q'(\\boldsymbol{\\theta})$ and $U'(\\boldsymbol{\\theta})$.\n- Compute the Fourier-space E and B modes from the rotated maps using the standard flat-sky E/B decomposition from the Stokes parameters $Q$ and $U$ (do not hard-code target results; implement the correct transform definitions implied by the flat-sky relations between Fourier-space Stokes parameters and the E/B scalar fields).\n- Compute the total Fourier-space power in E and B,\n$$\nP_E = \\sum_{\\boldsymbol{k}} \\left|E(\\boldsymbol{k})\\right|^2,\\quad P_B = \\sum_{\\boldsymbol{k}} \\left|B(\\boldsymbol{k})\\right|^2,\n$$\nand report the spurious B-mode power fraction\n$$\nR = \\frac{P_B}{P_E}.\n$$\n\nYou must use the following fixed numerical setup unless specified otherwise by the test suite:\n- Patch side length $L = 1.0$ (radians).\n- Grid size $N = 64$.\n- Baseline E-mode amplitude $A = 1.0$ (dimensionless).\n- Single nonzero Fourier mode indices $(k_{x,\\text{ind}}, k_{y,\\text{ind}}) = (4, 0)$, giving $\\varphi_k = 0$.\n\nImplement a LOS numerical integration over $\\chi \\in [0,1]$ using a sufficiently fine one-dimensional grid to evaluate $\\int_0^1 g(\\chi)\\,d\\chi$.\n\nTest Suite:\nFor each test case, compute the spurious B-mode fraction $R$ as a float. Use the following parameter sets $(\\varepsilon, \\varphi_p, \\sigma)$:\n- Case $1$: $(0.0, \\pi/4, 0.05)$ — isotropic baseline, expected to yield $R$ near $0$.\n- Case $2$: $(0.05, \\pi/4, 0.05)$ — small anisotropy misaligned by $45^\\circ$.\n- Case $3$: $(0.2, \\pi/4, 0.05)$ — stronger anisotropy misaligned by $45^\\circ$.\n- Case $4$: $(0.2, 0.0, 0.05)$ — preferred direction parallel to the mode direction, symmetry should suppress rotation and yield $R$ near $0$.\n- Case $5$: $(0.2, \\pi/8, 10^{-3})$ — narrow visibility to test LOS integration stability with a nontrivial misalignment.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[r_1,r_2,r_3,r_4,r_5]$), where each $r_i$ is the computed spurious B-mode fraction $R$ for the corresponding test case, expressed as a float (dimensionless). No other text should be printed.", "solution": "We begin from the physical basis that in isotropic Thomson scattering, scalar perturbations produce polarization patterns with vanishing Magnetic-type (B) modes due to parity and azimuthal symmetry, while Electric-type (E) modes are nonzero. The Stokes parameters $Q$ and $U$ describe linear polarization on the sky. On the flat sky, it is standard to decompose the polarization into scalar E and B fields in Fourier space via linear combinations of the Fourier transforms $\\tilde{Q}(\\boldsymbol{k})$ and $\\tilde{U}(\\boldsymbol{k})$ with angular dependence on the wavevector direction $\\varphi_{\\boldsymbol{k}}$. The algorithmic goal is to construct a controlled baseline pure E-mode map and then apply a toy anisotropic kernel that induces a uniform rotation of the Stokes field, which mixes E into B. This provides a diagnostic: isotropic cases yield $B \\approx 0$, while anisotropy yields $B \\neq 0$ in proportion to the control parameters.\n\nStep-by-step derivation and algorithmic design:\n\n1. Flat-sky setup and Fourier conventions:\n   - Consider a square angular patch of side length $L$ in radians, discretized on an $N \\times N$ grid. Denote real-space angular coordinates by $\\boldsymbol{\\theta} = (\\theta_x, \\theta_y)$ and Fourier-space wavevectors by $\\boldsymbol{k} = (k_x, k_y)$ with angle $\\varphi_{\\boldsymbol{k}} = \\arctan2(k_y, k_x)$.\n   - Use Discrete Fourier Transforms to convert between real-space maps $Q(\\boldsymbol{\\theta}), U(\\boldsymbol{\\theta})$ and their Fourier transforms $\\tilde{Q}(\\boldsymbol{k}), \\tilde{U}(\\boldsymbol{k})$. For a real map, Fourier modes must satisfy Hermitian symmetry, i.e., $\\tilde{F}(-\\boldsymbol{k}) = \\tilde{F}(\\boldsymbol{k})^\\ast$ for any field $\\tilde{F}$.\n\n2. Construct a baseline pure E-mode field:\n   - Choose a single nonzero Fourier mode at indices $(k_{x,\\text{ind}}, k_{y,\\text{ind}}) = (4, 0)$ and its conjugate counterpart at $(-4, 0)$ to make real maps. Assign an E-mode amplitude $A > 0$ distributed symmetrically so that the sum of the pair yields a cosine in real space.\n   - For a pure E-mode in Fourier space, the Stokes parameters at each $\\boldsymbol{k}$ are given by\n     $$\n     \\tilde{Q}(\\boldsymbol{k}) = \\tilde{E}(\\boldsymbol{k}) \\cos\\left(2\\varphi_{\\boldsymbol{k}}\\right), \\quad\n     \\tilde{U}(\\boldsymbol{k}) = \\tilde{E}(\\boldsymbol{k}) \\sin\\left(2\\varphi_{\\boldsymbol{k}}\\right),\n     $$\n     with $\\tilde{B}(\\boldsymbol{k}) = 0$. By constructing $\\tilde{E}(\\boldsymbol{k})$ only at $\\pm \\boldsymbol{k}_0$ and zero elsewhere, inverse transforming yields real-space $Q(\\boldsymbol{\\theta})$ and $U(\\boldsymbol{\\theta})$ maps with vanishing B when decomposed back to E/B, up to numerical precision.\n\n3. Define the toy anisotropic scattering kernel and LOS integral:\n   - The anisotropic kernel introduces a preferred direction at angle $\\varphi_p$ and produces a uniform rotation of the polarization by angle $\\alpha$ derived from an LOS integral over a normalized Gaussian visibility function:\n     $$\n     g(\\chi) = \\frac{1}{\\sqrt{2\\pi}\\,\\sigma}\\exp\\left(-\\frac{(\\chi-\\chi_\\star)^2}{2\\sigma^2}\\right), \\quad \\chi_\\star = 0.5,\\quad \\sigma > 0,\\quad 0 \\le \\chi \\le 1.\n     $$\n     The kernel strength is controlled by $\\varepsilon$, and the relative misalignment between the plane-wave direction and the preferred direction is $\\Delta = \\varphi_k - \\varphi_p$, where $\\varphi_k$ is the angle of the nonzero mode $\\boldsymbol{k}_0$.\n   - The rotation angle is modeled as\n     $$\n     \\alpha = \\varepsilon \\left(\\int_{0}^{1} g(\\chi)\\,d\\chi\\right) \\sin(2\\Delta),\n     $$\n     which vanishes for $\\Delta = 0$ or $\\Delta = \\pi/2$, capturing symmetry cases where the anisotropy does not generate a net rotation. The integral must be computed numerically using a sufficiently fine grid to ensure stability.\n\n4. Polarization rotation and E/B mixing:\n   - Under a rotation of the polarization reference frame by angle $\\alpha$, the Stokes parameters transform as\n     $$\n     Q'(\\boldsymbol{\\theta}) = Q(\\boldsymbol{\\theta})\\cos(2\\alpha) - U(\\boldsymbol{\\theta})\\sin(2\\alpha), \\quad\n     U'(\\boldsymbol{\\theta}) = Q(\\boldsymbol{\\theta})\\sin(2\\alpha) + U(\\boldsymbol{\\theta})\\cos(2\\alpha).\n     $$\n     In Fourier space, the flat-sky E/B decomposition relates $(\\tilde{Q}, \\tilde{U})$ to $(\\tilde{E}, \\tilde{B})$ via angular factors depending on $\\varphi_{\\boldsymbol{k}}$. Implement these standard relations to compute $\\tilde{E}(\\boldsymbol{k})$ and $\\tilde{B}(\\boldsymbol{k})$ from $\\tilde{Q}'(\\boldsymbol{k})$ and $\\tilde{U}'(\\boldsymbol{k})$.\n   - Starting from a pure E-mode with $\\tilde{B} = 0$, a uniform rotation by $\\alpha$ mixes E into B. One can show that, mode by mode,\n     $$\n     \\tilde{E}'(\\boldsymbol{k}) = \\tilde{E}(\\boldsymbol{k})\\cos(2\\alpha),\\quad\n     \\tilde{B}'(\\boldsymbol{k}) = -\\tilde{E}(\\boldsymbol{k})\\sin(2\\alpha),\n     $$\n     and thus for a single mode the power ratio is\n     $$\n     R = \\frac{P_B}{P_E} = \\frac{\\sum_{\\boldsymbol{k}}|\\tilde{B}'(\\boldsymbol{k})|^2}{\\sum_{\\boldsymbol{k}}|\\tilde{E}'(\\boldsymbol{k})|^2} = \\tan^2(2\\alpha).\n     $$\n     In the numerical scheme using the discrete transform and summation over all modes, numerical precision and finite-grid effects may introduce small deviations, but the qualitative scaling remains.\n\n5. Numerical implementation details:\n   - Generate the Fourier-space grid wavevectors from the discrete frequencies $\\left(\\frac{2\\pi n_x}{L}, \\frac{2\\pi n_y}{L}\\right)$ using $n_x, n_y \\in \\mathbb{Z}$ from the $N$-point Fast Fourier Transform (FFT) frequency conventions.\n   - Build $\\tilde{E}(\\boldsymbol{k})$ with nonzero entries only at $(k_{x,\\text{ind}}, k_{y,\\text{ind}})$ and its Hermitian counterpart, ensuring $\\tilde{Q}$ and $\\tilde{U}$ inherit Hermitian symmetry so that the inverse FFT yields real $Q$ and $U$.\n   - Compute the LOS integral $\\int_0^1 g(\\chi)\\,d\\chi$ numerically using Simpson’s rule on a finely sampled $\\chi$ grid; evaluate $\\alpha$; rotate $Q$ and $U$; transform back to Fourier space; compute $\\tilde{E}$ and $\\tilde{B}$; then compute $P_E$ and $P_B$ and finally $R$.\n\n6. Test suite coverage and boundary cases:\n   - Case $1$ validates the isotropic baseline ($\\varepsilon = 0$), which should yield $R \\approx 0$.\n   - Cases $2$ and $3$ explore increasing anisotropy with $\\varphi_p = \\pi/4$, yielding nonzero $R$ that grows with $\\varepsilon$.\n   - Case $4$ sets $\\varphi_p = 0$, parallel to $\\varphi_k = 0$, so $\\Delta = 0$ and the symmetry suppresses rotation: $R \\approx 0$ despite nonzero $\\varepsilon$.\n   - Case $5$ uses a very narrow visibility ($\\sigma = 10^{-3}$) and $\\varphi_p = \\pi/8$ to test LOS integration stability and nontrivial misalignment.\n\nThe program must output a single line with a list of the five computed $R$ values in the exact format $[r_1,r_2,r_3,r_4,r_5]$ with no additional text.", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import simpson\n\ndef build_pure_E_qu(N, L, amplitude, kx_ind, ky_ind):\n    \"\"\"\n    Construct baseline pure E-mode Stokes Q and U maps on an NxN grid with side length L (radians),\n    using a single Fourier mode at indices (kx_ind, ky_ind) and its Hermitian counterpart.\n    \"\"\"\n    # Fourier-space wave numbers\n    kx = (2.0 * np.pi) * np.fft.fftfreq(N, d=L / N)\n    ky = (2.0 * np.pi) * np.fft.fftfreq(N, d=L / N)\n    KX, KY = np.meshgrid(kx, ky, indexing='xy')\n    # Angle of each wavevector\n    phi = np.arctan2(KY, KX)\n    # Handle k=0 angle gracefully\n    phi[np.isnan(phi)] = 0.0\n\n    # Initialize Fourier-space E field and ensure Hermitian symmetry\n    E_k = np.zeros((N, N), dtype=np.complex128)\n\n    # Positive index\n    pos = (ky_ind % N, kx_ind % N)\n    # Negative (Hermitian counterpart) index\n    neg = ((-ky_ind) % N, (-kx_ind) % N)\n\n    if pos == neg:\n        # If the mode is its own counterpart (only possible if both indices are 0, which we avoid),\n        # assign full amplitude to avoid double-counting.\n        E_k[pos] = amplitude\n    else:\n        # Split amplitude equally to produce a real cosine in real space\n        E_k[pos] = amplitude / 2.0\n        E_k[neg] = amplitude / 2.0\n\n    # Build Q_k and U_k from E_k using flat-sky relations for a pure E-mode\n    Q_k = E_k * np.cos(2.0 * phi)\n    U_k = E_k * np.sin(2.0 * phi)\n\n    # Inverse FFT to get real-space maps\n    Q = np.fft.ifft2(Q_k).real\n    U = np.fft.ifft2(U_k).real\n\n    return Q, U, KX, KY, phi\n\ndef rotate_stokes(Q, U, alpha):\n    \"\"\"\n    Apply uniform polarization rotation by angle alpha (radians) to Stokes Q, U.\n    Rotation acts as (Q', U') = R(2 alpha) (Q, U).\n    \"\"\"\n    ca = np.cos(2.0 * alpha)\n    sa = np.sin(2.0 * alpha)\n    Qp = Q * ca - U * sa\n    Up = Q * sa + U * ca\n    return Qp, Up\n\ndef eb_from_qu(Q, U, KX, KY):\n    \"\"\"\n    Compute Fourier-space E and B modes from Stokes Q and U maps via flat-sky relations.\n    \"\"\"\n    # Forward FFTs\n    Q_k = np.fft.fft2(Q)\n    U_k = np.fft.fft2(U)\n\n    # Wavevector angle\n    phi = np.arctan2(KY, KX)\n    phi[np.isnan(phi)] = 0.0\n\n    # E(k) and B(k) in Fourier space\n    E_k = Q_k * np.cos(2.0 * phi) + U_k * np.sin(2.0 * phi)\n    B_k = -Q_k * np.sin(2.0 * phi) + U_k * np.cos(2.0 * phi)\n    return E_k, B_k\n\ndef visibility_integral(sigma, chi_star=0.5, n_steps=4097):\n    \"\"\"\n    Numerically evaluate the integral of a normalized Gaussian visibility g(chi)\n    over chi in [0, 1] using Simpson's rule.\n    g(chi) = (1 / (sqrt(2*pi)*sigma)) * exp( - (chi - chi_star)^2 / (2*sigma^2) )\n    \"\"\"\n    chi = np.linspace(0.0, 1.0, n_steps)\n    g = (1.0 / (np.sqrt(2.0 * np.pi) * sigma)) * np.exp(-0.5 * ((chi - chi_star) / sigma) ** 2)\n    integral = simpson(g, chi)\n    return integral\n\ndef spurious_B_fraction(N, L, amplitude, kx_ind, ky_ind, epsilon, phi_p, sigma):\n    \"\"\"\n    Compute the spurious B-mode power fraction R = P_B / P_E for given anisotropy parameters.\n    \"\"\"\n    # Build baseline pure E-mode Stokes maps\n    Q, U, KX, KY, phi_grid = build_pure_E_qu(N, L, amplitude, kx_ind, ky_ind)\n\n    # Determine the angle of the single mode k0\n    kx0 = (2.0 * np.pi) * (kx_ind / L)\n    ky0 = (2.0 * np.pi) * (ky_ind / L)\n    phi_k = np.arctan2(ky0, kx0)\n\n    # LOS integral (normalized Gaussian visibility over [0,1])\n    G = visibility_integral(sigma=sigma, chi_star=0.5, n_steps=4097)\n\n    # Rotation angle alpha from anisotropic kernel\n    delta = phi_k - phi_p\n    alpha = epsilon * G * np.sin(2.0 * delta)\n\n    # Rotate Stokes parameters\n    Qp, Up = rotate_stokes(Q, U, alpha)\n\n    # Compute E and B modes after rotation\n    E_k, B_k = eb_from_qu(Qp, Up, KX, KY)\n\n    # Compute power sums (exclude k=0 if desired; here we include all modes uniformly)\n    P_E = np.sum(np.abs(E_k) ** 2)\n    P_B = np.sum(np.abs(B_k) ** 2)\n\n    # Avoid divide-by-zero: if P_E is tiny due to numerical issues, handle gracefully\n    if P_E == 0.0:\n        return 0.0\n    R = (P_B / P_E).real  # ratio is real-valued\n    return float(R)\n\ndef solve():\n    # Fixed grid and baseline parameters per problem statement\n    N = 64\n    L = 1.0  # radians\n    amplitude = 1.0\n    kx_ind, ky_ind = 4, 0  # single nonzero mode -> phi_k = 0\n\n    # Define the test cases (epsilon, phi_p, sigma)\n    test_cases = [\n        (0.0, np.pi / 4.0, 0.05),         # Case 1\n        (0.05, np.pi / 4.0, 0.05),        # Case 2\n        (0.2, np.pi / 4.0, 0.05),         # Case 3\n        (0.2, 0.0, 0.05),                 # Case 4\n        (0.2, np.pi / 8.0, 1e-3),         # Case 5\n    ]\n\n    results = []\n    for epsilon, phi_p, sigma in test_cases:\n        r = spurious_B_fraction(N, L, amplitude, kx_ind, ky_ind, epsilon, phi_p, sigma)\n        results.append(r)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3478286"}, {"introduction": "The highly oscillatory nature of spherical Bessel functions, $j_\\ell(x)$, within the line-of-sight integral poses a significant challenge for numerical stability and efficiency, particularly for large values of the wavenumber $k$ and multipole $\\ell$. This practice introduces an advanced technique, integration by parts (IBP), to reformulate the integral in a more numerically friendly way. The method works by transferring derivatives from the rapidly oscillating Bessel function to the typically smoother source function, effectively damping the integrand's oscillations. By deriving and implementing the IBP scheme, you will learn a powerful method for handling oscillatory integrals and test its performance against a direct quadrature, especially when dealing with physically realistic source functions that exhibit sharp features from the epoch of recombination [@problem_id:3478268].", "problem": "You are tasked with developing and validating a numerical integration-by-parts scheme for line-of-sight projections used in Cosmic Microwave Background (CMB) calculations. The objective is to transfer derivatives from oscillatory spherical Bessel functions onto the source function to achieve improved numerical stability. Your work must begin from fundamental, widely accepted bases in cosmology and applied mathematics, and you must not assume any unproven or ad hoc formulas.\n\nThe fundamental base to use is:\n- The photon Boltzmann hierarchy can be cast into a line-of-sight integral representation for multipole transfer functions. This representation expresses a multipole transfer function as an integral over conformal time of a source function multiplied by a spherical Bessel function, whose argument is the product of a wave number and a conformal time difference.\n- The spherical Bessel function $j_\\ell(x)$ is the standard special function arising in the separation of variables of the Helmholtz equation in spherical coordinates, and it is a solution of the spherical Bessel differential equation. Its oscillatory nature at large argument and order is known to cause numerical challenges in direct quadrature.\n\nYour tasks are:\n1. Derive, by integration by parts with respect to conformal time, a mathematically rigorous scheme that moves derivatives from the spherical Bessel factor onto the source function $S_X(k,\\eta)$ in the line-of-sight integral for a generic multipole $\\ell$ and wave number $k$. The derivation must begin from the standard line-of-sight integral expression and use only properties of the spherical Bessel function and basic calculus. You must not introduce any shortcut formulas that are not justified by these foundations. Clearly identify any boundary terms that arise and explain why they are retained.\n2. Design and implement a numerical algorithm that evaluates both:\n   - The original (direct) line-of-sight integral using straightforward quadrature.\n   - Your integration-by-parts reformulation, using the derivative of the source function and an antiderivative of the spherical Bessel function that results from your derivation.\n3. Construct a physically inspired, dimensionless source model $S_X(k,\\eta)$ that mimics sharp features from recombination while remaining smooth (continuously differentiable) so that its derivative exists. Use the following form:\n   - A recombination bump centered at conformal time $\\eta_{\\mathrm{rec}}$ with narrow width $\\sigma_{\\mathrm{rec}}$ and oscillatory acoustic modulation with angular frequency proportional to $k$:\n     $$S_{\\mathrm{rec}}(k,\\eta) = A_{\\mathrm{rec}} \\exp\\left[-\\frac{(\\eta-\\eta_{\\mathrm{rec}})^2}{2\\sigma_{\\mathrm{rec}}^2}\\right] \\cos\\!\\left(\\alpha(k)\\,(\\eta-\\eta_{\\mathrm{rec}})\\right),$$\n     where $\\alpha(k)$ is proportional to $k$ through a constant sound speed $c_s$.\n   - A broad Integrated Sachs–Wolfe-like late-time contribution centered at $\\eta_{\\mathrm{isw}}$ with width $\\sigma_{\\mathrm{isw}}$:\n     $$S_{\\mathrm{isw}}(\\eta) = A_{\\mathrm{isw}} \\exp\\left[-\\frac{(\\eta-\\eta_{\\mathrm{isw}})^2}{2\\sigma_{\\mathrm{isw}}^2}\\right].$$\n   - The total source is the sum $S_X(k,\\eta) = S_{\\mathrm{rec}}(k,\\eta) + S_{\\mathrm{isw}}(\\eta)$.\n   Provide analytic expressions for $\\partial S_X/\\partial \\eta$ and use them in your integration-by-parts scheme. All trigonometric arguments must be in radians.\n4. Implement the computations in dimensionless units by normalizing the present-day conformal time to $\\eta_0=1$ and the start of integration to $\\eta_i=0$. Use the change of variables $x=k(\\eta_0-\\eta)$ as appropriate for your scheme. No physical units are required; every quantity is dimensionless.\n5. Define numerical stability in terms of the relative difference between the direct integral and the integration-by-parts result. For a given pair of outputs $I_{\\mathrm{direct}}$ and $I_{\\mathrm{IBP}}$, define the relative difference as\n   $$\\delta = \\frac{\\lvert I_{\\mathrm{IBP}} - I_{\\mathrm{direct}} \\rvert}{\\max\\left(\\lvert I_{\\mathrm{direct}} \\rvert, \\epsilon\\right)},$$\n   with $\\epsilon$ a small positive number to avoid division by zero, which you must explicitly specify.\n6. Using your implementation, evaluate the relative difference $\\delta$ for the following test suite, which covers general behavior and sharp-feature edge cases:\n   - Test case 1 (happy path): $\\ell=50$, $k=80$, $\\sigma_{\\mathrm{rec}}=0.02$, threshold $\\tau=5\\times 10^{-3}$.\n   - Test case 2 (higher multipole and sharper feature): $\\ell=150$, $k=220$, $\\sigma_{\\mathrm{rec}}=0.01$, threshold $\\tau=10^{-2}$.\n   - Test case 3 (edge case, very sharp recombination bump): $\\ell=300$, $k=300$, $\\sigma_{\\mathrm{rec}}=0.005$, threshold $\\tau=2\\times 10^{-2}$.\n   Use fixed parameters $A_{\\mathrm{rec}}=1$, $A_{\\mathrm{isw}}=0.2$, $\\eta_{\\mathrm{rec}}=0.3$, $\\eta_{\\mathrm{isw}}=0.8$, $\\sigma_{\\mathrm{isw}}=0.2$, $c_s=0.5$, $\\eta_0=1$, $\\eta_i=0$, and $\\epsilon=10^{-15}$.\n7. For each test case, return a boolean indicating stability, defined as $\\delta < \\tau$.\n8. Final output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[$\\text{result1},\\text{result2},\\text{result3}$]\"). The entries must be the three booleans for the three test cases, in the order given above.\n\nYour final answer must be a complete, runnable program in Python that performs the calculations and prints the results in the specified format. Angles must be in radians, and all quantities are dimensionless.", "solution": "The user has provided a problem from the domain of numerical cosmology, tasking me to derive, implement, and test an integration-by-parts (IBP) scheme for computing Cosmic Microwave Background (CMB) line-of-sight integrals. The problem is scientifically sound, well-posed, and all necessary parameters and definitions are provided. I will therefore proceed with a complete solution.\n\nThe solution involves three main stages:\n1.  A mathematical derivation of the integration-by-parts formula for the line-of-sight integral.\n2.  The analytical definition of the source function and its derivative.\n3.  The design of a numerical algorithm to compute and compare the direct integral with the IBP formulation.\n\n### 1. Mathematical Derivation of the Integration-by-Parts Scheme\n\nThe fundamental line-of-sight integral for a generic CMB multipole transfer function $\\Delta_\\ell(k)$ is given by:\n$$ \\Delta_\\ell(k) = \\int_{\\eta_i}^{\\eta_0} S_X(k, \\eta) j_\\ell(k(\\eta_0 - \\eta)) \\, d\\eta $$\nHere, $S_X(k, \\eta)$ is the source function for a given wave number $k$ at conformal time $\\eta$, $j_\\ell$ is the spherical Bessel function of order $\\ell$, and the integration is from an initial time $\\eta_i$ to the present time $\\eta_0$. The problem specifies dimensionless units where $\\eta_i = 0$ and $\\eta_0 = 1$. The integral is thus:\n$$ \\Delta_\\ell(k) = \\int_{0}^{1} S_X(k, \\eta) j_\\ell(k(1 - \\eta)) \\, d\\eta $$\nThe objective is to reformulate this integral using integration by parts, $\\int u \\, dv = [uv] - \\int v \\, du$, to transfer the effective \"differentiation\" from the oscillatory Bessel function to the smoother source function.\n\nWe choose the parts as follows:\n-   $u(\\eta) = S_X(k, \\eta)$\n-   $dv = j_\\ell(k(1 - \\eta)) \\, d\\eta$\n\nFrom this, the derivative of $u$ is straightforward:\n-   $du = \\frac{\\partial S_X(k, \\eta)}{\\partial \\eta} \\, d\\eta$\n\nTo find $v(\\eta)$, we must integrate $dv$. Let's perform a change of variable to $y = k(1 - \\eta)$, which implies $d\\eta = -dy/k$.\n$$ v(\\eta) = \\int j_\\ell(k(1 - \\eta)) \\, d\\eta = \\int j_\\ell(y) \\left(-\\frac{dy}{k}\\right) = -\\frac{1}{k} \\int j_\\ell(y) \\, dy $$\nWe define the antiderivative of the spherical Bessel function, $J_\\ell^{(-1)}(x)$, as the definite integral from $0$ to $x$:\n$$ J_\\ell^{(-1)}(x) \\equiv \\int_0^x j_\\ell(y) \\, dy $$\nThis choice of lower limit is a convention that simplifies the boundary terms, as $J_\\ell^{(-1)}(0) = 0$. With this definition, $v(\\eta)$ becomes:\n$$ v(\\eta) = -\\frac{1}{k} J_\\ell^{(-1)}(k(1 - \\eta)) $$\nNow, we apply the integration-by-parts formula:\n$$ \\Delta_\\ell(k) = \\left[ u(\\eta)v(\\eta) \\right]_0^1 - \\int_0^1 v(\\eta) du(\\eta) $$\n$$ \\Delta_\\ell(k) = \\left[ S_X(k, \\eta) \\left(-\\frac{1}{k} J_\\ell^{(-1)}(k(1 - \\eta))\\right) \\right]_0^1 - \\int_0^1 \\left(-\\frac{1}{k} J_\\ell^{(-1)}(k(1 - \\eta))\\right) \\frac{\\partial S_X(k, \\eta)}{\\partial \\eta} \\, d\\eta $$\nLet's evaluate the boundary term part, which the problem requires us to retain:\n$$ \\left[ \\dots \\right]_0^1 = \\left( S_X(k, 1) \\left(-\\frac{1}{k} J_\\ell^{(-1)}(0)\\right) \\right) - \\left( S_X(k, 0) \\left(-\\frac{1}{k} J_\\ell^{(-1)}(k(1-0))\\right) \\right) $$\nUsing our definition $J_\\ell^{(-1)}(0) = 0$, the first part vanishes:\n$$ \\left[ \\dots \\right]_0^1 = 0 - \\left( -\\frac{S_X(k, 0)}{k} J_\\ell^{(-1)}(k) \\right) = \\frac{S_X(k, 0)}{k} J_\\ell^{(-1)}(k) $$\nThe integral term simplifies to:\n$$ \\frac{1}{k} \\int_0^1 \\frac{\\partial S_X(k, \\eta)}{\\partial \\eta} J_\\ell^{(-1)}(k(1 - \\eta)) \\, d\\eta $$\nCombining the boundary and integral terms gives the final integration-by-parts formulation:\n$$ \\Delta_\\ell(k)_{\\text{IBP}} = \\frac{S_X(k, 0)}{k} \\int_0^k j_\\ell(y) \\, dy + \\frac{1}{k} \\int_0^1 \\frac{\\partial S_X(k, \\eta)}{\\partial \\eta} \\left( \\int_0^{k(1-\\eta)} j_\\ell(y) \\, dy \\right) d\\eta $$\nThis is the rigorous scheme to be implemented. It replaces the integral of the highly oscillatory $j_\\ell$ with an integral involving its antiderivative, $J_\\ell^{(-1)}$, and the derivative of the source function, $\\partial S_X/\\partial \\eta$.\n\n### 2. Source Function and its Derivative\n\nThe problem defines a physically inspired source function $S_X(k, \\eta)$ as the sum of a recombination term $S_{\\mathrm{rec}}(k,\\eta)$ and a late-time Integrated Sachs-Wolfe (ISW) term $S_{\\mathrm{isw}}(\\eta)$:\n$$ S_X(k,\\eta) = S_{\\mathrm{rec}}(k,\\eta) + S_{\\mathrm{isw}}(\\eta) $$\nwhere\n$$ S_{\\mathrm{rec}}(k,\\eta) = A_{\\mathrm{rec}} \\exp\\left[-\\frac{(\\eta-\\eta_{\\mathrm{rec}})^2}{2\\sigma_{\\mathrm{rec}}^2}\\right] \\cos\\!\\left(k c_s (\\eta-\\eta_{\\mathrm{rec}})\\right) $$\n$$ S_{\\mathrm{isw}}(\\eta) = A_{\\mathrm{isw}} \\exp\\left[-\\frac{(\\eta-\\eta_{\\mathrm{isw}})^2}{2\\sigma_{\\mathrm{isw}}^2}\\right] $$\nThe derivative $\\partial S_X / \\partial \\eta$, required for the IBP scheme, is found by differentiating each term.\nThe derivative of the ISW term is:\n$$ \\frac{\\partial S_{\\mathrm{isw}}}{\\partial \\eta} = A_{\\mathrm{isw}} \\exp\\left[-\\frac{(\\eta-\\eta_{\\mathrm{isw}})^2}{2\\sigma_{\\mathrm{isw}}^2}\\right] \\cdot \\left( -\\frac{2(\\eta-\\eta_{\\mathrm{isw}})}{2\\sigma_{\\mathrm{isw}}^2} \\right) = -A_{\\mathrm{isw}} \\frac{(\\eta-\\eta_{\\mathrm{isw}})}{\\sigma_{\\mathrm{isw}}^2} \\exp\\left[-\\frac{(\\eta-\\eta_{\\mathrm{isw}})^2}{2\\sigma_{\\mathrm{isw}}^2}\\right] $$\nThe derivative of the recombination term requires the product rule:\n$$ \\frac{\\partial S_{\\mathrm{rec}}}{\\partial \\eta} = \\frac{\\partial}{\\partial\\eta} \\left( A_{\\mathrm{rec}} \\exp\\left[\\dots\\right] \\cos\\left[\\dots\\right] \\right) $$\n$$ = A_{\\mathrm{rec}} \\left\\{ \\left( -\\frac{\\eta-\\eta_{\\mathrm{rec}}}{\\sigma_{\\mathrm{rec}}^2} \\exp[\\dots] \\right) \\cos[\\dots] + \\exp[\\dots] \\left( -k c_s \\sin[\\dots] \\right) \\right\\} $$\n$$ = -A_{\\mathrm{rec}} \\exp\\left[-\\frac{(\\eta-\\eta_{\\mathrm{rec}})^2}{2\\sigma_{\\mathrm{rec}}^2}\\right] \\left[ \\frac{\\eta-\\eta_{\\mathrm{rec}}}{\\sigma_{\\mathrm{rec}}^2} \\cos(k c_s (\\eta-\\eta_{\\mathrm{rec}})) + k c_s \\sin(k c_s (\\eta-\\eta_{\\mathrm{rec}})) \\right] $$\nThese analytical expressions for $S_X(k, \\eta)$ and $\\partial S_X(k,\\eta)/\\partial\\eta$ will be implemented in the numerical code.\n\n### 3. Numerical Implementation and Stability Test\n\nThe verification of the IBP scheme's numerical stability will be performed by comparing its result, $I_{\\mathrm{IBP}}$, against a direct numerical evaluation of the original integral, $I_{\\mathrm{direct}}$.\n\n**Direct Method:**\nThe integral is computed directly using a standard numerical quadrature routine (`scipy.integrate.quad`):\n$$ I_{\\mathrm{direct}} = \\int_0^1 S_X(k, \\eta) j_\\ell(k(1-\\eta)) \\, d\\eta $$\n\n**Integration-by-Parts (IBP) Method:**\nThe IBP formulation involves nested integrals. The outer integration is over $\\eta$, and for each evaluation point $\\eta$, an inner integral is computed to find the value of the Bessel function's antiderivative $J_\\ell^{(-1)}$.\n$$ I_{\\mathrm{IBP}} = \\text{BoundaryTerm} + \\text{IntegralTerm} $$\n$$ \\text{BoundaryTerm} = \\frac{S_X(k, 0)}{k} J_\\ell^{(-1)}(k) = \\frac{S_X(k, 0)}{k} \\int_0^k j_\\ell(y) \\, dy $$\n$$ \\text{IntegralTerm} = \\frac{1}{k} \\int_0^1 \\frac{\\partial S_X(k, \\eta)}{\\partial \\eta} J_\\ell^{(-1)}(k(1 - \\eta)) \\, d\\eta = \\frac{1}{k} \\int_0^1 \\frac{\\partial S_X(k, \\eta)}{\\partial \\eta} \\left( \\int_0^{k(1 - \\eta)} j_\\ell(y) \\, dy \\right) d\\eta $$\nBoth the inner and outer integrals will be computed using `scipy.integrate.quad`. The spherical Bessel function $j_\\ell(x)$ will be evaluated using `scipy.special.spherical_jn`.\n\n**Stability Metric:**\nThe numerical stability is quantified by the relative difference $\\delta$ between the two methods:\n$$ \\delta = \\frac{\\lvert I_{\\mathrm{IBP}} - I_{\\mathrm{direct}} \\rvert}{\\max\\left(\\lvert I_{\\mathrm{direct}} \\rvert, \\epsilon\\right)} $$\nA small constant $\\epsilon = 10^{-15}$ is used to prevent division by zero. A test case is deemed \"stable\" if its computed $\\delta$ is less than a given threshold $\\tau$. This process will be repeated for all test cases specified in the problem.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import spherical_jn\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Derives, implements, and tests an integration-by-parts (IBP) scheme for\n    CMB line-of-sight integrals.\n    \"\"\"\n    \n    # Define fixed parameters from the problem statement.\n    A_rec = 1.0\n    A_isw = 0.2\n    eta_rec = 0.3\n    eta_isw = 0.8\n    sigma_isw = 0.2\n    c_s = 0.5\n    eta0 = 1.0\n    eta_i = 0.0\n    epsilon = 1e-15\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'l': 50, 'k': 80, 'sigma_rec': 0.02, 'tau': 5e-3},\n        {'l': 150, 'k': 220, 'sigma_rec': 0.01, 'tau': 1e-2},\n        {'l': 300, 'k': 300, 'sigma_rec': 0.005, 'tau': 2e-2},\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        l = case['l']\n        k = case['k']\n        sigma_rec = case['sigma_rec']\n        tau = case['tau']\n        \n        # 1. Define the source function and its derivative\n        def source_function(eta, k_val, sigma_rec_val):\n            # Recombination part\n            eta_diff_rec = eta - eta_rec\n            exp_rec = np.exp(-eta_diff_rec**2 / (2 * sigma_rec_val**2))\n            cos_rec = np.cos(k_val * c_s * eta_diff_rec)\n            s_rec = A_rec * exp_rec * cos_rec\n            \n            # ISW part\n            eta_diff_isw = eta - eta_isw\n            exp_isw = np.exp(-eta_diff_isw**2 / (2 * sigma_isw**2))\n            s_isw = A_isw * exp_isw\n            \n            return s_rec + s_isw\n\n        def source_derivative(eta, k_val, sigma_rec_val):\n            # Derivative of recombination part\n            eta_diff_rec = eta - eta_rec\n            exp_rec = np.exp(-eta_diff_rec**2 / (2 * sigma_rec_val**2))\n            \n            term1_rec = (eta_diff_rec / sigma_rec_val**2) * np.cos(k_val * c_s * eta_diff_rec)\n            term2_rec = (k_val * c_s) * np.sin(k_val * c_s * eta_diff_rec)\n            ds_rec_deta = -A_rec * exp_rec * (term1_rec + term2_rec)\n            \n            # Derivative of ISW part\n            eta_diff_isw = eta - eta_isw\n            ds_isw_deta = -A_isw * (eta_diff_isw / sigma_isw**2) * np.exp(-eta_diff_isw**2 / (2 * sigma_isw**2))\n            \n            return ds_rec_deta + ds_isw_deta\n            \n        S_X = lambda eta: source_function(eta, k, sigma_rec)\n        dS_X_deta = lambda eta: source_derivative(eta, k, sigma_rec)\n\n        # 2. Compute the direct integral\n        integrand_direct = lambda eta: S_X(eta) * spherical_jn(l, k * (eta0 - eta))\n        I_direct, _ = quad(integrand_direct, eta_i, eta0, limit=200)\n        \n        # 3. Compute the IBP integral\n        \n        # Helper function for the antiderivative of j_l(x)\n        # Using a cache dictionary for memoization to speed up nested integration,\n        # although quad's adaptive nature means it's not guaranteed to hit the same point.\n        j_antideriv_cache = {}\n        def j_antiderivative(x_max, ell):\n            if (x_max, ell) in j_antideriv_cache:\n                return j_antideriv_cache[(x_max, ell)]\n            if x_max == 0:\n                return 0.0\n            \n            # The integrand for the antiderivative\n            integrand = lambda y: spherical_jn(ell, y)\n            \n            # Numerical integration to get the antiderivative\n            # Use stricter tolerance for the inner integral for better accuracy\n            result, _ = quad(integrand, 0, x_max, limit=200, epsabs=1.49e-10, epsrel=1.49e-10)\n            j_antideriv_cache[(x_max, ell)] = result\n            return result\n        \n        # Boundary term\n        s0 = S_X(eta_i)\n        boundary_term = (s0 / k) * j_antiderivative(k, l) if k != 0 else 0\n        \n        # Integral term\n        integrand_ibp = lambda eta: dS_X_deta(eta) * j_antiderivative(k * (eta0 - eta), l)\n        \n        integral_term, _ = quad(integrand_ibp, eta_i, eta0, limit=200)\n        integral_term /= k\n\n        I_ibp = boundary_term + integral_term\n        \n        # 4. Calculate relative difference and determine stability\n        diff = abs(I_ibp - I_direct)\n        norm = max(abs(I_direct), epsilon)\n        delta = diff / norm\n        \n        is_stable = delta < tau\n        results.append(is_stable)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, [r for r in results]))}]\")\n\nsolve()\n```", "id": "3478268"}]}