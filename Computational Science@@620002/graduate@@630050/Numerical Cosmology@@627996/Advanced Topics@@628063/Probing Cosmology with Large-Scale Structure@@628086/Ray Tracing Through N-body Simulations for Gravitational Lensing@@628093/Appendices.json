{"hands_on_practices": [{"introduction": "Before diving into complex numerical simulations, it is essential to master the analytical foundations of gravitational lensing. The Singular Isothermal Sphere (SIS) model, despite its simplicity, provides a powerful and surprisingly accurate description for galaxy-scale lenses. This exercise [@problem_id:3483295] guides you through deriving the deflection angle and Einstein radius for an SIS lens from first principles, providing a crucial analytical benchmark for testing and validating numerical ray-tracing codes.", "problem": "In numerical cosmology ray tracing through N-body gravitational simulations, a widely used analytic benchmark is the singular isothermal sphere (SIS). Consider a spherically symmetric lens with $3$-dimensional mass density profile $\\rho(r) = \\sigma_v^2 \\big/ \\left(2 \\pi G r^2\\right)$, where $r$ is the spherical radius, $\\sigma_v$ is the one-dimensional velocity dispersion, and $G$ is Newton’s gravitational constant. A source lies at redshift $z_s$ and the lens at redshift $z_l$. Let $D_l$, $D_s$, and $D_{ls}$ denote the angular diameter distances from observer to lens, observer to source, and lens to source, respectively, in an arbitrary Friedmann–Lemaître–Robertson–Walker cosmology. Adopt the thin-lens approximation and axisymmetry.\n\nStarting from fundamental gravitational lensing definitions and the Newtonian-limit light deflection by a localized mass distribution, carry out the following steps:\n\n- Compute the projected surface mass density $\\Sigma(\\xi)$ by integrating $\\rho(r)$ along the line of sight, where $\\xi$ is the projected radius in the lens plane.\n- Using axisymmetry, obtain the enclosed projected mass $M(\\xi)$ and the corresponding physical deflection magnitude in the lens plane $\\hat{\\alpha}(\\xi)$ for a light ray with impact parameter $\\xi$.\n- Relate the reduced deflection angle on the sky, $\\boldsymbol{\\alpha}(\\boldsymbol{\\theta})$, to $\\hat{\\alpha}(\\xi)$ using angular diameter distances, with $\\boldsymbol{\\xi} = D_l \\boldsymbol{\\theta}$.\n- Determine the Einstein radius $\\theta_E$ by imposing perfect alignment of source, lens, and observer.\n\nExpress $\\boldsymbol{\\alpha}(\\boldsymbol{\\theta})$ as a vector in the direction of $\\boldsymbol{\\theta}$ and $\\theta_E$ as a scalar, both in terms of $\\sigma_v$, $c$, $D_l$, $D_s$, and $D_{ls}$, where $c$ is the speed of light. Express all angular quantities in radians. Provide your final answer as a single row matrix with two entries in the order $\\left(\\boldsymbol{\\alpha}(\\boldsymbol{\\theta}), \\theta_E\\right)$. No numerical evaluation is required, and no rounding is needed. Do not include units in the final boxed answer; use radians implicitly for angles.", "solution": "The user has provided a well-posed and scientifically grounded problem in astrophysics, specifically in the domain of gravitational lensing. The problem requires the derivation of the deflection angle and Einstein radius for a singular isothermal sphere (SIS) lens model. The validation process confirms that the problem is complete, consistent, and solvable using established principles of physics and mathematics. I will now proceed with a systematic derivation following the steps outlined in the problem statement.\n\nThe $3$-dimensional mass density profile of the singular isothermal sphere is given by\n$$ \\rho(r) = \\frac{\\sigma_v^2}{2 \\pi G r^2} $$\nwhere $r$ is the spherical radius, $\\sigma_v$ is the one-dimensional velocity dispersion, and $G$ is the gravitational constant.\n\nStep 1: Compute the projected surface mass density $\\Sigma(\\xi)$.\nThe surface mass density, $\\Sigma(\\xi)$, is obtained by integrating the volume mass density, $\\rho(r)$, along the line of sight. Let the line-of-sight coordinate be $z$, and the projected radius in the lens plane be $\\xi$. The spherical radius $r$ is related to these coordinates by $r^2 = \\xi^2 + z^2$.\n$$ \\Sigma(\\xi) = \\int_{-\\infty}^{\\infty} \\rho(r) \\, dz = \\int_{-\\infty}^{\\infty} \\rho\\left(\\sqrt{\\xi^2 + z^2}\\right) \\, dz $$\nSubstituting the expression for $\\rho(r)$:\n$$ \\Sigma(\\xi) = \\int_{-\\infty}^{\\infty} \\frac{\\sigma_v^2}{2 \\pi G (\\xi^2 + z^2)} \\, dz $$\nWe can factor out the constants and evaluate the standard integral:\n$$ \\Sigma(\\xi) = \\frac{\\sigma_v^2}{2 \\pi G} \\int_{-\\infty}^{\\infty} \\frac{1}{\\xi^2 + z^2} \\, dz = \\frac{\\sigma_v^2}{2 \\pi G} \\left[ \\frac{1}{\\xi} \\arctan\\left(\\frac{z}{\\xi}\\right) \\right]_{z=-\\infty}^{z=\\infty} $$\nEvaluating the limits:\n$$ \\Sigma(\\xi) = \\frac{\\sigma_v^2}{2 \\pi G \\xi} \\left( \\frac{\\pi}{2} - \\left(-\\frac{\\pi}{2}\\right) \\right) = \\frac{\\sigma_v^2}{2 \\pi G \\xi} (\\pi) = \\frac{\\sigma_v^2}{2 G \\xi} $$\n\nStep 2: Obtain the enclosed projected mass $M(\\xi)$ and the physical deflection magnitude $\\hat{\\alpha}(\\xi)$.\nDue to the specified axisymmetry, the mass enclosed within a projected radius $\\xi$ is found by integrating the surface mass density over a circular area of radius $\\xi$.\n$$ M(\\xi) = \\int_{0}^{\\xi} 2\\pi \\xi' \\Sigma(\\xi') \\, d\\xi' $$\nSubstituting the expression for $\\Sigma(\\xi')$:\n$$ M(\\xi) = \\int_{0}^{\\xi} 2\\pi \\xi' \\left( \\frac{\\sigma_v^2}{2 G \\xi'} \\right) \\, d\\xi' = \\int_{0}^{\\xi} \\frac{\\pi \\sigma_v^2}{G} \\, d\\xi' = \\frac{\\pi \\sigma_v^2}{G} \\xi $$\nThe physical deflection angle $\\hat{\\alpha}$ for a light ray with impact parameter $\\xi$ is given by the weak-field gravitational lensing formula. For a circularly symmetric projected mass distribution, this is analogous to the deflection by a point mass, where the mass $M$ is replaced by the enclosed projected mass $M(\\xi)$.\n$$ \\hat{\\alpha}(\\xi) = \\frac{4 G M(\\xi)}{c^2 \\xi} $$\nwhere $c$ is the speed of light. Substituting the expression for $M(\\xi)$:\n$$ \\hat{\\alpha}(\\xi) = \\frac{4 G}{c^2 \\xi} \\left( \\frac{\\pi \\sigma_v^2}{G} \\xi \\right) = \\frac{4 \\pi \\sigma_v^2}{c^2} $$\nA key result for the SIS model is that the physical deflection angle $\\hat{\\alpha}$ is constant, independent of the impact parameter $\\xi$.\n\nStep 3: Relate the reduced deflection angle $\\boldsymbol{\\alpha}(\\boldsymbol{\\theta})$ to $\\hat{\\alpha}(\\xi)$.\nThe lens equation relates the true angular position of the source, $\\boldsymbol{\\beta}$, to the observed angular position of the image, $\\boldsymbol{\\theta}$, via the reduced deflection angle, $\\boldsymbol{\\alpha}(\\boldsymbol{\\theta})$:\n$$ \\boldsymbol{\\beta} = \\boldsymbol{\\theta} - \\boldsymbol{\\alpha}(\\boldsymbol{\\theta}) $$\nThe reduced deflection angle $\\boldsymbol{\\alpha}(\\boldsymbol{\\theta})$ is related to the physical deflection angle in the lens plane, $\\hat{\\boldsymbol{\\alpha}}(\\boldsymbol{\\xi})$, by the ratio of angular diameter distances $D_{ls}$ (lens to source) and $D_s$ (observer to source):\n$$ \\boldsymbol{\\alpha}(\\boldsymbol{\\theta}) = \\frac{D_{ls}}{D_s} \\hat{\\boldsymbol{\\alpha}}(\\boldsymbol{\\xi}) $$\nFor a spherically symmetric lens, the deflection is radial. The vector $\\boldsymbol{\\alpha}(\\boldsymbol{\\theta})$ points from the lens center towards the image position $\\boldsymbol{\\theta}$ in the standard convention where the image appears farther from the optic axis than the source. Thus, the direction of $\\boldsymbol{\\alpha}(\\boldsymbol{\\theta})$ is parallel to $\\boldsymbol{\\theta}$. The magnitude of the reduced deflection angle, which we denote as $\\alpha(\\theta)$, is:\n$$ \\alpha(\\theta) = \\frac{D_{ls}}{D_s} \\hat{\\alpha}(\\xi) $$\nwhere $\\theta = |\\boldsymbol{\\theta}|$ is the magnitude of the angular position vector. The physical impact parameter $\\xi$ is related to the angle $\\theta$ by $\\xi = D_l \\theta$, where $D_l$ is the angular diameter distance to the lens. Since $\\hat{\\alpha}$ is constant for an SIS lens, $\\alpha(\\theta)$ is also a constant, independent of $\\theta$:\n$$ \\alpha = \\frac{4 \\pi \\sigma_v^2}{c^2} \\frac{D_{ls}}{D_s} $$\nThe vector expression for the reduced deflection angle is its magnitude multiplied by the unit vector in the direction of $\\boldsymbol{\\theta}$:\n$$ \\boldsymbol{\\alpha}(\\boldsymbol{\\theta}) = \\alpha \\frac{\\boldsymbol{\\theta}}{\\theta} = \\left( \\frac{4 \\pi \\sigma_v^2 D_{ls}}{c^2 D_s} \\right) \\frac{\\boldsymbol{\\theta}}{\\theta} $$\n\nStep 4: Determine the Einstein radius $\\theta_E$.\nThe Einstein radius, $\\theta_E$, is the angular radius of the ring-shaped image formed when the source, lens, and observer are perfectly aligned. This alignment corresponds to the source being on the optical axis, i.e., $\\boldsymbol{\\beta} = \\mathbf{0}$.\nSetting $\\boldsymbol{\\beta} = \\mathbf{0}$ in the lens equation gives:\n$$ \\boldsymbol{\\theta} = \\boldsymbol{\\alpha}(\\boldsymbol{\\theta}) $$\nThe solution to this equation, denoted $\\boldsymbol{\\theta}_E$, represents the position of the Einstein ring. Taking the magnitude of both sides:\n$$ |\\boldsymbol{\\theta}_E| = |\\boldsymbol{\\alpha}(\\boldsymbol{\\theta}_E)| $$\nLetting $\\theta_E = |\\boldsymbol{\\theta}_E|$, and using the result for the magnitude of the deflection angle $\\alpha$:\n$$ \\theta_E = \\alpha = \\frac{4 \\pi \\sigma_v^2}{c^2} \\frac{D_{ls}}{D_s} $$\nThus, for the singular isothermal sphere, the Einstein radius is a constant equal to the magnitude of the reduced deflection angle.\n\nThe two requested quantities are the vector expression for the reduced deflection angle, $\\boldsymbol{\\alpha}(\\boldsymbol{\\theta})$, and the scalar expression for the Einstein radius, $\\theta_E$. They are given by:\n$$ \\boldsymbol{\\alpha}(\\boldsymbol{\\theta}) = \\left( \\frac{4 \\pi \\sigma_v^2 D_{ls}}{c^2 D_s} \\right) \\frac{\\boldsymbol{\\theta}}{|\\boldsymbol{\\theta}|} \\quad \\text{and} \\quad \\theta_E = \\frac{4 \\pi \\sigma_v^2 D_{ls}}{c^2 D_s} $$\nNote that the results do not depend on the lens distance $D_l$, which is a characteristic feature of the SIS model. All angular quantities are in radians, as specified.", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\left( \\frac{4 \\pi \\sigma_v^2 D_{ls}}{c^2 D_s} \\right) \\frac{\\boldsymbol{\\theta}}{|\\boldsymbol{\\theta}|}  \\frac{4 \\pi \\sigma_v^2 D_{ls}}{c^2 D_s}\n\\end{pmatrix}\n}\n$$", "id": "3483295"}, {"introduction": "Moving from analytical theory to numerical practice involves discretizing continuous fields onto a grid, a process that introduces its own set of challenges. This exercise [@problem_id:3483287] uses the more realistic Navarro-Frenk-White (NFW) profile to explore how a halo's density is represented on a pixelated map and the consequences for ray tracing. By comparing the lensed signal recovered via bilinear interpolation to the exact analytical result, you will directly quantify numerical errors and gain intuition for the trade-offs between grid resolution and accuracy.", "problem": "Consider a single lens plane populated by an analytic Navarro–Frenk–White (NFW) halo defined by mass and concentration parameters $(M_{200},c)$. Work in a spatially flat Friedmann–Lemaître–Robertson–Walker (FLRW) cosmology with matter density parameter $\\Omega_{\\mathrm{m}}$, dark energy density parameter $\\Omega_{\\Lambda}$, and Hubble parameter $H_0$. Place the lens at redshift $z_{\\mathrm{d}}$ and sources at redshift $z_{\\mathrm{s}}$. You are to embed the analytic NFW profile into a pixelized density field, perform ray tracing on the resulting convergence map using bilinear interpolation, and quantify interpolation-induced biases by comparing to the exact analytic convergence evaluated at the same ray positions.\n\nUse the following fundamental laws and well-tested formulas as the base:\n- The angular diameter distance in a flat Universe is $D_{\\mathrm{A}}(z) = \\chi(z)/(1+z)$, where $\\chi(z) = \\int_0^z \\frac{c}{H(z')} \\, \\mathrm{d}z'$ is the comoving distance, $c$ is the speed of light, and $H(z) = H_0 \\sqrt{\\Omega_{\\mathrm{m}}(1+z)^3 + \\Omega_{\\Lambda}}$.\n- The critical surface density is $\\Sigma_{\\mathrm{crit}} = \\frac{c^2}{4\\pi G} \\frac{D_{\\mathrm{s}}}{D_{\\mathrm{d}} D_{\\mathrm{ds}}}$, where $D_{\\mathrm{d}} = D_{\\mathrm{A}}(z_{\\mathrm{d}})$, $D_{\\mathrm{s}} = D_{\\mathrm{A}}(z_{\\mathrm{s}})$, and $D_{\\mathrm{ds}} = \\frac{\\chi(z_{\\mathrm{s}})-\\chi(z_{\\mathrm{d}})}{1+z_{\\mathrm{s}}}$.\n- The NFW three-dimensional mass profile defines $r_{200}$ via $M_{200} = \\frac{4\\pi}{3} 200 \\rho_{\\mathrm{crit}}(z_{\\mathrm{d}}) r_{200}^3$, where $\\rho_{\\mathrm{crit}}(z) = \\frac{3 H(z)^2}{8\\pi G}$, and $r_{\\mathrm{s}} = r_{200}/c$. The characteristic density is $\\rho_{\\mathrm{s}} = \\frac{M_{200}}{4\\pi r_{\\mathrm{s}}^3 [\\ln(1+c) - c/(1+c)]}$.\n- The projected NFW surface density $\\Sigma(R)$ at projected radius $R$ can be written as $\\Sigma(R) = 2 \\rho_{\\mathrm{s}} r_{\\mathrm{s}} f(x)$ with $x=R/r_{\\mathrm{s}}$ and\n$$\nf(x) =\n\\begin{cases}\n\\dfrac{1 - \\frac{2}{\\sqrt{1-x^2}} \\operatorname{arctanh}\\left(\\sqrt{\\frac{1-x}{1+x}}\\right)}{x^2 - 1},  0  x  1, \\\\\n\\dfrac{1}{3},  x=1, \\\\\n\\dfrac{1 - \\frac{2}{\\sqrt{x^2-1}} \\arctan\\left(\\sqrt{\\frac{x-1}{x+1}}\\right)}{x^2 - 1},  x > 1,\n\\end{cases}\n$$\nand the convergence (dimensionless surface mass density) is $\\kappa(R) = \\Sigma(R)/\\Sigma_{\\mathrm{crit}}$.\n\nYour task:\n1. Derive the expressions required to compute $D_{\\mathrm{d}}$, $D_{\\mathrm{s}}$, $D_{\\mathrm{ds}}$, $\\Sigma_{\\mathrm{crit}}$, $r_{200}$, $r_{\\mathrm{s}}$, $\\rho_{\\mathrm{s}}$, and the analytic $\\kappa(R)$ for an NFW halo using the base formulas above.\n2. Construct a square, uniformly spaced, two-dimensional grid that covers a box of side length $L = 4 r_{200}$ centered on the halo. The grid resolution is $N \\times N$ pixels, with pixel width $\\Delta = L/N$. At each pixel center $(x_i,y_j)$, compute the projected radius $R_{ij} = \\sqrt{x_i^2 + y_j^2}$ and assign the analytic $\\Sigma(R_{ij})$ to the grid to create a surface density map. Then compute the convergence map $\\kappa_{ij} = \\Sigma(R_{ij})/\\Sigma_{\\mathrm{crit}}$. To maintain numerical stability, define a softening scale $R_{\\mathrm{soft}} = \\max(10^{-4} r_{\\mathrm{s}}, \\Delta/2)$ and evaluate $\\Sigma(R)$ at $R' = \\max(R,R_{\\mathrm{soft}})$ to avoid the logarithmic divergence at $R \\to 0$.\n3. Emulate ray tracing by sampling $N_{\\mathrm{ray}}$ ray positions $(x,y)$ in the lens plane. Use $N_{\\mathrm{ray}}=3000$ ray positions with radii $R$ drawn logarithmically from $R_{\\min} = 2\\Delta$ to $R_{\\max} = \\min(1.5 r_{200}, L/2 - 2\\Delta)$, and angles $\\phi$ uniformly from $[0, 2\\pi)$ (in radians). For each ray, compute:\n   - The analytic convergence $\\kappa_{\\mathrm{true}} = \\kappa(R)$.\n   - The interpolated convergence $\\kappa_{\\mathrm{interp}}$ by bilinear interpolation of the pixelized $\\kappa$ map at $(x,y)$.\n4. For each test case, compute the root-mean-square (RMS) relative bias\n$$\nb_{\\mathrm{RMS}} = \\sqrt{\\frac{1}{N_{\\mathrm{ray}}} \\sum_{n=1}^{N_{\\mathrm{ray}}} \\left(\\frac{\\kappa_{\\mathrm{interp},n} - \\kappa_{\\mathrm{true},n}}{\\kappa_{\\mathrm{true},n}}\\right)^2 }.\n$$\n\nCosmological parameters and units:\n- Use $\\Omega_{\\mathrm{m}} = 0.3$, $\\Omega_{\\Lambda} = 0.7$, $H_0 = 70\\,\\mathrm{km}\\,\\mathrm{s}^{-1}\\,\\mathrm{Mpc}^{-1}$, $c = 299{,}792.458\\,\\mathrm{km}\\,\\mathrm{s}^{-1}$, and $G = 4.30091\\times 10^{-9}\\,\\mathrm{Mpc}\\,(\\mathrm{km}/\\mathrm{s})^2\\,M_{\\odot}^{-1}$.\n- Place the lens at $z_{\\mathrm{d}} = 0.3$ and source at $z_{\\mathrm{s}} = 1.0$.\n- Express all distances in $\\mathrm{Mpc}$, masses in $M_{\\odot}$, and surface densities in $M_{\\odot}/\\mathrm{Mpc}^2$. The final RMS relative bias $b_{\\mathrm{RMS}}$ is dimensionless.\n\nTest suite:\nEvaluate $b_{\\mathrm{RMS}}$ for the following four cases:\n- Case A (happy path): $(M_{200}, c, N) = (1.0\\times 10^{14}\\,M_{\\odot}, 6, 256)$.\n- Case B (high concentration, moderate grid): $(M_{200}, c, N) = (1.0\\times 10^{12}\\,M_{\\odot}, 12, 128)$.\n- Case C (coarse resolution edge case): $(M_{200}, c, N) = (5.0\\times 10^{14}\\,M_{\\odot}, 4, 64)$.\n- Case D (massive halo, fine grid): $(M_{200}, c, N) = (2.0\\times 10^{15}\\,M_{\\odot}, 3, 512)$.\n\nFinal output specification:\nYour program should produce a single line of output containing the four $b_{\\mathrm{RMS}}$ values for Cases A–D, as a comma-separated list enclosed in square brackets, in the order [A,B,C,D]. For example: \"[0.00123,0.00456,0.01234,0.00078]\". Angles must be in radians for all computations.", "solution": "The user has provided a scientifically sound and well-posed problem. The task is to calculate the root-mean-square (RMS) relative bias introduced by bilinear interpolation when ray tracing through a pixelized convergence map of an analytic Navarro–Frenk–White (NFW) halo.\n\nThis solution will proceed in a structured manner, first detailing the calculation of all necessary physical quantities and then outlining the numerical algorithm designed to compute the specified bias.\n\n### 1. Cosmological Framework and Lensing Quantities\n\nThe problem is set in a spatially flat Friedmann–Lemaître–Robertson–Walker (FLRW) cosmology. The evolution of the Hubble parameter $H(z)$ with redshift $z$ is given by:\n$$H(z) = H_0 \\sqrt{\\Omega_{\\mathrm{m}}(1+z)^3 + \\Omega_{\\Lambda}}$$\nwhere $H_0 = 70\\,\\mathrm{km}\\,\\mathrm{s}^{-1}\\,\\mathrm{Mpc}^{-1}$ is the Hubble constant, $\\Omega_{\\mathrm{m}} = 0.3$ is the matter density parameter, and $\\Omega_{\\Lambda} = 0.7$ is the dark energy density parameter.\n\nThe comoving distance $\\chi(z)$ from an observer at $z=0$ to an object at redshift $z$ is calculated by integrating the Hubble distance:\n$$\\chi(z) = \\int_0^z \\frac{c_{light}}{H(z')} \\, \\mathrm{d}z'$$\nwhere $c_{light} = 299792.458\\,\\mathrm{km}\\,\\mathrm{s}^{-1}$ is the speed of light. This integral will be computed numerically.\n\nThe angular diameter distances to the lens ($D_{\\mathrm{d}}$), to the source ($D_{\\mathrm{s}}$), and from the lens to the source ($D_{\\mathrm{ds}}$) are essential for lensing calculations. For a flat universe, they are:\n$$D_{\\mathrm{d}} = D_{\\mathrm{A}}(z_{\\mathrm{d}}) = \\frac{\\chi(z_{\\mathrm{d}})}{1+z_{\\mathrm{d}}}$$\n$$D_{\\mathrm{s}} = D_{\\mathrm{A}}(z_{\\mathrm{s}}) = \\frac{\\chi(z_{\\mathrm{s}})}{1+z_{\\mathrm{s}}}$$\n$$D_{\\mathrm{ds}} = \\frac{\\chi(z_{\\mathrm{s}})-\\chi(z_{\\mathrm{d}})}{1+z_{\\mathrm{s}}}$$\nwith the lens at redshift $z_{\\mathrm{d}} = 0.3$ and the source at $z_{\\mathrm{s}} = 1.0$.\n\nThe critical surface mass density, $\\Sigma_{\\mathrm{crit}}$, is the threshold surface density required for strong lensing. It depends on the geometry of the lens system:\n$$\\Sigma_{\\mathrm{crit}} = \\frac{c_{light}^2}{4\\pi G} \\frac{D_{\\mathrm{s}}}{D_{\\mathrm{d}} D_{\\mathrm{ds}}}$$\nwhere $G = 4.30091\\times 10^{-9}\\,\\mathrm{Mpc}\\,(\\mathrm{km}/\\mathrm{s})^2\\,M_{\\odot}^{-1}$ is the gravitational constant.\n\n### 2. NFW Halo Model\n\nThe lens is modeled as an NFW dark matter halo, defined by its mass $M_{200}$ and concentration parameter $c_{conc}$.\nThe radius $r_{200}$ encloses a mean density equal to $200$ times the critical density of the universe at the lens redshift, $\\rho_{\\mathrm{crit}}(z_{\\mathrm{d}})$. The critical density is:\n$$\\rho_{\\mathrm{crit}}(z) = \\frac{3 H(z)^2}{8\\pi G}$$\nFrom the definition of $M_{200}$, we can solve for $r_{200}$:\n$$M_{200} = \\frac{4\\pi}{3} 200 \\rho_{\\mathrm{crit}}(z_{\\mathrm{d}}) r_{200}^3 \\implies r_{200} = \\left( \\frac{3 M_{200}}{800\\pi \\rho_{\\mathrm{crit}}(z_{\\mathrm{d}})} \\right)^{1/3}$$\nThe NFW profile has two parameters: a scale radius $r_{\\mathrm{s}}$ and a characteristic density $\\rho_{\\mathrm{s}}$. They are related to $M_{200}$ and $c_{conc}$ by:\n$$r_{\\mathrm{s}} = \\frac{r_{200}}{c_{conc}}$$\n$$\\rho_{\\mathrm{s}} = \\frac{M_{200}}{4\\pi r_{\\mathrm{s}}^3 \\left[\\ln(1+c_{conc}) - \\frac{c_{conc}}{1+c_{conc}}\\right]}$$\n\n### 3. Projected Density and Convergence\n\nThe three-dimensional NFW density profile, when projected onto the lens plane, results in a surface mass density $\\Sigma(R)$ at a projected radius $R$:\n$$\\Sigma(R) = 2 \\rho_{\\mathrm{s}} r_{\\mathrm{s}} f(x), \\quad \\text{where } x = R/r_{\\mathrm{s}}$$\nThe dimensionless function $f(x)$ is given by:\n$$\nf(x) =\n\\begin{cases}\n\\dfrac{1 - \\frac{2}{\\sqrt{1-x^2}} \\operatorname{arctanh}\\left(\\sqrt{\\frac{1-x}{1+x}}\\right)}{x^2 - 1},  0  x  1, \\\\\n\\dfrac{1}{3},  x=1, \\\\\n\\dfrac{1 - \\frac{2}{\\sqrt{x^2-1}} \\arctan\\left(\\sqrt{\\frac{x-1}{x+1}}\\right)}{x^2 - 1},  x > 1.\n\\end{cases}\n$$\nThe NFW profile has a cusp at $R=0$, leading to a logarithmic divergence in $\\Sigma(R)$. To ensure numerical stability, a softening length $R_{\\mathrm{soft}} = \\max(10^{-4} r_{\\mathrm{s}}, \\Delta/2)$ is introduced, where $\\Delta$ is the grid pixel width. The surface density is evaluated at a softened radius $R' = \\max(R, R_{\\mathrm{soft}})$.\n\nThe convergence, $\\kappa(R)$, is the surface mass density normalized by the critical density:\n$$\\kappa(R) = \\frac{\\Sigma(R)}{\\Sigma_{\\mathrm{crit}}}$$\n\n### 4. Numerical Algorithm\n\n#### Grid Generation\nA two-dimensional convergence map is created on a square grid.\n- Grid side length: $L = 4 r_{200}$, centered on the halo.\n- Grid resolution: $N \\times N$ pixels.\n- Pixel width: $\\Delta = L/N$.\n- The grid consists of pixel values $\\kappa_{ij}$, computed by evaluating the analytic (softened) convergence $\\kappa(R_{ij})$ at the center of each pixel $(i,j)$ with projected radius $R_{ij}$.\n\n#### Ray Sampling\n$N_{\\mathrm{ray}}=3000$ light rays are traced through the lens plane. Their positions $(x,y)$ are generated as follows:\n- Radii $R$ are drawn from a logarithmic distribution between $R_{\\min} = 2\\Delta$ and $R_{\\max} = \\min(1.5 r_{200}, L/2 - 2\\Delta)$. For all test cases, this simplifies to $R_{\\max} = 1.5 r_{200}$.\n- Azimuthal angles $\\phi$ are drawn from a uniform distribution in $[0, 2\\pi)$.\n\n#### Interpolation and Comparison\nFor each sampled ray at position $(x,y)$:\n- The true convergence, $\\kappa_{\\mathrm{true}}$, is calculated using the analytic formula $\\kappa(R)$, where $R=\\sqrt{x^2+y^2}$. To isolate interpolation error, $\\kappa_{\\mathrm{true}}$ is computed using the same softening rule applied to the grid, i.e., at radius $R' = \\max(R, R_{\\mathrm{soft}})$.\n- The interpolated convergence, $\\kappa_{\\mathrm{interp}}$, is obtained by performing bilinear interpolation on the four nearest pixel values of the $\\kappa_{ij}$ map.\n\n### 5. Quantifying Interpolation Bias\n\nThe RMS relative bias $b_{\\mathrm{RMS}}$ is computed to quantify the average discrepancy between the interpolated and true convergence values over all sampled rays:\n$$b_{\\mathrm{RMS}} = \\sqrt{\\frac{1}{N_{\\mathrm{ray}}} \\sum_{n=1}^{N_{\\mathrm{ray}}} \\left(\\frac{\\kappa_{\\mathrm{interp},n} - \\kappa_{\\mathrm{true},n}}{\\kappa_{\\mathrm{true},n}}\\right)^2 }$$\n\nThis procedure is repeated for each of the four test cases specified in the problem statement. The implementation will be vectorized for efficient computation.", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Solves the gravitational lensing interpolation bias problem.\n    This function encapsulates the entire logic to compute the RMS relative bias\n    for four different NFW halo and grid configurations.\n    \"\"\"\n\n    # Cosmological parameters and physical constants\n    C_LIGHT = 299792.458  # Speed of light in km/s\n    G_CONST = 4.30091e-9  # Gravitational constant in Mpc*(km/s)^2/M_sun\n    H0 = 70.0  # Hubble constant in km/s/Mpc\n    OMEGA_M = 0.3  # Matter density parameter\n    OMEGA_L = 0.7  # Dark energy density parameter\n    Z_D = 0.3  # Lens redshift\n    Z_S = 1.0  # Source redshift\n\n    # Simulation parameters\n    N_RAY = 3000\n\n    # Set a random seed for reproducible ray sampling\n    np.random.seed(42)\n\n    # --- Cosmological Calculations ---\n    memoized_chi = {}\n    def H_z(z):\n        return H0 * np.sqrt(OMEGA_M * (1 + z)**3 + OMEGA_L)\n\n    def H_inv(z):\n        return 1.0 / H_z(z)\n\n    def chi_z(z):\n        if z not in memoized_chi:\n            result, _ = quad(H_inv, 0, z)\n            memoized_chi[z] = C_LIGHT * result\n        return memoized_chi[z]\n\n    chi_d = chi_z(Z_D)\n    chi_s = chi_z(Z_S)\n    \n    D_d = chi_d / (1.0 + Z_D)\n    D_s = chi_s / (1.0 + Z_S)\n    D_ds = (chi_s - chi_d) / (1.0 + Z_S)\n\n    Sigma_crit = (C_LIGHT**2 / (4 * np.pi * G_CONST)) * (D_s / (D_d * D_ds))\n    \n    # --- NFW Profile Functions ---\n    def nfw_f(x):\n        \"\"\"\n        Computes the NFW dimensionless projected density function f(x) for x = R/r_s.\n        This function is vectorized to handle numpy arrays.\n        \"\"\"\n        x = np.atleast_1d(x)\n        out = np.zeros_like(x, dtype=float)\n        \n        # Case 1: 0  x  1\n        mask_lt1 = (x  1.0)  ~np.isclose(x, 1.0)\n        if np.any(mask_lt1):\n            x_lt1 = x[mask_lt1]\n            term = np.arctanh(np.sqrt((1.0 - x_lt1) / (1.0 + x_lt1)))\n            out[mask_lt1] = (1.0 - (2.0 / np.sqrt(1.0 - x_lt1**2)) * term) / (x_lt1**2 - 1.0)\n\n        # Case 2: x = 1\n        mask_eq1 = np.isclose(x, 1.0)\n        if np.any(mask_eq1):\n            out[mask_eq1] = 1.0 / 3.0\n\n        # Case 3: x > 1\n        mask_gt1 = x > 1.0\n        if np.any(mask_gt1):\n            x_gt1 = x[mask_gt1]\n            term = np.arctan(np.sqrt((x_gt1 - 1.0) / (x_gt1 + 1.0)))\n            out[mask_gt1] = (1.0 - (2.0 / np.sqrt(x_gt1**2 - 1.0)) * term) / (x_gt1**2 - 1.0)\n        \n        return out if x.size > 1 else out.item()\n\n\n    def calculate_rms_bias(M200, c_conc, N):\n        \"\"\"\n        Main function to compute RMS bias for a given set of parameters.\n        \n        Args:\n            M200 (float): Halo mass in solar masses.\n            c_conc (float): Halo concentration.\n            N (int): Grid resolution (N x N).\n        \n        Returns:\n            float: The calculated RMS relative bias.\n        \"\"\"\n        # 1. Calculate NFW halo parameters\n        H_zd = H_z(Z_D)\n        rho_crit_zd = (3.0 * H_zd**2) / (8.0 * np.pi * G_CONST)\n        r200 = ((3.0 * M200) / (4.0 * np.pi * 200.0 * rho_crit_zd))**(1.0/3.0)\n        r_s = r200 / c_conc\n        \n        denominator = 4.0 * np.pi * r_s**3 * (np.log(1.0 + c_conc) - c_conc / (1.0 + c_conc))\n        rho_s = M200 / denominator\n\n        # 2. Set up the pixelized convergence map\n        L = 4.0 * r200\n        delta = L / N\n        R_soft = max(1e-4 * r_s, delta / 2.0)\n\n        grid_coords_1d = np.linspace(-L/2.0 + delta/2.0, L/2.0 - delta/2.0, N)\n        xx, yy = np.meshgrid(grid_coords_1d, grid_coords_1d, indexing='ij')\n        R_grid = np.sqrt(xx**2 + yy**2)\n\n        def kappa_analytic(R):\n            R_eff = np.maximum(R, R_soft)\n            x = R_eff / r_s\n            Sigma = 2.0 * rho_s * r_s * nfw_f(x)\n            return Sigma / Sigma_crit\n        \n        kappa_map = kappa_analytic(R_grid)\n\n        # 3. Sample ray positions\n        R_min = 2.0 * delta\n        R_max = 1.5 * r200\n        \n        radii = np.logspace(np.log10(R_min), np.log10(R_max), N_RAY)\n        angles = np.random.uniform(0, 2.0 * np.pi, N_RAY)\n        \n        ray_x = radii * np.cos(angles)\n        ray_y = radii * np.sin(angles)\n        ray_R = np.sqrt(ray_x**2 + ray_y**2)\n\n        # 4. Compute true and interpolated convergence values\n        kappa_true = kappa_analytic(ray_R)\n\n        # Vectorized bilinear interpolation\n        i_f = (ray_x + L/2.0) / delta - 0.5\n        j_f = (ray_y + L/2.0) / delta - 0.5\n        \n        i1 = np.floor(i_f).astype(int)\n        j1 = np.floor(j_f).astype(int)\n        \n        i1 = np.clip(i1, 0, N - 2)\n        j1 = np.clip(j1, 0, N - 2)\n        i2, j2 = i1 + 1, j1 + 1\n\n        dx, dy = i_f - i1, j_f - j1\n        \n        Q11 = kappa_map[i1, j1] # val at (i1, j1)\n        Q21 = kappa_map[i2, j1] # val at (i2, j1)\n        Q12 = kappa_map[i1, j2] # val at (i1, j2)\n        Q22 = kappa_map[i2, j2] # val at (i2, j2)\n\n        kappa_interp = (Q11 * (1 - dx) * (1 - dy) +\n                        Q21 * dx * (1 - dy) +\n                        Q12 * (1 - dx) * dy +\n                        Q22 * dx * dy)\n\n        # 5. Calculate RMS relative bias\n        relative_errors = (kappa_interp - kappa_true) / kappa_true\n        valid_mask = np.isfinite(relative_errors)  (kappa_true != 0)\n        b_rms = np.sqrt(np.mean(relative_errors[valid_mask]**2))\n        \n        return b_rms\n\n    # --- Test Suite Execution ---\n    test_cases = [\n        # Case A: happy path\n        {'M200': 1.0e14, 'c_conc': 6.0, 'N': 256},\n        # Case B: high concentration, moderate grid\n        {'M200': 1.0e12, 'c_conc': 12.0, 'N': 128},\n        # Case C: coarse resolution edge case\n        {'M200': 5.0e14, 'c_conc': 4.0, 'N': 64},\n        # Case D: massive halo, fine grid\n        {'M200': 2.0e15, 'c_conc': 3.0, 'N': 512},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = calculate_rms_bias(case['M200'], case['c_conc'], case['N'])\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3483287"}, {"introduction": "Cosmological simulations begin not with analytical profiles, but with discrete particles. Assigning these particles to a grid using schemes like Cloud-In-Cell (CIC) is a fundamental step, but it inherently smooths the density field, an effect described by a convolution. This exercise [@problem_id:3483297] demonstrates a powerful technique to correct for this smoothing by working in Fourier space. You will learn to deconvolve the CIC window function from a convergence map, allowing for the reconstruction of a more accurate deflection field and highlighting the importance of post-processing simulation data.", "problem": "You are given a two-dimensional convergence field $\\kappa(\\boldsymbol{\\theta})$ on a flat sky, sampled on a periodic square domain of angular size $\\Theta_{\\rm box}$ in radians. The map has been produced by projecting $N$-body particles onto a grid using the Cloud-In-Cell (CIC) assignment scheme, which introduces a known convolution kernel. Your task is to deconvolve the CIC kernel in Fourier space to obtain a corrected convergence $\\tilde{\\kappa}(\\boldsymbol{\\ell})$, reconstruct the deflection field $\\boldsymbol{\\alpha}(\\boldsymbol{\\theta})$, and quantify the recovery accuracy against a known ground truth.\n\nFundamental base and definitions:\n- The two-dimensional angular coordinate is $\\boldsymbol{\\theta} = (\\theta_x, \\theta_y)$ with $\\theta_x, \\theta_y \\in [0,\\Theta_{\\rm box})$ in radians. The corresponding Fourier wavevector (multipole) is $\\boldsymbol{\\ell} = (\\ell_x,\\ell_y)$ with $\\ell = \\|\\boldsymbol{\\ell}\\|$ in $\\text{rad}^{-1}$.\n- The flat-sky Fourier transform convention is $\\tilde{f}(\\boldsymbol{\\ell}) = \\int d^2\\boldsymbol{\\theta}\\, f(\\boldsymbol{\\theta}) e^{-i\\boldsymbol{\\ell}\\cdot\\boldsymbol{\\theta}}$ and its inverse $f(\\boldsymbol{\\theta}) = \\int \\frac{d^2\\boldsymbol{\\ell}}{(2\\pi)^2}\\, \\tilde{f}(\\boldsymbol{\\ell}) e^{+i\\boldsymbol{\\ell}\\cdot\\boldsymbol{\\theta}}$.\n- The convergence $\\kappa(\\boldsymbol{\\theta})$ and lensing potential $\\psi(\\boldsymbol{\\theta})$ satisfy $\\kappa(\\boldsymbol{\\theta}) = \\frac{1}{2}\\nabla^2 \\psi(\\boldsymbol{\\theta})$. In Fourier space this implies $\\tilde{\\kappa}(\\boldsymbol{\\ell}) = -\\frac{1}{2}\\ell^2 \\tilde{\\psi}(\\boldsymbol{\\ell})$, where $\\ell^2 \\equiv \\ell_x^2+\\ell_y^2$.\n- The deflection field is $\\boldsymbol{\\alpha}(\\boldsymbol{\\theta}) = \\nabla \\psi(\\boldsymbol{\\theta})$. In Fourier space, $\\tilde{\\boldsymbol{\\alpha}}(\\boldsymbol{\\ell}) = i\\boldsymbol{\\ell}\\,\\tilde{\\psi}(\\boldsymbol{\\ell})$, which yields the relation $\\tilde{\\boldsymbol{\\alpha}}(\\boldsymbol{\\ell}) = -2i \\frac{\\boldsymbol{\\ell}}{\\ell^2}\\, \\tilde{\\kappa}(\\boldsymbol{\\ell})$ for $\\ell \\neq 0$ and $\\tilde{\\boldsymbol{\\alpha}}(\\boldsymbol{0})=\\boldsymbol{0}$ under periodic boundary conditions.\n- Cloud-In-Cell (CIC) assignment induces a multiplicative window in Fourier space. For a square grid with pixel size $\\Delta\\theta = \\Theta_{\\rm box}/N$, the CIC window is\n$$\nW_{\\rm CIC}(\\boldsymbol{\\ell}) = \\left[\\operatorname{sinc}\\left(\\frac{\\ell_x \\Delta\\theta}{2}\\right)\\right]^2 \\left[\\operatorname{sinc}\\left(\\frac{\\ell_y \\Delta\\theta}{2}\\right)\\right]^2,\n$$\nwhere $\\operatorname{sinc}(x) \\equiv \\frac{\\sin x}{x}$ with $\\operatorname{sinc}(0)=1$. If $\\tilde{\\kappa}_{\\rm CIC}(\\boldsymbol{\\ell})$ is the Fourier transform of the CIC-assigned convergence map, then the deconvolved estimate is $\\tilde{\\kappa}(\\boldsymbol{\\ell}) = \\tilde{\\kappa}_{\\rm CIC}(\\boldsymbol{\\ell})/W_{\\rm CIC}(\\boldsymbol{\\ell})$ for modes where $W_{\\rm CIC}(\\boldsymbol{\\ell}) \\neq 0$.\n\nDiscrete setup and algorithmic requirements:\n- The map is represented on an $N\\times N$ grid with $N$ even, periodic boundary conditions, and uniform pixel spacing $\\Delta\\theta = \\Theta_{\\rm box}/N$.\n- Use a Fast Fourier Transform (FFT) to implement all transforms consistently with the above continuous relations by identifying discrete frequencies $f_x,f_y$ (in cycles per radian) via $f = \\text{fftfreq}(N,\\Delta\\theta)$ and $\\boldsymbol{\\ell} = 2\\pi \\boldsymbol{f}$.\n- Implement the deconvolution by dividing $\\tilde{\\kappa}_{\\rm CIC}(\\boldsymbol{\\ell})$ by $W_{\\rm CIC}(\\boldsymbol{\\ell})$ mode-by-mode. For numerical safety, define a small positive threshold $\\epsilon$ and, for modes with $W_{\\rm CIC}(\\boldsymbol{\\ell}) \\le \\epsilon$, set $\\tilde{\\kappa}(\\boldsymbol{\\ell})$ to zero. Choose $\\epsilon$ small enough that the deconvolution is not biased for accessible modes, e.g., $\\epsilon = 10^{-15}$.\n- Reconstruct the deflection field by computing $\\tilde{\\boldsymbol{\\alpha}}(\\boldsymbol{\\ell}) = -2i \\frac{\\boldsymbol{\\ell}}{\\ell^2}\\, \\tilde{\\kappa}(\\boldsymbol{\\ell})$ for $\\ell \\neq 0$, and inverse FFT to obtain $\\boldsymbol{\\alpha}(\\boldsymbol{\\theta})$ in configuration space. Treat the $\\ell=\\boldsymbol{0}$ mode as zero.\n\nTest suite:\nConstruct synthetic ground-truth cases for $\\kappa(\\boldsymbol{\\theta})$ by defining a single discrete Fourier mode with known amplitude. Specifically, define the ground-truth $\\tilde{\\kappa}(\\boldsymbol{\\ell})$ on the discrete grid as two symmetric delta coefficients at indices $(m_x,m_y)$ and $(-m_x,-m_y)$ to ensure a real field. Use the discrete FFT normalization such that setting the Fourier coefficients to $\\frac{A N^2}{2}$ at both $(m_x,m_y)$ and $(-m_x,-m_y)$ yields a cosine mode in real space with peak amplitude $A$. Then define $\\tilde{\\kappa}_{\\rm CIC}(\\boldsymbol{\\ell}) = W_{\\rm CIC}(\\boldsymbol{\\ell}) \\tilde{\\kappa}(\\boldsymbol{\\ell})$, and apply your deconvolution and deflection reconstruction pipeline.\n\nProvide the following test cases:\n- Case $1$ (happy path): $N=64$, $\\Theta_{\\rm box} = 0.5$ radians, mode indices $(m_x,m_y)=(5,7)$, amplitude $A=10^{-2}$.\n- Case $2$ (high-frequency edge): $N=64$, $\\Theta_{\\rm box} = 0.5$ radians, mode indices $(m_x,m_y)=(31,0)$, amplitude $A=10^{-2}$.\n- Case $3$ (zero field boundary): $N=64$, $\\Theta_{\\rm box} = 0.5$ radians, mode indices $(m_x,m_y)=(0,0)$, amplitude $A=0$.\n\nFor each case:\n- Generate the ground-truth $\\tilde{\\kappa}(\\boldsymbol{\\ell})$ as above, compute the ground-truth deflection field $\\boldsymbol{\\alpha}_{\\rm true}(\\boldsymbol{\\theta})$ using the Fourier-domain relation between $\\tilde{\\kappa}(\\boldsymbol{\\ell})$ and $\\tilde{\\boldsymbol{\\alpha}}(\\boldsymbol{\\ell})$.\n- Obtain $\\tilde{\\kappa}_{\\rm CIC}(\\boldsymbol{\\ell})$ by multiplying by $W_{\\rm CIC}(\\boldsymbol{\\ell})$, then deconvolve to estimate $\\tilde{\\kappa}(\\boldsymbol{\\ell})$.\n- Reconstruct the corrected deflection field $\\boldsymbol{\\alpha}_{\\rm rec}(\\boldsymbol{\\theta})$.\n- Compute the root-mean-square error in radians,\n$$\n{\\rm RMSE} = \\left[\\frac{1}{N^2}\\sum_{p=1}^{N^2} \\left( (\\alpha_{{\\rm rec},x}^{(p)} - \\alpha_{{\\rm true},x}^{(p)})^2 + (\\alpha_{{\\rm rec},y}^{(p)} - \\alpha_{{\\rm true},y}^{(p)})^2 \\right) \\right]^{1/2},\n$$\nwhere the sum is over all pixels $p$, and $(\\alpha_x,\\alpha_y)$ are the two components of the deflection vector at each pixel.\n\nAngle unit specification:\n- All angular quantities, including the deflection field and errors, must be expressed in radians.\n\nFinal output specification:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each entry must be the ${\\rm RMSE}$ for one of the cases in the order $[{\\rm Case}\\,1, {\\rm Case}\\,2, {\\rm Case}\\,3]$, expressed in radians in scientific notation with nine significant digits (for example, $[1.234567890e-06,9.876543210e-04,0.000000000e+00]$).", "solution": "The problem statement is entirely valid. It presents a well-posed numerical task grounded in the standard principles of gravitational lensing analysis in cosmology. All necessary physical relations, numerical definitions, and test parameters are provided, allowing for a unique and verifiable solution.\n\nThe solution involves implementing a series of operations in Fourier space using the Fast Fourier Transform (FFT). The process can be broken down into the following steps: generating a ground-truth signal, simulating the effect of the Cloud-In-Cell (CIC) assignment scheme, deconvolving this effect, reconstructing the physical quantity of interest (the deflection field), and quantifying the error.\n\nFirst, we set up the discrete two-dimensional grid. The simulation domain is a periodic square of angular size $\\Theta_{\\rm box}$ radians, discretized into an $N \\times N$ grid of pixels. The pixel size is $\\Delta\\theta = \\Theta_{\\rm box} / N$. In this discrete domain, we use the `numpy.fft` library to perform Fourier transforms. The angular frequencies (multipoles) $\\boldsymbol{\\ell} = (\\ell_x, \\ell_y)$ are related to the discrete frequencies $\\boldsymbol{f} = (f_x, f_y)$ from `numpy.fft.fftfreq` by $\\boldsymbol{\\ell} = 2\\pi \\boldsymbol{f}$. We construct $2$D grids for $\\ell_x, \\ell_y$ and $\\ell^2 = \\ell_x^2 + \\ell_y^2$.\n\nSecond, for each test case, we generate the ground-truth convergence field $\\kappa_{\\rm true}(\\boldsymbol{\\theta})$ and deflection field $\\boldsymbol{\\alpha}_{\\rm true}(\\boldsymbol{\\theta})$. This is done in Fourier space. The problem specifies that the ground-truth convergence field for a given test case is a single cosine mode with amplitude $A$ and integer mode indices $(m_x, m_y)$. A real-valued cosine mode in configuration space corresponds to two delta functions in Fourier space at symmetric wavevectors. To achieve a real field with peak amplitude $A$, we initialize an $N \\times N$ complex array for $\\tilde{\\kappa}_{\\rm true}(\\boldsymbol{\\ell})$ with zeros. Then, we add the value $V = \\frac{A N^2}{2}$ to the elements at array indices $(m_x, m_y)$ and $(-m_x, -m_y)$ (where negative indices are interpreted modulo $N$). This prescription correctly handles all mode types, including DC, Nyquist, and off-axis modes, and is consistent with the `numpy.fft` inverse transform normalization, which includes a factor of $1/N^2$.\n\nWith the ground-truth $\\tilde{\\kappa}_{\\rm true}(\\boldsymbol{\\ell})$ defined, we compute the ground-truth Fourier-space deflection field $\\tilde{\\boldsymbol{\\alpha}}_{\\rm true}(\\boldsymbol{\\ell})$ using the provided relation:\n$$\n\\tilde{\\boldsymbol{\\alpha}}(\\boldsymbol{\\ell}) = -2i \\frac{\\boldsymbol{\\ell}}{\\ell^2}\\, \\tilde{\\kappa}(\\boldsymbol{\\ell})\n$$\nThe singularity at $\\ell = 0$ is handled by setting $\\tilde{\\boldsymbol{\\alpha}}(\\boldsymbol{0}) = \\boldsymbol{0}$, as specified. Numerically, we compute a grid for $1/\\ell^2$ and set its value at the origin to $0$. We then apply an inverse $2$D FFT to $\\tilde{\\boldsymbol{\\alpha}}_{\\rm true}(\\boldsymbol{\\ell})$ to obtain the real-space ground-truth deflection field, $\\boldsymbol{\\alpha}_{\\rm true}(\\boldsymbol{\\theta})$. We take the real part of the result to discard negligible imaginary components arising from floating-point inaccuracies.\n\nThird, we simulate the observation, which is convolved with the CIC kernel. This convolution in real space is a multiplication by a window function $W_{\\rm CIC}(\\boldsymbol{\\ell})$ in Fourier space. We compute the CIC window function on the discrete frequency grid:\n$$\nW_{\\rm CIC}(\\boldsymbol{\\ell}) = \\left[\\operatorname{sinc}\\left(\\frac{\\ell_x \\Delta\\theta}{2}\\right)\\right]^2 \\left[\\operatorname{sinc}\\left(\\frac{\\ell_y \\Delta\\theta}{2}\\right)\\right]^2,\n$$\nwhere $\\operatorname{sinc}(x) = (\\sin x)/x$. A safe implementation is used to handle the $x=0$ case where $\\operatorname{sinc}(0)=1$. The CIC-convolved convergence map in Fourier space is then $\\tilde{\\kappa}_{\\rm CIC}(\\boldsymbol{\\ell}) = \\tilde{\\kappa}_{\\rm true}(\\boldsymbol{\\ell}) W_{\\rm CIC}(\\boldsymbol{\\ell})$.\n\nFourth, we perform the deconvolution and reconstruction. To recover an estimate of the true convergence, we deconvolve the CIC window. This corresponds to a division in Fourier space:\n$$\n\\tilde{\\kappa}_{\\rm rec}(\\boldsymbol{\\ell}) = \\frac{\\tilde{\\kappa}_{\\rm CIC}(\\boldsymbol{\\ell})}{W_{\\rm CIC}(\\boldsymbol{\\ell})}\n$$\nTo prevent numerical instability from division by zero or very small numbers, we implement the specified thresholding method. For any mode where $W_{\\rm CIC}(\\boldsymbol{\\ell}) \\le \\epsilon$ (with $\\epsilon=10^{-15}$), we set the reconstructed coefficient $\\tilde{\\kappa}_{\\rm rec}(\\boldsymbol{\\ell})$ to $0$. From this deconvolved $\\tilde{\\kappa}_{\\rm rec}(\\boldsymbol{\\ell})$, we reconstruct the deflection field $\\boldsymbol{\\alpha}_{\\rm rec}(\\boldsymbol{\\theta})$ using the same Fourier-space method used for the ground truth.\n\nFinally, we quantify the accuracy of the reconstruction by computing the root-mean-square error (RMSE) between the reconstructed and true deflection fields. The RMSE is calculated over all $N^2$ pixels as:\n$$\n{\\rm RMSE} = \\left[\\frac{1}{N^2}\\sum_{p=1}^{N^2} \\left( \\|\\boldsymbol{\\alpha}_{\\rm rec}^{(p)} - \\boldsymbol{\\alpha}_{\\rm true}^{(p)}\\| \\right)^2 \\right]^{1/2}\n$$\nThis calculation is performed for each of the three test cases, and the results are formatted to the specified precision. For the test cases given, since the ground truth consists of single modes and there is no noise, the deconvolution should be nearly perfect, and the resulting RMSE should be very close to zero, limited only by floating-point precision. The case with $A=0$ should yield an RMSE of exactly $0$.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the gravitational lensing deconvolution and reconstruction problem\n    for the specified test cases.\n    \"\"\"\n    test_cases = [\n        # (N, Theta_box, mode_indices, A)\n        {'N': 64, 'Theta_box': 0.5, 'mode_indices': (5, 7), 'A': 1e-2},\n        {'N': 64, 'Theta_box': 0.5, 'mode_indices': (31, 0), 'A': 1e-2},\n        {'N': 64, 'Theta_box': 0.5, 'mode_indices': (0, 0), 'A': 0.0},\n    ]\n\n    results = []\n    epsilon = 1e-15\n\n    for case in test_cases:\n        N = case['N']\n        Theta_box = case['Theta_box']\n        mode_indices = case['mode_indices']\n        A = case['A']\n\n        # Step 1: Setup Grids (Real and Fourier)\n        Delta_theta = Theta_box / N\n        \n        # 1D frequencies and wavenumbers (multipoles)\n        freqs_1d = np.fft.fftfreq(N, d=Delta_theta)\n        ells_1d = 2.0 * np.pi * freqs_1d\n        \n        # 2D grids for wavenumbers\n        ell_x, ell_y = np.meshgrid(ells_1d, ells_1d, indexing='ij')\n        ell_sq = ell_x**2 + ell_y**2\n\n        # Step 2: Generate Ground-Truth Fields\n        # 2a. Ground-truth convergence in Fourier space (kappa_tilde_true)\n        mx, my = mode_indices\n        kappa_tilde_true = np.zeros((N, N), dtype=np.complex128)\n        \n        # Per problem spec, this normalization gives a cosine of peak amplitude A\n        val = A * N**2 / 2.0\n        \n        # Add contributions for mode (mx, my) and its conjugate (-mx, -my)\n        # numpy's += on the same index will correctly sum contributions for DC/Nyquist\n        kappa_tilde_true[mx, my] += val\n        kappa_tilde_true[-mx, -my] += val\n\n        # 2b. Ground-truth deflection field (alpha_true)\n        # We need 1/ell^2, handle ell=0 safely\n        inv_ell_sq = np.zeros_like(ell_sq)\n        nonzero_mask = ell_sq != 0\n        inv_ell_sq[nonzero_mask] = 1.0 / ell_sq[nonzero_mask]\n        \n        # alpha_tilde = -2i * l/l^2 * kappa_tilde\n        alpha_tilde_true_x = -2.0j * ell_x * inv_ell_sq * kappa_tilde_true\n        alpha_tilde_true_y = -2.0j * ell_y * inv_ell_sq * kappa_tilde_true\n\n        # Transform to real space\n        alpha_true_x = np.fft.ifft2(alpha_tilde_true_x).real\n        alpha_true_y = np.fft.ifft2(alpha_tilde_true_y).real\n\n        # Step 3: Simulate CIC-convolved field\n        # 3a. CIC window function W_cic\n        def safe_sinc(x):\n            # sinc(x) = sin(x)/x\n            s = np.ones_like(x, dtype=float)\n            mask = x != 0\n            s[mask] = np.sin(x[mask]) / x[mask]\n            return s\n\n        arg_x = ell_x * Delta_theta / 2.0\n        arg_y = ell_y * Delta_theta / 2.0\n        \n        W_cic = (safe_sinc(arg_x)**2) * (safe_sinc(arg_y)**2)\n        \n        # 3b. Apply CIC window to get kappa_tilde_cic\n        kappa_tilde_cic = kappa_tilde_true * W_cic\n        \n        # Step 4: Deconvolve and Reconstruct\n        # 4a. Deconvolve CIC kernel\n        kappa_tilde_rec = np.zeros_like(kappa_tilde_cic)\n        deconv_mask = W_cic > epsilon\n        kappa_tilde_rec[deconv_mask] = kappa_tilde_cic[deconv_mask] / W_cic[deconv_mask]\n        \n        # 4b. Reconstruct deflection field alpha_rec\n        alpha_tilde_rec_x = -2.0j * ell_x * inv_ell_sq * kappa_tilde_rec\n        alpha_tilde_rec_y = -2.0j * ell_y * inv_ell_sq * kappa_tilde_rec\n\n        # Transform to real space\n        alpha_rec_x = np.fft.ifft2(alpha_tilde_rec_x).real\n        alpha_rec_y = np.fft.ifft2(alpha_tilde_rec_y).real\n\n        # Step 5: Compute RMSE in radians\n        diff_sq_x = (alpha_rec_x - alpha_true_x)**2\n        diff_sq_y = (alpha_rec_y - alpha_true_y)**2\n        \n        mean_sq_err = np.mean(diff_sq_x + diff_sq_y)\n        rmse = np.sqrt(mean_sq_err)\n        \n        results.append(\"{:.9e}\".format(rmse))\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3483297"}]}