{"hands_on_practices": [{"introduction": "The journey of light from a distant galaxy to our telescopes is not a straight line, but a path bent and distorted by the gravitational influence of intervening cosmic structures. This exercise allows you to simulate this process from first principles by implementing and comparing two core numerical methods: a high-accuracy continuous integration of the ray's trajectory and the computationally efficient multiple-lens-plane approximation. Mastering this practice [@problem_id:3502405] provides a foundational tool for creating mock lensing data and develops a deep, physical intuition for how gravitational deflections accumulate along the line of sight.", "problem": "You are asked to implement and validate a numerical method for weak gravitational lensing by comparing a discrete multiple-lens-plane algorithm against a continuous integration approach. The implementation must begin from first principles. Start with null geodesics in a perturbed Friedmann–Lemaître–Robertson–Walker (FLRW) spacetime in the weak-field and small-angle limits, and derive the governing equations that relate the transverse comoving coordinates of a light ray to the Newtonian gravitational potential. Use the Born approximation and restrict to a spatially flat case. Use dimensionless units with the speed of light normalized to $c=1$, the source comoving distance normalized to $\\chi_{\\mathrm{s}}=1$, and angles expressed in radians. All integration should be with respect to the comoving line-of-sight coordinate $\\chi$.\n\nConstruct both of the following, starting from the governing equations you derive:\n- A continuous approach that integrates the light-ray equations of motion for the transverse comoving coordinates as a function of $\\chi$, using a high-accuracy ordinary differential equation solver from first principles, and\n- A multiple-lens-plane method that discretizes the line of sight into $N$ thin planes, applies discrete deflection “kicks” due to the projected gravitational potential at each plane, and drifts the ray between planes. Your multiple-lens-plane update must be second-order accurate in the plane spacing.\n\nUse the following matter distribution as the gravitational potential. In the weak-field regime, approximate the three-dimensional Newtonian gravitational potential as a superposition of $M$ Gaussian lenses,\n$$\n\\Phi(x,y,\\chi) \\equiv \\sum_{j=1}^{M} A_j \\exp\\!\\left(-\\frac{(x-\\mu_{x,j})^2+(y-\\mu_{y,j})^2}{2\\sigma_{t,j}^2}\\right)\\exp\\!\\left(-\\frac{(\\chi-\\chi_{0,j})^2}{2\\sigma_{\\ell,j}^2}\\right),\n$$\nwhere $(x,y)$ are the transverse comoving coordinates, $\\chi$ is the comoving line-of-sight coordinate, $A_j$ are dimensionless amplitudes satisfying the weak-field limit, $(\\mu_{x,j},\\mu_{y,j})$ are transverse centers, $\\sigma_{t,j}$ are transverse widths, $\\chi_{0,j}$ are central line-of-sight positions, and $\\sigma_{\\ell,j}$ are line-of-sight widths. All quantities are dimensionless by construction. You must compute transverse deflections using the transverse gradient $\\nabla_{\\perp}\\Phi(x,y,\\chi)$ of this potential.\n\nImplement both methods under the same initial conditions. At the observer at $\\chi=0$, set the initial transverse position to $x(0)=0$, $y(0)=0$, and the initial ray angle to be the derivative of the transverse comoving position with respect to $\\chi$, namely $x'(0)=\\theta_x$, $y'(0)=\\theta_y$, with angles in radians. Propagate to the source plane at $\\chi=\\chi_{\\mathrm{s}}=1$.\n\nDefine the error metrics for a given test as follows. Let $(x_{\\mathrm{c}},y_{\\mathrm{c}},x'_{\\mathrm{c}},y'_{\\mathrm{c}})$ be the final state from the continuous integration and $(x_{\\mathrm{d}},y_{\\mathrm{d}},x'_{\\mathrm{d}},y'_{\\mathrm{d}})$ be the final state from the multiple-lens-plane method at $\\chi=\\chi_{\\mathrm{s}}$. Report two floats:\n- The absolute position error $e_{\\mathrm{pos}} \\equiv \\sqrt{(x_{\\mathrm{d}}-x_{\\mathrm{c}})^2+(y_{\\mathrm{d}}-y_{\\mathrm{c}})^2}$.\n- The absolute angle error $e_{\\mathrm{ang}} \\equiv \\sqrt{(x'_{\\mathrm{d}}-x'_{\\mathrm{c}})^2+(y'_{\\mathrm{d}}-y'_{\\mathrm{c}})^2}$.\n\nImplement the following test suite. For each test, use the specified Gaussian lens parameters, initial angle, and number of planes $N$ for the discrete method. In all tests, use $\\chi_{\\mathrm{s}}=1$ and $(x(0),y(0))=(0,0)$.\n\n- Test $1$ (multi-clump, moderate $N$):\n  - Lenses: $M=3$ with parameters\n    - $A_1=2.0\\times 10^{-5}$, $\\sigma_{t,1}=0.06$, $\\sigma_{\\ell,1}=0.08$, $(\\mu_{x,1},\\mu_{y,1})=(0.02,-0.015)$, $\\chi_{0,1}=0.30$,\n    - $A_2=3.0\\times 10^{-5}$, $\\sigma_{t,2}=0.05$, $\\sigma_{\\ell,2}=0.06$, $(\\mu_{x,2},\\mu_{y,2})=(-0.015,0.01)$, $\\chi_{0,2}=0.60$,\n    - $A_3=1.5\\times 10^{-5}$, $\\sigma_{t,3}=0.07$, $\\sigma_{\\ell,3}=0.07$, $(\\mu_{x,3},\\mu_{y,3})=(0.0,0.0)$, $\\chi_{0,3}=0.85$.\n  - Initial angle: $(\\theta_x,\\theta_y)=(1.0\\times 10^{-3},\\,0.5\\times 10^{-3})$.\n  - Number of planes: $N=8$.\n\n- Test $2$ (no lensing, boundary case):\n  - Lenses: $M=0$.\n  - Initial angle: $(\\theta_x,\\theta_y)=(1.0\\times 10^{-3},\\,0.5\\times 10^{-3})$.\n  - Number of planes: $N=8$.\n\n- Test $3$ (single axisymmetric lens, coarse $N$):\n  - Lenses: $M=1$ with parameters\n    - $A_1=2.5\\times 10^{-5}$, $\\sigma_{t,1}=0.04$, $\\sigma_{\\ell,1}=0.04$, $(\\mu_{x,1},\\mu_{y,1})=(0.02,0.0)$, $\\chi_{0,1}=0.50$.\n  - Initial angle: $(\\theta_x,\\theta_y)=(8.0\\times 10^{-4},\\,0.0)$.\n  - Number of planes: $N=2$.\n\n- Test $4$ (multi-clump, very coarse $N$):\n  - Same lenses as Test $1$.\n  - Initial angle: $(\\theta_x,\\theta_y)=(1.0\\times 10^{-3},\\,0.5\\times 10^{-3})$.\n  - Number of planes: $N=2$.\n\n- Test $5$ (multi-clump, fine $N$):\n  - Same lenses as Test $1$.\n  - Initial angle: $(\\theta_x,\\theta_y)=(1.0\\times 10^{-3},\\,0.5\\times 10^{-3})$.\n  - Number of planes: $N=64$.\n\nYour program must compute $(e_{\\mathrm{pos}},e_{\\mathrm{ang}})$ for each test and produce a single line of output containing the results as a comma-separated list of lists with no spaces, in the exact format\n\"[[e_pos_1,e_ang_1],[e_pos_2,e_ang_2],...[e_pos_5,e_ang_5]]\".\nAll reported angles are in radians. No physical units are used beyond the specified dimensionless normalization. The final numerical outputs must be floating-point numbers. The program must run without any user input and must not access external files or networks.", "solution": "The user's request is a valid scientific computing problem. It asks for the implementation and comparison of two numerical methods for simulating weak gravitational lensing, based on first principles.\n\n### **1. Derivation of the Governing Equations**\n\nWe begin by deriving the equation of motion for a light ray in a perturbed Friedmann–Lemaître–Robertson–Walker (FLRW) spacetime. For a spatially flat universe, the metric in the Newtonian gauge, including scalar perturbations $\\Phi$, is given by:\n$$ds^2 = a^2(\\eta) [-(1+2\\Phi)d\\eta^2 + (1-2\\Phi)(dx^2+dy^2+dz^2)]$$\nHere, $\\eta$ is the conformal time, $a(\\eta)$ is the scale factor, $(x,y,z)$ are comoving coordinates, and we have set the speed of light $c=1$. The gravitational potential $\\Phi$ is assumed to be small, i.e., $|\\Phi| \\ll 1$ (weak-field limit).\n\nThe path of a light ray is a null geodesic, $ds^2=0$. Let the ray propagate primarily along the $z$-direction. We can use the comoving distance along this axis, $\\chi \\equiv z$, as the path parameter. We describe the ray's path by its transverse coordinates $\\mathbf{x}_{\\perp}(\\chi) = (x(\\chi), y(\\chi))$.\n\nFor a null geodesic, the trajectory is governed by Fermat's principle, which states that light travels along a path of extremal time. The effective refractive index $n$ of the perturbed spacetime is $n(\\mathbf{x}_{\\perp}, \\chi) = 1 - 2\\Phi(\\mathbf{x}_{\\perp}, \\chi)$. The path follows the eikonal equation, which, in the paraxial approximation (small deflection angles), simplifies to the following equation for the transverse displacement $\\mathbf{x}_{\\perp}$:\n$$\\frac{d^2\\mathbf{x}_{\\perp}}{d\\chi^2} = \\nabla_{\\perp} n = -2\\nabla_{\\perp}\\Phi(\\mathbf{x}_{\\perp}(\\chi), \\chi)$$\nwhere $\\nabla_{\\perp} \\equiv (\\partial/\\partial x, \\partial/\\partial y)$ is the two-dimensional transverse gradient operator. This is the fundamental equation of motion we need to solve. It is a second-order ordinary differential equation (ODE) for the transverse position of the light ray as a function of the line-of-sight comoving distance $\\chi$. The term $-2\\nabla_{\\perp}\\Phi$ acts as an acceleration.\n\nThe initial conditions are specified at the observer, $\\chi=0$. The ray originates at the center of the coordinate system, $\\mathbf{x}_{\\perp}(0)=(0,0)$, with an initial angle $\\boldsymbol{\\theta}=(\\theta_x, \\theta_y)$. In our formulation, the angle is the derivative of the transverse position with respect to the comoving distance, a small quantity: $\\frac{d\\mathbf{x}_{\\perp}}{d\\chi}\\bigg|_{\\chi=0} = \\boldsymbol{\\theta}$.\n\n### **2. Gravitational Potential and its Gradient**\n\nThe problem provides a specific model for the 3D Newtonian gravitational potential $\\Phi$ as a sum of $M$ Gaussian distributions:\n$$\\Phi(x,y,\\chi) = \\sum_{j=1}^{M} A_j \\exp\\!\\left(-\\frac{(x-\\mu_{x,j})^2+(y-\\mu_{y,j})^2}{2\\sigma_{t,j}^2}\\right)\\exp\\left(-\\frac{(\\chi-\\chi_{0,j})^2}{2\\sigma_{\\ell,j}^2}\\right)$$\nTo solve the equation of motion, we need the transverse gradient, $\\nabla_{\\perp}\\Phi = (\\frac{\\partial\\Phi}{\\partial x}, \\frac{\\partial\\Phi}{\\partial y})$. Differentiating the potential with respect to $x$ and $y$ gives:\n$$\n\\frac{\\partial\\Phi}{\\partial x} = \\sum_{j=1}^{M} A_j \\left( -\\frac{x-\\mu_{x,j}}{\\sigma_{t,j}^2} \\right) \\exp\\left(-\\frac{(x-\\mu_{x,j})^2+(y-\\mu_{y,j})^2}{2\\sigma_{t,j}^2}\\right)\\exp\\left(-\\frac{(\\chi-\\chi_{0,j})^2}{2\\sigma_{\\ell,j}^2}\\right)\n$$\n$$\n\\frac{\\partial\\Phi}{\\partial y} = \\sum_{j=1}^{M} A_j \\left( -\\frac{y-\\mu_{y,j}}{\\sigma_{t,j}^2} \\right) \\exp\\left(-\\frac{(x-\\mu_{x,j})^2+(y-\\mu_{y,j})^2}{2\\sigma_{t,j}^2}\\right)\\exp\\left(-\\frac{(\\chi-\\chi_{0,j})^2}{2\\sigma_{\\ell,j}^2}\\right)\n$$\nThe acceleration of the light ray is then $\\mathbf{a}(\\chi) = -2\\nabla_{\\perp}\\Phi(\\mathbf{x}_{\\perp}(\\chi), \\chi)$.\n\n### **3. Numerical Algorithms**\n\nWe implement two numerical methods to solve the initial value problem defined by the ODE and initial conditions.\n\n#### **3.1. Continuous Integration Approach**\n\nThis method serves as the high-accuracy \"ground truth\" for comparison. We first rewrite the single second-order ODE as a system of four first-order ODEs. Let the state vector be $\\mathbf{Y}(\\chi) = [x(\\chi), y(\\chi), v_x(\\chi), v_y(\\chi)]^T$, where $\\mathbf{v} = d\\mathbf{x}_{\\perp}/d\\chi$ is the ray's angle (velocity). The system is:\n$$\n\\frac{d\\mathbf{Y}}{d\\chi} = \n\\begin{pmatrix}\nv_x \\\\\nv_y \\\\\na_x(x, y, \\chi) \\\\\na_y(x, y, \\chi)\n\\end{pmatrix}\n=\n\\begin{pmatrix}\nv_x \\\\\nv_y \\\\\n-2 \\frac{\\partial\\Phi}{\\partial x} \\\\\n-2 \\frac{\\partial\\Phi}{\\partial y}\n\\end{pmatrix}\n$$\nThe initial state is $\\mathbf{Y}(0) = [0, 0, \\theta_x, \\theta_y]^T$. We integrate this system from $\\chi=0$ to the source plane at $\\chi_{\\mathrm{s}}=1$. For this purpose, we use a high-accuracy, adaptive step-size Runge-Kutta solver. The Python library `scipy.integrate.solve_ivp` with the `DOP853` method (Dormand-Prince 8(5,3) method) and very strict error tolerances (e.g., $10^{-13}$) is suitable for obtaining a precise reference solution.\n\n#### **3.2. Multiple-Lens-Plane Approach**\n\nThis method discretizes the line of sight into $N$ intervals of equal width $\\Delta\\chi = \\chi_{\\mathrm{s}}/N$. The planes are located at $\\chi_i = i\\Delta\\chi$ for $i=0, ..., N$. The integration proceeds step-by-step, approximating the continuous deflection with discrete \"kicks\" at each plane and \"drifts\" in straight lines between planes.\n\nTo achieve the required second-order accuracy, we employ a symplectic integrator, specifically the Kick-Drift-Kick (KDK) form of the leapfrog algorithm. The positions $\\mathbf{x}_{\\perp,i}$ are defined at integer steps $\\chi_i$, while the velocities (angles) $\\mathbf{v}_i$ are staggered and defined at half-steps $\\chi_{i-1/2}$.\n\nThe algorithm proceeds as follows, starting with state $(\\mathbf{x}_0, \\mathbf{v}_0)$ at $\\chi_0 = 0$:\n\n1.  **Initial Half-Kick:** Advance the velocity by a half-step. The acceleration $\\mathbf{a}_0$ is computed at the initial position $\\mathbf{x}_0$.\n    $$\\mathbf{v}_{1/2} = \\mathbf{v}_0 + \\mathbf{a}(\\mathbf{x}_0, \\chi_0)\\frac{\\Delta\\chi}{2}$$\n2.  **Main Loop (for $i=0, \\dots, N-1$):**\n    a. **Full Drift:** Update the position using the half-step velocity.\n       $$\\mathbf{x}_{i+1} = \\mathbf{x}_i + \\mathbf{v}_{i+1/2}\\Delta\\chi$$\n    b. **Full Kick:** Compute acceleration $\\mathbf{a}_{i+1}$ at the new position $\\mathbf{x}_{i+1}$ and plane $\\chi_{i+1}$, then update the velocity for the next half-step.\n       $$\\mathbf{v}_{i+3/2} = \\mathbf{v}_{i+1/2} + \\mathbf{a}(\\mathbf{x}_{i+1}, \\chi_{i+1})\\Delta\\chi$$\n3.  **Final Half-Kick:** After the loop, we have the final position $\\mathbf{x}_N$ and the half-step velocity $\\mathbf{v}_{N+1/2}$. To find the final velocity at the integer step $\\chi_N$, we perform one last half-kick correction.\n    $$\\mathbf{v}_N = \\mathbf{v}_{N-1/2} + \\mathbf{a}(\\mathbf{x}_N, \\chi_N)\\frac{\\Delta\\chi}{2} = \\mathbf{v}_{N+1/2} - \\mathbf{a}(\\mathbf{x}_N, \\chi_N)\\frac{\\Delta\\chi}{2}$$\n\nThis KDK scheme is symplectic, time-reversible, and second-order accurate in the step size $\\Delta\\chi$.\n\n### **4. Error Evaluation**\n\nThe accuracy of the multiple-lens-plane method is quantified by comparing its final state $(x_{\\mathrm{d}}, y_{\\mathrm{d}}, v_{x,\\mathrm{d}}, v_{y,\\mathrm{d}})$ at $\\chi=\\chi_{\\mathrm{s}}$ against the high-accuracy continuous solution $(x_{\\mathrm{c}}, y_{\\mathrm{c}}, v_{x,\\mathrm{c}}, v_{y,\\mathrm{c}})$. Two error metrics are calculated:\n-   **Position Error:** The Euclidean distance between the final positions.\n    $$e_{\\mathrm{pos}} = \\sqrt{(x_{\\mathrm{d}}-x_{\\mathrm{c}})^2+(y_{\\mathrm{d}}-y_{\\mathrm{c}})^2}$$\n-   **Angle Error:** The Euclidean distance between the final angles (velocities).\n    $$e_{\\mathrm{ang}} = \\sqrt{(v_{x,\\mathrm{d}}-v_{x,\\mathrm{c}})^2+(v_{y,\\mathrm{d}}-v_{y,\\mathrm{c}})^2}$$\n\nThe implementation will execute the test suite, calculating these two error metrics for each case, and present the results in the specified format.", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Implements and validates a numerical method for weak gravitational lensing\n    by comparing a discrete multiple-lens-plane algorithm against a continuous\n    integration approach.\n    \"\"\"\n\n    # Lens parameters for Test 1/4/5\n    lenses_test1 = [\n        {'A': 2.0e-5, 'sigma_t': 0.06, 'sigma_l': 0.08, 'mu_x': 0.02, 'mu_y': -0.015, 'chi_0': 0.30},\n        {'A': 3.0e-5, 'sigma_t': 0.05, 'sigma_l': 0.06, 'mu_x': -0.015, 'mu_y': 0.01, 'chi_0': 0.60},\n        {'A': 1.5e-5, 'sigma_t': 0.07, 'sigma_l': 0.07, 'mu_x': 0.0, 'mu_y': 0.0, 'chi_0': 0.85},\n    ]\n\n    # Lens parameters for Test 3\n    lenses_test3 = [\n        {'A': 2.5e-5, 'sigma_t': 0.04, 'sigma_l': 0.04, 'mu_x': 0.02, 'mu_y': 0.0, 'chi_0': 0.50}\n    ]\n\n    test_cases = [\n        # Test 1: multi-clump, moderate N\n        (lenses_test1, (1.0e-3, 0.5e-3), 8),\n        # Test 2: no lensing, boundary case\n        ([], (1.0e-3, 0.5e-3), 8),\n        # Test 3: single axisymmetric lens, coarse N\n        (lenses_test3, (8.0e-4, 0.0), 2),\n        # Test 4: multi-clump, very coarse N\n        (lenses_test1, (1.0e-3, 0.5e-3), 2),\n        # Test 5: multi-clump, fine N\n        (lenses_test1, (1.0e-3, 0.5e-3), 64),\n    ]\n\n    def grad_perp_phi(x: float, y: float, chi: float, lenses: list) -> np.ndarray:\n        \"\"\"Computes the transverse gradient of the gravitational potential Phi.\"\"\"\n        grad_x = 0.0\n        grad_y = 0.0\n        for lens in lenses:\n            A, sigma_t, sigma_l, mu_x, mu_y, chi_0 = lens.values()\n            \n            sigma_t2 = sigma_t**2\n            sigma_l2 = sigma_l**2\n            \n            dx = x - mu_x\n            dy = y - mu_y\n            dchi = chi - chi_0\n            \n            arg_trans = (dx**2 + dy**2) / (2 * sigma_t2)\n            arg_los = dchi**2 / (2 * sigma_l2)\n            \n            # Avoid numerical issues with large arguments to exp\n            if arg_trans > 50.0 or arg_los > 50.0:\n                continue\n\n            exp_trans = np.exp(-arg_trans)\n            exp_los = np.exp(-arg_los)\n            \n            common_factor = A * exp_trans * exp_los\n            \n            grad_x += common_factor * (-dx / sigma_t2)\n            grad_y += common_factor * (-dy / sigma_t2)\n            \n        return np.array([grad_x, grad_y])\n\n    def ode_system(chi: float, state: np.ndarray, lenses: list) -> list:\n        \"\"\"\n        Defines the ODE system dY/dchi = f(chi, Y) for the light ray trajectory.\n        state = [x, y, v_x, v_y]\n        \"\"\"\n        x, y, vx, vy = state\n        grad = grad_perp_phi(x, y, chi, lenses)\n        ax = -2.0 * grad[0]\n        ay = -2.0 * grad[1]\n        return [vx, vy, ax, ay]\n\n    def multiple_lens_plane_solver(lenses: list, initial_conditions: list, N: int, chi_s: float = 1.0):\n        \"\"\"\n        Solves the light ray trajectory using a second-order accurate\n        Kick-Drift-Kick (KDK) leapfrog integrator.\n        \"\"\"\n        delta_chi = chi_s / N\n        x0, y0, vx0, vy0 = initial_conditions\n        \n        pos = np.array([x0, y0], dtype=np.float64)\n        vel = np.array([vx0, vy0], dtype=np.float64)\n        chi = 0.0\n        \n        # Initial half-kick\n        accel = -2.0 * grad_perp_phi(pos[0], pos[1], chi, lenses)\n        vel_half = vel + accel * delta_chi / 2.0\n        \n        # Main loop: N steps of drift and kick\n        for i in range(N):\n            # Full drift\n            pos += vel_half * delta_chi\n            \n            # Update chi to the new plane position\n            chi = (i + 1) * delta_chi\n            \n            # Calculate acceleration at the new position\n            accel = -2.0 * grad_perp_phi(pos[0], pos[1], chi, lenses)\n            \n            # Full kick\n            vel_half += accel * delta_chi\n        \n        # Final half-kick to bring velocity to integer step\n        final_vel = vel_half - accel * delta_chi / 2.0\n          \n        return pos[0], pos[1], final_vel[0], final_vel[1]\n\n    results = []\n    \n    for case in test_cases:\n        lenses, initial_angle, N = case\n        \n        y0 = [0.0, 0.0, initial_angle[0], initial_angle[1]]\n        chi_s = 1.0\n\n        # Continuous approach using a high-accuracy ODE solver\n        sol_c = solve_ivp(\n            ode_system, \n            [0, chi_s], \n            y0, \n            args=(lenses,), \n            method='DOP853', \n            rtol=1e-13, \n            atol=1e-13\n        )\n        x_c, y_c, vx_c, vy_c = sol_c.y[:, -1]\n\n        # Multiple-lens-plane approach\n        x_d, y_d, vx_d, vy_d = multiple_lens_plane_solver(lenses, y0, N, chi_s)\n        \n        # Calculate error metrics\n        e_pos = np.sqrt((x_d - x_c)**2 + (y_d - y_c)**2)\n        e_ang = np.sqrt((vx_d - vx_c)**2 + (vy_d - vy_c)**2)\n        \n        results.append([e_pos, e_ang])\n    \n    output_str = \"[\" + \",\".join([f\"[{e[0]},{e[1]}]\" for e in results]) + \"]\"\n\n    print(output_str)\n\nsolve()\n```", "id": "3502405"}, {"introduction": "Gravitational lensing manifests as a subtle distortion in the observed shapes of background galaxies, a signal we must meticulously measure. However, every astronomical image is blurred by the instrument's Point Spread Function (PSF), which corrupts the intrinsic galaxy shape and mimics a lensing signal. This practice [@problem_id:3502401] guides you through building a forward model to quantify how the PSF contaminates shape measurements, leading to the critical concepts of additive ($\\boldsymbol{c}$) and multiplicative ($\\boldsymbol{m}$) shear bias, which are central to the calibration of all modern weak lensing surveys.", "problem": "You are asked to build a principled forward model for how Point Spread Function (PSF) convolution and PSF anisotropy affect galaxy shape measurements in weak gravitational lensing, and to derive the residual shear bias after applying a naive PSF correction in the second-moment domain. All quantities are to be treated as dimensionless, with lengths expressed in pixel units.\n\nBegin from the following fundamental base, without using any domain-specific shortcut formulas:\n\n- The observed surface brightness field is the convolution of an intrinsic source surface brightness with the telescope Point Spread Function (PSF). If the intrinsic galaxy brightness is denoted by $I(\\boldsymbol{x})$ and the PSF by $P(\\boldsymbol{x})$, then the observed image is $I_{\\mathrm{obs}}(\\boldsymbol{x}) = \\int d^{2}\\boldsymbol{x}'\\, I(\\boldsymbol{x}') P(\\boldsymbol{x} - \\boldsymbol{x}')$.\n\n- The second central moment tensor of an image $I(\\boldsymbol{x})$ with a weight $W(\\boldsymbol{x})$ is defined by\n$$\n\\mathbf{Q} = \\frac{\\int d^{2}\\boldsymbol{x}\\, W(\\boldsymbol{x})\\, I(\\boldsymbol{x})\\, \\boldsymbol{x}\\,\\boldsymbol{x}^{\\mathsf{T}}}{\\int d^{2}\\boldsymbol{x}\\, W(\\boldsymbol{x})\\, I(\\boldsymbol{x})}\\,,\n$$\nwith the centroid fixed to the origin. For a two-dimensional positive-definite symmetric matrix $\\mathbf{Q}$ with trace $T = \\mathrm{Tr}(\\mathbf{Q})$, define an ellipticity estimator by\n$$\ne_{1} = \\frac{Q_{11} - Q_{22}}{T}\\,, \\quad e_{2} = \\frac{2 Q_{12}}{T}\\,.\n$$\n\n- The reduced shear with components $\\boldsymbol{g} = (g_{1}, g_{2})$ in the absence of convergence $\\kappa$ is related to the Jacobian of the lens mapping. For small shear, a circular source of size $s$ (in pixels) with covariance $\\mathbf{S}_{\\mathrm{s}} = s^{2}\\,\\mathbf{I}_{2}$ is mapped to an observed, pre-PSF galaxy covariance $\\mathbf{S}_{\\mathrm{g}}$ according to\n$$\n\\mathbf{S}_{\\mathrm{g}} \\approx \\mathbf{S}_{\\mathrm{s}} + \\boldsymbol{\\Gamma}\\, \\mathbf{S}_{\\mathrm{s}} + \\mathbf{S}_{\\mathrm{s}}\\, \\boldsymbol{\\Gamma}\\,,\n$$\nwhere\n$$\n\\boldsymbol{\\Gamma} = \\begin{pmatrix} g_{1} & g_{2} \\\\ g_{2} & -g_{1} \\end{pmatrix}\\,.\n$$\n\n- You will measure weighted moments using a fixed circular Gaussian weight of covariance $\\mathbf{S}_{\\mathrm{w}} = s_{\\mathrm{w}}^{2}\\, \\mathbf{I}_{2}$, where $s_{\\mathrm{w}}$ is specified.\n\n- The PSF is modeled as an elliptical Gaussian with covariance $\\mathbf{S}_{\\mathrm{p}}$ constrained to have a specified trace $T_{\\mathrm{p}} = 2 s_{\\mathrm{p}}^{2}$ and ellipticity components $(e_{1,\\mathrm{p}}, e_{2,\\mathrm{p}})$ defined by\n$$\ne_{1,\\mathrm{p}} = \\frac{(S_{\\mathrm{p}})_{11} - (S_{\\mathrm{p}})_{22}}{\\mathrm{Tr}(\\mathbf{S}_{\\mathrm{p}})}\\,, \\quad e_{2,\\mathrm{p}} = \\frac{2(S_{\\mathrm{p}})_{12}}{\\mathrm{Tr}(\\mathbf{S}_{\\mathrm{p}})}\\,.\n$$\nAssume $ \\sqrt{e_{1,\\mathrm{p}}^{2} + e_{2,\\mathrm{p}}^{2}} < 1 $ to ensure that $ \\mathbf{S}_{\\mathrm{p}} $ is positive definite.\n\nTasks:\n\n1. Derive, from first principles using the Gaussian product and convolution identities, an explicit expression for the weighted second-moment tensor of the convolved image in terms of the galaxy covariance, the PSF covariance, and the weight covariance, assuming Gaussian models for galaxy, PSF, and weight. Justify every step by appealing only to the definitions above and general Gaussian integral identities.\n\n2. Define a naive PSF correction in moment space by subtracting the weighted PSF moment tensor from the weighted observed moment tensor. Using that corrected tensor, define the ellipticity estimator $(e_{1}, e_{2})$ and the corresponding shear estimator $\\hat{\\boldsymbol{g}} = \\frac{1}{2} (e_{1}, e_{2})$.\n\n3. Define the additive bias vector $\\boldsymbol{c} = (c_{1}, c_{2})$ as the shear estimator obtained when the true shear is $\\boldsymbol{g} = (0, 0)$, and define the component-wise multiplicative bias $\\boldsymbol{m} = (m_{1}, m_{2})$ for a nonzero true shear $\\boldsymbol{g}$ by\n$$\nm_{i} = \\frac{\\hat{g}_{i} - c_{i}}{g_{i}} - 1\\,, \\quad i \\in \\{1,2\\}\\,,\n$$\nwhere division is performed component-wise. Explain why these definitions capture residual bias after PSF correction.\n\n4. Implement a program that, for each test case below, computes the pair $(\\boldsymbol{m}, \\boldsymbol{c})$ using the forward model you derived. For each test case, your program must internally evaluate the zero-shear case $\\boldsymbol{g} = (0, 0)$ in order to compute $\\boldsymbol{c}$ for that test case, and then compute $\\boldsymbol{m}$ for the provided nonzero $\\boldsymbol{g}$. All lengths are in pixels. Report the final results as decimal floats rounded to six digits after the decimal point.\n\nTest suite (each entry specifies $(s, s_{\\mathrm{p}}, e_{1,\\mathrm{p}}, e_{2,\\mathrm{p}}, s_{\\mathrm{w}}, g_{1}, g_{2})$):\n\n- Case $1$: $(s, s_{\\mathrm{p}}, e_{1,\\mathrm{p}}, e_{2,\\mathrm{p}}, s_{\\mathrm{w}}, g_{1}, g_{2}) = (\\,$ $1.2$, $0.7$, $0.08$, $0.02$, $1.0$, $0.02$, $-0.01$ $\\,)$\n- Case $2$: $(\\,$ $1.2$, $0.6$, $0.0$, $0.0$, $0.8$, $0.02$, $-0.01$ $\\,)$\n- Case $3$: $(\\,$ $0.8$, $1.3$, $0.12$, $-0.05$, $1.0$, $0.02$, $-0.01$ $\\,)$\n- Case $4$: $(\\,$ $1.5$, $0.3$, $0.10$, $0.0$, $0.7$, $0.02$, $-0.01$ $\\,)$\n\nNumerical and algorithmic requirements:\n\n- All matrix operations must be performed exactly as implied by your derivation. Assume all images are Gaussian and centered.\n- Angles, if any arise in your reasoning, must be in radians. However, the implementation should not require explicit angles because ellipticity components are directly specified.\n- Output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For each case in order, append the four floats $[m_{1}, m_{2}, c_{1}, c_{2}]$, rounded to six digits after the decimal point. Thus, the final output will contain $4 \\times 4 = 16$ comma-separated floats inside one bracketed list.", "solution": "The problem requires the derivation of a forward model for PSF-convolved galaxy shape measurements and the subsequent calculation of shear measurement biases. We will proceed by first deriving the necessary analytical expressions from first principles and then implementing them numerically.\n\n### 1. Derivation of the Weighted Second-Moment Tensor\n\nThe first task is to derive an expression for the weighted second-moment tensor, $\\mathbf{Q}_{\\mathrm{obs}}$, of an observed galaxy image. The problem statement provides the foundational definitions and assumptions:\n- The observed image, $I_{\\mathrm{obs}}(\\boldsymbol{x})$, is the convolution of the intrinsic (lensed) galaxy surface brightness, $I(\\boldsymbol{x})$, and the Point Spread Function (PSF), $P(\\boldsymbol{x})$: $I_{\\mathrm{obs}}(\\boldsymbol{x}) = (I * P)(\\boldsymbol{x})$.\n- The intrinsic galaxy, PSF, and measurement weight function, $W(\\boldsymbol{x})$, are all modeled as centered multivariate Gaussian functions.\n- The weighted second-moment tensor of a general image $F(\\boldsymbol{x})$ is defined as:\n$$\n\\mathbf{Q}_{F} = \\frac{\\int d^{2}\\boldsymbol{x}\\, W(\\boldsymbol{x})\\, F(\\boldsymbol{x})\\, \\boldsymbol{x}\\,\\boldsymbol{x}^{\\mathsf{T}}}{\\int d^{2}\\boldsymbol{x}\\, W(\\boldsymbol{x})\\, F(\\boldsymbol{x})}\n$$\nwhere the centroid is at the origin, $\\boldsymbol{x} = (x_1, x_2)^{\\mathsf{T}}$.\n\nLet the un-normalized Gaussian forms for the intrinsic galaxy, PSF, and weight function be:\n- $I(\\boldsymbol{x}) \\propto \\exp(-\\frac{1}{2} \\boldsymbol{x}^{\\mathsf{T}} \\mathbf{S}_{\\mathrm{g}}^{-1} \\boldsymbol{x})$, where $\\mathbf{S}_{\\mathrm{g}}$ is the galaxy covariance matrix.\n- $P(\\boldsymbol{x}) \\propto \\exp(-\\frac{1}{2} \\boldsymbol{x}^{\\mathsf{T}} \\mathbf{S}_{\\mathrm{p}}^{-1} \\boldsymbol{x})$, where $\\mathbf{S}_{\\mathrm{p}}$ is the PSF covariance matrix.\n- $W(\\boldsymbol{x}) \\propto \\exp(-\\frac{1}{2} \\boldsymbol{x}^{\\mathsf{T}} \\mathbf{S}_{\\mathrm{w}}^{-1} \\boldsymbol{x})$, where $\\mathbf{S}_{\\mathrm{w}}$ is the weight function covariance matrix.\n\nA fundamental property of Gaussian distributions is that the convolution of two Gaussians is another Gaussian. The covariance of the resulting Gaussian is the sum of the individual covariances. Therefore, the observed image $I_{\\mathrm{obs}} = I * P$ is also a centered Gaussian with covariance $\\mathbf{S}_{\\mathrm{obs}} = \\mathbf{S}_{\\mathrm{g}} + \\mathbf{S}_{\\mathrm{p}}$:\n$$\nI_{\\mathrm{obs}}(\\boldsymbol{x}) \\propto \\exp\\left(-\\frac{1}{2} \\boldsymbol{x}^{\\mathsf{T}} (\\mathbf{S}_{\\mathrm{g}} + \\mathbf{S}_{\\mathrm{p}})^{-1} \\boldsymbol{x}\\right)\n$$\n\nWe now evaluate the integrals in the definition of $\\mathbf{Q}_{\\mathrm{obs}}$. The term in the integrands is the product of two Gaussians, $W(\\boldsymbol{x})$ and $I_{\\mathrm{obs}}(\\boldsymbol{x})$. The product of two centered Gaussians with covariances $\\mathbf{A}$ and $\\mathbf{B}$ is another un-normalized centered Gaussian:\n$$\n\\exp\\left(-\\frac{1}{2} \\boldsymbol{x}^{\\mathsf{T}} \\mathbf{A}^{-1} \\boldsymbol{x}\\right) \\exp\\left(-\\frac{1}{2} \\boldsymbol{x}^{\\mathsf{T}} \\mathbf{B}^{-1} \\boldsymbol{x}\\right) = \\exp\\left(-\\frac{1}{2} \\boldsymbol{x}^{\\mathsf{T}} (\\mathbf{A}^{-1} + \\mathbf{B}^{-1}) \\boldsymbol{x}\\right)\n$$\nThe covariance of this product distribution is $(\\mathbf{A}^{-1} + \\mathbf{B}^{-1})^{-1}$. In our case, $\\mathbf{A}=\\mathbf{S}_{\\mathrm{obs}}$ and $\\mathbf{B}=\\mathbf{S}_{\\mathrm{w}}$. So, the product $W(\\boldsymbol{x}) I_{\\mathrm{obs}}(\\boldsymbol{x})$ is a Gaussian with covariance $\\mathbf{S}_{\\mathrm{eff}} = ((\\mathbf{S}_{\\mathrm{g}} + \\mathbf{S}_{\\mathrm{p}})^{-1} + \\mathbf{S}_{\\mathrm{w}}^{-1})^{-1}$.\n\nThe definition of $\\mathbf{Q}_{\\mathrm{obs}}$ can be rewritten as the second central moment of the product distribution $p_{\\mathrm{prod}}(\\boldsymbol{x}) \\propto W(\\boldsymbol{x}) I_{\\mathrm{obs}}(\\boldsymbol{x})$. For any centered probability distribution $p(\\boldsymbol{x})$ with total integral $\\int p(\\boldsymbol{x}) d^2\\boldsymbol{x} = K$, its covariance matrix $\\mathbf{C}$ is given by $\\mathbf{C} = \\frac{1}{K} \\int p(\\boldsymbol{x}) \\boldsymbol{x}\\boldsymbol{x}^{\\mathsf{T}} d^2\\boldsymbol{x}$.\nComparing this with the definition of $\\mathbf{Q}_{\\mathrm{obs}}$, we see that $\\mathbf{Q}_{\\mathrm{obs}}$ is precisely the covariance matrix of the product distribution $W(\\boldsymbol{x})I_{\\mathrm{obs}}(\\boldsymbol{x})$. Therefore:\n$$\n\\mathbf{Q}_{\\mathrm{obs}} = ((\\mathbf{S}_{\\mathrm{g}} + \\mathbf{S}_{\\mathrm{p}})^{-1} + \\mathbf{S}_{\\mathrm{w}}^{-1})^{-1}\n$$\nThis is the required expression for the weighted second-moment tensor of the convolved image.\n\n### 2. Naive PSF Correction and Shear Estimation\n\nThe problem defines a naive PSF correction in moment space as the subtraction of the weighted PSF moment tensor, $\\mathbf{Q}_{\\mathrm{p}}$, from the weighted observed moment tensor, $\\mathbf{Q}_{\\mathrm{obs}}$. The tensor $\\mathbf{Q}_{\\mathrm{p}}$ is the weighted second moment of the PSF itself. By direct analogy to the derivation above (setting the image to be $P(\\boldsymbol{x})$ with covariance $\\mathbf{S}_{\\mathrm{p}}$), we find:\n$$\n\\mathbf{Q}_{\\mathrm{p}} = (\\mathbf{S}_{\\mathrm{p}}^{-1} + \\mathbf{S}_{\\mathrm{w}}^{-1})^{-1}\n$$\nThe \"PSF-corrected\" moment tensor is thus:\n$$\n\\mathbf{Q}_{\\mathrm{corr}} = \\mathbf{Q}_{\\mathrm{obs}} - \\mathbf{Q}_{\\mathrm{p}} = ((\\mathbf{S}_{\\mathrm{g}} + \\mathbf{S}_{\\mathrm{p}})^{-1} + \\mathbf{S}_{\\mathrm{w}}^{-1})^{-1} - (\\mathbf{S}_{\\mathrm{p}}^{-1} + \\mathbf{S}_{\\mathrm{w}}^{-1})^{-1}\n$$\nThis correction is termed \"naive\" because it incorrectly assumes that moments add linearly, which is not true for weighted moments. A proper deconvolution would be more complex.\n\nFrom this corrected tensor $\\mathbf{Q}_{\\mathrm{corr}}$, we define the ellipticity estimator $(e_1, e_2)$ and the shear estimator $\\hat{\\boldsymbol{g}} = (\\hat{g}_1, \\hat{g}_2)$:\n- Let $T_{\\mathrm{corr}} = \\mathrm{Tr}(\\mathbf{Q}_{\\mathrm{corr}})$.\n- $e_1 = \\frac{(\\mathbf{Q}_{\\mathrm{corr}})_{11} - (\\mathbf{Q}_{\\mathrm{corr}})_{22}}{T_{\\mathrm{corr}}}$\n- $e_2 = \\frac{2(\\mathbf{Q}_{\\mathrm{corr}})_{12}}{T_{\\mathrm{corr}}}$\n- $\\hat{\\boldsymbol{g}} = (\\hat{g}_1, \\hat{g}_2) = \\frac{1}{2}(e_1, e_2) = \\left( \\frac{(\\mathbf{Q}_{\\mathrm{corr}})_{11} - (\\mathbf{Q}_{\\mathrm{corr}})_{22}}{2 T_{\\mathrm{corr}}}, \\frac{(\\mathbf{Q}_{\\mathrm{corr}})_{12}}{T_{\\mathrm{corr}}} \\right)$\n\n### 3. Bias Definition and Interpretation\n\nShear measurement biases quantify systematic errors in the estimator $\\hat{\\boldsymbol{g}}$. They are typically decomposed into an additive component $\\boldsymbol{c}$ and a multiplicative component $\\boldsymbol{m}$.\n\n- **Additive Bias $\\boldsymbol{c}$**: This is defined as the shear estimated when the true shear is zero, $\\boldsymbol{g}=(0,0)$.\n$$\n\\boldsymbol{c} = \\hat{\\boldsymbol{g}}|_{\\boldsymbol{g}=(0,0)}\n$$\nWhen $\\boldsymbol{g}=(0,0)$, the intrinsic galaxy is circular, $\\mathbf{S}_{\\mathrm{g}} = s^2 \\mathbf{I}_2$. If the PSF is anisotropic ($\\mathbf{S}_{\\mathrm{p}}$ not a multiple of $\\mathbf{I}_2$), it will induce an ellipticity in the observed image. The naive correction scheme does not perfectly remove this induced ellipticity, resulting in a non-zero estimated shear $\\hat{\\boldsymbol{g}}$. This residual signal is the additive bias.\n\n- **Multiplicative Bias $\\boldsymbol{m}$**: This characterizes the error in the estimator's response to a true, non-zero shear, after accounting for the additive bias. It is defined component-wise:\n$$\nm_{i} = \\frac{\\hat{g}_{i} - c_{i}}{g_{i}} - 1, \\quad i \\in \\{1,2\\}\n$$\nThis can be rearranged to $\\hat{g}_i = (1+m_i)g_i + c_i$. An ideal estimator would have a response of $1$ (i.e., $\\hat{g}_i = g_i$) after correction for additive bias, resulting in $m_i=0$. A non-zero $m_i$ indicates that the estimated shear is a biased multiple of the true shear. Convolution with the PSF tends to make objects appear larger and rounder, which 'dilutes' the shear signal, typically leading to a negative multiplicative bias ($m_i < 0$).\n\n### 4. Algorithmic Implementation Plan\n\nTo compute $(\\boldsymbol{m}, \\boldsymbol{c})$ for each test case, we perform the following steps:\n\n1.  **Construct Covariance Matrices**: For each test case's parameters $(s, s_{\\mathrm{p}}, e_{1,\\mathrm{p}}, e_{2,\\mathrm{p}}, s_{\\mathrm{w}}, g_{1}, g_{2})$:\n    -   PSF covariance $\\mathbf{S}_{\\mathrm{p}}$: Using $T_{\\mathrm{p}} = 2s_{\\mathrm{p}}^2$, we find the components from the definition of PSF ellipticity.\n        $$\n        \\mathbf{S}_{\\mathrm{p}} = s_{\\mathrm{p}}^2 \\begin{pmatrix} 1+e_{1,\\mathrm{p}} & e_{2,\\mathrm{p}} \\\\ e_{2,\\mathrm{p}} & 1-e_{1,\\mathrm{p}} \\end{pmatrix}\n        $$\n    -   Weight covariance $\\mathbf{S}_{\\mathrm{w}}$: Given by $\\mathbf{S}_{\\mathrm{w}} = s_{\\mathrm{w}}^2 \\mathbf{I}_2$.\n2.  **Calculate Additive Bias $\\boldsymbol{c}$**:\n    -   Set true shear $\\boldsymbol{g}=(0,0)$.\n    -   The galaxy covariance is $\\mathbf{S}_{\\mathrm{g},0} = s^2 \\mathbf{I}_2$.\n    -   Calculate $\\mathbf{Q}_{\\mathrm{corr},0} = ((\\mathbf{S}_{\\mathrm{g},0} + \\mathbf{S}_{\\mathrm{p}})^{-1} + \\mathbf{S}_{\\mathrm{w}}^{-1})^{-1} - (\\mathbf{S}_{\\mathrm{p}}^{-1} + \\mathbf{S}_{\\mathrm{w}}^{-1})^{-1}$. This requires matrix inversions.\n    -   Compute $\\boldsymbol{c} = (\\hat{g}_1, \\hat{g}_2)$ from $\\mathbf{Q}_{\\mathrm{corr},0}$.\n3.  **Calculate Multiplicative Bias $\\boldsymbol{m}$**:\n    -   Use the non-zero true shear $\\boldsymbol{g}=(g_1, g_2)$ from the test case.\n    -   Construct the lensed galaxy covariance: $\\mathbf{S}_{\\mathrm{s}} = s^2 \\mathbf{I}_2$, $\\boldsymbol{\\Gamma} = \\begin{pmatrix} g_1 & g_2 \\\\ g_2 & -g_1 \\end{pmatrix}$, and $\\mathbf{S}_{\\mathrm{g}} = \\mathbf{S}_{\\mathrm{s}} + 2 \\boldsymbol{\\Gamma}\\mathbf{S}_{\\mathrm{s}} = s^2(\\mathbf{I}_2 + 2\\boldsymbol{\\Gamma})$.\n    -   Calculate $\\mathbf{Q}_{\\mathrm{corr}} = ((\\mathbf{S}_{\\mathrm{g}} + \\mathbf{S}_{\\mathrm{p}})^{-1} + \\mathbf{S}_{\\mathrm{w}}^{-1})^{-1} - (\\mathbf{S}_{\\mathrm{p}}^{-1} + \\mathbf{S}_{\\mathrm{w}}^{-1})^{-1}$.\n    -   Compute the full shear estimate $\\hat{\\boldsymbol{g}}$ from $\\mathbf{Q}_{\\mathrm{corr}}$.\n    -   Compute $\\boldsymbol{m}=(m_1, m_2)$ using its definition with the previously calculated $\\boldsymbol{c}$ and the given $\\boldsymbol{g}$.\n\nThe following code implements this procedure.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_biases(s, s_p, e1_p, e2_p, s_w, g1, g2):\n    \"\"\"\n    Calculates the shear measurement biases (m, c) for a given set of parameters.\n\n    Args:\n        s (float): Intrinsic galaxy size parameter.\n        s_p (float): PSF size parameter.\n        e1_p (float): First component of PSF ellipticity.\n        e2_p (float): Second component of PSF ellipticity.\n        s_w (float): Weight function size parameter.\n        g1 (float): First component of true shear.\n        g2 (float): Second component of true shear.\n\n    Returns:\n        tuple: A tuple containing (m1, m2, c1, c2).\n    \"\"\"\n    # Define identity matrix\n    I2 = np.identity(2)\n\n    # 1. Construct constant covariance matrices\n    \n    # PSF covariance S_p\n    S_p = (s_p**2) * np.array([[1 + e1_p, e2_p], [e2_p, 1 - e1_p]])\n\n    # Weight covariance S_w\n    S_w = (s_w**2) * I2\n    S_w_inv = np.linalg.inv(S_w)\n\n    # 2. Calculate additive bias c\n    \n    # Galaxy covariance S_g for zero shear\n    S_g0 = (s**2) * I2\n\n    # Observed covariance for zero shear\n    S_obs0 = S_g0 + S_p\n    S_obs0_inv = np.linalg.inv(S_obs0)\n    \n    # Weighted observed moments for zero shear\n    Q_obs0 = np.linalg.inv(S_obs0_inv + S_w_inv)\n\n    # Weighted PSF moments\n    S_p_inv = np.linalg.inv(S_p)\n    Q_p = np.linalg.inv(S_p_inv + S_w_inv)\n\n    # Corrected moments for zero shear\n    Q_corr0 = Q_obs0 - Q_p\n\n    # Ellipticity and shear estimate for zero shear\n    T_corr0 = np.trace(Q_corr0)\n    e1_0 = (Q_corr0[0, 0] - Q_corr0[1, 1]) / T_corr0\n    e2_0 = 2 * Q_corr0[0, 1] / T_corr0\n    \n    c1 = 0.5 * e1_0\n    c2 = 0.5 * e2_0\n\n    # 3. Calculate multiplicative bias m\n    \n    # Galaxy covariance S_g for non-zero shear\n    Gamma = np.array([[g1, g2], [g2, -g1]])\n    S_g = (s**2) * (I2 + 2 * Gamma)\n\n    # Observed covariance for non-zero shear\n    S_obs = S_g + S_p\n    S_obs_inv = np.linalg.inv(S_obs)\n    \n    # Weighted observed moments for non-zero shear\n    Q_obs = np.linalg.inv(S_obs_inv + S_w_inv)\n\n    # Corrected moments for non-zero shear\n    Q_corr = Q_obs - Q_p\n\n    # Ellipticity and shear estimate for non-zero shear\n    T_corr = np.trace(Q_corr)\n    e1_hat = (Q_corr[0, 0] - Q_corr[1, 1]) / T_corr\n    e2_hat = 2 * Q_corr[0, 1] / T_corr\n    \n    g1_hat = 0.5 * e1_hat\n    g2_hat = 0.5 * e2_hat\n\n    # Calculate multiplicative bias components\n    m1 = (g1_hat - c1) / g1 - 1\n    m2 = (g2_hat - c2) / g2 - 1\n\n    return m1, m2, c1, c2\n\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each tuple is (s, s_p, e1_p, e2_p, s_w, g1, g2)\n    test_cases = [\n        (1.2, 0.7, 0.08, 0.02, 1.0, 0.02, -0.01),\n        (1.2, 0.6, 0.0, 0.0, 0.8, 0.02, -0.01),\n        (0.8, 1.3, 0.12, -0.05, 1.0, 0.02, -0.01),\n        (1.5, 0.3, 0.10, 0.0, 0.7, 0.02, -0.01),\n    ]\n\n    results = []\n    for case in test_cases:\n        m1, m2, c1, c2 = calculate_biases(*case)\n        # Round to six digits and append to the list\n        results.extend([\n            round(m1, 6),\n            round(m2, 6),\n            round(c1, 6),\n            round(c2, 6)\n        ])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3502401"}, {"introduction": "After carefully measuring the shear field, the ultimate goal is to reconstruct the projected mass density, or convergence $\\kappa$, that created it. This inversion is plagued by a fundamental ambiguity known as the mass-sheet degeneracy, where physically distinct mass distributions can produce identical shear fields. This powerful coding exercise [@problem_id:3502434] will have you demonstrate this degeneracy numerically and then show how a seemingly separate lensing effect, magnification bias, can be cleverly used to break it, turning a potential systematic into a powerful source of information.", "problem": "You are to write a complete, runnable program that numerically demonstrates the mass-sheet degeneracy in weak gravitational lensing and shows how magnification with a number-count slope can break that degeneracy in a mock analysis. Work in the regime of weak lensing and model a two-dimensional, axisymmetric, projected mass distribution using a physically plausible and self-consistent profile. All mathematical symbols, functions, operators, and numbers must be expressed in LaTeX.\n\nBegin from the following foundational base in weak gravitational lensing: the Jacobian (distortion) matrix $A$ of the lens mapping is defined by the convergence $\\kappa$ and the two-component shear $\\gamma = (\\gamma_1,\\gamma_2)$ via\n$$\nA = \\begin{pmatrix}\n1 - \\kappa - \\gamma_1 & -\\gamma_2 \\\\\n-\\gamma_2 & 1 - \\kappa + \\gamma_1\n\\end{pmatrix}.\n$$\nThe reduced shear $g$ is defined by\n$$\ng_i = \\frac{\\gamma_i}{1 - \\kappa}, \\quad i \\in \\{1,2\\},\n$$\nand the scalar magnification $\\mu$ is defined by\n$$\n\\mu = \\frac{1}{\\det A}.\n$$\nFor an axisymmetric projected mass distribution with radial convergence profile $\\kappa(R)$, the tangential shear amplitude $\\gamma_{\\mathrm{t}}(R)$ satisfies\n$$\n\\gamma_{\\mathrm{t}}(R) = \\bar{\\kappa}(<R) - \\kappa(R), \\quad \\bar{\\kappa}(<R) = \\frac{2}{R^2}\\int_0^R r \\kappa(r)\\,dr.\n$$\nThe Cartesian shear components for a purely tangential shear pattern are\n$$\n\\gamma_1(R,\\phi) = -\\gamma_{\\mathrm{t}}(R)\\cos(2\\phi), \\quad \\gamma_2(R,\\phi) = -\\gamma_{\\mathrm{t}}(R)\\sin(2\\phi),\n$$\nwhere $\\phi = \\arctan2(y,x)$ is the polar angle. This is a well-tested formulation in weak lensing.\n\nImplement the mass-sheet transformation defined by adding a constant $\\lambda$ to the convergence and rescaling the shear,\n$$\n\\kappa'(R) = \\kappa(R) + \\lambda, \\quad \\gamma'(R,\\phi) = (1 - \\lambda)\\,\\gamma(R,\\phi).\n$$\nUnder this transformation, $\\kappa$ and $\\gamma$ change, but the observable reduced shear $g$ is known to be invariant in the ideal case. Magnification, however, is not invariant. In galaxy number-count analyses with a limiting magnitude, the observed number density per solid angle shifts under magnification with a number-count slope $s$ according to a power-law response. Define the number-count response exponent\n$$\nq(s) = 2.5\\,s - 1,\n$$\nand assume the observed number density per pixel is proportional to $\\mu^{q(s)}$ in the absence of other systematics.\n\nYour task is to:\n- Construct a square grid of size $N \\times N$ with coordinates $(x,y)$ spanning a finite angular domain. You must use an axisymmetric Gaussian convergence profile,\n$$\n\\kappa(R) = \\kappa_0\\,\\exp\\left(-\\frac{R^2}{2\\sigma^2}\\right),\n$$\nwith $R = \\sqrt{x^2 + y^2}$, where $\\kappa_0$ and $\\sigma$ are dimensionless parameters chosen to keep the configuration in the weak-lensing regime.\n- Compute $\\bar{\\kappa}(<R)$ analytically for the chosen Gaussian profile, then compute $\\gamma_{\\mathrm{t}}(R)$, and then compute the shear components $\\gamma_1$ and $\\gamma_2$ over the grid. From $\\kappa$ and $\\gamma$, compute the reduced shear components $g_1$ and $g_2$, and the magnification $\\mu$ over the grid.\n- Apply the mass-sheet transformation with a given $\\lambda$ and recompute $g_1'$, $g_2'$, and $\\mu'$.\n- Quantify the invariance of reduced shear by computing the root-mean-square (RMS) difference between the original and transformed reduced shear fields,\n$$\n\\epsilon_g(\\lambda) = \\sqrt{\\left\\langle \\left(g_1' - g_1\\right)^2 + \\left(g_2' - g_2\\right)^2 \\right\\rangle},\n$$\nwhere $\\langle\\cdot\\rangle$ denotes the average over all grid pixels for which the expressions are numerically well-defined.\n- Quantify the magnification bias effect in number counts by computing the ratio\n$$\nR(\\lambda,s) = \\frac{\\left\\langle \\mu'^{\\,q(s)} \\right\\rangle}{\\left\\langle \\mu^{\\,q(s)} \\right\\rangle},\n$$\nwhich indicates how the average observed number density changes under the mass-sheet transformation for slope $s$.\n\nScientific realism requirements:\n- Choose $\\kappa_0$ and $\\sigma$ such that $\\kappa(R)$ remains below unity everywhere on the grid and the weak-lensing approximation is appropriate.\n- Ensure no division by zero occurs by excluding pixels where denominators approach zero, or by using numerically stable masks.\n- All quantities $\\kappa$, $\\gamma$, $g$, and $\\mu$ are dimensionless. Angles (for $\\phi$) must be computed in radians.\n\nTest suite specification:\n- Use a square grid with $N = 256$, spanning $x,y \\in [-1.0, 1.0]$.\n- Use $\\kappa_0 = 0.3$ and $\\sigma = 0.3$.\n- Provide the following five test cases, each defined by a pair $(\\lambda, s)$:\n  1. $(\\lambda, s) = (0.0, 0.6)$.\n  2. $(\\lambda, s) = (0.3, 0.6)$.\n  3. $(\\lambda, s) = (-0.2, 0.6)$.\n  4. $(\\lambda, s) = (0.3, 0.4)$.\n  5. $(\\lambda, s) = (0.3, 0.0)$.\nThese test cases cover a baseline, positive and negative mass sheets, and the critical number-count slope $s$ where magnification bias does not alter counts, as well as a shallow slope.\n\nRequired final output format:\n- Your program should produce a single line of output containing the results as a comma-separated list of floating-point numbers ordered as\n$$\n[\\epsilon_g(\\lambda_1), R(\\lambda_1,s_1), \\epsilon_g(\\lambda_2), R(\\lambda_2,s_2), \\ldots ].\n$$\nNo other text should be printed. You may compute with full precision and do not need to round, but the output must strictly adhere to this single-line list format.", "solution": "The user has provided a valid, well-posed problem statement that is scientifically grounded in the principles of numerical cosmology and weak gravitational lensing. The task is to numerically demonstrate the mass-sheet degeneracy and its resolution via magnification bias. This requires deriving an intermediate analytical expression and implementing a series of numerical calculations on a grid.\n\nThe problem is valid because:\n1.  **Scientifically Grounded:** All provided equations for the lensing Jacobian $A$, reduced shear $g$, magnification $\\mu$, and mass-sheet transformation are standard or well-defined theoretical constructs in the field of gravitational lensing. The Gaussian mass profile is a physically plausible model. The number-count response model is a standard phenomenological description of magnification bias.\n2.  **Well-Posed:** The problem provides a complete set of parameters ($N$, domain size, $\\kappa_0$, $\\sigma$), a specific mass profile, and a clear set of tasks and test cases, leading to a unique numerical solution. The requirement to analytically compute an intermediate quantity ($\\bar{\\kappa}(<R)$) is a part of the problem's instructions, not a sign of incompleteness.\n3.  **Internally Consistent:** The parameter choices ($\\kappa_0 = 0.3$) place the simulation in the weak lensing regime ($\\kappa \\ll 1$) as required. While the stated invariance of the reduced shear $g$ under the given transformation is an approximation, the problem correctly anticipates a small, non-zero deviation by asking for the computation of the RMS difference $\\epsilon_g(\\lambda)$, thereby making the setup self-consistent.\n\nI will now proceed with a complete, reasoned solution.\n\n### 1. Theoretical Framework\n\nThe problem explores weak gravitational lensing, where the distortion of background galaxy images is described by the Jacobian matrix $A$ of the lens mapping. For a given convergence $\\kappa$ and two-component shear $\\gamma = (\\gamma_1, \\gamma_2)$, this matrix is:\n$$\nA = \\begin{pmatrix}\n1 - \\kappa - \\gamma_1 & -\\gamma_2 \\\\\n-\\gamma_2 & 1 - \\kappa + \\gamma_1\n\\end{pmatrix}\n$$\nThe direct observable from galaxy ellipticities is the reduced shear $g$, defined as:\n$$\ng_i = \\frac{\\gamma_i}{1 - \\kappa}, \\quad i \\in \\{1,2\\}\n$$\nThe magnification $\\mu$, which changes the observed flux and size of a source, is the inverse of the Jacobian determinant:\n$$\n\\mu = \\frac{1}{\\det A} = \\frac{1}{(1-\\kappa)^2 - (\\gamma_1^2 + \\gamma_2^2)} = \\frac{1}{(1-\\kappa)^2 (1-g_1^2 - g_2^2)}\n$$\nFor an axisymmetric projected mass distribution, the convergence $\\kappa(R)$ is a function of the radial coordinate $R = \\sqrt{x^2+y^2}$ only. The tangential shear amplitude $\\gamma_{\\mathrm{t}}(R)$ is related to $\\kappa(R)$ and the mean convergence $\\bar{\\kappa}(<R)$ enclosed within radius $R$:\n$$\n\\gamma_{\\mathrm{t}}(R) = \\bar{\\kappa}(<R) - \\kappa(R)\n$$\nwhere $\\bar{\\kappa}(<R)$ is given by the integral:\n$$\n\\bar{\\kappa}(<R) = \\frac{2}{R^2}\\int_0^R r \\kappa(r)\\,dr\n$$\n\n### 2. Analytical Derivation for the Gaussian Profile\n\nThe problem specifies a Gaussian convergence profile:\n$$\n\\kappa(R) = \\kappa_0\\,\\exp\\left(-\\frac{R^2}{2\\sigma^2}\\right)\n$$\nTo compute the tangential shear, we must first analytically solve the integral for $\\bar{\\kappa}(<R)$. Let's perform a substitution with $u = r^2/ (2\\sigma^2)$, which implies $du = r dr / \\sigma^2$.\n$$\n\\int_0^R r \\kappa_0 \\exp\\left(-\\frac{r^2}{2\\sigma^2}\\right) dr = \\kappa_0 \\int_0^{R^2/(2\\sigma^2)} \\sigma^2 e^{-u} du\n$$\n$$\n= \\kappa_0 \\sigma^2 \\left[ -e^{-u} \\right]_0^{R^2/(2\\sigma^2)} = \\kappa_0 \\sigma^2 \\left( -e^{-R^2/(2\\sigma^2)} - (-e^0) \\right) = \\kappa_0 \\sigma^2 \\left(1 - \\exp\\left(-\\frac{R^2}{2\\sigma^2}\\right)\\right)\n$$\nSubstituting this back into the definition of $\\bar{\\kappa}(<R)$:\n$$\n\\bar{\\kappa}(<R) = \\frac{2}{R^2} \\left[ \\kappa_0 \\sigma^2 \\left(1 - \\exp\\left(-\\frac{R^2}{2\\sigma^2}\\right)\\right) \\right] = 2\\kappa_0\\frac{\\sigma^2}{R^2}\\left(1 - \\exp\\left(-\\frac{R^2}{2\\sigma^2}\\right)\\right)\n$$\nThis expression is numerically unstable at $R=0$. We find the limit as $R \\to 0$ using the Taylor series expansion for the exponential, $\\exp(-x) \\approx 1-x$ for small $x$:\n$$\n\\lim_{R\\to 0} \\bar{\\kappa}(<R) = \\lim_{R\\to 0} 2\\kappa_0\\frac{\\sigma^2}{R^2}\\left(1 - \\left(1 - \\frac{R^2}{2\\sigma^2} + \\dots\\right)\\right) = \\lim_{R\\to 0} 2\\kappa_0\\frac{\\sigma^2}{R^2}\\left(\\frac{R^2}{2\\sigma^2}\\right) = \\kappa_0\n$$\nThus, at the center, the mean convergence equals the peak convergence, as expected. With these analytical results, the tangential shear $\\gamma_{\\mathrm{t}}(R)$ is fully determined. The Cartesian shear components are then found using the polar angle $\\phi = \\arctan2(y,x)$:\n$$\n\\gamma_1(R,\\phi) = -\\gamma_{\\mathrm{t}}(R)\\cos(2\\phi), \\quad \\gamma_2(R,\\phi) = -\\gamma_{\\mathrm{t}}(R)\\sin(2\\phi)\n$$\n\n### 3. Mass-Sheet Degeneracy and Magnification Bias\n\nThe mass-sheet degeneracy is a transformation that, in the ideal weak lensing limit, leaves the reduced shear $g$ invariant. The problem defines the transformation as:\n$$\n\\kappa'(R) = \\kappa(R) + \\lambda, \\quad \\gamma'(R,\\phi) = (1 - \\lambda)\\,\\gamma(R,\\phi)\n$$\nwhere $\\lambda$ is a constant. The transformed reduced shear $g'$ is:\n$$\ng'_i = \\frac{\\gamma'_i}{1-\\kappa'} = \\frac{(1-\\lambda)\\gamma_i}{1-(\\kappa+\\lambda)} = \\frac{(1-\\lambda)\\gamma_i}{1-\\kappa-\\lambda+\\lambda\\kappa} = g_i \\frac{(1-\\lambda)(1-\\kappa)}{1-\\kappa-\\lambda}\n$$\nIn the weak lensing limit where $\\kappa \\ll 1$ and the transformation is small $|\\lambda| \\ll 1$, the product $\\lambda\\kappa$ is a second-order term. The fraction becomes $\\frac{1-\\kappa-\\lambda+\\lambda\\kappa}{1-\\kappa-\\lambda} \\approx \\frac{1-\\kappa-\\lambda}{1-\\kappa-\\lambda} = 1$. Thus, $g' \\approx g$, and the reduced shear is approximately invariant. The quantity $\\epsilon_g(\\lambda)$ will measure the deviation from perfect invariance.\n\nHowever, the magnification $\\mu$ is not invariant. The transformed magnification is:\n$$\n\\mu' = \\frac{1}{(1-\\kappa')^2 - |\\gamma'|^2} = \\frac{1}{(1-\\kappa-\\lambda)^2 - (1-\\lambda)^2|\\gamma|^2}\n$$\nThis change in magnification alters the observed number density of background galaxies. For a number count distribution with a power-law slope $s$, the observed number density is modulated by $\\mu^{q(s)}$, where the exponent is $q(s) = 2.5s-1$. The ratio $R(\\lambda,s) = \\langle \\mu'^{\\,q(s)} \\rangle / \\langle \\mu^{\\,q(s)} \\rangle$ quantifies this change, demonstrating how magnification information can break the mass-sheet degeneracy. A special case occurs when $s=0.4$, which gives $q(0.4) = 2.5(0.4) - 1 = 0$. In this case, $\\mu^{q(s)} = 1$, and the number counts are insensitive to magnification, yielding $R(\\lambda, 0.4) = 1$.\n\n### 4. Numerical Implementation\n\nThe algorithm proceeds as follows:\n1.  **Grid Setup:** A square grid of size $N \\times N$ ($256 \\times 256$) is defined for coordinates $(x,y)$ spanning $[-1.0, 1.0]$. The radial coordinate $R$ and polar angle $\\phi$ are computed for each pixel.\n2.  **Base Field Calculation:** The initial fields $\\kappa(R)$, $\\bar{\\kappa}(<R)$, $\\gamma_{\\mathrm{t}}(R)$, $\\gamma_1(R,\\phi)$, and $\\gamma_2(R,\\phi)$ are computed over the grid using the analytical formulae derived above. The special case for $R=0$ is handled for $\\bar{\\kappa}(<R)$. From these, the base reduced shear fields $g_1, g_2$ and magnification field $\\mu$ are calculated.\n3.  **Iterate Through Test Cases:** For each pair of $(\\lambda, s)$:\n    a. The transformed fields $\\kappa'$ and $\\gamma'$ are computed.\n    b. The transformed reduced shear $g'$ and magnification $\\mu'$ are calculated.\n    c. A validity mask is created to exclude any pixels where denominators ($1-\\kappa$, $1-\\kappa'$, $\\det A$, $\\det A'$) are zero or where magnification becomes non-positive. Given the problem parameters, these conditions are not expected to be met, but it is a robust practice.\n    d. The RMS difference $\\epsilon_g(\\lambda) = \\sqrt{\\langle (g_1' - g_1)^2 + (g_2' - g_2)^2 \\rangle}$ is computed over all valid pixels.\n    e. The number count slope exponent $q(s)$ is computed.\n    f. The ratio $R(\\lambda,s) = \\langle \\mu'^{\\,q(s)} \\rangle / \\langle \\mu^{\\,q(s)} \\rangle$ is computed over all valid pixels.\n4.  **Output:** The calculated values of $\\epsilon_g$ and $R$ for each test case are collected and printed in the specified format.\n\nThe following Python program implements this logic.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Numerically demonstrates the mass-sheet degeneracy in weak lensing and its\n    breaking via magnification bias.\n    \"\"\"\n    # Test suite specification\n    N = 256\n    domain_half_width = 1.0\n    k0 = 0.3\n    sigma = 0.3\n\n    test_cases = [\n        # (lambda, s)\n        (0.0, 0.6),\n        (0.3, 0.6),\n        (-0.2, 0.6),\n        (0.3, 0.4),\n        (0.3, 0.0),\n    ]\n\n    # 1. Grid Setup\n    x = np.linspace(-domain_half_width, domain_half_width, N)\n    y = np.linspace(-domain_half_width, domain_half_width, N)\n    xx, yy = np.meshgrid(x, y)\n\n    R = np.sqrt(xx**2 + yy**2)\n    phi = np.arctan2(yy, xx)\n\n    # 2. Base Field Calculation (Original, untransformed fields)\n\n    # Convergence kappa(R)\n    kappa = k0 * np.exp(-(R**2) / (2 * sigma**2))\n\n    # Average convergence bar_kappa(<R)\n    # The analytical expression is 2*k0*(sigma^2/R^2)*(1-exp(-R^2/(2*sigma^2)))\n    # We handle the R=0 case using the analytical limit bar_kappa(<0) = k0\n    R_sq = R**2\n    # Epsilon to avoid division by zero, though the mask handles it.\n    R_sq_safe = R_sq + 1e-12 \n    bar_kappa = 2 * k0 * (sigma**2 / R_sq_safe) * (1 - np.exp(-R_sq / (2 * sigma**2)))\n    bar_kappa[R == 0] = k0  # Apply the limit at R=0\n\n    # Tangential shear gamma_t(R)\n    gamma_t = bar_kappa - kappa\n\n    # Cartesian shear components gamma_1, gamma_2\n    cos_2phi = np.cos(2 * phi)\n    sin_2phi = np.sin(2 * phi)\n    gamma1 = -gamma_t * cos_2phi\n    gamma2 = -gamma_t * sin_2phi\n\n    # Base reduced shear g_1, g_2\n    denom_g = 1 - kappa\n    g1 = gamma1 / denom_g\n    g2 = gamma2 / denom_g\n\n    # Base magnification mu\n    det_A = (1 - kappa)**2 - (gamma1**2 + gamma2**2)\n    mu = 1 / det_A\n\n    results = []\n    \n    # 3. Iterate Through Test Cases\n    for lambda_val, s_val in test_cases:\n        # Trivial case: lambda = 0 means no transformation\n        if lambda_val == 0.0:\n            eps_g = 0.0\n            R_val = 1.0\n            results.extend([eps_g, R_val])\n            continue\n\n        # Transformed convergence kappa'\n        kappa_prime = kappa + lambda_val\n\n        # Transformed shear gamma'\n        gamma1_prime = (1 - lambda_val) * gamma1\n        gamma2_prime = (1 - lambda_val) * gamma2\n\n        # Transformed reduced shear g'\n        denom_g_prime = 1 - kappa_prime\n        \n        # Transformed magnification mu'\n        det_A_prime = (1 - kappa_prime)**2 - (gamma1_prime**2 + gamma2_prime**2)\n        \n        # Create a mask to ensure all denominators are non-zero and mu is positive.\n        # With the given parameters, these conditions are always met, but this is\n        # a robust practice.\n        valid_mask = (denom_g != 0) & (denom_g_prime != 0) & \\\n                     (det_A > 0) & (det_A_prime > 0)\n        \n        # Calculate g' only where valid\n        g1_prime = np.full_like(g1, np.nan)\n        g2_prime = np.full_like(g2, np.nan)\n        g1_prime[valid_mask] = gamma1_prime[valid_mask] / denom_g_prime[valid_mask]\n        g2_prime[valid_mask] = gamma2_prime[valid_mask] / denom_g_prime[valid_mask]\n\n        # Calculate mu' only where valid\n        mu_prime = np.full_like(mu, np.nan)\n        mu_prime[valid_mask] = 1.0 / det_A_prime[valid_mask]\n        \n        # Calculate RMS difference in reduced shear\n        diff_g_sq = (g1_prime - g1)**2 + (g2_prime - g2)**2\n        eps_g = np.sqrt(np.mean(diff_g_sq[valid_mask]))\n\n        # Calculate number count response\n        q_val = 2.5 * s_val - 1.0\n        \n        # For q=0, R must be 1.0. This handles s=0.4 case without FP errors.\n        if np.isclose(q_val, 0.0):\n            R_val = 1.0\n        else:\n            # Power can be negative, so ensure mu>0 is handled by mask\n            num_counts_orig = mu[valid_mask]**q_val\n            num_counts_prime = mu_prime[valid_mask]**q_val\n            \n            mean_counts_orig = np.mean(num_counts_orig)\n            mean_counts_prime = np.mean(num_counts_prime)\n            \n            R_val = mean_counts_prime / mean_counts_orig\n\n        results.extend([eps_g, R_val])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3502434"}]}