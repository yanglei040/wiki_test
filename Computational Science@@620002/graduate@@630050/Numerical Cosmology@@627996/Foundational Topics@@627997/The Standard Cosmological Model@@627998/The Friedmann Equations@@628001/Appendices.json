{"hands_on_practices": [{"introduction": "The Friedmann equation is the cornerstone of modern cosmology, describing the expansion of a homogeneous and isotropic universe. This foundational exercise [@problem_id:3495819] translates this fundamental equation into a computational model. By building a numerical solver for the scale factor $a(t)$ and validating it against exact analytical solutions for simplified universes, you will develop a core skill in numerical cosmology and build intuition for how different forms of energy—matter, radiation, and dark energy—govern cosmic history.", "problem": "Consider a spatially homogeneous and isotropic Universe described by the Friedmann–Lemaître–Robertson–Walker (FLRW) metric and governed by the Friedmann expansion law. Let $a(t)$ denote the scale factor, and define the Hubble rate $H(a)$ via $H(a) = \\dot{a}/a$. The evolution of $H(a)$ is governed by the Friedmann equation, which relates the expansion rate to the total energy density, spatial curvature, and the cosmological constant. The total energy density may be modeled as a sum of non-interacting perfect fluid components with constant equation-of-state parameter $w$, for which energy conservation implies a scaling law for the energy density with the scale factor. In addition, spatial curvature and the cosmological constant contribute additively to the right-hand side through the curvature term and a constant term, respectively.\n\nYour task is to design and implement a numerical solver that computes $H(a)$ and integrates the ordinary differential equation (ODE) for $a(t)$,\n$$\n\\frac{da}{dt} = a \\, H(a),\n$$\nfor specified single-component universes. You must then validate the numerical solution for $a(t)$ against analytically derived solutions that apply in single-component cases. The program must operate in a dimensionless normalization where all constants are chosen such that the characteristic expansion scales are of order unity; no physical units are required in the final numerical outputs. All outputs must be dimensionless, and angles do not appear in this problem.\n\nFundamental base to use:\n- The Friedmann equation, which in the chosen normalization can be written as\n$$\nH(a)^2 = \\sum_i C_i \\, a^{-3(1+w_i)} - \\frac{k}{a^2} + L,\n$$\nwhere $C_i$ are non-negative constants corresponding to perfect fluid components with equation-of-state parameter $w_i$, $k$ is the spatial curvature parameter, and $L$ is a constant proportional to the cosmological constant term.\n- Energy conservation in an expanding FLRW Universe for a perfect fluid with constant $w$, which implies\n$$\n\\rho(a) \\propto a^{-3(1+w)}.\n$$\nNo other shortcut formulas are to be assumed in the problem statement; all analytic expressions used for validation must be derived from these bases in your solution.\n\nAlgorithmic requirements:\n1. Implement a function to evaluate $H(a)$ for given $(C_i, w_i)$, $k$, and $L$.\n2. Integrate the ODE $da/dt = a H(a)$ forward in $t$ from a specified initial time $t_0$ with initial scale factor $a(t_0) = a_0$.\n3. Derive and implement analytic solutions for $a(t)$ appropriate to single-component cases to validate the numerical integration. Use these analytic expressions to set consistent initial conditions at $t_0$ and to compute validation targets at specified times.\n\nTest suite:\nYou must run your program on the following three single-component cases. For each case, compute the numerical solution $a_{\\text{num}}(t)$ at the times listed in $t_{\\text{eval}}$, compute the corresponding analytic solution $a_{\\text{ana}}(t)$, and report the maximum relative error across the times in $t_{\\text{eval}}$,\n$$\n\\max_{t \\in t_{\\text{eval}}} \\left| \\frac{a_{\\text{num}}(t) - a_{\\text{ana}}(t)}{a_{\\text{ana}}(t)} \\right|.\n$$\n\n- Case A (single radiation component):\n  - One component with $(C, w) = (1.0, 1/3)$.\n  - Spatial curvature $k = 0.0$.\n  - Cosmological constant term $L = 0.0$.\n  - Initial time $t_0 = 0.01$.\n  - Initial scale factor $a_0$ must equal the analytic value at $t_0$ derived in your solution.\n  - Validation times $t_{\\text{eval}} = [0.05, 0.1, 1.0]$.\n\n- Case B (single pressureless matter component):\n  - One component with $(C, w) = (1.0, 0.0)$.\n  - Spatial curvature $k = 0.0$.\n  - Cosmological constant term $L = 0.0$.\n  - Initial time $t_0 = 0.01$.\n  - Initial scale factor $a_0$ must equal the analytic value at $t_0$ derived in your solution.\n  - Validation times $t_{\\text{eval}} = [0.05, 0.1, 1.0]$.\n\n- Case C (pure cosmological constant):\n  - No fluid components.\n  - Spatial curvature $k = 0.0$.\n  - Cosmological constant term $L = 1.0$.\n  - Initial time $t_0 = 0.0$.\n  - Initial scale factor $a_0 = 1.0$.\n  - Validation times $t_{\\text{eval}} = [0.05, 0.1, 1.0]$.\n\nFinal output format:\nYour program should produce a single line of output containing the three maximum relative errors, one for each case, as a comma-separated list enclosed in square brackets (for example, \"[e_A,e_B,e_C]\"). Each entry must be a floating-point number. No other text must be printed.", "solution": "The problem requires the design and implementation of a numerical solver for the scale factor $a(t)$ in a spatially homogeneous and isotropic Universe described by the Friedmann–Lemaître–Robertson–Walker (FLRW) metric. The evolution of $a(t)$ is governed by the first Friedmann equation and the definition of the Hubble rate, which combine into a first-order ordinary differential equation (ODE). The numerical solution must then be validated against analytic solutions for specific single-component universes.\n\nThe fundamental governing equations are the ODE for the scale factor,\n$$\n\\frac{da}{dt} = a(t) H(a(t))\n$$\nand the Friedmann equation, which defines the Hubble rate $H(a)$:\n$$\nH(a)^2 = \\sum_i C_i \\, a^{-3(1+w_i)} - \\frac{k}{a^2} + L\n$$\nHere, $C_i$ are constants representing the energy density of perfect fluid components with equation of state $w_i$, $k$ is the spatial curvature parameter, and $L$ represents the cosmological constant. The problem specifies evaluation in a dimensionless system.\n\nThe core of the task is to first derive analytic solutions for $a(t)$ in simplified, single-component universes, and then to use these solutions to validate a numerical integration of the general ODE.\n\n**1. Derivation of Analytic Solutions**\n\nTo find an analytic solution for $a(t)$, we rearrange the ODE as $dt = \\frac{da}{a H(a)}$ and integrate. The form of $H(a)$ is determined by the specific cosmological components present. We consider the three single-component test cases specified.\n\n**Case A: Radiation-dominated Universe**\nFor this case, the universe contains only a radiation component with $(C, w) = (1.0, 1/3)$, and has zero spatial curvature ($k=0$) and no cosmological constant ($L=0$). The Friedmann equation simplifies to:\n$$\nH(a)^2 = C a^{-3(1+w)} = (1.0) a^{-3(1+1/3)} = a^{-4}\n$$\nAssuming an expanding universe, we take the positive root for the Hubble rate, $H(a) = a^{-2}$. The ODE for the scale factor becomes:\n$$\n\\frac{da}{dt} = a H(a) = a \\cdot a^{-2} = a^{-1}\n$$\nWe solve this by separation of variables:\n$$\na \\, da = dt\n$$\nIntegrating both sides, $\\int a' \\, da' = \\int dt'$, yields $\\frac{1}{2}a^2 = t + K$, where $K$ is an integration constant. By choosing the origin of time such that $a(0)=0$, we set $K=0$. This gives the analytic solution:\n$$\na_{\\text{ana}}(t) = \\sqrt{2t}\n$$\nFor this case, the initial time is $t_0 = 0.01$. The initial scale factor $a_0$ must be consistent with the analytic solution, so $a_0 = a_{\\text{ana}}(t_0) = \\sqrt{2 \\cdot 0.01} = \\sqrt{0.02}$.\n\n**Case B: Matter-dominated Universe**\nThis case considers a universe with only pressureless matter, $(C, w) = (1.0, 0.0)$, and again with $k=0$ and $L=0$. The Friedmann equation is:\n$$\nH(a)^2 = C a^{-3(1+w)} = (1.0) a^{-3(1+0)} = a^{-3}\n$$\nTaking the positive root, $H(a) = a^{-3/2}$. The ODE for the scale factor is:\n$$\n\\frac{da}{dt} = a H(a) = a \\cdot a^{-3/2} = a^{-1/2}\n$$\nSeparating variables gives:\n$$\na^{1/2} \\, da = dt\n$$\nIntegrating $\\int (a')^{1/2} \\, da' = \\int dt'$ gives $\\frac{2}{3}a^{3/2} = t + K$. Again choosing $a(0)=0$ sets the integration constant $K=0$, leading to the analytic solution:\n$$\na_{\\text{ana}}(t) = \\left(\\frac{3}{2} t\\right)^{2/3}\n$$\nThe initial time is $t_0 = 0.01$, so the consistent initial scale factor is $a_0 = a_{\\text{ana}}(t_0) = (\\frac{3}{2} \\cdot 0.01)^{2/3} = (0.015)^{2/3}$.\n\n**Case C: Cosmological Constant-dominated Universe**\nThis case has no fluid components, $k=0$, and a non-zero cosmological constant term $L=1.0$. The Friedmann equation simplifies to:\n$$\nH(a)^2 = L = 1.0\n$$\nThe Hubble rate is constant: $H(a) = \\sqrt{L} = 1$. The ODE for the scale factor is:\n$$\n\\frac{da}{dt} = a H(a) = a\n$$\nSeparating variables gives $\\frac{da}{a} = dt$. Integrating from an initial time $t_0$ with scale factor $a_0$ to a later time $t$ gives:\n$$\n\\int_{a_0}^{a(t)} \\frac{da'}{a'} = \\int_{t_0}^{t} dt' \\implies \\ln\\left(\\frac{a(t)}{a_0}\\right) = t - t_0\n$$\nThe analytic solution is thus exponential growth:\n$$\na_{\\text{ana}}(t) = a_0 e^{t - t_0}\n$$\nFor this case, the initial conditions are explicitly given as $t_0=0.0$ and $a_0=1.0$. The analytic solution simplifies to $a_{\\text{ana}}(t) = e^t$, which is consistent since $a_{\\text{ana}}(0)=e^0=1.0$.\n\n**2. Numerical Integration and Validation**\n\nThe numerical solution is obtained by integrating the ODE $\\frac{da}{dt} = a H(a)$ using a standard numerical solver. The `scipy.integrate.solve_ivp` function from the SciPy library is a suitable choice, providing a robust implementation of high-order Runge-Kutta methods.\n\nFor each test case:\n1. A Python function representing the right-hand side of the ODE, $f(t, a) = a H(a)$, is defined based on the case-specific parameters $(C, w, k, L)$.\n2. The initial condition $(t_0, a_0)$ is set. For cases A and B, $a_0$ is calculated from the respective analytic solution at $t_0$. For case C, it is given directly.\n3. `solve_ivp` is called to integrate the ODE from $t_0$ to the maximum time in $t_{\\text{eval}}$, requesting the solution values at the specific times listed in $t_{\\text{eval}}$. To ensure high accuracy, tight error tolerances (e.g., relative tolerance `rtol` and absolute tolerance `atol` of $10^{-12}$) are specified.\n4. The numerical solution $a_{\\text{num}}(t)$ is obtained from the solver's output.\n5. The analytic solution $a_{\\text{ana}}(t)$ is computed at the same set of times $t_{\\text{eval}}$.\n6. The maximum relative error is then calculated according to the formula:\n$$\n\\text{error} = \\max_{t \\in t_{\\text{eval}}} \\left| \\frac{a_{\\text{num}}(t) - a_{\\text{ana}}(t)}{a_{\\text{ana}}(t)} \\right|\n$$\nThis error quantifies the deviation of the numerical result from the exact analytic solution and serves as the validation metric. The expected errors should be very small, on the order of the solver's tolerance.\n\nThe procedure is applied to the three specified cases:\n- **Case A:** $(C, w)=(1.0, 1/3), k=0, L=0$. Initial conditions: $t_0=0.01, a_0=a_{\\text{ana}}(0.01)$.\n- **Case B:** $(C, w)=(1.0, 0), k=0, L=0$. Initial conditions: $t_0=0.01, a_0=a_{\\text{ana}}(0.01)$.\n- **Case C:** No fluid, $k=0, L=1.0$. Initial conditions: $t_0=0.0, a_0=1.0$.\n\nThe final output is a list of the maximum relative errors for each case.", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Solves for the scale factor a(t) in single-component universes,\n    validates against analytic solutions, and reports the maximum relative error.\n    \"\"\"\n\n    # Define the three test cases as specified in the problem statement.\n    # Each tuple contains:\n    # (C, w, k, L, t0, a0 (or None if derived), t_eval, analytic_func)\n    test_cases = [\n        # Case A: Radiation-dominated\n        (\n            1.0, 1.0/3.0, 0.0, 0.0, 0.01, None,\n            np.array([0.05, 0.1, 1.0]),\n            lambda t: np.sqrt(2.0 * t)\n        ),\n        # Case B: Matter-dominated\n        (\n            1.0, 0.0, 0.0, 0.0, 0.01, None,\n            np.array([0.05, 0.1, 1.0]),\n            lambda t: (1.5 * t)**(2.0/3.0)\n        ),\n        # Case C: Cosmological constant-dominated\n        (\n            0.0, 0.0, 0.0, 1.0, 0.0, 1.0,\n            np.array([0.05, 0.1, 1.0]),\n            lambda t: np.exp(t)\n        )\n    ]\n\n    results = []\n\n    for case in test_cases:\n        C, w, k, L, t0, a0_val, t_eval, a_analytic_func = case\n\n        # Set the initial scale factor a0.\n        # If a0_val is not provided, compute it from the analytic solution at t0.\n        if a0_val is None:\n            a0 = a_analytic_func(t0)\n        else:\n            a0 = a0_val\n\n        # Define the ODE: da/dt = a * H(a)\n        def dadt(t, y):\n            a = y[0]\n            \n            # Guard against non-positive scale factor due to numerical errors.\n            # a > 0 for all cases considered.\n            if a = 0:\n                return [0.0]\n\n            # Calculate H(a)^2 from the Friedmann equation.\n            # Handle potential negative values from numerical precision issues.\n            h_squared = C * a**(-3.0 * (1.0 + w)) - k * a**(-2.0) + L\n            if h_squared  0:\n                h_squared = 0.0\n\n            H = np.sqrt(h_squared)\n            return [a * H]\n\n        # Set up integration time span and initial conditions.\n        t_span = (t0, t_eval[-1])\n        y0 = [a0]\n\n        # Use a high-precision solver to integrate the ODE.\n        # rtol and atol are set to small values to minimize solver error.\n        sol = solve_ivp(\n            dadt,\n            t_span,\n            y0,\n            t_eval=t_eval,\n            method='DOP853', # A high-order accurate solver\n            rtol=1e-13,\n            atol=1e-13\n        )\n\n        # Extract the numerical solution at the evaluation times.\n        a_numerical = sol.y[0]\n\n        # Compute the analytic solution at the evaluation times for validation.\n        a_analytical = a_analytic_func(t_eval)\n\n        # Calculate the maximum relative error.\n        # Guard against division by zero if an analytic value is zero (not the case here).\n        relative_errors = np.abs((a_numerical - a_analytical) / a_analytical)\n        max_relative_error = np.max(relative_errors)\n        \n        results.append(max_relative_error)\n\n    # Print the results in the specified format.\n    print(f\"[{','.join(f'{err:.10e}' for err in results)}]\")\n\nsolve()\n```", "id": "3495819"}, {"introduction": "Once we can model the expansion history $H(z)$, the next step is to compute observable quantities, such as cosmological distances. The geometry of spacetime, determined by the curvature parameter $k$, dictates the relationship between angular size, flux, and distance. This exercise [@problem_id:3495804] focuses on implementing the transverse comoving distance function $S_k(\\chi)$, which is essential for these calculations, and tackles a critical numerical challenge: maintaining precision in nearly-flat universes, a vital skill for analyzing modern cosmological data.", "problem": "You are asked to implement a numerically robust evaluation of the transverse comoving distance function $S_k(\\chi)$ that arises in the spatial part of the Friedmann–Robertson–Walker (FRW) metric of a homogeneous and isotropic universe. Use the following fundamental base.\n\n1. The Friedmann equations define the expansion rate through the dimensionless Hubble function $E(z)$, with $E(z) = H(z)/H_0$, where $H_0$ is the Hubble constant. For a universe with matter density parameter $\\Omega_m$, cosmological constant density parameter $\\Omega_\\Lambda$, and curvature density parameter $\\Omega_k$, assume $E(z)$ has the form\n$$\nE(z) = \\sqrt{\\Omega_m (1+z)^3 + \\Omega_k (1+z)^2 + \\Omega_\\Lambda}.\n$$\nIgnore radiation for this problem.\n\n2. The line-of-sight comoving distance $\\chi(z)$ is defined by\n$$\n\\chi(z) = \\int_{0}^{z} \\frac{dz'}{E(z')}.\n$$\n\n3. The spatial curvature constant of the FRW spatial slices is $k_\\text{geom}$, which is related to the curvature density parameter by\n$$\nk_\\text{geom} = -\\Omega_k \\frac{H_0^2}{c^2}.\n$$\n\n4. The transverse comoving distance function $S_k(\\chi)$ is defined as the unique solution to the ordinary differential equation\n$$\n\\frac{d^2 S_k}{d\\chi^2} + k_\\text{geom}\\, S_k = 0,\n$$\nwith the initial conditions $S_k(0) = 0$ and $\\left.\\frac{d S_k}{d\\chi}\\right|_{\\chi=0} = 1$.\n\nYour task is to:\n\n- Derive a numerically stable algorithm to evaluate $S_k(\\chi)$ for general $k_\\text{geom}$ and $\\chi$, paying careful attention to edge cases such as $k_\\text{geom} \\to 0$, large arguments, and cancellation. Implement the algorithm in a complete, runnable program that computes $S_k(\\chi(z))$ from the given cosmological parameters via the integral for $\\chi(z)$.\n\n- Assume natural units with $c/H_0 = 1$, so all distances are dimensionless and your outputs are dimensionless numbers. No angle units or physical unit conversions are needed.\n\n- Discuss and algorithmically address domain and numerical issues: continuity of $S_k(\\chi)$ at $k_\\text{geom}=0$, behavior for $k_\\text{geom}  0$ and $k_\\text{geom}  0$, cancellation for small $|k_\\text{geom}|\\chi^2$, and overflow risks for large $|k_\\text{geom}|^{1/2}\\chi$ when hyperbolic functions appear.\n\nDesign a test suite with the following parameter sets to evaluate your implementation:\n\n- Case A (happy path, flat universe): $(\\Omega_m, \\Omega_\\Lambda, \\Omega_k, z) = (0.3, 0.7, 0.0, 2.0)$. Output the float value of $S_k(\\chi(z))$.\n\n- Case B (closed universe): $(\\Omega_m, \\Omega_\\Lambda, \\Omega_k, z) = (0.3, 0.75, -0.05, 2.0)$, where $k_\\text{geom}  0$. Output the float value of $S_k(\\chi(z))$.\n\n- Case C (open universe): $(\\Omega_m, \\Omega_\\Lambda, \\Omega_k, z) = (0.3, 0.65, 0.05, 2.0)$, where $k_\\text{geom}  0$. Output the float value of $S_k(\\chi(z))$.\n\n- Case D (near-flat continuity check): $(\\Omega_m, \\Omega_\\Lambda, \\Omega_k, z) = (0.3, 0.7, 10^{-12}, 2.0)$. Compute both $S_k(\\chi(z))$ and $\\chi(z)$ and output a boolean indicating whether the relative difference satisfies $\\left|S_k(\\chi) - \\chi\\right|/\\max(1,\\chi)  10^{-10}$.\n\n- Case E (zero-distance boundary): $(\\Omega_m, \\Omega_\\Lambda, \\Omega_k, z) = (0.3, 0.7, 0.0, 0.0)$. Output a boolean indicating whether $S_k(\\chi(0)) = 0$ within machine precision.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[resultA,resultB,resultC,resultD,resultE]\"). The outputs must be in the order of the cases listed above. The first three entries must be floats, the fourth and fifth entries must be booleans. No additional text should be printed.", "solution": "The user wants a numerically robust implementation of the transverse comoving distance function $S_k(\\chi)$ used in cosmology. The solution involves calculating the line-of-sight comoving distance $\\chi(z)$ via numerical integration and then evaluating $S_k(\\chi)$ using its analytical form, with special care for numerical stability near flatness ($k_\\text{geom} \\to 0$).\n\nThe fundamental principles for this problem are drawn from the Friedmann–Robertson–Walker (FRW) model of a homogeneous and isotropic universe. The derivation proceeds in several steps: solving the defining differential equation for $S_k(\\chi)$, analyzing the solution's numerical properties, and devising a robust algorithm.\n\n**1. Formulation and Simplification**\n\nThe problem provides the necessary definitions. The dimensionless Hubble function is given as:\n$$\nE(z) = \\sqrt{\\Omega_m (1+z)^3 + \\Omega_k (1+z)^2 + \\Omega_\\Lambda}\n$$\nThe line-of-sight comoving distance $\\chi$ to a redshift $z$ is the integral of the comoving speed of light:\n$$\n\\chi(z) = \\int_{0}^{z} \\frac{dz'}{E(z')}\n$$\nThe transverse comoving distance $S_k(\\chi)$ is governed by the second-order ordinary differential equation (ODE):\n$$\n\\frac{d^2 S_k}{d\\chi^2} + k_\\text{geom}\\, S_k = 0\n$$\nwith initial conditions $S_k(0) = 0$ and $\\left.\\frac{d S_k}{d\\chi}\\right|_{\\chi=0} = 1$. The spatial curvature constant $k_\\text{geom}$ is related to the curvature density parameter $\\Omega_k$ by $k_\\text{geom} = -\\Omega_k \\frac{H_0^2}{c^2}$.\n\nThe problem specifies using natural units where the Hubble distance $c/H_0 = 1$. This implies $c = H_0$. Substituting this into the expression for $k_\\text{geom}$ yields a significant simplification:\n$$\nk_\\text{geom} = -\\Omega_k \\frac{H_0^2}{H_0^2} = -\\Omega_k\n$$\nThis direct relationship allows us to work with $\\Omega_k$ when determining the geometry.\n\n**2. Analytical Solution of the ODE**\n\nThe ODE for $S_k(\\chi)$ is a linear, homogeneous, second-order equation with a constant coefficient $k_\\text{geom} = -\\Omega_k$. The solution depends on the sign of $k_\\text{geom}$. There are $3$ distinct cases:\n\nCase 1: $k_\\text{geom}  0$ (Closed Universe, $\\Omega_k  0$)\nThe equation is $S_k'' + (\\sqrt{k_\\text{geom}})^2 S_k = 0$. The general solution is $S_k(\\chi) = A \\cos(\\sqrt{k_\\text{geom}}\\chi) + B \\sin(\\sqrt{k_\\text{geom}}\\chi)$. Applying the initial conditions:\n- $S_k(0) = 0 \\implies A = 0$.\n- $S_k'(0) = 1 \\implies B\\sqrt{k_\\text{geom}}\\cos(0) = 1 \\implies B = 1/\\sqrt{k_\\text{geom}}$.\nThe solution is:\n$$\nS_k(\\chi) = \\frac{1}{\\sqrt{k_\\text{geom}}} \\sin(\\sqrt{k_\\text{geom}}\\chi)\n$$\n\nCase 2: $k_\\text{geom}  0$ (Open Universe, $\\Omega_k  0$)\nThe equation is $S_k'' - (\\sqrt{-k_\\text{geom}})^2 S_k = 0$. The general solution is $S_k(\\chi) = A \\cosh(\\sqrt{-k_\\text{geom}}\\chi) + B \\sinh(\\sqrt{-k_\\text{geom}}\\chi)$. Applying the initial conditions:\n- $S_k(0) = 0 \\implies A = 0$.\n- $S_k'(0) = 1 \\implies B\\sqrt{-k_\\text{geom}}\\cosh(0) = 1 \\implies B = 1/\\sqrt{-k_\\text{geom}}$.\nThe solution is:\n$$\nS_k(\\chi) = \\frac{1}{\\sqrt{-k_\\text{geom}}} \\sinh(\\sqrt{-k_\\text{geom}}\\chi)\n$$\n\nCase 3: $k_\\text{geom} = 0$ (Flat Universe, $\\Omega_k = 0$)\nThe equation is $S_k'' = 0$. The general solution is $S_k(\\chi) = A\\chi + B$. Applying the initial conditions:\n- $S_k(0) = 0 \\implies B = 0$.\n- $S_k'(0) = 1 \\implies A = 1$.\nThe solution is:\n$$\nS_k(\\chi) = \\chi\n$$\n\n**3. Numerical Stability Analysis and Algorithm Design**\n\nA naive implementation of these analytical solutions faces numerical issues when $|k_\\text{geom}|$ is very small. For small $x$, $\\sin(x) \\approx x$ and $\\sinh(x) \\approx x$. Direct computation of expressions like $\\sin(\\sqrt{k_\\text{geom}}\\chi)/\\sqrt{k_\\text{geom}}$ for small $k_\\text{geom}$ leads to a form of $0/0$, resulting in catastrophic cancellation and loss of precision.\n\nTo build a robust algorithm, we analyze the behavior of the solutions as $k_\\text{geom} \\to 0$ using Taylor series expansions.\nLet $y = k_\\text{geom}\\chi^2$.\n- For $k_\\text{geom}  0$, $y  0$. The solution can be written as $S_k(\\chi) = \\chi \\frac{\\sin(\\sqrt{y})}{\\sqrt{y}}$. The Taylor series for $\\frac{\\sin(x)}{x}$ is $\\sum_{n=0}^{\\infty} (-1)^n \\frac{x^{2n}}{(2n+1)!}$. Substituting $x = \\sqrt{y}$ gives:\n$$\nS_k(\\chi) = \\chi \\sum_{n=0}^{\\infty} (-1)^n \\frac{y^n}{(2n+1)!} = \\chi \\left(1 - \\frac{y}{6} + \\frac{y^2}{120} - \\ldots\\right)\n$$\n- For $k_\\text{geom}  0$, $y  0$. Let $y' = -y  0$. The solution is $S_k(\\chi) = \\chi \\frac{\\sinh(\\sqrt{y'})}{\\sqrt{y'}}$. The Taylor series for $\\frac{\\sinh(x)}{x}$ is $\\sum_{n=0}^{\\infty} \\frac{x^{2n}}{(2n+1)!}$. Substituting $x = \\sqrt{y'}$ gives:\n$$\nS_k(\\chi) = \\chi \\sum_{n=0}^{\\infty} \\frac{(y')^n}{(2n+1)!} = \\chi \\sum_{n=0}^{\\infty} \\frac{(-y)^n}{(2n+1)!} = \\chi \\left(1 - \\frac{y}{6} + \\frac{y^2}{120} - \\ldots\\right)\n$$\nRemarkably, both cases share the same Taylor series in the variable $y = k_\\text{geom}\\chi^2$. This provides a unified and numerically stable way to compute $S_k(\\chi)$ when $|y|$ is small.\n\nAlgorithm for $S_k(\\chi)$:\n1. Given $\\chi$ and $\\Omega_k$, calculate $k_\\text{geom} = -\\Omega_k$.\n2. If $k_\\text{geom}$ is exactly $0$, return $\\chi$.\n3. If $\\chi$ is exactly $0$, return $0$.\n4. Calculate $y = k_\\text{geom} \\chi^2$.\n5. Choose a threshold, e.g., $TOL = 10^{-8}$. If $|y|  TOL$, compute $S_k(\\chi)$ using a truncated Taylor series to avoid cancellation:\n   $$S_k(\\chi) \\approx \\chi \\left(1 - \\frac{y}{6}\\left(1 - \\frac{y}{20}\\left(1 - \\frac{y}{42}\\right)\\right)\\right)$$\n   This nested form (Horner's method) is efficient and stable for polynomial evaluation.\n6. If $|y| \\ge TOL$, use the standard analytical formulas:\n   - If $k_\\text{geom}  0$, compute $S_k(\\chi) = \\sin(\\sqrt{k_\\text{geom}}\\chi) / \\sqrt{k_\\text{geom}}$.\n   - If $k_\\text{geom}  0$, compute $S_k(\\chi) = \\sinh(\\sqrt{-k_\\text{geom}}\\chi) / \\sqrt{-k_\\text{geom}}$.\n\nAdditionally, for the open universe case ($k_\\text{geom}  0$), the argument of the hyperbolic sine, $\\sqrt{-k_\\text{geom}}\\chi$, can become large, risking floating-point overflow. For the test cases provided, this is not an issue as the arguments remain small. In a general-purpose library, one might switch to a logarithmic representation for large arguments.\n\n**4. Implementation Plan**\n\nThe final program will be structured as follows:\n1. A function `compute_chi(z, Omega_m, Omega_Lambda, Omega_k)` will calculate the comoving distance $\\chi(z)$ by numerically integrating $1/E(z')$ from $z'=0$ to $z$ using `scipy.integrate.quad`. An explicit check for $z=0$ will return $0$ immediately.\n2. A function `compute_Sk_chi(chi, Omega_k)` will implement the robust algorithm described above to calculate $S_k(\\chi)$.\n3. The main `solve()` function will iterate through the $5$ test cases provided in the problem statement.\n4. For each case, it will call `compute_chi` and `compute_Sk_chi` to get the required values.\n5. For cases A, B, and C, the float value of $S_k(\\chi(z))$ is stored.\n6. For case D, the boolean result of the relative difference test, $|\\frac{S_k(\\chi) - \\chi}{\\max(1, \\chi)}|  10^{-10}$, is stored.\n7. For case E, the boolean result of testing if $S_k(\\chi(0))$ is equal to $0$ is stored.\n8. All results will be collected into a list and printed in the specified comma-separated format.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Solves the problem of calculating the transverse comoving distance S_k(chi)\n    for a set of cosmological parameters and redshifts.\n    \"\"\"\n    \n    # (Omega_m, Omega_Lambda, Omega_k, z)\n    # Omega_r is assumed to be 0.\n    # Natural units with c/H_0 = 1 are used.\n    test_cases = [\n        # Case A: Happy path, flat universe\n        (0.3, 0.7, 0.0, 2.0),\n        # Case B: Closed universe\n        (0.3, 0.75, -0.05, 2.0),\n        # Case C: Open universe\n        (0.3, 0.65, 0.05, 2.0),\n        # Case D: Near-flat continuity check\n        (0.3, 0.7, 1e-12, 2.0),\n        # Case E: Zero-distance boundary\n        (0.3, 0.7, 0.0, 0.0),\n    ]\n\n    def _integrand(z_prime, om_m, om_l, om_k):\n        \"\"\"The integrand 1/E(z') for the comoving distance integral.\"\"\"\n        e_z = np.sqrt(om_m * (1 + z_prime)**3 + om_k * (1 + z_prime)**2 + om_l)\n        return 1.0 / e_z\n\n    def compute_chi(z, om_m, om_l, om_k):\n        \"\"\"\n        Calculates the line-of-sight comoving distance chi(z).\n        \"\"\"\n        if z == 0.0:\n            return 0.0\n        \n        # scipy.integrate.quad returns a tuple (result, error_estimate)\n        chi_val, _ = quad(_integrand, 0, z, args=(om_m, om_l, om_k))\n        return chi_val\n\n    def compute_Sk_chi(chi, om_k):\n        \"\"\"\n        Calculates the transverse comoving distance S_k(chi) using a\n        numerically robust algorithm.\n        \"\"\"\n        # In natural units with c/H_0=1, k_geom = -Omega_k\n        k_geom = -om_k\n\n        # Case 1: Flat universe (k_geom = 0)\n        if k_geom == 0.0:\n            return chi\n        \n        # Handle chi=0 boundary condition\n        if chi == 0.0:\n            return 0.0\n\n        # Argument for Taylor expansion/analytical functions\n        y = k_geom * chi**2\n        \n        # Threshold for switching to Taylor series to avoid cancellation error\n        TOLERANCE = 1e-8\n        if abs(y)  TOLERANCE:\n            # S_k(chi) = chi * (1 - y/6 + y^2/120 - y^3/5040 + ...)\n            # Use Horner's method for stable polynomial evaluation\n            val = chi * (1.0 - y / 6.0 * (1.0 - y / 20.0 * (1.0 - y / 42.0)))\n            return val\n        \n        # Case 2: Closed universe (k_geom > 0)\n        if k_geom > 0:\n            sqrt_k = np.sqrt(k_geom)\n            return np.sin(sqrt_k * chi) / sqrt_k\n        # Case 3: Open universe (k_geom  0)\n        else:\n            sqrt_abs_k = np.sqrt(-k_geom)\n            return np.sinh(sqrt_abs_k * chi) / sqrt_abs_k\n\n    results = []\n    \n    # Case A\n    om_m, om_l, om_k, z = test_cases[0]\n    chi = compute_chi(z, om_m, om_l, om_k)\n    Sk_chi = compute_Sk_chi(chi, om_k)\n    results.append(Sk_chi)\n\n    # Case B\n    om_m, om_l, om_k, z = test_cases[1]\n    chi = compute_chi(z, om_m, om_l, om_k)\n    Sk_chi = compute_Sk_chi(chi, om_k)\n    results.append(Sk_chi)\n\n    # Case C\n    om_m, om_l, om_k, z = test_cases[2]\n    chi = compute_chi(z, om_m, om_l, om_k)\n    Sk_chi = compute_Sk_chi(chi, om_k)\n    results.append(Sk_chi)\n\n    # Case D\n    om_m, om_l, om_k, z = test_cases[3]\n    chi = compute_chi(z, om_m, om_l, om_k)\n    Sk_chi = compute_Sk_chi(chi, om_k)\n    relative_difference = abs(Sk_chi - chi) / max(1.0, chi)\n    results.append(relative_difference  1e-10)\n\n    # Case E\n    om_m, om_l, om_k, z = test_cases[4]\n    chi = compute_chi(z, om_m, om_l, om_k)  # This will be 0.0\n    Sk_chi = compute_Sk_chi(chi, om_k)      # This will be 0.0\n    results.append(Sk_chi == 0.0)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3495804"}, {"introduction": "Cosmological models are defined by parameters, like the matter density $\\Omega_m$, which are constrained by observational data. A crucial aspect of modeling is understanding how our predictions depend on these parameters. This advanced practice [@problem_id:3495846] introduces a powerful and efficient method for this task: the Tangent Linear Model, which allows us to directly compute the sensitivity of the cosmic evolution, $\\partial a / \\partial \\Omega_m$. Mastering this technique is a key step towards sophisticated applications like parameter forecasting and uncertainty quantification.", "problem": "Consider a spatially flat Friedmann–Lemaître–Robertson–Walker (FLRW) Universe governed by the first Friedmann equation. Let the Hubble expansion rate normalized by its present value be defined by the dimensionless function $E(a)$, where $a$ is the scale factor, and define the dimensionless time $\\tau$ by $\\tau \\equiv H_0 t$ so that $d\\tau = H_0 \\, dt$. Assume a flat energy budget with a constant radiation density parameter $\\Omega_r$ and a matter density parameter $\\Omega_m$, with dark energy density parameter $\\Omega_\\Lambda$ adjusted to maintain flatness, i.e., $\\Omega_\\Lambda = 1 - \\Omega_m - \\Omega_r$. The normalized Hubble function is $E(a) = \\sqrt{\\Omega_r a^{-4} + \\Omega_m a^{-3} + \\Omega_\\Lambda}$. The scale factor $a(\\tau;\\Omega_m)$ evolves from a strictly positive initial value $a(0;\\Omega_m) = a_i$, independent of $\\Omega_m$, according to the autonomous Ordinary Differential Equation (ODE) $da/d\\tau = a E(a)$.\n\nYour task is to derive, implement, and validate a Tangent Linear Model (TLM) for the sensitivity of the scale factor with respect to the matter density parameter. Define the sensitivity as $s(\\tau) \\equiv \\partial a(\\tau;\\Omega_m)/\\partial \\Omega_m$ evaluated at fixed $\\tau$. Starting only from the first Friedmann equation, the definition of the dimensionless time, and the autonomous ODE for $a(\\tau;\\Omega_m)$, derive the linear ODE satisfied by $s(\\tau)$ of the general form $ds/d\\tau = \\left(\\partial f/\\partial a\\right) s + \\partial f/\\partial \\Omega_m$ with $f(a,\\Omega_m) = a E(a)$, together with an appropriate initial condition consistent with $a(0;\\Omega_m) = a_i$ being independent of $\\Omega_m$. Your derivation must express all partial derivatives explicitly in terms of $a$, $\\Omega_m$, and $\\Omega_r$ without introducing any additional parameters.\n\nThen, implement a numerical solver to compute $a(\\tau;\\Omega_m)$ and $s(\\tau)$ by integrating the ODE for $a$ and the derived TLM for $s$ from $\\tau = 0$ to a given final time $\\tau_f$, starting from $a(0) = a_i$ and the initial condition for $s(\\tau)$ implied by your derivation. Validate the TLM by comparing $s(\\tau_f)$ against a Central Difference (CD) finite-difference estimate computed using the two perturbed solutions $a(\\tau_f;\\Omega_m + \\delta)$ and $a(\\tau_f;\\Omega_m - \\delta)$ via $(a(\\tau_f;\\Omega_m + \\delta) - a(\\tau_f;\\Omega_m - \\delta))/(2 \\delta)$, where $\\delta$ is a small positive number. Use sufficiently strict numerical tolerances in your ODE solver to ensure that the discrepancy between the TLM sensitivity and the central-difference estimate is dominated by truncation in $\\delta$, not by time-integration error.\n\nNo physical units are required because $\\tau$ is dimensionless. Angles do not appear. All reported numerical answers must be real numbers.\n\nTest suite. Your program must evaluate the absolute difference between the TLM sensitivity and the CD estimate for each of the following test cases, each given as a five-tuple $(\\Omega_m,\\Omega_r,\\tau_f,a_i,\\delta)$:\n- Test A: $(0.3, 9 \\times 10^{-5}, 1.0, 10^{-3}, 10^{-5})$.\n- Test B: $(0.3, 9 \\times 10^{-5}, 0.1, 10^{-4}, 10^{-6})$.\n- Test C: $(0.8, 10^{-5}, 0.5, 10^{-3}, 10^{-5})$.\n- Test D: $(0.1, 9 \\times 10^{-5}, 2.0, 10^{-3}, 10^{-5})$.\n\nImplementation requirements:\n- Integrate the ODE for $a(\\tau;\\Omega_m)$ and the TLM for $s(\\tau)$ with strict absolute and relative tolerances to credibly resolve the dynamics for the given parameters.\n- Use the flatness relation $\\Omega_\\Lambda = 1 - \\Omega_m - \\Omega_r$ consistently in all evaluations of $E(a)$ and its derivatives.\n- Ensure the initial condition for $s(\\tau)$ is consistent with $a(0;\\Omega_m) = a_i$ being independent of $\\Omega_m$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The $k$-th entry must be the absolute difference between the TLM sensitivity and the CD estimate for the $k$-th test case in the order A, B, C, D. For example, a valid output has the form $[x_1,x_2,x_3,x_4]$, where each $x_k$ is a real number.", "solution": "The problem is assessed as valid. It is scientifically grounded in standard cosmological principles (the Friedmann equations), is mathematically well-posed with a complete and consistent set of definitions and initial conditions, and is expressed in objective, formal language. The task is a standard, albeit non-trivial, exercise in sensitivity analysis applied to a system of ordinary differential equations (ODEs) describing cosmic expansion.\n\n### Derivation of the Tangent Linear Model (TLM)\n\nThe evolution of the scale factor, $a$, as a function of dimensionless time, $\\tau$, is governed by the autonomous first-order ODE:\n$$\n\\frac{da}{d\\tau} = a E(a) \\equiv f(a, \\Omega_m)\n$$\nHere, $a$ is treated as a function of both $\\tau$ and the matter density parameter $\\Omega_m$, i.e., $a = a(\\tau; \\Omega_m)$. The normalized Hubble function $E(a)$ for a spatially flat universe is given by:\n$$\nE(a) = \\sqrt{\\Omega_r a^{-4} + \\Omega_m a^{-3} + \\Omega_\\Lambda}\n$$\nUsing the flatness condition $\\Omega_r + \\Omega_m + \\Omega_\\Lambda = 1$, we can write $\\Omega_\\Lambda = 1 - \\Omega_m - \\Omega_r$. Substituting this into the expression for $E(a)$ gives:\n$$\nE(a) = \\sqrt{\\Omega_r (a^{-4} - 1) + \\Omega_m (a^{-3} - 1) + 1}\n$$\nThe function $f(a, \\Omega_m)$ is therefore:\n$$\nf(a, \\Omega_m) = a \\sqrt{\\Omega_r (a^{-4} - 1) + \\Omega_m (a^{-3} - 1) + 1}\n$$\nThe sensitivity of the scale factor with respect to the matter density parameter is defined as $s(\\tau) \\equiv \\partial a(\\tau; \\Omega_m) / \\partial \\Omega_m$. To find the governing ODE for $s(\\tau)$, we differentiate the ODE for $a$ with respect to $\\Omega_m$:\n$$\n\\frac{\\partial}{\\partial \\Omega_m} \\left( \\frac{da}{d\\tau} \\right) = \\frac{\\partial f(a, \\Omega_m)}{\\partial \\Omega_m}\n$$\nSince $\\tau$ and $\\Omega_m$ are independent variables, we can interchange the order of differentiation on the left-hand side:\n$$\n\\frac{d}{d\\tau} \\left( \\frac{\\partial a}{\\partial \\Omega_m} \\right) = \\frac{d s}{d\\tau}\n$$\nUsing the multivariate chain rule on the right-hand side, we obtain:\n$$\n\\frac{ds}{d\\tau} = \\frac{\\partial f}{\\partial a} \\frac{\\partial a}{\\partial \\Omega_m} + \\frac{\\partial f}{\\partial \\Omega_m}\n$$\nSubstituting the definition of sensitivity $s = \\partial a / \\partial \\Omega_m$, we arrive at the Tangent Linear Model (TLM) equation, which is a linear, first-order ODE for $s(\\tau)$:\n$$\n\\frac{ds}{d\\tau} = \\left( \\frac{\\partial f}{\\partial a} \\right) s + \\frac{\\partial f}{\\partial \\Omega_m}\n$$\nTo complete the model, we must derive explicit expressions for the partial derivatives $\\partial f / \\partial a$ and $\\partial f / \\partial \\Omega_m$.\n\n#### Calculation of $\\partial f / \\partial a$\nWe differentiate $f(a, \\Omega_m) = a E(a)$ with respect to $a$, holding $\\Omega_m$ constant:\n$$\n\\frac{\\partial f}{\\partial a} = \\frac{\\partial}{\\partial a}(a E(a)) = E(a) + a \\frac{\\partial E(a)}{\\partial a}\n$$\nFirst, we find $\\partial E(a) / \\partial a$ by differentiating $E(a)^2 = \\Omega_r a^{-4} + \\Omega_m a^{-3} + \\Omega_\\Lambda$:\n$$\n2 E(a) \\frac{\\partial E(a)}{\\partial a} = -4 \\Omega_r a^{-5} - 3 \\Omega_m a^{-4}\n$$\n$$\n\\frac{\\partial E(a)}{\\partial a} = \\frac{-4 \\Omega_r a^{-5} - 3 \\Omega_m a^{-4}}{2 E(a)}\n$$\nSubstituting this back into the expression for $\\partial f / \\partial a$:\n$$\n\\frac{\\partial f}{\\partial a} = E(a) + a \\left( \\frac{-4 \\Omega_r a^{-5} - 3 \\Omega_m a^{-4}}{2 E(a)} \\right) = \\frac{2 E(a)^2 - 4 \\Omega_r a^{-4} - 3 \\Omega_m a^{-3}}{2 E(a)}\n$$\nReplacing $E(a)^2$ with its definition:\n$$\n\\frac{\\partial f}{\\partial a} = \\frac{2 (\\Omega_r a^{-4} + \\Omega_m a^{-3} + \\Omega_\\Lambda) - 4 \\Omega_r a^{-4} - 3 \\Omega_m a^{-3}}{2 E(a)}\n$$\n$$\n\\frac{\\partial f}{\\partial a} = \\frac{-2 \\Omega_r a^{-4} - \\Omega_m a^{-3} + 2 \\Omega_\\Lambda}{2 E(a)}\n$$\n\n#### Calculation of $\\partial f / \\partial \\Omega_m$\nWe differentiate $f(a, \\Omega_m) = a E(a)$ with respect to $\\Omega_m$, holding $a$ constant.\n$$\n\\frac{\\partial f}{\\partial \\Omega_m} = a \\frac{\\partial E(a)}{\\partial \\Omega_m}\n$$\nWe use $E(a)^2 = \\Omega_r (a^{-4} - 1) + \\Omega_m (a^{-3} - 1) + 1$. Differentiating with respect to $\\Omega_m$:\n$$\n2 E(a) \\frac{\\partial E(a)}{\\partial \\Omega_m} = a^{-3} - 1\n$$\n$$\n\\frac{\\partial E(a)}{\\partial \\Omega_m} = \\frac{a^{-3} - 1}{2 E(a)}\n$$\nTherefore, the partial derivative of $f$ is:\n$$\n\\frac{\\partial f}{\\partial \\Omega_m} = a \\left( \\frac{a^{-3} - 1}{2 E(a)} \\right) = \\frac{a^{-2} - a}{2 E(a)}\n$$\n\n#### Initial Condition for $s(\\tau)$\nThe problem states that the initial scale factor $a(0; \\Omega_m) = a_i$ is a constant, independent of $\\Omega_m$. The initial condition for the sensitivity, $s(0)$, is found by differentiating the initial condition for $a$ with respect to $\\Omega_m$:\n$$\ns(0) = \\frac{\\partial a(0; \\Omega_m)}{\\partial \\Omega_m} = \\frac{\\partial (a_i)}{\\partial \\Omega_m} = 0\n$$\n\n### Numerical Implementation Strategy\nWe solve the following system of two coupled first-order ODEs for the state vector $Y(\\tau)=[a(\\tau), s(\\tau)]^T$:\n$$\n\\frac{d}{d\\tau}\n\\begin{pmatrix}\na \\\\\ns\n\\end{pmatrix}\n=\n\\begin{pmatrix}\na E(a) \\\\\n\\left( \\frac{-2 \\Omega_r a^{-4} - \\Omega_m a^{-3} + 2 \\Omega_\\Lambda}{2 E(a)} \\right) s + \\left( \\frac{a^{-2} - a}{2 E(a)} \\right)\n\\end{pmatrix}\n$$\nwith the initial conditions $a(0) = a_i$ and $s(0) = 0$. This system is integrated from $\\tau=0$ to $\\tau = \\tau_f$ using a numerical solver. The result for the sensitivity is the value of $s(\\tau_f)$.\n\nFor validation, this result is compared against a second-order accurate Central Difference (CD) estimate. The CD estimate is computed by integrating the original ODE, $da/d\\tau = a E(a)$, twice:\n1.  Once with the parameter $\\Omega_m + \\delta$, yielding $a_+(\\tau_f) = a(\\tau_f; \\Omega_m + \\delta, \\Omega_r)$.\n2.  Once with the parameter $\\Omega_m - \\delta$, yielding $a_-(\\tau_f) = a(\\tau_f; \\Omega_m - \\delta, \\Omega_r)$.\n\nThe CD estimate for the sensitivity is then:\n$$\ns_{CD}(\\tau_f) = \\frac{a_+(\\tau_f) - a_-(\\tau_f)}{2 \\delta}\n$$\nThe final output is the absolute difference $|s(\\tau_f) - s_{CD}(\\tau_f)|$. All integrations are performed using `scipy.integrate.solve_ivp` with strict tolerances ($atol = 10^{-12}$, $rtol = 10^{-12}$) to minimize numerical integration error.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Derives, implements, and validates a Tangent Linear Model for the sensitivity\n    of the cosmological scale factor with respect to the matter density parameter.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0.3, 9e-5, 1.0, 1e-3, 1e-5),  # Test A\n        (0.3, 9e-5, 0.1, 1e-4, 1e-6),  # Test B\n        (0.8, 1e-5, 0.5, 1e-3, 1e-5),  # Test C\n        (0.1, 9e-5, 2.0, 1e-3, 1e-5),  # Test D\n    ]\n\n    results = []\n\n    # ODE system for the scale factor 'a' and its sensitivity 's'\n    def coupled_system(tau, y, Omega_m, Omega_r):\n        a, s = y\n        \n        # Avoid division by zero or negative roots if 'a' becomes non-positive.\n        if a = 0:\n            return np.array([0., 0.])\n\n        Omega_L = 1.0 - Omega_m - Omega_r\n        \n        a_inv = 1.0 / a\n        a_inv2 = a_inv * a_inv\n        a_inv3 = a_inv2 * a_inv\n        a_inv4 = a_inv3 * a_inv\n\n        E_squared = Omega_r * a_inv4 + Omega_m * a_inv3 + Omega_L\n        E = np.sqrt(E_squared)\n\n        # Evolution equation for a\n        f_a = a * E\n        da_dtau = f_a\n\n        # Partial derivatives for the sensitivity equation\n        # df/da = (-2*Or*a^-4 - Om*a^-3 + 2*OL) / (2*E)\n        df_da_num = -2.0 * Omega_r * a_inv4 - Omega_m * a_inv3 + 2.0 * Omega_L\n        df_da = df_da_num / (2.0 * E)\n\n        # df/dOm = (a^-2 - a) / (2*E)\n        df_dOm_num = a_inv2 - a\n        df_dOm = df_dOm_num / (2.0 * E)\n\n        # Evolution equation for s\n        ds_dtau = df_da * s + df_dOm\n        \n        return np.array([da_dtau, ds_dtau])\n\n    # ODE system for the scale factor 'a' only, for Central Difference calculation\n    def a_only_system(tau, a, Omega_m, Omega_r):\n        if a = 0:\n            return 0.\n        \n        Omega_L = 1.0 - Omega_m - Omega_r\n        \n        # Use a single-element array for the state vector\n        a_val = a[0] \n        E_squared = Omega_r * a_val**-4 + Omega_m * a_val**-3 + Omega_L\n        E = np.sqrt(E_squared)\n        \n        da_dtau = a_val * E\n        return np.array([da_dtau])\n\n    # Numerical integration tolerances\n    rtol = 1e-12\n    atol = 1e-12\n\n    for case in test_cases:\n        Omega_m, Omega_r, tau_f, a_i, delta = case\n\n        # 1. Solve the coupled system for the TLM sensitivity\n        y0_coupled = np.array([a_i, 0.0])\n        t_span = np.array([0., tau_f])\n        \n        sol_tlm = solve_ivp(\n            coupled_system, t_span, y0_coupled,\n            args=(Omega_m, Omega_r),\n            rtol=rtol, atol=atol,\n            method='RK45'\n        )\n        s_tlm = sol_tlm.y[1, -1]\n\n        # 2. Compute the Central Difference estimate\n        y0_a = np.array([a_i])\n\n        # Perturbed '+' solution\n        sol_p = solve_ivp(\n            a_only_system, t_span, y0_a,\n            args=(Omega_m + delta, Omega_r),\n            rtol=rtol, atol=atol,\n            method='RK45'\n        )\n        a_plus = sol_p.y[0, -1]\n\n        # Perturbed '-' solution\n        sol_m = solve_ivp(\n            a_only_system, t_span, y0_a,\n            args=(Omega_m - delta, Omega_r),\n            rtol=rtol, atol=atol,\n            method='RK45'\n        )\n        a_minus = sol_m.y[0, -1]\n\n        s_cd = (a_plus - a_minus) / (2.0 * delta)\n\n        # 3. Calculate the absolute difference\n        abs_diff = np.abs(s_tlm - s_cd)\n        results.append(abs_diff)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3495846"}]}