{"hands_on_practices": [{"introduction": "A cornerstone of practical cosmology is the calculation of distances, which depend on the spatial curvature of the universe. This geometry is encoded in the function $S_k(\\chi)$, which relates the comoving radial coordinate $\\chi$ to a physical distance measure. This exercise guides you through building a numerically stable routine to evaluate $S_k(\\chi)$ by combining its exact analytical forms with a Maclaurin series expansion, a crucial technique to avoid catastrophic cancellation errors near $\\chi=0$ and ensure precision across all scales [@problem_id:3496187].", "problem": "Consider the spatial sections of the Friedmann-Lemaître-Robertson-Walker (FLRW) metric, which are three-dimensional constant-curvature spaces characterized by a curvature parameter $k \\in \\{-1,0,+1\\}$. Let $S_k(\\chi)$ denote the unique function $S : \\mathbb{R} \\to \\mathbb{R}$ solving the initial value problem\n$$\n\\frac{d^2 S}{d \\chi^2} + k\\, S = 0, \\quad S(0) = 0, \\quad \\frac{d S}{d \\chi}(0) = 1,\n$$\nwhere $\\chi$ is the comoving radial coordinate. This function encodes the geometry of spatial geodesics in constant-curvature spaces and appears in line-of-sight distance calculations within the FLRW framework of numerical cosmology.\n\nYour task is to develop a unified numerical routine that evaluates $S_k(\\chi)$ stably for all $k \\in \\{-1,0,+1\\}$ and for a wide range of $\\chi$ values. The routine must satisfy the following requirements:\n\n1. It must rely on stable formulas and series expansions that avoid loss of significance for small $|\\chi|$ and maintain reliability for moderate to large $|\\chi|$.\n2. It must automatically select between truncated Maclaurin series evaluation and direct evaluation formulas depending on $|\\chi|$, using a principled threshold based on floating-point machine precision.\n3. It must be robust for both positive and negative $\\chi$.\n4. Angles must be treated in radians. The coordinate $\\chi$ is dimensionless and must be provided in radians.\n\nYou are expected to design the algorithm starting from a fundamental base grounded in the geometric properties of constant-curvature spaces embodied by the above initial value problem and the regularity conditions at $\\chi = 0$. Do not assume or use any pre-supplied closed-form expressions for $S_k(\\chi)$ in the problem statement; rather, deduce and implement numerically stable evaluation strategies that are consistent with the differential equation, the initial conditions, and the analytic structure of the solutions.\n\nImplement the routine in a complete, runnable program. The program must evaluate $S_k(\\chi)$ for the following test suite of cases that probe distinct numerical regimes:\n\n- Case 1: $k=+1$, $\\chi = 10^{-12}$.\n- Case 2: $k=-1$, $\\chi = 10^{-12}$.\n- Case 3: $k=0$, $\\chi = 10^{-12}$.\n- Case 4: $k=+1$, $\\chi = \\pi - 10^{-12}$.\n- Case 5: $k=-1$, $\\chi = 20$.\n- Case 6: $k=+1$, $\\chi = 20$.\n- Case 7: $k=-1$, $\\chi = -20$.\n- Case 8: $k=0$, $\\chi = -3.5$.\n- Case 9: $k=+1$, $\\chi = 0$.\n- Case 10: $k=-1$, $\\chi = 0$.\n\nThe required final output format is a single line containing the results of these cases as a comma-separated list enclosed in square brackets, in the order listed above. Each entry must be a floating-point number representing $S_k(\\chi)$ in radians for the given input pair. For example, the output should look like \"[result1,result2,result3,...]\".\n\nAll angles must be in radians. Express all numerical outputs as floating-point numbers. No percentage signs are permitted in any output. The program must be fully self-contained and must not require any external input. The evaluations must be numerically stable and consistent with the defining properties of $S_k(\\chi)$ across the specified regimes.", "solution": "The problem requires the development of a numerically stable routine to evaluate the function $S_k(\\chi)$, defined as the unique solution to the initial value problem (IVP):\n$$\n\\frac{d^2 S}{d \\chi^2} + k\\, S = 0, \\quad S(0) = 0, \\quad \\frac{d S}{d \\chi}(0) = 1,\n$$\nfor the curvature parameter $k \\in \\{-1, 0, +1\\}$. This function is fundamental in the description of spatial geometry within the Friedmann-Lemaître-Robertson-Walker (FLRW) cosmological model.\n\nThe solution will be developed by first deriving the analytic expressions for $S_k(\\chi)$ for each value of $k$, then formulating a unified Maclaurin series representation, and finally designing a hybrid numerical algorithm that combines these forms to ensure stability and accuracy across all required regimes.\n\n### Derivation of Analytic Solutions\n\nWe solve the second-order linear ordinary differential equation (ODE) for each case of $k$.\n\n**Case 1: $k = +1$ (Spherical Geometry)**\nThe ODE is $\\frac{d^2 S}{d \\chi^2} + S = 0$. The general solution is $S(\\chi) = A \\cos(\\chi) + B \\sin(\\chi)$. We apply the initial conditions:\n1.  $S(0) = 0 \\implies A \\cos(0) + B \\sin(0) = A \\cdot 1 + B \\cdot 0 = A = 0$.\n2.  The solution simplifies to $S(\\chi) = B \\sin(\\chi)$. The derivative is $\\frac{dS}{d\\chi} = B \\cos(\\chi)$.\n3.  $\\frac{dS}{d\\chi}(0) = 1 \\implies B \\cos(0) = B \\cdot 1 = B = 1$.\nThus, the unique solution is $S_{+1}(\\chi) = \\sin(\\chi)$.\n\n**Case 2: $k = -1$ (Hyperbolic Geometry)**\nThe ODE is $\\frac{d^2 S}{d \\chi^2} - S = 0$. The general solution is $S(\\chi) = A \\cosh(\\chi) + B \\sinh(\\chi)$. Applying the initial conditions:\n1.  $S(0) = 0 \\implies A \\cosh(0) + B \\sinh(0) = A \\cdot 1 + B \\cdot 0 = A = 0$.\n2.  The solution is $S(\\chi) = B \\sinh(\\chi)$. The derivative is $\\frac{dS}{d\\chi} = B \\cosh(\\chi)$.\n3.  $\\frac{dS}{d\\chi}(0) = 1 \\implies B \\cosh(0) = B \\cdot 1 = B = 1$.\nThus, the unique solution is $S_{-1}(\\chi) = \\sinh(\\chi)$.\n\n**Case 3: $k = 0$ (Euclidean/Flat Geometry)**\nThe ODE is $\\frac{d^2 S}{d \\chi^2} = 0$. Integrating once yields $\\frac{dS}{d\\chi} = C_1$.\n1.  Applying $\\frac{dS}{d\\chi}(0) = 1$, we find $C_1 = 1$.\n2.  Integrating $\\frac{dS}{d\\chi} = 1$ yields $S(\\chi) = \\chi + C_2$.\n3.  Applying $S(0) = 0$, we find $0 + C_2 = 0 \\implies C_2 = 0$.\nThus, the unique solution is $S_{0}(\\chi) = \\chi$.\n\n### Unified Series Representation\nTo develop a unified evaluation strategy, particularly for small values of $|\\chi|$, we derive the Maclaurin series for $S_k(\\chi)$ directly from the ODE. Let $S_k(\\chi) = \\sum_{n=0}^\\infty c_n \\chi^n$.\nThe initial conditions $S(0)=0$ and $S'(0)=1$ immediately give $c_0 = 0$ and $c_1 = 1$.\nSubstituting the series into the ODE, $S''(\\chi) = -k S(\\chi)$, gives:\n$$\n\\sum_{n=2}^\\infty n(n-1)c_n \\chi^{n-2} = -k \\sum_{n=0}^\\infty c_n \\chi^n\n$$\nRe-indexing the left-hand side with $j = n-2$:\n$$\n\\sum_{j=0}^\\infty (j+2)(j+1)c_{j+2} \\chi^j = -k \\sum_{j=0}^\\infty c_j \\chi^j\n$$\nBy comparing coefficients of $\\chi^j$, we obtain the recurrence relation: $c_{j+2} = \\frac{-k}{(j+2)(j+1)}c_j$.\nSince $c_0 = 0$, the recurrence implies that all even coefficients $c_{2m}$ are zero.\nFor the odd coefficients, starting with $c_1=1$:\n$c_3 = \\frac{-k}{3 \\cdot 2} c_1 = \\frac{-k}{3!}$\n$c_5 = \\frac{-k}{5 \\cdot 4} c_3 = \\frac{-k}{5 \\cdot 4}\\left(\\frac{-k}{3!}\\right) = \\frac{(-k)^2}{5!}$\nThe general odd coefficient is $c_{2m+1} = \\frac{(-k)^m}{(2m+1)!}$.\nThis yields the unified series representation valid for all $k$:\n$$\nS_k(\\chi) = \\sum_{m=0}^\\infty \\frac{(-k)^m}{(2m+1)!} \\chi^{2m+1} = \\chi - k \\frac{\\chi^3}{3!} + k^2 \\frac{\\chi^5}{5!} - \\dots\n$$\nThis series correctly reproduces $\\sin(\\chi)$, $\\sinh(\\chi)$, and $\\chi$ for $k=+1$, $k=-1$, and $k=0$, respectively.\n\n### Numerical Stability and Algorithmic Design\nA robust numerical routine must handle different regimes of $\\chi$.\n1.  **Large $|\\chi|$:** For values of $|\\chi|$ not close to zero, the direct analytic formulae $S_{+1}(\\chi) = \\sin(\\chi)$ and $S_{-1}(\\chi) = \\sinh(\\chi)$ can be used. High-quality library implementations of these functions (like those in `numpy`) are optimized for accuracy and performance, including proper argument reduction for trigonometric functions.\n2.  **Small $|\\chi|$:** For values of $|\\chi|$ approaching zero, direct evaluation can be problematic. For example, computing $\\sinh(\\chi) = (\\exp(\\chi)-\\exp(-\\chi))/2$ involves the subtraction of two numbers close to $1$, leading to catastrophic cancellation and loss of precision. In this regime, the Maclaurin series is the numerically superior method. It is an additive series where the first term dominates, avoiding subtractive cancellation.\n\nThe algorithm will therefore be a hybrid:\n- If $|\\chi|$ is below a certain threshold `TOL`, use the truncated Maclaurin series.\n- If $|\\chi|$ is at or above `TOL`, use the direct analytic functions.\n\n### Threshold Selection\nThe threshold `TOL` must be chosen based on a principled analysis of numerical errors. Let's use the series truncated after the $\\chi^5$ term:\n$$\nP_5(\\chi) = \\chi - k\\frac{\\chi^3}{6} + k^2\\frac{\\chi^5}{120}\n$$\nThe first neglected term is $-k^3\\frac{\\chi^7}{7!}$. The relative truncation error is approximately its magnitude divided by the magnitude of $S_k(\\chi) \\approx \\chi$:\n$$\n\\text{Relative Error} \\approx \\frac{|-k^3 \\chi^7/5040|}{|\\chi|} = \\frac{|k|^3 |\\chi|^6}{5040} = \\frac{\\chi^6}{5040} \\quad (\\text{for } k=\\pm1)\n$$\nWe require this error to be substantially smaller than the machine epsilon for double-precision floating-point numbers, $\\epsilon_{mach} \\approx 2.22 \\times 10^{-16}$. A conservative choice for the threshold is $\\text{TOL} = 10^{-4}$. At this value, the relative error is on the order of $(10^{-4})^6 / 5040 = 10^{-24}/5040$, which is many orders of magnitude smaller than $\\epsilon_{mach}$, guaranteeing that the series approximation is highly accurate within this domain.\n\n### Final Algorithm\nThe implemented function `S_k(k, chi)` will proceed as follows:\n1.  If $k=0$, the solution is exact and trivial: return $\\chi$.\n2.  For $k \\in \\{-1, +1\\}$, check if $|\\chi|  \\text{TOL} = 10^{-4}$.\n3.  If it is, calculate $S_k(\\chi)$ using the truncated Maclaurin series. To optimize for precision and efficiency, we use a nested (Horner's method) form of the series up to the $\\chi^5$ term:\n    $$\n    S_k(\\chi) \\approx \\chi \\left(1 - \\frac{k\\chi^2}{6} \\left(1 - \\frac{k\\chi^2}{20}\\right)\\right)\n    $$\n    This is equivalent to $ \\chi - k\\frac{\\chi^3}{6} + k^2\\frac{\\chi^5}{120} $.\n4.  If $|\\chi| \\ge \\text{TOL}$, evaluate the corresponding analytic function: $\\sin(\\chi)$ for $k=+1$ and $\\sinh(\\chi)$ for $k=-1$.\n\nThis approach ensures stability, accuracy, and is grounded in the fundamental properties of the defining initial value problem. The function is intrinsically odd, $S_k(-\\chi) = -S_k(\\chi)$, a property which is respected by all forms of the evaluation (analytic formulae and series expansion), so no special handling for negative $\\chi$ beyond using its value is necessary.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef S_k_eval(k: int, chi: float) - float:\n    \"\"\"\n    Evaluates the function S_k(chi) based on the FLRW metric geometry.\n\n    S_k(chi) is the unique solution to the initial value problem:\n    d^2S/d(chi)^2 + k*S = 0, with S(0) = 0 and dS/d(chi)|_{chi=0} = 1.\n\n    Args:\n        k (int): The curvature parameter, one of {-1, 0, +1}.\n        chi (float): The comoving radial coordinate in radians.\n\n    Returns:\n        float: The value of S_k(chi).\n    \"\"\"\n    # Case k=0 (flat space) is trivial\n    if k == 0:\n        return float(chi)\n\n    # Threshold for |chi| below which the Maclaurin series expansion is used.\n    # The threshold is chosen such that for |chi|  TOL, the truncated series\n    # provides precision far exceeding standard floating-point capabilities,\n    # and potential cancellation errors in direct formulas are avoided.\n    # The relative error of the series truncated at the chi^5 term is ~|chi|^6/5040.\n    # At chi=1e-4, this is ~1e-24/5040, far below machine epsilon (~2.22e-16).\n    TOL = 1e-4\n\n    if abs(chi)  TOL:\n        # For small |chi|, use the Maclaurin series to avoid loss of precision:\n        # S_k(chi) = chi - k*chi^3/6 + k^2*chi^5/120 - ...\n        # This is evaluated using a nested (Horner-like) form for stability.\n        if chi == 0.0:\n            return 0.0\n        \n        chi2 = chi * chi\n        # Series truncated after the chi^5 term:\n        # chi * (1 - k*chi^2/6 + k^2*chi^4/120) = chi * (1 - k*chi^2/6 * (1 - k*chi^2/20))\n        return chi * (1.0 - k * chi2 / 6.0 * (1.0 - k * chi2 / 20.0))\n    else:\n        # For larger |chi|, direct evaluation using standard library functions is stable and efficient.\n        if k == 1: # Spherical case\n            return np.sin(chi)\n        elif k == -1: # Hyperbolic case\n            return np.sinh(chi)\n        else:\n            # This path should ideally not be reached given k is in {-1, 0, 1}\n            raise ValueError(\"k must be -1, 0, or 1\")\n\ndef solve():\n    \"\"\"\n    Runs the specified test suite for the S_k(chi) evaluation function.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (k, chi)\n        (1, 1e-12),               # Case 1: k=+1, chi = 1e-12\n        (-1, 1e-12),              # Case 2: k=-1, chi = 1e-12\n        (0, 1e-12),               # Case 3: k=0, chi = 1e-12\n        (1, np.pi - 1e-12),       # Case 4: k=+1, chi = pi - 1e-12\n        (-1, 20.0),               # Case 5: k=-1, chi = 20\n        (1, 20.0),                # Case 6: k=+1, chi = 20\n        (-1, -20.0),              # Case 7: k=-1, chi = -20\n        (0, -3.5),                # Case 8: k=0, chi = -3.5\n        (1, 0.0),                 # Case 9: k=+1, chi = 0\n        (-1, 0.0),                # Case 10: k=-1, chi = 0\n    ]\n\n    results = []\n    for k, chi in test_cases:\n        result = S_k_eval(k, chi)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The str() function provides a standard, high-precision representation.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3496187"}, {"introduction": "The cosmological redshift is a fundamental prediction of the FLRW model, directly linking the expansion of the universe to the stretching of light's wavelength. Rather than taking the relation $1+z = a_0/a_e$ for granted, this practice challenges you to derive it from first principles. By numerically integrating the null geodesic equations for a photon's energy and path through an expanding spacetime, you will see how this famous relationship emerges directly from the geometry of the universe, providing a deep, computational insight into this cornerstone of observational cosmology [@problem_id:3496232].", "problem": "You are tasked with building a complete, runnable program that numerically ray-traces photon geodesics in a Friedmann–Lemaître–Robertson–Walker (FLRW) spacetime and simultaneously evolves photon energy along the geodesic to verify the cosmological redshift relation across varying emission histories. The program must be constructed from first principles and core definitions, and must not rely on pre-coded shortcuts for the target relations. Your derivation and implementation must start from the Friedmann–Lemaître–Robertson–Walker (FLRW) metric, the definition of null geodesics, and the Friedmann equation for the Hubble expansion rate.\n\nThe fundamental base you must use is:\n- The FLRW line element for a spatially homogeneous and isotropic universe, given by $ds^2 = -c^2\\,dt^2 + a(t)^2\\,\\left[\\frac{dr^2}{1-k r^2} + r^2(d\\theta^2 + \\sin^2\\theta\\, d\\phi^2)\\right]$, where $c$ is the speed of light, $a(t)$ is the scale factor, $r$ is the comoving radial coordinate, and $k \\in \\{-1,0,+1\\}$ encodes spatial curvature.\n- The assumption of a radial photon trajectory implies $d\\theta = d\\phi = 0$ and the null condition $ds^2=0$.\n- The Hubble expansion rate defined by the Friedmann equation in terms of the scale factor $a$ and present-day parameters: $H(a) = H_0 \\sqrt{\\Omega_r a^{-4} + \\Omega_m a^{-3} + \\Omega_k a^{-2} + \\Omega_\\Lambda}$, where $\\Omega_k = 1 - (\\Omega_r + \\Omega_m + \\Omega_\\Lambda)$.\n- The definition of cosmological redshift for a photon emitted at scale factor $a_e$ and observed today at scale factor $a_0$ (with $a_0$ fixed to $1$ by convention): $(1+z)$ is the ratio of observed wavelength to emitted wavelength measured by comoving observers.\n\nYour program must implement the following, derived from the above base:\n1. A numerical integration of the radial null geodesic to obtain the comoving distance $r$ between an emission event at scale factor $a_e$ and the observer today at $a_0$. Use a scientifically sound numerical method based on the geodesic equation, expressed with the independent variable chosen to avoid stiffness where appropriate.\n2. A numerical evolution of photon energy $E$ along the geodesic using a dynamical equation consistent with the null geodesic and the cosmological expansion, so that the scaling $E \\propto 1/a$ emerges from the computation rather than being imposed. From the numerically evolved $E$, compute a numerical estimate of the redshift.\n3. A verification step that compares the numerically obtained redshift to the theoretical redshift for each emission event across an arbitrary time-dependent emission history $E_{\\mathrm{emit}}(a_e)$, demonstrating independence of the intrinsic emission variability.\n\nPhysical and numerical units and normalization:\n- Use $a_0 = 1$.\n- Use $c$ in $\\mathrm{m/s}$, $H_0$ in $\\mathrm{km/s/Mpc}$ converted internally to $\\mathrm{s^{-1}}$, and produce comoving distances in megaparsecs ($\\mathrm{Mpc}$).\n- Energies may be treated in arbitrary units since only ratios enter $(1+z)$; report redshift verification as dimensionless differences.\n\nAngle units are not involved in this computation. If you choose to parameterize trigonometric emission histories, use arguments in radians by default.\n\nDesign a test suite that exercises:\n- A general flat Lambda-Cold Dark Matter cosmology.\n- A pure matter-dominated flat cosmology.\n- A toy radiation-dominated flat cosmology probing the early universe.\n- A cosmology dominated by the cosmological constant at late times.\n\nFor each test case, sample multiple emission events across a specified range of emission scale factors $a_e \\in [a_{\\min}, a_{\\max}]$ using a numerically sensible spacing. For each emission event, use a nontrivial emission history with time-varying emitted energy defined by $E_{\\mathrm{emit}}(a) = E_0 \\left(1 + A \\sin(\\alpha \\ln a) + B\\, a^\\beta\\right)$, where $E_0$, $A$, $B$, $\\alpha$, and $\\beta$ are case-specific parameters. Your program must:\n- Numerically evolve $E(a)$ from $a_e$ to $a_0$ and compute the numerical redshift $z_{\\mathrm{num}} = E_{\\mathrm{emit}}(a_e)/E_{\\mathrm{obs}} - 1$.\n- Compute the theoretical redshift $z_{\\mathrm{theory}} = a_0/a_e - 1$.\n- Report, for each test case, the maximum absolute discrepancy $\\max |z_{\\mathrm{num}} - z_{\\mathrm{theory}}|$ across its emission events, and the comoving distance to the earliest emission event in that case expressed in $\\mathrm{Mpc}$.\n\nSpecify the following test suite explicitly:\n- Test case $1$ (flat Lambda-Cold Dark Matter): $H_0 = 70\\,\\mathrm{km/s/Mpc}$, $\\Omega_m = 0.3$, $\\Omega_r = 9\\times 10^{-5}$, $\\Omega_\\Lambda = 0.69991$ (so that $\\Omega_k = 0$), emission scale factors $a_e \\in [0.2, 0.95]$, with parameters $E_0 = 1$, $A = 0.2$, $B = 0.1$, $\\alpha = 5$, $\\beta = 0.3$.\n- Test case $2$ (flat matter-dominated): $H_0 = 50\\,\\mathrm{km/s/Mpc}$, $\\Omega_m = 1$, $\\Omega_r = 0$, $\\Omega_\\Lambda = 0$ (so that $\\Omega_k = 0$), emission scale factors $a_e \\in [0.05, 0.9]$, with parameters $E_0 = 1$, $A = 0.2$, $B = 0.1$, $\\alpha = 3$, $\\beta = 0.5$.\n- Test case $3$ (flat toy radiation-dominated): $H_0 = 70\\,\\mathrm{km/s/Mpc}$, $\\Omega_r = 9.999\\times 10^{-1}$, $\\Omega_m = 10^{-4}$, $\\Omega_\\Lambda = 0$ (so that $\\Omega_k = 0$), emission scale factors $a_e \\in [10^{-6}, 10^{-4}]$, with parameters $E_0 = 1$, $A = 0.2$, $B = 0.1$, $\\alpha = 8$, $\\beta = 0.2$.\n- Test case $4$ (flat late-time cosmological-constant dominated): $H_0 = 70\\,\\mathrm{km/s/Mpc}$, $\\Omega_m = 10^{-2}$, $\\Omega_r = 9\\times 10^{-5}$, $\\Omega_\\Lambda = 0.98991$ (so that $\\Omega_k = 0$), emission scale factors $a_e \\in [0.8, 0.999]$, with parameters $E_0 = 1$, $A = 0.2$, $B = 0.1$, $\\alpha = 4$, $\\beta = 0.7$.\n\nUse a sample size of at least $5$ emission events per test case, spaced appropriately across the specified $a_e$ interval to probe both low and high redshifts and numerically sensitive regimes.\n\nYour program should produce a single line of output containing the eight results (two per test case, in order of the four test cases): the four maximum absolute discrepancies followed by the four comoving distances. The format must be a comma-separated list enclosed in square brackets, for example $[\\delta_1,D_1,\\delta_2,D_2,\\delta_3,D_3,\\delta_4,D_4]$, where each $\\delta_i$ is a dimensionless float and each $D_i$ is a float in $\\mathrm{Mpc}$.", "solution": "The problem requires the numerical verification of the cosmological redshift relation from first principles, specifically the Friedmann-Lemaître-Robertson-Walker (FLRW) metric and the geodesic equation for photons. This is accomplished by numerically integrating the equations of motion for a photon's energy and path in an expanding universe for several cosmological models. The core of the task is to demonstrate that the well-known energy-redshift relation, $E \\propto 1/a(t)$, where $E$ is the photon energy and $a(t)$ is the scale factor, emerges naturally from the underlying geometry of spacetime, rather than being assumed a priori.\n\nThe solution is divided into two main derivations followed by their numerical implementation:\n1.  Derivation and computation of the comoving distance to an object emitting a photon at a scale factor $a_e$.\n2.  Derivation and numerical integration of the differential equation governing photon energy evolution along its geodesic.\n\n**1. Comoving Distance Calculation**\n\nThe starting point is the FLRW line element:\n$$ds^2 = -c^2\\,dt^2 + a(t)^2\\,\\left[\\frac{dr^2}{1-k r^2} + r^2(d\\theta^2 + \\sin^2\\theta\\, d\\phi^2)\\right]$$\nFor a photon traveling along a radial trajectory from an emitter to an observer at the origin, we have $d\\theta = 0$ and $d\\phi = 0$. The null condition for a photon is $ds^2 = 0$. This simplifies the metric equation to:\n$$c^2\\,dt^2 = a(t)^2 \\frac{dr^2}{1-kr^2}$$\nTaking the square root and rearranging, we relate the infinitesimal changes in coordinate time $dt$ and comoving radial coordinate $dr$:\n$$c \\frac{dt}{a(t)} = \\pm \\frac{dr}{\\sqrt{1-kr^2}}$$\nAs the photon travels from the emitter at $r_e$ towards the observer at $r=0$, its radial coordinate decreases, so $dr  0$. We choose the negative sign to keep both sides positive:\n$$\\frac{dr}{\\sqrt{1-kr^2}} = -c \\frac{dt}{a(t)}$$\nThe test cases specified in the problem are for flat universes, where the curvature parameter $k=0$. This simplification yields $dr = -c\\,dt/a(t)$.\nTo compute the total comoving distance $r_e$ to the emitter, we integrate from the time of emission $t_e$ to the time of observation $t_0$:\n$$r_e = \\int_0^{r_e} dr' = \\int_{t_e}^{t_0} \\frac{c\\,dt}{a(t)}$$\nFor numerical integration, it is more convenient to change the integration variable from time $t$ to the scale factor $a$. Using the definition of the Hubble parameter, $H = \\dot{a}/a = (1/a)(da/dt)$, we can write $dt = da/(aH)$. Substituting this into the integral gives:\n$$r_e = \\int_{a_e}^{a_0} \\frac{c\\,da}{a(t) \\cdot a(t) H(a)} = c \\int_{a_e}^{a_0} \\frac{da}{a^2 H(a)}$$\nThe problem specifies the observer is \"today\", so we set $a_0 = 1$. The Hubble parameter's evolution is given by the Friedmann equation:\n$$H(a) = H_0 \\sqrt{\\Omega_r a^{-4} + \\Omega_m a^{-3} + \\Omega_k a^{-2} + \\Omega_\\Lambda}$$\nAll test cases use parameters such that $\\Omega_k = 1 - (\\Omega_r + \\Omega_m + \\Omega_\\Lambda) = 0$. The comoving distance to the earliest emission event ($a_e = a_{\\min}$) in each test case is thus calculated by the definite integral:\n$$r(a_{\\min}) = c \\int_{a_{\\min}}^{1} \\frac{da}{a^2 H_0 \\sqrt{\\Omega_r a^{-4} + \\Omega_m a^{-3} + \\Omega_\\Lambda}}$$\nBy factoring out constants, we can write this in a form useful for computation:\n$$r(a_{\\min}) = \\frac{c}{H_0} \\int_{a_{\\min}}^{1} \\frac{da}{a^2 \\sqrt{\\Omega_r a^{-4} + \\Omega_m a^{-3} + \\Omega_\\Lambda}}$$\nIf $c$ is expressed in $\\mathrm{km/s}$ and $H_0$ in $\\mathrm{km/s/Mpc}$, the pre-factor $c/H_0$ (the Hubble distance) is in units of $\\mathrm{Mpc}$, and the integral is dimensionless. The comoving distance is computed numerically using the `scipy.integrate.quad` function.\n\n**2. Photon Energy Evolution**\n\nTo verify the redshift relation, we must derive the evolution of a photon's energy $E$ from the geodesic equation without assuming the result $E \\propto 1/a$. The energy of a photon as measured by a comoving observer with 4-velocity $U^\\mu$ is $E = -g_{\\mu\\nu} P^\\mu U^\\nu$, where $P^\\mu = dx^\\mu/d\\lambda$ is the photon's 4-momentum with $\\lambda$ being an affine parameter.\nFor a comoving observer, $U^\\mu = (1, 0, 0, 0)$ in $(t, r, \\theta, \\phi)$ coordinates, and the metric component $g_{tt}=-c^2$. The energy is $E = -g_{tt} P^t U^t = c^2 P^t = c^2 (dt/d\\lambda)$. Thus, the energy evolution is determined by the evolution of the time component of the 4-momentum, $P^t$.\nThe geodesic equation is:\n$$\\frac{dP^\\mu}{d\\lambda} + \\Gamma^\\mu_{\\alpha\\beta} P^\\alpha P^\\beta = 0$$\nFor the time component ($\\mu=t$), this is $\\frac{dP^t}{d\\lambda} + \\Gamma^t_{\\alpha\\beta} P^\\alpha P^\\beta = 0$. For a radial geodesic, only $P^t$ and $P^r$ are non-zero. The only relevant Christoffel symbol is $\\Gamma^t_{rr}$. For the FLRW metric, it is $\\Gamma^t_{rr} = \\frac{a\\dot{a}}{c^2(1-kr^2)}$. The geodesic equation becomes:\n$$\\frac{dP^t}{d\\lambda} + \\Gamma^t_{rr} (P^r)^2 = 0$$\nThe null condition $g_{\\mu\\nu}P^\\mu P^\\nu=0$ yields $-c^2 (P^t)^2 + g_{rr} (P^r)^2 = 0$, which implies $(P^r)^2 = \\frac{c^2}{g_{rr}} (P^t)^2 = \\frac{c^2(1-kr^2)}{a^2} (P^t)^2$. Substituting this into the geodesic equation:\n$$\\frac{dP^t}{d\\lambda} + \\left(\\frac{a\\dot{a}}{c^2(1-kr^2)}\\right) \\left(\\frac{c^2(1-kr^2)}{a^2} (P^t)^2\\right) = 0$$\n$$\\frac{dP^t}{d\\lambda} + \\frac{\\dot{a}}{a} (P^t)^2 = 0$$\nTo obtain an equation for $P^t$ as a function of time $t$, we use the chain rule: $\\frac{d}{d\\lambda} = \\frac{dt}{d\\lambda}\\frac{d}{dt} = P^t\\frac{d}{dt}$.\n$$P^t \\frac{dP^t}{dt} + \\frac{\\dot{a}}{a} (P^t)^2 = 0$$\nAssuming $P^t \\neq 0$, we divide by $P^t$ to get a linear ODE:\n$$\\frac{dP^t}{dt} + \\frac{\\dot{a}}{a} P^t = 0 \\quad \\implies \\quad \\frac{1}{P^t}\\frac{dP^t}{dt} = -\\frac{1}{a}\\frac{da}{dt}$$\nThis shows that $d(\\ln P^t)/dt = -d(\\ln a)/dt$, which integrates to $P^t \\propto 1/a$. Since $E \\propto P^t$, we have $E \\propto 1/a$.\nTo frame this for numerical integration against the scale factor $a$, we write:\n$$\\frac{dE}{da} = \\frac{dE}{dt}\\frac{dt}{da}$$\nFrom $E \\propto 1/a$, we have $dE/dt = d(k/a)/dt = -k \\dot{a}/a^2 = -(Ea)\\dot{a}/a^2 = -E(\\dot{a}/a) = -EH$.\nAnd $dt/da = 1/\\dot{a} = 1/(aH)$. So,\n$$\\frac{dE}{da} = (-EH) \\left(\\frac{1}{aH}\\right) = -\\frac{E}{a}$$\nThis first-order ODE, $\\frac{dE}{da} = -E/a$, is the dynamical equation to be solved numerically.\n\n**3. Numerical Implementation**\n\nFor each test case and for each specified emission scale factor $a_e$, we perform the following:\n1.  Set the initial condition for the energy $E(a_e)$ using the provided emission history function: $E_{\\mathrm{emit}}(a_e) = E_0 \\left(1 + A \\sin(\\alpha \\ln a_e) + B a_e^\\beta\\right)$.\n2.  Numerically solve the ODE $\\frac{dE}{da} = -E/a$ over the interval $[a_e, 1]$ using `scipy.integrate.solve_ivp` with high-precision tolerances. The final value at $a=1$ is the observed energy, $E_{\\mathrm{obs}}$.\n3.  Calculate the numerical redshift $z_{\\mathrm{num}} = E_{\\mathrm{emit}}(a_e)/E_{\\mathrm{obs}} - 1$.\n4.  Calculate the theoretical redshift $z_{\\mathrm{theory}} = a_0/a_e - 1 = 1/a_e - 1$.\n5.  The absolute difference $|z_{\\mathrm{num}} - z_{\\mathrm{theory}}|$ is computed. The maximum of these differences over all sampled $a_e$ values for a given test case is reported.\n\nThis procedure rigorously tests the direct consequences of the FLRW geometry on photon propagation, and the numerical results should confirm the theoretical redshift relation up to the precision of the numerical solver.", "answer": "```python\nimport numpy as np\nfrom scipy import integrate\n\ndef solve():\n    \"\"\"\n    Numerically ray-traces photon geodesics in FLRW spacetime to verify\n    the cosmological redshift relation from first principles.\n    \"\"\"\n    # Physical constants\n    # Speed of light in km/s\n    C_KM_S = 299792.458\n\n    # Test case definitions\n    # (H0, Omega_m, Omega_r, Omega_Lambda, a_range, E_params)\n    test_cases = [\n        # Case 1: Flat Lambda-Cold Dark Matter\n        (70.0, 0.3, 9e-5, 0.69991, (0.2, 0.95), (1.0, 0.2, 0.1, 5.0, 0.3)),\n        # Case 2: Flat matter-dominated\n        (50.0, 1.0, 0.0, 0.0, (0.05, 0.9), (1.0, 0.2, 0.1, 3.0, 0.5)),\n        # Case 3: Flat toy radiation-dominated\n        (70.0, 1e-4, 0.9999, 0.0, (1e-6, 1e-4), (1.0, 0.2, 0.1, 8.0, 0.2)),\n        # Case 4: Flat late-time cosmological-constant dominated\n        (70.0, 1e-2, 9e-5, 0.98991, (0.8, 0.999), (1.0, 0.2, 0.1, 4.0, 0.7)),\n    ]\n\n    results = []\n\n    for h0, om_m, om_r, om_l, a_range, e_params in test_cases:\n        a_min, a_max = a_range\n        om_k = 1.0 - (om_m + om_r + om_l)  # All cases are flat, so om_k is 0\n\n        # Define the normalized Hubble parameter function H(a)/H0\n        def hubble_normalized(a):\n            term_r = om_r * a**-4\n            term_m = om_m * a**-3\n            term_k = om_k * a**-2\n            term_l = om_l\n            return np.sqrt(term_r + term_m + term_k + term_l)\n\n        # 1. Calculate comoving distance to the earliest emission event (a_min)\n        # Integrand for comoving distance calculation\n        def dist_integrand(a):\n            return 1.0 / (a**2 * hubble_normalized(a))\n        \n        # Hubble distance in Mpc\n        hubble_dist_mpc = C_KM_S / h0\n        \n        # Use quad for high-precision integration\n        dist_integral, _ = integrate.quad(dist_integrand, a_min, 1.0, epsabs=1e-14, epsrel=1e-14)\n        \n        comoving_dist_mpc = hubble_dist_mpc * dist_integral\n\n        # 2. Verify redshift relation by evolving photon energy\n        e0, A, B, alpha, beta = e_params\n\n        # Time-varying emitted energy function\n        def e_emit_func(a):\n            return e0 * (1.0 + A * np.sin(alpha * np.log(a)) + B * a**beta)\n            \n        # ODE for energy evolution: dE/da = -E/a\n        def energy_ode(a, E):\n            return -E / a\n\n        # Set up emission event samples\n        num_samples = 10\n        # For large scale factor ranges, log spacing is more appropriate\n        if a_max / a_min  100:\n            a_e_samples = np.logspace(np.log10(a_min), np.log10(a_max), num_samples)\n        else:\n            a_e_samples = np.linspace(a_min, a_max, num_samples)\n            \n        discrepancies = []\n        for a_e in a_e_samples:\n            # Initial condition: energy at emission\n            e_initial = e_emit_func(a_e)\n            \n            # Solve the ODE from a_e to a_0=1\n            sol = integrate.solve_ivp(\n                energy_ode,\n                t_span=[a_e, 1.0],\n                y0=[e_initial],\n                rtol=1e-13,\n                atol=1e-13,\n                dense_output=True,\n                method='RK45'\n            )\n            e_observed = sol.y[0, -1]\n            \n            # Numerical redshift\n            z_numerical = e_initial / e_observed - 1.0\n            \n            # Theoretical redshift for a_0=1\n            z_theoretical = 1.0 / a_e - 1.0\n            \n            # Store the absolute discrepancy\n            discrepancies.append(np.abs(z_numerical - z_theoretical))\n            \n        max_discrepancy = np.max(discrepancies)\n        \n        results.extend([max_discrepancy, comoving_dist_mpc])\n\n    # Format the final output as a single comma-separated list in brackets\n    output_str = ','.join(f\"{x:.12g}\" for x in results)\n    print(f\"[{output_str}]\")\n\nsolve()\n```", "id": "3496232"}, {"introduction": "Beyond the standard cosmological model, theorists explore more exotic possibilities, such as phantom energy models where the dark energy equation of state parameter $w$ is less than $-1$. These models predict a dramatic future singularity known as the \"Big Rip,\" where the universe is torn apart in a finite amount of time. This practice requires you to compute the time remaining until this event by evaluating an improper integral, a task that demands careful numerical treatment [@problem_id:3496205]. You will learn to guarantee the accuracy of your result by deriving a rigorous analytical bound on the integral's tail, a powerful method for tackling problems with singularities or asymptotic behavior.", "problem": "You are asked to design and implement a numerical integrator to compute the remaining cosmic proper time until the scale factor diverges (the so-called Big Rip) in a homogeneous and isotropic universe described by the Friedmann–Lemaître–Robertson–Walker (FLRW) metric with a constant dark energy equation of state parameter $w$ satisfying $wlt;-1$. Your program must be a complete, runnable program that takes no input and outputs the required results for a specified test suite.\n\nFundamental base:\n- The first Friedmann equation for a homogeneous and isotropic universe with scale factor $a(t)$ and Hubble parameter $H(t) \\equiv \\dot{a}/a$ is\n$$\nH(a)^2 = H_0^2\\left(\\Omega_r a^{-4} + \\Omega_m a^{-3} + \\Omega_k a^{-2} + \\Omega_{\\mathrm{de}}\\,a^{-3(1+w)}\\right),\n$$\nwhere $H_0$ is the present Hubble constant, $\\Omega_r$ is the present radiation density parameter, $\\Omega_m$ is the present matter density parameter, $\\Omega_k$ is the present curvature density parameter, $\\Omega_{\\mathrm{de}}$ is the present dark energy density parameter, and $w$ is the constant dark energy equation of state parameter $p=w\\rho$.\n- Energy-momentum conservation for a perfect fluid implies $\\rho \\propto a^{-3(1+w)}$ for a component with constant $w$.\n- By definition of $H(a)$, one has $H(a) = \\frac{1}{a}\\frac{da}{dt}$, so $dt = \\frac{da}{a H(a)}$.\n\nTask:\n- For each parameter set listed in the Test Suite below, compute the remaining proper time from today (defined by $a=1$) until the Big Rip singularity at $a \\to \\infty$. This is obtained by integrating $dt=\\frac{da}{aH(a)}$ from $a=1$ to $a \\to \\infty$. You must design a numerically stable and reliable method that:\n  1. Reformulates the integral into a form that is suitable for numerical evaluation over a semi-infinite domain without loss of precision.\n  2. Includes a safe termination criterion near the singularity using a rigorously derived upper bound on the remaining integral (a tail bound), ensuring the total absolute error is bounded by a user-chosen tolerance.\n- Your program must implement a termination rule that guarantees the absolute error on the computed remaining time is no larger than a specified absolute tolerance $\\epsilon$ by combining:\n  - A controlled numerical quadrature error over a finite interval.\n  - A mathematically rigorous, computable upper bound on the remainder of the integral from the truncation point to $a \\to \\infty$.\n- You must not rely on any closed-form expression for the total integral; all results must arise from your numerical method with the mathematically justified tail bound.\n\nPhysical and numerical units:\n- Express the final proper time results in gigayears (Gyr).\n- Use the following exact constants for unit conversion:\n  - $1\\,\\mathrm{Mpc} = 3.0856775814913673\\times 10^{22}\\,\\mathrm{m}$.\n  - $1\\,\\mathrm{yr} = 365.25 \\times 86400\\,\\mathrm{s} = 31557600\\,\\mathrm{s}$.\n  - $1\\,\\mathrm{Gyr} = 10^9\\,\\mathrm{yr}$.\n- The Hubble constant $H_0$ will be provided in $\\mathrm{km\\,s^{-1}\\,Mpc^{-1}}$ and must be converted to $\\mathrm{Gyr^{-1}}$ before use.\n\nNumerical method requirements:\n- Re-express the integral in a form suitable for numerical integration over a semi-infinite domain, and implement an adaptive numerical quadrature with an error estimator to control the integration error on the finite domain.\n- Derive and implement a tail bound that upper-bounds the remaining integral contribution from a finite truncation point to infinity, and use it to decide when to terminate the integration safely. The total absolute error must be bounded by a target tolerance $\\epsilon = 10^{-6}\\,\\mathrm{Gyr}$.\n- Your algorithm must be robust for $wlt;-1$ and compositions with nonzero $\\Omega_r$, $\\Omega_m$, and $\\Omega_k$, provided all densities are nonnegative and $H(a)$ is real for $a\\ge 1$.\n\nTest Suite:\nFor each of the following parameter sets $(H_0, \\Omega_m, \\Omega_r, \\Omega_k, \\Omega_{\\mathrm{de}}, w)$, compute the remaining proper time to the Big Rip and report it in $\\mathrm{Gyr}$ rounded to exactly six digits after the decimal point.\n\n- Case 1 (flat, phantom moderately below $-1$):\n  - $H_0 = 70.0\\,\\mathrm{km\\,s^{-1}\\,Mpc^{-1}}$, $\\Omega_m = 0.3$, $\\Omega_r = 0.0$, $\\Omega_k = 0.0$, $\\Omega_{\\mathrm{de}} = 0.7$, $w = -1.2$.\n- Case 2 (Planck-like $H_0$, small radiation, phantom stronger):\n  - $H_0 = 67.74\\,\\mathrm{km\\,s^{-1}\\,Mpc^{-1}}$, $\\Omega_m = 0.315$, $\\Omega_r = 9.0\\times 10^{-5}$, $\\Omega_k = 0.0$, $\\Omega_{\\mathrm{de}} = 0.68491$, $w = -1.5$.\n- Case 3 (open universe with curvature, phantom below $-1$):\n  - $H_0 = 73.0\\,\\mathrm{km\\,s^{-1}\\,Mpc^{-1}}$, $\\Omega_m = 0.25$, $\\Omega_r = 5.0\\times 10^{-5}$, $\\Omega_k = 0.02$, $\\Omega_{\\mathrm{de}} = 0.72995$, $w = -1.3$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results for Cases $1$–$3$ as a comma-separated list enclosed in square brackets, for example, $[x_1,x_2,x_3]$, where each $x_i$ is the time to the Big Rip in $\\mathrm{Gyr}$ rounded to six digits after the decimal point, with no extra spaces.\n\nScoring and validation:\n- The output values must be floats as specified. There is no additional input. The program must be self-contained and must not rely on any external data beyond the constants listed above.", "solution": "The user has requested the computation of the time remaining until a \"Big Rip\" singularity in a universe model described by the Friedmann-Lemaître-Robertson-Walker (FLRW) metric. The model includes a dark energy component with a constant equation of state parameter $w  -1$. The solution requires a numerically robust method with rigorous error control.\n\n### 1. Mathematical Formulation\nThe time evolution of the scale factor $a(t)$ is governed by the first Friedmann equation:\n$$\nH(a)^2 = H_0^2\\left(\\Omega_r a^{-4} + \\Omega_m a^{-3} + \\Omega_k a^{-2} + \\Omega_{\\mathrm{de}}\\,a^{-3(1+w)}\\right)\n$$\nwhere $H(a) = \\frac{1}{a}\\frac{da}{dt}$ is the Hubble parameter. The present day is defined by $a=1$. The remaining proper time until the Big Rip singularity (where $a \\to \\infty$) is given by the integral:\n$$\nT_{rip} = \\int_{t_0}^{\\infty} dt = \\int_{a=1}^{a=\\infty} \\frac{da}{a H(a)}\n$$\nFor $w-1$, the term proportional to $a^{-3(1+w)}$ grows with $a$, causing $H(a)$ to diverge as $a \\to \\infty$, which in turn leads to a finite total time $T_{rip}$. The integral is convergent.\n\n### 2. Unit Conversion\nThe Hubble constant $H_0$ is provided in units of $\\mathrm{km\\,s^{-1}\\,Mpc^{-1}}$. For the final result to be in Gigayears (Gyr), $H_0$ must be converted to $\\mathrm{Gyr}^{-1}$. The conversion factor is derived from the provided physical constants:\n$1\\,\\mathrm{Mpc} = 3.0856775814913673\\times 10^{22}\\,\\mathrm{m}$\n$1\\,\\mathrm{Gyr} = 10^9 \\times 365.25 \\times 86400\\,\\mathrm{s} = 3.15576 \\times 10^{16}\\,\\mathrm{s}$\n$$\nH_0 [\\mathrm{Gyr}^{-1}] = H_0 [\\mathrm{km\\,s^{-1}\\,Mpc^{-1}}] \\times \\frac{1000 \\, [\\mathrm{m/km}] \\times 3.15576 \\times 10^{16} \\, [\\mathrm{s/Gyr}]}{3.0856775814913673\\times 10^{22} \\, [\\mathrm{m/Mpc}]}\n$$\nThis conversion factor will be used to express $H_0$ in the appropriate units before any calculation. All subsequent calculations will be in a system of units where time is measured in Gyr.\n\n### 3. Numerical Strategy and Error Control\nThe integral for $T_{rip}$ is improper due to its infinite upper limit, posing a challenge for standard numerical quadrature routines. To address this, we split the integral at a large, finite scale factor $a_{max}$:\n$$\nT_{rip} = \\int_{1}^{a_{max}} \\frac{da}{a H(a)} + \\int_{a_{max}}^{\\infty} \\frac{da}{a H(a)} = I_{num} + I_{tail}\n$$\nThe total result is approximated by the numerically computed integral $I_{num}$. The absolute error of this approximation is the sum of the error from the numerical quadrature of $I_{num}$ (let's call it $\\Delta_{quad}$) and the magnitude of the truncated tail, $I_{tail}$.\n$$\n\\text{Total Error} = |\\text{Computed} - \\text{True}| \\le \\Delta_{quad} + |I_{tail}|\n$$\nTo guarantee the total absolute error is less than a specified tolerance $\\epsilon$, we require that each component of the error is bounded. We will enforce $\\Delta_{quad} \\le \\epsilon/2$ and $|I_{tail}| \\le \\epsilon/2$. The key is to find an $a_{max}$ large enough to satisfy the latter condition, which requires deriving a rigorous upper bound for $|I_{tail}|$.\n\n### 4. Derivation of the Tail Bound\nFor large $a$, the dark energy term $\\Omega_{\\mathrm{de}}\\,a^{-3(1+w)}$ dominates the expression for $H(a)^2$, since $w  -1$ makes its exponent positive while all other exponents are negative. Given that all $\\Omega_i \\ge 0$ in the provided test cases, we can establish a rigorous lower bound on $H(a)^2$ for $a \\ge 1$:\n$$\nH(a)^2 \\ge H_0^2 \\Omega_{\\mathrm{de}}\\,a^{-3(1+w)} \\implies H(a) \\ge H_0 \\sqrt{\\Omega_{\\mathrm{de}}} a^{-3(1+w)/2}\n$$\nThis gives an upper bound on the integrand:\n$$\n\\frac{1}{a H(a)} \\le \\frac{1}{a \\left( H_0 \\sqrt{\\Omega_{\\mathrm{de}}} a^{-3(1+w)/2} \\right)} = \\frac{1}{H_0 \\sqrt{\\Omega_{\\mathrm{de}}}} a^{\\frac{3(1+w)}{2} - 1}\n$$\nThe tail integral is therefore bounded by:\n$$\n|I_{tail}| \\le \\int_{a_{max}}^{\\infty} \\frac{1}{H_0 \\sqrt{\\Omega_{\\mathrm{de}}}} a^{\\frac{3(1+w)}{2} - 1} da\n$$\nLet $p = \\frac{3(1+w)}{2} - 1$. Since $w  -1$, we have $p  -1$, so the integral converges.\n$$\n|I_{tail}| \\le \\frac{1}{H_0 \\sqrt{\\Omega_{\\mathrm{de}}}} \\left[ \\frac{a^{p+1}}{p+1} \\right]_{a_{max}}^{\\infty} = \\frac{1}{H_0 \\sqrt{\\Omega_{\\mathrm{de}}}} \\left( -\\frac{a_{max}^{p+1}}{p+1} \\right)\n$$\nSubstituting $p+1 = \\frac{3(1+w)}{2}$ yields the analytical tail bound $B(a_{max})$:\n$$\nB(a_{max}) = \\frac{2 a_{max}^{\\frac{3}{2}(1+w)}}{-3(1+w) H_0 \\sqrt{\\Omega_{\\mathrm{de}}}}\n$$\nWe choose our truncation point $a_{max}$ by solving $B(a_{max}) = \\epsilon_{tail} = \\epsilon/2$:\n$$\na_{max} = \\left[ \\frac{-3(1+w) H_0 \\sqrt{\\Omega_{\\mathrm{de}}} (\\epsilon/2)}{2} \\right]^{\\frac{2}{3(1+w)}}\n$$\nSince $\\frac{2}{3(1+w)}$ is a negative exponent, this yields a very large $a_{max}$, ensuring the tail contribution is small.\n\n### 5. Integral Reformulation for Quadrature\nThe integration range $[1, a_{max}]$ can span many orders of magnitude, which is inefficient for standard quadrature algorithms. To create a well-behaved integrand over a compact domain, we perform a change of variables: $a = e^u$. This gives $da = e^u du$, and the integration limits change from $[1, a_{max}]$ to $[0, \\ln(a_{max})]$.\n$$\nI_{num} = \\int_{1}^{a_{max}} \\frac{da}{a H(a)} = \\int_{0}^{\\ln(a_{max})} \\frac{e^u du}{e^u H(e^u)} = \\int_{0}^{\\ln(a_{max})} \\frac{du}{H(e^u)}\n$$\nThe new integrand, $h(u) = 1/H(e^u)$, is smoother over the transformed domain $[0, \\ln(a_{max})]$, which is of a moderate size. This formulation is highly suitable for a standard adaptive quadrature library function like `scipy.integrate.quad`.\n\n### 6. Algorithmic Summary\nThe complete algorithm for each test case is as follows:\n1.  Define the total absolute tolerance $\\epsilon = 10^{-6}$ Gyr. Set component tolerances $\\epsilon_{quad} = \\epsilon/2$ and $\\epsilon_{tail} = \\epsilon/2$.\n2.  Convert the input $H_0$ from $\\mathrm{km\\,s^{-1}\\,Mpc^{-1}}$ to $\\mathrm{Gyr}^{-1}$ using the derived conversion factor.\n3.  Calculate the upper integration limit $a_{max}$ by solving the tail bound equation $B(a_{max}) = \\epsilon_{tail}$.\n4.  Transform the integration range by setting $u_{max} = \\ln(a_{max})$.\n5.  Perform numerical quadrature of the function $h(u) = 1/H(e^u)$ over the interval $[0, u_{max}]$, requesting an absolute error tolerance of $\\epsilon_{quad}$ from the integration routine.\n6.  The result of the numerical integration is the final computed time to the Big Rip. The total error is guaranteed to be bounded by $\\epsilon$.\n7.  The final value is formatted to six decimal places as required.\nThis method is robust, adheres to all problem constraints, and correctly uses the derived tail bound to define a numerically tractable problem with guaranteed error control.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import integrate\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    It computes the remaining proper time until the Big Rip singularity for three different\n    cosmological models, formats the results, and prints them.\n    \"\"\"\n    # Physical constants as specified in the problem statement\n    # 1 Megaparsec in meters\n    MPC_IN_M = 3.0856775814913673e22\n    # 1 Julian year in seconds\n    S_IN_YR = 365.25 * 86400.0\n    # 1 Gigayear in seconds\n    S_IN_GYR = S_IN_YR * 1e9\n    \n    # Conversion factor for H0 from km/s/Mpc to 1/Gyr\n    # The conversion is: H0_Gyr = H0_kmsMpc * (1000 m/km) * (S_IN_GYR s/Gyr) / (MPC_IN_M m/Mpc)\n    H0_CONV_FACTOR = (1000.0 * S_IN_GYR) / MPC_IN_M\n\n    # Test cases from the problem statement\n    test_cases = [\n        # (H0 [km/s/Mpc], Omega_m, Omega_r, Omega_k, Omega_de, w)\n        (70.0, 0.3, 0.0, 0.0, 0.7, -1.2),\n        (67.74, 0.315, 9.0e-5, 0.0, 0.68491, -1.5),\n        (73.0, 0.25, 5.0e-5, 0.02, 0.72995, -1.3),\n    ]\n\n    results = []\n    # Target total absolute error for the computed integral\n    epsilon = 1e-6  # Gyr\n\n    for params in test_cases:\n        t_rip = compute_time_to_rip(params, H0_CONV_FACTOR, epsilon)\n        # Format the result to exactly six digits after the decimal point\n        results.append(f\"{t_rip:.6f}\")\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(results)}]\")\n\n\ndef compute_time_to_rip(params, h0_conv_factor, total_tolerance):\n    \"\"\"\n    Computes the time to the Big Rip for a given set of cosmological parameters using\n    a robust numerical integration method with a rigorous error bound.\n\n    Args:\n        params (tuple): A tuple of cosmological parameters (H0, Om, Or, Ok, Ode, w).\n        h0_conv_factor (float): The factor to convert H0 to Gyr^-1.\n        total_tolerance (float): The desired total absolute error for the result.\n\n    Returns:\n        float: The calculated time in Gyr until the Big Rip.\n    \"\"\"\n    H0_kmsMpc, Om, Or, Ok, Ode, w = params\n\n    # Split the total tolerance between the numerical quadrature and the truncated tail.\n    epsilon_quad = total_tolerance / 2.0\n    epsilon_tail = total_tolerance / 2.0\n\n    # Convert Hubble constant to units of Gyr^-1\n    H0_per_Gyr = H0_kmsMpc * h0_conv_factor\n    \n    # --- Tail Bound and Integration Limit Calculation ---\n    # The tail integral from a_max to infinity is bounded by assuming dark energy dominance.\n    # The analytical bound B(a_max) is used to find a_max such that B(a_max) = epsilon_tail.\n    # B(a_max) = (2 * a_max^(1.5*(1+w))) / (-3*(1+w)*H0*sqrt(Ode)).\n    \n    # Define exponent gamma = 1.5 * (1 + w), which is negative for w  -1\n    gamma = 1.5 * (1.0 + w)\n    \n    if Ode = 0:\n        # A Big Rip of this type requires a positive dark energy density.\n        raise ValueError(\"Dark energy density Omega_de must be positive for a Big Rip.\")\n\n    # Solve B(a_max) = epsilon_tail for a_max.\n    # a_max^gamma = epsilon_tail * (-gamma * H0_per_Gyr * sqrt(Ode))\n    a_max_raised_to_gamma = epsilon_tail * (-gamma) * H0_per_Gyr * np.sqrt(Ode)\n    \n    # a_max = (a_max_raised_to_gamma)^(1/gamma). Since gamma  0, a_max will be large.\n    a_max = a_max_raised_to_gamma**(1.0 / gamma)\n\n    # --- Integrand Definition for Numerical Quadrature ---\n    # To handle the large range [1, a_max], we substitute a = exp(u).\n    # The integral becomes integral from 0 to log(a_max) of du / H(exp(u)).\n    \n    w_const = -3.0 * (1.0 + w)\n\n    def integrand_log_scale(u):\n        a = np.exp(u)\n        \n        # H(a)^2 / H0^2 = Or*a^-4 + Om*a^-3 + Ok*a^-2 + Ode*a^(-3(1+w))\n        h_squared_term = (Or * a**-4.0 + \n                          Om * a**-3.0 + \n                          Ok * a**-2.0 + \n                          Ode * a**w_const)\n        \n        h_val = H0_per_Gyr * np.sqrt(h_squared_term)\n        return 1.0 / h_val\n\n    # --- Numerical Integration ---\n    # The upper limit for the transformed integral is log(a_max).\n    u_max = np.log(a_max)\n\n    # Use scipy's quad to perform the integration with the specified absolute tolerance.\n    integral_val, _ = integrate.quad(\n        integrand_log_scale, \n        0, \n        u_max, \n        epsabs=epsilon_quad,\n        # Increase iteration limit for potentially complex integrals\n        limit=200 \n    )\n\n    # The result is the value of the numerical integration. The total error is bounded\n    # by epsilon_quad (from quad) + epsilon_tail (from truncation).\n    return integral_val\n\n# Execute the main solver function\nsolve()\n```", "id": "3496205"}]}