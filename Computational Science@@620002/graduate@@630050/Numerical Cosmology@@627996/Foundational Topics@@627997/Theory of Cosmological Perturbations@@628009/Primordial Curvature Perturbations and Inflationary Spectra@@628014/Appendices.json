{"hands_on_practices": [{"introduction": "The journey into the numerical study of primordial perturbations begins with the evolution of a single Fourier mode, from its initial quantum state deep inside the horizon to its final classical value on super-horizon scales. This process is governed by the fundamental Mukhanov-Sasaki equation, which unifies the dynamics of the quantum field and the expanding spacetime background into a single, elegant framework.\n\nThis practice provides direct, hands-on experience with numerically integrating this equation [@problem_id:3482626]. By tracking a mode with wavenumber $k$, you will directly observe the conservation of the comoving curvature perturbation, $\\mathcal{R}_k$, on super-horizon scales—a cornerstone prediction of simple, single-field inflationary models. Furthermore, comparing this standard adiabatic evolution to a scenario with a non-adiabatic source will build crucial intuition for how more complex physics, such as in multi-field models, can alter this simple picture.", "problem": "You are tasked with constructing a numerical experiment to evolve the comoving curvature perturbation mode $\\mathcal{R}_k$ across horizon exit during inflation for two scenarios: an adiabatic single-field case and a mildly non-adiabatic two-field-inspired case. The goal is to quantify deviations from conservation of $\\mathcal{R}_k$ as a function of the comoving wavenumber $k$, using a scientifically justified toy model that captures the dominant physics near and after horizon exit.\n\nUse the following fundamental base:\n\n- The Mukhanov–Sasaki equation for the canonically normalized variable $u_k = z \\, \\mathcal{R}_k$ in conformal time $\\eta$ for a quasi-de Sitter background is\n$$\nu_k'' + \\left(c_s^2 k^2 - \\frac{z''}{z}\\right) u_k = 0 ,\n$$\nwith primes denoting differentiation with respect to $\\eta$. For canonical single-field slow-roll inflation with constant slow-roll parameter $\\epsilon \\ll 1$ and constant Hubble rate $H$, adopt $c_s = 1$ and $a(\\eta) = -\\frac{1}{H \\eta}$ for $\\eta  0$. In reduced Planck units (reduced Planck mass equal to unity), let\n$$\nz(\\eta) = a(\\eta) \\sqrt{2 \\epsilon}, \\quad \\text{so that} \\quad \\frac{z''}{z} = \\frac{2}{\\eta^2}.\n$$\n\n- Deep inside the horizon ($k |\\eta| \\gg 1$), initialize the mode in the Bunch–Davies vacuum:\n$$\nu_k(\\eta_i) \\approx \\frac{e^{-i k \\eta_i}}{\\sqrt{2 k}}, \\quad u_k'(\\eta_i) \\approx -i k \\, u_k(\\eta_i),\n$$\nat a suitably early initial conformal time $\\eta_i$ satisfying $k |\\eta_i| \\gg 1$.\n\n- Horizon crossing occurs when $k = a H$, which for the adopted background occurs at $\\eta_\\text{cross} = -\\frac{1}{k}$.\n\n- For the adiabatic case, evolve $u_k$ using the homogeneous Mukhanov–Sasaki equation, compute $\\mathcal{R}_k = u_k / z$, and quantify the fractional change in amplitude across horizon exit from $\\eta_\\text{cross}$ to a fixed late time $\\eta_\\text{late}$ after horizon exit:\n$$\n\\Delta_{\\text{ad}}(k) = \\frac{\\left|\\mathcal{R}_k(\\eta_\\text{late})\\right| - \\left|\\mathcal{R}_k(\\eta_\\text{cross})\\right|}{\\left|\\mathcal{R}_k(\\eta_\\text{cross})\\right|}.\n$$\n\n- For the mildly non-adiabatic case, model a small super-horizon transfer from isocurvature to curvature due to a constant turn-rate in field space. After computing $\\left|\\mathcal{R}_k(\\eta_\\text{cross})\\right|$ as above, assume an isocurvature amplitude $S_k(N_\\text{cross}) = \\sigma \\left|\\mathcal{R}_k(\\eta_\\text{cross})\\right|$ at horizon crossing, with $\\sigma \\ll 1$ a small ratio. For $N$ the number of e-folds, use a standard super-horizon phenomenological coupling\n$$\n\\frac{d \\mathcal{R}_k}{dN} \\approx 2 \\Theta \\, S_k, \\quad \\frac{d S_k}{dN} \\approx -\\mu \\, S_k ,\n$$\nwhere $\\Theta$ is the constant turn-rate (in units of the Hubble rate) and $\\mu > 0$ is the entropy decay rate. Over $\\Delta N$ e-folds from $\\eta_\\text{cross}$ to $\\eta_\\text{late}$, this yields an additive change in the amplitude\n$$\n\\delta \\mathcal{R}_k \\approx \\frac{2 \\Theta}{\\mu} S_k(N_\\text{cross}) \\left(1 - e^{-\\mu \\Delta N}\\right),\n$$\nwith $\\Delta N = \\ln\\left(\\frac{a(\\eta_\\text{late})}{a(\\eta_\\text{cross})}\\right) = \\ln\\left(\\frac{|\\eta_\\text{cross}|}{|\\eta_\\text{late}|}\\right)$ for the adopted background. Define the fractional deviation for the non-adiabatic case as\n$$\n\\Delta_{\\text{nonad}}(k) = \\frac{\\left(\\left|\\mathcal{R}_k(\\eta_\\text{late})\\right| + \\delta \\mathcal{R}_k\\right) - \\left|\\mathcal{R}_k(\\eta_\\text{cross})\\right|}{\\left|\\mathcal{R}_k(\\eta_\\text{cross})\\right|}.\n$$\n\nNumerical and modeling instructions:\n\n- Work entirely in reduced Planck units with $H = 1$, so all quantities are dimensionless.\n- Use $\\epsilon = 0.01$, $\\Theta = 0.01$, $\\mu = 0.2$, $\\sigma = 0.05$.\n- For each comoving wavenumber $k$ in the test suite below, integrate the Mukhanov–Sasaki equation from $\\eta_i = -\\frac{50}{k}$ to $\\eta_\\text{cross} = -\\frac{1}{k}$, then continue to $\\eta_\\text{late} = -10^{-3}$. Use the initial conditions given above at $\\eta_i$. Compute $\\Delta_{\\text{ad}}(k)$ and $\\Delta_{\\text{nonad}}(k)$ as defined above.\n- All angles, if any arise, must be in radians. However, the requested outputs are dimensionless floats; no physical units are required in the final answer.\n\nTest suite:\n\n- Use $k \\in \\{0.05, 0.5, 5.0, 50.0\\}$, which probes late crossing, typical crossing, and early crossing, covering a boundary at very small $k$ and an edge at very large $k$.\n\nFinal output specification:\n\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order\n$$\n[\\Delta_{\\text{ad}}(0.05), \\Delta_{\\text{nonad}}(0.05), \\Delta_{\\text{ad}}(0.5), \\Delta_{\\text{nonad}}(0.5), \\Delta_{\\text{ad}}(5.0), \\Delta_{\\text{nonad}}(5.0), \\Delta_{\\text{ad}}(50.0), \\Delta_{\\text{nonad}}(50.0)].\n$$\nEach entry must be a floating-point number.", "solution": "The user has provided a valid, well-posed problem in numerical cosmology. The problem is scientifically grounded in the standard theory of inflationary perturbations and provides a complete set of equations, parameters, and numerical instructions. The task is to compute the fractional change in the comoving curvature perturbation, $\\mathcal{R}_k$, for a range of comoving wavenumbers, $k$, in two scenarios: a standard adiabatic evolution and a phenomenological non-adiabatic case.\n\nThe algorithm to solve this problem is designed as follows:\n\nFirst, we address the evolution of the canonically normalized variable $u_k = z \\mathcal{R}_k$. Its dynamics are governed by the Mukhanov-Sasaki equation, which for the provided quasi-de Sitter background simplifies to a second-order linear ordinary differential equation (ODE) in conformal time $\\eta$:\n$$\nu_k'' + \\left(k^2 - \\frac{2}{\\eta^2}\\right) u_k = 0\n$$\nHere, primes denote differentiation with respect to $\\eta$. The variable $u_k(\\eta)$ is complex. To solve this equation numerically, we decompose $u_k$ into its real and imaginary parts, $u_k(\\eta) = u_{k,R}(\\eta) + i u_{k,I}(\\eta)$. Since the coefficients of the ODE are real, the real and imaginary parts decouple and each satisfies the same ODE independently:\n$$\nu_{k,R}'' + \\left(k^2 - \\frac{2}{\\eta^2}\\right) u_{k,R} = 0\n$$\n$$\nu_{k,I}'' + \\left(k^2 - \\frac{2}{\\eta^2}\\right) u_{k,I} = 0\n$$\nEach of these second-order ODEs is converted into a system of two first-order ODEs for numerical integration. For a generic real function $y(\\eta)$ satisfying the equation, we define a state vector $\\mathbf{y}(\\eta) = [y(\\eta), y'(\\eta)]^T$. The system of first-order ODEs is then:\n$$\n\\frac{d\\mathbf{y}}{d\\eta} = \\begin{bmatrix} y' \\\\ y'' \\end{bmatrix} = \\begin{bmatrix} y' \\\\ -\\left(k^2 - \\frac{2}{\\eta^2}\\right) y \\end{bmatrix}\n$$\nThe problem specifies Bunch-Davies initial conditions to be set deep inside the horizon at an initial time $\\eta_i = -50/k$. This condition corresponds to $k|\\eta_i| = 50 \\gg 1$. The initial state is given by:\n$$\nu_k(\\eta_i) = \\frac{e^{-i k \\eta_i}}{\\sqrt{2 k}} = \\frac{e^{i 50}}{\\sqrt{2 k}}, \\quad u_k'(\\eta_i) = -i k u_k(\\eta_i)\n$$\nDecomposing these into real and imaginary parts provides the initial conditions for the two systems of ODEs:\n$$\nu_{k,R}(\\eta_i) = \\frac{\\cos(50)}{\\sqrt{2k}}, \\quad u_{k,R}'(\\eta_i) = \\frac{k\\sin(50)}{\\sqrt{2k}}\n$$\n$$\nu_{k,I}(\\eta_i) = \\frac{\\sin(50)}{\\sqrt{2k}}, \\quad u_{k,I}'(\\eta_i) = -\\frac{k\\cos(50)}{\\sqrt{2k}}\n$$\nFor each wavenumber $k$ in the test suite, we integrate these two systems from $\\eta_i = -50/k$ to a late time $\\eta_{\\text{late}} = -10^{-3}$, which is well after horizon crossing for all specified $k$. The numerical integration is performed using a high-precision adaptive step-size solver, specifically `scipy.integrate.solve_ivp`. We request the solver to provide the solution at two specific points: horizon crossing, $\\eta_{\\text{cross}} = -1/k$, and the final time, $\\eta_{\\text{late}}$.\n\nFrom the numerical solutions for $u_{k,R}$ and $u_{k,I}$, we reconstruct the complex mode function $u_k$ and its magnitude $|u_k| = \\sqrt{u_{k,R}^2 + u_{k,I}^2}$ at $\\eta_{\\text{cross}}$ and $\\eta_{\\text{late}}$.\n\nThe comoving curvature perturbation $\\mathcal{R}_k$ is then recovered via its definition, $\\mathcal{R}_k = u_k / z$. The pump field $z(\\eta)$ is given by $z(\\eta) = a(\\eta)\\sqrt{2\\epsilon} = -\\frac{\\sqrt{2\\epsilon}}{H\\eta}$. With $H=1$, its magnitude is $|z(\\eta)| = \\frac{\\sqrt{2\\epsilon}}{|\\eta|}$. The magnitude of the curvature perturbation is thus $|\\mathcal{R}_k(\\eta)| = |u_k(\\eta)| / |z(\\eta)|$.\n\nWith $|\\mathcal{R}_k(\\eta_{\\text{cross}})|$ and $|\\mathcal{R}_k(\\eta_{\\text{late}})|$ computed, we calculate the fractional change for the adiabatic case:\n$$\n\\Delta_{\\text{ad}}(k) = \\frac{|\\mathcal{R}_k(\\eta_{\\text{late}})| - |\\mathcal{R}_k(\\eta_{\\text{cross}})|}{|\\mathcal{R}_k(\\eta_{\\text{cross}})|}\n$$\nFor the non-adiabatic case, a super-horizon contribution $\\delta \\mathcal{R}_k$ is added to the amplitude of $\\mathcal{R}_k$. This contribution models a transfer from an isocurvature mode and is calculated as:\n$$\n\\delta\\mathcal{R}_k = \\frac{2 \\Theta \\sigma}{\\mu} |\\mathcal{R}_k(\\eta_{\\text{cross}})| \\left(1 - e^{-\\mu \\Delta N}\\right)\n$$\nwhere the number of e-folds between horizon crossing and the late time is $\\Delta N = \\ln(|\\eta_{\\text{cross}}|/|\\eta_{\\text{late}}|) = \\ln(\\frac{1/k}{10^{-3}}) = \\ln(1000/k)$. The parameters $\\Theta=0.01$, $\\sigma=0.05$, and $\\mu=0.2$ are given. The fractional deviation for the non-adiabatic case is then defined as:\n$$\n\\Delta_{\\text{nonad}}(k) = \\frac{\\left(|\\mathcal{R}_k(\\eta_{\\text{late}})| + \\delta \\mathcal{R}_k\\right) - |\\mathcal{R}_k(\\eta_{\\text{cross}})|}{|\\mathcal{R}_k(\\eta_{\\text{cross}})|} = \\Delta_{\\text{ad}}(k) + \\frac{\\delta \\mathcal{R}_k}{|\\mathcal{R}_k(\\eta_{\\text{cross}})|}\n$$\nThe second term simplifies to $\\frac{2 \\Theta \\sigma}{\\mu} (1 - e^{-\\mu \\Delta N})$.\n\nThis procedure is systematically applied to each value of $k$ in the test suite $\\{0.05, 0.5, 5.0, 50.0\\}$, and the resulting values of $\\Delta_{\\text{ad}}(k)$ and $\\Delta_{\\text{nonad}}(k)$ are collected and formatted into the specified output string.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Solves for the fractional change in the comoving curvature perturbation R_k\n    for both adiabatic and non-adiabatic scenarios across a range of wavenumbers k.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (epsilon, Theta, mu, sigma, H, wavenumbers)\n        (0.01, 0.01, 0.2, 0.05, 1.0, [0.05, 0.5, 5.0, 50.0])\n    ]\n\n    for case in test_cases:\n        epsilon, Theta, mu, sigma, H, k_values = case\n        \n        results = []\n\n        # Pre-compute constants to optimize the loop\n        sqrt_2_epsilon = np.sqrt(2.0 * epsilon)\n        cos50 = np.cos(50.0)\n        sin50 = np.sin(50.0)\n        non_ad_coeff = (2.0 * Theta * sigma) / mu\n\n        def mukhanov_sasaki_system(eta, y, k):\n            \"\"\"\n            Defines the system of first-order ODEs for the Mukhanov-Sasaki equation.\n            y[0] = u_k, y[1] = u_k'\n            The equation is u_k'' + (k^2 - 2/eta^2) * u_k = 0\n            \"\"\"\n            potential = k**2 - 2.0 / eta**2\n            return [y[1], -potential * y[0]]\n\n        for k in k_values:\n            # 1. Define integration and evaluation time points\n            eta_i = -50.0 / k\n            eta_cross = -1.0 / k\n            eta_late = -1.0e-3\n            \n            # 2. Set up initial conditions based on the Bunch-Davies vacuum approximation\n            # The normalization factor 1/sqrt(2k)\n            norm = 1.0 / np.sqrt(2.0 * k)\n            \n            # Real part of u_k and its derivative\n            uR_i = cos50 * norm\n            uR_prime_i = k * sin50 * norm\n            y0_R = [uR_i, uR_prime_i]\n\n            # Imaginary part of u_k and its derivative\n            uI_i = sin50 * norm\n            uI_prime_i = -k * cos50 * norm\n            y0_I = [uI_i, uI_prime_i]\n\n            # 3. Points in time where the solution is to be evaluated\n            t_eval_points = [eta_cross, eta_late]\n\n            # 4. Numerically integrate the ODE for both real and imaginary parts\n            sol_R = solve_ivp(\n                fun=mukhanov_sasaki_system,\n                t_span=(eta_i, eta_late),\n                y0=y0_R,\n                t_eval=t_eval_points,\n                args=(k,),\n                method='RK45',\n                rtol=1e-12,\n                atol=1e-12\n            )\n\n            sol_I = solve_ivp(\n                fun=mukhanov_sasaki_system,\n                t_span=(eta_i, eta_late),\n                y0=y0_I,\n                t_eval=t_eval_points,\n                args=(k,),\n                method='RK45',\n                rtol=1e-12,\n                atol=1e-12\n            )\n\n            # 5. Extract the solutions at eta_cross and eta_late\n            uR_at_eval_points = sol_R.y[0]\n            uI_at_eval_points = sol_I.y[0]\n\n            # 6. Reconstruct the magnitude of u_k\n            u_mag_cross = np.sqrt(uR_at_eval_points[0]**2 + uI_at_eval_points[0]**2)\n            u_mag_late = np.sqrt(uR_at_eval_points[1]**2 + uI_at_eval_points[1]**2)\n\n            # 7. Calculate the magnitude of R_k = u_k / z\n            # |z(eta)| = sqrt(2*epsilon) / |eta| since H=1\n            z_mag_cross = sqrt_2_epsilon / abs(eta_cross)\n            z_mag_late = sqrt_2_epsilon / abs(eta_late)\n            \n            R_k_mag_cross = u_mag_cross / z_mag_cross\n            R_k_mag_late = u_mag_late / z_mag_late\n            \n            # 8. Compute the fractional change for the adiabatic case\n            delta_ad = (R_k_mag_late - R_k_mag_cross) / R_k_mag_cross\n            results.append(delta_ad)\n\n            # 9. Compute the fractional change for the non-adiabatic case\n            # The number of e-folds between horizon crossing and late time\n            delta_N = np.log(abs(eta_cross) / abs(eta_late))\n            \n            # The super-horizon contribution to R_k, normalized by |R_k(cross)|\n            non_ad_term = non_ad_coeff * (1.0 - np.exp(-mu * delta_N))\n            \n            delta_nonad = delta_ad + non_ad_term\n            results.append(delta_nonad)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3482626"}, {"introduction": "Having mastered the basics of mode evolution, we can now explore a deeper physical interpretation of features in the power spectrum. Transient events during inflation, such as a temporary change in the inflaton's speed or a bump in its potential, can powerfully excite quantum vacuum fluctuations. This practice frames such an event as a \"quantum quench,\" a concept from condensed matter physics where a rapid change in a system's parameters leads to the creation of particles from the vacuum.\n\nBy implementing this model [@problem_id:3482635], you will connect the abstract formalism of Bogoliubov coefficients—which quantify this particle creation—to a concrete cosmological observable: oscillations in the primordial power spectrum. This exercise provides a powerful bridge between the formalisms of quantum field theory in curved spacetime and the practical prediction of observational signatures, illuminating how features in the inflationary potential are imprinted onto the statistics of our universe.", "problem": "Consider the canonical quantization of scalar curvature perturbations in single-field inflation, where the Mukhanov variable $u_k(\\tau)$ obeys the linear differential equation\n$$\nu_k''(\\tau) + \\left(k^2 - \\frac{z''(\\tau)}{z(\\tau)}\\right) u_k(\\tau) = 0,\n$$\nwith conformal time $\\tau  0$, comoving wavenumber $k$, and $z(\\tau) \\equiv a(\\tau) \\sqrt{2 \\epsilon(\\tau)}\\, M_{\\mathrm{Pl}}$ for scale factor $a(\\tau)$, first slow-roll parameter $\\epsilon(\\tau)$, and reduced Planck mass $M_{\\mathrm{Pl}}$. In exact de Sitter spacetime with constant Hubble parameter $H$ and constant slow-roll parameter $\\epsilon$, the background satisfies $a(\\tau) = -1/(H \\tau)$ and, in the absence of features, $\\epsilon(\\tau)$ is constant, so that $z(\\tau) \\propto 1/\\tau$ and $z''(\\tau)/z(\\tau) = 2/\\tau^2$. Suppose, however, that $z(\\tau)$ is modulated by a localized, smooth feature modeling a quantum quench:\n$$\nz(\\tau) = \\frac{C}{\\tau} \\, f(\\tau), \\quad f(\\tau) = 1 + A \\exp\\left(-\\frac{(\\tau - \\tau_0)^2}{2 \\sigma^2}\\right),\n$$\nwith $C \\equiv \\sqrt{2 \\epsilon}\\, M_{\\mathrm{Pl}}/H$ constant, amplitude $A$, center time $\\tau_0  0$, and width $\\sigma  0$. This quench modifies the effective frequency of the linear oscillator $u_k$ via\n$$\n\\frac{z''(\\tau)}{z(\\tau)} = \\frac{f''(\\tau)}{f(\\tau)} - \\frac{2 f'(\\tau)}{f(\\tau)} \\frac{1}{\\tau} + \\frac{2}{\\tau^2}.\n$$\nThe initial state is the Bunch–Davies vacuum, defined in the far past where $k^2 \\gg z''/z$, which yields the subhorizon condition\n$$\nu_k(\\tau_i) = \\frac{e^{- i k \\tau_i}}{\\sqrt{2 k}}, \\qquad u_k'(\\tau_i) = - i k \\, u_k(\\tau_i),\n$$\nat some sufficiently early negative conformal time $\\tau_i$.\n\nYour tasks are:\n1. Implement the background $z(\\tau)$ and compute $\\frac{z''(\\tau)}{z(\\tau)}$ analytically from the given $f(\\tau)$, $f'(\\tau)$, and $f''(\\tau)$.\n2. For each comoving wavenumber $k$ in a prescribed set, numerically integrate the Mukhanov–Sasaki equation for $u_k(\\tau)$ from $\\tau = \\tau_i$ to a late time $\\tau = \\tau_f$ with $|k \\tau_f| \\ll 1$ so that the curvature perturbation freezes out.\n3. In a subhorizon window after the quench (times $\\tau  \\tau_0$ such that $k |\\tau| \\gg 1$ and the feature is exponentially suppressed), treat the dynamics as an approximate time-dependent harmonic oscillator and extract the Bogoliubov coefficients $(\\alpha_k, \\beta_k)$ by least-squares projection of the numerically integrated $u_k(\\tau)$ onto a plane-wave basis $\\{e^{- i k \\tau}, e^{+ i k \\tau}\\}$ appropriate for $k^2 \\gg z''/z$. Use the normalization consistent with the Bunch–Davies mode functions. Report the excitation magnitude via $|\\beta_k|^2$ for conceptual comparison to condensed-matter quantum quench dynamics.\n4. Compute the curvature perturbation $\\mathcal{R}_k(\\tau) = u_k(\\tau)/z(\\tau)$ and the late-time dimensionless curvature power spectrum\n$$\nP_{\\mathcal{R}}(k) = \\frac{k^3}{2 \\pi^2} \\left| \\frac{u_k(\\tau_f)}{z(\\tau_f)} \\right|^2,\n$$\nand compare to a smooth baseline without a quench ($A = 0$). Quantify the oscillatory modulation induced by the quench via the root-mean-square fractional deviation\n$$\n\\Delta_{\\mathrm{rms}} = \\left[ \\frac{1}{N_k} \\sum_{i=1}^{N_k} \\left( \\frac{P_{\\mathcal{R}}^{\\mathrm{quench}}(k_i)}{P_{\\mathcal{R}}^{(0)}(k_i)} - 1 \\right)^2 \\right]^{1/2},\n$$\nwhere $P_{\\mathcal{R}}^{(0)}(k)$ is computed with $A = 0$ and the same $(\\tau_i, \\tau_f)$ and $k$ set, and $N_k$ is the number of wavenumbers in the set.\n\nUse units where $H = 1$ and $M_{\\mathrm{Pl}} = 1$. Express all times $\\tau$ in units of inverse Hubble parameter $H^{-1}$, all wavenumbers $k$ in units of $H$, and the final reported values of $\\Delta_{\\mathrm{rms}}$ are dimensionless floats.\n\nTest Suite:\n- Integrate over the wavenumber set $k \\in \\{0.01, 0.02, 0.035, 0.05, 0.065, 0.08, 0.1\\}$ with fixed $\\tau_i = -200$ and $\\tau_f = -0.1$.\n- Use constant slow-roll parameter $\\epsilon = 0.01$.\n- Evaluate four quench parameter sets:\n  (i) $(A, \\sigma, \\tau_0) = (0.2, 1.5, -50)$,\n  (ii) $(A, \\sigma, \\tau_0) = (0.0, 1.5, -50)$,\n  (iii) $(A, \\sigma, \\tau_0) = (0.5, 0.5, -30)$,\n  (iv) $(-0.2, 2.0, -80)$.\n- For each parameter set, compute $\\Delta_{\\mathrm{rms}}$ across the specified $k$ values. The expected boundary behavior is that case (ii) yields a value near zero because there is no quench, whereas cases (i), (iii), and (iv) produce nonzero values reflecting excitations and oscillations of $P_{\\mathcal{R}}(k)$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the four results $\\Delta_{\\mathrm{rms}}$ for the above four test cases as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4]\"). Each entry must be a floating-point number. No additional text should be printed.", "solution": "We begin with the canonical action for curvature perturbations in single-field inflation,\n$$\nS = \\frac{1}{2} \\int d\\tau\\, d^3 x \\left[ (u')^2 - (\\nabla u)^2 + \\frac{z''}{z} u^2 \\right],\n$$\nwhere $u(\\tau, \\mathbf{x})$ is the Mukhanov variable and $z(\\tau) \\equiv a(\\tau) \\sqrt{2 \\epsilon(\\tau)}\\, M_{\\mathrm{Pl}}$. Varying this action leads to the equation of motion for Fourier modes $u_k(\\tau)$,\n$$\nu_k''(\\tau) + \\left(k^2 - \\frac{z''(\\tau)}{z(\\tau)} \\right) u_k(\\tau) = 0.\n$$\nThis is a linear oscillator with a time-dependent effective frequency squared\n$$\n\\omega_k^2(\\tau) \\equiv k^2 - \\frac{z''(\\tau)}{z(\\tau)}.\n$$\nIn exact de Sitter spacetime with constant slow-roll parameter $\\epsilon$, the background satisfies $a(\\tau) = -1/(H \\tau)$ and $z(\\tau) \\propto 1/\\tau$, giving $\\frac{z''}{z} = \\frac{2}{\\tau^2}$. The Bunch–Davies vacuum is the unique adiabatic vacuum selected in the far past where $k^2 \\gg z''/z$, yielding the initial conditions\n$$\nu_k(\\tau_i) = \\frac{e^{- i k \\tau_i}}{\\sqrt{2 k}}, \\qquad u_k'(\\tau_i) = - i k \\, u_k(\\tau_i),\n$$\nfor sufficiently negative $\\tau_i$.\n\nWe introduce a localized modulation in $z(\\tau)$,\n$$\nz(\\tau) = \\frac{C}{\\tau} \\, f(\\tau), \\quad f(\\tau) = 1 + A \\exp\\left(-\\frac{(\\tau - \\tau_0)^2}{2 \\sigma^2}\\right),\n$$\nwith $C = \\sqrt{2 \\epsilon}\\, M_{\\mathrm{Pl}}/H$. The modulation is motivated by transient departures from slow roll in the inflationary background, and in the oscillator language it constitutes a quantum quench in the effective frequency. To compute $\\frac{z''}{z}$ consistently, we differentiate $z(\\tau)$ analytically:\n$$\nz'(\\tau) = C \\left( \\frac{f'(\\tau)}{\\tau} - \\frac{f(\\tau)}{\\tau^2} \\right), \\quad\nz''(\\tau) = C \\left( \\frac{f''(\\tau)}{\\tau} - \\frac{2 f'(\\tau)}{\\tau^2} + \\frac{2 f(\\tau)}{\\tau^3} \\right).\n$$\nTherefore,\n$$\n\\frac{z''(\\tau)}{z(\\tau)} = \\frac{f''(\\tau)}{f(\\tau)} - \\frac{2 f'(\\tau)}{f(\\tau)} \\frac{1}{\\tau} + \\frac{2}{\\tau^2}.\n$$\nWith $g(\\tau) \\equiv \\exp\\left(-\\frac{(\\tau - \\tau_0)^2}{2 \\sigma^2}\\right)$, we have $f(\\tau) = 1 + A g(\\tau)$, $f'(\\tau) = A g'(\\tau)$, $f''(\\tau) = A g''(\\tau)$, and\n$$\ng'(\\tau) = - \\frac{\\tau - \\tau_0}{\\sigma^2} g(\\tau), \\qquad g''(\\tau) = \\left( \\frac{(\\tau - \\tau_0)^2}{\\sigma^4} - \\frac{1}{\\sigma^2} \\right) g(\\tau).\n$$\n\nNumerical scheme:\n1. Fix $H = 1$ and $M_{\\mathrm{Pl}} = 1$, and choose constant $\\epsilon = 0.01$, so $C = \\sqrt{2 \\epsilon} = \\sqrt{0.02}$. Times and wavenumbers are measured in units of $H^{-1}$ and $H$, respectively.\n2. For each test case $(A, \\sigma, \\tau_0)$ and each wavenumber $k$ in the set $k \\in \\{0.01, 0.02, 0.035, 0.05, 0.065, 0.08, 0.1\\}$, integrate the Mukhanov–Sasaki equation from $\\tau = \\tau_i = -200$ to $\\tau = \\tau_f = -0.1$. We evolve a real system for the real and imaginary parts by rewriting the second-order complex ordinary differential equation as a first-order system for $(\\Re u_k, \\Im u_k, \\Re u_k', \\Im u_k')$. The effective potential is computed via the analytic expression above for $\\frac{z''}{z}$.\n3. To extract Bogoliubov coefficients $(\\alpha_k, \\beta_k)$ after the quench, select a time window $\\tau \\in [\\tau_{\\mathrm{start}}, \\tau_{\\mathrm{end}}]$ with $\\tau_{\\mathrm{start}} = \\tau_0 + 3 \\sigma$, and $\\tau_{\\mathrm{end}} = \\min(\\tau_0 + 10 \\sigma, -2)$, ensuring we are well past the feature yet safely in the subhorizon regime for modest $k$. In this window, the modes approximately obey\n$$\nu_k(\\tau) \\approx \\frac{1}{\\sqrt{2 k}} \\left( \\alpha_k e^{- i k \\tau} + \\beta_k e^{+ i k \\tau} \\right),\n$$\nsince $k^2 \\gg z''/z$ implies $\\omega_k(\\tau) \\approx k$, and the adiabatic basis is approximately plane waves. We sample $u_k(\\tau)$ at many points in the window and compute $(\\alpha_k, \\beta_k)$ by complex least-squares projection: minimize $\\sum_j \\left| u_k(\\tau_j) \\sqrt{2 k} - \\alpha_k e^{- i k \\tau_j} - \\beta_k e^{+ i k \\tau_j} \\right|^2$ with respect to complex $\\alpha_k$ and $\\beta_k$. The excitation number is $|\\beta_k|^2$, as in condensed-matter quench dynamics where a sudden change in the oscillator frequency creates pairs of excitations.\n4. Evaluate the curvature perturbation at late times, $\\mathcal{R}_k(\\tau_f) = u_k(\\tau_f)/z(\\tau_f)$, and the curvature power spectrum\n$$\nP_{\\mathcal{R}}(k) = \\frac{k^3}{2 \\pi^2} \\left| \\frac{u_k(\\tau_f)}{z(\\tau_f)} \\right|^2,\n$$\nfor the quench case and for the baseline $A = 0$ case (with the same $k$ set and $(\\tau_i, \\tau_f)$). Compute the root-mean-square fractional deviation\n$$\n\\Delta_{\\mathrm{rms}} = \\left[ \\frac{1}{N_k} \\sum_{i=1}^{N_k} \\left( \\frac{P_{\\mathcal{R}}^{\\mathrm{quench}}(k_i)}{P_{\\mathcal{R}}^{(0)}(k_i)} - 1 \\right)^2 \\right]^{1/2}.\n$$\n\nScientific reasoning and expectations:\n- The function $\\frac{z''}{z}$ acts as a time-dependent potential in the mode equation. A localized modulation corresponds to a transient change in the effective frequency $\\omega_k(\\tau)$, analogous to a quantum quench in condensed matter, where a sudden change in parameters excites a distribution of modes. In the inflationary context, this produces mixing between positive and negative frequency components, parameterized by Bogoliubov coefficients $(\\alpha_k, \\beta_k)$. Deep inside the horizon, the adiabatic basis is well approximated by plane waves with constant frequency $k$, justifying the least-squares extraction.\n- The curvature power spectrum $P_{\\mathcal{R}}(k)$ is constant after horizon exit. A transient feature imprints oscillatory modulations in $P_{\\mathcal{R}}(k)$ as a function of $k$ because the phase and amplitude mixing induced by nonzero $\\beta_k$ varies across $k$. Thus, cases with $A \\neq 0$ exhibit nonzero $\\Delta_{\\mathrm{rms}}$, while the smooth case $A = 0$ yields $\\beta_k \\approx 0$ and $\\Delta_{\\mathrm{rms}} \\approx 0$.\n- Edge cases: A narrow, strong feature (small $\\sigma$, large $|A|$) excites a broader range of $k$ more significantly, increasing $\\Delta_{\\mathrm{rms}}$. A feature far in the past (large $|\\tau_0|$) or mild in amplitude produces smaller modulations because modes experience the quench when $k^2 \\gg z''/z$, minimizing mixing.\n\nAlgorithmic summary:\n- Implement $f(\\tau)$, $f'(\\tau)$, $f''(\\tau)$, $z(\\tau)$, and $z''/z$ analytically.\n- Integrate the first-order system for $(\\Re u_k, \\Im u_k, \\Re u_k', \\Im u_k')$ from $\\tau_i$ to $\\tau_f$ for each $k$ using initial Bunch–Davies conditions.\n- Extract $(\\alpha_k, \\beta_k)$ via least-squares projection of $u_k(\\tau)$ in the post-quench subhorizon window onto $\\{e^{- i k \\tau}, e^{+ i k \\tau}\\}$.\n- Compute $P_{\\mathcal{R}}(k)$ at $\\tau_f$ and $\\Delta_{\\mathrm{rms}}$ for each test case relative to the smooth baseline.\n- Output the four $\\Delta_{\\mathrm{rms}}$ values in the specified single-line format.\n\nAll outputs are dimensionless floats. Times are in $H^{-1}$ and wavenumbers in $H$. The final format is a single line with a comma-separated list enclosed in square brackets, containing the four $\\Delta_{\\mathrm{rms}}$ values in the order of the given test cases.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\n# Constants (units: H = 1, M_pl = 1)\nH = 1.0\nM_Pl = 1.0\nepsilon = 0.01\nC = np.sqrt(2.0 * epsilon) * M_Pl / H\n\n# Time domain for integration\ntau_i = -200.0\ntau_f = -0.1\n\n# Wavenumber set\nk_values = np.array([0.01, 0.02, 0.035, 0.05, 0.065, 0.08, 0.1], dtype=float)\n\ndef f_gauss(tau, A, sigma, tau0):\n    \"\"\"Gaussian modulation f(τ) = 1 + A * exp(-(τ-τ0)^2 / (2 σ^2)).\"\"\"\n    g = np.exp(-((tau - tau0) ** 2) / (2.0 * sigma ** 2))\n    f = 1.0 + A * g\n    # Derivatives of g:\n    gp = - (tau - tau0) / (sigma ** 2) * g\n    gpp = ((tau - tau0) ** 2 / (sigma ** 4) - 1.0 / (sigma ** 2)) * g\n    # Derivatives of f:\n    fp = A * gp\n    fpp = A * gpp\n    return f, fp, fpp\n\ndef z_and_V(tau, A, sigma, tau0):\n    \"\"\"Return z(τ) and V(τ) = z''/z.\"\"\"\n    f, fp, fpp = f_gauss(tau, A, sigma, tau0)\n    # z(τ) = C * f / τ\n    z = C * f / tau\n    # V = z''/z = f''/f - 2 (f'/f)/τ + 2/τ^2\n    # Handle small numerical issues if f ~ 0: clamp f\n    f_safe = np.where(np.abs(f)  1e-12, 1e-12, f)\n    V = (fpp / f_safe) - 2.0 * (fp / f_safe) / tau + 2.0 / (tau ** 2)\n    return z, V\n\ndef mode_rhs(tau, y, k, A, sigma, tau0):\n    \"\"\"\n    First-order real system for u'' + (k^2 - V) u = 0.\n    y = [u_re, u_im, v_re, v_im] with v = u'.\n    \"\"\"\n    u_re, u_im, v_re, v_im = y\n    # Compute V = z''/z\n    _, V = z_and_V(tau, A, sigma, tau0)\n    # u'' = - (k^2 - V) u\n    coeff = -(k ** 2 - V)\n    du_re = v_re\n    du_im = v_im\n    dv_re = coeff * u_re\n    dv_im = coeff * u_im\n    return np.array([du_re, du_im, dv_re, dv_im], dtype=float)\n\ndef bd_initial_conditions(k):\n    \"\"\"Bunch–Davies initial conditions at tau_i.\"\"\"\n    phase = -k * tau_i\n    u0 = np.exp(1j * phase) / np.sqrt(2.0 * k)\n    up0 = -1j * k * u0\n    return np.array([u0.real, u0.imag, up0.real, up0.imag], dtype=float)\n\ndef integrate_mode(k, A, sigma, tau0):\n    \"\"\"Integrate the mode equation and return solution with dense output.\"\"\"\n    y0 = bd_initial_conditions(k)\n    # Integrate with dense output for sampling later\n    sol = solve_ivp(\n        fun=lambda t, y: mode_rhs(t, y, k, A, sigma, tau0),\n        t_span=(tau_i, tau_f),\n        y0=y0,\n        method='RK45',\n        rtol=1e-8,\n        atol=1e-9,\n        dense_output=True,\n        max_step=1.0\n    )\n    return sol\n\ndef extract_bogoliubov(sol, k, A, sigma, tau0):\n    \"\"\"\n    Extract Bogoliubov coefficients (α_k, β_k) using least-squares projection\n    in a subhorizon window after the quench.\n    \"\"\"\n    # Define window after quench: start = tau0 + 3 σ, end = min(tau0 + 10 σ, -2)\n    tau_start = tau0 + 3.0 * sigma\n    tau_end = min(tau0 + 10.0 * sigma, -2.0)\n    # Ensure window lies within integration domain\n    tau_start = max(tau_start, tau_i + 1.0)\n    tau_end = min(tau_end, tau_f - 1e-3)\n    if not (tau_start  tau_end):\n        # Fallback: choose a window a bit after tau0 if defaults fail\n        tau_start = tau0 + 2.0 * sigma\n        tau_end = tau_start + 5.0\n        tau_end = min(tau_end, -2.0)\n        tau_start = max(tau_start, tau_i + 1.0)\n        if not (tau_start  tau_end):\n            # If still invalid, return trivial coefficients\n            return 1.0 + 0.0j, 0.0 + 0.0j\n\n    # Sample points\n    N = 400\n    taus = np.linspace(tau_start, tau_end, N)\n    # Evaluate solution u(τ)\n    Y = sol.sol(taus)\n    u = Y[0] + 1j * Y[1]  # u_re + i u_im\n\n    # Build least-squares system: u * sqrt(2k) ~ α e^{-ikτ} + β e^{+ikτ}\n    b = u * np.sqrt(2.0 * k)\n    basis_minus = np.exp(-1j * k * taus)\n    basis_plus = np.exp(+1j * k * taus)\n    # Construct design matrix with complex entries\n    A_mtx = np.vstack([basis_minus, basis_plus]).T  # shape (N, 2)\n\n    # Solve complex least squares\n    # Convert to real system by stacking real and imaginary parts\n    A_real = np.hstack([np.real(A_mtx), np.imag(A_mtx)])\n    b_real = np.hstack([np.real(b), np.imag(b)])\n    # We solve for [Re(α), Re(β), Im(α), Im(β)] via least squares on real system\n    # Construct block matrix to map unknowns to real/imag parts:\n    # [Re(A)  -Im(A)] [Re(x)] = Re(b)\n    # [Im(A)   Re(A)] [Im(x)] = Im(b)\n    # But we already formed A_real and b_real by horizontal stacking; better to set up properly.\n    # We'll directly solve complex least squares using numpy.linalg.lstsq on complex arrays.\n    # Note: numpy supports complex least squares via lstsq on complex matrices.\n    coeffs, *_ = np.linalg.lstsq(A_mtx, b, rcond=None)\n    alpha = coeffs[0]\n    beta = coeffs[1]\n    return alpha, beta\n\ndef compute_power_spectrum(sol, A, sigma, tau0, k):\n    \"\"\"Compute P_R(k) at tau_f for given solution and parameters.\"\"\"\n    Yf = sol.sol(tau_f)\n    u_f = Yf[0] + 1j * Yf[1]\n    z_f, _ = z_and_V(tau_f, A, sigma, tau0)\n    R_f = u_f / z_f\n    P_R = (k ** 3) / (2.0 * np.pi ** 2) * (np.abs(R_f) ** 2)\n    return P_R\n\ndef compute_baseline_P0(k_values):\n    \"\"\"Compute baseline P_R(k) with A = 0.\"\"\"\n    P0 = []\n    for k in k_values:\n        sol0 = integrate_mode(k, A=0.0, sigma=1.0, tau0=-50.0)  # sigma, tau0 irrelevant when A=0\n        P0.append(compute_power_spectrum(sol0, A=0.0, sigma=1.0, tau0=-50.0, k=k))\n    return np.array(P0, dtype=float)\n\ndef run_case(A, sigma, tau0, P0, k_values):\n    \"\"\"Run a quench case and compute RMS fractional deviation Δ_rms.\"\"\"\n    P = []\n    beta_list = []\n    for k in k_values:\n        sol = integrate_mode(k, A=A, sigma=sigma, tau0=tau0)\n        Pk = compute_power_spectrum(sol, A=A, sigma=sigma, tau0=tau0, k=k)\n        P.append(Pk)\n        # Extract Bogoliubov coefficients (not used in final metric but computed for completeness)\n        alpha, beta = extract_bogoliubov(sol, k, A, sigma, tau0)\n        beta_list.append(np.abs(beta) ** 2)\n    P = np.array(P, dtype=float)\n    ratio = P / P0\n    delta_rms = np.sqrt(np.mean((ratio - 1.0) ** 2))\n    # The beta_list could be used for diagnostics or further analysis if needed.\n    return float(delta_rms)\n\ndef solve():\n    # Define test cases\n    test_cases = [\n        (0.2, 1.5, -50.0),   # (i) moderate amplitude, moderate width\n        (0.0, 1.5, -50.0),   # (ii) baseline: no quench\n        (0.5, 0.5, -30.0),   # (iii) strong, narrow quench earlier\n        (-0.2, 2.0, -80.0),  # (iv) negative amplitude, wide, far past\n    ]\n\n    # Baseline P0 computed once for the given k_values\n    P0 = compute_baseline_P0(k_values)\n\n    results = []\n    for (A, sigma, tau0) in test_cases:\n        delta_rms = run_case(A, sigma, tau0, P0, k_values)\n        results.append(delta_rms)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3482635"}, {"introduction": "From the microphysics of individual modes, we now zoom out to constrain the global properties of an entire inflationary model. The celebrated Lyth bound provides a profound connection between a potentially observable quantity, the tensor-to-scalar ratio $r$, and the total distance the inflaton field must travel during inflation, $\\Delta\\phi$. However, the simplest form of this bound, $\\Delta\\phi / M_{\\mathrm{Pl}} \\propto \\sqrt{r}$, assumes a canonical single-field model with a standard sound speed ($c_s=1$).\n\nThis exercise challenges you to investigate how this fundamental relationship is modified by more complex, physically-motivated scenarios [@problem_id:3482603]. By incorporating phases of subluminal sound speed ($c_s \\lt 1$) or the conversion of isocurvature perturbations into curvature perturbations, you will numerically compute the required field excursion for a target $r$. This practice provides a quantitative feel for the constraints on inflationary model-building and the ways in which new physics can relax them.", "problem": "You are asked to implement a numerical test of the robustness of the Lyth bound in inflationary cosmology when the sound speed and isocurvature-to-curvature transfer vary in time, including temporary phases with subluminal sound speed and sharp turns in field space. Your program must compute the integrated field-space path length in units of the reduced Planck mass for several prescribed scenarios.\n\nUse the following foundational base, which is standard in inflationary perturbation theory:\n- Let $H$ denote the Hubble rate, and let the Hubble slow-roll parameter be $\\epsilon \\equiv -\\dot{H}/H^2$. For a canonically normalized background trajectory in a flat field-space metric, the background field-space speed satisfies $\\dot{\\phi}^2 = 2 \\epsilon H^2 M_{\\mathrm{Pl}}^2$, hence $d\\phi/M_{\\mathrm{Pl}} = \\sqrt{2 \\epsilon}\\, dN$, where $N \\equiv \\ln a$ is the number of e-folds and $a$ is the scale factor.\n- The dimensionless curvature perturbation power spectrum at horizon exit can be represented as $\\mathcal{P}_{\\mathcal{R}} \\propto H^2 / (\\epsilon c_s)$ up to order-unity prefactors, where $c_s \\in (0,1]$ is the effective scalar sound speed. If isocurvature modes source curvature modes due to a turn in field space, the final curvature power can be modeled as an amplified version of the horizon-exit value, with an amplification factor $1 + T_{RS}^2$, where $T_{RS}$ is the real-valued transfer coefficient from entropy to curvature perturbations. The primordial tensor power spectrum satisfies $\\mathcal{P}_T \\propto H^2$. Therefore, the tensor-to-scalar ratio is $r \\equiv \\mathcal{P}_T/\\mathcal{P}_{\\mathcal{R}}$ and is a function of the epoch (or the comoving wavenumber), and depends on $\\epsilon$, $c_s$, and $T_{RS}$.\n\nYour task:\n- Given a target function $r(N)$, a sound speed profile $c_s(N)$, and a transfer profile $T_{RS}(N)$, compute the integrated field-space path length over a specified e-fold interval $[N_i, N_f]$:\n  $$\\Delta \\phi / M_{\\mathrm{Pl}} \\equiv \\int_{N_i}^{N_f} \\sqrt{2 \\epsilon(N)}\\, dN,$$\n  with $\\epsilon(N)$ inferred consistently from the relation between $r(N)$, $\\epsilon(N)$, $c_s(N)$, and $T_{RS}(N)$ under the above physical base. Express your final answers as dimensionless numbers (no physical units are required because $\\Delta \\phi/M_{\\mathrm{Pl}}$ is dimensionless).\n\nAssumptions and modeling choices to ensure universal applicability:\n- Treat $N$ as the clock labeling the exit time of modes of interest, and assume $r(N)$ is the target ratio assigned to those modes at their exit and after any subsequent sourcing is included in the final scalar amplitude. This avoids having to reconstruct the exact $k$–$N$ mapping under varying $c_s(N)$. You must use only the definitions in the foundational base to connect $r(N)$ to $\\epsilon(N)$.\n- All functions are smooth except where stated; sharp turns are represented by sharply peaked but continuous $T_{RS}(N)$ profiles.\n\nNumerical details to implement:\n- For each test case, define $r(N)$, $c_s(N)$, and $T_{RS}(N)$ on the integration interval $[N_i, N_f]$.\n- Compute $\\Delta \\phi/M_{\\mathrm{Pl}}$ by numerically integrating $d\\phi/M_{\\mathrm{Pl}} = \\sqrt{2\\epsilon(N)}\\, dN$ over $[N_i, N_f]$ using the relation that follows from the foundational base between $r(N)$, $\\epsilon(N)$, $c_s(N)$, and $T_{RS}(N)$.\n- Use a high-accuracy numerical quadrature method to ensure reliability for sharply peaked profiles.\n\nTest Suite:\nCompute $\\Delta \\phi/M_{\\mathrm{Pl}}$ for the following four cases, in the exact order listed. In all cases, the e-fold interval is $[N_i, N_f] = [0, 7]$.\n\n- Case A (baseline, happy path):\n  - $r(N) = r_0$ with $r_0 = 10^{-2}$ for all $N \\in [0,7]$.\n  - $c_s(N) = 1$ for all $N \\in [0,7]$.\n  - $T_{RS}(N) = 0$ for all $N \\in [0,7]$.\n- Case B (temporary subluminal sound speed):\n  - $r(N) = r_0$ with $r_0 = 10^{-2}$ for all $N \\in [0,7]$.\n  - $c_s(N) = 1 - A_c \\exp\\left(-\\dfrac{(N - N_c)^2}{2 \\sigma_c^2}\\right)$ with $A_c = 0.9$, $N_c = 3.5$, $\\sigma_c = 0.3$.\n  - $T_{RS}(N) = 0$ for all $N \\in [0,7]$.\n- Case C (sharp turn with isocurvature sourcing):\n  - $r(N) = r_0$ with $r_0 = 10^{-2}$ for all $N \\in [0,7]$.\n  - $c_s(N) = 1$ for all $N \\in [0,7]$.\n  - $T_{RS}(N) = A_T \\exp\\left(-\\dfrac{(N - N_T)^2}{2 \\sigma_T^2}\\right)$ with $A_T = 3$, $N_T = 3.5$, $\\sigma_T = 0.2$.\n- Case D (boundary case with very small tensor-to-scalar ratio):\n  - $r(N) = r_0$ with $r_0 = 10^{-4}$ for all $N \\in [0,7]$.\n  - $c_s(N) = 1$ for all $N \\in [0,7]$.\n  - $T_{RS}(N) = 0$ for all $N \\in [0,7]$.\n\nFinal output specification:\n- Your program should produce a single line of output containing a list of the four computed values of $\\Delta \\phi/M_{\\mathrm{Pl}}$, in the order of the test suite above. Each value must be rounded to exactly six digits after the decimal point.\n- The output must be formatted as a comma-separated list enclosed in square brackets, with no extra spaces, for example: $[\\text{value}_A,\\text{value}_B,\\text{value}_C,\\text{value}_D]$.", "solution": "The problem statement is assessed to be valid. It is scientifically grounded in the principles of inflationary cosmology, well-posed with a clear objective and sufficient information, and free from ambiguity or contradiction. It presents a standard, albeit numerically intensive, task in theoretical cosmology: to compute the total field excursion of an inflaton-like scalar field given phenomenological models for the tensor-to-scalar ratio $r(N)$, sound speed $c_s(N)$, and isocurvature-to-curvature transfer function $T_{RS}(N)$.\n\nThe central task is to compute the integrated field-space path length, normalized by the reduced Planck mass $M_{\\mathrm{Pl}}$, given by the integral:\n$$ \\frac{\\Delta \\phi}{M_{\\mathrm{Pl}}} = \\int_{N_i}^{N_f} \\sqrt{2 \\epsilon(N)}\\, dN $$\nwhere $N$ is the number of e-folds and $\\epsilon(N)$ is the Hubble slow-roll parameter. The core of the problem lies in determining the function $\\epsilon(N)$ from the other provided functions.\n\nWe begin by establishing the precise relationship between $r(N)$, $\\epsilon(N)$, $c_s(N)$, and $T_{RS}(N)$ based on the foundational principles outlined in the problem.\n\n1.  **Power Spectra Definitions**: The primordial tensor and scalar power spectra in the slow-roll approximation are given by:\n    $$ \\mathcal{P}_T(k) = \\frac{2 H^2}{\\pi^2 M_{\\mathrm{Pl}}^2} \\bigg|_{k=aH} $$\n    For a general sound speed $c_s$, the primordial scalar power spectrum is:\n    $$ \\mathcal{P}_{\\mathcal{R}, \\text{prim}}(k) = \\frac{H^2}{2 \\pi^2 \\epsilon c_s M_{\\mathrm{Pl}}^2} \\bigg|_{k=aH c_s} $$\n    The problem statement specifies that we should treat $N$ as the clock labeling the exit of modes, which simplifies the $k$-to-$N$ mapping and allows us to write these spectra as functions of $N$. The problem also introduces an amplification of the scalar spectrum due to isocurvature perturbations converting to curvature perturbations after horizon exit. The final, observable scalar spectrum $\\mathcal{P}_{\\mathcal{R}}$ is thus modeled as:\n    $$ \\mathcal{P}_{\\mathcal{R}}(N) = \\mathcal{P}_{\\mathcal{R}, \\text{prim}}(N) (1 + T_{RS}(N)^2) $$\n\n2.  **Tensor-to-Scalar Ratio**: The tensor-to-scalar ratio $r(N)$ is defined as the ratio of the tensor power spectrum to the final, amplified scalar power spectrum:\n    $$ r(N) \\equiv \\frac{\\mathcal{P}_T(N)}{\\mathcal{P}_{\\mathcal{R}}(N)} $$\n    Substituting the expressions for the spectra:\n    $$ r(N) = \\frac{\\frac{2 H(N)^2}{\\pi^2 M_{\\mathrm{Pl}}^2}}{\\left(\\frac{H(N)^2}{2 \\pi^2 \\epsilon(N) c_s(N) M_{\\mathrm{Pl}}^2}\\right) (1 + T_{RS}(N)^2)} $$\n    The terms $H(N)^2$, $\\pi^2$, and $M_{\\mathrm{Pl}}^2$ cancel, yielding the key relation:\n    $$ r(N) = \\frac{2}{\\frac{1}{2 \\epsilon(N) c_s(N)}} \\frac{1}{1 + T_{RS}(N)^2} = \\frac{16 \\epsilon(N) c_s(N)}{1 + T_{RS}(N)^2} $$\n\n3.  **Solving for $\\epsilon(N)$**: We can now algebraically invert this equation to express $\\epsilon(N)$ as a function of the given quantities:\n    $$ \\epsilon(N) = \\frac{r(N) (1 + T_{RS}(N)^2)}{16 c_s(N)} $$\n    This expression for $\\epsilon(N)$ is valid for all the scenarios considered, where $r(N)$, $c_s(N)$, and $T_{RS}(N)$ are specified functions. For $\\epsilon$ to be a physical slow-roll parameter, we require $\\epsilon(N) > 0$. Since $r > 0$, $c_s \\in (0,1]$, and $1+T_{RS}^2 \\geq 1$, this condition is always met.\n\n4.  **Formulating the Integral**: We substitute the derived expression for $\\epsilon(N)$ into the integral for the field excursion $\\Delta \\phi / M_{\\mathrm{Pl}}$:\n    $$ \\frac{\\Delta \\phi}{M_{\\mathrm{Pl}}} = \\int_{N_i}^{N_f} \\sqrt{2 \\left( \\frac{r(N) (1 + T_{RS}(N)^2)}{16 c_s(N)} \\right)} \\, dN $$\n    Simplifying the constant factor gives the final expression for the numerical integration:\n    $$ \\frac{\\Delta \\phi}{M_{\\mathrm{Pl}}} = \\int_{N_i}^{N_f} \\sqrt{\\frac{r(N) (1 + T_{RS}(N)^2)}{8 c_s(N)}} \\, dN $$\n\n5.  **Numerical Implementation**: The problem is now reduced to evaluating the above definite integral for each of the four specified test cases over the interval $[N_i, N_f] = [0, 7]$. The integrands can have sharp features, particularly in Cases B and C, which necessitates the use of a robust numerical quadrature method. The `scipy.integrate.quad` function is an excellent choice, as it employs adaptive quadrature, which is well-suited for such functions.\n\nThe implementation will proceed as follows:\n- For each case, define Python functions that represent $r(N)$, $c_s(N)$, and $T_{RS}(N)$.\n- Construct the integrand function according to the derived formula above.\n- Use `scipy.integrate.quad` to compute the definite integral from $N=0$ to $N=7$.\n- Collect the four results, format them to six decimal places, and print them in the specified list format.\n\nThis systematic approach ensures the problem is solved correctly based on a rigorous derivation from first principles, and the numerical method is appropriate for the nature of the integrands.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import integrate\n\ndef solve():\n    \"\"\"\n    Computes the integrated field-space path length for four inflationary scenarios.\n    \"\"\"\n\n    # Define the integration interval\n    N_i = 0.0\n    N_f = 7.0\n\n    # -- Case A: Baseline --\n    # r(N) = 1e-2, c_s(N) = 1, T_RS(N) = 0\n    case_A_params = {\n        \"r0\": 1e-2,\n        \"cs_func\": lambda N: 1.0,\n        \"trs_func\": lambda N: 0.0\n    }\n\n    # -- Case B: Temporary subluminal sound speed --\n    # r(N) = 1e-2\n    # c_s(N) = 1 - A_c * exp(-(N - N_c)^2 / (2 * sigma_c^2))\n    # A_c = 0.9, N_c = 3.5, sigma_c = 0.3\n    # T_RS(N) = 0\n    Ac, Nc, sigma_c = 0.9, 3.5, 0.3\n    case_B_params = {\n        \"r0\": 1e-2,\n        \"cs_func\": lambda N: 1.0 - Ac * np.exp(-(N - Nc)**2 / (2 * sigma_c**2)),\n        \"trs_func\": lambda N: 0.0\n    }\n\n    # -- Case C: Sharp turn with isocurvature sourcing --\n    # r(N) = 1e-2, c_s(N) = 1\n    # T_RS(N) = A_T * exp(-(N - N_T)^2 / (2 * sigma_T^2))\n    # A_T = 3, N_T = 3.5, sigma_T = 0.2\n    AT, NT, sigma_T = 3.0, 3.5, 0.2\n    case_C_params = {\n        \"r0\": 1e-2,\n        \"cs_func\": lambda N: 1.0,\n        \"trs_func\": lambda N: AT * np.exp(-(N - NT)**2 / (2 * sigma_T**2))\n    }\n\n    # -- Case D: Boundary case with very small tensor-to-scalar ratio --\n    # r(N) = 1e-4, c_s(N) = 1, T_RS(N) = 0\n    case_D_params = {\n        \"r0\": 1e-4,\n        \"cs_func\": lambda N: 1.0,\n        \"trs_func\": lambda N: 0.0\n    }\n\n    test_cases = [case_A_params, case_B_params, case_C_params, case_D_params]\n    results = []\n\n    for case in test_cases:\n        r0 = case[\"r0\"]\n        cs_func = case[\"cs_func\"]\n        trs_func = case[\"trs_func\"]\n\n        # The integrand is sqrt(r(N) * (1 + T_RS(N)^2) / (8 * c_s(N)))\n        integrand = lambda N: np.sqrt(r0 * (1 + trs_func(N)**2) / (8 * cs_func(N)))\n\n        # Perform the numerical integration using scipy.integrate.quad\n        # quad returns a tuple (result, error_estimate)\n        integral_value, _ = integrate.quad(integrand, N_i, N_f, limit=200)\n        results.append(integral_value)\n\n    # Format the final output as a comma-separated list of strings,\n    # with each value rounded to 6 decimal places, enclosed in square brackets.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3482603"}]}