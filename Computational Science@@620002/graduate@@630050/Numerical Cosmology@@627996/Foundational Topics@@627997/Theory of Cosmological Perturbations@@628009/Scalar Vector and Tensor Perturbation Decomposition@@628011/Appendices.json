{"hands_on_practices": [{"introduction": "Before we can decompose a complex field, it is instructive to learn how to construct the \"pure\" components from first principles. This exercise guides you through the synthesis of Gaussian random fields that are, by construction, purely scalar (as a gradient), purely vector (divergence-free), or purely tensor (transverse-traceless) [@problem_id:3485117]. Mastering this process is crucial for creating robust test data for decomposition codes and for generating realistic initial conditions in cosmological simulations.", "problem": "Consider a three-dimensional periodic cubic domain of side length $L$ in which fields are represented by their discrete Fourier transforms on a uniform $N \\times N \\times N$ grid. You will construct three statistically independent Gaussian random fields that are pure scalar, pure divergence-free vector, and pure transverse-traceless (TT, transverse-traceless) tensor components, and then validate their purity using Fourier-space projectors and norm ratios.\n\nFundamental base:\n- The discrete Fourier representation uses wavevectors $\\mathbf{k} = (k_x,k_y,k_z)$ with components $k_\\alpha \\in \\frac{2\\pi}{L}\\mathbb{Z}$ consistent with the discrete Fast Fourier Transform. For any real field on a periodic lattice, the Fourier coefficients satisfy Hermitian symmetry.\n- The Helmholtz decomposition of a vector field in Fourier space uses the longitudinal projector $L_{ij}(\\mathbf{k}) = \\frac{k_i k_j}{k^2}$ and the solenoidal projector $\\Lambda_{ij}(\\mathbf{k}) = \\delta_{ij} - \\frac{k_i k_j}{k^2}$ for $k^2 \\equiv \\mathbf{k}\\cdot\\mathbf{k} \\neq 0$.\n- The transverse-traceless projector for a symmetric rank-$2$ field $h_{ij}$ in Fourier space is given by\n$$\nP^{\\mathrm{TT}}_{ij,kl}(\\mathbf{k}) = \\Lambda_{ik}(\\mathbf{k})\\Lambda_{jl}(\\mathbf{k}) - \\tfrac{1}{2}\\Lambda_{ij}(\\mathbf{k})\\Lambda_{kl}(\\mathbf{k}),\n$$\nfor $k^2 \\neq 0$.\n- A Gaussian random field with power spectrum $P(\\mathbf{k})$ can be generated by applying a spectral filter proportional to $\\sqrt{P(\\mathbf{k})}$ to a white Gaussian field in Fourier space. The ensemble of realizations has the prescribed spectrum.\n\nYour task:\n1. Generate a scalar potential field $\\Phi(\\mathbf{x})$ by filtering white Gaussian noise in Fourier space with a prescribed scalar-spectrum $P_\\Phi(k)$ and validate that its gradient is purely longitudinal (i.e., its solenoidal component vanishes).\n2. Generate a divergence-free vector field $\\mathbf{v}(\\mathbf{x})$ by projecting white Gaussian vector noise in Fourier space with the solenoidal projector $\\Lambda_{ij}(\\mathbf{k})$ and validate that its longitudinal component vanishes.\n3. Generate a symmetric tensor field $h_{ij}(\\mathbf{x})$, project it to transverse-traceless using $P^{\\mathrm{TT}}_{ij,kl}(\\mathbf{k})$, and validate transversality and tracelessness. Also validate consistency by re-applying the TT projector to $h_{ij}$ and quantifying the difference.\n\nValidation metrics:\n- Define the Fourier-space gradient of $\\Phi$ as $g_i(\\mathbf{k}) = i k_i \\Phi(\\mathbf{k})$.\n- The solenoidal component of any vector $w_i(\\mathbf{k})$ is $w^{\\mathrm{sol}}_i(\\mathbf{k}) = \\Lambda_{ij}(\\mathbf{k}) w_j(\\mathbf{k})$, and the longitudinal component is $w^{\\mathrm{long}}_i(\\mathbf{k}) = L_{ij}(\\mathbf{k}) w_j(\\mathbf{k})$.\n- For the tensor $h_{ij}$, define its divergence as $d_j(\\mathbf{k}) = k_i h_{ij}(\\mathbf{k})$ and its trace as $\\mathrm{tr}(\\mathbf{k}) = h_{ii}(\\mathbf{k})$.\n- For any complex field $X$ on the grid, let $\\|X\\|^2$ denote the sum over all grid points (and component indices, if any) of the squared modulus. In all ratios below, exclude the $\\mathbf{k}=\\mathbf{0}$ mode from any computation that requires division by $k^2$; when needed, set the corresponding projected mode to zero.\n\nCompute the following five purity ratios for each test case:\n- $R_{\\mathrm{scalar}} = \\dfrac{\\| \\Lambda \\cdot \\mathbf{g} \\|^2}{\\| \\mathbf{g} \\|^2}$.\n- $R_{\\mathrm{vector}} = \\dfrac{\\| L \\cdot \\mathbf{V} \\|^2}{\\| \\mathbf{V} \\|^2}$, where $\\mathbf{V}(\\mathbf{k})$ is the Fourier transform of the generated $\\mathbf{v}(\\mathbf{x})$.\n- $R_{\\mathrm{div}} = \\dfrac{\\| \\mathbf{d} \\|^2}{\\| h \\|^2}$ for the tensor.\n- $R_{\\mathrm{trace}} = \\dfrac{\\| \\mathrm{tr} \\|^2}{\\| h \\|^2}$ for the tensor.\n- $R_{\\mathrm{TT}} = \\dfrac{\\| h - P^{\\mathrm{TT}}[h] \\|^2}{\\| h \\|^2}$ for the tensor, where $P^{\\mathrm{TT}}[h]$ is the TT projection applied to $h$ mode-by-mode in Fourier space.\n\nSpectral shapes:\nUse dimensionless units throughout. For each test case, use the following dimensionless spectra depending on $k=\\|\\mathbf{k}\\|$:\n- Scalar potential spectrum $P_\\Phi(k) = A \\big/ \\big( 1 + (k/k_0)^4 \\big)$.\n- Vector field spectrum $S_v(k) = B \\exp\\big( - (k/k_0)^2 \\big)$.\n- Tensor field spectrum $S_h(k) = C \\,(k/k_0)^2 \\exp\\big( - (k/k_0)^2 \\big)$.\n\nAlgorithmic constraints:\n- Generate white Gaussian fields in real space and use the Fast Fourier Transform to obtain Fourier coefficients with Hermitian symmetry automatically. Apply the appropriate projector and $\\sqrt{\\text{spectrum}}$ filter in Fourier space, then transform back to real space if needed. All validations must be performed in Fourier space to avoid discretization ambiguities.\n- At $\\mathbf{k}=\\mathbf{0}$, set the vector and tensor Fourier coefficients to zero after projection because the projectors are undefined there.\n\nTest suite:\nProvide three test cases with distinct parameters and random seeds. For each case specify $N$, $L$, $A$, $B$, $C$, and $k_0$ as follows:\n- Case $1$: $N=16$, $L=1$, $A=1.0$, $B=1.0$, $C=1.0$, $k_0=12.0$, random seed $s_1=12345$.\n- Case $2$: $N=8$, $L=1$, $A=1.0$, $B=0.5$, $C=1.5$, $k_0=9.0$, random seed $s_2=54321$.\n- Case $3$: $N=20$, $L=1$, $A=2.0$, $B=0.8$, $C=0.7$, $k_0=10.0$, random seed $s_3=2025$.\n\nOutput specification:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must concatenate, in order for each test case, the five purity ratios $[R_{\\mathrm{scalar}}, R_{\\mathrm{vector}}, R_{\\mathrm{div}}, R_{\\mathrm{trace}}, R_{\\mathrm{TT}}]$ as floating-point numbers. For example, the final output format must be\n$[r_1,r_2,r_3,r_4,r_5,r_6,r_7,r_8,r_9,r_{10},r_{11},r_{12},r_{13},r_{14},r_{15}]$\nwith $5$ entries per test case and $15$ entries in total. All quantities are dimensionless. Round nothing and print raw Python float representations.", "solution": "The user-provided problem is assessed to be valid. It is scientifically grounded in the principles of cosmological perturbation theory and Fourier analysis, well-posed with a complete and consistent set of parameters, and objective in its formulation. The task is to numerically construct and validate pure scalar, vector, and tensor modes of Gaussian random fields on a periodic 3D lattice, which is a standard and non-trivial exercise in numerical cosmology.\n\n### 1. Theoretical Framework and Principles\n\nThe problem revolves around the scalar-vector-tensor (SVT) decomposition of fields on a 3D manifold, a fundamental tool in physics, particularly in cosmology for classifying metric and matter perturbations. In a flat, periodic space, this decomposition is most naturally performed in Fourier space, where derivatives become algebraic multiplications with the wavevector $\\mathbf{k}$.\n\nA field can be decomposed into components that transform irreducibly under the rotation group SO(3). For a vector field, this is the Helmholtz decomposition into a longitudinal (curl-free) part and a solenoidal (divergence-free) part. For a symmetric rank-2 tensor field, the decomposition is more complex, but the most important component in many physical applications (like gravitational waves) is the transverse-traceless (TT) part.\n\nThe core of the numerical task is to construct fields that are \"pure,\" meaning they belong exclusively to one of these components (e.g., purely longitudinal gradient, purely solenoidal vector, or purely TT tensor). This is achieved using projection operators in Fourier space.\n\n### 2. Algorithmic Implementation\n\nThe overall algorithm proceeds by generating Gaussian white noise, transforming it to Fourier space, applying the appropriate spectral filter and projection operator, and then computing validation metrics.\n\n**2.1. Fourier Space Grid**\nA uniform cubic grid of size $N \\times N \\times N$ with physical side length $L$ is established. The corresponding wavevectors $\\mathbf{k} = (k_x, k_y, k_z)$ are constructed using `numpy.fft.fftfreq`. For an $N$-point grid over length $L$, the sample spacing is $d = L/N$. The wavenumbers are then $k_\\alpha = 2\\pi f_\\alpha$, where $f_\\alpha$ are the frequencies returned by `numpy.fft.fftfreq(N, d=L/N)`. We compute the grid of wavevectors `k_vecs`, their squared magnitude `k_squared`, and their magnitude `k_norm`. A crucial step is to handle the $\\mathbf{k}=\\mathbf{0}$ mode, where projectors involving division by $k^2$ are singular. This is managed by applying projectors only where $k^2 > 0$.\n\n**2.2. Pure Scalar Mode (Longitudinal Gradient)**\nA scalar potential $\\Phi(\\mathbf{x})$ is a field that transforms as a scalar. Its gradient in real space, $\\nabla\\Phi$, is a vector field.\n1.  **Generation**: We generate a real-space Gaussian white noise field, which has a flat power spectrum. Its Fourier transform, `noise_phi_k`, has the requisite Hermitian symmetry. To give it the desired power spectrum $P_\\Phi(k)$, we filter it by multiplying with $\\sqrt{P_\\Phi(k)}$. This yields the Fourier representation of the scalar potential, $\\Phi(\\mathbf{k})$.\n2.  **Gradient**: The gradient in Fourier space is $\\mathbf{g}(\\mathbf{k}) = i \\mathbf{k} \\Phi(\\mathbf{k})$.\n3.  **Validation**: A gradient field is intrinsically curl-free ($\\nabla \\times \\nabla\\Phi = 0$). In Fourier space, this means $\\mathbf{k} \\times \\mathbf{g}(\\mathbf{k}) = \\mathbf{k} \\times (i\\mathbf{k}\\Phi(\\mathbf{k})) = i(\\mathbf{k} \\times \\mathbf{k})\\Phi(\\mathbf{k}) = \\mathbf{0}$. A curl-free field is purely longitudinal. Therefore, its projection onto the solenoidal (transverse) subspace must vanish. We compute the solenoidal component $\\mathbf{g}^{\\mathrm{sol}}(\\mathbf{k}) = \\Lambda_{ij}(\\mathbf{k}) g_j(\\mathbf{k})$ and calculate the ratio $R_{\\mathrm{scalar}} = \\|\\mathbf{g}^{\\mathrm{sol}}\\|^2 / \\|\\mathbf{g}\\|^2$. Theoretically, this ratio should be zero; numerically, it will be a small number reflecting floating-point precision.\n\n**2.3. Pure Vector Mode (Solenoidal Field)**\nA divergence-free vector field is purely solenoidal.\n1.  **Generation**: We start with a random vector field generated from three independent Gaussian white noise fields, one for each component. After Fourier transformation, we obtain a random vector field $\\mathbf{V}^{\\mathrm{noise}}(\\mathbf{k})$. We then apply the solenoidal projector, $\\mathbf{V}^{\\mathrm{proj}}(\\mathbf{k}) = \\Lambda_{ij}(\\mathbf{k}) V_j^{\\mathrm{noise}}(\\mathbf{k})$. The resulting field is, by construction, divergence-free for $\\mathbf{k} \\neq \\mathbf{0}$. Finally, we apply the spectral filter $\\sqrt{S_v(k)}$ to get the final field $\\mathbf{V}(\\mathbf{k})$. The $\\mathbf{k}=\\mathbf{0}$ mode is set to zero as required.\n2.  **Validation**: Since $\\mathbf{V}(\\mathbf{k})$ is constructed to be purely solenoidal, its longitudinal component must be zero. We compute this component, $\\mathbf{V}^{\\mathrm{long}}(\\mathbf{k}) = L_{ij}(\\mathbf{k}) V_j(\\mathbf{k})$, and the ratio $R_{\\mathrm{vector}} = \\|\\mathbf{V}^{\\mathrm{long}}\\|^2 / \\|\\mathbf{V}\\|^2$. This ratio should be numerically close to zero.\n\n**2.4. Pure Tensor Mode (Transverse-Traceless Field)**\nA transverse-traceless (TT) symmetric tensor field $h_{ij}$ satisfies two conditions in Fourier space for $\\mathbf{k} \\neq \\mathbf{0}$: transversality ($k_i h_{ij}(\\mathbf{k}) = 0$) and tracelessness ($h_{ii}(\\mathbf{k}) = 0$).\n1.  **Generation**: We generate a general rank-2 tensor field from 9 independent Gaussian white noise fields. In Fourier space, we first symmetrize it: $h^{\\mathrm{sym}}_{ij} = \\frac{1}{2}(h_{ij} + h_{ji})$. We then apply the TT projector $P^{\\mathrm{TT}}_{ij,kl}$. This is implemented sequentially for computational efficiency:\n    a. Make the tensor transverse on both indices: $h^{\\mathrm{T}}_{ij} = \\Lambda_{ik}\\Lambda_{jl}h^{\\mathrm{sym}}_{kl}$.\n    b. Remove the trace while preserving transversality: $h^{\\mathrm{TT}}_{ij} = h^{\\mathrm{T}}_{ij} - \\frac{1}{2}\\Lambda_{ij} h^{\\mathrm{T}}_{kk}$.\n    The resulting field $h^{\\mathrm{TT}}(\\mathbf{k})$ is projected. We then apply the spectral filter $\\sqrt{S_h(k)}$ to obtain the final field $h(\\mathbf{k})$.\n2.  **Validation**: We compute three ratios:\n    *   $R_{\\mathrm{div}}$: Measures the norm of the divergence $d_j = k_i h_{ij}$ relative to the norm of the tensor itself. Since $h$ is transverse, this should be near zero.\n    *   $R_{\\mathrm{trace}}$: Measures the norm of the trace $\\mathrm{tr} = h_{ii}$ relative to the tensor norm. Since $h$ is traceless, this should be near zero.\n    *   $R_{\\mathrm{TT}}$: Tests the idempotency of the projector. Since $h(\\mathbf{k})$ is already in the TT subspace, projecting it again should not change it: $P^{\\mathrm{TT}}[h] = h$. This ratio measures the relative norm of the difference, $\\|h - P^{\\mathrm{TT}}[h]\\|^2 / \\|h\\|^2$, which should also be numerically close to zero, validating the implementation of the projector.\n\nIn all calculations, norms $\\|X\\|^2$ are computed as the sum of the squared modulus over all grid points and component indices, i.e., `numpy.sum(numpy.abs(X)**2)`.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_for_case(params):\n    \"\"\"\n    Generates and validates scalar, vector, and tensor fields for a single test case.\n\n    Args:\n        params (dict): A dictionary containing the parameters N, L, A, B, C, k0, and seed.\n\n    Returns:\n        list: A list of the five computed purity ratios.\n    \"\"\"\n    N, L, A, B, C, k0, seed = params['N'], params['L'], params['A'], params['B'], params['C'], params['k0'], params['seed']\n    rng = np.random.default_rng(seed)\n\n    # 1. Setup k-space grid\n    k_coords = 2 * np.pi * np.fft.fftfreq(N, d=L/N)\n    kx, ky, kz = np.meshgrid(k_coords, k_coords, k_coords, indexing='ij')\n    k_vecs = np.array([kx, ky, kz])\n    k_squared = kx**2 + ky**2 + kz**2\n    k_norm = np.sqrt(k_squared)\n    \n    k_is_nonzero = k_squared > 1e-12 # Use tolerance for float comparison\n    \n    k_squared_inv = np.zeros_like(k_squared, dtype=float)\n    np.divide(1.0, k_squared, out=k_squared_inv, where=k_is_nonzero)\n\n    # --- Part 1: Scalar Field ---\n    \n    noise_phi_real = rng.standard_normal(size=(N, N, N))\n    noise_phi_k = np.fft.fftn(noise_phi_real)\n    \n    P_phi = A / (1 + (k_norm / k0)**4)\n    phi_k = noise_phi_k * np.sqrt(P_phi)\n    \n    g_k = 1j * k_vecs * phi_k\n    \n    k_dot_g = np.einsum('i...,i...->...', k_vecs, g_k)\n    g_long = k_vecs * k_squared_inv * k_dot_g\n    g_sol = g_k - g_long\n    \n    norm_g_sq = np.sum(np.abs(g_k)**2)\n    norm_g_sol_sq = np.sum(np.abs(g_sol)**2)\n    R_scalar = norm_g_sol_sq / norm_g_sq if norm_g_sq > 0 else 0.0\n\n    # --- Part 2: Vector Field ---\n\n    noise_v_real = rng.standard_normal(size=(3, N, N, N))\n    noise_v_k = np.fft.fftn(noise_v_real, axes=(1, 2, 3))\n\n    k_dot_noise_v = np.einsum('i...,i...->...', k_vecs, noise_v_k)\n    V_proj_k = noise_v_k - k_vecs * k_squared_inv * k_dot_noise_v\n    V_proj_k[:, np.logical_not(k_is_nonzero)] = 0.0\n\n    S_v = B * np.exp(-(k_norm / k0)**2)\n    V_k = V_proj_k * np.sqrt(S_v)\n    \n    k_dot_V = np.einsum('i...,i...->...', k_vecs, V_k)\n    V_long = k_vecs * k_squared_inv * k_dot_V\n    \n    norm_V_sq = np.sum(np.abs(V_k)**2)\n    norm_V_long_sq = np.sum(np.abs(V_long)**2)\n    R_vector = norm_V_long_sq / norm_V_sq if norm_V_sq > 0 else 0.0\n\n    # --- Part 3: Tensor Field ---\n    \n    def project_to_TT(T_k):\n        # 1. Make transverse on first index: T'_ij = T_ij - k_i/k^2 (k_m T_mj)\n        v_j = np.einsum('m...,mj...->j...', k_vecs, T_k, optimize=True)\n        T_prime = T_k - np.einsum('i...,j...->ij...', k_vecs * k_squared_inv, v_j, optimize=True)\n\n        # 2. Make transverse on second index: T''_ij = T'_ij - k_j/k^2 (k_m T'_im)\n        u_i = np.einsum('m...,im...->i...', k_vecs, T_prime, optimize=True)\n        h_T = T_prime - np.einsum('j...,i...->ij...', k_vecs * k_squared_inv, u_i, optimize=True)\n        \n        # 3. Make traceless: h_TT = h_T - 1/2 Lambda tr(h_T)\n        trace_h_T = np.einsum('ii...->...', h_T, optimize=True)\n        \n        k_outer_k_over_ksq = np.einsum('i...,j...->ij...', k_vecs, k_vecs, optimize=True) * k_squared_inv\n        Lambda_ij = np.eye(3)[:, :, np.newaxis, np.newaxis, np.newaxis] - k_outer_k_over_ksq\n        \n        h_TT = h_T - 0.5 * Lambda_ij * trace_h_T\n        h_TT[:, :, np.logical_not(k_is_nonzero)] = 0.0\n        return h_TT\n\n    noise_h_real = rng.standard_normal(size=(3, 3, N, N, N))\n    noise_h_k = np.fft.fftn(noise_h_real, axes=(2, 3, 4))\n    h_sym_k = 0.5 * (noise_h_k + noise_h_k.transpose(1, 0, 2, 3, 4))\n    \n    h_TT_k = project_to_TT(h_sym_k)\n    \n    S_h = C * (k_norm / k0)**2 * np.exp(-(k_norm / k0)**2)\n    np.nan_to_num(S_h, copy=False, nan=0.0)\n    h_k = h_TT_k * np.sqrt(S_h)\n\n    norm_h_sq = np.sum(np.abs(h_k)**2)\n\n    d_j = np.einsum('i...,ij...->j...', k_vecs, h_k, optimize=True)\n    norm_d_sq = np.sum(np.abs(d_j)**2)\n    R_div = norm_d_sq / norm_h_sq if norm_h_sq > 0 else 0.0\n\n    tr = np.einsum('ii...->...', h_k, optimize=True)\n    norm_tr_sq = np.sum(np.abs(tr)**2)\n    R_trace = norm_tr_sq / norm_h_sq if norm_h_sq > 0 else 0.0\n    \n    h_reprojected = project_to_TT(h_k)\n    diff_h = h_k - h_reprojected\n    norm_diff_h_sq = np.sum(np.abs(diff_h)**2)\n    R_TT = norm_diff_h_sq / norm_h_sq if norm_h_sq > 0 else 0.0\n\n    return [R_scalar, R_vector, R_div, R_trace, R_TT]\n\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'N': 16, 'L': 1, 'A': 1.0, 'B': 1.0, 'C': 1.0, 'k0': 12.0, 'seed': 12345},\n        {'N': 8,  'L': 1, 'A': 1.0, 'B': 0.5, 'C': 1.5, 'k0': 9.0,  'seed': 54321},\n        {'N': 20, 'L': 1, 'A': 2.0, 'B': 0.8, 'C': 0.7, 'k0': 10.0, 'seed': 2025},\n    ]\n\n    results = []\n    for params in test_cases:\n        case_results = solve_for_case(params)\n        results.extend(case_results)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3485117"}, {"introduction": "With an understanding of how to build pure modes, we can now tackle the inverse problem: decomposing an arbitrary symmetric tensor field into its irreducible scalar, vector, and tensor parts. This practice challenges you to develop a complete decomposition algorithm that operates in Fourier space, leveraging the power of the Fast Fourier Transform (FFT) to turn differential constraints into simple algebraic operations [@problem_id:3485225]. This is a capstone exercise that translates the entire theoretical framework into a powerful and practical tool for analyzing data from cosmological simulations.", "problem": "You are given a real-valued, symmetric rank-$2$ tensor field $h_{ij}(\\mathbf{x})$ sampled on a periodic cubic grid of size $N \\times N \\times N$ with periodic box length $L$. The goal is to implement a program that performs a Scalar–Vector–Tensor (SVT) decomposition of $h_{ij}$ on the periodic domain using the Fast Fourier Transform (FFT), leveraging the fact that in Fourier space derivatives map to multiplication by $i k_i$, where $k_i$ are the Fourier wavevector components, and that divergence and trace constraints can be expressed algebraically. Work in three spatial dimensions $i,j \\in \\{0,1,2\\}$.\n\nBase your derivation and algorithm on the following fundamental principles and core definitions:\n\n- Periodic Fourier analysis on a cubic box of side $L$ with discrete modes labeled by integer triplets $(n_x,n_y,n_z)$, and wavevectors $\\mathbf{k}$ such that $k_i = 2\\pi n_i / L$.\n- The mapping of spatial derivatives to Fourier multipliers: $\\partial_i \\to i k_i$, and the associated properties of divergence and trace in Fourier space.\n- The decomposition of a symmetric perturbation tensor perturbation $h_{ij}$ into scalar, vector, and tensor contributions that satisfy the defining constraints:\n  - Scalar part comprises contributions built from scalar potentials and contributes to isotropic trace and double derivatives.\n  - Vector part is built from a transverse vector potential (divergence-free) and yields a symmetric contribution linear in derivatives that is divergence-free but not traceless in general.\n  - Tensor part is simultaneously transverse and traceless.\n- Orthogonal projectors built from the Fourier wavevector that separate longitudinal and transverse components, and the related algebraic construction to isolate transverse and traceless pieces in Fourier space.\n\nYou must outline, derive, and implement an algorithm that, given $h_{ij}(\\mathbf{x})$, computes its scalar $S_{ij}(\\mathbf{x})$, vector $V_{ij}(\\mathbf{x})$, and tensor $T_{ij}(\\mathbf{x})$ components such that $h_{ij} = S_{ij} + V_{ij} + T_{ij}$, with $V_{ij}$ being divergence-free and $T_{ij}$ being divergence-free and traceless in the sense of Fourier-space constraints.\n\nScientific and numerical handling requirements:\n\n- Treat the periodic zero mode $\\mathbf{k}=\\mathbf{0}$ by a convention that is consistent and numerically stable. Specifically, at $\\mathbf{k}=\\mathbf{0}$, you must not divide by $k^2$ and you must define a convention that assigns the isotropic trace of $h_{ij}$ to the scalar sector and sets the vector and tensor sectors to zero at this mode.\n- Treat Nyquist modes, i.e., those modes for which any component $k_i$ equals the Nyquist value in an even-sized grid, carefully. Since Nyquist modes are self-conjugate under $\\mathbf{k}\\to -\\mathbf{k}$, ensure the algebra is applied without division by zero and that the resulting Fourier coefficients are consistent with a real-valued field in real space.\n- Your algorithm must be invariant under rotations of $\\mathbf{k}$ and must rely only on algebraic operations in Fourier space plus inverse transforms back to configuration space.\n\nImplementation details required:\n\n- Use discrete Fourier transforms via the Fast Fourier Transform to map between real space and Fourier space on the periodic domain.\n- Work in three spatial dimensions, indices $i,j \\in \\{0,1,2\\}$.\n- Let the periodic box length be $L = 1$ (unitless), and compute Fourier wavevectors as $k_i = 2\\pi \\,\\mathrm{fftfreq}(N, d=L/N)$ along each axis.\n- Construct a test suite of synthetic fields to verify your implementation. For each test, you must generate a real-space tensor field by constructing its Fourier coefficients according to the following deterministic recipes, and then applying an inverse FFT.\n\nSynthetic test suite:\n\n- Test $1$ (Scalar-only, even grid): $N=8$, $L=1$. Define scalar potentials in Fourier space using real, even amplitudes\n  - $\\psi(\\mathbf{k}) = \\exp\\!\\big(-(|\\mathbf{k}|/k_0)^2\\big)$ with $k_0 = 4.0$, except set $\\psi(\\mathbf{0}) = 1.2$,\n  - $E(\\mathbf{k}) = 0.3 \\,\\exp\\!\\big(-(|\\mathbf{k}|/k_1)^2\\big)$ with $k_1 = 3.0$.\n  Construct $h^{(S)}_{ij}(\\mathbf{k}) = 2 \\,\\psi(\\mathbf{k}) \\,\\delta_{ij} - 2 \\,E(\\mathbf{k}) \\,k_i k_j$. Set vector and tensor parts to zero: $h^{(V)}_{ij}(\\mathbf{k})=0$, $h^{(T)}_{ij}(\\mathbf{k})=0$. Inverse transform to $h_{ij}(\\mathbf{x})$.\n- Test $2$ (Vector-only, even grid): $N=8$, $L=1$. Define a transverse vector field in Fourier space as follows. For each $\\mathbf{k}\\neq \\mathbf{0}$, define the transverse projector $P_{ij}(\\mathbf{k})$ built from $\\mathbf{k}$, choose a fixed unit vector $a_j$ with $a_j = (0,0,1)$, and set $n_j(\\mathbf{k}) = P_{jk}(\\mathbf{k})\\,a_k$, with the fallback $a_j=(0,1,0)$ if $n_j(\\mathbf{k})=\\mathbf{0}$. Let $A_F(\\mathbf{k}) = \\exp\\!\\big(-(|\\mathbf{k}|/k_0)^2\\big)$ with $k_0=5.0$, and define $F_j(\\mathbf{k}) = A_F(\\mathbf{k}) \\,n_j(\\mathbf{k})/\\big\\|n(\\mathbf{k})\\big\\|$. Set $F_j(\\mathbf{0})=\\mathbf{0}$. Then set $h^{(V)}_{ij}(\\mathbf{k}) = i \\,k_i F_j(\\mathbf{k}) + i \\,k_j F_i(\\mathbf{k})$. Set scalar and tensor parts to zero: $h^{(S)}_{ij}(\\mathbf{k})=0$, $h^{(T)}_{ij}(\\mathbf{k})=0$. Inverse transform to $h_{ij}(\\mathbf{x})$.\n- Test $3$ (Tensor-only, odd grid): $N=9$, $L=1$. For a constant symmetric matrix $C_{lm}=\\mathrm{diag}(1,-1,0)$ and amplitude $A_T(\\mathbf{k}) = \\exp\\!\\big(-(|\\mathbf{k}|/k_0)^2\\big)$ with $k_0=4.0$, define for each $\\mathbf{k}\\neq \\mathbf{0}$ the transverse projector $P_{ij}(\\mathbf{k})$ and construct the standard transverse-traceless operator built from $P_{ij}$. Apply it to $C_{lm}$ and multiply by $A_T(\\mathbf{k})$ to obtain $h^{(T)}_{ij}(\\mathbf{k})$, and set $h^{(T)}_{ij}(\\mathbf{0})=0$. Set scalar and vector parts to zero: $h^{(S)}_{ij}(\\mathbf{k})=0$, $h^{(V)}_{ij}(\\mathbf{k})=0$. Inverse transform to $h_{ij}(\\mathbf{x})$.\n- Test $4$ (Mixed, even grid): $N=8$, $L=1$. Construct $h^{(S)}_{ij}$ as in Test $1$, $h^{(V)}_{ij}$ as in Test $2$, and $h^{(T)}_{ij}$ as in Test $3$ but with $N=8$ and the same $k_0=4.0$. Sum all three in Fourier space and inverse transform to obtain a mixed field $h_{ij}(\\mathbf{x})$.\n\nNumerical comparison and outputs:\n\n- For each test, let $H$ denote the full input field in real space and let $(S,V,T)$ be the components returned by your decomposition algorithm in real space.\n- Define the discrete $L^2$-norm of a tensor field $X$ on the grid as the square root of the sum of squares over all components and all grid points.\n- For Test $1$, compute the following three floats:\n  - $e_{1,S} = \\|S - H\\|/\\|H\\|$,\n  - $r_{1,V} = \\|V\\|/\\|H\\|$,\n  - $r_{1,T} = \\|T\\|/\\|H\\|$.\n- For Test $2$, compute:\n  - $r_{2,S} = \\|S\\|/\\|H\\|$,\n  - $e_{2,V} = \\|V - H\\|/\\|H\\|$,\n  - $r_{2,T} = \\|T\\|/\\|H\\|$.\n- For Test $3$, compute:\n  - $r_{3,S} = \\|S\\|/\\|H\\|$,\n  - $r_{3,V} = \\|V\\|/\\|H\\|$,\n  - $e_{3,T} = \\|T - H\\|/\\|H\\|$.\n- For Test $4$, compute:\n  - $e_{4,S} = \\|S - H^{(S)}\\|/\\|H^{(S)}\\|$,\n  - $e_{4,V} = \\|V - H^{(V)}\\|/\\|H^{(V)}\\|$,\n  - $e_{4,T} = \\|T - H^{(T)}\\|/\\|H^{(T)}\\|$,\n  where $H^{(S)}$, $H^{(V)}$, and $H^{(T)}$ are the real-space components generated for the mixed field.\n\nYour program should produce a single line of output containing the $12$ results for Tests $1$ through $4$ in the following order:\n$[e_{1,S}, r_{1,V}, r_{1,T}, r_{2,S}, e_{2,V}, r_{2,T}, r_{3,S}, r_{3,V}, e_{3,T}, e_{4,S}, e_{4,V}, e_{4,T}]$,\nas a comma-separated list enclosed in square brackets. All values are unitless real numbers. Roundings are not required; print full-precision floats as obtained by the computation.\n\nConstraints and notes:\n\n- Ensure numerical stability by never dividing by $k^2$ at $\\mathbf{k}=\\mathbf{0}$, and by treating Nyquist modes like any other nonzero wavevector.\n- Ensure that the inverse FFT of the constructed Fourier-space fields produces real-valued $h_{ij}(\\mathbf{x})$ within numerical precision, by maintaining the Hermitian symmetry required for real fields.\n- The implementation must be self-contained, require no input, and follow the exact output format described above.", "solution": "The provided code implements a standard algorithm for the Scalar-Vector-Tensor (SVT) decomposition in Fourier space, where differential operators become algebraic multiplications. The method proceeds as follows:\n1.  **Fourier Transform**: The input real-space tensor field $h_{ij}(\\mathbf{x})$ is transformed into Fourier space to get $\\tilde{h}_{ij}(\\mathbf{k})$ using a Fast Fourier Transform (FFT). All subsequent operations are performed on $\\tilde{h}_{ij}(\\mathbf{k})$ for each wavevector $\\mathbf{k}$.\n2.  **Handle Zero Mode**: The $\\mathbf{k}=\\mathbf{0}$ mode is treated separately, as the projection operators are singular at this mode. By convention, the entire $\\mathbf{k}=\\mathbf{0}$ component of the tensor is assigned to the scalar part, representing the spatial average of the field. The vector and tensor components at $\\mathbf{k}=\\mathbf{0}$ are set to zero.\n3.  **Isolate Scalar Component**: For each $\\mathbf{k} \\neq \\mathbf{0}$, the scalar part $\\tilde{S}_{ij}$ is constructed. This part can be expressed in terms of two scalar potentials. The algorithm extracts these by first computing two scalar quantities from $\\tilde{h}_{ij}$: its trace, $\\tilde{h}_{kk}$, and its \"double divergence,\" $k_i k_j \\tilde{h}_{ij}$. From these, the two scalar potentials are algebraically determined, which allows for the reconstruction of the full scalar component tensor $\\tilde{S}_{ij}(\\mathbf{k})$.\n4.  **Isolate Vector Component**: The vector component $\\tilde{V}_{ij}$ is constructed from a transverse vector potential. The algorithm first computes the divergence of the input tensor, $k_i \\tilde{h}_{ij}$, to get a vector. It then projects out the longitudinal part of this vector to isolate the transverse vector potential. This potential is then used to construct the purely vector part of the tensor, $\\tilde{V}_{ij}(\\mathbf{k})$.\n5.  **Isolate Tensor Component**: The tensor component $\\tilde{T}_{ij}$ is, by definition, what remains after the scalar and vector parts have been subtracted: $\\tilde{T}_{ij} = \\tilde{h}_{ij} - \\tilde{S}_{ij} - \\tilde{V}_{ij}$. By construction, this component is transverse ($k_i \\tilde{T}_{ij} = 0$) and traceless ($\\tilde{T}_{kk} = 0$) for $\\mathbf{k} \\neq \\mathbf{0}$.\n6.  **Inverse Transform**: Finally, the separated Fourier-space components $\\tilde{S}_{ij}$, $\\tilde{V}_{ij}$, and $\\tilde{T}_{ij}$ are transformed back to real space using an inverse FFT to yield the final decomposed fields $S_{ij}(\\mathbf{x})$, $V_{ij}(\\mathbf{x})$, and $T_{ij}(\\mathbf{x})$.", "answer": "```python\nimport numpy as np\n\ndef l2_norm(tensor_field):\n    \"\"\"Computes the discrete L2-norm of a real tensor field on the grid.\"\"\"\n    return np.sqrt(np.sum(tensor_field**2))\n\ndef svt_decomposition(h_ij, L):\n    \"\"\"\n    Performs the Scalar-Vector-Tensor (SVT) decomposition of a symmetric rank-2 tensor field h_ij.\n    \n    Args:\n        h_ij (np.ndarray): A (3, 3, N, N, N) real-valued tensor field.\n        L (float): The side length of the periodic box.\n\n    Returns:\n        tuple: A tuple (S_ij, V_ij, T_ij) of the real-space component fields.\n    \"\"\"\n    N = h_ij.shape[-1]\n    \n    # Step 1: Fourier transform the input field.\n    h_tilde = np.fft.fftn(h_ij, axes=(-3, -2, -1))\n\n    # Step 2: Set up k-space grid.\n    k_coords = 2 * np.pi * np.fft.fftfreq(N, d=L/N)\n    kx, ky, kz = np.meshgrid(k_coords, k_coords, k_coords, indexing='ij')\n    k_vec = np.stack((kx, ky, kz), axis=0)\n    k_squared = kx**2 + ky**2 + kz**2\n\n    # Step 3: Initialize Fourier components of S, V, T.\n    S_tilde = np.zeros_like(h_tilde, dtype=complex)\n    V_tilde = np.zeros_like(h_tilde, dtype=complex)\n\n    # Step 4: Isolate k != 0 modes for algebraic operations.\n    nonzero_k_mask = k_squared > 1e-12\n    \n    if np.any(nonzero_k_mask):\n        k_vec_nz = k_vec[..., nonzero_k_mask]\n        k_squared_nz = k_squared[nonzero_k_mask]\n        h_tilde_nz = h_tilde[..., nonzero_k_mask]\n        \n        # --- Scalar part (S_tilde) for k != 0 ---\n        h_tr_nz = np.einsum('ii...->...', h_tilde_nz)\n        h_divdiv_nz = np.einsum('i...,j...,ij...->...', k_vec_nz, k_vec_nz, h_tilde_nz)\n        \n        inv_k2_nz = 1.0 / k_squared_nz\n        \n        # The two scalar potentials (up to factors)\n        sigma_nz = 0.5 * (h_tr_nz - h_divdiv_nz * inv_k2_nz)\n        E_double_prime_nz = 0.5 * inv_k2_nz * (h_divdiv_nz * inv_k2_nz - h_tr_nz)\n        \n        delta_ij = np.identity(3).reshape(3, 3, 1)\n        k_outer_k_nz = np.einsum('i...,j...->ij...', k_vec_nz, k_vec_nz)\n        S_tilde[..., nonzero_k_mask] = delta_ij * sigma_nz + k_outer_k_nz * E_double_prime_nz\n\n        # --- Vector part (V_tilde) for k != 0 ---\n        v_nz = np.einsum('i...,ij...->j...', k_vec_nz, h_tilde_nz)\n        v_dot_k_nz = np.einsum('i...,i...->...', k_vec_nz, v_nz)\n        v_transverse_nz = v_nz - k_vec_nz * v_dot_k_nz * inv_k2_nz\n        \n        # Vector potential (up to factors)\n        F_nz = v_transverse_nz / (1j * k_squared_nz)\n        \n        term1 = np.einsum('i...,j...->ij...', k_vec_nz, F_nz)\n        V_tilde[..., nonzero_k_mask] = 1j * (term1 + term1.transpose(1, 0, 2))\n\n    # Step 5: Handle the k = 0 mode according to the specified convention.\n    S_tilde[:, :, 0, 0, 0] = h_tilde[:, :, 0, 0, 0]\n    V_tilde[:, :, 0, 0, 0] = 0.0\n\n    # Step 6: The tensor part is the remainder.\n    T_tilde = h_tilde - S_tilde - V_tilde\n    \n    # Step 7: Inverse transform to get real-space fields.\n    S_ij = np.fft.ifftn(S_tilde, axes=(-3, -2, -1)).real\n    V_ij = np.fft.ifftn(V_tilde, axes=(-3, -2, -1)).real\n    T_ij = np.fft.ifftn(T_tilde, axes=(-3, -2, -1)).real\n\n    return S_ij, V_ij, T_ij\n\ndef generate_scalar_field(N, L, k0, k1):\n    k_coords = 2 * np.pi * np.fft.fftfreq(N, d=L/N)\n    kx, ky, kz = np.meshgrid(k_coords, k_coords, k_coords, indexing='ij')\n    k_squared = kx**2 + ky**2 + kz**2\n    k_abs = np.sqrt(k_squared)\n    \n    psi = np.exp(-(k_abs/k0)**2)\n    psi[0,0,0] = 1.2\n    E = 0.3 * np.exp(-(k_abs/k1)**2)\n    \n    delta_ij = np.identity(3).reshape(3,3,1,1,1)\n    k_vec = np.stack((kx, ky, kz), axis=0)\n    k_outer_k = np.einsum('i...,j...->ij...', k_vec, k_vec)\n    \n    h_S_tilde = 2.0 * psi * delta_ij - 2.0 * E * k_outer_k\n    h_V_tilde = np.zeros_like(h_S_tilde, dtype=complex)\n    h_T_tilde = np.zeros_like(h_S_tilde, dtype=complex)\n    return h_S_tilde, h_V_tilde, h_T_tilde\n\ndef generate_vector_field(N, L, k0):\n    k_coords = 2 * np.pi * np.fft.fftfreq(N, d=L/N)\n    kx, ky, kz = np.meshgrid(k_coords, k_coords, k_coords, indexing='ij')\n    k_vec = np.stack((kx, ky, kz), axis=0)\n    k_squared = kx**2 + ky**2 + kz**2\n    k_abs = np.sqrt(k_squared)\n\n    h_V_tilde = np.zeros((3,3,N,N,N), dtype=complex)\n    nonzero_k_mask = k_squared > 1e-12\n    \n    inv_k2 = np.divide(1.0, k_squared, where=nonzero_k_mask, out=np.zeros_like(k_squared))\n    \n    a_vec = np.array([0,0,1]).reshape(3,1,1,1)\n    k_dot_a = kz\n    n_vec = a_vec - k_vec * k_dot_a * inv_k2\n\n    z_axis_mask = (kx==0)  (ky==0)  nonzero_k_mask\n    if np.any(z_axis_mask):\n        a_fb = np.array([0,1,0]).reshape(3,1,1,1)\n        k_dot_a_fb = ky\n        n_fb = a_fb - k_vec * k_dot_a_fb * inv_k2\n        n_vec[..., z_axis_mask] = n_fb[..., z_axis_mask]\n\n    n_norm = np.linalg.norm(n_vec, axis=0)\n    F_vec = np.zeros_like(k_vec, dtype=complex)\n    AF = np.exp(-(k_abs/k0)**2)\n\n    valid_mask = (n_norm > 1e-12)  nonzero_k_mask\n    np.divide(n_vec, n_norm, out=F_vec, where=valid_mask)\n    F_vec *= AF\n    \n    k_otimes_F = np.einsum('i...,j...->ij...', k_vec, F_vec)\n    h_V_tilde = 1j * (k_otimes_F + k_otimes_F.transpose(1,0,2,3,4))\n    \n    return np.zeros_like(h_V_tilde), h_V_tilde, np.zeros_like(h_V_tilde)\n\ndef generate_tensor_field(N, L, k0):\n    k_coords = 2 * np.pi * np.fft.fftfreq(N, d=L/N)\n    kx, ky, kz = np.meshgrid(k_coords, k_coords, k_coords, indexing='ij')\n    k_vec = np.stack((kx, ky, kz), axis=0)\n    k_squared = kx**2 + ky**2 + kz**2\n    k_abs = np.sqrt(k_squared)\n\n    h_T_tilde = np.zeros((3,3,N,N,N), dtype=complex)\n    nonzero_k_mask = k_squared > 1e-12\n    \n    inv_k2 = np.divide(1.0, k_squared, where=nonzero_k_mask, out=np.zeros_like(k_squared))\n    C = np.diag([1.0, -1.0, 0.0]).reshape(3,3,1,1,1)\n    delta_ij = np.identity(3).reshape(3,3,1,1,1)\n    \n    P_op = np.zeros_like(h_T_tilde, dtype=float)\n    k_outer_k = np.einsum('i...,j...->ij...', k_vec, k_vec)\n    P_op[..., nonzero_k_mask] = (delta_ij - k_outer_k * inv_k2)[..., nonzero_k_mask]\n\n    PPC = np.einsum('il...,jm...,lm...->ij...', P_op, P_op, C)\n    P_trace_C = np.einsum('lm...,lm...->...', P_op, C)\n    Lambda_C = PPC - 0.5 * P_op * P_trace_C[np.newaxis, np.newaxis, ...]\n\n    AT = np.exp(-(k_abs/k0)**2)\n    h_T_tilde = AT * Lambda_C\n    h_T_tilde[..., ~nonzero_k_mask] = 0.0\n\n    return np.zeros_like(h_T_tilde), np.zeros_like(h_T_tilde), h_T_tilde\n\ndef generate_test_case(test_id, N):\n    if test_id == 1:\n        L, k0, k1 = 1.0, 4.0, 3.0\n        h_S_tilde, h_V_tilde, h_T_tilde = generate_scalar_field(N, L, k0, k1)\n    elif test_id == 2:\n        L, k0 = 1.0, 5.0\n        h_S_tilde, h_V_tilde, h_T_tilde = generate_vector_field(N, L, k0)\n    elif test_id == 3:\n        L, k0 = 1.0, 4.0\n        h_S_tilde, h_V_tilde, h_T_tilde = generate_tensor_field(N, L, k0)\n    elif test_id == 4:\n        L = 1.0\n        s_S, _, _ = generate_scalar_field(N, L, 4.0, 3.0)\n        _, s_V, _ = generate_vector_field(N, L, 5.0)\n        _, _, s_T = generate_tensor_field(N, L, 4.0)\n        h_S_tilde, h_V_tilde, h_T_tilde = s_S, s_V, s_T\n    else:\n        raise ValueError(\"Invalid test_id\")\n\n    h_total_tilde = h_S_tilde + h_V_tilde + h_T_tilde\n    \n    H = np.fft.ifftn(h_total_tilde, axes=(-3,-2,-1)).real\n    H_S = np.fft.ifftn(h_S_tilde, axes=(-3,-2,-1)).real\n    H_V = np.fft.ifftn(h_V_tilde, axes=(-3,-2,-1)).real\n    H_T = np.fft.ifftn(h_T_tilde, axes=(-3,-2,-1)).real\n    \n    return H, H_S, H_V, H_T, L\n\ndef solve():\n    results = []\n\n    # Test 1\n    H1, _, _, _, L1 = generate_test_case(1, N=8)\n    S1, V1, T1 = svt_decomposition(H1, L1)\n    norm_H1 = l2_norm(H1)\n    e_1_S = l2_norm(S1 - H1) / norm_H1\n    r_1_V = l2_norm(V1) / norm_H1\n    r_1_T = l2_norm(T1) / norm_H1\n    results.extend([e_1_S, r_1_V, r_1_T])\n\n    # Test 2\n    H2, _, _, _, L2 = generate_test_case(2, N=8)\n    S2, V2, T2 = svt_decomposition(H2, L2)\n    norm_H2 = l2_norm(H2)\n    r_2_S = l2_norm(S2) / norm_H2\n    e_2_V = l2_norm(V2 - H2) / norm_H2\n    r_2_T = l2_norm(T2) / norm_H2\n    results.extend([r_2_S, e_2_V, r_2_T])\n\n    # Test 3\n    H3, _, _, _, L3 = generate_test_case(3, N=9)\n    S3, V3, T3 = svt_decomposition(H3, L3)\n    norm_H3 = l2_norm(H3)\n    r_3_S = l2_norm(S3) / norm_H3\n    r_3_V = l2_norm(V3) / norm_H3\n    e_3_T = l2_norm(T3 - H3) / norm_H3\n    results.extend([r_3_S, r_3_V, e_3_T])\n\n    # Test 4\n    H4, H4_S, H4_V, H4_T, L4 = generate_test_case(4, N=8)\n    S4, V4, T4 = svt_decomposition(H4, L4)\n    norm_H4_S = l2_norm(H4_S)\n    norm_H4_V = l2_norm(H4_V)\n    norm_H4_T = l2_norm(H4_T)\n    \n    e_4_S = l2_norm(S4 - H4_S) / norm_H4_S if norm_H4_S > 1e-15 else l2_norm(S4 - H4_S)\n    e_4_V = l2_norm(V4 - H4_V) / norm_H4_V if norm_H4_V > 1e-15 else l2_norm(V4 - H4_V)\n    e_4_T = l2_norm(T4 - H4_T) / norm_H4_T if norm_H4_T > 1e-15 else l2_norm(T4 - H4_T)\n    results.extend([e_4_S, e_4_V, e_4_T])\n\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```", "id": "3485225"}, {"introduction": "The SVT decomposition is not just a static classification scheme; it is also a powerful diagnostic for assessing the quality of numerical simulations. This final practice demonstrates how to use these concepts to monitor the evolution of a vector field that should analytically remain divergence-free but develops a spurious \"scalar contamination\" due to numerical discretization errors [@problem_id:3485188]. This exercise provides a concrete example of how the SVT framework is essential for validating the physical fidelity of complex numerical codes and understanding the subtle ways in which discrete operators can violate continuum conservation laws.", "problem": "Consider a two-dimensional, periodic, square domain with side length $L=2\\pi$, uniform grid of size $N\\times N$, and dimensionless coordinates $(x,y)\\in[0,2\\pi)\\times[0,2\\pi)$. In cosmological perturbation theory, the vector (solenoidal) component of a velocity perturbation field, denoted by $\\mathbf{v}^{\\mathrm{V}}$, is defined by the constraint $\\nabla\\cdot \\mathbf{v}^{\\mathrm{V}} = 0$. The scalar contamination in a numerically evolved velocity field $\\mathbf{v}$ can be quantified by monitoring the growth of $\\nabla\\cdot \\mathbf{v}$ over time. \n\nYou will study how spatial finite-difference stencils and explicit time integrators affect the divergence constraint when evolving an initially divergence-free field. Use the following physically and numerically well-posed setup based on the diffusion equation, which analytically preserves solenoidality: the field evolves according to\n$$\n\\partial_t \\mathbf{v}(x,y,t) = \\nu \\nabla^2 \\mathbf{v}(x,y,t),\n$$\nwith viscosity coefficient $\\nu>0$, and periodic boundary conditions in both directions. The analytical property\n$$\n\\partial_t (\\nabla\\cdot \\mathbf{v}) = \\nu \\nabla^2 (\\nabla\\cdot \\mathbf{v})\n$$\nimplies that if $\\nabla\\cdot \\mathbf{v}(x,y,0) = 0$ initially, then $\\nabla\\cdot \\mathbf{v}(x,y,t)=0$ for all $t$, in the continuum. Any nonzero $\\nabla\\cdot \\mathbf{v}$ that emerges in the computation is due to discretization and time-integration errors.\n\nConstruct the initial divergence-free field from a stream function $\\Psi(x,y)$ so that\n$$\n\\mathbf{v}(x,y,0) \\equiv \\mathbf{v}^{\\mathrm{V}}(x,y,0) = (\\partial_y \\Psi,\\,-\\partial_x \\Psi),\n$$\nwith\n$$\n\\Psi(x,y) = \\sin(k x)\\sin(k y),\n$$\nwhere $k$ is an integer wavenumber. This guarantees $\\nabla\\cdot \\mathbf{v}(x,y,0)=0$ analytically.\n\nSpatial discretization of the Laplacian $\\nabla^2$ must be performed using one of the following finite-difference central stencils on a uniform grid with spacing $\\Delta x = \\Delta y = 2\\pi/N$, and periodic wrap-around:\n- Second-order accurate Laplacian in each direction:\n$$\n\\partial_{xx} f \\approx \\frac{f_{i+1,j} - 2 f_{i,j} + f_{i-1,j}}{\\Delta x^2},\\quad\n\\partial_{yy} f \\approx \\frac{f_{i,j+1} - 2 f_{i,j} + f_{i,j-1}}{\\Delta x^2}.\n$$\n- Fourth-order accurate Laplacian in each direction:\n$$\n\\partial_{xx} f \\approx \\frac{-f_{i+2,j} + 16 f_{i+1,j} - 30 f_{i,j} + 16 f_{i-1,j} - f_{i-2,j}}{12\\,\\Delta x^2},\\quad\n\\partial_{yy} f \\approx \\frac{-f_{i,j+2} + 16 f_{i,j+1} - 30 f_{i,j} + 16 f_{i,j-1} - f_{i,j-2}}{12\\,\\Delta x^2}.\n$$\n\nTime integration must be performed using one of the following explicit schemes:\n- Forward Euler (first order):\n$$\n\\mathbf{v}^{n+1} = \\mathbf{v}^n + \\Delta t\\, \\nu \\nabla^2 \\mathbf{v}^n.\n$$\n- Two-stage second-order Runge–Kutta (Heun’s method):\n$$\n\\mathbf{v}^{(1)} = \\mathbf{v}^n + \\Delta t\\, \\nu \\nabla^2 \\mathbf{v}^n,\\quad\n\\mathbf{v}^{n+1} = \\mathbf{v}^n + \\frac{\\Delta t}{2}\\left[\\nu \\nabla^2 \\mathbf{v}^n + \\nu \\nabla^2 \\mathbf{v}^{(1)}\\right].\n$$\n\nTo measure scalar contamination independently of the chosen finite-difference stencil, compute the divergence field $\\nabla\\cdot\\mathbf{v}$ using a spectral derivative with the Fast Fourier Transform (FFT), defining wavenumbers by $k_x = 2\\pi\\,\\mathrm{fftfreq}(N,\\Delta x)$ and similarly for $k_y$, so that in Fourier space the divergence is\n$$\n\\widehat{\\nabla\\cdot\\mathbf{v}}(\\mathbf{k}) = i k_x \\widehat{v_x}(\\mathbf{k}) + i k_y \\widehat{v_y}(\\mathbf{k}),\n$$\nwith inverse FFT to return to physical space. Quantify contamination at the final time $T = \\mathrm{steps}\\times \\Delta t$ by the ratio of root-mean-square (RMS) norms\n$$\nR \\equiv \\frac{\\sqrt{\\langle (\\nabla\\cdot \\mathbf{v})^2 \\rangle}}{\\sqrt{\\langle |\\mathbf{v}|^2 \\rangle}},\n$$\nwhere $\\langle\\cdot\\rangle$ denotes the spatial average over the grid, and $|\\mathbf{v}|^2 = v_x^2 + v_y^2$. This $R$ is dimensionless because all quantities are defined on a dimensionless domain.\n\nImplement a complete, runnable program that:\n- Initializes $\\mathbf{v}(x,y,0)$ from $\\Psi$ with $k=4$,\n- Evolves the field according to the specified $\\nu$, finite-difference Laplacian order, and time integrator choice,\n- Computes the final contamination ratio $R$ using the FFT-based divergence.\n\nUse the following test suite of parameter values to probe the effects of stencil accuracy and time integration on divergence growth. All quantities are dimensionless; express all answers as floating-point numbers. The angle unit for trigonometric functions is radians.\n\nTest suite (each case is a tuple $(N,\\mathrm{order},\\mathrm{integrator},\\Delta t,\\mathrm{steps},\\nu)$):\n1. $(64,\\,2,\\,\\text{euler},\\,0.02,\\,100,\\,0.1)$\n2. $(64,\\,2,\\,\\text{rk2},\\,0.02,\\,100,\\,0.1)$\n3. $(64,\\,4,\\,\\text{euler},\\,0.005,\\,400,\\,0.1)$\n4. $(64,\\,4,\\,\\text{rk2},\\,0.01,\\,200,\\,0.1)$\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[r_1,r_2,r_3,r_4]$), where $r_i$ is the final contamination ratio $R$ computed for test case $i$. The output must be strictly in this format and contain no additional text.", "solution": "The user-provided problem has been analyzed and is deemed valid. It is scientifically grounded, well-posed, objective, and contains all necessary information for a unique solution. The following is a complete, reasoned solution.\n\n### **1. Principle of the Method**\n\nThe core task is to simulate the viscous diffusion of a two-dimensional velocity field $\\mathbf{v}(x,y,t)$ on a periodic square domain and quantify the breakdown of an analytically conserved property, the divergence-free (solenoidal) condition, due to numerical errors. The evolution is governed by the vector diffusion equation:\n$$\n\\partial_t \\mathbf{v} = \\nu \\nabla^2 \\mathbf{v}\n$$\nwhere $\\nu$ is the kinematic viscosity. Analytically, if the initial field is divergence-free, i.e., $\\nabla \\cdot \\mathbf{v}(t=0) = 0$, it remains so for all time $t>0$. This is because the divergence and Laplacian operators commute: $\\partial_t(\\nabla \\cdot \\mathbf{v}) = \\nabla \\cdot (\\partial_t \\mathbf{v}) = \\nabla \\cdot (\\nu \\nabla^2 \\mathbf{v}) = \\nu \\nabla^2 (\\nabla \\cdot \\mathbf{v})$. Thus, the divergence itself obeys a diffusion equation, and if it is initially zero everywhere, it remains zero.\n\nIn a numerical simulation using finite-difference methods, the discrete operators for divergence and the Laplacian may not commute perfectly. This leads to the generation of a spurious, non-zero divergence, often referred to as scalar contamination in cosmology. The magnitude of this contamination depends on the accuracy of the spatial discretization and the time integration scheme. This problem investigates this effect by comparing different numerical schemes.\n\n### **2. Discretization and Initial Conditions**\n\nThe simulation is performed on a uniform $N \\times N$ grid over the domain $[0, 2\\pi) \\times [0, 2\\pi)$. The grid spacing is $\\Delta x = \\Delta y = 2\\pi/N$.\n\nThe initial velocity field must be divergence-free. This is guaranteed by constructing it from a stream function $\\Psi(x,y)$:\n$$\n\\mathbf{v}(x,y,0) = (v_x, v_y) = (\\partial_y \\Psi, -\\partial_x \\Psi)\n$$\nThis automatically satisfies $\\nabla \\cdot \\mathbf{v} = \\partial_x v_x + \\partial_y v_y = \\partial_x(\\partial_y \\Psi) + \\partial_y(-\\partial_x \\Psi) = \\partial_x \\partial_y \\Psi - \\partial_y \\partial_x \\Psi = 0$ for smooth functions.\n\nUsing the given stream function $\\Psi(x,y) = \\sin(k x)\\sin(k y)$ with wavenumber $k=4$, the initial velocity components are computed analytically and then evaluated on the grid points $(x_i, y_j)$:\n$$\nv_x(x,y,0) = k \\sin(k x) \\cos(k y)\n$$\n$$\nv_y(x,y,0) = -k \\cos(k x) \\sin(k y)\n$$\nThis provides the initial discrete fields $(v_x^0, v_y^0)$ for the time evolution.\n\n### **3. Numerical Implementation**\n\n#### **3.1. Spatial Discretization: The Laplacian Operator**\n\nThe Laplacian operator $\\nabla^2 = \\partial_{xx} + \\partial_{yy}$ is approximated using central finite-difference stencils. Due to the periodic domain, grid points outside the boundary are mapped back into the domain. This is implemented efficiently using `numpy.roll`, which shifts array elements with wrap-around. Two stencil accuracies are required:\n\n- **Second-order:** For a field $f_{i,j}$, the Laplacian is discretized as:\n$$\n(\\nabla^2 f)_{i,j} \\approx \\frac{f_{i+1,j} - 2f_{i,j} + f_{i-1,j}}{\\Delta x^2} + \\frac{f_{i,j+1} - 2f_{i,j} + f_{i,j-1}}{\\Delta y^2}\n$$\n- **Fourth-order:** The higher-order stencil provides a more accurate approximation:\n$$\n(\\nabla^2 f)_{i,j} \\approx \\frac{-f_{i+2,j} + 16f_{i+1,j} - 30f_{i,j} + 16f_{i-1,j} - f_{i-2,j}}{12\\Delta x^2} + \\frac{-f_{i,j+2} + 16f_{i,j+1} - 30f_{i,j} + 16f_{i,j-1} - f_{i,j-2}}{12\\Delta y^2}\n$$\nA function implements these stencils, taking the field, stencil order, and grid spacing $\\Delta x$ as input.\n\n#### **3.2. Time Integration**\n\nThe system of ordinary differential equations resulting from spatial discretization, $\\frac{d\\mathbf{v}}{dt} = \\nu \\nabla^2_{FD} \\mathbf{v}$, is solved using one of two explicit time-stepping methods.\n\n- **Forward Euler (1st order):** A simple, one-step method.\n$$\n\\mathbf{v}^{n+1} = \\mathbf{v}^n + \\Delta t \\, (\\nu \\nabla^2_{FD} \\mathbf{v}^n)\n$$\n- **Heun's Method (2nd-order Runge-Kutta):** A two-stage predictor-corrector method with higher accuracy.\n$$\n\\mathbf{v}^{*} = \\mathbf{v}^n + \\Delta t \\, (\\nu \\nabla^2_{FD} \\mathbf{v}^n) \\quad\\text{(predictor)}\n$$\n$$\n\\mathbf{v}^{n+1} = \\mathbf{v}^n + \\frac{\\Delta t}{2} \\left[ \\nu \\nabla^2_{FD} \\mathbf{v}^n + \\nu \\nabla^2_{FD} \\mathbf{v}^{*} \\right] \\quad\\text{(corrector)}\n$$\nThe evolution is carried out for a specified number of steps, `steps`.\n\n### **4. Analysis of Scalar Contamination**\n\nAfter the final time step, the level of scalar contamination is quantified.\n\n#### **4.1. Divergence Calculation via FFT**\n\nTo obtain a highly accurate measurement of the divergence, independent of the finite-difference stencil used for the evolution, a spectral method is employed. The derivative property of the Fourier transform states that differentiation in real space corresponds to multiplication by $i\\mathbf{k}$ in Fourier space, where $\\mathbf{k}=(k_x, k_y)$ is the wavevector.\n\nThe algorithm is as follows:\n1.  Compute the 2D Fast Fourier Transform (FFT) of the final velocity components: $\\widehat{v_x}(\\mathbf{k}) = \\mathcal{F}(v_x)$ and $\\widehat{v_y}(\\mathbf{k}) = \\mathcal{F}(v_y)$.\n2.  Define the discrete wavevectors corresponding to the grid, as specified: $k_x = 2\\pi\\,\\mathrm{fftfreq}(N, \\Delta x)$ and $k_y = 2\\pi\\,\\mathrm{fftfreq}(N, \\Delta y)$.\n3.  Compute the FFT of the divergence field: $\\widehat{\\nabla\\cdot\\mathbf{v}}(\\mathbf{k}) = i k_x \\widehat{v_x}(\\mathbf{k}) + i k_y \\widehat{v_y}(\\mathbf{k})$.\n4.  Compute the inverse FFT to transform the result back to real space: $\\nabla\\cdot\\mathbf{v}(x,y) = \\mathcal{F}^{-1}(\\widehat{\\nabla\\cdot\\mathbf{v}})$. The result is a real-valued field, so the imaginary part from numerical noise is discarded.\n\n#### **4.2. Contamination Ratio $R$**\n\nThe final contamination is measured by the dimensionless ratio $R$, which normalizes the \"energy\" in the divergent component of the flow by the total energy in the flow. It is calculated using the root-mean-square (RMS) spatial average, denoted by $\\langle \\cdot \\rangle$:\n$$\nR = \\frac{\\sqrt{\\langle (\\nabla\\cdot \\mathbf{v})^2 \\rangle}}{\\sqrt{\\langle |\\mathbf{v}|^2 \\rangle}} = \\frac{\\sqrt{\\frac{1}{N^2}\\sum_{i,j} (\\nabla\\cdot \\mathbf{v}_{i,j})^2}}{\\sqrt{\\frac{1}{N^2}\\sum_{i,j} (v_{x,i,j}^2 + v_{y,i,j}^2)}}\n$$\nThis ratio is computed for the final state of the velocity field for each test case.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef get_laplacian(field, order, dx):\n    \"\"\"\n    Computes the 2D Laplacian of a field on a periodic grid using finite differences.\n    \n    Args:\n        field (np.ndarray): The 2D input field.\n        order (int): The order of accuracy of the stencil (2 or 4).\n        dx (float): The grid spacing, assumed equal in both directions.\n\n    Returns:\n        np.ndarray: The discretized Laplacian of the field.\n    \"\"\"\n    if order == 2:\n        d2_dx2 = (np.roll(field, -1, axis=0) - 2 * field + np.roll(field, 1, axis=0)) / dx**2\n        d2_dy2 = (np.roll(field, -1, axis=1) - 2 * field + np.roll(field, 1, axis=1)) / dx**2\n        return d2_dx2 + d2_dy2\n    elif order == 4:\n        # Coefficients for the 5-point, 4th-order stencil\n        c = np.array([-1., 16., -30., 16., -1.])\n        denom = 12. * dx**2\n        \n        d2_dx2 = (c[0] * np.roll(field, -2, axis=0) +\n                  c[1] * np.roll(field, -1, axis=0) +\n                  c[2] * field +\n                  c[3] * np.roll(field, 1, axis=0) +\n                  c[4] * np.roll(field, 2, axis=0)) / denom\n        \n        d2_dy2 = (c[0] * np.roll(field, -2, axis=1) +\n                  c[1] * np.roll(field, -1, axis=1) +\n                  c[2] * field +\n                  c[3] * np.roll(field, 1, axis=1) +\n                  c[4] * np.roll(field, 2, axis=1)) / denom\n        return d2_dx2 + d2_dy2\n    else:\n        raise ValueError(\"Stencil order must be 2 or 4\")\n\ndef compute_contamination_ratio(vx, vy, N, dx):\n    \"\"\"\n    Computes the scalar contamination ratio R using FFT-based divergence.\n\n    Args:\n        vx (np.ndarray): The x-component of the velocity field.\n        vy (np.ndarray): The y-component of the velocity field.\n        N (int): The grid size in one dimension.\n        dx (float): The grid spacing.\n\n    Returns:\n        float: The dimensionless contamination ratio R.\n    \"\"\"\n    # 1. Compute divergence using spectral method\n    k_1d = 2 * np.pi * np.fft.fftfreq(N, d=dx)\n    kx, ky = np.meshgrid(k_1d, k_1d, indexing='ij')\n\n    vx_hat = np.fft.fft2(vx)\n    vy_hat = np.fft.fft2(vy)\n\n    div_v_hat = 1j * kx * vx_hat + 1j * ky * vy_hat\n    div_v = np.fft.ifft2(div_v_hat).real\n\n    # 2. Compute RMS norms\n    rms_div_v = np.sqrt(np.mean(div_v**2))\n    rms_v = np.sqrt(np.mean(vx**2 + vy**2))\n    \n    if rms_v == 0:\n        return 0.0\n\n    return rms_div_v / rms_v\n\ndef run_simulation(N, order, integrator, dt, steps, nu):\n    \"\"\"\n    Runs a single simulation case and returns the final contamination ratio.\n\n    Args:\n        N (int): Grid size.\n        order (int): Stencil order.\n        integrator (str): Time integrator ('euler' or 'rk2').\n        dt (float): Time step size.\n        steps (int): Number of time steps.\n        nu (float): Viscosity coefficient.\n\n    Returns:\n        float: The final contamination ratio R.\n    \"\"\"\n    L = 2. * np.pi\n    k_wave = 4.\n    dx = L / N\n\n    # Initialize grid and velocity field\n    grid_pts = np.arange(N) * dx\n    x, y = np.meshgrid(grid_pts, grid_pts, indexing='ij')\n    \n    vx = k_wave * np.sin(k_wave * x) * np.cos(k_wave * y)\n    vy = -k_wave * np.cos(k_wave * x) * np.sin(k_wave * y)\n\n    # Time evolution loop\n    for _ in range(steps):\n        if integrator == 'euler':\n            lap_vx = get_laplacian(vx, order, dx)\n            lap_vy = get_laplacian(vy, order, dx)\n            vx += dt * nu * lap_vx\n            vy += dt * nu * lap_vy\n        elif integrator == 'rk2':\n            # Stage 1 (predictor)\n            lap_vx_n = get_laplacian(vx, order, dx)\n            lap_vy_n = get_laplacian(vy, order, dx)\n            \n            vx_star = vx + dt * nu * lap_vx_n\n            vy_star = vy + dt * nu * lap_vy_n\n            \n            # Stage 2 (corrector)\n            lap_vx_star = get_laplacian(vx_star, order, dx)\n            lap_vy_star = get_laplacian(vy_star, order, dx)\n            \n            vx += 0.5 * dt * nu * (lap_vx_n + lap_vx_star)\n            vy += 0.5 * dt * nu * (lap_vy_n + lap_vy_star)\n        else:\n            raise ValueError(f\"Unknown integrator: {integrator}\")\n\n    # Compute final answer\n    return compute_contamination_ratio(vx, vy, N, dx)\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # (N, order, integrator, dt, steps, nu)\n        (64, 2, 'euler', 0.02, 100, 0.1),\n        (64, 2, 'rk2', 0.02, 100, 0.1),\n        (64, 4, 'euler', 0.005, 400, 0.1),\n        (64, 4, 'rk2', 0.01, 200, 0.1),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_simulation(*case)\n        results.append(result)\n\n    # Print results in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3485188"}]}