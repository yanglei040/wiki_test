{"hands_on_practices": [{"introduction": "The physics of Baryon Acoustic Oscillations is rooted in the behavior of the primordial photon-baryon fluid. While photons provide immense pressure, baryons contribute inertia without significant pressure, effectively acting as a \"load\" on the system. This practice explores the fundamental consequence of this baryon loading, which is a reduction in the fluid's sound speed. By performing this analytical calculation ([@problem_id:3465623]), you will directly derive the phase shift imparted on an acoustic wave, providing a core understanding of how the baryon-to-photon ratio, $R$, critically influences the acoustic scale.", "problem": "Consider a Fourier mode with comoving wavenumber $k$ in the tightly coupled photon–baryon fluid before the baryon drag epoch. In the tight-coupling limit and neglecting anisotropic stress, photon diffusion (Silk damping), and any time variation of the gravitational potential, the combined photon–baryon fluid obeys an acoustic wave equation with an effective sound speed $c_{s}$ that depends on the baryon loading parameter $R$, where $R \\equiv 3 \\rho_{b}/(4 \\rho_{\\gamma})$ and $\\rho_{b}$ and $\\rho_{\\gamma}$ denote the baryon and photon energy densities, respectively. In units where the speed of light is $c=1$, the sound speed satisfies $c_{s}^{2} = 1/\\big(3(1+R)\\big)$.\n\nAssume the following scientifically realistic scenario:\n- For conformal times $\\eta < \\eta_{1}$, the baryon loading is negligible, so $R \\approx 0$ and $c_{s} = 1/\\sqrt{3}$.\n- For conformal times $\\eta \\in [\\eta_{1}, \\eta_{d}]$, the baryon loading $R$ can be treated as constant and nonzero ($R>0$), such that $c_{s} = 1/\\sqrt{3(1+R)}$ over this interval.\n- The acoustic phase of the mode is well described by the Wentzel–Kramers–Brillouin (WKB) form, with phase accumulation given by the integral of the instantaneous frequency $k c_{s}$ over conformal time.\n\nDefine the acoustic phase $\\varphi(k,\\eta)$ by the argument of the oscillatory solution and consider the phase at the end of the interval, $\\eta=\\eta_{d}$. Let $\\Delta \\varphi(k)$ denote the difference between the acoustic phase accumulated in the baryon-loaded model and the baryon-free reference computed over the same interval $[\\eta_{1}, \\eta_{d}]$:\n$$\\Delta \\varphi(k) \\equiv \\big[\\varphi_{R>0}(k,\\eta_{d}) - \\varphi_{R>0}(k,\\eta_{1})\\big] - \\big[\\varphi_{R=0}(k,\\eta_{d}) - \\varphi_{R=0}(k,\\eta_{1})\\big].$$\n\nStarting from the tight-coupling acoustic dynamics and the definition of $c_{s}$ given above, derive a closed-form analytic expression for $\\Delta \\varphi(k)$ under the assumptions stated. Express your final answer in radians as a function of $k$, $R$, and the conformal time interval $\\Delta \\eta \\equiv \\eta_{d} - \\eta_{1}$. The final answer must be a single analytical expression, not an inequality or an equation to be solved.", "solution": "The problem statement is scientifically grounded, well-posed, and internally consistent under the stated assumptions. It presents a standard, albeit simplified, scenario in the study of baryon acoustic oscillations. All required definitions and conditions are provided, allowing for a direct and unambiguous derivation. Therefore, the problem is valid.\n\nThe central task is to calculate the phase difference $\\Delta \\varphi(k)$ for a comoving Fourier mode with wavenumber $k$. The problem defines $\\Delta \\varphi(k)$ as the difference in accumulated acoustic phase between a baryon-loaded universe and a baryon-free universe over the conformal time interval $[\\eta_{1}, \\eta_{d}]$.\n$$\n\\Delta \\varphi(k) \\equiv \\big[\\varphi_{R>0}(k,\\eta_{d}) - \\varphi_{R>0}(k,\\eta_{1})\\big] - \\big[\\varphi_{R=0}(k,\\eta_{d}) - \\varphi_{R=0}(k,\\eta_{1})\\big]\n$$\n\nAccording to the Wentzel–Kramers–Brillouin (WKB) approximation specified, the acoustic phase $\\varphi(k, \\eta)$ accumulates over conformal time as the integral of the instantaneous frequency, which is given by $k c_{s}(\\eta)$. Therefore, the phase accumulated over the interval $[\\eta_{1}, \\eta_{d}]$ is given by the integral:\n$$\n\\varphi(k, \\eta_{d}) - \\varphi(k, \\eta_{1}) = \\int_{\\eta_{1}}^{\\eta_{d}} k c_{s}(\\eta') \\, d\\eta'\n$$\n\nWe must evaluate this integral for the two scenarios described: one with baryon loading ($R>0$) and a reference scenario without it ($R=0$).\n\nFirst, consider the baryon-loaded case ($R>0$). The problem states that for $\\eta \\in [\\eta_{1}, \\eta_{d}]$, the baryon loading parameter $R$ is a non-zero constant. The effective sound speed $c_{s}$ is thus also constant over this interval and is given by:\n$$\nc_{s, R>0} = \\frac{1}{\\sqrt{3(1+R)}}\n$$\nThe phase accumulated in this case, which is the first term in the definition of $\\Delta \\varphi(k)$, is:\n$$\n\\varphi_{R>0}(k,\\eta_{d}) - \\varphi_{R>0}(k,\\eta_{1}) = \\int_{\\eta_{1}}^{\\eta_{d}} k \\, c_{s, R>0} \\, d\\eta'\n$$\nSince $k$ and $c_{s, R>0}$ are constant with respect to the integration variable $\\eta'$, we can take them outside the integral:\n$$\n\\varphi_{R>0}(k,\\eta_{d}) - \\varphi_{R>0}(k,\\eta_{1}) = k \\, c_{s, R>0} \\int_{\\eta_{1}}^{\\eta_{d}} d\\eta' = k \\frac{1}{\\sqrt{3(1+R)}} (\\eta_{d} - \\eta_{1})\n$$\nUsing the definition $\\Delta \\eta \\equiv \\eta_{d} - \\eta_{1}$, this becomes:\n$$\n\\varphi_{R>0}(k,\\eta_{d}) - \\varphi_{R>0}(k,\\eta_{1}) = \\frac{k \\Delta \\eta}{\\sqrt{3(1+R)}}\n$$\n\nNext, we consider the baryon-free reference case ($R=0$). This corresponds to a fluid of photons only. The sound speed is found by setting $R=0$ in the general formula:\n$$\nc_{s, R=0} = \\frac{1}{\\sqrt{3(1+0)}} = \\frac{1}{\\sqrt{3}}\n$$\nThis sound speed is also constant. The phase accumulated in this reference case, which is the second term in the definition of $\\Delta \\varphi(k)$, is:\n$$\n\\varphi_{R=0}(k,\\eta_{d}) - \\varphi_{R=0}(k,\\eta_{1}) = \\int_{\\eta_{1}}^{\\eta_{d}} k \\, c_{s, R=0} \\, d\\eta'\n$$\nSimilarly, we take the constants outside the integral:\n$$\n\\varphi_{R=0}(k,\\eta_{d}) - \\varphi_{R=0}(k,\\eta_{1}) = k \\, c_{s, R=0} \\int_{\\eta_{1}}^{\\eta_{d}} d\\eta' = k \\frac{1}{\\sqrt{3}} (\\eta_{d} - \\eta_{1})\n$$\nIn terms of $\\Delta \\eta$, this is:\n$$\n\\varphi_{R=0}(k,\\eta_{d}) - \\varphi_{R=0}(k,\\eta_{1}) = \\frac{k \\Delta \\eta}{\\sqrt{3}}\n$$\n\nFinally, we substitute these two results into the defining expression for $\\Delta \\varphi(k)$:\n$$\n\\Delta \\varphi(k) = \\left( \\frac{k \\Delta \\eta}{\\sqrt{3(1+R)}} \\right) - \\left( \\frac{k \\Delta \\eta}{\\sqrt{3}} \\right)\n$$\nWe can factor out the common terms $k$, $\\Delta \\eta$, and $1/\\sqrt{3}$ to obtain the final closed-form expression:\n$$\n\\Delta \\varphi(k) = \\frac{k \\Delta \\eta}{\\sqrt{3}} \\left( \\frac{1}{\\sqrt{1+R}} - 1 \\right)\n$$\nThis expression represents the phase shift, which is negative as expected since baryon loading reduces the sound speed and thus retards the phase accumulation of the acoustic wave. It is a function of $k$, $R$, and $\\Delta \\eta$ as required.", "answer": "$$\n\\boxed{\\frac{k \\Delta \\eta}{\\sqrt{3}} \\left( \\frac{1}{\\sqrt{1+R}} - 1 \\right)}\n$$", "id": "3465623"}, {"introduction": "The sound horizon at the drag epoch, $r_d$, serves as the \"standard ruler\" in BAO cosmology. Its size is determined by the total comoving distance an acoustic wave could travel from the Big Bang until the time when baryons decoupled from photons. This calculation requires integrating the evolving sound speed, $c_s(a)$, over the expansion history of the Universe. This hands-on coding exercise ([@problem_id:3465692]) guides you through the process of numerically computing $r_d$, stress-testing the stability of your result with different numerical methods, and validating it against the widely-used Eisenstein-Hu analytical approximation.", "problem": "Implement a program that computes the baryon-drag sound horizon scale $r_d$ in megaparsecs for several cosmological models and stress-tests numerical stability against rapidly varying effective sound speed by comparing two adaptive numerical methods and cross-checking with a standard approximate formula.\n\nBegin from the following foundations.\n\n1. The baryon-drag sound horizon at the drag epoch is defined as the conformal distance traveled by coupled baryon-photon acoustic waves up to the drag scale factor $a_d$, which is given by\n$$\nr_d \\equiv \\int_{0}^{a_d} \\frac{c_s(a)}{a^2 H(a)} \\, \\mathrm{d}a,\n$$\nwhere $c_s(a)$ is the effective sound speed of the photon-baryon fluid, and $H(a)$ is the Hubble expansion rate.\n\n2. The effective sound speed is\n$$\nc_s(a) = \\frac{c}{\\sqrt{3\\left(1 + R(a)\\right)}},\n$$\nwith\n$$\nR(a) \\equiv \\frac{3 \\rho_b(a)}{4 \\rho_\\gamma(a)} = \\frac{3}{4}\\frac{\\Omega_b}{\\Omega_\\gamma} a.\n$$\nHere $c$ is the speed of light in vacuum in $\\mathrm{km/s}$, $\\rho_b$ and $\\rho_\\gamma$ are the baryon and photon energy densities, respectively, and $\\Omega_b$ and $\\Omega_\\gamma$ are their present-day density parameters.\n\n3. The Hubble rate as a function of scale factor $a$ in a spatially flat Universe is\n$$\nH(a) = H_0 \\sqrt{\\Omega_r a^{-4} + \\Omega_m a^{-3} + \\Omega_\\Lambda},\n$$\nwith $H_0 = 100\\, h \\, \\mathrm{km\\, s^{-1}\\, Mpc^{-1}}$, and $\\Omega_\\Lambda = 1 - \\Omega_m - \\Omega_r$. The present-day radiation density parameter is\n$$\n\\Omega_r = \\Omega_\\gamma \\left( 1 + 0.2271\\, N_{\\mathrm{eff}} \\right),\n$$\nwhere $N_{\\mathrm{eff}}$ is the Effective Number of Relativistic Species (commonly $N_{\\mathrm{eff}} \\approx 3.046$). The photon density parameter satisfies\n$$\n\\Omega_\\gamma h^2 = 2.469 \\times 10^{-5} \\left(\\frac{T_{\\mathrm{CMB}}}{2.7255\\,\\mathrm{K}}\\right)^4,\n$$\nwhere $T_{\\mathrm{CMB}}$ is the temperature of the Cosmic Microwave Background (CMB).\n\n4. The drag redshift $z_d$ is to be computed from the Eisenstein–Hu fitting formula,\n$$\nz_d = \\frac{1291 (\\Omega_m h^2)^{0.251}}{1 + 0.659 (\\Omega_m h^2)^{0.828}}\\left[ 1 + b_1 (\\Omega_b h^2)^{b_2} \\right],\n$$\nwhere\n$$\nb_1 = 0.313 (\\Omega_m h^2)^{-0.419}\\left[1 + 0.607 (\\Omega_m h^2)^{0.674} \\right],\\quad\nb_2 = 0.238 (\\Omega_m h^2)^{0.223}.\n$$\nThen $a_d = 1/(1+z_d)$.\n\n5. For cross-checking purposes, use the Eisenstein–Hu analytic approximation for the sound horizon at the drag epoch,\n$$\nr_d^{\\mathrm{EH}} = \\frac{2}{3 k_{\\mathrm{eq}}} \\sqrt{\\frac{6}{R_{\\mathrm{eq}}}} \\,\n\\ln\\!\\left(\\frac{\\sqrt{1 + R_d} + \\sqrt{R_d + R_{\\mathrm{eq}}}}{1 + \\sqrt{R_{\\mathrm{eq}}}}\\right),\n$$\nwhere $R_d = R(a_d)$, $a_{\\mathrm{eq}} = \\Omega_r / \\Omega_m$, $R_{\\mathrm{eq}} = R(a_{\\mathrm{eq}})$, and\n$$\nk_{\\mathrm{eq}} \\equiv \\frac{a_{\\mathrm{eq}} H(a_{\\mathrm{eq}})}{c},\n$$\nexpressed in $\\mathrm{Mpc}^{-1}$ when $H$ is in $\\mathrm{km\\, s^{-1}\\, Mpc^{-1}}$ and $c$ in $\\mathrm{km\\, s^{-1}}$. The value $r_d^{\\mathrm{EH}}$ is in $\\mathrm{Mpc}$.\n\nTask requirements.\n\nA. Implement two independent adaptive numerical methods to evaluate $r_d$:\n- Method 1: Adaptive quadrature of the integral over $a \\in [0, a_d]$. Because the integrand is finite but approaches a constant as $a \\to 0$ in the radiation-dominated regime, you must start the numerical integral at a small $a_{\\min} > 0$ and add the analytic early-time contribution\n$$\n\\Delta r(a_{\\min}) = \\frac{c}{\\sqrt{3}\\, H_0 \\sqrt{\\Omega_r}}\\, a_{\\min},\n$$\nso that $r_d \\approx \\Delta r(a_{\\min}) + \\int_{a_{\\min}}^{a_d} \\frac{c_s(a)}{a^2 H(a)}\\, \\mathrm{d}a$.\n- Method 2: Adaptive integration of the ordinary differential equation\n$$\n\\frac{\\mathrm{d}r}{\\mathrm{d}a} = \\frac{c_s(a)}{a^2 H(a)}, \\quad r(a_{\\min}) = \\Delta r(a_{\\min}),\n$$\nfrom $a_{\\min}$ to $a_d$ with stepsize control.\n\nBoth methods must use tight absolute and relative tolerances to probe numerical stability under rapidly varying $c_s(a)$ induced by the baryon loading term $R(a)$.\n\nB. For each cosmological parameter set, compute:\n- The value $r_d$ in $\\mathrm{Mpc}$ by Method 1 (adaptive quadrature).\n- The value $r_d$ in $\\mathrm{Mpc}$ by Method 2 (adaptive ODE).\n- The approximate $r_d^{\\mathrm{EH}}$ in $\\mathrm{Mpc}$ from the Eisenstein–Hu approximation.\n\nFrom these, form two dimensionless diagnostics:\n- The relative difference between the two numerical methods,\n$$\n\\delta_{\\mathrm{num}} = \\frac{\\left| r_d^{(1)} - r_d^{(2)} \\right|}{\\tfrac{1}{2}\\left( r_d^{(1)} + r_d^{(2)} \\right)}.\n$$\n- The relative deviation from the Eisenstein–Hu approximation using Method 1,\n$$\n\\delta_{\\mathrm{EH}} = \\frac{\\left| r_d^{(1)} - r_d^{\\mathrm{EH}} \\right|}{r_d^{\\mathrm{EH}}}.\n$$\n\nC. Use the following test suite of five cosmological models, each specified by $(\\Omega_m, \\Omega_b, h, N_{\\mathrm{eff}}, T_{\\mathrm{CMB}})$:\n- Case 1 (Planck-like baseline): $(0.315, 0.049, 0.674, 3.046, 2.7255\\,\\mathrm{K})$.\n- Case 2 (high baryon loading): $(0.35, 0.08, 0.70, 3.046, 2.7255\\,\\mathrm{K})$.\n- Case 3 (enhanced relativistic species): $(0.315, 0.049, 0.674, 4.0, 2.7255\\,\\mathrm{K})$.\n- Case 4 (low baryon fraction): $(0.30, 0.02, 0.67, 3.046, 2.7255\\,\\mathrm{K})$.\n- Case 5 (extremely low baryon fraction): $(0.27, 0.005, 0.67, 3.046, 2.7255\\,\\mathrm{K})$.\n\nOutput specification.\n\n- Internal computations of $r_d$ must be performed and treated in $\\mathrm{Mpc}$.\n- For each case, compute $\\delta_{\\mathrm{num}}$ and $\\delta_{\\mathrm{EH}}$ as defined above (dimensionless).\n- Your program should produce a single line of output containing the results as a comma-separated list of $10$ floating-point numbers enclosed in square brackets, in the order\n$$\n[\\delta_{\\mathrm{num}}^{(1)}, \\delta_{\\mathrm{EH}}^{(1)}, \\delta_{\\mathrm{num}}^{(2)}, \\delta_{\\mathrm{EH}}^{(2)}, \\ldots, \\delta_{\\mathrm{num}}^{(5)}, \\delta_{\\mathrm{EH}}^{(5)}].\n$$\nRound nothing; print the full precision produced by standard Python string conversion of floats.", "solution": "The problem is valid as it is well-posed, scientifically grounded in established cosmological principles, and provides a complete, consistent set of definitions and parameters. All provided equations are standard in the field of cosmology or come from widely used fitting formulae. The test cases are physically plausible. The task is a well-defined numerical problem.\n\nThe solution computes the baryon-drag sound horizon, $r_d$, a fundamental scale in cosmology related to Baryon Acoustic Oscillations (BAOs). This scale is the maximum distance a sound wave in the primordial baryon-photon plasma could travel from the Big Bang until the epoch when baryons decoupled from photons (the drag epoch, at scale factor $a_d$). The computation is performed for several cosmological models, each defined by a set of parameters $(\\Omega_m, \\Omega_b, h, N_{\\mathrm{eff}}, T_{\\mathrm{CMB}})$.\n\nFirst, for each model, we establish the cosmological background. The input parameters are the present-day matter density parameter $\\Omega_m$, baryon density parameter $\\Omega_b$, reduced Hubble constant $h$, effective number of relativistic species $N_{\\mathrm{eff}}$, and CMB temperature $T_{\\mathrm{CMB}}$. From these, we derive other essential quantities. The Hubble constant is $H_0 = 100\\, h \\, \\mathrm{km\\, s^{-1}\\, Mpc^{-1}}$. The present photon density parameter $\\Omega_\\gamma$ is calculated from $T_{\\mathrm{CMB}}$ via the Stefan-Boltzmann law, using the relation $\\Omega_\\gamma h^2 = 2.469 \\times 10^{-5} (T_{\\mathrm{CMB}} / 2.7255\\,\\mathrm{K})^4$. The total radiation density $\\Omega_r$ includes photons and relativistic neutrinos, given by $\\Omega_r = \\Omega_\\gamma ( 1 + 0.2271\\, N_{\\mathrm{eff}} )$. In a spatially flat universe, the dark energy density is $\\Omega_\\Lambda = 1 - \\Omega_m - \\Omega_r$. With these parameters, the Hubble expansion rate at any scale factor $a$ is given by the Friedmann equation:\n$$\nH(a) = H_0 \\sqrt{\\Omega_r a^{-4} + \\Omega_m a^{-3} + \\Omega_\\Lambda}\n$$\n\nThe sound horizon $r_d$ is defined by the integral of the sound speed $c_s(a)$ over conformal time up to the drag epoch $a_d$:\n$$\nr_d = \\int_0^{a_d} \\frac{c_s(a)}{a^2 H(a)} \\, \\mathrm{d}a\n$$\nThe sound speed of the photon-baryon fluid depends on the ratio of baryon to photon energy densities, $R(a) = (3\\rho_b/4\\rho_\\gamma) = (3/4)(\\Omega_b/\\Omega_\\gamma)a$:\n$$\nc_s(a) = \\frac{c}{\\sqrt{3\\left(1 + R(a)\\right)}}\n$$\nwhere $c$ is the speed of light. The upper limit of integration, $a_d$, is the scale factor at the drag epoch, calculated from the drag redshift $z_d$ as $a_d = 1/(1+z_d)$. We compute $z_d$ using the accurate Eisenstein-Hu fitting formula, which depends on the physical matter and baryon densities, $\\Omega_m h^2$ and $\\Omega_b h^2$.\n\nThe integral for $r_d$ runs from $a=0$. The term $a^2$ in the denominator creates a potential numerical singularity. However, in the early universe ($a \\to 0$), the universe is radiation-dominated, so $H(a) \\approx H_0 \\sqrt{\\Omega_r} a^{-2}$, and the baryon loading $R(a) \\to 0$, so $c_s(a) \\to c/\\sqrt{3}$. The integrand thus approaches a constant, $\\frac{c}{\\sqrt{3} H_0 \\sqrt{\\Omega_r}}$. To handle the integral, we split it at a small scale factor $a_{\\min} > 0$:\n$$\nr_d = \\int_0^{a_{\\min}} \\frac{c_s(a)}{a^2 H(a)} \\, \\mathrm{d}a + \\int_{a_{\\min}}^{a_d} \\frac{c_s(a)}{a^2 H(a)} \\, \\mathrm{d}a\n$$\nThe first term is well-approximated by $\\Delta r(a_{\\min}) = \\frac{c}{\\sqrt{3} H_0 \\sqrt{\\Omega_r}} a_{\\min}$. The second term is computed numerically.\n\nWe implement two high-precision numerical methods for this task:\n1.  **Method 1 (Adaptive Quadrature)**: We directly compute the definite integral from $a_{\\min}$ to $a_d$ using `scipy.integrate.quad`, a robust adaptive quadrature routine. The final result is $r_d^{(1)} = \\Delta r(a_{\\min}) + \\int_{a_{\\min}}^{a_d} \\frac{c_s(a)}{a^2 H(a)} \\, \\mathrm{d}a$.\n2.  **Method 2 (Adaptive ODE Integration)**: We recast the problem as a first-order ordinary differential equation for $r(a)$, $\\frac{\\mathrm{d}r}{\\mathrm{d}a} = \\frac{c_s(a)}{a^2 H(a)}$, with the initial condition $r(a_{\\min}) = \\Delta r(a_{\\min})$. We solve this initial value problem from $a = a_{\\min}$ to $a = a_d$ using `scipy.integrate.solve_ivp` with a high-order adaptive step-size solver. The value of the solution at $a_d$ gives $r_d^{(2)}$.\n\nFor cross-checking, we also compute the Eisenstein-Hu analytic approximation, $r_d^{\\mathrm{EH}}$, which provides a quick and fairly accurate estimate of the sound horizon without numerical integration.\n\nFinally, for each cosmological model, we compute two dimensionless diagnostics. The first, $\\delta_{\\mathrm{num}} = |r_d^{(1)} - r_d^{(2)}| / (\\frac{1}{2}(r_d^{(1)} + r_d^{(2)}))$, measures the numerical stability and agreement between the two independent high-precision methods. The second, $\\delta_{\\mathrm{EH}} = |r_d^{(1)} - r_d^{\\mathrm{EH}}| / r_d^{\\mathrm{EH}}$, quantifies the accuracy of the Eisenstein-Hu fitting formula against a precise numerical integration. These diagnostics are calculated for all five test cases and presented in the required output format. Extremely tight tolerances ($10^{-13}$) are used for the numerical solvers to ensure that $\\delta_{\\mathrm{num}}$ is a robust measure of method consistency.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad, solve_ivp\n\nC_KM_S = 299792.458  # Speed of light in km/s\n\ndef calculate_diagnostics(params):\n    \"\"\"\n    Computes diagnostic quantities for a given cosmological model.\n    \n    For a given set of cosmological parameters, this function calculates the \n    baryon-drag sound horizon r_d using two numerical methods and one analytic \n    approximation. It then computes the relative differences between these results.\n    \n    Args:\n        params (tuple): A tuple of cosmological parameters \n                        (Omega_m, Omega_b, h, N_eff, T_CMB).\n\n    Returns:\n        tuple: A tuple containing two floats: (delta_num, delta_eh).\n    \"\"\"\n    Omega_m, Omega_b, h, N_eff, T_CMB = params\n\n    # Constants and Derived Parameters\n    H0 = 100.0 * h  # Hubble constant in km/s/Mpc\n    omega_mh2 = Omega_m * h**2\n    omega_bh2 = Omega_b * h**2\n\n    # Photon and radiation densities\n    omega_gamma_h2 = 2.469e-5 * (T_CMB / 2.7255)**4\n    Omega_gamma = omega_gamma_h2 / h**2\n    omega_r_h2 = omega_gamma_h2 * (1.0 + 0.2271 * N_eff)\n    Omega_r = omega_r_h2 / h**2\n\n    # Dark energy density for a flat universe\n    Omega_Lambda = 1.0 - Omega_m - Omega_r\n\n    # Cosmological functions of scale factor 'a'\n    def H(a):\n        return H0 * np.sqrt(Omega_r * a**-4 + Omega_m * a**-3 + Omega_Lambda)\n\n    def R(a):\n        return (3.0 / 4.0) * (Omega_b / Omega_gamma) * a\n    \n    def cs(a):\n        return C_KM_S / np.sqrt(3.0 * (1.0 + R(a)))\n\n    # Drag epoch redshift (z_d) and scale factor (a_d) from Eisenstein-Hu formula\n    b1 = 0.313 * (omega_mh2)**-0.419 * (1.0 + 0.607 * (omega_mh2)**0.674)\n    b2 = 0.238 * (omega_mh2)**0.223\n    z_d = 1291. * (omega_mh2)**0.251 / (1.0 + 0.659 * (omega_mh2)**0.828) * (1.0 + b1 * (omega_bh2)**b2)\n    a_d = 1.0 / (1.0 + z_d)\n\n    # Integrand for sound horizon r_d\n    def integrand(a):\n        if a == 0:\n            # The limit as a -> 0 is finite\n            return C_KM_S / (np.sqrt(3.0) * H0 * np.sqrt(Omega_r))\n        return cs(a) / (a**2 * H(a))\n\n    # Handle the integral from a=0 by splitting at a_min\n    a_min = 1e-10\n    integrand_early = C_KM_S / (np.sqrt(3.0) * H0 * np.sqrt(Omega_r))\n    dr_amin = integrand_early * a_min\n\n    # --- Method 1: Adaptive Quadrature ---\n    # Using scipy.integrate.quad with tight tolerances\n    integral_val, _ = quad(integrand, a_min, a_d, epsabs=1e-13, epsrel=1e-13)\n    r_d1 = dr_amin + integral_val\n\n    # --- Method 2: Adaptive ODE Integration ---\n    # dr/da = integrand(a), solved with scipy.integrate.solve_ivp\n    sol = solve_ivp(\n        lambda a, r: integrand(a),\n        (a_min, a_d),\n        [dr_amin],\n        method='DOP853',  # High-order accurate solver\n        rtol=1e-13,\n        atol=1e-13\n    )\n    r_d2 = sol.y[0, -1]\n\n    # --- Eisenstein-Hu Analytic Approximation ---\n    a_eq = Omega_r / Omega_m\n    R_d = R(a_d)\n    R_eq = R(a_eq)\n    k_eq = a_eq * H(a_eq) / C_KM_S  # in 1/Mpc\n\n    log_arg_num = np.sqrt(1.0 + R_d) + np.sqrt(R_d + R_eq)\n    log_arg_den = 1.0 + np.sqrt(R_eq)\n    r_d_eh = (2.0 / (3.0 * k_eq)) * np.sqrt(6.0 / R_eq) * np.log(log_arg_num / log_arg_den)\n\n    # --- Diagnostics ---\n    delta_num = abs(r_d1 - r_d2) / (0.5 * (r_d1 + r_d2))\n    delta_eh = abs(r_d1 - r_d_eh) / r_d_eh\n\n    return delta_num, delta_eh\n\ndef solve():\n    \"\"\"\n    Main function to run the cosmological calculations for all test cases.\n    \"\"\"\n    # Test suite of cosmological models\n    test_cases = [\n        (0.315, 0.049, 0.674, 3.046, 2.7255),  # Case 1 (Planck-like)\n        (0.35, 0.08, 0.70, 3.046, 2.7255),    # Case 2 (high baryon)\n        (0.315, 0.049, 0.674, 4.0, 2.7255),    # Case 3 (high N_eff)\n        (0.30, 0.02, 0.67, 3.046, 2.7255),    # Case 4 (low baryon fraction)\n        (0.27, 0.005, 0.67, 3.046, 2.7255),   # Case 5 (very low baryon)\n    ]\n\n    all_results = []\n    for params in test_cases:\n        delta_num, delta_eh = calculate_diagnostics(params)\n        all_results.extend([delta_num, delta_eh])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "3465692"}, {"introduction": "While the BAO feature originates in the linear regime, we observe it in a Universe that is decidedly non-linear today. A crucial question for BAO cosmology is how robust the acoustic scale is to the effects of non-linear gravitational evolution. This numerical experiment ([@problem_id:3465676]) allows you to investigate this question using the lognormal transformation, a simple but powerful model for mimicking the initial effects of non-linear growth. By generating a Gaussian random field with a known linear BAO scale and then measuring the peak location after applying the mapping, you will directly test whether this local non-Gaussian transformation introduces a systematic bias to the BAO standard ruler.", "problem": "You are asked to design and implement a complete, reproducible numerical experiment to investigate whether applying a purely local non-Gaussian mapping to a Gaussian random field with linear-theory baryon acoustic oscillation (BAO) structure biases the inferred BAO scale measured from the two-point correlation function. The work must be framed in purely mathematical terms and expressed as a runnable program that outputs a single-line list aggregating the results from a specified test suite. All distances must be treated as comoving units in $h^{-1}\\,\\mathrm{Mpc}$, and all wavenumbers as $h\\,\\mathrm{Mpc}^{-1}$. The final numerical answers must be floats expressed in $h^{-1}\\,\\mathrm{Mpc}$, rounded to three decimal places.\n\nYour program must implement the following pipeline grounded in core definitions and well-tested formulas:\n\n- A statistically homogeneous and isotropic Gaussian random field $\\delta_{\\mathrm{G}}(\\mathbf{x})$ in a cubic periodic volume of side length $L$, sampled on a regular Cartesian grid of linear size $N$, is completely specified by its power spectrum $P(k)$, where $k \\equiv \\lvert \\mathbf{k} \\rvert$. The two-point correlation function $\\xi(r)$ of the field is the three-dimensional Fourier transform of $P(k)$, with $r \\equiv \\lvert \\mathbf{r} \\rvert$. For a stationary field on a periodic grid, the discrete estimator of the auto-correlation can be constructed via the convolution theorem: if $\\tilde{\\delta}(\\mathbf{k})$ is the discrete Fourier transform of $\\delta(\\mathbf{x})$ on the grid and $\\mathcal{F}^{-1}$ denotes the inverse discrete Fourier transform with $1/N^{3}$ normalization, then the configuration-space auto-correlation on the grid is given by $\\xi_{\\mathrm{grid}}(\\mathbf{r}) = \\mathcal{F}^{-1}\\left[\\lvert \\tilde{\\delta}(\\mathbf{k}) \\rvert^{2}\\right] / N^{3}$ after subtracting the field mean. The isotropic $\\xi(r)$ is obtained by binning $\\xi_{\\mathrm{grid}}(\\mathbf{r})$ in spherical shells of radius $r$.\n\n- The lognormal mapping defines a non-Gaussian field $\\delta_{\\mathrm{LN}}(\\mathbf{x})$ via a purely local transformation of the Gaussian field $\\delta_{\\mathrm{G}}(\\mathbf{x})$: $\\delta_{\\mathrm{LN}}(\\mathbf{x}) = \\exp\\left(\\delta_{\\mathrm{G}}(\\mathbf{x}) - \\sigma_{\\mathrm{G}}^{2}/2\\right) - 1$, where $\\sigma_{\\mathrm{G}}^{2}$ is the variance of $\\delta_{\\mathrm{G}}$ over the grid. This choice ensures $\\langle \\delta_{\\mathrm{LN}} \\rangle = 0$ for a strictly Gaussian input. Under the assumption of Gaussian $\\delta_{\\mathrm{G}}$, the two-point function of the lognormal field relates to that of the Gaussian field by $\\xi_{\\mathrm{LN}}(r) = \\exp\\left(\\xi_{\\mathrm{G}}(r)\\right) - 1$, which reduces to $\\xi_{\\mathrm{LN}}(r) \\approx \\xi_{\\mathrm{G}}(r)$ for $\\lvert \\xi_{\\mathrm{G}}(r) \\rvert \\ll 1$. This suggests that the BAO peak location should be approximately preserved by the mapping in the weakly non-linear regime, but a direct numerical test is required.\n\n- To imprint BAO features in the linear power spectrum, construct a physically motivated, isotropic model consisting of a smooth no-wiggle baseline multiplied by a damped oscillatory modulation. Let\n$$\nP(k) = P_{\\mathrm{nw}}(k) \\left[ 1 + \\alpha \\, \\exp\\left( - (k \\,\\Sigma)^{2} \\right) \\frac{\\sin(k\\,r_{\\mathrm{s}})}{k\\,r_{\\mathrm{s}}} \\right],\n$$\nwith\n$$\nP_{\\mathrm{nw}}(k) = A \\left( \\frac{k}{k_{0}} \\right)^{n_{\\mathrm{s}}} \\exp\\left( - \\left(\\frac{k}{k_{c}}\\right)^{2} \\right).\n$$\nHere $P_{\\mathrm{nw}}(k)$ captures a tilt and a large-$k$ Gaussian cutoff for numerical stability, while the modulation encodes BAO oscillations with a characteristic scale $r_{\\mathrm{s}}$. The damping factor with width parameter $\\Sigma$ models diffusion of acoustic features in Fourier space. Use the continuous limit convention for $k$ on the periodic grid: $k_{i} = 2\\pi m_{i} / L$ with integer triplet $(m_{x}, m_{y}, m_{z})$. Define $\\sin(x)/x \\equiv 1$ at $x = 0$ by continuity to avoid division by zero.\n\n- Generate $\\delta_{\\mathrm{G}}$ by coloring unit-variance white noise with the square-root of the target power spectrum in Fourier space: if $w(\\mathbf{x})$ is a real white-noise field with $\\langle w(\\mathbf{x}) \\rangle = 0$ and $\\langle w(\\mathbf{x})^{2} \\rangle = 1$, then set $\\delta_{\\mathrm{G}}(\\mathbf{x}) = \\mathcal{F}^{-1}\\left[\\sqrt{P(k)} \\, \\tilde{w}(\\mathbf{k})\\right]$, where $\\tilde{w}(\\mathbf{k})$ is the discrete Fourier transform of $w(\\mathbf{x})$. After generation, rescale $\\delta_{\\mathrm{G}}$ to a specified target standard deviation $\\sigma_{\\mathrm{target}}$ to control the non-Gaussianity strength downstream, i.e., $\\delta_{\\mathrm{G}} \\leftarrow \\delta_{\\mathrm{G}} \\cdot \\sigma_{\\mathrm{target}} / \\hat{\\sigma}$, where $\\hat{\\sigma}$ is the empirical standard deviation of the realization.\n\n- Measure the isotropic two-point correlation functions $\\xi_{\\mathrm{G}}(r)$ and $\\xi_{\\mathrm{LN}}(r)$ from $\\delta_{\\mathrm{G}}$ and $\\delta_{\\mathrm{LN}}$, respectively, by FFT-based convolution as above followed by spherical shell averaging over the periodic box. Locate the BAO scale $r_{\\mathrm{BAO}}$ as the location of the global maximum of $\\xi(r)$ within a search window around the expected acoustic scale. To reduce realization noise, optionally apply a mild, spherically symmetric one-dimensional smoothing to the binned $\\xi(r)$ profile prior to peak finding. Refine the peak location by quadratic interpolation using the maximum bin and its two neighbors when available.\n\n- Report the BAO shift $\\Delta r \\equiv r_{\\mathrm{BAO}}^{(\\mathrm{mapped})} - r_{\\mathrm{BAO}}^{(\\mathrm{Gaussian})}$ for each test case, in units of $h^{-1}\\,\\mathrm{Mpc}$ as a float rounded to three decimals.\n\nSpecifications and constraints to enforce scientific realism and reproducibility:\n\n- Use a cubic periodic box with side length $L = 1000\\,h^{-1}\\,\\mathrm{Mpc}$ sampled on a grid with $N = 128$ points per side. Use a single, fixed isotropic bin width equal to the grid spacing $\\Delta r = L/N$ to compute the radial $\\xi(r)$ up to $r_{\\max} = L/2$.\n\n- Use $k_{0} = 0.2\\,h\\,\\mathrm{Mpc}^{-1}$, $n_{\\mathrm{s}} = 0.96$, $k_{c} = 0.45\\,h\\,\\mathrm{Mpc}^{-1}$, $\\alpha = 0.05$, $\\Sigma = 8\\,h^{-1}\\,\\mathrm{Mpc}$, and $r_{\\mathrm{s}} = 105\\,h^{-1}\\,\\mathrm{Mpc}$. Set $A = 1$ (the overall amplitude is later rescaled by $\\sigma_{\\mathrm{target}}$). Treat $\\sin(x)/x$ at $x=0$ by its limiting value of $1$.\n\n- Restrict the BAO peak search to the window $r \\in [70, 140]\\,h^{-1}\\,\\mathrm{Mpc}]$. If the detection falls on the boundary bins, still report the refined estimate using the available neighboring bins; if the quadratic refinement is ill-conditioned (zero denominator), report the bin center.\n\n- Use a fixed pseudo-random number generator seed per test case to ensure reproducibility.\n\n- Units: Distances $r$ and $L$ must be handled in $h^{-1}\\,\\mathrm{Mpc}$, wavenumbers $k$ in $h\\,\\mathrm{Mpc}^{-1}$. Your outputs must be in $h^{-1}\\,\\mathrm{Mpc}$, rounded to three decimals.\n\nTest suite to implement and evaluate, covering happy path, increased non-Gaussianity, and a small-variance edge case, plus an identity mapping control:\n\n- Case $\\#1$: mapping type “identity” (i.e., no non-Gaussian transformation), $\\sigma_{\\mathrm{target}} = 0.20$, seed $= 1$.\n\n- Case $\\#2$: mapping type “lognormal”, $\\sigma_{\\mathrm{target}} = 0.20$, seed $= 2$.\n\n- Case $\\#3$: mapping type “lognormal”, $\\sigma_{\\mathrm{target}} = 0.40$, seed $= 3$.\n\n- Case $\\#4$: mapping type “lognormal”, $\\sigma_{\\mathrm{target}} = 0.05$, seed $= 4$.\n\nFor each case, generate the same Gaussian field realization for the “Gaussian” baseline and construct the “mapped” field by applying the specified mapping type to that realization. Then compute the BAO peak positions $r_{\\mathrm{BAO}}^{(\\mathrm{Gaussian})}$ and $r_{\\mathrm{BAO}}^{(\\mathrm{mapped})}$, and report the shift $\\Delta r$ for that case.\n\nFinal output format requirement:\n\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the test cases $\\#1$ through $\\#4$, e.g., $\\left[ x_{1}, x_{2}, x_{3}, x_{4} \\right]$, where each $x_{i}$ is the float value of $\\Delta r$ in $h^{-1}\\,\\mathrm{Mpc}$ rounded to three decimals. No other text should be printed.", "solution": "The user has provided a well-defined problem in numerical cosmology, which requires the implementation of a numerical experiment to measure the potential biasing effect of a local non-Gaussian transformation on the baryon acoustic oscillation (BAO) scale. The problem is scientifically grounded, well-posed, and objective. It specifies all necessary physical parameters, numerical settings, and procedural steps to ensure reproducibility. I will therefore proceed with a full solution.\n\nThe core of the problem is to generate a realization of a Gaussian random field with a specific power spectrum, apply a transformation to it, and then measure the location of the BAO peak in the two-point correlation function for both the original and transformed fields. The difference in these peak locations, $\\Delta r$, is the quantity of interest.\n\nThe algorithmic pipeline will be implemented as follows:\n\n1.  **Grid and Parameter Initialization**: We begin by defining the physical and numerical constants. The simulation is set in a periodic cubic box of side length $L = 1000\\,h^{-1}\\,\\mathrm{Mpc}$, discretized on a Cartesian grid of size $N \\times N \\times N$ with $N=128$. This defines a grid spacing, which is also our correlation function bin width, of $\\Delta x = L/N \\approx 7.8125\\,h^{-1}\\,\\mathrm{Mpc}$. We also define the parameters for the model power spectrum: reference wavenumber $k_0 = 0.2\\,h\\,\\mathrm{Mpc}^{-1}$, spectral tilt $n_{\\mathrm{s}} = 0.96$, large-$k$ cutoff scale $k_c = 0.45\\,h\\,\\mathrm{Mpc}^{-1}$, BAO amplitude $\\alpha = 0.05$, BAO damping scale $\\Sigma = 8\\,h^{-1}\\,\\mathrm{Mpc}$, and the fundamental acoustic scale $r_{\\mathrm{s}} = 105\\,h^{-1}\\,\\mathrm{Mpc}$.\n\n2.  **Fourier Space Grid Construction**: To work with Fourier transforms, we construct the grid of wavenumbers $\\mathbf{k} = (k_x, k_y, k_z)$. For a periodic box of side $L$, the discrete wavenumbers are given by $k_i = 2\\pi m_i / L$, where $m_i$ are integers. The `numpy.fft.fftfreq` function provides the correct set of sorted frequencies for use with FFT routines. We generate the 3D grid of $k_x$, $k_y$, and $k_z$ and from them, a grid of wavenumber magnitudes $k = \\sqrt{k_x^2 + k_y^2 + k_z^2}$.\n\n3.  **Theoretical Power Spectrum**: With the $k$-grid established, we can evaluate the theoretical linear power spectrum $P(k)$ at each point in Fourier space. The model is given by:\n    $$\n    P(k) = A \\left( \\frac{k}{k_{0}} \\right)^{n_{\\mathrm{s}}} \\exp\\left( - \\left(\\frac{k}{k_{c}}\\right)^{2} \\right) \\left[ 1 + \\alpha \\, \\exp\\left( - (k \\,\\Sigma)^{2} \\right) \\frac{\\sin(k\\,r_{\\mathrm{s}})}{k\\,r_{\\mathrm{s}}} \\right]\n    $$\n    The amplitude $A$ is set to $1$, as the field will be rescaled later. The term $\\sin(x)/x$ is handled by its limiting value of $1$ at $x=0$ to avoid division by zero at the $k=0$ mode. `numpy.sinc` is a numerically stable choice for this.\n\n4.  **Gaussian Random Field Generation**: A statistically homogeneous and isotropic Gaussian random field $\\delta_{\\mathrm{G}}(\\mathbf{x})$ is generated. The process follows the problem description:\n    a. A real-space white noise field, $w(\\mathbf{x})$, is created by drawing a random number from a standard normal distribution for each grid cell. A fixed seed is used for each test case to ensure reproducibility.\n    b. This white noise field is Fourier transformed to get $\\tilde{w}(\\mathbf{k}) = \\mathcal{F}[w(\\mathbf{x})]$.\n    c. The Fourier-space field is then \"colored\" by multiplying it with the square root of the power spectrum: $\\tilde{\\delta}_{\\mathrm{G}}(\\mathbf{k}) = \\tilde{w}(\\mathbf{k}) \\sqrt{P(k)}$. The $k=0$ mode of $P(k)$ is zero due to the $(k/k_0)^{n_s}$ term, which ensures the resulting field has zero mean.\n    d. An inverse Fourier transform yields the Gaussian field in configuration space: $\\delta_{\\mathrm{G}}(\\mathbf{x}) = \\mathcal{F}^{-1}[\\tilde{\\delta}_{\\mathrm{G}}(\\mathbf{k})]$. The result is the real part of the complex output of the inverse FFT.\n    e. Finally, the field is rescaled to have a specific target standard deviation, $\\sigma_{\\mathrm{target}}$, as specified by the test case. This is done by calculating the empirical standard deviation $\\hat{\\sigma}$ of the generated field and multiplying the field by the ratio $\\sigma_{\\mathrm{target}}/\\hat{\\sigma}$.\n\n5.  **Non-Gaussian Mapping**: The \"mapped\" field is generated from the Gaussian field $\\delta_{\\mathrm{G}}$.\n    - For the \"lognormal\" mapping, we apply the transformation: $\\delta_{\\mathrm{LN}}(\\mathbf{x}) = \\exp\\left(\\delta_{\\mathrm{G}}(\\mathbf{x}) - \\sigma_{\\mathrm{G}}^{2}/2\\right) - 1$, where $\\sigma_{\\mathrm{G}}^2 = \\sigma_{\\mathrm{target}}^2$ is the variance of the input Gaussian field.\n    - For the \"identity\" mapping (a control case), the mapped field is simply a copy of the Gaussian field: $\\delta_{\\text{mapped}}(\\mathbf{x}) = \\delta_{\\mathrm{G}}(\\mathbf{x})$.\n\n6.  **Two-Point Correlation Function Estimation**: We compute the isotropic two-point correlation function $\\xi(r)$ for both the Gaussian and the mapped fields.\n    a. First, the mean of the field is subtracted to ensure $\\langle\\delta\\rangle=0$. This is crucial for the lognormal field, whose sample mean may not be exactly zero.\n    b. The correlation function on the grid, $\\xi_{\\mathrm{grid}}(\\mathbf{r})$, is computed efficiently using the convolution theorem via FFTs. The discrete estimator is $\\xi_{\\mathrm{grid}} = \\mathcal{F}^{-1}[|\\mathcal{F}[\\delta]|^2]$. A careful normalization is required. Based on the properties of the discrete Fourier transform (specifically Parseval's theorem) and the definition that $\\xi(0)$ must equal the variance of the field, the correct numerical implementation using standard FFT libraries is `real(ifftn(|fftn(field)|^2)) / (N**3)`.\n    c. To obtain the isotropic correlation function $\\xi(r)$, we average $\\xi_{\\mathrm{grid}}(\\mathbf{r})$ in spherical shells of radius $r$. We pre-compute a grid of distances from the origin, accounting for the periodic boundary conditions. Then, we use a histogram-based approach to bin the values of $\\xi_{\\mathrm{grid}}$ according to their corresponding radial distance. The bin width is set to the grid spacing, $\\Delta x = L/N$.\n\n7.  **BAO Peak Location**: The final step is to find the BAO peak, which is the maximum of $\\xi(r)$ in the search window $r \\in [70, 140]\\,h^{-1}\\,\\mathrm{Mpc}$.\n    a. To mitigate noise from the single realization, the binned $\\xi(r)$ profile is smoothed using a one-dimensional Gaussian filter with a small width (`sigma=1` bin). This is consistent with the problem's optional suggestion.\n    b. The bin containing the maximum value of the smoothed $\\xi(r)$ within the search window is identified.\n    c. To achieve sub-bin precision, quadratic interpolation is performed using the maximum value and its two immediate neighbors. The location of the vertex of the fitted parabola, $r_{\\text{peak}} = r_i - \\frac{(y_{i+1}-y_{i-1})\\Delta x}{2(y_{i+1}+y_{i-1}-2y_i)}$, gives the refined peak position. If the denominator is zero (collinear points), the bin center is used.\n\n8.  **Execution and Reporting**: The entire pipeline is executed for each of the four test cases. For each case, we compute the peak locations for the Gaussian field ($r_{\\mathrm{BAO}}^{(\\mathrm{Gaussian})}$) and the mapped field ($r_{\\mathrm{BAO}}^{(\\mathrm{mapped})}$). The final reported quantity is the shift $\\Delta r = r_{\\mathrm{BAO}}^{(\\mathrm{mapped})} - r_{\\mathrm{BAO}}^{(\\mathrm{Gaussian})}$, rounded to three decimal places. The results for all cases are aggregated into a single list and printed. For the identity map, $\\Delta r$ is expected to be exactly zero, serving as a robust validation of the numerical pipeline.", "answer": "```python\nimport numpy as np\nfrom scipy.ndimage import gaussian_filter1d\n\ndef solve():\n    \"\"\"\n    Main function to run the numerical experiment and print the results.\n    \"\"\"\n\n    # --- Problem Specifications ---\n    L = 1000.0  # Box side length in h^-1 Mpc\n    N = 128     # Grid size per dimension\n    \n    # Power spectrum parameters\n    k0 = 0.2    # h Mpc^-1\n    ns = 0.96\n    kc = 0.45   # h Mpc^-1\n    alpha = 0.05\n    Sigma = 8.0 # h^-1 Mpc\n    rs = 105.0  # h^-1 Mpc\n    A = 1.0\n\n    # Peak finding parameters\n    r_search_min = 70.0  # h^-1 Mpc\n    r_search_max = 140.0 # h^-1 Mpc\n    \n    # Test suite\n    test_cases = [\n        {\"type\": \"identity\", \"sigma_target\": 0.20, \"seed\": 1},\n        {\"type\": \"lognormal\", \"sigma_target\": 0.20, \"seed\": 2},\n        {\"type\": \"lognormal\", \"sigma_target\": 0.40, \"seed\": 3},\n        {\"type\": \"lognormal\", \"sigma_target\": 0.05, \"seed\": 4},\n    ]\n\n    results = []\n    \n    # --- Pre-computation ---\n    # Setup k-space grid\n    k_freq = np.fft.fftfreq(N, d=L / N) * 2 * np.pi\n    kx, ky, kz = np.meshgrid(k_freq, k_freq, k_freq, indexing='ij')\n    k_mag = np.sqrt(kx**2 + ky**2 + kz**2)\n    \n    # Calculate theoretical P(k)\n    with np.errstate(divide='ignore', invalid='ignore'):\n        P_nw = A * (k_mag / k0)**ns * np.exp(-(k_mag / kc)**2)\n        # np.sinc(x) is sin(pi*x)/(pi*x)\n        bao_term = 1 + alpha * np.exp(-(k_mag * Sigma)**2) * np.sinc(k_mag * rs / np.pi)\n        P_k = P_nw * bao_term\n    P_k[k_mag == 0] = 0.0\n    sqrt_Pk = np.sqrt(P_k)\n\n    # Setup r-space grid for binning\n    dx = L / N\n    x = np.arange(N) * dx\n    grid_coords_1d = np.minimum(x, L - x)\n    grid_coords_1d[0] = 0 # Handle origin for meshgrid\n    \n    # Distances from the origin, accounting for periodic boundary conditions\n    rx, ry, rz = np.meshgrid(grid_coords_1d, grid_coords_1d, grid_coords_1d, indexing='ij')\n    r_grid = np.sqrt(rx**2 + ry**2 + rz**2)\n    \n    # Binning setup\n    r_max = L / 2.0\n    bins = np.arange(0, r_max + dx, dx)\n    bin_centers = (bins[:-1] + bins[1:]) / 2.0\n\n    # --- Main Loop over Test Cases ---\n    for case in test_cases:\n        \n        # --- 1. Generate Gaussian Field ---\n        rng = np.random.default_rng(seed=case[\"seed\"])\n        white_noise = rng.standard_normal(size=(N, N, N))\n        \n        delta_g_k = np.fft.fftn(white_noise) * sqrt_Pk\n        delta_g = np.fft.ifftn(delta_g_k).real\n        \n        # Rescale to target standard deviation\n        current_sigma = np.std(delta_g)\n        delta_g *= (case[\"sigma_target\"] / current_sigma)\n\n        # --- 2. Apply Non-Gaussian Mapping ---\n        if case[\"type\"] == \"identity\":\n            delta_mapped = delta_g\n        elif case[\"type\"] == \"lognormal\":\n            sigma2_g = case[\"sigma_target\"]**2\n            delta_mapped = np.exp(delta_g - sigma2_g / 2.0) - 1.0\n        else:\n            raise ValueError(f\"Unknown mapping type: {case['type']}\")\n\n        # --- 3. Compute Correlation Functions and Find Peaks ---\n        peak_locations = {}\n        fields_to_process = {\"Gaussian\": delta_g, \"mapped\": delta_mapped}\n        \n        for name, field in fields_to_process.items():\n            # Subtract mean\n            field_mean_sub = field - np.mean(field)\n            \n            # Compute correlation function using FFT\n            delta_k = np.fft.fftn(field_mean_sub)\n            # The result of ifftn(|fftn(field)|^2) has xi(0)=sum(field^2)\n            # To get variance, must divide by total number of points N^3\n            xi_grid = np.fft.ifftn(np.abs(delta_k)**2).real / (N**3)\n\n            # Isotropic averaging\n            counts, _ = np.histogram(r_grid.flatten(), bins=bins)\n            sums, _ = np.histogram(r_grid.flatten(), bins=bins, weights=xi_grid.flatten())\n            \n            xi_r = np.zeros_like(bin_centers)\n            non_empty_bins = counts > 0\n            xi_r[non_empty_bins] = sums[non_empty_bins] / counts[non_empty_bins]\n            \n            # Smooth the binned correlation function\n            xi_r_smooth = gaussian_filter1d(xi_r, sigma=1.0)\n            \n            # Find peak in search window\n            search_mask = (bin_centers >= r_search_min)  (bin_centers = r_search_max)\n            \n            if not np.any(search_mask):\n                peak_r = np.nan # No peak in window\n            else:\n                masked_xi = xi_r_smooth[search_mask]\n                max_idx_local = np.argmax(masked_xi)\n                max_idx_global = np.where(search_mask)[0][max_idx_local]\n                \n                # Quadratic interpolation for sub-bin accuracy\n                if 0  max_idx_global  len(bin_centers) - 1:\n                    y_m1, y_0, y_p1 = xi_r_smooth[max_idx_global-1:max_idx_global+2]\n                    denominator = 2 * (y_p1 + y_m1 - 2 * y_0)\n                    if np.abs(denominator) > 1e-12:\n                        offset = dx * (y_m1 - y_p1) / denominator\n                        peak_r = bin_centers[max_idx_global] + offset\n                    else:\n                        peak_r = bin_centers[max_idx_global]\n                else: # Max is at boundary of computed xi(r) range\n                    peak_r = bin_centers[max_idx_global]\n\n            peak_locations[name] = peak_r\n\n        # --- 4. Calculate Shift and Store Result ---\n        delta_r = peak_locations[\"mapped\"] - peak_locations[\"Gaussian\"]\n        results.append(round(delta_r, 3))\n    \n    # Final formatted output\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3465676"}]}