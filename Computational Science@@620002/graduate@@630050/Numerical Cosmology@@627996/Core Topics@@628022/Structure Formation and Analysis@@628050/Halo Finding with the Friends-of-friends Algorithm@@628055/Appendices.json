{"hands_on_practices": [{"introduction": "Before using an algorithm on complex scientific data, we must be confident it is correct. This practice focuses on unit testing, a cornerstone of reliable scientific software. By running your Friends-of-Friends code on synthetic particle distributions—such as a perfect lattice or a random set—where the number of halos can be predicted from first principles, you can rigorously validate your implementation's logic and its handling of the linking parameter $b$ [@problem_id:3474766].", "problem": "You are tasked with designing unit tests that validate a Friends-of-Friends (FoF) halo finder in a periodic, cubic domain using synthetic point sets that mimic common numerical cosmology inputs. The FoF algorithm links two particles if their minimum-image separation is less than or equal to a linking length, and halos are defined as connected components under the transitive closure of this link relation. All distances in this problem are dimensionless and expressed in units of the cubic box side length, which is set to $L = 1$.\n\nFundamental base and definitions:\n- Consider $N$ particles in a periodic, cubic box with volume $V = L^3 = 1$.\n- The mean interparticle separation is defined by $l_{\\mathrm{bar}} = \\left(\\frac{V}{N}\\right)^{1/3} = N^{-1/3}$.\n- The FoF linking length is $l_{\\mathrm{link}} = b \\, l_{\\mathrm{bar}}$, where $b > 0$ is a dimensionless control parameter.\n- Let $\\mathbf{x}_i \\in [0,1)^3$ denote the position of the $i$-th particle.\n- The minimum-image separation between two particles $i$ and $j$ is given by the Euclidean norm of the vector $\\Delta \\mathbf{x}_{ij}$ after mapping each coordinate difference $\\Delta x = x_j - x_i$ into the interval $[-\\frac{L}{2}, \\frac{L}{2})$ via $\\Delta x \\mapsto \\Delta x - L \\,\\left\\lfloor \\Delta x/L + \\frac{1}{2} \\right\\rfloor$. The particles $i$ and $j$ are said to be friends if $\\|\\Delta \\mathbf{x}_{ij}\\| \\le l_{\\mathrm{link}}$. A halo is the set of particles in a connected component of the graph built from the friendship relation. The FoF halo count $H$ is the number of connected components.\n\nSynthetic point sets to be tested:\n1. A homogeneous Poisson point set (uniform random positions) in the periodic box.\n2. A perfect cubic lattice of $n \\times n \\times n$ points with spacing $a = \\frac{L}{n}$, located at cell centers $\\left(\\frac{i + \\frac{1}{2}}{n}, \\frac{j + \\frac{1}{2}}{n}, \\frac{k + \\frac{1}{2}}{n}\\right)$.\n3. A glass-like configuration constructed as a jittered lattice with bounded displacements, defined by starting from the lattice positions and adding a deterministic, bounded, alternating offset $\\pm \\epsilon$ in each coordinate so that nearest-neighbor axis-aligned separations are no smaller than $a - 2\\epsilon$. This mimics a blue-noise or relaxed configuration with suppressed close pairs.\n\nYour program must:\n- Implement a FoF group finder in a periodic box using the minimum-image convention and $l_{\\mathrm{link}} = b \\, l_{\\mathrm{bar}}$.\n- Construct the synthetic point sets for each test case below.\n- For each test case, derive the expected FoF halo count $H_{\\mathrm{exp}}$ purely from geometric reasoning and the definitions above. The expected count for the Poisson cases must be derived from extreme parameter regimes where the outcome is deterministic: either $b = 0$ (no links) or $l_{\\mathrm{link}} \\ge \\frac{\\sqrt{3}}{2} L$ (every pair is linked by the minimum-image metric).\n- Compare the computed halo count $H_{\\mathrm{comp}}$ from your implementation with the derived $H_{\\mathrm{exp}}$ and report whether the test passes, i.e., whether $H_{\\mathrm{comp}} = H_{\\mathrm{exp}}$.\n\nTest suite and parameters:\nLet $L = 1$ throughout and use the exact parameters given. For the lattice, set $n$ so that $N = n^3$. For the glass, use the jitter construction with the specified $\\epsilon$.\n\n- Case 1 (Lattice, below-neighbor threshold): $n = 2$, so $N = 8$, $a = \\frac{1}{2}$, $b = 0.9$. Compute $l_{\\mathrm{link}} = b \\, l_{\\mathrm{bar}}$ with $l_{\\mathrm{bar}} = \\frac{1}{2}$. Derive $H_{\\mathrm{exp}}$.\n- Case 2 (Lattice, at-neighbor threshold boundary): $n = 2$, so $N = 8$, $a = \\frac{1}{2}$, $b = 1.0$. Compute $l_{\\mathrm{link}}$ as above. Derive $H_{\\mathrm{exp}}$.\n- Case 3 (Glass-like, below jitter threshold): $n = 3$, so $N = 27$, $a = \\frac{1}{3}$, $\\epsilon = 0.05$, $b = 0.6$. Compute $l_{\\mathrm{link}} = b \\, l_{\\mathrm{bar}}$ with $l_{\\mathrm{bar}} = \\frac{1}{3}$. Use the bound on nearest-neighbor separations to derive $H_{\\mathrm{exp}}$.\n- Case 4 (Glass-like, at jitter threshold boundary): $n = 3$, so $N = 27$, $a = \\frac{1}{3}$, $\\epsilon = 0.05$, choose $b$ such that $l_{\\mathrm{link}} = a - 2\\epsilon$. Derive $H_{\\mathrm{exp}}$ numerically from this equality.\n- Case 5 (Poisson, zero linking length): $N = 10$, $b = 0$. Derive $H_{\\mathrm{exp}}$.\n- Case 6 (Poisson, super-linking regime): $N = 10$, $b = 2.0$. Compute $l_{\\mathrm{link}}$ and compare to the maximum possible minimum-image separation $\\frac{\\sqrt{3}}{2}L$. Derive $H_{\\mathrm{exp}}$.\n\nAnswer specification:\n- For each case, compute a boolean indicating whether the computed halo count equals the derived expected count.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[True,False,True,True,False,True]\").\n\nScientific realism:\n- Use the minimum-image metric for periodic boundaries.\n- Use disjoint-set union (union-find) or equivalent to compute connected components under the FoF friendship relation.\n- For the Poisson cases, use deterministic regimes ($b = 0$ or $l_{\\mathrm{link}} \\ge \\frac{\\sqrt{3}}{2} L$) to ensure non-random expected outcomes.\n\nNo angles or physical units beyond the dimensionless distances are involved. All outputs are dimensionless and unit-free numbers or booleans. The final outputs must be booleans as specified above.", "solution": "This problem requires validating a Friends-of-Friends (FoF) halo finder by deriving the expected number of halos ($H_{\\mathrm{exp}}$) for six specific test cases and comparing them to the computed result. The FoF algorithm connects particles with separation less than or equal to the linking length, $l_{\\mathrm{link}}$, and the number of halos is the number of connected components. The core of the solution is the geometric derivation of $H_{\\mathrm{exp}}$ for each case.\n\n**Case 1: Lattice, below-neighbor threshold**\nA perfect lattice of $n=2$ gives $N=8$ particles and a lattice spacing of $a = L/n = 1/2$. The mean interparticle separation is $l_{\\mathrm{bar}} = N^{-1/3} = 1/2$. The linking length is $l_{\\mathrm{link}} = b \\, l_{\\mathrm{bar}} = 0.9 \\times (1/2) = 0.45$. The minimum distance between any two particles on the lattice is $a=0.5$. Since $l_{\\mathrm{link}}  a$, no particles can be linked. Each particle is an isolated halo. Thus, $H_{\\mathrm{exp}} = N = 8$.\n\n**Case 2: Lattice, at-neighbor threshold boundary**\nThe setup is the same as Case 1, but with $b=1.0$. The linking length is $l_{\\mathrm{link}} = 1.0 \\times (1/2) = 0.5$. This is exactly equal to the nearest-neighbor distance $a$. Every particle will link to its axis-aligned neighbors. In a periodic box, this connects all particles into a single component. Thus, $H_{\\mathrm{exp}} = 1$.\n\n**Case 3: Glass-like, below jitter threshold**\nA jittered lattice with $n=3$ gives $N=27$ particles, $a=1/3$, and $l_{\\mathrm{bar}}=1/3$. The jitter $\\epsilon=0.05$ creates a minimum axis-aligned separation of $d_{min} = a - 2\\epsilon = 1/3 - 0.1 \\approx 0.2333$. The linking length is $l_{\\mathrm{link}} = b \\, l_{\\mathrm{bar}} = 0.6 \\times (1/3) = 0.2$. Since $l_{\\mathrm{link}}  d_{min}$, no particles can be linked. Thus, $H_{\\mathrm{exp}} = N = 27$.\n\n**Case 4: Glass-like, at jitter threshold boundary**\nThe setup is the same as Case 3, but the linking length is set to the minimum separation, $l_{\\mathrm{link}} = a - 2\\epsilon = 7/30 \\approx 0.2333$. Links will form only between particles separated by this exact distance. In the specified jittered lattice, these links form between axis-aligned neighbors where the jitter reduces their separation (e.g., between cell indices $i$ and $i+1$ where $i$ is even). For $n=3$, this partitions the indices $\\{0,1,2\\}$ into the sets $\\{0,1\\}$ and $\\{2\\}$ along each axis. The halos are formed by the Cartesian products of these index-space partitions, leading to:\n- 1 halo of size $2^3=8$ (from indices $\\{0,1\\}^3$)\n- 3 halos of size $1 \\times 2^2=4$ (e.g., from $\\{2\\} \\times \\{0,1\\}^2$)\n- 3 halos of size $1^2 \\times 2=2$ (e.g., from $\\{2\\}^2 \\times \\{0,1\\}$)\n- 1 halo of size $1^3=1$ (from $\\{2\\}^3$)\nThe total number of halos is $1 + 3 + 3 + 1 = 8$. Thus, $H_{\\mathrm{exp}} = 8$.\n\n**Case 5: Poisson, zero linking length**\nFor $N=10$ particles and $b=0$, the linking length is $l_{\\mathrm{link}} = 0$. In a continuous random distribution, the probability of two particles having zero separation is zero. No links are formed, and each particle is an isolated halo. Thus, $H_{\\mathrm{exp}} = N = 10$.\n\n**Case 6: Poisson, super-linking regime**\nFor $N=10$ particles and $b=2.0$, the linking length is $l_{\\mathrm{link}} = 2.0 \\times 10^{-1/3} \\approx 0.928$. The maximum possible separation between any two points in a periodic box of side $L=1$ is $d_{max} = \\sqrt{(1/2)^2 + (1/2)^2 + (1/2)^2} = \\sqrt{3}/2 \\approx 0.866$. Since $l_{\\mathrm{link}} > d_{max}$, every pair of particles in the box will be linked. All particles form a single halo. Thus, $H_{\\mathrm{exp}} = 1$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.spatial import cKDTree\n\ndef fof_finder(positions, l_link, L=1.0):\n    \"\"\"\n    Finds Friends-of-Friends halos in a periodic box.\n\n    Args:\n        positions (np.ndarray): Array of shape (N, 3) with particle positions.\n        l_link (float): The linking length.\n        L (float): The side length of the periodic cubic box.\n\n    Returns:\n        int: The number of halos found.\n    \"\"\"\n    N = positions.shape[0]\n    if N == 0:\n        return 0\n\n    # Use cKDTree for efficient periodic neighbor search.\n    # The 'boxsize' argument handles the minimum image convention correctly.\n    tree = cKDTree(positions, boxsize=L)\n    pairs = tree.query_pairs(r=l_link, p=2.0)  # p=2.0 for Euclidean distance\n\n    # Use a Disjoint-Set Union (DSU) or Union-Find algorithm\n    # to find connected components from the list of pairs.\n    parent = list(range(N))\n    \n    def find(i):\n        if parent[i] == i:\n            return i\n        parent[i] = find(parent[i])\n        return parent[i]\n\n    def union(i, j):\n        root_i = find(i)\n        root_j = find(j)\n        if root_i != root_j:\n            parent[root_i] = root_j\n\n    for i, j in pairs:\n        union(i, j)\n\n    # The number of halos is the number of unique roots in the DSU structure.\n    n_halos = len({find(i) for i in range(N)})\n    \n    return n_halos\n\ndef solve():\n    \"\"\"\n    Runs the full test suite and prints the final result.\n    \"\"\"\n    L = 1.0\n\n    test_cases = [\n        # Case 1: Lattice, below-neighbor threshold\n        {'type': 'lattice', 'n': 2, 'b': 0.9, 'H_exp': 8},\n        # Case 2: Lattice, at-neighbor threshold boundary\n        {'type': 'lattice', 'n': 2, 'b': 1.0, 'H_exp': 1},\n        # Case 3: Glass-like, below jitter threshold\n        {'type': 'glass', 'n': 3, 'epsilon': 0.05, 'b': 0.6, 'H_exp': 27},\n        # Case 4: Glass-like, at jitter threshold boundary\n        {'type': 'glass', 'n': 3, 'epsilon': 0.05, 'l_link_special': 'a-2e', 'H_exp': 8},\n        # Case 5: Poisson, zero linking length\n        {'type': 'poisson', 'N': 10, 'b': 0.0, 'H_exp': 10},\n        # Case 6: Poisson, super-linking regime\n        {'type': 'poisson', 'N': 10, 'b': 2.0, 'H_exp': 1},\n    ]\n\n    results = []\n    \n    # Use a fixed seed for reproducible Poisson distributions\n    np.random.seed(42)\n\n    for case in test_cases:\n        positions = None\n        l_link = 0.0\n\n        if case['type'] == 'lattice':\n            n = case['n']\n            N = n**3\n            l_bar = N**(-1/3.0)\n            l_link = case['b'] * l_bar\n            \n            indices = np.arange(n)\n            grid = np.meshgrid(indices, indices, indices, indexing='ij')\n            positions = (np.vstack([g.ravel() for g in grid]).T + 0.5) / n\n\n        elif case['type'] == 'glass':\n            n = case['n']\n            epsilon = case['epsilon']\n            N = n**3\n            a = L / n\n            \n            if 'l_link_special' in case and case['l_link_special'] == 'a-2e':\n                l_link = a - 2 * epsilon\n            else:\n                l_bar = N**(-1/3.0)\n                l_link = case['b'] * l_bar\n\n            indices = np.arange(n)\n            ii, jj, kk = np.meshgrid(indices, indices, indices, indexing='ij')\n            indices_flat = np.vstack([ii.ravel(), jj.ravel(), kk.ravel()]).T\n            \n            positions = np.zeros((N, 3))\n            for p_idx, (i, j, k) in enumerate(indices_flat):\n                pos_x = (i + 0.5) / n + epsilon * ((-1)**i)\n                pos_y = (j + 0.5) / n + epsilon * ((-1)**j)\n                pos_z = (k + 0.5) / n + epsilon * ((-1)**k)\n                positions[p_idx] = [pos_x, pos_y, pos_z]\n        \n        elif case['type'] == 'poisson':\n            N = case['N']\n            l_bar = N**(-1/3.0)\n            l_link = case['b'] * l_bar\n            \n            positions = np.random.rand(N, 3)\n\n        # Run the FoF finder and get the computed halo count\n        H_comp = fof_finder(positions, l_link, L)\n        \n        # Compare with the expected count and store the boolean result\n        results.append(H_comp == case['H_exp'])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3474766"}, {"introduction": "A naive implementation of the FoF algorithm that checks every particle pair scales as $O(N^2)$, which is too slow for modern cosmological simulations. This exercise guides you through implementing a cell-linked list, a critical optimization technique that reduces the algorithmic complexity. By spatially binning particles into a grid, you can restrict the search for friends to a small local neighborhood, making your code viable for large-scale problems [@problem_id:3474726].", "problem": "You are tasked with constructing a complete cell-linked-list neighbor search for the Friends-of-Friends (FoF) algorithm in a three-dimensional periodic domain and deriving a principled upper bound on the number of candidate pairs examined per particle. The setting is a periodic cube of side length $L$ populated by $N$ particles at positions $\\{\\mathbf{x}_i\\}_{i=1}^N$. The FoF linking length is defined by $l = b\\,s$, where $b$ is the dimensionless linking parameter and $s = n^{-1/3}$ is the mean interparticle separation for number density $n = N/L^3$. The objective is to implement an algorithm that, for each particle, enumerates candidate neighbors from a local cell stencil and performs a single distance check per candidate, and to establish an upper bound on the number of such candidate pair examinations per particle in terms of $b$ and the cell size.\n\nFundamental base to use:\n- The Friends-of-Friends (FoF) algorithm (acronym FoF) defines neighbors by Euclidean distance $d \\le l$ in a periodic cube of side $L$.\n- A uniform Cartesian grid partitions the cube into $m$ cells per dimension, so the cell size is $h = L/m$.\n- Number density is $n = N/L^3$ with mean interparticle separation $s = n^{-1/3}$.\n- For a particle in the cell-linked-list scheme, a safe neighbor search stencil is the set of all cells within a Chebyshev radius $r_c = \\lceil l/h \\rceil$ in grid index space; the total number of visited cells is $M = (2r_c + 1)^3$.\n- Periodic boundary conditions are implemented via the minimum-image convention, i.e., for displacement $\\Delta \\mathbf{x}$, each component is wrapped by $\\Delta x \\mapsto \\Delta x - L\\,\\mathrm{round}(\\Delta x/L)$.\n\nAlgorithmic requirements:\n1. Construct a cell-linked list data structure that maps each cell to the list of particle indices it contains, with each particle assigned to its unique cell via integer index $\\mathbf{c} = \\lfloor \\mathbf{x}/h \\rfloor$, computed component-wise, with periodic wrapping.\n2. For each particle $i$, enumerate all cells in the stencil of offsets $\\Delta \\mathbf{c}$ with components in $\\{-r_c,\\dots,+r_c\\}$, wrapped periodically in index space, and for every particle $j$ found in these cells, perform one minimum-image distance computation. Count one \"candidate pair examination\" for every such $(i,j)$ with $j \\ne i$, regardless of whether $d_{ij} \\le l$.\n3. Compute the average number of candidate pair examinations per particle, defined as the total number of examinations across all $i$ divided by $N$.\n\nProof requirement:\n- Starting from the definitions above and geometric considerations of the stencil, derive an upper bound on the expected number of candidate pair examinations per particle in terms of $b$ and $h$. Use the facts that (i) the stencil count is $M = (2\\lceil l/h \\rceil + 1)^3$, and (ii) under uniform sampling with number density $n$, the expected occupancy per cell is $n h^3$. Conclude that the expected number of candidate examinations per particle is bounded above by $C(b,h) = n h^3 M$. In the special deterministic test configurations specified below with exactly $k$ particles per cell, show that $n h^3 = k$ and thus the bound reduces to $C(b,h) = k M$, and the actual examinations per particle equal $k M - 1$, which is less than or equal to $C(b,h)$.\n\nTest suite and parameter specification:\n- The domain is a cube with side length $L = 1$.\n- A regular grid of $m$ cells per dimension is used, with cell size $h = L/m$. The total number of particles is $N = k m^3$ with exactly $k$ particles placed in each cell. Positions are constructed deterministically within each cell to avoid boundary ambiguities.\n- Three parameter sets are provided:\n    1. Case A (general realistic): $m = 8$, $k = 2$, $b = 0.2$. Here $N = 2 \\cdot 8^3$, $s = (L^3/N)^{1/3}$, $l = b s$, $h = L/m$, $r_c = \\lceil l/h \\rceil$, $M = (2 r_c + 1)^3$, $n = N/L^3$, and $C(b,h) = n h^3 M$.\n    2. Case B (boundary where $l/h$ is exactly one): $m = 10$, $k = 3$, $b = 3^{1/3}$, so that $l/h = 1$. Use the same definitions for $N$, $s$, $l$, $h$, $r_c$, $M$, $n$, and $C(b,h)$ as above.\n    3. Case C (large stencil): $m = 12$, $k = 1$, $b = 2.5$. Although $b$ is larger than typical cosmological values, it is mathematically valid and induces a larger stencil. Use the same definitions for $N$, $s$, $l$, $h$, $r_c$, $M$, $n$, and $C(b,h)$.\n\nRequired outputs:\n- For each test case, compute and return a list of three floats: the actual average number of candidate pair examinations per particle, the theoretical upper bound $C(b,h)$, and the ratio of the actual average to the bound. The final output must aggregate the results from all test cases into a single line as a comma-separated list enclosed in square brackets, where each test case contributes its own bracketed list. For example, the output format must be exactly of the form $[\\,[a_1,b_1,c_1],\\,[a_2,b_2,c_2],\\,[a_3,b_3,c_3]\\,]$ without any additional characters or whitespace constraints beyond standard number formatting.\n\nAngle units are not applicable. No physical units are required since all quantities are dimensionless in this normalized setup.\n\nYour program must be self-contained and produce the specified single-line output with no user input or external files. The algorithm must implement minimum-image periodic distance checks and count examinations exactly as defined above.", "solution": "This problem requires the analysis of a cell-linked-list algorithm used to optimize neighbor searches for the Friends-of-Friends (FoF) algorithm. The core tasks are to derive an upper bound for the number of candidate pairs examined and to verify this bound with a numerical implementation for specific test cases.\n\n**Derivation of the Upper Bound**\n\nThe domain is a periodic cube of side length $L$ partitioned into $m^3$ grid cells of size $h = L/m$. The FoF linking length is $l$. To guarantee that all friends of a given particle are found, one must search a stencil of neighboring cells. A sufficient stencil is a cube in grid-index space of side length $2r_c+1$ centered on the particle's own cell, where the Chebyshev radius is $r_c = \\lceil l/h \\rceil$. The total number of cells in this stencil is $M = (2r_c + 1)^3$.\n\nFor a uniform random distribution of $N$ particles with number density $n = N/L^3$, the expected number of particles in a single cell of volume $h^3$ is $n h^3$. The total number of particles in the search stencil for a given particle is the number of cells in the stencil, $M$, multiplied by the average number of particles per cell. Therefore, the expected number of candidate neighbors (including the particle itself) is $n h^3 M$. This value, $C(b,h) = n h^3 M$, serves as an upper bound on the average number of candidate pair examinations per particle.\n\nFor the deterministic test cases provided, there are exactly $k$ particles in each of the $m^3$ cells, giving a total of $N = k m^3$ particles. The number density is $n = N/L^3 = km^3/L^3$. We can express the cell size as $h=L/m$, which gives $m=L/h$. Substituting this into the density expression yields $n = k(L/h)^3/L^3 = k/h^3$. This gives the identity $n h^3 = k$.\n\nThe upper bound $C(b,h)$ simplifies to $C(b,h) = (n h^3) M = k M$.\n\nIn this deterministic setup, the number of examinations is exact. For any particle, its search stencil of $M$ cells will contain exactly $M \\times k$ particles. The number of candidate pair examinations is the number of other particles in this stencil, which is $kM - 1$. This is the actual average number of examinations per particle. As required, we can see that this is bounded by $C(b,h)$:\n$kM-1 \\le kM$.\n\nThe ratio of the actual average to the bound is therefore $(kM - 1) / (kM)$. The implementation will compute these quantities for the specified test cases.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the cell-linked-list neighbor search algorithm.\n    It iterates through predefined test cases, computes the required metrics, and prints\n    the final result in the specified format.\n    \"\"\"\n\n    def run_case(m, k, b):\n        \"\"\"\n        Executes a single test case of the cell-linked-list candidate pair search.\n\n        Args:\n            m (int): Number of cells per dimension.\n            k (int): Number of particles per cell.\n            b (float): Dimensionless linking parameter.\n\n        Returns:\n            list: A list containing three floats:\n                  1. The actual average number of candidate pair examinations per particle.\n                  2. The theoretical upper bound C(b,h).\n                  3. The ratio of the actual average to the bound.\n        \"\"\"\n        # 1. Calculate derived parameters\n        L = 1.0\n        h = L / m\n        N = k * (m**3)\n        \n        # In this deterministic setup n = k/h^3, s = n^(-1/3) = (k/h^3)^(-1/3) = k^(-1/3)h\n        # Thus, l = b*s = b * k^(-1/3) * h\n        # And l/h = b * k^(-1/3)\n        l_over_h = b * (k**(-1/3.0))\n        \n        r_c = int(np.ceil(l_over_h))\n        M = (2 * r_c + 1)**3\n        \n        # In the deterministic case, n*h^3 = k\n        # So the theoretical bound C(b,h) = n * h^3 * M simplifies to k * M\n        bound_C = float(k * M)\n        \n        # The actual number of examinations per particle in this highly symmetric setup\n        # is k*M - 1, as each particle is checked against all k*M particles in its\n        # stencil, minus itself. We will still compute this via the full algorithm\n        # to demonstrate correctness.\n        \n        # 2. Generate particle positions and build cell-linked list\n        positions = np.zeros((N, 3))\n        cells = {}  # Using a dictionary for sparse storage: (cx,cy,cz) - [particle_indices]\n        \n        particle_idx = 0\n        for cx in range(m):\n            for cy in range(m):\n                for cz in range(m):\n                    cell_pos_x = (cx + 0.5) * h\n                    cell_pos_y = (cy + 0.5) * h\n                    cell_pos_z = (cz + 0.5) * h\n                    cell_center = np.array([cell_pos_x, cell_pos_y, cell_pos_z])\n                    \n                    # Get the cell index tuple for the dictionary key\n                    cell_key = (cx, cy, cz)\n                    cells[cell_key] = []\n                    \n                    # Place k particles at the center of this cell\n                    for _ in range(k):\n                        positions[particle_idx] = cell_center\n                        cells[cell_key].append(particle_idx)\n                        particle_idx += 1\n\n        # 3. Count candidate pair examinations\n        total_examinations = 0\n        for i in range(N):\n            pos_i = positions[i]\n            cell_i_indices = np.floor(pos_i / h).astype(int)\n            \n            # Iterate through the stencil of cells\n            for dcx in range(-r_c, r_c + 1):\n                for dcy in range(-r_c, r_c + 1):\n                    for dcz in range(-r_c, r_c + 1):\n                        # Apply periodic boundary conditions to cell indices\n                        neigh_cell_x = (cell_i_indices[0] + dcx) % m\n                        neigh_cell_y = (cell_i_indices[1] + dcy) % m\n                        neigh_cell_z = (cell_i_indices[2] + dcz) % m\n                        \n                        neigh_cell_key = (neigh_cell_x, neigh_cell_y, neigh_cell_z)\n                        \n                        # Count particles in the neighbor cell\n                        if neigh_cell_key in cells:\n                            for j in cells[neigh_cell_key]:\n                                if i != j:\n                                    total_examinations += 1\n        \n        avg_examinations = total_examinations / N\n        \n        # 4. Calculate ratio and return results\n        ratio = avg_examinations / bound_C if bound_C > 0 else 0.0\n        \n        return [avg_examinations, bound_C, ratio]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (m, k, b)\n        (8, 2, 0.2),         # Case A\n        (10, 3, 3**(1/3)),   # Case B\n        (12, 1, 2.5),        # Case C\n    ]\n\n    results = []\n    for case in test_cases:\n        m, k, b = case\n        result = run_case(m, k, b)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The format is a string representation of a Python list of lists.\n    # [[a1, b1, c1], [a2, b2, c2], ...]\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "3474726"}, {"introduction": "Analyzing the largest cosmological simulations requires distributing the computational work across many processors. This practice delves into the parallelization of the FoF algorithm using domain decomposition, where the simulation volume is divided into sub-domains. You will compare a naive parallel approach with a correct 'ghost zone' method, learning how to properly identify halos that extend across processor boundaries [@problem_id:3474759].", "problem": "You are tasked with implementing and analyzing parallelization strategies for the Friends-of-Friends (FoF) algorithm in numerical cosmology. Consider a cubic simulation box of side length $L = 1$ with periodic boundary conditions in all three dimensions. There are $N$ particles at positions $\\mathbf{x}_i \\in [0,1)^3$, with $i \\in \\{0,1,\\dots,N-1\\}$. The Friends-of-Friends (FoF) algorithm defines an undirected graph on the particles where an edge $\\{i,j\\}$ exists if the periodic Euclidean distance $d_{\\mathrm{PBC}}(\\mathbf{x}_i,\\mathbf{x}_j) \\leq \\ell$, and a halo is a connected component of this graph. The linking length $\\ell$ is defined from first principles as $\\ell = b \\, \\bar{n}^{-1/3}$, where the mean number density $\\bar{n} = N / L^3$, and therefore with $L=1$ this gives $\\ell = b \\, N^{-1/3}$.\n\nThe box is decomposed into $p$ equal-width slab subdomains along the $x$-axis, with subdomain $s$ covering $x \\in [s/p,(s+1)/p)$ for $s \\in \\{0,1,\\dots,p-1\\}$. The decomposition is periodic, so subdomain $p-1$ is adjacent to subdomain $0$. You must implement three parallelization strategies and compare them to the globally correct FoF result:\n- Strategy $\\mathrm{Global}$: Construct the full FoF graph across all $N$ particles using the periodic distance $d_{\\mathrm{PBC}}$ and compute the number of halos as the number of connected components.\n- Strategy $\\mathrm{Naive}$: Partition particles by subdomain and construct FoF graphs independently within each subdomain using only particles whose $x$ coordinate lies in the subdomain interval. Count the total number of connected components summed over subdomains. No cross-subdomain links are considered.\n- Strategy $\\mathrm{Ghost}$: For each subdomain $s$, include all its local particles. Additionally include ghost particles from the two adjacent subdomains whose $x$ coordinate lies within a thickness $\\ell$ of the subdomain boundaries at $x = s/p$ and $x = (s+1)/p$, measured in the periodic $x$-axis metric. Within each subdomain, construct edges among the union of local and ghost particles, but record only edges involving at least one local particle of the subdomain so that the union of all subdomain edge sets over $s$ recovers cross-boundary links. Then compute the number of halos as the number of connected components on the $N$ original particles using the union of all recorded edges over subdomains.\n- Strategy $\\mathrm{Merge}$: Run local FoF independently within each subdomain as in $\\mathrm{Naive}$ to get within-subdomain edges. Then, for each adjacent subdomain pair $(s, (s+1) \\bmod p)$ including $(p-1, 0)$, add cross-boundary edges for any particle pair $(i,j)$ with $i$ in $s$ and $j$ in $(s+1) \\bmod p$ for which $d_{\\mathrm{PBC}}(\\mathbf{x}_i,\\mathbf{x}_j) \\leq \\ell$. Compute the number of halos as the number of connected components on the $N$ original particles using the union of within-subdomain and cross-boundary edges.\n\nAll distances must be computed using the periodic Euclidean metric: for $\\Delta \\mathbf{x} = \\mathbf{x}_i - \\mathbf{x}_j$, define the component-wise periodic displacement $\\Delta \\mathbf{x}_{\\mathrm{PBC}} = \\Delta \\mathbf{x} - \\mathrm{round}(\\Delta \\mathbf{x})$, and $d_{\\mathrm{PBC}}(\\mathbf{x}_i,\\mathbf{x}_j) = \\|\\Delta \\mathbf{x}_{\\mathrm{PBC}}\\|_2$. The domain assignment of a particle with coordinate $x$ is $s = \\lfloor x \\, p \\rfloor$ under left-inclusive, right-exclusive interval convention.\n\nYour program must compute, for each of the test cases below, the number of halos under the four strategies described above and output a single line aggregating the results for all test cases. The required final output format is a single line containing a list of lists with no spaces, where each inner list has the form $[\\mathrm{Global},\\mathrm{Naive},\\mathrm{Ghost},\\mathrm{Merge}]$ for that test case, for example $[[g_1,n_1,gh_1,m_1],[g_2,n_2,gh_2,m_2],\\dots]$.\n\nYou must use dimensionless units in this problem, with $L = 1$ and all coordinates and the linking length $\\ell$ expressed in the same unit. Angles are not involved. The only outputs are integers.\n\nImplement the program according to the following test suite, which is designed to probe correctness, boundary handling, and periodic wrap-around:\n\n- Test case $1$ (happy path, well-separated halos contained within subdomains):\n    - $N = 8$, $b = 0.30$, $p = 2$.\n    - Particle positions $\\mathbf{x}_i$:\n        - $\\mathbf{x}_0 = (0.20, 0.20, 0.20)$,\n        - $\\mathbf{x}_1 = (0.22, 0.20, 0.20)$,\n        - $\\mathbf{x}_2 = (0.20, 0.22, 0.20)$,\n        - $\\mathbf{x}_3 = (0.20, 0.20, 0.22)$,\n        - $\\mathbf{x}_4 = (0.70, 0.70, 0.70)$,\n        - $\\mathbf{x}_5 = (0.72, 0.70, 0.70)$,\n        - $\\mathbfx_6 = (0.70, 0.72, 0.70)$,\n        - $\\mathbf{x}_7 = (0.70, 0.70, 0.72)$.\n- Test case $2$ (boundary crossing between adjacent subdomains):\n    - $N = 10$, $b = 0.28$, $p = 3$.\n    - Particle positions $\\mathbf{x}_i$:\n        - $\\mathbf{x}_0 = (0.322, 0.200, 0.200)$,\n        - $\\mathbf{x}_1 = (0.345, 0.205, 0.200)$,\n        - $\\mathbf{x}_2 = (0.332, 0.220, 0.200)$,\n        - $\\mathbf{x}_3 = (0.318, 0.205, 0.220)$,\n        - $\\mathbf{x}_4 = (0.349, 0.220, 0.220)$,\n        - $\\mathbf{x}_5 = (0.550, 0.600, 0.600)$,\n        - $\\mathbf{x}_6 = (0.560, 0.600, 0.600)$,\n        - $\\mathbf{x}_7 = (0.550, 0.610, 0.600)$,\n        - $\\mathbf{x}_8 = (0.550, 0.600, 0.610)$,\n        - $\\mathbf{x}_9 = (0.560, 0.610, 0.610)$.\n- Test case $3$ (periodic wrap-around and transitive linking across a boundary):\n    - $N = 12$, $b = 0.25$, $p = 4$.\n    - Particle positions $\\mathbf{x}_i$:\n        - $\\mathbf{x}_0 = (0.990, 0.300, 0.300)$,\n        - $\\mathbf{x}_1 = (0.010, 0.300, 0.300)$,\n        - $\\mathbf{x}_2 = (0.985, 0.305, 0.300)$,\n        - $\\mathbf{x}_3 = (0.015, 0.295, 0.300)$,\n        - $\\mathbfx_4 = (0.990, 0.310, 0.295)$,\n        - $\\mathbf{x}_5 = (0.010, 0.290, 0.305)$,\n        - $\\mathbf{x}_6 = (0.240, 0.800, 0.800)$,\n        - $\\mathbf{x}_7 = (0.290, 0.800, 0.800)$,\n        - $\\mathbf{x}_8 = (0.340, 0.800, 0.800)$,\n        - $\\mathbf{x}_9 = (0.390, 0.800, 0.800)$,\n        - $\\mathbf{x}_{10} = (0.440, 0.800, 0.800)$,\n        - $\\mathbf{x}_{11} = (0.490, 0.800, 0.800)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets and with no spaces, where each element corresponds to one test case and is itself a list of four integers of the form $[\\mathrm{Global},\\mathrm{Naive},\\mathrm{Ghost},\\mathrm{Merge}]$. For example: $[[2,2,2,2],[2,3,2,2],[2,4,2,2]]$.", "solution": "This problem tests four strategies for implementing the Friends-of-Friends (FoF) algorithm, focusing on how parallelization via domain decomposition is handled. The number of halos is found by counting the connected components in a graph where vertices are particles and edges connect pairs closer than the linking length, $\\ell$. A Disjoint Set Union (DSU) data structure is ideal for tracking these components.\n\nThe four strategies are:\n1.  **Global**: The baseline, correct method. A single DSU is used for all $N$ particles. Every particle pair is checked, and if their periodic distance is $\\le \\ell$, their sets are united.\n2.  **Naive**: An incorrect parallel approach. Particles are partitioned into $p$ subdomains. FoF is run independently within each subdomain. The total halo count is the sum of halo counts from each subdomain. This fails for halos that cross subdomain boundaries.\n3.  **Ghost**: A correct parallel approach. A single DSU for all $N$ particles is used. Each subdomain processes its local particles and a \"ghost\" layer of particles from adjacent subdomains that lie within a distance $\\ell$ of the boundary. Edges are added to the global DSU if they involve at least one local particle and the distance is $\\le \\ell$. The union of these edge sets from all subdomains recovers the global graph.\n4.  **Merge**: Another correct parallel approach. It involves two phases. First, local FoF is run within each subdomain, adding edges to a global DSU. Second, an explicit merge step checks for and adds edges between particles in adjacent subdomains.\n\nThe core of the implementation is a robust DSU class and a function to calculate the periodic distance. For each test case, we calculate $\\ell = b \\cdot N^{-1/3}$ and then apply each of the four strategies to find the number of halos. The `Global`, `Ghost`, and `Merge` strategies should always yield the same result, representing the true number of halos. The `Naive` strategy will yield a higher count if any halos are split by the subdomain boundaries.", "answer": "```python\nimport numpy as np\nimport math\n\nclass DSU:\n    \"\"\"Disjoint Set Union (Union-Find) data structure.\"\"\"\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.num_sets = n\n\n    def find(self, i):\n        if self.parent[i] == i:\n            return i\n        self.parent[i] = self.find(self.parent[i])\n        return self.parent[i]\n\n    def union(self, i, j):\n        root_i = self.find(i)\n        root_j = self.find(j)\n        if root_i != root_j:\n            self.parent[root_j] = root_i\n            self.num_sets -= 1\n            return True\n        return False\n\ndef pbc_distance_sq(pos1, pos2, box_size=1.0):\n    \"\"\"Calculates the squared periodic Euclidean distance.\"\"\"\n    delta = pos1 - pos2\n    delta -= np.round(delta / box_size) * box_size\n    return np.sum(delta**2)\n\ndef strategy_global(N, positions, ell):\n    \"\"\"Global FoF strategy.\"\"\"\n    dsu = DSU(N)\n    ell_sq = ell**2\n    for i in range(N):\n        for j in range(i + 1, N):\n            if pbc_distance_sq(positions[i], positions[j]) = ell_sq:\n                dsu.union(i, j)\n    return dsu.num_sets\n\ndef strategy_naive(N, p, positions, ell):\n    \"\"\"Naive parallel FoF strategy.\"\"\"\n    ell_sq = ell**2\n    subdomain_particles = [[] for _ in range(p)]\n    for i in range(N):\n        s = math.floor(positions[i, 0] * p)\n        subdomain_particles[s].append(i)\n\n    total_halos = 0\n    for s in range(p):\n        particles_in_s = subdomain_particles[s]\n        k = len(particles_in_s)\n        if k == 0:\n            continue\n        \n        local_dsu = DSU(k)\n        # Map global particle index to local DSU index\n        global_to_local_map = {p_idx: i for i, p_idx in enumerate(particles_in_s)}\n\n        for i1_idx in range(k):\n            for i2_idx in range(i1_idx + 1, k):\n                p1 = particles_in_s[i1_idx]\n                p2 = particles_in_s[i2_idx]\n                if pbc_distance_sq(positions[p1], positions[p2]) = ell_sq:\n                    local_dsu.union(global_to_local_map[p1], global_to_local_map[p2])\n        total_halos += local_dsu.num_sets\n        \n    return total_halos\n\ndef strategy_ghost(N, p, positions, ell):\n    \"\"\"Ghost-zone based parallel FoF strategy.\"\"\"\n    dsu = DSU(N)\n    ell_sq = ell**2\n    \n    subdomain_particles = [[] for _ in range(p)]\n    for i in range(N):\n        s = math.floor(positions[i, 0] * p)\n        subdomain_particles[s].append(i)\n\n    for s in range(p):\n        local_particles_set = set(subdomain_particles[s])\n        \n        s_prev = (s - 1 + p) % p\n        s_next = (s + 1) % p\n        \n        left_boundary_x = s / p\n        right_boundary_x = (s + 1) / p\n        \n        ghost_particles_set = set()\n        \n        potential_ghosts = subdomain_particles[s_prev] + subdomain_particles[s_next]\n        for p_idx in potential_ghosts:\n            x_p = positions[p_idx, 0]\n            # Periodic distance to a point on a line\n            dist_left_x = abs(x_p - left_boundary_x)\n            pbc_dist_left_x = min(dist_left_x, 1.0 - dist_left_x)\n\n            dist_right_x = abs(x_p - right_boundary_x)\n            pbc_dist_right_x = min(dist_right_x, 1.0 - dist_right_x)\n\n            if pbc_dist_left_x = ell or pbc_dist_right_x = ell:\n                ghost_particles_set.add(p_idx)\n\n        combined_particles = list(local_particles_set.union(ghost_particles_set))\n        \n        k = len(combined_particles)\n        for i1_idx in range(k):\n            for i2_idx in range(i1_idx + 1, k):\n                p1 = combined_particles[i1_idx]\n                p2 = combined_particles[i2_idx]\n                \n                # Edge must involve at least one local particle\n                if p1 in local_particles_set or p2 in local_particles_set:\n                    if pbc_distance_sq(positions[p1], positions[p2]) = ell_sq:\n                        dsu.union(p1, p2)\n\n    return dsu.num_sets\n\n\ndef strategy_merge(N, p, positions, ell):\n    \"\"\"Merge-based parallel FoF strategy.\"\"\"\n    dsu = DSU(N)\n    ell_sq = ell**2\n    \n    subdomain_particles = [[] for _ in range(p)]\n    for i in range(N):\n        s = math.floor(positions[i, 0] * p)\n        subdomain_particles[s].append(i)\n\n    # Phase 1: Local FoF\n    for s in range(p):\n        particles_in_s = subdomain_particles[s]\n        k = len(particles_in_s)\n        for i1_idx in range(k):\n            for i2_idx in range(i1_idx + 1, k):\n                p1 = particles_in_s[i1_idx]\n                p2 = particles_in_s[i2_idx]\n                if pbc_distance_sq(positions[p1], positions[p2]) = ell_sq:\n                    dsu.union(p1, p2)\n\n    # Phase 2: Cross-boundary merge\n    for s in range(p):\n        s_next = (s + 1) % p\n        particles_s = subdomain_particles[s]\n        particles_s_next = subdomain_particles[s_next]\n        \n        for p1 in particles_s:\n            for p2 in particles_s_next:\n                if pbc_distance_sq(positions[p1], positions[p2]) = ell_sq:\n                    dsu.union(p1, p2)\n\n    return dsu.num_sets\n\n\ndef solve():\n    test_cases = [\n        # Test Case 1\n        {\n            \"N\": 8, \"b\": 0.30, \"p\": 2,\n            \"positions\": np.array([\n                [0.20, 0.20, 0.20], [0.22, 0.20, 0.20], [0.20, 0.22, 0.20], [0.20, 0.20, 0.22],\n                [0.70, 0.70, 0.70], [0.72, 0.70, 0.70], [0.70, 0.72, 0.70], [0.70, 0.70, 0.72]\n            ])\n        },\n        # Test Case 2\n        {\n            \"N\": 10, \"b\": 0.28, \"p\": 3,\n            \"positions\": np.array([\n                [0.322, 0.200, 0.200], [0.345, 0.205, 0.200], [0.332, 0.220, 0.200],\n                [0.318, 0.205, 0.220], [0.349, 0.220, 0.220], [0.550, 0.600, 0.600],\n                [0.560, 0.600, 0.600], [0.550, 0.610, 0.600], [0.550, 0.600, 0.610],\n                [0.560, 0.610, 0.610]\n            ])\n        },\n        # Test Case 3\n        {\n            \"N\": 12, \"b\": 0.25, \"p\": 4,\n            \"positions\": np.array([\n                [0.990, 0.300, 0.300], [0.010, 0.300, 0.300], [0.985, 0.305, 0.300],\n                [0.015, 0.295, 0.300], [0.990, 0.310, 0.295], [0.010, 0.290, 0.305],\n                [0.240, 0.800, 0.800], [0.290, 8.00e-01, 8.00e-01], [0.340, 0.800, 0.800],\n                [0.390, 0.800, 0.800], [0.440, 0.800, 0.800], [0.490, 0.800, 0.800]\n            ])\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        N, b, p, positions = case[\"N\"], case[\"b\"], case[\"p\"], case[\"positions\"]\n        ell = b * (N ** (-1/3.0))\n        \n        num_global = strategy_global(N, positions, ell)\n        num_naive = strategy_naive(N, p, positions, ell)\n        num_ghost = strategy_ghost(N, p, positions, ell)\n        num_merge = strategy_merge(N, p, positions, ell)\n        \n        all_results.append([num_global, num_naive, num_ghost, num_merge])\n\n    # Format the final output string as per requirements\n    result_str = \",\".join(str(r).replace(\" \", \"\") for r in all_results)\n    print(f\"[{result_str}]\")\n\nsolve()\n```", "id": "3474759"}]}