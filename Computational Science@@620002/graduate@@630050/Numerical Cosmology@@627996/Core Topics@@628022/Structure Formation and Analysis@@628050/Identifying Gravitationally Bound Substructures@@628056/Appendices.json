{"hands_on_practices": [{"introduction": "To move from theory to practice, we begin with the most fundamental algorithm for identifying gravitationally bound structures. This exercise guides you through implementing an iterative 'unbinding' procedure, which cleans a candidate group of particles by progressively removing those with positive total energy. Mastering this technique [@problem_id:3476134] is essential, as it forms the basis of many sophisticated halo-finding algorithms used in modern cosmology.", "problem": "You are given a small set of subhalo candidates, each defined by particle positions, physical velocities, and masses at a cosmic scale factor $a$ with a specified Hubble parameter $H(a)$. Your task is to implement an unbinding procedure using the total specific energy criterion to determine which particles are gravitationally bound to their subhalo candidate, then report the bound fraction for each candidate.\n\nThe problem must be solved from first principles using Newtonian gravity in an expanding universe with the following physically consistent assumptions and definitions.\n\n- Particles are described by their physical positions $\\mathbf{x}_i$ in kiloparsecs, their physical velocities $\\mathbf{v}_i$ in kilometers per second, and masses $m_i$ in solar masses.\n- The Hubble parameter $H(a)$ is provided in kilometers per second per megaparsec and is to be used to compute peculiar velocities by subtracting the Hubble flow.\n- The peculiar velocity of particle $i$ is defined as $\\mathbf{u}_i = \\mathbf{v}_i - H(a)\\,\\mathbf{x}_i^{\\mathrm{(Mpc)}}$, where $\\mathbf{x}_i^{\\mathrm{(Mpc)}}$ is the position in megaparsecs, i.e., $\\mathbf{x}_i^{\\mathrm{(Mpc)}} = \\mathbf{x}_i^{\\mathrm{(kpc)}}/1000$.\n- At any iteration, define the bulk peculiar velocity of the current particle set by the mass-weighted mean\n$$\n\\mathbf{u}_{\\mathrm{bulk}} = \\frac{\\sum_i m_i \\mathbf{u}_i}{\\sum_i m_i}.\n$$\n- The specific kinetic energy of particle $i$ relative to the bulk is\n$$\nK_i = \\frac{1}{2}\\,\\|\\mathbf{u}_i - \\mathbf{u}_{\\mathrm{bulk}}\\|^2.\n$$\n- The specific gravitational potential energy of particle $i$ due to all other particles in the current set is computed with Plummer softening of length $\\epsilon$ (in kiloparsecs) as\n$$\n\\phi_i = - G \\sum_{j \\neq i} \\frac{m_j}{\\sqrt{\\|\\mathbf{x}_i - \\mathbf{x}_j\\|^2 + \\epsilon^2}},\n$$\nwhere the gravitational constant is to be used in the astrophysical unit system $G = 4.300917270\\times 10^{-6}\\,(\\mathrm{km/s})^2\\,\\mathrm{kpc}/M_\\odot$.\n- The specific total energy is $E_i = K_i + \\phi_i$. A particle is classified as bound if and only if $E_i  0$.\n- Use an iterative unbinding procedure: start with all candidate particles, compute $\\mathbf{u}_{\\mathrm{bulk}}$, then $\\phi_i$ and $E_i$ for each particle, remove all particles with $E_i \\ge 0$, and repeat until convergence (no removals) or the set becomes empty. The final bound set is the converged set.\n\nAll calculations must consistently use the stated units with distances in kiloparsecs, velocities in kilometers per second, masses in solar masses, and $H(a)$ in kilometers per second per megaparsec. Angles do not appear in this task. Final answers must be reported as decimal floats rounded to three decimal places.\n\nImplement a program that evaluates the following test suite. For each case, the positions are given as a list of vectors $[\\,[x,y,z],\\ldots\\,]$ in kiloparsecs, the velocities as a list of vectors $[\\,[v_x,v_y,v_z],\\ldots\\,]$ in kilometers per second, and the masses as a list $[\\,m_0,\\ldots\\,]$ in solar masses. The Hubble parameter $H(a)$ is in kilometers per second per megaparsec, the scale factor is $a$, and the softening length is $\\epsilon$ in kiloparsecs.\n\n- Case A (two-body circular orbit, happy path):\n    - $a = 1$, $H(a) = 70$.\n    - $\\epsilon = 0.05$.\n    - Positions (kiloparsecs): $[\\,[-5,0,0],[5,0,0]\\,]$.\n    - Masses (solar masses): $[\\,10^9, 10^9\\,]$.\n    - Velocities (kilometers per second): Let $d = 10$ be the separation in kiloparsecs and define the peculiar circular speed magnitude by $v_c = \\sqrt{G m/(2d)}$ with $m = 10^9$. Then the physical velocities are\n      $$\n      \\mathbf{v}_0 = [\\, -0.35,\\, +v_c,\\, 0 \\,],\\quad \\mathbf{v}_1 = [\\, +0.35,\\,-v_c,\\, 0 \\,],\n      $$\n      where the Hubble flow terms $\\pm 0.35$ arise from $H(a)\\,x$ with $x=\\pm 0.005$ megaparsecs.\n\n- Case B (central massive particle with one bound and one unbound satellite):\n    - $a = 1$, $H(a) = 70$.\n    - $\\epsilon = 0.05$.\n    - Positions (kiloparsecs): $[\\, [0,0,0],\\,[5,0,0],\\,[0,8,0]\\, ]$.\n    - Masses (solar masses): $[\\,10^{10},\\,5\\times 10^9,\\,5\\times 10^8\\,]$.\n    - Velocities (kilometers per second): define peculiar velocities $[\\, [0,0,0],\\,[0,50,0],\\,[0,200,0]\\, ]$ and add the Hubble flow to obtain physical velocities. The only nonzero Hubble contribution is for the particle at $[\\,5,0,0\\,]$, with $H(a)\\,x = 0.35$, giving\n      $$\n      \\mathbf{v}_0 = [\\,0,\\,0,\\,0\\,],\\quad \\mathbf{v}_1 = [\\,0.35,\\,50,\\,0\\,],\\quad \\mathbf{v}_2 = [\\,0,\\,200,\\,0\\,].\n      $$\n\n- Case C (single particle boundary case):\n    - $a = 1$, $H(a) = 70$.\n    - $\\epsilon = 0.05$.\n    - Positions (kiloparsecs): $[\\, [0,0,0] \\,]$.\n    - Masses (solar masses): $[\\,10^9\\,]$.\n    - Velocities (kilometers per second): $[\\, [0,0,0] \\,]$.\n\n- Case D (two-body borderline unbound with center-of-mass reference):\n    - $a = 1$, $H(a) = 70$.\n    - $\\epsilon = 0.05$.\n    - Positions (kiloparsecs): $[\\, [0,0,0],\\,[20,0,0] \\,]$.\n    - Masses (solar masses): $[\\,10^9,\\,10^9\\,]$.\n    - Velocities (kilometers per second): set the peculiar velocity of the first particle to $[\\,0,0,0\\,]$ and that of the second to have magnitude\n      $$\n      v_b = \\sqrt{\\frac{8\\,G\\,m}{d}},\n      $$\n      where $m=10^9$ and $d=20$ kiloparsecs is the separation, directed along $+y$. Add the Hubble flow to obtain physical velocities. Thus\n      $$\n      \\mathbf{v}_0 = [\\,0,\\,0,\\,0\\,],\\quad \\mathbf{v}_1 = [\\,1.4,\\,v_b,\\,0\\,],\n      $$\n      since $x=0.02$ megaparsecs gives $H(a)\\,x = 1.4$.\n\nYour program must apply the iterative unbinding procedure for each case and output the bound fraction, defined as the ratio of the number of bound particles after convergence to the initial number of particles, as a decimal rounded to three decimal places. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[f_A,f_B,f_C,f_D]\") in this exact format.\n\nAll numeric work must use the units stated above. Report the four bound fractions for the four cases in the specified order.", "solution": "The user requires the implementation of an iterative unbinding algorithm to identify gravitationally bound particles within subhalo candidates in a cosmological context. For each candidate, the fraction of bound particles relative to the initial set must be calculated. The problem is well-posed and scientifically grounded in the principles of Newtonian mechanics applied to an expanding universe, as is common in the analysis of N-body cosmological simulations.\n\nThe core of the methodology rests upon the total specific energy of each particle. A particle is considered gravitationally bound to a system if its total energy is negative, implying it lacks sufficient kinetic energy to escape the system's gravitational potential well. The process is iterative because the removal of unbound particles changes the system's total mass and center of mass velocity, which in turn affects the energy calculations for the remaining particles.\n\nThe algorithm proceeds as follows for each subhalo candidate:\n\n1.  **Initialization**: Begin with the full set of candidate particles, each described by its mass $m_i$, physical position $\\mathbf{x}_i$, and physical velocity $\\mathbf{v}_i$. The initial number of particles, $N_{\\mathrm{initial}}$, is recorded. The cosmological parameters, Hubble parameter $H(a)$ and gravitational constant $G = 4.300917270\\times 10^{-6}\\,(\\mathrm{km/s})^2\\,\\mathrm{kpc}/M_\\odot$, are established.\n\n2.  **Iterative Unbinding Loop**: The procedure is repeated until no more particles are removed in an iteration, indicating convergence to a stable, self-bound system.\n\n    a.  **Peculiar Velocity Calculation**: First, the effect of the universe's expansion (the Hubble flow) must be removed from the particles' physical velocities to obtain their peculiar velocities. The peculiar velocity $\\mathbf{u}_i$ of a particle $i$ is its motion relative to the Hubble flow at its location and is calculated as:\n        $$\n        \\mathbf{u}_i = \\mathbf{v}_i - H(a)\\,\\mathbf{x}_i^{\\mathrm{(Mpc)}}\n        $$\n        where $\\mathbf{x}_i^{\\mathrm{(Mpc)}}$ is the particle's position vector expressed in megaparsecs (Mpc), obtained by converting from kiloparsecs (kpc) via $\\mathbf{x}_i^{\\mathrm{(Mpc)}} = \\mathbf{x}_i^{\\mathrm{(kpc)}} / 1000$.\n\n    b.  **Bulk Velocity Calculation**: The center of mass velocity of the current set of particles is determined. This \"bulk\" peculiar velocity serves as the reference frame for calculating kinetic energies. It is the mass-weighted average of the individual peculiar velocities:\n        $$\n        \\mathbf{u}_{\\mathrm{bulk}} = \\frac{\\sum_i m_i \\mathbf{u}_i}{\\sum_i m_i}\n        $$\n        The summation is over all particles currently in the candidate set.\n\n    c.  **Specific Energy Calculation**: For each particle $i$, its specific total energy $E_i$ (energy per unit mass) is the sum of its specific kinetic energy $K_i$ and specific potential energy $\\phi_i$.\n        \n        i.  **Specific Kinetic Energy**: This is the kinetic energy with respect to the bulk motion of the system:\n            $$\n            K_i = \\frac{1}{2}\\,\\|\\mathbf{u}_i - \\mathbf{u}_{\\mathrm{bulk}}\\|^2\n            $$\n\n        ii. **Specific Gravitational Potential Energy**: This is the potential energy of particle $i$ due to the gravitational field of all other particles $j$ in the current set. A Plummer softening length, $\\epsilon$, is introduced to prevent the potential from diverging at small particle separations:\n            $$\n            \\phi_i = - G \\sum_{j \\neq i} \\frac{m_j}{\\sqrt{\\|\\mathbf{x}_i - \\mathbf{x}_j\\|^2 + \\epsilon^2}}\n            $$\n\n    d.  **Binding Criterion and Particle Removal**: A particle $i$ is classified as gravitationally bound if its total specific energy is negative:\n        $$\n        E_i = K_i + \\phi_i  0\n        $$\n        All particles with $E_i \\ge 0$ are deemed unbound and are removed from the set for the next iteration.\n\n3.  **Termination and Final Calculation**: The loop terminates when an iteration results in no particles being removed, or if the set of particles becomes empty. The number of particles in the final, converged set, $N_{\\mathrm{final}}$, is counted. The bound fraction for the candidate is then computed as the ratio:\n    $$\n    f_{\\mathrm{bound}} = \\frac{N_{\\mathrm{final}}}{N_{\\mathrm{initial}}}\n    $$\n    This fraction is reported rounded to three decimal places. For a single particle system, $\\mathbf{u}_{\\mathrm{bulk}} = \\mathbf{u}_0$, so $K_0=0$. The potential sum $\\phi_0$ is empty, so $\\phi_0=0$. Thus $E_0=0$, and the particle is unbound, leading to a bound fraction of $0$.\n\nThis physically-motivated, iterative algorithm will be applied to each test case provided.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the bound fraction of particles in four subhalo candidate test cases.\n    \"\"\"\n    G_ASTRO = 4.300917270e-6  # (km/s)^2 * kpc / M_sun\n\n    def calculate_bound_fraction(pos, vel, mass, H, epsilon):\n        \"\"\"\n        Performs the iterative unbinding procedure and returns the bound fraction.\n        \"\"\"\n        # Ensure inputs are numpy arrays\n        pos = np.array(pos, dtype=np.float64)\n        vel = np.array(vel, dtype=np.float64)\n        mass = np.array(mass, dtype=np.float64)\n        \n        if pos.ndim == 1: pos = pos.reshape(1, -1)\n        if vel.ndim == 1: vel = vel.reshape(1, -1)\n        if mass.ndim == 0: mass = mass.reshape(1)\n\n        initial_particle_count = len(mass)\n        if initial_particle_count == 0:\n            return 0.0\n\n        current_indices = np.arange(initial_particle_count)\n        \n        while True:\n            num_particles = len(current_indices)\n            if num_particles == 0:\n                break\n\n            current_pos = pos[current_indices]\n            current_vel = vel[current_indices]\n            current_mass = mass[current_indices]\n\n            # 1. Calculate peculiar velocities\n            pos_mpc = current_pos / 1000.0\n            hubble_flow = H * pos_mpc\n            peculiar_vel = current_vel - hubble_flow\n\n            # 2. Calculate bulk peculiar velocity\n            total_mass = np.sum(current_mass)\n            if total_mass == 0: # Should not happen with positive masses\n                break\n                \n            mass_vel_product = current_mass[:, np.newaxis] * peculiar_vel\n            bulk_vel = np.sum(mass_vel_product, axis=0) / total_mass\n            \n            # 3. Calculate specific energies\n            # Specific kinetic energy\n            rel_vel = peculiar_vel - bulk_vel\n            kinetic_energy = 0.5 * np.sum(rel_vel**2, axis=1)\n\n            # Specific potential energy\n            potential_energy = np.zeros(num_particles, dtype=np.float64)\n            for i in range(num_particles):\n                # Vectorized calculation for particle i's potential\n                # from all other particles j\n                delta_pos = current_pos[i] - current_pos\n                dist_sq = np.sum(delta_pos**2, axis=1)\n                \n                # Create a mask to exclude the i=j case and handle small mass particles\n                valid_j = np.ones(num_particles, dtype=bool)\n                valid_j[i] = False\n                \n                if np.any(valid_j):\n                    # Denominator of potential term, with softening\n                    denom = np.sqrt(dist_sq[valid_j] + epsilon**2)\n                    # Sum of potential contributions from all other particles\n                    potential_energy[i] = -G_ASTRO * np.sum(current_mass[valid_j] / denom)\n            \n            total_energy = kinetic_energy + potential_energy\n\n            # 4. Identify bound particles and create a new index list\n            bound_mask = total_energy  0\n            new_indices = current_indices[bound_mask]\n\n            # 5. Check for convergence\n            if len(new_indices) == num_particles:\n                break  # Converged\n            \n            current_indices = new_indices\n            \n        final_particle_count = len(current_indices)\n        bound_fraction = final_particle_count / initial_particle_count\n        \n        return round(bound_fraction, 3)\n\n    # --- Test Cases ---\n\n    # Case A: Two-body circular orbit\n    d_a = 10.0\n    m_a = 1e9\n    v_c_a = np.sqrt(G_ASTRO * m_a / (2 * d_a))\n    vel_a = [\n        [-0.35, v_c_a, 0.0],\n        [0.35, -v_c_a, 0.0]\n    ]\n    case_a = (\n        [[-5.0, 0.0, 0.0], [5.0, 0.0, 0.0]],  # pos\n        vel_a,                                 # vel\n        [1e9, 1e9],                            # mass\n        70.0,                                  # H\n        0.05                                   # epsilon\n    )\n\n    # Case B: Central massive particle with one bound and one unbound satellite\n    case_b = (\n        [[0.0, 0.0, 0.0], [5.0, 0.0, 0.0], [0.0, 8.0, 0.0]], # pos\n        [[0.0, 0.0, 0.0], [0.35, 50.0, 0.0], [0.0, 200.0, 0.0]], # vel\n        [1e10, 5e9, 5e8],                      # mass\n        70.0,                                  # H\n        0.05                                   # epsilon\n    )\n\n    # Case C: Single particle boundary case\n    case_c = (\n        [[0.0, 0.0, 0.0]],                     # pos\n        [[0.0, 0.0, 0.0]],                     # vel\n        [1e9],                                 # mass\n        70.0,                                  # H\n        0.05                                   # epsilon\n    )\n\n    # Case D: Two-body borderline unbound\n    d_d = 20.0\n    m_d = 1e9\n    v_b_d = np.sqrt(8.0 * G_ASTRO * m_d / d_d)\n    vel_d = [\n        [0.0, 0.0, 0.0],\n        [1.4, v_b_d, 0.0]\n    ]\n    case_d = (\n        [[0.0, 0.0, 0.0], [20.0, 0.0, 0.0]],  # pos\n        vel_d,                                 # vel\n        [1e9, 1e9],                            # mass\n        70.0,                                  # H\n        0.05                                   # epsilon\n    )\n    \n    test_cases = [case_a, case_b, case_c, case_d]\n    results = [calculate_bound_fraction(*case) for case in test_cases]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3476134"}, {"introduction": "While simulations provide a detailed, particle-based view of the gravitational potential, analytic models like the Navarro-Frenk-White (NFW) profile offer a powerful theoretical benchmark. In this practice, you will compute particle boundness using both a given numerical potential and one derived from an NFW model. By comparing the results [@problem_id:3476125], you will gain insight into how well idealized models capture the complexity of simulated halos and develop skills in model-data comparison.", "problem": "You are given a set of particles in the vicinity of a gravitationally bound substructure (a subhalo). For each particle, you are provided the absolute position vector in kiloparsec (kpc), the absolute velocity vector in kilometers per second (km/s), and a numerically estimated gravitational potential at that particle’s location in units of $(\\mathrm{km}/\\mathrm{s})^2$. You are also given the subhalo’s center-of-mass position and velocity, and a global analytic Navarro–Frenk–White (NFW) model for the subhalo specified by the parameters $M_{200}$ in Solar masses ($M_{\\odot}$), $c$ (dimensionless concentration), and $r_{200}$ in kiloparsec (kpc). The gravitational constant to be used is $G = 4.30091\\times 10^{-6}\\ \\mathrm{kpc}\\,(\\mathrm{km}/\\mathrm{s})^2\\,M_{\\odot}^{-1}$.\n\nYour task is to proceed from first principles of Newtonian mechanics to:\n- derive the escape speed $v_{\\rm esc}$ from a gravitational potential that is zero at infinity for each particle, and use it to classify boundness using the particle speed in the subhalo center-of-mass frame,\n- construct an analytic NFW gravitational potential using the given NFW parameters and, for each particle’s radius from the subhalo center, compute the corresponding analytic escape speed and a second, independent boundness classification,\n- quantitatively compare the numerical and NFW escape speeds per test case.\n\nUse the following fundamental base:\n- The specific mechanical energy of a particle of mass $m$ in a gravitational field is $E = \\frac{1}{2} v^2 + \\Phi$, where $v$ is the particle speed with respect to the subhalo center-of-mass frame and $\\Phi$ is the gravitational potential per unit mass. The total specific energy $E$ is conserved along ballistic trajectories in a time-independent potential.\n- The escape condition from a localized mass distribution with $\\Phi(\\infty) = 0$ occurs at the threshold where the total specific energy reaches $E = 0$.\n- The Navarro–Frenk–White (NFW) profile is a widely used model for dark matter halos defined by a characteristic scale radius $r_s$ and concentration $c$, with $r_s = r_{200}/c$, and by the function $f(c) = \\ln(1+c) - \\dfrac{c}{1+c}$. Use the NFW total mass parameter $M_{200}$ and these definitions to construct the analytic potential that is zero at infinity.\n\nRequired algorithmic decisions:\n- Work strictly in the subhalo center-of-mass frame to compute particle speeds $v$.\n- Treat a particle as gravitationally bound under a given potential if and only if $v \\le v_{\\rm esc} - \\epsilon$ with an absolute numerical tolerance $\\epsilon = 10^{-9}$ in $(\\mathrm{km}/\\mathrm{s})$. Otherwise, classify it as not bound. This rule applies both to the numerical-potential-based $v_{\\rm esc}$ and to the NFW-analytic $v_{\\rm esc}$ classifications.\n- For the analytic NFW potential, take the limit at $r \\to 0$ consistently and use positions’ Euclidean norms $r$ in kpc to evaluate the potential and escape speed.\n\nUnits:\n- Positions must be treated in $\\mathrm{kpc}$.\n- Velocities must be treated in $\\mathrm{km}/\\mathrm{s}$.\n- Potentials must be treated in $(\\mathrm{km}/\\mathrm{s})^2$.\n- The final escape-speed differences must be reported in $\\mathrm{km}/\\mathrm{s}$.\n\nTest suite and parameters:\n- Global parameters shared by all test cases:\n    - $G = 4.30091\\times 10^{-6}\\ \\mathrm{kpc}\\,(\\mathrm{km}/\\mathrm{s})^2\\,M_{\\odot}^{-1}$\n    - $M_{200} = 10^{12}\\ M_{\\odot}$\n    - $c = 10$\n    - $r_{200} = 205\\ \\mathrm{kpc}$\n- Test Case $1$:\n    - Subhalo center-of-mass position: $[0,0,0]\\ \\mathrm{kpc}$\n    - Subhalo center-of-mass velocity: $[0,0,0]\\ \\mathrm{km}/\\mathrm{s}$\n    - Particle absolute positions in $\\mathrm{kpc}$:\n        - $[5,0,0]$, $[0,20,0]$, $[0,0,50]$, $[70,70,0]$, $[300,0,0]$\n    - Particle absolute velocities in $\\mathrm{km}/\\mathrm{s}$:\n        - $[100,50,0]$, $[200,0,0]$, $[0,350,0]$, $[-50,0,50]$, $[30,0,0]$\n    - Numerical potentials $\\Phi_{\\rm num}$ at particle locations in $(\\mathrm{km}/\\mathrm{s})^2$:\n        - $-128{,}316.0$, $-97{,}416.0$, $-71{,}320.0$, $-53{,}996.25$, $-23{,}796.0$\n- Test Case $2$:\n    - Subhalo center-of-mass position: $[10,-5,2]\\ \\mathrm{kpc}$\n    - Subhalo center-of-mass velocity: $[150,-50,20]\\ \\mathrm{km}/\\mathrm{s}$\n    - Particle absolute positions in $\\mathrm{kpc}$:\n        - $[10,-5,7]$, $[10,15,2]$, $[60,-5,2]$, $[-60,65,2]$, $[310,-5,2]$\n    - Particle absolute velocities in $\\mathrm{km}/\\mathrm{s}$:\n        - $[200,-50,20]$, $[50,-50,20]$, $[200,300,20]$, $[150,-50,200]$, $[0,0,0]$\n    - Numerical potentials $\\Phi_{\\rm num}$ at particle locations in $(\\mathrm{km}/\\mathrm{s})^2$:\n        - $-125{,}800.0$, $-101{,}352.0$, $-69{,}893.6$, $-56{,}567.5$, $-22{,}474.0$\n- Test Case $3$:\n    - Subhalo center-of-mass position: $[0,0,0]\\ \\mathrm{kpc}$\n    - Subhalo center-of-mass velocity: $[0,0,0]\\ \\mathrm{km}/\\mathrm{s}$\n    - Particle absolute positions in $\\mathrm{kpc}$:\n        - $[0,20,0]$, $[0.1,0,0]$, $[0,0,300]$\n    - Particle absolute velocities in $\\mathrm{km}/\\mathrm{s}$:\n        - $[443.0,0,0]$, $[0,800.0,0]$, $[0,0,10.0]$\n    - Numerical potentials $\\Phi_{\\rm num}$ at particle locations in $(\\mathrm{km}/\\mathrm{s})^2$:\n        - $-98{,}124.5$, $-140{,}000.0$, $-26{,}000.0$\n\nAnalytic NFW model specification:\n- Use $r_s = r_{200}/c$ and $f(c) = \\ln(1+c) - \\dfrac{c}{1+c}$.\n- Construct an analytic potential $\\Phi_{\\rm NFW}(r)$ that satisfies $\\Phi_{\\rm NFW}(\\infty) = 0$ using $G$, $M_{200}$, $r_s$, and $f(c)$, then compute $v_{{\\rm esc},\\rm NFW}(r)$ accordingly.\n\nProgram requirements:\n- For each test case:\n    1. Compute particle speeds $v$ in the subhalo center-of-mass frame in $\\mathrm{km}/\\mathrm{s}$.\n    2. From the given numerical potentials $\\Phi_{\\rm num}$, compute $v_{{\\rm esc},\\rm num} = \\sqrt{\\max(0,\\,-2\\,\\Phi_{\\rm num})}$ for each particle in $\\mathrm{km}/\\mathrm{s}$, then classify boundness using the tolerance rule above.\n    3. From the analytic NFW potential $\\Phi_{\\rm NFW}(r)$, compute $v_{{\\rm esc},\\rm NFW}(r)$ for each particle and classify boundness using the same tolerance rule.\n    4. Compute the maximum absolute difference of escape speeds $\\max_i \\left|v_{{\\rm esc},\\rm num}^{(i)} - v_{{\\rm esc},\\rm NFW}^{(i)}\\right|$ across particles, in $\\mathrm{km}/\\mathrm{s}$, rounded to six decimal places.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case result is a list of three elements: the list of numerical-potential boundness booleans, the list of NFW boundness booleans, and the maximum absolute escape-speed difference rounded to six decimal places. Concretely, the output must look like:\n- $[\\,[\\,[b_{1,1},\\dots],\\,[b_{1,1}^{\\rm NFW},\\dots],\\,\\Delta_1],\\ [\\,[b_{2,1},\\dots],\\,[b_{2,1}^{\\rm NFW},\\dots],\\,\\Delta_2],\\ [\\,[b_{3,1},\\dots],\\,[b_{3,1}^{\\rm NFW},\\dots],\\,\\Delta_3]\\,]$\nwhere each $b$ is either $True$ or $False$, and each $\\Delta_j$ is a float in $\\mathrm{km}/\\mathrm{s}$ rounded to six decimals.\n\nYour program must be a complete, runnable Python script that uses only the specified runtime environment and must not read any input or write any files or extra text beyond the single required output line.", "solution": "The problem is assessed as valid as it is scientifically grounded in Newtonian mechanics and standard cosmological models, well-posed, internally consistent, and contains all necessary information for a unique solution.\n\nThe primary objective is to determine whether particles are gravitationally bound to a subhalo, based on two distinct models for the gravitational potential: one derived from numerical estimates and another from an analytic Navarro–Frenk–White (NFW) profile. The results from these two approaches will be compared.\n\nThe analysis is performed in the center-of-mass frame of the subhalo. For each particle, we are given its absolute position vector $\\vec{r}_{\\rm abs}$ and absolute velocity vector $\\vec{v}_{\\rm abs}$. The subhalo's center-of-mass position is $\\vec{R}_{\\rm cm}$ and its velocity is $\\vec{V}_{\\rm cm}$. A particle's position and velocity relative to the subhalo are therefore:\n$$ \\vec{r} = \\vec{r}_{\\rm abs} - \\vec{R}_{\\rm cm} $$\n$$ \\vec{v} = \\vec{v}_{\\rm abs} - \\vec{V}_{\\rm cm} $$\nThe particle's speed in this frame is the magnitude of its relative velocity vector, $v = |\\vec{v}|$.\n\nThe specific mechanical energy of a particle (energy per unit mass) in a time-independent gravitational potential $\\Phi$ is given by the sum of its specific kinetic energy and potential energy:\n$$ E = \\frac{1}{2}v^2 + \\Phi $$\nA particle is considered gravitationally bound to the mass distribution creating the potential if its total specific energy is negative ($E  0$). If its total energy is non-negative ($E \\ge 0$), it has sufficient energy to escape to an infinite distance, where the potential is defined to be zero ($\\Phi(\\infty) = 0$).\n\nThe threshold for being bound is the escape condition, $E = 0$. The speed at which this occurs is the escape speed, $v_{\\rm esc}$. It is derived from the energy equation:\n$$ \\frac{1}{2}v_{\\rm esc}^2 + \\Phi = 0 \\implies v_{\\rm esc} = \\sqrt{-2\\Phi} $$\nSince a binding potential is negative ($\\Phi  0$), $-2\\Phi$ is positive. For cases where $\\Phi \\ge 0$ (e.g., due to numerical noise or being outside the bound system), the potential is not binding, and the escape speed is taken to be zero. Thus, we use $v_{\\rm esc} = \\sqrt{\\max(0, -2\\Phi)}$.\n\nA particle is classified as bound if its speed $v$ is less than the local escape speed $v_{\\rm esc}$. To handle numerical precision, the problem specifies the condition for being bound as $v \\le v_{\\rm esc} - \\epsilon$, where $\\epsilon = 10^{-9}\\ \\mathrm{km}/\\mathrm{s}$ is a small tolerance.\n\nThe procedure involves two parallel analyses for each particle:\n\n**1. Analysis with Numerical Potential ($\\Phi_{\\rm num}$)**\nFor each particle, a numerical estimate of the potential, $\\Phi_{\\rm num}$, is provided.\n- The escape speed is calculated as $v_{{\\rm esc},\\rm num} = \\sqrt{\\max(0, -2\\Phi_{\\rm num})}$.\n- The particle is classified as bound if $v \\le v_{{\\rm esc},\\rm num} - \\epsilon$.\n\n**2. Analysis with Analytic NFW Potential ($\\Phi_{\\rm NFW}$)**\nThe NFW profile is an empirical model for the mass distribution of dark matter halos. The gravitational potential for an NFW profile, with the boundary condition $\\Phi(\\infty)=0$, is given by:\n$$ \\Phi_{\\rm NFW}(r) = -\\frac{G M_{200}}{r_s f(c)} \\frac{\\ln(1+r/r_s)}{r/r_s} $$\nwhere $r=|\\vec{r}|$ is the particle's distance from the subhalo center. The parameters in this equation are derived from the global halo properties provided:\n- $M_{200}$ is the mass enclosed within a radius $r_{200}$, inside which the mean density is $200$ times the critical density of the universe.\n- $c$ is the dimensionless concentration parameter.\n- $r_s$ is the scale radius, defined as $r_s = r_{200}/c$.\n- $f(c)$ is a function related to the total mass, defined as $f(c) = \\ln(1+c) - \\frac{c}{1+c}$.\n- $G$ is the gravitational constant.\n\nFor each particle, we perform the following steps:\n- Calculate its distance $r$ from the subhalo center.\n- Evaluate $\\Phi_{\\rm NFW}(r)$ using the formula above. In the limit $r \\to 0$, the term $\\frac{\\ln(1+r/r_s)}{r/r_s}$ approaches $1$, resulting in a finite central potential.\n- Calculate the escape speed from this analytic potential: $v_{{\\rm esc},\\rm NFW}(r) = \\sqrt{\\max(0, -2\\Phi_{\\rm NFW}(r))}$.\n- The particle is classified as bound if $v \\le v_{{\\rm esc},\\rm NFW}(r) - \\epsilon$.\n\n**3. Quantitative Comparison**\nAfter classifying each particle using both potential models, the two sets of escape velocities are compared. For each test case, the maximum absolute difference across all its particles is computed:\n$$ \\Delta v_{\\rm esc} = \\max_{i} \\left| v_{{\\rm esc},\\rm num}^{(i)} - v_{{\\rm esc},\\rm NFW}^{(i)} \\right| $$\nwhere the index $i$ runs over the particles in the test case.\n\nThis complete procedure is applied to each test case provided, yielding per-particle boundness classifications and a single escape speed difference metric for each case. The results are then aggregated into the specified output format.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the gravitational boundness problem for the given test cases.\n    \"\"\"\n    # Global parameters and constants\n    G = 4.30091e-6  # kpc*(km/s)^2/M_sun\n    M200 = 1e12  # M_sun\n    c = 10.0\n    r200 = 205.0  # kpc\n    epsilon = 1e-9  # km/s\n\n    # NFW analytic model pre-computation\n    r_s = r200 / c\n    f_c = np.log(1.0 + c) - c / (1.0 + c)\n    nfw_potential_const = - (G * M200) / (r_s * f_c)\n\n    def get_phi_nfw(r):\n        \"\"\"Computes the analytic NFW potential at a given radius r.\"\"\"\n        if r  1e-12:  # Handle r=0 case to avoid division by zero\n            # lim_{x-0} ln(1+x)/x = 1\n            return nfw_potential_const\n        x = r / r_s\n        return nfw_potential_const * np.log(1.0 + x) / x\n\n    test_cases = [\n        {\n            \"subhalo_pos\": np.array([0.0, 0.0, 0.0]),\n            \"subhalo_vel\": np.array([0.0, 0.0, 0.0]),\n            \"particles\": [\n                {\"pos\": np.array([5.0, 0.0, 0.0]), \"vel\": np.array([100.0, 50.0, 0.0]), \"phi_num\": -128316.0},\n                {\"pos\": np.array([0.0, 20.0, 0.0]), \"vel\": np.array([200.0, 0.0, 0.0]), \"phi_num\": -97416.0},\n                {\"pos\": np.array([0.0, 0.0, 50.0]), \"vel\": np.array([0.0, 350.0, 0.0]), \"phi_num\": -71320.0},\n                {\"pos\": np.array([70.0, 70.0, 0.0]), \"vel\": np.array([-50.0, 0.0, 50.0]), \"phi_num\": -53996.25},\n                {\"pos\": np.array([300.0, 0.0, 0.0]), \"vel\": np.array([30.0, 0.0, 0.0]), \"phi_num\": -23796.0},\n            ]\n        },\n        {\n            \"subhalo_pos\": np.array([10.0, -5.0, 2.0]),\n            \"subhalo_vel\": np.array([150.0, -50.0, 20.0]),\n            \"particles\": [\n                {\"pos\": np.array([10.0, -5.0, 7.0]), \"vel\": np.array([200.0, -50.0, 20.0]), \"phi_num\": -125800.0},\n                {\"pos\": np.array([10.0, 15.0, 2.0]), \"vel\": np.array([50.0, -50.0, 20.0]), \"phi_num\": -101352.0},\n                {\"pos\": np.array([60.0, -5.0, 2.0]), \"vel\": np.array([200.0, 300.0, 20.0]), \"phi_num\": -69893.6},\n                {\"pos\": np.array([-60.0, 65.0, 2.0]), \"vel\": np.array([150.0, -50.0, 200.0]), \"phi_num\": -56567.5},\n                {\"pos\": np.array([310.0, -5.0, 2.0]), \"vel\": np.array([0.0, 0.0, 0.0]), \"phi_num\": -22474.0},\n            ]\n        },\n        {\n            \"subhalo_pos\": np.array([0.0, 0.0, 0.0]),\n            \"subhalo_vel\": np.array([0.0, 0.0, 0.0]),\n            \"particles\": [\n                {\"pos\": np.array([0.0, 20.0, 0.0]), \"vel\": np.array([443.0, 0.0, 0.0]), \"phi_num\": -98124.5},\n                {\"pos\": np.array([0.1, 0.0, 0.0]), \"vel\": np.array([0.0, 800.0, 0.0]), \"phi_num\": -140000.0},\n                {\"pos\": np.array([0.0, 0.0, 300.0]), \"vel\": np.array([0.0, 0.0, 10.0]), \"phi_num\": -26000.0},\n            ]\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        subhalo_pos = case[\"subhalo_pos\"]\n        subhalo_vel = case[\"subhalo_vel\"]\n        \n        num_boundness = []\n        nfw_boundness = []\n        esc_speed_diffs = []\n\n        for p in case[\"particles\"]:\n            # 1. Compute particle speed in subhalo center-of-mass frame\n            rel_pos = p[\"pos\"] - subhalo_pos\n            rel_vel = p[\"vel\"] - subhalo_vel\n            r = np.linalg.norm(rel_pos)\n            v = np.linalg.norm(rel_vel)\n            \n            # 2. Numerical potential analysis\n            phi_num = p[\"phi_num\"]\n            v_esc_num = np.sqrt(max(0.0, -2.0 * phi_num))\n            is_bound_num = v = (v_esc_num - epsilon)\n            num_boundness.append(is_bound_num)\n            \n            # 3. Analytic NFW potential analysis\n            phi_nfw = get_phi_nfw(r)\n            v_esc_nfw = np.sqrt(max(0.0, -2.0 * phi_nfw))\n            is_bound_nfw = v = (v_esc_nfw - epsilon)\n            nfw_boundness.append(is_bound_nfw)\n            \n            # 4. Store difference in escape speeds\n            esc_speed_diffs.append(abs(v_esc_num - v_esc_nfw))\n\n        max_diff = 0.0\n        if esc_speed_diffs:\n            max_diff = max(esc_speed_diffs)\n            \n        all_results.append([num_boundness, nfw_boundness, round(max_diff, 6)])\n\n    # Format the final output string\n    result_strings = []\n    for res in all_results:\n        # Use str() which gives Python's True/False and list syntax, then remove spaces\n        res_str = f\"[{str(res[0])},{str(res[1])},{res[2]:.6f}]\".replace(\" \", \"\")\n        result_strings.append(res_str)\n    \n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```", "id": "3476125"}, {"introduction": "The universe is a dynamic place, and subhalos are constantly interacting with the tidal fields of their hosts. An instantaneous snapshot of a particle's energy may not tell the whole story about its long-term fate. This advanced practice [@problem_id:3476096] challenges the static binding criterion by asking you to integrate particle orbits through a tidal field, revealing the crucial difference between being instantaneously bound and being truly stable against tidal disruption.", "problem": "You are given a snapshot of tracer particles around a candidate subhalo inside a rapidly merging environment. The goal is to quantify how the instantaneous membership criterion based on specific energy compares with an orbit-integrated membership criterion over one dynamical time, and to summarize where disagreements occur in Six Dimensional (6D) phase-space. Work in the subhalo rest frame, treat the internal potential as a Plummer sphere, and approximate the external host’s influence as a constant, traceless tidal tensor.\n\nStarting from the following foundational principles, design and implement a complete program that carries out the required calculations:\n1. Newton’s Second Law: $m \\, d^2 \\boldsymbol{r} / dt^2 = \\boldsymbol{F}$, where $m$ is particle mass, $t$ is time, $\\boldsymbol{r}$ is position, and $\\boldsymbol{F}$ is total force.\n2. Gravitational potential energy in a Plummer model: $U(r) = - G M / \\sqrt{r^2 + a^2}$, where $G$ is Newton’s constant, $M$ is subhalo mass, $a$ is scale radius, and $r = \\lVert \\boldsymbol{r} \\rVert$.\n3. Acceleration in a Plummer model: $\\boldsymbol{a}_{\\mathrm{sub}}(\\boldsymbol{r}) = - G M \\boldsymbol{r} / (r^2 + a^2)^{3/2}$.\n4. External tidal acceleration modeled by a constant tidal tensor: $\\boldsymbol{a}_{\\mathrm{tide}}(\\boldsymbol{r}) = \\mathbf{T} \\, \\boldsymbol{r}$, with $\\mathbf{T}$ a symmetric tensor satisfying $\\mathrm{Tr}(\\mathbf{T}) = 0$.\n5. Instantaneous specific energy relative to the subhalo: $E = K + U = \\frac{1}{2} \\lVert \\boldsymbol{v} \\rVert^2 + U(r)$, where $\\boldsymbol{v}$ is velocity.\n6. A particle is instantaneously bound if and only if $E  0$.\n7. Orbit integration over one dynamical time $t_{\\mathrm{dyn}}$ defined at the subhalo scale radius $a$ by\n$$\nt_{\\mathrm{dyn}} = 2 \\pi \\sqrt{\\frac{a^3}{G M(a)}} \\quad \\text{with} \\quad M(r) = \\frac{M r^3}{(r^2 + a^2)^{3/2}} ,\n$$\nand $M(a)$ computed from the Plummer enclosed mass formula. During orbit integration, treat the acceleration as $\\boldsymbol{a}(\\boldsymbol{r}) = \\boldsymbol{a}_{\\mathrm{sub}}(\\boldsymbol{r}) + \\boldsymbol{a}_{\\mathrm{tide}}(\\boldsymbol{r})$.\n8. An orbit-integrated bound particle is one whose instantaneous specific energy $E(t)$ relative to the subhalo satisfies $E(t)  0$ for all $t \\in [0, t_{\\mathrm{dyn}}]$.\n\nYour program must evaluate, for each specified test case, both the instantaneous membership and the orbit-integrated membership. Then, for the set of particles that disagree (i.e., instantaneous criterion says bound while orbit-integrated says unbound, or vice versa), compute the following four summary metrics:\n1. The fraction of discrepant particles $f_{\\mathrm{disc}}$ as a decimal in $[0, 1]$.\n2. The mean radius $\\bar{r}_{\\mathrm{disc}}$ of discrepant particles in $\\mathrm{kpc}$.\n3. The mean speed $\\bar{v}_{\\mathrm{disc}}$ of discrepant particles in $\\mathrm{km/s}$.\n4. The root-mean-square of standardized 6D coordinates for discrepant particles, defined by forming the standardized vector\n$$\n\\boldsymbol{X} = \\left( \\frac{x}{a}, \\frac{y}{a}, \\frac{z}{a}, \\frac{v_x}{v_{\\mathrm{esc}}(a)}, \\frac{v_y}{v_{\\mathrm{esc}}(a)}, \\frac{v_z}{v_{\\mathrm{esc}}(a)} \\right) ,\n$$\nwhere\n$$\nv_{\\mathrm{esc}}(a) = \\sqrt{2 \\lvert U(a) \\rvert} = \\sqrt{ \\frac{2 G M}{\\sqrt{a^2 + a^2}} } = \\sqrt{ \\frac{2 G M}{\\sqrt{2} \\, a} } ,\n$$\nand then taking\n$$\n\\mathrm{RMS}_{6\\mathrm{D}} = \\sqrt{ \\frac{1}{6 N_{\\mathrm{disc}}} \\sum_{i=1}^{N_{\\mathrm{disc}}} \\left( \\sum_{j=1}^{6} X_{i,j}^2 \\right) } ,\n$$\nwith $N_{\\mathrm{disc}}$ the number of discrepant particles. If there are no discrepant particles in a test case, report $\\bar{r}_{\\mathrm{disc}} = 0$, $\\bar{v}_{\\mathrm{disc}} = 0$, and $\\mathrm{RMS}_{6\\mathrm{D}} = 0$.\n\nIntegration details and units:\n- Use a symplectic Velocity-Verlet (leapfrog) scheme consistent with Newton’s Second Law.\n- Integrate for $t_{\\mathrm{dyn}}$ with a fixed step size $\\Delta t = t_{\\mathrm{dyn}} / N_{\\mathrm{step}}$, where $N_{\\mathrm{step}} = 512$. All time is in seconds implicitly through unit consistency; numerical values do not require explicit time unit conversion since the gravitational constant $G$ is specified below in consistent mixed units.\n- Gravitational constant: $G = 4.30091 \\times 10^{-6} \\, \\mathrm{kpc} \\, (\\mathrm{km/s})^2 \\, \\mathrm{M_\\odot}^{-1}$.\n- Positions are in $\\mathrm{kpc}$, velocities in $\\mathrm{km/s}$, masses in $\\mathrm{M_\\odot}$, and the tidal tensor components in $\\mathrm{(km/s)^2/kpc^2}$.\n\nTest suite:\nFor each case, the tidal tensor is diagonal and traceless with $\\mathbf{T} = \\mathrm{diag}(-T_0, -T_0, 2 T_0)$.\n\nCase $1$ (moderate tide, happy path):\n- Subhalo mass $M = 1.0 \\times 10^9 \\, \\mathrm{M_\\odot}$, scale radius $a = 0.5 \\, \\mathrm{kpc}$, tidal amplitude $T_0 = 100.0 \\, \\mathrm{(km/s)^2/kpc^2}$.\n- Particles given as $(x, y, z)$ in $\\mathrm{kpc}$ and $(v_x, v_y, v_z)$ in $\\mathrm{km/s}$:\n  - $(0.4, 0.0, 0.0)$, $(30.0, 0.0, 0.0)$\n  - $(1.2, 0.2, 0.0)$, $(90.0, -20.0, 10.0)$\n  - $(0.1, -0.3, 0.2)$, $(10.0, 15.0, 5.0)$\n  - $(1.5, 0.0, 0.0)$, $(120.0, 0.0, 0.0)$\n  - $(0.8, 0.8, 0.0)$, $(-40.0, 30.0, 0.0)$\n\nCase $2$ (strong tide, boundary behavior):\n- Subhalo mass $M = 1.0 \\times 10^9 \\, \\mathrm{M_\\odot}$, scale radius $a = 0.5 \\, \\mathrm{kpc}$, tidal amplitude $T_0 = 2000.0 \\, \\mathrm{(km/s)^2/kpc^2}$.\n- Particles:\n  - $(1.0, 0.0, 0.0)$, $(85.0, 0.0, 0.0)$\n  - $(0.9, 0.9, 0.0)$, $(60.0, -90.0, 0.0)$\n  - $(0.2, 0.0, 0.7)$, $(20.0, 10.0, -20.0)$\n  - $(1.5, 1.5, 0.0)$, $(70.0, 70.0, 0.0)$\n  - $(0.4, -0.1, 0.0)$, $(30.0, 50.0, 0.0)$\n\nCase $3$ (no tide, baseline edge case mix):\n- Subhalo mass $M = 5.0 \\times 10^8 \\, \\mathrm{M_\\odot}$, scale radius $a = 0.3 \\, \\mathrm{kpc}$, tidal amplitude $T_0 = 0.0 \\, \\mathrm{(km/s)^2/kpc^2}$.\n- Particles:\n  - $(0.1, 0.1, 0.0)$, $(5.0, 5.0, 0.0)$\n  - $(0.5, 0.0, 0.0)$, $(80.0, 0.0, 0.0)$\n  - $(0.9, 0.0, 0.0)$, $(60.0, 60.0, 0.0)$\n  - $(1.2, 0.0, 0.0)$, $(30.0, 90.0, 0.0)$\n  - $(0.05, 0.0, 0.0)$, $(20.0, 0.0, 0.0)$\n  - $(2.0, 0.0, 0.0)$, $(150.0, 0.0, 0.0)$\n\nCase $4$ (very strong tide, rapidly merging extreme):\n- Subhalo mass $M = 1.0 \\times 10^9 \\, \\mathrm{M_\\odot}$, scale radius $a = 0.5 \\, \\mathrm{kpc}$, tidal amplitude $T_0 = 8000.0 \\, \\mathrm{(km/s)^2/kpc^2}$.\n- Particles:\n  - $(0.3, 0.0, 0.0)$, $(50.0, 0.0, 0.0)$\n  - $(0.7, 0.7, 0.7)$, $(0.0, 30.0, -10.0)$\n  - $(1.0, 0.0, 1.0)$, $(0.0, 0.0, 80.0)$\n  - $(0.5, 1.5, 0.0)$, $(40.0, 40.0, 0.0)$\n  - $(2.0, 0.0, 0.0)$, $(0.0, 200.0, 0.0)$\n\nRequired computations for each test case:\n- Compute $t_{\\mathrm{dyn}}$ using the enclosed mass formula at $r = a$.\n- For each particle, compute instantaneous $E$ and the boolean bound status from $E  0$.\n- Using leapfrog integration over $t_{\\mathrm{dyn}}$, compute whether the particle remains bound for the entire interval.\n- Identify discrepant particles where the instantaneous and orbit-integrated booleans differ.\n- Compute $f_{\\mathrm{disc}}$, $\\bar{r}_{\\mathrm{disc}}$ in $\\mathrm{kpc}$, $\\bar{v}_{\\mathrm{disc}}$ in $\\mathrm{km/s}$, and $\\mathrm{RMS}_{6\\mathrm{D}}$ as defined above.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order\n$$\n[\\; f_{\\mathrm{disc}}^{(1)}, \\bar{r}_{\\mathrm{disc}}^{(1)}, \\bar{v}_{\\mathrm{disc}}^{(1)}, \\mathrm{RMS}_{6\\mathrm{D}}^{(1)}, \\; f_{\\mathrm{disc}}^{(2)}, \\bar{r}_{\\mathrm{disc}}^{(2)}, \\bar{v}_{\\mathrm{disc}}^{(2)}, \\mathrm{RMS}_{6\\mathrm{D}}^{(2)}, \\; f_{\\mathrm{disc}}^{(3)}, \\bar{r}_{\\mathrm{disc}}^{(3)}, \\bar{v}_{\\mathrm{disc}}^{(3)}, \\mathrm{RMS}_{6\\mathrm{D}}^{(3)}, \\; f_{\\mathrm{disc}}^{(4)}, \\bar{r}_{\\mathrm{disc}}^{(4)}, \\bar{v}_{\\mathrm{disc}}^{(4)}, \\mathrm{RMS}_{6\\mathrm{D}}^{(4)} \\;] ,\n$$\nwith each quantity reported as a decimal number. Radii must be in $\\mathrm{kpc}$ and speeds in $\\mathrm{km/s}$.", "solution": "The user has provided a valid, well-posed problem in the field of computational astrophysics. The task is to compare two different criteria for determining whether a particle is gravitationally bound to a subhalo, and to quantify the disagreement between them. The problem is scientifically grounded in Newtonian dynamics and uses standard models and numerical techniques. All parameters, constants, and evaluation metrics are clearly and objectively defined.\n\nHerein, a step-by-step solution is developed based on the foundational principles provided.\n\n### 1. Physical and Dynamical Framework\n\nThe problem is set in the rest frame of a candidate subhalo. The motion of a tracer particle with position $\\boldsymbol{r}$ and velocity $\\boldsymbol{v}$ is governed by Newton's Second Law, where the total acceleration $\\boldsymbol{a}(\\boldsymbol{r})$ is the sum of the internal acceleration from the subhalo and the external acceleration from the host halo's tidal field.\n\nThe subhalo's gravitational field is modeled as a Plummer sphere with mass $M$ and scale radius $a$. The gravitational potential energy $U(r)$ of a particle at a distance $r = \\lVert \\boldsymbol{r} \\rVert$ from the subhalo center is:\n$$\nU(r) = - \\frac{G M}{\\sqrt{r^2 + a^2}}\n$$\nwhere $G$ is the gravitational constant. The corresponding acceleration is the negative gradient of the potential, $\\boldsymbol{a}_{\\mathrm{sub}}(\\boldsymbol{r}) = -\\nabla U(r)$, which is:\n$$\n\\boldsymbol{a}_{\\mathrm{sub}}(\\boldsymbol{r}) = - \\frac{G M \\boldsymbol{r}}{(r^2 + a^2)^{3/2}}\n$$\nThe external tidal field is approximated by a constant, symmetric, and traceless tidal tensor $\\mathbf{T}$, leading to a tidal acceleration:\n$$\n\\boldsymbol{a}_{\\mathrm{tide}}(\\boldsymbol{r}) = \\mathbf{T} \\boldsymbol{r}\n$$\nFor the specified test cases, $\\mathbf{T}$ is diagonal: $\\mathbf{T} = \\mathrm{diag}(-T_0, -T_0, 2T_0)$. The total acceleration governing the particle's motion is:\n$$\n\\boldsymbol{a}(\\boldsymbol{r}) = \\boldsymbol{a}_{\\mathrm{sub}}(\\boldsymbol{r}) + \\boldsymbol{a}_{\\mathrm{tide}}(\\boldsymbol{r})\n$$\n\n### 2. Membership Criteria\n\nThe core of the problem is to compare two membership criteria.\n\n**Instantaneous Membership:** A particle is considered instantaneously bound if its specific energy relative to the subhalo is negative. The specific energy $E$ is the sum of specific kinetic energy $K$ and potential energy $U$:\n$$\nE = K + U = \\frac{1}{2} \\lVert \\boldsymbol{v} \\rVert^2 - \\frac{G M}{\\sqrt{\\lVert \\boldsymbol{r} \\rVert^2 + a^2}}\n$$\nThus, a particle is instantaneously bound if $E  0$. This criterion only considers the particle's state at a single moment in time.\n\n**Orbit-Integrated Membership:** This is a more stringent criterion. A particle is considered bound if it remains bound over a characteristic timescale. The problem defines this timescale as one dynamical time, $t_{\\mathrm{dyn}}$, evaluated at the subhalo's scale radius $a$:\n$$\nt_{\\mathrm{dyn}} = 2 \\pi \\sqrt{\\frac{a^3}{G M(a)}}\n$$\nwhere $M(r)$ is the mass enclosed within radius $r$ for a Plummer sphere:\n$$\nM(r) = \\frac{M r^3}{(r^2 + a^2)^{3/2}}\n$$\nAt $r=a$, the enclosed mass is $M(a) = M a^3 / (a^2+a^2)^{3/2} = M / (2\\sqrt{2})$.\nA particle is orbit-integrated bound if its specific energy $E(t)$ relative to the subhalo remains negative for all time $t$ in the interval $[0, t_{\\mathrm{dyn}}]$.\n\nA particle is deemed \"discrepant\" if these two criteria disagree. Since a particle cannot be orbit-integrated bound if it is not instantaneously bound at $t=0$, a discrepancy only occurs when a particle is instantaneously bound ($E(0)  0$) but becomes unbound ($E(t) \\ge 0$) at some later time $t \\in (0, t_{\\mathrm{dyn}}]$.\n\n### 3. Numerical Integration Scheme\n\nTo evaluate the orbit-integrated criterion, we must integrate the particle's trajectory. The problem specifies the Velocity-Verlet (leapfrog) algorithm, a symplectic integrator well-suited for preserving energy in gravitational simulations over long periods. Given the state $(\\boldsymbol{r}(t), \\boldsymbol{v}(t))$ and the acceleration $\\boldsymbol{a}(t) = \\boldsymbol{a}(\\boldsymbol{r}(t))$, the state at time $t+\\Delta t$ is computed as follows:\n1. Update position: $\\boldsymbol{r}(t+\\Delta t) = \\boldsymbol{r}(t) + \\boldsymbol{v}(t)\\Delta t + \\frac{1}{2}\\boldsymbol{a}(t)(\\Delta t)^2$\n2. Compute the new acceleration: $\\boldsymbol{a}(t+\\Delta t) = \\boldsymbol{a}(\\boldsymbol{r}(t+\\Delta t))$\n3. Update velocity: $\\boldsymbol{v}(t+\\Delta t) = \\boldsymbol{v}(t) + \\frac{1}{2}(\\boldsymbol{a}(t) + \\boldsymbol{a}(t+\\Delta t))\\Delta t$\n\nThe integration is performed over the interval $[0, t_{\\mathrm{dyn}}]$ using $N_{\\mathrm{step}} = 512$ fixed time steps of size $\\Delta t = t_{\\mathrm{dyn}} / N_{\\mathrm{step}}$.\n\n### 4. Algorithm for Analysis\n\nFor each test case, the following procedure is implemented:\n1.  Read the subhalo parameters ($M, a, T_0$) and the initial phase-space coordinates $(\\boldsymbol{r}_0, \\boldsymbol{v}_0)$ for each particle.\n2.  Calculate the constants for the case: $t_{\\mathrm{dyn}}$, $\\Delta t$, and the escape velocity at the scale radius, $v_{\\mathrm{esc}}(a)$, needed for standardization. The escape velocity is derived from $ \\frac{1}{2}v_{\\mathrm{esc}}^2 + U(r) = 0 $:\n    $$\n    v_{\\mathrm{esc}}(a) = \\sqrt{-2 U(a)} = \\sqrt{\\frac{2 G M}{\\sqrt{a^2+a^2}}} = \\sqrt{\\frac{\\sqrt{2} G M}{a}}\n    $$\n3.  Initialize an empty list to store the initial phase-space coordinates of discrepant particles.\n4.  For each particle:\n    a. Determine its instantaneous bound status by calculating $E(0)$ and checking if $E(0)  0$.\n    b. If the particle is instantaneously unbound, it cannot be discrepant, so we proceed to the next particle.\n    c. If the particle is instantaneously bound, integrate its orbit for $N_{\\mathrm{step}}$ steps using the Velocity-Verlet method. After each step, calculate the specific energy $E(t)$. If at any step $E(t) \\ge 0$, the particle fails the orbit-integrated test. It is then flagged as discrepant, its initial coordinates are stored, and its integration is terminated.\n5.  After processing all particles, calculate the four summary metrics for the collected set of $N_{\\mathrm{disc}}$ discrepant particles:\n    a. **Fraction of discrepant particles**: $f_{\\mathrm{disc}} = N_{\\mathrm{disc}} / N_{\\mathrm{total}}$.\n    b. **Mean radius**: $\\bar{r}_{\\mathrm{disc}} = \\frac{1}{N_{\\mathrm{disc}}} \\sum_{i=1}^{N_{\\mathrm{disc}}} \\lVert \\boldsymbol{r}_{i,0} \\rVert$.\n    c. **Mean speed**: $\\bar{v}_{\\mathrm{disc}} = \\frac{1}{N_{\\mathrm{disc}}} \\sum_{i=1}^{N_{\\mathrm{disc}}} \\lVert \\boldsymbol{v}_{i,0} \\rVert$.\n    d. **Standardized 6D RMS**: First, for each discrepant particle $i$, form a standardized 6D vector $\\boldsymbol{X}_i$:\n       $$\n       \\boldsymbol{X}_i = \\left( \\frac{x_{i,0}}{a}, \\frac{y_{i,0}}{a}, \\frac{z_{i,0}}{a}, \\frac{v_{x, i,0}}{v_{\\mathrm{esc}}(a)}, \\frac{v_{y, i,0}}{v_{\\mathrm{esc}}(a)}, \\frac{v_{z, i,0}}{v_{\\mathrm{esc}}(a)} \\right)\n       $$\n       Then, compute the RMS value:\n       $$\n       \\mathrm{RMS}_{6\\mathrm{D}} = \\sqrt{ \\frac{1}{6 N_{\\mathrm{disc}}} \\sum_{i=1}^{N_{\\mathrm{disc}}} \\lVert \\boldsymbol{X}_i \\rVert^2 }\n       $$\n       If $N_{\\mathrm{disc}} = 0$, the metrics $\\bar{r}_{\\mathrm{disc}}$, $\\bar{v}_{\\mathrm{disc}}$, and $\\mathrm{RMS}_{6\\mathrm{D}}$ are all set to $0$.\n\nThis comprehensive algorithm is implemented in Python using the `NumPy` library for efficient vector and matrix operations, ensuring a correct and numerically stable solution.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Solves the problem of comparing instantaneous vs. orbit-integrated subhalo membership.\n    \"\"\"\n    # Define the gravitational constant and integration steps\n    G = 4.30091e-6  # kpc (km/s)^2 / M_sun\n    N_STEP = 512\n\n    # Define the test cases from the problem statement.\n    test_cases_data = [\n        {\n            \"M\": 1.0e9, \"a\": 0.5, \"T0\": 100.0,\n            \"particles\": [\n                (np.array([0.4, 0.0, 0.0]), np.array([30.0, 0.0, 0.0])),\n                (np.array([1.2, 0.2, 0.0]), np.array([90.0, -20.0, 10.0])),\n                (np.array([0.1, -0.3, 0.2]), np.array([10.0, 15.0, 5.0])),\n                (np.array([1.5, 0.0, 0.0]), np.array([120.0, 0.0, 0.0])),\n                (np.array([0.8, 0.8, 0.0]), np.array([-40.0, 30.0, 0.0])),\n            ]\n        },\n        {\n            \"M\": 1.0e9, \"a\": 0.5, \"T0\": 2000.0,\n            \"particles\": [\n                (np.array([1.0, 0.0, 0.0]), np.array([85.0, 0.0, 0.0])),\n                (np.array([0.9, 0.9, 0.0]), np.array([60.0, -90.0, 0.0])),\n                (np.array([0.2, 0.0, 0.7]), np.array([20.0, 10.0, -20.0])),\n                (np.array([1.5, 1.5, 0.0]), np.array([70.0, 70.0, 0.0])),\n                (np.array([0.4, -0.1, 0.0]), np.array([30.0, 50.0, 0.0])),\n            ]\n        },\n        {\n            \"M\": 5.0e8, \"a\": 0.3, \"T0\": 0.0,\n            \"particles\": [\n                (np.array([0.1, 0.1, 0.0]), np.array([5.0, 5.0, 0.0])),\n                (np.array([0.5, 0.0, 0.0]), np.array([80.0, 0.0, 0.0])),\n                (np.array([0.9, 0.0, 0.0]), np.array([60.0, 60.0, 0.0])),\n                (np.array([1.2, 0.0, 0.0]), np.array([30.0, 90.0, 0.0])),\n                (np.array([0.05, 0.0, 0.0]), np.array([20.0, 0.0, 0.0])),\n                (np.array([2.0, 0.0, 0.0]), np.array([150.0, 0.0, 0.0])),\n            ]\n        },\n        {\n            \"M\": 1.0e9, \"a\": 0.5, \"T0\": 8000.0,\n            \"particles\": [\n                (np.array([0.3, 0.0, 0.0]), np.array([50.0, 0.0, 0.0])),\n                (np.array([0.7, 0.7, 0.7]), np.array([0.0, 30.0, -10.0])),\n                (np.array([1.0, 0.0, 1.0]), np.array([0.0, 0.0, 80.0])),\n                (np.array([0.5, 1.5, 0.0]), np.array([40.0, 40.0, 0.0])),\n                (np.array([2.0, 0.0, 0.0]), np.array([0.0, 200.0, 0.0])),\n            ]\n        }\n    ]\n\n    def specific_energy(pos, vel, M, a):\n        r_norm = np.linalg.norm(pos)\n        v_norm = np.linalg.norm(vel)\n        potential_energy = -G * M / np.sqrt(r_norm**2 + a**2)\n        kinetic_energy = 0.5 * v_norm**2\n        return kinetic_energy + potential_energy\n\n    def total_acceleration(pos, M, a, T_diag):\n        r_norm = np.linalg.norm(pos)\n        r_sq = r_norm**2\n        # Plummer acceleration\n        denom = (r_sq + a**2)**1.5\n        acc_sub = -G * M * pos / denom\n        # Tidal acceleration\n        acc_tide = T_diag * pos\n        return acc_sub + acc_tide\n\n    results = []\n    for case in test_cases_data:\n        M, a, T0 = case[\"M\"], case[\"a\"], case[\"T0\"]\n        particles = case[\"particles\"]\n        T_diag = np.array([-T0, -T0, 2 * T0])\n\n        M_lt_a = M / (2 * np.sqrt(2))\n        t_dyn = 2 * np.pi * np.sqrt(a**3 / (G * M_lt_a))\n        dt = t_dyn / N_STEP\n        v_esc_a = np.sqrt(np.sqrt(2) * G * M / a)\n\n        discrepant_particles = []\n\n        for pos0, vel0 in particles:\n            E0 = specific_energy(pos0, vel0, M, a)\n            is_inst_bound = E0  0\n            \n            if not is_inst_bound:\n                continue\n\n            is_orbit_bound = True\n            \n            pos = np.copy(pos0)\n            vel = np.copy(vel0)\n            acc = total_acceleration(pos, M, a, T_diag)\n\n            for _ in range(N_STEP):\n                # Velocity-Verlet integration\n                pos = pos + vel * dt + 0.5 * acc * dt**2\n                acc_new = total_acceleration(pos, M, a, T_diag)\n                vel = vel + 0.5 * (acc + acc_new) * dt\n                acc = acc_new\n\n                E_t = specific_energy(pos, vel, M, a)\n                if E_t = 0:\n                    is_orbit_bound = False\n                    break\n            \n            if is_inst_bound and not is_orbit_bound:\n                discrepant_particles.append((pos0, vel0))\n        \n        n_total = len(particles)\n        n_disc = len(discrepant_particles)\n\n        if n_disc == 0:\n            f_disc, r_disc_mean, v_disc_mean, rms_6d = 0.0, 0.0, 0.0, 0.0\n        else:\n            f_disc = n_disc / n_total\n\n            initial_radii = [np.linalg.norm(p[0]) for p in discrepant_particles]\n            initial_speeds = [np.linalg.norm(p[1]) for p in discrepant_particles]\n\n            r_disc_mean = np.mean(initial_radii)\n            v_disc_mean = np.mean(initial_speeds)\n\n            sum_sq_std_coords = 0.0\n            for p_pos, p_vel in discrepant_particles:\n                std_pos = p_pos / a\n                std_vel = p_vel / v_esc_a\n                sum_sq_std_coords += np.sum(std_pos**2) + np.sum(std_vel**2)\n            \n            rms_6d = np.sqrt(sum_sq_std_coords / (6 * n_disc))\n\n        results.extend([f_disc, r_disc_mean, v_disc_mean, rms_6d])\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3476096"}]}