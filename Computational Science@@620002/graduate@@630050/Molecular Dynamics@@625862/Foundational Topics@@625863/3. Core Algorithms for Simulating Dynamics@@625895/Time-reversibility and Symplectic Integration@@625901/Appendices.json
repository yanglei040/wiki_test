{"hands_on_practices": [{"introduction": "The theoretical property of time-reversibility is a cornerstone of many symplectic integration schemes. This exercise provides a direct and stringent hands-on test of this property by verifying if an integrator can return a system to its initial state, bit-for-bit, after a forward and backward evolution [@problem_id:3456282]. By contrasting a time-reversible algorithm like Velocity Verlet with a non-reversible one, you will gain a deep appreciation for how algorithmic symmetry translates into remarkable numerical stability and error cancellation, even in the face of finite-precision arithmetic.", "problem": "Consider a molecular dynamics system with configuration coordinates $q \\in \\mathbb{R}^{n}$, conjugate momenta $p \\in \\mathbb{R}^{n}$, mass parameters $m \\in \\mathbb{R}^{n}$ with strictly positive components, and a potential energy $V(q)$. The equations of motion follow from Newton's Second Law and Hamiltonian mechanics, with the Hamiltonian $H(q,p) = \\sum_{i=1}^{n} \\frac{p_i^2}{2m_i} + V(q)$, and the evolution determined by $\\dot{q} = \\partial H / \\partial p$ and $\\dot{p} = - \\partial H / \\partial q$. Define the time-reversal operator $\\mathcal{R}$ that acts as $\\mathcal{R}(q,p) = (q,-p)$. An integrator with step map $\\Phi_{\\Delta t}$ is time-reversible if $\\mathcal{R} \\circ \\Phi_{\\Delta t} \\circ \\mathcal{R} = \\Phi_{-\\Delta t}$. A symplectic integrator preserves the symplectic two-form inherited from the Hamiltonian flow.\n\nYour task is to implement a complete, runnable program that performs a stringent test of exact time-reversibility using the following procedure for multiple subsystems and code paths:\n1. Starting from an initial state $(q_0,p_0)$, integrate forward with a numerically symplectic and time-reversible scheme, for a total time $T$ using a fixed time step $\\Delta t$ and a strictly positive integer number of steps $N$ such that $T = N \\Delta t$. Denote the resulting state as $(q_T, p_T)$.\n2. Apply the time-reversal operator to momenta: $(q_T, p_T) \\mapsto (q_T, -p_T)$.\n3. Integrate forward again for the same number of steps $N$ with the same scheme and time step $\\Delta t$, producing $(q_{\\mathrm{back}}, p_{\\mathrm{back}})$.\n4. Apply the time-reversal operator again to momenta: $(q_{\\mathrm{fin}}, p_{\\mathrm{fin}}) = (q_{\\mathrm{back}}, -p_{\\mathrm{back}})$.\n5. Measure bitwise equality between $(q_{\\mathrm{fin}}, p_{\\mathrm{fin}})$ and $(q_0, p_0)$, meaning exact equality of the binary representation of all $64$-bit floating-point components of $q$ and $p$ when viewed as unsigned integers. Report a boolean result for this test.\n\nAdditionally, implement a non-time-reversible baseline integrator based on Forward Euler to contrast the behavior.\n\nUse non-dimensional units (that is, all quantities are unitless scalars consistent with the numerical model).\n\nImplement two structurally different code paths for the symplectic integrator:\n- A \"scalar-loop\" path that performs updates in-place in a sequential order.\n- A \"vectorized\" path that performs updates using vectorized array operations with different arithmetic grouping.\n\nYour program must execute the above procedure for the following test suite. For each test case, output a boolean indicating whether the final $(q_{\\mathrm{fin}}, p_{\\mathrm{fin}})$ is bitwise equal to the initial $(q_0, p_0)$:\n\n- Test Case 1 (happy path, dyadic step): One-dimensional harmonic oscillator with $V(q) = \\frac{1}{2} k q^2$, $k=1$, mass $m=1$, initial $q_0 = 1/2$, $p_0 = 1/4$, time step $\\Delta t = 1/8$, total time $T = 8$, use the symplectic time-reversible scheme with the scalar-loop path.\n\n- Test Case 2 (alternate code path): Same system and parameters as Test Case 1, but use the vectorized path.\n\n- Test Case 3 (non-dyadic step): One-dimensional harmonic oscillator with $k=1$, $m=1$, initial $q_0 = 1/2$, $p_0 = 1/4$, time step $\\Delta t = 0.1$, total time $T = 1.0$, use the symplectic time-reversible scheme with the scalar-loop path.\n\n- Test Case 4 (boundary, zero force): Two-dimensional free particle ($V(q) \\equiv 0$), $m=1$ for each degree of freedom, initial $q_0 = [1/4, -1/8]$, $p_0 = [1/16, 1/32]$, time step $\\Delta t = 1/16$, total time $T = 1$, use the symplectic time-reversible scheme with the vectorized path.\n\n- Test Case 5 (nonlinear interaction): Two particles in two dimensions interacting via the Lennard–Jones potential $V(r) = 4 \\varepsilon \\left[ (\\sigma/r)^{12} - (\\sigma/r)^6 \\right]$ with $\\varepsilon = 1$, $\\sigma = 1$, masses $m=1$ for both particles, initial positions $q_{0,1} = [1.5, 0.0]$, $q_{0,2} = [-1.5, 0.0]$, initial momenta $p_{0,1} = [0.0, 0.05]$, $p_{0,2} = [0.0, -0.05]$, time step $\\Delta t = 0.001$, total time $T = 0.01$, use the symplectic time-reversible scheme with the vectorized path.\n\n- Test Case 6 (non-time-reversible baseline): One-dimensional harmonic oscillator with $k=1$, $m=1$, initial $q_0 = 1/2$, $p_0 = 1/4$, time step $\\Delta t = 1/8$, total time $T = 8$, use the Forward Euler baseline integrator with scalar-loop path.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4,result5,result6]\"), where each entry is either \"True\" or \"False\" corresponding to the bitwise equality test for each case, in the order listed above. Angles are not involved; no unit conversions are needed beyond the stated non-dimensionalization.", "solution": "The solution implements the specified time-reversibility test, which involves a forward integration, a momentum reversal, a second forward integration, and a final momentum reversal. For a perfectly time-reversible algorithm, this sequence should restore the initial state bit-for-bit. The core of the implementation lies in constructing two distinct integrators: a time-reversible Velocity Verlet scheme and a non-reversible Forward Euler scheme. The Velocity Verlet integrator is implemented using the symmetric 'kick-drift-kick' update sequence, ensuring its time-reversal symmetry is robust even with floating-point arithmetic. The Forward Euler integrator uses a simple, non-symmetric update, which is expected to fail the bitwise test due to the accumulation of rounding errors in a non-symmetric fashion. The program defines force functions for different potentials (harmonic, free particle, Lennard-Jones) and systematically runs each test case, performing a final bitwise comparison of the initial and final states by reinterpreting the floating-point arrays as unsigned integers.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef are_bitwise_equal(q1, p1, q2, p2):\n    \"\"\"\n    Performs a bitwise comparison of two states (q, p).\n    Each state is composed of numpy arrays q and p of dtype float64.\n    \"\"\"\n    s1 = np.concatenate((np.ravel(q1), np.ravel(p1)))\n    s2 = np.concatenate((np.ravel(q2), np.ravel(p2)))\n\n    if s1.dtype != np.float64 or s2.dtype != np.float64:\n        raise TypeError(\"Inputs must be float64 numpy arrays for bitwise comparison.\")\n\n    if s1.shape != s2.shape:\n        return False\n\n    # View arrays as 64-bit unsigned integers and check for equality.\n    return np.all(s1.view(np.uint64) == s2.view(np.uint64))\n\n# --- Force Functions ---\n\ndef force_harmonic_oscillator(q, k=1.0):\n    \"\"\"Force for a 1D harmonic oscillator: F = -kq.\"\"\"\n    return -k * q\n\ndef force_free_particle(q):\n    \"\"\"Force for a free particle: F = 0.\"\"\"\n    return np.zeros_like(q)\n\ndef force_lennard_jones(q, epsilon=1.0, sigma=1.0):\n    \"\"\"Force for two particles interacting via Lennard-Jones potential.\"\"\"\n    q1 = q[0:2]\n    q2 = q[2:4]\n    r_vec = q1 - q2\n    r_sq = np.dot(r_vec, r_vec)\n    \n    r_minus2 = 1.0 / r_sq\n    sigma_sq = sigma * sigma\n    \n    sig2_r_minus2 = sigma_sq * r_minus2\n    sig6_r_minus6 = sig2_r_minus2 * sig2_r_minus2 * sig2_r_minus2\n    sig12_r_minus12 = sig6_r_minus6 * sig6_r_minus6\n\n    # F = (24*epsilon/r^2) * [2*(sigma/r)^12 - (sigma/r)^6] * r_vec\n    force_scalar_part = (24.0 * epsilon * r_minus2) * (2.0 * sig12_r_minus12 - sig6_r_minus6)\n    \n    force_on_1 = force_scalar_part * r_vec\n    force_on_2 = -force_on_1\n    \n    return np.concatenate((force_on_1, force_on_2))\n\n# --- Integrator Implementations ---\n\nclass VelocityVerletScalar:\n    def __init__(self, force_func, m):\n        self.force_func = force_func\n        self.m = m\n\n    def step(self, q, p, dt):\n        \"\"\"In-place update using sequential scalar loops.\"\"\"\n        force = self.force_func(q)\n        for i in range(len(q)):\n            p[i] += force[i] * 0.5 * dt\n        \n        for i in range(len(q)):\n            q[i] += (p[i] / self.m[i]) * dt\n        \n        force = self.force_func(q)\n        for i in range(len(q)):\n            p[i] += force[i] * 0.5 * dt\n        \n        return q, p\n\nclass VelocityVerletVectorized:\n    def __init__(self, force_func, m):\n        self.force_func = force_func\n        self.m = m\n\n    def step(self, q, p, dt):\n        \"\"\"In-place update using vectorized numpy operations.\"\"\"\n        p += self.force_func(q) * 0.5 * dt\n        q += (p / self.m) * dt\n        p += self.force_func(q) * 0.5 * dt\n        return q, p\n\nclass ForwardEulerScalar:\n    def __init__(self, force_func, m):\n        self.force_func = force_func\n        self.m = m\n\n    def step(self, q, p, dt):\n        \"\"\"Out-of-place update using scalar loops.\"\"\"\n        force = self.force_func(q)\n        q_next = np.empty_like(q)\n        p_next = np.empty_like(p)\n        for i in range(len(q)):\n            q_next[i] = q[i] + (p[i] / self.m[i]) * dt\n            p_next[i] = p[i] + force[i] * dt\n        return q_next, p_next\n\n# --- Simulation and Test Logic ---\n\ndef test_reversibility(integrator_class, force_func, q0_list, p0_list, m_val, T, dt, force_params):\n    \"\"\"\n    Executes the time-reversibility test for a given configuration.\n    \"\"\"\n    # Bind parameters to the force function\n    bound_force_func = lambda q: force_func(q, **force_params)\n\n    # Prepare initial state as float64 numpy arrays\n    q0 = np.array(q0_list, dtype=np.float64)\n    p0 = np.array(p0_list, dtype=np.float64)\n    m = np.full_like(q0, m_val, dtype=np.float64)\n\n    # Calculate number of steps\n    num_steps = int(round(T / dt))\n\n    integrator = integrator_class(bound_force_func, m)\n\n    # --- Step 1: Forward integration ---\n    q_fwd, p_fwd = q0.copy(), p0.copy()\n    for _ in range(num_steps):\n        q_fwd, p_fwd = integrator.step(q_fwd, p_fwd, dt)\n    \n    # --- Step 2: Apply time-reversal to momenta ---\n    p_fwd = -p_fwd\n\n    # --- Step 3: Integrate forward again (\"backward\" evolution) ---\n    q_back, p_back = q_fwd.copy(), p_fwd.copy()\n    for _ in range(num_steps):\n        q_back, p_back = integrator.step(q_back, p_back, dt)\n    \n    # --- Step 4: Apply time-reversal again ---\n    q_fin, p_fin = q_back.copy(), -p_back\n\n    # --- Step 5: Measure bitwise equality ---\n    return are_bitwise_equal(q0, p0, q_fin, p_fin)\n\ndef solve():\n    test_cases = [\n        # Test Case 1 (happy path, dyadic step)\n        {\"integrator_class\": VelocityVerletScalar, \"force_func\": force_harmonic_oscillator, \"force_params\": {\"k\": 1.0},\n         \"q0_list\": [1/2], \"p0_list\": [1/4], \"m_val\": 1.0, \"T\": 8.0, \"dt\": 1/8},\n        # Test Case 2 (alternate code path)\n        {\"integrator_class\": VelocityVerletVectorized, \"force_func\": force_harmonic_oscillator, \"force_params\": {\"k\": 1.0},\n         \"q0_list\": [1/2], \"p0_list\": [1/4], \"m_val\": 1.0, \"T\": 8.0, \"dt\": 1/8},\n        # Test Case 3 (non-dyadic step)\n        {\"integrator_class\": VelocityVerletScalar, \"force_func\": force_harmonic_oscillator, \"force_params\": {\"k\": 1.0},\n         \"q0_list\": [1/2], \"p0_list\": [1/4], \"m_val\": 1.0, \"T\": 1.0, \"dt\": 0.1},\n        # Test Case 4 (boundary, zero force)\n        {\"integrator_class\": VelocityVerletVectorized, \"force_func\": force_free_particle, \"force_params\": {},\n         \"q0_list\": [1/4, -1/8], \"p0_list\": [1/16, 1/32], \"m_val\": 1.0, \"T\": 1.0, \"dt\": 1/16},\n        # Test Case 5 (nonlinear interaction)\n        {\"integrator_class\": VelocityVerletVectorized, \"force_func\": force_lennard_jones, \"force_params\": {\"epsilon\": 1.0, \"sigma\": 1.0},\n         \"q0_list\": [1.5, 0.0, -1.5, 0.0], \"p0_list\": [0.0, 0.05, 0.0, -0.05], \"m_val\": 1.0, \"T\": 0.01, \"dt\": 0.001},\n        # Test Case 6 (non-time-reversible baseline)\n        {\"integrator_class\": ForwardEulerScalar, \"force_func\": force_harmonic_oscillator, \"force_params\": {\"k\": 1.0},\n         \"q0_list\": [1/2], \"p0_list\": [1/4], \"m_val\": 1.0, \"T\": 8.0, \"dt\": 1/8},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = test_reversibility(\n            integrator_class=case[\"integrator_class\"],\n            force_func=case[\"force_func\"],\n            q0_list=case[\"q0_list\"],\n            p0_list=case[\"p0_list\"],\n            m_val=case[\"m_val\"],\n            T=case[\"T\"],\n            dt=case[\"dt\"],\n            force_params=case[\"force_params\"]\n        )\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3456282"}, {"introduction": "While verifying abstract properties is crucial, the true value of symplectic integration is revealed in long-term simulations of complex, chaotic systems. This practice immerses you in the historic Fermi-Pasta-Ulam-Tsingou (FPUT) problem, a classic testbed for numerical integrators [@problem_id:3456295]. By comparing the performance of the symplectic Velocity-Verlet method against the high-order but non-symplectic Runge-Kutta scheme, you will quantify the profound differences in energy conservation and the preservation of subtle, long-term dynamical features, demonstrating why preserving geometric structure is paramount for physical fidelity.", "problem": "Consider a one-dimensional Fermi–Pasta–Ulam–Tsingou chain of $N$ identical particles with periodic boundary conditions and unit particle mass. Let the positions and momenta be $(q_i,p_i)$ for $i=0,1,\\dots,N-1$ arranged on a ring. The system evolves according to Hamiltonian dynamics with the $\\beta$-Fermi–Pasta–Ulam–Tsingou Hamiltonian\n$$\nH(q,p) \\equiv \\sum_{i=0}^{N-1} \\frac{1}{2} p_i^2 + \\sum_{i=0}^{N-1} \\left( \\frac{1}{2} \\left(q_{i+1} - q_i\\right)^2 + \\frac{\\beta}{4} \\left(q_{i+1} - q_i\\right)^4 \\right),\n$$\nwhere indices are understood modulo $N$ (periodicity), and $\\beta > 0$ controls the nonlinearity strength. The equations of motion are given by Newton's second law in Hamiltonian form,\n$$\n\\dot{q}_i = p_i, \\quad \\dot{p}_i = F_i(q),\n$$\nwhere the force $F_i(q)$ is obtained from $-\\partial H / \\partial q_i$.\n\nYou must implement and compare two numerical integrators for this Hamiltonian system over a long time horizon:\n- A time-reversible symplectic integrator: velocity–Verlet,\n- A non-symplectic explicit integrator: classical fourth-order Runge–Kutta.\n\nFor each integrator and each test case, you must compute the following diagnostic metrics over the time interval $[0,T]$ with a fixed time step $dt$ and $n=\\lfloor T/dt \\rfloor$ total steps:\n\n1. Maximum absolute relative energy drift:\n$$\nD_{\\mathrm{energy}} \\equiv \\max_{0 \\le k \\le n} \\left| \\frac{H\\left(q^{(k)},p^{(k)}\\right) - H\\left(q^{(0)},p^{(0)}\\right)}{H\\left(q^{(0)},p^{(0)}\\right)} \\right|,\n$$\nwhere $(q^{(k)},p^{(k)})$ denotes the state after $k$ steps.\n\n2. Time–reversibility error: perform a forward integration from $t=0$ to $t=T$ using time step $dt$ to produce $(q^{(n)},p^{(n)})$, then reverse the momenta to $(q^{(n)},-p^{(n)})$ and integrate backward using the same number of steps with negative time step $-dt$ to obtain $(\\tilde{q}^{(0)},\\tilde{p}^{(0)})$. Define\n$$\nD_{\\mathrm{rev}} \\equiv \\sqrt{ \\frac{1}{N} \\sum_{i=0}^{N-1} \\left( \\left[\\tilde{q}^{(0)}_i - q^{(0)}_i\\right]^2 + \\left[\\tilde{p}^{(0)}_i - p^{(0)}_i\\right]^2 \\right) }.\n$$\n\n3. Metastability leakage based on linear normal modes: define the Discrete Fourier Transform (DFT) of $q$ and $p$ with unitary normalization $Q_k = \\frac{1}{\\sqrt{N}} \\sum_{j=0}^{N-1} q_j e^{-2\\pi i k j / N}$ and $P_k = \\frac{1}{\\sqrt{N}} \\sum_{j=0}^{N-1} p_j e^{-2\\pi i k j / N}$ for $k=0,1,\\dots,N-1$. For the linearized chain, the mode frequencies are\n$$\n\\omega_k = \\sqrt{2\\left(1 - \\cos\\left(\\frac{2\\pi k}{N}\\right)\\right)}, \\quad k=0,1,\\dots,N-1.\n$$\nDefine the linearized modal energy at time step $k_{\\mathrm{step}}$ for wavenumber $m$ as\n$$\n\\mathcal{E}_m(k_{\\mathrm{step}}) \\equiv \\frac{1}{2} \\left|P_m\\right|^2 + \\frac{1}{2} \\omega_m^2 \\left|Q_m\\right|^2,\n$$\nand the set of initially excited low-frequency conjugate modes $\\mathcal{S} \\equiv \\{1, N-1\\}$. The instantaneous leakage at step $k_{\\mathrm{step}}$ is\n$$\nL(k_{\\mathrm{step}}) \\equiv 1 - \\frac{\\sum_{m \\in \\mathcal{S}} \\mathcal{E}_m(k_{\\mathrm{step}})}{\\sum_{m=1}^{N-1} \\mathcal{E}_m(k_{\\mathrm{step}})}.\n$$\nThe metastability leakage metric is the time-average\n$$\nD_{\\mathrm{leak}} \\equiv \\frac{1}{n} \\sum_{k_{\\mathrm{step}}=1}^{n} L(k_{\\mathrm{step}}).\n$$\n\nInitialization: use the low-amplitude single-mode displacement\n$$\nq_i(0) = A \\cos\\left(\\frac{2\\pi i}{N}\\right), \\quad p_i(0) = 0,\n$$\nwith amplitude $A > 0$.\n\nFor each test case, compute the triple of differences between the two integrators' diagnostics,\n$$\n\\left[\\, D_{\\mathrm{energy}}^{\\mathrm{RK4}} - D_{\\mathrm{energy}}^{\\mathrm{VV}}, \\quad D_{\\mathrm{rev}}^{\\mathrm{RK4}} - D_{\\mathrm{rev}}^{\\mathrm{VV}}, \\quad D_{\\mathrm{leak}}^{\\mathrm{RK4}} - D_{\\mathrm{leak}}^{\\mathrm{VV}} \\,\\right],\n$$\nwhere superscripts indicate the integrator method (Runge–Kutta of order four versus velocity–Verlet). All quantities are dimensionless; report numerical values as floats.\n\nYour program must produce a single line of output containing the results as a comma-separated list of lists enclosed in square brackets, for example, $\\left[ [x_1,y_1,z_1], [x_2,y_2,z_2], [x_3,y_3,z_3] \\right]$, where each inner list corresponds to one test case in the order listed below.\n\nUse the following test suite, which covers a typical scenario, a small time step case, and a stronger nonlinearity with larger time step:\n- Case 1 (typical): $N=8$, $\\beta=0.25$, $A=0.1$, $T=100$, $dt=0.02$.\n- Case 2 (small step): $N=8$, $\\beta=0.25$, $A=0.1$, $T=100$, $dt=0.005$.\n- Case 3 (stronger nonlinearity): $N=8$, $\\beta=1.0$, $A=0.2$, $T=100$, $dt=0.05$.\n\nYour final output must be a single line containing the three computed triples in the exact format $\\left[\\,[\\cdot,\\cdot,\\cdot],\\,[\\cdot,\\cdot,\\cdot],\\,[\\cdot,\\cdot,\\cdot]\\,\\right]$.", "solution": "The solution involves implementing both the Velocity-Verlet (VV) and the classical fourth-order Runge-Kutta (RK4) integrators to simulate the Fermi-Pasta-Ulam-Tsingou (FPUT) chain. The core logic calculates the force on each particle, accounting for periodic boundary conditions using array-rolling operations. For each integrator, a simulation loop runs for the specified time, and diagnostic metrics are computed. The energy drift is calculated by comparing the Hamiltonian at each step to its initial value. The time-reversibility error is found by performing a forward-then-backward integration and measuring the final deviation from the initial state. The metastability leakage is computed by transforming the state to linear normal mode coordinates via a Fast Fourier Transform (FFT) at each step and tracking the energy distribution. The final output is the difference in these three diagnostics between the non-symplectic RK4 and the symplectic VV methods, highlighting the superior conservation properties of the latter.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_force(q, beta):\n    \"\"\"Calculates the force on each particle in the FPUT chain.\"\"\"\n    dq_plus = np.roll(q, -1) - q\n    dq_minus = q - np.roll(q, 1)\n    # The term (dq + beta * dq^3) represents the force from a spring.\n    # The net force is the difference between the pull from the right and the pull from the left.\n    force = (dq_plus + beta * dq_plus**3) - (dq_minus + beta * dq_minus**3)\n    return force\n\ndef calculate_hamiltonian(q, p, beta):\n    \"\"\"Calculates the total energy (Hamiltonian) of the FPUT chain.\"\"\"\n    kinetic_energy = 0.5 * np.sum(p**2)\n    dq = np.roll(q, -1) - q\n    potential_energy = np.sum(0.5 * dq**2 + (beta / 4.0) * dq**4)\n    return kinetic_energy + potential_energy\n\ndef velocity_verlet_step(q, p, dt, beta):\n    \"\"\"Performs a single step of the velocity-Verlet integrator.\"\"\"\n    force_t = calculate_force(q, beta)\n    p_half = p + 0.5 * dt * force_t\n    q_new = q + dt * p_half\n    force_t_plus_dt = calculate_force(q_new, beta)\n    p_new = p_half + 0.5 * dt * force_t_plus_dt\n    return q_new, p_new\n\ndef rk4_step(q, p, dt, beta):\n    \"\"\"Performs a single step of the classical fourth-order Runge-Kutta integrator.\"\"\"\n    # State vector y = (q, p), ODE is y_dot = f(y) = (p, F(q))\n    # k1\n    k1_q = p\n    k1_p = calculate_force(q, beta)\n    # k2\n    q2 = q + 0.5 * dt * k1_q\n    p2 = p + 0.5 * dt * k1_p\n    k2_q = p2\n    k2_p = calculate_force(q2, beta)\n    # k3\n    q3 = q + 0.5 * dt * k2_q\n    p3 = p + 0.5 * dt * k2_p\n    k3_q = p3\n    k3_p = calculate_force(q3, beta)\n    # k4\n    q4 = q + dt * k3_q\n    p4 = p + dt * k3_p\n    k4_q = p4\n    k4_p = calculate_force(q4, beta)\n    \n    q_new = q + (dt / 6.0) * (k1_q + 2.0 * k2_q + 2.0 * k3_q + k4_q)\n    p_new = p + (dt / 6.0) * (k1_p + 2.0 * k2_p + 2.0 * k3_p + k4_p)\n    return q_new, p_new\n\ndef compute_diagnostics(integrator_name, q0, p0, N, beta, T, dt):\n    \"\"\"Computes the three diagnostic metrics for a given integrator.\"\"\"\n    if integrator_name == 'vv':\n        step_func = velocity_verlet_step\n    elif integrator_name == 'rk4':\n        step_func = rk4_step\n    else:\n        raise ValueError(\"Unknown integrator\")\n\n    n_steps = int(np.floor(T / dt))\n\n    # --- Forward integration for D_energy and D_leak ---\n    q_curr, p_curr = q0.copy(), p0.copy()\n    \n    # Store final state for reversibility test\n    q_final, p_final = None, None\n    \n    # D_energy calculation\n    H0 = calculate_hamiltonian(q0, p0, beta)\n    if H0 == 0: H0 = 1.0 # Avoid division by zero, though unlikely\n    max_energy_drift = 0.0\n\n    # D_leak calculation\n    k_modes = np.arange(N)\n    omega_sq = 2.0 * (1.0 - np.cos(2.0 * np.pi * k_modes / N))\n    total_leakage = 0.0\n\n    for k in range(n_steps):\n        q_curr, p_curr = step_func(q_curr, p_curr, dt, beta)\n        \n        # Energy drift\n        Hk = calculate_hamiltonian(q_curr, p_curr, beta)\n        drift = np.abs((Hk - H0) / H0)\n        if drift > max_energy_drift:\n            max_energy_drift = drift\n\n        # Leakage\n        Q_k = np.fft.fft(q_curr, norm='ortho')\n        P_k = np.fft.fft(p_curr, norm='ortho')\n        modal_energies = 0.5 * (np.abs(P_k)**2 + omega_sq * np.abs(Q_k)**2)\n        total_linear_energy = np.sum(modal_energies[1:])\n        energy_in_S = modal_energies[1] + modal_energies[N-1]\n        \n        if total_linear_energy > 1e-15:\n            instantaneous_leakage = 1.0 - (energy_in_S / total_linear_energy)\n        else:\n            instantaneous_leakage = 0.0\n        total_leakage += instantaneous_leakage\n    \n    q_final, p_final = q_curr, p_curr\n    D_energy = max_energy_drift\n    D_leak = total_leakage / n_steps if n_steps > 0 else 0.0\n\n    # --- Backward integration for D_rev ---\n    q_rev, p_rev = q_final.copy(), -p_final.copy() # Reverse momenta\n    \n    for _ in range(n_steps):\n        q_rev, p_rev = step_func(q_rev, p_rev, -dt, beta)\n\n    # Reversibility error\n    q_diff_sq = np.sum((q_rev - q0)**2)\n    p_diff_sq = np.sum((p_rev - p0)**2)\n    D_rev = np.sqrt((q_diff_sq + p_diff_sq) / N)\n\n    return D_energy, D_rev, D_leak\n\ndef solve():\n    test_cases = [\n        # Case 1 (typical)\n        {'N': 8, 'beta': 0.25, 'A': 0.1, 'T': 100, 'dt': 0.02},\n        # Case 2 (small step)\n        {'N': 8, 'beta': 0.25, 'A': 0.1, 'T': 100, 'dt': 0.005},\n        # Case 3 (stronger nonlinearity)\n        {'N': 8, 'beta': 1.0, 'A': 0.2, 'T': 100, 'dt': 0.05}\n    ]\n\n    all_results = []\n    for case in test_cases:\n        N, beta, A, T, dt = case['N'], case['beta'], case['A'], case['T'], case['dt']\n        \n        # Initial conditions\n        i = np.arange(N)\n        q0 = A * np.cos(2.0 * np.pi * i / N)\n        p0 = np.zeros(N)\n\n        # Compute diagnostics for both integrators\n        d_energy_vv, d_rev_vv, d_leak_vv = compute_diagnostics(\n            'vv', q0, p0, N, beta, T, dt)\n        \n        d_energy_rk4, d_rev_rk4, d_leak_rk4 = compute_diagnostics(\n            'rk4', q0, p0, N, beta, T, dt)\n\n        # Calculate differences RK4 - VV\n        diffs = [\n            d_energy_rk4 - d_energy_vv,\n            d_rev_rk4 - d_rev_vv,\n            d_leak_rk4 - d_leak_vv\n        ]\n        all_results.append(diffs)\n\n    # Final print statement in the exact required format.\n    # The default str() representation of a list of lists matches the required format.\n    print(str(all_results))\n\nsolve()\n```", "id": "3456295"}, {"introduction": "Having established the importance of geometric properties, the next step is to learn how to construct more powerful integrators that retain them. This practice introduces the elegant and powerful technique of operator splitting and composition, specifically the Yoshida method, to build a fourth-order symplectic integrator from a standard second-order one [@problem_id:3456317]. Implementing and analyzing this higher-order method will allow you to explore the trade-offs between computational cost and accuracy, and to measure the reduction in systematic sampling bias, a key consideration for accurate statistical mechanics simulations.", "problem": "Implement, analyze, and compare time-reversibility and microcanonical sampling properties for a class of symplectic molecular dynamics integrators constructed by composition. Consider a one-dimensional system of $N$ independent harmonic particles with Hamiltonian\n$$H(q,p) \\equiv K(p) + V(q) = \\sum_{i=1}^{N} \\frac{p_i^2}{2} + \\frac{k}{2}\\sum_{i=1}^{N} q_i^2,$$\nwhere $q \\in \\mathbb{R}^N$ are positions, $p \\in \\mathbb{R}^N$ are momenta, and $k > 0$ is a stiffness constant. Work in reduced units where mass, length, and energy are dimensionless and set to unity, so all reported quantities are dimensionless numbers.\n\nStarting from Hamilton's equations and the concept of operator splitting, define a symmetric second-order symplectic map $S(h)$ obtained by Strang splitting of the exact flow generated by $H$, i.e., a composition of exact subflows for $K$ and $V$ over a time step $h$. Then, construct a fourth-order symplectic integrator via Yoshida composition:\n$$S_4(h) = S(a h)\\, S(b h)\\, S(a h),$$\nwhere $a$ and $b$ are real constants to be chosen so that $S_4(h)$ attains fourth-order accuracy while remaining symmetric and symplectic.\n\nYour program must:\n- Implement $S(h)$ as the standard velocity-Verlet (leapfrog) update that corresponds to Strang splitting for this separable Hamiltonian.\n- Derive and use the Yoshida coefficients $a$ and $b$ to implement $S_4(h)$ as the triple composition of $S(h)$ with substeps $a h$, $b h$, and $a h$.\n- For each test case described below, initialize the system at fixed total energy $E$ with initial conditions\n  $q_i(0) = 0$ for all $i$, and $p_i(0) = \\sqrt{\\frac{2E}{N}}$ for all $i$,\n  which ensures $K(0) = E$ and $V(0) = 0$.\n- For each integrator ($S$ and $S_4$) and test case:\n  1. Compute a reversibility error as follows. Evolve forward for $M_{\\mathrm{rev}}$ steps with time step $h$, then negate the momenta and evolve forward again for $M_{\\mathrm{rev}}$ steps with the same method and $h$. Denote the final state by $(q^{\\ast},p^{\\ast})$ and the initial state by $(q^{(0)},p^{(0)})$. Report the reversibility error\n     $$\\varepsilon \\equiv \\max\\big(\\lVert q^{\\ast} - q^{(0)}\\rVert_{\\infty},\\, \\lVert p^{\\ast} + p^{(0)}\\rVert_{\\infty}\\big).$$\n  2. Estimate the microcanonical sampling bias in the potential-energy fraction by running a long trajectory of $M_{\\mathrm{samp}}$ steps and computing the time average of the potential energy $\\langle V \\rangle$. For the exact dynamics of this quadratic Hamiltonian, the microcanonical fraction satisfies $\\langle V \\rangle / E = 1/2$. Define the bias\n     $$B \\equiv \\left|\\frac{\\langle V \\rangle}{E} - \\frac{1}{2}\\right|.$$\n  Use uniform sampling every step along the trajectory after initializing at the specified $(q(0),p(0))$.\n\nUse the following test suite. In all cases, use the same time step $h$ for both $S$ and $S_4$.\n- Test case $1$: $N = 1$, $k = 1.0$, $E = 1.0$, $h = 0.3$, $M_{\\mathrm{samp}} = 20000$, $M_{\\mathrm{rev}} = 400$.\n- Test case $2$: $N = 3$, $k = 0.5$, $E = 2.0$, $h = 1.0$, $M_{\\mathrm{samp}} = 20000$, $M_{\\mathrm{rev}} = 400$.\n- Test case $3$: $N = 5$, $k = 1.0$, $E = 5.0$, $h = 1.1$, $M_{\\mathrm{samp}} = 20000$, $M_{\\mathrm{rev}} = 400$.\n\nNotes and requirements:\n- The stability condition for the velocity-Verlet map applied to a harmonic mode of frequency $\\omega$ is $h \\omega  2$. For the Yoshida composition $S_4(h)$ with coefficients $a$ and $b$, ensure that $\\max(|a|,|b|) h \\omega  2$ for all tested $\\omega = \\sqrt{k}$, which is satisfied by the test suite specified above.\n- Express all outputs as dimensionless floating-point numbers.\n- Final output format: Your program should produce a single line of output containing the results as a list of lists, one per test case, where each inner list has the four floats $[\\varepsilon_S,\\varepsilon_{S_4},B_S,B_{S_4}]$ in that order. For example, the printed line must look like\n  $$\\big[\\,[\\varepsilon_S^{(1)},\\varepsilon_{S_4}^{(1)},B_S^{(1)},B_{S_4}^{(1)}],\\,[\\varepsilon_S^{(2)},\\varepsilon_{S_4}^{(2)},B_S^{(2)},B_{S_4}^{(2)}],\\,[\\varepsilon_S^{(3)},\\varepsilon_{S_4}^{(3)},B_S^{(3)},B_{S_4}^{(3)}]\\,\\big].$$\nThe single printed line must be exactly this bracketed list structure with numeric entries.", "solution": "The solution is based on the principle of operator splitting and composition. First, a second-order symmetric integrator, $S(h)$, is implemented based on Strang splitting. This corresponds to the standard velocity-Verlet algorithm, where a time step consists of a half-step momentum 'kick', a full-step position 'drift', and a final half-step 'kick'. Next, a fourth-order integrator, $S_4(h)$, is constructed by composing the second-order integrator three times: $S_4(h) = S(ah)S(bh)S(ah)$. The required Yoshida coefficients are derived from the conditions $2a+b=1$ and $2a^3+b^3=0$, yielding $a = 1/(2 - 2^{1/3})$ and $b = -2^{1/3}/(2 - 2^{1/3})$. The program then evaluates both integrators by computing two metrics: the time-reversibility error $\\varepsilon$, which tests for perfect round-trip accuracy, and the microcanonical sampling bias $B$, which measures the deviation of the time-averaged potential energy from the exact theoretical value of $E/2$. The implementation iterates through the specified test cases, running simulations with both integrators to generate and compare these four diagnostic values.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Global constants for Yoshida coefficients\nYOSHIDA_A = 1.0 / (2.0 - 2.0**(1.0/3.0))\nYOSHIDA_B = 1.0 - 2.0 * YOSHIDA_A\n\ndef step_S(q, p, h, k):\n    \"\"\"\n    Performs a single step of the second-order velocity-Verlet integrator (S(h)).\n    \n    Args:\n        q (np.ndarray): Current positions.\n        p (np.ndarray): Current momenta.\n        h (float): Time step.\n        k (float): Stiffness constant.\n        \n    Returns:\n        tuple[np.ndarray, np.ndarray]: Updated positions and momenta.\n    \"\"\"\n    p_half = p - 0.5 * h * k * q\n    q_new = q + h * p_half\n    p_new = p_half - 0.5 * h * k * q_new\n    return q_new, p_new\n\ndef step_S4(q, p, h, k):\n    \"\"\"\n    Performs a single step of the fourth-order Yoshida integrator (S4(h)).\n    \n    Args:\n        q (np.ndarray): Current positions.\n        p (np.ndarray): Current momenta.\n        h (float): Time step.\n        k (float): Stiffness constant.\n        \n    Returns:\n        tuple[np.ndarray, np.ndarray]: Updated positions and momenta.\n    \"\"\"\n    q1, p1 = step_S(q, p, YOSHIDA_A * h, k)\n    q2, p2 = step_S(q1, p1, YOSHIDA_B * h, k)\n    q3, p3 = step_S(q2, p2, YOSHIDA_A * h, k)\n    return q3, p3\n\ndef compute_reversibility_error(integrator_type, q0, p0, h, k, M_rev):\n    \"\"\"\n    Computes the time-reversibility error for a given integrator.\n    \"\"\"\n    q, p = q0.copy(), p0.copy()\n    \n    step_func = step_S if integrator_type == 'S' else step_S4\n\n    # Evolve forward for M_rev steps\n    for _ in range(M_rev):\n        q, p = step_func(q, p, h, k)\n\n    # Negate momenta\n    p = -p\n\n    # Evolve forward again for M_rev steps\n    for _ in range(M_rev):\n        q, p = step_func(q, p, h, k)\n        \n    # Final state is (q*, p*) in the problem statement\n    err_q = np.linalg.norm(q - q0, ord=np.inf)\n    err_p = np.linalg.norm(p + p0, ord=np.inf)\n    \n    return max(err_q, err_p)\n\ndef compute_sampling_bias(integrator_type, q0, p0, h, k, E, M_samp):\n    \"\"\"\n    Computes the microcanonical sampling bias in potential energy.\n    \"\"\"\n    q, p = q0.copy(), p0.copy()\n    total_V = 0.0\n    \n    step_func = step_S if integrator_type == 'S' else step_S4\n\n    for _ in range(M_samp):\n        q, p = step_func(q, p, h, k)\n        potential_energy = 0.5 * k * np.sum(q**2)\n        total_V += potential_energy\n        \n    avg_V = total_V / M_samp\n    bias = abs(avg_V / E - 0.5)\n    \n    return bias\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # (N, k, E, h, M_samp, M_rev)\n        (1, 1.0, 1.0, 0.3, 20000, 400),\n        (3, 0.5, 2.0, 1.0, 20000, 400),\n        (5, 1.0, 5.0, 1.1, 20000, 400),\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        N, k, E, h, M_samp, M_rev = case\n        \n        # Initial conditions\n        q0 = np.zeros(N, dtype=np.float64)\n        p0 = np.full(N, np.sqrt(2.0 * E / N), dtype=np.float64)\n\n        # Compute metrics for S integrator\n        eps_S = compute_reversibility_error('S', q0, p0, h, k, M_rev)\n        bias_S = compute_sampling_bias('S', q0, p0, h, k, E, M_samp)\n        \n        # Compute metrics for S4 integrator\n        eps_S4 = compute_reversibility_error('S4', q0, p0, h, k, M_rev)\n        bias_S4 = compute_sampling_bias('S4', q0, p0, h, k, E, M_samp)\n        \n        all_results.append([eps_S, eps_S4, bias_S, bias_S4])\n\n    # Format and print output exactly as specified\n    output_str = \"[\" + \",\".join([f\"[{','.join(map(str, row))}]\" for row in all_results]) + \"]\"\n    print(output_str)\n\nsolve()\n```", "id": "3456317"}]}