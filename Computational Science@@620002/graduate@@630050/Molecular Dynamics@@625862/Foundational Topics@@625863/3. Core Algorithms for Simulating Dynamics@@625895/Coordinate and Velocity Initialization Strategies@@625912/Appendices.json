{"hands_on_practices": [{"introduction": "When initializing velocities for a molecular dynamics simulation, we face a fundamental choice: should we deterministically rescale velocities so the system's kinetic energy exactly matches the ensemble average, or should we stochastically draw velocities from a distribution that yields this average? This exercise delves into the statistical ramifications of these two approaches. By analyzing the resulting kinetic energy variance and velocity autocorrelations, you will gain a deeper understanding of how the initial state's statistical properties can influence the subsequent system dynamics and equilibration pathway [@problem_id:3405766].", "problem": "Consider a system of $N$ identical particles of mass $m$ in a molecular dynamics simulation. Let $f=3N$ denote the total number of velocity degrees of freedom. The target temperature is $T$, and the Boltzmann constant is $k_B$. Assume that before any initialization, the velocities are a single sample from the Maxwell–Boltzmann distribution (MB), meaning each component $v_i$ is independent and normally distributed with mean $0$ and variance $\\sigma^2=k_B T/m$, and the instantaneous kinetic energy is $K=\\sum_{i=1}^{f} \\frac{m}{2} v_i^2$. Two initialization strategies are considered at time $t=0$:\n\n- Strategy A (instantaneous velocity rescaling): Scale the entire velocity vector by a scalar factor so that the instantaneous kinetic energy equals the MB mean kinetic energy at temperature $T$, i.e., $K_{\\text{target}}=\\frac{f}{2} k_B T$.\n- Strategy B (stochastic resampling): Replace the entire velocity vector by an independent draw from the MB distribution at temperature $T$.\n\nDefine the following metrics to quantify bias in the initialization:\n1. The kinetic-energy-variance bias $b_K$ is defined as the normalized deviation of the post-initialization kinetic-energy variance from the MB value,\n$$\nb_K \\equiv \\frac{\\operatorname{Var}\\{K'\\}}{\\operatorname{Var}_{\\text{MB}}\\{K\\}} - 1,\n$$\nwhere $K'$ is the post-initialization kinetic energy, and $\\operatorname{Var}_{\\text{MB}}\\{K\\}$ denotes the variance for an MB ensemble at temperature $T$ with $f$ degrees of freedom.\n2. The initial componentwise velocity autocorrelation $c$ is defined as the Pearson correlation coefficient between any given velocity component before and after initialization, $c \\equiv \\operatorname{Corr}(v_i, v_i')$, where $v_i$ and $v_i'$ denote the same component pre- and post-initialization, respectively.\n\nStarting from fundamental facts about the Maxwell–Boltzmann distribution (Gaussian components and the chi-square distribution of quadratic forms), the equipartition theorem, and standard properties of gamma and beta distributions, derive $b_K$ and $c$ for both strategies. Then define the composite bias functional\n$$\n\\Delta B(f) \\equiv \\big(b_K^{\\text{A}} + c^{\\text{A}}\\big) - \\big(b_K^{\\text{B}} + c^{\\text{B}}\\big),\n$$\nand obtain a single closed-form expression for $\\Delta B(f)$ in terms of $f$ only. Express your final answer as an analytic expression without units. No numerical rounding is required. Provide the final answer as a single expression in terms of $f$ only.", "solution": "The problem asks for the derivation of a composite bias functional $\\Delta B(f)$ that compares two velocity initialization strategies in molecular dynamics. The derivation must proceed from fundamental statistical principles.\n\nFirst, we establish the statistical properties of the system in a Maxwell-Boltzmann (MB) ensemble at temperature $T$. The velocity components $v_i$ for $i \\in \\{1, \\dots, f\\}$ are independent and identically distributed according to a normal distribution with mean $0$ and variance $\\sigma^2 = k_B T / m$. We can define normalized velocity components $u_i = v_i / \\sigma = v_i \\sqrt{m/(k_B T)}$, which are independent and follow the standard normal distribution, $u_i \\sim \\mathcal{N}(0, 1)$.\n\nThe instantaneous kinetic energy $K$ is given by $K = \\sum_{i=1}^{f} \\frac{m}{2} v_i^2$. Substituting $v_i = u_i \\sigma$, we get:\n$$K = \\sum_{i=1}^{f} \\frac{m}{2} (u_i^2 \\sigma^2) = \\sum_{i=1}^{f} \\frac{m}{2} u_i^2 \\frac{k_B T}{m} = \\frac{k_B T}{2} \\sum_{i=1}^{f} u_i^2$$\nThe sum of squares of $f$ independent standard normal variables, $X = \\sum_{i=1}^{f} u_i^2$, follows a chi-squared distribution with $f$ degrees of freedom, $X \\sim \\chi^2(f)$. A $\\chi^2(f)$ distribution is a special case of the gamma distribution, $\\operatorname{Gamma}(k, \\theta)$, with shape $k=f/2$ and scale $\\theta=2$.\nThe mean and variance of a $\\operatorname{Gamma}(k, \\theta)$ distribution are $k\\theta$ and $k\\theta^2$, respectively. Therefore, for $X \\sim \\chi^2(f)$:\n$\\mathbb{E}[X] = (f/2) \\cdot 2 = f$\n$\\operatorname{Var}[X] = (f/2) \\cdot 2^2 = 2f$\n\nFrom this, we can find the mean and variance of the kinetic energy $K = \\frac{k_B T}{2} X$ in the MB ensemble:\n$\\mathbb{E}_{\\text{MB}}[K] = \\frac{k_B T}{2} \\mathbb{E}[X] = \\frac{f}{2} k_B T$. This is the equipartition result.\n$\\operatorname{Var}_{\\text{MB}}\\{K\\} = \\left(\\frac{k_B T}{2}\\right)^2 \\operatorname{Var}[X] = \\left(\\frac{k_B T}{2}\\right)^2 (2f) = \\frac{f}{2} (k_B T)^2$. This quantity serves as the reference variance for the bias metric $b_K$.\n\nNext, we analyze each initialization strategy.\n\n**Strategy B: Stochastic Resampling**\nIn this strategy, the post-initialization velocities $v_i'$ are an independent draw from the same MB distribution.\n1.  **Kinetic-Energy-Variance Bias $b_K^{\\text{B}}$**:\n    The post-initialization kinetic energy $K'_{\\text{B}} = \\sum_i \\frac{m}{2} (v_i')^2$ is a new, independent realization from the same distribution as the original $K$. Therefore, its variance is the same as the MB variance: $\\operatorname{Var}\\{K'_{\\text{B}}\\} = \\operatorname{Var}_{\\text{MB}}\\{K\\}$.\n    The bias $b_K^{\\text{B}}$ is then:\n    $$b_K^{\\text{B}} = \\frac{\\operatorname{Var}\\{K'_{\\text{B}}\\}}{\\operatorname{Var}_{\\text{MB}}\\{K\\}} - 1 = \\frac{\\operatorname{Var}_{\\text{MB}}\\{K\\}}{\\operatorname{Var}_{\\text{MB}}\\{K\\}} - 1 = 1 - 1 = 0$$\n2.  **Velocity Autocorrelation $c^{\\text{B}}$**:\n    The correlation is defined as $c^{\\text{B}} = \\operatorname{Corr}(v_i, v_i')$. Since the new velocity vector is drawn independently from the old one, $v_i'$ is statistically independent of $v_i$. For independent variables, the covariance is zero, and thus the correlation is zero.\n    $$c^{\\text{B}} = 0$$\n\n**Strategy A: Instantaneous Velocity Rescaling**\nIn this strategy, all velocities are scaled by a factor $\\alpha$ such that the new kinetic energy $K'_{\\text{A}}$ is fixed to the mean value $K_{\\text{target}} = \\frac{f}{2} k_B T$.\nThe new velocities are $v_i' = \\alpha v_i$. The new kinetic energy is $K'_{\\text{A}} = \\alpha^2 K = K_{\\text{target}}$. This gives the scaling factor $\\alpha = \\sqrt{K_{\\text{target}}/K} = \\sqrt{\\frac{f k_B T}{2K}}$.\nThe post-initialization velocity components are $v_i' = v_i \\sqrt{\\frac{f k_B T}{2K}}$.\n\n1.  **Kinetic-Energy-Variance Bias $b_K^{\\text{A}}$**:\n    The post-initialization kinetic energy $K'_{\\text{A}}$ is set to a deterministic constant value, $K_{\\text{target}}$. The variance of a constant is zero, so $\\operatorname{Var}\\{K'_{\\text{A}}\\} = 0$.\n    The bias $b_K^{\\text{A}}$ is:\n    $$b_K^{\\text{A}} = \\frac{\\operatorname{Var}\\{K'_{\\text{A}}\\}}{\\operatorname{Var}_{\\text{MB}}\\{K\\}} - 1 = \\frac{0}{\\frac{f}{2} (k_B T)^2} - 1 = -1$$\n2.  **Velocity Autocorrelation $c^{\\text{A}}$**:\n    The correlation is $c^{\\text{A}} = \\operatorname{Corr}(v_i, v_i') = \\frac{\\operatorname{Cov}(v_i, v_i')}{\\sqrt{\\operatorname{Var}(v_i)\\operatorname{Var}(v_i')}}$.\n    The variance of the pre-initialization velocity is $\\operatorname{Var}(v_i) = \\sigma^2 = k_B T / m$.\n    To find $\\operatorname{Var}(v_i')$, we first note that $\\mathbb{E}[v_i'] = \\mathbb{E}[v_i \\alpha] = 0$ due to the symmetry of the distribution of $v_i$ (the integrand is an odd function of $v_i$). Thus, $\\operatorname{Var}(v_i') = \\mathbb{E}[(v_i')^2]$. The total kinetic energy is conserved at the mean value, so by symmetry, each degree of freedom must have the same average kinetic energy:\n    $\\mathbb{E}[\\frac{m}{2} (v_i')^2] = \\frac{1}{f} \\mathbb{E}[K'_{\\text{A}}] = \\frac{1}{f} \\left(\\frac{f}{2} k_B T\\right) = \\frac{1}{2} k_B T$.\n    This implies $\\frac{m}{2} \\mathbb{E}[(v_i')^2] = \\frac{1}{2} k_B T$, so $\\mathbb{E}[(v_i')^2] = k_B T / m = \\sigma^2$. Hence, $\\operatorname{Var}(v_i') = \\sigma^2$.\n    The denominator of the correlation is $\\sqrt{\\sigma^2 \\cdot \\sigma^2} = \\sigma^2$.\n    The numerator is the covariance: $\\operatorname{Cov}(v_i, v_i') = \\mathbb{E}[v_i v_i'] - \\mathbb{E}[v_i]\\mathbb{E}[v_i'] = \\mathbb{E}[v_i v_i'] = \\mathbb{E}\\left[v_i^2 \\sqrt{\\frac{f k_B T}{2K}}\\right]$.\n    We express this expectation in terms of the normalized variables $u_i$:\n    $\\operatorname{Cov}(v_i, v_i') = \\mathbb{E}\\left[\\sigma^2 u_i^2 \\sqrt{\\frac{f k_B T}{2 \\frac{k_B T}{2} \\sum_j u_j^2}}\\right] = \\sigma^2 \\sqrt{f} \\, \\mathbb{E}\\left[\\frac{u_i^2}{\\sqrt{\\sum_j u_j^2}}\\right]$.\n    Let $Y = u_i^2 \\sim \\chi^2(1)$ and $Z = \\sum_{j \\neq i} u_j^2 \\sim \\chi^2(f-1)$. $Y$ and $Z$ are independent. The sum is $X = Y+Z = \\sum_j u_j^2 \\sim \\chi^2(f)$. We need to calculate $\\mathbb{E}[Y / \\sqrt{X}]$.\n    Let $W = Y/X = Y/(Y+Z)$. For independent Gamma variables (which $\\chi^2$ variables are), $W$ follows a Beta distribution, $W \\sim \\operatorname{Beta}(\\frac{1}{2}, \\frac{f-1}{2})$, and is independent of their sum $X$.\n    Using this independence, $\\mathbb{E}[Y / \\sqrt{X}] = \\mathbb{E}[W \\sqrt{X}] = \\mathbb{E}[W]\\mathbb{E}[\\sqrt{X}]$.\n    The mean of a $\\operatorname{Beta}(\\alpha, \\beta)$ distribution is $\\frac{\\alpha}{\\alpha+\\beta}$, so $\\mathbb{E}[W] = \\frac{1/2}{1/2+(f-1)/2} = \\frac{1}{f}$.\n    To find $\\mathbb{E}[\\sqrt{X}]$, we use the formula for the $n$-th moment of a $\\operatorname{Gamma}(k, \\theta)$ variable, $\\mathbb{E}[X^n] = \\theta^n \\frac{\\Gamma(k+n)}{\\Gamma(k)}$. For $X \\sim \\chi^2(f)$, we have $k=f/2$, $\\theta=2$, and we need the moment for $n=1/2$.\n    $\\mathbb{E}[\\sqrt{X}] = 2^{1/2} \\frac{\\Gamma(f/2 + 1/2)}{\\Gamma(f/2)} = \\sqrt{2} \\frac{\\Gamma((f+1)/2)}{\\Gamma(f/2)}$.\n    Putting it all together:\n    $\\operatorname{Cov}(v_i, v_i') = \\sigma^2 \\sqrt{f} \\left(\\frac{1}{f}\\right) \\left(\\sqrt{2} \\frac{\\Gamma((f+1)/2)}{\\Gamma(f/2)}\\right) = \\sigma^2 \\sqrt{\\frac{2}{f}} \\frac{\\Gamma((f+1)/2)}{\\Gamma(f/2)}$.\n    Finally, we find the correlation $c^{\\text{A}}$:\n    $$c^{\\text{A}} = \\frac{\\operatorname{Cov}(v_i, v_i')}{\\sigma^2} = \\sqrt{\\frac{2}{f}} \\frac{\\Gamma\\left(\\frac{f+1}{2}\\right)}{\\Gamma\\left(\\frac{f}{2}\\right)}$$\n\n**Composite Bias Functional $\\Delta B(f)$**\nNow we assemble the final expression for $\\Delta B(f)$ using the four calculated metrics:\n$b_K^{\\text{A}} = -1$\n$c^{\\text{A}} = \\sqrt{\\frac{2}{f}} \\frac{\\Gamma\\left(\\frac{f+1}{2}\\right)}{\\Gamma\\left(\\frac{f}{2}\\right)}$\n$b_K^{\\text{B}} = 0$\n$c^{\\text{B}} = 0$\nThe definition of the functional is $\\Delta B(f) \\equiv \\left(b_K^{\\text{A}} + c^{\\text{A}}\\right) - \\left(b_K^{\\text{B}} + c^{\\text{B}}\\right)$.\nSubstituting the derived values:\n$$\\Delta B(f) = \\left(-1 + \\sqrt{\\frac{2}{f}} \\frac{\\Gamma\\left(\\frac{f+1}{2}\\right)}{\\Gamma\\left(\\frac{f}{2}\\right)}\\right) - (0 + 0)$$\n$$\\Delta B(f) = \\sqrt{\\frac{2}{f}} \\frac{\\Gamma\\left(\\frac{f+1}{2}\\right)}{\\Gamma\\left(\\frac{f}{2}\\right)} - 1$$\nThis is the required closed-form expression for $\\Delta B(f)$ in terms of $f$.", "answer": "$$\\boxed{\\sqrt{\\frac{2}{f}} \\frac{\\Gamma\\left(\\frac{f+1}{2}\\right)}{\\Gamma\\left(\\frac{f}{2}\\right)} - 1}$$", "id": "3405766"}, {"introduction": "For simulations of isolated systems, it is standard practice to set the total linear momentum to zero by removing the center-of-mass (COM) motion. While seemingly simple, this step can introduce a subtle but systematic error if not handled carefully. This problem guides you through quantifying the consequences of naively applying this constraint without adjusting the number of degrees of freedom, which leads to an incorrect initial temperature [@problem_id:3405734]. You will use the equipartition theorem to derive the magnitude of this temperature discrepancy and, more importantly, the exact scaling factor required to restore the system to its target temperature.", "problem": "Consider a system of $N$ particles of masses $\\{m_i\\}_{i=1}^{N}$ in three spatial dimensions, initialized for Molecular Dynamics (MD) such that each Cartesian velocity component is independently drawn from the Maxwell–Boltzmann distribution at a target temperature $T_0$. Define the Boltzmann constant as $k_B$ and the kinetic energy as $K = \\sum_{i=1}^{N} \\frac{1}{2} m_i |\\mathbf{v}_i|^2$. A practitioner performs a naive initialization by first rescaling the sampled velocities $\\{\\mathbf{v}_i\\}$ so that $K$ satisfies the equipartition prediction for $f = 3N$ degrees of freedom, and then removes the net center-of-mass (COM) motion by subtracting the center-of-mass velocity $\\mathbf{V}_{\\mathrm{CM}} = \\left(\\sum_{i=1}^{N} m_i \\mathbf{v}_i\\right)/\\left(\\sum_{i=1}^{N} m_i\\right)$ from every particle’s velocity. After this COM removal, the practitioner computes the “naive” temperature $T_{\\mathrm{naive}}$ using the definition $T_{\\mathrm{naive}} = \\frac{2K'}{3N k_B}$, where $K' = \\sum_{i=1}^{N} \\frac{1}{2} m_i |\\mathbf{v}_i - \\mathbf{V}_{\\mathrm{CM}}|^2$ is the new kinetic energy.\n\nStarting from the Maxwell–Boltzmann statistics and the equipartition theorem, quantify the expected effect of this naive COM removal on the temperature, and then derive a single multiplicative rescaling factor $s$ that, when applied uniformly to the COM-removed velocities $\\{\\mathbf{v}_i - \\mathbf{V}_{\\mathrm{CM}}\\}$, restores the target temperature $T_0$ under the same naive $f = 3N$ temperature computation. Provide your final answer as a closed-form analytical expression for $s$. No numerical evaluation is required.", "solution": "The problem asks for an analysis of a specific, albeit naive, velocity initialization procedure in molecular dynamics and for a correction factor to achieve a desired target temperature. The solution will proceed by first validating the problem statement and then deriving the required quantities using principles of statistical mechanics.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n- Number of particles: $N$\n- Particle masses: $\\{m_i\\}_{i=1}^{N}$\n- Spatial dimensions: $3$\n- Initial velocity sampling: Each Cartesian velocity component is independently drawn from the Maxwell–Boltzmann distribution at a target temperature $T_0$.\n- Boltzmann constant: $k_B$\n- Kinetic energy definition: $K = \\sum_{i=1}^{N} \\frac{1}{2} m_i |\\mathbf{v}_i|^2$\n- Center-of-mass (COM) velocity: $\\mathbf{V}_{\\mathrm{CM}} = \\left(\\sum_{i=1}^{N} m_i \\mathbf{v}_i\\right)/\\left(\\sum_{i=1}^{N} m_i\\right)$\n- Practitioner's initialization procedure:\n    1. Sample velocities $\\{\\mathbf{v}_i^{(0)}\\}$ from the Maxwell-Boltzmann distribution at $T_0$.\n    2. Rescale these velocities to get $\\{\\mathbf{v}_i^{(1)}\\}$ such that the total kinetic energy $K^{(1)}$ exactly equals the equipartition prediction for $f = 3N$ degrees of freedom, i.e., $K^{(1)} = \\frac{3N}{2} k_B T_0$.\n    3. Remove the COM motion by defining new velocities $\\{\\mathbf{v}_i^{(2)}\\} = \\{\\mathbf{v}_i^{(1)} - \\mathbf{V}_{\\mathrm{CM}}^{(1)}\\}$.\n- Naive temperature calculation: The temperature is computed as $T_{\\mathrm{naive}} = \\frac{2K'}{3N k_B}$, where $K' = \\sum_{i=1}^{N} \\frac{1}{2} m_i |\\mathbf{v}_i^{(2)}|^2$ is the kinetic energy after COM removal.\n- Objective:\n    1. Quantify the expected effect of this COM removal on the temperature.\n    2. Derive a multiplicative rescaling factor $s$ which, when applied to the COM-removed velocities $\\{\\mathbf{v}_i^{(2)}\\}$, restores the expected temperature to $T_0$ under the same naive $f=3N$ computation.\n\n**Step 2: Validate Using Extracted Givens**\n- **Scientifically Grounded**: The problem is well-founded in classical statistical mechanics and its application to molecular dynamics simulations. It deals with standard concepts like the Maxwell-Boltzmann distribution, equipartition theorem, kinetic energy, and degrees of freedom.\n- **Well-Posed**: The problem is clearly defined, providing all necessary variables, constants, and procedural steps. The objective is unambiguous, leading to a unique analytical solution.\n- **Objective**: The problem is stated in precise, quantitative, and unbiased terms.\n\n**Step 3: Verdict and Action**\nThe problem is valid. A detailed solution will be provided.\n\n### Derivation of the Solution\n\nThe core of the problem lies in understanding how kinetic energy is partitioned among the system's degrees of freedom. A system of $N$ particles in $3$ dimensions has $3N$ total degrees of freedom for translational motion. These can be decomposed into $3$ degrees of freedom corresponding to the translational motion of the center of mass (COM) and $3N-3$ degrees of freedom corresponding to the motion of particles relative to the COM.\n\nLet the velocities after the initial Maxwell-Boltzmann sampling be $\\{\\mathbf{v}_i^{(0)}\\}$. The practitioner's first step is to rescale these velocities to obtain a new set $\\{\\mathbf{v}_i^{(1)}\\}$ such that the total kinetic energy $K^{(1)}$ is no longer a statistical variable but a fixed quantity:\n$$K^{(1)} = \\sum_{i=1}^{N} \\frac{1}{2} m_i |\\mathbf{v}_i^{(1)}|^2 = \\frac{3N}{2} k_B T_0$$\nThis step imposes a microcanonical-like constraint on the system's kinetic energy.\n\nAccording to Koenig's theorem, the total kinetic energy can be decomposed as:\n$$K^{(1)} = K' + K_{\\mathrm{CM}}^{(1)}$$\nwhere $K' = \\sum_{i=1}^{N} \\frac{1}{2} m_i |\\mathbf{v}_i^{(1)} - \\mathbf{V}_{\\mathrm{CM}}^{(1)}|^2$ is the kinetic energy relative to the COM (the quantity used to calculate $T_{\\mathrm{naive}}$), and $K_{\\mathrm{CM}}^{(1)} = \\frac{1}{2} M |\\mathbf{V}_{\\mathrm{CM}}^{(1)}|^2$ is the kinetic energy of the COM, with $M = \\sum_{i=1}^{N} m_i$ being the total mass.\n\nThe initial sampling from the Maxwell-Boltzmann distribution ensures that, on average, energy is distributed equally among all quadratic degrees of freedom (equipartition). The uniform rescaling in the second step does not alter this relative distribution. Therefore, the fixed total kinetic energy $K^{(1)}$ is, on average, partitioned equally among the $3N$ available degrees of freedom.\n\nThe expected energy per degree of freedom is:\n$$\\langle E_{\\mathrm{dof}} \\rangle = \\frac{K^{(1)}}{3N} = \\frac{1}{3N} \\left(\\frac{3N}{2} k_B T_0\\right) = \\frac{1}{2} k_B T_0$$\n\nThe COM motion accounts for $3$ degrees of freedom. The expected kinetic energy associated with the COM is:\n$$\\langle K_{\\mathrm{CM}}^{(1)} \\rangle = 3 \\times \\langle E_{\\mathrm{dof}} \\rangle = \\frac{3}{2} k_B T_0$$\n\nThe remaining kinetic energy, $K'$, is associated with the internal motion relative to the COM, which has $3N-3$ degrees of freedom. Its expected value is:\n$$\\langle K' \\rangle = (3N-3) \\times \\langle E_{\\mathrm{dof}} \\rangle = \\frac{3(N-1)}{2} k_B T_0$$\nWe can verify this: $\\langle K^{(1)} \\rangle = \\langle K' \\rangle + \\langle K_{\\mathrm{CM}}^{(1)} \\rangle = \\frac{3(N-1)}{2} k_B T_0 + \\frac{3}{2} k_B T_0 = \\frac{3N}{2} k_B T_0$, which is consistent with the fixed total energy.\n\nNow, we quantify the effect of the naive COM removal on the temperature. The practitioner calculates a \"naive\" temperature using $K'$ but incorrectly assumes $3N$ degrees of freedom:\n$$T_{\\mathrm{naive}} = \\frac{2K'}{3N k_B}$$\nThe expected value of this naive temperature is:\n$$\\langle T_{\\mathrm{naive}} \\rangle = \\frac{2 \\langle K' \\rangle}{3N k_B} = \\frac{2}{3N k_B} \\left(\\frac{3(N-1)}{2} k_B T_0\\right) = \\frac{N-1}{N} T_0$$\nThis shows that the procedure systematically results in a lower temperature than the target $T_0$, with the expected temperature being reduced by a factor of $(N-1)/N$.\n\nThe final part of the problem is to find a single multiplicative factor $s$ to correct this. The COM-removed velocities $\\{\\mathbf{v}_i^{(2)}\\}$ (where $\\mathbf{v}_i^{(2)} = \\mathbf{v}_i^{(1)} - \\mathbf{V}_{\\mathrm{CM}}^{(1)}$) are to be rescaled to $\\{\\mathbf{v}_i^{(3)}\\} = \\{s \\mathbf{v}_i^{(2)}\\}$. The new total kinetic energy will be $K''$:\n$$K'' = \\sum_{i=1}^{N} \\frac{1}{2} m_i |s \\mathbf{v}_i^{(2)}|^2 = s^2 \\sum_{i=1}^{N} \\frac{1}{2} m_i |\\mathbf{v}_i^{(2)}|^2 = s^2 K'$$\nThe practitioner will then calculate a final temperature $T_{final}$ using the same naive formula:\n$$T_{final} = \\frac{2 K''}{3N k_B} = \\frac{2 s^2 K'}{3N k_B}$$\nWe require that the *expected* value of this final temperature equals the target temperature $T_0$:\n$$\\langle T_{final} \\rangle = T_0$$\nSubstituting the expressions for $T_{final}$ and $\\langle K' \\rangle$:\n$$\\left\\langle \\frac{2 s^2 K'}{3N k_B} \\right\\rangle = s^2 \\frac{2 \\langle K' \\rangle}{3N k_B} = T_0$$\n$$s^2 \\frac{2}{3N k_B} \\left(\\frac{3(N-1)}{2} k_B T_0\\right) = T_0$$\nSimplifying the expression:\n$$s^2 \\left(\\frac{N-1}{N}\\right) T_0 = T_0$$\nAssuming $T_0 \\neq 0$, we can divide by $T_0$:\n$$s^2 = \\frac{N}{N-1}$$\nSince the scaling factor $s$ must be positive, we take the positive square root:\n$$s = \\sqrt{\\frac{N}{N-1}}$$\nThis is the required closed-form analytical expression for the rescaling factor.", "answer": "$$\\boxed{\\sqrt{\\frac{N}{N-1}}}$$", "id": "3405734"}, {"introduction": "This final practice moves from analytical derivations to a comprehensive implementation, challenging you to build a robust, parallel-safe velocity initialization workflow from first principles. You will tackle the practicalities of setting up a simulation for modern high-performance computing, including designing a reproducible random number generation scheme that guarantees statistical independence across parallel processes. This exercise synthesizes the concepts of Maxwell-Boltzmann sampling and center-of-mass velocity removal into a runnable program, solidifying your understanding of how to ensure a simulation starts from a physically sound and computationally correct state [@problem_id:3405774].", "problem": "You are asked to construct and analyze a parallel-safe velocity initialization strategy for molecular dynamics that generalizes to Message Passing Interface (MPI) environments. The task must be solved from first principles consistent with Newtonian mechanics, the equipartition theorem, and the Maxwell–Boltzmann distribution, and it must be numerically demonstrable by a single, complete, runnable program. The core requirements are: (i) design a deterministic, rank-indexed random seeding method that yields statistically independent velocity samples for non-overlapping particle subsets assigned to different ranks, and (ii) prove that exact global linear momentum constraints are satisfied after performing center-of-mass velocity removal. The program must simulate multiple MPI ranks in a single process by partitioning particles into disjoint subsets indexed by a rank label; it must not actually use MPI, but it must model the independence and gathering steps that would occur across Message Passing Interface (MPI) ranks.\n\nFundamental base to use: the definition of velocity as $v = dx/dt$, Newton’s Second Law $F = m a$ for the interpretation of linear momentum, the equipartition theorem stating that each quadratic degree of freedom contributes $\\frac{1}{2} k_{\\mathrm{B}} T$ to the average energy at temperature $T$, and the Maxwell–Boltzmann velocity distribution for a classical particle of mass $m$. No shortcut formulas are to be assumed; you must derive any sampling variance and any center-of-mass removal transformation starting only from these foundations in your solution.\n\nDesign constraints and goals:\n- Define a seeding scheme that takes a base integer seed $S$ and a rank index $r \\in \\{0,1,\\dots,R-1\\}$ and produces independent pseudorandom streams, one per rank, in a manner that is parallel-safe and reproducible. Independence here means no shared internal state and no overlap of generated subsequences across ranks, given fixed $S$ and disjoint rank labels.\n- Sample initial velocities for particle $i$ of mass $m_i$ at temperature $T$ from the Maxwell–Boltzmann distribution consistent with the equipartition theorem. You must reason to determine the component-wise distribution and its variance strictly from the fundamental base specified above.\n- After sampling, perform a single global center of mass (COM) velocity removal step that enforces the physical constraint of zero total linear momentum. In your solution, you must derive why subtracting the appropriate constant vector from every particle’s velocity achieves zero total momentum.\n- Units: masses must be in kilograms ($\\mathrm{kg}$), temperature in Kelvin ($\\mathrm{K}$), velocities in meters per second ($\\mathrm{m/s}$), and momentum in kilogram-meters per second ($\\mathrm{kg\\cdot m/s}$). Boltzmann’s constant $k_{\\mathrm{B}}$ must be used in joules per Kelvin, where $1\\,\\mathrm{J} = 1\\,\\mathrm{kg\\cdot m^2/s^2}$.\n- Your program must validate the independence of rank-local velocity streams and the satisfaction of the momentum constraint after COM removal. Independence validation must be deterministic: for each rank, compute a digest of the raw, pre-COM-removal velocities and confirm that all rank digests are distinct for non-empty rank assignments. Momentum validation must compute the global total momentum after COM removal and check that its components are within a specified absolute tolerance $\\epsilon$.\n\nTest suite and parameters:\nUse the following physically consistent constants and masses derived from atomic mass units. Let the atomic mass unit be $u = 1.66053906660 \\times 10^{-27}\\,\\mathrm{kg}$, Boltzmann’s constant be $k_{\\mathrm{B}} = 1.380649 \\times 10^{-23}\\,\\mathrm{J/K}$. Define species masses\n- Argon: $m_{\\mathrm{Ar}} = 39.948\\,u$,\n- Hydrogen: $m_{\\mathrm{H}} = 1.00784\\,u$,\n- Xenon: $m_{\\mathrm{Xe}} = 131.293\\,u$.\n\nImplement three test cases:\n1. Happy path: $N = 1000$ particles, $R = 4$ ranks, uniform mass $m_i = m_{\\mathrm{Ar}}$ for all $i$, temperature $T = 300\\,\\mathrm{K}$, base seed $S = 123456789$, tolerance $\\epsilon = 1\\times 10^{-25}\\,\\mathrm{kg\\cdot m/s}$.\n2. Boundary case: $N = 1$ particle, $R = 1$ rank, mass $m_1 = m_{\\mathrm{Ar}}$, temperature $T = 500\\,\\mathrm{K}$, base seed $S = 987654321$, tolerance $\\epsilon = 1\\times 10^{-25}\\,\\mathrm{kg\\cdot m/s}$.\n3. Heterogeneous masses: $N = 100$ particles, $R = 3$ ranks, temperature $T = 1000\\,\\mathrm{K}$, base seed $S = 192837465$, tolerance $\\epsilon = 1\\times 10^{-25}\\,\\mathrm{kg\\cdot m/s}$. Mass assignment: $m_i = m_{\\mathrm{H}}$ for $i \\in \\{1,2,\\dots,50\\}$ and $m_i = m_{\\mathrm{Xe}}$ for $i \\in \\{51,52,\\dots,100\\}$.\n\nProgram requirements:\n- Partition the $N$ particles into $R$ contiguous subsets (as evenly sized as possible) to represent rank-local ownership; for each rank $r$, sample its local velocities from its independent pseudorandom stream.\n- Perform one global COM removal step on the concatenated velocity field across all ranks.\n- Validate and return, per test case: (a) a boolean indicating whether all per-rank digests of raw velocities are distinct, (b) a boolean indicating whether the post-COM-removal total momentum satisfies the tolerance $\\epsilon$, and (c) the maximum absolute component of the total momentum vector after COM removal in $\\mathrm{kg\\cdot m/s}$ as a float.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case contributes a nested list of the form $[b_1,b_2,x]$ with $b_1$ and $b_2$ booleans and $x$ a float in $\\mathrm{kg\\cdot m/s}$. Concretely, the output must be of the form $[[b_{1}^{(1)},b_{2}^{(1)},x^{(1)}],[b_{1}^{(2)},b_{2}^{(2)},x^{(2)}],[b_{1}^{(3)},b_{2}^{(3)},x^{(3)}]]$ printed on a single line, with no additional text.", "solution": "The problem requires the design and implementation of a parallel-safe velocity initialization strategy for molecular dynamics simulations. The solution must be derived from first principles, specifically the equipartition theorem and the definition of linear momentum, and must be demonstrable in a single-process program that models a multi-rank MPI environment.\n\nThe solution is presented in three parts:\n1.  Derivation of the single-particle velocity sampling distribution from the equipartition theorem.\n2.  Design of a deterministic and parallel-safe random number generation scheme.\n3.  Derivation of the center-of-mass (COM) velocity removal transformation to enforce zero total linear momentum.\n\n**1. Derivation of the Velocity Sampling Distribution**\n\nThe equipartition theorem is a cornerstone of classical statistical mechanics. It states that for a system in thermal equilibrium at temperature $T$, every quadratic degree of freedom in the Hamiltonian contributes an average energy of $\\frac{1}{2} k_{\\mathrm{B}} T$, where $k_{\\mathrm{B}}$ is the Boltzmann constant.\n\nFor a single particle of mass $m_i$ with velocity vector $\\vec{v}_i = (v_{ix}, v_{iy}, v_{iz})$ in three dimensions, the kinetic energy is given by:\n$$E_{k,i} = \\frac{1}{2} m_i v_i^2 = \\frac{1}{2} m_i (v_{ix}^2 + v_{iy}^2 + v_{iz}^2)$$\nThis expression can be separated into three independent terms, one for each spatial dimension:\n$$E_{k,i} = \\frac{1}{2} m_i v_{ix}^2 + \\frac{1}{2} m_i v_{iy}^2 + \\frac{1}{2} m_i v_{iz}^2$$\nEach of these terms ($ \\frac{1}{2} m_i v_{i\\alpha}^2 $ for $\\alpha \\in \\{x, y, z\\}$) is a quadratic degree of freedom. Applying the equipartition theorem, the average energy for each component is:\n$$\\left\\langle \\frac{1}{2} m_i v_{i\\alpha}^2 \\right\\rangle = \\frac{1}{2} k_{\\mathrm{B}} T$$\nwhere $\\langle \\cdot \\rangle$ denotes the ensemble average. This simplifies to:\n$$m_i \\langle v_{i\\alpha}^2 \\rangle = k_{\\mathrm{B}} T \\implies \\langle v_{i\\alpha}^2 \\rangle = \\frac{k_{\\mathrm{B}} T}{m_i}$$\nThe velocities of particles in a thermalized system are described by the Maxwell-Boltzmann distribution. For a single velocity component, say $v_{ix}$, this distribution takes the form of a Gaussian (normal) distribution, $f(v_{ix})$, with a mean of zero, $\\langle v_{ix} \\rangle = 0$, as there is no preferred direction of motion. The variance of this distribution, $\\sigma_{i\\alpha}^2$, is given by:\n$$\\sigma_{i\\alpha}^2 = \\langle (v_{i\\alpha} - \\langle v_{i\\alpha} \\rangle)^2 \\rangle = \\langle v_{i\\alpha}^2 \\rangle - \\langle v_{i\\alpha} \\rangle^2$$\nSince $\\langle v_{i\\alpha} \\rangle = 0$, the variance is simply $\\sigma_{i\\alpha}^2 = \\langle v_{i\\alpha}^2 \\rangle$. From our result from the equipartition theorem, we have:\n$$\\sigma_{i\\alpha}^2 = \\frac{k_{\\mathrm{B}} T}{m_i}$$\nThis holds for each component $\\alpha \\in \\{x, y, z\\}$. Therefore, to initialize the velocity of particle $i$, we must sample each of its three velocity components ($v_{ix}$, $v_{iy}$, $v_{iz}$) independently from a normal distribution with mean $\\mu=0$ and standard deviation $\\sigma_i = \\sqrt{k_{\\mathrm{B}} T / m_i}$.\n\n**2. Parallel-Safe Random Number Generation**\n\nIn a parallel MPI environment, each process (rank) must generate random numbers independently without collaborating with other ranks after initial setup. This requires a seeding mechanism that guarantees that the sequences of random numbers generated by different ranks are statistically independent and do not overlap.\n\nA robust method for achieving this is to use a master seed to spawn independent seed sequences for each rank. Given a single base integer seed $S$ and the total number of ranks $R$, we can initialize a master `SeedSequence` object. This object can then `spawn` $R$ new, independent `SeedSequence` objects. Rank $r$ (where $r \\in \\{0, 1, \\dots, R-1\\}$) then uses the $r$-th spawned seed sequence to initialize its own private pseudorandom number generator (PRNG). This approach ensures reproducibility (the same $S$ and $R$ always yield the same set of streams) and statistical independence across ranks. This is the strategy implemented in the accompanying code using `numpy.random.SeedSequence`.\n\nTo validate this independence deterministically, we can compute a digest for the set of raw velocities generated by each rank before any global operations. A secure hash of the raw velocity data for each rank provides a reliable digest. If the seeding mechanism is correct, each rank will generate a unique sequence of velocities, resulting in a unique digest for each non-empty rank partition.\n\n**3. Derivation of Center-of-Mass Velocity Removal**\n\nIn many molecular dynamics simulations, particularly for isolated systems (NVE ensemble), the total linear momentum of the system should be a conserved quantity. It is common practice to initialize the system with zero total linear momentum. The initial sampling from the Maxwell-Boltzmann distribution generates velocities with a zero mean on average, but for any finite sample of $N$ particles, the net momentum will be non-zero due to statistical fluctuations.\n\nThe total linear momentum of the system, $\\vec{P}_{\\text{total}}$, is the vector sum of the individual momenta:\n$$\\vec{P}_{\\text{total}} = \\sum_{i=1}^{N} \\vec{p}_i = \\sum_{i=1}^{N} m_i \\vec{v}_i$$\nThe center-of-mass (COM) velocity, $\\vec{V}_{\\text{COM}}$, is defined as the total momentum divided by the total mass, $M_{\\text{total}} = \\sum_{i=1}^{N} m_i$:\n$$\\vec{V}_{\\text{COM}} = \\frac{\\vec{P}_{\\text{total}}}{M_{\\text{total}}} = \\frac{\\sum_{i=1}^{N} m_i \\vec{v}_i}{\\sum_{i=1}^{N} m_i}$$\nOur goal is to find a corrected set of velocities, $\\vec{v}'_i$, such that the new total momentum, $\\vec{P}'_{\\text{total}}$, is the zero vector, $\\vec{0}$. The standard procedure is to shift the system into the COM reference frame by subtracting $\\vec{V}_{\\text{COM}}$ from each particle's velocity:\n$$\\vec{v}'_i = \\vec{v}_i - \\vec{V}_{\\text{COM}}$$\nWe now prove that this transformation correctly nullifies the total momentum. The new total momentum is:\n$$\\vec{P}'_{\\text{total}} = \\sum_{i=1}^{N} m_i \\vec{v}'_i = \\sum_{i=1}^{N} m_i (\\vec{v}_i - \\vec{V}_{\\text{COM}})$$\nDistributing the sum:\n$$\\vec{P}'_{\\text{total}} = \\sum_{i=1}^{N} m_i \\vec{v}_i - \\sum_{i=1}^{N} m_i \\vec{V}_{\\text{COM}}$$\nThe first term is the original total momentum, $\\vec{P}_{\\text{total}}$. In the second term, $\\vec{V}_{\\text{COM}}$ is a constant vector with respect to the sum over particles, so it can be factored out:\n$$\\vec{P}'_{\\text{total}} = \\vec{P}_{\\text{total}} - \\vec{V}_{\\text{COM}} \\left(\\sum_{i=1}^{N} m_i\\right) = \\vec{P}_{\\text{total}} - \\vec{V}_{\\text{COM}} M_{\\text{total}}$$\nSubstituting the definition $\\vec{P}_{\\text{total}} = \\vec{V}_{\\text{COM}} M_{\\text{total}}$:\n$$\\vec{P}'_{\\text{total}} = (\\vec{V}_{\\text{COM}} M_{\\text{total}}) - \\vec{V}_{\\text{COM}} M_{\\text{total}} = \\vec{0}$$\nThis confirms that subtracting the center-of-mass velocity from each particle velocity sets the total linear momentum of the system to zero. In a simulated MPI context, this requires a global communication step: each rank computes its local contribution to the total momentum ($ \\sum_{i \\in \\text{rank}} m_i \\vec{v}_i $) and total mass. These are then summed across all ranks (a global reduction) to compute the global $\\vec{V}_{\\text{COM}}$, which is then broadcast back to all ranks to perform the subtraction. The provided program models this by performing the calculation on the concatenated global velocity array.", "answer": "```python\nimport numpy as np\nimport hashlib\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for parallel-safe velocity initialization.\n    \"\"\"\n\n    # Define physical constants and masses\n    u = 1.66053906660e-27  # Atomic mass unit in kg\n    k_B = 1.380649e-23     # Boltzmann constant in J/K\n\n    mass_species = {\n        'Ar': 39.948 * u,\n        'H': 1.00784 * u,\n        'Xe': 131.293 * u,\n    }\n\n    # Define test cases\n    test_cases = [\n        # Case 1: Happy path\n        {\n            \"N\": 1000, \"R\": 4, \"T\": 300.0, \"S\": 123456789,\n            \"masses\": np.full(1000, mass_species['Ar']),\n            \"epsilon\": 1e-25\n        },\n        # Case 2: Boundary case\n        {\n            \"N\": 1, \"R\": 1, \"T\": 500.0, \"S\": 987654321,\n            \"masses\": np.full(1, mass_species['Ar']),\n            \"epsilon\": 1e-25\n        },\n        # Case 3: Heterogeneous masses\n        {\n            \"N\": 100, \"R\": 3, \"T\": 1000.0, \"S\": 192837465,\n            \"masses\": np.concatenate([\n                np.full(50, mass_species['H']),\n                np.full(50, mass_species['Xe'])\n            ]),\n            \"epsilon\": 1e-25\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_simulation(\n            N=case[\"N\"], R=case[\"R\"], T=case[\"T\"], S=case[\"S\"],\n            masses=case[\"masses\"], epsilon=case[\"epsilon\"], k_B=k_B\n        )\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef run_simulation(N, R, T, S, masses, epsilon, k_B):\n    \"\"\"\n    Simulates the velocity initialization for a single test case.\n    \n    This function models an MPI environment by partitioning particles and using\n    independent random streams per partition (rank).\n    \"\"\"\n\n    # 1. Partition particles into R contiguous, evenly-sized subsets for each rank\n    base_size = N // R\n    remainder = N % R\n    counts = [base_size + 1] * remainder + [base_size] * (R - remainder)\n    \n    # Ensure all ranks get at least one particle if N >= R\n    if N > 0 and R > 0 and N  R:\n        counts = [1] * N + [0] * (R-N)\n\n    indices = np.cumsum([0] + counts)\n    # particle_indices_per_rank is a list of Python range objects\n    particle_indices_per_rank = [range(indices[r], indices[r+1]) for r in range(R)]\n\n    # 2. Create independent, deterministic random number generators for each rank\n    master_ss = np.random.SeedSequence(S)\n    child_sgs = master_ss.spawn(R)\n    rngs = [np.random.default_rng(sg) for sg in child_sgs]\n\n    # 3. Sample velocities for each rank from its independent stream\n    # This loop simulates each rank working on its local data\n    velocities = np.zeros((N, 3))\n    rank_digests = []\n\n    for r in range(R):\n        rank_indices = particle_indices_per_rank[r]\n        num_particles_in_rank = len(rank_indices)\n        \n        if num_particles_in_rank == 0:\n            continue\n\n        rng = rngs[r]\n        \n        # Get masses for particles owned by this rank\n        rank_masses = masses[rank_indices]\n\n        # Calculate standard deviation for velocity components from equipartition\n        # sigma = sqrt(k_B * T / m)\n        # We compute it per-particle for heterogeneous systems\n        sigma_per_particle = np.sqrt(k_B * T / rank_masses)\n        \n        # Sample velocities from N(0, sigma^2)\n        # Broadcasting sigma_per_particle to (num_particles_in_rank, 3)\n        local_velocities = rng.normal(0.0, sigma_per_particle[:, np.newaxis], size=(num_particles_in_rank, 3))\n        \n        # Store in global velocity array\n        velocities[rank_indices, :] = local_velocities\n\n        # Compute a digest of the raw (pre-COM-removal) velocities for this rank\n        digest = hashlib.sha256(local_velocities.tobytes()).hexdigest()\n        rank_digests.append(digest)\n\n    # 4. Validate independence of random streams via digests\n    # All non-empty ranks should have generated unique velocity blocks\n    are_digests_distinct = (len(set(rank_digests)) == len(rank_digests))\n\n    # 5. Perform global COM velocity removal\n    total_mass = np.sum(masses)\n    \n    # Check for division by zero\n    if total_mass > 0:\n        # Calculate initial total momentum (sum over all ranks)\n        # In a real MPI code, this would be a sum-reduction\n        total_momentum = np.sum(velocities * masses[:, np.newaxis], axis=0)\n\n        # Calculate center-of-mass velocity\n        com_velocity = total_momentum / total_mass\n\n        # Subtract COM velocity from all particles\n        # In a real MPI code, V_com would be broadcast to all ranks\n        velocities_prime = velocities - com_velocity\n    else: # Handle case of zero total mass if N=0\n        velocities_prime = velocities\n\n    # 6. Validate momentum constraint\n    # Calculate final total momentum\n    final_total_momentum = np.sum(velocities_prime * masses[:, np.newaxis], axis=0)\n    \n    # Check if max absolute component is within tolerance\n    max_abs_momentum_component = np.max(np.abs(final_total_momentum))\n    is_momentum_zero = max_abs_momentum_component = epsilon\n\n    return [are_digests_distinct, is_momentum_zero, float(max_abs_momentum_component)]\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3405774"}]}