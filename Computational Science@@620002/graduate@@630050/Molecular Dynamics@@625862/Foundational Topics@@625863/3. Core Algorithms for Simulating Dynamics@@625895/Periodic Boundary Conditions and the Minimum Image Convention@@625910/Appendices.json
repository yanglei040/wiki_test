{"hands_on_practices": [{"introduction": "The most direct way to understand the minimum image convention is to implement it for the simplest case: an orthorhombic simulation box. In this scenario, the calculation conveniently decouples into three independent one-dimensional problems, one for each Cartesian axis. This practice [@problem_id:3474216] provides a foundational exercise in deriving and implementing the wrapping logic that forms the basis of all periodic boundary condition calculations.", "problem": "Consider an orthorhombic simulation cell subject to periodic boundary conditions. Let the box edge lengths along the three Cartesian axes be $L_x$, $L_y$, and $L_z$, and let the position vectors of two particles be $\\mathbf{r}_i = (r_{i,x}, r_{i,y}, r_{i,z})$ and $\\mathbf{r}_j = (r_{j,x}, r_{j,y}, r_{j,z})$. The unwrapped displacement is $\\Delta \\mathbf{r} = \\mathbf{r}_j - \\mathbf{r}_i$, with components $\\Delta r_\\alpha$ for $\\alpha \\in \\{x,y,z\\}$. Under periodic boundary conditions, position vectors are equivalent up to integer translations by the box lengths along each axis. The minimum image convention requires choosing a representative displacement for each component such that it lies within a half-open interval of width equal to the box length, centered at zero.\n\nStarting from the definition of periodic boundary conditions and the concept of equivalence classes under integer translations, derive a principled componentwise transformation that, for each axis $\\alpha \\in \\{x,y,z\\}$, selects an integer $n_\\alpha$ so that the wrapped component\n$$\n\\Delta r_\\alpha^{\\mathrm{MIC}} = \\Delta r_\\alpha - n_\\alpha L_\\alpha\n$$\nsatisfies the half-open interval constraint\n$$\n\\Delta r_\\alpha^{\\mathrm{MIC}} \\in \\left[-\\frac{L_\\alpha}{2}, \\frac{L_\\alpha}{2}\\right).\n$$\nExplain how your choice of $n_\\alpha$ enforces the minimum image convention and the interval constraint, including the treatment of boundary cases where $\\Delta r_\\alpha$ is exactly at $\\pm L_\\alpha/2$ or differs from zero by an integer multiple of $L_\\alpha$.\n\nImplement a complete program that:\n- Computes the unwrapped displacements $\\Delta \\mathbf{r}$ for a given set of box lengths and position pairs $(\\mathbf{r}_i,\\mathbf{r}_j)$.\n- Applies the derived componentwise minimum image convention transformation to obtain $\\Delta \\mathbf{r}^{\\mathrm{MIC}}$.\n- Verifies, for each test case, that all three components satisfy $\\Delta r_\\alpha^{\\mathrm{MIC}} \\in \\left[-\\frac{L_\\alpha}{2}, \\frac{L_\\alpha}{2}\\right)$ for $\\alpha=x,y,z$, accounting for floating-point rounding with a physically reasonable tolerance.\n\nAll quantities are given in dimensionless reduced units; no physical unit conversion is required. Angles do not appear in this problem.\n\nUse the following test suite, which is designed to probe general behavior, large translations, and boundary conditions:\n1. $L=(3.0,\\,4.0,\\,5.0)$, $\\mathbf{r}_i=(0.9,\\,-1.9,\\,2.4)$, $\\mathbf{r}_j=(1.1,\\,3.7,\\,-2.6)$.\n2. $L=(10.0,\\,8.0,\\,6.0)$, $\\mathbf{r}_i=(0.0,\\,0.0,\\,0.0)$, $\\mathbf{r}_j=(5.0,\\,-4.0,\\,3.0)$.\n3. $L=(7.0,\\,7.0,\\,7.0)$, $\\mathbf{r}_i=(0.0,\\,0.0,\\,0.0)$, $\\mathbf{r}_j=(24.4,\\,-17.4,\\,35.0)$.\n4. $L=(2.0,\\,3.0,\\,4.0)$, $\\mathbf{r}_i=(0.0,\\,0.0,\\,0.0)$, $\\mathbf{r}_j=(0.0,\\,1.49,\\,-2.01)$.\n5. $L=(5.0,\\,4.0,\\,10.0)$, $\\mathbf{r}_i=(0.0,\\,0.0,\\,0.0)$, $\\mathbf{r}_j=(12.5,\\,-6.0,\\,25.0)$.\n6. $L=(9.3,\\,4.7,\\,2.1)$, $\\mathbf{r}_i=(3.2,\\,-2.35,\\,1.05)$, $\\mathbf{r}_j=(-7.1,\\,5.05,\\,-4.25)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is a boolean indicating whether the wrapped displacement for the corresponding test case satisfies the stated interval constraint for all three components (for example, $[\\mathrm{True},\\mathrm{True},\\ldots]$).", "solution": "The problem requires the derivation and implementation of a componentwise transformation for calculating the displacement vector between two particles, $\\mathbf{r}_i$ and $\\mathbf{r}_j$, in an orthorhombic simulation cell under periodic boundary conditions (PBC). This transformation must adhere to the minimum image convention (MIC), which dictates that the resulting wrapped displacement vector, $\\Delta \\mathbf{r}^{\\mathrm{MIC}}$, corresponds to the shortest distance between particle $j$ and any periodic image of particle $i$.\n\nThe simulation cell is defined by its edge lengths $L_x$, $L_y$, and $L_z$ along the Cartesian axes. Under PBC, a particle at position $\\mathbf{r}$ is equivalent to an infinite set of image particles at positions $\\mathbf{r} + n_x L_x \\hat{\\mathbf{x}} + n_y L_y \\hat{\\mathbf{y}} + n_z L_z \\hat{\\mathbf{z}}$, where $n_x, n_y, n_z$ are any integers.\n\nThe unwrapped displacement vector is given by $\\Delta \\mathbf{r} = \\mathbf{r}_j - \\mathbf{r}_i$. The wrapped displacement vector, $\\Delta \\mathbf{r}^{\\mathrm{MIC}}$, is obtained by choosing a specific periodic image of particle $i$ such that the distance to particle $j$ is minimized. For an orthorhombic cell, this minimization can be performed independently for each Cartesian component.\n\nFor each component $\\alpha \\in \\{x,y,z\\}$, we seek an integer $n_\\alpha$ such that the wrapped displacement component,\n$$\n\\Delta r_\\alpha^{\\mathrm{MIC}} = \\Delta r_\\alpha - n_\\alpha L_\\alpha\n$$\nlies within the specified half-open interval centered at zero:\n$$\n\\Delta r_\\alpha^{\\mathrm{MIC}} \\in \\left[-\\frac{L_\\alpha}{2}, \\frac{L_\\alpha}{2}\\right)\n$$\nBy substituting the definition of $\\Delta r_\\alpha^{\\mathrm{MIC}}$ into the interval constraint, we obtain an inequality for $n_\\alpha$:\n$$\n-\\frac{L_\\alpha}{2} \\le \\Delta r_\\alpha - n_\\alpha L_\\alpha  \\frac{L_\\alpha}{2}\n$$\nWe can solve this compound inequality for $n_\\alpha$. First, we consider the left-hand side:\n$$\n-\\frac{L_\\alpha}{2} \\le \\Delta r_\\alpha - n_\\alpha L_\\alpha\n$$\n$$\nn_\\alpha L_\\alpha \\le \\Delta r_\\alpha + \\frac{L_\\alpha}{2}\n$$\nDividing by $L_\\alpha$ (which is always positive), we get:\n$$\nn_\\alpha \\le \\frac{\\Delta r_\\alpha}{L_\\alpha} + \\frac{1}{2}\n$$\nNext, we consider the right-hand side:\n$$\n\\Delta r_\\alpha - n_\\alpha L_\\alpha  \\frac{L_\\alpha}{2}\n$$\n$$\n\\Delta r_\\alpha - \\frac{L_\\alpha}{2}  n_\\alpha L_\\alpha\n$$\nDividing by $L_\\alpha$ gives:\n$$\n\\frac{\\Delta r_\\alpha}{L_\\alpha} - \\frac{1}{2}  n_\\alpha\n$$\nCombining these two results, we find that the integer $n_\\alpha$ must satisfy:\n$$\n\\frac{\\Delta r_\\alpha}{L_\\alpha} - \\frac{1}{2}  n_\\alpha \\le \\frac{\\Delta r_\\alpha}{L_\\alpha} + \\frac{1}{2}\n$$\nThe width of this interval for $n_\\alpha$ is exactly $1$, i.e., $\\left(\\frac{\\Delta r_\\alpha}{L_\\alpha} + \\frac{1}{2}\\right) - \\left(\\frac{\\Delta r_\\alpha}{L_\\alpha} - \\frac{1}{2}\\right) = 1$. Therefore, for any value of $\\frac{\\Delta r_\\alpha}{L_\\alpha}$, there is a unique integer $n_\\alpha$ that satisfies this condition. This unique integer is found by rounding the quantity $\\frac{\\Delta r_\\alpha}{L_\\alpha}$ to the nearest integer.\n\nThe specific rounding rule must be chosen carefully to respect the semi-open nature of the target interval $\\left[-\\frac{L_\\alpha}{2}, \\frac{L_\\alpha}{2}\\right)$. Let's analyze the boundary case where $\\frac{\\Delta r_\\alpha}{L_\\alpha}$ is exactly halfway between two integers, for instance, $\\frac{\\Delta r_\\alpha}{L_\\alpha} = k + \\frac{1}{2}$ for some integer $k$. Our inequality for $n_\\alpha$ becomes:\n$$\n(k + \\frac{1}{2}) - \\frac{1}{2}  n_\\alpha \\le (k + \\frac{1}{2}) + \\frac{1}{2}\n$$\n$$\nk  n_\\alpha \\le k + 1\n$$\nThe unique integer solution is $n_\\alpha = k+1$. This means that values of the form $k + \\frac{1}{2}$ must be rounded up to the next integer, $k+1$. This rounding behavior (round half up) is achieved by the floor function:\n$$\nn_\\alpha = \\left\\lfloor \\frac{\\Delta r_\\alpha}{L_\\alpha} + \\frac{1}{2} \\right\\rfloor\n$$\nThis formula correctly determines the integer multiple of the box length to subtract. For example, if $\\Delta r_\\alpha = \\frac{L_\\alpha}{2}$, then $\\frac{\\Delta r_\\alpha}{L_\\alpha} = \\frac{1}{2}$. Our formula gives $n_\\alpha = \\lfloor \\frac{1}{2} + \\frac{1}{2} \\rfloor = \\lfloor 1 \\rfloor = 1$. The resulting wrapped component is $\\Delta r_\\alpha^{\\mathrm{MIC}} = \\frac{L_\\alpha}{2} - 1 \\cdot L_\\alpha = -\\frac{L_\\alpha}{2}$, which correctly lies on the inclusive lower bound of the interval. If $\\Delta r_\\alpha$ is slightly less than $\\frac{L_\\alpha}{2}$, say $\\frac{L_\\alpha}{2} - \\epsilon$, then $\\frac{\\Delta r_\\alpha}{L_\\alpha} = \\frac{1}{2} - \\frac{\\epsilon}{L_\\alpha}$. The formula gives $n_\\alpha = \\lfloor (\\frac{1}{2} - \\frac{\\epsilon}{L_\\alpha}) + \\frac{1}{2} \\rfloor = \\lfloor 1 - \\frac{\\epsilon}{L_\\alpha} \\rfloor = 0$. The wrapped component is $\\Delta r_\\alpha^{\\mathrm{MIC}} = (\\frac{L_\\alpha}{2} - \\epsilon) - 0 = \\frac{L_\\alpha}{2} - \\epsilon$, which is correctly inside the interval. This demonstrates that the derived choice of $n_\\alpha$ correctly enforces the minimum image convention and the half-open interval constraint.\n\nThe implementation will first compute the unwrapped displacement components $\\Delta r_\\alpha$. Then, for each component, it will calculate the corresponding integer $n_\\alpha = \\lfloor \\frac{\\Delta r_\\alpha}{L_\\alpha} + 0.5 \\rfloor$. Finally, it will compute the wrapped displacement $\\Delta r_\\alpha^{\\mathrm{MIC}} = \\Delta r_\\alpha - n_\\alpha L_\\alpha$. The verification step checks if $-L_\\alpha/2 \\le \\Delta r_\\alpha^{\\mathrm{MIC}}  L_\\alpha/2$ for all three components, using a small numerical tolerance to handle floating-point inaccuracies.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the periodic boundary condition problem for a given set of test cases.\n    It derives and applies the minimum image convention transformation and verifies\n    that the resulting wrapped displacement vectors fall within the specified\n    half-open interval.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (L, r_i, r_j)\n        (np.array([3.0, 4.0, 5.0]), np.array([0.9, -1.9, 2.4]), np.array([1.1, 3.7, -2.6])),\n        (np.array([10.0, 8.0, 6.0]), np.array([0.0, 0.0, 0.0]), np.array([5.0, -4.0, 3.0])),\n        (np.array([7.0, 7.0, 7.0]), np.array([0.0, 0.0, 0.0]), np.array([24.4, -17.4, 35.0])),\n        (np.array([2.0, 3.0, 4.0]), np.array([0.0, 0.0, 0.0]), np.array([0.0, 1.49, -2.01])),\n        (np.array([5.0, 4.0, 10.0]), np.array([0.0, 0.0, 0.0]), np.array([12.5, -6.0, 25.0])),\n        (np.array([9.3, 4.7, 2.1]), np.array([3.2, -2.35, 1.05]), np.array([-7.1, 5.05, -4.25])),\n    ]\n\n    results = []\n    # A small tolerance for floating-point comparisons.\n    epsilon = 1e-9\n\n    for L, r_i, r_j in test_cases:\n        # Step 1: Compute the unwrapped displacement vector.\n        delta_r = r_j - r_i\n\n        # Step 2: Apply the derived componentwise minimum image convention (MIC) transformation.\n        # The integer n_alpha is chosen such that the wrapped displacement satisfies\n        # delta_r_mic_alpha is in [-L_alpha/2, L_alpha/2).\n        # This is achieved by n = floor(delta_r / L + 0.5)\n        \n        # In NumPy, this is equivalent to np.floor(delta_r / L + 0.5).\n        n_vector = np.floor(delta_r / L + 0.5)\n        \n        delta_r_mic = delta_r - n_vector * L\n\n        # Step 3: Verify that the wrapped displacement components satisfy the interval constraint.\n        # The condition is -L/2 = delta_r_mic  L/2.\n        half_L = L / 2.0\n\n        # Check lower bound: delta_r_mic >= -half_L\n        # With tolerance: delta_r_mic - (-half_L) >= -epsilon\n        lower_bound_check = (delta_r_mic + half_L) >= -epsilon\n\n        # Check upper bound: delta_r_mic  half_L\n        # With tolerance: half_L - delta_r_mic > epsilon\n        upper_bound_check = (half_L - delta_r_mic) > epsilon\n\n        # The result is True only if all components satisfy both constraints.\n        is_valid = np.all(lower_bound_check) and np.all(upper_bound_check)\n        results.append(is_valid)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3474216"}, {"introduction": "While component-wise wrapping works for orthorhombic cells, this intuition breaks down in skewed, or triclinic, systems where the lattice vectors are not orthogonal. This exercise [@problem_id:3435070] demonstrates the failure of a naive Cartesian approach and introduces the correct, general method using fractional coordinates and the cell matrix, $\\mathbf{H}$. Mastering this technique is essential for simulating a wide range of crystalline materials.", "problem": "A molecular dynamics simulation employs Periodic Boundary Conditions (PBC) in a skewed triclinic cell. Let the Bravais lattice be generated by the lattice vectors $\\mathbf{a}_1$, $\\mathbf{a}_2$, and $\\mathbf{a}_3$ assembled as columns of the cell matrix $\\mathbf{H}$. Two particles at Cartesian positions $\\mathbf{r}_i$ and $\\mathbf{r}_j$ interact via the Minimum Image Convention (MIC), which, by definition, selects the shortest Euclidean separation vector among all lattice images. In a skewed cell, naive component-wise wrapping in Cartesian coordinates may fail to identify the true minimum image.\n\nConsider the skewed cell defined by\n$$\n\\mathbf{a}_1 = \\begin{pmatrix} 10 \\\\ 0 \\\\ 0 \\end{pmatrix},\\quad\n\\mathbf{a}_2 = \\begin{pmatrix} 4 \\\\ 8 \\\\ 0 \\end{pmatrix},\\quad\n\\mathbf{a}_3 = \\begin{pmatrix} 0 \\\\ 0 \\\\ 10 \\end{pmatrix},\n$$\nso that $\\mathbf{H} = \\begin{pmatrix} 10  4  0 \\\\ 0  8  0 \\\\ 0  0  10 \\end{pmatrix}$. Let the two particle positions (in Cartesian coordinates, in angstroms) be\n$$\n\\mathbf{r}_i = \\begin{pmatrix} 4.5 \\\\ 7.5 \\\\ 1.0 \\end{pmatrix},\\qquad\n\\mathbf{r}_j = \\begin{pmatrix} 0.5 \\\\ 1.0 \\\\ 1.5 \\end{pmatrix}.\n$$\n\n1. Using a naive component-wise wrapping that treats the box as orthorhombic with lengths $L_x = 10$, $L_y = 8$, and $L_z = 10$ (i.e., independently wrapping each Cartesian component of $\\mathbf{r}_j - \\mathbf{r}_i$ into $(-L_\\alpha/2, L_\\alpha/2]$ for $\\alpha \\in \\{x,y,z\\}$), compute the resulting wrapped separation vector and its Euclidean norm. Briefly explain why this procedure can fail in skewed cells.\n\n2. Starting from first principles of PBC and MIC, namely that images differ by integer lattice translations and the minimum image distance is\n$$\n\\min_{\\mathbf{n}\\in\\mathbb{Z}^3} \\left\\| \\left(\\mathbf{r}_j - \\mathbf{r}_i\\right) + \\mathbf{H}\\,\\mathbf{n} \\right\\|_2,\n$$\nderive and apply the metric-based approach: introduce fractional coordinates $\\mathbf{s}$ via $\\left(\\mathbf{r}_j - \\mathbf{r}_i\\right) = \\mathbf{H}\\,\\mathbf{s}$, express the squared distance as a quadratic form involving the metric tensor $\\mathbf{G} = \\mathbf{H}^{\\mathsf{T}}\\mathbf{H}$, and determine the integer vector $\\mathbf{m}\\in\\mathbb{Z}^3$ that minimizes $\\|\\mathbf{H}(\\mathbf{s}+\\mathbf{m})\\|_2$. Explicitly compute the corrected minimum image separation vector and its Euclidean norm.\n\nReport only the corrected minimum image distance magnitude. Round your answer to four significant figures. Express the final distance in angstroms.", "solution": "The problem requires the calculation of the minimum image distance between two particles in a skewed triclinic cell. Before proceeding to the solution, a validation of the problem statement is necessary.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n- Cell lattice vectors:\n$$\n\\mathbf{a}_1 = \\begin{pmatrix} 10 \\\\ 0 \\\\ 0 \\end{pmatrix},\\quad\n\\mathbf{a}_2 = \\begin{pmatrix} 4 \\\\ 8 \\\\ 0 \\end{pmatrix},\\quad\n\\mathbf{a}_3 = \\begin{pmatrix} 0 \\\\ 0 \\\\ 10 \\end{pmatrix}\n$$\n- Cell matrix $\\mathbf{H}$:\n$$\n\\mathbf{H} = \\begin{pmatrix} 10  4  0 \\\\ 0  8  0 \\\\ 0  0  10 \\end{pmatrix}\n$$\n- Particle Cartesian positions (in angstroms):\n$$\n\\mathbf{r}_i = \\begin{pmatrix} 4.5 \\\\ 7.5 \\\\ 1.0 \\end{pmatrix},\\quad\n\\mathbf{r}_j = \\begin{pmatrix} 0.5 \\\\ 1.0 \\\\ 1.5 \\end{pmatrix}\n$$\n- Definition of the naive component-wise wrapping: wrap each Cartesian component of $\\mathbf{r}_j - \\mathbf{r}_i$ into $(-L_\\alpha/2, L_\\alpha/2]$ for $\\alpha \\in \\{x,y,z\\}$, using $L_x = 10$, $L_y = 8$, $L_z = 10$.\n- Definition of the Minimum Image Convention (MIC): find the minimum of $\\| (\\mathbf{r}_j - \\mathbf{r}_i) + \\mathbf{H}\\,\\mathbf{n} \\|_2$ over all integer vectors $\\mathbf{n}\\in\\mathbb{Z}^3$.\n- Procedure for the correct method: use fractional coordinates $\\mathbf{s}$ where $(\\mathbf{r}_j - \\mathbf{r}_i) = \\mathbf{H}\\,\\mathbf{s}$, relate the squared distance to the metric tensor $\\mathbf{G} = \\mathbf{H}^{\\mathsf{T}}\\mathbf{H}$, and find the integer vector $\\mathbf{m}$ that minimizes $\\|\\mathbf{H}(\\mathbf{s}+\\mathbf{m})\\|_2$.\n\n**Step 2: Validate Using Extracted Givens**\n- **Scientifically Grounded:** The problem is firmly based on the standard and fundamental principles of molecular dynamics simulations, specifically the implementation of Periodic Boundary Conditions (PBC) and the Minimum Image Convention (MIC) for non-orthorhombic (triclinic) simulation cells. The use of fractional coordinates and the metric tensor is a standard technique in solid-state physics and computational materials science.\n- **Well-Posed:** All necessary data (lattice vectors, particle positions) are provided. The objective is clearly stated: to compute the minimum image distance, contrasting a naive method with the correct one. The existence and uniqueness of a minimum image distance are guaranteed.\n- **Objective:** The problem is stated in precise, formal mathematical and physical language, free of ambiguity or subjective claims.\n\n**Step 3: Verdict and Action**\nThe problem is valid. A complete solution will now be provided.\n\n### Solution\n\nThe problem asks for the minimum image distance between two particles, first considering a naive approach and then the correct, rigorous approach for a skewed cell.\n\nThe raw separation vector in Cartesian coordinates is:\n$$\n\\mathbf{r}_{ij} = \\mathbf{r}_j - \\mathbf{r}_i = \\begin{pmatrix} 0.5 - 4.5 \\\\ 1.0 - 7.5 \\\\ 1.5 - 1.0 \\end{pmatrix} = \\begin{pmatrix} -4.0 \\\\ -6.5 \\\\ 0.5 \\end{pmatrix}\n$$\nUnits are in angstroms.\n\n**1. Naive Component-wise Wrapping**\n\nThis method incorrectly treats the skewed cell as an orthorhombic box with side lengths equal to the diagonal elements of $\\mathbf{H}$: $L_x=10$, $L_y=8$, and $L_z=10$. The wrapping for each component $\\Delta r_\\alpha$ is $\\Delta r_{\\alpha}' = \\Delta r_\\alpha - L_\\alpha \\cdot \\text{round}(\\Delta r_\\alpha / L_\\alpha)$.\n\n- $x$-component: $\\Delta r_x' = -4.0 - 10 \\cdot \\text{round}(-4.0/10) = -4.0 - 10 \\cdot 0 = -4.0$.\n- $y$-component: $\\Delta r_y' = -6.5 - 8 \\cdot \\text{round}(-6.5/8) = -6.5 - 8 \\cdot (-1) = 1.5$.\n- $z$-component: $\\Delta r_z' = 0.5 - 10 \\cdot \\text{round}(0.5/10) = 0.5 - 10 \\cdot 0 = 0.5$.\n\nThe naive separation vector is $\\Delta\\mathbf{r}_{\\text{naive}} = \\begin{pmatrix} -4.0 \\\\ 1.5 \\\\ 0.5 \\end{pmatrix}$. Its squared norm is $(-4.0)^2 + (1.5)^2 + (0.5)^2 = 16 + 2.25 + 0.25 = 18.5$. The distance is $\\sqrt{18.5} \\approx 4.301$ Å.\n\nThis procedure is incorrect because it ignores the off-diagonal elements of the cell matrix $\\mathbf{H}$, in this case $H_{12}=4$. It assumes the lattice vectors are orthogonal, which they are not since $\\mathbf{a}_1 \\cdot \\mathbf{a}_2 = 40 \\neq 0$. Applying PBC requires translating by integer combinations of the true lattice vectors $\\mathbf{a}_1, \\mathbf{a}_2, \\mathbf{a}_3$, not by vectors aligned with the Cartesian axes.\n\n**2. Correct Metric-Based Approach**\n\nThe MIC consists of finding an integer vector $\\mathbf{m} \\in \\mathbb{Z}^3$ such that the vector $\\Delta\\mathbf{r}_{\\text{min}} = \\mathbf{r}_{ij} + \\mathbf{H}\\mathbf{m}$ has the minimum possible Euclidean norm.\n\nTo solve this, we transform the problem into the space of fractional coordinates, $\\mathbf{s}$. The Cartesian separation vector $\\mathbf{r}_{ij}$ is related to its fractional counterpart $\\mathbf{s}$ by $\\mathbf{r}_{ij} = \\mathbf{H}\\mathbf{s}$. Thus, $\\mathbf{s} = \\mathbf{H}^{-1}\\mathbf{r}_{ij}$.\n\nFirst, we must compute the inverse of the cell matrix $\\mathbf{H}$:\n$$\n\\mathbf{H} = \\begin{pmatrix} 10  4  0 \\\\ 0  8  0 \\\\ 0  0  10 \\end{pmatrix}\n$$\nFor an upper triangular matrix, the inverse is also upper triangular. We solve $\\mathbf{H}\\mathbf{s} = \\mathbf{r}_{ij}$:\n$10s_1 + 4s_2 = r_{ij,x}$\n$8s_2 = r_{ij,y}$\n$10s_3 = r_{ij,z}$\nSolving for $\\mathbf{s}$ in terms of $\\mathbf{r}_{ij}$ gives:\n$s_3 = r_{ij,z}/10$\n$s_2 = r_{ij,y}/8$\n$s_1 = (r_{ij,x} - 4s_2)/10 = r_{ij,x}/10 - 4/10 \\cdot r_{ij,y}/8 = r_{ij,x}/10 - r_{ij,y}/20$.\nThis corresponds to the inverse matrix:\n$$\n\\mathbf{H}^{-1} = \\begin{pmatrix} 1/10  -1/20  0 \\\\ 0  1/8  0 \\\\ 0  0  1/10 \\end{pmatrix} = \\begin{pmatrix} 0.1  -0.05  0 \\\\ 0  0.125  0 \\\\ 0  0  0.1 \\end{pmatrix}\n$$\nNow, we compute the fractional separation vector $\\mathbf{s}$:\n$$\n\\mathbf{s} = \\mathbf{H}^{-1}\\mathbf{r}_{ij} = \\begin{pmatrix} 0.1  -0.05  0 \\\\ 0  0.125  0 \\\\ 0  0  0.1 \\end{pmatrix} \\begin{pmatrix} -4.0 \\\\ -6.5 \\\\ 0.5 \\end{pmatrix} = \\begin{pmatrix} 0.1(-4.0) - 0.05(-6.5) \\\\ 0.125(-6.5) \\\\ 0.1(0.5) \\end{pmatrix} = \\begin{pmatrix} -0.4 + 0.325 \\\\ -0.8125 \\\\ 0.05 \\end{pmatrix} = \\begin{pmatrix} -0.075 \\\\ -0.8125 \\\\ 0.05 \\end{pmatrix}\n$$\nThe vector to be minimized is $\\Delta \\mathbf{r} = \\mathbf{H}(\\mathbf{s} + \\mathbf{m})$. The squared distance is $d^2 = \\|\\Delta \\mathbf{r}\\|^2 = \\Delta \\mathbf{r}^{\\mathsf{T}}\\Delta \\mathbf{r} = (\\mathbf{s}+\\mathbf{m})^{\\mathsf{T}}\\mathbf{H}^{\\mathsf{T}}\\mathbf{H}(\\mathbf{s}+\\mathbf{m}) = (\\mathbf{s}+\\mathbf{m})^{\\mathsf{T}}\\mathbf{G}(\\mathbf{s}+\\mathbf{m})$, where $\\mathbf{G} = \\mathbf{H}^{\\mathsf{T}}\\mathbf{H}$ is the metric tensor. The vector $\\mathbf{m}$ is chosen to bring the components of $\\mathbf{s}+\\mathbf{m}$ into the central image, conventionally defined by the interval $[-0.5, 0.5]$. This is achieved by setting each component $m_k$ of the integer vector $\\mathbf{m}$ to the negative of the nearest integer to the corresponding component $s_k$:\n$$\nm_k = -\\text{round}(s_k)\n$$\nFor our fractional vector $\\mathbf{s}$:\n- $m_1 = -\\text{round}(-0.075) = -0 = 0$\n- $m_2 = -\\text{round}(-0.8125) = -(-1) = 1$\n- $m_3 = -\\text{round}(0.05) = -0 = 0$\nSo, the integer vector for the translation is $\\mathbf{m} = \\begin{pmatrix} 0  1  0 \\end{pmatrix}^{\\mathsf{T}}$.\n\nThe wrapped fractional vector, $\\mathbf{s}' = \\mathbf{s} + \\mathbf{m}$, is:\n$$\n\\mathbf{s}' = \\begin{pmatrix} -0.075 \\\\ -0.8125 \\\\ 0.05 \\end{pmatrix} + \\begin{pmatrix} 0 \\\\ 1 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} -0.075 \\\\ 0.1875 \\\\ 0.05 \\end{pmatrix}\n$$\nFinally, we convert this minimum image fractional vector back to Cartesian coordinates to obtain the minimum image separation vector $\\Delta\\mathbf{r}_{\\text{min}}$:\n$$\n\\Delta\\mathbf{r}_{\\text{min}} = \\mathbf{H}\\mathbf{s}' = \\begin{pmatrix} 10  4  0 \\\\ 0  8  0 \\\\ 0  0  10 \\end{pmatrix} \\begin{pmatrix} -0.075 \\\\ 0.1875 \\\\ 0.05 \\end{pmatrix} = \\begin{pmatrix} 10(-0.075) + 4(0.1875) \\\\ 8(0.1875) \\\\ 10(0.05) \\end{pmatrix} = \\begin{pmatrix} -0.75 + 0.75 \\\\ 1.5 \\\\ 0.5 \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 1.5 \\\\ 0.5 \\end{pmatrix}\n$$\nThe corrected minimum image distance is the Euclidean norm of this vector:\n$$\nd_{\\text{min}} = \\|\\Delta\\mathbf{r}_{\\text{min}}\\|_2 = \\sqrt{0^2 + (1.5)^2 + (0.5)^2} = \\sqrt{0 + 2.25 + 0.25} = \\sqrt{2.5}\n$$\nThe numerical value is $d_{\\text{min}} \\approx 1.5811388...$ Å. Rounding to four significant figures gives $1.581$ Å. This distance is significantly smaller than the one obtained by the naive method, illustrating the importance of the correct procedure.", "answer": "$$ \\boxed{1.581} $$", "id": "3435070"}, {"introduction": "A correct algorithm must not only be mathematically sound but also numerically robust, preserving fundamental physical laws like Newton's third law. This practice [@problem_id:3435077] addresses the subtle but critical issue of handling particle separations at exactly half the box length, where naive implementations can break symmetry due to floating-point ambiguities. You will design a deterministic strategy that guarantees force antisymmetry, $\\mathbf{F}_{ij} = -\\mathbf{F}_{ji}$, under all conditions.", "problem": "Consider a system of point particles in a cubic simulation box with periodic boundary conditions. Let the box length be $L$, and let the particle positions be vectors $\\mathbf{x}_i \\in [0,L)^3$. Under periodic boundary conditions, each particle has an infinite set of images translated by integer multiples of $L$ along each Cartesian direction. The minimum image convention selects the unique displacement vector $\\mathbf{r}_{ij}$ between particles $i$ and $j$ that minimizes the Euclidean norm, where $\\mathbf{r}_{ij} = \\mathbf{x}_i - \\mathbf{x}_j - L \\mathbf{n}$ for some integer vector $\\mathbf{n} \\in \\mathbb{Z}^3$ chosen to minimize $\\|\\mathbf{r}_{ij}\\|$.\n\nThe classical force between two particles interacting via a pair potential $U(r)$ depends on the separation $r = \\|\\mathbf{r}_{ij}\\|$ and obeys Newton's third law. For the Lennard–Jones potential in reduced units, with energy scale $\\epsilon = 1$ and size scale $\\sigma = 1$, the potential is $U(r) = 4 \\left( r^{-12} - r^{-6} \\right)$, and the force on particle $i$ due to particle $j$ is $\\mathbf{F}_{ij} = - \\nabla_{\\mathbf{x}_i} U(\\|\\mathbf{r}_{ij}\\|)$.\n\nWhen two particles are separated by exactly half a box length in one or more dimensions, i.e., when a displacement component satisfies $|x_{i,k} - x_{j,k}| = L/2$ for some Cartesian index $k \\in \\{1,2,3\\}$, the minimum image convention admits two equally valid choices differing by sign for that component ($+L/2$ and $-L/2$). Numerical implementations rely on floating-point arithmetic governed by the Institute of Electrical and Electronics Engineers (IEEE) standard, where rounding modes and representability can cause ties at half-box separations to resolve inconsistently, potentially breaking determinism and Newton’s third law symmetry $\\mathbf{F}_{ij} = -\\mathbf{F}_{ji}$.\n\nYour task is to design and implement a strategy that guarantees deterministic and symmetric force calculations under the minimum image convention when one or more components of the displacement are exactly half a box length, while accounting for IEEE rounding behavior. You must start from the following foundational bases:\n- Newton’s laws of motion, including Newton’s third law stating that for every force $\\mathbf{F}_{ij}$ there is an equal and opposite force $\\mathbf{F}_{ji} = -\\mathbf{F}_{ij}$.\n- The definition of periodic boundary conditions and the minimum image convention.\n- The definition of the Lennard–Jones potential in reduced units.\n- Floating-point arithmetic properties with IEEE representability and rounding, including the notion of a unit in the last place.\n\nYou must produce a complete, runnable program that:\n- Implements a minimum image mapping for each Cartesian component that yields an antisymmetric displacement vector, i.e., for any pair of particles $i$ and $j$, $\\mathbf{r}_{ij} = -\\mathbf{r}_{ji}$ exactly under your mapping, including at half-box ties.\n- Uses a deterministic tie-breaking policy that is independent of library rounding idiosyncrasies and consistent across particle orderings $i,j$ and $j,i$.\n- Detects half-box ties robustly by comparing to $L/2$ using a tolerance based on the unit in the last place near $L/2$ so that representability and rounding are handled predictably.\n\nThen, using your minimum image mapping and the Lennard–Jones force in reduced units ($\\epsilon = 1$, $\\sigma = 1$), evaluate the following test suite of particle pairs in cubic boxes. For each test case, compute $\\mathbf{F}_{ij}$ and $\\mathbf{F}_{ji}$ and report whether Newton’s third law is satisfied to within a tolerance of $1\\times 10^{-12}$ in each Cartesian component.\n\nTest suite (each case is a tuple $(L,\\mathbf{x}_i,\\mathbf{x}_j)$, with components in reduced units):\n- Case $1$: $L = 10$, $\\mathbf{x}_i = (1.1,2.2,3.3)$, $\\mathbf{x}_j = (9.9,2.2,3.3)$.\n- Case $2$: $L = 10$, $\\mathbf{x}_i = (0.0,0.0,0.0)$, $\\mathbf{x}_j = (5.0,1.0,1.0)$.\n- Case $3$: $L = 10$, $\\mathbf{x}_i = (5.0,5.0,0.0)$, $\\mathbf{x}_j = (0.0,0.0,0.0)$.\n- Case $4$: $L = 10$, $\\mathbf{x}_i = (5.0,0.0,0.0)$, $\\mathbf{x}_j = (0.0,0.0,0.0)$.\n- Case $5$: $L = 7$, $\\mathbf{x}_i = (3.5,3.5,0.0)$, $\\mathbf{x}_j = (0.0,0.0,0.0)$.\n- Case $6$: $L = 10$, $\\mathbf{x}_i = (\\text{next representable after } 5.0 \\text{ toward } +\\infty, 0.0, 0.0)$, $\\mathbf{x}_j = (0.0,0.0,0.0)$.\n- Case $7$: $L = 10$, $\\mathbf{x}_i = (\\text{next representable before } 5.0 \\text{ toward } -\\infty, 0.0, 0.0)$, $\\mathbf{x}_j = (0.0,0.0,0.0)$.\n- Case $8$: $L = 10$, $\\mathbf{x}_i = (5.0,5.0,5.0)$, $\\mathbf{x}_j = (0.0,0.0,0.0)$.\n\nYour program should compute the Lennard–Jones forces in reduced units ($\\epsilon = 1$, $\\sigma = 1$) for each case and determine whether $\\mathbf{F}_{ij} + \\mathbf{F}_{ji} = \\mathbf{0}$ holds componentwise within the tolerance $1\\times 10^{-12}$. The final output format must be a single line containing the results as a comma-separated list of booleans enclosed in square brackets, e.g., $[\\text{result}_1,\\text{result}_2,\\dots,\\text{result}_8]$. No units conversion is required because all quantities are dimensionless reduced units, and no angles are involved. The program must be self-contained and require no external input.", "solution": "The problem statement is scientifically sound, well-posed, and objective. It addresses a genuine and critical issue in computational physics related to the implementation of periodic boundary conditions and the minimum image convention, specifically the need to preserve Newton's third law in the presence of floating-point arithmetic ambiguities. The problem is valid, and a solution can be constructed based on fundamental principles.\n\nThe core of the problem lies in satisfying Newton's third law for forces between pairs of particles, which states that the force exerted by particle $j$ on particle $i$, $\\mathbf{F}_{ij}$, must be equal and opposite to the force exerted by particle $i$ on particle $j$, $\\mathbf{F}_{ji}$. That is, $\\mathbf{F}_{ij} = -\\mathbf{F}_{ji}$.\n\nThe force $\\mathbf{F}_{ij}$ is derived from the pair potential $U(r)$ as $\\mathbf{F}_{ij} = -\\nabla_{\\mathbf{x}_i} U(\\|\\mathbf{r}_{ij}\\|)$, where $\\mathbf{r}_{ij}$ is the minimum image displacement vector. This expression can be expanded using the chain rule:\n$$\n\\mathbf{F}_{ij} = - \\frac{d U}{dr} \\frac{\\partial r}{\\partial \\mathbf{x}_i} = - \\frac{d U}{dr} \\frac{\\mathbf{r}_{ij}}{r_{ij}}\n$$\nwhere $r_{ij} = \\|\\mathbf{r}_{ij}\\|$. Let us define a scalar function $S(r^2) = -\\frac{1}{r} \\frac{dU}{dr}$. The force vector can then be written as $\\mathbf{F}_{ij} = S(r_{ij}^2) \\mathbf{r}_{ij}$. For the Lennard-Jones potential in reduced units, $U(r) = 4(r^{-12} - r^{-6})$, the force expression becomes:\n$$\n\\mathbf{F}_{ij} = \\left( 48 r_{ij}^{-14} - 24 r_{ij}^{-8} \\right) \\mathbf{r}_{ij}\n$$\nThe scalar prefactor, $(48 r_{ij}^{-14} - 24 r_{ij}^{-8})$, depends only on the squared distance $r_{ij}^2 = \\mathbf{r}_{ij} \\cdot \\mathbf{r}_{ij}$. For Newton's third law to hold, we require $\\mathbf{F}_{ji} = -\\mathbf{F}_{ij}$. Let's examine the expression for $\\mathbf{F}_{ji}$:\n$$\n\\mathbf{F}_{ji} = \\left( 48 r_{ji}^{-14} - 24 r_{ji}^{-8} \\right) \\mathbf{r}_{ji}\n$$\nSymmetry is upheld if two conditions are met:\n$1$. The squared distance is independent of particle order: $r_{ij}^2 = r_{ji}^2$.\n$2$. The displacement vector is antisymmetric: $\\mathbf{r}_{ij} = -\\mathbf{r}_{ji}$.\n\nIf $\\mathbf{r}_{ij} = -\\mathbf{r}_{ji}$, then $r_{ij}^2 = \\mathbf{r}_{ij} \\cdot \\mathbf{r}_{ij} = (-\\mathbf{r}_{ji}) \\cdot (-\\mathbf{r}_{ji}) = \\mathbf{r}_{ji} \\cdot \\mathbf{r}_{ji} = r_{ji}^2$. The first condition holds. The scalar prefactor is identical for both forces. The second condition then leads to:\n$$\n\\mathbf{F}_{ji} = S(r_{ji}^2) \\mathbf{r}_{ji} = S(r_{ij}^2) (-\\mathbf{r}_{ij}) = - (S(r_{ij}^2) \\mathbf{r}_{ij}) = -\\mathbf{F}_{ij}\n$$\nThus, the entire requirement for satisfying Newton's third law reduces to designing a minimum image convention (MIC) mapping, let's call it $f$, that is strictly antisymmetric (i.e., an odd function) for any raw displacement vector $\\Delta\\mathbf{x} = \\mathbf{x}_i - \\mathbf{x}_j$. That is, $\\mathbf{r}_{ij} = f(\\mathbf{x}_i - \\mathbf{x}_j)$ must satisfy $f(\\Delta\\mathbf{x}) = -f(-\\Delta\\mathbf{x})$.\n\nThe raw displacement $\\Delta\\mathbf{x}_{ji} = \\mathbf{x}_j - \\mathbf{x}_i$ is always the exact negative of $\\Delta\\mathbf{x}_{ij} = \\mathbf{x}_i - \\mathbf{x}_j$ in floating-point arithmetic. Therefore, we need to ensure our component-wise mapping $f_k$ for each Cartesian component is an odd function. The challenge arises at the boundaries of the domain $[-L/2, L/2]$. A common but flawed approach, `dx - L * round(dx/L)`, fails this test because the behavior of standard `round()` functions at half-integer values (e.g., `round(0.5)` vs. `round(-0.5)`) can break the odd-function property, depending on the rounding mode (e.g., round-half-to-even).\n\nA robust and correct strategy is to define a mapping that is explicitly odd by construction. We will define the minimum image displacement to be in the closed interval $[-L/2, L/2]$. A component-wise algorithm to achieve this is:\nFor each component $\\Delta x_k$ of the raw displacement $\\Delta\\mathbf{x}$:\n$1$. Let $L_{half} = L/2$.\n$2$. If $\\Delta x_k  L_{half}$, the minimum image component is $r_k = \\Delta x_k - L$.\n$3$. Else if $\\Delta x_k  -L_{half}$, the minimum image component is $r_k = \\Delta x_k + L$.\n$4$. Otherwise (i.e., if $-L_{half} \\le \\Delta x_k \\le L_{half}$), the minimum image component is $r_k = \\Delta x_k$.\n\nLet's verify that this mapping, $f_k(\\Delta x_k) = r_k$, is an odd function.\n- If $|\\Delta x_k|  L/2$, then $f_k(\\Delta x_k) = \\Delta x_k$. For the swapped pair, $-\\Delta x_k$ is also in this range, so $f_k(-\\Delta x_k) = -\\Delta x_k = -f_k(\\Delta x_k)$, which is odd.\n- If $\\Delta x_k  L/2$, then $f_k(\\Delta x_k) = \\Delta x_k - L$. For the swapped pair, $-\\Delta x_k  -L/2$, so $f_k(-\\Delta x_k) = -\\Delta x_k + L = -(\\Delta x_k - L) = -f_k(\\Delta x_k)$, which is odd.\n- If $\\Delta x_k = L/2$, the 'otherwise' branch is taken, so $f_k(L/2) = L/2$. For the swapped pair, $\\Delta x_k = -L/2$, and the 'otherwise' branch is again taken, yielding $f_k(-L/2) = -L/2$. Thus, $f_k(-L/2) = -f_k(L/2)$, which is odd.\n\nThis logical structure is deterministic, avoids platform-dependent rounding functions, and does not require fragile equality checks against $L/2$. The prompt's mention of using a tolerance based on the unit in the last place (ULP) is a technique to robustify implementations that rely on such equality checks. Our design sidesteps this fragility altogether by using only inequalities, which are well-defined and deterministic in IEEE $754$ arithmetic. This constitutes a fully deterministic and symmetric strategy for any pair of particles, fulfilling all requirements of the problem.\n\nThe following program implements this robust MIC mapping. It then computes the Lennard-Jones forces for particle pairs $(i, j)$ and $(j, i)$ for each test case and verifies that their sum is zero within the specified tolerance, which should hold true for all cases due to the guaranteed antisymmetry of the displacement vectors.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of ensuring Newton's third law in periodic boundary conditions.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: Standard case\n        (10.0, np.array([1.1, 2.2, 3.3]), np.array([9.9, 2.2, 3.3])),\n        # Case 2: One component at half-box length\n        (10.0, np.array([0.0, 0.0, 0.0]), np.array([5.0, 1.0, 1.0])),\n        # Case 3: Two components at half-box length\n        (10.0, np.array([5.0, 5.0, 0.0]), np.array([0.0, 0.0, 0.0])),\n        # Case 4: One component at half-box length (swapped from Case 2)\n        (10.0, np.array([5.0, 0.0, 0.0]), np.array([0.0, 0.0, 0.0])),\n        # Case 5: L/2 is exactly representable\n        (7.0, np.array([3.5, 3.5, 0.0]), np.array([0.0, 0.0, 0.0])),\n        # Case 6: Displacement slightly > L/2 due to float representation\n        (10.0, np.array([np.nextafter(5.0, np.inf), 0.0, 0.0]), np.array([0.0, 0.0, 0.0])),\n        # Case 7: Displacement slightly  L/2 due to float representation\n        (10.0, np.array([np.nextafter(5.0, -np.inf), 0.0, 0.0]), np.array([0.0, 0.0, 0.0])),\n        # Case 8: All three components at half-box length\n        (10.0, np.array([5.0, 5.0, 5.0]), np.array([0.0, 0.0, 0.0])),\n    ]\n\n    results = []\n    \n    def get_mic_vector(delta_r, box_L):\n        \"\"\"\n        Calculates the minimum image convention vector.\n        This implementation is deterministic and guarantees r_ij = -r_ji.\n        It maps the displacement into the interval [-L/2, L/2].\n        \"\"\"\n        half_L = box_L / 2.0\n        # This nested np.where is equivalent to the robust if/elif/else logic.\n        # if dr > half_L: dr -= L\n        # elif dr  -half_L: dr += L\n        # else: dr = dr\n        return np.where(delta_r > half_L, delta_r - box_L, \n                        np.where(delta_r  -half_L, delta_r + box_L, delta_r))\n\n    def get_lj_force(r_vec):\n        \"\"\"\n        Computes the Lennard-Jones force for a given displacement vector r_vec.\n        Reduced units (epsilon=1, sigma=1) are used.\n        \"\"\"\n        r_sq = np.dot(r_vec, r_vec)\n        \n        # If distance is zero, force is undefined. Return zero vector.\n        # This won't happen for distinct particles.\n        if r_sq == 0.0:\n            return np.zeros_like(r_vec)\n            \n        r_m2 = 1.0 / r_sq\n        r_m6 = r_m2 * r_m2 * r_m2\n        r_m12 = r_m6 * r_m6\n        \n        # force_scalar = (dU/dr) / r\n        force_scalar = (48.0 * r_m12 - 24.0 * r_m6) * r_m2\n        \n        return force_scalar * r_vec\n\n    for L, x_i, x_j in test_cases:\n        # Calculate raw displacement vectors\n        delta_rij = x_i - x_j\n        delta_rji = x_j - x_i\n        \n        # Apply minimum image convention\n        r_ij = get_mic_vector(delta_rij, L)\n        r_ji = get_mic_vector(delta_rji, L)\n        \n        # Compute forces\n        F_ij = get_lj_force(r_ij)\n        F_ji = get_lj_force(r_ji)\n\n        # Check if Newton's third law is satisfied within tolerance\n        force_sum = F_ij + F_ji\n        is_satisfied = np.all(np.abs(force_sum)  1e-12)\n        results.append(is_satisfied)\n\n    # Format the final output as a comma-separated list of booleans in a single line.\n    # Python's str() of a boolean produces 'True' or 'False', which is standard.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3435077"}]}