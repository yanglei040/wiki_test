{"hands_on_practices": [{"introduction": "Before diving into complex simulations, it's crucial to understand the tools we use. This first practice examines the internal structure of a classic generator, the Linear Congruential Generator (LCG). While computationally simple, LCGs can harbor non-random patterns, particularly in their low-order bits. This exercise [@problem_id:3439293] will guide you through a mathematical derivation to quantify this infamous flaw and analyze a common 'bit-scrambling' remedy, providing a foundational understanding of why not all random numbers are created equal.", "problem": "Consider a Linear Congruential Generator (LCG) used in a molecular dynamics simulation to generate pseudorandom integers for uniform variate mapping, defined by the recurrence $X_{n+1} = (a X_{n} + c) \\bmod 2^{w}$, where $w \\geq 2$, $a$ is odd, and $c$ is odd. In many codes, integers are mapped to floating-point doubles by scaling $U_{n} = X_{n} / 2^{w}$, so any nonrandom structure in the low-order bits of $X_{n}$ can degrade the uniformity and independence of the resulting $U_{n}$ at advanced precision.\n\nStarting from modular arithmetic and the definition of lag-$1$ autocorrelation for a stationary binary process, do the following:\n\n1. Derive the evolution equation for the least significant bit $b_{n} = X_{n} \\bmod 2$, and compute the lag-$1$ autocorrelation coefficient $\\rho_{b}$ of the binary sequence $\\{b_{n}\\}$ taken over one full period of the LCG modulo $2$.\n\n2. To remedy low-order bit structure before mapping to doubles, consider bit-scrambling via the output transformation $Y_{n} = X_{n} \\oplus (X_{n} \\gg 1)$, where $\\oplus$ denotes bitwise exclusive-or and $\\gg$ denotes right-shift. Under the additional assumption $a \\equiv 1 \\pmod{4}$ and $c \\equiv 1 \\pmod{2}$, derive the evolution of the two least significant bits $t_{n} = X_{n} \\bmod 4$, and compute the lag-$1$ autocorrelation coefficient $\\rho_{s}$ of the scrambled least significant bit $s_{n} = Y_{n} \\bmod 2$ over one full period modulo $4$.\n\nProvide the ordered pair $(\\rho_{b}, \\rho_{s})$ as your final answer. No rounding is required. The answer must be two real numbers.", "solution": "The problem statement has been validated and is deemed valid. It is scientifically grounded, well-posed, and objective. All necessary information for a unique solution is provided, and the problem is a non-trivial exercise in the analysis of pseudorandom number generators.\n\nThe problem requires the calculation of two lag-$1$ autocorrelation coefficients, $\\rho_{b}$ and $\\rho_{s}$, for binary sequences derived from a Linear Congruential Generator (LCG).\n\n**Part 1: Autocorrelation of the Least Significant Bit**\n\nThe LCG is defined by the recurrence relation:\n$$X_{n+1} = (a X_{n} + c) \\bmod 2^{w}$$\nwhere $w \\geq 2$, and both the multiplier $a$ and the increment $c$ are odd integers.\n\nThe least significant bit (LSB) of $X_{n}$ is given by $b_{n} = X_{n} \\bmod 2$. To find the evolution equation for the sequence $\\{b_{n}\\}$, we take the LCG recurrence modulo $2$. Since $w \\geq 2$, we have:\n$$X_{n+1} \\bmod 2 = ((a X_{n} + c) \\bmod 2^{w}) \\bmod 2$$\n$$X_{n+1} \\bmod 2 = (a X_{n} + c) \\bmod 2$$\nSubstituting the definition of $b_{n}$, we get:\n$$b_{n+1} = (a (X_{n} \\bmod 2) + (c \\bmod 2)) \\bmod 2$$\n$$b_{n+1} = (a b_{n} + c) \\bmod 2$$\nGiven that $a$ and $c$ are odd, their values modulo $2$ are $a \\equiv 1 \\pmod{2}$ and $c \\equiv 1 \\pmod{2}$. The evolution equation for the LSB sequence simplifies to:\n$$b_{n+1} = (1 \\cdot b_{n} + 1) \\bmod 2 = (b_{n} + 1) \\bmod 2$$\nThis recurrence relation generates a purely alternating sequence. If $b_{0}=0$, the sequence is $\\{0, 1, 0, 1, \\dots\\}$. If $b_{0}=1$, the sequence is $\\{1, 0, 1, 0, \\dots\\}$. In either case, the sequence is periodic with period $P_{b}=2$.\n\nWe now compute the lag-$1$ autocorrelation coefficient, $\\rho_{b}$, for this stationary binary process over one full period. Let's consider the sequence over one period to be $\\{0, 1\\}$.\nThe mean of the sequence $\\{b_{n}\\}$ is:\n$$\\mu_{b} = \\frac{1}{P_{b}} \\sum_{n=0}^{P_{b}-1} b_{n} = \\frac{1}{2}(0+1) = \\frac{1}{2}$$\nThe variance of the sequence is:\n$$\\sigma_{b}^{2} = \\frac{1}{P_{b}} \\sum_{n=0}^{P_{b}-1} (b_{n} - \\mu_{b})^{2} = \\frac{1}{2} \\left[ \\left(0 - \\frac{1}{2}\\right)^{2} + \\left(1 - \\frac{1}{2}\\right)^{2} \\right] = \\frac{1}{2} \\left( \\frac{1}{4} + \\frac{1}{4} \\right) = \\frac{1}{4}$$\nThe lag-$1$ autocovariance, $C_{b}(1)$, is defined as:\n$$C_{b}(1) = \\frac{1}{P_{b}} \\sum_{n=0}^{P_{b}-1} (b_{n} - \\mu_{b})(b_{n+1} - \\mu_{b})$$\nUsing the periodic nature of the sequence ($b_{2} = b_{0}$):\n$$C_{b}(1) = \\frac{1}{2} \\left[ (b_{0} - \\mu_{b})(b_{1} - \\mu_{b}) + (b_{1} - \\mu_{b})(b_{2} - \\mu_{b}) \\right]$$\n$$C_{b}(1) = \\frac{1}{2} \\left[ \\left(0 - \\frac{1}{2}\\right)\\left(1 - \\frac{1}{2}\\right) + \\left(1 - \\frac{1}{2}\\right)\\left(0 - \\frac{1}{2}\\right) \\right]$$\n$$C_{b}(1) = \\frac{1}{2} \\left[ \\left(-\\frac{1}{2}\\right)\\left(\\frac{1}{2}\\right) + \\left(\\frac{1}{2}\\right)\\left(-\\frac{1}{2}\\right) \\right] = \\frac{1}{2} \\left( -\\frac{1}{4} - \\frac{1}{4} \\right) = -\\frac{1}{4}$$\nThe lag-$1$ autocorrelation coefficient is the ratio of the autocovariance to the variance:\n$$\\rho_{b} = \\frac{C_{b}(1)}{\\sigma_{b}^{2}} = \\frac{-1/4}{1/4} = -1$$\n\n**Part 2: Autocorrelation of the Scrambled Least Significant Bit**\n\nFor this part, we consider the additional assumptions $a \\equiv 1 \\pmod{4}$ and $c$ is odd ($c \\equiv 1 \\pmod{2}$). We first derive the evolution of the two least significant bits, represented by $t_{n} = X_{n} \\bmod 4$. Taking the LCG recurrence modulo $4$ (since $w \\geq 2$):\n$$X_{n+1} \\bmod 4 = (a X_{n} + c) \\bmod 4$$\n$$t_{n+1} = (a t_{n} + c) \\bmod 4$$\nSubstituting $a \\equiv 1 \\pmod{4}$, the equation becomes:\n$$t_{n+1} = (t_{n} + c) \\bmod 4$$\nSince $c$ is odd, $c$ can be congruent to $1$ or $3$ modulo $4$.\nCase 1: $c \\equiv 1 \\pmod{4}$. The sequence is $t_{n+1} = (t_{n} + 1) \\bmod 4$. Starting from any value, this generates a cycle of length $4$, e.g., $\\{0, 1, 2, 3, \\dots\\}$.\nCase 2: $c \\equiv 3 \\pmod{4}$. The sequence is $t_{n+1} = (t_{n} + 3) \\bmod 4$. This also generates a cycle of length $4$, e.g., $\\{0, 3, 2, 1, \\dots\\}$.\nThe period of the sequence $\\{t_{n}\\}$ is $P_{t}=4$.\n\nThe scrambled output is $Y_{n} = X_{n} \\oplus (X_{n} \\gg 1)$, where $\\oplus$ is bitwise XOR and $\\gg$ is right-shift. The scrambled LSB is $s_{n} = Y_{n} \\bmod 2$. Let $X_{n}$ be represented in binary as $\\dots b_{n,1}b_{n,0}$. The LSB of $Y_{n}$ is the XOR of the two LSBs of $X_{n}$:\n$$s_{n} = b_{n,0} \\oplus b_{n,1}$$\nWe can determine the value of $s_{n}$ from $t_{n} = 2 b_{n,1} + b_{n,0}$:\n- If $t_{n}=0=(00)_{2}$, then $b_{n,1}=0, b_{n,0}=0 \\implies s_{n} = 0 \\oplus 0 = 0$.\n- If $t_{n}=1=(01)_{2}$, then $b_{n,1}=0, b_{n,0}=1 \\implies s_{n} = 1 \\oplus 0 = 1$.\n- If $t_{n}=2=(10)_{2}$, then $b_{n,1}=1, b_{n,0}=0 \\implies s_{n} = 0 \\oplus 1 = 1$.\n- If $t_{n}=3=(11)_{2}$, then $b_{n,1}=1, b_{n,0}=1 \\implies s_{n} = 1 \\oplus 1 = 0$.\n\nNow we compute the lag-$1$ autocorrelation coefficient $\\rho_{s}$ for the sequence $\\{s_{n}\\}$ over one period of length $P_{s}=4$.\nIf $c \\equiv 1 \\pmod{4}$, one period of $\\{t_{n}\\}$ is $\\{0, 1, 2, 3\\}$. The corresponding sequence $\\{s_{n}\\}$ is $\\{0, 1, 1, 0\\}$.\nIf $c \\equiv 3 \\pmod{4}$, one period of $\\{t_{n}\\}$ is $\\{0, 3, 2, 1\\}$. The corresponding sequence $\\{s_{n}\\}$ is $\\{0, 0, 1, 1\\}$.\nThe calculation for $\\rho_{s}$ is identical for both sequences, as one is a cyclic shift of the other. Let's use the sequence $\\{0, 1, 1, 0\\}$.\nThe mean of the sequence $\\{s_{n}\\}$ is:\n$$\\mu_{s} = \\frac{1}{4}(0+1+1+0) = \\frac{1}{2}$$\nThe variance is:\n$$\\sigma_{s}^{2} = \\frac{1}{4} \\left[ \\left(0 - \\frac{1}{2}\\right)^{2} + \\left(1 - \\frac{1}{2}\\right)^{2} + \\left(1 - \\frac{1}{2}\\right)^{2} + \\left(0 - \\frac{1}{2}\\right)^{2} \\right] = \\frac{1}{4} \\left( \\frac{1}{4} + \\frac{1}{4} + \\frac{1}{4} + \\frac{1}{4} \\right) = \\frac{1}{4}$$\nThe lag-$1$ autocovariance $C_{s}(1)$ is:\n$$C_{s}(1) = \\frac{1}{4} \\sum_{n=0}^{3} (s_{n} - \\mu_{s})(s_{n+1} - \\mu_{s})$$\n$$C_{s}(1) = \\frac{1}{4} \\left[ \\left(0-\\frac{1}{2}\\right)\\left(1-\\frac{1}{2}\\right) + \\left(1-\\frac{1}{2}\\right)\\left(1-\\frac{1}{2}\\right) + \\left(1-\\frac{1}{2}\\right)\\left(0-\\frac{1}{2}\\right) + \\left(0-\\frac{1}{2}\\right)\\left(0-\\frac{1}{2}\\right) \\right]$$\nThe terms correspond to $s_0, s_1, s_2, s_3$ and $s_4=s_0$.\n$$C_{s}(1) = \\frac{1}{4} \\left[ \\left(-\\frac{1}{2}\\right)\\left(\\frac{1}{2}\\right) + \\left(\\frac{1}{2}\\right)\\left(\\frac{1}{2}\\right) + \\left(\\frac{1}{2}\\right)\\left(-\\frac{1}{2}\\right) + \\left(-\\frac{1}{2}\\right)\\left(-\\frac{1}{2}\\right) \\right]$$\n$$C_{s}(1) = \\frac{1}{4} \\left[ -\\frac{1}{4} + \\frac{1}{4} - \\frac{1}{4} + \\frac{1}{4} \\right] = 0$$\nThe lag-$1$ autocorrelation coefficient is:\n$$\\rho_{s} = \\frac{C_{s}(1)}{\\sigma_{s}^{2}} = \\frac{0}{1/4} = 0$$\nThe bit-scrambling successfully removes the lag-$1$ autocorrelation from the least significant bit.\n\nThe final answer is the ordered pair $(\\rho_{b}, \\rho_{s})$.", "answer": "$$\n\\boxed{\n\\begin{pmatrix} -1 & 0 \\end{pmatrix}\n}\n$$", "id": "3439293"}, {"introduction": "Building on our understanding of internal PRNG flaws, this practice demonstrates their dramatic consequences in a real-world simulation context. What happens when the correlated low-order bits of a generator, which we analyzed previously, are used to make decisions for a rare stochastic event like a collision in an Anderson thermostat? This problem [@problem_id:3439356] presents a cautionary tale where this seemingly minor implementation choice leads to a catastrophic failure of the thermostat, completely suppressing the intended physical process and highlighting the critical need for careful PRNG application.", "problem": "Consider an Anderson thermostat applied to a molecular dynamics system in three spatial dimensions, where stochastic collisions are modeled as a Poisson process with constant rate parameter $\\nu$ per particle. In a time-discretized integrator with time step $\\Delta t$, the probability that a given particle undergoes a collision in a step is $p = 1 - \\exp(-\\nu \\Delta t)$. Assume $\\nu$ and $\\Delta t$ are chosen such that $p = 2^{-10}$ exactly.\n\nA single shared pseudorandom number generator (PRNG) is used across all particles and time steps, implemented as a linear congruential generator (LCG) with modulus $2^{32}$, multiplier $a$, and increment $c$,\n$$\nx_{n+1} = a x_n + c \\pmod{2^{32}},\n$$\nwhere $a \\equiv 1 \\pmod{4}$ and $c$ is odd. The code decides whether a collision occurs for a particle at time step $t$ by forming an integer $b_t = x_{n_t} \\bmod 2^{10}$ from the lowest $10$ bits of the PRNG state and declaring a collision if and only if $b_t < T$, where $T = \\lfloor p \\cdot 2^{10} \\rfloor$. The code structure advances the PRNG in fixed blocks, so that $n_t = n_0 + t s$ with stride $s = 2^{11}$ for successive time steps across the simulation.\n\nAnswer the following, starting from first principles and scientifically well-tested facts:\n- Derive, using only properties of the LCG modulo powers of $2$, whether the sequence $\\{b_t\\}$ is invariant in $t$ for this stride. Use this to determine the realized per-step collision rate $R_{\\text{biased}}$ in a typical run whose initial seed satisfies $x_{n_0} \\bmod 2^{10} \\neq 0$.\n- Propose a specific bit-mixing remedy defined by $y_n = x_n \\oplus (x_n \\gg 16)$, where $\\oplus$ denotes bitwise exclusive-or and $\\gg$ is logical right shift, and switch the decision rule to $d_t = y_{n_t} \\bmod 2^{10}$ with a collision if and only if $d_t < T$. Analyze whether this mixing recovers the intended event rate, and compute the realized per-step collision rate $R_{\\text{mixed}}$.\n\nExpress your final answer as a two-entry row matrix containing $R_{\\text{biased}}$ and $R_{\\text{mixed}}$, in exact fractional form, with no rounding. No physical units are required for the final numerical values.", "solution": "The problem is subjected to validation.\n\n### Step 1: Extract Givens\n-   **System**: Molecular dynamics in three spatial dimensions.\n-   **Thermostat**: Anderson thermostat.\n-   **Stochastic Collision Model**: Poisson process with rate $\\nu$ per particle.\n-   **Time Step**: $\\Delta t$.\n-   **Collision Probability**: The probability of a collision for a particle in one time step is $p = 1 - \\exp(-\\nu \\Delta t)$.\n-   **Specified Probability**: $p = 2^{-10}$.\n-   **Pseudorandom Number Generator (PRNG)**: Linear Congruential Generator (LCG).\n-   **LCG Definition**: $x_{n+1} = a x_n + c \\pmod{2^{32}}$.\n-   **LCG Parameters**:\n    -   Modulus: $m = 2^{32}$.\n    -   Multiplier: $a \\equiv 1 \\pmod{4}$.\n    -   Increment: $c$ is an odd integer.\n-   **Initial Collision Decision Rule**:\n    -   A random integer $b_t = x_{n_t} \\bmod 2^{10}$ is generated from the lowest $10$ bits of the PRNG state $x_{n_t}$.\n    -   A collision occurs if and only if $b_t < T$.\n-   **Threshold**: $T = \\lfloor p \\cdot 2^{10} \\rfloor$.\n-   **PRNG State Indexing**: The sequence of PRNG states used for time steps $t=0, 1, 2, \\dots$ is sampled at indices $n_t = n_0 + t s$.\n-   **Stride**: $s = 2^{11}$.\n-   **Initial Condition**: A typical run starts with an initial seed such that $x_{n_0} \\bmod 2^{10} \\neq 0$.\n-   **Remedy Proposal**:\n    -   A new random variate is defined: $y_n = x_n \\oplus (x_n \\gg 16)$, where $\\oplus$ is bitwise XOR and $\\gg$ is logical right shift.\n    -   The decision rule is changed to use $d_t = y_{n_t} \\bmod 2^{10}$.\n    -   A collision occurs if and only if $d_t < T$.\n-   **Task**:\n    1.  Derive if the sequence $\\{b_t\\}$ is invariant in $t$.\n    2.  Determine the realized per-step collision rate $R_{\\text{biased}}$ under the initial rule.\n    3.  Analyze if the remedy recovers the intended rate.\n    4.  Compute the realized per-step collision rate $R_{\\text{mixed}}$ under the new rule.\n    5.  Express the final answer as a two-entry row matrix $[R_{\\text{biased}}, R_{\\text{mixed}}]$.\n\n### Step 2: Validate Using Extracted Givens\n-   **Scientific Grounding**: The problem is well-grounded in the established theory of pseudorandom number generation and its application in computational physics. The properties of LCGs with power-of-two moduli are a classic topic in numerical analysis and computer science. The described flaw (correlation in lower bits) and the proposed remedy (bit mixing via XOR-shifting) are standard concepts.\n-   **Well-Posedness**: The problem is self-contained and provides all necessary parameters ($m$, conditions on $a$ and $c$, $p$, $s$) and definitions to perform the analysis. The questions are precise and lead to a unique mathematical solution.\n-   **Objectivity**: The problem is stated in formal, objective language without any subjective or ambiguous terms.\n\n### Step 3: Verdict and Action\nThe problem is scientifically sound, well-posed, and objective. It is deemed **valid**. A full solution will be provided.\n\n### Solution Derivation\n\nFirst, we determine the collision threshold $T$. Given the collision probability $p = 2^{-10}$, the threshold is:\n$$\nT = \\lfloor p \\cdot 2^{10} \\rfloor = \\lfloor 2^{-10} \\cdot 2^{10} \\rfloor = \\lfloor 1 \\rfloor = 1\n$$\nA collision occurs if the generated random integer is less than $1$, which means the integer must be $0$.\n\n#### Part 1: Analysis of the Biased Rate $R_{\\text{biased}}$\n\nThe first implementation uses the sequence $b_t = x_{n_t} \\bmod 2^{10}$. The LCG is defined by $x_{n+1} = (a x_n + c) \\pmod{2^{32}}$ with $a \\equiv 1 \\pmod{4}$ and $c$ odd. These conditions on $a$ and $c$ ensure that the LCG has a full period of $2^{32}$.\n\nA fundamental property of an LCG with a power-of-two modulus $m = 2^k$ is that the sequence of the low-order $j$ bits, $z_n = x_n \\bmod 2^j$ (for $j \\le k$), is itself periodic. The sequence $\\{z_n\\}$ is generated by $z_{n+1} = (a z_n + c) \\pmod{2^j}$, and for the given conditions on $a$ and $c$, its period is exactly $2^j$.\n\nIn our case, we are interested in the sequence of the lowest $10$ bits, so we consider $j=10$. The sequence $\\{x_n \\bmod 2^{10}\\}$ is periodic with a period of $2^{10}$.\n\nThe simulation code does not use consecutive values from the LCG. Instead, it samples the LCG state at indices $n_t = n_0 + ts$, with a stride of $s = 2^{11}$. We analyze the sequence of low bits at these specific indices:\n$$\nb_t = x_{n_t} \\bmod 2^{10} = x_{n_0 + ts} \\bmod 2^{10}\n$$\nThe stride is $s = 2^{11} = 2 \\cdot 2^{10}$. This stride is an integer multiple of the period of the low-10-bit sequence. Consequently, for any integer $t \\ge 0$:\n$$\nx_{n_0 + ts} \\equiv x_{n_0} \\pmod{2^{10}}\n$$\nThis implies that $b_t = x_{n_0} \\bmod 2^{10} = b_0$ for all $t$. The sequence $\\{b_t\\}$ is invariant in time; it is a constant sequence.\n\nThe problem specifies that the simulation is initiated with a seed such that $x_{n_0} \\bmod 2^{10} \\neq 0$. This means $b_0 \\neq 0$. Since $b_t = b_0$ for all subsequent time steps, we have $b_t \\neq 0$ for all $t$.\n\nA collision occurs if and only if $b_t = 0$. Since this condition is never met, no collisions ever occur. The realized per-step collision rate is therefore zero.\n$$\nR_{\\text{biased}} = 0\n$$\n\n#### Part 2: Analysis of the Mixed Rate $R_{\\text{mixed}}$\n\nThe proposed remedy uses a new random variate $y_n = x_n \\oplus (x_n \\gg 16)$, where $\\oplus$ is bitwise exclusive-or and $\\gg$ is logical right shift by $16$ positions. The decision is based on $d_t = y_{n_t} \\bmod 2^{10}$.\n\nLet's decompose the $32$-bit integer $x_n$ into its high and low $16$-bit parts:\n$H_n = \\lfloor x_n / 2^{16} \\rfloor$ (high bits)\n$L_n = x_n \\bmod 2^{16}$ (low bits)\nSo, $x_n = H_n \\cdot 2^{16} + L_n$.\nThe operation $x_n \\gg 16$ yields the integer $H_n$.\nThe bitwise XOR operation $y_n = x_n \\oplus H_n$ results in a number whose high $16$ bits are equal to $H_n$ and whose low $16$ bits are $L_n \\oplus H_n$.\n$y_n = H_n \\cdot 2^{16} + (L_n \\oplus H_n)$.\n\nThe decision rule uses $d_t = y_{n_t} \\bmod 2^{10}$. This value depends on the lowest $10$ bits of the low-$16$ part of $y_{n_t}$:\n$$\nd_t = (L_{n_t} \\oplus H_{n_t}) \\bmod 2^{10}\n$$\nLet $l_t = L_{n_t} \\bmod 2^{10}$ and $h_t = H_{n_t} \\bmod 2^{10}$. We can write $d_t$ as:\n$$\nd_t = l_t \\oplus h_t\n$$\nThe value $l_t$ is derived from the low bits of $x_{n_t}$. Specifically, $l_t = (x_{n_t} \\bmod 2^{16}) \\bmod 2^{10} = x_{n_t} \\bmod 2^{10}$. As established in Part 1, this sequence is constant: $l_t = l_0 = x_{n_0} \\bmod 2^{10}$.\n\nThe value $h_t$ is derived from the high bits of $x_{n_t}$. The sequence of higher-order bits of a full-period LCG is known to exhibit good statistical properties, closely approximating a uniform distribution. The LCG sequence itself is sampled with a large stride $s=2^{11}$, which is not a multiple of the full period $2^{32}$, ensuring the sampled states $x_{n_t}$ are not trivially correlated. It is a standard and scientifically justified assumption that the resulting sequence of high bits $\\{H_{n_t}\\}$ and thus its truncation $\\{h_t\\}$ is uniformly distributed over the set $\\{0, 1, \\dots, 2^{10}-1\\}$.\n\nNow consider the sequence $d_t = l_0 \\oplus h_t$. We are XORing a uniformly distributed sequence $\\{h_t\\}$ with a constant value $l_0$. The function $f(z) = l_0 \\oplus z$ is a bijection on the set $\\{0, 1, \\dots, 2^{10}-1\\}$. A bijective transformation of a uniformly distributed sequence results in a uniformly distributed sequence. Therefore, the sequence $\\{d_t\\}$ is uniformly distributed on $\\{0, 1, \\dots, 2^{10}-1\\}$.\n\nThe probability of $d_t$ taking any specific value $k$ in its range is:\n$$\nP(d_t = k) = \\frac{1}{2^{10}}\n$$\nThe collision condition is $d_t < T=1$, which means $d_t=0$. The probability of this event is:\n$$\nP(d_t = 0) = \\frac{1}{2^{10}}\n$$\nThis probability is the realized per-step collision rate, $R_{\\text{mixed}}$.\n$$\nR_{\\text{mixed}} = \\frac{1}{2^{10}} = \\frac{1}{1024}\n$$\nThis rate matches the intended collision rate $p=2^{-10}$, so the bit-mixing remedy is successful in recovering the desired statistical behavior.\n\nThe final answer combines both results in the specified format.", "answer": "$$\n\\boxed{\\begin{pmatrix} 0 & \\frac{1}{1024} \\end{pmatrix}}\n$$", "id": "3439356"}, {"introduction": "Having witnessed how PRNGs can fail, we now shift to the proactive, professional approach: in-situ validation. Simply choosing a 'good' PRNG is not enough; we must verify its statistical properties within the actual simulation environment. This comprehensive coding exercise [@problem_id:3439285] tasks you with building a Langevin dynamics simulation and embedding a suite of rigorous statistical tests to assess the quality of modern, high-fidelity generators, moving from identifying failures to ensuring robust and physically correct results.", "problem": "You are tasked with writing a complete, runnable program that embeds a mini test suite into a simple Molecular Dynamics (MD) workflow to assess Pseudo Random Number Generators (PRNGs) via diagnostic statistical tests commonly used in the analysis of thermostatted dynamics. The program must implement a three-dimensional Langevin dynamics simulation of a single particle in a harmonic potential using dimensionless units, test the statistical properties of the generated stochastic sequences, and rank PRNGs by pass rates and their impact on measured observables.\n\nThe foundational base is the Langevin equation for a particle of mass $m$ with position $\\mathbf{x}$ and velocity $\\mathbf{v}$ in a harmonic potential with force constant $k$, which reads\n$$ m \\frac{d\\mathbf{v}}{dt} = - \\gamma m \\mathbf{v} - \\nabla U(\\mathbf{x}) + \\sqrt{2 \\gamma m k_{\\mathrm{B}} T} \\, \\boldsymbol{\\eta}(t), $$\nwhere $U(\\mathbf{x}) = \\frac{1}{2} k \\lVert \\mathbf{x} \\rVert^2$, $\\gamma$ is the friction coefficient, $T$ is the temperature, $k_{\\mathrm{B}}$ is the Boltzmann constant, and $\\boldsymbol{\\eta}(t)$ is a zero-mean, unit-variance Gaussian white noise with delta correlation in time. The program must discretize the dynamics using a scientifically sound variant of the stochastic velocity Verlet integrator with an exact Ornstein–Uhlenbeck velocity update over a timestep $\\Delta t$, commonly organized in the \"BAOAB\" sequence: deterministic half velocity update, deterministic half position update, stochastic velocity update, deterministic half position update, and deterministic half velocity update.\n\nDiagnostics to perform:\n1. Kolmogorov–Smirnov (K–S) test: For each velocity component $v_x$, $v_y$, $v_z$, test the null hypothesis that the sampled component is Gaussian distributed with mean $0$ and variance $\\sigma^2 = k_{\\mathrm{B}} T / m$. Use the one-sample K–S test at significance $\\alpha = 0.05$ and record a pass if the $p$-value $\\ge 0.05$.\n2. Runs test on thermostat kicks: Consider the sequence of standard normal variates used internally in the stochastic Ornstein–Uhlenbeck velocity update (the \"thermostat kicks\") for one chosen component. Convert this sequence to a binary sequence by classifying samples as \"above zero\" or \"below zero\" (discard exact zeros if any), compute the number of runs $R$ as the number of contiguous subsequences of equal classification, and assess the large-sample $z$-score\n   $$ z = \\frac{R - \\mathbb{E}[R]}{\\sqrt{\\mathrm{Var}[R]}}, \\quad \\mathbb{E}[R] = \\frac{2 n_+ n_-}{n} + 1, \\quad \\mathrm{Var}[R] = \\frac{2 n_+ n_- (2 n_+ n_- - n)}{n^2 (n - 1)}, $$\n   where $n_+$ is the number of positives, $n_-$ is the number of negatives, and $n = n_+ + n_-$. Record a pass if $\\lvert z \\rvert \\le 2.0$; if $n_+ = 0$ or $n_- = 0$, record a fail.\n3. Periodogram test on stochastic forces: Construct the sequence of discrete stochastic force impulses for one chosen component as $F_n^{\\mathrm{noise}} = m \\Delta v_n^{\\mathrm{noise}} / \\Delta t$, where $\\Delta v_n^{\\mathrm{noise}}$ is the stochastic velocity increment at step $n$. Compute the periodogram via the discrete Fourier transform of the demeaned sequence and estimate the slope $s$ of the log–log relationship between frequency and power for nonzero frequencies using least-squares linear regression. Record a pass if $\\lvert s \\rvert \\le 0.15$.\n\nObservable to measure:\n- Kinetic temperature error: For each test case, compute the absolute error between the target temperature and the measured kinetic temperature,\n  $$ T_{\\mathrm{meas}} = \\frac{m}{3 k_{\\mathrm{B}}} \\left\\langle v_x^2 + v_y^2 + v_z^2 \\right\\rangle, \\quad \\Delta T = \\lvert T_{\\mathrm{meas}} - T \\rvert, $$\n  where the average $\\langle \\cdot \\rangle$ is over all recorded timesteps in the production run. Use $k_{\\mathrm{B}} = 1$.\n\nProgram requirements:\n- Implement a three-dimensional simulation with the BAOAB sequence and exact Ornstein–Uhlenbeck velocity update over $\\Delta t$ for the thermostat step; $c = e^{-\\gamma \\Delta t}$ is the velocity decay factor and the stochastic increment per component has standard deviation $\\sqrt{(k_{\\mathrm{B}} T / m) (1 - c^2)}$.\n- Discard the first $10\\%$ of steps as equilibration and use the remaining steps for diagnostics and observable measurement.\n- Use three PRNGs: $0$ for \"MT19937\", $1$ for \"PCG64\", and $2$ for \"Philox\". Each PRNG must be instantiated with a seed specific to the test case.\n- For each test case, perform the three diagnostics described above, yielding five pass–fail outcomes (three K–S component tests, one runs test, one periodogram test). Define the pass rate for a test case as the fraction of these five outcomes that pass.\n- Rank the PRNGs by their average pass rate across all test cases. In the event of a tie, break ties by the smaller average kinetic temperature error, averaged across the test cases for the PRNG.\n\nTest suite:\n- Use the following nine test cases, each a tuple $(\\mathrm{prng\\_id}, T, \\gamma, k, m, \\Delta t, N, \\mathrm{seed})$ with $k_{\\mathrm{B}} = 1$:\n  1. $(0, 1.0, 1.0, 1.0, 1.0, 0.001, 20000, 12345)$\n  2. $(1, 1.0, 1.0, 1.0, 1.0, 0.001, 20000, 12346)$\n  3. $(2, 1.0, 1.0, 1.0, 1.0, 0.001, 20000, 12347)$\n  4. $(0, 1.0, 1.0, 1.0, 1.0, 0.001, 6000, 22345)$\n  5. $(1, 1.0, 1.0, 1.0, 1.0, 0.001, 6000, 22346)$\n  6. $(2, 1.0, 1.0, 1.0, 1.0, 0.001, 6000, 22347)$\n  7. $(0, 1.0, 2.0, 10.0, 1.0, 0.001, 20000, 32345)$\n  8. $(1, 1.0, 2.0, 10.0, 1.0, 0.001, 20000, 32346)$\n  9. $(2, 1.0, 2.0, 10.0, 1.0, 0.001, 20000, 32347)$\n\nFinal output specification:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with the following content and order:\n  1. Three integers giving the PRNG ranking by identifier $(0, 1, 2)$ as described (first is best).\n  2. Three floats giving the average pass rates for PRNGs $0$, $1$, and $2$ across the nine test cases.\n  3. Three floats giving the average absolute kinetic temperature errors $\\Delta T$ for PRNGs $0$, $1$, and $2$ across the nine test cases.\n  4. Nine booleans giving, in the order of the test suite above, whether all five diagnostics passed for that test case (true if all five passed, false otherwise).\n\nExample format (not actual values): $[2,1,0,0.84,0.82,0.80,0.02,0.03,0.05,True,False,True,True,True,False,True,True,True]$.\n\nNo physical units are required beyond the dimensionless specification above. Angles are not used. All numerical quantities must be represented in floating-point arithmetic as needed.", "solution": "The problem is assessed to be valid as it is scientifically grounded, well-posed, and contains sufficient information to construct a unique and meaningful solution. The task requires implementing a computational test suite to evaluate Pseudo Random Number Generators (PRNGs) within a molecular dynamics context, a standard practice in computational science for ensuring simulation fidelity.\n\nThe solution is structured as follows:\nFirst, a primary function iterates through a predefined set of nine test cases. Each test case specifies a PRNG to use, physical parameters for a Langevin dynamics simulation, and simulation control parameters. For each case, a dedicated function executes the simulation, performs statistical diagnostics, and computes a key physical observable. The results are then aggregated to rank the PRNGs and format the final output as specified.\n\nThe core of the program is a three-dimensional Langevin dynamics simulation of a single particle of mass $m$ in a harmonic potential $U(\\mathbf{x}) = \\frac{1}{2} k \\lVert \\mathbf{x} \\rVert^2$, for which the force is $\\mathbf{F}(\\mathbf{x}) = -\\nabla U(\\mathbf{x}) = -k\\mathbf{x}$. The dynamics are propagated using the BAOAB splitting scheme for the stochastic differential equation. This integrator sequence consists of five steps applied over a timestep $\\Delta t$:\n1.  **B (Velocity Half-Step):** The velocity $\\mathbf{v}$ is updated under the deterministic force for $\\Delta t / 2$. Given the velocity $\\mathbf{v}_n$ at the start of the timestep, the update is $\\mathbf{v}_{n+1/4} = \\mathbf{v}_n + \\frac{\\mathbf{F}(\\mathbf{x}_n)}{m} \\frac{\\Delta t}{2}$.\n2.  **A (Position Half-Step):** The position $\\mathbf{x}$ is updated using the new velocity for $\\Delta t / 2$: $\\mathbf{x}_{n+1/2} = \\mathbf{x}_n + \\mathbf{v}_{n+1/4} \\frac{\\Delta t}{2}$.\n3.  **O (Stochastic Velocity Step):** The velocity is updated according to the exact solution of the Ornstein-Uhlenbeck process over the full timestep $\\Delta t$. This step models the effects of friction and the random thermal bath. The update for each velocity component is $v' = c v + \\sigma_v \\xi$, where $c = e^{-\\gamma \\Delta t}$ is the velocity decay factor due to friction $\\gamma$, $\\xi$ is a random number drawn from a standard normal distribution $\\mathcal{N}(0, 1)$, and $\\sigma_v = \\sqrt{(k_{\\mathrm{B}} T / m) (1 - c^2)}$ is the standard deviation of the thermal kick. Here $k_{\\mathrm{B}}$ is the Boltzmann constant (set to $1$), and $T$ is the target temperature. This step updates the velocity from $\\mathbf{v}_{n+1/4}$ to $\\mathbf{v}_{n+3/4}$.\n4.  **A (Position Half-Step):** The position is updated for another $\\Delta t / 2$ with the thermostatted velocity: $\\mathbf{x}_{n+1} = \\mathbf{x}_{n+1/2} + \\mathbf{v}_{n+3/4} \\frac{\\Delta t}{2}$.\n5.  **B (Velocity Half-Step):** A final deterministic velocity update for $\\Delta t / 2$ using the force at the new position completes the step: $\\mathbf{v}_{n+1} = \\mathbf{v}_{n+3/4} + \\frac{\\mathbf{F}(\\mathbf{x}_{n+1})}{m} \\frac{\\Delta t}{2}$.\n\nDuring each simulation, which runs for $N$ total steps, several data sequences are recorded. The first $10\\%$ of the trajectory is discarded for equilibration. The remaining $90\\%$ (the production run) is used for analysis. Three diagnostic tests are performed on this data, yielding five pass/fail outcomes:\n\n1.  **Kolmogorov–Smirnov (K–S) Test:** For each velocity component ($v_x, v_y, v_z$), the empirical distribution of sampled velocities is compared against the theoretical Maxwell-Boltzmann distribution, which is a Gaussian with mean $0$ and variance $\\sigma^2 = k_{\\mathrm{B}} T / m$. The one-sample K-S test from `scipy.stats` is used. A test is considered passed if the resulting $p$-value is greater than or equal to the significance level $\\alpha = 0.05$.\n\n2.  **Runs Test:** This test assesses the serial independence of the random numbers used in the thermostat. The sequence of standard normal variates $\\{\\xi_i\\}$ sampled for one component (e.g., $x$) during the O-step is converted into a binary sequence based on a sample's sign relative to zero. The number of runs $R$ (contiguous subsequences of the same sign) is calculated. The $z$-score, $z = (R - \\mathbb{E}[R]) / \\sqrt{\\mathrm{Var}[R]}$, is computed using the large-sample approximations for the expected value $\\mathbb{E}[R]$ and variance $\\mathrm{Var}[R]$. A test is passed if $|z| \\le 2.0$, which corresponds to a confidence level of approximately $95\\%$. The test fails if the sequence contains variates of only one sign.\n\n3.  **Periodogram Test:** This test checks if the stochastic force behaves as white noise, which should have a flat power spectrum. The sequence of discrete stochastic force impulses for one component, $F_n^{\\mathrm{noise}} = m \\Delta v_n^{\\mathrm{noise}} / \\Delta t$, where $\\Delta v_n^{\\mathrm{noise}} = \\sigma_v \\xi_n$, is analyzed. The power spectral density (periodogram) is computed via a Fast Fourier Transform. For white noise, the log-log plot of power versus frequency should have a slope near zero. A linear regression is performed on this log-log data for non-zero frequencies. The test is passed if the absolute value of the slope, $|s|$, is less than or equal to $0.15$.\n\nFor each test case, the pass rate is the fraction of these five diagnostics that passed. Additionally, the measured kinetic temperature, $T_{\\mathrm{meas}} = \\frac{m}{3 k_{\\mathrm{B}}} \\langle v_x^2 + v_y^2 + v_z^2 \\rangle$, is calculated by averaging over the production run. The absolute error $\\Delta T = |T_{\\mathrm{meas}} - T|$ is computed.\n\nFinally, the PRNGs are ranked. The primary ranking criterion is the average pass rate across the test cases specific to each PRNG. A higher average pass rate is better. In case of a tie, the PRNG with the lower average kinetic temperature error $\\Delta T$ is ranked higher. The program then prints the ranked PRNG identifiers, the average pass rates and temperature errors for each PRNG (in the fixed order $0, 1, 2$), and a boolean for each of the nine test cases indicating if all five diagnostics passed.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import kstest, norm, linregress\n\ndef _run_single_test(test_case):\n    \"\"\"\n    Runs a single MD simulation and performs all diagnostics.\n    \"\"\"\n    prng_id, T, gamma, k, m, dt, N, seed = test_case\n    kB = 1.0\n\n    # Initialize the PRNG based on the provided ID and seed\n    prng_map = {0: np.random.MT19937, 1: np.random.PCG64, 2: np.random.Philox}\n    rng = np.random.Generator(prng_map[prng_id](seed))\n\n    # Initialize particle state (position and velocity)\n    x = np.zeros(3, dtype=np.float64)\n    v = np.zeros(3, dtype=np.float64)\n\n    # Pre-calculate constants for the BAOAB integrator\n    c = np.exp(-gamma * dt)\n    stoch_std = np.sqrt((kB * T / m) * (1 - c**2))\n\n    # Allocate history arrays for analysis\n    vel_history = np.zeros((N, 3), dtype=np.float64)\n    xi_x_history = np.zeros(N, dtype=np.float64)\n    f_noise_x_history = np.zeros(N, dtype=np.float64)\n\n    # Main simulation loop\n    for n in range(N):\n        # B-step: half-step velocity update\n        force = -k * x\n        v += 0.5 * dt * force / m\n\n        # A-step: half-step position update\n        x += 0.5 * dt * v\n\n        # O-step: full-step stochastic velocity update\n        xi = rng.normal(size=3)\n        stoch_increment = stoch_std * xi\n        v = c * v + stoch_increment\n        \n        # Store data for diagnostics\n        xi_x_history[n] = xi[0]\n        f_noise_x_history[n] = m * stoch_increment[0] / dt\n\n        # A-step: second half-step position update\n        x += 0.5 * dt * v\n\n        # B-step: second half-step velocity update\n        force = -k * x\n        v += 0.5 * dt * force / m\n\n        vel_history[n, :] = v\n\n    # Discard equilibration steps (first 10%)\n    equil_steps = int(0.1 * N)\n    prod_vel = vel_history[equil_steps:]\n    prod_xi_x = xi_x_history[equil_steps:]\n    prod_f_noise_x = f_noise_x_history[equil_steps:]\n\n    total_passes = 0\n    \n    # Diagnostic 1: Kolmogorov–Smirnov test (3 outcomes)\n    ks_passes = 0\n    target_v_std = np.sqrt(kB * T / m)\n    for i in range(3):\n        _stat, p_value = kstest(prod_vel[:, i], 'norm', args=(0, target_v_std))\n        if p_value >= 0.05:\n            ks_passes += 1\n    total_passes += ks_passes\n    \n    # Diagnostic 2: Runs test (1 outcome)\n    runs_pass = False\n    seq = prod_xi_x[prod_xi_x != 0]\n    n_plus = np.sum(seq > 0)\n    n_minus = len(seq) - n_plus\n    n = n_plus + n_minus\n    \n    if n_plus > 0 and n_minus > 0 and n > 1:\n        R = np.sum(np.diff(seq > 0) != 0) + 1\n        E_R = (2 * n_plus * n_minus / n) + 1\n        var_R_num = 2 * n_plus * n_minus * (2 * n_plus * n_minus - n)\n        var_R_den = n**2 * (n - 1)\n        \n        if var_R_den > 0:\n            var_R = var_R_num / var_R_den\n            if var_R > 0:\n                z = (R - E_R) / np.sqrt(var_R)\n                if np.abs(z) <= 2.0:\n                    runs_pass = True\n    if runs_pass:\n        total_passes += 1\n\n    # Diagnostic 3: Periodogram test (1 outcome)\n    periodogram_pass = False\n    f_demeaned = prod_f_noise_x - np.mean(prod_f_noise_x)\n    n_fft = len(f_demeaned)\n\n    if n_fft >= 2:\n        freqs = np.fft.rfftfreq(n_fft, d=dt)\n        power = np.abs(np.fft.rfft(f_demeaned))**2\n        valid_indices = (freqs > 0) & (power > 0)\n        \n        if np.sum(valid_indices) >= 2:\n            log_freqs = np.log(freqs[valid_indices])\n            log_power = np.log(power[valid_indices])\n            res = linregress(log_freqs, log_power)\n            if np.abs(res.slope) <= 0.15:\n                periodogram_pass = True\n    if periodogram_pass:\n        total_passes += 1\n\n    pass_rate = total_passes / 5.0\n    all_passed = (total_passes == 5)\n    \n    # Observable: Kinetic temperature error\n    v_sq_sum = np.sum(prod_vel**2, axis=1)\n    mean_v_sq_sum = np.mean(v_sq_sum)\n    T_meas = (m / (3 * kB)) * mean_v_sq_sum\n    temp_error = np.abs(T_meas - T)\n\n    return pass_rate, temp_error, all_passed\n\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (prng_id, T, gamma, k, m, dt, N, seed)\n        (0, 1.0, 1.0, 1.0, 1.0, 0.001, 20000, 12345),\n        (1, 1.0, 1.0, 1.0, 1.0, 0.001, 20000, 12346),\n        (2, 1.0, 1.0, 1.0, 1.0, 0.001, 20000, 12347),\n        (0, 1.0, 1.0, 1.0, 1.0, 0.001, 6000, 22345),\n        (1, 1.0, 1.0, 1.0, 1.0, 0.001, 6000, 22346),\n        (2, 1.0, 1.0, 1.0, 1.0, 0.001, 6000, 22347),\n        (0, 1.0, 2.0, 10.0, 1.0, 0.001, 20000, 32345),\n        (1, 1.0, 2.0, 10.0, 1.0, 0.001, 20000, 32346),\n        (2, 1.0, 2.0, 10.0, 1.0, 0.001, 20000, 32347),\n    ]\n\n    results_by_prng = {0: [], 1: [], 2: []}\n    all_tests_passed_flags = []\n\n    for case in test_cases:\n        prng_id = case[0]\n        pass_rate, temp_error, all_passed = _run_single_test(case)\n        results_by_prng[prng_id].append((pass_rate, temp_error))\n        all_tests_passed_flags.append(all_passed)\n        \n    # Calculate average statistics for each PRNG\n    avg_pass_rates = {}\n    avg_temp_errors = {}\n    for prng_id in [0, 1, 2]:\n        rates = [r[0] for r in results_by_prng[prng_id]]\n        errors = [r[1] for r in results_by_prng[prng_id]]\n        avg_pass_rates[prng_id] = np.mean(rates) if rates else 0.0\n        avg_temp_errors[prng_id] = np.mean(errors) if errors else 0.0\n\n    # Rank PRNGs: primary key is pass rate (desc), secondary is temp error (asc)\n    ranking_data = [\n        (avg_pass_rates[i], avg_temp_errors[i], i) for i in [0, 1, 2]\n    ]\n    ranking_data.sort(key=lambda x: (-x[0], x[1]))\n    ranked_prng_ids = [item[2] for item in ranking_data]\n\n    # Assemble the final output list in the specified order\n    final_output_list = []\n    final_output_list.extend(ranked_prng_ids)\n    final_output_list.extend([avg_pass_rates[0], avg_pass_rates[1], avg_pass_rates[2]])\n    final_output_list.extend([avg_temp_errors[0], avg_temp_errors[1], avg_temp_errors[2]])\n    final_output_list.extend(all_tests_passed_flags)\n\n    # Format and print the final output string\n    print(f\"[{','.join(map(str, final_output_list))}]\")\n\nsolve()\n```", "id": "3439285"}]}