{"hands_on_practices": [{"introduction": "The cell-list method is a cornerstone for efficiently building neighbor lists, but its performance hinges on a critical parameter: the cell size. This exercise guides you through developing a simple computational work model that captures the trade-off between the cost of visiting neighboring cells and the cost of processing candidate particles within them. By minimizing this work function, you will derive an analytical expression for the optimal cell size, providing a quantitative foundation for tuning molecular dynamics simulation performance [@problem_id:3428313].", "problem": "Consider a large, periodic, homogeneous system simulated by Molecular Dynamics (MD), consisting of $N$ indistinguishable particles at constant number density $\\rho$ in three spatial dimensions (3D). A Verlet neighbor list is constructed with an interaction cutoff $r_c$ and a safety skin $\\delta$; the effective search radius is $r_{\\mathrm{eff}} = r_c + \\delta$. The neighbor list is built using a uniform cubic cell list with cell edge $l_{\\text{cell}}$, and for each particle, all particles in a cube of neighboring cells centered on the particle’s own cell are examined, where the cube is chosen to fully cover the ball of radius $r_{\\mathrm{eff}}$ so that no pair within $r_{\\mathrm{eff}}$ is missed prior to the next rebuild.\n\nStarting from the definitions of uniform number density, geometric coverage of a ball by an axis-aligned cube of cells, and the requirement that $l_{\\text{cell}}$ be strictly positive, perform the following:\n\n1. Derive the exact expected per-particle candidate list size $S(l_{\\text{cell}})$ under the assumption of a uniform particle distribution, expressing it in terms of $\\rho$, $l_{\\text{cell}}$, and $r_{\\mathrm{eff}}$ (do not assume any particular ratio between $l_{\\text{cell}}$ and $r_{\\mathrm{eff}}$; treat the required cell radius in each direction exactly).\n2. Introduce a computational work model for a single neighbor-list build per particle that includes a constant per-candidate evaluation cost $c_p$ (for each particle examined in the candidate set) and a constant per-cell visitation overhead $c_c$ (for each distinct cell accessed in the neighboring cube). Using this model, write the total expected work $W(l_{\\text{cell}})$ as a function of $l_{\\text{cell}}$, $\\rho$, $r_{\\mathrm{eff}}$, $c_p$, and $c_c$.\n3. To obtain a closed-form expression, apply a continuous geometric relaxation that replaces discrete cell counts by their continuous analogs while preserving coverage: approximate the visited cube edge by $2 r_{\\mathrm{eff}} + l_{\\text{cell}}$ and the number of visited cells by $\\left( \\frac{2 r_{\\mathrm{eff}}}{l_{\\text{cell}}} + 1 \\right)^{3}$. Under this relaxation, minimize the resulting $W(l_{\\text{cell}})$ with respect to $l_{\\text{cell}}$ and derive the optimal $l_{\\text{cell}}^{\\ast}$.\n\nExpress the final $l_{\\text{cell}}^{\\ast}$ as a single closed-form symbolic expression in terms of $r_c$, $\\delta$, $\\rho$, $c_p$, and $c_c$. No rounding is required; provide the exact analytic expression. If you introduce any acronym, spell out its full name at its first appearance.", "solution": "The problem asks for the derivation of an optimal cell size for a cell-based neighbor list algorithm in a Molecular Dynamics (MD) simulation. The process is broken into three parts: deriving the candidate list size, formulating the computational work function, and optimizing this function under a continuous relaxation. The problem statement is scientifically grounded, well-posed, and objective, thus it is valid.\n\n**Part 1: Derivation of the Candidate List Size $S(l_{\\text{cell}})$**\n\nThe system consists of particles at a uniform number density $\\rho$. A Verlet neighbor list is constructed using a uniform cubic grid of cells, each with edge length $l_{\\text{cell}}$. For any given particle, a set of neighboring cells is searched for potential interaction partners. The search must find all particles within an effective search radius $r_{\\mathrm{eff}} = r_c + \\delta$.\n\nTo guarantee that no pair of particles within the distance $r_{\\mathrm{eff}}$ is missed, the neighborhood of cells to be searched for a given particle must be sufficiently large. Let a particle `i` be located at position $\\vec{r}_i$ within its cell $C_i$. Any partner particle `j` at position $\\vec{r}_j$ satisfying $|\\vec{r}_i - \\vec{r}_j| \\le r_{\\mathrm{eff}}$ must be found. This condition implies that for each Cartesian component $\\alpha \\in \\{x, y, z\\}$, the separation is bounded: $|r_{i,\\alpha} - r_{j,\\alpha}| \\le r_{\\mathrm{eff}}$.\n\nThe cell-list algorithm discretizes space into a grid. Let the cell index of a particle at coordinate $x$ be given by $I(x) = \\lfloor x/l_{\\text{cell}} \\rfloor$. We need to determine the maximum possible difference in cell indices between two particles `i` and `j` whose separation is at most $r_{\\mathrm{eff}}$.\n\nFrom the bounding condition, $r_{j,\\alpha} \\le r_{i,\\alpha} + r_{\\mathrm{eff}}$. Dividing by $l_{\\text{cell}}$ gives $r_{j,\\alpha}/l_{\\text{cell}} \\le r_{i,\\alpha}/l_{\\text{cell}} + r_{\\mathrm{eff}}/l_{\\text{cell}}$. Applying the floor function to both sides to get the cell indices, and using the identity $\\lfloor u+v \\rfloor \\le \\lfloor u \\rfloor + \\lceil v \\rceil$, we have:\n$$\nI(r_{j,\\alpha}) = \\lfloor r_{j,\\alpha}/l_{\\text{cell}} \\rfloor \\le \\lfloor r_{i,\\alpha}/l_{\\text{cell}} + r_{\\mathrm{eff}}/l_{\\text{cell}} \\rfloor \\le \\lfloor r_{i,\\alpha}/l_{\\text{cell}} \\rfloor + \\lceil r_{\\mathrm{eff}}/l_{\\text{cell}} \\rceil = I(r_{i,\\alpha}) + \\lceil r_{\\mathrm{eff}}/l_{\\text{cell}} \\rceil\n$$\nSimilarly, from $r_{j,\\alpha} \\ge r_{i,\\alpha} - r_{\\mathrm{eff}}$ and using the identity $\\lfloor u-v \\rfloor \\ge \\lfloor u \\rfloor - \\lceil v \\rceil$:\n$$\nI(r_{j,\\alpha}) \\ge I(r_{i,\\alpha}) - \\lceil r_{\\mathrm{eff}}/l_{\\text{cell}} \\rceil\n$$\nThus, to ensure all pairs are found, for a particle in a given cell, we must search all cells whose indices differ by at most $n_c = \\lceil r_{\\mathrm{eff}} / l_{\\text{cell}} \\rceil$ in each dimension. This defines a search cube of cells centered on the particle's own cell. The number of cells along each dimension is $2n_c + 1$. The total number of cells to be visited, $N_{\\text{cells}}$, is:\n$$\nN_{\\text{cells}} = (2n_c + 1)^3 = \\left( 2 \\left\\lceil \\frac{r_{\\mathrm{eff}}}{l_{\\text{cell}}} \\right\\rceil + 1 \\right)^3\n$$\nThe total volume of this search region is $V_{\\text{search}} = N_{\\text{cells}} \\cdot l_{\\text{cell}}^3$. With a uniform particle density $\\rho$, the expected number of particles in this volume is $\\rho V_{\\text{search}}$. This is the expected size of the candidate list, $S(l_{\\text{cell}})$. We neglect the $-1$ for the particle itself, as it is insignificant for a large system and in an expectation value context.\n$$\nS(l_{\\text{cell}}) = \\rho V_{\\text{search}} = \\rho l_{\\text{cell}}^3 \\left( 2 \\left\\lceil \\frac{r_{\\mathrm{eff}}}{l_{\\text{cell}}} \\right\\rceil + 1 \\right)^3\n$$\n\n**Part 2: Formulation of the Total Work $W(l_{\\text{cell}})$**\n\nThe computational work model per particle has two components: a cost $c_p$ for each candidate particle pair evaluation and an overhead $c_c$ for each cell visited.\nThe total expected work per particle, $W(l_{\\text{cell}})$, is the sum of these two costs.\n\n1.  Cost of candidate evaluations: $c_p \\times (\\text{number of candidates}) = c_p S(l_{\\text{cell}})$.\n2.  Cost of visiting cells: $c_c \\times (\\text{number of cells}) = c_c N_{\\text{cells}}$.\n\nCombining these yields the total work function:\n$$\nW(l_{\\text{cell}}) = c_p S(l_{\\text{cell}}) + c_c N_{\\text{cells}} = c_p \\rho l_{\\text{cell}}^3 \\left( 2 \\left\\lceil \\frac{r_{\\mathrm{eff}}}{l_{\\text{cell}}} \\right\\rceil + 1 \\right)^3 + c_c \\left( 2 \\left\\lceil \\frac{r_{\\mathrm{eff}}}{l_{\\text{cell}}} \\right\\rceil + 1 \\right)^3\n$$\nThis can be factored to give:\n$$\nW(l_{\\text{cell}}) = \\left( c_p \\rho l_{\\text{cell}}^3 + c_c \\right) \\left( 2 \\left\\lceil \\frac{r_{\\mathrm{eff}}}{l_{\\text{cell}}} \\right\\rceil + 1 \\right)^3\n$$\n\n**Part 3: Minimization of the Relaxed Work Function**\n\nThe function $W(l_{\\text{cell}})$ contains the ceiling function $\\lceil \\cdot \\rceil$, which makes it piecewise and difficult to differentiate analytically. The problem specifies a continuous geometric relaxation by replacing the discrete cell count with a continuous analog. This is equivalent to making the approximation $\\lceil x \\rceil \\approx x$.\nApplying this to the term $(2 \\lceil \\frac{r_{\\mathrm{eff}}}{l_{\\text{cell}}} \\rceil + 1)$, we get $(2 \\frac{r_{\\mathrm{eff}}}{l_{\\text{cell}}} + 1)$. This is consistent with the problem's stated approximations for the number of visited cells and the visited cube edge.\n\nLet $\\tilde{W}(l_{\\text{cell}})$ be the relaxed work function.\n$$\n\\tilde{W}(l_{\\text{cell}}) = \\left( c_p \\rho l_{\\text{cell}}^3 + c_c \\right) \\left( 2 \\frac{r_{\\mathrm{eff}}}{l_{\\text{cell}}} + 1 \\right)^3\n$$\nTo simplify for differentiation, we can rewrite the expression:\n$$\n\\tilde{W}(l_{\\text{cell}}) = \\left( c_p \\rho + \\frac{c_c}{l_{\\text{cell}}^3} \\right) (2 r_{\\mathrm{eff}} + l_{\\text{cell}})^3\n$$\nTo find the optimal cell size $l_{\\text{cell}}^{\\ast}$ that minimizes this work, we compute the derivative with respect to $l_{\\text{cell}}$ and set it to zero. Let $L = l_{\\text{cell}}$ for notational simplicity.\n$$\n\\frac{d\\tilde{W}}{dL} = \\frac{d}{dL} \\left[ \\left( c_p \\rho + c_c L^{-3} \\right) (2 r_{\\mathrm{eff}} + L)^3 \\right]\n$$\nUsing the product rule $(uv)' = u'v + uv'$:\n$$\n\\frac{d\\tilde{W}}{dL} = (-3 c_c L^{-4}) (2 r_{\\mathrm{eff}} + L)^3 + (c_p \\rho + c_c L^{-3}) \\cdot 3(2 r_{\\mathrm{eff}} + L)^2\n$$\nSetting the derivative to zero to find the extremum:\n$$\n0 = -3 c_c L^{-4} (2 r_{\\mathrm{eff}} + L)^3 + 3(c_p \\rho + c_c L^{-3}) (2 r_{\\mathrm{eff}} + L)^2\n$$\nSince $L > 0$ and $r_{\\mathrm{eff}} > 0$, the term $3(2 r_{\\mathrm{eff}} + L)^2$ is non-zero, so we can divide by it:\n$$\n0 = -c_c L^{-4} (2 r_{\\mathrm{eff}} + L) + (c_p \\rho + c_c L^{-3})\n$$\nMultiplying the entire equation by $L^4$ to clear the denominators:\n$$\n0 = -c_c (2 r_{\\mathrm{eff}} + L) + (c_p \\rho L^3 + c_c) L\n$$\n$$\n0 = -2 c_c r_{\\mathrm{eff}} - c_c L + c_p \\rho L^4 + c_c L\n$$\nThe terms $-c_c L$ and $+c_c L$ cancel out:\n$$\n0 = -2 c_c r_{\\mathrm{eff}} + c_p \\rho L^4\n$$\nSolving for $L^4$:\n$$\nc_p \\rho L^4 = 2 c_c r_{\\mathrm{eff}}\n$$\n$$\nL^4 = \\frac{2 c_c r_{\\mathrm{eff}}}{c_p \\rho}\n$$\nThe optimal cell size $l_{\\text{cell}}^{\\ast}$ is the fourth root of this expression. We can confirm this is a minimum by checking the second derivative, which will be positive.\n$$\nl_{\\text{cell}}^{\\ast} = \\left( \\frac{2 c_c r_{\\mathrm{eff}}}{c_p \\rho} \\right)^{1/4}\n$$\nFinally, we substitute the definition $r_{\\mathrm{eff}} = r_c + \\delta$ to express the result in terms of the given parameters.\n$$\nl_{\\text{cell}}^{\\ast} = \\left( \\frac{2 c_c (r_c + \\delta)}{c_p \\rho} \\right)^{1/4}\n$$\nThis is the closed-form symbolic expression for the optimal cell edge length under the specified model and relaxation.", "answer": "$$\\boxed{\\left( \\frac{2 c_c (r_c + \\delta)}{c_p \\rho} \\right)^{1/4}}$$", "id": "3428313"}, {"introduction": "While neighbor lists are built on geometric criteria, the underlying physics of molecular systems introduces further complexity, as bonded topology dictates that some non-bonded interactions are excluded. This practice challenges you to quantify the performance gain from \"pruning\" these topologically excluded pairs (e.g., 1-2 and 1-3 pairs) from the neighbor list. You will calculate the expected speedup, highlighting how algorithm efficiency is improved by tailoring it to the specific chemical model of the system being simulated [@problem_id:3428275].", "problem": "A three-dimensional molecular dynamics simulation of a linear homopolymer melt uses a Verlet neighbor list (VNL). The system contains $M$ identical chains, each with $N$ beads, for a total of $N_{\\text{tot}} = MN$ beads at number density $\\rho$. Nonbonded forces are computed using a spherical cutoff of radius $r_{c}$. The VNL is constructed for exactly the cutoff radius $r_{c}$ (ignore any additional skin distance), and the traversal loop touches each neighbor once per time step. The bonded topology excludes pairwise nonbonded interactions for directly bonded neighbors ($1\\text{-}2$ pairs) and for second neighbors along the chain ($1\\text{-}3$ pairs). All other intrachain and interchain nonbonded interactions are included. Assume the bond length $b$ and typical bond angle are such that all $1\\text{-}2$ and $1\\text{-}3$ pairs lie well within the nonbonded cutoff $r_{c}$, i.e., each excluded topological neighbor is always inside the cutoff. Assume a spatially uniform number density at the scale of $r_{c}$.\n\nUse the following parameters: $M = 50$, $N = 500$, $\\rho = 8.0\\,\\text{nm}^{-3}$, and $r_{c} = 1.0\\,\\text{nm}$.\n\nStarting from first principles and core definitions of neighbor lists and polymer chain topology, perform the following steps:\n\n- Derive the expected total number of candidate neighbors within the cutoff sphere for a generic bead, as a function of $\\rho$ and $r_{c}$.\n- Derive the average number of topology-excluded neighbors per bead for a linear chain of length $N$ when $1\\text{-}2$ and $1\\text{-}3$ pairs are excluded, accounting exactly for chain ends.\n- Compute the fraction $f_{\\text{excl}}$ of potential neighbors within the cutoff that are excluded due to topology.\n- Define the traversal time per neighbor as a constant cost $c_{t}$ that is independent of whether a force is evaluated (focus on traversal overhead only; consider force evaluation to be handled separately). Using this cost model, derive an expression for the expected speedup factor $S$ in traversal time when the VNL is constructed with topology pruning (excluded pairs are removed from the list) compared to a VNL without topology pruning (excluded pairs remain in the list but are skipped during force evaluation). Express $S$ purely in terms of $f_{\\text{excl}}$.\n\nEvaluate $S$ numerically for the given parameters. Round your final answer to four significant figures. Express the final speedup factor as a dimensionless number (no units).", "solution": "The problem statement has been meticulously validated and is determined to be scientifically grounded, well-posed, and complete. It presents a standard scenario in molecular dynamics simulations that can be analyzed from first principles.\n\nThe solution proceeds by following the steps outlined in the problem.\n\n**1. Derivation of the Expected Number of Candidate Neighbors ($n_{\\text{cand}}$)**\n\nFor a generic bead in the system, we consider a spherical volume of radius $r_c$ centered on it. This is the nonbonded interaction cutoff sphere. The problem states to assume a spatially uniform number density $\\rho$ at this scale. The volume of the cutoff sphere, $V_c$, is given by:\n$$V_c = \\frac{4}{3}\\pi r_c^3$$\nThe number of beads in this volume is the product of the number density and the volume. Since we are looking for the number of *neighbors* to the central bead, we count all *other* beads within this volume. Assuming the density $\\rho$ represents the average density of beads throughout the system, the expected number of candidate neighbors, $n_{\\text{cand}}$, for any given bead is:\n$$n_{\\text{cand}} = \\rho V_c = \\frac{4}{3}\\pi \\rho r_c^3$$\n\n**2. Derivation of the Average Number of Excluded Neighbors ($\\langle n_{\\text{excl}} \\rangle$)**\n\nThe problem specifies that nonbonded interactions are excluded for $1\\text{-}2$ pairs (directly bonded neighbors) and $1\\text{-}3$ pairs (beads separated by two bonds). We need to find the average number of such excluded neighbors per bead for a linear chain of length $N$. The assumption that all such pairs are within the cutoff radius $r_c$ simplifies the calculation to a purely topological count. We analyze the number of excluded neighbors based on a bead's position within the chain. Let the beads be indexed from $1$ to $N$.\n\n*   **End Beads ($i=1$ and $i=N$):** There are $2$ such beads.\n    *   An end bead (e.g., bead $1$) has one $1\\text{-}2$ neighbor (bead $2$) and one $1\\text{-}3$ neighbor (bead $3$, assuming $N \\ge 3$).\n    *   Total excluded neighbors for an end bead: $1 + 1 = 2$.\n\n*   **Penultimate Beads ($i=2$ and $i=N-1$):** There are $2$ such beads (assuming $N \\ge 4$).\n    *   A penultimate bead (e.g., bead $2$) has two $1\\text{-}2$ neighbors (beads $1$ and $3$).\n    *   It has one $1\\text{-}3$ neighbor (bead $4$). Note that bead $1$ is a $1\\text{-}2$ neighbor of bead $2$, not a $1\\text{-}3$ neighbor.\n    *   Total excluded neighbors for a penultimate bead: $2 + 1 = 3$.\n\n*   **Interior Beads ($i \\in [3, N-2]$):** There are $N-4$ such beads (assuming $N \\ge 5$).\n    *   An interior bead has two $1\\text{-}2$ neighbors (beads $i-1$ and $i+1$).\n    *   It also has two $1\\text{-}3$ neighbors (beads $i-2$ and $i+2$).\n    *   Total excluded neighbors for an interior bead: $2 + 2 = 4$.\n\nGiven $N=500$, all these categories are well-defined. The total number of excluded neighbor instances, summed over all beads in a single chain, is:\n$$\\text{Total Exclusions} = (2 \\text{ beads} \\times 2) + (2 \\text{ beads} \\times 3) + ((N-4) \\text{ beads} \\times 4)$$\nThe average number of excluded neighbors per bead, $\\langle n_{\\text{excl}} \\rangle$, is this total divided by the number of beads in the chain, $N$:\n$$\\langle n_{\\text{excl}} \\rangle = \\frac{1}{N} [2 \\times 2 + 2 \\times 3 + (N-4) \\times 4]$$\n$$\\langle n_{\\text{excl}} \\rangle = \\frac{1}{N} [4 + 6 + 4N - 16] = \\frac{4N - 6}{N} = 4 - \\frac{6}{N}$$\nThis average applies to the entire system, as all chains are identical.\n\n**3. Computation of the Fraction of Excluded Neighbors ($f_{\\text{excl}}$)**\n\nThe fraction of potential neighbors that are excluded due to topology, $f_{\\text{excl}}$, is the ratio of the average number of excluded neighbors to the average total number of candidate neighbors:\n$$f_{\\text{excl}} = \\frac{\\langle n_{\\text{excl}} \\rangle}{n_{\\text{cand}}} = \\frac{4 - \\frac{6}{N}}{\\frac{4}{3}\\pi \\rho r_c^3}$$\n\n**4. Derivation of the Speedup Factor ($S$)**\n\nLet $c_t$ be the constant traversal cost per neighbor in the list. The problem specifies that this cost is incurred even if the force evaluation is skipped.\n\n*   **Case 1: VNL without topology pruning.**\n    The neighbor list for a bead contains, on average, $n_{\\text{cand}}$ entries. The traversal loop must iterate over all of them. The average traversal time per bead, $T_{\\text{no-prune}}$, is:\n    $$T_{\\text{no-prune}} = n_{\\text{cand}} \\cdot c_t$$\n\n*   **Case 2: VNL with topology pruning.**\n    The excluded pairs are removed from the neighbor list during its construction. The number of entries in the pruned list for a bead is, on average, $n_{\\text{pruned}} = n_{\\text{cand}} - \\langle n_{\\text{excl}} \\rangle$. The average traversal time per bead, $T_{\\text{prune}}$, is:\n    $$T_{\\text{prune}} = (n_{\\text{cand}} - \\langle n_{\\text{excl}} \\rangle) \\cdot c_t$$\n\nThe speedup factor, $S$, is the ratio of the time taken without pruning to the time taken with pruning:\n$$S = \\frac{T_{\\text{no-prune}}}{T_{\\text{prune}}} = \\frac{n_{\\text{cand}} \\cdot c_t}{(n_{\\text{cand}} - \\langle n_{\\text{excl}} \\rangle) \\cdot c_t} = \\frac{n_{\\text{cand}}}{n_{\\text{cand}} - \\langle n_{\\text{excl}} \\rangle}$$\nTo express $S$ purely in terms of $f_{\\text{excl}}$, we divide the numerator and denominator by $n_{\\text{cand}}$:\n$$S = \\frac{1}{1 - \\frac{\\langle n_{\\text{excl}} \\rangle}{n_{\\text{cand}}}} = \\frac{1}{1 - f_{\\text{excl}}}$$\n\n**Numerical Evaluation**\n\nWe now substitute the given parameters: $N = 500$, $\\rho = 8.0\\,\\text{nm}^{-3}$, and $r_{c} = 1.0\\,\\text{nm}$.\n\nFirst, we calculate $n_{\\text{cand}}$:\n$$n_{\\text{cand}} = \\frac{4}{3}\\pi (8.0\\,\\text{nm}^{-3}) (1.0\\,\\text{nm})^3 = \\frac{32\\pi}{3} \\approx 33.5103$$\n\nNext, we calculate $\\langle n_{\\text{excl}} \\rangle$:\n$$\\langle n_{\\text{excl}} \\rangle = 4 - \\frac{6}{500} = 4 - 0.012 = 3.988$$\n\nNow, we compute the fraction $f_{\\text{excl}}$:\n$$f_{\\text{excl}} = \\frac{3.988}{\\frac{32\\pi}{3}} \\approx \\frac{3.988}{33.5103} \\approx 0.119008$$\n\nFinally, we calculate the speedup factor $S$:\n$$S = \\frac{1}{1 - f_{\\text{excl}}} \\approx \\frac{1}{1 - 0.119008} = \\frac{1}{0.880992} \\approx 1.1351198$$\n\nRounding the result to four significant figures gives $1.135$.\n\nThe speedup factor of $1.135$ indicates that by pruning topologically excluded pairs from the neighbor list, the traversal portion of the nonbonded force calculation is expected to be approximately $13.5\\%$ faster.", "answer": "$$\\boxed{1.135}$$", "id": "3428275"}, {"introduction": "A neighbor list is a snapshot in time, and its validity degrades as particles move. The common strategy of adding a \"skin\" provides a safety buffer, but under what conditions does this buffer fail? This computational exercise guides you through simulating a system under affine shear to find the breaking point of a static neighbor list. You will then implement a mathematically robust \"co-moving\" list that guarantees correctness even under large, continuous deformations, a crucial concept for non-equilibrium simulations [@problem_id:3428321].", "problem": "You are given a two-dimensional system of particles that undergoes a homogeneous affine shear deformation. The goal is to formalize and test when a static neighbor list, built at the initial configuration in the laboratory (original) frame, fails to include newly interacting pairs as the system deforms, and to construct a co-moving neighbor search that maintains correctness under the same deformation. You must produce a complete, runnable program that constructs explicit test cases and outputs a list of boolean results.\n\nConsider particles with initial positions $\\{\\mathbf{r}_i^{(0)}\\}_{i=1}^N \\subset \\mathbb{R}^2$, and a neighbor list built at time $t=0$ that includes all pairs $(i,j)$ such that the Euclidean distance $\\|\\mathbf{r}_i^{(0)} - \\mathbf{r}_j^{(0)}\\| \\le r_{\\ell}$, where $r_{\\ell} = r_c + r_s$, with $r_c$ the interaction cutoff and $r_s$ a nonnegative “skin” radius. The system then undergoes an affine simple shear in the $x$-direction with shear strain $\\gamma \\in \\mathbb{R}$, represented by the deformation gradient\n$$\n\\mathbf{F}(\\gamma) = \\begin{pmatrix} 1  \\gamma \\\\ 0  1 \\end{pmatrix}.\n$$\nThe positions at the deformed configuration are $\\mathbf{r}_i = \\mathbf{F}(\\gamma)\\,\\mathbf{r}_i^{(0)}$. Assume no non-affine motion. There are no periodic boundaries; use standard Euclidean distances.\n\nDefine the “frozen original-frame neighbor list validity” at deformation $\\gamma$ as the boolean statement that every pair $(i,j)$ satisfying $\\|\\mathbf{r}_i - \\mathbf{r}_j\\| \\le r_c$ is already present in the initial neighbor list built in the original frame at $t=0$ with radius $r_{\\ell} = r_c + r_s$. If this is true, the frozen list is valid; otherwise, it fails.\n\nDefine a “co-moving cell list” correctness guarantee as follows: Instead of binning and searching in the original frame, transform to material coordinates via $\\mathbf{q} = \\mathbf{F}(\\gamma)^{-1} \\mathbf{r}$ and build a static neighbor list in the material frame at $t=0$ that contains all pairs within radius\n$$\nr_{\\ell}^{\\mathrm{mat}}(\\gamma) = \\|\\mathbf{F}(\\gamma)^{-1}\\|_2\\, r_c,\n$$\nwhere $\\|\\cdot\\|_2$ denotes the spectral norm (maximum singular value). Show that this co-moving construction is guaranteed to be correct for purely affine motion by proving that if $\\|\\mathbf{r}_i - \\mathbf{r}_j\\| \\le r_c$ at deformation $\\gamma$, then $\\|\\mathbf{r}_i^{(0)} - \\mathbf{r}_j^{(0)}\\| \\le \\|\\mathbf{F}(\\gamma)^{-1}\\|_2 r_c$, ensuring the pair would have been included in the material-frame list built at $t=0$. Your program should validate this correctness numerically.\n\nStart from the following fundamental principles and definitions:\n- The Euclidean norm and triangle inequality: for any vectors $\\mathbf{a}, \\mathbf{b} \\in \\mathbb{R}^2$, $\\|\\mathbf{a} + \\mathbf{b}\\| \\le \\|\\mathbf{a}\\| + \\|\\mathbf{b}\\|$ and $\\big| \\|\\mathbf{a}\\| - \\|\\mathbf{b}\\| \\big| \\le \\|\\mathbf{a} - \\mathbf{b}\\|$.\n- The definition of a neighbor list with cutoff $r_c$ and skin $r_s$, and the common rebuild heuristic that if every particle’s displacement since the last rebuild is bounded by $r_s/2$, then no missed neighbors can occur upon deformation.\n- The spectral norm bound: for any matrix $\\mathbf{A}$ and vector $\\mathbf{x}$, $\\|\\mathbf{x}\\| \\le \\|\\mathbf{A}^{-1}\\|_2 \\|\\mathbf{A}\\mathbf{x}\\|$ whenever $\\mathbf{A}$ is invertible.\n\nYour tasks:\n1. Implement generation of initial positions as a regular grid in a rectangle $[0,L_x] \\times [0,L_y]$ with $N_x$ points in the $x$-direction and $N_y$ points in the $y$-direction, including the endpoints, yielding $N = N_x N_y$ particles. All quantities are nondimensional. Distances are Euclidean. No periodic boundaries are used.\n2. For each test case, build:\n   - The initial neighbor list in the original frame at $t=0$ computed from $\\{\\mathbf{r}_i^{(0)}\\}$ with list radius $r_{\\ell} = r_c + r_s$.\n   - The set of currently interacting pairs at deformation $\\gamma$, computed from $\\{\\mathbf{r}_i = \\mathbf{F}(\\gamma)\\mathbf{r}_i^{(0)}\\}$ with cutoff $r_c$.\n   - The material-frame neighbor list at $t=0$ computed from $\\{\\mathbf{r}_i^{(0)}\\}$ with radius $r_{\\ell}^{\\mathrm{mat}}(\\gamma) = \\|\\mathbf{F}(\\gamma)^{-1}\\|_2 r_c$, where for simple shear the spectral norm is\n     $$\n     \\|\\mathbf{F}(\\gamma)\\|_2 = \\sqrt{\\frac{(2 + \\gamma^2) + |\\gamma| \\sqrt{\\gamma^2 + 4}}{2}}, \\quad \\|\\mathbf{F}(\\gamma)^{-1}\\|_2 = \\|\\mathbf{F}(\\gamma)\\|_2.\n     $$\n3. For each test case, compute two booleans:\n   - The original-frame frozen neighbor list validity: whether every currently interacting pair is contained in the initial original-frame neighbor list.\n   - The co-moving material-frame correctness: whether every currently interacting pair is contained in the material-frame neighbor list with radius $r_{\\ell}^{\\mathrm{mat}}(\\gamma)$.\n4. Your program must output, for all test cases, a single line containing a comma-separated list of two-element lists, where each two-element list is of the form $[\\text{original\\_valid}, \\text{comoving\\_valid}]$, for the corresponding test case.\n\nScientific reasoning targets:\n- Derive a sufficient condition for the original-frame frozen neighbor list to remain valid under shear using the particle-displacement heuristic. For affine shear $\\mathbf{u}_i = \\mathbf{r}_i - \\mathbf{r}_i^{(0)} = (\\gamma y_i^{(0)}, 0)$, show that the maximum single-particle displacement satisfies $\\max_i \\|\\mathbf{u}_i\\| = |\\gamma| \\max_i |y_i^{(0)}|$. Hence, a sufficient condition for no missed neighbors is $|\\gamma| \\max_i |y_i^{(0)}| \\le r_s/2$. Explain why violation of this bound does not necessarily imply failure, but satisfying it guarantees correctness.\n- Prove the co-moving correctness bound using the spectral norm as described above.\n\nTest suite:\nUse the following four test cases, each specified by $(N_x, N_y, L_x, L_y, r_c, r_s, \\gamma)$:\n- Case $1$: $(5, 5, 1.0, 1.0, 0.26, 0.04, 0.15)$.\n- Case $2$: $(5, 5, 1.0, 1.0, 0.26, 0.20, 0.10)$.\n- Case $3$: $(10, 2, 1.0, 1.0, 0.15, 0.02, 0.90)$.\n- Case $4$: $(6, 6, 1.0, 1.0, 0.18, 0.02, 0.40)$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list of two-element lists, in the same order as the test cases. For example, the line should look like $[[\\text{True},\\text{True}],[\\text{False},\\text{True}],\\dots]$, with no spaces required beyond those generated by standard list formatting. No units are needed; all quantities are nondimensional. All computations should be exact up to standard floating-point arithmetic, and all outputs must be strict booleans.", "solution": "We begin by formalizing the neighbor list and the deformation. Let $\\{\\mathbf{r}_i^{(0)}\\}$ be the initial positions, with $\\mathbf{r}_i^{(0)} \\in \\mathbb{R}^2$. We construct a neighbor list at time $t=0$ in the original frame by including all unordered pairs $(i,j)$ with $ij$ that satisfy\n$$\n\\|\\mathbf{r}_i^{(0)} - \\mathbf{r}_j^{(0)}\\| \\le r_{\\ell}, \\quad r_{\\ell} = r_c + r_s,\n$$\nwhere $r_c  0$ is the interaction cutoff and $r_s \\ge 0$ is a skin distance. Under an affine simple shear with shear strain $\\gamma$, the deformation gradient is\n$$\n\\mathbf{F}(\\gamma) = \\begin{pmatrix} 1  \\gamma \\\\ 0  1 \\end{pmatrix},\n$$\nso that $\\mathbf{r}_i = \\mathbf{F}(\\gamma)\\,\\mathbf{r}_i^{(0)}$ and the displacement is\n$$\n\\mathbf{u}_i = \\mathbf{r}_i - \\mathbf{r}_i^{(0)} = \\big(\\gamma\\, y_i^{(0)}, 0\\big).\n$$\nFor the “frozen original-frame” neighbor list validity, we require that any pair $(i,j)$ that interacts at the deformed configuration, i.e.,\n$$\n\\|\\mathbf{r}_i - \\mathbf{r}_j\\| \\le r_c,\n$$\nmust already be present in the original neighbor list built at $t=0$ with radius $r_{\\ell}$. Formally, if we denote by $\\mathcal{N}_{\\ell}^{(0)}$ the set of pairs with $\\|\\mathbf{r}_i^{(0)} - \\mathbf{r}_j^{(0)}\\| \\le r_{\\ell}$ and by $\\mathcal{I}(\\gamma)$ the set of pairs with $\\|\\mathbf{r}_i - \\mathbf{r}_j\\| \\le r_c$, then the frozen list is valid if and only if\n$$\n\\mathcal{I}(\\gamma) \\subseteq \\mathcal{N}_{\\ell}^{(0)}.\n$$\n\nA classical sufficient condition for $\\mathcal{I}(\\gamma) \\subseteq \\mathcal{N}_{\\ell}^{(0)}$ comes from bounding the decrease in pair distances by the sum of particle displacements. For any two particles, the change in their separation obeys\n$$\n\\big| \\|\\mathbf{r}_i - \\mathbf{r}_j\\| - \\|\\mathbf{r}_i^{(0)} - \\mathbf{r}_j^{(0)}\\| \\big| \\le \\|(\\mathbf{u}_i - \\mathbf{u}_j)\\| \\le \\|\\mathbf{u}_i\\| + \\|\\mathbf{u}_j\\|,\n$$\nby the triangle inequality. If each particle’s displacement magnitude since the build is bounded by $r_s/2$, i.e.,\n$$\n\\max_i \\|\\mathbf{u}_i\\| \\le \\frac{r_s}{2},\n$$\nthen any initially non-neighbor pair with $\\|\\mathbf{r}_i^{(0)} - \\mathbf{r}_j^{(0)}\\|  r_c + r_s$ cannot become interacting, because in the worst case its separation can decrease by at most $r_s$. Under affine shear, $\\|\\mathbf{u}_i\\| = |\\gamma|\\,|y_i^{(0)}|$, so a sufficient condition for the original-frame frozen list to remain valid is\n$$\n|\\gamma| \\,\\max_i |y_i^{(0)}| \\le \\frac{r_s}{2}.\n$$\nThis condition guarantees correctness but is not necessary; it can be violated without actual missed pairs depending on geometry and $r_c$.\n\nTo maintain correctness under finite $\\gamma$ without frequent rebuilds, we consider a co-moving construction: transform to material coordinates $\\mathbf{q} = \\mathbf{F}(\\gamma)^{-1} \\mathbf{r}$, in which purely affine motion appears stationary. For any pair difference $\\Delta \\mathbf{r} = \\mathbf{r}_i - \\mathbf{r}_j$ at deformation $\\gamma$ and corresponding material difference $\\Delta \\mathbf{r}^{(0)} = \\mathbf{r}_i^{(0)} - \\mathbf{r}_j^{(0)}$, we have\n$$\n\\Delta \\mathbf{r} = \\mathbf{F}(\\gamma)\\, \\Delta \\mathbf{r}^{(0)}.\n$$\nIf a pair is interacting at deformation $\\gamma$, i.e., $\\|\\Delta \\mathbf{r}\\| \\le r_c$, then by properties of the spectral norm:\n$$\n\\|\\Delta \\mathbf{r}^{(0)}\\| \\le \\|\\mathbf{F}(\\gamma)^{-1}\\|_2 \\, \\|\\Delta \\mathbf{r}\\| \\le \\|\\mathbf{F}(\\gamma)^{-1}\\|_2 \\, r_c.\n$$\nTherefore, any interacting pair at the deformed configuration must have had an initial material separation not exceeding $r_{\\ell}^{\\mathrm{mat}}(\\gamma) = \\|\\mathbf{F}(\\gamma)^{-1}\\|_2 r_c$. Consequently, if at $t=0$ we build a neighbor list in the material frame including all pairs with $\\|\\Delta \\mathbf{r}^{(0)}\\| \\le r_{\\ell}^{\\mathrm{mat}}(\\gamma)$, then this list is guaranteed to contain all pairs that will interact at deformation $\\gamma$. This establishes correctness for purely affine motion without requiring any rebuilds, provided the list radius scales with $\\|\\mathbf{F}(\\gamma)^{-1}\\|_2$.\n\nFor simple shear, the spectral norm is obtainable from the singular values of $\\mathbf{F}(\\gamma)$. Compute $\\mathbf{F}(\\gamma)^\\top \\mathbf{F}(\\gamma)$:\n$$\n\\mathbf{F}(\\gamma)^\\top \\mathbf{F}(\\gamma) = \\begin{pmatrix} 1  0 \\\\ \\gamma  1 \\end{pmatrix} \\begin{pmatrix} 1  \\gamma \\\\ 0  1 \\end{pmatrix} = \\begin{pmatrix} 1  \\gamma \\\\ \\gamma  \\gamma^2 + 1 \\end{pmatrix}.\n$$\nThe eigenvalues of this symmetric matrix are\n$$\n\\lambda_{\\pm} = \\frac{(2 + \\gamma^2) \\pm |\\gamma| \\sqrt{\\gamma^2 + 4}}{2},\n$$\nso the singular values of $\\mathbf{F}(\\gamma)$ are $\\sigma_{\\max} = \\sqrt{\\lambda_{+}}$ and $\\sigma_{\\min} = \\sqrt{\\lambda_{-}}$. Since $\\det \\mathbf{F}(\\gamma) = 1$, we have $\\sigma_{\\max} \\sigma_{\\min} = 1$, implying\n$$\n\\|\\mathbf{F}(\\gamma)\\|_2 = \\sigma_{\\max} = \\sqrt{\\frac{(2 + \\gamma^2) + |\\gamma| \\sqrt{\\gamma^2 + 4}}{2}}, \\quad \\|\\mathbf{F}(\\gamma)^{-1}\\|_2 = \\sigma_{\\max}.\n$$\n\nAlgorithmic design for the program:\n- For each test case, generate a regular grid of size $N_x \\times N_y$ over $[0,L_x] \\times [0,L_y]$, including endpoints. This yields coordinates $\\mathbf{r}_i^{(0)}$.\n- Build the initial original-frame neighbor set $\\mathcal{N}_{\\ell}^{(0)}$ by enumerating all pairs with $\\|\\mathbf{r}_i^{(0)} - \\mathbf{r}_j^{(0)}\\| \\le r_{\\ell} = r_c + r_s$.\n- Deform positions via $\\mathbf{r}_i = \\mathbf{F}(\\gamma) \\mathbf{r}_i^{(0)}$ and build the current interacting set $\\mathcal{I}(\\gamma)$ with cutoff $r_c$.\n- Compute $\\sigma_{\\max} = \\|\\mathbf{F}(\\gamma)^{-1}\\|_2$ via the closed-form expression above, and build the material neighbor set $\\mathcal{N}_{\\ell}^{\\mathrm{mat}}$ using the initial positions with radius $r_{\\ell}^{\\mathrm{mat}}(\\gamma) = \\sigma_{\\max} r_c$.\n- Evaluate two booleans per case:\n  - Original-frame validity: $\\mathcal{I}(\\gamma) \\subseteq \\mathcal{N}_{\\ell}^{(0)}$.\n  - Co-moving correctness: $\\mathcal{I}(\\gamma) \\subseteq \\mathcal{N}_{\\ell}^{\\mathrm{mat}}$.\n\nInterpretation with the test suite:\n- Case $1$ has $r_s = 0.04$, so $r_s/2 = 0.02$, while the maximum $|y_i^{(0)}|$ equals $L_y = 1.0$, hence the sufficient condition $|\\gamma|\\max |y| \\le r_s/2$ is violated for $\\gamma = 0.15$. Failure is possible and is detected numerically if any pair not in the initial list becomes interacting after shear. The program reports the actual boolean outcome. The co-moving construction will report true since it is guaranteed by the spectral norm bound.\n- Case $2$ has $r_s = 0.20$, so $r_s/2 = 0.10$, and $\\gamma = 0.10$ saturates the sufficient condition. By construction, the original-frame frozen list is guaranteed valid in this case. The co-moving construction remains valid.\n- Case $3$ has $\\gamma = 0.90$ and a very small interaction range $r_c = 0.15$ with only two rows ($N_y = 2$). Although the sufficient condition is violated ($0.90  0.01$), the geometry prevents any new interactions from forming; thus, the original-frame list can remain valid. The program computes the exact boolean by pair enumeration. The co-moving construction remains valid.\n- Case $4$ explores an intermediate density and cutoff where deformation can cause missed neighbors; the program determines validity explicitly.\n\nThe program outputs a single line containing a list of two-element lists $[[b_{1,\\mathrm{orig}}, b_{1,\\mathrm{comov}}], \\dots, [b_{4,\\mathrm{orig}}, b_{4,\\mathrm{comov}}]]$, where each $b$ is a boolean. This directly tests the neighbor list failure in the original frame and the correctness of the co-moving construction under affine shear.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef generate_grid(Nx, Ny, Lx, Ly):\n    # Include endpoints\n    xs = np.linspace(0.0, Lx, Nx)\n    ys = np.linspace(0.0, Ly, Ny)\n    X, Y = np.meshgrid(xs, ys, indexing='xy')\n    pts = np.stack([X.ravel(), Y.ravel()], axis=1)\n    return pts\n\ndef build_pairs(positions, r_cut):\n    # Return set of pairs (i,j) with ij and distance = r_cut\n    N = positions.shape[0]\n    pairs = set()\n    # For small N this nested loop is fine\n    for i in range(N):\n        pi = positions[i]\n        # Only ji\n        diff = positions[i+1:] - pi\n        d2 = np.einsum('ij,ij-i', diff, diff)\n        within = np.where(d2 = r_cut * r_cut)[0]\n        for idx in within:\n            j = i + 1 + int(idx)\n            pairs.add((i, j))\n    return pairs\n\ndef apply_shear(positions, gamma):\n    # Simple shear: x' = x + gamma * y; y' = y\n    pos = positions.copy()\n    pos[:, 0] = positions[:, 0] + gamma * positions[:, 1]\n    return pos\n\ndef shear_sigma_max(gamma):\n    # Spectral norm of F = [[1, gamma],[0,1]] equals sqrt(((2+g^2)+|g|*sqrt(g^2+4))/2)\n    g = float(gamma)\n    term = (2.0 + g*g) + abs(g) * np.sqrt(g*g + 4.0)\n    return np.sqrt(0.5 * term)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (Nx, Ny, Lx, Ly, r_c, r_s, gamma)\n    test_cases = [\n        (5, 5, 1.0, 1.0, 0.26, 0.04, 0.15),  # Case 1\n        (5, 5, 1.0, 1.0, 0.26, 0.20, 0.10),  # Case 2\n        (10, 2, 1.0, 1.0, 0.15, 0.02, 0.90), # Case 3\n        (6, 6, 1.0, 1.0, 0.18, 0.02, 0.40),  # Case 4\n    ]\n\n    results = []\n    for case in test_cases:\n        Nx, Ny, Lx, Ly, r_c, r_s, gamma = case\n        # Generate initial positions\n        pos0 = generate_grid(Nx, Ny, Lx, Ly)\n        # Build initial original-frame neighbor list with r_list = r_c + r_s\n        r_list = r_c + r_s\n        orig_list_pairs = build_pairs(pos0, r_list)\n\n        # Apply shear to get current positions\n        pos_t = apply_shear(pos0, gamma)\n        # Build current interacting pairs at r_c\n        current_pairs = build_pairs(pos_t, r_c)\n\n        # Original-frame validity: all current_pairs must be in orig_list_pairs\n        original_valid = current_pairs.issubset(orig_list_pairs)\n\n        # Co-moving construction: build material-frame neighbor list with r_list_mat = ||F^{-1}|| * r_c\n        sigma_max = shear_sigma_max(gamma)\n        r_list_mat = sigma_max * r_c\n        material_list_pairs = build_pairs(pos0, r_list_mat)\n\n        # Co-moving validity: all current interacting pairs must be in material-frame list\n        comoving_valid = current_pairs.issubset(material_list_pairs)\n\n        results.append([original_valid, comoving_valid])\n\n    # Final print statement in the exact required format.\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "3428321"}]}