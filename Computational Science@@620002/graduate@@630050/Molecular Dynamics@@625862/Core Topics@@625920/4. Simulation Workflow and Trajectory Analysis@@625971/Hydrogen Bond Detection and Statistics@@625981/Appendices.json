{"hands_on_practices": [{"introduction": "A brute-force search for hydrogen bonds in a simulation of $N$ molecules scales as $O(N^2)$, which is computationally prohibitive for large systems. This exercise guides you through deriving the improved $O(N)$ scaling achieved with a cell list algorithm, a cornerstone of modern simulation software. Understanding this principle is key to appreciating how large-scale simulations are made feasible [@problem_id:3416805].", "problem": "A cubic periodic system representative of Molecular Dynamics (MD) simulations contains a homogeneous fluid suitable for hydrogen bond analysis. The system has $N$ molecules uniformly distributed in a cubic box of volume $V$ with number density $\\rho = N/V$. In the geometric hydrogen bond criterion, only donor–acceptor pairs within an Euclidean distance less than a cutoff $r_{c}$ are considered distance-qualified; angular criteria are applied after distance qualification.\n\nConsider a water-like fluid where each molecule contributes $m_{d}$ donor sites and $m_{a}$ acceptor sites, and donors and acceptors are uniformly and independently distributed following the same spatial homogeneity as molecules. Hydrogen bond detection is performed per frame by looping over all donor sites and, for each donor, evaluating donor–acceptor distances against $r_{c}$. The naive approach that checks all donor–acceptor pairs scales as the square of the system size.\n\nTo accelerate the distance search, a cell list is built by partitioning the box into equal cubic cells of edge length $a$, with $a = r_{c}$. For each donor site, only acceptor sites residing in the donor’s own cell and the $3 \\times 3 \\times 3$ block of adjacent cells are considered for distance evaluation; periodic boundary conditions ensure that this neighborhood is well defined at the box boundaries.\n\nStarting from the definitions of number density and uniform spatial distribution, and without invoking any unstated formulas, derive the scaling of the expected number of donor–acceptor distance evaluations per frame under the cell list algorithm for a homogeneous system. Then, using the parameters\n- $N = 1.0 \\times 10^{5}$ molecules,\n- $\\rho = 3.34 \\times 10^{1}\\ \\mathrm{nm}^{-3}$,\n- $m_{d} = 2$ donors per molecule,\n- $m_{a} = 2$ acceptors per molecule,\n- $r_{c} = 3.5 \\times 10^{-1}\\ \\mathrm{nm}$,\n- $a = r_{c}$,\nand assuming independence between donors and acceptors and spatial homogeneity, compute the expected total number of donor–acceptor distance computations per frame performed by the cell list algorithm. Express your final answer as a pure count (no units) and round your answer to four significant figures.", "solution": "The problem statement has been rigorously validated and is determined to be scientifically grounded, well-posed, objective, and self-contained. It presents a standard, solvable problem in computational statistical mechanics.\n\nThe task is to first derive the scaling and then compute the expected total number of donor–acceptor distance evaluations per frame for a molecular dynamics simulation using a cell list algorithm. The derivation must start from fundamental definitions.\n\nLet $N$ be the total number of molecules in a cubic box of volume $V$. The number density of molecules is given as $\\rho = N/V$. Each molecule possesses $m_d$ donor sites and $m_a$ acceptor sites. The total number of donor sites in the system is $N_d = N m_d$, and the total number of acceptor sites is $N_a = N m_a$.\n\nThe problem states that molecules, and thus donor and acceptor sites, are uniformly and independently distributed throughout the volume $V$. This principle of spatial homogeneity implies that the number density of any species of site is constant throughout the box. The number density of acceptor sites, $\\rho_a$, is therefore:\n$$ \\rho_a = \\frac{N_a}{V} = \\frac{N m_a}{V} = \\left(\\frac{N}{V}\\right) m_a = \\rho m_a $$\n\nThe cell list algorithm proceeds by iterating over all donor sites in the system. For each donor site, it calculates the distance to a subset of acceptor sites. The total number of distance evaluations is the sum of evaluations performed for each donor. By linearity of expectation, the total expected number of evaluations, $\\mathbb{E}[E]$, is the product of the total number of donor sites, $N_d$, and the expected number of distance evaluations for a single, arbitrary donor site, $\\mathbb{E}[E_{\\text{per donor}}]$.\n$$ \\mathbb{E}[E] = N_d \\cdot \\mathbb{E}[E_{\\text{per donor}}] $$\n\nTo find $\\mathbb{E}[E_{\\text{per donor}}]$, we must determine the number of acceptor sites checked for a given donor. The algorithm defines a search neighborhood for each donor as its own cell plus the surrounding $26$ adjacent cells, forming a $3 \\times 3 \\times 3$ block of cells. The total number of cells in this search neighborhood is $27$.\n\nThe cells are cubic with an edge length $a$. The problem specifies that $a=r_c$, where $r_c$ is the distance cutoff for hydrogen bonds. The volume of a single cell is $V_{\\text{cell}} = a^3 = r_c^3$. The total volume of the search neighborhood for a single donor, $V_{\\text{search}}$, is:\n$$ V_{\\text{search}} = 27 \\cdot V_{\\text{cell}} = 27 a^3 = 27 r_c^3 $$\nSince periodic boundary conditions are used, this search volume is constant for every donor in the system, regardless of its position.\n\nThe expected number of acceptor sites residing within this search volume, $\\mathbb{E}[N_{a, \\text{search}}]$, is given by the product of the acceptor site density, $\\rho_a$, and the search volume, $V_{\\text{search}}$. This is a direct consequence of the uniform spatial distribution.\n$$ \\mathbb{E}[N_{a, \\text{search}}] = \\rho_a \\cdot V_{\\text{search}} = (\\rho m_a) \\cdot (27 r_c^3) $$\nThis quantity represents the expected number of distance evaluations per donor site, so $\\mathbb{E}[E_{\\text{per donor}}] = \\mathbb{E}[N_{a, \\text{search}}]$.\n\nWe can now formulate the expression for the total expected number of distance evaluations per frame, $\\mathbb{E}[E]$:\n$$ \\mathbb{E}[E] = N_d \\cdot \\mathbb{E}[N_{a, \\text{search}}] = (N m_d) \\cdot (27 \\rho m_a r_c^3) $$\n$$ \\mathbb{E}[E] = 27 N m_d m_a \\rho r_c^3 $$\n\nThis completes the first part of the task: the derivation. To determine the scaling, we analyze this expression. For a given fluid at a given thermodynamic state, the parameters $m_d$, $m_a$, $\\rho$, and $r_c$ are constants. The total expected number of computations $\\mathbb{E}[E]$ is therefore directly proportional to the number of molecules $N$.\n$$ \\mathbb{E}[E] \\propto N $$\nThe scaling of the expected number of evaluations is linear with the system size, which is denoted as $O(N)$.\n\nThe second part of the task is to compute the numerical value of $\\mathbb{E}[E]$ using the provided parameters:\n- $N = 1.0 \\times 10^{5}$\n- $\\rho = 3.34 \\times 10^{1}\\ \\mathrm{nm}^{-3}$\n- $m_d = 2$\n- $m_a = 2$\n- $r_c = 3.5 \\times 10^{-1}\\ \\mathrm{nm}$\n\nSubstituting these values into the derived formula:\n$$ \\mathbb{E}[E] = 27 \\cdot (1.0 \\times 10^{5}) \\cdot (2) \\cdot (2) \\cdot (3.34 \\times 10^{1}\\ \\mathrm{nm}^{-3}) \\cdot (3.5 \\times 10^{-1}\\ \\mathrm{nm})^3 $$\nThe units $(\\mathrm{nm}^{-3}) \\cdot (\\mathrm{nm})^3$ cancel, yielding a dimensionless count as expected. Let us evaluate the numerical result.\n$$ (3.5 \\times 10^{-1})^3 = 3.5^3 \\times (10^{-1})^3 = 42.875 \\times 10^{-3} $$\n$$ \\mathbb{E}[E] = 27 \\cdot (1.0 \\times 10^{5}) \\cdot 4 \\cdot (33.4) \\cdot (42.875 \\times 10^{-3}) $$\n$$ \\mathbb{E}[E] = (27 \\cdot 4 \\cdot 33.4 \\cdot 42.875) \\cdot (10^5 \\cdot 10^{-3}) $$\n$$ \\mathbb{E}[E] = (108 \\cdot 33.4 \\cdot 42.875) \\cdot 10^2 $$\n$$ \\mathbb{E}[E] = (3607.2 \\cdot 42.875) \\cdot 10^2 $$\n$$ \\mathbb{E}[E] = 154651.5 \\cdot 10^2 $$\n$$ \\mathbb{E}[E] = 15,465,150 $$\nIn standard scientific notation, this is $1.546515 \\times 10^7$.\n\nThe problem requires the final answer to be rounded to four significant figures.\n$$ \\mathbb{E}[E] \\approx 1.547 \\times 10^7 $$", "answer": "$$ \\boxed{1.547 \\times 10^{7}} $$", "id": "3416805"}, {"introduction": "Molecular dynamics simulations of bulk phases rely on Periodic Boundary Conditions (PBC) to minimize surface effects, but this creates a challenge: how do we measure the distance between atoms on opposite sides of the simulation box? This coding exercise tasks you with implementing and comparing a naive distance calculation with the correct Minimum Image Convention (MIC). Through this practice, you will quantify the critical errors that arise from ignoring PBC and appreciate the necessity of proper geometric handling in periodic systems [@problem_id:3416826].", "problem": "You are given a task in molecular dynamics to rigorously evaluate the impact of periodic boundary conditions (PBC) and imaging choices on hydrogen bond detection near the edges of a cubic simulation box. Your goal is to derive from foundational principles a minimum-image consistent algorithm for hydrogen bond geometry evaluation and quantify the resulting biases in the hydrogen-bond radial–angular distribution function, denoted as $g_{\\mathrm{HB}}(r,\\theta)$, where $r$ is the acceptor–hydrogen distance and $\\theta$ is the donor–hydrogen–acceptor angle. Work in a cubic box of edge length $L$ with periodic boundary conditions, and treat all molecules as rigid water-like entities to construct donor and acceptor sets.\n\nStart from the following foundational base:\n- Under periodic boundary conditions, the physical system is modeled as an infinite tiling of the primary simulation box, and \"nearest-image\" geometry must be used to compute interatomic vectors. The minimum-image convention states that the physically relevant displacement vector between two positions is the one with the smallest Euclidean norm among all periodic images.\n- Hydrogen bond geometry is defined by the pair $(r,\\theta)$ with $r$ equal to the norm of the vector from hydrogen to the acceptor heavy atom, and $\\theta$ equal to the angle at the hydrogen between the vector from the hydrogen to its donor heavy atom and the vector from the hydrogen to the acceptor heavy atom. Distances must be expressed in ångström units and angles must be expressed in degrees.\n\nYour program must implement two algorithms for evaluating $(r,\\theta)$ for all donor–acceptor candidates across all frames in a test suite:\n1. A naive, non-imaged algorithm that computes raw Cartesian differences without invoking periodic minimum-image mapping.\n2. A minimum-image consistent algorithm that uses the same periodic mapping for the donor–hydrogen and hydrogen–acceptor vectors, ensuring compatibility with periodic boundary conditions.\n\nUsing these two algorithms, compute two-dimensional histograms that approximate $g_{\\mathrm{HB}}(r,\\theta)$ over fixed bins and normalize them to probability densities so that the integral over the histogram domain equals $1$. Quantify the bias induced by the naive algorithm relative to the minimum-image consistent algorithm by calculating the root-mean-square difference between the normalized histograms. For each test case, report this single scalar bias as a dimensionless float.\n\nTest suite and geometry specifications:\n- Use water-like molecules, each with one donor heavy atom at position $\\mathbf{O}$ and two hydrogens at positions $\\mathbf{H}_1$ and $\\mathbf{H}_2$. Hydrogens are placed relative to $\\mathbf{O}$ using fixed offsets $\\Delta \\mathbf{r}_1 = (0.95,0,0)$ and $\\Delta \\mathbf{r}_2 = (-0.24,0.93,0)$ in ångström units, followed by wrapping each hydrogen coordinate into the primary box using modulo arithmetic onto $[0,L)$ for each Cartesian component. The donor heavy atom is the oxygen $\\mathbf{O}$ of each molecule. Each oxygen $\\mathbf{O}$ also acts as an acceptor for all hydrogens of other molecules (cross-molecular pairs only).\n- For each test case, the program must evaluate across two frames. Distances must be computed in ångström units and angles in degrees. The radial histogram must use bin edges $[1.5,1.9,2.3,2.7,3.1,3.5]$ in ångström units, and the angular histogram must use bin edges $[120,130,140,150,160,170,180]$ in degrees. The two-dimensional histogram must be normalized to a probability density $g_{\\mathrm{HB}}(r,\\theta)$ such that the sum over all bins of $g_{\\mathrm{HB}}(r,\\theta)\\,\\Delta r\\,\\Delta \\theta$ equals $1$, where $\\Delta r$ and $\\Delta \\theta$ are the bin widths for $r$ and $\\theta$, respectively. If a test case yields no pairs within the histogram domain, define its histogram as identically zero and the bias as $0$.\n- The test suite consists of four cases with the following parameters:\n    - Case $1$: $L = 10$ ångström units, frame $1$ molecules:\n        - Molecule $\\mathrm{A}$: $\\mathbf{O} = (9.8,5.0,5.0)$, $\\mathbf{H}_1 = (0.75,5.0,5.0)$, $\\mathbf{H}_2 = (9.56,5.93,5.0)$.\n        - Molecule $\\mathrm{B}$: $\\mathbf{O} = (2.4,5.2,5.0)$, $\\mathbf{H}_1 = (3.35,5.2,5.0)$, $\\mathbf{H}_2 = (2.16,6.13,5.0)$.\n      Frame $2$ molecules:\n        - Molecule $\\mathrm{A}$: $\\mathbf{O} = (9.9,5.1,5.0)$, $\\mathbf{H}_1 = (0.85,5.1,5.0)$, $\\mathbf{H}_2 = (9.66,6.03,5.0)$.\n        - Molecule $\\mathrm{B}$: $\\mathbf{O} = (2.5,5.1,5.0)$, $\\mathbf{H}_1 = (3.45,5.1,5.0)$, $\\mathbf{H}_2 = (2.26,6.03,5.0)$.\n    - Case $2$: $L = 20$ ångström units, frame $1$ molecules:\n        - Molecule $\\mathrm{C}$: $\\mathbf{O} = (10.0,10.0,10.0)$, $\\mathbf{H}_1 = (10.95,10.0,10.0)$, $\\mathbf{H}_2 = (9.76,10.93,10.0)$.\n        - Molecule $\\mathrm{D}$: $\\mathbf{O} = (14.0,14.0,14.0)$, $\\mathbf{H}_1 = (14.95,14.0,14.0)$, $\\mathbf{H}_2 = (13.76,14.93,14.0)$.\n      Frame $2$ molecules:\n        - Molecule $\\mathrm{C}$: $\\mathbf{O} = (10.1,10.1,10.0)$, $\\mathbf{H}_1 = (11.05,10.1,10.0)$, $\\mathbf{H}_2 = (9.86,11.03,10.0)$.\n        - Molecule $\\mathrm{D}$: $\\mathbf{O} = (13.9,14.1,14.0)$, $\\mathbf{H}_1 = (14.85,14.1,14.0)$, $\\mathbf{H}_2 = (13.66,15.03,14.0)$.\n    - Case $3$: $L = 8$ ångström units, frame $1$ molecules:\n        - Molecule $\\mathrm{E}$: $\\mathbf{O} = (7.9,3.0,3.0)$, $\\mathbf{H}_1 = (0.85,3.0,3.0)$, $\\mathbf{H}_2 = (7.66,3.93,3.0)$.\n        - Molecule $\\mathrm{F}$: $\\mathbf{O} = (2.4,3.1,3.0)$, $\\mathbf{H}_1 = (3.35,3.1,3.0)$, $\\mathbf{H}_2 = (2.16,4.03,3.0)$.\n      Frame $2$ molecules:\n        - Molecule $\\mathrm{E}$: $\\mathbf{O} = (7.85,3.1,3.0)$, $\\mathbf{H}_1 = (0.80,3.1,3.0)$, $\\mathbf{H}_2 = (7.61,4.03,3.0)$.\n        - Molecule $\\mathrm{F}$: $\\mathbf{O} = (2.5,3.2,3.0)$, $\\mathbf{H}_1 = (3.45,3.2,3.0)$, $\\mathbf{H}_2 = (2.26,4.13,3.0)$.\n    - Case $4$: $L = 12$ ångström units, frame $1$ molecules:\n        - Molecule $\\mathrm{G}$: $\\mathbf{O} = (1.0,1.0,1.0)$, $\\mathbf{H}_1 = (1.95,1.0,1.0)$, $\\mathbf{H}_2 = (0.76,1.93,1.0)$.\n        - Molecule $\\mathrm{H}$: $\\mathbf{O} = (9.5,9.5,9.5)$, $\\mathbf{H}_1 = (10.45,9.5,9.5)$, $\\mathbf{H}_2 = (9.26,10.43,9.5)$.\n      Frame $2$ molecules:\n        - Molecule $\\mathrm{G}$: $\\mathbf{O} = (1.5,1.5,1.0)$, $\\mathbf{H}_1 = (2.45,1.5,1.0)$, $\\mathbf{H}_2 = (1.26,2.43,1.0)$.\n        - Molecule $\\mathrm{H}$: $\\mathbf{O} = (9.0,9.0,10.0)$, $\\mathbf{H}_1 = (9.95,9.0,10.0)$, $\\mathbf{H}_2 = (8.76,9.93,10.0)$.\n\nProgram requirements:\n- Implement both the naive and minimum-image consistent algorithms to compute $(r,\\theta)$ for all donor–acceptor candidates across all frames and molecules in each test case, where donors are $(\\mathbf{O},\\mathbf{H}_k)$ pairs and acceptors are $\\mathbf{O}$ of other molecules.\n- Build two-dimensional histograms over the specified bin edges for $r$ in ångström units and $\\theta$ in degrees, and normalize to a probability density $g_{\\mathrm{HB}}(r,\\theta)$ as described.\n- Compute for each test case the bias defined as the root-mean-square difference between the two normalized histograms.\n\nFinal output:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[r_1,r_2,r_3,r_4]$), where each $r_i$ is the bias value (dimensionless float) for the corresponding test case in the order given above.", "solution": "The problem requires a rigorous comparison between two computational algorithms for determining hydrogen bond geometry in a molecular dynamics context under periodic boundary conditions (PBC). The goal is to quantify the bias introduced by a naive algorithm that ignores PBC, relative to a physically correct minimum-image consistent (MIC) algorithm. The bias is measured as the root-mean-square difference between the normalized two-dimensional radial-angular distribution functions, $g_{\\mathrm{HB}}(r,\\theta)$, produced by each method.\n\nThe foundational principles and algorithmic design are detailed below. All mathematical entities are rendered in LaTeX as required.\n\n### 1. Periodic Boundary Conditions and the Minimum Image Convention\n\nIn computer simulations of bulk matter, periodic boundary conditions are employed to mitigate finite-size effects. The simulation box is treated as the primitive cell of an infinite lattice, effectively creating an infinite, periodic system. When calculating the interaction or geometric relationship between two particles $i$ and $j$ at positions $\\mathbf{r}_i$ and $\\mathbf{r}_j$, one must consider the interaction between particle $i$ and all periodic images of particle $j$.\n\nThe Minimum Image Convention (MIC) is the standard procedure for this. It states that the physically relevant displacement is the shortest possible vector between particle $i$ and any image of particle $j$. For a cubic simulation box of edge length $L$, the raw displacement vector is $\\mathbf{d} = \\mathbf{r}_j - \\mathbf{r}_i$. Each Cartesian component of the minimum image vector, $\\mathbf{d}_{\\text{mic}}$, is calculated to be in the interval $[-L/2, L/2]$. This can be achieved by the component-wise operation:\n$$\nd_{k, \\text{mic}} = d_k - L \\cdot \\left\\lfloor \\frac{d_k}{L} + \\frac{1}{2} \\right\\rfloor \\quad \\text{for } k \\in \\{x, y, z\\}\n$$\nwhere $\\lfloor \\cdot \\rfloor$ is the floor function. This operation effectively finds the nearest image of particle $j$ with respect to particle $i$. We define a vector function $\\text{MIC}(\\mathbf{d}, L)$ that applies this operation to all components of $\\mathbf{d}$.\n\n### 2. Hydrogen Bond Geometry Definition\n\nA hydrogen bond is characterized by a donor-hydrogen-acceptor triplet of atoms. Let their positions be $\\mathbf{r}_D$ (donor heavy atom), $\\mathbf{r}_H$ (hydrogen), and $\\mathbf{r}_A$ (acceptor heavy atom). The geometry is defined by two parameters:\n1.  The hydrogen-acceptor distance, $r$, which is the norm of the vector from $\\mathbf{H}$ to $\\mathbf{A}$.\n2.  The donor-hydrogen-acceptor angle, $\\theta$, which is the angle formed at the hydrogen atom.\n\nThe crucial distinction between the two algorithms lies in how the vectors defining $r$ and $\\theta$ are calculated. We define the fundamental vectors originating from the hydrogen atom:\n-   Vector from hydrogen to donor: $\\mathbf{v}_{HD} = \\mathbf{r}_D - \\mathbf{r}_H$\n-   Vector from hydrogen to acceptor: $\\mathbf{v}_{HA} = \\mathbf{r}_A - \\mathbf{r}_H$\n\n### 3. Algorithm Implementation\n\n#### a. Naive (Non-Imaged) Algorithm\nThis algorithm computes the geometric parameters using the raw Cartesian displacement vectors, without accounting for PBC. This approach is fundamentally flawed as it ignores the periodic nature of the system, leading to incorrect distances and angles for atom pairs separated by a box boundary.\n\n-   Distance: $r_{\\text{naive}} = ||\\mathbf{r}_A - \\mathbf{r}_H||_2$\n-   Angle: The angle is calculated from the dot product of the raw vectors.\n    $$\n    \\theta_{\\text{naive}} = \\arccos\\left(\\frac{(\\mathbf{r}_D - \\mathbf{r}_H) \\cdot (\\mathbf{r}_A - \\mathbf{r}_H)}{||\\mathbf{r}_D - \\mathbf{r}_H||_2 \\cdot ||\\mathbf{r}_A - \\mathbf{r}_H||_2}\\right)\n    $$\n    The result is converted from radians to degrees.\n\n#### b. Minimum-Image Consistent (MIC) Algorithm\nThis algorithm correctly applies the MIC to all displacement vectors used in the geometric calculation. This ensures that the geometry reflects the true proximity in the periodically replicated space.\n\n1.  Compute the minimum-image vector from $\\mathbf{H}$ to $\\mathbf{D}$: $\\mathbf{v}_{HD}^{\\text{mic}} = \\text{MIC}(\\mathbf{r}_D - \\mathbf{r}_H, L)$.\n2.  Compute the minimum-image vector from $\\mathbf{H}$ to $\\mathbf{A}$: $\\mathbf{v}_{HA}^{\\text{mic}} = \\text{MIC}(\\mathbf{r}_A - \\mathbf{r}_H, L)$.\n3.  Calculate distance and angle using these MIC-corrected vectors:\n    -   Distance: $r_{\\text{mic}} = ||\\mathbf{v}_{HA}^{\\text{mic}}||_2$\n    -   Angle:\n        $$\n        \\theta_{\\text{mic}} = \\arccos\\left(\\frac{\\mathbf{v}_{HD}^{\\text{mic}} \\cdot \\mathbf{v}_{HA}^{\\text{mic}}}{||\\mathbf{v}_{HD}^{\\text{mic}}||_2 \\cdot ||\\mathbf{v}_{HA}^{\\text{mic}}||_2}\\right)\n        $$\n        The result is converted from radians to degrees.\n\n### 4. Statistical Analysis and Bias Quantification\n\nFor each algorithm, the set of all calculated $(r, \\theta)$ pairs across all valid donor-acceptor candidates and all frames is collected.\n\n#### a. Histogramming\nA two-dimensional histogram is constructed using the provided bin edges:\n-   Radial bins ($r$): edges at $[1.5, 1.9, 2.3, 2.7, 3.1, 3.5]$ ångströms. This results in $5$ bins, each of width $\\Delta r = 0.4$ Å.\n-   Angular bins ($\\theta$): edges at $[120, 130, 140, 150, 160, 170, 180]$ degrees. This results in $6$ bins, each of width $\\Delta \\theta = 10$ degrees.\nThe raw histogram, $N_{ij}$, contains the count of $(r, \\theta)$ pairs falling into bin $(i, j)$.\n\n#### b. Normalization\nThe raw counts $N_{ij}$ are normalized to a probability density function $g_{ij}$ such that the integral over the domain is unity. Let $N_{\\text{total}} = \\sum_{i,j} N_{ij}$ be the total number of pairs that fall within the histogram's range. The normalized density in bin $(i, j)$ is:\n$$\ng_{ij} = \\frac{N_{ij}}{N_{\\text{total}} \\cdot \\Delta r \\cdot \\Delta \\theta}\n$$\nThis is valid for $N_{\\text{total}} > 0$. If $N_{\\text{total}} = 0$, all $g_{ij}$ are defined as $0$. This normalization ensures that $\\sum_{i,j} g_{ij} \\Delta r \\Delta \\theta = 1$.\n\n#### c. Bias Calculation\nThe bias introduced by the naive algorithm is quantified by the root-mean-square difference (RMSD) between the two normalized histograms, $g^{\\text{naive}}$ and $g^{\\text{mic}}$. The sum is over all $N_{\\text{bins}} = 5 \\times 6 = 30$ bins of the histogram.\n$$\n\\text{Bias} = \\sqrt{\\frac{1}{N_{\\text{bins}}} \\sum_{i,j} (g_{ij}^{\\text{naive}} - g_{ij}^{\\text{mic}})^2}\n$$\nIf both histograms are empty (i.e., no pairs are found in the specified range for either algorithm), the bias is $0$.\n\n### 5. Computational Procedure\n\nThe solution proceeds by executing the following steps for each test case:\n1.  Initialize empty lists to store the $(r, \\theta)$ pairs for both algorithms.\n2.  Iterate through the two frames provided for the test case.\n3.  For each frame, iterate through all possible cross-molecular donor-acceptor pairings. Per the problem statement, with two molecules (e.g., A and B), the pairs are (Donor A, Acceptor B) and (Donor B, Acceptor A).\n4.  For each pairing, iterate through the two hydrogen atoms of the donor molecule.\n5.  For each resulting D-H-A triplet, calculate $(r, \\theta)$ using both the naive and MIC algorithms. Store the results.\n6.  After processing all pairs, generate the 2D histograms $N_{ij}^{\\text{naive}}$ and $N_{ij}^{\\text{mic}}$ from the collected pairs and specified bin edges.\n7.  Normalize both histograms to obtain probability densities $g_{ij}^{\\text{naive}}$ and $g_{ij}^{\\text{mic}}$.\n8.  Calculate the final scalar bias using the RMSD formula.\nThe resulting bias values for all four cases are collected and reported.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the hydrogen bond geometry problem for all test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1\n        {\n            \"L\": 10.0,\n            \"frames\": [\n                [ # Frame 1\n                    {\"O\": (9.8, 5.0, 5.0), \"H1\": (0.75, 5.0, 5.0), \"H2\": (9.56, 5.93, 5.0)},\n                    {\"O\": (2.4, 5.2, 5.0), \"H1\": (3.35, 5.2, 5.0), \"H2\": (2.16, 6.13, 5.0)}\n                ],\n                [ # Frame 2\n                    {\"O\": (9.9, 5.1, 5.0), \"H1\": (0.85, 5.1, 5.0), \"H2\": (9.66, 6.03, 5.0)},\n                    {\"O\": (2.5, 5.1, 5.0), \"H1\": (3.45, 5.1, 5.0), \"H2\": (2.26, 6.03, 5.0)}\n                ]\n            ]\n        },\n        # Case 2\n        {\n            \"L\": 20.0,\n            \"frames\": [\n                [ # Frame 1\n                    {\"O\": (10.0, 10.0, 10.0), \"H1\": (10.95, 10.0, 10.0), \"H2\": (9.76, 10.93, 10.0)},\n                    {\"O\": (14.0, 14.0, 14.0), \"H1\": (14.95, 14.0, 14.0), \"H2\": (13.76, 14.93, 14.0)}\n                ],\n                [ # Frame 2\n                    {\"O\": (10.1, 10.1, 10.0), \"H1\": (11.05, 10.1, 10.0), \"H2\": (9.86, 11.03, 10.0)},\n                    {\"O\": (13.9, 14.1, 14.0), \"H1\": (14.85, 14.1, 14.0), \"H2\": (13.66, 15.03, 14.0)}\n                ]\n            ]\n        },\n        # Case 3\n        {\n            \"L\": 8.0,\n            \"frames\": [\n                [ # Frame 1\n                    {\"O\": (7.9, 3.0, 3.0), \"H1\": (0.85, 3.0, 3.0), \"H2\": (7.66, 3.93, 3.0)},\n                    {\"O\": (2.4, 3.1, 3.0), \"H1\": (3.35, 3.1, 3.0), \"H2\": (2.16, 4.03, 3.0)}\n                ],\n                [ # Frame 2\n                    {\"O\": (7.85, 3.1, 3.0), \"H1\": (0.80, 3.1, 3.0), \"H2\": (7.61, 4.03, 3.0)},\n                    {\"O\": (2.5, 3.2, 3.0), \"H1\": (3.45, 3.2, 3.0), \"H2\": (2.26, 4.13, 3.0)}\n                ]\n            ]\n        },\n        # Case 4\n        {\n            \"L\": 12.0,\n            \"frames\": [\n                [ # Frame 1\n                    {\"O\": (1.0, 1.0, 1.0), \"H1\": (1.95, 1.0, 1.0), \"H2\": (0.76, 1.93, 1.0)},\n                    {\"O\": (9.5, 9.5, 9.5), \"H1\": (10.45, 9.5, 9.5), \"H2\": (9.26, 10.43, 9.5)}\n                ],\n                [ # Frame 2\n                    {\"O\": (1.5, 1.5, 1.0), \"H1\": (2.45, 1.5, 1.0), \"H2\": (1.26, 2.43, 1.0)},\n                    {\"O\": (9.0, 9.0, 10.0), \"H1\": (9.95, 9.0, 10.0), \"H2\": (8.76, 9.93, 10.0)}\n                ]\n            ]\n        }\n    ]\n\n    r_bins = np.array([1.5, 1.9, 2.3, 2.7, 3.1, 3.5])\n    theta_bins = np.array([120, 130, 140, 150, 160, 170, 180])\n    delta_r = 0.4\n    delta_theta = 10.0\n    bin_area = delta_r * delta_theta\n    num_bins = (len(r_bins) - 1) * (len(theta_bins) - 1)\n\n\n    def calculate_bias_for_case(case_data):\n        L = case_data[\"L\"]\n        frames = case_data[\"frames\"]\n\n        pairs_naive = []\n        pairs_mic = []\n\n        def apply_mic(v, box_L):\n            return v - box_L * np.floor(v / box_L + 0.5)\n\n        for molecules_in_frame in frames:\n            mol_indices = range(len(molecules_in_frame))\n            for i in mol_indices:\n                for j in mol_indices:\n                    if i == j:\n                        continue\n                    \n                    donor_mol = molecules_in_frame[i]\n                    acceptor_mol = molecules_in_frame[j]\n\n                    r_D = np.array(donor_mol['O'])\n                    r_A = np.array(acceptor_mol['O'])\n                    \n                    hydrogens = [np.array(donor_mol['H1']), np.array(donor_mol['H2'])]\n\n                    for r_H in hydrogens:\n                        # Naive calculation\n                        v_HD_naive = r_D - r_H\n                        v_HA_naive = r_A - r_H\n                        norm_v_HD_naive = np.linalg.norm(v_HD_naive)\n                        norm_v_HA_naive = np.linalg.norm(v_HA_naive)\n\n                        if norm_v_HD_naive > 1e-9 and norm_v_HA_naive > 1e-9:\n                            r_naive = norm_v_HA_naive\n                            cos_theta_naive = np.dot(v_HD_naive, v_HA_naive) / (norm_v_HD_naive * norm_v_HA_naive)\n                            theta_naive = np.degrees(np.arccos(np.clip(cos_theta_naive, -1.0, 1.0)))\n                            pairs_naive.append((r_naive, theta_naive))\n\n                        # MIC calculation\n                        v_HD_mic = apply_mic(r_D - r_H, L)\n                        v_HA_mic = apply_mic(r_A - r_H, L)\n                        norm_v_HD_mic = np.linalg.norm(v_HD_mic)\n                        norm_v_HA_mic = np.linalg.norm(v_HA_mic)\n                        \n                        if norm_v_HD_mic > 1e-9 and norm_v_HA_mic > 1e-9:\n                            r_mic = norm_v_HA_mic\n                            cos_theta_mic = np.dot(v_HD_mic, v_HA_mic) / (norm_v_HD_mic * norm_v_HA_mic)\n                            theta_mic = np.degrees(np.arccos(np.clip(cos_theta_mic, -1.0, 1.0)))\n                            pairs_mic.append((r_mic, theta_mic))\n\n        # Histogramming and Normalization\n        if not pairs_naive and not pairs_mic:\n             return 0.0\n\n        if pairs_naive:\n            r_vals_naive = [p[0] for p in pairs_naive]\n            theta_vals_naive = [p[1] for p in pairs_naive]\n            H_naive, _, _ = np.histogram2d(r_vals_naive, theta_vals_naive, bins=[r_bins, theta_bins])\n        else:\n            H_naive = np.zeros((len(r_bins) - 1, len(theta_bins) - 1))\n        \n        if pairs_mic:\n            r_vals_mic = [p[0] for p in pairs_mic]\n            theta_vals_mic = [p[1] for p in pairs_mic]\n            H_mic, _, _ = np.histogram2d(r_vals_mic, theta_vals_mic, bins=[r_bins, theta_bins])\n        else:\n            H_mic = np.zeros((len(r_bins) - 1, len(theta_bins) - 1))\n\n        N_total_naive = np.sum(H_naive)\n        N_total_mic = np.sum(H_mic)\n\n        g_naive = np.zeros_like(H_naive)\n        if N_total_naive > 0:\n            g_naive = H_naive / (N_total_naive * bin_area)\n        \n        g_mic = np.zeros_like(H_mic)\n        if N_total_mic > 0:\n            g_mic = H_mic / (N_total_mic * bin_area)\n        \n        # Bias calculation\n        if N_total_naive == 0 and N_total_mic == 0:\n            return 0.0\n            \n        rms_diff = np.sqrt(np.mean((g_naive - g_mic)**2))\n        return rms_diff\n\n    results = [calculate_bias_for_case(case) for case in test_cases]\n    \n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\nsolve()\n```", "id": "3416826"}, {"introduction": "Beyond simply counting hydrogen bonds, we are often interested in their dynamics—how long they persist and how they rearrange over time. This exercise challenges you to design a \"streaming\" algorithm to compute statistics like the hydrogen-bond autocorrelation function on-the-fly, using bounded memory. Mastering this approach is a crucial skill for efficiently analyzing the massive datasets generated by modern, long-timescale simulations [@problem_id:3416818].", "problem": "You are given the task of designing and implementing a streaming (online) hydrogen-bond detector for Molecular Dynamics (MD) trajectories that computes running estimates using bounded memory and validates them against a full offline analysis. The detector must operate on a sequence of Cartesian coordinates of water molecules and produce two statistics: (i) the time-average of the number of hydrogen bonds per frame, denoted by $\\langle n_{\\mathrm{HB}}\\rangle$, and (ii) the intermittent hydrogen-bond autocorrelation function $C(k)$ at discrete frame lags $k \\in \\{0,1,\\dots,L\\}$, where $L$ is a small nonnegative integer.\n\nHydrogen bonds are to be determined using the following geometric rule, derived from simple vector geometry and well-accepted molecular criteria:\n\n- A donor is an oxygen atom of a water molecule together with one of its two hydrogens.\n- An acceptor is an oxygen atom of a water molecule.\n- Intra-molecular hydrogen bonds are forbidden (the donor and acceptor must belong to different water molecules).\n- A hydrogen bond exists between a donor oxygen $D$ with an attached hydrogen $H$ and an acceptor oxygen $A$ if and only if both conditions hold simultaneously:\n  1. The donor–acceptor distance is at most a cutoff, $| \\mathbf{r}_{A} - \\mathbf{r}_{D} | \\le r_c$.\n  2. The donor–hydrogen–acceptor angle satisfies $\\theta = \\angle D\\text{–}H\\cdots A \\ge \\theta_{\\min}$, where $\\theta$ is the angle between vectors $\\mathbf{r}_{D}-\\mathbf{r}_{H}$ and $\\mathbf{r}_{A}-\\mathbf{r}_{H}$, computed using the dot product definition. Angles must be computed in degrees.\n\nAt each frame $t$, define a set $S(t)$ of donor–acceptor pairs $(D,A)$ for which the geometric hydrogen-bond criterion is satisfied by at least one hydrogen attached to $D$. Each pair $(D,A)$ is counted once per frame regardless of how many hydrogens satisfy the angle criterion. The total number of hydrogen bonds in frame $t$ is $n_{\\mathrm{HB}}(t) = |S(t)|$.\n\nLet $T$ be the number of frames. The time-average $\\langle n_{\\mathrm{HB}}\\rangle$ is the sample average\n$$\n\\langle n_{\\mathrm{HB}}\\rangle = \\frac{1}{T}\\sum_{t=0}^{T-1} n_{\\mathrm{HB}}(t).\n$$\nDefine the intermittent hydrogen-bond autocorrelation function for integer lag $k \\in \\{0,\\dots,L\\}$ as\n$$\nC(k) = \\frac{\\sum\\limits_{t=0}^{T-1-k} \\sum\\limits_{(D,A)} \\mathbb{1}\\!\\left[(D,A) \\in S(t)\\right] \\, \\mathbb{1}\\!\\left[(D,A) \\in S(t+k)\\right]}{\\sum\\limits_{t=0}^{T-1-k} \\sum\\limits_{(D,A)} \\mathbb{1}\\!\\left[(D,A) \\in S(t)\\right]} \\,,\n$$\nwhich equivalently equals\n$$\nC(k) = \\frac{\\sum\\limits_{t=0}^{T-1-k} | S(t) \\cap S(t+k) |}{\\sum\\limits_{t=0}^{T-1-k} | S(t) |}.\n$$\nBy construction, $C(0) = 1$ when the denominator is nonzero.\n\nYour program must implement both:\n- A streaming estimator that processes frames one-by-one, maintaining bounded memory that does not grow with $T$ (it may grow with $L$ and with the instantaneous number of hydrogen-bonded pairs in the most recent $L$ frames), and incrementally updates $\\langle n_{\\mathrm{HB}}\\rangle$ and $C(k)$ for $k \\in \\{0,\\dots,L\\}$ without storing the entire trajectory.\n- A full offline analysis that computes $\\langle n_{\\mathrm{HB}}\\rangle$ and $C(k)$ exactly from $S(t)$ for all frames.\n\nThe core algorithmic requirements must be derived from the following base principles:\n- Euclidean distance in three dimensions: for vectors $\\mathbf{a}$ and $\\mathbf{b}$, the distance is $|\\mathbf{a}-\\mathbf{b}| = \\sqrt{(a_x-b_x)^2 + (a_y-b_y)^2 + (a_z-b_z)^2}$.\n- The angle between nonzero vectors $\\mathbf{u}$ and $\\mathbf{v}$ satisfies $\\cos \\theta = \\dfrac{\\mathbf{u}\\cdot \\mathbf{v}}{\\|\\mathbf{u}\\| \\, \\|\\mathbf{v}\\|}$; use the inverse cosine to compute $\\theta$ in radians and then convert to degrees.\n- Time averages and autocorrelations are to be computed as above, using sample sums.\n\nUnits and conventions:\n- All distances must be treated in ångström, denoted $\\mathrm{\\AA}$.\n- All angles must be in degrees.\n- The donors and acceptors are defined for water molecules, each with atom ordering $(\\mathrm{O}, \\mathrm{H}, \\mathrm{H})$ per molecule. Each water molecule contributes one donor oxygen with two attached hydrogens and one acceptor oxygen (the same oxygen).\n\nImplement three test cases. For each case, supply the hydrogen-bond cutoffs $r_c$ and $\\theta_{\\min}$, the lag limit $L$, and the trajectory coordinates. Your code must use these exact values.\n\nGlobal parameters for all test cases:\n- Cutoff distance $r_c = 3.5\\,\\mathrm{\\AA}$.\n- Angle threshold $\\theta_{\\min} = 150.0$ degrees.\n- Maximum lag $L = 2$ frames.\n- Each atom’s coordinates are in ångström. No periodic boundary conditions are applied.\n\nTest case A (happy path; bond forms then breaks):\n- Two water molecules, total of $6$ frames.\n- Molecule $1$ atoms: $\\mathrm{O}_1=(0,0,0)$; $\\mathrm{H}_{1a}=(1,0,0)$; $\\mathrm{H}_{1b}=(0,1,0)$ for all frames.\n- Molecule $2$ atoms in frames $t \\in \\{0,1,2\\}$: $\\mathrm{O}_2=(2.8,0,0)$; $\\mathrm{H}_{2a}=(2.8,1,0)$; $\\mathrm{H}_{2b}=(2.8,0,1)$.\n- Molecule $2$ atoms in frames $t \\in \\{3,4,5\\}$: $\\mathrm{O}_2=(6.0,0,0)$; $\\mathrm{H}_{2a}=(6.0,1,0)$; $\\mathrm{H}_{2b}=(6.0,0,1)$.\n\nTest case B (boundary inclusivity; equality at both thresholds):\n- Two water molecules, total of $4$ identical frames.\n- Molecule $1$ atoms fixed: $\\mathrm{O}_1=(0,0,0)$; $\\mathrm{H}_{1a}=(1,0,0)$; $\\mathrm{H}_{1b}=(0,1,0)$.\n- Molecule $2$ oxygen is at $\\mathrm{O}_2 = \\left(3.25,\\; \\tfrac{1}{4}\\sqrt{27},\\; 0\\right)$, which implies $|\\mathrm{O}_2 - \\mathrm{O}_1| = 3.5\\,\\mathrm{\\AA}$ and $\\angle \\mathrm{D}\\text{–}\\mathrm{H}\\cdots \\mathrm{A} = 150.0$ degrees at $\\mathrm{H}_{1a}$; hydrogens $\\mathrm{H}_{2a} = \\mathrm{O}_2 + (0,1,0)$ and $\\mathrm{H}_{2b} = \\mathrm{O}_2 + (0,0,1)$.\n\nTest case C (multiple pairs and switching; tests pair-level correlation):\n- Three water molecules, total of $4$ frames.\n- Molecule $1$ fixed: $\\mathrm{O}_1=(0,0,0)$; $\\mathrm{H}_{1a}=(1,0,0)$; $\\mathrm{H}_{1b}=(-1,0,0)$ for all frames.\n- Molecule $2$ hydrogens set orthogonal: $\\mathrm{H}_{2a}=\\mathrm{O}_2 + (0,1,0)$; $\\mathrm{H}_{2b}=\\mathrm{O}_2 + (0,0,1)$ in all frames.\n- Molecule $3$ hydrogens set orthogonal: $\\mathrm{H}_{3a}=\\mathrm{O}_3 + (0,1,0)$; $\\mathrm{H}_{3b}=\\mathrm{O}_3 + (0,0,1)$ in all frames.\n- Oxygen positions by frame:\n  - Frame $0$: $\\mathrm{O}_2=(2.9,0,0)$; $\\mathrm{O}_3=(-2.9,0,0)$.\n  - Frame $1$: $\\mathrm{O}_2=(2.9,0,0)$; $\\mathrm{O}_3=(-6.0,0,0)$.\n  - Frame $2$: $\\mathrm{O}_2=(6.0,0,0)$; $\\mathrm{O}_3=(-2.9,0,0)$.\n  - Frame $3$: $\\mathrm{O}_2=(2.9,0,0)$; $\\mathrm{O}_3=(-2.9,0,0)$.\n\nYour implementation requirements:\n- Hydrogen-bond detection per frame must use only the specified geometric criteria. For each donor–acceptor pair $(D,A)$, if any of the donor’s hydrogens satisfies the angle criterion simultaneously with the distance criterion, the pair is counted once in $S(t)$ for that frame.\n- The streaming algorithm must maintain:\n  - A running estimate of $\\langle n_{\\mathrm{HB}}\\rangle$ using an incremental update upon receipt of each frame.\n  - For each lag $k \\in \\{0,\\dots,L\\}$, running numerators and denominators such that, upon ingesting frame $t$, contributions for pairs with time origins at $t-k$ are updated using only the last $L$ stored sets $S(t')$.\n  - Bounded memory that stores at most the last $L$ sets $S(t)$ and aggregate counters.\n- The offline algorithm must compute the exact $S(t)$ for all frames and then compute $\\langle n_{\\mathrm{HB}}\\rangle$ and $C(k)$ directly using the definitions above.\n\nValidation target and output:\n- For each test case, compute the absolute difference between the streaming and offline estimates of $\\langle n_{\\mathrm{HB}}\\rangle$ and the maximum absolute difference over $k \\in \\{0,1,2\\}$ of $C(k)$. Report, for each test case, the maximum of these two absolute differences as a floating-point number.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[x_A,x_B,x_C]$), where $x_A$, $x_B$, and $x_C$ are the results for test cases A, B, and C, respectively. Distances must be interpreted in $\\mathrm{\\AA}$ and angles in degrees throughout. The output numbers should be standard decimal floats.\n\nDesign for coverage:\n- Test case A exercises the general operation where a bond persists for several frames and then disappears.\n- Test case B exercises boundary inclusivity at exactly $r_c$ and $\\theta_{\\min}$, which must be counted as bonded due to the inclusive inequalities.\n- Test case C exercises multiple simultaneous bonds and switching among distinct donor–acceptor pairs, stressing the correct pair-level correlation logic.\n\nYour task is to implement a complete, runnable program that constructs the above trajectories, performs both analyses, and prints the required single-line output.", "solution": "The user-provided problem is a well-defined computational task in the field of molecular dynamics (MD) simulation analysis. It requires the implementation of two algorithms—one offline (batch) and one online (streaming)—to compute hydrogen-bond statistics from a trajectory of atomic coordinates. The goal is to validate the streaming algorithm against the exact offline calculation. The problem statement is scientifically sound, mathematically precise, and algorithmically complete. Therefore, a solution is warranted.\n\n### Principle of Hydrogen Bond Detection\n\nA hydrogen bond is a non-covalent interaction critical to the structure of many chemical systems, particularly water. The problem specifies a common geometric definition based on the relative positions of a donor oxygen ($D$), its covalently bonded hydrogen ($H$), and an acceptor oxygen ($A$). A hydrogen bond exists if and only if two conditions are met:\n1.  The distance between the donor and acceptor oxygen atoms is less than or equal to a cutoff, $|\\mathbf{r}_{A} - \\mathbf{r}_{D}| \\le r_c$.\n2.  The angle formed by the donor oxygen, the hydrogen, and the acceptor oxygen is greater than or equal to a minimum threshold, $\\theta = \\angle D\\text{–}H\\cdots A \\ge \\theta_{\\min}$.\n\nThese geometric criteria are computed using fundamental principles of vector algebra in three-dimensional Euclidean space. Given the Cartesian coordinates of the atoms, the squared distance is computed as $(\\mathbf{r}_A - \\mathbf{r}_D) \\cdot (\\mathbf{r}_A - \\mathbf{r}_D)$. The angle $\\theta$ is derived from the dot product of the vectors defining the angle's arms, $\\mathbf{u} = \\mathbf{r}_D - \\mathbf{r}_H$ and $\\mathbf{v} = \\mathbf{r}_A - \\mathbf{r}_H$, via the relation:\n$$\n\\cos \\theta = \\frac{\\mathbf{u} \\cdot \\mathbf{v}}{\\|\\mathbf{u}\\| \\|\\mathbf{v}\\|}\n$$\nThe angle $\\theta$ is then found by taking the inverse cosine and converting from radians to degrees. For each frame $t$, we identify the set $S(t)$ of all unique donor-acceptor molecular pairs $(D, A)$ that form at least one hydrogen bond. The number of hydrogen bonds in the frame is then $n_{\\mathrm{HB}}(t) = |S(t)|$.\n\n### Statistical Analysis: Offline vs. Online Algorithms\n\nThe problem requires the calculation of two key statistical quantities: the time-average number of hydrogen bonds, $\\langle n_{\\mathrm{HB}}\\rangle$, and the intermittent hydrogen-bond autocorrelation function, $C(k)$.\n\n**1. Offline (Batch) Algorithm**\n\nThe offline algorithm represents a standard two-pass analysis.\n-   **Pass 1**: Iterate through all frames $t$ from $0$ to $T-1$. For each frame, apply the geometric criteria to all possible donor-acceptor pairs to compute the set of bonded pairs, $S(t)$. Store all these sets in memory, for example, in a list `[S(0), S(1), ..., S(T-1)]`.\n-   **Pass 2**: With all $S(t)$ available, compute the final statistics directly from their definitions:\n    -   The average number of hydrogen bonds is $\\langle n_{\\mathrm{HB}}\\rangle = \\frac{1}{T}\\sum_{t=0}^{T-1} |S(t)|$.\n    -   The autocorrelation function for each lag $k \\in \\{0, \\dots, L\\}$ is $C(k) = \\frac{\\sum_{t=0}^{T-1-k} | S(t) \\cap S(t+k) |}{\\sum_{t=0}^{T-1-k} | S(t) |}$. This involves iterating through the appropriate time windows for each lag $k$ and using the pre-computed sets $S(t)$.\n\nThis approach is straightforward but memory-intensive, as it requires storing information for the entire trajectory.\n\n**2. Online (Streaming) Algorithm**\n\nThe online algorithm processes the trajectory one frame at a time and updates the statistics incrementally, using bounded memory that does not scale with the total number of frames $T$.\n\n-   **Memory**: The algorithm maintains running sums for the statistics and a small buffer to store the hydrogen-bond sets of the most recent $L+1$ frames. A circular buffer is an efficient data structure for this task.\n-   **Processing Frame $t$**: Upon receiving the coordinates for frame $t$:\n    1.  Compute the current set of hydrogen bonds, $S(t)$, and its size, $n_{\\mathrm{HB}}(t)$.\n    2.  Update the running sum for the average: A running total $\\Sigma_n$ is incremented by $n_{\\mathrm{HB}}(t)$. The average at frame $t$ is $\\frac{\\Sigma_n}{t+1}$.\n    3.  Store $S(t)$ in the circular buffer, overwriting the data from frame $t-(L+1)$.\n    4.  Update the running sums for $C(k)$. For each lag $k \\in \\{0, \\dots, L\\}$, if $t \\ge k$, the frame pair $(t-k, t)$ contributes to the correlation. We retrieve the historical set $S(t-k)$ from the buffer and compute its intersection with $S(t)$.\n        -   The numerator sum for $C(k)$ is incremented by $|S(t-k) \\cap S(t)|$.\n        -   The denominator sum for $C(k)$ is incremented by $|S(t-k)|$.\n\nAfter processing all frames, the final statistics are computed by dividing the accumulated sums. This online approach is mathematically equivalent to the offline one and will produce identical results, barring any floating-point precision issues. The problem's request for the difference between the two serves as a robust method to verify the correctness of the streaming implementation.\n\n### Implementation and Verification\n\nThe provided solution will implement both algorithms. A core function performs the per-frame hydrogen bond detection. The offline and streaming functions will call this core function but manage data and computations differently as described above. The test cases are designed to exercise various scenarios: a simple bond formation/dissociation event (A), boundary conditions of the geometric criteria (B), and multiple competing bond partners (C). The final output, reporting the maximum absolute difference between the results of the two methods, is expected to be an array of zeros, confirming the correctness of the online algorithm's design and implementation.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport collections\n\n# Global parameters from the problem statement\nR_C = 3.5  # Angstrom\nTHETA_MIN = 150.0  # degrees\nL_MAX = 2\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, run analyses, and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case A\n        {\n            \"num_molecules\": 2,\n            \"num_frames\": 6,\n            \"get_coords\": lambda t: np.array([\n                [[0.0, 0.0, 0.0], [1.0, 0.0, 0.0], [0.0, 1.0, 0.0]],\n                [[2.8, 0.0, 0.0], [2.8, 1.0, 0.0], [2.8, 0.0, 1.0]]\n            ]) if t < 3 else np.array([\n                [[0.0, 0.0, 0.0], [1.0, 0.0, 0.0], [0.0, 1.0, 0.0]],\n                [[6.0, 0.0, 0.0], [6.0, 1.0, 0.0], [6.0, 0.0, 1.0]]\n            ])\n        },\n        # Test Case B\n        {\n            \"num_molecules\": 2,\n            \"num_frames\": 4,\n            \"get_coords\": lambda t: np.array([\n                [[0.0, 0.0, 0.0], [1.0, 0.0, 0.0], [0.0, 1.0, 0.0]],\n                [\n                    [3.25, np.sqrt(27)/4.0, 0.0],\n                    [3.25, np.sqrt(27)/4.0 + 1.0, 0.0],\n                    [3.25, np.sqrt(27)/4.0, 1.0]\n                ]\n            ])\n        },\n        # Test Case C\n        {\n            \"num_molecules\": 3,\n            \"num_frames\": 4,\n            \"get_coords\": lambda t: np.array([\n                [[0.0, 0.0, 0.0], [1.0, 0.0, 0.0], [-1.0, 0.0, 0.0]],\n                *({\n                    0: [[[2.9,0,0],[2.9,1,0],[2.9,0,1]],[[-2.9,0,0],[-2.9,1,0],[-2.9,0,1]]],\n                    1: [[[2.9,0,0],[2.9,1,0],[2.9,0,1]],[[-6.0,0,0],[-6.0,1,0],[-6.0,0,1]]],\n                    2: [[[6.0,0,0],[6.0,1,0],[6.0,0,1]],[[-2.9,0,0],[-2.9,1,0],[-2.9,0,1]]],\n                    3: [[[2.9,0,0],[2.9,1,0],[2.9,0,1]],[[-2.9,0,0],[-2.9,1,0],[-2.9,0,1]]]\n                }[t])\n            ])\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        trajectory = [case[\"get_coords\"](t) for t in range(case[\"num_frames\"])]\n        \n        n_hb_offline, c_k_offline = offline_analyzer(trajectory, case[\"num_molecules\"])\n        n_hb_streaming, c_k_streaming = streaming_analyzer(trajectory, case[\"num_molecules\"])\n        \n        diff_n_hb = abs(n_hb_offline - n_hb_streaming)\n        diff_c_k = np.max(np.abs(np.array(c_k_offline) - np.array(c_k_streaming)))\n        \n        results.append(max(diff_n_hb, diff_c_k))\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef detect_hbonds_frame(coords, num_molecules):\n    \"\"\"\n    Detects hydrogen bonds in a single frame based on geometric criteria.\n    - coords: (num_molecules, 3 atoms, 3 coords) numpy array\n    Returns a set of (donor_idx, acceptor_idx) tuples.\n    \"\"\"\n    hbond_pairs = set()\n    for d_idx in range(num_molecules):\n        for a_idx in range(num_molecules):\n            if d_idx == a_idx:\n                continue\n\n            r_d = coords[d_idx, 0]\n            r_a = coords[a_idx, 0]\n\n            dist_vec = r_a - r_d\n            dist_sq = np.dot(dist_vec, dist_vec)\n            if dist_sq > R_C**2:\n                continue\n            \n            # Distance criterion met, check angles\n            is_h_bonded = False\n            for h_idx in [1, 2]: # H1 and H2\n                r_h = coords[d_idx, h_idx]\n                \n                vec_dh = r_d - r_h\n                vec_ah = r_a - r_h\n\n                norm_dh = np.linalg.norm(vec_dh)\n                norm_ah = np.linalg.norm(vec_ah)\n\n                if norm_dh == 0 or norm_ah == 0:\n                    continue\n\n                cos_theta = np.dot(vec_dh, vec_ah) / (norm_dh * norm_ah)\n                # Clamp cos_theta to handle potential floating point inaccuracies\n                cos_theta = np.clip(cos_theta, -1.0, 1.0)\n                \n                theta_rad = np.arccos(cos_theta)\n                theta_deg = np.rad2deg(theta_rad)\n\n                if theta_deg >= THETA_MIN:\n                    is_h_bonded = True\n                    break # Pair is counted once\n\n            if is_h_bonded:\n                hbond_pairs.add((d_idx, a_idx))\n    \n    return hbond_pairs\n\ndef offline_analyzer(trajectory, num_molecules):\n    \"\"\"\n    Computes H-bond statistics by processing the entire trajectory in batch.\n    \"\"\"\n    num_frames = len(trajectory)\n    if num_frames == 0:\n        return 0.0, [1.0] + [0.0] * L_MAX\n\n    all_s_t = [detect_hbonds_frame(coords, num_molecules) for coords in trajectory]\n    n_hb_list = [len(s) for s in all_s_t]\n\n    # Calculate avg(n_HB)\n    avg_n_hb = np.mean(n_hb_list) if n_hb_list else 0.0\n\n    # Calculate C(k)\n    c_k = []\n    for k in range(L_MAX + 1):\n        if num_frames <= k:\n            c_k.append(0.0) # Not enough frames for this lag\n            continue\n        \n        numerator = 0.0\n        denominator = 0.0\n        for t in range(num_frames - k):\n            numerator += len(all_s_t[t].intersection(all_s_t[t+k]))\n            denominator += len(all_s_t[t])\n        \n        c_k.append(numerator / denominator if denominator > 0 else (1.0 if k == 0 else 0.0))\n\n    return avg_n_hb, c_k\n\ndef streaming_analyzer(trajectory, num_molecules):\n    \"\"\"\n    Computes H-bond statistics by processing the trajectory frame by frame.\n    \"\"\"\n    num_frames = len(trajectory)\n    if num_frames == 0:\n        return 0.0, [1.0] + [0.0] * L_MAX\n\n    sum_n_hb = 0.0\n    \n    c_k_numerators = np.zeros(L_MAX + 1)\n    c_k_denominators = np.zeros(L_MAX + 1)\n    \n    s_buffer = collections.deque(maxlen=L_MAX + 1)\n\n    for t in range(num_frames):\n        coords = trajectory[t]\n        current_s = detect_hbonds_frame(coords, num_molecules)\n        current_n_hb = len(current_s)\n        \n        # Update mean n_HB\n        sum_n_hb += current_n_hb\n        \n        s_buffer.append(current_s)\n        \n        # Update C(k)\n        for k in range(L_MAX + 1):\n            if t >= k:\n                # The pair of frames is (t-k, t)\n                # s_buffer[len-1] is current_s, s_buffer[len-1-k] is S(t-k)\n                past_s = s_buffer[len(s_buffer) - 1 - k]\n                c_k_numerators[k] += len(past_s.intersection(current_s))\n                c_k_denominators[k] += len(past_s)\n\n    avg_n_hb = sum_n_hb / num_frames if num_frames > 0 else 0.0\n    \n    c_k = []\n    for k in range(L_MAX + 1):\n        if c_k_denominators[k] > 0:\n            c_k.append(c_k_numerators[k] / c_k_denominators[k])\n        else:\n            # Handle cases with no bonds, C(0) should be 1 if any frame with bonds exists,\n            # but if no bonds ever, denominator will be 0.\n            c_k.append(1.0 if k == 0 and sum_n_hb > 0 else 0.0)\n            if k == 0 and sum_n_hb == 0: c_k[-1] = 1.0 # C(0) is 1 by convention if frames exist.\n            if num_frames <=k: c_k[-1] = 0.0 # Match offline behavior if trajectory is too short\n    \n    # Special case, C(0) is 1 if there's at least one frame.\n    if num_frames > 0:\n        sum_of_hb_counts = c_k_denominators[0]\n        c_k[0] = 1.0 if sum_of_hb_counts > 0 else (1.0 if num_frames > 0 else 0.0)\n\n    # If num_frames is small, some lags may not be computable\n    for k in range(L_MAX + 1):\n        if num_frames <= k:\n            c_k[k] = 0.0\n\n    return avg_n_hb, c_k\n\n\n# Execute the solution\nif __name__ == '__main__':\n    solve()\n\n```", "id": "3416818"}]}