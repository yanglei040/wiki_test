{"hands_on_practices": [{"introduction": "Any meaningful comparison of two molecular structures begins with their optimal alignment. This practice delves into the mathematical core of this process, deriving the optimal rotation and translation that minimize the mass-weighted root-mean-square deviation (RMSD) from first principles [@problem_id:3443709]. Mastering this derivation provides a fundamental understanding of the algorithms, such as the Kabsch algorithm, that are ubiquitously used in structural analysis software.", "problem": "Consider two conformations of a macromolecule in three-dimensional space used for root-mean-square deviation (RMSD) analysis in molecular dynamics. The conformations are represented by atom coordinate sets $\\{x_{i}\\}_{i=1}^{N}$ and $\\{y_{i}\\}_{i=1}^{N}$ with $x_{i}, y_{i} \\in \\mathbb{R}^{3}$, and strictly positive atomic masses $\\{m_{i}\\}_{i=1}^{N}$. An optimal superposition is defined as a rigid motion with rotation $R \\in \\mathrm{SO}(3)$ (the special orthogonal group of dimension $3$, i.e., $R^{\\top}R = I$ and $\\det(R) = 1$) and translation $t \\in \\mathbb{R}^{3}$ that minimizes the mass-weighted sum of squared deviations\n$$\nJ(R,t) = \\sum_{i=1}^{N} m_{i} \\left\\| R x_{i} + t - y_{i} \\right\\|^{2}.\n$$\nStarting from first principles (the definition of the mass-weighted least squares objective and the constraints on $R$), derive the mass-weighted optimal superposition by minimizing $J(R,t)$ with respect to the translation $t$ and then re-express the objective in terms of centered coordinates to identify the quantity used to compute the optimal rotation $R$. In particular, obtain explicit analytic expressions for:\n- the mass-weighted centroid of the $x$-coordinates,\n- the mass-weighted centroid of the $y$-coordinates,\n- the mass-weighted covariance matrix that enters the rotation computation (for example, via singular value decomposition (SVD)),\n- and the optimal translation $t^{\\star}$ in terms of $R$ and the centroids.\n\nYour final answer must be a single closed-form analytic expression collecting these four quantities. No numerical evaluation is required. If any intermediate scalar normalization is needed, express it symbolically. Do not include any units in your final answer.", "solution": "The user has provided a problem statement that is scientifically grounded, well-posed, objective, and self-contained. It is a standard derivation in the field of computational structural biology and molecular dynamics, specifically related to the optimal superposition of two molecular structures. The problem is based on established mathematical principles of multivariable calculus and linear algebra. All necessary data and definitions are provided, and there are no contradictions or ambiguities. Therefore, the problem is deemed valid and a solution will be provided.\n\nThe objective is to find the optimal rotation $R \\in \\mathrm{SO}(3)$ and translation $t \\in \\mathbb{R}^{3}$ that minimize the mass-weighted sum of squared deviations between two sets of atomic coordinates, $\\{x_{i}\\}_{i=1}^{N}$ and $\\{y_{i}\\}_{i=1}^{N}$. The objective function is given by:\n$$\nJ(R,t) = \\sum_{i=1}^{N} m_{i} \\left\\| R x_{i} + t - y_{i} \\right\\|^{2}\n$$\nwhere $\\{m_{i}\\}_{i=1}^{N}$ are the strictly positive atomic masses.\n\nThe minimization can be carried out in two steps: first with respect to the translation vector $t$, and then with respect to the rotation matrix $R$.\n\n**Step 1: Minimization with Respect to Translation $t$**\n\nFor a fixed rotation $R$, the optimal translation $t^{\\star}$ is found by setting the gradient of $J(R,t)$ with respect to $t$ to the zero vector. The gradient $\\nabla_{t} J$ is computed as follows:\n$$\n\\nabla_{t} J(R,t) = \\nabla_{t} \\sum_{i=1}^{N} m_{i} (R x_{i} + t - y_{i})^{\\top}(R x_{i} + t - y_{i})\n$$\nUsing the identity $\\nabla_{v} (u^{\\top}u) = 2 u^{\\top} \\nabla_{v}u$, and noting that $\\nabla_{t}(R x_{i} + t - y_{i}) = I$ (the identity matrix), we get:\n$$\n\\nabla_{t} J(R,t) = \\sum_{i=1}^{N} m_{i} \\cdot 2(R x_{i} + t - y_{i})^{\\top}\n$$\nSetting the gradient (transposed to a column vector) to zero:\n$$\n\\sum_{i=1}^{N} 2 m_{i} (R x_{i} + t^{\\star} - y_{i}) = 0\n$$\nSince $m_i > 0$, we can divide by $2$ and rearrange the summation:\n$$\n\\sum_{i=1}^{N} m_{i} R x_{i} + \\sum_{i=1}^{N} m_{i} t^{\\star} - \\sum_{i=1}^{N} m_{i} y_{i} = 0\n$$\n$$\nR \\left(\\sum_{i=1}^{N} m_{i} x_{i}\\right) + t^{\\star} \\left(\\sum_{i=1}^{N} m_{i}\\right) - \\left(\\sum_{i=1}^{N} m_{i} y_{i}\\right) = 0\n$$\nTo simplify this expression, we define the total mass $M$ and the mass-weighted centroids of the two coordinate sets. Let the total mass be $M = \\sum_{k=1}^{N} m_{k}$. The mass-weighted centroids are:\n- The centroid of the $\\{x_{i}\\}$ coordinates: $x_{c} = \\frac{1}{M} \\sum_{i=1}^{N} m_{i} x_{i}$.\n- The centroid of the $\\{y_{i}\\}$ coordinates: $y_{c} = \\frac{1}{M} \\sum_{i=1}^{N} m_{i} y_{i}$.\n\nSubstituting these definitions into the equation for $t^{\\star}$:\n$$\nR (M x_{c}) + M t^{\\star} - M y_{c} = 0\n$$\nSince $M > 0$, we can divide by $M$ to obtain:\n$$\nR x_{c} + t^{\\star} - y_{c} = 0\n$$\nThis yields the expression for the optimal translation $t^{\\star}$ in terms of the rotation $R$ and the centroids:\n$$\nt^{\\star} = y_{c} - R x_{c}\n$$\nThis is the fourth quantity required by the problem. The first two quantities are the explicit expressions for the centroids $x_c$ and $y_c$.\n\n**Step 2: Re-expressing the Objective and Identifying the Covariance Matrix**\n\nNow, we substitute the optimal translation $t^{\\star}$ back into the objective function $J(R,t)$ to obtain a function that depends only on the rotation $R$:\n$$\nJ(R) = J(R, t^{\\star}) = \\sum_{i=1}^{N} m_{i} \\left\\| R x_{i} + (y_{c} - R x_{c}) - y_{i} \\right\\|^{2}\n$$\nRearranging the terms inside the norm:\n$$\nJ(R) = \\sum_{i=1}^{N} m_{i} \\left\\| (R x_{i} - R x_{c}) - (y_{i} - y_{c}) \\right\\|^{2} = \\sum_{i=1}^{N} m_{i} \\left\\| R(x_{i} - x_{c}) - (y_{i} - y_{c}) \\right\\|^{2}\n$$\nWe introduce the centered coordinates:\n- $x'_{i} = x_{i} - x_{c}$\n- $y'_{i} = y_{i} - y_{c}$\nThe objective function becomes a problem of finding the rotation that best aligns the centered coordinate sets:\n$$\nJ(R) = \\sum_{i=1}^{N} m_{i} \\left\\| R x'_{i} - y'_{i} \\right\\|^{2}\n$$\nExpanding the squared norm:\n$$\n\\left\\| R x'_{i} - y'_{i} \\right\\|^{2} = (R x'_{i} - y'_{i})^{\\top}(R x'_{i} - y'_{i}) = (R x'_{i})^{\\top}(R x'_{i}) - 2(R x'_{i})^{\\top}y'_{i} + (y'_{i})^{\\top}y'_{i}\n$$\nSince $R$ is an orthogonal matrix ($R^{\\top}R = I$), we have $(R x'_{i})^{\\top}(R x'_{i}) = (x'_{i})^{\\top}R^{\\top}R x'_{i} = (x'_{i})^{\\top}I x'_{i} = \\|x'_{i}\\|^{2}$.\nThe expanded term is $\\|x'_{i}\\|^{2} - 2(x'_{i})^{\\top}R^{\\top}y'_{i} + \\|y'_{i}\\|^{2}$.\nSubstituting this back into the expression for $J(R)$:\n$$\nJ(R) = \\sum_{i=1}^{N} m_{i} \\left( \\|x'_{i}\\|^{2} + \\|y'_{i}\\|^{2} \\right) - 2 \\sum_{i=1}^{N} m_{i} (x'_{i})^{\\top}R^{\\top}y'_{i}\n$$\nTo minimize $J(R)$, we must maximize the term that depends on $R$. The first part of the sum, $\\sum_{i=1}^{N} m_{i} ( \\|x'_{i}\\|^{2} + \\|y'_{i}\\|^{2} )$, is constant with respect to $R$. Therefore, minimizing $J(R)$ is equivalent to maximizing the quantity $S(R)$:\n$$\nS(R) = \\sum_{i=1}^{N} m_{i} (x'_{i})^{\\top}R^{\\top}y'_{i}\n$$\nWe can express this sum using the trace operator. For any scalar $a$, $a = \\mathrm{Tr}(a)$.\n$$\nS(R) = \\sum_{i=1}^{N} m_{i} \\mathrm{Tr}\\left( (x'_{i})^{\\top}R^{\\top}y'_{i} \\right)\n$$\nUsing the cyclic property of the trace, $\\mathrm{Tr}(ABC) = \\mathrm{Tr}(BCA)$:\n$$\nS(R) = \\sum_{i=1}^{N} m_{i} \\mathrm{Tr}\\left( R^{\\top}y'_{i}(x'_{i})^{\\top} \\right)\n$$\nBy the linearity of the trace operator:\n$$\nS(R) = \\mathrm{Tr}\\left( R^{\\top} \\left( \\sum_{i=1}^{N} m_{i} y'_{i}(x'_{i})^{\\top} \\right) \\right)\n$$\nThis expression identifies the matrix that governs the rotational part of the problem. This is the mass-weighted covariance matrix $C$:\n$$\nC = \\sum_{i=1}^{N} m_{i} y'_{i}(x'_{i})^{\\top} = \\sum_{i=1}^{N} m_{i} (y_{i} - y_{c})(x_{i} - x_{c})^{\\top}\n$$\nThe problem of finding the optimal rotation $R$ is thus reduced to maximizing $\\mathrm{Tr}(R^{\\top}C)$. This is typically solved by computing the singular value decomposition (SVD) of the matrix $C$. This matrix $C$ is the third quantity required by the problem.\n\nThe four required quantities are thus:\n1.  The mass-weighted centroid of the $x$-coordinates: $x_{c} = \\frac{\\sum_{i=1}^{N} m_{i} x_{i}}{\\sum_{k=1}^{N} m_{k}}$.\n2.  The mass-weighted centroid of the $y$-coordinates: $y_{c} = \\frac{\\sum_{i=1}^{N} m_{i} y_{i}}{\\sum_{k=1}^{N} m_{k}}$.\n3.  The mass-weighted covariance matrix: $C = \\sum_{i=1}^{N} m_{i} (y_{i} - y_{c})(x_{i} - x_{c})^{\\top}$.\n4.  The optimal translation: $t^{\\star} = y_{c} - R x_{c}$.\n\nThese are collected into a single analytical expression in the final answer.", "answer": "$$\n\\boxed{\n\\begin{matrix}\n\\frac{\\sum_{i=1}^{N} m_{i} x_{i}}{\\sum_{k=1}^{N} m_{k}} & \n\\frac{\\sum_{i=1}^{N} m_{i} y_{i}}{\\sum_{k=1}^{N} m_{k}} & \n\\sum_{i=1}^{N} m_{i} \\left(y_{i} - \\frac{\\sum_{j=1}^{N} m_{j} y_{j}}{\\sum_{k=1}^{N} m_{k}}\\right)\\left(x_{i} - \\frac{\\sum_{l=1}^{N} m_{l} x_{l}}{\\sum_{k=1}^{N} m_{k}}\\right)^{\\top} & \n\\frac{\\sum_{i=1}^{N} m_{i} y_{i}}{\\sum_{k=1}^{N} m_{k}} - R\\left(\\frac{\\sum_{i=1}^{N} m_{i} x_{i}}{\\sum_{k=1}^{N} m_{k}}\\right)\n\\end{matrix}\n}\n$$", "id": "3443709"}, {"introduction": "While standard RMSF calculations are straightforward for Cartesian coordinates, they can produce nonsensical results when naively applied to periodic variables like dihedral angles. This exercise highlights this common pitfall and demonstrates the correct statistical approach for handling circular data by mapping angles onto the unit circle [@problem_id:3443644]. This practice is essential for accurately quantifying the flexibility of a molecule's torsional degrees of freedom, which are often central to its function.", "problem": "Consider a molecular dynamics trajectory of a peptide dihedral angle, where the angle is a periodic variable on the circle. The angular coordinate is recorded over eight equally spaced frames, yielding the values $\\{\\theta_k\\}_{k=1}^{8}$ in radians:\n$$\n\\theta_1 = \\pi - 0.03,\\quad \\theta_2 = \\pi - 0.04,\\quad \\theta_3 = \\pi - 0.05,\\quad \\theta_4 = \\pi - 0.06,\\\\\n\\theta_5 = -\\pi + 0.03,\\quad \\theta_6 = -\\pi + 0.04,\\quad \\theta_7 = -\\pi + 0.05,\\quad \\theta_8 = -\\pi + 0.06.\n$$\nThis observable is a torsional degree of freedom with $2\\pi$-periodicity. Your task is to analyze its average and fluctuations in a way consistent with the topology of the circle and the goals of root-mean-square deviation and fluctuation analysis.\n\nStarting from first principles appropriate to angular data in molecular dynamics:\n- Argue why directly averaging the angles as real numbers on the line can produce a misleading result, based on the periodic identification of angles and the existence of a discontinuity seam at $\\pm \\pi$ on the real line.\n- Derive, by representing each angle $\\theta_k$ as a unit complex number via Euler’s formula, the estimator for the angular mean direction and a variance-like concentration measure that respects circular topology.\n- Using your derivations, define the root-mean-square geodesic deviation about the mean direction for angular data and compute its value for the given dataset.\n\nRound your final numerical answer to four significant figures and express it in radians. Provide only the final numerical value of the root-mean-square geodesic deviation in radians as your answer.", "solution": "The appropriate base for angular statistics in molecular dynamics combines the geometry of the circle with the representation of angles as points on the unit circle. The angle $\\theta$ lives on the manifold $S^1$, where $\\theta$ and $\\theta + 2\\pi$ represent the same physical state. A naive average on the real line does not respect this identification and can be pathologically sensitive to the placement of the discontinuity seam at $\\pm \\pi$.\n\nFirst, consider the naive arithmetic mean of the given angles:\n$$\n\\bar{\\theta}_{\\text{naive}} = \\frac{1}{8}\\sum_{k=1}^{8}\\theta_k.\n$$\nGroup the data into pairs $(\\pi - \\varepsilon, -\\pi + \\varepsilon)$ for $\\varepsilon \\in \\{0.03, 0.04, 0.05, 0.06\\}$. For any such pair,\n$$\n(\\pi - \\varepsilon) + (-\\pi + \\varepsilon) = 0,\n$$\nso the sum over all eight angles is $0$, and hence $\\bar{\\theta}_{\\text{naive}} = 0$. This is misleading: the eight angles cluster near $\\theta \\approx \\pm \\pi$, so the physical mean direction should be near $\\pi$ (or equivalently $-\\pi$), not near $0$. The pathology arises because averaging on the real line does not account for wrap-around at $\\pm \\pi$, effectively dragging values just to the left of $-\\pi$ towards large negative values and values just to the right of $\\pi$ towards large positive values, which cancel in the sum despite being physically adjacent on the circle.\n\nTo avoid this, we embed the angles into the complex plane using Euler’s formula. For each data point,\n$$\nz_k = \\exp(i\\theta_k) = \\cos(\\theta_k) + i\\sin(\\theta_k),\\quad k=1,\\dots,8.\n$$\nDefine the resultant vector\n$$\nS = \\sum_{k=1}^{8} z_k,\\quad R = \\frac{|S|}{8},\n$$\nwhere $|S|$ is the magnitude of $S$. The estimator of the mean direction is the argument of $S$:\n$$\n\\hat{\\mu} = \\arg(S),\n$$\nand the concentration (variance-like) measure can be defined in terms of the mean resultant length $R$, for example the circular variance $V$ given by\n$$\nV = 1 - R,\n$$\nwhich decreases as the angles cluster more tightly around a direction.\n\nCompute $S$ for the given dataset. Use the identities\n$$\n\\exp\\!\\big(i(\\pi - \\varepsilon)\\big) = -\\cos(\\varepsilon) + i\\sin(\\varepsilon),\\quad\n\\exp\\!\\big(i(-\\pi + \\varepsilon)\\big) = -\\cos(\\varepsilon) - i\\sin(\\varepsilon).\n$$\nFor each pair $(\\pi - \\varepsilon, -\\pi + \\varepsilon)$, the sum is\n$$\n-\\cos(\\varepsilon) + i\\sin(\\varepsilon) + \\big(-\\cos(\\varepsilon) - i\\sin(\\varepsilon)\\big) = -2\\cos(\\varepsilon).\n$$\nSumming over $\\varepsilon \\in \\{0.03, 0.04, 0.05, 0.06\\}$,\n$$\nS = -2\\sum_{\\varepsilon \\in \\{0.03, 0.04, 0.05, 0.06\\}} \\cos(\\varepsilon),\n$$\nwhich lies on the negative real axis, so\n$$\n\\hat{\\mu} = \\pi,\\quad R = \\frac{|S|}{8} = \\frac{2\\sum \\cos(\\varepsilon)}{8} = \\frac{1}{4}\\sum_{\\varepsilon \\in \\{0.03, 0.04, 0.05, 0.06\\}} \\cos(\\varepsilon).\n$$\nThis correctly places the mean direction at $\\pi$, in contrast to the naive mean $\\bar{\\theta}_{\\text{naive}} = 0$.\n\nFor root-mean-square deviation and fluctuation analysis on the circle, we must measure deviations along the geodesic on $S^1$, that is, the minimal wrap-around difference. Define the wrapped difference about $\\hat{\\mu}$:\n$$\n\\delta_k = \\mathrm{wrap}_{(-\\pi,\\pi]}\\!\\big(\\theta_k - \\hat{\\mu}\\big),\n$$\nwhich is the representative of $\\theta_k - \\hat{\\mu}$ in $(-\\pi,\\pi]$. The root-mean-square geodesic deviation (circular root-mean-square deviation) about $\\hat{\\mu}$ is\n$$\n\\mathrm{RMS}_{\\mathrm{geo}} = \\sqrt{\\frac{1}{8}\\sum_{k=1}^{8}\\delta_k^{2}}.\n$$\nIn our dataset, with $\\hat{\\mu} = \\pi$, we have\n$$\n\\theta = \\pi - \\varepsilon \\;\\Rightarrow\\; \\delta = -\\varepsilon,\\qquad\n\\theta = -\\pi + \\varepsilon \\;\\Rightarrow\\; \\delta = \\varepsilon,\n$$\nso $|\\delta| = \\varepsilon$ for each angle. Therefore,\n$$\n\\mathrm{RMS}_{\\mathrm{geo}} = \\sqrt{\\frac{1}{8}\\left(2\\sum_{\\varepsilon \\in \\{0.03, 0.04, 0.05, 0.06\\}} \\varepsilon^{2}\\right)}.\n$$\nCompute the sum of squares:\n$$\n0.03^{2} = 0.0009,\\quad 0.04^{2} = 0.0016,\\quad 0.05^{2} = 0.0025,\\quad 0.06^{2} = 0.0036,\n$$\nso\n$$\n\\sum_{\\varepsilon} \\varepsilon^{2} = 0.0009 + 0.0016 + 0.0025 + 0.0036 = 0.0086,\n$$\nand\n$$\n\\frac{1}{8}\\left(2\\sum \\varepsilon^{2}\\right) = \\frac{1}{8}\\times 2 \\times 0.0086 = \\frac{0.0172}{8} = 0.00215.\n$$\nThus,\n$$\n\\mathrm{RMS}_{\\mathrm{geo}} = \\sqrt{0.00215}.\n$$\nEvaluating and rounding to four significant figures in radians,\n$$\n\\mathrm{RMS}_{\\mathrm{geo}} \\approx 0.04637.\n$$\nThis value quantifies the root-mean-square angular fluctuation about the correct circular mean and avoids the wrap-around pathology inherent in naive linear averaging.", "answer": "$$\\boxed{0.04637}$$", "id": "3443644"}, {"introduction": "Translating theory into practice requires addressing the technical realities of simulation environments, chief among them being Periodic Boundary Conditions (PBC). This coding exercise confronts the problem of molecules or parts of molecules diffusing across the simulation box, which can artificially inflate RMSD and RMSF values if not handled correctly [@problem_id:3443654]. By implementing the minimal-image convention, you will develop a crucial and practical skill for obtaining physically meaningful fluctuation data from raw trajectory files.", "problem": "You must write a complete and runnable program that, for trajectories of atoms in an orthorhombic periodic box, quantifies the impact of Periodic Boundary Conditions (PBC) on Root-Mean-Square Deviation (RMSD) and Root-Mean-Square Fluctuation (RMSF) by comparing naive wrapped coordinates versus minimal-image corrected displacements. The program must be self-contained and produce the requested numerical results for the specified test suite in the exact output format.\n\nFundamental base and definitions to use:\n- Euclidean geometry: for any vector $\\mathbf{a}\\in\\mathbb{R}^3$, its squared norm is $\\|\\mathbf{a}\\|^2 = a_x^2 + a_y^2 + a_z^2$ and $\\|\\mathbf{a}\\| = \\sqrt{\\|\\mathbf{a}\\|^2}$.\n- Time averaging: for a time sequence $\\{x(t)\\}_{t=1}^T$, the average is $\\overline{x} = \\frac{1}{T}\\sum_{t=1}^T x(t)$.\n- Periodic Boundary Conditions (PBC) in an orthorhombic box: the box lengths are given by $\\mathbf{L} = (L_x, L_y, L_z)$ and positions are wrapped into the interval $[0,L_\\alpha)$ in each Cartesian component $\\alpha\\in\\{x,y,z\\}$.\n- Minimal-image correction: for each atom $i$ at time $t$, choose $\\mathbf{n}_{i}(t)\\in \\mathbb{Z}^3$ component-wise so that the corrected displacement vector $\\Delta\\mathbf{r}_i^{MIC}(t) = \\Delta\\mathbf{r}_i^{wrap}(t) + \\mathbf{n}_i(t)\\circ \\mathbf{L}$ has minimal Euclidean norm, where $\\Delta\\mathbf{r}_i^{wrap}(t) = \\mathbf{r}_i(t) - \\mathbf{r}_i^{ref}$ and $\\circ$ denotes element-wise multiplication. The choice must be made independently in each component by selecting the nearest integer to $\\Delta r_{i,\\alpha}(t)/L_\\alpha$; ties at exactly half a box ($\\Delta r_{i,\\alpha}(t)/L_\\alpha = \\pm \\tfrac{1}{2}$) must be resolved to the nearest even integer to ensure deterministic behavior.\n- Root-Mean-Square Deviation (RMSD): for $N$ atoms, at time $t$ with a displacement convention $\\Delta\\mathbf{r}_i(t)$, define $R(t) = \\sqrt{\\frac{1}{N}\\sum_{i=1}^N \\|\\Delta\\mathbf{r}_i(t)\\|^2}$ and report the time average $\\overline{R} = \\frac{1}{T}\\sum_{t=1}^T R(t)$.\n- Root-Mean-Square Fluctuation (RMSF): for each atom $i$, reconstruct coordinates $\\mathbf{u}_i(t)$ by adding the displacement to the reference, $\\mathbf{u}_i(t) = \\mathbf{r}_i^{ref} + \\Delta\\mathbf{r}_i(t)$, compute the time average $\\overline{\\mathbf{u}}_i = \\frac{1}{T}\\sum_{t=1}^T \\mathbf{u}_i(t)$, and define $\\mathrm{RMSF}_i = \\sqrt{\\frac{1}{T}\\sum_{t=1}^T \\|\\mathbf{u}_i(t) - \\overline{\\mathbf{u}}_i\\|^2}$. Report the mean across atoms, $\\overline{\\mathrm{F}} = \\frac{1}{N}\\sum_{i=1}^N \\mathrm{RMSF}_i$.\n- Two displacement conventions must be compared:\n  1. Naive wrapped displacements: $\\Delta\\mathbf{r}_i^{wrap}(t) = \\mathbf{r}_i(t) - \\mathbf{r}_i^{ref}$.\n  2. Minimal-image corrected displacements: $\\Delta\\mathbf{r}_i^{MIC}(t)$ constructed as above.\nFor each test case, compute and report four floats: $\\overline{R}^{wrap}$, $\\overline{R}^{MIC}$, $\\overline{\\mathrm{F}}^{wrap}$, $\\overline{\\mathrm{F}}^{MIC}$.\n\nAll positions and box lengths are given in nanometers and all outputs must be reported in nanometers, rounded to $6$ decimal places.\n\nTest suite:\n- Case $1$ (single atom crossing a boundary):\n  - Box: $\\mathbf{L} = (\\,1.0,\\,1.0,\\,1.0\\,)$ in $\\mathrm{nm}$.\n  - Number of atoms: $N=1$.\n  - Number of frames: $T=4$.\n  - Reference positions: $\\mathbf{r}_1^{ref} = (\\,0.90,\\,0.00,\\,0.00\\,)$ in $\\mathrm{nm}$.\n  - Trajectory frames (wrapped coordinates, in $\\mathrm{nm}$):\n    $t=1$: $\\mathbf{r}_1(1) = (\\,0.90,\\,0.00,\\,0.00\\,)$,\n    $t=2$: $\\mathbf{r}_1(2) = (\\,0.95,\\,0.00,\\,0.00\\,)$,\n    $t=3$: $\\mathbf{r}_1(3) = (\\,0.98,\\,0.00,\\,0.00\\,)$,\n    $t=4$: $\\mathbf{r}_1(4) = (\\,0.02,\\,0.00,\\,0.00\\,)$.\n- Case $2$ (three atoms with crossings in different dimensions):\n  - Box: $\\mathbf{L} = (\\,2.0,\\,1.0,\\,1.5\\,)$ in $\\mathrm{nm}$.\n  - Number of atoms: $N=3$.\n  - Number of frames: $T=3$.\n  - Reference positions (in $\\mathrm{nm}$):\n    $\\mathbf{r}_1^{ref} = (\\,1.80,\\,0.20,\\,0.75\\,)$,\n    $\\mathbf{r}_2^{ref} = (\\,0.10,\\,0.90,\\,0.10\\,)$,\n    $\\mathbf{r}_3^{ref} = (\\,1.99,\\,0.05,\\,1.49\\,)$.\n  - Trajectory frames (wrapped coordinates, in $\\mathrm{nm}$):\n    $t=1$:\n      $\\mathbf{r}_1(1) = (\\,1.85,\\,0.22,\\,0.78\\,)$,\n      $\\mathbf{r}_2(1) = (\\,0.15,\\,0.92,\\,0.14\\,)$,\n      $\\mathbf{r}_3(1) = (\\,1.98,\\,0.06,\\,1.48\\,)$.\n    $t=2$:\n      $\\mathbf{r}_1(2) = (\\,0.05,\\,0.22,\\,0.78\\,)$,\n      $\\mathbf{r}_2(2) = (\\,0.15,\\,0.02,\\,0.14\\,)$,\n      $\\mathbf{r}_3(2) = (\\,1.98,\\,0.06,\\,0.01\\,)$.\n    $t=3$:\n      $\\mathbf{r}_1(3) = (\\,0.10,\\,0.24,\\,0.77\\,)$,\n      $\\mathbf{r}_2(3) = (\\,0.18,\\,0.05,\\,0.08\\,)$,\n      $\\mathbf{r}_3(3) = (\\,0.02,\\,0.04,\\,0.02\\,)$.\n- Case $3$ (edge case at exactly half-box displacements in components):\n  - Box: $\\mathbf{L} = (\\,1.0,\\,1.0,\\,1.0\\,)$ in $\\mathrm{nm}$.\n  - Number of atoms: $N=2$.\n  - Number of frames: $T=2$.\n  - Reference positions (in $\\mathrm{nm}$):\n    $\\mathbf{r}_1^{ref} = (\\,0.25,\\,0.25,\\,0.25\\,)$,\n    $\\mathbf{r}_2^{ref} = (\\,0.75,\\,0.75,\\,0.75\\,)$.\n  - Trajectory frames (wrapped coordinates, in $\\mathrm{nm}$):\n    $t=1$:\n      $\\mathbf{r}_1(1) = (\\,0.75,\\,0.25,\\,0.25\\,)$,\n      $\\mathbf{r}_2(1) = (\\,0.25,\\,0.75,\\,0.75\\,)$.\n    $t=2$:\n      $\\mathbf{r}_1(2) = (\\,0.75,\\,0.75,\\,0.25\\,)$,\n      $\\mathbf{r}_2(2) = (\\,0.25,\\,0.25,\\,0.75\\,)$.\n\nProgram requirements:\n- Implement functions to compute $\\overline{R}^{wrap}$, $\\overline{R}^{MIC}$, $\\overline{\\mathrm{F}}^{wrap}$, and $\\overline{\\mathrm{F}}^{MIC}$ exactly as described above, using the specified tie-breaking rule for the minimal-image selection (nearest integer with ties resolved to the even integer) independently in each Cartesian component.\n- Units: inputs are in $\\mathrm{nm}$ and outputs must be in $\\mathrm{nm}$.\n- Output rounding: round each reported float to $6$ decimal places.\n- Final output format: a single line containing a list of results for all test cases, where each test case contributes a list of four floats in the order $[\\,\\overline{R}^{wrap},\\,\\overline{R}^{MIC},\\,\\overline{\\mathrm{F}}^{wrap},\\,\\overline{\\mathrm{F}}^{MIC}\\,]$. The overall output must be a single list of these lists, printed exactly as a Python list literal, for example, `[[a_1, b_1, c_1, d_1], [a_2, b_2, c_2, d_2], [a_3, b_3, c_3, d_3]]`.", "solution": "The problem presented is a well-defined computational task from the field of molecular dynamics simulation analysis. It requires the calculation of two standard metrics, Root-Mean-Square Deviation (RMSD) and Root-Mean-Square Fluctuation (RMSF), under two different conventions for handling particle displacements in a system with Periodic Boundary Conditions (PBC). The problem is scientifically grounded, internally consistent, and provides all necessary data and definitions for a unique, verifiable solution. Thus, the problem is deemed valid and a solution will be constructed.\n\nThe core of the problem lies in comparing a \"naive\" calculation, which ignores particles crossing periodic boundaries, with a \"corrected\" calculation that accounts for such crossings using the minimal-image convention (MIC). We are tasked with quantifying this difference for RMSD and RMSF. Let us systematically define the required quantities and outline the computational procedure.\n\nAll positions $\\mathbf{r}$ and box lengths $\\mathbf{L}$ are vectors in $\\mathbb{R}^3$. We are given a set of $N$ atoms, a reference configuration $\\{\\mathbf{r}_i^{ref}\\}_{i=1}^N$, and a trajectory of $T$ time frames, $\\{\\mathbf{r}_i(t)\\}_{i=1, t=1}^{N, T}$.\n\n**1. Displacement Conventions**\n\nTwo conventions for calculating the displacement vector, $\\Delta\\mathbf{r}_i(t) = \\mathbf{r}_i(t) - \\mathbf{r}_i^{ref}$, are specified.\n\n*   **Naive Wrapped Displacement ($\\Delta\\mathbf{r}^{wrap}$):** This is the simple vector difference between the wrapped coordinates at time $t$ and the reference coordinates.\n    $$ \\Delta\\mathbf{r}_i^{wrap}(t) = \\mathbf{r}_i(t) - \\mathbf{r}_i^{ref} $$\n    This calculation can yield artificially large displacements if an atom has crossed a periodic boundary.\n\n*   **Minimal-Image Corrected Displacement ($\\Delta\\mathbf{r}^{MIC}$):** This convention corrects the wrapped displacement by finding the periodic image of atom $i$ at time $t$ that is closest to its reference position. For an orthorhombic box with side lengths $\\mathbf{L}=(L_x, L_y, L_z)$, the corrected displacement is:\n    $$ \\Delta\\mathbf{r}_i^{MIC}(t) = \\Delta\\mathbf{r}_i^{wrap}(t) + \\mathbf{n}_i(t) \\circ \\mathbf{L} $$\n    where $\\circ$ denotes the element-wise (Hadamard) product, and $\\mathbf{n}_i(t)$ is a vector of integers chosen to minimize the norm $\\|\\Delta\\mathbf{r}_i^{MIC}(t)\\|$. This is achieved by minimizing each component independently. For each Cartesian component $\\alpha \\in \\{x, y, z\\}$, we must choose an integer $n_{i, \\alpha}(t)$ such that $|\\Delta r_{i,\\alpha}^{wrap}(t) + n_{i, \\alpha}(t) L_{\\alpha}|$ is minimized. This is equivalent to ensuring the corrected component lies in the interval $[-L_{\\alpha}/2, L_{\\alpha}/2]$. The integer $n_{i, \\alpha}(t)$ is calculated as:\n    $$ n_{i, \\alpha}(t) = -\\text{round}\\left(\\frac{\\Delta r_{i, \\alpha}^{wrap}(t)}{L_{\\alpha}}\\right) $$\n    The problem specifies a tie-breaking rule for when the scaled displacement is exactly $\\pm 0.5$: the value is rounded to the nearest even integer. This ensures deterministic behavior.\n\n**2. Root-Mean-Square Deviation (RMSD)**\n\nThe RMSD measures the average distance between the atoms in a given configuration and the reference configuration.\nFirst, for each time frame $t$, we compute the instantaneous root-mean-square distance, $R(t)$:\n$$ R(t) = \\sqrt{\\frac{1}{N}\\sum_{i=1}^N \\|\\Delta\\mathbf{r}_i(t)\\|^2} $$\nwhere $\\|\\cdot\\|$ is the Euclidean norm. The final reported RMSD, $\\overline{R}$, is the time-average of $R(t)$:\n$$ \\overline{R} = \\frac{1}{T}\\sum_{t=1}^T R(t) $$\nWe will compute this for both displacement conventions, yielding $\\overline{R}^{wrap}$ and $\\overline{R}^{MIC}$.\n\n**3. Root-Mean-Square Fluctuation (RMSF)**\n\nThe RMSF measures the fluctuation of each atom around its average position over the trajectory.\nFirst, we must reconstruct a continuous (unwrapped) trajectory, $\\mathbf{u}_i(t)$, based on a chosen displacement convention:\n$$ \\mathbf{u}_i(t) = \\mathbf{r}_i^{ref} + \\Delta\\mathbf{r}_i(t) $$\nNext, we find the time-averaged position for each atom, $\\overline{\\mathbf{u}}_i$:\n$$ \\overline{\\mathbf{u}}_i = \\frac{1}{T}\\sum_{t=1}^T \\mathbf{u}_i(t) $$\nThe RMSF for atom $i$, $\\mathrm{RMSF}_i$, is the root-mean-square of its deviations from this average position:\n$$ \\mathrm{RMSF}_i = \\sqrt{\\frac{1}{T}\\sum_{t=1}^T \\|\\mathbf{u}_i(t) - \\overline{\\mathbf{u}}_i\\|^2} $$\nThe final reported value, $\\overline{\\mathrm{F}}$, is the average of the individual atomic RMSF values over all atoms:\n$$ \\overline{\\mathrm{F}} = \\frac{1}{N}\\sum_{i=1}^N \\mathrm{RMSF}_i $$\nWe will compute this for both displacement conventions, yielding $\\overline{\\mathrm{F}}^{wrap}$ and $\\overline{\\mathrm{F}}^{MIC}$.\n\n**Algorithm Implementation**\n\nThe solution will be implemented in Python using the `numpy` library for efficient vectorized operations.\n\n1.  For each test case, the input data (box dimensions $\\mathbf{L}$, reference positions $\\mathbf{r}^{ref}$, and trajectory positions $\\mathbf{r}(t)$) are loaded into `numpy` arrays.\n2.  The wrapped displacements $\\Delta\\mathbf{r}^{wrap}$ are calculated as a $T \\times N \\times 3$ array.\n3.  A function implementing the MIC rule is used to compute the MIC displacements $\\Delta\\mathbf{r}^{MIC}$, also as a $T \\times N \\times 3$ array. `numpy.round` naturally implements the specified 'round half to even' tie-breaking rule.\n4.  Separate functions are implemented to calculate $\\overline{R}$ and $\\overline{\\mathrm{F}}$ from a given displacement array ($T \\times N \\times 3$) and the reference positions.\n5.  These functions are called with both $\\Delta\\mathbf{r}^{wrap}$ and $\\Delta\\mathbf{r}^{MIC}$ to obtain the four required metrics: $\\overline{R}^{wrap}$, $\\overline{R}^{MIC}$, $\\overline{\\mathrm{F}}^{wrap}$, and $\\overline{\\mathrm{F}}^{MIC}$.\n6.  The results for each case are rounded to $6$ decimal places and collected.\n7.  Finally, the collected results from all test cases are formatted into a single string representing a list of lists, as specified.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to process all test cases and print the final results.\n    \"\"\"\n    test_cases = [\n        {\n            \"L\": (1.0, 1.0, 1.0),\n            \"N\": 1,\n            \"T\": 4,\n            \"ref_pos\": [[0.90, 0.00, 0.00]],\n            \"traj\": [\n                [[0.90, 0.00, 0.00]],\n                [[0.95, 0.00, 0.00]],\n                [[0.98, 0.00, 0.00]],\n                [[0.02, 0.00, 0.00]],\n            ],\n        },\n        {\n            \"L\": (2.0, 1.0, 1.5),\n            \"N\": 3,\n            \"T\": 3,\n            \"ref_pos\": [\n                [1.80, 0.20, 0.75],\n                [0.10, 0.90, 0.10],\n                [1.99, 0.05, 1.49],\n            ],\n            \"traj\": [\n                [\n                    [1.85, 0.22, 0.78],\n                    [0.15, 0.92, 0.14],\n                    [1.98, 0.06, 1.48],\n                ],\n                [\n                    [0.05, 0.22, 0.78],\n                    [0.15, 0.02, 0.14],\n                    [1.98, 0.06, 0.01],\n                ],\n                [\n                    [0.10, 0.24, 0.77],\n                    [0.18, 0.05, 0.08],\n                    [0.02, 0.04, 0.02],\n                ],\n            ],\n        },\n        {\n            \"L\": (1.0, 1.0, 1.0),\n            \"N\": 2,\n            \"T\": 2,\n            \"ref_pos\": [\n                [0.25, 0.25, 0.25],\n                [0.75, 0.75, 0.75],\n            ],\n            \"traj\": [\n                [\n                    [0.75, 0.25, 0.25],\n                    [0.25, 0.75, 0.75],\n                ],\n                [\n                    [0.75, 0.75, 0.25],\n                    [0.25, 0.25, 0.75],\n                ]\n            ],\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        case_results = _compute_metrics_for_case(case)\n        results.append(case_results)\n\n    # The string representation of a list of lists is the required format.\n    print(str(results))\n\ndef _get_mic_displacements(delta_r_wrap, L_array):\n    \"\"\"\n    Computes minimal-image corrected displacements from wrapped displacements.\n    The tie-breaking rule (round half to nearest even integer) is the default\n    behavior of numpy.round().\n    \"\"\"\n    scaled_dr = delta_r_wrap / L_array\n    n = -np.round(scaled_dr)\n    delta_r_mic = delta_r_wrap + n * L_array\n    return delta_r_mic\n\ndef _compute_avg_rmsd(displacements, N, T):\n    \"\"\"Computes time-averaged RMSD from a displacement array.\"\"\"\n    sq_norms = np.sum(displacements**2, axis=2)  # Shape: (T, N)\n    msd_t = np.mean(sq_norms, axis=1)           # Shape: (T,)\n    R_t = np.sqrt(msd_t)\n    avg_R = np.mean(R_t)\n    return avg_R\n\ndef _compute_avg_rmsf(displacements, ref_pos, N, T):\n    \"\"\"Computes atom-averaged RMSF from a displacement array and reference positions.\"\"\"\n    # Reconstruct continuous trajectory u_i(t) = r_ref_i + delta_r_i(t)\n    # ref_pos has shape (N, 3). Add new axis to broadcast to (T, N, 3)\n    u = ref_pos[np.newaxis, :, :] + displacements\n    \n    # Compute time-averaged position for each atom, u_mean has shape (N, 3)\n    u_mean = np.mean(u, axis=0)\n    \n    # Calculate deviations from the mean: u(t) - u_mean\n    # u_mean has shape (N, 3). Add new axis to broadcast to (T, N, 3)\n    dev_from_mean = u - u_mean[np.newaxis, :, :]\n    \n    # Compute RMSF per atom\n    sq_norms_dev = np.sum(dev_from_mean**2, axis=2) # Shape: (T, N)\n    msd_i = np.mean(sq_norms_dev, axis=0)          # Shape: (N,)\n    RMSF_i = np.sqrt(msd_i)\n    \n    # Average RMSF over all atoms\n    avg_F = np.mean(RMSF_i)\n    return avg_F\n\ndef _compute_metrics_for_case(case_data):\n    \"\"\"\n    Processes a single test case to compute all four required metrics.\n    \"\"\"\n    L = np.array(case_data[\"L\"])\n    ref_pos = np.array(case_data[\"ref_pos\"])\n    traj = np.array(case_data[\"traj\"])\n    N = case_data[\"N\"]\n    T = case_data[\"T\"]\n\n    # Calculate wrapped displacements: traj - ref_pos\n    # ref_pos has shape (N, 3). Add a new axis to broadcast to (T, N, 3).\n    delta_r_wrap = traj - ref_pos[np.newaxis, :, :]\n\n    # Calculate minimal-image corrected displacements\n    delta_r_mic = _get_mic_displacements(delta_r_wrap, L)\n\n    # Compute RMSD for both conventions\n    R_wrap = _compute_avg_rmsd(delta_r_wrap, N, T)\n    R_mic = _compute_avg_rmsd(delta_r_mic, N, T)\n\n    # Compute RMSF for both conventions\n    F_wrap = _compute_avg_rmsf(delta_r_wrap, ref_pos, N, T)\n    F_mic = _compute_avg_rmsf(delta_r_mic, ref_pos, N, T)\n\n    # Round results to 6 decimal places\n    return [\n        round(R_wrap, 6),\n        round(R_mic, 6),\n        round(F_wrap, 6),\n        round(F_mic, 6)\n    ]\n\n# Run the solution\nsolve()\n```", "id": "3443654"}]}