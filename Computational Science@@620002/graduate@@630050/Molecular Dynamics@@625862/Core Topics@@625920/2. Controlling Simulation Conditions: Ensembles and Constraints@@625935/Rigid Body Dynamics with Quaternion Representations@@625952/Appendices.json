{"hands_on_practices": [{"introduction": "The quaternion representation of rotations offers significant advantages in avoiding singularities, but its double-covering nature—where both $\\mathbf{q}$ and $-\\mathbf{q}$ encode the same physical orientation—presents a practical challenge. This exercise [@problem_id:3442442] dives into the critical task of post-processing orientation trajectories to resolve this ambiguity, which can otherwise manifest as large, artificial jumps in angular data. By implementing and comparing different \"unwrapping\" conventions, you will develop an essential skill for ensuring the integrity and physical meaning of your simulation results.", "problem": "Consider a rigid body in molecular dynamics under periodic boundary conditions. The orientation of the rigid body at discrete time index $t$ is represented by a unit quaternion $q_t \\in \\mathbb{H}$ with scalar part $q_{t,0}$ and vector part $\\mathbf{q}_{t,v}$, satisfying $\\|q_t\\| = 1$. The unit quaternion representation double-covers the special orthogonal group in three dimensions $\\mathrm{SO}(3)$, meaning $q$ and $-q$ represent the same physical rotation. This sign indeterminacy can produce artificial discontinuities in recorded orientation trajectories when naïvely post-processed, especially when coordinates are remapped by periodic boundary conditions or when a fixed-hemisphere sign rule is imposed without regard to temporal continuity.\n\nStart from the following fundamental bases and definitions:\n- A unit quaternion $q = (q_0, \\mathbf{q}_v)$ represents a rotation by angle $\\theta \\in [0, 2\\pi)$ about a unit axis $\\hat{\\mathbf{u}}$ through the mapping $q = \\left(\\cos(\\theta/2), \\hat{\\mathbf{u}} \\sin(\\theta/2)\\right)$.\n- The inverse of a unit quaternion is its conjugate, $q^{-1} = \\bar{q} = (q_0, -\\mathbf{q}_v)$.\n- The Hamilton product $\\otimes$ composes rotations: if $p$ and $q$ are unit quaternions, then $p \\otimes q$ corresponds to applying rotation $q$ after rotation $p$.\n- For two orientations $p$ and $q$, the relative orientation is $r = p^{-1} \\otimes q$, which corresponds to a rotation by angle $\\Delta \\theta \\in [0, 2\\pi]$ about some axis, with $\\Delta \\theta$ obtained from the scalar part $r_0$ via $\\Delta \\theta = 2 \\arccos(\\max(-1,\\min(1,r_0)))$. All angles in this problem must be expressed in radians.\n\nTask. You must implement three sign-wrapping conventions for a sequence of unit quaternions $\\{q_t\\}_{t=0}^{N-1}$, and for each convention compute the maximum frame-to-frame rotation angle $\\max_{t \\ge 1} \\Delta \\theta_t$ as follows:\n- Convention $\\mathcal{N}$ (\"none\"): Leave the sequence unchanged. For each $t \\ge 1$, compute the relative quaternion $r_t = \\bar{q}_{t-1} \\otimes q_t$ and the step angle $\\Delta \\theta_t = 2 \\arccos(\\max(-1,\\min(1,(r_t)_0)))$ using $r_t$'s scalar part $(r_t)_0$.\n- Convention $\\mathcal{H}$ (\"hemisphere\"): Map each $q_t$ to $q_t'$ by multiplying by $-1$ if and only if $q_{t,0} < 0$, leaving it unchanged otherwise. Then compute $\\Delta \\theta_t$ using the same relative-quaternion procedure on $\\{q_t'\\}$.\n- Convention $\\mathcal{S}$ (\"smooth-min-jump\"): Starting from $q_0' = q_0$, recursively choose $q_t' \\in \\{q_t, -q_t\\}$ for $t \\ge 1$ so that the immediate frame-to-frame rotation angle between $q_{t-1}'$ and $q_t'$ is minimized, that is, choose the sign of $q_t'$ that minimizes $\\Delta \\theta_t$ computed from $r_t' = \\overline{q_{t-1}'} \\otimes q_t'$. Then compute $\\Delta \\theta_t$ using $\\{q_t'\\}$.\n\nYou should implement the following test suite, where each trajectory is defined by a fixed unit axis $\\hat{\\mathbf{u}}$, an angular increment per frame $\\omega$, a length $N$, and an optional set of indices $\\mathcal{F}$ at which the recorded quaternion is multiplied by $-1$ to simulate sign flips introduced by post-processing:\n- Trajectory $\\mathsf{A}$: $\\hat{\\mathbf{u}}_{\\mathsf{A}} = (0,0,1)$, $\\omega_{\\mathsf{A}} = 0.1$, $N_{\\mathsf{A}} = 200$, $\\mathcal{F}_{\\mathsf{A}} = \\{50, 120, 121\\}$. Define $q_t^{\\mathsf{A}} = \\left(\\cos(\\theta_t/2), \\hat{\\mathbf{u}}_{\\mathsf{A}} \\sin(\\theta_t/2)\\right)$ with $\\theta_t = \\omega_{\\mathsf{A}} t$. After constructing the sequence, apply $q_t^{\\mathsf{A}} \\leftarrow - q_t^{\\mathsf{A}}$ for all $t \\in \\mathcal{F}_{\\mathsf{A}}$.\n- Trajectory $\\mathsf{B}$: $\\hat{\\mathbf{u}}_{\\mathsf{B}} = (1,0,0)$, $\\omega_{\\mathsf{B}} = 0.2$, $N_{\\mathsf{B}} = 100$, $\\mathcal{F}_{\\mathsf{B}} = \\varnothing$. Construct $q_t^{\\mathsf{B}}$ analogously with $\\theta_t = \\omega_{\\mathsf{B}} t$.\n- Trajectory $\\mathsf{C}$: $\\hat{\\mathbf{u}}_{\\mathsf{C}} = \\frac{1}{\\sqrt{14}}(1,2,3)$, $\\omega_{\\mathsf{C}} = 1.3\\pi$, $N_{\\mathsf{C}} = 5$, $\\mathcal{F}_{\\mathsf{C}} = \\varnothing$. Construct $q_t^{\\mathsf{C}}$ analogously with $\\theta_t = \\omega_{\\mathsf{C}} t$.\n\nFor each trajectory $\\mathsf{X} \\in \\{\\mathsf{A}, \\mathsf{B}, \\mathsf{C}\\}$ and each convention $\\mathcal{C} \\in \\{\\mathcal{N}, \\mathcal{H}, \\mathcal{S}\\}$, compute the maximum frame-to-frame rotation angle\n$$\nJ(\\mathsf{X}, \\mathcal{C}) = \\max_{1 \\le t \\le N_{\\mathsf{X}}-1} \\left[ 2 \\arccos\\left(\\max(-1,\\min(1, (r_t^{\\mathcal{C}})_0))\\right) \\right],\n$$\nwhere $r_t^{\\mathcal{C}}$ is the relative quaternion computed from the post-processed sequence under convention $\\mathcal{C}$ as defined above. All angles must be in radians.\n\nFinal output format. Your program should produce a single line of output containing the nine floating-point results\n$$\n\\left[ J(\\mathsf{A},\\mathcal{N}), J(\\mathsf{A},\\mathcal{H}), J(\\mathsf{A},\\mathcal{S}), J(\\mathsf{B},\\mathcal{N}), J(\\mathsf{B},\\mathcal{H}), J(\\mathsf{B},\\mathcal{S}), J(\\mathsf{C},\\mathcal{N}), J(\\mathsf{C},\\mathcal{H}), J(\\mathsf{C},\\mathcal{S}) \\right]\n$$\nrounded to six decimal places, printed as a comma-separated list enclosed in square brackets, for example, `[x_1,x_2,...,x_9]` where each $x_i$ is a decimal numeral in radians with exactly six digits after the decimal point.", "solution": "The objective is to analyze quaternion trajectories representing rigid body rotations by computing the maximum frame-to-frame angular displacement under three different sign-unwrapping conventions. This addresses a common artifact in molecular dynamics simulations where the sign ambiguity of quaternions ($q$ and $-q$ represent the same rotation) can lead to spurious jumps in a time series. The analysis involves implementing the conventions and applying them to three test trajectories, $\\mathsf{A}$, $\\mathsf{B}$, and $\\mathsf{C}$.\n\nThe foundational mathematical framework relies on the algebra of unit quaternions. A unit quaternion $q = (q_0, \\mathbf{q}_v)$ with scalar part $q_0 \\in \\mathbb{R}$ and vector part $\\mathbf{q}_v \\in \\mathbb{R}^3$ satisfies the condition $\\|q\\|^2 = q_0^2 + \\|\\mathbf{q}_v\\|^2 = 1$.\n\nThe key operations are:\n$1$. **Quaternion Conjugate**: The inverse of a unit quaternion $q$ is its conjugate, $\\bar{q} = (q_0, -\\mathbf{q}_v)$.\n$2$. **Hamilton Product**: The composition of two rotations represented by quaternions $p$ and $q$ is given by their Hamilton product, $p \\otimes q$. For $p=(p_0, \\mathbf{p}_v)$ and $q=(q_0, \\mathbf{q}_v)$, the product $r=p \\otimes q$ is defined as $r = (p_0 q_0 - \\mathbf{p}_v \\cdot \\mathbf{q}_v, p_0 \\mathbf{q}_v + q_0 \\mathbf{p}_v + \\mathbf{p}_v \\times \\mathbf{q}_v)$.\n$3$. **Relative Orientation**: The rotation that transforms an orientation represented by $q_{t-1}$ to an orientation represented by $q_t$ is given by the relative quaternion $r_t = \\bar{q}_{t-1} \\otimes q_t$.\n$4$. **Angle Extraction**: The angle of rotation $\\Delta\\theta_t$ corresponding to the relative quaternion $r_t$ is extracted from its scalar part $(r_t)_0$ using the formula $\\Delta\\theta_t = 2 \\arccos((r_t)_0)$. To ensure numerical stability, the argument of $\\arccos$ is clamped to the interval $[-1, 1]$.\n\nBased on these operations, we evaluate the maximum angular jump $J(\\mathsf{X}, \\mathcal{C}) = \\max_{1 \\le t \\le N-1} \\Delta\\theta_t$ for each trajectory $\\mathsf{X}$ and convention $\\mathcal{C}$ by processing the raw quaternion sequence $\\{q_t\\}_{t=0}^{N-1}$ as follows.\n\n**Convention $\\mathcal{N}$ (\"none\")**:\nThis convention performs no modification to the input trajectory. The sequence used for angle calculation is simply the original sequence, $\\{q_t'\\} = \\{q_t\\}$. The maximum angle is computed directly from this sequence. This serves as a baseline, revealing the raw discontinuities present in the data.\n\n**Convention $\\mathcal{H}$ (\"hemisphere\")**:\nThis convention enforces a fixed sign choice by mapping all quaternions to a single hemisphere of the $S^3$ hypersphere, conventionally the one where the scalar part is non-negative. The new sequence $\\{q_t'\\}$ is generated from the original sequence $\\{q_t\\}$ by the rule:\n$$\nq_t' = \\begin{cases}\n-q_t & \\text{if } q_{t,0} < 0 \\\\\nq_t & \\text{if } q_{t,0} \\ge 0\n\\end{cases}\n$$\nThis is applied independently to each quaternion in the sequence. While simple, this method does not guarantee temporal smoothness and can introduce new discontinuities where the trajectory crosses the $q_0=0$ boundary.\n\n**Convention $\\mathcal{S}$ (\"smooth-min-jump\")**:\nThis convention aims to produce a temporally smooth trajectory by minimizing the frame-to-frame rotational distance. It is a recursive process. Starting with $q_0' = q_0$, each subsequent quaternion $q_t'$ is chosen from the pair $\\{q_t, -q_t\\}$ to be \"closer\" to the preceding processed quaternion $q_{t-1}'$. The minimal rotation angle corresponds to the maximal scalar part of the relative quaternion $r_t' = \\overline{q_{t-1}'} \\otimes q_t'$. The scalar part of $\\overline{q_{t-1}'} \\otimes q_t$ is the four-dimensional dot product $q_{t-1}' \\cdot q_t$. The scalar part of $\\overline{q_{t-1}'} \\otimes (-q_t)$ is $-(q_{t-1}' \\cdot q_t)$. Therefore, to maximize the scalar part, one must ensure it is non-negative. The recursive rule is:\n$q_0' = q_0$\n$$\nq_t' = \\begin{cases}\n-q_t & \\text{if } q_{t-1}' \\cdot q_t < 0 \\\\\nq_t & \\text{if } q_{t-1}' \\cdot q_t \\ge 0\n\\end{cases}\n\\quad \\text{for } t \\ge 1\n$$\nThis greedy approach effectively unwraps the trajectory by propagating a consistent sign choice forward in time.\n\nThe overall computational procedure is as follows:\n$1$. For each test case ($\\mathsf{A}$, $\\mathsf{B}$, $\\mathsf{C}$), generate the raw quaternion trajectory $\\{q_t\\}$ using the provided axis $\\hat{\\mathbf{u}}$, angular increment $\\omega$, number of steps $N$, and flip set $\\mathcal{F}$.\n$2$. For each convention ($\\mathcal{N}$, $\\mathcal{H}$, $\\mathcal{S}$), create a processed trajectory $\\{q_t'\\}$ according to its specific rule.\n$3$. For each processed trajectory, iterate from $t=1$ to $N-1$, calculate the relative quaternion $r_t' = \\overline{q_{t-1}'} \\otimes q_t'$, extract the angle $\\Delta\\theta_t = 2 \\arccos(\\text{clip}((r_t')_0, -1, 1))$, and determine the maximum angle over the trajectory.\n$4$. Collect the nine resulting values, format them to six decimal places, and print them in the specified list format.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the quaternion trajectory processing problem.\n    This function defines the quaternion operations, trajectory generation,\n    processing conventions, and then computes the required metrics for the\n    given test cases.\n    \"\"\"\n\n    # --- Quaternion Operations ---\n\n    def hamilton_product(p, q):\n        \"\"\"Computes the Hamilton product of two quaternions.\"\"\"\n        p0, pv = p[0], p[1:]\n        q0, qv = q[0], q[1:]\n        r0 = p0 * q0 - np.dot(pv, qv)\n        rv = p0 * qv + q0 * pv + np.cross(pv, qv)\n        return np.array([r0, rv[0], rv[1], rv[2]])\n\n    def conjugate(q):\n        \"\"\"Computes the conjugate of a quaternion.\"\"\"\n        return np.array([q[0], -q[1], -q[2], -q[3]])\n\n    # --- Trajectory Generation ---\n\n    def generate_trajectory(u, w, N, flips):\n        \"\"\"Generates a quaternion trajectory.\"\"\"\n        q_traj = np.zeros((N, 4))\n        for t in range(N):\n            theta = w * float(t)\n            q0 = np.cos(theta / 2.0)\n            qv = u * np.sin(theta / 2.0)\n            q = np.array([q0, qv[0], qv[1], qv[2]])\n            if t in flips:\n                q = -q\n            q_traj[t] = q\n        return q_traj\n\n    # --- Processing Conventions ---\n\n    def process_none(q_traj):\n        \"\"\"Convention N: No modification.\"\"\"\n        return q_traj\n\n    def process_hemisphere(q_traj):\n        \"\"\"Convention H: Map to q0 >= 0 hemisphere.\"\"\"\n        q_prime = q_traj.copy()\n        # Vectorized operation for efficiency\n        q_prime[q_prime[:, 0] < 0] *= -1\n        return q_prime\n\n    def process_smooth(q_traj):\n        \"\"\"Convention S: Minimize frame-to-frame jump.\"\"\"\n        q_prime = np.zeros_like(q_traj)\n        q_prime[0] = q_traj[0]\n        for t in range(1, len(q_traj)):\n            # The 4D dot product determines the shorter rotational path.\n            # A negative dot product implies the rotation via -q_t is shorter.\n            if np.dot(q_prime[t-1], q_traj[t]) < 0:\n                q_prime[t] = -q_traj[t]\n            else:\n                q_prime[t] = q_traj[t]\n        return q_prime\n\n    # --- Main Calculation ---\n\n    def compute_max_angle(q_traj):\n        \"\"\"Computes the max frame-to-frame angle for a trajectory.\"\"\"\n        max_angle = 0.0\n        if len(q_traj) < 2:\n            return 0.0\n            \n        for t in range(1, len(q_traj)):\n            q_prev = q_traj[t-1]\n            q_curr = q_traj[t]\n            \n            # Relative quaternion r = q_prev^{-1} * q_curr\n            r = hamilton_product(conjugate(q_prev), q_curr)\n            \n            # Clip to handle potential floating-point inaccuracies\n            r0 = np.clip(r[0], -1.0, 1.0)\n            \n            angle = 2.0 * np.arccos(r0)\n            if angle > max_angle:\n                max_angle = angle\n                \n        return max_angle\n\n    # --- Test Case Definitions ---\n\n    uA = np.array([0.0, 0.0, 1.0])\n    wA = 0.1\n    NA = 200\n    fA = {50, 120, 121}\n\n    uB = np.array([1.0, 0.0, 0.0])\n    wB = 0.2\n    NB = 100\n    fB = set()\n\n    uC_unnormalized = np.array([1.0, 2.0, 3.0])\n    uC = uC_unnormalized / np.linalg.norm(uC_unnormalized)\n    wC = 1.3 * np.pi\n    NC = 5\n    fC = set()\n    \n    test_cases = [\n        {'u': uA, 'w': wA, 'N': NA, 'flips': fA},\n        {'u': uB, 'w': wB, 'N': NB, 'flips': fB},\n        {'u': uC, 'w': wC, 'N': NC, 'flips': fC}\n    ]\n\n    results = []\n    \n    # --- Execution Loop ---\n    \n    for case in test_cases:\n        traj = generate_trajectory(case['u'], case['w'], case['N'], case['flips'])\n        \n        # Convention N\n        traj_N = process_none(traj)\n        max_angle_N = compute_max_angle(traj_N)\n        results.append(max_angle_N)\n        \n        # Convention H\n        traj_H = process_hemisphere(traj)\n        max_angle_H = compute_max_angle(traj_H)\n        results.append(max_angle_H)\n        \n        # Convention S\n        traj_S = process_smooth(traj)\n        max_angle_S = compute_max_angle(traj_S)\n        results.append(max_angle_S)\n        \n    # --- Final Output ---\n    \n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3442442"}, {"introduction": "Moving from analyzing trajectories to controlling them, this practice [@problem_id:3442479] introduces the fundamental concept of applying orientational constraints. You will use the principle of virtual work and Lagrange multipliers to derive the precise torque required to align a rigid body's specific axis with a direction in space. This exercise builds a core competency in constrained dynamics, forming the basis for steering molecular systems or modeling environments with fixed geometric requirements.", "problem": "Consider a rigid body used in Molecular Dynamics simulations whose orientation is represented by a unit Hamilton quaternion $\\,\\mathbf{q}=(q_0,q_1,q_2,q_3)\\,$ with scalar-first ordering. Let $\\,R(\\mathbf{q})\\in\\mathbb{R}^{3\\times 3}\\,$ be the rotation matrix corresponding to $\\,\\mathbf{q}\\,$, mapping body-fixed vectors to the space (laboratory) frame. Define the orientation alignment constraint as the scalar function\n$$\ng(\\mathbf{q})=\\hat{\\mathbf{e}}_z\\cdot R(\\mathbf{q})\\hat{\\mathbf{n}}-c,\n$$\nwhere $\\,\\hat{\\mathbf{e}}_z=(0,0,1)\\,$ is the unit vector along the space-frame $z$-axis, $\\,\\hat{\\mathbf{n}}\\in\\mathbb{R}^3\\,$ is a unit vector fixed in the body frame, and $\\,c\\in[-1,1]\\,$ is a prescribed constant. Angles are to be treated in radians. All torques must be expressed in Newton-meters (N·m).\n\nStarting from first principles appropriate to rigid-body dynamics and Molecular Dynamics:\n- Use the virtual work principle for holonomic constraints and the quaternion kinematic relation for small rotations to derive an expression for the generalized constraint torque $\\,\\boldsymbol{\\tau}_c(\\mathbf{q},\\lambda)\\,$ associated with $\\,g(\\mathbf{q})\\,$, where $\\,\\lambda\\,$ is the Lagrange multiplier with units of Newton-meters.\n- Derive the gradient $\\,\\nabla_{\\mathbf{q}} g(\\mathbf{q})\\in\\mathbb{R}^4\\,$ using quaternion calculus and the mapping between infinitesimal angular variation $\\,\\delta\\boldsymbol{\\theta}\\in\\mathbb{R}^3\\,$ and quaternion variation $\\,\\delta\\mathbf{q}\\,$. Let $\\,E(\\mathbf{q})\\in\\mathbb{R}^{4\\times 3}\\,$ denote the matrix that satisfies $\\,\\dot{\\mathbf{q}}=\\tfrac{1}{2}E(\\mathbf{q})\\boldsymbol{\\omega}\\,$ for angular velocity $\\,\\boldsymbol{\\omega}\\,$; use this to express $\\,\\nabla_{\\mathbf{q}} g(\\mathbf{q})\\,$ in a closed form.\n\nYou must implement a complete program that:\n1. Normalizes any input quaternion $\\,\\mathbf{q}\\,$ to unit length and any input body-fixed direction $\\,\\hat{\\mathbf{n}}\\,$ to unit length.\n2. Computes $\\,R(\\mathbf{q})\\,$ from the normalized quaternion.\n3. Computes the constraint torque $\\,\\boldsymbol{\\tau}_c(\\mathbf{q},\\lambda)\\,$ and the quaternion gradient $\\,\\nabla_{\\mathbf{q}} g(\\mathbf{q})\\,$ according to your derivation.\n4. For each test case in the test suite below, outputs the magnitude $\\,\\|\\boldsymbol{\\tau}_c\\|\\,$ in N·m, rounded to six decimal places.\n\nUse the following test suite of parameter values:\n- Test case 1 (general nontrivial alignment): $\\,\\mathbf{q}=\\big(\\cos(\\pi/8),\\,0,\\,\\sin(\\pi/8),\\,0\\big),\\ \\hat{\\mathbf{n}}=(0,0,1),\\ c=0.7,\\ \\lambda=1.0\\,$.\n- Test case 2 (boundary alignment, zero torque direction): $\\,\\mathbf{q}=(1,0,0,0),\\ \\hat{\\mathbf{n}}=(0,0,1),\\ c=1.0,\\ \\lambda=5.0\\,$.\n- Test case 3 (unnormalized quaternion, off-axis body direction): $\\,\\mathbf{q}=(0.9,0.3,0.1,0.1),\\ \\hat{\\mathbf{n}}=(1,0,0),\\ c=0.0,\\ \\lambda=2.0\\,$.\n- Test case 4 (antialignment, zero torque direction): $\\,\\mathbf{q}=(0,1,0,0),\\ \\hat{\\mathbf{n}}=(0,0,1),\\ c=-1.0,\\ \\lambda=3.0\\,$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Specifically, output the four torque magnitudes for the test cases in the order listed above, each rounded to six decimal places, for example $\\,\\big[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4\\big]\\,$.", "solution": "The problem statement has been validated and is deemed scientifically grounded, well-posed, and objective. It contains a complete and consistent setup for a standard problem in constrained rigid-body dynamics.\n\nThe task is to derive expressions for the constraint torque $\\boldsymbol{\\tau}_c$ and the quaternion gradient of the constraint function $\\nabla_{\\mathbf{q}} g(\\mathbf{q})$, and then to implement these to calculate the magnitude of the torque for several test cases. All mathematical derivations and procedures will be presented from first principles as requested.\n\n### Derivation of the Constraint Torque $\\boldsymbol{\\tau}_c$\n\nThe constraint is given by the holonomic equation $g(\\mathbf{q}) = \\hat{\\mathbf{e}}_z \\cdot R(\\mathbf{q})\\hat{\\mathbf{n}} - c = 0$. The generalized force (in this case, torque) associated with this constraint can be derived using the principle of virtual work. The virtual work $\\delta W_c$ done by the constraint torque $\\boldsymbol{\\tau}_c$ under an infinitesimal virtual rotation $\\delta\\boldsymbol{\\theta}$ (expressed in the space frame) is:\n$$\n\\delta W_c = \\boldsymbol{\\tau}_c \\cdot \\delta\\boldsymbol{\\theta}\n$$\nAccording to the method of Lagrange multipliers, this virtual work is also given by $\\delta W_c = -\\lambda \\delta g$, where $\\lambda$ is the Lagrange multiplier and $\\delta g$ is the variation of the constraint function.\nWe calculate $\\delta g$ by taking the variation of $g(\\mathbf{q})$:\n$$\n\\delta g = \\delta (\\hat{\\mathbf{e}}_z \\cdot R(\\mathbf{q})\\hat{\\mathbf{n}} - c) = \\hat{\\mathbf{e}}_z \\cdot (\\delta R(\\mathbf{q})) \\hat{\\mathbf{n}}\n$$\nas $\\hat{\\mathbf{e}}_z$, $\\hat{\\mathbf{n}}$, and $c$ are constants.\n\nAn infinitesimal rotation $\\delta\\boldsymbol{\\theta}$ in the space frame induces a change in the rotation matrix $R$ given by $\\delta R = [\\delta\\boldsymbol{\\theta}]_{\\times} R$, where $[\\mathbf{v}]_{\\times}$ is the skew-symmetric matrix corresponding to the cross product operator such that $[\\mathbf{v}]_{\\times}\\mathbf{u} = \\mathbf{v} \\times \\mathbf{u}$. Substituting this into the expression for $\\delta g$:\n$$\n\\delta g = \\hat{\\mathbf{e}}_z \\cdot ([\\delta\\boldsymbol{\\theta}]_{\\times} R(\\mathbf{q})\\hat{\\mathbf{n}}) = \\hat{\\mathbf{e}}_z \\cdot (\\delta\\boldsymbol{\\theta} \\times (R(\\mathbf{q})\\hat{\\mathbf{n}}))\n$$\nUsing the scalar triple product identity $\\mathbf{a} \\cdot (\\mathbf{b} \\times \\mathbf{c}) = \\mathbf{b} \\cdot (\\mathbf{c} \\times \\mathbf{a})$, we get:\n$$\n\\delta g = \\delta\\boldsymbol{\\theta} \\cdot (R(\\mathbf{q})\\hat{\\mathbf{n}} \\times \\hat{\\mathbf{e}}_z)\n$$\nNow, we equate the two expressions for the virtual work:\n$$\n\\boldsymbol{\\tau}_c \\cdot \\delta\\boldsymbol{\\theta} = -\\lambda \\, \\delta g = -\\lambda \\, \\delta\\boldsymbol{\\theta} \\cdot (R(\\mathbf{q})\\hat{\\mathbf{n}} \\times \\hat{\\mathbf{e}}_z)\n$$\nThis equality must hold for any arbitrary virtual rotation $\\delta\\boldsymbol{\\theta}$. Therefore, we can equate the vector coefficients:\n$$\n\\boldsymbol{\\tau}_c = -\\lambda (R(\\mathbf{q})\\hat{\\mathbf{n}} \\times \\hat{\\mathbf{e}}_z) = \\lambda (\\hat{\\mathbf{e}}_z \\times R(\\mathbf{q})\\hat{\\mathbf{n}})\n$$\nThis is the expression for the constraint torque in the space frame. Its magnitude is $\\|\\boldsymbol{\\tau}_c\\| = |\\lambda| \\|\\hat{\\mathbf{e}}_z \\times R(\\mathbf{q})\\hat{\\mathbf{n}}\\|$. Since $\\hat{\\mathbf{e}}_z$ and $\\hat{\\mathbf{n}}$ are unit vectors and $R(\\mathbf{q})$ is a rotation, $R(\\mathbf{q})\\hat{\\mathbf{n}}$ is also a unit vector. The magnitude simplifies to $\\|\\boldsymbol{\\tau}_c\\| = |\\lambda| \\sqrt{1 - (\\hat{\\mathbf{e}}_z \\cdot R(\\mathbf{q})\\hat{\\mathbf{n}})^2}$.\n\n### Derivation of the Quaternion Gradient $\\nabla_{\\mathbf{q}} g(\\mathbf{q})$\n\nThe gradient of the scalar function $g(\\mathbf{q})$ with respect to the quaternion $\\mathbf{q} \\in \\mathbb{R}^4$ relates the variation $\\delta g$ to the quaternion variation $\\delta\\mathbf{q}$:\n$$\n\\delta g = (\\nabla_{\\mathbf{q}} g)^T \\delta\\mathbf{q}\n$$\nThe problem provides the quaternion kinematic equation relating the time derivative of the quaternion, $\\dot{\\mathbf{q}}$, to the body-frame angular velocity $\\boldsymbol{\\omega}_b$:\n$$\n\\dot{\\mathbf{q}} = \\frac{1}{2}E(\\mathbf{q})\\boldsymbol{\\omega}_b\n$$\nFor an infinitesimal time step $\\delta t$, the variations are related by $\\delta\\mathbf{q} = \\dot{\\mathbf{q}}\\delta t$ and $\\delta\\boldsymbol{\\theta}_s = \\boldsymbol{\\omega}_s \\delta t$, where $\\boldsymbol{\\omega}_s$ is the angular velocity in the space frame. The space- and body-frame angular velocities are related by $\\boldsymbol{\\omega}_s = R(\\mathbf{q})\\boldsymbol{\\omega}_b$, or $\\boldsymbol{\\omega}_b = R(\\mathbf{q})^T\\boldsymbol{\\omega}_s$.\nSubstituting this into the expression for $\\delta\\mathbf{q}$:\n$$\n\\delta\\mathbf{q} = \\frac{1}{2} E(\\mathbf{q}) (R(\\mathbf{q})^T \\boldsymbol{\\omega}_s) \\delta t = \\frac{1}{2} E(\\mathbf{q}) R(\\mathbf{q})^T \\delta\\boldsymbol{\\theta}_s\n$$\nSubstituting this into the gradient relation for $\\delta g$:\n$$\n\\delta g = (\\nabla_{\\mathbf{q}} g)^T \\left( \\frac{1}{2} E(\\mathbf{q}) R(\\mathbf{q})^T \\delta\\boldsymbol{\\theta}_s \\right) = \\frac{1}{2} (\\nabla_{\\mathbf{q}} g)^T E(\\mathbf{q}) R(\\mathbf{q})^T \\delta\\boldsymbol{\\theta}_s\n$$\nWe previously found that $\\delta g = (R(\\mathbf{q})\\hat{\\mathbf{n}} \\times \\hat{\\mathbf{e}}_z)^T \\delta\\boldsymbol{\\theta}_s$. Comparing the two expressions for $\\delta g$, we identify the coefficients of $\\delta\\boldsymbol{\\theta}_s$:\n$$\n(R(\\mathbf{q})\\hat{\\mathbf{n}} \\times \\hat{\\mathbf{e}}_z)^T = \\frac{1}{2} (\\nabla_{\\mathbf{q}} g)^T E(\\mathbf{q}) R(\\mathbf{q})^T\n$$\nTaking the transpose of both sides:\n$$\nR(\\mathbf{q})\\hat{\\mathbf{n}} \\times \\hat{\\mathbf{e}}_z = \\frac{1}{2} R(\\mathbf{q}) E(\\mathbf{q})^T \\nabla_{\\mathbf{q}} g\n$$\nTo solve for $\\nabla_{\\mathbf{q}} g$, we multiply by $R(\\mathbf{q})^T$ from the left and use the orthogonality of $R(\\mathbf{q})$:\n$$\nR(\\mathbf{q})^T(R(\\mathbf{q})\\hat{\\mathbf{n}} \\times \\hat{\\mathbf{e}}_z) = \\frac{1}{2} E(\\mathbf{q})^T \\nabla_{\\mathbf{q}} g\n$$\nThis equation relates a $3$-vector to a projection of the $4$-vector $\\nabla_{\\mathbf{q}} g$. We need an additional condition. Since $\\mathbf{q}$ is a unit quaternion, any valid variation $\\delta\\mathbf{q}$ must be orthogonal to $\\mathbf{q}$ (i.e., $\\mathbf{q}^T\\delta\\mathbf{q}=0$). Consequently, the physically meaningful component of $\\nabla_{\\mathbf{q}} g$ must also be orthogonal to $\\mathbf{q}$. The matrix $E(\\mathbf{q})$ has the property that its columns are orthogonal to $\\mathbf{q}$ ($E(\\mathbf{q})^T\\mathbf{q} = \\mathbf{0}$). Therefore, $\\nabla_{\\mathbf{q}} g$ must lie in the column space of $E(\\mathbf{q})$, so $\\nabla_{\\mathbf{q}} g = E(\\mathbf{q})\\mathbf{u}$ for some vector $\\mathbf{u} \\in \\mathbb{R}^3$.\nSubstituting this into our equation:\n$$\nR(\\mathbf{q})^T(R(\\mathbf{q})\\hat{\\mathbf{n}} \\times \\hat{\\mathbf{e}}_z) = \\frac{1}{2} E(\\mathbf{q})^T (E(\\mathbf{q})\\mathbf{u}) = \\frac{1}{2} (E(\\mathbf{q})^T E(\\mathbf{q})) \\mathbf{u}\n$$\nFor a unit quaternion, $E(\\mathbf{q})^T E(\\mathbf{q}) = \\|\\mathbf{q}\\|^2 I_{3\\times3} = I_{3\\times3}$. Thus, we can solve for $\\mathbf{u}$:\n$$\n\\mathbf{u} = 2 R(\\mathbf{q})^T (R(\\mathbf{q})\\hat{\\mathbf{n}} \\times \\hat{\\mathbf{e}}_z)\n$$\nFinally, substituting $\\mathbf{u}$ back into the expression for $\\nabla_{\\mathbf{q}} g$:\n$$\n\\nabla_{\\mathbf{q}} g(\\mathbf{q}) = 2 E(\\mathbf{q}) R(\\mathbf{q})^T (R(\\mathbf{q})\\hat{\\mathbf{n}} \\times \\hat{\\mathbf{e}}_z)\n$$\nThis is the closed-form expression for the quaternion gradient.\n\n### Computational Procedure\nFor each test case, the following steps are performed:\n1.  The input quaternion $\\mathbf{q}_{in}$ and body-fixed vector $\\hat{\\mathbf{n}}_{in}$ are normalized to unit length to get $\\mathbf{q}$ and $\\hat{\\mathbf{n}}$.\n2.  The rotation matrix $R(\\mathbf{q})$ is constructed from the components of the normalized quaternion $\\mathbf{q} = (q_0, q_1, q_2, q_3)^T$:\n    $$\n    R(\\mathbf{q}) = \\begin{pmatrix}\n    q_0^2 + q_1^2 - q_2^2 - q_3^2 & 2(q_1q_2 - q_0q_3) & 2(q_1q_3 + q_0q_2) \\\\\n    2(q_1q_2 + q_0q_3) & q_0^2 - q_1^2 + q_2^2 - q_3^2 & 2(q_2q_3 - q_0q_1) \\\\\n    2(q_1q_3 - q_0q_2) & 2(q_2q_3 + q_0q_1) & q_0^2 - q_1^2 - q_2^2 + q_3^2\n    \\end{pmatrix}\n    $$\n3.  The rotated body vector $\\mathbf{v}_s = R(\\mathbf{q})\\hat{\\mathbf{n}}$ is computed.\n4.  The space-frame constraint torque is calculated using the derived formula: $\\boldsymbol{\\tau}_c = \\lambda (\\hat{\\mathbf{e}}_z \\times \\mathbf{v}_s)$, where $\\hat{\\mathbf{e}}_z=(0,0,1)^T$.\n5.  The Euclidean norm (magnitude) $\\|\\boldsymbol{\\tau}_c\\|$ is computed and stored.\n6.  The program outputs the list of torque magnitudes, each rounded to six decimal places.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by calculating the constraint torque magnitude for each test case.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Format: (quaternion, body_vector_n, constant_c, lambda)\n    test_cases = [\n        ((np.cos(np.pi/8), 0, np.sin(np.pi/8), 0), (0, 0, 1), 0.7, 1.0),\n        ((1, 0, 0, 0), (0, 0, 1), 1.0, 5.0),\n        ((0.9, 0.3, 0.1, 0.1), (1, 0, 0), 0.0, 2.0),\n        ((0, 1, 0, 0), (0, 0, 1), -1.0, 3.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        q_in, n_in, c, lambda_val = case\n        \n        # The constant c is part of the constraint g(q)=0 definition but does not\n        # enter the expression for the torque, which depends on the gradient of g.\n        \n        # 1. Normalize quaternion and body-fixed vector\n        q_in = np.array(q_in, dtype=float)\n        q = q_in / np.linalg.norm(q_in)\n\n        n_in = np.array(n_in, dtype=float)\n        norm_n = np.linalg.norm(n_in)\n        # Avoid division by zero if n_in is a zero vector, though not in test cases.\n        n = n_in / norm_n if norm_n > 0 else n_in\n\n        # 2. Compute rotation matrix R(q) from the normalized quaternion\n        q0, q1, q2, q3 = q[0], q[1], q[2], q[3]\n\n        R = np.array([\n            [q0**2 + q1**2 - q2**2 - q3**2, 2*(q1*q2 - q0*q3), 2*(q1*q3 + q0*q2)],\n            [2*(q1*q2 + q0*q3), q0**2 - q1**2 + q2**2 - q3**2, 2*(q2*q3 - q0*q1)],\n            [2*(q1*q3 - q0*q2), 2*(q2*q3 + q0*q1), q0**2 - q1**2 - q2**2 + q3**2]\n        ])\n        \n        # 3. Compute rotated vector and constraint torque\n        e_z = np.array([0.0, 0.0, 1.0])\n        v_s = R @ n\n        \n        # From derivation: tau_c = lambda * (e_z x R*n)\n        tau_c = lambda_val * np.cross(e_z, v_s)\n        \n        # 4. Compute the magnitude of the torque\n        tau_c_magnitude = np.linalg.norm(tau_c)\n        results.append(f\"{tau_c_magnitude:.6f}\")\n\n        # The problem also asks for the derivation of the quaternion gradient,\n        # but not for its computation in the output. The derived formula is:\n        # grad_g = 2 * E(q) * R(q)^T * (R(q)n x e_z)\n        # The following lines could be uncommented to compute it.\n        # E = np.array([\n        #     [-q1, -q2, -q3],\n        #     [ q0, -q3,  q2],\n        #     [ q3,  q0, -q1],\n        #     [-q2,  q1,  q0]\n        # ])\n        # grad_g = 2 * E @ R.T @ np.cross(v_s, e_z)\n\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3442479"}, {"introduction": "Real-world molecular systems often consist of multiple domains whose movements are correlated. This advanced practice [@problem_id:3442432] extends the concept of constraints to a multi-body problem, challenging you to link the relative orientation of two rigid bodies. You will implement a stabilized holonomic constraint, a robust technique used in modern molecular dynamics engines, to dynamically compute the interaction torques that maintain a prescribed geometric relationship between the domains.", "problem": "Consider two rigid domains in a Molecular Dynamics (MD) simulation of a polymer. Each domain is modeled as a rigid body whose orientation is represented by a unit quaternion $q \\in \\mathbb{H}$, and the corresponding rotation matrix $R(q) \\in \\mathbb{R}^{3 \\times 3}$. Let $\\hat{\\mathbf{n}}_1 \\in \\mathbb{R}^3$ and $\\hat{\\mathbf{n}}_2 \\in \\mathbb{R}^3$ be fixed unit vectors embedded in the body frames of domain $1$ and domain $2$, respectively. Define the holonomic scalar constraint linking the orientations of the two domains by\n$$\ng(\\mathbf{q}_1,\\mathbf{q}_2) = \\hat{\\mathbf{n}}_1^\\top R(\\mathbf{q}_1)^\\top R(\\mathbf{q}_2)\\,\\hat{\\mathbf{n}}_2 - c,\n$$\nwhere $c \\in [-1,1]$ is a specified constant. The world-frame images of the embedded directions are $\\mathbf{a}_1 = R(\\mathbf{q}_1)\\,\\hat{\\mathbf{n}}_1$ and $\\mathbf{a}_2 = R(\\mathbf{q}_2)\\,\\hat{\\mathbf{n}}_2$, so the constraint simplifies to $g = \\mathbf{a}_1^\\top \\mathbf{a}_2 - c$.\n\nStarting from first principles suitable for rigid body dynamics with quaternion representations, namely:\n- Newton–Euler rotational dynamics with rotational inertia $I \\in \\mathbb{R}^{3 \\times 3}$ and angular velocity $\\boldsymbol{\\omega} \\in \\mathbb{R}^3$.\n- The kinematic relation for a fixed body-frame vector: if $\\mathbf{a}(t) = R(\\mathbf{q}(t))\\,\\hat{\\mathbf{n}}$, then $\\dot{\\mathbf{a}} = \\boldsymbol{\\omega} \\times \\mathbf{a}$.\n- The definition of unit quaternions and their associated rotation matrices.\n\nDerive expressions for the orientation-constraint forces as torques on each domain using Lagrange multipliers. Assume isotropic rotational inertia for each domain, i.e., $I_1 = \\mathcal{I}_1 \\mathbf{I}_{3}$ and $I_2 = \\mathcal{I}_2 \\mathbf{I}_{3}$, where $\\mathbf{I}_{3}$ is the $3 \\times 3$ identity matrix and $\\mathcal{I}_1,\\mathcal{I}_2 > 0$ are scalars. You must obtain an explicit algorithm to compute the instantaneous constraint Lagrange multiplier $\\lambda$ and the resulting constraint torques $\\boldsymbol{\\tau}_{c,1}$ and $\\boldsymbol{\\tau}_{c,2}$ on domains $1$ and $2$, respectively, given the instantaneous states $(\\mathbf{q}_1,\\mathbf{q}_2,\\boldsymbol{\\omega}_1,\\boldsymbol{\\omega}_2)$ and applied torques $\\boldsymbol{\\tau}_{\\text{app},1}, \\boldsymbol{\\tau}_{\\text{app},2}$. Use a standard stabilization form with parameters $\\alpha$ and $\\beta$ such that the target constraint evolution satisfies $\\ddot{g} + 2\\beta \\dot{g} + \\alpha g = 0$.\n\nYour program must:\n1. Implement the quaternion-to-rotation $R(\\mathbf{q})$ map for unit quaternions.\n2. Compute $\\mathbf{a}_1$, $\\mathbf{a}_2$, and the scalar constraint $g$.\n3. Compute the instantaneous Jacobian acting on angular velocities and the necessary kinematic quantities to evaluate $\\dot{g}$ and $\\ddot{g}$ consistently with the assumed isotropic inertia.\n4. Solve for the scalar Lagrange multiplier $\\lambda$ at the instant using the stabilization parameters $\\alpha$ and $\\beta$ and produce the corresponding constraint torques on the two domains.\n5. Robustly handle degenerate configurations where the instantaneous constraint Jacobian norm is smaller than a specified threshold $\\varepsilon > 0$.\n\nAll angles must be specified in radians. Angular velocities must be in radians per second. Rotational inertias must be in kilogram-square meter. Torques must be in Newton-meter.\n\nTest Suite:\nProvide results for the following three test cases. In each case, the final outputs must be computed strictly from the provided parameters.\n\n- Case A (happy path):\n    - $\\mathbf{q}_1$: identity quaternion.\n    - $\\mathbf{q}_2$: axis-angle rotation about the $z$-axis by $\\theta = \\pi/3$ radians.\n    - $\\hat{\\mathbf{n}}_1 = [1,0,0]^\\top$, $\\hat{\\mathbf{n}}_2 = [1,0,0]^\\top$.\n    - $c = 0.5$.\n    - $\\mathcal{I}_1 = 1.0$, $\\mathcal{I}_2 = 1.0$ (kilogram-square meter).\n    - $\\boldsymbol{\\omega}_1 = [0.0,0.2,0.0]^\\top$ (radians per second), $\\boldsymbol{\\omega}_2 = [0.0,-0.1,0.0]^\\top$ (radians per second).\n    - $\\boldsymbol{\\tau}_{\\text{app},1} = [0.0,0.0,0.0]^\\top$ (Newton-meter), $\\boldsymbol{\\tau}_{\\text{app},2} = [0.0,0.0,0.0]^\\top$ (Newton-meter).\n    - Stabilization parameters: $\\alpha = 50.0$ (per second squared), $\\beta = 5.0$ (per second).\n    - Degeneracy threshold: $\\varepsilon = 10^{-10}$.\n\n- Case B (boundary degeneracy):\n    - $\\mathbf{q}_1$: identity quaternion.\n    - $\\mathbf{q}_2$: identity quaternion.\n    - $\\hat{\\mathbf{n}}_1 = [0,1,0]^\\top$, $\\hat{\\mathbf{n}}_2 = [0,1,0]^\\top$.\n    - $c = 1.0$.\n    - $\\mathcal{I}_1 = 1.0$, $\\mathcal{I}_2 = 2.0$ (kilogram-square meter).\n    - $\\boldsymbol{\\omega}_1 = [0.5,0.0,0.0]^\\top$ (radians per second), $\\boldsymbol{\\omega}_2 = [0.0,0.5,0.0]^\\top$ (radians per second).\n    - $\\boldsymbol{\\tau}_{\\text{app},1} = [0.1,0.0,0.0]^\\top$ (Newton-meter), $\\boldsymbol{\\tau}_{\\text{app},2} = [0.0,0.1,0.0]^\\top$ (Newton-meter).\n    - Stabilization parameters: $\\alpha = 50.0$ (per second squared), $\\beta = 5.0$ (per second).\n    - Degeneracy threshold: $\\varepsilon = 10^{-10}$.\n\n- Case C (general off-alignment with nonzero error):\n    - $\\mathbf{q}_1$: axis-angle rotation about the $x$-axis by $\\theta = \\pi/4$ radians.\n    - $\\mathbf{q}_2$: axis-angle rotation about the $y$-axis by $\\theta = \\pi/6$ radians.\n    - $\\hat{\\mathbf{n}}_1 = [0,1,0]^\\top$, $\\hat{\\mathbf{n}}_2 = [0,0,1]^\\top$.\n    - $c = 0.2$.\n    - $\\mathcal{I}_1 = 0.8$, $\\mathcal{I}_2 = 1.2$ (kilogram-square meter).\n    - $\\boldsymbol{\\omega}_1 = [0.1,0.2,-0.1]^\\top$ (radians per second), $\\boldsymbol{\\omega}_2 = [-0.05,0.0,0.15]^\\top$ (radians per second).\n    - $\\boldsymbol{\\tau}_{\\text{app},1} = [0.0,0.0,0.0]^\\top$ (Newton-meter), $\\boldsymbol{\\tau}_{\\text{app},2} = [0.01,-0.02,0.0]^\\top$ (Newton-meter).\n    - Stabilization parameters: $\\alpha = 100.0$ (per second squared), $\\beta = 10.0$ (per second).\n    - Degeneracy threshold: $\\varepsilon = 10^{-10}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case contributes a list of seven floats in the order $[\\lambda,\\tau_{c,1,x},\\tau_{c,1,y},\\tau_{c,1,z},\\tau_{c,2,x},\\tau_{c,2,y},\\tau_{c,2,z}]$. For example, the output format must be like `[[lambda_A,...],[lambda_B,...],[lambda_C,...]]` printed as a single line with no spaces.", "solution": "The user has provided a valid problem statement grounded in the principles of classical mechanics and multibody dynamics. The problem is well-posed, objective, and contains all necessary information to derive a unique and meaningful solution. The task is to derive and implement an algorithm for computing constraint torques for a holonomic orientation constraint between two rigid bodies, a standard problem in molecular dynamics simulations.\n\nThe derivation and resulting algorithm are presented below, following first principles as requested.\n\n### 1. Constraint and Kinematics\nThe system consists of two rigid domains, whose orientations are given by unit quaternions $\\mathbf{q}_1$ and $\\mathbf{q}_2$, corresponding to rotation matrices $R(\\mathbf{q}_1)$ and $R(\\mathbf{q}_2)$. The holonomic constraint is defined on the relative orientation of two body-fixed unit vectors, $\\hat{\\mathbf{n}}_1$ and $\\hat{\\mathbf{n}}_2$:\n$$\ng(\\mathbf{q}_1,\\mathbf{q}_2) = \\hat{\\mathbf{n}}_1^\\top R(\\mathbf{q}_1)^\\top R(\\mathbf{q}_2)\\,\\hat{\\mathbf{n}}_2 - c = 0\n$$\nwhere $c \\in [-1,1]$ is a constant. Let $\\mathbf{a}_1 = R(\\mathbf{q}_1)\\,\\hat{\\mathbf{n}}_1$ and $\\mathbf{a}_2 = R(\\mathbf{q}_2)\\,\\hat{\\mathbf{n}}_2$ be the world-frame representations of these vectors. The constraint simplifies to:\n$$\ng = \\mathbf{a}_1 \\cdot \\mathbf{a}_2 - c = 0\n$$\nThe kinematic evolution of these world-frame vectors is given by the relation for a body-fixed vector, where $\\boldsymbol{\\omega}_i$ is the angular velocity of body $i$:\n$$\n\\dot{\\mathbf{a}}_i = \\boldsymbol{\\omega}_i \\times \\mathbf{a}_i\n$$\n\n### 2. Derivation of Constraint Torques\nThe constraint torques, $\\boldsymbol{\\tau}_{c,1}$ and $\\boldsymbol{\\tau}_{c,2}$, are derived from the principle that the virtual work done by constraint forces for any virtual displacement consistent with the constraints is zero. For a single scalar constraint $g$, the constraint torques are proportional to the gradient of $g$ with respect to the generalized coordinates for rotation. The generalized force (torque) for body $i$ is $\\boldsymbol{\\tau}_{c,i} = \\lambda \\frac{\\partial g}{\\partial \\boldsymbol{\\theta}_i}$, where $\\delta \\boldsymbol{\\theta}_i$ is an infinitesimal rotation vector.\n\nThe variation of $g$ is:\n$$\n\\delta g = \\frac{\\partial g}{\\partial \\mathbf{a}_1} \\cdot \\delta \\mathbf{a}_1 + \\frac{\\partial g}{\\partial \\mathbf{a}_2} \\cdot \\delta \\mathbf{a}_2 = \\mathbf{a}_2 \\cdot \\delta \\mathbf{a}_1 + \\mathbf{a}_1 \\cdot \\delta \\mathbf{a}_2\n$$\nThe variation in $\\mathbf{a}_i$ due to an infinitesimal rotation $\\delta \\boldsymbol{\\theta}_i$ is $\\delta \\mathbf{a}_i = \\delta \\boldsymbol{\\theta}_i \\times \\mathbf{a}_i$. Substituting this into the expression for $\\delta g$:\n$$\n\\delta g = \\mathbf{a}_2 \\cdot (\\delta \\boldsymbol{\\theta}_1 \\times \\mathbf{a}_1) + \\mathbf{a}_1 \\cdot (\\delta \\boldsymbol{\\theta}_2 \\times \\mathbf{a}_2)\n$$\nUsing the scalar triple product identity $\\mathbf{A} \\cdot (\\mathbf{B} \\times \\mathbf{C}) = (\\mathbf{A} \\times \\mathbf{B}) \\cdot \\mathbf{C}$:\n$$\n\\delta g = (\\mathbf{a}_2 \\times \\mathbf{a}_1) \\cdot \\delta \\boldsymbol{\\theta}_1 + (\\mathbf{a}_1 \\times \\mathbf{a}_2) \\cdot \\delta \\boldsymbol{\\theta}_2 = -(\\mathbf{a}_1 \\times \\mathbf{a}_2) \\cdot \\delta \\boldsymbol{\\theta}_1 + (\\mathbf{a}_1 \\times \\mathbf{a}_2) \\cdot \\delta \\boldsymbol{\\theta}_2\n$$\nThe virtual work done by the constraint torques is $\\delta W_c = \\boldsymbol{\\tau}_{c,1} \\cdot \\delta \\boldsymbol{\\theta}_1 + \\boldsymbol{\\tau}_{c,2} \\cdot \\delta \\boldsymbol{\\theta}_2$. By the principle of virtual work, $\\delta W_c = -\\lambda \\delta g$. Comparing terms, we identify the constraint torques (adopting the convention $\\boldsymbol{\\tau}_c = -\\lambda \\nabla g$):\n$$\n\\boldsymbol{\\tau}_{c,1} = \\lambda (\\mathbf{a}_1 \\times \\mathbf{a}_2)\n$$\n$$\n\\boldsymbol{\\tau}_{c,2} = -\\lambda (\\mathbf{a}_1 \\times \\mathbf{a}_2)\n$$\nThis form is correct and consistent with Newton's third law.\n\n### 3. Equation for the Lagrange Multiplier\nTo find the scalar Lagrange multiplier $\\lambda$, we use the stabilization condition $\\ddot{g} + 2\\beta \\dot{g} + \\alpha g = 0$. This requires expressions for $\\dot{g}$ and $\\ddot{g}$.\n\nThe first time derivative of the constraint is:\n$$\n\\dot{g} = \\frac{d}{dt}(\\mathbf{a}_1 \\cdot \\mathbf{a}_2 - c) = \\dot{\\mathbf{a}}_1 \\cdot \\mathbf{a}_2 + \\mathbf{a}_1 \\cdot \\dot{\\mathbf{a}}_2\n$$\nSubstituting the kinematic relation $\\dot{\\mathbf{a}}_i = \\boldsymbol{\\omega}_i \\times \\mathbf{a}_i$:\n$$\n\\dot{g} = (\\boldsymbol{\\omega}_1 \\times \\mathbf{a}_1) \\cdot \\mathbf{a}_2 + \\mathbf{a}_1 \\cdot (\\boldsymbol{\\omega}_2 \\times \\mathbf{a}_2)\n$$\nUsing the scalar triple product identity, this becomes:\n$$\n\\dot{g} = \\boldsymbol{\\omega}_1 \\cdot (\\mathbf{a}_1 \\times \\mathbf{a}_2) + \\boldsymbol{\\omega}_2 \\cdot (\\mathbf{a}_2 \\times \\mathbf{a}_1) = (\\boldsymbol{\\omega}_1 - \\boldsymbol{\\omega}_2) \\cdot (\\mathbf{a}_1 \\times \\mathbf{a}_2)\n$$\nThe second time derivative is:\n$$\n\\ddot{g} = \\frac{d}{dt}(\\dot{\\mathbf{a}}_1 \\cdot \\mathbf{a}_2 + \\mathbf{a}_1 \\cdot \\dot{\\mathbf{a}}_2) = \\ddot{\\mathbf{a}}_1 \\cdot \\mathbf{a}_2 + \\mathbf{a}_1 \\cdot \\ddot{\\mathbf{a}}_2 + 2(\\dot{\\mathbf{a}}_1 \\cdot \\dot{\\mathbf{a}}_2)\n$$\nThe world-frame vector acceleration $\\ddot{\\mathbf{a}}_i$ is:\n$$\n\\ddot{\\mathbf{a}}_i = \\frac{d}{dt}(\\boldsymbol{\\omega}_i \\times \\mathbf{a}_i) = \\dot{\\boldsymbol{\\omega}}_i \\times \\mathbf{a}_i + \\boldsymbol{\\omega}_i \\times \\dot{\\mathbf{a}}_i = \\dot{\\boldsymbol{\\omega}}_i \\times \\mathbf{a}_i + \\boldsymbol{\\omega}_i \\times (\\boldsymbol{\\omega}_i \\times \\mathbf{a}_i)\n$$\nThe Newton-Euler equations of motion are needed for $\\dot{\\boldsymbol{\\omega}}_i$. For an isotropic inertia tensor $I_i = \\mathcal{I}_i \\mathbf{I}_3$, the equation is $\\mathcal{I}_i \\dot{\\boldsymbol{\\omega}}_i = \\boldsymbol{\\tau}_i$, where $\\boldsymbol{\\tau}_i = \\boldsymbol{\\tau}_{\\text{app},i} + \\boldsymbol{\\tau}_{c,i}$ is the total torque (applied plus constraint). Substituting the constraint torques:\n$$\n\\dot{\\boldsymbol{\\omega}}_1 = \\frac{1}{\\mathcal{I}_1}(\\boldsymbol{\\tau}_{\\text{app},1} + \\lambda (\\mathbf{a}_1 \\times \\mathbf{a}_2))\n$$\n$$\n\\dot{\\boldsymbol{\\omega}}_2 = \\frac{1}{\\mathcal{I}_2}(\\boldsymbol{\\tau}_{\\text{app},2} - \\lambda (\\mathbf{a}_1 \\times \\mathbf{a}_2))\n$$\nNow, substitute these into the expression for $\\ddot{g}$. The result separates into a term linear in $\\lambda$ and a term independent of $\\lambda$.\n$$\n\\ddot{g} = \\ddot{g}_{\\lambda} + \\ddot{g}_0\n$$\nThe term depending on $\\lambda$, $\\ddot{g}_{\\lambda}$, is:\n$$\n\\ddot{g}_{\\lambda} = \\left(\\frac{\\lambda}{\\mathcal{I}_1}(\\mathbf{a}_1 \\times \\mathbf{a}_2) \\times \\mathbf{a}_1\\right) \\cdot \\mathbf{a}_2 + \\left(-\\frac{\\lambda}{\\mathcal{I}_2}(\\mathbf{a}_1 \\times \\mathbf{a}_2) \\times \\mathbf{a}_2\\right) \\cdot \\mathbf{a}_1\n$$\nUsing the scalar triple product, this simplifies to:\n$$\n\\ddot{g}_{\\lambda} = \\frac{\\lambda}{\\mathcal{I}_1}(\\mathbf{a}_1 \\times \\mathbf{a}_2) \\cdot (\\mathbf{a}_1 \\times \\mathbf{a}_2) - \\frac{\\lambda}{\\mathcal{I}_2}(\\mathbf{a}_1 \\times \\mathbf{a}_2) \\cdot (\\mathbf{a}_2 \\times \\mathbf{a}_1) = \\lambda \\left(\\frac{1}{\\mathcal{I}_1} + \\frac{1}{\\mathcal{I}_2}\\right) \\|\\mathbf{a}_1 \\times \\mathbf{a}_2\\|^2\n$$\nLet's define the effective inverse mass for the constraint, $K$:\n$$\nK = \\left(\\frac{1}{\\mathcal{I}_1} + \\frac{1}{\\mathcal{I}_2}\\right) \\|\\mathbf{a}_1 \\times \\mathbf{a}_2\\|^2\n$$\nThe term independent of $\\lambda$, $\\ddot{g}_0$, is the acceleration of the constraint if no constraint force were applied:\n$$\n\\ddot{g}_0 = \\left(\\frac{\\boldsymbol{\\tau}_{\\text{app},1}}{\\mathcal{I}_1} \\times \\mathbf{a}_1\\right) \\cdot \\mathbf{a}_2 + \\left(\\frac{\\boldsymbol{\\tau}_{\\text{app},2}}{\\mathcal{I}_2} \\times \\mathbf{a}_2\\right) \\cdot \\mathbf{a}_1 + [\\boldsymbol{\\omega}_1 \\times (\\boldsymbol{\\omega}_1 \\times \\mathbf{a}_1)] \\cdot \\mathbf{a}_2 + [\\boldsymbol{\\omega}_2 \\times (\\boldsymbol{\\omega}_2 \\times \\mathbf{a}_2)] \\cdot \\mathbf{a}_1 + 2(\\dot{\\mathbf{a}}_1 \\cdot \\dot{\\mathbf{a}}_2)\n$$\nThe stabilization equation $\\ddot{g} + 2\\beta \\dot{g} + \\alpha g = 0$ becomes $K\\lambda + \\ddot{g}_0 + 2\\beta \\dot{g} + \\alpha g = 0$. Solving for $\\lambda$:\n$$\n\\lambda = -\\frac{\\ddot{g}_0 + 2\\beta \\dot{g} + \\alpha g}{K}\n$$\nThis is valid provided $K$ is not zero. A degenerate configuration occurs when $\\mathbf{a}_1$ and $\\mathbf{a}_2$ are parallel or anti-parallel, making $\\|\\mathbf{a}_1 \\times \\mathbf{a}_2\\|^2 = 0$ and thus $K=0$. In such cases, the constraint torque cannot be uniquely determined. The problem requires handling this by checking if $K < \\varepsilon$ for a small threshold $\\varepsilon > 0$. If the condition is met, we set $\\lambda = 0$.\n\n### 4. Algorithm Summary\nThe complete algorithm is as follows:\n1.  Given $\\mathbf{q}_1, \\mathbf{q}_2, \\hat{\\mathbf{n}}_1, \\hat{\\mathbf{n}}_2, c, \\mathcal{I}_1, \\mathcal{I}_2, \\boldsymbol{\\omega}_1, \\boldsymbol{\\omega}_2, \\boldsymbol{\\tau}_{\\text{app},1}, \\boldsymbol{\\tau}_{\\text{app},2}, \\alpha, \\beta, \\varepsilon$.\n2.  Compute rotation matrices $R_1=R(\\mathbf{q}_1)$ and $R_2=R(\\mathbf{q}_2)$.\n3.  Compute world-frame vectors: $\\mathbf{a}_1 = R_1 \\hat{\\mathbf{n}}_1$, $\\mathbf{a}_2 = R_2 \\hat{\\mathbf{n}}_2$.\n4.  Compute the constraint violation: $g = \\mathbf{a}_1 \\cdot \\mathbf{a}_2 - c$.\n5.  Compute the cross product vector, which is central to the calculations: $\\mathbf{v} = \\mathbf{a}_1 \\times \\mathbf{a}_2$.\n6.  Compute the constraint velocity: $\\dot{g} = (\\boldsymbol{\\omega}_1 - \\boldsymbol{\\omega}_2) \\cdot \\mathbf{v}$.\n7.  Compute the effective inverse mass: $K = (\\frac{1}{\\mathcal{I}_1} + \\frac{1}{\\mathcal{I}_2}) (\\mathbf{v} \\cdot \\mathbf{v})$.\n8.  Check for degeneracy: If $K < \\varepsilon$, set $\\lambda=0, \\boldsymbol{\\tau}_{c,1}=\\mathbf{0}, \\boldsymbol{\\tau}_{c,2}=\\mathbf{0}$ and terminate for this case.\n9.  Compute $\\ddot{g}_0$:\n    a. Applied torque term: $\\ddot{g}_{\\text{app}} = (\\frac{1}{\\mathcal{I}_1} \\boldsymbol{\\tau}_{\\text{app},1} - \\frac{1}{\\mathcal{I}_2} \\boldsymbol{\\tau}_{\\text{app},2}) \\cdot \\mathbf{v}$.\n    b. Kinematic term $\\dot{J}\\omega$: $\\ddot{g}_{\\text{kin}} = [\\boldsymbol{\\omega}_1 \\times (\\boldsymbol{\\omega}_1 \\times \\mathbf{a}_1)] \\cdot \\mathbf{a}_2 + [\\boldsymbol{\\omega}_2 \\times (\\boldsymbol{\\omega}_2 \\times \\mathbf{a}_2)] \\cdot \\mathbf{a}_1 + 2 ((\\boldsymbol{\\omega}_1 \\times \\mathbf{a}_1) \\cdot (\\boldsymbol{\\omega}_2 \\times \\mathbf{a}_2))$.\n    c. $\\ddot{g}_0 = \\ddot{g}_{\\text{app}} + \\ddot{g}_{\\text{kin}}$.\n10. Solve for the Lagrange multiplier: $\\lambda = -(\\ddot{g}_0 + 2\\beta \\dot{g} + \\alpha g) / K$.\n11. Compute the constraint torques: $\\boldsymbol{\\tau}_{c,1} = \\lambda \\mathbf{v}$, $\\boldsymbol{\\tau}_{c,2} = -\\lambda \\mathbf{v}$.\n12. Return the results $[\\lambda, \\tau_{c,1,x}, \\tau_{c,1,y}, \\tau_{c,1,z}, \\tau_{c,2,x}, \\tau_{c,2,y}, \\tau_{c,2,z}]$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the given problem for all test cases.\n    \"\"\"\n\n    def axis_angle_to_quaternion(axis, angle):\n        \"\"\"Converts an axis-angle rotation to a unit quaternion (w, x, y, z).\"\"\"\n        axis = np.asarray(axis, dtype=float)\n        norm = np.linalg.norm(axis)\n        if norm < 1e-12:\n            return np.array([1.0, 0.0, 0.0, 0.0])\n        axis = axis / norm\n        half_angle = angle / 2.0\n        s = np.sin(half_angle)\n        return np.array([np.cos(half_angle), axis[0] * s, axis[1] * s, axis[2] * s])\n\n    def quaternion_to_rotation_matrix(q):\n        \"\"\"Converts a unit quaternion (w, x, y, z) to a 3x3 rotation matrix.\"\"\"\n        w, x, y, z = q\n        # Ensure it's a unit quaternion\n        norm_sq = w*w + x*x + y*y + z*z\n        if abs(norm_sq - 1.0) > 1e-9:\n             # Normalize if not unit, though inputs should be\n             norm = np.sqrt(norm_sq)\n             w, x, y, z = w/norm, x/norm, y/norm, z/norm\n\n        R = np.zeros((3, 3))\n        \n        # Using the standard formula for scalar-first quaternions\n        R[0, 0] = 1.0 - 2.0 * (y**2 + z**2)\n        R[0, 1] = 2.0 * (x * y - w * z)\n        R[0, 2] = 2.0 * (x * z + w * y)\n        R[1, 0] = 2.0 * (x * y + w * z)\n        R[1, 1] = 1.0 - 2.0 * (x**2 + z**2)\n        R[1, 2] = 2.0 * (y * z - w * x)\n        R[2, 0] = 2.0 * (x * z - w * y)\n        R[2, 1] = 2.0 * (y * z + w * x)\n        R[2, 2] = 1.0 - 2.0 * (x**2 + y**2)\n        \n        return R\n\n    def calculate_constraint_forces(params):\n        \"\"\"\n        Calculates the Lagrange multiplier and constraint torques for one case.\n        \"\"\"\n        q1_in, q2_in = params['q1'], params['q2']\n        n1_hat, n2_hat = np.array(params['n1_hat']), np.array(params['n2_hat'])\n        c = params['c']\n        I1, I2 = params['I1'], params['I2']\n        inv_I1, inv_I2 = 1.0 / I1, 1.0 / I2\n        omega1, omega2 = np.array(params['omega1']), np.array(params['omega2'])\n        tau_app1, tau_app2 = np.array(params['tau_app1']), np.array(params['tau_app2'])\n        alpha, beta = params['alpha'], params['beta']\n        epsilon = params['epsilon']\n\n        R1 = quaternion_to_rotation_matrix(q1_in)\n        R2 = quaternion_to_rotation_matrix(q2_in)\n\n        a1 = R1 @ n1_hat\n        a2 = R2 @ n2_hat\n\n        # Step 4: Compute constraint value g\n        g = np.dot(a1, a2) - c\n\n        # Step 5: Compute central cross product vector\n        v = np.cross(a1, a2)\n        \n        # Step 6: Compute constraint time derivative g_dot\n        g_dot = np.dot(omega1 - omega2, v)\n        \n        # Step 7: Compute effective inverse mass K\n        K = (inv_I1 + inv_I2) * np.dot(v, v)\n        \n        # Step 8: Degeneracy check\n        if abs(K) < epsilon:\n            return [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n            \n        # Step 9: Compute g_ddot_0\n        # Applied torque term\n        g_ddot_app = (inv_I1 * np.dot(tau_app1, v)) - (inv_I2 * np.dot(tau_app2, v))\n\n        # Kinematic term (quadratic velocity term)\n        a1_dot = np.cross(omega1, a1)\n        a2_dot = np.cross(omega2, a2)\n        \n        g_ddot_kin = (\n            np.dot(np.cross(omega1, a1_dot), a2) +\n            np.dot(np.cross(omega2, a2_dot), a1) +\n            2.0 * np.dot(a1_dot, a2_dot)\n        )\n        \n        g_ddot_0 = g_ddot_app + g_ddot_kin\n\n        # Step 10: Solve for lambda\n        numerator = -(g_ddot_0 + 2.0 * beta * g_dot + alpha * g)\n        lambda_val = numerator / K\n        \n        # Step 11: Compute constraint torques\n        tau_c1 = lambda_val * v\n        tau_c2 = -lambda_val * v\n\n        # Step 12: Collect results\n        result = [lambda_val] + tau_c1.tolist() + tau_c2.tolist()\n        return result\n\n    # Test cases from the problem statement\n    test_cases_params = [\n        # Case A\n        {\n            'q1': np.array([1.0, 0.0, 0.0, 0.0]),\n            'q2': axis_angle_to_quaternion([0, 0, 1], np.pi / 3),\n            'n1_hat': [1.0, 0.0, 0.0], 'n2_hat': [1.0, 0.0, 0.0], 'c': 0.5,\n            'I1': 1.0, 'I2': 1.0,\n            'omega1': [0.0, 0.2, 0.0], 'omega2': [0.0, -0.1, 0.0],\n            'tau_app1': [0.0, 0.0, 0.0], 'tau_app2': [0.0, 0.0, 0.0],\n            'alpha': 50.0, 'beta': 5.0, 'epsilon': 1e-10\n        },\n        # Case B\n        {\n            'q1': np.array([1.0, 0.0, 0.0, 0.0]),\n            'q2': np.array([1.0, 0.0, 0.0, 0.0]),\n            'n1_hat': [0.0, 1.0, 0.0], 'n2_hat': [0.0, 1.0, 0.0], 'c': 1.0,\n            'I1': 1.0, 'I2': 2.0,\n            'omega1': [0.5, 0.0, 0.0], 'omega2': [0.0, 0.5, 0.0],\n            'tau_app1': [0.1, 0.0, 0.0], 'tau_app2': [0.0, 0.1, 0.0],\n            'alpha': 50.0, 'beta': 5.0, 'epsilon': 1e-10\n        },\n        # Case C\n        {\n            'q1': axis_angle_to_quaternion([1, 0, 0], np.pi / 4),\n            'q2': axis_angle_to_quaternion([0, 1, 0], np.pi / 6),\n            'n1_hat': [0.0, 1.0, 0.0], 'n2_hat': [0.0, 0.0, 1.0], 'c': 0.2,\n            'I1': 0.8, 'I2': 1.2,\n            'omega1': [0.1, 0.2, -0.1], 'omega2': [-0.05, 0.0, 0.15],\n            'tau_app1': [0.0, 0.0, 0.0], 'tau_app2': [0.01, -0.02, 0.0],\n            'alpha': 100.0, 'beta': 10.0, 'epsilon': 1e-10\n        }\n    ]\n\n    results = []\n    for params in test_cases_params:\n        result_floats = calculate_constraint_forces(params)\n        results.append(f\"[{','.join(f'{x:.8f}' for x in result_floats)}]\")\n\n    # Format output as a single line string\n    final_output = f\"[{','.join(results)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "3442432"}]}