{"hands_on_practices": [{"introduction": "The stability of a numerical integrator is not an intrinsic property but depends critically on the system it simulates, particularly its fastest timescale of motion. This exercise guides you through a foundational linear stability analysis for the widely used velocity Verlet algorithm, revealing the direct link between a system's fastest vibrational frequency and the maximum allowable time step. By working through the dynamics of a simple harmonic oscillator, you will derive the fundamental rule governing the choice of a stable time step and explore the crucial difference between mere numerical stability and the physical accuracy required for meaningful simulations. [@problem_id:3415676]", "problem": "A one-dimensional high-frequency vibrational mode in Molecular Dynamics (MD) can be modeled as a harmonic oscillator with potential energy $U(x) = \\tfrac{1}{2} k x^{2}$ and mass $m$, where $x$ is the displacement, $k$ is the force constant, and $m$ is the mass. The equation of motion follows from Newton’s second law, $m \\dfrac{d^{2} x}{dt^{2}} = -k x$, which defines the angular frequency $\\omega$ by $\\omega = \\sqrt{k/m}$. Consider the velocity Verlet integrator for numerical time evolution with time step $dt$. The update equations are\n$$x_{n+1} = x_{n} + v_{n} dt + \\tfrac{1}{2} a_{n} dt^{2}, \\quad v_{n+1} = v_{n} + \\tfrac{1}{2} \\big(a_{n} + a_{n+1}\\big) dt,$$\nwhere $a_{n} = -\\omega^{2} x_{n}$ is the acceleration at step $n$.\n\nStarting from these definitions and equations, perform a linear stability analysis of the discrete dynamics to obtain the stability condition that ensures bounded motion of the numerical solution. Then, using that result, determine the maximum time step $dt_{\\max}$ for the following physically realistic parameters:\n- $k = 500\\,\\mathrm{N/m}$,\n- $m = 1.000\\,\\mathrm{amu}$ with the conversion $1\\,\\mathrm{amu} = 1.66053906660 \\times 10^{-27}\\,\\mathrm{kg}$.\n\nExpress $dt_{\\max}$ in femtoseconds and round your answer to four significant figures. Finally, justify why, in practice, one often chooses a time step substantially smaller than the maximum allowed by stability, discussing accuracy considerations for high-frequency modes beyond mere numerical stability.", "solution": "The problem is valid as it is scientifically grounded in the principles of classical mechanics and numerical analysis, is well-posed with a clear objective and sufficient data, and is formulated objectively. The analysis pertains to the stability of the velocity Verlet algorithm, a cornerstone of molecular dynamics simulations.\n\nThe solution proceeds in three parts: first, a linear stability analysis to derive the stability condition; second, the calculation of the maximum stable time step for the given physical parameters; and third, a discussion on why practical time steps are chosen to be smaller than this maximum value.\n\n**1. Linear Stability Analysis**\n\nThe system is a one-dimensional harmonic oscillator with the equation of motion $m \\ddot{x} = -k x$, which can be written as $\\ddot{x} = -\\omega^2 x$, where $\\omega = \\sqrt{k/m}$ is the angular frequency. The acceleration at time step $n$ is $a_n = -\\omega^2 x_n$.\n\nThe velocity Verlet algorithm is given by the update equations:\n$$x_{n+1} = x_{n} + v_{n} dt + \\tfrac{1}{2} a_{n} dt^{2}$$\n$$v_{n+1} = v_{n} + \\tfrac{1}{2} \\big(a_{n} + a_{n+1}\\big) dt$$\n\nTo perform a stability analysis, we express the state of the system at step $n+1$, represented by the vector $\\mathbf{z}_{n+1} = \\begin{pmatrix} x_{n+1} \\\\ v_{n+1} \\end{pmatrix}$, as a linear transformation of the state at step $n$, $\\mathbf{z}_{n} = \\begin{pmatrix} x_{n} \\\\ v_{n} \\end{pmatrix}$. This defines the transfer matrix $\\mathbf{T}$ such that $\\mathbf{z}_{n+1} = \\mathbf{T} \\mathbf{z}_{n}$.\n\nFirst, we substitute $a_n = -\\omega^2 x_n$ into the position update equation:\n$$x_{n+1} = x_{n} + v_{n} dt - \\tfrac{1}{2} \\omega^{2} x_{n} dt^{2} = \\left(1 - \\tfrac{1}{2}\\omega^2 dt^2\\right) x_n + v_n dt$$\n\nNext, we express $v_{n+1}$ in terms of $x_n$ and $v_n$. We use $a_{n+1} = -\\omega^2 x_{n+1}$ in the velocity update equation:\n$$v_{n+1} = v_{n} + \\tfrac{1}{2} \\left(-\\omega^2 x_n - \\omega^2 x_{n+1}\\right) dt = v_n - \\tfrac{1}{2} \\omega^2 dt (x_n + x_{n+1})$$\nSubstituting the expression for $x_{n+1}$:\n$$v_{n+1} = v_n - \\tfrac{1}{2} \\omega^2 dt \\left(x_n + \\left(1 - \\tfrac{1}{2}\\omega^2 dt^2\\right) x_n + v_n dt\\right)$$\n$$v_{n+1} = v_n - \\tfrac{1}{2} \\omega^2 dt \\left(\\left(2 - \\tfrac{1}{2}\\omega^2 dt^2\\right) x_n + v_n dt\\right)$$\n$$v_{n+1} = -\\omega^2 dt \\left(1 - \\tfrac{1}{4}\\omega^2 dt^2\\right) x_n + \\left(1 - \\tfrac{1}{2}\\omega^2 dt^2\\right) v_n$$\n\nWe can now write the system in matrix form:\n$$\\begin{pmatrix} x_{n+1} \\\\ v_{n+1} \\end{pmatrix} = \\begin{pmatrix} 1 - \\tfrac{1}{2}\\omega^2 dt^2  dt \\\\ -\\omega^2 dt \\left(1 - \\tfrac{1}{4}\\omega^2 dt^2\\right)  1 - \\tfrac{1}{2}\\omega^2 dt^2 \\end{pmatrix} \\begin{pmatrix} x_n \\\\ v_n \\end{pmatrix}$$\n\nThe transfer matrix is:\n$$\\mathbf{T} = \\begin{pmatrix} 1 - \\tfrac{1}{2}\\omega^2 dt^2  dt \\\\ -\\omega^2 dt \\left(1 - \\tfrac{1}{4}\\omega^2 dt^2\\right)  1 - \\tfrac{1}{2}\\omega^2 dt^2 \\end{pmatrix}$$\n\nFor the numerical solution to remain bounded (stable), the magnitudes of the eigenvalues $\\lambda$ of $\\mathbf{T}$ must not exceed $1$, i.e., $|\\lambda| \\le 1$. The eigenvalues are the roots of the characteristic equation $\\det(\\mathbf{T} - \\lambda \\mathbf{I}) = 0$. Let $A = 1 - \\tfrac{1}{2}\\omega^2 dt^2$.\n$$\\det \\begin{pmatrix} A - \\lambda  dt \\\\ -\\omega^2 dt \\left(1 - \\tfrac{1}{4}\\omega^2 dt^2\\right)  A - \\lambda \\end{pmatrix} = 0$$\n$$(A - \\lambda)^2 + \\omega^2 dt^2 \\left(1 - \\tfrac{1}{4}\\omega^2 dt^2\\right) = 0$$\n$$\\lambda^2 - 2A\\lambda + A^2 + \\omega^2 dt^2 - \\tfrac{1}{4}\\omega^4 dt^4 = 0$$\nNote that $\\det(\\mathbf{T}) = A^2 + \\omega^2 dt^2 (1 - \\tfrac{1}{4}\\omega^2 dt^2) = (1-\\tfrac{1}{2}\\omega^2 dt^2)^2 + \\omega^2 dt^2 - \\tfrac{1}{4}\\omega^4 dt^4 = 1 - \\omega^2 dt^2 + \\tfrac{1}{4}\\omega^4 dt^4 + \\omega^2 dt^2 - \\tfrac{1}{4}\\omega^4 dt^4 = 1$. Since the product of the eigenvalues is $1$, instability arises if $|\\lambda| > 1$ for one eigenvalue (and thus $|\\lambda|  1$ for the other). Stability requires the eigenvalues to be complex conjugates on the unit circle. This occurs when the discriminant of the quadratic characteristic equation is non-positive.\nThe roots are $\\lambda = A \\pm \\sqrt{A^2 - \\det(\\mathbf{T})} = A \\pm \\sqrt{A^2-1}$.\nFor complex roots, we need $A^2 - 1 \\le 0$, which means $|A| \\le 1$.\n$$|1 - \\tfrac{1}{2}\\omega^2 dt^2| \\le 1$$\nThis inequality splits into two conditions:\n1) $1 - \\tfrac{1}{2}\\omega^2 dt^2 \\le 1 \\implies -\\tfrac{1}{2}\\omega^2 dt^2 \\le 0$, which is always true since $\\omega^2 > 0$ and $dt^2 > 0$.\n2) $1 - \\tfrac{1}{2}\\omega^2 dt^2 \\ge -1 \\implies 2 \\ge \\tfrac{1}{2}\\omega^2 dt^2 \\implies 4 \\ge \\omega^2 dt^2$.\nSince $\\omega > 0$ and $dt > 0$, we take the square root:\n$$\\omega dt \\le 2$$\nThis is the stability condition for the velocity Verlet integrator applied to a harmonic oscillator.\n\n**2. Calculation of the Maximum Time Step**\n\nThe stability condition $\\omega dt \\le 2$ gives the maximum allowed time step as $dt_{\\max} = \\frac{2}{\\omega}$. We are given the physical parameters to calculate this value.\n- $k = 500 \\, \\mathrm{N/m} = 500 \\, \\mathrm{kg/s^2}$\n- $m = 1.000 \\, \\mathrm{amu}$\n- $1 \\, \\mathrm{amu} = 1.66053906660 \\times 10^{-27} \\, \\mathrm{kg}$\n\nFirst, we calculate the mass in SI units:\n$$m = 1.000 \\times (1.66053906660 \\times 10^{-27} \\, \\mathrm{kg}) = 1.66053906660 \\times 10^{-27} \\, \\mathrm{kg}$$\n\nNext, we calculate the angular frequency $\\omega$:\n$$\\omega = \\sqrt{\\frac{k}{m}} = \\sqrt{\\frac{500 \\, \\mathrm{kg/s^2}}{1.66053906660 \\times 10^{-27} \\, \\mathrm{kg}}}$$\n$$\\omega \\approx \\sqrt{3.01106031 \\times 10^{29} \\, \\mathrm{s}^{-2}} \\approx 5.48731305 \\times 10^{14} \\, \\mathrm{s}^{-1}$$\n\nNow, we calculate the maximum time step $dt_{\\max}$:\n$$dt_{\\max} = \\frac{2}{\\omega} = \\frac{2}{5.48731305 \\times 10^{14} \\, \\mathrm{s}^{-1}} \\approx 3.644743 \\times 10^{-15} \\, \\mathrm{s}$$\n\nFinally, we convert the result to femtoseconds ($1 \\, \\mathrm{fs} = 10^{-15} \\, \\mathrm{s}$) and round to four significant figures:\n$$dt_{\\max} \\approx 3.644743 \\, \\mathrm{fs}$$\n$$dt_{\\max} \\approx 3.645 \\, \\mathrm{fs}$$\n\n**3. Justification for Using a Smaller Time Step**\n\nThe stability condition $\\omega dt \\le 2$ only ensures that the numerical trajectory does not diverge exponentially; it does not guarantee accuracy. In practice, molecular dynamics simulations must accurately reproduce the physical dynamics, which imposes a much stricter constraint on the time step $dt$.\n\nThe primary measure of accuracy for an oscillator is how well the numerical integration conserves energy and reproduces the correct frequency of oscillation. Although the velocity Verlet algorithm is symplectic and exhibits excellent long-term energy conservation, it introduces a phase error that depends on the size of the time step. This error manifests as a shift in the oscillation frequency.\n\nThe frequency of the numerical oscillator, $\\omega_{\\text{num}}$, can be related to the true frequency $\\omega$ from the eigenvalues of the transfer matrix. The eigenvalues are $\\lambda = e^{\\pm i \\omega_{\\text{num}} dt}$. The real part is $\\Re(\\lambda) = \\cos(\\omega_{\\text{num}} dt)$. From our analysis, $\\Re(\\lambda) = A = 1 - \\tfrac{1}{2}(\\omega dt)^2$.\nThus, we have the relation:\n$$\\cos(\\omega_{\\text{num}} dt) = 1 - \\tfrac{1}{2}(\\omega dt)^2$$\nFor small values of its argument $x$, the cosine function can be expanded as $\\cos(x) \\approx 1 - x^2/2 + x^4/24$. Applying this to both sides gives:\n$$1 - \\frac{(\\omega_{\\text{num}} dt)^2}{2} + \\frac{(\\omega_{\\text{num}} dt)^4}{24} \\approx 1 - \\frac{(\\omega dt)^2}{2}$$\nFor small $dt$, $\\omega_{\\text{num}} \\approx \\omega$. Substituting this into the fourth-order term, we can solve for a more accurate expression for $\\omega_{\\text{num}}$:\n$$\\frac{(\\omega_{\\text{num}} dt)^2}{2} \\approx \\frac{(\\omega dt)^2}{2} + \\frac{(\\omega dt)^4}{24}$$\n$$\\omega_{\\text{num}}^2 \\approx \\omega^2 \\left(1 + \\frac{(\\omega dt)^2}{12}\\right)$$\n$$\\omega_{\\text{num}} \\approx \\omega \\left(1 + \\frac{(\\omega dt)^2}{24}\\right)$$\nThis means $\\omega_{\\text{num}} > \\omega$, so the numerical oscillator is slightly *faster* than the real one, leading to an increasing phase lead over time. The relative error in frequency, $\\frac{\\omega_{\\text{num}} - \\omega}{\\omega} \\approx \\frac{1}{24}(\\omega dt)^2$, scales quadratically with the product $\\omega dt$.\n\nAt the stability limit where $\\omega dt = 2$, the relation becomes $\\cos(\\omega_{\\text{num}} dt) = 1 - \\frac{1}{2}(2^2) = -1$. This implies $\\omega_{\\text{num}} dt = \\pi$, so $\\omega_{\\text{num}} = \\frac{\\pi}{dt} = \\frac{\\pi}{2/\\omega} = \\frac{\\pi}{2}\\omega \\approx 1.57 \\omega$. This is a frequency error of over 50%, which is unacceptably large for any physical simulation.\n\nTo maintain high fidelity, the error in frequency must be kept small. For instance, to keep the relative frequency error below $1\\%$ ($0.01$), we would need:\n$$\\frac{1}{24}(\\omega dt)^2 \\lesssim 0.01$$\n$$(\\omega dt)^2 \\lesssim 0.24 \\implies \\omega dt \\lesssim \\sqrt{0.24} \\approx 0.49$$\nThis condition, $\\omega dt \\lesssim 0.5$, is four times more restrictive than the stability condition $\\omega dt \\le 2$. This implies that the timestep must be at least four times smaller than $dt_{\\max}$.\n\nA general rule of thumb in MD is to use a time step that is at least an order of magnitude smaller than the period of the fastest vibrational mode in the system ($T = 2\\pi/\\omega$). This corresponds to $dt \\approx T/10 = (2\\pi/\\omega)/10 = (\\pi/5)/\\omega \\approx 0.628/\\omega$. This choice, $dt \\approx 0.6/\\omega$, ensures that the fastest oscillation is sampled multiple times per cycle, leading to an accurate integration of its dynamics and maintaining acceptable energy conservation and phase accuracy. For the system in this problem, this practical rule would suggest a timestep of $dt \\approx \\frac{0.628}{5.487 \\times 10^{14}} \\approx 1.14 \\, \\mathrm{fs}$, which is substantially smaller than $dt_{\\max}=3.645 \\, \\mathrm{fs}$.\n\nIn summary, numerical stability is merely the threshold to prevent a simulation from exploding. Accurate and physically meaningful results require a much smaller time step to minimize the integration errors, particularly the phase error for high-frequency modes.", "answer": "$$\\boxed{3.645}$$", "id": "3415676"}, {"introduction": "Theoretical analysis provides essential guidance, but observing a principle in action builds powerful intuition. In this practice, you will move from pen-and-paper analysis to computation by building a small simulation to empirically locate the \"breaking point\" of the Verlet integrator. By systematically increasing the time step, $dt$, for a system containing a stiff bond, you will connect the abstract stability condition to concrete, observable failures like exploding energy, thereby solidifying your understanding of why this limit is so critical in practice. [@problem_id:3415667]", "problem": "Construct a fully specified program that empirically locates the critical time step at which high-frequency modes destabilize a simple molecular dynamics system by scanning time step values and evaluating stability diagnostics. Work entirely in reduced units where mass $m$, Boltzmann constant $k_{\\mathrm{B}}$, and characteristic length and energy scales are all equal to $1$, so no physical units are required.\n\nConsider a one-dimensional system of two identical point particles with mass $m = 1$, positions $x_0(t)$ and $x_1(t)$, and velocities $v_0(t)$ and $v_1(t)$. The pair is connected by a harmonic bond with spring constant $k_b$ and zero rest length, and each particle is tethered to the origin by a harmonic spring with spring constant $k_t$. The total potential energy is\n$$\nU(x_0,x_1) = \\tfrac{1}{2} k_t x_0^2 + \\tfrac{1}{2} k_t x_1^2 + \\tfrac{1}{2} k_b (x_1 - x_0)^2.\n$$\nFrom Newton's second law, the total forces on particle $0$ and particle $1$ are\n$$\nF_0 = -\\frac{\\partial U}{\\partial x_0} = -k_t x_0 + k_b (x_1 - x_0), \\quad F_1 = -\\frac{\\partial U}{\\partial x_1} = -k_t x_1 - k_b (x_1 - x_0).\n$$\nThe equations of motion are\n$$\nm \\frac{d^2 x_i}{dt^2} = F_i, \\quad i \\in \\{0,1\\}, \\quad m = 1.\n$$\nIntegrate the dynamics using the velocity Verlet method with uniform time step $\\Delta t$:\n- Given positions $x_i(t)$, velocities $v_i(t)$, and accelerations $a_i(t) = F_i(t)/m$ at time $t$, update\n$$\nx_i(t+\\Delta t) = x_i(t) + v_i(t)\\,\\Delta t + \\tfrac{1}{2} a_i(t)\\,\\Delta t^2,\n$$\ncompute $F_i(t+\\Delta t)$ and $a_i(t+\\Delta t) = F_i(t+\\Delta t)/m$, then update\n$$\nv_i(t+\\Delta t) = v_i(t) + \\tfrac{1}{2}\\left[a_i(t) + a_i(t+\\Delta t)\\right]\\Delta t.\n$$\n\nInitialization and observables:\n- Initialize positions at $x_0(0) = -x_{\\mathrm{init}}$, $x_1(0) = +x_{\\mathrm{init}}$, with $x_{\\mathrm{init}} = 0.1$.\n- Initialize velocities by independent draws from a normal distribution with zero mean and variance $\\sigma_v^2 = T_0/m$, with target temperature $T_0 = 1$. Use a fixed pseudorandom number generator seed of $13579$ for reproducibility, and reinitialize the random number generator with this same seed for each new scan value of $\\Delta t$ and each test case.\n- Define the instantaneous kinetic energy\n$$\nK(t) = \\tfrac{1}{2} m\\left[v_0(t)^2 + v_1(t)^2\\right],\n$$\nthe instantaneous total energy\n$$\nE(t) = K(t) + U\\big(x_0(t),x_1(t)\\big),\n$$\nand the instantaneous temperature (in reduced units with $k_{\\mathrm{B}}=1$)\n$$\nT(t) = \\frac{2\\,K(t)}{\\mathrm{dof}},\n$$\nwith total number of degrees of freedom $\\mathrm{dof} = 2$.\n- Define the root-mean-square force as the time-and-particle averaged value\n$$\nF_{\\mathrm{RMS}} = \\left(\\frac{1}{2N_s}\\sum_{n=1}^{N_s}\\sum_{i=0}^{1} F_i(t_n)^2 \\right)^{1/2},\n$$\nwhere $N_s$ is the number of sampled time points after discarding an initial equilibration segment.\n\nStability diagnostics and decision rule:\n- For a given $\\Delta t$, run $N_{\\mathrm{steps}}$ integration steps, discard the first $N_{\\mathrm{burn}}$ samples as equilibration, then evaluate:\n    - The relative standard deviation of temperature,\n    $$\n    \\delta_T = \\frac{\\mathrm{std}\\left(T\\right)}{\\mathrm{mean}\\left(T\\right)},\n    $$\n      computed over the sampled segment after burn-in.\n    - The relative peak-to-peak oscillation amplitude of total energy,\n    $$\n    \\delta_E = \\frac{\\max(E) - \\min(E)}{\\mathrm{mean}(E)},\n    $$\n      computed over the sampled segment after burn-in.\n    - The root-mean-square force $F_{\\mathrm{RMS}}$ computed over the entire trajectory after burn-in.\n- A simulation at time step $\\Delta t$ is deemed unstable if any of the following conditions are met:\n    - Early-termination triggers: at any time during integration, $|x_0|$ or $|x_1|$ exceeds $X_{\\max}$, or $|E|$ exceeds $E_{\\max}$, or any non-finite value is encountered in positions, velocities, or energies.\n    - Post-run metric thresholds: $\\delta_T > \\tau_T$, or $\\delta_E > \\tau_E$, or $F_{\\mathrm{RMS}} > \\tau_F$.\n- Use the thresholds\n$$\n\\tau_T = 0.25,\\quad \\tau_E = 0.20,\\quad \\tau_F = 10^3,\\quad X_{\\max} = 10^3,\\quad E_{\\max} = 10^6.\n$$\n\nTime step scan and threshold reporting:\n- For each test case, scan a specified range of $\\Delta t$ values on a uniform grid. The critical threshold is the smallest $\\Delta t$ in the scan for which instability is detected. If no instability is detected across the entire scan, return $-1.0$ for that test case.\n\nImplementation details and constants to use:\n- Use $N_{\\mathrm{steps}} = 5000$ and $N_{\\mathrm{burn}} = 200$ for all runs.\n- For each $\\Delta t$, reinitialize the positions and velocities from the same initial conditions and the same random seed $13579$ as specified above.\n- Use mass $m=1$, $k_{\\mathrm{B}}=1$, and degrees of freedom $\\mathrm{dof}=2$ as defined above.\n\nTest suite:\n- Case A (very stiff bond):\n    - $k_b = 1000$, $k_t = 1$, $\\Delta t$ in the interval $[0.005, 0.08]$ with increment $0.0025$.\n- Case B (moderately stiff bond):\n    - $k_b = 200$, $k_t = 1$, $\\Delta t$ in the interval $[0.01, 0.20]$ with increment $0.005$.\n- Case C (soft bond):\n    - $k_b = 20$, $k_t = 1$, $\\Delta t$ in the interval $[0.02, 0.30]$ with increment $0.01$.\n\nProgram requirements:\n- Your program must implement the above dynamics and diagnostics exactly and produce a single line of output containing the three detected thresholds for Cases A, B, and C, in that order, rounded to $6$ decimal places. If no threshold is found for a given case, output $-1.000000$ for that case.\n- Final output format: a single line containing a comma-separated Python-style list, e.g., $\"[0.045000,0.105000,-1.000000]\"$.\n\nNo input is to be read from standard input. The result must be computed entirely within the program using the specified test suite and constants, and printed in the exact output format.", "solution": "The problem presented is a well-posed and scientifically sound exercise in computational physics, specifically in the field of molecular dynamics. It is deemed valid and a full solution is provided below. The task is to empirically determine the critical integration time step, $\\Delta t$, at which a simple two-particle harmonic oscillator system becomes numerically unstable. This is accomplished by performing a series of molecular dynamics simulations over a range of $\\Delta t$ values and applying a set of explicit stability criteria.\n\nThe core of the problem lies in the trade-off between computational efficiency (favoring larger $\\Delta t$) and numerical accuracy and stability (requiring smaller $\\Delta t$). The stability of numerical integrators like the velocity Verlet method is limited by the highest frequency of motion within the system. For a harmonic system, this frequency is determined by the masses and spring constants. The problem is designed to demonstrate this principle by testing systems with progressively stiffer bonds (higher $k_b$), which introduce higher-frequency oscillations and thus demand smaller, more carefully chosen time steps.\n\nThe solution is implemented by following a rigorous, step-by-step procedure for each test case.\n\n**1. System Definition and Equations of Motion**\n\nThe physical system consists of two particles of mass $m=1$ at positions $x_0(t)$ and $x_1(t)$. Their interaction and confinement are described by the potential energy function:\n$$\nU(x_0, x_1) = \\frac{1}{2} k_t x_0^2 + \\frac{1}{2} k_t x_1^2 + \\frac{1}{2} k_b (x_1 - x_0)^2\n$$\nHere, $k_t$ is the spring constant tethering each particle to the origin, and $k_b$ is the spring constant of the harmonic bond connecting the two particles.\n\nThe forces acting on each particle are derived from the negative gradient of the potential energy, $F_i = -\\frac{\\partial U}{\\partial x_i}$:\n$$\nF_0 = -k_t x_0 + k_b (x_1 - x_0) = -(k_t + k_b) x_0 + k_b x_1\n$$\n$$\nF_1 = -k_t x_1 - k_b (x_1 - x_0) = k_b x_0 - (k_t + k_b) x_1\n$$\nThe accelerations are then given by Newton's second law, $a_i = F_i / m$. Since mass $m=1$, we have $a_i = F_i$.\n\n**2. Numerical Integration: The Velocity Verlet Algorithm**\n\nThe equations of motion are integrated numerically using the velocity Verlet algorithm. This is a standard, robust method that exhibits good energy conservation over long simulations. Given the state of the system—positions $x_i(t)$, velocities $v_i(t)$, and accelerations $a_i(t)$—at time $t$, the state at time $t+\\Delta t$ is computed in two stages:\n- **Stage 1 (Position Update):** The positions are advanced by a full time step $\\Delta t$:\n$$\nx_i(t+\\Delta t) = x_i(t) + v_i(t)\\,\\Delta t + \\frac{1}{2} a_i(t)\\,\\Delta t^2\n$$\n- **Stage 2 (Velocity Update):** New forces $F_i(t+\\Delta t)$ and accelerations $a_i(t+\\Delta t)$ are computed using the updated positions $x_i(t+\\Delta t)$. The velocities are then advanced by a full time step using a symmetric average of the old and new accelerations:\n$$\nv_i(t+\\Delta t) = v_i(t) + \\frac{1}{2}\\left[a_i(t) + a_i(t+\\Delta t)\\right]\\Delta t\n$$\n\n**3. Simulation Protocol and Stability Assessment**\n\nFor each parameter set (a \"test case\"), a scan is performed across a specified range of $\\Delta t$ values. For each individual $\\Delta t$ in the scan, a complete simulation is executed.\n\n- **Initialization:** For each simulation run, the system is re-initialized to ensure an independent test. Positions are set to fixed values: $x_0(0) = -0.1$ and $x_1(0) = 0.1$. Velocities $v_0(0)$ and $v_1(0)$ are drawn from a normal distribution with mean $0$ and variance $\\sigma_v^2 = T_0/m = 1/1 = 1$. Critically, the pseudorandom number generator is re-seeded with the value $13579$ for each $\\Delta t$. This guarantees that every time step is tested against the exact same initial microscopic state, making the comparison fair and reproducible.\n\n- **Integration:** The system is evolved for $N_{\\mathrm{steps}} = 5000$ steps. During the integration, two *early-termination* checks for gross instability are performed at every step:\n    1. If the absolute position of either particle, $|x_i|$, exceeds a large value $X_{\\max} = 10^3$.\n    2. If the absolute total energy, $|E|$, exceeds $E_{\\max} = 10^6$.\n    If any of these occur, or if a non-finite number (e.g., `NaN`, `inf`) is generated, the simulation for that $\\Delta t$ is immediately halted and flagged as unstable.\n\n- **Post-Run Analysis:** If the simulation completes all $5000$ steps, the trajectory data from the first $N_{\\mathrm{burn}} = 200$ steps are discarded to allow the system to equilibrate. The remaining $N_s = 4800$ steps are used to compute three diagnostic metrics:\n    1. **Temperature Fluctuation $\\delta_T$**: The relative standard deviation of the instantaneous temperature, $\\delta_T = \\mathrm{std}(T)/\\mathrm{mean}(T)$. The temperature is defined as $T(t) = 2K(t)/\\mathrm{dof} = K(t)$, where $K(t)$ is the total kinetic energy and the number of degrees of freedom is $\\mathrm{dof}=2$.\n    2. **Energy Fluctuation $\\delta_E$**: The relative peak-to-peak fluctuation of the total energy, $\\delta_E = (\\max(E) - \\min(E))/\\mathrm{mean}(E)$.\n    3. **Root-Mean-Square Force $F_{\\mathrm{RMS}}$**: The time-and-particle averaged RMS force, $F_{\\mathrm{RMS}} = \\left(\\frac{1}{2N_s}\\sum_{n=1}^{N_s}\\sum_{i=0}^{1} F_i(t_n)^2 \\right)^{1/2}$.\n\n- **Decision Rule:** The run is classified as unstable if any of the computed metrics exceed their predefined thresholds: $\\delta_T > 0.25$, $\\delta_E > 0.20$, or $F_{\\mathrm{RMS}} > 10^3$.\n\n**4. Determining the Critical Time Step**\n\nThe scan for each test case proceeds from the smallest $\\Delta t$ to the largest. The first $\\Delta t$ value for which the simulation is deemed unstable (by either early termination or post-run analysis) is the critical time step for that case. The search for that case is then terminated. If the scan completes without any simulation being flagged as unstable, a value of $-1.0$ is reported, indicating that the stability limit is beyond the tested range.\n\nThis entire procedure is automated in the provided Python code, which methodically implements each step to arrive at the final numerical results for the three specified test cases.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# from scipy import ...\n\ndef potential_energy(x, kb, kt):\n    \"\"\"Calculates the potential energy of the system.\"\"\"\n    x0, x1 = x\n    return 0.5 * kt * x0**2 + 0.5 * kt * x1**2 + 0.5 * kb * (x1 - x0)**2\n\ndef forces(x, kb, kt):\n    \"\"\"Calculates the forces on the particles.\"\"\"\n    x0, x1 = x\n    F0 = -kt * x0 + kb * (x1 - x0)\n    F1 = -kt * x1 - kb * (x1 - x0)\n    return np.array([F0, F1])\n\ndef run_simulation(kb, kt, dt, params):\n    \"\"\"\n    Runs a single molecular dynamics simulation for a given set of parameters.\n    Returns True if stable, False if unstable.\n    \"\"\"\n    # Unpack parameters\n    m, T0, dof, x_init_val, seed = params['m'], params['T0'], params['dof'], params['x_init'], params['seed']\n    N_steps, N_burn = params['N_steps'], params['N_burn']\n    X_max, E_max = params['X_max'], params['E_max']\n    tau_T, tau_E, tau_F = params['tau_T'], params['tau_E'], params['tau_F']\n    N_samples = N_steps - N_burn\n\n    # 1. Initialization for each run\n    rng = np.random.default_rng(seed)\n    x = np.array([-x_init_val, x_init_val])\n    v = rng.normal(loc=0.0, scale=np.sqrt(T0 / m), size=2)\n\n    # Initial calculations\n    F = forces(x, kb, kt)\n    a = F / m\n    U = potential_energy(x, kb, kt)\n    K = 0.5 * m * np.sum(v**2)\n    E = K + U\n\n    if not np.isfinite(E):\n        return False\n\n    # Data storage for post-run analysis\n    E_samples = []\n    T_samples = []\n    F_squared_sum = 0.0\n\n    # 2. Integration loop (Velocity Verlet)\n    for step in range(N_steps):\n        # Position update\n        x = x + v * dt + 0.5 * a * dt**2\n\n        # Early termination check: position\n        if np.any(np.abs(x) > X_max):\n            return False\n\n        # Force/acceleration update\n        F_new = forces(x, kb, kt)\n        a_new = F_new / m\n\n        # Velocity update\n        v = v + 0.5 * (a + a_new) * dt\n\n        # Update acceleration for next step\n        a = a_new\n\n        # Energy and other observables\n        U = potential_energy(x, kb, kt)\n        K = 0.5 * m * np.sum(v**2)\n        E = K + U\n\n        # Early termination checks: energy and finite values\n        if not np.isfinite(E) or abs(E) > E_max:\n            return False\n            \n        # 3. Data Sampling\n        if step >= N_burn:\n            T = 2.0 * K / dof\n            E_samples.append(E)\n            T_samples.append(T)\n            F_squared_sum += np.sum(F_new**2)\n\n    # 4. Post-run analysis\n    E_arr = np.array(E_samples)\n    T_arr = np.array(T_samples)\n\n    if E_arr.size == 0 or T_arr.size == 0 or not np.all(np.isfinite(E_arr)) or not np.all(np.isfinite(T_arr)):\n        return False\n        \n    mean_T = np.mean(T_arr)\n    std_T = np.std(T_arr)\n    mean_E = np.mean(E_arr)\n    \n    if mean_T == 0 or mean_E == 0: # Avoid division by zero\n        return False\n\n    delta_T = std_T / mean_T\n    delta_E = (np.max(E_arr) - np.min(E_arr)) / mean_E\n    F_rms = np.sqrt(F_squared_sum / (2 * N_samples))\n\n    # 5. Decision rule\n    if delta_T > tau_T or delta_E > tau_E or F_rms > tau_F:\n        return False\n\n    return True # Stable\n\ndef find_critical_dt(case_params, sim_params):\n    \"\"\"\n    Scans a range of dt values to find the first unstable one.\n    \"\"\"\n    kb, kt, dt_start, dt_end, dt_inc = case_params\n\n    # Generate the scan range for dt, ensuring endpoint is included\n    dt_scan = np.arange(dt_start, dt_end + dt_inc * 0.5, dt_inc)\n\n    for dt in dt_scan:\n        is_stable = run_simulation(kb, kt, dt, sim_params)\n        if not is_stable:\n            return dt\n            \n    return -1.0\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    sim_params = {\n        'm': 1.0, \n        'T0': 1.0, \n        'dof': 2,\n        'x_init': 0.1,\n        'seed': 13579,\n        'N_steps': 5000, \n        'N_burn': 200,\n        'X_max': 1.0e3, \n        'E_max': 1.0e6,\n        'tau_T': 0.25, \n        'tau_E': 0.20, \n        'tau_F': 1.0e3\n    }\n\n    test_cases = [\n        # (kb, kt, dt_start, dt_end, dt_inc)\n        (1000.0, 1.0, 0.005, 0.08, 0.0025),  # Case A\n        (200.0, 1.0, 0.01, 0.20, 0.005),   # Case B\n        (20.0, 1.0, 0.02, 0.30, 0.01),      # Case C\n    ]\n    \n    results = []\n    for case in test_cases:\n        critical_dt = find_critical_dt(case, sim_params)\n        results.append(critical_dt)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```", "id": "3415667"}, {"introduction": "Since high-frequency vibrations often force the use of impractically small time steps, a common strategy is to \"freeze\" these motions altogether using rigid constraints. This advanced conceptual exercise challenges you to analyze the consequences of this powerful technique on a simulation's most important diagnostic: total energy conservation. You will dissect the differences between an unconstrained simulation and one using a constraint algorithm like SHAKE or RATTLE, weighing the benefit of a larger time step against the subtle numerical errors introduced by the constraint solver. [@problem_id:3415632]", "problem": "A rigid-bond approximation is widely used in Molecular Dynamics (MD) to remove High-Frequency Vibrational Modes (HFVM) so that larger time steps can be employed without destabilizing the integrator. Consider a diatomic molecule with atoms of equal mass $m$ connected by a stiff harmonic bond potential $V(r) = \\tfrac{1}{2} k (r - r_0)^2$, where $r$ is the interatomic distance, $r_0$ is the equilibrium bond length, and $k$ is a large stiffness constant. The reduced mass is $\\mu = m/2$, so the natural frequency of the bond is $\\omega_h = \\sqrt{k / \\mu}$. Two numerical protocols are considered:\n\n(i) An unconstrained velocity Verlet scheme applied to the full Hamiltonian dynamics with the stiff bond potential unresolved by constraints, using a constant time step $dt$ that satisfies the linear stability condition for the method.\n\n(ii) A constrained velocity Verlet scheme that enforces the holonomic bond-length constraint $r = r_0$ via position and velocity corrections each step, using a projection algorithm in the class of SHAKE/RATTLE-type methods that iteratively solves the constraint residuals to within a specified tolerance $\\epsilon_c$, defined as the maximum norm of the position constraint violation after the correction per step.\n\nAssume no thermostats, no barostats, no external forces, and neglect round-off error. All corrections are performed deterministically. For protocol (ii), assume the constraint solver, if run to exact satisfaction of constraints ($\\epsilon_c = 0$), yields a symplectic constrained map; otherwise, with finite $\\epsilon_c > 0$, the map departs from exact symplecticness.\n\nStarting from Newton’s second law for the diatomic system, $m \\,\\ddot{\\boldsymbol{r}}_1 = - \\nabla_{\\boldsymbol{r}_1} V$, $m \\,\\ddot{\\boldsymbol{r}}_2 = - \\nabla_{\\boldsymbol{r}_2} V$, and the definition of velocity Verlet as a second-order, time-reversible, symplectic integrator in the unconstrained case, reason about the qualitative and quantitative long-time behavior of the total energy $E(t)$ under each protocol. In particular, determine the leading-order scaling (in terms of $dt$, $\\omega_h$, and $\\epsilon_c$) of:\n\n- The amplitude of bounded oscillations in $E(t)$ about its mean for protocol (i).\n- The presence or absence of a secular drift in $E(t)$ and its rate for protocol (i).\n- The amplitude of bounded oscillations in $E(t)$ for protocol (ii) when $\\epsilon_c > 0$ but small.\n- The presence or absence of a secular drift in $E(t)$ and its rate for protocol (ii) when $\\epsilon_c > 0$ but small.\n\nSelect the option that most accurately captures these scalings and behaviors.\n\nA. For protocol (i), $E(t)$ exhibits bounded oscillations with amplitude scaling as $\\mathcal{O}\\!\\left( (\\omega_h dt)^2 \\right)$ and no secular drift. For protocol (ii), when $\\epsilon_c > 0$, the method loses exact symplecticness and produces a secular energy drift with rate scaling as $\\mathcal{O}\\!\\left( \\epsilon_c^2 / dt \\right)$, while the oscillatory component of the energy error for the remaining degrees of freedom (DOF) scales as $\\mathcal{O}\\!\\left( dt^2 \\right)$.\n\nB. For protocol (i), $E(t)$ shows a secular drift with rate $\\mathcal{O}\\!\\left( dt \\right)$; for protocol (ii), constraint corrections eliminate drift entirely and leave only bounded oscillations with amplitude $\\mathcal{O}\\!\\left( dt^3 \\right)$.\n\nC. For protocol (i), the amplitude of bounded energy oscillations is $\\mathcal{O}\\!\\left( dt \\right)$; for protocol (ii), the secular drift rate is $\\mathcal{O}\\!\\left( \\epsilon_c / dt \\right)$ and the oscillatory component is $\\mathcal{O}\\!\\left( dt \\right)$.\n\nD. For protocol (i), $E(t)$ exhibits bounded oscillations of amplitude $\\mathcal{O}\\!\\left( dt^2 \\right)$ plus a long-time drift accumulating at rate $\\mathcal{O}\\!\\left( dt^3 \\right)$; for protocol (ii), the secular drift rate is $\\mathcal{O}\\!\\left( \\epsilon_c \\right)$, independent of $dt$.\n\nE. Both protocols produce purely bounded oscillations of amplitude $\\mathcal{O}\\!\\left( dt^2 \\right)$ with exactly zero secular drift for any $\\epsilon_c \\ge 0$.", "solution": "The problem statement is a valid exercise in the analysis of numerical integrators for molecular dynamics. It is scientifically grounded, well-posed, and objective. It accurately describes two standard simulation protocols and poses a theoretically sound question about their long-time energy conservation properties. We may therefore proceed with a full solution.\n\nThe analysis hinges on the properties of the velocity Verlet integrator and the effect of imposing holonomic constraints.\n\n**Protocol (i): Unconstrained Velocity Verlet**\n\nThe velocity Verlet algorithm is a second-order, time-reversible, and symplectic integrator. A key consequence of symplecticness, established by backward error analysis, is that the numerical trajectory generated by the integrator does not exactly conserve the true Hamiltonian, $H$, but instead exactly conserves a nearby *shadow Hamiltonian*, $\\tilde{H}$. For a second-order integrator with time step $dt$, the shadow Hamiltonian can be expressed as an asymptotic series:\n$$ \\tilde{H} = H + dt^2 H_2 + dt^4 H_4 + \\dots $$\nwhere $H_2$, $H_4$, etc., are functions of positions and momenta involving higher-order derivatives of the potential.\n\nBecause the numerical trajectory exactly conserves $\\tilde{H}$, the total energy of the true system, $E(t) = H(\\boldsymbol{q}(t), \\boldsymbol{p}(t))$, exhibits bounded oscillations around the constant value of $\\tilde{H}$. There is no secular (long-term, systematic) drift in the mean energy.\n\nThe amplitude of these energy oscillations is determined by the magnitude of the leading-order correction term in the shadow Hamiltonian, $dt^2 H_2$. The term $H_2$ involves Poisson brackets of the Hamiltonian with itself and scales with the stiffness of the potential. For a harmonic oscillator with natural frequency $\\omega_h$, the term $H_2$ will contain factors proportional to the force constant $k = \\mu \\omega_h^2$. The dimensionless parameter governing the error is $\\omega_h dt$. A detailed analysis shows that the amplitude of the energy oscillations scales quadratically with this parameter.\n$$ \\text{Amplitude}(E_{\\text{osc}}) \\sim \\mathcal{O}\\! \\left( ( \\omega_h dt )^2 \\right) $$\nThe stability of the Verlet integrator requires that $\\omega_h dt  2$, so this dimensionless quantity is the correct measure of error for the high-frequency mode.\n\nIn summary, for protocol (i), the total energy $E(t)$ exhibits bounded oscillations with an amplitude scaling as $\\mathcal{O}((\\omega_h dt)^2)$ and no secular drift.\n\n**Protocol (ii): Constrained Velocity Verlet (SHAKE/RATTLE)**\n\nThis protocol replaces the stiff harmonic bond with a rigid holonomic constraint, $g(\\boldsymbol{r}) = r - r_0 = 0$. The SHAKE/RATTLE algorithms are used to enforce this constraint at each time step.\n\nThe problem statement correctly notes that if the constraint equations were solved to machine precision (i.e., $\\epsilon_c = 0$), the resulting map (e.g., RATTLE) would be symplectic on the constrained phase space. In this idealized case, the energy behavior would be analogous to protocol (i), but with the high frequency $\\omega_h$ eliminated. The remaining degrees of freedom (translation and rotation) have much lower characteristic frequencies, leading to bounded energy oscillations of amplitude $\\mathcal{O}(dt^2)$ and no secular drift.\n\nHowever, the problem specifies a finite tolerance $\\epsilon_c > 0$. This means the iterative solver for the constraint equations is terminated when the position constraint violation is less than or equal to $\\epsilon_c$. This inexact solution introduces a small, non-conservative perturbation at each step, breaking the exact symplecticness of the integration scheme. A non-symplectic integrator will, in general, exhibit a secular drift in energy.\n\nWe can estimate the rate of this drift. The position constraint violation is $|\\Delta r| \\sim \\mathcal{O}(\\epsilon_c)$. This means the atoms are at a distance $r \\approx r_0 \\pm \\epsilon_c$, which introduces a residual potential energy and an associated artificial restoring force from the original potential, $F_{\\text{res}} \\approx k \\Delta r \\sim \\mathcal{O}(k \\epsilon_c)$. The RATTLE algorithm for velocities also incurs an error related to $\\epsilon_c$. The velocity component parallel to the bond, which should be zero, is non-zero and scales as $v_{\\parallel} \\sim \\mathcal{O}(\\epsilon_c / dt)$. This non-zero velocity means the residual force can perform work. The work done by this artificial force in a single time step $\\Delta t = dt$ is approximately:\n$$ \\Delta E_{\\text{step}} \\approx F_{\\text{res}} \\cdot (v_{\\parallel} \\cdot dt) $$\nSubstituting the scaling behaviors:\n$$ \\Delta E_{\\text{step}} \\sim (k \\epsilon_c) \\cdot (\\frac{\\epsilon_c}{dt} \\cdot dt) \\sim k \\epsilon_c^2 $$\nThis is the energy drift per step. The rate of secular energy drift is the drift per step divided by the time step duration:\n$$ \\frac{dE}{dt} \\approx \\frac{\\Delta E_{\\text{step}}}{dt} \\sim \\mathcal{O}\\! \\left( \\frac{k \\epsilon_c^2}{dt} \\right) \\sim \\mathcal{O}\\! \\left( \\frac{\\omega_h^2 \\epsilon_c^2}{dt} \\right) $$\nThe problem asks for scaling in terms of the given parameters, so the rate scales as $\\mathcal{O}(\\epsilon_c^2 / dt)$.\n\nIn addition to this drift, the underlying second-order integrator still evolves the remaining, unconstrained degrees of freedom (e.g., center-of-mass translation, overall rotation). The energy associated with these slower motions will exhibit the characteristic bounded oscillations of the Verlet method, with an amplitude scaling as $\\mathcal{O}(dt^2)$.\n\n**Evaluation of Options**\n\n*   **A. For protocol (i), $E(t)$ exhibits bounded oscillations with amplitude scaling as $\\mathcal{O}\\!\\left( (\\omega_h dt)^2 \\right)$ and no secular drift. For protocol (ii), when $\\epsilon_c > 0$, the method loses exact symplecticness and produces a secular energy drift with rate scaling as $\\mathcal{O}\\!\\left( \\epsilon_c^2 / dt \\right)$, while the oscillatory component of the energy error for the remaining degrees of freedom (DOF) scales as $\\mathcal{O}\\!\\left( dt^2 \\right)$.**\n    This statement perfectly matches our derived behavior for both protocols. The analysis of protocol (i) (bounded oscillations scaling as $\\mathcal{O}((\\omega_h dt)^2)$, no drift) is correct. The analysis of protocol (ii) (secular drift from non-symplecticness, drift rate scaling as $\\mathcal{O}(\\epsilon_c^2/dt)$, and underlying oscillations scaling as $\\mathcal{O}(dt^2)$) is also correct.\n    **Verdict: Correct.**\n\n*   **B. For protocol (i), $E(t)$ shows a secular drift with rate $\\mathcal{O}\\!\\left( dt \\right)$; for protocol (ii), constraint corrections eliminate drift entirely and leave only bounded oscillations with amplitude $\\mathcal{O}\\!\\left( dt^3 \\right)$.**\n    This statement is incorrect on multiple grounds. Protocol (i) uses a symplectic integrator and does not have a leading-order secular drift. For protocol (ii), using a finite tolerance $\\epsilon_c > 0$ *introduces* secular drift, it does not eliminate it. The amplitude of oscillations for a second-order method scales as $\\mathcal{O}(dt^2)$, not $\\mathcal{O}(dt^3)$.\n    **Verdict: Incorrect.**\n\n*   **C. For protocol (i), the amplitude of bounded energy oscillations is $\\mathcal{O}\\!\\left( dt \\right)$; for protocol (ii), the secular drift rate is $\\mathcal{O}\\!\\left( \\epsilon_c / dt \\right)$ and the oscillatory component is $\\mathcal{O}\\!\\left( dt \\right)$.**\n    This statement is incorrect. For protocol (i), the amplitude of energy oscillations scales as $\\mathcal{O}(dt^2)$, not $\\mathcal{O}(dt)$. For protocol (ii), while the drift rate scaling is a subject of some debate in literature (with some analyses yielding $\\mathcal{O}(\\epsilon_c/dt)$), the oscillatory component scaling of $\\mathcal{O}(dt)$ is definitively wrong; it should be $\\mathcal{O}(dt^2)$.\n    **Verdict: Incorrect.**\n\n*   **D. For protocol (i), $E(t)$ exhibits bounded oscillations of amplitude $\\mathcal{O}\\!\\left( dt^2 \\right)$ plus a long-time drift accumulating at rate $\\mathcal{O}\\!\\left( dt^3 \\right)$; for protocol (ii), the secular drift rate is $\\mathcal{O}\\!\\left( \\epsilon_c \\right)$, independent of $dt$.**\n    This statement is incorrect. Protocol (i) does not have a secular drift. The scaling of the drift rate for protocol (ii) as $\\mathcal{O}(\\epsilon_c)$ is physically and dimensionally questionable and inconsistent with standard analysis, which shows a dependence on $dt$.\n    **Verdict: Incorrect.**\n\n*   **E. Both protocols produce purely bounded oscillations of amplitude $\\mathcal{O}\\!\\left( dt^2 \\right)$ with exactly zero secular drift for any $\\epsilon_c \\ge 0$.**\n    This statement is incorrect. It rightly identifies the bounded oscillations for protocol (i) (though it omits the important $\\omega_h$ dependence), but it falsely claims that protocol (ii) with $\\epsilon_c > 0$ has zero secular drift. The non-symplectic nature of the inexactly constrained integrator necessarily leads to energy drift.\n    **Verdict: Incorrect.**\n\nBased on the rigorous analysis, Option A is the only one that provides a completely accurate description of the energy behavior for both protocols.", "answer": "$$\\boxed{A}$$", "id": "3415632"}]}