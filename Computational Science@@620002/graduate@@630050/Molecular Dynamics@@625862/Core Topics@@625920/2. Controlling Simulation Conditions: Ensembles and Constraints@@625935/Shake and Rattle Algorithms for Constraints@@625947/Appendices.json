{"hands_on_practices": [{"introduction": "To truly understand how constraint algorithms work, we begin with the simplest possible scenario: two particles connected by a single rigid bond. This foundational exercise guides you through the derivation of the SHAKE position correction from first principles, using the method of Lagrange multipliers. By working through this problem [@problem_id:3444923], you will see how the principle of minimizing mass-weighted displacement leads directly to the algorithm's iconic update rule.", "problem": "Consider two atoms $i$ and $j$ in a Molecular Dynamics (MD) simulation, with masses $m_i$ and $m_j$, respectively. After an unconstrained position update over a time step, their predicted positions are $\\tilde{\\mathbf{r}}_i$ and $\\tilde{\\mathbf{r}}_j$. A single holonomic bond-length constraint requires that the final, corrected positions $\\mathbf{r}_i = \\tilde{\\mathbf{r}}_i + \\delta \\mathbf{r}_i$ and $\\mathbf{r}_j = \\tilde{\\mathbf{r}}_j + \\delta \\mathbf{r}_j$ satisfy $|\\mathbf{r}_i - \\mathbf{r}_j| = d$, where $d$ is a prescribed constant bond length. Define $\\tilde{\\mathbf{r}}_{ij} \\equiv \\tilde{\\mathbf{r}}_i - \\tilde{\\mathbf{r}}_j$ and assume $|\\tilde{\\mathbf{r}}_{ij}| \\neq 0$.\n\nUsing only first principles (Newtonian mechanics, holonomic constraints, and the defining principle of the SHAKE algorithm that position corrections minimize the mass-weighted displacement subject to the constraint being exactly satisfied at the end of the time step), derive closed-form expressions for the position corrections $\\delta \\mathbf{r}_i$ and $\\delta \\mathbf{r}_j$ that enforce the constraint exactly for this single bond. Express your final answer in terms of $m_i$, $m_j$, $\\tilde{\\mathbf{r}}_{ij}$, and $d$. Choose the solution that yields the smallest mass-weighted displacement from $(\\tilde{\\mathbf{r}}_i, \\tilde{\\mathbf{r}}_j)$ and preserves the original bond orientation, and assume no other constraints are present.\n\nGive your final answer as the pair $\\delta \\mathbf{r}_i$ and $\\delta \\mathbf{r}_j$ in a single row matrix. No numerical evaluation is required, and no units should be included in the final answer.", "solution": "The problem requires the derivation of the atomic position corrections, $\\delta \\mathbf{r}_i$ and $\\delta \\mathbf{r}_j$, for two atoms of mass $m_i$ and $m_j$ respectively, to satisfy a single bond-length constraint. The derivation is based on the core principle of the SHAKE algorithm: the corrections must minimize the total mass-weighted squared displacement while exactly satisfying the constraint.\n\nThe objective is to minimize the function $S$:\n$$S(\\delta \\mathbf{r}_i, \\delta \\mathbf{r}_j) = m_i |\\delta \\mathbf{r}_i|^2 + m_j |\\delta \\mathbf{r}_j|^2$$\nsubject to the holonomic constraint that the final separation between the atoms is a constant distance $d$. The final positions are given by $\\mathbf{r}_i = \\tilde{\\mathbf{r}}_i + \\delta \\mathbf{r}_i$ and $\\mathbf{r}_j = \\tilde{\\mathbf{r}}_j + \\delta \\mathbf{r}_j$, where $\\tilde{\\mathbf{r}}_i$ and $\\tilde{\\mathbf{r}}_j$ are the unconstrained predicted positions.\n\nThe constraint equation is:\n$$\\sigma(\\mathbf{r}_i, \\mathbf{r}_j) = |\\mathbf{r}_i - \\mathbf{r}_j|^2 - d^2 = 0$$\nUsing the definitions of the corrected positions, the constraint becomes:\n$$|(\\tilde{\\mathbf{r}}_i + \\delta \\mathbf{r}_i) - (\\tilde{\\mathbf{r}}_j + \\delta \\mathbf{r}_j)|^2 - d^2 = 0$$\nLet $\\tilde{\\mathbf{r}}_{ij} = \\tilde{\\mathbf{r}}_i - \\tilde{\\mathbf{r}}_j$. The constraint equation is then:\n$$|\\tilde{\\mathbf{r}}_{ij} + \\delta \\mathbf{r}_i - \\delta \\mathbf{r}_j|^2 - d^2 = 0$$\n\nThis is a constrained optimization problem, which we will solve using the method of Lagrange multipliers. We define the Lagrangian function $\\mathcal{L}$:\n$$\\mathcal{L} = m_i |\\delta \\mathbf{r}_i|^2 + m_j |\\delta \\mathbf{r}_j|^2 - \\lambda (|\\tilde{\\mathbf{r}}_{ij} + \\delta \\mathbf{r}_i - \\delta \\mathbf{r}_j|^2 - d^2)$$\nwhere $\\lambda$ is the Lagrange multiplier. To find the minimum, we set the gradients of $\\mathcal{L}$ with respect to the optimization variables $\\delta \\mathbf{r}_i$ and $\\delta \\mathbf{r}_j$ to zero.\n\nTaking the gradient with respect to $\\delta \\mathbf{r}_i$:\n$$\\nabla_{\\delta \\mathbf{r}_i} \\mathcal{L} = 2 m_i \\delta \\mathbf{r}_i - 2 \\lambda (\\tilde{\\mathbf{r}}_{ij} + \\delta \\mathbf{r}_i - \\delta \\mathbf{r}_j) = \\mathbf{0}$$\nTaking the gradient with respect to $\\delta \\mathbf{r}_j$:\n$$\\nabla_{\\delta \\mathbf{r}_j} \\mathcal{L} = 2 m_j \\delta \\mathbf{r}_j - 2 \\lambda (-1) (\\tilde{\\mathbf{r}}_{ij} + \\delta \\mathbf{r}_i - \\delta \\mathbf{r}_j) = \\mathbf{0}$$\nLet the final, corrected interatomic vector be $\\mathbf{r}_{ij} = \\mathbf{r}_i - \\mathbf{r}_j = \\tilde{\\mathbf{r}}_{ij} + \\delta \\mathbf{r}_i - \\delta \\mathbf{r}_j$. The gradient equations simplify to:\n$$m_i \\delta \\mathbf{r}_i = \\lambda \\mathbf{r}_{ij}$$\n$$m_j \\delta \\mathbf{r}_j = - \\lambda \\mathbf{r}_{ij}$$\nFrom these two equations, we can solve for the position corrections $\\delta \\mathbf{r}_i$ and $\\delta \\mathbf{r}_j$ in terms of $\\lambda$ and $\\mathbf{r}_{ij}$:\n$$\\delta \\mathbf{r}_i = \\frac{\\lambda}{m_i} \\mathbf{r}_{ij}$$\n$$\\delta \\mathbf{r}_j = -\\frac{\\lambda}{m_j} \\mathbf{r}_{ij}$$\nA direct consequence is that $m_i \\delta \\mathbf{r}_i + m_j \\delta \\mathbf{r}_j = \\mathbf{0}$. This shows that the corrections do not displace the center of mass of the two-atom system, a fundamental property of internal forces.\n\nNow, we substitute these expressions back into the definition of $\\mathbf{r}_{ij}$:\n$$\\mathbf{r}_{ij} = \\tilde{\\mathbf{r}}_{ij} + \\delta \\mathbf{r}_i - \\delta \\mathbf{r}_j = \\tilde{\\mathbf{r}}_{ij} + \\left(\\frac{\\lambda}{m_i} \\mathbf{r}_{ij}\\right) - \\left(-\\frac{\\lambda}{m_j} \\mathbf{r}_{ij}\\right)$$\n$$\\mathbf{r}_{ij} = \\tilde{\\mathbf{r}}_{ij} + \\lambda \\left(\\frac{1}{m_i} + \\frac{1}{m_j}\\right) \\mathbf{r}_{ij}$$\nRearranging the terms to solve for $\\mathbf{r}_{ij}$:\n$$\\mathbf{r}_{ij} \\left[1 - \\lambda \\left(\\frac{1}{m_i} + \\frac{1}{m_j}\\right)\\right] = \\tilde{\\mathbf{r}}_{ij}$$\nThis equation shows that the final interatomic vector $\\mathbf{r}_{ij}$ must be parallel to the unconstrained interatomic vector $\\tilde{\\mathbf{r}}_{ij}$. The constraint requires the magnitude of $\\mathbf{r}_{ij}$ to be $d$, i.e., $|\\mathbf{r}_{ij}| = d$. The problem statement also specifies that the original bond orientation should be preserved. This means that $\\mathbf{r}_{ij}$ must point in the same direction as $\\tilde{\\mathbf{r}}_{ij}$. Therefore, we can write:\n$$\\mathbf{r}_{ij} = d \\frac{\\tilde{\\mathbf{r}}_{ij}}{|\\tilde{\\mathbf{r}}_{ij}|}$$\nThis is valid since the problem states $|\\tilde{\\mathbf{r}}_{ij}| \\neq 0$.\n\nWe can now determine the Lagrange multiplier $\\lambda$ by substituting this expression for $\\mathbf{r}_{ij}$ into the rearranged equation:\n$$\\left(d \\frac{\\tilde{\\mathbf{r}}_{ij}}{|\\tilde{\\mathbf{r}}_{ij}|}\\right) \\left[1 - \\lambda \\left(\\frac{1}{m_i} + \\frac{1}{m_j}\\right)\\right] = \\tilde{\\mathbf{r}}_{ij}$$\nDividing both sides by the vector $\\tilde{\\mathbf{r}}_{ij}$ (or, more formally, taking the magnitude of both sides) yields a scalar equation:\n$$\\frac{d}{|\\tilde{\\mathbf{r}}_{ij}|} \\left[1 - \\lambda \\left(\\frac{1}{m_i} + \\frac{1}{m_j}\\right)\\right] = 1$$\nSolving for $\\lambda$:\n$$1 - \\lambda \\left(\\frac{1}{m_i} + \\frac{1}{m_j}\\right) = \\frac{|\\tilde{\\mathbf{r}}_{ij}|}{d}$$\n$$\\lambda \\left(\\frac{m_i + m_j}{m_i m_j}\\right) = 1 - \\frac{|\\tilde{\\mathbf{r}}_{ij}|}{d}$$\n$$\\lambda = \\frac{m_i m_j}{m_i+m_j} \\left(1 - \\frac{|\\tilde{\\mathbf{r}}_{ij}|}{d}\\right)$$\nNow we have all the components to find the final expressions for $\\delta \\mathbf{r}_i$ and $\\delta \\mathbf{r}_j$. Substituting the expressions for $\\lambda$ and $\\mathbf{r}_{ij}$ into the equations for the corrections:\nFor $\\delta \\mathbf{r}_i$:\n$$\\delta \\mathbf{r}_i = \\frac{\\lambda}{m_i} \\mathbf{r}_{ij} = \\frac{1}{m_i} \\left[\\frac{m_i m_j}{m_i+m_j} \\left(1 - \\frac{|\\tilde{\\mathbf{r}}_{ij}|}{d}\\right)\\right] \\left(d \\frac{\\tilde{\\mathbf{r}}_{ij}}{|\\tilde{\\mathbf{r}}_{ij}|}\\right)$$\n$$\\delta \\mathbf{r}_i = \\frac{m_j}{m_i+m_j} \\left(\\frac{d - |\\tilde{\\mathbf{r}}_{ij}|}{d}\\right) \\frac{d}{|\\tilde{\\mathbf{r}}_{ij}|} \\tilde{\\mathbf{r}}_{ij}$$\n$$\\delta \\mathbf{r}_i = \\frac{m_j}{m_i+m_j} \\left(\\frac{d - |\\tilde{\\mathbf{r}}_{ij}|}{|\\tilde{\\mathbf{r}}_{ij}|}\\right) \\tilde{\\mathbf{r}}_{ij}$$\nThis can be written more cleanly as:\n$$\\delta \\mathbf{r}_i = \\frac{m_j}{m_i+m_j} \\left(\\frac{d}{|\\tilde{\\mathbf{r}}_{ij}|} - 1\\right) \\tilde{\\mathbf{r}}_{ij}$$\nFor $\\delta \\mathbf{r}_j$:\n$$\\delta \\mathbf{r}_j = -\\frac{\\lambda}{m_j} \\mathbf{r}_{ij} = -\\frac{1}{m_j} \\left[\\frac{m_i m_j}{m_i+m_j} \\left(1 - \\frac{|\\tilde{\\mathbf{r}}_{ij}|}{d}\\right)\\right] \\left(d \\frac{\\tilde{\\mathbf{r}}_{ij}}{|\\tilde{\\mathbf{r}}_{ij}|}\\right)$$\n$$\\delta \\mathbf{r}_j = -\\frac{m_i}{m_i+m_j} \\left(\\frac{d - |\\tilde{\\mathbf{r}}_{ij}|}{d}\\right) \\frac{d}{|\\tilde{\\mathbf{r}}_{ij}|} \\tilde{\\mathbf{r}}_{ij}$$\n$$\\delta \\mathbf{r}_j = -\\frac{m_i}{m_i+m_j} \\left(\\frac{d - |\\tilde{\\mathbf{r}}_{ij}|}{|\\tilde{\\mathbf{r}}_{ij}|}\\right) \\tilde{\\mathbf{r}}_{ij}$$\nWhich can be written as:\n$$\\delta \\mathbf{r}_j = -\\frac{m_i}{m_i+m_j} \\left(\\frac{d}{|\\tilde{\\mathbf{r}}_{ij}|} - 1\\right) \\tilde{\\mathbf{r}}_{ij}$$\nThese are the closed-form expressions for the position corrections that satisfy the bond-length constraint exactly while minimizing the mass-weighted displacement.", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{m_j}{m_i+m_j} \\left(\\frac{d}{|\\tilde{\\mathbf{r}}_{ij}|} - 1\\right) \\tilde{\\mathbf{r}}_{ij} & -\\frac{m_i}{m_i+m_j} \\left(\\frac{d}{|\\tilde{\\mathbf{r}}_{ij}|} - 1\\right) \\tilde{\\mathbf{r}}_{ij}\n\\end{pmatrix}\n}\n$$", "id": "3444923"}, {"introduction": "Theory provides the \"why,\" but implementation reveals the \"how.\" This practice moves from derivation to coding, tasking you with simulating a simple two-particle system using the SHAKE and RATTLE algorithms. Your goal is to investigate a critical numerical challenge [@problem_id:2436786]: the effect of large mass ratios on the convergence of the iterative solver, a situation commonly encountered in simulations of molecules containing both heavy atoms and light hydrogen atoms.", "problem": "Consider a system of two point particles in three spatial dimensions with positions $\\mathbf{r}_1 \\in \\mathbb{R}^3$ and $\\mathbf{r}_2 \\in \\mathbb{R}^3$, and masses $m_1$ and $m_2$ (in $\\mathrm{kg}$). The particles are linked by a rigid holonomic constraint that fixes their separation to a prescribed bond length $d$ (in $\\mathrm{m}$), namely\n$$\n\\phi(\\mathbf{r}_1,\\mathbf{r}_2) \\equiv \\lVert \\mathbf{r}_2 - \\mathbf{r}_1 \\rVert^2 - d^2 = 0.\n$$\nThere are no external forces. Let the initial positions and velocities be\n$$\n\\mathbf{r}_1(0) = (0,0,0)\\ \\mathrm{m},\\quad \\mathbf{r}_2(0) = (d,0,0)\\ \\mathrm{m},\n$$\n$$\n\\mathbf{v}_1(0) = (0,+v_0,0)\\ \\mathrm{m/s},\\quad \\mathbf{v}_2(0) = (0,-v_0,0)\\ \\mathrm{m/s},\n$$\nwith $d = 1.0\\ \\mathrm{m}$ and $v_0 = 1.0\\ \\mathrm{m/s}$. Evolve the system in time using a uniform time step $h = 0.01\\ \\mathrm{s}$ for $T = 50$ steps. At each time step, perform a free-flight position prediction using uniform-velocity motion,\n$$\n\\mathbf{r}_i^{\\ast} = \\mathbf{r}_i + h\\,\\mathbf{v}_i\\quad \\text{for } i \\in \\{1,2\\},\n$$\nand then enforce the holonomic constraint $\\phi(\\mathbf{r}_1,\\mathbf{r}_2)=0$ by iteratively updating the positions along the constraint gradient using mass-weighted corrections until the absolute constraint violation $|\\phi|$ is at most a tolerance $\\varepsilon = 10^{-12}\\ \\mathrm{m}^2$. One iteration is defined as one application of such a mass-weighted correction computed from the current iterate to reduce the residual of $\\phi$. After positions are corrected at a time step, enforce the corresponding velocity-level constraint at the corrected positions so that $\\dot{\\phi} = \\nabla_{\\mathbf{r}_1}\\phi \\cdot \\mathbf{v}_1 + \\nabla_{\\mathbf{r}_2}\\phi \\cdot \\mathbf{v}_2 = 0$ holds at the end of the time step.\n\nUsing the above setup, for each of the following four test cases of $(m_1,m_2)$ in $\\mathrm{kg}$:\n- Test case $1$: $(1.0,\\,1.0)$,\n- Test case $2$: $(1000.0,\\,1.0)$,\n- Test case $3$: $(10^{8},\\,1.0)$,\n- Test case $4$: $(10^{12},\\,1.0)$,\n\nsimulate the system and determine, for each test case, the maximum number of inner position-correction iterations required over all $T$ time steps to achieve $|\\phi| \\le \\varepsilon$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the test cases $1$ through $4$, where each entry is an integer. For example, the required format is\n$$\n[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4].\n$$\nAll physical quantities must be interpreted and computed in the specified International System of Units (SI). Angles, if any occur in intermediate computations, must be interpreted in radians, but the final reported results are unitless integers as defined above.", "solution": "The user has provided a computational physics problem that requires simulating a two-particle system with a rigid bond constraint. I must first validate the problem statement.\n\n### Step 1: Extract Givens\n- **System**: Two point particles in three-dimensional space.\n- **State variables**: Positions $\\mathbf{r}_1, \\mathbf{r}_2 \\in \\mathbb{R}^3$ and velocities $\\mathbf{v}_1, \\mathbf{v}_2 \\in \\mathbb{R}^3$.\n- **Parameters**: Masses $m_1, m_2$ (in $\\mathrm{kg}$), bond length $d = 1.0\\ \\mathrm{m}$, initial velocity component $v_0 = 1.0\\ \\mathrm{m/s}$.\n- **Holonomic constraint**: $\\phi(\\mathbf{r}_1,\\mathbf{r}_2) \\equiv \\lVert \\mathbf{r}_2 - \\mathbf{r}_1 \\rVert^2 - d^2 = 0$.\n- **Initial conditions**:\n  - $\\mathbf{r}_1(0) = (0,0,0)\\ \\mathrm{m}$, $\\mathbf{r}_2(0) = (d,0,0)\\ \\mathrm{m}$.\n  - $\\mathbf{v}_1(0) = (0,+v_0,0)\\ \\mathrm{m/s}$, $\\mathbf{v}_2(0) = (0,-v_0,0)\\ \\mathrm{m/s}$.\n- **Dynamics**: No external forces.\n- **Numerical method**:\n  - Time step $h = 0.01\\ \\mathrm{s}$.\n  - Number of steps $T = 50$.\n  - **Position Prediction**: Free-flight (uniform velocity) motion: $\\mathbf{r}_i^{\\ast} = \\mathbf{r}_i + h\\,\\mathbf{v}_i$.\n  - **Position Correction (SHAKE)**: Iteratively correct positions $\\mathbf{r}_i$ to satisfy $|\\phi| \\le \\varepsilon = 10^{-12}\\ \\mathrm{m}^2$. Corrections are mass-weighted and applied along the constraint gradient.\n  - **Velocity Correction (RATTLE)**: After position correction, velocities are adjusted to satisfy the time-differentiated constraint $\\dot{\\phi} = 0$.\n- **Task**: For four test cases of $(m_1, m_2)$ in $\\mathrm{kg}$:\n  1. $(1.0,\\,1.0)$,\n  2. $(1000.0,\\,1.0)$,\n  3. $(10^{8},\\,1.0)$,\n  4. $(10^{12},\\,1.0)$,\n  determine the maximum number of SHAKE iterations required across all $T$ time steps.\n- **Output format**: `[result_1,result_2,result_3,result_4]`\n\n### Step 2: Validate Using Extracted Givens\n1.  **Scientifically Grounded**: The problem describes a system under a holonomic constraint, a fundamental topic in classical and computational mechanics. The specified algorithms, SHAKE and RATTLE, are standard and widely used numerical methods for molecular dynamics simulations with constraints. The setup is scientifically sound.\n2.  **Well-Posed**: The problem is well-defined. Initial conditions, system parameters, the algorithm, and the stopping criterion are all precisely specified. A unique trajectory and a corresponding numerical result (maximum iteration count) are computable.\n3.  **Objective**: The problem is stated using objective, mathematical language, free from ambiguity or subjective claims.\n4.  **Incomplete or Contradictory Setup**: The setup is complete. The initial conditions are consistent with the constraints: $\\phi(\\mathbf{r}_1(0), \\mathbf{r}_2(0)) = \\lVert (d,0,0) - (0,0,0) \\rVert^2 - d^2 = 0$, and $\\dot{\\phi}(0) = 2(\\mathbf{r}_2(0)-\\mathbf{r}_1(0)) \\cdot (\\mathbf{v}_2(0)-\\mathbf{v}_1(0)) = 2(d,0,0)\\cdot(0,-2v_0,0) = 0$. There are no contradictions.\n5.  **Unrealistic or Infeasible**: While the mass ratios in test cases 3 and 4 are extreme, they are designed to test the numerical stability and performance of the algorithm under stiff conditions, which is a valid scientific investigation. The problem is numerically feasible.\n6.  **All other criteria**: The problem passes all other validity checks. It is formalizable, relevant to the topic, not ill-posed, and its result is scientifically verifiable.\n\n### Step 3: Verdict and Action\nThe problem is valid. I will proceed with providing a solution.\n\n### Principle-Based Design of the Solution\n\nThe problem requires the implementation of a simulation loop incorporating the SHAKE and RATTLE constraint algorithms, which are extensions of the Verlet integration scheme.\n\n#### The Simulation Loop\nThe system evolves from time $t_n$ to $t_{n+1} = t_n + h$. Let $\\mathbf{r}_i(n)$ and $\\mathbf{v}_i(n)$ be the positions and velocities of particle $i$ at time $t_n$.\n\n1.  **Position Prediction**: In the absence of external forces, particles move at a constant velocity. The predicted positions $\\mathbf{r}_i^*$ are:\n    $$ \\mathbf{r}_i^{\\ast} = \\mathbf{r}_i(n) + h\\,\\mathbf{v}_i(n) $$\n    These predicted positions, in general, will not satisfy the bond length constraint.\n\n2.  **Position Correction (SHAKE Algorithm)**: The SHAKE algorithm iteratively corrects the predicted positions until the constraint is met. Let $\\mathbf{r}_i^{(k)}$ be the position of particle $i$ at the $k$-th SHAKE iteration, with $\\mathbf{r}_i^{(0)} = \\mathbf{r}_i^*$. The correction at each step, $\\delta\\mathbf{r}_i^{(k)} = \\mathbf{r}_i^{(k+1)} - \\mathbf{r}_i^{(k)}$, is directed along the constraint gradient $\\nabla_{\\mathbf{r}_i}\\phi$ and weighted by the inverse mass $1/m_i$.\n\n    The constraint is $\\phi = \\lVert \\mathbf{r}_2 - \\mathbf{r}_1 \\rVert^2 - d^2 = 0$.\n    The gradients are $\\nabla_{\\mathbf{r}_1}\\phi = -2(\\mathbf{r}_2 - \\mathbf{r}_1)$ and $\\nabla_{\\mathbf{r}_2}\\phi = 2(\\mathbf{r}_2 - \\mathbf{r}_1)$.\n    The corrections are $\\delta\\mathbf{r}_i^{(k)} = \\lambda_k \\frac{1}{m_i} \\nabla_{\\mathbf{r}_i}\\phi^{(k)}$, where $\\lambda_k$ is a single Lagrange multiplier for the constraint.\n\n    To find $\\lambda_k$, we linearize the constraint equation around the current iterate $\\mathbf{r}^{(k)}$:\n    $$ \\phi(\\mathbf{r}^{(k+1)}) \\approx \\phi(\\mathbf{r}^{(k)}) + \\sum_{i=1}^2 \\nabla_{\\mathbf{r}_i}\\phi^{(k)} \\cdot \\delta\\mathbf{r}_i^{(k)} = 0 $$\n    Substituting the expression for $\\delta\\mathbf{r}_i^{(k)}$:\n    $$ \\phi^{(k)} + \\lambda_k \\sum_{i=1}^2 \\frac{1}{m_i} \\lVert \\nabla_{\\mathbf{r}_i}\\phi^{(k)} \\rVert^2 = 0 $$\n    Letting $\\mathbf{r}_{12}^{(k)} = \\mathbf{r}_2^{(k)} - \\mathbf{r}_1^{(k)}$, we have $\\lVert\\nabla_{\\mathbf{r}_1}\\phi\\rVert^2 = \\lVert\\nabla_{\\mathbf{r}_2}\\phi\\rVert^2 = 4\\lVert\\mathbf{r}_{12}^{(k)}\\rVert^2$. The denominator becomes $4\\lVert\\mathbf{r}_{12}^{(k)}\\rVert^2 (\\frac{1}{m_1} + \\frac{1}{m_2})$.\n    Solving for $\\lambda_k$:\n    $$ \\lambda_k = - \\frac{\\phi^{(k)}}{4 \\lVert\\mathbf{r}_{12}^{(k)}\\rVert^2 \\left(\\frac{1}{m_1} + \\frac{1}{m_2}\\right)} $$\n    The iterative update rule is thus:\n    $$ \\mathbf{r}_1^{(k+1)} = \\mathbf{r}_1^{(k)} - 2\\lambda_k \\frac{1}{m_1}\\mathbf{r}_{12}^{(k)} $$\n    $$ \\mathbf{r}_2^{(k+1)} = \\mathbf{r}_2^{(k)} + 2\\lambda_k \\frac{1}{m_2}\\mathbf{r}_{12}^{(k)} $$\n    This process is repeated until $|\\phi^{(k)}| \\le \\varepsilon$. The number of iterations $k$ is tracked. The final corrected positions are denoted $\\mathbf{r}_i(n+1)$.\n\n3.  **Velocity Correction (RATTLE Algorithm)**: After obtaining the corrected positions $\\mathbf{r}_i(n+1)$, the velocities must be updated. A temporary velocity $\\mathbf{v}_i'$ is first calculated consistent with the position change:\n    $$ \\mathbf{v}_i' = \\frac{\\mathbf{r}_i(n+1) - \\mathbf{r}_i(n)}{h} $$\n    These velocities do not necessarily satisfy the velocity-level constraint $\\dot{\\phi}=0$. A correction $\\delta\\mathbf{v}_i$ is added, analogous to the SHAKE correction: $\\mathbf{v}_i(n+1) = \\mathbf{v}_i' + \\delta\\mathbf{v}_i$. The correction is $\\delta\\mathbf{v}_i = \\gamma \\frac{1}{m_i} \\nabla_{\\mathbf{r}_i}\\phi(n+1)$, where $\\gamma$ is another Lagrange multiplier.\n\n    We enforce $\\dot{\\phi}(n+1) = \\sum_{i=1}^2 \\nabla_{\\mathbf{r}_i}\\phi(n+1) \\cdot \\mathbf{v}_i(n+1) = 0$.\n    $$ \\sum_{i=1}^2 \\nabla_{\\mathbf{r}_i}\\phi \\cdot \\mathbf{v}_i' + \\gamma \\sum_{i=1}^2 \\frac{1}{m_i} \\lVert\\nabla_{\\mathbf{r}_i}\\phi\\rVert^2 = 0 $$\n    Letting $\\mathbf{r}_{12}(n+1) = \\mathbf{r}_2(n+1) - \\mathbf{r}_1(n+1)$, the first term is $2\\mathbf{r}_{12}(n+1) \\cdot (\\mathbf{v}_2'-\\mathbf{v}_1')$. The corrected positions satisfy $\\lVert\\mathbf{r}_{12}(n+1)\\rVert^2 \\approx d^2$.\n    Solving for $\\gamma$:\n    $$ \\gamma = - \\frac{2\\mathbf{r}_{12}(n+1) \\cdot (\\mathbf{v}_2' - \\mathbf{v}_1')}{4d^2\\left(\\frac{1}{m_1} + \\frac{1}{m_2}\\right)} $$\n    The final velocities for the next time step are:\n    $$ \\mathbf{v}_1(n+1) = \\mathbf{v}_1' - \\frac{2\\gamma}{m_1}\\mathbf{r}_{12}(n+1) $$\n    $$ \\mathbf{v}_2(n+1) = \\mathbf{v}_2' + \\frac{2\\gamma}{m_2}\\mathbf{r}_{12}(n+1) $$\n\nThis entire sequence (Predict-Correct-Correct) comprises one time step. The simulation is run for $T$ steps for each mass combination, and the maximum number of SHAKE iterations is recorded. The extreme mass ratios in the test cases are expected to highlight numerical stiffness and potential degradation of convergence due to finite floating-point precision, where the corrective displacement for the heavy particle becomes vanishingly small compared to its position's magnitude.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Simulates a two-particle system with a rigid bond constraint using the\n    SHAKE and RATTLE algorithms and determines the maximum number of SHAKE\n    iterations required for various mass ratios.\n    \"\"\"\n    \n    # Define physical constants and simulation parameters\n    d = 1.0  # Bond length in meters\n    v0 = 1.0  # Initial velocity component in m/s\n    h = 0.01  # Time step in seconds\n    T_steps = 50  # Total number of time steps\n    tolerance = 1e-12  # Constraint tolerance in m^2\n\n    # Test cases for masses (m1, m2) in kg\n    test_cases = [\n        (1.0, 1.0),\n        (1000.0, 1.0),\n        (1.0e8, 1.0),\n        (1.0e12, 1.0),\n    ]\n\n    results = []\n\n    for m1, m2 in test_cases:\n        # Convert masses to numpy float64 for consistent calculations\n        m1_np = np.float64(m1)\n        m2_np = np.float64(m2)\n        inv_m1 = np.float64(1.0) / m1_np\n        inv_m2 = np.float64(1.0) / m2_np\n\n        # Initial conditions for positions and velocities\n        r1 = np.array([0.0, 0.0, 0.0], dtype=np.float64)\n        r2 = np.array([d, 0.0, 0.0], dtype=np.float64)\n        v1 = np.array([0.0, v0, 0.0], dtype=np.float64)\n        v2 = np.array([0.0, -v0, 0.0], dtype=np.float64)\n\n        max_iterations = 0\n\n        # Main simulation loop\n        for _ in range(T_steps):\n            r1_old, r2_old = r1.copy(), r2.copy()\n\n            # --- 1. Position Prediction (Free-flight) ---\n            # r_i* = r_i(n) + h * v_i(n)\n            r1_pred = r1 + h * v1\n            r2_pred = r2 + h * v2\n\n            # --- 2. Position Correction (SHAKE) ---\n            shake_iterations = 0\n            r1_corr, r2_corr = r1_pred.copy(), r2_pred.copy()\n            \n            while True:\n                r12 = r2_corr - r1_corr\n                r12_sq = np.dot(r12, r12)\n                phi = r12_sq - d*d\n\n                if np.abs(phi) <= tolerance:\n                    break\n                \n                shake_iterations += 1\n                \n                # Calculate Lagrange multiplier lambda\n                # Grad_r1(phi) = -2*r12, Grad_r2(phi) = 2*r12\n                # Denominator term: (1/m1)*||Grad_r1||^2 + (1/m2)*||Grad_r2||^2\n                # = (inv_m1 * 4 * r12_sq) + (inv_m2 * 4 * r12_sq)\n                # = 4 * r12_sq * (inv_m1 + inv_m2)\n                denominator = 4.0 * r12_sq * (inv_m1 + inv_m2)\n\n                # Avoid division by zero, though unlikely in this problem\n                if denominator == 0:\n                    break\n\n                lagrange_lambda = -phi / denominator\n\n                # Update positions\n                # delta_r1 = lambda * (1/m1) * Grad_r1(phi)\n                # delta_r2 = lambda * (1/m2) * Grad_r2(phi)\n                r1_corr += lagrange_lambda * inv_m1 * (-2.0 * r12)\n                r2_corr += lagrange_lambda * inv_m2 * (2.0 * r12)\n\n            if shake_iterations > max_iterations:\n                max_iterations = shake_iterations\n            \n            # Final corrected positions for the time step\n            r1, r2 = r1_corr, r2_corr\n\n            # --- 3. Velocity Correction (RATTLE) ---\n            # First, compute uncorrected velocities\n            v1_prime = (r1 - r1_old) / h\n            v2_prime = (r2 - r2_old) / h\n            \n            # Constraint at velocity level: Grad_phi . v = 0\n            # Grad_r1 . v1 + Grad_r2 . v2 = 0\n            # Solve for Lagrange multiplier gamma\n            r12_final = r2 - r1\n            v12_prime = v2_prime - v1_prime\n            \n            # Numerator term: Grad_r1 . v1' + Grad_r2 . v2'\n            # = -2 * r12_final . v1' + 2 * r12_final . v2'\n            # = 2 * r12_final . (v2' - v1')\n            numerator_gamma = 2.0 * np.dot(r12_final, v12_prime)\n            \n            # Denominator is same form as in SHAKE, evaluated at final positions\n            # Here, r12_sq is guaranteed to be d*d to high precision\n            denominator_gamma = 4.0 * d*d * (inv_m1 + inv_m2)\n\n            if denominator_gamma == 0: # Failsafe\n                lagrange_gamma = 0.0\n            else:\n                lagrange_gamma = -numerator_gamma / denominator_gamma\n            \n            # Update velocities\n            v1 = v1_prime + lagrange_gamma * inv_m1 * (-2.0 * r12_final)\n            v2 = v2_prime + lagrange_gamma * inv_m2 * (2.0 * r12_final)\n        \n        results.append(max_iterations)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2436786"}, {"introduction": "Beyond simply holding a molecule together, constraint algorithms play a profound role in the long-term stability of a simulation. This exercise explores the connection between the RATTLE velocity constraint, time-reversibility, and energy conservation. By simulating a simple pendulum [@problem_id:2436781] and intentionally relaxing the velocity constraint tolerance, you will directly observe how failing to precisely satisfy the velocity-level constraint breaks the algorithm's underlying geometric structure, leading to unphysical energy drift.", "problem": "Implement and analyze a symplectic constrained integrator for a single particle of mass $m$ constrained to move on a circle of radius $L$ in a uniform gravitational field of magnitude $g$. Use the SHAKE and RATTLE constraint algorithms, focusing on how asymmetric tolerances between the position and velocity constraint solvers influence long-time energy behavior.\n\nStart from the following fundamental base:\n- Newton's second law for a particle, $m\\,\\mathrm{d}^{2}\\mathbf{q}/\\mathrm{d}t^{2}=\\mathbf{f}(\\mathbf{q})$, with $\\mathbf{q}\\in\\mathbb{R}^{2}$ and $\\mathbf{f}(\\mathbf{q})$ the non-constraint force.\n- A holonomic constraint $g(\\mathbf{q})=0$ with gradient $\\mathbf{G}(\\mathbf{q})=\\nabla g(\\mathbf{q})$, enforced via Lagrange multipliers so that the instantaneous velocity obeys $\\mathbf{G}(\\mathbf{q})\\cdot\\mathbf{v}=0$.\n- The Velocity Verlet update as the base integrator.\n\nPhysical model and constants:\n- A single point mass with $m=1\\,\\mathrm{kg}$ constrained to the circle $g(\\mathbf{q})=\\mathbf{q}\\cdot\\mathbf{q}-L^{2}=0$ of radius $L=1\\,\\mathrm{m}$ centered at the origin, subject to uniform gravity $\\mathbf{f}(\\mathbf{q})=(0,-m g)$ with $g=9.81\\,\\mathrm{m/s^{2}}$.\n- All physical quantities must be treated in International System of Units (SI). Angles must be in radians.\n\nInitial conditions:\n- Choose the initial angle $\\theta_{0}=\\pi/3$ and set the initial position $\\mathbf{q}_{0}=(L\\sin\\theta_{0},-L\\cos\\theta_{0})$ so that $g(\\mathbf{q}_{0})=0$ holds exactly.\n- Choose the initial velocity $\\mathbf{v}_{0}=(0,0)$, which satisfies $\\mathbf{G}(\\mathbf{q}_{0})\\cdot\\mathbf{v}_{0}=0$.\n\nIntegrator to implement:\n- Use a time step $\\Delta t=1\\times 10^{-3}\\,\\mathrm{s}$ and integrate for a total time $T=1\\times 10^{1}\\,\\mathrm{s}$.\n- The unconstrained force is $\\mathbf{f}(\\mathbf{q})=(0,-m g)$ and the potential energy is $V(\\mathbf{q})=m g\\,y$, where $y$ is the vertical coordinate of $\\mathbf{q}=(x,y)$. The kinetic energy is $K(\\mathbf{v})=\\tfrac{1}{2}m\\,\\mathbf{v}\\cdot\\mathbf{v}$, and the total mechanical energy is $E=K+V$.\n- Implement Velocity Verlet with SHAKE and RATTLE:\n  1. Predict position: $\\tilde{\\mathbf{q}}=\\mathbf{q}_{n}+\\Delta t\\,\\mathbf{v}_{n}+\\tfrac{1}{2}\\Delta t^{2}\\,\\mathbf{a}(\\mathbf{q}_{n})$, where $\\mathbf{a}(\\mathbf{q})=\\mathbf{f}(\\mathbf{q})/m$.\n  2. Apply SHAKE to enforce $g(\\mathbf{q}_{n+1})=0$ by solving for a correction $\\delta\\mathbf{q}$ along $-M^{-1}\\mathbf{G}^{\\top}$ (with $M=m I$) via linearization about the current iterate. Terminate when $|g(\\mathbf{q}_{n+1})|\\le \\varepsilon_{p}$, where $\\varepsilon_{p}$ is the position tolerance.\n  3. Compute $\\mathbf{a}(\\mathbf{q}_{n+1})$ and the unconstrained velocity update $\\tilde{\\mathbf{v}}=\\mathbf{v}_{n}+\\tfrac{1}{2}\\Delta t\\left[\\mathbf{a}(\\mathbf{q}_{n})+\\mathbf{a}(\\mathbf{q}_{n+1})\\right]$.\n  4. Apply RATTLE to enforce the velocity constraint $\\mathbf{G}(\\mathbf{q}_{n+1})\\cdot\\mathbf{v}_{n+1}=0$ using an iterative linear solve for the Lagrange multiplier. Specifically, define the residual $r=\\mathbf{G}(\\mathbf{q}_{n+1})\\cdot\\mathbf{v}$ and the scalar $A=\\mathbf{G}(\\mathbf{q}_{n+1})\\cdot M^{-1}\\mathbf{G}(\\mathbf{q}_{n+1})$, and iterate a Richardson update for the multiplier with a fixed step factor $\\theta=1/2$: update $\\mathbf{v}\\leftarrow \\mathbf{v}-M^{-1}\\mathbf{G}^{\\top}\\,\\alpha\\,r$ with $\\alpha=\\theta/A$, recomputing $r$ at each iteration, and stop when $|r|\\le \\varepsilon_{v}$, where $\\varepsilon_{v}$ is the velocity tolerance. This construct makes the velocity solve inexact when $\\varepsilon_{v}$ is loose, so that residuals persist.\n\nTask:\n- Implement the above algorithm in a single, complete, runnable program that performs the simulation and computes the absolute relative energy drift after the final time, defined as $\\left|E(T)-E(0)\\right|/E(0)$, which is dimensionless.\n- Investigate the breakdown of energy conservation by varying the velocity constraint tolerance $\\varepsilon_{v}$ while keeping the position tolerance $\\varepsilon_{p}$ tight. Use the following test suite of $(\\varepsilon_{p},\\varepsilon_{v})$ pairs:\n  - Test $1$: $(\\varepsilon_{p},\\varepsilon_{v})=(1\\times 10^{-10},1\\times 10^{-10})$.\n  - Test $2$: $(\\varepsilon_{p},\\varepsilon_{v})=(1\\times 10^{-10},1\\times 10^{-5})$.\n  - Test $3$: $(\\varepsilon_{p},\\varepsilon_{v})=(1\\times 10^{-10},1\\times 10^{-3})$.\n  - Test $4$: $(\\varepsilon_{p},\\varepsilon_{v})=(1\\times 10^{-10},1\\times 10^{-1})$.\n- For each test, run the simulation and compute the single float equal to the absolute relative energy drift at $t=T$. Aggregate the results in order.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example: $[r_{1},r_{2},r_{3},r_{4}]$, where each $r_{k}$ is the float for test $k$.", "solution": "The problem statement has been validated and is deemed valid. It presents a well-posed problem in computational physics, suitable for rigorous analysis. It is scientifically grounded, internally consistent, and requires the implementation of a standard, albeit specifically configured, numerical algorithm. The task is to simulate a constrained mechanical system—a simple pendulum—using the Velocity Verlet integrator combined with the SHAKE and RATTLE algorithms for constraint enforcement. The objective is to quantify the effect of inexact velocity constraint satisfaction on the long-term energy conservation of the system.\n\nThe system is a point mass $m$ moving in two dimensions $\\mathbf{q}=(x,y)$, subject to a uniform gravitational force $\\mathbf{f}=(0, -mg)$. The motion is restricted to a circle of radius $L$ centered at the origin. This represents a holonomic constraint, which can be expressed as an equation for the coordinates:\n$$\ng(\\mathbf{q}) = \\mathbf{q} \\cdot \\mathbf{q} - L^2 = 0\n$$\nThe gradient of this constraint function is $\\mathbf{G}(\\mathbf{q}) = \\nabla g(\\mathbf{q}) = 2\\mathbf{q}$. The equation of motion for this constrained system is given by Lagrange's equations of the first kind:\n$$\nm\\ddot{\\mathbf{q}} = \\mathbf{f} - \\lambda(t) \\mathbf{G}(\\mathbf{q})\n$$\nwhere $\\lambda(t)$ is a time-dependent Lagrange multiplier that determines the magnitude of the constraint force, which acts along the direction of the constraint gradient. Differentiating the constraint equation twice with respect to time leads to the velocity and acceleration constraints:\n$$\n\\frac{\\mathrm{d}g}{\\mathrm{d}t} = \\mathbf{G}(\\mathbf{q}) \\cdot \\dot{\\mathbf{q}} = 0\n$$\n$$\n\\frac{\\mathrm{d}^2g}{\\mathrm{d}t^2} = \\dot{\\mathbf{G}}(\\mathbf{q}) \\cdot \\dot{\\mathbf{q}} + \\mathbf{G}(\\mathbf{q}) \\cdot \\ddot{\\mathbf{q}} = 0\n$$\nNumerical integration of such a system requires special care to prevent the trajectory from violating the constraints due to discretization errors. The SHAKE and RATTLE algorithms are designed for this purpose, embedding constraint satisfaction directly into the steps of a Verlet-type integrator.\n\nThe core integrator is the Velocity Verlet algorithm. For a time step $\\Delta t$, it updates positions $\\mathbf{q}$ and velocities $\\mathbf{v}$ from time $t_n$ to $t_{n+1}$ as follows:\n$$\n\\mathbf{q}_{n+1} = \\mathbf{q}_n + \\Delta t \\, \\mathbf{v}_n + \\frac{1}{2}\\Delta t^2 \\mathbf{a}_n\n$$\n$$\n\\mathbf{v}_{n+1} = \\mathbf{v}_n + \\frac{1}{2}\\Delta t (\\mathbf{a}_n + \\mathbf{a}_{n+1})\n$$\nwhere $\\mathbf{a}_n = \\mathbf{F}_n / m$ is the acceleration at time $t_n$. When constraints are present, this basic scheme is modified. The total force $\\mathbf{F}_n$ includes both the external force $\\mathbf{f}_n$ and the constraint force $\\mathbf{F}_{c,n} = -\\lambda_n \\mathbf{G}(\\mathbf{q}_n)$. The Velocity Verlet with SHAKE and RATTLE algorithm decouples the integration of the unconstrained motion from the enforcement of the constraints, which are applied as projection steps.\n\nThe specified algorithm proceeds as follows for each time step:\n$1$. Predict the unconstrained position: Starting from a valid state $(\\mathbf{q}_n, \\mathbf{v}_n)$ that satisfies the constraints, an intermediate position $\\tilde{\\mathbf{q}}$ is calculated using only the external force $\\mathbf{f}(\\mathbf{q}_n)$. The acceleration is $\\mathbf{a}(\\mathbf{q}_n) = \\mathbf{f}(\\mathbf{q}_n)/m$.\n$$\n\\tilde{\\mathbf{q}} = \\mathbf{q}_n + \\Delta t \\, \\mathbf{v}_n + \\frac{1}{2}\\Delta t^2 \\mathbf{a}(\\mathbf{q}_n)\n$$\nThis predicted position $\\tilde{\\mathbf{q}}$ will generally not satisfy the position constraint, i.e., $g(\\tilde{\\mathbf{q}}) \\neq 0$.\n\n$2$. Apply SHAKE to correct the position: The SHAKE algorithm iteratively corrects $\\tilde{\\mathbf{q}}$ to find a final position $\\mathbf{q}_{n+1}$ that lies on the constraint manifold, i.e., $g(\\mathbf{q}_{n+1})=0$ within a specified tolerance $\\varepsilon_p$. The correction is applied along the constraint gradient. Starting with $\\mathbf{q}^{(0)} = \\tilde{\\mathbf{q}}$, the iteration is:\n$$\n\\mathbf{q}^{(k+1)} = \\mathbf{q}^{(k)} - \\Delta \\mathbf{q}^{(k)} \\quad \\text{where} \\quad \\Delta \\mathbf{q}^{(k)} = \\lambda^{(k)} m^{-1} \\mathbf{G}(\\mathbf{q}^{(k)})\n$$\nThe scalar $\\lambda^{(k)}$ is determined by linearizing the constraint equation: $g(\\mathbf{q}^{(k+1)}) \\approx g(\\mathbf{q}^{(k)}) - \\mathbf{G}(\\mathbf{q}^{(k)}) \\cdot \\Delta \\mathbf{q}^{(k)} = 0$. Substituting the form of $\\Delta \\mathbf{q}^{(k)}$ gives:\n$$\n\\lambda^{(k)} = m \\frac{g(\\mathbf{q}^{(k)})}{|\\mathbf{G}(\\mathbf{q}^{(k)})|^2}\n$$\nFor the specific constraint $g(\\mathbf{q}) = \\mathbf{q}\\cdot\\mathbf{q} - L^2$ and $m=1$, this simplifies to:\n$$\n\\mathbf{q}^{(k+1)} = \\mathbf{q}^{(k)} - \\frac{(\\mathbf{q}^{(k)}\\cdot\\mathbf{q}^{(k)}) - L^2}{2(\\mathbf{q}^{(k)}\\cdot\\mathbf{q}^{(k)})} \\mathbf{q}^{(k)}\n$$\nThis loop continues until $|g(\\mathbf{q}^{(k+1)})| \\le \\varepsilon_p$. This results in the final position $\\mathbf{q}_{n+1}$.\n\n$3$. Update velocity (unconstrained part): The unconstrained part of the velocity update uses the standard Velocity Verlet form, incorporating the force at the new, corrected position $\\mathbf{q}_{n+1}$.\n$$\n\\tilde{\\mathbf{v}} = \\mathbf{v}_n + \\frac{1}{2}\\Delta t (\\mathbf{a}(\\mathbf{q}_n) + \\mathbf{a}(\\mathbf{q}_{n+1}))\n$$\nThis intermediate velocity $\\tilde{\\mathbf{v}}$ will generally not satisfy the velocity constraint, i.e., $\\mathbf{G}(\\mathbf{q}_{n+1})\\cdot\\tilde{\\mathbf{v}} \\neq 0$.\n\n$4$. Apply RATTLE to correct the velocity: The RATTLE algorithm projects $\\tilde{\\mathbf{v}}$ onto the tangent plane of the constraint manifold at $\\mathbf{q}_{n+1}$ to find the final velocity $\\mathbf{v}_{n+1}$ that satisfies $\\mathbf{G}(\\mathbf{q}_{n+1})\\cdot\\mathbf{v}_{n+1}=0$ within a tolerance $\\varepsilon_v$. The problem specifies an iterative Richardson-type update scheme. Starting with $\\mathbf{v}^{(0)} = \\tilde{\\mathbf{v}}$, the iteration is:\n$$\n\\mathbf{v}^{(k+1)} = \\mathbf{v}^{(k)} - m^{-1} \\mathbf{G}(\\mathbf{q}_{n+1}) \\alpha r^{(k)}\n$$\nwhere the residual is $r^{(k)} = \\mathbf{G}(\\mathbf{q}_{n+1}) \\cdot \\mathbf{v}^{(k)}$ and the update factor is $\\alpha = \\theta / A$ with $\\theta=1/2$ and $A = \\mathbf{G}(\\mathbf{q}_{n+1}) \\cdot m^{-1} \\mathbf{G}(\\mathbf{q}_{n+1})$. For our system with $m=1$ and $L=1$, $|\\mathbf{q}_{n+1}|=L=1$. Thus, $\\mathbf{G}_{n+1}=2\\mathbf{q}_{n+1}$, and $A = |2\\mathbf{q}_{n+1}|^2 = 4|\\mathbf{q}_{n+1}|^2 = 4$. This gives $\\alpha = (1/2)/4 = 1/8$. The update rule is:\n$$\n\\mathbf{v}^{(k+1)} = \\mathbf{v}^{(k)} - \\mathbf{G}_{n+1} \\frac{1}{8} r^{(k)}\n$$\nThis loop continues until $|r^{(k)}| \\le \\varepsilon_v$. The final result is $\\mathbf{v}_{n+1}$.\n\nThe combination of Velocity Verlet with exact SHAKE and RATTLE corrections yields a symplectic and time-reversible integrator. Symplecticity implies that the algorithm conserves a \"shadow\" Hamiltonian, which is a slight perturbation of the true Hamiltonian. This leads to excellent long-term energy conservation, characterized by bounded fluctuations around the initial energy, but no systematic drift.\n\nThis desirable property hinges on the exact satisfaction of constraints at each step. In this problem, the position constraint tolerance $\\varepsilon_p$ is held at a very small value ($10^{-10}$), so the position constraint is effectively satisfied. However, the velocity constraint tolerance $\\varepsilon_v$ is varied from a small value to a large one. When $\\varepsilon_v$ is large, the RATTLE iterative solver terminates prematurely, leaving a non-zero residual in the velocity constraint, $\\mathbf{G}(\\mathbf{q}_{n+1}) \\cdot \\mathbf{v}_{n+1} \\neq 0$. This failure to enforce the velocity constraint exactly breaks the time-reversibility of the algorithm, which in turn destroys its symplecticity. A non-symplectic integrator does not conserve any shadow Hamiltonian and will typically exhibit a systematic drift in total energy over long-time simulations. The magnitude of this drift is expected to correlate strongly with the magnitude of the permitted constraint violation, i.e., with $\\varepsilon_v$. The simulation is designed to demonstrate and quantify this breakdown.\n\nFinally, the measure for energy degradation is the \"absolute relative energy drift\", defined in the problem as $\\left|E(T)-E(0)\\right|/E(0)$. The initial energy $E(0)$ is negative for the given initial conditions. A literal interpretation of this formula would yield a negative value for a positive drift $|E(T)-E(0)|$, which is scientifically nonsensical for a quantity described as an \"absolute drift\". Scientific and engineering convention dictates that a relative error or drift is a non-negative quantity. Therefore, the physically meaningful definition, $\\left|E(T)-E(0)\\right|/\\left|E(0)\\right|$, will be used for the computation. This is a necessary correction to maintain scientific rigor.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and analyzes a constrained integrator for a particle on a circle.\n    \n    This function sets up the physical model of a simple pendulum and simulates\n    its motion using a Velocity Verlet integrator augmented with SHAKE and RATTLE\n    constraint algorithms. It investigates how varying the tolerance of the\n    velocity constraint solver (RATTLE) affects long-term energy conservation.\n    The absolute relative energy drift is computed for a suite of test cases.\n    \"\"\"\n\n    def run_simulation(eps_p, eps_v):\n        \"\"\"\n        Runs a single simulation for given position and velocity tolerances.\n\n        Args:\n            eps_p (float): Tolerance for the SHAKE position constraint solver.\n            eps_v (float): Tolerance for the RATTLE velocity constraint solver.\n        \n        Returns:\n            float: The absolute relative energy drift after the simulation.\n        \"\"\"\n        # Physical model and constants (SI units)\n        m = 1.0  # kg\n        L = 1.0  # m\n        g_accel = 9.81  # m/s^2\n\n        # Simulation parameters\n        dt = 1.0e-3  # s\n        T = 10.0  # s\n        n_steps = int(T / dt)\n\n        # Initial conditions\n        theta_0 = np.pi / 3.0\n        q = np.array([L * np.sin(theta_0), -L * np.cos(theta_0)]) # position\n        v = np.array([0.0, 0.0]) # velocity\n\n        # Unconstrained force and acceleration (constant for uniform gravity)\n        force = np.array([0.0, -m * g_accel])\n        accel = force / m\n\n        # Energy calculation functions\n        def kinetic_energy(vel):\n            return 0.5 * m * np.dot(vel, vel)\n\n        def potential_energy(pos):\n            return m * g_accel * pos[1]\n\n        def total_energy(pos, vel):\n            return kinetic_energy(vel) + potential_energy(pos)\n\n        # Initial energy\n        E_initial = total_energy(q, v)\n\n        # Main time-stepping loop\n        for _ in range(n_steps):\n            q_n, v_n = q, v\n            a_n = accel # Acceleration is constant\n\n            # 1. Predict position (unconstrained)\n            q_tilde = q_n + dt * v_n + 0.5 * dt**2 * a_n\n\n            # 2. Apply SHAKE to enforce position constraint g(q) = q.q - L^2 = 0\n            q_k = q_tilde\n            # A max iteration count is good practice to prevent infinite loops\n            max_shake_iter = 10 \n            for _ in range(max_shake_iter):\n                g_k = np.dot(q_k, q_k) - L**2\n                if abs(g_k) <= eps_p:\n                    break\n                \n                # As derived in the solution text, for m=1\n                # q_k_plus_1 = q_k - (g_k / (2 * q_k.q_k)) * q_k\n                # Avoid division by zero if q_k is near origin (not possible here)\n                q_k_dot_q_k = np.dot(q_k, q_k)\n                if q_k_dot_q_k == 0:\n                    # This case should not be reached for this problem\n                    break \n                q_k = q_k - (g_k / (2.0 * q_k_dot_q_k)) * q_k\n            \n            q = q_k # Final position for this step\n\n            # 3. Compute unconstrained velocity update\n            a_n_plus_1 = accel # Acceleration is constant\n            v_tilde = v_n + 0.5 * dt * (a_n + a_n_plus_1)\n\n            # 4. Apply RATTLE to enforce velocity constraint G(q).v = 0\n            G_n_plus_1 = 2.0 * q\n            v_k = v_tilde\n            \n            # Precompute constant parts of the RATTLE iteration\n            # A = G.inv(M).G = |G|^2/m = (4*|q|^2)/m = 4*L^2/m\n            # For m=1, L=1, A=4. alpha = theta/A = (1/2)/4 = 1/8.\n            alpha_G = (1.0 / 8.0) * G_n_plus_1\n            \n            max_rattle_iter = 20 # Convergence is fast, but set a limit\n            for _ in range(max_rattle_iter):\n                r_k = np.dot(G_n_plus_1, v_k)\n                if abs(r_k) <= eps_v:\n                    break\n                v_k = v_k - alpha_G * r_k\n            \n            v = v_k # Final velocity for this step\n        \n        # Final energy\n        E_final = total_energy(q, v)\n        \n        # Calculate absolute relative energy drift, using abs(E_initial) for robustness.\n        # This corrects the ambiguity in the problem statement for a scientifically\n        # meaningful result, as explained in the solution text.\n        if abs(E_initial) == 0:\n             # Handle case of zero initial energy, though not applicable here\n            if abs(E_final) == 0:\n                return 0.0\n            else:\n                return np.inf # Or handle as an error\n        \n        energy_drift = abs(E_final - E_initial) / abs(E_initial)\n        \n        return energy_drift\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (1e-10, 1e-10),\n        (1e-10, 1e-5),\n        (1e-10, 1e-3),\n        (1e-10, 1e-1),\n    ]\n\n    results = []\n    for case in test_cases:\n        eps_p, eps_v = case\n        result = run_simulation(eps_p, eps_v)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # Format each result to a reasonable number of significant figures\n    # to maintain a clean output.\n    formatted_results = [f\"{r:.6e}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2436781"}]}