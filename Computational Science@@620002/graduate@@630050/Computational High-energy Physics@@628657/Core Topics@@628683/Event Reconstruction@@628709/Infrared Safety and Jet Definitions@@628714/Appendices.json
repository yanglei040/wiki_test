{"hands_on_practices": [{"introduction": "A primary goal in high-energy physics is to map the complex patterns of particles observed in a detector back to the fundamental quarks and gluons that produced them. This mapping is achieved through jet algorithms, but not all intuitive approaches are theoretically sound. This first exercise provides a crucial hands-on demonstration of why Infrared and Collinear (IRC) safety is a non-negotiable property for any reliable jet definition. By implementing and contrasting the modern, IRC-safe anti-$k_T$ algorithm with a simplified, historically-motivated cone algorithm, you will directly observe how the latter fails catastrophically under collinear particle splitting—a common occurrence in QCD—while the anti-$k_T$ algorithm remains robust [@problem_id:3517907].", "problem": "You are to write a complete, self-contained program that constructs a controlled collinear splitting scenario and numerically verifies collinear safety of anti-$k_{T}$ clustering against the instability of a seed-based cone algorithm when seeds are thresholded. Work in a massless approximation of final-state particles represented by transverse momentum, rapidity, and azimuth $(p_{T}, y, \\phi)$ with four-momentum defined by the usual relations. Use the Minkowski metric signature $(+,-,-,-)$ and the $E$-scheme recombination (four-vector summation).\n\nFundamental base and definitions to be used:\n- Use the Minkowski metric for jet mass squared, $m_{J}^{2} = \\left(\\sum_{i} p_{i}^{\\mu}\\right)^{2} = \\left(\\sum_{i} E_{i}\\right)^{2} - \\left\\|\\sum_{i} \\vec{p}_{i}\\right\\|^{2}$.\n- Model massless particles by the mapping between $(p_{T}, y, \\phi)$ and four-momentum components: $p_{x} = p_{T} \\cos\\phi$, $p_{y} = p_{T} \\sin\\phi$, $p_{z} = p_{T} \\sinh y$, $E = p_{T} \\cosh y$.\n- Use the rapidity–azimuth distance $\\Delta R = \\sqrt{(\\Delta y)^{2} + (\\Delta \\phi)^{2}}$, with $\\Delta \\phi$ defined as the minimal angle difference on the circle.\n- Implement the anti-$k_{T}$ sequential recombination algorithm with distance measures\n$$\nd_{ij} = \\min\\left(p_{T,i}^{-2}, p_{T,j}^{-2}\\right)\\,\\frac{\\Delta R_{ij}^{2}}{R^{2}}, \\quad d_{iB} = p_{T,i}^{-2},\n$$\nwhere $R$ is the jet radius parameter, using $E$-scheme recombination until all remaining objects are declared jets.\n- Implement a simplified seed-based iterative cone algorithm with a seed threshold $p_{T}^{\\text{seed}}$: seeds are all particles with $p_{T} \\ge p_{T}^{\\text{seed}}$; for each seed, build a cone of radius $R$ about an axis initialized at the seed direction; include all particles with $\\Delta R \\le R$; recompute the axis from the summed four-momentum; iterate until the axis is stable within a small tolerance; return all distinct stable cones as jets. If no seeds exist, the algorithm returns no jets.\n\nScenario to construct:\n- Consider an unsplit event $\\mathcal{E}_{0}$ consisting of a single massless particle with four-momentum $p^{\\mu}$ defined by $(p_{T,0}, y_{0}, \\phi_{0})$.\n- Construct a split event $\\mathcal{E}_{\\text{split}}$ by replacing $p^{\\mu}$ with two collinear daughters with momenta $z\\,p^{\\mu}$ and $(1-z)\\,p^{\\mu}$, separated by a small but controlled rapidity–azimuth distance $\\Delta R$. To parameterize the separation while preserving the net axis approximately, place the daughters at $(y_{0} - \\Delta R/2, \\phi_{0})$ and $(y_{0} + \\Delta R/2, \\phi_{0})$ with transverse momenta $z\\,p_{T,0}$ and $(1-z)\\,p_{T,0}$ respectively. In the exact collinear limit, take $\\Delta R = 0$ by placing both daughters at $(y_{0}, \\phi_{0})$.\n\nRequired computations:\n- For each event, cluster jets with anti-$k_{T}$ with radius $R$ and compute the leading jet mass squared $m_{J}^{2}$ in $\\text{GeV}^{2}$ using the $E$-scheme four-vector sum of the jet’s constituents.\n- Repeat with the seed-based cone algorithm using the same $R$ and a seed threshold $p_{T}^{\\text{seed}}$. If the algorithm returns no jets, treat the leading jet mass squared as undefined for purposes of comparison.\n- Quantify collinear safety for anti-$k_{T}$ by the absolute difference\n$$\n\\Delta m^{2}_{\\text{anti-}k_{T}} = \\left| m_{J}^{2}\\left(\\mathcal{E}_{\\text{split}}\\right) - m_{J}^{2}\\left(\\mathcal{E}_{0}\\right) \\right|,\n$$\nand declare it numerically invariant if $\\Delta m^{2}_{\\text{anti-}k_{T}} \\le \\varepsilon$, where $\\varepsilon$ is a numerical tolerance.\n- Quantify the seed-based cone behavior by\n$$\n\\Delta m^{2}_{\\text{cone}} = \\left| m_{J}^{2}\\left(\\mathcal{E}_{\\text{split}}\\right) - m_{J}^{2}\\left(\\mathcal{E}_{0}\\right) \\right|\n$$\nif both masses are defined; otherwise, if the split event returns no jets, set a sentinel value of $-1$ to indicate instability due to missing seeds.\n\nUnits and angles:\n- Use energies in $\\text{GeV}$ and report jet mass squared in $\\text{GeV}^{2}$.\n- Use angles in radians.\n\nNumerical parameters:\n- Use $R = 0.4$, $p_{T,0} = 100\\,\\text{GeV}$, $(y_{0}, \\phi_{0}) = (0, 0)$, $p_{T}^{\\text{seed}} = 65\\,\\text{GeV}$, and numerical tolerance $\\varepsilon = 10^{-12}\\,\\text{GeV}^{2}$.\n\nTest suite:\nFor each tuple $(z, \\Delta R)$ below, construct $\\mathcal{E}_{0}$ and $\\mathcal{E}_{\\text{split}}$ as described, compute the quantities above for both algorithms, and record the results.\n\n- Test $1$ (happy path, clear seed instability): $(z, \\Delta R) = (0.6, 0.0)$.\n- Test $2$ (asymmetric split with a surviving seed): $(z, \\Delta R) = (0.9, 10^{-6})$.\n- Test $3$ (symmetric small but finite separation): $(z, \\Delta R) = (0.5, 10^{-3})$.\n- Test $4$ (boundary at the seed threshold): $(z, \\Delta R) = (0.65, 10^{-6})$.\n- Test $5$ (nonzero separation well within the cone): $(z, \\Delta R) = (0.6, 0.2)$.\n\nAnswer specification:\n- For each test, the program must output a three-element list $[\\Delta m^{2}_{\\text{anti-}k_{T}}, \\Delta m^{2}_{\\text{cone}} \\text{ or } -1.0, \\text{invariance}]$, where the third element is a boolean equal to $\\text{True}$ if $\\Delta m^{2}_{\\text{anti-}k_{T}} \\le \\varepsilon$ and $\\text{False}$ otherwise.\n- Aggregate the five per-test lists into a single list in the original order of tests.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is itself a three-element list in the order specified (for example, $[[a_{1},b_{1},c_{1}],[a_{2},b_{2},c_{2}],\\dots]$). All jet mass-squared values must be floats representing $\\text{GeV}^{2}$, and the invariance flag must be a boolean.", "solution": "The problem requires an analysis of collinear safety for two distinct jet clustering algorithms: the sequential recombination anti-$k_T$ algorithm and a simplified seed-based iterative cone algorithm. We are tasked with constructing a controlled collinear splitting scenario and numerically verifying the expected behavior of each algorithm.\n\n**1. Theoretical Framework and Definitions**\n\nWe operate in the massless particle approximation, where each particle's state is defined by its transverse momentum $p_T$, rapidity $y$, and azimuthal angle $\\phi$. The four-momentum $p^\\mu = (E, p_x, p_y, p_z)$ is constructed using the relations:\n$$\np_x = p_T \\cos\\phi\n$$\n$$\np_y = p_T \\sin\\phi\n$$\n$$\np_z = p_T \\sinh y\n$$\n$$\nE = \\sqrt{p_x^2 + p_y^2 + p_z^2} = \\sqrt{p_T^2 + (p_T \\sinh y)^2} = p_T \\cosh y\n$$\nThe distance between particles in the rapidity-azimuth plane is given by $\\Delta R = \\sqrt{(\\Delta y)^2 + (\\Delta \\phi)^2}$, where $\\Delta \\phi$ is the shortest angular distance. The invariant mass squared of a jet $J$, composed of a set of constituent particles $\\{i\\}$, is computed using the $E$-scheme (four-vector summation) and the Minkowski metric with signature $(+,-,-,-)$:\n$$\nm_J^2 = P_J^\\mu P_{J, \\mu} = \\left(\\sum_i p_i^\\mu\\right)^2 = \\left(\\sum_i E_i\\right)^2 - \\left\\|\\sum_i \\vec{p}_i\\right\\|^2\n$$\n\n**2. Collinear Splitting Scenario**\n\nTo test for collinear safety, we compare an observable computed on an event $\\mathcal{E}_0$ with that computed on a modified event $\\mathcal{E}_{\\text{split}}$.\n- Event $\\mathcal{E}_0$: A single massless particle with four-momentum $p^\\mu$ corresponding to $(p_{T,0}, y_0, \\phi_0)$. A jet composed of a single massless particle has $m_J^2 = (p^\\mu)^2 = 0$.\n- Event $\\mathcal{E}_{\\text{split}}$: The particle $p^\\mu$ is replaced by two collinear daughters, $p_1^\\mu$ and $p_2^\\mu$. Their momenta are fractions $z$ and $(1-z)$ of the original particle's momentum, respectively. They are separated by a small distance $\\Delta R$. The specific parameterization is:\n  - Particle 1: $(p_T, y, \\phi) = (z p_{T,0}, y_0 - \\Delta R/2, \\phi_0)$\n  - Particle 2: $(p_T, y, \\phi) = ((1-z) p_{T,0}, y_0 + \\Delta R/2, \\phi_0)$\n\nAn observable is **collinear safe** if its value on $\\mathcal{E}_{\\text{split}}$ smoothly approaches its value on $\\mathcal{E}_0$ as the splitting separation $\\Delta R \\to 0$.\n\n**3. Algorithm Design and Expected Behavior**\n\n**Anti-$k_T$ Algorithm:**\nThis is a sequential recombination algorithm. It iteratively merges the pair of objects (particles or proto-jets) that has the smallest distance, until all objects are separated by a distance larger than a threshold related to the beam distance. The distances are:\n$$\nd_{ij} = \\min\\left(p_{T,i}^{-2}, p_{T,j}^{-2}\\right)\\,\\frac{\\Delta R_{ij}^{2}}{R^{2}}, \\quad d_{iB} = p_{T,i}^{-2}\n$$\nIn our scenario with two close-by particles, $\\Delta R_{12} = \\Delta R$. For any configuration where $\\Delta R  R$, the inter-particle distance $d_{12}$ will be smaller than the beam distances $d_{1B}$ and $d_{2B}$. Thus, the two daughters will be merged first. The resulting jet will have a four-momentum $P_J^\\mu = p_1^\\mu + p_2^\\mu$. The invariant mass squared of this jet can be calculated analytically. With $y_0 = 0$ and $\\phi_0=0$:\n$$\nm_J^2(\\mathcal{E}_{\\text{split}}) = 4z(1-z) p_{T,0}^2 \\sinh^2(\\Delta R/2)\n$$\nAs $\\Delta R \\to 0$, $m_J^2(\\mathcal{E}_{\\text{split}}) \\to 0$, which is exactly $m_J^2(\\mathcal{E}_0)$. This demonstrates that the jet mass from the anti-$k_T$ algorithm is a collinear-safe observable. A numerical test is performed by checking if $\\Delta m^2_{\\text{anti-}k_T} = |m_J^2(\\mathcal{E}_{\\text{split}}) - m_J^2(\\mathcal{E}_0)| \\le \\varepsilon$ for a small tolerance $\\varepsilon$. For any finite $\\Delta R > 0$, we expect this difference to be non-zero and likely larger than a very small $\\varepsilon$, but for $\\Delta R = 0$, it must be exactly zero.\n\n**Seed-Based Cone Algorithm:**\nThis algorithm is fundamentally different. It seeks stable cones of particles around high-$p_T$ \"seeds\".\n1. Identify all particles with $p_T \\ge p_T^{\\text{seed}}$. These are the seeds.\n2. If no seeds exist, no jets are found.\n3. For each seed, iterate: form a cone of radius $R$ around an axis, sum the momenta of particles within it, and use the direction of this sum as the new axis. The process stops when the axis is stable.\n\nThis algorithm is expected to be **collinear unsafe**. Consider the splitting of a particle with $p_T > p_T^{\\text{seed}}$ into two daughters, both with $p_T  p_T^{\\text{seed}}$.\n- In $\\mathcal{E}_0$, the single particle is a seed, and a jet is found.\n- In $\\mathcal{E}_{\\text{split}}$, neither daughter particle qualifies as a seed. The algorithm finds no seeds and thus returns no jets.\nThe result of the jet finding abruptly changes from one jet to zero jets upon an infinitesimal change in the event (the splitting), which is the hallmark of an unsafe algorithm. This will be signaled by a sentinel value of $-1$. If a seed survives the split, the algorithm will find a jet, and the mass difference $\\Delta m^2_{\\text{cone}}$ can be computed, typically yielding a result similar to anti-$k_T$ as the cone will contain both collinear daughters.\n\n**4. Implementation Strategy**\n\nWe will implement helper functions to manage four-vector conversions and kinematic calculations. The two jet algorithms will be implemented as separate functions. The main program will loop through the specified test cases. For each case, it will construct $\\mathcal{E}_0$ and $\\mathcal{E}_{\\text{split}}$, apply both algorithms, compute the leading jet mass squared, and then calculate the required quantities $\\Delta m^2_{\\text{anti-}k_T}$, its invariance status, and $\\Delta m^2_{\\text{cone}}$ (or the sentinel value). The final results will be aggregated into a list of lists as specified.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the jet algorithm safety analysis.\n    \"\"\"\n    # Global parameters\n    R = 0.4\n    PT0 = 100.0  # GeV\n    Y0, PHI0 = 0.0, 0.0\n    PT_SEED = 65.0  # GeV\n    EPSILON = 1e-12  # GeV^2\n\n    CONE_STABILITY_TOL = 1e-9\n\n    # Test suite\n    test_cases = [\n        # (z, DeltaR)\n        (0.6, 0.0),\n        (0.9, 1e-6),\n        (0.5, 1e-3),\n        (0.65, 1e-6),\n        (0.6, 0.2),\n    ]\n\n    # Helper class for particles\n    class Particle:\n        def __init__(self, pt, y, phi):\n            self.pt = pt\n            self.y = y\n            self.phi = phi\n            self.pmu = self.to_pmu()\n\n        def to_pmu(self):\n            px = self.pt * np.cos(self.phi)\n            py = self.pt * np.sin(self.phi)\n            pz = self.pt * np.sinh(self.y)\n            e = self.pt * np.cosh(self.y)\n            return np.array([e, px, py, pz])\n\n        @staticmethod\n        def from_pmu(pmu):\n            e, px, py, pz = pmu\n            pt = np.sqrt(px**2 + py**2)\n            if pt  1e-15:\n                return 0.0, 0.0, 0.0\n            \n            # Rapidity y = 0.5 * log((E+pz)/(E-pz))\n            # phi = atan2(py, px)\n            if e + pz = 0 or e - pz = 0:\n                y = 0.0 # handle potential numerical issues for very specific kinematics\n            else:\n                y = 0.5 * np.log((e + pz) / (e - pz))\n                \n            phi = np.arctan2(py, px)\n            return pt, y, phi\n\n    # Kinematic helpers\n    def delta_phi(phi1, phi2):\n        dphi = phi1 - phi2\n        while dphi  np.pi: dphi -= 2 * np.pi\n        while dphi = -np.pi: dphi += 2 * np.pi\n        return dphi\n\n    def delta_R2(y1, phi1, y2, phi2):\n        dy = y1 - y2\n        dphi = delta_phi(phi1, phi2)\n        return dy**2 + dphi**2\n\n    def get_jet_mass_sq(pmu_sum):\n        return pmu_sum[0]**2 - pmu_sum[1]**2 - pmu_sum[2]**2 - pmu_sum[3]**2\n\n    # Algorithm implementations\n    def anti_kt_cluster(particles):\n        protojets = {i: p.pmu for i, p in enumerate(particles)}\n        protojets_coords = {i: (p.y, p.phi, p.pt) for i, p in enumerate(particles)}\n        jets = []\n        \n        while protojets:\n            min_dist = np.inf\n            merge_pair = None # (i, j)\n            beam_jet_idx = None # i\n            \n            ids = list(protojets.keys())\n\n            # d_iB distances\n            for i in ids:\n                dist_ib = 1.0 / (protojets_coords[i][2]**2)\n                if dist_ib  min_dist:\n                    min_dist = dist_ib\n                    beam_jet_idx = i\n                    merge_pair = None\n            \n            # d_ij distances\n            for i in range(len(ids)):\n                for j in range(i + 1, len(ids)):\n                    id_i, id_j = ids[i], ids[j]\n                    y_i, phi_i, pt_i = protojets_coords[id_i]\n                    y_j, phi_j, pt_j = protojets_coords[id_j]\n                    \n                    dr2 = delta_R2(y_i, phi_i, y_j, phi_j)\n                    dist_ij = min(1.0/pt_i**2, 1.0/pt_j**2) * dr2 / R**2\n                    \n                    if dist_ij  min_dist:\n                        min_dist = dist_ij\n                        merge_pair = (id_i, id_j)\n                        beam_jet_idx = None\n\n            if beam_jet_idx is not None:\n                jets.append(protojets[beam_jet_idx])\n                del protojets[beam_jet_idx]\n                del protojets_coords[beam_jet_idx]\n            elif merge_pair:\n                i, j = merge_pair\n                pmu_i, pmu_j = protojets[i], protojets[j]\n                \n                new_pmu = pmu_i + pmu_j\n                new_pt, new_y, new_phi = Particle.from_pmu(new_pmu)\n                \n                del protojets[i]\n                del protojets_coords[i]\n                del protojets[j]\n                del protojets_coords[j]\n                \n                new_id = max(ids) + 1 if ids else 0\n                protojets[new_id] = new_pmu\n                protojets_coords[new_id] = (new_y, new_phi, new_pt)\n                \n        # Sort jets by pT and return\n        jets.sort(key=lambda pmu: Particle.from_pmu(pmu)[0], reverse=True)\n        return jets\n\n    def cone_cluster(particles):\n        seeds = [p for p in particles if p.pt = PT_SEED]\n        if not seeds:\n            return []\n\n        stable_cones_pmu = []\n        for seed in seeds:\n            axis_y, axis_phi = seed.y, seed.phi\n            \n            for _ in range(100): # max iterations\n                old_axis_y, old_axis_phi = axis_y, axis_phi\n                \n                constituents_pmu = np.array([0.0, 0.0, 0.0, 0.0])\n                for p in particles:\n                    if delta_R2(p.y, p.phi, axis_y, axis_phi) = R**2:\n                        constituents_pmu += p.pmu\n                \n                if constituents_pmu[0]  1e-15:\n                    # no particles in cone, rare but possible\n                    break\n                \n                _, new_y, new_phi = Particle.from_pmu(constituents_pmu)\n                axis_y, axis_phi = new_y, new_phi\n\n                if delta_R2(old_axis_y, old_axis_phi, axis_y, axis_phi)  CONE_STABILITY_TOL**2:\n                    break\n            \n            stable_cones_pmu.append(constituents_pmu)\n        \n        # Remove duplicate cones (very simple check for this problem)\n        unique_cones = []\n        for cone_pmu in stable_cones_pmu:\n            is_duplicate = False\n            for unique_pmu in unique_cones:\n                 if np.allclose(cone_pmu, unique_pmu):\n                    is_duplicate = True\n                    break\n            if not is_duplicate:\n                unique_cones.append(cone_pmu)\n        \n        unique_cones.sort(key=lambda pmu: Particle.from_pmu(pmu)[0], reverse=True)\n        return unique_cones\n\n\n    results = []\n    for z, delta_R in test_cases:\n        # Event E0: unsplit\n        event0 = [Particle(PT0, Y0, PHI0)]\n        \n        # Event E_split\n        p1 = Particle(z * PT0, Y0 - delta_R / 2, PHI0)\n        p2 = Particle((1 - z) * PT0, Y0 + delta_R / 2, PHI0)\n        event_split = [p1, p2]\n\n        # Process E0\n        jets0_akt = anti_kt_cluster(event0)\n        m2_0_akt = get_jet_mass_sq(jets0_akt[0]) if jets0_akt else 0.0\n        \n        jets0_cone = cone_cluster(event0)\n        m2_0_cone = get_jet_mass_sq(jets0_cone[0]) if jets0_cone else 0.0\n\n        # Process E_split\n        jets_split_akt = anti_kt_cluster(event_split)\n        m2_split_akt = get_jet_mass_sq(jets_split_akt[0]) if jets_split_akt else 0.0\n\n        jets_split_cone = cone_cluster(event_split)\n        m2_split_cone_defined = bool(jets_split_cone)\n        m2_split_cone = get_jet_mass_sq(jets_split_cone[0]) if m2_split_cone_defined else 0.0\n        \n        # Calculate differences\n        delta_m2_akt = abs(m2_split_akt - m2_0_akt)\n        invariance_akt = delta_m2_akt = EPSILON\n\n        if m2_split_cone_defined:\n            delta_m2_cone = abs(m2_split_cone - m2_0_cone)\n        else:\n            delta_m2_cone = -1.0\n            \n        results.append([float(delta_m2_akt), float(delta_m2_cone), invariance_akt])\n\n    # Final print statement\n    formatted_results = [f\"[{r[0]},{r[1]},{str(r[2]).lower()}]\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3517907"}, {"introduction": "Having established the critical need for IRC-safe algorithms, we now delve deeper into the mathematical principles that guarantee this property. The robustness of a sequential recombination algorithm is not accidental; it is encoded directly within its distance metric. This practice [@problem_id:3517894] empowers you to act as an algorithm designer, exploring a generalized distance measure $d_{ij} = \\min(p_{Ti}^{2p}, p_{Tj}^{2p}) (\\Delta R_{ij}/R)^{\\alpha}$. By systematically varying the angular exponent $\\alpha$, you will discover the precise conditions required for collinear safety, providing a first-principles understanding of why standard algorithms are constructed the way they are.", "problem": "Implement a sequential recombination jet algorithm with a generalized distance metric to study Infrared and Collinear (IRC) safety, starting from the established definition of sequential recombination and the general structure of jet algorithms used in high-energy physics. The fundamental base is the following:\n\n- Sequential recombination algorithms define pairwise distances and beam distances to iteratively cluster particles into jets. For particles labeled by indices $i$ and $j$, with transverse momenta $p_{Ti}$ and $p_{Tj}$, rapidities $y_i$ and $y_j$, and azimuthal angles $\\phi_i$ and $\\phi_j$, define the angular separation\n$$\n\\Delta R_{ij} \\equiv \\sqrt{(y_i - y_j)^2 + (\\phi_i - \\phi_j)^2},\n$$\nwhere all angles are in radians. The jet radius parameter is $R$.\n\n- The general family of distance measures is\n$$\nd_{ij} = \\min\\left(p_{Ti}^{2p},\\, p_{Tj}^{2p}\\right)\\,\\left(\\frac{\\Delta R_{ij}}{R}\\right)^{\\alpha}, \\qquad d_{iB} = p_{Ti}^{2p},\n$$\nwhere $p$ is the power index specifying the algorithm family (for example, $p=-1$ corresponds to the anti-$k_T$ algorithm) and $\\alpha$ is a generalized angular exponent. Standard generalized $k_T$ algorithms use $\\alpha=2$. Here you will consider $\\alpha \\neq 2$ and investigate the consequences for IRC safety.\n\n- The recombination scheme is the four-vector (so-called $E$-scheme) sum: when clustering $i$ and $j$, define massless four-vectors $(E,\\vec{p})$ from $(p_T, y, \\phi)$ using $E = p_T \\cosh y$, $p_x = p_T \\cos\\phi$, $p_y = p_T \\sin\\phi$, $p_z = p_T \\sinh y$, and recombine by summing four-vectors. The new protojet kinematics are recovered from the sum by $p_T = \\sqrt{p_x^2+p_y^2}$, $\\phi = \\operatorname{atan2}(p_y,p_x)$, and $y = \\tfrac{1}{2}\\ln\\left(\\frac{E+p_z}{E-p_z}\\right)$, assuming massless kinematics.\n\nDefinitions of safety to be tested:\n\n- Infrared safety: adding an arbitrarily soft particle (with $p_T \\to 0$) must not change the set of hard jets in the limit $p_T \\to 0$.\n\n- Collinear safety: replacing a particle by two collinear particles (with $\\Delta R \\to 0$) whose momenta sum to the original momentum must not change the final reconstructed jets in the limit $\\Delta R \\to 0$.\n\nAlgorithm task:\n\n1. Implement the inclusive sequential recombination algorithm specified above. At each step, compute all $d_{ij}$ and $d_{iB}$. Select the smallest distance. If it is a pairwise distance $d_{ij}$, recombine $i$ and $j$ by four-vector sum; if it is a beam distance $d_{iB}$, declare $i$ a final jet and remove it from the list of protojets. Iterate until no protojets remain.\n\n2. Implement two diagnostic tests for a given $(p,\\alpha,R)$:\n   - Infrared test: Cluster a base configuration and then cluster the same configuration with an added very soft particle of transverse momentum $\\epsilon p_T$ with $\\epsilon$ extremely small. Compare the two sets of hardest jets to verify that they coincide in the limit $\\epsilon \\to 0$ (numerically approximate this by using a very small $\\epsilon$ and numerical tolerances).\n   - Collinear test: Cluster a base configuration, then cluster a configuration obtained by replacing one hard particle with two nearly collinear particles whose vector sum equals the original particle and whose separation is very small. Compare the resulting jets to verify that they coincide in the limit $\\Delta R \\to 0$ (numerically approximate this by using a very small $\\Delta R$ and numerical tolerances).\n\n3. Numerical comparison protocol:\n   - Sort final jets by descending $p_T$ and compare the top $N$ jets (choose $N$ as specified below) between the two configurations for each test. Two jets are considered matching if their transverse momenta agree within a relative tolerance $\\delta_{p_T}$ and their axes agree within an angular tolerance $\\delta_R$ in $\\Delta R$.\n   - Use the following tolerances: $\\delta_{p_T} = 10^{-9}$ (dimensionless, relative) and $\\delta_R = 10^{-9}$ (radians). Use $\\epsilon = 10^{-12}$ for the infrared test soft transverse momentum fraction, and use a collinear splitting separation of $\\Delta R_{\\text{split}} = 10^{-6}$ with balanced azimuthal and rapidity offsets to achieve that separation.\n\nBase configurations:\n\n- Infrared test base configuration consists of two hard particles:\n  - Particle A: $(p_T, y, \\phi) = (100.0, 0.0, 0.0)$,\n  - Particle B: $(p_T, y, \\phi) = (80.0, 0.3, 1.8)$,\n  and the soft particle to be added:\n  - Particle S: $(p_T, y, \\phi) = (\\epsilon \\times 100.0, 0.1, 0.9)$.\n  Compare the top $N=2$ jets between the configurations with and without particle S.\n\n- Collinear test base configuration consists of two particles:\n  - Particle H: $(p_T, y, \\phi) = (100.0, 0.0, 0.0)$,\n  - Particle M: $(p_T, y, \\phi) = (50.0, 0.4, 2.5)$.\n  The collinear-split configuration replaces particle H by two particles $H_1$ and $H_2$ with $(p_T, y, \\phi) = (60.0, \\delta y, \\delta \\phi)$ and $(40.0, -\\delta y, -\\delta \\phi)$, chosen so that\n  $$\n  \\sqrt{(2\\delta y)^2 + (2\\delta \\phi)^2} = \\Delta R_{\\text{split}} = 10^{-6}.\n  $$\n  For concreteness, take $\\delta y = \\delta \\phi = \\Delta R_{\\text{split}}/(2\\sqrt{2})$. Compare the top $N=2$ jets between the unsplit and split configurations.\n\nTest suite and required outputs:\n\nEvaluate the two diagnostics for the following parameter sets, each specified by $(p,\\alpha,R)$:\n\n- Test $1$: $(p,\\alpha,R) = (-1.0, 2.0, 0.6)$.\n- Test $2$: $(p,\\alpha,R) = (-1.0, 1.0, 0.6)$.\n- Test $3$: $(p,\\alpha,R) = (-1.0, 0.0, 0.6)$.\n- Test $4$: $(p,\\alpha,R) = (-1.0, -1.0, 0.6)$.\n\nFor each test, compute an integer score\n$$\nS = 2 \\times I + C,\n$$\nwhere $I$ is $1$ if the infrared test passes and $0$ otherwise, and $C$ is $1$ if the collinear test passes and $0$ otherwise. Thus $S \\in \\{0,1,2,3\\}$, with $S=3$ meaning both infrared and collinear safety tests pass, $S=2$ meaning only infrared passes, $S=1$ meaning only collinear passes, and $S=0$ meaning both fail.\n\nYour program should produce a single line of output containing the scores for Tests $1$ through $4$ as a comma-separated list enclosed in square brackets (for example, \"[3,3,2,2]\"). Angles must be in radians. No physical unit conversion is required for $p_T$ because only dimensionless safety checks are performed. The output must be fully determined by the above specifications, without any user input.", "solution": "The goal is to assess Infrared and Collinear (IRC) safety for a generalized sequential recombination family parameterized by the power $p$ and a generalized angular exponent $\\alpha$ in the pairwise distance\n$$\nd_{ij} = \\min\\left(p_{Ti}^{2p},\\, p_{Tj}^{2p}\\right)\\left(\\frac{\\Delta R_{ij}}{R}\\right)^{\\alpha},\n$$\nwith beam distance $d_{iB} = p_{Ti}^{2p}$. The standard generalized $k_T$ family uses $\\alpha=2$; here, we explore $\\alpha \\neq 2$.\n\nPrinciples:\n\n1. Infrared safety requires that adding a particle with $p_T \\to 0$ not alter the set of hard jets in this limit. In a sequential recombination algorithm, the addition of an infinitesimally soft particle $s$ modifies the set of distances by adding $d_{sj}$ and $d_{sB}$. For $p0$ (for example, anti-$k_T$ with $p=-1$), $d_{sB} = p_{Ts}^{2p}$ is extremely large, while $d_{sj} = \\min(p_{Ts}^{2p}, p_{Tj}^{2p})(\\Delta R_{sj}/R)^{\\alpha} = p_{Tj}^{2p}(\\Delta R_{sj}/R)^{\\alpha}$ because $p_{Ts}^{2p}$ is large and $p_{Tj}^{2p}$ is small. The soft merges into some hard protojet before being declared a jet itself. The four-vector recombination changes the hard jet four-vector by an additive contribution that is suppressed by $p_{Ts}$; in the limit $p_{Ts} \\to 0$, this perturbation vanishes. Therefore, under mild conditions, the hard jets are stable in the infrared limit. Numerically, one must set a very small $\\epsilon$ and compare jets with strict tolerances.\n\n2. Collinear safety requires that if a particle splits into two with $\\Delta R \\to 0$ and whose momenta sum to the original, the clustering should first recombine the pair before any beam declaration, effectively undoing the splitting and recovering the original final jets. For the generalized measure,\n$$\nd_{ij} = \\min(p_{Ti}^{2p}, p_{Tj}^{2p})\\left(\\frac{\\Delta R_{ij}}{R}\\right)^{\\alpha}.\n$$\nThe distances to beam are $d_{iB} = p_{Ti}^{2p}$ and $d_{jB} = p_{Tj}^{2p}$. For collinear safety to hold robustly, one requires that $d_{ij}  \\min(d_{iB}, d_{jB})$ as $\\Delta R_{ij} \\to 0$. Equivalently,\n$$\n\\min(p_{Ti}^{2p}, p_{Tj}^{2p})\\left(\\frac{\\Delta R_{ij}}{R}\\right)^{\\alpha}  \\min(p_{Ti}^{2p}, p_{Tj}^{2p}).\n$$\nCanceling the common factor yields\n$$\n\\left(\\frac{\\Delta R_{ij}}{R}\\right)^{\\alpha}  1.\n$$\nFor $\\Delta R_{ij}/R  1$, this inequality is satisfied if and only if $\\alpha > 0$, violated for $\\alpha  0$, and marginal (equality) for $\\alpha = 0$. Thus, based on first principles, the generalized measure is collinear safe for $\\alpha > 0$ and fails collinear safety for $\\alpha \\le 0$ in the strict limit. The failure for $\\alpha=0$ appears as a degeneracy where the pairwise distance equals the smaller beam distance; in practice this degeneracy can be broken by perturbations and lead to non-robust clustering.\n\nAlgorithmic design:\n\n- Implement the inclusive clustering by computing all distances $d_{ij}$ and $d_{iB}$ at each step, selecting the minimum. If the minimum is a pairwise distance, combine by four-vector sum; if it is a beam distance, finalize that protojet as a jet.\n\n- Represent particles as massless four-vectors derived from $(p_T, y, \\phi)$ via $E = p_T \\cosh y$, $p_x = p_T \\cos\\phi$, $p_y = p_T \\sin\\phi$, and $p_z = p_T \\sinh y$. On recombination, sum $(E, \\vec{p})$ and reconstruct $(p_T, y, \\phi)$ via $p_T = \\sqrt{p_x^2+p_y^2}$, $\\phi = \\operatorname{atan2}(p_y,p_x)$, and $y = \\tfrac{1}{2}\\ln\\left(\\frac{E+p_z}{E-p_z}\\right)$, with small numerical safeguards to keep $E > |p_z|$.\n\nDiagnostics:\n\n- For the infrared test, cluster the base two-hard configuration with and without the added soft particle. Compare the top $N=2$ jets by checking that their $p_T$ values agree within a relative tolerance $\\delta_{p_T} = 10^{-9}$ and their axes agree within $\\delta_R = 10^{-9}$ in $\\Delta R$. The soft particle uses $\\epsilon = 10^{-12}$ relative to the hard scale. Passing this test yields $I=1$, failing yields $I=0$.\n\n- For the collinear test, cluster the two-particle base configuration and a split configuration where the $p_T=100.0$ particle is replaced by two nearly collinear particles of $p_T=60.0$ and $p_T=40.0$, separated by $\\Delta R_{\\text{split}}=10^{-6}$ by choosing $\\delta y = \\delta \\phi = \\Delta R_{\\text{split}}/(2\\sqrt{2})$. Compare the top $N=2$ jets using the same tolerances. Passing yields $C=1$, failing yields $C=0$.\n\nScoring and expected trends:\n\n- For $(p,\\alpha,R) = (-1.0, 2.0, 0.6)$ (anti-$k_T$ with standard angular exponent), both tests should pass, yielding $S=3$.\n\n- For $(p,\\alpha,R) = (-1.0, 1.0, 0.6)$, the collinear-safety inequality $(\\Delta R/R)^{\\alpha}  1$ holds for small $\\Delta R$ since $\\alpha>0$, so it should also be collinear safe; infrared safety is maintained, thus $S=3$.\n\n- For $(p,\\alpha,R) = (-1.0, 0.0, 0.6)$, the collinear-safety inequality becomes equality, indicating non-robustness. Numerically one may or may not detect a failure depending on subtle orderings, but the algorithm will objectively compare outcomes under the prescribed tolerances. If the clustering happens to be identical, $C=1$; if not, $C=0$.\n\n- For $(p,\\alpha,R) = (-1.0, -1.0, 0.6)$, the collinear-safety inequality is violated, so the split pair does not preferentially recombine before beam declarations; this typically changes the outcome and yields $C=0$. Infrared safety for sequential recombination with four-vector recombination is generally retained, so $I=1$ is expected. The program will confirm via the numerical checks.\n\nImplementation details:\n\n- The code computes distances exactly as specified and clusters until completion.\n\n- Jet comparison is done by matching the two lists of top-$N$ jets: sort by $p_T$, then check pairwise agreement using the specified tolerances.\n\n- The final output prints a single line with the list of integer scores $S = 2I + C$ for Tests $1$ through $4$.\n\nThis approach integrates the foundational definitions of IRC safety with the computational algorithm and provides a concrete, testable benchmark across parameter regimes, highlighting the degradation of collinear safety for $\\alpha \\le 0$ while affirming stability for $\\alpha > 0$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Utilities to convert between (pt, y, phi) and massless four-vectors (E, px, py, pz)\ndef ptyphi_to_four(pt, y, phi):\n    px = pt * np.cos(phi)\n    py = pt * np.sin(phi)\n    pz = pt * np.sinh(y)\n    E = pt * np.cosh(y)\n    return np.array([E, px, py, pz], dtype=float)\n\ndef four_to_ptyphi(four):\n    E, px, py, pz = four\n    pt = np.hypot(px, py)\n    phi = np.arctan2(py, px)\n    # Numerical safeguard: ensure E  |pz|\n    # If E = |pz| due to rounding, nudge slightly to avoid invalid rapidity.\n    tiny = 1e-18\n    if E = abs(pz):\n        # increase E minimally\n        E = abs(pz) + (abs(pz) + 1.0) * tiny\n    y = 0.5 * np.log((E + pz) / (E - pz))\n    return float(pt), float(y), float(phi)\n\ndef deltaR(y1, phi1, y2, phi2):\n    dphi = np.arctan2(np.sin(phi1 - phi2), np.cos(phi1 - phi2))\n    dy = y1 - y2\n    return np.hypot(dy, dphi)\n\n# Sequential recombination clustering with generalized metric\ndef cluster_jets(particles, p, alpha, R):\n    # particles: list of (pt, y, phi)\n    # Represent protojets as dictionaries holding both kinematics and 4-vector\n    protojets = []\n    for pt, y, phi in particles:\n        four = ptyphi_to_four(pt, y, phi)\n        protojets.append({\"pt\": pt, \"y\": y, \"phi\": phi, \"four\": four})\n\n    jets = []\n\n    # Predefine exponent calculation with care for alpha=0\n    def dij(pi, pj):\n        # Pairwise distance\n        pti = pi[\"pt\"]\n        ptj = pj[\"pt\"]\n        # min(pt^{2p})\n        wij = min(pti ** (2.0 * p), ptj ** (2.0 * p))\n        if alpha == 0.0:\n            ang = 1.0\n        else:\n            ang = (deltaR(pi[\"y\"], pi[\"phi\"], pj[\"y\"], pj[\"phi\"]) / R) ** alpha\n        return wij * ang\n\n    def diB(pi):\n        return pi[\"pt\"] ** (2.0 * p)\n\n    # Main clustering loop\n    while len(protojets)  0:\n        # Compute all distances and find global minimum\n        min_val = None\n        min_pair = None  # (i,j)\n        min_beam = None  # i\n        n = len(protojets)\n        # Pairwise\n        for i in range(n):\n            # Beam distance\n            di = diB(protojets[i])\n            if (min_val is None) or (di  min_val) or (di == min_val and min_beam is None and min_pair is not None):\n                min_val = di\n                min_beam = i\n                min_pair = None\n            # Pairwise distances\n            for j in range(i + 1, n):\n                dij_val = dij(protojets[i], protojets[j])\n                if (min_val is None) or (dij_val  min_val) or (dij_val == min_val and min_pair is None):\n                    min_val = dij_val\n                    min_pair = (i, j)\n                    min_beam = None\n\n        # Act on minimum\n        if min_pair is not None:\n            i, j = min_pair\n            # Recombine i and j by four-vector sum\n            fi = protojets[i][\"four\"]\n            fj = protojets[j][\"four\"]\n            fsum = fi + fj\n            pt_new, y_new, phi_new = four_to_ptyphi(fsum)\n            new = {\"pt\": pt_new, \"y\": y_new, \"phi\": phi_new, \"four\": fsum}\n            # Remove ji first to keep indices correct\n            for idx in sorted([i, j], reverse=True):\n                del protojets[idx]\n            protojets.append(new)\n        else:\n            # Beam declaration\n            i = min_beam\n            jets.append(protojets[i])\n            del protojets[i]\n\n    # Sort jets by pt descending\n    jets.sort(key=lambda J: -J[\"pt\"])\n    # Convert to simple tuples for comparison\n    jets_simple = [(J[\"pt\"], J[\"y\"], J[\"phi\"]) for J in jets]\n    return jets_simple\n\n# Matching utilities\ndef match_jets(jetsA, jetsB, N=2, rel_pt_tol=1e-9, dr_tol=1e-9):\n    # Compare top N jets from both lists\n    JA = jetsA[:N]\n    JB = jetsB[:N]\n    if len(JA) != len(JB):\n        return False\n    # Sort both by pt descending (already sorted in cluster_jets)\n    for (ptA, yA, phiA), (ptB, yB, phiB) in zip(JA, JB):\n        # Relative pt agreement\n        if ptA == 0.0 and ptB == 0.0:\n            pt_ok = True\n        else:\n            denom = max(ptA, ptB, 1e-30)\n            pt_ok = abs(ptA - ptB) / denom = rel_pt_tol\n        # Axis agreement\n        dr = deltaR(yA, phiA, yB, phiB)\n        if not (pt_ok and dr = dr_tol):\n            return False\n    return True\n\n# Infrared test\ndef infrared_test(p, alpha, R, eps=1e-12):\n    # Base configuration: two hard particles\n    base_particles = [\n        (100.0, 0.0, 0.0),\n        (80.0, 0.3, 1.8),\n    ]\n    # Add very soft particle scaled by eps relative to 100.0\n    soft_particle = (100.0 * eps, 0.1, 0.9)\n    jets_base = cluster_jets(base_particles, p, alpha, R)\n    jets_soft = cluster_jets(base_particles + [soft_particle], p, alpha, R)\n    # Compare top N=2 jets\n    return match_jets(jets_base, jets_soft, N=2, rel_pt_tol=1e-9, dr_tol=1e-9)\n\n# Collinear test\ndef collinear_test(p, alpha, R, dr_split=1e-6):\n    # Base configuration: one hard and one medium\n    base_particles = [\n        (100.0, 0.0, 0.0),       # H\n        (50.0, 0.4, 2.5),        # M\n    ]\n    # Split H into H1 and H2 with separation dr_split and balanced offsets\n    delta = dr_split / (2.0 * np.sqrt(2.0))\n    H1 = (60.0, delta, delta)\n    H2 = (40.0, -delta, -delta)\n    split_particles = [H1, H2, (50.0, 0.4, 2.5)]\n    jets_base = cluster_jets(base_particles, p, alpha, R)\n    jets_split = cluster_jets(split_particles, p, alpha, R)\n    # Compare top N=2 jets\n    return match_jets(jets_base, jets_split, N=2, rel_pt_tol=1e-9, dr_tol=1e-9)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case is (p, alpha, R)\n    test_cases = [\n        (-1.0, 2.0, 0.6),   # Test 1\n        (-1.0, 1.0, 0.6),   # Test 2\n        (-1.0, 0.0, 0.6),   # Test 3\n        (-1.0, -1.0, 0.6),  # Test 4\n    ]\n\n    results = []\n    for p, alpha, R in test_cases:\n        I = 1 if infrared_test(p, alpha, R, eps=1e-12) else 0\n        C = 1 if collinear_test(p, alpha, R, dr_split=1e-6) else 0\n        score = 2 * I + C\n        results.append(score)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3517894"}, {"introduction": "With a solid foundation in constructing IRC-safe jets, we can advance to analyzing their internal structure, a field known as jet substructure. This final practice addresses a subtle but vital point: even when using a safe jet algorithm, observables derived from the jet's constituents are not automatically safe themselves. You will construct an observable that is sensitive to the emission of arbitrarily soft particles and then implement a modern grooming procedure, Soft Drop, to restore its theoretical robustness [@problem_id:3517881]. This exercise serves as a practical introduction to the essential techniques used to mitigate contaminating radiation and reliably probe the physics within jets.", "problem": "You are asked to construct and analyze a collinear-safe but soft-unsafe event-shape observable using a simple, deterministic clustering model, and then to apply a grooming procedure to restore Sudakov safety. You will implement the Cambridge/Aachen clustering algorithm in a one-dimensional angular space and compute two observables from the resulting binary clustering tree: an ungroomed last-split momentum sharing fraction that is collinear safe but soft unsafe, and a groomed momentum sharing fraction using Soft Drop grooming that is Sudakov safe. You will then explore numerically how the groomed observable transitions to the ungroomed one as the Soft Drop threshold parameter $z_\\text{cut}$ approaches $0$.\n\nFundamental base:\n- The core behavior is governed by the infrared and collinear structure of Quantum Chromodynamics (QCD). An observable is infrared safe if it is insensitive to adding emissions with vanishing momentum, and collinear safe if it is insensitive to replacing a particle with two collinear particles whose momenta sum to the original. Deterministic clustering algorithms such as Cambridge/Aachen are designed to be infrared and collinear safe at the level of jets.\n- You must use the following definitions and facts as the fundamental base:\n  1. Cambridge/Aachen clustering: at each iteration, merge the pair of pseudojets with the smallest angular distance, where the pairwise angular separation in a one-dimensional azimuthal space is $\\Delta\\phi_{ij} = |\\phi_i - \\phi_j|$. Continue until only one pseudojet remains, yielding a binary clustering tree. Use $p_T$-scheme recombination, i.e., for merging nodes $a$ and $b$, the new pseudojet has total transverse momentum $p_{T,\\text{new}} = p_{T,a} + p_{T,b}$ and angle $\\phi_{\\text{new}} = \\frac{p_{T,a}\\phi_a + p_{T,b}\\phi_b}{p_{T,a} + p_{T,b}}$.\n  2. The ungroomed last-split event shape is the momentum sharing at the final clustering step:\n     $$ z_{\\text{last}} = \\frac{\\min(p_{T,1}, p_{T,2})}{p_{T,1} + p_{T,2}}. $$\n     This is collinear safe because any collinear splitting occurs at vanishing angle and is merged before the last split, leaving the last split invariant. It is soft unsafe because adding a wide-angle emission of momentum $\\epsilon$ can create a final split with $z_{\\text{last}} \\approx \\epsilon/(p_{T,\\text{hard}} + \\epsilon) \\to 0$ as $\\epsilon \\to 0$.\n  3. Soft Drop grooming with angular exponent $\\beta = 0$ is defined recursively by declustering the C/A tree from the root: at each binary split into branches with transverse momenta $p_{T,1}$ and $p_{T,2}$, compute\n     $$ z = \\frac{\\min(p_{T,1}, p_{T,2})}{p_{T,1} + p_{T,2}}. $$\n     If $z > z_\\text{cut}$, accept and define $z_g = z$. If $z \\le z_\\text{cut}$, drop the softer branch and continue declustering the harder branch. If no split passes the threshold, define $z_g = 0$. For fixed $z_\\text{cut} > 0$, $z_g$ is Sudakov safe; as $z_\\text{cut} \\to 0$, $z_g$ approaches the ungroomed $z_{\\text{last}}$ and loses soft safety.\n\nTask:\n- Implement the one-dimensional Cambridge/Aachen clustering over particle lists represented by transverse momenta $p_T$ (in $\\text{GeV}$) and angles $\\phi$ (in radians). Treat $\\phi$ as a real number in radians without any periodic wrap-around; only use $\\Delta\\phi = |\\phi_i - \\phi_j|$.\n- Construct the binary tree by repeatedly merging the pair with the smallest $\\Delta\\phi$, using the recombination scheme above. The final merge defines the last split. For a collection with a single particle, define $z_{\\text{last}} = 0$ by convention.\n- Implement Soft Drop grooming with $\\beta = 0$ and threshold $z_\\text{cut}$. Declustering starts from the root of the clustering tree: at each split with children having momenta $p_{T,1}$ and $p_{T,2}$, compute $z$ as above and compare to $z_\\text{cut}$. If $z > z_\\text{cut}$, set $z_g = z$; if not, continue declustering by discarding the softer child and proceeding down the harder child. If a leaf is reached without accepting any split, define $z_g = 0$. For a single-particle input, define $z_g = 0$ for all $z_\\text{cut}$.\n- Compute, for each event in the test suite, a list containing $[z_{\\text{last}}, z_g(z_\\text{cut} = 0.1), z_g(z_\\text{cut} = 0.01), z_g(z_\\text{cut} = 10^{-9})]$. All outputs are dimensionless real numbers. Do not apply rounding; report the full-precision floating-point results produced by your implementation.\n\nUnits and conventions:\n- All transverse momenta $p_T$ are in $\\text{GeV}$.\n- All angles $\\phi$ are in radians.\n- The outputs $z_{\\text{last}}$ and $z_g$ are dimensionless.\n\nTest suite:\n- Event $1$ (soft-unsafe demonstration): three particles, $[(p_T,\\phi)] = [(100, 0.0), (50, 0.1), (10^{-6}, 1.0)]$. This produces a final split between the hard cluster and the wide-angle soft particle, making $z_{\\text{last}}$ sensitive to the soft emission. The groomed $z_g$ selects the hard split for $z_\\text{cut} \\in \\{0.1, 0.01\\}$, and transitions toward $z_{\\text{last}}$ as $z_\\text{cut} \\to 0$.\n- Event $2$ (collinear safety check): three particles, $[(p_T,\\phi)] = [(70, 0.0), (30, 10^{-6}), (50, 0.8)]$. The two nearly collinear particles emulate a collinear split of a $100$ $\\text{GeV}$ prong; C/A merges them first, so the last split, and therefore $z_{\\text{last}}$ and $z_g$, remain equal to the corresponding two-prong value.\n- Event $3$ (boundary case): one particle, $[(p_T,\\phi)] = [(123, 0.5)]$. There is no split; by convention, $z_{\\text{last}} = 0$ and $z_g = 0$ for all $z_\\text{cut}$.\n\nYour program should produce a single line of output containing the results for the three events as a comma-separated list of lists in the order above, e.g., \n\"[[z_last_1,zg_1_0.1,zg_1_0.01,zg_1_1e-9],[z_last_2,zg_2_0.1,zg_2_0.01,zg_2_1e-9],[z_last_3,zg_3_0.1,zg_3_0.01,zg_3_1e-9]]\"\nwith the numerical values filling the placeholders. No other text should be printed.", "solution": "The user has provided a valid problem statement.\n\n### Step 1: Extract Givens\n- **Task**: Implement Cambridge/Aachen (C/A) clustering, an ungroomed observable $z_{\\text{last}}$, and a groomed observable $z_g$ using Soft Drop. Analyze their behavior on a given test suite.\n- **Clustering Algorithm**: One-dimensional Cambridge/Aachen (C/A).\n    - **Metric**: Iteratively merge the pair of pseudojets $(i, j)$ with the smallest angular distance $\\Delta\\phi_{ij} = |\\phi_i - \\phi_j|$.\n    - **Recombination Scheme**: For merging pseudojets $a$ and $b$ with transverse momenta $p_{T,a}$, $p_{T,b}$ and angles $\\phi_a$, $\\phi_b$:\n        - $p_{T,\\text{new}} = p_{T,a} + p_{T,b}$\n        - $\\phi_{\\text{new}} = \\frac{p_{T,a}\\phi_a + p_{T,b}\\phi_b}{p_{T,a} + p_{T,b}}$\n- **Ungroomed Observable ($z_{\\text{last}}$)**:\n    - Defined as the momentum sharing at the final clustering step. For two subjets with momenta $p_{T,1}$ and $p_{T,2}$, $z_{\\text{last}} = \\frac{\\min(p_{T,1}, p_{T,2})}{p_{T,1} + p_{T,2}}$.\n    - For events with a single particle, $z_{\\text{last}} = 0$.\n- **Groomed Observable ($z_g$)**:\n    - **Algorithm**: Soft Drop grooming with angular exponent $\\beta = 0$ and momentum sharing threshold $z_\\text{cut}$.\n    - **Procedure**: Recursively decluster the C/A tree from the root. At each split into branches with momenta $p_{T,1}$ and $p_{T,2}$, compute $z = \\frac{\\min(p_{T,1}, p_{T,2})}{p_{T,1} + p_{T,2}}$.\n        - If $z > z_\\text{cut}$, the split is accepted. Define $z_g = z$ and stop.\n        - If $z \\le z_\\text{cut}$, the softer branch is dropped. Declustering continues on the harder branch.\n        - If no split passes the threshold (i.e., a leaf is reached), define $z_g = 0$.\n    - For events with a single particle, $z_g = 0$.\n- **Computational Task**: For each event, compute a list of four values: $[z_{\\text{last}}, z_g(z_\\text{cut} = 0.1), z_g(z_\\text{cut} = 0.01), z_g(z_\\text{cut} = 10^{-9})]$.\n- **Test Suite**:\n    - Event 1: $[(p_T=100\\,\\text{GeV}, \\phi=0.0), (p_T=50\\,\\text{GeV}, \\phi=0.1), (p_T=10^{-6}\\,\\text{GeV}, \\phi=1.0)]$\n    - Event 2: $[(p_T=70\\,\\text{GeV}, \\phi=0.0), (p_T=30\\,\\text{GeV}, \\phi=10^{-6}), (p_T=50\\,\\text{GeV}, \\phi=0.8)]$\n    - Event 3: $[(p_T=123\\,\\text{GeV}, \\phi=0.5)]$\n\n### Step 2: Validate Using Extracted Givens\nThe problem is scientifically grounded in Quantum Chromodynamics (QCD) and jet physics, specifically dealing with the well-established concepts of infrared and collinear (IRC) safety, jet clustering algorithms (C/A), and jet grooming techniques (Soft Drop). The definitions provided for the algorithms and observables are standard and correct. The problem is well-posed, as the deterministic nature of the C/A algorithm and the Soft Drop procedure ensures a unique solution for any given input. The problem statement is objective, complete, and self-consistent, providing all necessary definitions, constants, and test cases. The physical scenarios are simplified but plausible, serving as effective pedagogical examples of key physics principles. The problem is therefore deemed **valid**.\n\n### Step 3: Proceed to Solution\n\n#### Principle-Based Algorithmic Design\n\nThe solution hinges on constructing and then analyzing a binary clustering tree. This structure, generated by the Cambridge/Aachen (C/A) algorithm, encodes the geometric history of the jet's formation. Observables are then computed by traversing this tree.\n\n**1. Data Structure for Pseudojets and Tree Construction**\n\nTo represent the state of the system at any point during clustering, we define a `PseudoJet` object. This object encapsulates the kinematic properties of a particle or a cluster of particles, specifically its transverse momentum $p_T$ and its angle $\\phi$. Crucially, to form the binary tree, each `PseudoJet` that results from a merger must also store references to its two constituents (children in the declustering sense). A `PseudoJet` representing an initial particle is a leaf node with no children.\n\n**2. Cambridge/Aachen (C/A) Clustering Implementation**\n\nThe C/A algorithm is governed by the principle of angular ordering. It builds the jet structure by iteratively merging the pair of pseudojets with the smallest angular separation $\\Delta\\phi_{ij} = |\\phi_i - \\phi_j|$. This process is implemented as follows:\n1. Initialize a list of `PseudoJet` objects from the input particles.\n2. While more than one `PseudoJet` remains:\n    a. Find the pair $(i, j)$ that minimizes $\\Delta\\phi_{ij}$. This is a brute-force search over all unique pairs.\n    b. Merge this pair into a new `PseudoJet` using the specified $p_T$-scheme recombination rules: $p_{T,\\text{new}} = p_{T,i} + p_{T,j}$ and $\\phi_{\\text{new}} = (p_{T,i}\\phi_i + p_{T,j}\\phi_j) / p_{T,\\text{new}}$. The two merged pseudojets are stored as the children of the new one.\n    c. Remove the constituent pseudojets from the active list and add the newly formed one.\n3. The process terminates when a single `PseudoJet` remains. This is the root of the clustering tree.\n\n**3. Ungroomed Observable: $z_{\\text{last}}$**\n\nThe observable $z_{\\text{last}}$ is a measure of the momentum balance of the final split in the C/A sequence. It is calculated directly from the two children of the root node of the tree. If their momenta are $p_{T,1}$ and $p_{T,2}$, then $z_{\\text{last}} = \\min(p_{T,1}, p_{T,2}) / (p_{T,1} + p_{T,2})$.\n\nThis observable is collinear-safe because a collinear splitting results in particles with a very small angular separation. The C/A algorithm merges them at an early stage, leaving the final, widest-angle split unchanged. However, $z_{\\text{last}}$ is soft-unsafe. As demonstrated by Event 1, a soft particle at a wide angle (e.g., $p_T = 10^{-6}\\,\\text{GeV}$ at $\\phi=1.0$) is merged last. This final split becomes extremely unbalanced, causing $z_{\\text{last}} \\to 0$ as the soft particle's momentum goes to zero, making the observable sensitive to soft radiation.\n\n**4. Groomed Observable: $z_g$ with Soft Drop**\n\nSoft Drop grooming is designed to restore Sudakov safety by removing soft, wide-angle radiation. It operates by \"declustering\" the C/A tree, effectively reversing the clustering process. Our implementation is a recursive function that traverses the tree from the root downwards:\n\n`get_zg(node, z_cut)`:\n1.  **Base Case**: If `node` is a leaf (has no children), it means we have declustered down to an initial particle without finding a split satisfying the grooming condition. By definition, we return $z_g=0$.\n2.  **Recursive Step**: If `node` has children with momenta $p_{T,1}$ and $p_{T,2}$, we compute the momentum sharing $z = \\min(p_{T,1}, p_{T,2}) / (p_{T,1} + p_{T,2})$.\n    a.  **Condition Pass**: If $z > z_\\text{cut}$, the split is considered \"hard enough\". We accept this split and return its $z$ value as the final $z_g$. The recursion terminates.\n    b.  **Condition Fail**: If $z \\le z_\\text{cut}$, the split is too soft. The softer child branch is discarded, and the function recursively calls itself on the harder child: `get_zg(harder_child, z_cut)`.\n\nFor Event 1, with $z_\\text{cut}=0.1$ or $z_\\text{cut}=0.01$, the initial soft split at the root of the tree fails the condition. The algorithm proceeds to the next split inside the hard jet, which is balanced ($z=1/3$) and passes the condition, yielding $z_g=1/3$. This demonstrates the removal of the soft contamination. As $z_\\text{cut} \\to 0$ (e.g., $z_\\text{cut} = 10^{-9}$), the Soft Drop condition becomes more permissive. The initially soft split now passes the condition ($z_{\\text{last}} \\approx 6.7 \\times 10^{-9} > 10^{-9}$), so $z_g$ becomes equal to $z_{\\text{last}}$, recovering the ungroomed, soft-unsafe behavior.\n\nFor Event 2, the nearly collinear particles are merged first, emulating a single hard prong. The last split is between two hard components, yielding a large $z_{\\text{last}} = 1/3$. This split immediately satisfies the Soft Drop condition for all given $z_\\text{cut}$ values, so $z_g = z_{\\text{last}} = 1/3$ throughout. This illustrates the collinear safety of the procedure.\n\nThe boundary case, Event 3, with a single particle, has no splits, so by convention both $z_{\\text{last}}$ and all $z_g$ values are defined to be $0$.\n\nThe implementation will compute these values for all test cases and format them as requested.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# No other libraries are permitted.\n\nclass PseudoJet:\n    \"\"\"\n    Represents a particle or a cluster of particles (jet) with its kinematic\n    properties and clustering history.\n    \"\"\"\n    def __init__(self, pT, phi, children=None):\n        self.pT = np.float64(pT)\n        self.phi = np.float64(phi)\n        self.children = children  # A tuple (child1, child2) or None for leaves\n\ndef solve_for_event(particles_data):\n    \"\"\"\n    Performs C/A clustering and calculates z_last and z_g for a single event.\n    \"\"\"\n    num_particles = len(particles_data)\n\n    # Handle boundary cases as per problem definition\n    if num_particles = 1:\n        return [0.0, 0.0, 0.0, 0.0]\n\n    # Initialize list of active pseudojets\n    active_jets = [PseudoJet(pT, phi) for pT, phi in particles_data]\n\n    # Cambridge/Aachen clustering loop\n    while len(active_jets)  1:\n        min_dist = np.inf\n        best_pair_indices = None\n\n        # Find pair with minimum angular distance\n        for i in range(len(active_jets)):\n            for j in range(i + 1, len(active_jets)):\n                dist = np.abs(active_jets[i].phi - active_jets[j].phi)\n                if dist  min_dist:\n                    min_dist = dist\n                    best_pair_indices = (i, j)\n        \n        # Unpack indices, ensuring i  j for easier list manipulation\n        i, j = sorted(best_pair_indices)\n        jet1, jet2 = active_jets[i], active_jets[j]\n\n        # pT-scheme recombination\n        new_pT = jet1.pT + jet2.pT\n        new_phi = (jet1.pT * jet1.phi + jet2.pT * jet2.phi) / new_pT\n        \n        # Create new jet, storing its history\n        new_jet = PseudoJet(new_pT, new_phi, children=(jet1, jet2))\n        \n        # Update the list of active jets for the next iteration\n        # Remove merged jets (larger index first) and add the new one\n        active_jets.pop(j)\n        active_jets.pop(i)\n        active_jets.append(new_jet)\n        \n    root_node = active_jets[0]\n\n    # Calculate z_last from the final split\n    child1, child2 = root_node.children\n    z_last = np.min([child1.pT, child2.pT]) / (child1.pT + child2.pT)\n\n    # Calculate z_g for specified z_cut values\n    z_cuts = [0.1, 0.01, 1e-9]\n    z_g_values = []\n    \n    def get_zg_recursive(node, z_cut):\n        \"\"\"\n        Recursively applies the Soft Drop grooming condition.\n        \"\"\"\n        # Base case: leaf node reached, no split passed the condition\n        if not node.children:\n            return np.float64(0.0)\n\n        pT1, pT2 = node.children[0].pT, node.children[1].pT\n        \n        # Momentum sharing for the current split\n        z = np.min([pT1, pT2]) / (pT1 + pT2)\n\n        if z  z_cut:\n            # Soft Drop condition passed, this is the groomed split\n            return z\n        else:\n            # Condition failed, drop softer branch and continue on harder branch\n            if pT1  pT2:\n                harder_child = node.children[0]\n            else:\n                harder_child = node.children[1]\n            return get_zg_recursive(harder_child, z_cut)\n\n    for z_cut in z_cuts:\n        zg = get_zg_recursive(root_node, z_cut)\n        z_g_values.append(zg)\n\n    return [z_last] + z_g_values\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Event 1: soft-unsafe demonstration\n        [(100, 0.0), (50, 0.1), (1e-6, 1.0)],\n        # Event 2: collinear safety check\n        [(70, 0.0), (30, 1e-6), (50, 0.8)],\n        # Event 3: boundary case with one particle\n        [(123, 0.5)],\n    ]\n\n    results = []\n    for case in test_cases:\n        result_list = solve_for_event(case)\n        results.append(result_list)\n\n    # Format the output exactly as specified.\n    # The output is a string representation of a list of lists of floats.\n    list_strs = []\n    for res_list in results:\n        # Format each inner list to \"[v1,v2,v3,v4]\"\n        list_str = f\"[{','.join(map(str, res_list))}]\"\n        list_strs.append(list_str)\n\n    # Join the inner list strings into the final format \"[[...],[...]]\"\n    final_output_str = f\"[{','.join(list_strs)}]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output_str)\n\nsolve()\n```", "id": "3517881"}]}