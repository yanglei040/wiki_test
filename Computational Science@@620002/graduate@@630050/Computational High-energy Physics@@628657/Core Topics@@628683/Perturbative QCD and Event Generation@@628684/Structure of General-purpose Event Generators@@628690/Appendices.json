{"hands_on_practices": [{"introduction": "A core component of any event generator is the parton shower, which models the radiation of gluons and quarks. This perturbative evolution must be terminated at a low-energy scale, introducing an infrared (IR) cutoff, often denoted $p_T^{\\min}$. This exercise explores the crucial concept of IR safety, which dictates that physical observables should be insensitive to the precise value of this unphysical cutoff. By deriving an analytical model for the cutoff dependence and an extrapolation scheme to remove it, you will gain a deep, quantitative understanding of how generators bridge the gap between the perturbative shower and the non-perturbative physics that lies beyond. [@problem_id:3538355]", "problem": "Consider a simplified but scientifically consistent model of a general-purpose event generator for final-state Quantum Chromodynamics (QCD) radiation, focusing on the structure of the parton shower and its infrared regularization. The shower is ordered in transverse momentum, with an infrared cutoff $p_T^{\\min}$ that terminates the perturbative evolution. The hard scale is denoted by $Q$ and the strong coupling is taken to be fixed and small. The emission kernel is taken in the leading-logarithmic (LL) soft-collinear approximation as a continuous inhomogeneous Poisson process along the shower evolution.\n\nFundamental base and core definitions:\n- The emission rate (intensity) as a function of transverse momentum $p_T$ is modeled by\n$$\n\\lambda(p_T;Q) = \\frac{\\alpha_s C_R}{\\pi}\\,\\frac{\\ln\\!\\left(\\frac{Q}{p_T}\\right)}{p_T},\n$$\nwhere $\\alpha_s$ is the strong coupling constant, $C_R$ is the appropriate quadratic Casimir in the representation of the radiator ($C_F = 4/3$ for quarks and $C_A = 3$ for gluons), and the phase-space rapidity integral produces the logarithm $\\ln(Q/p_T)$ at leading logarithmic accuracy. This functional form is a well-tested outcome of soft-collinear factorization and defines both the real-emission rate and the exponent in the Sudakov form factor.\n- The Sudakov form factor $\\Delta(Q,p_T^{\\min})$ is the no-emission probability down to $p_T^{\\min}$, defined by exponentiation of the negative integral of the LL rate,\n$$\n\\Delta(Q,p_T^{\\min}) = \\exp\\!\\left(-\\int_{p_T^{\\min}}^{Q} \\lambda(p_T;Q)\\,dp_T\\right).\n$$\n- Consider the infrared and collinear safe (IR-safe) additive observable\n$$\nV = \\sum_{i\\in\\text{emissions}} \\left(\\frac{p_{T,i}}{Q}\\right)^{a},\n$$\nwith $a>0$. This $V$ is dimensionless and IR-safe because emissions at vanishing $p_T$ contribute vanishing weight.\n\nTask:\n1. Starting from the definitions above, derive an expression for the expectation value $\\mathbb{E}[V]$ at fixed $Q$, $\\alpha_s$, $C_R$, $a$, and infrared cutoff $p_T^{\\min}$, in units where $p_T$ and $Q$ are expressed in $\\mathrm{GeV}$ and the observable $V$ is dimensionless. Your derivation must proceed from the LL emission rate and the additivity of $V$ under independent emissions. No heuristic shortcuts are permitted; the derivation must start from the integral representation of the emission rate and the definition of $V$.\n2. Propose an extrapolation scheme for $p_T^{\\min}\\to 0$ that preserves Sudakov consistency. Specifically, the scheme must use the same LL kernel $\\lambda(p_T;Q)$ in both the real-emission contribution for $V$ and the Sudakov exponent governing unresolved emissions. Implement the extrapolation by adding the leading-logarithmic contribution from the unresolved region $p_T \\in (0,p_T^{\\min})$ to the finite-cutoff expectation value. This addition should be derived as the leading term in the small-$x_0$ expansion, where $x_0 = p_T^{\\min}/Q$.\n3. Compute the exact zero-cutoff limit of $\\mathbb{E}[V]$ under the same LL model, by integrating the appropriate expression down to $p_T=0$.\n4. Estimate the residual power corrections as the difference between the exact zero-cutoff limit and the leading-logarithmic extrapolated value. This difference should scale as a power in $x_0$ possibly modified by logarithms; provide the explicit functional dependence that emerges from your derivation.\n5. For each test case below, compute and report the following five quantities as floats: \n   - The expectation value at finite cutoff, $\\mathbb{E}[V]$ at $p_T^{\\min}$,\n   - The leading-logarithmic extrapolated value to $p_T^{\\min}\\to 0$ obtained by adding the leading unresolved contribution,\n   - The exact zero-cutoff limit $\\mathbb{E}[V]\\big|_{p_T^{\\min}\\to 0}$,\n   - The residual power correction estimate defined as the difference between the exact zero-cutoff limit and the leading-logarithmic extrapolated value,\n   - The Sudakov form factor $\\Delta(Q,p_T^{\\min})$.\n6. Angle units do not appear explicitly in this formulation. All $p_T$ and $Q$ inputs are in $\\mathrm{GeV}$ and all outputs are dimensionless floats. \n\nTest suite:\n- Case 1 (happy path, quark radiator): $Q=100\\,\\mathrm{GeV}$, $p_T^{\\min}=1\\,\\mathrm{GeV}$, $\\alpha_s=0.12$, $C_R=4/3$, $a=1.0$.\n- Case 2 (boundary, no phase space): $Q=100\\,\\mathrm{GeV}$, $p_T^{\\min}=100\\,\\mathrm{GeV}$, $\\alpha_s=0.12$, $C_R=4/3$, $a=1.0$.\n- Case 3 (deep infrared cutoff): $Q=100\\,\\mathrm{GeV}$, $p_T^{\\min}=0.001\\,\\mathrm{GeV}$, $\\alpha_s=0.12$, $C_R=4/3$, $a=1.0$.\n- Case 4 (gluon radiator, different exponent): $Q=200\\,\\mathrm{GeV}$, $p_T^{\\min}=2\\,\\mathrm{GeV}$, $\\alpha_s=0.12$, $C_R=3.0$, $a=0.5$.\n- Case 5 (larger coupling, steeper weight): $Q=50\\,\\mathrm{GeV}$, $p_T^{\\min}=5\\,\\mathrm{GeV}$, $\\alpha_s=0.20$, $C_R=4/3$, $a=2.0$.\n\nFinal output format requirement:\nYour program should produce a single line of output containing the results for the five test cases as a comma-separated list enclosed in square brackets, where each element is a list of five floats in the order specified above. For example:\n$$\n[\\,[v_{1,\\text{cut}},v_{1,\\text{LL}},v_{1,0},r_{1},\\Delta_{1}],\\,[v_{2,\\text{cut}},v_{2,\\text{LL}},v_{2,0},r_{2},\\Delta_{2}],\\,\\dots\\,]\n$$\nNo other text may be printed.", "solution": "The problem is subjected to validation and is determined to be valid. It is scientifically grounded in the established principles of Quantum Chromodynamics (QCD) parton showers, specifically the leading-logarithmic (LL) approximation for soft-collinear emissions. The problem is well-posed, with all necessary parameters and functions defined, allowing for a unique and meaningful solution. The language is objective and precise. Therefore, we proceed with the derivation and solution.\n\nThe foundation of this problem is the modeling of parton emissions as an inhomogeneous Poisson process. The evolution variable is the transverse momentum, $p_T$, of the emitted partons. The intensity or rate of this process is given by the function $\\lambda(p_T;Q)$. For an additive observable of the form $V = \\sum_i f(p_{T,i})$, where the sum is over all emissions, its expectation value $\\mathbb{E}[V]$ can be calculated using Campbell's theorem for Poisson point processes. The theorem states that the expectation value is the integral of the single-emission contribution, $f(p_T)$, weighted by the emission rate $\\lambda(p_T)$:\n$$\n\\mathbb{E}[V] = \\int_{\\text{phase space}} f(p_T) \\lambda(p_T; Q) \\, dp_T\n$$\nIn this problem, the observable is $V = \\sum_{i\\in\\text{emissions}} (p_{T,i}/Q)^a$, so the single-emission contribution is $f(p_T) = (p_T/Q)^a$. The phase space for resolved emissions is the interval $p_T \\in [p_T^{\\min}, Q]$.\n\nLet us define a constant $K = \\frac{\\alpha_s C_R}{\\pi}$ to simplify the notation. The emission rate is then $\\lambda(p_T;Q) = K \\frac{\\ln(Q/p_T)}{p_T}$.\n\n**1. Derivation of the Expectation Value at Finite Cutoff, $\\mathbb{E}[V]_{\\text{cut}}$**\n\nThe expectation value of $V$ considering only emissions above the infrared cutoff $p_T^{\\min}$ is given by the integral over the resolved phase space:\n$$\n\\mathbb{E}[V]_{\\text{cut}} = \\int_{p_T^{\\min}}^{Q} \\left(\\frac{p_T}{Q}\\right)^a \\lambda(p_T; Q) \\, dp_T = \\int_{p_T^{\\min}}^{Q} \\frac{p_T^a}{Q^a} K \\frac{\\ln(Q/p_T)}{p_T} \\, dp_T\n$$\n$$\n\\mathbb{E}[V]_{\\text{cut}} = \\frac{K}{Q^a} \\int_{p_T^{\\min}}^{Q} p_T^{a-1} \\ln(Q/p_T) \\, dp_T\n$$\nWe perform a change of variables to $u = p_T/Q$, which implies $dp_T = Q\\,du$. The integration limits become $x_0 = p_T^{\\min}/Q$ and $1$.\n$$\n\\mathbb{E}[V]_{\\text{cut}} = \\frac{K}{Q^a} \\int_{x_0}^{1} (uQ)^{a-1} (-\\ln u) \\, (Q\\,du) = K \\int_{x_0}^{1} u^{a-1} (-\\ln u) \\, du\n$$\nThis integral can be solved using integration by parts, $\\int w'v = wv - \\int wv'$. Let $v = -\\ln u$ and $w' = u^{a-1}$, so $v' = -1/u$ and $w = u^a/a$.\n$$\n\\int u^{a-1}(-\\ln u) \\, du = -\\frac{u^a}{a}\\ln u + \\int \\frac{u^a}{a} \\frac{1}{u} \\, du = -\\frac{u^a}{a}\\ln u + \\frac{u^a}{a^2}\n$$\nEvaluating the definite integral:\n$$\n\\int_{x_0}^{1} u^{a-1}(-\\ln u) \\, du = \\left[ -\\frac{u^a}{a}\\ln u + \\frac{u^a}{a^2} \\right]_{x_0}^{1} = \\left(0 + \\frac{1}{a^2}\\right) - \\left(-\\frac{x_0^a}{a}\\ln x_0 + \\frac{x_0^a}{a^2}\\right)\n$$\n$$\n= \\frac{1}{a^2} + \\frac{x_0^a}{a}\\ln x_0 - \\frac{x_0^a}{a^2}\n$$\nThus, the expectation value at finite cutoff is:\n$$\n\\mathbb{E}[V]_{\\text{cut}} = K \\left( \\frac{1}{a^2} + \\frac{x_0^a}{a}\\ln x_0 - \\frac{x_0^a}{a^2} \\right) = \\frac{\\alpha_s C_R}{\\pi a^2} \\left( 1 + a x_0^a \\ln x_0 - x_0^a \\right)\n$$\n\n**2. Derivation of the Exact Zero-Cutoff Limit, $\\mathbb{E}[V]_{0}$**\n\nThe exact zero-cutoff limit is obtained by taking $p_T^{\\min} \\to 0$, which corresponds to $x_0 \\to 0$. We must evaluate the limit of $\\mathbb{E}[V]_{\\text{cut}}$ as $x_0 \\to 0^+$. Since $a>0$, we have $\\lim_{x_0\\to 0} x_0^a = 0$. The term $x_0^a \\ln x_0$ is an indeterminate form $0 \\cdot (-\\infty)$, which can be evaluated using L'Hôpital's rule:\n$$\n\\lim_{x_0 \\to 0^+} x_0^a \\ln x_0 = \\lim_{x_0 \\to 0^+} \\frac{\\ln x_0}{x_0^{-a}} = \\lim_{x_0 \\to 0^+} \\frac{1/x_0}{-a x_0^{-a-1}} = \\lim_{x_0 \\to 0^+} -\\frac{x_0^a}{a} = 0\n$$\nTherefore, the limiting value is:\n$$\n\\mathbb{E}[V]_{0} = \\lim_{x_0 \\to 0^+} \\mathbb{E}[V]_{\\text{cut}} = K \\left( \\frac{1}{a^2} + 0 - 0 \\right) = \\frac{K}{a^2} = \\frac{\\alpha_s C_R}{\\pi a^2}\n$$\n\n**3. Derivation of the Leading-Logarithmic Extrapolated Value, $\\mathbb{E}[V]_{\\text{LL}}$**\n\nThe extrapolation scheme involves adding the leading contribution from the unresolved region $p_T \\in (0, p_T^{\\min})$ to the finite-cutoff result $\\mathbb{E}[V]_{\\text{cut}}$. The contribution from the unresolved region is:\n$$\n\\mathbb{E}[V]_{\\text{unresolved}} = \\mathbb{E}[V]_{0} - \\mathbb{E}[V]_{\\text{cut}} = \\frac{K}{a^2} - K \\left( \\frac{1}{a^2} + \\frac{x_0^a}{a}\\ln x_0 - \\frac{x_0^a}{a^2} \\right) = -K\\left(\\frac{x_0^a}{a}\\ln x_0 - \\frac{x_0^a}{a^2}\\right)\n$$\nFor small $x_0$, the term with the logarithm $\\ln x_0$ is dominant. The problem asks for the *leading-logarithmic* contribution, which is the leading term in the small-$x_0$ expansion of $\\mathbb{E}[V]_{\\text{unresolved}}$. This is the term $-K \\frac{x_0^a}{a} \\ln x_0$.\nThe extrapolated value $\\mathbb{E}[V]_{\\text{LL}}$ is defined as:\n$$\n\\mathbb{E}[V]_{\\text{LL}} = \\mathbb{E}[V]_{\\text{cut}} + \\left( -K \\frac{x_0^a}{a} \\ln x_0 \\right)\n$$\nSubstituting the expression for $\\mathbb{E}[V]_{\\text{cut}}$:\n$$\n\\mathbb{E}[V]_{\\text{LL}} = K \\left( \\frac{1}{a^2} + \\frac{x_0^a}{a}\\ln x_0 - \\frac{x_0^a}{a^2} \\right) - K \\frac{x_0^a}{a} \\ln x_0 = K \\left( \\frac{1}{a^2} - \\frac{x_0^a}{a^2} \\right)\n$$\n$$\n\\mathbb{E}[V]_{\\text{LL}} = \\frac{\\alpha_s C_R}{\\pi a^2} (1 - x_0^a)\n$$\n\n**4. Estimation of Residual Power Corrections, $R$**\n\nThe residual power correction is defined as the difference between the exact zero-cutoff limit and the LL extrapolated value:\n$$\nR = \\mathbb{E}[V]_{0} - \\mathbb{E}[V]_{\\text{LL}} = \\frac{K}{a^2} - \\frac{K}{a^2}(1 - x_0^a) = \\frac{K}{a^2} x_0^a\n$$\n$$\nR = \\frac{\\alpha_s C_R}{\\pi a^2} \\left(\\frac{p_T^{\\min}}{Q}\\right)^a\n$$\nThis demonstrates that the residual correction scales as a power of the ratio of the infrared and hard scales, with the power given by the exponent $a$ of the observable.\n\n**5. Derivation of the Sudakov Form Factor, $\\Delta(Q, p_T^{\\min})$**\n\nThe Sudakov form factor is the no-emission probability in the interval $[p_T^{\\min}, Q]$. It is calculated by exponentiating the negative of the integrated emission rate:\n$$\n\\Delta(Q, p_T^{\\min}) = \\exp\\left(-\\int_{p_T^{\\min}}^{Q} \\lambda(p_T;Q)\\,dp_T\\right) = \\exp\\left(-K \\int_{p_T^{\\min}}^{Q} \\frac{\\ln(Q/p_T)}{p_T}\\,dp_T\\right)\n$$\nTo evaluate the integral, let $y = \\ln(Q/p_T)$. Then $p_T = Qe^{-y}$ and $dp_T/p_T = -dy$. The integration limits for $y$ are $\\ln(Q/p_T^{\\min})$ (for $p_T = p_T^{\\min}$) and $0$ (for $p_T=Q$).\n$$\n\\int_{p_T^{\\min}}^{Q} \\frac{\\ln(Q/p_T)}{p_T}\\,dp_T = \\int_{\\ln(Q/p_T^{\\min})}^{0} y(-dy) = \\int_{0}^{\\ln(Q/p_T^{\\min})} y\\,dy = \\left[\\frac{y^2}{2}\\right]_{0}^{\\ln(Q/p_T^{\\min})} = \\frac{1}{2}\\left(\\ln\\frac{Q}{p_T^{\\min}}\\right)^2\n$$\nSubstituting this back into the expression for $\\Delta$:\n$$\n\\Delta(Q, p_T^{\\min}) = \\exp\\left(-\\frac{K}{2}\\left(\\ln\\frac{Q}{p_T^{\\min}}\\right)^2\\right) = \\exp\\left(-\\frac{\\alpha_s C_R}{2\\pi}\\left(\\ln\\frac{Q}{p_T^{\\min}}\\right)^2\\right)\n$$\n\n**Summary of Formulae for Computation:**\nFor each test case, we compute the following five quantities using $K = \\frac{\\alpha_s C_R}{\\pi}$, $x_0 = p_T^{\\min}/Q$, and $L = \\ln(Q/p_T^{\\min}) = -\\ln x_0$:\n1.  $\\mathbb{E}[V]_{\\text{cut}} = \\frac{K}{a^2}(1 - x_0^a(1 + aL))$\n2.  $\\mathbb{E}[V]_{\\text{LL}} = \\frac{K}{a^2}(1 - x_0^a)$\n3.  $\\mathbb{E}[V]_{0} = \\frac{K}{a^2}$\n4.  $R = \\frac{K}{a^2}x_0^a$\n5.  $\\Delta(Q, p_T^{\\min}) = \\exp\\left(-\\frac{K}{2}L^2\\right)$\nFor the edge case $p_T^{\\min} \\ge Q$, the phase space for emission is zero. This corresponds to $x_0 \\ge 1$, and specifically for $p_T^{\\min}=Q$, we have $x_0=1$ and $L=0$. The formulae correctly yield $\\mathbb{E}[V]_{\\text{cut}} = 0$, $\\mathbb{E}[V]_{\\text{LL}} = 0$, and $\\Delta=1$.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the QCD parton shower problem for a set of test cases.\n    \"\"\"\n\n    test_cases = [\n        # (Q, pt_min, alpha_s, C_R, a)\n        # Case 1: happy path, quark radiator\n        (100.0, 1.0, 0.12, 4.0/3.0, 1.0),\n        # Case 2: boundary, no phase space\n        (100.0, 100.0, 0.12, 4.0/3.0, 1.0),\n        # Case 3: deep infrared cutoff\n        (100.0, 0.001, 0.12, 4.0/3.0, 1.0),\n        # Case 4: gluon radiator, different exponent\n        (200.0, 2.0, 0.12, 3.0, 0.5),\n        # Case 5: larger coupling, steeper weight\n        (50.0, 5.0, 0.20, 4.0/3.0, 2.0),\n    ]\n\n    def calculate_observables(Q, pt_min, alpha_s, C_R, a):\n        \"\"\"\n        Calculates the five required quantities based on the derived formulae.\n        \n        Args:\n            Q (float): The hard scale in GeV.\n            pt_min (float): The infrared cutoff in GeV.\n            alpha_s (float): The strong coupling constant.\n            C_R (float): The quadratic Casimir.\n            a (float): The exponent for the observable V.\n\n        Returns:\n            list: A list of five floats: [ev_cut, ev_ll, ev_0, R, delta].\n        \"\"\"\n        # Ensure a > 0 as per problem spec, to avoid division by zero.\n        if a <= 0:\n            raise ValueError(\"Parameter 'a' must be greater than 0.\")\n\n        # Handle the edge case of no emission phase space.\n        if pt_min >= Q:\n            x0 = 1.0\n            L = 0.0\n        else:\n            x0 = pt_min / Q\n            L = np.log(Q / pt_min)\n\n        K = alpha_s * C_R / np.pi\n        a_sq = a * a\n\n        # 1. Exact zero-cutoff limit, E[V]_0\n        ev_0 = K / a_sq\n\n        # 2. Residual power correction, R\n        R = ev_0 * (x0**a)\n\n        # 3. Leading-logarithmic extrapolated value, E[V]_LL\n        ev_ll = ev_0 * (1.0 - x0**a)\n\n        # 4. Finite-cutoff expectation value, E[V]_cut\n        # Formula: (K/a^2) * (1 - x0^a * (1 + a*L))\n        ev_cut = ev_0 * (1.0 - (x0**a) * (1.0 + a * L))\n        \n        # Explicitly set to 0 if no phase space, to handle potential float precision issues\n        if pt_min >= Q:\n            ev_cut = 0.0\n            ev_ll = 0.0\n        \n        # 5. Sudakov form factor, Delta\n        sudakov_exponent = -K / 2.0 * L**2\n        delta = np.exp(sudakov_exponent)\n\n        return [ev_cut, ev_ll, ev_0, R, delta]\n\n    results = []\n    for case in test_cases:\n        res_list = calculate_observables(*case)\n        results.append(res_list)\n\n    # Format the final output string according to the specification.\n    outer_list_str = []\n    for res_list in results:\n        # Use str() for default float formatting which is generally sufficient.\n        inner_list_str = f\"[{','.join(map(str, res_list))}]\"\n        outer_list_str.append(inner_list_str)\n        \n    print(f\"[{','.join(outer_list_str)}]\")\n\nsolve()\n```", "id": "3538355"}, {"introduction": "Once the parton shower concludes, the colored quarks and gluons must be transformed into the colorless hadrons observed in detectors. This non-perturbative process, known as hadronization, is described by phenomenological models. This practice delves into the celebrated Lund string model, where the color field between partons is pictured as a relativistic string that fragments into hadrons. You will implement a simplified version of this model to connect a fundamental parameter—the string tension $\\kappa$—to measurable final-state properties like particle multiplicity and transverse momentum, providing insight into how generators build the observable world from underlying partons. [@problem_id:3538393]", "problem": "Consider an idealized, single string fragmentation picture for electron-positron ($e^+e^-$) annihilation at the mass of the $Z$ boson, with center-of-mass energy $\\sqrt{s}$. In the Lund string framework, quark-antiquark pair production in the color field proceeds by quantum tunneling with probability density proportional to $\\exp(-\\pi m_T^2 / \\kappa)$, where $\\kappa$ is the string tension and $m_T$ is the transverse mass. Assume all produced hadrons are formed from adjacent quark-antiquark pairs whose transverse momenta add vectorially and independently.\n\nYour task is to write a complete, runnable program that computes, for given values of the string tension $\\kappa$:\n- The effect on the average charged hadron multiplicity at the $Z$ pole (dimensionless).\n- The effect on the mean transverse momentum relative to the string axis (in $\\mathrm{GeV}$).\n\nBase your derivation and implementation on the following fundamental laws and core definitions:\n- Quantum mechanical tunneling in a linear potential yields a transverse mass distribution proportional to $\\exp(-\\pi m_T^2 / \\kappa)$.\n- The transverse momentum $\\vec{p}_T$ of a quark produced by tunneling is distributed isotropically in the transverse plane, and independent, identical distributions apply to the quark and antiquark at each string break.\n- The hadron transverse momentum is the vector sum of two independent quark transverse momenta from adjacent breaks.\n- Energy conservation at fixed $\\sqrt{s}$ implies that if the longitudinal phase-space occupancy (rapidity profile) is approximately unchanged by moderate variations of $\\kappa$ at fixed energy, then the total hadron multiplicity is inversely proportional to a characteristic energy per hadron, which we approximate by the average transverse mass $\\langle m_T \\rangle$. Calibrate the proportionality constant using a baseline point.\n\nImplement the following modeling assumptions and computations, which must be derived from the above bases rather than postulated:\n1. From the tunneling weight $\\exp(-\\pi m_T^2 / \\kappa)$, deduce the two-dimensional Gaussian distribution for a single quark’s transverse momentum $\\vec{p}_T$ and its variance per Cartesian component. Use this to obtain the hadron’s transverse momentum as the sum of two independent such vectors, and compute the mean magnitude $\\langle p_T \\rangle$ relative to the string axis for hadrons.\n2. Introduce a representative light hadron rest mass $m_0$ and approximate the average hadron transverse mass by $\\langle m_T \\rangle \\approx \\sqrt{m_0^2 + \\langle p_T^2 \\rangle}$, where $\\langle p_T^2 \\rangle$ is taken from your hadron-level transverse momentum distribution.\n3. Use energy conservation to argue that the total hadron multiplicity $N_{\\text{tot}}(\\kappa)$ scales as $N_{\\text{tot}}(\\kappa) \\propto 1/\\langle m_T \\rangle(\\kappa)$ when the rapidity profile is held fixed by the parton shower at $\\sqrt{s}$. Determine the constant of proportionality by calibrating to a baseline charged multiplicity $N_{\\text{ch},0}$ at a baseline string tension $\\kappa_0$. Assume a constant charged fraction $f_{\\text{ch}}$ so that $N_{\\text{tot},0} = N_{\\text{ch},0}/f_{\\text{ch}}$ and $N_{\\text{tot}}(\\kappa)\\,\\langle m_T \\rangle(\\kappa) = N_{\\text{tot},0}\\,\\langle m_T \\rangle(\\kappa_0)$.\n\nNumerical inputs:\n- Use $\\sqrt{s} = 91.1876\\,\\mathrm{GeV}$ (this is the center-of-mass energy; it is not directly needed in the final scaling but defines the physical context).\n- Use $m_0 = 0.14\\,\\mathrm{GeV}$.\n- Use baseline $\\kappa_0 = 0.18\\,\\mathrm{GeV}^2$.\n- Use baseline charged multiplicity $N_{\\text{ch},0} = 20.90$ (dimensionless).\n- Use charged fraction $f_{\\text{ch}} = 2/3$ (dimensionless).\n\nTest suite:\n- Evaluate the model for the following $\\kappa$ values (in $\\mathrm{GeV}^2$): $\\{0.05,\\;0.14,\\;0.18,\\;0.22,\\;0.50\\}$.\n- For each $\\kappa$ in the above set, compute:\n  - The predicted average charged multiplicity $N_{\\text{ch}}(\\kappa)$ (dimensionless).\n  - The predicted mean transverse momentum $\\langle p_T \\rangle(\\kappa)$ in $\\mathrm{GeV}$.\n\nAngle units do not apply. There are no percentages in the answers.\n\nFinal output format:\n- Your program should produce a single line of output containing all results as a comma-separated list enclosed in square brackets, ordered as\n  [$N_{\\text{ch}}(\\kappa_1)$, $\\langle p_T \\rangle(\\kappa_1)$, $N_{\\text{ch}}(\\kappa_2)$, $\\langle p_T \\rangle(\\kappa_2)$, …].\n- Express $N_{\\text{ch}}(\\kappa)$ as a float rounded to two decimals (dimensionless), and $\\langle p_T \\rangle(\\kappa)$ as a float rounded to three decimals in $\\mathrm{GeV}$.\n- For the provided test suite, this means the output must contain $10$ numbers in total.\n\nYour code must be self-contained and not require any input. It must implement the derivation described above and then compute and print the results in the exact format specified.", "solution": "The problem is valid as it is scientifically grounded in the established Lund string model of hadronization, is mathematically well-posed with sufficient information for a unique solution, and is expressed in objective, formal language. The provided parameters are physically reasonable for the context of $e^+e^-$ annihilation at the $Z$ pole.\n\nThe problem requires the calculation of the average charged hadron multiplicity $N_{\\text{ch}}$ and the mean hadron transverse momentum $\\langle p_T \\rangle$ as a function of the string tension $\\kappa$. The derivation proceeds in three main steps as outlined.\n\n**Step 1: Single Quark and Hadron Transverse Momentum Distributions**\n\nThe probability density for producing a quark-antiquark pair via quantum tunneling in the string is given as proportional to $\\exp(-\\pi m_T^2 / \\kappa)$. For the purpose of the transverse momentum distribution, we can assume the constituent quarks are massless, so their transverse mass squared is $m_T^2 = p_{T,q}^2$, where $\\vec{p}_{T,q} = (p_x, p_y)$ is the transverse momentum of the quark relative to the string axis. The probability density function for $\\vec{p}_{T,q}$ is therefore a two-dimensional Gaussian:\n$$\nf_q(p_x, p_y) = C \\exp\\left(-\\frac{\\pi}{\\kappa}(p_x^2 + p_y^2)\\right)\n$$\nwhere $C$ is a normalization constant. A standard 2D Gaussian for independent components, each with variance $\\sigma^2$, is written as:\n$$\nf(p_x, p_y) = \\frac{1}{2\\pi\\sigma^2} \\exp\\left(-\\frac{p_x^2 + p_y^2}{2\\sigma^2}\\right)\n$$\nBy comparing the exponents, we can identify $\\frac{1}{2\\sigma^2} = \\frac{\\pi}{\\kappa}$. This yields the variance for each Cartesian component of a single quark's transverse momentum:\n$$\n\\sigma^2 = \\frac{\\kappa}{2\\pi}\n$$\nA hadron's transverse momentum $\\vec{P}_T$ is the vector sum of the transverse momenta of its constituent quark ($\\vec{p}_{T,q}$) and antiquark ($\\vec{p}_{T,\\bar{q}}$): $\\vec{P}_T = \\vec{p}_{T,q} + \\vec{p}_{T,\\bar{q}}$. The problem states that $\\vec{p}_{T,q}$ and $\\vec{p}_{T,\\bar{q}}$ are independent and identically distributed random vectors. The components of $\\vec{p}_{T,q}$ and $\\vec{p}_{T,\\bar{q}}$ are independent Gaussian variables with mean $0$ and variance $\\sigma^2 = \\kappa/(2\\pi)$.\n\nThe components of the hadron's momentum, $P_x = p_{x,q} + p_{x,\\bar{q}}$ and $P_y = p_{y,q} + p_{y,\\bar{q}}$, are also Gaussian random variables. The mean of each component is $\\langle P_x \\rangle = \\langle p_{x,q} \\rangle + \\langle p_{x,\\bar{q}} \\rangle = 0$ and similarly $\\langle P_y \\rangle = 0$. The variance of the sum of two independent random variables is the sum of their variances. Thus, the variance for each component of the hadron's transverse momentum, denoted $\\sigma_H^2$, is:\n$$\n\\sigma_H^2 = \\mathrm{Var}(P_x) = \\mathrm{Var}(p_{x,q}) + \\mathrm{Var}(p_{x,\\bar{q}}) = \\sigma^2 + \\sigma^2 = 2\\sigma^2 = 2\\left(\\frac{\\kappa}{2\\pi}\\right) = \\frac{\\kappa}{\\pi}\n$$\nThe magnitude of the hadron's transverse momentum, $p_T = |\\vec{P}_T| = \\sqrt{P_x^2 + P_y^2}$, follows a Rayleigh distribution because its components $P_x$ and $P_y$ are independent and identically distributed zero-mean Gaussian variables. The probability density function of $p_T$ is $f_H(p_T) = \\frac{p_T}{\\sigma_H^2} \\exp\\left(-\\frac{p_T^2}{2\\sigma_H^2}\\right)$. The mean of this distribution, $\\langle p_T \\rangle$, is given by the standard formula for a Rayleigh distribution:\n$$\n\\langle p_T \\rangle = \\sigma_H \\sqrt{\\frac{\\pi}{2}}\n$$\nSubstituting our result for $\\sigma_H = \\sqrt{\\kappa/\\pi}$, we obtain the mean hadron transverse momentum as a function of $\\kappa$:\n$$\n\\langle p_T \\rangle(\\kappa) = \\sqrt{\\frac{\\kappa}{\\pi}} \\sqrt{\\frac{\\pi}{2}} = \\sqrt{\\frac{\\kappa}{2}}\n$$\n\n**Step 2: Average Transverse Mass and Multiplicity Scaling**\n\nNext, we determine the average transverse mass, $\\langle m_T \\rangle$, using the specified approximation $\\langle m_T \\rangle \\approx \\sqrt{m_0^2 + \\langle p_T^2 \\rangle}$, where $m_0$ is a representative hadron rest mass. To do this, we must first compute the mean squared transverse momentum, $\\langle p_T^2 \\rangle$.\n$$\n\\langle p_T^2 \\rangle = \\langle P_x^2 + P_y^2 \\rangle = \\langle P_x^2 \\rangle + \\langle P_y^2 \\rangle\n$$\nFor a zero-mean Gaussian variable, the variance is equal to the mean of its square. Therefore, $\\langle P_x^2 \\rangle = \\mathrm{Var}(P_x) = \\sigma_H^2$ and $\\langle P_y^2 \\rangle = \\mathrm{Var}(P_y) = \\sigma_H^2$. This gives:\n$$\n\\langle p_T^2 \\rangle(\\kappa) = \\sigma_H^2 + \\sigma_H^2 = 2\\sigma_H^2 = 2\\frac{\\kappa}{\\pi}\n$$\nWe can now write the expression for the average transverse mass:\n$$\n\\langle m_T \\rangle(\\kappa) \\approx \\sqrt{m_0^2 + \\frac{2\\kappa}{\\pi}}\n$$\nThe problem posits that the total hadron multiplicity $N_{\\text{tot}}$ scales inversely with the average transverse mass, derived from energy conservation at a fixed center-of-mass energy $\\sqrt{s}$. This implies the product $N_{\\text{tot}}(\\kappa) \\langle m_T \\rangle(\\kappa)$ is constant. We calibrate this constant using the baseline point $(\\kappa_0, N_{\\text{ch},0})$. The total multiplicity is related to the charged multiplicity by $N_{\\text{tot}} = N_{\\text{ch}} / f_{\\text{ch}}$, where $f_{\\text{ch}}$ is the charged fraction.\n$$\n\\frac{N_{\\text{ch}}(\\kappa)}{f_{\\text{ch}}} \\langle m_T \\rangle(\\kappa) = \\frac{N_{\\text{ch},0}}{f_{\\text{ch}}} \\langle m_T \\rangle(\\kappa_0)\n$$\nThe factor $f_{\\text{ch}}$ cancels, leaving a direct scaling relation for the charged multiplicity:\n$$\nN_{\\text{ch}}(\\kappa) = N_{\\text{ch},0} \\frac{\\langle m_T \\rangle(\\kappa_0)}{\\langle m_T \\rangle(\\kappa)}\n$$\nSubstituting our derived expression for $\\langle m_T \\rangle(\\kappa)$ yields the final formula for the predicted charged multiplicity:\n$$\nN_{\\text{ch}}(\\kappa) = N_{\\text{ch},0} \\frac{\\sqrt{m_0^2 + 2\\kappa_0/\\pi}}{\\sqrt{m_0^2 + 2\\kappa/\\pi}}\n$$\n\n**Step 3: Numerical Computation**\n\nWe are given the numerical inputs:\n- $m_0 = 0.14\\,\\mathrm{GeV}$\n- $\\kappa_0 = 0.18\\,\\mathrm{GeV}^2$\n- $N_{\\text{ch},0} = 20.90$\n- Test values for $\\kappa$ are $\\{0.05, 0.14, 0.18, 0.22, 0.50\\}$ in units of $\\mathrm{GeV}^2$.\n\nThe quantities to be computed for each test value of $\\kappa$ are:\n1.  The mean transverse momentum: $\\langle p_T \\rangle(\\kappa) = \\sqrt{\\kappa/2}$.\n2.  The average charged multiplicity: $N_{\\text{ch}}(\\kappa) = N_{\\text{ch},0} \\frac{\\sqrt{m_0^2 + 2\\kappa_0/\\pi}}{\\sqrt{m_0^2 + 2\\kappa/\\pi}}$.\n\nThe following program implements these formulas, calculates the values for the specified test suite, and formats the output as required.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes hadron multiplicity and mean transverse momentum based on the Lund string model.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        0.05,  # kappa in GeV^2\n        0.14,\n        0.18,\n        0.22,\n        0.50,\n    ]\n\n    # Define physical constants and baseline values\n    m0 = 0.14      # Representative hadron rest mass in GeV\n    k0 = 0.18      # Baseline string tension in GeV^2\n    n_ch0 = 20.90  # Baseline charged multiplicity (dimensionless)\n\n    results = []\n\n    # Pre-calculate the numerator term for multiplicity scaling.\n    # The scaling relation is N_ch(k) = (N_ch0 * <m_T>(k0)) / <m_T>(k).\n    # <m_T>(k) = sqrt(m0^2 + 2*k/pi)\n    m_T_k0 = np.sqrt(m0**2 + 2 * k0 / np.pi)\n    \n    # This is the constant product N_ch0 * <m_T>(k0)\n    scaling_numerator = n_ch0 * m_T_k0\n\n    # Iterate through each test value of kappa\n    for kappa in test_cases:\n        # 1. Calculate the predicted mean transverse momentum <p_T>(kappa).\n        # This is derived from the mean of a Rayleigh distribution whose\n        # scale parameter sigma_H = sqrt(kappa / pi).\n        # <p_T>(kappa) = sigma_H * sqrt(pi / 2) = sqrt(kappa / 2).\n        mean_pT = np.sqrt(kappa / 2.0)\n        \n        # 2. Calculate the predicted average transverse mass <m_T>(kappa).\n        # This uses the approximation <m_T> approx sqrt(m0^2 + <p_T^2>).\n        # <p_T^2> = 2 * sigma_H^2 = 2 * kappa / pi.\n        m_T_kappa = np.sqrt(m0**2 + 2 * kappa / np.pi)\n        \n        # 3. Calculate the predicted average charged multiplicity N_ch(kappa).\n        # This uses the scaling relation derived from energy conservation.\n        n_ch_kappa = scaling_numerator / m_T_kappa\n        \n        # Append the results to the list, formatted to the required precision.\n        results.append(f\"{n_ch_kappa:.2f}\")\n        results.append(f\"{mean_pT:.3f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\n# Execute the solver function.\nsolve()\n```", "id": "3538393"}, {"introduction": "A complete simulated event involves not only the production of primary hadrons but also the subsequent decay of all unstable particles. Throughout this complex cascade, fundamental conservation laws stemming from the symmetries of the Standard Model must be rigorously enforced. This final practice places you in the role of a quality control expert, tasked with building a program to audit the conservation of quantum numbers like charge, baryon number, and flavor across the hadronization and decay stages. This exercise will reinforce your understanding of how different interactions (strong, electromagnetic, and weak) are modeled and will highlight the importance of ensuring the physical integrity of the final event record. [@problem_id:3538354]", "problem": "Design and implement a complete, runnable program that audits the conservation of quantum numbers through the stages typically modeled by a general-purpose high-energy physics event generator: the transition from partons to hadrons (hadronization) and subsequent decays. The program must check, for each event, whether the following constraints are satisfied in a scientifically realistic and self-consistent way, based on fundamental symmetry principles.\n\nUse the following base, which is standard in particle physics and event generator design:\n\n- Noether’s theorem implies that continuous symmetries produce conserved quantities. Gauge invariance of the Electromagnetic (EM) interaction corresponds to $U(1)_{\\mathrm{EM}}$, which enforces exact conservation of electric charge $Q$ at every stage.\n- Quantum Chromodynamics (QCD) is a non-Abelian gauge theory with $SU(3)_{\\mathrm{color}}$ symmetry. The strong interaction conserves baryon number $B$ and each flavor quantum number.\n- In the Standard Model (SM), strong and electromagnetic interactions conserve strangeness $S$, charm $C$, and bottomness $\\beta$ (bottomness is defined as $\\beta=-1$ for a bottom quark $b$ and $\\beta=+1$ for an anti-bottom quark $\\bar{b}$). Weak interactions conserve electric charge $Q$ and baryon number $B$ but can change $S$, $C$, and $\\beta$ according to selection rules tied to the Cabibbo-Kobayashi-Maskawa (CKM) matrix.\n\nDefinitions for the checking logic:\n\n- Represent each particle $p$ by a quantum number vector $q(p)=\\left(Q(p),\\,B(p),\\,S(p),\\,C(p),\\,\\beta(p)\\right)$.\n- For a collection of particles $\\{p_i\\}$, define the total as $q_{\\mathrm{tot}}=\\sum_i q(p_i)$, with the sum taken component-wise.\n- Hadronization stage (strong interaction): $Q$, $B$, $S$, $C$, and $\\beta$ must be exactly conserved, i.e., $\\Delta Q=\\Delta B=\\Delta S=\\Delta C=\\Delta \\beta=0$ between the incoming partons and the hadronized hadrons.\n- Decay stage:\n  - For a decay labeled “strong” or “EM”: all components must be conserved exactly, i.e., $\\Delta Q=\\Delta B=\\Delta S=\\Delta C=\\Delta \\beta=0$ between the parent and the sum of products.\n  - For a decay labeled “weak”: $Q$ and $B$ must be conserved exactly, and flavor changes are allowed but constrained by single-vertex selection rules. Enforce $|\\Delta S|\\le 1$, $|\\Delta C|\\le 1$, $|\\Delta \\beta|\\le 1$, and allow simultaneous changes in more than one flavor, but require $|\\Delta S|+|\\Delta C|+|\\Delta \\beta|\\le 3$. This upper bound reflects that a single weak decay can simultaneously change heavy flavor and produce a light flavor through the $W$ boson hadronic decay, yet remains within physically plausible limits for a single decay step.\n\nThe program must:\n\n- Encode a scientifically sound dictionary of particles with their quantum numbers. Use exact rational values for quark charges and baryon numbers to avoid floating-point artifacts; for example, $Q(u)=+\\frac{2}{3}$, $B(u)=+\\frac{1}{3}$, $Q(\\bar{u})=-\\frac{2}{3}$, $B(\\bar{u})=-\\frac{1}{3}$, and similarly for $d, s, c, b$ and their antiparticles. For hadrons, use integer charges and baryon numbers, and compute $S$, $C$, and $\\beta$ from valence content.\n- Process each event containing:\n  - An ordered list of initial partons before hadronization.\n  - A list of hadrons after hadronization.\n  - An ordered list of decay steps, each a triple consisting of a decay mode label (“strong”, “EM”, or “weak”), a parent hadron, and a list of product particles.\n- Implement three checks per event:\n  $1)$ Hadronization conservation: exact conservation of $Q$, $B$, $S$, $C$, $\\beta$ from initial partons to hadronized hadrons.\n  $2)$ Per-step decay conservation: apply the rules above to each decay step in sequence. Removing the parent from the running final-state list and adding its products must be consistent with the conservation rules prescribed by the decay mode.\n  $3)$ Global conservation from initial partons to the final post-decay state: exact conservation of $Q$ and $B$ (weak decays may change $S$, $C$, and $\\beta$, so those are not required to be conserved globally across the entire event once weak decays are applied).\n\nYour program must implement all three checks and return, for each event, a single boolean that is `True` if and only if all checks pass and `False` otherwise.\n\nTest Suite:\nProvide exactly $6$ events covering typical and edge scenarios:\n\n- Case $1$ (happy path; strong hadronization and realistic weak plus EM decays):\n  - Initial partons: $[u, u, d, s, \\bar{s}]$.\n  - Hadronized hadrons: $[p, K^+, K^-]$.\n  - Decays (ordered): $(\\text{weak}, K^+ \\rightarrow \\pi^+\\pi^0)$, $(\\text{weak}, K^- \\rightarrow \\pi^-\\pi^0)$, $(\\text{EM}, \\pi^0 \\rightarrow \\gamma\\gamma)$, $(\\text{EM}, \\pi^0 \\rightarrow \\gamma\\gamma)$.\n- Case $2$ (boundary case; no decays):\n  - Initial partons: $[c, \\bar{u}]$.\n  - Hadronized hadrons: $[D^0]$.\n  - Decays: none.\n- Case $3$ (baryon number leak in hadronization):\n  - Initial partons: $[u, u, d]$.\n  - Hadronized hadrons: $[\\pi^+, \\pi^0]$.\n  - Decays: none.\n- Case $4$ (charge leak in decay):\n  - Initial partons: $[u, d, s]$.\n  - Hadronized hadrons: $[\\Lambda^0]$.\n  - Decays (ordered): $(\\text{weak}, \\Lambda^0 \\rightarrow p\\pi^+)$.\n- Case $5$ (flavor leak in strong hadronization and global $Q$ mismatch):\n  - Initial partons: $[s, \\bar{s}]$.\n  - Hadronized hadrons: $[K^+]$.\n  - Decays: none.\n- Case $6$ (weak decay with unrealistic multi-flavor change in a single step):\n  - Initial partons: $[b, \\bar{u}]$.\n  - Hadronized hadrons: $[B^-]$.\n  - Decays (ordered): $(\\text{weak}, B^- \\rightarrow D^+K^-K^-)$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the boolean results for the $6$ test cases, in order, as a comma-separated list enclosed in square brackets, for example, `[`True`,`False`, ... ]`. There must be no other printed text. No physical units or angles are involved in this problem, and all answers are booleans.", "solution": "The user requires a program to audit the conservation of quantum numbers in simulated high-energy physics events, according to a specified set of physical rules. The problem is scientifically sound, well-posed, and provides all necessary definitions to construct a deterministic solution. It is a valid problem.\n\nThe solution will be implemented by following a structured, principle-based approach.\n\nFirst, we must establish a definitive database of particles and their fundamental quantum numbers: electric charge ($Q$), baryon number ($B$), strangeness ($S$), charm ($C$), and bottomness ($\\beta$). To maintain numerical precision, particularly for the fractional quantum numbers of quarks, Python's `fractions.Fraction` class is indispensable. The quantum numbers for hadrons are derived from their valence quark content, adhering to the principles of the quark model.\n\nThe core of the program will be a function that audits a single event. An event is comprised of three stages: the initial parton state, the post-hadronization hadron state, and a sequence of decays. The audit process involves three distinct checks, as mandated by the problem.\n\n1.  **Hadronization Conservation Check**: This check verifies that the transition from the initial set of partons to the set of primary hadrons conserves all five quantum numbers ($Q, B, S, C, \\beta$) exactly. This reflects the nature of the strong interaction (QCD), which governs hadronization. The total quantum number vector of the initial partons, calculated as the component-wise sum, must equal that of the hadronized particles.\n\n2.  **Per-Step Decay Conservation Check**: This check scrutinizes each decay in the event's history. A running list of final-state particles is maintained, initialized with the hadronized hadrons. For each decay step, the parent particle is removed from this list, and its decay products are added. The validity of the step depends on the interaction mode:\n    *   **Strong and Electromagnetic (EM) Decays**: These must conserve all five quantum numbers exactly. The total quantum number vector of the decay products must equal that of the parent particle.\n    *   **Weak Decays**: These are subject to different rules. Electric charge ($Q$) and baryon number ($B$) must be conserved exactly. However, flavor quantum numbers ($S, C, \\beta$) can change, but within specific constraints: $|\\Delta S| \\le 1$, $|\\Delta C| \\le 1$, $|\\Delta \\beta| \\le 1$, and $|\\Delta S| + |\\Delta C| + |\\Delta \\beta| \\le 3$. These rules are simplifications of the SM's CKM mechanism for single-vertex weak decays.\n    If any decay step violates its corresponding rule, the entire event is flagged as invalid.\n\n3.  **Global Conservation Check**: After processing all decays, this final check ensures that certain fundamental quantities are conserved over the entire event evolution, from the initial partons to the final, stable (or quasi-stable) particles. In the Standard Model, all interactions, including weak ones, conserve electric charge and baryon number. Therefore, we verify that the total $Q$ and total $B$ of the initial partons are equal to the total $Q$ and total $B$ of the final particles. Flavor quantum numbers are not expected to be conserved globally due to weak decays.\n\nAn event is deemed valid (`True`) if and only if it passes all three checks in succession. A failure in any check results in the event being invalid (`False`). The program will process a suite of test cases, each representing a different physical scenario, and output the boolean validity result for each.\nTo facilitate calculations, quantum number vectors will be represented using `numpy` arrays of `Fraction` objects, which allows for clear and arithmetically safe vector operations.", "answer": "```python\nimport numpy as np\nfrom fractions import Fraction\n\ndef solve():\n    \"\"\"\n    Solves the particle physics event auditing problem.\n    \"\"\"\n    \n    # Using 'g' for gamma as in problem statement. Using '_bar' for antiparticles.\n    # Quantum numbers are in the order (Q, B, S, C, beta)\n    # Q: Electric Charge, B: Baryon Number, S: Strangeness, C: Charm, beta: Bottomness\n    PARTICLE_DB = {\n        # Quarks\n        'u': np.array([Fraction(2, 3), Fraction(1, 3), 0, 0, 0]),\n        'd': np.array([Fraction(-1, 3), Fraction(1, 3), 0, 0, 0]),\n        's': np.array([Fraction(-1, 3), Fraction(1, 3), -1, 0, 0]),\n        'c': np.array([Fraction(2, 3), Fraction(1, 3), 0, 1, 0]),\n        'b': np.array([Fraction(-1, 3), Fraction(1, 3), 0, 0, -1]),\n        # Anti-quarks\n        'u_bar': np.array([Fraction(-2, 3), Fraction(-1, 3), 0, 0, 0]),\n        'd_bar': np.array([Fraction(1, 3), Fraction(-1, 3), 0, 0, 0]),\n        's_bar': np.array([Fraction(1, 3), Fraction(-1, 3), 1, 0, 0]),\n        'c_bar': np.array([Fraction(-2, 3), Fraction(-1, 3), 0, -1, 0]),\n        'b_bar': np.array([Fraction(-1, 3), Fraction(-1, 3), 0, 0, 1]),\n        # Hadrons from test cases\n        # Baryons (B=1)\n        'p': np.array([1, 1, 0, 0, 0]),       # uud\n        'Lambda0': np.array([0, 1, -1, 0, 0]), # uds\n        # Mesons (B=0)\n        'K+': np.array([1, 0, 1, 0, 0]),      # us_bar\n        'K-': np.array([-1, 0, -1, 0, 0]),     # su_bar\n        'pi+': np.array([1, 0, 0, 0, 0]),     # ud_bar\n        'pi-': np.array([-1, 0, 0, 0, 0]),    # du_bar\n        'pi0': np.array([0, 0, 0, 0, 0]),     # (uu_bar - dd_bar)/sqrt(2)\n        'D0': np.array([0, 0, 0, 1, 0]),      # cu_bar\n        'D+': np.array([1, 0, 0, 1, 0]),      # cd_bar\n        'B-': np.array([-1, 0, 0, 0, -1]),    # bu_bar\n        # Bosons/Leptons\n        'g': np.array([0, 0, 0, 0, 0]),       # photon\n    }\n\n    def get_total_q(particle_list):\n        \"\"\"Calculates the total quantum number vector for a list of particles.\"\"\"\n        if not particle_list:\n            return np.array([0, 0, 0, 0, 0], dtype=object)\n        \n        q_vectors = [PARTICLE_DB[p] for p in particle_list]\n        return np.sum(q_vectors, axis=0)\n\n    def audit_event(event):\n        \"\"\"Audits a single event based on the three required checks.\"\"\"\n        initial_partons = event['initial_partons']\n        hadronized_hadrons = event['hadronized_hadrons']\n        decays = event['decays']\n\n        # --- Check 1: Hadronization Conservation ---\n        q_initial = get_total_q(initial_partons)\n        q_hadrons = get_total_q(hadronized_hadrons)\n        if not np.array_equal(q_initial, q_hadrons):\n            return False\n\n        # --- Check 2: Per-step Decay Conservation ---\n        current_particles = list(hadronized_hadrons)\n        for mode, parent, products in decays:\n            if parent not in current_particles:\n                return False # Inconsistent decay history\n            \n            q_parent = PARTICLE_DB[parent]\n            q_products = get_total_q(products)\n            delta_q = q_products - q_parent\n            \n            dQ, dB, dS, dC, dBeta = delta_q\n            \n            is_valid_step = False\n            if mode in (\"strong\", \"EM\"):\n                if np.all(delta_q == 0):\n                    is_valid_step = True\n            elif mode == \"weak\":\n                if (dQ == 0 and dB == 0 and\n                    abs(dS) <= 1 and abs(dC) <= 1 and abs(dBeta) <= 1 and\n                    (abs(dS) + abs(dC) + abs(dBeta)) <= 3):\n                    is_valid_step = True\n            \n            if not is_valid_step:\n                return False\n\n            current_particles.remove(parent)\n            current_particles.extend(products)\n        \n        final_particles = current_particles\n        \n        # --- Check 3: Global Conservation ---\n        q_final = get_total_q(final_particles)\n        # Check for Q and B conservation globally\n        if not (q_initial[0] == q_final[0] and q_initial[1] == q_final[1]):\n            return False\n\n        return True\n\n    test_cases = [\n        # Case 1 (happy path)\n        {\n            'initial_partons': ['u', 'u', 'd', 's', 's_bar'],\n            'hadronized_hadrons': ['p', 'K+', 'K-'],\n            'decays': [\n                ('weak', 'K+', ['pi+', 'pi0']),\n                ('weak', 'K-', ['pi-', 'pi0']),\n                ('EM', 'pi0', ['g', 'g']),\n                ('EM', 'pi0', ['g', 'g']),\n            ]\n        },\n        # Case 2 (boundary case; no decays)\n        {\n            'initial_partons': ['c', 'u_bar'],\n            'hadronized_hadrons': ['D0'],\n            'decays': []\n        },\n        # Case 3 (baryon number leak in hadronization)\n        {\n            'initial_partons': ['u', 'u', 'd'],\n            'hadronized_hadrons': ['pi+', 'pi0'],\n            'decays': []\n        },\n        # Case 4 (charge leak in decay)\n        {\n            'initial_partons': ['u', 'd', 's'],\n            'hadronized_hadrons': ['Lambda0'],\n            'decays': [\n                ('weak', 'Lambda0', ['p', 'pi+'])\n            ]\n        },\n        # Case 5 (flavor leak in strong hadronization and global Q mismatch)\n        {\n            'initial_partons': ['s', 's_bar'],\n            'hadronized_hadrons': ['K+'],\n            'decays': []\n        },\n        # Case 6 (weak decay with unrealistic multi-flavor change)\n        {\n            'initial_partons': ['b', 'u_bar'],\n            'hadronized_hadrons': ['B-'],\n            'decays': [\n                ('weak', 'B-', ['D+', 'K-', 'K-'])\n            ]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = audit_event(case)\n        results.append(str(result))\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n\n```", "id": "3538354"}]}