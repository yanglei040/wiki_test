{"hands_on_practices": [{"introduction": "Before an automated system can compute a scattering amplitude, it must have a well-defined and complete description of the event's kinematics. This description must be built from Lorentz-invariant quantities to ensure the result is physically meaningful. This fundamental exercise [@problem_id:3505457] has you derive from first principles the minimal number of independent scalar variables required to fully specify the kinematics of a generic $n$-particle massless scattering process, a result crucial for constructing the phase space of any matrix element generator.", "problem": "Consider a generic Quantum Field Theory (QFT) tree-level scattering process within the Standard Model in four-dimensional Minkowski spacetime. In automated matrix-element generation, a code must represent kinematics using Lorentz-invariant scalars constructed from external momenta. Let a $2 \\to 2$ massless scattering process have incoming four-momenta $p_{1}$ and $p_{2}$, and outgoing four-momenta $p_{3}$ and $p_{4}$, all satisfying $p_{i}^{2} = 0$ and total momentum conservation $\\sum_{i=1}^{4} p_{i} = 0$. Define the canonical Mandelstam invariants from first principles, and deduce their dependence in the massless case.\n\nThen, generalize to an $n$-point massless amplitude in four dimensions, with $n \\geq 4$ external lightlike momenta $\\{p_{1},\\dots,p_{n}\\}$ obeying $p_{i}^{2} = 0$ and $\\sum_{i=1}^{n} p_{i} = 0$. Starting strictly from the on-shell conditions, total momentum conservation, and global Lorentz invariance, derive the minimal number of independent Lorentz-invariant scalars required to fully parametrize generic external kinematics up to a global Lorentz transformation. Construct an explicit minimal set composed exclusively of two-particle invariants $s_{ij} \\equiv 2\\,p_{i}\\cdot p_{j}$ appropriate for use in automated codes, and justify its independence.\n\nYour final answer must be the single closed-form expression for the minimal number of independent invariants as a function of $n$. No intermediate equalities are permitted as the final answer. If you introduce any numerical quantity, do not round unless explicitly instructed, and no rounding is requested here. Express all mathematics in LaTeX, and state units only if needed; none are needed here. Angles, if any appear, must be in radians; none are needed here.", "solution": "The problem asks for a derivation of the minimal number of independent Lorentz-invariant scalars required to parametrize the kinematics of an $n$-point massless scattering amplitude in four-dimensional spacetime. First, the specific case of $2 \\to 2$ scattering ($n=4$) will be analyzed, followed by the generalization to arbitrary $n \\geq 4$.\n\nThe provided constraints are that all external four-momenta $\\{p_1, \\dots, p_n\\}$ are lightlike (on-shell and massless), satisfying $p_i^2 = 0$, and that total momentum is conserved, $\\sum_{i=1}^n p_i = 0$. The latter convention, where all momenta are treated on an equal footing (e.g., all incoming or all outgoing), is standard in automated matrix element generation systems. The Lorentz-invariant scalars are defined as $s_{ij} \\equiv 2 p_i \\cdot p_j$. Note that with the on-shell condition $p_i^2=0$, an alternative common definition $s_{ij} \\equiv (p_i+p_j)^2$ is equivalent, since $(p_i+p_j)^2 = p_i^2 + p_j^2 + 2 p_i \\cdot p_j = 0 + 0 + 2 p_i \\cdot p_j = s_{ij}$.\n\n**Part 1: Analysis of $2 \\to 2$ Scattering ($n=4$)**\n\nFor a $2 \\to 2$ process with massless particles, we have four momenta $p_1, p_2, p_3, p_4$ satisfying $p_i^2 = 0$ for $i \\in \\{1,2,3,4\\}$ and $p_1+p_2+p_3+p_4=0$.\nThe problem asks to define the canonical Mandelstam invariants. In the physical scattering process $p_1 + p_2 \\to p_3' + p_4'$, momentum conservation is $p_1+p_2 = p_3'+p_4'$. To match the problem's convention $\\sum p_i=0$, we identify the outgoing physical momenta as $p_3 = -p_3'$ and $p_4 = -p_4'$. The standard Mandelstam variables are:\n$$s = (p_1+p_2)^2$$\n$$t = (p_1-p_3')^2 = (p_1+p_3)^2$$\n$$u = (p_1-p_4')^2 = (p_1+p_4)^2$$\nUsing the on-shell condition $p_i^2=0$, these become:\n$$s = 2 p_1 \\cdot p_2 = s_{12}$$\n$$t = 2 p_1 \\cdot p_3 = s_{13}$$\n$$u = 2 p_1 \\cdot p_4 = s_{14}$$\nTo find the dependence among them, we use the momentum conservation law. By taking the dot product of $p_1$ with the conservation equation $\\sum_{j=1}^4 p_j=0$, we get:\n$$p_1 \\cdot (p_1+p_2+p_3+p_4) = 0$$\n$$p_1^2 + p_1 \\cdot p_2 + p_1 \\cdot p_3 + p_1 \\cdot p_4 = 0$$\nSince $p_1^2=0$, and using the definitions of $s_{ij}$, this yields:\n$$\\frac{1}{2}s_{12} + \\frac{1}{2}s_{13} + \\frac{1}{2}s_{14} = 0$$\n$$s+t+u = 0$$\nThis is the well-known relation for massless $2 \\to 2$ scattering. It demonstrates that only two of the three Mandelstam variables are independent. For example, given $s$ and $t$, $u$ is fixed. Thus, for $n=4$, the minimal number of independent invariants is $2$.\n\n**Part 2: Generalization to $n$-Point Amplitudes**\n\nWe now derive the minimal number of independent Lorentz-invariant scalars needed to specify the kinematics for a generic $n$-point massless scattering process in $D=4$ dimensions. The number of such scalars is equal to the dimension of the moduli space of kinematic configurations. We can calculate this dimension by counting the total degrees of freedom and subtracting those removed by constraints and symmetries.\n\n1.  **Initial Degrees of Freedom**: We begin with $n$ four-vectors, $\\{p_1, \\dots, p_n\\}$. Each four-vector $p_i$ has $D=4$ components. Thus, the total number of initial variables is $n \\times D = 4n$.\n\n2.  **Constraints**: The system is subject to two types of physical constraints:\n    *   **On-shell Conditions**: Each particle is massless and on-shell, meaning its four-momentum squared is zero: $p_i^2 = 0$. This provides $n$ independent scalar equations.\n    *   **Momentum Conservation**: The total momentum is conserved: $\\sum_{i=1}^n p_i = 0$. This is a vector equation, providing $D=4$ independent scalar constraints.\n\n    The number of variables remaining after imposing these constraints is $4n - n - 4 = 3n - 4$.\n\n3.  **Symmetry Redundancy**: A physical scattering amplitude is independent of the observer's inertial reference frame. The kinematics are therefore defined only up to a global Lorentz transformation. The set of such transformations forms the Lorentz group, $SO(1, D-1)$. The number of parameters (or generators) of this group is $\\binom{D}{2}$. For $D=4$, the number of parameters is $\\binom{4}{2} = 6$ (three spatial rotations and three Lorentz boosts). These transformations do not change the Lorentz-invariant scalars, so the $3n-4$ variables we counted above are not independent invariants. We must subtract the number of parameters of the Lorentz group to find the dimension of the space of invariants.\n\n4.  **Minimal Number of Invariants**: The minimal number of independent Lorentz-invariant scalars is the number of kinematic variables minus the number of parameters of the Lorentz group:\n    $$N_{\\text{indep}} = (nD - n - D) - \\binom{D}{2}$$\n    Substituting $D=4$:\n    $$N_{\\text{indep}} = (4n - n - 4) - \\binom{4}{2} = (3n - 4) - 6 = 3n - 10$$\n    This formula is valid for $n \\ge 4$. For $n=4$, it correctly yields $3(4) - 10 = 2$. For $n=5$, it yields $3(5) - 10 = 5$.\n\n**Construction of an Explicit Minimal Set**\n\nThe problem requires the construction of an explicit minimal set of $3n-10$ independent invariants of the form $s_{ij} = 2 p_i \\cdot p_j$. The total number of such invariants is $\\binom{n}{2}$, which for $n>4$ is larger than $3n-10$. This implies the existence of non-trivial relations among the $s_{ij}$. These relations arise from two sources:\n1.  **Linear Constraints**: From momentum conservation, for any $i \\in \\{1, \\dots, n\\}$, we have $\\sum_{j \\neq i} s_{ij} = 2 p_i \\cdot \\sum_{j \\neq i} p_j = 2 p_i \\cdot (-p_i) = -2 p_i^2 = 0$. There are $n-1$ independent relations of this type.\n2.  **Non-linear Constraints**: The fact that the momenta exist in a $D=4$ dimensional spacetime imposes further non-linear constraints, known as Gram determinant conditions. For any set of $k>D$ vectors, the determinant of their Gram matrix (matrix of dot products) must vanish. Due to momentum conservation, the rank of the Gram matrix of all $n$ momenta is at most $D-1=3$. These conditions lead to complex polynomial relations among the $s_{ij}$.\n\nConstructing a basis requires a careful selection of $s_{ij}$ that avoids all such linear and non-linear dependencies. A valid construction for a minimal set of $3n-10$ independent invariants for generic kinematics (i.e., not restricted to a lower-dimensional subspace) for $n \\ge 4$ is as follows:\n$$ \\mathcal{B} = \\{s_{1,j} \\mid j=2, \\dots, n-2\\} \\cup \\{s_{2,j} \\mid j=3, \\dots, n-1\\} \\cup \\{s_{3,j} \\mid j=4, \\dots, n-1\\} $$\nLet's verify the size of this set. The number of elements is:\n$$ ( (n-2) - 2 + 1 ) + ( (n-1) - 3 + 1 ) + ( (n-1) - 4 + 1 ) = (n-3) + (n-3) + (n-4) = 3n-10 $$\nThe count is correct for $n \\ge 5$. For the edge case $n=4$, the set is $\\{s_{1,2}\\} \\cup \\{s_{2,3}\\} \\cup \\emptyset$, giving two invariants, $\\{s_{12}, s_{23}\\}$. This is a valid basis, as $s_{13}$ can be determined via the linear relations (e.g., $s_{13}=s_{24}$ and $s_{12}+s_{13}+s_{14}=0$).\n\nThe independence of this set for generic kinematics is non-trivial to prove formally but can be understood intuitively. The invariants involving $p_1, p_2, p_3$ serve to establish a \"reference frame\", and the remaining invariants position the other momenta $p_4, \\dots, p_{n-1}$ with respect to this frame ($p_n$ is then fixed by momentum conservation). The specific indices are chosen to avoid the simplest dependencies while spanning the full $3n-10$ dimensional space.\n\nThe final answer requested is the single closed-form expression for the minimal number of independent invariants as a function of $n$. Based on the counting of degrees of freedom, this number is $3n-10$.", "answer": "$$\\boxed{3n-10}$$", "id": "3505457"}, {"introduction": "A key task in automating matrix element generation is the systematic enumeration of all contributing Feynman diagrams. A naive approach can generate thousands of diagrams that are structurally identical but differ only in the arbitrary labeling of their nodes, leading to massive redundancy. This computational practice [@problem_id:3505556] addresses this challenge by having you implement a canonicalization algorithm based on graph theory, a technique used by real-world generators to identify and store only the unique topologies.", "problem": "You are tasked with designing and validating a canonicalization module for tree-level Feynman diagram topologies in non-Abelian gauge theory, with a focus on automated matrix element generation. At tree level in Yang–Mills theory, pure-gluon diagrams can be represented by undirected trees where internal interaction vertices have degree $3$ (cubic representation) and external legs (gluons) correspond to degree-$1$ leaves. Two such trees represent the same diagram topology if and only if they are isomorphic as unlabeled graphs. The computational problem is to algorithmically identify and merge duplicates arising from graph isomorphism, which is a key step in automated matrix element generation to avoid redundant evaluation of identical topologies.\n\nStarting from the following foundational bases:\n\n- The definition of graph isomorphism: two undirected graphs $G = (V,E)$ and $G' = (V',E')$ are isomorphic if there exists a bijection $\\phi: V \\to V'$ such that for every unordered pair $\\{u,v\\} \\subset V$ one has $\\{u,v\\} \\in E$ if and only if $\\{\\phi(u),\\phi(v)\\} \\in E'$.\n- The concept of a tree: an undirected connected acyclic graph.\n- The combinatorial fact that a full binary rooted tree with $n$ leaves, when converted to an unrooted tree by suppressing the root (contracting its two incident edges into one), produces an unrooted tree whose internal vertices all have degree $3$ and whose leaves have degree $1$; this is a standard cubic representation of tree-level gluon diagrams.\n- The well-tested method for tree isomorphism via canonical forms using centers and rooted canonical encodings, where the center of a tree is obtained by iteratively removing leaves until one or two nodes remain.\n\nYour program must:\n\n1. Implement a canonicalization routine for undirected trees that returns a canonical string representative that is identical for isomorphic trees and distinct for non-isomorphic trees. The routine must:\n   - For an unrooted tree, find its center(s) by iteratively removing leaves.\n   - For a rooted tree, compute a canonical encoding recursively by collecting canonical encodings of subtrees, sorting them, and concatenating them with delimiters. The unrooted canonical form is chosen as the lexicographically minimal rooted canonical form taken over the center(s).\n2. Generate tree ensembles representing $n$-gluon tree topologies as follows:\n   - Enumerate all ordered full binary rooted trees with $n$ leaves by recursively splitting $n$ into $k$ and $n-k$ leaves for $k \\in \\{1,\\dots,n-1\\}$ and combining left and right subtrees. Then convert each to an unrooted cubic tree by suppressing the root (removing the root and connecting its two children by an edge), producing an undirected tree graph in which internal nodes have degree $3$ and leaves have degree $1$.\n   - Create ensembles with random node label permutations to simulate random labeling. For these, random bijections on node identifiers must be applied to generate isomorphic copies of the same topology.\n3. Use the canonicalization routine to compress each ensemble into unique topologies and report the number of distinct canonical representatives found.\n\nDesign choices must be derived from the definitions above and must not rely on any pre-baked graph isomorphism library. All graph manipulations should be explicit in your code.\n\nTest Suite and Required Output:\n\nImplement the following test cases, each producing an integer count of unique topologies across the described ensemble:\n- Case A (label-invariance validation): For $n = 7$, choose any single unrooted cubic tree generated by the enumeration described above, then generate $M = 50$ isomorphic copies by applying $50$ independent, uniformly random permutations of node identifiers. Compute the canonical form for each and count the number of unique canonical representatives. This should validate that isomorphic relabelings are merged. Use a fixed pseudorandom seed so the result is deterministic.\n- Case B (happy path enumeration): For $n = 6$, enumerate all ordered full binary rooted trees with $n$ leaves, convert each to an unrooted cubic tree, canonicalize, and count the number of unique representatives.\n- Case C (growing complexity): Same as Case B but for $n = 7$.\n- Case D (increased coverage): Same as Case B but for $n = 8$.\n- Case E (boundary case): Same as Case B but for $n = 3$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets in the order [Case A, Case B, Case C, Case D, Case E], for example, \"[1,2,3,6,1]\". No physical units are involved, and no angles are involved. All outputs are integers.", "solution": "The posed problem concerns the canonicalization of tree-level Feynman diagram topologies in the context of automated matrix element generation for non-Abelian gauge theories, such as Yang-Mills theory. At tree level, pure-gluon scattering amplitudes are represented by a specific class of graphs: unrooted, undirected trees where all internal vertices have a degree of $3$ and external particles (gluons) correspond to leaves of degree $1$. The fundamental computational challenge is that many different labeled graphs, arising from the enumeration process, can correspond to the same underlying physical topology. Identifying and eliminating these duplicates is crucial for efficiency. This is precisely the graph isomorphism problem, applied to this specific family of trees.\n\nThe solution rests upon the principle of defining a canonical representation for each tree. A canonical form is a unique string or label for an entire isomorphism class of graphs. Two graphs are isomorphic if, and only if, their canonical forms are identical. The problem specifies a robust, standard algorithm for tree canonicalization that leverages the structural properties of trees, namely their center(s).\n\n**Theoretical and Algorithmic Framework**\n\n1.  **Graph Representation**: An undirected graph is represented using an adjacency list, specifically a dictionary where keys are integer vertex identifiers and values are lists of adjacent vertex identifiers.\n\n2.  **Topology Generation**: The initial set of candidate topologies is generated by enumerating all *ordered full binary rooted trees* with $n$ leaves. The number of such trees is the $(n-1)$-th Catalan number, $C_{n-1}$. This enumeration is performed recursively: to form a tree with $n$ leaves, we combine a left subtree with $k$ leaves and a right subtree with $n-k$ leaves, for all possible partitions where $k \\in \\{1, 2, \\dots, n-1\\}$. Each abstract tree structure is then realized as a concrete graph. A rooted graph with $n$ leaves and $n-1$ internal nodes is built, for a total of $2n-1$ vertices. This rooted tree is then converted to the required unrooted cubic tree representation by \"suppressing the root.\" This operation involves removing the root vertex and connecting its two children with a new edge. The resulting graph has $n$ leaves (degree $1$) and $n-2$ internal vertices (degree $3$), accurately modeling an $n$-gluon tree-level interaction.\n\n3.  **Canonicalization via Tree Centers**: The core of the solution is the canonical labeling algorithm, which proceeds in three steps:\n    a. **Finding the Center**: The center of an unrooted tree provides a unique structural reference point. It consists of either one vertex (a unicentered tree) or two adjacent vertices (a bicentered tree). The center is found by an iterative pruning algorithm: all vertices of degree $1$ (leaves) are removed. This process is repeated on the resulting smaller tree until only one or two vertices remain. These final vertices form the center.\n    b. **Rooted Canonical Form**: Once a tree is conceptually \"rooted\" at a vertex, its canonical form can be computed recursively. For a given node, the canonical forms of the subtrees hanging off its children are computed first. These resulting strings are then sorted lexicographically and concatenated, enclosed by delimiters (parentheses in this implementation) to form the canonical string for the node. A leaf, having no children, has a base canonical form, `()`. The recursive definition is:\n    $$\n    \\text{CanonicalForm}(\\text{node}) = \\text{\"(\"} + \\text{sorted\\_join}(\\{\\text{CanonicalForm}(\\text{child}_i)\\}) + \\text{\")\"}\n    $$\n    c. **Unrooted Canonical Form**: The canonical form for the original unrooted tree is determined by its center. It is defined as the lexicographically *minimal* rooted canonical form, where the candidates are generated by rooting the tree at each of its central vertices. If the center is a single vertex $c$, there is only one candidate form. If the center is a pair of vertices $\\{c_1, c_2\\}$, we compute the rooted canonical forms with respect to both $c_1$ and $c_2$ and choose the lexicographically smaller string. This procedure ensures a unique outcome for any given tree topology, regardless of initial vertex labeling.\n\n4.  **Test Suite and Verification**: The algorithm is validated against a specified test suite:\n    *   **Case A ($n=7$, label invariance)**: This case acts as a sanity check. A single tree topology is created, and $M=50$ isomorphic copies are generated by applying random permutations to its vertex labels. A correct canonicalization algorithm must map all these differently labeled but structurally identical graphs to the same canonical string. Thus, the number of unique representatives must be $1$.\n    *   **Cases B, C, D, E ($n=6, 7, 8, 3$)**: These cases test the full enumeration and canonicalization pipeline. For each $n$, all ordered binary trees are generated, converted to unrooted cubic trees, and canonicalized. The number of unique canonical forms found corresponds to the number of distinct unlabeled cubic trees with $n$ leaves. These quantities are known in combinatorics and provide a definitive verification of the algorithm's correctness. The expected counts for distinct tree topologies for $n=3, 6, 7, 8$ are $1, 2, 3, 6$ respectively.\n\nThe implementation encapsulates these principles into a set of functions that generate, manipulate, and canonicalize the tree graphs, ultimately computing the required counts for each test case.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import defaultdict\nimport sys\n\n# It is necessary to increase the recursion limit for deeper tree structures\n# that can arise during generation, particularly for n=8.\nsys.setrecursionlimit(3000)\n\n_memo_generate_trees = {}\n\ndef generate_ordered_binary_trees(n):\n    \"\"\"\n    Recursively generates all ordered full binary trees with n leaves.\n    The trees are represented as nested tuples, where () is a leaf.\n    Uses memoization to avoid recomputing for the same n.\n    \"\"\"\n    if n in _memo_generate_trees:\n        return _memo_generate_trees[n]\n    if n == 1:\n        return [()]  # A leaf is represented by an empty tuple\n    \n    trees = []\n    for k in range(1, n):\n        left_subtrees = generate_ordered_binary_trees(k)\n        right_subtrees = generate_ordered_binary_trees(n - k)\n        for L in left_subtrees:\n            for R in right_subtrees:\n                trees.append((L, R))\n    \n    _memo_generate_trees[n] = trees\n    return trees\n\ndef build_graph_from_tuple(tree_tuple, n_leaves):\n    \"\"\"\n    Converts a nested tuple representation of a rooted binary tree\n    into an adjacency list graph representation.\n    Leaves are labeled 0 to n-1, internal nodes from n upwards.\n    Returns the adjacency list and the ID of the root node.\n    \"\"\"\n    adj = defaultdict(list)\n    leaf_counter = [0]\n    internal_counter = [n_leaves]\n\n    def _build(subtree):\n        # Base case: a leaf node\n        if not subtree:\n            node_id = leaf_counter[0]\n            leaf_counter[0] += 1\n            return node_id\n\n        # Recursive step: an internal node\n        node_id = internal_counter[0]\n        internal_counter[0] += 1\n        \n        left_id = _build(subtree[0])\n        right_id = _build(subtree[1])\n\n        adj[node_id].append(left_id)\n        adj[left_id].append(node_id)\n        adj[node_id].append(right_id)\n        adj[right_id].append(node_id)\n        \n        return node_id\n\n    root_id = _build(tree_tuple)\n    return dict(adj), root_id\n\ndef convert_to_unrooted(adj, root_id):\n    \"\"\"\n    Converts a rooted binary tree graph to an unrooted cubic tree by\n    suppressing the root: removing the root and connecting its two children.\n    \"\"\"\n    unrooted_adj = {k: list(v) for k, v in adj.items()}\n    \n    # A tree with n=2 leaves becomes a single edge between the leaves.\n    if len(adj) == 3 and n_leaves_from_adj(adj) == 2:\n        leaves = [k for k, v in adj.items() if len(v) == 1]\n        l1, l2 = leaves\n        return {l1: [l2], l2: [l1]}\n\n    if root_id not in unrooted_adj or len(unrooted_adj[root_id]) != 2:\n         # This block handles simple cases or malformed inputs gracefully.\n         # For n=3+, the root will always have 2 children in our generation scheme.\n         return unrooted_adj\n\n    c1, c2 = unrooted_adj[root_id]\n    \n    del unrooted_adj[root_id]\n    \n    unrooted_adj[c1].remove(root_id)\n    unrooted_adj[c2].remove(root_id)\n    \n    unrooted_adj[c1].append(c2)\n    unrooted_adj[c2].append(c1)\n    \n    return unrooted_adj\n\ndef find_center(adj):\n    \"\"\"\n    Finds the center(s) of a tree by iteratively removing leaves.\n    Returns a list containing one or two central node IDs.\n    \"\"\"\n    if not adj:\n        return []\n    if len(adj) <= 2:\n        return list(adj.keys())\n\n    nodes = set(adj.keys())\n    degrees = {node: len(neighbors) for node, neighbors in adj.items()}\n    \n    leaves = [node for node, deg in degrees.items() if deg == 1]\n    \n    count = len(leaves)\n    while len(nodes) - count > 0:\n        new_leaves = []\n        for leaf in leaves:\n            for neighbor in adj[leaf]:\n                degrees[neighbor] -= 1\n                if degrees[neighbor] == 1:\n                    new_leaves.append(neighbor)\n        count += len(new_leaves)\n        if not new_leaves:\n            break\n        leaves = new_leaves\n        \n    return leaves\n\ndef _rooted_canonical_form(adj, root, parent):\n    \"\"\"\n    Recursively computes the canonical string for a tree rooted at `root`.\n    `parent` is used to prevent traversing backwards.\n    \"\"\"\n    children = [n for n in adj.get(root, []) if n != parent]\n    if not children:\n        return \"()\"\n    \n    child_forms = []\n    for child in children:\n        child_forms.append(_rooted_canonical_form(adj, child, root))\n    \n    child_forms.sort()\n    return \"(\" + \"\".join(child_forms) + \")\"\n\ndef get_canonical_form(adj):\n    \"\"\"\n    Computes the canonical form of an unrooted tree by finding its center(s)\n    and choosing the lexicographically minimal rooted representation.\n    \"\"\"\n    if not adj: return \"\"\n    if len(adj) == 1: return \"()\"\n\n    centers = find_center(adj)\n    \n    candidate_forms = []\n    for c in centers:\n        # parent is set to a value guaranteed not to be a node ID\n        candidate_forms.append(_rooted_canonical_form(adj, c, -1))\n        \n    return min(candidate_forms)\n\ndef n_leaves_from_adj(adj):\n    \"\"\"Helper to count leaves (degree-1 nodes) in a graph.\"\"\"\n    return sum(1 for node in adj if len(adj[node]) == 1)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases_params = [\n        {'type': 'A', 'n': 7, 'M': 50},\n        {'type': 'B', 'n': 6},\n        {'type': 'C', 'n': 7},\n        {'type': 'D', 'n': 8},\n        {'type': 'E', 'n': 3},\n    ]\n\n    results = []\n    \n    # Pre-clear memoization for clean runs if solve() were called multiple times\n    _memo_generate_trees.clear()\n\n    for case in test_cases_params:\n        n = case['n']\n        \n        if case['type'] == 'A':\n            # Case A: Validate canonicalization on isomorphic graphs\n            canonical_forms = set()\n            # Generate a single representative tree for n=7\n            # We pick the first one generated for simplicity.\n            first_tree_tuple = generate_ordered_binary_trees(n)[0]\n            base_adj, root_id = build_graph_from_tuple(first_tree_tuple, n)\n            base_unrooted_adj = convert_to_unrooted(base_adj, root_id)\n            \n            canonical_forms.add(get_canonical_form(base_unrooted_adj))\n            \n            # Generate M isomorphic copies by permuting node labels\n            nodes = sorted(list(base_unrooted_adj.keys()))\n            num_nodes = len(nodes)\n            rng = np.random.default_rng(seed=42) # for deterministic result\n            \n            for _ in range(case['M']):\n                perm = rng.permutation(nodes)\n                mapping = {old: new for old, new in zip(nodes, perm)}\n                \n                permuted_adj = defaultdict(list)\n                for u, neighbors in base_unrooted_adj.items():\n                    new_u = mapping[u]\n                    for v in neighbors:\n                        new_v = mapping[v]\n                        permuted_adj[new_u].append(new_v)\n                \n                canonical_forms.add(get_canonical_form(dict(permuted_adj)))\n\n            results.append(len(canonical_forms))\n\n        else:\n            # Cases B, C, D, E: Enumerate and count unique topologies\n            ordered_trees = generate_ordered_binary_trees(n)\n            canonical_forms = set()\n\n            for tree_tuple in ordered_trees:\n                adj, root_id = build_graph_from_tuple(tree_tuple, n)\n                unrooted_adj = convert_to_unrooted(adj, root_id)\n                form = get_canonical_form(unrooted_adj)\n                canonical_forms.add(form)\n\n            results.append(len(canonical_forms))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3505556"}, {"introduction": "The true power of automated calculation lies in its ability to tackle complex, realistic processes and test the deep structure of our physical theories. This capstone exercise [@problem_id:3505533] moves from abstract algorithms to concrete physics by testing the Goldstone boson equivalence theorem, a profound consequence of electroweak symmetry breaking. By numerically comparing the production of longitudinal $W$ bosons with that of their corresponding Goldstone bosons at high energy, you will not only implement a full Standard Model calculation but also gain insight into the non-trivial cancellations that ensure the consistency of gauge theories.", "problem": "You are tasked with designing and implementing a complete, runnable program that numerically tests the Goldstone boson equivalence theorem at tree level by comparing the unpolarized, spin-averaged squared matrix elements for the processes $f\\bar f \\to W_L^+ W_L^-$ and $f\\bar f \\to \\phi^+ \\phi^-$ at high energy, while quantifying the finite-energy deviations. The context is the Standard Model (SM) electroweak sector at tree level in Feynman gauge, with all external fermions treated as massless and widths neglected. You must proceed from first principles based on well-tested formulas and definitions from quantum field theory and the Standard Model (SM).\n\nStart from the following foundational base:\n- Use the Minkowski metric with signature $g_{\\mu\\nu} = \\mathrm{diag}(+1,-1,-1,-1)$.\n- The unpolarized spin-summed and spin-averaged initial-state fermion current correlator for massless fermions is\n$$\n\\frac{1}{4}\\sum_{\\text{spins}} J_\\mu^{(V)} J_\\nu^{(V')*} = \\frac{1}{2}\\left(g_L^{(V)} g_L^{(V')} + g_R^{(V)} g_R^{(V')}\\right) \\left(p_{2\\mu} p_{1\\nu} + p_{2\\nu} p_{1\\mu} - g_{\\mu\\nu}\\, p_1\\cdot p_2\\right),\n$$\nwhere $J_\\mu^{(V)} = \\bar v(p_2) \\gamma_\\mu (g_L^{(V)} P_L + g_R^{(V)} P_R) u(p_1)$ and $P_{L,R} = \\tfrac{1}{2}(1 \\mp \\gamma^5)$.\n- For $f\\bar f \\to \\phi^+ \\phi^-$ via $s$-channel neutral gauge boson exchange $V \\in \\{\\gamma, Z\\}$, the scalar current is derivative-coupled: the $V\\phi\\phi$ vertex is $i g_{V\\phi} (k_+ - k_-)^\\mu$.\n- For $f\\bar f \\to W^+ W^-$ via $s$-channel $V \\in \\{\\gamma,Z\\}$, the trilinear gauge vertex is\n$$\n\\Gamma_{\\mu\\alpha\\beta}(q,k_+,k_-) = (k_- - k_+)_\\mu g_{\\alpha\\beta} + (q - 2 k_-)_\\alpha g_{\\beta\\mu} + (2 k_+ - q)_\\beta g_{\\mu\\alpha},\n$$\nwith $q = p_1 + p_2 = k_+ + k_-$, and the vector boson propagator taken as $-i g_{\\mu\\nu}/(s - m_V^2)$.\n- The longitudinal polarization vector for an on-shell $W$ boson of mass $m_W$ and four-momentum $k^\\mu = (E,\\vec{k})$ is\n$$\n\\varepsilon_L^\\mu(k) = \\left(\\frac{|\\vec{k}|}{m_W}, \\frac{E}{m_W}\\,\\hat{k}\\right),\n$$\nwith $\\hat{k} = \\vec{k}/|\\vec{k}|$, satisfying $\\varepsilon_L\\cdot k = 0$ and $\\varepsilon_L^2 = -1$.\n- Electroweak couplings at tree level:\n    - Electric charge $e = \\sqrt{4\\pi \\alpha_{\\mathrm{em}}}$.\n    - Weak mixing: $\\cos\\theta_W = m_W/m_Z$, $\\sin^2\\theta_W = 1 - \\cos^2\\theta_W$, and $g = e/\\sin\\theta_W$.\n    - Initial-state fermion taken as an up-type quark $f = u$: electric charge $Q_f = +\\tfrac{2}{3}$, weak isospin $T_3^f = +\\tfrac{1}{2}$ for left chiral component and $T_3^f = 0$ for right chiral component. The neutral-current chiral couplings are\n      $$\n      g_L^{(Z)} = \\frac{g}{\\cos\\theta_W}\\left(T_3^f - Q_f \\sin^2\\theta_W\\right),\\quad\n      g_R^{(Z)} = -\\frac{g}{\\cos\\theta_W}\\,Q_f \\sin^2\\theta_W,\n      $$\n      and for the photon $g_L^{(\\gamma)} = g_R^{(\\gamma)} = e Q_f$.\n    - Goldstone couplings: for $\\phi^\\pm$ as the charged components of the Higgs doublet with $T_3^\\phi = +\\tfrac{1}{2}$ and $Q_\\phi=+1$,\n      $$\n      g_{Z\\phi} = \\frac{g}{\\cos\\theta_W}\\left(T_3^\\phi - \\sin^2\\theta_W Q_\\phi\\right) = \\frac{g}{\\cos\\theta_W}\\left(\\tfrac{1}{2} - \\sin^2\\theta_W\\right),\\quad g_{\\gamma\\phi} = e Q_\\phi = e.\n      $$\n    - Trilinear gauge couplings: $g_{\\gamma WW} = e$, $g_{ZWW} = e \\cot\\theta_W$.\n\nYou must:\n1. Construct the kinematics in the center-of-mass frame for $f(p_1)\\bar f(p_2)\\to X(k_+) Y(k_-)$ with $X,Y\\in\\{W^+_L,W^-_L\\}$ or $X,Y\\in\\{\\phi^+,\\phi^-\\}$. Use $p_1^\\mu = (\\sqrt{s}/2,0,0,+\\sqrt{s}/2)$, $p_2^\\mu = (\\sqrt{s}/2,0,0,-\\sqrt{s}/2)$, $k_\\pm^\\mu = (E_W,\\pm |\\vec{k}|\\sin\\theta,0,\\pm |\\vec{k}|\\cos\\theta)$, where $E_W = \\sqrt{s}/2$ and $|\\vec{k}| = \\sqrt{E_W^2 - m_W^2}$. Take the Goldstone boson mass equal to $m_W$, which corresponds to Feynman gauge.\n2. For $f\\bar f \\to \\phi^+ \\phi^-$, form the vector\n$$\nS_V^\\mu = \\frac{g_{V\\phi}}{s - m_V^2} (k_+ - k_-)^\\mu,\\quad V\\in\\{\\gamma,Z\\},\\ m_\\gamma = 0.\n$$\n3. For $f\\bar f \\to W_L^+ W_L^-$, form the vector\n$$\nX_V^\\mu = \\frac{g_{VWW}}{s - m_V^2}\\left[(k_- - k_+ )^\\mu (\\varepsilon_+\\cdot \\varepsilon_-) + \\big((q - 2k_-)\\cdot \\varepsilon_+\\big)\\,\\varepsilon_-^\\mu + \\big((2k_+ - q)\\cdot \\varepsilon_- \\big)\\,\\varepsilon_+^\\mu \\right],\n$$\nwith $\\varepsilon_\\pm^\\mu$ the longitudinal polarization vectors of $W^\\pm$.\n4. Using the spin-averaged current correlator above, compute the unpolarized, spin-averaged squared matrix element as\n$$\n\\overline{|{\\cal M}|^2} = \\frac{1}{2}\\sum_{V,V'\\in\\{\\gamma,Z\\}}\\left(g_L^{(V)} g_L^{(V')} + g_R^{(V)} g_R^{(V')}\\right)\\left[p_2\\cdot A_V\\,\\, p_1\\cdot A_{V'} + p_2\\cdot A_{V'}\\,\\, p_1\\cdot A_V - (p_1\\cdot p_2)\\, A_V\\cdot A_{V'}\\right],\n$$\nwhere $A_V^\\mu$ is $S_V^\\mu$ for the scalar channel and $X_V^\\mu$ for the longitudinal vector channel, and all dot products are Minkowski with $g_{\\mu\\nu}$.\n5. Quantify the finite-energy deviation by computing the dimensionless ratio\n$$\n\\delta(s,\\cos\\theta) = \\frac{\\overline{|{\\cal M}(f\\bar f\\to W_L^+ W_L^-)|^2}}{\\overline{|{\\cal M}(f\\bar f\\to \\phi^+ \\phi^-)|^2}} - 1,\n$$\nwhich is expected to approach $0$ as $\\sqrt{s}\\to \\infty$ according to the Goldstone boson equivalence theorem.\n\nUse the following physical constants and conventions:\n- $m_W = 80.379$ GeV, $m_Z = 91.1876$ GeV, $\\alpha_{\\mathrm{em}} = 1/127.95$, $m_\\gamma = 0$ GeV.\n- All energies must be in GeV. Angles must be specified via $\\cos\\theta$, which is dimensionless.\n\nTest suite:\n- Provide results for the following parameter sets $(\\sqrt{s}\\,\\text{[GeV]}, \\cos\\theta)$:\n  - $(200.0, 0.0)$,\n  - $(500.0, 0.3)$,\n  - $(1000.0, -0.7)$,\n  - $(3000.0, 0.9)$,\n  - $(170.0, 0.0)$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the same order as the test suite, for example: $[\\delta_1,\\delta_2,\\delta_3,\\delta_4,\\delta_5]$.", "solution": "We aim to test the Goldstone boson equivalence theorem by comparing the unpolarized, spin-averaged squared matrix elements for $f\\bar f\\to W_L^+W_L^-$ and $f\\bar f\\to \\phi^+\\phi^-$ in the Standard Model (SM) at tree level. The theorem predicts that, for $\\sqrt{s}\\gg m_W$, the amplitudes for longitudinally polarized vector boson pair production should coincide with those for the corresponding Goldstone boson pair, modulo corrections suppressed by inverse powers of energy.\n\nPrinciple-based setup:\n1. Kinematics and metric. We work in the center-of-mass (CoM) frame with Minkowski metric $g_{\\mu\\nu} = \\mathrm{diag}(+1,-1,-1,-1)$. Incoming momenta are $p_1^\\mu=(\\sqrt{s}/2,0,0,+\\sqrt{s}/2)$ and $p_2^\\mu=(\\sqrt{s}/2,0,0,-\\sqrt{s}/2)$. Outgoing momenta $k_\\pm^\\mu$ have energies $E_W=\\sqrt{s}/2$ and three-momenta $\\vec{k}_\\pm = \\pm |\\vec{k}|(\\sin\\theta,0,\\cos\\theta)$ with $|\\vec{k}|=\\sqrt{E_W^2-m_W^2}$. We take the Goldstone boson mass equal to $m_W$ in Feynman gauge so that the kinematics are identical for $W_L^+W_L^-$ and $\\phi^+\\phi^-$. The total momentum is $q^\\mu=p_1^\\mu+p_2^\\mu=k_+^\\mu+k_-^\\mu$.\n\n2. Electroweak couplings. At tree level, the electromagnetic coupling is $e=\\sqrt{4\\pi\\alpha_{\\mathrm{em}}}$, and the weak mixing parameters are $\\cos\\theta_W = m_W/m_Z$, $\\sin\\theta_W = \\sqrt{1-\\cos^2\\theta_W}$, and $g=e/\\sin\\theta_W$. For the initial up-type quark, the chiral neutral-current couplings are\n$$\ng_L^{(Z)}=\\frac{g}{\\cos\\theta_W}\\left(T_3^f - Q_f\\sin^2\\theta_W\\right),\\quad g_R^{(Z)}=-\\frac{g}{\\cos\\theta_W}Q_f\\sin^2\\theta_W,\n$$\nwith $Q_f=+\\tfrac{2}{3}$ and $T_3^f=+\\tfrac{1}{2}$ for the left-chiral component, and $T_3^f=0$ for the right-chiral component. For the photon, $g_L^{(\\gamma)}=g_R^{(\\gamma)}=eQ_f$. For the Goldstones, $g_{\\gamma\\phi}=e Q_\\phi=e$ and $g_{Z\\phi}=\\frac{g}{\\cos\\theta_W}\\left(\\tfrac{1}{2}-\\sin^2\\theta_W\\right)$. For the trilinear gauge couplings, $g_{\\gamma WW}=e$ and $g_{ZWW}=e\\cot\\theta_W$.\n\n3. Longitudinal polarization. The exact longitudinal polarization vector for a massive vector boson is chosen as\n$$\n\\varepsilon_L^\\mu(k) = \\left(\\frac{|\\vec{k}|}{m_W}, \\frac{E_W}{m_W}\\,\\hat{k}\\right),\n$$\nwith $\\hat{k}=\\vec{k}/|\\vec{k}|$. It satisfies $\\varepsilon_L\\cdot k=0$ and $\\varepsilon_L^2=-1$ with our metric.\n\n4. Amplitudes via Feynman rules. For $s$-channel exchange $V\\in\\{\\gamma,Z\\}$ with propagator $-ig_{\\mu\\nu}/(s-m_V^2)$ and real couplings, the amplitude for a given $V$ factorizes into a fermion current and a final-state structure. We define, for the scalar channel,\n$$\nS_V^\\mu = \\frac{g_{V\\phi}}{s-m_V^2}(k_+ - k_-)^\\mu,\n$$\nand for the vector channel,\n$$\nX_V^\\mu = \\frac{g_{VWW}}{s-m_V^2}\\left[(k_- - k_+ )^\\mu (\\varepsilon_+\\cdot \\varepsilon_-) + \\big((q - 2k_-)\\cdot \\varepsilon_+\\big)\\,\\varepsilon_-^\\mu + \\big((2k_+ - q)\\cdot \\varepsilon_- \\big)\\,\\varepsilon_+^\\mu \\right],\n$$\nwhich result from contracting the trilinear vertex with the longitudinal polarization vectors. The full amplitude is a sum over $V\\in\\{\\gamma,Z\\}$ with fermion current $J_\\mu^{(V)}=\\bar v \\gamma_\\mu (g_L^{(V)}P_L+g_R^{(V)}P_R) u$.\n\n5. Spin averaging using traces. For massless fermions, the unpolarized spin-summed and spin-averaged current correlator is\n$$\n\\frac{1}{4}\\sum_{\\text{spins}} J_\\mu^{(V)} J_\\nu^{(V')*} = \\frac{1}{2}\\left(g_L^{(V)} g_L^{(V')} + g_R^{(V)} g_R^{(V')}\\right) \\left(p_{2\\mu} p_{1\\nu} + p_{2\\nu} p_{1\\mu} - g_{\\mu\\nu}\\, p_1\\cdot p_2\\right).\n$$\nThus the unpolarized, spin-averaged squared amplitude takes the compact form\n$$\n\\overline{|{\\cal M}|^2} = \\frac{1}{2}\\sum_{V,V'\\in\\{\\gamma,Z\\}}\\left(g_L^{(V)} g_L^{(V')} + g_R^{(V)} g_R^{(V')}\\right)\\left[p_2\\cdot A_V\\,\\, p_1\\cdot A_{V'} + p_2\\cdot A_{V'}\\,\\, p_1\\cdot A_V - (p_1\\cdot p_2)\\, A_V\\cdot A_{V'}\\right],\n$$\nwhere $A_V^\\mu = S_V^\\mu$ for the $\\phi^+\\phi^-$ channel and $A_V^\\mu = X_V^\\mu$ for the $W_L^+W_L^-$ channel.\n\n6. Goldstone boson equivalence theorem and deviation. The equivalence theorem states that\n$$\n{\\cal M}(f\\bar f \\to W_L^+ W_L^-)\\;=\\;{\\cal M}(f\\bar f \\to \\phi^+ \\phi^-)\\;+\\;{\\cal O}\\!\\left(\\frac{m_W}{\\sqrt{s}}\\right),\n$$\nso that, at large $\\sqrt{s}$, the ratio of unpolarized squared matrix elements,\n$$\n\\delta(s,\\cos\\theta) = \\frac{\\overline{|{\\cal M}(f\\bar f\\to W_L^+ W_L^-)|^2}}{\\overline{|{\\cal M}(f\\bar f\\to \\phi^+ \\phi^-)|^2}} - 1,\n$$\ntends to $0$. Finite-energy corrections arise from using exact longitudinal polarization vectors and the full trilinear vertex rather than replacing $W_L$ by $\\phi$ directly.\n\nAlgorithmic implementation:\n- Build four-vectors for $p_1$, $p_2$, $k_\\pm$ from $(\\sqrt{s},\\cos\\theta)$, with energies in GeV.\n- Construct $\\varepsilon_\\pm^\\mu$ for the longitudinal $W^\\pm$.\n- Compute $S_V^\\mu$ and $X_V^\\mu$ for each $V\\in\\{\\gamma,Z\\}$ using the couplings and propagators.\n- Compute all Minkowski dot products using $g_{\\mu\\nu}=\\mathrm{diag}(+1,-1,-1,-1)$.\n- Assemble $\\overline{|{\\cal M}|^2}$ for both channels using the trace-based tensor contraction:\n$$\nT_{\\mu\\nu} = p_{2\\mu}p_{1\\nu} + p_{2\\nu}p_{1\\mu} - g_{\\mu\\nu}\\,p_1\\cdot p_2,\n$$\nand the contraction\n$$\n{\\cal C}(A,B) = p_2\\cdot A\\, p_1\\cdot B + p_2\\cdot B\\, p_1\\cdot A - (p_1\\cdot p_2)\\, A\\cdot B.\n$$\n- Form $\\delta(s,\\cos\\theta)$ and report the results for the test suite.\n\nParameter choices:\n- $m_W = 80.379$ GeV, $m_Z = 91.1876$ GeV, $\\alpha_{\\mathrm{em}} = 1/127.95$, $m_\\gamma = 0$ GeV.\n- $\\cos\\theta_W = m_W/m_Z$, $\\sin^2\\theta_W = 1-\\cos^2\\theta_W$, $e=\\sqrt{4\\pi\\alpha_{\\mathrm{em}}}$, $g=e/\\sin\\theta_W$.\n- Up-quark initial state: $Q_f=+\\tfrac{2}{3}$, $T_3^f=+\\tfrac{1}{2}$ (left), $T_3^f=0$ (right).\n\nTest suite and output:\n- Evaluate $\\delta$ for the ordered list of $(\\sqrt{s}\\,[\\mathrm{GeV}],\\cos\\theta)$:\n  - $(200.0, 0.0)$,\n  - $(500.0, 0.3)$,\n  - $(1000.0, -0.7)$,\n  - $(3000.0, 0.9)$,\n  - $(170.0, 0.0)$.\n- Print a single line: a comma-separated list within square brackets, e.g., $[\\delta_1,\\delta_2,\\delta_3,\\delta_4,\\delta_5]$.\n\nThis construction strictly follows from the Standard Model Feynman rules, Lorentz invariance, and spin averaging via trace technology, ensuring a first-principles, gauge-invariant comparison of the two channels. The deviations at finite energy quantify the subleading corrections beyond the asymptotic high-energy limit.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Minkowski metric with signature (+,-,-,-)\nETA = np.diag([1.0, -1.0, -1.0, -1.0])\n\ndef minkowski_dot(a, b):\n    \"\"\"Minkowski dot product with metric diag(+,-,-,-).\"\"\"\n    return float(a[0]*b[0] - a[1]*b[1] - a[2]*b[2] - a[3]*b[3])\n\ndef vector_add(a, b):\n    return a + b\n\ndef vector_sub(a, b):\n    return a - b\n\ndef scalar_mul(c, a):\n    return c * a\n\ndef polarization_longitudinal(k, m):\n    \"\"\"\n    Exact longitudinal polarization vector for a massive vector boson with 4-momentum k=(E,kx,ky,kz),\n    epsilon_L = (|k|/m, (E/m) * k_hat), where k_hat = k_vec / |k|.\n    \"\"\"\n    E = k[0]\n    kv = k[1:]\n    p = np.linalg.norm(kv)\n    if p <= 0.0:\n        # At exact threshold, choose an arbitrary direction; here default z.\n        khat = np.array([0.0, 0.0, 1.0])\n    else:\n        khat = kv / p\n    eps0 = p / m\n    eps_spatial = (E / m) * khat\n    return np.array([eps0, eps_spatial[0], eps_spatial[1], eps_spatial[2]], dtype=float)\n\ndef build_kinematics(sqrt_s, cos_theta, mW):\n    \"\"\"\n    Build 4-vectors in the COM frame:\n    p1=(E,0,0,+E), p2=(E,0,0,-E),\n    k+ and k- with scattering angle theta and equal energies E_W = sqrt_s/2.\n    \"\"\"\n    Ecm = sqrt_s\n    E = Ecm / 2.0\n    p1 = np.array([E, 0.0, 0.0, +E], dtype=float)\n    p2 = np.array([E, 0.0, 0.0, -E], dtype=float)\n\n    # Final-state W momenta\n    EW = E\n    p_abs_sq = EW*EW - mW*mW\n    if p_abs_sq <= 0:\n        p_abs = 0.0\n    else:\n        p_abs = np.sqrt(p_abs_sq)\n\n    # Ensure cos_theta within [-1,1]\n    ct = float(np.clip(cos_theta, -1.0, 1.0))\n    st_sq = max(0.0, 1.0 - ct*ct)\n    st = np.sqrt(st_sq)\n\n    k_plus = np.array([EW, +p_abs*st, 0.0, +p_abs*ct], dtype=float)\n    k_minus = np.array([EW, -p_abs*st, 0.0, -p_abs*ct], dtype=float)\n\n    return p1, p2, k_plus, k_minus\n\ndef build_couplings():\n    \"\"\"\n    Electroweak parameters and couplings.\n    \"\"\"\n    # Physical constants (GeV)\n    mW = 80.379\n    mZ = 91.1876\n    alpha_em = 1.0 / 127.95\n    e = np.sqrt(4.0 * np.pi * alpha_em)\n    cW = mW / mZ\n    sW = np.sqrt(max(0.0, 1.0 - cW*cW))\n    g = e / sW\n\n    # Initial-state fermion: up-quark\n    Qf = +2.0/3.0\n    T3L = +0.5  # only for left-chiral; right has T3=0\n\n    # Chiral couplings to Z\n    gL_Z = (g / cW) * (T3L - Qf * sW*sW)\n    gR_Z = -(g / cW) * (Qf * sW*sW)\n\n    # Photon couplings (vector-like)\n    gL_A = e * Qf\n    gR_A = e * Qf\n\n    # Goldstone couplings\n    Qphi = +1.0\n    T3phi = +0.5\n    g_A_phi = e * Qphi\n    g_Z_phi = (g / cW) * (T3phi - (sW*sW) * Qphi)\n\n    # Trilinear gauge couplings\n    g_A_WW = e\n    g_Z_WW = e * cW / sW  # = g * cW\n\n    # Vector boson masses\n    mA = 0.0\n    mZ_val = mZ\n\n    couplings = {\n        \"e\": e,\n        \"g\": g,\n        \"sW\": sW,\n        \"cW\": cW,\n        \"mW\": mW,\n        \"mZ\": mZ_val,\n        \"mA\": mA,\n        # fermion chiral couplings\n        \"gL\": {\"A\": gL_A, \"Z\": gL_Z},\n        \"gR\": {\"A\": gR_A, \"Z\": gR_Z},\n        # scalar and trilinear couplings\n        \"gVphi\": {\"A\": g_A_phi, \"Z\": g_Z_phi},\n        \"gVWW\": {\"A\": g_A_WW, \"Z\": g_Z_WW},\n    }\n    return couplings\n\ndef A_vector_scalar_channel(p1, p2, k_plus, k_minus, V, couplings):\n    \"\"\"\n    Build A_V^\\mu for scalar channel: S_V^\\mu = g_{Vphi}/(s - m_V^2) * (k_plus - k_minus)^\\mu\n    \"\"\"\n    q = vector_add(k_plus, k_minus)\n    s = minkowski_dot(q, q)\n    if V == \"A\":\n        mV2 = 0.0\n    else:\n        mV2 = couplings[\"mZ\"]**2\n    denom = s - mV2\n    gVphi = couplings[\"gVphi\"][V]\n    vec = vector_sub(k_plus, k_minus)\n    return scalar_mul(gVphi / denom, vec)\n\ndef A_vector_vector_channel(p1, p2, k_plus, k_minus, V, couplings):\n    \"\"\"\n    Build A_V^\\mu for vector channel with longitudinal polarizations.\n    X_V^\\mu = g_{VWW}/(s - m_V^2) [ (k_- - k_+ )^\\mu (epsp·epsm) + ((q - 2k_- )·epsp) epsm^\\mu + ((2k_+ - q)·epsm) epsp^\\mu ]\n    \"\"\"\n    q = vector_add(k_plus, k_minus)\n    s = minkowski_dot(q, q)\n    if V == \"A\":\n        mV2 = 0.0\n    else:\n        mV2 = couplings[\"mZ\"]**2\n    denom = s - mV2\n    gVWW = couplings[\"gVWW\"][V]\n\n    # Longitudinal polarization vectors\n    eps_p = polarization_longitudinal(k_plus, couplings[\"mW\"])\n    eps_m = polarization_longitudinal(k_minus, couplings[\"mW\"])\n\n    # Compute needed components\n    km_minus_kp = vector_sub(k_minus, k_plus)\n    q_minus_2km = vector_sub(q, scalar_mul(2.0, k_minus))\n    two_kp_minus_q = vector_sub(scalar_mul(2.0, k_plus), q)\n\n    epsp_dot_epsm = minkowski_dot(eps_p, eps_m)\n    qmk_dot_epsp = minkowski_dot(q_minus_2km, eps_p)\n    tkmq_dot_epsm = minkowski_dot(two_kp_minus_q, eps_m)\n\n    term1 = scalar_mul(epsp_dot_epsm, km_minus_kp)\n    term2 = scalar_mul(qmk_dot_epsp, eps_m)\n    term3 = scalar_mul(tkmq_dot_epsm, eps_p)\n\n    X = vector_add(term1, vector_add(term2, term3))\n    return scalar_mul(gVWW / denom, X)\n\ndef contraction_T(p1, p2, A, B):\n    \"\"\"\n    Compute C(A,B) = p2·A p1·B + p2·B p1·A - (p1·p2) A·B\n    \"\"\"\n    p2dotA = minkowski_dot(p2, A)\n    p1dotB = minkowski_dot(p1, B)\n    p2dotB = minkowski_dot(p2, B)\n    p1dotA = minkowski_dot(p1, A)\n    p1dotp2 = minkowski_dot(p1, p2)\n    AdotB = minkowski_dot(A, B)\n    return p2dotA * p1dotB + p2dotB * p1dotA - p1dotp2 * AdotB\n\ndef M2_unpolarized_channel(p1, p2, k_plus, k_minus, channel, couplings):\n    \"\"\"\n    Compute the unpolarized, spin-averaged squared matrix element:\n    M2 = (1/2) sum_{V,V' in {A,Z}} (gL^V gL^V' + gR^V gR^V') * C(A_V, A_V')\n    where A_V is S_V for scalar channel or X_V for vector channel.\n    \"\"\"\n    # Build A_V for V in A,Z\n    if channel == \"scalar\":\n        AV = {\n            \"A\": A_vector_scalar_channel(p1, p2, k_plus, k_minus, \"A\", couplings),\n            \"Z\": A_vector_scalar_channel(p1, p2, k_plus, k_minus, \"Z\", couplings),\n        }\n    elif channel == \"vector\":\n        AV = {\n            \"A\": A_vector_vector_channel(p1, p2, k_plus, k_minus, \"A\", couplings),\n            \"Z\": A_vector_vector_channel(p1, p2, k_plus, k_minus, \"Z\", couplings),\n        }\n    else:\n        raise ValueError(\"Unknown channel\")\n\n    gL = couplings[\"gL\"]\n    gR = couplings[\"gR\"]\n\n    # Sum over V,V'\n    M2 = 0.0\n    for V in (\"A\", \"Z\"):\n        for Vp in (\"A\", \"Z\"):\n            coeff = 0.5 * (gL[V] * gL[Vp] + gR[V] * gR[Vp])\n            M2 += coeff * contraction_T(p1, p2, AV[V], AV[Vp])\n    return M2\n\ndef compute_delta(sqrt_s, cos_theta, couplings):\n    \"\"\"\n    Compute delta(s,cosθ) = M2_vector / M2_scalar - 1.\n    \"\"\"\n    mW = couplings[\"mW\"]\n    p1, p2, k_plus, k_minus = build_kinematics(sqrt_s, cos_theta, mW)\n    # sanity check: ensure above threshold to avoid kinematic issues\n    # Build matrix elements\n    M2_scalar = M2_unpolarized_channel(p1, p2, k_plus, k_minus, \"scalar\", couplings)\n    M2_vector = M2_unpolarized_channel(p1, p2, k_plus, k_minus, \"vector\", couplings)\n    # Avoid division by zero\n    if M2_scalar == 0.0:\n        return np.nan\n    return (M2_vector / M2_scalar) - 1.0\n\ndef solve():\n    # Define the test cases from the problem statement as (sqrt(s) in GeV, cos(theta))\n    test_cases = [\n        (200.0, 0.0),\n        (500.0, 0.3),\n        (1000.0, -0.7),\n        (3000.0, 0.9),\n        (170.0, 0.0),\n    ]\n\n    couplings = build_couplings()\n\n    results = []\n    for sqrt_s, cos_theta in test_cases:\n        delta = compute_delta(sqrt_s, cos_theta, couplings)\n        results.append(delta)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3505533"}]}