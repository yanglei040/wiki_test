{"hands_on_practices": [{"introduction": "Before analyzing complex algorithms, we must first understand the finite nature of computer arithmetic. This exercise tackles catastrophic cancellation, a common pitfall where subtracting two nearly-equal numbers leads to a disastrous loss of precision. By analyzing the function $f(x) = \\frac{1 - \\cos x}{x^2}$ for small $x$, you will learn to identify, quantify, and remedy this fundamental source of numerical error, a critical skill for high-precision scientific computing [@problem_id:3527080].", "problem": "In high-accuracy gravitational-wave template generation and weak lensing map synthesis, small-angle trigonometric combinations routinely arise and can suffer catastrophic cancellation when evaluated naively in floating-point arithmetic. Consider the function $f(x) = \\frac{1 - \\cos x}{x^2}$ at the small angle $x = 10^{-8}$ radians. Assume arithmetic is performed in binary64 double precision conforming to the Institute of Electrical and Electronics Engineers (IEEE) 754 standard, with rounding to nearest, ties to even, and correctly rounded elementary functions.\n\nStarting from fundamental series expansions for trigonometric functions and the standard floating-point rounding model, analyze the numerical stability of computing $f(x)$ as written. Specifically:\n\n1. Using the Taylor series for $\\cos x$ and properties of IEEE 754 double precision, quantify the loss of significance in the naive evaluation of $f(x)$ at $x = 10^{-8}$ due to subtractive cancellation in $1 - \\cos x$.\n2. Construct a mathematically equivalent reformulation of $f(x)$ that avoids subtractive cancellation and is numerically stable for small $x$. Justify its stability from first principles.\n3. Derive a forward relative error bound for evaluating your reformulated expression under the standard model $\\operatorname{fl}(a \\circ b) = (a \\circ b)(1 + \\delta)$ with $|\\delta| \\leq u$ for each basic operation $\\circ$, where $u$ is the unit roundoff of binary64 double precision. Treat the evaluation of elementary functions similarly, with a single rounding step that is correctly rounded.\n4. Verify the bound with a short calculation at $x = 10^{-8}$ by estimating the exact value of $f(x)$ from the Taylor series and comparing it to the computed value implied by your floating-point model analysis. Use this to estimate the observed relative error magnitude for the stable reformulation and check consistency with your bound.\n\nReport as your final quantity the empirically observed relative error, expressed as a unitless decimal, of the naive evaluation of $f(x)$ at $x = 10^{-8}$ under these assumptions. Round your final answer to four significant figures.", "solution": "The problem requires a detailed numerical analysis of the function $f(x) = \\frac{1 - \\cos x}{x^2}$ for a small value of $x$, specifically $x = 10^{-8}$. The analysis will proceed in four parts as outlined in the problem statement. All calculations assume IEEE 754 double precision arithmetic.\n\nFirst, I shall analyze the numerical stability of the naive evaluation, quantifying the loss of significance. Second, I will construct and justify a numerically stable reformulation of the function. Third, a forward relative error bound for this stable reformulation will be derived. Finally, I will verify the analysis and compute the requested final quantity, which is the observed relative error of the naive evaluation.\n\n1. Numerical Stability of the Naive Evaluation\n\nThe function is given by $f(x) = \\frac{1 - \\cos x}{x^2}$. We evaluate it at $x = 10^{-8}$. The primary source of error in this naive formulation is the subtraction in the numerator, $1 - \\cos x$, for small values of $x$.\n\nThe Taylor series expansion of $\\cos x$ around $x=0$ is:\n$$\n\\cos x = 1 - \\frac{x^{2}}{2!} + \\frac{x^{4}}{4!} - \\frac{x^{6}}{6!} + \\mathcal{O}(x^{8})\n$$\nFor $x = 10^{-8}$, the value of $\\cos x$ is:\n$$\n\\cos(10^{-8}) = 1 - \\frac{(10^{-8})^{2}}{2} + \\frac{(10^{-8})^{4}}{24} - \\dots = 1 - 5 \\times 10^{-17} + \\frac{1}{24} \\times 10^{-32} - \\dots\n$$\nThe value of $\\cos(10^{-8})$ is extremely close to $1$. In IEEE 754 double precision (binary64), a floating-point number is stored with a $53$-bit significand. The unit roundoff is $u = 2^{-53} \\approx 1.11022 \\times 10^{-16}$. The spacing between representable numbers around $1$ is the machine epsilon for $1$, which is $\\epsilon_{1} = 2^{-52} \\approx 2.22044 \\times 10^{-16}$.\n\nA real number $y$ is rounded to the nearest representable floating-point number. The tie-breaking rule is \"ties to even\", but that is not relevant here. A number $y$ between two representable numbers $a$ and $b$ is rounded to $a$ if $|y-a|  |y-b|$. The midpoint between the representable numbers $1$ and $1-\\epsilon_1 = 1-2^{-52}$ is $1 - \\epsilon_1/2 = 1 - 2^{-53} = 1-u$.\n\nThe true value of $\\cos(10^{-8})$ must be compared to this midpoint to determine how it is rounded. The true value is $c_{true} = \\cos(10^{-8}) \\approx 1 - 5 \\times 10^{-17}$. We need to determine if $c_{true}$ is greater than or less than the midpoint $1 - u \\approx 1 - 1.11 \\times 10^{-16}$.\nSince $5 \\times 10^{-17}  1.11 \\times 10^{-16}$, it follows that $1 - 5 \\times 10^{-17}  1 - 1.11 \\times 10^{-16}$. Thus, the true value of $\\cos(10^{-8})$ lies in the interval $(1-u, 1)$. As this value is closer to $1$ than to $1-\\epsilon_1$, it is correctly rounded to $1$.\nSo, $\\operatorname{fl}(\\cos(10^{-8})) = 1$.\n\nThe numerator is then computed as $\\operatorname{fl}(1 - \\operatorname{fl}(\\cos(10^{-8}))) = \\operatorname{fl}(1 - 1) = 0$.\nThe denominator is $\\operatorname{fl}(x^2) = \\operatorname{fl}((10^{-8})^2) = \\operatorname{fl}(10^{-16})$, which is a non-zero floating point number. The final computed result is $\\operatorname{fl}(0 / \\operatorname{fl}(10^{-16})) = 0$.\n\nThe true value of $f(x)$ is found from its Taylor series:\n$$\nf(x) = \\frac{1 - (1 - \\frac{x^{2}}{2} + \\frac{x^{4}}{24} - \\dots)}{x^{2}} = \\frac{1}{2} - \\frac{x^{2}}{24} + \\mathcal{O}(x^{4})\n$$\nFor $x=10^{-8}$, the true value is $f_{true} \\approx 1/2$. The computed value is $0$. This phenomenon is called catastrophic cancellation. The subtraction $1-y$ for $y \\approx 1$ loses significant digits. In this case, the difference is smaller than the precision available relative to the operands, leading to a complete loss of significant figures in the result of the subtraction. The relative error is $|0 - (1/2)| / |1/2| = 1$, or $100\\%$. The subtraction loses approximately $-\\log_2(x^2/2) \\approx -\\log_2(5 \\times 10^{-17}) \\approx 54$ bits of information, while only $53$ bits are available in the significand.\n\n2. Stable Reformulation of the Function\n\nTo avoid the catastrophic cancellation in $1 - \\cos x$, we use the half-angle trigonometric identity:\n$$\n1 - \\cos x = 2 \\sin^2\\left(\\frac{x}{2}\\right)\n$$\nSubstituting this into the expression for $f(x)$:\n$$\nf(x) = \\frac{2 \\sin^2(x/2)}{x^{2}} = \\frac{2 \\sin^2(x/2)}{4(x/2)^{2}} = \\frac{1}{2} \\left( \\frac{\\sin(x/2)}{x/2} \\right)^2\n$$\nLet's denote $y = x/2$. The reformulated function is $f(x) = \\frac{1}{2} \\left( \\frac{\\sin y}{y} \\right)^2$. This formulation is numerically stable for small $x$.\n\nThe stability comes from avoiding the subtraction of nearly equal numbers. For small $y$, $\\sin y \\approx y$. The evaluation of $\\sin y$ for a small argument $y$ does not involve internal cancellations and is a well-conditioned operation. The subsequent division by $y$ is also well-conditioned. The condition number of the function $S(y) = \\frac{\\sin y}{y}$ is $\\kappa_S(y) = \\left| \\frac{y S'(y)}{S(y)} \\right| = |y \\cot y - 1|$. As $y \\to 0$, we have $y \\cot y \\approx y(\\frac{1}{y} - \\frac{y}{3}) = 1 - \\frac{y^2}{3}$, so $\\kappa_S(y) \\to 0$. The problem of computing $S(y)$ is inherently well-conditioned for small $y$. Since the reformulated algorithm computes this well-conditioned function using stable operations (division, sine function for small argument, squaring), the overall computation is stable.\n\n3. Forward Relative Error Bound for the Stable Reformulation\n\nLet the stable formulation be $g(y) = \\frac{1}{2} S(y)^2$, where $S(y) = \\frac{\\sin y}{y}$ and $y=x/2$. We analyze the propagation of error using the standard model $\\operatorname{fl}(a \\circ b) = (a \\circ b)(1+\\delta)$ with $|\\delta| \\leq u$.\nThe computation proceeds as:\n1. $y_{fl} = (x/2)(1+\\delta_1)$\n2. $s_{fl} = \\sin(y_{fl})(1+\\delta_2)$\n3. $d_{fl} = (s_{fl}/y_{fl})(1+\\delta_3)$\n4. $q_{fl} = d_{fl}^2(1+\\delta_4)$\n5. $f_{fl} = (q_{fl}/2)(1+\\delta_5)$\n\nLet $\\hat{f}$ denote the computed value $f_{fl}$. The total relative error is $\\frac{\\hat{f} - f(x)}{f(x)}$. Let's trace the errors.\nThe relative error of $y=x/2$ is $\\delta_y = \\delta_1$.\nThe relative error of $s = \\sin y$ is $\\delta_s \\approx \\kappa_{\\sin}(y)\\delta_y + \\delta_2 = (y \\cot y)\\delta_1 + \\delta_2$.\nThe relative error of $d=s/y$ is $\\delta_d \\approx \\delta_s - \\delta_y + \\delta_3 = ((y\\cot y)\\delta_1 + \\delta_2) - \\delta_1 + \\delta_3 = (y\\cot y - 1)\\delta_1 + \\delta_2 + \\delta_3$.\nThe term $(y\\cot y - 1)$ is the relative sensitivity of $S(y)$ to perturbations in $y$, which is $-\\kappa_S(y)$ (without the absolute value). So $\\delta_d \\approx -\\kappa_S(y)\\delta_1 + \\delta_2 + \\delta_3$.\nThe relative error of $q=d^2$ is $\\delta_q \\approx 2\\delta_d + \\delta_4 = 2(-\\kappa_S(y)\\delta_1 + \\delta_2 + \\delta_3) + \\delta_4$.\nThe final relative error of $f=q/2$ is $\\delta_f \\approx \\delta_q + \\delta_5 = -2\\kappa_S(y)\\delta_1 + 2\\delta_2 + 2\\delta_3 + \\delta_4 + \\delta_5$.\n\nTaking the absolute value, the bound on the total relative error is:\n$$\n|\\delta_f| \\leq (2|\\kappa_S(y)| + 2 + 2 + 1 + 1)u = (2|y\\cot y - 1| + 6)u\n$$\nFor small $y$, $|y\\cot y - 1| \\approx y^2/3$. For $x = 10^{-8}$, $y = 0.5 \\times 10^{-8}$.\n$|\\kappa_S(y)| \\approx \\frac{(0.5 \\times 10^{-8})^2}{3} = \\frac{0.25 \\times 10^{-16}}{3} \\approx 8.3 \\times 10^{-18}$.\nThis term is negligible compared to $6$. Thus, the forward relative error bound is approximately $6u$.\n$|\\delta_f| \\lesssim 6u = 6 \\times 2^{-53} \\approx 6.66 \\times 10^{-16}$.\n\n4. Verification and Final Answer Calculation\n\nFirst, as requested, we verify the bound for the stable reformulation. The bound is approximately $6u \\approx 6.66 \\times 10^{-16}$. The observed relative error for the stable calculation is expected to be on the order of $u$, which is consistent with this bound. The small value of $\\kappa_S(y)$ confirms that the algorithm is stable and introduces minimal error beyond the inherent rounding errors of the floating-point operations themselves.\n\nNow, we compute the quantity for the final answer: the empirically observed relative error of the naive evaluation of $f(x)$ at $x = 10^{-8}$.\nThe \"true\" value is estimated from the Taylor series:\n$$\nf_{true} = \\frac{1}{2} - \\frac{x^{2}}{24} + \\frac{x^{4}}{720} - \\dots = \\frac{1}{2} - \\frac{(10^{-8})^2}{24} + \\mathcal{O}(10^{-32}) = 0.5 - 4.166... \\times 10^{-18}\n$$\nThe computed value using the naive formula, as determined in Part 1, is:\n$$\nf_{computed} = 0\n$$\nThe observed relative error is defined as $\\frac{|f_{computed} - f_{true}|}{|f_{true}|}$.\n$$\n\\text{Relative Error} = \\frac{|0 - (0.5 - 4.166... \\times 10^{-18})|}{|0.5 - 4.166... \\times 10^{-18}|} = \\frac{0.5 - 4.166... \\times 10^{-18}}{0.5 - 4.166... \\times 10^{-18}} = 1\n$$\nThe relative error is exactly $1$. The question asks for this value rounded to four significant figures.", "answer": "$$\n\\boxed{1.000}\n$$", "id": "3527080"}, {"introduction": "Explicit numerical schemes for solving time-dependent partial differential equations are often constrained by stability limits, and exceeding them can cause solutions to grow without bound. This practice uses the workhorse method of Von Neumann stability analysis on the linear advection equation to derive the famous Courant-Friedrichs-Lewy (CFL) condition. You will bridge theory and practice by analytically determining the stability bound and then confirming it with a direct numerical simulation, observing the dramatic consequences of violating it [@problem_id:3527165].", "problem": "Consider the linear advection equation $u_t + a\\,u_x = 0$ with constant advection speed $a > 0$, posed on a periodic domain $x \\in [0,L]$. The forward-in-time, upwind-in-space explicit scheme is defined on a uniform grid with spacing $\\Delta x$ and time step $\\Delta t$ by updating the nodal values $u_j^n \\approx u(x_j, t^n)$ via $u_j^{n+1} = u_j^n - C\\,(u_j^n - u_{j-1}^n)$ for $a>0$, where the Courant number is $C = a\\,\\Delta t/\\Delta x$. Use Von Neumann (Fourier) stability analysis and a numerical verification to address the following tasks.\n\nStarting from the fundamental base of the Fourier-mode ansatz $u_j^n = \\hat{u}^n\\,e^{i j \\theta}$ for $\\theta \\in [0,2\\pi]$ in a discrete periodic setting, and the explicit update rule defined above, derive the amplification factor $G(C,\\theta)$ and characterize the stability region as the set of real values of $C$ for which the supremum over $\\theta$ of the magnitude of the amplification factor satisfies $\\sup_{\\theta \\in [0,2\\pi]} |G(C,\\theta)| \\le 1$. Determine the maximum stable Courant number $C_{\\max}$ for $a>0$.\n\nThen, implement a numerical experiment to verify the stability behavior by time-stepping the scheme on the periodic interval of length $L$, with $N$ grid points, and explicit periodic boundary conditions $u_0^n \\equiv u_N^n$ for all $n$. Use the following physically and numerically consistent parameters:\n- Advection speed $a = 1$ in $\\mathrm{m/s}$.\n- Domain length $L = 1$ in $\\mathrm{m}$.\n- Number of grid points $N = 256$ (uniform grid).\n- Angle $\\theta$ must be treated in radians.\n- Use an initial condition that contains multiple Fourier modes, including the highest resolvable discrete mode to probe worst-case stability: $u_j^0 = \\sin\\!\\left(\\tfrac{2\\pi x_j}{L}\\right) + 0.1\\,\\sin\\!\\left(\\tfrac{4\\pi x_j}{L}\\right) + 0.1\\,(-1)^j$, where $x_j = j\\,\\Delta x$.\n- For each Courant number $C$, set the time step via $\\Delta t = C\\,\\Delta x/a$.\n- Evolve to a final physical time $T_{\\mathrm{end}} = 0.05$ in $\\mathrm{s}$.\n\nDefine the Von Neumann stability predicate for a given $C$ as the boolean that is true if $\\sup_{\\theta \\in [0,2\\pi]} |G(C,\\theta)| \\le 1$ and false otherwise. Define the numerical stability predicate for a given $C$ as the boolean that is true if the discrete $\\ell^2$ norm of the numerical solution at $t=T_{\\mathrm{end}}$, computed as $\\left(\\Delta x \\sum_{j=0}^{N-1} (u_j^{n_{\\mathrm{end}}})^2\\right)^{1/2}$, does not increase by more than a relative tolerance of $0.01$ compared to its initial value at $t=0$, that is, if $\\|u(\\cdot,T_{\\mathrm{end}})\\|_2 \\le 1.01\\,\\|u(\\cdot,0)\\|_2$.\n\nYour program must:\n- Compute an approximation to the stability region by scanning $C$ on a dense grid in $[0,2]$ and, for each $C$, scanning $\\theta$ on a dense grid in $[0,2\\pi]$ to numerically evaluate $\\sup_{\\theta} |G(C,\\theta)|$. Report the maximum stable Courant number $C_{\\max}$ found, rounded to $3$ decimal places.\n- Evaluate the Von Neumann stability predicate for the test suite values $C \\in \\{0.1,\\,0.8,\\,1.0,\\,1.2\\}$.\n- Run the time integration with the specified parameters and initial condition for each $C$ in the test suite and evaluate the numerical stability predicate defined above.\n\nThe final output must be a single line containing a comma-separated list enclosed in square brackets of the following quantities in order:\n$[C_{\\max}, \\text{VN}(0.1), \\text{VN}(0.8), \\text{VN}(1.0), \\text{VN}(1.2), \\text{NUM}(0.1), \\text{NUM}(0.8), \\text{NUM}(1.0), \\text{NUM}(1.2)]$,\nwhere $\\text{VN}(C)$ is the Von Neumann stability boolean for the Courant number $C$, and $\\text{NUM}(C)$ is the numerical stability boolean for the Courant number $C$. $C_{\\max}$ is dimensionless; booleans must be printed as plain true-or-false values in the programming language's native boolean representation. Angles must be handled in radians. No additional text must be printed besides this line. All quantities are dimensionless except for $a$, $L$, $\\Delta x$, and $T_{\\mathrm{end}}$, which must be treated with the units specified above. The list must be strictly in the order shown, and $C_{\\max}$ must be rounded to $3$ decimal places.", "solution": "The problem is assessed to be valid as it is scientifically grounded, well-posed, and objective. It constitutes a standard exercise in the numerical analysis of partial differential equations, with all necessary parameters and definitions provided for a unique and meaningful solution.\n\nThe analysis proceeds in two parts: first, a theoretical derivation of the stability condition using Von Neumann analysis, and second, a numerical experiment designed to verify this theoretical result.\n\n### Part 1: Von Neumann Stability Analysis\n\nThe problem concerns the forward-in-time, upwind-in-space (FTUS) scheme for the linear advection equation, $u_t + a\\,u_x = 0$, where the advection speed $a > 0$. The domain is periodic. The discrete update rule is given by:\n$$u_j^{n+1} = u_j^n - C\\,(u_j^n - u_{j-1}^n)$$\nwhere $u_j^n$ is the numerical approximation of the solution $u$ at grid point $x_j = j \\Delta x$ and time $t^n = n \\Delta t$. The Courant-Friedrichs-Lewy (CFL) number, or Courant number, is $C = a \\Delta t / \\Delta x$.\n\nVon Neumann analysis investigates the stability of a linear finite difference scheme by examining how it propagates individual Fourier modes. We use the ansatz that the solution can be represented as a superposition of modes of the form:\n$$u_j^n = \\hat{u}^n\\,e^{i j \\theta}$$\nwhere $\\hat{u}^n$ is the amplitude of the mode at time level $n$, $i = \\sqrt{-1}$ is the imaginary unit, and $\\theta = k_x \\Delta x$ is the dimensionless wavenumber, with $k_x$ being the physical wavenumber. For a periodic domain, $\\theta$ ranges from $0$ to $2\\pi$.\n\nSubstituting the ansatz into the numerical scheme:\n$$\\hat{u}^{n+1} e^{i j \\theta} = \\hat{u}^n e^{i j \\theta} - C (\\hat{u}^n e^{i j \\theta} - \\hat{u}^n e^{i (j-1) \\theta})$$\nDividing through by $\\hat{u}^n e^{i j \\theta}$ (assuming $\\hat{u}^n \\neq 0$) yields the amplification factor $G(C,\\theta) = \\hat{u}^{n+1} / \\hat{u}^n$:\n$$G(C,\\theta) = 1 - C (1 - e^{-i\\theta})$$\nUsing Euler's identity, $e^{-i\\theta} = \\cos\\theta - i\\sin\\theta$, we can write $G(C,\\theta)$ in Cartesian form:\n$$G(C,\\theta) = (1 - C + C\\cos\\theta) + i(C\\sin\\theta)$$\nFor the scheme to be stable, the magnitude of the amplification factor must not exceed unity for all possible wavenumbers, i.e., $\\sup_{\\theta \\in [0,2\\pi]} |G(C,\\theta)| \\le 1$. It is more convenient to analyze the squared magnitude, $|G(C,\\theta)|^2 \\le 1$:\n$$|G(C,\\theta)|^2 = (\\operatorname{Re}(G))^2 + (\\operatorname{Im}(G))^2 = (1 - C + C\\cos\\theta)^2 + (C\\sin\\theta)^2$$\nExpanding the terms:\n$$|G(C,\\theta)|^2 = (1-C)^2 + 2C(1-C)\\cos\\theta + C^2\\cos^2\\theta + C^2\\sin^2\\theta$$\n$$|G(C,\\theta)|^2 = (1-C)^2 + 2C(1-C)\\cos\\theta + C^2(\\cos^2\\theta + \\sin^2\\theta)$$\n$$|G(C,\\theta)|^2 = 1 - 2C + C^2 + 2C\\cos\\theta - 2C^2\\cos\\theta + C^2$$\n$$|G(C,\\theta)|^2 = 1 - 2C(1 - \\cos\\theta) + 2C^2(1 - \\cos\\theta)$$\n$$|G(C,\\theta)|^2 = 1 - 2C(1-C)(1-\\cos\\theta)$$\nThe stability requirement $|G(C, \\theta)|^2 \\le 1$ thus implies:\n$$1 - 2C(1-C)(1-\\cos\\theta) \\le 1$$\n$$-2C(1-C)(1-\\cos\\theta) \\le 0$$\nWe analyze this inequality. The Courant number $C = a \\Delta t / \\Delta x$ is non-negative since $a>0$, $\\Delta t>0$, and $\\Delta x>0$. The term $(1-\\cos\\theta)$ is also non-negative for all real $\\theta$, ranging from $0$ (for $\\theta=0, 2\\pi$) to $2$ (for $\\theta=\\pi$). Therefore, the inequality simplifies to:\n$$C(1-C) \\ge 0$$\nSince $C \\ge 0$, stability requires $1-C \\ge 0$, which means $C \\le 1$.\nThe complete stability region for the FTUS scheme with $a>0$ is $0 \\le C \\le 1$. The maximum stable Courant number is therefore $C_{\\max} = 1$.\n\n### Part 2: Numerical Verification Design\n\nThe program will consist of two components corresponding to the analytical and numerical parts of the problem.\n\n#### Analytical Verification\nFirst, we will numerically verify the derived stability bound $C_{\\max}=1$. We define a function for the squared magnitude of the amplification factor, $|G(C,\\theta)|^2 = 1 - 2C(1-C)(1-\\cos\\theta)$. We then create a dense grid of $C$ values in the interval $[0, 2]$ and a dense grid of $\\theta$ values in $[0, 2\\pi]$. For each $C$, we numerically compute $\\sup_{\\theta} |G(C,\\theta)|$ by finding the maximum value of $|G(C,\\theta)|$ over the $\\theta$ grid. The largest value of $C$ for which this supremum is less than or equal to $1$ is our numerical estimate of $C_{\\max}$, which will be rounded to $3$ decimal places. This same procedure is used to evaluate the Von Neumann stability predicate, $\\text{VN}(C)$, for the test values $C \\in \\{0.1, 0.8, 1.0, 1.2\\}$.\n\n#### Numerical Experiment\nSecond, we will perform a time integration of the advection equation using the FTUS scheme to evaluate the numerical stability predicate, $\\text{NUM}(C)$.\nThe physical and numerical parameters are set as specified: $a=1$, $L=1$, $N=256$. This defines the grid spacing $\\Delta x = L/N$. The grid points are $x_j = j \\Delta x$ for $j=0, \\dots, N-1$.\nThe initial condition is $u_j^0 = \\sin\\!\\left(\\tfrac{2\\pi x_j}{L}\\right) + 0.1\\,\\sin\\!\\left(\\tfrac{4\\pi x_j}{L}\\right) + 0.1\\,(-1)^j$. The term $(-1)^j = e^{i\\pi j}$ corresponds to the highest resolvable frequency on the grid ($\\theta=\\pi$), which maximally tests the stability limit.\nFor each test Courant number $C$, the time step is $\\Delta t = C\\,\\Delta x/a$. The simulation is evolved until the final time $T_{\\mathrm{end}} = 0.05$. The number of time steps required is $n_{\\text{steps}} = \\lceil T_{\\mathrm{end}}/\\Delta t \\rceil$.\nThe update rule $u_j^{n+1} = u_j^n - C(u_j^n - u_{j-1}^n)$ with periodic boundary conditions ($u_{-1}^n \\equiv u_{N-1}^n$) is implemented efficiently for the entire grid using vector operations.\nThe discrete $\\ell^2$ norm $\\|u^n\\|_2 = \\left(\\Delta x \\sum_{j=0}^{N-1} (u_j^{n})^2\\right)^{1/2}$ is computed for the initial state $u^0$ and the final state $u^{n_{\\mathrm{end}}}$. The numerical stability predicate $\\text{NUM}(C)$ is true if $\\|u^{n_{\\mathrm{end}}}\\|_2 \\le 1.01\\,\\|u^0\\|_2$, and false otherwise.\n\nFinally, the results are collected and printed in the specified format: $[C_{\\max}, \\text{VN}(0.1), \\text{VN}(0.8), \\text{VN}(1.0), \\text{VN}(1.2), \\text{NUM}(0.1), \\text{NUM}(0.8), \\text{NUM}(1.0), \\text{NUM}(1.2)]$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the advection equation stability problem.\n    1. Derives the amplification factor G and finds C_max.\n    2. Evaluates Von Neumann and numerical stability for given C values.\n    \"\"\"\n    # Define problem parameters\n    A_SPEED = 1.0\n    L_DOMAIN = 1.0\n    N_POINTS = 256\n    T_END = 0.05\n    C_TEST_VALUES = [0.1, 0.8, 1.0, 1.2]\n\n    # --- Part 1: Analytical Stability Analysis ---\n\n    def get_max_amplification_sq(C, theta_grid):\n        \"\"\"\n        Calculates the squared magnitude of the amplification factor.\n        |G|^2 = 1 - 2*C*(1-C)*(1-cos(theta))\n        \"\"\"\n        # This is numerically stable and direct.\n        g_sq = 1.0 - 2.0 * C * (1.0 - C) * (1.0 - np.cos(theta_grid))\n        return np.max(g_sq)\n\n    # 1a: Find C_max by scanning a dense grid of C values\n    c_grid = np.linspace(0, 2, 4001)\n    theta_grid = np.linspace(0, 2 * np.pi, 721)\n    c_max_val = 0.0\n    # Floating point tolerance for comparing with 1.\n    # The scheme is stable if max|G|^2 = 1.\n    tolerance = 1e-9\n    for c in c_grid:\n        if get_max_amplification_sq(c, theta_grid) = 1.0 + tolerance:\n            c_max_val = c\n\n    # Format C_max to 3 decimal places\n    c_max_rounded = f\"{c_max_val:.3f}\"\n\n    # 1b: Evaluate the Von Neumann stability predicate for test cases\n    vn_stability = []\n    for c in C_TEST_VALUES:\n        is_stable = get_max_amplification_sq(c, theta_grid) = 1.0 + tolerance\n        vn_stability.append(is_stable)\n\n    # --- Part 2: Numerical Experiment ---\n\n    dx = L_DOMAIN / N_POINTS\n    # Grid points x_j = j*dx for j=0..N-1\n    x = np.arange(N_POINTS) * dx\n\n    # Initial condition u(x, 0)\n    # (-1)^j term excites the highest frequency mode (theta=pi)\n    j_indices = np.arange(N_POINTS)\n    u0 = (np.sin(2 * np.pi * x / L_DOMAIN) +\n          0.1 * np.sin(4 * np.pi * x / L_DOMAIN) +\n          0.1 * (-1.0)**j_indices)\n\n    # Initial discrete L2 norm\n    norm_u0 = np.sqrt(dx * np.sum(u0**2))\n    \n    num_stability = []\n    for c_val in C_TEST_VALUES:\n        u = u0.copy()\n        \n        # Determine time step and number of steps\n        dt = c_val * dx / A_SPEED\n        \n        if T_END  0 and dt  0:\n            num_steps = int(np.ceil(T_END / dt))\n        else:\n            num_steps = 0 # No evolution if T_end or dt is zero\n\n        # Time-stepping loop\n        for _ in range(num_steps):\n            # FTUS update rule: u_j^{n+1} = u_j^n - C * (u_j^n - u_{j-1}^n)\n            # np.roll(u, 1) provides u_{j-1} with periodic boundaries\n            u = u - c_val * (u - np.roll(u, 1))\n\n        # Final discrete L2 norm\n        norm_u_final = np.sqrt(dx * np.sum(u**2))\n        \n        # Check numerical stability predicate\n        is_numerically_stable = (norm_u_final = 1.01 * norm_u0)\n        num_stability.append(is_numerically_stable)\n\n    # --- Part 3: Assemble and Print Final Output ---\n    \n    results = [c_max_rounded] + vn_stability + num_stability\n    \n    # Final print statement must be in the exact required format.\n    # The provided template implies using map(str, ...), which converts\n    # Python's True/False to \"True\"/\"False\".\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3527165"}, {"introduction": "A stable numerical scheme is not necessarily an accurate one; discretization always introduces errors that can alter the qualitative behavior of a solution. This hands-on simulation of a linear Alfvén wave—a fundamental mode in astrophysical plasmas—will allow you to directly measure two such errors: numerical dissipation (spurious damping) and numerical dispersion (incorrect phase speed) [@problem_id:3527099]. By examining how these errors change with grid resolution, you will develop crucial intuition for assessing the fidelity of magnetohydrodynamic simulations.", "problem": "You are to implement a self-contained program that numerically simulates a one-dimensional linear Alfvén wave using a first-order finite volume method with a Lax–Friedrichs (Rusanov) numerical flux at a Courant–Friedrichs–Lewy (CFL) number of $0.8$. The purpose is to quantify numerical dissipation (amplitude decay) and numerical dispersion (phase lag) as functions of spatial resolution.\n\nThe physical model is the linearized Alfvén subsystem of ideal magnetohydrodynamics (MHD), in dimensionless units with vacuum permeability set to unity. Let $x \\in [0,L)$ with periodic boundary conditions. With constant background density $\\rho_0$ and constant background magnetic field $B_0$ aligned with the $x$-axis, the decoupled linear Alfvén subsystem for transverse perturbations $(v_y,B_y)$ can be written in conservative form\n$$\n\\partial_t \\mathbf{U} + \\partial_x \\mathbf{F}(\\mathbf{U}) = 0,\\quad \\mathbf{U} =\n\\begin{bmatrix}\nv_y \\\\\nB_y\n\\end{bmatrix},\\quad\n\\mathbf{F}(\\mathbf{U}) =\n\\begin{bmatrix}\n- (B_0/\\rho_0)\\, B_y \\\\\n- B_0\\, v_y\n\\end{bmatrix}.\n$$\nThe characteristic speeds are $\\lambda = \\pm v_A$ with the Alfvén speed $v_A = B_0/\\sqrt{\\rho_0}$.\n\nInitialize a right-traveling monochromatic mode at wavenumber $k = 2\\pi/L$ by choosing\n$$\nv_y(x,0) = A \\sin(k x),\\quad B_y(x,0) = -\\sqrt{\\rho_0}\\, v_y(x,0),\n$$\nwhich corresponds to the right-going Alfvén eigenmode. The exact solution preserves amplitude and propagates without distortion:\n$$\nv_y(x,t) = A \\sin(k (x - v_A t)),\\quad B_y(x,t) = -\\sqrt{\\rho_0}\\, v_y(x,t).\n$$\n\nNumerical method and parameters:\n- Use a uniform grid of $N$ cells with cell centers $x_i = (i+1/2)\\,\\Delta x$, $i=0,\\dots,N-1$, $\\Delta x = L/N$.\n- Use a first-order finite volume update\n$$\n\\mathbf{U}_i^{n+1} = \\mathbf{U}_i^n - \\frac{\\Delta t}{\\Delta x}\\left(\\hat{\\mathbf{F}}_{i+1/2}^n - \\hat{\\mathbf{F}}_{i-1/2}^n\\right),\n$$\nwith periodic boundary conditions, where the Lax–Friedrichs (Rusanov) interface flux is\n$$\n\\hat{\\mathbf{F}}_{i+1/2} = \\frac{1}{2}\\left(\\mathbf{F}(\\mathbf{U}_i) + \\mathbf{F}(\\mathbf{U}_{i+1})\\right) - \\frac{\\alpha}{2}\\left(\\mathbf{U}_{i+1} - \\mathbf{U}_i\\right),\n$$\nand $\\alpha = \\max|\\lambda| = v_A$.\n- Enforce a Courant–Friedrichs–Lewy (CFL) number of $0.8$ via $\\Delta t = \\mathrm{CFL}\\,\\Delta x/\\alpha$ for all full time steps. If the final time $T$ is not reached exactly by an integer number of full steps, take one final step with $\\Delta t_\\mathrm{final} \\le \\mathrm{CFL}\\,\\Delta x/\\alpha$ to reach exactly $T$.\n- Use domain length $L = 1$, background parameters $\\rho_0 = 1$, $B_0 = 1$ (so $v_A = 1$), amplitude $A = 10^{-3}$, and final time $T = 0.7$ (dimensionless units).\n\nMeasurement and outputs:\n- Let $k = 2\\pi/L$. After advancing to time $T$, compute the numerical amplitude and phase of $v_y(x,T)$ by projecting onto the basis $\\{\\sin(k x), \\cos(k x)\\}$ using the discrete inner product over cell centers. Define\n$$\na_s = \\frac{\\sum_{i=0}^{N-1} v_y(x_i,T)\\,\\sin(k x_i)}{\\sum_{i=0}^{N-1} \\sin^2(k x_i)},\\quad\na_c = \\frac{\\sum_{i=0}^{N-1} v_y(x_i,T)\\,\\cos(k x_i)}{\\sum_{i=0}^{N-1} \\cos^2(k x_i)}.\n$$\nThen the numerical amplitude and phase are\n$$\nA_\\mathrm{num} = \\sqrt{a_s^2 + a_c^2},\\quad \\phi_\\mathrm{num} = \\mathrm{atan2}(a_c, a_s).\n$$\nThe exact phase is $\\phi_\\mathrm{exact} = -k v_A T$. Define the amplitude ratio and phase error as\n$$\nR = \\frac{A_\\mathrm{num}}{A},\\quad \\Delta\\phi = \\mathrm{wrap}_{(-\\pi,\\pi]}\\left(\\phi_\\mathrm{num} - \\phi_\\mathrm{exact}\\right),\n$$\nwhere $\\mathrm{wrap}_{(-\\pi,\\pi]}(\\cdot)$ wraps an angle into $(-\\pi,\\pi]$. Report $\\Delta\\phi$ in radians.\n\nTest suite:\n- Simulate and report $(R,\\Delta\\phi)$ for the following grid resolutions $N \\in \\{32, 64, 128, 256\\}$.\n- Use the fixed parameters $L = 1$, $\\rho_0 = 1$, $B_0 = 1$, $A = 10^{-3}$, $T = 0.7$, $\\mathrm{CFL} = 0.8$.\n\nFinal output format:\n- Your program should produce a single line of output containing a list of four two-element lists, each inner list being $[R,\\Delta\\phi]$ for one $N$, in the order $N=32$, $N=64$, $N=128$, $N=256$.\n- The single-line output must be formatted as a comma-separated list with no spaces, enclosed in square brackets. For example: \"[[R32,phi32],[R64,phi64],[R128,phi128],[R256,phi256]]\".\n- $R$ and $\\Delta\\phi$ must be floating-point numbers. Report $\\Delta\\phi$ in radians (dimensionless) and $R$ as a dimensionless ratio.\n\nAll quantities in this problem are dimensionless; no physical units are required. Angles must be in radians.", "solution": "We consider the one-dimensional linearized Alfvén subsystem from ideal magnetohydrodynamics (MHD) about a uniform state with density $\\rho_0$ and magnetic field $B_0$ aligned with the $x$-direction. In transverse variables $\\mathbf{U} = [v_y, B_y]^T$, the system\n$$\n\\partial_t \\mathbf{U} + \\partial_x \\mathbf{F}(\\mathbf{U}) = 0,\\quad\n\\mathbf{F}(\\mathbf{U}) = \\begin{bmatrix} 0  -B_0/\\rho_0 \\\\ -B_0  0 \\end{bmatrix} \\begin{bmatrix} v_y \\\\ B_y \\end{bmatrix}\n$$\nhas constant coefficient Jacobian $\\mathbf{A} = \\partial \\mathbf{F}/\\partial \\mathbf{U} = \\begin{bmatrix} 0  -B_0/\\rho_0 \\\\ -B_0  0 \\end{bmatrix}$ with eigenvalues $\\lambda = \\pm v_A$, where the Alfvén speed is $v_A = B_0/\\sqrt{\\rho_0}$. The right-going eigenvector satisfies $B_y = -\\sqrt{\\rho_0}\\, v_y$ and the left-going satisfies $B_y = +\\sqrt{\\rho_0}\\, v_y$.\n\nWe initialize a right-propagating single Fourier mode at wavenumber $k = 2\\pi/L$ as\n$$\nv_y(x,0) = A \\sin(k x),\\quad B_y(x,0) = -\\sqrt{\\rho_0}\\, v_y(x,0),\n$$\nwhich is an eigenmode of the system. The exact solution preserves the amplitude and translates at speed $v_A$:\n$$\nv_y(x,t) = A \\sin(k (x - v_A t)),\\quad B_y(x,t) = -\\sqrt{\\rho_0}\\, v_y(x,t).\n$$\n\nWe discretize in space on a uniform mesh of $N$ cells with cell centers $x_i = (i+1/2)\\,\\Delta x$, $i=0,\\dots,N-1$, $\\Delta x = L/N$. A first-order finite volume method updates the cell averages via\n$$\n\\mathbf{U}_i^{n+1} = \\mathbf{U}_i^n - \\frac{\\Delta t}{\\Delta x}\\left(\\hat{\\mathbf{F}}_{i+1/2}^n - \\hat{\\mathbf{F}}_{i-1/2}^n\\right),\n$$\nwhere periodic boundary conditions are enforced and $\\hat{\\mathbf{F}}_{i+1/2}$ is the Lax–Friedrichs (Rusanov) numerical flux\n$$\n\\hat{\\mathbf{F}}_{i+1/2} = \\frac{1}{2}\\left(\\mathbf{F}(\\mathbf{U}_i) + \\mathbf{F}(\\mathbf{U}_{i+1})\\right) - \\frac{\\alpha}{2}\\left(\\mathbf{U}_{i+1} - \\mathbf{U}_i\\right),\\quad \\alpha = \\max|\\lambda| = v_A.\n$$\nTime stepping uses a Courant–Friedrichs–Lewy (CFL) number $\\mathrm{CFL} = 0.8$, namely $\\Delta t = \\mathrm{CFL}\\,\\Delta x/\\alpha$ for all full steps, plus a final shorter step to hit $T$ exactly if needed.\n\nBecause the initial condition is a single right-going eigenmode, the system effectively reduces to advecting a scalar wave at speed $a = v_A$ when projected onto the right eigenvector. For a scalar linear advection equation $u_t + a u_x = 0$, the Lax–Friedrichs (Rusanov) update with constant $\\alpha = |a|$ can be written as\n$$\nu_j^{n+1} = u_j^n - \\frac{a \\Delta t}{2\\Delta x}(u_{j+1}^n - u_{j-1}^n) + \\frac{\\alpha \\Delta t}{2\\Delta x}(u_{j+1}^n - 2 u_j^n + u_{j-1}^n).\n$$\nA modified equation analysis obtained by Taylor expanding $u_{j\\pm 1}^n$ and $u_j^{n+1}$ shows that, to leading order in $\\Delta x$,\n$$\nu_t + a u_x = D\\, u_{xx} + \\mathcal{O}(\\Delta x^2),\\quad D = \\frac{1}{2}\\left(\\alpha \\Delta x - a^2 \\Delta t\\right).\n$$\nWith $\\alpha = |a|$ and $\\Delta t = \\mathrm{CFL}\\,\\Delta x/\\alpha$, this simplifies to\n$$\nD = \\frac{|a|\\,\\Delta x}{2}\\left(1 - \\mathrm{CFL}\\right).\n$$\nThus, for a single Fourier mode $u \\propto \\sin(k x)$, the amplitude decays approximately as $\\exp(- D k^2 t)$, revealing linear-in-$\\Delta x$ dissipative error controlled by $1 - \\mathrm{CFL}$. Additionally, higher-order terms in the modified equation include a dispersive term of the form $(a/6)\\,\\Delta x^2\\, u_{xxx}$ on the left-hand side, implying an effective numerical phase speed\n$$\nc_\\mathrm{num} \\approx a\\left(1 - \\frac{(k \\Delta x)^2}{6}\\right)\n$$\nfor small $k \\Delta x$. Therefore, after time $T$, the phase error behaves as\n$$\n\\Delta \\phi \\equiv (\\phi_\\mathrm{num} - \\phi_\\mathrm{exact}) \\approx \\left(c_\\mathrm{num} - a\\right) k T \\approx -\\frac{a}{6}\\, k^3\\, \\Delta x^2\\, T,\n$$\nwhich is second order in $\\Delta x$ for fixed $k$ and $T$.\n\nIn our specific setup, we choose $L = 1$, $\\rho_0 = 1$, $B_0 = 1$, whence $v_A = 1$, and $k = 2\\pi/L = 2\\pi$. We set $A = 10^{-3}$ and $T = 0.7$. The algorithm proceeds as follows for each $N \\in \\{32, 64, 128, 256\\}$:\n1. Compute $\\Delta x = L/N$ and $\\Delta t = \\mathrm{CFL}\\,\\Delta x/\\alpha$ with $\\mathrm{CFL} = 0.8$, $\\alpha = v_A = 1$.\n2. Initialize $\\mathbf{U}_i^0$ at cell centers $x_i = (i+1/2)\\,\\Delta x$ using $v_y(x,0) = A \\sin(k x)$ and $B_y(x,0) = -\\sqrt{\\rho_0}\\, v_y(x,0)$.\n3. Advance in time by repeated application of the finite volume update using the Lax–Friedrichs flux, with a final shorter step so that the cumulative time equals exactly $T$.\n4. Measure the numerical amplitude and phase of $v_y(x,T)$ using the projections\n$$\na_s = \\frac{\\sum_i v_y(x_i,T)\\,\\sin(k x_i)}{\\sum_i \\sin^2(k x_i)},\\quad\na_c = \\frac{\\sum_i v_y(x_i,T)\\,\\cos(k x_i)}{\\sum_i \\cos^2(k x_i)},\n$$\nthen compute\n$$\nA_\\mathrm{num} = \\sqrt{a_s^2 + a_c^2},\\quad \\phi_\\mathrm{num} = \\mathrm{atan2}(a_s,a_s).\n$$\n5. Compute exact phase $\\phi_\\mathrm{exact} = -k v_A T$ and define amplitude ratio and phase error\n$$\nR = \\frac{A_\\mathrm{num}}{A},\\quad \\Delta\\phi = \\mathrm{wrap}_{(-\\pi,\\pi]}\\left(\\phi_\\mathrm{num} - \\phi_\\mathrm{exact}\\right).\n$$\n\nInterpretation:\n- Dissipation: The Lax–Friedrichs scheme introduces a leading-order diffusion coefficient $D = \\frac{1}{2} v_A \\Delta x (1 - \\mathrm{CFL})$. For our $\\mathrm{CFL} = 0.8$ and $v_A = 1$, $D = 0.1\\,\\Delta x$. Thus, the amplitude ratio should approximately follow $R \\approx \\exp(- D k^2 T) = \\exp(-0.1\\, k^2\\, \\Delta x\\, T)$, which approaches $1$ linearly as $\\Delta x \\to 0$.\n- Dispersion: The phase speed error is of order $\\mathcal{O}(\\Delta x^2)$, implying $\\Delta \\phi \\sim -\\frac{1}{6} k^3 \\Delta x^2 T$ for the right-going mode with $a = v_A = 1$. Hence, doubling the resolution (halving $\\Delta x$) should reduce the magnitude of $\\Delta \\phi$ by approximately a factor of $4$.\n\nThe program implements this solver and outputs a single line formatted as a list of four pairs $[R,\\Delta\\phi]$ in radians for the specified $N$ values, with no spaces, thereby enabling automated verification. The reported quantities are dimensionless and the angle is in radians.", "answer": "```python\nimport numpy as np\n\ndef rusanov_flux(U, F, alpha):\n    \"\"\"\n    Compute Rusanov (Lax–Friedrichs) numerical flux at all interfaces for a 1D periodic grid.\n    U: array shape (m, N), conservative variables in each cell.\n    F: array shape (m, N), physical flux in each cell.\n    alpha: scalar, maximum wavespeed (constant).\n    Returns: array shape (m, N), numerical flux at interfaces i+1/2 stored at index i.\n    \"\"\"\n    U_right = np.roll(U, -1, axis=1)\n    F_right = np.roll(F, -1, axis=1)\n    return 0.5 * (F + F_right) - 0.5 * alpha * (U_right - U)\n\ndef simulate_linear_alfven(N, L=1.0, rho0=1.0, B0=1.0, A=1e-3, T=0.7, CFL=0.8):\n    \"\"\"\n    Simulate the linear Alfvén subsystem with Rusanov flux on N cells and measure amplitude ratio and phase error.\n    Returns: (R, dphi) where R = A_num/A and dphi is the wrapped phase error in radians.\n    \"\"\"\n    # Constants and grid\n    vA = B0 / np.sqrt(rho0)\n    alpha = vA\n    dx = L / N\n    k = 2.0 * np.pi / L\n\n    # Cell centers\n    i = np.arange(N)\n    x = (i + 0.5) * dx\n\n    # Initial condition: right-going eigenmode (By = -sqrt(rho0) * vy)\n    vy0 = A * np.sin(k * x)\n    By0 = -np.sqrt(rho0) * vy0\n\n    # State vector U = [vy, By]\n    U = np.vstack([vy0, By0])\n\n    # Time step control\n    dt_full = CFL * dx / alpha\n    t = 0.0\n\n    # Advance in time\n    while t + dt_full  T - 1e-15:\n        # Physical flux F(U) = [-(B0/rho0) * By, -B0 * vy]\n        F = np.vstack([-(B0 / rho0) * U[1], -B0 * U[0]])\n        # Numerical flux at interfaces\n        F_half = rusanov_flux(U, F, alpha)\n        # Update U\n        U = U - (dt_full / dx) * (F_half - np.roll(F_half, 1, axis=1))\n        t += dt_full\n\n    # Final partial step to hit exactly T\n    dt_last = T - t\n    if dt_last  1e-15:\n        F = np.vstack([-(B0 / rho0) * U[1], -B0 * U[0]])\n        F_half = rusanov_flux(U, F, alpha)\n        U = U - (dt_last / dx) * (F_half - np.roll(F_half, 1, axis=1))\n        t += dt_last\n\n    # Sanity: ensure we reached T\n    # Measure amplitude and phase using projection onto sin(kx), cos(kx)\n    vy = U[0]\n    s = np.sin(k * x)\n    c = np.cos(k * x)\n    s_norm = np.dot(s, s)\n    c_norm = np.dot(c, c)\n\n    # Avoid division by zero (should not happen for N = 2)\n    a_s = float(np.dot(vy, s) / s_norm) if s_norm  0 else 0.0\n    a_c = float(np.dot(vy, c) / c_norm) if c_norm  0 else 0.0\n\n    A_num = np.hypot(a_s, a_c)\n    phi_num = np.arctan2(a_c, a_s)\n\n    # Exact phase at time T\n    phi_exact = -k * vA * T\n\n    # Wrap phase error into (-pi, pi]\n    dphi = phi_num - phi_exact\n    dphi = (dphi + np.pi) % (2.0 * np.pi) - np.pi\n\n    R = A_num / A\n    return R, dphi\n\ndef solve():\n    # Define the test cases: resolutions N\n    test_cases = [32, 64, 128, 256]\n\n    results = []\n    for N in test_cases:\n        R, dphi = simulate_linear_alfven(N=N, L=1.0, rho0=1.0, B0=1.0, A=1e-3, T=0.7, CFL=0.8)\n        results.append((R, dphi))\n\n    # Format output: list of [R, dphi] with no spaces\n    def fmt_float(x):\n        # 12 significant digits is a reasonable compromise\n        return f\"{x:.12g}\"\n\n    inner = \",\".join(f\"[{fmt_float(r)},{fmt_float(p)}]\" for r, p in results)\n    print(f\"[{inner}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3527099"}]}