{"hands_on_practices": [{"introduction": "Before tackling complex multi-dimensional simulations, it is essential to build and verify the core physical components in their simplest form. This practice focuses on the fundamental interaction between a dust particle and gas: the drag force. You will implement and validate the analytical solutions for both linear and quadratic drag regimes, providing a crucial first-principles check on your understanding and coding [@problem_id:3519080]. Furthermore, by dissecting numerical errors into those from time integration and those from interpolation, you will develop a deeper intuition for the sources of inaccuracy in numerical models.", "problem": "You are asked to validate the Dustybox model for the time evolution of the relative velocity between a dust parcel and gas in one dimension under drag, and to quantify two distinct sources of numerical error: time-integration error and interpolation error. Consider two drag laws: linear (Stokes-like) drag and quadratic (high Reynolds number) drag. Your starting point must be Newton's second law applied to the dust-gas system and the definition of relative velocity, and you must work in a regime where the gas velocity is spatially uniform and constant in time. The one-dimensional relative velocity is denoted by $w(t)$ with initial condition $w(0)=w_0$ in units of $\\mathrm{m\\,s^{-1}}$, and time $t$ is in units of $\\mathrm{s}$. For linear drag, the drag coefficient is $\\lambda$ with units $\\mathrm{s^{-1}}$. For quadratic drag, the coefficient is $\\alpha$ with units $\\mathrm{m^{-1}}$.\n\n1) Use Newton's second law to model the relative velocity dynamics for each drag law:\n- Linear drag: write the ordinary differential equation (ODE) for $w(t)$ in terms of $\\lambda$.\n- Quadratic drag: write the ODE for $w(t)$ in terms of $\\alpha$.\n\n2) Derive the analytic solution $w(t)$ from first principles for each case. You must derive and then use the correct functional dependence:\n- For linear drag, the exact solution must be expressed in terms of $w_0$, $\\lambda$, and $t$.\n- For quadratic drag, the exact solution must be expressed in terms of $w_0$, $\\alpha$, and $t$, and must handle both $w_0>0$ and $w_00$ consistently.\n\n3) Implement a forward Euler time integrator for $w(t)$ for both drag laws with a constant time step $\\Delta t$ (in $\\mathrm{s}$), advancing from $t=0$ to a specified final time $t_{\\mathrm{end}}$ (in $\\mathrm{s}$). If $t_{\\mathrm{end}}$ is not an integer multiple of $\\Delta t$, the final step size must be truncated to exactly reach $t_{\\mathrm{end}}$.\n\n4) Define and compute two error metrics, both dimensionless:\n- Time-integration error $\\varepsilon_{\\mathrm{time}}$: the maximum absolute relative error between the numerical solution and the exact analytic solution evaluated at the discrete integrator time samples $\\{t_n\\}$ used by the forward Euler method. Formally,\n$$\n\\varepsilon_{\\mathrm{time}}=\\max_n \\frac{\\left|w_{\\mathrm{num}}(t_n)-w_{\\mathrm{exact}}(t_n)\\right|}{\\max\\left(\\left|w_{\\mathrm{exact}}(t_n)\\right|,\\epsilon\\right)},\n$$\nwhere $\\epsilon$ is a small floor to avoid division by zero; set $\\epsilon=10^{-12}\\ \\mathrm{m\\,s^{-1}}$.\n- Interpolation error $\\varepsilon_{\\mathrm{interp}}$: the maximum absolute relative error at midpoints $t_{n+\\frac{1}{2}}=\\frac{1}{2}\\left(t_n+t_{n+1}\\right)$ between linear interpolation of the exact endpoint values and the exact analytic value at the midpoint. Formally,\n$$\nw_{\\mathrm{lin}}(t_{n+\\frac{1}{2}})=\\frac{1}{2}\\left[w_{\\mathrm{exact}}(t_n)+w_{\\mathrm{exact}}(t_{n+1})\\right],\\quad\n\\varepsilon_{\\mathrm{interp}}=\\max_n \\frac{\\left|w_{\\mathrm{lin}}(t_{n+\\frac{1}{2}})-w_{\\mathrm{exact}}(t_{n+\\frac{1}{2}})\\right|}{\\max\\left(\\left|w_{\\mathrm{exact}}(t_{n+\\frac{1}{2}})\\right|,\\epsilon\\right)}.\n$$\n\n5) Test Suite. Your program must evaluate the following five parameter sets and report, for each, the pair $[\\varepsilon_{\\mathrm{time}},\\varepsilon_{\\mathrm{interp}}]$:\n- Case A (linear drag, well-resolved): $w_0=10\\ \\mathrm{m\\,s^{-1}}$, $\\lambda=2\\ \\mathrm{s^{-1}}$, $t_{\\mathrm{end}}=1\\ \\mathrm{s}$, $\\Delta t=0.1\\ \\mathrm{s}$.\n- Case B (linear drag, coarse step near stability boundary): $w_0=10\\ \\mathrm{m\\,s^{-1}}$, $\\lambda=2\\ \\mathrm{s^{-1}}$, $t_{\\mathrm{end}}=1\\ \\mathrm{s}$, $\\Delta t=0.95\\ \\mathrm{s}$.\n- Case C (quadratic drag, well-resolved): $w_0=10\\ \\mathrm{m\\,s^{-1}}$, $\\alpha=0.1\\ \\mathrm{m^{-1}}$, $t_{\\mathrm{end}}=1\\ \\mathrm{s}$, $\\Delta t=0.05\\ \\mathrm{s}$.\n- Case D (quadratic drag, coarse step): $w_0=10\\ \\mathrm{m\\,s^{-1}}$, $\\alpha=0.1\\ \\mathrm{m^{-1}}$, $t_{\\mathrm{end}}=1\\ \\mathrm{s}$, $\\Delta t=0.5\\ \\mathrm{s}$.\n- Case E (quadratic drag, negative initial velocity): $w_0=-5\\ \\mathrm{m\\,s^{-1}}$, $\\alpha=0.2\\ \\mathrm{m^{-1}}$, $t_{\\mathrm{end}}=2\\ \\mathrm{s}$, $\\Delta t=0.1\\ \\mathrm{s}$.\n\n6) Final Output Format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each entry is a two-element list corresponding to the two errors for a case, ordered as $[\\varepsilon_{\\mathrm{time}},\\varepsilon_{\\mathrm{interp}}]$, in the same order as the cases above. For example, the output should look like\n\"[[x_A_time,x_A_interp],[x_B_time,x_B_interp],[x_C_time,x_C_interp],[x_D_time,x_D_interp],[x_E_time,x_E_interp]]\"\nwith each $x$ a floating-point value (dimensionless). No additional text should be printed.", "solution": "The problem requires the validation of a one-dimensional dust-gas relative velocity model under two different drag laws, and the quantification of two distinct numerical errors: time-integration error from a forward Euler scheme and interpolation error from linear approximation. The analysis begins from first principles.\n\n### 1. Governing Equations from First Principles\n\nLet the one-dimensional velocities of the dust parcel and the gas be $v_d(t)$ and $v_g(t)$, respectively. The relative velocity is defined as $w(t) = v_d(t) - v_g(t)$. The problem states that the gas velocity is constant, so $\\frac{dv_g}{dt} = 0$. The rate of change of the relative velocity is then solely determined by the acceleration of the dust:\n$$\n\\frac{dw}{dt} = \\frac{d}{dt}(v_d - v_g) = \\frac{dv_d}{dt} - \\frac{dv_g}{dt} = \\frac{dv_d}{dt}\n$$\nNewton's second law for the dust particle of mass $m_d$ states that its acceleration is caused by the drag force $F_{drag}$ exerted by the gas:\n$$\nm_d \\frac{dv_d}{dt} = F_{drag}\n$$\nCombining these, we obtain the governing equation for the relative velocity:\n$$\n\\frac{dw}{dt} = \\frac{1}{m_d} F_{drag}\n$$\nThe drag force always opposes the relative motion, i.e., its direction is opposite to the sign of $w$.\n\n**Linear Drag (Stokes-like):**\nFor low Reynolds numbers, the drag force is linearly proportional to the relative velocity, $F_{drag} = -K w$, where $K$ is a positive constant. Substituting this into the equation of motion gives:\n$$\n\\frac{dw}{dt} = -\\frac{K}{m_d} w\n$$\nWe define the drag coefficient $\\lambda = K/m_d$, which has units of $\\mathrm{s^{-1}}$. The final ordinary differential equation (ODE) for linear drag is:\n$$\n\\frac{dw}{dt} = -\\lambda w\n$$\n\n**Quadratic Drag:**\nFor high Reynolds numbers, the drag force is proportional to the square of the relative velocity. To ensure the force always opposes the motion, it is expressed as $F_{drag} = -C w|w|$, where $C$ is a positive constant. This form is equivalent to $-C \\cdot \\mathrm{sgn}(w) \\cdot w^2$. The equation of motion becomes:\n$$\n\\frac{dw}{dt} = -\\frac{C}{m_d} w|w|\n$$\nWe define the drag coefficient $\\alpha = C/m_d$, which has units of $\\mathrm{m^{-1}}$. The final ODE for quadratic drag is:\n$$\n\\frac{dw}{dt} = -\\alpha w|w|\n$$\n\n### 2. Analytic Solutions\n\nWe solve these ODEs as initial value problems with the condition $w(t=0) = w_0$.\n\n**Linear Drag Solution:**\nThe ODE $\\frac{dw}{dt} = -\\lambda w$ is a separable first-order differential equation.\n$$\n\\frac{1}{w} dw = -\\lambda dt\n$$\nIntegrating both sides from the initial state $(0, w_0)$ to a general state $(t, w(t))$:\n$$\n\\int_{w_0}^{w(t)} \\frac{1}{\\tilde{w}} d\\tilde{w} = \\int_{0}^{t} -\\lambda d\\tilde{t}\n$$\n$$\n[\\ln|\\tilde{w}|]_{w_0}^{w(t)} = -[\\lambda \\tilde{t}]_{0}^{t}\n$$\n$$\n\\ln|w(t)| - \\ln|w_0| = -\\lambda t \\implies \\ln\\left|\\frac{w(t)}{w_0}\\right| = -\\lambda t\n$$\nSince $w(t)$ can only reach zero asymptotically (for $w_0 \\neq 0$), its sign remains constant and equal to the sign of $w_0$. Therefore, we can remove the absolute value signs.\n$$\n\\frac{w(t)}{w_0} = e^{-\\lambda t} \\implies w(t) = w_0 e^{-\\lambda t}\n$$\n\n**Quadratic Drag Solution:**\nThe ODE is $\\frac{dw}{dt} = -\\alpha w|w|$. This is also separable, but we must consider the sign of $w$.\n\nCase 1: $w_0 > 0$. Since the drag force cannot change the sign of the velocity, $w(t) > 0$ for all $t \\geq 0$. Thus, $|w|=w$.\n$$\n\\frac{dw}{dt} = -\\alpha w^2 \\implies \\frac{1}{w^2}dw = -\\alpha dt\n$$\nIntegrating from $(0, w_0)$ to $(t, w(t))$:\n$$\n\\int_{w_0}^{w(t)} \\frac{1}{\\tilde{w}^2} d\\tilde{w} = \\int_{0}^{t} -\\alpha d\\tilde{t}\n$$\n$$\n\\left[-\\frac{1}{\\tilde{w}}\\right]_{w_0}^{w(t)} = -\\alpha t \\implies -\\frac{1}{w(t)} + \\frac{1}{w_0} = -\\alpha t\n$$\n$$\n\\frac{1}{w(t)} = \\frac{1}{w_0} + \\alpha t = \\frac{1 + \\alpha w_0 t}{w_0} \\implies w(t) = \\frac{w_0}{1 + \\alpha w_0 t}\n$$\n\nCase 2: $w_0  0$. In this case, $w(t)  0$ for all $t \\geq 0$, so $|w|=-w$.\n$$\n\\frac{dw}{dt} = -\\alpha w(-w) = \\alpha w^2 \\implies \\frac{1}{w^2}dw = \\alpha dt\n$$\nIntegrating similarly:\n$$\n\\left[-\\frac{1}{\\tilde{w}}\\right]_{w_0}^{w(t)} = \\alpha t \\implies -\\frac{1}{w(t)} + \\frac{1}{w_0} = \\alpha t\n$$\n$$\n\\frac{1}{w(t)} = \\frac{1}{w_0} - \\alpha t = \\frac{1 - \\alpha w_0 t}{w_0} \\implies w(t) = \\frac{w_0}{1 - \\alpha w_0 t}\n$$\n\nThese two cases can be unified into a single expression. For $w_0 > 0$, $|w_0|=w_0$. For $w_0  0$, $|w_0|=-w_0$. The denominator in the second case is $1 - \\alpha w_0 t = 1 + \\alpha (-w_0) t = 1 + \\alpha |w_0| t$. The denominator in the first case is $1 + \\alpha w_0 t = 1 + \\alpha |w_0| t$. Thus, for any $w_0 \\neq 0$, the solution is:\n$$\nw(t) = \\frac{w_0}{1 + \\alpha |w_0| t}\n$$\nThis formula also correctly yields $w(t)=0$ if $w_0=0$.\n\n### 3. Numerical Integration Scheme: Forward Euler\n\nThe forward Euler method is an explicit first-order integrator for an ODE of the form $\\frac{dw}{dt} = f(t, w)$. Given a value $w_n$ at time $t_n$, the value $w_{n+1}$ at time $t_{n+1} = t_n + \\Delta t$ is approximated as:\n$$\nw_{n+1} = w_n + \\Delta t \\cdot f(t_n, w_n)\n$$\n- For linear drag, $f(w) = -\\lambda w$, so the update rule is $w_{n+1} = w_n + \\Delta t(-\\lambda w_n) = w_n(1 - \\lambda \\Delta t)$.\n- For quadratic drag, $f(w) = -\\alpha w|w|$, so the update rule is $w_{n+1} = w_n + \\Delta t(-\\alpha w_n|w_n|) = w_n(1 - \\alpha |w_n| \\Delta t)$.\n\nThe integration proceeds from $t=0$ to $t=t_{\\mathrm{end}}$. If $t_{\\mathrm{end}}$ is not an integer multiple of the primary time step $\\Delta t$, the final step is truncated to ensure the integration terminates exactly at $t_{\\mathrm{end}}$.\n\n### 4. Error Metrics\n\nTwo dimensionless error metrics are defined to quantify different sources of numerical inaccuracy.\n\n- **Time-integration error $\\varepsilon_{\\mathrm{time}}$**: This metric measures the discrepancy between the numerically computed solution $w_{\\mathrm{num}}$ and the exact solution $w_{\\mathrm{exact}}$ at the discrete time points $t_n$ used by the integrator. It is a direct measure of the accuracy of the forward Euler method for the given step size.\n$$\n\\varepsilon_{\\mathrm{time}} = \\max_n \\frac{\\left|w_{\\mathrm{num}}(t_n) - w_{\\mathrm{exact}}(t_n)\\right|}{\\max\\left(\\left|w_{\\mathrm{exact}}(t_n)\\right|, \\epsilon\\right)}\n$$\nwhere the floor value $\\epsilon = 10^{-12}\\ \\mathrm{m\\,s^{-1}}$ prevents division by zero.\n\n- **Interpolation error $\\varepsilon_{\\mathrm{interp}}$**: This metric isolates the error made by assuming a linear evolution of the true solution between two time points. It compares the exact solution at the midpoint of a time interval, $w_{\\mathrm{exact}}(t_{n+1/2})$, with the value obtained by linearly interpolating the exact solutions at the interval's endpoints, $w_{\\mathrm{lin}}(t_{n+1/2})$. This error quantifies the non-linearity of the exact solution over a single time step $\\Delta t$.\n$$\nw_{\\mathrm{lin}}(t_{n+\\frac{1}{2}}) = \\frac{1}{2}\\left[w_{\\mathrm{exact}}(t_n) + w_{\\mathrm{exact}}(t_{n+1})\\right]\n$$\n$$\n\\varepsilon_{\\mathrm{interp}} = \\max_n \\frac{\\left|w_{\\mathrm{lin}}(t_{n+\\frac{1}{2}}) - w_{\\mathrm{exact}}(t_{n+\\frac{1}{2}})\\right|}{\\max\\left(\\left|w_{\\mathrm{exact}}(t_{n+\\frac{1}{2}})\\right|, \\epsilon\\right)}\n$$\n\nThe implementation will compute these values for each of the five specified test cases.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Validates the Dustybox model and quantifies numerical errors for dust-gas dynamics.\n    \"\"\"\n    \n    # Epsilon value for error normalization to avoid division by zero.\n    epsilon = 1e-12\n\n    def get_time_grid(t_end, dt):\n        \"\"\"\n        Generates the grid of time points for the integration.\n        Handles the case where t_end is not a multiple of dt.\n        \"\"\"\n        if dt = 0 or t_end  0:\n            return np.array([0.0])\n        \n        num_steps = int(t_end / dt)\n        times = [i * dt for i in range(num_steps + 1)]\n        \n        # Check if the last point is t_end\n        if not np.isclose(times[-1], t_end):\n            # If t_end was not a multiple of dt, add it\n            if times[-1]  t_end:\n                 times.append(t_end)\n            # If t_end was smaller than dt, the list is [0, dt], fix it to [0, t_end]\n            elif len(times) == 2 and t_end  dt:\n                times = [0.0, t_end]\n\n        return np.array(times, dtype=float)\n\n    def w_exact_linear(t, w0, lam):\n        return w0 * np.exp(-lam * t)\n\n    def w_exact_quadratic(t, w0, alpha):\n        return w0 / (1 + alpha * np.abs(w0) * t)\n\n    def forward_euler(w0, t_grid, f_dw_dt):\n        \"\"\"\n        Performs forward Euler integration.\n        \"\"\"\n        w_numerical = np.zeros_like(t_grid)\n        w_numerical[0] = w0\n        \n        for n in range(len(t_grid) - 1):\n            dt = t_grid[n+1] - t_grid[n]\n            w_numerical[n+1] = w_numerical[n] + dt * f_dw_dt(w_numerical[n])\n            \n        return w_numerical\n\n    def run_case(case_params):\n        \"\"\"\n        Runs a single test case and computes both error metrics.\n        \"\"\"\n        drag_type = case_params['type']\n        w0 = case_params['w0']\n        t_end = case_params['t_end']\n        dt = case_params['dt']\n\n        if drag_type == 'linear':\n            lam = case_params['coeff']\n            w_exact_func = lambda t: w_exact_linear(t, w0, lam)\n            f_dw_dt = lambda w: -lam * w\n        elif drag_type == 'quadratic':\n            alpha = case_params['coeff']\n            w_exact_func = lambda t: w_exact_quadratic(t, w0, alpha)\n            f_dw_dt = lambda w: -alpha * w * np.abs(w)\n        else:\n            raise ValueError(\"Unknown drag type specified.\")\n\n        # Generate time grid and perform numerical integration\n        t_grid = get_time_grid(t_end, dt)\n        w_num = forward_euler(w0, t_grid, f_dw_dt)\n        \n        # Calculate analytic solution at the same time points\n        w_exact_at_grid = w_exact_func(t_grid)\n        \n        # --- Calculate Time Integration Error (epsilon_time) ---\n        numerator = np.abs(w_num - w_exact_at_grid)\n        denominator = np.maximum(np.abs(w_exact_at_grid), epsilon)\n        time_errors = numerator / denominator\n        eps_time = np.max(time_errors)\n        \n        # --- Calculate Interpolation Error (epsilon_interp) ---\n        interp_errors = []\n        for n in range(len(t_grid) - 1):\n            t_n = t_grid[n]\n            t_n1 = t_grid[n+1]\n            t_mid = 0.5 * (t_n + t_n1)\n            \n            # Exact values at endpoints\n            w_exact_n = w_exact_at_grid[n]\n            w_exact_n1 = w_exact_at_grid[n+1]\n            \n            # Linearly interpolated value at midpoint\n            w_lin_mid = 0.5 * (w_exact_n + w_exact_n1)\n            \n            # Exact value at midpoint\n            w_exact_mid = w_exact_func(t_mid)\n            \n            # Error at midpoint\n            num_interp = np.abs(w_lin_mid - w_exact_mid)\n            den_interp = np.maximum(np.abs(w_exact_mid), epsilon)\n            interp_errors.append(num_interp / den_interp)\n        \n        eps_interp = np.max(interp_errors) if interp_errors else 0.0\n        \n        return [eps_time, eps_interp]\n\n    test_cases = [\n        # Case A (linear drag, well-resolved)\n        {'type': 'linear', 'w0': 10.0, 'coeff': 2.0, 't_end': 1.0, 'dt': 0.1},\n        # Case B (linear drag, coarse step near stability boundary)\n        {'type': 'linear', 'w0': 10.0, 'coeff': 2.0, 't_end': 1.0, 'dt': 0.95},\n        # Case C (quadratic drag, well-resolved)\n        {'type': 'quadratic', 'w0': 10.0, 'coeff': 0.1, 't_end': 1.0, 'dt': 0.05},\n        # Case D (quadratic drag, coarse step)\n        {'type': 'quadratic', 'w0': 10.0, 'coeff': 0.1, 't_end': 1.0, 'dt': 0.5},\n        # Case E (quadratic drag, negative initial velocity)\n        {'type': 'quadratic', 'w0': -5.0, 'coeff': 0.2, 't_end': 2.0, 'dt': 0.1},\n    ]\n\n    results = [run_case(case) for case in test_cases]\n    \n    # Format the final output string\n    result_str = \",\".join(map(str, results))\n    print(f\"[{result_str}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3519080"}, {"introduction": "In a closed system, physical laws like the conservation of energy must be upheld not just in theory, but also by the numerical algorithm itself. Drag forces dissipate kinetic energy from the relative motion of dust and gas, converting it into thermal energy that heats the gas. This exercise moves from single-particle physics to a coupled two-fluid system, introducing the critical concept of discrete conservation laws [@problem_id:3519058]. You will implement a semi-implicit velocity update that is stable for any timestep and derive the corresponding heating term that guarantees exact energy conservation at the discrete level, a hallmark of high-quality numerical methods.", "problem": "Consider a spatially uniform, closed box containing a two-fluid mixture of gas and pressureless dust. Let the gas have mass density per volume $\\rho_g$, velocity $u_g$, and internal energy per volume $e_g$, and let the dust have mass density per volume $\\rho_d$ and velocity $u_d$. The only interaction between the two components is a linear drag described by a drag coefficient per unit volume $K$. There are no external forces and no spatial gradients, and all boundaries are periodic, so the box is closed and isolated.\n\nStart from Newton's second law applied to each fluid component and the definition of energy, with the following fundamental base:\n- Newton's second law: $\\rho_g\\,\\mathrm{d}u_g/\\mathrm{d}t = F_g$ and $\\rho_d\\,\\mathrm{d}u_d/\\mathrm{d}t = F_d$.\n- Equal and opposite drag force densities: $F_g = +K\\,(u_d - u_g)$ and $F_d = -K\\,(u_d - u_g)$.\n- Kinetic energy per volume: $E_k = \\tfrac{1}{2}\\rho_g u_g^2 + \\tfrac{1}{2}\\rho_d u_d^2$.\n- Total energy per volume in the box: $E_{\\mathrm{tot}} = E_k + e_g$, with the dust treated as pressureless (zero internal energy).\n\nYour task is to design and implement a time-integration scheme for the drag-only dynamics that, at the discrete level, preserves total energy in the closed box by adding the mechanical energy lost by the kinetic degrees of freedom into the gas internal energy as drag heating. Explicitly, the continuous-time rate of mechanical energy loss due to drag is $\\mathrm{d}E_k/\\mathrm{d}t = -K\\,|u_d - u_g|^2$, so the gas internal energy must change according to $\\mathrm{d}e_g/\\mathrm{d}t = +K\\,|u_d - u_g|^2$ to enforce $\\mathrm{d}E_{\\mathrm{tot}}/\\mathrm{d}t = 0$ in the closed box.\n\nImplement a discrete-time update over $\\Delta t$ for $u_g$ and $u_d$ that respects the exact drag-only evolution of the relative velocity and conserves the mass-weighted mean velocity. Then, update $e_g$ with a drag heating increment that is consistent with the chosen discrete evolution so that the discrete total energy $E_{\\mathrm{tot}}$ remains constant to within numerical round-off. You must provide two heating modes:\n- An exact-in-time heating mode that integrates $K\\,|u_d - u_g|^2$ over the step $\\Delta t$ consistently with the exact evolution of $u_d - u_g$.\n- A simple explicit heating mode that uses $K\\,|u_d - u_g|^2\\,\\Delta t$ evaluated at the beginning of the step.\n\nSimulate each test case for $N$ steps of size $\\Delta t$. At each step, compute the total energy per volume $E_{\\mathrm{tot}}$ and track the maximum absolute deviation from the initial total energy $E_{\\mathrm{tot},0}$ over the entire simulation. For each test case, return a boolean indicating whether this maximum absolute deviation is less than a tolerance $\\epsilon = 10^{-10}$ in units of Joule per cubic meter. All physical quantities must be handled in the following units:\n- Mass density per volume $\\rho_g$ and $\\rho_d$ in $\\mathrm{kg}\\,\\mathrm{m}^{-3}$.\n- Velocity $u_g$ and $u_d$ in $\\mathrm{m}\\,\\mathrm{s}^{-1}$.\n- Drag coefficient per unit volume $K$ in $\\mathrm{kg}\\,\\mathrm{m}^{-3}\\,\\mathrm{s}^{-1}$.\n- Time step $\\Delta t$ in $\\mathrm{s}$.\n- Energy per volume $E_{\\mathrm{tot}}$ and $e_g$ in $\\mathrm{J}\\,\\mathrm{m}^{-3}$.\n\nUse the following test suite, where each test case is a tuple $(\\rho_g, \\rho_d, K, u_{g,0}, u_{d,0}, e_{g,0}, \\Delta t, N, \\text{heating\\_mode})$:\n1. Moderate drag, moderate contrast: $(10^{-9}, 10^{-10}, 10^{-7}, 20, 5, 10^{-6}, 10^{-1}, 10, \"exact\")$.\n2. No drag (boundary case): $(10^{-9}, 10^{-10}, 0, 5, -5, 0, 1, 5, \"exact\")$.\n3. Strong drag with small time step: $(10^{-6}, 10^{-7}, 10^{-3}, 100, -100, 0, 10^{-4}, 1000, \"exact\")$.\n4. Highly asymmetric mass densities: $(10^{-8}, 10^{-12}, 5\\times 10^{-8}, 0, 100, 2, 0.5, 20, \"exact\")$.\n5. Same as case $1$ but with explicit heating to demonstrate non-conservation: $(10^{-9}, 10^{-10}, 10^{-7}, 20, 5, 10^{-6}, 10^{-1}, 10, \"explicit\")$.\n\nYour program should produce a single line of output containing the results for the five test cases as a comma-separated list enclosed in square brackets, in the order given above (for example, $[True,True,True,True,False]$).", "solution": "The problem asks for the design and implementation of a time-integration scheme for the dynamics of a gas-dust fluid mixture interacting solely through a linear drag force. The scheme must be constructed to exactly conserve total energy at the discrete level for a closed, uniform system. We will first derive the analytical solution for the velocity evolution, then construct a discrete update scheme that respects this solution, and finally derive the corresponding heating term that ensures total energy conservation.\n\nAll physical quantities are defined per unit volume. The gas is described by its mass density $\\rho_g$, velocity $u_g$, and internal energy $e_g$. The dust is pressureless and described by its mass density $\\rho_d$ and velocity $u_d$. The interaction is governed by a drag coefficient $K$.\n\nThe equations of motion, as given by Newton's second law, are:\n$$\n\\rho_g \\frac{\\mathrm{d}u_g}{\\mathrm{d}t} = +K(u_d - u_g)\n$$\n$$\n\\rho_d \\frac{\\mathrm{d}u_d}{\\mathrm{d}t} = -K(u_d - u_g)\n$$\n\nIt is advantageous to decompose the motion into the evolution of the center-of-mass velocity and the relative velocity. The total mass density is $\\rho_t = \\rho_g + \\rho_d$. The center-of-mass velocity, $v_c$, is defined as the mass-weighted mean velocity:\n$$\nv_c = \\frac{\\rho_g u_g + \\rho_d u_d}{\\rho_t}\n$$\nThe time-derivative of $v_c$ is:\n$$\n\\frac{\\mathrm{d}v_c}{\\mathrm{d}t} = \\frac{1}{\\rho_t} \\left( \\rho_g\\frac{\\mathrm{d}u_g}{\\mathrm{d}t} + \\rho_d\\frac{\\mathrm{d}u_d}{\\mathrm{d}t} \\right) = \\frac{1}{\\rho_t} \\left( K(u_d - u_g) - K(u_d - u_g) \\right) = 0\n$$\nThis confirms that the center-of-mass velocity $v_c$ is a conserved quantity, a direct consequence of the total momentum conservation in the closed system.\n\nThe relative velocity is $v_r = u_d - u_g$. Its time evolution is given by:\n$$\n\\frac{\\mathrm{d}v_r}{\\mathrm{d}t} = \\frac{\\mathrm{d}u_d}{\\mathrm{d}t} - \\frac{\\mathrm{d}u_g}{\\mathrm{d}t} = -\\frac{K}{\\rho_d}(u_d - u_g) - \\frac{K}{\\rho_g}(u_d - u_g) = -K\\left(\\frac{1}{\\rho_g} + \\frac{1}{\\rho_d}\\right)(u_d - u_g)\n$$\n$$\n\\frac{\\mathrm{d}v_r}{\\mathrm{d}t} = -K\\left(\\frac{\\rho_g + \\rho_d}{\\rho_g \\rho_d}\\right)v_r = -\\frac{1}{t_s}v_r\n$$\nwhere we have defined the characteristic drag or \"stopping\" time $t_s = \\frac{\\rho_g \\rho_d}{K(\\rho_g + \\rho_d)}$. This is a first-order linear ordinary differential equation with the exact solution:\n$$\nv_r(t) = v_r(0) e^{-t/t_s}\n$$\nThe relative velocity between the two components decays exponentially to zero.\n\nA discrete time-update scheme for the velocities from a time $t_n$ to $t_{n+1} = t_n + \\Delta t$ can be constructed to respect these analytical properties. Let $u_g^n$ and $u_d^n$ denote the velocities at time $t_n$. The updated velocities $u_g^{n+1}$ and $u_d^{n+1}$ must satisfy:\n1. Conservation of center-of-mass velocity: $v_c^{n+1} = v_c^n$.\n2. Exact evolution of relative velocity: $v_r^{n+1} = v_r^n e^{-\\Delta t/t_s}$.\n\nThe individual velocities can be expressed in terms of $v_c$ and $v_r$:\n$$\nu_g = v_c - \\frac{\\rho_d}{\\rho_t} v_r\n$$\n$$\nu_d = v_c + \\frac{\\rho_g}{\\rho_t} v_r\n$$\nApplying the update rules for $v_c$ and $v_r$, we obtain the updated individual velocities:\n$$\nu_g^{n+1} = v_c^n - \\frac{\\rho_d}{\\rho_t} \\left( v_r^n e^{-\\Delta t/t_s} \\right)\n$$\n$$\nu_d^{n+1} = v_c^n + \\frac{\\rho_g}{\\rho_t} \\left( v_r^n e^{-\\Delta t/t_s} \\right)\n$$\nThis semi-implicit scheme is stable for any timestep $\\Delta t$ and exactly captures the drag dynamics. For the special case $K=0$, $t_s \\to \\infty$, so $e^{-\\Delta t/t_s} \\to 1$, and the velocities remain constant, as expected.\n\nNext, we address the conservation of total energy, $E_{\\mathrm{tot}} = E_k + e_g$. The kinetic energy per volume, $E_k$, is given by:\n$$\nE_k = \\frac{1}{2}\\rho_g u_g^2 + \\frac{1}{2}\\rho_d u_d^2\n$$\nSubstituting the expressions for $u_g$ and $u_d$ in terms of $v_c$ and $v_r$ yields:\n$$\nE_k = \\frac{1}{2}\\rho_t v_c^2 + \\frac{1}{2}\\frac{\\rho_g\\rho_d}{\\rho_g+\\rho_d} v_r^2 = \\frac{1}{2}\\rho_t v_c^2 + \\frac{1}{2}\\mu v_r^2\n$$\nwhere $\\mu = \\frac{\\rho_g\\rho_d}{\\rho_g+\\rho_d}$ is the reduced mass density.\nSince $v_c$ is constant, the change in kinetic energy over a timestep $\\Delta t$ depends only on the change in $v_r$:\n$$\n\\Delta E_k = E_k^{n+1} - E_k^n = \\frac{1}{2}\\mu (v_r^{n+1})^2 - \\frac{1}{2}\\mu (v_r^n)^2 = \\frac{1}{2}\\mu \\left( (v_r^n e^{-\\Delta t/t_s})^2 - (v_r^n)^2 \\right)\n$$\n$$\n\\Delta E_k = -\\frac{1}{2}\\mu (v_r^n)^2 \\left( 1 - e^{-2\\Delta t/t_s} \\right)\n$$\nTo conserve total energy $E_{\\mathrm{tot}}$ at the discrete level, the change in internal energy, $\\Delta e_g = e_g^{n+1} - e_g^n$, must exactly balance the loss in kinetic energy:\n$$\n\\Delta e_g = -\\Delta E_k = +\\frac{1}{2}\\mu (v_r^n)^2 \\left( 1 - e^{-2\\Delta t/t_s} \\right)\n$$\nThis is the \"exact-in-time\" heating term. It corresponds precisely to integrating the continuous heating rate $\\mathrm{d}e_g/\\mathrm{d}t = K v_r(t)^2$ over the interval $\\Delta t$, using the exact solution for $v_r(t)$.\n\nFor comparison, the \"simple explicit\" heating mode is defined as using the heating rate evaluated at the beginning of the step:\n$$\n\\Delta e_{g, \\text{explicit}} = \\left( K |u_d^n - u_g^n|^2 \\right) \\Delta t = K (v_r^n)^2 \\Delta t\n$$\nSince $1 - e^{-x} \\approx x$ only for $x \\ll 1$, where $x = 2\\Delta t/t_s$, this explicit heating term is a first-order approximation to the exact heating. It will not conserve total energy except in the limit $\\Delta t \\to 0$.\n\nThe implementation will simulate the system for $N$ steps of size $\\Delta t$ using the derived velocity updates. It will compute the internal energy update using either the \"exact\" or \"explicit\" mode. The maximum absolute deviation of the total energy from its initial value, $|E_{\\mathrm{tot}} - E_{\\mathrm{tot},0}|$, will be tracked and compared against a tolerance $\\epsilon = 10^{-10}$.\n\nSpecial cases must be handled carefully. If $K=0$, then $t_s \\to \\infty$, the velocity decay factor is $1$, and the heating $\\Delta e_g$ is $0$. If either $\\rho_g=0$ or $\\rho_d=0$, then $\\mu=0$ and $t_s=0$. This implies infinitely strong coupling; the relative velocity damps instantly, and the decay factor is $0$. The heating term also becomes zero as $\\mu=0$. The logic must accommodate these limits.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the dust-gas drag problem for a series of test cases and\n    checks for energy conservation.\n    \"\"\"\n    test_cases = [\n        # (rho_g, rho_d, K, u_g_0, u_d_0, e_g_0, dt, N, heating_mode)\n        (1e-9, 1e-10, 1e-7, 20.0, 5.0, 1e-6, 0.1, 10, \"exact\"),\n        (1e-9, 1e-10, 0.0, 5.0, -5.0, 0.0, 1.0, 5, \"exact\"),\n        (1e-6, 1e-7, 1e-3, 100.0, -100.0, 0.0, 1e-4, 1000, \"exact\"),\n        (1e-8, 1e-12, 5e-8, 0.0, 100.0, 2.0, 0.5, 20, \"exact\"),\n        (1e-9, 1e-10, 1e-7, 20.0, 5.0, 1e-6, 0.1, 10, \"explicit\"),\n    ]\n    epsilon = 1e-10\n    results = []\n\n    for case in test_cases:\n        rho_g, rho_d, K, u_g_0, u_d_0, e_g_0, dt, N, mode = case\n\n        # Initialize state variables\n        u_g, u_d, e_g = float(u_g_0), float(u_d_0), float(e_g_0)\n\n        # Pre-compute constants\n        rho_t = rho_g + rho_d\n\n        # Calculate initial total energy\n        E_k_0 = 0.5 * rho_g * u_g**2 + 0.5 * rho_d * u_d**2\n        E_tot_0 = E_k_0 + e_g\n\n        max_dev = 0.0\n\n        for _ in range(N):\n            if rho_t == 0:\n                # If there's no mass, velocities and energies are trivially zero.\n                # No change occurs.\n                break\n\n            # Decompose into center-of-mass and relative velocities\n            v_c = (rho_g * u_g + rho_d * u_d) / rho_t\n            v_r = u_d - u_g\n\n            decay_factor = 1.0\n            delta_e_g = 0.0\n\n            # Calculate decay factor and heating term\n            if K  0.0 and rho_g  0.0 and rho_d  0.0:\n                mu = (rho_g * rho_d) / rho_t\n                t_s = mu / K\n                \n                # A very small t_s indicates stiff coupling, relative velocity damps quickly.\n                # np.exp handles large negative exponents gracefully.\n                if t_s  0.0:\n                    decay_factor = np.exp(-dt / t_s)\n                    if mode == \"exact\":\n                        # This term is exactly the kinetic energy lost by the relative motion\n                        delta_e_g = 0.5 * mu * v_r**2 * (1.0 - decay_factor**2)\n                    elif mode == \"explicit\":\n                        delta_e_g = K * v_r**2 * dt\n                else: # t_s is zero or negative (unphysical), means infinite coupling\n                    decay_factor = 0.0\n                    if mode == \"exact\":\n                        # All relative kinetic energy is dissipated in one step\n                        delta_e_g = 0.5 * mu * v_r**2\n                    elif mode == \"explicit\":\n                        # This would be infinite if K was infinite, but we handle via t_s\n                        delta_e_g = K * v_r**2 * dt\n\n            # For K=0, or if one density is zero, decay_factor remains 1 and delta_e_g is 0.\n\n            # Update relative velocity, which defines the new state\n            v_r_new = v_r * decay_factor\n\n            # Reconstruct individual velocities conserving center-of-mass velocity\n            # Note: v_c is constant and does not need to be updated.\n            u_g = v_c - (rho_d / rho_t) * v_r_new\n            u_d = v_c + (rho_g / rho_t) * v_r_new\n\n            # Update internal energy\n            e_g += delta_e_g\n\n            # Calculate new total energy and update maximum deviation\n            E_k_new = 0.5 * rho_g * u_g**2 + 0.5 * rho_d * u_d**2\n            E_tot_new = E_k_new + e_g\n            \n            max_dev = max(max_dev, abs(E_tot_new - E_tot_0))\n\n        results.append(max_dev  epsilon)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(lambda b: 'True' if b else 'False', results))}]\")\n\nsolve()\n```", "id": "3519058"}, {"introduction": "Realistic astrophysical simulations, particularly of protoplanetary disks, require specialized boundary conditions to model a small patch of a large, differentially rotating system. The shearing sheet approximation uses shearing-periodic boundary conditions, where fluid leaving one radial boundary re-enters the other with an azimuthal shift and momentum adjustment to account for the background Keplerian shear. This practice provides hands-on experience implementing one of the most important components of local disk simulations, developing a conservative remap algorithm to ensure that fundamental quantities like mass and momentum are conserved across the boundariesâ€”a mandatory requirement for any stable and physically meaningful simulation [@problem_id:3519067].", "problem": "You are to implement shearing-periodic boundary conditions for a two-fluid (gas and dust) finite-volume model in a local differentially rotating disk (the shearing sheet). Your implementation must guarantee, up to floating-point roundoff, conservation of total mass and total azimuthal momentum for both fluids across the shearing-periodic radial boundaries by using a conservative azimuthal remap and the correct azimuthal momentum offset implied by the background shear.\n\nThe physical base you must start from is:\n- The local shearing sheet has a background linear shear flow given by $v_{0,y}(x) = - q \\, \\Omega \\, x$, where $q$ is the dimensionless shear parameter and $\\Omega$ is the local angular frequency.\n- The shearing-periodic remap between the two radial boundaries separated by $L_x$ is an azimuthal translation by $\\Delta y(t) = q \\, \\Omega \\, L_x \\, t$.\n- The conserved variables are the cell-averaged density $\\rho$ and the azimuthal momentum $m_y = \\rho \\, v_y$ for each fluid. Across the radial boundaries, the azimuthal velocity differs by $\\pm q \\, \\Omega \\, L_x$ due to the background shear, so the corresponding azimuthal momentum must be offset by $\\pm \\rho \\, q \\, \\Omega \\, L_x$ to preserve the continuity of the fluctuation $v_y' \\equiv v_y + q \\, \\Omega \\, x$.\n\nYou must work in two spatial dimensions $(x,y)$ on a uniform Cartesian grid with cell centers. Let there be $N_x$ cells in $x$ across a domain of size $L_x$, and $N_y$ cells in $y$ across a domain of size $L_y$. Use $n_g$ ghost cells on each radial side. The left and right $x$ boundaries are shearing-periodic, and the azimuthal $y$ boundaries are strictly periodic.\n\nMathematically and algorithmically, you must:\n1. Derive the azimuthal shift in units of cells, $s(t)$, from $\\Delta y(t)$ as\n   $$ s(t) \\equiv \\frac{\\Delta y(t)}{\\Delta y_{\\text{cell}}} = \\frac{q \\, \\Omega \\, L_x \\, t}{L_y/N_y}, $$\n   where $\\Delta y_{\\text{cell}} = L_y/N_y$ is the cell size in the azimuthal direction.\n2. Implement a strictly conservative periodic remap of cell averages along $y$ by a shift $s$ (which may be any real number), for any one-dimensional array of cell averages $a_j$ with $j \\in \\{0,\\dots,N_y-1\\}$. The remap must produce new averages $b_j$ that represent the field translated by $\\Delta y$ and must satisfy\n   $$ \\sum_{j=0}^{N_y-1} b_j = \\sum_{j=0}^{N_y-1} a_j, $$\n   exactly up to floating-point roundoff. Use a piecewise-constant conservative translation constructed from integer and fractional parts of $s$. For a shift by $s$ cells, let $k \\equiv \\lfloor s \\rfloor$ and $f \\equiv s - k \\in [0,1)$, and require\n   $$ b_j = (1-f) \\, a_{(j-k)\\bmod N_y} + f \\, a_{(j-k-1)\\bmod N_y}. $$\n3. Use the same conservative remap to fill the ghost zones for both fluids at each radial boundary:\n   - Left ghost from right interior: remap by $+s$.\n   - Right ghost from left interior: remap by $-s$.\n4. Apply the azimuthal momentum offset across the radial boundaries consistently with the background shear:\n   - Mapping from right interior to left ghost must add $+ \\rho \\, q \\, \\Omega \\, L_x$ to the azimuthal momentum after conservative remap of $\\rho$ and $m_y$.\n   - Mapping from left interior to right ghost must add $- \\rho \\, q \\, \\Omega \\, L_x$ to the azimuthal momentum after conservative remap of $\\rho$ and $m_y$.\n   Here the $\\rho$ used in the offset is the remapped density at the receiver ghost cells, ensuring a physically consistent velocity offset.\n\nYour program must:\n- Construct initial cell-centered fields for gas and dust over the interior domain, using the following smooth, nontrivial, and scientifically plausible profiles in code units:\n  - Background coordinates with domain centered at $x=0$: $x_i = (i+0.5)\\, \\Delta x - L_x/2$ for $i \\in \\{0,\\dots,N_x-1\\}$ and $y_j = (j+0.5)\\, \\Delta y - L_y/2$ for $j \\in \\{0,\\dots,N_y-1\\}$, with $\\Delta x = L_x/N_x$ and $\\Delta y = L_y/N_y$.\n  - Gas density:\n    $$ \\rho_g(x,y) = 1 + 0.1 \\, \\sin\\!\\left(2\\pi \\frac{x}{L_x}\\right) \\cos\\!\\left(2\\pi \\frac{y}{L_y}\\right). $$\n  - Gas azimuthal velocity:\n    $$ v_{y,g}(x,y) = - q \\, \\Omega \\, x + 0.05 \\, \\sin\\!\\left(2\\pi \\frac{y}{L_y}\\right). $$\n  - Dust density:\n    $$ \\rho_d(x,y) = 0.5 + 0.2 \\, \\cos\\!\\left(2\\pi \\frac{x}{L_x}\\right) \\sin\\!\\left(4\\pi \\frac{y}{L_y}\\right). $$\n  - Dust azimuthal velocity:\n    $$ v_{y,d}(x,y) = - q \\, \\Omega \\, x - 0.03 \\, \\cos\\!\\left(2\\pi \\frac{y}{L_y}\\right). $$\n  - Define $m_{y,g} = \\rho_g \\, v_{y,g}$ and $m_{y,d} = \\rho_d \\, v_{y,d}$.\n- Build $n_g$ ghost zones on each radial side for both fluids and both conserved fields $(\\rho, m_y)$ using the conservative remap and momentum offset rules above.\n- Quantitatively verify conservation of total mass and azimuthal momentum across each radial boundary by comparing the donor interior panels and the receiver ghost panels. For the left boundary, the donor panel is the rightmost $n_g$ interior columns; for the right boundary, the donor panel is the leftmost $n_g$ interior columns. Let $\\Delta A = \\Delta x \\, \\Delta y$. Define, for each boundary and each fluid:\n  - Donor mass:\n    $$ M_{\\text{don}} = \\sum \\rho_{\\text{donor}} \\, \\Delta A. $$\n  - Receiver ghost mass:\n    $$ M_{\\text{ghost}} = \\sum \\rho_{\\text{ghost}} \\, \\Delta A. $$\n  - Donor azimuthal momentum:\n    $$ P_{\\text{don}} = \\sum m_{y,\\text{donor}} \\, \\Delta A. $$\n  - Receiver ghost azimuthal momentum:\n    $$ P_{\\text{ghost}} = \\sum m_{y,\\text{ghost}} \\, \\Delta A. $$\n  - Required conservation conditions:\n    - Mass: $M_{\\text{ghost}} = M_{\\text{don}}$.\n    - Momentum: $P_{\\text{ghost}} = P_{\\text{don}} \\pm q \\, \\Omega \\, L_x \\, M_{\\text{don}}$, with the $+$ sign for mapping from right to left, and the $-$ sign for mapping from left to right.\n  - Report the relative conservation errors:\n    $$ \\epsilon_M = \\frac{\\left|M_{\\text{ghost}} - M_{\\text{don}}\\right|}{\\max\\left(1, \\left|M_{\\text{don}}\\right|\\right)}, \\quad \\epsilon_P = \\frac{\\left|P_{\\text{ghost}} - \\left(P_{\\text{don}} \\pm q \\, \\Omega \\, L_x \\, M_{\\text{don}}\\right)\\right|}{\\max\\left(1, \\left|P_{\\text{don}} \\pm q \\, \\Omega \\, L_x \\, M_{\\text{don}}\\right|\\right)}. $$\n\nTest suite:\nRun your implementation on the following four test cases covering a zero shift, an integer-cell shift, a generic fractional shift, and a large-time multi-wrap shift. In all cases, use $q = 3/2$ and $\\Omega = 1$ in code units.\n- Case A (happy path, zero shift): $N_x = 32$, $N_y = 64$, $n_g = 2$, $L_x = 1$, $L_y = 1$, $t = 0$.\n- Case B (integer-cell shift): $N_x = 32$, $N_y = 64$, $n_g = 2$, $L_x = 1$, $L_y = 1$, choose $t$ such that $s = 17$, i.e.,\n  $$ t = \\frac{17}{q \\, \\Omega \\, N_y}. $$\n- Case C (fractional-cell shift): $N_x = 32$, $N_y = 64$, $n_g = 2$, $L_x = 1$, $L_y = 1$, choose $t$ such that $s = 12.37$, i.e.,\n  $$ t = \\frac{12.37}{q \\, \\Omega \\, N_y}. $$\n- Case D (large-time, many wraps, different $N_y$): $N_x = 28$, $N_y = 63$, $n_g = 3$, $L_x = 1$, $L_y = 1$, choose $t$ such that $s = 1234.567$, i.e.,\n  $$ t = \\frac{1234.567}{q \\, \\Omega \\, N_y}. $$\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each entry is a floating-point number equal to the maximum relative conservation error among $\\epsilon_M$ and $\\epsilon_P$ for gas and dust, across both radial boundaries, for that test case. In other words, produce\n$$ [E_A, E_B, E_C, E_D], $$\nwhere each $E_\\bullet$ is the maximum of the four errors (mass and momentum for gas and dust) across both the left and right boundary mappings for the corresponding case. These $E_\\bullet$ are dimensionless numbers. Print the numbers using default Python floating-point formatting.", "solution": "The problem requires the implementation and verification of shearing-periodic boundary conditions for a two-fluid, two-dimensional finite-volume hydrodynamic model. The model is situated in the local shearing sheet frame, which is a standard approximation for studying dynamics in a small patch of a differentially rotating disk. The solution must ensure conservation of mass and azimuthal momentum up to machine precision.\n\nThe physical domain is a Cartesian box of size $L_x \\times L_y$ with a background linear shear flow $v_{0,y}(x) = -q \\, \\Omega \\, x$, where $x \\in [-L_x/2, L_x/2]$. The shear parameter is $q$, and $\\Omega$ is the local orbital frequency. The domain is discretized into a uniform grid of $N_x \\times N_y$ cells. The conserved variables are the cell-averaged densities $\\rho_g, \\rho_d$ and azimuthal momentum densities $m_{y,g}, m_{y,d}$ for the gas and dust fluids, respectively. The azimuthal ($y$) boundaries are periodic. The radial ($x$) boundaries at $x = \\pm L_x/2$ are shearing-periodic, meaning that fluid crossing a radial boundary is re-introduced at the opposing boundary with an azimuthal shift and a velocity adjustment consistent with the background shear.\n\nThe core of the problem lies in the correct implementation of the boundary data transfer between the interior domain and the $n_g$ layers of ghost cells on each radial side. This process involves three main steps: a conservative azimuthal remap, the application of a momentum offset, and a quantitative verification of conservation.\n\nFirst, we define the time-dependent azimuthal shift. A parcel of fluid moving with the background flow at $x = L_x/2$ relative to one at $x = -L_x/2$ has a differential azimuthal velocity of $\\Delta v_y = v_{0,y}(-L_x/2) - v_{0,y}(L_x/2) = q\\Omega(L_x/2) - (-q\\Omega(L_x/2)) = q\\Omega L_x$. Over a time $t$, this results in an azimuthal displacement of $\\Delta y(t) = q \\, \\Omega \\, L_x \\, t$. Normalizing this by the azimuthal cell size $\\Delta y_{\\text{cell}} = L_y/N_y$, we obtain the shift in units of grid cells:\n$$ s(t) \\equiv \\frac{\\Delta y(t)}{\\Delta y_{\\text{cell}}} = \\frac{q \\, \\Omega \\, L_x \\, t}{L_y/N_y} $$\n\nNext, we address the conservative remap. To fill ghost cells, we must translate a column of cell-averaged data from the interior domain by a shift $s$. A simple interpolation would not conserve the total quantity. The problem specifies a piecewise-constant conservative translation. For a one-dimensional array of cell averages $a_j$ for $j \\in \\{0, \\dots, N_y-1\\}$, we seek a new array of averages $b_j$ representing the data shifted by $s$ cells. We decompose the shift $s$ into its integer and fractional parts: $k \\equiv \\lfloor s \\rfloor$ and $f \\equiv s - k \\in [0,1)$. The formula for the remapped averages is:\n$$ b_j = (1-f) \\, a_{(j-k)\\bmod N_y} + f \\, a_{(j-k-1)\\bmod N_y} $$\nThis operation is conservative, meaning $\\sum_{j=0}^{N_y-1} b_j = \\sum_{j=0}^{N_y-1} a_j$, up to floating-point error. This can be shown by summing $b_j$ over all $j$. The summation operator commutes with the linear combination, and the sums $\\sum_j a_{(j-k)\\bmod N_y}$ and $\\sum_j a_{(j-k-1)\\bmod N_y}$ are simply reorderings of the original sum $\\sum_j a_j$. Thus, $\\sum_j b_j = (1-f)\\sum_j a_j + f\\sum_j a_j = \\sum_j a_j$.\n\nThe ghost cell filling procedure is as follows:\n1.  **Left Ghost Cells (from Right Interior)**: The ghost cells on the left boundary ($x  -L_x/2$) are filled from the interior cells at the right boundary ($x \\approx L_x/2$). The mapping involves a positive azimuthal shift of $\\Delta y(t)$, corresponding to a cell shift of $+s$. For each of the $n_g$ columns in the left ghost region, the corresponding donor column from the right interior is identified. The conserved quantities ($\\rho$ and $m_y$) in this donor column are remapped azimuthally using the conservative formula with shift $+s$.\n2.  **Right Ghost Cells (from Left Interior)**: Symmetrically, the right ghost cells ($x  L_x/2$) are filled from the left interior cells ($x \\approx -L_x/2$). This mapping requires a negative azimuthal shift of $-\\Delta y(t)$, or a cell shift of $-s$.\n\nAfter the remap, the azimuthal momentum must be adjusted. The physical velocity fluctuation, $v_y' \\equiv v_y + q \\, \\Omega \\, x$, must be continuous across the boundaries. When fluid is mapped from the right boundary ($x=L_x/2$) to the left ($x=-L_x/2$), its total azimuthal velocity must jump by $\\Delta v_y = q\\Omega L_x$ to preserve $v_y'$. The azimuthal momentum $m_y = \\rho v_y$ is therefore adjusted as $m_{y, \\text{ghost}} = m_{y,\\text{remap}} + \\rho_{\\text{ghost}} q \\Omega L_x$. The density $\\rho_{\\text{ghost}}$ is the already remapped density, ensuring the velocity jump is applied correctly. For the mapping from left to right, the velocity must jump by $-q\\Omega L_x$, so the momentum adjustment is $m_{y, \\text{ghost}} = m_{y,\\text{remap}} - \\rho_{\\text{ghost}} q \\Omega L_x$.\n\nFinally, we verify the conservation properties. The total mass and corrected total azimuthal momentum in a panel of $n_g$ ghost columns must exactly equal the corresponding totals in the donor panel of $n_g$ interior columns. Let $\\Delta A = \\Delta x \\Delta y$ be the cell area.\nFor the right-to-left mapping:\n$$ M_{\\text{ghost}} = \\sum_{\\text{left ghost}} \\rho_{\\text{ghost}} \\, \\Delta A = \\sum_{\\text{right donor}} \\rho_{\\text{donor}} \\, \\Delta A = M_{\\text{don}} $$\n$$ P_{\\text{ghost}} = \\sum_{\\text{left ghost}} m_{y,\\text{ghost}} \\, \\Delta A = P_{\\text{don}} + q \\, \\Omega \\, L_x \\, M_{\\text{don}} $$\nFor the left-to-right mapping:\n$$ M_{\\text{ghost}} = \\sum_{\\text{right ghost}} \\rho_{\\text{ghost}} \\, \\Delta A = \\sum_{\\text{left donor}} \\rho_{\\text{donor}} \\, \\Delta A = M_{\\text{don}} $$\n$$ P_{\\text{ghost}} = \\sum_{\\text{right ghost}} m_{y,\\text{ghost}} \\, \\Delta A = P_{\\text{don}} - q \\, \\Omega \\, L_x \\, M_{\\text{don}} $$\nThe algorithm, by construction, satisfies these identities. The implementation calculates the relative errors, $\\epsilon_M$ and $\\epsilon_P$, which are expected to be of the order of machine precision. The numerical implementation uses `numpy` for efficient array-based calculations, particularly `numpy.roll` for the integer part of the azimuthal shift. Initial conditions for gas and dust fields ($\\rho_g$, $v_{y,g}$, $\\rho_d$, $v_{y,d}$) are generated on a cell-centered grid according to the provided functions. The procedure is then executed for each test case, and the maximum relative error across both fluids and both boundaries is reported.", "answer": "```python\nimport numpy as np\n\ndef conservative_remap(arr_1d, shift):\n    \"\"\"\n    Performs a 1D conservative periodic remap on cell-averaged data.\n\n    Args:\n        arr_1d (np.ndarray): 1D array of cell averages.\n        shift (float): The shift distance in units of cells.\n\n    Returns:\n        np.ndarray: The remapped 1D array.\n    \"\"\"\n    ny = len(arr_1d)\n    k = int(np.floor(shift))\n    f = shift - k\n\n    # The remap formula is b_j = (1-f)a_{j-k} + f*a_{j-k-1}\n    # np.roll(a, s) creates a result where result[i] = a[i-s].\n    term1 = np.roll(arr_1d, k)\n    term2 = np.roll(arr_1d, k + 1)\n    \n    remapped_arr = (1.0 - f) * term1 + f * term2\n    return remapped_arr\n\ndef apply_bcs(rho_interior, my_interior, Nx, Ny, ng, s, q, Omega, Lx):\n    \"\"\"\n    Applies shearing-periodic boundary conditions to a fluid's fields.\n\n    Args:\n        rho_interior (np.ndarray): 2D array of interior density.\n        my_interior (np.ndarray): 2D array of interior azimuthal momentum.\n        Nx, Ny, ng (int): Grid parameters.\n        s (float): Azimuthal shift in cells.\n        q, Omega, Lx (float): Physical parameters.\n\n    Returns:\n        tuple[np.ndarray, np.ndarray]: Full 2D arrays for density and momentum\n                                       including ghost zones.\n    \"\"\"\n    rho_full = np.zeros((Nx + 2 * ng, Ny))\n    my_full = np.zeros((Nx + 2 * ng, Ny))\n\n    rho_full[ng:ng+Nx, :] = rho_interior\n    my_full[ng:ng+Nx, :] = my_interior\n\n    # Fill left ghost zones (from right interior)\n    for i in range(ng):\n        donor_idx = Nx - ng + i # Index in interior array\n        ghost_idx = i           # Index in full array\n        \n        rho_donor_col = rho_interior[donor_idx, :]\n        rho_ghost_col = conservative_remap(rho_donor_col, s)\n        rho_full[ghost_idx, :] = rho_ghost_col\n\n        my_donor_col = my_interior[donor_idx, :]\n        my_ghost_col_remap = conservative_remap(my_donor_col, s)\n        \n        my_offset = rho_ghost_col * (q * Omega * Lx)\n        my_full[ghost_idx, :] = my_ghost_col_remap + my_offset\n\n    # Fill right ghost zones (from left interior)\n    for i in range(ng):\n        donor_idx = i           # Index in interior array\n        ghost_idx = ng + Nx + i # Index in full array\n        \n        rho_donor_col = rho_interior[donor_idx, :]\n        rho_ghost_col = conservative_remap(rho_donor_col, -s)\n        rho_full[ghost_idx, :] = rho_ghost_col\n\n        my_donor_col = my_interior[donor_idx, :]\n        my_ghost_col_remap = conservative_remap(my_donor_col, -s)\n        \n        my_offset = rho_ghost_col * (q * Omega * Lx)\n        my_full[ghost_idx, :] = my_ghost_col_remap - my_offset\n    \n    return rho_full, my_full\n\ndef verify_conservation(rho_int, my_int, rho_full, my_full, Nx, Ny, ng, dx, dy, q, Omega, Lx):\n    \"\"\"\n    Verifies mass and momentum conservation across boundaries and returns max error.\n    \"\"\"\n    dA = dx * dy\n    errors = []\n\n    # Left boundary (right interior - left ghost)\n    rho_donor_L = rho_int[Nx-ng:Nx, :]\n    my_donor_L = my_int[Nx-ng:Nx, :]\n    rho_ghost_L = rho_full[0:ng, :]\n    my_ghost_L = my_full[0:ng, :]\n    \n    M_don_L = np.sum(rho_donor_L) * dA\n    M_ghost_L = np.sum(rho_ghost_L) * dA\n    P_don_L = np.sum(my_donor_L) * dA\n    P_ghost_L = np.sum(my_ghost_L) * dA\n    \n    P_target_L = P_don_L + q * Omega * Lx * M_don_L\n    \n    err_M_L = np.abs(M_ghost_L - M_don_L) / max(1.0, np.abs(M_don_L))\n    err_P_L = np.abs(P_ghost_L - P_target_L) / max(1.0, np.abs(P_target_L))\n    errors.extend([err_M_L, err_P_L])\n    \n    # Right boundary (left interior - right ghost)\n    rho_donor_R = rho_int[0:ng, :]\n    my_donor_R = my_int[0:ng, :]\n    rho_ghost_R = rho_full[ng+Nx:ng+Nx+ng, :]\n    my_ghost_R = my_full[ng+Nx:ng+Nx+ng, :]\n    \n    M_don_R = np.sum(rho_donor_R) * dA\n    M_ghost_R = np.sum(rho_ghost_R) * dA\n    P_don_R = np.sum(my_donor_R) * dA\n    P_ghost_R = np.sum(my_ghost_R) * dA\n    \n    P_target_R = P_don_R - q * Omega * Lx * M_don_R\n    \n    err_M_R = np.abs(M_ghost_R - M_don_R) / max(1.0, np.abs(M_don_R))\n    err_P_R = np.abs(P_ghost_R - P_target_R) / max(1.0, np.abs(P_target_R))\n    errors.extend([err_M_R, err_P_R])\n\n    return max(errors)\n    \ndef run_case(params):\n    \"\"\"\n    Runs a single test case and returns the maximum conservation error.\n    \"\"\"\n    Nx, Ny, ng, Lx, Ly, t, q, Omega = params\n\n    dx = Lx / Nx\n    dy = Ly / Ny\n    x = (np.arange(Nx) + 0.5) * dx - Lx / 2\n    y = (np.arange(Ny) + 0.5) * dy - Ly / 2\n    xx, yy = np.meshgrid(x, y, indexing='ij')\n\n    # Initial conditions for gas\n    rho_g_int = 1.0 + 0.1 * np.sin(2 * np.pi * xx / Lx) * np.cos(2 * np.pi * yy / Ly)\n    vy_g_int = -q * Omega * xx + 0.05 * np.sin(2 * np.pi * yy / Ly)\n    my_g_int = rho_g_int * vy_g_int\n\n    # Initial conditions for dust\n    rho_d_int = 0.5 + 0.2 * np.cos(2 * np.pi * xx / Lx) * np.sin(4 * np.pi * yy / Ly)\n    vy_d_int = -q * Omega * xx - 0.03 * np.cos(2 * np.pi * yy / Ly)\n    my_d_int = rho_d_int * vy_d_int\n\n    s = (q * Omega * Lx * t) / dy\n\n    # Apply boundary conditions\n    rho_g_full, my_g_full = apply_bcs(rho_g_int, my_g_int, Nx, Ny, ng, s, q, Omega, Lx)\n    rho_d_full, my_d_full = apply_bcs(rho_d_int, my_d_int, Nx, Ny, ng, s, q, Omega, Lx)\n\n    # Verify conservation and get errors\n    err_g = verify_conservation(rho_g_int, my_g_int, rho_g_full, my_g_full, Nx, Ny, ng, dx, dy, q, Omega, Lx)\n    err_d = verify_conservation(rho_d_int, my_d_int, rho_d_full, my_d_full, Nx, Ny, ng, dx, dy, q, Omega, Lx)\n    \n    return max(err_g, err_d)\n\ndef solve():\n    \"\"\"\n    Main solver function to run all test cases and print results.\n    \"\"\"\n    q = 1.5\n    Omega = 1.0\n    \n    # (Nx, Ny, ng, Lx, Ly, t)\n    case_params = [\n        (32, 64, 2, 1.0, 1.0, 0.0),\n        (32, 64, 2, 1.0, 1.0, 17.0 / (q * Omega * 64)),\n        (32, 64, 2, 1.0, 1.0, 12.37 / (q * Omega * 64)),\n        (28, 63, 3, 1.0, 1.0, 1234.567 / (q * Omega * 63)),\n    ]\n\n    # Append q and Omega to each case's parameters\n    test_cases = [case + (q, Omega) for case in case_params]\n\n    results = []\n    for case in test_cases:\n        max_error = run_case(case)\n        results.append(max_error)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3519067"}]}