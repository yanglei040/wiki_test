{"hands_on_practices": [{"introduction": "Before we can populate a synthetic universe with galaxies, we must first define the stage on which they exist. This practice provides a foundational exercise in cosmological calculations, demonstrating how to determine the comoving volume corresponding to a specific redshift slice [@problem_id:3512721]. Mastering this conversion is essential for correctly translating theoretical galaxy number densities into the expected counts within a mock survey.", "problem": "You are constructing a mock galaxy catalog for a synthetic photometric survey. To convert a target comoving number density into expected counts per solid angle for a thin redshift slice, you need the comoving radial thickness of the slice at a given redshift. Consider a spatially flat Lambda Cold Dark Matter (ΛCDM) cosmology with matter density parameter $\\Omega_{m}=0.3$, dark energy density parameter $\\Omega_{\\Lambda}=0.7$, and Hubble constant $H_{0}=70\\,\\mathrm{km\\,s^{-1}\\,Mpc^{-1}}$. Assume negligible radiation density at the relevant redshift and spatial flatness so that $\\Omega_{m}+\\Omega_{\\Lambda}=1$. Using the definition of comoving radial distance and the Friedmann equation for $\\Lambda$CDM, derive the first-order expression for the comoving radial thickness $\\Delta \\chi$ of a redshift slice of width $\\Delta z$ centered at $z=1$, and compute its numerical value for $\\Delta z=0.1$. Use the speed of light $c=2.99792458\\times 10^{5}\\,\\mathrm{km\\,s^{-1}}$. Express your final numerical answer in megaparsecs (Mpc) and round to four significant figures.", "solution": "The comoving radial distance in a spatially flat Friedmann–Lemaître–Robertson–Walker spacetime is defined by\n$$\n\\chi(z)=c\\int_{0}^{z}\\frac{dz'}{H(z')}\\,,\n$$\nwhere $c$ is the speed of light and $H(z)$ is the redshift-dependent Hubble parameter. For a thin redshift slice centered at $z$ with width $\\Delta z$ such that higher-order terms in $\\Delta z$ are negligible, the comoving radial thickness is given to first order by\n$$\n\\Delta \\chi \\approx \\left.\\frac{d\\chi}{dz}\\right|_{z}\\,\\Delta z = \\frac{c}{H(z)}\\,\\Delta z\\,.\n$$\nThus the task reduces to evaluating $H(z)$ at $z=1$ in the given cosmology. For a spatially flat Lambda Cold Dark Matter (ΛCDM) cosmology with matter density parameter $\\Omega_{m}$ and dark energy density parameter $\\Omega_{\\Lambda}$ (assuming negligible radiation), the Friedmann equation gives\n$$\nH(z)=H_{0}\\,\\sqrt{\\Omega_{m}(1+z)^{3}+\\Omega_{\\Lambda}}\\,.\n$$\nEvaluating at $z=1$ with the provided parameters,\n$$\nH(1)=H_{0}\\,\\sqrt{\\Omega_{m}(1+1)^{3}+\\Omega_{\\Lambda}}=H_{0}\\,\\sqrt{\\Omega_{m}\\cdot 8+\\Omega_{\\Lambda}}=70\\,\\mathrm{km\\,s^{-1}\\,Mpc^{-1}}\\times \\sqrt{0.3\\times 8+0.7}\\,.\n$$\nCompute the argument of the square root:\n$$\n0.3\\times 8+0.7=2.4+0.7=3.1\\,,\n$$\nso\n$$\nH(1)=70\\,\\mathrm{km\\,s^{-1}\\,Mpc^{-1}}\\times \\sqrt{3.1}\\,.\n$$\nTherefore,\n$$\n\\Delta \\chi \\approx \\frac{c}{H(1)}\\,\\Delta z=\\frac{2.99792458\\times 10^{5}\\,\\mathrm{km\\,s^{-1}}}{70\\,\\mathrm{km\\,s^{-1}\\,Mpc^{-1}}\\,\\sqrt{3.1}}\\times 0.1\\,.\n$$\nCanceling the $\\mathrm{km\\,s^{-1}}$ units and simplifying the prefactor,\n$$\n\\Delta \\chi = \\frac{2.99792458\\times 10^{5}}{70\\,\\sqrt{3.1}}\\,\\mathrm{Mpc}\\times 0.1\\,.\n$$\nNow evaluate numerically in steps, keeping symbolic constants until the final computation:\n- Compute $\\sqrt{3.1}$ symbolically and then numerically: $\\sqrt{3.1}\\approx 1.7606816861659$.\n- Compute $H(1)=70\\times \\sqrt{3.1}\\approx 70\\times 1.7606816861659\\approx 123.247718031613\\,\\mathrm{km\\,s^{-1}\\,Mpc^{-1}}$.\n- Compute $c/H(1)\\approx \\frac{2.99792458\\times 10^{5}}{123.247718031613}\\,\\mathrm{Mpc}\\approx 2{,}432.438205\\,\\mathrm{Mpc}$.\n- Multiply by $\\Delta z=0.1$:\n$$\n\\Delta \\chi \\approx 243.2438205\\,\\mathrm{Mpc}\\,.\n$$\nRounding to four significant figures as requested yields\n$$\n\\Delta \\chi \\approx 243.2\\,\\mathrm{Mpc}\\,.\n$$", "answer": "$$\\boxed{243.2}$$", "id": "3512721"}, {"introduction": "Not every galaxy in the universe makes it into our catalogs; the sensitivity of our instruments imposes a fundamental selection effect. This practice guides you through the process of quantifying survey completeness by modeling how observational noise and varying survey depth affect the detection of galaxies with a given magnitude distribution [@problem_id:3512735]. Implementing this model is a key step toward creating mock catalogs that realistically mimic the selection biases of actual astronomical surveys.", "problem": "You are given a synthetic sky described by a Hierarchical Equal Area isoLatitude Pixelization (HEALPix) map, which for each pixel indexed by its angular center $\\vec{\\theta}_i$ stores the local $5\\sigma$ depth limiting magnitude in a single survey band, denoted $m_{\\mathrm{lim}}(\\vec{\\theta}_i)$. Assume a galaxy population with true apparent magnitude $m$ distributed according to a differential number counts model $p(m)$ across the bounded interval $[m_{\\min}, m_{\\max}]$, and assume that instrumental measurement noise on magnitude is Gaussian. Specifically, the measured magnitude $m_{\\mathrm{meas}}$ conditioned on the true magnitude $m$ is distributed as a normal random variable with mean $m$ and standard deviation $\\sigma_m$, and a source is detected if and only if $m_{\\mathrm{meas}} \\le m_{\\mathrm{lim}}(\\vec{\\theta})$. Define the local completeness $C(\\vec{\\theta})$ as the fraction of the intrinsic galaxy population that is detected at the location $\\vec{\\theta}$, averaged over the true magnitude distribution, within the interval $[m_{\\min}, m_{\\max}]$.\n\nStarting from probability theory and the Gaussian model specified above, derive an expression for $C(\\vec{\\theta})$ in terms of an integral over $m$, and implement a numerical algorithm that, given a HEALPix map of $m_{\\mathrm{lim}}(\\vec{\\theta}_i)$ and the parameters of $p(m)$ and $\\sigma_m$, computes $C(\\vec{\\theta}_i)$ for every pixel $i$ in the map. For this problem, take the galaxy magnitude distribution to be\n$$\np(m) \\propto 10^{\\beta m} \\quad \\text{for} \\quad m \\in [m_{\\min}, m_{\\max}],\n$$\nwith $p(m) = 0$ outside the interval. The proportionality constant does not need to be determined explicitly because $C(\\vec{\\theta})$ is a ratio of integrals in which any constant normalization cancels.\n\nYour program must compute $C(\\vec{\\theta}_i)$ for each specified test case below and output the results for all test cases on a single line, formatted as a comma-separated Python-style list whose elements are lists of floating-point numbers, each inner list corresponding to one test case and containing the per-pixel completeness values in the same order as the input $m_{\\mathrm{lim}}(\\vec{\\theta}_i)$ values. Round every completeness value to $4$ decimal places. No physical unit conversion is required because astronomical magnitudes are dimensionless by definition; angles $\\vec{\\theta}$ are not used directly in the computation, but if any angle is referenced it should be considered in radians. The detection threshold rule is the only instrument model used in this problem.\n\nImplement the solution using the following test suite, where each test case provides the HEALPix pixel limiting magnitudes $m_{\\mathrm{lim}}(\\vec{\\theta}_i)$, the slope parameter $\\beta$ of $p(m)$, the magnitude bounds $m_{\\min}$ and $m_{\\max}$, and the measurement noise $\\sigma_m$:\n\n- Test Case $1$ (general case, varied depths):\n  - $m_{\\mathrm{lim}}(\\vec{\\theta}_i)$: $\\left[24.5, 24.0, 23.0, 25.5\\right]$\n  - $\\beta = 0.6$\n  - $m_{\\min} = 20.0$, $m_{\\max} = 26.0$\n  - $\\sigma_m = 0.1$\n\n- Test Case $2$ (bright-limit boundary, expected low completeness):\n  - $m_{\\mathrm{lim}}(\\vec{\\theta}_i)$: $\\left[21.0, 21.5\\right]$\n  - $\\beta = 0.6$\n  - $m_{\\min} = 20.0$, $m_{\\max} = 26.0$\n  - $\\sigma_m = 0.05$\n\n- Test Case $3$ (faint-limit case, expected high completeness):\n  - $m_{\\mathrm{lim}}(\\vec{\\theta}_i)$: $\\left[26.0, 26.5, 27.0\\right]$\n  - $\\beta = 0.4$\n  - $m_{\\min} = 20.0$, $m_{\\max} = 27.0$\n  - $\\sigma_m = 0.2$\n\n- Test Case $4$ (uniform distribution across magnitudes, $\\beta = 0$):\n  - $m_{\\mathrm{lim}}(\\vec{\\theta}_i)$: $\\left[24.0, 25.0, 26.0\\right]$\n  - $\\beta = 0.0$\n  - $m_{\\min} = 22.0$, $m_{\\max} = 26.0$\n  - $\\sigma_m = 0.2$\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is itself a list corresponding to a test case. For example, the output should look like $\\left[[c_{1,1}, c_{1,2}, \\dots], [c_{2,1}, c_{2,2}, \\dots], \\dots\\right]$ with each $c_{t,i}$ a floating-point number rounded to $4$ decimal places.", "solution": "The problem requires the derivation and implementation of a formula for the local completeness, $C(\\vec{\\theta})$, which is defined as the fraction of an intrinsic galaxy population detected at a specific sky location $\\vec{\\theta}$. The detection is subject to a limiting magnitude $m_{\\mathrm{lim}}(\\vec{\\theta})$ and Gaussian measurement noise.\n\nFirst, we formalize the components of the calculation. The intrinsic distribution of galaxy true apparent magnitudes $m$ is given by a number counts model $p(m)$, which is non-zero only on the interval $[m_{\\min}, m_{\\max}]$. The problem specifies $p(m) \\propto 10^{\\beta m}$ on this interval. A galaxy is drawn from this distribution. Its magnitude is then measured, yielding a value $m_{\\mathrm{meas}}$. This measurement is a random variable following a normal distribution with mean equal to the true magnitude $m$ and a standard deviation of $\\sigma_m$. We can write this as $P(m_{\\mathrm{meas}} | m) = \\mathcal{N}(m, \\sigma_m^2)$. A galaxy is detected if and only if its measured magnitude is less than or equal to the local limiting magnitude, i.e., $m_{\\mathrm{meas}} \\le m_{\\mathrm{lim}}(\\vec{\\theta})$.\n\nThe probability of detecting a galaxy, conditioned on its true magnitude $m$ and the local limiting magnitude $m_{\\mathrm{lim}} \\equiv m_{\\mathrm{lim}}(\\vec{\\theta})$, is the probability $P(m_{\\mathrm{meas}} \\le m_{\\mathrm{lim}} | m)$. This is given by the cumulative distribution function (CDF) of the normal distribution $\\mathcal{N}(m, \\sigma_m^2)$, evaluated at $m_{\\mathrm{lim}}$.\n$$ P(\\text{detection}|m, m_{\\mathrm{lim}}) = \\int_{-\\infty}^{m_{\\mathrm{lim}}} \\frac{1}{\\sqrt{2\\pi}\\sigma_m} \\exp\\left(-\\frac{(x-m)^2}{2\\sigma_m^2}\\right) dx $$\nBy performing a change of variables $z = (x-m)/\\sigma_m$, this integral becomes the CDF of the standard normal distribution, $\\Phi(z)$, evaluated at $z = (m_{\\mathrm{lim}} - m)/\\sigma_m$.\n$$ P(\\text{detection}|m, m_{\\mathrm{lim}}) = \\Phi\\left(\\frac{m_{\\mathrm{lim}} - m}{\\sigma_m}\\right) $$\nThe standard normal CDF $\\Phi(z)$ is related to the error function $\\text{erf}(x)$ by the identity $\\Phi(z) = \\frac{1}{2}\\left(1 + \\text{erf}\\left(\\frac{z}{\\sqrt{2}}\\right)\\right)$. Substituting this into our expression gives the detection probability:\n$$ P(\\text{detection}|m, m_{\\mathrm{lim}}) = \\frac{1}{2}\\left(1 + \\text{erf}\\left(\\frac{m_{\\mathrm{lim}} - m}{\\sqrt{2}\\sigma_m}\\right)\\right) $$\n\nThe completeness $C(\\vec{\\theta})$ is the total fraction of detected galaxies, which is the average of the detection probability $P(\\text{detection}|m, m_{\\mathrm{lim}})$ weighted by the intrinsic magnitude distribution $p(m)$. This is calculated as the ratio of the number of detected galaxies to the total number of galaxies. In terms of probability densities, this ratio is:\n$$ C(m_{\\mathrm{lim}}) = \\frac{\\int_{m_{\\min}}^{m_{\\max}} p(m) P(\\text{detection}|m, m_{\\mathrm{lim}}) \\,dm}{\\int_{m_{\\min}}^{m_{\\max}} p(m) \\,dm} $$\nNote that the dependence on $\\vec{\\theta}$ is entirely through $m_{\\mathrm{lim}}(\\vec{\\theta})$, so we write $C(m_{\\mathrm{lim}})$. Substituting the expressions for $p(m)$ and the detection probability, we get:\n$$ C(m_{\\mathrm{lim}}) = \\frac{\\int_{m_{\\min}}^{m_{\\max}} 10^{\\beta m} \\cdot \\frac{1}{2}\\left(1 + \\text{erf}\\left(\\frac{m_{\\mathrm{lim}} - m}{\\sqrt{2}\\sigma_m}\\right)\\right) \\,dm}{\\int_{m_{\\min}}^{m_{\\max}} 10^{\\beta m} \\,dm} $$\nThe proportionality constant for $p(m)$ is identical in the numerator and the denominator, so it cancels, as stated in the problem.\n\nThe denominator can be solved analytically. The integral is $\\int 10^{\\beta m} dm = \\int e^{\\beta m \\ln(10)} dm$.\nFor $\\beta \\neq 0$:\n$$ \\int_{m_{\\min}}^{m_{\\max}} 10^{\\beta m} \\,dm = \\left[ \\frac{10^{\\beta m}}{\\beta \\ln(10)} \\right]_{m_{\\min}}^{m_{\\max}} = \\frac{10^{\\beta m_{\\max}} - 10^{\\beta m_{\\min}}}{\\beta \\ln(10)} $$\nFor the special case $\\beta = 0$, the integrand is $10^0 = 1$, so the integral is simply:\n$$ \\int_{m_{\\min}}^{m_{\\max}} 1 \\,dm = m_{\\max} - m_{\\min} $$\n\nThe numerator,\n$$ I_{\\text{num}} = \\int_{m_{\\min}}^{m_{\\max}} 10^{\\beta m} \\cdot \\frac{1}{2}\\left(1 + \\text{erf}\\left(\\frac{m_{\\mathrm{lim}} - m}{\\sqrt{2}\\sigma_m}\\right)\\right) \\,dm $$\ndoes not have a simple closed-form analytical solution and must be computed using numerical integration.\n\nThe algorithm to solve the problem is as follows:\n$1$. For each test case, parse the input parameters: the list of limiting magnitudes $\\{m_{\\mathrm{lim},i}\\}$, the slope $\\beta$, the bounds $m_{\\min}$ and $m_{\\max}$, and the noise $\\sigma_m$.\n$2$. For each $m_{\\mathrm{lim},i}$ in the list:\n    a. Define the integrand for the numerator as a function of $m$, $f(m) = 10^{\\beta m} \\cdot \\frac{1}{2}\\left(1 + \\text{erf}\\left(\\frac{m_{\\mathrm{lim},i} - m}{\\sqrt{2}\\sigma_m}\\right)\\right)$.\n    b.Numerically integrate $f(m)$ from $m_{\\min}$ to $m_{\\max}$ to get the numerator $I_{\\text{num}}$.\n    c. Analytically calculate the denominator $I_{\\text{den}}$ using the appropriate formula for the given $\\beta$.\n    d. Compute the completeness $C_i = I_{\\text{num}} / I_{\\text{den}}$.\n    e. Round the result to $4$ decimal places.\n$3$. Collect the computed completeness values for each test case into a list.\n$4$. Assemble the lists from all test cases into a final list of lists.\nThis procedure will be implemented using Python, with the `scipy.integrate.quad` function for numerical integration and `scipy.special.erf` for the error function.", "answer": "```python\nimport numpy as np\nfrom scipy.special import erf\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Solves the galaxy completeness problem for the given test cases.\n    \"\"\"\n\n    test_cases = [\n        # Test Case 1: general case, varied depths\n        {'m_lims': [24.5, 24.0, 23.0, 25.5], 'beta': 0.6, 'm_min': 20.0, 'm_max': 26.0, 'sigma_m': 0.1},\n        # Test Case 2: bright-limit boundary, expected low completeness\n        {'m_lims': [21.0, 21.5], 'beta': 0.6, 'm_min': 20.0, 'm_max': 26.0, 'sigma_m': 0.05},\n        # Test Case 3: faint-limit case, expected high completeness\n        {'m_lims': [26.0, 26.5, 27.0], 'beta': 0.4, 'm_min': 20.0, 'm_max': 27.0, 'sigma_m': 0.2},\n        # Test Case 4: uniform distribution across magnitudes, beta = 0\n        {'m_lims': [24.0, 25.0, 26.0], 'beta': 0.0, 'm_min': 22.0, 'm_max': 26.0, 'sigma_m': 0.2},\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        m_lims = case['m_lims']\n        beta = case['beta']\n        m_min = case['m_min']\n        m_max = case['m_max']\n        sigma_m = case['sigma_m']\n        \n        case_results = []\n        \n        # Calculate the denominator integral once per test case\n        if beta == 0.0:\n            denominator = m_max - m_min\n        else:\n            log_10 = np.log(10)\n            denominator = (10**(beta * m_max) - 10**(beta * m_min)) / (beta * log_10)\n\n        if denominator == 0:\n            # This case should not be reached with the given inputs, but is a safeguard.\n            # If the denominator is 0, it means no galaxies in the range, so completeness is ill-defined.\n            # We can treat it as 0 detected galaxies out of 0 total, or just set completeness to 0.\n            case_results = [0.0] * len(m_lims)\n            all_results.append(case_results)\n            continue\n            \n        for m_lim in m_lims:\n            # Define the integrand for the numerator\n            def numerator_integrand(m):\n                # Unnormalized galaxy number counts p(m)\n                p_m = 10**(beta * m)\n                \n                # Detection probability P(detection|m)\n                arg_erf = (m_lim - m) / (np.sqrt(2) * sigma_m)\n                p_det = 0.5 * (1.0 + erf(arg_erf))\n                \n                return p_m * p_det\n\n            # Numerically integrate the numerator\n            # The second return value of quad is the error estimate, which we ignore.\n            numerator, _ = quad(numerator_integrand, m_min, m_max)\n            \n            # Calculate completeness\n            completeness = numerator / denominator\n            case_results.append(round(completeness, 4))\n            \n        all_results.append(case_results)\n\n    # Print the final result in the exact specified format.\n    # The default str() representation of a list of lists is \"[[], [], ...]\" which is a valid Python-style list format.\n    print(all_results)\n\nsolve()\n```", "id": "3512735"}, {"introduction": "Realistic observations are often far from pristine, with effects like the blending of light from nearby objects corrupting our measurements. This advanced practice challenges you to build a forward model that simulates the impact of galaxy blending on fundamental observables like shape and color, and to quantify the resulting biases in cosmological measurements such as weak lensing shear and photometric redshifts [@problem_id:3512765]. By tackling this problem, you will gain deep insight into how complex systematics are propagated from raw pixels to final scientific conclusions.", "problem": "You are tasked with building a forward-modeling pipeline that generates synthetic observations of a crowded two-galaxy field, propagates photometric blending to shape and photometric redshift estimates, and quantifies biases in cosmic shear and galaxy–galaxy lensing signals. Work in a simplified, yet scientifically consistent and self-contained setting that uses a single source galaxy (the \"target\") blended with one neighbor. The target and neighbor have two-dimensional Gaussian surface brightness profiles observed through a Gaussian Point Spread Function (PSF). Assume weak lensing shear is present. The program must implement the following modeling elements and computations from first principles.\n\nModeling assumptions and fundamental bases:\n\n- The surface brightness of each galaxy is modeled as a two-dimensional Gaussian with isotropic covariance. For a galaxy indexed by $i$, with total flux $F_i$ in a given band and intrinsic isotropic size parameter $s_i$ (in arbitrary pixel units), its unconvolved second-moment tensor (about its own centroid) is $$\\mathbf{S}_i = s_i^2 \\mathbf{I},$$ where $\\mathbf{I}$ is the $2 \\times 2$ identity matrix. The PSF is Gaussian with isotropic covariance $$\\mathbf{P} = \\sigma_{\\mathrm{psf}}^2 \\mathbf{I}.$$\n- Convolution of two Gaussians results in a Gaussian with covariance equal to the sum of covariances. Therefore, the convolved second-moment tensor of galaxy $i$ is $$\\mathbf{Q}_i = \\mathbf{S}_i + \\mathbf{P}.$$\n- In the weak lensing regime, with small reduced shear $(g_1, g_2)$ and zero convergence, approximate the mapping of second moments by the first-order linearization. Let $$\\mathbf{G} = \\begin{pmatrix} g_1 & g_2 \\\\ g_2 & -g_1 \\end{pmatrix}, \\quad \\mathbf{A} = \\mathbf{I} + \\mathbf{G}.$$ The sheared second-moment tensor is $$\\mathbf{Q}_i' = \\mathbf{A}\\,\\mathbf{Q}_i\\,\\mathbf{A}^\\top.$$\n- The blended light distribution is the linear superposition of the two Gaussian components. Let the target have centroid $\\mathbf{x}_t = (0, 0)$ and the neighbor have centroid $\\mathbf{x}_n = (d, 0)$, i.e., the neighbor lies along the $x$-axis separated by a distance $d$. In a given band $B$, with fluxes $F_{t,B}$ and $F_{n,B}$, the flux-weighted blended centroid is $$\\bar{\\mathbf{x}}_B = \\frac{F_{t,B}\\,\\mathbf{x}_t + F_{n,B}\\,\\mathbf{x}_n}{F_{t,B} + F_{n,B}}.$$ The blended second-moment tensor about $\\bar{\\mathbf{x}}_B$ is the flux-weighted sum of the component second moments plus the centroid-offset contributions, $$\\mathbf{M}_B = \\frac{F_{t,B}\\left(\\mathbf{Q}_t' + (\\mathbf{x}_t - \\bar{\\mathbf{x}}_B)(\\mathbf{x}_t - \\bar{\\mathbf{x}}_B)^\\top\\right) + F_{n,B}\\left(\\mathbf{Q}_n' + (\\mathbf{x}_n - \\bar{\\mathbf{x}}_B)(\\mathbf{x}_n - \\bar{\\mathbf{x}}_B)^\\top\\right)}{F_{t,B} + F_{n,B}}.$$\n- Define the ellipticity components $(e_1, e_2)$ from the blended second moments (in the shape-measurement band) using the standard second-moment ellipticity definition, with the trace in the denominator to normalize the anisotropy. Use the same definition for the target-only case to obtain the baseline \"true\" ellipticity under shear without blending.\n- Photometric redshift is estimated from a single color constructed from two bands $r$ and $i$. Let the color be $$C = -2.5\\,\\log_{10}\\left(\\frac{F_r}{F_i}\\right),$$ using the total blended fluxes in those bands, and estimate $$\\hat{z} = a\\,C + b,$$ where $a$ and $b$ are fixed calibration parameters.\n- For galaxy–galaxy lensing, the measured excess surface density $\\Delta\\Sigma$ scales as the product of the true tangential shear and the critical surface density $\\Sigma_{\\mathrm{crit}}$. In a flat, low-redshift approximation, use angular diameter distances proportional to redshift, i.e., $$D(z) \\propto z,$$ so that $$\\Sigma_{\\mathrm{crit}}(z_l, z_s) \\propto \\frac{D(z_s)}{D(z_l)\\left[D(z_s) - D(z_l)\\right]} = \\frac{z_s}{z_l\\,(z_s - z_l)}.$$ The fractional bias in $\\Delta\\Sigma$ arising from shear calibration and photometric redshift error is $$\\delta_{\\Delta\\Sigma} = (1 + m)\\,\\frac{\\Sigma_{\\mathrm{crit}}(z_l, \\hat{z})}{\\Sigma_{\\mathrm{crit}}(z_l, z_t)} - 1,$$ where $m$ is the multiplicative shear bias defined below, $z_l$ is the lens redshift, $z_t$ is the true source redshift of the target, and $\\hat{z}$ is the photometric redshift estimated from the blended color.\n\nQuantities to compute for each test case:\n\n1. Compute the target-only second-moment tensor in the shape band $i$, its ellipticity $(e_{1,\\mathrm{true}}, e_{2,\\mathrm{true}})$ under shear, and the blended second-moment tensor and ellipticity $(e_{1,\\mathrm{obs}}, e_{2,\\mathrm{obs}})$ using the fluxes in band $i$.\n2. Define the multiplicative shear bias $m$ and additive shear bias vector $\\mathbf{c} = (c_1, c_2)$ through the relation $$\\mathbf{e}_{\\mathrm{obs}} = (1 + m)\\,\\mathbf{e}_{\\mathrm{true}} + \\mathbf{c},$$ and compute them, treating $m$ as the scalar that minimizes the squared residual along $\\mathbf{e}_{\\mathrm{true}}$ (i.e., $$m = \\frac{\\mathbf{e}_{\\mathrm{obs}} \\cdot \\mathbf{e}_{\\mathrm{true}}}{\\mathbf{e}_{\\mathrm{true}} \\cdot \\mathbf{e}_{\\mathrm{true}}} - 1$$), with $$\\mathbf{c} = \\mathbf{e}_{\\mathrm{obs}} - (1 + m)\\,\\mathbf{e}_{\\mathrm{true}}.$$\n3. Compute the photometric redshift bias $$\\delta z = \\hat{z} - z_t,$$ where $z_t$ is the true source redshift of the target, and $\\hat{z}$ is the blended estimate from the color definition above.\n4. Compute the fractional bias in galaxy–galaxy lensing $$\\delta_{\\Delta\\Sigma}$$ using the simplified critical surface density scaling in the low-redshift approximation.\n\nTest suite:\n\nUse the following four test cases, each specified as a tuple of parameters in the order $(s_t, s_n, F_{t,i}, F_{t,r}, F_{n,i}, F_{n,r}, d, \\sigma_{\\mathrm{psf}}, g_1, g_2, z_t, z_l, a, b)$:\n\n- Case A (general crowded-field blending): (1.0, 0.8, 1.0, 0.6, 0.3, 0.9, 0.5, 0.5, 0.02, -0.01, 0.7, 0.3, -1.2, 0.8).\n- Case B (near-complete overlap): (0.9, 0.9, 1.2, 0.7, 1.0, 1.5, 0.0, 0.7, 0.03, 0.0, 0.6, 0.3, -1.2, 0.8).\n- Case C (neighbor far away, minimal blending): (1.0, 1.0, 1.0, 0.8, 0.5, 0.5, 5.0, 0.6, 0.01, 0.01, 0.5, 0.2, -1.2, 0.8).\n- Case D (photometric contamination only, no shape blending in $i$): (1.1, 0.7, 1.0, 0.9, 0.0, 1.0, 2.0, 0.5, 0.02, 0.02, 0.65, 0.25, -1.2, 0.8).\n\nYour program must:\n\n- Implement the modeling and computations described above in a numerically stable manner using double-precision floating-point arithmetic.\n- For each test case, output the list $[m, c_1, c_2, \\delta z, \\delta_{\\Delta\\Sigma}]$.\n- Aggregate the results for all four test cases into a single line: a comma-separated list enclosed in square brackets, where each element is the per-case list described above. For example, a valid output format is $[ [x_1, x_2, x_3, x_4, x_5], [y_1, y_2, y_3, y_4, y_5], [z_1, z_2, z_3, z_4, z_5], [w_1, w_2, w_3, w_4, w_5] ].$\n\nAll outputs are dimensionless floats. No physical units or angle units are required in the final answers. Your implementation must be self-contained and require no external inputs. The acronyms used are Point Spread Function (PSF), Galaxy–Galaxy Lensing (GGL).", "solution": "The solution proceeds by systematically implementing the chain of forward models described in the problem statement. For each test case, specified by the parameter tuple $(s_t, s_n, F_{t,i}, F_{t,r}, F_{n,i}, F_{n,r}, d, \\sigma_{\\mathrm{psf}}, g_1, g_2, z_t, z_l, a, b)$, we compute the five requested quantities: the multiplicative shear bias $m$, the additive shear bias components $(c_1, c_2)$, the photometric redshift bias $\\delta z$, and the fractional galaxy-galaxy lensing bias $\\delta_{\\Delta\\Sigma}$.\n\n**1. Preliminary Definitions**\nWe define the fundamental matrices and vectors. The $2 \\times 2$ identity matrix is $\\mathbf{I}$. The weak lensing shear is described by the matrix $\\mathbf{G}$, and the corresponding linear transformation matrix is $\\mathbf{A}$:\n$$\n\\mathbf{G} = \\begin{pmatrix} g_1 & g_2 \\\\ g_2 & -g_1 \\end{pmatrix}, \\quad \\mathbf{A} = \\mathbf{I} + \\mathbf{G}\n$$\nThe centroids of the target and neighbor galaxies are $\\mathbf{x}_t = (0, 0)^\\top$ and $\\mathbf{x}_n = (d, 0)^\\top$, respectively.\n\n**2. Intrinsic and Sheared Galaxy Properties**\nThe unconvolved second-moment tensors for the target ($t$) and neighbor ($n$) are $\\mathbf{S}_t = s_t^2 \\mathbf{I}$ and $\\mathbf{S}_n = s_n^2 \\mathbf{I}$. The Point Spread Function (PSF) is modeled by its second-moment tensor $\\mathbf{P} = \\sigma_{\\mathrm{psf}}^2 \\mathbf{I}$.\nThe convolved (observed in isolation) second-moment tensors are the sum of the intrinsic and PSF covariances:\n$$\n\\mathbf{Q}_t = \\mathbf{S}_t + \\mathbf{P} = (s_t^2 + \\sigma_{\\mathrm{psf}}^2) \\mathbf{I} \\\\\n\\mathbf{Q}_n = \\mathbf{S}_n + \\mathbf{P} = (s_n^2 + \\sigma_{\\mathrm{psf}}^2) \\mathbf{I}\n$$\nThese moments are then transformed by the weak lensing shear. Assuming both galaxies are at the same source plane and are affected by the same shear, their sheared second-moment tensors are:\n$$\n\\mathbf{Q}_t' = \\mathbf{A}\\,\\mathbf{Q}_t\\,\\mathbf{A}^\\top \\quad \\text{and} \\quad \\mathbf{Q}_n' = \\mathbf{A}\\,\\mathbf{Q}_n\\,\\mathbf{A}^\\top\n$$\n\n**3. \"True\" Ellipticity without Blending**\nThe baseline or \"true\" ellipticity, $\\mathbf{e}_{\\mathrm{true}} = (e_{1,\\mathrm{true}}, e_{2,\\mathrm{true}})$, corresponds to the shape one would measure for the target galaxy alone, post-shear and post-convolution. It is calculated from $\\mathbf{Q}_t'$ using the standard second-moment ellipticity definition:\n$$\ne_{1,\\mathrm{true}} = \\frac{Q'_{t,11} - Q'_{t,22}}{\\mathrm{Tr}(\\mathbf{Q}_t')}, \\quad e_{2,\\mathrm{true}} = \\frac{2 Q'_{t,12}}{\\mathrm{Tr}(\\mathbf{Q}_t')}\n$$\nwhere $\\mathrm{Tr}(\\mathbf{Q}_t') = Q'_{t,11} + Q'_{t,22}$.\n\n**4. Blended Properties and \"Observed\" Ellipticity**\nWhen the two galaxies are blended, the total light distribution is a superposition. Shape measurements are performed in the $i$-band. The total flux in this band is $F_{\\mathrm{tot},i} = F_{t,i} + F_{n,i}$. The flux-weighted centroid of the blended object is:\n$$\n\\bar{\\mathbf{x}}_i = \\frac{F_{t,i}\\,\\mathbf{x}_t + F_{n,i}\\,\\mathbf{x}_n}{F_{\\mathrm{tot},i}} = \\left(\\frac{F_{n,i} d}{F_{t,i} + F_{n,i}}, 0\\right)^\\top\n$$\nThe blended second-moment tensor, $\\mathbf{M}_i$, is computed about this new centroid using the parallel axis theorem for a mixture of components:\n$$\n\\mathbf{M}_i = \\frac{F_{t,i}\\left(\\mathbf{Q}_t' + (\\mathbf{x}_t - \\bar{\\mathbf{x}}_i)(\\mathbf{x}_t - \\bar{\\mathbf{x}}_i)^\\top\\right) + F_{n,i}\\left(\\mathbf{Q}_n' + (\\mathbf{x}_n - \\bar{\\mathbf{x}}_i)(\\mathbf{x}_n - \\bar{\\mathbf{x}}_i)^\\top\\right)}{F_{t,i} + F_{n,i}}\n$$\nThe \"observed\" ellipticity of the blended object, $\\mathbf{e}_{\\mathrm{obs}} = (e_{1,\\mathrm{obs}}, e_{2,\\mathrm{obs}})$, is calculated from $\\mathbf{M}_i$:\n$$\ne_{1,\\mathrm{obs}} = \\frac{M_{i,11} - M_{i,22}}{\\mathrm{Tr}(\\mathbf{M}_i)}, \\quad e_{2,\\mathrm{obs}} = \\frac{2 M_{i,12}}{\\mathrm{Tr}(\\mathbf{M}_i)}\n$$\n\n**5. Shear Calibration Biases ($m$ and $c$)**\nThe multiplicative bias, $m$, and additive bias, $\\mathbf{c}=(c_1, c_2)$, are defined by modeling the observed ellipticity as a linear transformation of the true ellipticity: $\\mathbf{e}_{\\mathrm{obs}} = (1 + m)\\,\\mathbf{e}_{\\mathrm{true}} + \\mathbf{c}$. Using the provided definitions, we compute:\n$$\nm = \\frac{\\mathbf{e}_{\\mathrm{obs}} \\cdot \\mathbf{e}_{\\mathrm{true}}}{\\mathbf{e}_{\\mathrm{true}} \\cdot \\mathbf{e}_{\\mathrm{true}}} - 1\n$$\n$$\n\\mathbf{c} = \\mathbf{e}_{\\mathrm{obs}} - (1 + m)\\,\\mathbf{e}_{\\mathrm{true}}\n$$\n\n**6. Photometric Redshift Bias ($\\delta z$)**\nThe photometric redshift estimate, $\\hat{z}$, is based on the color from the total blended fluxes in the $r$ and $i$ bands: $F_{\\mathrm{tot},r} = F_{t,r} + F_{n,r}$ and $F_{\\mathrm{tot},i} = F_{t,i} + F_{n,i}$. The color $C$ and the estimated redshift $\\hat{z}$ are:\n$$\nC = -2.5\\,\\log_{10}\\left(\\frac{F_{\\mathrm{tot},r}}{F_{\\mathrm{tot},i}}\\right)\n$$\n$$\n\\hat{z} = a\\,C + b\n$$\nThe photometric redshift bias is the difference between the estimated and true redshift of the target galaxy:\n$$\n\\delta z = \\hat{z} - z_t\n$$\n\n**7. Galaxy-Galaxy Lensing Bias ($\\delta_{\\Delta\\Sigma}$)**\nThe fractional bias in the galaxy-galaxy lensing signal, $\\delta_{\\Delta\\Sigma}$, combines the effects of shear calibration bias ($m$) and photometric redshift bias. The bias depends on the ratio of the critical surface density, $\\Sigma_{\\mathrm{crit}}$, evaluated at the true source redshift $z_t$ and the estimated redshift $\\hat{z}$. Using the given low-redshift approximation $\\Sigma_{\\mathrm{crit}}(z_l, z_s) \\propto \\frac{z_s}{z_l\\,(z_s - z_l)}$, the ratio is:\n$$\n\\frac{\\Sigma_{\\mathrm{crit}}(z_l, \\hat{z})}{\\Sigma_{\\mathrm{crit}}(z_l, z_t)} = \\frac{\\hat{z}}{z_l(\\hat{z} - z_l)} \\cdot \\frac{z_l(z_t - z_l)}{z_t} = \\frac{\\hat{z}(z_t - z_l)}{z_t(\\hat{z} - z_l)}\n$$\nThe final fractional bias is then:\n$$\n\\delta_{\\Delta\\Sigma} = (1 + m)\\,\\frac{\\Sigma_{\\mathrm{crit}}(z_l, \\hat{z})}{\\Sigma_{\\mathrm{crit}}(z_l, z_t)} - 1 = (1 + m)\\,\\frac{\\hat{z}(z_t - z_l)}{z_t(\\hat{z} - z_l)} - 1\n$$\nThis formula is evaluated for each test case to obtain the final required quantity. The calculation is feasible for all test cases, as $\\hat{z} > z_l$ for all provided inputs.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation and print results for all test cases.\n    \"\"\"\n    # Test cases parameters are provided in the following order:\n    # (s_t, s_n, F_ti, F_tr, F_ni, F_nr, d, sigma_psf, g1, g2, z_t, z_l, a, b)\n    test_cases = [\n        # Case A (general crowded-field blending)\n        (1.0, 0.8, 1.0, 0.6, 0.3, 0.9, 0.5, 0.5, 0.02, -0.01, 0.7, 0.3, -1.2, 0.8),\n        # Case B (near-complete overlap)\n        (0.9, 0.9, 1.2, 0.7, 1.0, 1.5, 0.0, 0.7, 0.03, 0.0, 0.6, 0.3, -1.2, 0.8),\n        # Case C (neighbor far away, minimal blending)\n        (1.0, 1.0, 1.0, 0.8, 0.5, 0.5, 5.0, 0.6, 0.01, 0.01, 0.5, 0.2, -1.2, 0.8),\n        # Case D (photometric contamination only, no shape blending in i)\n        (1.1, 0.7, 1.0, 0.9, 0.0, 1.0, 2.0, 0.5, 0.02, 0.02, 0.65, 0.25, -1.2, 0.8)\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_biases_for_case(case)\n        # Format each number in the list to a consistent representation if needed,\n        # but Python's default float representation is fine.\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The string representation of a list of lists in Python matches the required format.\n    # Using the suggested template's join method for robustness.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef compute_biases_for_case(params):\n    \"\"\"\n    Computes all specified biases for a single test case.\n    \"\"\"\n    s_t, s_n, f_ti, f_tr, f_ni, f_nr, d, sigma_psf, g1, g2, z_t, z_l, a, b = params\n\n    # Use double-precision floating-point arithmetic (numpy default)\n    I = np.identity(2)\n    xt = np.array([0.0, 0.0])\n    xn = np.array([d, 0.0])\n\n    G = np.array([[g1, g2], [g2, -g1]])\n    A = I + G\n\n    # 1. Compute target-only properties and true ellipticity\n    Q_t = (s_t**2 + sigma_psf**2) * I\n    Q_t_prime = A @ Q_t @ A.T\n    \n    trace_qt = np.trace(Q_t_prime)\n    e1_true = (Q_t_prime[0, 0] - Q_t_prime[1, 1]) / trace_qt\n    e2_true = 2 * Q_t_prime[0, 1] / trace_qt\n    e_true = np.array([e1_true, e2_true])\n    \n    # 2. Compute blended properties and observed ellipticity\n    # Convolved, sheared second moments for neighbor\n    Q_n = (s_n**2 + sigma_psf**2) * I\n    Q_n_prime = A @ Q_n @ A.T\n\n    # Total flux in i-band for shape measurement\n    f_tot_i = f_ti + f_ni\n\n    if f_tot_i == 0.0:\n        # Avoid division by zero, though not expected for these test cases.\n        # If total flux is zero, the object is unobservable.\n        # Biases would be ill-defined. Return NaNs or handle as error.\n        # For this problem, we can assume f_tot_i > 0.\n        pass\n\n    # Blended centroid in i-band\n    x_bar_i = (f_ti * xt + f_ni * xn) / f_tot_i\n\n    # Parallel axis theorem terms (outer products)\n    xt_offset = xt - x_bar_i\n    xn_offset = xn - x_bar_i\n    v_t = np.outer(xt_offset, xt_offset)\n    v_n = np.outer(xn_offset, xn_offset)\n\n    # Blended second-moment tensor in i-band\n    M_i = (f_ti * (Q_t_prime + v_t) + f_ni * (Q_n_prime + v_n)) / f_tot_i\n\n    # Observed ellipticity from blended moments\n    trace_mi = np.trace(M_i)\n    e1_obs = (M_i[0, 0] - M_i[1, 1]) / trace_mi\n    e2_obs = 2 * M_i[0, 1] / trace_mi\n    e_obs = np.array([e1_obs, e2_obs])\n    \n    # 3. Compute shear calibration biases (m, c)\n    e_true_sq_norm = np.dot(e_true, e_true)\n    if e_true_sq_norm == 0.0:\n       # if g1=g2=0, e_true is zero, m is ill-defined.\n       # Problem constraints ensure g1,g2 are not both zero.\n       m = 0.0\n    else:\n       m = np.dot(e_obs, e_true) / e_true_sq_norm - 1.0\n\n    c = e_obs - (1 + m) * e_true\n    c1, c2 = c[0], c[1]\n\n    # 4. Compute photometric redshift bias (delta_z)\n    f_tot_r = f_tr + f_nr\n    if f_tot_i <= 0 or f_tot_r <= 0: # Physical fluxes must be positive\n        # Handle log of non-positive number. Not expected in test cases.\n        delta_z = np.nan\n    else:\n        color = -2.5 * np.log10(f_tot_r / f_tot_i)\n        z_hat = a * color + b\n        delta_z = z_hat - z_t\n\n    # 5. Compute GGL bias (delta_DeltaSigma)\n    if z_hat <= z_l or z_t <= z_l:\n        # Unphysical configuration or division by zero. Not in test cases.\n        delta_DeltaSigma = np.nan\n    else:\n        # Ratio of critical surface density scaling factors\n        sigma_crit_ratio = (z_hat * (z_t - z_l)) / (z_t * (z_hat - z_l))\n        delta_DeltaSigma = (1 + m) * sigma_crit_ratio - 1.0\n        \n    return [m, c1, c2, delta_z, delta_DeltaSigma]\n\nsolve()\n```", "id": "3512765"}]}