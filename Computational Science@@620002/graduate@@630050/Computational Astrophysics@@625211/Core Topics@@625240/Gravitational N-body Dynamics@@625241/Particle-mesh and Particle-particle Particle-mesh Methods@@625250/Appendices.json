{"hands_on_practices": [{"introduction": "The first step in any Particle-Mesh (PM) simulation is to project the discrete particle distribution onto a regular grid to create a continuous density field. This mass assignment is fundamental, as it bridges the Lagrangian particles and the Eulerian mesh. This exercise [@problem_id:3529293] provides concrete practice with the widely used Cloud-In-Cell (CIC) scheme, a method that offers a good compromise between computational simplicity and the suppression of numerical noise.", "problem": "Consider a uniform Cartesian mesh used in the Particle-Mesh (PM) method with grid nodes at positions $(i h, j h, k h)$ for integers $i$, $j$, and $k$, where $h$ is the uniform grid spacing. In the Cloud-In-Cell (CIC) mass assignment scheme, the particle mass is distributed to the mesh nodes using a separable, piecewise-linear shape function that conserves mass and is supported by the $8$ corner nodes of the cell that encloses the particle.\n\nA single particle of unit mass is located at position $\\boldsymbol{x}_{p} = (0.3 h, 0.7 h, 0.1 h)$, which lies inside the elementary cell bounded by the planes $x=0$, $x=h$, $y=0$, $y=h$, $z=0$, and $z=h$. Using the Cloud-In-Cell (CIC) assignment rule, compute the mass fractions deposited to the $8$ neighboring corner nodes of the enclosing cell in the following fixed order:\n$(0,0,0)$, $(h,0,0)$, $(0,h,0)$, $(h,h,0)$, $(0,0,h)$, $(h,0,h)$, $(0,h,h)$, $(h,h,h)$.\n\nExpress each fraction as an exact rational number, and present your final answer as a single row vector. No rounding is required. The fractions are dimensionless.", "solution": "The user wants to solve a particle-mesh problem. The problem is validated first.\n\n### Step 1: Extract Givens\n-   **Mesh Type**: Uniform Cartesian mesh with grid nodes at positions $(i h, j h, k h)$ for integers $i$, $j$, and $k$.\n-   **Grid Spacing**: $h$ is the uniform grid spacing.\n-   **Assignment Scheme**: Cloud-In-Cell (CIC), described as a separable, piecewise-linear shape function that conserves mass and is supported by 8 corner nodes.\n-   **Particle Properties**: A single particle of unit mass, $m_p = 1$.\n-   **Particle Position**: $\\boldsymbol{x}_{p} = (0.3 h, 0.7 h, 0.1 h)$.\n-   **Enclosing Cell**: The cell is bounded by the planes $x=0$, $x=h$, $y=0$, $y=h$, $z=0$, and $z=h$. Its eight corner nodes are at $(ih, jh, kh)$ for $i,j,k \\in \\{0,1\\}$.\n-   **Task**: Compute the mass fractions deposited to the 8 neighboring corner nodes.\n-   **Output Order**: The fractions must be for the nodes in the fixed order: $(0,0,0)$, $(h,0,0)$, $(0,h,0)$, $(h,h,0)$, $(0,0,h)$, $(h,0,h)$, $(0,h,h)$, $(h,h,h)$.\n-   **Output Format**: Each fraction must be an exact rational number, presented in a single row vector.\n\n### Step 2: Validate Using Extracted Givens\n-   **Scientifically Grounded**: The problem describes the Cloud-In-Cell (CIC) scheme, a standard and correct method used in computational astrophysics for N-body simulations. The principles are sound.\n-   **Well-Posed**: The problem is well-posed. The particle's position is clearly defined within a specific cell, and the CIC method provides a unique and stable algorithm for distributing the mass.\n-   **Objective**: The language is precise and unambiguous.\n-   **Completeness**: All necessary information (particle position, mass, cell definition, assignment scheme) is provided.\n-   **Consistency**: There are no internal contradictions.\n\n### Step 3: Verdict and Action\nThe problem is valid. A solution will be provided.\n\n***\n\nThe Cloud-In-Cell (CIC) mass assignment scheme distributes a particle's mass to the $8$ vertices of the grid cell that contains it. This distribution is equivalent to trilinear interpolation. The fraction of mass assigned to each vertex is proportional to the volume of the sub-cuboid that is diagonally opposite to that vertex, formed by planes passing through the particle's position parallel to the cell faces.\n\nA particle of unit mass, $m_p=1$, is located at position $\\boldsymbol{x}_{p} = (x_p, y_p, z_p) = (0.3h, 0.7h, 0.1h)$. The elementary cell containing the particle is defined by the $8$ corner nodes at positions $\\boldsymbol{x}_{ijk} = (ih, jh, kh)$, where $h$ is the grid spacing and $i, j, k \\in \\{0, 1\\}$.\n\nFirst, we define the particle's normalized, dimensionless coordinates within this cell, relative to the node at the origin $(0,0,0)$:\n$$ t_x = \\frac{x_p - 0}{h} = \\frac{0.3h}{h} = 0.3 $$\n$$ t_y = \\frac{y_p - 0}{h} = \\frac{0.7h}{h} = 0.7 $$\n$$ t_z = \\frac{z_p - 0}{h} = \\frac{0.1h}{h} = 0.1 $$\nThe particle is located at the normalized position $(t_x, t_y, t_z) = (0.3, 0.7, 0.1)$ within the unit cube defined by the normalized coordinates.\n\nThe CIC scheme uses a separable assignment function, meaning the total weight for a node is the product of $1$-dimensional linear interpolation weights. For a given dimension, say $x$, the weights assigned to the bounding nodes at $i=0$ and $i=1$ are:\n$$ w_x(0) = 1 - t_x $$\n$$ w_x(1) = t_x $$\nSimilarly for the $y$ and $z$ dimensions:\n$$ w_y(0) = 1 - t_y, \\quad w_y(1) = t_y $$\n$$ w_z(0) = 1 - t_z, \\quad w_z(1) = t_z $$\nThe mass fraction, $f_{ijk}$, assigned to the node at $(ih, jh, kh)$ is given by the product of these $1$-dimensional weights:\n$$ f_{ijk} = w_x(i) \\cdot w_y(j) \\cdot w_z(k) $$\nSince the particle's mass is $m_p=1$, these fractions are the absolute masses deposited on the grid nodes.\n\nUsing the particle's normalized position, we calculate the $1$-dimensional weights:\n$$ w_x(0) = 1 - 0.3 = 0.7 = \\frac{7}{10} \\quad \\text{and} \\quad w_x(1) = 0.3 = \\frac{3}{10} $$\n$$ w_y(0) = 1 - 0.7 = 0.3 = \\frac{3}{10} \\quad \\text{and} \\quad w_y(1) = 0.7 = \\frac{7}{10} $$\n$$ w_z(0) = 1 - 0.1 = 0.9 = \\frac{9}{10} \\quad \\text{and} \\quad w_z(1) = 0.1 = \\frac{1}{10} $$\n\nNow, we compute the mass fraction for each of the $8$ nodes in the specified order.\n\n1.  Node at $(0,0,0)$, corresponding to $(i,j,k)=(0,0,0)$:\n    $f_{000} = w_x(0) \\cdot w_y(0) \\cdot w_z(0) = \\frac{7}{10} \\times \\frac{3}{10} \\times \\frac{9}{10} = \\frac{189}{1000}$\n\n2.  Node at $(h,0,0)$, corresponding to $(i,j,k)=(1,0,0)$:\n    $f_{100} = w_x(1) \\cdot w_y(0) \\cdot w_z(0) = \\frac{3}{10} \\times \\frac{3}{10} \\times \\frac{9}{10} = \\frac{81}{1000}$\n\n3.  Node at $(0,h,0)$, corresponding to $(i,j,k)=(0,1,0)$:\n    $f_{010} = w_x(0) \\cdot w_y(1) \\cdot w_z(0) = \\frac{7}{10} \\times \\frac{7}{10} \\times \\frac{9}{10} = \\frac{441}{1000}$\n\n4.  Node at $(h,h,0)$, corresponding to $(i,j,k)=(1,1,0)$:\n    $f_{110} = w_x(1) \\cdot w_y(1) \\cdot w_z(0) = \\frac{3}{10} \\times \\frac{7}{10} \\times \\frac{9}{10} = \\frac{189}{1000}$\n\n5.  Node at $(0,0,h)$, corresponding to $(i,j,k)=(0,0,1)$:\n    $f_{001} = w_x(0) \\cdot w_y(0) \\cdot w_z(1) = \\frac{7}{10} \\times \\frac{3}{10} \\times \\frac{1}{10} = \\frac{21}{1000}$\n\n6.  Node at $(h,0,h)$, corresponding to $(i,j,k)=(1,0,1)$:\n    $f_{101} = w_x(1) \\cdot w_y(0) \\cdot w_z(1) = \\frac{3}{10} \\times \\frac{3}{10} \\times \\frac{1}{10} = \\frac{9}{1000}$\n\n7.  Node at $(0,h,h)$, corresponding to $(i,j,k)=(0,1,1)$:\n    $f_{011} = w_x(0) \\cdot w_y(1) \\cdot w_z(1) = \\frac{7}{10} \\times \\frac{7}{10} \\times \\frac{1}{10} = \\frac{49}{1000}$\n\n8.  Node at $(h,h,h)$, corresponding to $(i,j,k)=(1,1,1)$:\n    $f_{111} = w_x(1) \\cdot w_y(1) \\cdot w_z(1) = \\frac{3}{10} \\times \\frac{7}{10} \\times \\frac{1}{10} = \\frac{21}{1000}$\n\nAs a consistency check, we verify that the sum of the mass fractions equals $1$, which is a required property of the CIC scheme (mass conservation).\n$$ \\sum_{i,j,k \\in \\{0,1\\}} f_{ijk} = \\frac{1}{1000} (189 + 81 + 441 + 189 + 21 + 9 + 49 + 21) = \\frac{1000}{1000} = 1 $$\nThe sum confirms the calculations are correct. The final answer is the ordered list of these fractions.\nThe resulting row vector of mass fractions is:\n$$ \\begin{pmatrix} \\frac{189}{1000} & \\frac{81}{1000} & \\frac{441}{1000} & \\frac{189}{1000} & \\frac{21}{1000} & \\frac{9}{1000} & \\frac{49}{1000} & \\frac{21}{1000} \\end{pmatrix} $$", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{189}{1000} & \\frac{81}{1000} & \\frac{441}{1000} & \\frac{189}{1000} & \\frac{21}{1000} & \\frac{9}{1000} & \\frac{49}{1000} & \\frac{21}{1000}\n\\end{pmatrix}\n}\n$$", "id": "3529293"}, {"introduction": "Once the gravitational potential is computed on the mesh, the next crucial step is to interpolate the force back to the particle positions and advance their state in time. This exercise [@problem_id:3529327] simulates this core loop of a PM code by integrating a particle's orbit in a static, pre-computed PM potential field. By using the time-symmetric leapfrog integrator and monitoring energy conservation, you will gain hands-on experience with the dynamics and numerical stability of PM schemes.", "problem": "Consider a single test particle moving in a fixed spherically symmetric gravitational potential that corresponds to a Plummer sphere. Use a Particle-Mesh (PM) discretization of this potential on a uniform Cartesian grid in a cubic domain, and integrate the particle’s motion with a time-symmetric leapfrog scheme for exactly one orbital period of a circular orbit. Estimate the secular energy error as a function of the time step size $\\Delta t$. All quantities are to be expressed in dimensionless code units, where the gravitational constant $G$ equals $1$.\n\nThe Plummer sphere gravitational potential is defined by the well-tested formula\n$$\n\\Phi(r) = -\\frac{G M}{\\sqrt{r^2 + a^2}},\n$$\nwhere $r$ is the radial distance from the origin, $M$ is the total mass, and $a$ is the softening length. The gravitational acceleration is given by Newton’s second law and the gradient of the potential,\n$$\n\\mathbf{a}(\\mathbf{x}) = -\\nabla \\Phi(\\mathbf{x}).\n$$\n\nYou must construct a PM representation of the static potential by sampling $\\Phi(\\mathbf{x})$ on a uniform mesh and computing $\\nabla \\Phi(\\mathbf{x})$ on the mesh using finite differences. Use trilinear interpolation to evaluate the potential and its gradient at the particle’s position. Then integrate the particle’s orbit using a leapfrog time integrator (kick-drift-kick) that respects Newton’s second law.\n\nAssume the following fixed parameters in dimensionless code units:\n- $G = 1$, $M = 1$, $a = 0.1$.\n- The cubic domain is $[-L/2, L/2]^3$ with $L = 4$.\n- Use a uniform mesh with $N = 64$ nodes per dimension.\n- Initialize the particle at $\\mathbf{x}_0 = (r_0, 0, 0)$ with $r_0 = 1$. Choose the initial velocity $\\mathbf{v}_0 = (0, v_{\\mathrm{circ}}, 0)$, where $v_{\\mathrm{circ}}$ is the circular velocity computed by equating the centripetal acceleration to the gravitational acceleration in the Plummer potential:\n$$\n\\frac{v_{\\mathrm{circ}}^2}{r_0} = \\frac{G M r_0}{(r_0^2 + a^2)^{3/2}}.\n$$\n\nUse the circular orbit period\n$$\nT = \\frac{2\\pi r_0}{v_{\\mathrm{circ}}}\n$$\nwith angles measured in radians.\n\nDefine the total mechanical energy at position $\\mathbf{x}$ and velocity $\\mathbf{v}$ by\n$$\nE = \\frac{1}{2}\\|\\mathbf{v}\\|^2 + \\Phi(\\mathbf{x}),\n$$\nwhere $\\Phi(\\mathbf{x})$ is obtained via trilinear interpolation of the PM potential on the mesh, and $\\|\\mathbf{v}\\|$ is the Euclidean norm. The secular energy error after integrating for one orbital period is the absolute fractional difference\n$$\n\\epsilon = \\left|\\frac{E(T) - E(0)}{E(0)}\\right|.\n$$\nReport $\\epsilon$ as a decimal number (dimensionless).\n\nImplement the following:\n1. Construct the PM potential $\\Phi$ on the mesh and compute its gradient $\\nabla \\Phi$ at mesh nodes using central differences in the interior and one-sided differences at the boundaries.\n2. For a given $\\Delta t$, integrate for exactly one period $T$ using the leapfrog method and trilinear interpolation to compute the acceleration at intermediate positions.\n3. Compute and return the secular energy error $\\epsilon$ using the PM-interpolated potential for both $E(0)$ and $E(T)$.\n\nTest Suite:\nFor the same setup above, evaluate the secular energy error $\\epsilon$ for the following time steps, each chosen to exactly divide the period:\n- $\\Delta t = T/200$,\n- $\\Delta t = T/100$,\n- $\\Delta t = T/50$,\n- $\\Delta t = T/20$,\n- $\\Delta t = T/8$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4,result5]\"). Each result is the value of $\\epsilon$ for the corresponding $\\Delta t$ in the order listed above. All outputs are dimensionless decimals.", "solution": "The user has provided a problem from computational astrophysics that requires simulating a particle's orbit and evaluating the energy conservation of a Particle-Mesh (PM) scheme. The problem is valid as it is scientifically grounded, well-posed, and objective. It provides a complete and consistent set of parameters, initial conditions, and numerical methods for a standard computational experiment.\n\nThe solution proceeds as follows:\n\n1.  **System Definition and Initial Conditions:**\n    The problem describes a test particle under the influence of a static gravitational potential generated by a Plummer sphere, with potential $\\Phi(r) = -G M / \\sqrt{r^2 + a^2}$. The parameters are given in dimensionless code units as $G=1$, $M=1$, and the softening length $a=0.1$. The particle is initialized in a circular orbit in the $x-y$ plane at a radius $r_0=1$. The circular velocity, $v_{\\mathrm{circ}}$, is determined by balancing the gravitational force with the centripetal force:\n    $$\n    \\frac{v_{\\mathrm{circ}}^2}{r_0} = |\\mathbf{a}(r_0)| = \\left|-\\frac{d\\Phi}{dr}\\right|_{r=r_0} = \\frac{G M r_0}{(r_0^2 + a^2)^{3/2}}\n    $$\n    This gives an initial position $\\mathbf{x}_0 = (r_0, 0, 0)$ and velocity $\\mathbf{v}_0 = (0, v_{\\mathrm{circ}}, 0)$. The orbital period, which is the total integration time, is $T = 2\\pi r_0 / v_{\\mathrm{circ}}$.\n\n2.  **Particle-Mesh (PM) Discretization:**\n    The core of the PM method is to represent the continuous gravitational field on a discrete grid. The simulation is performed in a cubic domain of side length $L=4$, centered at the origin.\n    -   **Grid Generation:** A uniform Cartesian mesh with $N=64$ nodes per dimension is constructed. The grid spacing is $h = L / (N-1)$.\n    -   **Potential Sampling:** The analytical Plummer potential $\\Phi(\\mathbf{x})$ is evaluated at the coordinates of each of the $N \\times N \\times N$ grid nodes and stored in a 3D array, $\\Phi_{\\text{grid}}$.\n    -   **Force Field Calculation:** The gravitational acceleration field, $\\mathbf{a}(\\mathbf{x}) = -\\nabla\\Phi(\\mathbf{x})$, is computed on the grid by taking the numerical gradient of the potential grid, $\\Phi_{\\text{grid}}$. The gradient is computed using second-order central differences for interior nodes and first-order one-sided differences at the boundaries, as specified. This yields three 3D arrays, $\\mathbf{a}_{x, \\text{grid}}$, $\\mathbf{a}_{y, \\text{grid}}$, and $\\mathbf{a}_{z, \\text{grid}}$, representing the components of the acceleration field at each grid node.\n\n3.  **Particle Integration:**\n    To integrate the particle's equations of motion, $\\ddot{\\mathbf{x}} = \\mathbf{a}(\\mathbf{x})$, we require the acceleration at the particle's position, which generally does not coincide with a grid node.\n    -   **Field Interpolation:** Trilinear interpolation is used to evaluate both the potential $\\Phi$ and the acceleration components $\\mathbf{a}$ at an arbitrary particle position $\\mathbf{x}$. This is achieved by finding the grid cell containing the particle and performing a weighted average of the values at the cell's 8 corners. The weights are determined by the particle's fractional position within the cell.\n    -   **Leapfrog Integration (Kick-Drift-Kick):** The particle's state $(\\mathbf{x}(t), \\mathbf{v}(t))$ is advanced in time using a time-symmetric leapfrog integrator. The specific variant used is the \"velocity Verlet\" algorithm, which is equivalent to a Kick-Drift-Kick (KDK) scheme. For a single timestep $\\Delta t$, the update from state $(\\mathbf{x}_n, \\mathbf{v}_n)$ to $(\\mathbf{x}_{n+1}, \\mathbf{v}_{n+1})$ is:\n        1.  **Kick:** $\\mathbf{v}_{n+1/2} = \\mathbf{v}_n + \\mathbf{a}(\\mathbf{x}_n) \\frac{\\Delta t}{2}$\n        2.  **Drift:** $\\mathbf{x}_{n+1} = \\mathbf{x}_n + \\mathbf{v}_{n+1/2} \\Delta t$\n        3.  **Kick:** $\\mathbf{v}_{n+1} = \\mathbf{v}_{n+1/2} + \\mathbf{a}(\\mathbf{x}_{n+1}) \\frac{\\Delta t}{2}$\n    This scheme is second-order accurate in $\\Delta t$ and is symplectic, which leads to excellent long-term energy conservation properties (i.e., no secular energy drift).\n\n4.  **Energy Error Calculation:**\n    The total energy of the particle is defined using the PM-interpolated potential, not the analytical one, to consistently assess the error of the numerical method itself. The energy at a given state $(\\mathbf{x}, \\mathbf{v})$ is:\n    $$\n    E = \\frac{1}{2}\\|\\mathbf{v}\\|^2 + \\Phi_{\\text{interp}}(\\mathbf{x})\n    $$\n    The initial energy $E(0)$ is computed using the initial state $(\\mathbf{x}_0, \\mathbf{v}_0)$. The final energy $E(T)$ is computed after integrating for one full period $T$. The secular energy error $\\epsilon$ is the absolute fractional difference:\n    $$\n    \\epsilon = \\left|\\frac{E(T) - E(0)}{E(0)}\\right|\n    $$\n    This calculation is repeated for several time step sizes $\\Delta t$, which are chosen as integer fractions of the period $T$. Since the leapfrog integrator has a local truncation error of order $\\mathcal{O}(\\Delta t^3)$, the global energy error over a fixed interval is expected to scale as $\\epsilon \\propto \\Delta t^2$.", "answer": "```python\nimport numpy as np\nfrom scipy.interpolate import RegularGridInterpolator\n\ndef solve():\n    \"\"\"\n    Solves the particle-mesh orbit integration problem.\n    \"\"\"\n    # 1. System Parameters and Initial Conditions\n    G = 1.0\n    M = 1.0\n    a = 0.1\n    L = 4.0\n    N = 64\n    r0 = 1.0\n\n    # Test cases: time step as a fraction of the period T\n    T_divisors = [200, 100, 50, 20, 8]\n\n    # Derived constants and initial conditions\n    h = L / (N - 1)\n    grid_coords = np.linspace(-L / 2, L / 2, N)\n\n    # Circular velocity for a Plummer potential\n    v_circ_sq = (G * M * r0**2) / (r0**2 + a**2)**1.5\n    v_circ = np.sqrt(v_circ_sq)\n    \n    # Orbital period\n    T = 2 * np.pi * r0 / v_circ\n\n    # Initial state vectors\n    x0 = np.array([r0, 0.0, 0.0])\n    v0 = np.array([0.0, v_circ, 0.0])\n\n    # 2. PM Grid Construction\n    # Create grid coordinate arrays\n    X, Y, Z = np.meshgrid(grid_coords, grid_coords, grid_coords, indexing='ij')\n\n    # Compute potential on the grid\n    R_sq = X**2 + Y**2 + Z**2\n    Phi_grid = -G * M / np.sqrt(R_sq + a**2)\n\n    # Compute acceleration field using numerical gradient of the potential field\n    # np.gradient uses 2nd-order central differences for the interior\n    # and 1st-order one-sided differences at boundaries, as required.\n    # The gradient is returned as a list of arrays [d/dx, d/dy, d/dz]\n    # because meshgrid's indexing was 'ij'.\n    grad_Phi = np.gradient(Phi_grid, h)\n    Acc_x_grid = -grad_Phi[0]\n    Acc_y_grid = -grad_Phi[1]\n    Acc_z_grid = -grad_Phi[2]\n\n    # 3. Create Interpolators\n    # Stack all fields for efficient multi-value interpolation\n    values_to_interpolate = np.stack(\n        [Phi_grid, Acc_x_grid, Acc_y_grid, Acc_z_grid], axis=-1\n    )\n    \n    # The interpolator function will be used to get potential and acceleration\n    # at any off-grid particle position. 'linear' corresponds to trilinear.\n    interpolator = RegularGridInterpolator(\n        (grid_coords, grid_coords, grid_coords),\n        values_to_interpolate,\n        method='linear',\n        bounds_error=True  # Ensure particle stays within the simulation box\n    )\n\n    def get_potential_and_accel(pos):\n        # The interpolator expects a (n_points, n_dims) array.\n        # For a single point, we reshape and then squeeze the output.\n        interp_values = interpolator(pos.reshape(1, -1))\n        return interp_values[0] # Returns [phi, ax, ay, az]\n\n    # Calculate initial energy E(0) using the interpolated potential\n    phi0, _, _, _ = get_potential_and_accel(x0)\n    E0 = 0.5 * np.dot(v0, v0) + phi0\n\n    results = []\n    \n    # 4. Integration and Error Calculation Loop\n    for divisor in T_divisors:\n        dt = T / divisor\n        N_steps = int(divisor)\n\n        # Reset particle state for each test run\n        x = np.copy(x0)\n        v = np.copy(v0)\n\n        # KDK Leapfrog / Velocity Verlet Integrator\n        # Get initial acceleration\n        _, ax, ay, az = get_potential_and_accel(x)\n        a_current = np.array([ax, ay, az])\n\n        for _ in range(N_steps):\n            # Kick (half step)\n            v_half_step = v + a_current * dt / 2.0\n            # Drift (full step)\n            x = x + v_half_step * dt\n            # Update acceleration at the new position\n            _, ax_new, ay_new, az_new = get_potential_and_accel(x)\n            a_new = np.array([ax_new, ay_new, az_new])\n            # Kick (second half step)\n            v = v_half_step + a_new * dt / 2.0\n            # Store the new acceleration for the next iteration\n            a_current = a_new\n        \n        # At this point, x and v are the final state at time T\n        x_final = x\n        v_final = v\n\n        # Calculate final energy E(T)\n        phi_final, _, _, _ = get_potential_and_accel(x_final)\n        E_final = 0.5 * np.dot(v_final, v_final) + phi_final\n\n        # Calculate and store the secular energy error\n        error = np.abs((E_final - E0) / E0)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3529327"}, {"introduction": "The process of discretizing a field onto a grid inevitably introduces numerical artifacts, with aliasing being a primary concern in Fourier-based PM solvers. Understanding and correcting for these artifacts is essential for extracting accurate physical information, such as the matter power spectrum $P(k)$, from simulations. This advanced exercise [@problem_id:3529375] guides you through a controlled experiment to model the effects of mass assignment on the power spectrum and implement a deconvolution procedure to recover the true underlying signal.", "problem": "You are to implement a computational experiment grounded in Particle-Mesh (PM) and Particle-Particle Particle-Mesh (P³M) methods to analyze and correct aliasing in Fast Fourier Transform (FFT) power spectrum estimation due to mass assignment. Consider a three-dimensional periodic box of side length $L$ discretized into a uniform mesh with $N$ cells per dimension and grid spacing $dx$. The experiment must use a controlled isotropic density field with a known input power spectrum $P(k)$ and simulate the effect of mass assignment on estimating $P(k)$ from the discretized field. You must then design a deconvolution to restore the power spectrum to within a target fractional error.\n\nThe starting point is the definition of the isotropic input power spectrum $P(k)$, given by $P(k) = A \\, k^n \\, \\exp\\!\\left[-\\left( \\frac{k}{k_0} \\right)^2 \\right]$, where $A$, $n$, and $k_0$ are constants, and $k \\equiv |\\boldsymbol{k}|$ is the magnitude of the wave vector. The mesh spacing is $dx$, the fundamental wavenumber is $k_f = \\frac{2 \\pi}{L}$, the sampling wavenumber is $k_s = \\frac{2 \\pi}{dx}$, and the Nyquist wavenumber is $k_N = \\frac{\\pi}{dx}$. For concreteness and to ensure computational reproducibility, set $dx = 1$ (dimensionless units), so $L = N$, $k_f = \\frac{2 \\pi}{N}$, $k_s = 2 \\pi$, and $k_N = \\pi$. Use $A=1$ and $n=1$ and set $k_0 = \\alpha \\, k_N$ with $\\alpha = 0.9$. All physical quantities are dimensionless and angles are in radians.\n\nWhen estimating the power spectrum with mass assignment onto the mesh, you must model the effect of assignment kernels commonly used in PM and P³M codes:\n- Nearest Grid Point (NGP),\n- Cloud-In-Cell (CIC),\n- Triangular-Shaped Cloud (TSC).\n\nTreat these as uniform B-spline mass assignment kernels of order $p$, where $p=1$ for NGP, $p=2$ for CIC, and $p=3$ for TSC. The Fourier-space magnitude of the assignment window is separable in Cartesian components and is given by $W(\\boldsymbol{k}) = \\prod_{i \\in \\{x,y,z\\}} \\left[ \\mathrm{sinc}\\!\\left( \\frac{k_i dx}{2} \\right) \\right]^p$, where $\\mathrm{sinc}(x) \\equiv \\frac{\\sin x}{x}$ and $k_i$ are the Cartesian components of $\\boldsymbol{k}$. The observed, discretely sampled, mass-assigned estimate of the power spectrum $P_{\\mathrm{meas}}(\\boldsymbol{k})$ on the principal Fourier domain is affected by sampling aliasing. It can be modeled as the sum over integer alias images due to sampling: contributions at $\\boldsymbol{k} + \\boldsymbol{g}$ where $\\boldsymbol{g}$ has components $g_i = m_i \\, k_s$ with $m_i \\in \\mathbb{Z}$. You must approximate the alias sum using a finite stencil $m_i \\in \\{-1, 0, +1\\}$, which captures the dominant images for a sufficiently smooth $P(k)$.\n\nYour task is to:\n1. Construct the isotropic input $P(k)$ on the principal Fourier domain of the mesh.\n2. Compute the expected aliased, mass-assigned power $P_{\\mathrm{meas}}(\\boldsymbol{k})$ by summing $P\\!\\left(|\\boldsymbol{k}+\\boldsymbol{g}|\\right) \\, \\left| W\\!\\left(\\boldsymbol{k}+\\boldsymbol{g}\\right) \\right|^2$ over all $\\boldsymbol{g}$ with $m_i \\in \\{-1,0,+1\\}$ for each assignment kernel.\n3. Design a deconvolution estimator $P_{\\mathrm{corr}}(\\boldsymbol{k})$ that removes the assignment window and subtracts the alias contributions corresponding to $\\boldsymbol{g} \\neq \\boldsymbol{0}$, using only quantities specified above, to recover $P(k)$ to within a specified target fractional error. Evaluate the fractional error $\\Delta P / P$ on radial shells by binning in $k = |\\boldsymbol{k}|$ from $k_{\\min} = k_f$ up to $k_{\\max} = \\beta \\, k_N$ with $\\beta = 0.7$, excluding the zero mode. For each radial bin, compute the mean of $P_{\\mathrm{corr}}$ and the mean of $P_{\\mathrm{true}}$, then the fractional error in that bin as $\\left| P_{\\mathrm{corr}} - P_{\\mathrm{true}} \\right| / P_{\\mathrm{true}}$. Report the maximum bin-wise fractional error as the performance metric for the test case.\n\nYour program must implement the above logic exactly and evaluate the following test suite. For each test case, the output must be a boolean indicating whether the maximum bin-wise fractional error is less than or equal to the specified target threshold. Use the power spectrum parameters $A=1$, $n=1$, and $k_0 = 0.9 \\, k_N$ for all tests, and $dx = 1$ so that $L=N$:\n- Test case $1$: $N=64$, assignment kernel $=$ CIC, target threshold for $\\Delta P / P$ $=$ $0.02$.\n- Test case $2$: $N=64$, assignment kernel $=$ NGP, target threshold for $\\Delta P / P$ $=$ $0.05$.\n- Test case $3$: $N=48$, assignment kernel $=$ TSC, target threshold for $\\Delta P / P$ $=$ $0.01$.\n- Test case $4$: $N=32$, assignment kernel $=$ NGP, target threshold for $\\Delta P / P$ $=$ $0.02$.\n\nAll quantities are dimensionless. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result_1,result_2,result_3,result_4]\"), where each $\\mathrm{result}_i$ is the boolean pass/fail of test case $i$.", "solution": "The problem statement has been validated and is deemed to be scientifically grounded, well-posed, and internally consistent. It presents a clear, formalizable computational experiment within the domain of computational astrophysics, specifically concerning the numerical artifacts in Particle-Mesh (PM) and Particle-Particle Particle-Mesh (P³M) methods. All necessary parameters and definitions are provided. We may therefore proceed with the solution.\n\nThe core of this problem is to model the effects of mass assignment and sampling on the estimation of a cosmological power spectrum, and then to design and verify a correction scheme. The process involves several distinct steps: defining the true underlying power spectrum, modeling the \"measured\" spectrum as affected by numerical artifacts, applying a correction procedure, and quantifying the error of the corrected result.\n\nFirst, we define the theoretical quantities. The true, underlying isotropic power spectrum is given by\n$$\nP(k) = A \\, k^n \\, \\exp\\!\\left[-\\left( \\frac{k}{k_0} \\right)^2 \\right]\n$$\nwhere $k = |\\boldsymbol{k}|$ is the magnitude of the wavevector $\\boldsymbol{k}$. The problem specifies the dimensionless parameters $A=1$, $n=1$, and $dx=1$. The last condition implies a box size of $L=N$ and wavenumbers $k_f = \\frac{2\\pi}{N}$ (fundamental), $k_s = 2\\pi$ (sampling), and $k_N = \\pi$ (Nyquist). The parameter $k_0$ is set to $k_0 = 0.9 \\, k_N = 0.9\\pi$.\n\nThe mass assignment process, which deposits particle data onto the grid, acts as a convolution in real space, which is equivalent to a multiplication by a window function $W(\\boldsymbol{k})$ in Fourier space. For the specified B-spline kernels of order $p$ (where $p=1$ for NGP, $p=2$ for CIC, and $p=3$ for TSC), the window function is\n$$\nW(\\boldsymbol{k}) = \\prod_{i \\in \\{x,y,z\\}} \\left[ \\mathrm{sinc}\\!\\left( \\frac{k_i dx}{2} \\right) \\right]^p\n$$\nwhere $\\mathrm{sinc}(x) \\equiv \\frac{\\sin x}{x}$. With $dx=1$, this simplifies to $W(\\boldsymbol{k}) = \\prod_{i \\in \\{x,y,z\\}} \\left[ \\mathrm{sinc}\\!\\left( \\frac{k_i}{2} \\right) \\right]^p$.\n\nThe process of sampling onto a discrete grid introduces aliasing. The power at a given wavevector $\\boldsymbol{k}$ in the principal Fourier domain ($k_i \\in [-\\pi, \\pi)$) gets contaminated by power from higher-frequency modes at $\\boldsymbol{k}+\\boldsymbol{g}$, where $\\boldsymbol{g}$ are vectors to reciprocal lattice points, with components $g_i = m_i k_s = 2\\pi m_i$ for integers $m_i$. The problem asks us to model the measured power spectrum, $P_{\\mathrm{meas}}(\\boldsymbol{k})$, by approximating the infinite sum over all aliases with a finite sum over a $3 \\times 3 \\times 3$ stencil where $m_i \\in \\{-1, 0, +1\\}$. Thus, the model for the measured spectrum is:\n$$\nP_{\\mathrm{meas}}(\\boldsymbol{k}) = \\sum_{m_x, m_y, m_z \\in \\{-1, 0, 1\\}} P\\big(|\\boldsymbol{k} + \\boldsymbol{g}_{\\boldsymbol{m}}|\\big) \\, \\left| W(\\boldsymbol{k} + \\boldsymbol{g}_{\\boldsymbol{m}}) \\right|^2\n$$\nwhere $\\boldsymbol{g}_{\\boldsymbol{m}} = (2\\pi m_x, 2\\pi m_y, 2\\pi m_z)$. This sum explicitly includes the true power at $\\boldsymbol{k}$ (the $\\boldsymbol{m}=(0,0,0)$ term) and the contributions from its $26$ nearest alias images.\n\nThe next task is to design a deconvolution estimator, $P_{\\mathrm{corr}}(\\boldsymbol{k})$, that \"removes the assignment window and subtracts the alias contributions\". Based on our model for $P_{\\mathrm{meas}}(\\boldsymbol{k})$, we can separate the desired term from the alias terms:\n$$\nP_{\\mathrm{meas}}(\\boldsymbol{k}) = P(|\\boldsymbol{k}|) |W(\\boldsymbol{k})|^2 + \\sum_{\\boldsymbol{m} \\in \\{-1,0,1\\}^3, \\boldsymbol{m} \\neq \\boldsymbol{0}} P\\big(|\\boldsymbol{k} + \\boldsymbol{g}_{\\boldsymbol{m}}|\\big) \\, \\left| W(\\boldsymbol{k} + \\boldsymbol{g}_{\\boldsymbol{m}}) \\right|^2\n$$\nThe second term on the right-hand side represents the alias contributions, which we will denote as $C(\\boldsymbol{k})$. The deconvolution procedure must first subtract this estimated alias power and then divide by the window function's effect.\n$$\nP_{\\mathrm{corr}}(\\boldsymbol{k}) = \\frac{P_{\\mathrm{meas}}(\\boldsymbol{k}) - C(\\boldsymbol{k})}{|W(\\boldsymbol{k})|^2}\n$$\nSince the problem is a controlled numerical experiment where we have access to the analytical form of $P(k)$ and $W(\\boldsymbol{k})$, the alias correction term $C(\\boldsymbol{k})$ can be calculated exactly according to the model:\n$$\nC(\\boldsymbol{k}) = \\sum_{\\boldsymbol{m} \\in \\{-1,0,1\\}^3, \\boldsymbol{m} \\neq \\boldsymbol{0}} P\\big(|\\boldsymbol{k} + \\boldsymbol{g}_{\\boldsymbol{m}}|\\big) \\, \\left| W(\\boldsymbol{k} + \\boldsymbol{g}_{\\boldsymbol{m}}) \\right|^2\n$$\nSubstituting the expressions for $P_{\\mathrm{meas}}(\\boldsymbol{k})$ and $C(\\boldsymbol{k})$ into the equation for $P_{\\mathrm{corr}}(\\boldsymbol{k})$ yields:\n$$\nP_{\\mathrm{corr}}(\\boldsymbol{k}) = \\frac{\\left( P(|\\boldsymbol{k}|) |W(\\boldsymbol{k})|^2 + C(\\boldsymbol{k}) \\right) - C(\\boldsymbol{k})}{|W(\\boldsymbol{k})|^2} = \\frac{P(|\\boldsymbol{k}|) |W(\\boldsymbol{k})|^2}{|W(\\boldsymbol{k})|^2} = P(|\\boldsymbol{k}|)\n$$\nThis demonstrates that, by construction, the corrected power spectrum at each grid point, $P_{\\mathrm{corr}}(\\boldsymbol{k})$, is exactly equal to the true power spectrum, $P(|\\boldsymbol{k}|)$, provided the calculations are performed with sufficient numerical precision.\n\nFinally, we evaluate the performance by computing the fractional error. The evaluation is done in radial bins of $k = |\\boldsymbol{k}|$ from $k_{\\min} = k_f$ to $k_{\\max} = 0.7 k_N$. For each bin, we compute the mean of the corrected power, $\\langle P_{\\mathrm{corr}} \\rangle$, and the mean of the true power, $\\langle P_{\\mathrm{true}} \\rangle$, where $P_{\\mathrm{true}}(\\boldsymbol{k}) = P(|\\boldsymbol{k}|)$. Since $P_{\\mathrm{corr}}(\\boldsymbol{k}) = P_{\\mathrm{true}}(\\boldsymbol{k})$ at every point $\\boldsymbol{k}$, their means over any bin must also be identical. The fractional error, $\\left| \\langle P_{\\mathrm{corr}} \\rangle - \\langle P_{\\mathrm{true}} \\rangle \\right| / \\langle P_{\\mathrm{true}} \\rangle$, will therefore be zero, up to floating-point arithmetic errors. As the specified error thresholds are non-zero (ranging from $0.01$ to $0.05$), the logical conclusion is that all test cases should pass, as numerical precision errors in standard double-precision arithmetic will be many orders of magnitude smaller.\n\nThe implementation will therefore be a careful execution of these steps:\n1.  For each test case, set up the $N \\times N \\times N$ Fourier-space grid of wavevectors $\\boldsymbol{k}$.\n2.  Compute the \"measured\" power spectrum $P_{\\mathrm{meas}}(\\boldsymbol{k})$ by summing the $27$ alias terms for each point on the grid.\n3.  Compute the correction term $C(\\boldsymbol{k})$ by summing the $26$ off-center alias terms.\n4.  Calculate the corrected spectrum $P_{\\mathrm{corr}}(\\boldsymbol{k}) = (P_{\\mathrm{meas}}(\\boldsymbol{k}) - C(\\boldsymbol{k})) / |W(\\boldsymbol{k})|^2$.\n5.  Bin $P_{\\mathrm{corr}}(\\boldsymbol{k})$ and the true power $P(|\\boldsymbol{k}|)$ radially and compute the maximum fractional error between their bin means.\n6.  Compare the maximum error against the given threshold to determine the boolean result.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n\n    # Global parameters from the problem statement\n    A_PARAM = 1.0\n    N_POWER_PARAM = 1.0\n    ALPHA_PARAM = 0.9\n    BETA_PARAM = 0.7\n    DX_PARAM = 1.0\n\n    # Mapping of kernel names to their B-spline order p\n    KERNEL_P_MAP = {\n        'NGP': 1,\n        'CIC': 2,\n        'TSC': 3,\n    }\n\n    def my_sinc(x):\n        \"\"\"\n        Implements sinc(x) = sin(x)/x, using the numerically stable numpy.sinc.\n        numpy.sinc(y) = sin(pi*y)/(pi*y), so with y = x/pi, we get sin(x)/x.\n        \"\"\"\n        return np.sinc(x / np.pi)\n\n    def true_power_spectrum(k, A, n, k0):\n        \"\"\"\n        Calculates the true isotropic power spectrum P(k) = A * k^n * exp(-(k/k0)^2).\n        \"\"\"\n        # The form is safe for k=0 when n>0. Add a small epsilon for robustness.\n        k_safe = np.maximum(k, 1e-30)\n        return A * np.power(k_safe, n) * np.exp(-(k / k0)**2)\n\n    def window_function_sq(kx, ky, kz, p, dx):\n        \"\"\"\n        Calculates the squared magnitude of the mass assignment window function |W(k)|^2.\n        \"\"\"\n        sinc_kx_arg = kx * dx / 2.0\n        sinc_ky_arg = ky * dx / 2.0\n        sinc_kz_arg = kz * dx / 2.0\n        \n        W_val = (my_sinc(sinc_kx_arg) * my_sinc(sinc_ky_arg) * my_sinc(sinc_kz_arg))**p\n        return W_val**2\n\n    def run_simulation(N, kernel, threshold):\n        \"\"\"\n        Performs the full simulation and validation for a single test case.\n        \"\"\"\n        p = KERNEL_P_MAP[kernel]\n        L = N * DX_PARAM\n\n        # Wavenumber setup\n        k_s = 2.0 * np.pi / DX_PARAM\n        k_N = np.pi / DX_PARAM\n        k_f = 2.0 * np.pi / L\n        k0 = ALPHA_PARAM * k_N\n\n        # Generate 3D k-space grid\n        k_coords_1d = 2 * np.pi * np.fft.fftfreq(N, d=DX_PARAM)\n        kx, ky, kz = np.meshgrid(k_coords_1d, k_coords_1d, k_coords_1d, indexing='ij')\n\n        # Model P_meas(k) by summing over the 3x3x3 alias stencil\n        P_meas = np.zeros((N, N, N), dtype=np.float64)\n        C_alias = np.zeros((N, N, N), dtype=np.float64)\n        alias_stencil_m = [-1, 0, 1]\n\n        for mx in alias_stencil_m:\n            for my in alias_stencil_m:\n                for mz in alias_stencil_m:\n                    g_vec = np.array([mx * k_s, my * k_s, mz * k_s])\n                    \n                    k_prime_x, k_prime_y, k_prime_z = kx + g_vec[0], ky + g_vec[1], kz + g_vec[2]\n                    k_prime_mag = np.sqrt(k_prime_x**2 + k_prime_y**2 + k_prime_z**2)\n                    \n                    p_true_aliased = true_power_spectrum(k_prime_mag, A_PARAM, N_POWER_PARAM, k0)\n                    w_sq_aliased = window_function_sq(k_prime_x, k_prime_y, k_prime_z, p, DX_PARAM)\n                    \n                    alias_term = p_true_aliased * w_sq_aliased\n                    P_meas += alias_term\n                    \n                    if not (mx == 0 and my == 0 and mz == 0):\n                        C_alias += alias_term\n        \n        # Compute the corrected power spectrum P_corr(k)\n        W_sq_k = window_function_sq(kx, ky, kz, p, DX_PARAM)\n        P_corr = (P_meas - C_alias) / (W_sq_k + 1e-40) # Epsilon for safety\n\n        # Evaluate fractional error in radial bins\n        k_mag = np.sqrt(kx**2 + ky**2 + kz**2)\n        P_grid_true = true_power_spectrum(k_mag, A_PARAM, N_POWER_PARAM, k0)\n\n        k_min_bin = k_f\n        k_max_bin = BETA_PARAM * k_N\n        \n        num_bins = 50 # A reasonable number of bins\n        bins = np.linspace(k_min_bin, k_max_bin, num_bins + 1)\n        \n        # Flatten arrays and exclude k=0 mode\n        k_mag_flat = k_mag.flatten()\n        nonzero_mask = k_mag_flat > 1e-9\n        \n        P_corr_flat = P_corr.flatten()[nonzero_mask]\n        P_grid_true_flat = P_grid_true.flatten()[nonzero_mask]\n        k_mag_flat_nonzero = k_mag_flat[nonzero_mask]\n\n        bin_indices = np.digitize(k_mag_flat_nonzero, bins)\n        \n        max_frac_error = 0.0\n        for i in range(1, len(bins)):\n            in_bin_mask = (bin_indices == i)\n            if not np.any(in_bin_mask):\n                continue\n                \n            mean_P_corr = np.mean(P_corr_flat[in_bin_mask])\n            mean_P_true = np.mean(P_grid_true_flat[in_bin_mask])\n            \n            if mean_P_true > 1e-30:\n                frac_error = np.abs(mean_P_corr - mean_P_true) / mean_P_true\n                if frac_error > max_frac_error:\n                    max_frac_error = frac_error\n                    \n        return max_frac_error <= threshold\n\n    test_cases = [\n        (64, 'CIC', 0.02),\n        (64, 'NGP', 0.05),\n        (48, 'TSC', 0.01),\n        (32, 'NGP', 0.02),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, kernel, threshold = case\n        result = run_simulation(N, kernel, threshold)\n        results.append(str(result).lower())\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3529375"}]}