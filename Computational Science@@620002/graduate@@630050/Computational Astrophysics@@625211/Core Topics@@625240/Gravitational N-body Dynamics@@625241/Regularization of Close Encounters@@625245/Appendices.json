{"hands_on_practices": [{"introduction": "Before implementing complex schemes, it's vital to understand why regularization works at a fundamental level. This first practice invites you to dissect the mathematical machinery of the Sundman time transformation, $ds/dt = r^{\\alpha}$. By deriving the equations of motion in the new time coordinate $s$ and analyzing the local truncation error, you will directly see how the choice of the exponent $\\alpha$ can either tame or worsen the numerical difficulties near a gravitational singularity [@problem_id:3532374]. This exercise provides a foundational understanding of how algorithmic regularization modifies the structure of the equations we are trying to solve.", "problem": "Consider the Newtonian two-body problem with a point mass moving under a fixed central gravitational potential with parameter $\\mu$ (gravitational parameter). Focus on purely radial motion (zero angular momentum) along a line, so that the physical equations of motion in physical time $t$ reduce to the ordinary differential equations (ODE) $dr/dt = v$ and $dv/dt = -\\mu/r^{2}$, where $r > 0$ is the radial distance and $v$ is the radial velocity. Introduce a Sundman-type time transformation for algorithmic regularization, defined by $ds/dt = r^{\\alpha}$ with $\\alpha \\in \\{-1, 0, 1, 2\\}$, and consider the transformed system in the fictitious time $s$.\n\nYour task is to study, from first principles and by derivation, how the leading-order local truncation error of a first-order forward Euler step in $s$ scales with $r$ near the close-encounter limit $r \\to 0$ under different choices of $\\alpha$. You must base your reasoning on the fundamental Newtonian ODEs, the definition of the Sundman transformation, and the definition of the local truncation error as the leading nonzero Taylor remainder term of the one-step forward Euler method applied to the $s$-time system.\n\nRequirements and constraints:\n- Start from the fundamental Newtonian ODEs and the definition $ds/dt = r^{\\alpha}$. Derive the transformed ODEs in $s$ for $r(s)$ and $v(s)$ using only the chain rule and algebra, without introducing any additional assumptions beyond radial motion and Newtonian gravity.\n- Define the leading-order local truncation error magnitude for the position update $r \\mapsto r + h_s \\, dr/ds$ after a single forward Euler step of size $h_s$ in $s$ as the absolute value of the first nonvanishing Taylor remainder term in $h_s$, evaluated at the initial state $(r, v)$.\n- Specialize to the near-collision regime by adopting parabolic free-fall kinematics as the asymptotic initial condition family, namely take $v(r) = -\\sqrt{2 \\mu / r}$, which is the radial speed for zero specific energy free-fall. This choice captures the universal $r \\to 0$ scaling.\n- For numerical estimation of the scaling exponent, you must compute the leading-order local truncation error magnitude as a function of $r$ for a prescribed set of radii, then perform a least-squares fit in logarithmic space to extract the exponent $\\beta$ such that the error scales as $r^{\\beta}$ as $r \\to 0$. Do not use any pre-tabulated or externally provided special-case formulas; derive what you need from the above bases.\n\nNumerical specifications:\n- Use normalized units with $\\mu = 1$.\n- Use a fictitious time step $h_s = 1$ (dimensionless); since you are extracting a scaling exponent in $r$, the specific positive value of $h_s$ only contributes a constant prefactor and does not affect the exponent.\n- Use the following set of radii for the fit: $r \\in \\{10^{-6}, 3 \\cdot 10^{-6}, 10^{-5}, 3 \\cdot 10^{-5}, 10^{-4}, 3 \\cdot 10^{-4}, 10^{-3}\\}$.\n- Evaluate the exponent $\\beta$ separately for each $\\alpha \\in \\{-1, 0, 1, 2\\}$.\n\nTest suite and outputs:\n- The test suite is the set of four $\\alpha$ values $\\{-1, 0, 1, 2\\}$ applied to the above $r$-grid.\n- For each $\\alpha$ in the order $\\alpha = -1, 0, 1, 2$, estimate the scaling exponent $\\beta$ from a least-squares fit of $\\log_{10}(\\text{error})$ versus $\\log_{10}(r)$.\n- Also determine the “optimal” choice of $\\alpha$ within the given set as the one that maximizes the estimated $\\beta$, i.e., the one for which the leading-order local truncation error decays most rapidly with decreasing $r$ (or diverges slowest if none decay).\n- The final program output must be a single line containing a list of 5 numbers: the four estimated exponents in the order $\\alpha = -1, 0, 1, 2$, followed by the corresponding optimal $\\alpha$ value. All four exponents must be rounded to three decimal places, and the optimal $\\alpha$ must be an integer. For example, an output may look like `[β_{-1},β_{0},β_{1},β_{2},α_{\\text{opt}}]`.\n\nAngle units are not applicable in this radial setup. No physical unit reporting is required for the exponents, which are dimensionless. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., `[1.000,-2.000,-4.000,-6.000,-1]`).", "solution": "The objective is to determine the scaling of the leading-order local truncation error for the radial coordinate with respect to the radial distance $r$ during a close encounter in the two-body problem. This analysis will be performed under a Sundman time transformation $ds/dt = r^{\\alpha}$ for different integer values of $\\alpha$. The scaling exponent provides insight into the regularizing power of the transformation.\n\nFirst, we derive the equations of motion in the fictitious time $s$. The fundamental Newtonian equations for purely radial motion are given as:\n$$\n\\frac{dr}{dt} = v\n$$\n$$\n\\frac{dv}{dt} = -\\frac{\\mu}{r^2}\n$$\nThe Sundman transformation relates the physical time $t$ to the fictitious time $s$ by $ds/dt = r^{\\alpha}$. From this, we have $dt = r^{-\\alpha} ds$. We use the chain rule to transform the derivatives from $t$ to $s$:\n$$\n\\frac{dr}{ds} = \\frac{dr}{dt} \\frac{dt}{ds} = v \\cdot \\frac{1}{r^{\\alpha}} = v r^{-\\alpha}\n$$\n$$\n\\frac{dv}{ds} = \\frac{dv}{dt} \\frac{dt}{ds} = \\left(-\\frac{\\mu}{r^2}\\right) \\cdot \\frac{1}{r^{\\alpha}} = -\\mu r^{-2-\\alpha}\n$$\nThese are the transformed ordinary differential equations (ODEs) for the state variables $(r, v)$ as functions of $s$.\n\nNext, we analyze the local truncation error (LTE) of the first-order forward Euler method applied to the position update in $s$-time. The forward Euler update for $r$ over a single step of size $h_s$ is:\n$$\nr_{n+1} = r_n + h_s \\left.\\frac{dr}{ds}\\right|_n\n$$\nThe exact solution for $r(s_n + h_s)$ can be expressed via a Taylor series expansion around $s_n$:\n$$\nr(s_n + h_s) = r(s_n) + h_s \\left.\\frac{dr}{ds}\\right|_n + \\frac{h_s^2}{2} \\left.\\frac{d^2r}{ds^2}\\right|_n + O(h_s^3)\n$$\nThe leading-order local truncation error, $E_r$, is the first non-vanishing term in the difference between the exact solution and the numerical approximation. For the first-order Euler method, this is the term proportional to $h_s^2$:\n$$\nE_r \\approx \\frac{h_s^2}{2} \\frac{d^2r}{ds^2}\n$$\nThe magnitude of this error is what we seek to analyze: $|E_r| \\approx \\frac{h_s^2}{2} \\left|\\frac{d^2r}{ds^2}\\right|$. To find its scaling with $r$, we must compute the second derivative $\\frac{d^2r}{ds^2}$. We differentiate $\\frac{dr}{ds} = v r^{-\\alpha}$ with respect to $s$ using the product and chain rules:\n$$\n\\frac{d^2r}{ds^2} = \\frac{d}{ds} (v r^{-\\alpha}) = \\frac{dv}{ds} r^{-\\alpha} + v \\frac{d}{ds}(r^{-\\alpha})\n$$\nApplying the chain rule to the second term: $\\frac{d}{ds}(r^{-\\alpha}) = \\frac{d}{dr}(r^{-\\alpha}) \\frac{dr}{ds} = (-\\alpha r^{-\\alpha-1}) \\frac{dr}{ds}$.\nSubstituting the expressions for $\\frac{dr}{ds}$ and $\\frac{dv}{ds}$:\n$$\n\\frac{d^2r}{ds^2} = (-\\mu r^{-2-\\alpha}) r^{-\\alpha} + v (-\\alpha r^{-\\alpha-1}) (v r^{-\\alpha})\n$$\n$$\n\\frac{d^2r}{ds^2} = -\\mu r^{-2-2\\alpha} - \\alpha v^2 r^{-2\\alpha-1}\n$$\nThis expression depends on both $r$ and $v$. The problem specifies using parabolic free-fall kinematics to model the near-collision regime, where the specific orbital energy is zero. This corresponds to the condition $v(r) = -\\sqrt{2\\mu/r}$, or $v^2 = 2\\mu/r$. Substituting this into the expression for the second derivative:\n$$\n\\frac{d^2r}{ds^2} = -\\mu r^{-2-2\\alpha} - \\alpha \\left(\\frac{2\\mu}{r}\\right) r^{-2\\alpha-1}\n$$\n$$\n\\frac{d^2r}{ds^2} = -\\mu r^{-2-2\\alpha} - 2\\alpha\\mu r^{-1} r^{-2\\alpha-1}\n$$\n$$\n\\frac{d^2r}{ds^2} = -\\mu r^{-2-2\\alpha} - 2\\alpha\\mu r^{-2-2\\alpha}\n$$\n$$\n\\frac{d^2r}{ds^2} = -\\mu (1 + 2\\alpha) r^{-2(1+\\alpha)}\n$$\nThis is the final expression for the second derivative under the specified conditions. Note that for $\\alpha = -1/2$, this derivative vanishes, indicating a higher order of accuracy; however, this value is not in the set we are considering.\n\nThe magnitude of the leading-order local truncation error is therefore:\n$$\n|E_r| \\approx \\frac{h_s^2}{2} \\left|-\\mu (1 + 2\\alpha) r^{-2(1+\\alpha)}\\right| = \\frac{h_s^2\\mu}{2} |1 + 2\\alpha| r^{-2(1+\\alpha)}\n$$\nThe error scales with $r$ as $r^{\\beta}$, where the scaling exponent $\\beta$ is given by:\n$$\n\\beta = -2(1+\\alpha)\n$$\nWe can now evaluate this exponent for each value of $\\alpha \\in \\{-1, 0, 1, 2\\}$:\n- For $\\alpha = -1$: $\\beta = -2(1 - 1) = 0$. The error is constant as $r \\to 0$.\n- For $\\alpha = 0$: $\\beta = -2(1 + 0) = -2$. The error diverges as $r^{-2}$. This corresponds to integrating in physical time, $dt=ds$.\n- For $\\alpha = 1$: $\\beta = -2(1 + 1) = -4$. The error diverges as $r^{-4}$. This is related to the Kepler time element $r dt$.\n- For $\\alpha = 2$: $\\beta = -2(1 + 2) = -6$. The error diverges as $r^{-6}$.\n\nThe numerical task is to confirm these scaling exponents by fitting a line to the logarithm of the computed error versus the logarithm of $r$. The model is $\\log(|E_r|) = \\log(\\text{const}) + \\beta \\log(r)$, so $\\beta$ is the slope of the log-log plot.\n\nThe \"optimal\" choice of $\\alpha$ from the set $\\{-1, 0, 1, 2\\}$ is the one that maximizes the exponent $\\beta$. A larger $\\beta$ means the error either decays faster or diverges slowest as $r \\to 0$. The calculated exponents are $\\{0, -2, -4, -6\\}$. The maximum value is $\\beta=0$, which corresponds to $\\alpha = -1$. This transformation, $ds = dt/r$, is known as the eccentric anomaly-like time element and it regularizes the free-fall singularity to the lowest degree among the choices, making the leading-order error independent of $r$ in this specific analysis.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the scaling exponent of the local truncation error for different\n    Sundman time transformations in the radial two-body problem.\n    \"\"\"\n    \n    # Numerical specifications from the problem statement\n    mu = 1.0\n    hs = 1.0\n    r_values = np.array([1e-6, 3e-6, 1e-5, 3e-5, 1e-4, 3e-4, 1e-3])\n    alpha_values = [-1, 0, 1, 2]\n\n    # Pre-calculate the logarithm of the radii for fitting\n    log10_r = np.log10(r_values)\n\n    beta_estimates = []\n\n    for alpha in alpha_values:\n        # Analytically derived expression for the second derivative d^2r/ds^2\n        # d^2r/ds^2 = -mu * (1 + 2*alpha) * r**(-2 * (1 + alpha))\n        # The constant part of the expression\n        # For alpha = -0.5, the expression is zero, which would require\n        # a different error analysis (higher-order terms). This case is not\n        # in the test suite.\n        const_factor = -mu * (1.0 + 2.0 * alpha)\n        \n        # Power of r in the expression\n        r_exponent = -2.0 * (1.0 + alpha)\n        \n        # Second derivative values\n        d2r_ds2_values = const_factor * (r_values ** r_exponent)\n        \n        # Leading-order local truncation error magnitude\n        # E(r) = (hs^2 / 2) * |d^2r/ds^2|\n        error_magnitudes = (hs**2 / 2.0) * np.abs(d2r_ds2_values)\n        \n        # Take the logarithm for linear fitting\n        log10_error = np.log10(error_magnitudes)\n        \n        # Perform a linear least-squares fit in log-log space.\n        # The model is log10(error) = beta * log10(r) + log10(C).\n        # np.polyfit returns [slope, intercept], so we need the first element.\n        beta, _ = np.polyfit(log10_r, log10_error, 1)\n        \n        beta_estimates.append(beta)\n\n    # Find the optimal alpha, which maximizes the scaling exponent beta\n    max_beta = -np.inf\n    optimal_alpha = None\n    for i, beta in enumerate(beta_estimates):\n        if beta > max_beta:\n            max_beta = beta\n            optimal_alpha = alpha_values[i]\n            \n    # Format the results as required by the problem statement\n    # Exponents rounded to three decimal places\n    formatted_betas = [f\"{b:.3f}\" for b in beta_estimates]\n    \n    # Final list of results\n    final_results = formatted_betas + [str(optimal_alpha)]\n    \n    # Print the final output in the specified single-line format\n    print(f\"[{','.join(final_results)}]\")\n\nsolve()\n```", "id": "3532374"}, {"introduction": "Building on the analysis of local error, this exercise quantifies the practical payoff of regularization in terms of computational efficiency. Here, you will estimate the total number of integration steps required to navigate a highly eccentric orbit through its most challenging segment: the pericenter passage [@problem_id:3532368]. By comparing the step count for an unregularized integration ($\\alpha=0$) with that of a regularized one ($\\alpha=1$), you will gain a tangible appreciation for how a well-chosen time transformation can dramatically reduce the computational cost of achieving a target accuracy.", "problem": "Consider a two-body Newtonian gravitational system with gravitational parameter $\\mu$ and a Keplerian conic orbit characterized by eccentricity $e$ and pericenter distance $r_p$. Let $f$ denote the true anomaly and $r(f)$ the radial distance at true anomaly $f$. The system is integrated in a reparameterized independent variable $s$ defined by the Sundman transformation $ds = dt / r^{\\alpha}$, where $\\alpha$ is a constant exponent controlling the regularization strength in close encounters.\n\nFrom the two-body dynamics, the instantaneous rate of change of true anomaly satisfies $df/dt = h/r^2$, where $h$ is the specific angular momentum and $r(f)$ is given by the Keplerian conic formula $r(f) = p/(1 + e \\cos f)$ with semilatus rectum $p = r_p (1 + e)$. The specific angular momentum is $h = \\sqrt{\\mu p}$. The Sundman reparameterization implies $df/ds = (df/dt)(dt/ds) = h r^{\\alpha - 2}$.\n\nDefine the pericenter passage region as the symmetric interval in true anomaly $f \\in [-f_0, f_0]$ such that $r(f_0) = R r_p$, where $R > 1$ is a fixed radial ratio selecting the boundary of the passage. This condition determines $f_0$ from the relation $r(f_0)/r_p = (1+e)/(1 + e \\cos f_0) = R$, hence $\\cos f_0 = \\left(\\frac{1+e}{R} - 1\\right)/e$. Angles must be treated in radians.\n\nYou are to derive, implement, and use a step estimate for a constant-$s$ step integrator to ensure a target bound on the phase error in true anomaly. Assume a conservative local step criterion that requires the change in true anomaly per step to be bounded by a target phase tolerance $\\varepsilon_f$ (in radians). Under this criterion, the maximum allowed step size in $s$ is $\\Delta s_{\\max} = \\varepsilon_f / \\max_{f \\in [-f_0, f_0]}(df/ds)$. Since $r(f)$ attains its minimum at pericenter $f = 0$ with $r(0) = r_p$, conclude $\\max(df/ds) = h r_p^{\\alpha - 2}$, and therefore $\\Delta s_{\\max} = \\varepsilon_f / (h r_p^{\\alpha - 2})$.\n\nLet $S(\\alpha)$ denote the total Sundman time spanned over one pericenter passage,\n$$\nS(\\alpha) = \\int_{-f_0}^{f_0} ds = \\int_{-f_0}^{f_0} \\frac{dt}{r^{\\alpha}} = \\int_{-f_0}^{f_0} \\frac{r^{2-\\alpha}}{h} \\, df = \\frac{1}{h}\\int_{-f_0}^{f_0} \\left( \\frac{p}{1 + e \\cos f} \\right)^{2 - \\alpha} \\, df.\n$$\nUsing the conservative step criterion described above, estimate the required number of constant-$s$ steps $N(\\alpha)$ to traverse the pericenter passage as\n$$\nN(\\alpha) = \\left\\lceil \\frac{S(\\alpha)}{\\Delta s_{\\max}} \\right\\rceil = \\left\\lceil \\frac{S(\\alpha) \\, h \\, r_p^{\\alpha - 2}}{\\varepsilon_f} \\right\\rceil.\n$$\n\nYour task is to:\n- Implement a program that, for each provided test case, computes the required number of steps $N(0)$ for $\\alpha = 0$ and $N(1)$ for $\\alpha = 1$ following the definitions above.\n- Use canonical units with $\\mu = 1$ and distances and times in consistent dimensionless units, and report angles in radians. The target phase tolerance $\\varepsilon_f$ is provided in radians.\n- Compute $f_0$ using the relation for $\\cos f_0$ above. Verify that the argument to $\\arccos$ lies in $[-1,1]$; otherwise, this test case is invalid.\n- Evaluate $S(\\alpha)$ as a definite integral over $f \\in [-f_0, f_0]$ by numerically integrating the integrand $(p/(1 + e \\cos f))^{2 - \\alpha}/h$.\n\nTest Suite:\nFor each test case, use parameters $(\\mu, e, r_p, R, \\varepsilon_f)$ as given below. All evaluations must be performed in radians, and the final output must be integers without units.\n\n1. Case A (near-parabolic, moderate passage width):\n   - $\\mu = 1$, $e = 0.999$, $r_p = 1$, $R = 5$, $\\varepsilon_f = 10^{-3}$.\n\n2. Case B (exact parabolic boundary case):\n   - $\\mu = 1$, $e = 1.0$, $r_p = 1$, $R = 5$, $\\varepsilon_f = 10^{-3}$.\n\n3. Case C (more extreme near-parabolic with smaller pericenter and wider passage):\n   - $\\mu = 1$, $e = 0.9999$, $r_p = 0.1$, $R = 10$, $\\varepsilon_f = 5 \\times 10^{-4}$.\n\n4. Case D (less extreme eccentricity, larger pericenter):\n   - $\\mu = 1$, $e = 0.99$, $r_p = 10$, $R = 5$, $\\varepsilon_f = 2 \\times 10^{-3}$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to one test case and is itself a two-element list $[N(0), N(1)]$. For example, the output should look like\n`[[N(0)_A, N(1)_A], [N(0)_B, N(1)_B], [N(0)_C, N(1)_C], [N(0)_D, N(1)_D]]`.", "solution": "The problem statement has been rigorously validated and is determined to be valid. It is scientifically grounded in the principles of Newtonian mechanics and celestial dynamics, specifically concerning the two-body problem and the technique of time regularization for numerical integration. The problem is well-posed, with all necessary parameters and definitions provided, and contains no internal contradictions or ambiguities. The computational task is feasible and relevant to the field of computational astrophysics.\n\nThe objective is to compute the estimated number of constant-$s$ steps, $N(\\alpha)$, required to integrate a two-body system through a pericenter passage for two different Sundman transformations, characterized by $\\alpha=0$ and $\\alpha=1$. The number of steps is given by the formula:\n$$\nN(\\alpha) = \\left\\lceil \\frac{S(\\alpha)}{\\Delta s_{\\max}} \\right\\rceil\n$$\nwhere $S(\\alpha)$ is the total Sundman time over the passage and $\\Delta s_{\\max}$ is the maximum allowed step size in the regularized time $s$.\n\nFollowing the definitions provided, we can write a more direct expression for $N(\\alpha)$. The total Sundman time is\n$$\nS(\\alpha) = \\frac{1}{h}\\int_{-f_0}^{f_0} r(f)^{2 - \\alpha} \\, df\n$$\nand the maximum step size is based on the most rapid change in true anomaly, which occurs at pericenter ($f=0$, $r=r_p$):\n$$\n\\Delta s_{\\max} = \\frac{\\varepsilon_f}{\\max(df/ds)} = \\frac{\\varepsilon_f}{h\\,r_p^{\\alpha - 2}}\n$$\nCombining these gives the final expression for the number of steps:\n$$\nN(\\alpha) = \\left\\lceil \\frac{\\left( \\frac{1}{h}\\int_{-f_0}^{f_0} r(f)^{2 - \\alpha} \\, df \\right) h \\, r_p^{\\alpha - 2}}{\\varepsilon_f} \\right\\rceil = \\left\\lceil \\frac{r_p^{\\alpha - 2}}{\\varepsilon_f} \\int_{-f_0}^{f_0} r(f)^{2 - \\alpha} \\, df \\right\\rceil\n$$\nwhere $r(f)$ is the orbital radius at true anomaly $f$.\n\nThe computational procedure for each test case $(\\mu, e, r_p, R, \\varepsilon_f)$ is as follows:\n\n1.  **Calculate Orbit and Passage Parameters**: First, we determine the fundamental properties of the Keplerian orbit and the pericenter passage.\n    - The semilatus rectum, $p$, is calculated as $p = r_p (1 + e)$.\n    - The orbital radius is given by the polar equation of a conic section: $r(f) = \\frac{p}{1 + e \\cos f}$.\n    - The boundary of the pericenter passage is defined by the true anomaly $\\pm f_0$ where the radial distance is $r(f_0) = R r_p$. This leads to the equation for $\\cos f_0$:\n      $$\n      \\cos f_0 = \\frac{\\frac{1+e}{R} - 1}{e}\n      $$\n      For the special case of a parabolic orbit ($e=1$), this simplifies to $\\cos f_0 = \\frac{2}{R} - 1$. A critical validation step, as stipulated by the problem, is to ensure the argument of the inverse cosine is within the valid range $[-1, 1]$. We then find $f_0 = \\arccos(\\cos f_0)$, with $f_0 \\in [0, \\pi]$.\n\n2.  **Evaluate the Integral**: The integral term $\\int_{-f_0}^{f_0} r(f)^{2 - \\alpha} \\, df$ does not, in general, have a simple analytical solution. Therefore, it must be evaluated using numerical quadrature. The integrand, $r(f)^{2-\\alpha}$, is an even function of $f$ since $\\cos(f) = \\cos(-f)$. This symmetry allows for a more efficient computation:\n    $$\n    \\int_{-f_0}^{f_0} r(f)^{2 - \\alpha} \\, df = 2 \\int_{0}^{f_0} \\left( \\frac{p}{1 + e \\cos f} \\right)^{2 - \\alpha} \\, df\n    $$\n    This definite integral is computed numerically for each required value of $\\alpha$ ($\\alpha=0$ and $\\alpha=1$).\n\n3.  **Calculate the Number of Steps $N(\\alpha)$**: With the integral value, we compute $N(\\alpha)$ using the derived formula:\n    $$\n    N(\\alpha) = \\left\\lceil \\frac{2 \\cdot r_p^{\\alpha - 2}}{\\varepsilon_f} \\int_{0}^{f_0} \\left( \\frac{p}{1 + e \\cos f} \\right)^{2 - \\alpha} \\, df \\right\\rceil\n    $$\n    The ceiling function, $\\lceil \\cdot \\rceil$, is applied to ensure the number of steps is an integer sufficient to cover the entire interval. This calculation is performed for $\\alpha=0$ (no time regularization, $ds=dt$) and $\\alpha=1$ (regularization via $ds=dt/r$).\n\nThis procedure provides a quantitative estimate of the computational effort required to navigate a close encounter. The comparison between $N(0)$ and $N(1)$ illustrates the effectiveness of regularization. For highly eccentric orbits where velocity changes dramatically near pericenter, a standard time-stepper ($\\alpha=0$) would require a very large number of steps to maintain accuracy. The $\\alpha=1$ regularization transforms the independent variable to slow down the numerical integration during the fastest parts of the orbit, resulting in a more uniform step size in the $s$ domain and, consequently, a smaller total number of steps $N(1)$ compared to $N(0)$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    It computes the number of steps N(0) and N(1) for each case\n    and prints the results in the specified format.\n    \"\"\"\n    test_cases = [\n        # Case A (near-parabolic, moderate passage width):\n        # (mu, e, r_p, R, eps_f)\n        (1.0, 0.999, 1.0, 5.0, 1e-3),\n\n        # Case B (exact parabolic boundary case):\n        (1.0, 1.0, 1.0, 5.0, 1e-3),\n\n        # Case C (more extreme near-parabolic with smaller pericenter and wider passage):\n        (1.0, 0.9999, 0.1, 10.0, 5e-4),\n\n        # Case D (less extreme eccentricity, larger pericenter):\n        (1.0, 0.99, 10.0, 5.0, 2e-3),\n    ]\n\n    results = []\n    for case in test_cases:\n        mu, e, r_p, R, eps_f = case\n        \n        # Calculate N for alpha = 0 and alpha = 1\n        n0 = _calculate_n_alpha(0, e, r_p, R, eps_f)\n        n1 = _calculate_n_alpha(1, e, r_p, R, eps_f)\n        \n        results.append(f\"[{n0},{n1}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef _calculate_n_alpha(alpha, e, r_p, R, eps_f):\n    \"\"\"\n    Calculates the number of steps N(alpha) for a given set of parameters.\n\n    Args:\n        alpha (float): The exponent of the Sundman transformation.\n        e (float): Eccentricity.\n        r_p (float): Pericenter distance.\n        R (float): Radial ratio defining the passage boundary.\n        eps_f (float): Target phase tolerance in radians.\n\n    Returns:\n        int: The calculated number of steps N(alpha).\n    \"\"\"\n    # Calculate the semilatus rectum p\n    p = r_p * (1.0 + e)\n\n    # Calculate the cosine of the boundary true anomaly f0\n    # Special handling for the parabolic case e = 1 to avoid division by zero in theory,\n    # though the formula simplifies correctly.\n    if np.isclose(e, 1.0):\n        cos_f0 = 2.0 / R - 1.0\n    else:\n        cos_f0 = ((1.0 + e) / R - 1.0) / e\n\n    # Validate that the argument for arccos is within [-1, 1]\n    if not -1.0 = cos_f0 = 1.0:\n        # This case should be considered invalid as per the problem description.\n        # This check is included for robustness.\n        raise ValueError(\n            f\"Invalid arccos argument for f0 calculation: {cos_f0:.6f}\"\n        )\n    \n    f0 = np.arccos(cos_f0)\n\n    # Define the integrand for the Sundman time S(alpha) calculation\n    # Integrand is r(f)^(2-alpha)\n    def integrand(f):\n        return (p / (1.0 + e * np.cos(f)))**(2.0 - alpha)\n        \n    # Numerically integrate from 0 to f0. The full integral is 2x this value.\n    # The quad function from SciPy returns the result and an error estimate.\n    integral_val, _ = quad(integrand, 0, f0)\n    \n    # Calculate N(alpha) using the derived formula\n    # N(alpha) = ceil( (r_p^(alpha-2) / eps_f) * integral over [-f0, f0] )\n    # integral over [-f0, f0] is 2 * integral over [0, f0]\n    term = (r_p**(alpha - 2.0) / eps_f) * (2.0 * integral_val)\n    \n    # The number of steps must be an integer, so we take the ceiling.\n    num_steps = np.ceil(term)\n    \n    return int(num_steps)\n\nsolve()\n```", "id": "3532368"}, {"introduction": "While accurately navigating a single close encounter is a key challenge, many problems in astrophysics demand simulations that remain stable and accurate over thousands or even millions of orbits. This final practice explores the long-term fidelity of regularized integrators by measuring the slow, cumulative \"secular\" error in a quantity that should be perfectly conserved: the angular momentum. By simulating a highly eccentric binary for a vast number of periods, you will investigate how the choice of regularization parameter $\\alpha$ and step size affect the long-term qualitative accuracy of the solution, a crucial aspect for simulations of planetary systems and stellar clusters [@problem_id:3532333].", "problem": "Consider a bound two-body problem in the plane under Newtonian gravity with gravitational parameter $\\mu > 0$. In relative coordinates, let the position be $\\mathbf{x}(t) \\in \\mathbb{R}^2$ and the velocity be $\\mathbf{v}(t) = d\\mathbf{x}/dt$. The equation of motion is given by $$\\frac{d^2 \\mathbf{x}}{dt^2} = - \\mu \\frac{\\mathbf{x}}{r^3},$$ where $r = \\|\\mathbf{x}\\|$. The angular momentum vector is $\\mathbf{L} = \\mathbf{x} \\times \\mathbf{v}$, which is conserved exactly in continuous dynamics, and in two dimensions its magnitude reduces to the scalar $L_z = x v_y - y v_x$.\n\nTo regularize close approaches, introduce a Sundman time transformation with parameter $\\alpha \\ge 0$, defined by $$dt = r^{\\alpha} \\, d\\tau.$$ Denote derivatives with respect to $\\tau$ by primes. By the chain rule, the transformed second-order system becomes $$\\mathbf{x}'' = - \\mu \\, \\mathbf{x} \\, r^{2\\alpha - 3} + \\alpha \\, r^{-2} \\, \\mathbf{x}' \\, (\\mathbf{x} \\cdot \\mathbf{x}'),$$ together with the time evolution $t' = r^{\\alpha}$. The physical velocity required for angular momentum evaluation is recovered via $$\\mathbf{v} = \\frac{\\mathbf{x}'}{r^{\\alpha}}.$$\n\nYou are to implement a numerical integrator for this transformed system using a fixed-step fourth-order Runge–Kutta method in the Sundman variable $\\tau$. The initial conditions correspond to a Keplerian ellipse of semi-major axis $a = 1$ and eccentricity $e = 0.9$ (dimensionless units), with $\\mu = 1$. Initialize at pericenter with $$\\mathbf{x}(0) = (r_p, 0), \\quad r_p = a (1 - e),$$ $$\\mathbf{v}(0) = \\left(0, \\sqrt{\\mu \\left(\\frac{2}{r_p} - \\frac{1}{a}\\right)}\\right),$$ and $$\\mathbf{x}'(0) = \\mathbf{v}(0)\\, r_p^{\\alpha}, \\quad t(0) = 0.$$ The orbital period is $$P = 2\\pi \\frac{a^{3/2}}{\\sqrt{\\mu}},$$ which in these units evaluates to $P = 2\\pi$.\n\nFor a given number of orbits $N_{\\text{orb}} = 10^5$, integrate until the physical time $t$ satisfies $t \\ge T_{\\text{final}}$, where $$T_{\\text{final}} = N_{\\text{orb}} \\, P.$$ At the end of integration, compute the scalar angular momentum $L_z$ using the final $\\mathbf{x}$ and $\\mathbf{v}$ via $$L_z = x v_y - y v_x = \\frac{x x'_y - y x'_x}{r^{\\alpha}}.$$ Quantify the long-term drift in angular momentum for the numerical scheme as the dimensionless scalar $$\\Delta = \\frac{L_z(T_{\\text{final}}) - L_z(0)}{L_z(0)}.$$\n\nDesign your program to evaluate $\\Delta$ for the following test suite of regularization parameters and Sundman step sizes $(\\alpha, h)$:\n- Test case $0$: $(\\alpha, h) = (1.0, 1.2)$.\n- Test case $1$: $(\\alpha, h) = (2.0, 1.2)$.\n- Test case $2$: $(\\alpha, h) = (0.5, 1.2)$.\n- Test case $3$: $(\\alpha, h) = (1.0, 2.4)$.\n\nAll quantities are dimensionless; no physical units are required. Angles (if any intermediate angles are used) must be understood in radians, but the numerical algorithm must work purely with vector states without explicitly using angles.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must contain five entries: the first four entries are the drifts $\\Delta$ for test cases $0$ through $3$ (in that order, as floating-point numbers), and the fifth entry is the integer index $i^\\ast \\in \\{0,1,2,3\\}$ of the test case that minimizes the absolute drift, i.e., $$i^\\ast = \\underset{i \\in \\{0,1,2,3\\}}{\\operatorname{argmin}} \\, |\\Delta_i|.$$\n\nEnsure scientific realism and numerical stability by adhering to the defined model and initial conditions. Your implementation must be self-contained, must not read input, and must not access any external resources. The final answer must be printed exactly in the specified format, with no additional text.", "solution": "The user-provided problem has been analyzed and validated. It is a well-posed, scientifically sound problem in computational astrophysics, asking for a numerical experiment on the regularization of the Kepler problem. All required parameters, equations, and conditions are provided, and no inconsistencies or ambiguities are present.\n\nThe core task is to integrate the equations of motion for a two-body system under gravity, which have been transformed using a Sundman time transformation, $dt = r^{\\alpha} \\, d\\tau$. This transformation regularizes the singularity at $r=0$ by slowing down the integration in the fictitious time $\\tau$ during close approaches (small $r$). The goal is to measure the long-term numerical error in the conservation of angular momentum for different values of the regularization parameter $\\alpha$ and the numerical step size $h$.\n\nThe algorithmic solution is structured as follows:\n\n1.  **System of First-Order ODEs**: The problem is formulated as a system of five first-order ordinary differential equations (ODEs) in the Sundman time variable $\\tau$. The state of the system is described by a vector $\\mathbf{Y}(\\tau) = [x(\\tau), y(\\tau), x'_x(\\tau), x'_y(\\tau), t(\\tau)]^T$, where $\\mathbf{x}=(x,y)$ is the position, $\\mathbf{x}'=d\\mathbf{x}/d\\tau$ is the transformed velocity, and $t$ is the physical time. The derivative of the state vector, $\\mathbf{Y}'(\\tau) = d\\mathbf{Y}/d\\tau$, is a function $F(\\mathbf{Y}, \\alpha)$ derived from the equations provided in the problem statement.\n\n2.  **Derivative Function $F(\\mathbf{Y}, \\alpha)$**: The components of the derivative vector $\\mathbf{Y}' = [x'_x, x'_y, x'', y'', t']^T$ are determined as follows:\n    -   The derivatives of position, $(x', y')$, are directly available as the third and fourth components of the state vector $\\mathbf{Y}$.\n    -   The derivative of physical time, $t'$, is given by the transformation rule: $t' = r^{\\alpha}$, where $r = \\sqrt{x^2+y^2}$.\n    -   The transformed acceleration, $\\mathbf{x}'' = (x'', y'')^T$, is given by the transformed equation of motion:\n        $$ \\mathbf{x}'' = - \\mu \\, \\mathbf{x} \\, r^{2\\alpha - 3} + \\alpha \\, r^{-2} \\, (\\mathbf{x} \\cdot \\mathbf{x}') \\, \\mathbf{x}' $$\n    This function $F(\\mathbf{Y}, \\alpha)$ defines the complete dynamics of the system in the $\\tau$ domain.\n\n3.  **Initial Conditions**: The integration starts at pericenter of a Keplerian ellipse with semi-major axis $a=1$ and eccentricity $e=0.9$.\n    -   The pericenter distance is $r_p = a(1-e) = 1(1-0.9) = 0.1$.\n    -   The initial position is $\\mathbf{x}(0) = (r_p, 0) = (0.1, 0)$.\n    -   The velocity at pericenter is purely in the $y$-direction, with magnitude $v_p = \\sqrt{\\mu(2/r_p - 1/a)} = \\sqrt{1(2/0.1 - 1/1)} = \\sqrt{19}$. Thus, $\\mathbf{v}(0) = (0, \\sqrt{19})$.\n    -   The initial transformed velocity is $\\mathbf{x}'(0) = \\mathbf{v}(0) r_p^{\\alpha} = (0, \\sqrt{19} \\cdot 0.1^\\alpha)$. This depends on the test case parameter $\\alpha$.\n    -   The initial physical time is $t(0) = 0$.\n    -   Combining these gives the initial state vector $\\mathbf{Y}(0) = [0.1, 0, 0, \\sqrt{19} \\cdot 0.1^\\alpha, 0]^T$.\n\n4.  **Numerical Integration**: A standard fourth-order Runge-Kutta (RK4) scheme with a fixed step size $h$ (in $\\tau$) is employed to advance the state vector from $\\mathbf{Y}_n$ to $\\mathbf{Y}_{n+1}$:\n    $$ \\mathbf{Y}_{n+1} = \\mathbf{Y}_n + \\frac{h}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4) $$\n    where $\\mathbf{k}_1 = F(\\mathbf{Y}_n, \\alpha)$, $\\mathbf{k}_2 = F(\\mathbf{Y}_n+\\frac{h}{2}\\mathbf{k}_1, \\alpha)$, $\\mathbf{k}_3 = F(\\mathbf{Y}_n+\\frac{h}{2}\\mathbf{k}_2, \\alpha)$, and $\\mathbf{k}_4 = F(\\mathbf{Y}_n + h \\mathbf{k}_3, \\alpha)$. The integration is performed iteratively, starting from $\\mathbf{Y}(0)$, and continues until the physical time component, $Y_4 = t$, meets or exceeds the target final time, $T_{\\text{final}} = N_{\\text{orb}} P = 10^5 \\times 2\\pi$.\n\n5.  **Error Quantification**: Upon completion of the integration, the numerical drift in angular momentum is calculated.\n    -   The initial angular momentum is $L_z(0) = x(0)v_y(0) - y(0)v_x(0) = r_p v_p = 0.1\\sqrt{19}$.\n    -   The final angular momentum, $L_z(T_{\\text{final}})$, is computed from the final state vector $\\mathbf{Y}_f = [x_f, y_f, x'_{xf}, x'_{yf}, t_f]^T$ using the formula:\n        $$ L_z(T_{\\text{final}}) = \\frac{x_f x'_{yf} - y_f x'_{xf}}{r_f^{\\alpha}} $$\n        where $r_f = \\sqrt{x_f^2+y_f^2}$.\n    -   The relative drift is then evaluated as $\\Delta = \\frac{L_z(T_{\\text{final}}) - L_z(0)}{L_z(0)}$.\n\n6.  **Execution and Output**: The above procedure is executed for each of the four test cases $(\\alpha, h)$. The resulting four values of $\\Delta$ are collected. The index $i^\\ast \\in \\{0,1,2,3\\}$ that corresponds to the minimum absolute drift, $|\\Delta_i|$, is identified. The final output is a single line containing the four drift values and the optimal index $i^\\ast$, formatted as a comma-separated list enclosed in square brackets.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the regularized two-body problem for the specified test cases\n    and determines the optimal regularization parameter set.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (alpha, h)\n        (1.0, 1.2),  # Case 0\n        (2.0, 1.2),  # Case 1\n        (0.5, 1.2),  # Case 2\n        (1.0, 2.4),  # Case 3\n    ]\n\n    # Physical and orbital parameters\n    MU = 1.0\n    A = 1.0\n    E = 0.9\n    N_ORB = 100000\n\n    # Calculated constants\n    P = 2.0 * np.pi * A**(1.5) / np.sqrt(MU)\n    T_FINAL = N_ORB * P\n\n    def F(Y, alpha):\n        \"\"\"\n        Computes the derivative dY/d(tau) for the regularized system.\n        Y = [x, y, x_prime, y_prime, t]\n        \"\"\"\n        x, y, vx_p, vy_p, _ = Y\n        \n        r_sq = x*x + y*y\n        r = np.sqrt(r_sq)\n\n        if r == 0.0:\n            return np.zeros_like(Y)\n            \n        # Time derivative: t' = r^alpha\n        t_prime = r**alpha\n\n        # Acceleration in tau-time: x''\n        x_vec = np.array([x, y])\n        xp_vec = np.array([vx_p, vy_p])\n        \n        # x'' = - mu * x * r^(2*alpha - 3) + alpha * r^(-2) * x' * (x . x')\n        r_pow_term = r**(2.0 * alpha - 3.0)\n        x_dot_xp = x * vx_p + y * vy_p\n        \n        x_dd_vec = -MU * r_pow_term * x_vec + alpha * r**(-2.0) * x_dot_xp * xp_vec\n        \n        return np.array([vx_p, vy_p, x_dd_vec[0], x_dd_vec[1], t_prime])\n\n    def run_simulation(alpha, h):\n        \"\"\"\n        Performs a full RK4 integration for a given (alpha, h) pair.\n        \"\"\"\n        # Initial conditions at pericenter\n        r_p = A * (1.0 - E)\n        v_p = np.sqrt(MU * (2.0/r_p - 1.0/A))\n        \n        x0_vec = np.array([r_p, 0.0])\n        v0_vec = np.array([0.0, v_p])\n        xp0_vec = v0_vec * (r_p**alpha)\n        \n        # State vector Y = [x, y, x_prime, y_prime, t]\n        Y = np.array([x0_vec[0], x0_vec[1], xp0_vec[0], xp0_vec[1], 0.0])\n\n        # Initial angular momentum Lz(0)\n        Lz0 = x0_vec[0] * v0_vec[1] - x0_vec[1] * v0_vec[0]\n\n        # RK4 integration loop\n        while Y[4]  T_FINAL:\n            k1 = F(Y, alpha)\n            k2 = F(Y + 0.5 * h * k1, alpha)\n            k3 = F(Y + 0.5 * h * k2, alpha)\n            k4 = F(Y + h * k3, alpha)\n            Y += (h / 6.0) * (k1 + 2.0*k2 + 2.0*k3 + k4)\n            \n        # Final state analysis\n        xf, yf, vxf_p, vyf_p, _ = Y\n        rf = np.sqrt(xf**2 + yf**2)\n        \n        if rf == 0.0:\n            Lz_final = 0.0\n        else:\n            # Lz_final = (x_f * x'_yf - y_f * x'_xf) / r_f^alpha\n            Lz_final = (xf * vyf_p - yf * vxf_p) / (rf**alpha)\n        \n        # Calculate relative drift\n        delta = (Lz_final - Lz0) / Lz0\n        return delta\n\n    # Execute for all test cases\n    results_delta = []\n    for case in test_cases:\n        alpha, h = case\n        delta = run_simulation(alpha, h)\n        results_delta.append(delta)\n\n    # Find the index of the test case with minimum absolute drift\n    min_abs_drift_index = np.argmin(np.abs(np.array(results_delta)))\n\n    # Combine results and print in the specified format\n    final_output = results_delta + [min_abs_drift_index]\n    print(f\"[{','.join(map(str, final_output))}]\")\n\nsolve()\n```", "id": "3532333"}]}