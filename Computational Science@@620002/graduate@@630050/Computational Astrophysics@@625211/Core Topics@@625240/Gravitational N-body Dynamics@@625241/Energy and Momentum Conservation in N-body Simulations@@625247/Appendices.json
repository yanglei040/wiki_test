{"hands_on_practices": [{"introduction": "The fidelity of any N-body simulation begins before the first timestep is even taken. Establishing a well-defined reference frame, such as the center-of-mass frame where total momentum is zero, is a fundamental prerequisite for stable integration and meaningful analysis. This exercise [@problem_id:3509637] challenges you to implement a robust initialization procedure, confronting the real-world numerical difficulties that arise from finite-precision arithmetic when dealing with vast dynamic ranges in mass and position common in astrophysics. You will go beyond naive summation to employ numerically stable algorithms, ensuring that conservation laws are respected to machine precision from the very start.", "problem": "Consider a gravitational $N$-body initialization in double-precision floating point arithmetic that must enforce two invariants prior to time integration: total momentum is zero and the center of mass is at the origin. Let masses be $\\{m_i\\}_{i=1}^N$ with $m_i \\in \\mathbb{R}^+$, positions be $\\{\\mathbf{r}_i\\}_{i=1}^N$ with $\\mathbf{r}_i \\in \\mathbb{R}^3$ in meters, and velocities be $\\{\\mathbf{v}_i\\}_{i=1}^N$ with $\\mathbf{v}_i \\in \\mathbb{R}^3$ in meters per second. The invariants to impose are $\\sum_{i=1}^N m_i \\mathbf{v}_i = \\mathbf{0}$ and $\\sum_{i=1}^N m_i \\mathbf{r}_i = \\mathbf{0}$.\n\nStarting from first principles, use the definitions of linear momentum and center of mass together with Newtonian mechanics to design a numerically robust procedure that computes the required aggregate quantities and applies a transformation to $\\mathbf{r}_i$ and $\\mathbf{v}_i$ which enforces the invariants to machine precision in floating point. The procedure must be robust to ill-conditioned sums arising from large dynamic ranges in $\\{m_i\\}$, $\\{\\mathbf{r}_i\\}$, and $\\{\\mathbf{v}_i\\}$. Your design must explicitly employ a summation strategy that stabilizes accumulation of $\\sum_{i=1}^N m_i$, $\\sum_{i=1}^N m_i \\mathbf{r}_i$, and $\\sum_{i=1}^N m_i \\mathbf{v}_i$ against rounding error (for example, compensated summation or pairwise summation) and it must include a corrective step that eliminates any residual violation of the invariants within floating point limits. You must preserve the relative configuration of bodies up to global translation and preserve velocities up to a uniform additive vector, and your procedure must handle the boundary case $N=1$ robustly.\n\nImplement this initialization procedure as a complete, runnable program. After applying your procedure, validate the invariants using a check that compares the residual norms $\\left\\|\\sum_{i=1}^N m_i \\mathbf{r}_i\\right\\|_2$ and $\\left\\|\\sum_{i=1}^N m_i \\mathbf{v}_i\\right\\|_2$ against a tolerance proportional to machine epsilon scaled by a physically meaningful norm. Use positions in meters and velocities in meters per second. Angles do not appear in this problem. The validation for each test case must return a boolean indicating whether both invariants are satisfied to machine precision under your tolerance criterion.\n\nTest suite:\n- Case A (general): $N=5$, masses $\\left[m_1,m_2,m_3,m_4,m_5\\right] = \\left[1.0, 2.0, 3.5, 0.8, 4.2\\right]$, positions (meters)\n$\\mathbf{r}_1 = \\left[1.0\\times 10^7, -2.0\\times 10^7, 3.0\\times 10^7\\right]$, \n$\\mathbf{r}_2 = \\left[-4.0\\times 10^7, 5.0\\times 10^7, -6.0\\times 10^7\\right]$, \n$\\mathbf{r}_3 = \\left[7.0\\times 10^7, -8.0\\times 10^7, 9.0\\times 10^7\\right]$, \n$\\mathbf{r}_4 = \\left[-1.5\\times 10^7, 2.2\\times 10^7, -3.3\\times 10^7\\right]$, \n$\\mathbf{r}_5 = \\left[4.4\\times 10^7, -5.5\\times 10^7, 6.6\\times 10^7\\right]$; velocities (meters per second)\n$\\mathbf{v}_1 = \\left[1200.0, -2300.0, 3100.0\\right]$, \n$\\mathbf{v}_2 = \\left[-4000.0, 5100.0, -6200.0\\right]$, \n$\\mathbf{v}_3 = \\left[7300.0, -8400.0, 9500.0\\right]$, \n$\\mathbf{v}_4 = \\left[-1600.0, 2200.0, -3300.0\\right]$, \n$\\mathbf{v}_5 = \\left[4400.0, -5500.0, 6600.0\\right]$.\n- Case B (boundary $N=1$): $N=1$, mass $\\left[m_1\\right] = \\left[1.0\\right]$, position (meters) $\\mathbf{r}_1 = \\left[1.0\\times 10^3, -2.0\\times 10^3, 3.0\\times 10^3\\right]$, velocity (meters per second) $\\mathbf{v}_1 = \\left[-10.0, 20.0, -30.0\\right]$.\n- Case C (extreme mass ratio): $N=5$, masses $\\left[m_1,\\dots,m_5\\right] = \\left[1.0\\times 10^{30}, 1.0, 1.0, 1.0, 1.0\\right]$, positions (meters)\n$\\mathbf{r}_1 = \\left[0.0, 0.0, 0.0\\right]$, \n$\\mathbf{r}_2 = \\left[1.0\\times 10^{11}, -2.0\\times 10^{11}, 3.0\\times 10^{11}\\right]$, \n$\\mathbf{r}_3 = \\left[-4.0\\times 10^{11}, 5.0\\times 10^{11}, -6.0\\times 10^{11}\\right]$, \n$\\mathbf{r}_4 = \\left[7.0\\times 10^{11}, -8.0\\times 10^{11}, 9.0\\times 10^{11}\\right]$, \n$\\mathbf{r}_5 = \\left[-1.0\\times 10^{11}, 2.0\\times 10^{11}, -3.0\\times 10^{11}\\right]$; velocities (meters per second)\n$\\mathbf{v}_1 = \\left[0.0, 0.0, 0.0\\right]$, \n$\\mathbf{v}_2 = \\left[1.0\\times 10^{4}, -2.0\\times 10^{4}, 3.0\\times 10^{4}\\right]$, \n$\\mathbf{v}_3 = \\left[-4.0\\times 10^{4}, 5.0\\times 10^{4}, -6.0\\times 10^{4}\\right]$, \n$\\mathbf{v}_4 = \\left[7.0\\times 10^{4}, -8.0\\times 10^{4}, 9.0\\times 10^{4}\\right]$, \n$\\mathbf{v}_5 = \\left[-1.0\\times 10^{4}, 2.0\\times 10^{4}, -3.0\\times 10^{4}\\right]$.\n- Case D (ill-conditioned sums): $N=6$, masses $\\left[m_1,\\dots,m_6\\right] = \\left[1.0, 1.0\\times 10^{-16}, 3.0, 1.0\\times 10^{-12}, 5.0, 1.0\\times 10^{-20}\\right]$, positions (meters)\n$\\mathbf{r}_1 = \\left[1.0\\times 10^{20}, -1.0\\times 10^{-10}, 1.0\\times 10^{5}\\right]$, \n$\\mathbf{r}_2 = \\left[-1.0\\times 10^{20}, 2.0\\times 10^{-10}, -1.0\\times 10^{5}\\right]$, \n$\\mathbf{r}_3 = \\left[3.0\\times 10^{15}, -3.0\\times 10^{-5}, 3.0\\times 10^{2}\\right]$, \n$\\mathbf{r}_4 = \\left[-4.0\\times 10^{15}, 4.0\\times 10^{-5}, -4.0\\times 10^{2}\\right]$, \n$\\mathbf{r}_5 = \\left[5.0\\times 10^{10}, -5.0\\times 10^{-5}, 5.0\\times 10^{2}\\right]$, \n$\\mathbf{r}_6 = \\left[6.0\\times 10^{5}, -6.0\\times 10^{-5}, 6.0\\times 10^{2}\\right]$; velocities (meters per second)\n$\\mathbf{v}_1 = \\left[1.0\\times 10^{5}, -1.0\\times 10^{-10}, 2.0\\times 10^{5}\\right]$, \n$\\mathbf{v}_2 = \\left[-1.0\\times 10^{5}, 2.0\\times 10^{-10}, -2.0\\times 10^{5}\\right]$, \n$\\mathbf{v}_3 = \\left[3.0\\times 10^{4}, -3.0\\times 10^{-5}, 6.0\\times 10^{4}\\right]$, \n$\\mathbf{v}_4 = \\left[-4.0\\times 10^{4}, 4.0\\times 10^{-5}, -8.0\\times 10^{4}\\right]$, \n$\\mathbf{v}_5 = \\left[5.0\\times 10^{3}, -5.0\\times 10^{-5}, 1.0\\times 10^{4}\\right]$, \n$\\mathbf{v}_6 = \\left[6.0\\times 10^{2}, -6.0\\times 10^{-5}, 1.2\\times 10^{3}\\right]$.\n- Case E (already balanced): $N=2$, masses $\\left[m_1,m_2\\right]=\\left[2.0, 2.0\\right]$, positions (meters)\n$\\mathbf{r}_1 = \\left[1.0\\times 10^{6}, 2.0\\times 10^{6}, -3.0\\times 10^{6}\\right]$, \n$\\mathbf{r}_2 = \\left[-1.0\\times 10^{6}, -2.0\\times 10^{6}, 3.0\\times 10^{6}\\right]$; velocities (meters per second)\n$\\mathbf{v}_1 = \\left[4.0\\times 10^{3}, -5.0\\times 10^{3}, 6.0\\times 10^{3}\\right]$, \n$\\mathbf{v}_2 = \\left[-4.0\\times 10^{3}, 5.0\\times 10^{3}, -6.0\\times 10^{3}\\right]$.\n\nYour program should apply your robust initialization to each case and then output a single line containing five booleans indicating whether both invariants are satisfied for each case, in the order A, B, C, D, E. Use a tolerance of the form $\\tau = c \\, \\epsilon \\, s$ where $\\epsilon$ is the machine epsilon for double precision, $c$ is a modest constant, and $s$ is a scale computed from the data (for instance, an $L^1$ or $L^2$ norm of the mass-weighted positions or velocities). Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $\\left[\\mathrm{result}_A,\\mathrm{result}_B,\\mathrm{result}_C,\\mathrm{result}_D,\\mathrm{result}_E\\right]$).", "solution": "The problem requires the design and implementation of a numerically robust procedure to initialize an $N$-body system such that its center of mass is at the origin and its total linear momentum is zero. These two conditions, $\\sum_{i=1}^N m_i \\mathbf{r}_i = \\mathbf{0}$ and $\\sum_{i=1}^N m_i \\mathbf{v}_i = \\mathbf{0}$, are crucial for many computational astrophysics simulations, as they place the system in a canonical reference frame. The procedure must be robust against floating-point rounding errors, especially when dealing with data spanning large dynamic ranges.\n\n**1. First Principles and Mathematical Formulation**\n\nFrom Newtonian mechanics, for a closed system of $N$ particles with masses $\\{m_i\\}_{i=1}^N$, positions $\\{\\mathbf{r}_i\\}_{i=1}^N$, and velocities $\\{\\mathbf{v}_i\\}_{i=1}^N$, the center of mass (COM) position $\\mathbf{R}_{CM}$ and velocity $\\mathbf{V}_{CM}$ are defined as:\n$$ \\mathbf{R}_{CM} = \\frac{\\sum_{i=1}^N m_i \\mathbf{r}_i}{\\sum_{i=1}^N m_i} $$\n$$ \\mathbf{V}_{CM} = \\frac{\\sum_{i=1}^N m_i \\mathbf{v}_i}{\\sum_{i=1}^N m_i} $$\nwhere the total mass is $M_{tot} = \\sum_{i=1}^N m_i$. The total linear momentum of the system is $\\mathbf{P}_{tot} = M_{tot} \\mathbf{V}_{CM}$.\n\nTo enforce the invariant $\\sum m_i \\mathbf{r}'_i = \\mathbf{0}$, we must shift the origin of our coordinate system to the center of mass. This is achieved by applying a uniform translation $-\\mathbf{R}_{CM}$ to all particle positions. The new positions $\\mathbf{r}'_i$ are:\n$$ \\mathbf{r}'_i = \\mathbf{r}_i - \\mathbf{R}_{CM} $$\nThis transformation preserves the relative positions of all particles, since $\\mathbf{r}'_i - \\mathbf{r}'_j = (\\mathbf{r}_i - \\mathbf{R}_{CM}) - (\\mathbf{r}_j - \\mathbf{R}_{CM}) = \\mathbf{r}_i - \\mathbf{r}_j$.\n\nTo enforce the invariant $\\sum m_i \\mathbf{v}'_i = \\mathbf{0}$, we must transform to a reference frame in which the center of mass is stationary. This is a Galilean transformation achieved by subtracting the COM velocity $\\mathbf{V}_{CM}$ from all particle velocities. The new velocities $\\mathbf{v}'_i$ are:\n$$ \\mathbf{v}'_i = \\mathbf{v}_i - \\mathbf{V}_{CM} $$\nThis transformation preserves relative velocities, $\\mathbf{v}'_i - \\mathbf{v}'_j = (\\mathbf{v}_i - \\mathbf{V}_{CM}) - (\\mathbf{v}_j - \\mathbf{V}_{CM}) = \\mathbf{v}_i - \\mathbf{v}_j$, preserving the internal kinetics of the system.\n\n**2. Numerical Stability and Compensated Summation**\n\nThe computation of the aggregate quantities $M_{tot}$, $\\sum m_i \\mathbf{r}_i$, and $\\sum m_i \\mathbf{v}_i$ involves summing floating-point numbers. Standard summation is prone to significant loss of precision when adding numbers of widely different magnitudes, a situation common in astrophysics (e.g., a star and its planets). The problem explicitly requires a robust summation strategy.\n\nWe will employ the Kahan summation algorithm. This algorithm mitigates rounding errors by maintaining a running compensation variable, $c$, which accumulates the error from each addition. For a sum $S = \\sum_{k=1}^N x_k$, the algorithm is:\n1. Initialize sum $s \\leftarrow 0.0$ and compensation $c \\leftarrow 0.0$.\n2. For $k=1$ to $N$:\n   a. $y \\leftarrow x_k - c$\n   b. $t \\leftarrow s + y$\n   c. $c \\leftarrow (t - s) - y$\n   d. $s \\leftarrow t$\n3. Return $s$.\n\nThe variable $c$ captures the low-order bits lost in the addition $s+y$. In the next iteration, this lost part is subtracted from the next term $x_{k+1}$ before it is added to the running sum $s$. This procedure is applied to compute the scalar total mass $M_{tot}$ and to each component of the vector sums $\\sum m_i \\mathbf{r}_i$ and $\\sum m_i \\mathbf{v}_i$.\n\n**3. Algorithmic Procedure and Refinement**\n\nEven with robust summation, the subtractions $\\mathbf{r}_i - \\mathbf{R}_{CM}$ and $\\mathbf{v}_i - \\mathbf{V}_{CM}$ can introduce new, smaller rounding errors. To ensure the invariants are satisfied to machine precision, a two-pass corrective procedure is implemented:\n\n**Step A: Initial Correction**\n1. Compute the total mass $M_{tot} = \\sum_{i=1}^N m_i$ using Kahan summation. The problem statement guarantees $m_i \\in \\mathbb{R}^+$, so $M_{tot} > 0$.\n2. Compute the mass-weighted position sum $\\mathbf{P}_{pos} = \\sum_{i=1}^N m_i \\mathbf{r}_i$ and velocity sum $\\mathbf{P}_{vel} = \\sum_{i=1}^N m_i \\mathbf{v}_i$. Each component of these vector sums is calculated using Kahan summation.\n3. Determine the initial COM position and velocity: $\\mathbf{R}_{CM} = \\mathbf{P}_{pos} / M_{tot}$ and $\\mathbf{V}_{CM} = \\mathbf{P}_{vel} / M_{tot}$.\n4. Apply the primary transformation to obtain the once-corrected state: $\\mathbf{r}'_i = \\mathbf{r}_i - \\mathbf{R}_{CM}$ and $\\mathbf{v}'_i = \\mathbf{v}_i - \\mathbf{V}_{CM}$.\n\n**Step B: Corrective Refinement**\n1. Using the corrected state $\\{\\mathbf{r}'_i, \\mathbf{v}'_i\\}$, re-compute the (now very small) residual mass-weighted sums, $\\delta\\mathbf{P}_{pos} = \\sum m_i \\mathbf{r}'_i$ and $\\delta\\mathbf{P}_{vel} = \\sum m_i \\mathbf{v}'_i$, again using Kahan summation.\n2. Calculate the small residual offsets: $\\delta\\mathbf{R}_{CM} = \\delta\\mathbf{P}_{pos} / M_{tot}$ and $\\delta\\mathbf{V}_{CM} = \\delta\\mathbf{P}_{vel} / M_{tot}$.\n3. Apply the final correction: $\\mathbf{r}''_i = \\mathbf{r}'_i - \\delta\\mathbf{R}_{CM}$ and $\\mathbf{v}''_i = \\mathbf{v}'_i - \\delta\\mathbf{V}_{CM}$.\n\nThis two-pass method effectively eliminates the residual error to within floating-point limits. For the boundary case $N=1$, the procedure correctly simplifies to setting the single particle's position and velocity to $\\mathbf{0}$.\n\n**4. Validation Criterion**\n\nAfter applying the procedure, we validate that the invariants are satisfied to machine precision. We compute the final residual norms, $res_r = \\left\\|\\sum m_i \\mathbf{r}''_i\\right\\|_2$ and $res_v = \\left\\|\\sum m_i \\mathbf{v}''_i\\right\\|_2$.\n\nThese residuals are compared against a tolerance $\\tau$ that is proportional to machine epsilon $\\epsilon$ and scaled by a characteristic magnitude of the problem's inputs. A suitable scale $s$ is the sum of the magnitudes of the terms in the original sums.\nFor the position invariant, the scale is $s_r = \\sum_{i=1}^N \\|m_i \\mathbf{r}_{i, \\text{initial}}\\|_2 = \\sum_{i=1}^N m_i \\|\\mathbf{r}_{i, \\text{initial}}\\|_2$.\nFor the velocity invariant, the scale is $s_v = \\sum_{i=1}^N m_i \\|\\mathbf{v}_{i, \\text{initial}}\\|_2$.\n\nThe tolerance is thus $\\tau = c \\cdot \\epsilon \\cdot s$, where $c$ is a small constant (we choose $c=10$) to account for the accumulation of round-off error across multiple operations. The validation check for each invariant is successful if its residual norm is less than or equal to its respective tolerance:\n$$ res_r \\le \\tau_r \\quad \\text{and} \\quad res_v \\le \\tau_v $$\nAll sums involved in the validation (for scale and final residual calculation) also use Kahan summation to ensure the check itself is accurate. A test case passes if and only if both invariants are satisfied.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef kahan_sum(arr: np.ndarray) -> float:\n    \"\"\"\n    Computes the sum of a 1D array of floats using the Kahan summation algorithm\n    to minimize numerical error.\n    \"\"\"\n    s = 0.0\n    c = 0.0\n    for i in range(arr.shape[0]):\n        x = arr[i]\n        y = x - c\n        t = s + y\n        c = (t - s) - y\n        s = t\n    return s\n\ndef kahan_sum_vec(vec_arr: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Computes the component-wise sum of an array of vectors (N, D) using Kahan summation.\n    \"\"\"\n    if vec_arr.shape[0] == 0:\n        return np.zeros(vec_arr.shape[1], dtype=np.float64)\n    \n    s = np.zeros(vec_arr.shape[1], dtype=np.float64)\n    c = np.zeros(vec_arr.shape[1], dtype=np.float64)\n    for i in range(vec_arr.shape[0]):\n        x = vec_arr[i, :]\n        y = x - c\n        t = s + y\n        c = (t - s) - y\n        s = t\n    return s\n\ndef robust_center_procedure(masses: np.ndarray, positions: np.ndarray, velocities: np.ndarray):\n    \"\"\"\n    Applies a numerically robust transformation to enforce zero total momentum\n    and center of mass at the origin.\n    \"\"\"\n    n_bodies = masses.shape[0]\n    \n    # Handle N=0 and N=1 cases robustly.\n    # For N=1, the a single body system in its COM frame is at rest at the origin.\n    if n_bodies = 1:\n        return np.zeros_like(positions), np.zeros_like(velocities)\n\n    # Use copies to preserve original data for validation scaling\n    final_positions = np.copy(positions)\n    final_velocities = np.copy(velocities)\n    \n    # Reshape mass array for broadcasting\n    m_col = masses.reshape(-1, 1)\n\n    # --- Pass 1: Initial Correction ---\n    total_mass = kahan_sum(masses)\n\n    # Compute COM position and velocity using Kahan summation\n    com_pos_numerator = kahan_sum_vec(final_positions * m_col)\n    com_vel_numerator = kahan_sum_vec(final_velocities * m_col)\n    \n    r_cm = com_pos_numerator / total_mass\n    v_cm = com_vel_numerator / total_mass\n    \n    # Apply the first correction\n    final_positions -= r_cm\n    final_velocities -= v_cm\n    \n    # --- Pass 2: Corrective Refinement ---\n    # Re-compute residual COM position and velocity from the corrected state\n    residual_pos_numerator = kahan_sum_vec(final_positions * m_col)\n    residual_vel_numerator = kahan_sum_vec(final_velocities * m_col)\n    \n    # Calculate and apply the small residual correction\n    dr_cm = residual_pos_numerator / total_mass\n    dv_cm = residual_vel_numerator / total_mass\n    \n    final_positions -= dr_cm\n    final_velocities -= dv_cm\n    \n    return final_positions, final_velocities\n\ndef validate_invariants(masses: np.ndarray, final_positions: np.ndarray, final_velocities: np.ndarray,\n                     initial_positions: np.ndarray, initial_velocities: np.ndarray) -> bool:\n    \"\"\"\n    Validates if the invariants are satisfied to machine precision.\n    \"\"\"\n    n_bodies = masses.shape[0]\n    if n_bodies == 0:\n        return True\n\n    m_col = masses.reshape(-1, 1)\n    \n    # --- Compute Final Residuals ---\n    # Use Kahan sum to accurately compute the final residual sums\n    final_pos_sum = kahan_sum_vec(final_positions * m_col)\n    final_vel_sum = kahan_sum_vec(final_velocities * m_col)\n    \n    residual_pos_norm = np.linalg.norm(final_pos_sum)\n    residual_vel_norm = np.linalg.norm(final_vel_sum)\n\n    # --- Compute Tolerances ---\n    # Define constants for tolerance calculation\n    epsilon = np.finfo(np.float64).eps\n    const_c = 10.0\n    \n    # Calculate problem scales from initial data\n    # The scale is the sum of norms of the mass-weighted vectors\n    initial_mass_pos_norms = np.linalg.norm(initial_positions * m_col, axis=1)\n    initial_mass_vel_norms = np.linalg.norm(initial_velocities * m_col, axis=1)\n\n    # Use Kahan sum to accurately calculate the scales\n    scale_pos = kahan_sum(initial_mass_pos_norms)\n    scale_vel = kahan_sum(initial_mass_vel_norms)\n    \n    # Define tolerances\n    tolerance_pos = const_c * epsilon * scale_pos\n    tolerance_vel = const_c * epsilon * scale_vel\n    \n    # --- Perform Validation Check ---\n    pos_ok = residual_pos_norm = tolerance_pos\n    vel_ok = residual_vel_norm = tolerance_vel\n\n    return pos_ok and vel_ok\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    float_type = np.float64\n    \n    test_cases = [\n        # Case A: general\n        (\n            np.array([1.0, 2.0, 3.5, 0.8, 4.2], dtype=float_type),\n            np.array([\n                [1.0e7, -2.0e7, 3.0e7], [-4.0e7, 5.0e7, -6.0e7], [7.0e7, -8.0e7, 9.0e7],\n                [-1.5e7, 2.2e7, -3.3e7], [4.4e7, -5.5e7, 6.6e7]\n            ], dtype=float_type),\n            np.array([\n                [1200.0, -2300.0, 3100.0], [-4000.0, 5100.0, -6200.0], [7300.0, -8400.0, 9500.0],\n                [-1600.0, 2200.0, -3300.0], [4400.0, -5500.0, 6600.0]\n            ], dtype=float_type)\n        ),\n        # Case B: boundary N=1\n        (\n            np.array([1.0], dtype=float_type),\n            np.array([[1.0e3, -2.0e3, 3.0e3]], dtype=float_type),\n            np.array([[-10.0, 20.0, -30.0]], dtype=float_type)\n        ),\n        # Case C: extreme mass ratio\n        (\n            np.array([1.0e30, 1.0, 1.0, 1.0, 1.0], dtype=float_type),\n            np.array([\n                [0.0, 0.0, 0.0], [1.0e11, -2.0e11, 3.0e11], [-4.0e11, 5.0e11, -6.0e11],\n                [7.0e11, -8.0e11, 9.0e11], [-1.0e11, 2.0e11, -3.0e11]\n            ], dtype=float_type),\n            np.array([\n                [0.0, 0.0, 0.0], [1.0e4, -2.0e4, 3.0e4], [-4.0e4, 5.0e4, -6.0e4],\n                [7.0e4, -8.0e4, 9.0e4], [-1.0e4, 2.0e4, -3.0e4]\n            ], dtype=float_type)\n        ),\n        # Case D: ill-conditioned sums\n        (\n            np.array([1.0, 1.0e-16, 3.0, 1.0e-12, 5.0, 1.0e-20], dtype=float_type),\n            np.array([\n                [1.0e20, -1.0e-10, 1.0e5], [-1.0e20, 2.0e-10, -1.0e5], [3.0e15, -3.0e-5, 3.0e2],\n                [-4.0e15, 4.0e-5, -4.0e2], [5.0e10, -5.0e-5, 5.0e2], [6.0e5, -6.0e-5, 6.0e2]\n            ], dtype=float_type),\n            np.array([\n                [1.0e5, -1.0e-10, 2.0e5], [-1.0e5, 2.0e-10, -2.0e5], [3.0e4, -3.0e-5, 6.0e4],\n                [-4.0e4, 4.0e-5, -8.0e4], [5.0e3, -5.0e-5, 1.0e4], [6.0e2, -6.0e-5, 1.2e3]\n            ], dtype=float_type)\n        ),\n        # Case E: already balanced\n        (\n            np.array([2.0, 2.0], dtype=float_type),\n            np.array([[1.0e6, 2.0e6, -3.0e6], [-1.0e6, -2.0e6, 3.0e6]], dtype=float_type),\n            np.array([[4.0e3, -5.0e3, 6.0e3], [-4.0e3, 5.0e3, -6.0e3]], dtype=float_type)\n        )\n    ]\n\n    results = []\n    for case in test_cases:\n        masses, initial_positions, initial_velocities = case\n        \n        final_positions, final_velocities = robust_center_procedure(\n            masses, initial_positions, initial_velocities)\n        \n        is_valid = validate_invariants(\n            masses, final_positions, final_velocities,\n            initial_positions, initial_velocities\n        )\n        results.append(is_valid)\n\n    # Format the Python boolean True/False as lowercase for the final output string.\n    formatted_results = [str(r).lower() for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3509637"}, {"introduction": "Once a system is properly initialized, the core of the simulation is the time-integration algorithm. While many numerical schemes can solve the equations of motion, their long-term fidelity in conservative Hamiltonian systems varies dramatically. This practice [@problem_id:3509626] moves beyond simple energy conservation checks to more powerful diagnostics that reveal the subtle, unphysical effects of numerical error. By implementing and comparing different integrators on a Keplerian orbit, you will learn to use conserved quantities like the Laplace-Runge-Lenz vector and techniques like frequency-map analysis to quantify spurious orbital precession, gaining a deeper intuition for why symplectic integrators are often essential for astrophysical problems.", "problem": "You are asked to design and implement a self-contained program to quantify spurious apsidal precession in nearly Keplerian orbits that arises solely from numerical angular-momentum non-conservation in orbit integrators. Begin from the following fundamental base: Newton’s second law, Newton’s law of universal gravitation, and the definitions of orbital angular momentum and the Laplace–Runge–Lenz vector. Assume a single test particle of mass $m$ orbiting a fixed central point mass with gravitational parameter $\\mu = G M$, and restrict to planar motion. No external perturbations are present beyond those induced by the numerical integration scheme itself.\n\nThe program must do all of the following.\n\n- Implement planar two-body motion in dimensionless “code units” where $\\mu = 1$, and initialize a bound Keplerian ellipse with given semimajor axis $a$ and eccentricity $e$ at pericenter. The initial position is $\\mathbf{r}(0) = (a (1 - e), 0)$ and the initial velocity is $\\mathbf{v}(0) = \\left(0, \\sqrt{\\mu \\dfrac{1 + e}{a (1 - e)}}\\right)$. Use $a = 1$.\n\n- Integrate the equations of motion $\\dfrac{d \\mathbf{r}}{d t} = \\mathbf{v}$ and $\\dfrac{d \\mathbf{v}}{d t} = - \\mu \\dfrac{\\mathbf{r}}{\\lVert \\mathbf{r} \\rVert^{3}}$ on a uniform time grid for a prescribed total duration $T$ and step size $\\Delta t$, using the specified numerical schemes.\n\n- Diagnose angular momentum drift by computing the $z$-component $L_{z}(t) = (\\mathbf{r} \\times \\mathbf{v})_{z}$ and reporting the maximum relative deviation over the run, namely $\\max_{t} \\left| \\dfrac{L_{z}(t) - L_{z}(0)}{L_{z}(0)} \\right|$ as a dimensionless float.\n\n- Diagnose spurious apsidal precession by using the Laplace–Runge–Lenz (LRL) vector $\\mathbf{A}(t) = \\mathbf{v}(t) \\times \\mathbf{L}(t) - \\mu \\dfrac{\\mathbf{r}(t)}{\\lVert \\mathbf{r}(t) \\rVert}$, where $\\mathbf{L}(t) = \\mathbf{r}(t) \\times \\mathbf{v}(t)$. In the exactly Keplerian two-body problem, $\\mathbf{A}(t)$ is constant and points toward the periapsis. Numerically, non-conservation of angular momentum can induce a slow rotation of $\\mathbf{A}(t)$. Quantify the mean spurious apsidal precession rate by:\n  - Detecting successive pericenter passages as local minima of $r(t) = \\lVert \\mathbf{r}(t) \\rVert$.\n  - Recording the in-plane angle $\\varpi_{k}$ of $\\mathbf{A}$ at each pericenter (use $\\mathrm{atan2}$ for the in-plane angle).\n  - Computing the mean absolute change per orbit, $\\langle \\Delta \\varpi \\rangle = \\dfrac{1}{N_{\\mathrm{orb}} - 1} \\sum_{k=1}^{N_{\\mathrm{orb}} - 1} \\left| \\operatorname{unwrap}\\left(\\varpi_{k+1} - \\varpi_{k}\\right) \\right|$, expressed in radians per orbit.\n\n- Perform a frequency-map analysis that estimates the fundamental radial and azimuthal angular frequencies in the first and second halves of the time series and reports their diffusion. Concretely:\n  - Compute the radial fundamental angular frequency $\\omega_{r}$ from the dominant peak in the discrete Fourier transform of $r(t) - \\langle r \\rangle$, where the peak is taken over positive frequencies and converted to angular frequency by multiplying by $2 \\pi$.\n  - Compute the azimuthal fundamental angular frequency $\\omega_{\\theta}$ as the best-fit slope (via least squares) of the unwrapped polar angle $\\theta(t) = \\mathrm{atan2}(y(t), x(t))$ versus $t$.\n  - Evaluate these frequencies separately over the first half and second half of the integration interval to obtain $(\\omega_{r}^{(1)}, \\omega_{\\theta}^{(1)})$ and $(\\omega_{r}^{(2)}, \\omega_{\\theta}^{(2)})$.\n  - Report the frequency-map diffusion metric $D_{\\mathrm{FMA}} = \\sqrt{\\left(\\omega_{r}^{(2)} - \\omega_{r}^{(1)}\\right)^{2} + \\left(\\omega_{\\theta}^{(2)} - \\omega_{\\theta}^{(1)}\\right)^{2}}$, in inverse time units of the chosen code units.\n\nUse the following test suite with specified integrators, eccentricities, and step sizes, all with total duration of $T = 50 \\times P$, where $P = 2 \\pi \\sqrt{\\dfrac{a^{3}}{\\mu}}$ is the Keplerian orbital period in the adopted units. For each case below, $\\Delta t$ is specified as a fraction of $P$ and should be converted to the code time unit before use. All angles must be expressed in radians. All reported values must be unitless except for the diffusion metric $D_{\\mathrm{FMA}}$, which is in inverse time units.\n\n- Case $1$ (happy path, nearly Keplerian ellipse with a symplectic scheme):\n  - Integrator: velocity-Verlet (also called leapfrog).\n  - Eccentricity: $e = 0.1$.\n  - Time step: $\\Delta t = P / 1000$.\n\n- Case $2$ (non-symplectic coarse stepping to induce large errors):\n  - Integrator: forward Euler.\n  - Eccentricity: $e = 0.1$.\n  - Time step: $\\Delta t = P / 200$.\n\n- Case $3$ (edge case with high eccentricity using a high-order non-symplectic scheme):\n  - Integrator: classical fourth-order Runge–Kutta.\n  - Eccentricity: $e = 0.6$.\n  - Time step: $\\Delta t = P / 1000$.\n\nFor each case, your program must output a list of three floats:\n- The maximum relative angular-momentum deviation $\\max_{t} \\left| \\dfrac{L_{z}(t) - L_{z}(0)}{L_{z}(0)} \\right|$ (dimensionless).\n- The mean apsidal precession per orbit $\\langle \\Delta \\varpi \\rangle$ (in radians per orbit).\n- The frequency-map diffusion metric $D_{\\mathrm{FMA}}$ (in inverse time units).\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is itself a three-element list in the same order as above and in the same units, for the three test cases in the order listed. For example, an output with placeholders would look like $[\\,[x_{1},y_{1},z_{1}],\\,[x_{2},y_{2},z_{2}],\\,[x_{3},y_{3},z_{3}]\\,]$. All floats should be rendered in standard decimal notation without units. No additional text may be printed.", "solution": "The provided problem is a well-defined exercise in computational physics, specifically in the domain of celestial mechanics. It asks for the implementation and analysis of numerical integrators for the Keplerian two-body problem. The goal is to quantify the numerical errors inherent in different integration schemes by monitoring an exactly conserved quantity (angular momentum) and quantities whose conservation is a special feature of the inverse-square force law (the Laplace-Runge-Lenz vector). The problem is scientifically grounded, well-posed, and objective. We shall proceed with a detailed solution.\n\n###\n#### 1. Theoretical Framework\n\nThe problem under consideration is the motion of a test particle of mass ~$m$~ around a central mass ~$M$~, governed by Newton's law of universal gravitation. The equation of motion for the particle's position vector ~$\\mathbf{r}$~ is:\n$$ \\frac{d^2 \\mathbf{r}}{dt^2} = - \\mu \\frac{\\mathbf{r}}{\\lVert \\mathbf{r} \\rVert^3} $$\nwhere ~$\\mu = G M$~ is the standard gravitational parameter. For this problem, we operate in dimensionless code units where ~$\\mu = 1$~, the semi-major axis ~$a=1$~, and the mass of the test particle ~$m$~ is irrelevant as it cancels out.\n\nIn the analytical solution to this two-body problem, several quantities are conserved:\n1.  **Specific Orbital Energy ($E$):** ~$E = \\frac{1}{2} \\mathbf{v} \\cdot \\mathbf{v} - \\frac{\\mu}{\\lVert \\mathbf{r} \\rVert}$. Conservation of energy dictates that the orbit's size and shape (encoded in the semi-major axis ~$a$~ and eccentricity ~$e$~) remain constant.\n2.  **Specific Angular Momentum Vector ($\\mathbf{L}$):** ~$\\mathbf{L} = \\mathbf{r} \\times \\mathbf{v}$. Conservation of this vector implies that the orbital plane is fixed in space and that the rate at which area is swept out by the position vector is constant (Kepler's second law).\n3.  **Laplace-Runge-Lenz (LRL) Vector ($\\mathbf{A}$):** ~$\\mathbf{A} = \\mathbf{v} \\times \\mathbf{L} - \\mu \\frac{\\mathbf{r}}{\\lVert \\mathbf{r} \\rVert}$. This vector is a special conserved quantity for inverse-square force laws. It lies in the orbital plane and points from the central body to the orbit's periapsis (point of closest approach). Its conservation implies that the orbit's orientation is fixed, meaning the orbit is a closed ellipse that does not precess.\n\nNumerical integration schemes approximate the continuous evolution of the system with discrete time steps. This approximation inevitably introduces errors, causing these \"conserved\" quantities to drift over time. This drift manifests as unphysical changes in the orbit, such as secular increases in energy or spurious apsidal precession (a rotation of the line of apsides, i.e., the axis connecting periapsis and apoapsis). This problem requires us to quantify these errors for different numerical schemes.\n\n###\n#### 2. Numerical Integration Schemes\n\nWe will implement three standard ordinary differential equation (ODE) integrators to solve the system of first-order equations:\n$$ \\frac{d\\mathbf{r}}{dt} = \\mathbf{v} $$\n$$ \\frac{d\\mathbf{v}}{dt} = \\mathbf{a}(\\mathbf{r}) = -\\mu \\frac{\\mathbf{r}}{\\lVert \\mathbf{r} \\rVert^3} $$\n\n1.  **Forward Euler:** This is a first-order explicit method. It is simple but numerically unstable for conservative systems, leading to rapid accumulation of energy.\n    $$ \\mathbf{v}_{n+1} = \\mathbf{v}_n + \\mathbf{a}(\\mathbf{r}_n) \\Delta t $$\n    $$ \\mathbf{r}_{n+1} = \\mathbf{r}_n + \\mathbf{v}_n \\Delta t $$\n\n2.  **Velocity-Verlet (Leapfrog):** This is a second-order method widely used in molecular dynamics and celestial mechanics. It belongs to the class of *symplectic integrators*, which are designed to approximately conserve the symplectic two-form of Hamiltonian systems. For gravitational dynamics, this results in excellent long-term stability and bounded energy error, although not perfect conservation. Its position-update form is given by:\n    $$ \\mathbf{r}_{n+1} = \\mathbf{r}_n + \\mathbf{v}_n \\Delta t + \\frac{1}{2} \\mathbf{a}(\\mathbf{r}_n) \\Delta t^2 $$\n    $$ \\mathbf{v}_{n+1} = \\mathbf{v}_n + \\frac{1}{2} (\\mathbf{a}(\\mathbf{r}_n) + \\mathbf{a}(\\mathbf{r}_{n+1})) \\Delta t $$\n\n3.  **Classical Fourth-Order Runge-Kutta (RK4):** This is a popular and highly accurate fourth-order explicit method. While very precise for a given step size over short durations, it is not symplectic and will exhibit secular energy drift in long-term integrations of conservative systems. The update for a state vector ~$\\mathbf{y} = (\\mathbf{r}, \\mathbf{v})$~ and its derivative ~$\\mathbf{f}(t, \\mathbf{y}) = (\\mathbf{v}, \\mathbf{a}(\\mathbf{r}))$~ is:\n    $$ \\mathbf{k}_1 = \\mathbf{f}(t_n, \\mathbf{y}_n) $$\n    $$ \\mathbf{k}_2 = \\mathbf{f}(t_n + \\frac{\\Delta t}{2}, \\mathbf{y}_n + \\frac{\\Delta t}{2} \\mathbf{k}_1) $$\n    $$ \\mathbf{k}_3 = \\mathbf{f}(t_n + \\frac{\\Delta t}{2}, \\mathbf{y}_n + \\frac{\\Delta t}{2} \\mathbf{k}_2) $$\n    $$ \\mathbf{k}_4 = \\mathbf{f}(t_n + \\Delta t, \\mathbf{y}_n + \\Delta t \\mathbf{k}_3) $$\n    $$ \\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{\\Delta t}{6} (\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4) $$\n\n###\n#### 3. Diagnostic Metrics\n\nWe will use three distinct diagnostics to measure the performance of each integrator.\n\n1.  **Angular Momentum Deviation:** For planar motion, the specific angular momentum vector ~$\\mathbf{L}$~ should be perpendicular to the plane, with a constant magnitude ~$L_z = x v_y - y v_x$ . We compute this quantity at each time step ~$t$~ and report the maximum relative deviation from its initial value:\n    $$ \\max_{t} \\left| \\frac{L_z(t) - L_z(0)}{L_z(0)} \\right| $$\n    This metric directly probes the integrator's ability to preserve rotational symmetry. Note that for any purely central force, a carefully implemented Velocity-Verlet or other leapfrog scheme should conserve angular momentum to machine precision. Non-symplectic methods like Euler and RK4 will not.\n\n2.  **Spurious Apsidal Precession:** The rotation of the LRL vector ~$\\mathbf{A}$~ signifies apsidal precession. To measure this, we first integrate the orbit and record the time series of position ~$\\mathbf{r}(t)$~ and velocity ~$\\mathbf{v}(t)$~. We then perform the following steps:\n    - Identify pericenter passages by finding the times ~$t_k$~ corresponding to local minima of the radial distance ~$r(t) = \\lVert \\mathbf{r}(t) \\rVert$~. This is reliably done using a peak-finding algorithm on the signal ~$-r(t)$~.\n    - At each pericenter time ~$t_k$~~, calculate the LRL vector ~$\\mathbf{A}(t_k)$~.\n    - Compute the orientation of the LRL vector in the plane, ~$\\varpi_k = \\mathrm{atan2}(A_y(t_k), A_x(t_k))$~.\n    - The sequence of angles ~$\\{\\varpi_k\\}$~ is unwrapped to account for the ~$2\\pi$~ ambiguity, creating a continuous measure of precession.\n    - The mean apsidal precession rate per orbit is then calculated as the average of the absolute differences between consecutive unwrapped angles: ~$\\langle \\Delta \\varpi \\rangle = \\frac{1}{N_{\\mathrm{orb}} - 1} \\sum_{k=1}^{N_{\\mathrm{orb}} - 1} |\\tilde{\\varpi}_{k+1} - \\tilde{\\varpi}_k|$~, where ~$\\tilde{\\varpi}$~ is the unwrapped angle sequence.\n\n3.  **Frequency-Map Analysis (FMA):** This powerful technique analyzes the fundamental frequencies of the orbit. In a perfect Keplerian orbit, the radial frequency (of oscillation in ~$r$~) and the azimuthal frequency (of oscillation in polar angle ~$\\theta$~) are identical: ~$\\omega_r = \\omega_\\theta = \\omega_K = \\sqrt{\\mu/a^3}$~. Numerical errors break this degeneracy, leading to ~$\\omega_\\theta \\neq \\omega_r$~~. The difference, ~$\\Omega_{ap} = \\omega_\\theta - \\omega_r$~~, is the apsidal precession rate. Furthermore, long-term changes in these frequencies indicate chaotic behavior or secular evolution.\n    - **Radial Frequency ~$\\omega_r$`:** We compute the discrete Fourier transform of the time series of ~$r(t) - \\langle r \\rangle$~. The frequency of the dominant peak in the power spectrum, ~$f_r$~~, is converted to an angular frequency ~$\\omega_r = 2\\pi f_r$~~.\n    - **Azimuthal Frequency ~$\\omega_\\theta$`:** We compute the unwrapped polar angle ~$\\theta(t) = \\mathrm{atan2}(y(t), x(t))$~. The mean azimuthal frequency ~$\\omega_\\theta$~ is then determined as the slope of a linear least-squares fit to ~$\\theta(t)$~ versus ~$t$~~.\n    - **Diffusion Metric ~$D_{\\mathrm{FMA}}$`:** To quantify the long-term stability, we compute the pair of frequencies ~$(\\omega_r, \\omega_\\theta)$~ separately for the first and second halves of the total integration time. The diffusion metric ~$D_{\\mathrm{FMA}}$~ is the Euclidean distance between the frequency vectors from the two halves, measuring how much the fundamental frequencies have drifted over the course of the simulation.\n    $$ D_{\\mathrm{FMA}} = \\sqrt{(\\omega_r^{(2)} - \\omega_r^{(1)})^2 + (\\omega_\\theta^{(2)} - \\omega_\\theta^{(1)})^2} $$\n\n###\n#### 4. Implementation Procedure\n\nThe overall procedure is as follows:\n1.  Set the global parameters in code units: ~$\\mu=1$~, ~$a=1$~~. This gives an orbital period of ~$P = 2\\pi\\sqrt{a^3/\\mu} = 2\\pi$~. The total integration time is ~$T=50P = 100\\pi$~~.\n2.  For each of the three test cases specified:\n    a. Determine the eccentricity ~$e$~ and the time step ~$\\Delta t$~.\n    b. Set the initial conditions at pericenter: ~$\\mathbf{r}(0) = (a(1-e), 0)$~ and ~$\\mathbf{v}(0) = (0, \\sqrt{\\mu(1+e)/(a(1-e))})$~.\n    c. Integrate the orbit from ~$t=0$~ to ~$t=T$~ using the specified integrator, storing the full history of ~$(\\mathbf{r}(t), \\mathbf{v}(t))$~.\n    d. Apply the three diagnostic methods to the resulting trajectory to compute the maximum relative angular momentum deviation, the mean apsidal precession rate, and the FMA diffusion metric.\n3.  Collect the three resulting floating-point numbers for each case.\n4.  Format the final output as a list of lists, with each sublist containing the three computed metrics for one test case.\n\nThis systematic approach will allow for a direct and quantitative comparison of the long-term fidelity of the forward Euler, velocity-Verlet, and RK4 integration schemes.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.signal import find_peaks\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation and analysis for all test cases.\n    \"\"\"\n\n    def acceleration(r, mu=1.0):\n        \"\"\"Computes gravitational acceleration: a = -mu*r / |r|^3.\"\"\"\n        r_norm = np.linalg.norm(r)\n        if r_norm == 0:\n            return np.zeros_like(r)\n        return -mu * r / r_norm**3\n\n    def forward_euler_step(r, v, dt, mu=1.0):\n        \"\"\"Performs a single step of the Forward Euler integrator.\"\"\"\n        a = acceleration(r, mu)\n        r_new = r + v * dt\n        v_new = v + a * dt\n        return r_new, v_new\n\n    def velocity_verlet_step(r, v, dt, mu=1.0):\n        \"\"\"Performs a single step of the Velocity-Verlet integrator.\"\"\"\n        a = acceleration(r, mu)\n        r_new = r + v * dt + 0.5 * a * dt**2\n        a_new = acceleration(r_new, mu)\n        v_new = v + 0.5 * (a + a_new) * dt\n        return r_new, v_new\n\n    def rk4_step(r, v, dt, mu=1.0):\n        \"\"\"Performs a single step of the Classical RK4 integrator.\"\"\"\n        # k1\n        k1r = v\n        k1v = acceleration(r, mu)\n        \n        # k2\n        k2r = v + 0.5 * dt * k1v\n        k2v = acceleration(r + 0.5 * dt * k1r, mu)\n\n        # k3\n        k3r = v + 0.5 * dt * k2v\n        k3v = acceleration(r + 0.5 * dt * k2r, mu)\n\n        # k4\n        k4r = v + dt * k3v\n        k4v = acceleration(r + dt * k3r, mu)\n        \n        # Update\n        r_new = r + (dt / 6.0) * (k1r + 2.0 * k2r + 2.0 * k3r + k4r)\n        v_new = v + (dt / 6.0) * (k1v + 2.0 * k2v + 2.0 * k3v + k4v)\n        \n        return r_new, v_new\n\n    integrator_map = {\n        \"velocity-Verlet\": velocity_verlet_step,\n        \"forward Euler\": forward_euler_step,\n        \"classical fourth-order Runge–Kutta\": rk4_step,\n    }\n\n    def run_integration(integrator, r0, v0, T, dt, mu=1.0):\n        \"\"\"Integrates the orbit and returns the time series of phase space.\"\"\"\n        num_steps = int(T / dt)\n        times = np.linspace(0, T, num_steps + 1)\n        r, v = np.copy(r0), np.copy(v0)\n        \n        # Pre-allocate arrays\n        history_r = np.zeros((num_steps + 1, 2))\n        history_v = np.zeros((num_steps + 1, 2))\n        history_r[0], history_v[0] = r, v\n\n        for i in range(num_steps):\n            r, v = integrator(r, v, dt, mu)\n            history_r[i+1], history_v[i+1] = r, v\n        \n        return times, history_r, history_v\n\n    def analyze_trajectory(times, history_r, history_v, mu=1.0):\n        \"\"\"Performs all required diagnostic calculations on a trajectory.\"\"\"\n        \n        # 1. Angular Momentum Deviation\n        Lz = history_r[:, 0] * history_v[:, 1] - history_r[:, 1] * history_v[:, 0]\n        Lz0 = Lz[0]\n        if Lz0 == 0:\n            max_rel_L_dev = 0.0\n        else:\n            max_rel_L_dev = np.max(np.abs((Lz - Lz0) / Lz0))\n\n        # 2. Apsidal Precession\n        r_norm = np.linalg.norm(history_r, axis=1)\n        \n        # Find pericenters by finding peaks in -r(t)\n        # The distance between pericenters is roughly the orbital period in steps\n        P = 2 * np.pi * np.sqrt(a**3 / mu)\n        dt = times[1] - times[0]\n        peak_dist = 0.8 * (P / dt) # 80% of period to be safe\n        \n        pericenter_indices, _ = find_peaks(-r_norm, distance=peak_dist)\n        \n        if len(pericenter_indices)  2:\n            mean_d_varpi = 0.0  # Cannot compute precession without at least two pericenters\n        else:\n            r_peri = history_r[pericenter_indices]\n            v_peri = history_v[pericenter_indices]\n            \n            L_vectors = np.cross(r_peri, v_peri)\n            # For 2D, L vector is (0, 0, Lz). We need it as a 3D vector for the next cross product.\n            L_vectors_3d = np.zeros((len(L_vectors), 3))\n            L_vectors_3d[:, 2] = L_vectors\n            \n            v_peri_3d = np.zeros((len(v_peri), 3))\n            v_peri_3d[:, :2] = v_peri\n\n            r_peri_3d = np.zeros((len(r_peri), 3))\n            r_peri_3d[:, :2] = r_peri\n\n            A_vectors = np.cross(v_peri_3d, L_vectors_3d) - mu * r_peri_3d / np.linalg.norm(r_peri_3d, axis=1)[:, np.newaxis]\n            \n            varpi_angles = np.arctan2(A_vectors[:, 1], A_vectors[:, 0])\n            unwrapped_varpi = np.unwrap(varpi_angles)\n            \n            mean_d_varpi = np.mean(np.abs(np.diff(unwrapped_varpi)))\n        \n        # 3. Frequency-Map Analysis (FMA)\n        def get_frequencies(t_series, r_series):\n            # Radial frequency from FFT\n            r_norm_series = np.linalg.norm(r_series, axis=1)\n            signal = r_norm_series - np.mean(r_norm_series)\n            fft_vals = np.fft.rfft(signal)\n            fft_freq = np.fft.rfftfreq(len(t_series), d=t_series[1] - t_series[0])\n            peak_idx = np.argmax(np.abs(fft_vals[1:])) + 1 # ignore DC component\n            omega_r = 2 * np.pi * fft_freq[peak_idx]\n\n            # Azimuthal frequency from linear fit to unwrapped angle\n            theta = np.unwrap(np.arctan2(r_series[:, 1], r_series[:, 0]))\n            omega_theta, _ = np.polyfit(t_series, theta, 1)\n\n            return omega_r, omega_theta\n\n        n_pts = len(times)\n        mid_pt = n_pts // 2\n        \n        omega_r1, omega_theta1 = get_frequencies(times[:mid_pt], history_r[:mid_pt])\n        omega_r2, omega_theta2 = get_frequencies(times[mid_pt:], history_r[mid_pt:])\n\n        D_FMA = np.sqrt((omega_r2 - omega_r1)**2 + (omega_theta2 - omega_theta1)**2)\n\n        return max_rel_L_dev, mean_d_varpi, D_FMA\n\n    # Test suite parameters\n    test_cases = [\n        {\"name\": \"Case 1\", \"integrator\": \"velocity-Verlet\", \"e\": 0.1, \"dt_frac\": 1.0/1000.0},\n        {\"name\": \"Case 2\", \"integrator\": \"forward Euler\", \"e\": 0.1, \"dt_frac\": 1.0/200.0},\n        {\"name\": \"Case 3\", \"integrator\": \"classical fourth-order Runge–Kutta\", \"e\": 0.6, \"dt_frac\": 1.0/1000.0},\n    ]\n\n    results = []\n    mu = 1.0\n    a = 1.0\n    \n    for case in test_cases:\n        e = case[\"e\"]\n        \n        # Initial conditions at pericenter\n        r0 = np.array([a * (1 - e), 0.0])\n        v0_mag = np.sqrt(mu * (1 + e) / (a * (1 - e)))\n        v0 = np.array([0.0, v0_mag])\n        \n        # Time parameters\n        P = 2 * np.pi * np.sqrt(a**3 / mu)\n        T = 50 * P\n        dt = P * case[\"dt_frac\"]\n        \n        # Run simulation\n        integrator_func = integrator_map[case[\"integrator\"]]\n        times, history_r, history_v = run_integration(integrator_func, r0, v0, T, dt, mu)\n        \n        # Analyze and store results\n        res_tuple = analyze_trajectory(times, history_r, history_v, mu)\n        results.append(list(res_tuple))\n\n    # The problem asks for standard decimal notation. str() on a list of floats\n    # will produce a standard, readable representation that includes scientific e-notation\n    # for very small or large numbers. To conform strictly, we manually format the string.\n    # However, Python's default representation is generally unambiguous and standard.\n    # We will use the default `str` representation for simplicity and robustness.\n    # If a specific number of decimal places were required, a manual formatter would be used.\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "3509626"}, {"introduction": "We have seen that numerical integrators introduce errors, but the crucial long-term question is whether this error is a bounded, harmless oscillation or a secular drift that invalidates the simulation's physical realism. This distinction is the primary motivator for using symplectic methods. In this exercise [@problem_id:3509659], you will move from a simple two-body system to a more complex and dynamically rich hierarchical triple, a common configuration in stellar systems. You will implement a formal diagnostic protocol to quantitatively classify the energy error behavior produced by both symplectic and non-symplectic integrators, developing an essential skill for assessing the long-term validity of any N-body simulation.", "problem": "You are tasked with writing a complete, runnable program that implements and executes a numerical protocol to diagnose whether energy error in a hierarchical triple ($N=3$) gravitational system is bounded (oscillatory without net drift) or drifting (systematic trend in energy error over time). The protocol must be defined from first principles and expressed purely in mathematical and algorithmic terms. All computations must be performed in normalized units with gravitational constant $G=1$, and all positions, velocities, and times must be expressed in these same normalized units. Angles, if needed, must be expressed in radians.\n\nThe system consists of three point masses with Newtonian gravity. The governing ordinary differential equations (ODEs) are derived from Newton’s laws:\n- The acceleration of mass $i$ is $\\mathbf{a}_i = \\sum_{j \\neq i} G m_j \\dfrac{\\mathbf{r}_j - \\mathbf{r}_i}{\\lVert \\mathbf{r}_j - \\mathbf{r}_i \\rVert^3}$.\n- The velocity satisfies $\\dfrac{d\\mathbf{r}_i}{dt} = \\mathbf{v}_i$ and $\\dfrac{d\\mathbf{v}_i}{dt} = \\mathbf{a}_i$.\n\nDefine the hierarchical triple in coplanar, circular configuration using two characteristic scales:\n- Inner binary between masses $m_0$ and $m_1$ with semi-major axis $a_{\\mathrm{in}}$.\n- Outer orbit between the inner binary’s barycenter and mass $m_2$ with semi-major axis $a_{\\mathrm{out}}$.\n\nFor circular orbits, the two-body period $T$ at semi-major axis $a$ and total mass $M$ follows Kepler’s third law:\n$$T = 2\\pi \\sqrt{\\frac{a^3}{G M}}.$$\nUse this to compute the inner period $T_{\\mathrm{in}}$ with $M_{\\mathrm{in}} = m_0 + m_1$ and the outer period $T_{\\mathrm{out}}$ with $M_{\\mathrm{out}} = M_{\\mathrm{in}} + m_2$.\n\nProtocol specification:\n- Observables to compute and sample:\n  1. Total energy $E(t) = K(t) + U(t)$, where $K(t) = \\frac{1}{2}\\sum_i m_i \\lVert \\mathbf{v}_i(t) \\rVert^2$ and $U(t) = -\\sum_{ij} \\dfrac{G m_i m_j}{\\lVert \\mathbf{r}_i(t) - \\mathbf{r}_j(t) \\rVert}$.\n  2. Total linear momentum $\\mathbf{P}(t) = \\sum_i m_i \\mathbf{v}_i(t)$.\n- Sampling cadence: sample the observables at uniform interval $\\Delta t_{\\mathrm{samp}} = T_{\\mathrm{in}}/50$.\n- Duration: simulate for $T_{\\mathrm{sim}} = 3 T_{\\mathrm{out}}$.\n\nEnergy drift diagnosis rule:\n- Define the fractional energy error time series $e(t_k) = \\dfrac{E(t_k) - E(0)}{|E(0)|}$ at sampled times $t_k$.\n- Fit a line $e(t_k) \\approx c + s\\, t_k$ via Least Squares (LS) to obtain slope $s$ and intercept $c$.\n- Compute the residuals $r_k = e(t_k) - (c + s\\, t_k)$ and their root-mean-square (RMS) $\\sigma_{\\mathrm{res}} = \\sqrt{\\dfrac{1}{N}\\sum_k r_k^2}$.\n- Declare drifting energy error if $|s| T_{\\mathrm{sim}}  3 \\sigma_{\\mathrm{res}}$. Otherwise, declare bounded energy error.\n\nInitial conditions construction:\n- Masses: $m_0 = 1$, $m_1 = 1$, $m_2 = 0.5$.\n- Inner semi-major axis: $a_{\\mathrm{in}} = 1$.\n- Outer semi-major axis: $a_{\\mathrm{out}} = 10$.\n- Place the inner binary along the $x$-axis such that the separation is $a_{\\mathrm{in}}$, with center-of-mass (COM) at the origin. For equal masses $m_0=m_1$, positions are $\\mathbf{r}_0 = (+a_{\\mathrm{in}}/2, 0, 0)$ and $\\mathbf{r}_1 = (-a_{\\mathrm{in}}/2, 0, 0)$. Inner orbital angular frequency is $\\omega_{\\mathrm{in}} = \\sqrt{\\dfrac{G M_{\\mathrm{in}}}{a_{\\mathrm{in}}^3}}$, and velocities are $\\mathbf{v}_0 = (0, +\\omega_{\\mathrm{in}}\\, a_{\\mathrm{in}}/2, 0)$ and $\\mathbf{v}_1 = (0, -\\omega_{\\mathrm{in}}\\, a_{\\mathrm{in}}/2, 0)$.\n- Place $m_2$ at $\\mathbf{r}_2 = (a_{\\mathrm{out}}, 0, 0)$. The relative circular speed for the outer two-body orbit is $v_{\\mathrm{rel,out}} = \\sqrt{ \\dfrac{G M_{\\mathrm{out}}}{a_{\\mathrm{out}}} }$. The inner binary COM gets $\\mathbf{V}_{\\mathrm{COM,in}} = (0, - \\dfrac{m_2}{M_{\\mathrm{out}}} v_{\\mathrm{rel,out}}, 0)$, and $m_2$ gets $\\mathbf{v}_2 = (0, + \\dfrac{M_{\\mathrm{in}}}{M_{\\mathrm{out}}} v_{\\mathrm{rel,out}}, 0)$. The velocities of $m_0$ and $m_1$ are the sum of their inner orbital velocities and $\\mathbf{V}_{\\mathrm{COM,in}}$.\n\nIntegrator choices to implement:\n- Kick-Drift-Kick (KDK) velocity Verlet, a symplectic method.\n- Classical Runge-Kutta fourth order (RK4), a non-symplectic method.\n\nYour program must:\n1. Construct the initial hierarchical triple as above.\n2. For each test case, integrate the ODEs with the specified integrator and time-step, sample $E(t)$ and $\\mathbf{P}(t)$ at the specified cadence, and apply the drift diagnosis rule to produce a boolean classification per case.\n3. Aggregate and print the boolean classifications in the specified final output format.\n\nTest Suite:\n- Case $1$: integrator $=$ KDK velocity Verlet, time step $\\Delta t = T_{\\mathrm{in}}/200$.\n- Case $2$: integrator $=$ KDK velocity Verlet, time step $\\Delta t = T_{\\mathrm{in}}/60$.\n- Case $3$: integrator $=$ RK4, time step $\\Delta t = T_{\\mathrm{in}}/30$.\n- Case $4$: integrator $=$ RK4, time step $\\Delta t = T_{\\mathrm{in}}/50$.\n\nAnswer specification:\n- For each case, output a boolean where $True$ signifies drifting energy error and $False$ signifies bounded energy error under the rule $|s| T_{\\mathrm{sim}}  3 \\sigma_{\\mathrm{res}}$.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[result_1,result_2,result_3,result_4]$), with each $result_i$ a Python boolean.\n\nAll computations must be self-contained and require no user input. Use double precision floating point. The program must strictly adhere to the specified integrator definitions and protocol, and must implement the observables, sampling cadence, and duration exactly as stated.", "solution": "We begin from the governing physics of $N$-body Newtonian gravity. For $N=3$ point masses with gravitational constant $G=1$, the acceleration of mass $i$ is given by\n$$\\mathbf{a}_i = \\sum_{j \\neq i} m_j \\frac{\\mathbf{r}_j - \\mathbf{r}_i}{\\lVert \\mathbf{r}_j - \\mathbf{r}_i \\rVert^3},$$\nwith state evolution described by the ordinary differential equations (ODEs) $\\dfrac{d\\mathbf{r}_i}{dt} = \\mathbf{v}_i$ and $\\dfrac{d\\mathbf{v}_i}{dt} = \\mathbf{a}_i$. The total energy $E(t)$ combines kinetic energy $K(t)$ and potential energy $U(t)$:\n$$K(t) = \\frac{1}{2}\\sum_{i=0}^{2} m_i \\lVert \\mathbf{v}_i(t) \\rVert^2,\\quad U(t) = -\\sum_{0 \\le i  j \\le 2} \\frac{m_i m_j}{\\lVert \\mathbf{r}_i(t) - \\mathbf{r}_j(t) \\rVert}, \\quad E(t) = K(t) + U(t).$$\nTotal momentum is $\\mathbf{P}(t) = \\sum_{i=0}^{2} m_i \\mathbf{v}_i(t)$. For exact Newtonian dynamics, $E(t)$ and $\\mathbf{P}(t)$ are constants of motion; numerical integration introduces deviations that we aim to classify as bounded or drifting.\n\nWe consider a hierarchical triple constructed from two circular orbits. For the inner binary of $m_0$ and $m_1$ at semi-major axis $a_{\\mathrm{in}}$, the inner period is\n$$T_{\\mathrm{in}} = 2\\pi \\sqrt{\\frac{a_{\\mathrm{in}}^3}{M_{\\mathrm{in}}}}, \\quad M_{\\mathrm{in}} = m_0 + m_1.$$\nFor the outer orbit of the inner binary’s barycenter and $m_2$ at semi-major axis $a_{\\mathrm{out}}$, the outer period is\n$$T_{\\mathrm{out}} = 2\\pi \\sqrt{\\frac{a_{\\mathrm{out}}^3}{M_{\\mathrm{out}}}}, \\quad M_{\\mathrm{out}} = M_{\\mathrm{in}} + m_2.$$\nThe inner angular frequency is $\\omega_{\\mathrm{in}} = \\sqrt{\\dfrac{M_{\\mathrm{in}}}{a_{\\mathrm{in}}^3}}$, and the outer relative circular speed is $v_{\\mathrm{rel,out}} = \\sqrt{\\dfrac{M_{\\mathrm{out}}}{a_{\\mathrm{out}}}}$. Setting the inner binary positions to $\\mathbf{r}_0 = (+a_{\\mathrm{in}}/2, 0, 0)$ and $\\mathbf{r}_1 = (-a_{\\mathrm{in}}/2, 0, 0)$ ensures the inner center-of-mass (COM) is at the origin. The inner velocities are $\\mathbf{v}_0^{\\mathrm{inner}} = (0, +\\omega_{\\mathrm{in}}\\, a_{\\mathrm{in}}/2, 0)$ and $\\mathbf{v}_1^{\\mathrm{inner}} = (0, -\\omega_{\\mathrm{in}}\\, a_{\\mathrm{in}}/2, 0)$. Placing $m_2$ at $\\mathbf{r}_2 = (a_{\\mathrm{out}}, 0, 0)$, the outer orbit requires COM velocities $\\mathbf{V}_{\\mathrm{COM,in}} = (0, - \\frac{m_2}{M_{\\mathrm{out}}} v_{\\mathrm{rel,out}}, 0)$ and $\\mathbf{v}_2 = (0, + \\frac{M_{\\mathrm{in}}}{M_{\\mathrm{out}}} v_{\\mathrm{rel,out}}, 0)$. The full initial velocities of $m_0$ and $m_1$ are $\\mathbf{v}_0 = \\mathbf{v}_0^{\\mathrm{inner}} + \\mathbf{V}_{\\mathrm{COM,in}}$ and $\\mathbf{v}_1 = \\mathbf{v}_1^{\\mathrm{inner}} + \\mathbf{V}_{\\mathrm{COM,in}}$.\n\nWe implement two numerical integrators:\n- Kick-Drift-Kick (KDK) velocity Verlet: Given current positions $\\mathbf{r}$, velocities $\\mathbf{v}$, and accelerations $\\mathbf{a}(\\mathbf{r})$, the update over time step $\\Delta t$ is\n$$\\mathbf{v}^{n+\\frac{1}{2}} = \\mathbf{v}^n + \\frac{\\Delta t}{2}\\, \\mathbf{a}(\\mathbf{r}^n), \\quad \\mathbf{r}^{n+1} = \\mathbf{r}^n + \\Delta t\\, \\mathbf{v}^{n+\\frac{1}{2}}, \\quad \\mathbf{v}^{n+1} = \\mathbf{v}^{n+\\frac{1}{2}} + \\frac{\\Delta t}{2}\\, \\mathbf{a}(\\mathbf{r}^{n+1}).$$\nThis method is symplectic and typically yields bounded energy error oscillations for well-resolved time steps.\n- Classical Runge-Kutta fourth order (RK4): With state derivative $\\dot{\\mathbf{y}} = \\mathbf{f}(\\mathbf{y})$ for $\\mathbf{y} = (\\mathbf{r}, \\mathbf{v})$, the RK4 increment is\n$$\\mathbf{k}_1 = \\mathbf{f}(\\mathbf{y}^n), \\quad \\mathbf{k}_2 = \\mathbf{f}\\left(\\mathbf{y}^n + \\frac{\\Delta t}{2} \\mathbf{k}_1\\right), \\quad \\mathbf{k}_3 = \\mathbf{f}\\left(\\mathbf{y}^n + \\frac{\\Delta t}{2} \\mathbf{k}_2\\right), \\quad \\mathbf{k}_4 = \\mathbf{f}\\left(\\mathbf{y}^n + \\Delta t \\mathbf{k}_3\\right),$$\n$$\\mathbf{y}^{n+1} = \\mathbf{y}^n + \\frac{\\Delta t}{6}\\left(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4\\right).$$\nRK4 is non-symplectic, and for Hamiltonian problems such as gravity it often produces a slowly drifting energy error even at moderate time steps.\n\nObservables and sampling: We calculate $E(t)$ and $\\mathbf{P}(t)$ throughout the simulation. We sample these at $\\Delta t_{\\mathrm{samp}} = T_{\\mathrm{in}}/50$ to obtain a discrete series $E(t_k)$. The duration is $T_{\\mathrm{sim}} = 3 T_{\\mathrm{out}}$ to cover multiple outer periods, ensuring that secular trends can be detected.\n\nDiagnosis metric: We define the fractional energy error $e(t_k) = \\dfrac{E(t_k) - E(0)}{|E(0)|}$ and perform a linear Least Squares (LS) fit $e(t_k) \\approx c + s t_k$. We compute residuals $r_k = e(t_k) - (c + s t_k)$ and their root-mean-square (RMS) $\\sigma_{\\mathrm{res}} = \\sqrt{ \\dfrac{1}{N} \\sum_k r_k^2 }$. We classify the energy error as drifting if the net change attributable to slope over the simulation exceeds the random scatter by a factor of $3$, that is if $|s| T_{\\mathrm{sim}}  3 \\sigma_{\\mathrm{res}}$. Otherwise, we classify it as bounded.\n\nTest suite and expectations:\n- Case $1$ and Case $2$ (KDK velocity Verlet) with $\\Delta t = T_{\\mathrm{in}}/200$ and $\\Delta t = T_{\\mathrm{in}}/60$ respectively should exhibit bounded energy error due to symplecticity and appropriate time resolution.\n- Case $3$ and Case $4$ (RK4) with $\\Delta t = T_{\\mathrm{in}}/30$ and $\\Delta t = T_{\\mathrm{in}}/50$ respectively are expected to show detectable drift because non-symplectic integration accumulates small energy changes coherently over many steps in a Hamiltonian system.\n\nAlgorithmic steps:\n1. Compute $T_{\\mathrm{in}}$ and $T_{\\mathrm{out}}$ from $a_{\\mathrm{in}}$, $a_{\\mathrm{out}}$, $M_{\\mathrm{in}}$, and $M_{\\mathrm{out}}$.\n2. Construct initial positions and velocities as described, combining inner orbital motion with the outer COM motion.\n3. For each test case, set the integrator and $\\Delta t$, then integrate the ODEs up to $T_{\\mathrm{sim}}$ while sampling $E(t)$ and $\\mathbf{P}(t)$ at $\\Delta t_{\\mathrm{samp}}$.\n4. Compute $e(t_k)$, fit the LS line to obtain $s$ and $c$, compute $\\sigma_{\\mathrm{res}}$, and apply the drift rule $|s| T_{\\mathrm{sim}}  3 \\sigma_{\\mathrm{res}}$.\n5. Output a single line with a list of booleans corresponding to the four cases.\n\nThis protocol directly links the numerical behavior of energy in $N$-body simulations to the physics of conservation laws. The Kick-Drift-Kick method, being symplectic, preserves the qualitative boundedness of the Hamiltonian error, while non-symplectic RK4 tends to produce secular drift. The sampling cadence relative to $T_{\\mathrm{in}}$ ensures resolution of inner orbit dynamics, and the duration relative to $T_{\\mathrm{out}}$ ensures secular trends across the outer orbit are captured. The LS slope test provides a quantifiable, reproducible diagnostic that is robust to oscillatory bounded fluctuations.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nG = 1.0  # Normalized units\n\ndef gravitational_accelerations(r, m):\n    \"\"\"\n    Compute accelerations on each body due to Newtonian gravity.\n    r: (N,3) positions\n    m: (N,) masses\n    Returns a: (N,3) accelerations\n    \"\"\"\n    N = r.shape[0]\n    a = np.zeros_like(r)\n    for i in range(N):\n        # Vectorized contribution from all j != i\n        diff = r - r[i]\n        dist2 = np.sum(diff**2, axis=1)\n        mask = np.ones(N, dtype=bool)\n        mask[i] = False\n        inv_r3 = np.zeros(N)\n        # Avoid division by zero\n        inv_r3[mask] = 1.0 / (dist2[mask] ** 1.5)\n        contrib = (diff.T * (m * inv_r3)).T\n        a[i] = G * np.sum(contrib[mask], axis=0)\n    return a\n\ndef total_energy(r, v, m):\n    \"\"\"\n    Compute total energy E = K + U.\n    \"\"\"\n    # Kinetic energy\n    K = 0.5 * np.sum(m * np.sum(v*v, axis=1))\n    # Potential energy\n    U = 0.0\n    N = r.shape[0]\n    for i in range(N):\n        for j in range(i+1, N):\n            rij = r[j] - r[i]\n            dist = np.linalg.norm(rij)\n            U -= G * m[i] * m[j] / dist\n    return K + U\n\ndef total_momentum(v, m):\n    return np.sum((v.T * m).T, axis=0)\n\ndef inner_outer_periods(masses, a_in, a_out):\n    m0, m1, m2 = masses\n    M_in = m0 + m1\n    M_out = M_in + m2\n    T_in = 2.0 * np.pi * np.sqrt((a_in**3) / (G * M_in))\n    T_out = 2.0 * np.pi * np.sqrt((a_out**3) / (G * M_out))\n    return T_in, T_out, M_in, M_out\n\ndef initial_conditions(masses, a_in=1.0, a_out=10.0):\n    \"\"\"\n    Construct hierarchical triple initial conditions:\n    Inner binary m0-m1 circular, outer orbit of inner COM with m2 circular.\n    Co-planar, COM of inner at origin, m2 at (a_out, 0, 0).\n    \"\"\"\n    m0, m1, m2 = masses\n    T_in, T_out, M_in, M_out = inner_outer_periods(masses, a_in, a_out)\n    # Inner positions (equal masses assumed but general masses allowed)\n    r0 = np.array([+a_in * m1 / M_in, 0.0, 0.0])  # distance from inner COM\n    r1 = np.array([-a_in * m0 / M_in, 0.0, 0.0])\n    # Inner velocities for circular motion\n    omega_in = np.sqrt(G * M_in / (a_in**3))\n    # Tangential velocities perpendicular to radius\n    v0_inner = np.array([0.0, +omega_in * np.linalg.norm(r0), 0.0])\n    v1_inner = np.array([0.0, -omega_in * np.linalg.norm(r1), 0.0])\n\n    # Outer placement of m2 at +x\n    r2 = np.array([a_out, 0.0, 0.0])\n\n    # Outer relative motion: COM velocities\n    v_rel_out = np.sqrt(G * M_out / a_out)\n    V_COM_inner = np.array([0.0, - (m2 / M_out) * v_rel_out, 0.0])\n    v2 = np.array([0.0, + (M_in / M_out) * v_rel_out, 0.0])\n\n    # Inner bodies get COM velocity added\n    v0 = v0_inner + V_COM_inner\n    v1 = v1_inner + V_COM_inner\n\n    r = np.vstack([r0, r1, r2])\n    v = np.vstack([v0, v1, v2])\n\n    return r, v, T_in, T_out\n\ndef step_leapfrog(r, v, m, dt):\n    \"\"\"\n    Kick-Drift-Kick (velocity Verlet) one step.\n    \"\"\"\n    a = gravitational_accelerations(r, m)\n    v_half = v + 0.5 * dt * a\n    r_new = r + dt * v_half\n    a_new = gravitational_accelerations(r_new, m)\n    v_new = v_half + 0.5 * dt * a_new\n    return r_new, v_new\n\ndef step_rk4(r, v, m, dt):\n    \"\"\"\n    Classical RK4 one step for Newtonian gravity.\n    State y = [r, v].\n    \"\"\"\n    def f(r_state, v_state):\n        a_state = gravitational_accelerations(r_state, m)\n        return a_state\n\n    # k1\n    a1 = gravitational_accelerations(r, m)\n    kr1 = v\n    kv1 = a1\n\n    # k2\n    r2 = r + 0.5 * dt * kr1\n    v2 = v + 0.5 * dt * kv1\n    a2 = gravitational_accelerations(r2, m)\n    kr2 = v2\n    kv2 = a2\n\n    # k3\n    r3 = r + 0.5 * dt * kr2\n    v3 = v + 0.5 * dt * kv2\n    a3 = gravitational_accelerations(r3, m)\n    kr3 = v3\n    kv3 = a3\n\n    # k4\n    r4 = r + dt * kr3\n    v4 = v + dt * kv3\n    a4 = gravitational_accelerations(r4, m)\n    kr4 = v4\n    kv4 = a4\n\n    r_new = r + (dt / 6.0) * (kr1 + 2.0 * kr2 + 2.0 * kr3 + kr4)\n    v_new = v + (dt / 6.0) * (kv1 + 2.0 * kv2 + 2.0 * kv3 + kv4)\n    return r_new, v_new\n\ndef integrate_case(integrator, dt, T_sim, T_samp, masses, r0, v0):\n    \"\"\"\n    Integrate one case and sample energy  momentum at cadence T_samp.\n    Returns times samples and energy time series.\n    \"\"\"\n    r = r0.copy()\n    v = v0.copy()\n    m = np.array(masses, dtype=float)\n    t = 0.0\n    next_sample = 0.0\n\n    energies = []\n    times = []\n\n    E0 = total_energy(r, v, m)\n\n    # Choose step function\n    if integrator == 'leapfrog':\n        step_fn = step_leapfrog\n    elif integrator == 'rk4':\n        step_fn = step_rk4\n    else:\n        raise ValueError(\"Unknown integrator\")\n\n    # Ensure we sample at t=0\n    energies.append(E0)\n    times.append(0.0)\n    next_sample += T_samp\n\n    # Main loop\n    # Number of steps roughly T_sim/dt; use while to hit exact duration\n    while t  T_sim - 1e-12:\n        r, v = step_fn(r, v, m, dt)\n        t += dt\n        # Sample when crossing next_sample\n        if t + 1e-12 >= next_sample:\n            E = total_energy(r, v, m)\n            energies.append(E)\n            times.append(next_sample)  # use scheduled sample time\n            next_sample += T_samp\n\n    return np.array(times), np.array(energies)\n\ndef diagnose_drift(times, energies):\n    \"\"\"\n    Apply LS slope test to fractional energy error e(t) = (E(t)-E0)/|E0|.\n    Drifting if |s| * T_sim > 3 * sigma_res.\n    \"\"\"\n    E0 = energies[0]\n    e = (energies - E0) / abs(E0)\n    t = times\n    # Linear fit: degree 1 polynomial\n    # polyfit returns [slope, intercept]\n    s, c = np.polyfit(t, e, 1)\n    residuals = e - (s * t + c)\n    sigma_res = np.sqrt(np.mean(residuals**2))\n    T_sim = t[-1]\n    drifting = abs(s) * T_sim > 3.0 * sigma_res\n    return drifting\n\ndef solve():\n    # Define masses and initial configuration\n    masses = (1.0, 1.0, 0.5)\n    a_in = 1.0\n    a_out = 10.0\n    r0, v0, T_in, T_out = initial_conditions(masses, a_in, a_out)\n\n    # Sampling cadence and duration\n    T_samp = T_in / 50.0\n    T_sim = 3.0 * T_out\n\n    # Define the test cases from the problem statement.\n    # Each case is (integrator_type, time_step_denominator_relative_to_T_in)\n    test_cases = [\n        ('leapfrog', 200),  # Case 1\n        ('leapfrog', 60),   # Case 2\n        ('rk4', 30),        # Case 3\n        ('rk4', 50),        # Case 4\n    ]\n\n    results = []\n    for integrator, denom in test_cases:\n        dt = T_in / float(denom)\n        times, energies = integrate_case(integrator, dt, T_sim, T_samp, masses, r0, v0)\n        drift = diagnose_drift(times, energies)\n        results.append(drift)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3509659"}]}