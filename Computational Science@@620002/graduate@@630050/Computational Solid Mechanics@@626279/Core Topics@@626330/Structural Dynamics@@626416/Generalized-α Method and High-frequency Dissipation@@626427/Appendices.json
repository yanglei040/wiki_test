{"hands_on_practices": [{"introduction": "Implementing an implicit time integration scheme like the generalized-$\\alpha$ method requires reformulating the dynamic equations into a linear system that can be solved at each time step. This foundational exercise guides you through the essential algebraic steps to derive the method's \"effective stiffness matrix,\" $K_{\\text{eff}}$. Mastering this derivation is key to understanding how the method is structured computationally and how the various algorithmic parameters influence the system being solved. [@problem_id:3568325]", "problem": "Consider linear structural dynamics governed by the second-order initial value problem in computational solid mechanics,\n$$\nM \\ddot{u}(t) + C \\dot{u}(t) + K u(t) = f(t),\n$$\nwhere $M$, $C$, and $K$ are the mass, damping, and stiffness matrices, respectively, $u(t)$ is the displacement vector, $\\dot{u}(t)$ and $\\ddot{u}(t)$ are its velocity and acceleration, and $f(t)$ is the external force. Let the time grid be $t_n$ with uniform step $\\Delta t$. The generalized-$\\alpha$ method (with user-prescribed high-frequency spectral radius $\\rho_{\\infty} \\in [0,1]$) enforces equilibrium at weighted times using the definitions\n$$\nx_{n+\\alpha} := (1-\\alpha)\\,x_n + \\alpha\\,x_{n+1},\n$$\napplied to $x \\in \\{u,\\dot{u},\\ddot{u},f\\}$ with distinct weights $\\alpha_f$ and $\\alpha_m$ for force/displacement/velocity and acceleration, respectively. The kinematics of the displacement, velocity, and acceleration are related by the standard Newmark family,\n$$\nu_{n+1} = u_n + \\Delta t\\,\\dot{u}_n + \\Delta t^2\\left(\\tfrac{1}{2}-\\beta\\right)\\ddot{u}_n + \\beta \\Delta t^2 \\ddot{u}_{n+1},\n$$\n$$\n\\dot{u}_{n+1} = \\dot{u}_n + \\Delta t\\left(1-\\gamma\\right)\\ddot{u}_n + \\gamma \\Delta t\\,\\ddot{u}_{n+1},\n$$\nfor method parameters $\\beta$ and $\\gamma$. The generalized-$\\alpha$ equilibrium at the weighted time is\n$$\nM \\ddot{u}_{n+\\alpha_m} + C \\dot{u}_{n+\\alpha_f} + K u_{n+\\alpha_f} = f_{n+\\alpha_f}.\n$$\n\nTask A. Starting from the above base, manipulate the Newmark kinematics to write the predictor-corrector relations that express $u_{n+1}$ and $\\dot{u}_{n+1}$ explicitly in terms of the unknown acceleration $\\ddot{u}_{n+1}$ and known $n$-level quantities.\n\nTask B. Using the weighted equilibrium and these relations, construct the single-step linear system for the displacement increment $\\Delta u_{n+1} := u_{n+1} - u_n$ in the form\n$$\nK_{\\text{eff}}\\,\\Delta u_{n+1} = r_{\\text{eff}},\n$$\nidentifying both the effective matrix $K_{\\text{eff}}$ and the effective right-hand side $r_{\\text{eff}}$ in terms of $M$, $C$, $K$, $\\Delta t$, $\\alpha_f$, $\\alpha_m$, $\\beta$, $\\gamma$, and $n$-level data.\n\nTask C. Impose second-order accuracy and unconditional stability, together with the design requirement that the spectral radius at the infinite-frequency limit equals the prescribed $\\rho_{\\infty}$ (high-frequency numerical dissipation control). Derive the parameter relations $\\alpha_m(\\rho_{\\infty})$, $\\alpha_f(\\rho_{\\infty})$, $\\gamma(\\rho_{\\infty})$, and $\\beta(\\rho_{\\infty})$.\n\nFinal deliverable. Substitute these relations into your $K_{\\text{eff}}$ from Task B and simplify to obtain a single closed-form analytic expression $K_{\\text{eff}}(M,C,K,\\Delta t,\\rho_{\\infty})$ depending only on $M$, $C$, $K$, $\\Delta t$, and $\\rho_{\\infty}$. Provide this simplified $K_{\\text{eff}}$ expression as your final answer. Do not include units. No rounding is required.", "solution": "The problem statement is a standard derivation in the field of computational solid mechanics concerning the generalized-$\\alpha$ time integration method. It is scientifically grounded, well-posed, objective, and contains all necessary information. The problem is therefore deemed valid and a solution will be provided.\n\nThe problem is divided into three tasks leading to a final deliverable. We will address each in sequence.\n\n### Task A: Predictor-Corrector Relations\n\nThe Newmark kinematic relations provide expressions for the updated displacement $u_{n+1}$ and velocity $\\dot{u}_{n+1}$ at time $t_{n+1}$ based on the state at time $t_n$ and the new acceleration $\\ddot{u}_{n+1}$. These relations already serve as the requested predictor-corrector forms.\n\nThe displacement at step $n+1$ is given by:\n$$\nu_{n+1} = u_n + \\Delta t\\,\\dot{u}_n + \\Delta t^2\\left(\\frac{1}{2}-\\beta\\right)\\ddot{u}_n + \\beta \\Delta t^2 \\ddot{u}_{n+1}\n$$\nThis can be interpreted as a predictor step,\n$$\n\\tilde{u}_{n+1} = u_n + \\Delta t\\,\\dot{u}_n + \\Delta t^2\\left(\\frac{1}{2}-\\beta\\right)\\ddot{u}_n\n$$\nfollowed by a corrector step based on the unknown acceleration $\\ddot{u}_{n+1}$:\n$$\nu_{n+1} = \\tilde{u}_{n+1} + \\beta \\Delta t^2 \\ddot{u}_{n+1}\n$$\nSimilarly, the velocity at step $n+1$ is given by:\n$$\n\\dot{u}_{n+1} = \\dot{u}_n + \\Delta t\\left(1-\\gamma\\right)\\ddot{u}_n + \\gamma \\Delta t\\,\\ddot{u}_{n+1}\n$$\nThis can also be split into a predictor:\n$$\n\\tilde{\\dot{u}}_{n+1} = \\dot{u}_n + \\Delta t\\left(1-\\gamma\\right)\\ddot{u}_n\n$$\nand a corrector:\n$$\n\\dot{u}_{n+1} = \\tilde{\\dot{u}}_{n+1} + \\gamma \\Delta t\\,\\ddot{u}_{n+1}\n$$\nThe problem statement's original Newmark equations are the explicit relations sought.\n\n### Task B: Effective Stiffness System\n\nThe goal is to formulate a linear system of the form $K_{\\text{eff}}\\,\\Delta u_{n+1} = r_{\\text{eff}}$, where $\\Delta u_{n+1} = u_{n+1} - u_n$. This requires expressing all unknown quantities at step $n+1$ in terms of $\\Delta u_{n+1}$ and known quantities at step $n$.\n\nFrom the first Newmark relation, we can isolate $\\ddot{u}_{n+1}$:\n$$\n\\beta \\Delta t^2 \\ddot{u}_{n+1} = (u_{n+1} - u_n) - \\Delta t\\,\\dot{u}_n - \\Delta t^2\\left(\\frac{1}{2}-\\beta\\right)\\ddot{u}_n\n$$\n$$\n\\ddot{u}_{n+1} = \\frac{1}{\\beta \\Delta t^2}\\Delta u_{n+1} - \\frac{1}{\\beta \\Delta t}\\dot{u}_n - \\left(\\frac{1}{2\\beta}-1\\right)\\ddot{u}_n\n$$\nNext, we express $\\dot{u}_{n+1}$ by substituting the above into the second Newmark relation:\n$$\n\\dot{u}_{n+1} = \\dot{u}_n + \\Delta t(1-\\gamma)\\ddot{u}_n + \\gamma \\Delta t \\left[ \\frac{1}{\\beta \\Delta t^2}\\Delta u_{n+1} - \\frac{1}{\\beta \\Delta t}\\dot{u}_n - \\left(\\frac{1}{2\\beta}-1\\right)\\ddot{u}_n \\right]\n$$\n$$\n\\dot{u}_{n+1} = \\frac{\\gamma}{\\beta \\Delta t}\\Delta u_{n+1} + \\left(1-\\frac{\\gamma}{\\beta}\\right)\\dot{u}_n + \\Delta t\\left(1-\\frac{\\gamma}{2\\beta}\\right)\\ddot{u}_n\n$$\nThe displacement update is simply $u_{n+1} = u_n + \\Delta u_{n+1}$.\n\nNow, substitute these into the weighted equilibrium equation:\n$$\nM \\ddot{u}_{n+\\alpha_m} + C \\dot{u}_{n+\\alpha_f} + K u_{n+\\alpha_f} = f_{n+\\alpha_f}\n$$\nUsing the definitions $x_{n+\\alpha} = (1-\\alpha)x_n + \\alpha x_{n+1}$, we get:\n$$\nM ((1-\\alpha_m)\\ddot{u}_n + \\alpha_m \\ddot{u}_{n+1}) + C ((1-\\alpha_f)\\dot{u}_n + \\alpha_f \\dot{u}_{n+1}) + K ((1-\\alpha_f)u_n + \\alpha_f u_{n+1}) = (1-\\alpha_f)f_n + \\alpha_f f_{n+1}\n$$\nWe substitute the expressions for $\\ddot{u}_{n+1}$, $\\dot{u}_{n+1}$, and $u_{n+1}$ in terms of $\\Delta u_{n+1}$. Let's isolate the terms containing $\\Delta u_{n+1}$ on the left-hand side:\n$$\nM \\alpha_m \\left(\\frac{1}{\\beta \\Delta t^2}\\Delta u_{n+1}\\right) + C \\alpha_f \\left(\\frac{\\gamma}{\\beta \\Delta t}\\Delta u_{n+1}\\right) + K \\alpha_f (\\Delta u_{n+1}) + \\dots = \\dots\n$$\nThis gives the effective stiffness matrix, $K_{\\text{eff}}$:\n$$\nK_{\\text{eff}} = \\frac{\\alpha_m}{\\beta \\Delta t^2} M + \\frac{\\alpha_f \\gamma}{\\beta \\Delta t} C + \\alpha_f K\n$$\nThe remaining terms form the effective right-hand side, $r_{\\text{eff}}$.\n\n### Task C: Parameter Relations\n\nThe generalized-$\\alpha$ method parameters are determined by imposing three conditions: second-order accuracy, unconditional stability for linear systems, and user-controlled numerical dissipation, quantified by the spectral radius at the infinite frequency limit, $\\rho_{\\infty}$.\n\nThe standard relations for the Chung-Hulbert formulation, which provide second-order accuracy and optimal high-frequency dissipation, are:\n$$\n\\alpha_m = \\frac{2-\\rho_{\\infty}}{1+\\rho_{\\infty}}\n$$\n$$\n\\alpha_f = \\frac{1}{1+\\rho_{\\infty}}\n$$\nSecond-order accuracy requires:\n$$\n\\gamma = \\frac{1}{2} - \\alpha_m + \\alpha_f\n$$\nTo maximize high-frequency dissipation for a given $\\rho_{\\infty}$, the parameter $\\beta$ is chosen as:\n$$\n\\beta = \\frac{1}{4}(1-\\alpha_m+\\alpha_f)^2\n$$\nWe can now derive explicit expressions for $\\gamma$ and $\\beta$ in terms of $\\rho_{\\infty}$.\nFirst, for $\\gamma$:\n$$\n\\gamma = \\frac{1}{2} - \\frac{2-\\rho_{\\infty}}{1+\\rho_{\\infty}} + \\frac{1}{1+\\rho_{\\infty}} = \\frac{1}{2} - \\frac{1-\\rho_{\\infty}}{1+\\rho_{\\infty}} = \\frac{(1+\\rho_{\\infty}) - 2(1-\\rho_{\\infty})}{2(1+\\rho_{\\infty})} = \\frac{3\\rho_{\\infty}-1}{2(1+\\rho_{\\infty})}\n$$\nNext, for $\\beta$:\n$$\n1-\\alpha_m+\\alpha_f = 1 - \\frac{2-\\rho_{\\infty}}{1+\\rho_{\\infty}} + \\frac{1}{1+\\rho_{\\infty}} = 1 - \\frac{1-\\rho_{\\infty}}{1+\\rho_{\\infty}} = \\frac{(1+\\rho_{\\infty})-(1-\\rho_{\\infty})}{1+\\rho_{\\infty}} = \\frac{2\\rho_{\\infty}}{1+\\rho_{\\infty}}\n$$\n$$\n\\beta = \\frac{1}{4}\\left(\\frac{2\\rho_{\\infty}}{1+\\rho_{\\infty}}\\right)^2 = \\frac{1}{4}\\frac{4\\rho_{\\infty}^2}{(1+\\rho_{\\infty})^2} = \\frac{\\rho_{\\infty}^2}{(1+\\rho_{\\infty})^2}\n$$\nThus, the four parameters are defined as functions of $\\rho_{\\infty}$.\n\n### Final Deliverable: Simplified Effective Stiffness Matrix\n\nThe final step is to substitute the expressions for $\\alpha_m$, $\\alpha_f$, $\\gamma$, and $\\beta$ from Task C into the expression for $K_{\\text{eff}}$ derived in Task B.\n\nThe expression for $K_{\\text{eff}}$ is:\n$$\nK_{\\text{eff}} = \\frac{\\alpha_m}{\\beta \\Delta t^2} M + \\frac{\\alpha_f \\gamma}{\\beta \\Delta t} C + \\alpha_f K\n$$\nWe will compute each coefficient separately.\n\n1.  **Coefficient of $M$**:\n    $$\n    \\frac{\\alpha_m}{\\beta} = \\frac{\\left(\\frac{2-\\rho_{\\infty}}{1+\\rho_{\\infty}}\\right)}{\\left(\\frac{\\rho_{\\infty}^2}{(1+\\rho_{\\infty})^2}\\right)} = \\frac{2-\\rho_{\\infty}}{1+\\rho_{\\infty}} \\cdot \\frac{(1+\\rho_{\\infty})^2}{\\rho_{\\infty}^2} = \\frac{(2-\\rho_{\\infty})(1+\\rho_{\\infty})}{\\rho_{\\infty}^2}\n    $$\n    So, the term is $\\frac{(2-\\rho_{\\infty})(1+\\rho_{\\infty})}{\\rho_{\\infty}^2 \\Delta t^2} M$.\n\n2.  **Coefficient of $C$**:\n    $$\n    \\frac{\\alpha_f \\gamma}{\\beta} = \\frac{\\left(\\frac{1}{1+\\rho_{\\infty}}\\right) \\left(\\frac{3\\rho_{\\infty}-1}{2(1+\\rho_{\\infty})}\\right)}{\\left(\\frac{\\rho_{\\infty}^2}{(1+\\rho_{\\infty})^2}\\right)} = \\frac{3\\rho_{\\infty}-1}{2(1+\\rho_{\\infty})^2} \\cdot \\frac{(1+\\rho_{\\infty})^2}{\\rho_{\\infty}^2} = \\frac{3\\rho_{\\infty}-1}{2\\rho_{\\infty}^2}\n    $$\n    So, the term is $\\frac{3\\rho_{\\infty}-1}{2\\rho_{\\infty}^2 \\Delta t} C$.\n\n3.  **Coefficient of $K$**:\n    $$\n    \\alpha_f = \\frac{1}{1+\\rho_{\\infty}}\n    $$\n    So, the term is $\\frac{1}{1+\\rho_{\\infty}} K$.\n\nCombining these results, the final closed-form analytic expression for the effective stiffness matrix is:\n$$\nK_{\\text{eff}}(M,C,K,\\Delta t,\\rho_{\\infty}) = \\frac{(2-\\rho_{\\infty})(1+\\rho_{\\infty})}{\\rho_{\\infty}^2 \\Delta t^2} M + \\frac{3\\rho_{\\infty}-1}{2\\rho_{\\infty}^2 \\Delta t} C + \\frac{1}{1+\\rho_{\\infty}} K\n$$\nThis expression depends only on the system matrices $M, C, K$, the time step $\\Delta t$, and the high-frequency spectral radius $\\rho_{\\infty}$, as required.", "answer": "$$\n\\boxed{\\frac{(2-\\rho_{\\infty})(1+\\rho_{\\infty})}{\\rho_{\\infty}^2 \\Delta t^2} M + \\frac{3\\rho_{\\infty}-1}{2\\rho_{\\infty}^2 \\Delta t} C + \\frac{1}{1+\\rho_{\\infty}} K}\n$$", "id": "3568325"}, {"introduction": "The primary advantage of the generalized-$\\alpha$ method is its user-controllable high-frequency dissipation, which is crucial for filtering out spurious oscillations that often arise from spatial discretization in finite element analysis. This problem provides a tangible application of this feature, asking you to connect the physical properties of a discretized bar to its highest natural frequency. You will then use the spectral radius, $\\rho_{\\infty}$, to quantify how effectively the algorithm damps this unwanted high-frequency response. [@problem_id:3568272]", "problem": "A uniform prismatic bar is modeled in one spatial dimension under small-strain, linear-elastic, longitudinal motion with no external damping. The bar has Young’s modulus $E = 210 \\,\\text{GPa}$, mass density $\\rho = 7800 \\,\\text{kg/m}^3$, and length $L = 1.0 \\,\\text{m}$. The finite element semi-discrete model uses linear shape functions on a uniform mesh with $N_{e} = 100$ elements, so the nodal spacing is $h = L/N_{e}$. The time integration is performed by the generalized-$\\alpha$ method, configured with spectral radius at infinity $\\rho_{\\infty} = 0.5$.\n\nStarting only from fundamental laws and core definitions, proceed as follows:\n- Use Newton’s second law for a continuum and the one-dimensional constitutive relation to obtain the longitudinal wave speed $c$ for the bar.\n- Using spatial sampling considerations for a nodal grid with spacing $h$, identify the highest resolvable wavenumber $k_{\\max}$ that can be represented on the mesh and estimate the corresponding highest resolvable angular frequency $\\omega_{\\max}$ of the semi-discrete model.\n- Using the definition of spectral radius at infinity $\\rho_{\\infty}$ for the generalized-$\\alpha$ method and its implication for the asymptotic high-frequency amplification factor per time step, determine the minimal integer number of time steps $n$ required to reduce the amplitude of the $\\omega_{\\max}$ mode by a factor $10^{-3}$.\n\nReport the following:\n1. The estimate of the highest resolvable angular frequency $\\omega_{\\max}$ in radians per second, rounded to four significant figures.\n2. The minimal integer number of time steps $n$.\n\nExpress the final answer as a two-entry row in the form $\\left(\\omega_{\\max}, n\\right)$. Do not include units in the final answer box, but use radians per second for $\\omega_{\\max}$ in your calculations as specified above.", "solution": "The problem statement has been validated and is deemed valid. It is scientifically grounded in continuum mechanics and computational methods, well-posed with sufficient and consistent data, and objectively stated.\n\nThe solution proceeds in three parts as requested.\n\nFirst, we derive the longitudinal wave speed $c$ for the uniform prismatic bar. We apply Newton's second law to a differential element of the bar with cross-sectional area $A$, length $dx$, and mass density $\\rho$. The mass of the element is $dm = \\rho A dx$. The net force on the element is the difference in stress $\\sigma$ over its length, $dF = (\\sigma(x+dx) - \\sigma(x))A \\approx \\frac{\\partial\\sigma}{\\partial x} A dx$. Newton's second law, $dF = (dm) a$, where the acceleration is $a = \\frac{\\partial^2 u}{\\partial t^2}$ for longitudinal displacement $u(x,t)$, becomes:\n$$ \\frac{\\partial\\sigma}{\\partial x} A dx = (\\rho A dx) \\frac{\\partial^2 u}{\\partial t^2} $$\nThis simplifies to the one-dimensional equation of motion:\n$$ \\frac{\\partial\\sigma}{\\partial x} = \\rho \\frac{\\partial^2 u}{\\partial t^2} $$\nFor a linear-elastic material under small strain, the constitutive relation is $\\sigma = E \\epsilon$, where $E$ is Young's modulus and $\\epsilon$ is the axial strain. The strain is defined as the spatial gradient of the displacement, $\\epsilon = \\frac{\\partial u}{\\partial x}$. Substituting this into the constitutive relation gives $\\sigma = E \\frac{\\partial u}{\\partial x}$.\nNext, we substitute this expression for stress into the equation of motion:\n$$ \\frac{\\partial}{\\partial x} \\left( E \\frac{\\partial u}{\\partial x} \\right) = \\rho \\frac{\\partial^2 u}{\\partial t^2} $$\nSince the bar is uniform, its properties $E$ and $\\rho$ are constant, so we can write:\n$$ E \\frac{\\partial^2 u}{\\partial x^2} = \\rho \\frac{\\partial^2 u}{\\partial t^2} $$\nRearranging this equation yields the classical one-dimensional wave equation:\n$$ \\frac{\\partial^2 u}{\\partial t^2} = \\frac{E}{\\rho} \\frac{\\partial^2 u}{\\partial x^2} $$\nBy comparing this to the canonical form $\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\frac{\\partial^2 u}{\\partial x^2}$, we identify the square of the wave speed as $c^2 = \\frac{E}{\\rho}$. Thus, the longitudinal wave speed is $c = \\sqrt{\\frac{E}{\\rho}}$.\nGiven the values $E = 210 \\,\\text{GPa} = 210 \\times 10^9 \\,\\text{Pa}$ and $\\rho = 7800 \\,\\text{kg/m}^3$, the wave speed is:\n$$ c = \\sqrt{\\frac{210 \\times 10^9}{7800}} \\,\\text{m/s} $$\n\nSecond, we estimate the highest resolvable angular frequency $\\omega_{\\max}$. The bar of length $L = 1.0 \\,\\text{m}$ is discretized into $N_{e} = 100$ uniform finite elements. The nodal spacing is therefore $h = \\frac{L}{N_{e}} = \\frac{1.0}{100} = 0.01 \\,\\text{m}$.\nSpatial sampling theory dictates that a grid with spacing $h$ can, at best, represent a wave with a minimum wavelength of $\\lambda_{\\min} = 2h$. This is the spatial equivalent of the Nyquist-Shannon sampling theorem. This mode corresponds to a nodal displacement pattern of alternating signs (e.g., $..., +1, -1, +1, -1, ...$). The highest resolvable wavenumber $k_{\\max}$ is associated with this minimum wavelength:\n$$ k_{\\max} = \\frac{2\\pi}{\\lambda_{\\min}} = \\frac{2\\pi}{2h} = \\frac{\\pi}{h} $$\nThe problem asks for an estimate of the corresponding highest angular frequency $\\omega_{\\max}$. The simplest and most direct estimate is obtained by using the non-dispersive dispersion relation from the continuum wave equation, $\\omega = c k$. Applying this to the highest wavenumber gives:\n$$ \\omega_{\\max} = c k_{\\max} = c \\frac{\\pi}{h} $$\nSubstituting the expressions for $c$ and $h$:\n$$ \\omega_{\\max} = \\left( \\sqrt{\\frac{210 \\times 10^9}{7800}} \\right) \\frac{\\pi}{0.01} = 100\\pi \\sqrt{\\frac{210 \\times 10^9}{7800}} \\,\\text{rad/s} $$\nNumerically, this evaluates to:\n$$ \\omega_{\\max} \\approx 1630080.3 \\,\\text{rad/s} $$\nAs per the problem's requirement, rounding this value to four significant figures gives:\n$$ \\omega_{\\max} \\approx 1.630 \\times 10^6 \\,\\text{rad/s} $$\n\nThird, we determine the minimal number of time steps $n$ required to achieve the desired amplitude reduction for the highest frequency mode. The generalized-$\\alpha$ method is characterized by a parameter $\\rho_{\\infty}$, the spectral radius at infinity. This parameter defines the asymptotic behavior of the numerical amplification factor, $A(\\Omega)$, as the non-dimensional frequency $\\Omega = \\omega \\Delta t$ approaches infinity:\n$$ \\rho_{\\infty} = \\lim_{\\Omega \\to \\infty} |A(\\Omega)| $$\nFor the highest frequency modes of the semi-discrete system, such as the mode with frequency $\\omega_{\\max}$, the amplification factor per time step is approximated by $\\rho_{\\infty}$. Let the initial amplitude of the $\\omega_{\\max}$ mode be $A_0$. After $n$ time steps, its amplitude $A_n$ will be approximately:\n$$ A_n \\approx A_0 (\\rho_{\\infty})^n $$\nThe problem requires the amplitude to be reduced by a factor of $10^{-3}$, which means the ratio of the final to initial amplitude must be $A_n / A_0 \\le 10^{-3}$. This leads to the inequality:\n$$ (\\rho_{\\infty})^n \\le 10^{-3} $$\nWe are given $\\rho_{\\infty} = 0.5$. Substituting this value:\n$$ (0.5)^n \\le 10^{-3} $$\nTo solve for $n$, we take the natural logarithm of both sides:\n$$ \\ln\\left((0.5)^n\\right) \\le \\ln(10^{-3}) $$\nUsing the property of logarithms $\\ln(a^b) = b\\ln(a)$:\n$$ n \\ln(0.5) \\le -3 \\ln(10) $$\nSince $\\ln(0.5) = -\\ln(2)$ is a negative value, dividing by it reverses the inequality sign:\n$$ n \\ge \\frac{-3 \\ln(10)}{-\\ln(2)} = \\frac{3 \\ln(10)}{\\ln(2)} $$\nUsing the standard values $\\ln(10) \\approx 2.302585$ and $\\ln(2) \\approx 0.693147$:\n$$ n \\ge \\frac{3 \\times 2.302585}{0.693147} \\approx 9.96578 $$\nSince the number of time steps $n$ must be an integer, we must find the smallest integer that satisfies this condition. This is obtained by taking the ceiling of the value:\n$$ n = \\lceil 9.96578 \\rceil = 10 $$\nTherefore, a minimum of $10$ time steps are required.\n\nThe final answer consists of the estimated highest angular frequency $\\omega_{\\max}$ rounded to four significant figures and the minimal integer number of time steps $n$.\n$$ (\\omega_{\\max}, n) = (1.630 \\times 10^6, 10) $$", "answer": "$$\n\\boxed{\n(1.630 \\times 10^6, 10)\n}\n$$", "id": "3568272"}, {"introduction": "There is no substitute for implementation when it comes to truly understanding a numerical algorithm. This practice challenges you to build a working time-integrator based on the generalized-$\\alpha$ method for a single-degree-of-freedom system. By simulating the system's response to different conditions and tracking its mechanical energy over time, you will directly observe and verify the method's dissipative properties in action. [@problem_id:3521406]", "problem": "Consider a Single Degree of Freedom (SDOF) oscillator representing the effective-stress skeleton response of a saturated soil element under dynamic loading. The governing equation is the effective-stress form of Newton's second law,\n$$\nm\\,\\ddot{x}(t) + c\\,\\dot{x}(t) + k\\,x(t) = F_{\\mathrm{eff}}(t),\n$$\nwhere $m$ is mass, $c$ is viscous damping, $k$ is the elastic stiffness of the soil skeleton, $x(t)$ is displacement, and $F_{\\mathrm{eff}}(t)$ is the effective external driving force obtained from the total stress minus pore pressure contribution according to the principle of effective stress. For a one-dimensional representation consistent with Terzaghi's principle of effective stress, the driving force may be conceptualized as\n$$\nF_{\\mathrm{eff}}(t) = F_{\\mathrm{tot}}(t)\\,\\left(1 - r_u(t)\\right),\n$$\nwhere $F_{\\mathrm{tot}}(t)$ is a physically plausible transient load and $r_u(t)$ is the pore pressure ratio ramping from $0$ to a prescribed maximum during loading.\n\nYou are required to discretize in time using the generalized-$\\alpha$ method with parameters chosen to enforce second-order accuracy and controlled high-frequency algorithmic dissipation via a prescribed spectral radius at infinity. The generalized-$\\alpha$ method introduces two parameters $\\alpha_m$ and $\\alpha_f$ and redefines equilibrium at a weighted time level $t_{n+\\alpha_f}$ using weighted kinematics at $t_{n+\\alpha_m}$. The discrete kinematic update relations are of the Newmark family with parameters $\\gamma$ and $\\beta$,\n$$\nx_{n+1} = x_n + \\Delta t\\,v_n + \\Delta t^2\\left(\\tfrac{1}{2} - \\beta\\right)a_n + \\beta\\,\\Delta t^2\\,a_{n+1},\n$$\n$$\nv_{n+1} = v_n + \\Delta t\\left(1 - \\gamma\\right)a_n + \\gamma\\,\\Delta t\\,a_{n+1},\n$$\nand the equilibrium is enforced at the generalized time levels,\n$$\nm\\,a_{n+\\alpha_m} + c\\,v_{n+\\alpha_f} + k\\,x_{n+\\alpha_f} = F_{n+\\alpha_f},\n$$\nwhere\n$$\na_{n+\\alpha_m} = \\left(1 - \\alpha_m\\right)a_{n+1} + \\alpha_m\\,a_n,\\quad\nv_{n+\\alpha_f} = \\left(1 - \\alpha_f\\right)v_{n+1} + \\alpha_f\\,v_n,\\quad\nx_{n+\\alpha_f} = \\left(1 - \\alpha_f\\right)x_{n+1} + \\alpha_f\\,x_n,\n$$\nand $F_{n+\\alpha_f} = \\left(1 - \\alpha_f\\right)F_{n+1} + \\alpha_f\\,F_n$. The parameters must be computed from the spectral radius at infinity $\\rho_\\infty$ to achieve second-order accuracy and unconditional stability:\n$$\n\\alpha_m = \\frac{2 - \\rho_\\infty}{1 + \\rho_\\infty},\\quad\n\\alpha_f = \\frac{1}{1 + \\rho_\\infty},\\quad\n\\gamma = \\tfrac{1}{2} - \\alpha_m + \\alpha_f,\\quad\n\\beta = \\tfrac{1}{4}\\left(1 - \\alpha_m + \\alpha_f\\right)^2.\n$$\n\nThe discrete mechanical energy at time step $n$ is\n$$\nE_n = \\tfrac{1}{2} k\\,x_n^2 + \\tfrac{1}{2} m\\,v_n^2,\n$$\nexpressed in Joules. To verify algorithmic dissipation, you must compute the sequence $\\{E_n\\}$ and check, after the transient load ceases at a known cutoff time $t_{\\mathrm{off}}$, whether the mechanical energy is non-increasing in $n$ (allowing for negligible numerical tolerance), i.e., $E_{n+1} \\le E_n$ for all time steps with $t_n \\ge t_{\\mathrm{off}}$.\n\nUse the following fixed physical parameters for all tests: $k = 1\\,\\mathrm{MN/m} = 10^6\\,\\mathrm{N/m}$, $m = 1000\\,\\mathrm{kg}$, $c = 1000\\,\\mathrm{N\\cdot s/m}$, $\\Delta t = 0.005\\,\\mathrm{s}$, and $\\rho_\\infty = 0.5$. For initial conditions, use $x_0$ and $v_0$ as specified per test case and compute $a_0 = \\left(F_{\\mathrm{eff}}(0) - c\\,v_0 - k\\,x_0\\right)/m$.\n\nImplement three test cases forming a test suite:\n- Test $1$ (general transient loading with effective-stress reduction): $F_{\\mathrm{tot}}(t) = F_0\\sin\\left(\\pi t / T_p\\right)$ for $0 \\le t \\le T_p$ and $F_{\\mathrm{tot}}(t) = 0$ otherwise, with $F_0 = 100000\\,\\mathrm{N}$, $T_p = 0.5\\,\\mathrm{s}$, $r_u(t) = r_{u,\\max}\\left(t/T_p\\right)$ for $0 \\le t \\le T_p$ ramping to $r_{u,\\max} = 0.4$, and $r_u(t) = r_{u,\\max}$ for $t > T_p$. Use $x_0 = 0\\,\\mathrm{m}$ and $v_0 = 0\\,\\mathrm{m/s}$. Simulate to $T_{\\mathrm{total}} = 3.0\\,\\mathrm{s}$. The cutoff time is $t_{\\mathrm{off}} = T_p$.\n- Test $2$ (free vibration boundary case): $F_{\\mathrm{tot}}(t) = 0$ for all $t$, $r_u(t) = 0$, $x_0 = 0.01\\,\\mathrm{m}$, $v_0 = 0\\,\\mathrm{m/s}$, simulate to $T_{\\mathrm{total}} = 3.0\\,\\mathrm{s}$. The cutoff time is $t_{\\mathrm{off}} = 0$.\n- Test $3$ (short, high-frequency transient): $F_{\\mathrm{tot}}(t) = F_0\\sin\\left(\\pi t / T_p\\right)$ for $0 \\le t \\le T_p$ and $F_{\\mathrm{tot}}(t) = 0$ otherwise, with $F_0 = 100000\\,\\mathrm{N}$, $T_p = 0.05\\,\\mathrm{s}$, $r_u(t) = 0$, $x_0 = 0\\,\\mathrm{m}$, $v_0 = 0\\,\\mathrm{m/s}$, simulate to $T_{\\mathrm{total}} = 1.0\\,\\mathrm{s}$. The cutoff time is $t_{\\mathrm{off}} = T_p$.\n\nFor each test, compute the discrete energy sequence $\\{E_n\\}$ and return a boolean indicating whether the energy is non-increasing for all time steps with $t_n \\ge t_{\\mathrm{off}}$, using a small numerical tolerance criterion that is physically reasonable. Express energies in Joules internally; the returned result per test is a boolean. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets in the exact format $[b_1,b_2,b_3]$, where each $b_i$ is either $\\mathrm{True}$ or $\\mathrm{False}$, and no spaces are permitted in the output line.", "solution": "The user has provided a well-defined problem in computational dynamics, specifically focusing on the time integration of a Single Degree of Freedom (SDOF) system representing a soil element's response. The problem requires the implementation of the generalized-$\\alpha$ method for time discretization and verification of the method's dissipative properties.\n\n### Step 1: Extract Givens\n- **Governing Equation**: $m\\,\\ddot{x}(t) + c\\,\\dot{x}(t) + k\\,x(t) = F_{\\mathrm{eff}}(t)$\n- **Effective Force**: $F_{\\mathrm{eff}}(t) = F_{\\mathrm{tot}}(t)\\,\\left(1 - r_u(t)\\right)$\n- **Numerical Method**: Generalized-$\\alpha$ method.\n- **Kinematic Updates (Newmark family)**:\n  - $x_{n+1} = x_n + \\Delta t\\,v_n + \\Delta t^2\\left(\\tfrac{1}{2} - \\beta\\right)a_n + \\beta\\,\\Delta t^2\\,a_{n+1}$\n  - $v_{n+1} = v_n + \\Delta t\\left(1 - \\gamma\\right)a_n + \\gamma\\,\\Delta t\\,a_{n+1}$\n- **Discrete Equilibrium Equation**: $m\\,a_{n+\\alpha_m} + c\\,v_{n+\\alpha_f} + k\\,x_{n+\\alpha_f} = F_{n+\\alpha_f}$\n- **Weighted State Variables**:\n  - $a_{n+\\alpha_m} = \\left(1 - \\alpha_m\\right)a_{n+1} + \\alpha_m\\,a_n$\n  - $v_{n+\\alpha_f} = \\left(1 - \\alpha_f\\right)v_{n+1} + \\alpha_f\\,v_n$\n  - $x_{n+\\alpha_f} = \\left(1 - \\alpha_f\\right)x_{n+1} + \\alpha_f\\,x_n$\n  - $F_{n+\\alpha_f} = \\left(1 - \\alpha_f\\right)F_{n+1} + \\alpha_f\\,F_n$\n- **Generalized-$\\alpha$ Parameter Formulas**:\n  - $\\alpha_m = \\frac{2 - \\rho_\\infty}{1 + \\rho_\\infty}$\n  - $\\alpha_f = \\frac{1}{1 + \\rho_\\infty}$\n  - $\\gamma = \\tfrac{1}{2} - \\alpha_m + \\alpha_f$\n  - $\\beta = \\tfrac{1}{4}\\left(1 - \\alpha_m + \\alpha_f\\right)^2$\n- **Discrete Mechanical Energy**: $E_n = \\tfrac{1}{2} k\\,x_n^2 + \\tfrac{1}{2} m\\,v_n^2$\n- **Validation Criterion**: For $t_n \\ge t_{\\mathrm{off}}$, verify if $E_{n+1} \\le E_n$ within a small numerical tolerance.\n- **Fixed Physical Parameters**:\n  - $k = 10^6\\,\\mathrm{N/m}$\n  - $m = 1000\\,\\mathrm{kg}$\n  - $c = 1000\\,\\mathrm{N\\cdot s/m}$\n  - $\\Delta t = 0.005\\,\\mathrm{s}$\n  - $\\rho_\\infty = 0.5$\n- **Initial Acceleration**: $a_0 = \\left(F_{\\mathrm{eff}}(0) - c\\,v_0 - k\\,x_0\\right)/m$\n- **Test Case 1**:\n  - $F_{\\mathrm{tot}}(t) = 100000\\sin\\left(\\pi t / 0.5\\right)$ for $t \\in [0, 0.5]$, $0$ otherwise.\n  - $r_u(t) = 0.4(t/0.5)$ for $t \\in [0, 0.5]$, $0.4$ otherwise.\n  - $x_0 = 0\\,\\mathrm{m}$, $v_0 = 0\\,\\mathrm{m/s}$.\n  - $T_{\\mathrm{total}} = 3.0\\,\\mathrm{s}$, $t_{\\mathrm{off}} = 0.5\\,\\mathrm{s}$.\n- **Test Case 2**:\n  - $F_{\\mathrm{tot}}(t) = 0$, $r_u(t) = 0$.\n  - $x_0 = 0.01\\,\\mathrm{m}$, $v_0 = 0\\,\\mathrm{m/s}$.\n  - $T_{\\mathrm{total}} = 3.0\\,\\mathrm{s}$, $t_{\\mathrm{off}} = 0\\,\\mathrm{s}$.\n- **Test Case 3**:\n  - $F_{\\mathrm{tot}}(t) = 100000\\sin\\left(\\pi t / 0.05\\right)$ for $t \\in [0, 0.05]$, $0$ otherwise.\n  - $r_u(t) = 0$.\n  - $x_0 = 0\\,\\mathrm{m}$, $v_0 = 0\\,\\mathrm{m/s}$.\n  - $T_{\\mathrm{total}} = 1.0\\,\\mathrm{s}$, $t_{\\mathrm{off}} = 0.05\\,\\mathrm{s}$.\n- **Output Format**: Single line, `[b_1,b_2,b_3]`, where $b_i \\in \\{\\mathrm{True}, \\mathrm{False}\\}$ with no spaces.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is scientifically grounded, drawing upon Newton's second law, Terzaghi's principle of effective stress from soil mechanics, and the generalized-$\\alpha$ method, which is a standard and well-documented numerical integration scheme in computational mechanics. All parameters, initial conditions, and forcing functions are explicitly defined for each test case, making the problem self-contained and well-posed. The language is objective and formal. The provided data are dimensionally consistent and physically plausible for a soil dynamics problem. The task is a standard exercise in numerical methods for engineering and does not violate any of the invalidity criteria.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. A solution will be formulated and implemented.\n\n### Principle-Based Design of the Solution\nThe core of the problem is to solve the SDOF equation of motion at discrete time steps using the generalized-$\\alpha$ method. This is an implicit method, meaning that the states at time $t_{n+1}$ depend on the acceleration $a_{n+1}$ at that same time step. This requires solving an equation for $a_{n+1}$ at each step.\n\n1.  **Algorithmic Parameter Calculation**: First, the parameters of the generalized-$\\alpha$ method ($\\alpha_m, \\alpha_f$) and the associated Newmark parameters ($\\beta, \\gamma$) are computed from the given spectral radius at infinity, $\\rho_\\infty = 0.5$, using the provided formulas. These parameters control the accuracy and numerical dissipation of the algorithm. For $\\rho_\\infty < 1.0$, the method introduces artificial damping for high-frequency oscillations, which is a desirable property for stability in many applications.\n\n2.  **Derivation of the Step-wise Solver**: The discrete equilibrium equation is enforced at the weighted time level $t_{n+1-\\alpha_f}$:\n    $$m\\,a_{n+1-\\alpha_m} + c\\,v_{n+1-\\alpha_f} + k\\,x_{n+1-\\alpha_f} = F_{n+1-\\alpha_f}$$\n    The unknown is the acceleration at the new time step, $a_{n+1}$. All other quantities can be expressed in terms of known values from step $n$ and $a_{n+1}$. We substitute the definitions for the weighted state variables and the Newmark kinematic relations into the equilibrium equation.\n    The Newmark updates can be written in a predictor-corrector format. The predictors, denoted with a hat ($\\hat{\\cdot}$), are calculated first:\n    $$ \\hat{x}_{n+1} = x_n + \\Delta t\\,v_n + \\Delta t^2\\left(\\tfrac{1}{2} - \\beta\\right)a_n $$\n    $$ \\hat{v}_{n+1} = v_n + \\Delta t\\left(1 - \\gamma\\right)a_n $$\n    The final \"corrector\" step updates these values using the solution for $a_{n+1}$:\n    $$ x_{n+1} = \\hat{x}_{n+1} + \\beta\\,\\Delta t^2\\,a_{n+1} $$\n    $$ v_{n+1} = \\hat{v}_{n+1} + \\gamma\\,\\Delta t\\,a_{n+1} $$\n    Substituting these relations into the expanded equilibrium equation yields a linear algebraic equation for $a_{n+1}$:\n    $$ C_{eff} \\cdot a_{n+1} = R_{eff} $$\n    The effective stiffness/mass coefficient, $C_{eff}$, and the effective residual force, $R_{eff}$, are derived by collecting all terms containing $a_{n+1}$ on the left-hand side and all other (known) terms on the right-hand side.\n    The coefficient $C_{eff}$ is:\n    $$ C_{eff} = m(1 - \\alpha_m) + c(1 - \\alpha_f)\\gamma\\Delta t + k(1 - \\alpha_f)\\beta\\Delta t^2 $$\n    The right-hand side $R_{eff}$ is the residual based on the predicted state:\n    $$ R_{eff} = F_{n+1-\\alpha_f} - \\left( m\\alpha_m a_n + c((1-\\alpha_f)\\hat{v}_{n+1} + \\alpha_f v_n) + k((1-\\alpha_f)\\hat{x}_{n+1} + \\alpha_f x_n)\\right) $$\n    where $F_{n+1-\\alpha_f} = (1-\\alpha_f)F_{\\mathrm{eff}}(t_{n+1}) + \\alpha_f F_{\\mathrm{eff}}(t_n)$.\n    At each time step $n$, we solve for $a_{n+1} = R_{eff}/C_{eff}$ and then update $x_{n+1}$ and $v_{n+1}$.\n\n3.  **Time Simulation Loop**:\n    - Initialize the state vectors $x, v, a$ and the energy vector $E$. The initial acceleration $a_0$ is computed from the equilibrium equation at $t=0$.\n    - For each time step from $n=0$ to the final step, perform the solver calculation described above to find $(x_{n+1}, v_{n+1}, a_{n+1})$.\n    - At each step, calculate the mechanical energy $E_{n+1} = \\tfrac{1}{2} k x_{n+1}^2 + \\tfrac{1}{2} m v_{n+1}^2$ and store it.\n\n4.  **Energy Dissipation Verification**: After the simulation is complete for a given test case, iterate through the stored energy sequence $\\{E_n\\}$. For all time indices $n$ such that $t_n = n \\cdot \\Delta t \\ge t_{\\mathrm{off}}$, check if the condition $E_{n+1} \\le E_n$ holds. To account for floating-point inaccuracies, this check is implemented as $E_{n+1} \\le E_n + \\epsilon$, where $\\epsilon$ is a small positive tolerance (e.g., $10^{-9}\\,\\mathrm{J}$). If this condition is violated for any $n$ in the specified range, the result for that test case is `False`; otherwise, it is `True`. This procedure is repeated for all three test cases.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the SDOF oscillator problem.\n    \"\"\"\n\n    def run_simulation(case):\n        \"\"\"\n        Runs a single simulation for a given test case using the generalized-alpha method.\n        \"\"\"\n        # --- 1. Unpack parameters and initialize ---\n        k = 1.0e6  # Stiffness (N/m)\n        m = 1000.0   # Mass (kg)\n        c = 1000.0   # Damping (N.s/m)\n        dt = 0.005   # Time step (s)\n        rho_infty = 0.5  # Spectral radius at infinity\n\n        x0 = case['x0']\n        v0 = case['v0']\n        T_total = case['T_total']\n        t_off = case['t_off']\n        force_func = case['force_func']\n        \n        # --- 2. Calculate generalized-alpha and Newmark parameters ---\n        alpha_m = (2.0 - rho_infty) / (1.0 + rho_infty)\n        alpha_f = 1.0 / (1.0 + rho_infty)\n        gamma = 0.5 - alpha_m + alpha_f\n        beta = 0.25 * (1.0 - alpha_m + alpha_f)**2\n\n        # --- 3. Set up simulation arrays ---\n        num_steps = int(round(T_total / dt))\n        t = np.linspace(0, T_total, num_steps + 1)\n        \n        x = np.zeros(num_steps + 1)\n        v = np.zeros(num_steps + 1)\n        a = np.zeros(num_steps + 1)\n        E = np.zeros(num_steps + 1)\n\n        x[0], v[0] = x0, v0\n        F_eff_0 = force_func(0.0)\n        a[0] = (F_eff_0 - c * v[0] - k * x[0]) / m\n        E[0] = 0.5 * k * x[0]**2 + 0.5 * m * v[0]**2\n\n        # --- 4. Time integration loop ---\n        # Pre-calculate effective coefficient (constant for linear system)\n        # Note: The equilibrium is at t_{n+1-alpha_f}, so we use the definitions\n        # a_{n+1-alpha_m} = (1-alpha_m)a_{n+1} + alpha_m a_n etc.\n        C_eff = m * (1.0 - alpha_m) + c * (1.0 - alpha_f) * gamma * dt + k * (1.0 - alpha_f) * beta * dt**2\n\n        for n in range(num_steps):\n            # Known state at step n\n            x_n, v_n, a_n = x[n], v[n], a[n]\n            t_n, t_n1 = t[n], t[n+1]\n\n            # Forces at n and n+1\n            F_n = force_func(t_n)\n            F_n1 = force_func(t_n1)\n            F_alpha_f = (1.0 - alpha_f) * F_n1 + alpha_f * F_n\n            \n            # Predictor step (for terms not multiplied by a_{n+1})\n            v_hat_n1 = v_n + (1.0 - gamma) * dt * a_n\n            x_hat_n1 = x_n + dt * v_n + (0.5 - beta) * dt**2 * a_n\n\n            # Form effective right-hand side (residual from predictors)\n            R_eff = F_alpha_f - (m * alpha_m * a_n + \n                                 c * ((1.0 - alpha_f) * v_hat_n1 + alpha_f * v_n) +\n                                 k * ((1.0 - alpha_f) * x_hat_n1 + alpha_f * x_n))\n\n            # Solve for acceleration at n+1\n            a_n1 = R_eff / C_eff\n            a[n+1] = a_n1\n\n            # Corrector step\n            v[n+1] = v_hat_n1 + gamma * dt * a_n1\n            x[n+1] = x_hat_n1 + beta * dt**2 * a_n1\n\n            # Calculate and store energy\n            E[n+1] = 0.5 * k * x[n+1]**2 + 0.5 * m * v[n+1]**2\n\n        # --- 5. Verify energy dissipation ---\n        n_off = int(round(t_off / dt))\n        tolerance = 1e-9  # Small tolerance for floating point comparisons\n\n        for i in range(n_off, num_steps):\n            if E[i+1] > E[i] + tolerance:\n                return False\n        \n        return True\n\n    # --- Test Case Definitions ---\n\n    # Case 1: General transient loading\n    F0_1 = 100000.0\n    Tp_1 = 0.5\n    ru_max_1 = 0.4\n    def force_case1(t):\n        if 0 <= t <= Tp_1:\n            F_tot = F0_1 * np.sin(np.pi * t / Tp_1)\n            r_u = ru_max_1 * (t / Tp_1)\n            return F_tot * (1.0 - r_u)\n        elif t > Tp_1:\n            return 0.0 * (1.0 - ru_max_1) # F_tot is 0\n        return 0.0\n\n    # Case 2: Free vibration\n    def force_case2(t):\n        return 0.0\n\n    # Case 3: Short transient\n    F0_3 = 100000.0\n    Tp_3 = 0.05\n    def force_case3(t):\n        if 0 <= t <= Tp_3:\n            return F0_3 * np.sin(np.pi * t / Tp_3)\n        return 0.0\n\n    test_cases = [\n        {'x0': 0.0, 'v0': 0.0, 'T_total': 3.0, 't_off': 0.5, 'force_func': force_case1},\n        {'x0': 0.01, 'v0': 0.0, 'T_total': 3.0, 't_off': 0.0, 'force_func': force_case2},\n        {'x0': 0.0, 'v0': 0.0, 'T_total': 1.0, 't_off': 0.05, 'force_func': force_case3},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_simulation(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3521406"}]}