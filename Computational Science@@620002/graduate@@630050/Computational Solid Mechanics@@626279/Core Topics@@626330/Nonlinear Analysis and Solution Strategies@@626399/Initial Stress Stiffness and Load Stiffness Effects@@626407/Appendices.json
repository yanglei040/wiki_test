{"hands_on_practices": [{"introduction": "Understanding the initial stress stiffness begins with seeing where it comes from. This first practice takes you back to first principles, using the principle of virtual work for a simple truss element to derive the classic geometric stiffness matrix, often denoted as $K_G$ or $K_{\\sigma}$ [@problem_id:3574666]. By performing this derivation, you will directly connect the nonlinear terms in the Green-Lagrange strain tensor to the emergence of a stiffness contribution that depends on the pre-existing axial force in the element.", "problem": "A straight, prismatic, two-node truss element of undeformed length $L$ and constant reference cross-sectional area $A$ undergoes large rigid-body rotation but small axial strain. The element is modeled in a corotational formulation, so that in the corotated local frame the only nonzero kinematic degrees of freedom are the scalar axial nodal displacements $u_{1}$ and $u_{2}$ along the element axis. Let the axial force resultant be $N$, which represents the current internal axial force carried by the element and is assumed uniform along the element. Use the principle of virtual work (PVW) in a total Lagrangian setting, with Green–Lagrange strain and the second Piola–Kirchhoff stress, and a linear shape-function interpolation for the axial displacement field, to derive the initial stress (geometric) stiffness contribution in the local axial subspace. Specifically, starting from first principles, linearize the internal virtual work about the current configuration in the corotational frame to obtain the $2 \\times 2$ geometric stiffness submatrix associated with the local axial nodal degrees of freedom $u_{1}$ and $u_{2}$.\n\nYour derivation must clearly identify where the initial stress contribution originates in the linearization and must state the assumptions under which the final expression is valid. Express your final result as a closed-form analytic $2 \\times 2$ matrix in terms of $N$ and $L$. No numerical rounding is required. Do not include physical units in your final expression.", "solution": "The appropriate starting point is the principle of virtual work (PVW) in a total Lagrangian setting for a one-dimensional truss, written in terms of the Green–Lagrange strain and the second Piola–Kirchhoff stress. For a prismatic truss with reference cross-sectional area $A$ and reference coordinate $X \\in [0,L]$, the internal virtual work is\n$$\n\\delta W_{\\text{int}} \\;=\\; \\int_{0}^{L} A\\, S\\, \\delta E \\, \\mathrm{d}X,\n$$\nwhere $S$ is the second Piola–Kirchhoff stress and $E$ is the Green–Lagrange strain. In the corotational local frame, the axial displacement field is interpolated by linear shape functions:\n$$\nu(X) \\;=\\; N_{1}(X)\\,u_{1} \\;+\\; N_{2}(X)\\,u_{2}, \\quad N_{1}(X) \\;=\\; 1 - \\frac{X}{L}, \\quad N_{2}(X) \\;=\\; \\frac{X}{L}.\n$$\nDefine the constant axial displacement gradient\n$$\n\\alpha \\;=\\; \\frac{\\mathrm{d}u}{\\mathrm{d}X} \\;=\\; \\frac{u_{2} - u_{1}}{L}.\n$$\nFor a one-dimensional axial deformation, the deformation gradient is $F = 1 + \\alpha$, and the Green–Lagrange strain is\n$$\nE \\;=\\; \\frac{1}{2}\\big(F^{2} - 1\\big) \\;=\\; \\alpha \\;+\\; \\frac{1}{2}\\,\\alpha^{2}.\n$$\nIts variation is\n$$\n\\delta E \\;=\\; \\frac{\\partial E}{\\partial \\alpha}\\,\\delta \\alpha \\;=\\; (1+\\alpha)\\,\\delta \\alpha, \\quad \\delta \\alpha \\;=\\; \\frac{\\mathrm{d}}{\\mathrm{d}X}(\\delta u) \\;=\\; \\frac{-\\,\\delta u_{1} + \\delta u_{2}}{L}.\n$$\nSubstituting into the internal virtual work and using that $\\delta \\alpha$ is constant over $[0,L]$ for linear interpolation,\n$$\n\\delta W_{\\text{int}} \\;=\\; \\int_{0}^{L} A\\,S\\,(1+\\alpha)\\,\\delta \\alpha \\,\\mathrm{d}X \\;=\\; A\\,S\\,(1+\\alpha)\\,L\\,\\delta \\alpha \\;=\\; A\\,S\\,(1+\\alpha)\\,\\big(-\\,\\delta u_{1} + \\delta u_{2}\\big).\n$$\nIdentifying the internal nodal force vector $f_{\\text{int}}$ through $\\delta W_{\\text{int}} = \\delta u_{1}\\,f_{\\text{int},1} + \\delta u_{2}\\,f_{\\text{int},2}$ gives\n$$\nf_{\\text{int}} \\;=\\; A\\,S\\,(1+\\alpha)\\,\\begin{bmatrix} -1 \\\\[4pt] 1 \\end{bmatrix}.\n$$\nTo obtain the consistent tangent stiffness, we linearize $f_{\\text{int}}$ with respect to the nodal displacements $(u_{1},u_{2})$. The linearization naturally separates into a material part (through $\\partial S/\\partial u_{i}$ from the constitutive law) and a geometric or initial stress part (through the kinematic factor $(1+\\alpha)$ multiplying the shape-function gradient). The initial stress stiffness is obtained by freezing the current stress $S$ (i.e., neglecting $\\partial S/\\partial u_{i}$ in the directional derivative) and differentiating only the kinematic factor $(1+\\alpha)$:\n$$\nK_{\\sigma} \\;=\\; \\frac{\\partial}{\\partial \\mathbf{u}}\\Big(A\\,S\\,(1+\\alpha)\\,\\begin{bmatrix} -1 \\\\[2pt] 1 \\end{bmatrix}\\Big)\\Big|_{S=\\text{const}} \\;=\\; A\\,S\\,\\frac{\\partial (1+\\alpha)}{\\partial \\mathbf{u}}\\,\\begin{bmatrix} -1 \\\\[2pt] 1 \\end{bmatrix}.\n$$\nWith $\\alpha = (u_{2}-u_{1})/L$, the derivatives of $(1+\\alpha)$ are\n$$\n\\frac{\\partial (1+\\alpha)}{\\partial u_{1}} \\;=\\; -\\,\\frac{1}{L}, \\quad \\frac{\\partial (1+\\alpha)}{\\partial u_{2}} \\;=\\; \\frac{1}{L}.\n$$\nTherefore,\n$$\nK_{\\sigma} \\;=\\; A\\,S\\,\\frac{1}{L}\\,\\begin{bmatrix} 1 & -1 \\\\[4pt] -1 & 1 \\end{bmatrix}.\n$$\nTo express this in terms of the axial force resultant $N$, we note that the internal nodal force vector has the structure $f_{\\text{int}} = \\begin{bmatrix} -N \\\\ N \\end{bmatrix}$. Comparing with $f_{\\text{int}} = A\\,S\\,(1+\\alpha)\\,\\begin{bmatrix} -1 \\\\ 1 \\end{bmatrix}$ shows that\n$$\nN \\;=\\; A\\,S\\,(1+\\alpha).\n$$\nUnder the small axial strain assumption in the corotational setting, one has $(1+\\alpha) \\approx 1$, so that $N \\approx A\\,S$, and the geometric stiffness can be written compactly as\n$$\nK_{\\sigma} \\;=\\; \\frac{N}{L}\\,\\begin{bmatrix} 1 & -1 \\\\[4pt] -1 & 1 \\end{bmatrix}.\n$$\nThis $2 \\times 2$ submatrix acts on the local axial nodal degrees of freedom $(u_{1},u_{2})$.\n\nThe conditions under which this expression holds are:\n- The corotational frame removes rigid-body rotations so that the axial kinematics are described by scalar displacements $u_{1}$ and $u_{2}$ along the element axis, while allowing arbitrarily large rotations but small axial strain, i.e., $|\\alpha| \\ll 1$, so that $(1+\\alpha) \\approx 1$.\n- The axial force $N$ is uniform along the element and is interpreted as the current internal axial force resultant; under small axial strain, $N \\approx A\\,S$.\n- The element is straight and prismatic, with constant reference area $A$, and uses linear shape functions so that the axial displacement gradient is constant.\n- There are no follower load effects in the local axial subspace; the load stiffness associated with external follower forces is not included here. The derived matrix is the initial stress (geometric) stiffness arising from the internal pre-stress $N$.\n- The result is the local axial $2 \\times 2$ block; when assembling the full element tangent in global coordinates with transverse degrees of freedom, the standard rotational transformation recovers the familiar geometric stiffness distribution across all translational components.", "answer": "$$\\boxed{\\frac{N}{L}\\begin{bmatrix}1 & -1 \\\\ -1 & 1\\end{bmatrix}}$$", "id": "3574666"}, {"introduction": "Beyond the effects of internal stress, the tangent stiffness must also account for external loads that change with the configuration, known as follower loads. This practice focuses on the load stiffness matrix, $K_L$, which captures these non-conservative effects [@problem_id:3574664]. You will derive the analytical form of $K_L$ for a pressure-loaded curved element and then validate your result against a numerical estimate, a crucial verification skill in computational code development.", "problem": "Consider a planar, quadratic, isoparametric, three-node line element representing a circular arc subjected to a follower pressure load. The element occupies a curve defined by nodal positions $\\mathbf{X}_i \\in \\mathbb{R}^2$ for $i \\in \\{1,2,3\\}$, where the reference-location nodes are placed on a circle of radius $R$ at angles $\\theta_1=-\\alpha$, $\\theta_2=0$, and $\\theta_3=\\alpha$ (angles in radians). Thus, $\\mathbf{X}_i=\\left[R\\cos(\\theta_i),\\,R\\sin(\\theta_i)\\right]$. The current configuration nodal positions are $\\mathbf{x}_i=\\mathbf{X}_i+\\mathbf{u}_{0i}$, where $\\mathbf{u}_{0i}\\in\\mathbb{R}^2$ are prescribed initial displacements. The parametric coordinate is $\\xi\\in[-1,1]$, with quadratic Lagrange shape functions $N_1(\\xi)=\\frac{1}{2}\\xi(\\xi-1)$, $N_2(\\xi)=1-\\xi^2$, and $N_3(\\xi)=\\frac{1}{2}\\xi(\\xi+1)$, and derivatives $N_1'(\\xi)=\\xi-\\frac{1}{2}$, $N_2'(\\xi)=-2\\xi$, and $N_3'(\\xi)=\\xi+\\frac{1}{2}$. The geometric mapping is $\\mathbf{x}(\\xi)=\\sum_{i=1}^3 N_i(\\xi)\\,\\mathbf{x}_i$ and its parametric tangent is $\\mathbf{x}'(\\xi)=\\frac{d\\mathbf{x}}{d\\xi}=\\sum_{i=1}^3 N_i'(\\xi)\\,\\mathbf{x}_i$. Let $\\tau(\\xi)=\\frac{\\mathbf{x}'(\\xi)}{\\|\\mathbf{x}'(\\xi)\\|}$ be the unit tangent, let the unit normal be $\\mathbf{n}(\\xi)=\\mathbf{Q}\\,\\tau(\\xi)$ with the planar $90^\\circ$ rotation matrix $\\mathbf{Q}=\\begin{bmatrix}0 & -1 \\\\ 1 & 0\\end{bmatrix}$, and let the line element Jacobian be $J(\\xi)=\\|\\mathbf{x}'(\\xi)\\|$. A uniform pressure $p$ acts in the normal direction so that the distributed traction per unit current length is $\\mathbf{t}(\\xi)=p\\,\\mathbf{n}(\\xi)$.\n\nFrom the principle of virtual work and the definition of external nodal force in the Finite Element Method (FEM), the external force vector $\\mathbf{f}_{\\text{ext}}(\\mathbf{u})\\in\\mathbb{R}^{6}$ has $2$ components per node and is given by\n$$\n\\mathbf{f}_{\\text{ext}}(\\mathbf{u}) = \\int_{-1}^{1} \\left[\\begin{array}{c}\nN_1(\\xi)\\,\\mathbf{t}(\\xi)\\,J(\\xi) \\\\\nN_2(\\xi)\\,\\mathbf{t}(\\xi)\\,J(\\xi) \\\\\nN_3(\\xi)\\,\\mathbf{t}(\\xi)\\,J(\\xi)\n\\end{array}\\right]\\,d\\xi,\n$$\nwhere the stacked vector groups the $2$-component contributions for nodes $1$ through $3$. The load stiffness matrix $\\mathbf{K}_L$ is defined as the consistent linearization (Jacobian) of $\\mathbf{f}_{\\text{ext}}(\\mathbf{u})$ with respect to the nodal displacements $\\mathbf{u}$, evaluated at the current configuration $\\mathbf{u}=\\mathbf{u}_0$. That is,\n$$\n\\mathbf{K}_L = \\left.\\frac{\\partial \\mathbf{f}_{\\text{ext}}(\\mathbf{u})}{\\partial \\mathbf{u}}\\right|_{\\mathbf{u}=\\mathbf{u}_0},\n$$\nwith units of newton per meter (N/m).\n\nTasks:\n1. Starting from the definitions above, derive an expression for the consistent linearization of the external force due to follower pressure for this planar element and obtain an analytical formula for the load stiffness matrix $\\mathbf{K}_L$ that depends only on the shape functions, their parametric derivatives, the rotation matrix $\\mathbf{Q}$, and the pressure $p$.\n2. Implement a numerical finite-difference approximation of $\\mathbf{K}_L$ using central differences in the displacement degrees of freedom. Specifically, for each degree of freedom, perturb the corresponding nodal displacement by $\\pm\\varepsilon$ (in meters), recompute $\\mathbf{f}_{\\text{ext}}$, and approximate the Jacobian column by\n$$\n\\frac{\\mathbf{f}_{\\text{ext}}(\\mathbf{u}_0+\\varepsilon\\,\\mathbf{e}_k)-\\mathbf{f}_{\\text{ext}}(\\mathbf{u}_0-\\varepsilon\\,\\mathbf{e}_k)}{2\\varepsilon},\n$$\nwhere $\\mathbf{e}_k$ is the unit vector in the $k$-th displacement direction.\n3. Validate the analytical $\\mathbf{K}_L$ against the finite-difference estimate by computing the maximum absolute entrywise difference\n$$\nE_{\\max}=\\max_{a,b}\\left|(\\mathbf{K}_L^{\\text{FD}}-\\mathbf{K}_L^{\\text{an}})_{ab}\\right|,\n$$\nexpressed in newton per meter (N/m).\n\nUse Gaussian quadrature in the parametric coordinate $\\xi$ for all integrals, with enough points to integrate polynomials of degree up to $3$ exactly.\n\nTest Suite:\nFor each test case below, compute $E_{\\max}$ and report it in N/m.\n\n- Case $1$: $R=2.0$ m, $\\alpha=0.5$ rad, $p=10.0$ Pa, $\\varepsilon=10^{-6}$ m, $\\mathbf{u}_{01}=[0.0,0.0]$ m, $\\mathbf{u}_{02}=[0.0,0.0]$ m, $\\mathbf{u}_{03}=[0.0,0.0]$ m.\n- Case $2$: $R=1.0$ m, $\\alpha=0.4$ rad, $p=-5.0$ Pa, $\\varepsilon=10^{-7}$ m, $\\mathbf{u}_{01}=[10^{-3},-2\\cdot 10^{-3}]$ m, $\\mathbf{u}_{02}=[0.0,10^{-3}]$ m, $\\mathbf{u}_{03}=[-1.5\\cdot 10^{-3},0.5\\cdot 10^{-3}]$ m.\n- Case $3$: $R=0.5$ m, $\\alpha=0.9$ rad, $p=50.0$ Pa, $\\varepsilon=10^{-6}$ m, $\\mathbf{u}_{01}=[2\\cdot 10^{-3},2\\cdot 10^{-3}]$ m, $\\mathbf{u}_{02}=[-10^{-3},0.0]$ m, $\\mathbf{u}_{03}=[0.0,-2\\cdot 10^{-3}]$ m.\n- Case $4$: $R=10.0$ m, $\\alpha=10^{-3}$ rad, $p=100.0$ Pa, $\\varepsilon=10^{-6}$ m, $\\mathbf{u}_{01}=[0.0,0.0]$ m, $\\mathbf{u}_{02}=[0.0,0.0]$ m, $\\mathbf{u}_{03}=[0.0,0.0]$ m.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[r_1,r_2,r_3,r_4]$), where $r_i$ is the $E_{\\max}$ for Case $i$ in newton per meter (N/m).", "solution": "The user wants me to solve a problem in computational solid mechanics, specifically related to the derivation and implementation of a load stiffness matrix for a follower pressure load on a quadratic line element.\n\nHere's my plan:\n\n1.  **Validate the Problem:**\n    *   **Step 1: Extract Givens:** I need to list all the provided information: element type, shape functions, geometric mapping, traction definition, external force vector definition, and the definition of the load stiffness matrix. I'll also list the test case parameters.\n    *   **Step 2: Validate:** I'll check the problem against my validation criteria.\n        *   **Scientifically Grounded:** The concepts (FEM, isoparametric elements, follower loads, principle of virtual work, consistent linearization, load stiffness) are standard in nonlinear continuum mechanics and computational solid mechanics. The formulas provided for shape functions, external force vector, and load stiffness are correct.\n        *   **Well-Posed:** The problem asks for a derivation, an implementation, and a validation. This is a well-defined task. The numerical validation using finite differences is a standard procedure.\n        *   **Objective:** The language is highly technical and precise. No subjective statements.\n        *   **Completeness:** All necessary parameters ($R, \\alpha, p, \\varepsilon, \\mathbf{u}_0$) are given for each test case. The shape functions and their derivatives are explicitly provided. The definition of the normal vector using the rotation matrix $\\mathbf{Q}$ is clear. The quadrature rule requirement (exact for polynomials of degree up to 3) is specific.\n        *   **Consistency:** The units seem consistent (meters, radians, Pascals, N/m). The definitions are consistent with standard literature.\n\n    *   **Step 3: Verdict:** The problem appears to be valid. I can proceed to the solution.\n\n2.  **Solve the Problem (Derivation Part - Task 1):**\n    *   **Goal:** Derive an analytical expression for $\\mathbf{K}_L = \\frac{\\partial \\mathbf{f}_{\\text{ext}}}{\\partial \\mathbf{u}}$.\n    *   The external force vector is $\\mathbf{f}_{\\text{ext}} = \\int_{-1}^{1} \\mathbf{N}^T(\\xi) \\mathbf{t}(\\xi) J(\\xi) d\\xi$.\n    *   Let's write it out more explicitly. The contribution for node $i$ is $\\mathbf{f}_i = \\int_{-1}^{1} N_i(\\xi) \\mathbf{t}(\\xi) J(\\xi) d\\xi$.\n    *   The traction is $\\mathbf{t}(\\xi) = p\\,\\mathbf{n}(\\xi)$.\n    *   The normal is $\\mathbf{n}(\\xi) = \\mathbf{Q}\\,\\tau(\\xi) = \\mathbf{Q} \\frac{\\mathbf{x}'(\\xi)}{J(\\xi)}$, where $J(\\xi) = \\|\\mathbf{x}'(\\xi)\\|$.\n    *   Substituting this into the force expression:\n        $\\mathbf{f}_i = \\int_{-1}^{1} N_i(\\xi) (p\\,\\mathbf{Q} \\frac{\\mathbf{x}'(\\xi)}{J(\\xi)}) J(\\xi) d\\xi = p \\int_{-1}^{1} N_i(\\xi) \\mathbf{Q} \\mathbf{x}'(\\xi) d\\xi$.\n    *   This simplifies the integrand significantly. Now I need to linearize this with respect to the nodal displacements $\\mathbf{u}$.\n    *   The current nodal positions are $\\mathbf{x}_j = \\mathbf{X}_j + \\mathbf{u}_j$. The current geometry is parameterized by `u`.\n    *   The tangent vector is $\\mathbf{x}'(\\xi) = \\sum_{j=1}^3 N_j'(\\xi) \\mathbf{x}_j = \\sum_{j=1}^3 N_j'(\\xi) (\\mathbf{X}_j + \\mathbf{u}_j)$.\n    *   The variation of $\\mathbf{x}'(\\xi)$ with respect to a change in nodal displacements $\\delta\\mathbf{u}$ is:\n        $\\delta\\mathbf{x}'(\\xi) = \\sum_{j=1}^3 N_j'(\\xi) \\delta\\mathbf{u}_j$.\n    *   The linearization of the force vector for node $i$ is:\n        $\\delta\\mathbf{f}_i = p \\int_{-1}^{1} N_i(\\xi) \\mathbf{Q} \\delta\\mathbf{x}'(\\xi) d\\xi$.\n        $\\delta\\mathbf{f}_i = p \\int_{-1}^{1} N_i(\\xi) \\mathbf{Q} \\left( \\sum_{j=1}^3 N_j'(\\xi) \\delta\\mathbf{u}_j \\right) d\\xi$.\n    *   We can write $\\delta\\mathbf{f} = \\mathbf{K}_L \\delta\\mathbf{u}$. The force vector $\\delta\\mathbf{f}$ is a $6 \\times 1$ vector, and so is $\\delta\\mathbf{u}$.\n    *   Let's look at the sub-matrix $\\mathbf{K}_{L, ij}$, which is the contribution of a change in displacement at node $j$ ($\\delta\\mathbf{u}_j$) to the force at node $i$ ($\\delta\\mathbf{f}_i$). $\\mathbf{K}_{L, ij}$ is a $2 \\times 2$ matrix.\n        $\\delta\\mathbf{f}_i = \\sum_{j=1}^3 \\mathbf{K}_{L, ij} \\delta\\mathbf{u}_j$.\n    *   Comparing with the derived expression:\n        $\\mathbf{K}_{L, ij} \\delta\\mathbf{u}_j = p \\int_{-1}^{1} N_i(\\xi) \\mathbf{Q} N_j'(\\xi) \\delta\\mathbf{u}_j d\\xi$.\n    *   Since this must hold for any $\\delta\\mathbf{u}_j$, we can identify the block matrix:\n        $\\mathbf{K}_{L, ij} = p \\left( \\int_{-1}^{1} N_i(\\xi) N_j'(\\xi) d\\xi \\right) \\mathbf{Q}$.\n    *   This is a remarkably simple and elegant result. The integral is a scalar, depending only on the shape functions. The pressure $p$ is a scalar multiplier, and $\\mathbf{Q}$ is a constant matrix.\n    *   The load stiffness matrix $\\mathbf{K}_L$ is a $6 \\times 6$ matrix composed of $3 \\times 3$ blocks of $2 \\times 2$ matrices:\n        $\\mathbf{K}_L = \\begin{bmatrix}\n        \\mathbf{K}_{L, 11} & \\mathbf{K}_{L, 12} & \\mathbf{K}_{L, 13} \\\\\n        \\mathbf{K}_{L, 21} & \\mathbf{K}_{L, 22} & \\mathbf{K}_{L, 23} \\\\\n        \\mathbf{K}_{L, 31} & \\mathbf{K}_{L, 32} & \\mathbf{K}_{L, 33}\n        \\end{bmatrix}$\n        where $\\mathbf{K}_{L, ij} = p \\, c_{ij} \\, \\mathbf{Q}$, and $c_{ij} = \\int_{-1}^{1} N_i(\\xi) N_j'(\\xi) d\\xi$.\n    *   The matrix $\\mathbf{Q} = \\begin{bmatrix} 0 & -1 \\\\ 1 & 0 \\end{bmatrix}$. So $\\mathbf{K}_{L, ij} = p \\, c_{ij} \\begin{bmatrix} 0 & -1 \\\\ 1 & 0 \\end{bmatrix}$.\n    *   Let's check the dependency. The problem states the formula should depend only on shape functions, their derivatives, $\\mathbf{Q}$, and $p$. My result $\\mathbf{K}_{L, ij} = p \\left( \\int_{-1}^{1} N_i(\\xi) N_j'(\\xi) d\\xi \\right) \\mathbf{Q}$ fits this perfectly. It is independent of the geometry ($R, \\alpha$) and the current displacement state ($\\mathbf{u}_0$). This seems odd at first, but it comes from the simplification $p\\,\\mathbf{n}(\\xi)J(\\xi) = p\\,\\mathbf{Q}\\,\\mathbf{x}'(\\xi)$. The Jacobian $J(\\xi)$ cancels out, which removes the highly nonlinear geometric dependence.\n    *   Let's re-verify this derivation.\n        $\\mathbf{f}_{\\text{ext}} = \\int_{-1}^1 \\mathbf{N}(\\xi)^T p \\, \\mathbf{n}(\\xi) J(\\xi) d\\xi$\n        where $\\mathbf{N}(\\xi)$ is a $3 \\times 6$ matrix of shape functions: $\\begin{bmatrix} N_1\\mathbf{I} & N_2\\mathbf{I} & N_3\\mathbf{I} \\end{bmatrix}$.\n        Let's write this in component form to be safer.\n        $\\mathbf{f}_{ext, i} = \\int_{-1}^1 N_i(\\xi) p \\, \\mathbf{n}(\\xi) J(\\xi) d\\xi$ for $i=1,2,3$. These are $2 \\times 1$ vectors.\n        $\\mathbf{n}(\\xi) J(\\xi) = \\mathbf{Q} \\mathbf{x}'(\\xi) = \\mathbf{Q} \\sum_{k=1}^3 N_k'(\\xi) \\mathbf{x}_k$.\n        So, $\\mathbf{f}_{ext, i} = p \\int_{-1}^1 N_i(\\xi) \\mathbf{Q} \\sum_{k=1}^3 N_k'(\\xi) \\mathbf{x}_k d\\xi$.\n        Now, we take the derivative with respect to the displacement of node $j$, $\\mathbf{u}_j$. Let's denote the components of $\\mathbf{u}_j$ as $u_{j,1}$ and $u_{j,2}$.\n        $\\frac{\\partial \\mathbf{f}_{ext, i}}{\\partial \\mathbf{u}_j}$ is a $2 \\times 2$ matrix, which is $\\mathbf{K}_{L, ij}$.\n        The position vector $\\mathbf{x}_k = \\mathbf{X}_k + \\mathbf{u}_k$ depends on $\\mathbf{u}_k$.\n        The derivative $\\frac{\\partial \\mathbf{x}_k}{\\partial \\mathbf{u}_j}$ is $\\delta_{kj} \\mathbf{I}$, where $\\mathbf{I}$ is the $2 \\times 2$ identity matrix and $\\delta_{kj}$ is the Kronecker delta.\n        $\\frac{\\partial \\mathbf{f}_{ext, i}}{\\partial \\mathbf{u}_j} = p \\int_{-1}^1 N_i(\\xi) \\mathbf{Q} \\sum_{k=1}^3 N_k'(\\xi) \\frac{\\partial \\mathbf{x}_k}{\\partial \\mathbf{u}_j} d\\xi$.\n        $\\frac{\\partial \\mathbf{f}_{ext, i}}{\\partial \\mathbf{u}_j} = p \\int_{-1}^1 N_i(\\xi) \\mathbf{Q} \\sum_{k=1}^3 N_k'(\\xi) \\delta_{kj} \\mathbf{I} d\\xi$.\n        The sum collapses to the $k=j$ term.\n        $\\frac{\\partial \\mathbf{f}_{ext, i}}{\\partial \\mathbf{u}_j} = p \\int_{-1}^1 N_i(\\xi) \\mathbf{Q} N_j'(\\xi) \\mathbf{I} d\\xi$.\n        $\\mathbf{K}_{L, ij} = p \\left( \\int_{-1}^1 N_i(\\xi) N_j'(\\xi) d\\xi \\right) \\mathbf{Q}$.\n        The derivation is correct. The load stiffness matrix for this type of follower force is indeed independent of the element's current configuration.\n    *   Now I need to compute the integrals $c_{ij} = \\int_{-1}^{1} N_i(\\xi) N_j'(\\xi) d\\xi$.\n        The shape functions are polynomials of degree 2, their derivatives are of degree 1. The product $N_i N_j'$ is a polynomial of degree at most 3.\n        The problem says to use Gaussian quadrature \"with enough points to integrate polynomials of degree up to 3 exactly\".\n        A 2-point Gauss-Legendre quadrature integrates polynomials of degree up to $2n-1 = 2(2)-1 = 3$ exactly. So, 2-point quadrature is sufficient.\n        The points are $\\xi_{1,2} = \\pm 1/\\sqrt{3}$ and weights are $w_{1,2} = 1$.\n        Let's compute the $c_{ij}$ matrix. Let's call it $\\mathbf{C}$.\n        $N_1 = \\frac{1}{2}(\\xi^2-\\xi)$, $N_2 = 1-\\xi^2$, $N_3 = \\frac{1}{2}(\\xi^2+\\xi)$.\n        $N_1' = \\xi-\\frac{1}{2}$, $N_2' = -2\\xi$, $N_3' = \\xi+\\frac{1}{2}$.\n        Example: $c_{11} = \\int_{-1}^1 N_1 N_1' d\\xi = \\int_{-1}^1 \\frac{1}{2}(\\xi^2-\\xi)(\\xi-\\frac{1}{2}) d\\xi = \\frac{1}{2}\\int_{-1}^1 (\\xi^3 - \\frac{1}{2}\\xi^2 - \\xi^2 + \\frac{1}{2}\\xi) d\\xi = \\frac{1}{2}\\int_{-1}^1 (\\xi^3 - \\frac{3}{2}\\xi^2 + \\frac{1}{2}\\xi) d\\xi$.\n        $\\int_{-1}^1 \\xi^n d\\xi = 0$ for odd $n$, and $2/(n+1)$ for even $n$.\n        $c_{11} = \\frac{1}{2} [0 - \\frac{3}{2}\\frac{2}{3} + 0] = \\frac{1}{2}[-1] = -1/2$.\n        Let's do this systematically for all $c_{ij}$.\n        $N_i(\\xi) N_j'(\\xi)$ is a polynomial in $\\xi$.\n        Integrals of polynomials: $\\int_{-1}^1 \\xi^n d\\xi$.\n        $n=0: 2$\n        $n=1: 0$\n        $n=2: 2/3$\n        $n=3: 0$\n        $N_1 N_1' = \\frac{1}{2}(\\xi^3 - \\frac{3}{2}\\xi^2 + \\frac{1}{2}\\xi) \\implies c_{11} = \\frac{1}{2}(0 - \\frac{3}{2}\\frac{2}{3} + 0) = -1/2$\n        $N_1 N_2' = \\frac{1}{2}(\\xi^2-\\xi)(-2\\xi) = -\\xi^3+\\xi^2 \\implies c_{12} = 0 + 2/3 = 2/3$\n        $N_1 N_3' = \\frac{1}{2}(\\xi^2-\\xi)(\\xi+\\frac{1}{2}) = \\frac{1}{2}(\\xi^3 + \\frac{1}{2}\\xi^2 - \\xi^2 - \\frac{1}{2}\\xi) = \\frac{1}{2}(\\xi^3-\\frac{1}{2}\\xi^2-\\frac{1}{2}\\xi) \\implies c_{13} = \\frac{1}{2}(0 - \\frac{1}{2}\\frac{2}{3} - 0) = -1/6$\n        \n        $N_2 N_1' = (1-\\xi^2)(\\xi-\\frac{1}{2}) = \\xi - \\frac{1}{2} - \\xi^3 + \\frac{1}{2}\\xi^2 \\implies c_{21} = 0 - \\frac{1}{2}(2) - 0 + \\frac{1}{2}\\frac{2}{3} = -1 + 1/3 = -2/3$\n        $N_2 N_2' = (1-\\xi^2)(-2\\xi) = -2\\xi+2\\xi^3 \\implies c_{22} = 0$\n        $N_2 N_3' = (1-\\xi^2)(\\xi+\\frac{1}{2}) = \\xi + \\frac{1}{2} - \\xi^3 - \\frac{1}{2}\\xi^2 \\implies c_{23} = 0 + \\frac{1}{2}(2) - 0 - \\frac{1}{2}\\frac{2}{3} = 1 - 1/3 = 2/3$\n\n        $N_3 N_1' = \\frac{1}{2}(\\xi^2+\\xi)(\\xi-\\frac{1}{2}) = \\frac{1}{2}(\\xi^3 - \\frac{1}{2}\\xi^2 + \\xi^2 - \\frac{1}{2}\\xi) = \\frac{1}{2}(\\xi^3+\\frac{1}{2}\\xi^2-\\frac{1}{2}\\xi) \\implies c_{31} = \\frac{1}{2}(0 + \\frac{1}{2}\\frac{2}{3} - 0) = 1/6$\n        $N_3 N_2' = \\frac{1}{2}(\\xi^2+\\xi)(-2\\xi) = -\\xi^3-\\xi^2 \\implies c_{32} = 0 - 2/3 = -2/3$\n        $N_3 N_3' = \\frac{1}{2}(\\xi^2+\\xi)(\\xi+\\frac{1}{2}) = \\frac{1}{2}(\\xi^3 + \\frac{1}{2}\\xi^2 + \\xi^2 + \\frac{1}{2}\\xi) = \\frac{1}{2}(\\xi^3+\\frac{3}{2}\\xi^2+\\frac{1}{2}\\xi) \\implies c_{33} = \\frac{1}{2}(0 + \\frac{3}{2}\\frac{2}{3} + 0) = 1/2$\n\n        So the constant matrix $\\mathbf{C}$ is:\n        $\\mathbf{C} = \\begin{bmatrix}\n        -1/2 & 2/3 & -1/6 \\\\\n        -2/3 & 0 & 2/3 \\\\\n        1/6 & -2/3 & 1/2\n        \\end{bmatrix}$\n        This matrix is anti-symmetric in a way. Check $\\sum_i c_{ij} = 0$ and $\\sum_j c_{ij} = 0$?\n        $\\sum_j c_{1j} = -1/2 + 2/3 - 1/6 = (-3+4-1)/6 = 0$. Correct.\n        $\\sum_j c_{2j} = -2/3 + 0 + 2/3 = 0$. Correct.\n        $\\sum_j c_{3j} = 1/6 - 2/3 + 1/2 = (1-4+3)/6 = 0$. Correct.\n        This is expected because $\\sum_j \\mathbf{K}_{L,ij} = 0$ for a constant pressure field. No, rigid body translation should not induce forces if the pressure field is 'closed'. Here it's an open arc. But the sum of shape function derivatives is not zero: $\\sum_j N_j'(\\xi) = (\\xi - 1/2) - 2\\xi + (\\xi + 1/2) = 0$. Yes, it is. So $\\sum_{j} N_j'(\\xi) = 0$.\n        Then $\\sum_j c_{ij} = \\int_{-1}^1 N_i(\\xi) (\\sum_j N_j'(\\xi)) d\\xi = \\int_{-1}^1 N_i(\\xi) \\cdot 0 \\, d\\xi = 0$. Row sums must be zero. My calculation is correct.\n        What about column sums? $\\sum_i N_i(\\xi) = 1$.\n        $\\sum_i c_{ij} = \\int_{-1}^1 (\\sum_i N_i(\\xi)) N_j'(\\xi) d\\xi = \\int_{-1}^1 N_j'(\\xi) d\\xi = [N_j(\\xi)]_{-1}^1$.\n        $\\sum_i c_{i1} = N_1(1) - N_1(-1) = 1 - 0 = 1$. Let's check my matrix: $-1/2 - 2/3 + 1/6 = (-3-4+1)/6 = -6/6 = -1$. Where did I miss a sign?\n        Let me recheck the integrals.\n        $N_1(1) = 0.5(1-1)=0$, $N_1(-1)=0.5(-1)(-2)=1$. So $[N_1]_{-1}^1 = 0-1 = -1$. My sum is $-1$. Ok.\n        $N_2(1)=0$, $N_2(-1)=0$. So $[N_2]_{-1}^1 = 0-0=0$. My sum: $2/3 + 0 - 2/3 = 0$. Ok.\n        $N_3(1)=0.5(1)(2)=1$, $N_3(-1)=0$. So $[N_3]_{-1}^1 = 1-0 = 1$. My sum: $-1/6+2/3+1/2 = (-1+4+3)/6 = 6/6 = 1$. Ok.\n        The matrix $\\mathbf{C}$ is correct.\n\n        So, $\\mathbf{K}_L^{\\text{an}} = p \\cdot (\\mathbf{C} \\otimes \\mathbf{Q})$ where $\\otimes$ is the Kronecker product.\n        This is the analytical solution.\n\n3.  **Implementation Plan (Task 2 & 3):**\n    *   **Main function `solve()`:**\n        *   Loop through the four test cases.\n        *   For each case, unpack the parameters: $R, \\alpha, p, \\varepsilon, \\mathbf{u}_0$.\n        *   Call a function `calculate_matrices(R, alpha, p, epsilon, u0)` that returns $\\mathbf{K}_L^{\\text{an}}$ and $\\mathbf{K}_L^{\\text{FD}}$.\n        *   Calculate $E_{\\max} = \\max|\\mathbf{K}_L^{\\text{FD}} - \\mathbf{K}_L^{\\text{an}}|$.\n        *   Append $E_{\\max}$ to a results list.\n        *   Print the list in the specified format.\n\n    *   **Function `calculate_matrices(...)`:**\n        *   **Analytical matrix $\\mathbf{K}_L^{\\text{an}}$:**\n            *   Define the constant matrix $\\mathbf{C}$ as calculated above.\n            *   Define the rotation matrix $\\mathbf{Q}$.\n            *   Construct the $6 \\times 6$ matrix $\\mathbf{K}_L^{\\text{an}}$ using $p \\cdot \\mathbf{C} \\otimes \\mathbf{Q}$.\n        *   **Finite difference matrix $\\mathbf{K}_L^{\\text{FD}}$:**\n            *   This requires a function to compute $\\mathbf{f}_{\\text{ext}}(\\mathbf{u})$.\n            *   The input `u0` is a list of lists. I should flatten it into a $6 \\times 1$ vector.\n            *   Initialize a $6 \\times 6$ zero matrix $\\mathbf{K}_L^{\\text{FD}}$.\n            *   Loop $k$ from $0$ to $5$.\n                *   Create the perturbation vector $\\mathbf{e}_k$ (a vector of zeros with a $1$ at index $k$).\n                *   Calculate $\\mathbf{u}_+ = \\mathbf{u}_0 + \\varepsilon \\mathbf{e}_k$.\n                *   Calculate $\\mathbf{u}_- = \\mathbf{u}_0 - \\varepsilon \\mathbf{e}_k$.\n                *   Compute $\\mathbf{f}_+ = \\mathbf{f}_{\\text{ext}}(\\mathbf{u}_+)$.\n                *   Compute $\\mathbf{f}_- = \\mathbf{f}_{\\text{ext}}(\\mathbf{u}_-)$.\n                *   The $k$-th column of $\\mathbf{K}_L^{\\text{FD}}$ is $(\\mathbf{f}_+ - \\mathbf{f}_-) / (2\\varepsilon)$.\n        *   Return both matrices.\n\n    *   **Function `compute_f_ext(u_vec, R, alpha, p)`:**\n        *   Input `u_vec` is a flat $6 \\times 1$ vector of nodal displacements.\n        *   Reshape `u_vec` into a $3 \\times 2$ matrix of nodal displacements $\\mathbf{u}$.\n        *   Get reference nodal positions $\\mathbf{X}$:\n            *   $\\theta_1 = -\\alpha$, $\\theta_2 = 0$, $\\theta_3 = \\alpha$.\n            *   $\\mathbf{X}_i = [R \\cos(\\theta_i), R \\sin(\\theta_i)]$.\n        *   Compute current nodal positions $\\mathbf{x}_i = \\mathbf{X}_i + \\mathbf{u}_i$.\n        *   The integral for $\\mathbf{f}_\\text{ext}$ needs to be computed numerically using Gaussian quadrature. The problem says to use enough points to integrate polynomials of degree up to 3 exactly.\n        *   Let's check the integrand for $\\mathbf{f}_\\text{ext}$: $\\mathbf{N}^T(\\xi) \\mathbf{t}(\\xi) J(\\xi)$.\n        *   We already simplified this to $\\mathbf{N}^T(\\xi) p \\mathbf{Q} \\mathbf{x}'(\\xi)$.\n        *   $\\mathbf{x}'(\\xi) = \\sum N_i'(\\xi) \\mathbf{x}_i$. $N_i'$ is degree 1. So $\\mathbf{x}'$ is degree 1 in $\\xi$.\n        *   $\\mathbf{N}^T(\\xi)$ contains shape functions $N_i(\\xi)$ of degree 2.\n        *   The integrand is a vector of polynomials of degree $2+1=3$.\n        *   So, 2-point Gaussian quadrature is indeed sufficient.\n        *   Initialize $\\mathbf{f}_\\text{ext}$ to a $6 \\times 1$ zero vector.\n        *   Get Gauss points $\\xi_g$ and weights $w_g$ for 2-point rule: $\\xi = \\pm 1/\\sqrt{3}$, $w=1$.\n        *   Loop through Gauss points $g$:\n            *   Get $\\xi_g$ and $w_g$.\n            *   Evaluate shape functions $N_i(\\xi_g)$ and their derivatives $N_i'(\\xi_g)$.\n            *   Compute tangent vector $\\mathbf{x}'(\\xi_g) = \\sum_i N_i'(\\xi_g) \\mathbf{x}_i$.\n            *   The integrand value is: `integrand_val = p * Q @ x_prime`.\n            *   Loop through nodes $i=1, 2, 3$:\n                *   The force contribution to node $i$ is $N_i(\\xi_g) \\cdot \\text{integrand_val}$.\n                *   This is a $2 \\times 1$ vector.\n                *   Add $w_g \\cdot (\\text{contribution})$ to the corresponding part of $\\mathbf{f}_\\text{ext}$.\n        *   Return the $6 \\times 1$ vector $\\mathbf{f}_\\text{ext}$.\n\n4.  **Code Structure Details:**\n    *   Need `numpy`. The problem explicitly allows it.\n    *   `scipy` is also allowed, maybe for Gauss quadrature points/weights, but I can hardcode them for 2-point rule. `scipy.integrate.quadrature` could be used, but hardcoding is simpler and fits the problem better. I'll hardcode them.\n    *   `solve()` function to orchestrate the process.\n    *   `test_cases` list.\n    *   Helper function for shape functions and their derivatives: `shape_functions(xi)`. Returns `N` (vector of $N_i$) and `dN_dxi` (vector of $N_i'$).\n    *   Helper function `compute_f_ext` as described above.\n    *   Main logic will call these helpers.\n    *   The matrix $\\mathbf{C}$ can be precomputed and stored as a constant.\n    *   The matrix $\\mathbf{Q}$ is also a constant.\n    *   The analytical $\\mathbf{K}_L$ calculation will be very fast.\n    *   The FD calculation will involve $6 \\times 2 = 12$ calls to `compute_f_ext`.\n    *   Final output formatting is critical. `f\"[{','.join(map(str, results))}]\"`\n\nLet's double check the numerical integration.\n$\\mathbf{f}_{\\text{ext}} = \\int_{-1}^{1} p \\begin{bmatrix} N_1 \\mathbf{Q} \\mathbf{x}' \\\\ N_2 \\mathbf{Q} \\mathbf{x}' \\\\ N_3 \\mathbf{Q} \\mathbf{x}' \\end{bmatrix} d\\xi = \\sum_{g} w_g p \\begin{bmatrix} N_1(\\xi_g) \\mathbf{Q} \\mathbf{x}'(\\xi_g) \\\\ N_2(\\xi_g) \\mathbf{Q} \\mathbf{x}'(\\xi_g) \\\\ N_3(\\xi_g) \\mathbf{Q} \\mathbf{x}'(\\xi_g) \\end{bmatrix}$\nThis looks correct. The integrand is a vector where each component is a polynomial of degree at most 3. A 2-point Gauss quadrature (which is exact for polynomials up to degree 3) will calculate this integral *exactly*.\nThis has an important implication: The finite difference result should be extremely close to the analytical result, with the error only due to floating-point precision and the finite-difference truncation error (which depends on $\\varepsilon$). `E_max` should be very small.\nExample walkthrough for one column of FD matrix:\nLet's find column 1 ($k=1$). This corresponds to the $x$-displacement of node 1.\n$\\mathbf{u}_0$ is given.\n$\\mathbf{u}_+ = \\mathbf{u}_0 + [\\varepsilon, 0, 0, 0, 0, 0]^T$\n$\\mathbf{u}_- = \\mathbf{u}_0 - [\\varepsilon, 0, 0, 0, 0, 0]^T$\nCompute $\\mathbf{f}_+ = \\text{compute_f_ext}(\\mathbf{u}_+, ...)$\nCompute $\\mathbf{f}_- = \\text{compute_f_ext}(\\mathbf{u}_-, ...)$\nColumn 1 of $\\mathbf{K}_L^\\text{FD}$ is $(\\mathbf{f}_+ - \\mathbf{f}_-) / (2\\varepsilon)$.\nThis needs to be done for all 6 columns.\nThe logic holds up. I'm ready to write the solution and code.\nFinal check on problem statement details.\n- \"analytical formula ... that depends only on the shape functions, their parametric derivatives, the rotation matrix Q, and the pressure p.\"\n  - My derivation $\\mathbf{K}_{L,ij} = p \\left( \\int_{-1}^{1} N_i(\\xi) N_j'(\\xi) d\\xi \\right) \\mathbf{Q}$ matches this perfectly.\n- \"Gaussian quadrature... with enough points to integrate polynomials of degree up to 3 exactly.\"\n  - My choice of 2-point quadrature is correct.\n- \"Validate ... by computing the maximum absolute entrywise difference $E_{\\max}$\"\n  - My implementation calculates `np.max(np.abs(KL_fd - KL_an))`. This is correct.\n- Test cases are well-defined.\n- Output format: `[r_1,r_2,r_3,r_4]`\n- Python runtime environment: `numpy` 1.23.5, `scipy` 1.11.4. I only need `numpy`. This is fine.\n\nThe logic and structure are complete. I will now write the final output.\nFinal check on LaTeX formatting rules. \"every mathematical entity... must be written in LaTeX\". This means I need to be very careful. e.g., $i$, $1,2,3$, $\\mathbf{X}_i$, $\\mathbb{R}^2$, $\\theta_1=-\\alpha$, etc.\n\nLooks good. Proceed to generation.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef get_shape_functions(xi):\n    \"\"\"\n    Evaluates the quadratic Lagrange shape functions and their derivatives\n    at a given parametric coordinate xi.\n    \"\"\"\n    N1 = 0.5 * xi * (xi - 1)\n    N2 = 1.0 - xi**2\n    N3 = 0.5 * xi * (xi + 1)\n    \n    dN1_dxi = xi - 0.5\n    dN2_dxi = -2.0 * xi\n    dN3_dxi = xi + 0.5\n    \n    N = np.array([N1, N2, N3])\n    dN_dxi = np.array([dN1_dxi, dN2_dxi, dN3_dxi])\n    \n    return N, dN_dxi\n\ndef compute_f_ext(u_vec, R, alpha, p, Q_mat, gauss_points, gauss_weights):\n    \"\"\"\n    Computes the external force vector f_ext for a given set of nodal displacements.\n    The integration is performed using 2-point Gaussian quadrature.\n    \"\"\"\n    u_nodes = u_vec.reshape(3, 2)\n    \n    # Reference nodal positions\n    thetas = np.array([-alpha, 0.0, alpha])\n    X_nodes = np.zeros((3, 2))\n    X_nodes[:, 0] = R * np.cos(thetas)\n    X_nodes[:, 1] = R * np.sin(thetas)\n    \n    # Current nodal positions\n    x_nodes = X_nodes + u_nodes\n    \n    f_ext = np.zeros(6)\n    \n    # Perform Gaussian quadrature\n    for xi, w in zip(gauss_points, gauss_weights):\n        N, dN_dxi = get_shape_functions(xi)\n        \n        # Parametric tangent x_prime = sum(N_i' * x_i)\n        x_prime = np.dot(dN_dxi, x_nodes)\n            \n        # The term p * n * J simplifies to p * Q * x_prime\n        integrand_base = p * (Q_mat @ x_prime)\n        \n        # Assemble force vector contributions from the current quadrature point\n        for i in range(3):\n            f_ext[2*i : 2*i+2] += w * N[i] * integrand_base\n            \n    return f_ext\n\ndef get_analytical_KL(p, C_mat, Q_mat):\n    \"\"\"\n    Computes the analytical load stiffness matrix K_L.\n    K_L = p * (C_mat kron Q_mat)\n    \"\"\"\n    # Use Kronecker product to construct the 6x6 matrix from 3x3 and 2x2 blocks\n    KL_an = p * np.kron(C_mat, Q_mat)\n    return KL_an\n\ndef get_fd_KL(u0_vec, R, alpha, p, epsilon, Q_mat, gauss_points, gauss_weights):\n    \"\"\"\n    Computes the load stiffness matrix using a central finite-difference scheme.\n    \"\"\"\n    num_dofs = 6\n    KL_fd = np.zeros((num_dofs, num_dofs))\n    \n    for k in range(num_dofs):\n        # Create perturbation vector for the k-th degree of freedom\n        e_k = np.zeros(num_dofs)\n        e_k[k] = 1.0\n        \n        # Perturb displacements\n        u_plus = u0_vec + epsilon * e_k\n        u_minus = u0_vec - epsilon * e_k\n        \n        # Compute external forces at perturbed configurations\n        f_plus = compute_f_ext(u_plus, R, alpha, p, Q_mat, gauss_points, gauss_weights)\n        f_minus = compute_f_ext(u_minus, R, alpha, p, Q_mat, gauss_points, gauss_weights)\n        \n        # Central difference formula for the k-th column of the Jacobian\n        KL_fd[:, k] = (f_plus - f_minus) / (2.0 * epsilon)\n        \n    return KL_fd\n\ndef solve():\n    \"\"\"\n    Main solver function to process test cases and compute the validation error.\n    \"\"\"\n    # Test cases defined in the problem statement\n    test_cases = [\n        {'R': 2.0, 'alpha': 0.5, 'p': 10.0, 'epsilon': 1e-6, \n         'u0': np.array([[0.0, 0.0], [0.0, 0.0], [0.0, 0.0]])},\n        {'R': 1.0, 'alpha': 0.4, 'p': -5.0, 'epsilon': 1e-7, \n         'u0': np.array([[1e-3, -2e-3], [0.0, 1e-3], [-1.5e-3, 0.5e-3]])},\n        {'R': 0.5, 'alpha': 0.9, 'p': 50.0, 'epsilon': 1e-6, \n         'u0': np.array([[2e-3, 2e-3], [-1e-3, 0.0], [0.0, -2e-3]])},\n        {'R': 10.0, 'alpha': 1e-3, 'p': 100.0, 'epsilon': 1e-6, \n         'u0': np.array([[0.0, 0.0], [0.0, 0.0], [0.0, 0.0]])}\n    ]\n\n    # Pre-computation of constants\n    # Gaussian Quadrature points and weights for 2 points (exact for degree 3 polynomials)\n    gauss_points = [-1.0 / np.sqrt(3.0), 1.0 / np.sqrt(3.0)]\n    gauss_weights = [1.0, 1.0]\n    \n    # 90-degree planar rotation matrix Q\n    Q_mat = np.array([[0.0, -1.0], [1.0, 0.0]])\n    \n    # Precomputed coefficient matrix C from analytical integration\n    # C_ij = integral from -1 to 1 of (N_i(xi) * N_j'(xi)) dxi\n    C_mat = np.array([\n        [-1.0/2.0, 2.0/3.0, -1.0/6.0],\n        [-2.0/3.0, 0.0,      2.0/3.0],\n        [ 1.0/6.0, -2.0/3.0, 1.0/2.0]\n    ])\n\n    results = []\n    for case in test_cases:\n        R = case['R']\n        alpha = case['alpha']\n        p = case['p']\n        epsilon = case['epsilon']\n        u0_nodes = case['u0']\n        u0_vec = u0_nodes.flatten()\n        \n        # 1. Compute the analytical load stiffness matrix\n        KL_an = get_analytical_KL(p, C_mat, Q_mat)\n        \n        # 2. Compute the finite-difference approximation of the load stiffness matrix\n        KL_fd = get_fd_KL(u0_vec, R, alpha, p, epsilon, Q_mat, gauss_points, gauss_weights)\n        \n        # 3. Compute the maximum absolute entrywise difference for validation\n        E_max = np.max(np.abs(KL_fd - KL_an))\n        results.append(E_max)\n\n    # Print results in the specified single-line format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3574664"}, {"introduction": "Having formulated the initial stress ($K_G$) and load stiffness ($K_L$) matrices, we now investigate their impact on the performance of a nonlinear analysis. This numerical experiment uses a simplified two-degree-of-freedom model to explore how selectively including or excluding these terms from the solver's tangent matrix affects convergence and stability [@problem_id:3574659]. By observing the solver's behavior, you will gain empirical insight into why a fully consistent tangent leads to quadratic convergence and how omitting terms can degrade performance or lead to failure in the presence of buckling or flutter phenomena.", "problem": "Implement a small, self-contained numerical experiment to isolate and compare the roles of material stiffness, initial stress (geometric) stiffness, and load stiffness in a nonlinear solution procedure for a reduced, nondimensional structural model. Work in nondimensional variables so that no physical unit conversion is required. Your program must be a complete, runnable program that assembles and solves incremental load steps using Newton’s method with user-controllable switches that include or exclude the initial stress stiffness and the load stiffness from the tangent used by the solver (while keeping the “true” residual fixed). The goal is to empirically separate the roles of the three parts of the tangent on convergence and stability.\n\nStart from the following principle-based objects, stated without derivation in the problem but to be justified in your solution:\n\n- The model has a reduced-order state vector $u \\in \\mathbb{R}^2$.\n- The internal force linearization in the neighborhood of the reference configuration decomposes additively as a sum of a material stiffness, an initial stress (geometric) stiffness scaled by an axial prestress parameter $N \\ge 0$, and a load stiffness scaled by a follower load parameter $P \\ge 0$. Therefore, for each load step, the “true” tangent is the matrix\n$$\nK_{\\mathrm{true}}(N,P) \\;=\\; K_M \\;+\\; N\\,K_G \\;+\\; P\\,K_L.\n$$\n- The corresponding residual at a given step is\n$$\nR(u;N,P) \\;=\\; K_{\\mathrm{true}}(N,P)\\,u \\;-\\; P\\,f_0,\n$$\nwhere $f_0 \\in \\mathbb{R}^2$ is a fixed nondimensional load direction vector representing the dead part of the follower load.\n- The material stiffness $K_M$ is symmetric positive definite; the initial stress stiffness $K_G$ is symmetric and negative definite in compression (so that increasing $N$ can drive a loss of positive definiteness); and the load stiffness $K_L$ is skew-symmetric (so that it induces nonconservative effects). Use the following concrete matrices and vector, expressed in nondimensional form:\n$$\nK_M \\;=\\; \\begin{bmatrix} 4.0 & 0.5 \\\\[4pt] 0.5 & 1.5 \\end{bmatrix},\\quad\nK_G \\;=\\; -\\,\\begin{bmatrix} 1.6 & 0.2 \\\\[4pt] 0.2 & 0.9 \\end{bmatrix},\\quad\nK_L \\;=\\; \\begin{bmatrix} 0.0 & 1.0 \\\\[4pt] -1.0 & 0.0 \\end{bmatrix},\\quad\nf_0 \\;=\\; \\begin{bmatrix} 1.0 \\\\[4pt] 0.2 \\end{bmatrix}.\n$$\n- At each load step, Newton’s method solves $R(u;N,P)=0$ with an approximate tangent\n$$\nA(N,P;\\,\\sigma_G,\\sigma_L) \\;=\\; K_M \\;+\\; \\sigma_G\\,N\\,K_G \\;+\\; \\sigma_L\\,P\\,K_L,\n$$\nwhere the switch $\\sigma_G \\in \\{0,1\\}$ includes or excludes the geometric stiffness in the solver tangent, and the switch $\\sigma_L \\in \\{0,1\\}$ includes or excludes the load stiffness in the solver tangent. Note that $R$ always uses $K_{\\mathrm{true}}(N,P)$ (never switched), while the solver’s tangent $A$ can differ via the switches. The Newton update at iteration $k$ is\n$$\nu^{k+1} \\;=\\; u^k \\;-\\; A(N,P;\\,\\sigma_G,\\sigma_L)^{-1}\\,R(u^k;N,P).\n$$\n\nNumerical procedure:\n\n- Initialize $u=\\mathbf{0}$ at the first step of each case, and then use the converged solution as the initial guess for the next step within the same case.\n- Use a maximum of $200$ Newton iterations per step, with the convergence criterion\n$$\n\\frac{\\lVert R(u;N,P)\\rVert_2}{\\lVert P\\,f_0\\rVert_2 + 10^{-16}} \\;\\le\\; 10^{-8}.\n$$\n- If the linear solve with $A$ fails (numerical singularity or condition number exceeding $10^{12}$) or the iteration does not meet the convergence criterion within the maximum iterations, declare the current load step as non-converged and stop further steps for the current case.\n\nYour task:\n\n- Implement the above Newton procedure with the switches $\\sigma_G$ and $\\sigma_L$.\n- For each specified case (the test suite below), count how many load steps converge and return that count.\n\nTest suite:\n\nProvide results for the following four cases, designed to separately probe the roles of $K_M$, $K_G$, and $K_L$:\n\n- Case $1$ (baseline quasi-Newton without load-dependent tangents): $\\sigma_G = 0$, $\\sigma_L = 0$, with the load sequence of three steps\n  - Step $1$: $(N,P)=(0.0,\\,0.05)$\n  - Step $2$: $(N,P)=(0.3,\\,0.05)$\n  - Step $3$: $(N,P)=(0.6,\\,0.05)$\n- Case $2$ (include geometric stiffness only in the tangent): $\\sigma_G = 1$, $\\sigma_L = 0$, with the load sequence of four steps\n  - Step $1$: $(N,P)=(0.0,\\,0.20)$\n  - Step $2$: $(N,P)=(0.8,\\,0.40)$\n  - Step $3$: $(N,P)=(0.8,\\,0.80)$\n  - Step $4$: $(N,P)=(0.8,\\,1.60)$\n- Case $3$ (include load stiffness only in the tangent): $\\sigma_G = 0$, $\\sigma_L = 1$, with the load sequence of four steps\n  - Step $1$: $(N,P)=(0.0,\\,0.0)$\n  - Step $2$: $(N,P)=(0.6,\\,0.0)$\n  - Step $3$: $(N,P)=(0.9,\\,0.0)$\n  - Step $4$: $(N,P)=(1.2,\\,0.0)$\n- Case $4$ (exact Newton with both load-dependent tangents): $\\sigma_G = 1$, $\\sigma_L = 1$, with the load sequence of four steps\n  - Step $1$: $(N,P)=(0.0,\\,0.0)$\n  - Step $2$: $(N,P)=(0.8,\\,0.2)$\n  - Step $3$: $(N,P)=(1.0,\\,0.2)$\n  - Step $4$: $(N,P)=(1.2,\\,0.2)$\n\nFinal output specification:\n\n- Your program should produce a single line of output containing a list of four integers, where the $i$-th integer is the number of converged steps in Case $i$, in the exact format\n$$\n[\\text{r1},\\text{r2},\\text{r3},\\text{r4}],\n$$\nwith no spaces in the list and no additional text. For example, a valid output would be $[3,2,4,4]$ (the actual numbers depend on your implementation and the specified matrices and load sequences).", "solution": "The user has requested the implementation of a numerical experiment to study the roles of material, initial stress, and load stiffness in a simplified structural mechanics model. The validation and solution process is as follows.\n\n### **Problem Validation**\n\n**Step 1: Extract Givens**\n\n-   **State Vector**: $u \\in \\mathbb{R}^2$.\n-   **True Tangent Stiffness**: $K_{\\mathrm{true}}(N,P) = K_M + N\\,K_G + P\\,K_L$, where $N \\ge 0$ is a prestress parameter and $P \\ge 0$ is a follower load parameter.\n-   **Residual Vector**: $R(u;N,P) = K_{\\mathrm{true}}(N,P)\\,u - P\\,f_0$.\n-   **Component Matrices and Vector**:\n    $$\n    K_M = \\begin{bmatrix} 4.0 & 0.5 \\\\ 0.5 & 1.5 \\end{bmatrix} \\quad (\\text{Symmetric Positive-Definite})\n    $$\n    $$\n    K_G = -\\begin{bmatrix} 1.6 & 0.2 \\\\ 0.2 & 0.9 \\end{bmatrix} \\quad (\\text{Symmetric Negative-Definite})\n    $$\n    $$\n    K_L = \\begin{bmatrix} 0.0 & 1.0 \\\\ -1.0 & 0.0 \\end{bmatrix} \\quad (\\text{Skew-Symmetric})\n    $$\n    $$\n    f_0 = \\begin{bmatrix} 1.0 \\\\ 0.2 \\end{bmatrix}\n    $$\n-   **Approximate Solver Tangent**: $A(N,P;\\,\\sigma_G,\\sigma_L) = K_M + \\sigma_G\\,N\\,K_G + \\sigma_L\\,P\\,K_L$, with switches $\\sigma_G, \\sigma_L \\in \\{0,1\\}$.\n-   **Newton Update**: $u^{k+1} = u^k - A^{-1}\\,R(u^k)$.\n-   **Numerical Procedure**:\n    -   Initialize $u=\\mathbf{0}$ for the first step of a case; use the previous converged solution for subsequent steps.\n    -   Maximum iterations per step: $200$.\n    -   Convergence criterion: $\\frac{\\lVert R(u;N,P)\\rVert_2}{\\lVert P\\,f_0\\rVert_2 + 10^{-16}} \\le 10^{-8}$.\n    -   Failure conditions: Linear solve with $A$ fails (singularity or condition number $> 10^{12}$) or non-convergence within maximum iterations.\n-   **Task**: For four specified cases, count the number of successfully converged load steps.\n\n**Step 2: Validate Using Extracted Givens**\n\n1.  **Scientifically Grounded**: The problem is a well-founded abstraction of a nonlinear structural analysis problem, common in the finite element method. The decomposition of the tangent stiffness into material ($K_M$), geometric ($K_G$), and load-dependent ($K_L$) parts is canonical. The properties of the given matrices are consistent with their physical interpretations: $K_M$ is symmetric positive-definite (eigenvalues are $\\approx 4.15, 1.35$), $K_G$ is symmetric negative-definite (eigenvalues of the positive part are $\\approx 1.7, 0.8$, so eigenvalues of $K_G$ are negative), and $K_L$ is skew-symmetric ($K_L = -K_L^T$). The setup of a quasi-Newton method, where an approximate tangent $A$ is used to solve a system governed by a true stiffness $K_{\\mathrm{true}}$, is a standard technique and a valid basis for a numerical experiment.\n2.  **Well-Posed**: All necessary data, matrices, parameters, and algorithms are explicitly provided. The objective—counting converged steps—is clear and yields a unique, deterministic result.\n3.  **Objective**: The problem is stated in precise, mathematical language, free from subjectivity.\n4.  **Incomplete or Contradictory Setup**: The problem is self-contained and free of contradictions. The use of Newton's method on what is, for fixed $N$ and $P$, a linear system $K_{\\mathrm{true}}u = Pf_0$, is a valid experimental design to probe the convergence of quasi-Newton methods where the solver's Jacobian ($A$) does not match the system's true Jacobian ($K_{\\mathrm{true}}$).\n5.  **Unrealistic or Infeasible**: The problem is nondimensional and the requested computations are standard linear algebra operations, all of which are feasible.\n6.  **Ill-Posed or Trivial**: The problem is not ill-posed. While some test cases (e.g., Case 3) may appear trivial, their behavior is a direct and informative consequence of the problem physics ($P=0$ implies no external force, leading to a trivial solution). This probes a valid corner case. The overall experiment is non-trivial and illuminates important concepts in computational mechanics.\n\n**Step 3: Verdict and Action**\n\nThe problem is deemed **valid**. It is a sound, self-contained, and well-posed numerical problem that is grounded in the principles of computational solid mechanics. A solution will be provided.\n\n### **Principle-Based Solution Design**\n\nThe core of the task is to implement a quasi-Newton iterative solver. The fundamental principle of Newton's method is to iteratively find a root of a function (here, the residual $R(u)$) by approximating the function with its tangent at the current iterate.\n\n1.  **Governing Equation and Residual**: The physical system is modeled by the equation $K_{\\mathrm{true}}(N,P)\\,u = P\\,f_0$. The objective of the solver is to find the displacement vector $u$ that satisfies this equation. The residual, $R(u) = K_{\\mathrm{true}}(N,P)\\,u - P\\,f_0$, quantifies the error for a given $u$. A solution is found when $R(u) = \\mathbf{0}$.\n\n2.  **Quasi-Newton Iteration**: The standard Newton-Raphson method linearizes the residual at each step. The update $\\Delta u$ is found by solving $J \\Delta u = -R(u^k)$, where $J = \\frac{\\partial R}{\\partial u}$ is the Jacobian. For our linear residual, the exact Jacobian is $J = K_{\\mathrm{true}}$. This problem introduces a quasi-Newton scheme by replacing the exact Jacobian $J$ with an approximation $A(N,P;\\,\\sigma_G,\\sigma_L)$. The iterative update is thus:\n    $$\n    u^{k+1} = u^k + \\Delta u^k \\quad \\text{where} \\quad A \\Delta u^k = -R(u^k)\n    $$\n    The choice of $A$ dictates the solver's behavior:\n    -   When $A=K_{\\mathrm{true}}$ (Case 4), we have the exact Newton method, which converges in one iteration for this linear residual.\n    -   When $A \\neq K_{\\mathrm{true}}$ (Cases 1, 2, 3), we have a quasi-Newton method. Its convergence depends on how well $A$ approximates $K_{\\mathrm{true}}$. A poor approximation can lead to slow convergence or divergence.\n\n3.  **Physical Interpretation of Stiffness Components**:\n    -   $K_M$: The intrinsic stiffness of the material. It is the baseline, symmetric positive-definite part of the tangent.\n    -   $N K_G$: The initial stress or geometric stiffness. A compressive prestress ($N>0$) typically reduces the overall stiffness. If $N$ is large enough, $K_M + N K_G$ can become singular, corresponding to elastic buckling.\n    -   $P K_L$: The load stiffness, arising from non-conservative \"follower\" forces. Its skew-symmetry can lead to non-symmetric tangent matrices, potentially causing flutter instability.\n\n4.  **Algorithmic Implementation**: The solution is constructed by writing a program that iterates through the four specified test cases. For each case, it proceeds through a sequence of load steps. Within each step, it executes the quasi-Newton loop, checking for convergence or failure.\n    -   **State Initialization**: The displacement $u$ is reset to $\\mathbf{0}$ at the beginning of each case and is carried over from one converged step to the next within a case. This simulates an incremental loading history.\n    -   **Matrix Assembly**: For each step, both $K_{\\mathrm{true}}$ and $A$ are assembled based on the current load parameters $(N, P)$ and the case's switches $(\\sigma_G, \\sigma_L)$.\n    -   **Failure Handling**: Before iterating, the condition number of the solver matrix $A$ is checked against a threshold ($10^{12}$) to preemptively detect ill-conditioning. During iteration, the linear solve $A \\Delta u = -R$ is monitored for numerical failure. If the maximum number of iterations ($200$) is reached without the residual satisfying the tolerance ($\\lVert R \\rVert_2 / (\\lVert P f_0 \\rVert_2 + \\epsilon) \\le 10^{-8}$), the step is marked as non-converged.\n    -   **Counting and Reporting**: A counter for each case tracks the number of successful steps. The process for a case halts at the first failed step. The final counts for all four cases are reported.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a quasi-Newton solver to test the effects of stiffness matrix components.\n    \"\"\"\n    # Define the nondimensional matrices and load vector from the problem statement.\n    K_M = np.array([[4.0, 0.5],\n                    [0.5, 1.5]])\n\n    K_G = -np.array([[1.6, 0.2],\n                     [0.2, 0.9]])\n\n    K_L = np.array([[0.0, 1.0],\n                    [-1.0, 0.0]])\n\n    f_0 = np.array([1.0, 0.2])\n\n    # Define numerical procedure parameters.\n    MAX_ITER = 200\n    TOL = 1e-8\n    COND_LIMIT = 1e12\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (sigma_G, sigma_L, list_of_load_steps)\n    test_cases = [\n        # Case 1: Baseline quasi-Newton without load-dependent tangents\n        (0, 0, [(0.0, 0.05), (0.3, 0.05), (0.6, 0.05)]),\n        # Case 2: Include geometric stiffness only\n        (1, 0, [(0.0, 0.20), (0.8, 0.40), (0.8, 0.80), (0.8, 1.60)]),\n        # Case 3: Include load stiffness only\n        (0, 1, [(0.0, 0.0), (0.6, 0.0), (0.9, 0.0), (1.2, 0.0)]),\n        # Case 4: Exact Newton with both load-dependent tangents\n        (1, 1, [(0.0, 0.0), (0.8, 0.2), (1.0, 0.2), (1.2, 0.2)])\n    ]\n\n    results = []\n    \n    # Iterate through each test case.\n    for case in test_cases:\n        sigma_G, sigma_L, load_steps = case\n        \n        # Initialize displacement vector and converged step counter for the case.\n        u = np.zeros(2)\n        converged_steps_count = 0\n        \n        # Iterate through the load steps for the current case.\n        for N, P in load_steps:\n            # The initial guess for this step is the converged solution from the previous step.\n            u_k = np.copy(u)\n            \n            # Assemble the \"true\" and \"approximate\" tangent matrices.\n            K_true = K_M + N * K_G + P * K_L\n            A = K_M + sigma_G * N * K_G + sigma_L * P * K_L\n            \n            step_converged = False\n\n            # Pre-check for ill-conditioning of the solver's tangent matrix.\n            try:\n                if np.linalg.cond(A) > COND_LIMIT:\n                    break # Step fails, so break from the load_steps loop for this case.\n            except np.linalg.LinAlgError:\n                break # Matrix is singular.\n\n            # Calculate the external force vector and the denominator for the convergence criterion.\n            F_ext = P * f_0\n            conv_denom = np.linalg.norm(F_ext) + 1e-16\n\n            # Perform Newton-Raphson iteration.\n            for _ in range(MAX_ITER):\n                # Calculate the residual vector.\n                R_k = K_true @ u_k - F_ext\n                \n                # Check for convergence.\n                if np.linalg.norm(R_k) / conv_denom = TOL:\n                    step_converged = True\n                    u = u_k  # Store the converged solution for the next step.\n                    break\n\n                # Solve for the displacement update: A * delta_u = -R_k.\n                try:\n                    delta_u = np.linalg.solve(A, -R_k)\n                except np.linalg.LinAlgError:\n                    # Linear solve failed, iteration cannot continue.\n                    step_converged = False\n                    break \n                \n                # Update the displacement vector.\n                u_k += delta_u\n            \n            # If the step converged, increment the counter.\n            if step_converged:\n                converged_steps_count += 1\n            else:\n                # If a step fails, stop processing this case.\n                break\n\n        results.append(converged_steps_count)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3574659"}]}