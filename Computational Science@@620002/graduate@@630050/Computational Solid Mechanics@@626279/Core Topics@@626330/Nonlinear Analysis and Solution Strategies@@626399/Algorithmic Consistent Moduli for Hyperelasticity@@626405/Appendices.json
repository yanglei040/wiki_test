{"hands_on_practices": [{"introduction": "A cornerstone of implementing any hyperelastic constitutive model is the correct derivation of the stress and the corresponding algorithmic tangent modulus. This foundational practice guides you through this process for a compressible Neo-Hookean material, starting from the strain-energy density function [@problem_id:3543698]. The exercise culminates in the essential task of verifying your analytical tangent against a numerical finite-difference approximation, a fundamental skill for developing robust and reliable computational mechanics code.", "problem": "Consider a three-dimensional hyperelastic body characterized by a strain-energy density function $W$ that depends on the Right Cauchy-Green tensor (RCG), defined as $\\mathbf{C} = \\mathbf{F}^{\\mathsf{T}} \\mathbf{F}$, where $\\mathbf{F}$ is the deformation gradient. Let the Green-Lagrange strain be $\\mathbf{E} = \\tfrac{1}{2}(\\mathbf{C} - \\mathbf{I})$, and denote the Second Piola-Kirchhoff stress (SPK) as $\\mathbf{S} = \\dfrac{\\partial W}{\\partial \\mathbf{E}}$. The algorithmic consistent moduli $\\mathbf{c}$ are defined as the fourth-order tensor $\\mathbf{c} = \\dfrac{\\partial^2 W}{\\partial \\mathbf{E} \\, \\partial \\mathbf{E}} = \\dfrac{\\partial \\mathbf{S}}{\\partial \\mathbf{E}}$. \n\nWork with the compressible Neo-Hookean model in three dimensions, with Lamé parameters $\\lambda$ and $\\mu$ (both in Pascals). The strain-energy density is given by\n$$\nW(\\mathbf{C}) = \\frac{\\mu}{2} (I_1 - 3) - \\mu \\ln J + \\frac{\\lambda}{2} (\\ln J)^2,\n$$\nwhere $I_1 = \\operatorname{tr}(\\mathbf{C})$, $J = \\det(\\mathbf{F})$, and $\\ln J$ is the natural logarithm of $J$. Note that $\\det(\\mathbf{C}) = J^2$, so $\\ln J = \\tfrac{1}{2} \\ln(\\det(\\mathbf{C}))$.\n\nYour tasks are:\n1. Starting from $W(\\mathbf{C})$, derive the Second Piola-Kirchhoff stress $\\mathbf{S}$ and the algorithmic consistent moduli $\\mathbf{c} = \\dfrac{\\partial \\mathbf{S}}{\\partial \\mathbf{E}}$ expressed as functions of $\\mathbf{C}$, $\\lambda$, and $\\mu$. Do not assume any shortcut formulas; base your derivation on fundamental differentiation rules, the chain rule, and the identity $\\mathrm{d}\\,\\mathbf{C}^{-1} = -\\mathbf{C}^{-1} (\\mathrm{d}\\,\\mathbf{C}) \\mathbf{C}^{-1}$.\n2. Implement a program that, for given $\\mathbf{F}$, $\\lambda$, and $\\mu$, computes:\n   - the analytic $\\mathbf{S}$ and $\\mathbf{c}$ derived in Task 1,\n   - finite-difference approximations to $\\dfrac{\\partial \\mathbf{S}}{\\partial \\mathbf{E}}$ by applying small symmetric perturbations $\\delta \\mathbf{E}$ to $\\mathbf{E}$ and using a central difference scheme.\n3. Quantify the relative error between the analytic derivative and its finite-difference approximation for each independent symmetric perturbation direction of $\\mathbf{E}$, and return the worst-case (maximum) relative error across these directions. Use the Frobenius norm for comparison:\n$$\ne = \\max_{n \\in \\{1,\\dots,6\\}} \\frac{\\left\\| \\left.\\frac{\\partial \\mathbf{S}}{\\partial \\mathbf{E}}\\right|_{\\text{FD},n} - \\left.\\frac{\\partial \\mathbf{S}}{\\partial \\mathbf{E}}\\right|_{\\text{analytic},n} \\right\\|_F}{\\max\\left(\\left\\| \\left.\\frac{\\partial \\mathbf{S}}{\\partial \\mathbf{E}}\\right|_{\\text{analytic},n} \\right\\|_F, \\, \\varepsilon\\right)},\n$$\nwhere each $n$ corresponds to a symmetric basis direction of $\\mathbf{E}$ among $\\{(1,1),(2,2),(3,3),(1,2),(2,3),(1,3)\\}$, and $\\varepsilon$ is a small regularization constant to avoid division by zero (choose $\\varepsilon = 10^{-12}$). The central difference step size for the strain perturbation must be $h = 10^{-6}$ (dimensionless), and the perturbation must be applied to $\\mathbf{C}$ via $\\delta \\mathbf{C} = 2 \\, \\delta \\mathbf{E}$.\n\nPhysical units: use $\\lambda$ and $\\mu$ in Pascals (Pa). The deformation gradient $\\mathbf{F}$ is dimensionless. The relative error $e$ is dimensionless. Angles are not used in this problem.\n\nTest Suite:\n- Case 1 (general moderate deformation): \n  - $\\lambda = 1.20 \\times 10^{5}\\,\\text{Pa}$, $\\mu = 8.00 \\times 10^{4}\\,\\text{Pa}$,\n  - $\\mathbf{F} = \\begin{bmatrix} 1.1 & 0.2 & 0.0 \\\\ 0.0 & 0.9 & 0.1 \\\\ 0.0 & 0.0 & 1.05 \\end{bmatrix}$.\n- Case 2 (near-incompressible response with small volumetric change):\n  - $\\lambda = 1.00 \\times 10^{6}\\,\\text{Pa}$, $\\mu = 1.00 \\times 10^{4}\\,\\text{Pa}$,\n  - $\\mathbf{F} = \\begin{bmatrix} 1.02 & 0.0 & 0.0 \\\\ 0.0 & 0.98 & 0.0 \\\\ 0.0 & 0.0 & 1.00 \\end{bmatrix}$.\n- Case 3 (significant compression along one axis with shear):\n  - $\\lambda = 5.00 \\times 10^{4}\\,\\text{Pa}$, $\\mu = 2.00 \\times 10^{5}\\,\\text{Pa}$,\n  - $\\mathbf{F} = \\begin{bmatrix} 1.0 & 0.3 & 0.0 \\\\ 0.0 & 1.0 & 0.0 \\\\ 0.0 & 0.0 & 0.8 \\end{bmatrix}$.\n\nYour program should produce a single line of output containing, for the above three cases, the worst-case relative error $e$ as a comma-separated list enclosed in square brackets (for example, $[e_1,e_2,e_3]$). Each $e_i$ must be a floating-point number. No additional text should be printed.", "solution": "The problem is valid as it is well-posed, scientifically grounded in the principles of continuum mechanics, and provides a complete and consistent set of definitions and data for a standard verification procedure in computational hyperelasticity.\n\n### Task 1: Derivation of Stress and Moduli\n\nThe primary task is to derive the Second Piola-Kirchhoff (SPK) stress tensor $\\mathbf{S}$ and the fourth-order tensor of algorithmic consistent moduli $\\mathbf{c}$ for a compressible Neo-Hookean material. The derivation will proceed from the given strain-energy density function $W$.\n\nThe strain-energy density function is given by:\n$$\nW(\\mathbf{C}) = \\frac{\\mu}{2} (I_1 - 3) - \\mu \\ln J + \\frac{\\lambda}{2} (\\ln J)^2\n$$\nwhere $I_1 = \\operatorname{tr}(\\mathbf{C})$, $J = \\det(\\mathbf{F}) = \\sqrt{\\det(\\mathbf{C})}$, and $\\mathbf{C} = \\mathbf{F}^{\\mathsf{T}}\\mathbf{F}$ is the Right Cauchy-Green tensor. The Lamé parameters $\\lambda$ and $\\mu$ are material constants.\n\nThe Green-Lagrange strain tensor $\\mathbf{E}$ is defined as $\\mathbf{E} = \\frac{1}{2}(\\mathbf{C} - \\mathbf{I})$, where $\\mathbf{I}$ is the second-order identity tensor. This gives the relationship $\\mathbf{C} = 2\\mathbf{E} + \\mathbf{I}$. The differentials are related by $\\mathrm{d}\\mathbf{C} = 2 \\, \\mathrm{d}\\mathbf{E}$.\n\nThe SPK stress $\\mathbf{S}$ and the moduli $\\mathbf{c}$ are defined by derivatives with respect to $\\mathbf{E}$:\n$$\n\\mathbf{S} = \\frac{\\partial W}{\\partial \\mathbf{E}}, \\quad \\mathbf{c} = \\frac{\\partial \\mathbf{S}}{\\partial \\mathbf{E}} = \\frac{\\partial^2 W}{\\partial \\mathbf{E} \\partial \\mathbf{E}}\n$$\nUsing the chain rule, we can express these derivatives in terms of $\\mathbf{C}$:\n$$\n\\mathbf{S} = \\frac{\\partial W}{\\partial \\mathbf{E}} = \\frac{\\partial W}{\\partial \\mathbf{C}} : \\frac{\\partial \\mathbf{C}}{\\partial \\mathbf{E}} = 2 \\frac{\\partial W}{\\partial \\mathbf{C}}\n$$\n$$\n\\mathbf{c} = \\frac{\\partial \\mathbf{S}}{\\partial \\mathbf{E}} = \\frac{\\partial \\mathbf{S}}{\\partial \\mathbf{C}} : \\frac{\\partial \\mathbf{C}}{\\partial \\mathbf{E}} = 2 \\frac{\\partial \\mathbf{S}}{\\partial \\mathbf{C}}\n$$\nThe factor of $2$ arises from the definition of $\\mathbf{E}$.\n\n#### Derivation of the Second Piola-Kirchhoff Stress $\\mathbf{S}$\n\nFirst, we compute the derivative of $W$ with respect to $\\mathbf{C}$. This requires the derivatives of its constituent parts, $I_1$ and $\\ln J$.\n\n1.  **Derivative of $I_1 = \\operatorname{tr}(\\mathbf{C})$:**\n    The trace is a linear operator, $I_1 = \\mathbf{I}:\\mathbf{C}$. Its derivative is:\n    $$\n    \\frac{\\partial I_1}{\\partial \\mathbf{C}} = \\mathbf{I}\n    $$\n\n2.  **Derivative of $\\ln J$:**\n    We are given $\\ln J = \\frac{1}{2}\\ln(\\det(\\mathbf{C}))$. Using the chain rule and Jacobi's formula for the derivative of a determinant, $\\frac{\\partial(\\det \\mathbf{A})}{\\partial \\mathbf{A}} = (\\det \\mathbf{A}) \\mathbf{A}^{-\\mathsf{T}}$, we have (since $\\mathbf{C}$ is symmetric):\n    $$\n    \\frac{\\partial (\\ln J)}{\\partial \\mathbf{C}} = \\frac{\\partial}{\\partial \\mathbf{C}}\\left(\\frac{1}{2}\\ln(\\det(\\mathbf{C}))\\right) = \\frac{1}{2} \\frac{1}{\\det(\\mathbf{C})} \\frac{\\partial(\\det \\mathbf{C})}{\\partial \\mathbf{C}} = \\frac{1}{2 J^2} (J^2 \\mathbf{C}^{-1}) = \\frac{1}{2}\\mathbf{C}^{-1}\n    $$\n    \nNow we can differentiate $W$:\n$$\n\\frac{\\partial W}{\\partial \\mathbf{C}} = \\frac{\\partial}{\\partial \\mathbf{C}}\\left[ \\frac{\\mu}{2} (I_1 - 3) - \\mu \\ln J + \\frac{\\lambda}{2} (\\ln J)^2 \\right]\n$$\n$$\n\\frac{\\partial W}{\\partial \\mathbf{C}} = \\frac{\\mu}{2} \\frac{\\partial I_1}{\\partial \\mathbf{C}} - \\mu \\frac{\\partial (\\ln J)}{\\partial \\mathbf{C}} + \\lambda (\\ln J) \\frac{\\partial (\\ln J)}{\\partial \\mathbf{C}}\n$$\nSubstituting the derivatives found above:\n$$\n\\frac{\\partial W}{\\partial \\mathbf{C}} = \\frac{\\mu}{2} \\mathbf{I} - \\mu \\left(\\frac{1}{2}\\mathbf{C}^{-1}\\right) + \\lambda (\\ln J) \\left(\\frac{1}{2}\\mathbf{C}^{-1}\\right) = \\frac{\\mu}{2} \\mathbf{I} + \\frac{1}{2}(\\lambda \\ln J - \\mu) \\mathbf{C}^{-1}\n$$\nThe SPK stress $\\mathbf{S}$ is $2 \\frac{\\partial W}{\\partial \\mathbf{C}}$:\n$$\n\\mathbf{S} = 2 \\left[ \\frac{\\mu}{2} \\mathbf{I} + \\frac{1}{2}(\\lambda \\ln J - \\mu) \\mathbf{C}^{-1} \\right] = \\mu \\mathbf{I} + (\\lambda \\ln J - \\mu) \\mathbf{C}^{-1}\n$$\nThis is the analytical expression for the Second Piola-Kirchhoff stress.\n\n#### Derivation of the Algorithmic Consistent Moduli $\\mathbf{c}$\n\nThe algorithmic moduli tensor is $\\mathbf{c} = 2 \\frac{\\partial \\mathbf{S}}{\\partial \\mathbf{C}}$. We must differentiate the expression for $\\mathbf{S}$ with respect to $\\mathbf{C}$.\n$$\n\\frac{\\partial \\mathbf{S}}{\\partial \\mathbf{C}} = \\frac{\\partial}{\\partial \\mathbf{C}} \\left[ \\mu \\mathbf{I} + (\\lambda \\ln J - \\mu) \\mathbf{C}^{-1} \\right]\n$$\nThe first term $\\mu\\mathbf{I}$ is constant with respect to $\\mathbf{C}$, so its derivative is zero. For the second term, we apply the product rule for tensors: $(\\phi \\mathbf{A})' = \\phi' \\otimes \\mathbf{A} + \\phi \\mathbf{A}'$.\nLet $\\phi = \\lambda \\ln J - \\mu$ and $\\mathbf{A} = \\mathbf{C}^{-1}$.\n$$\n\\frac{\\partial}{\\partial \\mathbf{C}} \\left[ (\\lambda \\ln J - \\mu) \\mathbf{C}^{-1} \\right] = \\left(\\frac{\\partial (\\lambda \\ln J - \\mu)}{\\partial \\mathbf{C}}\\right) \\otimes \\mathbf{C}^{-1} + (\\lambda \\ln J - \\mu) \\frac{\\partial \\mathbf{C}^{-1}}{\\partial \\mathbf{C}}\n$$\nWe evaluate each part:\n\n1.  **First term:** The derivative of the scalar part is:\n    $$\n    \\frac{\\partial (\\lambda \\ln J - \\mu)}{\\partial \\mathbf{C}} = \\lambda \\frac{\\partial (\\ln J)}{\\partial \\mathbf{C}} = \\frac{\\lambda}{2} \\mathbf{C}^{-1}\n    $$\n    The first term of the product rule is therefore $\\frac{\\lambda}{2} \\mathbf{C}^{-1} \\otimes \\mathbf{C}^{-1}$. In index notation, this is a fourth-order tensor with components $\\frac{\\lambda}{2} C^{-1}_{ij} C^{-1}_{kl}$.\n\n2.  **Second term:** We need the derivative of the inverse tensor, $\\frac{\\partial \\mathbf{C}^{-1}}{\\partial \\mathbf{C}}$. Using the identity $\\mathrm{d}(\\mathbf{C}^{-1}) = -\\mathbf{C}^{-1}(\\mathrm{d}\\mathbf{C})\\mathbf{C}^{-1}$ and ensuring the resulting operator maps symmetric tensors to symmetric tensors, the derivative is the fourth-order tensor $\\mathcal{K}$ with components:\n    $$\n    \\mathcal{K}_{ijkl} = \\frac{\\partial C^{-1}_{ij}}{\\partial C_{kl}} = -\\frac{1}{2} \\left( C^{-1}_{ik} C^{-1}_{jl} + C^{-1}_{il} C^{-1}_{jk} \\right)\n    $$\n    The second term of the product rule is thus $(\\lambda \\ln J - \\mu) \\mathcal{K}$.\n\nCombining both terms, we get $\\frac{\\partial \\mathbf{S}}{\\partial \\mathbf{C}}$:\n$$\n\\left(\\frac{\\partial \\mathbf{S}}{\\partial \\mathbf{C}}\\right)_{ijkl} = \\frac{\\lambda}{2} C^{-1}_{ij} C^{-1}_{kl} - \\frac{\\lambda \\ln J - \\mu}{2} \\left( C^{-1}_{ik} C^{-1}_{jl} + C^{-1}_{il} C^{-1}_{jk} \\right)\n$$\nFinally, the moduli tensor $\\mathbf{c} = 2 \\frac{\\partial \\mathbf{S}}{\\partial \\mathbf{C}}$ is obtained by multiplying by $2$:\n$$\nc_{ijkl} = \\lambda C^{-1}_{ij} C^{-1}_{kl} - (\\lambda \\ln J - \\mu) \\left( C^{-1}_{ik} C^{-1}_{jl} + C^{-1}_{il} C^{-1}_{jk} \\right)\n$$\nRearranging for a more conventional form:\n$$\nc_{ijkl} = \\lambda \\, C^{-1}_{ij} C^{-1}_{kl} + (\\mu - \\lambda \\ln J) \\left( C^{-1}_{ik} C^{-1}_{jl} + C^{-1}_{il} C^{-1}_{jk} \\right)\n$$\nThis is the analytical expression for the algorithmic consistent moduli, which possesses the required major and minor symmetries. These expressions for $\\mathbf{S}$ and $\\mathbf{c}$ will be implemented and verified numerically.\n\n### Task 2 & 3: Implementation and Error Quantification\n\nThe implementation involves computing $\\mathbf{S}$ and $\\mathbf{c}$ analytically using the derived formulas. Then, for verification, we approximate the action of the derivative $\\frac{\\partial \\mathbf{S}}{\\partial \\mathbf{E}}$ on a set of basis vectors. For a basis direction $\\mathbf{\\Delta}_n$ in the space of symmetric second-order tensors, the finite difference approximation of the directional derivative is calculated using a central difference scheme with step size $h$:\n$$\n\\left.\\frac{\\partial \\mathbf{S}}{\\partial \\mathbf{E}}\\right|_{\\text{FD},n} = \\frac{\\mathbf{S}(\\mathbf{E} + h \\mathbf{\\Delta}_n) - \\mathbf{S}(\\mathbf{E} - h \\mathbf{\\Delta}_n)}{2h}\n$$\nSince $\\mathbf{S}$ is a function of $\\mathbf{C} = 2\\mathbf{E} + \\mathbf{I}$, a perturbation $\\delta\\mathbf{E} = h\\mathbf{\\Delta}_n$ corresponds to a perturbation $\\delta\\mathbf{C} = 2h\\mathbf{\\Delta}_n$. The finite difference calculation becomes:\n$$\n\\frac{\\mathbf{S}(\\mathbf{C} + 2h\\mathbf{\\Delta}_n) - \\mathbf{S}(\\mathbf{C} - 2h\\mathbf{\\Delta}_n)}{2h}\n$$\nThis numerical result is compared against the analytical one, which is the tensor contraction $\\mathbf{c}:\\mathbf{\\Delta}_n$, with components $(c_{ijkl})(\\Delta_n)_{kl}$. The maximum relative error over the $6$ basis directions of symmetric $3 \\times 3$ tensors is then reported for each test case.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_S(C, lam, mu):\n    \"\"\"\n    Computes the Second Piola-Kirchhoff stress tensor S.\n    \n    Args:\n        C (np.ndarray): 3x3 Right Cauchy-Green tensor.\n        lam (float): First Lamé parameter.\n        mu (float): Second Lamé parameter (shear modulus).\n    \n    Returns:\n        np.ndarray: 3x3 Second Piola-Kirchhoff stress tensor.\n    \"\"\"\n    det_C = np.linalg.det(C)\n    if det_C <= 0:\n        raise ValueError(\"Determinant of C must be positive.\")\n    \n    J = np.sqrt(det_C)\n    ln_J = np.log(J)\n    C_inv = np.linalg.inv(C)\n    I = np.identity(3)\n    \n    S = mu * I + (lam * ln_J - mu) * C_inv\n    return S\n\ndef calculate_analytical_c(C, lam, mu):\n    \"\"\"\n    Computes the analytical algorithmic consistent tangent moduli c.\n    \n    Args:\n        C (np.ndarray): 3x3 Right Cauchy-Green tensor.\n        lam (float): First Lamé parameter.\n        mu (float): Second Lamé parameter (shear modulus).\n\n    Returns:\n        np.ndarray: 3x3x3x3 fourth-order tangent moduli tensor.\n    \"\"\"\n    det_C = np.linalg.det(C)\n    if det_C <= 0:\n        raise ValueError(\"Determinant of C must be positive.\")\n        \n    J = np.sqrt(det_C)\n    ln_J = np.log(J)\n    C_inv = np.linalg.inv(C)\n\n    # c_ijkl = lambda_ * C_inv_ij * C_inv_kl + (mu - lambda_ * ln(J)) * (C_inv_ik*C_inv_jl + C_inv_il*C_inv_jk)\n    \n    # Term 1: lambda * (C_inv (x) C_inv)\n    term1 = lam * np.einsum('ij,kl->ijkl', C_inv, C_inv)\n    \n    # Term 2: (mu - lambda * ln(J)) * (I_symm(C_inv))\n    term2_factor = mu - lam * ln_J\n    term2_tensor = np.einsum('ik,jl->ijkl', C_inv, C_inv) + np.einsum('il,jk->ijkl', C_inv, C_inv)\n    \n    c_analytic = term1 + term2_factor * term2_tensor\n    return c_analytic\n\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and compute errors.\n    \"\"\"\n    test_cases = [\n        (1.20e5, 8.00e4, np.array([[1.1, 0.2, 0.0], [0.0, 0.9, 0.1], [0.0, 0.0, 1.05]])),\n        (1.00e6, 1.00e4, np.array([[1.02, 0.0, 0.0], [0.0, 0.98, 0.0], [0.0, 0.0, 1.00]])),\n        (5.00e4, 2.00e5, np.array([[1.0, 0.3, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 0.8]]))\n    ]\n\n    h = 1e-6\n    epsilon = 1e-12\n    max_errors = []\n\n    # Define the 6 independent symmetric perturbation basis directions for E.\n    perturbation_directions = []\n    # Diagonal directions (1,1), (2,2), (3,3)\n    for i in range(3):\n        delta = np.zeros((3, 3))\n        delta[i, i] = 1.0\n        perturbation_directions.append(delta)\n    # Off-diagonal directions (1,2), (2,3), (1,3)\n    for i, j in [(0, 1), (1, 2), (0, 2)]:\n        delta = np.zeros((3, 3))\n        delta[i, j] = 1.0\n        delta[j, i] = 1.0\n        perturbation_directions.append(delta)\n\n    for lam, mu, F in test_cases:\n        # Base calculation at the given deformation state\n        C = F.T @ F\n        \n        # 1. Compute analytical tangent moduli tensor c\n        c_analytic = calculate_analytical_c(C, lam, mu)\n        \n        errors_for_case = []\n        \n        # 2. Loop through perturbation directions to perform finite difference check\n        for delta_E_dir in perturbation_directions:\n            # Perturbation in C is 2 * delta_E\n            # The step size for delta_E is h\n            delta_C = 2 * h * delta_E_dir\n            \n            # Calculate S at perturbed states using central difference\n            C_plus = C + delta_C\n            C_minus = C - delta_C\n            \n            S_plus = calculate_S(C_plus, lam, mu)\n            S_minus = calculate_S(C_minus, lam, mu)\n            \n            # Finite difference approximation of (c : delta_E_dir)\n            # This is the directional derivative of S wrt E in direction delta_E_dir\n            c_colon_delta_fd = (S_plus - S_minus) / (2 * h)\n            \n            # Analytical result for comparison: contract c with the direction\n            c_colon_delta_analytic = np.einsum('ijkl, kl -> ij', c_analytic, delta_E_dir)\n\n            # 3. Quantify relative error for this direction\n            numerator = np.linalg.norm(c_colon_delta_fd - c_colon_delta_analytic, 'fro')\n            denominator = np.linalg.norm(c_colon_delta_analytic, 'fro')\n            \n            # Apply regularization to avoid division by zero\n            denominator = max(denominator, epsilon)\n            \n            relative_error = numerator / denominator\n            errors_for_case.append(relative_error)\n        \n        # Worst-case error for this test case\n        max_error = max(errors_for_case)\n        max_errors.append(max_error)\n        \n    print(f\"[{','.join(map(str, max_errors))}]\")\n\nsolve()\n\n```", "id": "3543698"}, {"introduction": "Many modern hyperelastic models gain physical insight and numerical stability by decomposing the deformation gradient into stretch and rotation via the polar decomposition. A robust simulation requires the consistent linearization of this decomposition, which can be challenging in states of severe deformation where the gradient is nearly singular [@problem_id:3543722]. This practice challenges you to design and validate a numerically stable algorithm based on the Singular Value Decomposition (SVD) to compute the derivatives of the stretch and rotation tensors, a critical technique for production-level finite element codes.", "problem": "You are asked to design and validate a numerically robust algorithm for computing the derivatives of the orthogonal factor and the right stretch in the polar decomposition needed for an algorithmic consistent tangent operator in hyperelasticity. Let $ \\mathbf{F} \\in \\mathbb{R}^{3 \\times 3} $ be the deformation gradient with polar decomposition $ \\mathbf{F} = \\mathbf{R} \\mathbf{U} $, where $ \\mathbf{R} \\in \\mathrm{SO}(3) $ is the proper orthogonal rotation and $ \\mathbf{U} \\in \\mathbb{R}^{3 \\times 3} $ is the symmetric positive-definite right stretch. The goal is to compute the linear maps $ \\mathrm{d}\\mathbf{U}[\\mathrm{d}\\mathbf{F}] $ and $ \\mathrm{d}\\mathbf{R}[\\mathrm{d}\\mathbf{F}] $ robustly using a Singular Value Decomposition (SVD) based approach that remains stable even when $ \\mathbf{F} $ is nearly rank-deficient, and then use these to assemble the algorithmic consistent tangent for a hyperelastic energy that depends only on $ \\mathbf{U} $.\n\nBase your derivation solely on the following fundamental definitions and facts:\n- The polar decomposition $ \\mathbf{F} = \\mathbf{R} \\mathbf{U} $ with $ \\mathbf{R}^\\mathsf{T} \\mathbf{R} = \\mathbf{I} $, $ \\det \\mathbf{R} = 1 $, and $ \\mathbf{U} = (\\mathbf{F}^\\mathsf{T} \\mathbf{F})^{1/2} $.\n- The Singular Value Decomposition $ \\mathbf{F} = \\bar{\\mathbf{U}} \\boldsymbol{\\Sigma} \\mathbf{V}^\\mathsf{T} $ with $ \\boldsymbol{\\Sigma} = \\mathrm{diag}(\\sigma_1,\\sigma_2,\\sigma_3) $, $ \\sigma_i \\ge 0 $, $ \\bar{\\mathbf{U}}, \\mathbf{V} \\in \\mathrm{O}(3) $, and the identities $ \\mathbf{R} = \\bar{\\mathbf{U}} \\mathbf{V}^\\mathsf{T} $, $ \\mathbf{U} = \\mathbf{V} \\boldsymbol{\\Sigma} \\mathbf{V}^\\mathsf{T} $.\n- The compressible Neo-Hookean stored energy written as a function of $ \\mathbf{U} $:\n$$\nW(\\mathbf{U}) = \\frac{\\mu}{2} \\left( \\mathrm{tr}(\\mathbf{U}^2) - 3 \\right) - \\mu \\ln J + \\frac{\\lambda}{2} (\\ln J)^2,\n$$\nwith $ J = \\det \\mathbf{U} = \\det \\mathbf{F} $, shear modulus $ \\mu > 0 $, and first Lamé parameter $ \\lambda > 0 $.\n- The first Piola-Kirchhoff stress for an energy depending only on $ \\mathbf{U} $ can be expressed as $ \\mathbf{P} = \\mathbf{R} \\, \\mathbf{S}(\\mathbf{U}) $, where $ \\mathbf{S}(\\mathbf{U}) = \\partial W / \\partial \\mathbf{U} $ is symmetric.\n- The algorithmic consistent tangent is the Fréchet derivative $ \\mathbb{A}[\\mathrm{d}\\mathbf{F}] = \\mathrm{d}\\mathbf{P}[\\mathrm{d}\\mathbf{F}] $.\n\nYour tasks are:\n1) Derive expressions for $ \\mathrm{d}\\mathbf{U}[\\mathrm{d}\\mathbf{F}] $ and $ \\mathrm{d}\\mathbf{R}[\\mathrm{d}\\mathbf{F}] $ that are valid for general, non-singular $ \\mathbf{F} $, starting from the polar decomposition identities and the definition $ \\mathbf{U} = (\\mathbf{F}^\\mathsf{T} \\mathbf{F})^{1/2} $. Show how to pose the necessary linear matrix equations for $ \\mathrm{d}\\mathbf{U} $ and for the skew-symmetric generator $ \\boldsymbol{\\Omega} $ such that $ \\mathrm{d}\\mathbf{R} = \\mathbf{R} \\boldsymbol{\\Omega} $.\n2) Propose a robust SVD-based computational algorithm to evaluate these derivatives that remains well behaved when $ \\mathbf{F} $ is nearly rank-deficient (e.g., when one singular value $ \\sigma_i $ is extremely small). Your algorithm must use only quantities obtained from the SVD and should include a regularization strategy for any divisions that become ill-conditioned. Explicitly state how you regularize the denominators in the spectral formulas you derive, and how you ensure $ \\det \\mathbf{R} = 1 $ when computing from the SVD.\n3) Using the results from (1) and (2), derive a formula for the algorithmic consistent tangent action $ \\mathbb{A}[\\mathrm{d}\\mathbf{F}] = \\mathrm{d}\\mathbf{P}[\\mathrm{d}\\mathbf{F}] $ for the given hyperelastic model expressed entirely in terms of $ \\mathbf{R} $, $ \\mathbf{U} $, $ \\mathbf{S}(\\mathbf{U}) $, the second derivative $ \\partial^2 W / \\partial \\mathbf{U} \\partial \\mathbf{U} $ acting on $ \\mathrm{d}\\mathbf{U} $, and $ \\boldsymbol{\\Omega} $.\n\nImplementation requirements:\n- Implement a program that computes:\n  - The derivative maps $ \\mathrm{d}\\mathbf{U}[\\mathrm{d}\\mathbf{F}] $ and $ \\boldsymbol{\\Omega}[\\mathrm{d}\\mathbf{F}] $ via your robust SVD-based algorithm.\n  - The first Piola-Kirchhoff stress $ \\mathbf{P}(\\mathbf{F}) = \\mathbf{R} \\, \\mathbf{S}(\\mathbf{U}) $.\n  - The algorithmic consistent tangent action $ \\mathbb{A}[\\mathrm{d}\\mathbf{F}] $ as $ \\mathrm{d}\\mathbf{P}[\\mathrm{d}\\mathbf{F}] $ using the chain rule built on your computed $ \\mathrm{d}\\mathbf{U} $ and $ \\boldsymbol{\\Omega} $.\n  - Independent finite-difference checks for $ \\mathrm{d}\\mathbf{U}[\\mathrm{d}\\mathbf{F}] $, $ \\boldsymbol{\\Omega}[\\mathrm{d}\\mathbf{F}] $, and $ \\mathbb{A}[\\mathrm{d}\\mathbf{F}] $ using a central-difference scheme with a small step $ \\varepsilon $.\n- All quantities are nondimensional. No physical units are required.\n- All angles used internally, if any are needed, must be in radians.\n\nTest suite:\nUse $ \\lambda = 20 $ and $ \\mu = 10 $. For each case below, use the provided $ \\mathbf{F} $ and direction $ \\mathrm{d}\\mathbf{F} $ (both $ 3 \\times 3 $ matrices), and central-difference step $ \\varepsilon = 10^{-8} $:\n- Case 1 (general well-conditioned):\n  - $ \\mathbf{F}_1 = \\begin{bmatrix} 1.2 & 0.3 & 0.1 \\\\ 0.2 & 0.9 & -0.4 \\\\ 0.0 & 0.5 & 1.1 \\end{bmatrix} $,\n  - $ \\mathrm{d}\\mathbf{F}_1 = \\begin{bmatrix} 0.01 & -0.02 & 0.03 \\\\ -0.01 & 0.02 & 0.01 \\\\ 0.0 & -0.03 & 0.04 \\end{bmatrix} $.\n- Case 2 (highly distorted, nearly rank-deficient): Let $ \\theta = 0.7 $. Define the rotation about the unit axis $ \\mathbf{a} = \\frac{1}{\\sqrt{3}} [1,1,1]^\\mathsf{T} $ by Rodrigues' formula, and set\n  - $ \\mathbf{F}_2 = \\mathbf{R}_\\theta \\, \\mathrm{diag}(2.5, 10^{-6}, 0.5) $,\n  - $ \\mathrm{d}\\mathbf{F}_2 = \\begin{bmatrix} 0.02 & 0.01 & -0.01 \\\\ -0.03 & 0.04 & 0.02 \\\\ 0.01 & -0.02 & 0.03 \\end{bmatrix} $.\n- Case 3 (nearly repeated singular values): Let $ \\phi = 0.9 $ and $ \\psi = -0.4 $ define two independent rotations about axes $ \\mathbf{e}_z $ and $ \\mathbf{e}_x $ respectively; set\n  - $ \\mathbf{F}_3 = \\mathbf{R}_z(\\phi) \\, \\mathrm{diag}(1.0, 1.0 + 10^{-8}, 0.7) \\, \\mathbf{R}_x(\\psi)^\\mathsf{T} $,\n  - $ \\mathrm{d}\\mathbf{F}_3 = \\begin{bmatrix} -0.015 & 0.005 & 0.01 \\\\ 0.025 & -0.02 & 0.005 \\\\ -0.005 & 0.015 & -0.01 \\end{bmatrix} $.\n\nFor each case $ k \\in \\{1,2,3\\} $, compute the following dimensionless relative errors:\n- $ e^{(k)}_{\\mathbf{U}} = \\dfrac{\\left\\| \\mathrm{d}\\mathbf{U}_\\text{algo} - \\mathrm{d}\\mathbf{U}_\\text{fd} \\right\\|_F}{\\max\\left(10^{-30}, \\left\\| \\mathrm{d}\\mathbf{U}_\\text{fd} \\right\\|_F \\right)} $,\n- $ e^{(k)}_{\\boldsymbol{\\Omega}} = \\dfrac{\\left\\| \\boldsymbol{\\Omega}_\\text{algo} - \\boldsymbol{\\Omega}_\\text{fd} \\right\\|_F}{\\max\\left(10^{-30}, \\left\\| \\boldsymbol{\\Omega}_\\text{fd} \\right\\|_F \\right)} $, where $ \\boldsymbol{\\Omega}_\\text{fd} $ is obtained from $ \\mathbf{R}^\\mathsf{T} \\, \\mathrm{d}\\mathbf{R}_\\text{fd} $ projected onto the skew-symmetric part,\n- $ e^{(k)}_{\\mathbb{A}} = \\dfrac{\\left\\| \\mathbb{A}_\\text{algo}[\\mathrm{d}\\mathbf{F}_k] - \\mathrm{d}\\mathbf{P}_\\text{fd} \\right\\|_F}{\\max\\left(10^{-30}, \\left\\| \\mathrm{d}\\mathbf{P}_\\text{fd} \\right\\|_F \\right)} $.\n\nProgram output format:\n- Your program should produce a single line of output containing the nine results as a comma-separated list enclosed in square brackets in the following order: $ [ e^{(1)}_{\\mathbf{U}}, e^{(1)}_{\\boldsymbol{\\Omega}}, e^{(1)}_{\\mathbb{A}}, e^{(2)}_{\\mathbf{U}}, e^{(2)}_{\\boldsymbol{\\Omega}}, e^{(2)}_{\\mathbb{A}}, e^{(3)}_{\\mathbf{U}}, e^{(3)}_{\\boldsymbol{\\Omega}}, e^{(3)}_{\\mathbb{A}} ] $.", "solution": "The problem requires the derivation and implementation of a robust algorithm for computing the derivatives of the polar decomposition factors of the deformation gradient, $ \\mathbf{F} $, and using these to compute the algorithmic consistent tangent for a compressible Neo-Hookean material. The process will be detailed in three parts as requested.\n\n### Part 1: Derivation of Linear Matrix Equations for $ \\mathrm{d}\\mathbf{U} $ and $ \\boldsymbol{\\Omega} $\n\nLet the deformation gradient be $ \\mathbf{F} \\in \\mathbb{R}^{3\\times3} $. Its polar decomposition is $ \\mathbf{F} = \\mathbf{R} \\mathbf{U} $, where $ \\mathbf{R} \\in \\mathrm{SO}(3) $ is a proper orthogonal rotation tensor ($ \\mathbf{R}^\\mathsf{T}\\mathbf{R}=\\mathbf{I} $, $ \\det\\mathbf{R}=1 $) and $ \\mathbf{U} $ is the symmetric, positive-definite right stretch tensor. The time rate or directional derivative of a quantity will be denoted by $ \\mathrm{d}(\\cdot) $, which is a linear map acting on the increment $ \\mathrm{d}\\mathbf{F} $.\n\nWe start by taking the derivative of the polar decomposition expression:\n$$ \\mathrm{d}\\mathbf{F} = \\mathrm{d}\\mathbf{R} \\, \\mathbf{U} + \\mathbf{R} \\, \\mathrm{d}\\mathbf{U} $$\nThe derivative of the rotation tensor, $ \\mathrm{d}\\mathbf{R} $, can be expressed in terms of a skew-symmetric tensor $ \\boldsymbol{\\Omega} $ as $ \\mathrm{d}\\mathbf{R} = \\mathbf{R} \\boldsymbol{\\Omega} $. The skew-symmetry of $ \\boldsymbol{\\Omega} $ arises from the orthogonality condition $ \\mathbf{R}^\\mathsf{T}\\mathbf{R}=\\mathbf{I} $, whose derivative gives $ \\mathrm{d}\\mathbf{R}^\\mathsf{T}\\mathbf{R} + \\mathbf{R}^\\mathsf{T}\\mathrm{d}\\mathbf{R} = \\mathbf{0} $, leading to $ \\boldsymbol{\\Omega}^\\mathsf{T} + \\boldsymbol{\\Omega} = \\mathbf{0} $.\n\nSubstituting $ \\mathrm{d}\\mathbf{R} = \\mathbf{R} \\boldsymbol{\\Omega} $ into the derivative of $ \\mathbf{F} $:\n$$ \\mathrm{d}\\mathbf{F} = \\mathbf{R} \\boldsymbol{\\Omega} \\mathbf{U} + \\mathbf{R} \\, \\mathrm{d}\\mathbf{U} $$\nLeft-multiplying by $ \\mathbf{R}^\\mathsf{T} $, we obtain:\n$$ \\mathbf{R}^\\mathsf{T} \\mathrm{d}\\mathbf{F} = \\boldsymbol{\\Omega} \\mathbf{U} + \\mathrm{d}\\mathbf{U} $$\nLet us define the tensor $ \\mathbf{L} = \\mathbf{R}^\\mathsf{T} \\mathrm{d}\\mathbf{F} $. The equation becomes $ \\mathbf{L} = \\boldsymbol{\\Omega} \\mathbf{U} + \\mathrm{d}\\mathbf{U} $.\nThe tensor $ \\mathrm{d}\\mathbf{U} $ must be symmetric since $ \\mathbf{U} $ is symmetric. $ \\boldsymbol{\\Omega} $ is skew-symmetric. We can decompose $ \\mathbf{L} $ into its symmetric and skew-symmetric parts: $ \\mathbf{L} = \\mathrm{symm}(\\mathbf{L}) + \\mathrm{skew}(\\mathbf{L}) $.\n$$ \\mathrm{symm}(\\mathbf{L}) = \\mathrm{symm}(\\boldsymbol{\\Omega} \\mathbf{U} + \\mathrm{d}\\mathbf{U}) = \\mathrm{symm}(\\boldsymbol{\\Omega} \\mathbf{U}) + \\mathrm{d}\\mathbf{U} $$\n$$ \\mathrm{skew}(\\mathbf{L}) = \\mathrm{skew}(\\boldsymbol{\\Omega} \\mathbf{U} + \\mathrm{d}\\mathbf{U}) = \\mathrm{skew}(\\boldsymbol{\\Omega} \\mathbf{U}) $$\nThe second equation provides a linear system for $ \\boldsymbol{\\Omega} $. Expanding the skew-symmetric part:\n$$ \\mathrm{skew}(\\boldsymbol{\\Omega} \\mathbf{U}) = \\frac{1}{2}\\left( \\boldsymbol{\\Omega}\\mathbf{U} - (\\boldsymbol{\\Omega}\\mathbf{U})^\\mathsf{T} \\right) = \\frac{1}{2}\\left( \\boldsymbol{\\Omega}\\mathbf{U} - \\mathbf{U}^\\mathsf{T}\\boldsymbol{\\Omega}^\\mathsf{T} \\right) $$\nUsing $ \\mathbf{U}^\\mathsf{T} = \\mathbf{U} $ and $ \\boldsymbol{\\Omega}^\\mathsf{T} = -\\boldsymbol{\\Omega} $, this becomes:\n$$ \\mathrm{skew}(\\boldsymbol{\\Omega} \\mathbf{U}) = \\frac{1}{2}\\left( \\boldsymbol{\\Omega}\\mathbf{U} + \\mathbf{U}\\boldsymbol{\\Omega} \\right) $$\nThus, we obtain the first linear matrix equation, a continuous Sylvester (or Lyapunov) equation for $ \\boldsymbol{\\Omega} $:\n$$ 2\\,\\mathrm{skew}(\\mathbf{L}) = \\boldsymbol{\\Omega}\\mathbf{U} + \\mathbf{U}\\boldsymbol{\\Omega} $$\nOnce $ \\boldsymbol{\\Omega} $ is found, $ \\mathrm{d}\\mathbf{U} $ can be immediately calculated from $ \\mathbf{L} = \\boldsymbol{\\Omega} \\mathbf{U} + \\mathrm{d}\\mathbf{U} $ as:\n$$ \\mathrm{d}\\mathbf{U} = \\mathbf{L} - \\boldsymbol{\\Omega}\\mathbf{U} $$\nThis system constitutes the required linear matrix equations. Alternatively, one could start from $ \\mathbf{U}^2 = \\mathbf{F}^\\mathsf{T}\\mathbf{F} $, which yields a Sylvester equation for $ \\mathrm{d}\\mathbf{U} $ directly. Both approaches are consistent and lead to the same solution.\n\n### Part 2: Robust SVD-based Computational Algorithm\n\nTo solve these equations robustly, especially in cases of nearly repeated or zero singular values, we project them onto the eigenbasis of $ \\mathbf{U} $. The Singular Value Decomposition (SVD) of $ \\mathbf{F} $ is $ \\mathbf{F} = \\bar{\\mathbf{U}} \\boldsymbol{\\Sigma} \\mathbf{V}^\\mathsf{T} $, where $ \\boldsymbol{\\Sigma} = \\mathrm{diag}(\\sigma_1, \\sigma_2, \\sigma_3) $. The polar decomposition factors are related to the SVD factors by $ \\mathbf{R} = \\bar{\\mathbf{U}} \\mathbf{V}^\\mathsf{T} $ and $ \\mathbf{U} = \\mathbf{V} \\boldsymbol{\\Sigma} \\mathbf{V}^\\mathsf{T} $. The columns of $ \\mathbf{V} $ are the eigenvectors of $ \\mathbf{U} $.\n\nTo ensure $ \\det\\mathbf{R} = 1 $, we adopt the standard procedure for hyperelasticity, where $ \\det\\mathbf{F}>0 $. If the SVD algorithm yields $ \\det(\\bar{\\mathbf{U}}\\mathbf{V}^\\mathsf{T}) = -1 $, we adjust one of the orthogonal matrices. A common stable choice is to flip the sign of the column of $ \\bar{\\mathbf{U}} $ corresponding to the smallest singular value. However, a simpler and more common method is to enforce $ \\det \\mathbf{R} = 1 $ by defining $\\mathbf{R} = \\bar{\\mathbf{U}} \\mathbf{J} \\mathbf{V}^\\mathsf{T}$ where $\\mathbf{J} = \\mathrm{diag}(1, 1, \\det(\\bar{\\mathbf{U}}\\mathbf{V}^\\mathsf{T}))$. For brevity, we redefine $ \\bar{\\mathbf{U}} \\leftarrow \\bar{\\mathbf{U}}\\mathbf{J} $ so that $ \\mathbf{R} = \\bar{\\mathbf{U}}\\mathbf{V}^\\mathsf{T} $ always has determinant $ +1 $.\n\nLet us transform the equations into the eigenbasis of $ \\mathbf{U} $, defined by $ \\mathbf{V} $. Let $ \\hat{(\\cdot)} = \\mathbf{V}^\\mathsf{T} (\\cdot) \\mathbf{V} $. The equation $ 2\\,\\mathrm{skew}(\\mathbf{L}) = \\boldsymbol{\\Omega}\\mathbf{U} + \\mathbf{U}\\boldsymbol{\\Omega} $ becomes:\n$$ 2\\,\\mathrm{skew}(\\hat{\\mathbf{L}}) = \\hat{\\boldsymbol{\\Omega}}\\boldsymbol{\\Sigma} + \\boldsymbol{\\Sigma}\\hat{\\boldsymbol{\\Omega}} $$\nwhere $ \\hat{\\mathbf{L}} = \\mathbf{V}^\\mathsf{T} \\mathbf{R}^\\mathsf{T} \\mathrm{d}\\mathbf{F} \\mathbf{V} = (\\mathbf{R}\\mathbf{V})^\\mathsf{T} \\mathrm{d}\\mathbf{F} \\mathbf{V} = \\bar{\\mathbf{U}}^\\mathsf{T} \\mathrm{d}\\mathbf{F} \\mathbf{V} $. Let's denote this matrix by $ \\mathbf{M} $.\nIn component form, for $ i,j \\in \\{1,2,3\\} $:\n$$ 2\\,\\mathrm{skew}(M)_{ij} = \\hat{\\Omega}_{ij}\\sigma_j + \\sigma_i\\hat{\\Omega}_{ij} = (\\sigma_i + \\sigma_j)\\hat{\\Omega}_{ij} $$\n$$ M_{ij} - M_{ji} = (\\sigma_i + \\sigma_j)\\hat{\\Omega}_{ij} $$\nThis gives a component-wise solution for $ \\hat{\\Omega}_{ij} $:\n$$ \\hat{\\Omega}_{ij} = \\frac{M_{ij} - M_{ji}}{\\sigma_i + \\sigma_j} $$\nThis formula is robust, as the denominator $ \\sigma_i + \\sigma_j $ is non-zero as long as not both singular values are zero, which is true for any physically meaningful deformation. This form gracefully handles the case of repeated singular values ($ \\sigma_i = \\sigma_j $), where the alternative formulation with $ (\\sigma_j - \\sigma_i) $ in the denominator would fail.\n\nNow we find $ \\mathrm{d}\\mathbf{U} $. From $ \\mathrm{d}\\mathbf{U} = \\mathbf{L} - \\boldsymbol{\\Omega}\\mathbf{U} $, we transform to the eigenbasis:\n$$ \\hat{\\mathrm{d}\\mathbf{U}} = \\hat{\\mathbf{L}} - \\hat{\\boldsymbol{\\Omega}}\\boldsymbol{\\Sigma} = \\mathbf{M} - \\hat{\\boldsymbol{\\Omega}}\\boldsymbol{\\Sigma} $$\nComponent-wise:\n$$ (\\hat{\\mathrm{d}\\mathbf{U}})_{ij} = M_{ij} - \\hat{\\Omega}_{ij}\\sigma_j = M_{ij} - \\frac{M_{ij} - M_{ji}}{\\sigma_i + \\sigma_j} \\sigma_j $$\n$$ (\\hat{\\mathrm{d}\\mathbf{U}})_{ij} = \\frac{M_{ij}(\\sigma_i + \\sigma_j) - (M_{ij} - M_{ji})\\sigma_j}{\\sigma_i + \\sigma_j} = \\frac{M_{ij}\\sigma_i + M_{ji}\\sigma_j}{\\sigma_i + \\sigma_j} $$\nThis formula is also robust. For computational implementation, when $ \\sigma_i + \\sigma_j $ is close to zero (indicating a highly degenerate state), the corresponding components can be set to zero, as they will correspond to indeterminate deformation modes.\n\nThe algorithm is as follows:\n1.  Given $ \\mathbf{F} $ and $ \\mathrm{d}\\mathbf{F} $, compute the SVD of $ \\mathbf{F} = \\bar{\\mathbf{U}} \\boldsymbol{\\Sigma} \\mathbf{V}^\\mathsf{T} $.\n2.  Adjust $ \\bar{\\mathbf{U}} $ to ensure $ \\det(\\bar{\\mathbf{U}}\\mathbf{V}^\\mathsf{T}) = 1 $. For instance, if $ \\det(\\bar{\\mathbf{U}})\\det(\\mathbf{V}) = -1 $, multiply the last column of $ \\bar{\\mathbf{U}} $ by $ -1 $.\n3.  Compute $ \\mathbf{M} = \\bar{\\mathbf{U}}^\\mathsf{T} \\mathrm{d}\\mathbf{F} \\mathbf{V} $.\n4.  Compute components of $ \\hat{\\mathrm{d}\\mathbf{U}} $ and $ \\hat{\\boldsymbol{\\Omega}} $ using the spectral formulas above, with a small tolerance for the denominator to handle potential floating-point issues near zero.\n5.  Transform back to the original basis: $ \\mathrm{d}\\mathbf{U} = \\mathbf{V} \\hat{\\mathrm{d}\\mathbf{U}} \\mathbf{V}^\\mathsf{T} $ and $ \\boldsymbol{\\Omega} = \\mathbf{V} \\hat{\\boldsymbol{\\Omega}} \\mathbf{V}^\\mathsf{T} $.\n\n### Part 3: Algorithmic Consistent Tangent\n\nThe first Piola-Kirchhoff stress is $ \\mathbf{P}(\\mathbf{F}) = \\mathbf{R} \\, \\mathbf{S}(\\mathbf{U}) $, where $ \\mathbf{S}(\\mathbf{U}) = \\partial W/\\partial \\mathbf{U} $. The algorithmic consistent tangent is its Fréchet derivative, $ \\mathbb{A}[\\mathrm{d}\\mathbf{F}] = \\mathrm{d}\\mathbf{P}[\\mathrm{d}\\mathbf{F}] $. Applying the product rule:\n$$ \\mathrm{d}\\mathbf{P} = \\mathrm{d}\\mathbf{R} \\, \\mathbf{S} + \\mathbf{R} \\, \\mathrm{d}\\mathbf{S} $$\nUsing $ \\mathrm{d}\\mathbf{R} = \\mathbf{R}\\boldsymbol{\\Omega} $ and the chain rule for $ \\mathrm{d}\\mathbf{S} = (\\partial \\mathbf{S}/\\partial \\mathbf{U})[\\mathrm{d}\\mathbf{U}] = (\\partial^2 W/\\partial \\mathbf{U}\\partial \\mathbf{U})[\\mathrm{d}\\mathbf{U}] =: \\mathbb{C}^\\mathbf{U}[\\mathrm{d}\\mathbf{U}] $, we get:\n$$ \\mathbb{A}[\\mathrm{d}\\mathbf{F}] = \\mathbf{R}\\boldsymbol{\\Omega}\\mathbf{S} + \\mathbf{R}\\,\\mathbb{C}^\\mathbf{U}[\\mathrm{d}\\mathbf{U}] $$\nFor the given Neo-Hookean energy functional $ W(\\mathbf{U}) = \\frac{\\mu}{2} (\\mathrm{tr}(\\mathbf{U}^2) - 3) - \\mu \\ln J + \\frac{\\lambda}{2} (\\ln J)^2 $ where $ J = \\det\\mathbf{U} $, we find the stress $ \\mathbf{S} $ and its derivative $ \\mathbb{C}^\\mathbf{U}[\\mathrm{d}\\mathbf{U}] $.\nThe derivative of the trace term is $ \\partial(\\mathrm{tr}(\\mathbf{U}^2))/\\partial \\mathbf{U} = 2\\mathbf{U} $. The derivative of the volumetric term is $ \\partial(\\ln J)/\\partial \\mathbf{U} = J^{-1} (\\partial J/\\partial \\mathbf{U}) = J^{-1} (J \\mathbf{U}^{-\\mathsf{T}}) = \\mathbf{U}^{-1} $.\nThus, the symmetric stress tensor $ \\mathbf{S} $ is:\n$$ \\mathbf{S} = \\frac{\\partial W}{\\partial \\mathbf{U}} = \\mu\\mathbf{U} - \\mu J^{-1}J\\mathbf{U}^{-1} + \\lambda (\\ln J) J^{-1}J\\mathbf{U}^{-1} = \\mu\\mathbf{U} + (\\lambda \\ln J - \\mu)\\mathbf{U}^{-1} $$\nNow we compute its derivative, $ \\mathrm{d}\\mathbf{S} = \\mathbb{C}^\\mathbf{U}[\\mathrm{d}\\mathbf{U}] $:\n$$ \\mathrm{d}\\mathbf{S} = \\mu\\,\\mathrm{d}\\mathbf{U} + \\mathrm{d}(\\lambda \\ln J - \\mu)\\,\\mathbf{U}^{-1} + (\\lambda \\ln J - \\mu)\\,\\mathrm{d}(\\mathbf{U}^{-1}) $$\nWe need the derivatives $ \\mathrm{d}(\\ln J) = J^{-1}\\mathrm{d}J = \\mathrm{tr}(\\mathbf{U}^{-1}\\mathrm{d}\\mathbf{U}) $ and $ \\mathrm{d}(\\mathbf{U}^{-1}) = -\\mathbf{U}^{-1}\\mathrm{d}\\mathbf{U}\\mathbf{U}^{-1} $.\nSubstituting these gives the action of the material tangent operator $ \\mathbb{C}^\\mathbf{U} $:\n$$ \\mathbb{C}^\\mathbf{U}[\\mathrm{d}\\mathbf{U}] = \\mu\\,\\mathrm{d}\\mathbf{U} + \\lambda\\,\\mathrm{tr}(\\mathbf{U}^{-1}\\mathrm{d}\\mathbf{U})\\,\\mathbf{U}^{-1} - (\\lambda \\ln J - \\mu)\\,\\mathbf{U}^{-1}\\mathrm{d}\\mathbf{U}\\mathbf{U}^{-1} $$\nThe final expression for the action of the algorithmic consistent tangent is obtained by substituting $ \\mathbf{S} $ and $ \\mathbb{C}^\\mathbf{U}[\\mathrm{d}\\mathbf{U}] $ into the expression for $ \\mathrm{d}\\mathbf{P} $. All quantities required are now defined in terms of $ \\mathbf{U} $, $ \\mathrm{d}\\mathbf{U} $, and $ \\boldsymbol{\\Omega} $.", "answer": "```python\nimport numpy as np\n\ndef rodrigues_formula(axis, angle):\n    \"\"\"Computes a rotation matrix using Rodrigues' formula.\"\"\"\n    axis = axis / np.linalg.norm(axis)\n    K = np.array([\n        [0, -axis[2], axis[1]],\n        [axis[2], 0, -axis[0]],\n        [-axis[1], axis[0], 0]\n    ])\n    R = np.eye(3) + np.sin(angle) * K + (1 - np.cos(angle)) * np.dot(K, K)\n    return R\n\ndef get_polar_decomposition(F):\n    \"\"\"Computes polar decomposition F = R U ensuring det(R) = 1.\"\"\"\n    ubar, s_diag, v_t = np.linalg.svd(F)\n    v = v_t.T\n    \n    # Ensure R has determinant +1, which is standard for hyperelasticity\n    det_check = np.linalg.det(ubar) * np.linalg.det(v)\n    if det_check < 0:\n        ubar[:, -1] *= -1\n\n    R = ubar @ v.T\n    U = v @ np.diag(s_diag) @ v.T\n    return R, U, ubar, np.diag(s_diag), v\n\ndef solve_one_case(F_in, dF_in, lamb, mu):\n    \"\"\"Computes analytical derivatives and compares with finite differences.\"\"\"\n    \n    # --- Analytical derivatives (algo) ---\n    ubar, s_diag, v_t = np.linalg.svd(F_in)\n    v = v_t.T\n    s = np.diag(s_diag)\n    \n    det_check = np.linalg.det(ubar) * np.linalg.det(v)\n    if det_check < 0:\n        ubar[:, -1] *= -1\n\n    R_algo = ubar @ v.T\n    U_algo = v @ s @ v.T\n\n    # Compute M matrix\n    M = ubar.T @ dF_in @ v\n    \n    # Compute derivatives in the spectral basis\n    d_hat_U = np.zeros((3, 3))\n    omega_hat = np.zeros((3, 3))\n    \n    s_vec = np.diag(s)\n    \n    for i in range(3):\n        for j in range(3):\n            denom = s_vec[i] + s_vec[j]\n            if np.abs(denom) > 1e-30:\n                d_hat_U[i, j] = (s_vec[i] * M[i, j] + s_vec[j] * M[j, i]) / denom\n                omega_hat[i, j] = (M[i, j] - M[j, i]) / denom\n\n    # Transform back to spatial basis\n    dU_algo = v @ d_hat_U @ v.T\n    Omega_algo = v @ omega_hat @ v.T\n\n    # --- Compute stress and tangent action (algo) ---\n    U_inv = np.linalg.inv(U_algo)\n    J = np.linalg.det(U_algo)\n    \n    # First Piola-Kirchhoff stress P = R*S\n    S = mu * U_algo + (lamb * np.log(J) - mu) * U_inv\n    P_algo = R_algo @ S\n    \n    # Algorithmic tangent action A[dF] = dP\n    tr_Uinv_dU = np.trace(U_inv @ dU_algo)\n    dS = mu * dU_algo + lamb * tr_Uinv_dU * U_inv - (lamb * np.log(J) - mu) * (U_inv @ dU_algo @ U_inv)\n    \n    dP_algo = R_algo @ Omega_algo @ S + R_algo @ dS\n\n    return dU_algo, Omega_algo, P_algo, dP_algo\n\ndef check_with_fd(F_in, dF_in, lamb, mu, eps):\n    \"\"\"Computes derivatives using central finite differences.\"\"\"\n    \n    def get_kinematics_and_stress(F):\n        R, U, _, _, _ = get_polar_decomposition(F)\n        if np.linalg.det(U) < 1e-12: # Handle near singular case\n            P = np.zeros((3,3)) # Physically stress should be zero\n        else:\n            U_inv = np.linalg.inv(U)\n            J = np.linalg.det(U)\n            S = mu * U + (lamb * np.log(J) - mu) * U_inv\n            P = R @ S\n        return R, U, P\n\n    R_center, U_center, P_center = get_kinematics_and_stress(F_in)\n\n    F_p = F_in + eps * dF_in\n    F_m = F_in - eps * dF_in\n    \n    R_p, U_p, P_p = get_kinematics_and_stress(F_p)\n    R_m, U_m, P_m = get_kinematics_and_stress(F_m)\n\n    dU_fd = (U_p - U_m) / (2 * eps)\n    dP_fd = (P_p - P_m) / (2 * eps)\n    dR_fd = (R_p - R_m) / (2 * eps)\n    \n    # Omega_fd = skew(R_center.T @ dR_fd)\n    omega_mat = R_center.T @ dR_fd\n    Omega_fd = 0.5 * (omega_mat - omega_mat.T)\n    \n    return dU_fd, Omega_fd, dP_fd\n\n\ndef solve():\n    lamb = 20.0\n    mu = 10.0\n    eps = 1e-8\n    \n    # Case 1\n    F1 = np.array([[1.2, 0.3, 0.1], [0.2, 0.9, -0.4], [0.0, 0.5, 1.1]])\n    dF1 = np.array([[0.01, -0.02, 0.03], [-0.01, 0.02, 0.01], [0.0, -0.03, 0.04]])\n\n    # Case 2\n    theta = 0.7\n    axis_a = np.array([1, 1, 1]) / np.sqrt(3)\n    R_theta = rodrigues_formula(axis_a, theta)\n    diag_F2 = np.diag([2.5, 1e-6, 0.5])\n    F2 = R_theta @ diag_F2\n    dF2 = np.array([[0.02, 0.01, -0.01], [-0.03, 0.04, 0.02], [0.01, -0.02, 0.03]])\n\n    # Case 3\n    phi = 0.9\n    psi = -0.4\n    Rz_phi = np.array([[np.cos(phi), -np.sin(phi), 0], [np.sin(phi), np.cos(phi), 0], [0, 0, 1]])\n    Rx_psi = np.array([[1, 0, 0], [0, np.cos(psi), -np.sin(psi)], [0, np.sin(psi), np.cos(psi)]])\n    diag_F3 = np.diag([1.0, 1.0 + 1e-8, 0.7])\n    F3 = Rz_phi @ diag_F3 @ Rx_psi.T\n    dF3 = np.array([[-0.015, 0.005, 0.01], [0.025, -0.02, 0.005], [-0.005, 0.015, -0.01]])\n    \n    test_cases = [ (F1, dF1), (F2, dF2), (F3, dF3) ]\n    \n    results = []\n    \n    for F_case, dF_case in test_cases:\n        dU_algo, Omega_algo, _, dP_algo = solve_one_case(F_case, dF_case, lamb, mu)\n        dU_fd, Omega_fd, dP_fd = check_with_fd(F_case, dF_case, lamb, mu, eps)\n\n        norm_dU_fd = np.linalg.norm(dU_fd, 'fro')\n        err_U = np.linalg.norm(dU_algo - dU_fd, 'fro') / max(1e-30, norm_dU_fd)\n        results.append(err_U)\n        \n        norm_Omega_fd = np.linalg.norm(Omega_fd, 'fro')\n        err_Omega = np.linalg.norm(Omega_algo - Omega_fd, 'fro') / max(1e-30, norm_Omega_fd)\n        results.append(err_Omega)\n        \n        norm_dP_fd = np.linalg.norm(dP_fd, 'fro')\n        err_A = np.linalg.norm(dP_algo - dP_fd, 'fro') / max(1e-30, norm_dP_fd)\n        results.append(err_A)\n\n    print(f\"[{','.join([f'{r:.6e}' for r in results])}]\")\n\nsolve()\n\n```", "id": "3543722"}, {"introduction": "An alternative and powerful approach for isotropic hyperelasticity is the spectral formulation, where the material response is expressed directly in terms of principal stretches and stresses. This method can be computationally efficient but introduces its own numerical challenges, particularly when principal stretches become equal, leading to singularities in the standard tangent formulation [@problem_id:3543741]. This advanced exercise explores the derivation of the spectral tangent and demonstrates how to analytically resolve such singularities using a limiting procedure, ensuring a robust implementation even in degenerate states.", "problem": "Consider an isotropic, compressible neo-Hookean hyperelastic solid with strain-energy density per unit reference volume\n$$\nW(\\mathbf{C})=\\frac{\\mu}{2}\\left(I_{1}-3\\right)-\\mu \\ln J+\\frac{\\kappa}{2}\\left(\\ln J\\right)^{2},\n$$\nwhere $\\mathbf{C}=\\mathbf{F}^{\\mathsf{T}}\\mathbf{F}$ is the right Cauchy-Green tensor, $\\mathbf{F}$ is the deformation gradient, $I_{1}=\\operatorname{tr}\\mathbf{C}$, $J=\\det\\mathbf{F}$, $\\mu>0$ is the shear modulus, and $\\kappa>0$ is the bulk modulus. Let $\\lambda_{i}$ be the principal stretches, and define the principal logarithmic strains $\\varepsilon_{i}=\\ln\\lambda_{i}$. The Kirchhoff stress is $\\boldsymbol{\\tau}=J\\,\\boldsymbol{\\sigma}$, with principal values $\\tau_{i}$ aligned with the principal stretches.\n\nIn a Newton method for finite elements using a spectral formulation with principal logarithmic strains, the algorithmic consistent tangent in the principal basis is the linear map $d\\varepsilon_{j}\\mapsto d\\tau_{i}$ characterized by coefficients $A_{ij}$ such that $d\\tau_{i}=\\sum_{j}A_{ij}\\,d\\varepsilon_{j}$, accounting for both eigenvalue and eigenvector variations.\n\nFor a nearly equal-biaxial state $\\lambda_{1}\\approx\\lambda_{2}\\neq\\lambda_{3}$, derive the spectral consistent tangent coefficients $A_{ij}$ in terms of $\\mu$, $\\kappa$, and $\\lambda_{i}$ starting from fundamental definitions of hyperelastic response and spectral calculus of tensor functions. Then, by taking the appropriate limit to remove any potential numerical singularity due to the near-multiplicity $\\lambda_{1}\\to\\lambda_{2}$, compute the closed-form expression of the limiting off-diagonal coefficient\n$$\nA_{12}^{\\mathrm{lim}}=\\lim_{\\lambda_{2}\\to\\lambda_{1}}A_{12}\n$$\nin terms of $\\mu$ and the common value $\\lambda$ of the repeated stretch. Briefly explain why this limiting procedure removes the numerical singularity.\n\nProvide as your final answer the simplified symbolic expression for $A_{12}^{\\mathrm{lim}}$. You do not need to report units; provide only the expression.", "solution": "The problem requires the derivation of the consistent tangent coefficients for an isotropic, compressible neo-Hookean solid, and specifically, the computation of a limiting off-diagonal coefficient in a state of repeated principal stretches. The process involves several steps, beginning with the fundamental constitutive relations and culminating in a limit analysis to handle the singularity associated with repeated eigenvalues.\n\nFirst, we express the strain-energy density function $W$ in terms of the principal stretches $\\lambda_i$. The invariants $I_1$ and $J$ are given by:\n$$\nI_1 = \\operatorname{tr}(\\mathbf{C}) = \\lambda_1^2 + \\lambda_2^2 + \\lambda_3^2\n$$\n$$\nJ = \\det(\\mathbf{F}) = \\lambda_1 \\lambda_2 \\lambda_3\n$$\nSubstituting these into the given expression for $W$ yields:\n$$\nW(\\lambda_1, \\lambda_2, \\lambda_3) = \\frac{\\mu}{2}\\left(\\lambda_1^2 + \\lambda_2^2 + \\lambda_3^2 - 3\\right) - \\mu \\ln(\\lambda_1 \\lambda_2 \\lambda_3) + \\frac{\\kappa}{2}\\left(\\ln(\\lambda_1 \\lambda_2 \\lambda_3)\\right)^2\n$$\n\nFor an isotropic hyperelastic material, the principal values of the Kirchhoff stress tensor $\\boldsymbol{\\tau}$ are coaxial with the principal stretches and are given by the relation $\\tau_i = \\lambda_i \\frac{\\partial W}{\\partial \\lambda_i}$. We compute the partial derivative of $W$ with respect to $\\lambda_i$:\n$$\n\\frac{\\partial W}{\\partial \\lambda_i} = \\frac{\\mu}{2}(2\\lambda_i) - \\mu \\frac{1}{J} \\frac{\\partial J}{\\partial \\lambda_i} + \\frac{\\kappa}{2} (2 \\ln J) \\frac{1}{J} \\frac{\\partial J}{\\partial \\lambda_i}\n$$\nUsing $\\frac{\\partial J}{\\partial \\lambda_i} = \\frac{J}{\\lambda_i}$, we get:\n$$\n\\frac{\\partial W}{\\partial \\lambda_i} = \\mu\\lambda_i - \\mu\\frac{1}{\\lambda_i} + \\kappa \\frac{\\ln J}{\\lambda_i}\n$$\nTherefore, the principal Kirchhoff stresses are:\n$$\n\\tau_i = \\lambda_i \\left( \\mu\\lambda_i - \\frac{\\mu}{\\lambda_i} + \\kappa \\frac{\\ln J}{\\lambda_i} \\right) = \\mu(\\lambda_i^2 - 1) + \\kappa \\ln J.\n$$\n\nThe problem defines the algorithmic consistent tangent coefficients $A_{ij}$ as the components of the linear map from increments of principal logarithmic strains $d\\varepsilon_j = d(\\ln\\lambda_j)$ to increments of principal Kirchhoff stresses $d\\tau_i$. The formulation must account for variations of both eigenvalues and eigenvectors of the strain/stress tensors. In the context of spectral decomposition and consistent linearization for finite element analysis, for the case of distinct principal stretches ($\\lambda_i \\neq \\lambda_j$), the off-diagonal coefficients of this tangent matrix are given by:\n$$\nA_{ij} = \\frac{\\tau_i - \\tau_j}{\\varepsilon_i - \\varepsilon_j} \\quad \\text{for } i \\neq j\n$$\nThis expression becomes singular when $\\lambda_i \\to \\lambda_j$ (and thus $\\varepsilon_i \\to \\varepsilon_j$), as it approaches the indeterminate form $0/0$. The problem asks for the resolution of this singularity through a limiting procedure.\n\nLet us focus on the coefficient $A_{12}$ for a nearly equal-biaxial state where $\\lambda_1 \\approx \\lambda_2$. For $\\lambda_1 \\neq \\lambda_2$, the coefficient is:\n$$\nA_{12} = \\frac{\\tau_1 - \\tau_2}{\\varepsilon_1 - \\varepsilon_2}\n$$\nWe compute the numerator, $\\tau_1 - \\tau_2$:\n$$\n\\tau_1 - \\tau_2 = \\left[ \\mu(\\lambda_1^2 - 1) + \\kappa \\ln J \\right] - \\left[ \\mu(\\lambda_2^2 - 1) + \\kappa \\ln J \\right] = \\mu(\\lambda_1^2 - \\lambda_2^2)\n$$\nThe denominator is $\\varepsilon_1 - \\varepsilon_2 = \\ln\\lambda_1 - \\ln\\lambda_2 = \\ln(\\lambda_1/\\lambda_2)$. Thus, the coefficient is:\n$$\nA_{12} = \\frac{\\mu(\\lambda_1^2 - \\lambda_2^2)}{\\ln\\lambda_1 - \\ln\\lambda_2}\n$$\n\nTo find the coefficient for the case of repeated eigenvalues $\\lambda_1 = \\lambda_2$, we compute the limit $A_{12}^{\\mathrm{lim}}=\\lim_{\\lambda_{2}\\to\\lambda_{1}}A_{12}$.\n$$\nA_{12}^{\\mathrm{lim}} = \\lim_{\\lambda_2 \\to \\lambda_1} \\frac{\\mu(\\lambda_1^2 - \\lambda_2^2)}{\\ln\\lambda_1 - \\ln\\lambda_2}\n$$\nThis is an indeterminate form of the type $0/0$. We apply L'Hôpital's rule, treating $\\lambda_1$ as a constant and differentiating the numerator and the denominator with respect to the variable $\\lambda_2$:\n-   Let $f(\\lambda_2) = \\mu(\\lambda_1^2 - \\lambda_2^2)$. The derivative is $f'(\\lambda_2) = -2\\mu\\lambda_2$.\n-   Let $g(\\lambda_2) = \\ln\\lambda_1 - \\ln\\lambda_2$. The derivative is $g'(\\lambda_2) = -\\frac{1}{\\lambda_2}$.\n\nThe limit is then the ratio of these derivatives evaluated at $\\lambda_2 = \\lambda_1$:\n$$\nA_{12}^{\\mathrm{lim}} = \\lim_{\\lambda_2 \\to \\lambda_1} \\frac{f'(\\lambda_2)}{g'(\\lambda_2)} = \\lim_{\\lambda_2 \\to \\lambda_1} \\frac{-2\\mu\\lambda_2}{-1/\\lambda_2} = \\lim_{\\lambda_2 \\to \\lambda_1} 2\\mu\\lambda_2^2\n$$\nEvaluating the limit, we let $\\lambda$ be the common value $\\lambda = \\lambda_1 = \\lambda_2$:\n$$\nA_{12}^{\\mathrm{lim}} = 2\\mu\\lambda^2\n$$\n\nThis limiting procedure is necessary because the formula for $A_{12}$ is ill-defined when principal stretches are equal. Physically, when two principal stretches are equal, the corresponding principal directions (eigenvectors) are not unique but span a plane. A small perturbation in strain can cause a large, arbitrary rotation of the numerically computed eigenvectors within this plane. The expression for the tangent coefficients for distinct eigenvalues depends on the well-defined principal directions. Its singularity reflects this physical indeterminacy. By taking the analytical limit, we obtain a well-defined, stable value for the tangent coefficient that correctly describes the material's response to perturbations from a state with repeated eigenvalues, thus removing the numerical singularity that would otherwise occur in a computational implementation.", "answer": "$$\\boxed{2\\mu\\lambda^2}$$", "id": "3543741"}]}