{"hands_on_practices": [{"introduction": "In finite element analysis, distributed loads like pressure or traction must be converted into discrete forces acting at the nodes. This exercise demonstrates how to derive these \"consistent\" nodal forces from first principles. By applying the principle of virtual work, you will see how the element's own shape functions are used to ensure that the work done by the discrete nodal forces is equivalent to the work done by the continuous traction, a key step for accurate modeling. [@problem_id:3583980]", "problem": "Consider a two-dimensional isoparametric nine-node Lagrangian quadrilateral element (often denoted as a Q9 element) used in the Finite Element Method (FEM) for computational solid mechanics. Let the natural coordinates be denoted by $\\xi$ and $\\eta$, with the usual square reference domain $[-1,1] \\times [-1,1]$. Assume the element is mapped to a straight-sided rectangle in physical space such that the right edge corresponds to $\\xi=1$ and has physical length $L$, with the three edge nodes located at $\\eta=-1$, $\\eta=0$, and $\\eta=1$. The element has constant thickness $b$.\n\nA surface traction is applied along the right edge $\\xi=1$, acting purely in the $x$-direction, and is given in terms of the natural edge coordinate $\\eta$ by the quadratic function\n$$\nt_{x}(\\eta) = \\alpha + \\beta \\,\\eta + \\gamma \\,\\eta^{2},\n$$\nwhere $\\alpha$, $\\beta$, and $\\gamma$ are constants. Using the fundamental boundary term from the principle of virtual work, derive the consistent edge nodal forces associated with the three nodes on this edge in the $x$-direction, expressed in terms of $\\alpha$, $\\beta$, $\\gamma$, $b$, and $L$ only. Start from first principles and construct the necessary interpolation along the edge directly from the definition of one-dimensional quadratic Lagrange shape functions associated with the points $\\eta=-1$, $\\eta=0$, and $\\eta=1$; do not invoke any pre-stated finite element formulas.\n\nThen, verify that these integrals are evaluated exactly by a one-dimensional Gauss-Legendre quadrature rule with the minimum number of points required for exactness. You must justify the chosen number of points based on the polynomial degree of the integrand restricted to the edge and the exactness property of Gauss-Legendre rules.\n\nExpress your final answer as the row of the three $x$-direction nodal forces corresponding to $\\eta=-1$, $\\eta=0$, and $\\eta=1$, in a closed-form analytic expression. No numerical substitution is required, and no units should be included in the final expression in the answer box.", "solution": "The problem is deemed valid as it is scientifically grounded, well-posed, objective, and contains all necessary information for a unique solution.\n\nThe derivation of the consistent nodal forces begins with the principle of virtual work. The external virtual work, $\\delta W_{\\text{ext}}$, done by a surface traction vector $\\mathbf{t}$ over a surface $S_t$ is given by the integral of the dot product of the traction and the virtual displacement vector $\\delta\\mathbf{u}$:\n$$\n\\delta W_{\\text{ext}} = \\int_{S_t} \\delta\\mathbf{u}^T \\mathbf{t} \\, dS\n$$\nIn this two-dimensional problem, the traction is applied to the edge at $\\xi=1$ and acts solely in the $x$-direction, $t_x(\\eta) = \\alpha + \\beta\\eta + \\gamma\\eta^2$. The virtual displacement in the $x$-direction is $\\delta u_x$. The surface element is $dS = b \\, ds$, where $b$ is the constant thickness and $ds$ is the differential arc length along the edge. The virtual work expression simplifies to:\n$$\n\\delta W_{\\text{ext}} = \\int_{S_{\\text{edge}}} \\delta u_x(\\eta) t_x(\\eta) b \\, ds\n$$\nWithin the finite element framework, the displacement field along the edge is interpolated from the nodal displacements using shape functions. The edge in question has three nodes, corresponding to $\\eta = -1$, $\\eta = 0$, and $\\eta = 1$. Let their $x$-direction nodal displacements be $d_{x1}$, $d_{x2}$, and $d_{x3}$, and the corresponding one-dimensional shape functions be $N_1(\\eta)$, $N_2(\\eta)$, and $N_3(\\eta)$. The displacement $u_x$ and virtual displacement $\\delta u_x$ along the edge are:\n$$\nu_x(\\eta) = N_1(\\eta)d_{x1} + N_2(\\eta)d_{x2} + N_3(\\eta)d_{x3} = \\sum_{i=1}^3 N_i(\\eta) d_{xi}\n$$\n$$\n\\delta u_x(\\eta) = N_1(\\eta)\\delta d_{x1} + N_2(\\eta)\\delta d_{x2} + N_3(\\eta)\\delta d_{x3} = \\sum_{i=1}^3 N_i(\\eta) \\delta d_{xi}\n$$\nSubstituting $\\delta u_x$ into the virtual work expression:\n$$\n\\delta W_{\\text{ext}} = \\int_{S_{\\text{edge}}} \\left( \\sum_{i=1}^3 N_i(\\eta) \\delta d_{xi} \\right) t_x(\\eta) b \\, ds\n$$\nSince the virtual nodal displacements $\\delta d_{xi}$ are arbitrary and constant with respect to the integration, we can write:\n$$\n\\delta W_{\\text\next}} = \\sum_{i=1}^3 \\delta d_{xi} \\left( \\int_{S_{\\text{edge}}} N_i(\\eta) t_x(\\eta) b \\, ds \\right)\n$$\nThe external virtual work is also defined as the sum of the products of the consistent nodal forces $F_{xi}$ and the corresponding virtual nodal displacements $\\delta d_{xi}$:\n$$\n\\delta W_{\\text{ext}} = \\sum_{i=1}^3 F_{xi} \\delta d_{xi}\n$$\nBy comparing the two expressions for $\\delta W_{\\text{ext}}$, the consistent nodal force for node $i$ is:\n$$\nF_{xi} = \\int_{S_{\\text{edge}}} N_i(\\eta) t_x(\\eta) b \\, ds\n$$\nThe problem states the physical edge is a straight line of length $L$, corresponding to the natural coordinate $\\eta$ varying from $-1$ to $1$. The relationship between the physical differential length $ds$ and the natural coordinate differential $d\\eta$ is found via the Jacobian of the one-dimensional mapping, $J_s = ds/d\\eta$. For a linear mapping from $[-1, 1]$ to $[0, L]$, we have $s(\\eta) = \\frac{L}{2}(\\eta+1)$, so $J_s = ds/d\\eta = L/2$. The integral becomes:\n$$\nF_{xi} = \\int_{-1}^{1} N_i(\\eta) t_x(\\eta) b \\left( \\frac{L}{2} \\right) d\\eta = \\frac{bL}{2} \\int_{-1}^{1} N_i(\\eta) t_x(\\eta) \\, d\\eta\n$$\nNext, we construct the one-dimensional, quadratic Lagrange shape functions for nodes at $\\eta_1=-1$, $\\eta_2=0$, and $\\eta_3=1$.\nFor $N_1(\\eta)$ (node at $\\eta=-1$), it must be zero at $\\eta=0$ and $\\eta=1$. Thus, $N_1(\\eta) = C_1(\\eta-0)(\\eta-1)$. Applying the condition $N_1(-1)=1$ gives $C_1(-1)(-2)=1 \\implies C_1=1/2$.\n$$ N_1(\\eta) = \\frac{1}{2}\\eta(\\eta-1) = \\frac{1}{2}(\\eta^2-\\eta) $$\nFor $N_2(\\eta)$ (node at $\\eta=0$), it must be zero at $\\eta=-1$ and $\\eta=1$. Thus, $N_2(\\eta) = C_2(\\eta+1)(\\eta-1)$. Applying $N_2(0)=1$ gives $C_2(1)(-1)=1 \\implies C_2=-1$.\n$$ N_2(\\eta) = -(\\eta^2-1) = 1-\\eta^2 $$\nFor $N_3(\\eta)$ (node at $\\eta=1$), it must be zero at $\\eta=-1$ and $\\eta=0$. Thus, $N_3(\\eta) = C_3(\\eta+1)(\\eta-0)$. Applying $N_3(1)=1$ gives $C_3(2)(1)=1 \\implies C_3=1/2$.\n$$ N_3(\\eta) = \\frac{1}{2}\\eta(\\eta+1) = \\frac{1}{2}(\\eta^2+\\eta) $$\nNow we compute the integral for each nodal force.\nFor $F_{x1}$:\n$$ F_{x1} = \\frac{bL}{2} \\int_{-1}^{1} \\frac{1}{2}(\\eta^2-\\eta)(\\alpha + \\beta\\eta + \\gamma\\eta^2) \\, d\\eta = \\frac{bL}{4} \\int_{-1}^{1} (\\gamma\\eta^4 + (\\beta-\\gamma)\\eta^3 + (\\alpha-\\beta)\\eta^2 - \\alpha\\eta) \\, d\\eta $$\nOver the symmetric interval $[-1, 1]$, integrals of odd-powered terms ($\\eta^3$, $\\eta$) are zero.\n$$ F_{x1} = \\frac{bL}{4} \\int_{-1}^{1} (\\gamma\\eta^4 + (\\alpha-\\beta)\\eta^2) \\, d\\eta = \\frac{bL}{4} \\left[ \\gamma\\frac{\\eta^5}{5} + (\\alpha-\\beta)\\frac{\\eta^3}{3} \\right]_{-1}^{1} = \\frac{bL}{4} \\left( 2\\frac{\\gamma}{5} + 2\\frac{\\alpha-\\beta}{3} \\right) = \\frac{bL}{2} \\left( \\frac{3\\gamma + 5\\alpha - 5\\beta}{15} \\right) = \\frac{bL}{30}(5\\alpha - 5\\beta + 3\\gamma) $$\nFor $F_{x2}$:\n$$ F_{x2} = \\frac{bL}{2} \\int_{-1}^{1} (1-\\eta^2)(\\alpha + \\beta\\eta + \\gamma\\eta^2) \\, d\\eta = \\frac{bL}{2} \\int_{-1}^{1} (-\\gamma\\eta^4 - \\beta\\eta^3 + (\\gamma-\\alpha)\\eta^2 + \\beta\\eta + \\alpha) \\, d\\eta $$\nAgain, odd-powered terms integrate to zero.\n$$ F_{x2} = \\frac{bL}{2} \\int_{-1}^{1} (-\\gamma\\eta^4 + (\\gamma-\\alpha)\\eta^2 + \\alpha) \\, d\\eta = \\frac{bL}{2} \\left[ -\\gamma\\frac{\\eta^5}{5} + (\\gamma-\\alpha)\\frac{\\eta^3}{3} + \\alpha\\eta \\right]_{-1}^{1} = \\frac{bL}{2} \\left( -2\\frac{\\gamma}{5} + 2\\frac{\\gamma-\\alpha}{3} + 2\\alpha \\right) = bL \\left( -\\frac{\\gamma}{5} + \\frac{\\gamma-\\alpha}{3} + \\alpha \\right) $$\n$$ F_{x2} = bL \\left( \\frac{-3\\gamma + 5\\gamma - 5\\alpha + 15\\alpha}{15} \\right) = bL \\left( \\frac{10\\alpha + 2\\gamma}{15} \\right) = \\frac{bL}{30}(20\\alpha + 4\\gamma) $$\nFor $F_{x3}$:\n$$ F_{x3} = \\frac{bL}{2} \\int_{-1}^{1} \\frac{1}{2}(\\eta^2+\\eta)(\\alpha + \\beta\\eta + \\gamma\\eta^2) \\, d\\eta = \\frac{bL}{4} \\int_{-1}^{1} (\\gamma\\eta^4 + (\\beta+\\gamma)\\eta^3 + (\\alpha+\\beta)\\eta^2 + \\alpha\\eta) \\, d\\eta $$\nOdd-powered terms integrate to zero.\n$$ F_{x3} = \\frac{bL}{4} \\int_{-1}^{1} (\\gamma\\eta^4 + (\\alpha+\\beta)\\eta^2) \\, d\\eta = \\frac{bL}{4} \\left[ \\gamma\\frac{\\eta^5}{5} + (\\alpha+\\beta)\\frac{\\eta^3}{3} \\right]_{-1}^{1} = \\frac{bL}{4} \\left( 2\\frac{\\gamma}{5} + 2\\frac{\\alpha+\\beta}{3} \\right) = \\frac{bL}{2} \\left( \\frac{3\\gamma + 5\\alpha + 5\\beta}{15} \\right) = \\frac{bL}{30}(5\\alpha + 5\\beta + 3\\gamma) $$\nThe three nodal forces are:\n$F_{x1} = \\frac{bL}{30}(5\\alpha - 5\\beta + 3\\gamma)$\n$F_{x2} = \\frac{bL}{30}(20\\alpha + 4\\gamma)$\n$F_{x3} = \\frac{bL}{30}(5\\alpha + 5\\beta + 3\\gamma)$\n\nNow we must verify that these integrals are evaluated exactly by a Gauss-Legendre quadrature rule with the minimum number of points. The general form of the integral is $\\int_{-1}^1 f(\\eta) d\\eta$, where the integrand is $f(\\eta) = N_i(\\eta)t_x(\\eta)$.\nThe shape functions $N_i(\\eta)$ are polynomials of degree $2$. The traction function $t_x(\\eta)$ is also a polynomial of degree $2$. The product of these two, $f(\\eta) = N_i(\\eta)t_x(\\eta)$, is therefore a polynomial of degree $p = 2+2=4$.\nA Gauss-Legendre quadrature rule with $n$ points integrates a polynomial of degree up to $2n-1$ exactly. To ensure exact integration of our degree-$4$ polynomial, we must satisfy the condition:\n$2n - 1 \\ge 4$\n$2n \\ge 5$\n$n \\ge 2.5$\nSince the number of quadrature points $n$ must be an integer, the minimum number of points required for exactness is $n=3$. Therefore, a $3$-point Gauss-Legendre quadrature rule is the minimum rule that will evaluate the consistent nodal force integrals exactly. This completes the verification.\n\nThe final answer is the row of the three nodal forces. We can factor out the common term $\\frac{bL}{30}$.\nThe three forces are $\\frac{bL}{30}(5\\alpha - 5\\beta + 3\\gamma)$, $\\frac{bL}{30}(20\\alpha + 4\\gamma)$, and $\\frac{bL}{30}(5\\alpha + 5\\beta + 3\\gamma)$.", "answer": "$$\n\\boxed{\\frac{bL}{30} \\begin{pmatrix} 5\\alpha - 5\\beta + 3\\gamma & 20\\alpha + 4\\gamma & 5\\alpha + 5\\beta + 3\\gamma \\end{pmatrix}}\n$$", "id": "3583980"}, {"introduction": "Before an element can be used in a simulation, we must verify its fundamental correctness. The patch test is a critical benchmark that checks if an element can exactly represent a constant strain state, which is a necessary condition for convergence. This hands-on coding exercise will guide you through the implementation of the Q9 element's shape functions and isoparametric mapping, and then test its integrity against distorted geometries to identify conditions where the mapping becomes invalid. [@problem_id:3583985]", "problem": "Consider the two-dimensional isoparametric nine-node Lagrangian quadrilateral element defined over the reference square $[-1,1] \\times [-1,1]$ with local coordinates $(\\xi,\\eta)$. The nine nodes are located at $(\\xi,\\eta) \\in \\{(-1,-1),(0,-1),(1,-1),(-1,0),(0,0),(1,0),(-1,1),(0,1),(1,1)\\}$ and indexed in the following order: $k=0 \\rightarrow (-1,-1)$, $k=1 \\rightarrow (0,-1)$, $k=2 \\rightarrow (1,-1)$, $k=3 \\rightarrow (-1,0)$, $k=4 \\rightarrow (0,0)$, $k=5 \\rightarrow (1,0)$, $k=6 \\rightarrow (-1,1)$, $k=7 \\rightarrow (0,1)$, $k=8 \\rightarrow (1,1)$. Let the physical coordinates of node $k$ be $(X_k,Y_k)$.\n\nYou must construct the quadratic one-dimensional Lagrange polynomials $L_i(\\xi)$ and $L_j(\\eta)$ for $i,j \\in \\{-1,0,1\\}$, and then form the nine-node Lagrangian shape functions\n$$\nN_{ij}(\\xi,\\eta) = L_i(\\xi)\\,L_j(\\eta), \\quad i,j \\in \\{-1,0,1\\}.\n$$\nUse these to implement the standard isoparametric mapping\n$$\nx(\\xi,\\eta) = \\sum_{a=0}^{8} N_a(\\xi,\\eta)\\,X_a, \\quad y(\\xi,\\eta) = \\sum_{a=0}^{8} N_a(\\xi,\\eta)\\,Y_a,\n$$\nwhere $N_a(\\xi,\\eta)$ denotes the shape function associated with node $a$ under the stated ordering. Compute the Jacobian matrix\n$$\n\\mathbf{J}(\\xi,\\eta) = \n\\begin{bmatrix}\n\\frac{\\partial x}{\\partial \\xi} & \\frac{\\partial x}{\\partial \\eta} \\\\\n\\frac{\\partial y}{\\partial \\xi} & \\frac{\\partial y}{\\partial \\eta}\n\\end{bmatrix},\n$$\nand its determinant $\\det \\mathbf{J}(\\xi,\\eta)$ at the $3 \\times 3$ Gauss–Legendre quadrature points with abscissae $\\{-\\sqrt{3/5},\\,0,\\,\\sqrt{3/5}\\}$ in each coordinate.\n\nFor the patch test, consider the scalar displacement field (sufficient for verifying constant strain reproduction in the Finite Element Method (FEM))\n$$\nu(x,y) = a + b\\,x + c\\,y,\n$$\nwith given constants $a$, $b$, and $c$. Define nodal values $u_a = u(X_a,Y_a)$. Using the constructed shape functions and the chain rule, compute the gradient $\\nabla u$ at the $3 \\times 3$ Gauss points and compare against the exact constant gradient $\\nabla u_{\\text{exact}} = [\\,b,\\,c\\,]^T$. A test passes if and only if two conditions hold simultaneously: \n- $\\det \\mathbf{J}(\\xi,\\eta) > 0$ at all Gauss points, and \n- the maximum absolute component-wise error between the computed and exact gradients over all Gauss points is less than a tolerance of $10^{-10}$.\n\nYou must also identify the failure condition when $\\det \\mathbf{J}(\\xi,\\eta) \\le 0$ at any Gauss point, which invalidates the isoparametric map and causes the patch test to fail.\n\nImplement a complete, runnable program that:\n- Constructs $L_i(\\xi)$ and $L_j(\\eta)$ for $i,j \\in \\{-1,0,1\\}$ from first principles of Lagrange interpolation,\n- Builds $N_{ij}(\\xi,\\eta)$ and their derivatives with respect to $\\xi$ and $\\eta$,\n- Computes $\\mathbf{J}(\\xi,\\eta)$, its determinant, and the gradient $\\nabla u$ via the inverse-transpose of $\\mathbf{J}$,\n- Evaluates the patch test pass/fail as described.\n\nNo physical units or angle units are involved in this problem.\n\nTest Suite:\nUse the following four test cases, all defined for a single nine-node element. In each case, the node ordering is $k=0,\\dots,8$ corresponding to the $(\\xi,\\eta)$ locations listed at the beginning of this problem.\n\n- Test case $1$ (random mild distortion): Start from the unit square with corners $(0,0)$, $(1,0)$, $(0,1)$, $(1,1)$ assigned to $k \\in \\{0,2,6,8\\}$ respectively, midside nodes at edge midpoints, and center at $(0.5,0.5)$. Randomly perturb only the midside and center nodes by adding independent uniform perturbations in $[-0.1,0.1]$ in both $x$ and $y$ directions using a pseudorandom generator with seed $42$. Corners remain fixed.\n- Test case $2$ (bow-tie self-intersection): Assign corners to produce a self-intersecting quadrilateral: $k=0 \\rightarrow (0,0)$, $k=2 \\rightarrow (1,0)$, $k=6 \\rightarrow (1,1)$, $k=8 \\rightarrow (0,1)$. Set midside nodes to edge midpoints of the corresponding (possibly crossing) edges: $k=1 \\rightarrow (0.5,0)$, $k=3 \\rightarrow (0.5,0.5)$, $k=5 \\rightarrow (0.5,0.5)$, $k=7 \\rightarrow (0.5,1)$, and the center $k=4 \\rightarrow (0.5,0.5)$.\n- Test case $3$ (random strong distortion but attempting non-inversion): Same base unit square as test case $1$, but perturb midside and center nodes by uniform perturbations in $[-0.45,0.45]$ using seed $7$. Corners remain fixed.\n- Test case $4$ (collapsed bottom edge): Set $k=0 \\rightarrow (0,0)$, $k=2 \\rightarrow (0,0)$, bottom midside $k=1 \\rightarrow (0,0)$, left midside $k=3 \\rightarrow (0,0.5)$, right midside $k=5 \\rightarrow (0.5,0.5)$, top midside $k=7 \\rightarrow (0.5,1)$, top-left $k=6 \\rightarrow (0,1)$, top-right $k=8 \\rightarrow (1,1)$, center $k=4 \\rightarrow (0.25,0.5)$.\n\nUse the displacement parameters $a=0.3$, $b=-1.2$, $c=2.5$ for all test cases.\n\nAnswer Specification:\nFor each test case, compute:\n- a boolean indicating whether the patch test passes under the stated criteria, and\n- the minimum value of $\\det \\mathbf{J}(\\xi,\\eta)$ over the $3 \\times 3$ Gauss points.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case result is a list of two elements $[\\text{pass}, \\min\\det]$ in the same order as the test suite, for example, $\\big[\\, [\\text{True},\\,0.123],\\,[\\text{False},\\,-0.001],\\,[\\text{True},\\,0.05],\\,[\\text{False},\\,-0.02] \\,\\big]$.", "solution": "The user has provided a computational solid mechanics problem concerning the validation of a nine-node Lagrangian quadrilateral element using a patch test.\n\n### Step 1: Extract Givens\n- **Element Type**: Two-dimensional isoparametric nine-node Lagrangian quadrilateral element.\n- **Reference Domain**: A square defined by local coordinates $(\\xi, \\eta)$ where $\\xi, \\eta \\in [-1, 1]$.\n- **Node Locations (Reference)**: The nine nodes are at all combinations of $\\xi, \\eta \\in \\{-1, 0, 1\\}$.\n- **Node Ordering**: A specific mapping from index $k=0, \\dots, 8$ to reference coordinates $(\\xi_k, \\eta_k)$: $k=0 \\rightarrow (-1,-1)$, $k=1 \\rightarrow (0,-1)$, $k=2 \\rightarrow (1,-1)$, $k=3 \\rightarrow (-1,0)$, $k=4 \\rightarrow (0,0)$, $k=5 \\rightarrow (1,0)$, $k=6 \\rightarrow (-1,1)$, $k=7 \\rightarrow (0,1)$, $k=8 \\rightarrow (1,1)$.\n- **Shape Functions**: Defined by the tensor product of one-dimensional quadratic Lagrange polynomials: $N_{ij}(\\xi,\\eta) = L_i(\\xi)L_j(\\eta)$ for $i,j \\in \\{-1,0,1\\}$.\n- **Isoparametric Mapping**: The physical coordinates $(x,y)$ are mapped from the reference coordinates $(\\xi,\\eta)$ using the shape functions $N_a$ and nodal physical coordinates $(X_a, Y_a)$: $x(\\xi,\\eta) = \\sum_{a=0}^{8} N_a(\\xi,\\eta)X_a$ and $y(\\xi,\\eta) = \\sum_{a=0}^{8} N_a(\\xi,\\eta)Y_a$.\n- **Jacobian Matrix**: $\\mathbf{J}(\\xi,\\eta) = \\begin{bmatrix} \\partial x/\\partial \\xi & \\partial x/\\partial \\eta \\\\ \\partial y/\\partial \\xi & \\partial y/\\partial \\eta \\end{bmatrix}$. A quantity to compute is its determinant, $\\det \\mathbf{J}$.\n- **Evaluation Points**: The $3 \\times 3$ Gauss-Legendre quadrature points, with abscissae $\\{-\\sqrt{3/5}, 0, \\sqrt{3/5}\\}$ in each coordinate direction $(\\xi, \\eta)$.\n- **Patch Test Field**: A scalar displacement field $u(x,y) = a + b x + c y$ with given constants $a, b, c$.\n- **Nodal Values**: $u_a = u(X_a, Y_a)$.\n- **Gradient Calculation**: The gradient $\\nabla u = [\\partial u/\\partial x, \\partial u/\\partial y]^T$ is to be computed at the Gauss points using the shape functions and the chain rule.\n- **Patch Test Criteria**: A test passes if and only if both conditions are met:\n    1.  $\\det \\mathbf{J}(\\xi,\\eta) > 0$ at all $9$ Gauss points.\n    2.  The maximum absolute component-wise error between the computed gradient $\\nabla u$ and the exact gradient $[\\,b,\\,c\\,]^T$ over all Gauss points is less than a tolerance of $10^{-10}$.\n- **Displacement Parameters**: For all test cases, $a=0.3$, $b=-1.2$, $c=2.5$.\n- **Test Cases**: Four test cases are defined by the nodal physical coordinates $(X_k, Y_k)$ for $k=0, \\dots, 8$:\n    1.  **Random Mild Distortion**: Unit square with corners fixed, midside and center nodes perturbed by uniform random values in $[-0.1, 0.1]$ (seed $42$).\n    2.  **Bow-tie Self-intersection**: Corners are $k=0 \\to (0,0)$, $k=2 \\to (1,0)$, $k=6 \\to (1,1)$, $k=8 \\to (0,1)$. Midside and center nodes are placed accordingly, leading to some coincident nodes.\n    3.  **Random Strong Distortion**: Same as case 1 but with perturbations in $[-0.45, 0.45]$ (seed $7$).\n    4.  **Collapsed Bottom Edge**: Nodes $k=0, 1, 2$ are all mapped to the physical point $(0,0)$.\n- **Required Output**: For each test case, a boolean for patch test pass/fail and the minimum value of $\\det \\mathbf{J}$ over the Gauss points. The final output must be a single line containing a list of these results.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is subjected to validation against the specified criteria.\n- **Scientifically Grounded**: The problem is a standard verification procedure in the Finite Element Method (FEM). The concepts of isoparametric mapping, Lagrangian shape functions, the Jacobian of transformation, Gauss quadrature, and the patch test are all fundamental, well-established principles in computational solid mechanics.\n- **Well-Posed**: The problem is algorithmically specified. The inputs (nodal coordinates, displacement field parameters) are clearly defined for each case. The computational procedure is deterministic and leads to a unique solution for each test case.\n- **Objective**: The problem is stated in precise, quantitative, and unbiased mathematical language. All criteria are objective (e.g., $\\det \\mathbf{J} > 0$, error $< 10^{-10}$).\n- **Completeness and Consistency**: All necessary data and definitions are provided. The node ordering, shape function construction, physical coordinates, and evaluation criteria are all specified without ambiguity or contradiction.\n- **Feasibility and Realism**: The described computations are standard in FEM software and are physically and mathematically feasible. The test cases, including distorted and degenerate geometries, are designed to test the robustness of the element formulation, which is a common practice.\n- **Other Flaws**: The problem is not trivial, as it requires a non-negligible implementation of FEM concepts. It is not tautological, metaphorical, or outside the realm of scientific verifiability.\n\n### Step 3: Verdict and Action\nThe problem statement is **valid**. It is self-contained, scientifically sound, and well-posed. A complete solution will be provided.\n\n### Principle-Based Design of the Solution\nThe solution is developed by methodically implementing the principles of isoparametric finite element formulation.\n\n**1. One-Dimensional Lagrange Polynomials**\nThe basis for the nine-node element's shape functions are the one-dimensional quadratic Lagrange polynomials defined over the interval $[-1, 1]$ with nodes at $\\zeta \\in \\{-1, 0, 1\\}$. For an index $i \\in \\{-1, 0, 1\\}$, the polynomial $L_i(\\zeta)$ has the property that $L_i(\\zeta_j) = \\delta_{ij}$ (the Kronecker delta) where $\\zeta_j \\in \\{-1, 0, 1\\}$.\nThe general form is $L_i(\\zeta) = \\prod_{j \\in \\{-1,0,1\\}, j \\neq i} \\frac{\\zeta - \\zeta_j}{\\zeta_i - \\zeta_j}$. This yields:\n- $L_{-1}(\\zeta) = \\frac{(\\zeta-0)(\\zeta-1)}{(-1-0)(-1-1)} = \\frac{1}{2}\\zeta(\\zeta-1)$\n- $L_{0}(\\zeta) = \\frac{(\\zeta-(-1))(\\zeta-1)}{(0-(-1))(0-1)} = -(\\zeta+1)(\\zeta-1) = 1-\\zeta^2$\n- $L_{1}(\\zeta) = \\frac{(\\zeta-(-1))(\\zeta-0)}{(1-(-1))(1-0)} = \\frac{1}{2}\\zeta(\\zeta+1)$\n\nTheir derivatives with respect to $\\zeta$ are also required:\n- $\\frac{dL_{-1}}{d\\zeta} = \\zeta - \\frac{1}{2}$\n- $\\frac{dL_{0}}{d\\zeta} = -2\\zeta$\n- $\\frac{dL_{1}}{d\\zeta} = \\zeta + \\frac{1}{2}$\n\n**2. Two-Dimensional Shape Functions**\nThe two-dimensional shape functions $N_k(\\xi, \\eta)$ for node $k$ are formed by a tensor product of the 1D polynomials. Given the specified node ordering $k = 0, \\dots, 8$, we can establish a mapping from the scalar index $k$ to the pair of 1D node indices $(i, j) \\in \\{-1, 0, 1\\} \\times \\{-1, 0, 1\\}$. The mapping is $i = (k \\pmod 3) - 1$ and $j = \\lfloor k/3 \\rfloor - 1$.\nThe shape function for node $k$, corresponding to index pair $(i, j)$, is:\n$$N_k(\\xi, \\eta) = L_i(\\xi) L_j(\\eta)$$\nIts partial derivatives, required for the Jacobian calculation, are found using the product rule:\n$$\\frac{\\partial N_k}{\\partial \\xi} = \\frac{dL_i(\\xi)}{d\\xi} L_j(\\eta)$$\n$$\\frac{\\partial N_k}{\\partial \\eta} = L_i(\\xi) \\frac{dL_j(\\eta)}{d\\eta}$$\n\n**3. Isoparametric Mapping and the Jacobian Matrix**\nThe isoparametric formulation uses the same shape functions to interpolate both the geometry and the solution field. The mapping from the reference element $(\\xi, \\eta)$ to the physical element $(x, y)$ is:\n$$x(\\xi, \\eta) = \\sum_{k=0}^{8} N_k(\\xi, \\eta) X_k, \\quad y(\\xi, \\eta) = \\sum_{k=0}^{8} N_k(\\xi, \\eta) Y_k$$\nThe Jacobian matrix $\\mathbf{J}$ relates the differential elements in the two coordinate systems, $d\\mathbf{x} = \\mathbf{J} d\\boldsymbol{\\xi}$. Its components are:\n$$J_{11} = \\frac{\\partial x}{\\partial \\xi} = \\sum_{k=0}^{8} \\frac{\\partial N_k}{\\partial \\xi} X_k, \\quad J_{12} = \\frac{\\partial x}{\\partial \\eta} = \\sum_{k=0}^{8} \\frac{\\partial N_k}{\\partial \\eta} X_k$$\n$$J_{21} = \\frac{\\partial y}{\\partial \\xi} = \\sum_{k=0}^{8} \\frac{\\partial N_k}{\\partial \\xi} Y_k, \\quad J_{22} = \\frac{\\partial y}{\\partial \\eta} = \\sum_{k=0}^{8} \\frac{\\partial N_k}{\\partial \\eta} Y_k$$\nThe determinant $\\det \\mathbf{J}$ is a scaling factor between the differential areas: $dA_{phys} = \\det \\mathbf{J} \\, dA_{ref}$. A valid mapping requires $\\det \\mathbf{J} > 0$ everywhere in the element. If $\\det \\mathbf{J} \\le 0$, the mapping is singular or locally inverted (\"tangled mesh\"), which is unphysical.\n\n**4. The Patch Test**\nThe patch test verifies an element's ability to exactly reproduce a constant strain state. For a displacement field $u(x, y) = a + bx + cy$, the strain components (derivatives of displacement) are constant: $\\frac{\\partial u}{\\partial x} = b$ and $\\frac{\\partial u}{\\partial y} = c$. The exact gradient is $\\nabla u_{\\text{exact}} = [b, c]^T$.\nThe nodal displacements are set to the exact values: $u_k = u(X_k, Y_k) = a + b X_k + c Y_k$.\nThe interpolated displacement field within the element is $u^h(\\xi, \\eta) = \\sum_{k=0}^{8} N_k(\\xi, \\eta) u_k$. Due to the properties of the isoparametric mapping, specifically that $\\sum N_k = 1$ (partition of unity) and $\\sum N_k X_k = x$, it can be shown that $u^h(\\xi, \\eta) = a + b x(\\xi, \\eta) + c y(\\xi, \\eta)$. This means the interpolated field is identical to the exact field.\nThe computed gradient in physical coordinates is obtained via the chain rule:\n$$\\begin{pmatrix} \\partial u^h/\\partial \\xi \\\\ \\partial u^h/\\partial \\eta \\end{pmatrix} = \\mathbf{J} \\begin{pmatrix} \\partial u^h/\\partial x \\\\ \\partial u^h/\\partial y \\end{pmatrix} \\implies \\nabla u^h = \\begin{pmatrix} \\partial u^h/\\partial x \\\\ \\partial u^h/\\partial y \\end{pmatrix} = \\mathbf{J}^{-1} \\begin{pmatrix} \\partial u^h/\\partial \\xi \\\\ \\partial u^h/\\partial \\eta \\end{pmatrix}$$\nwhere $\\partial u^h/\\partial \\xi = \\sum_k (\\partial N_k/\\partial \\xi) u_k$ and $\\partial u^h/\\partial \\eta = \\sum_k (\\partial N_k/\\partial \\eta) u_k$.\nTheoretically, if $\\det \\mathbf{J} > 0$, the computed gradient $\\nabla u^h$ must equal the exact gradient $[b, c]^T$ to within machine precision. The test passes if this holds and the Jacobian determinant is positive at all specified Gauss points.\n\n**5. Implementation**\nThe solution is implemented as a Python program. This program defines functions for the 1D Lagrange polynomials and their derivatives. A core function computes the 2D shape functions and their derivatives at a given $(\\xi, \\eta)$ point. A main test function orchestrates the process for a given set of nodal coordinates: it iterates through the $3 \\times 3$ Gauss points, computes $\\mathbf{J}$ and $\\det \\mathbf{J}$, and if the mapping is valid, it proceeds to compute the displacement gradient and its error. The results are aggregated to determine the overall pass/fail status and the minimum Jacobian determinant. This process is repeated for each of the four test cases defined in the problem.", "answer": "```python\nimport numpy as np\n\ndef _l_1d(zeta, i):\n    \"\"\"Computes the 1D quadratic Lagrange polynomial L_i(zeta) for i in {-1, 0, 1}.\"\"\"\n    if i == -1:\n        return 0.5 * zeta * (zeta - 1.0)\n    elif i == 0:\n        return 1.0 - zeta**2\n    elif i == 1:\n        return 0.5 * zeta * (zeta + 1.0)\n    else:\n        raise ValueError(\"Invalid index for 1D Lagrange polynomial.\")\n\ndef _dl_1d(zeta, i):\n    \"\"\"Computes the derivative of the 1D Lagrange polynomial dL_i/dzeta.\"\"\"\n    if i == -1:\n        return zeta - 0.5\n    elif i == 0:\n        return -2.0 * zeta\n    elif i == 1:\n        return zeta + 0.5\n    else:\n        raise ValueError(\"Invalid index for 1D Lagrange polynomial derivative.\")\n\ndef get_shape_functions_and_derivs(xi, eta):\n    \"\"\"\n    Computes the 9-node quad shape functions and their derivatives at (xi, eta).\n    Node ordering k=0..8 corresponds to (i,j) pairs from (-1,-1) to (1,1).\n    \"\"\"\n    N = np.zeros(9)\n    dN_dxi_deta = np.zeros((9, 2))\n    \n    for k in range(9):\n        i = (k % 3) - 1\n        j = (k // 3) - 1\n\n        L_i_xi = _l_1d(xi, i)\n        L_j_eta = _l_1d(eta, j)\n        dL_i_xi = _dl_1d(xi, i)\n        dL_j_eta = _dl_1d(eta, j)\n\n        N[k] = L_i_xi * L_j_eta\n        dN_dxi_deta[k, 0] = dL_i_xi * L_j_eta  # dN_k/dxi\n        dN_dxi_deta[k, 1] = L_i_xi * dL_j_eta  # dN_k/deta\n        \n    return N, dN_dxi_deta\n\ndef run_patch_test_q9(coords, a, b, c, tol):\n    \"\"\"\n    Performs the patch test for a single 9-node element.\n    \"\"\"\n    gauss_abscissae = [-np.sqrt(3.0 / 5.0), 0.0, np.sqrt(3.0 / 5.0)]\n    gauss_points = [(xi, eta) for eta in gauss_abscissae for xi in gauss_abscissae]\n    \n    min_det_J = float('inf')\n    max_grad_error = 0.0\n    \n    all_dets_positive = True\n\n    # Nodal displacements from the exact field u(x,y)\n    nodal_u = a + b * coords[:, 0] + c * coords[:, 1]\n    grad_u_exact = np.array([b, c])\n\n    for xi, eta in gauss_points:\n        # Get shape functions and their derivatives at the current Gauss point\n        N, dN_dxi_deta = get_shape_functions_and_derivs(xi, eta)\n        \n        # Compute Jacobian matrix\n        # J = [dx/dxi, dx/deta]\n        #     [dy/dxi, dy/deta]\n        J = np.dot(dN_dxi_deta.T, coords)\n\n        # Compute determinant of Jacobian\n        det_J = np.linalg.det(J)\n        min_det_J = min(min_det_J, det_J)\n        \n        if det_J = 0:\n            all_dets_positive = False\n\n        # Compute gradient if mapping is valid\n        if det_J > 0:\n            # Gradient of u in reference coordinates\n            grad_u_ref = np.dot(dN_dxi_deta.T, nodal_u)\n\n            # Gradient of u in physical coordinates: grad_u_phys = J^-1 * grad_u_ref\n            try:\n                grad_u_phys = np.linalg.solve(J, grad_u_ref)\n                error = np.max(np.abs(grad_u_phys - grad_u_exact))\n                max_grad_error = max(max_grad_error, error)\n            except np.linalg.LinAlgError:\n                # This should not happen if det_J > 0, but as a safeguard\n                all_dets_positive = False\n    \n    passes = all_dets_positive and (max_grad_error  tol)\n    return [passes, min_det_J]\n\n\ndef solve():\n    # Define test parameters\n    a, b, c = 0.3, -1.2, 2.5\n    tolerance = 1e-10\n    \n    # --- Test Case Generation ---\n    test_cases_coords = []\n\n    # Case 1: Random Mild Distortion\n    rng1 = np.random.default_rng(42)\n    coords1 = np.array([\n        [0.0, 0.0], [0.5, 0.0], [1.0, 0.0],\n        [0.0, 0.5], [0.5, 0.5], [1.0, 0.5],\n        [0.0, 1.0], [0.5, 1.0], [1.0, 1.0]\n    ])\n    perturbed_indices = [1, 3, 4, 5, 7]\n    perturbations1 = rng1.uniform(-0.1, 0.1, size=(len(perturbed_indices), 2))\n    coords1[perturbed_indices] += perturbations1\n    test_cases_coords.append(coords1)\n\n    # Case 2: Bow-tie self-intersection\n    coords2 = np.array([\n        [0.0, 0.0], [0.5, 0.0], [1.0, 0.0],  # k=0,1,2\n        [0.5, 0.5], [0.5, 0.5], [0.5, 0.5],  # k=3,4,5\n        [1.0, 1.0], [0.5, 1.0], [0.0, 1.0]   # k=6,7,8\n    ])\n    test_cases_coords.append(coords2)\n\n    # Case 3: Random Strong Distortion\n    rng3 = np.random.default_rng(7)\n    coords3 = np.array([\n        [0.0, 0.0], [0.5, 0.0], [1.0, 0.0],\n        [0.0, 0.5], [0.5, 0.5], [1.0, 0.5],\n        [0.0, 1.0], [0.5, 1.0], [1.0, 1.0]\n    ])\n    perturbations3 = rng3.uniform(-0.45, 0.45, size=(len(perturbed_indices), 2))\n    coords3[perturbed_indices] += perturbations3\n    test_cases_coords.append(coords3)\n    \n    # Case 4: Collapsed bottom edge\n    coords4 = np.array([\n        [0.0, 0.0], [0.0, 0.0], [0.0, 0.0],      # k=0,1,2\n        [0.0, 0.5], [0.25, 0.5], [0.5, 0.5],    # k=3,4,5\n        [0.0, 1.0], [0.5, 1.0], [1.0, 1.0]     # k=6,7,8\n    ])\n    test_cases_coords.append(coords4)\n\n    # Run tests and collect results\n    results = []\n    for coords in test_cases_coords:\n        result = run_patch_test_q9(coords, a, b, c, tolerance)\n        results.append(result)\n        \n    # Format and print the final output as a single string\n    # E.g., [[True, 0.123], [False, -0.001]]\n    output_str = f\"[{', '.join(str(r) for r in results)}]\"\n    print(output_str)\n\nsolve()\n```", "id": "3583985"}, {"introduction": "While powerful, higher-order elements can sometimes suffer from numerical issues like \"locking,\" where the element becomes overly stiff and produces inaccurate results, especially when modeling nearly incompressible materials. This practice involves a full finite element implementation to solve a boundary value problem, allowing you to observe this volumetric locking phenomenon directly. You will then implement a selective integration technique, a classic remedy, to appreciate how numerical integration schemes can be tailored to improve element performance. [@problem_id:3584031]", "problem": "Implement, from first principles, a small-strain, two-dimensional isoparametric Finite Element Method (FEM) for a single nine-node Lagrangian quadrilateral element (often abbreviated as Q9) to study the effect of selective integration on volumetric locking. Consider linear, isotropic elasticity under plane strain with Lamé parameters $\\lambda$ and $\\mu$ defined from Young’s modulus $E$ and Poisson’s ratio $\\nu$ by $\\lambda = \\dfrac{E \\nu}{(1+\\nu)(1-2\\nu)}$ and $\\mu = \\dfrac{E}{2(1+\\nu)}$. The governing equations in the absence of body forces are derived from the quasi-static balance of linear momentum $\\nabla \\cdot \\boldsymbol{\\sigma} = \\boldsymbol{0}$, with the linear constitutive relation $\\boldsymbol{\\sigma} = \\mathbf{D} \\boldsymbol{\\varepsilon}$ and small strain tensor $\\boldsymbol{\\varepsilon} = \\text{sym}(\\nabla \\boldsymbol{u})$. Under plane strain, the elasticity (constitutive) matrix in Voigt notation $\\boldsymbol{\\varepsilon} = [\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy}]^T$ is\n$$\n\\mathbf{D} = \n\\begin{bmatrix}\n\\lambda + 2\\mu  \\lambda  0 \\\\\n\\lambda  \\lambda + 2\\mu  0 \\\\\n0  0  \\mu\n\\end{bmatrix}.\n$$\nUse the isoparametric mapping with biquadratic Lagrange shape functions on the parent square $(\\xi,\\eta)\\in[-1,1]^2$ and perform numerical integration by Gaussian Quadrature (GQ). The element stiffness matrix is \n$$\n\\mathbf{K}_e = \\int_{\\Omega_e} \\mathbf{B}^T \\mathbf{D} \\mathbf{B} \\, d\\Omega,\n$$\nwhere $\\mathbf{B}$ is the standard strain-displacement matrix built from spatial derivatives of shape functions. Apply a uniform traction $\\boldsymbol{t} = [p, 0]^T$ on the right edge $\\Gamma_t$ of the element and assemble the consistent nodal force vector \n$$\n\\mathbf{f}_t = \\int_{\\Gamma_t} \\mathbf{N}^T \\boldsymbol{t} \\, d\\Gamma,\n$$\nwhere $\\mathbf{N}$ collects the scalar shape functions and the line integral is evaluated by one-dimensional Gaussian Quadrature on that edge.\n\nYour task is to implement two integration strategies for the same Q9 element:\n- Full integration: use $3\\times 3$ Gaussian Quadrature for the domain integral in $\\mathbf{K}_e$ without modification to $\\mathbf{B}$.\n- Selective integration via a $\\bar{\\mathbf{B}}$-type modification: construct a modified $\\bar{\\mathbf{B}}$ at each $3\\times 3$ Gaussian point by replacing only the volumetric (dilatational) part of the strain with its element mean, approximated by a single $1\\times 1$ Gaussian point at the element center. Let $\\frac{\\partial N_i}{\\partial x}$ and $\\frac{\\partial N_i}{\\partial y}$ denote spatial derivatives of the $i$-th shape function at a given quadrature point, and let $\\langle \\frac{\\partial N_i}{\\partial x} \\rangle$ and $\\langle \\frac{\\partial N_i}{\\partial y} \\rangle$ denote their elementwise averages computed using the central $1\\times 1$ quadrature. To enforce that the dilatation $\\varepsilon_{xx} + \\varepsilon_{yy}$ equals its element mean while leaving the shear unchanged, modify the first two rows of $\\mathbf{B}$ as follows: for each node $i$, with the $2\\times 1$ displacement vector at node $i$ collecting $(u_i, v_i)$,\n- define $\\Delta_i^x = \\langle \\tfrac{\\partial N_i}{\\partial x} \\rangle - \\tfrac{\\partial N_i}{\\partial x}$ and $\\Delta_i^y = \\langle \\tfrac{\\partial N_i}{\\partial y} \\rangle - \\tfrac{\\partial N_i}{\\partial y}$,\n- add $\\tfrac{1}{2}\\Delta_i^x$ to the $(\\varepsilon_{xx}, u_i)$ entry and $\\tfrac{1}{2}\\Delta_i^y$ to the $(\\varepsilon_{xx}, v_i)$ entry,\n- add $\\tfrac{1}{2}\\Delta_i^x$ to the $(\\varepsilon_{yy}, u_i)$ entry and $\\tfrac{1}{2}\\Delta_i^y$ to the $(\\varepsilon_{yy}, v_i)$ entry,\n- leave the shear row (for $\\gamma_{xy}$) unchanged.\nThis enforces that $\\varepsilon_{xx}+\\varepsilon_{yy}$ is replaced by its elementwise average while preserving the deviatoric and shear content, which mitigates volumetric locking.\n\nGeometry, material, and loading:\n- Single Q9 element spanning the unit square with physical coordinates $(x,y)\\in[0,1]\\times[0,1]$ in meters, obtained by mapping the standard Q9 parent nodes $(\\xi,\\eta)\\in\\{(-1,-1),(1,-1),(1,1),(-1,1),(0,-1),(1,0),(0,1),(-1,0),(0,0)\\}$ via $x=\\frac{\\xi+1}{2}$ and $y=\\frac{\\eta+1}{2}$.\n- Thickness $t = 1$ meter (plane strain).\n- Young’s modulus $E = 1000$ Pascals.\n- Right edge traction magnitude $p = 1$ Newton per meter, applied in the positive $x$-direction.\n- Essential boundary conditions: fix both displacement components $u=v=0$ on the left edge $x=0$ (all nodes lying at $x=0$).\n\nQuantity of interest:\n- For each case, compute the horizontal displacement $u_x$ at the mid-node on the right edge (node at $(x,y)=(1,0.5)$, which is node $6$ in standard Q9 ordering) in meters.\n\nTest suite:\n- Three Poisson’s ratios $\\nu \\in \\{0.0, 0.3, 0.49\\}$ (unitless).\n- For each $\\nu$, compute two values: the full integration result $u_x^{\\text{full}}$ and the selective-integration result $u_x^{\\text{sel}}$, both in meters as floating-point numbers.\n\nFinal output format:\n- Your program should produce a single line of output containing a flat, comma-separated list of six numbers corresponding to $[u_x^{\\text{full}}(\\nu=0.0), u_x^{\\text{sel}}(\\nu=0.0), u_x^{\\text{full}}(\\nu=0.3), u_x^{\\text{sel}}(\\nu=0.3), u_x^{\\text{full}}(\\nu=0.49), u_x^{\\text{sel}}(\\nu=0.49)]$, expressed in meters and each rounded to six decimal places.\n- Example of the required formatting pattern (illustrative only): \"[0.001234,0.001567,0.000890,0.001234,0.000100,0.001200]\".\n\nScientific and numerical constraints:\n- Use the fundamental weak form of linear elasticity, small-strain kinematics, and standard isoparametric Q9 interpolation.\n- Use $3\\times 3$ Gaussian Quadrature for domain integrals in both strategies; in the selective strategy, use a central $1\\times 1$ quadrature solely to compute the element-mean derivatives that define the $\\bar{\\mathbf{B}}$ modification.\n- Use $3$-point Gaussian Quadrature for the right-edge traction integral.\n- Plane strain assumption must be used consistently.\n- All physical quantities must be reported in meters for displacements and Pascals for stiffness quantities internally, but only the displacements are to be printed in the final output line as specified.", "solution": "The user-provided problem is a valid, well-posed exercise in computational solid mechanics. It is scientifically grounded in the principles of linear elasticity and the Finite Element Method (FEM), contains all necessary data for a unique solution, and is formulated with objective and precise language. The task is to implement a two-dimensional, small-strain, isoparametric FEM analysis for a single nine-node Lagrangian quadrilateral (Q9) element to compare the effects of full and selective numerical integration on volumetric locking.\n\nThe solution proceeds as follows: First, we establish the theoretical framework, including the governing equations, the isoparametric Q9 element formulation, and the material model. Second, we detail the two numerical integration strategies: standard full integration and the selective integration scheme using the $\\bar{\\mathbf{B}}$ method. Finally, we outline the procedure for assembling the system of equations, applying boundary conditions, and solving for the nodal displacements.\n\n### 1. Theoretical Formulation\n\nThe problem is governed by the quasi-static balance of linear momentum, which in the absence of body forces is $\\nabla \\cdot \\boldsymbol{\\sigma} = \\boldsymbol{0}$, where $\\boldsymbol{\\sigma}$ is the Cauchy stress tensor. For small strains, the strain tensor is $\\boldsymbol{\\varepsilon} = \\text{sym}(\\nabla \\boldsymbol{u})$, where $\\boldsymbol{u}$ is the displacement field. The material is linear, elastic, and isotropic, following the constitutive relation $\\boldsymbol{\\sigma} = \\mathbf{D} \\boldsymbol{\\varepsilon}$.\n\nThe weak form of the governing equation, which is the basis of the FEM, leads to the element-level matrix equation:\n$$\n\\mathbf{K}_e \\mathbf{d}_e = \\mathbf{f}_e\n$$\nwhere $\\mathbf{d}_e$ is the vector of nodal displacements for the element, $\\mathbf{K}_e$ is the element stiffness matrix, and $\\mathbf{f}_e$ is the element nodal force vector.\n\nThe element stiffness matrix is given by the integral over the element's domain $\\Omega_e$:\n$$\n\\mathbf{K}_e = \\int_{\\Omega_e} \\mathbf{B}^T \\mathbf{D} \\mathbf{B} \\, d\\Omega\n$$\nThe strain-displacement matrix, $\\mathbf{B}$, relates nodal displacements to strain components: $\\boldsymbol{\\varepsilon} = \\mathbf{B} \\mathbf{d}_e$.\n\n### 2. Isoparametric Nine-Node Quadrilateral (Q9) Element\n\nWe use a Q9 element defined on a parent square domain $(\\xi, \\eta) \\in [-1, 1]^2$. The element has nine nodes located at the grid points of $\\{-1, 0, 1\\} \\times \\{-1, 0, 1\\}$. The physical coordinates $(x, y)$ are mapped from the parent coordinates $(\\xi, \\eta)$ using the same shape functions used for interpolating the displacement field (isoparametric concept):\n$$\nx(\\xi, \\eta) = \\sum_{i=1}^{9} N_i(\\xi, \\eta) x_i, \\quad y(\\xi, \\eta) = \\sum_{i=1}^{9} N_i(\\xi, \\eta) y_i\n$$\nwhere $(x_i, y_i)$ are the physical coordinates of node $i$. For the specified unit square geometry $(x,y)\\in[0,1]^2$, the mapping is $x = (\\xi+1)/2$ and $y = (\\eta+1)/2$.\n\nThe biquadratic Lagrange shape functions $N_i(\\xi, \\eta)$ are products of 1D quadratic Lagrange polynomials. For a node $i$ at parent coordinates $(\\xi_i, \\eta_i)$:\n$N_i(\\xi, \\eta) = L(\\xi, \\xi_i) L(\\eta, \\eta_i)$, where\n$$\nL(t, t_i) = \n\\begin{cases}\n    \\frac{1}{2} t(t-1)  \\text{if } t_i = -1 \\\\\n    1 - t^2  \\text{if } t_i = 0 \\\\\n    \\frac{1}{2} t(t+1)  \\text{if } t_i = 1\n\\end{cases}\n$$\nThe chain rule relates spatial derivatives to derivatives in the parent domain:\n$$\n\\begin{Bmatrix} \\frac{\\partial N_i}{\\partial x} \\\\ \\frac{\\partial N_i}{\\partial y} \\end{Bmatrix} = \\mathbf{J}^{-1} \\begin{Bmatrix} \\frac{\\partial N_i}{\\partial \\xi} \\\\ \\frac{\\partial N_i}{\\partial \\eta} \\end{Bmatrix}\n$$\nwhere $\\mathbf{J}$ is the Jacobian matrix of the coordinate transformation. For the given mapping, $\\mathbf{J}$ is constant: $\\mathbf{J} = \\begin{bmatrix} 1/2  0 \\\\ 0  1/2 \\end{bmatrix}$, so $\\det(\\mathbf{J})=1/4$.\n\nThe strain-displacement matrix $\\mathbf{B}$ for a 2D problem is a $3 \\times 18$ matrix, composed of $3 \\times 2$ blocks for each of the $9$ nodes:\n$$\n\\mathbf{B} = [\\mathbf{B}_1, \\mathbf{B}_2, \\dots, \\mathbf{B}_9], \\quad \\mathbf{B}_i = \\begin{bmatrix} \\frac{\\partial N_i}{\\partial x}  0 \\\\ 0  \\frac{\\partial N_i}{\\partial y} \\\\ \\frac{\\partial N_i}{\\partial y}  \\frac{\\partial N_i}{\\partial x} \\end{bmatrix}\n$$\n\n### 3. Material Constitutive Model: Plane Strain\n\nUnder the plane strain assumption ($\\varepsilon_{zz}=0$), the constitutive matrix $\\mathbf{D}$ relates the in-plane stress and strain components ($\\boldsymbol{\\varepsilon} = [\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy}]^T$) via Lamé parameters $\\lambda$ and $\\mu$:\n$$\n\\mathbf{D} = \n\\begin{bmatrix}\n\\lambda + 2\\mu  \\lambda  0 \\\\\n\\lambda  \\lambda + 2\\mu  0 \\\\\n0  0  \\mu\n\\end{bmatrix}\n$$\nThe parameters are defined from Young’s modulus $E$ and Poisson’s ratio $\\nu$ as:\n$$\n\\lambda = \\frac{E \\nu}{(1+\\nu)(1-2\\nu)}, \\quad \\mu = \\frac{E}{2(1+\\nu)}\n$$\nAs $\\nu \\to 0.5$ (incompressible limit), $\\lambda \\to \\infty$, which can lead to numerical instability known as volumetric locking.\n\n### 4. Integration Schemes\n\nThe stiffness integral is evaluated numerically using Gaussian Quadrature (GQ):\n$$\n\\mathbf{K}_e = \\int_{-1}^1 \\int_{-1}^1 \\mathbf{B}^T(\\xi, \\eta) \\mathbf{D} \\mathbf{B}(\\xi, \\eta) \\det(\\mathbf{J}) \\, d\\xi \\, d\\eta \\approx \\sum_{j=1}^{n_{gp}} \\sum_{k=1}^{n_{gp}} w_j w_k \\left[ \\mathbf{B}^T \\mathbf{D} \\mathbf{B} \\det(\\mathbf{J}) \\right]_{(\\xi_j, \\eta_k)}\n$$\n\n**Full Integration:**\nThis approach uses a $3 \\times 3$ grid of Gaussian points ($n_{gp}=3$), which is sufficient to exactly integrate the stiffness matrix for a rectangular Q9 element. However, it is susceptible to volumetric locking for nearly incompressible materials.\n\n**Selective Integration ($\\bar{\\mathbf{B}}$ Method):**\nThis method mitigates locking by modifying the strain-displacement matrix to enforce a constant volumetric strain across the element. The element stiffness is still computed using a $3 \\times 3$ GQ, but at each quadrature point $(\\xi_{gp}, \\eta_{gp})$, a modified matrix $\\bar{\\mathbf{B}}$ is used. The modification steps are:\n\n1.  Compute the standard spatial derivatives $\\frac{\\partial N_i}{\\partial x}$ and $\\frac{\\partial N_i}{\\partial y}$ at the current $3 \\times 3$ quadrature point.\n2.  Compute the element-mean spatial derivatives $\\langle \\frac{\\partial N_i}{\\partial x} \\rangle$ and $\\langle \\frac{\\partial N_i}{\\partial y} \\rangle$ by evaluating them at the element center $(\\xi=0, \\eta=0)$, which corresponds to a $1 \\times 1$ GQ rule.\n3.  For each node $i$, define the deviation terms: $\\Delta_i^x = \\langle \\tfrac{\\partial N_i}{\\partial x} \\rangle - \\tfrac{\\partial N_i}{\\partial x}$ and $\\Delta_i^y = \\langle \\tfrac{\\partial N_i}{\\partial y} \\rangle - \\tfrac{\\partial N_i}{\\partial y}$.\n4.  Construct the modified matrix $\\bar{\\mathbf{B}}$ by adjusting the blocks $\\mathbf{B}_i$ of the standard matrix $\\mathbf{B}$:\n    $$\n    \\bar{\\mathbf{B}}_i = \\begin{bmatrix}\n    \\frac{\\partial N_i}{\\partial x} + \\frac{1}{2}\\Delta_i^x  \\frac{1}{2}\\Delta_i^y \\\\\n    \\frac{1}{2}\\Delta_i^x  \\frac{\\partial N_i}{\\partial y} + \\frac{1}{2}\\Delta_i^y \\\\\n    \\frac{\\partial N_i}{\\partial y}  \\frac{\\partial N_i}{\\partial x}\n    \\end{bmatrix}\n    $$\nThis modification ensures that the computed volumetric strain $\\varepsilon_v = \\varepsilon_{xx} + \\varepsilon_{yy}$ is replaced by its element-wise average $\\langle \\varepsilon_v \\rangle$, effectively decoupling the volumetric response from higher-order deformation modes and preventing locking.\n\n### 5. Force Vector, Boundary Conditions, and Solution\n\nThe external load is a uniform traction $\\boldsymbol{t} = [p, 0]^T$ on the right edge ($x=1$, or $\\xi=1$). The consistent nodal force vector is computed by a line integral, evaluated using $3$-point one-dimensional GQ:\n$$\n\\mathbf{f}_t = \\int_{\\Gamma_t} \\mathbf{N}^T \\boldsymbol{t} \\, d\\Gamma = \\int_{-1}^1 \\mathbf{N}(\\xi=1, \\eta)^T \\begin{Bmatrix} p \\\\ 0 \\end{Bmatrix} |\\frac{d\\mathbf{x}}{d\\eta}| d\\eta \\approx \\sum_{k=1}^{3} w_k \\left[ \\mathbf{N}^T \\begin{Bmatrix} p \\\\ 0 \\end{Bmatrix} \\frac{1}{2} \\right]_{(\\xi=1, \\eta_k)}\n$$\nwhere $|d\\mathbf{x}/d\\eta|=1/2$ is the length of the differential line element on the edge.\n\nEssential boundary conditions $u=v=0$ are applied on the left edge ($x=0$), fixing the degrees of freedom (DOFs) associated with nodes 1, 4, and 8. The system $\\mathbf{K}\\mathbf{d} = \\mathbf{f}$ is partitioned into free and prescribed DOFs, and the reduced system $\\mathbf{K}_{ff} \\mathbf{d}_f = \\mathbf{f}_f$ is solved for the unknown displacements $\\mathbf{d}_f$. The horizontal displacement $u_x$ at the mid-node of the right edge (node 6) is then extracted from the solution vector.\nThis procedure is repeated for each specified value of Poisson's ratio $\\nu$ and for both integration schemes. The results demonstrate that for $\\nu$ approaching $0.5$, the full integration scheme produces an overly stiff response (small displacement), a classic sign of volumetric locking, while the selective integration scheme yields a more physically plausible result.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy is not needed for this problem, numpy.polynomial is sufficient\nfrom numpy.polynomial.legendre import leggauss\n\ndef solve():\n    \"\"\"\n    Implements a 2D FEM analysis for a single Q9 element to study volumetric locking.\n    \"\"\"\n    \n    def get_q9_shape_functions_and_derivs(xi, eta):\n        \"\"\"\n        Calculates the shape functions and their derivatives for a Q9 element \n        at a given point (xi, eta) in the parent domain.\n\n        Node ordering:\n        4---7---3\n        |   |   |\n        8---9---6\n        |   |   |\n        1---5---2  (This is a visual representation, my code uses a different standard order)\n        \n        The problem uses a standard counter-clockwise order:\n        1(-1,-1), 2(1,-1), 3(1,1), 4(-1,1), 5(0,-1), 6(1,0), 7(0,1), 8(-1,0), 9(0,0)\n        \"\"\"\n        # Nodal coordinates in parent domain [-1, 1] x [-1, 1]\n        xis = [-1, 1, 1, -1, 0, 1, 0, -1, 0]\n        etas = [-1, -1, 1, 1, -1, 0, 1, 0, 0]\n        \n        N = np.zeros(9)\n        dN_dxi = np.zeros(9)\n        dN_deta = np.zeros(9)\n\n        def get_1d_poly_and_deriv(t, t_i):\n            if t_i == -1:\n                L = 0.5 * t * (t-1)\n                dL_dt = 0.5 * (2*t - 1)\n            elif t_i == 0:\n                L = 1 - t**2\n                dL_dt = -2*t\n            elif t_i == 1:\n                L = 0.5 * t * (t+1)\n                dL_dt = 0.5 * (2*t + 1)\n            else:\n                raise ValueError(\"Invalid nodal coordinate\")\n            return L, dL_dt\n\n        for i in range(9):\n            xi_i, eta_i = xis[i], etas[i]\n            \n            # This logic is incorrect for tensor product. Correcting it.\n            # L_xi and L_eta need to be calculated based on node's xi_i and eta_i\n            # but using the general form based on t_i = -1, 0, 1\n            \n            # 1D functions for xi\n            L_xi_m1, dL_dxi_m1 = get_1d_poly_and_deriv(xi, -1)\n            L_xi_0,  dL_dxi_0  = get_1d_poly_and_deriv(xi, 0)\n            L_xi_p1, dL_dxi_p1 = get_1d_poly_and_deriv(xi, 1)\n            \n            # 1D functions for eta\n            L_eta_m1, dL_deta_m1 = get_1d_poly_and_deriv(eta, -1)\n            L_eta_0,  dL_deta_0  = get_1d_poly_and_deriv(eta, 0)\n            L_eta_p1, dL_deta_p1 = get_1d_poly_and_deriv(eta, 1)\n\n            L_xis = { -1: L_xi_m1, 0: L_xi_0, 1: L_xi_p1 }\n            dL_dxis = { -1: dL_dxi_m1, 0: dL_dxi_0, 1: dL_dxi_p1 }\n            L_etas = { -1: L_eta_m1, 0: L_eta_0, 1: L_eta_p1 }\n            dL_detas = { -1: dL_deta_m1, 0: dL_deta_0, 1: dL_deta_p1 }\n\n            N[i] = L_xis[xi_i] * L_etas[eta_i]\n            dN_dxi[i] = dL_dxis[xi_i] * L_etas[eta_i]\n            dN_deta[i] = L_xis[xi_i] * dL_detas[eta_i]\n\n        return N, dN_dxi, dN_deta\n\n    def get_fem_solution(E, nu, integration_type):\n        \"\"\"\n        Calculates the displacement for a given material and integration type.\n        \"\"\"\n        # Material parameters\n        if nu == 0.5: # Handle the incompressible limit case\n            # This is not strictly necessary for nu=0.49, but good practice\n            lambda_ = E / (2 * (1 + nu)) * nu / (1 - 2*nu)\n        else:\n            lambda_ = E * nu / ((1 + nu) * (1 - 2 * nu))\n        mu = E / (2 * (1 + nu))\n\n        D = np.array([\n            [lambda_ + 2 * mu, lambda_, 0],\n            [lambda_, lambda_ + 2 * mu, 0],\n            [0, 0, mu]\n        ])\n\n        # Isoparametric mapping and Jacobian\n        # x = (xi+1)/2, y = (eta+1)/2\n        J = np.array([[0.5, 0.0], [0.0, 0.5]])\n        detJ = np.linalg.det(J)\n        J_inv = np.linalg.inv(J)\n\n        # Stiffness Matrix K_e (18x18)\n        K_e = np.zeros((18, 18))\n        \n        # Gaussian quadrature for domain integral\n        gp_3, w_3 = leggauss(3)\n        \n        # Element-mean derivatives for B-bar method\n        if integration_type == 'selective':\n            _, dN_dxi_mean, dN_deta_mean = get_q9_shape_functions_and_derivs(0, 0)\n            dN_dx_mean = J_inv[0, 0] * dN_dxi_mean + J_inv[0, 1] * dN_deta_mean\n            dN_dy_mean = J_inv[1, 0] * dN_dxi_mean + J_inv[1, 1] * dN_deta_mean\n\n        for i in range(3):\n            for j in range(3):\n                xi, eta = gp_3[i], gp_3[j]\n                weight = w_3[i] * w_3[j]\n                \n                _, dN_dxi, dN_deta = get_q9_shape_functions_and_derivs(xi, eta)\n                \n                # Spatial derivatives dN/dx, dN/dy\n                dN_dx = J_inv[0, 0] * dN_dxi + J_inv[0, 1] * dN_deta\n                dN_dy = J_inv[1, 0] * dN_dxi + J_inv[1, 1] * dN_deta\n\n                # Strain-displacement matrix B (3x18)\n                B = np.zeros((3, 18))\n                for k in range(9):\n                    B[0, 2*k] = dN_dx[k]\n                    B[1, 2*k+1] = dN_dy[k]\n                    B[2, 2*k] = dN_dy[k]\n                    B[2, 2*k+1] = dN_dx[k]\n\n                # B-bar modification for selective integration\n                if integration_type == 'selective':\n                    B_bar = np.copy(B)\n                    for k in range(9):\n                        delta_x = dN_dx_mean[k] - dN_dx[k]\n                        delta_y = dN_dy_mean[k] - dN_dy[k]\n                        B_bar[0, 2*k] += 0.5 * delta_x\n                        B_bar[0, 2*k+1] += 0.5 * delta_y\n                        B_bar[1, 2*k] += 0.5 * delta_x\n                        B_bar[1, 2*k+1] += 0.5 * delta_y\n                    B_to_use = B_bar\n                else: # full integration\n                    B_to_use = B\n\n                K_e += B_to_use.T @ D @ B_to_use * detJ * weight\n\n        # Force vector F_t (18x1)\n        F_t = np.zeros(18)\n        p = 1.0  # Traction magnitude N/m\n        \n        # 1D GQ for line integral on right edge (xi=1)\n        gp_3_1d, w_3_1d = leggauss(3)\n        dl_deta = 0.5  # |dx/deta| on edge xi=1\n        \n        for i in range(3):\n            eta = gp_3_1d[i]\n            weight = w_3_1d[i]\n            \n            N, _, _ = get_q9_shape_functions_and_derivs(1, eta)\n            \n            for k in range(9):\n                F_t[2*k] += N[k] * p * dl_deta * weight\n                \n        # Apply boundary conditions\n        # Fix nodes 1, 4, 8 (left edge, x=0)\n        # Nodal indices (1-based): 1, 4, 8\n        # Code's 0-based indices: 0, 3, 7\n        # DOFs to fix (0-indexed): 0,1 (node 1); 6,7 (node 4); 14,15 (node 8)\n        fixed_dofs = [0, 1, 6, 7, 14, 15]\n        all_dofs = list(range(18))\n        free_dofs = [dof for dof in all_dofs if dof not in fixed_dofs]\n\n        K_ff = K_e[np.ix_(free_dofs, free_dofs)]\n        F_f = F_t[free_dofs]\n\n        # Solve for free displacements\n        U_f = np.linalg.solve(K_ff, F_f)\n        \n        # DOF of interest: u_x at node 6\n        # Node 6 (1-based) is index 5 (0-based) in code's list.\n        # DOFs 10 (u) and 11 (v) (0-indexed)\n        target_dof = 10\n        target_idx_in_Uf = free_dofs.index(target_dof)\n        \n        return U_f[target_idx_in_Uf]\n\n    # --- Main execution ---\n    test_cases = [\n        0.0,\n        0.3,\n        0.49\n    ]\n    E = 1000.0  # Pascals\n    \n    results = []\n    \n    for nu in test_cases:\n        # Full integration\n        ux_full = get_fem_solution(E, nu, integration_type='full')\n        results.append(ux_full)\n        \n        # Selective integration\n        ux_sel = get_fem_solution(E, nu, integration_type='selective')\n        results.append(ux_sel)\n\n    # Format output as specified\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3584031"}]}