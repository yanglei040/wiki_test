{"hands_on_practices": [{"introduction": "Before implementing enhanced modes, it's crucial to understand the theoretical constraints that ensure they improve performance without corrupting the solution. This exercise guides you through proving that a candidate incompatible mode satisfies two fundamental requirements: it must vanish on the element boundary to maintain compatibility in the mean, and it must be orthogonal to rigid body motions to prevent the generation of spurious energy [@problem_id:3573667]. Mastering these analytical checks is the first step toward designing robust finite elements.", "problem": "Consider a $4$-node isoparametric bilinear quadrilateral element ($Q4$) in the Finite Element Method (FEM) for small-strain, linear elastic analysis. To enhance the element’s bending performance while preserving consistency with the principle of virtual work, an internal (element-level) incompatible displacement field is added to the standard bilinear displacement interpolation. To prevent spurious coupling with rigid body motions and to avoid inter-element incompatibilities, the enhanced displacement field must vanish on the entire element boundary and be $L^{2}$-orthogonal to all rigid body motions over the reference element.\n\nLet the reference domain be $\\Omega = [-1,1] \\times [-1,1]$ with local coordinates $(\\xi,\\eta)$. Define the vector-valued enhanced displacement mode (incompatible mode) using polynomial terms that reflect the structure $\\xi(1-\\eta^{2})$ and $\\eta(1-\\xi^{2})$, but are further multiplied by the element-boundary bubble to enforce vanishing on $\\partial\\Omega$:\n$$\n\\widetilde{\\mathbf{u}}(\\xi,\\eta) \\;=\\; c\n\\begin{pmatrix}\n\\xi\\,(1-\\xi^{2})\\,(1-\\eta^{2}) \\\\\n\\eta\\,(1-\\xi^{2})\\,(1-\\eta^{2})\n\\end{pmatrix},\n$$\nwhere $c>0$ is a scalar normalization constant to be determined.\n\nUse the $L^{2}$ inner product on $\\Omega$ defined by\n$$\n\\langle \\mathbf{a},\\mathbf{b}\\rangle \\;=\\; \\int_{-1}^{1}\\int_{-1}^{1} \\mathbf{a}(\\xi,\\eta)\\cdot\\mathbf{b}(\\xi,\\eta)\\,\\mathrm{d}\\xi\\,\\mathrm{d}\\eta.\n$$\nLet the rigid body motions over $\\Omega$ be represented by the constant translations $\\mathbf{t}_{x} = (1,0)^{\\mathsf{T}}$, $\\mathbf{t}_{y} = (0,1)^{\\mathsf{T}}$, and the in-plane rotation about the origin $\\mathbf{r}(\\xi,\\eta) = (-\\eta,\\xi)^{\\mathsf{T}}$.\n\nStarting only from these definitions and the requirement that incompatible modes contribute no spurious energy under rigid motions, carry out the following:\n\n$1.$ Prove that $\\widetilde{\\mathbf{u}}(\\xi,\\eta)$ vanishes on the entire boundary $\\partial\\Omega$.\n\n$2.$ Prove that the orthogonality conditions\n$$\n\\langle \\widetilde{\\mathbf{u}},\\mathbf{t}_{x}\\rangle \\;=\\; \\langle \\widetilde{\\mathbf{u}},\\mathbf{t}_{y}\\rangle \\;=\\; \\langle \\widetilde{\\mathbf{u}},\\mathbf{r}\\rangle \\;=\\; 0\n$$\nare satisfied.\n\n$3.$ Determine the unique positive normalization factor $c$ such that the enhanced mode has unit $L^{2}$ norm,\n$$\n\\|\\widetilde{\\mathbf{u}}\\|_{L^{2}(\\Omega)} \\;=\\; \\left(\\int_{-1}^{1}\\int_{-1}^{1} \\|\\widetilde{\\mathbf{u}}(\\xi,\\eta)\\|^{2}\\,\\mathrm{d}\\xi\\,\\mathrm{d}\\eta\\right)^{1/2} \\;=\\; 1.\n$$\n\nYour final answer must be the exact closed-form expression for $c$ (no units, no rounding).", "solution": "The problem is subjected to validation before proceeding with a solution.\n\n### Step 1: Extract Givens\n-   Element Type: $4$-node isoparametric bilinear quadrilateral element ($Q4$) for small-strain, linear elastic analysis.\n-   Reference Domain: $\\Omega = [-1,1] \\times [-1,1]$ with local coordinates $(\\xi,\\eta)$.\n-   Incompatible Displacement Mode: $\\widetilde{\\mathbf{u}}(\\xi,\\eta) \\;=\\; c \\begin{pmatrix} \\xi\\,(1-\\xi^{2})\\,(1-\\eta^{2}) \\\\ \\eta\\,(1-\\xi^{2})\\,(1-\\eta^{2}) \\end{pmatrix}$, with a scalar normalization constant $c>0$.\n-   $L^{2}$ Inner Product: $\\langle \\mathbf{a},\\mathbf{b}\\rangle \\;=\\; \\int_{-1}^{1}\\int_{-1}^{1} \\mathbf{a}(\\xi,\\eta)\\cdot\\mathbf{b}(\\xi,\\eta)\\,\\mathrm{d}\\xi\\,\\mathrm{d}\\eta$.\n-   Rigid Body Motions:\n    -   Translation in $x$: $\\mathbf{t}_{x} = (1,0)^{\\mathsf{T}}$\n    -   Translation in $y$: $\\mathbf{t}_{y} = (0,1)^{\\mathsf{T}}$\n    -   In-plane rotation: $\\mathbf{r}(\\xi,\\eta) = (-\\eta,\\xi)^{\\mathsf{T}}$\n-   Tasks:\n    1.  Prove $\\widetilde{\\mathbf{u}}(\\xi,\\eta)$ vanishes on the entire boundary $\\partial\\Omega$.\n    2.  Prove the orthogonality conditions $\\langle \\widetilde{\\mathbf{u}},\\mathbf{t}_{x}\\rangle \\;=\\; 0$, $\\langle \\widetilde{\\mathbf{u}},\\mathbf{t}_{y}\\rangle \\;=\\; 0$, and $\\langle \\widetilde{\\mathbf{u}},\\mathbf{r}\\rangle \\;=\\; 0$.\n    3.  Determine the unique positive $c$ such that $\\|\\widetilde{\\mathbf{u}}\\|_{L^{2}(\\Omega)} \\;=\\; 1$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is scientifically grounded within the field of computational solid mechanics, specifically the Finite Element Method. The concept of incompatible modes (or enhanced assumed strains) and their required properties (vanishing on the boundary, orthogonality to rigid body motions) are well-established principles for developing robust finite elements that avoid locking phenomena. The problem is well-posed, with all necessary mathematical definitions provided. The language is objective and precise. The problem is self-contained, consistent, and requires a definite set of mathematical proofs and a calculation, all of which are verifiable. No flaws are identified.\n\n### Step 3: Verdict and Action\nThe problem is valid. A complete solution will be provided.\n\n***\n\n### Solution\n\nThe problem requires proofs of certain properties of the given incompatible displacement mode $\\widetilde{\\mathbf{u}}(\\xi,\\eta)$ and the calculation of its normalization constant $c$. The tasks are addressed in the specified order.\n\n**1. Proof of Vanishing on the Boundary**\n\nThe incompatible displacement field is given by:\n$$\n\\widetilde{\\mathbf{u}}(\\xi,\\eta) = c\n\\begin{pmatrix}\n\\xi\\,(1-\\xi^{2})\\,(1-\\eta^{2}) \\\\\n\\eta\\,(1-\\xi^{2})\\,(1-\\eta^{2})\n\\end{pmatrix}\n$$\nThe reference domain is the square $\\Omega = [-1,1] \\times [-1,1]$. Its boundary, $\\partial\\Omega$, consists of four segments:\n-   The line where $\\xi = 1$ for $\\eta \\in [-1,1]$.\n-   The line where $\\xi = -1$ for $\\eta \\in [-1,1]$.\n-   The line where $\\eta = 1$ for $\\xi \\in [-1,1]$.\n-   The line where $\\eta = -1$ for $\\xi \\in [-1,1]$.\n\nAny point $(\\xi,\\eta) \\in \\partial\\Omega$ must satisfy either $|\\xi| = 1$ or $|\\eta| = 1$.\n\nLet's examine the common factor $(1-\\xi^{2})(1-\\eta^{2})$ in both components of $\\widetilde{\\mathbf{u}}(\\xi,\\eta)$.\n-   If a point lies on the boundary where $|\\xi|=1$, the term $(1-\\xi^{2})$ becomes $(1 - (\\pm 1)^{2}) = 1-1=0$. This makes the entire product $(1-\\xi^{2})(1-\\eta^{2})$ equal to $0$.\n-   If a point lies on the boundary where $|\\eta|=1$, the term $(1-\\eta^{2})$ becomes $(1 - (\\pm 1)^{2}) = 1-1=0$. This also makes the entire product $(1-\\xi^{2})(1-\\eta^{2})$ equal to $0$.\n\nSince for any point on $\\partial\\Omega$ at least one of these conditions holds, the factor $(1-\\xi^{2})(1-\\eta^{2})$ is identically zero for all $(\\xi,\\eta) \\in \\partial\\Omega$. Consequently, both components of $\\widetilde{\\mathbf{u}}(\\xi,\\eta)$ are zero on the boundary.\n$$\n\\widetilde{\\mathbf{u}}(\\xi,\\eta) = \\mathbf{0} \\quad \\forall (\\xi,\\eta) \\in \\partial\\Omega\n$$\nThis completes the proof.\n\n**2. Proof of Orthogonality to Rigid Body Motions**\n\nWe must prove that $\\langle \\widetilde{\\mathbf{u}},\\mathbf{t}_{x}\\rangle = 0$, $\\langle \\widetilde{\\mathbf{u}},\\mathbf{t}_{y}\\rangle = 0$, and $\\langle \\widetilde{\\mathbf{u}},\\mathbf{r}\\rangle = 0$.\n\n-   **Orthogonality to $\\mathbf{t}_{x}$:**\n    The inner product is $\\langle \\widetilde{\\mathbf{u}},\\mathbf{t}_{x}\\rangle = \\int_{-1}^{1}\\int_{-1}^{1} \\widetilde{\\mathbf{u}}(\\xi,\\eta) \\cdot \\mathbf{t}_{x} \\,\\mathrm{d}\\xi\\,\\mathrm{d}\\eta$. The dot product is:\n    $$\n    \\widetilde{\\mathbf{u}} \\cdot \\mathbf{t}_{x} = c \\begin{pmatrix} \\xi(1-\\xi^2)(1-\\eta^2) \\\\ \\eta(1-\\xi^2)(1-\\eta^2) \\end{pmatrix} \\cdot \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} = c \\xi(1-\\xi^2)(1-\\eta^2)\n    $$\n    The integral is:\n    $$\n    \\langle \\widetilde{\\mathbf{u}},\\mathbf{t}_{x}\\rangle = c \\int_{-1}^{1}\\int_{-1}^{1} \\xi(1-\\xi^2)(1-\\eta^2) \\,\\mathrm{d}\\xi\\,\\mathrm{d}\\eta = c \\left( \\int_{-1}^{1} \\xi(1-\\xi^2)\\,\\mathrm{d}\\xi \\right) \\left( \\int_{-1}^{1} (1-\\eta^2)\\,\\mathrm{d}\\eta \\right)\n    $$\n    The integrand of the first integral, $f(\\xi) = \\xi - \\xi^3$, is an odd function since $f(-\\xi) = (-\\xi) - (-\\xi)^3 = -\\xi + \\xi^3 = -f(\\xi)$. The integral of an odd function over a symmetric interval $[-1,1]$ is zero.\n    $$\n    \\int_{-1}^{1} \\xi(1-\\xi^2)\\,\\mathrm{d}\\xi = 0\n    $$\n    Therefore, $\\langle \\widetilde{\\mathbf{u}},\\mathbf{t}_{x}\\rangle = c \\cdot 0 \\cdot \\left( \\int_{-1}^{1} (1-\\eta^2)\\,\\mathrm{d}\\eta \\right) = 0$.\n\n-   **Orthogonality to $\\mathbf{t}_{y}$:**\n    Similarly, the dot product is:\n    $$\n    \\widetilde{\\mathbf{u}} \\cdot \\mathbf{t}_{y} = c \\begin{pmatrix} \\xi(1-\\xi^2)(1-\\eta^2) \\\\ \\eta(1-\\xi^2)(1-\\eta^2) \\end{pmatrix} \\cdot \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix} = c \\eta(1-\\xi^2)(1-\\eta^2)\n    $$\n    The integral is:\n    $$\n    \\langle \\widetilde{\\mathbf{u}},\\mathbf{t}_{y}\\rangle = c \\int_{-1}^{1}\\int_{-1}^{1} \\eta(1-\\xi^2)(1-\\eta^2) \\,\\mathrm{d}\\xi\\,\\mathrm{d}\\eta = c \\left( \\int_{-1}^{1} (1-\\xi^2)\\,\\mathrm{d}\\xi \\right) \\left( \\int_{-1}^{1} \\eta(1-\\eta^2)\\,\\mathrm{d}\\eta \\right)\n    $$\n    The integrand of the second integral, $g(\\eta) = \\eta - \\eta^3$, is an odd function. Thus, its integral over $[-1,1]$ is zero.\n    $$\n    \\int_{-1}^{1} \\eta(1-\\eta^2)\\,\\mathrm{d}\\eta = 0\n    $$\n    Therefore, $\\langle \\widetilde{\\mathbf{u}},\\mathbf{t}_{y}\\rangle = 0$.\n\n-   **Orthogonality to $\\mathbf{r}$:**\n    The dot product with the rotational mode $\\mathbf{r}(\\xi,\\eta) = (-\\eta, \\xi)^{\\mathsf{T}}$ is:\n    $$\n    \\widetilde{\\mathbf{u}} \\cdot \\mathbf{r} = c \\begin{pmatrix} \\xi(1-\\xi^2)(1-\\eta^2) \\\\ \\eta(1-\\xi^2)(1-\\eta^2) \\end{pmatrix} \\cdot \\begin{pmatrix} -\\eta \\\\ \\xi \\end{pmatrix}\n    $$\n    $$\n    \\widetilde{\\mathbf{u}} \\cdot \\mathbf{r} = c \\left( -\\eta\\xi(1-\\xi^2)(1-\\eta^2) + \\xi\\eta(1-\\xi^2)(1-\\eta^2) \\right) = 0\n    $$\n    Since the integrand is identically zero everywhere in the domain $\\Omega$, the integral is zero.\n    $$\n    \\langle \\widetilde{\\mathbf{u}},\\mathbf{r}\\rangle = \\int_{-1}^{1}\\int_{-1}^{1} 0 \\,\\mathrm{d}\\xi\\,\\mathrm{d}\\eta = 0\n    $$\n    This completes the proof of orthogonality.\n\n**3. Determination of the Normalization Constant $c$**\n\nThe normalization condition is $\\|\\widetilde{\\mathbf{u}}\\|_{L^{2}(\\Omega)} = 1$, which is equivalent to $\\|\\widetilde{\\mathbf{u}}\\|_{L^{2}(\\Omega)}^{2} = 1$.\n$$\n\\int_{-1}^{1}\\int_{-1}^{1} \\|\\widetilde{\\mathbf{u}}(\\xi,\\eta)\\|^{2}\\,\\mathrm{d}\\xi\\,\\mathrm{d}\\eta = 1\n$$\nFirst, calculate the squared Euclidean norm of the vector $\\widetilde{\\mathbf{u}}$:\n$$\n\\|\\widetilde{\\mathbf{u}}\\|^{2} = \\left(c\\xi(1-\\xi^2)(1-\\eta^2)\\right)^2 + \\left(c\\eta(1-\\xi^2)(1-\\eta^2)\\right)^2\n$$\n$$\n\\|\\widetilde{\\mathbf{u}}\\|^{2} = c^2\\xi^2(1-\\xi^2)^2(1-\\eta^2)^2 + c^2\\eta^2(1-\\xi^2)^2(1-\\eta^2)^2\n$$\n$$\n\\|\\widetilde{\\mathbf{u}}\\|^{2} = c^2(\\xi^2 + \\eta^2)(1-\\xi^2)^2(1-\\eta^2)^2\n$$\nNow, we integrate this expression over the domain $\\Omega$:\n$$\n1 = c^2 \\int_{-1}^{1}\\int_{-1}^{1} (\\xi^2 + \\eta^2)(1-\\xi^2)^2(1-\\eta^2)^2 \\,\\mathrm{d}\\xi\\,\\mathrm{d}\\eta\n$$\nWe can split the integral into two parts:\n$$\n\\frac{1}{c^2} = \\int_{-1}^{1}\\int_{-1}^{1} \\xi^2(1-\\xi^2)^2(1-\\eta^2)^2\\,\\mathrm{d}\\xi\\,\\mathrm{d}\\eta + \\int_{-1}^{1}\\int_{-1}^{1} \\eta^2(1-\\xi^2)^2(1-\\eta^2)^2\\,\\mathrm{d}\\xi\\,\\mathrm{d}\\eta\n$$\nThese two integrals can be separated into products of one-dimensional integrals:\n$$\n\\frac{1}{c^2} = \\left( \\int_{-1}^{1} \\xi^2(1-\\xi^2)^2\\,\\mathrm{d}\\xi \\right)\\left( \\int_{-1}^{1} (1-\\eta^2)^2\\,\\mathrm{d}\\eta \\right) + \\left( \\int_{-1}^{1} (1-\\xi^2)^2\\,\\mathrm{d}\\xi \\right)\\left( \\int_{-1}^{1} \\eta^2(1-\\eta^2)^2\\,\\mathrm{d}\\eta \\right)\n$$\nLet's define two helper integrals, noting that the integrands are even functions:\n$$\nJ_1 = \\int_{-1}^{1} (1-x^2)^2\\,\\mathrm{d}x = \\int_{-1}^{1} (1 - 2x^2 + x^4)\\,\\mathrm{d}x = 2 \\left[ x - \\frac{2}{3}x^3 + \\frac{1}{5}x^5 \\right]_0^1 = 2\\left(1 - \\frac{2}{3} + \\frac{1}{5}\\right) = 2\\left(\\frac{15-10+3}{15}\\right) = \\frac{16}{15}\n$$\n$$\nJ_2 = \\int_{-1}^{1} x^2(1-x^2)^2\\,\\mathrm{d}x = \\int_{-1}^{1} (x^2 - 2x^4 + x^6)\\,\\mathrm{d}x = 2 \\left[ \\frac{1}{3}x^3 - \\frac{2}{5}x^5 + \\frac{1}{7}x^7 \\right]_0^1 = 2\\left(\\frac{1}{3} - \\frac{2}{5} + \\frac{1}{7}\\right) = 2\\left(\\frac{35-42+15}{105}\\right) = \\frac{16}{105}\n$$\nSubstituting these results back into the equation for $c$:\n$$\n\\frac{1}{c^2} = (J_2)(J_1) + (J_1)(J_2) = 2 J_1 J_2\n$$\n$$\n\\frac{1}{c^2} = 2 \\left( \\frac{16}{15} \\right) \\left( \\frac{16}{105} \\right) = \\frac{2 \\cdot 256}{15 \\cdot 105} = \\frac{512}{1575}\n$$\nSolving for $c^2$:\n$$\nc^2 = \\frac{1575}{512}\n$$\nSince the problem specifies that $c>0$, we take the positive square root:\n$$\nc = \\sqrt{\\frac{1575}{512}}\n$$\nTo simplify the expression, we find the prime factors:\n$1575 = 3^2 \\cdot 5^2 \\cdot 7 = 225 \\cdot 7$\n$512 = 2^9 = 256 \\cdot 2$\n$$\nc = \\sqrt{\\frac{225 \\cdot 7}{256 \\cdot 2}} = \\frac{\\sqrt{225}\\sqrt{7}}{\\sqrt{256}\\sqrt{2}} = \\frac{15\\sqrt{7}}{16\\sqrt{2}}\n$$\nRationalizing the denominator:\n$$\nc = \\frac{15\\sqrt{7}}{16\\sqrt{2}} \\cdot \\frac{\\sqrt{2}}{\\sqrt{2}} = \\frac{15\\sqrt{14}}{16 \\cdot 2} = \\frac{15\\sqrt{14}}{32}\n$$\nThis is the final expression for the normalization constant $c$.", "answer": "$$\\boxed{\\frac{15\\sqrt{14}}{32}}$$", "id": "3573667"}, {"introduction": "Theory must be validated by numerical experiment. This practice challenges you to implement a numerical patch test, a fundamental verification tool in finite element analysis, for an element with enhanced displacements [@problem_id:3573570]. You will verify that under a constant strain state, the enhanced degrees of freedom correctly condense to zero, but only if the coupling terms are integrated with sufficient accuracy, revealing a critical link between variational principles and their computational implementation.", "problem": "Consider a two-dimensional small-strain, linear-elastic, plane strain quadrilateral element occupying the physical domain $\\Omega = [0,1]\\times[0,1]$ with nodes at $(0,0)$, $(1,0)$, $(1,1)$, and $(0,1)$, ordered counterclockwise. The compatible displacement field is approximated by standard bilinear shape functions, so that $\\mathbf{u}_c(x,y) = \\sum_{i=1}^4 N_i(x,y)\\,\\mathbf{d}_i$, where $\\mathbf{d}_i \\in \\mathbb{R}^2$ are the nodal displacements, and the bilinear shape functions are\n- $N_1(x,y) = (1-x)(1-y)$,\n- $N_2(x,y) = x(1-y)$,\n- $N_3(x,y) = xy$,\n- $N_4(x,y) = (1-x)y$.\n\nThe enhanced displacement field augments the compatible field with two internal (element-level) degrees of freedom associated with a bubble function $\\phi_b(x,y)$ that vanishes on $\\partial\\Omega$, namely\n- $\\mathbf{u}_{e,1}(x,y) = \\begin{bmatrix}\\phi_b(x,y) \\\\ 0\\end{bmatrix}$,\n- $\\mathbf{u}_{e,2}(x,y) = \\begin{bmatrix}0 \\\\ \\phi_b(x,y)\\end{bmatrix}$,\nwith\n$$\n\\phi_b(x,y) = x(1-x)\\,y(1-y)\\,(x - c), \\quad c = 0.3.\n$$\nThe total displacement field is $\\mathbf{u}(x,y) = \\mathbf{u}_c(x,y) + \\mathbf{u}_e(x,y)$, where $\\mathbf{u}_e(x,y) = \\sum_{\\alpha=1}^{2} \\mathbf{h}_\\alpha(x,y)\\,a_\\alpha$ with $\\mathbf{h}_1=\\mathbf{u}_{e,1}$, $\\mathbf{h}_2=\\mathbf{u}_{e,2}$, and $a_\\alpha \\in \\mathbb{R}$ are the enhanced parameters.\n\nUse the small-strain tensor $\\boldsymbol{\\varepsilon}(\\mathbf{u}) = \\tfrac{1}{2}\\left(\\nabla\\mathbf{u} + \\nabla\\mathbf{u}^\\mathsf{T}\\right)$ and the Voigt vector $\\boldsymbol{\\varepsilon}_v = [\\varepsilon_{xx},\\,\\varepsilon_{yy},\\,\\gamma_{xy}]^\\mathsf{T}$ with engineering shear strain $\\gamma_{xy} = 2\\varepsilon_{xy}$. For plane strain, the constitutive matrix $\\mathbf{C}\\in\\mathbb{R}^{3\\times 3}$ is\n$$\n\\mathbf{C} = \\begin{bmatrix}\n\\lambda + 2\\mu & \\lambda & 0 \\\\\n\\lambda & \\lambda + 2\\mu & 0 \\\\\n0 & 0 & \\mu\n\\end{bmatrix}, \\quad\n\\mu = \\dfrac{E}{2(1+\\nu)}, \\quad \\lambda = \\dfrac{E\\nu}{(1+\\nu)(1-2\\nu)},\n$$\nwhere $E$ is the Young’s modulus and $\\nu$ is the Poisson’s ratio.\n\nStarting from the principle of virtual work and the definition of the element strain energy,\n$$\n\\Pi(\\mathbf{d},\\mathbf{a}) = \\tfrac{1}{2}\\int_{\\Omega} \\boldsymbol{\\varepsilon}_v(\\mathbf{u}_c + \\mathbf{u}_e)^\\mathsf{T}\\,\\mathbf{C}\\,\\boldsymbol{\\varepsilon}_v(\\mathbf{u}_c + \\mathbf{u}_e)\\, \\mathrm{d}\\Omega,\n$$\nshow that stationarity with respect to the enhanced parameters $\\mathbf{a}$ yields a linear system of the form\n$$\n\\mathbf{K}_{aa}\\,\\mathbf{a} + \\mathbf{K}_{ad}\\,\\mathbf{d} = \\mathbf{0},\n$$\nwith block matrices\n$$\n\\mathbf{K}_{dd} = \\int_{\\Omega} \\mathbf{B}_c^\\mathsf{T}\\mathbf{C}\\mathbf{B}_c\\,\\mathrm{d}\\Omega,\\quad\n\\mathbf{K}_{da} = \\int_{\\Omega} \\mathbf{B}_c^\\mathsf{T}\\mathbf{C}\\mathbf{B}_e\\,\\mathrm{d}\\Omega,\\quad\n\\mathbf{K}_{aa} = \\int_{\\Omega} \\mathbf{B}_e^\\mathsf{T}\\mathbf{C}\\mathbf{B}_e\\,\\mathrm{d}\\Omega,\n$$\nand $\\mathbf{K}_{ad}=\\mathbf{K}_{da}^\\mathsf{T}$. Here, $\\mathbf{B}_c$ and $\\mathbf{B}_e$ are the compatible and enhanced strain-displacement matrices associated with $\\mathbf{u}_c$ and $\\mathbf{u}_e$, respectively.\n\nFor a prescribed uniform strain state $\\boldsymbol{\\varepsilon}_0 = [\\varepsilon_{xx}^{(0)},\\,\\varepsilon_{yy}^{(0)},\\,\\gamma_{xy}^{(0)}]^\\mathsf{T}$, the exact displacement field is linear,\n$$\n\\mathbf{u}_0(x,y) = \\begin{bmatrix} \\varepsilon_{xx}^{(0)}\\,x + \\tfrac{1}{2}\\gamma_{xy}^{(0)}\\,y \\\\ \\tfrac{1}{2}\\gamma_{xy}^{(0)}\\,x + \\varepsilon_{yy}^{(0)}\\,y \\end{bmatrix},\n$$\nfrom which the nodal values $\\mathbf{d}$ are obtained by evaluating $\\mathbf{u}_0$ at the four nodes. Under exact integration, prove that the condensed enhanced parameters\n$$\n\\mathbf{a}^\\star = -\\mathbf{K}_{aa}^{-1}\\,\\mathbf{K}_{ad}\\,\\mathbf{d}\n$$\nmust be $\\mathbf{0}$ for any uniform strain state, due to the vanishing boundary of $\\phi_b$ and the divergence theorem applied to $\\int_{\\Omega}\\nabla \\phi_b\\,\\mathrm{d}\\Omega$.\n\nYour task is to implement a program that:\n- Assembles $\\mathbf{K}_{dd}$, $\\mathbf{K}_{da}$, and $\\mathbf{K}_{aa}$ using tensor-product Gauss–Legendre quadrature on $\\Omega$ with sufficient order to achieve exact integration for the chosen bubble function (use $n=5$ points per direction for all blocks to ensure exactness).\n- Forms $\\mathbf{d}$ from $\\boldsymbol{\\varepsilon}_0$ using the exact linear displacement field.\n- Computes $\\mathbf{a}^\\star = -\\mathbf{K}_{aa}^{-1}\\mathbf{K}_{ad}\\mathbf{d}$, and checks whether $\\|\\mathbf{a}^\\star\\|_2 \\le \\tau$ with tolerance $\\tau = 10^{-12}$.\n- For a final edge-case test, purposefully under-integrate only $\\mathbf{K}_{da}$ with a single Gauss point at the element center (i.e., $n=1$ per direction on $[0,1]$), while keeping $\\mathbf{K}_{aa}$ exact, and verify that the resulting $\\mathbf{a}^\\star$ fails the zero test for a general uniform strain state.\n\nUse the following test suite, where each tuple lists $(E,\\nu,\\varepsilon_{xx}^{(0)},\\varepsilon_{yy}^{(0)},\\gamma_{xy}^{(0)},\\text{integration\\_mode})$ with $\\text{integration\\_mode}\\in\\{\\text{exact},\\text{under}\\}$ specifying whether to use exact or under-integrated $\\mathbf{K}_{da}$:\n- Test $1$: $(200.0,\\,0.3,\\,0.01,\\,0.0,\\,0.0,\\,\\text{exact})$.\n- Test $2$: $(150.0,\\,0.0,\\,0.0,\\,0.02,\\,0.0,\\,\\text{exact})$.\n- Test $3$: $(210.0,\\,0.49,\\,0.0,\\,0.0,\\,0.03,\\,\\text{exact})$.\n- Test $4$: $(123.4,\\,0.27,\\,0.005,\\,-0.002,\\,0.01,\\,\\text{exact})$.\n- Test $5$: $(123.4,\\,0.27,\\,0.005,\\,-0.002,\\,0.01,\\,\\text{under})$.\n\nAll quantities are dimensionless. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5]$), where each $\\text{result}_i$ is a boolean that is $\\text{True}$ if $\\|\\mathbf{a}^\\star\\|_2 \\le \\tau$ and $\\text{False}$ otherwise.", "solution": "The problem statement is evaluated to be valid. It is scientifically grounded in the principles of computational solid mechanics, specifically the theory of enhanced strain finite elements. The problem is well-posed, containing all necessary definitions, constants, and boundary conditions to arrive at a unique, verifiable solution. The language is objective and precise.\n\nThe core of the problem is to verify the patch test for a quadrilateral element with an incompatible modes (enhanced strain) formulation. The patch test is a fundamental consistency check for a finite element formulation, which dictates that under a state of constant strain, the element must reproduce that strain field exactly, without parasitic effects. In the context of enhanced strain methods, this requires that the enhanced parameters, $\\mathbf{a}$, vanish for any prescribed uniform strain state.\n\n### 1. Element Formulation\n\nThe total displacement field $\\mathbf{u}$ is additively decomposed into a compatible part $\\mathbf{u}_c$ and an enhanced (or incompatible) part $\\mathbf{u}_e$:\n$$\n\\mathbf{u}(x,y) = \\mathbf{u}_c(x,y) + \\mathbf{u}_e(x,y)\n$$\nThe compatible part ensures inter-element continuity and is defined by the standard bilinear shape functions $N_i$ and nodal displacements $\\mathbf{d}_i \\in \\mathbb{R}^2$:\n$$\n\\mathbf{u}_c(x,y) = \\sum_{i=1}^4 N_i(x,y) \\mathbf{d}_i\n$$\nThe vector of nodal displacements is $\\mathbf{d} = [d_{1x}, d_{1y}, d_{2x}, d_{2y}, d_{3x}, d_{3y}, d_{4x}, d_{4y}]^\\mathsf{T} \\in \\mathbb{R}^8$.\n\nThe enhanced part $\\mathbf{u}_e$ is defined internally to the element and vanishes on the element boundary $\\partial \\Omega$. It is constructed using a bubble function $\\phi_b(x,y)$ and a set of internal parameters $\\mathbf{a} = [a_1, a_2]^\\mathsf{T}$.\n$$\n\\mathbf{u}_e(x,y) = \\sum_{\\alpha=1}^{2} \\mathbf{h}_\\alpha(x,y) a_\\alpha\n= a_1 \\begin{bmatrix}\\phi_b(x,y) \\\\ 0\\end{bmatrix} + a_2 \\begin{bmatrix}0 \\\\ \\phi_b(x,y)\\end{bmatrix}\n$$\nwhere $\\phi_b(x,y) = x(1-x)y(1-y)(x-c)$ with $c=0.3$. The factor $x(1-x)y(1-y)$ ensures that $\\phi_b$ is zero on the boundary of the unit square $\\Omega = [0,1]\\times[0,1]$.\n\n### 2. Strain-Displacement and Constitutive Relations\n\nThe small-strain tensor, in Voigt notation $\\boldsymbol{\\varepsilon}_v = [\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy}]^\\mathsf{T}$, is given by $\\boldsymbol{\\varepsilon}_v(\\mathbf{u}) = \\mathbf{L} \\mathbf{u}$, where $\\mathbf{L}$ is the differential operator matrix:\n$$\n\\mathbf{L} = \\begin{bmatrix} \\partial/\\partial x & 0 \\\\ 0 & \\partial/\\partial y \\\\ \\partial/\\partial y & \\partial/\\partial x \\end{bmatrix}\n$$\nThe total strain is also decomposed: $\\boldsymbol{\\varepsilon}_v = \\boldsymbol{\\varepsilon}_c + \\boldsymbol{\\varepsilon}_e$.\nThe compatible strain is $\\boldsymbol{\\varepsilon}_c = \\mathbf{L} \\mathbf{u}_c = \\mathbf{L} \\sum_{i=1}^4 N_i \\mathbf{I} \\mathbf{d}_i = (\\sum_{i=1}^4 (\\mathbf{L} N_i \\mathbf{I}) \\mathbf{d}_i)$. This defines the compatible strain-displacement matrix $\\mathbf{B}_c$, a $3 \\times 8$ matrix, such that $\\boldsymbol{\\varepsilon}_c = \\mathbf{B}_c \\mathbf{d}$. The columns of $\\mathbf{B}_c$ corresponding to node $i$ are:\n$$\n\\mathbf{B}_{c,i} = \\begin{bmatrix} \\partial N_i/\\partial x & 0 \\\\ 0 & \\partial N_i/\\partial y \\\\ \\partial N_i/\\partial y & \\partial N_i/\\partial x \\end{bmatrix}\n$$\nThe enhanced strain is $\\boldsymbol{\\varepsilon}_e = \\mathbf{L} \\mathbf{u}_e = \\mathbf{L} \\sum_{\\alpha=1}^2 \\mathbf{h}_\\alpha a_\\alpha$. This defines the enhanced strain-displacement matrix $\\mathbf{B}_e$, a $3 \\times 2$ matrix, such that $\\boldsymbol{\\varepsilon}_e = \\mathbf{B}_e \\mathbf{a}$. Its columns are:\n$$\n\\text{col}_1(\\mathbf{B}_e) = \\mathbf{L} \\begin{bmatrix} \\phi_b \\\\ 0 \\end{bmatrix} = \\begin{bmatrix} \\partial\\phi_b/\\partial x \\\\ 0 \\\\ \\partial\\phi_b/\\partial y \\end{bmatrix}, \\quad\n\\text{col}_2(\\mathbf{B}_e) = \\mathbf{L} \\begin{bmatrix} 0 \\\\ \\phi_b \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ \\partial\\phi_b/\\partial y \\\\ \\partial\\phi_b/\\partial x \\end{bmatrix}\n$$\nSo,\n$$\n\\mathbf{B}_e(x,y) = \\begin{bmatrix}\n\\partial\\phi_b/\\partial x & 0 \\\\\n0 & \\partial\\phi_b/\\partial y \\\\\n\\partial\\phi_b/\\partial y & \\partial\\phi_b/\\partial x\n\\end{bmatrix}\n$$\nThe stress and strain are related by the plane strain constitutive matrix $\\mathbf{C}$.\n\n### 3. Stationarity and the Patch Test\n\nThe element strain energy is $\\Pi = \\frac{1}{2} \\int_\\Omega \\boldsymbol{\\varepsilon}_v^\\mathsf{T} \\mathbf{C} \\boldsymbol{\\varepsilon}_v \\, \\mathrm{d}\\Omega$. Substituting the strain decomposition:\n$$\n\\Pi(\\mathbf{d}, \\mathbf{a}) = \\tfrac{1}{2}\\int_{\\Omega} (\\mathbf{B}_c\\mathbf{d} + \\mathbf{B}_e\\mathbf{a})^\\mathsf{T}\\,\\mathbf{C}\\,(\\mathbf{B}_c\\mathbf{d} + \\mathbf{B}_e\\mathbf{a})\\, \\mathrm{d}\\Omega\n$$\nThe Hu-Washizu principle (or a simplified version for this case) requires that the stress field derived from the enhanced strain part be orthogonal to the compatible strain field. A more direct approach is to enforce stationarity of the functional with respect to the internal parameters $\\mathbf{a}$, which are not connected to other elements. This gives rise to an element-level static condensation procedure.\n$$\n\\dfrac{\\partial \\Pi}{\\partial \\mathbf{a}} = \\int_{\\Omega} \\mathbf{B}_e^\\mathsf{T} \\mathbf{C} (\\mathbf{B}_c\\mathbf{d} + \\mathbf{B}_e\\mathbf{a}) \\, \\mathrm{d}\\Omega = \\mathbf{0}\n$$\nRearranging terms, we obtain the system given in the problem:\n$$\n\\left(\\int_{\\Omega} \\mathbf{B}_e^\\mathsf{T} \\mathbf{C} \\mathbf{B}_e \\, \\mathrm{d}\\Omega\\right) \\mathbf{a} + \\left(\\int_{\\Omega} \\mathbf{B}_e^\\mathsf{T} \\mathbf{C} \\mathbf{B}_c \\, \\mathrm{d}\\Omega\\right) \\mathbf{d} = \\mathbf{0}\n$$\nThis corresponds to $\\mathbf{K}_{aa} \\mathbf{a} + \\mathbf{K}_{da}^\\mathsf{T} \\mathbf{d} = \\mathbf{0}$, or $\\mathbf{K}_{aa} \\mathbf{a} + \\mathbf{K}_{ad} \\mathbf{d} = \\mathbf{0}$. The condensed parameters are then $\\mathbf{a}^\\star = -\\mathbf{K}_{aa}^{-1} \\mathbf{K}_{ad} \\mathbf{d}$.\n\nFor the patch test, a uniform strain field $\\boldsymbol{\\varepsilon}_0$ is prescribed. The nodal displacements $\\mathbf{d}$ are set by evaluating the corresponding linear displacement field $\\mathbf{u}_0(x,y)$ at the nodes. Because standard bilinear elements are complete to first order, the compatible displacement field exactly reproduces this linear field, i.e., $\\mathbf{u}_c(x,y) = \\mathbf{u}_0(x,y)$. Consequently, the compatible strain field is constant and equal to the target strain: $\\boldsymbol{\\varepsilon}_c(x,y) = \\mathbf{B}_c(x,y)\\mathbf{d} = \\boldsymbol{\\varepsilon}_0$.\n\nThe term $\\mathbf{K}_{ad}\\mathbf{d}$ can be rewritten as:\n$$\n\\mathbf{K}_{ad}\\mathbf{d} = \\left(\\int_{\\Omega} \\mathbf{B}_e^\\mathsf{T} \\mathbf{C} \\mathbf{B}_c \\, \\mathrm{d}\\Omega\\right) \\mathbf{d} = \\int_{\\Omega} \\mathbf{B}_e^\\mathsf{T} \\mathbf{C} (\\mathbf{B}_c\\mathbf{d}) \\, \\mathrm{d}\\Omega = \\int_{\\Omega} \\mathbf{B}_e^\\mathsf{T} \\mathbf{C} \\boldsymbol{\\varepsilon}_0 \\, \\mathrm{d}\\Omega\n$$\nSince $\\mathbf{C}$ and $\\boldsymbol{\\varepsilon}_0$ are constant matrices, they can be taken out of the integral:\n$$\n\\mathbf{K}_{ad}\\mathbf{d} = \\left(\\int_{\\Omega} \\mathbf{B}_e^\\mathsf{T} \\, \\mathrm{d}\\Omega\\right) \\mathbf{C} \\boldsymbol{\\varepsilon}_0\n$$\nThe crucial part is the integral of the matrix $\\mathbf{B}_e$. Each entry of $\\mathbf{B}_e$ is a derivative of $\\phi_b$. Consider the integral of a derivative, e.g., $\\frac{\\partial\\phi_b}{\\partial x}$:\n$$\n\\int_{\\Omega} \\frac{\\partial\\phi_b}{\\partial x} \\, \\mathrm{d}\\Omega = \\int_0^1 \\int_0^1 \\frac{\\partial\\phi_b}{\\partial x} \\, dx dy = \\int_0^1 \\left[ \\phi_b(x,y) \\right]_{x=0}^{x=1} \\, dy\n$$\nSince $\\phi_b$ is defined to be zero on the boundary $\\partial \\Omega$ (specifically at $x=0$ and $x=1$), this integral is zero. The same logic applies to $\\int_\\Omega \\frac{\\partial\\phi_b}{\\partial y} \\, \\mathrm{d}\\Omega$. This is a direct consequence of the Divergence Theorem, as $\\int_\\Omega \\nabla \\phi_b \\, \\mathrm{d}\\Omega = \\int_{\\partial \\Omega} \\phi_b \\mathbf{n} \\, dS = \\mathbf{0}$.\nTherefore, $\\int_\\Omega \\mathbf{B}_e \\, \\mathrm{d}\\Omega = \\mathbf{0}$, which implies $\\int_\\Omega \\mathbf{B}_e^\\mathsf{T} \\, \\mathrm{d}\\Omega = \\mathbf{0}$.\nThis proves that $\\mathbf{K}_{ad}\\mathbf{d} = \\mathbf{0}$ for any uniform strain state, provided the integration is performed exactly. The system for $\\mathbf{a}$ simplifies to $\\mathbf{K}_{aa}\\mathbf{a} = \\mathbf{0}$. As long as the chosen enhanced modes are not trivial, $\\mathbf{K}_{aa}$ will be positive definite and thus invertible, leading to the unique solution $\\mathbf{a}^\\star = \\mathbf{0}$.\n\n### 4. Numerical Implementation\n\nThe implementation will assemble the matrices $\\mathbf{K}_{dd}$, $\\mathbf{K}_{da}$, and $\\mathbf{K}_{aa}$ via numerical quadrature. A tensor-product Gauss-Legendre rule is used. The domain is $[0,1]\\times[0,1]$. Standard Gauss points $\\xi_p \\in [-1,1]$ and weights $w_p^{\\text{std}}$ are mapped to points $x_p = (1+\\xi_p)/2$ and weights $w_p = w_p^{\\text{std}}/2$.\nThe integrals are approximated as:\n$$\n\\mathbf{K} \\approx \\sum_{p=1}^n \\sum_{q=1}^n \\mathbf{F}(x_p, y_q) w_p w_q\n$$\nwhere $\\mathbf{F}$ is the respective integrand. The problem specifies an integration order of $n=5$ points per direction for exact integration. This is sufficient, as the highest polynomial degree in the integrands is $6$.\nFor the final test case, $\\mathbf{K}_{da}$ is purposefully under-integrated using $n=1$ point (the element center). At this specific point, $\\nabla \\phi_b$ is generally non-zero, so the numerical integral of $\\mathbf{B}_e$ will be non-zero, causing the patch test to fail, i.e., $\\mathbf{a}^\\star \\neq \\mathbf{0}$. This verifies the importance of the integration order.\n\nThe algorithm proceeds as follows for each test case:\n1.  Define material parameters $(E, \\nu)$ and calculate $\\lambda, \\mu$ to form $\\mathbf{C}$.\n2.  Define the uniform strain state $\\boldsymbol{\\varepsilon}_0$ and calculate the nodal displacement vector $\\mathbf{d}$ from the exact linear field $\\mathbf{u}_0(x,y)$.\n3.  Initialize stiffness matrices $\\mathbf{K}_{aa}$, $\\mathbf{K}_{dd}$, $\\mathbf{K}_{da}$ to zero.\n4.  Get Gauss-Legendre points and weights for the required orders ($n=5$ and, if needed, $n=1$).\n5.  Numerically integrate to assemble $\\mathbf{K}_{aa}$, $\\mathbf{K}_{dd}$ (using $n=5$) and $\\mathbf{K}_{da}$ (using $n=5$ or $n=1$).\n6.  Solve the linear system $\\mathbf{K}_{aa} \\mathbf{a}^\\star = - \\mathbf{K}_{da}^\\mathsf{T} \\mathbf{d}$ for $\\mathbf{a}^\\star$.\n7.  Check if $\\|\\mathbf{a}^\\star\\|_2 \\le 10^{-12}$ and record the boolean result.", "answer": "```python\nimport numpy as np\nfrom numpy.polynomial.legendre import leggauss\n\ndef solve():\n    \"\"\"\n    Solves the enhanced strain quadrilateral element problem.\n    \"\"\"\n    \n    test_cases = [\n        (200.0, 0.3, 0.01, 0.0, 0.0, 'exact'),\n        (150.0, 0.0, 0.0, 0.02, 0.0, 'exact'),\n        (210.0, 0.49, 0.0, 0.0, 0.03, 'exact'),\n        (123.4, 0.27, 0.005, -0.002, 0.01, 'exact'),\n        (123.4, 0.27, 0.005, -0.002, 0.01, 'under'),\n    ]\n\n    results = []\n    \n    # Tolerance for checking if the norm of a_star is zero\n    tolerance = 1e-12\n    # Constant c for the bubble function\n    c_const = 0.3\n    # Nodal coordinates (counter-clockwise)\n    nodes = np.array([[0.0, 0.0], [1.0, 0.0], [1.0, 1.0], [0.0, 1.0]])\n    \n    # --- Define symbolic functions for derivatives ---\n    # Shape function derivatives\n    dN_dx = [\n        lambda x, y: -(1 - y),\n        lambda x, y: 1 - y,\n        lambda x, y: y,\n        lambda x, y: -y,\n    ]\n    dN_dy = [\n        lambda x, y: -(1 - x),\n        lambda x, y: -x,\n        lambda x, y: x,\n        lambda x, y: 1 - x,\n    ]\n    \n    # Bubble function derivatives\n    dphi_b_dx = lambda x, y: (3 * x**2 - 2 * (1 + c_const) * x + c_const) * (y - y**2)\n    dphi_b_dy = lambda x, y: (x**3 - (1 + c_const) * x**2 + c_const * x) * (1 - 2 * y)\n\n    for E, nu, eps_xx0, eps_yy0, gam_xy0, integration_mode in test_cases:\n        # 1. Material and Strain Setup\n        mu = E / (2 * (1 + nu))\n        if nu == 0.49: # Use a higher precision value to avoid ill-conditioning\n            lame_lambda = E * nu / ((1 + nu) * (1 - 2*nu))\n        else:\n            lame_lambda = E * nu / ((1 + nu) * (1 - 2*nu))\n\n        C = np.array([\n            [lame_lambda + 2 * mu, lame_lambda, 0],\n            [lame_lambda, lame_lambda + 2 * mu, 0],\n            [0, 0, mu]\n        ])\n\n        eps0 = np.array([eps_xx0, eps_yy0, gam_xy0])\n\n        # 2. Compute Nodal Displacements\n        d_vec = np.zeros(8)\n        for i in range(4):\n            x, y = nodes[i]\n            d_vec[2 * i] = eps_xx0 * x + 0.5 * gam_xy0 * y       # u_x\n            d_vec[2 * i + 1] = 0.5 * gam_xy0 * x + eps_yy0 * y   # u_y\n\n        # 3. Numerical Integration Setup\n        n_exact = 5\n        n_under = 1\n        \n        # Gauss points and weights for exact integration on [-1,1]\n        gp_exact, gw_exact_std = leggauss(n_exact)\n        \n        # Mapped points and weights for [0,1]\n        gp_exact_map = 0.5 * (gp_exact + 1)\n        gw_exact_map = 0.5 * gw_exact_std\n\n        # Quadrature rules for each matrix block\n        n_Kaa = n_Kdd = n_exact\n        gw_Kaa = gw_Kdd = gw_exact_map\n        gp_Kaa = gp_Kdd = gp_exact_map\n\n        if integration_mode == 'exact':\n            n_Kda = n_exact\n            gw_Kda = gw_exact_map\n            gp_Kda = gp_exact_map\n        else: # 'under'\n            n_Kda = n_under\n            gp_under, gw_under_std = leggauss(n_under)\n            gp_Kda = 0.5 * (gp_under + 1)\n            gw_Kda = 0.5 * gw_under_std\n\n        # 4. Assemble Matrices\n        K_dd = np.zeros((8, 8))\n        K_da = np.zeros((8, 2))\n        K_aa = np.zeros((2, 2))\n\n        # Helper function for assembly\n        def assemble(K, B1, B2, C_mat, gw_x, gw_y):\n            K += (B1.T @ C_mat @ B2) * gw_x * gw_y\n\n        # Integration for K_dd\n        for i, (gx, wx) in enumerate(zip(gp_Kdd, gw_Kdd)):\n            for j, (gy, wy) in enumerate(zip(gp_Kdd, gw_Kdd)):\n                Bc = np.zeros((3, 8))\n                for k in range(4):\n                    Bc[0, 2 * k] = dN_dx[k](gx, gy)\n                    Bc[1, 2 * k + 1] = dN_dy[k](gx, gy)\n                    Bc[2, 2 * k] = dN_dy[k](gx, gy)\n                    Bc[2, 2 * k + 1] = dN_dx[k](gx, gy)\n                assemble(K_dd, Bc, Bc, C, wx, wy)\n\n        # Integration for K_aa\n        for i, (gx, wx) in enumerate(zip(gp_Kaa, gw_Kaa)):\n            for j, (gy, wy) in enumerate(zip(gp_Kaa, gw_Kaa)):\n                dphib_dx_val = dphi_b_dx(gx, gy)\n                dphib_dy_val = dphi_b_dy(gx, gy)\n                Be = np.array([\n                    [dphib_dx_val, 0],\n                    [0, dphib_dy_val],\n                    [dphib_dy_val, dphib_dx_val]\n                ])\n                assemble(K_aa, Be, Be, C, wx, wy)\n\n        # Integration for K_da\n        for i, (gx, wx) in enumerate(zip(gp_Kda, gw_Kda)):\n            for j, (gy, wy) in enumerate(zip(gp_Kda, gw_Kda)):\n                Bc = np.zeros((3, 8))\n                for k in range(4):\n                    Bc[0, 2 * k] = dN_dx[k](gx, gy)\n                    Bc[1, 2 * k + 1] = dN_dy[k](gx, gy)\n                    Bc[2, 2 * k] = dN_dy[k](gx, gy)\n                    Bc[2, 2 * k + 1] = dN_dx[k](gx, gy)\n                \n                dphib_dx_val = dphi_b_dx(gx, gy)\n                dphib_dy_val = dphi_b_dy(gx, gy)\n                Be = np.array([\n                    [dphib_dx_val, 0],\n                    [0, dphib_dy_val],\n                    [dphib_dy_val, dphib_dx_val]\n                ])\n\n                assemble(K_da, Bc, Be, C, wx, wy)\n\n        # 5. Solve for a_star and check norm\n        K_ad = K_da.T\n        try:\n            a_star = np.linalg.solve(K_aa, -K_ad @ d_vec)\n            norm_a_star = np.linalg.norm(a_star)\n            results.append(norm_a_star = tolerance)\n        except np.linalg.LinAlgError:\n            # Should not happen if K_aa is well-conditioned\n            results.append(False) \n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3573570"}, {"introduction": "The primary motivation for many enhanced element formulations is to create computationally efficient elements that are free from numerical locking and instabilities. This practice uses eigenvalue analysis to diagnose the infamous 'hourglass' instability that plagues under-integrated elements and demonstrates how a carefully designed stabilization, rooted in the concept of incompatible modes, can selectively stiffen these spurious mechanisms [@problem_id:3573623]. By comparing the eigenvalue spectra of different formulations, you will gain a clear, quantitative understanding of element stability.", "problem": "You are to implement a small-scale eigenvalue analysis that reveals, in a precise and verifiable manner, how reduced numerical integration of a four-node bilinear quadrilateral element in two-dimensional elasticity produces spurious zero-energy patterns (hourglass modes), and how an enhancement that targets only the hourglass subspace restores coercivity without affecting rigid body modes. Your derivation and algorithm must start from the Principle of Virtual Work and the standard isoparametric finite element definitions. The end-product must be a complete program that constructs element stiffness matrices, performs eigenanalysis, identifies spurious zero-energy modes, and demonstrates their removal by a carefully designed enhanced displacement field contribution.\n\nUse the following base and definitions.\n\n- The Principle of Virtual Work for small-strain linear elasticity at the element level reads $\\,\\delta \\Pi_{e} = \\delta \\boldsymbol{u}_{e}^{\\mathsf{T}} \\boldsymbol{K}_{e} \\boldsymbol{u}_{e} - \\delta \\boldsymbol{u}_{e}^{\\mathsf{T}} \\boldsymbol{f}_{e} = 0\\,$ for all admissible virtual displacements $\\,\\delta \\boldsymbol{u}_{e}\\,$, wherein the element stiffness matrix is $\\,\\boldsymbol{K}_{e} = \\int_{\\Omega_{e}} \\boldsymbol{B}^{\\mathsf{T}} \\boldsymbol{C} \\boldsymbol{B} \\,\\mathrm{d}\\Omega\\,$. The strain-displacement matrix is $\\,\\boldsymbol{B}\\,$ and $\\,\\boldsymbol{C}\\,$ is the constitutive (material) matrix.\n- Consider a standard isoparametric four-node bilinear quadrilateral (often abbreviated as $\\,\\mathrm{Q4}\\,$) with nodal coordinates $\\,\\{(x_{i},y_{i})\\}_{i=1}^{4}\\,$ and nodal displacement vector $\\,\\boldsymbol{u}_{e} \\in \\mathbb{R}^{8}\\,$ ordered as $\\,\\boldsymbol{u}_{e} = [u_{1x},u_{1y},u_{2x},u_{2y},u_{3x},u_{3y},u_{4x},u_{4y}]^{\\mathsf{T}}\\,$. The bilinear shape functions in the parent domain $\\,(\\xi,\\eta)\\in[-1,1]^{2}\\,$ are $\\,N_{1}(\\xi,\\eta)=\\tfrac{1}{4}(1-\\xi)(1-\\eta)\\,$, $\\,N_{2}(\\xi,\\eta)=\\tfrac{1}{4}(1+\\xi)(1-\\eta)\\,$, $\\,N_{3}(\\xi,\\eta)=\\tfrac{1}{4}(1+\\xi)(1+\\eta)\\,$, $\\,N_{4}(\\xi,\\eta)=\\tfrac{1}{4}(1-\\xi)(1+\\eta)\\,$. The mapping to physical space is $\\,\\boldsymbol{x}(\\xi,\\eta)=\\sum_{i=1}^{4} N_{i}(\\xi,\\eta)\\,\\boldsymbol{x}_{i}\\,$ with Jacobian $\\,\\boldsymbol{J}=\\partial \\boldsymbol{x}/\\partial(\\xi,\\eta)\\,$ and $\\,\\mathrm{d}\\Omega = \\det(\\boldsymbol{J})\\,\\mathrm{d}\\xi\\,\\mathrm{d}\\eta\\,$. The gradient of shape functions in physical coordinates is obtained by $\\,\\nabla N_{i} = \\boldsymbol{J}^{-1}\\,\\nabla_{\\xi,\\eta} N_{i}\\,$.\n- For two-dimensional plane strain, the constitutive matrix is $\\,\\boldsymbol{C}=\\dfrac{E}{(1+\\nu)(1-2\\nu)}\\begin{bmatrix}1-\\nu  \\nu  0\\\\ \\nu  1-\\nu  0\\\\ 0  0  \\tfrac{1}{2}(1-2\\nu)\\end{bmatrix}\\,$, where $\\,E\\,$ is Young’s modulus and $\\,\\nu\\,$ is Poisson’s ratio. The strain-displacement matrix $\\,\\boldsymbol{B}\\,$ is constructed in the standard manner from $\\,\\partial N_{i}/\\partial x\\,$ and $\\,\\partial N_{i}/\\partial y\\,$ entries.\n\nYou must implement three element stiffness constructions:\n- Reduced integration: a single Gauss point at $\\,(\\xi,\\eta)=(0,0)\\,$ with weight $\\,w=4\\,$ on $\\,[-1,1]^{2}\\,$ so that $\\,\\boldsymbol{K}_{\\mathrm{red}}=\\boldsymbol{B}(0,0)^{\\mathsf{T}}\\boldsymbol{C}\\,\\boldsymbol{B}(0,0)\\,\\det(\\boldsymbol{J}(0,0))\\,w\\,$. This produces rank deficiency beyond rigid body modes and hence spurious zero-energy modes.\n- Full integration: a $\\,2\\times 2\\,$ Gauss rule with points $\\,(\\pm 1/\\sqrt{3},\\pm 1/\\sqrt{3})\\,$ and weight $\\,w=1\\,$, summed to obtain $\\,\\boldsymbol{K}_{\\mathrm{full}}\\,$. This eliminates spurious zero-energy modes in regular settings, leaving only rigid body modes.\n- Enhanced displacement stabilization on top of reduced integration: let $\\,\\mathcal{N}(\\boldsymbol{K}_{\\mathrm{red}})\\,$ denote the null space of $\\,\\boldsymbol{K}_{\\mathrm{red}}\\,$. Let $\\,\\mathcal{R}\\,$ be the subspace of rigid body modes spanned by two translations and one in-plane rotation about the centroid $\\,\\boldsymbol{x}_{c}\\,$, i.e., $\\,\\boldsymbol{r}_{1}=[1,0,1,0,1,0,1,0]^{\\mathsf{T}}\\,$, $\\,\\boldsymbol{r}_{2}=[0,1,0,1,0,1,0,1]^{\\mathsf{T}}\\,$, and $\\,\\boldsymbol{r}_{3}=[-y_{1}^{c},x_{1}^{c},-y_{2}^{c},x_{2}^{c},-y_{3}^{c},x_{3}^{c},-y_{4}^{c},x_{4}^{c}]^{\\mathsf{T}}\\,$ with $\\,\\boldsymbol{x}_{i}^{c}=\\boldsymbol{x}_{i}-\\boldsymbol{x}_{c}\\,$ and $\\,\\boldsymbol{x}_{c}=\\tfrac{1}{4}\\sum_{i=1}^{4}\\boldsymbol{x}_{i}\\,$. Define the hourglass subspace $\\,\\mathcal{H}=\\mathcal{N}(\\boldsymbol{K}_{\\mathrm{red}})\\ominus\\mathcal{R}\\,$. Construct an orthonormal basis $\\,\\boldsymbol{H}\\in\\mathbb{R}^{8\\times n_{h}}\\,$ of $\\,\\mathcal{H}\\,$ with $\\,n_{h}\\,$ equal to the dimension of $\\,\\mathcal{H}\\,$. Add an enhanced displacement stabilization $\\,\\boldsymbol{K}_{\\mathrm{enh}}=\\beta\\,\\boldsymbol{H}\\boldsymbol{H}^{\\mathsf{T}}\\,$ with $\\,\\beta=\\alpha\\,\\mu\\,L\\,$, where $\\,\\mu=\\dfrac{E}{2(1+\\nu)}\\,$ is the shear modulus, $\\,L=\\sqrt{A}\\,$ with $\\,A\\,$ the element area, and $\\,\\alpha=1\\,$ a dimensionless scaling. The enhanced stiffness is $\\,\\boldsymbol{K}_{\\mathrm{red+enh}}=\\boldsymbol{K}_{\\mathrm{red}}+\\boldsymbol{K}_{\\mathrm{enh}}\\,$. This construction must leave rigid body modes unpenalized and lift only hourglass modes, thereby eliminating spurious zero-energy patterns.\n\nYou must diagnose spurious zero-energy patterns as follows. Given a symmetric matrix $\\,\\boldsymbol{K}\\,$, compute its eigenvalues $\\,\\{\\lambda_{i}\\}\\,$. Let $\\,\\lambda_{\\max}=\\max_{i}|\\lambda_{i}|\\,$ and define a relative threshold $\\,\\varepsilon=\\max(10^{-8},10^{-8}\\lambda_{\\max})\\,$. Count $\\,n_{0}\\,$, the number of eigenvalues with $\\,|\\lambda_{i}|\\varepsilon\\,$. The number of spurious zero-energy modes is $\\,n_{\\mathrm{spur}}=\\max(0, n_{0}-3)\\,$, since there are $\\,3\\,$ rigid body modes in two-dimensional elasticity for a free element.\n\nImplement the above and apply it to the following test suite. Use plane strain with $\\,E=210\\times 10^{9}\\,$ and $\\,\\nu=0.30\\,$. Define two geometries:\n- Geometry $\\,\\mathcal{G}_{1}\\,$ (square): nodes at $\\,\\boldsymbol{x}_{1}=(0,0)\\,$, $\\,\\boldsymbol{x}_{2}=(1,0)\\,$, $\\,\\boldsymbol{x}_{3}=(1,1)\\,$, $\\,\\boldsymbol{x}_{4}=(0,1)\\,$ in meters.\n- Geometry $\\,\\mathcal{G}_{2}\\,$ (distorted parallelogram): nodes at $\\,\\boldsymbol{x}_{1}=(0,0)\\,$, $\\,\\boldsymbol{x}_{2}=(2,0)\\,$, $\\,\\boldsymbol{x}_{3}=(2.2,1)\\,$, $\\,\\boldsymbol{x}_{4}=(0.2,1)\\,$ in meters.\n\nForm six cases and, for each, report $\\,n_{\\mathrm{spur}}\\,$ as an integer:\n- Case $\\,1\\,$: reduced integration on $\\,\\mathcal{G}_{1}\\,$.\n- Case $\\,2\\,$: reduced integration plus enhancement on $\\,\\mathcal{G}_{1}\\,$.\n- Case $\\,3\\,$: full integration on $\\,\\mathcal{G}_{1}\\,$.\n- Case $\\,4\\,$: reduced integration on $\\,\\mathcal{G}_{2}\\,$.\n- Case $\\,5\\,$: reduced integration plus enhancement on $\\,\\mathcal{G}_{2}\\,$.\n- Case $\\,6\\,$: full integration on $\\,\\mathcal{G}_{2}\\,$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, i.e., $\\,\\big[ n_{\\mathrm{spur}}^{(1)}, n_{\\mathrm{spur}}^{(2)}, n_{\\mathrm{spur}}^{(3)}, n_{\\mathrm{spur}}^{(4)}, n_{\\mathrm{spur}}^{(5)}, n_{\\mathrm{spur}}^{(6)} \\big]\\,$, where each entry is an integer in the specified order of cases. No physical units are required in the output because the requested final quantities are pure counts.", "solution": "The problem requires an implementation and verification of numerical techniques in computational solid mechanics, specifically concerning the four-node bilinear quadrilateral ($\\mathrm{Q4}$) element in two-dimensional linear elasticity. The core task is to demonstrate the emergence of spurious zero-energy modes (hourglassing) under reduced integration and their subsequent elimination using an enhanced displacement field method. The analysis will be performed by computing the eigenvalues of different element stiffness matrices.\n\nThe derivation begins with the Principle of Virtual Work, which states that for a body in equilibrium, the virtual work done by external forces is equal to the change in internal strain energy for any admissible virtual displacement. For a single finite element, this is expressed as $\\delta \\Pi_{e} = \\int_{\\Omega_e} \\delta\\boldsymbol{\\varepsilon}^{\\mathsf{T}}\\boldsymbol{\\sigma} \\,\\mathrm{d}\\Omega - \\delta \\boldsymbol{u}_{e}^{\\mathsf{T}} \\boldsymbol{f}_{e} = 0$, where $\\boldsymbol{\\sigma}$ is the stress tensor, $\\boldsymbol{\\varepsilon}$ is the strain tensor, $\\boldsymbol{u}_e$ is the vector of nodal displacements, and $\\boldsymbol{f}_e$ is the vector of nodal forces.\n\nUsing the linear elastic constitutive relation $\\boldsymbol{\\sigma} = \\boldsymbol{C}\\boldsymbol{\\varepsilon}$ and the strain-displacement relation $\\boldsymbol{\\varepsilon} = \\boldsymbol{B} \\boldsymbol{u}_e$, where $\\boldsymbol{C}$ is the material constitutive matrix and $\\boldsymbol{B}$ is the strain-displacement matrix, the virtual work principle can be rewritten as:\n$$ \\delta \\Pi_{e} = \\int_{\\Omega_e} (\\delta(\\boldsymbol{B}\\boldsymbol{u}_e))^{\\mathsf{T}}\\boldsymbol{C}(\\boldsymbol{B}\\boldsymbol{u}_e) \\,\\mathrm{d}\\Omega - \\delta \\boldsymbol{u}_{e}^{\\mathsf{T}} \\boldsymbol{f}_{e} = 0 $$\n$$ \\delta \\boldsymbol{u}_{e}^{\\mathsf{T}} \\left( \\int_{\\Omega_e} \\boldsymbol{B}^{\\mathsf{T}} \\boldsymbol{C} \\boldsymbol{B} \\,\\mathrm{d}\\Omega \\right) \\boldsymbol{u}_{e} - \\delta \\boldsymbol{u}_{e}^{\\mathsf{T}} \\boldsymbol{f}_{e} = 0 $$\nSince this must hold for any arbitrary virtual displacement $\\delta \\boldsymbol{u}_e$, we identify the element stiffness matrix $\\boldsymbol{K}_e = \\boldsymbol{k}_e \\boldsymbol{u}_e$ as:\n$$ \\boldsymbol{K}_e = \\int_{\\Omega_e} \\boldsymbol{B}^{\\mathsf{T}} \\boldsymbol{C} \\boldsymbol{B} \\,\\mathrm{d}\\Omega $$\nThe integral is over the element's physical domain $\\Omega_e$. For an isoparametric element, we map this integral to a parent domain, typically $(\\xi, \\eta) \\in [-1, 1]^2$, using the Jacobian $\\boldsymbol{J}$ of the geometric mapping: $\\mathrm{d}\\Omega = \\det(\\boldsymbol{J}) \\,\\mathrm{d}\\xi\\,\\mathrm{d}\\eta$. The stiffness matrix becomes:\n$$ \\boldsymbol{K}_e = \\int_{-1}^{1}\\int_{-1}^{1} \\boldsymbol{B}(\\xi, \\eta)^{\\mathsf{T}} \\boldsymbol{C} \\boldsymbol{B}(\\xi, \\eta) \\det(\\boldsymbol{J}(\\xi, \\eta)) \\,\\mathrm{d}\\xi\\,\\mathrm{d}\\eta $$\nThe strain-displacement matrix $\\boldsymbol{B}$ is constructed from the physical gradients of the shape functions $N_i$. For node $i$, the contribution $\\boldsymbol{B}_i$ is $\\boldsymbol{B}_i = \\begin{bmatrix} \\partial N_i/\\partial x  0 \\\\ 0  \\partial N_i/\\partial y \\\\ \\partial N_i/\\partial y  \\partial N_i/\\partial x \\end{bmatrix}$. The full matrix is $\\boldsymbol{B} = [\\boldsymbol{B}_1, \\boldsymbol{B}_2, \\boldsymbol{B}_3, \\boldsymbol{B}_4]$. The physical gradients are found from parent-space gradients via the chain rule: $\\nabla_{\\boldsymbol{x}} N_i = \\boldsymbol{J}^{-1} \\nabla_{\\boldsymbol{\\xi}} N_i$.\n\nThis integral for $\\boldsymbol{K}_e$ is computed numerically using Gauss quadrature. The choice of quadrature rule is critical.\n1.  **Full Integration ($\\boldsymbol{K}_{\\mathrm{full}}$)**: A $2\\times 2$ Gauss rule is used. It has $4$ integration points $(\\xi_{gp}, \\eta_{gp})$ with weights $w_{gp}=1$. This order of integration is sufficient to exactly integrate the stiffness matrix for a rectangular or parallelogram element and provides the correct rank for general quadrilaterals, ensuring no spurious zero-energy modes. The matrix rank is $n_{dof} - n_{rbm} = 8 - 3 = 5$, where $n_{dof}$ is the number of degrees of freedom and $n_{rbm}$ is the number of rigid body modes. The null space of $\\boldsymbol{K}_{\\mathrm{full}}$ has dimension $3$ and is spanned by the rigid body modes.\n\n2.  **Reduced Integration ($\\boldsymbol{K}_{\\mathrm{red}}$)**: A single Gauss point at the element center $(\\xi, \\eta) = (0, 0)$ with weight $w=4$ is used. This is computationally efficient. However, the strain-displacement matrix $\\boldsymbol{B}(0,0)$ evaluated at this single point may not capture all possible deformation modes. Certain deformation patterns, known as hourglass modes, produce zero strain at the element center, i.e., $\\boldsymbol{B}(0,0)\\boldsymbol{u}_{hg} = \\boldsymbol{0}$ for an hourglass nodal displacement vector $\\boldsymbol{u}_{hg}$. Consequently, these modes have zero strain energy ($\\frac{1}{2}\\boldsymbol{u}_{hg}^{\\mathsf{T}}\\boldsymbol{K}_{\\mathrm{red}}\\boldsymbol{u}_{hg}=0$) and appear as additional vectors in the null space of $\\boldsymbol{K}_{\\mathrm{red}}$. The rank of $\\boldsymbol{K}_{\\mathrm{red}}$ is lower than $5$, leading to a rank-deficient and overly flexible element formulation that can be unstable in a global analysis. For a rectangular element, two such hourglass modes exist, so $\\mathrm{rank}(\\boldsymbol{K}_{\\mathrm{red}})=3$ and $\\mathrm{dim}(\\mathcal{N}(\\boldsymbol{K}_{\\mathrm{red}}))=5$. For a general parallelogram, one hourglass mode exists, so $\\mathrm{rank}(\\boldsymbol{K}_{\\mathrm{red}})=4$ and $\\mathrm{dim}(\\mathcal{N}(\\boldsymbol{K}_{\\mathrm{red}}))=4$.\n\n3.  **Reduced Integration with Enhancement ($\\boldsymbol{K}_{\\mathrm{red+enh}}$)**: To restore stability to the reduced integration element, a stabilization term $\\boldsymbol{K}_{\\mathrm{enh}}$ is added. This term must only penalize the spurious hourglass modes while leaving the rigid body modes and other valid deformations unaffected. This is achieved by defining a modified potential energy $\\Pi_{e, \\text{enh}} = \\Pi_{e, \\text{red}} + \\Pi_{e, \\text{stab}}$, where $\\Pi_{e, \\text{stab}}$ is a penalty energy associated with hourglass deformations. We define the hourglass subspace $\\mathcal{H}$ as the part of the null space of $\\boldsymbol{K}_{\\mathrm{red}}$ that is orthogonal to the rigid body subspace $\\mathcal{R}$, i.e., $\\mathcal{H} = \\mathcal{N}(\\boldsymbol{K}_{\\mathrm{red}}) \\ominus \\mathcal{R}$. Let $\\boldsymbol{H}$ be a matrix whose columns form an orthonormal basis for $\\mathcal{H}$. The hourglass penalty energy is defined as $\\Pi_{e, \\text{stab}} = \\frac{1}{2}\\beta \\| \\boldsymbol{H}^{\\mathsf{T}}\\boldsymbol{u}_e \\|_2^2 = \\frac{1}{2}\\beta \\boldsymbol{u}_e^{\\mathsf{T}}\\boldsymbol{H}\\boldsymbol{H}^{\\mathsf{T}}\\boldsymbol{u}_e$. Taking the second variation with respect to $\\boldsymbol{u}_e$ gives the stabilization stiffness $\\boldsymbol{K}_{\\mathrm{enh}} = \\beta \\boldsymbol{H}\\boldsymbol{H}^{\\mathsf{T}}$. The total stiffness is $\\boldsymbol{K}_{\\mathrm{red+enh}} = \\boldsymbol{K}_{\\mathrm{red}} + \\boldsymbol{K}_{\\mathrm{enh}}$. The stabilization parameter $\\beta$ is chosen based on material ($\\mu$) and geometric ($L$) properties to provide appropriate stiffness. Crucially, if $\\boldsymbol{u}_e$ is a rigid body mode, it is orthogonal to the columns of $\\boldsymbol{H}$, so $\\boldsymbol{H}^{\\mathsf{T}}\\boldsymbol{u}_e=\\boldsymbol{0}$ and no penalty is applied. If $\\boldsymbol{u}_e$ is an hourglass mode, it lies in the span of $\\boldsymbol{H}$, and the penalty term provides the necessary energy to prevent spurious behavior.\n\nThe algorithm to identify the hourglass basis $\\boldsymbol{H}$ proceeds as follows:\n- Find an orthonormal basis for the null space of $\\boldsymbol{K}_{\\mathrm{red}}$, denoted by the columns of matrix $\\boldsymbol{N}_{\\text{basis}}$.\n- Construct the rigid body modes $\\boldsymbol{r}_1, \\boldsymbol{r}_2, \\boldsymbol{r}_3$ and find an orthonormal basis for the space they span, $\\mathcal{R}$, denoted by the columns of $\\boldsymbol{R}_{\\text{basis}}$.\n- A vector $\\boldsymbol{v}$ is an hourglass mode if it is in $\\mathcal{N}(\\boldsymbol{K}_{\\mathrm{red}})$ and orthogonal to $\\mathcal{R}$. This means $\\boldsymbol{v} = \\boldsymbol{N}_{\\text{basis}}\\boldsymbol{c}$ for some coefficient vector $\\boldsymbol{c}$, and $\\boldsymbol{R}_{\\text{basis}}^{\\mathsf{T}}\\boldsymbol{v} = \\boldsymbol{0}$. This leads to the condition $(\\boldsymbol{R}_{\\text{basis}}^{\\mathsf{T}}\\boldsymbol{N}_{\\text{basis}})\\boldsymbol{c} = \\boldsymbol{0}$.\n- We solve for the null space of the matrix $(\\boldsymbol{R}_{\\text{basis}}^{\\mathsf{T}}\\boldsymbol{N}_{\\text{basis}})$ to find the admissible coefficients $\\boldsymbol{c}$. Let this null space basis be $\\boldsymbol{Z}$.\n- The orthonormal basis for the hourglass subspace is then $\\boldsymbol{H} = \\boldsymbol{N}_{\\text{basis}}\\boldsymbol{Z}$.\n\nThe final step is to diagnose the number of spurious modes, $n_{\\mathrm{spur}}$, for each stiffness matrix. We compute the eigenvalues $\\{\\lambda_i\\}$ of the matrix. The number of zero-energy modes, $n_0$, is the count of eigenvalues smaller than a numerical threshold $\\varepsilon$. Since a free element has $3$ physical zero-energy modes (the rigid body modes), the number of spurious modes is $n_{\\mathrm{spur}}=\\max(0, n_0-3)$. This procedure allows for a quantitative verification of the effectiveness of each integration and stabilization scheme.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import null_space, orth\n\nclass Q4Element:\n    \"\"\"\n    Represents a 4-node bilinear quadrilateral element in 2D elasticity.\n    \"\"\"\n    def __init__(self, nodes, E, nu):\n        \"\"\"\n        Initializes the element.\n        :param nodes: A list of 4 tuples, each with (x, y) coordinates of the nodes.\n        :param E: Young's modulus.\n        :param nu: Poisson's ratio.\n        \"\"\"\n        self.nodes = np.array(nodes)  # 4x2 array of (x,y) coords\n        if self.nodes.shape != (4, 2):\n            raise ValueError(\"Nodes must be a 4x2 array.\")\n        self.E = E\n        self.nu = nu\n        # Pre-compute the constitutive matrix for plane strain\n        self.C = self._get_constitutive_matrix()\n\n    def _get_constitutive_matrix(self):\n        \"\"\"Computes the plane strain constitutive matrix C.\"\"\"\n        factor = self.E / ((1 + self.nu) * (1 - 2 * self.nu))\n        C = factor * np.array([\n            [1 - self.nu, self.nu, 0],\n            [self.nu, 1 - self.nu, 0],\n            [0, 0, (1 - 2 * self.nu) / 2]\n        ])\n        return C\n\n    def get_shape_func_grads_parent(self, xi, eta):\n        \"\"\"Computes gradients of shape functions w.r.t. parent coordinates (xi, eta).\"\"\"\n        dN_dxi = 0.25 * np.array([-(1 - eta), (1 - eta), (1 + eta), -(1 + eta)])\n        dN_deta = 0.25 * np.array([-(1 - xi), -(1 + xi), (1 + xi), (1 - xi)])\n        return dN_dxi, dN_deta\n\n    def get_B_matrix_and_jacobian_det(self, xi, eta):\n        \"\"\"Computes the strain-displacement matrix B and Jacobian determinant.\"\"\"\n        dN_dxi, dN_deta = self.get_shape_func_grads_parent(xi, eta)\n\n        # Jacobian matrix J = [[dx/dxi, dy/dxi], [dx/deta, dy/deta]]\n        J = np.zeros((2, 2))\n        J[0, 0] = np.dot(dN_dxi, self.nodes[:, 0])  # dx/dxi\n        J[0, 1] = np.dot(dN_dxi, self.nodes[:, 1])  # dy/dxi\n        J[1, 0] = np.dot(dN_deta, self.nodes[:, 0]) # dx/deta\n        J[1, 1] = np.dot(dN_deta, self.nodes[:, 1]) # dy/deta\n        \n        detJ = np.linalg.det(J)\n        if detJ = 0:\n            raise ValueError(\"Jacobian determinant is non-positive, check node ordering.\")\n        \n        invJ = np.linalg.inv(J)\n\n        # Gradients of N w.r.t. physical coordinates (x, y)\n        dN_dxy = invJ @ np.vstack((dN_dxi, dN_deta))\n        dN_dx, dN_dy = dN_dxy[0, :], dN_dxy[1, :]\n\n        # Strain-displacement matrix B\n        B = np.zeros((3, 8))\n        for i in range(4):\n            B[0, 2 * i] = dN_dx[i]\n            B[1, 2 * i + 1] = dN_dy[i]\n            B[2, 2 * i] = dN_dy[i]\n            B[2, 2 * i + 1] = dN_dx[i]\n            \n        return B, detJ\n\n    def get_stiffness_matrix_reduced(self):\n        \"\"\"Computes the stiffness matrix using 1-point reduced integration.\"\"\"\n        xi, eta, w = 0.0, 0.0, 4.0\n        B, detJ = self.get_B_matrix_and_jacobian_det(xi, eta)\n        K = B.T @ self.C @ B * detJ * w\n        return K\n\n    def get_stiffness_matrix_full(self):\n        \"\"\"Computes the stiffness matrix using 2x2 full integration.\"\"\"\n        gp_coord = 1.0 / np.sqrt(3)\n        gauss_points = [(-gp_coord, -gp_coord), (gp_coord, -gp_coord),\n                        (gp_coord, gp_coord), (-gp_coord, gp_coord)]\n        weights = [1.0, 1.0, 1.0, 1.0]\n\n        K = np.zeros((8, 8))\n        for (xi, eta), w in zip(gauss_points, weights):\n            B, detJ = self.get_B_matrix_and_jacobian_det(xi, eta)\n            K += B.T @ self.C @ B * detJ * w\n        return K\n\n    def get_stiffness_matrix_enhanced(self):\n        \"\"\"Computes the stiffness matrix with reduced integration plus hourglass control.\"\"\"\n        K_red = self.get_stiffness_matrix_reduced()\n        \n        # 1. Find an orthonormal basis for the null space of K_red\n        N_basis = null_space(K_red)\n\n        # 2. Construct rigid body modes and find an orthonormal basis for their span\n        centroid = np.mean(self.nodes, axis=0)\n        nodes_c = self.nodes - centroid\n        \n        r1 = np.tile([1, 0], 4)\n        r2 = np.tile([0, 1], 4)\n        r3 = np.zeros(8)\n        for i in range(4):\n            r3[2*i] = -nodes_c[i, 1]\n            r3[2*i+1] = nodes_c[i, 0]\n            \n        R_matrix = np.vstack([r1, r2, r3]).T\n        R_basis = orth(R_matrix)\n        \n        # 3. Find hourglass subspace basis H\n        if N_basis.shape[1] > R_basis.shape[1]:\n            M = R_basis.T @ N_basis\n            Z = null_space(M)\n            H = N_basis @ Z\n        else:\n            # The null space of K_red only contains rigid body modes (or fewer).\n            return K_red\n\n        if H.shape[1] == 0:  # No non-rigid-body modes found in the null space\n            return K_red\n        \n        # 4. Calculate stabilization matrix K_enh\n        # Area A using shoelace formula\n        x, y = self.nodes[:, 0], self.nodes[:, 1]\n        A = 0.5 * np.abs(np.dot(x, np.roll(y, -1)) - np.dot(y, np.roll(x, -1)))\n        \n        L = np.sqrt(A)\n        mu = self.E / (2 * (1 + self.nu))\n        alpha = 1.0\n        beta = alpha * mu * L\n        \n        K_enh = beta * (H @ H.T)\n        \n        return K_red + K_enh\n\ndef count_spurious_modes(K):\n    \"\"\"\n    Counts spurious zero-energy modes from a stiffness matrix K.\n    A mode is considered zero-energy if its eigenvalue is close to zero.\n    There are 3 rigid-body modes, so any zero-energy modes beyond 3 are spurious.\n    \"\"\"\n    # Use eigvalsh for symmetric matrices for better performance and stability\n    eigenvalues = np.linalg.eigvalsh(K)\n    \n    if len(eigenvalues) == 0:\n        return 0\n        \n    lambda_max = np.max(np.abs(eigenvalues))\n    # Epsilon threshold as per problem specification\n    epsilon = max(1e-8, 1e-8 * lambda_max) if lambda_max > 0 else 1e-8\n    \n    # Count eigenvalues whose absolute value is less than the threshold\n    n0 = np.sum(np.abs(eigenvalues)  epsilon)\n    \n    # Number of spurious modes is the number of zero modes minus 3 rigid body modes\n    n_spur = max(0, n0 - 3)\n    return int(n_spur)\n\ndef solve():\n    # Define material properties and test geometries\n    E = 210e9\n    nu = 0.30\n\n    nodes_g1 = [(0, 0), (1, 0), (1, 1), (0, 1)]  # Square\n    nodes_g2 = [(0, 0), (2, 0), (2.2, 1), (0.2, 1)] # Distorted parallelogram\n\n    # Define test cases: (geometry_nodes, stiffness_matrix_method_name)\n    test_cases = [\n        (nodes_g1, 'reduced'),\n        (nodes_g1, 'enhanced'),\n        (nodes_g1, 'full'),\n        (nodes_g2, 'reduced'),\n        (nodes_g2, 'enhanced'),\n        (nodes_g2, 'full'),\n    ]\n\n    results = []\n    for nodes, method in test_cases:\n        element = Q4Element(nodes, E, nu)\n        \n        if method == 'reduced':\n            K = element.get_stiffness_matrix_reduced()\n        elif method == 'enhanced':\n            K = element.get_stiffness_matrix_enhanced()\n        elif method == 'full':\n            K = element.get_stiffness_matrix_full()\n        \n        n_spur = count_spurious_modes(K)\n        results.append(n_spur)\n\n    # Print the final results in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3573623"}]}