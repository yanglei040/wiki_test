{"hands_on_practices": [{"introduction": "Before we can control a numerical artifact, we must first be able to reliably detect it. This exercise challenges you to design a \"patch test\" specifically to reveal hourglassing, a spurious zero-energy mode that arises in under-integrated finite elements. You will discover why the standard patch test, which verifies an element's ability to reproduce constant strain, is blind to these modes, forcing a more targeted approach to excite and identify them [@problem_id:3602258]. This conceptual practice sharpens your understanding of what hourglass modes are by demonstrating their orthogonality to the linear fields that well-behaved elements are designed to capture.", "problem": "A square elastic patch of side length $2h$ is discretized into a $2 \\times 2$ mesh of bilinear quadrilateral ($Q4$) elements. The material is linear elastic, homogeneous, and isotropic in plane strain with Young’s modulus $E$ and Poisson’s ratio $\\nu$. Each $Q4$ element is integrated with a single Gauss point at its centroid ($1$-point reduced integration). Let the global Cartesian coordinates be $(x,y)$, and the patch nodes form a uniform $3 \\times 3$ grid at $(x_i,y_j)$ where $x_i = i h$, $y_j = j h$, and $i,j \\in \\{0,1,2\\}$.\n\nYou are asked to design a displacement-based patch test that reveals hourglass instabilities (spurious zero-energy modes) in this reduced-integration discretization, and to explain why the standard linear (affine) displacement patch test fails to detect them. Use as fundamental base: the definition of the small strain tensor $\\varepsilon = \\tfrac{1}{2}(\\nabla \\mathbf{u} + \\nabla \\mathbf{u}^{\\mathsf{T}})$, the principle of virtual work $\\int_{\\Omega} \\boldsymbol{\\sigma}:\\delta \\boldsymbol{\\varepsilon} \\, \\mathrm{d}\\Omega = \\int_{\\partial \\Omega_t} \\bar{\\mathbf{t}} \\cdot \\delta \\mathbf{u} \\, \\mathrm{d}\\Gamma$, the bilinear $Q4$ shape functions, and the fact that $1$-point quadrature samples strains and stresses at element centroids only. Assume a square element of side $h$ with standard isoparametric mapping $(\\xi,\\eta) \\mapsto (x,y)$, where the Jacobian is constant and diagonal with entries $h/2$ for a regular mesh.\n\nConsider the following candidate boundary displacement prescriptions and diagnostics intended to reveal hourglass instabilities. In all cases, unless otherwise stated, take $u_x$ and $u_y$ to be the prescribed components of displacement at the boundary nodes, and set any unspecified displacement component to zero. Let $\\Delta>0$ be a prescribed displacement amplitude. The interior node at $(h,h)$ is left free.\n\nWhich option correctly specifies a displacement-based patch test that will reveal hourglass instabilities in this $2 \\times 2$ patch and correctly explains why the standard linear field patch test fails to detect them?\n\nA. Prescribe an affine boundary displacement field $u_x = a x + b y$, $u_y = c x + d y$ with constants $a,b,c,d$, and verify pass/fail by checking whether the element-wise constant strain is reproduced at the single Gauss point. This detects hourglassing because any rank-deficiency will appear as an inability to reproduce the constant strain.\n\nB. Prescribe an alternating “checkerboard” boundary displacement $u_x(i,j) = \\Delta \\, (-1)^{i+j}$ and $u_y(i,j) = 0$ for all boundary nodes $(i,j)$, and diagnose hourglassing by the appearance of zero (or near-zero) reaction forces despite nonzero boundary work. This reveals hourglassing because, for each element, the nodal $u_x$ pattern $[+,-,+,-]$ around the element produces zero centroid strain (hence zero internal energy) under $1$-point quadrature, so the reduced-integration stiffness cannot resist this mode. The standard linear field test fails because the affine field induces a constant strain that is sampled exactly at the centroid, so the reduced-integration $Q4$ passes despite being hourglass-prone.\n\nC. Prescribe a rigid-body rotation on the boundary $u_x = -\\theta y$, $u_y = \\theta x$ with constant $\\theta$, and detect hourglassing by observing zero reaction forces. This reveals hourglassing because zero reaction under a nontrivial displacement means a zero-energy mode. The linear field test fails because it is insensitive to rotations.\n\nD. Prescribe an alternating boundary displacement only along the left and right edges as $u_x(i,j) = \\Delta \\, (-1)^i$ and $u_y(i,j) = 0$, while top and bottom edges are fully fixed, and diagnose hourglassing by nonuniqueness of the interior node displacement. This reveals hourglassing because the alternating pattern reduces the centroid strain to zero in each element. The linear field test fails for the same reason as in option B.\n\nSelect the single best option.", "solution": "The problem requires an evaluation of candidate displacement-based patch tests to identify one that correctly reveals hourglass instabilities in a $2 \\times 2$ mesh of bilinear quadrilateral ($Q4$) elements employing $1$-point reduced integration. The problem statement itself is scientifically sound, well-posed, and objective, providing a valid basis for analysis.\n\nFirst, we will establish the fundamental behavior of a $1$-point integrated $Q4$ element. The displacement field $\\mathbf{u}(\\xi, \\eta)$ within an element is interpolated from its four nodal displacements $\\mathbf{d}_e$ using bilinear shape functions, $N_I(\\xi, \\eta) = \\frac{1}{4}(1+\\xi_I\\xi)(1+\\eta_I\\eta)$, where $(\\xi, \\eta)$ are the parent coordinates in $[-1, 1] \\times [-1, 1]$, and $(\\xi_I, \\eta_I)$ are the coordinates of node $I$. For a square element of side $h$ in a regular grid, the Jacobian matrix of the isoparametric mapping is constant and diagonal, $\\mathbf{J} = \\mathrm{diag}(h/2, h/2)$.\n\nThe strain tensor components are computed from the spatial derivatives of the displacement field. For example, $\\varepsilon_{xx} = \\partial u_x / \\partial x$. Using the chain rule, we relate spatial derivatives to derivatives in the parent domain:\n$$ \\begin{Bmatrix} \\partial/\\partial x \\\\ \\partial/\\partial y \\end{Bmatrix} = \\mathbf{J}^{-1} \\begin{Bmatrix} \\partial/\\partial \\xi \\\\ \\partial/\\partial \\eta \\end{Bmatrix} = \\begin{bmatrix} 2/h & 0 \\\\ 0 & 2/h \\end{bmatrix} \\begin{Bmatrix} \\partial/\\partial \\xi \\\\ \\partial/\\partial \\eta \\end{Bmatrix} $$\nThe strain components are thus expressed in terms of nodal displacements $u_{xI}, u_{yI}$. With $1$-point quadrature, these strains are evaluated only at the element centroid, $(\\xi, \\eta) = (0,0)$. The derivatives of the shape functions at the centroid are:\n$$ \\frac{\\partial N_I}{\\partial \\xi}\\bigg|_{(0,0)} = \\frac{1}{4}\\xi_I \\quad \\text{and} \\quad \\frac{\\partial N_I}{\\partial \\eta}\\bigg|_{(0,0)} = \\frac{1}{4}\\eta_I $$\nLet the local nodes $I=1,2,3,4$ correspond to parent coordinates $(-1,-1), (1,-1), (1,1), (-1,1)$ respectively. The strain components at the centroid become:\n$$ \\varepsilon_{xx}|_{(0,0)} = \\sum_{I=1}^4 \\frac{\\partial N_I}{\\partial x}\\bigg|_{(0,0)} u_{xI} = \\frac{2}{h} \\sum_{I=1}^4 \\left(\\frac{1}{4}\\xi_I\\right) u_{xI} = \\frac{1}{2h}(-u_{x1} + u_{x2} + u_{x3} - u_{x4}) $$\n$$ \\varepsilon_{yy}|_{(0,0)} = \\sum_{I=1}^4 \\frac{\\partial N_I}{\\partial y}\\bigg|_{(0,0)} u_{yI} = \\frac{2}{h} \\sum_{I=1}^4 \\left(\\frac{1}{4}\\eta_I\\right) u_{yI} = \\frac{1}{2h}(-u_{y1} - u_{y2} + u_{y3} + u_{y4}) $$\n$$ \\gamma_{xy}|_{(0,0)} = \\sum_{I=1}^4 \\left( \\frac{\\partial N_I}{\\partial y}\\bigg|_{(0,0)} u_{xI} + \\frac{\\partial N_I}{\\partial x}\\bigg|_{(0,0)} u_{yI} \\right) = \\frac{1}{2h} [(-u_{x1}-u_{x2}+u_{x3}+u_{x4}) + (-u_{y1}+u_{y2}+u_{y3}-u_{y4})] $$\nA spurious zero-energy mode, or hourglass mode, is a non-rigid-body nodal displacement pattern that results in zero strain at the integration point. From the principle of virtual work, if the strain $\\boldsymbol{\\varepsilon}$ is zero, the stress $\\boldsymbol{\\sigma} = \\mathbf{C}\\boldsymbol{\\varepsilon}$ is also zero, leading to zero internal virtual work, $\\int_{\\Omega} \\boldsymbol{\\sigma}:\\delta \\boldsymbol{\\varepsilon} \\, \\mathrm{d}\\Omega = 0$. This implies that the element stiffness matrix has zero resistance to such a deformation mode.\n\nA classic hourglass mode involves displacements of the form $u_{xI} = \\Delta \\xi_I \\eta_I$ and $u_{yI} = 0$. For our nodal ordering, this corresponds to a displacement vector $\\{u_{x1}, u_{x2}, u_{x3}, u_{x4}\\} = \\{\\Delta, -\\Delta, \\Delta, -\\Delta\\}$. Substituting this into the strain equations:\n$$ \\varepsilon_{xx}|_{(0,0)} \\propto -(\\Delta) + (-\\Delta) + (\\Delta) - (-\\Delta) = 0 $$\n$$ \\gamma_{xy}|_{(0,0)} \\propto -(\\Delta) - (-\\Delta) + (\\Delta) + (-\\Delta) = 0 $$\nThe displacement pattern is a zero-energy mode. This mode is non-physical and is an artifact of the reduced integration scheme.\n\nThe standard patch test verifies an element's ability to reproduce a constant strain state exactly. This corresponds to applying boundary conditions derived from an affine displacement field $\\mathbf{u}(\\mathbf{x}) = \\mathbf{u}_0 + \\mathbf{A}\\mathbf{x}$. The bilinear $Q4$ element can represent any linear polynomial exactly. Thus, the strain field will be constant and exact throughout the element. Evaluating this strain at the centroid naturally yields the correct value. The element passes the test. This test, however, is blind to the hourglassing instability because the constant strain modes are mathematically orthogonal to the hourglassing modes, which are higher-order. A test designed to reveal hourglassing must specifically excite these higher-order modes.\n\nNow we evaluate the given options.\n\n**A. Prescribe an affine boundary displacement field $u_x = a x + b y$, $u_y = c x + d y$ with constants $a,b,c,d$, and verify pass/fail by checking whether the element-wise constant strain is reproduced at the single Gauss point. This detects hourglassing because any rank-deficiency will appear as an inability to reproduce the constant strain.**\n\nThis describes the standard linear displacement patch test. As explained above, the reduced-integration $Q4$ element *passes* this test. It correctly reproduces the constant strain state. The test's success demonstrates the element's ability to capture constant strain, but it completely fails to probe for hourglassing. The conclusion that this test detects hourglassing is factually incorrect. Therefore, this option is incorrect.\n\nVerdict: **Incorrect**.\n\n**B. Prescribe an alternating “checkerboard” boundary displacement $u_x(i,j) = \\Delta \\, (-1)^{i+j}$ and $u_y(i,j) = 0$ for all boundary nodes $(i,j)$, and diagnose hourglassing by the appearance of zero (or near-zero) reaction forces despite nonzero boundary work. This reveals hourglassing because, for each element, the nodal $u_x$ pattern $[+,-,+,-]$ around the element produces zero centroid strain (hence zero internal energy) under $1$-point quadrature, so the reduced-integration stiffness cannot resist this mode. The standard linear field test fails because the affine field induces a constant strain that is sampled exactly at the centroid, so the reduced-integration $Q4$ passes despite being hourglass-prone.**\n\nLet us analyze the prescribed displacement. The global nodes are at $(x_i, y_j)$ with $i,j \\in \\{0,1,2\\}$. The displacement $u_x(i,j) = \\Delta (-1)^{i+j}$ applied over the grid excites the hourglass mode in every element. For example, consider the bottom-left element with nodes at $(0,0), (1,0), (1,1), (0,1)$. If the free central node at $(1,1)$ displaces by $u_x(1,1) = \\Delta(-1)^{1+1} = \\Delta$, the element's nodal displacements in $u_x$, starting from node $(0,0)$ and moving counter-clockwise, are $\\{\\Delta, -\\Delta, \\Delta, -\\Delta\\}$. As demonstrated in the preliminary analysis, this specific pattern yields zero strain at the element centroid. This holds true for all four elements in the patch. With zero strain in every element, the stresses are zero, the internal energy is zero, and thus the nodal reaction forces computed from the element stresses are zero. A non-trivial prescribed displacement field that results in zero reaction forces signifies a zero-energy mode, which in this case is the spurious hourglass instability. The phrase \"nonzero boundary work\" is slightly imprecise; the work $\\int \\bar{\\mathbf{t}} \\cdot \\mathbf{u} \\, \\mathrm{d}\\Gamma$ is zero because the reactions $\\bar{\\mathbf{t}}$ are zero. The crucial diagnostic is zero reaction force for a nonzero prescribed displacement. The explanation for why this test works and why the standard linear patch test fails is entirely correct and consistent with finite element theory.\n\nVerdict: **Correct**.\n\n**C. Prescribe a rigid-body rotation on the boundary $u_x = -\\theta y$, $u_y = \\theta x$ with constant $\\theta$, and detect hourglassing by observing zero reaction forces. This reveals hourglassing because zero reaction under a nontrivial displacement means a zero-energy mode. The linear field test fails because it is insensitive to rotations.**\n\nA small rigid-body rotation, given by $u_x = -\\theta y$ and $u_y = \\theta x$, is a state of zero strain: $\\varepsilon_{xx} = 0$, $\\varepsilon_{yy} = 0$, $\\gamma_{xy} = \\partial u_x/\\partial y + \\partial u_y/\\partial x = -\\theta + \\theta = 0$. Any valid finite element formulation must produce zero strain and zero stress for any rigid-body motion. Therefore, observing zero reaction forces for a prescribed rigid-body rotation simply confirms that the element correctly handles physical rigid-body modes. It does not reveal a *spurious* mode like hourglassing. The statement conflates a physical zero-energy mode with a spurious one. Furthermore, the claim that the \"linear field test fails because it is insensitive to rotations\" is false; a rigid-body rotation is a specific case of an affine/linear field, and the element's ability to pass the patch test includes correctly representing such states of zero strain.\n\nVerdict: **Incorrect**.\n\n**D. Prescribe an alternating boundary displacement only along the left and right edges as $u_x(i,j) = \\Delta \\, (-1)^i$ and $u_y(i,j) = 0$, while top and bottom edges are fully fixed, and diagnose hourglassing by nonuniqueness of the interior node displacement. This reveals hourglassing because the alternating pattern reduces the centroid strain to zero in each element. The linear field test fails for the same reason as in option B.**\n\nThe specified boundary conditions are self-contradictory. The node at $(0,0)$ is on the left edge ($i=0$) and the bottom edge ($j=0$). The left-edge rule prescribes $u_x(0,0) = \\Delta(-1)^0 = \\Delta$, while the bottom-edge rule requires it to be fully fixed, i.e., $u_x(0,0)=0$. These conditions cannot be applied simultaneously. Furthermore, the prescription $u_x(i,j) = \\Delta(-1)^i$ for the left edge ($i=0$) means $u_x = \\Delta$ for all nodes on that edge, which is not an \"alternating\" pattern along the edge. The proposed test is ill-defined. Even if we attempt to reinterpret the intent, the description is too flawed to be considered correct.\n\nVerdict: **Incorrect**.\n\nBased on a rigorous analysis, Option B provides the only correct description of a patch test designed to reveal hourglassing, along with a correct explanation for its mechanism and for the failure of the standard linear patch test.", "answer": "$$\\boxed{B}$$", "id": "3602258"}, {"introduction": "After conceptually identifying hourglassing, the next step is to measure its presence in a practical simulation. This practice moves from a 2D conceptual test to a 3D solid element under a common engineering deformation, torsion, which is known to excite these spurious modes. You will programmatically apply a prescribed twist to a bar meshed with reduced-integration hexahedral elements and then implement the mathematical projection of the nodal displacements onto the known hourglass mode vectors to quantify the \"hourglass amplitude\". This provides direct, hands-on experience in calculating hourglassing from first principles and reveals the important, and sometimes non-intuitive, relationship between mesh geometry and the excitation of non-physical deformations [@problem_id:3602265].", "problem": "Consider the eight-node trilinear hexahedron (Hex8) with one-point (reduced) Gaussian integration in three-dimensional linear elasticity. Begin from the principle of virtual work: the internal virtual work is given by $\\delta W_{\\text{int}} = \\int_{\\Omega} \\boldsymbol{\\varepsilon}(\\mathbf{u}) : \\mathbb{C} : \\boldsymbol{\\varepsilon}(\\delta \\mathbf{u}) \\, dV$, where $\\boldsymbol{\\varepsilon}(\\mathbf{u})$ is the small-strain tensor, $\\mathbb{C}$ is the fourth-order elasticity tensor, and $\\Omega$ is the element domain. For a Hex8 element with one-point integration, the element stiffness matrix is approximated as $\\mathbf{K}_e \\approx \\mathbf{B}(\\xi_0,\\eta_0,\\zeta_0)^{\\top} \\mathbb{C} \\, \\mathbf{B}(\\xi_0,\\eta_0,\\zeta_0) \\, \\det \\mathbf{J}(\\xi_0,\\eta_0,\\zeta_0)$ evaluated at the single reduced integration point $(\\xi_0,\\eta_0,\\zeta_0) = (0,0,0)$. This approximation is rank-deficient for the Hex8 element and admits spurious zero-energy modes, commonly called hourglass modes, that produce zero strain at the integration point and hence cost no energy under the reduced integration rule. These spurious modes can be represented through nodal sign patterns defined on the reference element.\n\nDefine the reference parametric coordinates $(r,s,t)\\in\\{-1,+1\\}^3$ at the eight corner nodes of the hexahedron, ordered as follows: node $1$ at $(r,s,t)=(-1,-1,-1)$, node $2$ at $(+1,-1,-1)$, node $3$ at $(+1,+1,-1)$, node $4$ at $(-1,+1,-1)$, node $5$ at $(-1,-1,+1)$, node $6$ at $(+1,-1,+1)$, node $7$ at $(+1,+1,+1)$, and node $8$ at $(-1,+1,+1)$. Let $h_i^{(1)}=r_i$, $h_i^{(2)}=s_i$, $h_i^{(3)}=t_i$, and $h_i^{(4)}=r_i s_i t_i$ denote the canonical hourglass shape patterns (for $i=1,\\dots,8$ and modes $\\alpha=1,\\dots,4$). For a given element with nodal displacement components $u_i^{(a)}$ in Cartesian direction $a\\in\\{x,y,z\\}$, define the hourglass amplitude in mode $\\alpha$ and direction $a$ by the discrete projection\n$$\nq_{e}^{(\\alpha,a)} = \\frac{1}{8} \\sum_{i=1}^{8} h_i^{(\\alpha)} \\, u_i^{(a)}.\n$$\nThis $q_{e}^{(\\alpha,a)}$ is a measure of how strongly the element’s nodal displacement pattern excites the corresponding spurious zero-energy mode under one-point integration.\n\nNow consider a straight prismatic bar of length $L$ aligned with the global $Z$-axis, with rectangular cross-section of widths $W_x$ and $W_y$ along the global $X$- and $Y$-axes, respectively. The bar is clamped at $Z=0$ and twisted by a small end rotation $\\Theta$ at $Z=L$. Adopt the small-twist kinematics that rigidly rotates each cross-section by an angle $\\theta(Z)=\\Theta \\, Z / L$ about the $Z$-axis. In Cartesian coordinates, the imposed displacement field is\n$$\nu_x(X,Y,Z) = -\\theta(Z) \\, Y = -\\frac{\\Theta}{L} \\, Z \\, Y,\\quad\nu_y(X,Y,Z) = \\theta(Z) \\, X = \\frac{\\Theta}{L} \\, Z \\, X,\\quad\nu_z(X,Y,Z) = 0.\n$$\n\nDiscretize the bar by a structured mesh of Hex8 elements, $N_x \\times N_y \\times N_z$ in the $X$-, $Y$-, and $Z$-directions, respectively. To vary the mesh orientation with respect to the global axes, rotate each element’s local in-plane axes by an angle $\\beta$ about the $Z$-axis, so that local directions $\\mathbf{e}_1$ and $\\mathbf{e}_2$ are obtained by rotating the global $(X,Y)$ axes by $\\beta$, and $\\mathbf{e}_3$ remains aligned with $Z$. Within each element, assume an affine mapping from $(r,s,t)\\in[-1,1]^3$ to the global coordinates:\n$$\n\\mathbf{x}(r,s,t) = \\mathbf{x}_c + \\mathbf{R}_z(\\beta) \\begin{bmatrix} \\frac{h_x}{2} r \\\\ \\frac{h_y}{2} s \\\\ \\frac{h_z}{2} t \\end{bmatrix},\n$$\nwhere $\\mathbf{x}_c$ is the element center in global coordinates, $h_x=W_x/N_x$, $h_y=W_y/N_y$, $h_z=L/N_z$, and $\\mathbf{R}_z(\\beta)$ is the standard rotation matrix about $Z$ by angle $\\beta$.\n\nFor each element, compute the nodal positions at the eight corners by substituting $(r_i,s_i,t_i)$ and then evaluate the imposed twist displacement $(u_x,u_y,u_z)$ at those nodal coordinates. Using the definitions above, compute $q_{e}^{(\\alpha,a)}$ for $\\alpha\\in\\{1,2,3,4\\}$ and $a\\in\\{x,y,z\\}$. As a scalar summary per mesh, define the maximum absolute hourglass amplitude\n$$\nQ_{\\max} = \\max_{e} \\max_{\\alpha\\in\\{1,2,3,4\\}} \\max_{a\\in\\{x,y,z\\}} \\left| q_{e}^{(\\alpha,a)} \\right|.\n$$\nThis $Q_{\\max}$ has the unit of length. Your task is to compute $Q_{\\max}$ for a set of parameterized test cases that vary mesh orientation $\\beta$, twist angle $\\Theta$, and element aspect ratios through $(N_x,N_y,N_z)$.\n\nYou must implement a program that performs the following steps from first principles:\n- Create the structured mesh element centers $\\mathbf{x}_c$ covering $X\\in[-W_x/2,W_x/2]$, $Y\\in[-W_y/2,W_y/2]$, $Z\\in[0,L]$, with $N_x$, $N_y$, $N_z$ elements.\n- For each element, generate its eight nodal coordinates using the affine mapping with rotation $\\beta$ and sizes $(h_x,h_y,h_z)$.\n- Evaluate the imposed displacement field at each node.\n- Compute the four hourglass mode amplitudes $q_{e}^{(\\alpha,a)}$ per element and the scalar $Q_{\\max}$ over the entire mesh.\n\nAll physical quantities use the International System of Units. Specifically:\n- All lengths $L$, $W_x$, $W_y$ must be given in meters, and the output $Q_{\\max}$ must be reported in meters.\n- The angle $\\Theta$ must be given in radians.\n- The mesh orientation angle $\\beta$ must be given in degrees in the input parameter sets and internally converted to radians for computation.\n\nTest Suite:\nCompute $Q_{\\max}$ for the following four test cases. Each case is an ordered tuple $(L,W_x,W_y,N_x,N_y,N_z,\\Theta,\\beta)$ with the units and conventions specified above.\n- Case $1$: $(L,W_x,W_y,N_x,N_y,N_z,\\Theta,\\beta) = (2.0, 1.0, 0.6, 2, 1, 4, 0.1, 0.0)$.\n- Case $2$: $(L,W_x,W_y,N_x,N_y,N_z,\\Theta,\\beta) = (2.0, 1.0, 0.6, 2, 1, 4, 0.1, 45.0)$.\n- Case $3$: $(L,W_x,W_y,N_x,N_y,N_z,\\Theta,\\beta) = (2.0, 1.0, 0.6, 4, 1, 2, 0.1, 0.0)$.\n- Case $4$: $(L,W_x,W_y,N_x,N_y,N_z,\\Theta,\\beta) = (2.0, 1.0, 0.6, 2, 1, 4, 1.0\\times 10^{-6}, 30.0)$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the values of $Q_{\\max}$ for the four cases, in meters, each formatted with exactly $10$ digits after the decimal point, as a comma-separated list enclosed in square brackets. For example, an acceptable output format is $[0.1234567890,0.2345678901,0.3456789012,0.4567890123]$. No additional text should be printed.", "solution": "The user has provided a valid, well-posed problem in computational solid mechanics. The task is to compute the maximum hourglass amplitude, denoted $Q_{\\max}$, for several discretizations of a prismatic bar under torsion. The solution requires a direct, numerical implementation of the provided formulas, proceeding from first principles as laid out in the problem statement. The following steps detail the procedure for calculating $Q_{\\max}$ for a single test case.\n\nThe first step is to establish the geometric and kinematic parameters for a given test case, which is defined by the tuple $(L, W_x, W_y, N_x, N_y, N_z, \\Theta, \\beta_{\\text{deg}})$. The physical dimensions of the bar are length $L$, width $W_x$, and depth $W_y$. It is discretized into a structured mesh of $N_x \\times N_y \\times N_z$ hexahedral elements. The dimensions of each element are $h_x = W_x / N_x$, $h_y = W_y / N_y$, and $h_z = L / N_z$. The total twist angle is $\\Theta$, and the element orientation angle $\\beta$ is obtained by converting $\\beta_{\\text{deg}}$ from degrees to radians.\n\nThe core of the computation involves iterating over every element in the mesh. The domain of the bar is centered in the $X$-$Y$ plane, spanning $X \\in [-W_x/2, W_x/2]$ and $Y \\in [-W_y/2, W_y/2]$, and extends along the $Z$-axis from $Z=0$ to $Z=L$. The center of an element, indexed by $(i,j,k)$ where $i \\in \\{0, \\dots, N_x-1\\}$, $j \\in \\{0, \\dots, N_y-1\\}$, and $k \\in \\{0, \\dots, N_z-1\\}$, is located at global coordinates $\\mathbf{x}_c = [X_c, Y_c, Z_c]^{\\top}$, calculated as:\n$$\nX_c = -\\frac{W_x}{2} + (i + 0.5) h_x\n$$\n$$\nY_c = -\\frac{W_y}{2} + (j + 0.5) h_y\n$$\n$$\nZ_c = (k + 0.5) h_z\n$$\nFor each element, we must determine the global coordinates of its eight nodes. The problem specifies an affine mapping from the reference element domain $(r,s,t) \\in [-1,1]^3$ to the global coordinate system $\\mathbf{x}$:\n$$\n\\mathbf{x}(r,s,t) = \\mathbf{x}_c + \\mathbf{R}_z(\\beta) \\begin{bmatrix} \\frac{h_x}{2} r \\\\ \\frac{h_y}{2} s \\\\ \\frac{h_z}{2} t \\end{bmatrix}\n$$\nwhere $\\mathbf{R}_z(\\beta)$ is the standard rotation matrix about the $Z$-axis:\n$$\n\\mathbf{R}_z(\\beta) = \\begin{bmatrix} \\cos\\beta & -\\sin\\beta & 0 \\\\ \\sin\\beta & \\cos\\beta & 0 \\\\ 0 & 0 & 1 \\end{bmatrix}\n$$\nThe coordinates of the eight nodes, $\\mathbf{x}_i = [X_i, Y_i, Z_i]^{\\top}$ for $i=1,\\dots,8$, are found by substituting the parametric coordinates $(r_i, s_i, t_i)$ corresponding to each node into the mapping function. The nodal ordering and their parametric coordinates $(r_i, s_i, t_i)$ are given as: $1:(-1,-1,-1)$, $2:(+1,-1,-1)$, $3:(+1,+1,-1)$, $4:(-1,+1,-1)$, $5:(-1,-1,+1)$, $6:(+1,-1,+1)$, $7:(+1,+1,+1)$, $8:(-1,+1,+1)$.\n\nOnce the global coordinates $(X_i, Y_i, Z_i)$ for each of the eight nodes are known, the imposed displacement field is evaluated at these locations. The displacement field for small-angle twist is:\n$$\nu_x(X,Y,Z) = -\\frac{\\Theta}{L} Z Y, \\quad u_y(X,Y,Z) = \\frac{\\Theta}{L} Z X, \\quad u_z(X,Y,Z) = 0\n$$\nSubstituting the nodal coordinates $(X_i, Y_i, Z_i)$ yields the nodal displacement components $(u_i^{(x)}, u_i^{(y)}, u_i^{(z)})$.\n\nWith the nodal displacements for an element calculated, the next step is to compute the hourglass mode amplitudes. These amplitudes, $q_{e}^{(\\alpha,a)}$, measure the projection of the element's deformation onto the spurious zero-energy modes. The formula provided is:\n$$\nq_{e}^{(\\alpha,a)} = \\frac{1}{8} \\sum_{i=1}^{8} h_i^{(\\alpha)} \\, u_i^{(a)}\n$$\nThis calculation is performed for each of the four hourglass modes $\\alpha \\in \\{1,2,3,4\\}$ and for each Cartesian direction $a \\in \\{x,y,z\\}$. The hourglass shape patterns, $h_i^{(\\alpha)}$, are defined based on the nodal parametric coordinates: $h_i^{(1)}=r_i$, $h_i^{(2)}=s_i$, $h_i^{(3)}=t_i$, and $h_i^{(4)}=r_i s_i t_i$. This results in a total of $4 \\times 3 = 12$ hourglass amplitudes for each element.\n\nFinally, the overall metric $Q_{\\max}$ is determined by finding the maximum absolute value among all computed hourglass amplitudes across all elements in the mesh:\n$$\nQ_{\\max} = \\max_{e} \\max_{\\alpha\\in\\{1,2,3,4\\}} \\max_{a\\in\\{x,y,z\\}} |q_{e}^{(\\alpha,a)}|\n$$\nThis process is repeated for each of the test cases specified in the problem, and the resulting values of $Q_{\\max}$ are collected. The implementation will use matrix and vector operations for efficiency, particularly for calculating nodal coordinates and the sum-products in the hourglass amplitude formula.", "answer": "```python\nimport numpy as np\n\ndef calculate_q_max(L, Wx, Wy, Nx, Ny, Nz, Theta, beta_deg):\n    \"\"\"\n    Computes the maximum absolute hourglass amplitude Q_max for a given set of parameters.\n    \"\"\"\n    # 1. Define constants and derived parameters\n    hx = Wx / Nx\n    hy = Wy / Ny\n    hz = L / Nz\n    beta_rad = np.deg2rad(beta_deg)\n    k0 = Theta / L\n\n    # 2. Pre-compute helper matrices\n    # Nodal parametric coordinates based on the specified ordering\n    r = np.array([-1, 1, 1, -1, -1, 1, 1, -1])\n    s = np.array([-1, -1, 1, 1, -1, -1, 1, 1])\n    t = np.array([-1, -1, -1, -1, 1, 1, 1, 1])\n\n    # Hourglass shape pattern vectors h_i^(alpha)\n    h1 = r\n    h2 = s\n    h3 = t\n    h4 = r * s * t\n    H = np.array([h1, h2, h3, h4])  # Shape (4, 8)\n\n    # Rotation matrix R_z(beta)\n    c, s_rot = np.cos(beta_rad), np.sin(beta_rad)\n    Rz = np.array([[c, -s_rot, 0], [s_rot, c, 0], [0, 0, 1]])\n\n    # Vector of local coordinates for the 8 nodes relative to the element center\n    nodes_local_coords = 0.5 * np.array([hx * r, hy * s, hz * t]) # Shape (3, 8)\n\n    global_q_max = 0.0\n\n    # 3. Iterate over all elements in the structured mesh\n    for i in range(Nx):\n        for j in range(Ny):\n            for k in range(Nz):\n                # 3.1. Calculate element center coordinates\n                Xc = -Wx / 2 + (i + 0.5) * hx\n                Yc = -Wy / 2 + (j + 0.5) * hy\n                Zc = (k + 0.5) * hz\n                elem_center = np.array([Xc, Yc, Zc])\n\n                # 3.2. Generate global coordinates for the 8 nodes of the element\n                # Use broadcasting: (3,1) + (3,3) @ (3,8) -> (3,8)\n                nodes_global_coords = elem_center[:, np.newaxis] + Rz @ nodes_local_coords\n                X_nodes = nodes_global_coords[0, :]\n                Y_nodes = nodes_global_coords[1, :]\n                Z_nodes = nodes_global_coords[2, :]\n\n                # 3.3. Evaluate the imposed displacement field at each node\n                ux_nodes = -k0 * Z_nodes * Y_nodes\n                uy_nodes = k0 * Z_nodes * X_nodes\n                uz_nodes = np.zeros(8)\n                U = np.array([ux_nodes, uy_nodes, uz_nodes]) # Shape (3, 8)\n\n                # 3.4. Compute the hourglass mode amplitudes for the element\n                # Q_e (4,3) = (1/8) * H(4,8) @ U.T(8,3)\n                Q_e = (1.0 / 8.0) * H @ U.T\n\n                # 3.5. Update the global maximum absolute amplitude\n                elem_q_max = np.max(np.abs(Q_e))\n                if elem_q_max > global_q_max:\n                    global_q_max = elem_q_max\n\n    return global_q_max\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    \"\"\"\n    # Test suite: (L, Wx, Wy, Nx, Ny, Nz, Theta, beta_deg)\n    test_cases = [\n        (2.0, 1.0, 0.6, 2, 1, 4, 0.1, 0.0),\n        (2.0, 1.0, 0.6, 2, 1, 4, 0.1, 45.0),\n        (2.0, 1.0, 0.6, 4, 1, 2, 0.1, 0.0),\n        (2.0, 1.0, 0.6, 2, 1, 4, 1.0e-6, 30.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        L, Wx, Wy, Nx, Ny, Nz, Theta, beta_deg = case\n        q_max_result = calculate_q_max(L, Wx, Wy, Nx, Ny, Nz, Theta, beta_deg)\n        results.append(f\"{q_max_result:.10f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3602265"}, {"introduction": "Having learned to identify and quantify hourglassing, the final and most critical step is to implement and evaluate control schemes designed to suppress it. This capstone practice provides a comprehensive look at the practical side of hourglass stabilization, requiring you to implement two classic control algorithms and assess their performance using both static and dynamic metrics. By varying the control parameter $\\alpha$, you will directly confront the fundamental trade-off in numerical methods: adding enough stiffness to control spurious modes without adding so much that the element becomes overly stiff, or \"locks,\" thereby corrupting the physical solution. This exercise demonstrates that hourglass control is not a simple \"fix\" but a careful balancing act that impacts both stress accuracy and dynamic wave propagation speed [@problem_id:3602193].", "problem": "Consider a two-dimensional, linearly elastic, homogeneous rectangular strip of length $L$, height $H$, thickness $t$, mass density $\\rho$, Young's modulus $E$, and Poisson's ratio $\\nu$, modeled under plane stress. The strip is discretized using four-node bilinear quadrilateral elements (denoted $Q_4$) with one-point (reduced) integration at the element center. Reduced integration in $Q_4$ elements is known to admit spurious zero-energy modes (hourglassing), which can corrupt both stress predictions and propagating wave characteristics in explicit dynamics.\n\nThe fundamental base for this problem is the principle of virtual work and the standard small-strain, linearized kinematics and constitutive law. The discrete internal elastic forces follow from the bilinear form\n$$\n\\mathbf{K} = \\sum_{e} \\int_{\\Omega_e} \\mathbf{B}^T \\mathbf{D} \\mathbf{B}\\, t \\, \\mathrm{d}\\Omega,\n$$\nwhere $e$ indexes elements, $\\mathbf{B}$ is the strain-displacement matrix at the quadrature point, $\\mathbf{D}$ is the plane stress constitutive matrix,\n$$\n\\mathbf{D} = \\frac{E}{1-\\nu^2}\n\\begin{bmatrix}\n1 & \\nu & 0 \\\\\n\\nu & 1 & 0 \\\\\n0 & 0 & \\frac{1-\\nu}{2}\n\\end{bmatrix},\n$$\nand $t$ is the thickness. The one-point integration approximates the integral by evaluating $\\mathbf{B}$ and $\\mathbf{D}$ at the element center and multiplying by the physical element area; mass is assembled as a lumped matrix\n$$\n\\mathbf{M} = \\sum_{e} \\rho \\, t \\, A_e \\, \\mathbf{M}_e^{\\text{lumped}},\n$$\nwith $A_e$ the in-plane area of element $e$ and appropriate per-node mass sharing.\n\nTo mitigate hourglassing, add an artificial hourglass control stiffness $\\mathbf{K}_{\\text{hg}}$ to each element. You will implement and compare two distinct algorithms, each parameterized by a non-dimensional control coefficient $\\alpha$ scaled by the material shear modulus $\\mu = \\dfrac{E}{2(1+\\nu)}$ and the thickness $t$:\n\n1. A Wilkins-style pattern control using two linearly independent nodal pattern vectors on the four nodes of a $Q_4$ element,\n   $$\n   \\mathbf{q}_1 = \\begin{bmatrix} 1 & -1 & 1 & -1 \\end{bmatrix}^T,\\quad\n   \\mathbf{q}_2 = \\begin{bmatrix} 1 & 1 & -1 & -1 \\end{bmatrix}^T,\n   $$\n   applied independently to the $u$- and $v$-components of nodal displacement, with stiffness scale $c = \\alpha \\, \\mu \\, t$.\n\n2. A Flanagan–Belytschko-style gradient-based control using constant hourglass vectors defined by the derivatives of bilinear shape functions at the element center,\n   $$\n   \\boldsymbol{\\gamma}_{\\xi} = \\frac{1}{2}\\begin{bmatrix} -1 & 1 & 1 & -1 \\end{bmatrix}^T,\\quad\n   \\boldsymbol{\\gamma}_{\\eta} = \\frac{1}{2}\\begin{bmatrix} -1 & -1 & 1 & 1 \\end{bmatrix}^T,\n   $$\n   applied independently to the $u$- and $v$-components, again with stiffness scale $c = \\alpha \\, \\mu \\, t$.\n\nThese artificial stiffnesses penalize discrete patterns that do not contribute to the strain at the center and should therefore suppress the spurious zero-energy modes; however, overly strong control can artificially stiffen the physical modes and distort stress and wave speed.\n\nYour program must:\n\n- Assemble the global stiffness $\\mathbf{K}_{\\text{tot}} = \\mathbf{K} + \\mathbf{K}_{\\text{hg}}$ and lumped mass $\\mathbf{M}$ for a mesh of $N_x \\times N_y$ elements covering the rectangle $[0,L] \\times [0,H]$.\n\n- Quantify the stress error under a uniform kinematic boundary condition: prescribe a uniform axial strain by setting the boundary nodal displacements to $u(x,y) = \\varepsilon_0 x$, $v(x,y) = 0$, with $\\varepsilon_0$ constant, solve for interior nodal displacements, and compute the average axial stress $\\overline{\\sigma}_{xx}$ over all elements using the center-point strains. The reference stress is $\\sigma_{xx}^{\\text{ref}} = E \\, \\varepsilon_0$. Report the relative stress error\n  $$\n  e_{\\sigma} = \\left| \\frac{\\overline{\\sigma}_{xx} - E \\varepsilon_0}{E \\varepsilon_0} \\right|.\n  $$\n\n- Quantify the wave speed error by solving the constrained generalized eigenproblem for longitudinal vibration with fixed ends: fix all degrees of freedom on the planes $x=0$ and $x=L$ to zero, leave the top and bottom free, and solve\n  $$\n  \\mathbf{K}_{\\text{tot,ff}} \\boldsymbol{\\phi} = \\lambda \\, \\mathbf{M}_{\\text{ff}} \\boldsymbol{\\phi},\n  $$\n  on the remaining free degrees of freedom. Extract the smallest positive eigenvalue $\\lambda_{\\min}$ (ignoring any non-positive or near-zero values). With strip length $L$, estimate the numerical wave speed via the first-mode relation $c_{\\text{num}} = \\dfrac{\\sqrt{\\lambda_{\\min}} \\, L}{\\pi}$, and compare to the continuum extensional wave speed $c_0 = \\sqrt{\\dfrac{E}{\\rho}}$ for an axially dominated mode in plane stress. Report the relative wave speed error\n  $$\n  e_c = \\left| \\frac{c_{\\text{num}} - c_0}{c_0} \\right|.\n  $$\n\n- Diagnose hourglass control strength regimes:\n  - Declare control \"too weak\" if the smallest eigenvalue of the constrained static stiffness matrix $\\mathbf{K}_{\\text{tot,ff}}$ satisfies $\\lambda_{\\min}^{K} < \\tau_K$, where $\\tau_K$ is a small tolerance scale tied to material stiffness; in this problem, use $\\tau_K = 10^{-9} \\, E \\, t$.\n  - Declare control \"too strong\" if either $e_c > \\tau_c$ or $e_{\\sigma} > \\tau_{\\sigma}$; in this problem, use $\\tau_c = 0.10$ and $\\tau_{\\sigma} = 0.05$.\n\nUse the following physical and numerical parameters, expressed in the required units:\n\n- $L = 1.0$ m, $H = 0.2$ m, $t = 0.01$ m.\n- $E = 70\\times 10^9$ Pa, $\\nu = 0.30$, $\\rho = 2700$ kg/m$^3$.\n- $\\varepsilon_0 = 0.001$ (dimensionless).\n- Mesh resolution $N_x = 10$, $N_y = 2$.\n\nImplement the two hourglass control algorithms described above and compare across the following test suite of $(\\text{algorithm}, \\alpha)$ pairs:\n\n- $[\\text{\"none\"}, 0.0]$ (no hourglass control),\n- $[\\text{\"wilkins\"}, 0.01]$,\n- $[\\text{\"wilkins\"}, 0.05]$,\n- $[\\text{\"wilkins\"}, 0.50]$,\n- $[\\text{\"fb\"}, 0.01]$,\n- $[\\text{\"fb\"}, 0.05]$,\n- $[\\text{\"fb\"}, 0.50]$.\n\nFor each test, compute the list $[e_{\\sigma}, e_c, \\text{weak}, \\text{strong}]$, where $e_{\\sigma}$ is a float, $e_c$ is a float, $\\text{weak}$ is a boolean, and $\\text{strong}$ is a boolean. Angle units do not apply. Express stress in pascals (Pa) internally; the final errors $e_{\\sigma}$ and $e_c$ are dimensionless.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case result is itself a sublist in the same order as above. For example, the output format must be\n`[\\,[e_{\\sigma}^{(1)}, e_c^{(1)}, \\text{weak}^{(1)}, \\text{strong}^{(1)}], \\ldots, [e_{\\sigma}^{(7)}, e_c^{(7)}, \\text{weak}^{(7)}, \\text{strong}^{(7)}]\\,].`", "solution": "The user-provided problem statement has been analyzed and found to be valid. The problem is scientifically grounded in computational solid mechanics, well-posed, objective, and contains sufficient information for a unique solution. The methodologies described—finite element analysis with reduced integration, hourglass control schemes, static analysis for stress accuracy, and eigenvalue analysis for wave propagation—are standard and correctly formulated. The provided parameters and test cases are clear and computationally feasible. The solution proceeds as follows.\n\n### 1. Finite Element Formulation\n\nThe core of the solution is a finite element (FE) model of a two-dimensional rectangular domain under plane stress conditions. The domain is discretized into a structured mesh of $N_x \\times N_y$ four-node bilinear quadrilateral ($Q_4$) elements. Each node possesses two degrees of freedom (DOFs), representing displacements in the $x$ and $y$ directions.\n\n**Element-Level Matrices:**\nFor each element $e$, we compute the stiffness matrix $\\mathbf{K}_e$, the lumped mass matrix $\\mathbf{M}_e$, and the hourglass control stiffness matrix $\\mathbf{K}_{\\text{hg},e}$.\n\nThe element stiffness matrix $\\mathbf{K}_e$ is calculated using one-point quadrature, meaning the integrand is evaluated only at the element's isoparametric center $(\\xi, \\eta) = (0, 0)$.\n$$\n\\mathbf{K}_e = (\\mathbf{B}^T \\mathbf{D} \\mathbf{B})_{(\\xi=0, \\eta=0)} \\cdot A_e \\cdot t\n$$\nwhere $A_e$ is the element area, $t$ is the thickness, $\\mathbf{D}$ is the plane stress constitutive matrix, and $\\mathbf{B}$ is the strain-displacement matrix. For a rectangular element of size $\\Delta x \\times \\Delta y$, the $\\mathbf{B}$ matrix evaluated at the center is constant and depends only on $\\Delta x$ and $\\Delta y$.\n\nThe element lumped mass matrix $\\mathbf{M}_e$ is a diagonal matrix. The total mass of the element, $m_e = \\rho A_e t$, is distributed equally among its four nodes. Each node is assigned a mass of $m_e/4$ for each of its two DOFs.\n\nThe hourglass stiffness matrix $\\mathbf{K}_{\\text{hg},e}$ is added to counteract the spurious zero-energy modes introduced by reduced integration. Its form depends on the chosen algorithm. For both Wilkins and Flanagan-Belytschko (FB) methods as specified, the element hourglass stiffness is constructed from given pattern vectors. Let $\\mathbf{p}_1$ and $\\mathbf{p}_2$ be the two characteristic vectors for a given method (e.g., for Wilkins, $\\mathbf{p}_1 = \\mathbf{q}_1$ and $\\mathbf{p}_2 = \\mathbf{q}_2$). The anti-hourglass stiffness for one displacement component (e.g., $u$) is given by $\\mathbf{Q} = c_e (\\mathbf{p}_1 \\mathbf{p}_1^T + \\mathbf{p}_2 \\mathbf{p}_2^T)$, where $c_e$ is the stiffness scale. The full $8 \\times 8$ element hourglass matrix $\\mathbf{K}_{\\text{hg},e}$ applies this stiffness block independently to both $u$ and $v$ displacements. The stiffness scale is given as $c_e = \\alpha \\mu t$, where $\\alpha$ is the dimensionless control coefficient and $\\mu = E / (2(1+\\nu))$ is the shear modulus.\n\n**Global Assembly:**\nThe global stiffness matrix $\\mathbf{K}_{\\text{tot}}$ and mass matrix $\\mathbf{M}$ are assembled by summing the contributions from all elements.\n$$\n\\mathbf{K}_{\\text{tot}} = \\sum_e (\\mathbf{K}_e + \\mathbf{K}_{\\text{hg},e})\n\\qquad\n\\mathbf{M} = \\sum_e \\mathbf{M}_e\n$$\nA standard assembly procedure maps local element DOFs to their corresponding global DOF indices.\n\n### 2. Static Analysis for Stress Error ($e_{\\sigma}$)\n\nThis analysis quantifies how well the model reproduces a state of uniform stress.\n1.  **Boundary Conditions (BCs):** Nodal displacements on the entire boundary of the rectangle ($x=0, x=L, y=0, y=H$) are prescribed to match a uniform strain field: $u(x,y) = \\varepsilon_0 x$ and $v(x,y) = 0$.\n2.  **System Partitioning:** The global system of equations $\\mathbf{K}_{\\text{tot}} \\mathbf{d} = \\mathbf{f}$ is partitioned into parts corresponding to interior (unknown) and boundary (known) DOFs. This yields $\\mathbf{K}_{\\text{ii}} \\mathbf{d}_{\\text{i}} = -\\mathbf{K}_{\\text{ib}} \\mathbf{d}_{\\text{b}}$, where 'i' denotes interior and 'b' denotes boundary.\n3.  **Solution:** The system is solved for the interior displacements $\\mathbf{d}_{\\text{i}}$. For the case with no hourglass control ($\\alpha = 0$), the matrix $\\mathbf{K}_{\\text{ii}}$ may be singular. A least-squares solver is used to find the minimum-norm solution, which is robust in such cases.\n4.  **Stress Calculation:** With the full displacement vector $\\mathbf{d}$ (both prescribed and solved parts), the strain $\\boldsymbol{\\epsilon}_e = \\mathbf{B} \\mathbf{d}_e$ and stress $\\boldsymbol{\\sigma}_e = \\mathbf{D} \\boldsymbol{\\epsilon}_e$ are computed at the center of each element.\n5.  **Error Calculation:** The average axial stress $\\overline{\\sigma}_{xx}$ across all elements is computed. The relative error is then $e_{\\sigma} = | (\\overline{\\sigma}_{xx} / \\sigma_{xx}^{\\text{ref}}) - 1 |$, with the reference stress being $\\sigma_{xx}^{\\text{ref}} = E \\varepsilon_0$.\n\n### 3. Eigenvalue Analysis for Wave Speed Error ($e_c$)\n\nThis analysis assesses the effect of hourglass control on the dynamic properties of the mesh, specifically the speed of longitudinal waves.\n1.  **Boundary Conditions (BCs):** All DOFs for nodes on the planes $x=0$ and $x=L$ are fixed (constrained to zero). All other DOFs are free.\n2.  **System Partitioning:** The global matrices $\\mathbf{K}_{\\text{tot}}$ and $\\mathbf{M}$ are reduced to only the free DOFs, yielding $\\mathbf{K}_{\\text{ff}}$ and $\\mathbf{M}_{\\text{ff}}$.\n3.  **Eigenproblem solution:** The generalized eigenvalue problem $\\mathbf{K}_{\\text{ff}} \\boldsymbol{\\phi} = \\lambda \\mathbf{M}_{\\text{ff}} \\boldsymbol{\\phi}$ is solved. The eigenvalues $\\lambda$ correspond to the squared natural frequencies ($\\omega^2$) of the free system.\n4.  **Wave Speed Calculation:** The smallest strictly positive eigenvalue, $\\lambda_{\\min}$, is identified. This corresponds to the fundamental mode of vibration. The numerical wave speed is estimated using the formula for a 1D rod: $c_{\\text{num}} = \\sqrt{\\lambda_{\\min}} L / \\pi$.\n5.  **Error Calculation:** This numerical speed is compared to the theoretical 1D extensional wave speed, $c_0 = \\sqrt{E/\\rho}$. The relative error is $e_c = | (c_{\\text{num}} / c_0) - 1 |$.\n\n### 4. Diagnosis of Control Strength\n\nFinally, the implemented hourglass control for each parameter set is diagnosed as \"too weak\" or \"too strong\" based on the following criteria.\n*   **\"Too weak\":** The control is insufficient if the constrained stiffness matrix $\\mathbf{K}_{\\text{ff}}$ is nearly singular, which indicates the presence of barely-resisted zero-energy modes. This is checked by computing the smallest eigenvalue of $\\mathbf{K}_{\\text{ff}}$, denoted $\\lambda_{\\min}^K$. If $\\lambda_{\\min}^K < \\tau_K = 10^{-9} E t$, the `weak` flag is set to `True`.\n*   **\"Too strong\":** The control is excessive if it unacceptably pollutes the physical response. This is diagnosed by checking if either the stress error or the wave speed error exceeds predefined tolerances. If $e_{\\sigma} > \\tau_{\\sigma} = 0.05$ or $e_c > \\tau_c = 0.10$, the `strong` flag is set to `True`.\n\nThis entire procedure is repeated for each of the seven test cases specified in the problem statement. The results are then collected and formatted into the required output.", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import eigh, eigvalsh\n\ndef solve():\n    # --- PHYSICAL AND NUMERICAL PARAMETERS ---\n    L = 1.0  # m\n    H = 0.2  # m\n    t = 0.01  # m\n    E = 70.0e9  # Pa\n    nu = 0.30\n    rho = 2700.0  # kg/m^3\n    eps0 = 0.001\n\n    # --- MESH PARAMETERS ---\n    Nx = 10\n    Ny = 2\n\n    # --- DIAGNOSIS TOLERANCES ---\n    tau_K = 1.0e-9 * E * t\n    tau_c = 0.10\n    tau_sigma = 0.05\n\n    # --- TEST CASES ---\n    test_cases = [\n        (\"none\", 0.0),\n        (\"wilkins\", 0.01),\n        (\"wilkins\", 0.05),\n        (\"wilkins\", 0.50),\n        (\"fb\", 0.01),\n        (\"fb\", 0.05),\n        (\"fb\", 0.50),\n    ]\n\n    def run_single_case(algorithm, alpha):\n        # --- DERIVED PARAMETERS ---\n        mu = E / (2.0 * (1.0 + nu))\n        c_hg = alpha * mu * t\n        \n        # Plane stress constitutive matrix D\n        D_factor = E / (1.0 - nu**2)\n        D = D_factor * np.array([\n            [1.0, nu, 0.0],\n            [nu, 1.0, 0.0],\n            [0.0, 0.0, (1.0 - nu) / 2.0]\n        ])\n\n        # --- MESH GENERATION ---\n        num_nodes_x = Nx + 1\n        num_nodes_y = Ny + 1\n        num_nodes = num_nodes_x * num_nodes_y\n        num_dofs = 2 * num_nodes\n        \n        dx = L / Nx\n        dy = H / Ny\n        A_e = dx * dy\n\n        node_coords = np.zeros((num_nodes, 2))\n        for i in range(num_nodes_x):\n            for j in range(num_nodes_y):\n                node_id = i * num_nodes_y + j\n                node_coords[node_id] = [i * dx, j * dy]\n\n        elements = np.zeros((Nx * Ny, 4), dtype=int)\n        for i in range(Nx):\n            for j in range(Ny):\n                el_id = i * Ny + j\n                n1 = i * num_nodes_y + j\n                n2 = (i + 1) * num_nodes_y + j\n                n3 = (i + 1) * num_nodes_y + (j + 1)\n                n4 = i * num_nodes_y + (j + 1)\n                elements[el_id] = [n1, n2, n3, n4]\n\n        # --- ELEMENT-LEVEL MATRICES (CONSTANT FOR UNIFORM MESH) ---\n        # Strain-displacement matrix B at element center\n        dN_dxi = 0.25 * np.array([-1, 1, 1, -1])\n        dN_deta = 0.25 * np.array([-1, -1, 1, 1])\n        J_inv = np.array([[2.0 / dx, 0.0], [0.0, 2.0 / dy]])\n        dN_dxy = J_inv @ np.vstack([dN_dxi, dN_deta])\n        dN_dx = dN_dxy[0, :]\n        dN_dy = dN_dxy[1, :]\n        \n        B = np.zeros((3, 8))\n        for i in range(4):\n            B[0, 2 * i] = dN_dx[i]\n            B[1, 2 * i + 1] = dN_dy[i]\n            B[2, 2 * i] = dN_dy[i]\n            B[2, 2 * i + 1] = dN_dx[i]\n\n        Ke = B.T @ D @ B * A_e * t\n\n        # Lumped mass matrix\n        m_node = rho * A_e * t / 4.0\n        Me = np.diag([m_node] * 8)\n\n        # Hourglass stiffness matrix\n        K_hg_e = np.zeros((8, 8))\n        if algorithm != \"none\":\n            if algorithm == \"wilkins\":\n                p1 = np.array([1, -1, 1, -1])\n                p2 = np.array([1, 1, -1, -1])\n            elif algorithm == \"fb\":\n                p1 = 0.5 * np.array([-1, 1, 1, -1])\n                p2 = 0.5 * np.array([-1, -1, 1, 1])\n            else:\n                raise ValueError(\"Unknown algorithm\")\n            \n            Q = p1[:, None] @ p1[None, :] + p2[:, None] @ p2[None, :]\n            K_hg_u = c_hg * Q\n            K_hg_e[0::2, 0::2] = K_hg_u\n            K_hg_e[1::2, 1::2] = K_hg_u\n\n        # --- ASSEMBLY ---\n        K_tot = np.zeros((num_dofs, num_dofs))\n        M = np.zeros((num_dofs, num_dofs))\n        for el_nodes in elements:\n            dof_map = np.empty(8, dtype=int)\n            for i in range(4):\n                dof_map[2 * i] = 2 * el_nodes[i]\n                dof_map[2 * i + 1] = 2 * el_nodes[i] + 1\n            \n            ix = np.ix_(dof_map, dof_map)\n            K_tot[ix] += Ke + K_hg_e\n            M[ix] += Me\n\n        # --- STRESS ERROR ANALYSIS ---\n        is_boundary_node = np.zeros(num_nodes, dtype=bool)\n        tol = 1e-9\n        is_boundary_node[node_coords[:, 0] < tol] = True\n        is_boundary_node[node_coords[:, 0] > L - tol] = True\n        is_boundary_node[node_coords[:, 1] < tol] = True\n        is_boundary_node[node_coords[:, 1] > H - tol] = True\n        \n        boundary_dofs = np.where(np.repeat(is_boundary_node, 2))[0]\n        interior_dofs = np.where(np.logical_not(np.repeat(is_boundary_node, 2)))[0]\n\n        d_b = np.zeros(len(boundary_dofs))\n        boundary_nodes = np.where(is_boundary_node)[0]\n        for i, b_dof in enumerate(boundary_dofs):\n            node_idx = b_dof // 2\n            coord = b_dof % 2\n            if coord == 0: # u-dof\n                d_b[i] = eps0 * node_coords[node_idx, 0]\n            # v-dof is 0\n\n        K_ii = K_tot[np.ix_(interior_dofs, interior_dofs)]\n        K_ib = K_tot[np.ix_(interior_dofs, boundary_dofs)]\n        \n        f_i = -K_ib @ d_b\n        \n        if algorithm == \"none\": # Use least squares for potentially singular matrix\n            d_i, _, _, _ = np.linalg.lstsq(K_ii, f_i, rcond=None)\n        else:\n            d_i = np.linalg.solve(K_ii, f_i)\n        \n        d = np.zeros(num_dofs)\n        d[boundary_dofs] = d_b\n        d[interior_dofs] = d_i\n\n        stresses = []\n        for el_nodes in elements:\n            el_dofs = np.empty(8, dtype=int)\n            for i in range(4):\n                el_dofs[2*i] = 2*el_nodes[i]\n                el_dofs[2*i+1] = 2*el_nodes[i]+1\n            d_e = d[el_dofs]\n            strain_e = B @ d_e\n            stress_e = D @ strain_e\n            stresses.append(stress_e[0]) # sigma_xx\n        \n        avg_sigma_xx = np.mean(stresses)\n        ref_sigma_xx = E * eps0\n        e_sigma = np.abs(avg_sigma_xx / ref_sigma_xx - 1.0)\n        \n        # --- WAVE SPEED ERROR ANALYSIS ---\n        is_fixed_node = (node_coords[:, 0] < tol) | (node_coords[:, 0] > L - tol)\n        fixed_dofs = np.where(np.repeat(is_fixed_node, 2))[0]\n        free_dofs = np.setdiff1d(np.arange(num_dofs), fixed_dofs)\n        \n        K_ff = K_tot[np.ix_(free_dofs, free_dofs)]\n        M_ff = M[np.ix_(free_dofs, free_dofs)]\n\n        eigvals = eigh(K_ff, M_ff, eigvals_only=True)\n        lambda_min = eigvals[eigvals > 1e-6]\n        if len(lambda_min) > 0:\n            lambda_min = lambda_min[0]\n            c_num = np.sqrt(lambda_min) * L / np.pi\n            c0 = np.sqrt(E / rho)\n            e_c = np.abs(c_num / c0 - 1.0)\n        else:\n            e_c = np.inf # No positive eigenvalue found\n\n        # --- DIAGNOSIS ---\n        eigvals_K = eigvalsh(K_ff)\n        lambda_min_K = eigvals_K[0] if len(eigvals_K) > 0 else 0.0\n        \n        is_weak = lambda_min_K < tau_K\n        is_strong = (e_c > tau_c) or (e_sigma > tau_sigma)\n        \n        return [e_sigma, e_c, is_weak, is_strong]\n\n    results = []\n    for algorithm, alpha in test_cases:\n        res = run_single_case(algorithm, alpha)\n        results.append(res)\n    \n    # --- FORMATTING OUTPUT ---\n    def format_val(v):\n        if isinstance(v, bool):\n            return str(v).lower()\n        return f\"{v:.6g}\"\n\n    result_str = \",\".join(\n        f'[{\",\".join(map(format_val, case))}]' for case in results\n    )\n    print(f\"[{result_str}]\")\n\n\nsolve()\n```", "id": "3602193"}]}