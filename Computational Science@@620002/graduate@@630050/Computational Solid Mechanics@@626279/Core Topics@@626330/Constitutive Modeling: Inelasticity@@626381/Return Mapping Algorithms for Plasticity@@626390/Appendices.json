{"hands_on_practices": [{"introduction": "To build a solid foundation, our first practice starts with the cornerstone of rate-independent plasticity: the $J_2$ flow theory. This exercise guides you through the fundamental elastic-predictor, plastic-corrector scheme for a simple shear loading scenario. By deriving a closed-form analytical solution [@problem_id:3596324], you will gain a clear and intuitive understanding of how a trial stress state violating the yield condition is \"returned\" to the yield surface, laying the groundwork for more complex numerical implementations.", "problem": "Consider a homogeneous, small-strain simple shear of an isotropic elastoplastic solid obeying the second invariant of the deviatoric stress ($J_2$) yield criterion with associative flow and linear isotropic hardening. The elastic response is linear with shear modulus $G$, and the hardening is characterized by a constant tangent modulus $H$. The initial yield stress is $\\sigma_{y0}$, and the initial state at time $t_n$ is stress-free and plastically undeformed. Over a single large time step of duration $\\Delta t$, impose a uniform engineering shear strain increment $\\Delta \\gamma \\ge 0$ in the $1$-$2$ plane (simple shear), with zero normal strain. \n\nStarting only from the following fundamentals:\n- Small-strain kinematics, including the relation between engineering shear strain and tensorial shear strain.\n- Linear isotropic elasticity with shear modulus $G$.\n- The definition of the $J_2$ yield function $f = q - \\sigma_{y}$, where $q$ is the von Mises equivalent stress and $\\sigma_{y} = \\sigma_{y0} + H \\varepsilon_{p}^{\\mathrm{eq}}$ is the current yield stress with equivalent plastic strain $\\varepsilon_{p}^{\\mathrm{eq}}$.\n- Associative flow with normality to the yield surface, and the backward-Euler (implicit) integration over the time step.\n- The definition $q = \\sqrt{\\frac{3}{2} \\boldsymbol{s}:\\boldsymbol{s}}$ and $\\varepsilon_{p}^{\\mathrm{eq}}$ satisfying $d\\varepsilon_{p}^{\\mathrm{eq}} = \\sqrt{\\frac{2}{3}} \\| d\\boldsymbol{\\varepsilon}_{p}^{\\mathrm{dev}} \\|$.\n\nDerive a closed-form update for the shear stress component $\\sigma_{12,n+1}$ after the step, expressed in terms of $G$, $H$, $\\sigma_{y0}$, and $\\Delta \\gamma$. Then validate that the same expression is obtained by directly solving the backward-Euler return-mapping equations as a numerical integration over the large step $\\Delta t$ (i.e., performing the implicit update in one step without substepping).\n\nYour final answer must be a single closed-form analytic expression for $\\sigma_{12,n+1}$ in terms of $G$, $H$, $\\sigma_{y0}$, and $\\Delta \\gamma$. Do not include units in your final boxed answer. If your expression is piecewise, you may write it as a single expression using a minimum operator.", "solution": "The problem statement is evaluated as valid. It presents a well-posed, scientifically grounded problem in computational solid mechanics, specifically concerning the application of return mapping algorithms for $J_2$ plasticity. The givens are complete, consistent, and objectively stated.\n\nThe task is to derive a closed-form expression for the shear stress component $\\sigma_{12,n+1}$ after a single step of simple shear, starting from a stress-free and plastically undeformed state. We will employ the standard elastic predictor/plastic corrector algorithm, which represents a direct solution of the backward-Euler integration of the constitutive equations over the time step $\\Delta t$.\n\nFirst, we define the kinematics. A simple engineering shear strain increment $\\Delta \\gamma$ in the $1$-$2$ plane, with zero normal strains, corresponds to a total strain increment tensor $\\Delta\\boldsymbol{\\varepsilon}$ given by:\n$$\n\\Delta\\boldsymbol{\\varepsilon} = \\begin{pmatrix} 0  \\frac{1}{2}\\Delta\\gamma  0 \\\\ \\frac{1}{2}\\Delta\\gamma  0  0 \\\\ 0  0  0 \\end{pmatrix}\n$$\nThe trace of $\\Delta\\boldsymbol{\\varepsilon}$ is zero, so the deformation is isochoric. The strain increment is purely deviatoric, i.e., $\\Delta\\boldsymbol{\\varepsilon} = \\Delta\\boldsymbol{\\varepsilon}^{\\mathrm{dev}}$.\n\nThe solution procedure follows the return mapping algorithm:\n\n1.  **Elastic Predictor:** We first assume the entire strain increment $\\Delta\\boldsymbol{\\varepsilon}$ is accommodated elastically. The trial stress state at time $t_{n+1}$ is computed. Since the initial state is stress-free ($\\boldsymbol{\\sigma}_n = \\boldsymbol{0}$), we have:\n    $$\n    \\boldsymbol{\\sigma}_{n+1}^{\\mathrm{trial}} = \\boldsymbol{C} : \\Delta\\boldsymbol{\\varepsilon}\n    $$\n    For linear isotropic elasticity and a deviatoric strain increment, the stress increment is given by $\\Delta\\boldsymbol{\\sigma} = 2G \\Delta\\boldsymbol{\\varepsilon}^{\\mathrm{dev}}$. Thus, the only non-zero component of the trial stress is:\n    $$\n    \\sigma_{12,n+1}^{\\mathrm{trial}} = 2G \\Delta\\varepsilon_{12} = 2G \\left(\\frac{1}{2}\\Delta\\gamma\\right) = G\\Delta\\gamma\n    $$\n    The trial stress tensor is purely deviatoric, so $\\boldsymbol{s}_{n+1}^{\\mathrm{trial}} = \\boldsymbol{\\sigma}_{n+1}^{\\mathrm{trial}}$.\n\n2.  **Yield Check:** We check if this trial stress state violates the yield condition. The yield function is $f = q - \\sigma_y$. At the beginning of the step, the material is plastically undeformed, so the yield stress is the initial yield stress, $\\sigma_y = \\sigma_{y0}$. We evaluate the von Mises equivalent stress for the trial state, $q_{n+1}^{\\mathrm{trial}}$:\n    $$\n    q_{n+1}^{\\mathrm{trial}} = \\sqrt{\\frac{3}{2} \\boldsymbol{s}_{n+1}^{\\mathrm{trial}} : \\boldsymbol{s}_{n+1}^{\\mathrm{trial}}} = \\sqrt{\\frac{3}{2} \\left( (\\sigma_{12,n+1}^{\\mathrm{trial}})^2 + (\\sigma_{21,n+1}^{\\mathrm{trial}})^2 \\right)} = \\sqrt{\\frac{3}{2} \\left( (G\\Delta\\gamma)^2 + (G\\Delta\\gamma)^2 \\right)}\n    $$\n    $$\n    q_{n+1}^{\\mathrm{trial}} = \\sqrt{\\frac{3}{2} (2 G^2 \\Delta\\gamma^2)} = \\sqrt{3} G |\\Delta\\gamma|\n    $$\n    Since the problem specifies $\\Delta\\gamma \\ge 0$, we have $q_{n+1}^{\\mathrm{trial}} = \\sqrt{3} G \\Delta\\gamma$.\n    The trial yield function value is $f^{\\mathrm{trial}} = q_{n+1}^{\\mathrm{trial}} - \\sigma_{y0}$.\n\n    - If $f^{\\mathrm{trial}} \\le 0$, i.e., $\\sqrt{3} G \\Delta\\gamma \\le \\sigma_{y0}$, the trial state is admissible. The step is purely elastic. The final stress is the trial stress:\n      $$\n      \\sigma_{12,n+1} = \\sigma_{12,n+1}^{\\mathrm{trial}} = G\\Delta\\gamma \\quad \\text{if } \\Delta\\gamma \\le \\frac{\\sigma_{y0}}{G\\sqrt{3}}\n      $$\n\n    - If $f^{\\mathrm{trial}} > 0$, i.e., $\\sqrt{3} G \\Delta\\gamma > \\sigma_{y0}$, the trial state is outside the yield surface. Plastic flow occurs, and a plastic correction is necessary.\n\n3.  **Plastic Corrector (Return Mapping):** For a plastic step, the final state $(\\boldsymbol{\\sigma}_{n+1}, \\varepsilon_{p,n+1}^{\\mathrm{eq}})$ must satisfy the integrated constitutive relations and the yield condition. The backward-Euler scheme implies:\n    - Additive decomposition: $\\Delta\\boldsymbol{\\varepsilon} = \\Delta\\boldsymbol{\\varepsilon}_e + \\Delta\\boldsymbol{\\varepsilon}_p$.\n    - Elastic law: $\\boldsymbol{\\sigma}_{n+1} = \\boldsymbol{C}:\\Delta\\boldsymbol{\\varepsilon}_e$.\n    - Flow rule (associative): $\\Delta\\boldsymbol{\\varepsilon}_p = \\Delta\\lambda \\frac{\\partial f}{\\partial \\boldsymbol{\\sigma}}\\Big|_{\\boldsymbol{\\sigma}_{n+1}} = \\Delta\\lambda \\frac{3}{2q_{n+1}} \\boldsymbol{s}_{n+1}$, where $\\Delta\\lambda$ is the consistency parameter.\n    - Hardening law: $\\varepsilon_{p,n+1}^{\\mathrm{eq}} = \\varepsilon_{p,n}^{\\mathrm{eq}} + \\Delta\\varepsilon_{p}^{\\mathrm{eq}}$. Given $\\varepsilon_{p,n}^{\\mathrm{eq}}=0$, we have $\\varepsilon_{p,n+1}^{\\mathrm{eq}} = \\Delta\\varepsilon_{p}^{\\mathrm{eq}}$. The rate form $d\\varepsilon_{p}^{\\mathrm{eq}} = \\sqrt{\\frac{2}{3} d\\boldsymbol{\\varepsilon}_p:d\\boldsymbol{\\varepsilon}_p}$ integrated over the step gives $\\Delta\\varepsilon_{p}^{\\mathrm{eq}} = \\Delta\\lambda$.\n    - Consistency condition: $f_{n+1} = q_{n+1} - (\\sigma_{y0} + H \\varepsilon_{p,n+1}^{\\mathrm{eq}}) = 0 \\implies q_{n+1} = \\sigma_{y0} + H \\Delta\\lambda$.\n\n    Combining these equations, we derive the return mapping. The final stress is related to the trial stress:\n    $$\n    \\boldsymbol{\\sigma}_{n+1} = \\boldsymbol{\\sigma}_{n+1}^{\\mathrm{trial}} - \\boldsymbol{C}:\\Delta\\boldsymbol{\\varepsilon}_p\n    $$\n    For the deviatoric components:\n    $$\n    \\boldsymbol{s}_{n+1} = \\boldsymbol{s}_{n+1}^{\\mathrm{trial}} - 2G \\Delta\\boldsymbol{\\varepsilon}_p = \\boldsymbol{s}_{n+1}^{\\mathrm{trial}} - 2G \\left(\\Delta\\lambda \\frac{3}{2q_{n+1}} \\boldsymbol{s}_{n+1}\\right) = \\boldsymbol{s}_{n+1}^{\\mathrm{trial}} - \\frac{3G\\Delta\\lambda}{q_{n+1}} \\boldsymbol{s}_{n+1}\n    $$\n    Rearranging gives $\\boldsymbol{s}_{n+1} \\left(1 + \\frac{3G\\Delta\\lambda}{q_{n+1}}\\right) = \\boldsymbol{s}_{n+1}^{\\mathrm{trial}}$. This shows that $\\boldsymbol{s}_{n+1}$ is coaxial with $\\boldsymbol{s}_{n+1}^{\\mathrm{trial}}$, which is the principle of radial return. We can write $\\boldsymbol{s}_{n+1} = k \\boldsymbol{s}_{n+1}^{\\mathrm{trial}}$ for some scalar $k$, which implies $q_{n+1} = k q_{n+1}^{\\mathrm{trial}}$.\n    The magnitude of the deviatoric stress is found by taking the norm of the rearranged equation:\n    $$\n    q_{n+1} = q_{n+1}^{\\mathrm{trial}} - 3G\\Delta\\lambda\n    $$\n    We now have a system of two algebraic equations for $\\Delta\\lambda$ and $q_{n+1}$:\n    1.  $q_{n+1} = q_{n+1}^{\\mathrm{trial}} - 3G\\Delta\\lambda$\n    2.  $q_{n+1} = \\sigma_{y0} + H\\Delta\\lambda$\n    Equating the two expressions for $q_{n+1}$:\n    $$\n    q_{n+1}^{\\mathrm{trial}} - 3G\\Delta\\lambda = \\sigma_{y0} + H\\Delta\\lambda \\implies q_{n+1}^{\\mathrm{trial}} - \\sigma_{y0} = (3G+H)\\Delta\\lambda\n    $$\n    Solving for the plastic multiplier $\\Delta\\lambda$:\n    $$\n    \\Delta\\lambda = \\frac{q_{n+1}^{\\mathrm{trial}} - \\sigma_{y0}}{3G+H}\n    $$\n    Since we are in the plastic case, $q_{n+1}^{\\mathrm{trial}} > \\sigma_{y0}$, so $\\Delta\\lambda > 0$.\n    Now we find the final stress. The final deviatoric stress is a radial scaling of the trial deviatoric stress:\n    $$\n    \\boldsymbol{s}_{n+1} = \\frac{q_{n+1}}{q_{n+1}^{\\mathrm{trial}}} \\boldsymbol{s}_{n+1}^{\\mathrm{trial}}\n    $$\n    Substituting $\\Delta\\lambda$ into the consistency condition to find $q_{n+1}$:\n    $$\n    q_{n+1} = \\sigma_{y0} + H \\left(\\frac{q_{n+1}^{\\mathrm{trial}} - \\sigma_{y0}}{3G+H}\\right) = \\frac{\\sigma_{y0}(3G+H) + H(q_{n+1}^{\\mathrm{trial}} - \\sigma_{y0})}{3G+H} = \\frac{3G\\sigma_{y0} + H q_{n+1}^{\\mathrm{trial}}}{3G+H}\n    $$\n    Thus, the final deviatoric stress tensor is:\n    $$\n    \\boldsymbol{s}_{n+1} = \\left(\\frac{3G\\sigma_{y0} + H q_{n+1}^{\\mathrm{trial}}}{(3G+H)q_{n+1}^{\\mathrm{trial}}}\\right) \\boldsymbol{s}_{n+1}^{\\mathrm{trial}}\n    $$\n    We need the component $\\sigma_{12,n+1}$. Since the deformation is isochoric, $\\sigma_{12,n+1} = s_{12,n+1}$.\n    $$\n    \\sigma_{12,n+1} = \\left(\\frac{3G\\sigma_{y0} + H q_{n+1}^{\\mathrm{trial}}}{(3G+H)q_{n+1}^{\\mathrm{trial}}}\\right) \\sigma_{12,n+1}^{\\mathrm{trial}}\n    $$\n    Substituting $\\sigma_{12,n+1}^{\\mathrm{trial}} = G\\Delta\\gamma$ and $q_{n+1}^{\\mathrm{trial}} = \\sqrt{3}G\\Delta\\gamma$:\n    $$\n    \\sigma_{12,n+1} = \\left(\\frac{3G\\sigma_{y0} + H (\\sqrt{3}G\\Delta\\gamma)}{(3G+H)(\\sqrt{3}G\\Delta\\gamma)}\\right) (G\\Delta\\gamma) = \\frac{3G\\sigma_{y0} + \\sqrt{3}GH\\Delta\\gamma}{\\sqrt{3}(3G+H)}\n    $$\n    $$\n    \\sigma_{12,n+1} = \\frac{\\sqrt{3}G\\sigma_{y0}}{3G+H} + \\frac{GH\\Delta\\gamma}{3G+H} \\quad \\text{if } \\Delta\\gamma > \\frac{\\sigma_{y0}}{G\\sqrt{3}}\n    $$\n\n4.  **Combined Expression:** We can combine the elastic and elastoplastic solutions into a single expression. Let $f(\\Delta\\gamma) = G\\Delta\\gamma$ be the elastic solution and $g(\\Delta\\gamma) = \\frac{GH\\Delta\\gamma + \\sqrt{3}G\\sigma_{y0}}{3G+H}$ be the plastic solution.\n    We analyze the difference $f(\\Delta\\gamma) - g(\\Delta\\gamma)$:\n    $$\n    G\\Delta\\gamma - \\frac{GH\\Delta\\gamma + \\sqrt{3}G\\sigma_{y0}}{3G+H} = \\frac{G\\Delta\\gamma(3G+H) - (GH\\Delta\\gamma + \\sqrt{3}G\\sigma_{y0})}{3G+H} = \\frac{3G^2\\Delta\\gamma - \\sqrt{3}G\\sigma_{y0}}{3G+H} = \\frac{\\sqrt{3}G}{3G+H}(\\sqrt{3}G\\Delta\\gamma - \\sigma_{y0})\n    $$\n    - If $\\Delta\\gamma \\le \\frac{\\sigma_{y0}}{G\\sqrt{3}}$, then $f(\\Delta\\gamma) \\le g(\\Delta\\gamma)$, and the correct solution is the elastic one, $f(\\Delta\\gamma)$.\n    - If $\\Delta\\gamma > \\frac{\\sigma_{y0}}{G\\sqrt{3}}$, then $f(\\Delta\\gamma) > g(\\Delta\\gamma)$, and the correct solution is the plastic one, $g(\\Delta\\gamma)$.\n    This logic corresponds precisely to the minimum operator. The final stress is the smaller of the two values:\n    $$\n    \\sigma_{12,n+1} = \\min\\left( G\\Delta\\gamma, \\frac{GH\\Delta\\gamma + \\sqrt{3}G\\sigma_{y0}}{3G+H} \\right)\n    $$\n    This single expression encapsulates the elastic predictor and the plastic corrector (radial return) for this one-dimensional problem, correctly transitioning from the elastic to the plastic regime. This expression can be slightly rearranged for compactness:\n    $$\n    \\sigma_{12,n+1} = \\min\\left( G\\Delta\\gamma, \\frac{G(H\\Delta\\gamma + \\sqrt{3}\\sigma_{y0})}{3G+H} \\right)\n    $$\n\nThis derivation confirms that directly solving the backward-Euler return mapping equations for a single large time step yields the provided closed-form solution.", "answer": "$$\n\\boxed{\\min\\left( G\\Delta\\gamma, \\frac{G(H\\Delta\\gamma + \\sqrt{3}\\sigma_{y0})}{3G+H} \\right)}\n$$", "id": "3596324"}, {"introduction": "Having mastered the basic return mapping for a smooth yield surface, we now introduce a common geometric complexity: an apex. This practice explores the Drucker-Prager model, whose conical yield surface is fundamental for modeling frictional materials like soils and concrete. You will develop the critical branching logic required to handle the singularity at the cone's apex [@problem_id:3596281], a crucial skill for implementing robust algorithms for a wide class of pressure-sensitive materials.", "problem": "Consider a small-strain elastoplastic solid obeying linear isotropic elasticity with bulk modulus $K$ and shear modulus $G$, and a Drucker–Prager yield function $f(\\boldsymbol{\\sigma}) = q + \\alpha p - k \\le 0$, where $p = \\frac{1}{3}\\mathrm{tr}(\\boldsymbol{\\sigma})$ is the mean (hydrostatic) stress taken positive in compression, $q = \\sqrt{\\frac{3}{2}\\boldsymbol{s}:\\boldsymbol{s}}$ is the von Mises equivalent stress with $\\boldsymbol{s}$ the deviatoric stress, $\\alpha > 0$ is a material parameter linked to friction, and $k > 0$ is a constant cohesion-like parameter (perfect plasticity). The plastic flow is defined by a nonassociated plastic potential $g(\\boldsymbol{\\sigma}) = q + \\beta p$ with dilation parameter $\\beta \\ge 0$. A standard implicit closest-point return mapping algorithm on stress space is used with a single plastic multiplier increment $\\Delta\\lambda \\ge 0$ over a time step, starting from a known trial elastic predictor state $\\boldsymbol{\\sigma}^{\\mathrm{tr}}$ with invariants $p^{\\mathrm{tr}}$ and $q^{\\mathrm{tr}}$. Assume the usual Kuhn–Tucker conditions and consistency at the corrected state.\n\nDevelop, from first principles, the condition under which the corrected stress must return to the apex of the cone (the hydrostatic tip where $q^{n+1} = 0$) rather than to the conical face (where $q^{n+1} > 0$), and state the corresponding branching logic. Your result should clearly identify:\n- the explicit inequality that separates cone-face return versus apex return in terms of $p^{\\mathrm{tr}}$, $q^{\\mathrm{tr}}$, $K$, $G$, $\\alpha$, and $\\beta$;\n- the expressions for $p^{n+1}$, $q^{n+1}$, and $\\Delta\\lambda$ in each branch under perfect plasticity.\n\nWhich of the following options correctly states the apex return condition and the branching logic for this problem?\n\nA. Face return if $q^{\\mathrm{tr}} > \\frac{3G}{\\alpha K \\beta}\\left(\\alpha p^{\\mathrm{tr}} - k\\right)$; apex return otherwise. In the face-return branch, $\\Delta\\lambda = \\frac{q^{\\mathrm{tr}} + \\alpha p^{\\mathrm{tr}} - k}{3G + \\alpha K \\beta}$, $q^{n+1} = q^{\\mathrm{tr}} - 3G \\Delta\\lambda$, $p^{n+1} = p^{\\mathrm{tr}} - K \\beta \\Delta\\lambda$. In the apex-return branch, $q^{n+1} = 0$, $p^{n+1} = \\frac{k}{\\alpha}$, and $\\Delta\\lambda = \\frac{p^{\\mathrm{tr}} - k/\\alpha}{K\\beta}$.\n\nB. Face return if $q^{\\mathrm{tr}} > \\frac{2G}{\\alpha K \\beta}\\left(\\alpha p^{\\mathrm{tr}} - k\\right)$; apex return otherwise. In the face-return branch, $\\Delta\\lambda = \\frac{q^{\\mathrm{tr}} + \\alpha p^{\\mathrm{tr}} - k}{2G + \\alpha K \\beta}$, $q^{n+1} = q^{\\mathrm{tr}} - 2G \\Delta\\lambda$, $p^{n+1} = p^{\\mathrm{tr}} - K \\beta \\Delta\\lambda$. In the apex-return branch, $q^{n+1} = 0$, $p^{n+1} = \\frac{k}{\\alpha}$, and $\\Delta\\lambda = \\frac{k/\\alpha - p^{\\mathrm{tr}}}{K \\beta}$.\n\nC. Face return if $q^{\\mathrm{tr}} > \\frac{3G}{K}\\left(p^{\\mathrm{tr}} - \\frac{k}{\\alpha}\\right)$; apex return otherwise. In the face-return branch, $\\Delta\\lambda = \\frac{q^{\\mathrm{tr}} + \\alpha p^{\\mathrm{tr}} - k}{3G + K}$, $q^{n+1} = q^{\\mathrm{tr}} - 3G \\Delta\\lambda$, $p^{n+1} = p^{\\mathrm{tr}} - K \\Delta\\lambda$. In the apex-return branch, $q^{n+1} = 0$, $p^{n+1} = \\frac{k}{\\alpha}$, and $\\Delta\\lambda = \\frac{k/\\alpha - p^{\\mathrm{tr}}}{K}$.\n\nD. Face return if $q^{\\mathrm{tr}} > \\left(\\alpha p^{\\mathrm{tr}} - k\\right)$; apex return otherwise. In the face-return branch, $\\Delta\\lambda = \\frac{q^{\\mathrm{tr}} + \\alpha p^{\\mathrm{tr}} - k}{3G}$, $q^{n+1} = q^{\\mathrm{tr}} - 3G \\Delta\\lambda$, $p^{n+1} = p^{\\mathrm{tr}}$. In the apex-return branch, $q^{n+1} = 0$, $p^{n+1} = \\frac{k}{\\alpha}$, and $\\Delta\\lambda = \\frac{p^{\\mathrm{tr}} - k/\\alpha}{3G}$.", "solution": "The user wants a detailed derivation and validation of the return mapping algorithm for a non-associated Drucker-Prager plasticity model, including the branching logic for apex return.\n\n**Problem Statement Validation**\n\n*   **Step 1: Extract Givens**\n    -   **Constitutive Law:** Small-strain elastoplasticity.\n    -   **Elasticity:** Linear isotropic with bulk modulus $K$ and shear modulus $G$.\n    -   **Yield Function:** $f(\\boldsymbol{\\sigma}) = q + \\alpha p - k \\le 0$, where $p = \\frac{1}{3}\\mathrm{tr}(\\boldsymbol{\\sigma})$ is mean stress (positive in compression), $q = \\sqrt{\\frac{3}{2}\\boldsymbol{s}:\\boldsymbol{s}}$ is von Mises equivalent stress, $\\alpha > 0$ is a friction parameter, and $k > 0$ is a cohesion parameter.\n    -   **Plasticity:** Perfect plasticity (hardening is zero).\n    -   **Flow Rule:** Non-associated, determined by the plastic potential $g(\\boldsymbol{\\sigma}) = q + \\beta p$, with dilation parameter $\\beta \\ge 0$.\n    -   **Algorithm:** Implicit closest-point return mapping starting from a trial elastic state $\\boldsymbol{\\sigma}^{\\mathrm{tr}}$ with invariants $p^{\\mathrm{tr}}$ and $q^{\\mathrm{tr}}$. A single plastic multiplier increment $\\Delta\\lambda \\ge 0$ is used.\n    -   **Conditions:** Kuhn–Tucker conditions ($\\Delta\\lambda \\ge 0$, $f(\\boldsymbol{\\sigma}^{n+1}) \\le 0$, $\\Delta\\lambda f(\\boldsymbol{\\sigma}^{n+1}) = 0$) and consistency at the corrected state $\\boldsymbol{\\sigma}^{n+1}$.\n\n*   **Step 2: Validate Using Extracted Givens**\n    The problem is scientifically-grounded, well-posed, and objective. It describes a standard scenario in computational solid mechanics. The Drucker-Prager model, non-associated flow, and return mapping algorithms are fundamental concepts in this field. The problem of handling the apex singularity of conical yield surfaces is a classic and important aspect of implementing these models. All parameters and functions are clearly defined, and the premises are internally consistent and factually sound within the theoretical framework of plasticity. No missing information, contradictions, or ambiguities are present.\n\n*   **Step 3: Verdict and Action**\n    The problem statement is **valid**. A solution will be derived.\n\n**Derivation from First Principles**\n\nThe return mapping algorithm corrects the trial elastic stress $\\boldsymbol{\\sigma}^{\\mathrm{tr}}$, which lies outside the yield surface (i.e., $f(\\boldsymbol{\\sigma}^{\\mathrm{tr}}) > 0$), to a final stress $\\boldsymbol{\\sigma}^{n+1}$ on the yield surface. The update rule is:\n$$ \\boldsymbol{\\sigma}^{n+1} = \\boldsymbol{\\sigma}^{\\mathrm{tr}} - \\mathbf{C} : \\Delta\\boldsymbol{\\varepsilon}^p $$\nwhere $\\mathbf{C}$ is the fourth-order isotropic elastic stiffness tensor and $\\Delta\\boldsymbol{\\varepsilon}^p$ is the plastic strain increment. For linear isotropic elasticity, $\\mathbf{C} = 2G \\mathbf{I}^{\\text{dev}} + K \\mathbf{1} \\otimes \\mathbf{1}$, where $\\mathbf{I}^{\\text{dev}}$ is the fourth-order deviatoric projector.\n\nThe plastic strain increment is given by the non-associated flow rule:\n$$ \\Delta\\boldsymbol{\\varepsilon}^p = \\Delta\\lambda \\frac{\\partial g}{\\partial \\boldsymbol{\\sigma}}\\bigg|_{\\boldsymbol{\\sigma}^{n+1}} $$\nwhere $\\Delta\\lambda \\ge 0$ is the plastic multiplier.\n\nFirst, we find the gradient of the plastic potential $g(\\boldsymbol{\\sigma}) = q + \\beta p$:\n$$ \\frac{\\partial g}{\\partial \\boldsymbol{\\sigma}} = \\frac{\\partial q}{\\partial \\boldsymbol{\\sigma}} + \\beta \\frac{\\partial p}{\\partial \\boldsymbol{\\sigma}} $$\nThe gradients of the stress invariants $p$ and $q$ are:\n$$ \\frac{\\partial p}{\\partial \\boldsymbol{\\sigma}} = \\frac{1}{3}\\mathbf{1} \\quad ; \\quad \\frac{\\partial q}{\\partial \\boldsymbol{\\sigma}} = \\frac{3}{2q}\\boldsymbol{s} \\quad (\\text{for } q > 0) $$\nwhere $\\boldsymbol{s} = \\boldsymbol{\\sigma} - p\\mathbf{1}$ is the deviatoric stress tensor.\nThus, the flow vector is:\n$$ \\frac{\\partial g}{\\partial \\boldsymbol{\\sigma}} = \\frac{3}{2q^{n+1}}\\boldsymbol{s}^{n+1} + \\frac{\\beta}{3}\\mathbf{1} $$\nThis expression is valid for a return to the conical face, where $q^{n+1} > 0$.\n\nSubstituting the flow rule into the stress update:\n$$ \\boldsymbol{\\sigma}^{n+1} = \\boldsymbol{\\sigma}^{\\mathrm{tr}} - \\Delta\\lambda \\, \\mathbf{C} : \\left( \\frac{3}{2q^{n+1}}\\boldsymbol{s}^{n+1} + \\frac{\\beta}{3}\\mathbf{1} \\right) $$\nUsing the properties of the isotropic stiffness tensor, $\\mathbf{C}:\\boldsymbol{s}^{n+1} = 2G\\boldsymbol{s}^{n+1}$ and $\\mathbf{C}:\\mathbf{1} = 3K\\mathbf{1}$, we get:\n$$ \\boldsymbol{\\sigma}^{n+1} = \\boldsymbol{\\sigma}^{\\mathrm{tr}} - \\Delta\\lambda \\left( 2G \\frac{3}{2q^{n+1}}\\boldsymbol{s}^{n+1} + K \\frac{\\beta}{3} 3\\mathbf{1} \\right) = \\boldsymbol{\\sigma}^{\\mathrm{tr}} - \\Delta\\lambda \\left( \\frac{3G}{q^{n+1}}\\boldsymbol{s}^{n+1} + K\\beta\\mathbf{1} \\right) $$\nWe decompose this equation into deviatoric and volumetric parts by letting $\\boldsymbol{\\sigma} = \\boldsymbol{s} + p\\mathbf{1}$:\n$$ \\boldsymbol{s}^{n+1} + p^{n+1}\\mathbf{1} = \\boldsymbol{s}^{\\mathrm{tr}} + p^{\\mathrm{tr}}\\mathbf{1} - \\frac{3G\\Delta\\lambda}{q^{n+1}}\\boldsymbol{s}^{n+1} - K\\beta\\Delta\\lambda\\mathbf{1} $$\nEquating the deviatoric components:\n$$ \\boldsymbol{s}^{n+1} = \\boldsymbol{s}^{\\mathrm{tr}} - \\frac{3G\\Delta\\lambda}{q^{n+1}}\\boldsymbol{s}^{n+1} \\implies \\boldsymbol{s}^{n+1} \\left(1 + \\frac{3G\\Delta\\lambda}{q^{n+1}}\\right) = \\boldsymbol{s}^{\\mathrm{tr}} $$\nThis relation shows that $\\boldsymbol{s}^{n+1}$ is collinear with $\\boldsymbol{s}^{\\mathrm{tr}}$. Taking the von Mises equivalent stress of both sides gives a scalar relation:\n$$ q^{n+1} \\left(1 + \\frac{3G\\Delta\\lambda}{q^{n+1}}\\right) = q^{\\mathrm{tr}} \\implies q^{n+1} + 3G\\Delta\\lambda = q^{\\mathrm{tr}} $$\n$$ q^{n+1} = q^{\\mathrm{tr}} - 3G\\Delta\\lambda $$\nEquating the volumetric (hydrostatic) components:\n$$ p^{n+1}\\mathbf{1} = p^{\\mathrm{tr}}\\mathbf{1} - K\\beta\\Delta\\lambda\\mathbf{1} \\implies p^{n+1} = p^{\\mathrm{tr}} - K\\beta\\Delta\\lambda $$\n\n**Case 1: Return to the Conical Face ($q^{n+1} > 0$)**\nThe corrected state must satisfy the yield condition, $f(\\boldsymbol{\\sigma}^{n+1}) = q^{n+1} + \\alpha p^{n+1} - k = 0$. Substituting the expressions for $q^{n+1}$ and $p^{n+1}$:\n$$ (q^{\\mathrm{tr}} - 3G\\Delta\\lambda) + \\alpha(p^{\\mathrm{tr}} - K\\beta\\Delta\\lambda) - k = 0 $$\nRearranging to solve for the plastic multiplier $\\Delta\\lambda$:\n$$ q^{\\mathrm{tr}} + \\alpha p^{\\mathrm{tr}} - k = \\Delta\\lambda(3G + \\alpha K \\beta) $$\n$$ \\Delta\\lambda = \\frac{q^{\\mathrm{tr}} + \\alpha p^{\\mathrm{tr}} - k}{3G + \\alpha K \\beta} $$\nThe numerator represents the value of the yield function at the trial state, $f^{\\mathrm{tr}}$. Since we assume a plastic step, $f^{\\mathrm{tr}} > 0$. The denominator is also positive since $G > 0$, $K > 0$, $\\alpha > 0$, and $\\beta \\ge 0$, ensuring $\\Delta\\lambda > 0$.\n\n**Branching Condition: Face Return vs. Apex Return**\nThe face-return derivation is valid only if $q^{n+1} > 0$.\n$$ q^{n+1} = q^{\\mathrm{tr}} - 3G\\Delta\\lambda > 0 \\implies q^{\\mathrm{tr}} > 3G\\Delta\\lambda $$\nSubstituting the expression for $\\Delta\\lambda$:\n$$ q^{\\mathrm{tr}} > 3G \\left( \\frac{q^{\\mathrm{tr}} + \\alpha p^{\\mathrm{tr}} - k}{3G + \\alpha K \\beta} \\right) $$\n$$ q^{\\mathrm{tr}}(3G + \\alpha K \\beta) > 3G(q^{\\mathrm{tr}} + \\alpha p^{\\mathrm{tr}} - k) $$\n$$ 3Gq^{\\mathrm{tr}} + \\alpha K \\beta q^{\\mathrm{tr}} > 3Gq^{\\mathrm{tr}} + 3G\\alpha p^{\\mathrm{tr}} - 3Gk $$\n$$ \\alpha K \\beta q^{\\mathrm{tr}} > 3G(\\alpha p^{\\mathrm{tr}} - k) $$\nAssuming $\\alpha > 0$, $K > 0$, $\\beta > 0$ (the case $\\beta=0$ requires special care but leads to a consistent limit), we get the face return condition:\n$$ q^{\\mathrm{tr}} > \\frac{3G}{\\alpha K \\beta}(\\alpha p^{\\mathrm{tr}} - k) $$\nIf this inequality holds, the return is to the conical face. Otherwise, the return is to the apex.\n\n**Case 2: Return to the Apex ($q^{n+1} = 0$)**\nThis occurs if $q^{\\mathrm{tr}} \\le \\frac{3G}{\\alpha K \\beta}(\\alpha p^{\\mathrm{tr}} - k)$.\nGeometrically, this corresponds to the return path (a line of slope $3G/(K\\beta)$ in the $(p,q)$ plane) intersecting the $p$-axis at a pressure $p_{\\text{intersect}} > k/\\alpha$, which is outside the elastic domain. The algorithm must therefore project to the closest admissible point, which is the apex itself.\nThe apex is defined by $q=0$ and the yield condition $q+\\alpha p - k \\le 0$, which for $q=0$ becomes $\\alpha p - k \\le 0$, or $p \\le k/\\alpha$. The apex point on the yield boundary is at $p=k/\\alpha$.\nThus, for an apex return, the final state is:\n$$ q^{n+1} = 0 \\quad ; \\quad p^{n+1} = k/\\alpha $$\nAt the apex, the flow direction is not unique and lies in the subdifferential of the plastic potential. The update equations for $p$ and $q$ still hold, but we determine $\\Delta\\lambda$ from the known final state. Using the hydrostatic update:\n$$ p^{n+1} = p^{\\mathrm{tr}} - K\\beta\\Delta\\lambda $$\n$$ k/\\alpha = p^{\\mathrm{tr}} - K\\beta\\Delta\\lambda $$\nSolving for $\\Delta\\lambda$ (again assuming $\\beta>0$):\n$$ \\Delta\\lambda = \\frac{p^{\\mathrm{tr}} - k/\\alpha}{K\\beta} $$\nFor this to be a valid plastic multiplier, we need $\\Delta\\lambda > 0$, which implies $p^{\\mathrm{tr}} > k/\\alpha$. This is consistent with the apex return condition, as $q^{\\mathrm{tr}}>0$ and $q^{\\mathrm{tr}} \\le \\frac{3G}{\\alpha K \\beta}(\\alpha p^{\\mathrm{tr}} - k)$ can only be satisfied if $(\\alpha p^{\\mathrm{tr}} - k) > 0$, which means $p^{\\mathrm{tr}} > k/\\alpha$.\n\n**Summary of Results:**\n*   **Branching Condition:**\n    - Face Return if: $q^{\\mathrm{tr}} > \\frac{3G}{\\alpha K \\beta}(\\alpha p^{\\mathrm{tr}} - k)$.\n    - Apex Return if: $q^{\\mathrm{tr}} \\le \\frac{3G}{\\alpha K \\beta}(\\alpha p^{\\mathrm{tr}} - k)$.\n*   **Face-Return Branch:**\n    - $\\Delta\\lambda = \\frac{q^{\\mathrm{tr}} + \\alpha p^{\\mathrm{tr}} - k}{3G + \\alpha K \\beta}$\n    - $q^{n+1} = q^{\\mathrm{tr}} - 3G \\Delta\\lambda$\n    - $p^{n+1} = p^{\\mathrm{tr}} - K \\beta \\Delta\\lambda$\n*   **Apex-Return Branch:**\n    - $q^{n+1} = 0$\n    - $p^{n+1} = k/\\alpha$\n    - $\\Delta\\lambda = \\frac{p^{\\mathrm{tr}} - k/\\alpha}{K\\beta}$\n\n**Option-by-Option Analysis**\n\n*   **Option A:** `Face return if $q^{\\mathrm{tr}}  \\dfrac{3G}{\\alpha K \\beta}\\left(\\alpha p^{\\mathrm{tr}} - k\\right)$; apex return otherwise. In the face-return branch, $\\Delta\\lambda = \\dfrac{q^{\\mathrm{tr}} + \\alpha p^{\\mathrm{tr}} - k}{3G + \\alpha K \\beta}$, $q^{n+1} = q^{\\mathrm{tr}} - 3G \\Delta\\lambda$, $p^{n+1} = p^{\\mathrm{tr}} - K \\beta \\Delta\\lambda$. In the apex-return branch, $q^{n+1} = 0$, $p^{n+1} = \\dfrac{k}{\\alpha}$, and $\\Delta\\lambda = \\dfrac{p^{\\mathrm{tr}} - k/\\alpha}{K \\beta}$.`\n    This option perfectly matches the derived branching condition, the face-return updates, and the apex-return updates.\n    **Verdict: Correct**\n\n*   **Option B:** `Face return if $q^{\\mathrm{tr}}  \\dfrac{2G}{\\alpha K \\beta}\\left(\\alpha p^{\\mathrm{tr}} - k\\right)$; apex return otherwise. In the face-return branch, $\\Delta\\lambda = \\dfrac{q^{\\mathrm{tr}} + \\alpha p^{\\mathrm{tr}} - k}{2G + \\alpha K \\beta}$, $q^{n+1} = q^{\\mathrm{tr}} - 2G \\Delta\\lambda$, $p^{n+1} = p^{\\mathrm{tr}} - K \\beta \\Delta\\lambda$. In the apex-return branch, $q^{n+1} = 0$, $p^{n+1} = \\dfrac{k}{\\alpha}$, and $\\Delta\\lambda = \\dfrac{k/\\alpha - p^{\\mathrm{tr}}}{K \\beta}$.`\n    This option incorrectly uses a factor of $2G$ instead of $3G$ throughout the deviatoric return calculations. The factor of $3G$ arises correctly from $2G \\times (3/2)$. Additionally, the expression for $\\Delta\\lambda$ in the apex return has the wrong sign in the numerator.\n    **Verdict: Incorrect**\n\n*   **Option C:** `Face return if $q^{\\mathrm{tr}}  \\dfrac{3G}{K}\\left(p^{\\mathrm{tr}} - \\dfrac{k}{\\alpha}\\right)$; apex return otherwise. In the face-return branch, $\\Delta\\lambda = \\dfrac{q^{\\mathrm{tr}} + \\alpha p^{\\mathrm{tr}} - k}{3G + K}$, $q^{n+1} = q^{\\mathrm{tr}} - 3G \\Delta\\lambda$, $p^{n+1} = p^{\\mathrm{tr}} - K \\Delta\\lambda$. In the apex-return branch, $q^{n+1} = 0$, $p^{n+1} = \\dfrac{k}{\\alpha}$, and $\\Delta\\lambda = \\dfrac{k/\\alpha - p^{\\mathrm{tr}}}{K}$.`\n    The branching condition is missing the factors $\\alpha$ and $\\beta$. The update equations for the face-return branch implicitly assume $\\alpha=1$ and $\\beta=1$. The apex return $\\Delta\\lambda$ also assumes $\\beta=1$ and has the wrong sign. This does not match the general non-associated model given.\n    **Verdict: Incorrect**\n\n*   **Option D:** `Face return if $q^{\\mathrm{tr}}  \\left(\\alpha p^{\\mathrm{tr}} - k\\right)$; apex return otherwise. In the face-return branch, $\\Delta\\lambda = \\dfrac{q^{\\mathrm{tr}} + \\alpha p^{\\mathrm{tr}} - k}{3G}$, $q^{n+1} = q^{\\mathrm{tr}} - 3G \\Delta\\lambda$, $p^{n+1} = p^{\\mathrm{tr}}$. In the apex-return branch, $q^{n+1} = 0$, $p^{n+1} = \\dfrac{k}{\\alpha}$, and $\\Delta\\lambda = \\dfrac{p^{\\mathrm{tr}} - k/\\alpha}{3G}$.`\n    This option corresponds to the special case where $\\beta=0$ (no plastic dilation) for the face return part, since $p^{n+1}=p^{\\mathrm{tr}}$ and the denominator of $\\Delta\\lambda$ lacks the $K$-dependent term. However, the branching condition is incorrect even for this case, and the expression for $\\Delta\\lambda$ in the apex-return branch is incorrect (denominator should be $K\\beta$, which is not defined for $\\beta=0$, highlighting the singularity of this case). The option is invalid for the general problem where $\\beta \\ge 0$.\n    **Verdict: Incorrect**", "answer": "$$\\boxed{A}$$", "id": "3596281"}, {"introduction": "Our final practice shifts focus from the geometry of the yield surface to the nonlinearity of the material's response, a feature of most engineering materials. This problem tackles the implementation of a J2 plasticity model with a nonlinear isotropic hardening law, which results in a nonlinear consistency equation. You will formulate and implement a safeguarded Newton-Raphson iteration [@problem_id:3596258], an essential numerical technique that ensures your return mapping algorithm is both efficient and robust.", "problem": "Consider a small-strain, linear isotropic elastic-plastic material with an associative flow rule and a yield function based on the second invariant of the deviatoric stress (J2). Use the following fundamental and well-tested base definitions and facts from computational solid mechanics:\n\n- The Cauchy stress tensor is decomposed into volumetric and deviatoric parts as $\\boldsymbol{\\sigma} = \\kappa \\mathrm{tr}(\\boldsymbol{\\varepsilon}) \\boldsymbol{I} + 2 \\mu \\boldsymbol{e}^{\\mathrm{dev}}$, where $\\kappa$ is the bulk modulus, $\\mu$ is the shear modulus, $\\boldsymbol{\\varepsilon}$ is the strain tensor, and $\\boldsymbol{e}^{\\mathrm{dev}}$ is the deviatoric elastic strain tensor. The deviatoric stress tensor is $\\boldsymbol{s} = 2 \\mu \\boldsymbol{e}^{\\mathrm{dev}}$.\n- The associative plastic flow rule is $\\mathrm{d}\\boldsymbol{\\varepsilon}^{\\mathrm{p}} = \\mathrm{d}\\lambda \\frac{\\partial f}{\\partial \\boldsymbol{\\sigma}}$, where $f$ is the yield function and $\\mathrm{d}\\lambda \\ge 0$ is the plastic multiplier increment.\n- For J2 plasticity, a common form of the yield function in terms of the deviatoric stress magnitude is $f(\\boldsymbol{\\sigma}, \\alpha) = \\|\\boldsymbol{s}\\| - \\sqrt{\\frac{2}{3}} \\sigma_{\\mathrm{y}}(\\alpha)$, where $\\alpha$ is the equivalent plastic strain and $\\sigma_{\\mathrm{y}}(\\alpha)$ is the current yield stress.\n- The equivalent plastic strain increment is $\\mathrm{d}\\bar{\\varepsilon}^{\\mathrm{p}} = \\sqrt{\\frac{2}{3}} \\|\\mathrm{d}\\boldsymbol{\\varepsilon}^{\\mathrm{p}}\\|$, which implies $\\mathrm{d}\\alpha = \\mathrm{d}\\bar{\\varepsilon}^{\\mathrm{p}}$.\n- Under the standard return mapping algorithm (radial return for J2), the updated deviatoric stress remains colinear with the trial deviatoric stress, and its magnitude is reduced by the plastic flow.\n- All quantities in this problem are dimensionless. No physical units are required.\n\nStarting from these bases, consider an isotropic hardening law of exponential type given by $\\sigma_{\\mathrm{y}}(\\alpha) = \\sigma_{\\mathrm{y}0} + H (1 - e^{-b \\alpha})$, where $\\sigma_{\\mathrm{y}0} > 0$ is the initial yield stress, $H \\ge 0$ is the hardening modulus, and $b > 0$ governs the saturation rate. Let $\\alpha_n$ denote the equivalent plastic strain at the previous time step and let $\\|\\boldsymbol{s}_{\\mathrm{tr}}\\|$ denote the magnitude of the trial deviatoric stress at the current step assuming purely elastic response. The return mapping seeks the plastic multiplier increment $\\Delta\\lambda \\ge 0$ such that the updated state lies exactly on the yield surface.\n\nYour tasks are:\n\n1. Derive, from the fundamental bases above and without shortcut formulas, the scalar consistency equation for the plastic multiplier increment $\\Delta\\lambda$ of the form $g(\\Delta\\lambda) = 0$, where $g(\\Delta\\lambda)$ is explicitly defined in terms of $\\mu$, $\\|\\boldsymbol{s}_{\\mathrm{tr}}\\|$, $\\sigma_{\\mathrm{y}0}$, $H$, $b$, and $\\alpha_n$.\n\n2. Formulate a safeguarded Newton iteration equipped with a line search for solving $g(\\Delta\\lambda) = 0$ in the one-dimensional variable $\\Delta\\lambda \\ge 0$. Your safeguarded Newton method must:\n   - Start from a valid bracket $[\\lambda_{\\mathrm{L}}, \\lambda_{\\mathrm{U}}]$ with $\\lambda_{\\mathrm{L}} = 0$ and update $\\lambda_{\\mathrm{U}}$ to ensure $g(\\lambda_{\\mathrm{L}}) \\ge 0$ and $g(\\lambda_{\\mathrm{U}}) \\le 0$ when plastic loading occurs.\n   - Use the Newton step $\\Delta\\lambda_{\\mathrm{trial}} = \\Delta\\lambda - \\frac{g(\\Delta\\lambda)}{g'(\\Delta\\lambda)}$ as a candidate.\n   - If $\\Delta\\lambda_{\\mathrm{trial}}$ violates the bracket, replace it by a bisection step $\\frac{\\lambda_{\\mathrm{L}} + \\lambda_{\\mathrm{U}}}{2}$.\n   - Apply a backtracking line search with the Armijo (sufficient decrease) condition on the merit function $\\phi(\\Delta\\lambda) = \\frac{1}{2} g(\\Delta\\lambda)^2$ to accept or reduce the step length along the Newton direction.\n\n3. State precise mathematical conditions, expressed in terms of the data and properties of $g(\\Delta\\lambda)$ and $g'(\\Delta\\lambda)$, under which global convergence to the unique root is guaranteed by the proposed safeguarded Newton method with line search. Your conditions must be stated purely in mathematical terms, referencing properties such as continuity, monotonicity, and boundedness of derivatives, and must be sufficient for uniqueness and convergence.\n\n4. Implement your algorithm as a complete, runnable program that, for the given test suite, computes $\\Delta\\lambda$ for each case and outputs the results.\n\nUse the following test suite, each case being a tuple $(\\mu,\\|\\boldsymbol{s}_{\\mathrm{tr}}\\|,\\sigma_{\\mathrm{y}0},H,b,\\alpha_n)$:\n- Case $1$ (general plastic): $(80000.0, 600.0, 250.0, 1000.0, 10.0, 0.05)$.\n- Case $2$ (elastic boundary): $(80000.0, 500.0, 250.0, 1000.0, 10.0, 0.05)$.\n- Case $3$ (perfect plasticity, no hardening): $(80000.0, 600.0, 250.0, 0.0, 10.0, 0.05)$.\n- Case $4$ (rapid saturation hardening): $(30000.0, 1200.0, 200.0, 1500.0, 200.0, 0.0)$.\n\nFor each case, your program must compute the plastic multiplier increment $\\Delta\\lambda$ as a floating-point number and aggregate the results into a single output line. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[\\text{result1},\\text{result2},\\text{result3},\\text{result4}]$). No other output is permitted.", "solution": "We begin with small-strain, linear isotropic elasticity and an associative plastic flow rule. The stress decomposition is $\\boldsymbol{\\sigma} = \\kappa \\mathrm{tr}(\\boldsymbol{\\varepsilon}) \\boldsymbol{I} + 2 \\mu \\boldsymbol{e}^{\\mathrm{dev}}$, where the deviatoric stress is $\\boldsymbol{s} = 2 \\mu \\boldsymbol{e}^{\\mathrm{dev}}$. The J2 yield function in terms of the deviatoric stress magnitude is $f(\\boldsymbol{\\sigma}, \\alpha) = \\|\\boldsymbol{s}\\| - \\sqrt{\\frac{2}{3}} \\sigma_{\\mathrm{y}}(\\alpha)$, where $\\alpha$ is the equivalent plastic strain and $\\sigma_{\\mathrm{y}}(\\alpha)$ is the current yield stress. The associative flow rule gives $\\mathrm{d}\\boldsymbol{\\varepsilon}^{\\mathrm{p}} = \\mathrm{d}\\lambda \\frac{\\partial f}{\\partial \\boldsymbol{\\sigma}}$. For the J2 yield function $f(\\boldsymbol{\\sigma}, \\alpha) = \\|\\boldsymbols\\| - \\sqrt{\\frac{2}{3}} \\sigma_{\\mathrm{y}}(\\alpha)$, the gradient with respect to the stress is $\\frac{\\partial f}{\\partial \\boldsymbol{\\sigma}} = \\frac{\\partial f}{\\partial \\boldsymbol{s}} = \\frac{\\boldsymbol{s}}{\\|\\boldsymbol{s}\\|}$, which is a deviatoric unit vector aligned with $\\boldsymbol{s}$.\n\nUnder the standard radial return mapping assumption, the updated deviatoric stress $\\boldsymbol{s}_{n+1}$ is colinear with the trial deviatoric stress $\\boldsymbol{s}_{\\mathrm{tr}}$, and its magnitude is reduced by the amount of deviatoric plastic strain increment through elasticity: $\\boldsymbol{s}_{n+1} = \\boldsymbol{s}_{\\mathrm{tr}} - 2 \\mu \\Delta\\boldsymbol{\\varepsilon}^{\\mathrm{p}}$, with $\\Delta\\boldsymbol{\\varepsilon}^{\\mathrm{p}} = \\Delta\\lambda \\frac{\\boldsymbol{s}_{n+1}}{\\|\\boldsymbol{s}_{n+1}\\|}$. Since $\\frac{\\boldsymbol{s}_{n+1}}{\\|\\boldsymbol{s}_{n+1}\\|}$ is aligned with $\\boldsymbol{s}_{\\mathrm{tr}}$, the magnitudes obey\n$$\n\\|\\boldsymbol{s}_{n+1}\\| = \\|\\boldsymbol{s}_{\\mathrm{tr}}\\| - 2 \\mu \\Delta\\lambda.\n$$\nThe yield function consistency condition at the end of the increment requires $f(\\boldsymbol{\\sigma}_{n+1}, \\alpha_{n+1}) = 0$, i.e.,\n$$\n\\|\\boldsymbol{s}_{n+1}\\| - \\sqrt{\\frac{2}{3}} \\sigma_{\\mathrm{y}}(\\alpha_{n+1}) = 0.\n$$\nThe equivalent plastic strain evolves as $\\mathrm{d}\\bar{\\varepsilon}^{\\mathrm{p}} = \\sqrt{\\frac{2}{3}} \\|\\mathrm{d}\\boldsymbol{\\varepsilon}^{\\mathrm{p}}\\|$, which, using $\\mathrm{d}\\boldsymbol{\\varepsilon}^{\\mathrm{p}} = \\mathrm{d}\\lambda \\frac{\\boldsymbol{s}}{\\|\\boldsymbol{s}\\|}$, yields $\\mathrm{d}\\bar{\\varepsilon}^{\\mathrm{p}} = \\sqrt{\\frac{2}{3}} \\mathrm{d}\\lambda$. Therefore, the increment in equivalent plastic strain is $\\Delta\\alpha = \\sqrt{\\frac{2}{3}} \\Delta\\lambda$, and the updated $\\alpha$ is $\\alpha_{n+1} = \\alpha_n + \\sqrt{\\frac{2}{3}} \\Delta\\lambda$.\n\nWith the exponential isotropic hardening law $\\sigma_{\\mathrm{y}}(\\alpha) = \\sigma_{\\mathrm{y}0} + H (1 - e^{-b \\alpha})$, the consistency condition becomes\n$$\n\\|\\boldsymbol{s}_{\\mathrm{tr}}\\| - 2 \\mu \\Delta\\lambda - \\sqrt{\\frac{2}{3}} \\left[ \\sigma_{\\mathrm{y}0} + H \\left( 1 - e^{-b (\\alpha_n + \\sqrt{\\frac{2}{3}} \\Delta\\lambda)} \\right) \\right] = 0.\n$$\nDefine the scalar function\n$$\ng(\\Delta\\lambda) = \\|\\boldsymbol{s}_{\\mathrm{tr}}\\| - 2 \\mu \\Delta\\lambda - \\sqrt{\\frac{2}{3}} \\left[ \\sigma_{\\mathrm{y}0} + H \\left( 1 - e^{-b (\\alpha_n + \\sqrt{\\frac{2}{3}} \\Delta\\lambda)} \\right) \\right].\n$$\nPlastic loading occurs if and only if $g(0) > 0$, in which case the unique root $\\Delta\\lambda > 0$ must be found.\n\nWe compute the derivative of $g(\\Delta\\lambda)$:\n$$\ng'(\\Delta\\lambda) = - 2 \\mu - \\sqrt{\\frac{2}{3}} \\left[ H \\cdot \\frac{\\mathrm{d}}{\\mathrm{d}\\Delta\\lambda} \\left( 1 - e^{-b (\\alpha_n + \\sqrt{\\frac{2}{3}} \\Delta\\lambda)} \\right) \\right].\n$$\nSince $\\frac{\\mathrm{d}}{\\mathrm{d}\\Delta\\lambda} \\left( 1 - e^{-b (\\alpha_n + \\sqrt{\\frac{2}{3}} \\Delta\\lambda)} \\right) = b \\sqrt{\\frac{2}{3}} e^{-b (\\alpha_n + \\sqrt{\\frac{2}{3}} \\Delta\\lambda)}$, we obtain\n$$\ng'(\\Delta\\lambda) = - 2 \\mu - \\left( \\frac{2}{3} \\right) H b e^{-b (\\alpha_n + \\sqrt{\\frac{2}{3}} \\Delta\\lambda)}.\n$$\nTherefore, $g'(\\Delta\\lambda)  0$ for all $\\Delta\\lambda \\ge 0$ whenever $\\mu > 0$, $H \\ge 0$, and $b > 0$. In fact,\n$$\ng'(\\Delta\\lambda) \\le - 2 \\mu  0,\n$$\nso $g$ is strictly decreasing and continuously differentiable. Moreover, $\\lim_{\\Delta\\lambda \\to +\\infty} g(\\Delta\\lambda) = -\\infty$, and thus there is at most one root. If $g(0) > 0$, by the intermediate value theorem, there exists a unique root $\\Delta\\lambda^\\star > 0$.\n\nWe now design a safeguarded Newton method with line search. Let the merit function be\n$$\n\\phi(\\Delta\\lambda) = \\frac{1}{2} g(\\Delta\\lambda)^2.\n$$\nWe use the Newton step\n$$\n\\Delta\\lambda_{\\mathrm{N}} = \\Delta\\lambda - \\frac{g(\\Delta\\lambda)}{g'(\\Delta\\lambda)}.\n$$\nTo ensure global convergence, we enforce the following safeguards:\n\n- Initialization and bracketing: Set the lower bound $\\lambda_{\\mathrm{L}} = 0$. If $g(0) \\le 0$, conclude elastic response and set $\\Delta\\lambda = 0$. Otherwise, choose an initial upper bound $\\lambda_{\\mathrm{U}}$ (for example, $\\lambda_{\\mathrm{U}} = \\max( \\frac{g(0)}{2 \\mu}, \\varepsilon )$ for a small $\\varepsilon > 0$) and increase $\\lambda_{\\mathrm{U}}$ (e.g., by doubling) until $g(\\lambda_{\\mathrm{U}}) \\le 0$. Then the unique root lies in $[\\lambda_{\\mathrm{L}}, \\lambda_{\\mathrm{U}}]$.\n- Safeguarded step: Compute the Newton candidate $\\Delta\\lambda_{\\mathrm{N}}$. If $\\Delta\\lambda_{\\mathrm{N}} \\notin [\\lambda_{\\mathrm{L}}, \\lambda_{\\mathrm{U}}]$, replace it with the bisection step $\\Delta\\lambda_{\\mathrm{B}} = \\frac{\\lambda_{\\mathrm{L}} + \\lambda_{\\mathrm{U}}}{2}$. Otherwise, use $\\Delta\\lambda_{\\mathrm{N}}$ as the direction base for a line search.\n- Line search with Armijo condition: Define the Newton direction $p = -\\frac{g(\\Delta\\lambda)}{g'(\\Delta\\lambda)}$. Starting with step size $\\alpha = 1$, backtrack (e.g., halve $\\alpha$ repeatedly) until the Armijo sufficient decrease condition holds:\n$$\n\\phi(\\Delta\\lambda + \\alpha p) \\le \\phi(\\Delta\\lambda) + c \\alpha \\nabla \\phi(\\Delta\\lambda) p,\n$$\nwith $c \\in (0,1)$, and where $\\nabla \\phi(\\Delta\\lambda) = g(\\Delta\\lambda) g'(\\Delta\\lambda)$. Because $p = -\\frac{g(\\Delta\\lambda)}{g'(\\Delta\\lambda)}$, the right-hand side simplifies to\n$$\n\\phi(\\Delta\\lambda) - c \\alpha g(\\Delta\\lambda)^2.\n$$\nAdditionally, ensure the accepted step $\\Delta\\lambda_{\\mathrm{new}} = \\Delta\\lambda + \\alpha p$ remains within $[\\lambda_{\\mathrm{L}}, \\lambda_{\\mathrm{U}}]$. If the Newton candidate violates the bracket, use the bisection step instead, which reduces the bracket size.\n- Bracket update: If $g(\\Delta\\lambda_{\\mathrm{new}}) > 0$, set $\\lambda_{\\mathrm{L}} \\leftarrow \\Delta\\lambda_{\\mathrm{new}}$; otherwise, set $\\lambda_{\\mathrm{U}} \\leftarrow \\Delta\\lambda_{\\mathrm{new}}$. Then set $\\Delta\\lambda \\leftarrow \\Delta\\lambda_{\\mathrm{new}}$.\n\nTermination criteria: Stop when either $|g(\\Delta\\lambda)| \\le \\varepsilon_{\\mathrm{tol}}$ for a chosen tolerance $\\varepsilon_{\\mathrm{tol}} > 0$, or the bracket width $|\\lambda_{\\mathrm{U}} - \\lambda_{\\mathrm{L}}| \\le \\varepsilon_{\\mathrm{tol}}$.\n\nGlobal convergence and uniqueness conditions: The proposed method converges globally to the unique root under the following conditions:\n- The function $g(\\Delta\\lambda)$ is continuously differentiable on $[0, +\\infty)$; this holds since $g$ is a combination of polynomials and exponentials.\n- Strict monotonicity with derivative bounded away from zero: There exists a constant $m > 0$ such that $g'(\\Delta\\lambda) \\le -m  0$ for all $\\Delta\\lambda \\ge 0$. In our case, $m = 2 \\mu$, so $g'(\\Delta\\lambda) \\le -2 \\mu  0$ for all $\\Delta\\lambda \\ge 0$, provided $\\mu > 0$. This ensures $g$ is strongly monotone and the root is unique.\n- Bracketing condition: If $g(0) > 0$, there exists $\\lambda_{\\mathrm{U}} > 0$ such that $g(\\lambda_{\\mathrm{U}}) \\le 0$; since $\\lim_{\\Delta\\lambda \\to +\\infty} g(\\Delta\\lambda) = -\\infty$, such a $\\lambda_{\\mathrm{U}}$ always exists. Establishing a bracket $[\\lambda_{\\mathrm{L}}, \\lambda_{\\mathrm{U}}]$ containing the root ensures that either the safeguarded Newton step or bisection keeps the iterates within the bracket and makes progress.\n- Merit function $\\phi(\\Delta\\lambda) = \\frac{1}{2} g(\\Delta\\lambda)^2$ is continuously differentiable and coercive along the line search direction (Newton direction is a descent direction for $\\phi$ whenever $g'(\\Delta\\lambda) \\neq 0$). The Armijo backtracking guarantees sufficient decrease and thus convergence from any starting point within the bracket.\n\nGiven these conditions and safeguards, the algorithm converges globally to the unique root $\\Delta\\lambda^\\star$ for all admissible material parameters with $\\mu > 0$, $H \\ge 0$, $b > 0$, and for any trial state where $g(0) > 0$ (plastic loading). If $g(0) \\le 0$, the step is elastic and the correct solution is $\\Delta\\lambda = 0$.\n\nImplementation details for the test suite: For each test case $(\\mu,\\|\\boldsymbol{s}_{\\mathrm{tr}}\\|,\\sigma_{\\mathrm{y}0},H,b,\\alpha_n)$, define\n$$\ng(\\Delta\\lambda) = \\|\\boldsymbol{s}_{\\mathrm{tr}}\\| - 2 \\mu \\Delta\\lambda - \\sqrt{\\frac{2}{3}} \\left[ \\sigma_{\\mathrm{y}0} + H \\left( 1 - e^{-b (\\alpha_n + \\sqrt{\\frac{2}{3}} \\Delta\\lambda)} \\right) \\right],\n$$\nand\n$$\ng'(\\Delta\\lambda) = - 2 \\mu - \\left( \\frac{2}{3} \\right) H b e^{-b (\\alpha_n + \\sqrt{\\frac{2}{3}} \\Delta\\lambda)}.\n$$\nApply the safeguarded Newton iteration with an Armijo backtracking line search and bisection fallback as described, and aggregate the computed $\\Delta\\lambda$ values for the four cases into the specified output format.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_delta_lambda(mu, s_tr_norm, sigma_y0, H, b, alpha_n,\n                         tol=1e-12, max_iter=200, armijo_c=1e-4, backtrack_factor=0.5):\n    \"\"\"\n    Safeguarded Newton iteration with line search to solve g(Δλ) = 0 for J2 plasticity\n    with exponential isotropic hardening. Returns Δλ = 0.\n    \"\"\"\n    sqrt23 = np.sqrt(2.0 / 3.0)\n\n    def g(lam):\n        return (s_tr_norm\n                - 2.0 * mu * lam\n                - sqrt23 * (sigma_y0 + H * (1.0 - np.exp(-b * (alpha_n + sqrt23 * lam)))))\n\n    def gp(lam):\n        # g'(lam) = -2 mu - (2/3) H b exp(-b (alpha_n + sqrt(2/3) lam))\n        return -2.0 * mu - (2.0 / 3.0) * H * b * np.exp(-b * (alpha_n + sqrt23 * lam))\n\n    # Elastic check: if g(0) = 0, no plastic correction\n    g0 = g(0.0)\n    if g0 = 0.0:\n        return 0.0\n\n    # Bracketing: lower bound is 0, find upper bound with g(upper) = 0\n    # Start with a heuristic upper bound and expand until sign change.\n    # Heuristic: ignoring hardening saturation, lam_u0 ~ g0 / (2 mu)\n    lam_L = 0.0\n    lam_U = max(g0 / (2.0 * mu), 1e-16)\n    # Ensure lam_U within a reasonable range by expansion\n    # Since g(lam) - -inf as lam - +inf, this loop will terminate.\n    iter_expand = 0\n    while g(lam_U)  0.0 and iter_expand  1000:\n        lam_U *= 2.0\n        iter_expand += 1\n    if g(lam_U)  0.0:\n        # As a fallback, set a very large upper bound\n        lam_U = lam_U + 1.0\n        while g(lam_U)  0.0:\n            lam_U *= 2.0\n\n    # Initialize current iterate within bracket\n    lam = lam_L\n\n    # Merit function\n    def phi(lam):\n        val = g(lam)\n        return 0.5 * val * val\n\n    # Main safeguarded Newton iteration with line search\n    for _ in range(max_iter):\n        val = g(lam)\n        if abs(val) = tol:\n            break\n        # Newton direction p = -g / g'\n        deriv = gp(lam)\n        # If derivative is too small (shouldn't happen with mu0), fallback to bisection\n        if deriv == 0.0 or not np.isfinite(deriv):\n            lam_cand = 0.5 * (lam_L + lam_U)\n        else:\n            p = -val / deriv\n            lam_newton = lam + p\n            # If Newton candidate leaves the bracket, use bisection step\n            if lam_newton = lam_L or lam_newton = lam_U or not np.isfinite(lam_newton):\n                lam_cand = 0.5 * (lam_L + lam_U)\n            else:\n                # Backtracking line search along Newton direction\n                alpha = 1.0\n                phi_curr = phi(lam)\n                # Armijo condition: phi(lam + alpha p) = phi(lam) - c * alpha * g(lam)^2\n                # Also enforce bracket membership\n                while True:\n                    lam_trial = lam + alpha * p\n                    # Project into bracket if numerical noise causes crossing\n                    if lam_trial = lam_L or lam_trial = lam_U or (not np.isfinite(lam_trial)):\n                        # Reduce step if outside bracket\n                        alpha *= backtrack_factor\n                        if alpha  1e-16:\n                            lam_trial = 0.5 * (lam_L + lam_U)\n                            break\n                        continue\n                    phi_trial = phi(lam_trial)\n                    if phi_trial = phi_curr - armijo_c * alpha * (val * val):\n                        lam_cand = lam_trial\n                        break\n                    alpha *= backtrack_factor\n                    if alpha  1e-16:\n                        lam_cand = 0.5 * (lam_L + lam_U)\n                        break\n\n        # Update bracket\n        val_cand = g(lam_cand)\n        if val_cand  0.0:\n            lam_L = lam_cand\n        else:\n            lam_U = lam_cand\n        lam = lam_cand\n\n        # Secondary termination: bracket width small\n        if (lam_U - lam_L) = tol:\n            break\n\n    return lam\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case is (mu, ||s_tr||, sigma_y0, H, b, alpha_n)\n    test_cases = [\n        (80000.0, 600.0, 250.0, 1000.0, 10.0, 0.05),  # Case 1: general plastic\n        (80000.0, 500.0, 250.0, 1000.0, 10.0, 0.05),  # Case 2: elastic boundary\n        (80000.0, 600.0, 250.0, 0.0,    10.0, 0.05),  # Case 3: perfect plasticity (H=0)\n        (30000.0, 1200.0, 200.0, 1500.0, 200.0, 0.0), # Case 4: rapid saturation hardening\n    ]\n\n    results = []\n    for case in test_cases:\n        mu, s_tr_norm, sigma_y0, H, b, alpha_n = case\n        dlambda = compute_delta_lambda(mu, s_tr_norm, sigma_y0, H, b, alpha_n)\n        results.append(dlambda)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3596258"}]}