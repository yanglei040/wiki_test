{"hands_on_practices": [{"introduction": "Correctly implementing finite elements, especially high-order ones, requires careful attention to numerical integration. The complexity of the stiffness matrix integrand depends on both the element's polynomial approximation degree ($p$) and the geometry mapping. This exercise provides fundamental practice in analyzing the integrand to determine the minimum required quadrature order for exact integration, a crucial skill for writing efficient and accurate FEM code. [@problem_id:3569252]", "problem": "Consider the Finite Element Method (FEM) approximation of a two-dimensional (2D) linear elastic body using isoparametric quadrilateral elements. Let the parent coordinates be denoted by $(\\xi,\\eta)\\in[-1,1]\\times[-1,1]$, and let the mapping from the parent element to the physical element be polynomial of total degree $m$, with components $x(\\xi,\\eta)$ and $y(\\xi,\\eta)$ that are polynomials of total degree $m$. The element displacement interpolation uses tensor-product Lagrange shape functions of degree $p$ in each parent coordinate, so each shape function has the form $N_{a}(\\xi,\\eta)=L_{i}(\\xi)L_{j}(\\eta)$, where $L_{i}$ and $L_{j}$ are one-dimensional Lagrange polynomials of degree $p$. Assume the constitutive (elasticity) tensor $\\mathbf{C}$ is constant.\n\nThe stiffness matrix entry for nodes $a$ and $b$ is given by\n$$\nK_{ab}=\\int_{\\Omega_{e}}\\mathbf{B}_{a}^{\\mathsf{T}}\\mathbf{C}\\,\\mathbf{B}_{b}\\,\\mathrm{d}\\Omega,\n$$\nwhere $\\mathbf{B}_{a}$ is the strain-displacement matrix for node $a$ and $\\Omega_{e}$ is the physical element domain. Under the isoparametric mapping, this integral is evaluated over the parent domain as\n$$\nK_{ab}=\\int_{-1}^{1}\\int_{-1}^{1}\\mathbf{B}_{a}^{\\mathsf{T}}(\\xi,\\eta)\\,\\mathbf{C}\\,\\mathbf{B}_{b}(\\xi,\\eta)\\,\\det\\mathbf{J}(\\xi,\\eta)\\,\\mathrm{d}\\xi\\,\\mathrm{d}\\eta,\n$$\nwhere $\\mathbf{J}(\\xi,\\eta)$ is the Jacobian of the mapping and $\\det\\mathbf{J}(\\xi,\\eta)$ its determinant.\n\nUse tensor-product Gauss–Legendre quadrature of order $Q$ per coordinate. The one-dimensional Gauss–Legendre rule of order $Q$ integrates exactly any polynomial of degree at most $2Q-1$.\n\nStarting from the foundational definitions of the isoparametric mapping and the strain-displacement relation,\n- derive, for the case of an affine mapping $(m=1)$, the minimal integer quadrature order $Q$ per coordinate that guarantees exact integration of all stiffness matrix entries for the $Q_p$ element described above, by determining the maximal polynomial degree that appears in each parent coordinate within the integrand $\\mathbf{B}_{a}^{\\mathsf{T}}\\mathbf{C}\\,\\mathbf{B}_{b}\\,\\det\\mathbf{J}$.\n- then relate this to the curved mapping case $(m>1)$ by explicitly characterizing the integrand as a rational function in $(\\xi,\\eta)$ and stating the total bivariate polynomial degrees in the numerator and denominator in terms of $p$ and $m$.\n\nProvide your final answer as a single closed-form analytic expression $Q_{\\min}(p)$ giving the minimal quadrature order per coordinate for exact stiffness integration when $m=1$. No rounding is required. No units should be included in the final answer.", "solution": "The problem requires the determination of the minimal Gaussian quadrature order for the exact integration of the stiffness matrix of a $Q_p$ isoparametric element, first for an affine mapping ($m=1$) and then a characterization of the integrand for a general curved mapping ($m>1$).\n\nLet us begin by formally defining the components of the integrand for the stiffness matrix entry $K_{ab}$:\n$$\nK_{ab} = \\int_{-1}^{1}\\int_{-1}^{1} \\underbrace{\\mathbf{B}_{a}^{\\mathsf{T}}(\\xi,\\eta)\\,\\mathbf{C}\\,\\mathbf{B}_{b}(\\xi,\\eta)\\,\\det\\mathbf{J}(\\xi,\\eta)}_{I(\\xi, \\eta)} \\,\\mathrm{d}\\xi\\,\\mathrm{d}\\eta\n$$\nThe analysis hinges on determining the polynomial nature of the integrand $I(\\xi, \\eta)$. The elasticity tensor $\\mathbf{C}$ is a constant matrix. We must therefore analyze the strain-displacement matrix $\\mathbf{B}_a$ and the Jacobian determinant $\\det\\mathbf{J}$.\n\nThe displacement field is interpolated using tensor-product Lagrange shape functions $N_a(\\xi, \\eta)$ of degree $p$ in each parent coordinate $\\xi$ and $\\eta$. A generic shape function is of the form $N_a(\\xi, \\eta) = L_i(\\xi) L_j(\\eta)$, where $L_i$ and $L_j$ are one-dimensional Lagrange polynomials of degree $p$.\n\nThe strain vector in 2D is $\\boldsymbol{\\epsilon} = \\left( \\frac{\\partial u}{\\partial x}, \\frac{\\partial v}{\\partial y}, \\frac{\\partial u}{\\partial y} + \\frac{\\partial v}{\\partial x} \\right)^{\\mathsf{T}}$. The strain-displacement matrix $\\mathbf{B}_a$ for a node $a$ is defined such that $\\boldsymbol{\\epsilon} = \\sum_a \\mathbf{B}_a \\mathbf{d}_a$, where $\\mathbf{d}_a$ are the nodal displacements. The matrix for node $a$ is:\n$$\n\\mathbf{B}_a = \\begin{pmatrix}\n\\frac{\\partial N_a}{\\partial x} & 0 \\\\\n0 & \\frac{\\partial N_a}{\\partial y} \\\\\n\\frac{\\partial N_a}{\\partial y} & \\frac{\\partial N_a}{\\partial x}\n\\end{pmatrix}\n$$\nThe derivatives with respect to physical coordinates $(x,y)$ are related to derivatives in parent coordinates $(\\xi,\\eta)$ via the inverse of the Jacobian matrix $\\mathbf{J}$:\n$$\n\\begin{Bmatrix} \\frac{\\partial N_a}{\\partial x} \\\\ \\frac{\\partial N_a}{\\partial y} \\end{Bmatrix} = \\mathbf{J}^{-1} \\begin{Bmatrix} \\frac{\\partial N_a}{\\partial \\xi} \\\\ \\frac{\\partial N_a}{\\partial \\eta} \\end{Bmatrix}\n\\quad \\text{where} \\quad\n\\mathbf{J} = \\begin{pmatrix} \\frac{\\partial x}{\\partial \\xi} & \\frac{\\partial y}{\\partial \\xi} \\\\ \\frac{\\partial x}{\\partial \\eta} & \\frac{\\partial y}{\\partial \\eta} \\end{pmatrix}\n$$\nThe derivatives of the shape function $N_a(\\xi, \\eta) = L_i(\\xi) L_j(\\eta)$ are:\n- $\\frac{\\partial N_a}{\\partial \\xi} = L'_i(\\xi) L_j(\\eta)$: This is a polynomial of degree $p-1$ in $\\xi$ and degree $p$ in $\\eta$.\n- $\\frac{\\partial N_a}{\\partial \\eta} = L_i(\\xi) L'_j(\\eta)$: This is a polynomial of degree $p$ in $\\xi$ and degree $p-1$ in $\\eta$.\n\n**Part 1: Affine Mapping ($m=1$)**\n\nFor an affine mapping, the coordinate transformation is linear:\n$x(\\xi, \\eta) = c_0 + c_1 \\xi + c_2 \\eta$\n$y(\\xi, \\eta) = d_0 + d_1 \\xi + d_2 \\eta$\nThis corresponds to a polynomial mapping of total degree $m=1$.\nConsequently, the entries of the Jacobian matrix $\\mathbf{J}$ are constants:\n$\\frac{\\partial x}{\\partial \\xi} = c_1$, $\\frac{\\partial y}{\\partial \\xi} = d_1$, $\\frac{\\partial x}{\\partial \\eta} = c_2$, $\\frac{\\partial y}{\\partial \\eta} = d_2$.\nAs a result, both the Jacobian matrix $\\mathbf{J}$ and its determinant $\\det\\mathbf{J}$ are constant for a valid (non-degenerate) mapping. The inverse Jacobian matrix $\\mathbf{J}^{-1}$ is also a constant matrix.\n\nThe entries of $\\mathbf{B}_a$ are linear combinations of $\\frac{\\partial N_a}{\\partial \\xi}$ and $\\frac{\\partial N_a}{\\partial \\eta}$ with constant coefficients from $\\mathbf{J}^{-1}$. For example:\n$$\n\\frac{\\partial N_a}{\\partial x} = (\\mathbf{J}^{-1})_{11} \\frac{\\partial N_a}{\\partial \\xi} + (\\mathbf{J}^{-1})_{12} \\frac{\\partial N_a}{\\partial \\eta} = (\\mathbf{J}^{-1})_{11} L'_i(\\xi) L_j(\\eta) + (\\mathbf{J}^{-1})_{12} L_i(\\xi) L'_j(\\eta)\n$$\nThe polynomial degree in $\\xi$ of the first term is $p-1$, and of the second term is $p$. Assuming general non-zero coefficients, the degree of $\\frac{\\partial N_a}{\\partial x}$ in $\\xi$ is $p$. By symmetry, its degree in $\\eta$ is also $p$. The same holds for $\\frac{\\partial N_a}{\\partial y}$. Thus, for an affine mapping, each entry of the strain-displacement matrix $\\mathbf{B}_a$ is a polynomial of degree at most $p$ in $\\xi$ and at most $p$ in $\\eta$.\n\nThe kernel of the stiffness integrand is the scalar product $\\mathbf{B}_{a}^{\\mathsf{T}}\\mathbf{C}\\,\\mathbf{B}_{b}$. This is a sum of products of entries from $\\mathbf{B}_a$ and $\\mathbf{B}_b$. Consider a generic product of two such entries, $P(\\xi, \\eta) \\cdot Q(\\xi, \\eta)$. The degree of the product in a single variable is the sum of the degrees of the factors in that variable.\nWe must find the maximum possible polynomial degree of the full integrand $I(\\xi, \\eta) = \\mathbf{B}_{a}^{\\mathsf{T}}\\mathbf{C}\\,\\mathbf{B}_{b}\\,\\det\\mathbf{J}$ in each coordinate direction. Since $\\det\\mathbf{J}$ is constant, we only need to analyze $\\mathbf{B}_{a}^{\\mathsf{T}}\\mathbf{C}\\,\\mathbf{B}_{b}$.\n\nLet's examine the polynomial degree in the $\\xi$ coordinate. A term in the expansion of $\\mathbf{B}_{a}^{\\mathsf{T}}\\mathbf{C}\\,\\mathbf{B}_{b}$ involves a product of an entry of $\\mathbf{B}_a$ and an entry of $\\mathbf{B}_b$. For example, a term contributing to the integrand is proportional to $(\\frac{\\partial N_a}{\\partial y})(\\frac{\\partial N_b}{\\partial y})$.\n$$\n\\frac{\\partial N_a}{\\partial y} = (\\mathbf{J}^{-1})_{21} \\frac{\\partial N_a}{\\partial \\xi} + (\\mathbf{J}^{-1})_{22} \\frac{\\partial N_a}{\\partial \\eta} = (\\mathbf{J}^{-1})_{21} L'_i(\\xi) L_j(\\eta) + (\\mathbf{J}^{-1})_{22} L_i(\\xi) L'_j(\\eta)\n$$\nThe degree in $\\xi$ of this polynomial is $p$. The product $(\\frac{\\partial N_a}{\\partial y})(\\frac{\\partial N_b}{\\partial y})$ is formed by multiplying two such polynomials, corresponding to nodes $a$ and $b$. The highest degree term in $\\xi$ arises from the product of the terms with the highest degree in $\\xi$: $(L_i(\\xi) L'_j(\\eta)) \\cdot (L_k(\\xi) L'_l(\\eta))$, where $N_b(\\xi,\\eta)=L_k(\\xi)L_l(\\eta)$. The term $L_i(\\xi) L_k(\\xi)$ has degree $p+p=2p$ in $\\xi$.\nTherefore, the polynomial $\\mathbf{B}_{a}^{\\mathsf{T}}\\mathbf{C}\\,\\mathbf{B}_{b}$ has a maximum degree of $2p$ in $\\xi$. By symmetry, its maximum degree in $\\eta$ is also $2p$.\n\nA one-dimensional Gauss-Legendre quadrature rule with $Q$ points (order $Q$) integrates a polynomial of degree at most $2Q-1$ exactly. To exactly integrate the stiffness matrix, the quadrature rule must be sufficient for the highest polynomial degree encountered in each coordinate direction.\nFor the $\\xi$-direction, we require:\n$$\n2Q - 1 \\ge 2p\n$$\n$$\n2Q \\ge 2p + 1 \\implies Q \\ge p + \\frac{1}{2}\n$$\nSince the quadrature order $Q$ must be an integer, the minimal required order is $Q_{\\min} = p+1$. The same logic applies to the $\\eta$-direction. Thus, a tensor-product rule of $(p+1) \\times (p+1)$ points is required.\nThe minimal integer quadrature order per coordinate is $Q_{\\min}(p) = p+1$.\n\n**Part 2: Curved Mapping ($m>1$)**\n\nWhen the mapping is curved, the coordinate transformation $x(\\xi,\\eta), y(\\xi,\\eta)$ is given by polynomials of total bivariate degree $m > 1$.\n- The entries of the Jacobian matrix $\\mathbf{J}$ are partial derivatives of these polynomials, so they are polynomials of total degree at most $m-1$.\n- The determinant, $\\det\\mathbf{J} = \\frac{\\partial x}{\\partial \\xi}\\frac{\\partial y}{\\partial \\eta} - \\frac{\\partial y}{\\partial \\xi}\\frac{\\partial x}{\\partial \\eta}$, is a product of such polynomials, so it is a polynomial of total degree at most $(m-1) + (m-1) = 2m-2$.\n- The inverse Jacobian is $\\mathbf{J}^{-1} = (\\det\\mathbf{J})^{-1} \\text{adj}(\\mathbf{J})$. The adjugate matrix entries are polynomials of total degree at most $m-1$. Thus, the entries of $\\mathbf{J}^{-1}$ are rational functions: a numerator polynomial of total degree $\\le m-1$ divided by a denominator polynomial, $\\det\\mathbf{J}$, of total degree $\\le 2m-2$.\n- An entry of the strain-displacement matrix, e.g., $\\frac{\\partial N_a}{\\partial x}$, is given by $\\frac{1}{\\det\\mathbf{J}}(\\frac{\\partial y}{\\partial \\eta}\\frac{\\partial N_a}{\\partial \\xi} - \\frac{\\partial y}{\\partial \\xi}\\frac{\\partial N_a}{\\partial \\eta})$.\n    - The shape function derivatives $\\frac{\\partial N_a}{\\partial \\xi}$ and $\\frac{\\partial N_a}{\\partial \\eta}$ are polynomials of total degree up to $2p-1$.\n    - The numerator of the expression for $\\frac{\\partial N_a}{\\partial x}$ is a sum of products of a polynomial of total degree $\\le m-1$ and a polynomial of total degree $\\le 2p-1$. The resulting numerator is a polynomial of total degree at most $(m-1) + (2p-1) = 2p+m-2$.\n- The full integrand is $I(\\xi, \\eta) = \\mathbf{B}_{a}^{\\mathsf{T}}\\mathbf{C}\\,\\mathbf{B}_{b} \\det\\mathbf{J}$.\n    - A term in $\\mathbf{B}_{a}^{\\mathsf{T}}\\mathbf{C}\\,\\mathbf{B}_{b}$ is a product of two entries from the B-matrices. This product is a rational function with denominator $(\\det\\mathbf{J})^2$ and a numerator that is a product of two polynomials of total degree $\\le 2p+m-2$. The resulting numerator for this term has total degree $\\le 2(2p+m-2) = 4p+2m-4$.\n    - The sum $\\mathbf{B}_{a}^{\\mathsf{T}}\\mathbf{C}\\,\\mathbf{B}_{b}$ is therefore a rational function $\\frac{P_1(\\xi, \\eta)}{(P_2(\\xi, \\eta))^2}$ where $P_1$ has total degree $\\le 4p+2m-4$ and $P_2=\\det\\mathbf{J}$ has total degree $\\le 2m-2$.\n    - Multiplying by $\\det\\mathbf{J}$ gives the final integrand:\n      $$ I(\\xi, \\eta) = \\frac{P_1(\\xi, \\eta)}{\\det\\mathbf{J}} $$\nIn summary, for the curved mapping case ($m>1$), the integrand is a rational function where:\n- The numerator is a polynomial of total bivariate degree up to $4p+2m-4$.\n- The denominator is a polynomial of total bivariate degree up to $2m-2$.\nBecause the integrand is a rational function, Gauss-Legendre quadrature can no longer guarantee exact integration.\n\nThe final answer requested is for the affine case ($m=1$).", "answer": "$$\n\\boxed{p+1}\n$$", "id": "3569252"}, {"introduction": "One of the powerful features of $p$-refinement is its ability to overcome numerical pathologies like volumetric locking in nearly incompressible materials, an issue where low-order elements behave far too stiffly. This hands-on coding exercise challenges you to investigate this phenomenon directly by comparing a standard implementation with a Selective Reduced Integration (SRI) scheme. By quantifying the polynomial degree $p$ needed to achieve a lock-free solution, you will gain tangible insight into the practical effectiveness of high-order methods. [@problem_id:3569277]", "problem": "Consider a two-dimensional plane-strain hyperelastic block occupying the domain $[0,1]\\times[0,1]$ meters. The material follows a compressible Neo-Hookean model, which in the small-strain limit reduces to linear elasticity with Lamé parameters $\\lambda$ and $\\mu$ given by $\\mu = E/(2(1+\\nu))$ and $\\lambda = \\nu E/((1+\\nu)(1-2\\nu))$, where $E$ is the Young's modulus and $\\nu$ is the Poisson's ratio. Take $E = 1$ Pascal and study the nearly incompressible limit as $\\nu \\to 0.5$. Volumetric locking is a known numerical pathology in the Finite Element Method (FEM) for nearly incompressible materials. One mitigation technique is Selective Reduced Integration (SRI), which evaluates the volumetric contribution to the stiffness with reduced quadrature while keeping the deviatoric contribution fully integrated.\n\nYou will implement a finite element solver on a fixed mesh of $2\\times 2$ quadrilateral elements with a tensor-product Lagrange polynomial basis of degree $p$ per element (denoted $Q_p$). The mesh is built over the unit square domain with straight edges. The geometry mapping is bilinear. The displacement field has two components, and plane-strain is assumed.\n\nBoundary conditions and loading are as follows:\n- The left edge at $x=0$ is clamped: $u_x=0$ and $u_y=0$.\n- A uniform shear traction is applied on the right edge at $x=1$, with traction $\\mathbf{t} = [0, t_0]$ Newton per meter, where $t_0 = 1$. All other edges are traction-free.\n\nThe constitutive law in the small-strain limit is the plane-strain linear elastic tensor $\\mathbf{D}$ acting on the strain vector $\\boldsymbol{\\varepsilon} = [\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy}]^T$ such that the stress vector $\\boldsymbol{\\sigma} = \\mathbf{D}\\boldsymbol{\\varepsilon}$. Write\n$$\n\\mathbf{D} = \\mathbf{D}_{\\text{dev}} + \\mathbf{D}_{\\text{vol}},\n$$\nwith\n$$\n\\mathbf{D}_{\\text{dev}} = \\begin{bmatrix} 2\\mu & 0 & 0 \\\\ 0 & 2\\mu & 0 \\\\ 0 & 0 & \\mu \\end{bmatrix}, \\quad\n\\mathbf{D}_{\\text{vol}} = \\begin{bmatrix} \\lambda & \\lambda & 0 \\\\ \\lambda & \\lambda & 0 \\\\ 0 & 0 & 0 \\end{bmatrix}.\n$$\nSelective Reduced Integration (SRI) is implemented by integrating the stiffness contribution from $\\mathbf{D}_{\\text{dev}}$ with a Gauss-Legendre quadrature of sufficient order for $Q_p$, and integrating the contribution from $\\mathbf{D}_{\\text{vol}}$ with a single Gauss point at the element center. Full integration uses the same sufficiently accurate Gauss-Legendre quadrature for the entire $\\mathbf{D}$.\n\nLet $u_{\\text{tip}}(p,\\nu)$ denote the vertical displacement at the top-right corner $(x=1,y=1)$ computed with full integration for polynomial degree $p$ and Poisson's ratio $\\nu$. Let $u_{\\text{tip}}^{\\text{SRI}}(p_{\\max},\\nu)$ denote the same quantity computed using SRI with a high polynomial degree $p_{\\max}$, which will serve as a lock-free reference. Define the relative discrepancy\n$$\n\\delta(p,\\nu) = \\left|\\frac{u_{\\text{tip}}(p,\\nu) - u_{\\text{tip}}^{\\text{SRI}}(p_{\\max},\\nu)}{u_{\\text{tip}}^{\\text{SRI}}(p_{\\max},\\nu)}\\right|.\n$$\nFor a fixed $\\nu$, define the threshold polynomial degree $p_{\\text{lock-free}}(\\nu)$ to be the smallest $p$ in the set $\\{1,2,3,4,5,6\\}$ such that $\\delta(p,\\nu) \\le \\tau$, where the tolerance is $\\tau = 0.02$. If no such $p$ exists in the set, report $-1$.\n\nStarting from the balance of linear momentum in the absence of body forces and the small-strain kinematics,\n$$\n\\nabla\\cdot \\boldsymbol{\\sigma} = \\mathbf{0}, \\quad \\boldsymbol{\\varepsilon} = \\frac{1}{2}(\\nabla \\mathbf{u} + (\\nabla \\mathbf{u})^T),\n$$\nderive the discrete finite element equations and implement the assembly of the global stiffness matrix and load vector for both full integration and SRI on the specified mesh. Use Gauss-Legendre quadrature with $n=p$ points per direction for full integration of $Q_p$ elements. Apply the specified boundary conditions, solve the resulting linear systems, and extract $u_{\\text{tip}}$ and $u_{\\text{tip}}^{\\text{SRI}}$.\n\nExpress any displacements internally in meters, but the final output must be unitless integers as described below. The angle unit is not applicable in this problem.\n\nTest Suite:\n- Case $1$: $\\nu = 0.30$.\n- Case $2$: $\\nu = 0.49$.\n- Case $3$: $\\nu = 0.499$.\n- Case $4$: $\\nu = 0.4999$.\n\nFor all cases use $E = 1$ and $t_0 = 1$ as specified. Use $p_{\\max} = 6$ to compute $u_{\\text{tip}}^{\\text{SRI}}$. For each test case, compute $p_{\\text{lock-free}}(\\nu)$ as defined, with the tolerance $\\tau = 0.02$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets in the order of the test suite, i.e., $[p_{\\text{lock-free}}(0.30), p_{\\text{lock-free}}(0.49), p_{\\text{lock-free}}(0.499), p_{\\text{lock-free}}(0.4999)]$.", "solution": "The problem is valid as it is scientifically grounded in the principles of computational solid mechanics, is well-posed, and all necessary parameters and conditions are objectively specified. We will proceed with a detailed solution based on the Finite Element Method (FEM).\n\nThe governing equation for static equilibrium in the absence of body forces is the balance of linear momentum:\n$$\n\\nabla \\cdot \\boldsymbol{\\sigma} = \\mathbf{0} \\quad \\text{in } \\Omega\n$$\nwhere $\\boldsymbol{\\sigma}$ is the Cauchy stress tensor and $\\Omega = [0,1] \\times [0,1]$ is the domain. The problem specifies boundary conditions on the displacement $\\mathbf{u}$ and traction $\\mathbf{t} = \\boldsymbol{\\sigma} \\cdot \\mathbf{n}$.\nThe relationship between strain $\\boldsymbol{\\varepsilon}$ and displacement $\\mathbf{u}$ is given by the small-strain kinematics:\n$$\n\\boldsymbol{\\varepsilon} = \\frac{1}{2}(\\nabla \\mathbf{u} + (\\nabla \\mathbf{u})^T)\n$$\nThe material follows a linear elastic constitutive law $\\boldsymbol{\\sigma} = \\mathbf{D} \\boldsymbol{\\varepsilon}$, where for plane strain, the stress and strain vectors are $\\boldsymbol{\\sigma} = [\\sigma_{xx}, \\sigma_{yy}, \\tau_{xy}]^T$ and $\\boldsymbol{\\varepsilon} = [\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy}]^T$. The plane strain stiffness matrix $\\mathbf{D}$ is:\n$$\n\\mathbf{D} = \\begin{bmatrix} \\lambda+2\\mu & \\lambda & 0 \\\\ \\lambda & \\lambda+2\\mu & 0 \\\\ 0 & 0 & \\mu \\end{bmatrix}\n$$\nwhere $\\lambda$ and $\\mu$ are the Lamé parameters, defined in terms of Young's modulus $E$ and Poisson's ratio $\\nu$.\n\nThe weak form of the governing equation is derived by multiplying by a test function $\\mathbf{v}$ (representing a virtual displacement) and integrating over the domain $\\Omega$:\n$$\n\\int_{\\Omega} (\\nabla \\cdot \\boldsymbol{\\sigma}) \\cdot \\mathbf{v} \\, d\\Omega = 0\n$$\nUsing the divergence theorem and the symmetry of the stress tensor, this leads to the principle of virtual work:\n$$\n\\int_{\\Omega} \\boldsymbol{\\sigma} : \\boldsymbol{\\varepsilon}(\\mathbf{v}) \\, d\\Omega = \\int_{\\Gamma_t} \\mathbf{t} \\cdot \\mathbf{v} \\, d\\Gamma\n$$\nwhere $\\boldsymbol{\\varepsilon}(\\mathbf{v})$ is the strain derived from the test function $\\mathbf{v}$, and the right-hand side represents the work done by external tractions on the boundary $\\Gamma_t$.\n\nIn the finite element method, the domain $\\Omega$ is discretized into elements $\\Omega_e$. Within each element, the displacement field $\\mathbf{u}$ is approximated as:\n$$\n\\mathbf{u}(\\mathbf{x}) \\approx \\mathbf{u}^h(\\mathbf{x}) = \\sum_{a=1}^{N_{en}} N_a(\\mathbf{x}) \\mathbf{d}_a\n$$\nwhere $N_a$ are the shape functions, $\\mathbf{d}_a = [d_{ax}, d_{ay}]^T$ is the vector of nodal displacements for the $a$-th node of the element, and $N_{en}$ is the number of nodes per element. For $Q_p$ elements, $N_{en} = (p+1)^2$. The test function $\\mathbf{v}$ is approximated similarly.\n\nThe strain vector can then be expressed in terms of the nodal displacements:\n$$\n\\boldsymbol{\\varepsilon} = \\sum_{a=1}^{N_{en}} \\mathbf{B}_a \\mathbf{d}_a\n$$\nwhere the matrix $\\mathbf{B}_a$ relates strain to nodal displacement and contains derivatives of the shape functions:\n$$\n\\mathbf{B}_a = \\begin{bmatrix} \\frac{\\partial N_a}{\\partial x} & 0 \\\\ 0 & \\frac{\\partial N_a}{\\partial y} \\\\ \\frac{\\partial N_a}{\\partial y} & \\frac{\\partial N_a}{\\partial x} \\end{bmatrix}\n$$\nThe derivatives are computed using the chain rule and the Jacobian of the isoparametric coordinate transformation from the reference element $[-1,1]^2$ with coordinates $(\\xi, \\eta)$ to the physical element. For the specified straight-edged rectangular mesh, this Jacobian is constant within each element.\n\nSubstituting the discretized fields into the weak form and noting that it must hold for any valid choice of virtual nodal displacements leads to a system of linear equations for each element:\n$$\n\\mathbf{k}^e \\mathbf{d}^e = \\mathbf{f}^e\n$$\nThe element stiffness matrix $\\mathbf{k}^e$ and force vector $\\mathbf{f}^e$ are given by:\n$$\n\\mathbf{k}^e = \\int_{\\Omega_e} \\mathbf{B}^T \\mathbf{D} \\mathbf{B} \\, d\\Omega, \\quad \\mathbf{f}^e = \\int_{\\Gamma_e} \\mathbf{N}^T \\mathbf{t} \\, d\\Gamma\n$$\nwhere $\\mathbf{B}$ and $\\mathbf{N}$ are matrices collecting the contributions from all nodes in the element.\n\nThe integrals are computed numerically using Gauss-Legendre quadrature. For full integration, the element stiffness matrix is:\n$$\n\\mathbf{k}^e_{\\text{full}} = \\sum_{i=1}^{n_{gp}} w_i (\\mathbf{B}(\\boldsymbol{\\xi}_i))^T \\mathbf{D} \\mathbf{B}(\\boldsymbol{\\xi}_i) |\\mathbf{J}(\\boldsymbol{\\xi}_i)|\n$$\nwhere $\\boldsymbol{\\xi}_i$ are the Gauss points, $w_i$ are the weights, $|\\mathbf{J}|$ is the determinant of the Jacobian, and $n_{gp}=p \\times p$ is the number of Gauss points.\n\nFor Selective Reduced Integration (SRI), the stiffness matrix $\\mathbf{D}$ is split into a deviatoric part $\\mathbf{D}_{\\text{dev}}$ and a volumetric part $\\mathbf{D}_{\\text{vol}}$ as defined in the problem. The element stiffness is computed as:\n$$\n\\mathbf{k}^e_{\\text{SRI}} = \\mathbf{k}^e_{\\text{dev}} + \\mathbf{k}^e_{\\text{vol}}\n$$\n$$\n\\mathbf{k}^e_{\\text{dev}} = \\sum_{i=1}^{n_{gp}} w_i (\\mathbf{B}(\\boldsymbol{\\xi}_i))^T \\mathbf{D}_{\\text{dev}} \\mathbf{B}(\\boldsymbol{\\xi}_i) |\\mathbf{J}(\\boldsymbol{\\xi}_i)|\n$$\n$$\n\\mathbf{k}^e_{\\text{vol}} = \\left( \\sum_{j=1}^{1} w_j |\\mathbf{J}(\\boldsymbol{\\xi}_j)| \\right) (\\bar{\\mathbf{B}})^T \\mathbf{D}_{\\text{vol}} \\bar{\\mathbf{B}}\n$$\nwhere the deviatoric part is integrated with the full $p \\times p$ quadrature rule, and the volumetric part is integrated with a single point at the element center $(\\xi_j=(0,0))$. $\\bar{\\mathbf{B}}$ is the $\\mathbf{B}$ matrix evaluated at this center point.\n\nThe global stiffness matrix $\\mathbf{K}$ and force vector $\\mathbf{F}$ are assembled by summing the contributions from all four elements. The specified boundary conditions are then applied. The clamped condition ($u_x=u_y=0$) at $x=0$ is an essential boundary condition, enforced by modifying the linear system. The shear traction at $x=1$ is a natural boundary condition, handled by assembling the element force vectors $\\mathbf{f}^e$ for the elements on that boundary.\n\nAfter enforcing the boundary conditions, the global linear system $\\mathbf{K}\\mathbf{d}=\\mathbf{F}$ is solved for the vector of all nodal displacements $\\mathbf{d}$. The required vertical tip displacement $u_{\\text{tip}}$ is then extracted from $\\mathbf{d}$ at the node corresponding to physical coordinates $(1,1)$.\n\nThe procedure is as follows:\n1. For each $\\nu$ in the test suite, calculate the reference displacement $u_{\\text{tip}}^{\\text{SRI}}(p_{\\max},\\nu)$ by running the FEM solver with $p=p_{\\max}=6$ and SRI.\n2. For the same $\\nu$, loop through $p \\in \\{1, 2, 3, 4, 5, 6\\}$.\n3. In each iteration, compute $u_{\\text{tip}}(p, \\nu)$ using full integration.\n4. Calculate the relative discrepancy $\\delta(p,\\nu)$.\n5. The first value of $p$ for which $\\delta(p, \\nu)$ is less than or equal to the tolerance $\\tau=0.02$ is recorded as $p_{\\text{lock-free}}(\\nu)$. If no such $p$ is found, the result is $-1$.\nThis process is repeated for all values of $\\nu$ in the test suite to generate the final output list.", "answer": "```python\nimport numpy as np\nfrom scipy.special import roots_legendre\n\ndef solve():\n    \"\"\"\n    Main driver function to solve the problem for the given test suite.\n    \"\"\"\n\n    def get_lagrange_basis(p, xi, nodes):\n        \"\"\"\n        Computes 1D Lagrange basis functions of degree p and their derivatives.\n        \"\"\"\n        n_nodes = p + 1\n        N = np.zeros(n_nodes)\n        dN_dxi = np.zeros(n_nodes)\n        \n        for i in range(n_nodes):\n            num = 1.0\n            den = 1.0\n            dnum = 0.0\n            \n            for j in range(n_nodes):\n                if i != j:\n                    num *= (xi - nodes[j])\n                    den *= (nodes[i] - nodes[j])\n            \n            for m in range(n_nodes):\n                if m != i:\n                    term = 1.0\n                    for j in range(n_nodes):\n                        if j != i and j != m:\n                            term *= (xi - nodes[j])\n                    dnum += term\n            \n            N[i] = num / den\n            dN_dxi[i] = dnum / den\n            \n        return N, dN_dxi\n\n    def solve_fem(p, nu, integration_type):\n        \"\"\"\n        A general FEM solver for the 2D plane strain problem.\n        p: polynomial degree of the Q_p element.\n        nu: Poisson's ratio.\n        integration_type: 'full' or 'sri'.\n        \"\"\"\n        E = 1.0\n        t0 = 1.0\n        \n        # Material properties\n        mu = E / (2 * (1 + nu))\n        lmbda = (E * nu) / ((1 + nu) * (1 - 2 * nu))\n\n        D_dev = np.array([[2 * mu, 0, 0], [0, 2 * mu, 0], [0, 0, mu]])\n        D_vol = np.array([[lmbda, lmbda, 0], [lmbda, lmbda, 0], [0, 0, 0]])\n        D_full = D_dev + D_vol\n\n        # Mesh properties\n        nels_x, nels_y = 2, 2\n        domain_size_x, domain_size_y = 1.0, 1.0\n        el_size_x = domain_size_x / nels_x\n        el_size_y = domain_size_y / nels_y\n\n        nnodes_x = nels_x * p + 1\n        nnodes_y = nels_y * p + 1\n        num_nodes = nnodes_x * nnodes_y\n        num_dofs = 2 * num_nodes\n\n        # Node coordinates\n        x_coords = np.linspace(0, domain_size_x, nnodes_x)\n        y_coords = np.linspace(0, domain_size_y, nnodes_y)\n        node_coords = np.array([[x, y] for y in y_coords for x in x_coords])\n\n        # Connectivity\n        num_el_nodes = (p + 1) ** 2\n        connectivity = np.zeros((nels_x * nels_y, num_el_nodes), dtype=int)\n        for el_y in range(nels_y):\n            for el_x in range(nels_x):\n                el_idx = el_y * nels_x + el_x\n                local_node_idx = 0\n                for j in range(p + 1):\n                    for i in range(p + 1):\n                        global_ix = el_x * p + i\n                        global_iy = el_y * p + j\n                        connectivity[el_idx, local_node_idx] = global_iy * nnodes_x + global_ix\n                        local_node_idx += 1\n        \n        # Quadrature points and weights\n        if integration_type == 'full':\n            pts_full, w_full = roots_legendre(p)\n            n_gp_full = p\n        elif integration_type == 'sri':\n            pts_full, w_full = roots_legendre(p)\n            n_gp_full = p\n            pts_red, w_red = np.array([0.0]), np.array([2.0]) # 1 point rule\n            n_gp_red = 1\n        \n        # Basis functions reference nodes\n        basis_nodes = np.linspace(-1, 1, p + 1)\n\n        # Assembly\n        K = np.zeros((num_dofs, num_dofs))\n        F = np.zeros(num_dofs)\n\n        for el_idx in range(nels_x * nels_y):\n            k_e = np.zeros((num_el_nodes * 2, num_el_nodes * 2))\n            \n            # Jacobian (constant for this mesh)\n            J = np.array([[el_size_x / 2, 0], [0, el_size_y / 2]])\n            detJ = np.linalg.det(J)\n            invJ = np.linalg.inv(J)\n\n            def assemble_stiffness(pts, w, D_mat):\n                k_mat = np.zeros((num_el_nodes * 2, num_el_nodes * 2))\n                for pt_y, w_y in zip(pts, w):\n                    for pt_x, w_x in zip(pts, w):\n                        N_1d_xi, dN_dxi_1d = get_lagrange_basis(p, pt_x, basis_nodes)\n                        N_1d_eta, dN_deta_1d = get_lagrange_basis(p, pt_y, basis_nodes)\n                        \n                        B = np.zeros((3, num_el_nodes * 2))\n                        for j in range(p + 1):\n                            for i in range(p + 1):\n                                node_idx = j * (p + 1) + i\n                                \n                                dN_dxi = dN_dxi_1d[i] * N_1d_eta[j]\n                                dN_deta = N_1d_xi[i] * dN_deta_1d[j]\n                                \n                                dN_dxy = invJ @ np.array([dN_dxi, dN_deta])\n                                \n                                B[0, 2 * node_idx] = dN_dxy[0]\n                                B[1, 2 * node_idx + 1] = dN_dxy[1]\n                                B[2, 2 * node_idx] = dN_dxy[1]\n                                B[2, 2 * node_idx + 1] = dN_dxy[0]\n                        k_mat += B.T @ D_mat @ B * detJ * w_x * w_y\n                return k_mat\n\n            if integration_type == 'full':\n                k_e = assemble_stiffness(pts_full, w_full, D_full)\n            elif integration_type == 'sri':\n                k_dev = assemble_stiffness(pts_full, w_full, D_dev)\n                \n                # Reduced integration for volumetric part (B-bar method)\n                # B at center (0,0)\n                N_1d_xi_c, dN_dxi_1d_c = get_lagrange_basis(p, 0.0, basis_nodes)\n                N_1d_eta_c, dN_deta_1d_c = get_lagrange_basis(p, 0.0, basis_nodes)\n                B_bar = np.zeros((3, num_el_nodes * 2))\n                for j in range(p + 1):\n                    for i in range(p + 1):\n                        node_idx = j * (p + 1) + i\n                        dN_dxi = dN_dxi_1d_c[i] * N_1d_eta_c[j]\n                        dN_deta = N_1d_xi_c[i] * dN_deta_1d_c[j]\n                        dN_dxy = invJ @ np.array([dN_dxi, dN_deta])\n                        B_bar[0, 2*node_idx] = dN_dxy[0]\n                        B_bar[1, 2*node_idx+1] = dN_dxy[1]\n                        B_bar[2, 2*node_idx] = dN_dxy[1]\n                        B_bar[2, 2*node_idx+1] = dN_dxy[0]\n                k_vol = B_bar.T @ D_vol @ B_bar * detJ * 4.0 # weight is 2*2=4\n                \n                k_e = k_dev + k_vol\n\n            # Assemble into global K\n            dof_indices = np.array([[2 * n, 2 * n + 1] for n in connectivity[el_idx, :]]).flatten()\n            K[np.ix_(dof_indices, dof_indices)] += k_e\n\n        # Apply traction BC on the right edge (x=1)\n        traction = np.array([0, t0])\n        q_pts_1d, q_w_1d = roots_legendre(p)\n        for el_y in range(nels_y):\n            el_idx = el_y * nels_x + (nels_x - 1)\n            f_e = np.zeros(num_el_nodes * 2)\n            \n            for pt_eta, w_eta in zip(q_pts_1d, q_w_1d):\n                N_1d_xi, _ = get_lagrange_basis(p, 1.0, basis_nodes) # edge at xi=1\n                N_1d_eta, _ = get_lagrange_basis(p, pt_eta, basis_nodes)\n                \n                for j in range(p + 1):\n                    for i in range(p + 1):\n                        node_idx = j * (p + 1) + i\n                        N_val = N_1d_xi[i] * N_1d_eta[j]\n                        f_e[2*node_idx:2*node_idx+2] += N_val * traction * (el_size_y/2) * w_eta\n            \n            dof_indices = np.array([[2 * n, 2 * n + 1] for n in connectivity[el_idx, :]]).flatten()\n            F[dof_indices] += f_e\n\n        # Apply displacement BC on the left edge (x=0)\n        fixed_dofs = []\n        for j in range(nnodes_y):\n            node_id = j * nnodes_x\n            fixed_dofs.append(2 * node_id)\n            fixed_dofs.append(2 * node_id + 1)\n        \n        K_bc = np.copy(K)\n        F_bc = np.copy(F)\n        for dof in fixed_dofs:\n            K_bc[dof, :] = 0\n            K_bc[:, dof] = 0\n            K_bc[dof, dof] = 1\n            F_bc[dof] = 0\n\n        # Solve\n        u = np.linalg.solve(K_bc, F_bc)\n\n        # Extract tip displacement\n        tip_node_id = nnodes_y * nnodes_x - 1\n        tip_dof_y = 2 * tip_node_id + 1\n        return u[tip_dof_y]\n\n    # --- Main Test Execution ---\n    test_cases = [0.30, 0.49, 0.499, 0.4999]\n    p_max = 6\n    tau = 0.02\n    p_values = range(1, 7)\n    \n    results = []\n    \n    for nu in test_cases:\n        p_lock_free = -1\n\n        # Compute reference solution\n        u_ref = solve_fem(p=p_max, nu=nu, integration_type='sri')\n\n        for p in p_values:\n            u_tip = solve_fem(p=p, nu=nu, integration_type='full')\n            \n            if abs(u_ref) > 1e-12:\n                delta = abs((u_tip - u_ref) / u_ref)\n            else: # to handle case where u_ref might be zero\n                delta = abs(u_tip)\n\n            if delta <= tau:\n                p_lock_free = p\n                break\n        \n        results.append(p_lock_free)\n    \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3569277"}, {"introduction": "The ultimate goal of these methods is often automated $hp$-adaptivity, where the code intelligently chooses between refining the mesh size ($h$) or increasing the polynomial order ($p$). This decision hinges on estimating the local smoothness of the exact solution from the computed approximation. This exercise guides you through the theoretical development of a powerful indicator based on the decay rate of hierarchical polynomial coefficients, allowing you to distinguish between smooth solutions (where $p$-refinement excels) and singular solutions (where $h$-refinement is necessary). [@problem_id:3569257]", "problem": "Consider a one-dimensional linear elasticity model problem over a mesh of elements, where on each element the local finite element approximation is expressed in a hierarchical orthonormal polynomial basis (for example, normalized Legendre polynomials) as $u_h(x)|_E = \\sum_{k=0}^{p} a_k \\,\\phi_k(x)$, with coefficients $\\{a_k\\}$ computed by orthogonal projection. In adaptive mesh size-refinement (h-refinement) and polynomial-degree refinement (p-refinement) within the Finite Element Method (FEM), a common strategy is to infer the local regularity of the exact solution from the decay of the hierarchical coefficients $\\{|a_k|\\}$ on each element.\n\nUse the following well-tested facts from spectral approximation theory as the fundamental base:\n- If the exact solution is analytic in a neighborhood of the element, then the modal coefficients admit the asymptotic form $|a_k| \\sim C \\,\\rho^{-k} k^{\\sigma}$ for some constants $C>0$, $\\rho>1$, and $\\sigma \\in \\mathbb{R}$, for sufficiently large $k$.\n- If the exact solution has only finite Sobolev regularity locally (for example, due to a nearby singularity) with $|a_k| \\sim C' \\, k^{-\\beta}$ for some constants $C'>0$ and $\\beta>0$, then the decay is algebraic.\n\nOn an element $E$ where the current polynomial degree is $p \\geq 3$, you have access only to the last three nonzero modal magnitudes $\\{|a_{p-2}|, |a_{p-1}|, |a_p|\\}$. Your tasks are:\n- Starting from the asymptotic models above, construct a dimensionless indicator $\\Psi_p$ that uses only $\\{|a_{p-2}|, |a_{p-1}|, |a_p|\\}$ and that asymptotically converges to a strictly positive constant for analytic behavior and to zero for algebraic behavior, thereby enabling a reliable local decision between h-refinement and p-refinement without any unknown scale factors such as $C$ or $C'$.\n- From your construction, derive a closed-form expression for the critical discrimination threshold $T_{\\star}$ such that, asymptotically, $\\Psi_p \\to T_{\\star}$ for algebraic decay while $\\Psi_p \\to T_{\\star} + \\Delta$ with $\\Delta>0$ for analytic decay. State the refinement logic in words, but your final answer must be the single closed-form value of $T_{\\star}$.\n\nExpress your indicator and intermediate reasoning entirely in terms of $\\{|a_{p-2}|, |a_{p-1}|, |a_p|\\}$ and $p$. No other data may be used. The final answer must be a single real number. No rounding is required.", "solution": "The problem requires the construction of a dimensionless indicator, $\\Psi_p$, to distinguish between algebraic and analytic solution behavior based on the asymptotic decay of hierarchical finite element coefficients. This indicator must be a function of the last three available coefficient magnitudes, $\\{|a_{p-2}|, |a_{p-1}|, |a_p|\\}$, and the polynomial degree $p$. From this construction, we must derive the critical discrimination threshold, $T_{\\star}$.\n\nThe two types of asymptotic decay are given as:\n1.  **Analytic behavior:** $|a_k| \\sim C \\rho^{-k} k^{\\sigma}$ for constants $C>0$, $\\rho>1$, $\\sigma \\in \\mathbb{R}$. This is an exponential decay, dominated by the $\\rho^{-k}$ term.\n2.  **Algebraic behavior:** $|a_k| \\sim C' k^{-\\beta}$ for constants $C'>0$, $\\beta>0$.\n\nA robust method to distinguish these two behaviors is to analyze the properties of the sequence of coefficients on a logarithmic scale. Let us consider the relationship between $\\ln|a_k|$ and $\\ln k$.\n\nFor algebraic decay, we have:\n$$ \\ln|a_k| \\sim \\ln(C' k^{-\\beta}) = \\ln C' - \\beta \\ln k $$\nThis indicates a linear relationship between $\\ln|a_k|$ and $\\ln k$ for large $k$, with a slope of $-\\beta$.\n\nFor analytic decay, we have:\n$$ \\ln|a_k| \\sim \\ln(C \\rho^{-k} k^{\\sigma}) = \\ln C - k \\ln \\rho + \\sigma \\ln k $$\nThis relationship is not linear in $\\ln k$ due to the presence of the term $-k \\ln \\rho$.\n\nThis difference in linearity on a log-log plot provides a basis for our indicator. A straight line has zero curvature. We can construct an indicator that approximates the curvature of the sequence $(\\ln k, \\ln|a_k|)$. Let us define a discrete slope, $S_k$, on the log-log plot using a finite difference:\n$$ S_k = \\frac{\\ln|a_k| - \\ln|a_{k-1}|}{\\ln k - \\ln(k-1)} = \\frac{\\ln(|a_k|/|a_{k-1}|)}{\\ln(k/(k-1))} $$\nFor a pure algebraic decay $|a_k| = C'k^{-\\beta}$, this slope is constant:\n$$ S_k = \\frac{\\ln((C'k^{-\\beta})/(C'(k-1)^{-\\beta}))}{\\ln(k/(k-1))} = \\frac{-\\beta \\ln(k/(k-1))}{\\ln(k/(k-1))} = -\\beta $$\nA discrete measure of curvature can be formed by taking the difference of consecutive slopes, $S_{p-1}$ and $S_p$. To satisfy the problem's requirement that the indicator be positive for the analytic case, we define our indicator $\\Psi_p$ as:\n$$ \\Psi_p = S_{p-1} - S_p = \\frac{\\ln(|a_{p-1}|/|a_{p-2}|)}{\\ln((p-1)/(p-2))} - \\frac{\\ln(|a_p|/|a_{p-1}|)}{\\ln(p/(p-1))} $$\nThis indicator is dimensionless and uses the three specified coefficient magnitudes $\\{|a_{p-2}|, |a_{p-1}|, |a_p|\\}$ and the degree $p$.\n\nNow, we analyze the asymptotic behavior of $\\Psi_p$ for large $p$ in both scenarios.\n\n**Case 1: Algebraic Decay**\nAs established, for the model $|a_k| = C' k^{-\\beta}$, we have $S_k = -\\beta$ for all $k$. Therefore, for this idealized model,\n$$ \\Psi_p = S_{p-1} - S_p = (-\\beta) - (-\\beta) = 0 $$\nFor the asymptotic form $|a_k| \\sim C'k^{-\\beta}$, higher-order terms in the asymptotic expansion would cause $\\Psi_p$ to approach $0$ as $p \\to \\infty$. Thus, for algebraic decay, the asymptotic limit is $0$.\n$$ \\lim_{p\\to\\infty} \\Psi_p = 0 $$\n\n**Case 2: Analytic Decay**\nFor analytic decay, $|a_k| \\sim C \\rho^{-k} k^{\\sigma}$. The slope $S_k$ is:\n$$ S_k = \\frac{\\ln((C\\rho^{-k}k^{\\sigma})/(C\\rho^{-(k-1)}(k-1)^{\\sigma}))}{\\ln(k/(k-1))} = \\frac{-\\ln\\rho + \\sigma\\ln(k/(k-1))}{\\ln(k/(k-1))} = \\sigma - \\frac{\\ln\\rho}{\\ln(k/(k-1))} $$\nThe indicator $\\Psi_p$ is then:\n$$ \\Psi_p = S_{p-1} - S_p = \\left(\\sigma - \\frac{\\ln\\rho}{\\ln((p-1)/(p-2))}\\right) - \\left(\\sigma - \\frac{\\ln\\rho}{\\ln(p/(p-1))}\\right) = \\ln\\rho \\left( \\frac{1}{\\ln(p/(p-1))} - \\frac{1}{\\ln((p-1)/(p-2))} \\right) $$\nTo find the limit as $p \\to \\infty$, we analyze the term $f(k) = 1/\\ln(k/(k-1))$. Let $x = 1/(k-1)$. As $k \\to \\infty$, $x \\to 0$.\n$$ \\ln\\left(\\frac{k}{k-1}\\right) = \\ln\\left(1+\\frac{1}{k-1}\\right) = \\ln(1+x) = x - \\frac{x^2}{2} + O(x^3) $$\n$$ f(k) = \\frac{1}{x - \\frac{x^2}{2} + O(x^3)} = \\frac{1}{x} \\left( \\frac{1}{1 - \\frac{x}{2} + O(x^2)} \\right) = \\frac{1}{x} \\left( 1 + \\frac{x}{2} + O(x^2) \\right) = \\frac{1}{x} + \\frac{1}{2} + O(x) $$\nSubstituting back $x = 1/(k-1)$:\n$$ f(k) = (k-1) + \\frac{1}{2} + O\\left(\\frac{1}{k}\\right) = k - \\frac{1}{2} + O\\left(\\frac{1}{k}\\right) $$\nNow we can evaluate the limit of $\\Psi_p$:\n$$ \\lim_{p\\to\\infty} \\Psi_p = \\lim_{p\\to\\infty} \\ln\\rho \\left( f(p) - f(p-1) \\right) $$\n$$ \\lim_{p\\to\\infty} \\Psi_p = \\lim_{p\\to\\infty} \\ln\\rho \\left( \\left[p - \\frac{1}{2} + O\\left(\\frac{1}{p}\\right)\\right] - \\left[(p-1) - \\frac{1}{2} + O\\left(\\frac{1}{p-1}\\right)\\right] \\right) $$\n$$ \\lim_{p\\to\\infty} \\Psi_p = \\lim_{p\\to\\infty} \\ln\\rho \\left( p - \\frac{1}{2} - p + 1 + \\frac{1}{2} + O\\left(\\frac{1}{p}\\right) \\right) = \\lim_{p\\to\\infty} \\ln\\rho \\left( 1 + O\\left(\\frac{1}{p}\\right) \\right) = \\ln\\rho $$\nSince $\\rho>1$, the limit $\\ln\\rho$ is a strictly positive constant.\n\n**Conclusion and Refinement Logic**\nOur constructed indicator $\\Psi_p$ has the following asymptotic limits:\n- For algebraic decay: $\\lim_{p\\to\\infty} \\Psi_p = 0$.\n- For analytic decay: $\\lim_{p\\to\\infty} \\Psi_p = \\ln\\rho > 0$.\n\nThis fulfills the requirements of the problem. The expression for the critical discrimination threshold $T_{\\star}$ is defined as the asymptotic limit of $\\Psi_p$ for algebraic decay.\n$$ T_{\\star} = \\lim_{p\\to\\infty, \\text{algebraic}} \\Psi_p = 0 $$\nFor analytic decay, the limit is $T_{\\star} + \\Delta = 0 + \\ln\\rho$, with $\\Delta = \\ln\\rho > 0$, consistent with the problem statement.\n\nThe refinement logic is as follows: on each element, compute $\\Psi_p$. If the value of $\\Psi_p$ is close to $T_{\\star} = 0$, the solution is inferred to have low regularity (algebraic convergence), and $h$-refinement (mesh subdivision) is the appropriate strategy. If $\\Psi_p$ is significantly greater than $0$, the solution is inferred to be analytic, and $p$-refinement (increasing the polynomial degree) is the more efficient strategy to achieve rapid convergence.\n\nThe problem asks for the single closed-form value of $T_{\\star}$. Based on our construction and analysis, this value is $0$.", "answer": "$$\n\\boxed{0}\n$$", "id": "3569257"}]}