{"hands_on_practices": [{"introduction": "To begin our practical exploration, we will implement the most fundamental approach to computational contact: the penalty method. This method approximates the non-penetration constraint by allowing for a small, unphysical overlap and introducing a restoring force proportional to the penetration depth, much like a stiff spring. This exercise [@problem_id:3553936] will solidify your understanding of the core components of a contact algorithm, including the signed gap function, the active set, and the penalty force calculation in a clear, one-dimensional context.", "problem": "Consider a one-dimensional elastic bar discretized into nodal points that can approach a perfectly rigid obstacle. Let the outward normal be defined along the bar’s axis toward the obstacle. For each node indexed by $i$, the signed normal gap $g_i$ represents the normal separation between the bar and the obstacle. By convention, $g_i \\ge 0$ indicates no contact (separation) and $g_i < 0$ indicates interpenetration that must be corrected by a contact reaction. The unilateral contact conditions are the complementarity conditions $g_i \\ge 0$, $\\lambda_i \\ge 0$, and $g_i \\lambda_i = 0$, where $\\lambda_i$ is the normal contact reaction (force) at node $i$. In computational practice, a penalty regularization introduces a linear penalty stiffness $k_p > 0$ such that contact reactions arise proportionally to the interpenetration, subject to an active set decision. To avoid numerical chatter, adopt an activation tolerance $\\varepsilon \\ge 0$ such that a node is in the active set if and only if $g_i \\le -\\varepsilon$. Assume frictionless contact and a purely normal penalty response. The input data to the program are the nodal gap values $g_i$ (in $\\,\\mathrm{m}\\,$), a penalty stiffness $k_p$ (in $\\,\\mathrm{N/m}\\,$), and an activation tolerance $\\varepsilon$ (in $\\,\\mathrm{m}\\,$). The required outputs are: the discrete active set as a list of booleans indicating, for each node $i$, whether it is active, and the corresponding list of normal contact forces (in $\\,\\mathrm{N}\\,$), rounded to six decimal places. Use the sign convention that a positive normal contact force acts to resist penetration of the obstacle.\n\nDerive, from first principles starting at the complementarity conditions and a linear penalty regularization, a method to compute:\n- The discrete active set $A = \\{ i \\mid g_i \\le -\\varepsilon \\}$, and\n- The normal contact force $\\lambda_i$ at each node $i$ based on the penalty model and the active set decision.\n\nImplement this method as a complete, runnable program that processes the following test suite. Each test case is specified by a tuple $(\\mathbf{g}, k_p, \\varepsilon)$ where $\\mathbf{g}$ is the list of nodal gaps. The units are consistent across all cases:\n- Case $1$ (happy path, mixed gaps and nonzero tolerance): $\\mathbf{g} = [0.005, -0.002, -0.0005, 0.0]$ in $\\,\\mathrm{m}\\,$, $k_p = 10^6$ in $\\,\\mathrm{N/m}\\,$, $\\varepsilon = 0.001$ in $\\,\\mathrm{m}\\,$.\n- Case $2$ (boundary condition at the activation threshold): $\\mathbf{g} = [-0.001, 0.01]$ in $\\,\\mathrm{m}\\,$, $k_p = 5 \\times 10^5$ in $\\,\\mathrm{N/m}\\,$, $\\varepsilon = 0.001$ in $\\,\\mathrm{m}\\,$.\n- Case $3$ (edge case with zero penalty stiffness): $\\mathbf{g} = [-0.003, -0.2]$ in $\\,\\mathrm{m}\\,$, $k_p = 0$ in $\\,\\mathrm{N/m}\\,$, $\\varepsilon = 10^{-6}$ in $\\,\\mathrm{m}\\,$.\n- Case $4$ (small negative and small positive gaps with finite tolerance): $\\mathbf{g} = [-10^{-9}, -10^{-4}, 10^{-8}]$ in $\\,\\mathrm{m}\\,$, $k_p = 10^3$ in $\\,\\mathrm{N/m}\\,$, $\\varepsilon = 10^{-6}$ in $\\,\\mathrm{m}\\,$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each element of this outer list corresponds to one test case and must be a two-list structure $[\\text{active}, \\text{forces}]$, where $\\text{active}$ is the list of booleans for the discrete active set and $\\text{forces}$ is the list of the corresponding normal contact forces in $\\,\\mathrm{N}\\,$ rounded to six decimal places. For example, the overall output must have the form $[[\\text{active}_1,\\text{forces}_1],[\\text{active}_2,\\text{forces}_2],\\dots]$.", "solution": "The problem posed is a well-defined exercise in computational contact mechanics, providing a clear and consistent set of definitions and data. It is scientifically grounded in the principles of penalty methods for enforcing unilateral constraints. Therefore, the problem is deemed valid and a solution is derived as follows.\n\nThe foundation of frictionless, unilateral contact mechanics for a discrete system is the set of Karush-Kuhn-Tucker (KKT) conditions for each potential contact node $i$. These conditions, provided in the problem, are:\n$1$. Kinematic admissibility (non-penetration): $g_i \\ge 0$\n$2$. Static admissibility (non-tensile force): $\\lambda_i \\ge 0$\n$3$. Complementarity (force exists only on closure): $g_i \\lambda_i = 0$\n\nHere, $g_i$ is the signed normal gap between node $i$ and the rigid obstacle, with $g_i > 0$ indicating separation. $\\lambda_i$ is the normal contact force (Lagrange multiplier) at node $i$. The sign convention specifies that $\\lambda_i$ is positive when acting to resist penetration.\n\nEnforcing these conditions exactly can be computationally demanding. The penalty method provides an approximation by relaxing the strict non-penetration constraint, $g_i \\ge 0$. Instead, it allows for a small, unphysical penetration, $g_i < 0$, and introduces a restoring force, $\\lambda_i$, that is proportional to the magnitude of this penetration.\n\nThe problem specifies a linear penalty regularization. In this model, the contact force $\\lambda_i$ is related to the gap $g_i$ via a penalty stiffness parameter $k_p > 0$. The force must be zero for separation ($g_i > 0$) and at the point of contact ($g_i = 0$). For penetration ($g_i < 0$), a positive restoring force must be generated. The magnitude of penetration is given by $-g_i$. Therefore, a linear force law is established as:\n$$\n\\lambda_i = \n\\begin{cases} \n-k_p g_i & \\text{if } g_i < 0 \\\\\n0 & \\text{if } g_i \\ge 0 \n\\end{cases}\n$$\nThis relationship ensures that $\\lambda_i \\ge 0$ as required, since $k_p > 0$ and for the case where a force is generated, $g_i < 0$, making $-k_p g_i > 0$.\n\nFor numerical stability and to prevent chatter (rapid switching of contact state for nodes near the boundary), the problem introduces an activation tolerance, $\\varepsilon \\ge 0$. This modifies the condition under which a contact force is generated. A node $i$ is considered to be in the \"active set\" $A$ of contacting nodes if and only if its penetration exceeds this tolerance. The formal definition for the active set is given as:\n$$\nA = \\{ i \\mid g_i \\le -\\varepsilon \\}\n$$\nA node $i \\in A$ is considered to be actively in contact and will generate a reaction force. A node $i \\notin A$ (i.e., $g_i > -\\varepsilon$) is considered inactive and generates no force. This inactive condition covers both true separation ($g_i \\ge 0$) and a small, tolerated amount of penetration ($-\\varepsilon < g_i < 0$).\n\nCombining the linear penalty law with the active set decision, we derive the final computational model for the contact force $\\lambda_i$ at each node $i$:\n\n$1$. **Active Set Determination**: For each node $i$, evaluate the condition $g_i \\le -\\varepsilon$. The result determines if the node belongs to the active set $A$. The output for this step is a boolean value for each node.\n\n$2$. **Contact Force Calculation**: The contact force $\\lambda_i$ is calculated based on the active set status:\n$$\n\\lambda_i = \n\\begin{cases} \n-k_p g_i & \\text{if } i \\in A \\quad (g_i \\le -\\varepsilon) \\\\\n0 & \\text{if } i \\notin A \\quad (g_i > -\\varepsilon)\n\\end{cases}\n$$\nThis formulation respects all conditions laid out in the problem. The sign of the force is positive, resisting penetration, because if a force is applied, $g_i$ is negative. If the penalty stiffness $k_p$ is zero, the resulting force $\\lambda_i$ will also be zero, regardless of the gap, which is physically consistent.\n\nThis step-by-step procedure is applied to each node to obtain the discrete active set and the corresponding vector of nodal contact forces. The units are consistent: if $k_p$ is in $\\mathrm{N/m}$ and $g_i$ is in $\\mathrm{m}$, then $\\lambda_i$ is correctly computed in $\\mathrm{N}$. The procedure is deterministic and directly implementable.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the active contact set and normal contact forces for a 1D bar\n    approaching a rigid obstacle, based on a penalty method with an activation\n    tolerance.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (list of gaps g, penalty stiffness kp, activation tolerance eps)\n    test_cases = [\n        # Case 1\n        (np.array([0.005, -0.002, -0.0005, 0.0]), 1e6, 0.001),\n        # Case 2\n        (np.array([-0.001, 0.01]), 5e5, 0.001),\n        # Case 3\n        (np.array([-0.003, -0.2]), 0.0, 1e-6),\n        # Case 4\n        (np.array([-1e-9, -1e-4, 1e-8]), 1e3, 1e-6),\n    ]\n\n    results = []\n    for g_vec, kp, eps in test_cases:\n        # Step 1: Determine the discrete active set A.\n        # A node i is active if and only if g_i = -eps.\n        # This vectorized operation returns a boolean numpy array.\n        active_set = g_vec = -eps\n\n        # Step 2: Compute the normal contact force lambda_i for each node.\n        # The force is lambda_i = -kp * g_i if the node is active, and 0 otherwise.\n        # np.where is an efficient way to perform this conditional logic on arrays.\n        forces = np.where(active_set, -kp * g_vec, 0.0)\n\n        # Round the forces to six decimal places as required.\n        rounded_forces = np.round(forces, 6)\n\n        # Append the results for the current test case to the main list.\n        # Convert numpy arrays to Python lists for the final output format.\n        results.append([active_set.tolist(), rounded_forces.tolist()])\n\n    # Final print statement must produce a single line in the exact required format.\n    # The str() representation of a list of lists matches the desired output structure.\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "3553936"}, {"introduction": "Building upon the basic penalty concept, we now tackle the geometric heart of most contact algorithms: finding the closest point on a curved surface. For a smooth, parametrically defined surface, the closest point is found where the vector connecting it to the slave point is orthogonal to the surface's tangent plane, a condition that gives rise to a system of nonlinear equations. This practice uses the robust Newton-Raphson method to solve for the contact point's parametric coordinates $(\\xi, \\eta)$. By implementing a single Newton step for a torus [@problem_id:3553921], you will gain hands-on experience with the kinematics of contact, including surface parameterization, tangent and normal vectors, and the iterative search process.", "problem": "Consider a smooth, two-parameter surface in three-dimensional Euclidean space defined by a torus with major radius $R$ and minor radius $r$ using the parametrization $x(\\xi,\\eta)$ with angles measured in radians. The parametrization is given by\n$$\nx(\\xi,\\eta) = \n\\begin{bmatrix}\n\\left(R + r \\cos \\eta\\right)\\cos \\xi \\\\\n\\left(R + r \\cos \\eta\\right)\\sin \\xi \\\\\nr \\sin \\eta\n\\end{bmatrix},\n$$\nwhere $R$ and $r$ are in meters and $x(\\xi,\\eta)$ is in meters. Let a fixed \"slave\" point in space be denoted by $x_s \\in \\mathbb{R}^3$, also in meters. The closest-point projection on a smooth surface satisfies the orthogonality conditions that the vector $x(\\xi,\\eta) - x_s$ is orthogonal to the surface tangent directions $x_{,\\xi}(\\xi,\\eta)$ and $x_{,\\eta}(\\xi,\\eta)$, where $x_{,\\xi}$ and $x_{,\\eta}$ denote partial derivatives with respect to $\\xi$ and $\\eta$, respectively.\n\nDefine the orthogonality residual vector $f(\\xi,\\eta)$ with components\n$$\nf_\\xi(\\xi,\\eta) = \\left(x(\\xi,\\eta)-x_s\\right)\\cdot x_{,\\xi}(\\xi,\\eta), \\quad\nf_\\eta(\\xi,\\eta) = \\left(x(\\xi,\\eta)-x_s\\right)\\cdot x_{,\\eta}(\\xi,\\eta),\n$$\nwhere $\\cdot$ denotes the Euclidean inner product. A single Newton step for solving $f(\\xi,\\eta) = 0$ from a current iterate $(\\xi,\\eta)$ is obtained by forming the Jacobian matrix $J(\\xi,\\eta)$ of $f$ and solving the linear system\n$$\nJ(\\xi,\\eta)\\,\\Delta =\n- f(\\xi,\\eta),\n$$\nto update the parameters as $(\\xi_{\\text{new}},\\eta_{\\text{new}}) = (\\xi+\\Delta_\\xi,\\eta+\\Delta_\\eta)$. After performing that single Newton step, compute:\n- the contact normal vector $n(\\xi_{\\text{new}},\\eta_{\\text{new}})$ as the unit vector along $x_{,\\xi}(\\xi_{\\text{new}},\\eta_{\\text{new}}) \\times x_{,\\eta}(\\xi_{\\text{new}},\\eta_{\\text{new}})$, where $\\times$ denotes the cross product,\n- the normal gap function $g_n = n(\\xi_{\\text{new}},\\eta_{\\text{new}})\\cdot\\left(x_s - x(\\xi_{\\text{new}},\\eta_{\\text{new}})\\right)$ in meters,\n- the updated orthogonality residuals $f_\\xi(\\xi_{\\text{new}},\\eta_{\\text{new}})$ and $f_\\eta(\\xi_{\\text{new}},\\eta_{\\text{new}})$.\n\nYour program must implement the above using first principles of contact kinematics: the orthogonality conditions for closest-point projection, the Newton linearization using the exact Jacobian formed from the first and second partial derivatives of $x(\\xi,\\eta)$ with respect to $\\xi$ and $\\eta$, and the gap function as the projection of the separation vector $x_s - x$ on the unit normal. Use the following test suite of parameter values, all with $R$ and $r$ in meters, $x_s$ in meters, and angles in radians:\n\n- Test case $1$: $R = 2.0$, $r = 0.5$, $\\xi_0 = 0.0$, $\\eta_0 = 0.0$, $x_s = \\begin{bmatrix} 2.6 \\\\ 0.05 \\\\ 0.0 \\end{bmatrix}$.\n- Test case $2$: $R = 2.0$, $r = 0.5$, $\\xi_0 = 0.0$, $\\eta_0 = \\pi$, $x_s = \\begin{bmatrix} 1.8 \\\\ 0.0 \\\\ 0.0 \\end{bmatrix}$.\n- Test case $3$: $R = 2.0$, $r = 0.5$, $\\xi_0 = 0.3$, $\\eta_0 = 1.1$, $x_s = \\begin{bmatrix} 2.0 \\\\ 0.0 \\\\ 0.5 \\end{bmatrix}$.\n\nFor each test case, perform exactly one Newton step from $(\\xi_0,\\eta_0)$, then compute and return the tuple of five values $[\\xi_{\\text{new}},\\eta_{\\text{new}},g_n,f_\\xi(\\xi_{\\text{new}},\\eta_{\\text{new}}),f_\\eta(\\xi_{\\text{new}},\\eta_{\\text{new}})]$. Express the angles $\\xi_{\\text{new}}$ and $\\eta_{\\text{new}}$ in radians as decimal numbers, the gap $g_n$ in meters as a decimal number, and the residuals as decimal numbers. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case result is itself a comma-separated list of the five values with no spaces and each number rounded to $8$ decimal places. For example, the overall output format is\n$$\n[\\,[\\xi_1,\\eta_1,g_{n,1},f_{\\xi,1},f_{\\eta,1}],\\,[\\xi_2,\\eta_2,g_{n,2},f_{\\xi,2},f_{\\eta,2}],\\,[\\xi_3,\\eta_3,g_{n,3},f_{\\xi,3},f_{\\eta,3}]\\,],\n$$\nwith the exact numeric values determined by your computation.\n\nNote: Use the exact Jacobian of $f(\\xi,\\eta)$ that follows from differentiating the orthogonality conditions, which requires the second partial derivatives $x_{,\\xi\\xi}(\\xi,\\eta)$, $x_{,\\xi\\eta}(\\xi,\\eta)$, and $x_{,\\eta\\eta}(\\xi,\\eta)$ of the torus parametrization. Ensure all operations are performed consistently in radians and meters, and report $g_n$ in meters. If the Jacobian matrix $J(\\xi,\\eta)$ is singular for a test case, solve the Newton system in the least-squares sense using a pseudoinverse so that a well-defined update is obtained.", "solution": "The problem is well-defined, scientifically grounded, and contains all necessary information to proceed with a solution. It is a standard application of numerical methods to a problem in computational contact mechanics.\n\nThe core of the problem is to find the closest point on a torus surface to a given point $x_s$ in space. The closest point $x(\\xi, \\eta)$ on the surface is characterized by the orthogonality conditions: the vector connecting the slave point to the surface point, $d = x(\\xi, \\eta) - x_s$, must be orthogonal to the tangent vectors of the surface at that point. These tangents are the partial derivatives of the parametrization with respect to the surface parameters, $x_{,\\xi}$ and $x_{,\\eta}$.\n\nThe problem is to solve the system of nonlinear equations for the parameters $(\\xi, \\eta)$:\n$$\nf(\\xi, \\eta) = \\begin{bmatrix} f_\\xi(\\xi,\\eta) \\\\ f_\\eta(\\xi,\\eta) \\end{bmatrix} = \\begin{bmatrix} (x(\\xi,\\eta)-x_s)\\cdot x_{,\\xi}(\\xi,\\eta) \\\\ (x(\\xi,\\eta)-x_s)\\cdot x_{,\\eta}(\\xi,\\eta) \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}\n$$\nWe are asked to perform one step of the Newton-Raphson method to update an initial guess $(\\xi_0, \\eta_0)$. The update step is given by solving the linear system:\n$$\nJ(\\xi_k, \\eta_k) \\Delta_k = -f(\\xi_k, \\eta_k)\n$$\nwhere $\\Delta_k = [\\Delta_\\xi, \\Delta_\\eta]^T$ is the update vector, and $J$ is the Jacobian matrix of $f$. The parameters are then updated as $(\\xi_{k+1}, \\eta_{k+1}) = (\\xi_k, \\eta_k) + (\\Delta_\\xi, \\Delta_\\eta)$.\n\nFirst, we derive the necessary analytical expressions.\nThe torus parametrization is:\n$$\nx(\\xi,\\eta) = \n\\begin{bmatrix}\n(R + r \\cos \\eta)\\cos \\xi \\\\\n(R + r \\cos \\eta)\\sin \\xi \\\\\nr \\sin \\eta\n\\end{bmatrix}\n$$\nThe first partial derivatives (tangent vectors) are:\n$$\nx_{,\\xi}(\\xi,\\eta) = \\frac{\\partial x}{\\partial \\xi} = \\begin{bmatrix} -(R + r \\cos \\eta)\\sin \\xi \\\\ (R + r \\cos \\eta)\\cos \\xi \\\\ 0 \\end{bmatrix}\n$$\n$$\nx_{,\\eta}(\\xi,\\eta) = \\frac{\\partial x}{\\partial \\eta} = \\begin{bmatrix} -r \\sin \\eta \\cos \\xi \\\\ -r \\sin \\eta \\sin \\xi \\\\ r \\cos \\eta \\end{bmatrix}\n$$\nFor the Jacobian of the residual $f$, we need the second partial derivatives of $x$:\n$$\nx_{,\\xi\\xi} = \\frac{\\partial^2 x}{\\partial \\xi^2} = \\begin{bmatrix} -(R + r \\cos \\eta)\\cos \\xi \\\\ -(R + r \\cos \\eta)\\sin \\xi \\\\ 0 \\end{bmatrix}\n$$\n$$\nx_{,\\eta\\eta} = \\frac{\\partial^2 x}{\\partial \\eta^2} = \\begin{bmatrix} -r \\cos \\eta \\cos \\xi \\\\ -r \\cos \\eta \\sin \\xi \\\\ -r \\sin \\eta \\end{bmatrix}\n$$\n$$\nx_{,\\xi\\eta} = \\frac{\\partial^2 x}{\\partial \\xi \\partial \\eta} = \\begin{bmatrix} r \\sin \\eta \\sin \\xi \\\\ -r \\sin \\eta \\cos \\xi \\\\ 0 \\end{bmatrix}\n$$\nThe components of the Jacobian matrix $J_{ij} = \\partial f_i / \\partial_j$ are derived using the product rule for differentiation of the dot product:\n$$\nJ_{\\xi\\xi} = \\frac{\\partial f_\\xi}{\\partial \\xi} = \\frac{\\partial}{\\partial \\xi} \\left( (x-x_s) \\cdot x_{,\\xi} \\right) = x_{,\\xi} \\cdot x_{,\\xi} + (x-x_s) \\cdot x_{,\\xi\\xi} = \\|x_{,\\xi}\\|^2 + (x-x_s) \\cdot x_{,\\xi\\xi}\n$$\n$$\nJ_{\\xi\\eta} = \\frac{\\partial f_\\xi}{\\partial \\eta} = \\frac{\\partial}{\\partial \\eta} \\left( (x-x_s) \\cdot x_{,\\xi} \\right) = x_{,\\eta} \\cdot x_{,\\xi} + (x-x_s) \\cdot x_{,\\xi\\eta}\n$$\n$$\nJ_{\\eta\\xi} = \\frac{\\partial f_\\eta}{\\partial \\xi} = \\frac{\\partial}{\\partial \\xi} \\left( (x-x_s) \\cdot x_{,\\eta} \\right) = x_{,\\xi} \\cdot x_{,\\eta} + (x-x_s) \\cdot x_{,\\eta\\xi}\n$$\n$$\nJ_{\\eta\\eta} = \\frac{\\partial f_\\eta}{\\partial \\eta} = \\frac{\\partial}{\\partial \\eta} \\left( (x-x_s) \\cdot x_{,\\eta} \\right) = x_{,\\eta} \\cdot x_{,\\eta} + (x-x_s) \\cdot x_{,\\eta\\eta} = \\|x_{,\\eta}\\|^2 + (x-x_s) \\cdot x_{,\\eta\\eta}\n$$\nFor the given orthogonal parametrization of the torus, $x_{,\\xi} \\cdot x_{,\\eta} = 0$. The Jacobian is symmetric since $x_{,\\xi\\eta}=x_{,\\eta\\xi}$, so $J_{\\xi\\eta} = J_{\\eta\\xi}$. The squared norms are $\\|x_{,\\xi}\\|^2 = (R+r\\cos\\eta)^2$ and $\\|x_{,\\eta}\\|^2 = r^2$.\n\nAfter performing one Newton step to find $(\\xi_{\\text{new}},\\eta_{\\text{new}})$, we compute the following quantities:\n1. The surface normal vector $n$. This is obtained by normalizing the cross product of the tangent vectors:\n$$\nn(\\xi,\\eta) = \\frac{x_{,\\xi} \\times x_{,\\eta}}{\\|x_{,\\xi} \\times x_{,\\eta}\\|}\n$$\nThe cross product is $x_{,\\xi} \\times x_{,\\eta} = r(R+r\\cos\\eta)[\\cos\\xi\\cos\\eta, \\sin\\xi\\cos\\eta, \\sin\\eta]^T$.\nThe norm is $\\|x_{,\\xi} \\times x_{,\\eta}\\| = \\|x_{,\\xi}\\| \\|x_{,\\eta}\\| = r(R+r\\cos\\eta)$.\nThus, the unit normal is $n(\\xi,\\eta) = [\\cos\\xi\\cos\\eta, \\sin\\xi\\cos\\eta, \\sin\\eta]^T$.\n2. The normal gap function $g_n$, defined as the projection of the vector from the surface point to the slave point onto the normal vector:\n$$\ng_n = n(\\xi_{\\text{new}},\\eta_{\\text{new}}) \\cdot (x_s - x(\\xi_{\\text{new}},\\eta_{\\text{new}}))\n$$\n3. The updated orthogonality residuals $f_\\xi(\\xi_{\\text{new}},\\eta_{\\text{new}})$ and $f_\\eta(\\xi_{\\text{new}},\\eta_{\\text{new}})$, which are evaluated at the new parameter values.\n\nThe algorithm for each test case is as follows:\n1. Given $R, r, \\xi_0, \\eta_0, x_s$. Let $(\\xi_k, \\eta_k) = (\\xi_0, \\eta_0)$.\n2. Evaluate $x$, $x_{,\\xi}$, $x_{,\\eta}$, $x_{,\\xi\\xi}$, $x_{,\\xi\\eta}$, $x_{,\\eta\\eta}$ at $(\\xi_k, \\eta_k)$.\n3. Compute the residual vector $f = [f_\\xi, f_\\eta]^T$.\n4. Compute the Jacobian matrix $J$.\n5. Solve the linear system $J\\Delta = -f$ for $\\Delta = [\\Delta_\\xi, \\Delta_\\eta]^T$ using the pseudoinverse to handle potential singularity.\n6. Update the parameters: $(\\xi_{\\text{new}}, \\eta_{\\text{new}}) = (\\xi_k, \\eta_k) + (\\Delta_\\xi, \\Delta_\\eta)$.\n7. At $(\\xi_{\\text{new}}, \\eta_{\\text{new}})$, calculate $x, x_{,\\xi}, x_{,\\eta}$, and $n$.\n8. Compute the final quantities: $g_n$, $f_{\\xi,\\text{new}}$, and $f_{\\eta,\\text{new}}$.\n9. Collect and format the results $[\\xi_{\\text{new}},\\eta_{\\text{new}},g_n,f_{\\xi,\\text{new}},f_{\\eta,\\text{new}}]$.\nThis procedure is implemented in the provided Python code.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that processes test cases and prints the final result.\n    \"\"\"\n    test_cases = [\n        {'R': 2.0, 'r': 0.5, 'xi0': 0.0, 'eta0': 0.0, 'xs': np.array([2.6, 0.05, 0.0])},\n        {'R': 2.0, 'r': 0.5, 'xi0': 0.0, 'eta0': np.pi, 'xs': np.array([1.8, 0.0, 0.0])},\n        {'R': 2.0, 'r': 0.5, 'xi0': 0.3, 'eta0': 1.1, 'xs': np.array([2.0, 0.0, 0.5])},\n    ]\n\n    all_results = []\n    for case in test_cases:\n        result = process_case(case['R'], case['r'], case['xi0'], case['eta0'], case['xs'])\n        all_results.append(result)\n    \n    # Format the output string as per the problem specification.\n    list_of_strings = []\n    for result_tuple in all_results:\n        # Round each value to 8 decimal places and format.\n        formatted_vals = [f\"{val:.8f}\" for val in result_tuple]\n        s = f\"[{','.join(formatted_vals)}]\"\n        list_of_strings.append(s)\n    \n    final_output = f\"[{','.join(list_of_strings)}]\"\n    print(final_output)\n\ndef process_case(R, r, xi_k, eta_k, xs):\n    \"\"\"\n    Performs one Newton step and calculates the required output values for a single test case.\n    \"\"\"\n    \n    # --- Step 1: Evaluate geometric quantities at the current iterate (xi_k, eta_k) ---\n    \n    # Helper trigonometric values\n    cos_xi = np.cos(xi_k)\n    sin_xi = np.sin(xi_k)\n    cos_eta = np.cos(eta_k)\n    sin_eta = np.sin(eta_k)\n    \n    # Parametrization x(xi, eta)\n    x = np.array([\n        (R + r * cos_eta) * cos_xi,\n        (R + r * cos_eta) * sin_xi,\n        r * sin_eta\n    ])\n    \n    # First partial derivatives\n    x_xi = np.array([\n        -(R + r * cos_eta) * sin_xi,\n        (R + r * cos_eta) * cos_xi,\n        0.0\n    ])\n    \n    x_eta = np.array([\n        -r * sin_eta * cos_xi,\n        -r * sin_eta * sin_xi,\n        r * cos_eta\n    ])\n    \n    # Second partial derivatives\n    x_xixi = np.array([\n        -(R + r * cos_eta) * cos_xi,\n        -(R + r * cos_eta) * sin_xi,\n        0.0\n    ])\n    \n    x_etaeta = np.array([\n        -r * cos_eta * cos_xi,\n        -r * cos_eta * sin_xi,\n        -r * sin_eta\n    ])\n    \n    x_xieta = np.array([\n        r * sin_eta * sin_xi,\n        -r * sin_eta * cos_xi,\n        0.0\n    ])\n\n    # --- Step 2: Form the residual vector f and the Jacobian matrix J ---\n    \n    # Residual vector f(xi, eta)\n    x_minus_xs = x - xs\n    f_xi = np.dot(x_minus_xs, x_xi)\n    f_eta = np.dot(x_minus_xs, x_eta)\n    f = np.array([f_xi, f_eta])\n    \n    # Jacobian matrix J(xi, eta)\n    J_xixi = np.dot(x_xi, x_xi) + np.dot(x_minus_xs, x_xixi)\n    J_xieta = np.dot(x_xi, x_eta) + np.dot(x_minus_xs, x_xieta)\n    J_etaeta = np.dot(x_eta, x_eta) + np.dot(x_minus_xs, x_etaeta)\n    \n    J = np.array([\n        [J_xixi, J_xieta],\n        [J_xieta, J_etaeta] # J is symmetric\n    ])\n    \n    # --- Step 3: Solve for the update delta and find new parameters ---\n    \n    # Solve J * delta = -f using pseudoinverse for robustness\n    delta = np.linalg.pinv(J) @ -f\n    \n    xi_new = xi_k + delta[0]\n    eta_new = eta_k + delta[1]\n    \n    # --- Step 4: Calculate final results at the new point (xi_new, eta_new) ---\n    \n    # Helper trigonometric values at the new point\n    cos_xi_new = np.cos(xi_new)\n    sin_xi_new = np.sin(xi_new)\n    cos_eta_new = np.cos(eta_new)\n    sin_eta_new = np.sin(eta_new)\n    \n    # Parametrization x at new point\n    x_new = np.array([\n        (R + r * cos_eta_new) * cos_xi_new,\n        (R + r * cos_eta_new) * sin_xi_new,\n        r * sin_eta_new\n    ])\n    \n    # First partial derivatives at new point\n    x_xi_new = np.array([\n        -(R + r * cos_eta_new) * sin_xi_new,\n        (R + r * cos_eta_new) * cos_xi_new,\n        0.0\n    ])\n    \n    x_eta_new = np.array([\n        -r * sin_eta_new * cos_xi_new,\n        -r * sin_eta_new * sin_xi_new,\n        r * cos_eta_new\n    ])\n    \n    # Contact normal vector n\n    normal_unscaled = np.cross(x_xi_new, x_eta_new)\n    norm_val = np.linalg.norm(normal_unscaled)\n    if norm_val > 1e-12: # Avoid division by zero\n        n_new = normal_unscaled / norm_val\n    else: # Should not happen for a regular torus\n        n_new = np.array([0.0, 0.0, 0.0])\n\n    # Normal gap gn\n    gn = np.dot(n_new, xs - x_new)\n    \n    # Updated residuals f_new\n    x_minus_xs_new = x_new - xs\n    f_xi_new = np.dot(x_minus_xs_new, x_xi_new)\n    f_eta_new = np.dot(x_minus_xs_new, x_eta_new)\n    \n    return xi_new, eta_new, gn, f_xi_new, f_eta_new\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3553921"}, {"introduction": "Our final practice elevates the challenge to a scenario common in large-scale finite element analysis: tracking a contact point as it slides across a discretized, piecewise surface. Real-world contact surfaces are represented by meshes of elements, and a robust algorithm must handle the transition of the contact point from one element to a neighbor, a phenomenon known as large sliding. This requires not only an iterative search within an element but also logic for re-parameterizing coordinates across shared edges and projecting onto boundaries when a neighbor is not found. This comprehensive exercise [@problem_id:3553969] integrates the previous concepts into a sophisticated tracking algorithm, providing critical insight into how commercial and research codes manage the complex kinematics of large-deformation contact.", "problem": "You are given a piecewise bilinear quadrilateral surface embedded in three-dimensional Euclidean space. The surface is described by a finite collection of elements, each parameterized by natural coordinates $(\\xi,\\eta)\\in[-1,1]\\times[-1,1]$ with the bilinear isoparametric mapping from $(\\xi,\\eta)$ to physical coordinates $\\mathbf{X}(\\xi,\\eta)\\in\\mathbb{R}^3$. For each element, the four nodes are ordered according to the standard bilinear quadrilateral convention: $(\\xi,\\eta)=(-1,-1)$, $(-1,1)$, $(1,1)$, $(1,-1)$, respectively. The element mapping is defined by the bilinear shape functions\n$$\nN_1(\\xi,\\eta)=\\tfrac{1}{4}(1-\\xi)(1-\\eta),\\quad\nN_2(\\xi,\\eta)=\\tfrac{1}{4}(1-\\xi)(1+\\eta),\\quad\nN_3(\\xi,\\eta)=\\tfrac{1}{4}(1+\\xi)(1+\\eta),\\quad\nN_4(\\xi,\\eta)=\\tfrac{1}{4}(1+\\xi)(1-\\eta),\n$$\nso that\n$$\n\\mathbf{X}(\\xi,\\eta)=\\sum_{i=1}^{4} N_i(\\xi,\\eta)\\,\\mathbf{X}_i,\n$$\nwhere $\\mathbf{X}_i\\in\\mathbb{R}^3$ are the nodal coordinates of the element in meters. The element tangents are\n$$\n\\mathbf{a}_\\xi(\\xi,\\eta)=\\frac{\\partial \\mathbf{X}}{\\partial \\xi},\\qquad\n\\mathbf{a}_\\eta(\\xi,\\eta)=\\frac{\\partial \\mathbf{X}}{\\partial \\eta}.\n$$\n\nStarting from first principles, the closest-point projection of a slave point $\\mathbf{x}_s\\in\\mathbb{R}^3$ onto the surface minimizes the squared distance\n$$\n\\phi(\\xi,\\eta)=\\tfrac{1}{2}\\,\\|\\mathbf{X}(\\xi,\\eta)-\\mathbf{x}_s\\|_2^2,\n$$\nwhich, for an unconstrained interior solution, must satisfy the orthogonality conditions\n$$\n\\mathbf{a}_\\xi(\\xi,\\eta)\\cdot\\left(\\mathbf{X}(\\xi,\\eta)-\\mathbf{x}_s\\right)=0,\\qquad\n\\mathbf{a}_\\eta(\\xi,\\eta)\\cdot\\left(\\mathbf{X}(\\xi,\\eta)-\\mathbf{x}_s\\right)=0.\n$$\nWhen the minimizing point lies on an element boundary, the problem reduces to a constrained search on the appropriate edge, and if the minimizing point lies at a vertex, it reduces to a discrete comparison among corners.\n\nYour task is to design and implement a robust algorithm that:\n- Solves the unconstrained problem via a principled iterative method grounded in minimization of $\\phi(\\xi,\\eta)$, using only the tangent information $(\\mathbf{a}_\\xi,\\mathbf{a}_\\eta)$ as the context-appropriate fundamental base.\n- Detects when the iterate exits the element domain $[-1,1]\\times[-1,1]$ and, if a neighboring element exists across the exiting edge, reparameterizes $(\\xi,\\eta)$ onto the neighbor’s natural coordinates consistently with the shared-edge orientation, then continues the iterative process on the neighbor. This implements large sliding across element boundaries.\n- If there is no neighboring element across the exiting edge, performs a constrained closest-point projection on the boundary edges and, if necessary, corners of the current element, choosing the global minimizer of the squared distance among these constrained candidates.\n- Computes the normal gap function\n$$\ng_n=\\mathbf{n}(\\xi,\\eta)\\cdot\\left(\\mathbf{x}_s-\\mathbf{X}(\\xi,\\eta)\\right),\n$$\nwith the unit normal\n$$\n\\mathbf{n}(\\xi,\\eta)=\\frac{\\mathbf{a}_\\xi(\\xi,\\eta)\\times \\mathbf{a}_\\eta(\\xi,\\eta)}{\\left\\|\\mathbf{a}_\\xi(\\xi,\\eta)\\times \\mathbf{a}_\\eta(\\xi,\\eta)\\right\\|_2},\n$$\nexpressed in meters, rounded to $6$ decimal places.\n\nYou must implement the algorithm to handle edge and corner cases robustly. Edge reparameterization must respect orientation. Let edge indices be defined as follows: edge $0$ is $\\xi=-1$ with $\\eta$ increasing from $-1$ to $1$, edge $1$ is $\\eta=1$ with $\\xi$ increasing from $-1$ to $1$, edge $2$ is $\\xi=1$ with $\\eta$ increasing from $-1$ to $1$, and edge $3$ is $\\eta=-1$ with $\\xi$ increasing from $-1$ to $1$. Across a shared edge, the neighbor provides a mapping $(\\xi',\\eta')$ satisfying $\\xi'=\\pm 1$ or $\\eta'=\\pm 1$ on its corresponding edge, and the tangential parameter along the edge must be reparameterized with a sign $s\\in\\{-1,1\\}$ that encodes orientation consistency.\n\nUse the following mesh in meters with three bilinear quadrilateral elements, including adjacency and edge orientation, to form your test suite. Nodes are given in the standard ordering $(-1,-1)$, $(-1,1)$, $(1,1)$, $(1,-1)$ for each element:\n- Element $0$ nodes:\n$$\n\\mathbf{X}_1=(0,0,0),\\quad\n\\mathbf{X}_2=(0,1,0),\\quad\n\\mathbf{X}_3=(1,1,0.1),\\quad\n\\mathbf{X}_4=(1,0,0.1).\n$$\nAdjacency: edge $2$ neighbors element $1$’s edge $0$ with orientation $s=+1$. All other edges have no neighbor.\n- Element $1$ nodes:\n$$\n\\mathbf{X}_1=(1,0,0.1),\\quad\n\\mathbf{X}_2=(1,1,0.1),\\quad\n\\mathbf{X}_3=(2,1,0.2),\\quad\n\\mathbf{X}_4=(2,0,0.2).\n$$\nAdjacency: edge $0$ neighbors element $0$’s edge $2$ with $s=+1$, edge $2$ neighbors element $2$’s edge $0$ with $s=+1$. All other edges have no neighbor.\n- Element $2$ nodes:\n$$\n\\mathbf{X}_1=(2,0,0.2),\\quad\n\\mathbf{X}_2=(2,1,0.2),\\quad\n\\mathbf{X}_3=(3,1,0.2),\\quad\n\\mathbf{X}_4=(3,0,0.2).\n$$\nAdjacency: edge $0$ neighbors element $1$’s edge $2$ with $s=+1$. All other edges have no neighbor.\n\nImplement your program to evaluate the normal gap function $g_n$ for the following five test cases, each given as a slave point $\\mathbf{x}_s$ in meters and an initial element index:\n- Test $1$: $\\mathbf{x}_s=(0.3,0.4,0.05)$, start element $0$.\n- Test $2$: $\\mathbf{x}_s=(1.4,0.5,0.05)$, start element $0$.\n- Test $3$: $\\mathbf{x}_s=(0.6,1.2,0.05)$, start element $0$.\n- Test $4$: $\\mathbf{x}_s=(3.7,-0.6,1.0)$, start element $1$.\n- Test $5$: $\\mathbf{x}_s=(2.6,0.2,0.3)$, start element $0$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each entry being the normal gap $g_n$ in meters rounded to $6$ decimal places in the order of the tests above, for example, $[g_1,g_2,g_3,g_4,g_5]$.", "solution": "The user has provided a problem in computational contact mechanics concerning the closest-point projection of a point onto a piecewise bilinear surface. The solution requires a robust iterative algorithm, handling of element-to-element sliding (large sliding), and constrained projection onto element boundaries and corners.\n\n### Step 1: Problem Validation\n\n#### Extraction of Givens\n- **Surface Representation**: A piecewise bilinear quadrilateral surface in $\\mathbb{R}^3$.\n- **Element Parameterization**: Each element is mapped from natural coordinates $(\\xi,\\eta) \\in [-1,1]\\times[-1,1]$ to physical coordinates $\\mathbf{X}(\\xi,\\eta) \\in \\mathbb{R}^3$.\n- **Shape Functions**:\n  $$ N_1(\\xi,\\eta)=\\tfrac{1}{4}(1-\\xi)(1-\\eta),\\quad N_2(\\xi,\\eta)=\\tfrac{1}{4}(1-\\xi)(1+\\eta) $$\n  $$ N_3(\\xi,\\eta)=\\tfrac{1}{4}(1+\\xi)(1+\\eta),\\quad N_4(\\xi,\\eta)=\\tfrac{1}{4}(1+\\xi)(1-\\eta) $$\n- **Isoparametric Mapping**: $\\mathbf{X}(\\xi,\\eta)=\\sum_{i=1}^{4} N_i(\\xi,\\eta)\\,\\mathbf{X}_i$, where $\\mathbf{X}_i$ are nodal coordinates.\n- **Node Ordering**: For each element, nodes correspond to $(\\xi,\\eta) = (-1,-1), (-1,1), (1,1), (1,-1)$ for $i=1,2,3,4$ respectively.\n- **Tangent Vectors**: $\\mathbf{a}_\\xi(\\xi,\\eta)=\\frac{\\partial \\mathbf{X}}{\\partial \\xi}$ and $\\mathbf{a}_\\eta(\\xi,\\eta)=\\frac{\\partial \\mathbf{X}}{\\partial \\eta}$.\n- **Objective Function**: Minimize the squared distance $\\phi(\\xi,\\eta)=\\tfrac{1}{2}\\,\\|\\mathbf{X}(\\xi,\\eta)-\\mathbf{x}_s\\|_2^2$ for a given slave point $\\mathbf{x}_s$.\n- **Orthogonality Conditions**: For an unconstrained interior minimum, the gradient of $\\phi$ must be zero:\n  $$ \\frac{\\partial\\phi}{\\partial\\xi} = \\mathbf{a}_\\xi\\cdot\\left(\\mathbf{X}-\\mathbf{x}_s\\right)=0 $$\n  $$ \\frac{\\partial\\phi}{\\partial\\eta} = \\mathbf{a}_\\eta\\cdot\\left(\\mathbf{X}-\\mathbf{x}_s\\right)=0 $$\n- **Output Quantity**: The normal gap function $g_n=\\mathbf{n}(\\xi,\\eta)\\cdot\\left(\\mathbf{x}_s-\\mathbf{X}(\\xi,\\eta)\\right)$, where $\\mathbf{n}$ is the unit normal vector:\n  $$ \\mathbf{n}(\\xi,\\eta)=\\frac{\\mathbf{a}_\\xi(\\xi,\\eta)\\times \\mathbf{a}_\\eta(\\xi,\\eta)}{\\left\\|\\mathbf{a}_\\xi(\\xi,\\eta)\\times \\mathbf{a}_\\eta(\\xi,\\eta)\\right\\|_2} $$\n- **Edge Indexing and Parameterization**:\n  - Edge $0$: $\\xi=-1$, $\\eta$ increases from $-1$ to $1$.\n  - Edge $1$: $\\eta=1$, $\\xi$ increases from $-1$ to $1$.\n  - Edge $2$: $\\xi=1$, $\\eta$ increases from $-1$ to $1$.\n  - Edge $3$: $\\eta=-1$, $\\xi$ increases from $-1$ to $1$.\n- **Mesh Data (in meters)**:\n  - Element 0 Nodes: $\\mathbf{X}_1=(0,0,0), \\mathbf{X}_2=(0,1,0), \\mathbf{X}_3=(1,1,0.1), \\mathbf{X}_4=(1,0,0.1)$.\n    Adjacency: Edge 2 neighbors Elem 1's Edge 0 ($s=+1$).\n  - Element 1 Nodes: $\\mathbf{X}_1=(1,0,0.1), \\mathbf{X}_2=(1,1,0.1), \\mathbf{X}_3=(2,1,0.2), \\mathbf{X}_4=(2,0,0.2)$.\n    Adjacency: Edge 0 neighbors Elem 0's Edge 2 ($s=+1$). Edge 2 neighbors Elem 2's Edge 0 ($s=+1$).\n  - Element 2 Nodes: $\\mathbf{X}_1=(2,0,0.2), \\mathbf{X}_2=(2,1,0.2), \\mathbf{X}_3=(3,1,0.2), \\mathbf{X}_4=(3,0,0.2)$.\n    Adjacency: Edge 0 neighbors Elem 1's Edge 2 ($s=+1$).\n- **Test Cases**:\n  1. $\\mathbf{x}_s=(0.3,0.4,0.05)$, start element $0$.\n  2. $\\mathbf{x}_s=(1.4,0.5,0.05)$, start element $0$.\n  3. $\\mathbf{x}_s=(0.6,1.2,0.05)$, start element $0$.\n  4. $\\mathbf{x}_s=(3.7,-0.6,1.0)$, start element $1$.\n  5. $\\mathbf{x}_s=(2.6,0.2,0.3)$, start element $0$.\n\n#### Validation using Givens\nThe problem is evaluated against the validation criteria.\n\n- **Scientifically Grounded**: The problem is a classic and fundamental task in computational contact mechanics. The formulation using isoparametric elements, shape functions, tangent vectors, and the minimization of a distance function is standard practice in the field of Finite Element Method (FEM). The use of an iterative Newton-Raphson-type method to solve the resulting nonlinear system of equations is also a standard, robust technique.\n- **Well-Posed**: The problem is well-posed. It seeks a minimum of a continuous function over a compact domain (the collection of element domains). A solution is guaranteed to exist. The combination of an unconstrained interior search, a sliding mechanism across elements, and a constrained boundary search provides a comprehensive strategy to find this minimum.\n- **Objective**: All definitions and data are provided in precise, unambiguous mathematical and numerical terms.\n- **Flaw Checklist**:\n  1.  **Scientific/Factual Unsoundness**: None. The principles are correct.\n  2.  **Non-Formalizable/Irrelevant**: None. The problem is central to computational solid mechanics.\n  3.  **Incomplete/Contradictory Setup**: The problem is self-contained. While the specified edge parameterization for edges 2 and 3 deviates from the standard counter-clockwise traversal of nodes, it is explicitly defined and constitutes a valid, if unconventional, part of the problem specification. This is not a contradiction but a specific instruction to follow.\n  4.  **Unrealistic/Infeasible**: The data and required computations are physically and computationally realistic.\n  5.  **Ill-Posed/Poorly Structured**: None. The problem structure guides towards a unique and meaningful solution.\n  6.  **Pseudo-Profound/Trivial**: None. The implementation requires careful handling of numerical methods, geometry, and logical branching, representing a non-trivial algorithmic challenge.\n  7.  **Outside Scientific Verifiability**: None. The results are deterministic and can be independently verified.\n\n#### Verdict\nThe problem is **valid**.\n\n### Solution Derivation\nThe core of the problem is to find the natural coordinates $(\\xi, \\eta)$ on one of the surface elements that minimize the squared distance to the slave point $\\mathbf{x}_s$. This is achieved by solving the system of nonlinear orthogonality equations $\\mathbf{r}(\\xi, \\eta) = \\mathbf{0}$, where $\\mathbf{r}$ is the residual vector:\n$$ \\mathbf{r}(\\xi, \\eta) = \\begin{pmatrix} r_\\xi \\\\ r_\\eta \\end{pmatrix} = \\begin{pmatrix} \\mathbf{a}_\\xi(\\xi, \\eta) \\cdot (\\mathbf{X}(\\xi, \\eta) - \\mathbf{x}_s) \\\\ \\mathbf{a}_\\eta(\\xi, \\eta) \\cdot (\\mathbf{X}(\\xi, \\eta) - \\mathbf{x}_s) \\end{pmatrix} $$\n\nAn iterative Newton-Raphson method is employed to solve this system. The update step is given by:\n$$ \\mathbf{H}(\\xi_k, \\eta_k) \\begin{pmatrix} \\Delta\\xi \\\\ \\Delta\\eta \\end{pmatrix} = -\\mathbf{r}(\\xi_k, \\eta_k) $$\n$$ \\xi_{k+1} = \\xi_k + \\Delta\\xi, \\quad \\eta_{k+1} = \\eta_k + \\Delta\\eta $$\nwhere $\\mathbf{H}$ is the Jacobian of $\\mathbf{r}$, which is also the Hessian of the objective function $\\phi$. The components of the Hessian are $H_{ij} = \\frac{\\partial^2\\phi}{\\partial s_i \\partial s_j}$ for $\\mathbf{s}=(\\xi, \\eta)$.\n\nThe bilinear nature of the mapping $\\mathbf{X}(\\xi, \\eta)$ can be expressed as:\n$$ \\mathbf{X}(\\xi,\\eta) = \\mathbf{c}_0 + \\mathbf{c}_\\xi \\xi + \\mathbf{c}_\\eta \\eta + \\mathbf{c}_{\\xi\\eta} \\xi \\eta $$\nwhere the constant vectors $\\mathbf{c}_0, \\mathbf{c}_\\xi, \\mathbf{c}_\\eta, \\mathbf{c}_{\\xi\\eta}$ are linear combinations of the nodal coordinates $\\mathbf{X}_i$. Specifically, $\\mathbf{c}_{\\xi\\eta} = \\frac{1}{4}(\\mathbf{X}_1 - \\mathbf{X}_2 + \\mathbf{X}_3 - \\mathbf{X}_4)$.\nThe tangent vectors are:\n$$ \\mathbf{a}_\\xi = \\frac{\\partial\\mathbf{X}}{\\partial\\xi} = \\mathbf{c}_\\xi + \\mathbf{c}_{\\xi\\eta} \\eta $$\n$$ \\mathbf{a}_\\eta = \\frac{\\partial\\mathbf{X}}{\\partial\\eta} = \\mathbf{c}_\\eta + \\mathbf{c}_{\\xi\\eta} \\xi $$\nThe Hessian matrix is:\n$$ \\mathbf{H} = \\begin{pmatrix} \\mathbf{a}_\\xi \\cdot \\mathbf{a}_\\xi + (\\mathbf{X} - \\mathbf{x}_s) \\cdot \\frac{\\partial^2\\mathbf{X}}{\\partial\\xi^2}  \\mathbf{a}_\\xi \\cdot \\mathbf{a}_\\eta + (\\mathbf{X} - \\mathbf{x}_s) \\cdot \\frac{\\partial^2\\mathbf{X}}{\\partial\\xi\\partial\\eta} \\\\ \\mathbf{a}_\\eta \\cdot \\mathbf{a}_\\xi + (\\mathbf{X} - \\mathbf{x}_s) \\cdot \\frac{\\partial^2\\mathbf{X}}{\\partial\\eta\\partial\\xi}  \\mathbf{a}_\\eta \\cdot \\mathbf{a}_\\eta + (\\mathbf{X} - \\mathbf{x}_s) \\cdot \\frac{\\partial^2\\mathbf{X}}{\\partial\\eta^2} \\end{pmatrix} $$\nFor a bilinear element, $\\frac{\\partial^2\\mathbf{X}}{\\partial\\xi^2} = \\mathbf{0}$ and $\\frac{\\partial^2\\mathbf{X}}{\\partial\\eta^2} = \\mathbf{0}$. The mixed partial derivative $\\frac{\\partial^2\\mathbf{X}}{\\partial\\xi\\partial\\eta} = \\mathbf{c}_{\\xi\\eta}$ is constant. The Hessian simplifies to:\n$$ \\mathbf{H} = \\begin{pmatrix} \\mathbf{a}_\\xi \\cdot \\mathbf{a}_\\xi  \\mathbf{a}_\\xi \\cdot \\mathbf{a}_\\eta \\\\ \\mathbf{a}_\\eta \\cdot \\mathbf{a}_\\xi  \\mathbf{a}_\\eta \\cdot \\mathbf{a}_\\eta \\end{pmatrix} + \\begin{pmatrix} 0  (\\mathbf{X} - \\mathbf{x}_s) \\cdot \\mathbf{c}_{\\xi\\eta} \\\\ (\\mathbf{X} - \\mathbf{x}_s) \\cdot \\mathbf{c}_{\\xi\\eta}  0 \\end{pmatrix} $$\nFor the specific elements given in the problem, the term $\\mathbf{c}_{\\xi\\eta}$ is zero for all three elements, meaning they are planar. This simplifies the Hessian to the Gauss-Newton approximation, which is constant for each element. However, the algorithm is implemented for the general non-planar case.\n\nThe overall algorithm proceeds as follows:\n1.  **Initialization**: Start with the given initial element and an initial guess for the natural coordinates, typically $(\\xi, \\eta) = (0, 0)$.\n2.  **Unconstrained Iteration**: Perform Newton-Raphson iterations to find the minimum of $\\phi(\\xi, \\eta)$ within the current element.\n3.  **Domain Check**: After each iteration, check if the new coordinates $(\\xi_{k+1}, \\eta_{k+1})$ are within the domain $[-1, 1] \\times [-1, 1]$.\n    a. If the process converges and the solution is inside the domain, the closest point on the surface has been found.\n    b. If the iterate exits the domain, the unconstrained search on the current element is terminated.\n4.  **Sliding and Reparameterization**: If an iterate exits the domain, identify the exit edge. Check the element's adjacency data for a neighbor across this edge.\n    a. If a neighbor exists, reparameterize the exit point's tangential coordinate into the neighbor's natural coordinate system, respecting the orientation sign $s$. Update the current element to the neighbor and continue the iterative search from this new starting point.\n    b. If no neighbor exists, the search is terminated, and the algorithm proceeds to a boundary search.\n5.  **Constrained Boundary Search**: If the search terminates at an edge with no neighbor, the closest point must lie on the boundary of the last active element. This requires finding the closest point to $\\mathbf{x}_s$ on the four edges and four corners of that element.\n    - The projection onto each edge (a line segment in $\\mathbb{R}^3$) is solved as a 1D minimization problem. The parameter for the closest point on the line containing the segment is calculated and then clamped to the range $[0, 1]$ corresponding to the segment's endpoints.\n    - All candidate points (the four corners and up to four interior-edge projections) are compared, and the one with the minimum distance to $\\mathbf{x}_s$ is selected as the final solution.\n6.  **Final Calculation**: Once the final element index and coordinates $(\\xi, \\eta)$ are determined, the physical point $\\mathbf{X}(\\xi, \\eta)$ and the unit normal $\\mathbf{n}(\\xi, \\eta)$ are computed. The normal gap is then calculated as $g_n = \\mathbf{n} \\cdot (\\mathbf{x}_s - \\mathbf{X})$.\n\nThis structured approach ensures robustness by handling interior solutions, sliding between elements, and constrained boundary conditions in a principled manner.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# language: Python\n# version: 3.12\n# libraries:\n#   name: numpy, version: 1.23.5\n\nclass BilinearElement:\n    \"\"\"\n    Represents a bilinear quadrilateral element.\n    \"\"\"\n    def __init__(self, elem_id, nodes, adjacency):\n        self.elem_id = elem_id\n        self.nodes = np.array(nodes)\n        self.adjacency = adjacency  # {edge_idx: (neighbor_id, neighbor_edge, s)}\n\n        # Pre-compute coefficients for the mapping X(xi, eta)\n        X1, X2, X3, X4 = self.nodes\n        self.c0 = 0.25 * (X1 + X2 + X3 + X4)\n        self.c_xi = 0.25 * (-X1 - X2 + X3 + X4)\n        self.c_eta = 0.25 * (-X1 + X2 + X3 - X4)\n        self.c_xi_eta = 0.25 * (X1 - X2 + X3 - X4)\n\n    def get_geometry(self, xi, eta):\n        \"\"\"\n        Computes physical coordinates and tangent vectors.\n        \"\"\"\n        X = self.c0 + self.c_xi * xi + self.c_eta * eta + self.c_xi_eta * xi * eta\n        a_xi = self.c_xi + self.c_xi_eta * eta\n        a_eta = self.c_eta + self.c_xi_eta * xi\n        return X, a_xi, a_eta\n\n    def project_onto_boundary(self, xs):\n        \"\"\"\n        Finds the closest point to xs on the element's boundary (edges and corners).\n        \"\"\"\n        candidates = []\n        # Add corners\n        node_coords = [(-1, -1), (-1, 1), (1, 1), (1, -1)]\n        for i in range(4):\n            X_node = self.nodes[i]\n            dist_sq = np.sum((X_node - xs)**2)\n            candidates.append((dist_sq, node_coords[i][0], node_coords[i][1]))\n\n        # Edge definitions based on node ordering 1-2-3-4\n        edge_nodes = [(0, 1), (1, 2), (2, 3), (3, 0)]\n        \n        for i in range(4):\n            p_a = self.nodes[edge_nodes[i][0]]\n            p_b = self.nodes[edge_nodes[i][1]]\n            \n            v = p_b - p_a\n            v_norm_sq = np.dot(v, v)\n            if v_norm_sq  1e-14:\n                continue\n\n            t = np.dot(xs - p_a, v) / v_norm_sq\n            \n            if 0  t  1:\n                proj_point = p_a + t * v\n                dist_sq = np.sum((proj_point - xs)**2)\n                \n                # Convert t back to (xi, eta)\n                xi_a, eta_a = node_coords[edge_nodes[i][0]]\n                xi_b, eta_b = node_coords[edge_nodes[i][1]]\n                xi_proj = (1 - t) * xi_a + t * xi_b\n                eta_proj = (1 - t) * eta_a + t * eta_b\n                candidates.append((dist_sq, xi_proj, eta_proj))\n\n        # Find the best candidate (minimum distance)\n        best_dist_sq, best_xi, best_eta = min(candidates, key=lambda item: item[0])\n        return best_xi, best_eta\n\n\ndef find_closest_point(xs, start_elem_idx, elements):\n    \"\"\"\n    Main algorithm to find the closest point on the piecewise surface.\n    \"\"\"\n    current_elem_idx = start_elem_idx\n    xi, eta = 0.0, 0.0  # Initial guess\n    \n    max_slides = 10 # Prevent infinite sliding loops\n    for _ in range(max_slides):\n        elem = elements[current_elem_idx]\n        \n        # Newton-Raphson iterations on the current element\n        max_iter = 20\n        tolerance = 1e-12\n        \n        solution_found_inside = False\n        for k in range(max_iter):\n            X, a_xi, a_eta = elem.get_geometry(xi, eta)\n            \n            # Residual vector\n            res = X - xs\n            r_xi = np.dot(a_xi, res)\n            r_eta = np.dot(a_eta, res)\n            \n            # Check for convergence\n            if np.sqrt(r_xi**2 + r_eta**2)  tolerance:\n                if abs(xi) = 1.0 and abs(eta) = 1.0:\n                    solution_found_inside = True\n                    break\n                else: # Converged outside, handled below\n                    break\n            \n            # Hessian matrix (Full Newton)\n            H_xixi = np.dot(a_xi, a_xi)\n            H_etaeta = np.dot(a_eta, a_eta)\n            H_xieta = np.dot(a_xi, a_eta) + np.dot(elem.c_xi_eta, res)\n            \n            H = np.array([[H_xixi, H_xieta], [H_xieta, H_etaeta]])\n            \n            # Solve for update\n            try:\n                # Use scipy.linalg.solve for robustness if it were allowed\n                update = np.linalg.solve(H, -np.array([r_xi, r_eta]))\n            except np.linalg.LinAlgError:\n                # Fallback to boundary search if Hessian is singular\n                xi, eta = elem.project_onto_boundary(xs)\n                return current_elem_idx, xi, eta\n\n            xi_new, eta_new = xi + update[0], eta + update[1]\n            \n            # Check if iterate exits the domain\n            if abs(xi_new) > 1.0 or abs(eta_new) > 1.0:\n                xi, eta = xi_new, eta_new # Update before exiting loop\n                break\n                \n            xi, eta = xi_new, eta_new\n            # Last iteration and still inside\n            if k == max_iter - 1:\n                solution_found_inside = True\n\n\n        if solution_found_inside:\n            return current_elem_idx, xi, eta\n\n        #---------- Sliding/Boundary Logic ----------\n        # Clip the out-of-bounds point back to the boundary\n        xi_exit = np.clip(xi, -1.0, 1.0)\n        eta_exit = np.clip(eta, -1.0, 1.0)\n\n        # Determine exit edge\n        exit_edge = -1\n        if abs(xi - xi_exit) > abs(eta - eta_exit): # Exited through a xi=const edge\n            exit_edge = 2 if xi > 1.0 else 0\n            tangential_param = eta_exit\n        else: # Exited through an eta=const edge\n            exit_edge = 1 if eta > 1.0 else 3\n            tangential_param = xi_exit\n        \n        neighbor_info = elem.adjacency.get(exit_edge)\n\n        if neighbor_info:\n            neighbor_id, neighbor_edge, s = neighbor_info\n            \n            # Reparameterize onto neighbor\n            new_tangential_param = s * tangential_param\n            \n            if neighbor_edge == 0: # xi' = -1\n                xi_new, eta_new = -1.0, new_tangential_param\n            elif neighbor_edge == 1: # eta' = 1\n                xi_new, eta_new = new_tangential_param, 1.0\n            elif neighbor_edge == 2: # xi' = 1\n                xi_new, eta_new = 1.0, new_tangential_param\n            else: # neighbor_edge == 3, eta' = -1\n                xi_new, eta_new = new_tangential_param, -1.0\n            \n            current_elem_idx = neighbor_id\n            # Step slightly inside the new element for the next iteration\n            xi = np.clip(xi_new, -1.0 + 1e-9, 1.0 - 1e-9)\n            eta = np.clip(eta_new, -1.0 + 1e-9, 1.0 - 1e-9)\n\n        else: # No neighbor, perform boundary search\n            final_xi, final_eta = elem.project_onto_boundary(xs)\n            return current_elem_idx, final_xi, final_eta\n    \n    # Fallback if max_slides is reached\n    final_xi, final_eta = elements[current_elem_idx].project_onto_boundary(xs)\n    return current_elem_idx, final_xi, final_eta\n\n\ndef solve():\n    nodes_all = [\n        [(0,0,0), (0,1,0), (1,1,0.1), (1,0,0.1)],\n        [(1,0,0.1), (1,1,0.1), (2,1,0.2), (2,0,0.2)],\n        [(2,0,0.2), (2,1,0.2), (3,1,0.2), (3,0,0.2)],\n    ]\n\n    # Edge indices: 0: xi=-1, 1: eta=1, 2: xi=1, 3: eta=-1\n    adj_all = [\n        {2: (1, 0, 1)},\n        {0: (0, 2, 1), 2: (2, 0, 1)},\n        {0: (1, 2, 1)},\n    ]\n    \n    elements = [BilinearElement(i, nodes_all[i], adj_all[i]) for i in range(3)]\n    \n    test_cases = [\n        {'xs': (0.3, 0.4, 0.05), 'start': 0},\n        {'xs': (1.4, 0.5, 0.05), 'start': 0},\n        {'xs': (0.6, 1.2, 0.05), 'start': 0},\n        {'xs': (3.7, -0.6, 1.0), 'start': 1},\n        {'xs': (2.6, 0.2, 0.3), 'start': 0},\n    ]\n\n    results = []\n    for case in test_cases:\n        xs = np.array(case['xs'])\n        start_idx = case['start']\n        \n        final_idx, final_xi, final_eta = find_closest_point(xs, start_idx, elements)\n\n        final_elem = elements[final_idx]\n        X, a_xi, a_eta = final_elem.get_geometry(final_xi, final_eta)\n        \n        normal_vec = np.cross(a_xi, a_eta)\n        norm_val = np.linalg.norm(normal_vec)\n        if norm_val  1e-12:\n            # Handle degenerate normal (e.g., at a seam)\n            # Use normal from element center as an approximation\n            _, a_xi_c, a_eta_c = final_elem.get_geometry(0, 0)\n            normal_vec = np.cross(a_xi_c, a_eta_c)\n            norm_val = np.linalg.norm(normal_vec)\n\n        n = normal_vec / norm_val\n        \n        gap = np.dot(n, xs - X)\n        results.append(f\"{gap:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3553969"}]}