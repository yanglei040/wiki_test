{"hands_on_practices": [{"introduction": "The journey from theoretical understanding to practical application begins with building a functional model from the ground up. This first exercise [@problem_id:3600550] guides you through the process of developing a complete finite element simulation for a one-dimensional Shape Memory Alloy (SMA) bar. By starting from fundamental variational principles—minimizing a total potential composed of free energy and dissipation—and implementing a staggered solution algorithm, you will gain direct insight into the coupled mechanics that govern SMA behavior.", "problem": "Consider a one-dimensional bar made of a Shape Memory Alloy (SMA). The bar has length $L$, constant cross-sectional area $A$, and is modeled under small strain kinematics. Let the axial displacement field be $u(x)$ with $x \\in [0,L]$, and the small strain be $\\varepsilon(x) = \\dfrac{du}{dx}$. The material has a linear elastic response with Young’s modulus $E$ in the austenitic phase and undergoes a uniaxial transformation strain of magnitude $\\varepsilon_{\\mathrm{L}}$ modulated by a martensite volume fraction $\\xi(x) \\in [0,1]$, so that the transformation strain is $\\varepsilon_{\\mathrm{tr}}(x) = \\varepsilon_{\\mathrm{L}} \\, \\xi(x)$. Include an isotropic hardening contribution with modulus $H \\ge 0$. The evolution of $\\xi$ is rate-independent with a constant transformation resistance characterized by a stress-like parameter $Y  0$.\n\nYou are tasked to derive, discretize, and implement a finite element solution based on the energetic variational formulation for a single quasi-static load increment. Use the following principle-based building blocks as the starting point (no other constitutive shortcuts are permitted in the problem statement):\n- The small-strain kinematics $\\varepsilon(x) = \\dfrac{du}{dx}$.\n- The quasi-static principle of minimum incremental potential energy for rate-independent systems: at a given load step with previous internal state $\\xi_{\\mathrm{prev}}(x)$, the pair $(u,\\xi)$ minimizes the incremental functional consisting of the Helmholtz free energy plus the rate-independent dissipation, minus the external work.\n- The Helmholtz free energy density consists of the elastic energy associated with the elastic strain $\\varepsilon - \\varepsilon_{\\mathrm{tr}}$ and an isotropic hardening energy depending on $\\xi$.\n- The rate-independent dissipation accumulated over the increment is the integral of a local dissipation density proportional to the absolute change $|\\xi - \\xi_{\\mathrm{prev}}|$.\n\nImpose essential (Dirichlet) boundary conditions $u(0) = 0$ and $u(L) = U$, with no applied tractions and no body forces. Discretize the bar with linear two-noded finite elements, using one constant internal variable $\\xi$ per element, and adopt an alternating-minimization algorithm per increment: for a fixed internal variable field $\\xi$, minimize with respect to $u$; for the updated displacement $u$, minimize locally and independently with respect to each element-wise constant $\\xi$ subject to the box constraint $\\xi \\in [0,1]$. Your implementation must:\n- Assemble the global linear system arising from the stationarity with respect to $u$ and enforce the Dirichlet boundary conditions.\n- Compute the element-averaged strain as the constant strain in each element.\n- Minimize locally the incremental functional with respect to each element’s $\\xi$ using only the principles stated above and general convex analysis ideas (in particular, treat the absolute-value dissipation consistently via subgradients), and enforce the bounds $\\xi \\in [0,1]$.\n- Iterate the two steps until convergence in both $u$ and $\\xi$ to a tight tolerance.\n\nAdopt the following data and units for all cases: $E$ in Pascals ($\\mathrm{Pa}$), $H$ in Pascals ($\\mathrm{Pa}$), $Y$ in Pascals ($\\mathrm{Pa}$), $L$ in meters ($\\mathrm{m}$), $U$ in meters ($\\mathrm{m}$), $\\varepsilon_{\\mathrm{L}}$ dimensionless, $A = 1$ in square meters ($\\mathrm{m}^2$). All computations and answers must be in the International System of Units (SI). The right-end reaction force should be reported in Newtons ($\\mathrm{N}$). Angles do not appear in this problem. The martensite fraction is dimensionless.\n\nTest suite (use these exactly as given):\n- Case A (happy path, partial transformation): $E = 4.0 \\times 10^{10}$, $H = 5.0 \\times 10^{8}$, $Y = 5.0 \\times 10^{7}$, $\\varepsilon_{\\mathrm{L}} = 6.0 \\times 10^{-2}$, $L = 1.0$, $N = 20$, $U = 3.0 \\times 10^{-2}$, $A = 1.0$.\n- Case B (sub-threshold, no transformation): $E = 4.0 \\times 10^{10}$, $H = 5.0 \\times 10^{8}$, $Y = 5.0 \\times 10^{7}$, $\\varepsilon_{\\mathrm{L}} = 6.0 \\times 10^{-2}$, $L = 1.0$, $N = 20$, $U = 1.0 \\times 10^{-2}$, $A = 1.0$.\n- Case C (boundary threshold): $E = 4.0 \\times 10^{10}$, $H = 5.0 \\times 10^{8}$, $Y = 5.0 \\times 10^{7}$, $\\varepsilon_{\\mathrm{L}} = 6.0 \\times 10^{-2}$, $L = 1.0$, $N = 20$, $U = L \\cdot \\dfrac{Y}{E \\, \\varepsilon_{\\mathrm{L}}}$, $A = 1.0$.\n\nYour program must compute, for each case, the converged spatial average of the martensite fraction $\\bar{\\xi}$ over the bar (dimensionless) and the right-end reaction force $R$ (in $\\mathrm{N}$). The final output must be a single line containing a comma-separated list with results in the order\n$[\\bar{\\xi}^{\\mathrm{A}}, R^{\\mathrm{A}}, \\bar{\\xi}^{\\mathrm{B}}, R^{\\mathrm{B}}, \\bar{\\xi}^{\\mathrm{C}}, R^{\\mathrm{C}}]$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[r_1,r_2,r_3,r_4,r_5,r_6]$). Report all values as floating-point numbers. For $R$, the unit is $\\mathrm{N}$; for $\\bar{\\xi}$ it is dimensionless.", "solution": "The problem requires the derivation and implementation of a finite element solution for a one-dimensional Shape Memory Alloy (SMA) bar subjected to a quasi-static prescribed displacement. The formulation is based on the principle of minimum incremental potential energy for a rate-independent system.\n\n### **1. Theoretical Formulation**\n\nThe state of the system is described by the axial displacement field $u(x)$ and the martensite volume fraction field $\\xi(x)$. For a single quasi-static load increment starting from a virgin state ($u_{\\mathrm{prev}} = 0$, $\\xi_{\\mathrm{prev}} = 0$), we seek to find the pair $(u, \\xi)$ that minimizes the total incremental potential energy functional $\\Pi[u, \\xi]$. This functional is the sum of the Helmholtz free energy and the dissipated energy integrated over the bar's volume.\n\nThe small strain is given by the kinematic relation:\n$$ \\varepsilon(x) = \\frac{du}{dx} $$\n\nThe total strain $\\varepsilon$ is additively decomposed into an elastic part $\\varepsilon_e$ and a transformation part $\\varepsilon_{tr}$:\n$$ \\varepsilon = \\varepsilon_e + \\varepsilon_{tr} $$\nThe transformation strain is proportional to the martensite fraction $\\xi$:\n$$ \\varepsilon_{tr}(x) = \\varepsilon_{\\mathrm{L}} \\xi(x) $$\nwhere $\\varepsilon_{\\mathrm{L}}$ is the maximum transformation strain.\n\nThe Helmholtz free energy density, $\\psi$, comprises an elastic strain energy term and an isotropic hardening term:\n$$ \\psi(\\varepsilon, \\xi) = \\frac{1}{2} E (\\varepsilon - \\varepsilon_{tr})^2 + \\frac{1}{2} H \\xi^2 = \\frac{1}{2} E (\\varepsilon - \\varepsilon_{\\mathrm{L}} \\xi)^2 + \\frac{1}{2} H \\xi^2 $$\nwhere $E$ is the Young's modulus and $H$ is the hardening modulus.\n\nThe rate-independent dissipation density for the first load increment is given by $\\mathcal{D}(\\xi, \\xi_{\\mathrm{prev}=0}) = Y |\\xi - 0|$. Since the martensite fraction $\\xi$ is non-negative by definition ($\\xi \\in [0,1]$), this simplifies to:\n$$ \\mathcal{D}(\\xi) = Y \\xi $$\nwhere $Y$ is the constant transformation resistance.\n\nThe total incremental potential energy functional to be minimized is:\n$$ \\Pi[u, \\xi] = \\int_0^L \\left[ \\psi(\\varepsilon(x), \\xi(x)) + \\mathcal{D}(\\xi(x)) \\right] A \\, dx $$\n$$ \\Pi[u, \\xi] = \\int_0^L \\left[ \\frac{1}{2} E \\left( \\frac{du}{dx} - \\varepsilon_{\\mathrm{L}} \\xi \\right)^2 + \\frac{1}{2} H \\xi^2 + Y \\xi \\right] A \\, dx $$\nsubject to the boundary conditions $u(0) = 0$, $u(L) = U$, and the constraint $0 \\le \\xi(x) \\le 1$.\n\n### **2. Finite Element Discretization and Algorithmic Scheme**\n\nWe discretize the bar of length $L$ into $N$ linear two-noded finite elements, each of length $h=L/N$.\nThe displacement field $u(x)$ is approximated with piecewise linear functions, and the martensite fraction $\\xi(x)$ is taken to be piecewise constant, with a single value $\\xi_e$ for each element $e$.\n\nThe discretized functional is a sum over all elements:\n$$ \\Pi^h(\\mathbf{u}, \\boldsymbol{\\xi}) = \\sum_{e=1}^N \\left[ \\frac{1}{2} E (\\varepsilon_e - \\varepsilon_{\\mathrm{L}} \\xi_e)^2 + \\frac{1}{2} H \\xi_e^2 + Y \\xi_e \\right] A h $$\nwhere $\\mathbf{u}$ is the vector of nodal displacements, $\\boldsymbol{\\xi}$ is the vector of element-wise martensite fractions, and $\\varepsilon_e = (u_i - u_{i-1})/h$ is the constant strain in element $e$ (connecting nodes $i-1$ and $i$).\n\nWe employ an alternating-minimization (or staggered) algorithm to solve the coupled minimization problem. Starting with an initial guess (e.g., $\\boldsymbol{\\xi}^{(0)} = \\mathbf{0}$), we iterate two steps until convergence:\n\n#### **Step 1: Displacement Update (u-step)**\nFor a fixed martensite field $\\boldsymbol{\\xi} = \\boldsymbol{\\xi}^{(k)}$, we find the displacement field $\\mathbf{u}^{(k+1)}$ that minimizes $\\Pi^h(\\mathbf{u}, \\boldsymbol{\\xi}^{(k)})$. This is a standard linear elasticity problem with an additional force term arising from the transformation strain. Minimization leads to a linear system of equations $\\mathbf{K}\\mathbf{u} = \\mathbf{f}_{tr}$, where $\\mathbf{K}$ is the global stiffness matrix and $\\mathbf{f}_{tr}$ is the nodal force vector due to transformation strains.\n\nFor the free internal nodes $i=1, \\dots, N-1$, the equilibrium equations are:\n$$ \\frac{EA}{h} (-u_{i-1} + 2u_i - u_{i+1}) = EA\\varepsilon_{\\mathrm{L}}(\\xi_{i-1} - \\xi_i) $$\nwhere we adopt the convention that element $i$ connects nodes $i$ and $i+1$, and its martensite fraction is $\\xi_i$. After enforcing the boundary conditions $u_0=0$ and $u_N=U$, we solve the resulting linear system for the unknown internal nodal displacements $u_1, \\dots, u_{N-1}$.\n\n#### **Step 2: Internal Variable Update ($\\xi$-step)**\nFor a fixed displacement field $\\mathbf{u} = \\mathbf{u}^{(k+1)}$, the total functional decouples into $N$ independent minimization problems, one for each element's $\\xi_e$. We find $\\xi_e^{(k+1)}$ that minimizes the local energy:\n$$ \\pi_e(\\xi_e) = \\left[ \\frac{1}{2} E (\\varepsilon_e - \\varepsilon_{\\mathrm{L}} \\xi_e)^2 + \\frac{1}{2} H \\xi_e^2 + Y \\xi_e \\right] A h $$\nsubject to $0 \\le \\xi_e \\le 1$. The strain $\\varepsilon_e$ in each element is now a known quantity calculated from the updated displacement field $\\mathbf{u}^{(k+1)}$.\n\nThe function $\\pi_e(\\xi_e)$ is a convex quadratic in $\\xi_e$. Its unconstrained minimum is found by setting its derivative to zero:\n$$ \\frac{d\\pi_e}{d\\xi_e} = \\left[ E(\\varepsilon_e - \\varepsilon_L \\xi_e)(-\\varepsilon_L) + H\\xi_e + Y \\right] A h = 0 $$\n$$ (E \\varepsilon_{\\mathrm{L}}^2 + H)\\xi_e - (E \\varepsilon_e \\varepsilon_{\\mathrm{L}} - Y) = 0 $$\nThe unconstrained minimizer is:\n$$ \\xi_e^* = \\frac{E \\varepsilon_e \\varepsilon_{\\mathrm{L}} - Y}{E \\varepsilon_{\\mathrm{L}}^2 + H} $$\nThe solution subject to the constraint $\\xi_e \\in [0,1]$ is obtained by projecting $\\xi_e^*$ onto this interval:\n$$ \\xi_e^{(k+1)} = \\max(0, \\min(1, \\xi_e^*)) $$\n\nThe two steps are iterated until the changes in both $\\mathbf{u}$ and $\\boldsymbol{\\xi}$ fall below a chosen tolerance.\n\n### **3. Post-Processing**\n\nUpon convergence, we compute the required outputs:\n- **Average Martensite Fraction ($\\bar{\\xi}$)**: As elements have equal length, this is the arithmetic mean of the element values:\n$$ \\bar{\\xi} = \\frac{1}{N} \\sum_{e=1}^N \\xi_e $$\n- **Right-End Reaction Force ($R$)**: This is the force at the support $x=L$, which equals the axial stress $\\sigma_N$ in the last element ($e=N$) multiplied by the area $A$. The stress is given by the constitutive law:\n$$ R = A \\sigma_N = A E (\\varepsilon_N - \\varepsilon_{\\mathrm{L}} \\xi_N) $$\nwhere $\\varepsilon_N = (u_N - u_{N-1})/h$ is the strain in the last element.\n\nThis methodology provides a robust and physically-consistent framework for solving the specified problem. For the specific case of no body forces, the internal stress becomes uniform, leading to a uniform strain and martensite fraction field, simplifying the convergence behavior of the staggered scheme significantly.", "answer": "```python\nimport numpy as np\n\ndef run_simulation(E, H, Y, eps_L, L, N, U, A):\n    \"\"\"\n    Solves the 1D SMA bar problem using an alternate minimization scheme.\n\n    Args:\n        E (float): Young's modulus [Pa]\n        H (float): Hardening modulus [Pa]\n        Y (float): Transformation resistance [Pa]\n        eps_L (float): Transformation strain magnitude [-]\n        L (float): Bar length [m]\n        N (int): Number of elements\n        U (float): Prescribed displacement at right end [m]\n        A (float): Cross-sectional area [m^2]\n\n    Returns:\n        tuple: A tuple containing:\n            - xi_avg (float): Spatially averaged martensite fraction.\n            - R (float): Reaction force at the right end [N].\n    \"\"\"\n    # Discretization parameter\n    h = L / N\n\n    # Initialize fields\n    # u: displacement vector of size N+1 for nodes 0 to N\n    u = np.linspace(0.0, U, N + 1)\n    # xi: martensite fraction vector of size N for elements 0 to N-1\n    xi = np.zeros(N)\n\n    # Alternate-Minimization (Staggered) Loop\n    max_iter = 100\n    tolerance = 1e-10\n    \n    for k in range(max_iter):\n        u_old = u.copy()\n        xi_old = xi.copy()\n\n        # Step 1: Minimize w.r.t. displacement u (for fixed xi)\n        # We solve a linear system K_free * u_free = f_eff for the free\n        # internal nodes u[1],...,u[N-1].\n        \n        num_free_dofs = N - 1\n        if num_free_dofs  0:\n            # Stiffness matrix for free nodes (N-1 x N-1)\n            K_free = (E * A / h) * (np.diag(np.full(num_free_dofs, 2.0)) - \n                                   np.diag(np.ones(num_free_dofs - 1), 1) - \n                                   np.diag(np.ones(num_free_dofs - 1), -1))\n            \n            # Effective force vector for free nodes\n            f_eff = np.zeros(num_free_dofs)\n            const_f = E * A * eps_L\n\n            # Element indices are 0 to N-1. Node indices are 0 to N.\n            # Element e is between node e and e+1.\n            # Internal node i is between element i-1 and i.\n            # Loop for nodes 1 to N-2\n            for i in range(1, N - 1):\n                f_eff[i-1] = const_f * (xi[i-1] - xi[i])\n            \n            # Last free node (N-1) gets force from xi and BC at u[N]\n            f_eff[N-2] = const_f * (xi[N-2] - xi[N-1]) + (E * A / h) * U\n\n            # Solve for internal displacements\n            u_free = np.linalg.solve(K_free, f_eff)\n            u[1:N] = u_free\n\n        # Step 2: Minimize w.r.t. internal variable xi (for fixed u)\n        # This is a local update for each element, indexed 0 to N-1.\n        \n        xi_denom = E * eps_L**2 + H\n        if xi_denom == 0: xi_denom = 1.0 # Avoid division by zero, though unlikely with H=0, E0\n\n        for e in range(N):\n            strain_e = (u[e+1] - u[e]) / h\n            xi_num = E * strain_e * eps_L - Y\n            xi_star = xi_num / xi_denom\n            xi[e] = np.clip(xi_star, 0.0, 1.0)\n\n        # Step 3: Check for convergence\n        u_err = np.linalg.norm(u - u_old)\n        xi_err = np.linalg.norm(xi - xi_old)\n        \n        u_norm = np.linalg.norm(u)\n        xi_norm = np.linalg.norm(xi)\n        \n        u_rel_err = u_err / u_norm if u_norm  tolerance else u_err\n        xi_rel_err = xi_err / xi_norm if xi_norm  tolerance else xi_err\n\n        if u_rel_err  tolerance and xi_rel_err  tolerance:\n            break\n            \n    # Post-processing after convergence\n    xi_avg = np.mean(xi)\n    \n    # Reaction force R = A * sigma_N = A * E * (epsilon_N - eps_L * xi_N)\n    strain_last_elem = (u[N] - u[N-1]) / h\n    # The last element is indexed N-1\n    xi_last_elem = xi[N-1]\n    R = A * E * (strain_last_elem - eps_L * xi_last_elem)\n    \n    return xi_avg, R\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and print results.\n    \"\"\"\n    params_A = {'E': 4.0e10, 'H': 5.0e8, 'Y': 5.0e7, 'eps_L': 6.0e-2, \n                'L': 1.0, 'N': 20, 'U': 3.0e-2, 'A': 1.0}\n    params_B = {'E': 4.0e10, 'H': 5.0e8, 'Y': 5.0e7, 'eps_L': 6.0e-2, \n                'L': 1.0, 'N': 20, 'U': 1.0e-2, 'A': 1.0}\n    \n    # For Case C, U is defined by a formula\n    E_C, Y_C, eps_L_C, L_C = 4.0e10, 5.0e7, 6.0e-2, 1.0\n    U_C = L_C * Y_C / (E_C * eps_L_C)\n    params_C = {'E': E_C, 'H': 5.0e8, 'Y': Y_C, 'eps_L': eps_L_C, \n                'L': L_C, 'N': 20, 'U': U_C, 'A': 1.0}\n    \n    test_cases = [params_A, params_B, params_C]\n    \n    results = []\n    for params in test_cases:\n        xi_avg, R = run_simulation(**params)\n        results.extend([xi_avg, R])\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3600550"}, {"introduction": "While the staggered scheme is straightforward to implement, state-of-the-art implicit finite element codes rely on monolithic solution methods for their robustness and superior convergence rate. The cornerstone of such solvers is the consistent algorithmic tangent, which linearizes the constitutive response at the end of an increment. This practice [@problem_id:3600551] challenges you to derive and implement this crucial material tangent, providing a deep dive into the local constitutive update that forms the heart of advanced computational models.", "problem": "You are to derive and implement the one-dimensional consistent algorithmic tangent for a pseudoelastic Shape Memory Alloy (SMA) within computational solid mechanics, starting from thermodynamically consistent principles. The consistent algorithmic tangent is defined as the derivative of stress with respect to strain, computed from the exact incremental stress update algorithm when an internal variable (the martensitic volume fraction) evolves under a transformation consistency condition. Your derivation and implementation must be scientifically sound and follow fundamental thermodynamics and mechanics. The implementation must produce numerically testable results for a specified test suite.\n\nConsider a one-dimensional bar made of a pseudoelastic SMA subjected to imposed small strain increments. Let the Helmholtz free energy density be defined as\n$$\n\\psi(\\varepsilon,\\xi,T) = \\tfrac{1}{2} E \\left(\\varepsilon - \\Lambda \\xi\\right)^2 + \\tfrac{1}{2} H \\xi^2 - s_0 \\left(T - T_0\\right)\\xi,\n$$\nwhere $E$ is the Young's modulus, $\\varepsilon$ is the total strain, $\\Lambda$ is the maximum transformation strain magnitude, $\\xi \\in [0,1]$ is the martensitic volume fraction, $H$ is the transformation hardening modulus, $s_0$ is a thermal coupling coefficient, $T$ is the absolute temperature, and $T_0$ is a reference temperature. The Cauchy stress is obtained from the standard thermodynamic relation\n$$\n\\sigma = \\frac{\\partial \\psi}{\\partial \\varepsilon} = E \\left(\\varepsilon - \\Lambda \\xi\\right).\n$$\nThe thermodynamic driving force for forward transformation is defined as\n$$\nr = -\\frac{\\partial \\psi}{\\partial \\xi} = E \\Lambda \\left(\\varepsilon - \\Lambda \\xi\\right) - H \\xi + s_0 \\left(T - T_0\\right),\n$$\nand forward transformation is activated when the consistency condition for the forward transformation function is enforced via Kuhn-Tucker conditions: the forward transformation function $f = r - R_{\\mathrm{fwd}}$ satisfies $f \\le 0$, forward transformation rate $\\dot{\\xi} \\ge 0$, and the complementarity condition $f \\, \\dot{\\xi} = 0$. When $\\dot{\\xi}  0$, consistency requires $f = 0$.\n\nYour tasks are:\n- From the given free energy, derive the stress update and the evolution of $\\xi$ under the forward transformation consistency condition when active, ensuring admissibility $\\xi \\in [0,1]$ and monotonicity for forward transformation increments. Explicitly derive the consistent algorithmic tangent, defined as $\\mathbb{C}_{\\mathrm{alg}} = \\dfrac{\\mathrm{d}\\sigma}{\\mathrm{d}\\varepsilon}$, both in the elastic regime (no transformation) and in the active forward transformation regime (unsaturated).\n- Implement a robust one-dimensional update algorithm that, for a given strain $\\varepsilon$, temperature $T$, and previous martensitic fraction $\\xi^{\\mathrm{prev}}$, returns the updated stress $\\sigma$, updated fraction $\\xi$, and consistent algorithmic tangent $\\mathbb{C}_{\\mathrm{alg}}$ suitable for Newton-Raphson iterations in the Finite Element Method (FEM).\n- The update must follow:\n  - Compute a trial driving force $r$ using $\\xi^{\\mathrm{prev}}$.\n  - If $r \\le R_{\\mathrm{fwd}}$ or $\\xi^{\\mathrm{prev}} \\ge 1$, the step is elastic with $\\xi = \\xi^{\\mathrm{prev}}$, $\\sigma = E (\\varepsilon - \\Lambda \\xi)$, and $\\mathbb{C}_{\\mathrm{alg}} = E$.\n  - If $r  R_{\\mathrm{fwd}}$ and $\\xi^{\\mathrm{prev}}  1$, enforce consistency $r = R_{\\mathrm{fwd}}$ to obtain the updated $\\xi$; clamp to the admissible interval and enforce forward monotonicity $\\xi \\ge \\xi^{\\mathrm{prev}}$. If the update clamps at $\\xi=1$, set $\\mathbb{C}_{\\mathrm{alg}} = E$, otherwise use the derived active-regime $\\mathbb{C}_{\\mathrm{alg}}$.\n\nThe physical and numerical parameters to be used are:\n- $E = 70 \\times 10^{9}$ $\\,\\mathrm{Pa}$,\n- $\\Lambda = 0.06$,\n- $H = 0.5 \\times 10^{9}$ $\\,\\mathrm{Pa}$,\n- $s_0 = 5 \\times 10^{6}$ $\\,\\mathrm{Pa/K}$,\n- $R_{\\mathrm{fwd}} = 150 \\times 10^{6}$ $\\,\\mathrm{Pa}$,\n- $T_0 = 293$ $\\,\\mathrm{K}$.\n\nLet the absolute temperature unit be Kelvin and the strain be dimensionless. The stress and the algorithmic tangent must be expressed in Pascal ($\\,\\mathrm{Pa}$). The martensitic fraction $\\xi$ is dimensionless.\n\nTest suite:\n- Case $1$ (elastic regime): $\\varepsilon = 0.005$, $T = 293$, $\\xi^{\\mathrm{prev}} = 0.0$.\n- Case $2$ (active unsaturated transformation): $\\varepsilon = 0.02$, $T = 323$, $\\xi^{\\mathrm{prev}} = 0.0$.\n- Case $3$ (active with nonzero previous fraction): $\\varepsilon = 0.03$, $T = 373$, $\\xi^{\\mathrm{prev}} = 0.3$.\n- Case $4$ (saturated transformation): $\\varepsilon = 0.04$, $T = 493$, $\\xi^{\\mathrm{prev}} = 0.8$.\n\nYour program must compute, for each case, the triplet $[\\sigma, \\mathbb{C}_{\\mathrm{alg}}, \\xi]$, where $\\sigma$ and $\\mathbb{C}_{\\mathrm{alg}}$ are rounded to the nearest integer in $\\,\\mathrm{Pa}$, and $\\xi$ is rounded to six decimal places. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is itself a list corresponding to one test case. For example: $[\\,[\\sigma_1, \\mathbb{C}_1, \\xi_1], [\\sigma_2, \\mathbb{C}_2, \\xi_2], [\\sigma_3, \\mathbb{C}_3, \\xi_3], [\\sigma_4, \\mathbb{C}_4, \\xi_4]\\,]$.", "solution": "The problem statement is assessed to be valid. It is scientifically grounded in the principles of continuum thermodynamics, specifically for modeling pseudoelastic Shape Memory Alloys (SMAs), and is a well-posed problem in computational solid mechanics. All necessary parameters and logical steps for the algorithm are provided, and there are no internal contradictions or factual inaccuracies.\n\nThe solution proceeds with the derivation of the necessary constitutive update equations and the consistent algorithmic tangent, followed by a summary of the numerical algorithm.\n\nThe state of the material is described by the total strain $\\varepsilon$, the martensitic volume fraction $\\xi$, and the absolute temperature $T$. The Helmholtz free energy density $\\psi$ is given by\n$$\n\\psi(\\varepsilon,\\xi,T) = \\tfrac{1}{2} E \\left(\\varepsilon - \\Lambda \\xi\\right)^2 + \\tfrac{1}{2} H \\xi^2 - s_0 \\left(T - T_0\\right)\\xi\n$$\nwhere $E$ is the Young's modulus, $\\Lambda$ is the maximum transformation strain, $H$ is the transformation hardening modulus, $s_0$ is a thermomechanical coupling coefficient, and $T_0$ is a reference temperature.\n\nThe Cauchy stress $\\sigma$ and the thermodynamic driving force $r$ for phase transformation are derived from standard thermodynamic relations:\n$$\n\\sigma = \\frac{\\partial \\psi}{\\partial \\varepsilon} = E \\left(\\varepsilon - \\Lambda \\xi\\right)\n$$\n$$\nr = -\\frac{\\partial \\psi}{\\partial \\xi} = E \\Lambda \\left(\\varepsilon - \\Lambda \\xi\\right) - H \\xi + s_0 \\left(T - T_0\\right)\n$$\nForward transformation from austenite to martensite ($\\dot{\\xi}  0$) occurs when the driving force $r$ reaches a critical threshold $R_{\\mathrm{fwd}}$. This is governed by the Kuhn-Tucker conditions for the forward transformation function $f = r - R_{\\mathrm{fwd}}$:\n$$\nf \\le 0, \\quad \\dot{\\xi} \\ge 0, \\quad f \\dot{\\xi} = 0\n$$\nAdditionally, the martensitic fraction is physically constrained to the interval $\\xi \\in [0,1]$.\n\nThe constitutive update algorithm for a given strain increment proceeds as follows. Given the state $(\\xi^{\\mathrm{prev}})$ at the beginning of a step and the new total strain $\\varepsilon$ and temperature $T$, we first compute a trial driving force assuming no change in the martensitic fraction, i.e., with $\\xi = \\xi^{\\mathrm{prev}}$:\n$$\nr_{\\mathrm{trial}} = E \\Lambda (\\varepsilon - \\Lambda \\xi^{\\mathrm{prev}}) - H \\xi^{\\mathrm{prev}} + s_0(T - T_0)\n$$\n\nIf $r_{\\mathrm{trial}} \\le R_{\\mathrm{fwd}}$ or if the material is already fully martensitic ($\\xi^{\\mathrm{prev}} \\ge 1$), the step is elastic (no further transformation occurs). In this case, the martensitic fraction remains unchanged, $\\xi = \\xi^{\\mathrm{prev}}$.\n\nIf $r_{\\mathrm{trial}}  R_{\\mathrm{fwd}}$ and $\\xi^{\\mathrm{prev}}  1$, a forward phase transformation occurs. The evolution of $\\xi$ is governed by the consistency condition, which dictates that during active transformation, the driving force must remain at the threshold value, i.e., $r = R_{\\mathrm{fwd}}$. We solve for the value of $\\xi$ that satisfies this condition:\n$$\nE \\Lambda \\left(\\varepsilon - \\Lambda \\xi\\right) - H \\xi + s_0 \\left(T - T_0\\right) = R_{\\mathrm{fwd}}\n$$\nThis is a linear equation for $\\xi$. Rearranging the terms to solve for $\\xi$ yields:\n$$\nE \\Lambda \\varepsilon + s_0(T-T_0) - R_{\\mathrm{fwd}} = (E \\Lambda^2 + H) \\xi\n$$\n$$\n\\xi_{\\mathrm{consistency}} = \\frac{E \\Lambda \\varepsilon + s_0(T-T_0) - R_{\\mathrm{fwd}}}{E \\Lambda^2 + H}\n$$\nThe final updated martensitic fraction $\\xi$ must respect the physical bounds, so we clamp the value at $\\xi=1$ if full transformation is reached. The monotonicity condition $\\xi \\ge \\xi^{\\mathrm{prev}}$ is implicitly satisfied by activating the transformation only when $r_{\\mathrm{trial}}  R_{\\mathrm{fwd}}$. Thus, the updated fraction is:\n$$\n\\xi = \\min\\left(1, \\xi_{\\mathrm{consistency}}\\right)\n$$\n\nThe consistent algorithmic tangent $\\mathbb{C}_{\\mathrm{alg}} = \\frac{\\mathrm{d}\\sigma}{\\mathrm{d}\\varepsilon}$ is required for implicit finite element solvers. It is the derivative of the stress at the end of the increment with respect to the total strain at the end of the increment.\n\n**1. Elastic and Saturated Regimes**\nIn the elastic regime, $\\xi$ is constant with respect to changes in $\\varepsilon$ (i.e., $\\xi = \\xi^{\\mathrm{prev}}$). The same holds for the saturated regime, where $\\xi$ is clamped at $1$. In both cases, $\\frac{\\mathrm{d}\\xi}{\\mathrm{d}\\varepsilon} = 0$.\nThe derivative of the stress is then straightforward:\n$$\n\\mathbb{C}_{\\mathrm{alg}} = \\frac{\\mathrm{d}\\sigma}{\\mathrm{d}\\varepsilon} = \\frac{\\mathrm{d}}{\\mathrm{d}\\varepsilon} \\left[ E \\left(\\varepsilon - \\Lambda \\xi\\right) \\right] = E \\left(1 - \\Lambda \\frac{\\mathrm{d}\\xi}{\\mathrm{d}\\varepsilon}\\right) = E(1 - 0)\n$$\n$$\n\\mathbb{C}_{\\mathrm{alg}} = E\n$$\n\n**2. Active Unsaturated Transformation Regime**\nIn this regime, $\\xi$ evolves as a function of $\\varepsilon$ to maintain the consistency condition $r = R_{\\mathrm{fwd}}$. To find $\\frac{\\mathrm{d}\\xi}{\\mathrm{d}\\varepsilon}$, we differentiate the consistency condition with respect to $\\varepsilon$, treating $T$ as a fixed parameter for the differentiation:\n$$\n\\frac{\\mathrm{d}}{\\mathrm{d}\\varepsilon} \\left[ E \\Lambda \\left(\\varepsilon - \\Lambda \\xi(\\varepsilon)\\right) - H \\xi(\\varepsilon) + s_0 \\left(T - T_0\\right) - R_{\\mathrm{fwd}} \\right] = 0\n$$\n$$\nE \\Lambda - E \\Lambda^2 \\frac{\\mathrm{d}\\xi}{\\mathrm{d}\\varepsilon} - H \\frac{\\mathrm{d}\\xi}{\\mathrm{d}\\varepsilon} = 0\n$$\nSolving for $\\frac{\\mathrm{d}\\xi}{\\mathrm{d}\\varepsilon}$:\n$$\nE \\Lambda = \\left( E \\Lambda^2 + H \\right) \\frac{\\mathrm{d}\\xi}{\\mathrm{d}\\varepsilon} \\implies \\frac{\\mathrm{d}\\xi}{\\mathrm{d}\\varepsilon} = \\frac{E \\Lambda}{E \\Lambda^2 + H}\n$$\nSubstituting this into the derivative of the stress equation:\n$$\n\\mathbb{C}_{\\mathrm{alg}} = E \\left(1 - \\Lambda \\frac{\\mathrm{d}\\xi}{\\mathrm{d}\\varepsilon}\\right) = E \\left(1 - \\Lambda \\left(\\frac{E \\Lambda}{E \\Lambda^2 + H}\\right)\\right)\n$$\n$$\n\\mathbb{C}_{\\mathrm{alg}} = E \\left( \\frac{E \\Lambda^2 + H - E \\Lambda^2}{E \\Lambda^2 + H} \\right) = \\frac{E H}{E \\Lambda^2 + H}\n$$\nThis is the consistent algorithmic tangent for the active, unsaturated transformation regime. It represents the reduced stiffness of the material during phase transformation.\n\nIn summary, the algorithm to be implemented is:\n1.  Calculate $r_{\\mathrm{trial}}$ using $\\varepsilon$, $T$, and $\\xi^{\\mathrm{prev}}$.\n2.  If $r_{\\mathrm{trial}} \\le R_{\\mathrm{fwd}}$ or $\\xi^{\\mathrm{prev}} \\ge 1$:\n    - $\\xi = \\xi^{\\mathrm{prev}}$\n    - $\\mathbb{C}_{\\mathrm{alg}} = E$\n3.  Otherwise (active transformation):\n    - Calculate $\\xi_{\\mathrm{consistency}}$ from the derived formula.\n    - Set $\\xi = \\min(1, \\xi_{\\mathrm{consistency}})$.\n    - If $\\xi = 1$ (saturated), $\\mathbb{C}_{\\mathrm{alg}} = E$.\n    - If $\\xi  1$ (unsaturated), $\\mathbb{C}_{\\mathrm{alg}} = \\frac{EH}{E \\Lambda^2 + H}$.\n4.  In all cases, calculate the final stress as $\\sigma = E(\\varepsilon - \\Lambda \\xi)$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef update_sma_state(epsilon, T, xi_prev, params):\n    \"\"\"\n    Computes the updated stress, algorithmic tangent, and martensitic fraction for a 1D SMA.\n\n    Args:\n        epsilon (float): Total strain.\n        T (float): Absolute temperature in Kelvin.\n        xi_prev (float): Martensitic fraction from the previous step.\n        params (dict): Dictionary of material parameters.\n\n    Returns:\n        tuple: A tuple containing the updated stress (sigma, Pa), consistent\n               algorithmic tangent (C_alg, Pa), and martensitic fraction (xi).\n    \"\"\"\n    E = params['E']\n    Lambda = params['Lambda']\n    H = params['H']\n    s0 = params['s0']\n    R_fwd = params['R_fwd']\n    T0 = params['T0']\n\n    # Step 1: Compute trial driving force\n    r_trial = E * Lambda * (epsilon - Lambda * xi_prev) - H * xi_prev + s0 * (T - T0)\n    \n    # Step 2: Check for elastic response\n    if r_trial = R_fwd or xi_prev = 1.0:\n        xi = xi_prev\n        C_alg = E\n        sigma = E * (epsilon - Lambda * xi)\n        return sigma, C_alg, xi\n    \n    # Step 3: Active transformation\n    else:\n        # Denominator for xi_consistency and C_alg calculation\n        denom = E * Lambda**2 + H\n        \n        # Calculate xi from the consistency condition\n        xi_consistency = (E * Lambda * epsilon + s0 * (T - T0) - R_fwd) / denom\n        \n        # Clamp xi to be at most 1.0. Monotonicity (xi = xi_prev) is guaranteed\n        # by the r_trial  R_fwd condition.\n        xi = min(1.0, xi_consistency)\n        \n        # Calculate the consistent algorithmic tangent\n        if xi = 1.0:\n            # Saturated transformation, tangent reverts to elastic modulus\n            C_alg = E\n        else:\n            # Active, unsaturated transformation\n            C_alg = (E * H) / denom\n        \n        # Calculate the final stress\n        sigma = E * (epsilon - Lambda * xi)\n        \n        return sigma, C_alg, xi\n\ndef solve():\n    \"\"\"\n    Main function to run the SMA model for the specified test suite.\n    \"\"\"\n    # Define physical and numerical parameters\n    params = {\n        'E': 70e9,       # Pa\n        'Lambda': 0.06,  # dimensionless\n        'H': 0.5e9,      # Pa\n        's0': 5e6,       # Pa/K\n        'R_fwd': 150e6,  # Pa\n        'T0': 293.0      # K\n    }\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0.005, 293, 0.0), # Case 1 (elastic regime)\n        (0.02,  323, 0.0), # Case 2 (active unsaturated transformation)\n        (0.03,  373, 0.3), # Case 3 (active with nonzero previous fraction)\n        (0.04,  493, 0.8)  # Case 4 (saturated transformation)\n    ]\n\n    results = []\n    for case in test_cases:\n        epsilon_input, T_input, xi_prev_input = case\n        \n        # Get the updated state variables\n        sigma, C_alg, xi = update_sma_state(epsilon_input, T_input, xi_prev_input, params)\n        \n        # Round results to the specified precision\n        sigma_rounded = int(round(sigma))\n        C_alg_rounded = int(round(C_alg))\n        xi_rounded = round(xi, 6)\n        \n        results.append([sigma_rounded, C_alg_rounded, xi_rounded])\n\n    # Final print statement in the exact required format.\n    # The default str representation of a list includes spaces. We build the string manually.\n    results_str = ','.join([f\"[{s},{c},{x}]\" for s, c, x in results])\n    print(f\"[{results_str}]\")\n\nsolve()\n```", "id": "3600551"}, {"introduction": "Having explored both a simple staggered solver and the details of an implicit update, we can now critically evaluate their performance. This final exercise [@problem_id:3600557] pits a simplified Operator Splitting (OS) scheme against a fully consistent Monolithic Newton-Raphson (MN) solver for a complex, nonproportional loading path. By quantifying the algorithmic error in the physically crucial quantity of total dissipation, you will develop a nuanced understanding of the trade-offs between algorithmic simplicity and thermodynamic consistency in computational mechanics.", "problem": "Consider a one-dimensional pseudoelastic Shape Memory Alloy (SMA) model with a single internal variable representing the martensite fraction. The goal is to compare an operator splitting strategy to a monolithic Newton–Raphson strategy under nonproportional thermomechanical paths and to quantify algorithmic error in terms of the time integral of dissipation. The comparison must be implemented as a complete, runnable program.\n\nThe model is defined by the following ingredients and constraints, which must be respected and derived from first principles.\n\n1. Let the total strain be denoted by $\\epsilon$, the Cauchy stress by $\\sigma$, the temperature by $T$, and the martensite fraction by $\\xi \\in [0,1]$, where $0$ indicates a fully austenitic state and $1$ indicates a fully martensitic state. Let the transformation strain scale be $\\epsilon_L  0$.\n\n2. The Helmholtz free energy per unit reference volume is approximated by a quadratic elastic part with a mixture rule for the elastic modulus and a linear transformation strain, plus a linear hardening contribution in the internal variable. Let the Young’s modulus in the austenite phase be $E_A$ and in the martensite phase be $E_M$. The mixture rule for the modulus is $E(\\xi) = E_A (1 - \\xi) + E_M \\xi$. Under small strain, the stress is $\\sigma = E(\\xi)\\left(\\epsilon - \\epsilon_L \\xi \\right)$.\n\n3. The thermodynamic driving force for forward transformation is derived from the negative partial derivative of the free energy with respect to $\\xi$. In this simplified pseudoelastic setting, adopt\n$$\nY(\\sigma,\\xi) = \\sigma \\epsilon_L - H \\xi,\n$$\nwhere $H  0$ is a hardening-like parameter with units of stress.\n\n4. The transformation criterion is given by a rate-independent consistency condition with a temperature-dependent threshold. Define the threshold as\n$$\nR(T) = R_0 + b \\left(T - T_0\\right),\n$$\nwith $R_00$, $b$ constant, and $T_0$ a reference temperature. The forward transformation occurs when the yield function $F = Y(\\sigma,\\xi) - R(T)$ satisfies $F \\ge 0$ and the internal variable increases, subject to the constraints $\\dot{\\xi} \\ge 0$, $\\xi \\in [0,1]$, and the Kuhn–Tucker conditions $F \\le 0$, $\\dot{\\xi} \\ge 0$, $F \\dot{\\xi} = 0$.\n\n5. Under isothermal conditions in the sense of neglecting latent heat evolution, the Clausius–Duhem inequality implies that the mechanical dissipation rate is nonnegative. For the rate-independent transformation, the instantaneous dissipation rate can be consistently taken as\n$$\n\\mathcal{D}(t) = R\\!\\left(T(t)\\right)\\, \\dot{\\xi}(t),\n$$\nwhen the forward transformation is active, and $\\mathcal{D}(t) = 0$ when inactive. The integral of dissipation over a time interval $[0, t_{\\mathrm{end}}]$ is then\n$$\n\\int_{0}^{t_{\\mathrm{end}}} \\mathcal{D}(t)\\, dt = \\int_{0}^{t_{\\mathrm{end}}} R\\!\\left(T(t)\\right)\\, \\dot{\\xi}(t)\\, dt,\n$$\nwhich, under a bounded-variation discretization with time steps of size $\\Delta t$, is computed as the sum $\\sum_{n} R\\!\\left(T_{n+1}\\right) \\left(\\xi_{n+1}-\\xi_n\\right)$.\n\n6. Two incremental update strategies must be implemented for each time step from $t_n$ to $t_{n+1}$ under given inputs $\\epsilon_{n+1}$ and $T_{n+1}$:\n- Operator Splitting (OS): Use a sequential approximation in which the trial stress is computed from the previous internal variable, $ \\sigma^{\\mathrm{tr}} = E(\\xi_n)\\left(\\epsilon_{n+1} - \\epsilon_L \\xi_n\\right)$. Then evaluate $F^{\\mathrm{tr}} = \\sigma^{\\mathrm{tr}} \\epsilon_L - H \\xi_n - R(T_{n+1})$. If $F^{\\mathrm{tr}} \\le 0$, set $\\xi_{n+1} = \\xi_n$; otherwise, update $\\xi_{n+1}$ by enforcing $Y(\\sigma^{\\mathrm{tr}}, \\xi_{n+1}) = R(T_{n+1})$ with $\\sigma^{\\mathrm{tr}}$ held fixed, i.e., solve $\\sigma^{\\mathrm{tr}} \\epsilon_L - H \\xi_{n+1} = R(T_{n+1})$ for $\\xi_{n+1}$, and clamp to $[\\xi_n,1]$. Finally, compute $\\sigma_{n+1} = E(\\xi_{n+1})\\left(\\epsilon_{n+1} - \\epsilon_L \\xi_{n+1}\\right)$.\n- Monolithic Newton–Raphson (MN): Solve the coupled system at the end of the step. First, form the elastic predictor with no transformation, $\\sigma^{E} = E(\\xi_n)\\left(\\epsilon_{n+1} - \\epsilon_L \\xi_n\\right)$ and test $F^{E} = \\sigma^{E} \\epsilon_L - H \\xi_n - R(T_{n+1})$. If $F^{E} \\le 0$, set $\\xi_{n+1} = \\xi_n$ and $\\sigma_{n+1} = \\sigma^{E}$. If $F^{E}  0$, solve simultaneously for $(\\sigma_{n+1},\\xi_{n+1})$ enforcing the stress relation and the active consistency condition:\n$$\n\\begin{cases}\n\\sigma_{n+1} - E(\\xi_{n+1})\\left(\\epsilon_{n+1} - \\epsilon_L \\xi_{n+1}\\right) = 0 \\\\\n\\sigma_{n+1}\\epsilon_L - H \\xi_{n+1} - R(T_{n+1}) = 0\n\\end{cases}\n$$\nwith $\\xi_{n+1} \\in [\\xi_n,1]$, via Newton–Raphson on $\\xi_{n+1}$ using the second equation and the stress relation to eliminate $\\sigma_{n+1}$.\n\n7. The algorithmic error to be reported is the absolute difference between the total dissipation computed by OS and by MN over the full path,\n$$\n\\mathrm{error} = \\left| \\sum_{n} R\\!\\left(T_{n+1}\\right) \\left(\\xi_{n+1}^{\\mathrm{OS}} - \\xi_{n}^{\\mathrm{OS}}\\right) - \\sum_{n} R\\!\\left(T_{n+1}\\right) \\left(\\xi_{n+1}^{\\mathrm{MN}} - \\xi_{n}^{\\mathrm{MN}}\\right) \\right|.\n$$\n\nAll quantities must be expressed in consistent units as follows: stress and modulus in megapascals ($\\mathrm{MPa}$), temperature in kelvin ($\\mathrm{K}$), time in seconds ($\\mathrm{s}$), strain dimensionless, and the dissipation integral in $\\mathrm{MPa}$ (energy per unit volume assuming small strain with $\\mathrm{MPa}$ equivalent to $\\mathrm{MJ}/\\mathrm{m}^3$). The final program must print the algorithmic error for each test case as a comma-separated list of decimal numbers enclosed in square brackets, e.g., $[\\dots]$, with each number rounded to six decimal places, and in units of $\\mathrm{MPa}$.\n\nUse the following parameter values, which must be embedded in the program:\n- $E_A = 30000~\\mathrm{MPa}$,\n- $E_M = 20000~\\mathrm{MPa}$,\n- $\\epsilon_L = 0.05$,\n- $H = 200~\\mathrm{MPa}$,\n- $R_0 = 40~\\mathrm{MPa}$,\n- $b = 0.05~\\mathrm{MPa}/\\mathrm{K}$,\n- $T_0 = 300~\\mathrm{K}$.\n\nImplement a discrete-time simulation with uniform time step size $\\Delta t$ and $N$ steps. For numerical robustness, clamp $\\xi$ to the interval $[0,1]$ and enforce monotonicity $\\xi_{n+1} \\ge \\xi_n$.\n\nTest Suite. For each of the following three nonproportional thermomechanical paths, compute the algorithmic error as defined above. In all cases, take initial conditions $\\xi_0 = 0$ and $\\epsilon_0 = 0$, and the initial temperature equal to the value at $t=0$ for the specified path. Use a uniform time step size $\\Delta t$ and end time $t_{\\mathrm{end}}$.\n\n- Case A (general nonproportional ramp with oscillatory temperature):\n  - $\\Delta t = 0.5~\\mathrm{s}$, $t_{\\mathrm{end}} = 10~\\mathrm{s}$, $N = t_{\\mathrm{end}}/\\Delta t$,\n  - strain path: $\\epsilon(t) = 0.01 \\cdot \\left( t / t_{\\mathrm{end}} \\right)$,\n  - temperature path: $T(t) = 300 + 50 \\cdot \\sin\\!\\left( \\pi t / t_{\\mathrm{end}} \\right)$.\n\n- Case B (near-threshold ramp at high temperature):\n  - $\\Delta t = 0.5~\\mathrm{s}$, $t_{\\mathrm{end}} = 10~\\mathrm{s}$, $N = t_{\\mathrm{end}}/\\Delta t$,\n  - strain path: $\\epsilon(t) = 0.004 \\cdot \\left( t / t_{\\mathrm{end}} \\right)$,\n  - temperature path: $T(t) = 350$ (constant).\n\n- Case C (accelerating strain with cooling temperature):\n  - $\\Delta t = 0.5~\\mathrm{s}$, $t_{\\mathrm{end}} = 10~\\mathrm{s}$, $N = t_{\\mathrm{end}}/\\Delta t$,\n  - strain path: $\\epsilon(t) = 0.012 \\cdot \\left( t / t_{\\mathrm{end}} \\right)^2$,\n  - temperature path: $T(t) = 340 - 40 \\cdot \\left( t / t_{\\mathrm{end}} \\right)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order $[$Case A result, Case B result, Case C result$]$, e.g., $[\\alpha,\\beta,\\gamma]$, where each entry is a decimal number rounded to six decimal places representing the algorithmic error in $\\mathrm{MPa}$ for that case. No additional text should be printed.", "solution": "The problem requires a comparison of two numerical integration strategies for a one-dimensional, rate-independent, pseudoelastic Shape Memory Alloy (SMA) model. The comparison is to be quantified by the algorithmic error in the total computed dissipation over a specified thermomechanical path. The two strategies are an Operator Splitting (OS) scheme and a Monolithic Newton–Raphson (MN) scheme. The solution involves implementing both algorithms and applying them to three distinct nonproportional loading cases.\n\nFirst, we formalize the constitutive model. The state of the material at any time $t$ is described by the total strain $\\epsilon(t)$, the temperature $T(t)$, and a single internal variable, the martensite volume fraction $\\xi(t)$. The Cauchy stress $\\sigma(t)$ is a state function.\nThe material properties are given by the Young's moduli for the austenite ($E_A$) and martensite ($E_M$) phases, the transformation strain scale ($\\epsilon_L$), a hardening parameter ($H$), and parameters defining the transformation threshold ($R_0$, $b$, $T_0$).\n\nThe stress $\\sigma$ is related to the strain $\\epsilon$ and martensite fraction $\\xi$ via the constitutive law:\n$$\n\\sigma = E(\\xi)\\left(\\epsilon - \\epsilon_L \\xi \\right)\n$$\nwhere $E(\\xi)$ is the effective Young's modulus obtained through a rule of mixtures:\n$$\nE(\\xi) = E_A (1 - \\xi) + E_M \\xi = E_A + (E_M - E_A)\\xi\n$$\n\nPhase transformation from austenite to martensite is governed by a thermodynamic driving force $Y$ and a temperature-dependent threshold $R(T)$. The forward transformation ($\\dot{\\xi}  0$) is activated when the yield function $F$ is zero. The model is specified by:\n- Driving force: $Y(\\sigma, \\xi) = \\sigma \\epsilon_L - H \\xi$\n- Transformation threshold: $R(T) = R_0 + b (T-T_0)$\n- Yield function: $F(\\sigma, \\xi, T) = Y(\\sigma, \\xi) - R(T)$\nThe evolution of $\\xi$ is governed by the standard Kuhn–Tucker loading/unloading conditions for rate-independent plasticity:\n$$\n\\dot{\\xi} \\ge 0, \\quad F \\le 0, \\quad F \\dot{\\xi} = 0\n$$\nsubject to the physical constraints $\\xi \\in [0, 1]$. The condition $\\dot{\\xi} \\ge 0$ implies that only the forward transformation (austenite to martensite) is considered, and reverse transformation is ignored.\n\nThe problem is solved incrementally over a-priori known loading paths for $\\epsilon(t)$ and $T(t)$, discretized into $N$ time steps from $t_0=0$ to $t_{\\mathrm{end}} = N\\Delta t$. For each step from $t_n$ to $t_{n+1}$, we know the state $(\\sigma_n, \\xi_n)$ and are given the controls $(\\epsilon_{n+1}, T_{n+1})$. We must compute the updated state $(\\sigma_{n+1}, \\xi_{n+1})$.\n\nThe core of the problem lies in implementing the two distinct algorithms for this incremental update.\n\n1.  **Operator Splitting (OS) Algorithm:** This is a two-step predictor-corrector scheme.\n    -   **Elastic Predictor:** First, a trial state is computed by assuming the entire increment is elastic (i.e., $\\xi$ remains constant at its value from the previous step, $\\xi_n$). The trial stress $\\sigma^{\\mathrm{tr}}$ is:\n        $$\n        \\sigma^{\\mathrm{tr}} = E(\\xi_n) (\\epsilon_{n+1} - \\epsilon_L \\xi_n)\n        $$\n    -   **Transformation Check:** The yield function is evaluated at this trial state:\n        $$\n        F^{\\mathrm{tr}} = Y(\\sigma^{\\mathrm{tr}}, \\xi_n) - R(T_{n+1}) = \\sigma^{\\mathrm{tr}}\\epsilon_L - H\\xi_n - R(T_{n+1})\n        $$\n        If $F^{\\mathrm{tr}} \\le 0$, the assumption was correct, the step is elastic, and we set $\\xi_{n+1} = \\xi_n$ and $\\sigma_{n+1} = \\sigma^{\\mathrm{tr}}$.\n    -   **Plastic Corrector:** If $F^{\\mathrm{tr}}  0$, transformation occurs. The OS scheme, as specified, updates the internal variable $\\xi$ by enforcing the consistency condition $Y(\\sigma, \\xi) = R(T)$ using the fixed trial stress $\\sigma^{\\mathrm{tr}}$. This yields an explicit update rule for $\\xi_{n+1}$:\n        $$\n        \\sigma^{\\mathrm{tr}}\\epsilon_L - H\\xi_{n+1} = R(T_{n+1}) \\implies \\xi_{n+1} = \\frac{\\sigma^{\\mathrm{tr}}\\epsilon_L - R(T_{n+1})}{H}\n        $$\n        The result is then clamped to satisfy the constraints: $\\xi_{n+1} \\in [\\xi_n, 1]$. Finally, the stress $\\sigma_{n+1}$ is re-computed using the updated $\\xi_{n+1}$ and the full constitutive law, ensuring it is consistent with the final state variables.\n\n2.  **Monolithic Newton–Raphson (MN) Algorithm:** This scheme solves the full system of equations simultaneously, ensuring that the state at the end of the step satisfies all governing equations.\n    -   **Elastic Predictor:** The trial step is identical to the OS case. If the trial yield function $F^{\\mathrm{tr}} \\le 0$, the step is elastic.\n    -   **Inelastic Corrector:** If $F^{\\mathrm{tr}}  0$, transformation occurs, and the state $(\\sigma_{n+1}, \\xi_{n+1})$ must satisfy both the stress-strain relation and the consistency condition at time $t_{n+1}$:\n        $$\n        \\begin{cases}\n        \\sigma_{n+1} - E(\\xi_{n+1})(\\epsilon_{n+1} - \\epsilon_L \\xi_{n+1}) = 0 \\\\\n        \\sigma_{n+1}\\epsilon_L - H \\xi_{n+1} - R(T_{n+1}) = 0\n        \\end{cases}\n        $$\n        Substituting the first equation into the second eliminates $\\sigma_{n+1}$ and results in a single nonlinear scalar residual equation, $g(\\xi_{n+1}) = 0$, for the unknown $\\xi_{n+1}$:\n        $$\n        g(\\xi) = \\left[ E(\\xi)(\\epsilon_{n+1} - \\epsilon_L \\xi) \\right] \\epsilon_L - H \\xi - R(T_{n+1}) = 0\n        $$\n        This equation is solved numerically using the Newton–Raphson method. The iterative update is $\\xi^{(k+1)} = \\xi^{(k)} - g(\\xi^{(k)})/g'(\\xi^{(k)})$, starting with an initial guess $\\xi^{(0)} = \\xi_n$. The derivative $g'(\\xi) = dg/d\\xi$ is:\n        $$\n        g'(\\xi) = \\left[ E'(\\xi)(\\epsilon_{n+1} - \\epsilon_L \\xi) - E(\\xi)\\epsilon_L \\right]\\epsilon_L - H\n        $$\n        where $E'(\\xi) = E_M-E_A$. The iteration continues until the residual $|g(\\xi^{(k)})|$ is below a prescribed tolerance. The resulting root is then clamped to the interval $[\\xi_n, 1]$.\n\nThe total dissipation over the path is calculated by summing the incremental dissipation at each step:\n$$\n\\text{Dissipation} = \\sum_{n=0}^{N-1} R(T_{n+1}) (\\xi_{n+1} - \\xi_n)\n$$\nThis is computed for both the OS and MN solutions, denoted $D^{\\mathrm{OS}}$ and $D^{\\mathrm{MN}}$. The algorithmic error is the absolute difference between these two totals:\n$$\n\\mathrm{error} = | D^{\\mathrm{OS}} - D^{\\mathrm{MN}} |\n$$\n\nThe implementation will consist of a main loop that iterates over the specified test cases. For each case, a simulation driver function will march through time, applying the prescribed strain and temperature at each step. Within this loop, both the OS and MN update routines are called to evolve the state according to each scheme. The respective dissipation increments are calculated and accumulated. Finally, the absolute difference of the total accumulated dissipations is computed and stored. The results for all three cases are collected and printed in the specified format.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the SMA modeling problem for all test cases.\n    \"\"\"\n    # Material and model parameters\n    params = {\n        'E_A': 30000.0,   # MPa\n        'E_M': 20000.0,   # MPa\n        'eps_L': 0.05,    # dimensionless\n        'H': 200.0,       # MPa\n        'R_0': 40.0,      # MPa\n        'b': 0.05,        # MPa/K\n        'T_0': 300.0,     # K\n    }\n\n    t_end = 10.0\n    dt = 0.5\n    N_steps = int(t_end / dt)\n    time_points = np.linspace(0, t_end, N_steps + 1)\n\n    # Test Case Definitions\n    test_cases = [\n        {\n            'name': 'A',\n            't_end': t_end,\n            'dt': dt,\n            'time_points': time_points,\n            'eps_path': lambda t: 0.01 * (t / t_end),\n            'T_path': lambda t: 300.0 + 50.0 * np.sin(np.pi * t / t_end)\n        },\n        {\n            'name': 'B',\n            't_end': t_end,\n            'dt': dt,\n            'time_points': time_points,\n            'eps_path': lambda t: 0.004 * (t / t_end),\n            'T_path': lambda t: 350.0\n        },\n        {\n            'name': 'C',\n            't_end': t_end,\n            'dt': dt,\n            'time_points': time_points,\n            'eps_path': lambda t: 0.012 * (t / t_end)**2,\n            'T_path': lambda t: 340.0 - 40.0 * (t / t_end)\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        error = run_simulation(case, params)\n        results.append(error)\n    \n    # Format and print the final output\n    print(f\"[{','.join(['{:.6f}'.format(r) for r in results])}]\")\n\ndef E_mod(xi, params):\n    \"\"\"Calculates Young's modulus E(xi).\"\"\"\n    return params['E_A'] * (1 - xi) + params['E_M'] * xi\n\ndef R_thresh(T, params):\n    \"\"\"Calculates transformation threshold R(T).\"\"\"\n    return params['R_0'] + params['b'] * (T - params['T_0'])\n\ndef os_update(xi_n, eps_np1, T_np1, params):\n    \"\"\"Performs one update step using Operator Splitting (OS).\"\"\"\n    # Elastic predictor step\n    E_n = E_mod(xi_n, params)\n    sigma_tr = E_n * (eps_np1 - params['eps_L'] * xi_n)\n    \n    # Check for transformation\n    R_np1 = R_thresh(T_np1, params)\n    F_tr = sigma_tr * params['eps_L'] - params['H'] * xi_n - R_np1\n\n    if F_tr = 0:\n        # Elastic step\n        return xi_n\n    else:\n        # Plastic corrector step\n        xi_cand = (sigma_tr * params['eps_L'] - R_np1) / params['H']\n        # Enforce constraints\n        xi_np1 = max(xi_n, min(1.0, xi_cand))\n        return xi_np1\n\ndef mn_update(xi_n, eps_np1, T_np1, params):\n    \"\"\"Performs one update step using Monolithic Newton-Raphson (MN).\"\"\"\n    # Elastic predictor step\n    E_n = E_mod(xi_n, params)\n    sigma_E = E_n * (eps_np1 - params['eps_L'] * xi_n)\n    \n    # Check for transformation\n    R_np1 = R_thresh(T_np1, params)\n    F_E = sigma_E * params['eps_L'] - params['H'] * xi_n - R_np1\n\n    if F_E = 0:\n        # Elastic step\n        return xi_n\n    else:\n        # Inelastic step: solve g(xi) = 0 via Newton-Raphson\n        \n        # Define residual and its derivative\n        dE = params['E_M'] - params['E_A']\n        \n        def g(xi):\n            E_xi = params['E_A'] + dE * xi\n            sigma_xi = E_xi * (eps_np1 - params['eps_L'] * xi)\n            return sigma_xi * params['eps_L'] - params['H'] * xi - R_np1\n\n        def g_prime(xi):\n            E_xi = params['E_A'] + dE * xi\n            # d(sigma)/d(xi) = E'(xi)*(eps-eps_L*xi) - E(xi)*eps_L\n            d_sigma_d_xi = dE * (eps_np1 - params['eps_L'] * xi) - E_xi * params['eps_L']\n            return d_sigma_d_xi * params['eps_L'] - params['H']\n\n        # Newton-Raphson iteration\n        xi_k = xi_n  # Initial guess\n        max_iter = 20\n        tolerance = 1e-9\n        \n        for _ in range(max_iter):\n            res = g(xi_k)\n            if abs(res)  tolerance:\n                break\n            grad = g_prime(xi_k)\n            if abs(grad)  1e-9: # Avoid division by zero\n                break\n            xi_k -= res / grad\n\n        # Enforce constraints\n        xi_np1 = max(xi_n, min(1.0, xi_k))\n        return xi_np1\n\ndef run_simulation(case, params):\n    \"\"\"\n    Runs a full simulation for a given test case and returns the algorithmic error.\n    \"\"\"\n    time = case['time_points']\n    N_steps = len(time) - 1\n\n    # Initial conditions\n    xi_0 = 0.0\n    \n    xi_os = np.zeros(N_steps + 1)\n    xi_mn = np.zeros(N_steps + 1)\n    xi_os[0] = xi_mn[0] = xi_0\n    \n    dissipation_os = 0.0\n    dissipation_mn = 0.0\n    \n    for n in range(N_steps):\n        t_np1 = time[n+1]\n        eps_np1 = case['eps_path'](t_np1)\n        T_np1 = case['T_path'](t_np1)\n        \n        # Operator Splitting update\n        xi_np1_os = os_update(xi_os[n], eps_np1, T_np1, params)\n        xi_os[n+1] = xi_np1_os\n        \n        # Monolithic Newton-Raphson update\n        xi_np1_mn = mn_update(xi_mn[n], eps_np1, T_np1, params)\n        xi_mn[n+1] = xi_np1_mn\n        \n        # Calculate incremental dissipation\n        R_np1 = R_thresh(T_np1, params)\n        dissipation_os += R_np1 * (xi_os[n+1] - xi_os[n])\n        dissipation_mn += R_np1 * (xi_mn[n+1] - xi_mn[n])\n        \n    # Calculate final algorithmic error\n    error = abs(dissipation_os - dissipation_mn)\n    return error\n\nif __name__ == \"__main__\":\n    solve()\n\n```", "id": "3600557"}]}