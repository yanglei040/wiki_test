{"hands_on_practices": [{"introduction": "Building a reduced-order model for a nonlinear system requires careful consideration of the projection technique. This first exercise guides you through the full process for a hyperelastic bar, from finite element discretization and snapshot generation to the construction of two distinct reduced-order models. By comparing a standard Galerkin projection with a Least-Squares Petrov-Galerkin (LSPG) projection, you will gain hands-on insight into how the choice of projection impacts the stability and physical consistency—specifically, the energy preservation—of the resulting model [@problem_id:3591637].", "problem": "You are asked to implement a complete, runnable program that constructs a projection-based reduced-order model for a nonlinear hyperelastic one-dimensional solid undergoing large deformations and compares standard Galerkin projection versus Least-Squares Petrov-Galerkin projection in terms of their ability to preserve the mechanical energy $E(u)$ across incremental load steps. The system, reduction approach, and comparison must be derived and implemented from first principles of computational solid mechanics and numerical approximation.\n\nThe physical model is a one-dimensional bar of length $L$ and constant cross-sectional area $A$, with the left end fixed and a prescribed axial force $P$ applied at the right end. The bar undergoes finite strain, and its constitutive behavior is hyperelastic. The equilibrium problem is quasi-static. You must work in the reference (material) configuration with coordinate $X \\in [0,L]$ and displacement field $u(X)$ mapping the material point to its current position $x(X) = X + u(X)$. The deformation gradient is $F(X) = \\dfrac{dx}{dX} = 1 + \\dfrac{du}{dX}$. The mechanical energy of interest is the total potential energy functional\n$$\nE(u) = \\int_0^L A\\, W(F(X))\\, dX - P\\, u(L),\n$$\nwhere $W(F)$ is the strain energy density per unit volume. Use the Green-Lagrange strain $E_{\\mathrm{GL}}(F) = \\dfrac{1}{2}(F^2 - 1)$ and define the strain energy density as\n$$\nW(F) = \\dfrac{1}{2}\\,E\\,E_{\\mathrm{GL}}(F)^2,\n$$\nwith $E$ the (effective) elastic modulus in pascals. The first Piola-Kirchhoff stress is $P_1(F) = \\dfrac{dW}{dF}$, and the consistent tangent is $H(F) = \\dfrac{dP_1}{dF}$. All quantities must be treated in the reference configuration. The units must be consistent with the International System of Units: length in meters (m), area in square meters (m$^2$), elastic modulus in pascals (Pa), force in newtons (N), and energy in joules (J). The energy $E(u)$ must be computed and reported in joules.\n\nDiscretize the bar with $N$ uniform two-node linear finite elements in the reference configuration. Enforce the left-end Dirichlet boundary condition $u(0)=0$ strongly by eliminating the corresponding degree of freedom. Use nodal unknowns $u_i$ at the mesh nodes. Derive the discrete residual vector and consistent tangent matrix from the stationary condition of the total potential energy. The discrete nonlinear system must be solved at each load step using Newton-Raphson with a consistent tangent and a simple backtracking line search if needed for robustness.\n\nConstruct a Proper Orthogonal Decomposition (POD) basis using the method of snapshots obtained from the full-order model (FOM) solutions across all load steps. Use the $L^2$ inner product weighted by the consistent mass matrix of the displacement field (i.e., the inner product $(v,w)_M = v^T M w$ with $M$ the consistent finite element mass matrix associated with the displacement shape functions and cross-sectional area $A$). Obtain a reduced basis of dimension $r$ that is $M$-orthonormal.\n\nForm two reduced-order models (ROMs) for the nonlinear equilibrium:\n- Standard Galerkin projection: Solve the reduced nonlinear system obtained by projecting the FOM residual onto the reduced space via the test space equal to the trial space and the $M$-orthonormal basis.\n- Least-Squares Petrov-Galerkin (LSPG) projection: Solve the reduced nonlinear system obtained by minimizing the $M$-weighted residual norm in the reduced coordinates, which leads to normal equations involving the Jacobian of the residual.\n\nFor both ROMs, perform the same sequence of load steps and compute the total potential energy $E(u)$ at each step using the ROM solution. Compare how well each ROM preserves the FOM mechanical energy across the load steps by computing the root-mean-square (RMS) relative energy deviation defined as\n$$\n\\varepsilon_{\\mathrm{RMS}} = \\dfrac{\\sqrt{\\dfrac{1}{K} \\sum_{k=1}^K \\left(E_{\\mathrm{ROM}}^{(k)} - E_{\\mathrm{FOM}}^{(k)}\\right)^2}}{\\dfrac{1}{K} \\sum_{k=1}^K \\left|E_{\\mathrm{FOM}}^{(k)}\\right|},\n$$\nwhere $K$ is the number of load steps, $E_{\\mathrm{FOM}}^{(k)}$ is the full-order energy at step $k$, and $E_{\\mathrm{ROM}}^{(k)}$ is the reduced energy for the method in question at step $k$. Report the RMS relative energy deviation for both standard Galerkin and Least-Squares Petrov-Galerkin.\n\nYour program must implement the following test suite of parameter sets, covering a typical case, a reduced basis size boundary case, a stronger nonlinearity case, and a coarser discretization case:\n\n- Case 1 (typical): $L = 1.0\\,\\mathrm{m}$, $A = 1.0\\times10^{-2}\\,\\mathrm{m}^2$, $E = 1.0\\times10^{6}\\,\\mathrm{Pa}$, $N = 30$, $K = 25$ load steps with forces linearly ramped from $0$ to $P_{\\max} = 1000\\,\\mathrm{N}$, reduced dimension $r=6$.\n- Case 2 (reduced basis boundary): Same as Case 1 but $r=1$.\n- Case 3 (stronger nonlinearity): Same as Case 1 but $P_{\\max} = 5000\\,\\mathrm{N}$, $r=6$.\n- Case 4 (coarser mesh): Same as Case 1 but $N = 8$, $r=6$.\n\nFor each case, compute and record two floating-point results: the RMS relative energy deviation for the standard Galerkin ROM and for the Least-Squares Petrov-Galerkin ROM. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order\n$$\n[\\varepsilon_{\\mathrm{G}}^{(1)}, \\varepsilon_{\\mathrm{LSPG}}^{(1)}, \\varepsilon_{\\mathrm{G}}^{(2)}, \\varepsilon_{\\mathrm{LSPG}}^{(2)}, \\varepsilon_{\\mathrm{G}}^{(3)}, \\varepsilon_{\\mathrm{LSPG}}^{(3)}, \\varepsilon_{\\mathrm{G}}^{(4)}, \\varepsilon_{\\mathrm{LSPG}}^{(4)}],\n$$\nwhere superscripts refer to the case number. Express all eight outputs as decimal floating-point numbers (dimensionless), and ensure they are computed from energies measured in joules.\n\nYou must provide a complete, runnable program with no user input or external files, as specified in the final answer section. The program must numerically approximate the continuous model and produce the required output. All mathematical entities in this problem statement must be written in LaTeX using $...$ or $$...$$ delimiters, and acronyms must be defined upon first usage (e.g., Proper Orthogonal Decomposition (POD), Least-Squares Petrov-Galerkin (LSPG)).", "solution": "We begin with the fundamental balance laws and definitions for a quasi-static hyperelastic solid. In the reference (material) configuration, static equilibrium can be stated in weak form by stationarity of the total potential energy. For a one-dimensional bar with displacement field $u(X)$, the deformation gradient is $F(X) = \\dfrac{dx}{dX} = 1 + \\dfrac{du}{dX}$. For a hyperelastic material, the strain energy density per unit volume is a function of $F$, denoted $W(F)$, and the first Piola-Kirchhoff stress is $P_1(F) = \\dfrac{dW}{dF}$. The total potential energy is\n$$\nE(u) = \\int_0^L A\\, W(F)\\, dX - P\\, u(L),\n$$\nwith $A$ the cross-sectional area and $P$ the applied axial force at the right end. The equilibrium configuration minimizes $E(u)$, and the necessary condition is that its first variation vanishes.\n\nWe adopt the Green-Lagrange strain $E_{\\mathrm{GL}}(F) = \\dfrac{1}{2}(F^2 - 1)$ and take the strain energy density\n$$\nW(F) = \\dfrac{1}{2}\\, E \\, E_{\\mathrm{GL}}(F)^2,\n$$\nwhere $E$ is an elastic modulus. This choice yields a nonlinear, but smooth, hyperelastic model capable of representing large deformations in one dimension. The associated first Piola-Kirchhoff stress is\n$$\nP_1(F) = \\dfrac{dW}{dF} \n= \\dfrac{d}{dF} \\left( \\dfrac{1}{2} E \\left(\\dfrac{1}{2}(F^2 - 1)\\right)^2 \\right)\n= \\dfrac{1}{2} E \\left( F^3 - F \\right),\n$$\nand the consistent tangent modulus is\n$$\nH(F) = \\dfrac{dP_1}{dF} = \\dfrac{1}{2} E \\left( 3 F^2 - 1 \\right).\n$$\n\nFor the finite element discretization, partition $[0,L]$ into $N$ uniform elements of size $h = \\dfrac{L}{N}$, with nodes $X_i = i h$, $i=0,\\dots,N$. Use linear shape functions on each element and nodal degrees of freedom $u_i$. Impose $u_0 = 0$ strongly, leaving $N$ free unknowns $u_1,\\dots,u_N$. On an element connecting nodes $i$ and $i+1$, the displacement is linear, so the gradient $\\dfrac{du}{dX}$ is constant: $\\dfrac{du}{dX} = \\dfrac{u_{i+1} - u_i}{h}$, and thus $F = 1 + \\dfrac{u_{i+1} - u_i}{h}$. The element contribution to the internal force vector for the two nodes follows from the first variation of $\\int A W(F)\\,dX$ and is\n$$\n\\mathbf{f}_{\\mathrm{int}}^{(e)} = A\\, P_1(F)\\, \\begin{bmatrix} -1 \\\\ 1 \\end{bmatrix},\n$$\nsince the sensitivity of $F$ to nodal displacements is $[\\partial F/\\partial u_i, \\partial F/\\partial u_{i+1}] = [-1/h, 1/h]$ and the element length is $h$. The consistent element tangent matrix is\n$$\n\\mathbf{K}^{(e)} = \\dfrac{A\\, H(F)}{h}\\, \\begin{bmatrix} 1 & -1 \\\\ -1 & 1 \\end{bmatrix}.\n$$\nAssemble these contributions to obtain the global internal force vector $\\mathbf{f}_{\\mathrm{int}}(\\mathbf{u})$ and global tangent matrix $\\mathbf{K}(\\mathbf{u})$. The external force vector is zero everywhere except at the right-end node $N$, where it is $P$. After enforcing $u_0=0$, extract the free-part residual\n$$\n\\mathbf{r}(\\mathbf{u}_f) = \\mathbf{f}_{\\mathrm{int},f}(\\mathbf{u}_f) - \\mathbf{f}_{\\mathrm{ext},f},\n$$\nand the free-part tangent $\\mathbf{K}_f(\\mathbf{u}_f)$, where $\\mathbf{u}_f = [u_1,\\dots,u_N]^T$ and the only nonzero component of $\\mathbf{f}_{\\mathrm{ext},f}$ is the last entry equal to $P$. Solve $\\mathbf{r}(\\mathbf{u}_f)=\\mathbf{0}$ at each load step with Newton-Raphson:\n$$\n\\mathbf{K}_f(\\mathbf{u}_f^{(m)})\\, \\Delta \\mathbf{u}_f^{(m)} = - \\mathbf{r}(\\mathbf{u}_f^{(m)}), \\quad \\mathbf{u}_f^{(m+1)} = \\mathbf{u}_f^{(m)} + \\alpha^{(m)} \\Delta \\mathbf{u}_f^{(m)},\n$$\nwhere $\\alpha^{(m)} \\in (0,1]$ is adjusted (backtracking) if needed to reduce the residual norm. The energy at a given load $P$ is computed as\n$$\nE(\\mathbf{u}_f) = \\sum_{e=1}^{N} A\\, h\\, W(F_e) - P\\, u_N,\n$$\nwith $F_e$ the deformation gradient on element $e$ and $u_N$ the displacement at the right end.\n\nFor Proper Orthogonal Decomposition (POD), collect the full-order displacement snapshots into a matrix $\\mathbf{S} \\in \\mathbb{R}^{n_f \\times K}$, where $n_f=N$ is the number of free degrees of freedom and $K$ the number of load steps. Define the consistent mass matrix $\\mathbf{M}$ for the displacement space (with unit density, since only a spatial weighting is required here) by assembling the element matrices\n$$\n\\mathbf{M}^{(e)} = A \\int_{X_i}^{X_{i+1}} \\begin{bmatrix} N_1 \\\\ N_2 \\end{bmatrix} \\begin{bmatrix} N_1 & N_2 \\end{bmatrix}\\, dX \n= A \\begin{bmatrix} \\dfrac{h}{3} & \\dfrac{h}{6} \\\\ \\dfrac{h}{6} & \\dfrac{h}{3} \\end{bmatrix}.\n$$\nExtract the free-part $\\mathbf{M}_f \\in \\mathbb{R}^{n_f \\times n_f}$. Compute the POD basis by solving the generalized eigenvalue problem for the snapshot covariance\n$$\n\\mathbf{C} = \\mathbf{S}^T \\mathbf{M}_f \\mathbf{S}, \\quad \\mathbf{C}\\,\\mathbf{w}_i = \\lambda_i\\, \\mathbf{w}_i,\n$$\nsorting eigenpairs by descending $\\lambda_i>0$, and forming $M$-orthonormal basis vectors\n$$\n\\mathbf{v}_i = \\dfrac{1}{\\sqrt{\\lambda_i}} \\mathbf{S}\\, \\mathbf{w}_i,\n$$\nwhich satisfy $\\mathbf{v}_i^T \\mathbf{M}_f \\mathbf{v}_j = \\delta_{ij}$. Stack the first $r$ basis vectors into $\\mathbf{V} \\in \\mathbb{R}^{n_f \\times r}$.\n\nFor the standard Galerkin reduced model, seek reduced coordinates $\\mathbf{a} \\in \\mathbb{R}^r$ such that the full displacement is approximated as $\\mathbf{u}_f \\approx \\mathbf{V}\\, \\mathbf{a}$ and the residual is orthogonal to the reduced space, yielding\n$$\n\\mathbf{V}^T\\, \\mathbf{r}(\\mathbf{V}\\mathbf{a}) = \\mathbf{0}.\n$$\nImplement Newton in reduced coordinates. The chain rule gives the reduced tangent \n$$\n\\mathbf{K}_r(\\mathbf{a}) = \\mathbf{V}^T\\, \\mathbf{K}_f(\\mathbf{V}\\mathbf{a})\\, \\mathbf{V},\n$$\nand the reduced Newton update is obtained by solving\n$$\n\\mathbf{K}_r(\\mathbf{a}^{(m)})\\, \\Delta \\mathbf{a}^{(m)} = - \\mathbf{V}^T\\, \\mathbf{r}(\\mathbf{V}\\mathbf{a}^{(m)}), \\quad \\mathbf{a}^{(m+1)} = \\mathbf{a}^{(m)} + \\alpha^{(m)} \\Delta \\mathbf{a}^{(m)}.\n$$\n\nFor the Least-Squares Petrov-Galerkin (LSPG) reduced model, minimize the $M$-weighted residual norm $\\|\\mathbf{r}(\\mathbf{V}\\mathbf{a})\\|_{\\mathbf{M}_f} = \\sqrt{\\mathbf{r}^T \\mathbf{M}_f \\mathbf{r}}$. The Gauss-Newton condition gives the normal equations\n$$\n\\left[ (\\mathbf{J}_r(\\mathbf{a}))^T \\mathbf{M}_f\\, \\mathbf{J}_r(\\mathbf{a}) \\right] \\Delta \\mathbf{a}\n= - (\\mathbf{J}_r(\\mathbf{a}))^T \\mathbf{M}_f\\, \\mathbf{r}(\\mathbf{V}\\mathbf{a}),\n$$\nwhere $\\mathbf{J}_r(\\mathbf{a}) = \\dfrac{\\partial \\mathbf{r}}{\\partial \\mathbf{u}_f}(\\mathbf{V}\\mathbf{a})\\, \\mathbf{V} = \\mathbf{K}_f(\\mathbf{V}\\mathbf{a})\\, \\mathbf{V}$. Update $\\mathbf{a}$ with backtracking if necessary to reduce the weighted residual norm.\n\nFor both ROMs, at each load step compute the reduced displacement $\\mathbf{u}_f^{\\mathrm{ROM}}$ and the corresponding energy $E_{\\mathrm{ROM}}$. Compare the reduced energies against the full-order energies $E_{\\mathrm{FOM}}$ by calculating the root-mean-square relative energy deviation across the $K$ steps:\n$$\n\\varepsilon_{\\mathrm{RMS}} = \\dfrac{\\sqrt{\\dfrac{1}{K} \\sum_{k=1}^K \\left(E_{\\mathrm{ROM}}^{(k)} - E_{\\mathrm{FOM}}^{(k)}\\right)^2}}{\\dfrac{1}{K} \\sum_{k=1}^K \\left|E_{\\mathrm{FOM}}^{(k)}\\right|}.\n$$\n\nAlgorithmic design for the program:\n- Define the mesh and assembly routines for internal force and tangent, using $P_1(F) = \\dfrac{1}{2}E(F^3 - F)$ and $H(F) = \\dfrac{1}{2}E(3F^2 - 1)$ on each element with $F = 1 + \\dfrac{u_{i+1}-u_i}{h}$.\n- Implement the full-order Newton solver over $K$ load steps ramping $P$ from $0$ to $P_{\\max}$, with initial guess $\\mathbf{u}_f=\\mathbf{0}$ and warm-starting from the previous step. Include a small diagonal regularization and simple backtracking on the update to improve robustness.\n- Assemble the consistent mass matrix $\\mathbf{M}_f$ for the displacement space using the prescribed element formula, and compute the mass-weighted POD basis $\\mathbf{V}$ of dimension $r$ from the full-order snapshots.\n- Implement the Galerkin ROM Newton solver and the LSPG ROM Gauss-Newton solver across the same load steps, initializing the reduced coordinates by mass-weighted projection $\\mathbf{a}_0 = \\mathbf{V}^T \\mathbf{M}_f \\mathbf{u}_f^{\\text{prev}}$.\n- Compute energies in joules at each step for FOM and each ROM. Compute the RMS relative energy deviations for both ROMs per case.\n- Execute the four cases specified in the problem statement and output the eight resulting floating-point values as a single comma-separated list enclosed in square brackets.\n\nAll computations are performed in SI units: $L$ in meters, $A$ in square meters, $E$ in pascals, forces in newtons, and energies $E(u)$ in joules. The final printed outputs are dimensionless decimals that quantify the energy preservation performance of the reduced models relative to the full model across the load steps.\n\nThis approach integrates the core principles of hyperelasticity, variational formulation of equilibrium, finite element discretization, Proper Orthogonal Decomposition (POD), standard Galerkin projection, and Least-Squares Petrov-Galerkin (LSPG), to produce a scientifically sound and algorithmically clear comparison focused on preservation of mechanical energy $E(u)$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef assemble_internal_and_tangent(u_free, L, A, E_mod, N, P_ext):\n    \"\"\"\n    Assemble internal force vector and tangent stiffness for the free dofs.\n    u_free: array of length N (nodes 1..N), with u0 = 0 fixed.\n    Returns residual r (size N), tangent K_ff (NxN), and energy computation utility can be separate.\n    \"\"\"\n    h = L / N\n    n_nodes = N + 1\n    # Full displacement including fixed left node\n    u_full = np.zeros(n_nodes)\n    u_full[1:] = u_free\n\n    f_full = np.zeros(n_nodes)\n    K_full = np.zeros((n_nodes, n_nodes))\n\n    # Loop over elements\n    for e in range(N):\n        i = e\n        j = e + 1\n        ui = u_full[i]\n        uj = u_full[j]\n        du_dx = (uj - ui) / h\n        F = 1.0 + du_dx\n        # First Piola stress and tangent for the chosen hyperelastic model\n        Pstress = 0.5 * E_mod * (F**3 - F)\n        Htan = 0.5 * E_mod * (3.0 * F**2 - 1.0)\n        # Element internal force contribution\n        f_e = A * Pstress * np.array([-1.0, 1.0])\n        f_full[i] += f_e[0]\n        f_full[j] += f_e[1]\n        # Element tangent contribution\n        Ke = (A * Htan / h) * np.array([[1.0, -1.0], [-1.0, 1.0]])\n        K_full[i:i+2, i:i+2] += Ke\n\n    # Extract free part\n    r = f_full[1:].copy()\n    # External force applied at the right end node N (index N in full, index N-1 in free)\n    r[-1] -= P_ext\n    K_ff = K_full[1:, 1:]\n    return r, K_ff\n\ndef compute_energy(u_free, L, A, E_mod, N, P_ext):\n    \"\"\"\n    Compute total potential energy E(u) = sum_e A*h*W(F_e) - P_ext * u(L).\n    \"\"\"\n    h = L / N\n    n_nodes = N + 1\n    u_full = np.zeros(n_nodes)\n    u_full[1:] = u_free\n    U_int = 0.0\n    for e in range(N):\n        i = e\n        j = e + 1\n        ui = u_full[i]\n        uj = u_full[j]\n        du_dx = (uj - ui) / h\n        F = 1.0 + du_dx\n        EGL = 0.5 * (F**2 - 1.0)\n        W = 0.5 * E_mod * (EGL**2)\n        U_int += A * h * W\n    U_ext = P_ext * u_full[-1]\n    E_total = U_int - U_ext\n    return E_total\n\ndef newton_fom(L, A, E_mod, N, P_values, tol=1e-10, max_iter=60):\n    \"\"\"\n    Full-order model Newton solve across load steps.\n    Returns snapshots matrix S (N x K), energies list E_fom (length K).\n    \"\"\"\n    n_free = N\n    K_steps = len(P_values)\n    S = np.zeros((n_free, K_steps))\n    E_fom = []\n    u_free = np.zeros(n_free)\n    # Solve for each load step\n    for k, Pk in enumerate(P_values):\n        # Warm start from previous step\n        # Newton iterations\n        for it in range(max_iter):\n            r, K = assemble_internal_and_tangent(u_free, L, A, E_mod, N, Pk)\n            rn = np.linalg.norm(r)\n            if rn  tol:\n                break\n            # Regularization\n            reg = 1e-12\n            K_reg = K + reg * np.eye(n_free)\n            try:\n                du = np.linalg.solve(K_reg, -r)\n            except np.linalg.LinAlgError:\n                # Fallback: add stronger regularization\n                K_reg = K + 1e-8 * np.eye(n_free)\n                du = np.linalg.solve(K_reg, -r)\n            # Backtracking line search on residual norm\n            alpha = 1.0\n            u_trial = u_free + alpha * du\n            r_trial, _ = assemble_internal_and_tangent(u_trial, L, A, E_mod, N, Pk)\n            rn_trial = np.linalg.norm(r_trial)\n            bt_count = 0\n            while rn_trial > rn and bt_count  10:\n                alpha *= 0.5\n                u_trial = u_free + alpha * du\n                r_trial, _ = assemble_internal_and_tangent(u_trial, L, A, E_mod, N, Pk)\n                rn_trial = np.linalg.norm(r_trial)\n                bt_count += 1\n            u_free = u_trial\n        # Save snapshot and energy\n        S[:, k] = u_free\n        E_fom.append(compute_energy(u_free, L, A, E_mod, N, Pk))\n    return S, np.array(E_fom)\n\ndef assemble_mass_matrix(L, A, N):\n    \"\"\"\n    Assemble consistent mass matrix M for displacement space (unit density weighting).\n    Returns free-part M_ff of size N x N.\n    \"\"\"\n    h = L / N\n    n_nodes = N + 1\n    M_full = np.zeros((n_nodes, n_nodes))\n    Me = A * np.array([[h/3.0, h/6.0],\n                       [h/6.0, h/3.0]])\n    for e in range(N):\n        i = e\n        j = e + 1\n        M_full[i:i+2, i:i+2] += Me\n    M_ff = M_full[1:, 1:]\n    return M_ff\n\ndef pod_mass_weighted(S, M_ff, r_dim, eig_tol=1e-14):\n    \"\"\"\n    Compute mass-weighted POD basis V (n_free x r_dim) with V^T M_ff V = I.\n    \"\"\"\n    # Covariance\n    C = S.T @ M_ff @ S\n    # Symmetric eigen-decomposition\n    evals, evecs = np.linalg.eigh(C)\n    # Sort descending\n    idx = np.argsort(evals)[::-1]\n    evals = evals[idx]\n    evecs = evecs[:, idx]\n    # Filter positive eigenvalues\n    pos = evals > eig_tol\n    evals = evals[pos]\n    evecs = evecs[:, pos]\n    r_eff = min(r_dim, evecs.shape[1])\n    if r_eff == 0:\n        # No variance; return zeros basis (should not happen with nontrivial snapshots)\n        return np.zeros((S.shape[0], 0))\n    evecs_r = evecs[:, :r_eff]\n    evals_r = evals[:r_eff]\n    # Build basis vectors: v_i = 1/sqrt(lambda_i) * S w_i\n    V = S @ (evecs_r / np.sqrt(evals_r))\n    return V\n\ndef project_initial(V, M_ff, u_free):\n    \"\"\"\n    Mass-weighted projection of full displacement onto reduced coordinates: a0 = V^T M u.\n    Assumes V^T M V = I.\n    \"\"\"\n    return V.T @ (M_ff @ u_free)\n\ndef rom_galerkin(L, A, E_mod, N, P_values, V, M_ff, tol=1e-10, max_iter=60):\n    \"\"\"\n    Standard Galerkin ROM solve across load steps.\n    Returns reduced energies list E_rom (length K).\n    \"\"\"\n    K_steps = len(P_values)\n    n_free = N\n    r = V.shape[1]\n    a = np.zeros(r)\n    E_rom = []\n    u_free_prev = np.zeros(n_free)\n    for k, Pk in enumerate(P_values):\n        # Warm start from projection of previous FOM/ROM solution\n        a = project_initial(V, M_ff, u_free_prev)\n        # Newton in reduced coordinates\n        for it in range(max_iter):\n            u = V @ a\n            r_full, K_full = assemble_internal_and_tangent(u, L, A, E_mod, N, Pk)\n            r_red = V.T @ r_full\n            rn = np.linalg.norm(r_red)\n            if rn  tol:\n                break\n            K_red = V.T @ (K_full @ V)\n            # Regularization\n            reg = 1e-12\n            K_red_reg = K_red + reg * np.eye(r)\n            try:\n                da = np.linalg.solve(K_red_reg, -r_red)\n            except np.linalg.LinAlgError:\n                K_red_reg = K_red + 1e-8 * np.eye(r)\n                da = np.linalg.solve(K_red_reg, -r_red)\n            # Backtracking on full residual norm\n            alpha = 1.0\n            a_trial = a + alpha * da\n            u_trial = V @ a_trial\n            r_trial, _ = assemble_internal_and_tangent(u_trial, L, A, E_mod, N, Pk)\n            rn_trial = np.linalg.norm(r_trial)\n            rn_full = np.linalg.norm(r_full)\n            bt_count = 0\n            while rn_trial > rn_full and bt_count  10:\n                alpha *= 0.5\n                a_trial = a + alpha * da\n                u_trial = V @ a_trial\n                r_trial, _ = assemble_internal_and_tangent(u_trial, L, A, E_mod, N, Pk)\n                rn_trial = np.linalg.norm(r_trial)\n                bt_count += 1\n            a = a_trial\n        u_sol = V @ a\n        E_rom.append(compute_energy(u_sol, L, A, E_mod, N, Pk))\n        u_free_prev = u_sol\n    return np.array(E_rom)\n\ndef rom_lspg(L, A, E_mod, N, P_values, V, M_ff, tol=1e-10, max_iter=60):\n    \"\"\"\n    Least-Squares Petrov-Galerkin ROM solve across load steps using Gauss-Newton normal equations.\n    Returns reduced energies list E_rom (length K).\n    \"\"\"\n    K_steps = len(P_values)\n    n_free = N\n    r = V.shape[1]\n    a = np.zeros(r)\n    E_rom = []\n    u_free_prev = np.zeros(n_free)\n    for k, Pk in enumerate(P_values):\n        # Warm start\n        a = project_initial(V, M_ff, u_free_prev)\n        for it in range(max_iter):\n            u = V @ a\n            r_full, K_full = assemble_internal_and_tangent(u, L, A, E_mod, N, Pk)\n            J_r = K_full @ V  # Jacobian of residual wrt reduced coords\n            # Normal equations: (J^T M J) da = - J^T M r\n            A_mat = J_r.T @ (M_ff @ J_r)\n            b_vec = J_r.T @ (M_ff @ r_full)\n            # Solve for increment\n            reg = 1e-12\n            A_reg = A_mat + reg * np.eye(r)\n            try:\n                da = -np.linalg.solve(A_reg, b_vec)\n            except np.linalg.LinAlgError:\n                A_reg = A_mat + 1e-8 * np.eye(r)\n                da = -np.linalg.solve(A_reg, b_vec)\n            # Backtracking on weighted residual norm\n            alpha = 1.0\n            r_weighted_norm = np.sqrt(r_full.T @ (M_ff @ r_full))\n            a_trial = a + alpha * da\n            u_trial = V @ a_trial\n            r_trial, _ = assemble_internal_and_tangent(u_trial, L, A, E_mod, N, Pk)\n            r_trial_weighted_norm = np.sqrt(r_trial.T @ (M_ff @ r_trial))\n            bt_count = 0\n            while r_trial_weighted_norm > r_weighted_norm and bt_count  10:\n                alpha *= 0.5\n                a_trial = a + alpha * da\n                u_trial = V @ a_trial\n                r_trial, _ = assemble_internal_and_tangent(u_trial, L, A, E_mod, N, Pk)\n                r_trial_weighted_norm = np.sqrt(r_trial.T @ (M_ff @ r_trial))\n                bt_count += 1\n            a = a_trial\n            # Convergence check on weighted residual norm\n            if r_trial_weighted_norm  tol:\n                break\n        u_sol = V @ a\n        E_rom.append(compute_energy(u_sol, L, A, E_mod, N, Pk))\n        u_free_prev = u_sol\n    return np.array(E_rom)\n\ndef rms_relative_energy_error(E_rom, E_fom, tiny=1e-16):\n    \"\"\"\n    Compute RMS relative energy deviation as specified.\n    \"\"\"\n    K = len(E_fom)\n    num = np.sqrt(np.mean((E_rom - E_fom)**2))\n    den = np.mean(np.abs(E_fom))\n    if den  tiny:\n        return float('nan')\n    return num / den\n\ndef run_case(L, A, E_mod, N, K_steps, P_max, r_dim):\n    # Load steps\n    P_values = np.linspace(0.0, P_max, K_steps)\n    # Full-order\n    S, E_fom = newton_fom(L, A, E_mod, N, P_values)\n    # Mass matrix for POD\n    M_ff = assemble_mass_matrix(L, A, N)\n    # POD basis\n    V = pod_mass_weighted(S, M_ff, r_dim)\n    # Galerkin ROM\n    E_g = rom_galerkin(L, A, E_mod, N, P_values, V, M_ff)\n    # LSPG ROM\n    E_lspg = rom_lspg(L, A, E_mod, N, P_values, V, M_ff)\n    # Errors\n    err_g = rms_relative_energy_error(E_g, E_fom)\n    err_l = rms_relative_energy_error(E_lspg, E_fom)\n    return err_g, err_l\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (L, A, E_mod, N, K_steps, P_max, r_dim)\n        (1.0, 1.0e-2, 1.0e6, 30, 25, 1000.0, 6),  # Case 1\n        (1.0, 1.0e-2, 1.0e6, 30, 25, 1000.0, 1),  # Case 2\n        (1.0, 1.0e-2, 1.0e6, 30, 25, 5000.0, 6),  # Case 3\n        (1.0, 1.0e-2, 1.0e6, 8,  25, 1000.0, 6),  # Case 4\n    ]\n\n    results = []\n    for case in test_cases:\n        L, A, E_mod, N, K_steps, P_max, r_dim = case\n        err_g, err_l = run_case(L, A, E_mod, N, K_steps, P_max, r_dim)\n        results.append(err_g)\n        results.append(err_l)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3591637"}, {"introduction": "Beyond accelerating predictive simulations, reduced-order models serve as powerful frameworks for state estimation and data assimilation. This practice explores the concept of Gappy Proper Orthogonal Decomposition (POD), a technique for reconstructing a full, high-dimensional state field from a sparse set of sensor measurements. You will implement a sensor selection strategy based on pivoted QR factorization and contrast the performance of the Gappy POD reconstruction with a standard predictive Galerkin ROM, clarifying the distinct roles these models play in engineering analysis [@problem_id:3591686].", "problem": "Consider a one-dimensional, linear elastic bar of length $L$ with spatial coordinate $x \\in [0,L]$, constant Young's modulus $E$, and constant cross-sectional area $A$. Let the displacement field be $u(x)$ and let the body force per unit length be $b(x;\\mu)$, where $\\mu \\in [0,1]$ is a scalar parameter. The governing strong form of equilibrium is $- \\dfrac{d}{dx}\\!\\left(EA \\dfrac{du}{dx}\\right) = b(x;\\mu)$, and the bar is subject to homogeneous Dirichlet boundary conditions $u(0) = 0$ and $u(L) = 0$. Use the standard Galerkin finite element method with continuous, piecewise-linear shape functions on a uniform mesh to discretize the problem and obtain a symmetric positive-definite linear system for the interior degrees of freedom, $\\mathbf{K}\\mathbf{u} = \\mathbf{f}(\\mu)$, where $\\mathbf{u} \\in \\mathbb{R}^{n}$ represents the vector of nodal displacements for the $n$ interior nodes (the two boundary nodes are eliminated by the boundary conditions), $\\mathbf{K} \\in \\mathbb{R}^{n \\times n}$ is the stiffness matrix, and $\\mathbf{f}(\\mu) \\in \\mathbb{R}^{n}$ is the load vector assembled from the body force.\n\nFrom first principles, the stiffness matrix for each element of length $h$ is given by the bilinear form associated with the internal virtual work, leading to the standard two-node element stiffness $\\mathbf{K}^{(e)} = \\dfrac{EA}{h} \\begin{bmatrix}1  -1 \\\\ -1  1 \\end{bmatrix}$, and the element load vector $\\mathbf{f}^{(e)}(\\mu)$ arises from the virtual work of the body force as $\\int_{x_e}^{x_{e+1}} N_i(x)\\, b(x;\\mu)\\, dx$, where $N_i(x)$ are the element shape functions. Assemble the global $\\mathbf{K}$ and $\\mathbf{f}(\\mu)$ accordingly.\n\nDefine the training snapshot matrix $\\mathbf{S} \\in \\mathbb{R}^{n \\times n_s}$ by collecting $n_s$ displacement solutions (snapshots) $\\mathbf{u}(\\mu_j)$ corresponding to parameter values $\\{\\mu_j\\}_{j=1}^{n_s}$, so that $\\mathbf{S} = [\\,\\mathbf{u}(\\mu_1)\\,\\cdots\\,\\mathbf{u}(\\mu_{n_s})\\,]$. Construct a Proper Orthogonal Decomposition (POD) basis of rank $r$ by extracting the first $r$ left singular vectors of $\\mathbf{S}$, gathered in the matrix $\\boldsymbol{\\Phi}_r \\in \\mathbb{R}^{n \\times r}$ with orthonormal columns. Select $m$ sensor locations (degrees of freedom) by performing a column-pivoted QR factorization on $\\mathbf{S}^\\top$, which returns a permutation vector that prioritizes rows of $\\mathbf{S}$; interpret the first $m$ selected rows as the sensor indices. Let $\\mathbf{C} \\in \\{0,1\\}^{m \\times n}$ denote the selection matrix that extracts these sensor entries, so that the sensor measurement vector for a state $\\mathbf{u}$ is $\\mathbf{y} = \\mathbf{C}\\mathbf{u} \\in \\mathbb{R}^{m}$.\n\nGiven a new parameter $\\mu^\\star$, define the following three constructs.\n\n1) Gappy Proper Orthogonal Decomposition (gappy POD) reconstruction: infer an approximation $\\widehat{\\mathbf{u}} \\in \\mathbb{R}^{n}$ from sparse sensors by finding coefficients $\\widehat{\\mathbf{a}} \\in \\mathbb{R}^{r}$ that minimize the residual between the measured data and the projection onto the reduced basis at the sensor locations, that is, find $\\widehat{\\mathbf{a}}$ solving $\\min_{\\mathbf{a} \\in \\mathbb{R}^{r}} \\| \\mathbf{C}\\boldsymbol{\\Phi}_r \\mathbf{a} - \\mathbf{C}\\,\\mathbf{u}(\\mu^\\star) \\|_2$, and set $\\widehat{\\mathbf{u}} = \\boldsymbol{\\Phi}_r \\widehat{\\mathbf{a}}$.\n\n2) Galerkin reduced-order model prediction: compute the reduced coordinates $\\mathbf{a}_{\\mathrm{rom}}(\\mu^\\star) \\in \\mathbb{R}^{r}$ by solving the reduced linear system $\\boldsymbol{\\Phi}_r^\\top \\mathbf{K} \\boldsymbol{\\Phi}_r \\,\\mathbf{a}_{\\mathrm{rom}}(\\mu^\\star) = \\boldsymbol{\\Phi}_r^\\top \\mathbf{f}(\\mu^\\star)$ and set $\\mathbf{u}_{\\mathrm{rom}} = \\boldsymbol{\\Phi}_r \\mathbf{a}_{\\mathrm{rom}}(\\mu^\\star)$.\n\n3) Scalar quantity of interest: define the compliance-like quantity $q(\\mathbf{u};\\mu^\\star) := \\mathbf{u}^\\top \\mathbf{f}(\\mu^\\star)$.\n\nFor each test case below, you must perform the following tasks:\n\n- Build the full-order model on a uniform mesh with $N$ total nodes (including the two boundary nodes), $E = 1$, $A = 1$, $L = 1$, and homogeneous Dirichlet boundary conditions at $x=0$ and $x=L$. Use two-point Gaussian quadrature in each element to assemble the load vector from the body force.\n- Use $n_s$ training parameters $\\{\\mu_j\\}_{j=1}^{n_s}$ to assemble the snapshot matrix $\\mathbf{S}$.\n- Compute the POD basis $\\boldsymbol{\\Phi}_r$ of rank $r$ from $\\mathbf{S}$.\n- Compute a pivoted QR factorization of $\\mathbf{S}^\\top$ to rank the sensor indices and select $m$ sensors.\n- For the specified test parameter $\\mu^\\star$, compute the high-fidelity solution $\\mathbf{u}(\\mu^\\star)$, the gappy reconstruction $\\widehat{\\mathbf{u}}$, and the Galerkin reduced-order solution $\\mathbf{u}_{\\mathrm{rom}}$.\n- Report the following three relative errors (express all answers as decimals):\n  - The relative state reconstruction error $e_{\\text{state}} := \\dfrac{\\|\\widehat{\\mathbf{u}} - \\mathbf{u}(\\mu^\\star)\\|_2}{\\|\\mathbf{u}(\\mu^\\star)\\|_2}$.\n  - The relative error in the quantity of interest for the gappy reconstruction, $e_{q,\\text{gappy}} := \\dfrac{|q(\\widehat{\\mathbf{u}};\\mu^\\star) - q(\\mathbf{u}(\\mu^\\star);\\mu^\\star)|}{|q(\\mathbf{u}(\\mu^\\star);\\mu^\\star)|}$.\n  - The relative error in the quantity of interest for the Galerkin reduced-order model, $e_{q,\\text{rom}} := \\dfrac{|q(\\mathbf{u}_{\\mathrm{rom}};\\mu^\\star) - q(\\mathbf{u}(\\mu^\\star);\\mu^\\star)|}{|q(\\mathbf{u}(\\mu^\\star);\\mu^\\star)|}$.\n\nUse the body force parameterization\n$$\nb(x;\\mu) = c_1 \\sin(\\pi x) + c_2 \\sin(2\\pi x) + c_3 \\exp\\!\\left(-\\frac{(x-\\mu)^2}{2\\sigma^2}\\right),\n$$\nwith $c_1 = 1$, $c_2 = \\tfrac{1}{2}$, $c_3 = 4$, and $\\sigma = 0.07$. Let the training parameters be uniformly spaced in $[0.1,0.9]$, specifically $\\mu_j = 0.1 + (j-1)\\Delta\\mu$ with $\\Delta\\mu = \\dfrac{0.8}{n_s-1}$ for $j=1,\\dots,n_s$. Use $N=121$ and $n_s=21$ for all test cases.\n\nTest Suite:\n- Case $1$: $r=8$, $m=12$, $\\mu^\\star = 0.37$.\n- Case $2$: $r=8$, $m=8$, $\\mu^\\star = 0.63$.\n- Case $3$: $r=8$, $m=25$, $\\mu^\\star = 0.51$.\n- Case $4$: $r=8$, $m=5$, $\\mu^\\star = 0.75$.\n- Case $5$: $r=5$, $m=8$, $\\mu^\\star = 0.42$.\n\nYour program must implement all steps above and, for each case, output the triple of floats $[e_{\\text{state}}, e_{q,\\text{gappy}}, e_{q,\\text{rom}}]$ in that order. All three are unitless. Your program should produce a single line of output containing the results as a comma-separated list of these triples, enclosed in square brackets. For example, the format must be\n$$\n\\big[\\,[e_{\\text{state}}^{(1)},e_{q,\\text{gappy}}^{(1)},e_{q,\\text{rom}}^{(1)}],\\dots,[e_{\\text{state}}^{(5)},e_{q,\\text{gappy}}^{(5)},e_{q,\\text{rom}}^{(5)}]\\,\\big].\n$$", "solution": "The problem requires a comprehensive numerical simulation and analysis involving the finite element method (FEM), proper orthogonal decomposition (POD), and related model reduction techniques for a one-dimensional elastic bar. The process is broken down into several stages: full-order model (FOM) construction, snapshot collection, reduced-order model (ROM) construction, and error evaluation.\n\nThe physical system is a linear elastic bar of length $L=1$, Young's modulus $E=1$, and cross-sectional area $A=1$. The governing equation for the displacement field $u(x)$ under a body force $b(x;\\mu)$ is the second-order ordinary differential equation:\n$$\n- \\frac{d}{dx}\\!\\left(EA \\frac{du}{dx}\\right) = b(x;\\mu), \\quad x \\in [0, 1]\n$$\nwith homogeneous Dirichlet boundary conditions $u(0)=0$ and $u(1)=0$.\n\nFirst, we discretize the spatial domain using the Galerkin finite element method. The domain $[0,1]$ is divided into $N-1=120$ equal-sized elements of length $h=1/120$, defined by $N=121$ nodes. We use continuous, piecewise-linear basis functions (hat functions). After applying the boundary conditions, we are left with $n=N-2=119$ interior degrees of freedom. The discretization leads to a linear system of equations for the vector of interior nodal displacements $\\mathbf{u} \\in \\mathbb{R}^{n}$:\n$$\n\\mathbf{K}\\mathbf{u} = \\mathbf{f}(\\mu)\n$$\nHere, $\\mathbf{K} \\in \\mathbb{R}^{n \\times n}$ is the global stiffness matrix and $\\mathbf{f}(\\mu) \\in \\mathbb{R}^{n}$ is the global load vector, which depends on the parameter $\\mu$.\n\nThe stiffness matrix $\\mathbf{K}$ is assembled from element stiffness matrices $\\mathbf{K}^{(e)} = \\frac{EA}{h} \\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix}$. For the interior nodes, this results in a symmetric, tridiagonal, positive-definite matrix with diagonal entries $K_{ii} = \\frac{2EA}{h}$ and off-diagonal entries $K_{i,i\\pm 1} = -\\frac{EA}{h}$. Since $E=1$, $A=1$, and $h=1/120$, the diagonal entries are $240$ and off-diagonals are $-120$.\n\nThe load vector $\\mathbf{f}(\\mu)$ is assembled from element contributions. For an interior node $i$, its corresponding entry $f_i(\\mu)$ is given by the integral of the body force $b(x;\\mu)$ weighted by the hat basis function $\\phi_i(x)$:\n$$\nf_i(\\mu) = \\int_0^1 \\phi_i(x) b(x;\\mu) dx = \\int_{x_{i-1}}^{x_{i+1}} \\phi_i(x) b(x;\\mu) dx\n$$\nThis integral is computed numerically over each of the two adjacent elements using two-point Gaussian quadrature, as specified. The body force is given by:\n$$\nb(x;\\mu) = c_1 \\sin(\\pi x) + c_2 \\sin(2\\pi x) + c_3 \\exp\\!\\left(-\\frac{(x-\\mu)^2}{2\\sigma^2}\\right)\n$$\nwith constants $c_1=1$, $c_2=1/2$, $c_3=4$, and $\\sigma=0.07$.\n\nWith the FOM established, we generate $n_s=21$ \"snapshots\" by solving the FOM for a set of training parameters $\\{\\mu_j\\}_{j=1}^{n_s}$ uniformly spaced in $[0.1, 0.9]$. The resulting displacement vectors (snapshots) $\\mathbf{u}(\\mu_j)$ are collected as columns of the snapshot matrix $\\mathbf{S} \\in \\mathbb{R}^{n \\times n_s}$.\n\nNext, we construct a low-dimensional basis for the solution manifold using Proper Orthogonal Decomposition (POD), which is equivalent to performing a Singular Value Decomposition (SVD) on the snapshot matrix $\\mathbf{S} = \\mathbf{U}\\boldsymbol{\\Sigma}\\mathbf{V}^\\top$. The POD basis of rank $r$, denoted $\\boldsymbol{\\Phi}_r \\in \\mathbb{R}^{n \\times r}$, consists of the first $r$ left singular vectors of $\\mathbf{S}$ (i.e., the first $r$ columns of $\\mathbf{U}$). These vectors form an orthonormal basis that optimally captures the energy of the snapshots.\n\nSensor locations are determined using a greedy algorithm based on column-pivoted QR factorization of $\\mathbf{S}^\\top$. This procedure selects $m$ row indices of $\\mathbf{S}$ (corresponding to degrees of freedom) that provide the most linearly independent information about the snapshots. These $m$ indices define the sensor locations and are used to build a selection matrix $\\mathbf{C} \\in \\{0,1\\}^{m \\times n}$.\n\nFor a given test parameter $\\mu^\\star$, we evaluate three different approximations of the solution $\\mathbf{u}(\\mu^\\star)$:\n$1$. The high-fidelity solution $\\mathbf{u}(\\mu^\\star)$, obtained by solving the full-order system $\\mathbf{K}\\mathbf{u}(\\mu^\\star)=\\mathbf{f}(\\mu^\\star)$. This serves as the \"ground truth\".\n$2$. The gappy POD reconstruction $\\widehat{\\mathbf{u}}$. This approximates the full state from sparse measurements $\\mathbf{y} = \\mathbf{C}\\mathbf{u}(\\mu^\\star)$. The state is approximated as a linear combination of the POD basis vectors, $\\widehat{\\mathbf{u}} = \\boldsymbol{\\Phi}_r \\widehat{\\mathbf{a}}$, where the coefficients $\\widehat{\\mathbf{a}} \\in \\mathbb{R}^r$ are found by solving the least-squares problem:\n$$\n\\widehat{\\mathbf{a}} = \\arg\\min_{\\mathbf{a} \\in \\mathbb{R}^{r}} \\| \\mathbf{C}\\boldsymbol{\\Phi}_r \\mathbf{a} - \\mathbf{y} \\|_2\n$$\n$3$. The Galerkin ROM prediction $\\mathbf{u}_{\\mathrm{rom}}$. This is found by projecting the governing FOM equations onto the POD basis. The solution is written as $\\mathbf{u}_{\\mathrm{rom}} = \\boldsymbol{\\Phi}_r \\mathbf{a}_{\\mathrm{rom}}$, where the reduced coordinates $\\mathbf{a}_{\\mathrm{rom}} \\in \\mathbb{R}^r$ are the solution to the much smaller $r \\times r$ linear system:\n$$\n\\mathbf{K}_r \\mathbf{a}_{\\mathrm{rom}} = \\mathbf{f}_r(\\mu^\\star), \\quad \\text{where} \\quad \\mathbf{K}_r = \\boldsymbol{\\Phi}_r^\\top \\mathbf{K} \\boldsymbol{\\Phi}_r \\quad \\text{and} \\quad \\mathbf{f}_r(\\mu^\\star) = \\boldsymbol{\\Phi}_r^\\top \\mathbf{f}(\\mu^\\star)\n$$\n\nFinally, for each test case, we compute three relative errors. First, the state reconstruction error for gappy POD:\n$$\ne_{\\text{state}} = \\frac{\\|\\widehat{\\mathbf{u}} - \\mathbf{u}(\\mu^\\star)\\|_2}{\\|\\mathbf{u}(\\mu^\\star)\\|_2}\n$$\nSecond and third, the relative errors in a scalar quantity of interest (QoI), defined as the compliance $q(\\mathbf{u};\\mu^\\star) = \\mathbf{u}^\\top \\mathbf{f}(\\mu^\\star)$, for both the gappy POD and Galerkin ROM solutions:\n$$\ne_{q,\\text{gappy}} = \\frac{|q(\\widehat{\\mathbf{u}};\\mu^\\star) - q(\\mathbf{u}(\\mu^\\star);\\mu^\\star)|}{|q(\\mathbf{u}(\\mu^\\star);\\mu^\\star)|}, \\quad e_{q,\\text{rom}} = \\frac{|q(\\mathbf{u}_{\\mathrm{rom}};\\mu^\\star) - q(\\mathbf{u}(\\mu^\\star);\\mu^\\star)|}{|q(\\mathbf{u}(\\mu^\\star);\\mu^\\star)|}\n$$\nThese computations are performed for each of the five test cases specified in the problem statement.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import qr, svd\n\ndef solve():\n    \"\"\"\n    Solves the model reduction problem for a 1D elastic bar.\n\n    The function implements the following steps:\n    1. Sets up the finite element model (FEM) for the bar.\n    2. Generates solution snapshots for a range of parameters.\n    3. Computes a Proper Orthogonal Decomposition (POD) basis from the snapshots.\n    4. Determines optimal sensor locations using column-pivoted QR factorization.\n    5. For each test case, it computes:\n        a. The high-fidelity FEM solution.\n        b. A gappy POD reconstruction from sparse sensor data.\n        c. A Galerkin reduced-order model (ROM) prediction.\n    6. Calculates and reports the relative errors for state reconstruction and a quantity of interest.\n    \"\"\"\n    \n    # --- 1. Model and Simulation Parameters ---\n    N = 121         # Total number of nodes\n    L = 1.0         # Length of the bar\n    E = 1.0         # Young's modulus\n    A = 1.0         # Cross-sectional area\n    n = N - 2       # Number of interior nodes (degrees of freedom)\n    h = L / (N - 1) # Element length\n    nodes = np.linspace(0, L, N) # Nodal coordinates\n\n    # Body force function parameters\n    c1, c2, c3, sigma = 1.0, 0.5, 4.0, 0.07\n\n    def body_force(x, mu):\n        term1 = c1 * np.sin(np.pi * x)\n        term2 = c2 * np.sin(2 * np.pi * x)\n        term3 = c3 * np.exp(-(x - mu)**2 / (2 * sigma**2))\n        return term1 + term2 + term3\n\n    # --- 2. Full-Order Model (FEM) Assembly ---\n    # Stiffness Matrix K\n    K_diag = 2.0 * E * A / h\n    K_offdiag = -E * A / h\n    K = np.diag(np.full(n, K_diag, dtype=np.float64)) + \\\n        np.diag(np.full(n - 1, K_offdiag, dtype=np.float64), k=1) + \\\n        np.diag(np.full(n - 1, K_offdiag, dtype=np.float64), k=-1)\n    \n    # Gaussian quadrature points and weights for 2-point rule\n    gauss_pts = np.array([-1.0/np.sqrt(3.0), 1.0/np.sqrt(3.0)], dtype=np.float64)\n    gauss_wts = np.array([1.0, 1.0], dtype=np.float64)\n    \n    def assemble_force_vector(mu):\n        f = np.zeros(n, dtype=np.float64)\n        # N1 and N2 are shape functions on the reference element [-1, 1]\n        N1_vals = (1.0 - gauss_pts) / 2.0\n        N2_vals = (1.0 + gauss_pts) / 2.0\n\n        for i in range(1, N - 1): # Iterate over interior nodes\n            node_idx = i - 1\n            \n            # Contribution from left element (element i-1)\n            # Node i is the 2nd node of this element -> use shape function N2\n            xq_left = nodes[i - 1] + (h / 2.0) * (1.0 + gauss_pts)\n            integral_left = (h / 2.0) * np.sum(gauss_wts * N2_vals * body_force(xq_left, mu))\n            \n            # Contribution from right element (element i)\n            # Node i is the 1st node of this element -> use shape function N1\n            xq_right = nodes[i] + (h / 2.0) * (1.0 + gauss_pts)\n            integral_right = (h / 2.0) * np.sum(gauss_wts * N1_vals * body_force(xq_right, mu))\n            \n            f[node_idx] = integral_left + integral_right\n        return f\n\n    # --- 3. Snapshot Generation ---\n    n_s = 21\n    mu_train = np.linspace(0.1, 0.9, n_s, dtype=np.float64)\n    S = np.zeros((n, n_s), dtype=np.float64)\n    for j in range(n_s):\n        f_j = assemble_force_vector(mu_train[j])\n        u_j = np.linalg.solve(K, f_j)\n        S[:, j] = u_j\n\n    # --- 4. SVD and QR Pre-computation ---\n    U, _, _ = svd(S, full_matrices=False)\n    _, _, P = qr(S.T, pivoting=True, mode='economic')\n\n    # --- 5. Test Suite Execution ---\n    test_cases = [\n        (8, 12, 0.37),\n        (8, 8, 0.63),\n        (8, 25, 0.51),\n        (8, 5, 0.75),\n        (5, 8, 0.42),\n    ]\n\n    results = []\n    for r, m, mu_star in test_cases:\n        # Get POD basis of rank r\n        Phi_r = U[:, :r]\n        \n        # Get m sensor locations\n        sensor_indices = P[:m]\n        \n        # Compute high-fidelity solution for mu_star\n        f_star = assemble_force_vector(mu_star)\n        u_hifi = np.linalg.solve(K, f_star)\n        u_hifi_norm = np.linalg.norm(u_hifi)\n        \n        # Gappy POD Reconstruction\n        C_Phi_r = Phi_r[sensor_indices, :]\n        y_meas = u_hifi[sensor_indices]\n        a_hat, _, _, _ = np.linalg.lstsq(C_Phi_r, y_meas, rcond=None)\n        u_gappy = Phi_r @ a_hat\n\n        # Galerkin ROM Prediction\n        K_r = Phi_r.T @ K @ Phi_r\n        f_r = Phi_r.T @ f_star\n        a_rom = np.linalg.solve(K_r, f_r)\n        u_rom = Phi_r @ a_rom\n        \n        # Quantities of Interest (QoI)\n        q_hifi = u_hifi @ f_star\n        q_gappy = u_gappy @ f_star\n        q_rom = u_rom @ f_star\n        q_hifi_abs = np.abs(q_hifi)\n\n        # Compute relative errors\n        e_state = np.linalg.norm(u_gappy - u_hifi) / u_hifi_norm\n        e_q_gappy = np.abs(q_gappy - q_hifi) / q_hifi_abs\n        e_q_rom = np.abs(q_rom - q_hifi) / q_hifi_abs\n        \n        results.append([e_state, e_q_gappy, e_q_rom])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3591686"}, {"introduction": "Effective engineering use of model reduction requires not just implementation skills, but also a theoretical understanding of error sources and computational cost. This final practice shifts our focus from coding to analysis, challenging you to deconstruct the error of a hyper-reduced model into its constituent parts: the projection error and the hyper-reduction error. By formalizing these error contributions, you will develop a principled strategy for optimally allocating computational resources—the sizes of the state basis $r$ and the force basis $m$—to achieve a desired accuracy at minimal cost [@problem_id:3591661].", "problem": "Consider a quasi-static nonlinear finite element model of hyperelasticity in which the full-order model (FOM) seeks $u^\\star \\in \\mathbb{R}^N$ satisfying the equilibrium equation $R(u;\\mu) = f_{\\mathrm{ext}}(\\mu) - f_{\\mathrm{int}}(u;\\mu) = 0$ for a given parameter $\\mu$. Assume the internal force $f_{\\mathrm{int}}(\\,\\cdot\\,;\\mu)$ is Gateaux differentiable and its Jacobian (the consistent tangent) $K(u;\\mu) = \\partial f_{\\mathrm{int}}/\\partial u$ is uniformly strongly monotone and Lipschitz continuous in a neighborhood of $u^\\star$, i.e., there exist constants $\\alpha  0$ and $L  0$ such that, for all $u,v$ in that neighborhood, $(K(w;\\mu)\\xi,\\xi) \\ge \\alpha \\|\\xi\\|_2^2$ for all $\\xi$ and $\\|K(u;\\mu) - K(v;\\mu)\\|_2 \\le L \\|u-v\\|_2$ for all $u,v,w$ on the segment between $u$ and $v$. A Proper Orthogonal Decomposition (POD) reduced basis $V_r \\in \\mathbb{R}^{N\\times r}$ with orthonormal columns (in the Euclidean inner product induced by mass lumping) is constructed from displacement snapshots, and a Discrete Empirical Interpolation Method (DEIM) basis $U_m \\in \\mathbb{R}^{N\\times m}$ with sampling matrix $P \\in \\mathbb{R}^{N\\times m}$ is constructed from internal force snapshots. The DEIM approximation is $f_{\\mathrm{int}}^m(u;\\mu) = U_m (P^T U_m)^{-1} P^T f_{\\mathrm{int}}(u;\\mu)$. The hyper-reduced reduced-order model (ROM) computes $a_m(\\mu) \\in \\mathbb{R}^r$ from $V_r^T\\big(f_{\\mathrm{ext}}(\\mu) - f_{\\mathrm{int}}^m(V_r a_m(\\mu);\\mu)\\big) = 0$ and returns the state approximation $u_r^m(\\mu) = V_r a_m(\\mu)$.\n\nSuppose the singular values of the displacement snapshot matrix decay algebraically as $\\sigma_i^{(u)} \\sim C_u^{(0)}\\, i^{-p}$ with $p  \\tfrac{1}{2}$, and the singular values of the internal force snapshot matrix decay as $\\sigma_i^{(f)} \\sim C_f^{(0)}\\, i^{-q}$ with $q  \\tfrac{1}{2}$. Let the DEIM interpolation stability be characterized by $\\kappa_m = \\|(P^T U_m)^{-1}\\|_2$; assume a strong rank-revealing factorization yields a uniform bound $\\kappa_m \\le \\kappa_0$ independent of $m$ in the regime of interest. Consider the computational cost per Newton step of the hyper-reduced ROM given by $\\mathcal{C}(r,m) = c_s r^3 + c_e m r$, where $c_s  0$ reflects reduced system factorization/solve and $c_e  0$ reflects hyper-reduced residual and Jacobian assembly.\n\nYour task is to reason from first principles to (i) decompose the total ROM state error $\\|u^\\star - u_r^m\\|_2$ into a projection component and a hyper-reduction component using a two-step argument based on strong monotonicity and the triangle inequality, and (ii) design a strategy to allocate basis size $r$ and DEIM size $m$ that meets a target tolerance $\\varepsilon  0$ on the state error at minimal cost. In particular, use the POD optimality property for snapshot approximation and the algebraic decay models above to justify asymptotic forms for the projection and hyper-reduction error contributions as functions of $r$ and $m$, and then describe how to determine $r$ and $m$ to minimize $\\mathcal{C}(r,m)$ subject to meeting the tolerance.\n\nAssume throughout that $\\alpha = L$, $\\kappa_m \\le \\kappa_0$ with a moderate $\\kappa_0$, and that the neighborhood assumptions required for Newton convergence and the operator inequalities are satisfied.\n\nWhich option best captures both a valid decomposition and a cost-minimizing allocation principle consistent with these assumptions?\n\nA. Introduce the intermediate Galerkin solution $u_r$ that solves $V_r^T\\big(f_{\\mathrm{ext}}(\\mu) - f_{\\mathrm{int}}(V_r a_r(\\mu);\\mu)\\big) = 0$, invoke strong monotonicity to obtain a quasi-optimality bound $\\|u^\\star - u_r\\|_2 \\le C_1 \\inf_{v\\in \\mathrm{Range}(V_r)} \\|u^\\star - v\\|_2$, and bound the hyper-reduction perturbation $\\|u_r - u_r^m\\|_2$ via residual consistency and $\\kappa_m$ to get $\\|u^\\star - u_r^m\\|_2 \\le C_1\\,\\rho_r + C_2\\,\\kappa_m\\,\\tau_m$, where $\\rho_r \\approx \\big(\\sum_{ir} (\\sigma_i^{(u)})^2\\big)^{1/2} \\sim \\tilde C_u\\, r^{-(p-\\tfrac{1}{2})}$ and $\\tau_m \\approx \\big(\\sum_{im} (\\sigma_i^{(f)})^2\\big)^{1/2} \\sim \\tilde C_f\\, m^{-(q-\\tfrac{1}{2})}$. Then choose $r$ and $m$ by solving the constrained optimization $\\min_{r,m} \\mathcal{C}(r,m)$ subject to $C_1\\,\\rho_r + C_2\\,\\kappa_0\\,\\tau_m \\le \\varepsilon$, using Lagrange multipliers to equalize the marginal cost per unit error reduction, i.e., $(\\partial \\mathcal{C}/\\partial r)/|\\partial (C_1\\rho_r)/\\partial r| = (\\partial \\mathcal{C}/\\partial m)/|\\partial (C_2\\kappa_0 \\tau_m)/\\partial m|$, which allocates a larger share of the error budget to the more expensive-to-reduce contribution (typically the projection error due to the $r^3$ term), thereby achieving minimal cost.\n\nB. Treat the projection and hyper-reduction errors as orthogonal and decompose the total error as a Euclidean sum $\\|u^\\star - u_r^m\\|_2^2 = \\|u^\\star - u_r\\|_2^2 + \\|u_r - u_r^m\\|_2^2$; then enforce equal allocation by imposing $\\|u^\\star - u_r\\|_2 = \\|u_r - u_r^m\\|_2 = \\varepsilon/ \\sqrt{2}$, which implies choosing $r$ and $m$ so that $\\rho_r \\approx \\tau_m \\approx \\varepsilon$, because equal splitting always minimizes the cost under any cost model.\n\nC. Choose $r$ and $m$ to be equal, $r = m$, since using the same number of POD modes for the state and the internal force ensures balanced accuracy; determine the common value by solving $\\rho_r \\approx \\tau_r \\approx \\varepsilon$ and ignore the distinct costs of solving the reduced system and assembling the hyper-reduced residual.\n\nD. Use the triangle inequality to write $\\|u^\\star - u_r^m\\|_2 \\le \\|u^\\star - u_r\\|_2 + \\|u_r - u_r^m\\|_2$, but then allocate the tolerance by forcing the two contributions to be equal, $\\|u^\\star - u_r\\|_2 = \\|u_r - u_r^m\\|_2 = \\varepsilon/2$, regardless of the cost model, because equal splitting minimizes the sum of two positive terms; compute $r$ and $m$ from the algebraic decay of $\\rho_r$ and $\\tau_m$ under this halving rule.", "solution": "The user requires a critical validation of the problem statement, followed by a first-principles derivation of the solution and a detailed evaluation of all provided options.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n\n-   **Full-Order Model (FOM):** The state vector $u^\\star \\in \\mathbb{R}^N$ solves the nonlinear system $R(u;\\mu) = f_{\\mathrm{ext}}(\\mu) - f_{\\mathrm{int}}(u;\\mu) = 0$ for a parameter $\\mu$.\n-   **Internal Force and Tangent Stiffness:** The internal force $f_{\\mathrm{int}}(u;\\mu)$ is Gateaux differentiable. Its Jacobian is the tangent stiffness matrix $K(u;\\mu) = \\partial f_{\\mathrm{int}}/\\partial u$.\n-   **Operator Properties:** $K(u;\\mu)$ is uniformly strongly monotone and Lipschitz continuous in a neighborhood of the solution $u^\\star$.\n    -   Strong monotonicity: $(K(w;\\mu)\\xi,\\xi) \\ge \\alpha \\|\\xi\\|_2^2$ for a constant $\\alpha  0$.\n    -   Lipschitz continuity: $\\|K(u;\\mu) - K(v;\\mu)\\|_2 \\le L \\|u-v\\|_2$ for a constant $L  0$.\n-   **Reduced Bases:**\n    -   A POD basis for displacement, $V_r \\in \\mathbb{R}^{N\\times r}$, has orthonormal columns ($V_r^T V_r = I_r$).\n    -   A DEIM basis for the internal force, $U_m \\in \\mathbb{R}^{N\\times m}$, is used with a sampling matrix $P \\in \\mathbb{R}^{N\\times m}$.\n-   **DEIM Approximation:** The internal force is approximated as $f_{\\mathrm{int}}^m(u;\\mu) = U_m (P^T U_m)^{-1} P^T f_{\\mathrm{int}}(u;\\mu)$.\n-   **Hyper-Reduced ROM (HROM):** The HROM solution is $u_r^m(\\mu) = V_r a_m(\\mu)$, where the reduced coordinate vector $a_m(\\mu) \\in \\mathbb{R}^r$ solves the projected system $V_r^T\\big(f_{\\mathrm{ext}}(\\mu) - f_{\\mathrm{int}}^m(V_r a_m(\\mu);\\mu)\\big) = 0$.\n-   **Error Decay Models:**\n    -   Singular values of displacement snapshots: $\\sigma_i^{(u)} \\sim C_u^{(0)}\\, i^{-p}$ with $p  \\tfrac{1}{2}$.\n    -   Singular values of internal force snapshots: $\\sigma_i^{(f)} \\sim C_f^{(0)}\\, i^{-q}$ with $q  \\tfrac{1}{2}$.\n-   **DEIM Stability:** The DEIM interpolation process has a stability constant bounded by $\\kappa_m = \\|(P^T U_m)^{-1}\\|_2 \\le \\kappa_0$.\n-   **Cost Model:** The computational cost per Newton step is $\\mathcal{C}(r,m) = c_s r^3 + c_e m r$, with $c_s  0$ and $c_e  0$.\n-   **Task:** (i) Decompose the total state error $\\|u^\\star - u_r^m\\|_2$ and (ii) determine a cost-minimizing strategy for selecting $r$ and $m$ to meet a tolerance $\\varepsilon  0$.\n-   **Assumptions:** $\\alpha = L$, and neighborhood assumptions for analysis hold.\n\n**Step 2: Validate Using Extracted Givens**\n\n-   **Scientific Grounding:** The problem is firmly grounded in the advanced literature of computational solid mechanics, specifically in projection-based model order reduction. All concepts—POD, DEIM, hyper-reduction, Newton's method, strong monotonicity, and Lipschitz continuity of operators—are standard and correctly formulated. The described framework is the state of the art for analyzing the accuracy of such methods.\n-   **Well-Posedness:** The problem is well-posed. It provides sufficient mathematical structure (e.g., operator properties ensuring unique solutions to the nonlinear systems) and defines a clear objective (error analysis and cost optimization).\n-   **Objectivity:** The problem statement is expressed in precise, objective mathematical language, free from ambiguity or subjective claims.\n\n**Step 3: Verdict and Action**\n\nThe problem statement is scientifically sound, self-contained, and well-posed. It represents a standard, albeit complex, theoretical problem in its field. All conditions are met for a valid problem. Therefore, I will proceed with the solution.\n\n### Derivation and Option Analysis\n\nThe task is to analyze the total error of the hyper-reduced model, $\\|u^\\star - u_r^m\\|_2$, and devise a strategy to minimize computational cost $\\mathcal{C}(r,m)$ for a given error tolerance $\\varepsilon$.\n\n**Part (i): Error Decomposition**\n\nA standard technique for analyzing the error of a perturbed system is to introduce an intermediate, unperturbed solution and apply the triangle inequality. The natural intermediate solution here is the Galerkin ROM solution, which uses projection but not hyper-reduction. Let $u_r = V_r a_r$ be the solution to the Galerkin ROM:\n$$ V_r^T R(u_r) = V_r^T(f_{\\mathrm{ext}}(\\mu) - f_{\\mathrm{int}}(u_r;\\mu)) = 0 $$\nThe total error can then be decomposed using the triangle inequality:\n$$ \\|u^\\star - u_r^m\\|_2 \\le \\|u^\\star - u_r\\|_2 + \\|u_r - u_r^m\\|_2 $$\nThis decomposition splits the total error into two distinct contributions:\n1.  $\\|u^\\star - u_r\\|_2$: The **projection error**, arising from approximating the solution manifold by the finite-dimensional subspace spanned by $V_r$.\n2.  $\\|u_r - u_r^m\\|_2$: The **hyper-reduction error**, which is the perturbation in the Galerkin solution caused by approximating the internal force $f_{\\mathrm{int}}$ with the DEIM approximation $f_{\\mathrm{int}}^m$.\n\n**Bounding the Projection Error $\\|u^\\star - u_r\\|_2$:**\nThe properties of strong monotonicity and Lipschitz continuity of the residual operator $R(u)$ (which follow from the given properties for $K = -\\partial R/\\partial u$) lead to a quasi-optimality result, a nonlinear analogue of Céa's lemma. This result states that the error of the Galerkin solution is bounded by a constant times the best possible approximation error from the subspace:\n$$ \\|u^\\star - u_r\\|_2 \\le C_1 \\inf_{v_r \\in \\mathrm{Range}(V_r)} \\|u^\\star - v_r\\|_2 $$\nThe constant $C_1$ depends on the operator properties (specifically, a ratio of a Lipschitz/boundedness constant to the strong monotonicity constant $\\alpha$). The term $\\inf_{v_r \\in \\mathrm{Range}(V_r)} \\|u^\\star - v_r\\|_2 = \\|(I - V_rV_r^T)u^\\star\\|_2$ is the error of the best approximation of $u^\\star$ in the subspace. POD is designed to make this term small on average over the set of snapshots used to generate $V_r$. The expected magnitude of this error is well-approximated by the truncated singular values of the displacement snapshot matrix. Let $\\rho_r$ denote this error term. Given the algebraic decay model $\\sigma_i^{(u)} \\sim C_u^{(0)} i^{-p}$, the root-mean-square error over the snapshots is $\\big(\\sum_{i=r+1}^{S} (\\sigma_i^{(u)})^2\\big)^{1/2}$. For large $r$, this sum can be approximated by an integral:\n$$ \\rho_r \\approx \\left( \\int_r^\\infty (C_u^{(0)} x^{-p})^2 dx \\right)^{1/2} = C_u^{(0)} \\left( \\frac{r^{1-2p}}{2p-1} \\right)^{1/2} \\sim \\tilde{C}_u r^{-(p - 1/2)} $$\nThis relies on the given condition $p  1/2$. Thus, we have $\\|u^\\star - u_r\\|_2 \\lesssim C_1 \\tilde{C}_u r^{-(p - 1/2)}$.\n\n**Bounding the Hyper-reduction Error $\\|u_r - u_r^m\\|_2$:**\nThis error is the difference between the solutions of the Galerkin ROM and the HROM. Their governing equations are:\n$$ V_r^T f_{\\mathrm{int}}(u_r) = V_r^T f_{\\mathrm{ext}} $$\n$$ V_r^T f_{\\mathrm{int}}^m(u_r^m) = V_r^T f_{\\mathrm{ext}} $$\nSubtracting gives $V_r^T (f_{\\mathrm{int}}(u_r) - f_{\\mathrm{int}}^m(u_r^m)) = 0$. By adding and subtracting $V_r^T f_{\\mathrm{int}}(u_r^m)$, we obtain:\n$$ V_r^T (f_{\\mathrm{int}}(u_r) - f_{\\mathrm{int}}(u_r^m)) = V_r^T (f_{\\mathrm{int}}^m(u_r^m) - f_{\\mathrm{int}}(u_r^m)) $$\nAn analysis based on the strong monotonicity of $f_{\\mathrm{int}}$ (which follows from that of $K$) shows that the left-hand side provides a lower bound in terms of $\\|u_r-u_r^m\\|_2^2$, while the right-hand side is the source term due to the DEIM approximation. This leads to a bound of the form:\n$$ \\|u_r - u_r^m\\|_2 \\le \\frac{1}{\\alpha'} \\|f_{\\mathrm{int}}(u_r^m) - f_{\\mathrm{int}}^m(u_r^m)\\|_2 $$\nwhere $\\alpha'$ is an effective strong monotonicity constant for the reduced system. The DEIM error itself is bounded by the best approximation error from the DEIM subspace, scaled by the stability constant $\\kappa_m = \\|(P^T U_m)^{-1}\\|_2$:\n$$ \\|f_{\\mathrm{int}}(u) - f_{\\mathrm{int}}^m(u)\\|_2 \\le C_{\\mathrm{DEIM}}\\,\\kappa_m\\, \\|(I - U_mU_m^T)f_{\\mathrm{int}}(u)\\|_2 $$\nThe term $\\|(I - U_mU_m^T)f_{\\mathrm{int}}(u)\\|_2$ is the error of the best approximation of the internal force vector from the subspace spanned by $U_m$. Let's call its supremum $\\tau_m$. Similar to the displacement case, this is estimated by the tail of the singular values of the internal force snapshot matrix, which yields the asymptotic behavior $\\tau_m \\sim \\tilde{C}_f m^{-(q - 1/2)}$.\nCombining these results and using the uniform bound $\\kappa_m \\le \\kappa_0$, we get the bound on the hyper-reduction error: $\\|u_r - u_r^m\\|_2 \\lesssim C_2 \\kappa_0 \\tau_m \\sim C_2 \\kappa_0 \\tilde{C}_f m^{-(q - 1/2)}$.\n\n**Total Error Bound:**\nCombining the two components, the total error is bounded by:\n$$ \\|u^\\star - u_r^m\\|_2 \\le C_1 \\rho_r + C_2 \\kappa_0 \\tau_m \\approx A r^{-(p-1/2)} + B m^{-(q-1/2)} $$\nwhere $A$ and $B$ are constants.\n\n**Part (ii): Cost Minimization**\n\nWe aim to minimize the cost $\\mathcal{C}(r,m) = c_s r^3 + c_e m r$ subject to the error constraint $A r^{-(p-1/2)} + B m^{-(q-1/2)} \\le \\varepsilon$. To find the minimum cost, we solve the problem for the equality constraint $A r^{-(p-1/2)} + B m^{-(q-1/2)} = \\varepsilon$. This is a constrained optimization problem, solvable with Lagrange multipliers. Let $P = p-1/2$ and $Q = q-1/2$. The Lagrangian is:\n$$ \\mathcal{L}(r, m, \\lambda) = (c_s r^3 + c_e m r) - \\lambda (A r^{-P} + B m^{-Q} - \\varepsilon) $$\nThe optimality conditions are $\\nabla \\mathcal{L} = 0$:\n$$ \\frac{\\partial \\mathcal{L}}{\\partial r} = (3 c_s r^2 + c_e m) - \\lambda (-P A r^{-P-1}) = 0 $$\n$$ \\frac{\\partial \\mathcal{L}}{\\partial m} = c_e r - \\lambda (-Q B m^{-Q-1}) = 0 $$\nFrom these two equations, we can solve for the Lagrange multiplier $\\lambda$:\n$$ \\lambda = \\frac{3 c_s r^2 + c_e m}{P A r^{-P-1}} = \\frac{c_e r}{Q B m^{-Q-1}} $$\nThe term $\\partial \\mathcal{C} / \\partial r = 3c_s r^2 + c_e m$ is the marginal cost of increasing $r$. The term $|\\partial(A r^{-P})/\\partial r| = P A r^{-P-1}$ is the marginal error reduction from increasing $r$. The ratio is precisely the left-hand expression for $\\lambda$. Similarly, the right-hand expression is the marginal cost per unit error reduction for $m$. The equality of these two ratios is the principle of equi-marginality: at the optimum, the \"value\" (in terms of error reduction) obtained from the last dollar spent must be the same, whether it's spent on increasing $r$ or increasing $m$.\n\nIf one error source (e.g., projection error reduced by $r$) is much more expensive to reduce, the optimization will favor a smaller $r$, thus allocating a larger portion of the total error budget $\\varepsilon$ to the projection error, while requiring a much smaller hyper-reduction error (achieved with a larger $m$) to compensate.\n\n### Option-by-Option Analysis\n\n**A. Introduce the intermediate Galerkin solution $u_r$ that solves $V_r^T\\big(f_{\\mathrm{ext}}(\\mu) - f_{\\mathrm{int}}(V_r a_r(\\mu);\\mu)\\big) = 0$, invoke strong monotonicity to obtain a quasi-optimality bound $\\|u^\\star - u_r\\|_2 \\le C_1 \\inf_{v\\in \\mathrm{Range}(V_r)} \\|u^\\star - v\\|_2$, and bound the hyper-reduction perturbation $\\|u_r - u_r^m\\|_2$ via residual consistency and $\\kappa_m$ to get $\\|u^\\star - u_r^m\\|_2 \\le C_1\\,\\rho_r + C_2\\,\\kappa_m\\,\\tau_m$, where $\\rho_r \\approx \\big(\\sum_{ir} (\\sigma_i^{(u)})^2\\big)^{1/2} \\sim \\tilde C_u\\, r^{-(p-\\tfrac{1}{2})}$ and $\\tau_m \\approx \\big(\\sum_{im} (\\sigma_i^{(f)})^2\\big)^{1/2} \\sim \\tilde C_f\\, m^{-(q-\\tfrac{1}{2})}$. Then choose $r$ and $m$ by solving the constrained optimization $\\min_{r,m} \\mathcal{C}(r,m)$ subject to $C_1\\,\\rho_r + C_2\\,\\kappa_0\\,\\tau_m \\le \\varepsilon$, using Lagrange multipliers to equalize the marginal cost per unit error reduction, i.e., $(\\partial \\mathcal{C}/\\partial r)/|\\partial (C_1\\rho_r)/\\partial r| = (\\partial \\mathcal{C}/\\partial m)/|\\partial (C_2\\kappa_0 \\tau_m)/\\partial m|$, which allocates a larger share of the error budget to the more expensive-to-reduce contribution (typically the projection error due to the $r^3$ term), thereby achieving minimal cost.**\n- This option perfectly follows the rigorous derivation. The error decomposition, the bounds based on operator properties, the asymptotic error forms, and the cost-optimization principle based on Lagrange multipliers (equalizing marginal cost per unit error reduction) are all correct. The concluding remark about allocating a larger error share to the more expensive component is a correct insight derived from this principle.\n- **Verdict: Correct.**\n\n**B. Treat the projection and hyper-reduction errors as orthogonal and decompose the total error as a Euclidean sum $\\|u^\\star - u_r^m\\|_2^2 = \\|u^\\star - u_r\\|_2^2 + \\|u_r - u_r^m\\|_2^2$; then enforce equal allocation by imposing $\\|u^\\star - u_r\\|_2 = \\|u_r - u_r^m\\|_2 = \\varepsilon/ \\sqrt{2}$, which implies choosing $r$ and $m$ so that $\\rho_r \\approx \\tau_m \\approx \\varepsilon$, because equal splitting always minimizes the cost under any cost model.**\n- The decomposition $\\|u^\\star - u_r^m\\|_2^2 = \\|u^\\star - u_r\\|_2^2 + \\|u_r - u_r^m\\|_2^2$ requires the error vectors $u^\\star - u_r$ and $u_r - u_r^m$ to be orthogonal. There is no mathematical reason for this to be true in general. The vector $u_r-u_r^m$ lies in the subspace $\\mathrm{Range}(V_r)$, but $u^\\star - u_r$ is not guaranteed to be orthogonal to this subspace. The claim that \"equal splitting always minimizes the cost\" is false; it ignores the cost function's structure.\n- **Verdict: Incorrect.**\n\n**C. Choose $r$ and $m$ to be equal, $r = m$, since using the same number of POD modes for the state and the internal force ensures balanced accuracy; determine the common value by solving $\\rho_r \\approx \\tau_r \\approx \\varepsilon$ and ignore the distinct costs of solving the reduced system and assembling the hyper-reduced residual.**\n- The assumption $r=m$ is an ad-hoc simplification. The optimal choice of $r$ and $m$ depends on the decay rates of the respective singular values ($p$ and $q$) and the cost coefficients ($c_s$ and $c_e$), none of which suggest $r$ and $m$ should be equal. Ignoring the distinct costs is contrary to the problem's goal of minimizing $\\mathcal{C}(r,m)$.\n- **Verdict: Incorrect.**\n\n**D. Use the triangle inequality to write $\\|u^\\star - u_r^m\\|_2 \\le \\|u^\\star - u_r\\|_2 + \\|u_r - u_r^m\\|_2$, but then allocate the tolerance by forcing the two contributions to be equal, $\\|u^\\star - u_r\\|_2 = \\|u_r - u_r^m\\|_2 = \\varepsilon/2$, regardless of the cost model, because equal splitting minimizes the sum of two positive terms; compute $r$ and $m$ from the algebraic decay of $\\rho_r$ and $\\tau_m$ under this halving rule.**\n- This option correctly starts with the triangle inequality. However, it then proposes a naive `a priori` error balancing scheme ($\\varepsilon/2$ for each term). This heuristic is not optimal because it fails to account for the potentially very different costs of reducing each error component. The justification \"because equal splitting minimizes the sum of two positive terms\" is a non-sequitur; the goal is to minimize cost for a fixed sum of errors, not to minimize the sum of errors itself.\n- **Verdict: Incorrect.**", "answer": "$$\\boxed{A}$$", "id": "3591661"}]}