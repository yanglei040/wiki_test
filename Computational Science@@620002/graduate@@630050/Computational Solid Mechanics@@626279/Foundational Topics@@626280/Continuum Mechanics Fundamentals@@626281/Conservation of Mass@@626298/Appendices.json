{"hands_on_practices": [{"introduction": "This practice bridges the gap between the continuous theory of mass conservation and the discrete world of numerical time integration. While the material time derivative of mass is zero in continuum mechanics, numerical schemes only approximate this. Here, you will derive a second-order explicit predictor-corrector scheme directly from the continuity equation and use it to simulate a deforming body [@problem_id:3550657]. This exercise is invaluable for understanding and quantifying numerical \"mass drift,\" an artifact that can accumulate over time and compromise the physical realism of dynamic simulations.", "problem": "Consider a $1$-dimensional Lagrangian discretization of a deforming bar in computational solid mechanics. Let the bar initially occupy a reference interval of length $L$ with uniform reference partition into $N$ material points, each associated with a reference sub-volume $\\Delta V_0 = L/N$. The initial mass density is uniform and equal to $\\rho_0$ (in $\\mathrm{kg}/\\mathrm{m}^3$). The velocity field is such that the local volumetric strain rate (the divergence of velocity) is spatially uniform and time-dependent, denoted by $s(t)$ (in $\\mathrm{s}^{-1}$), and given by $s(t) = k \\cos(\\omega t)$ where $k$ is a constant (in $\\mathrm{s}^{-1}$) and $\\omega$ is an angular frequency (in $\\mathrm{rad}/\\mathrm{s}$, radians per second).\n\nStarting from the fundamental mass conservation law for any material region, namely that the time derivative of the mass within that region is zero, and using a Lagrangian description, derive a predictor–corrector explicit scheme for the mass density $\\rho$ based solely on the continuity equation expressed in terms of the material time derivative. The derivation must begin from first principles: the integral statement of mass conservation and the definition of the material derivative. Do not assume any target discrete formula a priori. As part of your derivation, define the deformation Jacobian $J$ that maps reference to current volumes, and use the fact that mass conservation in the Lagrangian frame implies the invariance of the product $\\rho J$ under exact time evolution.\n\nIn the discrete algorithm, at each time step $n$, let the adaptive time step $\\Delta t_n$ be governed by the rule\n$$\n\\Delta t_n = \\frac{\\Delta t_{\\max}}{1 + \\gamma \\lvert s(t_n) \\rvert},\n$$\nwhere $\\Delta t_{\\max}$ (in $\\mathrm{s}$) is a user-specified maximum time step, $\\gamma$ (dimensionless) is an adaptivity coefficient, and $t_n$ is the current time. The predictor–corrector scheme must be constructed to second order in time using only values available at $t_n$ and $t_{n+1} = t_n + \\Delta t_n$.\n\nImplement your derived scheme to update both the mass density $\\rho$ and the deformation Jacobian $J$ at each time step, starting from $\\rho(0) = \\rho_0$ and $J(0) = 1$. For a uniform $s(t)$, each material point has identical evolution; however, to compute the total mass, aggregate over the $N$ reference sub-volumes using the current mass per sub-volume $\\rho(t) J(t) \\Delta V_0$. Define the total mass at time $t$ as\n$$\nM(t) = \\sum_{i=1}^{N} \\rho(t) J(t) \\Delta V_0 = \\rho(t) J(t) L,\n$$\nand the initial mass as $M(0) = \\rho_0 L$.\n\nFor each simulation, run until final time $T$ (in $\\mathrm{s}$) and report the mass drift as the dimensionless decimal fraction\n$$\n\\delta = \\frac{M(T) - M(0)}{M(0)}.\n$$\nExpress the output $\\delta$ as a decimal number (no percentage sign). Use the following test suite of parameter values to assess the algorithm under different adaptive time step scenarios. Physical parameters must be interpreted with their indicated units.\n\n- Test case $1$ (general case):\n  - $L = 1.0$ $\\mathrm{m}$,\n  - $N = 100$,\n  - $\\rho_0 = 7800.0$ $\\mathrm{kg}/\\mathrm{m}^3$,\n  - $k = 0.2$ $\\mathrm{s}^{-1}$,\n  - $\\omega = 10.0$ $\\mathrm{rad}/\\mathrm{s}$,\n  - $T = 0.5$ $\\mathrm{s}$,\n  - $\\Delta t_{\\max} = 0.005$ $\\mathrm{s}$,\n  - $\\gamma = 2.0$.\n- Test case $2$ (near-constant time step and near-incompressible evolution):\n  - $L = 1.0$ $\\mathrm{m}$,\n  - $N = 100$,\n  - $\\rho_0 = 7800.0$ $\\mathrm{kg}/\\mathrm{m}^3$,\n  - $k = 0.01$ $\\mathrm{s}^{-1}$,\n  - $\\omega = 5.0$ $\\mathrm{rad}/\\mathrm{s}$,\n  - $T = 0.2$ $\\mathrm{s}$,\n  - $\\Delta t_{\\max} = 0.001$ $\\mathrm{s}$,\n  - $\\gamma = 0.5$.\n- Test case $3$ (strong adaptivity under faster volumetric oscillations):\n  - $L = 1.0$ $\\mathrm{m}$,\n  - $N = 100$,\n  - $\\rho_0 = 7800.0$ $\\mathrm{kg}/\\mathrm{m}^3$,\n  - $k = 0.5$ $\\mathrm{s}^{-1}$,\n  - $\\omega = 30.0$ $\\mathrm{rad}/\\mathrm{s}$,\n  - $T = 0.4$ $\\mathrm{s}$,\n  - $\\Delta t_{\\max} = 0.002$ $\\mathrm{s}$,\n  - $\\gamma = 5.0$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the test cases given, for example, $[\\delta_1,\\delta_2,\\delta_3]$. Each $\\delta_i$ must be the decimal fraction defined above. No other output should be produced. Angle units for $\\omega$ are radians, and all time units are seconds. Length must be in meters and density in kilograms per cubic meter as specified. The solution should be universal and rely only on the stipulated physical laws and definitions, leading to a correct algorithmic implementation for the specified test suite.", "solution": "The problem is assessed to be valid as it is scientifically grounded in the principles of continuum mechanics, is well-posed with a clear objective and sufficient data, and is expressed in objective, formal language. It presents a standard, albeit simplified, problem in computational mechanics that is solvable through the derivation and implementation of a numerical method.\n\nThe derivation of the required numerical scheme proceeds from the fundamental principle of mass conservation.\n\n**1. Derivation of the Governing Differential Equations**\n\nThe law of conservation of mass states that for any arbitrary material volume $\\mathcal{V}(t)$ that moves with the deforming body, its mass is constant over time. The mass $M$ in this volume is given by the integral of the density field $\\rho(\\mathbf{x}, t)$ over the current volume $\\mathcal{V}(t)$:\n$$ M = \\int_{\\mathcal{V}(t)} \\rho(\\mathbf{x}, t) \\, dV $$\nMass conservation implies that the material time derivative of this mass is zero:\n$$ \\frac{dM}{dt} = \\frac{d}{dt} \\int_{\\mathcal{V}(t)} \\rho(\\mathbf{x}, t) \\, dV = 0 $$\nApplying the Reynolds transport theorem to the integral over the time-dependent material volume, we get:\n$$ \\frac{d}{dt} \\int_{\\mathcal{V}(t)} \\rho \\, dV = \\int_{\\mathcal{V}(t)} \\left( \\frac{\\partial \\rho}{\\partial t} + \\nabla \\cdot (\\rho \\mathbf{v}) \\right) dV = 0 $$\nwhere $\\mathbf{v}$ is the velocity field. Since this holds for any arbitrary material volume $\\mathcal{V}(t)$, the integrand must be zero, which yields the continuity equation in its Eulerian form:\n$$ \\frac{\\partial \\rho}{\\partial t} + \\nabla \\cdot (\\rho \\mathbf{v}) = 0 $$\nExpanding the divergence term gives $\\nabla \\cdot (\\rho \\mathbf{v}) = (\\nabla \\rho) \\cdot \\mathbf{v} + \\rho (\\nabla \\cdot \\mathbf{v})$. Substituting this back, we have:\n$$ \\frac{\\partial \\rho}{\\partial t} + (\\nabla \\rho) \\cdot \\mathbf{v} + \\rho (\\nabla \\cdot \\mathbf{v}) = 0 $$\nThe material time derivative of density, which represents the rate of change of density for a material particle, is defined as $\\frac{D\\rho}{Dt} = \\frac{\\partial \\rho}{\\partial t} + \\mathbf{v} \\cdot \\nabla \\rho$. The continuity equation can therefore be written in the Lagrangian frame as:\n$$ \\frac{D\\rho}{Dt} + \\rho (\\nabla \\cdot \\mathbf{v}) = 0 $$\nThe problem specifies that the volumetric strain rate, $\\nabla \\cdot \\mathbf{v}$, is spatially uniform and given by a time-dependent function $s(t) = k \\cos(\\omega t)$. Thus, the governing ordinary differential equation (ODE) for the density of any material point is:\n$$ \\frac{D\\rho}{Dt} = -\\rho(t) s(t) $$\nNext, we introduce the deformation Jacobian, $J$. The Jacobian $J$ is defined as the determinant of the deformation gradient tensor $\\mathbf{F}$, i.e., $J = \\det(\\mathbf{F})$. It provides a measure of the local change in volume, relating a differential volume element in the current configuration, $dV$, to its counterpart in the reference configuration, $dV_0$, via $dV = J dV_0$. The material time derivative of the Jacobian is given by the well-known relation (Liouville's formula):\n$$ \\frac{DJ}{Dt} = J (\\nabla \\cdot \\mathbf{v}) $$\nUsing the given expression for the volumetric strain rate, the governing ODE for the Jacobian is:\n$$ \\frac{DJ}{Dt} = J(t) s(t) $$\nFor the exact continuous solution, the product $\\rho J$ is an invariant. This can be shown by taking its material time derivative:\n$$ \\frac{D(\\rho J)}{Dt} = J \\frac{D\\rho}{Dt} + \\rho \\frac{DJ}{Dt} = J(-\\rho s(t)) + \\rho(J s(t)) = 0 $$\nSince $\\rho(0) = \\rho_0$ and $J(0) = 1$, we have $\\rho(t)J(t) = \\rho_0 J(0) = \\rho_0$ for all time $t$. This signifies that the mass within a material element, $\\rho dV = \\rho J dV_0$, is conserved, as it remains equal to the initial mass $\\rho_0 dV_0$. A numerical scheme may not perfectly preserve this invariant, leading to a \"mass drift\".\n\n**2. Derivation of the Predictor-Corrector Scheme**\n\nWe are tasked to derive a second-order explicit predictor-corrector scheme to solve the two coupled ODEs for $\\rho$ and $J$. We will use Heun's method, a standard second-order scheme. Let us consider a generic first-order ODE, $\\dot{y} = f(t, y)$. The update from time $t_n$ to $t_{n+1} = t_n + \\Delta t_n$ is as follows:\n\n- **Predictor Step:** An initial estimate for $y_{n+1}$ is computed using the forward Euler method. Let this be $y_{n+1}^*$.\n  $$ y_{n+1}^* = y_n + \\Delta t_n f(t_n, y_n) $$\n- **Corrector Step:** The final value $y_{n+1}$ is computed by averaging the slope at the beginning of the interval, $f(t_n, y_n)$, and the slope at the end of the interval, using the predicted value $y_{n+1}^*$. This is equivalent to applying the trapezoidal rule.\n  $$ y_{n+1} = y_n + \\frac{\\Delta t_n}{2} \\left[ f(t_n, y_n) + f(t_{n+1}, y_{n+1}^*) \\right] $$\n\nWe apply this method to our two ODEs.\n\n**For the Jacobian $J$:**\nThe ODE is $\\dot{J} = J s(t)$, so $f(t, J) = J s(t)$.\n- Predictor: $J_{n+1}^* = J_n + \\Delta t_n (J_n s(t_n)) = J_n (1 + \\Delta t_n s(t_n))$.\n- Corrector:\n  $$ J_{n+1} = J_n + \\frac{\\Delta t_n}{2} \\left[ J_n s(t_n) + J_{n+1}^* s(t_{n+1}) \\right] $$\n  $$ J_{n+1} = J_n + \\frac{\\Delta t_n}{2} \\left[ J_n s(t_n) + J_n(1 + \\Delta t_n s(t_n)) s(t_{n+1}) \\right] $$\n  $$ J_{n+1} = J_n \\left( 1 + \\frac{\\Delta t_n}{2} s(t_n) + \\frac{\\Delta t_n}{2} s(t_{n+1}) + \\frac{(\\Delta t_n)^2}{2} s(t_n)s(t_{n+1}) \\right) $$\n  $$ J_{n+1} = J_n \\left( 1 + \\frac{\\Delta t_n}{2} (s(t_n) + s(t_{n+1})) + \\frac{(\\Delta t_n)^2}{2} s(t_n)s(t_{n+1}) \\right) $$\n\n**For the density $\\rho$:**\nThe ODE is $\\dot{\\rho} = -\\rho s(t)$, so $f(t, \\rho) = -\\rho s(t)$.\n- Predictor: $\\rho_{n+1}^* = \\rho_n + \\Delta t_n (-\\rho_n s(t_n)) = \\rho_n (1 - \\Delta t_n s(t_n))$.\n- Corrector:\n  $$ \\rho_{n+1} = \\rho_n + \\frac{\\Delta t_n}{2} \\left[ (-\\rho_n s(t_n)) + (-\\rho_{n+1}^* s(t_{n+1})) \\right] $$\n  $$ \\rho_{n+1} = \\rho_n - \\frac{\\Delta t_n}{2} \\left[ \\rho_n s(t_n) + \\rho_n(1 - \\Delta t_n s(t_n)) s(t_{n+1}) \\right] $$\n  $$ \\rho_{n+1} = \\rho_n \\left( 1 - \\frac{\\Delta t_n}{2} (s(t_n) + s(t_{n+1})) + \\frac{(\\Delta t_n)^2}{2} s(t_n)s(t_{n+1}) \\right) $$\nThese two update formulae constitute the final numerical scheme for both $\\rho$ and $J$.\n\n**3. Numerical Algorithm and Evaluation**\n\nThe simulation proceeds iteratively from $t=0$ to the final time $T$.\n1.  Initialize state variables: $t \\leftarrow 0$, $\\rho \\leftarrow \\rho_0$, $J \\leftarrow 1$.\n2.  Loop while $t < T$:\n    a. Let the current time be $t_n=t$.\n    b. Compute the strain rate $s(t_n) = k \\cos(\\omega t_n)$.\n    c. Calculate the adaptive time step: $\\Delta t_n = \\frac{\\Delta t_{\\max}}{1 + \\gamma \\lvert s(t_n) \\rvert}$.\n    d. To ensure the simulation ends exactly at $T$, if $t_n + \\Delta t_n > T$, adjust the time step to $\\Delta t_n = T - t_n$.\n    e. Calculate the time at the end of the step: $t_{n+1} = t_n + \\Delta t_n$.\n    f. Compute the strain rate at the future time: $s(t_{n+1}) = k \\cos(\\omega t_{n+1})$.\n    g. Update $\\rho$ and $J$ to their values at $t_{n+1}$ using the derived predictor-corrector formulas.\n    h. Update the current time: $t \\leftarrow t_{n+1}$.\n3.  After the loop terminates, the final values are $\\rho(T)$ and $J(T)$.\n4.  The mass drift $\\delta$ is computed. The total mass at time $t$ is $M(t) = \\rho(t) J(t) L$. The initial mass is $M(0) = \\rho_0 L$. The drift is:\n    $$ \\delta = \\frac{M(T) - M(0)}{M(0)} = \\frac{\\rho(T)J(T)L - \\rho_0 L}{\\rho_0 L} = \\frac{\\rho(T)J(T)}{\\rho_0} - 1 $$\n    Note that the parameters $L$ and $N$ are part of the physical conceptualization but do not influence the final value of the dimensionless drift $\\delta$ due to cancellation and the spatial uniformity of the problem.\n\nThe implementation will follow this algorithm for each test case provided.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and implements a predictor-corrector scheme for mass conservation\n    in computational solid mechanics and calculates the numerical mass drift.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1 (general case)\n        {\n            'L': 1.0, 'N': 100, 'rho_0': 7800.0, 'k': 0.2, 'omega': 10.0,\n            'T': 0.5, 'dt_max': 0.005, 'gamma': 2.0\n        },\n        # Test case 2 (near-constant time step and near-incompressible evolution)\n        {\n            'L': 1.0, 'N': 100, 'rho_0': 7800.0, 'k': 0.01, 'omega': 5.0,\n            'T': 0.2, 'dt_max': 0.001, 'gamma': 0.5\n        },\n        # Test case 3 (strong adaptivity under faster volumetric oscillations)\n        {\n            'L': 1.0, 'N': 100, 'rho_0': 7800.0, 'k': 0.5, 'omega': 30.0,\n            'T': 0.4, 'dt_max': 0.002, 'gamma': 5.0\n        },\n    ]\n\n    results = []\n    \n    for params in test_cases:\n        # Extract parameters for the current simulation\n        rho_0 = params['rho_0']\n        k = params['k']\n        omega = params['omega']\n        T = params['T']\n        dt_max = params['dt_max']\n        gamma = params['gamma']\n        \n        # Initialize simulation variables\n        t = 0.0\n        rho = rho_0\n        J = 1.0\n        \n        # Volumetric strain rate function\n        def s(time):\n            return k * np.cos(omega * time)\n            \n        # Set a small epsilon for floating point comparisons with the final time T\n        epsilon = 1e-9\n        \n        # Time-stepping loop\n        while t < T - epsilon:\n            # State at the beginning of the step (t_n)\n            t_n = t\n            rho_n = rho\n            J_n = J\n            \n            s_n = s(t_n)\n            \n            # Calculate adaptive time step\n            dt = dt_max / (1.0 + gamma * np.abs(s_n))\n            \n            # Ensure the final step lands exactly on T\n            if t_n + dt > T:\n                dt = T - t_n\n                \n            t_n_plus_1 = t_n + dt\n            \n            # Strain rate at the end of the step (t_{n+1})\n            s_n_plus_1 = s(t_n_plus_1)\n            \n            # Apply the second-order predictor-corrector (Heun's method) updates\n            common_term_1 = 0.5 * dt * (s_n + s_n_plus_1)\n            common_term_2 = 0.5 * (dt**2) * s_n * s_n_plus_1\n            \n            # Update density\n            rho = rho_n * (1.0 - common_term_1 + common_term_2)\n            \n            # Update Jacobian\n            J = J_n * (1.0 + common_term_1 + common_term_2)\n            \n            # Advance time\n            t = t_n_plus_1\n\n        # Calculate mass drift\n        # The conserved quantity in the exact solution is rho * J.\n        # Initial value: rho_0 * J(0) = rho_0 * 1.0\n        # Final value: rho(T) * J(T)\n        delta = (rho * J - rho_0) / rho_0\n        results.append(delta)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```", "id": "3550657"}, {"introduction": "We now shift our focus from temporal discretization to the subtleties of spatial discretization in the Finite Element Method (FEM). Techniques like selective reduced integration are vital for modeling nearly incompressible materials without numerical locking, but they can introduce their own artifacts. This exercise explores the classic problem of \"hourglassing,\" where a reduced integration scheme fails to detect non-physical deformation modes [@problem_id:3550637]. You will quantify the resulting spurious density variations and see how a method can appear to conserve mass at the element level while producing physically incorrect local behavior, highlighting the need for stabilization techniques.", "problem": "Consider a single two-dimensional bilinear quadrilateral finite element in the reference configuration occupying the unit square with area $A_0 = 1\\,\\mathrm{m}^2$ and unit thickness in meters. Let the four nodes be located at parametric positions $(\\xi,\\eta) \\in \\{-1,1\\} \\times \\{-1,1\\}$, ordered as node $1$ at $(-1,-1)$, node $2$ at $(1,-1)$, node $3$ at $(1,1)$, and node $4$ at $(-1,1)$. Let the nodal volumetric strain values be prescribed as $\\theta_i$ at each node $i=1,\\dots,4$, understood as the best available discrete approximation to the divergence of the displacement field in the small-strain limit. In the small-strain regime, the Jacobian determinant of the deformation gradient satisfies $J \\approx 1 + \\theta$. The conservation of mass states that the current mass density $\\rho$ and the reference mass density $\\rho_0$ satisfy the pointwise relation $\\rho\\,J = \\rho_0$.\n\nIn a mixed finite element formulation with selective reduced integration of the volumetric constraint, the enforcement of $J \\approx 1$ is performed using only the element center $(\\xi,\\eta)=(0,0)$, while the deviatoric response may be integrated with more points. This selective enforcement may admit spurious volumetric modes that do not change the element-average but oscillate locally, potentially creating spurious density variations while preserving the element-average constraint.\n\nYour task is to implement a program that, for a set of given nodal volumetric strain patterns $\\{\\theta_i\\}_{i=1}^4$ for a single bilinear element, performs the following steps based strictly on fundamental principles:\n\n1. Use bilinear shape functions to interpolate the volumetric strain field over the element. Let the bilinear shape functions be\n$$\nN_1(\\xi,\\eta) = \\frac{1}{4}(1-\\xi)(1-\\eta),\\quad\nN_2(\\xi,\\eta) = \\frac{1}{4}(1+\\xi)(1-\\eta),\\quad\nN_3(\\xi,\\eta) = \\frac{1}{4}(1+\\xi)(1+\\eta),\\quad\nN_4(\\xi,\\eta) = \\frac{1}{4}(1-\\xi)(1+\\eta).\n$$\nThe interpolated volumetric strain is\n$$\n\\theta(\\xi,\\eta) = \\sum_{i=1}^4 N_i(\\xi,\\eta)\\,\\theta_i.\n$$\nSet $J(\\xi,\\eta) = 1 + \\theta(\\xi,\\eta)$ and the reference density to be $\\rho_0 = 1000\\,\\mathrm{kg/m^3}$.\n\n2. Define the reduced (one-point) enforcement density $\\rho_{\\mathrm{red}}$ obtained by evaluating the Jacobian determinant at the element center $(\\xi,\\eta)=(0,0)$:\n$$\nJ_c = J(0,0),\\quad \\rho_{\\mathrm{red}} = \\frac{\\rho_0}{J_c}.\n$$\nThis corresponds to enforcing the volumetric constraint using only the center point.\n\n3. Quantify spurious density modes by computing the mass conservation residual at a standard $2\\times 2$ Gauss quadrature set. Use Gauss points $(\\xi_g,\\eta_g)$ with $\\xi_g,\\eta_g\\in\\{-1/\\sqrt{3},\\,1/\\sqrt{3}\\}$ and weights $w_g = 1$ for each point. At each Gauss point, compute\n$$\nr_g^{\\mathrm{red}} = \\rho_{\\mathrm{red}}\\,J(\\xi_g,\\eta_g) - \\rho_0,\n$$\nand the variance of the residuals\n$$\n\\mathrm{Var}_{\\mathrm{red}} = \\frac{1}{4}\\sum_{g=1}^4 \\left(r_g^{\\mathrm{red}} - \\bar{r}^{\\mathrm{red}}\\right)^2,\\quad \\bar{r}^{\\mathrm{red}} = \\frac{1}{4}\\sum_{g=1}^4 r_g^{\\mathrm{red}}.\n$$\nReport also the difference between the reduced enforcement and the full-average:\n$$\n\\Delta J = J_c - \\bar{J},\\quad \\bar{J} = \\frac{1}{4}\\sum_{g=1}^4 J(\\xi_g,\\eta_g).\n$$\nCompute the element mass using the small-strain approximation\n$$\nm_{\\mathrm{red}} = \\sum_{g=1}^4 w_g\\,\\rho_{\\mathrm{red}}\\,J(\\xi_g,\\eta_g)\\,A_0/4,\n$$\nand the mass error\n$$\ne_m^{\\mathrm{red}} = m_{\\mathrm{red}} - \\rho_0\\,A_0.\n$$\nExpress $m_{\\mathrm{red}}$ in $\\mathrm{kg}$ and $e_m^{\\mathrm{red}}$ in $\\mathrm{kg}$.\n\n4. Propose and implement a stabilization that preserves mass while reducing spurious density residuals. Consider the following mass-preserving blending at Gauss points:\n$$\n\\rho_{\\mathrm{stab}}(\\xi_g,\\eta_g) = \\rho_{\\mathrm{red}} + \\beta\\left(\\frac{\\rho_0}{J(\\xi_g,\\eta_g)} - \\frac{\\rho_0}{\\bar{J}}\\right),\n$$\nwhere $\\beta\\in[0,1]$ is a stabilization parameter and $\\bar{J}$ is the $2\\times 2$ Gauss average. Show that this choice preserves element mass, that is,\n$$\n\\sum_{g=1}^4 w_g\\,\\rho_{\\mathrm{stab}}(\\xi_g,\\eta_g)\\,J(\\xi_g,\\eta_g)\\,A_0/4 = \\rho_0\\,A_0,\n$$\nfor any $\\beta\\in[0,1]$, and reduces the residual variance. Implement this with $\\beta=0.75$. Compute\n$$\nr_g^{\\mathrm{stab}} = \\rho_{\\mathrm{stab}}(\\xi_g,\\eta_g)\\,J(\\xi_g,\\eta_g) - \\rho_0,\\quad\n\\mathrm{Var}_{\\mathrm{stab}} = \\frac{1}{4}\\sum_{g=1}^4 \\left(r_g^{\\mathrm{stab}} - \\bar{r}^{\\mathrm{stab}}\\right)^2,\n$$\nand the mass error\n$$\ne_m^{\\mathrm{stab}} = \\sum_{g=1}^4 w_g\\,\\rho_{\\mathrm{stab}}(\\xi_g,\\eta_g)\\,J(\\xi_g,\\eta_g)\\,A_0/4 - \\rho_0\\,A_0.\n$$\n\n5. Use the following test suite of nodal volumetric strain patterns (dimensionless) to evaluate the quantities above. For each case, set the element area $A_0 = 1\\,\\mathrm{m^2}$ and reference density $\\rho_0 = 1000\\,\\mathrm{kg/m^3}$:\n- Case 1 (uniform compression, happy path): $\\theta = [-0.02,-0.02,-0.02,-0.02]$.\n- Case 2 (near-incompressible hourglass, boundary case): $\\theta = [10^{-6},-10^{-6},10^{-6},-10^{-6}]$.\n- Case 3 (moderate hourglass, spurious mode): $\\theta = [0.05,-0.05,0.05,-0.05]$.\n- Case 4 (strong hourglass, edge case within physical plausibility): $\\theta = [0.2,-0.2,0.2,-0.2]$.\n\n6. Final output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case contributes a list with four values:\n$$\n\\left[\\Delta J,\\ \\mathrm{Var}_{\\mathrm{red}},\\ \\mathrm{Var}_{\\mathrm{stab}},\\ e_m^{\\mathrm{red}}\\right].\n$$\nThe first quantity $\\Delta J$ is dimensionless, the variances are in $(\\mathrm{kg/m^3})^2$, and the mass error is in $\\mathrm{kg}$. The final line must be of the form\n$$\n\\big[\\,[d_1,v_{r1},v_{s1},e_{m1}],\\ [d_2,v_{r2},v_{s2},e_{m2}],\\ [d_3,v_{r3},v_{s3},e_{m3}],\\ [d_4,v_{r4},v_{s4},e_{m4}]\\,\\big].\n$$", "solution": "The problem is validated as scientifically sound, well-posed, and self-contained. It addresses a standard topic in computational solid mechanics—spurious modes arising from selective reduced integration in finite element analysis—using established principles and clear definitions. We proceed with the solution.\n\nThe core of the problem is to analyze the consequences of using a one-point quadrature (selective reduced integration) for the volumetric part of the strain energy in a bilinear quadrilateral element, and to evaluate a stabilization technique. The analysis hinges on properties of the bilinear shape functions and their integrals over the reference domain.\n\nThe nodal volumetric strains $\\{\\theta_i\\}_{i=1}^4$ are interpolated over the element using the bilinear shape functions $N_i(\\xi,\\eta)$:\n$$\n\\theta(\\xi,\\eta) = \\sum_{i=1}^4 N_i(\\xi,\\eta)\\,\\theta_i\n$$\nSubstituting the given shape functions and collecting terms yields a polynomial bilinear in $\\xi$ and $\\eta$:\n$$\n\\theta(\\xi,\\eta) = c_0 + c_1\\xi + c_2\\eta + c_3\\xi\\eta\n$$\nwhere the coefficients are linear combinations of the nodal values:\n$c_0 = \\frac{1}{4}(\\theta_1+\\theta_2+\\theta_3+\\theta_4)$\n$c_1 = \\frac{1}{4}(-\\theta_1+\\theta_2+\\theta_3-\\theta_4)$\n$c_2 = \\frac{1}{4}(-\\theta_1-\\theta_2+\\theta_3+\\theta_4)$\n$c_3 = \\frac{1}{4}(\\theta_1-\\theta_2+\\theta_3-\\theta_4)$\n\nThe small-strain approximation for the Jacobian determinant of the deformation gradient is $J(\\xi,\\eta) = 1 + \\theta(\\xi,\\eta)$.\n\nThe reduced-integration scheme evaluates the Jacobian at the element center, $(\\xi,\\eta)=(0,0)$, to define a single, element-wide density.\nThe Jacobian at the center is:\n$$\nJ_c = J(0,0) = 1 + \\theta(0,0) = 1 + c_0\n$$\nThe corresponding reduced-enforcement density, $\\rho_{\\mathrm{red}}$, is constant over the element:\n$$\n\\rho_{\\mathrm{red}} = \\frac{\\rho_0}{J_c} = \\frac{\\rho_0}{1+c_0}\n$$\n\nTo assess the quality of this approximation, we compare it to the average Jacobian, $\\bar{J}$, computed using a standard $2\\times2$ Gauss quadrature rule. The Gauss points are $(\\xi_g, \\eta_g)$ where $\\xi_g, \\eta_g \\in \\{\\pm a\\}$ with $a=1/\\sqrt{3}$, and all weights are $w_g=1$. The average Jacobian is:\n$$\n\\bar{J} = \\frac{1}{4}\\sum_{g=1}^4 w_g J(\\xi_g,\\eta_g) = \\frac{1}{4}\\sum_{g=1}^4 (1 + c_0 + c_1\\xi_g + c_2\\eta_g + c_3\\xi_g\\eta_g)\n$$\nDue to the symmetry of the Gauss points, the sums of terms linear in $\\xi$ or $\\eta$ are zero: $\\sum \\xi_g = 0$ and $\\sum \\eta_g = 0$. For a bilinear quadrilateral element, the $2\\times2$ Gauss rule integrates the term $c_3\\xi\\eta$ exactly to its true average over the element, which is zero. Specifically, $\\sum \\xi_g \\eta_g = a^2 - a^2 - a^2 + a^2 = 0$. Therefore, the sum simplifies to:\n$$\n\\bar{J} = \\frac{1}{4}\\sum_{g=1}^4 (1 + c_0) = \\frac{1}{4} \\cdot 4(1+c_0) = 1+c_0\n$$\nThus, for a bilinear element on an undistorted (rectangular) domain, we find the crucial result that $J_c = \\bar{J}$. This directly implies that the first quantity to be reported, $\\Delta J$, is identically zero for all test cases:\n$$\n\\Delta J = J_c - \\bar{J} = 0\n$$\nThis result is specific to the ideal geometry and bilinear interpolation; for distorted elements, this equality would not hold.\n\nNext, we evaluate the mass conservation residual at each Gauss point $g$ for the reduced scheme:\n$$\nr_g^{\\mathrm{red}} = \\rho_{\\mathrm{red}}\\,J(\\xi_g,\\eta_g) - \\rho_0 = \\frac{\\rho_0}{J_c} J(\\xi_g,\\eta_g) - \\rho_0\n$$\nThe average residual over the element is:\n$$\n\\bar{r}^{\\mathrm{red}} = \\frac{1}{4}\\sum_{g=1}^4 r_g^{\\mathrm{red}} = \\frac{1}{4}\\left(\\frac{\\rho_0}{J_c} \\sum_{g=1}^4 J_g - 4\\rho_0\\right) = \\frac{\\rho_0}{J_c}\\left(\\frac{1}{4}\\sum_{g=1}^4 J_g\\right) - \\rho_0 = \\frac{\\rho_0}{J_c}\\bar{J} - \\rho_0\n$$\nSince $J_c = \\bar{J}$, the average residual is always zero: $\\bar{r}^{\\mathrm{red}} = 0$.\nThe variance of the residuals, which quantifies the spurious oscillations, is then:\n$$\n\\mathrm{Var}_{\\mathrm{red}} = \\frac{1}{4}\\sum_{g=1}^4 (r_g^{\\mathrm{red}} - \\bar{r}^{\\mathrm{red}})^2 = \\frac{1}{4}\\sum_{g=1}^4 (r_g^{\\mathrm{red}})^2\n$$\nSubstituting the expression for $r_g^{\\mathrm{red}}$ and using $J_c=1+c_0$:\n$$\nr_g^{\\mathrm{red}} = \\frac{\\rho_0}{1+c_0} (1+c_0+c_1\\xi_g+c_2\\eta_g+c_3\\xi_g\\eta_g) - \\rho_0 = \\frac{\\rho_0}{1+c_0}(c_1\\xi_g+c_2\\eta_g+c_3\\xi_g\\eta_g)\n$$\nThe variance is calculated by summing the squares of these terms over the four Gauss points. The cross-terms in the squared sum (e.g., $2c_1c_2\\xi_g\\eta_g$) sum to zero over the symmetric Gauss pattern. The final derived formula for the variance is:\n$$\n\\mathrm{Var}_{\\mathrm{red}} = \\left(\\frac{\\rho_0}{1+c_0}\\right)^2 \\left( \\frac{1}{3}(c_1^2+c_2^2) + \\frac{1}{9}c_3^2 \\right)\n$$\nThe total element mass under the reduced scheme is computed by numerical integration:\n$$\nm_{\\mathrm{red}} = \\sum_{g=1}^4 w_g\\,\\rho_{\\mathrm{red}}\\,J(\\xi_g,\\eta_g)\\,\\frac{A_0}{4} = \\frac{A_0}{4} \\rho_{\\mathrm{red}} \\sum_{g=1}^4 J_g = A_0 \\rho_{\\mathrm{red}} \\bar{J}\n$$\nAgain, since $J_c = \\bar{J}$ and $\\rho_{\\mathrm{red}} = \\rho_0/J_c$, the mass is exactly conserved:\n$$\nm_{\\mathrm{red}} = A_0 \\frac{\\rho_0}{J_c} J_c = \\rho_0 A_0\n$$\nTherefore, the mass error is also identically zero: $e_m^{\\mathrm{red}} = m_{\\mathrm{red}} - \\rho_0 A_0 = 0$.\n\nThe proposed stabilization introduces a blended density at each Gauss point:\n$$\n\\rho_{\\mathrm{stab}}(\\xi_g,\\eta_g) = \\rho_{\\mathrm{red}} + \\beta\\left(\\frac{\\rho_0}{J(\\xi_g,\\eta_g)} - \\frac{\\rho_0}{\\bar{J}}\\right)\n$$\nWe can show this scheme is mass-preserving. The stabilized mass is:\n$$\nm_{\\mathrm{stab}} = \\sum_{g=1}^4 w_g\\,\\rho_{\\mathrm{stab}}(g)\\,J(g)\\,\\frac{A_0}{4} = \\frac{A_0}{4} \\sum_{g=1}^4 \\left[\\rho_{\\mathrm{red}} + \\beta\\left(\\frac{\\rho_0}{J_g} - \\frac{\\rho_0}{\\bar{J}}\\right)\\right]J_g\n$$\n$$\nm_{\\mathrm{stab}} = \\frac{A_0}{4} \\left( \\rho_{\\mathrm{red}}\\sum J_g + \\beta\\sum\\left(\\rho_0 - \\frac{\\rho_0 J_g}{\\bar{J}}\\right) \\right) = \\frac{A_0}{4} \\left( 4\\rho_{\\mathrm{red}}\\bar{J} + \\beta\\left(4\\rho_0 - \\frac{\\rho_0}{\\bar{J}}\\sum J_g\\right) \\right)\n$$\n$$\nm_{\\mathrm{stab}} = \\frac{A_0}{4} \\left( 4\\rho_{\\mathrm{red}}\\bar{J} + \\beta\\left(4\\rho_0 - \\frac{\\rho_0}{\\bar{J}}4\\bar{J}\\right) \\right) = A_0 \\rho_{\\mathrm{red}}\\bar{J} = m_{\\mathrm{red}} = \\rho_0 A_0\n$$\nThus, the stabilized mass error $e_m^{\\mathrm{stab}}$ is also zero.\n\nThe stabilized residual at a Gauss point is $r_g^{\\mathrm{stab}} = \\rho_{\\mathrm{stab}}(g)J_g - \\rho_0$. Using the definition of $\\rho_{\\mathrm{stab}}$ and $J_c=\\bar{J}$:\n$$\nr_g^{\\mathrm{stab}} = \\left[\\frac{\\rho_0}{\\bar{J}} + \\beta\\left(\\frac{\\rho_0}{J_g} - \\frac{\\rho_0}{\\bar{J}}\\right)\\right]J_g - \\rho_0 = \\rho_0\\left(\\frac{J_g}{\\bar{J}} + \\beta\\left(1 - \\frac{J_g}{\\bar{J}}\\right) - 1\\right)\n$$\n$$\nr_g^{\\mathrm{stab}} = \\rho_0(1-\\beta)\\left(\\frac{J_g}{\\bar{J}}-1\\right) = (1-\\beta)r_g^{\\mathrm{red}}\n$$\nThis elegant result shows that the stabilization scheme uniformly scales down the local mass residuals by a factor of $(1-\\beta)$. Since the average residual $\\bar{r}^{\\mathrm{red}}$ is zero, so is $\\bar{r}^{\\mathrm{stab}}$. The variance is consequently scaled by $(1-\\beta)^2$:\n$$\n\\mathrm{Var}_{\\mathrm{stab}} = \\frac{1}{4}\\sum_{g=1}^4 (r_g^{\\mathrm{stab}})^2 = (1-\\beta)^2 \\frac{1}{4}\\sum_{g=1}^4 (r_g^{\\mathrm{red}})^2 = (1-\\beta)^2 \\mathrm{Var}_{\\mathrm{red}}\n$$\nWith $\\beta = 0.75$, we have $\\mathrm{Var}_{\\mathrm{stab}} = (0.25)^2 \\mathrm{Var}_{\\mathrm{red}} = 0.0625\\,\\mathrm{Var}_{\\mathrm{red}}$.\n\nThe algorithmic implementation will compute $c_0, c_1, c_2, c_3$ for each test case, then use them in the derived formula for $\\mathrm{Var}_{\\mathrm{red}}$. The other three required outputs, $\\Delta J$, $\\mathrm{Var}_{\\mathrm{stab}}$, and $e_m^{\\mathrm{red}}$, follow directly.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries are required.\n\ndef solve():\n    \"\"\"\n    Solves the computational solid mechanics problem for a set of test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (uniform compression, happy path)\n        [-0.02, -0.02, -0.02, -0.02],\n        # Case 2 (near-incompressible hourglass, boundary case)\n        [1e-6, -1e-6, 1e-6, -1e-6],\n        # Case 3 (moderate hourglass, spurious mode)\n        [0.05, -0.05, 0.05, -0.05],\n        # Case 4 (strong hourglass, edge case)\n        [0.2, -0.2, 0.2, -0.2],\n    ]\n\n    # Global parameters\n    rho_0 = 1000.0  # kg/m^3\n    beta = 0.75     # stabilization parameter\n\n    results = []\n    for theta_nodes in test_cases:\n        t1, t2, t3, t4 = theta_nodes\n\n        # 1. Compute coefficients of the interpolated strain field\n        # theta(xi, eta) = c0 + c1*xi + c2*eta + c3*xi*eta\n        c0 = 0.25 * (t1 + t2 + t3 + t4)\n        c1 = 0.25 * (-t1 + t2 + t3 - t4)\n        c2 = 0.25 * (-t1 - t2 + t3 + t4)\n        c3 = 0.25 * (t1 - t2 + t3 - t4)\n\n        # 2. Compute J_c and Bar(J) and their difference Delta_J\n        # For a bilinear quad on a rectangular domain, J_c = Bar(J), so Delta_J = 0.\n        J_c = 1.0 + c0\n        delta_J = 0.0\n\n        # 3. Compute the variance of the residuals for the reduced scheme.\n        # Var_red = (rho_0 / J_c)^2 * ( (1/3)*(c1^2 + c2^2) + (1/9)*c3^2 )\n        # This is derived in the solution text.\n        if np.isclose(J_c, 0):\n            # Avoid division by zero, though not expected in these test cases.\n            var_red = float('inf')\n        else:\n            factor = (rho_0 / J_c)**2\n            term = (1.0/3.0) * (c1**2 + c2**2) + (1.0/9.0) * (c3**2)\n            var_red = factor * term\n\n        # 4. Compute the mass error for the reduced scheme.\n        # As derived, for this specific problem setup, the mass error is zero.\n        e_m_red = 0.0\n\n        # 5. Compute the variance for the stabilized scheme.\n        # Var_stab = (1 - beta)^2 * Var_red\n        var_stab = (1.0 - beta)**2 * var_red\n        \n        # Store the results for this case.\n        results.append([delta_J, var_red, var_stab, e_m_red])\n\n    # Format the final output string as specified.\n    # [[d1,vr1,vs1,em1], [d2,vr2,vs2,em2], ...]\n    case_strings = []\n    for res in results:\n        # Format each number in the sublist\n        num_strings = [f\"{val:.12g}\" for val in res]\n        # Join numbers into a sublist string \"[n1,n2,n3,n4]\"\n        case_strings.append(f\"[{','.join(num_strings)}]\")\n    \n    # Join all case strings into the final output string\n    final_output = f\"[{','.join(case_strings)}]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "3550637"}, {"introduction": "This final practice addresses an advanced topic: maintaining mass conservation when the computational mesh undergoes topological changes, such as in simulations of fracture or surgical cutting. Naively modifying the mesh can easily lead to the artificial creation or destruction of mass, violating a fundamental physical law. This exercise guides you through the implementation of a conservative cutting algorithm that splits elements and repartitions mass rigorously [@problem_id:3550666]. The key insight you will apply is that all geometric and mass calculations must be performed in the material's undeformed reference configuration, where the mass measure is originally defined and remains invariant.", "problem": "You are given a two-dimensional thin solid discretized by linear triangular elements for use in the Finite Element Method (FEM). The reference configuration is a square domain discretized into a structured mesh. The material has constant reference mass density $\\rho_0$ and constant thickness $t$. The conservation of mass states that the total mass is invariant under any internal topological change such as cutting, provided the reference mass measure is used. Your task is to implement a conservative surgical cutting operation that splits intersected elements by a prescribed cut polyline and repartitions nodal lumped masses so that the sum of nodal masses remains equal to the original total mass. The cut is given in the current (possibly deformed) configuration; to conserve mass, you must perform intersections and area computations strictly in the reference configuration.\n\nFundamental base to use:\n- The conservation of mass implies that the mass of each material element is constant and equals the reference density times the reference volume. For a thin plane-stress solid, the element mass is $m_e = \\rho_0 \\, t \\, A_0$, where $A_0$ is the element area in the reference configuration, $\\rho_0$ is the reference density, and $t$ is the thickness.\n- For a linear triangular element, the row-sum lumping of the consistent mass matrix yields equal mass contribution to each vertex; that is, the lumped mass contributed from one element to each of its three vertices is $m_e / 3$.\n- Under a homogeneous deformation gradient $\\mathbf{F}$, the Jacobian $J = \\det \\mathbf{F}$ relates current and reference measures via $\\rho \\, J = \\rho_0$, but the conserved mass measure for computation is $m_e = \\rho_0 \\, t \\, A_0$, which is independent of $\\mathbf{F}$.\n\nCutting model to implement:\n- Cutting is defined by a polyline in the current configuration. For mass-conservative splitting, map every polyline vertex $\\mathbf{x}$ in the current configuration to the reference configuration via $\\mathbf{X} = \\mathbf{F}^{-1} \\mathbf{x}$ for a given homogeneous deformation gradient $\\mathbf{F}$. For cases with the identity deformation, $\\mathbf{F} = \\mathbf{I}$, the cut polyline is already in the reference configuration.\n- Perform the splitting in the reference configuration. For each cut segment, for each triangle:\n  - Compute the intersections of the segment with the three triangle edges. Consider a proper intersection only if it occurs strictly inside both the segment and the edge (exclude endpoints within a tolerance) and the segment is not collinear with the edge.\n  - If there are exactly two proper intersections, they must lie on two distinct edges of the triangle that share a vertex. Let the shared vertex be $\\mathbf{V}$, let $\\mathbf{P}$ lie on edge $(\\mathbf{V}, \\mathbf{V}_1)$ and $\\mathbf{Q}$ lie on edge $(\\mathbf{V}, \\mathbf{V}_2)$. Replace the triangle by three sub-triangles: $(\\mathbf{V}, \\mathbf{P}, \\mathbf{Q})$, $(\\mathbf{V}_1, \\mathbf{P}, \\mathbf{Q})$, and $(\\mathbf{V}_1, \\mathbf{Q}, \\mathbf{V}_2)$. This partition conserves the area exactly in the reference configuration.\n  - If there are fewer than two proper intersections, or the segment is collinear with a triangle edge, do not split the triangle.\n- Process the polyline by applying the above procedure segment-by-segment, updating the mesh after each segment.\n\nNodal mass repartitioning:\n- After performing all cuts and subdividing triangles, compute the new lumped nodal masses by summing, for each sub-triangle, the quantity $\\rho_0 \\, t \\, A_{0,\\text{sub}} / 3$ into each of its three vertices (including any newly created nodes).\n- The sum of the new nodal masses must equal the original total mass computed from the initial mesh. All computations must use the reference configuration areas.\n\nMesh, material, and test suite:\n- Reference domain: the unit square $[0,1] \\times [0,1]$ discretized into a structured mesh of $N_x \\times N_y$ square cells, each split into two triangles by the diagonal from lower-left to upper-right. Use $N_x = 3$ and $N_y = 3$, so that there are $(N_x+1)(N_y+1) = 16$ nodes and $2 N_x N_y = 18$ triangles.\n- Reference mass density: $\\rho_0 = 7800 \\,\\text{kg/m}^3$.\n- Thickness: $t = 0.01 \\,\\text{m}$.\n- Deformation gradient for the high-deformation test: \n  $$\\mathbf{F} = \\begin{bmatrix} 1.8 & 0.9 \\\\ 0.2 & 0.7 \\end{bmatrix},$$\n  which has determinant $J = 1.08$.\n- Define three test cases, each consisting of a cut polyline in the current configuration and a deformation gradient $\\mathbf{F}$:\n  1. Happy path: horizontal cut across the domain without deformation. Use $\\mathbf{F} = \\mathbf{I}$ and the polyline with vertices $\\{(-0.2, 0.5), (1.2, 0.5)\\}$.\n  2. Boundary condition: cut along an existing mesh edge so that many segments are collinear with triangle edges; this should result in no splitting. Use $\\mathbf{F} = \\mathbf{I}$ and the polyline with vertices $\\{(0, 0), (1, 1)\\}$.\n  3. High deformation with complex cut: use the above $\\mathbf{F}$ and a polyline in the current configuration with vertices $\\{(-0.2, 0.2), (0.3, 0.6), (0.7, 0.4), (1.2, 0.8)\\}$. For this case, map the polyline to the reference configuration using $\\mathbf{F}^{-1}$ before performing any splitting.\n\nRequired outputs and units:\n- For each test case, compute the absolute discrepancy between the pre-cut total mass and the post-cut sum of nodal masses, both in kilograms. Express each discrepancy in $\\text{kg}$ as a decimal float rounded to $12$ decimal places.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $\"[a,b,c]\"$), where $a$, $b$, and $c$ are the discrepancies for test cases $1$, $2$, and $3$, respectively, each rounded to $12$ decimal places in $\\text{kg}$.\n\nScientific realism and constraints:\n- All intersections and area computations must be performed in the reference configuration to ensure exact conservation of the reference mass measure under cutting.\n- Intersection handling must exclude degenerate intersections at vertices and collinear overlaps; only triangles with exactly two proper edge intersections are to be split.\n- The algorithm must be deterministic and self-contained. No user input is allowed.", "solution": "The user-provided problem is valid as it is scientifically grounded in the principle of mass conservation, mathematically well-posed with a clear and deterministic algorithm, and objectively stated. It presents a standard procedure in computational mechanics for handling topological changes like cuts while preserving total mass.\n\nThe solution proceeds by implementing the specified cutting and mass-repartitioning algorithm. For each test case, we perform the following steps:\n\n1.  **Mesh and Mass Initialization**: A structured mesh of linear triangular elements is generated for the reference unit square domain $[0,1] \\times [0,1]$. The domain is discretized into a $3 \\times 3$ grid of cells, with each cell subdivided into two triangles, resulting in $16$ nodes and $18$ triangles. The total mass of this initial configuration is computed using the given reference density $\\rho_0 = 7800 \\,\\text{kg/m}^3$ and thickness $t = 0.01 \\,\\text{m}$. The mass of a single element is $m_e = \\rho_0 \\, t \\, A_0$, where $A_0$ is the element's area in the reference configuration. The total initial mass, $M_{\\text{pre}}$, is the sum of all element masses. This value serves as the benchmark for mass conservation.\n\n2.  **Cut Polyline Transformation**: Each test case provides a cutting polyline defined by vertices in the current (possibly deformed) configuration and an associated homogeneous deformation gradient $\\mathbf{F}$. To ensure mass is conserved with respect to the reference measure, all geometric operations (intersections, area calculations) must occur in the reference configuration. Therefore, each vertex $\\mathbf{x}$ of the given polyline is mapped to its corresponding reference position $\\mathbf{X}$ via the transformation $\\mathbf{X} = \\mathbf{F}^{-1} \\mathbf{x}$. If the deformation is identity ($\\mathbf{F}=\\mathbf{I}$), the polyline is already in the reference configuration.\n\n3.  **Iterative Mesh Cutting**: The algorithm iterates through each segment of the reference-mapped polyline. For each segment, it iterates through all triangles in the current state of the mesh.\n    *   **Intersection Detection**: A line segment intersection routine is used to find all \"proper\" intersections between the cutting segment and the three edges of a triangle. A proper intersection is defined as one that occurs strictly inside both the cutting segment and the triangle edge, with a numerical tolerance to exclude endpoints and vertices. Cases where the segment is collinear with an edge are also excluded.\n    *   **Splitting Criterion**: A triangle is marked for splitting if and only if the cutting segment creates exactly two proper intersections with its edges. These two intersections must lie on two distinct edges that share a common vertex.\n    *   **Triangle Subdivision**: If a triangle $(\\mathbf{V}, \\mathbf{V}_1, \\mathbf{V}_2)$ is split, with intersection point $\\mathbf{P}$ on edge $(\\mathbf{V}, \\mathbf{V}_1)$ and $\\mathbf{Q}$ on edge $(\\mathbf{V}, \\mathbf{V}_2)$, it is replaced by three new sub-triangles as specified: $(\\mathbf{V}, \\mathbf{P}, \\mathbf{Q})$, $(\\mathbf{V}_1, \\mathbf{P}, \\mathbf{Q})$, and $(\\mathbf{V}_1, \\mathbf{Q}, \\mathbf{V}_2)$. This subdivision partitions the area of the original triangle exactly. The new intersection points $\\mathbf{P}$ and $\\mathbf{Q}$ are added to the global list of nodes. A map is used to ensure that new nodes created at the same geometric location are represented by a single node index, preserving mesh topology.\n    *   **Mesh Update**: After checking all triangles against a single cutting segment, the mesh is updated. The original triangles that were split are removed, and the newly generated sub-triangles are added to the mesh's element list. This updated mesh is then used for processing the next cutting segment.\n\n4.  **Post-Cut Mass Calculation and Discrepancy**: After all segments of the polyline have been processed, a final mesh topology is obtained. The post-cut total mass, $M_{\\text{post}}$, is calculated by summing the contributions from all triangles in this final mesh. For each sub-triangle with reference area $A_{0,\\text{sub}}$, its mass $m_{\\text{sub}} = \\rho_0 \\, t \\, A_{0,\\text{sub}}$ is computed and distributed equally to its three vertices (lumped mass), i.e., $m_{\\text{sub}}/3$ per node. The sum of all nodal masses gives $M_{\\text{post}}$.\n\n5.  **Final Result**: The absolute discrepancy, $|M_{\\text{post}} - M_{\\text{pre}}|$, is computed for each test case. Due to the exact nature of the area-preserving subdivision in the reference frame, this discrepancy is expected to be zero, within the limits of floating-point precision. The final output is a list of these discrepancies, formatted to $12$ decimal places.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# A small tolerance for floating-point comparisons and geometric checks.\nTOL = 1e-9\n\ndef triangle_area(p1, p2, p3):\n    \"\"\"Computes the area of a triangle defined by three 2D points.\"\"\"\n    return 0.5 * abs(p1[0]*(p2[1]-p3[1]) + p2[0]*(p3[1]-p1[1]) + p3[0]*(p1[1]-p2[1]))\n\ndef find_segment_intersection(seg1_p1, seg1_p2, seg2_p1, seg2_p2):\n    \"\"\"\n    Finds the intersection of two line segments.\n    Returns the intersection point if it's a \"proper\" intersection, otherwise None.\n    A proper intersection occurs strictly inside both segments.\n    \"\"\"\n    r = seg1_p2 - seg1_p1\n    s = seg2_p2 - seg2_p1\n    q_minus_p = seg2_p1 - seg1_p1\n\n    denom = np.cross(r, s)\n    \n    # If denominator is close to zero, segments are parallel or collinear.\n    if abs(denom) < TOL:\n        return None\n        \n    u = np.cross(q_minus_p, s) / denom\n    v = np.cross(q_minus_p, r) / denom\n    \n    # A proper intersection must be strictly within both segments.\n    if TOL < u < 1.0 - TOL and TOL < v < 1.0 - TOL:\n        intersection_point = seg1_p1 + u * r\n        return intersection_point\n        \n    return None\n\nclass MeshCutter:\n    \"\"\"\n    Manages the mesh, cutting operations, and mass calculations.\n    \"\"\"\n    def __init__(self, Nx, Ny, rho0, t):\n        self.Nx = Nx\n        self.Ny = Ny\n        self.rho0 = rho0\n        self.t = t\n        self.nodes_orig = None\n        self.triangles_orig = None\n        self._generate_initial_mesh()\n        self.pre_cut_mass = self._calculate_total_mass(self.nodes_orig, self.triangles_orig)\n        \n        self.nodes = None\n        self.triangles = None\n\n    def _generate_initial_mesh(self):\n        \"\"\"Generates the initial structured triangular mesh on the unit square.\"\"\"\n        x = np.linspace(0, 1, self.Nx + 1)\n        y = np.linspace(0, 1, self.Ny + 1)\n        xv, yv = np.meshgrid(x, y)\n        self.nodes_orig = [np.array(p) for p in zip(xv.flatten(), yv.flatten())]\n        \n        self.triangles_orig = []\n        for j in range(self.Ny):\n            for i in range(self.Nx):\n                n00 = j * (self.Nx + 1) + i\n                n10 = j * (self.Nx + 1) + (i + 1)\n                n01 = (j + 1) * (self.Nx + 1) + i\n                n11 = (j + 1) * (self.Nx + 1) + (i + 1)\n                \n                self.triangles_orig.append([n00, n10, n11])\n                self.triangles_orig.append([n00, n11, n01])\n\n    def _calculate_total_mass(self, nodes, triangles):\n        \"\"\"Calculates the total mass of the mesh based on lumped nodal contributions.\"\"\"\n        if not nodes or not triangles:\n            return 0.0\n            \n        nodal_masses = np.zeros(len(nodes))\n        for tri_indices in triangles:\n            p1, p2, p3 = [nodes[i] for i in tri_indices]\n            area = triangle_area(p1, p2, p3)\n            mass_per_element = self.rho0 * self.t * area\n            lumped_mass_per_node = mass_per_element / 3.0\n            for idx in tri_indices:\n                nodal_masses[idx] += lumped_mass_per_node\n        return np.sum(nodal_masses)\n\n    def run_case(self, polyline_current, F_matrix):\n        \"\"\"Runs a single cutting test case.\"\"\"\n        self.nodes = self.nodes_orig[:]\n        self.triangles = [tri[:] for tri in self.triangles_orig]\n\n        if not np.allclose(F_matrix, np.identity(2)):\n            F_inv = np.linalg.inv(F_matrix)\n            ref_polyline = [F_inv @ p for p in polyline_current]\n        else:\n            ref_polyline = polyline_current\n\n        node_map = {tuple(np.round(n, 12)): i for i, n in enumerate(self.nodes)}\n\n        def get_or_add_node(p):\n            p_tuple = tuple(np.round(p, 12))\n            if p_tuple in node_map:\n                return node_map[p_tuple]\n            \n            new_idx = len(self.nodes)\n            self.nodes.append(p)\n            node_map[p_tuple] = new_idx\n            return new_idx\n\n        for i_seg in range(len(ref_polyline) - 1):\n            seg_p1, seg_p2 = ref_polyline[i_seg], ref_polyline[i_seg + 1]\n            \n            newly_created_triangles = []\n            triangles_to_remove_indices = set()\n\n            for i_tri, tri_indices in enumerate(self.triangles):\n                tri_coords = [self.nodes[idx] for idx in tri_indices]\n                \n                intersections = []\n                for j in range(3):\n                    edge_p1_idx, edge_p2_idx = tri_indices[j], tri_indices[(j + 1) % 3]\n                    edge_p1, edge_p2 = tri_coords[j], tri_coords[(j + 1) % 3]\n                    \n                    intersection_pt = find_segment_intersection(seg_p1, seg_p2, edge_p1, edge_p2)\n                    \n                    if intersection_pt is not None:\n                        is_duplicate = any(np.allclose(intersection_pt, existing_pt[1]) for existing_pt in intersections)\n                        if not is_duplicate:\n                            intersections.append(((edge_p1_idx, edge_p2_idx), intersection_pt))\n\n                if len(intersections) == 2:\n                    edge1_indices, P = intersections[0]\n                    edge2_indices, Q = intersections[1]\n\n                    shared_v_idx_set = set(edge1_indices) & set(edge2_indices)\n                    if not shared_v_idx_set:\n                        continue\n                    \n                    V_idx = shared_v_idx_set.pop()\n                    V1_idx = (set(edge1_indices) - {V_idx}).pop()\n                    V2_idx = (set(edge2_indices) - {V_idx}).pop()\n\n                    P_idx = get_or_add_node(P)\n                    Q_idx = get_or_add_node(Q)\n                    \n                    newly_created_triangles.append([V_idx, P_idx, Q_idx])\n                    newly_created_triangles.append([V1_idx, P_idx, Q_idx])\n                    newly_created_triangles.append([V1_idx, Q_idx, V2_idx])\n                    \n                    triangles_to_remove_indices.add(i_tri)\n\n            if triangles_to_remove_indices:\n                self.triangles = [tri for i, tri in enumerate(self.triangles) if i not in triangles_to_remove_indices]\n                self.triangles.extend(newly_created_triangles)\n\n        post_cut_mass = self._calculate_total_mass(self.nodes, self.triangles)\n        discrepancy = abs(post_cut_mass - self.pre_cut_mass)\n        return discrepancy\n\ndef solve():\n    RHO_0 = 7800.0\n    THICKNESS = 0.01\n\n    F_I = np.identity(2)\n    F_high = np.array([[1.8, 0.9], [0.2, 0.7]])\n\n    cut1 = [np.array([-0.2, 0.5]), np.array([1.2, 0.5])]\n    cut2 = [np.array([0.0, 0.0]), np.array([1.0, 1.0])]\n    cut3 = [np.array([-0.2, 0.2]), np.array([0.3, 0.6]), np.array([0.7, 0.4]), np.array([1.2, 0.8])]\n\n    test_cases = [\n        (cut1, F_I),\n        (cut2, F_I),\n        (cut3, F_high)\n    ]\n\n    results = []\n    \n    cutter = MeshCutter(Nx=3, Ny=3, rho0=RHO_0, t=THICKNESS)\n    for polyline, F in test_cases:\n        discrepancy = cutter.run_case(polyline, F)\n        results.append(discrepancy)\n\n    formatted_results = [\"{:.12f}\".format(r) for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3550666"}]}