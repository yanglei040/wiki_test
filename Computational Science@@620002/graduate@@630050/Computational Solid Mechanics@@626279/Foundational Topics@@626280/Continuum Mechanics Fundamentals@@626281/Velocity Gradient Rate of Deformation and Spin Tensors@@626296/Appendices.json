{"hands_on_practices": [{"introduction": "The first step in applying continuum mechanics concepts within a computational framework is understanding how continuous fields and their gradients are represented discretely. This exercise [@problem_id:3609150] guides you through the fundamental process of deriving the discrete velocity gradient operator, $\\mathbf{L}$, for a standard finite element. By connecting nodal velocities to the tensor field at a point via shape functions and the isoparametric mapping, you will solidify your understanding of how the rate of deformation, $\\mathbf{D}$, and spin, $\\mathbf{W}$, are calculated in practice within a finite element simulation.", "problem": "Consider a three-dimensional, isoparametric, trilinear (Q1) hexahedral finite element with eight nodes and parent (reference) coordinates $\\left(\\xi,\\eta,\\zeta\\right)\\in[-1,1]^3$. The physical element is an orthogonal rectangular brick centered at $\\left(x_c,y_c,z_c\\right)$ with edge lengths $L_x$, $L_y$, and $L_z$ aligned with the Cartesian axes. The isoparametric mapping is given by $x = x_c + \\frac{L_x}{2}\\,\\xi$, $y = y_c + \\frac{L_y}{2}\\,\\eta$, and $z = z_c + \\frac{L_z}{2}\\,\\zeta$, and the trilinear shape functions at node $a$ are $N_a(\\xi,\\eta,\\zeta) = \\frac{1}{8}\\left(1+\\xi\\,\\xi_a\\right)\\left(1+\\eta\\,\\eta_a\\right)\\left(1+\\zeta\\,\\zeta_a\\right)$, where $\\left(\\xi_a,\\eta_a,\\zeta_a\\right)\\in\\{-1,1\\}^3$ denotes the node’s parent-space signs.\n\nA spatial velocity field inside the element is interpolated as $\\mathbf{v}(\\mathbf{x})=\\sum_{a=1}^{8} N_a(\\mathbf{x})\\,\\mathbf{v}_a$, where $\\mathbf{v}_a$ are the nodal velocities. The velocity gradient tensor is defined as $L_{ij} = v_{i,j}$, where $v_{i,j}=\\frac{\\partial v_i}{\\partial x_j}$. The rate of deformation tensor is defined as $\\mathbf{D} = \\frac{1}{2}\\left(\\mathbf{L} + \\mathbf{L}^{\\mathsf{T}}\\right)$, and the spin tensor is defined as $\\mathbf{W} = \\frac{1}{2}\\left(\\mathbf{L} - \\mathbf{L}^{\\mathsf{T}}\\right)$.\n\nTasks:\n1) Starting only from the definitions above, and using the chain rule for the isoparametric mapping, derive the discrete gradient operator at the element center $\\left(\\xi,\\eta,\\zeta\\right)=(0,0,0)$ that maps the stacked nodal velocity vector to the velocity gradient tensor $\\mathbf{L}$. Express your result in terms of the gradients $\\nabla N_a$ evaluated at the element center, and provide the explicit expression of $\\nabla N_a$ in physical coordinates at the center in terms of $L_x$, $L_y$, $L_z$, and the node signs $\\left(\\xi_a,\\eta_a,\\zeta_a\\right)$.\n\n2) The element is subjected to a homogeneous simple shear with constant shear rate $\\kappa$ such that the underlying continuum velocity field is $\\mathbf{v}(\\mathbf{x})=\\left[\\kappa\\,y,\\,0,\\,0\\right]^{\\mathsf{T}}$. Impose this field exactly at the nodes, i.e., $\\mathbf{v}_a=\\left[\\kappa\\,y_a,\\,0,\\,0\\right]^{\\mathsf{T}}$, where $y_a = y_c + \\frac{L_y}{2}\\,\\eta_a$. Using your discrete gradient operator, compute the velocity gradient tensor $\\mathbf{L}$, the rate of deformation tensor $\\mathbf{D}$, and the spin tensor $\\mathbf{W}$ at the element center.\n\nAnswer specification:\n- Provide the final answer as a single row matrix that concatenates the entries of $\\mathbf{L}$, $\\mathbf{D}$, and $\\mathbf{W}$ in row-major order, i.e., $\\left[L_{11},L_{12},\\dots,L_{33},D_{11},\\dots,D_{33},W_{11},\\dots,W_{33}\\right]$.\n- Express the entries symbolically in terms of $\\kappa$.\n- The unit of each entry is $\\mathrm{s}^{-1}$; do not include units in the final boxed answer.\n- No rounding is required.", "solution": "The problem statement has been validated and is determined to be a valid, self-contained, and well-posed problem in the field of computational solid mechanics.\n\nThe objective is to compute the velocity gradient tensor $\\mathbf{L}$, the rate of deformation tensor $\\mathbf{D}$, and the spin tensor $\\mathbf{W}$ at the center of a trilinear hexahedral element under a specific velocity field.\n\n### Part 1: Derivation of the Discrete Gradient Operator\n\nThe velocity field $\\mathbf{v}$ is interpolated from the nodal velocities $\\mathbf{v}_a$ using the shape functions $N_a$:\n$$ \\mathbf{v}(\\mathbf{x}) = \\sum_{a=1}^{8} N_a(\\mathbf{x})\\,\\mathbf{v}_a $$\nThe velocity gradient tensor is defined as $L_{ij} = \\frac{\\partial v_i}{\\partial x_j}$. The shape functions $N_a$ are given in terms of parent coordinates $\\boldsymbol{\\xi} = (\\xi, \\eta, \\zeta)$, while the gradient is with respect to physical coordinates $\\mathbf{x} = (x, y, z)$. Therefore, the chain rule must be applied. The gradient of any function $f$ in physical coordinates is related to its gradient in parent coordinates by:\n$$ \\nabla_{\\mathbf{x}} f = \\mathbf{J}^{-\\mathsf{T}} \\nabla_{\\boldsymbol{\\xi}} f $$\nwhere $\\mathbf{J}$ is the Jacobian matrix of the isoparametric mapping $\\mathbf{x}(\\boldsymbol{\\xi})$. The components of $\\mathbf{J}$ are $J_{ij} = \\frac{\\partial x_i}{\\partial \\xi_j}$.\n\nThe given mapping is:\n$x = x_c + \\frac{L_x}{2}\\,\\xi$\n$y = y_c + \\frac{L_y}{2}\\,\\eta$\n$z = z_c + \\frac{L_z}{2}\\,\\zeta$\n\nThe Jacobian matrix $\\mathbf{J}$ is calculated as:\n$$\n\\mathbf{J} = \\begin{pmatrix}\n\\frac{\\partial x}{\\partial \\xi} & \\frac{\\partial x}{\\partial \\eta} & \\frac{\\partial x}{\\partial \\zeta} \\\\\n\\frac{\\partial y}{\\partial \\xi} & \\frac{\\partial y}{\\partial \\eta} & \\frac{\\partial y}{\\partial \\zeta} \\\\\n\\frac{\\partial z}{\\partial \\xi} & \\frac{\\partial z}{\\partial \\eta} & \\frac{\\partial z}{\\partial \\zeta}\n\\end{pmatrix}\n= \\begin{pmatrix}\n\\frac{L_x}{2} & 0 & 0 \\\\\n0 & \\frac{L_y}{2} & 0 \\\\\n0 & 0 & \\frac{L_z}{2}\n\\end{pmatrix}\n$$\nThis Jacobian is constant throughout the element. Its inverse is:\n$$\n\\mathbf{J}^{-1} = \\begin{pmatrix}\n\\frac{2}{L_x} & 0 & 0 \\\\\n0 & \\frac{2}{L_y} & 0 \\\\\n0 & 0 & \\frac{2}{L_z}\n\\end{pmatrix}\n$$\nSince $\\mathbf{J}$ is diagonal, its transpose is itself, so $\\mathbf{J}^{-\\mathsf{T}} = \\mathbf{J}^{-1}$.\n\nThe gradient of the $i$-th velocity component $v_i = \\sum_{a=1}^{8} N_a v_{ia}$ is:\n$$ \\nabla_{\\mathbf{x}} v_i = \\sum_{a=1}^{8} (\\nabla_{\\mathbf{x}} N_a) v_{ia} $$\nwhere $v_{ia}$ is the $i$-th component of the nodal velocity vector $\\mathbf{v}_a$. The gradient of the shape function in physical coordinates is $\\nabla_{\\mathbf{x}} N_a = \\mathbf{J}^{-\\mathsf{T}} \\nabla_{\\boldsymbol{\\xi}} N_a$.\nThe velocity gradient tensor components are then given by:\n$$ L_{ij} = \\frac{\\partial v_i}{\\partial x_j} = \\left( \\nabla_{\\mathbf{x}} v_i \\right)_j = \\sum_{a=1}^{8} \\left( \\nabla_{\\mathbf{x}} N_a \\right)_j v_{ia} = \\sum_{a=1}^{8} \\frac{\\partial N_a}{\\partial x_j} v_{ia} $$\nThis is the discrete gradient operator.\n\nTo find the explicit expression for $\\nabla_{\\mathbf{x}} N_a$ at the element center $(\\xi, \\eta, \\zeta) = (0,0,0)$, we first compute the gradient of $N_a$ in parent coordinates:\n$$ N_a(\\xi,\\eta,\\zeta) = \\frac{1}{8}\\left(1+\\xi\\,\\xi_a\\right)\\left(1+\\eta\\,\\eta_a\\right)\\left(1+\\zeta\\,\\zeta_a\\right) $$\nThe partial derivatives are:\n$$ \\frac{\\partial N_a}{\\partial \\xi} = \\frac{1}{8}\\xi_a\\left(1+\\eta\\,\\eta_a\\right)\\left(1+\\zeta\\,\\zeta_a\\right) $$\n$$ \\frac{\\partial N_a}{\\partial \\eta} = \\frac{1}{8}\\eta_a\\left(1+\\xi\\,\\xi_a\\right)\\left(1+\\zeta\\,\\zeta_a\\right) $$\n$$ \\frac{\\partial N_a}{\\partial \\zeta} = \\frac{1}{8}\\zeta_a\\left(1+\\xi\\,\\xi_a\\right)\\left(1+\\eta\\,\\eta_a\\right) $$\nEvaluating at the center $(\\xi, \\eta, \\zeta) = (0,0,0)$:\n$$ \\left.\\frac{\\partial N_a}{\\partial \\xi}\\right|_{(0,0,0)} = \\frac{\\xi_a}{8}, \\quad \\left.\\frac{\\partial N_a}{\\partial \\eta}\\right|_{(0,0,0)} = \\frac{\\eta_a}{8}, \\quad \\left.\\frac{\\partial N_a}{\\partial \\zeta}\\right|_{(0,0,0)} = \\frac{\\zeta_a}{8} $$\nSo, $\\left.\\nabla_{\\boldsymbol{\\xi}} N_a\\right|_{(0,0,0)} = \\frac{1}{8} \\begin{pmatrix} \\xi_a & \\eta_a & \\zeta_a \\end{pmatrix}^{\\mathsf{T}}$.\nNow, we transform this to physical coordinates:\n$$ \\left.\\nabla_{\\mathbf{x}} N_a\\right|_{(0,0,0)} = \\mathbf{J}^{-1} \\left.\\nabla_{\\boldsymbol{\\xi}} N_a\\right|_{(0,0,0)} = \\begin{pmatrix} \\frac{2}{L_x} & 0 & 0 \\\\ 0 & \\frac{2}{L_y} & 0 \\\\ 0 & 0 & \\frac{2}{L_z} \\end{pmatrix} \\frac{1}{8} \\begin{pmatrix} \\xi_a \\\\ \\eta_a \\\\ \\zeta_a \\end{pmatrix} = \\frac{1}{4} \\begin{pmatrix} \\xi_a/L_x \\\\ \\eta_a/L_y \\\\ \\zeta_a/L_z \\end{pmatrix} $$\nThis completes the first task.\n\n### Part 2: Computation for Simple Shear\n\nThe nodal velocities are given by $\\mathbf{v}_a = [\\kappa\\,y_a, 0, 0]^{\\mathsf{T}}$, where $y_a = y_c + \\frac{L_y}{2}\\eta_a$. Thus, $v_{1a} = \\kappa y_a$, and $v_{2a} = v_{3a} = 0$ for all nodes $a=1, \\dots, 8$.\n\nThe components of the velocity gradient tensor $\\mathbf{L}$ at the element center are calculated using the formula derived above.\nSince $v_{2a} = v_{3a} = 0$, the last two rows of $\\mathbf{L}$ are zero:\n$$ L_{2j} = \\sum_{a=1}^{8} \\frac{\\partial N_a}{\\partial x_j} v_{2a} = 0, \\quad L_{3j} = \\sum_{a=1}^{8} \\frac{\\partial N_a}{\\partial x_j} v_{3a} = 0 \\quad \\text{for } j=1,2,3. $$\nWe only need to calculate the components of the first row, $L_{1j}$:\n$$ L_{1j} = \\sum_{a=1}^{8} \\left.\\frac{\\partial N_a}{\\partial x_j}\\right|_{(0,0,0)} v_{1a} = \\sum_{a=1}^{8} \\left.\\frac{\\partial N_a}{\\partial x_j}\\right|_{(0,0,0)} (\\kappa y_a) $$\n\nFor $j=1$ ($x$-component):\n$$ L_{11} = \\sum_{a=1}^{8} \\left(\\frac{1}{4}\\frac{\\xi_a}{L_x}\\right) (\\kappa y_a) = \\frac{\\kappa}{4L_x} \\sum_{a=1}^{8} \\xi_a \\left(y_c + \\frac{L_y}{2}\\eta_a\\right) = \\frac{\\kappa}{4L_x} \\left(y_c \\sum_{a=1}^{8}\\xi_a + \\frac{L_y}{2} \\sum_{a=1}^{8}\\xi_a\\eta_a\\right) $$\nThe sums are over the $8$ nodes corresponding to the corners of the parent cube, where $(\\xi_a, \\eta_a, \\zeta_a) \\in \\{-1,1\\}^3$. Due to symmetry, $\\sum_{a=1}^{8}\\xi_a = 0$ and $\\sum_{a=1}^{8}\\xi_a\\eta_a = 0$. Thus, $L_{11} = 0$.\n\nFor $j=2$ ($y$-component):\n$$ L_{12} = \\sum_{a=1}^{8} \\left(\\frac{1}{4}\\frac{\\eta_a}{L_y}\\right) (\\kappa y_a) = \\frac{\\kappa}{4L_y} \\sum_{a=1}^{8} \\eta_a \\left(y_c + \\frac{L_y}{2}\\eta_a\\right) = \\frac{\\kappa}{4L_y} \\left(y_c \\sum_{a=1}^{8}\\eta_a + \\frac{L_y}{2} \\sum_{a=1}^{8}\\eta_a^2\\right) $$\nAgain, $\\sum_{a=1}^{8}\\eta_a = 0$. For $\\eta_a \\in \\{-1,1\\}$, we have $\\eta_a^2=1$. Thus, $\\sum_{a=1}^{8}\\eta_a^2 = 8$.\n$$ L_{12} = \\frac{\\kappa}{4L_y} \\left(0 + \\frac{L_y}{2} \\cdot 8\\right) = \\frac{\\kappa}{4L_y} (4L_y) = \\kappa $$\n\nFor $j=3$ ($z$-component):\n$$ L_{13} = \\sum_{a=1}^{8} \\left(\\frac{1}{4}\\frac{\\zeta_a}{L_z}\\right) (\\kappa y_a) = \\frac{\\kappa}{4L_z} \\sum_{a=1}^{8} \\zeta_a \\left(y_c + \\frac{L_y}{2}\\eta_a\\right) = \\frac{\\kappa}{4L_z} \\left(y_c \\sum_{a=1}^{8}\\zeta_a + \\frac{L_y}{2} \\sum_{a=1}^{8}\\zeta_a\\eta_a\\right) $$\nBy symmetry, $\\sum_{a=1}^{8}\\zeta_a = 0$ and $\\sum_{a=1}^{8}\\zeta_a\\eta_a = 0$. Thus, $L_{13} = 0$.\n\nThe resulting velocity gradient tensor at the center is:\n$$ \\mathbf{L} = \\begin{pmatrix} 0 & \\kappa & 0 \\\\ 0 & 0 & 0 \\\\ 0 & 0 & 0 \\end{pmatrix} $$\nThis result matches the analytical gradient of the continuum field $\\mathbf{v}(\\mathbf{x}) = [\\kappa y, 0, 0]^{\\mathsf{T}}$.\n\nNow, we compute the rate of deformation tensor $\\mathbf{D}$ and the spin tensor $\\mathbf{W}$.\n$$ \\mathbf{D} = \\frac{1}{2}\\left(\\mathbf{L} + \\mathbf{L}^{\\mathsf{T}}\\right) = \\frac{1}{2}\\left( \\begin{pmatrix} 0 & \\kappa & 0 \\\\ 0 & 0 & 0 \\\\ 0 & 0 & 0 \\end{pmatrix} + \\begin{pmatrix} 0 & 0 & 0 \\\\ \\kappa & 0 & 0 \\\\ 0 & 0 & 0 \\end{pmatrix} \\right) = \\begin{pmatrix} 0 & \\frac{\\kappa}{2} & 0 \\\\ \\frac{\\kappa}{2} & 0 & 0 \\\\ 0 & 0 & 0 \\end{pmatrix} $$\n$$ \\mathbf{W} = \\frac{1}{2}\\left(\\mathbf{L} - \\mathbf{L}^{\\mathsf{T}}\\right) = \\frac{1}{2}\\left( \\begin{pmatrix} 0 & \\kappa & 0 \\\\ 0 & 0 & 0 \\\\ 0 & 0 & 0 \\end{pmatrix} - \\begin{pmatrix} 0 & 0 & 0 \\\\ \\kappa & 0 & 0 \\\\ 0 & 0 & 0 \\end{pmatrix} \\right) = \\begin{pmatrix} 0 & \\frac{\\kappa}{2} & 0 \\\\ -\\frac{\\kappa}{2} & 0 & 0 \\\\ 0 & 0 & 0 \\end{pmatrix} $$\n\nThe final answer is the concatenation of the entries of $\\mathbf{L}$, $\\mathbf{D}$, and $\\mathbf{W}$ in row-major order.\nEntries of $\\mathbf{L}$: $[0, \\kappa, 0, 0, 0, 0, 0, 0, 0]$\nEntries of $\\mathbf{D}$: $[0, \\frac{\\kappa}{2}, 0, \\frac{\\kappa}{2}, 0, 0, 0, 0, 0]$\nEntries of $\\mathbf{W}$: $[0, \\frac{\\kappa}{2}, 0, -\\frac{\\kappa}{2}, 0, 0, 0, 0, 0]$\nCombining these gives the final vector.", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0 & \\kappa & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & \\frac{\\kappa}{2} & 0 & \\frac{\\kappa}{2} & 0 & 0 & 0 & 0 & 0 & 0 & \\frac{\\kappa}{2} & 0 & -\\frac{\\kappa}{2} & 0 & 0 & 0 & 0 & 0\n\\end{pmatrix}\n}\n$$", "id": "3609150"}, {"introduction": "A cornerstone of constitutive modeling is the principle of objectivity, which demands that material response be independent of the observer's frame of reference. This practice [@problem_id:3609175] focuses on a key consequence of this principle: the invariance of the rate of deformation tensor, $D$, under a superimposed rigid-body rotation. By programmatically verifying this property, you will gain a deeper physical intuition for why the split of the velocity gradient $L$ into $D$ and a spin tensor $W$ is so crucial for formulating physically meaningful material laws.", "problem": "Construct a programmatic verification of the invariance properties of the rate of deformation tensor under a superposed rigid rotation in computational solid mechanics. Begin from the following fundamental bases: the spatial velocity field $\\mathbf{v}(\\mathbf{x},t)$ and its velocity gradient $\\mathbf{L}(\\mathbf{x},t)$ defined by $L_{ij}=\\frac{\\partial v_{i}}{\\partial x_{j}}$, the symmetric rate of deformation tensor $\\mathbf{D}=\\tfrac{1}{2}\\left(\\mathbf{L}+\\mathbf{L}^{\\mathsf{T}}\\right)$, and the skew-symmetric spin tensor $\\mathbf{W}=\\tfrac{1}{2}\\left(\\mathbf{L}-\\mathbf{L}^{\\mathsf{T}}\\right)$. Consider a superposed rigid rotation with angular velocity vector $\\boldsymbol{\\omega}(t)$, which adds to the velocity field the rigid-body contribution $\\mathbf{v}^{\\mathrm{R}}(\\mathbf{x},t)=\\boldsymbol{\\omega}(t)\\times\\mathbf{x}$. The gradient of this rigid contribution is the skew-symmetric tensor $\\boldsymbol{\\Omega}$ that satisfies $\\boldsymbol{\\Omega}\\,\\mathbf{a}=\\boldsymbol{\\omega}\\times\\mathbf{a}$ for any vector $\\mathbf{a}$ and has the matrix representation\n$$\n\\boldsymbol{\\Omega}=\\begin{bmatrix}\n0 & -\\omega_{3} & \\omega_{2} \\\\\n\\omega_{3} & 0 & -\\omega_{1} \\\\\n-\\omega_{2} & \\omega_{1} & 0\n\\end{bmatrix}.\n$$\nUnder the superposed rigid rotation, the modified velocity gradient is $\\mathbf{L}^{\\ast}=\\mathbf{L}+\\boldsymbol{\\Omega}$, which implies $\\mathbf{D}^{\\ast}=\\tfrac{1}{2}\\left(\\mathbf{L}^{\\ast}+\\mathbf{L}^{\\ast\\mathsf{T}}\\right)$ and $\\mathbf{W}^{\\ast}=\\tfrac{1}{2}\\left(\\mathbf{L}^{\\ast}-\\mathbf{L}^{\\ast\\mathsf{T}}\\right)$. The invariance and transformation properties to be verified are: $\\mathbf{D}^{\\ast}=\\mathbf{D}$ and $\\mathbf{W}^{\\ast}=\\mathbf{W}+\\boldsymbol{\\Omega}$. Your program must implement these definitions, compute the relevant tensors, and verify the stated properties numerically using the Frobenius norm $\\|\\cdot\\|_{\\mathrm{F}}$.\n\nUse the following test suite of parameter values, where each test case provides a constant base velocity gradient $\\mathbf{L}$ in $\\mathrm{s}^{-1}$ and an angular velocity vector $\\boldsymbol{\\omega}$ in radians per second (rad/s). All quantities are expressed in the International System of Units (SI). The angle unit is radians.\n\nTest case $\\mathbf{1}$ (general non-symmetric $\\mathbf{L}$, nonzero $\\boldsymbol{\\omega}$):\n$$\n\\mathbf{L}_{1}=\\begin{bmatrix}\n0.5 & -1.2 & 0.3 \\\\\n2.1 & 0.0 & -0.7 \\\\\n0.4 & -0.9 & 1.8\n\\end{bmatrix}\\,\\mathrm{s}^{-1},\\quad\n\\boldsymbol{\\omega}_{1}=\\begin{bmatrix}\n0.6\\\\\n-0.2\\\\\n0.4\n\\end{bmatrix}\\,\\mathrm{rad/s}.\n$$\n\nTest case $\\mathbf{2}$ (general $\\mathbf{L}$, zero $\\boldsymbol{\\omega}$ boundary case):\n$$\n\\mathbf{L}_{2}=\\begin{bmatrix}\n-0.3 & 0.7 & -0.5 \\\\\n1.2 & 0.4 & -1.1 \\\\\n0.8 & -1.1 & 0.2\n\\end{bmatrix}\\,\\mathrm{s}^{-1},\\quad\n\\boldsymbol{\\omega}_{2}=\\begin{bmatrix}\n0.0\\\\\n0.0\\\\\n0.0\n\\end{bmatrix}\\,\\mathrm{rad/s}.\n$$\n\nTest case $\\mathbf{3}$ (purely symmetric $\\mathbf{L}$, nonzero $\\boldsymbol{\\omega}$):\n$$\n\\mathbf{L}_{3}=\\begin{bmatrix}\n1.0 & 0.2 & -0.3 \\\\\n0.2 & 0.5 & 0.1 \\\\\n-0.3 & 0.1 & 0.8\n\\end{bmatrix}\\,\\mathrm{s}^{-1},\\quad\n\\boldsymbol{\\omega}_{3}=\\begin{bmatrix}\n1.0\\\\\n1.0\\\\\n1.0\n\\end{bmatrix}\\,\\mathrm{rad/s}.\n$$\n\nTest case $\\mathbf{4}$ (purely skew-symmetric $\\mathbf{L}$, nonzero $\\boldsymbol{\\omega}$):\n$$\n\\mathbf{L}_{4}=\\begin{bmatrix}\n0.0 & -2.0 & 3.0 \\\\\n2.0 & 0.0 & -1.0 \\\\\n-3.0 & 1.0 & 0.0\n\\end{bmatrix}\\,\\mathrm{s}^{-1},\\quad\n\\boldsymbol{\\omega}_{4}=\\begin{bmatrix}\n-0.5\\\\\n2.0\\\\\n0.0\n\\end{bmatrix}\\,\\mathrm{rad/s}.\n$$\n\nTest case $\\mathbf{5}$ (tiny magnitudes edge case):\n$$\n\\mathbf{L}_{5}=\\begin{bmatrix}\n10^{-12} & -2\\times 10^{-12} & 3\\times 10^{-12} \\\\\n-2\\times 10^{-12} & 5\\times 10^{-12} & -4\\times 10^{-12} \\\\\n3\\times 10^{-12} & -4\\times 10^{-12} & -10^{-12}\n\\end{bmatrix}\\,\\mathrm{s}^{-1},\\quad\n\\boldsymbol{\\omega}_{5}=\\begin{bmatrix}\n10^{-12}\\\\\n-10^{-12}\\\\\n2\\times 10^{-12}\n\\end{bmatrix}\\,\\mathrm{rad/s}.\n$$\n\nVerification methodology and numerical tolerance: For each test case, compute $\\mathbf{D}$, $\\mathbf{W}$, $\\boldsymbol{\\Omega}$, $\\mathbf{D}^{\\ast}$, and $\\mathbf{W}^{\\ast}$. Let $e_{D}=\\left\\|\\mathbf{D}^{\\ast}-\\mathbf{D}\\right\\|_{\\mathrm{F}}$ and $e_{W}=\\left\\|\\mathbf{W}^{\\ast}-\\left(\\mathbf{W}+\\boldsymbol{\\Omega}\\right)\\right\\|_{\\mathrm{F}}$. A test case passes if $e_{D}\\leq \\varepsilon$ and $e_{W}\\leq \\varepsilon$, where the absolute tolerance is $\\varepsilon=10^{-12}$ in $\\mathrm{s}^{-1}$.\n\nFinal output specification: Your program should produce a single line of output containing the pass/fail results for the five test cases as a comma-separated list of booleans enclosed in square brackets, for example, $\\left[\\mathrm{True},\\mathrm{False},\\mathrm{True},\\mathrm{True},\\mathrm{True}\\right]$. The $i$-th boolean must be $\\mathrm{True}$ if and only if both invariance checks pass for test case $i$ under the stated tolerance.", "solution": "The problem statement is evaluated to be valid. It is scientifically grounded in continuum mechanics, well-posed, objective, and self-contained. The provided data and definitions are consistent and sufficient for a unique solution.\n\nThe task is to verify two fundamental properties of the rate of deformation and spin tensors under a superposed rigid-body rotation. The properties are the invariance of the rate of deformation tensor, $\\mathbf{D}^{\\ast}=\\mathbf{D}$, and the transformation rule for the spin tensor, $\\mathbf{W}^{\\ast}=\\mathbf{W}+\\boldsymbol{\\Omega}$. We will first provide an analytical proof of these properties and then outline the numerical verification algorithm.\n\n### Analytical Verification\n\nThe analysis begins with the definitions provided in the problem statement. The velocity gradient $\\mathbf{L}$ is additively decomposed into a symmetric part, the rate of deformation tensor $\\mathbf{D}$, and a skew-symmetric part, the spin tensor $\\mathbf{W}$:\n$$ \\mathbf{L} = \\mathbf{D} + \\mathbf{W} $$\nwhere\n$$ \\mathbf{D}=\\frac{1}{2}\\left(\\mathbf{L}+\\mathbf{L}^{\\mathsf{T}}\\right) \\quad \\text{and} \\quad \\mathbf{W}=\\frac{1}{2}\\left(\\mathbf{L}-\\mathbf{L}^{\\mathsf{T}}\\right) $$\nA superposed rigid-body rotation with angular velocity vector $\\boldsymbol{\\omega}$ adds a velocity component $\\boldsymbol{\\omega} \\times \\mathbf{x}$. The gradient of this velocity field is a skew-symmetric tensor $\\boldsymbol{\\Omega}$. This modifies the total velocity gradient to $\\mathbf{L}^{\\ast}$:\n$$ \\mathbf{L}^{\\ast}=\\mathbf{L}+\\boldsymbol{\\Omega} $$\nThe modified rate of deformation tensor $\\mathbf{D}^{\\ast}$ and spin tensor $\\mathbf{W}^{\\ast}$ are defined from $\\mathbf{L}^{\\ast}$ in the same manner as $\\mathbf{D}$ and $\\mathbf{W}$ are from $\\mathbf{L}$.\n\n**1. Verification of $\\mathbf{D}^{\\ast}=\\mathbf{D}$**\n\nWe begin with the definition of $\\mathbf{D}^{\\ast}$:\n$$ \\mathbf{D}^{\\ast} = \\frac{1}{2}\\left(\\mathbf{L}^{\\ast}+\\mathbf{L}^{\\ast\\mathsf{T}}\\right) $$\nSubstitute the expression for $\\mathbf{L}^{\\ast}$:\n$$ \\mathbf{D}^{\\ast} = \\frac{1}{2}\\left((\\mathbf{L}+\\boldsymbol{\\Omega}) + (\\mathbf{L}+\\boldsymbol{\\Omega})^{\\mathsf{T}}\\right) $$\nUsing the linearity of the transpose operation, $(\\mathbf{A}+\\mathbf{B})^{\\mathsf{T}} = \\mathbf{A}^{\\mathsf{T}}+\\mathbf{B}^{\\mathsf{T}}$:\n$$ \\mathbf{D}^{\\ast} = \\frac{1}{2}\\left(\\mathbf{L}+\\boldsymbol{\\Omega} + \\mathbf{L}^{\\mathsf{T}}+\\boldsymbol{\\Omega}^{\\mathsf{T}}\\right) $$\nThe tensor $\\boldsymbol{\\Omega}$ is skew-symmetric by definition, which implies $\\boldsymbol{\\Omega}^{\\mathsf{T}} = -\\boldsymbol{\\Omega}$. Substituting this property yields:\n$$ \\mathbf{D}^{\\ast} = \\frac{1}{2}\\left(\\mathbf{L}+\\boldsymbol{\\Omega} + \\mathbf{L}^{\\mathsf{T}}-\\boldsymbol{\\Omega}\\right) $$\nThe terms $\\boldsymbol{\\Omega}$ and $-\\boldsymbol{\\Omega}$ cancel each other out:\n$$ \\mathbf{D}^{\\ast} = \\frac{1}{2}\\left(\\mathbf{L}+\\mathbf{L}^{\\mathsf{T}}\\right) $$\nThis is precisely the definition of the original rate of deformation tensor $\\mathbf{D}$. Thus, we have analytically proven that:\n$$ \\mathbf{D}^{\\ast}=\\mathbf{D} $$\nThis result signifies that the rate of deformation, which characterizes the stretching and shearing of a material element, is objective or frame-invariant; it is not affected by a superposed rigid-body rotation.\n\n**2. Verification of $\\mathbf{W}^{\\ast}=\\mathbf{W}+\\boldsymbol{\\Omega}$**\n\nNext, we examine the modified spin tensor $\\mathbf{W}^{\\ast}$, defined as:\n$$ \\mathbf{W}^{\\ast} = \\frac{1}{2}\\left(\\mathbf{L}^{\\ast}-\\mathbf{L}^{\\ast\\mathsf{T}}\\right) $$\nAgain, we substitute $\\mathbf{L}^{\\ast}=\\mathbf{L}+\\boldsymbol{\\Omega}$:\n$$ \\mathbf{W}^{\\ast} = \\frac{1}{2}\\left((\\mathbf{L}+\\boldsymbol{\\Omega}) - (\\mathbf{L}+\\boldsymbol{\\Omega})^{\\mathsf{T}}\\right) $$\nApplying the transpose property:\n$$ \\mathbf{W}^{\\ast} = \\frac{1}{2}\\left(\\mathbf{L}+\\boldsymbol{\\Omega} - \\mathbf{L}^{\\mathsf{T}}-\\boldsymbol{\\Omega}^{\\mathsf{T}}\\right) $$\nUsing the skew-symmetry, $\\boldsymbol{\\Omega}^{\\mathsf{T}} = -\\boldsymbol{\\Omega}$:\n$$ \\mathbf{W}^{\\ast} = \\frac{1}{2}\\left(\\mathbf{L}+\\boldsymbol{\\Omega} - \\mathbf{L}^{\\mathsf{T}}- (-\\boldsymbol{\\Omega})\\right) = \\frac{1}{2}\\left(\\mathbf{L}+\\boldsymbol{\\Omega} - \\mathbf{L}^{\\mathsf{T}}+\\boldsymbol{\\Omega}\\right) $$\nRearranging terms within the parentheses to group the components of $\\mathbf{W}$ and the $\\boldsymbol{\\Omega}$ terms:\n$$ \\mathbf{W}^{\\ast} = \\frac{1}{2}\\left((\\mathbf{L}-\\mathbf{L}^{\\mathsf{T}}) + 2\\boldsymbol{\\Omega}\\right) $$\nDistributing the scalar factor $1/2$:\n$$ \\mathbf{W}^{\\ast} = \\frac{1}{2}\\left(\\mathbf{L}-\\mathbf{L}^{\\mathsf{T}}\\right) + \\frac{1}{2}(2\\boldsymbol{\\Omega}) $$\nThe first term is the definition of the original spin tensor $\\mathbf{W}$. This simplifies to:\n$$ \\mathbf{W}^{\\ast} = \\mathbf{W} + \\boldsymbol{\\Omega} $$\nThis confirms the transformation rule for the spin tensor. The spin of the material is augmented by the spin of the superposed rigid rotation, which is an expected physical result.\n\n### Programmatic Verification Algorithm\n\nThe program will numerically verify these two identities for each provided test case. The algorithm for each test case $(\\mathbf{L}, \\boldsymbol{\\omega})$ is as follows:\n\n1.  **Initialize**: Given the velocity gradient matrix $\\mathbf{L}$ and the angular velocity vector $\\boldsymbol{\\omega} = [\\omega_1, \\omega_2, \\omega_3]^{\\mathsf{T}}$.\n2.  **Construct $\\boldsymbol{\\Omega}$**: Form the $3 \\times 3$ skew-symmetric matrix $\\boldsymbol{\\Omega}$ from the components of $\\boldsymbol{\\omega}$ using the provided formula:\n    $$\n    \\boldsymbol{\\Omega}=\\begin{bmatrix}\n    0 & -\\omega_{3} & \\omega_{2} \\\\\n    \\omega_{3} & 0 & -\\omega_{1} \\\\\n    -\\omega_{2} & \\omega_{1} & 0\n    \\end{bmatrix}\n    $$\n3.  **Compute Base Tensors**: Calculate the original rate of deformation tensor $\\mathbf{D}$ and spin tensor $\\mathbf{W}$ from $\\mathbf{L}$:\n    - $\\mathbf{D} = 0.5 \\times (\\mathbf{L} + \\mathbf{L}^{\\mathsf{T}})$\n    - $\\mathbf{W} = 0.5 \\times (\\mathbf{L} - \\mathbf{L}^{\\mathsf{T}})$\n4.  **Compute Modified Tensors**:\n    - First, calculate the modified velocity gradient $\\mathbf{L}^{\\ast} = \\mathbf{L} + \\boldsymbol{\\Omega}$.\n    - Then, calculate the modified tensors $\\mathbf{D}^{\\ast}$ and $\\mathbf{W}^{\\ast}$ from $\\mathbf{L}^{\\ast}$:\n    - $\\mathbf{D}^{\\ast} = 0.5 \\times (\\mathbf{L}^{\\ast} + \\mathbf{L}^{\\ast\\mathsf{T}})$\n    - $\\mathbf{W}^{\\ast} = 0.5 \\times (\\mathbf{L}^{\\ast} - \\mathbf{L}^{\\ast\\mathsf{T}})$\n5.  **Calculate Errors**: Compute the error for each identity using the Frobenius norm, $\\|\\cdot\\|_{\\mathrm{F}}$:\n    - Error for $\\mathbf{D}$ invariance: $e_{D} = \\|\\mathbf{D}^{\\ast} - \\mathbf{D}\\|_{\\mathrm{F}}$\n    - Error for $\\mathbf{W}$ transformation: $e_{W} = \\|\\mathbf{W}^{\\ast} - (\\mathbf{W} + \\boldsymbol{\\Omega})\\|_{\\mathrm{F}}$\n6.  **Verify**: Compare the computed errors against the specified tolerance $\\varepsilon = 10^{-12}$. The test case passes if and only if both conditions are met:\n    - $e_{D} \\leq \\varepsilon$\n    - $e_{W} \\leq \\varepsilon$\n7.  **Store Result**: The result for the test case is a boolean value (`True` for pass, `False` for fail). This is repeated for all test cases.\n8.  **Output**: The final output is a list of these boolean results in the specified format.\n\nThis algorithm directly implements the mathematical definitions and verification criteria, leveraging numerical libraries for matrix operations and norm calculations.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Verifies the invariance of the rate of deformation tensor (D) and the\n    transformation rule for the spin tensor (W) under a superposed rigid rotation.\n    \"\"\"\n    # Define the absolute tolerance for numerical verification.\n    epsilon = 1e-12\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1\n        (\n            np.array([[0.5, -1.2, 0.3], [2.1, 0.0, -0.7], [0.4, -0.9, 1.8]]),\n            np.array([0.6, -0.2, 0.4])\n        ),\n        # Test case 2\n        (\n            np.array([[-0.3, 0.7, -0.5], [1.2, 0.4, -1.1], [0.8, -1.1, 0.2]]),\n            np.array([0.0, 0.0, 0.0])\n        ),\n        # Test case 3\n        (\n            np.array([[1.0, 0.2, -0.3], [0.2, 0.5, 0.1], [-0.3, 0.1, 0.8]]),\n            np.array([1.0, 1.0, 1.0])\n        ),\n        # Test case 4\n        (\n            np.array([[0.0, -2.0, 3.0], [2.0, 0.0, -1.0], [-3.0, 1.0, 0.0]]),\n            np.array([-0.5, 2.0, 0.0])\n        ),\n        # Test case 5\n        (\n            np.array([\n                [1e-12, -2e-12, 3e-12],\n                [-2e-12, 5e-12, -4e-12],\n                [3e-12, -4e-12, -1e-12]\n            ]),\n            np.array([1e-12, -1e-12, 2e-12])\n        ),\n    ]\n\n    results = []\n    for L, omega in test_cases:\n        # Construct the skew-symmetric tensor Omega from the angular velocity vector omega.\n        w1, w2, w3 = omega[0], omega[1], omega[2]\n        Omega = np.array([\n            [0, -w3, w2],\n            [w3, 0, -w1],\n            [-w2, w1, 0]\n        ])\n\n        # Calculate the base rate of deformation tensor D and spin tensor W from L.\n        D = 0.5 * (L + L.T)\n        W = 0.5 * (L - L.T)\n\n        # Calculate the modified velocity gradient L_star.\n        L_star = L + Omega\n\n        # Calculate the modified rate of deformation D_star and spin W_star from L_star.\n        D_star = 0.5 * (L_star + L_star.T)\n        W_star = 0.5 * (L_star - L_star.T)\n\n        # Calculate the verification errors using the Frobenius norm.\n        # e_D should be numerically close to zero, as D_star = D analytically.\n        e_D = np.linalg.norm(D_star - D, 'fro')\n        \n        # e_W should be numerically close to zero, as W_star = W + Omega analytically.\n        e_W = np.linalg.norm(W_star - (W + Omega), 'fro')\n\n        # A test case passes if both errors are within the tolerance.\n        passes = (e_D <= epsilon) and (e_W <= epsilon)\n        results.append(passes)\n\n    # Format the final output as a comma-separated list of booleans.\n    # Python's str(bool) produces 'True'/'False' with capitalization, as required.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3609175"}, {"introduction": "While the condition $\\operatorname{tr}(D)=0$ theoretically guarantees volume preservation for incompressible materials, numerical time integration can introduce errors that cause the volume to 'drift' over time. This advanced practice [@problem_id:3609164] delves into this critical numerical stability issue, asking you to both observe the drift and implement a projection method to correct it. This exercise demonstrates how the kinematic framework is used not just for description, but also for developing robust algorithms that enforce physical constraints in the face of numerical inaccuracies.", "problem": "You are given the kinematic evolution of the deformation gradient in continuum mechanics. The velocity gradient tensor is defined as $\\mathbf{L} = \\nabla \\mathbf{v}$, and it is decomposed into the symmetric rate of deformation tensor $\\mathbf{D}$ and the skew-symmetric spin tensor $\\mathbf{W}$ by the definitions $\\mathbf{D} = \\tfrac{1}{2}\\left(\\mathbf{L} + \\mathbf{L}^{\\mathsf{T}}\\right)$ and $\\mathbf{W} = \\tfrac{1}{2}\\left(\\mathbf{L} - \\mathbf{L}^{\\mathsf{T}}\\right)$. The deformation gradient $\\mathbf{F}$ evolves by the fundamental kinematic relation $\\dot{\\mathbf{F}} = \\mathbf{L}\\,\\mathbf{F}$ with initial condition $\\mathbf{F}(0)=\\mathbf{I}$, where $\\mathbf{I}$ is the identity tensor. Let $J = \\det \\mathbf{F}$. For an incompressible motion, $J$ must remain equal to $1$ for all time.\n\nYour tasks are:\n- Starting from the fundamental kinematic relation and basic matrix calculus, derive an evolution equation for $J$ and identify the condition on $\\mathbf{D}$ under which $J$ remains constant in time.\n- Explain why numerical roundoff and time integration error can cause drift of $J$ away from $1$ even when the theoretical condition for constant $J$ is satisfied.\n- Propose and justify a projection that enforces $J=1$ at each time step by an isotropic correction to $\\mathbf{F}$. The projection must be expressed entirely in terms of $\\mathbf{F}$ and its determinant and should be independent of the particular form of $\\mathbf{L}$.\n\nThen, implement a program that:\n- Integrates $\\dot{\\mathbf{F}} = \\mathbf{L}\\,\\mathbf{F}$ for constant-in-time $\\mathbf{L}$ defined by prescribed $\\mathbf{D}$ and $\\mathbf{W}$.\n- Compares three discrete update strategies:\n    1. Forward Euler without projection: $\\mathbf{F}_{n+1} = \\mathbf{F}_n + \\Delta t\\, \\mathbf{L} \\mathbf{F}_n$.\n    2. Forward Euler with per-step volumetric projection: compute $\\widehat{\\mathbf{F}}_{n+1} = \\mathbf{F}_n + \\Delta t\\, \\mathbf{L} \\mathbf{F}_n$, then set $\\mathbf{F}_{n+1} = \\alpha\\,\\widehat{\\mathbf{F}}_{n+1}$ with $\\alpha$ chosen so that $\\det(\\mathbf{F}_{n+1}) = 1$.\n    3. Exact constant-$\\mathbf{L}$ solution using a matrix exponential over the total time $T$: $\\mathbf{F}(T) = \\exp(\\mathbf{L}\\,T)$.\n- Also integrate the scalar ordinary differential equation for $J$ obtained in your derivation using forward Euler with the same $\\Delta t$ and initial value $J(0)=1$ to observe the effect of roundoff in the scalar evolution.\n\nUse the following constant-in-time test suite. In each case, define $\\mathbf{D} = \\mathrm{diag}(a,-a,0)$, $\\mathbf{W}$ as a planar spin about the $z$-axis with angular speed $\\omega$ given by\n$$\n\\mathbf{W} = \\begin{bmatrix}\n0 & -\\omega & 0 \\\\\n\\omega & 0 & 0 \\\\\n0 & 0 & 0\n\\end{bmatrix},\n$$\nand set $\\mathbf{L} = \\mathbf{D} + \\mathbf{W}$. Use the identity $\\mathbf{I}$ for the initial condition $\\mathbf{F}(0)$.\n\nTest suite (all quantities are dimensionless, so no physical units are required):\n- Case A (boundary, zero spin): $a = 0.2$, $\\omega = 0.0$, $\\Delta t = 10^{-3}$, $T = 10^{-1}$.\n- Case B (happy path, moderate spin): $a = 0.2$, $\\omega = 50.0$, $\\Delta t = 10^{-4}$, $T = 5\\times 10^{-2}$.\n- Case C (edge, large spin): $a = 0.2$, $\\omega = 2000.0$, $\\Delta t = 10^{-6}$, $T = 2\\times 10^{-3}$.\n\nFor each case, compute and report the following four scalars:\n- $e_{\\mathrm{unproj}}^{\\mathrm{final}} = \\left|\\det\\!\\left(F_{\\mathrm{Euler\\;unproj}}(T)\\right) - 1\\right|$.\n- $e_{\\mathrm{unproj}}^{\\mathrm{max}} = \\max_{0 \\le n \\le N} \\left|\\det\\!\\left(F_{\\mathrm{Euler\\;unproj}}(t_n)\\right) - 1\\right|$, where $t_n = n\\,\\Delta t$ and $N = \\lfloor T/\\Delta t \\rfloor$.\n- $e_{\\mathrm{proj}}^{\\mathrm{final}} = \\left|\\det\\!\\left(F_{\\mathrm{Euler\\;proj}}(T)\\right) - 1\\right|$.\n- $e_{\\mathrm{expm}}^{\\mathrm{final}} = \\left|\\det\\!\\left(F_{\\mathrm{expm}}(T)\\right) - 1\\right|$.\n\nYour program must implement the three integration strategies, including the volumetric projection you propose, and must compute the above four scalar results for each of the three cases in the specified order: Case A, then Case B, then Case C. The final output must be a single line containing these results as a comma-separated list of floating-point numbers enclosed in square brackets, in the order\n$$\n\\big[e_{\\mathrm{unproj}}^{\\mathrm{final}}(\\mathrm{A}),\\ e_{\\mathrm{unproj}}^{\\mathrm{max}}(\\mathrm{A}),\\ e_{\\mathrm{proj}}^{\\mathrm{final}}(\\mathrm{A}),\\ e_{\\mathrm{expm}}^{\\mathrm{final}}(\\mathrm{A}),\\ e_{\\mathrm{unproj}}^{\\mathrm{final}}(\\mathrm{B}),\\ e_{\\mathrm{unproj}}^{\\mathrm{max}}(\\mathrm{B}),\\ e_{\\mathrm{proj}}^{\\mathrm{final}}(\\mathrm{B}),\\ e_{\\mathrm{expm}}^{\\mathrm{final}}(\\mathrm{B}),\\ e_{\\mathrm{unproj}}^{\\mathrm{final}}(\\mathrm{C}),\\ e_{\\mathrm{unproj}}^{\\mathrm{max}}(\\mathrm{C}),\\ e_{\\mathrm{proj}}^{\\mathrm{final}}(\\mathrm{C}),\\ e_{\\mathrm{expm}}^{\\mathrm{final}}(\\mathrm{C})\\big].\n$$\n\nAll computations are dimensionless. Angles are not directly reported. No percentages are used. The program must be self-contained and must not require any external input or files. The answers are real numbers (floating-point values).", "solution": "The problem is well-posed and scientifically grounded in continuum mechanics and numerical analysis. We proceed with the solution, which consists of three parts: a theoretical derivation, an explanation of numerical errors, and the proposal of a projection method, followed by the implementation.\n\nFirst, we derive the evolution equation for the determinant of the deformation gradient, $J = \\det \\mathbf{F}$. The time derivative of a determinant of a time-dependent matrix $\\mathbf{F}(t)$ is given by Jacobi's formula:\n$$\n\\dot{J} = \\frac{d}{dt}(\\det \\mathbf{F}) = (\\det \\mathbf{F}) \\mathrm{tr}( \\dot{\\mathbf{F}} \\mathbf{F}^{-1} ) = J \\, \\mathrm{tr}( \\dot{\\mathbf{F}} \\mathbf{F}^{-1} )\n$$\nThe problem states the fundamental kinematic relation $\\dot{\\mathbf{F}} = \\mathbf{L} \\mathbf{F}$, where $\\mathbf{L}$ is the velocity gradient. Substituting this into Jacobi's formula yields:\n$$\n\\dot{J} = J \\, \\mathrm{tr}( (\\mathbf{L} \\mathbf{F}) \\mathbf{F}^{-1} ) = J \\, \\mathrm{tr}(\\mathbf{L} (\\mathbf{F} \\mathbf{F}^{-1})) = J \\, \\mathrm{tr}(\\mathbf{L})\n$$\nThe velocity gradient $\\mathbf{L}$ can be decomposed into its symmetric part, the rate of deformation tensor $\\mathbf{D}$, and its skew-symmetric part, the spin tensor $\\mathbf{W}$, such that $\\mathbf{L} = \\mathbf{D} + \\mathbf{W}$. The trace is a linear operator, so $\\mathrm{tr}(\\mathbf{L}) = \\mathrm{tr}(\\mathbf{D} + \\mathbf{W}) = \\mathrm{tr}(\\mathbf{D}) + \\mathrm{tr}(\\mathbf{W})$. The trace of any skew-symmetric matrix $\\mathbf{W}$ is zero, because its diagonal elements are necessarily zero. Thus, $\\mathrm{tr}(\\mathbf{W}) = 0$. This simplifies the evolution equation for $J$ to:\n$$\n\\dot{J} = J \\, \\mathrm{tr}(\\mathbf{D})\n$$\nFor $J$ to remain constant in time, its time derivative $\\dot{J}$ must be zero. Given the initial condition $\\mathbf{F}(0) = \\mathbf{I}$, we have $J(0) = \\det(\\mathbf{I}) = 1$. Since the solution to the ordinary differential equation is $J(t) = J(0) \\exp(\\int_0^t \\mathrm{tr}(\\mathbf{D}(\\tau)) d\\tau)$, $J$ will always be positive. Therefore, the condition $\\dot{J} = 0$ is equivalent to requiring $\\mathrm{tr}(\\mathbf{D}) = 0$. This condition means that the volumetric rate of strain is zero, which is the definition of an isochoric (volume-preserving) or incompressible motion. In the context of the provided test cases, $\\mathbf{D} = \\mathrm{diag}(a, -a, 0)$, so $\\mathrm{tr}(\\mathbf{D}) = a - a + 0 = 0$. Thus, the motion is theoretically incompressible, and $J$ should remain equal to $1$ for all time.\n\nSecond, we explain why numerical computations can lead to a drift of $J$ from $1$. There are two primary sources of error: time integration (truncation) error and floating-point roundoff error.\nThe Forward Euler method updates the deformation gradient as $\\mathbf{F}_{n+1} = \\mathbf{F}_n + \\Delta t \\mathbf{L} \\mathbf{F}_n = (\\mathbf{I} + \\Delta t \\mathbf{L}) \\mathbf{F}_n$. Applying the determinant to this update rule gives $J_{n+1} = \\det(\\mathbf{F}_{n+1}) = \\det(\\mathbf{I} + \\Delta t \\mathbf{L}) J_n$. The exact evolution over a time step $\\Delta t$ would be $\\mathbf{F}(t_n + \\Delta t) = \\exp(\\Delta t \\mathbf{L}) \\mathbf{F}(t_n)$, for which the determinant is $J(t_n + \\Delta t) = \\det(\\exp(\\Delta t \\mathbf{L})) J(t_n) = \\exp(\\mathrm{tr}(\\Delta t \\mathbf{L})) J(t_n)$. Since $\\mathrm{tr}(\\mathbf{L}) = 0$, the exact evolution gives $J(t_n + \\Delta t) = \\exp(0) J(t_n) = J(t_n)$, perfectly preserving the volume. However, the Forward Euler propagator $\\mathbf{I} + \\Delta t \\mathbf{L}$ is only a first-order approximation of $\\exp(\\Delta t \\mathbf{L})$. The determinant of the propagator is $\\det(\\mathbf{I} + \\Delta t \\mathbf{L}) \\approx 1 + \\Delta t \\mathrm{tr}(\\mathbf{L}) + \\mathcal{O}(\\Delta t^2)$. With $\\mathrm{tr}(\\mathbf{L})=0$, this becomes $\\det(\\mathbf{I} + \\Delta t \\mathbf{L}) = 1 + \\mathcal{O}(\\Delta t^2)$. The determinant is not exactly preserved at each step. This is the **truncation error** of the integration scheme. It causes a systematic drift in $J$ over many time steps, with the error accumulating approximately linearly with the number of steps.\n**Roundoff error** is a separate issue stemming from the finite precision of floating-point numbers on a computer. Every arithmetic operation can introduce a small error. This affects all three methods. For the Forward Euler method, this is typically subordinate to the larger truncation error. For the \"exact\" solution $\\mathbf{F}(T) = \\exp(\\mathbf{L}T)$, which is computed using numerical algorithms like Padé approximation, roundoff error is the only source of deviation. Thus, $\\det(\\exp(\\mathbf{L}T))$ will be very close to $1$ but not exactly $1$, differing by an amount related to the machine precision. The simple scalar integration $J_{n+1} = J_n + \\Delta t \\cdot 0 \\cdot J_n = J_n$ with $J_0=1$ would ideally maintain $J=1$ forever. Any deviation observed in a numerical implementation of this trivial update would be purely due to roundoff error.\n\nThird, we propose a projection to enforce $J=1$ at each step. After a time step, we compute a tentative deformation gradient, let's call it $\\widehat{\\mathbf{F}}_{n+1}$, for which the determinant $\\widehat{J}_{n+1} = \\det(\\widehat{\\mathbf{F}}_{n+1})$ may not be $1$. We seek a corrected deformation gradient $\\mathbf{F}_{n+1}$ that is \"close\" to $\\widehat{\\mathbf{F}}_{n+1}$ and satisfies $\\det(\\mathbf{F}_{n+1})=1$. The problem suggests an isotropic correction, which can be formulated as a uniform scaling:\n$$\n\\mathbf{F}_{n+1} = \\alpha \\widehat{\\mathbf{F}}_{n+1}\n$$\nwhere $\\alpha$ is a scalar correction factor. We find $\\alpha$ by enforcing the incompressibility constraint. Taking the determinant of both sides, for a problem in $d=3$ dimensions:\n$$\n\\det(\\mathbf{F}_{n+1}) = \\det(\\alpha \\widehat{\\mathbf{F}}_{n+1}) = \\alpha^3 \\det(\\widehat{\\mathbf{F}}_{n+1}) = \\alpha^3 \\widehat{J}_{n+1}\n$$\nSetting $\\det(\\mathbf{F}_{n+1})=1$, we get $1 = \\alpha^3 \\widehat{J}_{n+1}$. Solving for $\\alpha$ yields:\n$$\n\\alpha = \\left( \\frac{1}{\\widehat{J}_{n+1}} \\right)^{1/3} = \\widehat{J}_{n+1}^{-1/3}\n$$\nThus, the projection update is:\n$$\n\\mathbf{F}_{n+1} = (\\det \\widehat{\\mathbf{F}}_{n+1})^{-1/3} \\widehat{\\mathbf{F}}_{n+1}\n$$\nThis projection is expressed purely in terms of the computed state $\\widehat{\\mathbf{F}}_{n+1}$ and its determinant. It corresponds to applying a uniform volumetric correction to restore the unit volume, which is a common and effective technique in computational mechanics for enforcing incompressibility with explicit time integration schemes. The final error $e_{\\mathrm{proj}}^{\\mathrm{final}}$ will be non-zero only due to the roundoff error in the final calculation of $\\det(\\mathbf{F}_{n+1})$ after the last projection.", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef solve():\n    \"\"\"\n    Main function to run the simulations and compute the required error metrics.\n    \"\"\"\n    test_cases = [\n        # Case A (boundary, zero spin)\n        {'a': 0.2, 'omega': 0.0, 'dt': 1e-3, 'T': 1e-1},\n        # Case B (happy path, moderate spin)\n        {'a': 0.2, 'omega': 50.0, 'dt': 1e-4, 'T': 5e-2},\n        # Case C (edge, large spin)\n        {'a': 0.2, 'omega': 2000.0, 'dt': 1e-6, 'T': 2e-3},\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        a = case['a']\n        omega = case['omega']\n        dt = case['dt']\n        T = case['T']\n\n        # Ensure N is an integer, safe for floating point inaccuracies in T/dt\n        N = int(round(T / dt))\n\n        # Define D, W, and L tensors\n        D = np.array([\n            [a, 0, 0],\n            [0, -a, 0],\n            [0, 0, 0]\n        ])\n        W = np.array([\n            [0, -omega, 0],\n            [omega, 0, 0],\n            [0, 0, 0]\n        ])\n        L = D + W\n\n        # --- Method 1: Forward Euler without projection ---\n        F_unproj = np.eye(3)\n        # Pre-compute the update matrix for efficiency\n        Id_plus_dt_L = np.eye(3) + dt * L\n        \n        dets_unproj = []\n        for _ in range(N):\n            F_unproj = Id_plus_dt_L @ F_unproj\n            det_F = np.linalg.det(F_unproj)\n            dets_unproj.append(abs(det_F - 1.0))\n        \n        e_unproj_final = dets_unproj[-1] if dets_unproj else 0.0\n        e_unproj_max = max(dets_unproj) if dets_unproj else 0.0\n\n        # --- Method 2: Forward Euler with per-step volumetric projection ---\n        F_proj = np.eye(3)\n        # Re-using the same update matrix\n        for _ in range(N):\n            F_hat = Id_plus_dt_L @ F_proj\n            J_hat = np.linalg.det(F_hat)\n            \n            # Avoid division by zero or complex numbers if J_hat is negative\n            if J_hat <= 0:\n                # This case is not expected in this problem but is good practice\n                # In a real simulation, this might indicate an instability\n                alpha = 1.0 \n            else:\n                alpha = J_hat**(-1.0/3.0)\n                \n            F_proj = alpha * F_hat\n            \n        det_F_proj_final = np.linalg.det(F_proj)\n        e_proj_final = abs(det_F_proj_final - 1.0)\n        \n        # --- Method 3: Exact constant-L solution using matrix exponential ---\n        F_expm = expm(L * T)\n        det_F_expm = np.linalg.det(F_expm)\n        e_expm_final = abs(det_F_expm - 1.0)\n\n        all_results.extend([e_unproj_final, e_unproj_max, e_proj_final, e_expm_final])\n\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n\n```", "id": "3609164"}]}