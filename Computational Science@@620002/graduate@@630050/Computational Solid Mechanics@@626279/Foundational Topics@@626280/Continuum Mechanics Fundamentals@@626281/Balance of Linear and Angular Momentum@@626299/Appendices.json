{"hands_on_practices": [{"introduction": "Before delving into dynamic scenarios, it is crucial to verify that our computational methods respect the balance laws in the static limit. This practice [@problem_id:3546843] introduces the constant-stress patch test, a cornerstone of finite element verification. By subjecting a patch of elements to a uniform stress field, we can computationally confirm that the assembled internal nodal forces and moments sum to zero, thereby satisfying global equilibrium as dictated by the balance of linear and angular momentum.", "problem": "Consider a two-dimensional small-strain continuum occupying a bounded polygonal domain in the plane with coordinates in meters. Assume zero body force and zero inertia so that the balance of linear momentum reduces to $ \\nabla \\cdot \\boldsymbol{\\sigma} = \\boldsymbol{0} $ in the interior, where $ \\boldsymbol{\\sigma} $ is the Cauchy stress tensor. Further assume the Cauchy stress tensor is spatially uniform and symmetric, $ \\boldsymbol{\\sigma} = \\boldsymbol{\\sigma}^{\\top} $, everywhere in the domain. The boundary traction is conceptually taken as $ \\boldsymbol{t} = \\boldsymbol{\\sigma} \\boldsymbol{n} $ so that the continuum is in equilibrium with the uniform stress state.\n\nYou are given meshes composed of linear three-node triangular elements (also called $ P_1 $ elements). For each element with nodes at positions $ (x_1,y_1) $, $ (x_2,y_2) $, and $ (x_3,y_3) $, the shape functions $ N_1 $, $ N_2 $, and $ N_3 $ are linear and satisfy the partition of unity $ \\sum_{i=1}^{3} N_i = 1 $ and linear completeness $ \\sum_{i=1}^{3} x_i N_i = x $, $ \\sum_{i=1}^{3} y_i N_i = y $. The gradient $ \\nabla N_i $ is constant within a linear triangular element. Using the principle of virtual work and the balance of linear and angular momentum, the assembled internal nodal force vector is obtained by integrating the stress against appropriate test functions derived from $ \\nabla N_i $ over each element and summing contributions to shared nodes. Take unit thickness so that forces are in newtons (N) and moments are in newton-meters (N·m).\n\nTask: Implement a constant-stress patch test. For each provided mesh and a specified uniform symmetric Cauchy stress $ \\boldsymbol{\\sigma} $, compute the assembled internal nodal forces. Then verify global conservation by checking:\n- The resultant internal force $ \\boldsymbol{F} = \\sum_{a} \\boldsymbol{f}_a $ is numerically zero (the balance of global linear momentum), where $ \\boldsymbol{f}_a $ is the internal nodal force at node $ a $.\n- The resultant internal moment about the origin, $ M_z = \\sum_{a} (x_a f_{a,y} - y_a f_{a,x}) $, is numerically zero (the balance of global angular momentum), where $ (x_a,y_a) $ are nodal coordinates and $ (f_{a,x}, f_{a,y}) $ are components of $ \\boldsymbol{f}_a $.\n\nYou must treat every triangular element exactly in closed form using the linear shape function gradients (which are constant per element), and you must assemble contributions additively at shared nodes. Use a numerical tolerance of $ 10^{-9} $ N for the resultant force magnitude $ \\| \\boldsymbol{F} \\|_2 $ and $ 10^{-9} $ N·m for $ |M_z| $ to decide whether \"vanish\" holds.\n\nPhysical units:\n- Coordinates are in meters (m).\n- Stress components are in pascals (Pa).\n- Thickness is unity (m).\n- Forces are in newtons (N).\n- Moments are in newton-meters (N·m).\n\nAngle units are not used in this problem.\n\nTest suite:\nFor each test case, you are given a set of nodes, a triangulation (elements), and a uniform symmetric Cauchy stress tensor $ \\boldsymbol{\\sigma} $ in pascals.\n- Test case 1 (happy path, convex square mesh):\n  - Nodes: $ [(0,0), (1,0), (1,1), (0,1)] $.\n  - Elements (0-based node indices): $ [(0,1,2), (0,2,3)] $.\n  - Stress $\\boldsymbol{\\sigma}$: $\\begin{bmatrix} 2.0\\times 10^6  0.5\\times 10^6 \\\\ 0.5\\times 10^6  1.0\\times 10^6 \\end{bmatrix}$ Pa.\n- Test case 2 (skewed quadrilateral mesh):\n  - Nodes: $ [(0.0,0.0), (2.0,0.2), (2.2,1.0), (0.3,1.2)] $.\n  - Elements: $ [(0,1,2), (0,2,3)] $.\n  - Stress $\\boldsymbol{\\sigma}$: $\\begin{bmatrix} 0.0  3.0\\times 10^6 \\\\ 3.0\\times 10^6  0.0 \\end{bmatrix}$ Pa.\n- Test case 3 (single triangle, boundary-like case):\n  - Nodes: $ [(0.0,0.0), (2.0,0.0), (0.0,1.0)] $.\n  - Elements: $ [(0,1,2)] $.\n  - Stress $\\boldsymbol{\\sigma}$: $\\begin{bmatrix} 1.0\\times 10^6  0.0 \\\\ 0.0  1.0\\times 10^6 \\end{bmatrix}$ Pa.\n- Test case 4 (skinny near-degenerate triangles):\n  - Nodes: $ [(0.0,0.0), (1.0,1.0\\times 10^{-8}), (1.0,0.0), (0.5,1.0\\times 10^{-8})] $.\n  - Elements: $ [(0,1,2), (0,2,3)] $.\n  - Stress $\\boldsymbol{\\sigma}$: $\\begin{bmatrix} 4.0\\times 10^6  2.0\\times 10^6 \\\\ 2.0\\times 10^6  0.5\\times 10^6 \\end{bmatrix}$ Pa.\n\nRequired output:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case result is itself a two-entry list $ [\\mathrm{force\\_zero}, \\mathrm{moment\\_zero}] $ of booleans, where $ \\mathrm{force\\_zero} $ is true if $ \\| \\boldsymbol{F} \\|_2  10^{-9} $ N and $ \\mathrm{moment\\_zero} $ is true if $ |M_z|  10^{-9} $ N·m. For example: $ [[\\mathrm{true},\\mathrm{true}],[\\mathrm{true},\\mathrm{true}],\\dots] $.", "solution": "The problem statement is a valid exercise in computational solid mechanics, specifically a constant-stress patch test for linear triangular elements. It is scientifically grounded, well-posed, and provides all necessary information to proceed with a solution.\n\nThe solution is derived from the principle of virtual work, which states that the internal virtual work done by stresses is equal to the external virtual work done by applied forces for a body in equilibrium. For a continuum domain $\\Omega$ with no body forces, the internal virtual work $\\delta W_{\\text{int}}$ is given by:\n$$\n\\delta W_{\\text{int}} = \\int_{\\Omega} \\boldsymbol{\\sigma} : \\delta\\boldsymbol{\\varepsilon} \\, dV\n$$\nwhere $\\boldsymbol{\\sigma}$ is the Cauchy stress tensor and $\\delta\\boldsymbol{\\varepsilon}$ is the virtual strain tensor.\n\nIn the finite element method, the domain $\\Omega$ is discretized into elements. Within each element $\\Omega_e$, the displacement field $\\boldsymbol{u}$ is interpolated from the nodal displacements $\\boldsymbol{d}^e$ using a matrix of shape functions $\\boldsymbol{N}$:\n$$\n\\boldsymbol{u}(\\boldsymbol{x}) = \\boldsymbol{N}(\\boldsymbol{x}) \\boldsymbol{d}^e\n$$\nThe small strain tensor $\\boldsymbol{\\varepsilon}$ is related to the nodal displacements by the strain-displacement matrix $\\boldsymbol{B}$:\n$$\n\\boldsymbol{\\varepsilon}(\\boldsymbol{x}) = \\boldsymbol{B}(\\boldsymbol{x}) \\boldsymbol{d}^e\n$$\nThe virtual strain is then $\\delta\\boldsymbol{\\varepsilon} = \\boldsymbol{B} \\delta\\boldsymbol{d}^e$. Substituting this into the virtual work expression and expressing the tensor dot product using Voigt notation (where stresses $\\boldsymbol{\\sigma}$ and strains $\\boldsymbol{\\varepsilon}$ are represented as vectors) gives:\n$$\n\\delta W_{\\text{int}}^e = \\int_{\\Omega_e} (\\delta\\boldsymbol{d}^e)^T \\boldsymbol{B}^T \\boldsymbol{\\sigma} \\, dV = (\\delta\\boldsymbol{d}^e)^T \\left( \\int_{\\Omega_e} \\boldsymbol{B}^T \\boldsymbol{\\sigma} \\, dV \\right)\n$$\nThe internal virtual work is also defined as the work done by the internal nodal forces $\\boldsymbol{f}_{\\text{int}}^e$:\n$$\n\\delta W_{\\text{int}}^e = (\\delta\\boldsymbol{d}^e)^T \\boldsymbol{f}_{\\text{int}}^e\n$$\nBy comparing the two expressions, the elemental internal force vector is:\n$$\n\\boldsymbol{f}_{\\text{int}}^e = \\int_{\\Omega_e} \\boldsymbol{B}^T \\boldsymbol{\\sigma} \\, dV\n$$\nFor a two-dimensional problem with unit thickness $h=1$, the volume integral becomes an area integral. For a linear triangular element, the gradient of the shape functions is constant, making the matrix $\\boldsymbol{B}$ constant. Given that the stress tensor $\\boldsymbol{\\sigma}$ is also uniform, the integral simplifies to:\n$$\n\\boldsymbol{f}_{\\text{int}}^e = A_e \\, h \\, \\boldsymbol{B}^T \\boldsymbol{\\sigma} = A_e \\boldsymbol{B}^T \\boldsymbol{\\sigma}\n$$\nwhere $A_e$ is the area of the element.\n\nA more direct approach avoids forming the full $\\boldsymbol{B}$ matrix. The force on a single node $i$ of an element, $\\boldsymbol{f}_i^e$, can be found by considering its contribution to the virtual work. This results in:\n$$\n\\boldsymbol{f}_i^e = \\int_{A_e} (\\nabla N_i)^T \\boldsymbol{\\sigma} \\, dA\n$$\nwhere $N_i$ is the shape function for node $i$. Since $\\nabla N_i$ and $\\boldsymbol{\\sigma}$ are constant, this is:\n$$\n\\boldsymbol{f}_i^e = A_e (\\nabla N_i)^T \\boldsymbol{\\sigma}\n$$\nThe gradient of the shape function $N_i$ for a linear triangle with vertices $(x_1, y_1)$, $(x_2, y_2)$, and $(x_3, y_3)$ is:\n$$\n\\nabla N_i = \\begin{pmatrix} \\frac{\\partial N_i}{\\partial x} \\\\ \\frac{\\partial N_i}{\\partial y} \\end{pmatrix} = \\frac{1}{2A_e} \\begin{pmatrix} b_i \\\\ c_i \\end{pmatrix}\n$$\nwhere $A_e = \\frac{1}{2} (x_1(y_2-y_3) + x_2(y_3-y_1) + x_3(y_1-y_2))$ is the signed area of the triangle, and the coefficients are:\n$$\n\\begin{array}{lll}\nb_1 = y_2 - y_3  \\quad  c_1 = x_3 - x_2 \\\\\nb_2 = y_3 - y_1  \\quad  c_2 = x_1 - x_3 \\\\\nb_3 = y_1 - y_2  \\quad  c_3 = x_2 - x_1\n\\end{array}\n$$\nThe stress tensor is $\\boldsymbol{\\sigma} = \\begin{pmatrix} \\sigma_{xx}  \\sigma_{xy} \\\\ \\sigma_{yx}  \\sigma_{yy} \\end{pmatrix}$. Since it is symmetric, $\\sigma_{xy} = \\sigma_{yx}$.\nThe force vector $\\boldsymbol{f}_i^e = (f_{ix}^e, f_{iy}^e)^T$ for node $i$ is calculated as:\n$$\n\\boldsymbol{f}_i^e = A_e \\begin{pmatrix} \\frac{\\partial N_i}{\\partial x}  \\frac{\\partial N_i}{\\partial y} \\end{pmatrix} \\begin{pmatrix} \\sigma_{xx}  \\sigma_{xy} \\\\ \\sigma_{xy}  \\sigma_{yy} \\end{pmatrix}\n= A_e \\begin{pmatrix} \\frac{\\partial N_i}{\\partial x} \\sigma_{xx} + \\frac{\\partial N_i}{\\partial y} \\sigma_{xy} \\\\ \\frac{\\partial N_i}{\\partial x} \\sigma_{xy} + \\frac{\\partial N_i}{\\partial y} \\sigma_{yy} \\end{pmatrix}\n$$\nSubstituting the expressions for the gradients:\n$$\nf_{ix}^e = A_e \\left( \\frac{b_i}{2A_e} \\sigma_{xx} + \\frac{c_i}{2A_e} \\sigma_{xy} \\right) = \\frac{1}{2} (b_i \\sigma_{xx} + c_i \\sigma_{xy})\n$$\n$$\nf_{iy}^e = A_e \\left( \\frac{b_i}{2A_e} \\sigma_{xy} + \\frac{c_i}{2A_e} \\sigma_{yy} \\right) = \\frac{1}{2} (b_i \\sigma_{xy} + c_i \\sigma_{yy})\n$$\nThe patch test requires verification of global equilibrium. The total internal force $\\boldsymbol{F}$ is the sum of all assembled nodal forces $\\boldsymbol{f}_a$:\n$$\n\\boldsymbol{F} = \\sum_a \\boldsymbol{f}_a = \\sum_a \\left( \\sum_{e \\in \\text{patch}(a)} \\boldsymbol{f}_{a,e} \\right) = \\sum_e \\sum_{i=1}^3 \\boldsymbol{f}_i^e\n$$\nThe sum of forces for a single element is zero because $\\sum_i b_i = (y_2 - y_3) + (y_3 - y_1) + (y_1 - y_2) = 0$ and $\\sum_i c_i = (x_3 - x_2) + (x_1 - x_3) + (x_2 - x_1) = 0$. Consequently, the total force $\\boldsymbol{F}$ for any patch of elements must be zero.\n\nThe total moment about the origin, $M_z$, is the sum of moments from all assembled nodal forces:\n$$\nM_z = \\sum_a (x_a f_{a,y} - y_a f_{a,x}) = \\sum_e \\sum_{i=1}^3 (x_i f_{iy}^e - y_i f_{ix}^e)\n$$\nwhere $(x_i, y_i)$ are the coordinates of the nodes of element $e$. It can be shown through algebraic manipulation that the moment contribution from a single element is zero: $\\sum_{i=1}^3 (x_i f_{iy}^e - y_i f_{ix}^e) = 0$. This relies on the identities $\\sum y_i b_i = 0$, $\\sum x_i c_i = 0$, and $\\sum x_i b_i = \\sum y_i c_i = 2A_e$. As a result, the total moment $M_z$ for any patch must also be zero.\n\nThe algorithm proceeds as follows for each test case:\n1. Initialize a global force vector for all nodes to zero.\n2. For each triangular element:\n    a. Identify the coordinates $(x_1, y_1), (x_2, y_2), (x_3, y_3)$ of its three nodes.\n    b. Compute the coefficients $b_i$ and $c_i$ for $i=1, 2, 3$.\n    c. Use the derived formulas to calculate the elemental nodal force components $(f_{ix}^e, f_{iy}^e)$ for each of the three nodes.\n    d. Add these elemental forces to the corresponding entries in the global force vector.\n3. After processing all elements, calculate the resultant force $\\boldsymbol{F}$ by summing all vectors in the global force vector. Check if its L2-norm, $\\|\\boldsymbol{F}\\|_2$, is less than the tolerance $10^{-9}$.\n4. Calculate the resultant moment $M_z$ by summing the cross products $\\boldsymbol{r}_a \\times \\boldsymbol{f}_a$ for all nodes. Check if its absolute value, $|M_z|$, is less than the tolerance $10^{-9}$.\n5. Record the boolean results for the force and moment checks.\n\nThis procedure rigorously tests whether the finite element formulation for linear triangles satisfies the fundamental conservation laws of linear and angular momentum for a constant stress state, which is a critical verification test for any finite element code.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Performs a constant-stress patch test on several 2D triangular meshes.\n    Verifies that the sum of internal nodal forces and the sum of moments of these\n    forces about the origin are numerically zero, as required by the principles\n    of conservation of linear and angular momentum for a body in equilibrium.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"nodes\": [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)],\n            \"elements\": [(0, 1, 2), (0, 2, 3)],\n            \"stress\": np.array([[2.0e6, 0.5e6], [0.5e6, 1.0e6]])\n        },\n        {\n            \"nodes\": [(0.0, 0.0), (2.0, 0.2), (2.2, 1.0), (0.3, 1.2)],\n            \"elements\": [(0, 1, 2), (0, 2, 3)],\n            \"stress\": np.array([[0.0, 3.0e6], [3.0e6, 0.0]])\n        },\n        {\n            \"nodes\": [(0.0, 0.0), (2.0, 0.0), (0.0, 1.0)],\n            \"elements\": [(0, 1, 2)],\n            \"stress\": np.array([[1.0e6, 0.0], [0.0, 1.0e6]])\n        },\n        {\n            \"nodes\": [(0.0, 0.0), (1.0, 1.0e-8), (1.0, 0.0), (0.5, 1.0e-8)],\n            \"elements\": [(0, 1, 2), (0, 2, 3)],\n            \"stress\": np.array([[4.0e6, 2.0e6], [2.0e6, 0.5e6]])\n        }\n    ]\n\n    results = []\n    \n    # Set the numerical tolerance.\n    tolerance = 1e-9\n\n    for case in test_cases:\n        nodes = np.array(case[\"nodes\"], dtype=np.float64)\n        elements = np.array(case[\"elements\"], dtype=np.int64)\n        stress = case[\"stress\"]\n        \n        num_nodes = len(nodes)\n        global_forces = np.zeros((num_nodes, 2), dtype=np.float64)\n\n        # Extract stress components\n        s_xx = stress[0, 0]\n        s_yy = stress[1, 1]\n        s_xy = stress[0, 1]  # Stress tensor is symmetric\n\n        # Loop over each element to calculate and assemble internal forces\n        for element_indices in elements:\n            # Get nodal coordinates for the current element\n            p1 = nodes[element_indices[0]]\n            p2 = nodes[element_indices[1]]\n            p3 = nodes[element_indices[2]]\n            \n            x1, y1 = p1\n            x2, y2 = p2\n            x3, y3 = p3\n            \n            # Calculate coefficients for shape function gradients\n            # b_i = y_j - y_k, c_i = x_k - x_j (for i,j,k in cyclic order)\n            b1 = y2 - y3\n            c1 = x3 - x2\n            \n            b2 = y3 - y1\n            c2 = x1 - x3\n            \n            b3 = y1 - y2\n            c3 = x2 - x1\n            \n            b_coeffs = [b1, b2, b3]\n            c_coeffs = [c1, c2, c3]\n\n            # Calculate elemental nodal forces\n            # f_ix = 0.5 * (b_i * sigma_xx + c_i * sigma_xy)\n            # f_iy = 0.5 * (b_i * sigma_xy + c_i * sigma_yy)\n            for i in range(3):\n                node_global_idx = element_indices[i]\n                b_i = b_coeffs[i]\n                c_i = c_coeffs[i]\n                \n                f_ix = 0.5 * (b_i * s_xx + c_i * s_xy)\n                f_iy = 0.5 * (b_i * s_xy + c_i * s_yy)\n                \n                # Assemble into global force vector\n                global_forces[node_global_idx, 0] += f_ix\n                global_forces[node_global_idx, 1] += f_iy\n\n        # --- Verification Step ---\n        \n        # 1. Check balance of linear momentum (resultant force)\n        total_force = np.sum(global_forces, axis=0)\n        force_magnitude = np.linalg.norm(total_force)\n        force_is_zero = force_magnitude  tolerance\n\n        # 2. Check balance of angular momentum (resultant moment about origin)\n        total_moment = 0.0\n        for i in range(num_nodes):\n            x_i, y_i = nodes[i]\n            f_ix, f_iy = global_forces[i]\n            total_moment += x_i * f_iy - y_i * f_ix\n            \n        moment_is_zero = abs(total_moment)  tolerance\n        \n        # Store results as strings 'true'/'false' for output formatting\n        results.append(f\"[{str(force_is_zero).lower()},{str(moment_is_zero).lower()}]\")\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3546843"}, {"introduction": "When we introduce inertia to our system, the discretization of mass becomes as important as the discretization of stiffness. This exercise [@problem_id:3546856] explores the profound impact of mass matrix choice on the conservation of angular momentum in dynamic finite element simulations. You will investigate the discrepancy between using a 'lumped' versus a 'consistent' mass matrix for a rotating body, a classic problem that reveals how seemingly minor implementation details can affect the physical fidelity of a simulation.", "problem": "You are to implement a program that examines how the choice of discrete mass representation in the Finite Element Method (FEM) affects the preservation of angular momentum during free rigid-body rotation, quantifies the error, and applies a correction. The focus is on the balance of linear and angular momentum for an elastic solid under free rotation, in which the kinematics reduce to rigid-body motion and internal elastic forces vanish in the absence of strain.\n\nThe fundamental base assumptions and laws to start from are:\n- Newton’s Second Law in integral form for a continuum: for any region with mass density $\\rho$, body force per unit mass $\\mathbf{b}$, traction $\\mathbf{t}$ on the boundary, and velocity field $\\mathbf{v}$,\n$$\\frac{d}{dt}\\int_{\\Omega}\\rho\\,\\mathbf{v}\\,d\\Omega = \\int_{\\Omega}\\rho\\,\\mathbf{b}\\,d\\Omega + \\int_{\\partial\\Omega}\\mathbf{t}\\,dS.$$\n- Balance of angular momentum in integral form:\n$$\\frac{d}{dt}\\int_{\\Omega}\\rho\\,\\mathbf{x}\\times\\mathbf{v}\\,d\\Omega = \\int_{\\Omega}\\rho\\,\\mathbf{x}\\times\\mathbf{b}\\,d\\Omega + \\int_{\\partial\\Omega}\\mathbf{x}\\times\\mathbf{t}\\,dS.$$\n- Free rigid-body rotation corresponds to $\\mathbf{b}=\\mathbf{0}$ and no boundary tractions, and the velocity field is $\\mathbf{v}(\\mathbf{x})=\\boldsymbol{\\omega}\\times(\\mathbf{x}-\\mathbf{x}_{\\mathrm{cm}})$, where $\\boldsymbol{\\omega}$ is the angular velocity vector and $\\mathbf{x}_{\\mathrm{cm}}$ is the center of mass.\n\nIn a discrete FEM setting for a mesh of linear triangles in a planar body of uniform thickness, the mass matrix can be constructed in two forms:\n- The consistent mass matrix $M$ defined by\n$$M=\\int_{\\Omega}\\rho\\,\\mathbf{N}\\mathbf{N}^{T}\\,d\\Omega,$$\nwith $\\mathbf{N}$ collecting the scalar shape functions, assembled in a block-diagonal manner for vector degrees of freedom.\n- The lumped mass vector $m$ obtained by diagonalizing the consistent mass so that the nodal mass is $m_{i}=\\sum_{j}M_{ij}$ for each scalar degree of freedom.\n\nDiscrete linear momentum for a velocity vector of nodal values $\\mathbf{v}_{h}$ is\n$$\\mathbf{p}_{\\mathrm{cons}} = M\\,\\mathbf{v}_{h},\\quad \\mathbf{p}_{\\mathrm{lump}} = \\mathrm{diag}(m)\\,\\mathbf{v}_{h}.$$\nThe discrete angular momentum about the center of mass $\\mathbf{x}_{\\mathrm{cm}}$ is computed as\n$$\\mathbf{L}_{\\mathrm{cons}} = \\sum_{a=1}^{N}\\left(\\mathbf{x}_{a}-\\mathbf{x}_{\\mathrm{cm}}\\right)\\times\\mathbf{p}_{\\mathrm{cons},a},\\quad \\mathbf{L}_{\\mathrm{lump}} = \\sum_{a=1}^{N}\\left(\\mathbf{x}_{a}-\\mathbf{x}_{\\mathrm{cm}}\\right)\\times\\mathbf{p}_{\\mathrm{lump},a},$$\nwhere $\\mathbf{x}_{a}$ are nodal positions and $\\mathbf{p}_{\\cdot,a}$ are the nodal momentum vectors.\n\nYour program must:\n1. Construct a planar mesh of a rectangle of width $W$ and height $H$, centered at the origin, discretized into $n_{x}\\times n_{y}$ rectangular cells, each split into two triangles. Assume uniform thickness $t$ and uniform density $\\rho$.\n2. Assemble the consistent mass contributions element-wise for linear triangles, using exact integration for the scalar mass submatrix\n$$M_{e}^{\\mathrm{scalar}}=\\rho\\,t\\,\\frac{A_{e}}{12}\\begin{bmatrix}211\\\\121\\\\112\\end{bmatrix},$$\nand block-diagonal assembly for vector degrees of freedom.\n3. Assemble the lumped mass per node using $m_{i} = \\rho\\,t\\,\\sum_{e\\ni i}\\frac{A_{e}}{3}$ (for each scalar degree of freedom, identical for the two in-plane directions).\n4. Initialize nodal velocities to a rigid-body field $\\mathbf{v}(\\mathbf{x})=\\boldsymbol{\\omega}\\times(\\mathbf{x}-\\mathbf{x}_{\\mathrm{cm}})$ with $\\boldsymbol{\\omega}=(0,0,\\omega_{z})$, where $\\omega_{z}$ is specified. Use the mass-weighted center of mass computed from the lumped masses for $\\mathbf{x}_{\\mathrm{cm}}$.\n5. Compute the discrete angular momenta $\\mathbf{L}_{\\mathrm{cons}}$ and $\\mathbf{L}_{\\mathrm{lump}}$ and report the relative error\n$$E=\\frac{\\left\\|\\mathbf{L}_{\\mathrm{lump}}-\\mathbf{L}_{\\mathrm{cons}}\\right\\|_{2}}{\\left\\|\\mathbf{L}_{\\mathrm{cons}}\\right\\|_{2}}.$$\n6. Propose and apply a correction: compute the lumped inertia tensor\n$$I_{\\mathrm{lump}}=\\sum_{a=1}^{N}m_{a}\\left(\\|\\mathbf{r}_{a}\\|^{2}I_{3}-\\mathbf{r}_{a}\\mathbf{r}_{a}^{T}\\right),\\quad \\mathbf{r}_{a}=\\mathbf{x}_{a}-\\mathbf{x}_{\\mathrm{cm}},$$\nsolve for a corrective angular velocity\n$$\\delta\\boldsymbol{\\omega}=I_{\\mathrm{lump}}^{-1}\\left(\\mathbf{L}_{\\mathrm{cons}}-\\mathbf{L}_{\\mathrm{lump}}\\right),$$\napply corrected velocities $\\mathbf{v}_{a}^{\\mathrm{corr}}=\\mathbf{v}_{a}+\\delta\\boldsymbol{\\omega}\\times\\mathbf{r}_{a}$, and recompute $\\mathbf{L}_{\\mathrm{lump}}^{\\mathrm{corr}}$. Report the corrected relative error\n$$E_{\\mathrm{corr}}=\\frac{\\left\\|\\mathbf{L}_{\\mathrm{lump}}^{\\mathrm{corr}}-\\mathbf{L}_{\\mathrm{cons}}\\right\\|_{2}}{\\left\\|\\mathbf{L}_{\\mathrm{cons}}\\right\\|_{2}}.$$\n\nPhysical units: use International System of Units (SI). Input parameters are in meters ($\\mathrm{m}$) for $W$ and $H$, kilograms per cubic meter ($\\mathrm{kg/m^{3}}$) for $\\rho$, meters ($\\mathrm{m}$) for $t$, and radians per second ($\\mathrm{rad/s}$) for $\\omega_{z}$. The outputs are dimensionless floats (relative errors), so no unit conversion is required.\n\nYour program should produce results for the following test suite of parameter values:\n- Test case 1 (happy path, coarse mesh): $W=1.0$, $H=1.0$, $n_{x}=2$, $n_{y}=2$, $\\rho=1.0$, $t=1.0$, $\\omega_{z}=3.0$.\n- Test case 2 (boundary case, single cell): $W=1.0$, $H=1.0$, $n_{x}=1$, $n_{y}=1$, $\\rho=1.0$, $t=1.0$, $\\omega_{z}=2.0$.\n- Test case 3 (anisotropic rectangle, moderate resolution): $W=2.0$, $H=0.5$, $n_{x}=20$, $n_{y}=5$, $\\rho=1.0$, $t=1.0$, $\\omega_{z}=1.5$.\n- Test case 4 (fine mesh, larger spin): $W=1.0$, $H=1.0$, $n_{x}=40$, $n_{y}=40$, $\\rho=1.0$, $t=1.0$, $\\omega_{z}=7.0$.\n\nFor each test case, compute and return a list of two floats $[E,E_{\\mathrm{corr}}]$.\n\nFinal output format: Your program should produce a single line of output containing the results for all test cases as a comma-separated list of lists enclosed in square brackets. For example: \"[[e1_before,e1_after],[e2_before,e2_after],...]\".", "solution": "The problem has been validated and is determined to be a well-posed, scientifically sound problem in computational solid mechanics. It addresses the consequences of different mass lumping schemes on the conservation of angular momentum in a Finite Element Method (FEM) simulation of a rigid body rotation. The provided methodology for quantification and correction is standard and correct. We will proceed with a detailed derivation of the computational steps.\n\nThe solution is implemented by following the sequence of tasks prescribed in the problem statement.\n\n1.  **Mesh Generation**\n    A rectangular domain of width $W$ and height $H$ is centered at the origin, so its corners are at $(\\pm W/2, \\pm H/2)$. This domain is discretized into a grid of $n_{x} \\times n_{y}$ rectangular cells. The nodes of the mesh are located at the grid points. The number of nodes is $N_{nodes}=(n_{x}+1)(n_{y}+1)$. The coordinates $(x_i, y_j)$ of a node at grid position $(i,j)$ are given by:\n    $$x_i = -\\frac{W}{2} + i \\frac{W}{n_x}, \\quad i=0, 1, \\dots, n_x$$\n    $$y_j = -\\frac{H}{2} + j \\frac{H}{n_y}, \\quad j=0, 1, \\dots, n_y$$\n    Each rectangular cell is then subdivided into two linear triangular elements. A consistent diagonal splitting pattern is used across all cells, for example, connecting the bottom-left corner to the top-right corner of each cell. This process generates $2 \\times n_x \\times n_y$ triangular elements. The area of each triangle, $A_e$, is constant for this structured mesh:\n    $$A_e = \\frac{1}{2}\\left(\\frac{W}{n_x}\\right)\\left(\\frac{H}{n_y}\\right)$$\n\n2.  **Consistent Mass Matrix Assembly**\n    The problem involves planar motion, with two degrees of freedom (DOFs) per node (one for each Cartesian direction $x$ and $y$). The total number of DOFs is $N_{dof} = 2 N_{nodes}$. The consistent mass matrix $M$ is assembled from element-level contributions. For a linear triangle, the scalar element mass matrix is given as:\n    $$M_{e}^{\\mathrm{scalar}}=\\rho t \\frac{A_{e}}{12}\\begin{bmatrix}211\\\\121\\\\112\\end{bmatrix}$$\n    where $\\rho$ is the density and $t$ is the thickness. For vector DOFs, assuming no mass coupling between $x$ and $y$ directions, the global mass matrix $M$ is constructed by assembling a scalar mass matrix $M_s$ of size $N_{nodes} \\times N_{nodes}$ and then populating the full $N_{dof} \\times N_{dof}$ matrix such that $M_{2i,2j} = M_{2i+1,2j+1} = (M_s)_{ij}$ and $M_{2i,2j+1} = M_{2i+1,2j} = 0$. The matrix $M_s$ is built using a standard FEM assembly procedure, summing contributions from $M_{e}^{\\mathrm{scalar}}$ for all elements into the global matrix according to node connectivity.\n\n3.  **Lumped Mass Assembly**\n    The lumped mass matrix is a diagonal matrix. The scalar mass $m_a$ at each node $a$ is obtained by summing the entries in the corresponding row of the scalar consistent mass matrix $M_s$:\n    $$m_a = \\sum_{j=1}^{N_{nodes}} (M_s)_{aj}$$\n    This is equivalent to the provided formula $m_a = \\rho t \\sum_{e \\ni a} \\frac{A_e}{3}$. The lumped mass matrix $M_{\\mathrm{lump}}$ is a diagonal matrix of size $N_{dof} \\times N_{dof}$ where the diagonal entries for node $a$ are both equal to $m_a$.\n\n4.  **Velocity Initialization**\n    First, the center of mass $\\mathbf{x}_{\\mathrm{cm}}$ is computed using the lumped nodal masses:\n    $$\\mathbf{x}_{\\mathrm{cm}} = \\frac{\\sum_{a=1}^{N_{nodes}} m_a \\mathbf{x}_a}{\\sum_{a=1}^{N_{nodes}} m_a}$$\n    Due to the symmetry of the mesh and uniform density, the calculated $\\mathbf{x}_{\\mathrm{cm}}$ will be at the origin $(0,0)$. The nodal velocity vector $\\mathbf{v}_h$ is initialized to represent a rigid body rotation with angular velocity $\\boldsymbol{\\omega}=(0,0,\\omega_z)$ about this center of mass. For each node $a$ with position vector $\\mathbf{x}_a$, the velocity $\\mathbf{v}_a$ is:\n    $$\\mathbf{v}_a = \\boldsymbol{\\omega} \\times (\\mathbf{x}_a - \\mathbf{x}_{\\mathrm{cm}})$$\n    In component form, with $\\mathbf{r}_a = \\mathbf{x}_a - \\mathbf{x}_{\\mathrm{cm}} = (r_{ax}, r_{ay})$, the velocity is $\\mathbf{v}_a = (-\\omega_z r_{ay}, \\omega_z r_{ax})$. These values populate the global velocity vector $\\mathbf{v}_h$.\n\n5.  **Angular Momentum and Error Calculation**\n    The nodal linear momentum vectors are computed for both mass representations:\n    $$\\mathbf{p}_{\\mathrm{cons}} = M \\mathbf{v}_h \\quad \\text{and} \\quad \\mathbf{p}_{\\mathrm{lump}} = M_{\\mathrm{lump}} \\mathbf{v}_h$$\n    The total discrete angular momentum about $\\mathbf{x}_{\\mathrm{cm}}$ is then calculated by summing the contributions from each node $a$:\n    $$\\mathbf{L}_{\\mathrm{cons}} = \\sum_{a=1}^{N_{nodes}} \\mathbf{r}_a \\times \\mathbf{p}_{\\mathrm{cons},a}$$\n    $$\\mathbf{L}_{\\mathrm{lump}} = \\sum_{a=1}^{N_{nodes}} \\mathbf{r}_a \\times \\mathbf{p}_{\\mathrm{lump},a}$$\n    where $\\mathbf{p}_{\\cdot,a}$ is the $2$D linear momentum vector for node $a$. For this planar problem, the angular momentum vectors will only have a non-zero $z$-component. The relative error $E$ is computed as:\n    $$E = \\frac{\\|\\mathbf{L}_{\\mathrm{lump}} - \\mathbf{L}_{\\mathrm{cons}}\\|_2}{\\|\\mathbf{L}_{\\mathrm{cons}}\\|_2}$$\n\n6.  **Correction Procedure**\n    To correct the lumped mass angular momentum, a corrective velocity field is applied. First, the lumped inertia tensor $I_{\\mathrm{lump}}$ is computed. It represents the moment of inertia of the system of lumped masses:\n    $$I_{\\mathrm{lump}}=\\sum_{a=1}^{N_{nodes}} m_a (\\|\\mathbf{r}_a\\|^2 I_3 - \\mathbf{r}_a \\mathbf{r}_a^T)$$\n    where $I_3$ is the $3 \\times 3$ identity matrix and $\\mathbf{r}_a$ are $3$D position vectors (with $z=0$). The angular momentum discrepancy $\\Delta \\mathbf{L} = \\mathbf{L}_{\\mathrm{cons}} - \\mathbf{L}_{\\mathrm{lump}}$ is used to find a corrective angular velocity $\\delta \\boldsymbol{\\omega}$ by solving the linear system:\n    $$I_{\\mathrm{lump}} \\, \\delta\\boldsymbol{\\omega} = \\Delta \\mathbf{L}$$\n    The nodal velocities are then corrected:\n    $$\\mathbf{v}_{a}^{\\mathrm{corr}} = \\mathbf{v}_a + \\delta\\boldsymbol{\\omega} \\times \\mathbf{r}_a$$\n    Using the corrected velocity vector $\\mathbf{v}_h^{\\mathrm{corr}}$, the lumped angular momentum is recomputed, yielding $\\mathbf{L}_{\\mathrm{lump}}^{\\mathrm{corr}}$. By construction, $\\mathbf{L}_{\\mathrm{lump}}^{\\mathrm{corr}}$ should be equal to $\\mathbf{L}_{\\mathrm{cons}}$. The final corrected relative error, $E_{\\mathrm{corr}}$, is calculated, which is expected to be near machine precision zero.\n    $$E_{\\mathrm{corr}} = \\frac{\\|\\mathbf{L}_{\\mathrm{lump}}^{\\mathrm{corr}} - \\mathbf{L}_{\\mathrm{cons}}\\|_2}{\\|\\mathbf{L}_{\\mathrm{cons}}\\|_2}$$\nThe results for each test case consist of the pair $[E, E_{\\mathrm{corr}}]$.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    \n    def solve_case(W, H, nx, ny, rho, t, omega_z):\n        \"\"\"\n        Computes the angular momentum errors for a single test case.\n\n        Args:\n            W (float): Width of the rectangle.\n            H (float): Height of the rectangle.\n            nx (int): Number of cells in the x-direction.\n            ny (int): Number of cells in the y-direction.\n            rho (float): Material density.\n            t (float): Thickness of the planar body.\n            omega_z (float): Angular velocity about the z-axis.\n\n        Returns:\n            list[float, float]: A list containing the initial relative error E and the corrected relative error E_corr.\n        \"\"\"\n        # 1. Mesh Generation\n        num_nodes = (nx + 1) * (ny + 1)\n        nodes = np.zeros((num_nodes, 2), dtype=np.float64)\n        node_map = {}\n        k = 0\n        dx, dy = W / nx, H / ny\n        for j in range(ny + 1):\n            for i in range(nx + 1):\n                nodes[k] = [-W/2 + i * dx, -H/2 + j * dy]\n                node_map[(i, j)] = k\n                k += 1\n\n        elements = []\n        for j in range(ny):\n            for i in range(nx):\n                n1 = node_map[(i, j)]\n                n2 = node_map[(i + 1, j)]\n                n3 = node_map[(i + 1, j + 1)]\n                n4 = node_map[(i, j + 1)]\n                elements.append([n1, n2, n3])\n                elements.append([n1, n3, n4])\n\n        Ae = 0.5 * dx * dy\n\n        # 2. Consistent Mass Matrix Assembly\n        M_scalar = np.zeros((num_nodes, num_nodes), dtype=np.float64)\n        M_element_scalar = (rho * t * Ae / 12.0) * np.array([[2, 1, 1], [1, 2, 1], [1, 1, 2]])\n        for el_nodes in elements:\n            for i_local in range(3):\n                for j_local in range(3):\n                    i_global = el_nodes[i_local]\n                    j_global = el_nodes[j_local]\n                    M_scalar[i_global, j_global] += M_element_scalar[i_local, j_local]\n\n        num_dofs = 2 * num_nodes\n        M_consistent = np.zeros((num_dofs, num_dofs), dtype=np.float64)\n        for i in range(num_nodes):\n            for j in range(num_nodes):\n                M_consistent[2*i, 2*j] = M_scalar[i, j]\n                M_consistent[2*i+1, 2*j+1] = M_scalar[i, j]\n\n        # 3. Lumped Mass Assembly\n        m_scalar = np.sum(M_scalar, axis=1)\n        M_lumped_diag = np.zeros(num_dofs, dtype=np.float64)\n        for i in range(num_nodes):\n            M_lumped_diag[2*i] = m_scalar[i]\n            M_lumped_diag[2*i+1] = m_scalar[i]\n\n        # 4. Velocity Initialization\n        # Center of mass is (0,0) by symmetry. Using analytical result avoids float precision issues.\n        x_cm = np.array([0.0, 0.0])\n        r_nodes = nodes - x_cm\n        v_h = np.zeros(num_dofs, dtype=np.float64)\n        for i in range(num_nodes):\n            v_h[2*i]   = -omega_z * r_nodes[i, 1]\n            v_h[2*i+1] =  omega_z * r_nodes[i, 0]\n\n        # 5. Angular Momentum and Error Calculation\n        p_cons = M_consistent @ v_h\n        p_lump = M_lumped_diag * v_h\n\n        L_cons_z = np.sum(r_nodes[:, 0] * p_cons[1::2] - r_nodes[:, 1] * p_cons[0::2])\n        L_lump_z = np.sum(r_nodes[:, 0] * p_lump[1::2] - r_nodes[:, 1] * p_lump[0::2])\n        \n        L_cons_vec = np.array([0.0, 0.0, L_cons_z])\n        L_lump_vec = np.array([0.0, 0.0, L_lump_z])\n        \n        norm_L_cons = np.linalg.norm(L_cons_vec)\n        error = np.linalg.norm(L_lump_vec - L_cons_vec) / norm_L_cons if norm_L_cons > 0 else 0.0\n\n        # 6. Correction Procedure\n        I_lump = np.zeros((3, 3), dtype=np.float64)\n        r_nodes_3d = np.hstack([r_nodes, np.zeros((num_nodes, 1), dtype=np.float64)])\n        for i in range(num_nodes):\n            r_vec = r_nodes_3d[i, :]\n            I_node = m_scalar[i] * (np.dot(r_vec, r_vec) * np.eye(3) - np.outer(r_vec, r_vec))\n            I_lump += I_node\n        \n        delta_L = L_cons_vec - L_lump_vec\n        \n        try:\n            delta_omega_vec = np.linalg.solve(I_lump, delta_L)\n        except np.linalg.LinAlgError:\n            delta_omega_vec = np.zeros(3)\n\n        v_h_corr = np.copy(v_h)\n        for i in range(num_nodes):\n            v_corr_delta = np.cross(delta_omega_vec, r_nodes_3d[i, :])\n            v_h_corr[2*i]   += v_corr_delta[0]\n            v_h_corr[2*i+1] += v_corr_delta[1]\n            \n        p_lump_corr = M_lumped_diag * v_h_corr\n        \n        L_lump_corr_z = np.sum(r_nodes[:, 0] * p_lump_corr[1::2] - r_nodes[:, 1] * p_lump_corr[0::2])\n        L_lump_corr_vec = np.array([0.0, 0.0, L_lump_corr_z])\n\n        error_corr = np.linalg.norm(L_lump_corr_vec - L_cons_vec) / norm_L_cons if norm_L_cons > 0 else 0.0\n            \n        return [error, error_corr]\n\n    test_cases = [\n        (1.0, 1.0, 2, 2, 1.0, 1.0, 3.0),\n        (1.0, 1.0, 1, 1, 1.0, 1.0, 2.0),\n        (2.0, 0.5, 20, 5, 1.0, 1.0, 1.5),\n        (1.0, 1.0, 40, 40, 1.0, 1.0, 7.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_case(*case)\n        results.append(result)\n\n    print(f\"[{','.join(str(r) for r in results)}]\")\n\nsolve()\n```", "id": "3546856"}, {"introduction": "The balance laws for linear and angular momentum provide a clear separation of concerns: forces govern translational motion, and torques govern rotational motion. This hands-on practice [@problem_id:3546907] implements a critical verification test for any rigid body dynamics simulator based on this principle. By applying a pure couple—a set of forces with a zero resultant but a non-zero net moment—you will verify that the simulated body undergoes purely rotational motion, providing confidence that the code correctly implements these two fundamental laws.", "problem": "Consider a free rigid body in three-dimensional Euclidean space with mass $m$ and constant inertia tensor in the body frame $[\\mathbf{I}_b]$. The body’s translational state is given by its center-of-mass position $\\mathbf{x}(t)$ and velocity $\\mathbf{v}(t)$, and its rotational state is given by an orientation $\\mathbf{q}(t)$ represented by a unit quaternion and an angular velocity $\\boldsymbol{\\omega}(t)$ in the inertial (world) frame. External forces $\\mathbf{F}_i$ are applied at body-fixed points $\\mathbf{r}_{b,i}$ relative to the center of mass. The rotation matrix $\\mathbf{R}(t)$ maps body-frame vectors to world-frame vectors, so the world-frame application points are $\\mathbf{r}_i(t) = \\mathbf{R}(t)\\,\\mathbf{r}_{b,i}$.\n\nFundamental base:\n- Balance of linear momentum: $\\dfrac{d\\mathbf{P}}{dt} = \\sum_i \\mathbf{F}_i$, where $\\mathbf{P} = m\\,\\mathbf{v}$ is the linear momentum.\n- Balance of angular momentum about the center of mass: $\\dfrac{d\\mathbf{H}}{dt} = \\sum_i \\left(\\mathbf{r}_i(t) \\times \\mathbf{F}_i\\right)$, where $\\mathbf{H}$ is the angular momentum in the world frame.\n- Kinematic relations: $\\mathbf{P} = m\\,\\mathbf{v}$ and, in the world frame, $\\mathbf{H}(t) = \\mathbf{I}(t)\\,\\boldsymbol{\\omega}(t)$ with $\\mathbf{I}(t) = \\mathbf{R}(t)\\,[\\mathbf{I}_b]\\,\\mathbf{R}(t)^\\top$. The quaternion $\\mathbf{q}(t)$ evolves consistently with $\\boldsymbol{\\omega}(t)$ so that $\\|\\mathbf{q}(t)\\| = 1$. All angles must be interpreted in radians.\n\nObjective:\nDesign and implement a computational test to detect code bugs related to the balance of linear and angular momentum by applying equal and opposite forces at different points to create a net couple (pure moment) with zero resultant force. Verify, for various parameter sets, that only angular motion occurs: the linear momentum $\\mathbf{P}(t)$ and the center-of-mass velocity $\\mathbf{v}(t)$ remain zero (within a tight numerical tolerance), while the angular momentum $\\mathbf{H}(t)$ changes over time.\n\nImplementation requirements:\n- Use a time-stepping scheme that directly enforces the fundamental balances stated above. At each time step, compute the net force $\\sum_i \\mathbf{F}_i$ and net moment $\\sum_i (\\mathbf{r}_i(t) \\times \\mathbf{F}_i)$, update $\\mathbf{P}$ and $\\mathbf{H}$ through time integration, obtain $\\boldsymbol{\\omega}(t)$ by solving $\\mathbf{I}(t)\\,\\boldsymbol{\\omega}(t) = \\mathbf{H}(t)$, and advance $\\mathbf{q}(t)$ while maintaining unit norm.\n- Start from rest: $\\mathbf{v}(0) = \\mathbf{0}$, $\\boldsymbol{\\omega}(0) = \\mathbf{0}$, $\\mathbf{P}(0) = \\mathbf{0}$, $\\mathbf{H}(0) = \\mathbf{0}$, and identity orientation $\\mathbf{q}(0)$.\n- Use the International System of Units (SI): mass in $\\mathrm{kg}$, length in $\\mathrm{m}$, time in $\\mathrm{s}$, force in $\\mathrm{N}$, angular momentum in $\\mathrm{kg\\,m^2/s}$, and linear momentum in $\\mathrm{kg\\,m/s}$.\n- Let the numerical tolerances be $\\,\\varepsilon_P = 10^{-12}\\,\\mathrm{kg\\,m/s}$ for linear momentum magnitude, $\\,\\varepsilon_v = 10^{-12}\\,\\mathrm{m/s}$ for center-of-mass speed, and require a minimum angular momentum change magnitude $\\Delta H_{\\min} = 10^{-6}\\,\\mathrm{kg\\,m^2/s}$ to assert that angular motion has occurred.\n\nAcceptance criterion for each test case:\n- Compute $\\|\\mathbf{P}(T)\\|$ and $\\|\\mathbf{v}(T)\\|$ at the final time $T$. Compute $\\Delta H = \\|\\mathbf{H}(T) - \\mathbf{H}(0)\\|$. Declare the test case as passing (boolean true) if simultaneously $\\|\\mathbf{P}(T)\\| \\le \\varepsilon_P$, $\\|\\mathbf{v}(T)\\| \\le \\varepsilon_v$, and $\\Delta H \\ge \\Delta H_{\\min}$. Otherwise, declare it failing (boolean false).\n\nTest suite:\nUse the following five parameter sets. In each case, the body-frame inertia is diagonal $[\\mathbf{I}_b] = \\mathrm{diag}(I_x, I_y, I_z)$, time step $\\Delta t$, and duration $T$ are provided. All angles are in radians.\n\n- Case $1$ (pure couple, noncolinear lever arm and force):\n  - $m = 2.5\\,\\mathrm{kg}$, $I_x = 0.3\\,\\mathrm{kg\\,m^2}$, $I_y = 0.5\\,\\mathrm{kg\\,m^2}$, $I_z = 0.7\\,\\mathrm{kg\\,m^2}$.\n  - $\\mathbf{r}_{b,1} = [0.15,\\,0,\\,0]\\,\\mathrm{m}$, $\\mathbf{r}_{b,2} = [-0.15,\\,0,\\,0]\\,\\mathrm{m}$.\n  - $\\mathbf{F}_1 = [0,\\,0,\\,8]\\,\\mathrm{N}$, $\\mathbf{F}_2 = -\\mathbf{F}_1$.\n  - $\\Delta t = 0.001\\,\\mathrm{s}$, $T = 0.25\\,\\mathrm{s}$.\n- Case $2$ (degenerate couple, forces at the same point):\n  - $m = 2.5\\,\\mathrm{kg}$, $I_x = 0.3\\,\\mathrm{kg\\,m^2}$, $I_y = 0.5\\,\\mathrm{kg\\,m^2}$, $I_z = 0.7\\,\\mathrm{kg\\,m^2}$.\n  - $\\mathbf{r}_{b,1} = [0.15,\\,0,\\,0]\\,\\mathrm{m}$, $\\mathbf{r}_{b,2} = [0.15,\\,0,\\,0]\\,\\mathrm{m}$.\n  - $\\mathbf{F}_1 = [0,\\,0,\\,8]\\,\\mathrm{N}$, $\\mathbf{F}_2 = -\\mathbf{F}_1$.\n  - $\\Delta t = 0.001\\,\\mathrm{s}$, $T = 0.25\\,\\mathrm{s}$.\n- Case $3$ (colinear lines of action, zero moment):\n  - $m = 2.5\\,\\mathrm{kg}$, $I_x = 0.3\\,\\mathrm{kg\\,m^2}$, $I_y = 0.5\\,\\mathrm{kg\\,m^2}$, $I_z = 0.7\\,\\mathrm{kg\\,m^2}$.\n  - $\\mathbf{r}_{b,1} = [0,\\,0,\\,0.2]\\,\\mathrm{m}$, $\\mathbf{r}_{b,2} = [0,\\,0,\\,-0.2]\\,\\mathrm{m}$.\n  - $\\mathbf{F}_1 = [0,\\,0,\\,5]\\,\\mathrm{N}$, $\\mathbf{F}_2 = -\\mathbf{F}_1$.\n  - $\\Delta t = 0.001\\,\\mathrm{s}$, $T = 0.25\\,\\mathrm{s}$.\n- Case $4$ (near-couple with small resultant force, should fail the criterion):\n  - $m = 2.5\\,\\mathrm{kg}$, $I_x = 0.3\\,\\mathrm{kg\\,m^2}$, $I_y = 0.5\\,\\mathrm{kg\\,m^2}$, $I_z = 0.7\\,\\mathrm{kg\\,m^2}$.\n  - $\\mathbf{r}_{b,1} = [0.15,\\,0,\\,0]\\,\\mathrm{m}$, $\\mathbf{r}_{b,2} = [-0.15,\\,0,\\,0]\\,\\mathrm{m}$.\n  - $\\mathbf{F}_1 = [0,\\,0,\\,8]\\,\\mathrm{N}$, $\\mathbf{F}_2 = -(1 - 0.02)\\,\\mathbf{F}_1$.\n  - $\\Delta t = 0.001\\,\\mathrm{s}$, $T = 0.25\\,\\mathrm{s}$.\n- Case $5$ (pure couple with general non-axis-aligned forces and lever arms):\n  - $m = 1.2\\,\\mathrm{kg}$, $I_x = 0.4\\,\\mathrm{kg\\,m^2}$, $I_y = 0.4\\,\\mathrm{kg\\,m^2}$, $I_z = 0.6\\,\\mathrm{kg\\,m^2}$.\n  - $\\mathbf{r}_{b,1} = [0.1,\\,0.05,\\,0]\\,\\mathrm{m}$, $\\mathbf{r}_{b,2} = [-0.05,\\,-0.02,\\,0.03]\\,\\mathrm{m}$.\n  - $\\mathbf{F}_1 = [5,\\,-3,\\,4]\\,\\mathrm{N}$, $\\mathbf{F}_2 = -\\mathbf{F}_1$.\n  - $\\Delta t = 0.001\\,\\mathrm{s}$, $T = 0.25\\,\\mathrm{s}$.\n\nYour program must run these five cases, evaluate the acceptance criterion for each, and produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[\\mathrm{True},\\mathrm{False},\\ldots]$). The expected outputs are booleans, one per test case, in the order of the cases above. No other text should be printed.", "solution": "The problem is first validated to ensure it is scientifically sound, well-posed, and complete.\n\n### Step 1: Extract Givens\n- **System**: A free rigid body with mass $m$ and a constant body-frame inertia tensor $[\\mathbf{I}_b]$.\n- **State Variables**: Center-of-mass position $\\mathbf{x}(t)$ and velocity $\\mathbf{v}(t)$; orientation as a unit quaternion $\\mathbf{q}(t)$ and inertial-frame angular velocity $\\boldsymbol{\\omega}(t)$.\n- **Dynamics**:\n    - Linear Momentum: $\\mathbf{P} = m\\,\\mathbf{v}$, with $\\dfrac{d\\mathbf{P}}{dt} = \\sum_i \\mathbf{F}_i$.\n    - Angular Momentum: $\\mathbf{H}(t) = \\mathbf{I}(t)\\,\\boldsymbol{\\omega}(t)$, with $\\dfrac{d\\mathbf{H}}{dt} = \\sum_i (\\mathbf{r}_i(t) \\times \\mathbf{F}_i)$.\n    - Inertia Tensor Transformation: $\\mathbf{I}(t) = \\mathbf{R}(t)\\,[\\mathbf{I}_b]\\,\\mathbf{R}(t)^\\top$, where $\\mathbf{R}(t)$ is the rotation matrix corresponding to $\\mathbf{q}(t)$.\n    - Force Application Points: $\\mathbf{r}_i(t) = \\mathbf{R}(t)\\,\\mathbf{r}_{b,i}$, where $\\mathbf{r}_{b,i}$ are body-fixed points.\n- **Initial Conditions**: The body starts from rest at $t=0$, i.e., $\\mathbf{v}(0) = \\mathbf{0}$, $\\boldsymbol{\\omega}(0) = \\mathbf{0}$, which implies $\\mathbf{P}(0) = \\mathbf{0}$ and $\\mathbf{H}(0) = \\mathbf{0}$. The initial orientation $\\mathbf{q}(0)$ is the identity orientation.\n- **Objective**: Implement a computational test to verify that applying a pure moment (zero net force) results in purely angular motion.\n- **Numerical Implementation**: A time-stepping scheme is required. At each time step, net force and moment are computed, $\\mathbf{P}$ and $\\mathbf{H}$ are updated via integration, $\\boldsymbol{\\omega}(t)$ is found by solving $\\mathbf{I}(t)\\,\\boldsymbol{\\omega}(t) = \\mathbf{H}(t)$, and $\\mathbf{q}(t)$ is advanced.\n- **Acceptance Criterion**: For a final time $T$, a test case passes if $\\|\\mathbf{P}(T)\\| \\le \\varepsilon_P$, $\\|\\mathbf{v}(T)\\| \\le \\varepsilon_v$, and $\\Delta H = \\|\\mathbf{H}(T) - \\mathbf{H}(0)\\| \\ge \\Delta H_{\\min}$.\n- **Tolerances**: $\\varepsilon_P = 10^{-12}\\,\\mathrm{kg\\,m/s}$, $\\varepsilon_v = 10^{-12}\\,\\mathrm{m/s}$, $\\Delta H_{\\min} = 10^{-6}\\,\\mathrm{kg\\,m^2/s}$.\n- **Test Cases**: Five distinct parameter sets are provided, specifying $m$, $[\\mathbf{I}_b]$, force application points $\\mathbf{r}_{b,i}$, forces $\\mathbf{F}_i$, time step $\\Delta t$, and total time $T$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is scientifically grounded in the Newton-Euler equations of classical rigid body mechanics. All specified equations, such as the transformation of the inertia tensor and the definitions of linear and angular momentum, are standard and correct. The problem is well-posed, providing a complete set of initial conditions, governing differential equations (implicitly), and parameters for an initial value problem. The language is objective and precise. The provided data are dimensionally consistent and physically realistic. The task is a standard exercise in computational dynamics, requiring the implementation of a numerical integrator for the equations of motion. The problem is non-trivial and its solution is algorithmically verifiable.\n\n### Step 3: Verdict and Action\nThe problem is deemed valid. A solution will be provided.\n\n### Principle-Based Solution Design\nThe solution involves numerically integrating the equations of motion for a rigid body over a specified time interval $T$. The state of the rigid body can be described by its linear momentum $\\mathbf{P}$, angular momentum $\\mathbf{H}$, and orientation quaternion $\\mathbf{q}$. The center-of-mass position $\\mathbf{x}$ is not needed for the verification.\n\n**1. Governing Equations:**\nThe fundamental principles are the balances of linear and angular momentum.\nThe rate of change of linear momentum is equal to the net external force:\n$$ \\frac{d\\mathbf{P}}{dt} = \\mathbf{F}_{net} = \\sum_{i} \\mathbf{F}_i $$\nThe rate of change of angular momentum about the center of mass is equal to the net external torque (moment):\n$$ \\frac{d\\mathbf{H}}{dt} = \\boldsymbol{\\tau}_{net} = \\sum_{i} (\\mathbf{r}_i(t) \\times \\mathbf{F}_i) $$\nThe orientation of the body is represented by a unit quaternion $\\mathbf{q}(t) = [q_w, q_x, q_y, q_z]^\\top$. Its rate of change is governed by the kinematic equation relating it to the world-frame angular velocity $\\boldsymbol{\\omega}(t)$:\n$$ \\frac{d\\mathbf{q}}{dt} = \\frac{1}{2} \\mathbf{q} \\otimes \\mathbf{p}(\\boldsymbol{\\omega}) $$\nwhere $\\mathbf{p}(\\boldsymbol{\\omega}) = [0, \\omega_x, \\omega_y, \\omega_z]^\\top$ is the pure quaternion representation of $\\boldsymbol{\\omega}$, and $\\otimes$ denotes quaternion multiplication.\n\n**2. Numerical Integration Scheme:**\nWe will employ an explicit forward Euler integration scheme, which is a direct and simple interpretation of the problem's requirements. For a state vector $\\mathbf{Y} = [\\mathbf{P}^\\top, \\mathbf{H}^\\top, \\mathbf{q}^\\top]^\\top$, the update rule from time $t_k$ to $t_{k+1} = t_k + \\Delta t$ is:\n$$ \\mathbf{Y}_{k+1} = \\mathbf{Y}_k + \\left. \\frac{d\\mathbf{Y}}{dt} \\right|_{t_k} \\Delta t $$\nThe algorithm for each time step is as follows:\n\n1.  **Given state at $t_k$**: $\\mathbf{P}_k$, $\\mathbf{H}_k$, $\\mathbf{q}_k$.\n2.  **Compute derived quantities**:\n    a. Convert quaternion $\\mathbf{q}_k$ to rotation matrix $\\mathbf{R}_k$.\n    b. Transform the body-frame inertia tensor $[\\mathbf{I}_b]$ to the world frame: $\\mathbf{I}_k = \\mathbf{R}_k [\\mathbf{I}_b] \\mathbf{R}_k^\\top$.\n    c. Solve the linear system $\\mathbf{I}_k \\boldsymbol{\\omega}_k = \\mathbf{H}_k$ to find the angular velocity $\\boldsymbol{\\omega}_k$.\n3.  **Compute rates of change (derivatives)**:\n    a. The net force $\\mathbf{F}_{net}$ is constant for all test cases.\n    b. Transform body-fixed application points to the world frame: $\\mathbf{r}_{i,k} = \\mathbf{R}_k \\mathbf{r}_{b,i}$.\n    c. Compute the net torque: $\\boldsymbol{\\tau}_{net,k} = \\sum_i (\\mathbf{r}_{i,k} \\times \\mathbf{F}_i)$.\n    d. The time derivatives are thus $\\dot{\\mathbf{P}}_k = \\mathbf{F}_{net}$ and $\\dot{\\mathbf{H}}_k = \\boldsymbol{\\tau}_{net,k}$.\n    e. Compute the quaternion rate: $\\dot{\\mathbf{q}}_k = \\frac{1}{2} \\mathbf{q}_k \\otimes \\mathbf{p}(\\boldsymbol{\\omega}_k)$.\n4.  **Update the state to $t_{k+1}$**:\n    a. $\\mathbf{P}_{k+1} = \\mathbf{P}_k + \\dot{\\mathbf{P}}_k \\Delta t$.\n    b. $\\mathbf{H}_{k+1} = \\mathbf{H}_k + \\dot{\\mathbf{H}}_k \\Delta t$.\n    c. $\\mathbf{q}_{k+1, \\text{un-normalized}} = \\mathbf{q}_k + \\dot{\\mathbf{q}}_k \\Delta t$.\n5.  **Post-step correction**:\n    a. The updated quaternion must be re-normalized to maintain its unit length, which is crucial for it to represent a valid rotation: $\\mathbf{q}_{k+1} = \\mathbf{q}_{k+1, \\text{un-normalized}} / \\|\\mathbf{q}_{k+1, \\text{un-normalized}}\\|$.\n\n**3. Initial and Final Conditions:**\nThe simulation starts with $\\mathbf{P}(0)=\\mathbf{0}$, $\\mathbf{H}(0)=\\mathbf{0}$, and $\\mathbf{q}(0) = [1, 0, 0, 0]^\\top$ (identity rotation). After iterating until the final time $T$, the following quantities are computed:\n-   Final center-of-mass velocity: $\\mathbf{v}(T) = \\mathbf{P}(T) / m$.\n-   Final linear momentum magnitude: $\\|\\mathbf{P}(T)\\|$.\n-   Final center-of-mass speed: $\\|\\mathbf{v}(T)\\|$.\n-   Change in angular momentum magnitude: $\\Delta H = \\|\\mathbf{H}(T) - \\mathbf{H}(0)\\| = \\|\\mathbf{H}(T)\\|$.\n\nThese final values are then compared against the specified tolerances $\\varepsilon_P$, $\\varepsilon_v$, and $\\Delta H_{\\min}$ to determine if the test case passes. A passing result is expected when the net force is zero and the net torque is non-zero, confirming that the numerical implementation correctly decouples linear and angular dynamics.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef quat_to_rot(q):\n    \"\"\"Converts a quaternion to a rotation matrix.\"\"\"\n    # q is [w, x, y, z]\n    q_w, q_x, q_y, q_z = q\n    \n    # Pre-calculate squared terms\n    q_x2 = q_x * q_x\n    q_y2 = q_y * q_y\n    q_z2 = q_z * q_z\n    \n    # Pre-calculate cross-product terms\n    q_xy = q_x * q_y\n    q_xz = q_x * q_z\n    q_yz = q_y * q_z\n    q_wx = q_w * q_x\n    q_wy = q_w * q_y\n    q_wz = q_w * q_z\n    \n    R = np.array([\n        [1.0 - 2.0 * (q_y2 + q_z2), 2.0 * (q_xy - q_wz),       2.0 * (q_xz + q_wy)],\n        [2.0 * (q_xy + q_wz),       1.0 - 2.0 * (q_x2 + q_z2), 2.0 * (q_yz - q_wx)],\n        [2.0 * (q_xz - q_wy),       2.0 * (q_yz + q_wx),       1.0 - 2.0 * (q_x2 + q_y2)]\n    ])\n    return R\n\ndef quat_mult(q1, q2):\n    \"\"\"Multiplies two quaternions q1 * q2.\"\"\"\n    # q1, q2 are [w, x, y, z]\n    w1, x1, y1, z1 = q1\n    w2, x2, y2, z2 = q2\n    \n    w = w1 * w2 - x1 * x2 - y1 * y2 - z1 * z2\n    x = w1 * x2 + x1 * w2 + y1 * z2 - z1 * y2\n    y = w1 * y2 - x1 * z2 + y1 * w2 + z1 * x2\n    z = w1 * z2 + x1 * y2 - y1 * x2 + z1 * w2\n    \n    return np.array([w, x, y, z])\n\ndef quat_rate(q, omega):\n    \"\"\"Computes the time derivative of a quaternion given angular velocity.\"\"\"\n    # omega is [ox, oy, oz]\n    omega_q = np.array([0.0, omega[0], omega[1], omega[2]])\n    return 0.5 * quat_mult(q, omega_q)\n    \ndef run_simulation(case_params):\n    \"\"\"Runs a single rigid body simulation test case.\"\"\"\n    m, Ib_diag, forces, rb_pts, dt, T, eps_P, eps_v, dH_min = case_params\n    \n    # Body-frame inertia tensor\n    Ib = np.diag(Ib_diag)\n    \n    # Unpack forces and points\n    F_list = [np.array(f) for f in forces]\n    rb_list = [np.array(r) for r in rb_pts]\n    \n    # Initial state\n    P = np.zeros(3)  # Linear momentum\n    H = np.zeros(3)  # Angular momentum\n    q = np.array([1.0, 0.0, 0.0, 0.0])  # Orientation quaternion [w, x, y, z]\n    H0 = np.copy(H)\n\n    # Net force (constant in these test cases)\n    F_net = sum(F_list)\n    \n    num_steps = int(round(T / dt))\n\n    for _ in range(num_steps):\n        # 1. Compute derived quantities from state (q, P, H)\n        R = quat_to_rot(q)\n        I_world = R @ Ib @ R.T\n        \n        # Avoid singular matrix for omega calculation if H is zero\n        if np.linalg.norm(H) > 1e-15:\n            omega = np.linalg.solve(I_world, H)\n        else:\n            omega = np.zeros(3)\n            \n        # 2. Compute rates of change\n        P_dot = F_net\n        \n        r_world_list = [R @ rb for rb in rb_list]\n        tau_net = sum(np.cross(r, F) for r, F in zip(r_world_list, F_list))\n        H_dot = tau_net\n        \n        q_dot = quat_rate(q, omega)\n        \n        # 3. Update state using explicit Euler method\n        P = P + P_dot * dt\n        H = H + H_dot * dt\n        q = q + q_dot * dt\n        \n        # 4. Re-normalize quaternion\n        q /= np.linalg.norm(q)\n        \n    # Final verification\n    v = P / m\n    \n    P_norm_final = np.linalg.norm(P)\n    v_norm_final = np.linalg.norm(v)\n    delta_H = np.linalg.norm(H - H0)\n    \n    # For cases 2 and 3, the net torque is zero, so angular momentum will not change.\n    # The acceptance criterion requires dH >= dH_min, so these cases should fail.\n    # This is correct behavior for the test.\n    passes = (P_norm_final = eps_P) and \\\n             (v_norm_final = eps_v) and \\\n             (delta_H >= dH_min)\n             \n    return passes\n\ndef solve():\n    \"\"\"\n    Main function to define, run, and report test cases.\n    \"\"\"\n    eps_P = 1e-12\n    eps_v = 1e-12\n    dH_min = 1e-6\n\n    test_cases_params = [\n        # Case 1\n        (2.5, [0.3, 0.5, 0.7], [[0, 0, 8], [0, 0, -8]], [[0.15, 0, 0], [-0.15, 0, 0]], 0.001, 0.25, eps_P, eps_v, dH_min),\n        # Case 2\n        (2.5, [0.3, 0.5, 0.7], [[0, 0, 8], [0, 0, -8]], [[0.15, 0, 0], [0.15, 0, 0]], 0.001, 0.25, eps_P, eps_v, dH_min),\n        # Case 3\n        (2.5, [0.3, 0.5, 0.7], [[0, 0, 5], [0, 0, -5]], [[0, 0, 0.2], [0, 0, -0.2]], 0.001, 0.25, eps_P, eps_v, dH_min),\n        # Case 4\n        (2.5, [0.3, 0.5, 0.7], [[0, 0, 8], [0, 0, -8 * (1 - 0.02)]], [[0.15, 0, 0], [-0.15, 0, 0]], 0.001, 0.25, eps_P, eps_v, dH_min),\n        # Case 5\n        (1.2, [0.4, 0.4, 0.6], [[5, -3, 4], [-5, 3, -4]], [[0.1, 0.05, 0], [-0.05, -0.02, 0.03]], 0.001, 0.25, eps_P, eps_v, dH_min),\n    ]\n\n    results = []\n    for params in test_cases_params:\n        result = run_simulation(params)\n        results.append(str(result).lower())\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3546907"}]}