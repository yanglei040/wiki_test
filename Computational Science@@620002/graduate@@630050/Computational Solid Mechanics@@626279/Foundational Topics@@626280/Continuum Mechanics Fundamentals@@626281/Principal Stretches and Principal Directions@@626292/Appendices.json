{"hands_on_practices": [{"introduction": "Understanding complex systems often begins with solving a simpler, representative case by hand. This exercise solidifies the fundamental relationship between the deformation gradient and principal stretches through a direct analytical derivation for a general two-dimensional deformation [@problem_id:3590880]. Mastering this foundational calculation provides not only deep insight into the kinematics of stretching but also yields an invaluable tool for verifying numerical algorithms.", "problem": "Consider a homogeneous two-dimensional (planar) deformation with deformation gradient $F \\in \\mathbb{R}^{2 \\times 2}$ given by\n$$\nF=\\begin{pmatrix} a & b \\\\ c & d \\end{pmatrix},\n$$\nwhere $\\det F>0$. Let the right Cauchy–Green deformation tensor be defined by $C=F^{\\top}F$. Principal stretches are defined as the positive eigenvalues of the right stretch tensor $U$, where $F$ admits the polar decomposition $F=R\\,U$ with $R$ proper orthogonal and $U$ symmetric positive-definite. Using only these foundational definitions, derive closed-form analytic expressions for the two principal stretches in terms of $a$, $b$, $c$, and $d$ by employing the characteristic polynomial of $C$. Report the two principal stretches in nondecreasing order. Express your final answer symbolically with no units.", "solution": "The problem as stated is scientifically grounded, well-posed, objective, and contains all necessary information for a unique solution. The definitions and relationships provided are standard in continuum mechanics. We may therefore proceed with the derivation.\n\nThe deformation gradient $F$ is given as a $2 \\times 2$ matrix with real components:\n$$\nF = \\begin{pmatrix} a & b \\\\ c & d \\end{pmatrix}\n$$\nThe problem states that $\\det F > 0$, which ensures the deformation is orientation-preserving.\n\nThe right Cauchy–Green deformation tensor $C$ is defined by $C = F^{\\top}F$. First, we compute the transpose of $F$:\n$$\nF^{\\top} = \\begin{pmatrix} a & c \\\\ b & d \\end{pmatrix}\n$$\nNow, we compute the matrix product $F^{\\top}F$:\n$$\nC = F^{\\top}F = \\begin{pmatrix} a & c \\\\ b & d \\end{pmatrix} \\begin{pmatrix} a & b \\\\ c & d \\end{pmatrix} = \\begin{pmatrix} a^2 + c^2 & ab + cd \\\\ ab + cd & b^2 + d^2 \\end{pmatrix}\n$$\nThe resulting tensor $C$ is symmetric, as expected.\n\nPrincipal stretches, let's denote them $\\lambda_1$ and $\\lambda_2$, are the eigenvalues of the right stretch tensor $U$. The tensor $U$ appears in the polar decomposition of $F$, which is $F=RU$, where $R$ is a proper orthogonal tensor ($R^{\\top}R=I$, $\\det R = 1$) and $U$ is a symmetric positive-definite tensor.\n\nThe relationship between $C$ and $U$ is derived from their definitions:\n$$\nC = F^{\\top}F = (RU)^{\\top}(RU) = U^{\\top}R^{\\top}RU\n$$\nSince $R$ is orthogonal, $R^{\\top}R=I$, where $I$ is the identity tensor. Thus,\n$$\nC = U^{\\top}U\n$$\nBecause $U$ is symmetric ($U^{\\top}=U$), this simplifies to:\n$$\nC = U^2\n$$\nThis relationship implies that the eigenvalues of $C$ are the squares of the eigenvalues of $U$. Let $\\mathbf{n}$ be a principal direction, which is an eigenvector of $U$ corresponding to a principal stretch $\\lambda$. Then, by definition:\n$$\nU\\mathbf{n} = \\lambda \\mathbf{n}\n$$\nApplying the tensor $C$ to this eigenvector $\\mathbf{n}$, we get:\n$$\nC\\mathbf{n} = U^2 \\mathbf{n} = U(U\\mathbf{n}) = U(\\lambda\\mathbf{n}) = \\lambda(U\\mathbf{n}) = \\lambda(\\lambda\\mathbf{n}) = \\lambda^2 \\mathbf{n}\n$$\nThis shows that if $\\lambda$ is an eigenvalue of $U$, then $\\mu = \\lambda^2$ is an eigenvalue of $C$. The principal stretches $\\lambda$ are defined as positive, so $\\lambda = \\sqrt{\\mu}$.\n\nTo find the principal stretches, we must first find the eigenvalues of $C$ by solving its characteristic equation, $\\det(C - \\mu I) = 0$.\n$$\nC - \\mu I = \\begin{pmatrix} a^2 + c^2 - \\mu & ab + cd \\\\ ab + cd & b^2 + d^2 - \\mu \\end{pmatrix}\n$$\nThe determinant is:\n$$\n\\det(C - \\mu I) = (a^2 + c^2 - \\mu)(b^2 + d^2 - \\mu) - (ab + cd)^2 = 0\n$$\nExpanding this expression gives the characteristic polynomial for $\\mu$:\n$$\n\\mu^2 - ((a^2 + c^2) + (b^2 + d^2))\\mu + (a^2 + c^2)(b^2 + d^2) - (ab + cd)^2 = 0\n$$\nThe coefficients of this quadratic equation are related to the invariants of $C$. The coefficient of the linear term in $\\mu$ is the negative of the trace of $C$:\n$$\n\\text{tr}(C) = a^2 + c^2 + b^2 + d^2\n$$\nThe constant term is the determinant of $C$:\n$$\n\\det(C) = (a^2 + c^2)(b^2 + d^2) - (ab + cd)^2 \\\\\n= a^2b^2 + a^2d^2 + c^2b^2 + c^2d^2 - (a^2b^2 + 2abcd + c^2d^2) \\\\\n= a^2d^2 - 2abcd + c^2b^2 \\\\\n= (ad - bc)^2\n$$\nWe recognize $ad-bc$ as $\\det F$, so $\\det C = (\\det F)^2$. The characteristic equation simplifies to:\n$$\n\\mu^2 - \\text{tr}(C)\\mu + \\det(C) = 0\n$$\nSubstituting the expressions for the trace and determinant in terms of $a,b,c,d$:\n$$\n\\mu^2 - (a^2 + b^2 + c^2 + d^2)\\mu + (ad - bc)^2 = 0\n$$\nWe solve this quadratic equation for the eigenvalues $\\mu$ using the quadratic formula:\n$$\n\\mu = \\frac{-[-(a^2+b^2+c^2+d^2)] \\pm \\sqrt{(-(a^2+b^2+c^2+d^2))^2 - 4(1)((ad-bc)^2)}}{2(1)}\n$$\n$$\n\\mu_{1,2} = \\frac{1}{2} \\left( (a^2+b^2+c^2+d^2) \\pm \\sqrt{(a^2+b^2+c^2+d^2)^2 - 4(ad-bc)^2} \\right)\n$$\nThe tensor $C$ is symmetric and positive-definite (since $\\det C = (\\det F)^2 > 0$), so its eigenvalues $\\mu_1$ and $\\mu_2$ are real and positive. The principal stretches are the positive square roots of these eigenvalues, $\\lambda_1 = \\sqrt{\\mu_1}$ and $\\lambda_2 = \\sqrt{\\mu_2}$.\n\nTo report them in nondecreasing order, we assign $\\lambda_1$ to be the smaller value and $\\lambda_2$ to be the larger value. This corresponds to using the minus sign for $\\mu_1$ and the plus sign for $\\mu_2$.\n\nThe smaller principal stretch, $\\lambda_1$, is:\n$$\n\\lambda_1 = \\sqrt{\\frac{1}{2} \\left( (a^2+b^2+c^2+d^2) - \\sqrt{(a^2+b^2+c^2+d^2)^2 - 4(ad-bc)^2} \\right)}\n$$\nThe larger principal stretch, $\\lambda_2$, is:\n$$\n\\lambda_2 = \\sqrt{\\frac{1}{2} \\left( (a^2+b^2+c^2+d^2) + \\sqrt{(a^2+b^2+c^2+d^2)^2 - 4(ad-bc)^2} \\right)}\n$$\nThese are the closed-form analytic expressions for the two principal stretches in terms of the components of the deformation gradient $F$.", "answer": "$$\n\\boxed{\\begin{pmatrix} \\sqrt{\\frac{1}{2} \\left( a^2+b^2+c^2+d^2 - \\sqrt{(a^2+b^2+c^2+d^2)^2 - 4(ad-bc)^2} \\right)} & \\sqrt{\\frac{1}{2} \\left( a^2+b^2+c^2+d^2 + \\sqrt{(a^2+b^2+c^2+d^2)^2 - 4(ad-bc)^2} \\right)} \\end{pmatrix}}\n$$", "id": "3590880"}, {"introduction": "A powerful way to test our understanding is to apply concepts to special, intuitive cases. This practice investigates a pure rigid body rotation, a deformation that involves no stretching whatsoever [@problem_id:3590864]. By demonstrating that all principal stretches are unity and that the principal directions become indeterminate, you will gain a deeper appreciation for how these kinematic measures distinguish true deformation from pure rotation.", "problem": "Let $\\varphi: \\mathbb{R}^{3} \\to \\mathbb{R}^{3}$ be a deformation with deformation gradient $\\mathbf{F} = \\nabla \\varphi$. Consider the special case of a pure rigid body rotation, so that $\\mathbf{F} = \\mathbf{Q} \\in \\mathrm{SO}(3)$, where $\\mathrm{SO}(3)$ denotes the special orthogonal group of proper rotations with $\\mathbf{Q}^{\\top}\\mathbf{Q} = \\mathbf{I}$ and $\\det \\mathbf{Q} = 1$. Assume $\\mathbf{Q}$ has an axis–angle representation with unit axis $\\mathbf{n} \\in \\mathbb{R}^{3}$ and rotation angle $\\theta \\in \\mathbb{R}$ (in radians), but do not use any special properties of $\\theta$ beyond the orthogonality constraint on $\\mathbf{Q}$.\n\nStarting only from the fundamental definitions of the right Cauchy–Green tensor $\\mathbf{C} := \\mathbf{F}^{\\top}\\mathbf{F}$, the right stretch tensor $\\mathbf{U}$ given by the right polar decomposition $\\mathbf{F} = \\mathbf{R}\\mathbf{U}$ with $\\mathbf{R} \\in \\mathrm{SO}(3)$ and $\\mathbf{U}$ symmetric positive definite, and the definition that principal stretches are the eigenvalues of $\\mathbf{U}$ (equivalently, the square roots of the eigenvalues of $\\mathbf{C}$), perform the following:\n\n- Rigorously derive the principal stretches for the case $\\mathbf{F} = \\mathbf{Q} \\in \\mathrm{SO}(3)$.\n- Explain, based on the spectral properties of $\\mathbf{C}$ and $\\mathbf{U}$ in this case, why principal directions are non-unique and how this non-uniqueness is structured in terms of invariant subspaces.\n\nReport the three principal stretches in increasing order as a $1 \\times 3$ row matrix. No rounding is required. There are no physical units to report for the principal stretches.", "solution": "The problem asks for the principal stretches and a discussion of the uniqueness of principal directions for a deformation that is a pure rigid body rotation. The deformation gradient is given as $\\mathbf{F} = \\mathbf{Q}$, where $\\mathbf{Q}$ is a proper orthogonal tensor, i.e., $\\mathbf{Q} \\in \\mathrm{SO}(3)$, satisfying $\\mathbf{Q}^{\\top}\\mathbf{Q} = \\mathbf{I}$ and $\\det \\mathbf{Q} = 1$.\n\nFirst, we will rigorously derive the principal stretches. The principal stretches, denoted by $\\lambda_i$, are defined as the eigenvalues of the right stretch tensor $\\mathbf{U}$, or equivalently, as the square roots of the eigenvalues of the right Cauchy–Green tensor $\\mathbf{C}$. We shall use both perspectives to demonstrate consistency.\n\n**Method 1: Using the Right Cauchy–Green Tensor $\\mathbf{C}$**\n\nThe right Cauchy–Green tensor $\\mathbf{C}$ is defined by the relation:\n$$\n\\mathbf{C} := \\mathbf{F}^{\\top}\\mathbf{F}\n$$\nIn the specific case of a pure rigid body rotation, the deformation gradient is $\\mathbf{F} = \\mathbf{Q}$, where $\\mathbf{Q} \\in \\mathrm{SO}(3)$. Substituting this into the definition of $\\mathbf{C}$ yields:\n$$\n\\mathbf{C} = \\mathbf{Q}^{\\top}\\mathbf{Q}\n$$\nBy the definition of an orthogonal tensor, $\\mathbf{Q}^{\\top}\\mathbf{Q} = \\mathbf{I}$, where $\\mathbf{I}$ is the second-order identity tensor in $\\mathbb{R}^{3}$. Therefore, for this deformation, the right Cauchy–Green tensor is simply the identity tensor:\n$$\n\\mathbf{C} = \\mathbf{I}\n$$\nThe eigenvalues of $\\mathbf{C}$, let's call them $\\lambda_i^{\\mathbf{C}}$, are the solutions to the characteristic equation $\\det(\\mathbf{C} - \\lambda^{\\mathbf{C}}\\mathbf{I}) = 0$. In this case, the equation becomes:\n$$\n\\det(\\mathbf{I} - \\lambda^{\\mathbf{C}}\\mathbf{I}) = \\det((1 - \\lambda^{\\mathbf{C}})\\mathbf{I}) = (1 - \\lambda^{\\mathbf{C}})^3 \\det(\\mathbf{I}) = (1 - \\lambda^{\\mathbf{C}})^3 = 0\n$$\nThis equation has a single root $\\lambda^{\\mathbf{C}} = 1$ with an algebraic multiplicity of $3$. Thus, the eigenvalues of $\\mathbf{C}$ are:\n$$\n\\lambda_1^{\\mathbf{C}} = 1, \\quad \\lambda_2^{\\mathbf{C}} = 1, \\quad \\lambda_3^{\\mathbf{C}} = 1\n$$\nThe principal stretches $\\lambda_i$ are the square roots of these eigenvalues:\n$$\n\\lambda_i = \\sqrt{\\lambda_i^{\\mathbf{C}}}\n$$\nTherefore, the three principal stretches are:\n$$\n\\lambda_1 = \\sqrt{1} = 1, \\quad \\lambda_2 = \\sqrt{1} = 1, \\quad \\lambda_3 = \\sqrt{1} = 1\n$$\n\n**Method 2: Using the Right Polar Decomposition**\n\nThe right polar decomposition theorem states that any invertible deformation gradient $\\mathbf{F}$ can be uniquely decomposed into the product of a proper orthogonal tensor $\\mathbf{R} \\in \\mathrm{SO}(3)$ and a symmetric positive-definite right stretch tensor $\\mathbf{U}$:\n$$\n\\mathbf{F} = \\mathbf{R}\\mathbf{U}\n$$\nIn our case, $\\mathbf{F} = \\mathbf{Q}$, where $\\mathbf{Q} \\in \\mathrm{SO}(3)$. Substituting this gives:\n$$\n\\mathbf{Q} = \\mathbf{R}\\mathbf{U}\n$$\nWe need to find $\\mathbf{R}$ and $\\mathbf{U}$ that satisfy this equation, subject to the constraints that $\\mathbf{R} \\in \\mathrm{SO}(3)$ and $\\mathbf{U}$ is symmetric and positive-definite. Let us propose the solution $\\mathbf{R} = \\mathbf{Q}$ and $\\mathbf{U} = \\mathbf{I}$.\n1.  The choice $\\mathbf{R} = \\mathbf{Q}$ is valid since we are given $\\mathbf{Q} \\in \\mathrm{SO}(3)$.\n2.  The choice $\\mathbf{U} = \\mathbf{I}$ is valid because the identity tensor $\\mathbf{I}$ is symmetric ($\\mathbf{I}^{\\top} = \\mathbf{I}$) and positive-definite (its eigenvalues are all $1 > 0$).\n3.  The equation $\\mathbf{Q} = \\mathbf{R}\\mathbf{U}$ is satisfied, as $\\mathbf{Q} = \\mathbf{Q}\\mathbf{I}$.\n\nSince the right polar decomposition is unique for an invertible $\\mathbf{F}$ (and $\\mathbf{Q}$ is invertible as $\\det \\mathbf{Q} = 1 \\neq 0$), our proposed solution must be the unique solution. Therefore, the right stretch tensor is $\\mathbf{U} = \\mathbf{I}$.\n\nThe principal stretches are the eigenvalues of $\\mathbf{U}$. The eigenvalues of the identity tensor $\\mathbf{I}$ are, by inspection, all equal to $1$.\nThus, this method confirms that the three principal stretches are $\\lambda_1 = 1$, $\\lambda_2 = 1$, $\\lambda_3 = 1$. The physical interpretation is that a pure rotation induces no stretching.\n\n**Non-Uniqueness of Principal Directions**\n\nPrincipal directions are defined as the directions of the eigenvectors of the right stretch tensor $\\mathbf{U}$ (or equivalently, of $\\mathbf{C}$). As we have established, for a pure rigid body rotation, $\\mathbf{U} = \\mathbf{I}$. Let $\\mathbf{v}$ be an eigenvector of $\\mathbf{U}$ corresponding to a principal stretch (eigenvalue) $\\lambda$. The eigenvector equation is:\n$$\n\\mathbf{Uv} = \\lambda \\mathbf{v}\n$$\nSubstituting $\\mathbf{U} = \\mathbf{I}$ and $\\lambda = 1$, we get:\n$$\n\\mathbf{Iv} = 1 \\cdot \\mathbf{v} \\implies \\mathbf{v} = \\mathbf{v}\n$$\nThis equation is a tautology, holding true for any vector $\\mathbf{v} \\in \\mathbb{R}^{3}$. This means that every non-zero vector in $\\mathbb{R}^{3}$ is an eigenvector of the identity tensor, with the corresponding eigenvalue being $1$.\n\nThe eigenspace associated with an eigenvalue is the set of all eigenvectors for that eigenvalue, plus the zero vector. In this case, the eigenvalue $\\lambda = 1$ has a multiplicity of $3$, and its corresponding eigenspace is the entire space $\\mathbb{R}^{3}$. An eigenspace with dimension greater than one is termed a degenerate eigenspace.\n\nBecause principal directions are the directions of the eigenvectors, and every direction in $\\mathbb{R}^{3}$ is an eigenvector, there is no unique set of principal directions. Conventionally, a set of principal directions forms an orthonormal basis. Since the entire space $\\mathbb{R}^{3}$ is the eigenspace for $\\lambda=1$, *any* orthonormal basis of $\\mathbb{R}^{3}$ constitutes a valid set of principal directions.\n\nThe non-uniqueness is structured by the spectral properties of $\\mathbf{U} = \\mathbf{I}$. The spectrum of $\\mathbf{U}$ consists of a single eigenvalue, $\\lambda = 1$, with a multiplicity of $3$. The corresponding eigenspace is the entire vector space $\\mathbb{R}^{3}$, which is a $3$-dimensional invariant subspace under the linear transformation represented by $\\mathbf{U}$. The non-uniqueness arises because we can choose any three mutually orthogonal unit vectors to span this invariant subspace, and they will all qualify as principal directions.\n\nIn summary, the principal stretches are all $1$, indicating no change in length, and the principal directions are indeterminate because every direction is preserved (up to the global rotation $\\mathbf{Q}$) without stretching.\n\nThe three principal stretches, ordered increasingly, are $1, 1, 1$.", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n1 & 1 & 1\n\\end{pmatrix}\n}\n$$", "id": "3590864"}, {"introduction": "Translating theoretical mechanics into functional code requires addressing the challenges of finite-precision arithmetic. This hands-on coding challenge guides you to build a numerically robust algorithm for computing principal stretches and directions, incorporating essential safeguarding techniques used in professional-grade software [@problem_id:3590872]. These practices are critical for preventing numerical failures and ensuring the stability and reproducibility of real-world simulations.", "problem": "You are tasked with designing and implementing a robust algorithm to compute principal stretches and material principal directions from the right Cauchy–Green deformation tensor. The goal is to ensure numerical robustness in the presence of small asymmetries and near-loss of positive definiteness due to finite precision or modeling artifacts. Your implementation must be a complete, runnable program that produces the specified outputs for the provided test suite.\n\nFundamental base and definitions:\n- Let the deformation gradient be denoted by $F \\in \\mathbb{R}^{3 \\times 3}$. The right Cauchy–Green deformation tensor is defined as $C = F^{\\top} F$.\n- For any symmetric positive definite (SPD) tensor $C$, the spectral theorem guarantees an orthonormal eigenbasis $\\{N_i\\}_{i=1}^3$ and nonnegative eigenvalues $\\{\\mu_i\\}_{i=1}^3$ such that $C = \\sum_{i=1}^3 \\mu_i \\, N_i \\otimes N_i$.\n- The principal stretches $\\{\\lambda_i\\}_{i=1}^3$ are defined by $\\lambda_i = \\sqrt{\\mu_i}$, and the material principal directions are the eigenvectors $\\{N_i\\}$ of $C$.\n- The principal directions must be orthonormal and can be chosen to form a right-handed triad.\n\nAlgorithmic requirements:\n1. Input handling:\n   - Given a $3 \\times 3$ matrix that is either a deformation gradient $F$ or an alleged right Cauchy–Green tensor $C$, form $C$ as follows:\n     - If the input is $F$, compute $C = F^{\\top} F$.\n     - If the input is $C$, use it directly.\n   - Enforce exact symmetry by $C \\leftarrow \\frac{1}{2}(C + C^{\\top})$.\n2. Symmetric Positive Definite (SPD) safeguard:\n   - Compute the eigen-decomposition of the symmetrized $C$ using a symmetric eigensolver to obtain eigenvalues $\\{\\tilde{\\mu}_i\\}$ and eigenvectors $\\{\\tilde{N}_i\\}$.\n   - Define a floor parameter $\\varepsilon = \\max\\!\\left(10^{-12},\\,10^{-8}\\,\\lVert C \\rVert_2\\right)$, where $\\lVert \\cdot \\rVert_2$ is the spectral norm.\n   - Form corrected eigenvalues $\\mu_i = \\max(\\tilde{\\mu}_i, \\varepsilon)$ and reconstruct the SPD tensor $C_{\\text{spd}} = \\sum_{i=1}^3 \\mu_i \\, \\tilde{N}_i \\otimes \\tilde{N}_i$.\n3. Principal stretches and directions:\n   - Compute $\\lambda_i = \\sqrt{\\mu_i}$.\n   - Sort the triplets $\\{(\\lambda_i, \\tilde{N}_i)\\}$ in non-increasing order of $\\lambda_i$.\n   - Enforce a deterministic sign convention on the eigenvectors:\n     - For each eigenvector, make its component with largest absolute value positive.\n     - After this adjustment, if the eigenvector matrix has negative determinant, flip the sign of the eigenvector associated with the smallest $\\lambda_i$ to ensure a right-handed basis.\n4. Reconstruction and diagnostics:\n   - Reconstruct $\\widehat{C} = \\sum_{i=1}^3 \\lambda_i^2 \\, N_i \\otimes N_i$ using the adjusted and sorted eigenpairs, and compute the maximum absolute reconstruction residual $e_{\\max} = \\max_{j,k} \\left| \\widehat{C}_{jk} - (C_{\\text{spd}})_{jk} \\right|$.\n   - Also compute the minimum raw eigenvalue of the symmetrized input prior to SPD correction, $\\tilde{\\mu}_{\\min} = \\min_i \\tilde{\\mu}_i$, as a diagnostic that reveals whether SPD correction was active.\n\nAngle unit specification:\n- All rotation angles in the test suite are specified in radians.\n\nTest suite:\nYour program must evaluate the algorithm on the following five cases, each defined by parameters that determine either a deformation gradient $F$ or a raw tensor $C$. Rotations are constructed via the axis–angle formula. For any axis vector $a \\in \\mathbb{R}^3$, use the normalized unit axis $\\hat{a} = a/\\lVert a \\rVert$, and define the rotation matrix via Rodrigues’ formula:\n$$\nR(\\hat{a},\\theta) = \\cos\\theta \\, I + \\sin\\theta \\, [\\hat{a}]_{\\times} + (1-\\cos\\theta)\\,\\hat{a}\\hat{a}^{\\top},\n$$\nwhere $[\\hat{a}]_{\\times}$ is the skew-symmetric matrix associated with the cross product by $\\hat{a}$.\n\n- Case 1 (general, well-conditioned, input as $F$):\n  - Stretches: $s = [1.3,\\,0.85,\\,1.1]$.\n  - $Q_1 = R([1,2,3],\\,0.7)$.\n  - $U_1 = Q_1 \\,\\mathrm{diag}(s)\\, Q_1^{\\top}$.\n  - $R_1 = R([0.5,-1,0.3],\\,-0.4)$.\n  - Input $F = R_1 U_1$.\n\n- Case 2 (nearly repeated eigenvalues, input as $F$):\n  - Stretches: $s = [1.0,\\,1.0,\\,1.000001]$.\n  - $Q_2 = R([1,0,0],\\,1.2)$.\n  - $U_2 = Q_2 \\,\\mathrm{diag}(s)\\, Q_2^{\\top}$.\n  - $R_2 = R([0,1,0],\\,0.3)$.\n  - Input $F = R_2 U_2$.\n\n- Case 3 (noisy and slightly indefinite input as $C$):\n  - True stretches: $s = [1.5,\\,1.2,\\,0.7]$.\n  - $Q_3 = R([-0.2,1,0.7],\\,1.0)$.\n  - $C_{\\text{true}} = Q_3 \\,\\mathrm{diag}(s^2)\\, Q_3^{\\top}$.\n  - Let $v_{\\min}$ be the eigenvector of $C_{\\text{true}}$ associated with the smallest eigenvalue $0.7^2$.\n  - Form $C_{\\text{bad}} = C_{\\text{true}} - 0.5\\, v_{\\min} v_{\\min}^{\\top} + \\Delta$, where $\\Delta$ is an antisymmetric perturbation with entries of order $10^{-8}$ generated from a fixed seed for reproducibility.\n  - Input $C = C_{\\text{bad}}$.\n\n- Case 4 (plane strain-like $F$):\n  - Input\n    $$\n    F = \\begin{bmatrix}\n    1.2 & 0.3 & 0 \\\\\n    0.1 & 0.9 & 0 \\\\\n    0 & 0 & 1.0\n    \\end{bmatrix}.\n    $$\n\n- Case 5 (isotropic stretch with rotation, input as $F$):\n  - Isotropic stretch factor $\\alpha = 1.05$.\n  - $R_5 = R([1,-1,0.5],\\,0.9)$.\n  - Input $F = \\alpha \\, R_5$.\n\nRequired outputs and format:\n- For each case, compute:\n  - The principal stretches $\\lambda_1 \\ge \\lambda_2 \\ge \\lambda_3$.\n  - The maximum absolute reconstruction residual $e_{\\max}$ as defined above.\n  - The minimum raw eigenvalue $\\tilde{\\mu}_{\\min}$ before SPD correction.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each case contributes a sublist in the form $[\\lambda_1,\\lambda_2,\\lambda_3,e_{\\max},\\tilde{\\mu}_{\\min}]$.\n- All numbers must be printed with exactly $8$ digits after the decimal point, with no spaces anywhere in the line.\n- Example of the overall output structure: \n  - $[[\\lambda_{1}^{(1)},\\lambda_{2}^{(1)},\\lambda_{3}^{(1)},e_{\\max}^{(1)},\\tilde{\\mu}_{\\min}^{(1)}],[\\lambda_{1}^{(2)},\\lambda_{2}^{(2)},\\lambda_{3}^{(2)},e_{\\max}^{(2)},\\tilde{\\mu}_{\\min}^{(2)}],\\dots]$.\n\nNotes:\n- There are no physical units associated with stretches in this problem; they are unitless.\n- Use radians for all angles.\n- Ensure numerical robustness by following the SPD safeguard and deterministic eigenvector orientation rules described above.", "solution": "The problem presents a valid and well-posed task within the domain of computational solid mechanics. It requires the design and implementation of an algorithm to compute principal stretches and their corresponding material directions from a given deformation tensor, with a strong emphasis on achieving numerical robustness. The problem statement is scientifically grounded, self-contained, and provides a clear, deterministic procedure to follow.\n\nThe core of the problem lies in the spectral analysis of the right Cauchy–Green deformation tensor, $C$. We will now delineate the theoretical principles and corresponding algorithmic steps for its solution.\n\n**1. Theoretical Foundation**\n\nIn continuum mechanics, the deformation of a body is described by the mapping of material points from a reference configuration to a current configuration. The local nature of this mapping is captured by the deformation gradient tensor, $F \\in \\mathbb{R}^{3 \\times 3}$.\n\nThe right Cauchy–Green deformation tensor is defined as:\n$$\nC = F^{\\top} F\n$$\nBy this definition, $C$ is symmetric, since $C^{\\top} = (F^{\\top} F)^{\\top} = F^{\\top} (F^{\\top})^{\\top} = F^{\\top} F = C$. Furthermore, for any non-zero vector $X \\in \\mathbb{R}^3$, the quadratic form $X^{\\top} C X = X^{\\top} F^{\\top} F X = (FX)^{\\top} (FX) = \\lVert FX \\rVert^2 \\ge 0$. If $F$ is invertible (i.e., $\\det(F) > 0$, a standard requirement for physical deformations), then $FX \\neq 0$ for $X \\neq 0$, which implies $X^{\\top} C X > 0$. Thus, $C$ is a symmetric positive definite (SPD) tensor.\n\nThe spectral theorem for symmetric matrices guarantees that $C$ has a set of three real eigenvalues, $\\{\\mu_i\\}_{i=1}^3$, and a corresponding orthonormal basis of eigenvectors, $\\{N_i\\}_{i=1}^3$. The spectral decomposition of $C$ is:\n$$\nC = \\sum_{i=1}^3 \\mu_i \\, N_i \\otimes N_i\n$$\nwhere $N_i \\otimes N_i$ denotes the outer product $N_i N_i^{\\top}$. Since $C$ is positive definite, all its eigenvalues $\\mu_i$ are strictly positive.\n\nThe principal stretches, denoted by $\\lambda_i$, are the positive square roots of the eigenvalues of $C$:\n$$\n\\lambda_i = \\sqrt{\\mu_i}\n$$\nPhysically, the principal stretches represent the factors by which infinitesimal line elements are stretched along the principal directions. The material principal directions are the eigenvectors $\\{N_i\\}$ of $C$. These directions form an orthonormal triad fixed in the material's reference configuration that, upon deformation, are only stretched and not rotated relative to each other.\n\n**2. Algorithmic Implementation and Robustness**\n\nThe problem specifies a precise algorithm to ensure numerical robustness, which we will now detail.\n\n**Step 2.1: Tensor Formation and Symmetrization**\nThe input is either a deformation gradient $F$ or a tensor alleged to be $C$.\n- If $F$ is provided, we compute $C = F^{\\top} F$.\n- If a raw $C$ is provided, we use it directly.\n\nIn floating-point arithmetic, the computed or provided $C$ may have small asymmetries. To ensure the applicability of eigensolvers for symmetric matrices, we enforce symmetry explicitly:\n$$\nC_{\\text{sym}} \\leftarrow \\frac{1}{2}(C + C^{\\top})\n$$\nThis operation projects the nearly symmetric tensor onto the space of symmetric tensors, removing any antisymmetric component.\n\n**Step 2.2: Symmetric Positive Definite (SPD) Safeguard**\nNumerical errors can cause a theoretically SPD matrix to have small negative eigenvalues. This would prevent the computation of real-valued principal stretches ($\\lambda_i = \\sqrt{\\mu_i}$). A safeguard is thus necessary.\n\nFirst, we perform an eigendecomposition on the symmetrized tensor $C_{\\text{sym}}$:\n$$\nC_{\\text{sym}} N_i = \\tilde{\\mu}_i N_i\n$$\nThis yields the \"raw\" eigenvalues $\\{\\tilde{\\mu}_i\\}$ and their corresponding eigenvectors $\\{\\tilde{N}_i\\}$. For this, a specialized symmetric eigensolver is used, such as the one provided by `numpy.linalg.eigh`.\n\nNext, we define a floor value $\\varepsilon$ to enforce positivity on the eigenvalues:\n$$\n\\varepsilon = \\max\\left(10^{-12}, \\, 10^{-8} \\lVert C_{\\text{sym}} \\rVert_2\\right)\n$$\nwhere $\\lVert C_{\\text{sym}} \\rVert_2$ is the spectral norm of $C_{\\text{sym}}$, equal to its largest absolute eigenvalue. This mixed absolute/relative tolerance prevents eigenvalues from becoming non-positive. We compute the corrected eigenvalues $\\mu_i$ as:\n$$\n\\mu_i = \\max(\\tilde{\\mu}_i, \\varepsilon)\n$$\nA key diagnostic, $\\tilde{\\mu}_{\\min} = \\min_i(\\tilde{\\mu}_i)$, is retained to track whether this correction was activated.\n\nUsing these corrected eigenvalues, we can define a strictly SPD tensor $C_{\\text{spd}}$:\n$$\nC_{\\text{spd}} = \\sum_{i=1}^3 \\mu_i \\, \\tilde{N}_i \\otimes \\tilde{N}_i\n$$\nThis tensor is the closest SPD approximation to the original $C_{\\text{sym}}$ under certain metrics and serves as the basis for subsequent calculations.\n\n**Step 2.3: Principal Stretches and Directions**\nThe principal stretches are computed from the corrected eigenvalues:\n$$\n\\lambda_i = \\sqrt{\\mu_i}\n$$\nTo establish a canonical representation, the triplets of (stretch, direction), i.e., $\\{(\\lambda_i, \\tilde{N}_i)\\}$, are sorted in non-increasing order of the stretch values, yielding $(\\lambda_1, N_1)$, $(\\lambda_2, N_2)$, $(\\lambda_3, N_3)$ such that $\\lambda_1 \\ge \\lambda_2 \\ge \\lambda_3$.\n\nEigenvectors are unique only up to a sign. To ensure a deterministic result, a sign convention is enforced.\n1. For each sorted eigenvector $N_i$, we find the component with the largest absolute value. If this component is negative, the sign of the entire eigenvector is flipped ($N_i \\leftarrow -N_i$).\n2. After adjusting all three eigenvectors, we check if they form a right-handed system by computing the determinant of the matrix $[N_1 \\, N_2 \\, N_3]$. If the determinant is negative (close to $-1$), we flip the sign of the eigenvector associated with the smallest stretch, $N_3 \\leftarrow -N_3$. This ensures the basis $\\{N_1, N_2, N_3\\}$ is right-handed.\n\n**Step 2.4: Reconstruction and Diagnostics**\nFinally, two diagnostic quantities are computed.\nFirst, we reconstruct the tensor $\\widehat{C}$ from the final, sorted, and oriented principal stretches and directions:\n$$\n\\widehat{C} = \\sum_{i=1}^3 \\lambda_i^2 \\, N_i \\otimes N_i\n$$\nThe maximum absolute reconstruction residual, $e_{\\max}$, measures the difference between this reconstructed tensor and the safeguarded SPD tensor:\n$$\ne_{\\max} = \\max_{j,k} \\left| \\widehat{C}_{jk} - (C_{\\text{spd}})_{jk} \\right|\n$$\nTheoretically, this residual should be zero up to machine precision, as the sign-flipping operations on eigenvectors do not alter the outer product $N_i N_i^{\\top}$. This check verifies the internal consistency of the eigen-decomposition and reconstruction process.\n\nThe second diagnostic is $\\tilde{\\mu}_{\\min}$, the minimum raw eigenvalue before the SPD correction. A negative value of $\\tilde{\\mu}_{\\min}$ indicates that the initial tensor was not positive definite and the safeguard was crucial.\n\nThis comprehensive, step-by-step procedure provides a robust and deterministic method for computing principal stretches and directions, suitable for implementation in a computational mechanics code. The test suite provided allows for verification across a range of scenarios, from well-behaved cases to those with numerical challenges like nearly repeated eigenvalues and loss of positive definiteness.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to compute principal stretches and directions for a suite of test cases.\n    \"\"\"\n\n    def skew(v):\n        \"\"\"\n        Returns the skew-symmetric matrix for a 3D vector.\n        \"\"\"\n        return np.array([[0, -v[2], v[1]],\n                         [v[2], 0, -v[0]],\n                         [-v[1], v[0], 0]])\n\n    def rodrigues_formula(axis, angle):\n        \"\"\"\n        Computes the rotation matrix using Rodrigues' formula.\n        R(a, theta) = cos(theta)*I + sin(theta)*[a]x + (1-cos(theta))*a*a^T\n        \"\"\"\n        a = np.asarray(axis)\n        a = a / np.linalg.norm(a)\n        \n        I = np.identity(3)\n        K = skew(a)\n        \n        # Using the formulation with the outer product for clarity\n        # R = np.cos(angle) * I + np.sin(angle) * K + (1 - np.cos(angle)) * np.outer(a, a)\n        \n        # Using the K@K = a*a^T - I formulation\n        R = I + np.sin(angle) * K + (1 - np.cos(angle)) * (K @ K)\n        return R\n\n    def process_tensor(tensor, is_F):\n        \"\"\"\n        Performs the full analysis on a given tensor (F or C).\n        \"\"\"\n        # Step 1: Input handling and Symmetrization\n        if is_F:\n            F = tensor\n            C = F.T @ F\n        else:\n            C = tensor\n        \n        C_sym = 0.5 * (C + C.T)\n\n        # Step 2: SPD Safeguard\n        # Compute eigen-decomposition of symmetrized C\n        # np.linalg.eigh returns eigenvalues in ascending order\n        raw_mu, raw_N = np.linalg.eigh(C_sym)\n        mu_min_raw = raw_mu[0] # Smallest raw eigenvalue\n\n        # Define floor parameter epsilon\n        norm_C = np.max(np.abs(raw_mu))\n        epsilon = max(1e-12, 1e-8 * norm_C)\n\n        # Form corrected eigenvalues\n        mu = np.maximum(raw_mu, epsilon)\n\n        # Reconstruct the SPD tensor\n        C_spd = raw_N @ np.diag(mu) @ raw_N.T\n\n        # Step 3: Principal Stretches and Directions\n        # Compute principal stretches\n        lambdas = np.sqrt(mu)\n\n        # Sort triplets {lambda_i, N_i} in non-increasing order of lambda_i\n        # eigh sorts eigenvalues ascending, so we reverse the order.\n        sorted_indices = np.argsort(lambdas)[::-1]\n        lambdas_sorted = lambdas[sorted_indices]\n        N_sorted = raw_N[:, sorted_indices]\n\n        # Enforce deterministic sign convention on eigenvectors\n        for i in range(3):\n            vec = N_sorted[:, i]\n            max_abs_idx = np.argmax(np.abs(vec))\n            if vec[max_abs_idx]  0:\n                N_sorted[:, i] *= -1\n\n        # Enforce right-handed basis\n        if np.linalg.det(N_sorted)  0:\n            # Flip sign of the eigenvector associated with the smallest lambda\n            N_sorted[:, 2] *= -1\n\n        # Step 4: Reconstruction and Diagnostics\n        # Reconstruct C_hat\n        lambda_sq = lambdas_sorted**2\n        C_hat = N_sorted @ np.diag(lambda_sq) @ N_sorted.T\n\n        # Compute max absolute reconstruction residual\n        e_max = np.max(np.abs(C_hat - C_spd))\n        \n        l1, l2, l3 = lambdas_sorted\n        return [l1, l2, l3, e_max, mu_min_raw]\n\n    # --- Test Suite ---\n    \n    # Case 1: General, well-conditioned, input as F\n    s1 = np.array([1.3, 0.85, 1.1])\n    Q1 = rodrigues_formula([1, 2, 3], 0.7)\n    U1 = Q1 @ np.diag(s1) @ Q1.T\n    R1 = rodrigues_formula([0.5, -1, 0.3], -0.4)\n    F1 = R1 @ U1\n    \n    # Case 2: Nearly repeated eigenvalues, input as F\n    s2 = np.array([1.0, 1.0, 1.000001])\n    Q2 = rodrigues_formula([1, 0, 0], 1.2)\n    U2 = Q2 @ np.diag(s2) @ Q2.T\n    R2 = rodrigues_formula([0, 1, 0], 0.3)\n    F2 = R2 @ U2\n    \n    # Case 3: Noisy and slightly indefinite input as C\n    s3 = np.array([1.5, 1.2, 0.7])\n    Q3 = rodrigues_formula([-0.2, 1, 0.7], 1.0)\n    C_true = Q3 @ np.diag(s3**2) @ Q3.T\n    mu_true, N_true = np.linalg.eigh(C_true)\n    v_min = N_true[:, 0] # Eigenvector for smallest eigenvalue\n    # Create reproducible antisymmetric perturbation\n    np.random.seed(0)\n    D_rand = np.random.rand(3, 3) * 1e-8\n    Delta = D_rand - D_rand.T\n    C_bad = C_true - 0.5 * np.outer(v_min, v_min) + Delta\n\n    # Case 4: Plane strain-like F\n    F4 = np.array([[1.2, 0.3, 0],\n                   [0.1, 0.9, 0],\n                   [0, 0, 1.0]])\n\n    # Case 5: Isotropic stretch with rotation, input as F\n    alpha5 = 1.05\n    R5 = rodrigues_formula([1, -1, 0.5], 0.9)\n    F5 = alpha5 * R5\n\n    test_cases = [\n        (F1, True),\n        (F2, True),\n        (C_bad, False),\n        (F4, True),\n        (F5, True)\n    ]\n    \n    results = []\n    for tensor, is_F in test_cases:\n        case_result = process_tensor(tensor, is_F)\n        results.append(case_result)\n\n    # Format output\n    result_strings = []\n    for res in results:\n        formatted_res = \",\".join([f\"{x:.8f}\" for x in res])\n        result_strings.append(f\"[{formatted_res}]\")\n    \n    final_output = f\"[{','.join(result_strings)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "3590872"}]}