{"hands_on_practices": [{"introduction": "Understanding a new concept often begins with applying it to a familiar, fundamental case. This first exercise provides a direct application of the definitions for the right and left Cauchy-Green deformation tensors, $C$ and $B$, to the case of simple shear. By working through the matrix algebra [@problem_id:3596643], you will not only solidify your grasp of the core formulas but also uncover important characteristics of this ubiquitous deformation mode, such as its volume-preserving nature.", "problem": "A homogeneous deformation of a continuum body in three spatial dimensions is described by the linear mapping $x = F X$, where $F$ is the deformation gradient. The right Cauchy-Green deformation tensor $C$ and the left Cauchy-Green deformation tensor $B$ are defined, respectively, by $C = F^{\\mathsf{T}} F$ and $B = F F^{\\mathsf{T}}$. The principal invariants of a second-order tensor $T$ with real eigenvalues $\\lambda_1$, $\\lambda_2$, and $\\lambda_3$ are defined by the coefficients of its characteristic polynomial, namely $I_1(T) = \\lambda_1 + \\lambda_2 + \\lambda_3$, $I_2(T) = \\lambda_1 \\lambda_2 + \\lambda_2 \\lambda_3 + \\lambda_3 \\lambda_1$, and $I_3(T) = \\lambda_1 \\lambda_2 \\lambda_3 = \\det(T)$. The local volume change is $J = \\det(F)$.\n\nConsider the simple shear deformation with deformation gradient\n$$\nF = \\begin{bmatrix}\n1 & \\gamma & 0 \\\\\n0 & 1 & 0 \\\\\n0 & 0 & 1\n\\end{bmatrix},\n$$\nwhere $\\gamma$ is a real-valued shear parameter. Using only the above fundamental definitions and identities that follow from them, compute the following quantities explicitly as functions of $\\gamma$: the right Cauchy-Green deformation tensor $C$, the left Cauchy-Green deformation tensor $B$, the first and second principal invariants of $C$, denoted $I_1$ and $I_2$, and the Jacobian $J$. Provide closed-form expressions. No numerical evaluation is required, and no rounding is needed.", "solution": "The problem statement is valid as it is scientifically grounded in the principles of continuum mechanics, well-posed, self-contained, and objective. We proceed to compute the requested quantities in a systematic manner.\n\nThe deformation gradient $F$ for simple shear is given as:\n$$\nF = \\begin{bmatrix}\n1 & \\gamma & 0 \\\\\n0 & 1 & 0 \\\\\n0 & 0 & 1\n\\end{bmatrix}\n$$\nwhere $\\gamma$ is the shear parameter.\n\nFirst, we compute the right Cauchy-Green deformation tensor $C$. By definition, $C = F^{\\mathsf{T}} F$. The transpose of $F$ is:\n$$\nF^{\\mathsf{T}} = \\begin{bmatrix}\n1 & 0 & 0 \\\\\n\\gamma & 1 & 0 \\\\\n0 & 0 & 1\n\\end{bmatrix}\n$$\nPerforming the matrix multiplication gives:\n$$\nC = F^{\\mathsf{T}} F = \\begin{bmatrix}\n1 & 0 & 0 \\\\\n\\gamma & 1 & 0 \\\\\n0 & 0 & 1\n\\end{bmatrix}\n\\begin{bmatrix}\n1 & \\gamma & 0 \\\\\n0 & 1 & 0 \\\\\n0 & 0 & 1\n\\end{bmatrix} = \\begin{bmatrix}\n1(1) + 0(0) + 0(0) & 1(\\gamma) + 0(1) + 0(0) & 1(0) + 0(0) + 0(1) \\\\\n\\gamma(1) + 1(0) + 0(0) & \\gamma(\\gamma) + 1(1) + 0(0) & \\gamma(0) + 1(0) + 0(1) \\\\\n0(1) + 0(0) + 1(0) & 0(\\gamma) + 0(1) + 1(0) & 0(0) + 0(0) + 1(1)\n\\end{bmatrix}\n$$\n$$\nC = \\begin{bmatrix}\n1 & \\gamma & 0 \\\\\n\\gamma & 1+\\gamma^2 & 0 \\\\\n0 & 0 & 1\n\\end{bmatrix}\n$$\n\nSecond, we compute the left Cauchy-Green deformation tensor $B$. By definition, $B = F F^{\\mathsf{T}}$.\n$$\nB = F F^{\\mathsf{T}} = \\begin{bmatrix}\n1 & \\gamma & 0 \\\\\n0 & 1 & 0 \\\\\n0 & 0 & 1\n\\end{bmatrix}\n\\begin{bmatrix}\n1 & 0 & 0 \\\\\n\\gamma & 1 & 0 \\\\\n0 & 0 & 1\n\\end{bmatrix} = \\begin{bmatrix}\n1(1) + \\gamma(\\gamma) + 0(0) & 1(0) + \\gamma(1) + 0(0) & 1(0) + \\gamma(0) + 0(1) \\\\\n0(1) + 1(\\gamma) + 0(0) & 0(0) + 1(1) + 0(0) & 0(0) + 1(0) + 0(1) \\\\\n0(1) + 0(\\gamma) + 1(0) & 0(0) + 0(1) + 1(0) & 0(0) + 0(0) + 1(1)\n\\end{bmatrix}\n$$\n$$\nB = \\begin{bmatrix}\n1+\\gamma^2 & \\gamma & 0 \\\\\n\\gamma & 1 & 0 \\\\\n0 & 0 & 1\n\\end{bmatrix}\n$$\n\nThird, we compute the first principal invariant of $C$, denoted $I_1$. The first invariant of a tensor is its trace.\n$$\nI_1 = I_1(C) = \\text{tr}(C) = 1 + (1+\\gamma^2) + 1 = 3+\\gamma^2\n$$\n\nFourth, we compute the second principal invariant of $C$, denoted $I_2$. The second invariant can be computed from the formula $I_2(T) = \\frac{1}{2} [(\\text{tr}(T))^2 - \\text{tr}(T^2)]$. We have already found $\\text{tr}(C) = 3+\\gamma^2$. We now compute $C^2$ to find its trace.\n$$\nC^2 = \\begin{bmatrix}\n1 & \\gamma & 0 \\\\\n\\gamma & 1+\\gamma^2 & 0 \\\\\n0 & 0 & 1\n\\end{bmatrix}\n\\begin{bmatrix}\n1 & \\gamma & 0 \\\\\n\\gamma & 1+\\gamma^2 & 0 \\\\\n0 & 0 & 1\n\\end{bmatrix} = \\begin{bmatrix}\n1+\\gamma^2 & \\gamma + \\gamma(1+\\gamma^2) & 0 \\\\\n\\gamma + \\gamma(1+\\gamma^2)  & \\gamma^2 + (1+\\gamma^2)^2 & 0 \\\\\n0 & 0 & 1\n\\end{bmatrix}\n$$\nThe trace of $C^2$ is the sum of its diagonal elements:\n$$\n\\text{tr}(C^2) = (1+\\gamma^2) + (\\gamma^2 + (1+\\gamma^2)^2) + 1 = 1+\\gamma^2 + \\gamma^2 + (1+2\\gamma^2+\\gamma^4) + 1 = 3 + 4\\gamma^2 + \\gamma^4\n$$\nNow, we can compute $I_2$:\n$$\nI_2 = I_2(C) = \\frac{1}{2} [(\\text{tr}(C))^2 - \\text{tr}(C^2)] = \\frac{1}{2} [(3+\\gamma^2)^2 - (3 + 4\\gamma^2 + \\gamma^4)]\n$$\n$$\nI_2 = \\frac{1}{2} [(9+6\\gamma^2+\\gamma^4) - 3 - 4\\gamma^2 - \\gamma^4] = \\frac{1}{2} [6+2\\gamma^2] = 3+\\gamma^2\n$$\nIt is a known property that $C$ and $B$ are co-spectral, meaning they share the same eigenvalues and thus the same principal invariants. Indeed, we find $I_1(C) = I_1(B) = 3+\\gamma^2$ and $I_2(C) = I_2(B) = 3+\\gamma^2$.\n\nFinally, we compute the Jacobian $J$, which is the determinant of the deformation gradient $F$. Since $F$ is an upper triangular matrix, its determinant is the product of its diagonal elements.\n$$\nJ = \\det(F) = \\det\\begin{bmatrix}\n1 & \\gamma & 0 \\\\\n0 & 1 & 0 \\\\\n0 & 0 & 1\n\\end{bmatrix} = 1 \\cdot 1 \\cdot 1 = 1\n$$\nThis result, $J=1$, confirms that simple shear is an isochoric (volume-preserving) deformation.\n\nThe required quantities are now fully determined as functions of $\\gamma$.", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\begin{pmatrix} 1 & \\gamma & 0 \\\\ \\gamma & 1+\\gamma^2 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} &\n\\begin{pmatrix} 1+\\gamma^2 & \\gamma & 0 \\\\ \\gamma & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} &\n3+\\gamma^2 &\n3+\\gamma^2 &\n1\n\\end{pmatrix}\n}\n$$", "id": "3596643"}, {"introduction": "Beyond mere calculation, the true power of the Cauchy-Green tensors lies in their physical interpretation. This practice focuses on the eigensystem of these tensors, which describes the principal magnitudes and directions of stretching. By analyzing a pure stretch deformation [@problem_id:3596678], where the rotational component is absent, you will build a clear and intuitive link between the eigenvalues of $C$ and the principal stretches, and its eigenvectors and the principal directions of deformation.", "problem": "Consider a deformation gradient $F \\in \\mathbb{R}^{3 \\times 3}$ given by $F = Q \\, \\operatorname{diag}(2, \\tfrac{1}{2}, 1) \\, Q^{T}$, where $Q \\in \\mathbb{R}^{3 \\times 3}$ is an orthogonal matrix satisfying $Q^{T} Q = I$. The right Cauchy-Green deformation tensor is defined by $C = F^{T} F$, and the left Cauchy-Green deformation tensor is defined by $B = F F^{T}$. The principal stretches are defined as the square roots of the eigenvalues of $C$ (equivalently of $B$). Starting from these definitions and the properties of orthogonal matrices, derive the principal stretches and determine the corresponding orthonormal eigenvectors of $C$ and $B$ in terms of the columns of $Q$. Express the final answer symbolically in terms of $Q$; no rounding is required and no units apply. Your final answer should list the principal stretches followed by the three eigenvectors (as column vectors) that span the eigenspaces of both $C$ and $B$.", "solution": "The problem is validated as scientifically grounded, well-posed, and objective. It is a standard problem in continuum mechanics that is self-contained and free of contradictions.\n\nLet the given deformation gradient be $F \\in \\mathbb{R}^{3 \\times 3}$. It is expressed as\n$$F = Q \\, \\operatorname{diag}\\left(2, \\frac{1}{2}, 1\\right) \\, Q^{T}$$\nwhere $Q \\in \\mathbb{R}^{3 \\times 3}$ is an orthogonal matrix, satisfying $Q^{T}Q = Q Q^{T} = I$, with $I$ being the identity matrix. Let us denote the diagonal matrix as $D$, so\n$$D = \\operatorname{diag}\\left(2, \\frac{1}{2}, 1\\right)$$\nThus, $F = Q D Q^{T}$. The diagonal entries of $D$ are positive, so $D$ is a positive-definite diagonal matrix.\n\nFirst, we analyze the structure of $F$. We compute its transpose, $F^T$:\n$$F^{T} = \\left(Q D Q^{T}\\right)^{T} = \\left(Q^{T}\\right)^{T} D^{T} Q^{T}$$\nSince the transpose of a product is the product of transposes in reverse order. For any matrix $A$, $(A^T)^T = A$. As $D$ is a diagonal matrix, it is symmetric, so $D^T = D$. Therefore,\n$$F^{T} = Q D Q^{T} = F$$\nThis shows that the given deformation gradient $F$ is a symmetric matrix. This is a special case of deformation, known as pure stretch, where the rotational part of the deformation is the identity.\n\nThe right Cauchy-Green deformation tensor, $C$, is defined as $C = F^{T}F$. Since $F^T = F$, we have:\n$$C = F^{T}F = F F = F^2$$\nSubstituting the given expression for $F$:\n$$C = (Q D Q^{T})(Q D Q^{T})$$\nUsing the property that $Q$ is orthogonal, $Q^{T}Q = I$:\n$$C = Q D (Q^{T}Q) D Q^{T} = Q D I D Q^{T} = Q D^2 Q^{T}$$\nThe matrix $D^2$ is\n$$D^2 = \\operatorname{diag}\\left(2^2, \\left(\\frac{1}{2}\\right)^2, 1^2\\right) = \\operatorname{diag}\\left(4, \\frac{1}{4}, 1\\right)$$\nThe expression $C = Q D^2 Q^T$ is the spectral decomposition of the symmetric matrix $C$. The eigenvalues of $C$ are the diagonal elements of $D^2$, and the corresponding eigenvectors are the columns of $Q$.\n\nThe principal stretches, denoted by $\\lambda_i$, are defined as the square roots of the eigenvalues of $C$. Let the eigenvalues of $C$ be $\\mu_i$.\n$$\\mu_1 = 4, \\quad \\mu_2 = \\frac{1}{4}, \\quad \\mu_3 = 1$$\nThe principal stretches are therefore:\n$$\\lambda_1 = \\sqrt{\\mu_1} = \\sqrt{4} = 2$$\n$$\\lambda_2 = \\sqrt{\\mu_2} = \\sqrt{\\frac{1}{4}} = \\frac{1}{2}$$\n$$\\lambda_3 = \\sqrt{\\mu_3} = \\sqrt{1} = 1$$\n\nNext, we determine the eigenvectors. Let the columns of the matrix $Q$ be denoted by $q_1, q_2, q_3$, such that $Q = \\begin{pmatrix} q_1 & q_2 & q_3 \\end{pmatrix}$. Since $Q$ is an orthogonal matrix, the set of vectors $\\{q_1, q_2, q_3\\}$ forms an orthonormal basis.\nFrom the spectral decomposition $C = Q D^2 Q^T$, the eigenvector of $C$ corresponding to the eigenvalue $\\mu_i$ is the $i$-th column of $Q$.\nThe eigenvector for $\\mu_1 = 4$ is $q_1$.\nThe eigenvector for $\\mu_2 = \\frac{1}{4}$ is $q_2$.\nThe eigenvector for $\\mu_3 = 1$ is $q_3$.\n\nNow we consider the left Cauchy-Green deformation tensor, $B$, defined as $B = FF^{T}$. Since we have already established that $F$ is symmetric ($F = F^T$), this gives:\n$$B = FF^{T} = FF = F^2$$\nThis implies that $B = C$.\n$$B = C = Q D^2 Q^{T}$$\nConsequently, the left Cauchy-Green tensor $B$ has the exact same eigenvalues and eigenvectors as the right Cauchy-Green tensor $C$.\nThe eigenvalues of $B$ are $\\mu_1 = 4$, $\\mu_2 = \\frac{1}{4}$, and $\\mu_3 = 1$. The corresponding orthonormal eigenvectors are $q_1$, $q_2$, and $q_3$, respectively.\n\nThe problem asks for the principal stretches and the corresponding orthonormal eigenvectors of both $C$ and $B$. Since $C=B$, their eigensystems are identical. The orthonormal eigenvectors $q_1, q_2, q_3$ span the eigenspaces for both tensors.\n\nTo summarize:\nThe principal stretches are $\\lambda_1 = 2$, $\\lambda_2 = \\frac{1}{2}$, and $\\lambda_3 = 1$.\nThe orthonormal eigenvectors of both $C$ and $B$ are the columns of the matrix $Q$. Let $q_1, q_2, q_3$ be the columns of $Q$.\n- The eigenvector corresponding to the principal stretch $\\lambda_1 = 2$ (eigenvalue $\\mu_1=4$) is $q_1$.\n- The eigenvector corresponding to the principal stretch $\\lambda_2 = \\frac{1}{2}$ (eigenvalue $\\mu_2=\\frac{1}{4}$) is $q_2$.\n- The eigenvector corresponding to the principal stretch $\\lambda_3 = 1$ (eigenvalue $\\mu_3=1$) is $q_3$.\n\nThe final answer will list the principal stretches, followed by symbolic representations for these three corresponding eigenvectors.", "answer": "$$\\boxed{\\begin{pmatrix} 2 & \\frac{1}{2} & 1 & q_1 & q_2 & q_3 \\end{pmatrix}}$$", "id": "3596678"}, {"introduction": "The theoretical concepts of deformation tensors find their purpose in powerful computational algorithms. This final exercise guides you through the implementation of one of the most fundamental procedures in continuum mechanics: the polar decomposition of the deformation gradient ($F=RU$). You will use the right Cauchy-Green tensor $C$ to compute the right stretch tensor $U$, and subsequently isolate the rotation tensor $R$, demonstrating how these tools are used to separate a complex deformation into its pure stretch and rigid rotation components [@problem_id:3596619].", "problem": "You are given the deformation gradient matrices for a series of three-dimensional cases. Your task is to implement a numerical routine that, for each case, constructs the right Cauchy-Green deformation tensor, obtains the right stretch tensor via spectral decomposition, reconstructs the rotation in the right polar decomposition, and verifies orthogonality. The derivation must start from fundamental definitions in continuum kinematics. Specifically, use the following base:\n- The deformation gradient is denoted by $F \\in \\mathbb{R}^{3 \\times 3}$.\n- The right Cauchy-Green deformation tensor is $C = F^{T} F$.\n- The left Cauchy-Green deformation tensor is $B = F F^{T}$.\n- The right stretch tensor $U$ is the unique symmetric positive definite (SPD) square root of $C$, i.e., $U = C^{1/2}$ with $U \\succ 0$ and $U^{2} = C$.\n- The left stretch tensor $V$ is the unique SPD square root of $B$, i.e., $V = B^{1/2}$ with $V \\succ 0$ and $V^{2} = B$.\n- The right polar decomposition is $F = R U$ with $R$ orthogonal and $U$ SPD.\n- The left polar decomposition is $F = V R$ with $V$ SPD and $R$ orthogonal.\n\nYour program must, for each provided $F$, do the following without using any external data:\n1. Construct $C = F^{T} F$ and $B = F F^{T}$.\n2. Compute $U$ as the SPD square root of $C$ using spectral decomposition of the symmetric matrix $C$: if $C = Q \\Lambda Q^{T}$ with $Q$ orthogonal and $\\Lambda = \\mathrm{diag}(\\lambda_{1},\\lambda_{2},\\lambda_{3})$ with $\\lambda_{i} \\ge 0$, then define $U = Q \\,\\mathrm{diag}(\\sqrt{\\lambda_{1}},\\sqrt{\\lambda_{2}},\\sqrt{\\lambda_{3}})\\, Q^{T}$. For numerical robustness, if any $\\lambda_{i}$ is slightly negative due to floating-point error, treat it as $0$.\n3. Form $R = F U^{-1}$ using the inverse of $U$ constructed via the same eigenbasis: $U^{-1} = Q \\,\\mathrm{diag}(1/\\sqrt{\\lambda_{1}},1/\\sqrt{\\lambda_{2}},1/\\sqrt{\\lambda_{3}})\\, Q^{T}$, assuming $\\lambda_{i} > 0$ (the provided test suite ensures invertibility).\n4. Verify orthogonality by computing the Frobenius norm $||R^{T} R - I||_{F}$ and checking it against a tolerance $\\tau_{\\mathrm{orth}} = 1 \\times 10^{-8}$.\n5. Independently compute the left stretch tensor $V = B^{1/2}$ via spectral decomposition of $B$, form $R_{\\mathrm{alt}} = V^{-1} F$, and check consistency with the previous rotation by evaluating $||R_{\\mathrm{alt}} - R||_{F} \\le \\tau_{\\mathrm{cons}}$ with $\\tau_{\\mathrm{cons}} = 1 \\times 10^{-8}$.\n6. Verify reconstruction by checking the relative Frobenius error $||F - R U||_{F} / ||F||_{F} \\le \\tau_{\\mathrm{rec}}$ with $\\tau_{\\mathrm{rec}} = 1 \\times 10^{-9}$.\n\nFor each test case, output a boolean that is true if and only if all three checks pass:\n- $||R^{T} R - I||_{F} \\le \\tau_{\\mathrm{orth}}$,\n- $||R_{\\mathrm{alt}} - R||_{F} \\le \\tau_{\\mathrm{cons}}$,\n- $||F - R U||_{F} / ||F||_{F} \\le \\tau_{\\mathrm{rec}}$,\nand false otherwise.\n\nAngle units, when used to construct the matrices below, are already embedded numerically; your program must not compute angles. No physical units are involved in the final answers.\n\nTest suite (each case is a $3 \\times 3$ matrix $F$):\n- Case 1 (general stretch and rotation): \n  $$\n  F_{1} = \\begin{bmatrix}\n  1.4330047336884090 & -0.2364161653290717 & 0.0 \\\\\n  0.4432803099920094 & 0.7642691913004848 & 0.0 \\\\\n  0.0 & 0.0 & 1.2\n  \\end{bmatrix}.\n  $$\n- Case 2 (pure rotation about the $x$-axis by $- \\pi/3$ radians):\n  $$\n  F_{2} = \\begin{bmatrix}\n  1.0 & 0.0 & 0.0 \\\\\n  0.0 & 0.5 & 0.8660254037844386 \\\\\n  0.0 & -0.8660254037844386 & 0.5\n  \\end{bmatrix}.\n  $$\n- Case 3 (improper deformation with negative determinant):\n  $$\n  F_{3} = \\begin{bmatrix}\n  -1.1 & 0.0 & 0.0 \\\\\n  0.0 & 0.9 & 0.0 \\\\\n  0.0 & 0.0 & 1.3\n  \\end{bmatrix}.\n  $$\n- Case 4 (ill-conditioned but invertible):\n  $$\n  F_{4} = \\begin{bmatrix}\n  0.0008775825618903728 & 0.0 & 47.9425538604203 \\\\\n  0.0 & 1.0 & 0.0 \\\\\n  -0.000479425538604203 & 0.0 & 87.75825618903728\n  \\end{bmatrix}.\n  $$\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[true1,true2,true3,true4]\" but using Python boolean formatting \"True\" or \"False\"). Specifically, the output must be of the form \"[$b_{1},b_{2},b_{3},b_{4}$]\" where $b_{k} \\in \\{\\mathrm{True},\\mathrm{False}\\}$ is the result for case $k$.", "solution": "The problem requires the implementation and verification of the polar decomposition of a given $3 \\times 3$ deformation gradient tensor $F$. The polar decomposition theorem states that any invertible tensor $F$ can be uniquely decomposed into the product of an orthogonal tensor $R$ and a symmetric positive-definite (SPD) tensor $U$ or $V$. Specifically, we have the right polar decomposition, $F=RU$, and the left polar decomposition, $F=VR$. The tensors $U$ and $V$ are called the right and left stretch tensors, respectively, and $R$ is the rotation tensor. The numerical procedure will be validated against three criteria: orthogonality of $R$, consistency between the right and left decompositions, and accuracy of reconstruction.\n\nThe kinematic definitions provided form the foundation of our algorithm. The deformation gradient is $F \\in \\mathbb{R}^{3 \\times 3}$. The right and left Cauchy-Green deformation tensors, $C$ and $B$, are defined as:\n$$\nC = F^{T} F\n$$\n$$\nB = F F^{T}\n$$\nBy construction, both $C$ and $B$ are symmetric matrices. They are also positive semi-definite, as for any vector $x \\in \\mathbb{R}^{3}$, we have $x^{T} C x = x^{T} F^{T} F x = (Fx)^{T}(Fx) = ||Fx||_{2}^{2} \\ge 0$. If $F$ is invertible, as specified for the test cases, then $C$ and $B$ are positive definite.\n\nThe right stretch tensor $U$ and the left stretch tensor $V$ are the unique symmetric positive-definite square roots of $C$ and $B$, respectively:\n$$\nU = C^{1/2}, \\quad U^2 = C, \\quad U=U^T, \\quad U \\succ 0\n$$\n$$\nV = B^{1/2}, \\quad V^2 = B, \\quad V=V^T, \\quad V \\succ 0\n$$\n\nThe core of the numerical task is to compute these tensor square roots. This is accomplished using the spectral (or eigendecomposition) of the symmetric matrices $C$ and $B$. For the symmetric matrix $C$, there exists an orthogonal matrix $Q$ whose columns are the orthonormal eigenvectors of $C$, and a diagonal matrix $\\Lambda$ whose entries are the corresponding real eigenvalues $\\lambda_{i}$. The decomposition is:\n$$\nC = Q \\Lambda Q^{T}\n$$\nwhere $\\Lambda = \\mathrm{diag}(\\lambda_{1}, \\lambda_{2}, \\lambda_{3})$. Since $C$ is positive definite, all its eigenvalues are strictly positive, $\\lambda_i > 0$. The square root $U$ can then be computed as:\n$$\nU = C^{1/2} = Q \\Lambda^{1/2} Q^{T}\n$$\nwhere $\\Lambda^{1/2} = \\mathrm{diag}(\\sqrt{\\lambda_{1}}, \\sqrt{\\lambda_{2}}, \\sqrt{\\lambda_{3}})$. As a measure of numerical robustness, if any eigenvalue is found to be a small negative number due to floating-point inaccuracies, it is clamped to $0$ before taking the square root.\n\nOnce $U$ is computed, the rotation tensor $R$ from the right polar decomposition $F = RU$ can be found by inverting $U$:\n$$\nR = F U^{-1}\n$$\nThe inverse of $U$ is computed efficiently using the same eigendecomposition:\n$$\nU^{-1} = (Q \\Lambda^{1/2} Q^{T})^{-1} = (Q^{T})^{-1} (\\Lambda^{1/2})^{-1} Q^{-1} = Q \\Lambda^{-1/2} Q^{T}\n$$\nwhere $\\Lambda^{-1/2} = \\mathrm{diag}(1/\\sqrt{\\lambda_{1}}, 1/\\sqrt{\\lambda_{2}}, 1/\\sqrt{\\lambda_{3}})$. This is valid since all $\\lambda_i > 0$.\n\nThe algorithm proceeds with the following steps for each given $F$:\n1.  Compute $C = F^{T} F$ and $B = F F^{T}$.\n2.  Perform the spectral decomposition of $C$ to get eigenvalues $\\lambda_i$ and eigenvector matrix $Q$. Compute $U = Q \\, \\mathrm{diag}(\\sqrt{\\lambda_i}) \\, Q^{T}$.\n3.  Compute the inverse $U^{-1} = Q \\, \\mathrm{diag}(1/\\sqrt{\\lambda_i}) \\, Q^{T}$ and then the rotation matrix $R = F U^{-1}$.\n4.  Perform the first verification: check for orthogonality. An orthogonal matrix $R$ satisfies $R^{T} R = I$, where $I$ is the identity matrix. The check is performed by computing the Frobenius norm of the residual, $||R^{T} R - I||_{F}$, and ensuring it is below a tolerance $\\tau_{\\mathrm{orth}} = 1 \\times 10^{-8}$.\n5.  Perform the second verification: check for consistency. The rotation matrix can also be computed from the left decomposition, $F=VR$, which gives $R_{\\mathrm{alt}} = V^{-1}F$. The left stretch tensor $V=B^{1/2}$ and its inverse $V^{-1}$ are computed via the spectral decomposition of $B$. The theory guarantees that $R_{\\mathrm{alt}}$ must be identical to $R$. This is checked by computing $||R_{\\mathrm{alt}} - R||_{F}$ and ensuring it is below a tolerance $\\tau_{\\mathrm{cons}} = 1 \\times 10^{-8}$.\n6.  Perform the third verification: check for reconstruction accuracy. The computed decomposition $F \\approx RU$ must reconstruct the original matrix $F$ to high precision. This is checked by evaluating the relative Frobenius error, $||F - R U||_{F} / ||F||_{F}$, and ensuring it is below a tolerance $\\tau_{\\mathrm{rec}} = 1 \\times 10^{-9}$.\n\nA test case is considered successful (evaluates to true) if and only if all three numerical checks are satisfied.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_spd_sqrt_and_inv(A):\n    \"\"\"\n    Computes the symmetric positive-definite square root of a matrix A and its inverse\n    using spectral decomposition.\n    A must be a symmetric positive semi-definite matrix.\n    \"\"\"\n    # Use eigh for symmetric matrices; it's more efficient and numerically stable.\n    eigvals, eigvecs = np.linalg.eigh(A)\n    \n    # Clamp small negative eigenvalues that may arise from floating-point errors.\n    eigvals[eigvals  0] = 0\n    \n    # Compute square root of eigenvalues\n    sqrt_eigvals = np.sqrt(eigvals)\n    \n    # Form the diagonal matrix of square root eigenvalues\n    Lambda_sqrt = np.diag(sqrt_eigvals)\n    \n    # Reconstruct the matrix square root\n    A_sqrt = eigvecs @ Lambda_sqrt @ eigvecs.T\n    \n    # Compute inverse square root of eigenvalues.\n    # Add a small epsilon to avoid division by zero if an eigenvalue is exactly 0,\n    # although the problem statement implies invertible F, so eigenvalues of C and B are > 0.\n    inv_sqrt_eigvals = np.zeros_like(eigvals)\n    # Check for non-zero eigenvalues before division\n    non_zero_mask = eigvals > 1e-12 # A practical tolerance for non-zero\n    inv_sqrt_eigvals[non_zero_mask] = 1.0 / sqrt_eigvals[non_zero_mask]\n\n    Lambda_inv_sqrt = np.diag(inv_sqrt_eigvals)\n    \n    # Reconstruct the inverse of the matrix square root\n    A_inv_sqrt = eigvecs @ Lambda_inv_sqrt @ eigvecs.T\n    \n    return A_sqrt, A_inv_sqrt\n\ndef solve():\n    \"\"\"\n    Performs polar decomposition for a series of deformation gradients F\n    and verifies the results against several criteria.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        np.array([\n            [1.4330047336884090, -0.2364161653290717, 0.0],\n            [0.4432803099920094, 0.7642691913004848, 0.0],\n            [0.0, 0.0, 1.2]\n        ]),\n        np.array([\n            [1.0, 0.0, 0.0],\n            [0.0, 0.5, 0.8660254037844386],\n            [0.0, -0.8660254037844386, 0.5]\n        ]),\n        np.array([\n            [-1.1, 0.0, 0.0],\n            [0.0, 0.9, 0.0],\n            [0.0, 0.0, 1.3]\n        ]),\n        np.array([\n            [0.0008775825618903728, 0.0, 47.9425538604203],\n            [0.0, 1.0, 0.0],\n            [-0.000479425538604203, 0.0, 87.75825618903728]\n        ])\n    ]\n\n    # Define tolerances\n    tau_orth = 1e-8\n    tau_cons = 1e-8\n    tau_rec = 1e-9\n\n    results = []\n    I = np.identity(3)\n\n    for F in test_cases:\n        # 1. Construct C and B\n        C = F.T @ F\n        B = F @ F.T\n\n        # 2. Compute U from C\n        U, U_inv = compute_spd_sqrt_and_inv(C)\n        \n        # 3. Form R\n        R = F @ U_inv\n\n        # 4. Verify orthogonality of R\n        orth_error = np.linalg.norm(R.T @ R - I, 'fro')\n        check_orth = orth_error = tau_orth\n\n        # 5. Compute R_alt from B and V, and check consistency\n        V, V_inv = compute_spd_sqrt_and_inv(B)\n        R_alt = V_inv @ F\n        cons_error = np.linalg.norm(R_alt - R, 'fro')\n        check_cons = cons_error = tau_cons\n\n        # 6. Verify reconstruction accuracy\n        F_norm = np.linalg.norm(F, 'fro')\n        # Avoid division by zero for a zero matrix F, although not in test cases\n        if F_norm > 1e-12:\n            rec_error_rel = np.linalg.norm(F - R @ U, 'fro') / F_norm\n        else:\n            rec_error_rel = np.linalg.norm(F - R @ U, 'fro')\n        \n        check_rec = rec_error_rel = tau_rec\n\n        # Final result for the case is true if all checks pass\n        results.append(check_orth and check_cons and check_rec)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3596619"}]}