{"hands_on_practices": [{"introduction": "To build a solid foundation, we begin with a case of pure homogeneous stretch. This exercise [@problem_id:3601263] guides you through the direct calculation of the key kinematic tensors, including the deformation gradient ($F$), the right Cauchy-Green tensor ($C$), and the Green-Lagrange strain ($E$). By performing the polar decomposition for this irrotational deformation, you will see how the right stretch tensor ($U$) captures the entire deformation, and the rotation tensor ($R$) reduces to the identity, reinforcing the core definitions in a clear and uncluttered context.", "problem": "Consider a three-dimensional body undergoing a homogeneous deformation described by the motion $\\,\\varphi:\\mathbb{R}^{3}\\to\\mathbb{R}^{3}\\,$ given in Cartesian material coordinates by $\\,\\varphi(X)=\\begin{bmatrix}\\lambda_{1} X_{1} \\\\ \\lambda_{2} X_{2} \\\\ \\lambda_{3} X_{3}\\end{bmatrix}\\,$, where $\\,\\lambda_{1},\\lambda_{2},\\lambda_{3}>0\\,$ are constant principal stretches. Treating this as a finite deformation exemplifying geometric nonlinearity, proceed as follows.\n\nStarting from the definitions of the deformation gradient, the right Cauchy–Green deformation tensor, the Green–Lagrange strain tensor, and the right polar decomposition, compute the deformation gradient $\\,F\\,$, the right Cauchy–Green tensor $\\,C\\,$, and the Green–Lagrange strain $\\,E\\,$ associated with $\\,\\varphi\\,$. Then perform the right polar decomposition of $\\,F\\,$, that is, write $\\,F=R\\,U\\,$, and identify the right stretch tensor $\\,U\\,$ and the rotation tensor $\\,R\\,$.\n\nAs your final reported answer, provide the exact symbolic expression for the Jacobian determinant $\\,J=\\det F\\,$ in terms of $\\,\\lambda_{1},\\lambda_{2},\\lambda_{3}\\,$. Express your final answer as a closed-form analytic expression. Do not include units. No rounding is required.", "solution": "The problem statement is evaluated as valid. It is scientifically grounded in the principles of continuum mechanics, well-posed with all necessary information provided, and objective in its formulation. The problem requires the application of standard definitions to a fundamental case of finite deformation, making it a suitable and solvable problem.\n\nThe motion of the body is described by the mapping $\\varphi$ from the material (or reference) configuration, with coordinates $\\mathbf{X} = (X_1, X_2, X_3)$, to the spatial (or current) configuration, with coordinates $\\mathbf{x} = (x_1, x_2, x_3)$. The given motion is:\n$$\n\\mathbf{x} = \\varphi(\\mathbf{X}) = \\begin{bmatrix} \\lambda_{1} X_{1} \\\\ \\lambda_{2} X_{2} \\\\ \\lambda_{3} X_{3} \\end{bmatrix}\n$$\nwhere $\\lambda_1, \\lambda_2, \\lambda_3 > 0$ are constant principal stretches.\n\nFirst, we compute the deformation gradient tensor, $\\mathbf{F}$. It is defined as the gradient of the motion with respect to the material coordinates:\n$$\n\\mathbf{F} = \\frac{\\partial \\varphi}{\\partial \\mathbf{X}} = \\nabla_{\\mathbf{X}} \\varphi\n$$\nIn component form, its elements are $F_{ij} = \\frac{\\partial x_i}{\\partial X_j}$. We compute the components:\n$F_{11} = \\frac{\\partial (\\lambda_1 X_1)}{\\partial X_1} = \\lambda_1$\n$F_{22} = \\frac{\\partial (\\lambda_2 X_2)}{\\partial X_2} = \\lambda_2$\n$F_{33} = \\frac{\\partial (\\lambda_3 X_3)}{\\partial X_3} = \\lambda_3$\nAll off-diagonal components are zero, for example, $F_{12} = \\frac{\\partial (\\lambda_1 X_1)}{\\partial X_2} = 0$.\nThus, the deformation gradient tensor $\\mathbf{F}$ is a diagonal matrix:\n$$\n\\mathbf{F} = \\begin{bmatrix} \\lambda_1 & 0 & 0 \\\\ 0 & \\lambda_2 & 0 \\\\ 0 & 0 & \\lambda_3 \\end{bmatrix}\n$$\n\nNext, we compute the right Cauchy–Green deformation tensor, $\\mathbf{C}$. It is defined as:\n$$\n\\mathbf{C} = \\mathbf{F}^T \\mathbf{F}\n$$\nwhere $\\mathbf{F}^T$ is the transpose of $\\mathbf{F}$. Since $\\mathbf{F}$ is a diagonal matrix, it is symmetric, so $\\mathbf{F}^T = \\mathbf{F}$.\n$$\n\\mathbf{C} = \\mathbf{F}^T \\mathbf{F} = \\mathbf{F} \\mathbf{F} = \\mathbf{F}^2 = \\begin{bmatrix} \\lambda_1 & 0 & 0 \\\\ 0 & \\lambda_2 & 0 \\\\ 0 & 0 & \\lambda_3 \\end{bmatrix} \\begin{bmatrix} \\lambda_1 & 0 & 0 \\\\ 0 & \\lambda_2 & 0 \\\\ 0 & 0 & \\lambda_3 \\end{bmatrix} = \\begin{bmatrix} \\lambda_1^2 & 0 & 0 \\\\ 0 & \\lambda_2^2 & 0 \\\\ 0 & 0 & \\lambda_3^2 \\end{bmatrix}\n$$\n\nThen, we compute the Green–Lagrange strain tensor, $\\mathbf{E}$. It is defined in terms of $\\mathbf{C}$ and the identity tensor $\\mathbf{I}$ as:\n$$\n\\mathbf{E} = \\frac{1}{2}(\\mathbf{C} - \\mathbf{I})\n$$\nSubstituting the expression for $\\mathbf{C}$:\n$$\n\\mathbf{E} = \\frac{1}{2} \\left( \\begin{bmatrix} \\lambda_1^2 & 0 & 0 \\\\ 0 & \\lambda_2^2 & 0 \\\\ 0 & 0 & \\lambda_3^2 \\end{bmatrix} - \\begin{bmatrix} 1 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{bmatrix} \\right) = \\frac{1}{2} \\begin{bmatrix} \\lambda_1^2 - 1 & 0 & 0 \\\\ 0 & \\lambda_2^2 - 1 & 0 \\\\ 0 & 0 & \\lambda_3^2 - 1 \\end{bmatrix}\n$$\n\nNow, we perform the right polar decomposition of $\\mathbf{F}$, which states that $\\mathbf{F}$ can be uniquely written as $\\mathbf{F} = \\mathbf{R} \\mathbf{U}$, where $\\mathbf{R}$ is a proper orthogonal tensor (the rotation tensor) and $\\mathbf{U}$ is a positive definite, symmetric tensor (the right stretch tensor).\nThe tensor $\\mathbf{U}$ can be computed from $\\mathbf{C}$ using the relation $\\mathbf{C} = \\mathbf{U}^2$, which implies $\\mathbf{U} = \\sqrt{\\mathbf{C}}$.\nFor the diagonal tensor $\\mathbf{C}$ we found, its principal square root is a diagonal tensor whose elements are the square roots of the diagonal elements of $\\mathbf{C}$.\n$$\n\\mathbf{U} = \\sqrt{\\mathbf{C}} = \\begin{bmatrix} \\sqrt{\\lambda_1^2} & 0 & 0 \\\\ 0 & \\sqrt{\\lambda_2^2} & 0 \\\\ 0 & 0 & \\sqrt{\\lambda_3^2} \\end{bmatrix}\n$$\nSince it is given that $\\lambda_1, \\lambda_2, \\lambda_3 > 0$, we have $\\sqrt{\\lambda_i^2} = \\lambda_i$.\n$$\n\\mathbf{U} = \\begin{bmatrix} \\lambda_1 & 0 & 0 \\\\ 0 & \\lambda_2 & 0 \\\\ 0 & 0 & \\lambda_3 \\end{bmatrix}\n$$\nNote that in this specific case of pure homogeneous stretch, $\\mathbf{U} = \\mathbf{F}$. This indicates the deformation is irrotational.\n\nThe rotation tensor $\\mathbf{R}$ can now be found from the decomposition $\\mathbf{F} = \\mathbf{R} \\mathbf{U}$. Since $\\mathbf{F}$ must be invertible for the decomposition to be unique ($\\det \\mathbf{F} \\neq 0$), we can write $\\mathbf{R} = \\mathbf{F} \\mathbf{U}^{-1}$.\nSubstituting our results for $\\mathbf{F}$ and $\\mathbf{U}$:\n$$\n\\mathbf{R} = \\mathbf{F} \\mathbf{U}^{-1} = \\begin{bmatrix} \\lambda_1 & 0 & 0 \\\\ 0 & \\lambda_2 & 0 \\\\ 0 & 0 & \\lambda_3 \\end{bmatrix} \\begin{bmatrix} \\frac{1}{\\lambda_1} & 0 & 0 \\\\ 0 & \\frac{1}{\\lambda_2} & 0 \\\\ 0 & 0 & \\frac{1}{\\lambda_3} \\end{bmatrix} = \\begin{bmatrix} 1 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{bmatrix} = \\mathbf{I}\n$$\nThe rotation tensor is the identity tensor $\\mathbf{I}$. This is a valid rotation tensor since it is orthogonal ($\\mathbf{I}^T\\mathbf{I} = \\mathbf{I}$) and has determinant $+1$. This confirms that the given deformation is a pure stretch with no rotation.\n\nFinally, we compute the Jacobian determinant, $J = \\det \\mathbf{F}$. The Jacobian measures the change in volume from the reference to the current configuration.\nUsing the matrix for $\\mathbf{F}$:\n$$\n\\mathbf{F} = \\begin{bmatrix} \\lambda_1 & 0 & 0 \\\\ 0 & \\lambda_2 & 0 \\\\ 0 & 0 & \\lambda_3 \\end{bmatrix}\n$$\nThe determinant of a diagonal matrix is the product of its diagonal elements.\n$$\nJ = \\det \\mathbf{F} = \\lambda_1 \\lambda_2 \\lambda_3\n$$\nThis is the final expression required by the problem.", "answer": "$$\n\\boxed{\\lambda_{1} \\lambda_{2} \\lambda_{3}}\n$$", "id": "3601263"}, {"introduction": "Having mastered pure stretch, we now tackle the classic case of simple shear, a deformation that inherently combines stretching and rotation. This practice [@problem_id:3516613] will challenge you to apply the polar decomposition to a non-symmetric deformation gradient, revealing the non-trivial rotation component that accompanies the shear. By analyzing the resulting strain tensor, you will gain crucial physical insight into finite deformation effects, such as the emergence of normal strains from a seemingly pure shear motion.", "problem": "Consider a homogeneous simple shear of a rectangular soil specimen commonly used in computational geomechanics to model direct shear, defined by the deformation mapping from the reference configuration coordinates $X_1, X_2, X_3$ to the current configuration coordinates $x_1, x_2, x_3$:\n$$x_{1} = X_{1} + \\gamma X_{2}, \\quad x_{2} = X_{2}, \\quad x_{3} = X_{3},$$\nwhere $\\gamma \\geq 0$ is the imposed shear amplitude. Using only fundamental definitions from finite deformation kinematics, compute the deformation gradient tensor, the right Cauchy–Green deformation tensor, the left Cauchy–Green deformation tensor, and the Green–Lagrange strain tensor associated with this mapping. Based on the polar decomposition of the deformation gradient tensor, interpret the physical meaning of the nonzero strain components you obtained, clarifying the roles of rotation and stretch in the shear. Then, determine the principal values (eigenvalues) of the Green–Lagrange strain tensor and identify the maximum principal Green–Lagrange strain as a function of $\\gamma$. Express your final answer as a single closed-form analytic expression in terms of $\\gamma$. No rounding is required, and since strain is dimensionless, no units are needed in the final answer.", "solution": "The problem is valid as it is scientifically grounded in continuum mechanics, well-posed, objective, and contains all necessary information for a unique solution.\n\nThe deformation mapping is given by:\n$$x_{1} = X_{1} + \\gamma X_{2}$$\n$$x_{2} = X_{2}$$\n$$x_{3} = X_{3}$$\nwhere $X_1, X_2, X_3$ are coordinates in the reference configuration and $x_1, x_2, x_3$ are coordinates in the current configuration. The parameter $\\gamma \\ge 0$ represents the shear amplitude.\n\nFirst, we compute the deformation gradient tensor $\\mathbf{F}$, whose components are defined as $F_{ij} = \\frac{\\partial x_i}{\\partial X_j}$.\nThe components are:\n$F_{11} = \\frac{\\partial}{\\partial X_1}(X_{1} + \\gamma X_{2}) = 1$\n$F_{12} = \\frac{\\partial}{\\partial X_2}(X_{1} + \\gamma X_{2}) = \\gamma$\n$F_{13} = \\frac{\\partial}{\\partial X_3}(X_{1} + \\gamma X_{2}) = 0$\n$F_{21} = \\frac{\\partial}{\\partial X_1}(X_{2}) = 0$\n$F_{22} = \\frac{\\partial}{\\partial X_2}(X_{2}) = 1$\n$F_{23} = \\frac{\\partial}{\\partial X_3}(X_{2}) = 0$\n$F_{31} = \\frac{\\partial}{\\partial X_1}(X_{3}) = 0$\n$F_{32} = \\frac{\\partial}{\\partial X_2}(X_{3}) = 0$\n$F_{33} = \\frac{\\partial}{\\partial X_3}(X_{3}) = 1$\n\nIn matrix form, the deformation gradient tensor $\\mathbf{F}$ is:\n$$\n\\mathbf{F} = \\begin{pmatrix} 1 & \\gamma & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix}\n$$\n\nNext, we compute the right Cauchy–Green deformation tensor $\\mathbf{C}$, defined as $\\mathbf{C} = \\mathbf{F}^T \\mathbf{F}$.\n$$\n\\mathbf{C} = \\begin{pmatrix} 1 & 0 & 0 \\\\ \\gamma & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} \\begin{pmatrix} 1 & \\gamma & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} = \\begin{pmatrix} 1 & \\gamma & 0 \\\\ \\gamma & \\gamma^2 + 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix}\n$$\n\nThe left Cauchy–Green deformation tensor $\\mathbf{B}$ is defined as $\\mathbf{B} = \\mathbf{F} \\mathbf{F}^T$.\n$$\n\\mathbf{B} = \\begin{pmatrix} 1 & \\gamma & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} \\begin{pmatrix} 1 & 0 & 0 \\\\ \\gamma & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} = \\begin{pmatrix} \\gamma^2 + 1 & \\gamma & 0 \\\\ \\gamma & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix}\n$$\n\nThe Green–Lagrange strain tensor $\\mathbf{E}$ is defined as $\\mathbf{E} = \\frac{1}{2}(\\mathbf{C} - \\mathbf{I})$, where $\\mathbf{I}$ is the identity tensor.\n$$\n\\mathbf{E} = \\frac{1}{2} \\left( \\begin{pmatrix} 1 & \\gamma & 0 \\\\ \\gamma & \\gamma^2 + 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} - \\begin{pmatrix} 1 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} \\right) = \\frac{1}{2} \\begin{pmatrix} 0 & \\gamma & 0 \\\\ \\gamma & \\gamma^2 & 0 \\\\ 0 & 0 & 0 \\end{pmatrix} = \\begin{pmatrix} 0 & \\frac{\\gamma}{2} & 0 \\\\ \\frac{\\gamma}{2} & \\frac{\\gamma^2}{2} & 0 \\\\ 0 & 0 & 0 \\end{pmatrix}\n$$\n\nFor the physical interpretation, we use the polar decomposition theorem, which states that any invertible deformation gradient $\\mathbf{F}$ can be uniquely decomposed into a rotation tensor $\\mathbf{R}$ and a symmetric positive-definite right stretch tensor $\\mathbf{U}$, such that $\\mathbf{F} = \\mathbf{R} \\mathbf{U}$. The tensor $\\mathbf{U}$ describes the pure deformation (stretching and shearing) of the material, while $\\mathbf{R}$ describes the rigid body rotation of the material element. The Green–Lagrange strain tensor $\\mathbf{E}$ is a measure of pure strain, as it is related to $\\mathbf{U}$ by $\\mathbf{E} = \\frac{1}{2}(\\mathbf{U}^2 - \\mathbf{I})$. For the given simple shear, $\\mathbf{F}$ is not symmetric for $\\gamma > 0$, which implies that the rotation tensor $\\mathbf{R}$ is not the identity tensor, so the deformation includes a rotational component. The nonzero components of $\\mathbf{E}$ elucidate the nature of the pure strain:\n$E_{12} = \\frac{\\gamma}{2}$ represents the shear strain component, quantifying the change in angle between material lines originally parallel to the $X_1$ and $X_2$ axes.\n$E_{22} = \\frac{\\gamma^2}{2}$ is a normal strain component along the $X_2$ direction. This is a finite deformation effect (often called the Poynting effect), which demonstrates that simple shear is accompanied by elongation or contraction in certain directions. This term is of second order in $\\gamma$ and is negligible in linearized, infinitesimal strain theory. Thus, the polar decomposition reveals that simple shear is not a \"pure shear\" but a combination of pure deformation (itself a mix of shearing and extension, measured by $\\mathbf{E}$) and a rigid body rotation.\n\nTo find the principal values of the Green–Lagrange strain tensor $\\mathbf{E}$, we solve the eigenvalue problem $\\det(\\mathbf{E} - \\lambda \\mathbf{I}) = 0$. The deformation is planar, so we analyze the upper-left $2 \\times 2$ submatrix. The third principal strain is evidently $0$.\n$$\n\\det \\begin{pmatrix} 0 - \\lambda & \\frac{\\gamma}{2} \\\\ \\frac{\\gamma}{2} & \\frac{\\gamma^2}{2} - \\lambda \\end{pmatrix} = 0\n$$\nThis gives the characteristic equation:\n$$\n(-\\lambda)\\left(\\frac{\\gamma^2}{2} - \\lambda\\right) - \\left(\\frac{\\gamma}{2}\\right)^2 = 0\n$$\n$$\n\\lambda^2 - \\frac{\\gamma^2}{2}\\lambda - \\frac{\\gamma^2}{4} = 0\n$$\nSolving this quadratic equation for $\\lambda$:\n$$\n\\lambda = \\frac{-(-\\frac{\\gamma^2}{2}) \\pm \\sqrt{(-\\frac{\\gamma^2}{2})^2 - 4(1)(-\\frac{\\gamma^2}{4})}}{2(1)}\n$$\n$$\n\\lambda = \\frac{\\frac{\\gamma^2}{2} \\pm \\sqrt{\\frac{\\gamma^4}{4} + \\gamma^2}}{2} = \\frac{\\frac{\\gamma^2}{2} \\pm \\sqrt{\\gamma^2(\\frac{\\gamma^2}{4} + 1)}}{2}\n$$\nSince $\\gamma \\ge 0$, we have $\\sqrt{\\gamma^2} = \\gamma$.\n$$\n\\lambda = \\frac{\\frac{\\gamma^2}{2} \\pm \\gamma \\sqrt{\\frac{\\gamma^2+4}{4}}}{2} = \\frac{\\frac{\\gamma^2}{2} \\pm \\frac{\\gamma}{2}\\sqrt{\\gamma^2+4}}{2}\n$$\n$$\n\\lambda = \\frac{\\gamma^2 \\pm \\gamma\\sqrt{\\gamma^2+4}}{4}\n$$\nThe three principal Green–Lagrange strains are:\n$$\n\\lambda_1 = \\frac{\\gamma^2 + \\gamma\\sqrt{\\gamma^2+4}}{4}\n$$\n$$\n\\lambda_2 = \\frac{\\gamma^2 - \\gamma\\sqrt{\\gamma^2+4}}{4}\n$$\n$$\n\\lambda_3 = 0\n$$\nTo find the maximum principal strain, we compare these values. Since $\\gamma \\ge 0$, the term $\\gamma\\sqrt{\\gamma^2+4}$ is non-negative.\nTherefore, $\\lambda_1 \\ge \\lambda_2$.\nAlso, for $\\gamma > 0$, we have $\\gamma^2 < \\gamma\\sqrt{\\gamma^2+4}$ because $\\gamma^4 < \\gamma^2(\\gamma^2+4) = \\gamma^4 + 4\\gamma^2$. This means $\\lambda_2 < 0$.\nClearly, $\\lambda_1 > 0$ for $\\gamma > 0$.\nTherefore, the maximum principal Green–Lagrange strain is $\\lambda_1$.\n\n$$\nE_{\\text{max}} = \\frac{\\gamma^2 + \\gamma\\sqrt{\\gamma^2+4}}{4}\n$$", "answer": "$$\n\\boxed{\\frac{\\gamma^2 + \\gamma\\sqrt{\\gamma^2+4}}{4}}\n$$", "id": "3516613"}, {"introduction": "We now transition from analytical calculations to a practical computational problem that addresses a critical issue in finite element simulations: element inversion. This coding exercise [@problem_id:3589220] demonstrates how the polar decomposition serves as a powerful tool to detect and repair non-physical deformation gradients where the determinant ($J$) is negative. You will implement a robust algorithm based on the Singular Value Decomposition (SVD) to project an invalid deformation state back onto a physically meaningful one, a technique essential for creating stable and realistic nonlinear solid mechanics simulations.", "problem": "Consider a three-dimensional deformation mapping from the reference configuration to the current configuration, with the deformation gradient denoted by $F \\in \\mathbb{R}^{3 \\times 3}$ and the Jacobian $J = \\det(F)$. In the mechanics of materials, physical realizability requires $F$ to be an element of the General Linear group with positive determinant ($GL^+(3)$), i.e., $J > 0$. In computational solid mechanics, incompatible interpolations of displacement or position fields can produce nonphysical $F$ with $J \\leq 0$, particularly $J < 0$ indicating a local inversion. Your task is to construct a program that detects such nonphysical cases and repairs them using polar decomposition and projection onto $GL^+(3)$, and then analyzes the effect on solution fidelity using a well-defined energy measure.\n\nYou are given a smooth ground-truth homogeneous deformation characterized by a proper rotation about the $z$-axis by angle $\\theta$ (in radians) and diagonal stretches $\\lambda_1$, $\\lambda_2$, $\\lambda_3$. The ground-truth deformation gradient is\n$$\nF_{\\text{true}} = R_z(\\theta)\\,\\mathrm{diag}(\\lambda_1,\\lambda_2,\\lambda_3),\n$$\nwhere $R_z(\\theta)$ is the rotation matrix about the $z$-axis. Your program must use $\\theta = 0.3$ (radians) and $(\\lambda_1,\\lambda_2,\\lambda_3) = (1.15, 0.90, 1.05)$.\n\nYou must construct three approximate deformation gradients, $F_{\\text{approx}}$, representing outcomes of incompatible interpolation:\n\n1. A small perturbation case (happy path) with $J>0$:\n$$\nF_{\\text{approx}}^{(1)} = F_{\\text{true}} + E^{(1)},\n$$\nwith\n$$\nE^{(1)} = \\begin{bmatrix}\n0.01 & -0.005 & 0.0 \\\\\n0.002 & 0.008 & 0.0 \\\\\n0.0 & 0.001 & -0.003\n\\end{bmatrix}.\n$$\n\n2. An orientation-inverted case where a reflection has been introduced along the $z$-axis:\n$$\nF_{\\text{approx}}^{(2)} = F_{\\text{true}}\\,\\mathrm{diag}(1,1,-1) + E^{(2)},\n$$\nwith\n$$\nE^{(2)} = 0.001 \\times \\begin{bmatrix}\n1 & 0 & 0 \\\\\n0 & -1 & 0 \\\\\n0 & 0 & 1\n\\end{bmatrix}.\n$$\n\n3. A near-singular orientation-inverted case, where the inversion magnitude is small:\n$$\nF_{\\text{approx}}^{(3)} = F_{\\text{true}}\\,\\mathrm{diag}(1,1,-0.02) + E^{(3)},\n$$\nwith\n$$\nE^{(3)} = 0.0005 \\times \\begin{bmatrix}\n-1 & 0 & 0 \\\\\n0 & 1 & 0 \\\\\n0 & 0 & -1\n\\end{bmatrix}.\n$$\n\nStarting from the polar decomposition definition, $F = R\\,U = V\\,R$, where $R$ is an orthogonal tensor and $U$ and $V$ are symmetric positive-definite stretch tensors, derive a principled algorithm that:\n- Detects nonphysical $F$ via the sign of $J$ and the character of $R$.\n- Repaires nonphysical $F$ by projecting it onto $GL^+(3)$ through the nearest proper rotation in the Special Orthogonal Group ($SO(3)$) applied to the polar factors. Use the fundamental properties of the Singular Value Decomposition (SVD) and orthogonal Procrustes projections to ensure the repaired $F_{\\text{proj}}$ has $J_{\\text{proj}}>0$ while minimally altering the stretch.\n\nFor each test case, quantify solution fidelity after repair using the compressible Neo-Hookean strain-energy density,\n$$\nW(F) = \\frac{\\mu}{2}\\left(\\mathrm{tr}(C) - 3\\right) - \\mu \\ln J + \\frac{\\lambda}{2} (\\ln J)^2,\n$$\nwhere $C = F^\\top F$, and $\\mu = 40$ and $\\lambda = 80$. If any intermediate quantity requires an angle, express it in radians. No physical units are required in the final outputs.\n\nYour program must:\n- Construct $F_{\\text{true}}$ using the specified $\\theta$ and $(\\lambda_1,\\lambda_2,\\lambda_3)$.\n- Assemble $F_{\\text{approx}}^{(i)}$ for $i = 1,2,3$ using the above definitions.\n- For each $F_{\\text{approx}}^{(i)}$, compute:\n    1. $J_{\\text{approx}}^{(i)} = \\det(F_{\\text{approx}}^{(i)})$,\n    2. The repaired $F_{\\text{proj}}^{(i)}$ by projection onto $GL^+(3)$ via polar decomposition and nearest proper rotation,\n    3. $J_{\\text{proj}}^{(i)} = \\det(F_{\\text{proj}}^{(i)})$,\n    4. The Frobenius-norm error before repair $e_{\\text{before}}^{(i)} = \\|F_{\\text{approx}}^{(i)} - F_{\\text{true}}\\|_F$,\n    5. The Frobenius-norm error after repair $e_{\\text{after}}^{(i)} = \\|F_{\\text{proj}}^{(i)} - F_{\\text{true}}\\|_F$,\n    6. The energy gap after repair $\\Delta W^{(i)} = W(F_{\\text{proj}}^{(i)}) - W(F_{\\text{true}})$.\n- Use $\\mathrm{tr}(\\cdot)$ for the trace and $\\|\\cdot\\|_F$ for the Frobenius norm.\n\nTest Suite and Final Output Specification:\n- The test suite is the set of three matrices $F_{\\text{approx}}^{(i)}$ defined above.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must contain three sublists, one for each test case $i = 1,2,3$, where the $i$-th sublist is\n$$\n\\left[J_{\\text{approx}}^{(i)}, J_{\\text{proj}}^{(i)}, e_{\\text{before}}^{(i)}, e_{\\text{after}}^{(i)}, \\Delta W^{(i)}\\right].\n$$\nFor example, the overall output format should be\n$$\n\\big[\\,[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],\\,[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],\\,[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot]\\,\\big]\n$$\nwith each $\\cdot$ replaced by a floating-point number and the angle used in radians.", "solution": "The user-provided problem is assessed to be valid. It is scientifically grounded in the principles of continuum mechanics, mathematically well-posed, objective, and provides all necessary information for a unique solution. The task is to analyze and repair non-physical deformation gradients, a standard problem in computational solid mechanics.\n\nThe core of the problem is to handle deformation gradients $F$ that are not physically realizable, specifically those with a non-positive Jacobian, $J = \\det(F) \\le 0$. Physical deformations must map a volume element to another volume element with the same orientation, which requires $J > 0$. An $F$ with $J > 0$ is an element of the general linear group with positive determinant, denoted $\\mathrm{GL}^+(3)$. When numerical methods produce an $F$ with $J \\le 0$, it must be projected onto $\\mathrm{GL}^+(3)$ to restore physical meaning.\n\nThe methodology for this projection is based on the polar decomposition of the deformation gradient, $F = R U$. Here, $R$ is an orthogonal tensor representing rotation and $U$ is a symmetric positive-definite tensor representing stretch. The right stretch tensor $U$ is uniquely determined by the Right Cauchy-Green deformation tensor $C = F^\\top F$ via $U = \\sqrt{C}$. The rotation tensor is then $R = F U^{-1}$.\n\nA computationally robust method to obtain the polar decomposition is through the Singular Value Decomposition (SVD) of $F$. Let the SVD of $F$ be:\n$$\nF = \\mathcal{U} \\Sigma \\mathcal{V}^\\top\n$$\nwhere $\\mathcal{U}$ and $\\mathcal{V}$ are orthogonal matrices ($\\mathcal{U}^\\top\\mathcal{U} = I$, $\\mathcal{V}^\\top\\mathcal{V} = I$) and $\\Sigma$ is a diagonal matrix containing the non-negative singular values $\\sigma_i$. From the SVD, the polar decomposition factors can be identified as:\n$$\nR = \\mathcal{U} \\mathcal{V}^\\top \\quad \\text{and} \\quad U = \\mathcal{V} \\Sigma \\mathcal{V}^\\top\n$$\nThe Jacobian $J$ can be expressed as $J = \\det(F) = \\det(\\mathcal{U}) \\det(\\Sigma) \\det(\\mathcal{V}^\\top) = \\det(\\mathcal{U}\\mathcal{V}^\\top)\\det(\\Sigma) = \\det(R) \\prod \\sigma_i$. Since all $\\sigma_i \\ge 0$, the sign of $J$ is determined by the sign of $\\det(R)$.\n- If $J > 0$, then $\\det(R) = +1$, and $R$ is a proper rotation, an element of the special orthogonal group $\\mathrm{SO}(3)$.\n- If $J < 0$, then $\\det(R) = -1$, and $R$ is an improper rotation (a reflection-rotation).\n- If $J = 0$, at least one $\\sigma_i=0$ and $F$ is singular.\n\nThe problem requires a principled repair algorithm that finds the nearest mapping in $\\mathrm{GL}^+(3)$ by minimally altering the stretch. This implies preserving the stretch tensor $U$ (which captures the physically meaningful deformation magnitude) and projecting the rotational part $R$ onto $\\mathrm{SO}(3)$. Given $R$ with $\\det(R) = -1$, the closest matrix $R_{\\text{proj}} \\in \\mathrm{SO}(3)$ in the Frobenius norm sense is sought. This is a classic orthogonal Procrustes problem.\n\nThe solution is found by modifying the SVD factors of $F$. If $\\det(R) = \\det(\\mathcal{U}\\mathcal{V}^\\top) = -1$, we can construct a new orthogonal matrix $\\mathcal{U}_{\\text{proj}}$ by flipping the sign of one of its columns, say the last one.\n$$\n\\mathcal{U}_{\\text{proj}} = \\mathcal{U} \\cdot \\mathrm{diag}(1, 1, -1)\n$$\nThis ensures that $\\det(\\mathcal{U}_{\\text{proj}}) = -\\det(\\mathcal{U})$, and consequently $\\det(\\mathcal{U}_{\\text{proj}}\\mathcal{V}^\\top) = -\\det(\\mathcal{U}\\mathcal{V}^\\top) = +1$. The projected rotation is then $R_{\\text{proj}} = \\mathcal{U}_{\\text{proj}} \\mathcal{V}^\\top$.\n\nSince we must preserve the stretch tensor $U = \\mathcal{V} \\Sigma \\mathcal{V}^\\top$, the repaired deformation gradient $F_{\\text{proj}}$ is constructed as:\n$$\nF_{\\text{proj}} = R_{\\text{proj}} U = (\\mathcal{U}_{\\text{proj}} \\mathcal{V}^\\top) (\\mathcal{V} \\Sigma \\mathcal{V}^\\top) = \\mathcal{U}_{\\text{proj}} \\Sigma \\mathcal{V}^\\top\n$$\nThis provides a simple and robust algorithm:\n1.  Compute the SVD of the approximate deformation gradient $F_{\\text{approx}} = \\mathcal{U} \\Sigma \\mathcal{V}^\\top$.\n2.  Check if a repair is needed by computing $J_{\\text{approx}} = \\det(F_{\\text{approx}})$. If $J_{\\text{approx}} > 0$, no repair is needed, and $F_{\\text{proj}} = F_{\\text{approx}}$.\n3.  If $J_{\\text{approx}} \\le 0$, construct the projected matrix $F_{\\text{proj}} = \\mathcal{U}_{\\text{proj}} \\Sigma \\mathcal{V}^\\top$, where $\\mathcal{U}_{\\text{proj}}$ is $\\mathcal{U}$ with the sign of its last column flipped. This ensures $\\det(F_{\\text{proj}}) > 0$ (unless $F_{\\text{approx}}$ was singular, in which case $\\det(F_{\\text{proj}}) = 0$).\n\nWe will apply this procedure to the three given test cases. First, we construct the ground-truth deformation gradient $F_{\\text{true}}$ with $\\theta = 0.3$ radians, $\\lambda_1 = 1.15$, $\\lambda_2 = 0.90$, and $\\lambda_3 = 1.05$.\n$$\nR_z(0.3) = \\begin{bmatrix} \\cos(0.3) & -\\sin(0.3) & 0 \\\\ \\sin(0.3) & \\cos(0.3) & 0 \\\\ 0 & 0 & 1 \\end{bmatrix}, \\quad \\Lambda = \\begin{bmatrix} 1.15 & 0 & 0 \\\\ 0 & 0.90 & 0 \\\\ 0 & 0 & 1.05 \\end{bmatrix}\n$$\n$$\nF_{\\text{true}} = R_z(0.3) \\Lambda\n$$\nThen, we construct the three approximate tensors $F_{\\text{approx}}^{(i)}$ for $i=1,2,3$ as specified. For each case, we compute the following quantities:\n1.  $J_{\\text{approx}}^{(i)} = \\det(F_{\\text{approx}}^{(i)})$.\n2.  The repaired deformation gradient $F_{\\text{proj}}^{(i)}$ using the SVD-based projection.\n3.  $J_{\\text{proj}}^{(i)} = \\det(F_{\\text{proj}}^{(i)})$.\n4.  The Frobenius-norm error before repair: $e_{\\text{before}}^{(i)} = \\|F_{\\text{approx}}^{(i)} - F_{\\text{true}}\\|_F$.\n5.  The Frobenius-norm error after repair: $e_{\\text{after}}^{(i)} = \\|F_{\\text{proj}}^{(i)} - F_{\\text{true}}\\|_F$.\n6.  The energy gap after repair, $\\Delta W^{(i)} = W(F_{\\text{proj}}^{(i)}) - W(F_{\\text{true}})$, using the compressible Neo-Hookean strain-energy density function with material parameters $\\mu = 40$ and $\\lambda = 80$:\n$$\nW(F) = \\frac{\\mu}{2}\\left(\\mathrm{tr}(F^\\top F) - 3\\right) - \\mu \\ln(\\det(F)) + \\frac{\\lambda}{2} (\\ln(\\det(F)))^2\n$$\nThe results for each test case will be collected and formatted as specified.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of detecting and repairing non-physical deformation gradients.\n    \"\"\"\n\n    # Define constants and parameters\n    theta = 0.3  # radians\n    lambdas = np.array([1.15, 0.90, 1.05])\n    mu = 40.0\n    lam = 80.0\n\n    # Define perturbation matrices\n    E1 = np.array([\n        [0.01, -0.005, 0.0],\n        [0.002, 0.008, 0.0],\n        [0.0, 0.001, -0.003]\n    ])\n    E2 = 0.001 * np.array([\n        [1.0, 0.0, 0.0],\n        [0.0, -1.0, 0.0],\n        [0.0, 0.0, 1.0]\n    ])\n    E3 = 0.0005 * np.array([\n        [-1.0, 0.0, 0.0],\n        [0.0, 1.0, 0.0],\n        [0.0, 0.0, -1.0]\n    ])\n\n    # Construct ground-truth deformation gradient F_true\n    c, s = np.cos(theta), np.sin(theta)\n    Rz = np.array([[c, -s, 0], [s, c, 0], [0, 0, 1]])\n    Lambda_diag = np.diag(lambdas)\n    F_true = Rz @ Lambda_diag\n\n    # Define test cases by constructing F_approx matrices\n    F_approx_1 = F_true + E1\n    F_approx_2 = F_true @ np.diag([1, 1, -1]) + E2\n    F_approx_3 = F_true @ np.diag([1, 1, -0.02]) + E3\n    \n    test_cases = [F_approx_1, F_approx_2, F_approx_3]\n\n    def calc_W(F, mu, lam):\n        \"\"\"Computes the compressible Neo-Hookean strain-energy density.\"\"\"\n        C = F.T @ F\n        J = np.linalg.det(F)\n        if J <= 0:\n            # Energy is undefined for non-physical deformations.\n            # This branch should not be taken by F_proj or F_true.\n            return np.inf \n        \n        # Explicitly taking log to avoid domain errors if by some chance J is negative\n        log_J = np.log(J) if J > 0 else -np.inf\n\n        W = (mu / 2.0) * (np.trace(C) - 3.0) - mu * log_J + (lam / 2.0) * (log_J**2)\n        return W\n\n    # Calculate energy of the ground-truth state\n    W_true = calc_W(F_true, mu, lam)\n    \n    results = []\n    for F_approx in test_cases:\n        # 1. Compute J_approx\n        J_approx = np.linalg.det(F_approx)\n\n        # 2. Repair F_approx by projection if necessary\n        U, s, Vh = np.linalg.svd(F_approx)\n        \n        # The determinant of the rotational part R = U @ Vh determines orientation\n        det_R = np.linalg.det(U @ Vh)\n\n        if det_R < 0: # also covers J_approx <= 0 cases where F is not singular\n            # Flip the sign of the last column of U to ensure det(R_proj) = 1\n            U_proj = U.copy()\n            U_proj[:, -1] *= -1\n            # Reconstruct F_proj = U_proj * Sigma * Vh\n            F_proj = U_proj @ np.diag(s) @ Vh\n        else:\n            # No repair needed for orientation\n            F_proj = F_approx\n\n        # 3. Compute J_proj\n        J_proj = np.linalg.det(F_proj)\n\n        # 4. Compute Frobenius-norm error before repair\n        e_before = np.linalg.norm(F_approx - F_true, 'fro')\n\n        # 5. Compute Frobenius-norm error after repair\n        e_after = np.linalg.norm(F_proj - F_true, 'fro')\n\n        # 6. Compute energy gap after repair\n        W_proj = calc_W(F_proj, mu, lam)\n        delta_W = W_proj - W_true\n        \n        results.append([J_approx, J_proj, e_before, e_after, delta_W])\n\n    # Format the final output string as [[...],[...],[...]]\n    sublist_strings = []\n    for sublist in results:\n        sublist_strings.append(f\"[{','.join(map(str, sublist))}]\")\n    final_output_str = f\"[{','.join(sublist_strings)}]\"\n    \n    print(final_output_str)\n\nsolve()\n```", "id": "3589220"}]}