{"hands_on_practices": [{"introduction": "The mathematical invariants of a stress tensor are not merely abstract curiosities; they are the building blocks for constitutive models that describe material behavior. This exercise demonstrates how to construct an isotropic plastic yield surface using the pressure $p$, and the second and third deviatoric invariants, $J_2$ and $J_3$. You will implement this model and then design targeted numerical experiments to probe its key features, learning how to isolate and verify pressure sensitivity and Lode angle dependence—a core skill in material model development and calibration [@problem_id:3605161].", "problem": "You are tasked with designing, analyzing, and testing an isotropic plastic yield surface for a solid mechanics model using fundamental tensor invariants. The formulation must depend only on scalar invariants of the Cauchy stress tensor to ensure isotropy, and the tests must explicitly check hydrostatic-shift behavior and sensitivity to the third invariant via paths that traverse the Lode angle. All stresses shall be specified in megapascal (MPa), all angles in radians, and all outputs from the yield function shall be dimensionless.\n\nFundamental base and definitions:\n- Let the Cauchy stress tensor be denoted by $\\boldsymbol{\\sigma} \\in \\mathbb{R}^{3 \\times 3}$.\n- The mean stress (pressure) is defined as $p = \\dfrac{\\operatorname{tr}(\\boldsymbol{\\sigma})}{3}$.\n- The deviatoric stress tensor is defined as $\\boldsymbol{s} = \\boldsymbol{\\sigma} - p \\boldsymbol{I}$, where $\\boldsymbol{I}$ is the identity tensor.\n- The second invariant of the deviatoric stress is $J_2 = \\dfrac{1}{2} \\boldsymbol{s}:\\boldsymbol{s}$.\n- The third invariant of the deviatoric stress is $J_3 = \\det(\\boldsymbol{s})$.\n- The Lode angle $\\theta \\in \\left[-\\dfrac{\\pi}{6},\\dfrac{\\pi}{6}\\right]$ is defined implicitly by the relation\n$$\n\\cos(3\\theta) = \\dfrac{3\\sqrt{3}}{2} \\dfrac{J_3}{J_2^{3/2}},\n$$\nwith appropriate numerical clipping to $[-1,1]$ for robustness, and $\\theta = \\dfrac{1}{3}\\arccos\\left(\\dfrac{3\\sqrt{3}}{2} \\dfrac{J_3}{J_2^{3/2}}\\right)$ for $J_2 > 0$. For $J_2 = 0$, define $\\theta = 0$ as a conventional limiting value.\n\nYou must formulate the following isotropic yield function:\n$$\nF(J_2, J_3, p) = \\dfrac{\\sqrt{J_2}}{\\kappa(p)} \\left(1 + \\beta \\cos(3\\theta)\\right) - 1,\n$$\nwhere $\\kappa(p) = k_0 + k_1 p$, with the constants $k_0 = 60$ MPa, $k_1 = 0.01$ (dimensionless), and the Lode dependence parameter $\\beta \\in \\mathbb{R}$. This $F$ is required to be expressed in terms of the invariants $J_2$, $J_3$, and $p$ only.\n\nTasks:\n1. Implement robust numerical functions to compute $p$, $\\boldsymbol{s}$, $J_2$, $J_3$, and $\\theta$ for any given $3 \\times 3$ stress tensor $\\boldsymbol{\\sigma}$ in MPa, using the definitions above. Compute $\\cos(3\\theta)$ from the invariants using the formula provided and ensure numerical clipping to $[-1,1]$ before applying $\\arccos(\\cdot)$.\n2. Implement the yield function $F(J_2, J_3, p)$ with the constants $k_0 = 60$ MPa and $k_1 = 0.01$, evaluated for two cases of $\\beta$: $\\beta = 0.3$ and $\\beta = 0$.\n3. Demonstrate equivalence under hydrostatic shifts: construct two stress states $\\boldsymbol{\\sigma}_a$ and $\\boldsymbol{\\sigma}_b$ that differ only by a hydrostatic shift, i.e., $\\boldsymbol{\\sigma}_b = \\boldsymbol{\\sigma}_a + \\Delta p \\boldsymbol{I}$ for a specified $\\Delta p$. Show numerically that $J_2(\\boldsymbol{\\sigma}_a) = J_2(\\boldsymbol{\\sigma}_b)$, $J_3(\\boldsymbol{\\sigma}_a) = J_3(\\boldsymbol{\\sigma}_b)$, and $\\cos(3\\theta(\\boldsymbol{\\sigma}_a)) = \\cos(3\\theta(\\boldsymbol{\\sigma}_b))$ within a tolerance of $10^{-10}$, and report the difference $F(\\boldsymbol{\\sigma}_b) - F(\\boldsymbol{\\sigma}_a)$ for $\\beta = 0.3$.\n4. Test identification of $J_3$ sensitivity via synthetic stress paths that circle around the Lode angle: for fixed $p$ and fixed $J_2$, construct a set of deviatoric principal stresses $\\{s_1, s_2, s_3\\}$ parametrized by $\\theta \\in [-\\pi/6, \\pi/6]$ such that $\\operatorname{tr}(\\boldsymbol{s}) = 0$ and $J_2$ is held constant. Use the parametrization\n$$\ns_1(\\theta) = \\dfrac{2}{\\sqrt{6}} R \\cos(\\theta), \\quad s_2(\\theta) = \\dfrac{2}{\\sqrt{6}} R \\cos\\left(\\theta - \\dfrac{2\\pi}{3}\\right), \\quad s_3(\\theta) = \\dfrac{2}{\\sqrt{6}} R \\cos\\left(\\theta + \\dfrac{2\\pi}{3}\\right),\n$$\nwhere $R = \\sqrt{2 J_2}$. Compose $\\boldsymbol{\\sigma}(\\theta) = p \\boldsymbol{I} + \\operatorname{diag}(s_1(\\theta), s_2(\\theta), s_3(\\theta))$. Evaluate $F$ along this path for both $\\beta = 0.3$ and $\\beta = 0$, and report the amplitude (maximum minus minimum) of $F$ across the path for each $\\beta$. Conclude whether the path reveals $J_3$ sensitivity by checking if the amplitude is positive for $\\beta = 0.3$ and approximately zero (within $10^{-10}$) for $\\beta = 0$.\n5. Evaluate the yield function for a purely hydrostatic stress state ($J_2 = 0$) and for a general non-hydrostatic stress state.\n\nUse the following explicit test suite of stress states, parameters, and path values (all stresses in MPa, angles in radians):\n- Hydrostatic-shift test:\n  - Base deviatoric principal stresses: $s_1 = 10$, $s_2 = -5$, $s_3 = -5$ (so $\\operatorname{tr}(\\boldsymbol{s}) = 0$).\n  - Base mean stress: $p_a = 30$.\n  - Shift: $\\Delta p = 50$.\n  - Define $\\boldsymbol{\\sigma}_a = p_a \\boldsymbol{I} + \\operatorname{diag}(10, -5, -5)$ and $\\boldsymbol{\\sigma}_b = (p_a + \\Delta p)\\boldsymbol{I} + \\operatorname{diag}(10, -5, -5)$.\n  - Tolerance for equality checks: $10^{-10}$.\n- Lode-angle path:\n  - Fixed mean stress $p = 30$.\n  - Fixed $J_2 = 1600$.\n  - Path angles: $\\theta \\in \\{-\\dfrac{\\pi}{6}, -\\dfrac{\\pi}{9}, -\\dfrac{\\pi}{12}, -\\dfrac{\\pi}{18}, 0, \\dfrac{\\pi}{18}, \\dfrac{\\pi}{12}, \\dfrac{\\pi}{9}, \\dfrac{\\pi}{6}\\}$.\n  - Evaluate amplitudes for $\\beta = 0.3$ and for $\\beta = 0$.\n- Pure hydrostatic state:\n  - $\\boldsymbol{\\sigma}_h = 50 \\boldsymbol{I}$ (i.e., $p = 50$, $J_2 = 0$).\n- General non-hydrostatic state:\n  - $\\boldsymbol{\\sigma}_g = \\begin{bmatrix} 120 & 15 & -10 \\\\ 15 & 80 & 5 \\\\ -10 & 5 & 100 \\end{bmatrix}$.\n\nYour program must:\n- Implement the invariant calculations and the yield function as specified.\n- Apply the test suite in the order provided and compute the following outputs:\n  1. For the hydrostatic-shift test on $\\boldsymbol{\\sigma}_a$ and $\\boldsymbol{\\sigma}_b$ with $\\beta = 0.3$: three booleans indicating equality of $J_2$, $J_3$, and $\\cos(3\\theta)$ (each within the tolerance $10^{-10}$), followed by the float difference $F(\\boldsymbol{\\sigma}_b) - F(\\boldsymbol{\\sigma}_a)$.\n  2. For the Lode-angle path: the float amplitude of $F$ across the path for $\\beta = 0.3$, the float amplitude for $\\beta = 0$, a boolean indicating the nonzero amplitude for $\\beta = 0.3$, and a boolean indicating the near-zero amplitude for $\\beta = 0$ within $10^{-10}$.\n  3. The float $F(\\boldsymbol{\\sigma}_h)$ for the purely hydrostatic state with $\\beta = 0.3$.\n  4. The float $F(\\boldsymbol{\\sigma}_g)$ for the general state with $\\beta = 0.3$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3]\"), in the exact order described above. This output list must therefore contain $10$ entries: $3$ booleans and $1$ float from the hydrostatic-shift test, $2$ floats and $2$ booleans from the Lode-angle path, and $2$ floats from the hydrostatic and general states, respectively.", "solution": "The user has provided a problem in computational solid mechanics concerning the implementation and verification of an isotropic plastic yield surface. I will first validate the problem statement to ensure its correctness and solvability before proceeding.\n\n### Step 1: Extract Givens\n\n- **Cauchy Stress Tensor**: $\\boldsymbol{\\sigma} \\in \\mathbb{R}^{3 \\times 3}$.\n- **Mean Stress (Pressure)**: $p = \\dfrac{\\operatorname{tr}(\\boldsymbol{\\sigma})}{3}$.\n- **Deviatoric Stress Tensor**: $\\boldsymbol{s} = \\boldsymbol{\\sigma} - p \\boldsymbol{I}$, where $\\boldsymbol{I}$ is the identity tensor.\n- **Second Deviatoric Stress Invariant**: $J_2 = \\dfrac{1}{2} \\boldsymbol{s}:\\boldsymbol{s}$.\n- **Third Deviatoric Stress Invariant**: $J_3 = \\det(\\boldsymbol{s})$.\n- **Lode Angle ($\\theta$)**: Defined by $\\cos(3\\theta) = \\dfrac{3\\sqrt{3}}{2} \\dfrac{J_3}{J_2^{3/2}}$, with $\\theta \\in \\left[-\\dfrac{\\pi}{6},\\dfrac{\\pi}{6}\\right]$. For computation, $\\theta = \\dfrac{1}{3}\\arccos\\left(\\dfrac{3\\sqrt{3}}{2} \\dfrac{J_3}{J_2^{3/2}}\\right)$ for $J_2 > 0$ after clipping the argument of arccos to $[-1,1]$, and $\\theta = 0$ for $J_2=0$.\n- **Yield Function ($F$)**: $F(J_2, J_3, p) = \\dfrac{\\sqrt{J_2}}{\\kappa(p)} \\left(1 + \\beta \\cos(3\\theta)\\right) - 1$.\n- **Hardening Function ($\\kappa$)**: $\\kappa(p) = k_0 + k_1 p$.\n- **Constants**: $k_0 = 60$ MPa, $k_1 = 0.01$ (dimensionless), parameter $\\beta \\in \\{0.3, 0\\}$.\n- **Tasks**:\n  1. Implement robust numerical functions for invariants and the yield function.\n  2. Implement the yield function for $\\beta = 0.3$ and $\\beta = 0$.\n  3. Perform a hydrostatic-shift test.\n  4. Perform a Lode-angle path test.\n  5. Evaluate the yield function for specific stress states.\n- **Test Suite**:\n  - **Hydrostatic-shift test**: Base deviatoric principal stresses $s_1=10, s_2=-5, s_3=-5$; base mean stress $p_a=30$; shift $\\Delta p=50$. Tolerance $10^{-10}$. Use $\\beta=0.3$.\n  - **Lode-angle path**: Fixed $p=30$, fixed $J_2=1600$. Path angles $\\theta \\in \\{-\\dfrac{\\pi}{6}, -\\dfrac{\\pi}{9}, -\\dfrac{\\pi}{12}, -\\dfrac{\\pi}{18}, 0, \\dfrac{\\pi}{18}, \\dfrac{\\pi}{12}, \\dfrac{\\pi}{9}, \\dfrac{\\pi}{6}\\}$. Path parametrization: $s_1(\\theta) = \\dfrac{2}{\\sqrt{6}} R \\cos(\\theta)$, $s_2(\\theta) = \\dfrac{2}{\\sqrt{6}} R \\cos\\left(\\theta - \\dfrac{2\\pi}{3}\\right)$, $s_3(\\theta) = \\dfrac{2}{\\sqrt{6}} R \\cos\\left(\\theta + \\dfrac{2\\pi}{3}\\right)$, where $R = \\sqrt{2 J_2}$.\n  - **Pure hydrostatic state**: $\\boldsymbol{\\sigma}_h = 50 \\boldsymbol{I}$.\n  - **General non-hydrostatic state**: $\\boldsymbol{\\sigma}_g = \\begin{bmatrix} 120 & 15 & -10 \\\\ 15 & 80 & 5 \\\\ -10 & 5 & 100 \\end{bmatrix}$.\n\n- **Required Output**: A list of $10$ specific results in a predefined order.\n\n### Step 2: Validate Using Extracted Givens\n\n- **Scientific Grounding**: The problem is firmly rooted in the classical theory of plasticity within continuum mechanics. The definitions of stress invariants ($p$, $J_2$, $J_3$), Lode angle ($\\theta$), and the general form of the isotropic yield function $F(p, J_2, J_3)$ are standard. The provided yield function is a specific instance of a pressure-sensitive model with Lode-angle dependence, a well-established class of models. The stress path parametrization for the Lode angle test correctly isolates the effect of the third invariant $J_3$ by keeping $p$ and $J_2$ constant. The problem is scientifically sound.\n- **Well-Posedness**: All necessary definitions, constants, and test cases are explicitly provided. The computational tasks are unambiguous and lead to a unique set of numerical results. The special case of hydrostatic stress ($J_2=0$), where the definition of the Lode angle becomes indeterminate, is handled by a stated convention ($\\theta = 0$), ensuring the problem is well-posed everywhere.\n- **Objectivity**: The problem is stated in precise, formal mathematical and engineering language, free of any subjectivity or ambiguity.\n- **Completeness and Consistency**: The problem is self-contained. All data and definitions required for the solution are provided. There are no internal contradictions. For example, the units are consistent: $k_0$ and $p$ in MPa, $k_1$ dimensionless, lead to $\\kappa$ in MPa. $\\sqrt{J_2}$ is in MPa, so the ratio $\\sqrt{J_2}/\\kappa$ is dimensionless, making the entire yield function $F$ dimensionless as required.\n\n### Step 3: Verdict and Action\n\nThe problem is valid. It is scientifically grounded, well-posed, and complete. I will proceed with the solution.\n\n### Principle-Based Design\n\nThe solution will be structured into a series of functions, each representing a key physical or mathematical concept. This modular design enhances clarity and correctness.\n\n1.  **`compute_invariants(sigma)` Function**: This core function encapsulates the fundamental principles of tensor decomposition and invariants.\n    -   Given a Cauchy stress tensor $\\boldsymbol{\\sigma}$, it first computes the volumetric part of the stress, represented by the mean stress or pressure $p = \\frac{1}{3}\\operatorname{tr}(\\boldsymbol{\\sigma})$. This isolates the hydrostatic component.\n    -   Next, it computes the deviatoric stress tensor $\\boldsymbol{s} = \\boldsymbol{\\sigma} - p\\boldsymbol{I}$, which represents the shear (shape-changing) part of the stress state. By definition, $\\operatorname{tr}(\\boldsymbol{s}) = 0$.\n    -   It then calculates the principal scalar invariants of the deviatoric stress tensor, $J_2$ and $J_3$.\n        -   $J_2 = \\frac{1}{2}\\boldsymbol{s}:\\boldsymbol{s}$ is a measure of the magnitude of the deviatoric stress. The double-dot product $\\boldsymbol{s}:\\boldsymbol{s}$ is the sum of the squares of the components of $\\boldsymbol{s}$.\n        -   $J_3 = \\det(\\boldsymbol{s})$ is related to the third principal invariant of $\\boldsymbol{s}$ and characterizes the type of shear state.\n    -   Finally, it computes $\\cos(3\\theta)$, a measure related to the Lode angle, directly from the invariants. The formula $\\cos(3\\theta) = \\frac{3\\sqrt{3}}{2} \\frac{J_3}{J_2^{3/2}}$ is used. A critical numerical robustness step is included: if $J_2$ is close to zero (hydrostatic state), $\\cos(3\\theta)$ is set to $1$ by convention, as $J_3$ will also be zero. The argument to the expression is also clipped to the valid range $[-1, 1]$ to prevent domain errors in potential inverse trigonometric function calls, although the yield function itself only requires $\\cos(3\\theta)$, not $\\theta$.\n\n2.  **`yield_function(p, J2, cos3theta, beta, k0, k1)` Function**: This function implements the specific constitutive model for the yield surface.\n    -   Its inputs are the scalar invariants ($p, J2, \\cos(3\\theta)$) and material parameters ($\\beta, k0, k1$), reflecting the principle of isotropy (dependence only on invariants).\n    -   It first computes the pressure-dependent cohesion term $\\kappa(p) = k_0 + k_1 p$. This linear function models the increase (or decrease) in shear strength with hydrostatic pressure, characteristic of materials like soils, rocks, and polymers.\n    -   It then evaluates the yield criterion $F = \\frac{\\sqrt{J_2}}{\\kappa(p)} (1 + \\beta \\cos(3\\theta)) - 1$.\n        -   The term $\\sqrt{J_2}$ represents a measure of equivalent shear stress.\n        -   The term $(1 + \\beta \\cos(3\\theta))$ introduces sensitivity to the third invariant, making the yield surface shape in the deviatoric plane (the \"$\\pi$-plane\") non-circular. When $\\beta=0$, this dependence vanishes, and the model reduces to a Lode-angle-independent form like the Drucker-Prager criterion.\n        -   The function returns a dimensionless value: $F < 0$ implies an elastic state, $F = 0$ implies a state on the yield surface (plastic yielding), and $F > 0$ represents a mathematically non-admissible stress state.\n\n3.  **Test Procedures**: The subsequent parts of the code are designed as specific numerical experiments to verify the physical and mathematical properties of the implemented model.\n    -   **Hydrostatic-Shift Test**: This test verifies a fundamental property of the deviatoric invariants $J_2$ and $J_3$. Adding a purely hydrostatic stress ($\\Delta p \\boldsymbol{I}$) to a stress tensor $\\boldsymbol{\\sigma}$ only shifts its volumetric component $p$, leaving the deviatoric component $\\boldsymbol{s}$ unchanged. Consequently, $J_2$ and $J_3$ must remain invariant. The test confirms this numerically. It also demonstrates how the yield function value $F$ changes due to the pressure dependence of $\\kappa(p)$.\n    -   **Lode-Angle Path Test**: This test is designed to probe the sensitivity of the yield function to the third invariant, $J_3$. By constructing a stress path where $p$ and $J_2$ are held constant while the Lode angle $\\theta$ varies, we isolate the effect of the term $\\beta \\cos(3\\theta)$. The test computes the amplitude of variation in $F$ along this path. For $\\beta \\neq 0$, the amplitude should be non-zero, confirming $J_3$ sensitivity. For $\\beta = 0$, the amplitude must be zero (within numerical tolerance), confirming the model's reduction to a $J_3$-independent form.\n    -   **Specific State Evaluations**: Finally, the function is evaluated for a purely hydrostatic state ($\\boldsymbol{s}=\\mathbf{0}$, hence $J_2=0$) and a general, non-diagonal stress state to ensure the implementation is robust and correct for various inputs. For the hydrostatic case, $F$ must evaluate to $-1$, as $\\sqrt{J_2}=0$.\n\nThe overall design follows a principle of building from fundamental physical quantities (stress invariants) to a constitutive model (yield function) and then using targeted numerical experiments to validate key theoretical properties of that model.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to execute the full test suite for the isotropic yield surface.\n    \"\"\"\n\n    # --- Constants and Parameters from Problem Statement ---\n    k0 = 60.0  # MPa\n    k1 = 0.01  # dimensionless\n    TOLERANCE = 1e-10\n\n    # --- Helper Functions ---\n\n    def compute_invariants(sigma):\n        \"\"\"\n        Computes the pressure p, and deviatoric invariants J2, J3, and cos(3*theta).\n\n        Args:\n            sigma (np.ndarray): A 3x3 Cauchy stress tensor.\n\n        Returns:\n            tuple: A tuple containing (p, J2, J3, cos3theta).\n        \"\"\"\n        if not isinstance(sigma, np.ndarray) or sigma.shape != (3, 3):\n            raise TypeError(\"Input sigma must be a 3x3 numpy array.\")\n\n        # Mean stress (pressure)\n        p = np.trace(sigma) / 3.0\n\n        # Deviatoric stress tensor\n        s = sigma - p * np.identity(3)\n\n        # Second invariant of deviatoric stress\n        # s:s = sum(s_ij * s_ij)\n        J2 = 0.5 * np.sum(s**2)\n\n        # Third invariant of deviatoric stress\n        J3 = np.linalg.det(s)\n\n        # cos(3*theta)\n        if J2 <= TOLERANCE:\n            # Hydrostatic state convention\n            cos3theta = 1.0\n        else:\n            # Argument for arccos in Lode angle definition\n            arg = (3.0 * np.sqrt(3.0) / 2.0) * J3 / (J2**1.5)\n            # Numerical clipping for robustness\n            cos3theta = np.clip(arg, -1.0, 1.0)\n            \n        return p, J2, J3, cos3theta\n\n    def yield_function(p, J2, cos3theta, beta):\n        \"\"\"\n        Computes the value of the isotropic yield function F.\n\n        Args:\n            p (float): Mean stress.\n            J2 (float): Second deviatoric invariant.\n            cos3theta (float): Cosine of 3 times the Lode angle.\n            beta (float): Lode dependence parameter.\n\n        Returns:\n            float: The dimensionless value of the yield function F.\n        \"\"\"\n        if J2 < 0:\n            # J2 must be non-negative by definition\n            J2 = 0\n            \n        kappa = k0 + k1 * p\n        if abs(kappa) < TOLERANCE:\n            # Avoid division by zero, return large value if on failure locus\n            return np.inf if J2 > TOLERANCE else -1.0\n            \n        F_val = (np.sqrt(J2) / kappa) * (1.0 + beta * cos3theta) - 1.0\n        return F_val\n\n    results = []\n\n    # --- Task 3: Hydrostatic-shift test ---\n    beta_hydro_shift = 0.3\n    s_diag_a = np.array([10.0, -5.0, -5.0])\n    p_a = 30.0\n    delta_p = 50.0\n    p_b = p_a + delta_p\n\n    sigma_a = np.diag(s_diag_a) + p_a * np.identity(3)\n    sigma_b = np.diag(s_diag_a) + p_b * np.identity(3)\n\n    p_val_a, J2_a, J3_a, cos3theta_a = compute_invariants(sigma_a)\n    p_val_b, J2_b, J3_b, cos3theta_b = compute_invariants(sigma_b)\n\n    # Check for equality within tolerance\n    j2_eq = abs(J2_a - J2_b) < TOLERANCE\n    j3_eq = abs(J3_a - J3_b) < TOLERANCE\n    cos3th_eq = abs(cos3theta_a - cos3theta_b) < TOLERANCE\n\n    F_a = yield_function(p_val_a, J2_a, cos3theta_a, beta_hydro_shift)\n    F_b = yield_function(p_val_b, J2_b, cos3theta_b, beta_hydro_shift)\n    f_diff = F_b - F_a\n    results.extend([j2_eq, j3_eq, cos3th_eq, f_diff])\n\n    # --- Task 4: Lode-angle path test ---\n    p_fixed = 30.0\n    J2_fixed = 1600.0\n    R = np.sqrt(2 * J2_fixed)\n    path_angles = np.array([-np.pi/6, -np.pi/9, -np.pi/12, -np.pi/18, 0,\n                            np.pi/18, np.pi/12, np.pi/9, np.pi/6])\n\n    f_values_b03 = []\n    f_values_b00 = []\n\n    for theta_val in path_angles:\n        s1 = (2.0 / np.sqrt(6.0)) * R * np.cos(theta_val)\n        s2 = (2.0 / np.sqrt(6.0)) * R * np.cos(theta_val - 2.0 * np.pi / 3.0)\n        s3 = (2.0 / np.sqrt(6.0)) * R * np.cos(theta_val + 2.0 * np.pi / 3.0)\n        \n        sigma_path = p_fixed * np.identity(3) + np.diag([s1, s2, s3])\n        p_path, J2_path, J3_path, cos3theta_path = compute_invariants(sigma_path)\n        \n        f_b03 = yield_function(p_path, J2_path, cos3theta_path, 0.3)\n        f_b00 = yield_function(p_path, J2_path, cos3theta_path, 0.0)\n        \n        f_values_b03.append(f_b03)\n        f_values_b00.append(f_b00)\n\n    amp_03 = max(f_values_b03) - min(f_values_b03)\n    amp_00 = max(f_values_b00) - min(f_values_b00)\n    is_pos_amp03 = amp_03 > TOLERANCE  # Check if strictly positive beyond tolerance\n    is_zero_amp00 = amp_00 < TOLERANCE\n    results.extend([amp_03, amp_00, is_pos_amp03, is_zero_amp00])\n    \n    # --- Task 5: Evaluate specific states ---\n    beta_specific = 0.3\n    \n    # Pure hydrostatic state\n    sigma_h = 50.0 * np.identity(3)\n    p_h, J2_h, _, cos3theta_h = compute_invariants(sigma_h)\n    F_h = yield_function(p_h, J2_h, cos3theta_h, beta_specific)\n    results.append(F_h)\n\n    # General non-hydrostatic state\n    sigma_g = np.array([[120.0, 15.0, -10.0],\n                        [15.0, 80.0, 5.0],\n                        [-10.0, 5.0, 100.0]])\n    p_g, J2_g, _, cos3theta_g = compute_invariants(sigma_g)\n    F_g = yield_function(p_g, J2_g, cos3theta_g, beta_specific)\n    results.append(F_g)\n    \n    # --- Final Output ---\n    # Convert all results to strings for a uniform list\n    # Booleans will be converted to 'True'/'False'\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3605161"}, {"introduction": "The principle of material frame indifference, or objectivity, is a cornerstone of continuum mechanics, ensuring that constitutive laws are independent of the observer. This practice moves into the realm of finite-strain hyperelasticity, where upholding objectivity requires careful distinction between material and spatial configurations. You will analyze a deliberately flawed implementation that improperly mixes tensors from different frames and design a numerical experiment to prove that it violates objectivity, providing a crucial lesson in debugging and validating nonlinear mechanics codes [@problem_id:3605128].", "problem": "Consider a compressible, isotropic, finite-strain hyperelastic material. Let the deformation gradient be denoted by $F$, the left Cauchy–Green tensor by $B = F F^{\\mathsf{T}}$, the right Cauchy–Green tensor by $C = F^{\\mathsf{T}} F$, and the Jacobian determinant by $J = \\det(F)$. Isotropy and frame indifference imply that the strain energy density can be written as a scalar function of the invariants of either $C$ or $B$. Define the first and second invariants of a second-order tensor $T$ as $I_1(T) = \\operatorname{tr}(T)$ and $I_2(T) = \\tfrac{1}{2} \\left( \\operatorname{tr}(T)^2 - \\operatorname{tr}(T^2) \\right)$.\n\nWe consider the strain energy\n$$\nW\\!\\left(I_1(C), I_2(C), J\\right) = a_1\\, I_1(C) + a_2\\, I_2(C) + \\frac{\\kappa}{2}\\, \\left(\\ln J\\right)^2,\n$$\nwith material parameters $a_1$, $a_2$, and $\\kappa$. Starting from the fundamental definitions and principles of objectivity and work-conjugacy, derive the expression for the Second Piola–Kirchhoff stress $S$, and the corresponding Cauchy stress $\\sigma$ obtained by a push-forward operation. Then, define and implement a deliberately flawed \"mixed-invariants\" stress computation in which the code forms a spatial (Kirchhoff) stress using the tensor $B$ multiplied by the derivative $\\partial W / \\partial C$, namely $\\tau_{\\text{bug}} = 2\\, B \\left( \\partial W / \\partial C \\right)$, and sets $\\sigma_{\\text{bug}} = \\tau_{\\text{bug}} / J$. Explain why this construction is not work-conjugate and generally violates frame indifference.\n\nDesign a numerical experiment to detect the bias introduced by this mixed-invariants mistake by testing frame indifference under superposed rigid body rotations. Specifically, for each test case:\n- Construct $F = R(\\theta)\\, U\\, S(\\gamma)$, where $R(\\theta)$ is a rotation about the $z$-axis by angle $\\theta$, $U = \\operatorname{diag}(s_1, s_2, s_3)$ is a diagonal stretch, and $S(\\gamma)$ is a simple shear in the $x$–$y$ plane with shear parameter $\\gamma$ given by $S(\\gamma) = \\begin{bmatrix} 1 & \\gamma & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{bmatrix}$. Angles must be expressed in radians.\n- Apply a superposed rigid body rotation $Q(\\phi)$ about the $y$-axis by angle $\\phi$ to form $F' = Q(\\phi)\\, F$.\n- Compute the correct Cauchy stress $\\sigma(F)$ and $\\sigma(F')$ and verify objectivity by comparing $\\sigma(F')$ to $Q(\\phi)\\, \\sigma(F)\\, Q(\\phi)^{\\mathsf{T}}$ using the relative residual\n$$\nr_{\\text{ok}} = \\frac{\\left\\| \\sigma(F') - Q(\\phi)\\, \\sigma(F)\\, Q(\\phi)^{\\mathsf{T}} \\right\\|_F}{\\left\\| Q(\\phi)\\, \\sigma(F)\\, Q(\\phi)^{\\mathsf{T}} \\right\\|_F + \\varepsilon},\n$$\nwhere $\\|\\cdot\\|_F$ denotes the Frobenius norm and $\\varepsilon$ is a small positive number to avoid division by zero.\n- Compute the buggy Cauchy stress $\\sigma_{\\text{bug}}(F)$ and $\\sigma_{\\text{bug}}(F')$ using the mixed-invariants construction and evaluate\n$$\nr_{\\text{bug}} = \\frac{\\left\\| \\sigma_{\\text{bug}}(F') - Q(\\phi)\\, \\sigma_{\\text{bug}}(F)\\, Q(\\phi)^{\\mathsf{T}} \\right\\|_F}{\\left\\| Q(\\phi)\\, \\sigma_{\\text{bug}}(F)\\, Q(\\phi)^{\\mathsf{T}} \\right\\|_F + \\varepsilon}.\n$$\nDeclare that a bias has been detected if $r_{\\text{ok}} \\le t_{\\text{ok}}$ and $r_{\\text{bug}} > t_{\\text{bug}}$, with thresholds $t_{\\text{ok}} = 10^{-12}$ and $t_{\\text{bug}} = 10^{-6}$, and use $\\varepsilon = 10^{-16}$.\n\nYour program must implement the above, using the following material parameters: $a_1 = 4.0$, $a_2 = 1.2$, $\\kappa = 50.0$. Use the three test cases below, specified by $(\\theta, \\phi, s_1, s_2, s_3, \\gamma)$, with all angles in radians:\n1. $(\\theta = 0.5, \\phi = 0.7, s_1 = 1.3, s_2 = 0.9, s_3 = 1.1, \\gamma = 0.4)$,\n2. $(\\theta = 0.3, \\phi = 0.6, s_1 = 1.1, s_2 = 1.1, s_3 = 1.1, \\gamma = 0.0)$,\n3. $(\\theta = 1.1, \\phi = 0.9, s_1 = 1.0, s_2 = 1.0, s_3 = 1.0, \\gamma = 1.5)$.\n\nFor each test case, return a boolean indicating whether bias was detected. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[ \\text{result}_1, \\text{result}_2, \\text{result}_3 ]$), where each $\\text{result}_i$ is a boolean literal $\\text{True}$ or $\\text{False}$.", "solution": "The problem statement is assessed to be valid as it is scientifically grounded in continuum mechanics, well-posed, objective, and internally consistent. We shall proceed with the derivation and numerical implementation.\n\nThe analysis is structured into three parts: first, the derivation of the correct, objective stress-strain relationship from the given strain energy function; second, an analysis of the proposed \"mixed-invariants\" formulation to demonstrate its fundamental flaws; and third, the design and implementation of a numerical experiment to detect the consequences of these flaws.\n\n**1. Derivation of the Correct Constitutive Law**\n\nThe cornerstone of hyperelasticity is that the stress tensor is derived from a scalar potential, the strain energy density function $W$. For a material formulation, the second Piola-Kirchhoff stress tensor $S$ is energetically conjugate to the rate of change of the right Cauchy-Green tensor $C$. This relationship is expressed as:\n$$\nS = 2 \\frac{\\partial W}{\\partial C}\n$$\nThe given strain energy function is $W\\!\\left(I_1(C), I_2(C), J\\right) = a_1\\, I_1(C) + a_2\\, I_2(C) + \\frac{\\kappa}{2}\\, \\left(\\ln J\\right)^2$. To find $S$, we apply the chain rule:\n$$\nS = 2 \\left( \\frac{\\partial W}{\\partial I_1(C)} \\frac{\\partial I_1(C)}{\\partial C} + \\frac{\\partial W}{\\partial I_2(C)} \\frac{\\partial I_2(C)}{\\partial C} + \\frac{\\partial W}{\\partial J} \\frac{\\partial J}{\\partial C} \\right)\n$$\nThe required partial derivatives of $W$ with respect to the invariants are:\n$$\n\\frac{\\partial W}{\\partial I_1(C)} = a_1\n$$\n$$\n\\frac{\\partial W}{\\partial I_2(C)} = a_2\n$$\n$$\n\\frac{\\partial W}{\\partial J} = \\frac{\\kappa}{J} \\ln J\n$$\nThe derivatives of the invariants with respect to the tensor $C$ are standard results in tensor calculus:\n$$\n\\frac{\\partial I_1(C)}{\\partial C} = \\frac{\\partial \\operatorname{tr}(C)}{\\partial C} = I\n$$\n$$\n\\frac{\\partial I_2(C)}{\\partial C} = \\frac{\\partial}{\\partial C} \\left( \\tfrac{1}{2} \\left( \\operatorname{tr}(C)^2 - \\operatorname{tr}(C^2) \\right) \\right) = I_1(C) I - C\n$$\n$$\n\\frac{\\partial J}{\\partial C} = \\frac{\\partial \\sqrt{\\det(C)}}{\\partial C} = \\frac{1}{2\\sqrt{\\det(C)}} \\frac{\\partial \\det(C)}{\\partial C} = \\frac{1}{2J} J C^{-1} = \\frac{1}{2} J C^{-1}\n$$\nwhere $I$ is the second-order identity tensor and the last result utilizes Jacobi's formula.\n\nSubstituting these into the expression for $S$ yields:\n$$\nS = 2 \\left( a_1 I + a_2 \\left( I_1(C) I - C \\right) + \\left( \\frac{\\kappa}{J} \\ln J \\right) \\left( \\frac{1}{2} J C^{-1} \\right) \\right)\n$$\n$$\nS = 2 a_1 I + 2 a_2 \\left( I_1(C) I - C \\right) + \\kappa (\\ln J) C^{-1}\n$$\nThis is the expression for the second Piola-Kirchhoff stress in the reference configuration. The physically relevant stress in the current (deformed) configuration is the Cauchy stress, $\\sigma$. It is obtained by a push-forward operation on $S$:\n$$\n\\sigma = \\frac{1}{J} F S F^{\\mathsf{T}}\n$$\nSubstituting the expression for $S$:\n$$\n\\sigma = \\frac{1}{J} F \\left( 2 a_1 I + 2 a_2 (I_1(C) I - C) + \\kappa (\\ln J) C^{-1} \\right) F^{\\mathsf{T}}\n$$\nWe simplify the terms using the kinematic identities $B = F F^{\\mathsf{T}}$, $I_1(C) = I_1(B)$, $F C F^{\\mathsf{T}} = F (F^{\\mathsf{T}} F) F^{\\mathsf{T}} = (F F^{\\mathsf{T}}) (F F^{\\mathsf{T}}) = B^2$, and $F C^{-1} F^{\\mathsf{T}} = F (F^{\\mathsf{T}} F)^{-1} F^{\\mathsf{T}} = F F^{-1} (F^{\\mathsf{T}})^{-1} F^{\\mathsf{T}} = I$.\n$$\n\\sigma = \\frac{1}{J} \\left( 2 a_1 ( F I F^{\\mathsf{T}} ) + 2 a_2 (I_1(C) F F^{\\mathsf{T}} - F C F^{\\mathsf{T}}) + \\kappa (\\ln J) F C^{-1} F^{\\mathsf{T}} \\right)\n$$\n$$\n\\sigma = \\frac{1}{J} \\left( 2 a_1 B + 2 a_2 (I_1(B) B - B^2) + \\kappa (\\ln J) I \\right)\n$$\nThis final expression for the Cauchy stress $\\sigma$ is formulated entirely in terms of spatial quantities ($B$, $J$, $I$) and is guaranteed to be objective by its derivation.\n\n**2. Analysis of the Flawed \"Mixed-Invariants\" Formulation**\n\nThe problem defines a flawed \"buggy\" stress calculation as:\n$$\n\\tau_{\\text{bug}} = 2 B \\frac{\\partial W}{\\partial C} \\quad \\text{and} \\quad \\sigma_{\\text{bug}} = \\frac{1}{J} \\tau_{\\text{bug}}\n$$\nSince $S = 2 \\partial W / \\partial C$, the buggy formulation is equivalent to $\\tau_{\\text{bug}} = B S$. This is incorrect; the correct Kirchhoff stress is $\\tau = F S F^{\\mathsf{T}}$. The expression $B S = (F F^{\\mathsf{T}})S$ is not equivalent to $F S F^{\\mathsf{T}}$ unless $S$ and $F^{\\mathsf{T}}$ commute, which is not generally true. This formulation is flawed for two fundamental reasons:\n\nFirst, it is **not work-conjugate**. The derivation of stress from a potential function is predicated on a specific pairing of stress and strain measures that ensures conservation of energy. The buggy formulation circumvents this rigorous derivation, instead performing an ad-hoc multiplication of a spatial tensor, $B$, and a material tensor, $S$. This operation has no physical basis and breaks the energetic consistency required by hyperelasticity.\n\nSecond, it **violates frame indifference (objectivity)**. The principle of objectivity requires that constitutive laws remain invariant under a change of observer, which is modeled by a superposed rigid body rotation. Let the current configuration undergo a rotation described by the orthogonal tensor $Q$ ($Q Q^{\\mathsf{T}} = I$, $\\det(Q) = 1$). The deformation gradient transforms to $F' = Q F$.\nThe corresponding transformations of the kinematic tensors are:\n- Right Cauchy-Green: $C' = (F')^{\\mathsf{T}} F' = (Q F)^{\\mathsf{T}} (Q F) = F^{\\mathsf{T}} Q^{\\mathsf{T}} Q F = F^{\\mathsf{T}} I F = C$. $C$ is objective (invariant).\n- Jacobian: $J' = \\det(F') = \\det(Q F) = \\det(Q) \\det(F) = 1 \\cdot J = J$. $J$ is objective.\n- Left Cauchy-Green: $B' = F' (F')^{\\mathsf{T}} = (Q F) (Q F)^{\\mathsf{T}} = Q F F^{\\mathsf{T}} Q^{\\mathsf{T}} = Q B Q^{\\mathsf{T}}$. $B$ transforms as a proper spatial tensor.\n\nSince $C$ and $J$ are invariant, the strain energy $W$ and its derivative with respect to $C$, $\\partial W / \\partial C$, are also invariant.\nLet's compute the buggy stress in the new frame:\n$$\n\\sigma_{\\text{bug}}(F') = \\frac{1}{J'} \\left( 2 B' \\frac{\\partial W(C', J')}{\\partial C'} \\right) = \\frac{2}{J} (Q B Q^{\\mathsf{T}}) \\frac{\\partial W(C, J)}{\\partial C}\n$$\nFor objectivity to hold, $\\sigma_{\\text{bug}}(F')$ must be equal to the rotated original buggy stress, $Q \\sigma_{\\text{bug}}(F) Q^{\\mathsf{T}}$:\n$$\nQ \\sigma_{\\text{bug}}(F) Q^{\\mathsf{T}} = Q \\left( \\frac{2}{J} B \\frac{\\partial W(C, J)}{\\partial C} \\right) Q^{\\mathsf{T}} = \\frac{2}{J} Q B \\frac{\\partial W(C, J)}{\\partial C} Q^{\\mathsf{T}}\n$$\nObjectivity requires the equality:\n$$\n\\frac{2}{J} (Q B Q^{\\mathsf{T}}) \\frac{\\partial W}{\\partial C} = \\frac{2}{J} Q B \\frac{\\partial W}{\\partial C} Q^{\\mathsf{T}}\n$$\nThis simplifies to $(Q B Q^{\\mathsf{T}}) A = Q B A Q^{\\mathsf{T}}$, where $A = \\partial W / \\partial C$. This equality does not hold for arbitrary tensors $B$, $A$, and rotation $Q$, because matrix multiplication is not commutative. The expression improperly mixes a spatial tensor $B$ with a material tensor $A$, leading to a non-objective result.\n\n**3. Numerical Experiment**\n\nThe numerical experiment will concretely demonstrate the violation of objectivity. We will compute the correct Cauchy stress, $\\sigma(F)$, and the buggy stress, $\\sigma_{\\text{bug}}(F)$, for a given deformation $F$. We then apply a superposed rotation $Q$ to get $F' = Q F$ and compute $\\sigma(F')$ and $\\sigma_{\\text{bug}}(F')$.\nObjectivity of the correct stress is verified by checking if the residual $r_{\\text{ok}} = \\frac{\\left\\| \\sigma(F') - Q \\sigma(F) Q^{\\mathsf{T}} \\right\\|_F}{\\left\\| Q \\sigma(F) Q^{\\mathsf{T}} \\right\\|_F + \\varepsilon}$ is close to machine precision ($r_{\\text{ok}} \\le 10^{-12}$).\nThe non-objectivity of the buggy stress is detected if its corresponding residual $r_{\\text{bug}} = \\frac{\\left\\| \\sigma_{\\text{bug}}(F') - Q \\sigma_{\\text{bug}}(F) Q^{\\mathsf{T}} \\right\\|_F}{\\left\\| Q \\sigma_{\\text{bug}}(F) Q^{\\mathsf{T}} \\right\\|_F + \\varepsilon}$ is significantly larger than zero ($r_{\\text{bug}} > 10^{-6}$).\nA bias is detected if both conditions are met, confirming the theoretical analysis.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_stresses(F, a1, a2, kappa):\n    \"\"\"\n    Computes the correct Cauchy stress and the flawed \"mixed-invariants\"\n    Cauchy stress for a given deformation gradient F.\n    \"\"\"\n    I = np.eye(3)\n    J = np.linalg.det(F)\n    \n    # It is numerically more stable to compute B first, then C if needed.\n    B = F @ F.T\n    \n    # --- Correct Cauchy Stress Calculation (spatial form) ---\n    I1_B = np.trace(B)\n    B_sq = B @ B\n    \n    # sigma = (1/J) * (2*a1*B + 2*a2*(I1_B*B - B_sq) + kappa*np.log(J)*I)\n    # The problem description implicitly suggests a volumetric/deviatoric split\n    # where the volumetric part (involving J) contributes only to the pressure.\n    # The term a1*I1(C) + a2*I2(C) is often used for the isochoric part.\n    # In that context, one would use modified invariants. However, following the\n    # problem statement literally:\n    # W = a1*I1(C) + a2*I2(C) + (kappa/2)*(lnJ)^2\n    # The derived spatial form is used here.\n    \n    term_a1 = 2.0 * a1 * B\n    term_a2 = 2.0 * a2 * (I1_B * B - B_sq)\n    term_kappa = kappa * np.log(J) * I\n    \n    sigma_correct = (1.0 / J) * (term_a1 + term_a2 + term_kappa)\n    \n    # --- Buggy Cauchy Stress Calculation (mixed-frame form) ---\n    C = F.T @ F\n    try:\n        C_inv = np.linalg.inv(C)\n    except np.linalg.LinAlgError:\n        # Handle singular C if it occurs, though unlikely with given test cases.\n        return sigma_correct, np.full((3,3), np.nan)\n\n    I1_C = np.trace(C)\n    \n    # S = 2 * dW/dC\n    S = 2.0 * a1 * I + 2.0 * a2 * (I1_C * I - C) + kappa * np.log(J) * C_inv\n    \n    # tau_bug = B @ S\n    tau_bug = B @ S\n    sigma_buggy = (1.0 / J) * tau_bug\n    \n    return sigma_correct, sigma_buggy\n\ndef solve():\n    \"\"\"\n    Main function to run the numerical experiment for detecting bias.\n    \"\"\"\n    # Material parameters\n    a1 = 4.0\n    a2 = 1.2\n    kappa = 50.0\n\n    # Numerical thresholds and constants\n    t_ok = 1e-12\n    t_bug = 1e-6\n    epsilon = 1e-16\n\n    # Test cases: (theta, phi, s1, s2, s3, gamma)\n    test_cases = [\n        (0.5, 0.7, 1.3, 0.9, 1.1, 0.4),\n        (0.3, 0.6, 1.1, 1.1, 1.1, 0.0),\n        (1.1, 0.9, 1.0, 1.0, 1.0, 1.5),\n    ]\n\n    results = []\n\n    for case in test_cases:\n        theta, phi, s1, s2, s3, gamma = case\n\n        # --- Construct matrices ---\n        # Rotation about z-axis\n        cos_t, sin_t = np.cos(theta), np.sin(theta)\n        R_z = np.array([[cos_t, -sin_t, 0],\n                        [sin_t,  cos_t, 0],\n                        [0,      0,     1]])\n\n        # Diagonal stretch\n        U = np.diag([s1, s2, s3])\n\n        # Simple shear in x-y plane\n        S_gamma = np.array([[1, gamma, 0],\n                            [0, 1,     0],\n                            [0, 0,     1]])\n\n        # Superposed rotation about y-axis\n        cos_p, sin_p = np.cos(phi), np.sin(phi)\n        Q_y = np.array([[cos_p,  0, sin_p],\n                        [0,      1, 0],\n                        [-sin_p, 0, cos_p]])\n        Q = Q_y\n\n        # --- Compute deformation gradients ---\n        F = R_z @ U @ S_gamma\n        F_prime = Q @ F\n\n        # --- Compute stresses ---\n        sigma_F_ok, sigma_F_bug = compute_stresses(F, a1, a2, kappa)\n        sigma_F_prime_ok, sigma_F_prime_bug = compute_stresses(F_prime, a1, a2, kappa)\n        \n        # --- Evaluate residuals ---\n        \n        # Correct stress objectivity check\n        sigma_F_ok_rotated = Q @ sigma_F_ok @ Q.T\n        num_ok = np.linalg.norm(sigma_F_prime_ok - sigma_F_ok_rotated, 'fro')\n        den_ok = np.linalg.norm(sigma_F_ok_rotated, 'fro') + epsilon\n        r_ok = num_ok / den_ok\n\n        # Buggy stress objectivity check\n        sigma_F_bug_rotated = Q @ sigma_F_bug @ Q.T\n        num_bug = np.linalg.norm(sigma_F_prime_bug - sigma_F_bug_rotated, 'fro')\n        den_bug = np.linalg.norm(sigma_F_bug_rotated, 'fro') + epsilon\n        r_bug = num_bug / den_bug\n\n        # --- Check for bias detection ---\n        bias_detected = (r_ok <= t_ok) and (r_bug > t_bug)\n        results.append(bias_detected)\n\n    # Convert numpy booleans to Python booleans for standard string representation\n    py_results = [bool(r) for r in results]\n    print(f\"[{','.join(map(str, py_results))}]\")\n\nsolve()\n\n```", "id": "3605128"}, {"introduction": "After building and debugging models, the final step is comprehensive verification. This capstone exercise shows how to use a powerful Monte Carlo simulation to rigorously verify that a complete numerical implementation—from the strain energy function $W$ to the assembled nodal forces in a finite element—correctly upholds the principle of rotational invariance. By randomly reorienting the principal axes of deformation and observing that the resulting physical response remains unchanged, you will confirm the integrity of an isotropic formulation in a practical computational setting [@problem_id:3605114].", "problem": "Develop a complete, runnable program that uses a Monte Carlo scheme to verify the rotational invariance of a discrete internal-force measure arising from the numerical integration of an isotropic hyperelastic stored energy function $W(I_1,I_2,I_3)$ for a homogeneous deformation. The verification must be performed by randomly perturbing the eigenvectors of the right Cauchy–Green deformation tensor $C$ while holding its eigenvalues fixed, and then measuring the resulting changes in a scalar internal-force measure assembled from a one-point integrated eight-node hexahedral element.\n\nYour implementation must be grounded in the following fundamental base:\n- The deformation gradient $F$ and the right Cauchy–Green deformation tensor $C$ satisfy $C = F^\\top F$.\n- For an isotropic hyperelastic material with stored energy $W(I_1,I_2,I_3)$, the second Piola–Kirchhoff stress $S$ is given by $S = 2\\,\\dfrac{\\partial W}{\\partial C}$, with the chain rule and the tensorial derivatives of the principal invariants $I_1$, $I_2$, and $I_3$ used to compute $\\dfrac{\\partial W}{\\partial C}$.\n- The first Piola–Kirchhoff (FPK) stress is $P = F\\,S$.\n- The internal nodal force vector for node $a$ in a finite deformation setting is $f_a = \\int_{\\Omega_0} \\mathrm{Grad}\\,N_a^\\top \\, P \\,\\mathrm{d}V_0$, where $\\mathrm{Grad}\\,N_a$ is the gradient of the shape function $N_a$ with respect to reference coordinates, and $\\Omega_0$ is the reference configuration.\n- A one-point Gauss rule on the trilinear eight-node hexahedron approximates the integral by evaluating all fields at the element center and multiplying by the appropriate weight; for a unit cube reference element this reduces to $f_a \\approx \\mathrm{Grad}\\,N_a^\\top P$ evaluated at the element center.\n\nYour program must implement the following, without using any pre-derived shortcut formulas beyond the definitions above:\n- Use the principal stretches $\\lambda_1$, $\\lambda_2$, and $\\lambda_3$ to construct the right stretch $U = Q \\,\\mathrm{diag}(\\lambda_1,\\lambda_2,\\lambda_3)\\, Q^\\top$, where $Q \\in \\mathrm{SO}(3)$ is a rotation in the Special Orthogonal Group (SO). Set $F = U$ to enforce a pure stretch with no superposed rotation, and therefore $C = U^2$ with the same eigenvectors and squared eigenvalues.\n- Use the stored energy\n$$\nW(I_1,I_2,I_3) = c_1\\,(I_1 - 3) + c_2\\,(I_2 - 3) + c_3\\,(I_3 - 1 - \\ln I_3),\n$$\nwith constants $c_1 = -1.0$, $c_2 = 0.5$, and $c_3 = 2.0$. You must compute $S = 2\\,\\dfrac{\\partial W}{\\partial C}$ by applying the chain rule to $W(I_1,I_2,I_3)$, using the tensorial derivatives of $I_1$, $I_2$, and $I_3$ with respect to $C$, and then compute $P = F\\,S$.\n- For the unit-cube eight-node hexahedral element with trilinear shape functions, evaluate $\\mathrm{Grad}\\,N_a$ at the element center and compute the internal forces $f_a \\approx \\mathrm{Grad}\\,N_a^\\top P$ for $a = 1,\\dots,8$. Assemble the scalar internal-force measure\n$$\n\\Phi = \\sum_{a=1}^{8} \\lVert f_a \\rVert_2^2.\n$$\n- For a given set of principal stretches $(\\lambda_1,\\lambda_2,\\lambda_3)$, hold them fixed while drawing $N$ random rotations $Q \\in \\mathrm{SO}(3)$, constructing $F=Q\\,\\mathrm{diag}(\\lambda_1,\\lambda_2,\\lambda_3)Q^\\top$, and computing $\\Phi$ for each $Q$. Use as baseline the unrotated eigenbasis $Q = I$.\n- Report, for each test case, the maximum absolute relative deviation of $\\Phi$ over the Monte Carlo trials with respect to the baseline, i.e.,\n$$\n\\Delta_\\mathrm{max} = \\max_{k=1,\\dots,N} \\left| \\frac{\\Phi^{(k)} - \\Phi^{(0)}}{\\Phi^{(0)}} \\right|,\n$$\nwhere $\\Phi^{(0)}$ is the value with $Q = I$ and $\\Phi^{(k)}$ is the value for the $k$-th random rotation.\n\nScientific realism and numerical soundness requirements:\n- All stretches $\\lambda_i$ must be strictly positive to ensure that $C$ is symmetric positive definite and invertible.\n- The test uses one-point integration at the element center on a unit cube in the reference configuration. Gradients of the trilinear shape functions at the center must be computed consistently with the mapping from natural to reference coordinates.\n- Random rotations $Q$ must be sampled uniformly over $\\mathrm{SO}(3)$ by, for example, applying the $\\mathrm{QR}$ decomposition to a random Gaussian matrix and correcting the determinant to be $+1$.\n\nTest suite and required output:\n- Use the following test suite, each defined by the tuple $(\\lambda_1,\\lambda_2,\\lambda_3,N)$, where $N$ is the number of random rotations:\n    - Case $1$: $(1.1,\\,0.9,\\,1.2,\\,200)$.\n    - Case $2$: $(1.05,\\,1.05,\\,0.95,\\,200)$.\n    - Case $3$: $(0.8,\\,0.9,\\,1.5,\\,200)$.\n    - Case $4$: $(1.02,\\,1.00,\\,1.00,\\,200)$.\n- For each case, compute $\\Delta_\\mathrm{max}$ as a floating-point number.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[r_1,r_2,r_3,r_4]$), where $r_i$ is the $\\Delta_\\mathrm{max}$ for case $i$.\n\nAngle units are not applicable. No physical units are required because the problem is posed in nondimensional form. All numeric tolerances, if any, must be implicit in floating-point arithmetic, and no user input is allowed. The output type for each test is a float. The randomness must be seeded for reproducibility with a deterministic seed of your choice.", "solution": "The problem statement is assessed to be valid. It is a well-posed, scientifically sound, and non-trivial numerical verification task rooted in computational solid mechanics. It requires the implementation of fundamental kinematic, constitutive, and finite element relations to test the principle of material frame-indifference for an isotropic hyperelastic model. The final result is expected to be a set of very small numbers, confirming the theoretical invariance up to the limits of floating-point precision.\n\nThe solution proceeds by first laying out the theoretical framework and then designing a program to implement the specified Monte Carlo verification scheme.\n\n### Theoretical Framework\n\n1.  **Kinematics of Deformation**:\n    The deformation is described by the deformation gradient tensor $F$. The problem specifies a homogeneous pure stretch, where the rotational part of the polar decomposition is the identity. The deformation gradient is thus symmetric and equal to the right stretch tensor $U$. It is constructed from a set of principal stretches $(\\lambda_1, \\lambda_2, \\lambda_3)$ and a rotation matrix $Q \\in \\mathrm{SO}(3)$ which defines the orientation of the principal stretch axes:\n    $$F = U = Q \\, \\mathrm{diag}(\\lambda_1, \\lambda_2, \\lambda_3) \\, Q^\\top$$\n    The right Cauchy-Green deformation tensor $C$ is given by $C = F^\\top F$. Since $F$ is symmetric ($F=F^\\top$), this simplifies to:\n    $$C = F^2 = (Q \\, \\mathrm{diag}(\\lambda_1, \\lambda_2, \\lambda_3) \\, Q^\\top)^2 = Q \\, \\mathrm{diag}(\\lambda_1^2, \\lambda_2^2, \\lambda_3^2) \\, Q^\\top$$\n    The eigenvalues of $C$ are $\\lambda_i^2$, and its eigenvectors are the columns of $Q$.\n\n2.  **Isotropic Hyperelasticity and Stress Calculation**:\n    The material response is governed by an isotropic stored energy function $W$, which depends on $C$ only through its principal invariants $I_1, I_2, I_3$:\n    $$I_1 = \\mathrm{tr}(C), \\quad I_2 = \\frac{1}{2}[(\\mathrm{tr}(C))^2 - \\mathrm{tr}(C^2)], \\quad I_3 = \\det(C)$$\n    The specific form of $W$ is given as:\n    $$W(I_1,I_2,I_3) = c_1(I_1 - 3) + c_2(I_2 - 3) + c_3(I_3 - 1 - \\ln I_3)$$\n    with constants $c_1 = -1.0$, $c_2 = 0.5$, and $c_3 = 2.0$.\n\n    The second Piola-Kirchhoff (PK2) stress tensor $S$ is derived from $W$ via $S = 2 \\frac{\\partial W}{\\partial C}$. Applying the chain rule:\n    $$S = 2 \\left( \\frac{\\partial W}{\\partial I_1}\\frac{\\partial I_1}{\\partial C} + \\frac{\\partial W}{\\partial I_2}\\frac{\\partial I_2}{\\partial C} + \\frac{\\partial W}{\\partial I_3}\\frac{\\partial I_3}{\\partial C} \\right)$$\n    The required derivatives are:\n    $$\\frac{\\partial W}{\\partial I_1} = c_1, \\quad \\frac{\\partial W}{\\partial I_2} = c_2, \\quad \\frac{\\partial W}{\\partial I_3} = c_3\\left(1 - \\frac{1}{I_3}\\right)$$\n    $$\\frac{\\partial I_1}{\\partial C} = I, \\quad \\frac{\\partial I_2}{\\partial C} = I_1 I - C, \\quad \\frac{\\partial I_3}{\\partial C} = I_3 C^{-1}$$\n    where $I$ is the second-order identity tensor. Substituting these gives the expression for $S$:\n    $$S = 2 \\left( c_1 I + c_2(I_1 I - C) + c_3(I_3 - 1) C^{-1} \\right)$$\n    The first Piola-Kirchhoff (FPK) stress tensor $P$ is then computed as $P = FS$.\n\n3.  **Finite Element Formulation and Internal Force Measure**:\n    The analysis uses an 8-node hexahedral element defined on a reference unit cube, $\\Omega_0 = [0,1]^3$. The internal force vector at node $a$ is approximated using a one-point integration rule at the element center $(\\xi, \\eta, \\zeta) = (0,0,0)$:\n    $$f_a \\approx V_0 \\cdot \\left(\\mathrm{Grad}\\,N_a^\\top P\\right)|_{\\text{center}}$$\n    For a unit cube reference element, the volume $V_0 = 1$, so the expression simplifies to $f_a \\approx (\\mathrm{Grad}\\,N_a^\\top P)|_{\\text{center}}$.\n    \n    The gradient of the shape function, $\\mathrm{Grad}\\,N_a$, is taken with respect to the reference coordinates $(X,Y,Z)$. For a mapping from natural coordinates $(\\xi, \\eta, \\zeta) \\in [-1,1]^3$ to reference coordinates $(X,Y,Z) \\in [0,1]^3$, the Jacobian matrix $J = \\frac{\\partial X_i}{\\partial\\xi_j}$ is a constant diagonal matrix $J = \\mathrm{diag}(0.5, 0.5, 0.5)$. The gradient is computed via the chain rule: $\\mathrm{Grad}_X N_a = J^{-1} \\mathrm{Grad}_\\xi N_a$. At the center $(\\xi, \\eta, \\zeta) = (0,0,0)$, the gradient in natural coordinates is $\\mathrm{Grad}_\\xi N_a = \\frac{1}{8}[\\xi_a, \\eta_a, \\zeta_a]^\\top$, where $(\\xi_a, \\eta_a, \\zeta_a)$ are the nodal coordinates (e.g., $\\pm 1$). Thus,\n    $$\\mathrm{Grad}_X N_a = \\mathrm{diag}(2,2,2) \\cdot \\frac{1}{8}[\\xi_a, \\eta_a, \\zeta_a]^\\top = \\frac{1}{4}[\\xi_a, \\eta_a, \\zeta_a]^\\top$$\n    \n    The scalar internal-force measure $\\Phi$ to be evaluated is the sum of the squared Euclidean norms of the nodal force vectors:\n    $$\\Phi = \\sum_{a=1}^{8} \\lVert f_a \\rVert_2^2$$\n\n### Monte Carlo Verification Procedure\n\nThe core of the problem is to verify that $\\Phi$ is invariant under a change of the principal stretch orientation, which is controlled by the rotation matrix $Q$. This is a direct test of material frame-indifference as implemented numerically.\n\n1.  **Baseline Calculation**: For a given set of stretches $(\\lambda_1, \\lambda_2, \\lambda_3)$, a baseline value $\\Phi^{(0)}$ is computed using the identity matrix for the rotation, $Q = I$.\n\n2.  **Random Trials**: A set of $N$ random rotation matrices $Q^{(k)} \\in \\mathrm{SO}(3)$ is generated. This is achieved by performing a QR decomposition on a $3 \\times 3$ matrix of random Gaussian numbers and ensuring the resulting orthogonal matrix $Q$ has a determinant of $+1$.\n\n3.  **Deviation Measurement**: For each random rotation $Q^{(k)}$, the entire sequence of calculations ($F, C, S, P, f_a$) is repeated to find a new measure $\\Phi^{(k)}$. The absolute relative deviation with respect to the baseline is calculated.\n\n4.  **Result**: The maximum deviation observed across all $N$ trials is reported:\n    $$\\Delta_\\mathrm{max} = \\max_{k=1,\\dots,N} \\left| \\frac{\\Phi^{(k)} - \\Phi^{(0)}}{\\Phi^{(0)}} \\right|$$\n    Theoretically, this value should be zero. In practice, due to floating-point arithmetic, it will be a small number close to machine precision, which validates the correctness of the implementation of the isotropic constitutive model.\n\nThe implementation will follow these steps precisely for each test case provided. A fixed random seed ensures the reproducibility of the Monte Carlo simulation.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import qr\n\ndef solve():\n    \"\"\"\n    Main solver function to orchestrate the verification process for all test cases.\n    \"\"\"\n    # Use a fixed random seed for reproducibility of the Monte Carlo simulation.\n    np.random.seed(42)\n\n    # Define the 8 nodal coordinates in the natural system (-1, 1).\n    # Standard ordering for an 8-node hexahedron.\n    # Bottom face (z=-1), counter-clockwise starting from (-1,-1).\n    # Top face (z=+1), counter-clockwise starting from (-1,-1).\n    natural_coords = np.array([\n        [-1, -1, -1],  # Node 1\n        [+1, -1, -1],  # Node 2\n        [+1, +1, -1],  # Node 3\n        [-1, +1, -1],  # Node 4\n        [-1, -1, +1],  # Node 5\n        [+1, -1, +1],  # Node 6\n        [+1, +1, +1],  # Node 7\n        [-1, +1, +1]   # Node 8\n    ])\n\n    # The gradient of the shape functions w.r.t reference coordinates (X,Y,Z)\n    # for a unit cube element, evaluated at the element center, is given by\n    # Grad_X N_a = J^{-1} Grad_xi N_a.\n    # For a unit cube [0,1]^3, J = diag(0.5, 0.5, 0.5), so J^-1 = diag(2,2,2).\n    # Grad_xi N_a at center is (1/8) * [xi_a, eta_a, zeta_a].\n    # So, Grad_X N_a = 2 * (1/8) * [xi_a, eta_a, zeta_a] = 0.25 * [xi_a, eta_a, zeta_a].\n    # We store these as column vectors.\n    grad_N_vectors = [0.25 * coord.reshape(3, 1) for coord in natural_coords]\n\n    # Material constants for the stored energy function\n    c1, c2, c3 = -1.0, 0.5, 2.0\n\n    # Define the test suite from the problem statement.\n    test_cases = [\n        ((1.1, 0.9, 1.2), 200),\n        ((1.05, 1.05, 0.95), 200),\n        ((0.8, 0.9, 1.5), 200),\n        ((1.02, 1.00, 1.00), 200),\n    ]\n\n    results = []\n    for lambdas, N_trials in test_cases:\n        max_dev = run_verification_test(lambdas, N_trials, c1, c2, c3, grad_N_vectors)\n        results.append(max_dev)\n\n    # Print the final results in the specified format.\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\ndef generate_random_rotation():\n    \"\"\"\n    Generates a random 3x3 rotation matrix Q from SO(3) using the QR method.\n    \"\"\"\n    # Create a random 3x3 matrix from a standard normal distribution.\n    A = np.random.randn(3, 3)\n    # Perform QR decomposition.\n    Q, R = qr(A)\n    # The QR decomposition gives a Q in O(3). We need to ensure it's in SO(3),\n    # i.e., det(Q) = +1. We can achieve this by flipping the sign of one\n    # column if the determinant is -1.\n    if np.linalg.det(Q) < 0:\n        Q[:, 0] *= -1\n    return Q\n\ndef calculate_phi(lambdas, Q, c1, c2, c3, grad_N_vectors):\n    \"\"\"\n    Calculates the scalar internal-force measure Phi for a given set of stretches\n    and a rotation matrix.\n    \"\"\"\n    # 1. Construct deformation gradient F and Right Cauchy-Green tensor C\n    L = np.diag(lambdas)\n    # F is a pure stretch: F = U = Q * diag(lambdas) * Q^T\n    F = Q @ L @ Q.T\n    # C = F^T * F. Since F is symmetric (F=U), C = F * F = F^2\n    C = F @ F\n\n    # 2. Compute the invariants of C\n    I1 = np.trace(C)\n    I2 = 0.5 * (I1**2 - np.trace(C @ C))\n    I3 = np.linalg.det(C)\n    \n    # 3. Compute the Second Piola-Kirchhoff stress S\n    # S = 2 * (dW/dI1 * dI1/dC + dW/dI2 * dI2/dC + dW/dI3 * dI3/dC)\n    \n    # Derivatives of W w.r.t. invariants\n    dW_dI1 = c1\n    dW_dI2 = c2\n    dW_dI3 = c3 * (1.0 - 1.0 / I3)\n\n    # Derivatives of invariants w.r.t. C\n    I = np.identity(3)\n    dI1_dC = I\n    dI2_dC = I1 * I - C\n    # dI3/dC = I3 * C^-1. C is SPD, so invertible.\n    dI3_dC = I3 * np.linalg.inv(C)\n    \n    S = 2.0 * (dW_dI1 * dI1_dC + dW_dI2 * dI2_dC + dW_dI3 * dI3_dC)\n\n    # 4. Compute the First Piola-Kirchhoff stress P\n    P = F @ S\n\n    # 5. Compute internal forces and the scalar measure Phi\n    phi_total = 0.0\n    for grad_Na in grad_N_vectors:\n        # f_a is given as Grad_N_a^T * P. This is a 1x3 row vector.\n        # grad_Na is a 3x1 column vector.\n        fa_row_vector = grad_Na.T @ P\n        # Phi is the sum of squared L2 norms of the force vectors.\n        # norm squared = sum of squares of components\n        phi_total += np.sum(fa_row_vector**2)\n        \n    return phi_total\n\ndef run_verification_test(lambdas, N_trials, c1, c2, c3, grad_N_vectors):\n    \"\"\"\n    Performs the Monte Carlo verification for a single test case.\n    \"\"\"\n    # Baseline calculation with Q = I (identity matrix)\n    Q_baseline = np.identity(3)\n    phi_baseline = calculate_phi(lambdas, Q_baseline, c1, c2, c3, grad_N_vectors)\n\n    max_relative_deviation = 0.0\n\n    # Monte Carlo simulation with N random rotations\n    for _ in range(N_trials):\n        Q_random = generate_random_rotation()\n        phi_trial = calculate_phi(lambdas, Q_random, c1, c2, c3, grad_N_vectors)\n        \n        # Avoid division by zero if phi_baseline is zero, though unlikely here.\n        if abs(phi_baseline) > 1e-15:\n            relative_deviation = abs((phi_trial - phi_baseline) / phi_baseline)\n            if relative_deviation > max_relative_deviation:\n                max_relative_deviation = relative_deviation\n\n    return max_relative_deviation\n\n# Entry point for the script execution.\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3605114"}]}