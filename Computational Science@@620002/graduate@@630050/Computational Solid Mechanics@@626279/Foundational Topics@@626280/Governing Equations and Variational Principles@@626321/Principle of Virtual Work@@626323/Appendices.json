{"hands_on_practices": [{"introduction": "The Principle of Virtual Work is the foundation for deriving the governing equations in nonlinear finite element analysis. A crucial step in solving these nonlinear equations with an iterative Newton-Raphson scheme is the formulation of the consistent tangent stiffness matrix. This exercise guides you through the process of starting from the internal virtual work for a hyperelastic material and performing a consistent linearization to derive the tangent stiffness, a fundamental skill for any computational mechanician. [@problem_id:3591302]", "problem": "Consider a single two-node isoparametric bar finite element of undeformed length $L$ and constant cross-sectional area $A$, aligned with the $x$-axis and undergoing small strains. The axial displacement field is approximated by the standard linear shape functions $N_{1}(x)=1-\\frac{x}{L}$ and $N_{2}(x)=\\frac{x}{L}$ as $u_{h}(x)=N_{1}(x)\\,u_{1}+N_{2}(x)\\,u_{2}$, where $u_{1}$ and $u_{2}$ are the nodal axial displacements. The material is a one-dimensional hyperelastic solid with Helmholtz free energy density $\\psi(\\varepsilon)=\\frac{1}{2}\\,E\\,\\varepsilon^{2}+\\frac{\\alpha}{4}\\,\\varepsilon^{4}$, where $\\varepsilon$ is the small axial strain, $E>0$ is the linear elastic modulus, and $\\alpha \\ge 0$ is a material nonlinearity parameter.\n\nUsing only the principle of virtual work (PVW) and definitions stemming from the free energy, formulate the element internal virtual work and deduce the element internal force vector. Then, by performing a consistent linearization with respect to the nodal displacement vector $\\mathbf{u}_{e}=[u_{1}\\;\\;u_{2}]^{T}$, derive the consistent tangent stiffness matrix for this element in terms of $A$, $L$, $E$, $\\alpha$, $u_{1}$, and $u_{2}$. Assume isothermal conditions, neglect body forces and tractions, and work within the small-strain, one-dimensional framework.\n\nExpress your final answer as a single closed-form $2\\times 2$ matrix function of $u_{1}$ and $u_{2}$, without units. Do not simplify by introducing intermediate constants. No numerical evaluation is required.", "solution": "The problem is valid as it is scientifically grounded in the principles of continuum mechanics and the finite element method, is well-posed with sufficient information, and is stated objectively.\n\nThe derivation of the consistent tangent stiffness matrix for the specified one-dimensional hyperelastic bar element proceeds in four steps: establishing the kinematic relations, defining the constitutive law from the given free energy, formulating the internal force vector via the Principle of Virtual Work (PVW), and finally, linearizing the internal force vector.\n\n**Step 1: Kinematics**\n\nThe axial displacement field $u_{h}(x)$ within the element is interpolated from the nodal displacements $u_{1}$ and $u_{2}$ using the linear shape functions $N_{1}(x) = 1 - \\frac{x}{L}$ and $N_{2}(x) = \\frac{x}{L}$.\nIn matrix form, this is $u_{h}(x) = \\mathbf{N}(x)\\mathbf{u}_{e}$, where:\n$$ \\mathbf{N}(x) = \\begin{pmatrix} N_{1}(x)  N_{2}(x) \\end{pmatrix}, \\quad \\mathbf{u}_{e} = \\begin{pmatrix} u_{1} \\\\ u_{2} \\end{pmatrix} $$\n\nWithin the small-strain framework, the axial strain $\\varepsilon$ is the spatial derivative of the displacement field:\n$$\n\\varepsilon(x) = \\frac{d u_{h}}{dx} = \\frac{d\\mathbf{N}}{dx}\\mathbf{u}_{e}\n$$\nThe derivative of the shape function matrix is the strain-displacement matrix, $\\mathbf{B}$:\n$$\n\\mathbf{B}(x) = \\frac{d\\mathbf{N}}{dx} = \\begin{pmatrix} \\frac{dN_{1}}{dx}  \\frac{dN_{2}}{dx} \\end{pmatrix} = \\begin{pmatrix} -\\frac{1}{L}  \\frac{1}{L} \\end{pmatrix}\n$$\nSince $\\mathbf{B}$ is constant, the strain $\\varepsilon$ is uniform throughout the element:\n$$\n\\varepsilon = \\mathbf{B}\\mathbf{u}_{e} = \\begin{pmatrix} -\\frac{1}{L}  \\frac{1}{L} \\end{pmatrix} \\begin{pmatrix} u_{1} \\\\ u_{2} \\end{pmatrix} = \\frac{u_{2} - u_{1}}{L}\n$$\n\n**Step 2: Constitutive Law**\n\nThe material is hyperelastic, and its behavior is governed by the Helmholtz free energy density $\\psi(\\varepsilon)$. For an isothermal process, the axial stress $\\sigma$ is thermodynamically conjugate to the axial strain $\\varepsilon$ and is obtained by differentiating $\\psi$ with respect to $\\varepsilon$:\n$$\n\\sigma = \\frac{\\partial\\psi}{\\partial\\varepsilon}\n$$\nGiven the free energy density $\\psi(\\varepsilon) = \\frac{1}{2}\\,E\\,\\varepsilon^{2}+\\frac{\\alpha}{4}\\,\\varepsilon^{4}$, the stress is:\n$$\n\\sigma = \\frac{\\partial}{\\partial\\varepsilon} \\left( \\frac{1}{2}\\,E\\,\\varepsilon^{2}+\\frac{\\alpha}{4}\\,\\varepsilon^{4} \\right) = E\\,\\varepsilon + \\alpha\\,\\varepsilon^{3}\n$$\nThis is a nonlinear stress-strain relationship.\n\n**Step 3: Internal Force Vector**\n\nThe Principle of Virtual Work (PVW) states that the internal virtual work, $\\delta W_{int}$, is equal to the external virtual work, $\\delta W_{ext}$. For an element in equilibrium, we consider the internal part. The internal virtual work is the integral of the stress acting over the virtual strain, $\\delta\\varepsilon$, throughout the element volume $V$.\n$$\n\\delta W_{int} = \\int_{V} \\sigma \\, \\delta\\varepsilon \\, dV\n$$\nIn one dimension, $dV = A\\,dx$, where $A$ is the cross-sectional area. The virtual strain is given by $\\delta\\varepsilon = \\mathbf{B}\\,\\delta\\mathbf{u}_{e}$. Substituting this into the expression for $\\delta W_{int}$:\n$$\n\\delta W_{int} = \\int_{0}^{L} \\sigma \\, (\\mathbf{B}\\,\\delta\\mathbf{u}_{e}) \\, A \\, dx\n$$\nSince the virtual nodal displacements $\\delta\\mathbf{u}_{e}$ are arbitrary and not functions of $x$, we can write this as:\n$$\n\\delta W_{int} = \\delta\\mathbf{u}_{e}^{T} \\left( \\int_{0}^{L} \\mathbf{B}^{T} \\, \\sigma \\, A \\, dx \\right)\n$$\nBy definition, the expression in the parenthesis is the element internal force vector, $\\mathbf{f}_{int}$:\n$$\n\\mathbf{f}_{int} = \\int_{0}^{L} \\mathbf{B}^{T} \\, \\sigma \\, A \\, dx\n$$\nSince $\\mathbf{B}$, $\\sigma$ (because $\\varepsilon$ is uniform), and $A$ are all constant over the length of the element, the integral simplifies:\n$$\n\\mathbf{f}_{int} = A \\, L \\, \\mathbf{B}^{T} \\, \\sigma\n$$\nSubstituting the expressions for $\\mathbf{B}$ and $\\sigma$:\n$$\n\\mathbf{f}_{int} = A \\, L \\, \\begin{pmatrix} -\\frac{1}{L} \\\\ \\frac{1}{L} \\end{pmatrix} (E\\,\\varepsilon + \\alpha\\,\\varepsilon^{3}) = A \\, \\begin{pmatrix} -1 \\\\ 1 \\end{pmatrix} (E\\,\\varepsilon + \\alpha\\,\\varepsilon^{3})\n$$\nFinally, substituting $\\varepsilon = \\frac{u_{2} - u_{1}}{L}$:\n$$\n\\mathbf{f}_{int} = A \\, \\begin{pmatrix} -1 \\\\ 1 \\end{pmatrix} \\left( E\\frac{u_{2} - u_{1}}{L} + \\alpha\\left(\\frac{u_{2} - u_{1}}{L}\\right)^{3} \\right)\n$$\n\n**Step 4: Consistent Tangent Stiffness Matrix**\n\nThe consistent tangent stiffness matrix, $\\mathbf{K}_{T}$, is obtained by the linearization of the internal force vector $\\mathbf{f}_{int}$ with respect to the nodal displacement vector $\\mathbf{u}_{e}$. This corresponds to taking the Jacobian of $\\mathbf{f}_{int}$:\n$$\n\\mathbf{K}_{T} = \\frac{\\partial \\mathbf{f}_{int}}{\\partial \\mathbf{u}_{e}} = \\begin{pmatrix} \\frac{\\partial (f_{int})_{1}}{\\partial u_{1}}  \\frac{\\partial (f_{int})_{1}}{\\partial u_{2}} \\\\ \\frac{\\partial (f_{int})_{2}}{\\partial u_{1}}  \\frac{\\partial (f_{int})_{2}}{\\partial u_{2}} \\end{pmatrix}\n$$\nLet's compute the components. The components of $\\mathbf{f}_{int}$ are:\n$$\n(f_{int})_{1} = -A \\left( \\frac{E}{L}(u_{2} - u_{1}) + \\frac{\\alpha}{L^{3}}(u_{2} - u_{1})^{3} \\right)\n$$\n$$\n(f_{int})_{2} = +A \\left( \\frac{E}{L}(u_{2} - u_{1}) + \\frac{\\alpha}{L^{3}}(u_{2} - u_{1})^{3} \\right)\n$$\nTaking the partial derivatives:\n$$\nK_{T,11} = \\frac{\\partial (f_{int})_{1}}{\\partial u_{1}} = -A \\left( \\frac{E}{L}(-1) + \\frac{\\alpha}{L^{3}} \\cdot 3(u_{2} - u_{1})^{2}(-1) \\right) = \\frac{AE}{L} + \\frac{3A\\alpha}{L^{3}}(u_{2} - u_{1})^{2}\n$$\n$$\nK_{T,12} = \\frac{\\partial (f_{int})_{1}}{\\partial u_{2}} = -A \\left( \\frac{E}{L}(1) + \\frac{\\alpha}{L^{3}} \\cdot 3(u_{2} - u_{1})^{2}(1) \\right) = -\\frac{AE}{L} - \\frac{3A\\alpha}{L^{3}}(u_{2} - u_{1})^{2}\n$$\n$$\nK_{T,21} = \\frac{\\partial (f_{int})_{2}}{\\partial u_{1}} = A \\left( \\frac{E}{L}(-1) + \\frac{\\alpha}{L^{3}} \\cdot 3(u_{2} - u_{1})^{2}(-1) \\right) = -\\frac{AE}{L} - \\frac{3A\\alpha}{L^{3}}(u_{2} - u_{1})^{2}\n$$\n$$\nK_{T,22} = \\frac{\\partial (f_{int})_{2}}{\\partial u_{2}} = A \\left( \\frac{E}{L}(1) + \\frac{\\alpha}{L^{3}} \\cdot 3(u_{2} - u_{1})^{2}(1) \\right) = \\frac{AE}{L} + \\frac{3A\\alpha}{L^{3}}(u_{2} - u_{1})^{2}\n$$\nAssembling these components into the matrix gives the final expression for the consistent tangent stiffness matrix:\n$$\n\\mathbf{K}_{T} = \\begin{pmatrix} \\frac{AE}{L} + \\frac{3A\\alpha(u_{2} - u_{1})^{2}}{L^{3}}  -\\frac{AE}{L} - \\frac{3A\\alpha(u_{2} - u_{1})^{2}}{L^{3}} \\\\ -\\frac{AE}{L} - \\frac{3A\\alpha(u_{2} - u_{1})^{2}}{L^{3}}  \\frac{AE}{L} + \\frac{3A\\alpha(u_{2} - u_{1})^{2}}{L^{3}} \\end{pmatrix}\n$$\nThis matrix is symmetric, as expected. If the nonlinear material parameter $\\alpha = 0$, the matrix correctly reduces to the standard linear stiffness matrix for a bar element.", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{AE}{L} + \\frac{3A\\alpha(u_{2} - u_{1})^{2}}{L^{3}}  -\\frac{AE}{L} - \\frac{3A\\alpha(u_{2} - u_{1})^{2}}{L^{3}} \\\\\n-\\frac{AE}{L} - \\frac{3A\\alpha(u_{2} - u_{1})^{2}}{L^{3}}  \\frac{AE}{L} + \\frac{3A\\alpha(u_{2} - u_{1})^{2}}{L^{3}}\n\\end{pmatrix}\n}\n$$", "id": "3591302"}, {"introduction": "Beyond internal material response, the Principle of Virtual Work also provides a rigorous framework for incorporating external forces, including those that depend on the body's deformation. This practice explores the case of non-conservative \"follower\" loads, where the direction of the applied force evolves with the structure's orientation. You will derive the contribution of such a load to the tangent stiffness matrix and uncover why it breaks the symmetry we often take for granted, a result with deep implications for structural stability analysis. [@problem_id:3591290]", "problem": "Consider a planar, two-node, straight bar element used within the Finite Element Method (FEM). The bar’s initial configuration has node $1$ located at $(0,0)$ and node $2$ located at $(L,0)$, where $L0$ is the undeformed length. Node $1$ is fixed. Node $2$ undergoes translational displacements $(u_x,u_y)$ in the $x$- and $y$-directions, respectively. A non-conservative follower force of constant magnitude $P0$ is applied at node $2$, always acting along the current unit normal to the bar’s axis in the deformed configuration. The bar is hyperelastic with symmetric internal tangent contributions, but you should focus on the external follower force contribution to the tangent.\n\nUsing the Principle of Virtual Work (PVW), begin from the fundamental weak statement that the total virtual work vanishes at equilibrium, namely $\\delta W_{\\text{int}} - \\delta W_{\\text{ext}} = 0$, where $\\delta W_{\\text{int}}$ is the internal virtual work and $\\delta W_{\\text{ext}}$ is the external virtual work due to the follower load. Treat the internal virtual work as producing a symmetric tangent contribution and consider only the external follower load contribution to demonstrate asymmetry.\n\nLet the current vector from node $1$ to node $2$ be $\\mathbf{r} = (x,y)$ with $x=L+u_x$ and $y=u_y$, and let its length be $R=\\sqrt{x^2+y^2}$. Define the current unit tangent along the bar as $\\mathbf{t} = \\mathbf{r}/R$, and the corresponding unit normal as $\\mathbf{n} = (-t_y, t_x) = \\left(-\\dfrac{y}{R}, \\dfrac{x}{R}\\right)$. The external nodal force at node $2$ due to the follower load is then $\\mathbf{f}_{\\text{ext}} = P\\,\\mathbf{n}$.\n\nForm the discrete external virtual work $\\delta W_{\\text{ext}} = \\mathbf{f}_{\\text{ext}} \\cdot \\delta \\mathbf{u}_2$ and, by consistent linearization with respect to $(u_x,u_y)$, obtain the external contribution to the $2\\times 2$ tangent matrix $\\mathbf{K}_{\\text{ext}} = \\dfrac{\\partial \\mathbf{f}_{\\text{ext}}}{\\partial \\mathbf{u}_2}$. Compute the off-diagonal difference $k_{12} - k_{21}$ of $\\mathbf{K}_{\\text{ext}}$ as a closed-form analytic expression in terms of $P$, $L$, $u_x$, and $u_y$.\n\nYour final answer must be a single closed-form analytic expression. The requested quantity $k_{12}-k_{21}$ has units of $\\mathrm{N/m}$; ensure your expression is dimensionally consistent with force per length. No rounding is required.", "solution": "The problem requires the derivation of the external contribution to the tangent stiffness matrix, $\\mathbf{K}_{\\text{ext}}$, for a non-conservative follower force. We will show that this matrix is asymmetric by computing the difference of its off-diagonal terms, $k_{12} - k_{21}$. The derivation proceeds by first defining the force vector in terms of the nodal displacements and then performing a consistent linearization.\n\n**Step 1: Define the External Force Vector**\n\nThe follower force $\\mathbf{f}_{\\text{ext}}$ has a constant magnitude $P$ and is directed along the current unit normal vector $\\mathbf{n}$. The displacement vector at the free node (node 2) is $\\mathbf{u}_2 = \\begin{pmatrix} u_x \\\\ u_y \\end{pmatrix}$. The current position of node 2 is $\\mathbf{r} = \\begin{pmatrix} x \\\\ y \\end{pmatrix} = \\begin{pmatrix} L+u_x \\\\ u_y \\end{pmatrix}$, and the current length of the bar is $R = \\|\\mathbf{r}\\| = \\sqrt{(L+u_x)^2 + u_y^2}$.\n\nThe unit normal vector is $\\mathbf{n} = \\frac{1}{R} \\begin{pmatrix} -y \\\\ x \\end{pmatrix}$. The external force vector is therefore:\n$$\n\\mathbf{f}_{\\text{ext}} = P\\mathbf{n} = \\frac{P}{R} \\begin{pmatrix} -y \\\\ x \\end{pmatrix} = \\frac{P}{\\sqrt{(L+u_x)^2 + u_y^2}} \\begin{pmatrix} -u_y \\\\ L+u_x \\end{pmatrix}\n$$\nLet the components of the force vector be $f_1$ and $f_2$.\n\n**Step 2: Define the External Tangent Matrix**\n\nThe external tangent matrix $\\mathbf{K}_{\\text{ext}}$ is the Jacobian of the external force vector with respect to the displacement vector $\\mathbf{u}_2$:\n$$\n\\mathbf{K}_{\\text{ext}} = \\frac{\\partial \\mathbf{f}_{\\text{ext}}}{\\partial \\mathbf{u}_2} = \\begin{pmatrix} \\frac{\\partial f_1}{\\partial u_x}  \\frac{\\partial f_1}{\\partial u_y} \\\\ \\frac{\\partial f_2}{\\partial u_x}  \\frac{\\partial f_2}{\\partial u_y} \\end{pmatrix} = \\begin{pmatrix} k_{11}  k_{12} \\\\ k_{21}  k_{22} \\end{pmatrix}\n$$\nWe need to compute the off-diagonal terms $k_{12}$ and $k_{21}$.\n\n**Step 3: Compute the Off-Diagonal Terms**\n\nFirst, we compute the partial derivatives of the bar's current length $R$:\n$$\n\\frac{\\partial R}{\\partial u_x} = \\frac{L+u_x}{R} = \\frac{x}{R} \\quad \\text{and} \\quad \\frac{\\partial R}{\\partial u_y} = \\frac{u_y}{R} = \\frac{y}{R}\n$$\nNow, we compute $k_{12} = \\frac{\\partial f_1}{\\partial u_y}$ using the quotient rule, where $f_1 = -P \\frac{y}{R}$:\n$$\nk_{12} = \\frac{\\partial}{\\partial u_y} \\left( -P \\frac{y}{R} \\right) = -P \\left( \\frac{(\\frac{\\partial y}{\\partial u_y})R - y(\\frac{\\partial R}{\\partial u_y})}{R^2} \\right) = -P \\left( \\frac{1 \\cdot R - y \\cdot \\frac{y}{R}}{R^2} \\right) = -P \\frac{R^2 - y^2}{R^3}\n$$\nSince $R^2 = x^2 + y^2$, we get $k_{12} = -P \\frac{x^2}{R^3}$.\n\nNext, we compute $k_{21} = \\frac{\\partial f_2}{\\partial u_x}$, where $f_2 = P \\frac{x}{R}$:\n$$\nk_{21} = \\frac{\\partial}{\\partial u_x} \\left( P \\frac{x}{R} \\right) = P \\left( \\frac{(\\frac{\\partial x}{\\partial u_x})R - x(\\frac{\\partial R}{\\partial u_x})}{R^2} \\right) = P \\left( \\frac{1 \\cdot R - x \\cdot \\frac{x}{R}}{R^2} \\right) = P \\frac{R^2 - x^2}{R^3}\n$$\nSince $R^2 = x^2 + y^2$, we get $k_{21} = P \\frac{y^2}{R^3}$.\n\n**Step 4: Compute the Asymmetry**\n\nThe asymmetry is given by the difference $k_{12} - k_{21}$:\n$$\nk_{12} - k_{21} = -P \\frac{x^2}{R^3} - P \\frac{y^2}{R^3} = -P \\frac{x^2 + y^2}{R^3}\n$$\nSubstituting $x^2 + y^2 = R^2$:\n$$\nk_{12} - k_{21} = -P \\frac{R^2}{R^3} = -\\frac{P}{R}\n$$\nExpressing this in terms of the given displacement variables, we arrive at the final result:\n$$\nk_{12} - k_{21} = -\\frac{P}{\\sqrt{(L+u_x)^2 + u_y^2}}\n$$\nSince $P>0$, this difference is non-zero, proving that the tangent contribution from the follower force is indeed asymmetric.", "answer": "$$\n\\boxed{-\\frac{P}{\\sqrt{(L+u_x)^2 + u_y^2}}}\n$$", "id": "3591290"}, {"introduction": "Bridging the gap between analytical theory and robust computational code is a vital skill in modern engineering. While manual derivations are instructive for simple cases, real-world simulations rely on automated and verified implementations of complex material models. This exercise introduces the \"tangent check,\" a cornerstone of professional finite element development, where you will verify an analytical tangent stiffness computed via automatic differentiation against a numerical tangent computed via finite differences, ensuring the correctness of a hyperelastic material model implementation. [@problem_id:3591268]", "problem": "Consider a three-dimensional hyperelastic material at a single integration point with total potential energy density given by a strain-energy function $\\Psi(I_1, I_2, J)$, where $I_1$ and $I_2$ are the first and second principal invariants of the right Cauchy-Green tensor $C = F^{\\mathsf T} F$, and $J = \\det F$ is the Jacobian of the deformation gradient $F$. The internal virtual work is defined from first principles by the Principle of Virtual Work as $\\delta W_{\\text{int}} = \\int_{\\Omega_0} P : \\delta F \\, \\mathrm{d}V$, where $P$ is the first Piola-Kirchhoff stress and $\\Omega_0$ is the reference configuration. In a discretized setting with a finite set of generalized degrees of freedom $u \\in \\mathbb{R}^n$ and a kinematic mapping $F(u)$, the internal virtual work takes the form $\\delta W_{\\text{int}}(u;\\delta u) = \\delta u^{\\mathsf T} f_{\\text{int}}(u)$, where $f_{\\text{int}}(u)$ is the internal force vector. The consistent linearization required by Newton-type methods is the Jacobian $K(u) = \\dfrac{\\partial f_{\\text{int}}(u)}{\\partial u}$, which is the derivative of the internal virtual work with respect to $u$.\n\nYour task is to derive and implement, from the Principle of Virtual Work and standard tensor definitions, a verification that the consistent linearization computed analytically via automatic differentiation of the scalar energy $W(u) = \\int_{\\Omega_0} \\Psi(I_1, I_2, J) \\, \\mathrm{d}V$ coincides with a numerical tangent computed by finite differences of $f_{\\text{int}}(u) = \\dfrac{\\partial W(u)}{\\partial u}$. Work at a single material point with unit reference volume so that $\\int_{\\Omega_0} (\\cdot) \\, \\mathrm{d}V = (\\cdot)$, and use a kinematic map of the form\n$$\nF(u) = I + \\sum_{a=1}^{n} u_a H_a,\n$$\nwith $n=4$ and constant basis matrices\n$$\nH_1 = E_{11}, \\quad H_2 = E_{12}, \\quad H_3 = E_{22}, \\quad H_4 = E_{33},\n$$\nwhere $E_{ij}$ is the matrix with entry $1$ at row $i$, column $j$, and zero elsewhere, and $I$ is the identity. Thus,\n$$\nF(u) =\n\\begin{bmatrix}\n1 + u_1  u_2  0 \\\\\n0  1 + u_3  0 \\\\\n0  0  1 + u_4\n\\end{bmatrix}.\n$$\n\nUse the following invariant definitions:\n- $C = F^{\\mathsf T} F$,\n- $I_1 = \\mathrm{tr}(C)$,\n- $I_2 = \\dfrac{1}{2}\\left( I_1^2 - \\mathrm{tr}(C^2) \\right)$,\n- $J = \\det(F)$.\n\nAdopt the compressible hyperelastic strain-energy density\n$$\n\\Psi(I_1, I_2, J) = \\frac{\\mu}{2}(I_1 - 3) + \\frac{\\alpha}{2}(I_2 - 3) - \\mu \\ln J + \\frac{\\lambda}{2} (\\ln J)^2,\n$$\nwith material parameters $\\mu = 20000$, $\\lambda = 40000$, and $\\alpha = 5000$ (in Pascals). The total internal energy at the point is $W(u) = \\Psi(I_1(u), I_2(u), J(u))$.\n\nYou must:\n- Start from the Principle of Virtual Work and the above definitions to identify $f_{\\text{int}}(u) = \\dfrac{\\partial W(u)}{\\partial u}$ and $K(u) = \\dfrac{\\partial^2 W(u)}{\\partial u^2}$.\n- Implement a forward-mode automatic differentiation engine that returns both the gradient and Hessian of the scalar function $W(u)$ with respect to $u$ at a given $u$.\n- Compute a numerical tangent matrix $K_{\\text{FD}}(u)$ via centered finite differences applied to $f_{\\text{int}}(u)$ with a perturbation $h = 10^{-6}$.\n- Verify, for each test case, that the maximum absolute entry-wise difference between $K(u)$ and $K_{\\text{FD}}(u)$ is below a tolerance $\\varepsilon = 10^{-6}$.\n\nTest suite:\n- Case $1$ (general moderate deformation): $u = [0.05, \\, 0.02, \\, -0.03, \\, 0.04]$.\n- Case $2$ (identity): $u = [0, \\, 0, \\, 0, \\, 0]$.\n- Case $3$ (pure shear): $u = [0, \\, 0.1, \\, 0, \\, 0]$.\n- Case $4$ (compressive but admissible): $u = [-0.4, \\, 0.2, \\, -0.3, \\, -0.2]$.\n\nAll deformations must satisfy $J(u)  0$ implicitly through the chosen $u$ and $h$.\n\nYour program must:\n- For each test case, compute $K(u)$ via automatic differentiation and $K_{\\text{FD}}(u)$ via centered finite differences of $f_{\\text{int}}(u)$.\n- For each test case, compute the scalar discrepancy $d = \\max_{i,j} \\left| K_{ij}(u) - K_{\\text{FD},ij}(u) \\right|$ and produce a boolean indicating whether $d \\le \\varepsilon$.\n- Produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[True,True,False,True]\").\n\nNo external input should be required. No physical units are required in the output because the requested outputs are boolean values. Angles are not used, so no angular unit specification is required.", "solution": "The stated problem requires the verification of the consistent tangent stiffness matrix for a hyperelastic material model at a single point. This is a fundamental procedure in computational solid mechanics to ensure that the iterative Newton-Raphson solver, which relies on this matrix, will exhibit quadratic convergence. The verification compares the analytical tangent matrix, derived from the material's potential energy, with a numerical approximation computed via finite differences.\n\nWe begin from the Principle of Virtual Work, which states that the internal virtual work $\\delta W_{\\text{int}}$ is given by\n$$\n\\delta W_{\\text{int}} = \\int_{\\Omega_0} P : \\delta F \\, \\mathrm{d}V,\n$$\nwhere $P$ is the first Piola-Kirchhoff stress tensor, $F$ is the deformation gradient, and $\\Omega_0$ is the material reference configuration. The stress $P$ is constitutively related to the strain energy density function $\\Psi$ by $P = \\dfrac{\\partial \\Psi}{\\partial F}$. The total potential energy $W$ is the integral of the strain energy density, $W = \\int_{\\Omega_0} \\Psi \\, \\mathrm{d}V$. Therefore, the internal virtual work is the first variation of the total potential energy, $\\delta W_{\\text{int}} = \\delta W$.\n\nIn a discretized system parameterized by generalized coordinates $u \\in \\mathbb{R}^n$, the deformation gradient becomes a function $F(u)$. The total potential energy is a scalar function $W(u)$. The variation $\\delta W$ can be expressed using the chain rule:\n$$\n\\delta W(u; \\delta u) = \\frac{\\partial W(u)}{\\partial u} \\cdot \\delta u = \\sum_{a=1}^{n} \\frac{\\partial W(u)}{\\partial u_a} \\delta u_a.\n$$\nBy definition, the internal virtual work is also expressed in terms of the internal force vector $f_{\\text{int}}(u)$:\n$$\n\\delta W_{\\text{int}}(u; \\delta u) = f_{\\text{int}}(u)^{\\mathsf{T}} \\delta u = \\sum_{a=1}^{n} f_{\\text{int},a}(u) \\delta u_a.\n$$\nComparing these two expressions reveals the fundamental relationship between the internal force vector and the potential energy:\n$$\nf_{\\text{int}}(u) = \\frac{\\partial W(u)}{\\partial u} = \\nabla_u W(u).\n$$\nThe internal force vector is the gradient of the total potential energy with respect to the discrete degrees of freedom.\n\nThe consistent linearization of the internal force vector, required for Newton-type solvers, is the tangent stiffness matrix $K(u)$. It is defined as the Jacobian of the internal force vector:\n$$\nK(u) = \\frac{\\partial f_{\\text{int}}(u)}{\\partial u}.\n$$\nSubstituting the expression for $f_{\\text{int}}(u)$, we find that the tangent stiffness matrix is the Hessian of the total potential energy:\n$$\nK(u) = \\frac{\\partial}{\\partial u} \\left( \\frac{\\partial W(u)}{\\partial u} \\right) = \\frac{\\partial^2 W(u)}{\\partial u^2} = \\nabla_u^2 W(u).\n$$\nThe problem simplifies to a single point with unit volume, thus $W(u) = \\Psi(u)$. The task is to compute the gradient $f_{\\text{int}}(u)$ and Hessian $K(u)$ of $W(u)$ and verify their relationship.\n\nTo compute the analytical derivatives, we employ forward-mode automatic differentiation (AD). This technique calculates the value of a function and its derivatives simultaneously by propagating them through each step of the computation. We define a custom data type, an `ADVar`, that stores a function's value, its gradient vector, and its Hessian matrix. For a scalar function $g(u)$, its `ADVar` representation at a point $u_0$ would be the tuple $(g(u_0), \\nabla_u g(u_0), \\nabla_u^2 g(u_0))$. We then overload arithmetic operators ($+$, $-$, $*$, $/$) and elementary functions ($\\ln$) to operate on these tuples according to the rules of calculus. For example, for two functions $g(u)$ and $h(u)$, the rules for their product $p(u) = g(u)h(u)$ are:\n- Value: $p = gh$\n- Gradient: $\\nabla p = (\\nabla g)h + g(\\nabla h)$\n- Hessian: $\\nabla^2 p = (\\nabla^2 g)h + g(\\nabla^2 h) + (\\nabla g)(\\nabla h)^{\\mathsf{T}} + (\\nabla h)(\\nabla g)^{\\mathsf{T}}$\n\nThe computational procedure using AD is as follows:\n1.  Initialize the independent variables $u_a$ as `ADVar` objects: $u_a \\rightarrow (u_a, e_a, 0)$, where $e_a$ is the $a$-th standard basis vector and $0$ is a zero matrix.\n2.  Construct the deformation gradient matrix $F(u)$ as a matrix of `ADVar` objects, using the given kinematic map:\n    $$\n    F(u) =\n    \\begin{bmatrix}\n    1 + u_1  u_2  0 \\\\\n    0  1 + u_3  0 \\\\\n    0  0  1 + u_4\n    \\end{bmatrix}.\n    $$\n    Each entry is an `ADVar` resulting from operations on the initial $u_a$ `ADVar`s.\n3.  Compute the right Cauchy-Green tensor $C = F^{\\mathsf T} F$. This matrix multiplication is performed on `ADVar` objects, automatically propagating values, gradients, and Hessians.\n4.  Calculate the invariants $I_1 = \\mathrm{tr}(C)$, $I_2 = \\frac{1}{2}(I_1^2 - \\mathrm{tr}(C^2))$, and $J = \\det(F)$. These operations are also performed on `ADVar`s.\n5.  Evaluate the strain-energy function $\\Psi(I_1, I_2, J)$ using the given material parameters. The final result is an `ADVar` object whose components are the total energy $W(u)$, the internal force vector $f_{\\text{int}}(u)$, and the tangent stiffness matrix $K(u)$.\n\nTo verify this analytical tangent $K(u)$, we compute a numerical tangent $K_{\\text{FD}}(u)$ using the centered finite difference method. This method approximates the columns of the Jacobian of $f_{\\text{int}}(u)$. The $j$-th column of $K_{\\text{FD}}(u)$ is given by:\n$$\nK_{\\text{FD}, \\cdot j}(u) = \\frac{f_{\\text{int}}(u + h e_j) - f_{\\text{int}}(u - h e_j)}{2h},\n$$\nwhere $e_j$ is the $j$-th standard basis vector and $h$ is a small perturbation. The function $f_{\\text{int}}$ used in this formula is the gradient component obtained from our AD calculation.\n\nThe verification consists of comparing the analytical tangent $K(u)$ and the numerical tangent $K_{\\text{FD}}(u)$ for each test case. The maximum absolute entry-wise difference, $d = \\max_{i,j} | K_{ij}(u) - K_{\\text{FD},ij}(u) |$, is computed and checked against a small tolerance $\\varepsilon = 10^{-6}$. A successful check ($d \\le \\varepsilon$) confirms the correctness of the analytical derivative implementation.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Note: The problem statement allows for scipy, but it is not used in this implementation\n# as all necessary components (AD, FD) are built from first principles using numpy.\n\ndef solve():\n    \"\"\"\n    Main function to perform the tangent stiffness verification for all test cases.\n    \"\"\"\n\n    class ADVar:\n        \"\"\"\n        A class for forward-mode automatic differentiation up to the second order (Hessian).\n        An ADVar object stores a value, its gradient, and its Hessian with respect to\n        a set of independent variables.\n        \"\"\"\n        def __init__(self, val, grad=None, hess=None, n_vars=4):\n            self.val = float(val)\n            self.n_vars = n_vars\n            \n            if grad is None:\n                self.grad = np.zeros(self.n_vars)\n            else:\n                self.grad = np.array(grad, dtype=float)\n\n            if hess is None:\n                self.hess = np.zeros((self.n_vars, self.n_vars))\n            else:\n                self.hess = np.array(hess, dtype=float)\n\n        def __repr__(self):\n            return f\"ADVar(val={self.val})\"\n\n        def __add__(self, other):\n            if isinstance(other, ADVar):\n                val = self.val + other.val\n                grad = self.grad + other.grad\n                hess = self.hess + other.hess\n                return ADVar(val, grad, hess, self.n_vars)\n            else:\n                return ADVar(self.val + other, self.grad, self.hess, self.n_vars)\n\n        def __radd__(self, other):\n            return self.__add__(other)\n\n        def __sub__(self, other):\n            if isinstance(other, ADVar):\n                val = self.val - other.val\n                grad = self.grad - other.grad\n                hess = self.hess - other.hess\n                return ADVar(val, grad, hess, self.n_vars)\n            else:\n                return ADVar(self.val - other, self.grad, self.hess, self.n_vars)\n\n        def __rsub__(self, other):\n            val = other - self.val\n            grad = -self.grad\n            hess = -self.hess\n            return ADVar(val, grad, hess, self.n_vars)\n\n        def __mul__(self, other):\n            if isinstance(other, ADVar):\n                val = self.val * other.val\n                grad = self.val * other.grad + other.val * self.grad\n                hess = (self.val * other.hess + other.val * self.hess +\n                        np.outer(self.grad, other.grad) + np.outer(other.grad, self.grad))\n                return ADVar(val, grad, hess, self.n_vars)\n            else:\n                return ADVar(self.val * other, self.grad * other, self.hess * other, self.n_vars)\n\n        def __rmul__(self, other):\n            return self.__mul__(other)\n        \n        def __pow__(self, power):\n            if power == 2: # Specific optimization for x^2\n                return self * self\n            val = self.val ** power\n            grad = power * (self.val ** (power - 1)) * self.grad\n            hess = power * (self.val ** (power - 1)) * self.hess + \\\n                   power * (power - 1) * (self.val ** (power - 2)) * np.outer(self.grad, self.grad)\n            return ADVar(val, grad, hess, self.n_vars)\n\n        def __neg__(self):\n            return ADVar(-self.val, -self.grad, -self.hess, self.n_vars)\n\n    def ad_log(x: ADVar):\n        \"\"\" Logarithm function for ADVar \"\"\"\n        if not isinstance(x, ADVar):\n            return np.log(x)\n        val = np.log(x.val)\n        grad = (1.0 / x.val) * x.grad\n        hess = (1.0 / x.val) * x.hess - (1.0 / x.val**2) * np.outer(x.grad, x.grad)\n        return ADVar(val, grad, hess, x.n_vars)\n\n    # Material Parameters\n    mu = 20000.0\n    alpha = 5000.0\n    lambda_ = 40000.0\n    \n    def compute_energy_grad_hess(u_vec):\n        \"\"\"\n        Computes the energy, internal force (gradient), and tangent stiffness (Hessian)\n        for a given displacement vector u_vec using Automatic Differentiation.\n        \"\"\"\n        n_vars = len(u_vec)\n        \n        u_ad = []\n        for i in range(n_vars):\n            grad_vec = np.zeros(n_vars)\n            grad_vec[i] = 1.0\n            u_ad.append(ADVar(u_vec[i], grad=grad_vec, n_vars=n_vars))\n\n        F = np.array([\n            [ADVar(1.0, n_vars=n_vars), ADVar(0.0, n_vars=n_vars), ADVar(0.0, n_vars=n_vars)],\n            [ADVar(0.0, n_vars=n_vars), ADVar(1.0, n_vars=n_vars), ADVar(0.0, n_vars=n_vars)],\n            [ADVar(0.0, n_vars=n_vars), ADVar(0.0, n_vars=n_vars), ADVar(1.0, n_vars=n_vars)]\n        ], dtype=object)\n\n        F[0, 0] += u_ad[0]\n        F[0, 1] += u_ad[1]\n        F[1, 1] += u_ad[2]\n        F[2, 2] += u_ad[3]\n\n        C = F.T @ F\n        C2 = C @ C\n        \n        I1 = np.trace(C)\n        tr_C2 = np.trace(C2)\n        I2 = 0.5 * (I1**2 - tr_C2)\n        \n        J = F[0, 0] * F[1, 1] * F[2, 2]\n\n        # Strain-energy function\n        ln_J = ad_log(J)\n        Psi = (mu / 2.0) * (I1 - 3.0) + \\\n              (alpha / 2.0) * (I2 - 3.0) - \\\n              mu * ln_J + \\\n              (lambda_ / 2.0) * (ln_J**2)\n\n        return Psi.val, Psi.grad, Psi.hess\n\n    def compute_fd_hessian(u_vec, h=1e-6):\n        \"\"\"\n        Computes the tangent stiffness (Hessian) using centered finite differences\n        of the internal force vector (gradient).\n        \"\"\"\n        n_vars = len(u_vec)\n        K_fd = np.zeros((n_vars, n_vars))\n        \n        def get_f_int(u):\n            _, grad, _ = compute_energy_grad_hess(u)\n            return grad\n\n        for j in range(n_vars):\n            e_j = np.zeros(n_vars)\n            e_j[j] = 1.0\n            \n            u_plus = u_vec + h * e_j\n            u_minus = u_vec - h * e_j\n            \n            f_plus = get_f_int(u_plus)\n            f_minus = get_f_int(u_minus)\n            \n            K_fd[:, j] = (f_plus - f_minus) / (2.0 * h)\n            \n        return K_fd\n\n    test_cases = [\n        np.array([0.05, 0.02, -0.03, 0.04]),\n        np.array([0.0, 0.0, 0.0, 0.0]),\n        np.array([0.0, 0.1, 0.0, 0.0]),\n        np.array([-0.4, 0.2, -0.3, -0.2]),\n    ]\n    \n    tolerance = 1e-6\n    results = []\n\n    for u_test in test_cases:\n        _, _, K_ad = compute_energy_grad_hess(u_test)\n        K_fd = compute_fd_hessian(u_test)\n        \n        discrepancy = np.max(np.abs(K_ad - K_fd))\n        results.append(discrepancy = tolerance)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3591268"}]}