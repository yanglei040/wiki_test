{"hands_on_practices": [{"introduction": "A robust parallel simulation requires that each process uses a unique and non-overlapping sequence of random numbers. The foundational technique to achieve this is the \"skip-ahead\" method, where we partition a generator's long primary sequence into distant substreams. This practice challenges you to develop and implement the efficient algorithm required to \"jump\" a Linear Congruential Generator forward by a massive number of steps, leveraging the algebraic structure of its update rule to create independent streams in a theoretically sound manner [@problem_id:3338260].", "problem": "Consider the Linear Congruential Generator (LCG) defined by the recurrence $x_{k+1} = (a x_k + c) \\bmod m$ on the state space $\\{0,1,\\dots,m-1\\}$, where $m = 2^{48}$, $a = 25214903917$, and $c = 11$. In stochastic simulation and Monte Carlo methods (MC), seed initialization and stream independence are achieved by deterministic skip-ahead so that multiple independent substreams can be constructed from a single generator without overlap in prescribed windows.\n\nStarting from the following fundamental base:\n- The LCG recurrence $x_{k+1} = (a x_k + c) \\bmod m$ defines an affine map $f(x) = (a x + c) \\bmod m$ over the ring $\\mathbb{Z}/m\\mathbb{Z}$.\n- Composition of affine maps is associative and closed: if $f(x) = (A x + C) \\bmod m$ and $g(x) = (B x + D) \\bmod m$ then $g \\circ f$ is an affine map over $\\mathbb{Z}/m\\mathbb{Z}$.\n- Binary exponentiation (also called exponentiation by squaring) reduces repeated composition to $O(\\log t)$ compositions.\n\nYour tasks are:\n1. Derive, from first principles, an algorithm that computes $x_{n+t}$ from a given $x_n$ for arbitrary nonnegative integer $t$ using binary exponentiation of affine maps modulo $m$. Specialize your derivation to $t = 10^{12}$ and show how to compute $x_{n+10^{12}}$ without iterating the recurrence $10^{12}$ times and without requiring any modular inverse that may not exist in $\\mathbb{Z}/2^{48}\\mathbb{Z}$.\n2. Analyze the time and space complexity of your algorithm as functions of $t$ and discuss how this supports stream independence via skip-ahead in Monte Carlo simulation.\n3. Implement the algorithm in a complete, runnable program and apply it to the following test suite. Each test case produces a single boolean or integer result:\n   - Test 1 (correctness against naive iteration): Let $x_n = 42$ and $t = 1000$. Compute $x_{n+t}$ by your skip-ahead algorithm and by direct iteration of the LCG, and return a boolean indicating whether the two results are equal.\n   - Test 2 (identity boundary): Let $x_n = 1234567890123$ and $t = 0$. Compute and return $x_{n+t}$ as an integer.\n   - Test 3 (single-step boundary): Let $x_n = 1$ and $t = 1$. Compute and return $x_{n+t}$ as an integer.\n   - Test 4 (large skip from zero): Let $x_n = 0$ and $t = 10^{12}$. Compute and return $x_{n+t}$ as an integer.\n   - Test 5 (empirical substream independence in a window): Define two substreams using stride $S = 10^{12}$. Let the initial seed be $x_0 = 1234567890123$, define the second seed as $x_0' = x_{0+S}$ via your skip-ahead algorithm, and then produce the first $L = 1000$ states of each substream by direct iteration. Return a boolean indicating whether the sets of the first $L$ states of the two substreams are disjoint.\n\nYour program should produce a single line of output containing the results of the tests as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4,result5]\"). No physical units or angles are involved; all quantities are pure integers or booleans in the specified ring arithmetic.", "solution": "The problem asks for the derivation, analysis, and implementation of an efficient algorithm to compute the state $x_{n+t}$ of a Linear Congruential Generator (LCG) given a starting state $x_n$, without performing $t$ iterations. This technique is known as skip-ahead or jump-ahead.\n\nThe LCG is defined by the recurrence relation:\n$$x_{k+1} = (a x_k + c) \\bmod m$$\nwith parameters $m = 2^{48}$, $a = 25214903917$, and $c = 11$.\n\n### 1. Derivation of the Skip-Ahead Algorithm\n\nThe core principle is to represent the LCG recurrence as the repeated application of an affine transformation and then use an efficient algorithm to compute the $t$-th power of this transformation.\n\n**Step 1: Formalize the LCG as an Affine Map**\nThe recurrence $x_{k+1} = (ax_k + c) \\pmod m$ can be expressed as the application of a function $f$ to the state $x_k$:\n$$x_{k+1} = f(x_k)$$\nwhere $f(x) = (ax + c) \\pmod m$. This is an affine transformation on the ring of integers modulo $m$, $\\mathbb{Z}/m\\mathbb{Z}$.\nTo find the state after $t$ steps, $x_{n+t}$, we must apply the map $f$ a total of $t$ times to the initial state $x_n$:\n$$x_{n+t} = f(f(\\dots f(x_n)\\dots)) = f^t(x_n)$$\n\n**Step 2: The Algebra of Affine Map Composition**\nLet us analyze the composition of two such affine maps. Consider two maps, $g(x) = (A'x + C') \\pmod m$ and $h(x) = (Ax + C) \\pmod m$. Their composition $(g \\circ h)(x)$ is:\n$$(g \\circ h)(x) = g(h(x)) = A'(Ax + C) + C' = (A'A)x + (A'C + C') \\pmod m$$\nThe composition of two affine maps is another affine map. We can define a composition operation on the coefficient pairs $(A, C)$. If $g$ corresponds to the pair $(A', C')$ and $h$ to $(A, C)$, their composition $g \\circ h$ corresponds to a new pair:\n$$(A', C') \\circ (A, C) = (A'A \\pmod m, (A'C + C') \\pmod m)$$\nThis composition operation is associative, which is a crucial property for exponentiation.\n\nA brute-force calculation of $x_{n+t}$ would be $f^t(x_n)$, which is computationally expensive. A more direct formula can be found by induction:\n$$x_{n+1} = ax_n + c$$\n$$x_{n+2} = a(ax_n+c)+c = a^2x_n + ac+c$$\n$$x_{n+3} = a(a^2x_n+ac+c)+c = a^3x_n + a^2c+ac+c$$\nThe general form for $x_{n+t}$ is:\n$$x_{n+t} = \\left(a^t x_n + c \\sum_{i=0}^{t-1} a^i\\right) \\pmod m$$\nThe sum is a geometric series, which has a closed-form solution $\\sum_{i=0}^{t-1} a^i = \\frac{a^t-1}{a-1}$. Using this, we would get:\n$$x_{n+t} = \\left(a^t x_n + c \\frac{a^t-1}{a-1}\\right) \\pmod m$$\nThis formula requires division by $a-1$, which means we would need to find the modular multiplicative inverse of $(a-1) \\pmod m$. For $m=2^{48}$ and $a=25214903917$, $a-1=25214903916$, which is an even number. Since $m$ is also even, $\\gcd(a-1, m) \\neq 1$, and thus the modular inverse of $(a-1) \\pmod{2^{48}}$ does not exist. This approach is therefore invalid for the given parameters, as correctly noted in the problem statement.\n\n**Step 3: Binary Exponentiation of Affine Maps**\nThe valid approach, which avoids modular inverses, is to compute the coefficients of the composed map $f^t(x) = (A_t x + C_t) \\pmod m$ using the composition rule and binary exponentiation (also known as exponentiation by squaring).\n\nThe goal is to compute the pair $(A_t, C_t)$ that represents $f^t$. This is equivalent to computing the $t$-th power of the map $f$, represented by its coefficient pair $(a, c)$, under the composition operation.\n\nThe algorithm for computing $(A_t, C_t) = (a, c)^t$ is as follows:\nLet the binary representation of $t$ be $t = \\sum_{i=0}^k b_i 2^i$, where $b_i \\in \\{0, 1\\}$. Then $f^t = \\prod_{i: b_i=1} f^{2^i}$. We can compute this product iteratively.\n\n1.  **Initialization**:\n    The identity map is $id(x) = 1 \\cdot x + 0$, so its coefficient pair is $(1, 0)$. This will be our accumulator for the final result.\n    Let $(A_{res}, C_{res}) = (1, 0)$.\n    The base map is $f^1$, corresponding to the pair $(a, c)$.\n    Let $(A_{base}, C_{base}) = (a, c)$.\n\n2.  **Iteration**: We process the bits of $t$ from least significant to most significant.\n    While $t > 0$:\n    a. If the current least significant bit of $t$ is $1$, we compose our accumulated result with the current base map:\n       $(A_{res}, C_{res}) \\leftarrow (A_{base}, C_{base}) \\circ (A_{res}, C_{res})$. Using the composition rule, this becomes:\n       - $A_{res, new} = (A_{base} \\cdot A_{res}) \\pmod m$\n       - $C_{res, new} = (A_{base} \\cdot C_{res} + C_{base}) \\pmod m$\n    b. We square the base map to prepare for the next bit, as $f^{2^{i+1}} = f^{2^i} \\circ f^{2^i}$:\n       $(A_{base}, C_{base}) \\leftarrow (A_{base}, C_{base}) \\circ (A_{base}, C_{base})$. This becomes:\n       - $A_{base, new} = (A_{base} \\cdot A_{base}) \\pmod m$\n       - $C_{base, new} = (A_{base} \\cdot C_{base} + C_{base}) \\pmod m$\n    c. We discard the processed bit of $t$ by right-shifting: $t \\leftarrow t \\gg 1$.\n\n3.  **Finalization**:\n    After the loop finishes, the pair $(A_{res}, C_{res})$ will be $(A_t, C_t)$.\n    The final state $x_{n+t}$ is then computed by applying this map to $x_n$:\n    $$x_{n+t} = (A_t \\cdot x_n + C_t) \\pmod m$$\nThis algorithm computes the result using only modular multiplication and addition, with no need for inverses. For $t = 10^{12}$, this algorithm is exceptionally efficient, as the number of iterations is proportional to $\\log_2(10^{12})$.\n\n### 2. Complexity Analysis and Application to Stream Independence\n\n**Time Complexity**\nThe binary exponentiation algorithm iterates approximately $\\log_2 t$ times. Inside each iteration, a fixed number of modular multiplications and additions are performed to carry out the two composition operations. The numbers involved are bounded by $m$, and for a fixed $m$, these arithmetic operations take constant time. Therefore, the time complexity to compute the coefficients $(A_t, C_t)$ is $O(\\log t)$. After computing the coefficients, a single application of the map requires one multiplication and one addition, which is an $O(1)$ operation. The overall time complexity of the skip-ahead algorithm is thus $O(\\log t)$.\n\n**Space Complexity**\nThe algorithm requires a fixed number of variables to store the coefficients of the accumulator and base maps, along with the input parameters. The memory usage does not scale with $t$. Consequently, the space complexity is $O(1)$.\n\n**Support for Stream Independence in Monte Carlo Simulation**\nIn parallel Monte Carlo simulations, it is critical that each of the $P$ parallel processes generates a sequence of random numbers that is statistically independent from the others. A single LCG produces one long sequence of states. A robust method to create independent \"substreams\" for each process is to partition this main sequence.\n\nWe can assign process $i$ (for $i \\in \\{0, 1, \\dots, P-1\\}$) a substream starting at seed $x_S^{(i)} = x_{i \\cdot S}$, where $S$ is a very large skip distance or stride. For instance, we could choose $S=10^{12}$.\n- Process $0$ starts with $x_0$.\n- Process $1$ starts with $x_S$, computed as $f^S(x_0)$.\n- Process $2$ starts with $x_{2S}$, computed as $f^S(x_S)$.\n- And so on, with process $i$ starting at $x_{iS} = f^S(x_{(i-1)S})$.\n\nThe derived skip-ahead algorithm with its $O(\\log S)$ time complexity is the enabling technology for this approach. Computing the starting seed for each process is nearly instantaneous, even for enormous strides like $S=10^{12}$. Without this algorithm, calculating $x_{i \\cdot S}$ would require $i \\cdot S$ iterations, which would be computationally infeasible and defeat the purpose of parallelization.\n\nBy choosing $S$ to be much larger than the number of random variates any single process will consume, we can ensure that the substreams used by different processes do not overlap, thereby providing a practical guarantee of their statistical independence.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the LCG skip-ahead problem by implementing the algorithm derived from\n    first principles and running the specified test cases.\n    \"\"\"\n    # Parameters of the LCG from the problem statement\n    m = 2**48\n    a = 25214903917\n    c = 11\n    # For m=2**k, modulo can be done with a bitwise AND, which is faster.\n    mask = m - 1\n\n    def power_map(t: int, a_base: int, c_base: int, mod_mask: int):\n        \"\"\"\n        Computes the coefficients (A_t, C_t) of the composed affine map f^t,\n        where f^t(x) = (A_t * x + C_t) mod m, using binary exponentiation.\n\n        The composition of g(x)=a1*x+c1 and h(x)=a2*x+c2 is g(h(x)) = (a1*a2)*x + (a1*c2+c1).\n        The corresponding operation on coefficient pairs is (a1, c1) o (a2, c2) -> (a1*a2, a1*c2+c1).\n        \"\"\"\n        if t == 0:\n            # Identity map: x -> 1*x + 0\n            return 1, 0\n\n        # Accumulator for the final map, initialized to identity.\n        final_a, final_c = 1, 0\n\n        # Current power of the base map, starts with f^1 = (a, c).\n        current_a, current_c = a_base, c_base\n        \n        power = t\n        while power > 0:\n            if power % 2 == 1:\n                # Accumulate this power: final_map - current_map o final_map\n                final_a, final_c = (\n                    (current_a * final_a)  mod_mask,\n                    (current_a * final_c + current_c)  mod_mask\n                )\n\n            # Square the current power map: current_map - current_map o current_map\n            current_a, current_c = (\n                (current_a * current_a)  mod_mask,\n                (current_a * current_c + current_c)  mod_mask\n            )\n            \n            power //= 2\n        \n        return final_a, final_c\n\n    def skip_ahead(x_n: int, t: int):\n        \"\"\"\n        Computes x_{n+t} from x_n by finding the composed map f^t and applying it.\n        \"\"\"\n        if t == 0:\n            return x_n\n        \n        A_t, C_t = power_map(t, a, c, mask)\n        return (A_t * x_n + C_t)  mask\n    \n    def lcg_step(x: int):\n        \"\"\"Performs a single step of the LCG.\"\"\"\n        return (a * x + c)  mask\n\n    results = []\n\n    # Test 1: correctness against naive iteration\n    x_n_1, t_1 = 42, 1000\n    res_skip_1 = skip_ahead(x_n_1, t_1)\n    res_iter_1 = x_n_1\n    for _ in range(t_1):\n        res_iter_1 = lcg_step(res_iter_1)\n    results.append(res_skip_1 == res_iter_1)\n\n    # Test 2: identity boundary (t=0)\n    x_n_2, t_2 = 1234567890123, 0\n    res_2 = skip_ahead(x_n_2, t_2)\n    results.append(res_2)\n\n    # Test 3: single-step boundary (t=1)\n    x_n_3, t_3 = 1, 1\n    res_3 = skip_ahead(x_n_3, t_3)\n    results.append(res_3)\n\n    # Test 4: large skip from zero\n    x_n_4, t_4 = 0, 10**12\n    res_4 = skip_ahead(x_n_4, t_4)\n    results.append(res_4)\n\n    # Test 5: empirical substream independence in a window\n    S_5 = 10**12\n    L_5 = 1000\n    x0_5 = 1234567890123\n    \n    # Generate first substream\n    stream1 = []\n    current_x1 = x0_5\n    for _ in range(L_5):\n        stream1.append(current_x1)\n        current_x1 = lcg_step(current_x1)\n        \n    # Find start of second substream and generate it\n    x0_prime_5 = skip_ahead(x0_5, S_5)\n    stream2 = []\n    current_x2 = x0_prime_5\n    for _ in range(L_5):\n        stream2.append(current_x2)\n        current_x2 = lcg_step(current_x2)\n\n    # Check for disjointness using sets for efficiency\n    set1 = set(stream1)\n    set2 = set(stream2)\n    results.append(set1.isdisjoint(set2))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3338260"}, {"introduction": "After learning a correct method for creating streams, it is equally important to understand why seemingly plausible shortcuts can fail. This exercise shifts our focus from implementation to theoretical analysis, asking you to diagnose a critical flaw in a common but misguided parallelization strategy. By examining a Permuted Congruential Generator (PCG) where streams are distinguished only by their additive constant, you will use modular arithmetic to prove that this approach creates a catastrophic deterministic correlation between the least significant bits of the supposedly independent streams, highlighting the importance of rigorous analysis [@problem_id:3338270].", "problem": "Consider a family of random number generator streams defined by the Permuted Congruential Generator (PCG), where each stream has its own increment. The internal state for stream $i$ evolves as an affine Linear Congruential Generator (LCG) over the ring of integers modulo $2^{64}$:\n$$\nx^{(i)}_{n+1} \\equiv a\\,x^{(i)}_{n} + c_i \\pmod{2^{64}},\n$$\nwhere $a$ is a fixed odd multiplier and $c_i$ is a fixed per-stream increment. The output permutation used by PCG is a bijection on $64$-bit words; for the purposes of this problem, focus on the statistical properties of the internal state itself, in particular its lowest-order bits. Assume initial states $x^{(i)}_0$ are chosen independently and uniformly from $\\{0,1,\\dots,2^{64}-1\\}$ for each stream $i$.\n\nPart A: Using the ring structure modulo powers of $2$, analyze the evolution of the least significant bit (LSB) $b^{(i)}_n := x^{(i)}_n \\bmod 2$ for arbitrary streams $i$ and $j$. Derive conditions on the increments $c_i$ and $c_j$ under which the LSB processes of distinct streams, $b^{(i)}_n$ and $b^{(j)}_n$, avoid deterministic coupling over time. Your analysis must start from the definition of the recurrence modulo $2$ and reason from first principles about how parity evolves. State clearly whether full-period requirements for each stream (with modulus $2^{64}$) are compatible with your LSB independence conditions.\n\nPart B (counterexample and calculation): Consider a practitioner who mistakenly sets one stream’s increment to be even. Specifically, take stream $j$ with $c_j \\equiv 0 \\pmod{2}$, while maintaining the standard full-period conditions for other streams. For stream $j$, define the empirical mean of its LSB over its LSB-period as\n$$\n\\hat{\\mu}_{\\text{LSB}} := \\frac{1}{N}\\sum_{n=0}^{N-1} b^{(j)}_n,\n$$\nwhere $N$ is the length of the LSB cycle that results from the recurrence for $b^{(j)}_n$. Compute the magnitude of the bias\n$$\n\\left|\\hat{\\mu}_{\\text{LSB}} - \\frac{1}{2}\\right|\n$$\nthat this poor choice of $c_j$ induces. Your final answer must be a single real number. No rounding is required.", "solution": "The problem is divided into two parts. Part A requires an analysis of the least significant bit (LSB) of the generator's internal state to derive conditions for stream independence and to check compatibility with full-period requirements. Part B requires the calculation of a specific statistical bias resulting from a poor choice of generator parameters.\n\nPart A: LSB Analysis and Stream Independence\n\nThe internal state of stream $i$ is governed by the recurrence relation:\n$$\nx^{(i)}_{n+1} \\equiv a\\,x^{(i)}_{n} + c_i \\pmod{2^{64}}\n$$\nwhere $a$ is a fixed odd multiplier and $c_i$ is the per-stream increment.\n\nTo analyze the least significant bit (LSB), we consider this recurrence modulo $2$. The LSB of $x^{(i)}_n$ is defined as $b^{(i)}_n := x^{(i)}_n \\bmod 2$. Taking the recurrence modulo $2$ yields:\n$$\nx^{(i)}_{n+1} \\bmod 2 \\equiv (a\\,x^{(i)}_{n} + c_i) \\bmod 2\n$$\nUsing the properties of modular arithmetic, this becomes:\n$$\nb^{(i)}_{n+1} \\equiv ( (a \\bmod 2) \\cdot (x^{(i)}_{n} \\bmod 2) + (c_i \\bmod 2) ) \\pmod 2\n$$\n$$\nb^{(i)}_{n+1} \\equiv ( (a \\bmod 2) \\cdot b^{(i)}_n + (c_i \\bmod 2) ) \\pmod 2\n$$\nThe problem states that the multiplier $a$ is odd, which means $a \\equiv 1 \\pmod 2$. Substituting this into the LSB recurrence gives:\n$$\nb^{(i)}_{n+1} \\equiv b^{(i)}_n + (c_i \\bmod 2) \\pmod 2\n$$\nThis is a simple first-order linear recurrence for the LSB sequence. Let $C_i = c_i \\bmod 2$. The LSB sequence is then given by unrolling the recurrence:\n$$\nb^{(i)}_n \\equiv b^{(i)}_0 + n \\cdot C_i \\pmod 2\n$$\nThis equation reveals the entire structure of the LSB sequence. If $C_i = 0$ (i.e., $c_i$ is even), the recurrence is $b^{(i)}_{n+1} \\equiv b^{(i)}_n \\pmod 2$, meaning the LSB is constant for all $n$. If $C_i = 1$ (i.e., $c_i$ is odd), the recurrence is $b^{(i)}_{n+1} \\equiv b^{(i)}_n + 1 \\pmod 2$, meaning the LSB flips at every step, producing an alternating sequence of period $2$.\n\nNow, consider two distinct streams, $i$ and $j$. Their LSB sequences are:\n$$\nb^{(i)}_n \\equiv b^{(i)}_0 + n \\cdot (c_i \\bmod 2) \\pmod 2\n$$\n$$\nb^{(j)}_n \\equiv b^{(j)}_0 + n \\cdot (c_j \\bmod 2) \\pmod 2\n$$\nDeterministic coupling occurs if there is a simple, fixed relationship between $b^{(i)}_n$ and $b^{(j)}_n$ that does not depend on $n$ in a complex way. Let's examine the exclusive-or (XOR) of the two sequences, which is equivalent to their sum modulo $2$:\n$$\nb^{(i)}_n \\oplus b^{(j)}_n \\equiv b^{(i)}_n + b^{(j)}_n \\pmod 2\n$$\n$$\nb^{(i)}_n + b^{(j)}_n \\equiv (b^{(i)}_0 + n(c_i \\bmod 2)) + (b^{(j)}_0 + n(c_j \\bmod 2)) \\pmod 2\n$$\n$$\nb^{(i)}_n + b^{(j)}_n \\equiv (b^{(i)}_0 + b^{(j)}_0) + n((c_i \\bmod 2) + (c_j \\bmod 2)) \\pmod 2\n$$\nIf the increments have the same parity, $c_i \\equiv c_j \\pmod 2$, then $(c_i \\bmod 2) = (c_j \\bmod 2)$.\nLet $C = c_i \\bmod 2 = c_j \\bmod 2$. Then $(c_i \\bmod 2) + (c_j \\bmod 2) = C+C = 2C \\equiv 0 \\pmod 2$.\nIn this case, the relationship simplifies to:\n$$\nb^{(i)}_n + b^{(j)}_n \\equiv b^{(i)}_0 + b^{(j)}_0 \\pmod 2\n$$\nThis means $b^{(i)}_n \\oplus b^{(j)}_n = b^{(i)}_0 \\oplus b^{(j)}_0$, which is a constant for all $n$. The two LSB sequences are perfectly correlated (or anti-correlated). For instance, if $b^{(i)}_0 = b^{(j)}_0$, then $b^{(i)}_n = b^{(j)}_n$ for all $n$. This is a severe deterministic coupling that is highly undesirable for independent random number streams.\n\nTo avoid this deterministic coupling, the coefficient of $n$ in the expression for $b^{(i)}_n + b^{(j)}_n$ must be non-zero. This requires:\n$$\n(c_i \\bmod 2) + (c_j \\bmod 2) \\not\\equiv 0 \\pmod 2\n$$\nThis is equivalent to $(c_i \\bmod 2) \\neq (c_j \\bmod 2)$. That is, the increments $c_i$ and $c_j$ must have different parity.\n\nNext, we assess the compatibility of this condition with the requirement for each stream to have a full period. For a Linear Congruential Generator of the form $x_{n+1} \\equiv ax_n+c \\pmod{2^k}$ with $k \\ge 2$, a full period of $2^k$ is achieved if and only if two conditions are met (Theorem A, Section 3.2.1.2 of Knuth's TAOCP, Vol 2):\n1. The increment $c$ is odd.\n2. The multiplier $a$ satisfies $a \\equiv 1 \\pmod 4$.\n\nFor our generator with modulus $2^{64}$, the full-period requirement for stream $i$ dictates that its increment $c_i$ must be odd, i.e., $c_i \\equiv 1 \\pmod 2$. For stream $j$ to also have a full period, its increment $c_j$ must also be odd, $c_j \\equiv 1 \\pmod 2$.\nThis implies $c_i \\equiv c_j \\pmod 2$.\n\nTherefore, the condition for avoiding LSB coupling ($c_i \\not\\equiv c_j \\pmod 2$) is fundamentally incompatible with the condition that both streams achieve the maximum possible period ($c_i \\equiv 1 \\pmod 2$ and $c_j \\equiv 1 \\pmod 2$). This reveals a critical weakness in creating multiple streams by only varying the LCG increment.\n\nPart B: Bias Calculation\n\nIn this part, we consider a stream $j$ where the practitioner has mistakenly chosen an even increment, $c_j \\equiv 0 \\pmod 2$. The LSB recurrence for this stream is:\n$$\nb^{(j)}_{n+1} \\equiv b^{(j)}_n + (c_j \\bmod 2) \\pmod 2 \\implies b^{(j)}_{n+1} \\equiv b^{(j)}_n \\pmod 2\n$$\nThis recurrence implies that the LSB sequence is constant: $b^{(j)}_n = b^{(j)}_0$ for all $n \\ge 0$. The sequence is either $0, 0, 0, \\dots$ or $1, 1, 1, \\dots$, depending on the LSB of the initial state $x^{(j)}_0$.\n\nThe problem defines $N$ as the length of the LSB cycle. For a constant sequence, the cycle length is $N=1$. The empirical mean of the LSB over this period is:\n$$\n\\hat{\\mu}_{\\text{LSB}} = \\frac{1}{N}\\sum_{n=0}^{N-1} b^{(j)}_n = \\frac{1}{1} \\sum_{n=0}^{0} b^{(j)}_n = b^{(j)}_0\n$$\nSo the empirical mean is simply the initial LSB, $b^{(j)}_0$.\n\nThe initial state $x^{(j)}_0$ is chosen uniformly from $\\{0, 1, \\dots, 2^{64}-1\\}$. This set contains $2^{63}$ even numbers and $2^{63}$ odd numbers. Therefore, the LSB $b^{(j)}_0 = x^{(j)}_0 \\bmod 2$ is $0$ with probability $1/2$ and $1$ with probability $1/2$.\n\nThe ideal mean for a sequence of unbiased random bits is $1/2$. The bias is the deviation of the empirical mean from this ideal value. We are asked to compute the magnitude of this bias:\n$$\n\\left|\\hat{\\mu}_{\\text{LSB}} - \\frac{1}{2}\\right|\n$$\nWe must evaluate this for the two possible outcomes of $\\hat{\\mu}_{\\text{LSB}}$:\n\\begin{enumerate}\n    \\item If $x^{(j)}_0$ is even, then $b^{(j)}_0=0$, and $\\hat{\\mu}_{\\text{LSB}} = 0$. The magnitude of the bias is $\\left|0 - \\frac{1}{2}\\right| = \\frac{1}{2}$.\n    \\item If $x^{(j)}_0$ is odd, then $b^{(j)}_0=1$, and $\\hat{\\mu}_{\\text{LSB}} = 1$. The magnitude of the bias is $\\left|1 - \\frac{1}{2}\\right| = \\frac{1}{2}$.\n\\end{enumerate}\nIn both cases, the magnitude of the bias induced by the poor choice of an even increment $c_j$ is exactly $\\frac{1}{2}$. This represents a catastrophic failure of the generator's LSB sequence, which is fixed at a single value instead of seeming random. The resulting empirical mean is maximally biased, being as far as possible from the ideal mean of $1/2$ for a binary value.", "answer": "$$\\boxed{\\frac{1}{2}}$$", "id": "3338270"}, {"introduction": "While analytical methods are powerful for simple generators, the internal complexity of modern generators like the Mersenne Twister makes theoretical proofs of stream independence intractable. In these cases, we must rely on sophisticated empirical testing to validate our parallelization schemes. This practice guides you through implementing a multidimensional spectral test to detect subtle, large-scale correlations between streams created by naively spacing their initial seeds, demonstrating a powerful technique for ensuring simulation quality when direct analysis is not feasible [@problem_id:3338282].", "problem": "Consider parallel streams produced by the Mersenne Twister variant with period $2^{19937}-1$ (commonly referred to as MT19937). For each integer seed $s_i = s_0 + i\\Delta$, define stream $i$ as a sequence $\\{U_t^{(i)}\\}_{t \\ge 1}$ of independent realizations from the Uniform distribution on the unit interval $\\mathsf{Uniform}(0,1)$ obtained by initializing MT19937 with seed $s_i$. The goal is to assess whether pairs of streams $(i,j)$ are independent by testing the two-dimensional sequence $\\{(U_t^{(i)}, U_t^{(j)})\\}_{t=1}^T$ for joint uniformity on the unit square.\n\nYou must implement a multidimensional spectral test that operates as follows:\n\n1. Partition the unit square into an $m \\times m$ grid of congruent bins. Map each pair $(U_t^{(i)}, U_t^{(j)})$ to its bin indices $(a_t, b_t)$, where $a_t = \\lfloor m U_t^{(i)} \\rfloor$ and $b_t = \\lfloor m U_t^{(j)} \\rfloor$, for $t = 1, \\ldots, T$.\n\n2. Form the centered occupancy field by subtracting the expected uniform bin count from each cell. Compute the two-dimensional discrete Fourier transform (DFT) of this centered field. Exclude the $(0,0)$ (zero-frequency) component. Construct a fixed low-frequency set $L \\subset \\{0,1,\\ldots,m-1\\}^2 \\setminus \\{(0,0)\\}$ with small indices that probe large-scale alignment.\n\n3. Aggregate the energy of the selected low-frequency components to obtain a test statistic that, under the hypothesis that $\\{(U_t^{(i)}, U_t^{(j)})\\}$ are independent and identically distributed $\\mathsf{Uniform}([0,1]^2)$, converges in distribution to a chi-square random variable with $2|L|$ degrees of freedom. Use this asymptotic distribution to compute a $p$-value and decide whether to reject independence at a prescribed significance level.\n\nThe only foundational facts you may use in your derivation and algorithmic design are:\n- The definition of independence and the Uniform distribution on the unit interval.\n- The discrete Fourier transform and its orthogonality properties on finite grids.\n- The Multivariate Central Limit Theorem for sums of independent and identically distributed random variables.\n\nThe program must implement the spectral test entirely from first principles, without invoking any special-purpose random number test libraries. Use the NumPy implementation of MT19937 via its modern random number generation interface to construct streams, and SciPy only for evaluating the chi-square survival function.\n\nAdopt the following fixed parameters for the spectral test:\n- Grid size $m = 16$.\n- Low-frequency set $L = \\{(k,\\ell) : k \\in \\{0,1,2\\},\\, \\ell \\in \\{0,1,2\\}\\} \\setminus \\{(0,0)\\}$.\n- Significance level $\\alpha = 10^{-3}$.\n\nDefine the base seed and spacing as $s_0 = 987654321$ and $\\Delta = 65537$. Construct streams using $s_i = s_0 + i\\Delta$.\n\nTo exercise the test and evaluate detection performance across different scenarios, implement the following test suite of parameter sets. For each case, generate the pair $\\{(U_t^{(i)}, U_t^{(j)})\\}_{t=1}^T$ according to the specified mode, then apply the spectral test and report whether dependence is detected (reject independence):\n\n- Case 1 (general independent case): $i=1$, $j=17$, $T=100000$, mode = independent, meaning $U_t^{(i)}$ and $U_t^{(j)}$ are generated from two separate MT19937 instances initialized with seeds $s_i$ and $s_j$, respectively.\n- Case 2 (strong alignment edge case): $i=5$, $j=5$, $T=30000$, mode = identical, meaning $U_t^{(j)} \\equiv U_t^{(i)}$ for all $t$ (this simulates a pathological stream cloning).\n- Case 3 (subtle alignment scenario): $i=9$, $j=10$, $T=80000$, mode = shifted, meaning $U_t^{(j)} = (U_t^{(i)} + 1/m) \\bmod 1$ for all $t$ (this simulates a low-bit alignment bug in parallelization that shifts one stream by a constant fractional offset).\n- Case 4 (small-sample boundary): $i=2$, $j=3$, $T=512$, mode = independent, as in Case 1.\n\nOutput specification:\n- For each case, output a boolean indicating whether dependence was detected (true if the spectral test rejects independence at level $\\alpha$, false otherwise).\n- Your program should produce a single line of output containing the four booleans corresponding to Cases 1–4 in order, as a comma-separated list enclosed in square brackets, for example, \"[true,false,true,false]\". Use Python boolean literals \"True\" and \"False\" in the output.\n\nNo physical units apply to this task. Angles arising in the DFT are in radians by the mathematical definition of the transform. The final outputs are booleans, not percentages.\n\nYour implementation must be a complete, runnable program that constructs the specified streams, applies the spectral test derived from first principles and the Multivariate Central Limit Theorem, and prints the required output format.", "solution": "The problem requires the implementation of a multidimensional spectral test to assess the independence of pairs of pseudo-random number streams. The design and implementation of this test are derived from first principles, namely the properties of the uniform distribution, the Discrete Fourier Transform (DFT), and the Multivariate Central Limit Theorem (CLT).\n\nLet the two streams be denoted by $\\{U_t^{(i)}\\}_{t=1}^T$ and $\\{U_t^{(j)}\\}_{t=1}^T$. The null hypothesis, $H_0$, posits that the pairs $\\{(U_t^{(i)}, U_t^{(j)})\\}_{t=1}^T$ are a sequence of $T$ independent and identically distributed (i.i.d.) random draws from the uniform distribution on the unit square, $\\mathsf{Uniform}([0,1]^2)$.\n\n1.  **Binning and Occupancy Field**\n\nThe first step is to discretize the continuous sample space. The unit square $[0,1]^2$ is partitioned into a uniform grid of $m \\times m$ disjoint square bins. For each pair of random variates $(U_t^{(i)}, U_t^{(j)})$, we identify its corresponding bin indices $(a_t, b_t)$ as:\n$$\na_t = \\lfloor m U_t^{(i)} \\rfloor, \\quad b_t = \\lfloor m U_t^{(j)} \\rfloor\n$$\nwhere $a_t, b_t \\in \\{0, 1, \\ldots, m-1\\}$.\n\nUnder $H_0$, the probability of any single point falling into a specific bin $(a,b)$ is $p_{a,b} = 1/m^2$. Let $N_{a,b}$ be the number of points from the sample of size $T$ that fall into bin $(a,b)$. The expected count for any bin is:\n$$\nE[N_{a,b}] = T \\cdot p_{a,b} = \\frac{T}{m^2}\n$$\nWe form the centered occupancy field, $X_{a,b}$, by subtracting the expected count from the observed count in each bin:\n$$\nX_{a,b} = N_{a,b} - \\frac{T}{m^2}\n$$\nThe sum of all elements in this field is zero: $\\sum_{a=0}^{m-1} \\sum_{b=0}^{m-1} X_{a,b} = T - m^2(T/m^2) = 0$.\n\n2.  **Discrete Fourier Transform**\n\nThe spectral test analyzes the periodicities in the occupancy counts by examining the Fourier transform of the centered field. The two-dimensional DFT of $X_{a,b}$ is defined as:\n$$\n\\hat{X}_{k,\\ell} = \\sum_{a=0}^{m-1} \\sum_{b=0}^{m-1} X_{a,b} \\exp\\left(-2\\pi \\mathrm{i} \\left(\\frac{ak}{m} + \\frac{b\\ell}{m}\\right)\\right)\n$$\nfor frequency indices $k, \\ell \\in \\{0, 1, \\ldots, m-1\\}$, where $\\mathrm{i}$ is the imaginary unit. The zero-frequency component, $\\hat{X}_{0,0} = \\sum_{a,b} X_{a,b}$, is identically zero and is thus excluded from the analysis.\n\n3.  **Asymptotic Distribution via Central Limit Theorem**\n\nTo derive the test statistic, we analyze the statistical properties of the DFT coefficients $\\hat{X}_{k,\\ell}$ under $H_0$. We can express $\\hat{X}_{k,\\ell}$ as a sum over the $T$ sample points. For $(k,\\ell) \\neq (0,0)$:\n$$\n\\hat{X}_{k,\\ell} = \\sum_{a,b} \\left( \\sum_{t=1}^T \\mathbb{I}((a,b) = (a_t,b_t)) - \\frac{T}{m^2} \\right) \\omega_{a,b}^{k,\\ell} = \\sum_{t=1}^T \\omega_{a_t, b_t}^{k,\\ell}\n$$\nwhere $\\omega_{a,b}^{k,\\ell} = \\exp\\left(-2\\pi \\mathrm{i} \\left(\\frac{ak}{m} + \\frac{b\\ell}{m}\\right)\\right)$, and $\\mathbb{I}(\\cdot)$ is the indicator function. The simplification arises because the sum involving $T/m^2$ vanishes for non-zero frequencies due to the orthogonality of the complex exponentials.\n\nLet $Z_t^{k,\\ell} = \\omega_{a_t, b_t}^{k,\\ell}$. Then $\\hat{X}_{k,\\ell} = \\sum_{t=1}^T Z_t^{k,\\ell}$. Under $H_0$, the $\\{Z_t^{k,\\ell}\\}_{t=1}^T$ are i.i.d. complex random variables. Their expectation is $E[Z_t^{k,\\ell}] = \\sum_{a,b} (1/m^2) \\omega_{a,b}^{k,\\ell} = 0$ for $(k,\\ell) \\neq (0,0)$.\n\nBy the Multivariate CLT, the vector of normalized DFT coefficients $(\\ldots, \\frac{1}{\\sqrt{T}}\\hat{X}_{k,\\ell}, \\ldots)$ converges in distribution to a multivariate complex normal distribution. The real and imaginary parts of $\\frac{1}{\\sqrt{T}}\\hat{X}_{k,\\ell}$ are asymptotically independent normal random variables. Specifically, for frequencies $(k,\\ell)$ such that $(2k, 2\\ell) \\not\\equiv (0,0) \\pmod m$, one can show that $Var(\\text{Re}(Z_t^{k,\\ell})) = Var(\\text{Im}(Z_t^{k,\\ell})) = 1/2$ and their covariance is $0$.\nThis implies that for large $T$:\n$$\n\\frac{\\sqrt{2}}{\\sqrt{T}} \\text{Re}(\\hat{X}_{k,\\ell}) \\sim \\mathcal{N}(0,1) \\quad \\text{and} \\quad \\frac{\\sqrt{2}}{\\sqrt{T}} \\text{Im}(\\hat{X}_{k,\\ell}) \\sim \\mathcal{N}(0,1)\n$$\nwhere $\\mathcal{N}(0,1)$ is the standard normal distribution.\n\n4.  **Test Statistic and Hypothesis Test**\n\nThe sum of the squares of these two independent standard normal variables follows a chi-square distribution with $2$ degrees of freedom ($\\chi^2_2$). This quantity is:\n$$\n\\left(\\frac{\\sqrt{2}}{\\sqrt{T}} \\text{Re}(\\hat{X}_{k,\\ell})\\right)^2 + \\left(\\frac{\\sqrt{2}}{\\sqrt{T}} \\text{Im}(\\hat{X}_{k,\\ell})\\right)^2 = \\frac{2}{T} |\\hat{X}_{k,\\ell}|^2 \\sim \\chi^2_2\n$$\nThe test statistic, $S$, is constructed by summing these contributions over a predefined set $L$ of low-frequency modes, which are sensitive to large-scale correlations.\n$$\nS = \\sum_{(k,\\ell) \\in L} \\frac{2}{T} |\\hat{X}_{k,\\ell}|^2\n$$\nThe DFT coefficients for distinct non-conjugate frequencies are asymptotically independent. The specified set $L = \\{(k,\\ell) : k, \\ell \\in \\{0,1,2\\}\\} \\setminus \\{(0,0)\\}$ with $m=16$ contains $|L| = 8$ frequency pairs, none of which are special (e.g., aliased with their conjugate). Thus, by the additive property of the chi-square distribution, $S$ converges in distribution to a chi-square random variable with $d = 2|L| = 16$ degrees of freedom.\n$$\nS \\xrightarrow{d} \\chi^2_{16}\n$$\nTo make a decision, we compute the observed value of the statistic, $S_{obs}$, and calculate the associated $p$-value. The $p$-value is the probability of observing a statistic at least as large as $S_{obs}$ if $H_0$ were true:\n$$\np\\text{-value} = P(\\chi^2_{16} \\ge S_{obs})\n$$\nThis is computed using the survival function of the chi-square distribution. The null hypothesis of independence is rejected if the $p$-value is less than the prescribed significance level, $\\alpha = 10^{-3}$.\n\nThe algorithm proceeds by generating the random variates for each case, performing the binning, computing the centered field, applying the DFT, calculating the statistic $S$ for the given set $L$, and finally determining the $p$-value to decide whether to reject $H_0$.", "answer": "```python\nimport numpy as np\nfrom scipy.stats import chi2\n\ndef run_spectral_test(stream1, stream2, T, m, L, alpha):\n    \"\"\"\n    Performs a 2D spectral test on a pair of random number streams.\n\n    Args:\n        stream1 (np.ndarray): The first stream of uniform random numbers.\n        stream2 (np.ndarray): The second stream of uniform random numbers.\n        T (int): The number of points in each stream.\n        m (int): The grid size for binning (m x m).\n        L (set): A set of (k, l) frequency tuples to include in the test.\n        alpha (float): The significance level for the hypothesis test.\n\n    Returns:\n        bool: True if dependence is detected (H0 is rejected), False otherwise.\n    \"\"\"\n    # Step 1: Binning\n    # Create an m x m grid and count the occurrences in each bin.\n    counts = np.zeros((m, m), dtype=np.int32)\n    \n    # Vectorized computation of bin indices for all T points.\n    indices_a = np.floor(m * stream1).astype(int)\n    indices_b = np.floor(m * stream2).astype(int)\n    \n    # Clip to handle the edge case where a uniform variate is exactly 1.0.\n    indices_a = np.clip(indices_a, 0, m - 1)\n    indices_b = np.clip(indices_b, 0, m - 1)\n    \n    # Efficiently increment counts for all points.\n    np.add.at(counts, (indices_a, indices_b), 1)\n\n    # Step 2: Centered Occupancy Field and Discrete Fourier Transform\n    # Subtract the expected count under the null hypothesis of uniformity.\n    expected_count = T / (m * m)\n    centered_counts = counts - expected_count\n    \n    # Compute the 2D DFT of the centered field.\n    dft_coeffs = np.fft.fft2(centered_counts)\n\n    # Step 3: Test Statistic Calculation\n    # Aggregate the energy from the selected low-frequency components.\n    energy_sum = 0.0\n    for k, l in L:\n        coeff = dft_coeffs[k, l]\n        energy_sum += np.abs(coeff)**2\n    \n    # Normalize to form the chi-square statistic.\n    statistic_S = (2.0 / T) * energy_sum\n\n    # Step 4: p-value Calculation and Decision\n    # The degrees of freedom is 2 for each complex frequency pair.\n    dof = 2 * len(L)\n    \n    # Compute the p-value using the survival function (1 - CDF) of the chi-square distribution.\n    p_value = chi2.sf(statistic_S, df=dof)\n    \n    # Reject the null hypothesis if the p-value is below the significance level.\n    return p_value  alpha\n\ndef solve():\n    \"\"\"\n    Main function to run the specified test suite and print results.\n    \"\"\"\n    # Fixed parameters for the spectral test from the problem statement.\n    m = 16\n    L_set = {(k, l) for k in range(3) for l in range(3)} - {(0, 0)}\n    alpha = 1e-3\n    s0 = 987654321\n    delta = 65537\n\n    # Define the four test cases.\n    test_cases = [\n        {'id': 1, 'i': 1, 'j': 17, 'T': 100000, 'mode': 'independent'},\n        {'id': 2, 'i': 5, 'j': 5, 'T': 30000, 'mode': 'identical'},\n        {'id': 3, 'i': 9, 'j': 10, 'T': 80000, 'mode': 'shifted'},\n        {'id': 4, 'i': 2, 'j': 3, 'T': 512, 'mode': 'independent'},\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        i, j, T, mode = case['i'], case['j'], case['T'], case['mode']\n        \n        # Initialize random number generators with specified seeds.\n        seed_i = s0 + i * delta\n        rng_i = np.random.Generator(np.random.MT19937(seed_i))\n        \n        # Generate stream(s) based on the test case mode.\n        stream_i = rng_i.uniform(size=T)\n        \n        if mode == 'independent':\n            seed_j = s0 + j * delta\n            rng_j = np.random.Generator(np.random.MT19937(seed_j))\n            stream_j = rng_j.uniform(size=T)\n        elif mode == 'identical':\n            # Pathological case: streams are identical.\n            stream_j = stream_i\n        elif mode == 'shifted':\n            # Pathological case: one stream is a shifted version of the other.\n            stream_j = (stream_i + 1.0 / m) % 1.0\n        else:\n            # This path should not be reached with the given test cases.\n            raise ValueError(f\"Unknown mode specified: {mode}\")\n            \n        # Run the test and store the boolean result.\n        is_dependent = run_spectral_test(stream_i, stream_j, T, m, L_set, alpha)\n        results.append(is_dependent)\n    \n    # Print the final results in the specified format.\n    # The map(str, ...) correctly converts Python booleans to \"True\" and \"False\".\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3338282"}]}