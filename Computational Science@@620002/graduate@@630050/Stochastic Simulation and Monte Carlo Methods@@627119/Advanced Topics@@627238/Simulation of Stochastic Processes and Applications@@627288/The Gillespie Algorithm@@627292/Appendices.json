{"hands_on_practices": [{"introduction": "This first exercise brings us back to the fundamental principles of the Stochastic Simulation Algorithm (SSA). Before tackling complex networks, it is crucial to understand precisely how the algorithm determines *when* the next reaction will occur and *which* reaction it will be. By analyzing a simple reversible reaction from a specific initial state, this problem guides you through deriving the waiting time distribution for the very first event, reinforcing the connection between reaction propensities and the exponential waiting times that govern the process [@problem_id:3353349].", "problem": "Consider a well-stirred, thermally equilibrated system with two chemical species, $A$ and $B$, undergoing the reversible network $A \\xrightarrow{c_1} B$ and $B \\xrightarrow{c_2} A$ under the standard assumptions of a continuous-time Markov jump process governed by mass-action kinetics. Let the initial molecular counts be $(x_A,x_B)=(1,0)$ and the reaction rate constants be $c_1>0$ and $c_2>0$. The Stochastic Simulation Algorithm (SSA), specifically the First Reaction Method (FRM), conceptualizes the next reaction event by associating to each reaction channel a waiting time that is driven by the corresponding hazard (propensity) evaluated at the current state. \n\nStarting from the foundational principles that, for a continuous-time Markov jump process with piecewise-constant hazard rates, (i) the instantaneous hazard for a reaction channel equals its propensity at the current state, and (ii) the waiting time to the next event is generated by these hazards, construct the conceptual FRM for this network at the given initial condition. Based strictly on these principles, derive the probability density function $p(t)$ of the time $t \\geq 0$ to the first reaction event, and determine (in words, not as part of the final numerical expression) which reaction channel is selected as the first event at this initial state. \n\nProvide the final $p(t)$ as a single closed-form analytic expression in terms of $c_1$, $c_2$, and $t$. No intermediate formulas should be given in the final answer. No numerical evaluation is required. Express your answer without units.", "solution": "The problem statement is subjected to validation prior to any attempt at a solution.\n\n**Step 1: Extracted Givens**\n- System: A well-stirred, thermally equilibrated system with two chemical species, $A$ and $B$.\n- Reaction network: $A \\xrightarrow{c_1} B$ (Reaction $R_1$) and $B \\xrightarrow{c_2} A$ (Reaction $R_2$).\n- Model: Continuous-time Markov jump process governed by mass-action kinetics.\n- Initial condition: Molecular counts at time $t=0$ are $(x_A, x_B) = (1, 0)$.\n- Rate constants: $c_1 > 0$ and $c_2 > 0$.\n- Algorithmic context: Stochastic Simulation Algorithm (SSA), specifically the First Reaction Method (FRM).\n- Foundational principles: (i) The instantaneous hazard for a reaction channel equals its propensity at the current state. (ii) The waiting time to the next event is generated by these hazards.\n- Required outputs:\n    1. The probability density function $p(t)$ for the time $t \\geq 0$ to the first reaction event.\n    2. A determination, in words, of which reaction channel is selected as the first event.\n\n**Step 2: Validation**\nThe problem is scientifically grounded, well-posed, and objective. It describes a standard, fundamental scenario in stochastic chemical kinetics. The assumptions (Markov process, mass-action kinetics) are standard in the field. The initial conditions and parameters are clearly specified and consistent, allowing for a unique and meaningful solution. The problem is free of scientific flaws, ambiguity, or missing information.\n\n**Step 3: Verdict**\nThe problem is valid. A solution will be constructed.\n\n**Derivation**\n\nThe state of the system at any time $t$ is given by the vector of molecular counts $\\mathbf{X}(t) = (x_A(t), x_B(t))$. The initial state is specified as $\\mathbf{X}(0) = (1, 0)$. The system evolves through two possible reaction channels:\n$R_1: A \\xrightarrow{c_1} B$\n$R_2: B \\xrightarrow{c_2} A$\n\nAccording to the principles of mass-action kinetics, the propensity function, or instantaneous hazard, $a_j(\\mathbf{x})$ for a reaction channel $R_j$ is proportional to the number of distinct combinations of reactant molecules in the state $\\mathbf{x}$. For the given first-order reactions, the propensities are:\n- For $R_1$: $a_1(\\mathbf{x}) = c_1 x_A$\n- For $R_2$: $a_2(\\mathbf{x}) = c_2 x_B$\n\nThe problem requires constructing the First Reaction Method (FRM) conceptualization starting from the initial state $\\mathbf{X}(0) = (1, 0)$. In the FRM, one associates a putative waiting time, $\\tau_j$, with each reaction channel $R_j$. This $\\tau_j$ is a random variable representing the time it would take for reaction $R_j$ to occur, were it the only possible reaction.\n\nBased on the foundational principle (ii), that waiting times are generated by the hazards, and the established theory of Poisson processes, the waiting time for an event with a constant hazard rate $\\lambda$ follows an exponential distribution with rate parameter $\\lambda$. Since the propensities are constant between reaction events in a continuous-time Markov jump process, we can apply this principle.\n\nFirst, we evaluate the propensities at the initial state $\\mathbf{x} = (1, 0)$:\n$a_1(\\mathbf{X}(0)) = c_1 \\cdot 1 = c_1$\n$a_2(\\mathbf{X}(0)) = c_2 \\cdot 0 = 0$\n\nThe hazard for reaction $R_1$ is $a_1 = c_1 > 0$. Therefore, we can generate a putative waiting time $\\tau_1$ for this reaction. $\\tau_1$ is a random variable drawn from an exponential distribution with rate parameter $c_1$. The probability density function (PDF) for $\\tau_1$ is $p_1(t) = c_1 \\exp(-c_1 t)$ for $t \\ge 0$.\n\nThe hazard for reaction $R_2$ is $a_2 = 0$. A hazard of zero implies that the probability of this event occurring in any finite time interval is zero. Consequently, the waiting time $\\tau_2$ for this reaction is infinite. There is no possibility for reaction $R_2$ to occur while the system is in the state $(1, 0)$.\n\nThe time to the *first* reaction event, which we denote as $t$, is the minimum of the putative waiting times for all possible reactions:\n$t = \\min(\\tau_1, \\tau_2)$\n\nGiven our calculated propensities, this becomes:\n$t = \\min(\\tau_1, \\infty) = \\tau_1$\n\nThis result directly implies two conclusions. First, the reaction channel selected as the first event is the one corresponding to the minimum waiting time. As $\\tau_1$ is finite and $\\tau_2$ is infinite, the first reaction to occur is unambiguously reaction channel $R_1: A \\xrightarrow{c_1} B$.\n\nSecond, the probability density function $p(t)$ of the time to this first reaction event must be identical to the PDF of $\\tau_1$. Since $\\tau_1$ is exponentially distributed with rate parameter $c_1$, the PDF for the time to the first reaction is:\n$p(t) = c_1 \\exp(-c_1 t)$ for $t \\ge 0$.\n\nThis expression for $p(t)$ is formulated in terms of the given parameters $c_1$ and $t$. The parameter $c_2$ does not appear, as the initial absence of species $B$ renders the reverse reaction impossible as the first event, making its rate constant irrelevant to the timing of the first event. This derivation adheres strictly to the foundational principles specified in the problem.", "answer": "$$\n\\boxed{c_1 \\exp(-c_1 t)}\n$$", "id": "3353349"}, {"introduction": "Moving from theory to practice, the heart of any SSA implementation is a robust function that calculates reaction propensities. This exercise challenges you to implement a general algorithm for computing propensities based on the fundamental principles of stochastic mass-action kinetics. By working through various reaction orders and reactant combinations, you will translate the combinatorial formula for reactant selections into code, a critical skill for building your own stochastic simulators [@problem_id:3353359].", "problem": "Consider a well-mixed, continuous-time Markov chain model of a chemical reaction network under stochastic mass-action kinetics, as used by the Stochastic Simulation Algorithm (SSA), also known as the Gillespie algorithm. Let there be $d$ species and $R$ reaction channels. A system state is the vector $X \\in \\mathbb{N}^d$, where $X_i$ is the copy number of species $i$. Each reaction channel $r$ is characterized by a nonnegative rate constant $c_r$ and a reactant stoichiometric vector $\\nu_r^- \\in \\mathbb{N}^d$ indicating the number of molecules of each species consumed when the reaction fires. The reaction order is the sum $\\sum_{i=1}^d \\nu_{r,i}^-$. Under stochastic mass-action kinetics, the instantaneous propensity $a_r(X)$ is the product of the intrinsic rate constant $c_r$ and the number of distinct unordered selections of reactant molecules that can be drawn from the current state $X$ consistent with the required multiplicities given by $\\nu_r^-$. If $X_i < \\nu_{r,i}^-$ for any species $i$, then $a_r(X)$ must be zero.\n\nTask. Design and implement a robust, general algorithm that, given an arbitrary nonnegative integer state vector $X \\in \\mathbb{N}^d$ and a list of reactions $\\{(c_r,\\nu_r^-)\\}_{r=1}^R$ with reaction orders ranging from $0$ to $3$ inclusive, returns all propensities $\\{a_r(X)\\}_{r=1}^R$ computed according to the above principle. Your algorithm must not special-case individual reaction patterns; it must correctly compute the number of reactant selections for all reaction orders $0$ through $3$ by reasoning from the counting principle described above. The algorithm must remain correct in edge cases such as zero-order reactions, insufficient copy numbers, and repeated identical reactants.\n\nImplementation constraints. The program must be self-contained and must not read any input. It must compute propensities for the following test suite. For each test case, species are indexed by position in the vectors. Each reaction is specified as a pair $(c_r,\\nu_r^-)$ where $\\nu_r^-$ is listed in the species order.\n\nTest case A:\n- Species count $d = 4$, state $X = [6,5,3,0]$.\n- Reactions (rate constant, reactant stoichiometric vector):\n  - $(0.75,[0,0,0,0])$\n  - $(0.1,[1,0,0,0])$\n  - $(0.02,[1,1,0,0])$\n  - $(0.03,[0,2,0,0])$\n  - $(0.001,[1,1,1,0])$\n  - $(0.004,[2,1,0,0])$\n  - $(0.005,[3,0,0,0])$\n  - $(0.07,[0,0,2,0])$\n  - $(1.0,[0,0,0,1])$\n  - $(0.11,[0,1,1,0])$\n\nTest case B:\n- Species count $d = 3$, state $X = [2,1,0]$.\n- Reactions:\n  - $(0.5,[3,0,0])$\n  - $(0.5,[2,1,0])$\n  - $(0.5,[1,1,1])$\n  - $(0.5,[0,2,0])$\n  - $(2.0,[0,0,0])$\n  - $(1.25,[1,0,0])$\n  - $(0.2,[1,1,0])$\n\nTest case C:\n- Species count $d = 2$, state $X = [50,40]$.\n- Reactions:\n  - $(10^{-3},[2,0])$\n  - $(10^{-6},[3,0])$\n  - $(2\\times 10^{-4},[1,1])$\n  - $(10^{-6},[2,1])$\n  - $(10^{-7},[0,3])$\n  - $(3.14,[0,0])$\n  - $(0.01,[1,0])$\n\nOutput specification. Your program must compute, for each test case, the list of all propensities in the order the reactions are specified. It must then produce a single line of output containing the three lists as a comma-separated list enclosed in square brackets, with no whitespace characters. Concretely, the output must be of the form $[[\\cdot],[\\cdot],[\\cdot]]$, where each inner bracket contains the floating-point propensities for that test case in order, written as decimals or in standard scientific notation. The outputs are dimensionless in this task. The final printed line must contain only this aggregate list and nothing else.", "solution": "We begin from the continuous-time Markov chain description of a well-mixed reaction network under stochastic mass-action kinetics. The state is $X \\in \\mathbb{N}^d$, where $X_i$ counts the molecules of species $i$. A reaction channel $r$ is defined by a rate constant $c_r \\ge 0$ and a reactant stoichiometric vector $\\nu_r^- \\in \\mathbb{N}^d$. The reaction order is $\\sum_{i=1}^d \\nu_{r,i}^-$. The fundamental definition of the propensity $a_r(X)$ under stochastic mass-action is that $a_r(X)$ equals the product of $c_r$ and the number of distinct unordered selections of reactant molecules present in $X$ that match the multiplicities required by $\\nu_r^-$. If any required multiplicity exceeds the available copies, then no valid selection exists and the propensity must be zero.\n\nWe derive an explicit counting rule. For a fixed reaction channel $r$, consider species $i$ with $X_i$ indistinguishable molecules available. We must select $\\nu_{r,i}^-$ molecules of species $i$ to participate (if $\\nu_{r,i}^- = 0$, nothing is chosen from this species). Because molecules of the same species are indistinguishable and only multiplicity matters, the number of ways to select $\\nu_{r,i}^-$ molecules from $X_i$ is the binomial coefficient\n$$\n\\binom{X_i}{\\nu_{r,i}^-} =\n\\begin{cases}\n\\dfrac{X_i!}{\\nu_{r,i}^!\\,(X_i-\\nu_{r,i}^-)!}, & \\text{if } 0 \\le \\nu_{r,i}^- \\le X_i,\\\n$$6pt]\n0, & \\text{if } \\nu_{r,i}^- > X_i.\n\\end{cases}\n$$\nThe selections across species are independent choices, so the total number of distinct unordered selections consistent with $\\nu_r^-$ is the product over all species:\n$N_r(X) = \\prod_{i=1}^d \\binom{X_i}{\\nu_{r,i}^-}.$\nTherefore, by the defining principle of stochastic mass-action kinetics, the propensity is\n$a_r(X) = c_r N_r(X) = c_r \\prod_{i=1}^d \\binom{X_i}{\\nu_{r,i}^-}.$\nThis single rule simultaneously handles all cases:\n- Zero-order reactions have $\\nu_r^- = 0$ componentwise, so each factor is $\\binom{X_i}{0} = 1$ and $a_r(X) = c_r$.\n- First-order reactions have exactly one component $\\nu_{r,i}^- = 1$, yielding $a_r(X) = c_r X_i$.\n- Second-order heterogeneous reactions have two distinct species with $\\nu_{r,i}^- = 1$, giving $a_r(X) = c_r X_i X_j$; second-order homogeneous reactions have $\\nu_{r,i}^- = 2$ for a single species, giving $a_r(X) = c_r \\binom{X_i}{2} = c_r X_i (X_i - 1)/2$.\n- Third-order reactions cover the patterns $\\nu_{r,i}^- \\in \\{(3,0,\\dots),(2,1,0,\\dots),(1,1,1,0,\\dots)\\}$ across species, and the formula specializes respectively to $a_r(X) = c_r \\binom{X_i}{3}$, $a_r(X) = c_r \\binom{X_i}{2} X_j$, and $a_r(X) = c_r X_i X_j X_k$ when the relevant multiplicities are available. If any required multiplicity exceeds the available $X_i$, the corresponding binomial coefficient is zero and thus $a_r(X) = 0$.\n\nAlgorithm design. The algorithm iterates over reactions $r = 1,\\dots,R$. For each reaction, it computes the product $\\prod_{i=1}^d \\binom{X_i}{\\nu_{r,i}^-}$ using integer-safe binomial coefficients. Specifically, for each species $i$:\n- If $\\nu_{r,i}^- = 0$, the factor is $1$.\n- Else if $\\nu_{r,i}^- > X_i$, the product becomes $0$ and we can short-circuit.\n- Else multiply the running product by the exact integer value $\\binom{X_i}{\\nu_{r,i}^-}$.\nFinally multiply the integer product by the floating-point rate constant $c_r$ to obtain $a_r(X)$. This is numerically robust for reaction orders up to $3$, since all binomial coefficients are modest in size and exactly representable as integers, and the only source of floating-point rounding is the final scaling by $c_r$.\n\nComplexity. For each reaction, the computation costs $O(d)$ time and uses $O(1)$ additional space. For the given test suite, this is trivial computationally.\n\nNow we evaluate the specified test cases.\n\nTest case A: $X = [6,5,3,0]$ and the reactions listed. Applying $a_r(X) = c_r \\prod_i \\binom{X_i}{\\nu_{r,i}^-}$:\n- $(0.75,[0,0,0,0])$: $0.75 \\times 1 = 0.75$.\n- $(0.1,[1,0,0,0])$: $0.1 \\times \\binom{6}{1} = 0.6$.\n- $(0.02,[1,1,0,0])$: $0.02 \\times \\binom{6}{1}\\binom{5}{1} = 0.6$.\n- $(0.03,[0,2,0,0])$: $0.03 \\times \\binom{5}{2} = 0.3$.\n- $(0.001,[1,1,1,0])$: $0.001 \\times \\binom{6}{1}\\binom{5}{1}\\binom{3}{1} = 0.09$.\n- $(0.004,[2,1,0,0])$: $0.004 \\times \\binom{6}{2}\\binom{5}{1} = 0.3$.\n- $(0.005,[3,0,0,0])$: $0.005 \\times \\binom{6}{3} = 0.1$.\n- $(0.07,[0,0,2,0])$: $0.07 \\times \\binom{3}{2} = 0.21$.\n- $(1.0,[0,0,0,1])$: $1.0 \\times \\binom{0}{1} = 0$.\n- $(0.11,[0,1,1,0])$: $0.11 \\times \\binom{5}{1}\\binom{3}{1} = 1.65$.\nTherefore, the propensity list is $[0.75,0.6,0.6,0.3,0.09,0.3,0.1,0.21,0.0,1.65]$.\n\nTest case B: $X = [2,1,0]$:\n- $(0.5,[3,0,0])$: $0.5 \\times \\binom{2}{3} = 0$.\n- $(0.5,[2,1,0])$: $0.5 \\times \\binom{2}{2}\\binom{1}{1} = 0.5$.\n- $(0.5,[1,1,1])$: $0.5 \\times \\binom{0}{1} = 0$.\n- $(0.5,[0,2,0])$: $0.5 \\times \\binom{1}{2} = 0$.\n- $(2.0,[0,0,0])$: $2.0 \\times 1 = 2.0$.\n- $(1.25,[1,0,0])$: $1.25 \\times \\binom{2}{1} = 2.5$.\n- $(0.2,[1,1,0])$: $0.2 \\times \\binom{2}{1}\\binom{1}{1} = 0.4$.\nTherefore, the propensity list is $[0.0,0.5,0.0,0.0,2.0,2.5,0.4]$.\n\nTest case C: $X = [50,40]$:\n- $(10^{-3},[2,0])$: $10^{-3} \\times \\binom{50}{2} = 1.225$.\n- $(10^{-6},[3,0])$: $10^{-6} \\times \\binom{50}{3} = 0.0196$.\n- $(2\\times 10^{-4},[1,1])$: $(2\\times 10^{-4}) \\times \\binom{50}{1}\\binom{40}{1} = 0.4$.\n- $(10^{-6},[2,1])$: $10^{-6} \\times \\binom{50}{2}\\binom{40}{1} = 0.049$.\n- $(10^{-7},[0,3])$: $10^{-7} \\times \\binom{40}{3} = 0.000988$.\n- $(3.14,[0,0])$: $3.14 \\times 1 = 3.14$.\n- $(0.01,[1,0])$: $0.01 \\times \\binom{50}{1} = 0.5$.\nTherefore, the propensity list is $[1.225,0.0196,0.4,0.049,0.000988,3.14,0.5]$.\n\nThe program below implements the general algorithm described, applies it to the test suite, and prints the three lists in a single-line, whitespace-free format as required.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport math\nimport numpy as np  # numpy is available; not strictly needed but permitted.\n\ndef comb_nonneg(n: int, k: int) -> int:\n    \"\"\"Return C(n,k) for integers n,k with the convention C(n,k)=0 if k>n or k<0.\"\"\"\n    if k < 0:\n        return 0\n    if k > n:\n        return 0\n    # For k==0 or k==n, math.comb handles correctly as 1\n    return math.comb(n, k)\n\ndef propensity_for_reaction(state, reactant_stoich, rate_constant) -> float:\n    \"\"\"\n    Compute propensity a = c * product_i C(state[i], reactant_stoich[i]).\n    If any required multiplicity exceeds availability, propensity is zero.\n    \"\"\"\n    product = 1\n    for xi, si in zip(state, reactant_stoich):\n        c = comb_nonneg(int(xi), int(si))\n        if c == 0:\n            return 0.0\n        product *= c\n    return float(rate_constant) * float(product)\n\ndef compute_propensities(state, reactions):\n    \"\"\"\n    state: list[int] of species counts\n    reactions: list of tuples (rate_constant: float, reactant_stoich: list[int])\n    returns: list[float] propensities\n    \"\"\"\n    props = []\n    for rate, stoich in reactions:\n        props.append(propensity_for_reaction(state, stoich, rate))\n    return props\n\ndef format_float(x: float) -> str:\n    \"\"\"\n    Format a float into a concise string without unnecessary whitespace,\n    using up to 12 significant digits, avoiding long binary tails.\n    \"\"\"\n    # Use general format; this trims trailing zeros and uses scientific notation when appropriate.\n    s = format(x, \".12g\")\n    return s\n\ndef format_list_no_spaces(lst):\n    \"\"\"Format a list of floats as [v1,v2,...] with no spaces.\"\"\"\n    return \"[\" + \",\".join(format_float(x) for x in lst) + \"]\"\n\ndef solve():\n    # Define the test cases from the problem statement.\n\n    # Test case A\n    state_A = [6, 5, 3, 0]\n    reactions_A = [\n        (0.75, [0, 0, 0, 0]),\n        (0.1, [1, 0, 0, 0]),\n        (0.02, [1, 1, 0, 0]),\n        (0.03, [0, 2, 0, 0]),\n        (0.001, [1, 1, 1, 0]),\n        (0.004, [2, 1, 0, 0]),\n        (0.005, [3, 0, 0, 0]),\n        (0.07, [0, 0, 2, 0]),\n        (1.0, [0, 0, 0, 1]),\n        (0.11, [0, 1, 1, 0]),\n    ]\n\n    # Test case B\n    state_B = [2, 1, 0]\n    reactions_B = [\n        (0.5, [3, 0, 0]),\n        (0.5, [2, 1, 0]),\n        (0.5, [1, 1, 1]),\n        (0.5, [0, 2, 0]),\n        (2.0, [0, 0, 0]),\n        (1.25, [1, 0, 0]),\n        (0.2, [1, 1, 0]),\n    ]\n\n    # Test case C\n    state_C = [50, 40]\n    reactions_C = [\n        (1e-3, [2, 0]),\n        (1e-6, [3, 0]),\n        (2e-4, [1, 1]),\n        (1e-6, [2, 1]),\n        (1e-7, [0, 3]),\n        (3.14, [0, 0]),\n        (0.01, [1, 0]),\n    ]\n\n    test_cases = [\n        (state_A, reactions_A),\n        (state_B, reactions_B),\n        (state_C, reactions_C),\n    ]\n\n    results = []\n    for state, reactions in test_cases:\n        props = compute_propensities(state, reactions)\n        results.append(props)\n\n    # Prepare nested list formatting without spaces\n    inner = \",\".join(format_list_no_spaces(r) for r in results)\n    print(f\"[{inner}]\")\n\nsolve()\n```", "id": "3353359"}, {"introduction": "An algorithm is only as good as its verification. Once you have an implementation of the SSA, how can you be confident that it is correct? This problem provides a suite of conceptual tests designed to probe the correctness of an SSA simulator, distinguishing between sound verification strategies and common fallacies. Engaging with these tests will deepen your understanding of the algorithm's statistical properties and equip you with the tools to validate your own code rigorously [@problem_id:3353365].", "problem": "Consider implementing the Stochastic Simulation Algorithm (SSA) for a well-mixed reaction network modeled as a continuous-time Markov chain with states $\\mathbf{X}(t) \\in \\mathbb{Z}_{\\ge 0}^n$, stoichiometric change vectors $\\boldsymbol{\\nu}_j \\in \\mathbb{Z}^n$, and propensities $a_j(\\mathbf{x})$ that satisfy the chemical master equation (CME). A team proposes several tests to verify correctness of their SSA implementation. Your task is to identify which of the proposed tests are theoretically sound, based on first principles of the CME and the continuous-time Markov chain construction underlying the SSA. Assume propensities are standard mass-action where appropriate, and that random numbers used by the SSA are independent and identically distributed Uniform($0,1$). Select all valid tests.\n\nA. Conservation-law and non-negativity invariant test: For the reversible unimolecular network $S_1 \\xrightleftharpoons[c_2]{c_1} S_2$ with propensities $a_1(\\mathbf{x}) = c_1 X_1$ and $a_2(\\mathbf{x}) = c_2 X_2$, verify across many SSA trajectories that $X_1(t) + X_2(t) = X_1(0) + X_2(0)$ for all $t \\ge 0$, and that $X_1(t) \\ge 0$ and $X_2(t) \\ge 0$ for all $t \\ge 0$.\n\nB. Zero-propensity edge case: Include a bimolecular reaction $2 S_1 \\to S_2$ with mass-action propensity $a_3(\\mathbf{x}) = c_3 \\binom{X_1}{2}$ in a network that also has the reversible unimolecular reactions in option A. Initialize with $X_1(0) = 1$, $X_2(0) = 0$. Verify that reaction $3$ never fires until some other reaction changes the state so that $X_1 \\ge 2$, at which point the firing of reaction $3$ becomes possible.\n\nC. Single-reaction goodness-of-fit: Consider the single-reaction birth process $\\varnothing \\to S_1$ with constant propensity $a(\\mathbf{x}) = c$ independent of $\\mathbf{x}$. Using many independent SSA paths, perform a Kolmogorovâ€“Smirnov (KS) goodness-of-fit test for the inter-event waiting times against the exponential distribution with rate $c$, and a chi-square test that the event count in a fixed window of length $T$ is Poisson with mean $c T$.\n\nD. First-event selection probability test: For a general network with reactions indexed by $j \\in \\{1, \\dots, m\\}$ and propensities $a_j(\\mathbf{x})$, fix an initial state $\\mathbf{X}(0) = \\mathbf{x}_0$. Across many independent runs, stop each trajectory after the first reaction fires, and estimate the probability that reaction $j$ is the first to fire. Verify that this empirical probability agrees with $a_j(\\mathbf{x}_0) / a_0(\\mathbf{x}_0)$, where $a_0(\\mathbf{x}) = \\sum_{i=1}^m a_i(\\mathbf{x})$.\n\nE. Raw-time exponential fit in general networks: For a general multireaction network with state-dependent propensities, pool all inter-event waiting times $\\tau_k$ observed along full SSA trajectories and perform a KS test that $\\tau_k$ are independent and identically distributed exponential random variables with rate $a_0(\\mathbf{X}(0))$.\n\nF. Time-rescaling goodness-of-fit: For a general multireaction network, compute the transformed inter-event times $Z_k = \\int_{t_k}^{t_{k+1}} a_0(\\mathbf{X}(s)) \\, ds$, where $t_k$ and $t_{k+1}$ are consecutive reaction times and $a_0(\\mathbf{x}) = \\sum_{j=1}^m a_j(\\mathbf{x})$. Perform a KS test that $Z_k$ are independent and identically distributed exponential random variables with rate $1$, and complement with a quantile-quantile plot against the exponential distribution with rate $1$.\n\nG. Max-propensity heuristic check: At each reaction step, verify that the reaction fired is the one with the largest propensity $a_j(\\mathbf{X})$ among all reactions; flag any trajectory where a reaction with smaller propensity fires.\n\nSelect all tests that are theoretically valid for verifying correctness of an SSA implementation.", "solution": "The problem statement constitutes a valid, well-posed query within the domain of stochastic simulation. It asks to evaluate the theoretical soundness of several proposed tests for verifying an implementation of the Stochastic Simulation Algorithm (SSA), also known as the Gillespie algorithm. The problem is scientifically grounded in the theory of continuous-time Markov chains and the chemical master equation, which form the basis for the SSA. It is objective, unambiguous, and contains sufficient information to proceed with a rigorous analysis.\n\nThe SSA is an exact simulation method for the stochastic time evolution of a well-mixed reacting system. At each step, for a system in state $\\mathbf{x}$, the algorithm performs two tasks:\n1.  Draw a time-to-next-event, $\\tau$, from an exponential distribution with rate $a_0(\\mathbf{x}) = \\sum_{j=1}^m a_j(\\mathbf{x})$.\n2.  Draw the index of the next reaction, $j$, from a discrete distribution where the probability of choosing reaction $j$ is $a_j(\\mathbf{x}) / a_0(\\mathbf{x})$.\n\nThe new state is then $\\mathbf{x} + \\boldsymbol{\\nu}_j$ at time $t + \\tau$. All proposed tests will be evaluated against these first principles.\n\n**A. Conservation-law and non-negativity invariant test**\n\nThis test proposes to verify two properties for the reversible reaction $S_1 \\xrightleftharpoons[c_2]{c_1} S_2$.\n1.  **Conservation Law**: The reactions are $S_1 \\to S_2$ and $S_2 \\to S_1$. The stoichiometric change vectors are $\\boldsymbol{\\nu}_1 = (-1, 1)^T$ and $\\boldsymbol{\\nu}_2 = (1, -1)^T$, where the state is $(X_1, X_2)^T$. For any reaction that fires, the change in the total number of molecules, $X_1 + X_2$, is $\\Delta(X_1 + X_2) = \\nu_{j,1} + \\nu_{j,2}$. For both $j=1$ and $j=2$, this sum is $0$. Thus, $X_1(t) + X_2(t)$ is a constant of motion, or a conservation law, for the system. A correct SSA implementation must preserve all such linear conservation laws. Verifying that $X_1(t) + X_2(t) = X_1(0) + X_2(0)$ is a valid test of the state update step.\n2.  **Non-negativity**: The state variables $X_1(t)$ and $X_2(t)$ represent molecule counts and must be non-negative integers. The mass-action propensities $a_1(\\mathbf{x}) = c_1 X_1$ and $a_2(\\mathbf{x}) = c_2 X_2$ are defined such that if a species count is zero (e.g., $X_1 = 0$), the propensity of any reaction consuming that species is also zero ($a_1 = 0$). According to the SSA, a reaction with zero propensity has zero probability of being chosen. Therefore, a correct implementation will never allow a reaction to fire that would result in a negative population count. Checking that $X_1(t) \\ge 0$ and $X_2(t) \\ge 0$ is a fundamental and valid test.\n\nThe verdict for this option is **Correct**.\n\n**B. Zero-propensity edge case**\n\nThis test examines the algorithm's behavior when a reaction propensity is exactly zero. The reaction $2S_1 \\to S_2$ has a mass-action propensity $a_3(\\mathbf{x}) = c_3 \\binom{X_1}{2} = c_3 \\frac{X_1(X_1-1)}{2}$. If the system is initialized with $X_1(0) = 1$, the initial propensity is $a_3 = c_3 \\frac{1(1-1)}{2} = 0$. Since the probability of selecting reaction $j$ is $a_j(\\mathbf{x})/a_0(\\mathbf{x})$, the probability of selecting reaction $3$ is $0/a_0(\\mathbf{x}) = 0$. Reaction $3$ cannot fire. It only becomes possible for it to fire if another reaction in the network first increases the population of $S_1$ to at least $2$. This is a crucial edge case. A faulty implementation (e.g., one with poor handling of floating-point arithmetic or indexing) might incorrectly select a reaction with zero propensity. This test is designed to catch such a flaw.\n\nThe verdict for this option is **Correct**.\n\n**C. Single-reaction goodness-of-fit**\n\nThis test considers a simple birth process $\\varnothing \\to S_1$ with constant propensity $a(\\mathbf{x}) = c$.\n1.  **Inter-event times**: The total propensity is $a_0(\\mathbf{x}) = c$, which is constant. According to the SSA, the time between consecutive events, $\\tau$, must be drawn from an exponential distribution with rate $a_0(\\mathbf{x}) = c$. Since the rate is constant, all inter-event times are independent and identically distributed (i.i.d.) random variables from $\\text{Exponential}(c)$. A Kolmogorov-Smirnov (KS) test is a standard statistical procedure to check if a sample of data comes from a specified continuous distribution. Thus, it is a valid way to test the \"when\" part of the SSA.\n2.  **Event count**: A process where events occur with a constant rate $c$ is a homogeneous Poisson process. For such a process, the number of events occurring in a fixed time interval of length $T$ follows a Poisson distribution with mean $\\lambda = cT$. A chi-square goodness-of-fit test is a standard method to test if count data follows a particular discrete distribution, like the Poisson. This is also a valid verification method.\n\nThe verdict for this option is **Correct**.\n\n**D. First-event selection probability test**\n\nThis test focuses on the reaction selection rule. For a fixed initial state $\\mathbf{X}(0) = \\mathbf{x}_0$, the total propensity is fixed at $a_0(\\mathbf{x}_0) = \\sum_{j=1}^m a_j(\\mathbf{x}_0)$. The theoretical probability that the very first reaction to fire is reaction $j$ is given by the SSA's selection rule: $P(j|\\mathbf{x}_0) = a_j(\\mathbf{x}_0) / a_0(\\mathbf{x}_0)$. By running many independent simulations and recording which reaction fires first, one can generate an empirical frequency distribution. Comparing this empirical distribution to the theoretical probabilities $\\{P(j|\\mathbf{x}_0)\\}_{j=1}^m$ (e.g., using a chi-square test) provides a direct and powerful verification of the \"which\" part of the SSA implementation.\n\nThe verdict for this option is **Correct**.\n\n**E. Raw-time exponential fit in general networks**\n\nThis test proposes pooling all inter-event times $\\tau_k$ from trajectories of a general network and testing if they fit an exponential distribution with rate $a_0(\\mathbf{X}(0))$. This is theoretically incorrect. The inter-event time $\\tau_k$ is drawn from an exponential distribution with rate $a_0(\\mathbf{X}(t_{k-1}))$, where $\\mathbf{X}(t_{k-1})$ is the state *at that time*. In a general network, the state $\\mathbf{X}$ changes, so the total propensity $a_0$ is a function of time, $a_0(t) \\equiv a_0(\\mathbf{X}(t))$. The waiting times $\\tau_k$ are therefore drawn from exponential distributions with *different* rates. They are independent but not identically distributed. Pooling them creates a mixture distribution, which is not, in general, an exponential distribution. Testing this mixture against a specific exponential distribution (especially one with the an arbitrarily chosen rate from the initial time) is statistically and theoretically unfounded.\n\nThe verdict for this option is **Incorrect**.\n\n**F. Time-rescaling goodness-of-fit**\n\nThis test is a sophisticated and correct alternative to E. It uses the time-rescaling theorem. The inter-event time $\\tau_k = t_{k+1} - t_k$ is a random variable drawn from $\\text{Exponential}(\\lambda_k)$, where the rate is $\\lambda_k = a_0(\\mathbf{X}(t_k))$. The state $\\mathbf{X}(s)$ is constant for $s \\in [t_k, t_{k+1})$, so $\\mathbf{X}(s) = \\mathbf{X}(t_k)$ on this interval. The proposed transformed variable is $Z_k = \\int_{t_k}^{t_{k+1}} a_0(\\mathbf{X}(s)) \\, ds$. Since the integrand is constant, this becomes $Z_k = a_0(\\mathbf{X}(t_k)) \\cdot (t_{k+1} - t_k) = \\lambda_k \\tau_k$. If a random variable $\\tau_k \\sim \\text{Exponential}(\\lambda_k)$, then the scaled random variable $Z_k = \\lambda_k \\tau_k$ follows an exponential distribution with rate $1$. This holds for every step $k$. Therefore, the sequence of transformed times $\\{Z_k\\}$ should be a sample of i.i.d. random variables from the standard $\\text{Exponential}(1)$ distribution. Using a KS test or a Q-Q plot to verify this is a powerful and theoretically sound method for validating the timing aspect of the SSA in the general case of state-dependent propensities.\n\nThe verdict for this option is **Correct**.\n\n**G. Max-propensity heuristic check**\n\nThis test proposes to verify that the reaction with the largest propensity is always the one that fires. This is a fundamental misunderstanding of the SSA. The SSA is a stochastic algorithm, not a deterministic one. The propensities determine the *probabilities* of reactions, not a deterministic choice. A reaction $j$ is chosen with probability $a_j(\\mathbf{x}) / a_0(\\mathbf{x})$. While a reaction with a larger propensity is more likely to be chosen, any reaction with a non-zero propensity has a non-zero chance of occurring. For example, if $a_1(\\mathbf{x}) = 100$ and $a_2(\\mathbf{x}) = 1$, reaction $2$ has a small but non-zero probability of being selected, approximately $1/101$. A correct SSA implementation must be able to select reaction $2$. Flagging a trajectory where this happens as an error would be incorrect. This test describes a greedy algorithm, not the SSA.\n\nThe verdict for this option is **Incorrect**.\n\nIn summary, the theoretically valid tests are A, B, C, D, and F.", "answer": "$$\\boxed{ABCDF}$$", "id": "3353365"}]}