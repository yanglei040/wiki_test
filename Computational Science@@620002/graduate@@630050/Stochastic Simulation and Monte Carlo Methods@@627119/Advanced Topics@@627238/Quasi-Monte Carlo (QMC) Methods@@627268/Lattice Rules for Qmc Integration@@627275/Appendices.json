{"hands_on_practices": [{"introduction": "The power of lattice rules stems from a deep connection between the integration error and the structure of a \"dual lattice\" in the frequency domain. This exercise guides you through the foundational steps of this theory, demonstrating how the error is not random but a sum of specific Fourier coefficients aliased by the lattice. By working through a small-scale example, you will gain a concrete understanding of how the geometry of the dual lattice directly governs the accuracy of the QMC approximation [@problem_id:3317421].", "problem": "Consider a rank-one lattice rule for Quasi-Monte Carlo (QMC) integration on the two-dimensional torus with generator vector $g=(1,4)$ and number of points $N=13$. The lattice point set is defined by $x_{n}=\\{\\frac{n g}{N}\\}$ for $n=0,1,\\dots,12$, where $\\{\\cdot\\}$ denotes the component-wise fractional part. Let $f:[0,1]^{2}\\rightarrow \\mathbb{C}$ be a periodic function (period $1$ in each coordinate) with Fourier expansion $f(x)=\\sum_{h\\in\\mathbb{Z}^{2}} \\hat{f}(h) \\exp(2\\pi i\\, h\\cdot x)$, where $h\\cdot x=h_{1}x_{1}+h_{2}x_{2}$. The rank-one lattice rule approximation to $\\int_{[0,1]^{2}} f(x)\\,dx$ is $Q_{N}(f)=\\frac{1}{N}\\sum_{n=0}^{N-1} f(x_{n})$.\n\nStarting from the foundational identity that the discrete exponential sum $\\frac{1}{N}\\sum_{n=0}^{N-1}\\exp\\!\\big(2\\pi i\\, n\\, t\\big)$ equals $1$ if $t\\in \\mathbb{Z}$ and $0$ otherwise, derive the condition under which a Fourier mode $\\exp(2\\pi i\\, h\\cdot x)$ aliases under the lattice rule, and show how the quadrature error $Q_{N}(f)-\\int_{[0,1]^2} f(x)\\, dx$ depends on the subset of Fourier coefficients that satisfy the aliasing condition.\n\nThen, explicitly enumerate all nonzero integer vectors $h=(h_{1},h_{2})$ satisfying the dual congruence $h\\cdot g\\equiv 0 \\pmod{N}$ with $\\|h\\|_{\\infty}\\leq 3$, where $\\|h\\|_{\\infty}=\\max\\{|h_{1}|,|h_{2}|\\}$. Finally, assume a Fourier decay model $|\\hat{f}(h)|=c\\, \\|h\\|_{2}^{-2}$ for all $h\\neq 0$, where $c>0$ is a constant and $\\|h\\|_{2}=\\sqrt{h_{1}^{2}+h_{2}^{2}}$. Compute the sum of absolute contributions to the magnitude of the quadrature error coming from the enumerated dual vectors with $\\|h\\|_{\\infty}\\leq 3$, and provide your final answer as a simplified analytic expression in terms of $c$. No rounding is required.", "solution": "The analysis of the problem proceeds in three stages as requested: first, the derivation of the quadrature error expression for a rank-one lattice rule; second, the enumeration of the specific dual lattice vectors; and third, the calculation of the error contribution based on a given Fourier decay model.\n\nThe true value of the integral of the function $f(x)$ over the unit hypercube $[0,1]^2$ is given by its zeroth Fourier coefficient, $\\hat{f}(0)$. This is seen by integrating the Fourier series term by term:\n$$\n\\int_{[0,1]^2} f(x) dx = \\int_{[0,1]^2} \\sum_{h \\in \\mathbb{Z}^2} \\hat{f}(h) \\exp(2\\pi i h \\cdot x) dx = \\sum_{h \\in \\mathbb{Z}^2} \\hat{f}(h) \\int_{[0,1]^2} \\exp(2\\pi i h \\cdot x) dx\n$$\nThe integral $\\int_{[0,1]^2} \\exp(2\\pi i h \\cdot x) dx$ is equal to $1$ if $h=(0,0)$ and $0$ if $h \\in \\mathbb{Z}^2 \\setminus \\{0\\}$. Thus,\n$$\n\\int_{[0,1]^2} f(x) dx = \\hat{f}(0)\n$$\n\nThe rank-one lattice rule approximation, $Q_N(f)$, is the average of the function evaluated at the $N$ lattice points $x_n = \\{\\frac{n g}{N}\\}$ for $n=0, 1, \\dots, N-1$. We substitute the Fourier expansion of $f(x_n)$ into the definition of $Q_N(f)$:\n$$\nQ_N(f) = \\frac{1}{N} \\sum_{n=0}^{N-1} f(x_n) = \\frac{1}{N} \\sum_{n=0}^{N-1} \\sum_{h \\in \\mathbb{Z}^2} \\hat{f}(h) \\exp(2\\pi i h \\cdot x_n)\n$$\nThe lattice points are $x_n = \\frac{n g}{N} \\pmod 1$. Since $h$ is an integer vector, the term $\\exp(2\\pi i h \\cdot x)$ is periodic with period $1$ in each component of $x$. Therefore, we can ignore the integer part resulting from the fractional part operation, which means we can write $\\exp(2\\pi i h \\cdot x_n) = \\exp(2\\pi i h \\cdot \\frac{n g}{N})$. Swapping the order of summation, which is permissible under suitable convergence conditions on the Fourier series, we get:\n$$\nQ_N(f) = \\sum_{h \\in \\mathbb{Z}^2} \\hat{f}(h) \\left( \\frac{1}{N} \\sum_{n=0}^{N-1} \\exp\\left(2\\pi i h \\cdot \\frac{n g}{N}\\right) \\right) = \\sum_{h \\in \\mathbb{Z}^2} \\hat{f}(h) \\left( \\frac{1}{N} \\sum_{n=0}^{N-1} \\exp\\left(2\\pi i n \\frac{h \\cdot g}{N}\\right) \\right)\n$$\nWe now use the foundational identity provided: the discrete sum $\\frac{1}{N}\\sum_{n=0}^{N-1}\\exp(2\\pi i n t)$ is $1$ if $t$ is an integer and $0$ otherwise. In our expression, $t = \\frac{h \\cdot g}{N}$. The sum is therefore $1$ if and only if $\\frac{h \\cdot g}{N}$ is an integer, which is equivalent to the congruence relation $h \\cdot g \\equiv 0 \\pmod N$. This condition defines the dual lattice.\nA Fourier mode $\\exp(2\\pi i h \\cdot x)$ aliases, meaning it is indistinguishable from the constant function $1$ under the sampling scheme of the lattice rule, precisely when this condition $h \\cdot g \\equiv 0 \\pmod N$ is met.\nThe set of all such integer vectors $h$ is called the dual lattice, denoted $L^* = \\{ h \\in \\mathbb{Z}^2 \\mid h \\cdot g \\equiv 0 \\pmod N \\}$.\nThe QMC approximation can thus be written as a sum over the dual lattice:\n$$\nQ_N(f) = \\sum_{h \\in L^*} \\hat{f}(h)\n$$\nThe quadrature error is the difference between the approximation and the true integral value:\n$$\nE_N(f) = Q_N(f) - \\int_{[0,1]^2} f(x) dx = \\sum_{h \\in L^*} \\hat{f}(h) - \\hat{f}(0)\n$$\nThe zero vector $h=(0,0)$ always satisfies the dual lattice condition, $0 \\cdot g = 0 \\equiv 0 \\pmod N$, so $h=0$ is always in $L^*$. We can therefore separate the $h=0$ term from the sum:\n$$\nE_N(f) = \\left( \\hat{f}(0) + \\sum_{h \\in L^* \\setminus \\{0\\}} \\hat{f}(h) \\right) - \\hat{f}(0) = \\sum_{h \\in L^* \\setminus \\{0\\}} \\hat{f}(h)\n$$\nThis shows that the quadrature error is the sum of the Fourier coefficients corresponding to all non-zero vectors in the dual lattice.\n\nNext, we must enumerate the specific non-zero integer vectors $h=(h_1, h_2)$ that satisfy the dual congruence for the given parameters $g=(1,4)$ and $N=13$, under the constraint $\\|h\\|_{\\infty} \\leq 3$. The conditions are:\n1. $h \\in \\mathbb{Z}^2 \\setminus \\{0\\}$\n2. $h_1 \\cdot 1 + h_2 \\cdot 4 \\equiv 0 \\pmod{13}$\n3. $\\|h\\|_{\\infty} = \\max\\{|h_1|, |h_2|\\} \\leq 3$, which means $h_1, h_2 \\in \\{-3, -2, -1, 0, 1, 2, 3\\}$.\n\nThe congruence is $h_1 + 4h_2 \\equiv 0 \\pmod{13}$. This means $h_1 + 4h_2$ must be a multiple of $13$.\nGiven the range for $h_1$ and $h_2$, the value of the expression $h_1 + 4h_2$ is bounded:\nThe minimum value is $-3 + 4(-3) = -15$.\nThe maximum value is $3 + 4(3) = 15$.\nThe only integer multiples of $13$ in the interval $[-15, 15]$ are $-13$, $0$, and $13$.\n\nCase 1: $h_1 + 4h_2 = 13$.\nWe test values of $h_2$ from its allowed range:\nIf $h_2=3$, then $h_1 + 12 = 13 \\implies h_1 = 1$. Both $h_1=1$ and $h_2=3$ are in the range $[-3, 3]$. So, $h=(1,3)$ is a solution.\nIf $h_2=2$, then $h_1 + 8 = 13 \\implies h_1=5$. This is outside the allowed range for $h_1$.\nFor any $h_2 < 2$, $h_1$ will be even larger, so there are no other solutions in this case.\n\nCase 2: $h_1 + 4h_2 = 0$.\nIf $h_2=0$, then $h_1=0$. This gives the vector $h=(0,0)$, which is explicitly excluded as we are looking for non-zero vectors. For any other integer value of $h_2$ in its range, $h_1=-4h_2$ will be outside the range of $h_1$. For example, if $h_2=1$, $h_1=-4$.\n\nCase 3: $h_1 + 4h_2 = -13$.\nWe test values of $h_2$:\nIf $h_2=-3$, then $h_1 - 12 = -13 \\implies h_1 = -1$. Both $h_1=-1$ and $h_2=-3$ are in the range $[-3, 3]$. So, $h=(-1,-3)$ is a solution.\nIf $h_2=-2$, then $h_1 - 8 = -13 \\implies h_1=-5$. This is outside the allowed range for $h_1$.\nFor any $h_2 > -2$, $h_1$ will be algebraically larger (less negative) and will not yield a solution.\n\nThus, the set of non-zero integer vectors $h$ satisfying the specified conditions is $\\{ (1,3), (-1,-3) \\}$.\n\nFinally, we compute the sum of the absolute contributions to the error from these enumerated vectors. The problem provides a decay model for the magnitude of the Fourier coefficients: $|\\hat{f}(h)| = c \\|h\\|_2^{-2}$ for $h \\neq 0$, where $\\|h\\|_2 = \\sqrt{h_1^2 + h_2^2}$. The quantity to compute is $\\sum_{h \\in \\{(1,3), (-1,-3)\\}} |\\hat{f}(h)|$.\n\nFor $h=(1,3)$:\n$\\|h\\|_2^2 = 1^2 + 3^2 = 1+9=10$.\n$|\\hat{f}((1,3))| = c \\cdot (10)^{-1} = \\frac{c}{10}$.\n\nFor $h=(-1,-3)$:\n$\\|h\\|_2^2 = (-1)^2 + (-3)^2 = 1+9=10$.\n$|\\hat{f}((-1,-3))| = c \\cdot (10)^{-1} = \\frac{c}{10}$.\n\nThe sum of these absolute contributions is:\n$$\n\\frac{c}{10} + \\frac{c}{10} = \\frac{2c}{10} = \\frac{c}{5}\n$$\nThis is the final result.", "answer": "$$\n\\boxed{\\frac{c}{5}}\n$$", "id": "3317421"}, {"introduction": "Not all lattice rules are created equal; a poorly chosen generating vector can lead to catastrophic errors, even for seemingly simple functions. This practice problem presents a worst-case scenario where the lattice points are structured in such a way that they systematically alias a low-frequency cosine wave to a constant, producing a large, deterministic error. By identifying the short, non-zero vectors in the dual lattice, you will diagnose this failure and see firsthand how a function's structure can conspire with a \"bad\" lattice to undermine the integration result [@problem_id:3317438].", "problem": "Consider a rank-1 Quasi-Monte Carlo (QMC) lattice rule in dimension $s=3$ with $N=8$ points and generating vector $z=(1,2,4)^{\\top}$. The node set is given by $x_{j}=\\{j z / N\\}$ for $j=0,\\dots,N-1$, where the braces denote reduction modulo $1$ componentwise. Define the linear map $g:[0,1)^{3}\\to[0,1)^{3}$ by $g(u)=G u \\bmod 1$ with the integer matrix\n$$\nG=\\begin{pmatrix}\n0 & 0 & 2\\\\\n1 & 0 & 0\\\\\n0 & 1 & 0\n\\end{pmatrix},\n$$\nand consider the periodic integrand\n$$\nf(u)=\\cos\\!\\big(2\\pi\\, e_{1}^{\\top} g(u)\\big),\\quad u\\in[0,1)^{3},\n$$\nwhere $e_{1}=(1,0,0)^{\\top}$. The lattice rule estimator is $Q_{N}(f)=\\frac{1}{N}\\sum_{j=0}^{N-1} f(x_{j})$ and the true integral is $I(f)=\\int_{[0,1)^{3}} f(u)\\,du$.\n\nUsing only the core definitions of rank-1 lattice rules, the dual lattice $L^{*}=\\{h\\in\\mathbb{Z}^{3}: h\\cdot z\\equiv 0 \\,(\\mathrm{mod}\\, N)\\}$, basic trigonometric-exponential identities, and orthogonality of roots of unity, do the following:\n- Determine the shortest nonzero vector in $L^{*}$ with respect to the Euclidean norm and explain how the chosen $g$ aligns $f$ along the corresponding low-dimensional subspace.\n- Compute $Q_{N}(f)$ and $I(f)$ from first principles, and hence the bias $Q_{N}(f)-I(f)$.\n\nReport the bias $Q_{N}(f)-I(f)$ as your final answer. Express your final answer exactly (no rounding).", "solution": "The solution proceeds in three parts:\n1.  Analysis of the dual lattice $L^*$ and the function $f(u)$.\n2.  Computation of the true integral $I(f)$.\n3.  Computation of the lattice rule estimator $Q_N(f)$ and the final bias.\n\n**Part 1: Dual Lattice and Function Alignment**\n\nThe dual lattice $L^*$ associated with the rank-1 rule defined by $N=8$ and $z=(1,2,4)^\\top$ is the set of all integer vectors $h = (h_1, h_2, h_3)^\\top \\in \\mathbb{Z}^3$ such that the dot product $h \\cdot z$ is a multiple of $N$.\n$$\nL^* = \\{ h \\in \\mathbb{Z}^3 : h_1 \\cdot 1 + h_2 \\cdot 2 + h_3 \\cdot 4 \\equiv 0 \\pmod 8 \\}\n$$\nTo find the shortest non-zero vector in $L^*$, we search for integer vectors $h \\neq 0$ with the smallest squared Euclidean norm, $\\|h\\|^2 = h_1^2 + h_2^2 + h_3^2$. By testing vectors with increasing norm, we find that the vector $h=(2,0,0)^\\top$ gives $h\\cdot z = 2 \\not\\equiv 0 \\pmod 8$, $h=(0,2,0)^\\top$ gives $h\\cdot z = 4 \\not\\equiv 0 \\pmod 8$, but for $h=(0,0,2)^\\top$, we have $h \\cdot z = 8 \\equiv 0 \\pmod 8$. This vector is in $L^*$. A search of all vectors with smaller norm reveals no others in the dual lattice. Thus, a shortest non-zero vector in $L^*$ is $h^* = (0,0,2)^\\top$.\n\nNext, we analyze the integrand $f(u)$. The argument of the cosine function is $2\\pi e_1^\\top g(u)$. The expression $e_1^\\top G u$ is a linear transformation of the coordinates of $u$:\n$$\ne_1^\\top G u = \\begin{pmatrix} 1 & 0 & 0 \\end{pmatrix} \\begin{pmatrix} 0 & 0 & 2 \\\\ 1 & 0 & 0 \\\\ 0 & 1 & 0 \\end{pmatrix} \\begin{pmatrix} u_1 \\\\ u_2 \\\\ u_3 \\end{pmatrix} = \\begin{pmatrix} 0 & 0 & 2 \\end{pmatrix} \\begin{pmatrix} u_1 \\\\ u_2 \\\\ u_3 \\end{pmatrix} = 2u_3\n$$\nThis vector $\\begin{pmatrix} 0 & 0 & 2 \\end{pmatrix}$ is precisely the shortest non-zero vector $h^*$ we found in the dual lattice. The integrand is therefore\n$$\nf(u) = \\cos(2\\pi (2u_3)) = \\cos(4\\pi u_3) = \\cos(2\\pi h^* \\cdot u)\n$$\nThis demonstrates that the function $f(u)$ is constructed to vary only along the direction of a shortest non-zero vector in the dual lattice $L^*$. This represents a worst-case scenario for this lattice rule.\n\n**Part 2: Computation of the True Integral $I(f)$**\n\nThe true integral of $f(u)$ over the unit hypercube $[0,1)^3$ is computed as:\n$$\nI(f) = \\int_{[0,1)^3} f(u) \\, du = \\int_0^1 \\int_0^1 \\int_0^1 \\cos(4\\pi u_3) \\, du_1 \\, du_2 \\, du_3\n$$\nSince the integrand does not depend on $u_1$ and $u_2$, the first two integrations yield a factor of $1$:\n$$\nI(f) = \\int_0^1 \\cos(4\\pi u_3) \\, du_3 = \\left[ \\frac{\\sin(4\\pi u_3)}{4\\pi} \\right]_0^1 = \\frac{\\sin(4\\pi) - \\sin(0)}{4\\pi} = 0\n$$\n\n**Part 3: Computation of the QMC Estimator $Q_N(f)$ and Bias**\n\nThe QMC estimator is $Q_N(f) = \\frac{1}{N} \\sum_{j=0}^{N-1} f(x_j)$. The function evaluated at a lattice point $x_j$ is $f(x_j) = \\cos(2\\pi h^* \\cdot x_j)$. Using the property that $\\exp(2\\pi i h \\cdot \\{v\\}) = \\exp(2\\pi i h \\cdot v)$ for integer vector $h$:\n$$\nf(x_j) = \\text{Re}\\left( e^{2\\pi i h^* \\cdot x_j} \\right) = \\text{Re}\\left( e^{2\\pi i h^* \\cdot (jz/N)} \\right)\n$$\nThe argument of the exponential is $2\\pi i \\, j \\frac{h^* \\cdot z}{N}$. Since $h^* \\in L^*$, we know $h^* \\cdot z$ is an integer multiple of $N$. We computed $h^* \\cdot z = (0,0,2) \\cdot (1,2,4) = 8$. As $N=8$, we have $h^* \\cdot z = 1 \\cdot N$.\nTherefore, for any $j \\in \\{0, \\dots, 7\\}$:\n$$\ne^{2\\pi i h^* \\cdot x_j} = e^{2\\pi i j \\frac{8}{8}} = e^{2\\pi i j} = 1\n$$\nThis implies $f(x_j) = \\text{Re}(1) = 1$ for all $j=0, \\dots, N-1$.\n\nThe QMC estimator is then:\n$$\nQ_N(f) = \\frac{1}{N} \\sum_{j=0}^{N-1} f(x_j) = \\frac{1}{8} \\sum_{j=0}^{7} 1 = \\frac{1}{8} \\cdot 8 = 1\n$$\nThe bias, or integration error, is the difference between the estimator and the true integral:\n$$\n\\text{Bias} = Q_N(f) - I(f) = 1 - 0 = 1\n$$\nThis result confirms the worst-case scenario: the lattice rule samples the function $f(u) = \\cos(4\\pi u_3)$ only at points where its value is $1$, completely missing its oscillatory nature and leading to a maximal error.", "answer": "$$\\boxed{1}$$", "id": "3317438"}, {"introduction": "Having understood how to analyze lattice rules, the next step is to construct them effectively. This hands-on programming exercise moves from analysis to synthesis, challenging you to implement and compare two standard methods for finding high-quality generating vectors: the Korobov construction and the more powerful component-by-component (CBC) method. By using the minimal norm of dual vectors as a figure of merit, you will gain practical experience in the search for \"good\" lattices that are designed to deliver high accuracy [@problem_id:3317409].", "problem": "Consider a rank-1 lattice rule with modulus $N \\in \\mathbb{N}$ and a generator vector $\\boldsymbol{g} \\in \\{1,2,\\dots,N-1\\}^s$ in $s$ dimensions. The corresponding point set is $\\{\\{n \\boldsymbol{g} / N\\} : n = 0,1,\\dots,N-1\\}$, where the braces denote the fractional part applied componentwise. For a prime modulus $N$, define the dual constraint on integer vectors $\\boldsymbol{h} \\in \\mathbb{Z}^s$ by the congruence\n$$\n\\boldsymbol{h} \\cdot \\boldsymbol{g} \\equiv 0 \\pmod{N}.\n$$\nDefine the symmetric representative set for each coordinate as $\\{-\\lfloor N/2 \\rfloor, \\dots, 0, \\dots, \\lfloor N/2 \\rfloor\\}$. Because adding or subtracting multiples of $N$ in any coordinate preserves the congruence modulo $N$, every dual vector has a representative in this set with minimal absolute value per coordinate. The minimal Euclidean norm of a nonzero dual vector is then well-defined by\n$$\nm_2(\\boldsymbol{g}; N, s) \\;=\\; \\min_{\\substack{\\boldsymbol{h} \\in \\mathbb{Z}^s \\setminus \\{\\boldsymbol{0}\\} \\\\ \\boldsymbol{h} \\cdot \\boldsymbol{g} \\equiv 0 \\; (\\mathrm{mod}\\; N)}} \\left\\{ \\|\\boldsymbol{h}\\|_2 \\;:\\; h_j \\in \\left[-\\frac{N-1}{2}, \\frac{N-1}{2}\\right] \\cap \\mathbb{Z} \\text{ for all } j \\right\\}.\n$$\nWe use the squared minimal norm $m_2^2(\\boldsymbol{g}; N, s)$ as an integer-valued figure of merit, with larger values indicating better uniformity as motivated by the spectral test in quasi-Monte Carlo analysis.\n\nYou are asked to implement and compare two generator constructions:\n\n1. Korobov construction: for a given base $a \\in \\{1,2,\\dots,N-1\\}$, define\n$$\n\\boldsymbol{g}(a) \\;=\\; \\left( a^0 \\bmod N, \\; a^1 \\bmod N, \\; \\dots, \\; a^{s-1} \\bmod N \\right).\n$$\n\n2. Component-by-component (CBC) construction using the spectral figure of merit: fix $g_1 = 1$, and for $d = 2,3,\\dots,s$ choose $g_d \\in \\{1,2,\\dots,N-1\\}$ to maximize $m_2^2\\big((g_1,\\dots,g_{d-1}, g_d); N, d\\big)$. Break ties by the smallest $g_d$.\n\nAlgorithmic base to derive and implement:\n\n- The dual constraint for a fixed choice of the first $s-1$ coordinates $h_1,\\dots,h_{s-1}$ uniquely determines $h_s$ modulo $N$ when $g_s \\not\\equiv 0 \\pmod{N}$:\n$$\nh_s \\equiv - \\left(\\sum_{j=1}^{s-1} h_j g_j\\right) \\cdot g_s^{-1} \\pmod{N},\n$$\nwhere $g_s^{-1}$ is the multiplicative inverse modulo $N$ (which exists since $N$ is prime and $g_s \\not\\equiv 0 \\pmod{N}$). The representative of $h_s$ is then chosen in the symmetric range $\\left[-\\frac{N-1}{2}, \\frac{N-1}{2}\\right] \\cap \\mathbb{Z}$ to minimize $|h_s|$. It suffices to search over all $(h_1,\\dots,h_{s-1})$ in this symmetric range and exclude the all-zero vector.\n\n- For the CBC construction in dimension $d$, evaluate the squared minimal norm $m_2^2$ for each candidate $g_d$ using the same search with dimension $d$, solving for the $d$-th coordinate from the first $d-1$.\n\nTask:\n\n- For each specified test case, compute:\n  1. The best Korobov squared minimal dual norm $m_{2,\\mathrm{Kor}}^2 = \\max_{a \\in \\mathcal{A}} m_2^2(\\boldsymbol{g}(a); N, s)$ over the given candidate set of bases $\\mathcal{A}$.\n  2. The CBC generator $\\boldsymbol{g}_{\\mathrm{CBC}}$ as described and its squared minimal dual norm $m_{2,\\mathrm{CBC}}^2 = m_2^2(\\boldsymbol{g}_{\\mathrm{CBC}}; N, s)$.\n  3. A comparison indicator $I$ defined by $I = 1$ if $m_{2,\\mathrm{CBC}}^2 \\ge m_{2,\\mathrm{Kor}}^2$ and $I = 0$ otherwise.\n\n- Your program must output the results for all test cases on a single line as a comma-separated Python-style list containing one sublist per test case in the order given. Each sublist must be of the form $[m_{2,\\mathrm{Kor}}^2, m_{2,\\mathrm{CBC}}^2, I]$ with all entries as integers.\n\nTest suite:\n\n- Case 1: $N = 29$, $s = 3$, $\\mathcal{A} = \\{2,3,5,7\\}$.\n- Case 2: $N = 29$, $s = 4$, $\\mathcal{A} = \\{2,3,8\\}$.\n- Case 3: $N = 29$, $s = 3$, $\\mathcal{A} = \\{11,12,13,14,15\\}$.\n\nFinal output format:\n\n- Your program should produce a single line of output containing a Python-style list of three sublists, one per test case, in the exact form\n$[[m_{2,\\mathrm{Kor},1}^2, m_{2,\\mathrm{CBC},1}^2, I_1],[m_{2,\\mathrm{Kor},2}^2, m_{2,\\mathrm{CBC},2}^2, I_2],[m_{2,\\mathrm{Kor},3}^2, m_{2,\\mathrm{CBC},3}^2, I_3]]$,\nwith no additional text. All entries must be integers and there are no physical units involved.", "solution": "```python\nimport numpy as np\nimport itertools\n\ndef solve():\n    \"\"\"\n    Solves the lattice rule problem by implementing and comparing\n    Korobov and Component-by-Component (CBC) generator constructions.\n    \"\"\"\n\n    class LatticeQualityAssessor:\n        \"\"\"\n        A helper class to compute the figure of merit for a rank-1 lattice rule.\n        \"\"\"\n        def __init__(self, N):\n            self.N = N\n            self.half_N = (self.N - 1) // 2\n            self.h_range = range(-self.half_N, self.half_N + 1)\n            # Memoization cache: g_tuple -> m2_sq\n            self.memo_m2 = {}\n\n        def _get_symmetric_rep(self, h_mod_N):\n            \"\"\"\n            Maps an integer modulo N to its representative in [-floor(N/2), floor(N/2)].\n            \"\"\"\n            if h_mod_N > self.half_N:\n                return h_mod_N - self.N\n            return h_mod_N\n\n        def calculate_m2_sq(self, g):\n            \"\"\"\n            Calculates the squared minimal norm m_2^2 for a given generator g.\n            \"\"\"\n            s = len(g)\n            g_tuple = tuple(g)\n            if g_tuple in self.memo_m2:\n                return self.memo_m2[g_tuple]\n\n            if s == 1:\n                return np.inf\n\n            min_sq_norm = np.inf\n            g_inv_s = pow(g[s - 1], -1, self.N)\n\n            h_prefixes = itertools.product(self.h_range, repeat=s - 1)\n\n            for h_prefix in h_prefixes:\n                if all(h == 0 for h in h_prefix):\n                    continue\n\n                h_dot_g_prefix = sum(h_j * g[j] for j, h_j in enumerate(h_prefix))\n                \n                h_s_mod_N = (-h_dot_g_prefix * g_inv_s) % self.N\n                h_s = self._get_symmetric_rep(h_s_mod_N)\n\n                sq_norm_prefix = sum(h_j**2 for h_j in h_prefix)\n                current_sq_norm = sq_norm_prefix + h_s**2\n                \n                min_sq_norm = min(min_sq_norm, current_sq_norm)\n\n            result = int(min_sq_norm)\n            self.memo_m2[g_tuple] = result\n            return result\n\n    test_cases = [\n        {'N': 29, 's': 3, 'A': [2, 3, 5, 7]},\n        {'N': 29, 's': 4, 'A': [2, 3, 8]},\n        {'N': 29, 's': 3, 'A': [11, 12, 13, 14, 15]},\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        N, s, A = case['N'], case['s'], case['A']\n        assessor = LatticeQualityAssessor(N)\n\n        # 1. Korobov construction\n        max_kor_m2_sq = 0\n        for a in A:\n            g = tuple(pow(a, j, N) for j in range(s))\n            current_m2_sq = assessor.calculate_m2_sq(g)\n            if current_m2_sq > max_kor_m2_sq:\n                max_kor_m2_sq = current_m2_sq\n        \n        m_2_kor_sq_final = max_kor_m2_sq\n\n        # 2. Component-by-component construction\n        g_cbc = [1]\n        m_2_cbc_sq_final = 0\n\n        for d in range(2, s + 1):\n            best_gd_for_d = -1\n            max_m2_sq_in_d = -1\n            \n            for gd_candidate in range(1, N):\n                current_g_d = tuple(g_cbc + [gd_candidate])\n                current_m2_sq = assessor.calculate_m2_sq(current_g_d)\n                \n                if current_m2_sq > max_m2_sq_in_d:\n                    max_m2_sq_in_d = current_m2_sq\n                    best_gd_for_d = gd_candidate\n            \n            g_cbc.append(best_gd_for_d)\n            m_2_cbc_sq_final = max_m2_sq_in_d\n\n        # 3. Comparison\n        I = 1 if m_2_cbc_sq_final >= m_2_kor_sq_final else 0\n        \n        all_results.append([m_2_kor_sq_final, m_2_cbc_sq_final, I])\n\n    return f\"[{','.join(map(str, all_results))}]\"\n\n# The problem asks for the output of the program, which is generated here.\n# The final XML will contain this output string in the answer tag.\n# print(solve())\n```", "answer": "[[9,13,1],[9,10,1],[10,13,1]]", "id": "3317409"}]}