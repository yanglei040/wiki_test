{"hands_on_practices": [{"introduction": "To build a solid understanding of Sobol' sequences, there is no substitute for constructing one from first principles. This exercise guides you through the explicit, step-by-step generation of the first few points in a two-dimensional sequence. By manually performing the bitwise operations involving Gray codes and direction numbers, you will gain a concrete feel for the deterministic algorithm that gives Sobol' sequences their unique uniformity properties [@problem_id:3345407].", "problem": "Consider the construction of a two-dimensional Sobol' sequence in base $2$ from first principles. The construction uses the following ingredients.\n\n- Direction numbers for each coordinate (dimension) are generated from a primitive polynomial over the finite field $\\mathbb{F}_2$ and a set of initial odd integers. For a dimension with a degree-$m$ primitive polynomial $p(x) = x^m + a_1 x^{m-1} + \\cdots + a_{m-1} x + 1$ with $a_k \\in \\{0,1\\}$, one specifies odd integers $m_1,\\dots,m_m$ with $1 \\leq m_j < 2^j$, and defines the direction numbers $v_j = m_j / 2^j$ for $j \\leq m$. For $j > m$, the direction numbers are defined recursively by bitwise exclusive-or (XOR), using the recurrence on dyadic rationals\n$$\nv_j \\;=\\; \\bigoplus_{k=1}^{m-1} a_k \\, 2^{-k} v_{j-k} \\;\\oplus\\; 2^{-m} v_{j-m},\n$$\nwhere $\\oplus$ denotes exclusive-or (XOR) applied bit-by-bit to the binary expansions of dyadic rationals.\n\n- Given direction numbers $\\{v_j^{(d)}\\}_{j \\geq 1}$ for dimension $d \\in \\{1,2\\}$, the $n$-th coordinate in dimension $d$ is obtained from the Gray code of the index $n$, namely $G(n) = n \\oplus (n \\gg 1)$, where $\\gg$ denotes a right bit-shift and $\\oplus$ denotes bitwise XOR on nonnegative integers. If $G(n)$ has binary expansion $G(n) = \\sum_{j \\geq 1} g_j(n) 2^{j-1}$ with bits $g_j(n) \\in \\{0,1\\}$, then\n$$\nx_n^{(d)} \\;=\\; \\bigoplus_{j \\geq 1} g_j(n) \\, v_j^{(d)}.\n$$\n\nUse the above fundamental definitions to explicitly construct the first $8$ two-dimensional Sobol' points $(x_n^{(1)}, x_n^{(2)})$ for $n = 1,2,\\dots,8$, under the following concrete and fully specified choices.\n\n- For dimension $1$, use the degree-$1$ primitive polynomial $p_1(x) = x + 1$, and the canonical initial odd integers, which imply $v_j^{(1)} = 2^{-j}$ for all $j \\geq 1$.\n\n- For dimension $2$, use the degree-$3$ primitive polynomial $p_2(x) = x^3 + x + 1$, so that $m = 3$ and $(a_1,a_2) = (0,1)$. Take initial odd integers $(m_1,m_2,m_3) = (1,3,5)$, so that $v_1^{(2)} = \\frac{1}{2}$, $v_2^{(2)} = \\frac{3}{4}$, and $v_3^{(2)} = \\frac{5}{8}$. Generate $v_4^{(2)}$ as needed by the above XOR recurrence.\n\nCarry out all steps by showing the explicit bitwise manipulations in base $2$, including:\n- the computation of the Gray code bits $g_j(n)$ for each $n$,\n- the evaluation of the XOR combinations of the direction numbers in binary expansions to obtain each coordinate.\n\nProvide exact rational values for all coordinates in lowest terms. No rounding is required. For the final answer, list the $8$ two-dimensional points in order $n = 1,2,\\dots,8$, flattened as a single row matrix\n$$\n\\bigl[x_1^{(1)} \\; \\; x_1^{(2)} \\; \\; x_2^{(1)} \\; \\; x_2^{(2)} \\; \\; \\dots \\; \\; x_8^{(1)} \\; \\; x_8^{(2)}\\bigr].\n$$", "solution": "The problem statement is validated as self-contained, logically consistent, and mathematically well-posed. All the necessary definitions, constants, and initial conditions required for the construction of the specified two-dimensional Sobol' sequence are provided. The problem is thus solvable as stated. I will proceed with a detailed derivation of the first $8$ points.\n\nThe core of the task is to compute the coordinates $x_n^{(d)}$ for dimension $d \\in \\{1,2\\}$ and index $n \\in \\{1, 2, \\dots, 8\\}$. The formula for this is\n$$x_n^{(d)} = \\bigoplus_{j \\geq 1} g_j(n) v_j^{(d)}$$\nwhere $g_j(n)$ are the bits in the binary expansion of the Gray code of $n$, $G(n) = \\sum_{j \\geq 1} g_j(n) 2^{j-1}$, and $\\{v_j^{(d)}\\}$ are the direction numbers for dimension $d$. The operator $\\oplus$ denotes the bitwise exclusive-or (XOR) on the binary representations of the dyadic rationals.\n\nFirst, we establish the necessary direction numbers for each dimension. Since we need to compute points up to $n=8$, we must find the bits for $G(8)$. The index $n=8$ is $(1000)_2$. Its Gray code is $G(8) = 8 \\oplus (8 \\gg 1) = 8 \\oplus 4 = 12 = (1100)_2$. Since $12 = 1 \\cdot 2^3 + 1 \\cdot 2^2$, the highest index for a non-zero bit $g_j(n)$ is $j=4$ (for $g_4(8)=1$). Therefore, we need direction numbers up to $v_4^{(d)}$ for both dimensions.\n\n**Dimension 1:**\nThe problem specifies that for dimension $1$, the direction numbers are $v_j^{(1)} = 2^{-j}$ for all $j \\geq 1$. We list the first four:\n- $v_1^{(1)} = \\frac{1}{2} = (0.1)_2$\n- $v_2^{(1)} = \\frac{1}{4} = (0.01)_2$\n- $v_3^{(1)} = \\frac{1}{8} = (0.001)_2$\n- $v_4^{(1)} = \\frac{1}{16} = (0.0001)_2$\n\n**Dimension 2:**\nFor dimension $2$, the primitive polynomial is $p_2(x) = x^3 + x + 1$. This corresponds to degree $m=3$ and coefficients $(a_1, a_2) = (0,1)$ in the form $p(x) = x^m + a_1 x^{m-1} + \\dots + a_{m-1}x + 1$.\nThe initial direction numbers are given by $(m_1, m_2, m_3) = (1, 3, 5)$:\n- $v_1^{(2)} = \\frac{m_1}{2^1} = \\frac{1}{2} = (0.1)_2$\n- $v_2^{(2)} = \\frac{m_2}{2^2} = \\frac{3}{4} = (0.11)_2$\n- $v_3^{(2)} = \\frac{m_3}{2^3} = \\frac{5}{8} = (0.101)_2$\n\nWe must compute $v_4^{(2)}$ using the provided recurrence for $j>m=3$:\n$$v_j^{(2)} = \\bigoplus_{k=1}^{2} a_k \\, 2^{-k} v_{j-k}^{(2)} \\oplus 2^{-3} v_{j-3}^{(2)} = a_1 (v_{j-1}^{(2)} \\gg 1) \\oplus a_2 (v_{j-2}^{(2)} \\gg 2) \\oplus (v_{j-3}^{(2)} \\gg 3)$$\nWith $a_1=0$ and $a_2=1$, the recurrence simplifies to $v_j^{(2)} = (v_{j-2}^{(2)} \\gg 2) \\oplus (v_{j-3}^{(2)} \\gg 3)$.\nFor $j=4$:\n$$v_4^{(2)} = (v_2^{(2)} \\gg 2) \\oplus (v_1^{(2)} \\gg 3)$$\nThe operation $v \\gg k$ is a right bit-shift by $k$ places, equivalent to multiplying by $2^{-k}$.\n$v_2^{(2)} \\gg 2 = \\frac{3}{4} \\times \\frac{1}{4} = \\frac{3}{16}$\n$v_1^{(2)} \\gg 3 = \\frac{1}{2} \\times \\frac{1}{8} = \\frac{1}{16}$\nThe XOR operation is performed on the binary representations:\n$v_4^{(2)} = \\frac{3}{16} \\oplus \\frac{1}{16} = (0.0011)_2 \\oplus (0.0001)_2 = (0.0010)_2 = \\frac{2}{16} = \\frac{1}{8}$.\nSo, the direction number is $v_4^{(2)} = \\frac{1}{8} = (0.001)_2$.\n\nNow we compute the points $(x_n^{(1)}, x_n^{(2)})$ for $n=1, \\dots, 8$.\n\n**n=1**: $1=(1)_2$. $G(1)=1 \\oplus 0 = 1=(1)_2$. So $g_1(1)=1$, other $g_j(1)=0$.\n$x_1^{(1)} = v_1^{(1)} = \\frac{1}{2}$.\n$x_1^{(2)} = v_1^{(2)} = \\frac{1}{2}$.\nPoint 1: $(\\frac{1}{2}, \\frac{1}{2})$.\n\n**n=2**: $2=(10)_2$. $G(2)=2 \\oplus 1 = 3=(11)_2$. So $g_1(2)=1, g_2(2)=1$.\n$x_2^{(1)} = v_1^{(1)} \\oplus v_2^{(1)} = \\frac{1}{2} \\oplus \\frac{1}{4} = (0.1)_2 \\oplus (0.01)_2 = (0.11)_2 = \\frac{3}{4}$.\n$x_2^{(2)} = v_1^{(2)} \\oplus v_2^{(2)} = \\frac{1}{2} \\oplus \\frac{3}{4} = (0.10)_2 \\oplus (0.11)_2 = (0.01)_2 = \\frac{1}{4}$.\nPoint 2: $(\\frac{3}{4}, \\frac{1}{4})$.\n\n**n=3**: $3=(11)_2$. $G(3)=3 \\oplus 1 = 2=(10)_2$. So $g_2(3)=1$.\n$x_3^{(1)} = v_2^{(1)} = \\frac{1}{4}$.\n$x_3^{(2)} = v_2^{(2)} = \\frac{3}{4}$.\nPoint 3: $(\\frac{1}{4}, \\frac{3}{4})$.\n\n**n=4**: $4=(100)_2$. $G(4)=4 \\oplus 2 = 6=(110)_2$. So $g_2(4)=1, g_3(4)=1$.\n$x_4^{(1)} = v_2^{(1)} \\oplus v_3^{(1)} = \\frac{1}{4} \\oplus \\frac{1}{8} = (0.010)_2 \\oplus (0.001)_2 = (0.011)_2 = \\frac{3}{8}$.\n$x_4^{(2)} = v_2^{(2)} \\oplus v_3^{(2)} = \\frac{3}{4} \\oplus \\frac{5}{8} = (0.110)_2 \\oplus (0.101)_2 = (0.011)_2 = \\frac{3}{8}$.\nPoint 4: $(\\frac{3}{8}, \\frac{3}{8})$.\n\n**n=5**: $5=(101)_2$. $G(5)=5 \\oplus 2 = 7=(111)_2$. So $g_1(5)=1, g_2(5)=1, g_3(5)=1$.\n$x_5^{(1)} = v_1^{(1)} \\oplus v_2^{(1)} \\oplus v_3^{(1)} = (v_1^{(1)} \\oplus v_2^{(1)}) \\oplus v_3^{(1)} = \\frac{3}{4} \\oplus \\frac{1}{8} = (0.110)_2 \\oplus (0.001)_2 = (0.111)_2 = \\frac{7}{8}$.\n$x_5^{(2)} = v_1^{(2)} \\oplus v_2^{(2)} \\oplus v_3^{(2)} = (v_1^{(2)} \\oplus v_2^{(2)}) \\oplus v_3^{(2)} = \\frac{1}{4} \\oplus \\frac{5}{8} = (0.010)_2 \\oplus (0.101)_2 = (0.111)_2 = \\frac{7}{8}$.\nPoint 5: $(\\frac{7}{8}, \\frac{7}{8})$.\n\n**n=6**: $6=(110)_2$. $G(6)=6 \\oplus 3 = 5=(101)_2$. So $g_1(6)=1, g_3(6)=1$.\n$x_6^{(1)} = v_1^{(1)} \\oplus v_3^{(1)} = \\frac{1}{2} \\oplus \\frac{1}{8} = (0.100)_2 \\oplus (0.001)_2 = (0.101)_2 = \\frac{5}{8}$.\n$x_6^{(2)} = v_1^{(2)} \\oplus v_3^{(2)} = \\frac{1}{2} \\oplus \\frac{5}{8} = (0.100)_2 \\oplus (0.101)_2 = (0.001)_2 = \\frac{1}{8}$.\nPoint 6: $(\\frac{5}{8}, \\frac{1}{8})$.\n\n**n=7**: $7=(111)_2$. $G(7)=7 \\oplus 3 = 4=(100)_2$. So $g_3(7)=1$.\n$x_7^{(1)} = v_3^{(1)} = \\frac{1}{8}$.\n$x_7^{(2)} = v_3^{(2)} = \\frac{5}{8}$.\nPoint 7: $(\\frac{1}{8}, \\frac{5}{8})$.\n\n**n=8**: $8=(1000)_2$. $G(8)=8 \\oplus 4 = 12=(1100)_2$. So $g_3(8)=1, g_4(8)=1$.\n$x_8^{(1)} = v_3^{(1)} \\oplus v_4^{(1)} = \\frac{1}{8} \\oplus \\frac{1}{16} = (0.0010)_2 \\oplus (0.0001)_2 = (0.0011)_2 = \\frac{3}{16}$.\n$x_8^{(2)} = v_3^{(2)} \\oplus v_4^{(2)} = \\frac{5}{8} \\oplus \\frac{1}{8} = (0.101)_2 \\oplus (0.001)_2 = (0.100)_2 = \\frac{4}{8} = \\frac{1}{2}$.\nPoint 8: $(\\frac{3}{16}, \\frac{1}{2})$.\n\nThe computed coordinates, in exact fractional form and lowest terms, are:\n- $n=1: (\\frac{1}{2}, \\frac{1}{2})$\n- $n=2: (\\frac{3}{4}, \\frac{1}{4})$\n- $n=3: (\\frac{1}{4}, \\frac{3}{4})$\n- $n=4: (\\frac{3}{8}, \\frac{3}{8})$\n- $n=5: (\\frac{7}{8}, \\frac{7}{8})$\n- $n=6: (\\frac{5}{8}, \\frac{1}{8})$\n- $n=7: (\\frac{1}{8}, \\frac{5}{8})$\n- $n=8: (\\frac{3}{16}, \\frac{1}{2})$\n\nThese are collected into a single flattened row matrix for the final answer.", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{1}{2}  \\frac{1}{2}  \\frac{3}{4}  \\frac{1}{4}  \\frac{1}{4}  \\frac{3}{4}  \\frac{3}{8}  \\frac{3}{8}  \\frac{7}{8}  \\frac{7}{8}  \\frac{5}{8}  \\frac{1}{8}  \\frac{1}{8}  \\frac{5}{8}  \\frac{3}{16}  \\frac{1}{2}\n\\end{pmatrix}\n}\n$$", "id": "3345407"}, {"introduction": "After learning how to construct a Sobol' sequence, the next logical step is to quantify its quality. This is accomplished using a figure of merit known as the $t$-value, where a lower $t$ indicates a more uniform point set. This practice delves into the theoretical foundations of digital nets, showing how the quality parameter $t$ is directly determined by the linear independence of the rows of the generating matrices over the finite field $\\mathbb{F}_2$ [@problem_id:3345448]. You will apply a rank-based method to see firsthand how different choices of direction numbers can either improve or degrade the sequence's quality.", "problem": "Consider base two ($b=2$) digital nets generated by $m \\times m$ binary generating matrices $\\{C_{j}\\}_{j=1}^{s}$, where $m \\in \\mathbb{N}$ and $s \\in \\mathbb{N}$. In a Sobol' construction, the choice of direction numbers determines the entries of the generating matrices. A point set of size $N=2^{m}$ in dimension $s$ is obtained by mapping each index vector $n \\in \\{0,1\\}^{m}$ to coordinates whose $m$ binary digits are linear images of $n$ under the corresponding generating matrices. An elementary interval in $[0,1)^{s}$ is specified by fixing the first $d_{j}$ binary digits in coordinate $j$ for $j=1,\\dots,s$, where $d_{j} \\in \\{0,1,\\dots,m\\}$.\n\nStart from the following fundamental base:\n- In a base two digital net generated by $C_{1},\\dots,C_{s}$, fixing the first $d_{j}$ binary digits in coordinate $j$ imposes linear constraints $R n = r$ over the finite field of two elements, where $R$ is the matrix formed by stacking the first $d_{j}$ rows of each $C_{j}$, and $r$ is the right-hand side determined by the chosen digits.\n- The number of solutions $n \\in \\{0,1\\}^{m}$ to $R n = r$ equals $2^{m - \\operatorname{rank}(R)}$ and depends only on the rank of $R$ over the finite field of two elements.\n- A point set is a digital $(t,m,s)$-net if and only if for all choices of nonnegative integers $d_{1},\\dots,d_{s}$ with $\\sum_{j=1}^{s} d_{j} = m - t$, every such elementary interval contains exactly $2^{t}$ points.\n\nUsing only these base facts, derive a method to compute the $t$-value from the generating matrices in dimension $s=2$, and apply it to the following two scenarios with $m=4$ and $C_{1}$ fixed. In both scenarios, let\n$$\nC_{1} \\;=\\;\n\\begin{pmatrix}\n1  0  0  0 \\\\\n0  1  0  0 \\\\\n0  0  1  0 \\\\\n0  0  0  1\n\\end{pmatrix}.\n$$\nScenario A uses direction numbers that produce\n$$\nC_{2}^{(A)} \\;=\\;\n\\begin{pmatrix}\n0  0  0  1 \\\\\n0  0  1  1 \\\\\n0  1  0  1 \\\\\n1  0  0  1\n\\end{pmatrix},\n$$\nwhile Scenario B uses different direction numbers that produce\n$$\nC_{2}^{(B)} \\;=\\;\n\\begin{pmatrix}\n0  0  0  1 \\\\\n0  0  1  1 \\\\\n0  1  0  1 \\\\\n0  1  1  1\n\\end{pmatrix}.\n$$\n\nCompute the $t$-values $t_{A}$ and $t_{B}$ corresponding to Scenario A and Scenario B, respectively, by deriving and applying the rank-based method implied by the base facts above. Express your final answer as a row matrix whose entries are $t_{A}$ and $t_{B}$. No rounding is required. Provide your reasoning that shows how the change in direction numbers from Scenario A to Scenario B modifies the computed $t$-value.", "solution": "The problem requires the derivation of a method to compute the quality parameter $t$ of a digital net, based on a specific set of axiomatic definitions, and the application of this method to two scenarios. All operations are considered over the finite field of two elements, $\\mathbb{F}_2$.\n\nFirst, we derive the method for computing the $t$-value. The problem provides three fundamental facts:\n1. An elementary interval is specified by fixing the first $d_j$ binary digits for each coordinate $j=1, \\dots, s$. The constraints on the input index vector $n \\in \\{0,1\\}^m$ form a linear system $R n = r$, where $R$ is a matrix formed by stacking the first $d_j$ rows of each generating matrix $C_j$.\n2. The number of points from the net that fall into such an elementary interval is given by $2^{m - \\operatorname{rank}(R)}$, where the rank is computed over $\\mathbb{F}_2$.\n3. A point set constitutes a digital $(t,m,s)$-net if and only if for all choices of non-negative integers $d_1, \\dots, d_s$ satisfying $\\sum_{j=1}^{s} d_j = m - t$, every corresponding elementary interval contains exactly $2^t$ points.\n\nTo derive the method, we combine these facts. For a set to be a $(t,m,s)$-net, the number of points in the specified intervals must be $2^t$. According to fact 2, this number is also $2^{m - \\operatorname{rank}(R)}$. Equating these two expressions gives:\n$$2^t = 2^{m - \\operatorname{rank}(R)}$$\nThis implies the following condition on the rank of the matrix $R$:\n$$t = m - \\operatorname{rank}(R) \\implies \\operatorname{rank}(R) = m - t$$\nThis rank condition must hold for all matrices $R$ constructed from choices of $d_1, \\dots, d_s$ where $\\sum_{j=1}^{s} d_j = m - t$. The matrix $R$ is formed by stacking a total of $k = \\sum d_j = m-t$ rows. For its rank to be equal to $m-t$, the set of its rows must be linearly independent.\n\nThe quality parameter $t$ for a given set of generating matrices is defined as the smallest non-negative integer for which the set satisfies the properties of a $(t,m,s)$-net. Therefore, to compute the $t$-value, we must find the minimum non-negative integer $t$ such that for all choices of non-negative integers $d_1, \\dots, d_s$ with $\\sum_{j=1}^{s} d_j = m - t$, the corresponding set of $m-t$ rows taken from the generating matrices $\\{C_j\\}$ is linearly independent.\n\nThe derived method is as follows:\nWe test integer values for $t$ starting from $t=0$. For each $t$, we check if for all partitions $d_1 + \\dots + d_s = m-t$, the matrix $R$ formed by the first $d_j$ rows of each $C_j$ has full rank, i.e., $\\operatorname{rank}(R) = m-t$. The smallest $t$ for which this condition holds is the $t$-value of the net.\n\nNow, we apply this method to the two scenarios provided, where $m=4$ and $s=2$.\n\n**Scenario A: Computation of $t_A$**\nThe generating matrices are $C_1 = I_4$ and $C_2 = C_2^{(A)}$.\n$$ C_{1} = \\begin{pmatrix} 1  0  0  0 \\\\ 0  1  0  0 \\\\ 0  0  1  0 \\\\ 0  0  0  1 \\end{pmatrix}, \\quad C_{2}^{(A)} = \\begin{pmatrix} 0  0  0  1 \\\\ 0  0  1  1 \\\\ 0  1  0  1 \\\\ 1  0  0  1 \\end{pmatrix} $$\nWe start by testing $t=0$. For this, we must verify that for all non-negative integers $d_1, d_2$ with $d_1+d_2=m-t = 4-0 = 4$, the corresponding matrix $R(d_1, d_2)$ has rank $4$. The possible pairs for $(d_1, d_2)$ are $(0,4), (1,3), (2,2), (3,1), (4,0)$.\n- For $(d_1, d_2) = (4,0)$: $R(4,0) = C_1 = I_4$. The rank is clearly $4$.\n- For $(d_1, d_2) = (0,4)$: $R(0,4) = C_2^{(A)}$. The determinant is $\\det(C_2^{(A)}) = 1 \\pmod 2$. Thus, the rank is $4$.\n- For $(d_1, d_2) = (3,1)$: $R(3,1)$ consists of the first $3$ rows of $C_1$ and the first row of $C_2^{(A)}$. The matrix is $\\begin{pmatrix} 1000 \\\\ 0100 \\\\ 0010 \\\\ 0001 \\end{pmatrix} = I_4$. The rank is $4$.\n- For $(d_1, d_2) = (1,3)$: $R(1,3)$ consists of the first row of $C_1$ and the first $3$ rows of $C_2^{(A)}$. The matrix is $M = \\begin{pmatrix} 1000 \\\\ 0001 \\\\ 0011 \\\\ 0101 \\end{pmatrix}$. We find $\\det(M) = 1 \\pmod 2$. The rank is $4$.\n- For $(d_1, d_2) = (2,2)$: $R(2,2)$ consists of the first $2$ rows of $C_1$ and the first $2$ rows of $C_2^{(A)}$. The matrix is $M = \\begin{pmatrix} 1000 \\\\ 0100 \\\\ 0001 \\\\ 0011 \\end{pmatrix}$. We find $\\det(M) = 1 \\pmod 2$. The rank is $4$.\n\nSince the condition holds for all partitions of $4$, the net is a $(0,4,2)$-net. As $t$ must be the smallest such non-negative integer, we conclude that $t_A=0$.\n\n**Scenario B: Computation of $t_B$**\nThe generating matrices are $C_1 = I_4$ and $C_2 = C_2^{(B)}$.\n$$ C_{1} = \\begin{pmatrix} 1  0  0  0 \\\\ 0  1  0  0 \\\\ 0  0  1  0 \\\\ 0  0  0  1 \\end{pmatrix}, \\quad C_{2}^{(B)} = \\begin{pmatrix} 0  0  0  1 \\\\ 0  0  1  1 \\\\ 0  1  0  1 \\\\ 0  1  1  1 \\end{pmatrix} $$\nLet the rows of $C_2^{(B)}$ be denoted $c_{2,i}^{(B)}$. We find a linear dependency among the rows of $C_2^{(B)}$:\n$c_{2,1}^{(B)} + c_{2,2}^{(B)} + c_{2,3}^{(B)} = (0,0,0,1)+(0,0,1,1)+(0,1,0,1) = (0,1,1,1) = c_{2,4}^{(B)}$.\nThis means the four rows of $C_2^{(B)}$ are linearly dependent.\n\nWe test $t=0$. We check partitions of $d_1+d_2=4$.\n- For $(d_1, d_2) = (0,4)$: $R(0,4) = C_2^{(B)}$. As shown, its rows are linearly dependent, so its rank is less than $4$. (The rank is $3$, as the first three rows are linearly independent). The condition for $t=0$ fails. Thus, $t_B  0$.\n\nNext, we test $t=1$. For this, we must verify that for all non-negative integers $d_1, d_2$ with $d_1+d_2=m-t = 4-1 = 3$, the corresponding matrix $R(d_1, d_2)$ has rank $3$. The possible pairs are $(0,3), (1,2), (2,1), (3,0)$.\n- For $(d_1, d_2) = (3,0)$: $R(3,0)$ consists of the first $3$ rows of $C_1$, which are standard basis vectors and thus linearly independent. The rank is $3$.\n- For $(d_1, d_2) = (0,3)$: $R(0,3)$ consists of the first $3$ rows of $C_2^{(B)}$. The matrix is $\\begin{pmatrix} 0001 \\\\ 0011 \\\\ 0101 \\end{pmatrix}$. These rows are linearly independent. The rank is $3$.\n- For $(d_1, d_2) = (2,1)$: $R(2,1)$ consists of the first $2$ rows of $C_1$ and the first row of $C_2^{(B)}$. The rows are $\\{(1,0,0,0), (0,1,0,0), (0,0,0,1)\\}$, which are linearly independent. The rank is $3$.\n- For $(d_1, d_2) = (1,2)$: $R(1,2)$ consists of the first row of $C_1$ and the first $2$ rows of $C_2^{(B)}$. The rows are $\\{(1,0,0,0), (0,0,0,1), (0,0,1,1)\\}$, which are linearly independent. The rank is $3$.\n\nSince the condition holds for all partitions of $3$, the net is a $(1,4,2)$-net. Because the condition failed for $t=0$, the smallest integer for which it holds is $t=1$. Therefore, $t_B=1$.\n\nThe change in the $t$-value from $t_A=0$ to $t_B=1$ is a direct consequence of the modification of the generating matrix $C_2$. In Scenario A, all combinations of $4$ rows partitioned between $C_1$ and $C_2^{(A)}$ are linearly independent. In Scenario B, the fourth row of $C_2^{(B)}$ was chosen such that it created a linear dependency among the rows of $C_2^{(B)}$ itself. This specific dependency, $c_{2,4}^{(B)} = c_{2,1}^{(B)} + c_{2,2}^{(B)} + c_{2,3}^{(B)}$, caused the rank of $C_2^{(B)}$ to be $3$ instead of $4$, violating the condition required for a $(0,4,2)$-net. This failure forced the $t$-value to be at least $1$. Subsequent analysis showed that the conditions for a $(1,4,2)$-net are met, establishing $t_B=1$.", "answer": "$$\\boxed{\\begin{pmatrix} 0  1 \\end{pmatrix}}$$", "id": "3345448"}, {"introduction": "Even a high-quality, low-discrepancy sequence can perform poorly if the integrand has a structure that aligns with weaknesses in the point set's projections. This advanced exercise moves from abstract quality metrics to a practical demonstration of this phenomenon. You will construct a \"pathological\" test function using Walsh functions that is specifically designed to make a Sobol' sequence produce a large integration error, and then implement two powerful mitigation strategies—linear scrambling and integrand reparameterization—to restore the method's accuracy [@problem_id:3345410].", "problem": "You are to construct, analyze, and computationally verify a pathological case for two-dimensional Sobol' sequences using the theory of digital nets over the binary finite field $\\mathbb{F}_2$ and Walsh functions, and then demonstrate two mitigation strategies: scrambling via random binary linear maps and reparameterization of the integrand. Work in dimension $s=2$ with $N=2^{m}$ points for integer $m \\ge 1$. Use purely mathematical units; no physical units are involved.\n\nFundamental base and setting:\n- A two-dimensional Sobol'-type digital net in base $2$ can be represented by two generating matrices $G_1 \\in \\{0,1\\}^{m \\times m}$ and $G_2 \\in \\{0,1\\}^{m \\times m}$ over $\\mathbb{F}_2$. For each index $i \\in \\{0,1,\\dots,2^m-1\\}$, let $\\mathbf{b}(i) \\in \\{0,1\\}^m$ be the length-$m$ binary expansion of $i$ arranged from least significant bit to most significant bit. Define the binary coordinate vectors $\\mathbf{y}_d(i) = G_d \\mathbf{b}(i)$ over $\\mathbb{F}_2$, and the real coordinates by $x_d(i) = \\sum_{j=1}^m y_{d,j}(i)\\,2^{-j}$, for $d \\in \\{1,2\\}$. The point set is $\\{(x_1(i),x_2(i)) : i=0,1,\\dots,2^m-1\\} \\subset [0,1)^2$.\n- For this problem, use $G_1 = I_m$ (the $m\\times m$ identity matrix) and $G_2$ defined entrywise by $(G_2)_{j,k} = 1$ if $k \\le j$ and $(G_2)_{j,k} = 0$ otherwise. This is an invertible lower-triangular choice and yields a valid digital net in the Sobol' family.\n- Define the one-dimensional Walsh function $\\mathrm{wal}_k:[0,1) \\to \\{-1,+1\\}$ by the binary dyadic expansion: if $x = \\sum_{j=1}^\\infty x_j\\,2^{-j}$ with $x_j \\in \\{0,1\\}$ and $k = \\sum_{j=0}^\\infty k_j\\,2^j$ with $k_j \\in \\{0,1\\}$, then\n$$\n\\mathrm{wal}_k(x) = (-1)^{\\sum_{j=1}^\\infty k_{j-1} x_j}\n$$\nwhere the sum is taken in $\\mathbb{Z}$ and the exponent modulo $2$. In practice and for $N=2^m$, truncate $k$ to $m$ bits and $x$ to $m$ fractional bits since the points have $m$-bit precision. For dimension $2$, let $\\mathbf{k}_1,\\mathbf{k}_2 \\in \\{0,1\\}^m$ be the bit-vectors of $k_1$ and $k_2$. The two-dimensional test integrand is\n$$\nf(x_1,x_2)=\\mathrm{wal}_{k_1}(x_1)\\,\\mathrm{wal}_{k_2}(x_2)=(-1)^{\\langle \\mathbf{k}_1,\\mathbf{x}_1\\rangle \\oplus \\langle \\mathbf{k}_2,\\mathbf{x}_2\\rangle},\n$$\nwhere $\\mathbf{x}_d$ denotes the first $m$ binary fractional bits of $x_d$, $\\langle \\cdot,\\cdot\\rangle$ denotes the dot-product over $\\mathbb{F}_2$ and $\\oplus$ is addition in $\\mathbb{F}_2$.\n\nCore facts to use:\n- The integral of any non-constant Walsh function over $[0,1)$ is $0$. Thus, for any $(k_1,k_2)\\neq (0,0)$,\n$$\n\\int_{[0,1]^2} f(x_1,x_2)\\,\\mathrm{d}x_1\\,\\mathrm{d}x_2 = 0.\n$$\n- For $N=2^m$ points of a digital net with generating matrices $G_1,G_2$, the quasi-Monte Carlo average of $f$ over the point set equals $1$ if and only if the dual-net condition holds:\n$$\nG_1^\\top \\mathbf{k}_1 \\oplus G_2^\\top \\mathbf{k}_2 = \\mathbf{0} \\in \\mathbb{F}_2^m,\n$$\nand equals $0$ otherwise. This follows from the character sum property of Walsh functions on digital nets.\n- A Matoušek-style linear scrambling uses nonsingular lower-triangular binary matrices $L_1,L_2 \\in \\{0,1\\}^{m\\times m}$ to form new generating matrices $G'_1=L_1 G_1$ and $G'_2=L_2 G_2$. The scrambled average of the same $f$ then equals $1$ only if $G_1'^\\top \\mathbf{k}_1 \\oplus G_2'^\\top \\mathbf{k}_2=\\mathbf{0}$, which is rare for a fixed $(\\mathbf{k}_1,\\mathbf{k}_2)$ and random $L_1,L_2$; otherwise it equals $0$.\n- A bit-linear reparameterization of the integrand in the first coordinate via an invertible lower-triangular binary matrix $P \\in \\{0,1\\}^{m\\times m}$ corresponds to replacing $\\mathbf{k}_1$ by $P^\\top \\mathbf{k}_1$ in the exponent, thereby breaking the dual-net condition for generic $P$ and driving the average to $0$.\n\nTasks:\n1. Construct a test integrand $f$ that is maximally sensitive to the specific projection onto $(x_1,x_2)$ defined by the given $G_1,G_2$ by choosing $\\mathbf{k}_2 = \\mathbf{e}_r$ (the $r$-th standard basis vector in $\\mathbb{F}_2^m$ for a specified $r$ with $1 \\le r \\le m$) and $\\mathbf{k}_1 = G_2^\\top \\mathbf{e}_r$. This makes $G_1^\\top \\mathbf{k}_1 \\oplus G_2^\\top \\mathbf{k}_2=\\mathbf{0}$ and forces the unscrumbled quasi-Monte Carlo average to be $1$, while the true integral remains $0$.\n2. Implement two mitigation strategies:\n   - Linear scrambling: choose random nonsingular lower-triangular matrices $L_1$ and $L_2$ and compute the scrambled average using $G'_1=L_1G_1$ and $G'_2=L_2G_2$ for the same $(\\mathbf{k}_1,\\mathbf{k}_2)$. If $G_1'^\\top \\mathbf{k}_1 \\oplus G_2'^\\top \\mathbf{k}_2 \\ne \\mathbf{0}$, the scrambled average must be $0$.\n   - Integrand reparameterization: choose an invertible lower-triangular matrix $P$ and replace $\\mathbf{k}_1$ by $P^\\top \\mathbf{k}_1$ in the exponent while using the original $G_1,G_2$. If $G_1^\\top P^\\top \\mathbf{k}_1 \\oplus G_2^\\top \\mathbf{k}_2 \\ne \\mathbf{0}$, the average must be $0$.\n3. Compute the absolute errors $|\\,\\text{QMC average} - 0\\,|$ for the following test suite of parameter values:\n   - Test case $1$: $m=10$, $r=6$, no scrambling, no reparameterization.\n   - Test case $2$: $m=10$, $r=6$, scrambling applied with fixed random seed $123$ for $L_1,L_2$ to ensure reproducibility.\n   - Test case $3$: $m=10$, $r=6$, integrand reparameterization applied with a fixed random seed $456$ for $P$ to ensure reproducibility.\n   - Test case $4$ (boundary condition): $m=5$, $r=3$, no scrambling, no reparameterization.\nYour program must produce a single line of output containing the absolute errors for the test cases as a comma-separated list enclosed in square brackets (for example, \"[error1,error2,error3,error4]\"). All values must be printed as standard decimal floats.\n\nThe answer involves no physical units and no angles; it is purely mathematical. The final program must be complete and runnable as specified and must not require user input or external files.", "solution": "The problem requires the construction and analysis of a pathological test case for a two-dimensional Sobol'-type digital net, followed by the demonstration of two mitigation strategies. The entire analysis leverages the theoretical framework of digital nets over the finite field $\\mathbb{F}_2$ and Walsh functions, which allows for a direct calculation of the quasi-Monte Carlo (QMC) integration error without explicitly generating the point set.\n\nThe core of the problem lies in a fundamental result from the theory of digital nets, which connects the QMC integration error for a specific class of functions to a condition in a \"dual\" space. The test integrand is a two-dimensional Walsh function, $f(x_1, x_2) = \\mathrm{wal}_{k_1}(x_1)\\,\\mathrm{wal}_{k_2}(x_2)$. For any integer wave numbers $(k_1, k_2) \\neq (0,0)$, the true integral is $\\int_{[0,1]^2} f(x_1, x_2)\\,\\mathrm{d}x_1\\,\\mathrm{d}x_2 = 0$. The QMC approximation of this integral using a digital net of $N=2^m$ points is given by $\\frac{1}{N} \\sum_{i=0}^{N-1} f(x_1(i), x_2(i))$.\n\nThe problem provides the crucial \"core fact\" that this QMC average is exactly $1$ if a specific dual-net condition is satisfied, and exactly $0$ otherwise. Let $\\mathbf{k}_1, \\mathbf{k}_2 \\in \\mathbb{F}_2^m$ be the binary representations of the wave numbers $k_1$ and $k_2$, and let $G_1, G_2 \\in \\{0,1\\}^{m \\times m}$ be the generating matrices of the digital net. The QMC average is $1$ if and only if:\n$$\nG_1^\\top \\mathbf{k}_1 \\oplus G_2^\\top \\mathbf{k}_2 = \\mathbf{0} \\in \\mathbb{F}_2^m\n$$\nwhere all operations are performed in the finite field $\\mathbb{F}_2$. Otherwise, the average is $0$. The absolute integration error is therefore $|\\text{QMC average} - 0|$, which is either $1$ or $0$. Our task reduces to checking this algebraic condition for each of the four test cases.\n\nThe specified generating matrices for the digital net are $G_1 = I_m$ (the $m \\times m$ identity matrix) and $G_2$, an $m \\times m$ lower-triangular matrix where $(G_2)_{j,k} = 1$ if $k \\le j$ and $0$ otherwise. Both matrices are invertible over $\\mathbb{F}_2$.\n\n**1. Construction of the Pathological Case (Test Cases 1 and 4)**\n\nThe first task is to construct an integrand (i.e., choose $\\mathbf{k}_1, \\mathbf{k}_2$) that is \"pathological\" for the given $G_1, G_2$. This means we must choose $\\mathbf{k}_1, \\mathbf{k}_2$ such that the dual-net condition is satisfied, forcing the QMC error to be maximal ($1$). The problem directs us to set $\\mathbf{k}_2 = \\mathbf{e}_r$, the $r$-th standard basis vector in $\\mathbb{F}_2^m$ (with a $1$ in the $r$-th position and $0$s elsewhere), and $\\mathbf{k}_1 = G_2^\\top \\mathbf{e}_r$.\n\nLet's verify that this choice satisfies the condition:\n$G_1^\\top \\mathbf{k}_1 \\oplus G_2^\\top \\mathbf{k}_2 = (I_m)^\\top (G_2^\\top \\mathbf{e}_r) \\oplus G_2^\\top (\\mathbf{e}_r)$\nSince $I_m^\\top = I_m$ and matrix multiplication is associative, this becomes:\n$G_2^\\top \\mathbf{e}_r \\oplus G_2^\\top \\mathbf{e}_r$\nIn $\\mathbb{F}_2$, any vector added to itself results in the zero vector ($\\mathbf{v} \\oplus \\mathbf{v} = \\mathbf{0}$). Thus, the condition is met:\n$G_2^\\top \\mathbf{e}_r \\oplus G_2^\\top \\mathbf{e}_r = \\mathbf{0}$\n\nFor this constructed integrand, the QMC average is $1$, and the absolute error is $1$. This applies to Test Case 1 ($m=10, r=6$) and Test Case 4 ($m=5, r=3$). The parameters $m$ and $r$ change the specific vectors $\\mathbf{k}_1$ and $\\mathbf{k}_2$, but the algebraic result remains the same. The error is deterministically $1$.\n\n**2. Mitigation via Linear Scrambling (Test Case 2)**\n\nThis strategy modifies the point set by applying Matoušek-style linear scrambling. The original generating matrices $G_1, G_2$ are replaced by scrambled matrices $G'_1 = L_1 G_1$ and $G'_2 = L_2 G_2$, where $L_1$ and $L_2$ are random, nonsingular, lower-triangular matrices over $\\mathbb{F}_2$. The integrand (defined by $\\mathbf{k}_1, \\mathbf{k}_2$) remains the same as in the pathological case.\n\nThe dual-net condition for the scrambled net is:\n$(G'_1)^\\top \\mathbf{k}_1 \\oplus (G'_2)^\\top \\mathbf{k}_2 = \\mathbf{0}$\nSubstituting $G'_1 = L_1 G_1$ and $G'_2 = L_2 G_2$:\n$(L_1 G_1)^\\top \\mathbf{k}_1 \\oplus (L_2 G_2)^\\top \\mathbf{k}_2 = G_1^\\top L_1^\\top \\mathbf{k}_1 \\oplus G_2^\\top L_2^\\top \\mathbf{k}_2 = \\mathbf{0}$\nWe use the same pathological choice for $\\mathbf{k}_1, \\mathbf{k}_2$ as before: $\\mathbf{k}_1 = G_2^\\top \\mathbf{e}_r$ and $\\mathbf{k}_2 = \\mathbf{e}_r$. The condition becomes:\n$(I_m)^\\top L_1^\\top (G_2^\\top \\mathbf{e}_r) \\oplus G_2^\\top L_2^\\top \\mathbf{e}_r = L_1^\\top (G_2^\\top \\mathbf{e}_r) \\oplus G_2^\\top (L_2^\\top \\mathbf{e}_r) = \\mathbf{0}$\nThis equation must hold for the error to be $1$. However, $L_1$ and $L_2$ are chosen randomly. It is extremely unlikely that this specific linear combination of vectors will result in the zero vector. For almost all choices of $L_1, L_2$, the condition will fail. Therefore, the QMC average will be $0$, and the absolute error will be $0$. The computational part of the solution will verify this for the specific random seed provided.\n\n**3. Mitigation via Integrand Reparameterization (Test Case 3)**\n\nThis strategy leaves the point set unchanged but modifies the integrand. This is equivalent to testing the original net against a different Walsh function, characterized by a new wave vector $(\\mathbf{k}'_1, \\mathbf{k}_2)$. The transformation is defined by $\\mathbf{k}'_1 = P^\\top \\mathbf{k}_1$, where $P$ is a random, invertible, lower-triangular matrix.\n\nThe dual-net condition for the original net and the new wave vector is:\n$G_1^\\top \\mathbf{k}'_1 \\oplus G_2^\\top \\mathbf{k}_2 = \\mathbf{0}$\nSubstituting $\\mathbf{k}'_1 = P^\\top \\mathbf{k}_1$ and using the pathological choice $\\mathbf{k}_1 = G_2^\\top \\mathbf{e}_r, \\mathbf{k}_2 = \\mathbf{e}_r$:\n$G_1^\\top (P^\\top \\mathbf{k}_1) \\oplus G_2^\\top \\mathbf{k}_2 = I_m^\\top P^\\top (G_2^\\top \\mathbf{e}_r) \\oplus G_2^\\top \\mathbf{e}_r = \\mathbf{0}$\nThis simplifies to:\n$P^\\top (G_2^\\top \\mathbf{e}_r) \\oplus G_2^\\top \\mathbf{e}_r = \\mathbf{0}$\nWhich can be factored in $\\mathbb{F}_2$ as:\n$(P^\\top \\oplus I_m) (G_2^\\top \\mathbf{e}_r) = \\mathbf{0}$\nThis condition states that the vector $G_2^\\top \\mathbf{e}_r$ must be in the null space of the matrix $(P^\\top \\oplus I_m)$. Since $P$ is a random lower-triangular matrix with ones on the diagonal, $P^\\top$ is a random upper-triangular matrix. The matrix $P^\\top \\oplus I_m$ will have zeros on its diagonal and random entries in the upper triangle. For a non-zero vector like $G_2^\\top \\mathbf{e}_r$, it is highly improbable that it will fall into the null space of a randomly generated matrix. Thus, the condition is overwhelmingly likely to fail. The QMC average will be $0$, and the error will be $0$. This prediction will be confirmed by computation using the specified random seed.\n\n**Summary of Calculations**\n\nThe solution will be implemented by creating the specified matrices and vectors for each test case and explicitly checking the relevant dual-net condition.\n- **Case 1 ($m=10, r=6$, no mitigation):** Error is $1.0$.\n- **Case 2 ($m=10, r=6$, scrambling):** Check $L_1^\\top (G_2^\\top \\mathbf{e}_6) \\oplus G_2^\\top (L_2^\\top \\mathbf{e}_6) = \\mathbf{0}$. Expected error is $0.0$.\n- **Case 3 ($m=10, r=6$, reparameterization):** Check $(P^\\top \\oplus I_{10}) (G_2^\\top \\mathbf{e}_6) = \\mathbf{0}$. Expected error is $0.0$.\n- **Case 4 ($m=5, r=3$, no mitigation):** Error is $1.0$.\n\nThe implementation will generate the random matrices $L_1, L_2, P$ as nonsingular lower-triangular matrices by setting their diagonals to $1$ and choosing the strictly lower-triangular entries randomly from $\\{0, 1\\}$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes integration errors for four test cases involving a pathological\n    integrand for a 2D Sobol' sequence and two mitigation strategies.\n    The error is determined by checking an algebraic condition (the dual-net condition)\n    over the finite field F_2.\n    \"\"\"\n\n    def make_random_lt_matrix(m, rng):\n        \"\"\"\n        Generates a random m x m nonsingular lower-triangular matrix over F_2.\n        Nonsingularity is guaranteed by setting the diagonal to all 1s.\n        The strictly lower triangular part is filled with random 0s or 1s.\n        \"\"\"\n        mat = np.identity(m, dtype=int)\n        for i in range(1, m):\n            for j in range(i):\n                mat[i, j] = rng.integers(0, 2)\n        return mat\n\n    def calculate_qmc_average(m, r, scramble_seed, reparam_seed):\n        \"\"\"\n        Calculates the QMC average (0 or 1) based on the dual-net condition.\n        The absolute error is equal to this average since the true integral is 0.\n        \n        Args:\n            m (int): Number of bits, defines the number of points N = 2^m.\n            r (int): Index (1-based) for constructing the pathological wave vector.\n            scramble_seed (int or None): Seed for random scrambling matrices.\n            reparam_seed (int or None): Seed for random reparameterization matrix.\n            \n        Returns:\n            float: The absolute error of the QMC approximation (1.0 or 0.0).\n        \"\"\"\n        # Define generating matrices G1 and G2 over F_2.\n        # G1 is the m x m identity matrix.\n        G1 = np.identity(m, dtype=int)\n        # G2 is the m x m lower-triangular matrix of ones.\n        G2 = np.tril(np.ones((m, m), dtype=int))\n\n        # Construct the pathological wave vectors k1 and k2.\n        # k2 is the r-th standard basis vector (using 0-based indexing for r-1).\n        k2 = np.zeros(m, dtype=int)\n        k2[r - 1] = 1\n        \n        # k1 is constructed to satisfy the dual-net condition for the base case.\n        # All matrix and vector operations are implicitly mod 2.\n        k1 = (G2.T @ k2) % 2\n        \n        # Initialize effective matrices and wave vectors\n        G1_T = G1.T\n        G2_T = G2.T\n        k1_eff = k1\n        k2_eff = k2\n\n        if scramble_seed is not None:\n            # Case 2: Linear Scrambling\n            rng = np.random.default_rng(scramble_seed)\n            L1 = make_random_lt_matrix(m, rng)\n            L2 = make_random_lt_matrix(m, rng)\n            \n            # Scrambled matrices G' = L*G. Their transposes are G.T * L.T\n            G1_scrambled = (L1 @ G1) % 2\n            G2_scrambled = (L2 @ G2) % 2\n            G1_T = G1_scrambled.T\n            G2_T = G2_scrambled.T\n            # Wave vectors k1, k2 are unchanged\n            \n        elif reparam_seed is not None:\n            # Case 3: Integrand Reparameterization\n            rng = np.random.default_rng(reparam_seed)\n            P = make_random_lt_matrix(m, rng)\n            \n            # Generating matrices G1, G2 are unchanged\n            # The wave vector k1 is replaced by k1' = P.T @ k1\n            k1_eff = (P.T @ k1) % 2\n            # k2 is unchanged\n\n        # Check the dual-net condition: G1_eff.T @ k1_eff + G2_eff.T @ k2_eff == 0 (mod 2)\n        test_vector = (G1_T @ k1_eff + G2_T @ k2_eff) % 2\n\n        # If the test_vector is the zero vector, the condition holds.\n        if np.all(test_vector == 0):\n            qmc_average = 1.0\n        else:\n            qmc_average = 0.0\n            \n        # The true integral is 0, so the absolute error is |qmc_average - 0|.\n        return qmc_average\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (m, r, scramble_seed, reparam_seed)\n        (10, 6, None, None),      # Case 1: m=10, r=6, no mitigation\n        (10, 6, 123, None),       # Case 2: m=10, r=6, scrambling\n        (10, 6, None, 456),       # Case 3: m=10, r=6, reparameterization\n        (5, 3, None, None),       # Case 4: m=5, r=3, no mitigation\n    ]\n\n    results = []\n    for m, r, s_seed, p_seed in test_cases:\n        error = calculate_qmc_average(m, r, s_seed, p_seed)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3345410"}]}