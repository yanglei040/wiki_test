{"hands_on_practices": [{"introduction": "To solidify our understanding of the Propp-Wilson algorithm, we begin with a foundational exercise. By analyzing a small, manageable birth-death Markov chain, we can move beyond abstract definitions to a concrete calculation [@problem_id:3356322]. This practice will guide you through deriving the exact probability of coalescence from first principles, providing a clear window into the dynamics of how the coupled upper and lower bounding chains converge over time.", "problem": "Consider a time-homogeneous birth–death Markov chain on the finite partially ordered state space $\\{0,1,2\\}$, with the following transition probabilities at each discrete time step:\n- From state $0$: move to $1$ with probability $1/2$, stay at $0$ with probability $1/2$.\n- From state $1$: move to $0$ with probability $1/4$, stay at $1$ with probability $1/4$, move to $2$ with probability $1/2$.\n- From state $2$: move to $1$ with probability $1/2$, stay at $2$ with probability $1/2$.\n\nAssume the update rule is implemented by a single collection of independent and identically distributed random inputs: at each time $n$, an input $U_{n}$ is drawn from the Uniform$(0,1)$ distribution, and the next state is given by a threshold mapping $F(i,U_{n})$ defined for each current state $i \\in \\{0,1,2\\}$ as follows:\n$$\nF(0,u) = \\begin{cases}\n0,  0 \\le u  \\tfrac{1}{2},\\\\\n1,  \\tfrac{1}{2} \\le u \\le 1,\n\\end{cases}\n\\quad\nF(1,u) = \\begin{cases}\n0,  0 \\le u  \\tfrac{1}{4},\\\\\n1,  \\tfrac{1}{4} \\le u  \\tfrac{1}{2},\\\\\n2,  \\tfrac{1}{2} \\le u \\le 1,\n\\end{cases}\n\\quad\nF(2,u) = \\begin{cases}\n1,  0 \\le u  \\tfrac{1}{2},\\\\\n2,  \\tfrac{1}{2} \\le u \\le 1.\n\\end{cases}\n$$\n\nThis update function is monotone with respect to the natural order on $\\{0,1,2\\}$, so the Propp–Wilson Coupling From The Past (CFTP) method can be implemented using the sandwiching approach: given a time horizon $t \\in \\mathbb{N}$, start at time $-t$ with the lower and upper bounding states $L_{0}=0$ and $U_{0}=2$, and apply the same update inputs $U_{-t}, U_{-(t-1)}, \\dots, U_{-1}$ forward to time $0$ to obtain the bounding images $L_{t}$ and $U_{t}$. Coalescence by time $t$ occurs if and only if $L_{t} = U_{t}$.\n\nUsing only the foundational definitions of monotone Markov chains, the Propp–Wilson CFTP, and the above update rule, derive from first principles the exact closed-form expression (as a function of $t$) for the probability that coalescence occurs by time $t$ under this sandwiching scheme. Your final answer must be a single analytic expression. No rounding is required and no units should be included.", "solution": "The problem asks for the probability of coalescence by time $t$ for a Propp-Wilson Coupling From The Past (CFTP) process. The process is defined on the state space $S = \\{0, 1, 2\\}$ with the natural ordering $0 \\le 1 \\le 2$. The CFTP algorithm is implemented using a sandwiching approach, starting with a lower chain $L$ and an upper chain $U$ at the extremal states. The simulation runs for a time horizon of $t$ steps, from time $-t$ to time $0$.\n\nLet the state of the lower chain at a given time be denoted by $l$ and the upper chain by $u$. The simulation starts at time $-t$ with $l_{-t} = 0$ and $u_{-t} = 2$. At each step $k$ from $-t$ to $-1$, both chains are updated using the same random number $U_k \\sim \\text{Uniform}(0,1)$ and the monotone update function $F(i,u)$. Let the states of the chains after $n$ steps of the simulation (i.e., at time $-t+n$) be $(l_n, u_n)$. The initial state of this pair-process is $(l_0, u_0) = (0,2)$. The state after $n$ steps is $(l_n, u_n) = (F(l_{n-1}, U_{n-1}), F(u_{n-1}, U_{n-1}))$. We are interested in the probability that the chains coalesce after $t$ steps, i.e., $P(l_t = u_t)$.\n\nDue to the monotonicity of $F$, we are guaranteed that $l_n \\le u_n$ for all $n \\ge 0$. The state of the pair-process $(l_n, u_n)$ is an element of $\\{(i,j) \\in S \\times S \\mid i \\le j\\}$.\nCoalescence occurs when $l_n = u_n$. The states $(0,0)$, $(1,1)$, and $(2,2)$ are therefore absorbing states for the pair-process. Once a pair $(i,i)$ is reached, all subsequent states will be $(F(i,U), F(i,U))$, which means the chains remain coalesced.\n\nThe non-coalesced, or transient, states for the pair-process are $(0,1)$, $(0,2)$, and $(1,2)$. Let us analyze the transitions between these transient states. Let the random variable $U$ be drawn from $\\text{Uniform}(0,1)$. The next state $(l', u')$ is given by $(F(l,U), F(u,U))$.\n\nLet's define three states for our analysis of the non-coalesced dynamics:\n- State $A$: The pair is $(0,2)$.\n- State $B$: The pair is $(0,1)$.\n- State $C$: The pair is $(1,2)$.\n- State $D$: The chains have coalesced (the pair is in $\\{(0,0), (1,1), (2,2)\\}$). State $D$ is absorbing.\n\nThe initial state of the simulation is $(l_0, u_0) = (0,2)$, which is State $A$.\n\nWe now compute the single-step transition probabilities for states $A, B, C$.\n1.  From State $A = (0,2)$:\n    - If $U \\in [0, \\frac{1}{2})$: $l' = F(0,U)=0$, $u' = F(2,U)=1$. The new state is $(0,1)$, which is $B$. The probability is $P(U  \\frac{1}{2}) = \\frac{1}{2}$.\n    - If $U \\in [\\frac{1}{2}, 1]$: $l' = F(0,U)=1$, $u' = F(2,U)=2$. The new state is $(1,2)$, which is $C$. The probability is $P(U \\ge \\frac{1}{2}) = \\frac{1}{2}$.\n    - Transition Summary: $P(A \\to A) = 0$, $P(A \\to B) = \\frac{1}{2}$, $P(A \\to C) = \\frac{1}{2}$, $P(A \\to D) = 0$.\n\n2.  From State $B = (0,1)$:\n    - If $U \\in [0, \\frac{1}{4})$: $l' = F(0,U)=0$, $u' = F(1,U)=0$. The new state is $(0,0)$, which is $D$ (coalescence). The probability is $P(U  \\frac{1}{4}) = \\frac{1}{4}$.\n    - If $U \\in [\\frac{1}{4}, \\frac{1}{2})$: $l' = F(0,U)=0$, $u' = F(1,U)=1$. The new state is $(0,1)$, which is $B$. The probability is $P(\\frac{1}{4} \\le U  \\frac{1}{2}) = \\frac{1}{4}$.\n    - If $U \\in [\\frac{1}{2}, 1]$: $l' = F(0,U)=1$, $u' = F(1,U)=2$. The new state is $(1,2)$, which is $C$. The probability is $P(U \\ge \\frac{1}{2}) = \\frac{1}{2}$.\n    - Transition Summary: $P(B \\to B) = \\frac{1}{4}$, $P(B \\to C) = \\frac{1}{2}$, $P(B \\to D) = \\frac{1}{4}$.\n\n3.  From State $C = (1,2)$:\n    - If $U \\in [0, \\frac{1}{4})$: $l' = F(1,U)=0$, $u' = F(2,U)=1$. The new state is $(0,1)$, which is $B$. The probability is $P(U  \\frac{1}{4}) = \\frac{1}{4}$.\n    - If $U \\in [\\frac{1}{4}, \\frac{1}{2})$: $l' = F(1,U)=1$, $u' = F(2,U)=1$. The new state is $(1,1)$, which is $D$ (coalescence). The probability is $P(\\frac{1}{4} \\le U  \\frac{1}{2}) = \\frac{1}{4}$.\n    - If $U \\in [\\frac{1}{2}, 1]$: $l' = F(1,U)=2$, $u' = F(2,U)=2$. The new state is $(2,2)$, which is $D$ (coalescence). The probability is $P(U \\ge \\frac{1}{2}) = \\frac{1}{2}$.\n    - Transition Summary: $P(C \\to B) = \\frac{1}{4}$, $P(C \\to D) = \\frac{1}{4} + \\frac{1}{2} = \\frac{3}{4}$.\n\nLet $p_n(S)$ be the probability of being in a transient state $S \\in \\{A, B, C\\}$ after $n$ steps. Let $v_n = [p_n(A), p_n(B), p_n(C)]^T$ be the column vector of these probabilities. The evolution of this vector is given by $v_{n+1} = T v_n$, where $T$ is the transition matrix for the transient states.\n$$\nT = \\begin{pmatrix}\nP(A \\to A)  P(B \\to A)  P(C \\to A) \\\\\nP(A \\to B)  P(B \\to B)  P(C \\to B) \\\\\nP(A \\to C)  P(B \\to C)  P(C \\to C)\n\\end{pmatrix} = \\begin{pmatrix}\n0  0  0 \\\\\n\\frac{1}{2}  \\frac{1}{4}  \\frac{1}{4} \\\\\n\\frac{1}{2}  \\frac{1}{2}  0\n\\end{pmatrix}\n$$\nThe simulation starts in state $A$, so the initial probability vector is $v_0 = [1, 0, 0]^T$. After $t$ steps, the vector of probabilities is $v_t = T^t v_0$. The probability of not having coalesced by time $t$, $S_t$, is the sum of the components of $v_t$. The desired probability of coalescence is $P_c(t) = 1 - S_t$.\n\nTo compute $T^t$, we find the eigenvalues and eigenvectors of $T$. The characteristic equation is $\\det(T - \\lambda I) = 0$:\n$$ \\det \\begin{pmatrix} -\\lambda  0  0 \\\\ \\frac{1}{2}  \\frac{1}{4}-\\lambda  \\frac{1}{4} \\\\ \\frac{1}{2}  \\frac{1}{2}  -\\lambda \\end{pmatrix} = -\\lambda \\left( \\left(\\frac{1}{4}-\\lambda\\right)(-\\lambda) - \\left(\\frac{1}{4}\\right)\\left(\\frac{1}{2}\\right) \\right) = -\\lambda \\left( \\lambda^2 - \\frac{1}{4}\\lambda - \\frac{1}{8} \\right) = 0 $$\nThe eigenvalues are $\\lambda_3 = 0$ and the roots of $8\\lambda^2 - 2\\lambda - 1 = 0$, which are $\\lambda = \\frac{2 \\pm \\sqrt{4 - 4(8)(-1)}}{16} = \\frac{2 \\pm 6}{16}$.\nSo, the eigenvalues are $\\lambda_1 = \\frac{8}{16} = \\frac{1}{2}$, $\\lambda_2 = \\frac{-4}{16} = -\\frac{1}{4}$, and $\\lambda_3 = 0$.\n\nNext, we find the corresponding eigenvectors:\n- For $\\lambda_1 = \\frac{1}{2}$: $(T - \\frac{1}{2}I)x = 0$ leads to the eigenvector $e_1 = [0, 1, 1]^T$.\n- For $\\lambda_2 = -\\frac{1}{4}$: $(T + \\frac{1}{4}I)x = 0$ leads to the eigenvector $e_2 = [0, 1, -2]^T$.\n- For $\\lambda_3 = 0$: $Tx = 0$ leads to the eigenvector $e_3 = [1, -1, -1]^T$.\n\nWe express the initial vector $v_0$ as a linear combination of eigenvectors: $v_0 = c_1 e_1 + c_2 e_2 + c_3 e_3$.\n$$ \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix} = c_1 \\begin{pmatrix} 0 \\\\ 1 \\\\ 1 \\end{pmatrix} + c_2 \\begin{pmatrix} 0 \\\\ 1 \\\\ -2 \\end{pmatrix} + c_3 \\begin{pmatrix} 1 \\\\ -1 \\\\ -1 \\end{pmatrix} = \\begin{pmatrix} c_3 \\\\ c_1 + c_2 - c_3 \\\\ c_1 - 2c_2 - c_3 \\end{pmatrix} $$\nThis gives a system of linear equations for $(c_1, c_2, c_3)$, which solves to $c_1=1$, $c_2=0$, $c_3=1$.\nSo, $v_0 = e_1 + e_3$.\n\nNow we can compute $v_t = T^t v_0$:\n$$ v_t = T^t(e_1 + e_3) = T^t e_1 + T^t e_3 = \\lambda_1^t e_1 + \\lambda_3^t e_3 $$\nThe problem specifies $t \\in \\mathbb{N}$, which is typically interpreted as $t \\ge 1$. For $t \\ge 1$, $\\lambda_3^t = 0^t = 0$.\n$$ v_t = \\left(\\frac{1}{2}\\right)^t e_1 = \\left(\\frac{1}{2}\\right)^t \\begin{pmatrix} 0 \\\\ 1 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ (\\frac{1}{2})^t \\\\ (\\frac{1}{2})^t \\end{pmatrix} $$\nThis vector gives the probabilities of being in states $A, B, C$ after $t$ steps.\n$p_t(A) = 0$, $p_t(B) = (\\frac{1}{2})^t$, $p_t(C) = (\\frac{1}{2})^t$.\n\nThe probability of not having coalesced by time $t$, $S_t$, is the sum of these probabilities:\n$$ S_t = p_t(A) + p_t(B) + p_t(C) = 0 + \\left(\\frac{1}{2}\\right)^t + \\left(\\frac{1}{2}\\right)^t = 2 \\left(\\frac{1}{2}\\right)^t = \\left(\\frac{1}{2}\\right)^{t-1} $$\nThis result is valid for $t \\ge 1$.\n\nFinally, the probability that coalescence occurs by time $t$, $P_c(t)$, is $1$ minus the probability of not having coalesced:\n$$ P_c(t) = 1 - S_t = 1 - \\left(\\frac{1}{2}\\right)^{t-1} $$\nThis can be rewritten as $1 - 2^{1-t}$. This is the closed-form expression for the coalescence probability as a function of the time horizon $t$.\nFor $t=1$, $P_c(1) = 1 - 2^0 = 0$. This is correct, as the first step can only lead to non-coalesced states $(0,1)$ or $(1,2)$.\nFor $t \\to \\infty$, $P_c(t) \\to 1$, as expected for an irreducible and aperiodic finite-state Markov chain.", "answer": "$$\n\\boxed{1 - 2^{1-t}}\n$$", "id": "3356322"}, {"introduction": "The power of monotone CFTP lies in its ability to exploit a system's ordered structure, but what happens when no such exploitable order exists? This practice explores a classic scenario from statistical physics—the antiferromagnetic Ising model on a non-bipartite graph—where the crucial monotonicity condition cannot be met due to a property known as 'frustration' [@problem_id:3356306]. By analyzing this counterexample, you will understand the precise limitations of the standard algorithm and appreciate the motivation for more general perfect sampling methods like Dominated CFTP (DCFTP).", "problem": "Consider an undirected finite graph $G=(V,E)$ and the Ising model with spins $\\sigma_i \\in \\{-1,+1\\}$ for $i \\in V$, Gibbs distribution proportional to $\\exp\\big(\\sum_{\\{i,j\\}\\in E} J_{ij}\\sigma_i\\sigma_j + \\sum_{i\\in V} h_i \\sigma_i\\big)$, and single-site heat-bath Glauber dynamics. Recall the following foundational notions.\n\n- A Markov chain update is monotone with respect to the product partial order on $\\{-1,+1\\}^V$ if, when two configurations satisfy $\\sigma \\le \\tau$ coordinatewise, then the update map at any site $i$ can be coupled so that the post-update spins also satisfy $\\sigma' \\le \\tau'$ almost surely. For the Ising heat-bath update at site $i$, the conditional probability $p_i(\\sigma_{-i}) := \\mathbb{P}(\\sigma_i=+1 \\mid \\sigma_{-i})$ is nondecreasing in each neighbor spin $\\sigma_j$ if and only if the couplings $\\{J_{ij}\\}_{j\\sim i}$ are all nonnegative.\n\n- A node-wise sign transformation is a map $\\tau_i = s_i \\sigma_i$ with $s_i \\in \\{-1,+1\\}$ for each $i \\in V$, which sends couplings to $J'_{ij} = J_{ij} s_i s_j$ and fields to $h'_i = h_i s_i$.\n\n- A graph $G$ is bipartite if and only if its vertex set admits a $2$-coloring $V = U \\cup W$ such that every edge has one endpoint in $U$ and one in $W$. Equivalently, $G$ contains no odd cycle.\n\n- The Propp–Wilson algorithm for Coupling From The Past (CFTP) in its monotone form requires a partial order with top and bottom elements and a monotone update map to ensure coalescence from extremal initial states. Dominated Coupling From The Past (DCFTP) constructs a backward-in-time dependency graph controlled by a stochastically dominating process; if this backward exploration almost surely terminates, an exact sample can be produced without monotonicity.\n\nFocus on the antiferromagnetic case on the triangle $C_3$ with uniform pairwise couplings $J_{ij} = -\\beta$ for all $\\{i,j\\}\\in E$ and external fields $h_i=0$ for all $i\\in V$, where $\\beta0$ is fixed. Analyze the effect of non-bipartiteness on the existence of monotone transformations and on the feasibility of perfect sampling.\n\nWhich of the following statements are correct?\n\nA. There exists a choice of signs $\\{s_i\\}_{i\\in V}$ such that the node-wise sign transformation $\\tau_i = s_i \\sigma_i$ sends the antiferromagnetic Ising model on $C_3$ into a ferromagnetic model with $J'_{ij} \\ge 0$ for all $\\{i,j\\}\\in E$, thereby enabling monotone Propp–Wilson CFTP from the top and bottom elements.\n\nB. On any non-bipartite graph, and in particular on $C_3$, no node-wise sign transformation can make all transformed couplings $J'_{ij}$ nonnegative when all original couplings $J_{ij}0$. Consequently, the heat-bath update is not attractive under any product order, and the standard monotone Propp–Wilson CFTP with top and bottom bounding chains cannot be applied.\n\nC. Even without attractiveness, for sufficiently small $\\beta$ (high temperature), there exist perfect simulation schemes based on Dominated Coupling From The Past (DCFTP) that construct a backward dependency graph dominated by a subcritical branching process guaranteed to die out almost surely, yielding exact samples for the antiferromagnetic Ising model on $C_3$.\n\nD. The failure of bipartiteness implies the nonexistence of any perfect sampling algorithm for the model on $C_3$, since monotonicity is a necessary condition for perfect sampling.\n\nE. By modifying the dynamics to block-update two adjacent spins at a time with a heat-bath rule, one always recovers a monotone update map on $C_3$, so monotone Propp–Wilson CFTP becomes applicable regardless of $\\beta$.", "solution": "The problem asks for an analysis of the antiferromagnetic Ising model on a triangle graph $C_3$ concerning the applicability of perfect sampling algorithms like Coupling From The Past (CFTP).\n\nThe model is defined on the graph $G=(V,E)$ where $V=\\{1,2,3\\}$ and $E=\\{\\{1,2\\}, \\{2,3\\}, \\{3,1\\}\\}$. The Gibbs distribution is proportional to $\\exp\\big(\\sum_{\\{i,j\\}\\in E} J_{ij}\\sigma_i\\sigma_j\\big)$ with couplings $J_{ij} = -\\beta$ for a constant $\\beta0$ and external fields $h_i=0$. The Hamiltonian is $H(\\sigma) = -\\sum_{\\{i,j\\}\\in E} J_{ij}\\sigma_i\\sigma_j = \\beta(\\sigma_1\\sigma_2 + \\sigma_2\\sigma_3 + \\sigma_3\\sigma_1)$. The system seeks to minimize this energy, which favors anti-alignment of neighboring spins, typical of an antiferromagnet.\n\nThe standard monotone Propp-Wilson CFTP algorithm for single-site heat-bath dynamics requires the update rule to be monotone. This holds if and only if all couplings $J_{ij}$ are non-negative (ferromagnetic model). The problem explores whether the given antiferromagnetic model can be rendered ferromagnetic via a node-wise sign transformation $\\tau_i = s_i \\sigma_i$, where $s_i \\in \\{-1, +1\\}$. Such a transformation changes the couplings to $J'_{ij} = J_{ij} s_i s_j$. For our model, $J'_{ij} = (-\\beta) s_i s_j$. To make these non-negative, we need $s_i s_j = -1$ for all adjacent pairs $\\{i,j\\}$. This implies that adjacent vertices must have different signs. This is equivalent to finding a $2$-coloring for the graph $G$. A graph is $2$-colorable if and only if it is bipartite (contains no odd-length cycles). The graph $C_3$ is a cycle of length $3$, which is odd, and thus it is not bipartite. Therefore, it is impossible to find signs $\\{s_i\\}$ that make all transformed couplings $J'_{ij}$ non-negative. This phenomenon, where antiferromagnetic interactions on a non-bipartite graph cannot all be simultaneously satisfied, is called frustration.\n\nNow we evaluate each statement.\n\n**A. There exists a choice of signs $\\{s_i\\}_{i\\in V}$ such that the node-wise sign transformation $\\tau_i = s_i \\sigma_i$ sends the antiferromagnetic Ising model on $C_3$ into a ferromagnetic model with $J'_{ij} \\ge 0$ for all $\\{i,j\\}\\in E$, thereby enabling monotone Propp–Wilson CFTP from the top and bottom elements.**\n\nAs demonstrated, such a sign transformation is equivalent to finding a $2$-coloring of the graph $C_3$. Since $C_3$ is an odd cycle, it is not bipartite and thus not $2$-colorable. No such choice of signs $\\{s_i\\}$ exists. The product of the required sign relations along the cycle gives $(s_1 s_2)(s_2 s_3)(s_3 s_1) = (-1)^3 = -1$, while algebraically the expression is $s_1^2 s_2^2 s_3^2=1$, a contradiction. Therefore, the model cannot be transformed into a ferromagnetic one, and this route to applying monotone CFTP is closed.\n**Verdict: Incorrect.**\n\n**B. On any non-bipartite graph, and in particular on $C_3$, no node-wise sign transformation can make all transformed couplings $J'_{ij}$ nonnegative when all original couplings $J_{ij}0$. Consequently, the heat-bath update is not attractive under any product order, and the standard monotone Propp–Wilson CFTP with top and bottom bounding chains cannot be applied.**\n\nThis statement is correct. The first part is the general principle of frustration discussed above: an antiferromagnetic model on a non-bipartite graph cannot be gauge-transformed into a ferromagnetic one. The second part is a direct consequence. The attractiveness (monotonicity) of single-site heat-bath dynamics with respect to the standard product order on $\\{-1,+1\\}^V$ requires all couplings $J_{ij}$ to be non-negative. Attractiveness with respect to a different product order (related by signs $\\{s_i\\}$) is equivalent to attractiveness of the transformed variables $\\{\\tau_i\\}$ with respect to the standard order, which requires all $J'_{ij}$ to be non-negative. Since this cannot be achieved, the dynamics are not attractive under any product order. The standard monotone Propp-Wilson CFTP algorithm's mechanism of coupling chains starting from the extremal states (all $+1$s and all $-1$s) relies fundamentally on this attractiveness property. Without it, the algorithm is not applicable in its standard form.\n**Verdict: Correct.**\n\n**C. Even without attractiveness, for sufficiently small $\\beta$ (high temperature), there exist perfect simulation schemes based on Dominated Coupling From The Past (DCFTP) that construct a backward dependency graph dominated by a subcritical branching process guaranteed to die out almost surely, yielding exact samples for the antiferromagnetic Ising model on $C_3$.**\n\nThis statement correctly describes an alternative perfect sampling method, DCFTP, which does not require monotonicity. Its convergence depends on the dependencies in the system being sufficiently weak. For the Ising model, this corresponds to the high-temperature regime (small $\\beta$). In this regime, the system satisfies conditions like the Dobrushin uniqueness condition, which implies that the influence of any single spin on another decays rapidly. The backward dependency exploration of DCFTP can then be stochastically dominated by a simple process, like a Galton-Watson branching process. If the expected number of \"offspring\" in this dominating process is less than $1$ (i.e., it is subcritical), the process dies out almost surely, meaning the DCFTP algorithm terminates and produces an exact sample. For any finite-range Ising model on a finite graph, including our case on $C_3$, such a high-temperature regime always exists for sufficiently small $\\beta$.\n**Verdict: Correct.**\n\n**D. The failure of bipartiteness implies the nonexistence of any perfect sampling algorithm for the model on $C_3$, since monotonicity is a necessary condition for perfect sampling.**\n\nThis statement is factually incorrect. Monotonicity is a sufficient, but not necessary, condition for perfect sampling. As established in the analysis of option C, the DCFTP algorithm is a valid perfect sampling method that does not require monotonicity and can be applied to the antiferromagnetic Ising model on $C_3$ in the high-temperature regime. The existence of DCFTP provides a direct counterexample to the claim that no perfect sampling algorithm exists.\n**Verdict: Incorrect.**\n\n**E. By modifying the dynamics to block-update two adjacent spins at a time with a heat-bath rule, one always recovers a monotone update map on $C_3$, so monotone Propp–Wilson CFTP becomes applicable regardless of $\\beta$.**\n\nThis statement proposes to recover monotonicity by using a block update. Let's analyze the update of the block of spins $\\{\\sigma_1, \\sigma_2\\}$ conditional on the state of spin $\\sigma_3$. The heat-bath rule for the block means sampling from the conditional Gibbs distribution $\\mathbb{P}(\\sigma_1, \\sigma_2 \\mid \\sigma_3) \\propto \\exp(-H(\\sigma_1,\\sigma_2|\\sigma_3))$, where $H$ is the Hamiltonian. The relevant part of the Hamiltonian is $H = \\beta(\\sigma_1\\sigma_2 + \\sigma_2\\sigma_3 + \\sigma_3\\sigma_1)$. The conditional probability is proportional to $\\exp(-\\beta\\sigma_1\\sigma_2 - \\beta\\sigma_3(\\sigma_1+\\sigma_2))$. To check for monotonicity, we analyze how this distribution changes as $\\sigma_3$ flips from $-1$ to $+1$. The ratio of probabilities is:\n$$ \\frac{\\mathbb{P}(\\sigma_1, \\sigma_2 \\mid \\sigma_3=+1)}{\\mathbb{P}(\\sigma_1, \\sigma_2 \\mid \\sigma_3=-1)} = \\frac{\\exp(-\\beta\\sigma_1\\sigma_2 - \\beta(\\sigma_1+\\sigma_2))}{\\exp(-\\beta\\sigma_1\\sigma_2 + \\beta(\\sigma_1+\\sigma_2))} = \\exp(-2\\beta(\\sigma_1+\\sigma_2)) $$\nThis ratio decreases as the sum $\\sigma_1+\\sigma_2$ increases. For example, when $\\sigma_3$ flips from $-1$ to $+1$, the state $(\\sigma_1, \\sigma_2) = (+1,+1)$ (with sum $2$) becomes less likely relative to the state $(-1,-1)$ (with sum $-2$). This is the definition of anti-monotonicity with respect to the standard product order on the block. The update does not recover monotonicity; it reverses it. The claim that this works \"always\" and \"regardless of $\\beta$\" is false.\n**Verdict: Incorrect.**", "answer": "$$\\boxed{BC}$$", "id": "3356306"}, {"introduction": "This final practice bridges the gap between theory and implementation by tackling a canonical problem in computational statistical physics. You will engage with the Fortuin–Kasteleyn (FK) random-cluster representation of the Potts model, a powerful framework for studying phase transitions [@problem_id:3356348]. The task involves implementing a working monotone CFTP for the FK model's heat-bath dynamics and, contrastingly, demonstrating why a naive attempt to apply a similar scheme to the related Swendsen–Wang algorithm is impractical, offering deep insight into the subtleties of designing a valid coupling.", "problem": "You are tasked with designing, analyzing, and implementing a program that explores the use of Coupling From The Past (CFTP) and dominated CFTP ideas for exact sampling in ferromagnetic Potts models via the Fortuin–Kasteleyn (FK) representation. The focus is on the monotone CFTP feasibility for Swendsen–Wang dynamics by defining a partial order on bond configurations, and assessing the practicality of coalescence detection under that order.\n\nThe following fundamental base must be used, without shortcuts:\n- A finite undirected graph is given by a vertex set $V$ with $\\lvert V \\rvert = n$ and an edge set $E \\subseteq \\{ \\{u,v\\} : u,v \\in V, u \\neq v \\}$ with $\\lvert E \\rvert = m$.\n- The $q$-state ferromagnetic Potts model on a graph $G=(V,E)$ has spins $\\sigma \\in \\{1,2,\\dots,q\\}^{V}$ with probability proportional to $\\exp\\left(\\beta \\sum_{\\{u,v\\}\\in E} \\mathbf{1}\\{\\sigma(u)=\\sigma(v)\\}\\right)$ for inverse temperature $\\beta \\ge 0$.\n- The Edwards–Sokal (ES) coupling relates the Potts model with the FK random-cluster measure with parameters $(p,q)$ where $p = 1 - e^{-\\beta}$; the FK measure on bond configurations $\\omega \\in \\{0,1\\}^{E}$ has probability proportional to $p^{\\lvert \\omega \\rvert} (1-p)^{m - \\lvert \\omega \\rvert} q^{k(\\omega)}$, where $k(\\omega)$ is the number of connected components in the subgraph induced by the open edges $\\{e \\in E : \\omega(e)=1\\}$.\n- The Swendsen–Wang (SW) dynamics uses the ES coupling: given a spin configuration $\\sigma_t$, bonds $B_t$ are opened independently on edges $\\{u,v\\}$ with probability $p$ if and only if $\\sigma_t(u)=\\sigma_t(v)$; then each connected component of $(V, B_t)$ is assigned a new spin uniformly from $\\{1,\\dots,q\\}$, independently across components.\n- A partial order on bond configurations is the coordinate-wise inclusion: for $\\omega, \\omega' \\in \\{0,1\\}^{E}$, define $\\omega \\preceq \\omega'$ if and only if $\\{e \\in E : \\omega(e)=1\\} \\subseteq \\{e \\in E : \\omega'(e)=1\\}$.\n\nYour program must carry out two experiments and report coalescence viability under CFTP-style constructions:\n1. Monotone CFTP for FK random-cluster single-edge heat-bath dynamics:\n   - Consider the heat-bath update on a single edge $e = \\{u,v\\}$ chosen uniformly from $E$. Given the current bond configuration $\\omega$, let $\\omega^{\\setminus e}$ denote the configuration with edge $e$ removed. The conditional open probability for $\\omega(e)$ is:\n     - If $u$ and $v$ are connected in the graph induced by the open edges of $\\omega^{\\setminus e}$, then set $\\mathbb{P}(\\omega(e)=1 \\mid \\omega^{\\setminus e}) = p$.\n     - Otherwise, set $\\mathbb{P}(\\omega(e)=1 \\mid \\omega^{\\setminus e}) = \\dfrac{p}{p + (1-p) q}$.\n   - This chain is known to be attractive for $q \\ge 1$ under the inclusion order. Use a grand coupling driven by a fixed sequence of edge choices and independent uniform variables to implement monotone CFTP with the inclusion order. Use a doubling schedule: simulate the chain from time $-1$ to $0$, then from $-2$ to $0$, then from $-4$ to $0$, and so on, using the same driving randomness. Start lower and upper chains at the minimal and maximal bond configurations (all edges closed and all edges open, respectively). Declare coalescence when the lower and upper configurations agree at time $0$.\n   - The coalescence time you must report for a test case is the number of single-edge updates in the smallest doubling window that yields coalescence. If no coalescence is detected up to a specified maximum window size, report $-1$.\n\n2. Attempted monotone CFTP for Swendsen–Wang via bond-order domination:\n   - Define the bond-order partial order $\\preceq$ as above. For SW, the bond formation at time $t$ uses per-edge uniforms $U_{t,e} \\sim \\mathrm{Uniform}(0,1)$ and opens $\\{u,v\\}$ if and only if $U_{t,e}  p$ and spins are equal. A naive dominated bounding in bond space ignores spins and proposes an upper bounding bond set $U_t^{\\mathrm{up}} = \\{ e \\in E : U_{t,e}  p \\}$ and a lower bounding bond set $U_t^{\\mathrm{low}} = \\varnothing$ at each time $t$.\n   - Implement a doubling schedule similar to the FK case, but with the naive bond-order bounds above; your “upper” and “lower” bond sets for each time step are driven solely by the uniforms $U_{t,e}$. Under this naive scheme, declare coalescence only if the upper and lower bound processes necessarily coincide at time $0$ for all possible spin paths. A necessary condition in this naive scheme is that $U_{t,e} \\ge p$ for all $e \\in E$ at every time step in the simulation window, in which case both bounds force $\\varnothing$ for the bond configuration and SW spin recoloring becomes irrelevant. If this condition is not met up to the maximum window, report $-1$ as a failure to detect coalescence.\n   - This construction serves to assess practicality: it is expected to detect coalescence only in trivial or near-trivial regimes (e.g., $p=0$).\n\nYour implementation constraints:\n- All graphs must be treated as abstract finite undirected graphs with vertex indices $0,1,\\dots,n-1$ and edges specified as unordered pairs $\\{u,v\\}$ with $u \\neq v$.\n- For the FK heat-bath dynamics, you must compute “connectedness” of the endpoints in the current open-edge subgraph excluding the edge being updated using a logically correct graph search.\n- For CFTP, you must implement a doubling schedule. The driving randomness (edge selections and uniforms) must be fixed for a test case, reproducibly indexed by time, so that monotone coupling is valid across doublings.\n- All random variables must be generated using a fixed seed specified in each test case to ensure reproducibility. No external data or user input is allowed.\n\nTest suite:\nFor each test case below, your program must compute and return a single integer as specified. The program must produce a single line containing a comma-separated list of these integers enclosed in square brackets.\n\n- Case 1 (FK heat-bath, “happy path”): $n=4$, $E=\\{\\{0,1\\}, \\{1,2\\}, \\{2,3\\}, \\{3,0\\}\\}$, $q=2$, $p=0.5$, maximum doublings $=12$, seed $=123$.\n- Case 2 (FK heat-bath, strong coupling): $n=4$, $E=\\{\\{0,1\\}, \\{1,2\\}, \\{2,3\\}\\}$, $q=3$, $p=0.9$, maximum doublings $=12$, seed $=456$.\n- Case 3 (SW naive bond-order attempt, impractical regime): $n=3$, $E=\\{\\{0,1\\}, \\{1,2\\}, \\{2,0\\}\\}$, $q=2$, $p=0.5$, maximum doublings $=12$, seed $=789$.\n- Case 4 (SW naive bond-order attempt, boundary case): $n=3$, $E=\\{\\{0,1\\}, \\{1,2\\}, \\{2,0\\}\\}$, $q=2$, $p=0.0$, maximum doublings $=12$, seed $=42$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., “[r1,r2,r3,r4]”), where $r_i$ is the integer result for Case $i$ in order.\n- No physical units are involved. All numbers are pure integers.\n\nYour implementation must be complete, runnable as is, and adhere strictly to the final output format and the constraints described above.", "solution": "The user-provided problem statement has been analyzed and is determined to be valid. It is scientifically grounded, well-posed, and objective. All necessary parameters, definitions, and conditions for a complete and unambiguous implementation are provided. The problem correctly describes established concepts in statistical mechanics and computational physics, namely the Potts and Fortuin–Kasteleyn (FK) models, Swendsen–Wang dynamics, and the Coupling From The Past (CFTP) exact sampling algorithm. The two experiments proposed are well-defined investigations into the applicability of monotone CFTP methods under different dynamics, with clear criteria for success and failure. We may therefore proceed with a complete solution.\n\nThe core task is to implement two distinct simulation experiments based on the CFTP paradigm, both employing a doubling-window schedule to find a coalescence time. The first experiment applies a standard monotone CFTP algorithm to the FK random-cluster model, while the second analyzes the feasibility of a naive CFTP-like construction for the Swendsen-Wang algorithm.\n\n### Experiment 1: Monotone CFTP for FK Heat-Bath Dynamics\n\n**Theoretical Foundation**\nThe Coupling From The Past (CFTP) algorithm, specifically in its monotone variant, provides a method for generating an exact sample from the stationary distribution of a Markov chain. Its validity relies on three key components:\n$1$. A state space $\\mathcal{S}$ endowed with a partial order $\\preceq$.\n$2$. A minimal element $\\omega_{\\min}$ and a maximal element $\\omega_{\\max}$ in $\\mathcal{S}$ such that for any $\\omega \\in \\mathcal{S}$, $\\omega_{\\min} \\preceq \\omega \\preceq \\omega_{\\max}$.\n$3$. A family of update functions $\\{f(\\cdot, U)\\}$, parameterized by randomness $U$, that are monotone with respect to the partial order. That is, for any two states $\\omega_1, \\omega_2 \\in \\mathcal{S}$, if $\\omega_1 \\preceq \\omega_2$, then $f(\\omega_1, U) \\preceq f(\\omega_2, U)$ for the same realization of randomness $U$.\n\nIn this problem, the state space $\\mathcal{S}$ is the set of all bond configurations on the graph $G=(V,E)$, i.e., $\\mathcal{S} = \\{0,1\\}^E$. The partial order is the coordinate-wise inclusion: $\\omega \\preceq \\omega'$ if and only if the set of open edges in $\\omega$ is a subset of the open edges in $\\omega'$. The minimal element $\\omega_{\\min}$ is the configuration with all edges closed ($0$), and the maximal element $\\omega_{\\max}$ has all edges open ($1$).\n\nThe update function corresponds to the single-edge heat-bath Gibbs sampler for the FK random-cluster measure. An edge $e=\\{u,v\\}$ is chosen, and its state is resampled from the conditional distribution given the state of all other edges, $\\omega^{\\setminus e}$. The conditional probability of edge $e$ being open is given as:\n$$\n\\mathbb{P}(\\omega(e)=1 \\mid \\omega^{\\setminus e}) = \n\\begin{cases} \np  \\text{if } u \\text{ and } v \\text{ are connected in } (V, \\omega^{\\setminus e}) \\\\\n\\frac{p}{p + (1-p)q}  \\text{otherwise} \n\\end{cases}\n$$\nThis update is indeed monotone for $q \\ge 1$. To see this, let $\\omega_1 \\preceq \\omega_2$. The connectivity of endpoints $\\{u,v\\}$ in $\\omega^{\\setminus e}$ is a monotone property: if $u$ and $v$ are connected in $\\omega_1^{\\setminus e}$, they must also be connected in $\\omega_2^{\\setminus e}$. Because $q \\ge 1$, we have $p + (1-p)q \\ge p + (1-p) = 1$, which implies $\\frac{p}{p + (1-p)q} \\le p$. Thus, the probability $\\mathbb{P}(\\omega(e)=1 \\mid \\omega^{\\setminus e})$ is a non-decreasing function of $\\omega^{\\setminus e}$ under the inclusion order. When using a common uniform random variable $U$ to decide the update (i.e., setting $\\omega(e)=1$ if $U  \\mathbb{P}(\\omega(e)=1 | \\omega^{\\setminus e})$), the resulting updated configurations will preserve the partial order.\n\n**Algorithmic Design**\nThe algorithm implements a doubling schedule. We search for a time window $[-T, 0)$ such that if we start two chains, one at $\\omega_{\\min}$ and one at $\\omega_{\\max}$, at time $-T$ and evolve them to time $0$ using the *exact same sequence of random numbers*, their states at time $0$ are identical.\n$1$. Initialize window size $T=1$.\n$2$. Start a loop that continues until coalescence or the maximum number of doublings is reached.\n$3$. Set $\\omega_{\\text{low}}( -T ) = \\omega_{\\min}$ (all edges closed) and $\\omega_{\\text{high}}( -T ) = \\omega_{\\max}$ (all edges open).\n$4$. For each time step $t$ from $-T$ to $-1$:\n    a. Generate the randomness for this time step: a uniformly chosen edge index $i_t \\in \\{0, \\dots, m-1\\}$ and a uniform random number $U_t \\in [0,1)$. To ensure a valid grand coupling, this randomness must be a deterministic function of the time index $t$, reproducible across different doubling windows.\n    b. Update $\\omega_{\\text{low}}$: Let $e = E[i_t]$. Check connectivity of $e$'s endpoints in the graph defined by the open edges of $\\omega_{\\text{low}}$ excluding $e$. This is done using a Breadth-First Search (BFS) or Depth-First Search (DFS). Based on connectivity, calculate the probability $P_{\\text{low}}$ for $e$ to be open. Set the new state of edge $e$ in $\\omega_{\\text{low}}$ to $1$ if $U_t  P_{\\text{low}}$ and $0$ otherwise.\n    c. Update $\\omega_{\\text{high}}$ using the same edge $e$ and uniform variable $U_t$, following the same procedure as for $\\omega_{\\text{low}}$.\n$5$. At time $0$, check if $\\omega_{\\text{low}}(0) = \\omega_{\\text{high}}(0)$.\n$6$. If they are identical (coalesced), the algorithm terminates. The required coalescence time is the window size $T$.\n$7.$. If they are not identical, double the window size $T \\leftarrow 2T$ and repeat from step $3$. If the maximum allowed window size is exceeded, report $-1$.\n\n### Experiment 2: Attempted Monotone CFTP for Swendsen-Wang\n\n**Theoretical Foundation**\nThe Swendsen-Wang (SW) dynamic is a Markov chain on the space of spin configurations $\\{1, \\dots, q\\}^V$. A single update step $\\sigma_t \\to \\sigma_{t+1}$ proceeds via an auxiliary bond configuration $\\omega_t$:\n$1$. Given $\\sigma_t$, for each edge $e=\\{u,v\\}$, if $\\sigma_t(u)=\\sigma_t(v)$, the bond $\\omega_t(e)$ is set to $1$ with probability $p$. If $\\sigma_t(u) \\neq \\sigma_t(v)$, $\\omega_t(e)$ is set to $0$. This can be written as $\\omega_t(e) = 1$ if and only if $U_{t,e}  p$ and $\\sigma_t(u) = \\sigma_t(v)$, where $U_{t,e}$ are i.i.d. $\\mathrm{Uniform}(0,1)$ variables.\n$2$. A new spin configuration $\\sigma_{t+1}$ is generated by identifying the connected components in the graph $(V, \\omega_t)$ and assigning each component a new spin chosen uniformly and independently from $\\{1, \\dots, q\\}$.\n\nThe problem asks to assess a naive domination scheme in the bond space. At each time $t$, independent of the spin configuration $\\sigma_t$, we can define a lower and an upper bound on the resulting bond configuration $\\omega_t$.\n- **Lower bound:** $\\omega_{\\text{low}, t} = \\varnothing$ (all edges closed). This is a valid lower bound because an edge can only be active if spins match, so no edge is guaranteed to be active.\n- **Upper bound:** $\\omega_{\\text{up}, t} = \\{e \\in E : U_{t,e}  p\\}$. This is a valid upper bound because an edge can only be active if $U_{t,e}  p$.\n\n**Algorithmic Design**\nThe experiment seeks the condition under which the bond configuration $\\omega_t$ is uniquely determined for all possible spin paths. This occurs if and only if the lower and upper bounds coincide for all time steps within the simulation window, i.e., $\\omega_{\\text{low}, t} = \\omega_{\\text{up}, t}$ for $t \\in [-T, -1)$. This condition simplifies to $\\varnothing = \\{e \\in E : U_{t,e}  p\\}$ for all $t$ in the window. This is equivalent to requiring $U_{t,e} \\ge p$ for all edges $e$ and all time steps $t$ in the window. The algorithm is a direct check of this condition.\n\n$1$. Initialize window size $T=1$.\n$2$. Start a loop that continues until the condition is met or the maximum number of doublings is reached.\n$3$. For the window $[-T, 0)$:\n    a. Assume the condition holds (`coalesced = True`).\n    b. For each time step $t$ from $-T$ to $-1$:\n        i. Generate the randomness for this step: a set of $m$ uniform random numbers $\\{U_{t,e}\\}_{e \\in E}$.\n        ii. Check if $U_{t,e} \\ge p$ for all $e \\in E$.\n        iii. If this check fails for any edge, the condition is not met for this window. Set `coalesced = False` and break the inner loops.\n$4$. If `coalesced` remains `True` after checking all time steps in the window, the algorithm terminates. The result is the window size $T$.\n$5$. If `coalesced` is `False`, double the window size $T \\leftarrow 2T$ and repeat. If the maximum allowed window size is exceeded, report $-1$.\nThis experiment is designed to show the impracticality of this naive approach. The probability of $U_{t,e} \\ge p$ for all $m$ edges simultaneously is $(1-p)^m$. For this to hold over a window of size $T$, the probability is $((1-p)^m)^T$, which decays exponentially, making coalescence extremely unlikely for any non-trivial $p  0$ and $m0$. For the special case $p=0$, the condition $U_{t,e} \\ge 0$ is always true, so coalescence is found immediately with $T=1$.\n\n### Implementation Strategy\n\nThe solution will be implemented in Python using the `numpy` library for numerical operations and random number generation. A single seeded `numpy.random.Generator` instance is used for each test case to ensure reproducibility. For the grand coupling, a large buffer of random numbers (for both edge choices and uniform variates) is pre-generated, corresponding to the maximum possible simulation window. The simulation for a window of size $T$ then deterministically uses the last $T$ entries from this buffer, ensuring that the randomness for time $t$ remains the same across doublings. Graph connectivity for the FK case will be implemented with a standard BFS algorithm using `collections.deque`.", "answer": "```python\nimport numpy as np\nimport collections\n\ndef is_connected(u, v, n, edges, omega):\n    \"\"\"\n    Checks if nodes u and v are connected in the subgraph induced by open edges.\n    Uses Breadth-First Search (BFS).\n    \n    Args:\n        u (int): The first vertex.\n        v (int): The second vertex.\n        n (int): The number of vertices in the graph.\n        edges (list): The list of all edges in the graph.\n        omega (np.ndarray): The bond configuration (1 for open, 0 for closed).\n    \n    Returns:\n        bool: True if u and v are connected, False otherwise.\n    \"\"\"\n    if u == v:\n        return True\n    \n    adj = collections.defaultdict(list)\n    open_edges = np.where(omega)[0]\n    for edge_idx in open_edges:\n        n1, n2 = edges[edge_idx]\n        adj[n1].append(n2)\n        adj[n2].append(n1)\n        \n    q = collections.deque([u])\n    visited = {u}\n    \n    while q:\n        curr = q.popleft()\n        if curr == v:\n            return True\n        for neighbor in adj.get(curr, []):\n            if neighbor not in visited:\n                visited.add(neighbor)\n                q.append(neighbor)\n    return False\n\ndef solve_fk_case(n, E, q, p, max_doublings, seed):\n    \"\"\"\n    Solves Experiment 1: Monotone CFTP for FK heat-bath dynamics.\n    \"\"\"\n    m = len(E)\n    edges = [tuple(e) for e in E]\n    max_window_size = 2**(max_doublings) # one larger to avoid off by one in slicing\n\n    # Pre-generate randomness to ensure grand coupling\n    rng = np.random.default_rng(seed)\n    random_edge_indices = rng.integers(0, m, size=max_window_size)\n    random_uniforms = rng.uniform(size=max_window_size)\n\n    window_size = 1\n    for d in range(max_doublings):\n        # The evolution happens from time -window_size to -1\n        # which corresponds to indices max_window_size - window_size to max_window_size - 1\n        start_idx = max_window_size - window_size\n        \n        # Lower chain starts with all edges closed\n        omega_low = np.zeros(m, dtype=bool)\n        # Upper chain starts with all edges open\n        omega_high = np.ones(m, dtype=bool)\n\n        for i in range(window_size):\n            t_idx = start_idx + i\n            edge_idx = random_edge_indices[t_idx]\n            U = random_uniforms[t_idx]\n            u, v = edges[edge_idx]\n\n            # Update lower chain\n            omega_low_temp = np.copy(omega_low)\n            omega_low_temp[edge_idx] = False\n            conn_low = is_connected(u, v, n, edges, omega_low_temp)\n            prob_open_low = p if conn_low else p / (p + (1 - p) * q)\n            omega_low[edge_idx] = U  prob_open_low\n\n            # Update upper chain with the same randomness\n            omega_high_temp = np.copy(omega_high)\n            omega_high_temp[edge_idx] = False\n            conn_high = is_connected(u, v, n, edges, omega_high_temp)\n            prob_open_high = p if conn_high else p / (p + (1 - p) * q)\n            omega_high[edge_idx] = U  prob_open_high\n        \n        if np.array_equal(omega_low, omega_high):\n            return window_size\n        \n        window_size *= 2\n\n    return -1\n\ndef solve_sw_case(n, E, q, p, max_doublings, seed):\n    \"\"\"\n    Solves Experiment 2: Attempted monotone CFTP for Swendsen-Wang.\n    \"\"\"\n    m = len(E)\n    max_window_size = 2**(max_doublings)\n    \n    # Pre-generate randomness. Each time step needs m uniform numbers.\n    rng = np.random.default_rng(seed)\n    random_uniforms = rng.uniform(size=(max_window_size, m))\n\n    window_size = 1\n    for d in range(max_doublings):\n        start_idx = max_window_size - window_size\n        \n        coalesced_in_window = True\n        for i in range(window_size):\n            t_idx = start_idx + i\n            uniforms_t = random_uniforms[t_idx]\n            \n            # The condition for the naive bound to coalesce at step t is\n            # that U_{t,e} = p for all edges e.\n            if not np.all(uniforms_t = p):\n                coalesced_in_window = False\n                break\n        \n        if coalesced_in_window:\n            return window_size\n        \n        window_size *= 2\n\n    return -1\n\ndef solve():\n    test_cases = [\n        # Case 1 (FK heat-bath, “happy path”)\n        {'type': 'fk', 'n': 4, 'E': [[0,1], [1,2], [2,3], [3,0]], 'q': 2, 'p': 0.5, 'max_doublings': 12, 'seed': 123},\n        # Case 2 (FK heat-bath, strong coupling)\n        {'type': 'fk', 'n': 4, 'E': [[0,1], [1,2], [2,3]], 'q': 3, 'p': 0.9, 'max_doublings': 12, 'seed': 456},\n        # Case 3 (SW naive bond-order attempt, impractical regime)\n        {'type': 'sw', 'n': 3, 'E': [[0,1], [1,2], [2,0]], 'q': 2, 'p': 0.5, 'max_doublings': 12, 'seed': 789},\n        # Case 4 (SW naive bond-order attempt, boundary case)\n        {'type': 'sw', 'n': 3, 'E': [[0,1], [1,2], [2,0]], 'q': 2, 'p': 0.0, 'max_doublings': 12, 'seed': 42},\n    ]\n\n    results = []\n    for case in test_cases:\n        if case['type'] == 'fk':\n            result = solve_fk_case(case['n'], case['E'], case['q'], case['p'], case['max_doublings'], case['seed'])\n        elif case['type'] == 'sw':\n            result = solve_sw_case(case['n'], case['E'], case['q'], case['p'], case['max_doublings'], case['seed'])\n        else:\n            raise ValueError(\"Unknown test case type\")\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3356348"}]}