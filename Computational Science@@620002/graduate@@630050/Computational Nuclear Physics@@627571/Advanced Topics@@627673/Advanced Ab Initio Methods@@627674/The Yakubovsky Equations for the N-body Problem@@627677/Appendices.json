{"hands_on_practices": [{"introduction": "Before tackling the full complexity of the Yakubovsky equations, it is crucial to verify the correctness of the core components of a numerical solver. This practice guides you through constructing a simplified four-body problem using a separable potential, which allows for an exact analytical solution for the binding energy [@problem_id:3608781]. By comparing your numerical results against this known analytical answer, you can unit-test your implementation of the integral kernels and normalization conventions, building a solid and reliable foundation for more complex calculations.", "problem": "You will construct a fully specified, exactly solvable four-body bound-state test problem based on a rank-$1$ Yamaguchi-type separable interaction and a degenerate-kernel reduction of the Faddeev–Yakubovsky (FY) equations. The goal is to produce a small, runnable program that simultaneously checks integral kernels and normalization conventions by comparing analytic formulas against numerical quadrature and numerical root-finding. All quantities are to be treated in dimensionless natural units, so no physical units are entered or returned.\n\nThe fundamental starting point is the nonrelativistic $A$-body Schrödinger equation in momentum space, the Lippmann–Schwinger equation for the two-body $t$ operator, and the Faddeev–Yakubovsky (FY) decomposition for $A=4$. You are to use a pairwise rank-$1$ separable potential of the Yamaguchi type,\n$$\nV(\\mathbf{k},\\mathbf{k}') = -\\lambda\\, g(k)\\, g(k'), \\quad g(k) = \\frac{1}{k^2 + \\beta^2},\n$$\nwith $\\lambda > 0$ and $\\beta > 0$, and adopt the standard momentum-space normalization with the measure $\\int \\frac{d^3k}{(2\\pi)^3}$. Work in dimensionless units with $\\hbar = 1$ and reduced masses scaled so that the free two-body resolvent has denominator $k^2 + \\kappa^2$ for a bound state at energy $E = -\\kappa^2$ with $\\kappa > 0$. The free four-body resolvent is taken in Jacobi variables with the same scaling.\n\nFrom the Lippmann–Schwinger equation for a rank-$1$ separable interaction, the two-body $t$ operator takes the form\n$$\nt(E) = |g\\rangle\\, \\tau(E)\\, \\langle g|, \\quad \\tau(E) = \\frac{-\\lambda}{1 + \\lambda\\, I_2(E)}, \\quad I_2(E) \\equiv \\langle g|G_0(E)|g\\rangle,\n$$\nwhere $G_0(E)$ is the free two-body resolvent and, for a bound state energy $E = -\\kappa^2$, the loop integral is\n$$\nI_2(-\\kappa^2) = \\int \\frac{d^3k}{(2\\pi)^3}\\, \\frac{g(k)^2}{\\kappa^2 + k^2} = \\frac{1}{2\\pi^2} \\int_0^\\infty dk\\, \\frac{k^2}{(k^2 + \\beta^2)^2\\, (k^2 + \\kappa^2)}.\n$$\n\nIn the degenerate-kernel reduction of the FY equations for $A=4$ identical spinless bosons and $S$-wave dynamics with the above rank-$1$ separable interaction, assume the following:\n- The Yakubovsky components in each cluster topology are proportional to the two-body form factor in the appropriate Jacobi momentum, so the integral equations close on a two-dimensional subspace spanned by $g$.\n- The projection of the free resolvent $G_0(E)$ sandwiched between the form factors for the relevant Jacobi variables reduces to the same scalar loop integral $I_2(-\\kappa^2)$ that appears in the two-body problem. This is a deliberate degenerate-kernel test convention.\n- The permutation structure between the two Yakubovsky components of the $3+1$ and $2+2$ types is represented by the fixed $2\\times 2$ integer matrix\n$$\nP = \\begin{pmatrix} 3 & 2 \\\\ 1 & 4 \\end{pmatrix},\n$$\nwhich encodes the bosonic symmetry weights for the reduced coupling between components in this degenerate model.\n\nUnder these assumptions, the homogeneous bound-state FY system reduces to the algebraic eigenvalue problem\n$$\n\\bigl[I - x(E)\\, P\\bigr]\\, \\mathbf{A} = 0, \\quad x(E) \\equiv -\\tau(E)\\, I_2(E),\n$$\nwith the nontrivial solution condition\n$$\n\\det\\bigl[I - x(E)\\, P\\bigr] = 0.\n$$\nThe eigenvalues of $P$ are to be determined from first principles. Denote them by $\\Lambda \\in \\{\\Lambda_1,\\Lambda_2\\}$. Then the bound-state condition in each channel is\n$$\nx(E) = \\frac{1}{\\Lambda}.\n$$\nUsing $x(E) = -\\tau(E)\\, I_2(E)$ and $\\tau(E) = -\\lambda/[1 + \\lambda I_2(E)]$, this reduces to the scalar equation\n$$\n\\lambda\\, \\bigl[\\Lambda\\, J(E) - I_2(E)\\bigr] = 1,\n$$\nand under the test convention $J(E) \\equiv I_2(E)$ it simplifies to\n$$\n\\lambda\\, (\\Lambda - 1)\\, I_2(E) = 1.\n$$\nInterpreted as an equation for $\\kappa$ (with $E=-\\kappa^2$), this defines an exactly solvable four-body binding test in each symmetry channel $\\Lambda$. A solution exists with a physical bound state if and only if the corresponding $\\kappa$ is strictly positive.\n\nYour tasks:\n1) Derive the analytic expression of the loop integral $I_2(-\\kappa^2)$ in terms of $\\kappa$ and $\\beta$, starting from the $3$-dimensional integral written above. Your derivation must begin from the integral definition and proceed by legitimate analytic methods.\n2) Determine the eigenvalues $\\Lambda$ of the matrix $P$.\n3) Using items $1$ and $2$, show that the bound-state condition reduces to a scalar equation in $\\kappa$ that is solvable in closed form for each $\\Lambda$. Provide the explicit analytic expression for $\\kappa$ as a function of $\\lambda$, $\\beta$, and $\\Lambda$, and state the positivity condition for $\\kappa$ that signals the existence of a physical bound state.\n4) Implement a program that:\n   - Numerically evaluates $I_2(-\\kappa^2)$ via the one-dimensional radial integral (with the specified measure) using numerical quadrature over $k \\in [0,\\infty)$.\n   - For each channel $\\Lambda$, numerically solves the scalar bound-state equation\n     $$\n     F_\\Lambda(\\kappa) \\equiv \\lambda\\, (\\Lambda - 1)\\, I_2(-\\kappa^2) - 1 = 0\n     $$\n     for $\\kappa \\ge 0$ using a robust bracketed method. If $F_\\Lambda(0) \\le 0$, declare that no physical root exists in that channel.\n   - Compares each numerically obtained $\\kappa$ (when it exists) against the analytic $\\kappa$ from item $3$ and also checks the normalization condition\n     $$\n     -\\tau(-\\kappa^2)\\, I_2(-\\kappa^2) = \\frac{1}{\\Lambda}\n     $$\n     within a tight absolute tolerance.\n   - Reports, for each test case and for each channel $\\Lambda$, a boolean stating whether the analytic and numerical predictions agree: it must be $\\,\\text{True}\\,$ if and only if either (i) both the analytic and the numerical procedures agree that no bound state exists in that channel, or (ii) both find a bound state and the absolute difference in $\\kappa$ is within the tolerance and the normalization check is satisfied; otherwise it must be $\\,\\text{False}\\,$.\n\nTest suite:\nUse the following four parameter sets $(\\lambda,\\beta)$, all dimensionless:\n- Case $1$: $\\lambda = 100.0$, $\\beta = 1.0$.\n- Case $2$: $\\lambda = 20.0$, $\\beta = 1.0$.\n- Case $3$: $\\lambda = 2\\pi \\times 1.0001$, $\\beta = 1.0$.\n- Case $4$: $\\lambda = 300.0$, $\\beta = 2.0$.\n\nAngle units do not apply, and there are no physical units to report. Your program should compute two booleans per case, corresponding to the channels with the two eigenvalues of $P$, in the fixed order of the larger eigenvalue channel first, then the smaller. Aggregate all eight booleans from the four cases into a single line of output containing the results as a comma-separated Python-style list with no spaces, for example, `[True,False,True,True,False,False,True,True]`.", "solution": "The user has provided a well-posed problem in computational quantum mechanics. I will proceed to solve it by first deriving the necessary analytic expressions and then constructing a numerical program to verify these results, as stipulated.\n\n### Task 1: Analytic Evaluation of the Loop Integral $I_2(-\\kappa^2)$\n\nThe problem specifies the two-body loop integral for a bound state at energy $E = -\\kappa^2$ as:\n$$\nI_2(-\\kappa^2) = \\frac{1}{2\\pi^2} \\int_0^\\infty dk\\, \\frac{k^2}{(k^2 + \\beta^2)^2\\, (k^2 + \\kappa^2)}\n$$\nwhere $\\kappa > 0$ and $\\beta > 0$. This integral can be solved using several standard techniques, such as contour integration or partial fraction decomposition. We will use the latter for its accessibility. The integrand is an even function of $k$, so we may extend the integration to the entire real axis and divide by $2$. For the case $\\kappa \\neq \\beta$, we can decompose the integrand.\nA more direct method is to use a known identity derived from partial fractions. We can write:\n$$\n\\frac{1}{k^2 + \\kappa^2} = \\frac{1}{\\beta^2 - \\kappa^2} \\left( \\frac{\\beta^2 - \\kappa^2 - (k^2+\\beta^2) + (k^2+\\kappa^2)}{k^2+\\kappa^2} \\right) = \\frac{1}{\\beta^2 - \\kappa^2} \\left( \\frac{(k^2+\\beta^2) - (k^2+\\kappa^2)}{k^2+\\kappa^2} \\right)\n$$\nThis is not helpful. Let's decompose the full expression.\n$$\n\\frac{k^2}{(k^2+\\beta^2)(k^2+\\kappa^2)} = \\frac{1}{\\beta^2-\\kappa^2} \\left( \\frac{\\beta^2 k^2}{k^2+\\beta^2} - \\frac{\\kappa^2 k^2}{k^2+\\kappa^2} \\right) = \\frac{1}{\\beta^2-\\kappa^2} \\left( \\beta^2\\left(1-\\frac{\\beta^2}{k^2+\\beta^2}\\right) - \\kappa^2\\left(1-\\frac{\\kappa^2}{k^2+\\kappa^2}\\right) \\right)\n$$\nThis path is also convoluted. A more robust method is to use partial fraction decomposition on the factors involving $k^2$. Let the full radial integral be $J$.\n$$\nJ = \\int_0^\\infty dk\\, \\frac{k^2}{(k^2 + \\beta^2)^2\\, (k^2 + \\kappa^2)}\n$$\nWe apply the identity:\n$$\n\\frac{1}{(k^2 + \\beta^2)(k^2 + \\kappa^2)} = \\frac{1}{\\beta^2 - \\kappa^2} \\left( \\frac{1}{k^2+\\kappa^2} - \\frac{1}{k^2+\\beta^2} \\right)\n$$\nThus, the integrand is:\n$$\n\\frac{k^2}{(k^2 + \\beta^2)^2\\, (k^2 + \\kappa^2)} = \\frac{k^2}{k^2 + \\beta^2} \\frac{1}{\\beta^2-\\kappa^2} \\left( \\frac{1}{k^2+\\kappa^2} - \\frac{1}{k^2+\\beta^2} \\right)\n$$\nThis seems too complex. The most straightforward path is via standard integral formulas derived from residue calculus. We use:\n$$\n\\int_0^\\infty \\frac{dx}{(x^2+a^2)^2} = \\frac{\\pi}{4a^3}\n$$\n$$\n\\int_0^\\infty \\frac{dx}{(x^2+a^2)(x^2+b^2)} = \\frac{\\pi}{2ab(a+b)}\n$$\nWe first decompose the integrand based on the non-repeated denominator:\n$$\n\\frac{k^2}{(k^2 + \\beta^2)^2\\, (k^2 + \\kappa^2)} = \\frac{1}{\\beta^2-\\kappa^2} \\left[ \\frac{\\beta^2}{(k^2+\\beta^2)^2} - \\frac{\\kappa^2}{(k^2+\\kappa^2)(k^2+\\beta^2)} \\right]\n$$\nIntegrating this term by term:\n$$\nJ = \\frac{1}{\\beta^2 - \\kappa^2} \\left[ \\beta^2 \\int_0^\\infty \\frac{dk}{(k^2+\\beta^2)^2} - \\kappa^2 \\int_0^\\infty \\frac{dk}{(k^2+\\kappa^2)(k^2+\\beta^2)} \\right]\n$$\nUsing the standard integral formulas:\n$$\nJ = \\frac{1}{\\beta^2 - \\kappa^2} \\left[ \\beta^2 \\left( \\frac{\\pi}{4\\beta^3} \\right) - \\kappa^2 \\left( \\frac{\\pi}{2\\beta\\kappa(\\beta+\\kappa)} \\right) \\right]\n$$\n$$\nJ = \\frac{1}{\\beta^2 - \\kappa^2} \\left[ \\frac{\\pi}{4\\beta} - \\frac{\\pi\\kappa}{2\\beta(\\beta+\\kappa)} \\right] = \\frac{\\pi}{2\\beta(\\beta^2 - \\kappa^2)} \\left[ \\frac{1}{2} - \\frac{\\kappa}{\\beta+\\kappa} \\right]\n$$\n$$\nJ = \\frac{\\pi}{2\\beta(\\beta-\\kappa)(\\beta+\\kappa)} \\left[ \\frac{\\beta+\\kappa-2\\kappa}{2(\\beta+\\kappa)} \\right] = \\frac{\\pi}{2\\beta(\\beta-\\kappa)(\\beta+\\kappa)} \\frac{\\beta-\\kappa}{2(\\beta+\\kappa)}\n$$\nThis simplifies to:\n$$\nJ = \\frac{\\pi}{4\\beta(\\beta+\\kappa)^2}\n$$\nThis result is valid for $\\kappa \\neq \\beta$. In the case $\\kappa = \\beta$, the integral becomes $\\int_0^\\infty k^2/(k^2+\\beta^2)^3 dk = \\pi/(16\\beta^3)$. The derived formula gives $\\lim_{\\kappa\\to\\beta} \\pi/(4\\beta(\\beta+\\kappa)^2) = \\pi/(4\\beta(2\\beta)^2) = \\pi/(16\\beta^3)$, confirming the formula is valid for all $\\kappa > 0, \\beta > 0$.\n\nSubstituting this back into the definition of $I_2$:\n$$\nI_2(-\\kappa^2) = \\frac{1}{2\\pi^2} J = \\frac{1}{2\\pi^2} \\frac{\\pi}{4\\beta(\\beta+\\kappa)^2} = \\frac{1}{8\\pi\\beta(\\beta+\\kappa)^2}\n$$\n\n### Task 2: Eigenvalues of the Permutation Matrix $P$\n\nThe given permutation structure matrix is:\n$$\nP = \\begin{pmatrix} 3 & 2 \\\\ 1 & 4 \\end{pmatrix}\n$$\nThe eigenvalues $\\Lambda$ are found by solving the characteristic equation $\\det(P - \\Lambda I) = 0$:\n$$\n\\det \\begin{pmatrix} 3-\\Lambda & 2 \\\\ 1 & 4-\\Lambda \\end{pmatrix} = (3-\\Lambda)(4-\\Lambda) - (2)(1) = 0\n$$\n$$\n\\Lambda^2 - 7\\Lambda + 12 - 2 = 0\n$$\n$$\n\\Lambda^2 - 7\\Lambda + 10 = 0\n$$\nFactoring the quadratic equation gives:\n$$\n(\\Lambda-5)(\\Lambda-2) = 0\n$$\nThe eigenvalues are therefore $\\Lambda_1 = 5$ and $\\Lambda_2 = 2$.\n\n### Task 3: Analytic Solution for the Bound-State Momentum $\\kappa$\n\nThe bound-state condition for a channel with eigenvalue $\\Lambda$ is given by:\n$$\n\\lambda\\, (\\Lambda - 1)\\, I_2(-\\kappa^2) = 1\n$$\nSubstituting the derived analytic form of $I_2(-\\kappa^2)$:\n$$\n\\lambda (\\Lambda - 1) \\frac{1}{8\\pi\\beta(\\beta+\\kappa)^2} = 1\n$$\nWe solve for $\\kappa$. Rearranging the terms yields:\n$$\n(\\beta+\\kappa)^2 = \\frac{\\lambda(\\Lambda-1)}{8\\pi\\beta}\n$$\nSince $\\beta > 0$ and we seek a physical bound state with $\\kappa > 0$, we take the positive square root:\n$$\n\\beta+\\kappa = \\sqrt{\\frac{\\lambda(\\Lambda-1)}{8\\pi\\beta}}\n$$\nIsolating $\\kappa$ gives the explicit analytic expression:\n$$\n\\kappa = \\sqrt{\\frac{\\lambda(\\Lambda-1)}{8\\pi\\beta}} - \\beta\n$$\nA physical bound state exists if and only if its binding momentum $\\kappa$ is strictly positive. This leads to the condition:\n$$\n\\sqrt{\\frac{\\lambda(\\Lambda-1)}{8\\pi\\beta}} - \\beta > 0 \\implies \\frac{\\lambda(\\Lambda-1)}{8\\pi\\beta} > \\beta^2\n$$\nThus, a bound state exists for a given channel $\\Lambda$ if and only if the parameters satisfy:\n$$\n\\lambda(\\Lambda-1) > 8\\pi\\beta^3\n$$\n\n### Task 4: Numerical Verification Scheme\n\nThe final task is to implement a program that verifies the analytic results against numerical procedures. The program's design is as follows:\n\n1.  **Iterate through Test Cases and Channels**: The program iterates through each provided $(\\lambda, \\beta)$ parameter set and, for each set, through the two eigenvalue channels $\\Lambda \\in \\{5, 2\\}$.\n\n2.  **Analytic Prediction**: For each $(\\lambda, \\beta, \\Lambda)$ combination, it first determines analytically whether a bound state should exist using the condition $\\lambda(\\Lambda-1) > 8\\pi\\beta^3$. If one does, the corresponding $\\kappa_{analytic}$ is computed using the derived formula.\n\n3.  **Numerical Prediction**: Concurrently, a numerical prediction is made.\n    -   The existence of a bound state is determined by evaluating the function $F_\\Lambda(\\kappa) \\equiv \\lambda\\, (\\Lambda - 1)\\, I_2(-\\kappa^2) - 1$ at $\\kappa=0$. A physical root for $\\kappa > 0$ can only exist if $F_\\Lambda(0) > 0$, since $F_\\Lambda(\\kappa)$ is a monotonically decreasing function that approaches $-1$ as $\\kappa \\to \\infty$.\n    -   In this numerical check, the value of $I_2(-\\kappa^2)$ is computed via numerical quadrature using `scipy.integrate.quad` on the one-dimensional integral over $k \\in [0, \\infty)$.\n    -   If $F_\\Lambda(0) > 0$, a numerical root $\\kappa_{numeric}$ is found by applying a robust bracketed root-finding algorithm, `scipy.optimize.brentq`, to the equation $F_\\Lambda(\\kappa) = 0$. The search interval is established between $0$ and a suitable upper bound where $F_\\Lambda$ becomes negative.\n\n4.  **Validation and Comparison**: The analytic and numerical results are compared to yield a boolean success flag for the channel.\n    -   The boolean is `True` if both methods agree that no bound state exists.\n    -   If both methods predict a bound state, the boolean is `True` only if two further conditions are met within a strict tolerance of $10^{-9}$:\n        1.  The absolute difference between the analytic and numerical binding momenta, $|\\kappa_{analytic} - \\kappa_{numeric}|$, must be within the tolerance.\n        2.  The fundamental normalization condition $-\\tau(-\\kappa^2) I_2(-\\kappa^2) = 1/\\Lambda$ must hold for the numerically found $\\kappa_{numeric}$. The terms $\\tau(-\\kappa_{numeric}^2)$ and $I_2(-\\kappa_{numeric}^2)$ are computed using the problem's definitions and numerical quadrature. This check verifies the consistency of the entire framework and the accuracy of the numerical root.\n    -   In all other cases, such as a mismatch in existence prediction or failure of the tolerance checks, the boolean is `False`.\n\n5.  **Output**: The resulting eight boolean flags (one for each of two channels across four test cases) are aggregated and printed in the specified list format.", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import quad\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Solves the four-body test problem by comparing analytic and numerical results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (100.0, 1.0),\n        (20.0, 1.0),\n        (2.0 * np.pi * 1.0001, 1.0),\n        (300.0, 2.0),\n    ]\n\n    # Eigenvalues of the permutation matrix P, ordered from larger to smaller.\n    Lambdas = [5, 2]\n\n    # Absolute tolerance for numerical comparisons.\n    TOL = 1e-9\n\n    results = []\n\n    def I2_integrand(k, kappa, beta):\n        \"\"\"\n        Integrand of the loop integral I_2(-kappa^2) as a function of k.\n        Normalization factor 1/(2*pi^2) is included.\n        \"\"\"\n        if k  0: return 0.0\n        # The expression is k^2 / ((2*pi^2) * (k^2+beta^2)^2 * (k^2+kappa^2))\n        den_term1 = k**2 + beta**2\n        den_term2 = k**2 + kappa**2\n        if den_term1 == 0 or den_term2 == 0:\n            return 0.0 # Avoid division by zero, although k>=0 makes this rare\n        return (k**2 / (den_term1**2 * den_term2)) / (2.0 * np.pi**2)\n\n    for lam, beta in test_cases:\n        for Lambda in Lambdas:\n            \n            # --- Analytic Prediction ---\n            # A physical bound state exists if lambda*(Lambda-1) > 8*pi*beta^3\n            analytic_exists = lam * (Lambda - 1.0) > 8.0 * np.pi * beta**3\n            \n            kappa_analytic = 0.0\n            if analytic_exists:\n                kappa_analytic = np.sqrt(lam * (Lambda - 1.0) / (8.0 * np.pi * beta)) - beta\n            \n            # --- Numeric Prediction ---\n            def F_Lambda_numeric(kappa, lam_val, beta_val, Lambda_val):\n                \"\"\"\n                The function F(kappa) = 0 to be solved. Uses numerical quadrature for I_2.\n                \"\"\"\n                if kappa  0: return np.inf \n                # Use high-precision settings for quad to meet the final tolerance TOL.\n                i2_val, _ = quad(I2_integrand, 0, np.inf, args=(kappa, beta_val),\n                                 epsabs=1e-13, epsrel=1e-13)\n                return lam_val * (Lambda_val - 1.0) * i2_val - 1.0\n\n            # Evaluate at kappa=0 to check for the existence of a physical root (kappa > 0).\n            F_at_zero = F_Lambda_numeric(0, lam, beta, Lambda)\n            numeric_exists = F_at_zero > 0\n            \n            # --- Comparison  Validation ---\n            # Case (i): Both methods agree that no bound state exists.\n            if not analytic_exists and not numeric_exists:\n                results.append(True)\n                continue\n\n            # Case (ii): Both methods agree that a bound state exists.\n            # Then proceed to check if the results match within tolerance.\n            if analytic_exists and numeric_exists:\n                # Find an upper bracket for the root-finding algorithm.\n                # A good guess is a value larger than the analytic solution.\n                upper_bound = max(1.0, 2.0 * kappa_analytic if kappa_analytic > 0 else 2.0 * beta)\n                \n                # Ensure the bracket is valid (F(upper_bound)  0).\n                f_upper = F_Lambda_numeric(upper_bound, lam, beta, Lambda)\n                while f_upper > 0:\n                    upper_bound *= 2.0\n                    f_upper = F_Lambda_numeric(upper_bound, lam, beta, Lambda)\n\n                # Find the numerical root for kappa.\n                kappa_numeric = brentq(F_Lambda_numeric, 0, upper_bound, \n                                       args=(lam, beta, Lambda), xtol=TOL, rtol=TOL)\n\n                # Check 1: Absolute difference in kappa between analytic and numeric solutions.\n                kappa_diff_check = abs(kappa_analytic - kappa_numeric)  TOL\n                \n                # Check 2: Normalization condition using the numerical kappa.\n                # -tau(-kappa^2) * I_2(-kappa^2) = 1/Lambda\n                i2_check, _ = quad(I2_integrand, 0, np.inf, args=(kappa_numeric, beta),\n                                   epsabs=1e-13, epsrel=1e-13)\n                tau_val = -lam / (1.0 + lam * i2_check)\n                norm_val = -tau_val * i2_check\n                norm_check = abs(norm_val - 1.0/Lambda)  TOL\n                \n                if kappa_diff_check and norm_check:\n                    results.append(True)\n                else:\n                    results.append(False)\n            else:\n                # Disagreement on existence.\n                results.append(False)\n\n    # Print the final result in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3608781"}, {"introduction": "Real-world applications of the Yakubovsky equations require solving them numerically, as analytical solutions are generally not available. This exercise dives into the core of the computational challenge: discretizing the continuous integral equations into a solvable matrix system and handling the moving singularities that arise from the free-particle propagator [@problem_id:3608810]. You will implement a Gauss-Legendre quadrature scheme and use the complex-energy regularization technique to manage the on-shell singularities, developing the essential machinery for obtaining stable numerical solutions.", "problem": "Consider the coupled Yakubovsky equations (YE) for an $N$-body system reduced to two dominant Yakubovsky components in momentum space under a spherically symmetric $S$-wave approximation. The goal is to construct a momentum-space grid discretization of the corresponding coupled integral equations and to implement a numerically stable treatment of moving singularities near on-shell points that arise from free resolvents. The starting point must be the Lippmann–Schwinger framework and the Yakubovsky component decomposition, with the free resolvent generating denominators that can vanish for specific combinations of momenta, thereby producing moving singularities. You will then formulate, discretize, and solve a model system that captures these features.\n\nStarting from the Lippmann–Schwinger integral equation for scattering in momentum space and the Yakubovsky decomposition, model the coupled integral equations for two components $F_1(k)$ and $F_2(k)$ as\n$$\nF_a(k) = g_a(k) + \\sum_{b=1}^{2} \\int_{0}^{k_{\\max}} dq\\, q^2\\, K_{ab}(k,q)\\, F_b(q), \\quad a \\in \\{1,2\\},\n$$\nwhere $k$ and $q$ denote radial momenta, $k_{\\max}$ is the maximum momentum defining the grid extent, $g_a(k)$ are driving terms, and $K_{ab}(k,q)$ are effective kernels representing the combination of interaction and the free resolvent. Assume a model kernel of the form\n$$\nK_{ab}(k,q) = \\lambda_{ab}\\, V(k,q)\\, G_0(k,q;E),\n$$\nwhere $E$ is the total energy (dimensionless, using a consistent unit system with mass scaled to $m$), $\\lambda_{ab}$ are dimensionless coupling constants controlling the strength of the channel coupling, $V(k,q)$ is a smooth interaction form factor, and\n$$\nG_0(k,q;E) = \\frac{1}{E - \\frac{k^2 + q^2}{2m} + i\\,\\epsilon}\n$$\nis the free resolvent with a small imaginary part $i\\,\\epsilon$ to regularize the moving singularity at the on-shell locus defined by $E = \\frac{k^2 + q^2}{2m}$. This moving singularity shifts with $k$; the on-shell $q$ as a function of $k$ is $q_{\\mathrm{on}}(k) = \\sqrt{2mE - k^2}$ when $2mE \\ge k^2$, and is otherwise absent from the integration domain. For the interaction, use a smooth, spherically symmetric form factor\n$$\nV(k,q) = \\exp\\!\\left(-\\frac{k^2 + q^2}{\\Lambda^2}\\right),\n$$\nwith range parameter $\\Lambda$. Let the driving terms be\n$$\ng_a(k) = \\exp\\!\\left(-\\frac{k^2}{\\Lambda_g^2}\\right),\n$$\nwith a finite $\\Lambda_g$.\n\nDiscretize the integral equations on a one-dimensional momentum grid using Gauss–Legendre quadrature mapped from $[-1,1]$ to $[0,k_{\\max}]$, preserving the radial measure $q^2\\,dq$ in the weights. Specifically, construct $N$ nodes $\\{k_i\\}_{i=1}^{N}$ and weights $\\{w_i\\}_{i=1}^{N}$, with the mapping and weights chosen such that the integral is approximated by\n$$\n\\int_{0}^{k_{\\max}} dq\\, q^2\\, f(q) \\approx \\sum_{j=1}^{N} w_j\\, f(k_j),\n$$\nwhere each $w_j$ includes both the Gauss–Legendre weight and the Jacobian of the mapping together with the $q^2$ factor. Form the linear system in block-matrix form corresponding to the discretized coupled equations:\n$$\n\\left[\\mathbf{I} - \\mathbf{K}\\right] \\mathbf{F} = \\mathbf{g},\n$$\nwhere $\\mathbf{F} \\in \\mathbb{C}^{2N}$ stacks the discretized components, $\\mathbf{g} \\in \\mathbb{C}^{2N}$ stacks the driving terms, and $\\mathbf{K} \\in \\mathbb{C}^{2N \\times 2N}$ is composed of the four $N \\times N$ blocks with entries\n$$\n\\left(K_{ab}\\right)_{ij} = w_j\\, \\lambda_{ab}\\, V(k_i,k_j)\\, \\frac{1}{E - \\frac{k_i^2 + k_j^2}{2m} + i\\,\\epsilon}.\n$$\nYou must directly address the moving singularity near the on-shell points by implementing a numerically stable treatment. Acceptable approaches include the complex-energy regularization shown above with $i\\,\\epsilon$, a principal-value subtraction scheme, or a hybrid method. Your program should implement the complex-energy regularization and solve the resulting complex linear system for $\\mathbf{F}$.\n\nYour task is to:\n- Derive the discretized linear system from first principles as stated above, justify the quadrature and the measure, and explain the treatment of the moving singularity.\n- Implement a complete, runnable program that constructs the grid, assembles the block matrix, solves for $\\mathbf{F}$, and returns quantitative diagnostics of the solution. The diagnostics must be the square-integrable norms of the real and imaginary parts of each component, computed with the same quadrature weights: for component $a$, compute\n$$\n\\| \\Re(F_a) \\|_2 = \\left( \\sum_{i=1}^{N} w_i \\left[\\Re(F_a(k_i))\\right]^2 \\right)^{1/2}, \\quad\n\\| \\Im(F_a) \\|_2 = \\left( \\sum_{i=1}^{N} w_i \\left[\\Im(F_a(k_i))\\right]^2 \\right)^{1/2}.\n$$\nNo physical units are required; all quantities are dimensionless.\n\nProvide a test suite with three parameter sets that probe different regimes of the moving singularity:\n- Test $1$ (happy path, on-shell inside domain, moderate regularization): $N=64$, $k_{\\max}=4.0$, $m=1.0$, $E=8.0$, $\\epsilon=10^{-2}$, $\\Lambda=2.0$, $\\Lambda_g=2.0$, $\\lambda_{11}=0.5$, $\\lambda_{12}=0.2$, $\\lambda_{21}=0.2$, $\\lambda_{22}=0.5$.\n- Test $2$ (near-threshold energy, on-shell near lower boundary): $N=64$, $k_{\\max}=4.0$, $m=1.0$, $E=0.1$, $\\epsilon=10^{-2}$, $\\Lambda=2.0$, $\\Lambda_g=2.0$, $\\lambda_{11}=0.5$, $\\lambda_{12}=0.2$, $\\lambda_{21}=0.2$, $\\lambda_{22}=0.5$.\n- Test $3$ (more challenging regularization with smaller imaginary part): $N=80$, $k_{\\max}=4.0$, $m=1.0$, $E=8.0$, $\\epsilon=10^{-6}$, $\\Lambda=2.0$, $\\Lambda_g=2.0$, $\\lambda_{11}=0.5$, $\\lambda_{12}=0.2$, $\\lambda_{21}=0.2$, $\\lambda_{22}=0.5$.\n\nFor each test case, output four floating-point diagnostics in the order\n$$\n\\left[ \\| \\Re(F_1) \\|_2,\\, \\| \\Re(F_2) \\|_2,\\, \\| \\Im(F_1) \\|_2,\\, \\| \\Im(F_2) \\|_2 \\right],\n$$\nflattened across the three tests into a single list for the entire program run.\n\nFinal Output Format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with the twelve floats from the three tests concatenated in the stated order (for example, $[r_1,r_2,r_3,r_4,r_5,r_6,r_7,r_8,r_9,r_{10},r_{11},r_{12}]$). No other text should be printed.", "solution": "We begin with the Lippmann–Schwinger formulation for scattering states in momentum space, where the transition operator $T$ satisfies\n$$\nT = V + V G_0(E) T,\n$$\nwith $V$ an interaction and $G_0(E)$ the free resolvent. In the $N$-body scenario, the Yakubovsky equations (YE) decompose the full wave function into components $F_a$ that satisfy coupled integral equations structured by partitions and subcluster interactions. Under an $S$-wave approximation with spherical symmetry and a model reduction to two dominant components, the coupled equations on radial momenta are\n$$\nF_a(k) = g_a(k) + \\sum_{b=1}^{2}\\int_{0}^{k_{\\max}} dq\\, q^2\\, K_{ab}(k,q)\\, F_b(q),\n$$\nwhere the $q^2$ measure originates from the Jacobian in spherical coordinates for three-dimensional momentum integration. The kernel\n$$\nK_{ab}(k,q) = \\lambda_{ab}\\, V(k,q)\\, G_0(k,q;E)\n$$\ncaptures the essential structure of interaction and propagation, where\n$$\nG_0(k,q;E) = \\frac{1}{E - \\frac{k^2 + q^2}{2m} + i\\,\\epsilon}\n$$\nis the model free resolvent. The denominator $E - \\frac{k^2 + q^2}{2m}$ vanishes on the on-shell locus\n$$\nq_{\\mathrm{on}}(k) = \\sqrt{2mE - k^2}, \\quad \\text{for}\\quad 2mE \\ge k^2.\n$$\nThis locus depends on $k$, hence the term “moving singularity,” typical in Yakubovsky-type kernels where spectator momenta shift the position of singular manifolds.\n\nTo construct a momentum-space grid discretization, we apply Gauss–Legendre quadrature. Map $x \\in [-1,1]$ to $q \\in [0,k_{\\max}]$ using\n$$\nq(x) = \\frac{k_{\\max}}{2}\\,(x+1).\n$$\nLet $(x_j, \\omega_j)$ be the Gauss–Legendre nodes and weights on $[-1,1]$, with $j \\in \\{1,\\dots,N\\}$. The integral\n$$\n\\int_{0}^{k_{\\max}} dq\\, q^2\\, f(q)\n$$\nis approximated by\n$$\n\\sum_{j=1}^{N} w_j\\, f(q_j), \\quad \\text{where} \\quad q_j = \\frac{k_{\\max}}{2}\\,(x_j+1), \\quad w_j = \\left(\\frac{k_{\\max}}{2}\\right)\\, \\omega_j\\, q_j^2.\n$$\nHere $w_j$ includes the Jacobian factor $\\frac{k_{\\max}}{2}$ from the mapping and the $q^2$ measure appropriate to $S$-wave integrals.\n\nWith $k_i$ denoting the same mapped nodes for the “outer” momentum, the discretized coupled equations produce the block linear system\n$$\n\\left[\\mathbf{I} - \\mathbf{K}\\right] \\mathbf{F} = \\mathbf{g}, \\quad \\mathbf{F} \\in \\mathbb{C}^{2N}, \\mathbf{g} \\in \\mathbb{C}^{2N}.\n$$\nThe block matrix $\\mathbf{K}$ has $N \\times N$ blocks given by\n$$\n\\left(K_{ab}\\right)_{ij} = w_j\\, \\lambda_{ab}\\, V(k_i,k_j)\\, \\frac{1}{E - \\frac{k_i^2 + k_j^2}{2m} + i\\,\\epsilon},\n$$\nwhich faithfully discretizes\n$$\n\\int_{0}^{k_{\\max}} dq\\, q^2\\, K_{ab}(k_i,q)\\, F_b(q) \\approx \\sum_{j=1}^{N} \\left(K_{ab}\\right)_{ij} F_b(k_j).\n$$\n\nThe moving singularity arises when $E - \\frac{k_i^2 + k_j^2}{2m} = 0$ for some $(i,j)$, that is, when $k_j = q_{\\mathrm{on}}(k_i)$. Direct quadrature without regularization will be numerically unstable. A principled approach based on complex analysis (and widely used for scattering integrals) is to introduce a small imaginary part $i\\,\\epsilon$ into the energy, replacing $E$ by $E + i\\,\\epsilon$ in the resolvent. This yields\n$$\nG_0(k,q;E) \\to \\frac{1}{E - \\frac{k^2 + q^2}{2m} + i\\,\\epsilon},\n$$\nwhich effectively transforms the simple pole into a Lorentzian of width $\\epsilon$, realizing a causal Green’s function and providing a well-behaved numerical integrand. In the limit $\\epsilon \\to 0^+$, the real part of the solution approaches the principal value contribution, and the imaginary part encodes the on-shell strength associated with the pole. Alternative methods include analytic principal value subtraction and logarithmic singularity isolation, but the complex-energy regularization is straightforward and robust for numerical computation.\n\nFor the interaction, we choose a smooth, ultraviolet-regulating form factor\n$$\nV(k,q) = \\exp\\!\\left(-\\frac{k^2 + q^2}{\\Lambda^2}\\right),\n$$\nand driving terms\n$$\ng_a(k) = \\exp\\!\\left(-\\frac{k^2}{\\Lambda_g^2}\\right),\n$$\nwhich provide well-conditioned inputs and mimic finite-range physics.\n\nAlgorithmic steps:\n- Choose $N$ Gauss–Legendre nodes and weights $(x_j,\\omega_j)$ on $[-1,1]$, map them to $[0,k_{\\max}]$ to form $\\{k_j\\}$ and construct radial weights $\\{w_j\\}$ including $q^2$.\n- Build the four $N \\times N$ blocks of $\\mathbf{K}$ using the chosen parameters and the complex resolvent $G_0$.\n- Assemble $\\mathbf{I} - \\mathbf{K}$ and the vector $\\mathbf{g}$ (stacked $g_1$ and $g_2$) and solve the complex linear system for $\\mathbf{F}$.\n- Compute the diagnostics for each component:\n$$\n\\| \\Re(F_a) \\|_2 = \\left( \\sum_{i=1}^{N} w_i \\left[\\Re(F_a(k_i))\\right]^2 \\right)^{1/2}, \\quad\n\\| \\Im(F_a) \\|_2 = \\left( \\sum_{i=1}^{N} w_i \\left[\\Im(F_a(k_i))\\right]^2 \\right)^{1/2}.\n$$\n\nTest coverage rationale:\n- Test $1$ with $E=8.0$ and $k_{\\max}=4.0$ places the on-shell condition inside the integration domain for many $k_i$, exercising the regularization while keeping $\\epsilon=10^{-2}$ sufficiently large to ensure numerical stability.\n- Test $2$ with $E=0.1$ positions the on-shell locus near the lower boundary for small $k$, probing behavior near thresholds and boundary sensitivity.\n- Test $3$ uses $\\epsilon=10^{-6}$ to challenge the solver with a much sharper quasi-pole, assessing stability and convergence of the complex-energy regularization in a more singular regime.\n\nThe program outputs the twelve floats in the prescribed single-line format, enabling verification and comparison across parameter regimes. No physical units are needed because all quantities are dimensionless in the chosen scaling.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef gauss_legendre_nodes_weights(n, a, b):\n    \"\"\"\n    Compute Gauss-Legendre nodes and weights mapped from [-1,1] to [a,b].\n    Returns nodes q_j and base weights w_base_j (Jacobian included but not q^2).\n    \"\"\"\n    # Legendre nodes and weights on [-1,1]\n    x, w = np.polynomial.legendre.leggauss(n)\n    # Map to [a,b]\n    q = 0.5 * (b - a) * (x + 1.0) + a\n    jac = 0.5 * (b - a)\n    w_base = w * jac\n    return q, w_base\n\ndef build_blocks(k_nodes, w_radial, params):\n    \"\"\"\n    Build the four N x N kernel blocks K11, K12, K21, K22.\n    w_radial are the full radial weights including q^2 factor.\n    params: dict containing m, E, eps, Lambda, lambdas\n    \"\"\"\n    N = len(k_nodes)\n    m = params[\"m\"]\n    E = params[\"E\"]\n    eps = params[\"eps\"]\n    Lam = params[\"Lambda\"]\n    lam11 = params[\"lam11\"]\n    lam12 = params[\"lam12\"]\n    lam21 = params[\"lam21\"]\n    lam22 = params[\"lam22\"]\n\n    # Precompute V(k_i, k_j) and resolvent\n    k_i = k_nodes[:, None]  # shape (N,1)\n    k_j = k_nodes[None, :]  # shape (1,N)\n    V = np.exp(-(k_i**2 + k_j**2) / (Lam**2))\n    denom = (E - (k_i**2 + k_j**2) / (2.0 * m)) + 1j * eps\n    G0 = 1.0 / denom\n\n    # Each block includes weights w_j (radial) on the right\n    W = w_radial[None, :]  # shape (1,N)\n\n    K11 = (lam11 * V * G0) * W\n    K12 = (lam12 * V * G0) * W\n    K21 = (lam21 * V * G0) * W\n    K22 = (lam22 * V * G0) * W\n\n    return K11, K12, K21, K22\n\ndef build_system(N, kmax, m, E, eps, Lambda, Lambda_g, lam11, lam12, lam21, lam22):\n    \"\"\"\n    Construct the block matrix (I - K) and RHS vector g for the coupled system.\n    \"\"\"\n    # Nodes and base weights on [0, kmax]\n    k_nodes, w_base = gauss_legendre_nodes_weights(N, 0.0, kmax)\n    # Radial weights include q^2 factor\n    w_radial = w_base * (k_nodes**2)\n\n    # Driving terms g1, g2\n    g1 = np.exp(-(k_nodes**2) / (Lambda_g**2))\n    g2 = np.exp(-(k_nodes**2) / (Lambda_g**2))\n\n    # Kernel blocks\n    params = {\n        \"m\": m, \"E\": E, \"eps\": eps, \"Lambda\": Lambda,\n        \"lam11\": lam11, \"lam12\": lam12, \"lam21\": lam21, \"lam22\": lam22\n    }\n    K11, K12, K21, K22 = build_blocks(k_nodes, w_radial, params)\n\n    # Assemble block matrix A = I - K\n    I = np.eye(N, dtype=complex)\n    A11 = I - K11\n    A12 = -K12\n    A21 = -K21\n    A22 = I - K22\n\n    # Stack into 2N x 2N\n    top = np.concatenate([A11, A12], axis=1)\n    bottom = np.concatenate([A21, A22], axis=1)\n    A = np.concatenate([top, bottom], axis=0)\n\n    # RHS vector g (stacked)\n    g = np.concatenate([g1, g2]).astype(complex)\n\n    return A, g, k_nodes, w_radial\n\ndef solve_case(case):\n    \"\"\"\n    Solve one test case and return diagnostics:\n    [||Re(F1)||2, ||Re(F2)||2, ||Im(F1)||2, ||Im(F2)||2]\n    \"\"\"\n    N = case[\"N\"]\n    kmax = case[\"kmax\"]\n    m = case[\"m\"]\n    E = case[\"E\"]\n    eps = case[\"eps\"]\n    Lambda = case[\"Lambda\"]\n    Lambda_g = case[\"Lambda_g\"]\n    lam11 = case[\"lam11\"]\n    lam12 = case[\"lam12\"]\n    lam21 = case[\"lam21\"]\n    lam22 = case[\"lam22\"]\n\n    A, g, k_nodes, w_radial = build_system(N, kmax, m, E, eps, Lambda, Lambda_g, lam11, lam12, lam21, lam22)\n\n    # Solve linear system\n    F = np.linalg.solve(A, g)\n\n    # Split components\n    F1 = F[:N]\n    F2 = F[N:]\n\n    # Compute norms using radial weights\n    re_F1 = np.real(F1)\n    re_F2 = np.real(F2)\n    im_F1 = np.imag(F1)\n    im_F2 = np.imag(F2)\n\n    # Quadrature-based L2 norms\n    n_re_F1 = float(np.sqrt(np.sum(w_radial * (re_F1**2))))\n    n_re_F2 = float(np.sqrt(np.sum(w_radial * (re_F2**2))))\n    n_im_F1 = float(np.sqrt(np.sum(w_radial * (im_F1**2))))\n    n_im_F2 = float(np.sqrt(np.sum(w_radial * (im_F2**2))))\n\n    return [n_re_F1, n_re_F2, n_im_F1, n_im_F2]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"N\": 64, \"kmax\": 4.0, \"m\": 1.0, \"E\": 8.0, \"eps\": 1e-2,\n            \"Lambda\": 2.0, \"Lambda_g\": 2.0,\n            \"lam11\": 0.5, \"lam12\": 0.2, \"lam21\": 0.2, \"lam22\": 0.5\n        },\n        {\n            \"N\": 64, \"kmax\": 4.0, \"m\": 1.0, \"E\": 0.1, \"eps\": 1e-2,\n            \"Lambda\": 2.0, \"Lambda_g\": 2.0,\n            \"lam11\": 0.5, \"lam12\": 0.2, \"lam21\": 0.2, \"lam22\": 0.5\n        },\n        {\n            \"N\": 80, \"kmax\": 4.0, \"m\": 1.0, \"E\": 8.0, \"eps\": 1e-6,\n            \"Lambda\": 2.0, \"Lambda_g\": 2.0,\n            \"lam11\": 0.5, \"lam12\": 0.2, \"lam21\": 0.2, \"lam22\": 0.5\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        diagnostics = solve_case(case)\n        results.extend(diagnostics)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3608810"}, {"introduction": "A numerical result is only meaningful if its accuracy can be quantified. This final practice addresses the critical task of convergence analysis, which ensures that the solution is stable with respect to the necessary numerical cutoffs, such as mesh density, partial-wave expansion, and regulator parameters [@problem_id:3608783]. Using a realistic model for how errors decrease as these cutoffs are improved, you will implement quantitative criteria to determine if a calculation has reached a desired level of precision, a fundamental skill for producing reliable scientific results.", "problem": "Design a fully specified numerical convergence study for the Yakubovsky equations applied to the $N$-body problem in computational nuclear physics. Begin from the following fundamental base: the Yakubovsky equations result from a Faddeev-type decomposition of the $N$-body Schrödinger equation into coupled integral equations in momentum space; numerical solutions require discretization in a chosen basis, typically a partial-wave expansion truncated at a finite maximum orbital angular momentum, a finite momentum mesh, and an ultraviolet regulator that suppresses high-momentum components consistent with Effective Field Theory (EFT). Numerical discretization produces controllable errors. For short-range nuclear forces, the error from partial-wave truncation decays rapidly with the maximum orbital angular momentum cutoff due to the centrifugal barrier, while quadrature errors decay as powers of the number of mesh points for sufficiently smooth kernels, and regulator artifacts typically scale as inverse powers of the regulator cutoff.\n\nTo make this study purely computational and testable, model the dependence of the bound-state energy and elastic scattering phase shifts on the discretization and regulator as follows. Let the infinite-resolution (continuum-limit) bound-state energy be a constant $E_\\infty = -14.5 \\text{ MeV}$. For a finite momentum mesh with $N_k$ nodes, a maximum partial-wave cutoff $l_{\\max}$, and an ultraviolet regulator characterized by a cutoff $\\Lambda$ (in $\\text{fm}^{-1}$), define the model finite-resolution bound-state energy by\n$$\nE_b(N_k,l_{\\max},\\Lambda) = E_\\infty + \\frac{A_E}{N_k^{p_E}} + B_E \\, e^{-\\beta_E \\, l_{\\max}} + \\frac{C_E}{\\Lambda^{q_E}},\n$$\nwith constants $A_E = 3.2 \\text{ MeV}, \\quad p_E = 2.0, \\quad B_E = 1.5 \\text{ MeV}, \\quad \\beta_E = 0.9, \\quad C_E = 2.4 \\text{ MeV}, \\quad q_E = 2.0$.\n\nFor elastic $S$-wave scattering phase shifts at laboratory momenta $k$ (in $\\text{fm}^{-1}$), use the effective-range expansion as a physically motivated baseline. Define the continuum-limit phase shift $\\delta_\\infty(k)$ (in radians) by\n$$\nk \\cot \\delta_\\infty(k) = -\\frac{1}{a} + \\frac{1}{2} r_e k^2, \\quad \\delta_\\infty(k) = \\arctan\\!\\left(\\frac{k}{-\\frac{1}{a} + \\frac{1}{2} r_e k^2}\\right),\n$$\nwith scattering length $a = 5.4 \\text{ fm}$ and effective range $r_e = 1.8 \\text{ fm}$. The finite-resolution phase shift is modeled by\n$$\n\\delta(N_k,l_{\\max},\\Lambda;k) = \\delta_\\infty(k) + \\left[\\frac{A_\\delta}{N_k^{p_\\delta}} + B_\\delta \\, e^{-\\beta_\\delta \\, l_{\\max}} + \\frac{C_\\delta}{\\Lambda^{q_\\delta}}\\right],\n$$\nwhere the bracketed correction is in radians, with constants chosen to yield realistic magnitudes at typical discretizations:\n$A_\\delta = \\frac{2.5 \\pi}{180}, \\quad p_\\delta = 1.5, \\quad B_\\delta = \\frac{3.5 \\pi}{180}, \\quad \\beta_\\delta = 0.7, \\quad C_\\delta = \\frac{2.0 \\pi}{180}, \\quad q_\\delta = 2.0.$\nThese constants correspond to $2.5$, $3.5$, and $2.0$ degrees converted to radians.\n\nQuantitative acceptance criteria for convergence:\n- For the binding energy, define a refined calculation that doubles the mesh density, increments the partial-wave cutoff by $2$, and increases the regulator cutoff by $1.0 \\text{ fm}^{-1}$, i.e., compute $E_b'$ at parameters $N_k' = 2 N_k, \\quad l_{\\max}' = l_{\\max} + 2, \\quad \\Lambda' = \\Lambda + 1.0 \\text{ fm}^{-1}$. Accept the energy as converged if\n$$\n\\left|E_b' - E_b\\right| \\le \\max\\!\\left(\\varepsilon_E^{\\text{abs}}, \\, \\varepsilon_E^{\\text{rel}} \\, \\left|E_b'\\right|\\right),\n$$\nwith absolute tolerance $\\varepsilon_E^{\\text{abs}} = 0.05 \\text{ MeV}$ and relative tolerance $\\varepsilon_E^{\\text{rel}} = 10^{-3}$.\n- For the phase shifts, evaluate at a set of laboratory momenta $\\{k\\} = \\{0.4, \\, 1.0, \\, 2.0\\} \\text{ fm}^{-1}$. Compute $\\delta$ and $\\delta'$ (both in degrees) at $(N_k,l_{\\max},\\Lambda)$ and $(N_k',l_{\\max}',\\Lambda')$. Accept the phase shifts as converged if\n$$\n\\max_{k \\in \\{0.4, 1.0, 2.0\\}}\\left|\\delta'(k) - \\delta(k)\\right| \\le \\varepsilon_\\delta^{\\text{abs}},\n$$\nwith absolute tolerance $\\varepsilon_\\delta^{\\text{abs}} = 0.1 \\text{ degrees}$.\nA parameter set is accepted as converged if both the binding energy and all tested phase shifts meet their respective criteria.\n\nImplement a program that, for each parameter triplet $(N_k,l_{\\max},\\Lambda)$ in the test suite below, computes the modeled $E_b$ and $\\delta(k)$, then computes the refined $E_b'$ and $\\delta'(k)$, applies the acceptance criteria, and outputs a boolean for each case indicating whether the case is converged. Use energies in $\\text{MeV}$ and angles in degrees. The regulator cutoff $\\Lambda$ is in $\\text{fm}^{-1}$, and momenta $k$ are in $\\text{fm}^{-1}$. The test suite is:\n- Case $1$: $(N_k,l_{\\max},\\Lambda) = (64, \\, 8, \\, 6.0)$.\n- Case $2$: $(N_k,l_{\\max},\\Lambda) = (24, \\, 3, \\, 2.0)$.\n- Case $3$: $(N_k,l_{\\max},\\Lambda) = (128, \\, 6, \\, 3.0)$.\n- Case $4$: $(N_k,l_{\\max},\\Lambda) = (80, \\, 5, \\, 6.0)$.\n- Case $5$: $(N_k,l_{\\max},\\Lambda) = (32, \\, 10, \\, 4.5)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., `[result_1,result_2,result_3,result_4,result_5]`), where each entry is a boolean $True$ or $False$ indicating whether the corresponding case is converged according to the criteria above. No other text should be printed.", "solution": "The problem requires the implementation of a numerical convergence study for a model of the $N$-body problem in nuclear physics, solved using Yakubovsky equations. The study assesses whether a given set of discretization parameters—momentum mesh nodes $N_k$, partial-wave cutoff $l_{\\max}$, and regulator cutoff $\\Lambda$—achieves a desired level of numerical precision for the bound-state energy $E_b$ and elastic scattering phase shifts $\\delta(k)$. The solution involves creating functions to model these observables, implementing the specified convergence criteria, and applying them to a suite of test cases.\n\nThe methodological approach is as follows:\n1.  Define all physical and model constants as provided in the problem statement.\n2.  Implement a function to calculate the modeled bound-state energy $E_b(N_k, l_{\\max}, \\Lambda)$.\n3.  Implement a set of functions to calculate the modeled phase shift $\\delta(N_k, l_{\\max}, \\Lambda; k)$. Because the numerical error term is independent of momentum $k$, we can significantly simplify the calculation for the convergence criterion.\n4.  For each test case, apply the convergence criteria by comparing a calculation at the given parameters $(N_k, l_{\\max}, \\Lambda)$ with a more refined calculation at parameters $(N_k', l_{\\max}', \\Lambda')$.\n5.  Aggregate the boolean convergence results for all test cases and format the output as specified.\n\nThe first step is to implement the function for the bound-state energy, $E_b$. The model is given by\n$$\nE_b(N_k,l_{\\max},\\Lambda) = E_\\infty + \\frac{A_E}{N_k^{p_E}} + B_E \\, e^{-\\beta_E \\, l_{\\max}} + \\frac{C_E}{\\Lambda^{q_E}}\n$$\nwhere $E_\\infty = -14.5 \\text{ MeV}$ is the continuum-limit energy, and the other constants ($A_E, p_E, B_E, \\beta_E, C_E, q_E$) characterize the errors from momentum discretization, partial-wave truncation, and the regulator, respectively. This function will take $N_k$, $l_{\\max}$, and $\\Lambda$ as inputs and return the energy in $\\text{MeV}$.\n\nNext, we implement the calculation for the phase shift, $\\delta$. The model is\n$$\n\\delta(N_k,l_{\\max},\\Lambda;k) = \\delta_\\infty(k) + \\Delta\\delta(N_k, l_{\\max}, \\Lambda)\n$$\nwhere $\\delta_\\infty(k)$ is the continuum-limit phase shift and $\\Delta\\delta$ is the numerical error term. The continuum-limit contribution is defined by the effective-range expansion:\n$$\n\\delta_\\infty(k) = \\arctan\\!\\left(\\frac{k}{-\\frac{1}{a} + \\frac{1}{2} r_e k^2}\\right)\n$$\nwith scattering length $a = 5.4 \\text{ fm}$ and effective range $r_e = 1.8 \\text{ fm}$. The numerical error term, given in radians, is\n$$\n\\Delta\\delta(N_k, l_{\\max}, \\Lambda) = \\frac{A_\\delta}{N_k^{p_\\delta}} + B_\\delta \\, e^{-\\beta_\\delta \\, l_{\\max}} + \\frac{C_\\delta}{\\Lambda^{q_\\delta}}\n$$\nThe constants $A_\\delta, p_\\delta, B_\\delta, \\beta_\\delta, C_\\delta, q_\\delta$ are provided. Note that the error term $\\Delta\\delta$ is independent of the momentum $k$.\n\nThe core of the problem is to assess convergence. For each parameter set $(N_k, l_{\\max}, \\Lambda)$, we define a refined set $(N_k', l_{\\max}', \\Lambda')$ where $N_k' = 2 N_k$, $l_{\\max}' = l_{\\max} + 2$, and $\\Lambda' = \\Lambda + 1.0 \\text{ fm}^{-1}$.\n\nThe energy is deemed converged if the absolute difference between the refined and original calculations is within a mixed absolute-relative tolerance:\n$$\n\\left|E_b(N_k', l_{\\max}', \\Lambda') - E_b(N_k, l_{\\max}, \\Lambda)\\right| \\le \\max\\!\\left(\\varepsilon_E^{\\text{abs}}, \\, \\varepsilon_E^{\\text{rel}} \\, \\left|E_b(N_k', l_{\\max}', \\Lambda')\\right|\\right)\n$$\nwith $\\varepsilon_E^{\\text{abs}} = 0.05 \\text{ MeV}$ and $\\varepsilon_E^{\\text{rel}} = 10^{-3}$. We will compute both energies $E_b$ and $E_b'$, calculate the tolerance, and check this inequality.\n\nThe phase shifts are deemed converged if the maximum absolute difference between the refined and original calculations, evaluated over the momentum set $\\{k\\} = \\{0.4, \\, 1.0, \\, 2.0\\} \\text{ fm}^{-1}$, is below an absolute tolerance. The difference is required in degrees.\n$$\n\\max_{k}\\left|\\delta(N_k', l_{\\max}', \\Lambda'; k) - \\delta(N_k, l_{\\max}, \\Lambda; k)\\right| \\le \\varepsilon_\\delta^{\\text{abs}}\n$$\nwith $\\varepsilon_\\delta^{\\text{abs}} = 0.1 \\text{ degrees}$. A crucial simplification arises from the structure of $\\delta(k)$. The difference is:\n$$\n\\delta'(k) - \\delta(k) = \\left(\\delta_\\infty(k) + \\Delta\\delta'\\right) - \\left(\\delta_\\infty(k) + \\Delta\\delta\\right) = \\Delta\\delta' - \\Delta\\delta.\n$$\nThis difference is independent of $k$. Therefore, we only need to compute the difference between the error terms, $\\Delta\\delta(N_k', l_{\\max}', \\Lambda') - \\Delta\\delta(N_k, l_{\\max}, \\Lambda)$, convert this difference from radians to degrees, and check if its absolute value is less than or equal to $\\varepsilon_\\delta^{\\text{abs}}$.\n\nA test case is considered converged only if both the energy and the phase shift criteria are met. The final program will iterate through each test case, perform these checks, and store a boolean result ($True$ for converged, $False$ for not). The list of booleans is then printed in the specified format. The implementation will use the `numpy` library for mathematical functions like `exp` and `pi`.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries are used.\n\ndef solve():\n    \"\"\"\n    Implements a numerical convergence study for a model of the N-body problem.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (64, 8, 6.0),  # Case 1\n        (24, 3, 2.0),  # Case 2\n        (128, 6, 3.0), # Case 3\n        (80, 5, 6.0),  # Case 4\n        (32, 10, 4.5), # Case 5\n    ]\n    \n    # Constants for the bound-state energy model\n    E_infinity = -14.5  # MeV\n    A_E = 3.2           # MeV\n    p_E = 2.0\n    B_E = 1.5           # MeV\n    beta_E = 0.9\n    C_E = 2.4           # MeV\n    q_E = 2.0\n    \n    # Constants for the phase shift model\n    # a = 5.4 fm, r_e = 1.8 fm (not needed for convergence check)\n    A_delta = 2.5 * np.pi / 180.0\n    p_delta = 1.5\n    B_delta = 3.5 * np.pi / 180.0\n    beta_delta = 0.7\n    C_delta = 2.0 * np.pi / 180.0\n    q_delta = 2.0\n    \n    # Convergence criteria tolerances\n    eps_E_abs = 0.05  # MeV\n    eps_E_rel = 1e-3\n    eps_delta_abs = 0.1  # degrees\n    \n    # Momenta for phase shift evaluation (not directly needed due to simplification)\n    # k_values = [0.4, 1.0, 2.0]\n\n    def calculate_Eb(Nk, lmax, Lambda):\n        \"\"\"Calculates the modeled bound-state energy E_b.\"\"\"\n        error_term = (A_E / (Nk**p_E)) + \\\n                     (B_E * np.exp(-beta_E * lmax)) + \\\n                     (C_E / (Lambda**q_E))\n        return E_infinity + error_term\n\n    def calculate_delta_error_rad(Nk, lmax, Lambda):\n        \"\"\"Calculates the error term for the phase shift in radians.\"\"\"\n        error_term = (A_delta / (Nk**p_delta)) + \\\n                     (B_delta * np.exp(-beta_delta * lmax)) + \\\n                     (C_delta / (Lambda**q_delta))\n        return error_term\n\n    results = []\n    for case in test_cases:\n        Nk, lmax, Lambda = case\n        \n        # Define refined parameters\n        Nk_prime = 2 * Nk\n        lmax_prime = lmax + 2\n        Lambda_prime = Lambda + 1.0\n        \n        # 1. Energy convergence check\n        E_b = calculate_Eb(Nk, lmax, Lambda)\n        E_b_prime = calculate_Eb(Nk_prime, lmax_prime, Lambda_prime)\n        \n        energy_diff = abs(E_b_prime - E_b)\n        energy_tolerance = max(eps_E_abs, eps_E_rel * abs(E_b_prime))\n        \n        energy_converged = (energy_diff = energy_tolerance)\n        \n        # 2. Phase shift convergence check\n        # The difference delta'(k) - delta(k) is independent of k.\n        # We calculate the difference of the error terms directly.\n        delta_error_rad = calculate_delta_error_rad(Nk, lmax, Lambda)\n        delta_error_prime_rad = calculate_delta_error_rad(Nk_prime, lmax_prime, Lambda_prime)\n        \n        delta_diff_rad = delta_error_prime_rad - delta_error_rad\n        delta_diff_deg = np.rad2deg(delta_diff_rad)\n        \n        # max_k |delta'(k) - delta(k)| is just |delta_diff_deg|\n        max_delta_diff_deg = abs(delta_diff_deg)\n        \n        delta_converged = (max_delta_diff_deg = eps_delta_abs)\n        \n        # 3. Overall convergence\n        is_converged = energy_converged and delta_converged\n        results.append(is_converged)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3608783"}]}