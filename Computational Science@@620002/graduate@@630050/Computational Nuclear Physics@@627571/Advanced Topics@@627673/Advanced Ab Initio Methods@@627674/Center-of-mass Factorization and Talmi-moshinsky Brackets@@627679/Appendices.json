{"hands_on_practices": [{"introduction": "To build a solid foundation, our first practice focuses on the fundamental properties of the Talmi-Moshinsky (TM) transformation. We will begin with the simplest non-trivial case: a two-particle system with equal masses in a harmonic oscillator potential. This exercise [@problem_id:3549194] requires deriving the transformation coefficients from first principles using ladder operators and then implementing a numerical verification of their orthogonality, confirming that the transformation is indeed a unitary rotation between the single-particle and the relative/center-of-mass bases.", "problem": "You are tasked with deriving, implementing, and numerically verifying the orthogonality and completeness relations for Talmi-Moshinsky (TM) transformation matrices in the special case of two equal-mass particles in an isotropic harmonic oscillator and restricted to the total orbital angular momentum zero sector (also called the $s$-wave sector). The TM transformation connects the two-particle single-particle basis to the relative and center-of-mass (COM) basis. In the $s$-wave sector, the transformation preserves the total number of oscillator quanta and is characterized by quantum numbers $(n,l,N,L)$ under the constraint $2n + l + 2N + L = N_{\\text{tot}}$.\n\nStart from the following context-appropriate fundamental base:\n- The two-particle isotropic harmonic oscillator Hamiltonian $H = H_1 + H_2$ with equal masses and identical oscillator frequency separates into relative and center-of-mass parts under the orthogonal coordinate transformation $\\boldsymbol{r} = (\\boldsymbol{r}_1 - \\boldsymbol{r}_2)/\\sqrt{2}$ and $\\boldsymbol{R} = (\\boldsymbol{r}_1 + \\boldsymbol{r}_2)/\\sqrt{2}$, and similarly for their associated ladder operators $a_r = (a_1 - a_2)/\\sqrt{2}$ and $a_R = (a_1 + a_2)/\\sqrt{2}$.\n- In the $s$-wave sector (total orbital angular momentum zero), the basis states are characterized by radial quantum numbers $n$ and $N$ for the relative and center-of-mass sectors, respectively, with $l = L = 0$. The energy counting condition becomes $2n + 2N = N_{\\text{tot}}$, so $N_{\\text{tot}}$ must be even in this sector.\n\nYour objective is to:\n1. Derive from the ladder-operator relations the explicit linear transformation coefficients between the single-particle number-state basis $\\{|n_1, n_2\\rangle\\}$ and the relative/COM number-state basis $\\{|n, N\\rangle\\}$ in the $s$-wave sector, at fixed $N_{\\text{tot}} = 2n + 2N = 2n_1 + 2n_2$. Show that these coefficients arise from an orthogonal change of variables and are therefore unitary on the subspace of fixed $N_{\\text{tot}}$.\n2. Implement a numerical routine that constructs the TM transformation matrix $U$ for the $s$-wave sector at a given even $N_{\\text{tot}}$. Enumerate all permissible $(n,l,N,L)$ with $l=L=0$ and $2n + 2N = N_{\\text{tot}}$, and all corresponding single-particle pairs $(n_1, n_2)$ obeying $2n_1 + 2n_2 = N_{\\text{tot}}$. The matrix $U$ must map the relative/COM basis to the single-particle basis at fixed $N_{\\text{tot}}$.\n3. Verify orthogonality and completeness numerically by computing $U^\\dagger U$ and checking equality to the identity matrix $\\mathbb{1}$ to within an absolute tolerance of $10^{-12}$.\n\nConstraints and specifications:\n- Restrict to the $s$-wave sector, i.e., $l = L = 0$, so $N_{\\text{tot}}$ must be even. Enumerate all permissible $(n,N)$ pairs satisfying $2n + 2N = N_{\\text{tot}}$.\n- Derive and use a formula for the transformation coefficients that follows from the bosonic ladder operator identities and binomial expansions. Do not assume any pre-derived TM bracket tables.\n- No physical units appear in the final numerical verification; all computations are purely dimensionless overlaps under harmonic oscillator algebra.\n- The test suite consists of the following values of $N_{\\text{tot}}$: $0$, $2$, $4$, and $6$. For each case, construct $U$, compute $U^\\dagger U$, and check the maximum absolute deviation from the identity matrix. The result for each test case must be a boolean indicating whether $U^\\dagger U$ equals $\\mathbb{1}$ within the $10^{-12}$ tolerance.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4]\"), where each result is a boolean corresponding to one test case in the order $N_{\\text{tot}} = 0, 2, 4, 6$.", "solution": "The problem requires the derivation, implementation, and verification of the Talmi-Moshinsky (TM) transformation for a special case: two equal-mass particles in an isotropic harmonic oscillator, restricted to the $s$-wave sector where total orbital angular momentum is zero.\n\nThe transformation connects the single-particle (SP) basis, denoted by $|n_1, l_1=0; n_2, l_2=0\\rangle$, to the relative and center-of-mass (COM) basis, denoted by $|n, l=0; N, L=0\\rangle$. The quantum numbers $n_1, n_2, n, N$ are the radial quantum numbers. For simplicity, we will abbreviate the states as $|n_1, n_2\\rangle$ and $|n, N\\rangle$. The total number of oscillator quanta, $N_{\\text{tot}}$, is a conserved quantity. For s-wave states, the energy is proportional to $2n_{rad} + 3/2$, so the number of quanta is $2n_{rad}$. The conservation condition is thus $N_{\\text{tot}} = 2n_1 + 2n_2 = 2n + 2N$, which implies $N_{\\text_tot}$ must be even. Let $M = N_{\\text{tot}}/2$. The conservation law simplifies to $M = n_1 + n_2 = n + N$. This mathematical structure is identical to that of a two-particle system in a one-dimensional harmonic oscillator, where $M$ is the total number of quanta. The derivation will therefore proceed using the formalism of the one-dimensional harmonic oscillator, as suggested by the provided ladder operator relations.\n\nThe transformation matrix $U$ maps an orthonormal basis to another orthonormal basis, and is therefore unitary. As the coefficients are real, it is an orthogonal matrix, satisfying $U^\\dagger U = U^T U = \\mathbb{1}$. The elements of $U$ are the overlaps, or Talmi-Moshinsky brackets, $U_{ij} = \\langle \\text{sp}_i | \\text{rel-COM}_j \\rangle$. The problem specifies that $U$ maps the rel-COM basis to the SP basis, meaning $|\\text{sp}_i\\rangle = \\sum_j U_{ij} |\\text{rel-COM}_j\\rangle$. This implies $U_{ij} = \\langle \\text{rel-COM}_j | \\text{sp}_i \\rangle$. We will let the index $i$ correspond to the SP state with $n_1=i$ (and thus $n_2=M-i$), and the index $j$ correspond to the rel-COM state with $n=j$ (and $N=M-j$), for $i,j \\in \\{0, 1, \\dots, M\\}$.\n\nThe derivation begins with the relationship between the ladder operators. The transformation from single-particle coordinates $(\\boldsymbol{r}_1, \\boldsymbol{r}_2)$ to relative/COM coordinates $(\\boldsymbol{r}, \\boldsymbol{R})$ is orthogonal. This leads to a corresponding orthogonal transformation for the creation and annihilation operators. For the 1D case:\n$$ a_r^\\dagger = \\frac{1}{\\sqrt{2}}(a_1^\\dagger - a_2^\\dagger) \\quad ; \\quad a_R^\\dagger = \\frac{1}{\\sqrt{2}}(a_1^\\dagger + a_2^\\dagger) $$\nThe inverse transformation is:\n$$ a_1^\\dagger = \\frac{1}{\\sqrt{2}}(a_R^\\dagger + a_r^\\dagger) \\quad ; \\quad a_2^\\dagger = \\frac{1}{\\sqrt{2}}(a_R^\\dagger - a_r^\\dagger) $$\nA state in the SP basis is constructed by applying these creation operators to the vacuum state $|0,0\\rangle$:\n$$ |n_1, n_2\\rangle = \\frac{(a_1^\\dagger)^{n_1}}{\\sqrt{n_1!}} \\frac{(a_2^\\dagger)^{n_2}}{\\sqrt{n_2!}} |0,0\\rangle $$\nSubstituting the expressions for $a_1^\\dagger$ and $a_2^\\dagger$:\n$$ |n_1, n_2\\rangle = \\frac{1}{\\sqrt{n_1!n_2!}} \\left( \\frac{a_R^\\dagger + a_r^\\dagger}{\\sqrt{2}} \\right)^{n_1} \\left( \\frac{a_R^\\dagger - a_r^\\dagger}{\\sqrt{2}} \\right)^{n_2} |0,0\\rangle $$\nSince the relative and COM operators act on independent spaces, $[a_r^\\dagger, a_R^\\dagger] = 0$. We can use the binomial theorem to expand the terms:\n$$ |n_1, n_2\\rangle = \\frac{1}{\\sqrt{n_1!n_2!}} \\frac{1}{2^{(n_1+n_2)/2}} \\left( \\sum_{k_1=0}^{n_1} \\binom{n_1}{k_1} (a_R^\\dagger)^{n_1-k_1} (a_r^\\dagger)^{k_1} \\right) \\left( \\sum_{k_2=0}^{n_2} \\binom{n_2}{k_2} (a_R^\\dagger)^{n_2-k_2} (-a_r^\\dagger)^{k_2} \\right) |0,0\\rangle $$\nCombining the sums and rearranging terms:\n$$ |n_1, n_2\\rangle = \\frac{1}{\\sqrt{n_1!n_2!}} \\frac{1}{2^{M/2}} \\sum_{k_1=0}^{n_1} \\sum_{k_2=0}^{n_2} \\binom{n_1}{k_1} \\binom{n_2}{k_2} (-1)^{k_2} (a_R^\\dagger)^{n_1+n_2-k_1-k_2} (a_r^\\dagger)^{k_1+k_2} |0,0\\rangle $$\nWe want to express this as a superposition of rel-COM basis states $|n, N\\rangle = \\frac{(a_r^\\dagger)^n}{\\sqrt{n!}} \\frac{(a_R^\\dagger)^N}{\\sqrt{N!}}|0,0\\rangle$. This means we identify $n = k_1+k_2$ and $N = n_1+n_2-k_1-k_2 = M-n$. The un-normalized state is $(a_R^\\dagger)^N (a_r^\\dagger)^n |0,0\\rangle = \\sqrt{n!N!} |n,N\\rangle$.\n$$ |n_1, n_2\\rangle = \\frac{1}{\\sqrt{n_1!n_2!}} \\frac{1}{2^{M/2}} \\sum_{n=0}^{M} \\left( \\sum_{\\substack{k_1+k_2=n \\\\ 0\\le k_1 \\le n_1 \\\\ 0\\le k_2 \\le n_2}} \\binom{n_1}{k_1} \\binom{n_2}{k_2} (-1)^{k_2} \\right) \\sqrt{n!(M-n)!} |n, M-n\\rangle $$\nThe coefficient of $|n, N\\rangle$ in this expansion is the TM bracket $\\langle n, N | n_1, n_2 \\rangle$. Setting $k_2 = n-k_1$, the sum is over $k_1$. The summation limits for $k_1$ are $\\max(0, n-n_2) \\le k_1 \\le \\min(n, n_1)$.\n$$ \\langle n, N | n_1, n_2 \\rangle = \\frac{\\sqrt{n!N!}}{\\sqrt{n_1!n_2!}} \\frac{1}{2^{M/2}} \\sum_{k_1=\\max(0,n-n_2)}^{\\min(n,n_1)} \\binom{n_1}{k_1} \\binom{n_2}{n-k_1} (-1)^{n-k_1} $$\nThis is the formula for the transformation coefficient, where $n_1+n_2=n+N=M$.\n\nTo implement this numerically, we construct the $(M+1) \\times (M+1)$ matrix $U$ for a given $N_{\\text{tot}} = 2M$. The rows are indexed by $i=n_1 \\in \\{0, \\dots, M\\}$ and columns by $j=n \\in \\{0, \\dots, M\\}$.\nThe matrix element $U_{ij} = \\langle n=j, N=M-j | n_1=i, n_2=M-i \\rangle$ is:\n$$ U_{ij} = \\frac{\\sqrt{j!(M-j)!}}{\\sqrt{i!(M-i)!}} \\frac{1}{2^{M/2}} \\sum_{k=\\max(0,i+j-M)}^{\\min(i,j)} (-1)^{j-k} \\binom{i}{k} \\binom{M-i}{j-k} $$\nThe algorithm is as follows:\n1. For each $N_{\\text{tot}}$ in the test suite $\\{0, 2, 4, 6\\}$, calculate $M=N_{\\text{tot}}/2$.\n2. Create an $(M+1) \\times (M+1)$ matrix $U$.\n3. For each row $i \\in \\{0, \\dots, M\\}$ and column $j \\in \\{0, \\dots, M\\}$, calculate the element $U_{ij}$ using the derived formula. Factorials and binomial coefficients are computed using `scipy.special`.\n4. After constructing $U$, compute the product $P = U^T U$. Since $U$ is real, $U^\\dagger = U^T$.\n5. Compute the maximum absolute difference between $P$ and the identity matrix $\\mathbb{1}$ of the same dimension: $\\max(|\\mathbb{1} - P|)$.\n6. If this difference is less than the tolerance $10^{-12}$, the verification for that $N_{\\text{tot}}$ is successful (True), otherwise it fails (False).\n7. Collect the boolean results for all test cases and format the output as specified.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import factorial, binom\n\ndef calculate_tm_matrix(M: int) -> np.ndarray:\n    \"\"\"\n    Constructs the Talmi-Moshinsky transformation matrix for the s-wave sector.\n\n    Args:\n        M: The total number of oscillator quanta pairs, M = N_tot / 2.\n\n    Returns:\n        The (M+1)x(M+1) Talmi-Moshinsky transformation matrix U.\n        The element U_ij = <n=j, N=M-j | n1=i, n2=M-i>.\n    \"\"\"\n    dim = M + 1\n    U = np.zeros((dim, dim), dtype=np.float64)\n\n    for i in range(dim):  # Row index, for single-particle state (n1=i, n2=M-i)\n        n1 = i\n        n2 = M - i\n        for j in range(dim):  # Column index, for rel/COM state (n=j, N=M-j)\n            n = j\n            N = M - j\n            \n            # Normalization factor from wavefunctions\n            norm_factor = np.sqrt(factorial(n) * factorial(N)) / np.sqrt(factorial(n1) * factorial(n2))\n            \n            # Factor from the coordinate transformation\n            power_factor = 1.0 / (2**(M / 2.0))\n            \n            # Summation from binomial expansions\n            sum_val = 0.0\n            k_min = max(0, n1 + n - M)\n            k_max = min(n1, n)\n            \n            for k in range(k_min, k_max + 1):\n                term = (-1)**(n - k) * binom(n1, k) * binom(n2, n - k)\n                sum_val += term\n            \n            U[i, j] = norm_factor * power_factor * sum_val\n            \n    return U\n\ndef solve():\n    \"\"\"\n    Main function to run the verification for the specified test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [0, 2, 4, 6]  # Values of N_tot\n    results = []\n    TOLERANCE = 1e-12\n\n    for N_tot in test_cases:\n        M = N_tot // 2\n        dim = M + 1\n        \n        # Construct the Talmi-Moshinsky matrix U\n        tm_matrix = calculate_tm_matrix(M)\n        \n        # Verify orthogonality: U_dagger * U should be the identity matrix.\n        # Since U is real, U_dagger is U.T\n        identity_matrix = np.identity(dim, dtype=np.float64)\n        product_matrix = tm_matrix.T @ tm_matrix\n        \n        # Check if the product is the identity matrix within the given tolerance.\n        max_abs_diff = np.max(np.abs(product_matrix - identity_matrix))\n        \n        is_orthogonal = max_abs_diff < TOLERANCE\n        results.append(is_orthogonal)\n\n    # Final print statement in the exact required format.\n    # The map call converts boolean True/False to strings \"True\"/\"False\"\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3549194"}, {"introduction": "Building on the equal-mass formalism, we now generalize the Talmi-Moshinsky transformation to systems with unequal masses, which are common in nuclear physics, such as in the study of hypernuclei. This practice [@problem_id:3549238] involves deriving the TM bracket for the general case, parameterized by the mass ratio $\\alpha = m_1/m_2$. By computing these brackets, you will directly observe how the asymmetry breaks selection rules that were enforced by symmetry in the equal-mass case, providing deeper insight into the physical origins of the transformation's structure.", "problem": "Consider a two-body system in a three-dimensional isotropic harmonic oscillator where the single-particle coordinates are decoupled into relative and center-of-mass coordinates. The transformation from single-particle coordinates to relative and center-of-mass coordinates can be represented, in each Cartesian direction, as an orthogonal rotation in the space of dimensionless variables. The Talmi-Moshinsky (TM) brackets arise as the coefficients of this basis transformation from products of single-particle harmonic oscillator states to products of relative and center-of-mass harmonic oscillator states. In equal-mass systems, special selection rules emerge from symmetry under particle exchange that imply the vanishing of certain TM brackets. In hypernuclear systems, the masses are generally unequal, and this asymmetry breaks some of the equal-mass cancellations.\n\nStarting from the following base principles and definitions:\n- The dimensionless single-particle coordinates are defined by $ \\xi_i = x_i / b_i $, where $ x_i $ is the particle coordinate for particle $ i $ and $ b_i = \\sqrt{\\hbar / (m_i \\omega)} $ is the harmonic oscillator length associated with mass $ m_i $ and frequency $ \\omega $.\n- The Gaussian factor in the harmonic oscillator basis is preserved under orthogonal transformations in the dimensionless coordinates.\n- The orthogonal transformation to dimensionless center-of-mass and relative coordinates is $ \\Xi = \\cos \\theta \\, \\xi_1 + \\sin \\theta \\, \\xi_2 $ and $ \\varrho = -\\sin \\theta \\, \\xi_1 + \\cos \\theta \\, \\xi_2 $, with $ \\cos \\theta = \\sqrt{m_1/(m_1+m_2)} $ and $ \\sin \\theta = \\sqrt{m_2/(m_1+m_2)} $, derived from mass-weighted combinations that preserve orthonormality.\n- The physicists' Hermite polynomials $ H_n(\\xi) $ satisfy the generating function $ \\exp\\left(-t^2 + 2 t \\xi\\right) = \\sum_{n=0}^{\\infty} H_n(\\xi) \\, t^n / n! $.\n\nTasks:\n1. Derive the one-dimensional TM bracket $ \\mathcal{M}(N,n;n_1,n_2;\\theta) $ that connects products of single-particle harmonic oscillator eigenstates to products of center-of-mass and relative eigenstates, starting from the generating function of Hermite polynomials and the orthogonal rotation defined above. Show that the bracket vanishes unless $ N+n = n_1 + n_2 $ and provide an explicit expression for $ \\mathcal{M}(N,n;n_1,n_2;\\theta) $ in terms of binomial sums and factorials.\n2. Generalize this bracket to unequal masses parameterized by the mass ratio $ \\alpha = m_1/m_2 $. Express $ \\cos \\theta $ and $ \\sin \\theta $ explicitly in terms of $ \\alpha $.\n3. Implement a program that computes $ \\mathcal{M}(N,n;n_1,n_2;\\alpha) $ for specified integer quantum numbers $ n_1, n_2, N, n $ and mass ratio $ \\alpha $. Use exact integer arithmetic for binomial coefficients and factorials combined with floating-point arithmetic for powers of $ \\cos \\theta $ and $ \\sin \\theta $.\n4. Quantify deviations from equal-mass selection rules by comparing the unequal-mass brackets to the corresponding equal-mass value at $ \\alpha = 1 $. In particular, for configurations that vanish at $ \\alpha = 1 $ by symmetry, compute the absolute deviation $ \\delta(\\alpha) = \\left|\\mathcal{M}(N,n;n_1,n_2;\\alpha) - \\mathcal{M}(N,n;n_1,n_2;1)\\right| = \\left|\\mathcal{M}(N,n;n_1,n_2;\\alpha)\\right| $.\n5. Verify orthonormality for a fixed $ n_1, n_2 $ by checking that $ \\sum_{N=0}^{n_1+n_2} \\left[\\mathcal{M}\\left(N,n_1+n_2-N;n_1,n_2;\\alpha\\right)\\right]^2 = 1 $ within numerical tolerance, which expresses the unitarity of the rotation between the two bases.\n\nUse the following test suite to validate your implementation and analysis. These cases include equal-mass symmetry checks, hypernuclear realistic mass ratios, extreme mass ratios, and a selection rule violation boundary case. For each test case, compute the bracket $ \\mathcal{M} $ and the deviation $ \\delta $ as described.\n\n- Test case 1 (equal-mass symmetry cancellation, happy path): $ \\alpha = 1.0 $, $ n_1 = 1 $, $ n_2 = 1 $, $ N = 1 $, $ n = 1 $. Report $ \\mathcal{M} $, $ \\delta $, and whether the selection rule $ N+n = n_1+n_2 $ is satisfied as a boolean.\n- Test case 2 (realistic hypernuclear mass ratio): $ \\alpha = 1.19 $, $ n_1 = 1 $, $ n_2 = 1 $, $ N = 1 $, $ n = 1 $. Report $ \\mathcal{M} $, $ \\delta $, and selection rule boolean.\n- Test case 3 (extreme mass ratio): $ \\alpha = 10.0 $, $ n_1 = 1 $, $ n_2 = 1 $, $ N = 1 $, $ n = 1 $. Report $ \\mathcal{M} $, $ \\delta $, and selection rule boolean.\n- Test case 4 (another equal-mass symmetry cancellation): $ \\alpha = 1.0 $, $ n_1 = 2 $, $ n_2 = 2 $, $ N = 3 $, $ n = 1 $. Report $ \\mathcal{M} $, $ \\delta $, and selection rule boolean.\n- Test case 5 (unequal masses breaking the cancellation): $ \\alpha = 1.19 $, $ n_1 = 2 $, $ n_2 = 2 $, $ N = 3 $, $ n = 1 $. Report $ \\mathcal{M} $, $ \\delta $, and selection rule boolean.\n- Test case 6 (selection rule violation boundary condition): $ \\alpha = 2.5 $, $ n_1 = 0 $, $ n_2 = 1 $, $ N = 0 $, $ n = 0 $. Report $ \\mathcal{M} $, a deviation computed against $ \\alpha = 1.0 $, and selection rule boolean.\n- Test case 7 (orthonormality check): $ \\alpha = 1.19 $, $ n_1 = 1 $, $ n_2 = 1 $. Compute $ \\sum_{N=0}^{2} \\left[\\mathcal{M}\\left(N,2-N;1,1;\\alpha\\right)\\right]^2 $ and report whether it equals $ 1 $ within a tolerance of $ 10^{-12} $ as a boolean.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,...]\"). Each result should be either a float, a boolean, or a list containing floats and booleans in the order specified for each test case. No additional text should be printed. No physical units are required in this problem as all quantities are dimensionless by construction.", "solution": "The problem requires the derivation and implementation of the one-dimensional Talmi-Moshinsky (TM) bracket for a two-body system in a harmonic oscillator potential, particularly for particles of unequal mass.\n\n### Task 1: Derivation of the Talmi-Moshinsky Bracket\n\nThe one-dimensional harmonic oscillator eigenstate for a particle $i$ with quantum number $n_i$ is given by $\\psi_{n_i}(\\xi_i) = \\mathcal{N}_{n_i} H_{n_i}(\\xi_i) \\exp(-\\xi_i^2/2)$, where $\\xi_i = x_i/b_i$ is the dimensionless coordinate, $H_{n_i}$ is a Hermite polynomial, and $\\mathcal{N}_{n_i} = (2^{n_i} n_i! \\sqrt{\\pi})^{-1/2}$ is the normalization constant. A product of two such single-particle states, $\\psi_{n_1}(\\xi_1)\\psi_{n_2}(\\xi_2)$, can be expanded in the basis of states corresponding to the center-of-mass and relative coordinates, $\\Psi_N(\\Xi)\\Psi_n(\\varrho)$. The coefficients of this expansion are the Talmi-Moshinsky brackets, $\\mathcal{M}(N,n;n_1,n_2;\\theta) = \\langle N, n | n_1, n_2 \\rangle_\\theta$.\n$$\n\\psi_{n_1}(\\xi_1)\\psi_{n_2}(\\xi_2) = \\sum_{N,n} \\mathcal{M}(N,n;n_1,n_2;\\theta) \\Psi_N(\\Xi)\\Psi_n(\\varrho)\n$$\nThe transformation to dimensionless center-of-mass ($\\Xi$) and relative ($\\varrho$) coordinates is an orthogonal rotation:\n$$\n\\begin{pmatrix} \\Xi \\\\ \\varrho \\end{pmatrix} = \\begin{pmatrix} \\cos\\theta & \\sin\\theta \\\\ -\\sin\\theta & \\cos\\theta \\end{pmatrix} \\begin{pmatrix} \\xi_1 \\\\ \\xi_2 \\end{pmatrix}\n$$\nThe inverse transformation is:\n$$\n\\begin{pmatrix} \\xi_1 \\\\ \\xi_2 \\end{pmatrix} = \\begin{pmatrix} \\cos\\theta & -\\sin\\theta \\\\ \\sin\\theta & \\cos\\theta \\end{pmatrix} \\begin{pmatrix} \\Xi \\\\ \\varrho \\end{pmatrix}\n$$\nBecause this transformation is orthogonal, the sum of squares is invariant: $\\xi_1^2 + \\xi_2^2 = \\Xi^2 + \\varrho^2$. This means the Gaussian factor $\\exp(-(\\xi_1^2+\\xi_2^2)/2)$ in the product state is equal to $\\exp(-(\\Xi^2+\\varrho^2)/2)$, which is the Gaussian factor for the center-of-mass and relative state. The transformation thus reduces to a relationship between the polynomial parts of the wavefunctions.\n\nThe physicists' Hermite polynomials $H_k(z)$ have the generating function:\n$$\n\\exp(-t^2 + 2t z) = \\sum_{k=0}^{\\infty} H_k(z) \\frac{t^k}{k!}\n$$\nWe construct the generating function for the product of two Hermite polynomials $H_{n_1}(\\xi_1)H_{n_2}(\\xi_2)$ using two variables, $s$ and $t$:\n$$\n\\sum_{n_1=0}^{\\infty} \\sum_{n_2=0}^{\\infty} H_{n_1}(\\xi_1)H_{n_2}(\\xi_2) \\frac{s^{n_1}}{n_1!} \\frac{t^{n_2}}{n_2!} = \\exp(-s^2 + 2s\\xi_1) \\exp(-t^2 + 2t\\xi_2)\n$$\nSubstitute $\\xi_1 = \\Xi\\cos\\theta - \\varrho\\sin\\theta$ and $\\xi_2 = \\Xi\\sin\\theta + \\varrho\\cos\\theta$ into the exponent:\n$$\n2s\\xi_1 + 2t\\xi_2 = 2s(\\Xi\\cos\\theta - \\varrho\\sin\\theta) + 2t(\\Xi\\sin\\theta + \\varrho\\cos\\theta) = (2s\\cos\\theta + 2t\\sin\\theta)\\Xi + (-2s\\sin\\theta + 2t\\cos\\theta)\\varrho\n$$\nLet's define new generating function variables $S = s\\cos\\theta + t\\sin\\theta$ and $T = -s\\sin\\theta + t\\cos\\theta$. The exponent becomes $2S\\Xi + 2T\\varrho$. The quadratic part of the exponent, $-s^2-t^2$, is invariant under this rotation: $S^2+T^2 = (s\\cos\\theta + t\\sin\\theta)^2 + (-s\\sin\\theta + t\\cos\\theta)^2 = s^2+t^2$.\nSo, the generating function identity becomes:\n$$\n\\exp(-s^2 - t^2 + 2s\\xi_1 + 2t\\xi_2) = \\exp(-S^2 - T^2 + 2S\\Xi + 2T\\varrho) = \\exp(-S^2+2S\\Xi)\\exp(-T^2+2T\\varrho)\n$$\nThis is the product of generating functions for $H_N(\\Xi)$ and $H_n(\\varrho)$:\n$$\n\\sum_{n_1,n_2} \\frac{s^{n_1}t^{n_2}}{n_1!n_2!} H_{n_1}(\\xi_1)H_{n_2}(\\xi_2) = \\left( \\sum_N \\frac{S^N}{N!} H_N(\\Xi) \\right) \\left( \\sum_n \\frac{T^n}{n!} H_n(\\varrho) \\right) = \\sum_{N,n} \\frac{S^N T^n}{N!n!} H_N(\\Xi)H_n(\\varrho)\n$$\nThe relationship between the normalized wavefunctions implies a relationship between the Hermite polynomials scaled by normalization factors. With $N+n=n_1+n_2$, we have:\n$$\n\\frac{H_{n_1}(\\xi_1)H_{n_2}(\\xi_2)}{\\sqrt{n_1!n_2!}} = \\sum_{N,n} \\mathcal{M}(N,n; n_1, n_2; \\theta) \\frac{H_N(\\Xi)H_n(\\varrho)}{\\sqrt{N!n!}}\n$$\nTo find the bracket $\\mathcal{M}$, we extract the coefficient of $s^{n_1}t^{n_2} / (n_1!n_2!)$ on the RHS of the generating function identity. This involves expanding $S^N T^n$ using the binomial theorem:\n$$\nS^N T^n = (s\\cos\\theta + t\\sin\\theta)^N (-s\\sin\\theta + t\\cos\\theta)^n\n$$\nThe term containing $s^{n_1}t^{n_2}$ corresponds to a total power of $s$ being $n_1$ and a total power of $t$ being $n_2$. The total degree of the polynomial in $s$ and $t$ is $N+n$. Therefore, we must have $N+n = n_1+n_2$, which is the fundamental selection rule for the conservation of oscillator quanta. If this condition is not met, the bracket is zero.\n\nLet $[s^{n_1} t^{n_2}]P(s,t)$ be the coefficient of the $s^{n_1}t^{n_2}$ term in polynomial $P(s,t)$.\n$$\n[s^{n_1} t^{n_2}] (S^N T^n) = [s^{n_1} t^{n_2}] \\left(\\sum_{k_1=0}^N \\binom{N}{k_1} (s c)^ {k_1} (t s)^{N-k_1}\\right) \\left(\\sum_{k_2=0}^n \\binom{n}{k_2} (-s s)^{k_2} (t c)^{n-k_2}\\right)\n$$\nwhere $c=\\cos\\theta, s=\\sin\\theta$. Collecting powers of $s$ and $t$:\n$$\n= [s^{n_1} t^{n_2}] \\sum_{k_1, k_2} \\binom{N}{k_1} \\binom{n}{k_2} (-1)^{k_2} s^{k_1+k_2} t^{N-k_1+n-k_2} c^{k_1+n-k_2} s^{N-k_1+k_2}\n$$\nWe need $k_1+k_2=n_1$ and $N-k_1+n-k_2=n_2$. Summing these gives $N+n=n_1+n_2$. Substituting $k_2=n_1-k_1$, we can sum over $k_1$ (which we now call $k$):\n$$\nC(N,n,n_1) = \\sum_{k} (-1)^{n_1-k} \\binom{N}{k} \\binom{n}{n_1-k} (\\cos\\theta)^{k+n-(n_1-k)} (\\sin\\theta)^{N-k+(n_1-k)}\n$$\n$$\nC(N,n,n_1) = \\sum_{k=\\max(0, n_1-n)}^{\\min(N, n_1)} (-1)^{n_1-k} \\binom{N}{k} \\binom{n}{n_1-k} (\\cos\\theta)^{n-n_1+2k} (\\sin\\theta)^{N+n_1-2k}\n$$\nRelating the expansions:\n$$\n\\frac{H_{n_1}H_{n_2}}{n_1!n_2!} = \\sum_{N+n=n_1+n_2} \\frac{H_N H_n}{N!n!} C(N,n,n_1) \\implies H_{n_1}H_{n_2} = \\sum_{N+n=n_1+n_2} \\frac{n_1!n_2!}{N!n!} C(N,n,n_1) H_N H_n\n$$\nComparing this with the expansion in terms of the bracket $\\mathcal{M}$:\n$$\n\\mathcal{M}(N,n; n_1, n_2; \\theta) = \\sqrt{\\frac{n_1!n_2!}{N!n!}} \\frac{n_1!n_2!}{N!n!} C(N,n,n_1) \\frac{\\sqrt{N!n!}}{\\sqrt{n_1!n_2!}}\n$$\nThis seems overly complicated. Let's re-align coefficients directly:\n$H_{n_1} H_{n_2} \\frac{1}{\\sqrt{n_1! n_2!}} = \\sum \\mathcal{M} \\frac{H_N H_n}{\\sqrt{N! n!}}$.\n$\\frac{s^{n_1} t^{n_2}}{\\sqrt{n_1! n_2!}}$ coefficient in the generating function expansion must match.\nFrom $\\sum_{n_1,n_2} \\frac{s^{n_1} t^{n_2}}{n_1! n_2!} H_{n_1}H_{n_2} = \\sum_{N,n} \\frac{S^N T^n}{N!n!} H_N H_n$, we get $H_{n_1}H_{n_2} = n_1! n_2! \\sum_{N,n} \\frac{H_N H_n}{N!n!} [s^{n_1}t^{n_2}](S^N T^n)$.\nSubstituting this into the bracket relation:\n$\\frac{n_1! n_2!}{\\sqrt{n_1! n_2!}} \\sum \\dots = \\sqrt{n_1! n_2!} \\sum_{N,n} \\dots$ matches $\\sum \\mathcal{M} \\frac{H_N H_n}{\\sqrt{N!n!}}$.\nThus $\\mathcal{M} \\frac{1}{\\sqrt{N! n!}} = \\sqrt{n_1! n_2!} \\frac{1}{N!n!} C(N,n,n_1)$.\n$$\n\\mathcal{M}(N,n;n_1,n_2;\\theta) = \\sqrt{\\frac{n_1!n_2!}{N!n!}} C(N,n,n_1)\n$$\nThis yields the final expression for the TM bracket:\n$$\n\\mathcal{M}(N,n;n_1,n_2;\\theta) = \\delta_{N+n, n_1+n_2} \\sqrt{\\frac{n_1!n_2!}{N!n!}} \\sum_{k=\\max(0, n_1-n)}^{\\min(N, n_1)} (-1)^{n_1-k} \\binom{N}{k}\\binom{n}{n_1-k} (\\cos\\theta)^{n-n_1+2k} (\\sin\\theta)^{N+n_1-2k}\n$$\n\n### Task 2: Generalization to Unequal Masses\nThe angle $\\theta$ is defined by $\\cos\\theta = \\sqrt{m_1/(m_1+m_2)}$ and $\\sin\\theta = \\sqrt{m_2/(m_1+m_2)}$. Using the mass ratio $\\alpha = m_1/m_2$, we can re-express these as:\n$$\n\\cos\\theta = \\sqrt{\\frac{m_1/m_2}{(m_1/m_2)+1}} = \\sqrt{\\frac{\\alpha}{\\alpha+1}}\n$$\n$$\n\\sin\\theta = \\sqrt{\\frac{1}{(m_1/m_2)+1}} = \\sqrt{\\frac{1}{\\alpha+1}}\n$$\nSubstituting these expressions into the formula for $\\mathcal{M}$ provides the bracket as a function of the mass ratio $\\alpha$.\n\n### Tasks 3, 4, 5: Implementation and Verification\nThe derived formula is implemented in a Python function. It first checks a necessary condition, the selection rule $N+n=n_1+n_2$. If this fails, the bracket is $0$. Otherwise, it computes the sum over the index $k$. Factorials and binomial coefficients are computed using `scipy.special.factorial` and `scipy.special.comb` for numerical stability and precision, as they handle large numbers well. Powers of $\\cos\\theta$ and $\\sin\\theta$ are calculated using floating-point arithmetic.\nThe deviation $\\delta(\\alpha)$ is computed by taking the absolute difference between the bracket value at a given $\\alpha$ and its value at the equal-mass case, $\\alpha=1$. For cases where symmetry dictates the bracket is zero at $\\alpha=1$, this simplifies to $|\\mathcal{M}(\\alpha)|$.\nThe orthonormality of the transformation is a consequence of its unitary nature, expressed as $\\sum_{N,n} |\\langle N,n|n_1,n_2 \\rangle|^2 = 1$, where the sum is over all final states for a fixed initial state. For a fixed total quantum number $E=n_1+n_2$, this becomes $\\sum_{N=0}^{E} [\\mathcal{M}(N, E-N; n_1, n_2; \\alpha)]^2 = 1$. The implementation verifies this sum is equal to $1$ within a small numerical tolerance.", "answer": "```python\nimport numpy as np\nfrom scipy.special import comb, factorial\nimport math\n\ndef solve():\n    \"\"\"\n    Solves the Talmi-Moshinsky bracket problem for the given test cases.\n    \"\"\"\n\n    memo_factorial = {}\n    def fact(k):\n        \"\"\"Memoized factorial for integer inputs.\"\"\"\n        if k not in memo_factorial:\n            memo_factorial[k] = factorial(k, exact=True)\n        return memo_factorial[k]\n\n    memo_comb = {}\n    def nCr_exact(n, r):\n        \"\"\"Memoized exact binomial coefficient.\"\"\"\n        if r < 0 or r > n:\n            return 0\n        if (n, r) not in memo_comb:\n            memo_comb[(n, r)] = comb(n, r, exact=True)\n        return memo_comb[(n, r)]\n\n    def compute_m(N, n, n1, n2, alpha):\n        \"\"\"\n        Computes the one-dimensional Talmi-Moshinsky bracket M(N, n; n1, n2; alpha).\n        \n        Args:\n            N (int): Center-of-mass quantum number.\n            n (int): Relative motion quantum number.\n            n1 (int): Particle 1 quantum number.\n            n2 (int): Particle 2 quantum number.\n            alpha (float): Mass ratio m1/m2.\n        \n        Returns:\n            float: The value of the Talmi-Moshinsky bracket.\n        \"\"\"\n        # Task 1: Selection rule\n        if N + n != n1 + n2:\n            return 0.0\n\n        # Task 2: Parameterization with alpha\n        cos_theta = np.sqrt(alpha / (alpha + 1.0))\n        sin_theta = np.sqrt(1.0 / (alpha + 1.0))\n\n        # Task 1: Summation for the bracket formula\n        k_min = max(0, n1 - n)\n        k_max = min(N, n1)\n\n        total_sum = 0.0\n        for k in range(k_min, k_max + 1):\n            # Using integer arithmetic for binomials and signs\n            term_coeff = ((-1)**(n1 - k)) * nCr_exact(N, k) * nCr_exact(n, n1 - k)\n            \n            # Floating point for powers\n            term_powers = (cos_theta**(n - n1 + 2 * k)) * (sin_theta**(N + n1 - 2 * k))\n            \n            total_sum += float(term_coeff) * term_powers\n\n        # Prefactor\n        try:\n            prefactor_int = fact(n1) * fact(n2) / (fact(N) * fact(n))\n        except (ValueError, OverflowError):\n            # Fallback to log-gamma for large numbers if needed, though not for these test cases\n            log_prefactor = (math.lgamma(n1 + 1) + math.lgamma(n2 + 1) - \n                             math.lgamma(N + 1) - math.lgamma(n + 1))\n            prefactor = np.exp(0.5 * log_prefactor)\n        else:\n            prefactor = np.sqrt(float(prefactor_int))\n\n        return prefactor * total_sum\n\n    test_cases = [\n        # alpha, n1, n2, N, n\n        (1.0, 1, 1, 1, 1),\n        (1.19, 1, 1, 1, 1),\n        (10.0, 1, 1, 1, 1),\n        (1.0, 2, 2, 3, 1),\n        (1.19, 2, 2, 3, 1),\n        (2.5, 0, 1, 0, 0),\n    ]\n\n    results = []\n\n    # Process test cases 1-6\n    for i, case in enumerate(test_cases):\n        alpha, n1, n2, N, n = case\n        \n        # Task 3: Compute bracket M\n        m_val = compute_m(N, n, n1, n2, alpha)\n        \n        # Task 4: Compute deviation delta\n        m_val_equal_mass = compute_m(N, n, n1, n2, 1.0)\n        delta = abs(m_val - m_val_equal_mass)\n        \n        # Selection rule check\n        rule_satisfied = (N + n == n1 + n2)\n        \n        results.append([m_val, delta, rule_satisfied])\n\n    # Process test case 7 (Orthonormality)\n    alpha_ortho, n1_ortho, n2_ortho = 1.19, 1, 1\n    total_q = n1_ortho + n2_ortho\n    ortho_sum = 0.0\n    for N_loop in range(total_q + 1):\n        n_loop = total_q - N_loop\n        m_val = compute_m(N_loop, n_loop, n1_ortho, n2_ortho, alpha_ortho)\n        ortho_sum += m_val**2\n    \n    ortho_check = abs(ortho_sum - 1.0) < 1e-12\n    results.append(ortho_check)\n\n    # Final output formatting\n    # The str() function on a list neatly formats it as '[item1, item2, ...]'\n    # and on a boolean as 'True' or 'False'. This matches the implied format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3549238"}, {"introduction": "Our final practice bridges the gap between theoretical formalism and the realities of large-scale computation, where basis spaces must be truncated. This exercise [@problem_id:3549211] investigates a critical issue in nuclear structure calculations: the artificial violation of center-of-mass factorization caused by basis truncation. Using a simplified one-dimensional model, you will quantify how different truncation schemes—the total-quanta $N_{\\max}$ cutoff versus a single-particle $e_{\\max}$ cutoff—introduce spurious center-of-mass excitations, a crucial skill for diagnosing and ensuring the validity of computational results.", "problem": "You are to investigate center-of-mass factorization under different basis truncations by working entirely within a one-dimensional ($1$D) harmonic oscillator model of two identical particles. The $1$D setting is used to make the Talmi-Moshinsky transformation exact and computationally lightweight while preserving the essential logic of center-of-mass factorization versus truncation artifacts that also occur in three dimensions.\n\nDefine single-particle harmonic oscillator number states $\\lvert n_1 \\rangle \\otimes \\lvert n_2 \\rangle$ with non-negative integers $n_1$ and $n_2$, and define the relative and center-of-mass (c.m.) oscillator number states $\\lvert n \\rangle_{\\text{rel}} \\otimes \\lvert N \\rangle_{\\text{cm}}$, also with non-negative integers $n$ and $N$. The Talmi-Moshinsky transformation in this $1$D setting is the unitary change of basis induced by the linear mode rotation of creation operators,\n$$\na_{\\text{r}}^\\dagger = \\frac{a_1^\\dagger - a_2^\\dagger}{\\sqrt{2}}, \\quad\na_{\\text{c}}^\\dagger = \\frac{a_1^\\dagger + a_2^\\dagger}{\\sqrt{2}},\n$$\nwhich maps between the two-particle single-particle basis and the relative/c.m. basis. The overlap (the $1$D Talmi-Moshinsky bracket) between the bases is\n$$\n\\langle n, N \\vert n_1, n_2 \\rangle \\equiv U(n_1,n_2;n,N) =\n2^{-\\frac{n_1+n_2}{2}}\n\\sqrt{\\frac{n!\\,N!}{n_1!\\,n_2!}}\n\\sum_{k=k_{\\min}}^{k_{\\max}}\n\\binom{n_1}{k}\\binom{n_2}{n-k}(-1)^{n-k}\n$$\nsubject to the selection rule $n+N=n_1+n_2$, and with $k_{\\min}=\\max(0,n-n_2)$ and $k_{\\max}=\\min(n,n_1)$. All factorials and binomial coefficients have their standard definitions for non-negative integers, and the transform is orthonormal in the infinite space.\n\nConsider a target intrinsic (relative-coordinate only) state that is exactly factorized with the center-of-mass in its ground oscillator state,\n$$\n\\lvert \\Psi \\rangle = \\left(\\sum_{n=0}^{n_{\\max}} c_n \\,\\lvert n \\rangle_{\\text{rel}}\\right) \\otimes \\lvert 0 \\rangle_{\\text{cm}},\n$$\nwhere $c_n \\in \\mathbb{R}$ and $\\sum_{n=0}^{n_{\\max}} c_n^2 = 1$. In the full, untruncated space, this state has exact center-of-mass factorization with the center-of-mass in the $0s$ subspace ($N=0$). In the single-particle basis, amplitudes are\n$$\nA(n_1,n_2) = \\sum_{n=0}^{n_{\\max}} c_n \\, U(n_1,n_2;n,0),\n$$\nand the infinite-space transform guarantees that the distribution in the center-of-mass coordinate remains exactly $N=0$.\n\nNow impose a basis truncation in the single-particle space and form the truncated state by discarding basis components outside the truncation:\n- Single-particle truncation $e_{\\max}$: retain only components with $n_1 \\leq n_{\\max}^{\\text{sp}}$ and $n_2 \\leq n_{\\max}^{\\text{sp}}$, where $n_{\\max}^{\\text{sp}}$ is the maximum single-particle oscillator quantum number allowed. This is the $1$D analog of a single-particle $e_{\\max}$ truncation.\n- Total-quanta truncation $N_{\\max}$: retain only components with $n_1 + n_2 \\leq N_{\\max}$. This is the $1$D analog of the no-core shell model $N_{\\max}$ truncation.\n\nLet the truncated, normalized two-particle state be\n$$\n\\lvert \\Psi_{\\text{tr}} \\rangle = \\frac{1}{\\sqrt{\\mathcal{N}}} \\sum_{\\text{kept }(n_1,n_2)} A(n_1,n_2) \\, \\lvert n_1,n_2 \\rangle,\n\\quad \\text{with} \\quad\n\\mathcal{N} = \\sum_{\\text{kept }(n_1,n_2)} \\left|A(n_1,n_2)\\right|^2.\n$$\nProject this truncated state back to the relative and center-of-mass basis to obtain amplitudes\n$$\nB(n,N) = \\sum_{\\text{kept }(n_1,n_2)} U(n_1,n_2;n,N)\\,\\frac{A(n_1,n_2)}{\\sqrt{\\mathcal{N}}},\n$$\nand define the probability to be in c.m. oscillator quantum $N$ by\n$$\nP(N) = \\sum_{n=0}^{S_{\\max}} \\left| B(n,N) \\right|^2,\n$$\nwhere $S_{\\max}$ is any integer upper bound on $n+N$ that is at least as large as the maximum $n_1+n_2$ among the retained $(n_1,n_2)$ pairs. Finally, quantify center-of-mass factorization by:\n- The expectation value of c.m. quanta,\n$$\n\\langle N_{\\text{cm}} \\rangle = \\sum_{N=0}^{S_{\\max}} N \\, P(N),\n$$\n- The overlap with the $0s$ c.m. subspace,\n$$\n\\mathcal{O}_{0s} = P(0).\n$$\n\nYour task is to implement a program that constructs the above transforms exactly, applies the specified truncations, and computes $\\langle N_{\\text{cm}} \\rangle$ and $\\mathcal{O}_{0s}$ for each test case. All quantities are dimensionless. Angles are not used. No physical units are required.\n\nImplement the following test suite. In all cases, the input intrinsic state coefficients $\\{c_n\\}$ are specified explicitly and must be renormalized to satisfy $\\sum_n c_n^2 = 1$ before use.\n- Test case $1$ (baseline $N_{\\max}$ factorization): truncation type $N_{\\max}$ with $N_{\\max}=3$; coefficients $[1.0,\\,0.7,\\,0.5,\\,0.2]$ for $n=0,1,2,3$ respectively.\n- Test case $2$ (single-particle $e_{\\max}$ violation): truncation type single-particle with $n_{\\max}^{\\text{sp}}=1$; same coefficients as in test case $1$.\n- Test case $3$ (single-particle large $e_{\\max}$ restores factorization): truncation type single-particle with $n_{\\max}^{\\text{sp}}=3$; same coefficients as in test case $1$.\n- Test case $4$ (small $N_{\\max}$ truncation removes higher intrinsic components but preserves c.m.): truncation type $N_{\\max}$ with $N_{\\max}=1$; same coefficients as in test case $1$.\n- Test case $5$ (edge case with a single intrinsic excitation): truncation type single-particle with $n_{\\max}^{\\text{sp}}=1$; coefficients $[0.0,\\,0.0,\\,1.0]$ for $n=0,1,2$ respectively.\n\nYour program must:\n- Construct $U(n_1,n_2;n,N)$ exactly using the stated formula.\n- Build $A(n_1,n_2)$ from the intrinsic coefficients and $U(n_1,n_2;n,0)$.\n- Apply the specified truncation.\n- Normalize and project back to obtain $B(n,N)$, then compute $\\langle N_{\\text{cm}} \\rangle$ and $\\mathcal{O}_{0s}$.\n\nFinal output format: Your program should produce a single line of output containing a flattened list of real numbers for all test cases, ordered as\n$$\n\\big[\\langle N_{\\text{cm}}\\rangle_1,\\ \\mathcal{O}_{0s,1},\\ \\langle N_{\\text{cm}}\\rangle_2,\\ \\mathcal{O}_{0s,2},\\ \\ldots,\\ \\langle N_{\\text{cm}}\\rangle_5,\\ \\mathcal{O}_{0s,5}\\big].\n$$\nFor example, a three-test-case result would look like $\\big[0.0,1.0,\\,0.375,0.8125,\\,0.0,1.0\\big]$. Your program must not read any input and must not print anything else.", "solution": "**1. The Talmi-Moshinsky Transformation**\n\nThe problem is defined in a one-dimensional, two-particle harmonic oscillator system. The two-particle states can be described in two equivalent bases: the single-particle (s.p.) basis, $\\lvert n_1, n_2 \\rangle = \\lvert n_1 \\rangle \\otimes \\lvert n_2 \\rangle$, and the relative/center-of-mass basis, $\\lvert n, N \\rangle = \\lvert n \\rangle_{\\text{rel}} \\otimes \\lvert N \\rangle_{\\text{cm}}$. Here, $n_1, n_2, n, N$ are non-negative integer quantum numbers.\n\nThe transformation between these bases is given by the Talmi-Moshinsky bracket (TMB), $U(n_1,n_2;n,N) = \\langle n, N \\vert n_1, n_2 \\rangle$. The formula provided is:\n$$\nU(n_1,n_2;n,N) = 2^{-\\frac{n_1+n_2}{2}} \\sqrt{\\frac{n!\\,N!}{n_1!\\,n_2!}} \\sum_{k=k_{\\min}}^{k_{\\max}} \\binom{n_1}{k}\\binom{n_2}{n-k}(-1)^{n-k}\n$$\nThis transformation is non-zero only if the total number of oscillator quanta is conserved, i.e., it is subject to the selection rule $n_1+n_2 = n+N$. The summation limits are $k_{\\min}=\\max(0,n-n_2)$ and $k_{\\max}=\\min(n,n_1)$. A function will be implemented to compute this bracket, utilizing numerical libraries for the exact calculation of factorials and binomial coefficients. Due to repeated calls with identical arguments, this function is memoized for computational efficiency.\n\n**2. State Construction and Initial Transformation**\n\nThe target state $\\lvert \\Psi \\rangle$ is defined as being perfectly factorized, with the center-of-mass in its ground state ($N=0$):\n$$\n\\lvert \\Psi \\rangle = \\left(\\sum_{n=0}^{n_{\\max}} c_n \\,\\lvert n \\rangle_{\\text{rel}}\\right) \\otimes \\lvert 0 \\rangle_{\\text{cm}}\n$$\nThe provided coefficients $\\{c_n\\}$ are first normalized such that $\\sum_{n=0}^{n_{\\max}} c_n^2 = 1$.\n\nTo analyze the effect of truncation in the single-particle basis, we first express $\\lvert \\Psi \\rangle$ in this basis. The amplitudes $A(n_1,n_2) = \\langle n_1, n_2 \\vert \\Psi \\rangle$ are given by:\n$$\nA(n_1,n_2) = \\sum_{n=0}^{n_{\\max}} c_n \\, \\langle n_1, n_2 \\vert n, 0 \\rangle = \\sum_{n=0}^{n_{\\max}} c_n \\, U(n_1,n_2;n,0)\n$$\nDue to the selection rule $n_1+n_2=n+N$, the term $U(n_1,n_2;n,0)$ is non-zero only if $n = n_1+n_2$. This simplifies the sum to a single term. If $n_1+n_2 \\le n_{\\max}$, the amplitude is:\n$$\nA(n_1,n_2) = c_{n_1+n_2} \\, U(n_1,n_2; n_1+n_2, 0)\n$$\nIf $n_1+n_2 > n_{\\max}$, then $A(n_1,n_2) = 0$.\n\n**3. Basis Truncation and Renormalization**\n\nNext, a truncation is applied to the single-particle basis. Two schemes are considered:\n- **Total-quanta truncation ($N_{\\max}$)**: Only basis states $\\lvert n_1, n_2 \\rangle$ with $n_1 + n_2 \\leq N_{\\max}$ are retained.\n- **Single-particle truncation ($e_{\\max}$)**: Only basis states $\\lvert n_1, n_2 \\rangle$ with both $n_1 \\leq n_{\\max}^{\\text{sp}}$ and $n_2 \\leq n_{\\max}^{\\text{sp}}$ are retained.\n\nAfter discarding basis states outside the truncation window, the resulting state is no longer normalized. The truncated state $\\lvert \\Psi_{\\text{tr}} \\rangle$ is constructed by summing over the \"kept\" pairs $(n_1,n_2)$ and renormalizing:\n$$\n\\lvert \\Psi_{\\text{tr}} \\rangle = \\frac{1}{\\sqrt{\\mathcal{N}}} \\sum_{\\text{kept }(n_1,n_2)} A(n_1,n_2) \\, \\lvert n_1,n_2 \\rangle\n$$\nwhere the normalization constant is $\\mathcal{N} = \\sum_{\\text{kept }(n_1,n_2)} |A(n_1,n_2)|^2$.\n\n**4. Projection and Observable Calculation**\n\nTo quantify the effect of the truncation on center-of-mass factorization, the truncated state $\\lvert \\Psi_{\\text{tr}} \\rangle$ is projected back onto the relative/c.m. basis. The new amplitudes $B(n,N) = \\langle n,N \\vert \\Psi_{\\text{tr}} \\rangle$ are:\n$$\nB(n,N) = \\frac{1}{\\sqrt{\\mathcal{N}}} \\sum_{\\text{kept }(n_1,n_2)} A(n_1,n_2) \\, \\langle n,N \\vert n_1, n_2 \\rangle = \\frac{1}{\\sqrt{\\mathcal{N}}} \\sum_{\\text{kept }(n_1,n_2)} U(n_1,n_2;n,N)A(n_1,n_2)\n$$\nThe probability of finding the system with $N$ quanta of center-of-mass excitation is then the sum of squared amplitudes over all possible relative quantum numbers $n$:\n$$\nP(N) = \\sum_{n=0}^{S_{\\max}} \\left| B(n,N) \\right|^2\n$$\nHere, $S_{\\max}$ is chosen to be the maximum possible value of $n_1+n_2$ within the truncated space, ensuring all contributing states are included.\n\nFinally, two key observables are computed to measure the degree of c.m. factorization:\n- The expectation value of the c.m. excitation number: $\\langle N_{\\text{cm}} \\rangle = \\sum_{N=0}^{S_{\\max}} N \\, P(N)$.\n- The overlap with the c.m. ground state ($0s$) subspace: $\\mathcal{O}_{0s} = P(0)$.\n\nFor a perfectly factorized state with no c.m. excitation, we would find $\\langle N_{\\text{cm}} \\rangle = 0$ and $\\mathcal{O}_{0s} = 1$. Deviations from these values indicate spurious c.m. excitation introduced by the basis truncation. The algorithm iterates through each test case, performing these calculations to produce the required results.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import comb, factorial\nfrom functools import lru_cache\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'type': 'N_max', 'limit': 3, 'coeffs': [1.0, 0.7, 0.5, 0.2]},\n        {'type': 'single-particle', 'limit': 1, 'coeffs': [1.0, 0.7, 0.5, 0.2]},\n        {'type': 'single-particle', 'limit': 3, 'coeffs': [1.0, 0.7, 0.5, 0.2]},\n        {'type': 'N_max', 'limit': 1, 'coeffs': [1.0, 0.7, 0.5, 0.2]},\n        {'type': 'single-particle', 'limit': 1, 'coeffs': [0.0, 0.0, 1.0]}\n    ]\n\n    results = []\n    for case in test_cases:\n        N_cm_exp, O_0s = compute_observables(\n            case['type'], case['limit'], case['coeffs']\n        )\n        results.extend([N_cm_exp, O_0s])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\n@lru_cache(maxsize=None)\ndef talmi_moshinsky_bracket(n1, n2, n, N):\n    \"\"\"\n    Computes the 1D Talmi-Moshinsky bracket U(n1, n2; n, N).\n    Memoization is used to cache results for efficiency.\n    \"\"\"\n    if n1 + n2 != n + N:\n        return 0.0\n\n    # quantum numbers are small, direct computation is safe and exact.\n    # Check for impossible arguments for factorials.\n    if any(q < 0 for q in [n1, n2, n, N]):\n        return 0.0\n\n    try:\n        # Pre-factor calculation\n        prefactor = (2.0**(-0.5 * (n1 + n2))) * np.sqrt(\n            factorial(n) * factorial(N) / (factorial(n1) * factorial(n2))\n        )\n    except (ValueError, ZeroDivisionError):\n        # Handles cases like factorial of negative or division by zero from factorial(negative)\n        return 0.0\n\n    # Summation part\n    k_min = max(0, n - n2)\n    k_max = min(n, n1)\n\n    sum_val = 0.0\n    for k in range(k_min, k_max + 1):\n        term = comb(n1, k, exact=False) * comb(n2, n - k, exact=False) * ((-1)**(n - k))\n        sum_val += term\n\n    return prefactor * sum_val\n\ndef compute_observables(trunc_type, trunc_limit, coeffs_raw):\n    \"\"\"\n    Performs the full calculation for a single test case.\n    \"\"\"\n    # 1. Normalize initial coefficients\n    coeffs_raw = np.array(coeffs_raw, dtype=float)\n    norm = np.linalg.norm(coeffs_raw)\n    coeffs = coeffs_raw / norm if norm > 0 else coeffs_raw\n    n_max_coeffs = len(coeffs) - 1\n\n    # 2. Determine max quanta for this case's loops and generate \"kept\" (n1, n2) pairs\n    if trunc_type == 'N_max':\n        S_max = trunc_limit\n    else:  # single-particle\n        S_max = 2 * trunc_limit\n    \n    kept_pairs = []\n    for n1 in range(S_max + 1):\n        for n2 in range(S_max - n1 + 1):\n            is_kept = False\n            if trunc_type == 'N_max':\n                if n1 + n2 <= trunc_limit:\n                    is_kept = True\n            else:  # single-particle\n                if n1 <= trunc_limit and n2 <= trunc_limit:\n                    is_kept = True\n            \n            if is_kept:\n                kept_pairs.append((n1, n2))\n    \n    # 3. Calculate amplitudes A(n1, n2) and normalization factor N\n    A = {}\n    norm_sq = 0.0\n    \n    for n1, n2 in kept_pairs:\n        total_quanta = n1 + n2\n        if total_quanta > n_max_coeffs:\n            A[(n1, n2)] = 0.0\n        else:\n            u_val = talmi_moshinsky_bracket(n1, n2, total_quanta, 0)\n            A[(n1, n2)] = coeffs[total_quanta] * u_val\n        \n        norm_sq += A[(n1, n2)]**2\n\n    if norm_sq < 1e-15:\n        return 0.0, 0.0\n\n    norm_val = np.sqrt(norm_sq)\n\n    # 4. Project back to get B(n,N)\n    B = np.zeros((S_max + 1, S_max + 1), dtype=float)\n    for n_rel in range(S_max + 1):\n        for N_cm in range(S_max - n_rel + 1):\n            b_val = 0.0\n            for n1, n2 in kept_pairs:\n                if (n1, n2) in A:\n                    u_val = talmi_moshinsky_bracket(n1, n2, n_rel, N_cm)\n                    b_val += u_val * A[(n1, n2)]\n            \n            B[n_rel, N_cm] = b_val / norm_val\n\n    # 5. Calculate probabilities P(N)\n    P = np.zeros(S_max + 1, dtype=float)\n    for N_cm in range(S_max + 1):\n        P[N_cm] = np.sum(B[:, N_cm]**2)\n\n    # 6. Compute final observables\n    O_0s = P[0]\n    \n    N_vector = np.arange(S_max + 1)\n    N_cm_exp = np.sum(N_vector * P)\n        \n    return N_cm_exp, O_0s\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3549211"}]}