{"hands_on_practices": [{"introduction": "The cornerstone of any Variational Monte Carlo (VMC) simulation is the local energy, $E_{L}(\\mathbf{R}) = \\Psi_{T}(\\mathbf{R})^{-1}\\hat{H}\\Psi_{T}(\\mathbf{R})$. Before one can implement a program to sample this quantity, it is essential to understand how to derive it analytically for a given trial wavefunction and Hamiltonian. This foundational exercise guides you through the step-by-step derivation for the helium atom, a simple yet non-trivial two-electron system, reinforcing the direct connection between the abstract quantum mechanical operators and the concrete function evaluated at each step of a Monte Carlo simulation [@problem_id:2466739].", "problem": "In the Born–Oppenheimer and non-relativistic approximations, consider a Helium atom with nuclear charge $Z=2$ fixed at the origin. Work in atomic units, where $\\hbar = m_{e} = e = 1$ and $1/(4\\pi\\varepsilon_{0})=1$. The electronic Hamiltonian for the two-electron system is\n$$\n\\hat{H} = -\\frac{1}{2}\\nabla_{1}^{2} - \\frac{1}{2}\\nabla_{2}^{2} - \\frac{Z}{r_{1}} - \\frac{Z}{r_{2}} + \\frac{1}{r_{12}},\n$$\nwhere $r_{i} = |\\mathbf{r}_{i}|$ for $i=1,2$, and $r_{12} = |\\mathbf{r}_{1} - \\mathbf{r}_{2}|$. In Variational Monte Carlo (VMC), the local energy is defined as\n$$\nE_{L}(\\mathbf{R}) = \\frac{\\hat{H}\\Psi_{T}(\\mathbf{R})}{\\Psi_{T}(\\mathbf{R})},\n$$\nwith $\\mathbf{R} = (\\mathbf{r}_{1},\\mathbf{r}_{2})$. For the trial wavefunction\n$$\n\\Psi_{T}(\\mathbf{R}) = \\exp(-\\alpha r_{1})\\,\\exp(-\\alpha r_{2}),\n$$\nwith variational parameter $\\alpha > 0$, derive $E_{L}(\\mathbf{R})$ explicitly as a function of $r_{1}$, $r_{2}$, $r_{12}$, and $\\alpha$ for $Z=2$.\n\nExpress your final answer as a single closed-form analytic expression with no units.", "solution": "The problem statement has been evaluated and is determined to be valid. It is scientifically grounded, well-posed, objective, and contains all necessary information for a rigorous derivation. It represents a standard exercise in the application of the Variational Monte Carlo method in computational quantum chemistry. We proceed with the solution.\n\nThe objective is to derive the local energy $E_{L}(\\mathbf{R})$ for a Helium atom described by the given trial wavefunction $\\Psi_{T}(\\mathbf{R})$. The local energy is defined as:\n$$\nE_{L}(\\mathbf{R}) = \\frac{\\hat{H}\\Psi_{T}(\\mathbf{R})}{\\Psi_{T}(\\mathbf{R})}\n$$\nThe Hamiltonian $\\hat{H}$ is given in atomic units as:\n$$\n\\hat{H} = -\\frac{1}{2}\\nabla_{1}^{2} - \\frac{1}{2}\\nabla_{2}^{2} - \\frac{Z}{r_{1}} - \\frac{Z}{r_{2}} + \\frac{1}{r_{12}}\n$$\nWe can separate the Hamiltonian into a kinetic energy operator $\\hat{T}$ and a potential energy operator $\\hat{V}$:\n$$\n\\hat{T} = -\\frac{1}{2}\\nabla_{1}^{2} - \\frac{1}{2}\\nabla_{2}^{2}\n$$\n$$\n\\hat{V} = -\\frac{Z}{r_{1}} - \\frac{Z}{r_{2}} + \\frac{1}{r_{12}}\n$$\nThus, the local energy can be written as the sum of kinetic and potential contributions:\n$$\nE_{L}(\\mathbf{R}) = \\frac{\\hat{T}\\Psi_{T}(\\mathbf{R})}{\\Psi_{T}(\\mathbf{R})} + \\frac{\\hat{V}\\Psi_{T}(\\mathbf{R})}{\\Psi_{T}(\\mathbf{R})}\n$$\nThe potential energy operator $\\hat{V}$ is a multiplicative operator. Its action on $\\Psi_{T}(\\mathbf{R})$ is simply multiplication by the potential energy function $V(\\mathbf{R})$. Therefore, the potential energy contribution to the local energy is:\n$$\n\\frac{\\hat{V}\\Psi_{T}(\\mathbf{R})}{\\Psi_{T}(\\mathbf{R})} = V(\\mathbf{R}) = -\\frac{Z}{r_{1}} - \\frac{Z}{r_{2}} + \\frac{1}{r_{12}}\n$$\nNext, we evaluate the kinetic energy contribution. The trial wavefunction is given as:\n$$\n\\Psi_{T}(\\mathbf{R}) = \\exp(-\\alpha r_{1})\\,\\exp(-\\alpha r_{2})\n$$\nwhere $r_1 = |\\mathbf{r}_1|$ and $r_2 = |\\mathbf{r}_2|$. This wavefunction is a product of two functions, one depending only on the coordinates of electron $1$, $\\psi(\\mathbf{r}_{1}) = \\exp(-\\alpha r_{1})$, and the other on the coordinates of electron $2$, $\\psi(\\mathbf{r}_{2}) = \\exp(-\\alpha r_{2})$. So, $\\Psi_{T}(\\mathbf{R}) = \\psi(\\mathbf{r}_{1})\\psi(\\mathbf{r}_{2})$.\n\nThe action of the kinetic operator $\\hat{T}$ on $\\Psi_{T}$ is:\n$$\n\\hat{T}\\Psi_{T} = \\left(-\\frac{1}{2}\\nabla_{1}^{2} - \\frac{1}{2}\\nabla_{2}^{2}\\right) \\psi(\\mathbf{r}_{1})\\psi(\\mathbf{r}_{2})\n$$\nDue to the separability of the wavefunction and the operators, this becomes:\n$$\n\\hat{T}\\Psi_{T} = \\psi(\\mathbf{r}_{2})\\left(-\\frac{1}{2}\\nabla_{1}^{2}\\psi(\\mathbf{r}_{1})\\right) + \\psi(\\mathbf{r}_{1})\\left(-\\frac{1}{2}\\nabla_{2}^{2}\\psi(\\mathbf{r}_{2})\\right)\n$$\nThe kinetic contribution to the local energy is then:\n$$\n\\frac{\\hat{T}\\Psi_{T}}{\\Psi_{T}} = \\frac{\\psi(\\mathbf{r}_{2})\\left(-\\frac{1}{2}\\nabla_{1}^{2}\\psi(\\mathbf{r}_{1})\\right) + \\psi(\\mathbf{r}_{1})\\left(-\\frac{1}{2}\\nabla_{2}^{2}\\psi(\\mathbf{r}_{2})\\right)}{\\psi(\\mathbf{r}_{1})\\psi(\\mathbf{r}_{2})} = -\\frac{1}{2}\\frac{\\nabla_{1}^{2}\\psi(\\mathbf{r}_{1})}{\\psi(\\mathbf{r}_{1})} - \\frac{1}{2}\\frac{\\nabla_{2}^{2}\\psi(\\mathbf{r}_{2})}{\\psi(\\mathbf{r}_{2})}\n$$\nWe need to compute $\\nabla^{2}\\psi(\\mathbf{r})$ for $\\psi(\\mathbf{r}) = \\exp(-\\alpha r)$. Since $\\psi$ depends only on the radial coordinate $r$, we use the radial part of the Laplacian in spherical coordinates:\n$$\n\\nabla^{2}f(r) = \\frac{1}{r^{2}}\\frac{\\partial}{\\partial r}\\left(r^{2}\\frac{\\partial f}{\\partial r}\\right) = \\frac{\\partial^{2}f}{\\partial r^{2}} + \\frac{2}{r}\\frac{\\partial f}{\\partial r}\n$$\nFor $f(r) = \\exp(-\\alpha r)$:\nThe first derivative is $\\frac{\\partial f}{\\partial r} = -\\alpha\\exp(-\\alpha r)$.\nThe second derivative is $\\frac{\\partial^{2}f}{\\partial r^{2}} = \\alpha^{2}\\exp(-\\alpha r)$.\nSubstituting these into the Laplacian expression:\n$$\n\\nabla^{2}\\exp(-\\alpha r) = \\alpha^{2}\\exp(-\\alpha r) + \\frac{2}{r}(-\\alpha\\exp(-\\alpha r)) = \\left(\\alpha^{2} - \\frac{2\\alpha}{r}\\right)\\exp(-\\alpha r)\n$$\nTherefore, for a single electron:\n$$\n\\frac{\\nabla^{2}\\psi(\\mathbf{r})}{\\psi(\\mathbf{r})} = \\frac{(\\alpha^{2} - \\frac{2\\alpha}{r})\\exp(-\\alpha r)}{\\exp(-\\alpha r)} = \\alpha^{2} - \\frac{2\\alpha}{r}\n$$\nThe kinetic energy contribution for one electron to the local energy is:\n$$\n-\\frac{1}{2}\\frac{\\nabla^{2}\\psi(\\mathbf{r})}{\\psi(\\mathbf{r})} = -\\frac{1}{2}\\left(\\alpha^{2} - \\frac{2\\alpha}{r}\\right) = -\\frac{\\alpha^{2}}{2} + \\frac{\\alpha}{r}\n$$\nThe total kinetic contribution to $E_{L}$ is the sum for both electrons:\n$$\n\\frac{\\hat{T}\\Psi_{T}}{\\Psi_{T}} = \\left(-\\frac{\\alpha^{2}}{2} + \\frac{\\alpha}{r_{1}}\\right) + \\left(-\\frac{\\alpha^{2}}{2} + \\frac{\\alpha}{r_{2}}\\right) = -\\alpha^{2} + \\frac{\\alpha}{r_{1}} + \\frac{\\alpha}{r_{2}}\n$$\nFinally, we combine the kinetic and potential contributions to obtain the full local energy $E_{L}(\\mathbf{R})$:\n$$\nE_{L}(\\mathbf{R}) = \\left(-\\alpha^{2} + \\frac{\\alpha}{r_{1}} + \\frac{\\alpha}{r_{2}}\\right) + \\left(-\\frac{Z}{r_{1}} - \\frac{Z}{r_{2}} + \\frac{1}{r_{12}}\\right)\n$$\nGrouping terms with $r_{1}$ and $r_{2}$:\n$$\nE_{L}(\\mathbf{R}) = -\\alpha^{2} + \\frac{\\alpha - Z}{r_{1}} + \\frac{\\alpha - Z}{r_{2}} + \\frac{1}{r_{12}}\n$$\nThe problem specifies the nuclear charge for Helium, $Z=2$. Substituting this value yields the final expression:\n$$\nE_{L}(\\mathbf{R}) = -\\alpha^{2} + \\frac{\\alpha - 2}{r_{1}} + \\frac{\\alpha - 2}{r_{2}} + \\frac{1}{r_{12}}\n$$\nThis can be written as:\n$$\nE_{L}(\\mathbf{R}) = -\\alpha^{2} - \\frac{2 - \\alpha}{r_{1}} - \\frac{2 - \\alpha}{r_{2}} + \\frac{1}{r_{12}}\n$$\nThis is the explicit expression for the local energy as a function of $r_{1}$, $r_{2}$, $r_{12}$, and $\\alpha$.", "answer": "$$\n\\boxed{-\\alpha^{2} - \\frac{2-\\alpha}{r_{1}} - \\frac{2-\\alpha}{r_{2}} + \\frac{1}{r_{12}}}\n$$", "id": "2466739"}, {"introduction": "Moving from simple atomic systems to the nuclear many-body problem introduces significant complexity into the Hamiltonian. Nuclear forces are not purely central potentials; they include crucial non-central components like spin-orbit and tensor interactions. This practice demonstrates how to calculate the contribution of a spin-orbit potential, $V_{LS}(r_{ij})\\,\\mathbf{L}\\cdot\\mathbf{S}$, to the local energy for a specific two-nucleon configuration. By applying angular momentum algebra, you will see how the expectation value of such operators is evaluated within a VMC framework, a critical skill for working with realistic nuclear interactions [@problem_id:3610699].", "problem": "Consider a two-nucleon subsystem embedded in a shell-model based Slater determinant wave function $\\Phi_{\\mathrm{SD}}$ used as the trial state in Variational Monte Carlo (VMC). The trial many-body state is $\\Psi_{T}(\\mathbf{R},\\Sigma)$, constructed from $\\Phi_{\\mathrm{SD}}$, and the instantaneous local energy at a given Monte Carlo walker configuration $(\\mathbf{R},\\Sigma)$ is defined by the ratio $E_{L}(\\mathbf{R},\\Sigma) = \\frac{H\\,\\Psi_{T}(\\mathbf{R},\\Sigma)}{\\Psi_{T}(\\mathbf{R},\\Sigma)}$, where $H$ is the many-body Hamiltonian. Assume the only nonvanishing contribution you will compute here comes from a two-body spin-orbit interaction between nucleons $1$ and $2$ of the form\n$$\nH_{LS} = V_{LS}(r_{12})\\,\\mathbf{L}_{12}\\!\\cdot\\!\\mathbf{S}_{12},\n$$\nwith $\\mathbf{L}_{12}$ the relative orbital angular momentum operator and $\\mathbf{S}_{12} = \\mathbf{s}_{1} + \\mathbf{s}_{2}$ the total spin operator of the pair. Work in natural units with $\\hbar = 1$ so that $\\mathbf{L}_{12}\\!\\cdot\\!\\mathbf{S}_{12}$ is dimensionless and $V_{LS}(r_{12})$ has units of energy.\n\nSuppose a particular Monte Carlo walker configuration samples the two-body relative state of nucleons $1$ and $2$ in the $^{3}P_{2}$ channel, i.e., with orbital angular momentum $L = 1$, total spin $S = 1$, and total angular momentum $J = 2$. The interparticle separation at this configuration is $r_{12} = 1.4\\,\\text{fm}$. The radial strength in the spin-orbit potential is specified by\n$$\nV_{LS}(r) = \\alpha\\,r^{-3}\\,\\exp(-\\gamma r),\n$$\nwith $\\alpha = 25\\,\\text{MeV}\\cdot\\text{fm}^{3}$ and $\\gamma = 0.8\\,\\text{fm}^{-1}$.\n\nStarting from the definition of the local energy and basic angular momentum addition rules, compute the contribution of the spin-orbit potential $V_{LS}(r_{12})\\,\\mathbf{L}_{12}\\!\\cdot\\!\\mathbf{S}_{12}$ to the local energy for this configuration. Express the final energy in $\\text{MeV}$ and round your answer to four significant figures.", "solution": "The problem asks for the contribution of the two-body spin-orbit interaction, $H_{LS}$, to the local energy, $E_L$, for a specific Monte Carlo configuration. The local energy is defined as $E_{L}(\\mathbf{R},\\Sigma) = \\frac{H\\,\\Psi_{T}(\\mathbf{R},\\Sigma)}{\\Psi_{T}(\\mathbf{R},\\Sigma)}$. The contribution from a specific term in the Hamiltonian, such as $H_{LS}$, is therefore given by:\n$$\n(E_L)_{LS} = \\frac{H_{LS}\\,\\Psi_{T}(\\mathbf{R},\\Sigma)}{\\Psi_{T}(\\mathbf{R},\\Sigma)}\n$$\nThe spin-orbit Hamiltonian for the nucleon pair $(1,2)$ is given as $H_{LS} = V_{LS}(r_{12})\\,\\mathbf{L}_{12}\\!\\cdot\\!\\mathbf{S}_{12}$.\n\nThe problem states that at the given configuration, the two-nucleon subsystem is in a $^{3}P_{2}$ state. This notation specifies the quantum numbers for the relative orbital angular momentum ($L$), total spin ($S$), and total angular momentum ($J$) of the pair. A state with well-defined $L$, $S$, and $J$ is an eigenstate of the operators $\\mathbf{L}_{12}^2$, $\\mathbf{S}_{12}^2$, and $\\mathbf{J}^2$, where $\\mathbf{J} = \\mathbf{L}_{12} + \\mathbf{S}_{12}$. Consequently, it is also an eigenstate of the operator $\\mathbf{L}_{12}\\!\\cdot\\!\\mathbf{S}_{12}$.\n\nWe can express the operator $\\mathbf{L}_{12}\\!\\cdot\\!\\mathbf{S}_{12}$ in terms of the squared angular momentum operators. Starting from the definition of total angular momentum, $\\mathbf{J} = \\mathbf{L}_{12} + \\mathbf{S}_{12}$, we square it:\n$$\n\\mathbf{J}^2 = (\\mathbf{L}_{12} + \\mathbf{S}_{12}) \\cdot (\\mathbf{L}_{12} + \\mathbf{S}_{12}) = \\mathbf{L}_{12}^2 + \\mathbf{S}_{12}^2 + 2\\,\\mathbf{L}_{12}\\!\\cdot\\!\\mathbf{S}_{12}\n$$\nSince the orbital and spin operators act on different spaces, they commute. Rearranging this equation gives:\n$$\n\\mathbf{L}_{12}\\!\\cdot\\!\\mathbf{S}_{12} = \\frac{1}{2} \\left( \\mathbf{J}^2 - \\mathbf{L}_{12}^2 - \\mathbf{S}_{12}^2 \\right)\n$$\nWhen this operator acts on an eigenstate $|L, S, J, M_J\\rangle$, the result is the state multiplied by an eigenvalue, $\\lambda_{LS}$. With units where $\\hbar=1$, the eigenvalues of $\\mathbf{J}^2$, $\\mathbf{L}_{12}^2$, and $\\mathbf{S}_{12}^2$ are $J(J+1)$, $L(L+1)$, and $S(S+1)$, respectively. The eigenvalue of $\\mathbf{L}_{12}\\!\\cdot\\!\\mathbf{S}_{12}$ is therefore:\n$$\n\\lambda_{LS} = \\frac{1}{2} \\left[ J(J+1) - L(L+1) - S(S+1) \\right]\n$$\nNext, we determine the quantum numbers $L$, $S$, and $J$ from the spectroscopic notation $^{2S+1}L_J$, which is given as $^{3}P_{2}$.\n- The superscript $2S+1 = 3$, which implies $2S=2$, so the total spin is $S=1$.\n- The letter $P$ corresponds to the orbital angular momentum. By convention ($S, P, D, F, \\ldots$ for $L=0, 1, 2, 3, \\ldots$), $P$ signifies $L=1$.\n- The subscript is the total angular momentum, so $J=2$.\n\nWe substitute these quantum numbers ($L=1$, $S=1$, $J=2$) into the expression for $\\lambda_{LS}$:\n$$\n\\lambda_{LS} = \\frac{1}{2} \\left[ 2(2+1) - 1(1+1) - 1(1+1) \\right]\n$$\n$$\n\\lambda_{LS} = \\frac{1}{2} \\left[ 2(3) - 1(2) - 1(2) \\right] = \\frac{1}{2} [6 - 2 - 2] = \\frac{1}{2} [2] = 1\n$$\nSince the wave function at this configuration is an eigenstate of $\\mathbf{L}_{12}\\!\\cdot\\!\\mathbf{S}_{12}$ with eigenvalue $\\lambda_{LS}=1$, the local energy calculation simplifies:\n$$\n(E_L)_{LS} = \\frac{V_{LS}(r_{12})\\,(\\mathbf{L}_{12}\\!\\cdot\\!\\mathbf{S}_{12})\\,\\Psi_{T}}{\\Psi_{T}} = \\frac{V_{LS}(r_{12})\\,(\\lambda_{LS})\\,\\Psi_{T}}{\\Psi_{T}} = V_{LS}(r_{12}) \\times \\lambda_{LS}\n$$\nWith $\\lambda_{LS}=1$, the contribution to the local energy is simply the value of the potential radial function at the given separation, $(E_L)_{LS} = V_{LS}(r_{12})$.\n\nThe potential is given by $V_{LS}(r) = \\alpha\\,r^{-3}\\,\\exp(-\\gamma r)$. We are given the following parameters:\n- Interparticle separation: $r_{12} = 1.4\\,\\text{fm}$\n- Strength parameter: $\\alpha = 25\\,\\text{MeV}\\cdot\\text{fm}^{3}$\n- Range parameter: $\\gamma = 0.8\\,\\text{fm}^{-1}$\n\nWe can now substitute these values into the potential function:\n$$\n(E_L)_{LS} = V_{LS}(1.4\\,\\text{fm}) = (25\\,\\text{MeV}\\cdot\\text{fm}^{3}) \\times (1.4\\,\\text{fm})^{-3} \\times \\exp\\left(-(0.8\\,\\text{fm}^{-1}) \\times (1.4\\,\\text{fm})\\right)\n$$\nThe units cancel out correctly, leaving the result in $\\text{MeV}$.\n$$\n(E_L)_{LS} = \\frac{25}{(1.4)^3} \\exp(-0.8 \\times 1.4) \\,\\text{MeV}\n$$\n$$\n(E_L)_{LS} = \\frac{25}{2.744} \\exp(-1.12) \\,\\text{MeV}\n$$\n$$\n(E_L)_{LS} \\approx (9.110787...) \\times (0.326279...) \\,\\text{MeV}\n$$\n$$\n(E_L)_{LS} \\approx 2.9733435... \\,\\text{MeV}\n$$\nThe problem requires the answer to be rounded to four significant figures.\n$$\n(E_L)_{LS} \\approx 2.973 \\,\\text{MeV}\n$$\nThis is the contribution of the spin-orbit potential to the local energy for the given Monte Carlo configuration.", "answer": "$$\n\\boxed{2.973}\n$$", "id": "3610699"}, {"introduction": "An effective VMC simulation requires not only an accurate calculation of the local energy but also an efficient algorithm for sampling the configuration space. Modern nuclear potentials, often derived from Chiral Effective Field Theory, can feature strong short-range repulsion or singularities that cripple simple Metropolis sampling algorithms. This advanced, code-based practice tackles this frontier problem by exploring the Metropolis-Adjusted Langevin Algorithm (MALA), which uses gradient information to propose intelligent moves. You will investigate how to regularize the algorithm's drift term to handle singular interactions, dramatically improving sampling stability and efficiency without compromising the correctness of the simulation [@problem_id:3610701].", "problem": "Consider a three-dimensional variational Monte Carlo sampler targeting the square modulus of a two-body trial wave function, which models short-range correlations induced by nuclear forces. Let the position be a vector $\\mathbf{x} \\in \\mathbb{R}^3$ with $r=\\|\\mathbf{x}\\|$. The target probability density is $\\pi(\\mathbf{x})\\propto|\\Psi(r)|^2$, where one of the following radial families is used for the trial wave function:\n- A local-contact-like family (singular at the origin): $\\Psi_{\\mathrm{L}}(r) = \\exp\\!\\left(-\\dfrac{c}{r}\\right)$, which yields $\\ln \\pi_{\\mathrm{L}}(\\mathbf{x}) = -\\dfrac{2c}{r}$.\n- A nonlocal-smeared family (finite at the origin): $\\Psi_{\\mathrm{NL}}(r) = \\exp\\!\\left(-\\dfrac{c}{\\sqrt{r^2+\\lambda^2}}\\right)$, which yields $\\ln \\pi_{\\mathrm{NL}}(\\mathbf{x}) = -\\dfrac{2c}{\\sqrt{r^2+\\lambda^2}}$.\n\nYou will implement a Metropolis-Adjusted Langevin Algorithm (MALA) in $\\mathbb{R}^3$ with proposal\n$$\n\\mathbf{y} = \\mathbf{x}+\\frac{\\tau}{2}\\,\\mathbf{b}(\\mathbf{x})+\\sqrt{\\tau}\\,\\boldsymbol{\\xi},\\quad \\boldsymbol{\\xi} \\sim \\mathcal{N}(\\mathbf{0},\\mathbf{I}_3),\n$$\nwhere $\\tau>0$ is the time step and $\\mathbf{b}(\\mathbf{x})$ is the drift vector. The generic acceptance probability is\n$$\n\\alpha(\\mathbf{x}\\to\\mathbf{y}) = \\min\\left(1,\\exp\\big[\\ln\\pi(\\mathbf{y})-\\ln\\pi(\\mathbf{x})+\\ln q(\\mathbf{y}\\to\\mathbf{x})-\\ln q(\\mathbf{x}\\to\\mathbf{y})\\big]\\right),\n$$\nwhere the Gaussian proposal density has mean $\\mathbf{m}(\\mathbf{x}) = \\mathbf{x}+\\frac{\\tau}{2}\\mathbf{b}(\\mathbf{x})$ and covariance $\\tau\\mathbf{I}_3$, and\n$$\n\\ln q(\\mathbf{x}\\to\\mathbf{y}) = -\\frac{\\|\\mathbf{y}-\\mathbf{m}(\\mathbf{x})\\|^2}{2\\tau}+\\text{const}.\n$$\nConstants cancel in the Metropolis-Hastings ratio. For the unmodified MALA associated to a given target $\\pi(\\mathbf{x})$, the drift is chosen as the gradient of the log-target,\n$$\n\\mathbf{b}(\\mathbf{x}) = \\nabla_{\\mathbf{x}}\\ln\\pi(\\mathbf{x}).\n$$\nFor the local-contact-like family, this gives a singular drift at the origin:\n$$\n\\mathbf{b}_{\\mathrm{L}}(\\mathbf{x}) = \\frac{2c}{r^3}\\,\\mathbf{x}.\n$$\nFor the nonlocal-smeared family, the drift is finite:\n$$\n\\mathbf{b}_{\\mathrm{NL}}(\\mathbf{x}) = \\frac{2c}{(r^2+\\lambda^2)^{3/2}}\\,\\mathbf{x}.\n$$\nTo mitigate the singular behavior of the local-contact-like drift near $r\\to 0$, use a regularized drift that leaves the target $\\pi_{\\mathrm{L}}$ unchanged but modifies only the proposal:\n$$\n\\mathbf{b}_{\\mathrm{reg}}(\\mathbf{x};\\varepsilon) = \\frac{2c}{(r^2+\\varepsilon^2)^{3/2}}\\,\\mathbf{x}.\n$$\nThis choice can be motivated by replacing $r$ by $\\sqrt{r^2+\\varepsilon^2}$ in the denominator of the unregularized drift, which bounds the drift magnitude as $r\\to 0$. The acceptance step remains correct because the proposal density is computed consistently with the chosen drift, while the target in the Metropolis-Hastings ratio is still $\\pi_{\\mathrm{L}}$.\n\nStarting from the time-independent Schrödinger equation and the variational principle, one models short-distance correlations by the above forms of $\\Psi(r)$, where $c>0$ encodes the short-range correlation strength and $\\lambda>0$ corresponds to a nonlocal regulator length. In the Monte Carlo sampling of $\\pi(\\mathbf{x})\\propto|\\Psi(r)|^2$, the drift arises from the Fokker-Planck form of importance sampling and equals the gradient of $\\ln \\pi$ for the canonical MALA. The singular nature of local-contact-like interactions induces large drifts for small $r$, which can deteriorate acceptance. The nonlocal regulator and the proposed regularization mitigate this issue.\n\nYour task is to implement the three variants below and empirically measure their Metropolis acceptance rate as a function of the time step:\n- Variant A (local, unregularized): target $\\pi_{\\mathrm{L}}$ with drift $\\mathbf{b}_{\\mathrm{L}}$.\n- Variant B (local, regularized): target $\\pi_{\\mathrm{L}}$ with drift $\\mathbf{b}_{\\mathrm{reg}}(\\cdot;\\varepsilon)$.\n- Variant C (nonlocal): target $\\pi_{\\mathrm{NL}}$ with drift $\\mathbf{b}_{\\mathrm{NL}}$.\n\nImplementation and numerical requirements:\n- Work in three dimensions, with all quantities dimensionless.\n- Use the initial state $\\mathbf{x}_0=(r_0,0,0)$.\n- Use the acceptance rule as defined above, computing all probabilities in logarithmic form to avoid underflow or overflow.\n- Use a fixed random seed for reproducibility in each test case.\n\nTest suite:\nUse $c=0.5$ and the following four test cases, each run for $N=20000$ Metropolis proposals, with the specified parameters and random seed. In all cases, set $r_0=0.02$.\n1. Variant A: $\\tau=0.2$, seed $=7$.\n2. Variant B: $\\tau=0.2$, $\\varepsilon=0.05$, seed $=7$.\n3. Variant C: $\\tau=0.2$, $\\lambda=0.05$, seed $=7$.\n4. Variant B (edge case with large time step): $\\tau=1.0$, $\\varepsilon=0.05$, seed $=7$.\n\nFor each case, compute the acceptance rate defined as the number of accepted proposals divided by $N$.\n\nFinal output format:\nYour program should produce a single line of output containing the acceptance rates for the four test cases as a comma-separated list of decimal numbers rounded to four decimal places, enclosed in square brackets. For example: \"[0.8123,0.9340,0.9512,0.4721]\".", "solution": "The problem statement has been critically validated and found to be scientifically sound, well-posed, and complete. All conditions, parameters, and definitions required for a unique and verifiable solution are provided. The problem is a standard application of the Metropolis-Adjusted Langevin Algorithm (MALA) within the domain of computational nuclear physics, focused on comparing different importance sampling strategies for singular and regularized potentials.\n\nThe task is to implement a MALA sampler in three dimensions ($\\mathbb{R}^3$) for a target probability density $\\pi(\\mathbf{x}) \\propto |\\Psi(r)|^2$, where $r = \\|\\mathbf{x}\\|$. We will compare three variants of the algorithm based on different choices for the trial wave function $\\Psi(r)$ and the associated drift term $\\mathbf{b}(\\mathbf{x})$. The performance metric is the Metropolis acceptance rate.\n\nThe MALA is a Markov Chain Monte Carlo (MCMC) method that uses gradient information of the target distribution to propose moves more intelligently than a simple random walk. The proposal for a new state $\\mathbf{y}$ from a current state $\\mathbf{x}$ is given by the discretization of a Langevin stochastic differential equation:\n$$\n\\mathbf{y} = \\mathbf{x} + \\frac{\\tau}{2}\\mathbf{b}(\\mathbf{x}) + \\sqrt{\\tau}\\boldsymbol{\\xi}\n$$\nwhere $\\tau > 0$ is the time step, $\\mathbf{b}(\\mathbf{x})$ is the drift vector, and $\\boldsymbol{\\xi}$ is a random vector drawn from a standard multivariate normal distribution, $\\boldsymbol{\\xi} \\sim \\mathcal{N}(\\mathbf{0}, \\mathbf{I}_3)$.\n\nThe proposal $\\mathbf{y}$ is accepted or rejected based on the Metropolis-Hastings criterion. The acceptance probability $\\alpha(\\mathbf{x} \\to \\mathbf{y})$ is:\n$$\n\\alpha(\\mathbf{x}\\to\\mathbf{y}) = \\min\\left(1, \\frac{\\pi(\\mathbf{y})q(\\mathbf{y}\\to\\mathbf{x})}{\\pi(\\mathbf{x})q(\\mathbf{x}\\to\\mathbf{y})}\\right)\n$$\nwhere $q(\\mathbf{x}\\to\\mathbf{y})$ is the proposal probability density of moving from $\\mathbf{x}$ to $\\mathbf{y}$. Given the proposal mechanism, this density is a Gaussian with mean $\\mathbf{m}(\\mathbf{x}) = \\mathbf{x} + \\frac{\\tau}{2}\\mathbf{b}(\\mathbf{x})$ and covariance $\\tau\\mathbf{I}_3$. Its logarithm is:\n$$\n\\ln q(\\mathbf{x}\\to\\mathbf{y}) = -\\frac{\\|\\mathbf{y} - \\mathbf{m}(\\mathbf{x})\\|^2}{2\\tau} - \\frac{3}{2}\\ln(2\\pi\\tau)\n$$\nTo avoid numerical underflow and improve stability, we work with the logarithm of the acceptance ratio. The log-acceptance probability exponent is:\n$$\n\\ln\\left(\\frac{\\pi(\\mathbf{y})q(\\mathbf{y}\\to\\mathbf{x})}{\\pi(\\mathbf{x})q(\\mathbf{x}\\to\\mathbf{y})}\\right) = \\ln\\pi(\\mathbf{y}) - \\ln\\pi(\\mathbf{x}) + \\ln q(\\mathbf{y}\\to\\mathbf{x}) - \\ln q(\\mathbf{x}\\to\\mathbf{y})\n$$\nThe ratio of proposal densities simplifies, as the constant terms cancel:\n$$\n\\ln q(\\mathbf{y}\\to\\mathbf{x}) - \\ln q(\\mathbf{x}\\to\\mathbf{y}) = \\frac{1}{2\\tau} \\left( \\|\\mathbf{y} - \\mathbf{m}(\\mathbf{x})\\|^2 - \\|\\mathbf{x} - \\mathbf{m}(\\mathbf{y})\\|^2 \\right)\n$$\nwhere $\\mathbf{m}(\\mathbf{y}) = \\mathbf{y} + \\frac{\\tau}{2}\\mathbf{b}(\\mathbf{y})$. A move is accepted if $\\ln u < \\min(0, \\text{log-acceptance exponent})$, where $u \\sim \\mathcal{U}(0,1)$.\n\nThe problem specifies three distinct variants, defined by their log-target density $\\ln\\pi(\\mathbf{x})$ and drift vector $\\mathbf{b}(\\mathbf{x})$.\n\n**Variant A (local, unregularized):**\nThis variant uses the local-contact-like wave function, leading to a target density singular at the origin.\n- Log-target: $\\ln\\pi_{\\mathrm{L}}(\\mathbf{x}) = -\\dfrac{2c}{r}$, where $r = \\|\\mathbf{x}\\|$.\n- Drift (canonical choice): $\\mathbf{b}_{\\mathrm{L}}(\\mathbf{x}) = \\nabla_{\\mathbf{x}}\\ln\\pi_{\\mathrm{L}}(\\mathbf{x}) = \\dfrac{2c}{r^3}\\mathbf{x}$. This drift is also singular at $r=0$.\n\n**Variant B (local, regularized):**\nThis variant uses the same singular target density as Variant A but employs a regularized drift vector to improve sampling stability near the origin. This represents a non-canonical MALA where the drift is not the gradient of the log-target.\n- Log-target: $\\ln\\pi_{\\mathrm{L}}(\\mathbf{x}) = -\\dfrac{2c}{r}$.\n- Drift (regularized proposal): $\\mathbf{b}_{\\mathrm{reg}}(\\mathbf{x};\\varepsilon) = \\dfrac{2c}{(r^2+\\varepsilon^2)^{3/2}}\\mathbf{x}$. The acceptance probability calculation correctly uses $\\mathbf{b}_{\\mathrm{reg}}$ for the proposal term $q$, but $\\pi_{\\mathrm{L}}$ for the target term.\n\n**Variant C (nonlocal):**\nThis variant uses a nonlocal-smeared wave function, which is finite at the origin, thus regularizing both the target density and the drift.\n- Log-target: $\\ln\\pi_{\\mathrm{NL}}(\\mathbf{x}) = -\\dfrac{2c}{\\sqrt{r^2+\\lambda^2}}$.\n- Drift (canonical choice): $\\mathbf{b}_{\\mathrm{NL}}(\\mathbf{x}) = \\nabla_{\\mathbf{x}}\\ln\\pi_{\\mathrm{NL}}(\\mathbf{x}) = \\dfrac{2c}{(r^2+\\lambda^2)^{3/2}}\\mathbf{x}$.\n\nFor the numerical implementation, we initialize the state at $\\mathbf{x}_0=(r_0, 0, 0)$ with $r_0=0.02$. We then run $N=20000$ iterations for each test case. In each iteration, we perform the proposal and acceptance steps described above, using the functions specific to each variant. The acceptance rate is the total number of accepted proposals divided by $N$.\n\nThe specific parameters for the four test cases are:\n1.  **Case 1 (Variant A):** $c=0.5, \\tau=0.2$, seed $=7$.\n2.  **Case 2 (Variant B):** $c=0.5, \\tau=0.2, \\varepsilon=0.05$, seed $=7$.\n3.  **Case 3 (Variant C):** $c=0.5, \\tau=0.2, \\lambda=0.05$, seed $=7$.\n4.  **Case 4 (Variant B):** $c=0.5, \\tau=1.0, \\varepsilon=0.05$, seed $=7$.\n\nThe implementation will use a fixed random seed for each simulation to ensure reproducibility. To handle the singularity at $r=0$ for $\\ln\\pi_{\\mathrm{L}}$, we assign $\\ln\\pi_{\\mathrm{L}}(r=0) = -\\infty$, ensuring any proposal to the origin is rejected. For the singular drift $\\mathbf{b}_{\\mathrm{L}}$, a check is implemented to prevent division by zero, returning a zero drift vector if $r$ is numerically indistinguishable from zero.", "answer": "```python\nimport numpy as np\n\ndef log_pi_L(r, c):\n    \"\"\"Computes the log-target for the local-contact-like family.\"\"\"\n    if r < 1e-15:\n        return -np.inf\n    return -2.0 * c / r\n\ndef log_pi_NL(r, c, lam):\n    \"\"\"Computes the log-target for the nonlocal-smeared family.\"\"\"\n    return -2.0 * c / np.sqrt(r**2 + lam**2)\n\ndef drift_L(x, r, c):\n    \"\"\"Computes the unregularized drift for the local target.\"\"\"\n    if r < 1e-15:\n        return np.zeros_like(x)\n    return (2.0 * c / r**3) * x\n\ndef drift_reg(x, r, c, eps):\n    \"\"\"Computes the regularized drift.\"\"\"\n    r_sq = r**2\n    return (2.0 * c / (r_sq + eps**2)**1.5) * x\n\ndef drift_NL(x, r, c, lam):\n    \"\"\"Computes the drift for the nonlocal target.\"\"\"\n    r_sq = r**2\n    return (2.0 * c / (r_sq + lam**2)**1.5) * x\n\ndef run_mala_simulation(N, x0, tau, seed, log_pi_func, drift_func):\n    \"\"\"\n    Runs a MALA simulation for a given number of steps and returns the acceptance rate.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    x = np.copy(x0)\n    dim = len(x)\n    accepted_count = 0\n\n    for _ in range(N):\n        r_x = np.linalg.norm(x)\n        b_x = drift_func(x, r_x)\n        \n        # Proposal step\n        xi = rng.normal(size=dim)\n        m_x = x + 0.5 * tau * b_x\n        y = m_x + np.sqrt(tau) * xi\n        \n        r_y = np.linalg.norm(y)\n        b_y = drift_func(y, r_y)\n        \n        # Acceptance step\n        log_pi_x = log_pi_func(r_x)\n        log_pi_y = log_pi_func(r_y)\n\n        # The log-acceptance probability exponent\n        log_alpha_exponent = log_pi_y - log_pi_x\n        \n        # Add proposal ratio term if target densities are finite\n        if np.isfinite(log_alpha_exponent):\n            m_y = y + 0.5 * tau * b_y\n            log_q_ratio = (np.sum((y - m_x)**2) - np.sum((x - m_y)**2)) / (2.0 * tau)\n            log_alpha_exponent += log_q_ratio\n\n        if np.log(rng.uniform()) < min(0.0, log_alpha_exponent):\n            x = y\n            accepted_count += 1\n            \n    return accepted_count / N\n\ndef solve():\n    \"\"\"\n    Sets up and runs the four test cases as specified in the problem statement.\n    \"\"\"\n    c = 0.5\n    N = 20000\n    r0 = 0.02\n    x0 = np.array([r0, 0.0, 0.0])\n    \n    test_cases = [\n        {'variant': 'A', 'tau': 0.2, 'seed': 7, 'params': {}},\n        {'variant': 'B', 'tau': 0.2, 'seed': 7, 'params': {'eps': 0.05}},\n        {'variant': 'C', 'tau': 0.2, 'seed': 7, 'params': {'lam': 0.05}},\n        {'variant': 'B', 'tau': 1.0, 'seed': 7, 'params': {'eps': 0.05}}\n    ]\n    \n    results = []\n    \n    for case in test_cases:\n        tau = case['tau']\n        seed = case['seed']\n        params = case['params']\n        \n        if case['variant'] == 'A':\n            log_pi = lambda r: log_pi_L(r, c)\n            drift = lambda x, r: drift_L(x, r, c)\n        \n        elif case['variant'] == 'B':\n            eps = params['eps']\n            log_pi = lambda r: log_pi_L(r, c)\n            drift = lambda x, r: drift_reg(x, r, c, eps)\n            \n        elif case['variant'] == 'C':\n            lam = params['lam']\n            log_pi = lambda r: log_pi_NL(r, c, lam)\n            drift = lambda x, r: drift_NL(x, r, c, lam)\n\n        rate = run_mala_simulation(N, x0, tau, seed, log_pi, drift)\n        results.append(rate)\n\n    print(f\"[{','.join(f'{r:.4f}' for r in results)}]\")\n\nsolve()\n```", "id": "3610701"}]}