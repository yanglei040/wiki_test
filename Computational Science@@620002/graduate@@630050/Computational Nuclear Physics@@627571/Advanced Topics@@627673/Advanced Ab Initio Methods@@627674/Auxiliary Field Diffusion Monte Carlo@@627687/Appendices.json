{"hands_on_practices": [{"introduction": "The heart of any Diffusion Monte Carlo algorithm is the evaluation of the local energy, $E_L = (H\\Psi_T)/\\Psi_T$, which guides the random walk. In Auxiliary Field Diffusion Monte Carlo (AFDMC), the nuclear Hamiltonian $H$ contains complex spin-dependent interactions, such as tensor and spin-orbit forces. This first exercise provides foundational practice in applying these operators to a simple two-nucleon system, which is essential for understanding how AFDMC handles the rich structure of nuclear forces [@problem_id:3542892]. By calculating the local energy for different spin configurations, you will gain direct insight into how these forces depend on the spin state of the interacting particles.", "problem": "Consider two spin-$\\frac{1}{2}$ nucleons interacting via a two-body potential that contains a tensor term and a spin-orbit term, as typically sampled in Auxiliary Field Diffusion Monte Carlo (AFDMC). Let the relative coordinate be $\\mathbf{r}=\\mathbf{r}_1-\\mathbf{r}_2$ with magnitude $r=|\\mathbf{r}|$ and unit vector $\\hat{\\mathbf{r}}=\\mathbf{r}/r$. The interaction is\n$$\nV(\\mathbf{r}) \\;=\\; v_T(r)\\, S_{12} \\;+\\; v_{LS}(r)\\, \\mathbf{L}\\cdot \\mathbf{S},\n$$\nwith $v_T(r)=\\alpha \\exp(-\\beta r^2)$ and $v_{LS}(r)=\\gamma \\exp(-\\delta r^2)$, where $\\alpha$, $\\beta$, $\\gamma$, and $\\delta$ are positive constants. The tensor operator is\n$$\nS_{12} \\;=\\; 3\\,(\\boldsymbol{\\sigma}_1\\cdot \\hat{\\mathbf{r}})(\\boldsymbol{\\sigma}_2\\cdot \\hat{\\mathbf{r}})\\;-\\;\\boldsymbol{\\sigma}_1\\cdot \\boldsymbol{\\sigma}_2,\n$$\nand the total spin is $\\mathbf{S}=\\frac{1}{2}(\\boldsymbol{\\sigma}_1+\\boldsymbol{\\sigma}_2)$. The spin-orbit operator is $\\mathbf{L}\\cdot\\mathbf{S}$, with $\\mathbf{L}$ the relative orbital angular momentum operator acting on the spatial part of the wave function.\n\nLet the trial wave function factorize as $\\Psi_T(\\mathbf{r},\\chi)=\\phi(\\mathbf{r})\\,\\chi$, where $\\chi$ is a two-body spin state and the spatial part is a normalized $s$-wave Gaussian,\n$$\n\\phi(\\mathbf{r}) \\;=\\; \\left(\\frac{\\lambda}{\\pi}\\right)^{3/4}\\exp\\!\\left(-\\frac{\\lambda r^2}{2}\\right),\n$$\nwith $\\lambda>0$. Consider the local energy contributions from each operator at a walker configuration where $\\hat{\\mathbf{r}}=\\hat{\\mathbf{z}}$. The AFDMC local energy contribution of an operator term $V_O(r)\\,O$ is defined as\n$$\nE_L^{(O)}(\\mathbf{r},\\chi)\\;=\\; V_O(r)\\;\\frac{O\\,\\Psi_T(\\mathbf{r},\\chi)}{\\Psi_T(\\mathbf{r},\\chi)}.\n$$\n\nEvaluate, as explicit analytic functions of $r$, $\\alpha$, $\\beta$, $\\gamma$, and $\\delta$, the tensor and spin-orbit local energy contributions for the following two spin configurations:\n- aligned spins: $\\chi_{\\text{align}}=\\lvert\\uparrow\\uparrow\\rangle$ (triplet, $m_S=+1$),\n- anti-aligned spins: $\\chi_{\\text{anti}}=\\frac{1}{\\sqrt{2}}\\big(\\lvert\\uparrow\\downarrow\\rangle-\\lvert\\downarrow\\uparrow\\rangle\\big)$ (singlet, $S=0$).\n\nUse natural units with energy expressed in megaelectronvolts (MeV) and length in femtometers (fm). Report your final result as a single row matrix in the order\n$$\n\\big[E_T^{\\text{(aligned)}},\\;E_{LS}^{\\text{(aligned)}},\\;E_T^{\\text{(anti-aligned)}},\\;E_{LS}^{\\text{(anti-aligned)}}\\big],\n$$\nand express it exactly in terms of $\\alpha$, $\\beta$, $\\gamma$, $\\delta$, and $r$. Do not insert numerical values and do not attach units to the final reported expression.", "solution": "The problem asks for the local energy contributions from the tensor and spin-orbit terms of a two-nucleon potential for two different spin configurations. The local energy for an operator term $V_O(r)\\,O$ acting on a trial wave function $\\Psi_T = \\phi(\\mathbf{r})\\chi$ is given by\n$$\nE_L^{(O)}(\\mathbf{r},\\chi)\\;=\\; V_O(r)\\;\\frac{O\\,\\Psi_T(\\mathbf{r},\\chi)}{\\Psi_T(\\mathbf{r},\\chi)} = V_O(r)\\;\\frac{O\\,\\phi(\\mathbf{r})\\chi}{\\phi(\\mathbf{r})\\chi}.\n$$\nWe must evaluate this for the tensor operator $S_{12}$ and the spin-orbit operator $\\mathbf{L}\\cdot\\mathbf{S}$, for the aligned spin state $\\chi_{\\text{align}}=\\lvert\\uparrow\\uparrow\\rangle$ and the anti-aligned spin state $\\chi_{\\text{anti}}=\\frac{1}{\\sqrt{2}}(\\lvert\\uparrow\\downarrow\\rangle-\\lvert\\downarrow\\uparrow\\rangle)$. The evaluation is specified to be at a configuration where the relative coordinate unit vector is $\\hat{\\mathbf{r}}=\\hat{\\mathbf{z}}$. The radial functions are $v_T(r)=\\alpha \\exp(-\\beta r^2)$ and $v_{LS}(r)=\\gamma \\exp(-\\delta r^2)$.\n\nFirst, let us analyze the spin-orbit local energy contribution, $E_{LS}$. The operator is $\\mathbf{L}\\cdot\\mathbf{S}$. The relative orbital angular momentum operator, $\\mathbf{L} = -i\\hbar(\\mathbf{r}\\times\\nabla)$ (with $\\hbar=1$ in natural units), acts only on the spatial part of the wave function, $\\phi(\\mathbf{r})$. The spatial wave function is given as a normalized $s$-wave Gaussian:\n$$\n\\phi(\\mathbf{r}) \\;=\\; \\left(\\frac{\\lambda}{\\pi}\\right)^{3/4}\\exp\\!\\left(-\\frac{\\lambda r^2}{2}\\right).\n$$\nThis function depends only on the magnitude $r=|\\mathbf{r}|$, meaning it is spherically symmetric. A spherically symmetric function is an eigenfunction of the orbital angular momentum squared operator $\\mathbf{L}^2$ with eigenvalue $L(L+1)\\hbar^2=0$ (since $L=0$ for an $s$-wave). This implies that the action of any component of $\\mathbf{L}$ on $\\phi(\\mathbf{r})$ yields zero. We can show this explicitly:\n$$\n\\nabla \\phi(r) = \\frac{d\\phi}{dr} \\nabla r = \\frac{d\\phi}{dr} \\frac{\\mathbf{r}}{r}.\n$$\nThe action of $\\mathbf{L}$ on $\\phi(r)$ is\n$$\n\\mathbf{L}\\,\\phi(r) = -i(\\mathbf{r}\\times\\nabla)\\phi(r) = -i\\left(\\mathbf{r}\\times\\frac{\\mathbf{r}}{r}\\right)\\frac{d\\phi}{dr}.\n$$\nSince the cross product of a vector with itself is zero ($\\mathbf{r}\\times\\mathbf{r}=0$), we have $\\mathbf{L}\\,\\phi(r) = 0$.\nTherefore, the action of the spin-orbit operator on the total wave function is\n$$\n(\\mathbf{L}\\cdot\\mathbf{S})\\,\\Psi_T(\\mathbf{r},\\chi) = ((\\mathbf{L}\\phi(\\mathbf{r}))\\cdot\\mathbf{S})\\chi = (0\\cdot\\mathbf{S})\\chi = 0.\n$$\nThis means that the spin-orbit local energy contribution is zero for any spin state $\\chi$, as long as the spatial wave function is an $s$-wave.\n$$\nE_{LS}(\\mathbf{r},\\chi) = v_{LS}(r)\\frac{0}{\\phi(\\mathbf{r})\\chi} = 0.\n$$\nConsequently, for both the aligned and anti-aligned spin configurations:\n$$\nE_{LS}^{\\text{(aligned)}} = 0,\n$$\n$$\nE_{LS}^{\\text{(anti-aligned)}} = 0.\n$$\n\nNext, we evaluate the tensor local energy contribution, $E_T$. The tensor operator is\n$$\nS_{12} \\;=\\; 3\\,(\\boldsymbol{\\sigma}_1\\cdot \\hat{\\mathbf{r}})(\\boldsymbol{\\sigma}_2\\cdot \\hat{\\mathbf{r}})\\;-\\;\\boldsymbol{\\sigma}_1\\cdot \\boldsymbol{\\sigma}_2.\n$$\nThe problem specifies the evaluation at a configuration where $\\hat{\\mathbf{r}}=\\hat{\\mathbf{z}}$. At this configuration, the operator simplifies to\n$$\nS_{12}(\\hat{\\mathbf{r}}=\\hat{\\mathbf{z}}) = 3\\,(\\boldsymbol{\\sigma}_1\\cdot \\hat{\\mathbf{z}})(\\boldsymbol{\\sigma}_2\\cdot \\hat{\\mathbf{z}})\\;-\\;\\boldsymbol{\\sigma}_1\\cdot \\boldsymbol{\\sigma}_2 = 3\\,\\sigma_{1z}\\sigma_{2z}\\;-\\;\\boldsymbol{\\sigma}_1\\cdot \\boldsymbol{\\sigma}_2.\n$$\nThe local energy is then\n$$\nE_T(\\mathbf{r},\\chi) = v_T(r) \\frac{(3\\,\\sigma_{1z}\\sigma_{2z}\\;-\\;\\boldsymbol{\\sigma}_1\\cdot \\boldsymbol{\\sigma}_2)\\chi}{\\chi}.\n$$\nSince both spin states given are eigenstates of the operator $3\\,\\sigma_{1z}\\sigma_{2z}\\;-\\;\\boldsymbol{\\sigma}_1\\cdot \\boldsymbol{\\sigma}_2$, the fraction becomes the eigenvalue. We use the identity $\\boldsymbol{\\sigma}_1\\cdot\\boldsymbol{\\sigma}_2 = 2\\mathbf{S}^2-3$, where $\\mathbf{S}^2$ is the total spin squared operator with eigenvalues $S(S+1)$.\n\nFor the aligned spin state, $\\chi_{\\text{align}} = \\lvert\\uparrow\\uparrow\\rangle$:\nThis is a triplet state with total spin $S=1$ and spin projection $m_S=1$.\nIt is an eigenstate of $\\mathbf{S}^2$ with eigenvalue $S(S+1) = 1(1+1) = 2$.\nTherefore, the eigenvalue of $\\boldsymbol{\\sigma}_1\\cdot \\boldsymbol{\\sigma}_2$ for this state is $2(2)-3=1$.\nThe action of $\\sigma_{1z}\\sigma_{2z}$ on $\\chi_{\\text{align}}$ is\n$$\n\\sigma_{1z}\\sigma_{2z}\\lvert\\uparrow\\uparrow\\rangle = (\\sigma_{1z}\\lvert\\uparrow\\rangle)\\otimes(\\sigma_{2z}\\lvert\\uparrow\\rangle) = (+1\\lvert\\uparrow\\rangle)\\otimes(+1\\lvert\\uparrow\\rangle) = 1\\cdot\\lvert\\uparrow\\uparrow\\rangle.\n$$\nThe eigenvalue is $1$.\nThe eigenvalue of the simplified tensor operator is $3(1) - 1 = 2$.\nThus, the tensor local energy for the aligned state is\n$$\nE_T^{\\text{(aligned)}}(r) = v_T(r) \\cdot 2 = 2\\alpha\\exp(-\\beta r^2).\n$$\n\nFor the anti-aligned spin state, $\\chi_{\\text{anti}} = \\frac{1}{\\sqrt{2}}(\\lvert\\uparrow\\downarrow\\rangle-\\lvert\\downarrow\\uparrow\\rangle)$:\nThis is the singlet state with total spin $S=0$.\nIt is an eigenstate of $\\mathbf{S}^2$ with eigenvalue $S(S+1) = 0(0+1) = 0$.\nTherefore, the eigenvalue of $\\boldsymbol{\\sigma}_1\\cdot \\boldsymbol{\\sigma}_2$ for this state is $2(0)-3=-3$.\nThe action of $\\sigma_{1z}\\sigma_{2z}$ on $\\chi_{\\text{anti}}$ is\n$$\n\\sigma_{1z}\\sigma_{2z}\\chi_{\\text{anti}} = \\frac{1}{\\sqrt{2}}\\sigma_{1z}\\sigma_{2z}(\\lvert\\uparrow\\downarrow\\rangle-\\lvert\\downarrow\\uparrow\\rangle) = \\frac{1}{\\sqrt{2}}((+1)(-1)\\lvert\\uparrow\\downarrow\\rangle - (-1)(+1)\\lvert\\downarrow\\uparrow\\rangle) = \\frac{1}{\\sqrt{2}}(-\\lvert\\uparrow\\downarrow\\rangle + \\lvert\\downarrow\\uparrow\\rangle) = -1 \\cdot \\chi_{\\text{anti}}.\n$$\nThe eigenvalue is $-1$.\nThe eigenvalue of the simplified tensor operator is $3(-1) - (-3) = -3+3=0$.\nThus, the tensor local energy for the anti-aligned state is\n$$\nE_T^{\\text{(anti-aligned)}}(r) = v_T(r) \\cdot 0 = 0.\n$$\n\nIn summary, the four requested local energy contributions are:\n1. $E_T^{\\text{(aligned)}} = 2\\alpha\\exp(-\\beta r^2)$\n2. $E_{LS}^{\\text{(aligned)}} = 0$\n3. $E_T^{\\text{(anti-aligned)}} = 0$\n4. $E_{LS}^{\\text{(anti-aligned)}} = 0$\nThese are to be presented as a single row matrix.", "answer": "$$\n\\boxed{\\begin{pmatrix} 2\\alpha\\exp(-\\beta r^2) & 0 & 0 & 0 \\end{pmatrix}}\n$$", "id": "3542892"}, {"introduction": "While powerful, AFDMC must confront the notorious \"phase problem\" that plagues quantum Monte Carlo simulations of fermionic systems. This challenge arises when using the complex-valued trial wavefunctions often necessary to accurately describe realistic nuclei, introducing a systematic energy bias that must be carefully controlled. This practice guides you through a simplified but highly instructive model to derive and compare the energy biases introduced by two common solutions: the fixed-phase and constrained-path approximations [@problem_id:3542929]. Understanding these distinct biases is critical for assessing and mitigating the systematic errors in any advanced AFDMC calculation.", "problem": "You are asked to formalize, derive, and implement a simplified model that compares the constrained-path and fixed-phase forms of Auxiliary Field Diffusion Monte Carlo (AFDMC) for a one-dimensional quantum system using complex trial states. Work in units where the reduced Planck constant is $1$ and the particle mass is $1$. Angles must be treated in radians, and any angle variance must be interpreted as variance in radians squared. All energies must be given in these natural units and expressed as decimal floats.\n\nConsider the one-dimensional harmonic oscillator Hamiltonian $H = -\\frac{1}{2}\\frac{d^2}{dx^2} + \\frac{1}{2}\\omega^2 x^2$ with the exact real ground-state amplitude $|\\Psi_0(x)| \\propto \\exp(-\\omega x^2/2)$. Define a complex trial state of the form $\\Psi_T(x) = |\\Psi_0(x)| e^{i \\theta(x)}$, where the phase is linear, $\\theta(x) = \\kappa x$, and $\\kappa$ is determined by the phase variance $\\mathrm{Var}[\\theta]$ under the sampling distribution $|\\Psi_0(x)|^2$ via the relation $\\mathrm{Var}[\\theta] = \\kappa^2\\,\\mathrm{Var}[x]$. Using that $|\\Psi_0(x)|^2 \\propto e^{-\\omega x^2}$ is a normal distribution with variance $\\mathrm{Var}[x] = 1/(2\\omega)$, one has $\\kappa = \\sqrt{2\\omega\\,\\mathrm{Var}[\\theta]}$. The goal is to derive the bias in the mixed-estimator ground-state energy due solely to the phase constraint for two schemes:\n- Fixed-phase AFDMC: the gauge-field kinetic energy from the phase gradient appears in the real part of the local energy.\n- Constrained-path (phaseless) AFDMC: in addition to the real local-energy contribution, the phaseless constraint projects complex weights using a factor built from the phase rotation per time step, modeled here by a cosine factor at small imaginary-time step.\n\nBase your derivation only on the following foundational elements:\n- The imaginary-time Schrödinger equation, Trotter factorization, and importance sampling with a trial function.\n- The definition of the local energy $E_L(x) = (H\\Psi_T)/\\Psi_T$, and that for $\\Psi_T = |\\Psi_0| e^{i\\theta}$ the real part picks up a kinetic contribution from the phase gradient.\n- The drift-diffusion kernel of Diffusion Monte Carlo (DMC) with kinetic operator $-\\frac{1}{2}\\nabla^2$, which yields a Gaussian displacement with variance $\\Delta \\tau$ over a small time step $\\Delta \\tau$ in one dimension.\n- The phaseless constrained-path projection that replaces complex weight growth by a real factor approximated at small $\\Delta \\tau$ by a cosine of the phase increment $\\Delta \\theta$, and the stationarity condition that the average weight growth per step equals $1$.\n\nFrom these, derive leading-order, small-$\\Delta \\tau$ analytical expressions for the phase-induced energy biases (the excess over the exact ground-state energy) for both fixed-phase and constrained-path AFDMC, expressed as explicit functions of $\\omega$ and $\\mathrm{Var}[\\theta]$ alone. Your result must be applicable for any positive $\\omega$ and any nonnegative $\\mathrm{Var}[\\theta]$, and should not depend on the choice of $\\Delta \\tau$ at leading order. Treat any necessary expectations exactly under the Gaussian models implied by the assumptions above.\n\nThen, implement a program that, given a test suite of $(\\omega,\\mathrm{Var}[\\theta])$ values, computes the two biases:\n- The fixed-phase energy bias $b_{\\mathrm{FP}}(\\omega,\\mathrm{Var}[\\theta])$.\n- The constrained-path energy bias $b_{\\mathrm{CP}}(\\omega,\\mathrm{Var}[\\theta])$.\n\nProvide numerical answers rounded to six decimal places for each test case. Your program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with entries ordered as consecutive pairs $[b_{\\mathrm{FP},1}, b_{\\mathrm{CP},1}, b_{\\mathrm{FP},2}, b_{\\mathrm{CP},2}, \\ldots]$ corresponding to the test suite order.\n\nTest suite to implement:\n- Case $1$: $\\omega = 1.0$, $\\mathrm{Var}[\\theta] = 0.0$.\n- Case $2$: $\\omega = 0.7$, $\\mathrm{Var}[\\theta] = 0.05$.\n- Case $3$: $\\omega = 1.3$, $\\mathrm{Var}[\\theta] = 0.2$.\n- Case $4$: $\\omega = 2.0$, $\\mathrm{Var}[\\theta] = 1.0$.\n\nYour final answers must be decimal floats with six digits after the decimal point and no units in the output (the units are the natural units specified above). The results must be scientifically consistent with the derivation constrained by the stated foundational principles and assumptions, and must not be obtained by any other shortcuts or unstated formulas. The code must be complete and runnable as is, with no external inputs.", "solution": "The user has requested a derivation and implementation for a comparative model of fixed-phase and constrained-path Auxiliary Field Diffusion Monte Carlo (AFDMC) for a one-dimensional quantum system.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n\n- **System**: One-dimensional quantum system in units where $\\hbar=1$ and particle mass $m=1$.\n- **Hamiltonian**: $H = -\\frac{1}{2}\\frac{d^2}{dx^2} + \\frac{1}{2}\\omega^2 x^2$.\n- **Exact Ground-State Amplitude**: $|\\Psi_0(x)| \\propto \\exp(-\\omega x^2/2)$.\n- **Trial State**: $\\Psi_T(x) = |\\Psi_0(x)| e^{i \\theta(x)}$.\n- **Phase Function**: $\\theta(x) = \\kappa x$.\n- **Phase Variance Relation**: $\\mathrm{Var}[\\theta] = \\kappa^2\\,\\mathrm{Var}[x]$.\n- **Sampling Distribution**: $|\\Psi_0(x)|^2 \\propto e^{-\\omega x^2}$.\n- **Variance of Position**: $\\mathrm{Var}[x] = 1/(2\\omega)$.\n- **Derived Parameter**: $\\kappa = \\sqrt{2\\omega\\,\\mathrm{Var}[\\theta]}$.\n- **Goal**: Derive the energy bias for fixed-phase ($b_{\\mathrm{FP}}$) and constrained-path ($b_{\\mathrm{CP}}$) AFDMC as functions of $\\omega$ and $\\mathrm{Var}[\\theta]$.\n- **Foundational Elements for Derivation**:\n    1. Imaginary-time Schrödinger equation, Trotter factorization, importance sampling.\n    2. Local energy $E_L(x) = (H\\Psi_T)/\\Psi_T$; real part includes phase gradient kinetic energy.\n    3. Drift-diffusion kernel for $-\\frac{1}{2}\\nabla^2$ yields Gaussian displacement with variance $\\Delta \\tau$ in time step $\\Delta \\tau$.\n    4. Constrained-path projection approximates complex weight growth with $\\cos(\\Delta \\theta)$, where $\\Delta \\theta$ is the phase increment.\n    5. Stationarity condition: average weight growth per step is $1$.\n- **Constraints**: Derivation must be leading-order in small $\\Delta \\tau$ and independent of $\\Delta \\tau$. All angles are in radians.\n\n**Step 2: Validate Using Extracted Givens**\n\n- **Scientific Grounding**: The problem is based on the one-dimensional quantum harmonic oscillator, a canonical model system. The concepts used—imaginary-time evolution, importance sampling, local energy, fixed-phase and constrained-path approximations—are standard and well-established in the field of Quantum Monte Carlo. The relationships and definitions are consistent with the literature on the subject.\n- **Well-Posedness**: The problem clearly defines the system, the approximations to be used, the quantities to be derived ($b_{\\mathrm{FP}}$, $b_{\\mathrm{CP}}$), and the independent variables ($\\omega$, $\\mathrm{Var}[\\theta]$). The provided information is sufficient to construct a unique analytical solution within the specified model.\n- **Objectivity**: The problem is stated in precise, formal language, free of ambiguity or subjective claims.\n\n**Step 3: Verdict and Action**\n\nThe problem is scientifically grounded, well-posed, objective, and internally consistent. It is a valid problem. The derivation and implementation will proceed.\n\n### Derivation of Energy Biases\n\nThe objective is to find the expectation value of the energy for two different AFDMC schemes. This energy, in the context of a mixed estimator, is an average of the local energy, $E_L(x)$, over the walker distribution, which is maintained by the algorithm. In this idealized model, the walker distribution is assumed to be given exactly by $|\\Psi_0(x)|^2$.\n\n**1. Local Energy Calculation**\n\nThe local energy is defined as $E_L(x) = \\frac{H\\Psi_T(x)}{\\Psi_T(x)}$.\nGiven the trial wave function $\\Psi_T(x) = |\\Psi_0(x)| e^{i \\theta(x)}$, we first compute the action of the Hamiltonian $H$ on $\\Psi_T(x)$. The kinetic energy operator acts as follows:\n$$\n\\frac{d\\Psi_T}{dx} = \\left(\\frac{d|\\Psi_0|}{dx} + i|\\Psi_0|\\frac{d\\theta}{dx}\\right) e^{i\\theta}\n$$\n$$\n\\frac{d^2\\Psi_T}{dx^2} = \\left(\\frac{d^2|\\Psi_0|}{dx^2} + 2i\\frac{d|\\Psi_0|}{dx}\\frac{d\\theta}{dx} + i|\\Psi_0|\\frac{d^2\\theta}{dx^2} - |\\Psi_0|\\left(\\frac{d\\theta}{dx}\\right)^2\\right) e^{i\\theta}\n$$\nThe local energy is then:\n$$\nE_L(x) = \\frac{1}{\\Psi_T(x)} \\left[-\\frac{1}{2}\\frac{d^2\\Psi_T}{dx^2} + \\frac{1}{2}\\omega^2 x^2 \\Psi_T\\right]\n$$\nSubstituting the second derivative and dividing by $\\Psi_T(x) = |\\Psi_0(x)|e^{i\\theta(x)}$ yields:\n$$\nE_L(x) = \\frac{1}{|\\Psi_0|}\\left(-\\frac{1}{2}\\frac{d^2|\\Psi_0|}{dx^2} + \\frac{1}{2}\\omega^2 x^2 |\\Psi_0|\\right) + \\frac{1}{2}\\left(\\frac{d\\theta}{dx}\\right)^2 - i\\left(\\frac{1}{|\\Psi_0|}\\frac{d|\\Psi_0|}{dx}\\frac{d\\theta}{dx} + \\frac{1}{2}\\frac{d^2\\theta}{dx^2}\\right)\n$$\nThe first term is the local energy of the real amplitude $|\\Psi_0(x)|$. Since $|\\Psi_0(x)|$ is the exact ground-state amplitude for the Hamiltonian $H$, this term is constant and equal to the exact ground-state energy, $E_0 = \\frac{1}{2}\\omega$.\n\nFor the given linear phase, $\\theta(x) = \\kappa x$, we have $\\frac{d\\theta}{dx} = \\kappa$ and $\\frac{d^2\\theta}{dx^2} = 0$.\nThe amplitude $|\\Psi_0(x)| \\propto \\exp(-\\frac{1}{2}\\omega x^2)$ gives $\\frac{1}{|\\Psi_0|}\\frac{d|\\Psi_0|}{dx} = -\\omega x$.\nSubstituting these into the expression for $E_L(x)$:\n$$\nE_L(x) = E_0 + \\frac{1}{2}\\kappa^2 - i((-\\omega x)(\\kappa) + 0) = E_0 + \\frac{1}{2}\\kappa^2 + i\\omega\\kappa x\n$$\nSo, the real and imaginary parts of the local energy are:\n$$\n\\mathrm{Re}[E_L(x)] = E_0 + \\frac{1}{2}\\kappa^2\n$$\n$$\n\\mathrm{Im}[E_L(x)] = \\omega\\kappa x\n$$\nNote that $\\mathrm{Re}[E_L(x)]$ is a constant.\n\n**2. Fixed-Phase (FP) Energy Bias**\n\nIn the fixed-phase approximation, the energy is estimated as the expectation value of the real part of the local energy over the walker distribution.\n$$\nE_{\\mathrm{FP}} = \\langle \\mathrm{Re}[E_L(x)] \\rangle_{|\\Psi_0|^2}\n$$\nSince $\\mathrm{Re}[E_L(x)]$ is a constant, its expectation value is the constant itself:\n$$\nE_{\\mathrm{FP}} = E_0 + \\frac{1}{2}\\kappa^2\n$$\nThe energy bias, $b_{\\mathrm{FP}}$, is the difference between this estimated energy and the exact ground-state energy $E_0$:\n$$\nb_{\\mathrm{FP}} = E_{\\mathrm{FP}} - E_0 = \\frac{1}{2}\\kappa^2\n$$\nUsing the provided relation $\\kappa^2 = 2\\omega\\,\\mathrm{Var}[\\theta]$, we obtain the final expression for the fixed-phase bias:\n$$\nb_{\\mathrm{FP}}(\\omega, \\mathrm{Var}[\\theta]) = \\frac{1}{2}(2\\omega\\,\\mathrm{Var}[\\theta]) = \\omega\\,\\mathrm{Var}[\\theta]\n$$\n\n**3. Constrained-Path (CP) Energy Bias**\n\nIn the constrained-path (or phaseless) model specified, the complex weight evolution $\\exp(-i\\Delta\\tau \\mathrm{Im}[E_L])$ is replaced by a real projection factor, which is approximated for a small time step $\\Delta\\tau$ by $\\cos(\\Delta\\theta)$. The total weight growth is $W_{\\text{growth}} = \\exp(-\\Delta\\tau(\\mathrm{Re}[E_L(x)] - E_{\\mathrm{CP}})) \\cos(\\Delta\\theta)$. The stationarity condition requires the ensemble average of this growth factor to be unity, $\\langle W_{\\text{growth}} \\rangle = 1$.\n\nThe phase increment $\\Delta\\theta$ arises from the walker's movement from position $x$ to $x'$ in a time step $\\Delta\\tau$. This movement is governed by importance-sampled drift-diffusion dynamics. The displacement is $x' - x = v(x)\\Delta\\tau + \\eta$, where $v(x) = \\frac{d}{dx}\\ln|\\Psi_0(x)| = -\\omega x$ is the drift velocity and $\\eta$ is a Gaussian random variable with mean $\\langle\\eta\\rangle=0$ and variance $\\langle\\eta^2\\rangle=\\Delta\\tau$.\nThe phase change is:\n$$\n\\Delta\\theta = \\theta(x') - \\theta(x) = \\kappa x' - \\kappa x = \\kappa(x' - x) = \\kappa(-\\omega x \\Delta\\tau + \\eta)\n$$\nWe expand the weight growth factor to leading order in $\\Delta\\tau$. Noticing that $\\eta$ is of order $\\sqrt{\\Delta\\tau}$, $\\eta^2$ is of order $\\Delta\\tau$.\n$$\n\\exp(-\\Delta\\tau(...)) \\approx 1 - \\Delta\\tau(\\mathrm{Re}[E_L(x)] - E_{\\mathrm{CP}})\n$$\n$$\n\\cos(\\Delta\\theta) \\approx 1 - \\frac{1}{2}(\\Delta\\theta)^2 = 1 - \\frac{1}{2}\\kappa^2(-\\omega x \\Delta\\tau + \\eta)^2 = 1 - \\frac{1}{2}\\kappa^2(\\eta^2 - 2\\omega x \\eta \\Delta\\tau + \\omega^2 x^2 (\\Delta\\tau)^2)\n$$\nThe product is, up to terms of order $\\Delta\\tau$:\n$$\nW_{\\text{growth}} \\approx \\left(1 - \\Delta\\tau(\\mathrm{Re}[E_L] - E_{\\mathrm{CP}})\\right) \\left(1 - \\frac{1}{2}\\kappa^2\\eta^2\\right) \\approx 1 - \\Delta\\tau(\\mathrm{Re}[E_L] - E_{\\mathrm{CP}}) - \\frac{1}{2}\\kappa^2\\eta^2\n$$\nNow, we take the expectation value over the walker distribution (for $x$) and the diffusion process (for $\\eta$).\n$$\n\\langle W_{\\text{growth}} \\rangle = \\left\\langle 1 - \\Delta\\tau(\\mathrm{Re}[E_L(x)] - E_{\\mathrm{CP}}) - \\frac{1}{2}\\kappa^2\\eta^2 \\right\\rangle_{x,\\eta}\n$$\n$$\n\\langle W_{\\text{growth}} \\rangle = 1 - \\Delta\\tau(\\langle\\mathrm{Re}[E_L(x)]\\rangle_x - E_{\\mathrm{CP}}) - \\frac{1}{2}\\kappa^2\\langle\\eta^2\\rangle_\\eta\n$$\nUsing $\\langle\\mathrm{Re}[E_L(x)]\\rangle_x = E_0 + \\frac{1}{2}\\kappa^2$ and $\\langle\\eta^2\\rangle_\\eta = \\Delta\\tau$:\n$$\n\\langle W_{\\text{growth}} \\rangle = 1 - \\Delta\\tau\\left( (E_0 + \\frac{1}{2}\\kappa^2) - E_{\\mathrm{CP}} \\right) - \\frac{1}{2}\\kappa^2\\Delta\\tau\n$$\nSetting $\\langle W_{\\text{growth}} \\rangle = 1$ for stationarity implies that the terms proportional to $\\Delta\\tau$ must sum to zero:\n$$\n(E_0 + \\frac{1}{2}\\kappa^2) - E_{\\mathrm{CP}} + \\frac{1}{2}\\kappa^2 = 0\n$$\nSolving for the constrained-path energy $E_{\\mathrm{CP}}$:\n$$\nE_{\\mathrm{CP}} = E_0 + \\kappa^2\n$$\nThe energy bias $b_{\\mathrm{CP}}$ is then:\n$$\nb_{\\mathrm{CP}} = E_{\\mathrm{CP}} - E_0 = \\kappa^2\n$$\nSubstituting $\\kappa^2 = 2\\omega\\,\\mathrm{Var}[\\theta]$:\n$$\nb_{\\mathrm{CP}}(\\omega, \\mathrm{Var}[\\theta]) = 2\\omega\\,\\mathrm{Var}[\\theta]\n$$\n\n**Summary of Results**\n\n- Fixed-Phase bias: $b_{\\mathrm{FP}}(\\omega, \\mathrm{Var}[\\theta]) = \\omega\\,\\mathrm{Var}[\\theta]$.\n- Constrained-Path bias: $b_{\\mathrm{CP}}(\\omega, \\mathrm{Var}[\\theta]) = 2\\omega\\,\\mathrm{Var}[\\theta]$.\n\nThe formulas are now ready for implementation.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the fixed-phase and constrained-path energy biases for a 1D harmonic\n    oscillator model with a complex trial state, based on derived analytical formulas.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Each case is a tuple (omega, Var[theta]).\n    test_cases = [\n        (1.0, 0.0),\n        (0.7, 0.05),\n        (1.3, 0.2),\n        (2.0, 1.0),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        omega, var_theta = case\n        \n        # DERIVATION SUMMARY:\n        # The problem requires deriving the energy bias introduced by the phase of the\n        # trial wave function Psi_T(x) = |Psi_0(x)| exp(i*kappa*x) for a 1D harmonic oscillator.\n        # The exact ground state energy is E0 = omega / 2.\n        #\n        # 1. Local Energy:\n        #    E_L(x) = (H Psi_T) / Psi_T\n        #    E_L(x) = E0 + (1/2)*kappa^2 + i*omega*kappa*x\n        #    The real part is Re[E_L(x)] = E0 + (1/2)*kappa^2.\n        #    The relation kappa^2 = 2 * omega * Var[theta] is given.\n        #\n        # 2. Fixed-Phase (FP) Bias:\n        #    The FP energy is E_FP = <Re[E_L(x)]>. Since Re[E_L] is constant,\n        #    E_FP = E0 + (1/2)*kappa^2.\n        #    The bias is b_FP = E_FP - E0 = (1/2)*kappa^2.\n        #    Substituting for kappa^2:\n        #    b_FP = (1/2) * (2 * omega * var_theta) = omega * var_theta.\n        \n        b_fp = omega * var_theta\n        \n        # 3. Constrained-Path (CP) Bias:\n        #    The stationarity condition is <exp(-d_tau*(Re[E_L]-E_CP)) * cos(d_theta)> = 1.\n        #    Expanding to first order in d_tau gives:\n        #    E_CP = <Re[E_L]> + (1/2)*kappa^2\n        #    E_CP = (E0 + (1/2)*kappa^2) + (1/2)*kappa^2 = E0 + kappa^2.\n        #    The bias is b_CP = E_CP - E0 = kappa^2.\n        #    Substituting for kappa^2:\n        #    b_CP = 2 * omega * var_theta.\n\n        b_cp = 2 * omega * var_theta\n        \n        results.append(b_fp)\n        results.append(b_cp)\n\n    # Format the final output string according to the problem specification.\n    # Each result must be a decimal float with six digits after the decimal point.\n    # The output is a single line: [b_FP1,b_CP1,b_FP2,b_CP2,...]\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3542929"}, {"introduction": "An AFDMC simulation propagates a quantum state over many thousands of small imaginary-time steps, each involving matrix operations derived from the Hubbard-Stratonovich transformation. In practice, these operations are based on approximations (like a truncated series expansion of the propagator) and are subject to floating-point round-off error. This final exercise moves from physics principles to the practicalities of computation, addressing the crucial issue of numerical stability [@problem_id:3542998]. You will model the gradual loss of orthonormality in the spin-isospin basis and implement reorthonormalization schemes, a vital technique for ensuring the long-term fidelity of complex simulations.", "problem": "Consider the Auxiliary Field Diffusion Monte Carlo (AFDMC) method, where the Hubbard-Stratonovich (HS) transformation decouples two-body spin-isospin interactions into fluctuating one-body fields. In such simulations, sequential updates of spin-isospin basis states are applied many times, and numerical round-off together with operator approximation can lead to loss of orthonormality in the basis. Your task is to analyze the numerical stability of these sequential spinor updates under many HS draws by estimating the accumulation of round-off errors and implementing a reorthonormalization scheme for the spin-isospin basis states.\n\nStart from the following well-tested facts and core definitions:\n- The HS transformation expresses two-body operators as Gaussian integrals over auxiliary fields, which, after sampling, yield one-body propagators acting on spin-isospin degrees of freedom.\n- If a generator matrix is anti-Hermitian, then its exact matrix exponential is unitary and preserves orthonormality under exact arithmetic.\n\nDefine a simplified and universal mathematical model:\n- Let the spin-isospin basis matrix be $B_{0} \\in \\mathbb{C}^{4 \\times 4}$ with $B_{0}^{\\dagger} B_{0} = I_{4}$, where $I_{4}$ is the $4 \\times 4$ identity matrix and $^\\dagger$ denotes the conjugate transpose.\n- At time step $n$ with $n \\in \\{0, 1, \\dots, T-1\\}$, sample two independent three-dimensional Gaussian field vectors $a_{n} \\in \\mathbb{R}^{3}$ and $b_{n} \\in \\mathbb{R}^{3}$, each with independent components distributed as $\\mathcal{N}(0, \\sigma^{2})$.\n- Define the spin operators $S_{k} = \\sigma_{k} \\otimes I_{2}$ and the isospin operators $T_{k} = I_{2} \\otimes \\tau_{k}$ for $k \\in \\{x,y,z\\}$, where $\\sigma_{k}$ and $\\tau_{k}$ are the Pauli matrices and $I_{2}$ is the $2 \\times 2$ identity matrix.\n- For a given time step size $dt$, define the anti-Hermitian generator\n$$\nG_{n} = i \\, dt \\left( a_{n,x} S_{x} + a_{n,y} S_{y} + a_{n,z} S_{z} + b_{n,x} T_{x} + b_{n,y} T_{y} + b_{n,z} T_{z} \\right).\n$$\n- To model numerical approximation and round-off, approximate the update operator $U_{n}$ by the second-order truncated series\n$$\nU_{n} \\approx I_{4} + G_{n} + \\tfrac{1}{2} G_{n}^{2},\n$$\nwhich is not exactly unitary and therefore can accumulate orthonormality defects over iterations.\n- Update the basis sequentially by $B_{n+1} = U_{n} B_{n}$.\n\nDefine the orthonormality defect of a basis $B$ as the Frobenius norm\n$$\n\\Delta(B) = \\left\\| B^{\\dagger} B - I_{4} \\right\\|_{F}.\n$$\nTwo reorthonormalization schemes are to be considered:\n- Periodic QR scheme: after every $k$ steps, replace $B$ by the $Q$ factor of the complex QR decomposition of $B$, i.e., $B \\leftarrow Q$, which enforces $Q^{\\dagger} Q = I_{4}$.\n- Threshold QR scheme: at each step, compute $\\Delta(B)$ and if $\\Delta(B) > \\varepsilon$, perform $B \\leftarrow Q$ as above.\n\nYour program must implement the sequential update and optionally apply one of the reorthonormalization schemes. For reproducibility, each test case must use a fixed pseudo-random number generator seed as stated in the test suite. Angles are not used in this problem, and no physical unit is required because all parameters are dimensionless.\n\nCompute the final orthonormality defect $\\Delta(B_{T})$ for each test case. The test suite parameters are as follows, where each case is specified by $(T, dt, \\sigma, \\text{scheme}, \\text{scheme\\_parameter}, \\text{seed})$:\n- Case $1$: $(1000, 0.01, 0.1, \\text{\"none\"}, \\text{None}, 12345)$.\n- Case $2$: $(1000, 0.01, 0.1, \\text{\"periodic\"}, k=50, 12346)$.\n- Case $3$: $(2000, 0.02, 0.3, \\text{\"threshold\"}, \\varepsilon=10^{-6}, 12347)$.\n- Case $4$: $(0, 0.01, 0.1, \\text{\"none\"}, \\text{None}, 12348)$.\n- Case $5$: $(1000, 0.01, 0.1, \\text{\"periodic\"}, k=1, 12349)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[r_{1},r_{2},r_{3},r_{4},r_{5}]$), where each $r_{j}$ is the final orthonormality defect $\\Delta(B_{T})$ for Case $j$ expressed as a floating-point number.", "solution": "The analysis begins from the representation of one-body propagators emerging from the Hubbard-Stratonovich (HS) transformation in Auxiliary Field Diffusion Monte Carlo (AFDMC). The HS transformation rewrites the exponential of a two-body operator as an integral over auxiliary fields, leading to one-body operators sampled from Gaussian distributions. If the generator is anti-Hermitian, the exact exponential is unitary and preserves orthonormality: for a generator $G$ with $G^{\\dagger} = -G$, the exact $U = \\exp(G)$ satisfies $U^{\\dagger} U = I$, so applying $U$ to an orthonormal basis $B$ keeps $B^{\\dagger} B = I$.\n\nWe consider spin-isospin degrees of freedom with basis dimension $4$, arising from the tensor product of spin-$\\tfrac{1}{2}$ and isospin-$\\tfrac{1}{2}$ spaces. Let $B_{0} \\in \\mathbb{C}^{4 \\times 4}$ satisfy $B_{0}^{\\dagger} B_{0} = I_{4}$. At step $n$, the sampled fields $a_{n}, b_{n} \\in \\mathbb{R}^{3}$ define the anti-Hermitian generator\n$$\nG_{n} = i \\, dt \\left( a_{n,x} S_{x} + a_{n,y} S_{y} + a_{n,z} S_{z} + b_{n,x} T_{x} + b_{n,y} T_{y} + b_{n,z} T_{z} \\right),\n$$\nwhere the spin operators are $S_{k} = \\sigma_{k} \\otimes I_{2}$ and the isospin operators are $T_{k} = I_{2} \\otimes \\tau_{k}$ with Pauli matrices $\\sigma_{k}$ and $\\tau_{k}$. Under exact arithmetic with $U_{n} = \\exp(G_{n})$, the product of unitary matrices remains unitary and preserves orthonormality.\n\nHowever, in numerical practice, approximations and round-off introduce non-unitarity. To explicitly model this, we approximate\n$$\nU_{n} \\approx I_{4} + G_{n} + \\tfrac{1}{2} G_{n}^{2},\n$$\nwhich omits higher-order terms and is generally non-unitary. For a current basis $B_{n}$, the update $B_{n+1} = U_{n} B_{n}$ yields the orthonormality defect\n$$\n\\Delta(B_{n+1}) = \\left\\| B_{n+1}^{\\dagger} B_{n+1} - I_{4} \\right\\|_{F} = \\left\\| B_{n}^{\\dagger} \\left( U_{n}^{\\dagger} U_{n} - I_{4} \\right) B_{n} + \\left( B_{n}^{\\dagger} B_{n} - I_{4} \\right) \\right\\|_{F}.\n$$\nUsing the submultiplicativity of the Frobenius norm, we obtain the bound\n$$\n\\Delta(B_{n+1}) \\le \\left\\| U_{n}^{\\dagger} U_{n} - I_{4} \\right\\|_{F} \\left\\| B_{n}^{\\dagger} B_{n} \\right\\|_{2} + \\Delta(B_{n}),\n$$\nand since $\\left\\| B_{n}^{\\dagger} B_{n} \\right\\|_{2} \\ge 1$, this shows the defect grows roughly additively with the per-step non-unitarity. The leading contribution of the truncation error scales with $\\left\\| G_{n} \\right\\|^{3}$, so larger $dt$ and $\\sigma$ increase the rate of accumulation.\n\nTo control error growth, we apply reorthonormalization:\n- In the periodic scheme, after every $k$ steps, compute the complex QR decomposition $B_{n} = Q R$ and replace $B_{n} \\leftarrow Q$. This enforces $Q^{\\dagger} Q = I_{4}$ exactly in floating-point arithmetic up to round-off, resetting $\\Delta(B)$ close to zero. The choice of $k$ trades computational cost for accuracy; small $k$ yields tight control of $\\Delta(B)$.\n- In the threshold scheme, compute $\\Delta(B_{n})$ at each step and apply QR reorthonormalization only when $\\Delta(B_{n})$ exceeds a threshold $\\varepsilon$. This adaptive approach reduces overhead while maintaining stability.\n\nAlgorithmic design:\n1. Initialize $B_{0} = I_{4}$ in complex double precision.\n2. Precompute the $4 \\times 4$ matrices $S_{x}, S_{y}, S_{z}, T_{x}, T_{y}, T_{z}$ via Kronecker products of Pauli matrices.\n3. For each step $n$ from $0$ to $T-1$:\n   a. Draw $a_{n}, b_{n}$ with components $\\mathcal{N}(0,\\sigma^{2})$ using a fixed seed per test case for reproducibility.\n   b. Form $G_{n}$ and compute $U_{n} \\approx I_{4} + G_{n} + \\tfrac{1}{2} G_{n}^{2}$.\n   c. Update $B_{n+1} = U_{n} B_{n}$.\n   d. If using the periodic scheme and $(n+1) \\bmod k = 0$, set $B_{n+1} \\leftarrow Q$ from the complex QR of $B_{n+1}$.\n   e. If using the threshold scheme and $\\Delta(B_{n+1}) > \\varepsilon$, set $B_{n+1} \\leftarrow Q$ from the complex QR of $B_{n+1}$.\n4. After $T$ steps, compute $\\Delta(B_{T}) = \\left\\| B_{T}^{\\dagger} B_{T} - I_{4} \\right\\|_{F}$.\n\nExpected behavior across the test suite:\n- Case $1$ (no reorthonormalization) accumulates a noticeable defect due to non-unitary updates.\n- Case $2$ (periodic with $k=50$) shows a substantially reduced final defect compared to Case $1$.\n- Case $3$ (threshold with $\\varepsilon=10^{-6}$) adaptively controls the defect; with larger $T$, $dt$, and $\\sigma$, it should trigger reorthonormalization multiple times, yielding a final defect on the order of the threshold enforcement.\n- Case $4$ ($T=0$) yields $\\Delta(B_{T}) = 0$ exactly because no update is applied.\n- Case $5$ (periodic with $k=1$) performs QR at every step, keeping the defect minimal.\n\nThe implemented program follows these principles and outputs the final orthonormality defect for each case as a floating-point number in the specified single-line list format.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef pauli_matrices():\n    \"\"\"Return Pauli matrices as complex numpy arrays.\"\"\"\n    sx = np.array([[0, 1], [1, 0]], dtype=np.complex128)\n    sy = np.array([[0, -1j], [1j, 0]], dtype=np.complex128)\n    sz = np.array([[1, 0], [0, -1]], dtype=np.complex128)\n    return sx, sy, sz\n\ndef kron(a, b):\n    return np.kron(a, b).astype(np.complex128)\n\ndef build_spin_isospin_operators():\n    \"\"\"Construct 4x4 spin and isospin operators S_k and T_k via Kronecker products.\"\"\"\n    sx, sy, sz = pauli_matrices()\n    I2 = np.eye(2, dtype=np.complex128)\n    Sx = kron(sx, I2)\n    Sy = kron(sy, I2)\n    Sz = kron(sz, I2)\n    Tx = kron(I2, sx)\n    Ty = kron(I2, sy)\n    Tz = kron(I2, sz)\n    return Sx, Sy, Sz, Tx, Ty, Tz\n\ndef orthonormality_defect(B):\n    \"\"\"Compute Frobenius norm of B^H B - I.\"\"\"\n    G = B.conj().T @ B\n    I4 = np.eye(G.shape[0], dtype=np.complex128)\n    diff = G - I4\n    return float(np.linalg.norm(diff, ord='fro'))\n\ndef truncated_update_operator(G):\n    \"\"\"Second-order truncated series: U ≈ I + G + 0.5 G^2.\"\"\"\n    I = np.eye(G.shape[0], dtype=np.complex128)\n    return I + G + 0.5 * (G @ G)\n\ndef run_case(T, dt, sigma, scheme, scheme_param, seed):\n    \"\"\"\n    Run a single test case.\n    scheme: 'none', 'periodic', or 'threshold'\n    scheme_param: None, int k for periodic, or float epsilon for threshold\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    Sx, Sy, Sz, Tx, Ty, Tz = build_spin_isospin_operators()\n    B = np.eye(4, dtype=np.complex128)\n\n    k = None\n    eps = None\n    if scheme == 'periodic':\n        k = int(scheme_param)\n    elif scheme == 'threshold':\n        eps = float(scheme_param)\n\n    for n in range(T):\n        # Sample HS fields\n        a = rng.normal(loc=0.0, scale=sigma, size=3)\n        b = rng.normal(loc=0.0, scale=sigma, size=3)\n\n        # Build anti-Hermitian generator G_n = i dt (a·S + b·T)\n        G = 1j * dt * (\n            a[0] * Sx + a[1] * Sy + a[2] * Sz +\n            b[0] * Tx + b[1] * Ty + b[2] * Tz\n        )\n\n        # Truncated update\n        U = truncated_update_operator(G)\n        B = U @ B\n\n        # Reorthonormalization schemes\n        if scheme == 'periodic':\n            if (n + 1) % k == 0:\n                Q, _ = np.linalg.qr(B)\n                B = Q\n        elif scheme == 'threshold':\n            if orthonormality_defect(B) > eps:\n                Q, _ = np.linalg.qr(B)\n                B = Q\n        elif scheme == 'none':\n            pass\n        else:\n            raise ValueError(\"Unknown scheme\")\n\n    return orthonormality_defect(B)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (T, dt, sigma, scheme, scheme_param, seed)\n        (1000, 0.01, 0.1, \"none\", None, 12345),\n        (1000, 0.01, 0.1, \"periodic\", 50, 12346),\n        (2000, 0.02, 0.3, \"threshold\", 1e-6, 12347),\n        (0,    0.01, 0.1, \"none\", None, 12348),\n        (1000, 0.01, 0.1, \"periodic\", 1, 12349),\n    ]\n\n    results = []\n    for case in test_cases:\n        T, dt, sigma, scheme, scheme_param, seed = case\n        result = run_case(T, dt, sigma, scheme, scheme_param, seed)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3542998"}]}