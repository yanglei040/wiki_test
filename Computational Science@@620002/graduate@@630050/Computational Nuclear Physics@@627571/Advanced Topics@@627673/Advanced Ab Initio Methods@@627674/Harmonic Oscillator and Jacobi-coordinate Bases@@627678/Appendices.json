{"hands_on_practices": [{"introduction": "A cornerstone of quantum many-body theory is the correct implementation of particle statistics. For identical fermions, the system's wavefunction must be antisymmetric under the exchange of any two particles, a requirement encapsulated by the antisymmetrization projection operator, $A$. This exercise provides fundamental practice in constructing this projector for a three-fermion system and numerically verifying its defining mathematical property of idempotency ($A^2=A$), both in a simple particle-product basis and in the physically important Jacobi-coordinate basis [@problem_id:3563419].", "problem": "Implement a numerical verification of the three-body antisymmetrizer for identical spinless fermions in a one-dimensional harmonic oscillator (HO) basis and in the Jacobi-coordinate HO basis. Consider three equal-mass particles. Use the permutation group on three objects (the symmetric group $S_3$) and the corresponding projectors to define the antisymmetrizer. The antisymmetrizer is defined by\n$$\nA \\equiv \\frac{1}{6}\\sum_{\\pi \\in S_3} \\mathrm{sgn}(\\pi)\\, P_\\pi,\n$$\nwhere $P_\\pi$ is the permutation operator that reorders particle labels according to the permutation $\\pi$, and $\\mathrm{sgn}(\\pi)$ is $+1$ for even permutations and $-1$ for odd permutations. The defining property of a projector is idempotency, namely\n$$\nA^2 = A.\n$$\nYou will work in a truncated HO basis constructed from single-particle HO number eigenstates. Build a fixed-total-quanta three-body basis\n$$\n\\mathcal{B}_{\\mathrm{sp}}(N_{\\mathrm{tot}}) = \\{\\,|n_1,n_2,n_3\\rangle \\,:\\, n_i \\in \\mathbb{N}_0,\\; n_1+n_2+n_3 = N_{\\mathrm{tot}}\\,\\}.\n$$\nThe action of a permutation operator $P_\\pi$ on basis kets is defined by relabeling particle coordinates, equivalently mapping tuples by\n$$\nP_\\pi\\,|n_1,n_2,n_3\\rangle \\;=\\; |n_{\\pi^{-1}(1)},n_{\\pi^{-1}(2)},n_{\\pi^{-1}(3)}\\rangle.\n$$\nPart I (particle-ordered basis): Construct the $|\\,\\mathcal{B}_{\\mathrm{sp}}(N_{\\mathrm{tot}})\\,| \\times |\\,\\mathcal{B}_{\\mathrm{sp}}(N_{\\mathrm{tot}})\\,|$ matrices $P_\\pi$ for all six $\\pi \\in S_3$, assemble $A$, and verify numerically the projector property by evaluating the Frobenius norm\n$$\n\\|A^2 - A\\|_F \\equiv \\sqrt{\\mathrm{Tr}\\big((A^2-A)^\\top (A^2-A)\\big)}.\n$$\nPart II (Jacobi-coordinate basis with center-of-mass decoupling): Define Jacobi modes by the orthonormal transformation that maps particle coordinates to Jacobi coordinates. On the level of HO ladder operators, this is the real orthogonal mode-mixing\n$$\n\\begin{pmatrix}\nb_\\rho \\\\\nb_\\lambda \\\\\nb_{\\mathrm{CM}}\n\\end{pmatrix}\n=\nO\n\\begin{pmatrix}\na_1 \\\\\na_2 \\\\\na_3\n\\end{pmatrix},\n\\quad\nO \\equiv\n\\begin{pmatrix}\n\\frac{1}{\\sqrt{2}} & -\\frac{1}{\\sqrt{2}} & 0 \\\\\n\\frac{1}{\\sqrt{6}} & \\frac{1}{\\sqrt{6}} & -\\frac{2}{\\sqrt{6}} \\\\\n\\frac{1}{\\sqrt{3}} & \\frac{1}{\\sqrt{3}} & \\frac{1}{\\sqrt{3}}\n\\end{pmatrix}.\n$$\nHere $a_i$ are particle-mode annihilation operators and $(b_\\rho,b_\\lambda,b_{\\mathrm{CM}})$ are Jacobi annihilation operators associated with relative coordinates $(\\rho,\\lambda)$ and the center of mass (CM). Use this orthogonal transform to build the unitary change-of-basis matrix $U$ from the particle Fock basis $\\{|n_1,n_2,n_3\\rangle\\}$ with fixed total quanta $N_{\\mathrm{tot}}$ to the Jacobi Fock basis $\\{|n_\\rho,n_\\lambda,N_{\\mathrm{CM}}\\rangle\\}$ with $n_\\rho+n_\\lambda+N_{\\mathrm{CM}}=N_{\\mathrm{tot}}$. Then transform the antisymmetrizer by\n$$\nA_{\\mathrm{Jac}} \\;=\\; U\\, A\\, U^\\top,\n$$\nand restrict it to the center-of-mass ground subspace $N_{\\mathrm{CM}}=0$ by selecting rows and columns with $N_{\\mathrm{CM}}=0$. Verify idempotency in this subspace by computing\n$$\n\\big\\|A_{\\mathrm{Jac}}^{(N_{\\mathrm{CM}}=0)\\,2} - A_{\\mathrm{Jac}}^{(N_{\\mathrm{CM}}=0)}\\big\\|_F.\n$$\nFundamental bases you may use without further justification: (i) the definition of permutation operators and their composition, (ii) the group property $\\mathrm{sgn}(\\pi)\\mathrm{sgn}(\\sigma)=\\mathrm{sgn}(\\pi\\sigma)$, (iii) the three-body antisymmetrizer defined above, (iv) the orthonormality of the Jacobi transformation $O$ for equal masses and equal HO frequencies, and (v) ladder-operator algebra for HO modes.\n\nAlgorithmic implementation requirements:\n- Build the particle-ordered basis at fixed $N_{\\mathrm{tot}}$.\n- Construct all $P_\\pi$ by permuting basis tuples according to $\\pi^{-1}$.\n- Assemble $A$ and verify idempotency numerically via Frobenius norm.\n- Build the unitary change-of-basis $U$ exactly by applying the particle-mode creation operators expressed as linear combinations of Jacobi-mode creation operators to the vacuum, keeping track of normalization using ladder-operator action $b_k^\\dagger|m_k\\rangle=\\sqrt{m_k+1}\\,|m_k+1\\rangle$ and the sequential normalization factors required to construct normalized number states.\n- Transform $A$ to the Jacobi basis and restrict to $N_{\\mathrm{CM}}=0$ to verify idempotency there.\n\nNumerical test suite and required output:\n- Use the following five test cases, specified by the total HO quanta $N_{\\mathrm{tot}}$ and the representation in which to check idempotency:\n    1. $(N_{\\mathrm{tot}}=0,\\ \\mathrm{particle})$\n    2. $(N_{\\mathrm{tot}}=1,\\ \\mathrm{particle})$\n    3. $(N_{\\mathrm{tot}}=2,\\ \\mathrm{particle})$\n    4. $(N_{\\mathrm{tot}}=3,\\ \\mathrm{Jacobi\\ with\\ }N_{\\mathrm{CM}}=0)$\n    5. $(N_{\\mathrm{tot}}=4,\\ \\mathrm{Jacobi\\ with\\ }N_{\\mathrm{CM}}=0)$\n- For each case, compute a single real number equal to the Frobenius norm of the idempotency defect in the specified representation. Do not use any physical unit.\n- Final output format: Your program should produce a single line of output containing the results as a comma-separated list of floats, rounded to twelve decimal places, enclosed in square brackets (e.g., \"[0.0,0.0,0.0,0.0,0.0]\").\n\nYour submission must be a complete, runnable program that performs all steps above and prints the results in the exact required format for the five test cases listed.", "solution": "The user-provided problem is a well-posed and scientifically sound exercise in computational quantum mechanics, specifically concerning the representation of symmetry operators in different basis sets. The problem is valid and all necessary components for a solution are provided. We will proceed to construct the solution by following the specified algorithmic steps.\n\nThe core of the problem is to numerically verify the idempotency property, $A^2 = A$, of the three-body antisymmetrization projector $A$. This verification is performed in two different, but unitarily related, basis sets for a system of three identical spinless fermions in a one-dimensional harmonic oscillator potential.\n\n### Part I: Verification in the Particle-Ordered Basis\n\nFirst, we address the problem in the single-particle product basis.\n\n**1. Basis Construction**\nFor a fixed total number of harmonic oscillator quanta, $N_{\\mathrm{tot}}$, the basis is composed of kets $|n_1, n_2, n_3\\rangle$, where $n_i \\in \\mathbb{N}_0$ are the quantum numbers for particles $1, 2, 3$ respectively, and they satisfy the constraint $n_1 + n_2 + n_3 = N_{\\mathrm{tot}}$.\nWe generate a canonical, lexicographically sorted list of these state tuples $(n_1, n_2, n_3)$, which we denote as $\\mathcal{B}_{\\mathrm{sp}}(N_{\\mathrm{tot}})$. The dimension of this basis is $d = \\binom{N_{\\mathrm{tot}}+3-1}{3-1} = \\binom{N_{\\mathrm{tot}}+2}{2}$. Each state in this list is assigned a unique index, creating a map from the state tuple to its matrix index.\n\n**2. Permutation Operators**\nThe antisymmetrizer $A$ is a linear combination of permutation operators $P_\\pi$ for the six permutations $\\pi$ in the symmetric group $S_3$.\n$$\nA = \\frac{1}{6}\\sum_{\\pi \\in S_3} \\mathrm{sgn}(\\pi)\\, P_\\pi\n$$\nThe action of $P_\\pi$ on a basis ket is given by $P_\\pi\\,|n_1,n_2,n_3\\rangle = |n_{\\pi^{-1}(1)},n_{\\pi^{-1}(2)},n_{\\pi^{-1}(3)}\\rangle$. This means the quantum numbers are reordered according to the inverse permutation $\\pi^{-1}$.\nTo construct the $d \\times d$ matrix representation of $P_\\pi$, we consider its elements $(P_\\pi)_{ij} = \\langle i | P_\\pi | j \\rangle$, where $|i\\rangle$ and $|j\\rangle$ are basis kets. For each basis ket $|j\\rangle = |n_{j1}, n_{j2}, n_{j3}\\rangle$, we compute the permuted ket $|k\\rangle = P_\\pi |j\\rangle$. We then find the index $i$ such that $|i\\rangle = |k\\rangle$. The matrix element $(P_\\pi)_{ij}$ is then $1$, and all other elements in column $j$ are $0$. We repeat this for all $\\pi \\in S_3$. The sign, $\\mathrm{sgn}(\\pi)$, is $+1$ for even permutations (identity, 3-cycles) and $-1$ for odd permutations (transpositions).\n\n**3. Idempotency Verification**\nAfter constructing the matrix representations for all six $P_\\pi$, we assemble the matrix for $A$ by taking their signed sum and dividing by $6$. The final step is to compute the idempotency defect matrix, $A^2 - A$, and calculate its Frobenius norm, $\\|A^2 - A\\|_F$. For an exact projector, this norm must be zero. For spinless fermions, any state with two or more particles having the same quantum number (e.g., $|1,1,0\\rangle$ or $|2,0,0\\rangle$) must be annihilated by the antisymmetrizer. For $N_{\\mathrm{tot}} < 3$, any state $|n_1,n_2,n_3\\rangle$ must have at least two identical quantum numbers. Thus, for $N_{\\mathrm{tot}}=0, 1, 2$, the operator $A$ projects every basis state to zero, making $A$ the zero matrix. Consequently, $A^2-A=0$ and the norm is exactly $0$.\n\n### Part II: Verification in the Jacobi-Coordinate Basis\n\nNext, we transform to a basis that decouples the center-of-mass (CM) motion from the internal relative motion.\n\n**1. Basis Transformation**\nThe transformation from particle-mode ladder operators $(a_1, a_2, a_3)$ to Jacobi-mode operators $(b_\\rho, b_\\lambda, b_{\\mathrm{CM}})$ is given by the orthogonal matrix $O$. The corresponding transformation for creation operators is $a_i^\\dagger = \\sum_k (O^\\top)_{ik} b_k^\\dagger$. A particle basis ket $|n_1, n_2, n_3\\rangle$ can be constructed by applying particle creation operators to the vacuum:\n$$\n|n_1, n_2, n_3\\rangle = \\frac{(a_1^\\dagger)^{n_1}}{\\sqrt{n_1!}} \\frac{(a_2^\\dagger)^{n_2}}{\\sqrt{n_2!}} \\frac{(a_3^\\dagger)^{n_3}}{\\sqrt{n_3!}} |0\\rangle\n$$\nBy substituting the expressions for $a_i^\\dagger$ in terms of $b_k^\\dagger$, we can express any particle ket as a linear combination of Jacobi kets $|n_\\rho, n_\\lambda, N_{\\mathrm{CM}}\\rangle$. The coefficients of this expansion are the elements of the change-of-basis matrix $U$. These coefficients, known as Talmi-Moshinsky brackets, can be calculated systematically via a recursive algorithm with memoization. The recursion proceeds by expressing $|n_1, ..., n_i, ...\\rangle$ in terms of $a_i^\\dagger |n_1, ..., n_i-1, ...\\rangle$ and using the known expansion of the latter.\n\n**2. Transformed Antisymmetrizer**\nWith the unitary matrix $U$ constructed, the antisymmetrizer in the Jacobi basis is obtained by a similarity transformation: $A_{\\mathrm{Jac}} = U A U^\\top$. Since $U$ is real, $U^\\dagger = U^\\top$.\n\n**3. Subspace Restriction and Verification**\nWe are interested in the physics of the internal subsystem, which corresponds to the subspace where the center of mass is in its ground state, i.e., $N_{\\mathrm{CM}}=0$. We identify the rows and columns of $A_{\\mathrm{Jac}}$ that correspond to basis states $|n_\\rho, n_\\lambda, 0\\rangle$ with $n_\\rho+n_\\lambda=N_{\\mathrm{tot}}$. This yields a smaller matrix, $A_{\\mathrm{Jac}}^{(N_{\\mathrm{CM}}=0)}$. We then verify idempotency in this subspace by computing the Frobenius norm of its defect matrix, $\\| (A_{\\mathrm{Jac}}^{(N_{\\mathrm{CM}}=0)})^2 - A_{\\mathrm{Jac}}^{(N_{\\mathrm{CM}}=0)} \\|_F$. Due to the exactness of the implemented transformations, this norm should be numerically zero (i.e., on the order of machine floating-point precision).", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom math import sqrt\nfrom itertools import permutations\nfrom collections import defaultdict\n\n# Memoization cache for the recursive Jacobi expansion function.\n# A global variable is used for simplicity across calls for a single test case.\n_memo_U_calc = {}\n\n# Pre-calculate permutation information for the symmetric group S3.\n# The permutation action on a state |n1,n2,n3> is defined by reordering\n# the quantum numbers according to pi^{-1}. We compute the inverse for each\n# permutation pi in S3 and its sign.\n_S3_PERMS = []\nfor p in permutations(range(3)):\n    # Create the permutation matrix for 'p' to compute its sign (determinant).\n    mat = np.zeros((3, 3))\n    for i, j in enumerate(p):\n        mat[i, j] = 1\n    sign = int(round(np.linalg.det(mat)))\n    \n    # The permutation 'p' maps index i to p[i]. Its inverse maps p[i] back to i.\n    p_inv = [0, 0, 0]\n    for i, j in enumerate(p):\n        p_inv[j] = i\n    _S3_PERMS.append({'pi_inv': tuple(p_inv), 'sign': sign})\n\n# The problem defines the transformation from particle to Jacobi annihilation\n# operators via an orthogonal matrix O. For creation operators, the transformation\n# involves O transpose. This matrix stores the coefficients for expressing particle\n# creation operators (a_i^\\dagger) as linear combinations of Jacobi creation\n# operators (b_k^\\dagger).\n_O_T = np.array([\n    [1 / sqrt(2),  1 / sqrt(6), 1 / sqrt(3)],\n    [-1 / sqrt(2), 1 / sqrt(6), 1 / sqrt(3)],\n    [0,           -2 / sqrt(6), 1 / sqrt(3)]\n])\n\ndef _generate_basis(n_tot, num_particles):\n    \"\"\"\n    Generates all state tuples (n1, n2, ...) for a given total number of quanta\n    n_tot and number of particles. This is a recursive generator for integer partitions.\n    \"\"\"\n    if num_particles == 1:\n        yield (n_tot,)\n        return\n    for i in range(n_tot + 1):\n        for p in _generate_basis(n_tot - i, num_particles - 1):\n            yield (i,) + p\n\ndef _get_jacobi_expansion(n_tuple):\n    \"\"\"\n    Recursively computes the expansion of a particle state in the Jacobi basis\n    using memoization to store results of subproblems.\n    \"\"\"\n    if n_tuple in _memo_U_calc:\n        return _memo_U_calc[n_tuple]\n    \n    if sum(n_tuple) == 0:\n        # The vacuum state is the same in both bases.\n        return {(0, 0, 0): 1.0}\n\n    # For a canonical recursion path, always decrement the last non-zero quantum number.\n    idx_to_decr = -1\n    for i in range(len(n_tuple) - 1, -1, -1):\n        if n_tuple[i] > 0:\n            idx_to_decr = i\n            break\n    \n    prev_n_list = list(n_tuple)\n    prev_n_list[idx_to_decr] -= 1\n    prev_n_tuple = tuple(prev_n_list)\n\n    prev_coeffs = _get_jacobi_expansion(prev_n_tuple)\n    \n    new_coeffs = defaultdict(float)\n    \n    # Coefficients for a_i^\\dagger = sum_k (O^T)_ik b_k^\\dagger\n    a_op_coeffs = _O_T[idx_to_decr]\n\n    for jacobi_state, old_coeff in prev_coeffs.items():\n        # Action of b_rho^dagger\n        state_rho = (jacobi_state[0] + 1, jacobi_state[1], jacobi_state[2])\n        new_coeffs[state_rho] += old_coeff * a_op_coeffs[0] * sqrt(jacobi_state[0] + 1)\n        \n        # Action of b_lambda^dagger\n        state_lambda = (jacobi_state[0], jacobi_state[1] + 1, jacobi_state[2])\n        new_coeffs[state_lambda] += old_coeff * a_op_coeffs[1] * sqrt(jacobi_state[1] + 1)\n\n        # Action of b_cm^dagger\n        state_cm = (jacobi_state[0], jacobi_state[1], jacobi_state[2] + 1)\n        new_coeffs[state_cm] += old_coeff * a_op_coeffs[2] * sqrt(jacobi_state[2] + 1)\n        \n    # Final normalization factor sqrt(n_i) from a_i^dagger |...n_i-1...>\n    norm_factor = sqrt(n_tuple[idx_to_decr])\n    final_coeffs = {state: val / norm_factor for state, val in new_coeffs.items()}\n        \n    _memo_U_calc[n_tuple] = final_coeffs\n    return final_coeffs\n\ndef solve():\n    \"\"\"\n    Main function to execute the verification for all specified test cases.\n    \"\"\"\n    test_cases = [\n        (0, 'particle'),\n        (1, 'particle'),\n        (2, 'particle'),\n        (3, 'Jacobi'),\n        (4, 'Jacobi')\n    ]\n\n    results = []\n\n    for N_tot, basis_type in test_cases:\n        # Generate and order the basis states for a fixed N_tot. This structure\n        # is used for both the particle and Jacobi bases.\n        temp_basis = _generate_basis(N_tot, 3)\n        # The generator produces tuples in (n3,n2,n1) order; reverse and sort for canonical order.\n        basis = sorted([s[::-1] for s in temp_basis])\n        dim = len(basis)\n        state_map = {state: i for i, state in enumerate(basis)}\n\n        # Construct the antisymmetrizer matrix A in the particle basis.\n        A = np.zeros((dim, dim), dtype=np.float64)\n        for perm_info in _S3_PERMS:\n            pi_inv = perm_info['pi_inv']\n            sign = perm_info['sign']\n            P = np.zeros((dim, dim), dtype=np.float64)\n            for j, state_j in enumerate(basis):\n                permuted_state = (state_j[pi_inv[0]], state_j[pi_inv[1]], state_j[pi_inv[2]])\n                i = state_map[permuted_state]\n                P[i, j] = 1.0\n            A += sign * P\n        A /= 6.0\n\n        if basis_type == 'particle':\n            # Verify idempotency directly in the particle basis.\n            defect = A @ A - A\n            norm = np.linalg.norm(defect, 'fro')\n            results.append(norm)\n        else: # basis_type == 'Jacobi'\n            global _memo_U_calc\n            _memo_U_calc.clear() # Reset memoization for each new N_tot.\n\n            # Construct the unitary change-of-basis matrix U.\n            U = np.zeros((dim, dim), dtype=np.float64)\n            for j, sp_state in enumerate(basis):\n                expansion = _get_jacobi_expansion(sp_state)\n                for jac_state, coeff in expansion.items():\n                    if jac_state in state_map:\n                        i = state_map[jac_state]\n                        U[i, j] = coeff\n\n            # Transform A to the Jacobi basis.\n            A_jac = U @ A @ U.T\n\n            # Restrict to the N_CM = 0 subspace.\n            ncm0_indices = [i for i, state in enumerate(basis) if state[2] == 0]\n            A_jac_ncm0 = A_jac[np.ix_(ncm0_indices, ncm0_indices)]\n\n            # Verify idempotency in the restricted subspace.\n            defect = A_jac_ncm0 @ A_jac_ncm0 - A_jac_ncm0\n            norm = np.linalg.norm(defect, 'fro')\n            results.append(norm)\n            \n    print(f\"[{','.join([f'{r:.12f}' for r in results])}]\")\n\nsolve()\n```", "id": "3563419"}, {"introduction": "While the harmonic oscillator basis is a powerful tool, its practical use involves truncation, which can introduce unphysical artifacts. A primary example in nuclear physics is the mixing of the system's internal (intrinsic) motion with the motion of its center of mass, known as center-of-mass contamination. This practice introduces the Lawson method, a standard technique that suppresses these spurious excitations by adding a penalty term to the Hamiltonian, allowing for the extraction of physically meaningful intrinsic observables from truncated-space calculations [@problem_id:3563429].", "problem": "Consider a system of two distinguishable, equal-mass particles confined to one spatial dimension and moving in a Harmonic Oscillator (HO) potential. Work in Harmonic Oscillator units where $\\hbar = 1$, $m = 1$, and $\\omega = 1$, so that all energies and lengths are dimensionless. The total two-body laboratory-frame Hamiltonian is\n$$\nH_{\\text{tot}} = \\sum_{i=1}^{2} \\left( \\frac{p_i^2}{2} + \\frac{x_i^2}{2} \\right),\n$$\nand the center-of-mass Hamiltonian is\n$$\nH_{\\text{cm}} = \\frac{(p_1 + p_2)^2}{4} + \\frac{(x_1 + x_2)^2}{4}.\n$$\nDefine the intrinsic Hamiltonian by\n$$\nH_{\\text{intr}} = H_{\\text{tot}} - H_{\\text{cm}}.\n$$\nIntroduce a Lawson term parameterized by a nonnegative scalar $\\beta$ via\n$$\nH(\\beta) = H_{\\text{intr}} + \\beta \\left( H_{\\text{cm}} - \\frac{1}{2} \\right),\n$$\nwhich shifts states with nonzero center-of-mass excitations while leaving the $0\\hbar\\omega$ center-of-mass sector unshifted.\n\nYou will represent operators in a truncated single-particle HO basis of size $N_{\\text{sp}} + 1$ (with single-particle quantum numbers $n = 0, 1, \\dots, N_{\\text{sp}}$), and restrict the two-body product basis to the subspace with total quanta $n_1 + n_2 \\le N_{\\text{cut}}$. Use the standard HO ladder operators $a$ and $a^\\dagger$ to build the single-particle position and momentum matrices,\n$$\nx = \\frac{1}{\\sqrt{2}} \\left( a + a^\\dagger \\right), \\quad p = \\frac{i}{\\sqrt{2}} \\left( a^\\dagger - a \\right),\n$$\nand then construct two-body operators by Kronecker sums and products. Define the intrinsic observable\n$$\nO_{\\text{rel}} = (x_1 - x_2)^2,\n$$\nwhich depends only on the relative coordinate and is therefore an intrinsic operator.\n\nFundamental starting points to use:\n- The canonical ladder-operator relations of the Harmonic Oscillator, the definitions of $x$ and $p$ in terms of $a$ and $a^\\dagger$, and the HO single-particle Hamiltonian $h_{\\text{sp}} = \\frac{p^2}{2} + \\frac{x^2}{2}$.\n- The definitions of the center-of-mass coordinate $X_{\\text{cm}} = (x_1 + x_2)/2$ and momentum $P_{\\text{cm}} = p_1 + p_2$, producing $H_{\\text{cm}} = \\frac{P_{\\text{cm}}^2}{2M} + \\frac{1}{2} M \\omega^2 X_{\\text{cm}}^2$ with $M = 2$ and $\\omega = 1$, which simplifies to the given expression for $H_{\\text{cm}}$.\n- The notion that intrinsic observables commute with center-of-mass operators in the full infinite Hilbert space, implying that once spurious center-of-mass excitations are removed, intrinsic observables should be insensitive to the Lawson parameter $\\beta$.\n\nTask:\n- For each parameter set in the test suite below, and for each value of $\\beta$ specified in that set, diagonalize $H(\\beta)$ in the truncated two-body space. Among all eigenvectors, identify the state whose expectation value of $H_{\\text{cm}}$ is closest to $1/2$, which serves as the numerical proxy for the $0\\hbar\\omega$ center-of-mass sector in the truncated space. For that selected state, compute the intrinsic energy $E_{\\text{intr}} = \\langle H_{\\text{intr}} \\rangle$ and the intrinsic observable value $\\langle O_{\\text{rel}} \\rangle$.\n- For each parameter set, take the results at $\\beta = 0$ as the baseline and compute the maximum absolute deviation across the other $\\beta$ values within that set for both $E_{\\text{intr}}$ and $\\langle O_{\\text{rel}} \\rangle$. If both maxima are less than or equal to the tolerance $\\varepsilon = 10^{-6}$, return the boolean value $\\text{True}$ for that parameter set; otherwise, return $\\text{False}$.\n\nAll quantities are dimensionless in HO units. No angles or percentages are involved.\n\nTest suite:\n- Case $1$: $N_{\\text{sp}} = 6$, $N_{\\text{cut}} = 6$, $\\beta \\in \\{ 0.0, 1.0, 10.0, 50.0 \\}$.\n- Case $2$: $N_{\\text{sp}} = 2$, $N_{\\text{cut}} = 2$, $\\beta \\in \\{ 0.0, 2.0, 20.0 \\}$.\n- Case $3$: $N_{\\text{sp}} = 5$, $N_{\\text{cut}} = 3$, $\\beta \\in \\{ 0.0, 100.0 \\}$.\n- Case $4$ (boundary-only space): $N_{\\text{sp}} = 4$, $N_{\\text{cut}} = 0$, $\\beta \\in \\{ 0.0, 20.0, 200.0 \\}$.\n\nRequired final output format:\n- Your program should produce a single line of output containing the per-case results as a comma-separated list of booleans enclosed in square brackets (for example, $[True,False,True,True]$).", "solution": "The problem is valid. It presents a well-posed, scientifically-grounded exercise in computational quantum mechanics, specifically concerning the separation of center-of-mass and intrinsic motion in a many-body system within a truncated basis. This is a canonical problem in nuclear structure theory. The procedure is to construct the matrix representation of a specialized Hamiltonian, diagonalize it, and analyze the properties of the resulting ground state to verify the effectiveness of the so-called Lawson method.\n\nThe theoretical framework is the two-particle one-dimensional harmonic oscillator (HO). We work in dimensionless HO units where $\\hbar = m = \\omega = 1$.\n\n**1. Single-Particle Basis and Operators**\n\nThe foundation of the calculation is the single-particle HO basis, which consists of the eigenstates $|n\\rangle$ of the single-particle Hamiltonian $h_{\\text{sp}} = \\frac{p^2}{2} + \\frac{x^2}{2}$. The corresponding eigenvalues are $E_n = n + \\frac{1}{2}$ for $n = 0, 1, 2, \\dots$. For computational tractability, this basis is truncated to a finite dimension $N_{\\text{sp}} + 1$, including states $|n\\rangle$ for $n=0, 1, \\dots, N_{\\text{sp}}$.\n\nWithin this basis, the fundamental operators are the creation ($a^\\dagger$) and annihilation ($a$) operators, whose matrix elements are given by:\n$$\n\\langle n' | a | n \\rangle = \\sqrt{n} \\, \\delta_{n', n-1}\n$$\n$$\n\\langle n' | a^\\dagger | n \\rangle = \\sqrt{n+1} \\, \\delta_{n', n+1}\n$$\nThe position ($x$) and momentum ($p$) operators are then constructed from these ladder operators as specified:\n$$\nx = \\frac{1}{\\sqrt{2}} (a + a^\\dagger)\n$$\n$$\np = \\frac{i}{\\sqrt{2}} (a^\\dagger - a)\n$$\nThese definitions yield $(N_{\\text{sp}}+1) \\times (N_{\\text{sp}}+1)$ matrices for $x$ and $p$, which are the building blocks for all subsequent two-body operators.\n\n**2. Two-Body Basis and Operators**\n\nFor a system of two distinguishable particles, the basis is the tensor product of the single-particle spaces. A basis state is denoted as $|n_1\\rangle \\otimes |n_2\\rangle$ or simply $|n_1, n_2\\rangle$. An operator $O$ acting only on particle $i$ is represented in the two-body space as $O_1 = O \\otimes I$ and $O_2 = I \\otimes O$, where $I$ is the identity matrix in the single-particle space.\n\nThe problem imposes a crucial truncation on the two-body model space: only states $|n_1, n_2\\rangle$ for which the total number of quanta $n_1 + n_2 \\le N_{\\text{cut}}$ are retained. This defines the finite-dimensional Hilbert space in which all calculations are performed. The operators must be projected onto this truncated subspace. This is achieved by first constructing the operators in the full product space (of dimension $(N_{\\text{sp}}+1)^2$) and then selecting the sub-matrix corresponding to the basis states that satisfy the $N_{\\text{cut}}$ condition.\n\nUsing this prescription, we construct the matrix representations of the required two-body operators:\n- **Total Hamiltonian**: $H_{\\text{tot}} = h_{\\text{sp},1} + h_{\\text{sp},2} = (h_{\\text{sp}} \\otimes I) + (I \\otimes h_{\\text{sp}})$. Since $h_{\\text{sp}}$ is diagonal in the $|n\\rangle$ basis, $H_{\\text{tot}}$ is diagonal in the $|n_1, n_2\\rangle$ product basis with eigenvalues $(n_1 + \\frac{1}{2}) + (n_2 + \\frac{1}{2}) = n_1 + n_2 + 1$.\n- **Center-of-Mass Hamiltonian**: $H_{\\text{cm}} = \\frac{1}{4}(p_1 + p_2)^2 + \\frac{1}{4}(x_1 + x_2)^2$. This is constructed by first forming $x_1, x_2, p_1, p_2$ via Kronecker products and then combining them as specified.\n- **Intrinsic Hamiltonian**: $H_{\\text{intr}} = H_{\\text{tot}} - H_{\\text{cm}}$. This represents the dynamics in the relative coordinate.\n- **Relative Observable**: $O_{\\text{rel}} = (x_1 - x_2)^2$.\n\n**3. The Lawson Method and State Identification**\n\nIn the infinite Hilbert space, the total Hamiltonian separates perfectly, $H_{\\text{tot}} = H_{\\text{cm}} + H_{\\text{intr}}$, and its eigenstates are simple products of intrinsic and CM eigenstates. Consequently, intrinsic observables (like $O_{\\text{rel}}$), which commute with $H_{\\text{cm}}$, have expectation values that are independent of the CM state.\n\nHowever, truncating the basis to $n_1+n_2 \\le N_{\\text{cut}}$ breaks this separability. The eigenstates of $H_{\\text{tot}}$ (or $H_{\\text{intr}}$) in the truncated space become admixtures of different CM excitations. This is a common issue known as \"center-of-mass contamination.\"\n\nThe Lawson method is designed to mitigate this. We introduce the modified Hamiltonian:\n$$\nH(\\beta) = H_{\\text{intr}} + \\beta \\left( H_{\\text{cm}} - E_{\\text{cm},0} \\right)\n$$\nHere, $E_{\\text{cm},0} = \\frac{1}{2}$ is the energy of the CM ground state (a harmonic oscillator with mass $M=2$ and frequency $\\omega=1$). For a large, positive parameter $\\beta$, this term adds a large energy penalty to any state that is not in the CM ground state. Diagonalizing $H(\\beta)$ thus yields a low-lying eigenstate that is predominantly composed of the true intrinsic ground state, with spurious CM excitations suppressed.\n\nThe computational task is to diagonalize the matrix of $H(\\beta)$ for various $\\beta$ values. The desired \"physical\" state is identified as the eigenvector $|\\psi\\rangle$ for which the expectation value $\\langle\\psi|H_{\\text{cm}}|\\psi\\rangle$ is closest to the target CM ground-state energy, $\\frac{1}{2}$.\n\n**4. Calculation and Verification**\n\nFor the identified state $|\\psi\\rangle$, we compute the expectation values of the intrinsic energy, $E_{\\text{intr}} = \\langle\\psi|H_{\\text{intr}}|\\psi\\rangle$, and the intrinsic observable, $\\langle O_{\\text{rel}} \\rangle = \\langle\\psi|O_{\\text{rel}}|\\psi\\rangle$.\n\nThe central hypothesis is that as $\\beta$ increases, these intrinsic quantities should converge to their true, uncontaminated values. The case $\\beta=0$ represents the uncorrected result. The task requires computing the maximum absolute deviation of $E_{\\text{intr}}$ and $\\langle O_{\\text{rel}} \\rangle$ for $\\beta > 0$ relative to the $\\beta=0$ baseline. If these deviations are below a specified tolerance $\\varepsilon = 10^{-6}$, it confirms that the Lawson method is effective for the given truncation and that the calculated intrinsic properties are stable against the projection parameter.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main driver function to execute the problem for all test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1\n        {'N_sp': 6, 'N_cut': 6, 'betas': [0.0, 1.0, 10.0, 50.0]},\n        # Case 2\n        {'N_sp': 2, 'N_cut': 2, 'betas': [0.0, 2.0, 20.0]},\n        # Case 3\n        {'N_sp': 5, 'N_cut': 3, 'betas': [0.0, 100.0]},\n        # Case 4\n        {'N_sp': 4, 'N_cut': 0, 'betas': [0.0, 20.0, 200.0]}\n    ]\n    tolerance = 1e-6\n    final_results = []\n\n    for case in test_cases:\n        N_sp = case['N_sp']\n        N_cut = case['N_cut']\n        betas = case['betas']\n        \n        obs_results = []\n        for beta in betas:\n            # For each beta, calculate the intrinsic energy and observable expectation value.\n            E_intr, O_rel_val = calculate_observables(N_sp, N_cut, beta)\n            obs_results.append((E_intr, O_rel_val))\n            \n        # Use beta=0 as the baseline for comparison.\n        baseline_E_intr, baseline_O_rel = obs_results[0]\n        \n        max_dev_E = 0.0\n        max_dev_O = 0.0\n        \n        if len(obs_results) > 1:\n            for E, O in obs_results[1:]:\n                max_dev_E = max(max_dev_E, abs(E - baseline_E_intr))\n                max_dev_O = max(max_dev_O, abs(O - baseline_O_rel))\n        \n        # Check if both deviations are within the specified tolerance.\n        is_stable = (max_dev_E = tolerance) and (max_dev_O = tolerance)\n        final_results.append(is_stable)\n\n    # Format and print the final output as a single-line string.\n    print(f\"[{','.join(map(str, final_results))}]\")\n\ndef calculate_observables(N_sp, N_cut, beta):\n    \"\"\"\n    Constructs and solves the quantum system for a given set of parameters.\n\n    Args:\n        N_sp (int): Maximum single-particle quantum number.\n        N_cut (int): Maximum total quanta for the two-body basis.\n        beta (float): The Lawson parameter.\n\n    Returns:\n        tuple[float, float]: A tuple containing the calculated expectation values\n                             for the intrinsic energy and the relative observable.\n    \"\"\"\n    sp_dim = N_sp + 1\n\n    # 1. Construct single-particle ladder operators, position, and momentum.\n    n_range = np.arange(sp_dim)\n    # Annihilation operator a: n'|a|n = sqrt(n) * delta_{n', n-1}\n    a = np.diag(np.sqrt(n_range[1:]), k=1)\n    # Creation operator a_dag: n'|a_dag|n = sqrt(n+1) * delta_{n', n+1}\n    a_dag = np.diag(np.sqrt(n_range[1:]), k=-1)\n    \n    x_sp = (a + a_dag) / np.sqrt(2.0)\n    p_sp = 1j * (a_dag - a) / np.sqrt(2.0)\n\n    # 2. Define the truncated two-body basis.\n    # The valid_indices list stores the 1D index of each valid basis state |n1, n2>\n    # in the full tensor product space. The 1D index is n1*sp_dim + n2.\n    valid_indices = []\n    for n1 in range(sp_dim):\n        for n2 in range(sp_dim):\n            if n1 + n2 = N_cut:\n                valid_indices.append(n1 * sp_dim + n2)\n    \n    trunc_dim = len(valid_indices)\n    if trunc_dim == 0:\n        return (np.nan, np.nan) # Should not occur with given test cases.\n\n    # 3. Construct two-body operators in the full product space.\n    I_sp = np.identity(sp_dim)\n    x1 = np.kron(x_sp, I_sp)\n    x2 = np.kron(I_sp, x_sp)\n    p1 = np.kron(p_sp, I_sp)\n    p2 = np.kron(I_sp, p_sp)\n    \n    h_sp = 0.5 * (p_sp @ p_sp + x_sp @ x_sp)\n    H_tot_full = np.kron(h_sp, I_sp) + np.kron(I_sp, h_sp)\n    \n    P_cm_full = p1 + p2\n    inv_X_cm_term_full = x1 + x2 # This is (x1+x2)\n    H_cm_full = 0.25 * (P_cm_full @ P_cm_full + inv_X_cm_term_full @ inv_X_cm_term_full)\n    \n    H_intr_full = H_tot_full - H_cm_full\n    O_rel_full = (x1 - x2) @ (x1 - x2)\n\n    # 4. Project operators onto the truncated basis.\n    proj = np.ix_(valid_indices, valid_indices)\n    H_intr = H_intr_full[proj].real\n    H_cm = H_cm_full[proj].real\n    O_rel = O_rel_full[proj].real\n    I_trunc = np.identity(trunc_dim)\n\n    # 5. Construct the Lawson Hamiltonian H(beta) and diagonalize.\n    H_beta = H_intr + beta * (H_cm - 0.5 * I_trunc)\n    eigenvalues, eigenvectors = np.linalg.eigh(H_beta)\n\n    # 6. Identify the ground-state proxy.\n    # Calculate psi|H_cm|psi for all eigenvectors psi.\n    h_cm_exp_vals = np.einsum('ji,jk,ki->i', eigenvectors.conj(), H_cm, eigenvectors)\n    \n    # Find the index of the eigenvector with H_cm closest to 0.5.\n    gs_proxy_idx = np.argmin(np.abs(h_cm_exp_vals - 0.5))\n    psi_gs_proxy = eigenvectors[:, gs_proxy_idx]\n\n    # 7. Calculate final expectation values for the identified state.\n    e_intr_val = psi_gs_proxy.conj().T @ H_intr @ psi_gs_proxy\n    o_rel_val = psi_gs_proxy.conj().T @ O_rel @ psi_gs_proxy\n\n    return np.real(e_intr_val), np.real(o_rel_val)\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3563429"}, {"introduction": "The choice of basis is critical for the efficiency and accuracy of many-body calculations. While the harmonic oscillator basis is a convenient starting point, a more physically attuned basis can often provide a more compact representation. This exercise explores the transformation to the natural orbital basis, which is obtained by diagonalizing the one-body density matrix and is, by definition, the optimal single-particle basis for a given many-body state. You will quantify the effectiveness of this transformation by measuring the resulting basis compression and observing how it concentrates the Hamiltonian's structure along the diagonal [@problem_id:3563403].", "problem": "Consider a finite, orthonormal basis of Jacobi-coordinate harmonic oscillator (HO) single-particle states of dimension $N$, and an $A$-body state whose one-body density matrix (OBDM) $\\rho$ is given in that basis. Work in dimensionless harmonic oscillator units where the reduced Planck constant and oscillator frequency are scaled to unity, so no physical units are required. Angles must be expressed in radians. Starting from first principles in linear algebra and quantum mechanics, perform the following tasks for each parameter set in the test suite.\n\nFundamental base and definitions:\n- The one-body density matrix (OBDM) $\\rho$ is defined by $\\rho_{ij} = \\langle a_j^\\dagger a_i \\rangle$, where $a_i$ and $a_j^\\dagger$ are annihilation and creation operators for the single-particle basis states. The matrix $\\rho$ is Hermitian and positive semidefinite.\n- Natural orbitals (NO) are obtained by diagonalizing $\\rho$. If $U$ is the unitary matrix whose columns are the eigenvectors of $\\rho$, and $\\Lambda = \\mathrm{diag}(\\lambda_1,\\dots,\\lambda_N)$ is the diagonal matrix of eigenvalues, then $U^\\dagger \\rho U = \\Lambda$. Ordering the eigenvalues in descending order defines the natural orbital basis.\n- Basis compression is defined as retaining the smallest integer $K$ such that the cumulative occupation fraction satisfies $\\sum_{i=1}^K \\lambda_i \\big/ \\sum_{i=1}^N \\lambda_i \\ge \\tau$, where $0  \\tau \\le 1$ is a threshold.\n- Given a Hermitian Hamiltonian matrix $H$ in the original Jacobi-coordinate HO basis, the matrix in the natural orbital basis is $H' = U^\\dagger H U$. The compressed Hamiltonian is the top-left $K \\times K$ principal submatrix $H'_K$.\n- The off-diagonal fraction of a matrix $M$ is defined by\n$$\nf_{\\mathrm{off}}(M) = \\frac{\\left\\| M - \\mathrm{diag}(\\mathrm{diag}(M)) \\right\\|_F}{\\| M \\|_F},\n$$\nwhere $\\|\\cdot\\|_F$ is the Frobenius norm and $\\mathrm{diag}(\\mathrm{diag}(M))$ denotes the diagonal matrix formed from the diagonal of $M$.\n\nConstruction rules for test instances:\n1. Construct an orthogonal matrix $Q$ as an ordered left-product of Givens rotations acting in index planes $(p,q)$ with angle $\\theta$. A Givens rotation $G^{(p,q)}(\\theta)$ is the identity on all coordinates except the $(p,q)$-plane, where it has the $2 \\times 2$ block\n$$\n\\begin{pmatrix}\n\\cos\\theta  \\sin\\theta \\\\\n-\\sin\\theta  \\cos\\theta\n\\end{pmatrix}.\n$$\nGiven an ordered list $\\{(p_1,q_1,\\theta_1), \\dots, (p_m,q_m,\\theta_m)\\}$, define\n$$\nQ = G^{(p_m,q_m)}(\\theta_m)\\cdots G^{(p_2,q_2)}(\\theta_2) G^{(p_1,q_1)}(\\theta_1).\n$$\nIndices $p_\\ell,q_\\ell$ are one-based in the specification below.\n2. Given a diagonal matrix of prescribed nonnegative eigenvalues $\\Lambda = \\mathrm{diag}(\\lambda_1,\\dots,\\lambda_N)$, define the OBDM by\n$$\n\\rho = Q \\Lambda Q^\\top.\n$$\n3. Define a real-symmetric effective one-body Hamiltonian $H$ by\n$$\nH_{ii} = b + a\\,(i-1), \\quad i=1,\\dots,N,\n$$\n$$\nH_{ij} =\n\\begin{cases}\nt_1,  |i-j|=1, \\\\\nt_2,  |i-j|=2, \\\\\n0,  \\text{otherwise},\n\\end{cases}\n$$\nand set $H_{ji}=H_{ij}$ to enforce Hermiticity.\n\nComputational tasks for each test case:\n- Diagonalize $\\rho$ to obtain the natural orbital basis $U$ and the eigenvalues $\\{\\lambda_i\\}$ sorted in descending order.\n- Determine the minimal $K$ such that $\\sum_{i=1}^K \\lambda_i \\big/ \\sum_{i=1}^N \\lambda_i \\ge \\tau$.\n- Compute the compression ratio $K/N$.\n- Compute the off-diagonal fraction before transformation $f_{\\mathrm{off}}(H)$ and after transformation-and-truncation $f_{\\mathrm{off}}(H'_K)$, where $H' = U^\\dagger H U$ and $H'_K$ is its top-left $K\\times K$ principal submatrix.\n- Compute the change in off-diagonal fraction $\\Delta = f_{\\mathrm{off}}(H'_K) - f_{\\mathrm{off}}(H)$.\n\nTest suite:\nProvide results for the following parameter sets. Each angle is in radians. All quantities are dimensionless.\n\n- Test case 1:\n  - $N = 4$\n  - Eigenvalues: $\\{\\lambda_i\\} = [1.5, 0.8, 0.4, 0.3]$\n  - Givens rotations (ordered left-product): $\\{(1,2, 0.3), (3,4, -0.5), (1,3, 0.25), (2,4, -0.35)\\}$\n  - Hamiltonian parameters: $a = 0.7$, $b = 0.5$, $t_1 = 0.25$, $t_2 = 0.08$\n  - Threshold: $\\tau = 0.9$\n- Test case 2:\n  - $N = 4$\n  - Eigenvalues: $\\{\\lambda_i\\} = [2.0, 2.0, 0.5, 0.5]$\n  - Givens rotations (ordered left-product): $\\{(1,4, 0.4), (2,3, -0.6), (1,2, 0.2)\\}$\n  - Hamiltonian parameters: $a = 0.5$, $b = 1.0$, $t_1 = 0.3$, $t_2 = 0.0$\n  - Threshold: $\\tau = 1.0$\n- Test case 3:\n  - $N = 5$\n  - Eigenvalues: $\\{\\lambda_i\\} = [1.2, 0.9, 0.6, 0.2, 0.1]$\n  - Givens rotations (ordered left-product): $\\{(1,2, -0.2), (3,4, 0.5), (4,5, -0.3), (2,5, 0.4)\\}$\n  - Hamiltonian parameters: $a = 0.4$, $b = 0.7$, $t_1 = 0.2$, $t_2 = 0.05$\n  - Threshold: $\\tau = 0.5$\n\nRequired outputs:\n- For each test case, output a list of four floating-point numbers $[K/N, f_{\\mathrm{off}}(H), f_{\\mathrm{off}}(H'_K), \\Delta]$.\n- Your program should produce a single line of output containing the results for all three test cases as a comma-separated list enclosed in square brackets, with each per-case list enclosed in its own brackets, for example: \"[[x11,x12,x13,x14],[x21,x22,x23,x24],[x31,x32,x33,x34]]\". There must be no additional whitespace in the final output line.", "solution": "The user has provided a computational problem situated in the domain of nuclear many-body theory, specifically concerning basis transformations and truncations. The problem is self-contained, scientifically valid, and algorithmically well-defined. I will proceed with a detailed solution, starting from the fundamental principles as requested.\n\nThe core task is to analyze the properties of a model one-body Hamiltonian, $H$, before and after a change of basis. The initial basis is a generic, orthonormal set of harmonic oscillator states. The final basis is the \"natural orbital\" (NO) basis, which is defined as the eigenbasis of the one-body density matrix (OBDM), $\\rho$. This procedure is fundamental in many-body calculations because the NO basis provides an optimal representation for truncating the vast single-particle Hilbert space while retaining the most important physical information contained in the OBDM.\n\nThe solution proceeds systematically through the following steps for each test case:\n1.  Construction of the initial Hamiltonian matrix $H$ in the harmonic oscillator (HO) basis.\n2.  Construction of the one-body density matrix $\\rho$ in the same HO basis.\n3.  Diagonalization of $\\rho$ to find the natural orbitals (the matrix of eigenvectors, $U$) and the corresponding occupation numbers (the eigenvalues, $\\{\\lambda_i\\}$).\n4.  Determination of the truncated basis dimension, $K$, based on a cumulative occupation threshold $\\tau$.\n5.  Transformation of the Hamiltonian to the NO basis ($H' = U^\\dagger H U$) and subsequent truncation to dimension $K$ (yielding $H'_K$).\n6.  Calculation and comparison of the \"off-diagonal fraction\" for the initial Hamiltonian $H$ and the truncated transformed Hamiltonian $H'_K$.\n\n### Step 1: Construction of the Hamiltonian\nThe problem defines a real-symmetric, one-body Hamiltonian $H$ in an $N$-dimensional basis. The matrix elements are given by:\n$$\nH_{ij} =\n\\begin{cases}\nb + a(i-1)  \\text{if } i=j \\\\\nt_1  \\text{if } |i-j|=1 \\\\\nt_2  \\text{if } |i-j|=2 \\\\\n0  \\text{otherwise}\n\\end{cases}\n$$\nwhere indices $i, j$ run from $1$ to $N$. The parameters $a$, $b$, $t_1$, and $t_2$ are provided for each test case. This structure represents a simple model where single-particle energies increase linearly with the index (e.g., shell number) and there are short-range interactions or hopping terms between states.\n\n### Step 2: Construction of the One-Body Density Matrix\nThe OBDM, $\\rho$, is specified by its spectral decomposition. By the spectral theorem, any Hermitian matrix (such as $\\rho$) can be written as $\\rho = Q \\Lambda Q^\\dagger$, where $\\Lambda$ is a diagonal matrix of its real eigenvalues and $Q$ is a unitary matrix whose columns are the corresponding eigenvectors.\nThe problem provides the eigenvalues (occupation numbers) for $\\rho$ in a diagonal matrix $\\Lambda = \\mathrm{diag}(\\lambda_1, \\dots, \\lambda_N)$, and defines the matrix $Q$ as an orthogonal matrix constructed from a sequence of Givens rotations.\nA Givens rotation $G^{(p,q)}(\\theta)$ is an orthogonal matrix that is equal to the identity matrix except for a $2 \\times 2$ rotation in the $(p,q)$ plane:\n$$\n\\begin{blockarray}{ccccccc}\n p   q  \\\\\n\\begin{block}{c(cc|ccc)}\np  \\cos\\theta  \\cdots  \\sin\\theta  \\cdots \\\\\n\\vdots  \\vdots  \\ddots  \\vdots  \\\\\nq  -\\sin\\theta  \\cdots  \\cos\\theta  \\cdots \\\\\n\\vdots  \\vdots   \\vdots  \\ddots \\\\\n\\end{{block}}\n\\end{blockarray}\n$$\nGiven an ordered list of rotations $\\{(p_1,q_1,\\theta_1), \\dots, (p_m,q_m,\\theta_m)\\}$, the orthogonal matrix $Q$ is constructed as an ordered left-product:\n$$\nQ = G^{(p_m,q_m)}(\\theta_m) \\cdots G^{(p_2,q_2)}(\\theta_2) G^{(p_1,q_1)}(\\theta_1)\n$$\nThe OBDM is then defined as $\\rho = Q \\Lambda Q^\\top$. Since $Q$ is real and orthogonal ($Q^\\top = Q^{-1} = Q^\\dagger$) and $\\Lambda$ is real, $\\rho$ is real-symmetric. Since the given eigenvalues $\\lambda_i$ are non-negative, $\\rho$ is positive semidefinite, fulfilling the physical requirements for a density matrix.\n\n### Step 3: Finding the Natural Orbital Basis\nThe natural orbital basis is, by definition, the basis in which the OBDM is diagonal. The columns of the transformation matrix $U$ are the natural orbitals, and the diagonal elements are the occupation numbers. To find this basis, we must solve the eigenvalue problem for the constructed matrix $\\rho$:\n$$\n\\rho \\mathbf{v}_i = \\lambda'_i \\mathbf{v}_i\n$$\nThe eigenvectors $\\mathbf{v}_i$ form the columns of the unitary matrix $U = [\\mathbf{v}_1, \\mathbf{v}_2, \\dots, \\mathbf{v}_N]$. The eigenvalues $\\lambda'_i$ are the occupation numbers. Crucially, for a consistent definition of the NO basis for truncation, the occupation numbers must be sorted in descending order, $\\lambda'_1 \\ge \\lambda'_2 \\ge \\dots \\ge \\lambda'_N$, and the columns of $U$ (the natural orbitals) must be ordered accordingly. The eigenvalues $\\{\\lambda'_i\\}$ of the constructed matrix $\\rho$ will be the same as the initial $\\{\\lambda_i\\}$ used to form $\\Lambda$, but their association with the basis states is now determined by the diagonalization.\n\n### Step 4: Basis Compression\nThe utility of the NO basis lies in its efficiency for approximation. The occupation numbers $\\lambda'_i$ represent the importance of each natural orbital in the many-body state. Orbitals with large occupation numbers are a priority to include in a calculation. We compress the basis space by retaining only the $K$ most significant orbitals. The dimension $K$ is determined by finding the smallest integer such that the cumulative occupation fraction meets a specified threshold $\\tau \\in (0, 1]$:\n$$\n\\frac{\\sum_{i=1}^K \\lambda'_i}{\\sum_{i=1}^N \\lambda'_i} \\ge \\tau\n$$\nThe total occupation, $\\sum_{i=1}^N \\lambda'_i = \\mathrm{Tr}(\\rho)$, is the number of particles in the system if the basis states are normalized as such. The compression ratio is then simply $K/N$.\n\n### Step 5: Hamiltonian Transformation and Truncation\nThe Hamiltonian $H$, originally expressed in the HO basis, is transformed into the NO basis via a unitary similarity transformation:\n$$\nH' = U^\\dagger H U\n$$\nSince our $U$ is real and orthogonal, this is $H' = U^\\top H U$. This transformation preserves a_l_l properties of the Hamiltonian, such as its eigenvalues. The matrix $H'$ represents the same operator as $H$, but written in the new basis.\nThe final step is to apply the basis compression to the Hamiltonian. This is done by taking the top-left $K \\times K$ principal submatrix of $H'$, denoted $H'_K$. This operation corresponds to projecting the Hamiltonian onto the subspace spanned by the $K$ most significant natural orbitals.\n\n### Step 6: Quantifying Off-Diagonality\nA key goal of this transformation is often to make the Hamiltonian \"more diagonal,\" which simplifies subsequent calculations. We quantify the diagonality of any matrix $M$ using the off-diagonal fraction, $f_{\\mathrm{off}}(M)$, defined using the Frobenius norm, $\\|M\\|_F = \\sqrt{\\sum_{i,j} |M_{ij}|^2}$:\n$$\nf_{\\mathrm{off}}(M) = \\frac{\\left\\| M - \\mathrm{diag}(\\mathrm{diag}(M)) \\right\\|_F}{\\| M \\|_F}\n$$\nThe numerator is the Frobenius norm of the matrix with its diagonal elements set to zero. This can be computed more efficiently as $\\sqrt{\\|M\\|_F^2 - \\|\\mathrm{diag}(M)\\|_F^2}$. A value of $f_{\\mathrm{off}}(M)=0$ implies $M$ is diagonal, while a value approaching $1$ implies the matrix elements are concentrated on the off-diagonal. We compute this quantity for the initial Hamiltonian $H$ and the final truncated Hamiltonian $H'_K$ to assess the effect of the NO transformation and truncation. The change is measured by $\\Delta = f_{\\mathrm{off}}(H'_K) - f_{\\mathrm{off}}(H)$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        {\n            \"N\": 4,\n            \"lambdas\": [1.5, 0.8, 0.4, 0.3],\n            \"givens\": [(1, 2, 0.3), (3, 4, -0.5), (1, 3, 0.25), (2, 4, -0.35)],\n            \"ham_params\": {\"a\": 0.7, \"b\": 0.5, \"t1\": 0.25, \"t2\": 0.08},\n            \"tau\": 0.9,\n        },\n        # Test case 2\n        {\n            \"N\": 4,\n            \"lambdas\": [2.0, 2.0, 0.5, 0.5],\n            \"givens\": [(1, 4, 0.4), (2, 3, -0.6), (1, 2, 0.2)],\n            \"ham_params\": {\"a\": 0.5, \"b\": 1.0, \"t1\": 0.3, \"t2\": 0.0},\n            \"tau\": 1.0,\n        },\n        # Test case 3\n        {\n            \"N\": 5,\n            \"lambdas\": [1.2, 0.9, 0.6, 0.2, 0.1],\n            \"givens\": [(1, 2, -0.2), (3, 4, 0.5), (4, 5, -0.3), (2, 5, 0.4)],\n            \"ham_params\": {\"a\": 0.4, \"b\": 0.7, \"t1\": 0.2, \"t2\": 0.05},\n            \"tau\": 0.5,\n        },\n    ]\n\n    all_results = []\n    for case in test_cases:\n        result = _solve_case(\n            case[\"N\"],\n            case[\"lambdas\"],\n            case[\"givens\"],\n            case[\"ham_params\"],\n            case[\"tau\"],\n        )\n        all_results.append(result)\n\n    # Format the final output string exactly as required.\n    results_str_list = []\n    for res in all_results:\n        # Format each list of floats into a string \"[f1,f2,f3,f4]\"\n        # Using a sufficient number of decimal places for precision.\n        formatted_res = \",\".join([f\"{val:.12f}\" for val in res])\n        results_str_list.append(f\"[{formatted_res}]\")\n    \n    final_output = f\"[{','.join(results_str_list)}]\"\n    print(final_output)\n\ndef _calc_off_diagonal_fraction(M):\n    \"\"\"\n    Computes the off-diagonal fraction of a matrix M.\n    f_off(M) = ||M - diag(diag(M))||_F / ||M||_F\n    \"\"\"\n    if M.size == 0:\n        return 0.0\n    \n    norm_M_sq = np.sum(M**2)\n    if norm_M_sq == 0:\n        return 0.0\n\n    diag_M = np.diag(M)\n    norm_diag_M_sq = np.sum(diag_M**2)\n    \n    norm_offdiag_M = np.sqrt(max(0, norm_M_sq - norm_diag_M_sq))\n    \n    return norm_offdiag_M / np.sqrt(norm_M_sq)\n\ndef _solve_case(N, lambdas_diag, givens_rotations, ham_params, tau):\n    \"\"\"\n    Performs all computational tasks for a single test case.\n    \"\"\"\n    # Step 1: Construct the Hamiltonian H\n    a, b, t1, t2 = ham_params[\"a\"], ham_params[\"b\"], ham_params[\"t1\"], ham_params[\"t2\"]\n    H = np.zeros((N, N))\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                H[i, j] = b + a * i\n            elif abs(i - j) == 1:\n                H[i, j] = t1\n            elif abs(i - j) == 2:\n                H[i, j] = t2\n    \n    # Step 2: Construct the orthogonal matrix Q from Givens rotations\n    Q = np.identity(N)\n    for p, q, theta in givens_rotations:\n        p_idx, q_idx = p - 1, q - 1 # Convert 1-based to 0-based index\n        G = np.identity(N)\n        c, s = np.cos(theta), np.sin(theta)\n        G[p_idx, p_idx] = c\n        G[p_idx, q_idx] = s\n        G[q_idx, p_idx] = -s\n        G[q_idx, q_idx] = c\n        Q = G @ Q\n\n    # Step 3: Construct the one-body density matrix rho\n    Lambda = np.diag(lambdas_diag)\n    rho = Q @ Lambda @ Q.T\n\n    # Step 4: Diagonalize rho to get the natural orbital basis U\n    # np.linalg.eigh returns eigenvalues in ascending order.\n    evals, evecs = np.linalg.eigh(rho)\n    # Sort eigenvalues in descending order and reorder eigenvectors accordingly\n    sort_indices = np.argsort(evals)[::-1]\n    sorted_evals = evals[sort_indices]\n    U = evecs[:, sort_indices]\n\n    # Step 5: Determine the minimal truncation dimension K\n    total_occupation = np.sum(sorted_evals)\n    threshold_sum = tau * total_occupation\n    \n    # Handle the edge case of total_occupation being zero\n    if total_occupation == 0:\n        K = N\n    # Handle threshold tau requiring all states.\n    # Floating point comparison needs a tolerance.\n    elif np.isclose(tau, 1.0):\n        K = N\n    else:\n        cumulative_occupation = 0.0\n        K = 0\n        for i in range(N):\n            cumulative_occupation += sorted_evals[i]\n            if cumulative_occupation >= threshold_sum:\n                K = i + 1\n                break\n\n    # Step 6: Compute compression ratio\n    compression_ratio = K / N\n\n    # Step 7: Compute off-diagonal fractions\n    f_off_H = _calc_off_diagonal_fraction(H)\n\n    # Transform Hamiltonian to NO basis\n    H_prime = U.T @ H @ U\n    \n    # Truncate to KxK\n    H_prime_K = H_prime[:K, :K]\n\n    f_off_H_prime_K = _calc_off_diagonal_fraction(H_prime_K)\n    \n    # Step 8: Compute change in off-diagonal fraction\n    delta = f_off_H_prime_K - f_off_H\n    \n    return [compression_ratio, f_off_H, f_off_H_prime_K, delta]\n\nsolve()\n```", "id": "3563403"}]}