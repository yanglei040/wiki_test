{"hands_on_practices": [{"introduction": "Before solving the many-body Schrödinger equation, one must first construct the Hilbert space in which the problem is defined. This foundational exercise ([@problem_id:3597504]) provides direct practice in this crucial first step by building a two-particle basis from the single-particle states of the Berggren ensemble. By calculating the dimension of the M-scheme basis, you will develop a concrete understanding of how bound states, resonances, and the discretized continuum contribute to the overall size and complexity of a Gamow Shell Model calculation.", "problem": "Consider the Continuum Shell Model (CSM), also known as the Gamow Shell Model (GSM), for a system of $2$ valence neutrons outside an inert core. Assume a spherically symmetric mean field so that single-particle states are labeled by orbital angular momentum $l$, total angular momentum $j$, and its projection $m$. The single-particle basis is constructed in the Berggren ensemble up to a single-particle energy cutoff $E_{\\max}$ that includes all pole states (bound or resonant) below $E_{\\max}$ for the following partial waves: $s_{1/2}$, $p_{1/2}$, $p_{3/2}$, $d_{3/2}$, and $d_{5/2}$. Specifically, within this cutoff there are $1$ $s_{1/2}$ bound pole, $1$ $d_{5/2}$ bound pole, and $1$ $p_{3/2}$ resonant pole; there are no other poles below $E_{\\max}$ in the listed channels. The non-resonant scattering continuum for each listed partial wave is discretized along a contour into exactly $N_c$ radial scattering states, identical for each partial wave. Each radial state in a $(l,j)$ channel carries its full magnetic degeneracy $(2j+1)$.\n\nIgnore center-of-mass considerations and any restriction on total angular momentum or parity of the two-neutron system. Construct the many-body $M$-scheme basis of antisymmetrized Slater determinants for the $2$ neutrons using all single-particle states in the space described above. Starting from the Pauli exclusion principle and elementary counting of single-particle magnetic substates, derive a closed-form expression for the total basis dimension $D(N_c)$ as a function of $N_c$. Your final answer must be a single analytic expression. Do not perform any numerical approximation or rounding; no units are required.", "solution": "The problem requires the derivation of a closed-form expression for the total dimension of the two-neutron many-body M-scheme basis, given a specific single-particle space defined within the Continuum Shell Model framework.\n\nThe validation of the problem statement is the mandatory first step.\n\n### Step 1: Extract Givens\n- System: $2$ valence neutrons outside an inert core.\n- Model: Continuum Shell Model (CSM) / Gamow Shell Model (GSM).\n- Mean field: Spherically symmetric.\n- Single-particle states are labeled by $(l, j, m)$.\n- Single-particle basis: Berggren ensemble up to energy cutoff $E_{\\max}$.\n- Included partial waves: $s_{1/2}$, $p_{1/2}$, $p_{3/2}$, $d_{3/2}$, and $d_{5/2}$.\n- Pole states below $E_{\\max}$:\n  - $1$ $s_{1/2}$ bound pole.\n  - $1$ $d_{5/2}$ bound pole.\n  - $1$ $p_{3/2}$ resonant pole.\n- Non-resonant continuum states:\n  - Discretized into exactly $N_c$ radial scattering states for each listed partial wave.\n- Degeneracy: Each radial state in an $(l,j)$ channel has a magnetic degeneracy of $(2j+1)$.\n- Many-body basis: Antisymmetrized Slater determinants (M-scheme) for $2$ neutrons.\n- Constraints to ignore: Center-of-mass considerations, restrictions on total angular momentum, and restrictions on parity.\n- Objective: Derive a closed-form expression for the total basis dimension, $D(N_c)$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is assessed based on the established criteria.\n- **Scientifically Grounded**: The problem is set within the standard theoretical framework of the Continuum Shell Model (or Gamow Shell Model), a well-established method in computational nuclear physics for describing weakly bound and unbound nuclei. The concepts of the Berggren ensemble, single-particle states, pole states (bound and resonant), discretized continuum, M-scheme basis, and Slater determinants are all fundamental and scientifically sound.\n- **Well-Posed**: The problem is clearly defined. It specifies the number of particles ($2$ neutrons), the complete single-particle space from which the many-body basis is built, and the method of constructing the basis (M-scheme). The objective is to find the total dimensionality, a uniquely defined quantity. All necessary information is provided.\n- **Objective**: The problem is stated using precise, technical language common to the field of nuclear physics. There are no subjective or ambiguous terms.\n\nThe problem does not exhibit any flaws such as scientific unsoundness, incompleteness, contradiction, or ambiguity. It represents a standard, albeit simplified, combinatorial problem in nuclear structure theory.\n\n### Step 3: Verdict and Action\nThe problem is valid. A reasoned solution will be provided.\n\nThe problem asks for the total dimension of the M-scheme basis for a system of $N=2$ identical fermions (neutrons). The many-body basis is constructed from a set of single-particle states spanning a specific model space. In the M-scheme, a basis state is a Slater determinant formed by occupying a unique set of single-particle states. The total number of such states, which is the dimension of the many-body space, is given by the number of ways to choose $N$ distinct single-particle states from the total number of available single-particle states, $N_{sp}$.\n\nThis is a classic combinatorial problem, and the dimension, $D$, is given by the binomial coefficient:\n$$\nD = \\binom{N_{sp}}{N}\n$$\nGiven that we have $N=2$ neutrons, the dimension is:\n$$\nD(N_c) = \\binom{N_{sp}}{2} = \\frac{N_{sp}(N_{sp}-1)}{2}\n$$\nThe central task is to determine the total number of single-particle states, $N_{sp}$, as a function of $N_c$. The single-particle space is composed of pole states and discretized continuum states. Each state is characterized by its quantum numbers, including the magnetic projection quantum number $m$, which can take $2j+1$ values for a state with total angular momentum $j$.\n\nFirst, we calculate the number of magnetic substates contributed by the pole states.\n- $1$ $s_{1/2}$ bound pole: For this state, $j=1/2$. The number of magnetic substates is $2j+1 = 2(1/2) + 1 = 2$.\n- $1$ $d_{5/2}$ bound pole: For this state, $j=5/2$. The number of magnetic substates is $2j+1 = 2(5/2) + 1 = 6$.\n- $1$ $p_{3/2}$ resonant pole: For this state, $j=3/2$. The number of magnetic substates is $2j+1 = 2(3/2) + 1 = 4$.\n\nThe total number of single-particle states from poles, $N_{\\text{poles}}$, is the sum of these degeneracies:\n$$\nN_{\\text{poles}} = 2 + 6 + 4 = 12\n$$\nNext, we calculate the number of magnetic substates contributed by the discretized non-resonant continuum. The problem states there are $N_c$ radial scattering states for each of the specified partial waves. We must sum the contributions over all these partial waves.\n- $s_{1/2}$ continuum: $j=1/2$, so the degeneracy per radial state is $2j+1=2$. Total states: $N_c \\times 2 = 2N_c$.\n- $p_{1/2}$ continuum: $j=1/2$, so the degeneracy per radial state is $2j+1=2$. Total states: $N_c \\times 2 = 2N_c$.\n- $p_{3/2}$ continuum: $j=3/2$, so the degeneracy per radial state is $2j+1=4$. Total states: $N_c \\times 4 = 4N_c$.\n- $d_{3/2}$ continuum: $j=3/2$, so the degeneracy per radial state is $2j+1=4$. Total states: $N_c \\times 4 = 4N_c$.\n- $d_{5/2}$ continuum: $j=5/2$, so the degeneracy per radial state is $2j+1=6$. Total states: $N_c \\times 6 = 6N_c$.\n\nThe total number of single-particle states from the continuum, $N_{\\text{cont}}$, is the sum of these contributions:\n$$\nN_{\\text{cont}} = 2N_c + 2N_c + 4N_c + 4N_c + 6N_c = (2+2+4+4+6)N_c = 18N_c\n$$\nThe total number of single-particle states, $N_{sp}$, is the sum of the pole and continuum contributions:\n$$\nN_{sp} = N_{\\text{poles}} + N_{\\text{cont}} = 12 + 18N_c\n$$\nNow we can substitute this expression for $N_{sp}$ into the formula for the two-particle dimension $D(N_c)$:\n$$\nD(N_c) = \\frac{N_{sp}(N_{sp}-1)}{2} = \\frac{(12 + 18N_c)((12 + 18N_c) - 1)}{2}\n$$\n$$\nD(N_c) = \\frac{(12 + 18N_c)(11 + 18N_c)}{2}\n$$\nWe can factor out a $2$ from the first term in the numerator:\n$$\nD(N_c) = \\frac{2(6 + 9N_c)(11 + 18N_c)}{2} = (6 + 9N_c)(11 + 18N_c)\n$$\nExpanding this product yields the final polynomial expression for the dimension:\n$$\nD(N_c) = 6 \\cdot 11 + 6 \\cdot (18N_c) + (9N_c) \\cdot 11 + (9N_c) \\cdot (18N_c)\n$$\n$$\nD(N_c) = 66 + 108N_c + 99N_c + 162N_c^2\n$$\nCombining like terms and ordering by powers of $N_c$, we arrive at the closed-form expression:\n$$\nD(N_c) = 162N_c^2 + 207N_c + 66\n$$\nThis expression represents the total number of two-neutron Slater determinants that can be constructed from the given single-particle Berggren basis, as a function of the number of discretized continuum states, $N_c$, per partial wave.", "answer": "$$\n\\boxed{162N_c^2 + 207N_c + 66}\n$$", "id": "3597504"}, {"introduction": "The theoretical power of the Berggren basis is realized through robust numerical implementation. This hands-on coding practice ([@problem_id:3597500]) bridges the gap between formalism and application by guiding you through the core numerical technique of the Continuum Shell Model. You will solve the single-particle Schrödinger equation by discretizing the continuum along a complex momentum contour, a method that is essential for treating resonant states and exploring the stability of the solutions with respect to the discretization parameters.", "problem": "Consider a one-body Hamiltonian within the continuum shell model framework, formulated in momentum representation under the unit convention $\\hbar^2/(2\\mu) = 1$ for a single partial wave (s-wave). The kinetic energy operator is $T$ with eigenvalues $k^2$, and the interaction is a rank-one separable potential $V(k,k') = -\\lambda\\, g(k)\\, g(k')$ with $g(k) = \\frac{1}{k^2 + \\beta^2}$, where $\\lambda > 0$ and $\\beta > 0$ are fixed parameters. In the Gamow Shell Model (GSM), the continuum is treated via the Berggren ensemble, where the scattering states are integrated along a complex-momentum contour $L^+$ in the complex $k$-plane.\n\nA bound state solution with energy $E < 0$ can be constructed by solving the homogeneous momentum-space Schrödinger equation. Assuming a separable ansatz compatible with the potential structure and using the s-wave Berggren metric (the complex symmetric, or c-product, with no complex conjugation), the bound-state energy condition reduces to a self-consistency equation for the decay constant $\\kappa > 0$ defined via $E = -\\kappa^2$. The consistency equation involves the contour integral\n$$\nJ(\\kappa) = \\int_{L^+} \\mathrm{d}k\\, \\frac{k^2}{\\left(k^2 + \\beta^2\\right)^2 \\left(\\kappa^2 + k^2\\right)}.\n$$\nA solution $\\kappa$ of $1 - \\lambda J(\\kappa) = 0$ yields a bound state with energy $E = -\\kappa^2$. The corresponding (unnormalized) momentum-space wavefunction is proportional to\n$$\n\\phi(k) \\propto \\frac{g(k)}{E - k^2} = -\\frac{1}{\\left(k^2 + \\beta^2\\right)\\left(\\kappa^2 + k^2\\right)}.\n$$\nIn the Berggren metric, the norm of this unnormalized state is\n$$\nS(\\kappa) = \\int_{L^+} \\mathrm{d}k\\, \\frac{k^2}{\\left(k^2 + \\beta^2\\right)^2 \\left(\\kappa^2 + k^2\\right)^2},\n$$\nwhich is a dimensionless quantity. Numerical evaluation proceeds by discretizing $L^+$ and approximating the integrals with quadrature.\n\nYour task is to write a complete, runnable program that:\n1. Constructs a two-segment Berggren contour $L^+$ in the complex momentum plane:\n   - Segment $1$: from $k = 0$ to $k = k_{\\mathrm{peak}}$ along the real axis.\n   - Segment $2$: from $k = k_{\\mathrm{peak}}$ to $k = k_{\\max}$ along a straight line rotated into the lower half-plane by an angle $\\theta$ (specified in degrees), that is $k = k_{\\mathrm{peak}} + (k_{\\max} - k_{\\mathrm{peak}}) e^{-i\\theta}$ at the end of the segment.\n2. Discretizes each segment with Gauss–Legendre quadrature and includes the Jacobian $\\mathrm{d}k/\\mathrm{d}s$ for the parameterization of each segment.\n3. For a given set of parameters, solves for $\\kappa$ using root finding on the real interval such that $1 - \\lambda J(\\kappa) = 0$, with $J(\\kappa)$ evaluated along $L^+$ using the discretization.\n4. Computes the bound state energy $E = -\\kappa^2$ and the unnormalized Berggren norm $S(\\kappa)$ using the same contour discretization.\n5. Produces the final output as a single line with the list of results for a specified test suite, where each result is a two-element list $[E, S]$ of floats.\n\nFundamental base to start from:\n- The momentum-space Schrödinger equation $(E - k^2) \\phi(k) = \\int \\mathrm{d}k' \\, k'^2 \\, V(k,k') \\, \\phi(k')$ with s-wave kinetic energy $k^2$.\n- The rank-one separable potential $V(k,k') = -\\lambda g(k) g(k')$ with $g(k) = \\frac{1}{k^2 + \\beta^2}$.\n- The Berggren ensemble completeness for s-wave with c-product, which legitimizes the complex contour $L^+$ integration for scattering contributions and Gamow states.\n\nAngle unit specification: the rotation angle $\\theta$ must be interpreted in degrees.\n\nUnits:\n- All momenta $k$, decay constants $\\kappa$, and parameters $\\beta$, $k_{\\mathrm{peak}}$, $k_{\\max}$ are in inverse length units consistent with $\\hbar^2/(2\\mu) = 1$.\n- Energies $E$ must be expressed in these same natural units, and the output should present energy values as floats.\n- The norm $S$ is dimensionless and should be presented as a float.\n\nTest Suite:\nUse the following fixed parameters for the interaction and contour shape across all tests:\n- $\\lambda = 10.0$ (dimensionless coupling strength).\n- $\\beta = 1.0$ (inverse length).\n- $k_{\\mathrm{peak}} = 2.0$ (inverse length).\n- $\\theta = 30$ (degrees).\n\nVary the discretization density and $k_{\\max}$ to demonstrate convergence:\n- Test Case A: $N = 40$ total quadrature points, $k_{\\max} = 4.0$.\n- Test Case B: $N = 80$ total quadrature points, $k_{\\max} = 8.0$.\n- Test Case C: $N = 160$ total quadrature points, $k_{\\max} = 12.0$.\n- Test Case D: $N = 160$ total quadrature points, $k_{\\max} = 8.0$.\n- Test Case E: $N = 80$ total quadrature points, $k_{\\max} = 12.0$.\n\nAlgorithmic Requirements:\n- The Gauss–Legendre nodes $s_i \\in [-1,1]$ and weights $w_i$ must be mapped to each contour segment with $k(s) = \\frac{z_1 + z_0}{2} + \\frac{z_1 - z_0}{2} s$ and the complex Jacobian $\\frac{\\mathrm{d}k}{\\mathrm{d}s} = \\frac{z_1 - z_0}{2}$, where $z_0$ and $z_1$ are the complex endpoints of the segment.\n- The integral over $L^+$ is approximated by the sum $\\sum_i w_i \\frac{\\mathrm{d}k}{\\mathrm{d}s} f(k(s_i))$ over all segments, preserving complex weights. To ensure real-valued energy solutions, take the real part of the computed integrals when forming $J(\\kappa)$ and $S(\\kappa)$ due to small numerical imaginary components from discretization.\n\nFinal Output:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with one entry per test case and each entry itself a two-element list $[E, S]$. For example:\n\"[[E_A,S_A],[E_B,S_B],[E_C,S_C],[E_D,S_D],[E_E,S_E]]\"\nwhere each $E$ is the computed bound state energy in natural units and each $S$ is the dimensionless unnormalized Berggren norm.\n\nThe program must be self-contained and must not read any input; it must use the parameters provided above, compute the results for the five test cases, and print the final list exactly in the specified format.", "solution": "We begin with the momentum-space Schrödinger equation for a single s-wave partial component in units where $\\hbar^2/(2\\mu) = 1$:\n$$\n(E - k^2) \\phi(k) = \\int_0^\\infty \\mathrm{d}k'\\, k'^2 \\, V(k,k') \\, \\phi(k').\n$$\nWe use a rank-one separable potential $V(k,k') = -\\lambda g(k) g(k')$ with $g(k) = \\frac{1}{k^2 + \\beta^2}$, where $\\lambda>0$ and $\\beta>0$ are fixed parameters. For a bound state $E<0$, adopting the separable ansatz compatible with the potential,\n$$\n\\phi(k) = A \\frac{g(k)}{E - k^2},\n$$\nand substituting into the homogeneous equation yields\n$$\nA = -\\lambda A \\int_0^\\infty \\mathrm{d}k' \\, k'^2 \\, \\frac{g^2(k')}{E - k'^2}.\n$$\nAssuming $A \\neq 0$, the energy condition is\n$$\n1 = -\\lambda \\int_0^\\infty \\mathrm{d}k'\\, k'^2 \\frac{g^2(k')}{E - k'^2}.\n$$\nFor a bound state, let $E = -\\kappa^2$ with $\\kappa>0$. Then $E - k'^2 = -(\\kappa^2 + k'^2)$ and the integral becomes\n$$\n\\int_0^\\infty \\mathrm{d}k' \\, k'^2 \\frac{g^2(k')}{E - k'^2} = -\\int_0^\\infty \\mathrm{d}k' \\, \\frac{k'^2}{(k'^2 + \\beta^2)^2 (\\kappa^2 + k'^2)}.\n$$\nHence, the bound-state condition is\n$$\n1 = \\lambda \\int_0^\\infty \\mathrm{d}k \\, \\frac{k^2}{(k^2 + \\beta^2)^2 (\\kappa^2 + k^2)} \\equiv \\lambda J(\\kappa),\n$$\nwhere we defined\n$$\nJ(\\kappa) = \\int_0^\\infty \\mathrm{d}k \\, \\frac{k^2}{(k^2 + \\beta^2)^2 (\\kappa^2 + k^2)}.\n$$\nIn the Gamow Shell Model (GSM), scattering states and Gamow states are treated using the Berggren ensemble, replacing the real axis integration by a contour $L^+$ in the complex $k$-plane that includes a segment on the real axis up to $k_{\\mathrm{peak}}$ and then a rotated straight segment into the complex plane ending at $k_{\\mathrm{peak}} + (k_{\\max} - k_{\\mathrm{peak}}) e^{-i\\theta}$ with $\\theta>0$. The c-product (complex symmetric inner product) is used, so no complex conjugation is applied in integrals for norms or matrix elements. Under conditions of analyticity and decay, the integral along $L^+$ equals the original real-axis integral, but numerically we discretize $L^+$ to approximate these quantities:\n$$\nJ(\\kappa) \\approx \\sum_{i} w_i \\frac{\\mathrm{d}k}{\\mathrm{d}s}\\Big|_{s=s_i} \\frac{k(s_i)^2}{\\left(k(s_i)^2 + \\beta^2\\right)^2 \\left(\\kappa^2 + k(s_i)^2\\right)},\n$$\nwhere each segment is parameterized by $k(s) = \\frac{z_1 + z_0}{2} + \\frac{z_1 - z_0}{2} s$ with $s \\in [-1,1]$, endpoints $z_0$ and $z_1$, and Gauss–Legendre nodes $s_i$ and weights $w_i$. The Jacobian factor $\\frac{\\mathrm{d}k}{\\mathrm{d}s} = \\frac{z_1 - z_0}{2}$ is complex for the rotated segment. Although the exact integral is real for $\\kappa>0$, discretization along a complex contour can introduce a small imaginary part; taking the real part of the quadrature sum yields a real-valued approximation suitable for root finding:\n$$\n\\operatorname{Re}\\, J(\\kappa) \\approx \\operatorname{Re}\\left( \\sum_{i} w_i \\frac{\\mathrm{d}k}{\\mathrm{d}s}\\Big|_{s=s_i} \\frac{k(s_i)^2}{\\left(k(s_i)^2 + \\beta^2\\right)^2 \\left(\\kappa^2 + k(s_i)^2\\right)} \\right).\n$$\nWe find $\\kappa$ by solving the scalar nonlinear equation\n$$\nf(\\kappa) \\equiv 1 - \\lambda\\, \\operatorname{Re}\\, J(\\kappa) = 0,\n$$\non a bracket such as $\\kappa \\in [\\kappa_{\\min}, \\kappa_{\\max}]$ with $\\kappa_{\\min} \\ll 1$ and $\\kappa_{\\max}$ sufficiently large (e.g., of order $k_{\\max}$). The integrand behaves well at $k=0$ and decays as $k^{-4}$ for large $k$, ensuring convergence.\n\nOnce $\\kappa$ is obtained, the bound state energy is $E = -\\kappa^2$. To assess the convergence of the state normalization, we evaluate the unnormalized Berggren norm\n$$\nS(\\kappa) \\equiv \\int_{L^+} \\mathrm{d}k\\, \\frac{k^2}{\\left(k^2 + \\beta^2\\right)^2 \\left(\\kappa^2 + k^2\\right)^2} \\approx \\operatorname{Re}\\left( \\sum_{i} w_i \\frac{\\mathrm{d}k}{\\mathrm{d}s}\\Big|_{s=s_i} \\frac{k(s_i)^2}{\\left(k(s_i)^2 + \\beta^2\\right)^2 \\left(\\kappa^2 + k(s_i)^2\\right)^2} \\right),\n$$\nwhich is dimensionless. If the state were normalized by choosing a prefactor $A$ such that $\\int_{L^+} \\mathrm{d}k\\, k^2\\, \\phi(k)^2 = 1$ in the c-product, then $A = 1/\\sqrt{S(\\kappa)}$. However, here we report $S(\\kappa)$ directly to demonstrate numerical convergence behavior.\n\nAlgorithmic steps:\n1. Construct the contour $L^+$ with two segments:\n   - Segment $1$: $z_0^{(1)} = 0$, $z_1^{(1)} = k_{\\mathrm{peak}}$ (both real).\n   - Segment $2$: $z_0^{(2)} = k_{\\mathrm{peak}}$, $z_1^{(2)} = k_{\\mathrm{peak}} + (k_{\\max} - k_{\\mathrm{peak}}) e^{-i\\theta}$, with $\\theta$ in degrees converted to radians.\n2. For a requested total number of quadrature points $N$, split into $N_1 = \\lfloor N/2 \\rfloor$ on Segment $1$ and $N_2 = N - N_1$ on Segment $2$. For each segment, obtain Gauss–Legendre nodes and weights $\\{s_i,w_i\\}$ and map to complex momenta $k_i$ and complex weights $W_i = w_i\\, \\frac{z_1 - z_0}{2}$.\n3. Define the functions $J(\\kappa)$ and $S(\\kappa)$ as complex-weighted sums of the respective integrands, and take their real parts.\n4. Use a robust bracketed root-finding method on $f(\\kappa) = 1 - \\lambda \\operatorname{Re} J(\\kappa)$ with a bracket such as $[\\kappa_{\\min}, \\kappa_{\\max}] = [10^{-6}, k_{\\max}]$; ensure $f(\\kappa_{\\min}) < 0$ and $f(\\kappa_{\\max}) > 0$ for attractive potentials with sufficiently large $\\lambda$ (as in the provided test parameters).\n5. Compute $E = -\\kappa^2$, and evaluate $S(\\kappa)$.\n6. Repeat steps 2–5 for each test case with different $N$ and $k_{\\max}$ to demonstrate convergence of $E$ and $S$ as discretization density and $k_{\\max}$ are varied.\n\nAnalytic reference:\nFor the chosen separable form, the integral $J(\\kappa)$ along the real axis has a closed-form expression via partial fractions:\n$$\nJ(\\kappa) = \\int_0^\\infty \\mathrm{d}k \\, \\frac{k^2}{(k^2 + \\beta^2)^2 (\\kappa^2 + k^2)}\n= \\frac{\\pi}{2\\beta} \\frac{\\kappa^2}{(\\kappa^2 - \\beta^2)^2} - \\frac{\\pi}{4\\beta} \\frac{1}{\\kappa^2 - \\beta^2} - \\frac{\\pi}{2} \\frac{\\kappa}{(\\kappa^2 - \\beta^2)^2},\n$$\nwhich can be used to validate the numerical solution by solving $1 = \\lambda J(\\kappa)$ on the real axis. In practice, the complex-contour discretization used here reproduces this result as the number of points and $k_{\\max}$ increase.\n\nOutput:\nFor each test case A–E, the program outputs the pair $[E,S]$ where $E$ is the bound-state energy in natural units and $S$ is the dimensionless unnormalized Berggren norm. The final output is a single line:\n\"[[E_A,S_A],[E_B,S_B],[E_C,S_C],[E_D,S_D],[E_E,S_E]]\".\n\nThis design integrates the foundational Schrödinger equation with the Berggren ensemble discretization to demonstrate convergence behavior in the continuum shell model framework.", "answer": "```python\n# Python 3.12\n# Libraries: numpy 1.23.5, scipy 1.11.4\nimport numpy as np\nfrom numpy.polynomial.legendre import leggauss\nfrom scipy.optimize import root_scalar\n\ndef build_contour(k_peak, k_max, theta_deg, N_total):\n    \"\"\"\n    Construct L^+ with two segments:\n      Segment 1: 0 -> k_peak (real axis)\n      Segment 2: k_peak -> k_peak + (k_max - k_peak) * exp(-i * theta)\n    Returns arrays of complex k points and complex quadrature weights W_i.\n    \"\"\"\n    # Convert angle to radians\n    theta = np.deg2rad(theta_deg)\n\n    # Segment endpoints\n    z0_1 = 0.0 + 0.0j\n    z1_1 = complex(k_peak, 0.0)\n    z0_2 = complex(k_peak, 0.0)\n    z1_2 = complex(k_peak, 0.0) + (k_max - k_peak) * np.exp(-1j * theta)\n\n    # Split total points between segments\n    N1 = N_total // 2\n    N2 = N_total - N1\n    if N1 < 2:  # minimal points per segment to avoid pathological quadrature\n        N1 = 2\n        N2 = max(2, N_total - N1)\n\n    # Gauss-Legendre nodes and weights on [-1,1]\n    s1, w1 = leggauss(N1)\n    s2, w2 = leggauss(N2)\n\n    # Map nodes to segment 1\n    dkds_1 = (z1_1 - z0_1) / 2.0\n    k1 = (z1_1 + z0_1) / 2.0 + dkds_1 * s1\n    W1 = w1 * dkds_1\n\n    # Map nodes to segment 2\n    dkds_2 = (z1_2 - z0_2) / 2.0\n    k2 = (z1_2 + z0_2) / 2.0 + dkds_2 * s2\n    W2 = w2 * dkds_2\n\n    # Concatenate\n    k_points = np.concatenate([k1, k2])\n    weights = np.concatenate([W1, W2])\n\n    return k_points, weights\n\ndef J_discrete(kappa, beta, k_points, weights):\n    \"\"\"\n    Compute J(kappa) = ∫_{L+} dk k^2/[(k^2+beta^2)^2 (kappa^2 + k^2)]\n    using complex quadrature along L^+.\n    Returns the real part of the quadrature sum to mitigate small numerical Im parts.\n    \"\"\"\n    k = k_points\n    W = weights\n    k2 = k * k\n    denom1 = (k2 + beta**2)\n    integrand = (k2) / (denom1 * denom1 * (kappa**2 + k2))\n    val = np.sum(W * integrand)\n    return float(np.real(val))\n\ndef S_discrete(kappa, beta, k_points, weights):\n    \"\"\"\n    Compute S(kappa) = ∫_{L+} dk k^2/[(k^2+beta^2)^2 (kappa^2 + k^2)^2]\n    using complex quadrature along L^+.\n    Returns the real part of the quadrature sum.\n    \"\"\"\n    k = k_points\n    W = weights\n    k2 = k * k\n    denom1 = (k2 + beta**2)\n    integrand = (k2) / (denom1 * denom1 * (kappa**2 + k2) * (kappa**2 + k2))\n    val = np.sum(W * integrand)\n    return float(np.real(val))\n\ndef solve_case(N_total, k_max, lambda_cpl, beta, k_peak, theta_deg):\n    \"\"\"\n    For given discretization and contour parameters, solve for kappa via\n    1 - lambda * J(kappa) = 0, then compute energy E = -kappa^2 and norm S(kappa).\n    \"\"\"\n    # Build contour points and weights\n    k_points, weights = build_contour(k_peak, k_max, theta_deg, N_total)\n\n    # Define objective function f(kappa) = 1 - lambda * J(kappa)\n    def f(kappa):\n        return 1.0 - lambda_cpl * J_discrete(kappa, beta, k_points, weights)\n\n    # Choose a bracket [kappa_min, kappa_max] with f(kappa_min) < 0 and f(kappa_max) > 0\n    # For attractive potential and sufficient strength, this holds with small kappa_min and larger kappa_max.\n    kappa_min = 1e-6\n    kappa_max_bracket = max(2.0 * beta, k_max)  # ensure upper bound reasonably large\n    # Ensure bracket signs; if not, expand kappa_max_bracket multiplicatively\n    fmin = f(kappa_min)\n    fmax = f(kappa_max_bracket)\n    expand_factor = 2.0\n    attempts = 0\n    while fmin >= 0.0 and attempts < 10:\n        # If f(kappa_min) is not negative, reduce it further\n        kappa_min *= 0.1\n        fmin = f(kappa_min)\n        attempts += 1\n    attempts = 0\n    while fmax <= 0.0 and attempts < 10:\n        kappa_max_bracket *= expand_factor\n        fmax = f(kappa_max_bracket)\n        attempts += 1\n\n    # Root finding\n    root = root_scalar(f, bracket=[kappa_min, kappa_max_bracket], method='brentq')\n    if not root.converged:\n        # Fallback: try different bracket if needed\n        kappa_guess = beta\n        root = root_scalar(f, x0=kappa_guess, x1=kappa_guess*1.5, method='secant')\n\n    kappa = float(root.root)\n    E = -kappa**2\n\n    # Compute unnormalized Berggren norm S(kappa)\n    S_val = S_discrete(kappa, beta, k_points, weights)\n\n    return E, S_val\n\ndef solve():\n    # Fixed interaction and contour parameters across test cases\n    lambda_cpl = 10.0\n    beta = 1.0\n    k_peak = 2.0\n    theta_deg = 30.0\n\n    # Test suite: (N_total, k_max)\n    test_cases = [\n        (40, 4.0),    # A: coarse N, small k_max\n        (80, 8.0),    # B: medium N, medium k_max\n        (160, 12.0),  # C: fine N, large k_max\n        (160, 8.0),   # D: fine N, medium k_max\n        (80, 12.0),   # E: medium N, large k_max\n    ]\n\n    results = []\n    for N_total, k_max in test_cases:\n        E, S_val = solve_case(N_total, k_max, lambda_cpl, beta, k_peak, theta_deg)\n        # Append as [E, S] floats\n        results.append([E, S_val])\n\n    # Print as a single line in the exact required format\n    # Ensure default float string representation\n    formatted = \"[\" + \",\".join(f\"[{r[0]},{r[1]}]\" for r in results) + \"]\"\n    print(formatted)\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3597500"}, {"introduction": "The non-Hermitian nature of the Gamow Shell Model Hamiltonian is not merely a mathematical curiosity; it is the key to describing the rich physics of open quantum systems. This applied modeling exercise ([@problem_id:3597518]) uses an intuitive two-level system to explore how the coupling between discrete configurations and the particle continuum generates observable phenomena. By analyzing the behavior of complex eigenvalues, you will gain insight into the formation of decay widths and the dynamics of avoided crossings, which are characteristic features of weakly bound and unbound nuclei near decay thresholds.", "problem": "You are asked to design and implement a complete, runnable program that models channel coupling and configuration mixing near particle emission thresholds in the continuum shell model using a two-level non-Hermitian toy model. The task emphasizes deriving why and how non-Hermiticity emerges from coupling to the particle continuum, how it generates avoided crossings in the complex-energy plane, and how to fit a simple model to synthetic complex-energy data representative of the Gamow Shell Model (GSM).\n\nStart from the Feshbach projection formalism, which yields an energy-dependent effective non-Hermitian Hamiltonian in the intrinsic (closed) space. The standard form is the following: \n$$\nH_{\\text{eff}}(E) \\equiv H_{PP} + V_{PQ} \\frac{1}{E^+ - H_{QQ}} V_{QP},\n$$\nwhere $H_{PP}$ acts in the intrinsic space, $H_{QQ}$ in the continuum (scattering) space, and $V_{PQ}$ couples the two. The imaginary part encodes irreversible decay into the continuum and is zero below the emission threshold. Near a single-particle threshold, the dissipative width may be approximated by a linearized threshold law and the principal-value dispersive shift by a local linear slope, yielding the following two-level, energy-independent-in-the-window parametric model for a control parameter $\\lambda$:\n$$\nH(\\lambda) = \n\\begin{pmatrix}\nE_1 + \\Delta_1(\\lambda) - \\dfrac{i}{2}\\Gamma_1(\\lambda) & V_{12} \\\\\nV_{12} & E_2 + \\Delta_2(\\lambda) - \\dfrac{i}{2}\\Gamma_2(\\lambda)\n\\end{pmatrix},\n$$\nwith\n$$\n\\Gamma_i(\\lambda) = \\gamma_i \\max(\\lambda - \\lambda_{\\text{th},i}, 0), \\qquad \n\\Delta_i(\\lambda) = \\alpha_i \\left(\\lambda - \\lambda_{\\text{th},i}\\right),\n$$\nand a complex, $\\lambda$-independent off-diagonal coupling \n$$\nV_{12} \\equiv v_r + i v_i.\n$$\nAssume a complex-symmetric effective Hamiltonian so that $H_{12} = H_{21} = V_{12}$, which is a standard approximation for time-reversal-invariant open quantum systems. The observable eigenvalues are the complex poles $z_\\pm(\\lambda)$ of $H(\\lambda)$, written as $z \\equiv E - \\dfrac{i}{2}\\Gamma$, where $E$ is the energy in megaelectronvolts (MeV) and $\\Gamma$ is the decay width in megaelectronvolts (MeV). \n\nYour program must:\n- Implement the model above and compute the two complex eigenvalue branches as continuous functions of $\\lambda$ by following the branches to avoid mislabeling across avoided crossings in the complex plane. Continuity should be enforced by matching eigenvalues point-to-point along increasing $\\lambda$ to minimize the total complex distance between adjacent parameter points.\n- Generate synthetic \"GSM-like\" datasets by diagonalizing the model for specified \"true\" parameter sets and control-parameter meshes. There is no measurement noise.\n- Fit, for each dataset, only the complex off-diagonal coupling $V_{12} = v_r + i v_i$ by nonlinear least squares to minimize the sum of squared complex residuals between the model-predicted branches and the synthetic data branches. All other parameters are known and fixed. The complex residual at each $\\lambda$ point must be formed by stacking real and imaginary parts of both branches.\n- Report, for each dataset, the fitted magnitude $\\lvert V_{12} \\rvert = \\sqrt{v_r^2 + v_i^2}$ in megaelectronvolts (MeV) as a float. Express your final outputs in MeV.\n\nUse the following three datasets (each defines a complete test case). In all datasets, the control parameter $\\lambda$ is dimensionless, and all energies are in megaelectronvolts (MeV).\n\nDataset A (clear avoided crossing above one threshold):\n- Fixed parameters: \n  - $E_1 = 0.00$, $E_2 = 0.35$\n  - $\\lambda_{\\text{th},1} = 0.05$, $\\lambda_{\\text{th},2} = 0.25$\n  - $\\alpha_1 = 0.20$, $\\alpha_2 = 0.15$\n  - $\\gamma_1 = 0.40$, $\\gamma_2 = 0.70$\n- True coupling: \n  - $V_{12}^{(\\text{true})} = 0.045 - i\\,0.008$\n- Control mesh:\n  - $\\lambda \\in \\{-0.05, 0.00, 0.05, 0.10, 0.15, 0.20, 0.25, 0.30, 0.35, 0.40, 0.45\\}$\n\nDataset B (boundary case with vanishing mixing):\n- Fixed parameters: \n  - $E_1 = 0.10$, $E_2 = 0.30$\n  - $\\lambda_{\\text{th},1} = 0.05$, $\\lambda_{\\text{th},2} = 0.15$\n  - $\\alpha_1 = 0.10$, $\\alpha_2 = 0.10$\n  - $\\gamma_1 = 0.30$, $\\gamma_2 = 0.30$\n- True coupling: \n  - $V_{12}^{(\\text{true})} = 0.000 + i\\,0.000$\n- Control mesh:\n  - $\\lambda \\in \\{0.00, 0.05, 0.10, 0.15, 0.20, 0.25, 0.30, 0.35, 0.40\\}$\n\nDataset C (near-degeneracy near threshold with larger widths):\n- Fixed parameters: \n  - $E_1 = 0.12$, $E_2 = 0.14$\n  - $\\lambda_{\\text{th},1} = 0.11$, $\\lambda_{\\text{th},2} = 0.09$\n  - $\\alpha_1 = 0.25$, $\\alpha_2 = 0.20$\n  - $\\gamma_1 = 0.90$, $\\gamma_2 = 0.60$\n- True coupling:\n  - $V_{12}^{(\\text{true})} = 0.030 - i\\,0.020$\n- Control mesh:\n  - $\\lambda \\in \\{0.06, 0.08, 0.10, 0.12, 0.14, 0.16, 0.18, 0.20, 0.22\\}$\n\nNumerical and output requirements:\n- Angles are not involved. All energies must be treated and reported in megaelectronvolts (MeV).\n- Use a least-squares procedure appropriate for complex residuals by stacking real and imaginary parts.\n- Your program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Specifically, it must print \n  $[\\lvert V_{12}^{(A)}\\rvert,\\lvert V_{12}^{(B)}\\rvert,\\lvert V_{12}^{(C)}\\rvert]$ \n  with each value in MeV as a decimal float rounded to six decimal places, for example, \n  $[0.123456,0.000000,0.036789]$.\n\nTest suite and coverage rationale:\n- Dataset A is a general case with a visible avoided crossing in the complex plane as $\\lambda$ passes above one threshold, testing robust branch tracking and sensitivity to nonzero complex coupling.\n- Dataset B is a boundary condition with no mixing, ensuring the fitter correctly returns a coupling magnitude near zero.\n- Dataset C is an edge case with near-degenerate levels and stronger widths near threshold, testing stability of the fit and the ability to interpret complex avoided crossings dominated by continuum coupling.\n\nYour final program must be complete, self-contained, require no input, and must implement the model, data generation, fitting, and final reporting exactly as specified above. The only allowed external libraries are Numerical Python (NumPy) and Scientific Python (SciPy). The final output must be a single line containing the list described above, with values in MeV rounded to six decimal places.", "solution": "The problem posed is a valid exercise in computational nuclear physics, specifically addressing the modeling of open quantum systems near decay thresholds. It is scientifically grounded in the Feshbach projection formalism and the resulting non-Hermitian effective Hamiltonian, which are standard theoretical tools for describing resonant states and continuum coupling. The problem is well-posed, providing a complete set of parameters and a clear objective for implementation, data generation, and parameter fitting. It is objective, mathematically formalizable, and computationally feasible. Therefore, a full solution is warranted.\n\nThe theoretical foundation of this problem is the description of a discrete set of quantum states, the intrinsic or model space $P$, coupled to a continuum of scattering states, space $Q$. The effective Hamiltonian governing the dynamics within the $P$ space, after formally eliminating the $Q$ space, becomes non-Hermitian and energy-dependent. The general form is given by:\n$$\nH_{\\text{eff}}(E) = H_{PP} + V_{PQ} \\frac{1}{E^+ - H_{QQ}} V_{QP}\n$$\nHere, $H_{PP}$ is the Hamiltonian of the isolated intrinsic states, $H_{QQ}$ describes the continuum, and $V_{PQ}$ represents the coupling between the two spaces. The term $E^+ = E + i\\epsilon$ with $\\epsilon \\to 0^+$ ensures correct causal boundary conditions. The second term, the self-energy $\\Sigma(E) = V_{PQ} (E^+ - H_{QQ})^{-1} V_{QP}$, is complex. Its anti-Hermitian part, $-i\\text{Im}(\\Sigma(E))$, gives rise to decay widths, representing the irreversible loss of flux from the $P$ space to the $Q$ space.\n\nThe problem provides a simplified, energy-independent parametric model for this effective Hamiltonian, valid in a small energy window around a control parameter $\\lambda$. We consider a two-level system ($P$-space dimension is $2$), yielding a $2 \\times 2$ matrix:\n$$\nH(\\lambda) = \n\\begin{pmatrix}\nE_1 + \\Delta_1(\\lambda) - \\dfrac{i}{2}\\Gamma_1(\\lambda) & V_{12} \\\\\nV_{12} & E_2 + \\Delta_2(\\lambda) - \\dfrac{i}{2}\\Gamma_2(\\lambda)\n\\end{pmatrix}\n$$\nThe diagonal elements, $H_{ii}(\\lambda) = E_i + \\Delta_i(\\lambda) - \\frac{i}{2}\\Gamma_i(\\lambda)$, are the complex energies of the uncoupled \"diabatic\" states. $E_i$ are the base energies. The terms $\\Delta_i(\\lambda)$ and $\\Gamma_i(\\lambda)$ are the energy-dependent dispersive shift and decay width, respectively, arising from the self-energy. Their dependence on the control parameter $\\lambda$ is modeled linearly near the particle emission threshold $\\lambda_{\\text{th},i}$:\n$$\n\\Gamma_i(\\lambda) = \\gamma_i \\max(\\lambda - \\lambda_{\\text{th},i}, 0)\n$$\n$$\n\\Delta_i(\\lambda) = \\alpha_i \\left(\\lambda - \\lambda_{\\text{th},i}\\right)\n$$\nThe width $\\Gamma_i$ is non-zero only above the threshold ($\\lambda > \\lambda_{\\text{th},i}$), reflecting that decay is only possible when energetically allowed. The off-diagonal element $V_{12} = v_r + i v_i$ represents the effective coupling between the two states, which can itself be complex due to \"indirect\" coupling via the continuum. The assumption of a complex-symmetric matrix ($H_{12}=H_{21}$) is standard for systems with time-reversal invariance.\n\nThe physically observable quantities are the complex eigenvalues of $H(\\lambda)$, which correspond to the poles of the S-matrix. We denote them as $z(\\lambda) = E_{\\text{res}} - \\frac{i}{2}\\Gamma_{\\text{width}}$. The eigenvalues $z_\\pm$ of a general complex-symmetric $2 \\times 2$ matrix are given by the standard quadratic formula:\n$$\nz_\\pm(\\lambda) = \\frac{H_{11}(\\lambda) + H_{22}(\\lambda)}{2} \\pm \\frac{1}{2}\\sqrt{(H_{11}(\\lambda) - H_{22}(\\lambda))^2 + 4V_{12}^2}\n$$\nAs $\\lambda$ varies, these two eigenvalues trace out continuous branches in the complex energy plane. When the diabatic energies $H_{11}(\\lambda)$ and $H_{22}(\\lambda)$ approach each other, the eigenvalues exhibit an \"avoided crossing.\" The minimum separation between the branches at this point is determined by the coupling $V_{12}$.\n\nThe first part of the computational task is to calculate these eigenvalue branches for a given set of parameters and a mesh of $\\lambda$ values. A numerical diagonalization routine (like `numpy.linalg.eigvals`) at each $\\lambda$ point yields a pair of eigenvalues. However, their default ordering is arbitrary. To construct continuous branches, we must sort the eigenvalues at each step $\\lambda_k$ to match the ordering at the previous step $\\lambda_{k-1}$. This is achieved by minimizing the sum of the complex distances between the eigenvalues at consecutive steps. Given the branches $z_1(\\lambda_{k-1})$ and $z_2(\\lambda_{k-1})$, and the newly computed unordered eigenvalues $z'_a$ and $z'_b$ at $\\lambda_k$, we compare two possible assignments:\n1. $d_1 = |z_1(\\lambda_{k-1}) - z'_a| + |z_2(\\lambda_{k-1}) - z'_b|$\n2. $d_2 = |z_1(\\lambda_{k-1}) - z'_b| + |z_2(\\lambda_{k-1}) - z'_a|$\nIf $d_1 < d_2$, the assignment is $z_1(\\lambda_k)=z'_a$ and $z_2(\\lambda_k)=z'_b$. Otherwise, the assignment is swapped. This procedure ensures the correct tracking of states through any avoided crossings.\n\nThe second part of the task is to perform a parameter fit. We first generate a synthetic \"experimental\" dataset by computing the eigenvalue branches using a known \"true\" set of parameters, including a true coupling $V_{12}^{(\\text{true})}$. Then, assuming all parameters *except* for $V_{12}$ are known, we must determine $V_{12}$ by fitting our model to this synthetic data. The parameters to be determined are the real and imaginary parts of the coupling, $v_r$ and $v_i$.\n\nThis is a nonlinear least-squares problem. We define a residual function that quantifies the difference between the model predictions (for a trial set of parameters $p = [v_r, v_i]$) and the synthetic data. The model prediction for a trial $V_{12} = v_r+iv_i$ is a set of eigenvalue branches $\\{z_{1}^{\\text{model}}(\\lambda_j; p), z_{2}^{\\text{model}}(\\lambda_j; p)\\}$. The complex residuals are:\n$$\n\\delta_k(\\lambda_j; p) = z_{k}^{\\text{model}}(\\lambda_j; p) - z_{k}^{\\text{data}}(\\lambda_j), \\quad k \\in \\{1, 2\\}\n$$\nfor each point $\\lambda_j$ in the control mesh. For use with standard optimizers like `scipy.optimize.least_squares`, which operate on real-valued vectors, we construct a single residual vector by stacking the real and imaginary parts of all complex residuals:\n$$\n\\vec{R}(p) = [ \\dots, \\text{Re}(\\delta_1(\\lambda_j)), \\text{Im}(\\delta_1(\\lambda_j)), \\text{Re}(\\delta_2(\\lambda_j)), \\text{Im}(\\delta_2(\\lambda_j)), \\dots ]\n$$\nThe optimizer then finds the parameters $p = [v_r, v_i]$ that minimize the sum of squares of the elements of this vector, $\\sum_k R_k^2$, which is equivalent to minimizing the total squared complex error $\\sum_{j,k} |\\delta_k(\\lambda_j; p)|^2$. Once the optimal $v_r$ and $v_i$ are found, the required output is the magnitude $|V_{12}| = \\sqrt{v_r^2 + v_i^2}$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import least_squares\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all datasets.\n    \"\"\"\n\n    # Dataset A (clear avoided crossing above one threshold)\n    case_A = {\n        \"fixed_params\": {\n            \"E1\": 0.00, \"E2\": 0.35,\n            \"lambda_th1\": 0.05, \"lambda_th2\": 0.25,\n            \"alpha1\": 0.20, \"alpha2\": 0.15,\n            \"gamma1\": 0.40, \"gamma2\": 0.70,\n        },\n        \"true_V12\": 0.045 - 0.008j,\n        \"lambda_mesh\": np.array([-0.05, 0.00, 0.05, 0.10, 0.15, 0.20, 0.25, 0.30, 0.35, 0.40, 0.45]),\n    }\n\n    # Dataset B (boundary case with vanishing mixing)\n    case_B = {\n         \"fixed_params\": {\n            \"E1\": 0.10, \"E2\": 0.30,\n            \"lambda_th1\": 0.05, \"lambda_th2\": 0.15,\n            \"alpha1\": 0.10, \"alpha2\": 0.10,\n            \"gamma1\": 0.30, \"gamma2\": 0.30,\n        },\n        \"true_V12\": 0.000 + 0.000j,\n        \"lambda_mesh\": np.array([0.00, 0.05, 0.10, 0.15, 0.20, 0.25, 0.30, 0.35, 0.40]),\n    }\n\n    # Dataset C (near-degeneracy near threshold with larger widths)\n    case_C = {\n        \"fixed_params\": {\n            \"E1\": 0.12, \"E2\": 0.14,\n            \"lambda_th1\": 0.11, \"lambda_th2\": 0.09,\n            \"alpha1\": 0.25, \"alpha2\": 0.20,\n            \"gamma1\": 0.90, \"gamma2\": 0.60,\n        },\n        \"true_V12\": 0.030 - 0.020j,\n        \"lambda_mesh\": np.array([0.06, 0.08, 0.10, 0.12, 0.14, 0.16, 0.18, 0.20, 0.22]),\n    }\n\n    test_cases = [case_A, case_B, case_C]\n    results = []\n\n    for case in test_cases:\n        # Generate synthetic data using the true parameters\n        data_branches = calculate_branches(case[\"lambda_mesh\"], case[\"fixed_params\"], case[\"true_V12\"])\n        \n        # Define the residual function for the least-squares fit\n        def residuals(p, lambda_mesh, fixed_params, data_b1, data_b2):\n            \"\"\"\n            Calculates the residual vector for the least-squares fit.\n            p: array [v_r, v_i] of parameters to fit.\n            \"\"\"\n            v_r, v_i = p\n            trial_V12 = v_r + 1j * v_i\n            \n            model_b1, model_b2 = calculate_branches(lambda_mesh, fixed_params, trial_V12)\n            \n            # Calculate complex differences\n            diff1 = model_b1 - data_b1\n            diff2 = model_b2 - data_b2\n\n            # Stack real and imaginary parts into a 1D array\n            return np.concatenate([diff1.real, diff1.imag, diff2.real, diff2.imag])\n\n        # Initial guess for the fit\n        p0 = [0.0, 0.0]\n        \n        # Perform the non-linear least-squares fit\n        fit_result = least_squares(\n            residuals,\n            p0,\n            args=(case[\"lambda_mesh\"], case[\"fixed_params\"], data_branches[0], data_branches[1]),\n            method='lm' # Levenberg-Marquardt is robust for this type of problem\n        )\n        \n        # Extract fitted parameters\n        v_r_fit, v_i_fit = fit_result.x\n        \n        # Calculate the magnitude of the fitted V12\n        v12_magnitude = np.sqrt(v_r_fit**2 + v_i_fit**2)\n        results.append(v12_magnitude)\n\n    # Format and print the final output\n    print(f\"[{','.join([f'{r:.6f}' for r in results])}]\")\n\ndef calculate_branches(lambda_mesh, fixed_params, V12):\n    \"\"\"\n    Calculates the two complex eigenvalue branches for a given lambda mesh.\n    Enforces continuity by minimizing complex distance between points.\n    \"\"\"\n    fp = fixed_params\n    num_lambda = len(lambda_mesh)\n    branch1 = np.zeros(num_lambda, dtype=complex)\n    branch2 = np.zeros(num_lambda, dtype=complex)\n    \n    H = np.zeros((2, 2), dtype=complex)\n    \n    for i, lam in enumerate(lambda_mesh):\n        # Calculate diagonal elements of the Hamiltonian H(lambda)\n        delta1 = fp[\"alpha1\"] * (lam - fp[\"lambda_th1\"])\n        gamma1 = fp[\"gamma1\"] * max(lam - fp[\"lambda_th1\"], 0.0)\n        H[0, 0] = fp[\"E1\"] + delta1 - 0.5j * gamma1\n        \n        delta2 = fp[\"alpha2\"] * (lam - fp[\"lambda_th2\"])\n        gamma2 = fp[\"gamma2\"] * max(lam - fp[\"lambda_th2\"], 0.0)\n        H[1, 1] = fp[\"E2\"] + delta2 - 0.5j * gamma2\n        \n        # Set off-diagonal elements\n        H[0, 1] = H[1, 0] = V12\n        \n        # Get eigenvalues\n        eigvals = np.linalg.eigvals(H)\n        \n        if i == 0:\n            # For the first point, sort by real part as an initial condition\n            if eigvals[0].real < eigvals[1].real:\n                branch1[i] = eigvals[0]\n                branch2[i] = eigvals[1]\n            else:\n                branch1[i] = eigvals[1]\n                branch2[i] = eigvals[0]\n        else:\n            # For subsequent points, sort to maintain continuity\n            prev_b1 = branch1[i-1]\n            prev_b2 = branch2[i-1]\n            \n            # Two possible assignments for the new eigenvalues\n            e1, e2 = eigvals[0], eigvals[1]\n            \n            # Calculate sum of squared distances for both assignments\n            dist_noswap = abs(e1 - prev_b1) + abs(e2 - prev_b2)\n            dist_swap = abs(e2 - prev_b1) + abs(e1 - prev_b2)\n            \n            if dist_noswap < dist_swap:\n                branch1[i] = e1\n                branch2[i] = e2\n            else:\n                branch1[i] = e2\n                branch2[i] = e1\n                \n    return branch1, branch2\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3597518"}]}