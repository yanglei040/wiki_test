{"hands_on_practices": [{"introduction": "The concept of a Gamow state as a decaying resonance with a complex energy, $E = E_r - i\\Gamma/2$, is central to understanding open quantum systems. This first practice provides a direct, hands-on experience of finding such a state by solving the Schrödinger equation for a simple square well potential with purely outgoing boundary conditions [@problem_id:3600450]. By numerically locating the S-matrix pole in the complex momentum plane, you will solidify the fundamental connection between the pole's position and the resonance's physical properties: its energy $E_r$ and decay width $\\Gamma$.", "problem": "Consider a single-particle neutron described by the time-independent radial Schrödinger equation in a spherically symmetric, finite-range potential well. The potential is a spherical square well of radius $R$ and depth $V_0$, defined by $V(r) = -V_0$ for $0 \\le r \\le R$ and $V(r) = 0$ for $r > R$. Work in nonrelativistic quantum mechanics using standard single-particle scattering theory. Take the reduced mass equal to the neutron mass and use fully outgoing boundary conditions appropriate for Gamow states in the Gamow shell model. Use the following physical constants: reduced Planck constant times speed of light equal to $\\hbar c = 197.3269804\\,\\text{MeV}\\cdot\\text{fm}$ and neutron mass equal to $m_n c^2 = 939.0\\,\\text{MeV}$. Define $\\alpha \\equiv 2\\mu/\\hbar^2$ with $\\mu = m_n$.\n\nStarting from the radial Schrödinger equation for zero orbital angular momentum (that is, $s$-wave with $l=0$) and the requirement of purely outgoing asymptotics outside the well, derive the complex transcendental equation that determines the $S$-matrix pole positions. Express this equation in terms of the complex exterior momentum $k$ and the interior momentum $q$, where $k^2 = \\alpha E$ and $q^2 = \\alpha(E + V_0)$ with $E$ the complex energy. Clearly state the matching conditions at $r=R$ leading to the transcendental equation.\n\nDefine the pole energy by $E = E_r - i \\Gamma/2$, with $E_r$ and $\\Gamma$ real and $\\Gamma \\ge 0$. For any solution that satisfies the purely outgoing boundary condition and yields $\\operatorname{Im}(E) < 0$, extract the width $\\Gamma$ in $\\text{MeV}$ using $\\Gamma = -2\\,\\operatorname{Im}(E)$. If $\\operatorname{Im}(E) \\ge 0$, report the width as $0$.\n\nAlgorithmic task: implement a robust numerical solver for the complex transcendental equation you derived, using the complex variable $k$ as the unknown. Use the principal branch of the complex square root to define $q = \\sqrt{k^2 + \\alpha V_0}$. Solve for the $s$-wave pole located in the fourth quadrant of the complex $k$-plane with $\\operatorname{Re}(k) > 0$ and $\\operatorname{Im}(k) < 0$ that has the smallest positive real energy $E_r = \\operatorname{Re}(k^2/\\alpha)$. If multiple poles satisfy these criteria, select the one with the smallest $E_r$. If no such pole is found, return width $0$.\n\nNumerical units and output specification: express all energies in $\\text{MeV}$ and all lengths in $\\text{fm}$. Your program must compute the widths $\\Gamma$ for the following test suite of $(V_0, R)$ parameter sets:\n- $(V_0, R) = (50.0\\,\\text{MeV}, 4.0\\,\\text{fm})$\n- $(V_0, R) = (50.0\\,\\text{MeV}, 5.0\\,\\text{fm})$\n- $(V_0, R) = (30.0\\,\\text{MeV}, 4.0\\,\\text{fm})$\n- $(V_0, R) = (70.0\\,\\text{MeV}, 3.0\\,\\text{fm})$\n- $(V_0, R) = (10.0\\,\\text{MeV}, 4.0\\,\\text{fm})$\n\nYour algorithm must be self-contained and deterministic, without user input. To promote robustness, you may use multiple initial guesses for the complex momentum $k$ near $k \\approx m\\pi/R$ for small integers $m$, each with a small negative imaginary part, and pick the valid root according to the selection rule described above. Use the principal square root for complex arithmetic.\n\nYour program should produce a single line of output containing the five widths as a comma-separated list enclosed in square brackets, with each width rounded to six digits after the decimal point, for example, `[0.123456,0.000000,0.987654,0.111111,0.222222]`.", "solution": "The problem requires the derivation and numerical solution of the transcendental equation for $s$-wave Gamow states in a spherical square well potential. A Gamow state is a solution to the time-independent Schrödinger equation corresponding to a complex energy $E = E_r - i\\Gamma/2$, representing a quasi-bound or resonant state that decays over time. The imaginary part of the energy is related to the decay width $\\Gamma$.\n\nThe starting point is the radial Schrödinger equation for the reduced radial wave function $u(r) = r\\psi(r)$ for zero orbital angular momentum ($l=0$):\n$$\n-\\frac{\\hbar^2}{2\\mu} \\frac{d^2u(r)}{dr^2} + V(r)u(r) = E u(r)\n$$\nHere, $\\mu$ is the reduced mass, taken to be the neutron mass $m_n$. The potential $V(r)$ is a finite spherical square well of depth $V_0 > 0$ and radius $R$:\n$$\nV(r) =\n\\begin{cases}\n-V_0 & \\text{for } 0 \\le r \\le R \\\\\n0 & \\text{for } r > R\n\\end{cases}\n$$\nWe define the constant $\\alpha \\equiv 2\\mu/\\hbar^2$. The equation is analyzed in two regions.\n\nIn the interior region ($0 \\le r \\le R$), the equation is:\n$$\n\\frac{d^2u_I(r)}{dr^2} + \\alpha(E + V_0)u_I(r) = 0\n$$\nDefining the interior wave number $q$ such that $q^2 = \\alpha(E + V_0)$, the equation simplifies to a simple harmonic oscillator form:\n$$\n\\frac{d^2u_I(r)}{dr^2} + q^2 u_I(r) = 0\n$$\nThe general solution is $u_I(r) = A'\\sin(qr) + B'\\cos(qr)$. The physical requirement that the full wave function $\\psi(r) = u(r)/r$ remains finite at the origin implies that $u(0)=0$. This boundary condition forces $B'=0$, yielding the interior solution:\n$$\nu_I(r) = A \\sin(qr)\n$$\nwhere $A$ is a normalization constant.\n\nIn the exterior region ($r > R$), the potential is zero, $V(r)=0$, and the equation becomes:\n$$\n\\frac{d^2u_{II}(r)}{dr^2} + \\alpha E u_{II}(r) = 0\n$$\nDefining the exterior wave number $k$ such that $k^2 = \\alpha E$, the equation is:\n$$\n\\frac{d^2u_{II}(r)}{dr^2} + k^2 u_{II}(r) = 0\n$$\nThe general solution is a superposition of an incoming spherical wave, $e^{-ikr}$, and an outgoing spherical wave, $e^{ikr}$. Gamow states, as poles of the $S$-matrix, are defined by purely outgoing boundary conditions. This condition requires that the coefficient of the incoming wave be zero. Thus, the exterior solution is:\n$$\nu_{II}(r) = C e^{ikr}\n$$\nwhere $C$ is a constant. For a resonance, the energy $E$ is complex, and so is the wave number $k$. Specifically, for a decaying state, we expect $\\operatorname{Im}(E) < 0$, which implies that $k$ lies in the fourth quadrant of the complex plane ($\\operatorname{Re}(k) > 0$ and $\\operatorname{Im}(k) < 0$). This ensures that the probability density $|\\psi_{II}(r,t)|^2 \\propto |e^{i(kr - Et/\\hbar)}/r|^2$ grows exponentially with $r$, a characteristic feature of unphysical Gamow states.\n\nTo find the allowed complex energies, we impose continuity of the wave function $u(r)$ and its first derivative $u'(r)$ at the boundary $r=R$. The matching conditions are:\n1.  $u_I(R) = u_{II}(R) \\implies A \\sin(qR) = C e^{ikR}$\n2.  $u_I'(R) = u_{II}'(R) \\implies A q \\cos(qR) = C (ik) e^{ikR}$\n\nTo obtain an equation independent of the constants $A$ and $C$, we divide the second equation by the first (assuming $A, C,$ and $\\sin(qR)$ are non-zero):\n$$\n\\frac{A q \\cos(qR)}{A \\sin(qR)} = \\frac{C (ik) e^{ikR}}{C e^{ikR}}\n$$\nThis yields the complex transcendental equation for the $S$-matrix poles:\n$$\nq \\cot(qR) = ik\n$$\nThe solutions to this equation are the complex momenta $k$ of the Gamow states. The interior momentum $q$ is related to $k$ via the definitions $k^2 = \\alpha E$ and $q^2 = \\alpha(E+V_0)$, which gives $q^2 = k^2 + \\alpha V_0$. We use the principal branch of the complex square root to define $q = \\sqrt{k^2 + \\alpha V_0}$.\n\nThe algorithmic task is to solve this equation numerically for the complex variable $k$. For better numerical stability, especially near poles of the cotangent function, the equation is rewritten as $q \\cos(qR) - ik \\sin(qR) = 0$. The roots of this form are identical to the original equation's roots, except for the special cases where $\\sin(qR)=0$, which correspond to bound states of an infinite well and are not the solutions sought.\n\nThe algorithm proceeds as follows:\n1.  Calculate the constant $\\alpha = 2 m_n c^2 / (\\hbar c)^2$ using the provided physical constants.\n2.  For each pair of parameters $(V_0, R)$, solve the complex equation $f(k) = q \\cos(qR) - ik \\sin(qR) = 0$ using a numerical root-finding algorithm.\n3.  To find the desired pole, a search is performed using multiple initial guesses for $k$. Resonances are often viewed as \"leaky\" bound states. The wave numbers for states in an infinite well of radius $R$ are real, $k_m = m\\pi/R$ for positive integers $m$. Thus, good initial guesses for resonance poles are complex numbers close to these values, with a small negative imaginary part, e.g., $k_{\\text{guess}} = m\\pi/R - i\\delta$ for $\\delta > 0$.\n4.  Each root $k_{\\text{sol}}$ found by the solver is validated against the problem's criteria:\n    - The pole must be in the fourth quadrant: $\\operatorname{Re}(k_{\\text{sol}}) > 0$ and $\\operatorname{Im}(k_{\\text{sol}}) < 0$.\n    - The real part of the corresponding energy, $E_r = \\operatorname{Re}(k_{\\text{sol}}^2/\\alpha)$, must be positive.\n5.  All valid poles found from the various initial guesses are collected. If multiple distinct poles satisfy the criteria, they are sorted by their real energy $E_r$. The one with the smallest positive $E_r$ is selected.\n6.  From the selected pole's complex momentum $k_{\\text{pole}}$, the complex energy is computed as $E = k_{\\text{pole}}^2 / \\alpha$.\n7.  The decay width $\\Gamma$ is extracted using the relation $\\Gamma = -2\\operatorname{Im}(E)$. Given the selection criteria ($\\operatorname{Re}(k)>0, \\operatorname{Im}(k)<0$), $\\operatorname{Im}(E)$ will be negative, yielding a positive width $\\Gamma$. If no such pole is found, the width is reported as $0$. The final value is formatted to six decimal places.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import root\n\ndef solve():\n    \"\"\"\n    Derives and solves the transcendental equation for s-wave Gamow states\n    in a spherical square well potential.\n    \"\"\"\n\n    # Physical constants\n    HBARC = 197.3269804  # MeV * fm\n    M_N_C2 = 939.0      # MeV\n    ALPHA = 2.0 * M_N_C2 / HBARC**2  # MeV^-1 * fm^-2\n\n    # Test cases from the problem statement: (V0 in MeV, R in fm)\n    test_cases = [\n        (50.0, 4.0),\n        (50.0, 5.0),\n        (30.0, 4.0),\n        (70.0, 3.0),\n        (10.0, 4.0),\n    ]\n\n    results = []\n    for V0, R in test_cases:\n        pole_k = find_gamow_pole(V0, R, ALPHA)\n        \n        if pole_k is not None:\n            # Calculate complex energy E from the pole momentum k\n            E = pole_k**2 / ALPHA\n            # Calculate width Gamma = -2 * Im(E)\n            # Im(E) is guaranteed to be < 0 for a valid pole, so Gamma > 0.\n            # The problem asks to report Gamma=0 if Im(E) >= 0; this is a safeguard.\n            gamma = -2 * E.imag if E.imag < 0 else 0.0\n        else:\n            # If no valid pole is found, width is 0\n            gamma = 0.0\n        \n        results.append(f\"{gamma:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef find_gamow_pole(V0, R, alpha):\n    \"\"\"\n    Finds the s-wave Gamow pole with the smallest positive real energy.\n    \n    Args:\n        V0 (float): Potential well depth in MeV.\n        R (float): Potential well radius in fm.\n        alpha (float): Constant 2*mu/hbar^2 in MeV^-1 * fm^-2.\n\n    Returns:\n        complex or None: The complex momentum k of the desired pole, or None if not found.\n    \"\"\"\n\n    def target_function(k_vec, V0_in, R_in, alpha_in):\n        \"\"\"\n        Target function f(k) = q*cos(qR) - i*k*sin(qR) = 0 for the root finder.\n        The input k_vec is a real array [Re(k), Im(k)].\n        The output is a real array [Re(f(k)), Im(f(k))].\n        This form avoids poles of cot(qR).\n        \"\"\"\n        k = k_vec[0] + 1j * k_vec[1]\n        \n        # Avoid k=0\n        if abs(k) < 1e-9:\n            return [1e10, 1e10]\n\n        q_squared = k**2 + alpha_in * V0_in\n        q = np.sqrt(q_squared) # Principal square root\n        \n        qR = q * R_in\n\n        # Numerically stable form of the transcendental equation\n        val = q * np.cos(qR) - 1j * k * np.sin(qR)\n        \n        return [val.real, val.imag]\n\n    found_poles = []\n    \n    # Grid of initial guesses for k = k_r + i*k_i\n    # Guesses are based on resonances being \"leaky\" bound states of an infinite well (k_r ~ m*pi/R)\n    m_vals = range(1, 15)\n    im_k_vals = np.linspace(-0.01, -0.8, 20)\n\n    for m in m_vals:\n        re_k_guess = m * np.pi / R\n        for im_k_guess in im_k_vals:\n            k_guess = np.array([re_k_guess, im_k_guess])\n            \n            sol = root(target_function, k_guess, args=(V0, R, alpha), method='hybr', tol=1e-9)\n\n            if sol.success:\n                k_sol = sol.x[0] + 1j * sol.x[1]\n\n                # Verify that it is a genuine root\n                res = target_function(sol.x, V0, R, alpha)\n                if np.sqrt(res[0]**2 + res[1]**2) > 1e-7:\n                    continue\n\n                # Validate the pole based on problem criteria\n                # 1. Pole in 4th quadrant (Re(k) > 0, Im(k) < 0)\n                if k_sol.real <= 0 or k_sol.imag >= 0:\n                    continue\n                \n                # 2. Smallest positive real energy E_r\n                E = k_sol**2 / alpha\n                if E.real <= 0:\n                    continue\n                    \n                found_poles.append((E.real, k_sol))\n\n    if not found_poles:\n        return None\n\n    # Sort poles by the real part of the energy\n    found_poles.sort(key=lambda x: x[0])\n    \n    # Filter out duplicate solutions found from different initial guesses\n    unique_poles = []\n    for pole in found_poles:\n        is_duplicate = False\n        for unique_pole in unique_poles:\n            # Check if k-values are very close\n            if np.isclose(pole[1], unique_pole[1], rtol=1e-5, atol=1e-5):\n                is_duplicate = True\n                break\n        if not is_duplicate:\n            unique_poles.append(pole)\n\n    # Return the k of the pole with the smallest positive E_r\n    if unique_poles:\n        return unique_poles[0][1]\n    else:\n        return None\n\nif __name__ == \"__main__\":\n    solve()\n\n```", "id": "3600450"}, {"introduction": "The true power of the Gamow Shell Model (GSM) lies in its ability to describe many-body systems by combining single-particle states from a complete Berggren basis, which includes bound, resonant, and scattering states. This exercise guides you through the construction of a minimal two-neutron GSM Hamiltonian, moving from the single-particle picture to a simple many-body reality [@problem_id:3600461]. You will implement a residual pairing interaction and diagonalize the resulting complex-symmetric matrix to explore how configuration mixing between the resonant and continuum components gives rise to the properties of the correlated ground state.", "problem": "Implement a minimal two-neutron Gamow Shell Model (GSM) in a single $p_{3/2}$ partial wave using one explicit resonant single-particle state and a discretized non-resonant continuum along a rotated complex-energy contour. Construct the complex-symmetric two-body Hamiltonian for total angular momentum $J=0$ with a rank-one separable pairing residual interaction, and analyze configuration mixing of the resonant-resonant configuration as the pairing strength varies.\n\nYou must start from the following principles and core definitions:\n\n- Berggren completeness: a single-particle basis that includes bound and resonant Gamow states together with a discretized non-resonant continuum along a contour in the complex momentum or energy plane forms a complete set. In computations, the continuum integral is approximated by a quadrature over discretization points with positive weights.\n- For the single partial wave $p_{3/2}$, consider only two-neutron states coupled to total angular momentum $J=0$.\n- The complex-energy single-particle Hamiltonian yields a complex-symmetric two-body Hamiltonian (not Hermitian) when constructed in a Berggren basis. Right eigenvectors solve a generalized complex-symmetric eigenproblem.\n- A separable pairing residual interaction of rank one yields a two-body matrix of the form of an outer product.\n\nBased on these principles, implement the following concrete model choices without introducing any additional assumptions:\n\n1. Single-particle spectrum:\n   - One resonant Gamow pole with complex energy $E_{r} = 2.0 - i\\,0.2$ in mega-electron volts (MeV). Its quadrature weight is fixed to $w_{r} = 1.0$.\n   - A non-resonant continuum represented by $N$ points along a straight line in the complex energy plane parameterized by\n     $$E(s) = s\\,e^{-2 i \\theta}, \\quad s \\in (0, E_{\\max}),$$\n     where $E_{\\max} > 0$ is a real energy cutoff and $\\theta > 0$ is a rotation angle in radians. Use a midpoint rule with $N$ points:\n     $$s_{n} = \\left(n - \\tfrac{1}{2}\\right)\\frac{E_{\\max}}{N}, \\quad n = 1,2,\\dots,N,$$\n     with continuum quadrature weights\n     $$w_{n} = \\frac{E_{\\max}}{N}.$$\n     The single-particle list is then $\\{(E_{r}, w_{r}), (E(s_{1}), w_{1}), \\dots, (E(s_{N}), w_{N})\\}$.\n\n2. Two-particle $J=0$ basis and Hamiltonian:\n   - Build antisymmetrized two-particle basis states labeled by unordered pairs $(i,j)$ with $i \\le j$, where each index runs over the full single-particle set including the resonance and the $N$ continuum points. All single-particle states are assumed to have the same $j=3/2$.\n   - The unperturbed two-body energy is\n     $$H_{0,(ij),(ij)} = E_{i} + E_{j}.$$\n   - Include a rank-one separable pairing residual interaction\n     $$V = -G\\,|U\\rangle \\langle U|,$$\n     with scalar coupling strength $G \\ge 0$ (in MeV) and pair form factor components\n     $$U_{(ij)} = N_{ij}\\,\\sqrt{w_{i} w_{j}}, \\quad N_{ij} = \\begin{cases} 1 & i \\ne j, \\\\ \\tfrac{1}{\\sqrt{2}} & i=j. \\end{cases}$$\n     This produces the complex-symmetric matrix elements\n     $$V_{(ij),(kl)} = -G\\,U_{(ij)}\\,U_{(kl)}.$$\n   - The full two-body Hamiltonian is\n     $$H = H_{0} + V,$$\n     which is complex-symmetric.\n\n3. Eigenproblem and observables:\n   - Diagonalize $H$ to obtain eigenvalues $\\{\\mathcal{E}_{\\alpha}\\}$ and right eigenvectors $\\{|\\Psi_{\\alpha}\\rangle\\}$.\n   - Select the \"ground state\" as the eigenstate with the smallest real part $\\mathrm{Re}\\,\\mathcal{E}_{\\alpha}$.\n   - To analyze configuration mixing, focus on the resonant-resonant configuration $(i=j=\\text{resonance})$. Let $C_{\\mathrm{RR}}$ be the component of the selected right eigenvector along this basis state. For a numerically robust and real-valued mixing measure, normalize the right eigenvector using the standard Euclidean norm, i.e., enforce\n     $$\\sum_{p} |C_{p}|^{2} = 1,$$\n     and define the resonant-resonant mixing weight as\n     $$W_{\\mathrm{RR}} = |C_{\\mathrm{RR}}|^{2}.$$\n\n4. Units and numerical specifications:\n   - All energies must be expressed in mega-electron volts (MeV).\n   - All angles must be in radians.\n   - Report the ground-state energy as the real part $\\mathrm{Re}\\,\\mathcal{E}_{\\mathrm{gs}}$ in MeV, and the mixing weight $W_{\\mathrm{RR}}$ as a dimensionless decimal.\n   - Round both reported numbers to six decimal places.\n\n5. Required output format:\n   - Your program should produce a single line of output containing a list of results for each test case, where each result is itself a two-element list $[\\mathrm{Re}\\,\\mathcal{E}_{\\mathrm{gs}}, W_{\\mathrm{RR}}]$. The final output must be a single line of the form `[[x_1,y_1], [x_2,y_2], ...]]`, where each $x_{k}$ and $y_{k}$ is a decimal rounded to six places, with no extra spaces.\n\nTest suite to implement and evaluate:\n\n- Case A (happy path): $G = 0.25$ MeV, $N = 6$, $E_{\\max} = 10.0$ MeV, $\\theta = 0.34906585$ radians.\n- Case B (zero coupling boundary): $G = 0.0$ MeV, $N = 6$, $E_{\\max} = 10.0$ MeV, $\\theta = 0.34906585$ radians.\n- Case C (denser continuum, stronger pairing): $G = 0.75$ MeV, $N = 10$, $E_{\\max} = 12.0$ MeV, $\\theta = 0.261799388$ radians.\n- Case D (edge case with minimal continuum): $G = 1.2$ MeV, $N = 1$, $E_{\\max} = 8.0$ MeV, $\\theta = 0.34906585$ radians.\n\nYour program must construct the Hamiltonian exactly as specified, solve for the ground state according to the criterion above, compute $W_{\\mathrm{RR}}$ under Euclidean normalization, and print a single line containing the four results as a comma-separated list enclosed in square brackets, for example `[[x_A,y_A],[x_B,y_B],[x_C,y_C],[x_D,y_D]]`.", "solution": "The problem presents a valid, well-posed, and scientifically grounded task within the domain of computational nuclear physics. It requires the implementation of a minimal two-neutron Gamow Shell Model (GSM) for a single $p_{3/2}$ partial wave, exploring configuration mixing under a separable pairing interaction. The problem statement is self-contained, providing all necessary physical principles, mathematical definitions, and numerical parameters to construct and solve the model. We shall proceed with a systematic, step-by-step derivation and construction of the solution.\n\nThe core of the problem lies in constructing and diagonalizing a complex-symmetric many-body Hamiltonian. This Hamiltonian is built upon a single-particle basis, known as the Berggren basis, which is specifically designed for open quantum systems. Such systems are characterized by the possibility of particle emission, leading to states with finite lifetimes (resonances), which are described by complex energies.\n\n**Step 1: Construction of the Single-Particle Berggren Basis**\n\nThe foundation of the model is the single-particle basis, which, according to the Berggren completeness relation, comprises bound states, resonant (Gamow) states, and a discretized non-resonant continuum. The problem specifies a basis consisting of one resonant state and a discretized continuum contour. Let the total number of single-particle states be $K = N+1$. We label these states with an index $i \\in \\{0, 1, \\dots, N\\}$.\n\n1.  **Resonant State ($i=0$):**\n    A single resonant pole is given with a complex energy $E_0$ and an associated quadrature weight $w_0$:\n    $$E_0 = E_r = (2.0 - i\\,0.2) \\, \\mathrm{MeV}$$\n    $$w_0 = w_r = 1.0$$\n\n2.  **Discretized Continuum States ($i=1, \\dots, N$):**\n    The continuum is represented by $N$ states along a rotated contour in the complex energy plane, $E(s) = s\\,e^{-2i\\theta}$. The integral over the continuum is approximated by a quadrature sum using a midpoint rule. The $n$-th discretization point along the contour path, $s_n$, and its associated energy $E_n$ and weight $w_n$ are given by:\n    $$s_n = \\left(n - \\frac{1}{2}\\right) \\frac{E_{\\max}}{N}, \\quad \\text{for } n = 1, 2, \\dots, N$$\n    The corresponding complex energies for the continuum states (which we index from $i=1$ to $N$) are:\n    $$E_i = s_i \\, e^{-2i\\theta}, \\quad \\text{for } i = 1, 2, \\dots, N$$\n    The quadrature weights for these continuum states are:\n    $$w_i = \\frac{E_{\\max}}{N}, \\quad \\text{for } i = 1, 2, \\dots, N$$\n    This defines the complete set of single-particle energies $\\{E_i\\}_{i=0}^{N}$ and weights $\\{w_i\\}_{i=0}^{N}$.\n\n**Step 2: Construction of the Two-Body Hamiltonian for $J=0$**\n\nThe two-neutron Hamiltonian $H$ is the sum of the unperturbed two-body Hamiltonian $H_0$ and a residual pairing interaction $V$. We construct this Hamiltonian in a basis of antisymmetrized two-particle states $|\\phi_{ij}\\rangle$ formed from the single-particle states previously defined. For two neutrons in the same $j=3/2$ shell coupled to total angular momentum $J=0$, the basis states can be indexed by unordered pairs $(i,j)$ with $i, j \\in \\{0, 1, \\dots, N\\}$ and $i \\le j$.\n\nThe dimension of this two-body Hilbert space is $M = \\frac{(N+1)(N+2)}{2}$. We establish a mapping from a single matrix index $p \\in \\{0, 1, \\dots, M-1\\}$ to the pair indices $(i,j)$ by ordering them lexicographically, i.e., $(0,0), (0,1), \\dots, (0,N), (1,1), \\dots, (N,N)$.\n\n1.  **Unperturbed Hamiltonian ($H_0$):**\n    In this basis, $H_0$ is diagonal. The energy of a two-body state where the neutrons occupy single-particle states $i$ and $j$ is simply the sum of their energies.\n    $$H_{0,p,q} = (E_i + E_j) \\, \\delta_{pq}$$\n    where the pair $(i,j)$ corresponds to index $p$.\n\n2.  **Separable Pairing Interaction ($V$):**\n    The interaction is given as a rank-one separable potential, $V = -G |U\\rangle\\langle U|$, where $G$ is the pairing strength and $|U\\rangle$ is a vector of pair form factors in the two-body basis. The matrix elements of $V$ are:\n    $$V_{p,q} = -G \\, U_p \\, U_q$$\n    where $p$ and $q$ correspond to pairs $(i,j)$ and $(k,l)$ respectively. The component $U_p$ corresponding to the pair $(i,j)$ is defined as:\n    $$U_p \\equiv U_{(ij)} = N_{ij} \\sqrt{w_i w_j}$$\n    The normalization factor $N_{ij}$ arises from the antisymmetrization of the two-neutron wavefunction:\n    $$N_{ij} = \\begin{cases} \\frac{1}{\\sqrt{2}} & \\text{if } i = j \\\\ 1 & \\text{if } i \\ne j \\end{cases}$$\n\n3.  **Full Hamiltonian ($H$):**\n    The full Hamiltonian matrix is the sum $H = H_0 + V$.\n    $$H_{p,q} = (E_i + E_j) \\, \\delta_{pq} - G \\, U_p \\, U_q$$\n    This matrix is complex and symmetric ($H = H^T$), but not Hermitian ($H \\ne H^\\dagger$), a characteristic feature of Hamiltonians in a Berggren basis.\n\n**Step 3: Eigenproblem Solution and Observable Calculation**\n\nThe final step is to solve the time-independent Schrödinger equation for the two-neutron system, which takes the form of a matrix eigenvalue problem:\n$$H |\\Psi_\\alpha\\rangle = \\mathcal{E}_\\alpha |\\Psi_\\alpha\\rangle$$\nWe use a standard numerical eigensolver capable of handling complex, non-Hermitian matrices to find the complex eigenvalues $\\{\\mathcal{E}_\\alpha\\}$ and their corresponding right eigenvectors $\\{|\\Psi_\\alpha\\rangle\\}$.\n\n1.  **Ground State Identification:**\n    The problem defines the ground state as the eigenstate with the eigenvalue having the smallest real part. The real part of a complex eigenvalue is interpreted as the energy of the many-body state, a convention in open quantum system theory.\n    $$\\mathcal{E}_{\\mathrm{gs}} = \\min_{\\alpha} \\{\\mathrm{Re}(\\mathcal{E}_\\alpha)\\}$$\n    We identify this eigenvalue $\\mathcal{E}_{\\mathrm{gs}}$ and its associated eigenvector $|\\Psi_{\\mathrm{gs}}\\rangle$.\n\n2.  **Configuration Mixing Analysis:**\n    We are interested in the probability of finding the system in the resonant-resonant (RR) configuration, where both neutrons occupy the resonant Gamow state ($i=j=0$).\n    -   Identify the basis state corresponding to the RR configuration. In our lexicographical ordering, this corresponds to the first basis state, $p=0$.\n    -   Let the components of the ground-state eigenvector be $C_p$, i.e., $|\\Psi_{\\mathrm{gs}}\\rangle = \\sum_p C_p |\\phi_p\\rangle$. The RR component is $C_{\\mathrm{RR}} = C_0$.\n    -   The problem specifies a non-standard Euclidean normalization for the eigenvector to compute the mixing weight. We normalize the eigenvector such that $\\sum_p |C_p|^2 = 1$.\n    -   The mixing weight $W_{\\mathrm{RR}}$ is then defined as the squared magnitude of the normalized RR component:\n    $$W_{\\mathrm{RR}} = |C_{\\mathrm{RR}}|^2 / \\sum_{p=0}^{M-1} |C_p|^2$$\n\nThe algorithm proceeds by implementing these three steps for each given test case, calculating the ground-state energy $\\mathrm{Re}(\\mathcal{E}_{\\mathrm{gs}})$ and the mixing weight $W_{\\mathrm{RR}}$, and reporting the results to the specified precision.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Implements a minimal two-neutron Gamow Shell Model (GSM) to analyze configuration\n    mixing in an open quantum system.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: Happy path\n        # G (MeV), N, E_max (MeV), theta (rad)\n        (0.25, 6, 10.0, 0.34906585),\n        # Case B: Zero coupling boundary\n        (0.0, 6, 10.0, 0.34906585),\n        # Case C: Denser continuum, stronger pairing\n        (0.75, 10, 12.0, 0.261799388),\n        # Case D: Edge case with minimal continuum\n        (1.2, 1, 8.0, 0.34906585)\n    ]\n\n    results = []\n    for G, N, E_max, theta in test_cases:\n        # Step 1: Construct the single-particle Berggren basis\n        # The basis consists of one resonant state and N continuum states.\n        \n        # Resonant state (index 0)\n        E_r = 2.0 - 0.2j\n        w_r = 1.0\n\n        num_sp_states = N + 1\n        sp_energies = np.zeros(num_sp_states, dtype=np.complex128)\n        sp_weights = np.zeros(num_sp_states, dtype=np.float64)\n\n        sp_energies[0] = E_r\n        sp_weights[0] = w_r\n\n        # Discretized continuum states (indices 1 to N)\n        if N > 0:\n            s_n = (np.arange(1, N + 1) - 0.5) * E_max / N\n            continuum_energies = s_n * np.exp(-2j * theta)\n            continuum_weights = np.full(N, E_max / N)\n            \n            sp_energies[1:] = continuum_energies\n            sp_weights[1:] = continuum_weights\n\n        # Step 2: Construct the two-body Hamiltonian for J=0\n        \n        # Create a mapping from a flat matrix index 'p' to a pair of sp state indices (i, j)\n        basis_pairs = []\n        for i in range(num_sp_states):\n            for j in range(i, num_sp_states):\n                basis_pairs.append((i, j))\n        \n        dim = len(basis_pairs)\n        H = np.zeros((dim, dim), dtype=np.complex128)\n\n        # Construct H0 (diagonal part) and the U vector for the interaction\n        U = np.zeros(dim, dtype=np.float64)\n        for p, (i, j) in enumerate(basis_pairs):\n            # Unperturbed energy\n            H[p, p] = sp_energies[i] + sp_energies[j]\n            \n            # Form factor component U_p\n            N_ij = 1.0 / np.sqrt(2.0) if i == j else 1.0\n            U[p] = N_ij * np.sqrt(sp_weights[i] * sp_weights[j])\n\n        # Construct V (interaction part) and add to H\n        # V is a rank-one matrix: V = -G * |U><U|\n        if G > 0:\n            V = -G * np.outer(U, U)\n            H += V\n        \n        # Step 3: Solve the eigenproblem and compute observables\n        \n        eigenvalues, eigenvectors = linalg.eig(H)\n        \n        # Find the ground state: the one with the smallest real part of the eigenvalue\n        gs_idx = np.argmin(eigenvalues.real)\n        gs_energy = eigenvalues[gs_idx]\n        gs_vector = eigenvectors[:, gs_idx]\n        \n        # Calculate the ground state energy (real part)\n        Re_E_gs = gs_energy.real\n        \n        # Analyze configuration mixing. The resonant-resonant (RR) configuration\n        # corresponds to the pair (0,0), which is the first state in our basis (p=0).\n        rr_idx = 0\n        C_rr = gs_vector[rr_idx]\n        \n        # Normalize the eigenvector using the standard Euclidean norm as specified\n        norm_sq = np.sum(np.abs(gs_vector)**2)\n        \n        # Calculate the mixing weight W_RR\n        W_rr = np.abs(C_rr)**2 / norm_sq\n\n        # Store rounded results\n        results.append([round(Re_E_gs, 6), round(W_rr, 6)])\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"[{res[0]},{res[1]}]\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3600461"}, {"introduction": "A critical and defining feature of the GSM is its complex-symmetric, non-Hermitian Hamiltonian, which demands a different mathematical formalism than that of closed quantum systems. This practice focuses on the crucial concept of biorthogonality, guiding you to work with the distinct left and right eigenvectors and the appropriate complex-symmetric inner product, or $c$-product [@problem_id:3600507]. Mastering this formalism is essential for correctly calculating physical observables and validating the internal consistency of the theoretical framework, ensuring that expectation values are physically meaningful.", "problem": "You are asked to implement and validate biorthogonal normalization and metric-dependent expectation values in the Gamow shell model (GSM), a framework in computational nuclear physics that employs a complex-symmetric Hamiltonian to describe open quantum systems with resonant and scattering states. The Gamow shell model (GSM) uses the Berggren ensemble, which leads to a complex-symmetric Hamiltonian, so left and right eigenvectors are not related by Hermitian conjugation. Instead, the appropriate inner product is the so-called complex symmetric product, also known as the $c$-product, defined without complex conjugation.\n\nStarting from the fundamental base of non-Hermitian linear algebra and the spectral properties of complex-symmetric matrices, let $H$ be a complex-symmetric Hamiltonian matrix satisfying $H = H^{\\mathrm{T}}$, and let $O$ be an observable represented by a matrix that is not guaranteed to commute with $H$. Right eigenvectors $\\{ |\\Psi_n\\rangle \\}$ satisfy $H |\\Psi_n\\rangle = E_n |\\Psi_n\\rangle$, while left eigenvectors $\\{ \\langle\\tilde{\\Psi}_n| \\}$ satisfy $\\langle\\tilde{\\Psi}_n| H = E_n \\langle\\tilde{\\Psi}_n|$, equivalently $(H^{\\mathrm{T}}) |\\tilde{\\Psi}_n\\rangle = E_n |\\tilde{\\Psi}_n\\rangle$ with $\\langle\\tilde{\\Psi}_n| = |\\tilde{\\Psi}_n\\rangle^{\\mathrm{T}}$. The biorthogonal normalization condition in GSM is $\\langle\\tilde{\\Psi}_m|\\Psi_n\\rangle = \\delta_{mn}$, where $\\langle\\tilde{\\Psi}|$ denotes the $c$-product transpose bra. Expectation values in GSM are then taken as $\\langle\\tilde{\\Psi}|\\mathcal{O}|\\Psi\\rangle$, in contrast to the standard Hermitian-metric expectation $\\langle\\Psi|\\mathcal{O}|\\Psi\\rangle$.\n\nYou will:\n- Implement biorthogonal normalization under the $c$-product for two given complex-symmetric Hamiltonians.\n- Validate that the expectation of $H$ in its eigenstate under the $c$-product equals the eigenvalue, i.e., $\\langle\\tilde{\\Psi}_n|H|\\Psi_n\\rangle = E_n$.\n- Compare with the Hermitian-metric expectation $\\langle\\Psi_n|H|\\Psi_n\\rangle$ (with a standard normalization of $|\\Psi_n\\rangle$ under the Hermitian metric).\n- Explore how different metric conventions affect estimates for non-commuting observables by evaluating the magnitude of $\\langle\\cdot|[O_1, O_2]|\\cdot\\rangle$ under three metrics: the GSM $c$-product, the Hermitian metric, and a generalized metric with a positive-definite metric operator $\\eta$.\n\nUse the following explicit test suite of $3 \\times 3$ complex-symmetric matrices, where $\\mathrm{i}$ denotes the imaginary unit.\n\nHamiltonian $H_1$:\n$$\nH_1 = \\begin{pmatrix}\n-2.0 + 0.5\\,\\mathrm{i} & 0.35 & 0.15\\,\\mathrm{i} \\\\\n0.35 & -1.2 + 0.8\\,\\mathrm{i} & 0.27 - 0.05\\,\\mathrm{i} \\\\\n0.15\\,\\mathrm{i} & 0.27 - 0.05\\,\\mathrm{i} & -0.4 + 1.1\\,\\mathrm{i}\n\\end{pmatrix}.\n$$\n\nHamiltonian $H_2$:\n$$\nH_2 = \\begin{pmatrix}\n-1.0 + 0.3\\,\\mathrm{i} & 0.2 + 0.02\\,\\mathrm{i} & 0.05\\,\\mathrm{i} \\\\\n0.2 + 0.02\\,\\mathrm{i} & -0.98 + 0.31\\,\\mathrm{i} & 0.18 - 0.01\\,\\mathrm{i} \\\\\n0.05\\,\\mathrm{i} & 0.18 - 0.01\\,\\mathrm{i} & -0.6 + 0.95\\,\\mathrm{i}\n\\end{pmatrix}.\n$$\n\nOperators $O_1$ and $O_2$ for $H_1$:\n$$\nO_1^{(1)} = \\begin{pmatrix}\n1.0 & 0.1 & -0.05\\,\\mathrm{i} \\\\\n0.1 & 0.5 & 0.07 + 0.02\\,\\mathrm{i} \\\\\n-0.05\\,\\mathrm{i} & 0.07 + 0.02\\,\\mathrm{i} & -0.2\n\\end{pmatrix}, \\quad\nO_2^{(1)} = \\begin{pmatrix}\n0.3 & -0.06 + 0.03\\,\\mathrm{i} & 0.12 \\\\\n-0.06 + 0.03\\,\\mathrm{i} & -0.1 & -0.09\\,\\mathrm{i} \\\\\n0.12 & -0.09\\,\\mathrm{i} & 0.8\n\\end{pmatrix}.\n$$\n\nOperators $O_1$ and $O_2$ for $H_2$ (constructed to commute up to a scalar shift as a boundary case):\n$$\nO_1^{(2)} = \\begin{pmatrix}\n0.9 & 0.02 & -0.01\\,\\mathrm{i} \\\\\n0.02 & 0.88 & 0.015 \\\\\n-0.01\\,\\mathrm{i} & 0.015 & 0.1\n\\end{pmatrix}, \\quad\nO_2^{(2)} = O_1^{(2)} + 0.001\\,I,\n$$\nwhere $I$ is the identity matrix.\n\nGeneralized metric operators (diagonal and positive-definite):\n$$\n\\eta_1 = \\mathrm{diag}(1.0, 0.5, 2.0), \\quad \\eta_2 = \\mathrm{diag}(0.7, 1.1, 1.5).\n$$\n\nComputational tasks:\n1. For each Hamiltonian $H \\in \\{H_1, H_2\\}$, compute its right eigenpairs $\\{(E_n, |\\Psi_n\\rangle)\\}$ and left eigenvectors $\\{|\\tilde{\\Psi}_n\\rangle\\}$ from $H^{\\mathrm{T}}$, and perform biorthogonal normalization so that $\\langle\\tilde{\\Psi}_m|\\Psi_n\\rangle = \\delta_{mn}$, with the inner product being the $c$-product defined by $\\langle\\tilde{\\Psi}| = |\\tilde{\\Psi}\\rangle^{\\mathrm{T}}$ and $\\langle\\tilde{\\Psi}|\\Psi\\rangle = |\\tilde{\\Psi}\\rangle^{\\mathrm{T}} |\\Psi\\rangle$.\n2. Validate the GSM expectation consistency for the selected eigenstate $|\\Psi_*\\rangle$ chosen as the eigenstate with the smallest absolute value of the imaginary part of $E_n$ (interpreted as the narrowest resonance): compute the GSM expectation $\\langle\\tilde{\\Psi}_*|H|\\Psi_*\\rangle$ and report the magnitude of the difference $\\left| \\langle\\tilde{\\Psi}_*|H|\\Psi_*\\rangle - E_* \\right|$.\n3. Compute the Hermitian-metric expectation of $H$ in the same eigenstate, with the right eigenvector normalized under the Hermitian norm, i.e., define $|\\Phi_*\\rangle = |\\Psi_*\\rangle / \\sqrt{\\langle\\Psi_*|\\Psi_*\\rangle_{\\mathrm{Herm}}}$ where $\\langle\\Psi|\\Psi\\rangle_{\\mathrm{Herm}} = |\\Psi\\rangle^{\\dagger} |\\Psi\\rangle$, and report the magnitude of the difference $\\left| \\langle\\Phi_*|H|\\Phi_*\\rangle - E_* \\right|$.\n4. For each pair $(O_1^{(k)}, O_2^{(k)})$ with $k \\in \\{1,2\\}$, compute the commutator $[O_1^{(k)}, O_2^{(k)}] = O_1^{(k)} O_2^{(k)} - O_2^{(k)} O_1^{(k)}$, and evaluate the magnitude of its expectation value in the selected eigenstate $|\\Psi_*\\rangle$ under the three metric conventions:\n   - GSM $c$-product: $\\left| \\langle\\tilde{\\Psi}_*|[O_1^{(k)}, O_2^{(k)}]|\\Psi_*\\rangle \\right|$.\n   - Hermitian metric: $\\left| \\langle\\Phi_*|[O_1^{(k)}, O_2^{(k)}]|\\Phi_*\\rangle \\right|$.\n   - Generalized $\\eta$-metric: $\\left| \\frac{\\langle\\Psi_*|\\eta_k [O_1^{(k)}, O_2^{(k)}]|\\Psi_*\\rangle_{\\mathrm{Herm}}}{\\langle\\Psi_*|\\eta_k|\\Psi_*\\rangle_{\\mathrm{Herm}}} \\right|$.\n5. For biorthogonal normalization quality, check whether the full biorthogonality matrix $B$ with elements $B_{mn} = \\langle\\tilde{\\Psi}_m|\\Psi_n\\rangle$ is numerically equal to the identity within a tolerance $10^{-8}$, i.e., $\\max\\{\\lvert B_{mm} - 1 \\rvert, \\max_{m\\neq n} \\lvert B_{mn} \\rvert\\} < 10^{-8}$, and return a boolean pass/fail result for each Hamiltonian.\n\nNumerical and implementation details:\n- Use a numerical tolerance of $10^{-8}$ for all normalization checks.\n- All computations are dimensionless; no physical units are required.\n- Angles do not occur; no angle unit is required.\n- For eigenpair pairing between right and left spectra, match left eigenvalues to right eigenvalues by minimal absolute difference.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must contain, in order:\n- For $H_1$: the biorthogonal normalization pass boolean.\n- For $H_2$: the biorthogonal normalization pass boolean.\n- For $H_1$: the float $\\left| \\langle\\tilde{\\Psi}_*|H_1|\\Psi_*\\rangle - E_* \\right|$.\n- For $H_1$: the float $\\left| \\langle\\Phi_*|H_1|\\Phi_*\\rangle - E_* \\right|$.\n- For $H_1$: the three floats $\\left| \\langle\\tilde{\\Psi}_*|[O_1^{(1)}, O_2^{(1)}]|\\Psi_*\\rangle \\right|$, $\\left| \\langle\\Phi_*|[O_1^{(1)}, O_2^{(1)}]|\\Phi_*\\rangle \\right|$, and $\\left| \\frac{\\langle\\Psi_*|\\eta_1 [O_1^{(1)}, O_2^{(1)}]|\\Psi_*\\rangle_{\\mathrm{Herm}}}{\\langle\\Psi_*|\\eta_1|\\Psi_*\\rangle_{\\mathrm{Herm}}} \\right|$.\n- For $H_2$: the float $\\left| \\langle\\tilde{\\Psi}_*|H_2|\\Psi_*\\rangle - E_* \\right|$.\n- For $H_2$: the float $\\left| \\langle\\Phi_*|H_2|\\Phi_*\\rangle - E_* \\right|$.\n- For $H_2$: the three floats $\\left| \\langle\\tilde{\\Psi}_*|[O_1^{(2)}, O_2^{(2)}]|\\Psi_*\\rangle \\right|$, $\\left| \\langle\\Phi_*|[O_1^{(2)}, O_2^{(2)}]|\\Phi_*\\rangle \\right|$, and $\\left| \\frac{\\langle\\Psi_*|\\eta_2 [O_1^{(2)}, O_2^{(2)}]|\\Psi_*\\rangle_{\\mathrm{Herm}}}{\\langle\\Psi_*|\\eta_2|\\Psi_*\\rangle_{\\mathrm{Herm}}} \\right|$.\n\nThus, your program must output a list containing $12$ entries: two booleans followed by ten floats, in exactly this order and format, for the specified test suite.", "solution": "The problem requires the implementation and validation of concepts from non-Hermitian quantum mechanics, specifically those applied in the Gamow Shell Model (GSM) for open quantum systems. The foundation of this model is a complex-symmetric Hamiltonian, $H = H^{\\mathrm{T}}$, whose spectral properties differ significantly from those of Hermitian Hamiltonians used in describing closed systems. The central task is to correctly handle the biorthogonal basis of left and right eigenvectors and compute expectation values using different metric definitions.\n\nFirst, we must establish the eigensystem of a complex-symmetric Hamiltonian $H$. The right eigenvectors $|\\Psi_n\\rangle$ and their corresponding complex eigenvalues $E_n$ are found by solving the right-eigenvalue equation $H |\\Psi_n\\rangle = E_n |\\Psi_n\\rangle$. The left eigenvectors, denoted by bras $\\langle\\tilde{\\Psi}_n|$, satisfy the left-eigenvalue equation $\\langle\\tilde{\\Psi}_n| H = E_n \\langle\\tilde{\\Psi}_n|$. Taking the transpose of this equation yields $H^{\\mathrm{T}} |\\tilde{\\Psi}_n\\rangle = E_n |\\tilde{\\Psi}_n\\rangle$, where we have used the definition that the column vector representation of the left eigen-bra is $|\\tilde{\\Psi}_n\\rangle = (\\langle\\tilde{\\Psi}_n|)^{\\mathrm{T}}$. Since $H$ is complex-symmetric ($H=H^{\\mathrm{T}}$), the left eigenvectors of $H$ are simply the right eigenvectors of $H$ itself, corresponding to the same set of eigenvalues $\\{E_n\\}$. However, for a general non-degenerate matrix, the left eigenvector $|\\tilde{\\Psi}_n\\rangle$ is not simply related to the right eigenvector $|\\Psi_n\\rangle$. Computationally, we find the right eigenvectors by diagonalizing $H$ and the left eigenvectors by diagonalizing $H^{\\mathrm{T}}$. Standard numerical eigensolvers may return the eigenvalues and eigenvectors in different orders, so it is necessary to pair the corresponding left and right eigenvectors. This is achieved by matching the eigenvalues from both diagonalizations based on minimal absolute difference, which can be solved robustly using an optimal assignment algorithm.\n\nThe set of left and right eigenvectors, $\\{ |\\tilde{\\Psi}_m\\rangle \\}$ and $\\{ |\\Psi_n\\rangle \\}$, forms a biorthogonal system. They are not orthogonal under the standard Hermitian inner product, $\\langle u|v \\rangle_{\\mathrm{Herm}} = u^{\\dagger}v$. Instead, they are orthogonal with respect to the complex-symmetric inner product, or $c$-product, defined as $\\langle \\tilde{u}|v \\rangle = \\tilde{u}^{\\mathrm{T}}v$, without complex conjugation. For distinct non-degenerate eigenvalues, this gives $\\langle\\tilde{\\Psi}_m|\\Psi_n\\rangle = 0$ for $m \\neq n$. The next step is to enforce the full biorthonormality condition, $\\langle\\tilde{\\Psi}_m|\\Psi_n\\rangle = \\delta_{mn}$. If we start with raw eigenvectors $|\\Psi_n^{\\text{raw}}\\rangle$ and $|\\tilde{\\Psi}_n^{\\text{raw}}\\rangle$, we compute the normalization integral $N_n = \\langle\\tilde{\\Psi}_n^{\\text{raw}}|\\Psi_n^{\\text{raw}}\\rangle = (|\\tilde{\\Psi}_n^{\\text{raw}}\\rangle)^{\\mathrm{T}} |\\Psi_n^{\\text{raw}}\\rangle$. The normalized eigenvectors are then $|\\Psi_n\\rangle = |\\Psi_n^{\\text{raw}}\\rangle / \\sqrt{N_n}$ and $|\\tilde{\\Psi}_n\\rangle = |\\tilde{\\Psi}_n^{\\text{raw}}\\rangle / \\sqrt{N_n}$. This choice of scaling ensures the normalization condition is met. The quality of this normalization can be verified by constructing the matrix of overlaps $B_{mn} = \\langle\\tilde{\\Psi}_m|\\Psi_n\\rangle$ and checking its deviation from the identity matrix $I$.\n\nWith the biorthonormal basis established, we can compute expectation values. The correct definition for the expectation value of an observable $\\mathcal{O}$ in a state $|\\Psi_n\\rangle$ within the GSM framework is $\\langle \\mathcal{O} \\rangle_n = \\langle\\tilde{\\Psi}_n|\\mathcal{O}|\\Psi_n\\rangle$. A crucial consistency check is that the expectation value of the Hamiltonian itself must equal the corresponding eigenvalue: $\\langle\\tilde{\\Psi}_n|H|\\Psi_n\\rangle = \\langle\\tilde{\\Psi}_n|(E_n |\\Psi_n\\rangle) = E_n \\langle\\tilde{\\Psi}_n|\\Psi_n\\rangle = E_n$. The first part of the calculation validates this property numerically.\n\nThis is contrasted with the standard Hermitian expectation value, $\\langle\\Psi_n|\\mathcal{O}|\\Psi_n\\rangle_{\\mathrm{Herm}}$, which requires the state vector to be normalized under the Hermitian inner product, i.e., using $|\\Phi_n\\rangle = |\\Psi_n\\rangle / \\sqrt{\\langle\\Psi_n|\\Psi_n\\rangle_{\\mathrm{Herm}}}$. For a non-Hermitian operator like $H$, the quantity $\\langle\\Phi_n|H|\\Phi_n\\rangle_{\\mathrm{Herm}}$ is a Rayleigh quotient and is not, in general, equal to the eigenvalue $E_n$. The problem requires computing the magnitude of this deviation.\n\nFinally, we explore how the choice of metric affects the expectation value of an observable that does not commute with $H$. We compute the commutator $[O_1, O_2] = O_1 O_2 - O_2 O_1$ and evaluate its expectation value for the selected state $|\\Psi_*\\rangle$ (the narrowest resonance, having the smallest $|\\mathrm{Im}(E_n)|$) using three different prescriptions:\n1.  The GSM $c$-product expectation: $ \\langle\\tilde{\\Psi}_*|[O_1, O_2]|\\Psi_*\\rangle $.\n2.  The standard Hermitian expectation: $ \\langle\\Phi_*|[O_1, O_2]|\\Phi_*\\rangle_{\\mathrm{Herm}} $, using the Hermitian-normalized state $|\\Phi_*\\rangle$.\n3.  A generalized $\\eta$-metric expectation: $ \\frac{\\langle\\Psi_*|\\eta [O_1, O_2]|\\Psi_*\\rangle_{\\mathrm{Herm}}}{\\langle\\Psi_*|\\eta|\\Psi_*\\rangle_{\\mathrm{Herm}}} $, where $\\eta$ is a positive-definite metric operator. This uses the biorthogonally-normalized state $|\\Psi_*\\rangle$ within a generalized inner product structure.\n\nThe calculations are performed for two different Hamiltonians and their associated operators, with one case constructed such that the commutator is identically zero, serving as a numerical sanity check. The final results will quantify the differences arising from these distinct theoretical conventions for physical observables.\n\nThe algorithmic procedure for each test case is as follows:\n1.  Numerically diagonalize $H$ to get $\\{E_n, |\\Psi_n^{\\text{raw}}\\rangle\\}$ and $H^{\\mathrm{T}}$ to get $\\{E'_m, |\\tilde{\\Psi}_m^{\\text{raw}}\\rangle\\}$.\n2.  Align the left eigenvectors with the right eigenvectors by finding the permutation that minimizes the distance between the eigenvalue sets $\\{E_n\\}$ and $\\{E'_m\\}$.\n3.  For each pair $(n)$, compute the normalization constant $N_n = (|\\tilde{\\Psi}_n^{\\text{raw}}\\rangle)^{\\mathrm{T}} |\\Psi_n^{\\text{raw}}\\rangle$ and scale the eigenvectors to obtain the biorthonormal set $\\{ |\\Psi_n\\rangle, |\\tilde{\\Psi}_n\\rangle \\}$.\n4.  Verify the biorthonormality relation against the specified tolerance and record the boolean result.\n5.  Identify the index `$*$` corresponding to the eigenvalue with the smallest imaginary part in absolute value.\n6.  Compute the required expectation values and differences for the state indexed by `$*$` using the formulas for the GSM, Hermitian, and $\\eta$-metrics.\n7.  Collect and report all specified quantities.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linear_sum_assignment\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and orchestrate the calculations.\n    \"\"\"\n    \n    # Define Hamiltonians\n    H1 = np.array([\n        [-2.0 + 0.5j, 0.35, 0.15j],\n        [0.35, -1.2 + 0.8j, 0.27 - 0.05j],\n        [0.15j, 0.27 - 0.05j, -0.4 + 1.1j]\n    ], dtype=np.complex128)\n\n    H2 = np.array([\n        [-1.0 + 0.3j, 0.2 + 0.02j, 0.05j],\n        [0.2 + 0.02j, -0.98 + 0.31j, 0.18 - 0.01j],\n        [0.05j, 0.18 - 0.01j, -0.6 + 0.95j]\n    ], dtype=np.complex128)\n\n    # Define Operators for H1\n    O1_1 = np.array([\n        [1.0, 0.1, -0.05j],\n        [0.1, 0.5, 0.07 + 0.02j],\n        [-0.05j, 0.07 + 0.02j, -0.2]\n    ], dtype=np.complex128)\n\n    O2_1 = np.array([\n        [0.3, -0.06 + 0.03j, 0.12],\n        [-0.06 + 0.03j, -0.1, -0.09j],\n        [0.12, -0.09j, 0.8]\n    ], dtype=np.complex128)\n\n    # Define Operators for H2\n    O1_2 = np.array([\n        [0.9, 0.02, -0.01j],\n        [0.02, 0.88, 0.015],\n        [-0.01j, 0.015, 0.1]\n    ], dtype=np.complex128)\n\n    O2_2 = O1_2 + 0.001 * np.eye(3)\n\n    # Define Metric Operators\n    eta1 = np.diag([1.0, 0.5, 2.0])\n    eta2 = np.diag([0.7, 1.1, 1.5])\n\n    # Tolerance for normalization check\n    tolerance = 1e-8\n\n    # Process each case\n    results1 = process_case(H1, O1_1, O2_1, eta1, tolerance)\n    results2 = process_case(H2, O1_2, O2_2, eta2, tolerance)\n\n    # Assemble final list in the specified order\n    final_output = [\n        results1[0],  # Biorthogonal norm check H1\n        results2[0],  # Biorthogonal norm check H2\n        results1[1],  # GSM expectation diff H1\n        results1[2],  # Hermitian expectation diff H1\n        results1[3],  # Commutator GSM H1\n        results1[4],  # Commutator Hermitian H1\n        results1[5],  # Commutator eta-metric H1\n        results2[1],  # GSM expectation diff H2\n        results2[2],  # Hermitian expectation diff H2\n        results2[3],  # Commutator GSM H2\n        results2[4],  # Commutator Hermitian H2\n        results2[5]   # Commutator eta-metric H2\n    ]\n    \n    # Format the output string as required\n    print(f\"[{','.join(map(str, final_output))}]\")\n\ndef process_case(H, O1, O2, eta, tolerance):\n    \"\"\"\n    Performs all calculations for a single Hamiltonian and its associated operators.\n    \"\"\"\n    n_dim = H.shape[0]\n\n    # 1. Eigendecomposition and eigenvector pairing\n    E_R, V_R = np.linalg.eig(H)\n    E_L, V_L = np.linalg.eig(H.T)\n\n    # Pair left and right eigenvectors by matching eigenvalues\n    cost_matrix = np.abs(E_R[:, np.newaxis] - E_L[np.newaxis, :])\n    row_ind, col_ind = linear_sum_assignment(cost_matrix)\n    V_L_sorted = V_L[:, col_ind] # V_L_sorted columns correspond to V_R columns\n\n    # 2. Biorthogonal normalization\n    # Compute normalization constants\n    norm_factors_sq = np.einsum('ij,ij->j', V_L_sorted, V_R)\n    norm_factors = np.sqrt(norm_factors_sq)\n    \n    # Apply normalization\n    psi_R_norm = V_R / norm_factors[np.newaxis, :]\n    psi_L_norm = V_L_sorted / norm_factors[np.newaxis, :]\n\n    # 3. Task 5: Biorthogonality check\n    B = psi_L_norm.T @ psi_R_norm\n    off_diag = B - np.diag(np.diag(B))\n    max_off_diag_err = np.max(np.abs(off_diag))\n    max_diag_err = np.max(np.abs(np.diag(B) - 1.0))\n    norm_pass = max(max_diag_err, max_off_diag_err) < tolerance\n\n    # 4. State selection: narrowest resonance\n    star_idx = np.argmin(np.abs(np.imag(E_R)))\n    E_star = E_R[star_idx]\n    psi_star = psi_R_norm[:, star_idx]\n    psi_tilde_star = psi_L_norm[:, star_idx]\n\n    # 5. Task 2: GSM expectation consistency\n    exp_H_gsm = psi_tilde_star.T @ H @ psi_star\n    diff_gsm = np.abs(exp_H_gsm - E_star)\n\n    # 6. Task 3: Hermitian expectation of H\n    # Hermitian normalization for the selected right eigenvector\n    herm_norm = np.sqrt(psi_star.conj().T @ psi_star)\n    phi_star = psi_star / herm_norm\n    exp_H_herm = phi_star.conj().T @ H @ phi_star\n    diff_herm = np.abs(exp_H_herm - E_star)\n\n    # 7. Task 4: Commutator expectations\n    C = O1 @ O2 - O2 @ O1\n\n    # GSM c-product expectation\n    exp_C_gsm = np.abs(psi_tilde_star.T @ C @ psi_star)\n    \n    # Hermitian metric expectation\n    exp_C_herm = np.abs(phi_star.conj().T @ C @ phi_star)\n\n    # Generalized eta-metric expectation\n    num = psi_star.conj().T @ eta @ C @ psi_star\n    den = psi_star.conj().T @ eta @ psi_star\n    exp_C_eta = np.abs(num / den)\n\n    return [norm_pass, diff_gsm, diff_herm, exp_C_gsm, exp_C_herm, exp_C_eta]\n\nsolve()\n```", "id": "3600507"}]}