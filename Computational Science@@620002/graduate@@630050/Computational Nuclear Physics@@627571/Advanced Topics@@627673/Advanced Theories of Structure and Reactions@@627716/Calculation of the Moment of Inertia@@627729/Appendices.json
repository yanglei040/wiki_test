{"hands_on_practices": [{"introduction": "The cranking model is a cornerstone for describing rotating nuclei. This first exercise provides a direct numerical test of the model's internal consistency by verifying a fundamental relationship derived from the Feynman-Hellmann theorem, which connects the energy of a rotating system to its angular momentum [@problem_id:3548296]. By implementing this test, you will gain hands-on experience constructing and diagonalizing the rotational Hamiltonian, or Routhian, and appreciate the deep connection between the dynamic moment of inertia $J^{(2)}$ and the system's response to the cranking field.", "problem": "Consider a cranked single-particle model where a single nucleon occupies a truncated angular-momentum subspace with total angular momentum $j=\\frac{3}{2}$ and magnetic sublevels $m\\in\\left\\{-\\frac{3}{2},-\\frac{1}{2},\\frac{1}{2},\\frac{3}{2}\\right\\}$. Work in natural units where $\\hbar=1$. Let the non-cranked Hamiltonian be a diagonal matrix $H_0$ with level energies $E_m$ that phenomenologically mimic a static mean field (for instance, due to quadrupole deformation). Define the cranking about the $x$-axis by the Routhian $R(\\omega)=H_0-\\omega \\hat{J}_x$, where $\\omega$ is the rotational frequency. The physical energy-like functional used in this problem is defined by $E(\\omega)\\equiv -\\langle R(\\omega)\\rangle$ evaluated in the lowest-energy eigenstate of $R(\\omega)$ at fixed $\\omega$. \n\nYou must:\n- Construct the angular-momentum operator $\\hat{J}_x$ in the $j=\\frac{3}{2}$ subspace using the ladder operators $\\hat{J}_\\pm$ with matrix elements $ \\langle j,m'|\\hat{J}_\\pm|j,m\\rangle = \\sqrt{j(j+1)-m(m\\pm 1)}\\,\\delta_{m',m\\pm 1}$ and $\\hat{J}_x=\\frac{1}{2}\\left(\\hat{J}_+ + \\hat{J}_-\\right)$, with $\\hbar=1$.\n- Use the diagonal $H_0=\\mathrm{diag}(E_{-3/2},E_{-1/2},E_{1/2},E_{3/2})$ with $E_{-3/2}=0.00~\\mathrm{MeV}$, $E_{-1/2}=0.85~\\mathrm{MeV}$, $E_{1/2}=1.70~\\mathrm{MeV}$, and $E_{3/2}=2.80~\\mathrm{MeV}$.\n- For any given $\\omega$ (in $\\mathrm{MeV}$) compute the ground-state eigenpair $\\left(\\lambda_{\\min}(\\omega),|\\psi(\\omega)\\rangle\\right)$ of $R(\\omega)$, then evaluate the expectation value $\\langle \\hat{J}_x\\rangle(\\omega)=\\langle \\psi(\\omega)|\\hat{J}_x|\\psi(\\omega)\\rangle$ and the energy-like functional $E(\\omega)=-\\lambda_{\\min}(\\omega)$.\n- Approximate $\\frac{\\partial \\langle \\hat{J}_x\\rangle}{\\partial \\omega}$ by a symmetric finite difference with step $h$:\n$$\n\\frac{\\partial \\langle \\hat{J}_x\\rangle}{\\partial \\omega}\\bigg|_{\\omega}\\approx \\frac{\\langle \\hat{J}_x\\rangle(\\omega+h)-\\langle \\hat{J}_x\\rangle(\\omega-h)}{2h},\n$$\nand approximate the Hessian $\\frac{\\partial^2 E}{\\partial \\omega^2}$ by:\n$$\n\\frac{\\partial^2 E}{\\partial \\omega^2}\\bigg|_{\\omega}\\approx \\frac{E(\\omega+h)-2E(\\omega)+E(\\omega-h)}{h^2}.\n$$\n- Numerically verify the consistency relation $J^{(2)}(\\omega)=\\frac{\\partial \\langle \\hat{J}_x\\rangle}{\\partial \\omega}=\\frac{\\partial^2 E}{\\partial \\omega^2}$ for the specified test suite by comparing the two finite-difference estimates.\n\nUse the following test suite of $(\\omega,h)$ pairs (both in $\\mathrm{MeV}$):\n- $(\\omega,h)=\\left(0.00,10^{-3}\\right)$,\n- $(\\omega,h)=\\left(0.20,5\\times 10^{-3}\\right)$,\n- $(\\omega,h)=\\left(0.80,2\\times 10^{-3}\\right)$,\n- $(\\omega,h)=\\left(1.50,5\\times 10^{-3}\\right)$,\n- $(\\omega,h)=\\left(2.50,10^{-2}\\right)$.\n\nIn addition, include two edge cases to probe numerical stability:\n- $(\\omega,h)=\\left(0.00,10^{-6}\\right)$,\n- $(\\omega,h)=\\left(2.00,5\\times 10^{-4}\\right)$.\n\nAll energies and frequencies must be treated in $\\mathrm{MeV}$, and all angular-momentum expectation values are dimensionless due to $\\hbar=1$. For each test case, compute the absolute difference\n$$\n\\Delta(\\omega,h)=\\left|\\frac{\\partial \\langle \\hat{J}_x\\rangle}{\\partial \\omega}\\bigg|_{\\omega}-\\frac{\\partial^2 E}{\\partial \\omega^2}\\bigg|_{\\omega}\\right|\n$$\nand evaluate whether $\\Delta(\\omega,h)<\\varepsilon$ with a tolerance $\\varepsilon=10^{-6}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with one Boolean per test case in the order listed above (e.g., $[\\mathrm{True},\\mathrm{False},\\dots]$).", "solution": "The objective is to numerically verify the consistency relation for the dynamic moment of inertia, $J^{(2)}(\\omega) = \\frac{\\partial \\langle \\hat{J}_x \\rangle}{\\partial \\omega} = \\frac{\\partial^2 E}{\\partial \\omega^2}$, within the framework of a cranked single-particle model. This verification will be performed for a single nucleon in a truncated angular-momentum subspace with total angular momentum $j=\\frac{3}{2}$. The procedure involves constructing the relevant quantum mechanical operators as matrices, solving the eigenvalue problem for the Routhian, and then using finite differences to approximate the derivatives.\n\nFirst, we establish the mathematical representation of the physical system. The single-particle states are $|j, m\\rangle$, where the total angular momentum is fixed at $j=\\frac{3}{2}$ and the magnetic quantum number $m$ takes values in the set $\\left\\{-\\frac{3}{2}, -\\frac{1}{2}, \\frac{1}{2}, \\frac{3}{2}\\right\\}$. This defines a $4$-dimensional Hilbert space. We establish an ordered basis corresponding to increasing $m$:\n$$\n|1\\rangle \\equiv |\\frac{3}{2}, -\\frac{3}{2}\\rangle, \\quad |2\\rangle \\equiv |\\frac{3}{2}, -\\frac{1}{2}\\rangle, \\quad |3\\rangle \\equiv |\\frac{3}{2}, \\frac{1}{2}\\rangle, \\quad |4\\rangle \\equiv |\\frac{3}{2}, \\frac{3}{2}\\rangle\n$$\nIn this basis, the non-cranked Hamiltonian $H_0$ is a diagonal matrix whose elements are the given single-particle energies $E_m$:\n$$\nH_0 = \\mathrm{diag}(E_{-3/2}, E_{-1/2}, E_{1/2}, E_{3/2}) = \\begin{pmatrix} 0.00 & 0 & 0 & 0 \\\\ 0 & 0.85 & 0 & 0 \\\\ 0 & 0 & 1.70 & 0 \\\\ 0 & 0 & 0 & 2.80 \\end{pmatrix} \\, \\mathrm{MeV}\n$$\n\nNext, we construct the matrix for the angular momentum operator $\\hat{J}_x$. This is done via the ladder operators $\\hat{J}_+$ and $\\hat{J}_-$, as $\\hat{J}_x = \\frac{1}{2}(\\hat{J}_+ + \\hat{J}_-)$. The matrix elements of $\\hat{J}_\\pm$ in the $|j,m\\rangle$ basis are given by the formula (with $\\hbar=1$):\n$$\n\\langle j,m'|\\hat{J}_\\pm|j,m\\rangle = \\sqrt{j(j+1)-m(m\\pm 1)}\\,\\delta_{m',m\\pm 1}\n$$\nFor $j=\\frac{3}{2}$, the term $j(j+1) = \\frac{15}{4}$. The non-zero matrix elements of $\\hat{J}_+$ are:\n- $\\langle \\frac{3}{2}, -\\frac{1}{2} | \\hat{J}_+ | \\frac{3}{2}, -\\frac{3}{2} \\rangle = \\sqrt{\\frac{15}{4} - (-\\frac{3}{2})(-\\frac{1}{2})} = \\sqrt{3}$\n- $\\langle \\frac{3}{2}, \\frac{1}{2} | \\hat{J}_+ | \\frac{3}{2}, -\\frac{1}{2} \\rangle = \\sqrt{\\frac{15}{4} - (-\\frac{1}{2})(\\frac{1}{2})} = 2$\n- $\\langle \\frac{3}{2}, \\frac{3}{2} | \\hat{J}_+ | \\frac{3}{2}, \\frac{1}{2} \\rangle = \\sqrt{\\frac{15}{4} - (\\frac{1}{2})(\\frac{3}{2})} = \\sqrt{3}$\n\nThis gives the matrix representation of $\\hat{J}_+$ in our ordered basis. The operator $\\hat{J}_-$ is its Hermitian conjugate, $\\hat{J}_- = (\\hat{J}_+)^\\dagger$.\n$$\nJ_+ = \\begin{pmatrix} 0 & 0 & 0 & 0 \\\\ \\sqrt{3} & 0 & 0 & 0 \\\\ 0 & 2 & 0 & 0 \\\\ 0 & 0 & \\sqrt{3} & 0 \\end{pmatrix}, \\quad J_- = \\begin{pmatrix} 0 & \\sqrt{3} & 0 & 0 \\\\ 0 & 0 & 2 & 0 \\\\ 0 & 0 & 0 & \\sqrt{3} \\\\ 0 & 0 & 0 & 0 \\end{pmatrix}\n$$\nThe matrix for $\\hat{J}_x$ is then:\n$$\nJ_x = \\frac{1}{2}(J_+ + J_-) = \\frac{1}{2} \\begin{pmatrix}\n0 & \\sqrt{3} & 0 & 0 \\\\\n\\sqrt{3} & 0 & 2 & 0 \\\\\n0 & 2 & 0 & \\sqrt{3} \\\\\n0 & 0 & \\sqrt{3} & 0\n\\end{pmatrix}\n$$\nThe system's dynamics under rotation are described by the Routhian, $R(\\omega) = H_0 - \\omega \\hat{J}_x$. For a given rotational frequency $\\omega$, we solve the time-independent Schrödinger equation for the Routhian, $R(\\omega)|\\psi(\\omega)\\rangle = \\lambda(\\omega)|\\psi(\\omega)\\rangle$. We are interested in the ground state, which corresponds to the lowest eigenvalue $\\lambda_{\\min}(\\omega)$ and its associated eigenvector $|\\psi(\\omega)\\rangle$.\n\nThe physical energy-like functional is $E(\\omega) = -\\langle R(\\omega) \\rangle$. For an eigenstate, this simplifies to $E(\\omega) = -\\lambda(\\omega)$. Thus, for the ground state, $E(\\omega) = -\\lambda_{\\min}(\\omega)$. The expectation value of the angular momentum is $\\langle \\hat{J}_x \\rangle (\\omega) = \\langle \\psi(\\omega) | \\hat{J}_x | \\psi(\\omega) \\rangle$.\n\nThe relation to be verified, $\\frac{\\partial \\langle \\hat{J}_x \\rangle}{\\partial \\omega} = \\frac{\\partial^2 E}{\\partial \\omega^2}$, is a consequence of the Feynman-Hellmann theorem. Applying the theorem to the Routhian eigenvalue $\\lambda_{\\min}(\\omega)$ with respect to the parameter $\\omega$ yields $\\frac{\\partial \\lambda_{\\min}}{\\partial \\omega} = \\langle \\psi(\\omega) | \\frac{\\partial R}{\\partial \\omega} | \\psi(\\omega) \\rangle = \\langle \\psi(\\omega) | (-\\hat{J}_x) | \\psi(\\omega) \\rangle = -\\langle \\hat{J}_x \\rangle(\\omega)$. Since $E(\\omega) = -\\lambda_{\\min}(\\omega)$, we have $\\frac{\\partial E}{\\partial \\omega} = \\langle \\hat{J}_x \\rangle(\\omega)$. Differentiating once more with respect to $\\omega$ gives the desired identity.\n\nThe numerical algorithm proceeds as follows for each $(\\omega,h)$ pair from the test suite:\n1.  Define a function that, for any input frequency $\\omega'$, constructs the $4 \\times 4$ real symmetric matrix $R(\\omega') = H_0 - \\omega' J_x$.\n2.  Numerically diagonalize $R(\\omega')$ to obtain its eigenvalues and eigenvectors. Standard numerical libraries provide robust methods for this. We identify the lowest eigenvalue $\\lambda_{\\min}(\\omega')$ and the corresponding eigenvector $|\\psi(\\omega')\\rangle$.\n3.  Calculate the two quantities of interest: $E(\\omega') = -\\lambda_{\\min}(\\omega')$ and $\\langle \\hat{J}_x \\rangle (\\omega') = \\langle \\psi(\\omega') | J_x | \\psi(\\omega') \\rangle$.\n4.  Apply this function for the three required frequency points: $\\omega$, $\\omega+h$, and $\\omega-h$.\n5.  Use the computed values to calculate the two finite-difference approximations:\n    $$\n    \\frac{\\partial \\langle \\hat{J}_x\\rangle}{\\partial \\omega}\\bigg|_{\\omega}\\approx \\frac{\\langle \\hat{J}_x\\rangle(\\omega+h)-\\langle \\hat{J}_x\\rangle(\\omega-h)}{2h}\n    $$\n    $$\n    \\frac{\\partial^2 E}{\\partial \\omega^2}\\bigg|_{\\omega}\\approx \\frac{E(\\omega+h)-2E(\\omega)+E(\\omega-h)}{h^2}\n    $$\n6.  Compute the absolute difference $\\Delta(\\omega,h)$ between these two approximations.\n7.  Compare $\\Delta(\\omega,h)$ to the tolerance $\\varepsilon = 10^{-6}$ to determine if the relation holds numerically. The result is a Boolean value.\n\nThis procedure is systematically applied to all test cases, and the resulting list of Boolean values constitutes the final answer. The use of double-precision floating-point numbers is essential for achieving the required accuracy, especially for small values of the step size $h$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the cranked single-particle model problem by numerically verifying\n    the consistency relation J^(2)(omega) = d<Jx>/d(omega) = d^2E/d(omega)^2.\n    \"\"\"\n    \n    # Define physical constants and model parameters\n    J_TOTAL = 3/2.0\n    ENERGIES_MEV = np.array([0.00, 0.85, 1.70, 2.80])\n    TOLERANCE = 1e-6\n    \n    # The basis is ordered by m = -3/2, -1/2, 1/2, 3/2\n    M_VALUES = np.arange(-J_TOTAL, J_TOTAL + 1, 1.0)\n    DIM = len(M_VALUES)\n\n    # Construct the non-cranked Hamiltonian H0\n    H0 = np.diag(ENERGIES_MEV)\n\n    # Construct the angular momentum operator Jx\n    # Jx = 0.5 * (J+ + J-)\n    J_plus = np.zeros((DIM, DIM), dtype=float)\n    for i in range(DIM - 1):\n        m = M_VALUES[i]\n        # Matrix element <m+1|J+|m>\n        val = np.sqrt(J_TOTAL * (J_TOTAL + 1) - m * (m + 1))\n        J_plus[i + 1, i] = val\n\n    J_minus = J_plus.T\n    Jx = 0.5 * (J_plus + J_minus)\n\n    # Test suite of (omega, h) pairs in MeV\n    test_cases = [\n        (0.00, 1e-3),\n        (0.20, 5e-3),\n        (0.80, 2e-3),\n        (1.50, 5e-3),\n        (2.50, 1e-2),\n        (0.00, 1e-6),\n        (2.00, 5e-4),\n    ]\n\n    results = []\n\n    def calculate_observables(omega_val):\n        \"\"\"\n        For a given rotational frequency omega_val, constructs the Routhian R,\n        finds its ground state, and calculates the energy functional E\n        and the expectation value of Jx.\n\n        Args:\n            omega_val (float): The rotational frequency in MeV.\n\n        Returns:\n            tuple: A tuple containing (E(omega), <Jx>(omega)).\n        \"\"\"\n        # Construct the Routhian matrix R(omega) = H0 - omega * Jx\n        R_omega = H0 - omega_val * Jx\n        \n        # Diagonalize the Hermitian matrix R_omega. np.linalg.eigh returns\n        # eigenvalues in ascending order and corresponding eigenvectors.\n        eigenvalues, eigenvectors = np.linalg.eigh(R_omega)\n        \n        # The ground state corresponds to the lowest eigenvalue\n        lambda_min = eigenvalues[0]\n        psi_gs = eigenvectors[:, 0]\n        \n        # Calculate the energy functional E(omega) = -lambda_min\n        E_omega = -lambda_min\n        \n        # Calculate the expectation value <Jx>(omega) = <psi|Jx|psi>\n        # For real vectors, psi.T is the conjugate transpose.\n        Jx_exp = psi_gs.T @ Jx @ psi_gs\n        \n        return E_omega, Jx_exp\n\n    # Iterate through each test case\n    for omega_c, h in test_cases:\n        # Calculate observables at omega_c, omega_c + h, and omega_c - h\n        E_c, Jx_c = calculate_observables(omega_c)\n        E_p, Jx_p = calculate_observables(omega_c + h)\n        E_m, Jx_m = calculate_observables(omega_c - h)\n        \n        # Approximate the derivative d<Jx>/d(omega) using a symmetric finite difference\n        dJxdw_approx = (Jx_p - Jx_m) / (2.0 * h)\n        \n        # Approximate the second derivative d^2E/d(omega)^2 using a central difference\n        d2Edw2_approx = (E_p - 2.0 * E_c + E_m) / (h * h)\n        \n        # Compute the absolute difference and check against the tolerance\n        abs_diff = np.abs(dJxdw_approx - d2Edw2_approx)\n        results.append(abs_diff  TOLERANCE)\n\n    # Print the final result in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3548296"}, {"introduction": "Real nuclei, especially those near the limits of stability, are open quantum systems where bound states coexist with a continuum of unbound and resonant states. This practice explores how these continuum effects, modeled by complex-energy Gamow states, influence the nucleus's rotational response [@problem_id:3548279]. You will move from the familiar realm of Hermitian quantum mechanics to a non-Hermitian framework, adapting your computational tools to handle complex-symmetric Hamiltonians and specialized inner products. This exercise equips you with methods to tackle open quantum systems, a frontier in theoretical nuclear physics, and reveals how continuum coupling can alter fundamental properties like the moment of inertia.", "problem": "You are asked to design and implement a computational experiment that isolates how continuum and resonant (Gamow) contributions modify rotational response in weakly bound nuclear systems and, consequently, affect the calculation of the moment of inertia.\n\nStarting point and modeling assumptions to be used:\n- The time-independent Schrödinger equation in a finite basis is written as $H(\\omega)\\,| \\psi(\\omega) \\rangle = \\lambda(\\omega)\\,| \\psi(\\omega) \\rangle$, where $H(\\omega)$ is a finite-dimensional matrix representation of the microscopic Hamiltonian, $| \\psi(\\omega) \\rangle$ is the right eigenvector, and $\\lambda(\\omega)$ is the corresponding eigenvalue.\n- Weakly bound nuclei near particle emission thresholds are modeled by a finite set of discrete states. Bound states are assigned real energies, while resonances are represented by Gamow states with complex energies $E = E_r - i \\Gamma/2$, producing a complex-symmetric Hamiltonian when outgoing-wave boundary conditions are used. This captures continuum coupling and particle decay widths.\n- Rotation is introduced through a cranking field that couples linearly to the angular momentum projection operator $\\hat{J}_x$, producing a family of Hamiltonians $H(\\omega)$ that depend linearly on a small cranking frequency parameter $\\omega$ with units of energy, consistent with natural nuclear units where $\\hbar = 1$.\n\nExpectations in non-Hermitian (complex-symmetric) settings:\n- For complex-symmetric matrices, the appropriate bi-orthogonal inner product is the complex-symmetric $c$-product. If $H$ is complex-symmetric, the left eigenvector can be taken as the transpose of the right eigenvector. For any operator $\\hat{O}$ and state $| \\psi \\rangle$ the expectation value is computed as $\\langle \\hat{O} \\rangle = \\dfrac{\\langle \\psi| \\hat{O} | \\psi \\rangle_c}{\\langle \\psi | \\psi \\rangle_c}$ with the $c$-product $\\langle \\phi | \\psi \\rangle_c \\equiv \\phi^{\\mathsf{T}} \\psi$.\n\nYour tasks:\n1. Consider $H(\\omega) = D - \\omega J_x$, where $D = \\mathrm{diag}(E_1,E_2,\\dots,E_N)$ is the diagonal matrix of state energies and $J_x$ is a real-symmetric matrix representation of $\\hat{J}_x$ in the chosen basis.\n2. For each test case below, compute the ground-like state (the eigenstate whose eigenvalue has the smallest real part) of $H(\\omega)$ for two small values $\\omega = +\\delta$ and $\\omega = -\\delta$ with $\\delta = 1\\times 10^{-3}$ in $\\mathrm{MeV}$.\n3. For each of the two $\\omega$ values, evaluate the expectation $\\langle \\hat{J}_x \\rangle_{\\omega}$ using the complex-symmetric $c$-product appropriate to the Gamow basis.\n4. Numerically infer the linear rotational response coefficient $C$ at $\\omega=0$ by a symmetric finite difference, $C$ defined as the slope of the real part of $\\langle \\hat{J}_x \\rangle_{\\omega}$ at zero cranking frequency. Explicitly compute $C$ from $\\omega=\\pm \\delta$.\n5. Repeat steps $2$–$4$ for a baseline in which all energies are replaced by their real parts (i.e., all widths are set to zero, removing continuum decay effects), producing $C_{\\mathrm{real\\_only}}$.\n6. Quantify the change attributable to complex-energy contributions by computing $\\Delta C = C_{\\mathrm{complex}} - C_{\\mathrm{real\\_only}}$ for each test case. Report the real-valued quantity $\\Delta C$.\n7. Express the final results in $\\mathrm{MeV}^{-1}$, rounded to six decimal places.\n\nTest suite (all energies are in $\\mathrm{MeV}$; matrices are dimensioned to match the number of states):\n- Case A (bound-only baseline):\n  - Energies: $E = \\left[ -2.0,\\,-1.0 \\right]$.\n  - Operator: $J_x = \\begin{pmatrix} 0.0  0.5 \\\\ 0.5  0.0 \\end{pmatrix}$.\n- Case B (one narrow resonance):\n  - Energies: $E = \\left[ -2.0,\\,-1.0,\\,1.5 - i\\,0.1 \\right]$.\n  - Operator: $J_x = \\begin{pmatrix} 0.0  0.5  0.3 \\\\ 0.5  0.0  0.2 \\\\ 0.3  0.2  0.0 \\end{pmatrix}$.\n- Case C (one broad resonance):\n  - Energies: $E = \\left[ -2.0,\\,-1.5,\\,4.0 - i\\,0.8 \\right]$.\n  - Operator: $J_x = \\begin{pmatrix} 0.0  0.4  0.25 \\\\ 0.4  0.0  0.35 \\\\ 0.25  0.35  0.0 \\end{pmatrix}$.\n- Case D (near-threshold weakly bound state and multiple resonances):\n  - Energies: $E = \\left[ -0.05,\\,0.7 - i\\,0.05,\\,2.0 - i\\,0.5 \\right]$.\n  - Operator: $J_x = \\begin{pmatrix} 0.0  0.6  0.2 \\\\ 0.6  0.0  0.4 \\\\ 0.2  0.4  0.0 \\end{pmatrix}$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for the ordered test cases A, B, C, D. Each entry must be the real-valued $\\Delta C$ in $\\mathrm{MeV}^{-1}$, rounded to six decimal places. For example, an output should look like $\\left[0.000123,0.001234,0.000987,0.000456\\right]$ (this is only an example; compute the actual values from the model above).", "solution": "The problem requires the design and execution of a computational experiment to quantify the influence of continuum coupling, represented by complex Gamow state energies, on the rotational response of a weakly bound nuclear system. The rotational response is characterized by the linear response coefficient $C$, which is related to the moment of inertia. The objective is to compute the difference, $\\Delta C$, between the response coefficient calculated with complex energies ($C_{\\mathrm{complex}}$) and a baseline calculated with only the real parts of those energies ($C_{\\mathrm{real\\_only}}$).\n\nThe theoretical framework is the time-independent Schrödinger equation for a system under rotation, described within a finite, non-Hermitian (complex-symmetric) basis. The rotational effects are introduced via the cranking model.\n\nThe Hamiltonian of the system is given as a function of the cranking frequency $\\omega$:\n$$\nH(\\omega) = D - \\omega J_x\n$$\nHere, $D$ is a diagonal matrix, $D = \\mathrm{diag}(E_1, E_2, \\dots, E_N)$, whose elements $E_k$ are the energies of the basis states. These energies can be real for bound states or complex for resonant (Gamow) states, where a complex energy $E_k = E_{r,k} - i\\Gamma_k/2$ represents a resonance at energy $E_{r,k}$ with a decay width $\\Gamma_k$. The matrix $J_x$ is the real-symmetric representation of the angular momentum projection operator $\\hat{J}_x$. The parameter $\\omega$ is a small real number with units of energy. Since $D$ can be complex and $J_x$ is real-symmetric, the total Hamiltonian $H(\\omega)$ is a complex-symmetric matrix, i.e., $H(\\omega) = H(\\omega)^{\\mathsf{T}}$.\n\nThe core of the calculation involves solving the eigenvalue problem for this Hamiltonian at two small, symmetric cranking frequencies, $\\omega = +\\delta$ and $\\omega = -\\delta$, where $\\delta = 1 \\times 10^{-3} \\, \\mathrm{MeV}$:\n$$\nH(\\omega) \\, | \\psi_j(\\omega) \\rangle = \\lambda_j(\\omega) \\, | \\psi_j(\\omega) \\rangle\n$$\nThis yields a set of eigenvalues $\\lambda_j(\\omega)$ and corresponding right eigenvectors $|\\psi_j(\\omega)\\rangle$. We are interested in the \"ground-like\" state, which is defined as the eigenstate whose eigenvalue $\\lambda(\\omega)$ has the smallest real part. This state is the adiabatically continued ground state of the non-rotating system.\n\nFor a complex-symmetric Hamiltonian, the standard Hermitian inner product is not appropriate. Instead, we use the bi-orthogonal or complex-symmetric ($c$-) product. The expectation value of an operator $\\hat{O}$ for a state $|\\psi\\rangle$ is given by:\n$$\n\\langle \\hat{O} \\rangle = \\frac{\\langle \\psi | \\hat{O} | \\psi \\rangle_c}{\\langle \\psi | \\psi \\rangle_c}\n$$\nwhere the $c$-product is defined as $\\langle \\phi | \\psi \\rangle_c \\equiv \\phi^{\\mathsf{T}} \\psi$. Here, $\\phi^{\\mathsf{T}}$ is the transpose of the column vector $\\phi$. Computationally, if $\\psi$ is a column vector, this translates to $\\psi^{\\mathsf{T}} O \\psi / (\\psi^{\\mathsf{T}} \\psi)$.\n\nUsing the ground-like state eigenvector, we compute the expectation value of the angular momentum, $\\langle J_x \\rangle_{\\omega}$, for both $\\omega = +\\delta$ and $\\omega = -\\delta$.\n\nThe linear rotational response coefficient, $C$, is defined as the rate of change of the real part of the angular momentum expectation value with respect to the cranking frequency, evaluated at $\\omega=0$:\n$$\nC = \\left. \\frac{d}{d\\omega} \\mathrm{Re} \\left( \\langle J_x \\rangle_{\\omega} \\right) \\right|_{\\omega=0}\n$$\nWe approximate this derivative numerically using a symmetric finite difference scheme, which provides a second-order accurate approximation:\n$$\nC \\approx \\frac{\\mathrm{Re}(\\langle J_x \\rangle_{+\\delta}) - \\mathrm{Re}(\\langle J_x \\rangle_{-\\delta})}{(+\\delta) - (-\\delta)} = \\frac{\\mathrm{Re}(\\langle J_x \\rangle_{+\\delta}) - \\mathrm{Re}(\\langle J_x \\rangle_{-\\delta})}{2\\delta}\n$$\n\nTo isolate the effect of the continuum, we perform this calculation twice for each test case:\n1.  **Complex Calculation**: We use the full set of complex energies $E_k$ to construct $D$, leading to a complex-symmetric $H(\\omega)$. The procedure described above yields the coefficient $C_{\\mathrm{complex}}$.\n2.  **Real-Only Baseline**: We create a baseline Hamiltonian by setting all decay widths $\\Gamma_k$ to zero. This is achieved by taking only the real parts of the energies, $E_{k,\\mathrm{real}} = \\mathrm{Re}(E_k)$, to construct a real-diagonal matrix $D_{\\mathrm{real}}$. The resulting Hamiltonian, $H_{\\mathrm{real\\_only}}(\\omega) = D_{\\mathrm{real}} - \\omega J_x$, is real-symmetric. The same procedure yields the coefficient $C_{\\mathrm{real\\_only}}$.\n\nThe final quantity of interest is the difference between these two coefficients, which quantifies the change in rotational response due solely to the presence of decay widths:\n$$\n\\Delta C = C_{\\mathrm{complex}} - C_{\\mathrm{real\\_only}}\n$$\n\nThe algorithm for each test case is as follows:\n1.  Define the list of energies $E$ and the matrix $J_x$.\n2.  Define $\\delta = 1 \\times 10^{-3}$.\n3.  Calculate $C_{\\mathrm{complex}}$:\n    a. Construct $D = \\mathrm{diag}(E)$.\n    b. Solve the eigenproblem for $H(+\\delta) = D - \\delta J_x$ and $H(-\\delta) = D + \\delta J_x$.\n    c. For each, find the eigenvector corresponding to the eigenvalue with the minimum real part.\n    d. Compute $\\langle J_x \\rangle_{+\\delta}$ and $\\langle J_x \\rangle_{-\\delta}$ using the c-product.\n    e. Compute $C_{\\mathrm{complex}}$ using the finite difference formula.\n4.  Calculate $C_{\\mathrm{real\\_only}}$:\n    a. Construct $E_{\\mathrm{real}} = \\mathrm{Re}(E)$.\n    b. Repeat step 3 using $E_{\\mathrm{real}}$ to find $C_{\\mathrm{real\\_only}}$.\n5.  Compute $\\Delta C = C_{\\mathrm{complex}} - C_{\\mathrm{real\\_only}}$.\n6.  The final result for each test case is $\\Delta C$, reported in $\\mathrm{MeV}^{-1}$ and rounded to six decimal places.\n\nThis procedure will be implemented for each of the four test cases provided.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the computational nuclear physics problem.\n    It iterates through the test cases, calculates the change in the\n    rotational response coefficient (Delta C), and prints the results.\n    \"\"\"\n\n    def calculate_response_coefficient(energies, Jx, delta):\n        \"\"\"\n        Calculates the linear rotational response coefficient C.\n\n        Args:\n            energies (list or np.ndarray): A list of state energies (can be complex).\n            Jx (np.ndarray): The matrix representation of the Jx operator.\n            delta (float): The small cranking frequency value.\n\n        Returns:\n            float: The calculated response coefficient C.\n        \"\"\"\n        # Ensure energies are of complex type for consistent calculations.\n        D = np.diag(np.asarray(energies, dtype=complex))\n\n        # --- Calculation for omega = +delta ---\n        H_plus = D - delta * Jx\n        # Solve the eigenvalue problem for the complex-symmetric Hamiltonian.\n        eigvals_p, eigvecs_p = np.linalg.eig(H_plus)\n        # Identify the ground-like state (minimum real part of eigenvalue).\n        idx_p = np.argmin(np.real(eigvals_p))\n        psi_p = eigvecs_p[:, idx_p]\n        # Compute the expectation value using the c-product.\n        # psi_p is a 1D array, so @ is dot product.\n        j_exp_p = (psi_p @ Jx @ psi_p) / (psi_p @ psi_p)\n\n        # --- Calculation for omega = -delta ---\n        H_minus = D + delta * Jx\n        eigvals_m, eigvecs_m = np.linalg.eig(H_minus)\n        idx_m = np.argmin(np.real(eigvals_m))\n        psi_m = eigvecs_m[:, idx_m]\n        j_exp_m = (psi_m @ Jx @ psi_m) / (psi_m @ psi_m)\n\n        # Compute C using a symmetric finite difference formula.\n        C = (np.real(j_exp_p) - np.real(j_exp_m)) / (2.0 * delta)\n        return C\n\n    # Define the cranking frequency delta.\n    delta = 1.0e-3  # in MeV\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (bound-only baseline)\n        {\n            \"E\": [-2.0, -1.0],\n            \"Jx\": np.array([[0.0, 0.5], [0.5, 0.0]])\n        },\n        # Case B (one narrow resonance)\n        {\n            \"E\": [-2.0, -1.0, 1.5 - 0.1j],\n            \"Jx\": np.array([[0.0, 0.5, 0.3], [0.5, 0.0, 0.2], [0.3, 0.2, 0.0]])\n        },\n        # Case C (one broad resonance)\n        {\n            \"E\": [-2.0, -1.5, 4.0 - 0.8j],\n            \"Jx\": np.array([[0.0, 0.4, 0.25], [0.4, 0.0, 0.35], [0.25, 0.35, 0.0]])\n        },\n        # Case D (near-threshold weakly bound state and multiple resonances)\n        {\n            \"E\": [-0.05, 0.7 - 0.05j, 2.0 - 0.5j],\n            \"Jx\": np.array([[0.0, 0.6, 0.2], [0.6, 0.0, 0.4], [0.2, 0.4, 0.0]])\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        E = case[\"E\"]\n        Jx = case[\"Jx\"]\n\n        # 1. Calculate the response coefficient with complex energies.\n        C_complex = calculate_response_coefficient(E, Jx, delta)\n\n        # 2. Calculate the baseline response coefficient with real-only energies.\n        E_real_only = np.real(np.asarray(E))\n        C_real_only = calculate_response_coefficient(E_real_only, Jx, delta)\n\n        # 3. Compute the difference to isolate the continuum contribution.\n        delta_C = C_complex - C_real_only\n        results.append(delta_C)\n\n    # Final print statement in the exact required format.\n    # Each result is formatted to six decimal places.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3548279"}, {"introduction": "Our theoretical models, such as Energy Density Functionals (EDFs), depend on numerous parameters fit to experimental data. Understanding how predictions vary with these parameters is crucial for quantifying model uncertainties and guiding future experiments. This practice introduces the adjoint method, a powerful and efficient technique for calculating the sensitivity derivatives of an observable with respect to many model parameters [@problem_id:3548292]. By deriving and implementing this method for an abstracted problem, you will gain a computationally inexpensive tool for large-scale sensitivity analysis, a critical skill in modern computational science that extends far beyond nuclear physics.", "problem": "You are given a simplified, finite-dimensional model that abstracts the sensitivity of the nuclear moment of inertia to Energy Density Functional (EDF) tensor couplings in the Skyrme-type framework. The goal is to compute the sensitivity derivatives of the moment of inertia with respect to isoscalar and isovector tensor couplings using the adjoint method, and then to identify which coupling more strongly controls the moment of inertia. All quantities are nondimensionalized; report all computed derivatives as dimensionless numbers. Angles do not appear in this problem.\n\nFundamental base: The model is built from the following principles, which you must use to derive the algorithm and the program:\n- The equilibrium configuration of generalized local densities (collectively denoted by a vector $x$) in a cranking calculation at vanishing rotational frequency ($\\omega \\to 0$) is obtained from the stationary condition of the energy functional, which leads to the Euler–Lagrange equations. In a quadratic approximation, this yields a linear system of the form\n$$\nF(x, C) = A(C)\\,x - b = 0,\n$$\nwhere $A(C)$ is a symmetric positive-definite matrix depending linearly on a set of EDF parameters $C$, and $b$ is a constant source vector.\n- The Thouless–Valatin moment of inertia (in nondimensionalized units) is approximated by a quadratic form\n$$\nJ(x) = x^\\top W\\,x,\n$$\nwhere $W$ is a symmetric matrix that encodes the inertia kernel in the small-amplitude limit.\n- The sensitivity derivative of $J$ with respect to a parameter $C$ where the state $x$ satisfies the stationary condition must be computed by differentiating the constrained problem. The adjoint method provides a principled way to obtain this derivative without explicitly differentiating $x$ with respect to parameters. Start from the definitions above and derive the adjoint equation and the expression for the sensitivity $\\partial J/\\partial C$.\n\nIn this problem, the EDF tensor couplings are restricted to two parameters: the isoscalar coupling $C_0^{J}$ and the isovector coupling $C_1^{J}$. The parameter-dependent stiffness matrix is\n$$\nA(C_0^{J}, C_1^{J}) = A_0 + C_0^{J}\\,M_0 + C_1^{J}\\,M_1,\n$$\nwith\n$$\nA_0 =\n\\begin{bmatrix}\n10.0  0.3  0.0  0.0 \\\\\n0.3  9.0  0.25  0.0 \\\\\n0.0  0.25  8.0  0.2 \\\\\n0.0  0.0  0.2  7.0\n\\end{bmatrix},\\quad\nM_0 =\n\\begin{bmatrix}\n0.40  0.05  0.00  0.00 \\\\\n0.05  0.35  0.05  0.00 \\\\\n0.00  0.05  0.30  0.05 \\\\\n0.00  0.00  0.05  0.25\n\\end{bmatrix},\n$$\n$$\nM_1 =\n\\begin{bmatrix}\n0.30  0.04  0.00  0.00 \\\\\n0.04  0.28  0.04  0.00 \\\\\n0.00  0.04  0.26  0.04 \\\\\n0.00  0.00  0.04  0.22\n\\end{bmatrix},\\quad\nb =\n\\begin{bmatrix}\n1.2 \\\\ -0.8 \\\\ 0.5 \\\\ 0.7\n\\end{bmatrix},\n$$\nand\n$$\nW =\n\\begin{bmatrix}\n0.60  0.00  0.05  0.00 \\\\\n0.00  0.50  0.00  0.04 \\\\\n0.05  0.00  0.40  0.00 \\\\\n0.00  0.04  0.00  0.30\n\\end{bmatrix}.\n$$\nFor any given $(C_0^{J}, C_1^{J})$, the equilibrium state $x$ is defined by solving\n$$\nA(C_0^{J}, C_1^{J})\\,x = b.\n$$\nThen compute $J(x) = x^\\top W x$.\n\nTask:\n1. Starting from the stationary condition and the definition of $J(x)$, derive the adjoint equation and the final expression for the sensitivity derivatives $\\partial J/\\partial C_0^{J}$ and $\\partial J/\\partial C_1^{J}$, in terms of $x$, $A$, $W$, $M_0$, and $M_1$. The derivation must begin from the stated fundamental base and must not assume any shortcut formulas.\n2. Implement a program that:\n   - For each test case, constructs $A(C_0^{J}, C_1^{J})$, solves for $x$, computes $J(x)$, solves the adjoint system, and evaluates the sensitivities $\\partial J/\\partial C_0^{J}$ and $\\partial J/\\partial C_1^{J}$.\n   - Validates the adjoint sensitivities against central finite differences using a small perturbation $\\varepsilon = 10^{-6}$:\n     $$\n     \\frac{\\partial J}{\\partial C_t^{J}} \\approx \\frac{J(C_t^{J} + \\varepsilon) - J(C_t^{J} - \\varepsilon)}{2\\varepsilon},\\quad t\\in\\{0,1\\}.\n     $$\n     Use a tolerance of $10^{-5}$ on the relative error defined as\n     $$\n     \\text{rel\\_err} = \\frac{\\left|\\text{adjoint} - \\text{finite\\_difference}\\right|}{\\left|\\text{finite\\_difference}\\right| + 10^{-12}}.\n     $$\n   - Identifies the dominant parameter controlling $J$ in each test case as the index $t\\in\\{0,1\\}$ of the coupling with the largest absolute sensitivity.\n3. Output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case result must be a list of four entries: the two sensitivity derivatives (rounded to eight decimal places), the integer index of the dominant coupling, and a boolean indicating whether both adjoint derivatives passed the validation tolerance. The final output must therefore look like\n$$\n[\\,[d_0, d_1, t_{\\max}, \\text{bool}],\\,[\\dots],\\,[\\dots]\\,],\n$$\nwith numeric entries expressed as plain numbers. All derivatives are dimensionless.\n\nTest suite:\n- Case $1$: $(C_0^{J}, C_1^{J}) = (0.12, -0.08)$.\n- Case $2$ (boundary case): $(C_0^{J}, C_1^{J}) = (0.0, 0.0)$.\n- Case $3$ (stronger coupling case while maintaining positive-definiteness): $(C_0^{J}, C_1^{J}) = (0.25, 0.18)$.\n\nYour program must implement the adjoint method; do not compute $\\partial J/\\partial C_t^{J}$ by differentiating $x$ explicitly. All reported derivatives are dimensionless numbers, and you must round the derivatives to eight decimal places in the final output.", "solution": "The problem requires the derivation of the adjoint method for calculating the sensitivity derivatives $\\frac{\\mathrm{d}J}{\\mathrm{d}C_t^J}$ and its subsequent implementation. The system is defined by an observable, the moment of inertia $J(x) = x^\\top W x$, and a state equation that defines the equilibrium state vector $x$: $F(x, C) = A(C)x - b = 0$. The parameters are $C = (C_0^J, C_1^J)$. Since the state $x$ depends on the parameters $C$, the total derivative of $J$ with respect to a parameter $C_t$ (where $t \\in \\{0,1\\}$) requires the chain rule.\n\nTo avoid computing the complex term $\\frac{\\mathrm{d}x}{\\mathrm{d}C_t^J}$, we introduce a Lagrangian using an arbitrary vector of Lagrange multipliers $\\lambda$, also known as the adjoint state vector:\n$$\n\\mathcal{L}(x, \\lambda, C) = J(x) + \\lambda^\\top F(x, C) = x^\\top W x + \\lambda^\\top(A(C)x - b)\n$$\nSince the physical state $x$ satisfies the constraint $F(x,C)=0$, the value of $\\mathcal{L}$ is identical to $J$ for any choice of $\\lambda$. Consequently, their total derivatives with respect to $C_t^J$ are also equal: $\\frac{\\mathrm{d}J}{\\mathrm{d}C_t^J} = \\frac{\\mathrm{d}\\mathcal{L}}{\\mathrm{d}C_t^J}$. Applying the multivariable chain rule to $\\mathcal{L}$:\n$$\n\\frac{\\mathrm{d}\\mathcal{L}}{\\mathrm{d}C_t^J} = \\frac{\\partial \\mathcal{L}}{\\partial C_t^J} + \\left(\\frac{\\partial \\mathcal{L}}{\\partial x}\\right)^\\top \\frac{\\mathrm{d}x}{\\mathrm{d}C_t^J} + \\left(\\frac{\\partial \\mathcal{L}}{\\partial \\lambda}\\right)^\\top \\frac{\\mathrm{d}\\lambda}{\\mathrm{d}C_t^J}\n$$\nThe term involving the unknown derivative $\\frac{\\mathrm{d}x}{\\mathrm{d}C_t^J}$ can be eliminated by choosing $\\lambda$ such that its coefficient, $\\frac{\\partial \\mathcal{L}}{\\partial x}$, is zero. This gives the **adjoint equation**:\n$$\n\\frac{\\partial \\mathcal{L}}{\\partial x} = \\frac{\\partial}{\\partial x}(x^\\top W x) + \\frac{\\partial}{\\partial x}(\\lambda^\\top A(C)x) = (W+W^\\top)x + A(C)^\\top \\lambda = 0\n$$\nGiven that the matrices $W$ and $A(C)$ are symmetric, this simplifies to the linear system for the adjoint vector $\\lambda$:\n$$\nA(C)\\lambda = -2Wx\n$$\nWith this specific choice for $\\lambda$, the term with $\\frac{\\mathrm{d}x}{\\mathrm{d}C_t^J}$ vanishes. Furthermore, the term involving $\\frac{\\mathrm{d}\\lambda}{\\mathrm{d}C_t^J}$ also vanishes because its coefficient, $\\frac{\\partial \\mathcal{L}}{\\partial \\lambda} = F(x, C)$, is zero by the original state equation. The expression for the sensitivity derivative thus simplifies dramatically to just the partial derivative of the Lagrangian with respect to the parameter:\n$$\n\\frac{\\mathrm{d}J}{\\mathrm{d}C_t^J} = \\frac{\\partial \\mathcal{L}}{\\partial C_t^J} = \\frac{\\partial}{\\partial C_t^J} \\left( x^\\top W x + \\lambda^\\top(A(C)x - b) \\right) = \\lambda^\\top \\left( \\frac{\\partial A(C)}{\\partial C_t^J} x \\right)\n$$\nSince $A(C) = A_0 + C_0^{J}M_0 + C_1^{J}M_1$, the partial derivatives of the matrix $A$ are simply $\\frac{\\partial A}{\\partial C_0^J} = M_0$ and $\\frac{\\partial A}{\\partial C_1^J} = M_1$. Substituting these into the general expression gives the final formulas for the sensitivities:\n$$\n\\frac{\\partial J}{\\partial C_0^J} = \\lambda^\\top M_0 x\n$$\n$$\n\\frac{\\partial J}{\\partial C_1^J} = \\lambda^\\top M_1 x\n$$\nThis derivation leads to an efficient computational algorithm. First, solve the \"forward\" problem $Ax=b$ for the state $x$. Second, use $x$ to solve the \"adjoint\" problem $A\\lambda = -2Wx$ for the adjoint state $\\lambda$. Finally, compute the sensitivities using simple matrix-vector products. This avoids re-solving the main system for every parameter, which is the main advantage of the adjoint method.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes sensitivity derivatives of a model moment of inertia with respect\n    to EDF couplings using the adjoint method, validates the results against\n    finite differences, and formats the output as specified.\n    \"\"\"\n    # Define constant matrices and vector from the problem statement.\n    A0 = np.array([\n        [10.0, 0.3, 0.0, 0.0],\n        [0.3, 9.0, 0.25, 0.0],\n        [0.0, 0.25, 8.0, 0.2],\n        [0.0, 0.0, 0.2, 7.0]\n    ])\n    M0 = np.array([\n        [0.40, 0.05, 0.00, 0.00],\n        [0.05, 0.35, 0.05, 0.00],\n        [0.00, 0.05, 0.30, 0.05],\n        [0.00, 0.00, 0.05, 0.25]\n    ])\n    M1 = np.array([\n        [0.30, 0.04, 0.00, 0.00],\n        [0.04, 0.28, 0.04, 0.00],\n        [0.00, 0.04, 0.26, 0.04],\n        [0.00, 0.00, 0.04, 0.22]\n    ])\n    b = np.array([1.2, -0.8, 0.5, 0.7])\n    W = np.array([\n        [0.60, 0.00, 0.05, 0.00],\n        [0.00, 0.50, 0.00, 0.04],\n        [0.05, 0.00, 0.40, 0.00],\n        [0.00, 0.04, 0.00, 0.30]\n    ])\n\n    # Test cases\n    test_cases = [\n        (0.12, -0.08),\n        (0.0, 0.0),\n        (0.25, 0.18)\n    ]\n\n    all_results = []\n\n    for c0, c1 in test_cases:\n        # --- Adjoint Method Calculation ---\n\n        # 1. Forward solve: A(C)x = b\n        A = A0 + c0 * M0 + c1 * M1\n        x = np.linalg.solve(A, b)\n\n        # 2. Adjoint solve: A(C)λ = -2Wx\n        adjoint_rhs = -2 * (W @ x)\n        lambda_vec = np.linalg.solve(A, adjoint_rhs)\n\n        # 3. Compute sensitivities: dJ/dC = λ^T * (dA/dC) * x\n        dJ_dc0_adj = lambda_vec.T @ M0 @ x\n        dJ_dc1_adj = lambda_vec.T @ M1 @ x\n\n        # --- Validation with Finite Differences ---\n        eps = 1e-6\n        validation_passed = True\n\n        def calculate_J(c0_val, c1_val):\n            \"\"\"Helper function to compute J for given couplings.\"\"\"\n            A_val = A0 + c0_val * M0 + c1_val * M1\n            x_val = np.linalg.solve(A_val, b)\n            return x_val.T @ W @ x_val\n\n        # Validate dJ/dC0\n        J_plus_0 = calculate_J(c0 + eps, c1)\n        J_minus_0 = calculate_J(c0 - eps, c1)\n        dJ_dc0_fd = (J_plus_0 - J_minus_0) / (2 * eps)\n\n        # Validate dJ/dC1\n        J_plus_1 = calculate_J(c0, c1 + eps)\n        J_minus_1 = calculate_J(c0, c1 - eps)\n        dJ_dc1_fd = (J_plus_1 - J_minus_1) / (2 * eps)\n        \n        # Calculate relative errors\n        rel_tol = 1e-5\n        abs_tol_denom = 1e-12\n        rel_err_0 = abs(dJ_dc0_adj - dJ_dc0_fd) / (abs(dJ_dc0_fd) + abs_tol_denom)\n        rel_err_1 = abs(dJ_dc1_adj - dJ_dc1_fd) / (abs(dJ_dc1_fd) + abs_tol_denom)\n\n        if not (rel_err_0  rel_tol and rel_err_1  rel_tol):\n            validation_passed = False\n\n        # --- Identify Dominant Parameter ---\n        dominant_t = 0 if abs(dJ_dc0_adj) > abs(dJ_dc1_adj) else 1\n\n        # --- Store results ---\n        # Round derivatives to 8 decimal places as required for final output\n        d0_rounded = round(dJ_dc0_adj, 8)\n        d1_rounded = round(dJ_dc1_adj, 8)\n        \n        all_results.append([d0_rounded, d1_rounded, dominant_t, validation_passed])\n\n    # --- Format final output string ---\n    # Manually construct string to match [[d0,d1,t,B],[...]] without spaces\n    inner_parts = []\n    for res in all_results:\n        # str(bool) gives 'True' or 'False' as required\n        part = f\"[{res[0]},{res[1]},{res[2]},{str(res[3])}]\"\n        inner_parts.append(part)\n    final_output = f\"[{','.join(inner_parts)}]\"\n\n    print(final_output)\n\nsolve()\n```", "id": "3548292"}]}