{"hands_on_practices": [{"introduction": "Before applying a complex numerical tool to physical problems, it is crucial to verify that its fundamental components are implemented correctly. The angular momentum projection operator is built upon an integral of Wigner D-matrices over the rotation group. This first practice uses the fundamental orthogonality relation of the D-matrices as an exact analytical benchmark, allowing you to build and validate the core three-dimensional quadrature engine that forms the heart of any projection code [@problem_id:3542272].", "problem": "Consider the problem of numerically validating the orthogonality of Wigner rotation matrix elements in the context of angular momentum projection from mean-field states in computational nuclear physics. The Wigner rotation matrix element is defined as $D^{J}_{M K}(\\alpha,\\beta,\\gamma) = \\langle J, M | \\hat{R}(\\alpha,\\beta,\\gamma) | J, K \\rangle$, where $\\hat{R}(\\alpha,\\beta,\\gamma) = e^{-i \\alpha \\hat{J}_{z}} e^{-i \\beta \\hat{J}_{y}} e^{-i \\gamma \\hat{J}_{z}}$, and $\\alpha,\\beta,\\gamma$ are Euler angles in radians. The integration measure on the rotation group is the Haar measure, $d\\Omega = d\\alpha\\,\\sin\\beta\\,d\\beta\\,d\\gamma$, with $\\alpha \\in [0,2\\pi)$, $\\beta \\in [0,\\pi]$, and $\\gamma \\in [0,2\\pi)$.\n\nFrom the fundamental properties of unitary irreducible representations of the Special Orthogonal group of degree three (SO(3)) and their relationship to the Special Unitary group of degree two (SU(2)), it follows that the matrix elements $D^{J}_{M K}(\\alpha,\\beta,\\gamma)$ satisfy an orthogonality relation over the group manifold with respect to the Haar measure. This identity is central to constructing and validating angular-momentum projection operators used to project mean-field states onto good total angular momentum.\n\nYour task is to write a complete program that:\n- Implements $D^{J}_{M K}(\\alpha,\\beta,\\gamma)$ via the factorization $D^{J}_{M K}(\\alpha,\\beta,\\gamma) = e^{-i M \\alpha}\\, d^{J}_{M K}(\\beta)\\, e^{-i K \\gamma}$, with $d^{J}_{M K}(\\beta)$ computed as the matrix element of $e^{-i \\beta \\hat{J}_{y}}$ in the $\\hat{J}_{z}$ eigenbasis for a given $J$.\n- Numerically evaluates the triple integral\n$$\nI(J,J',M,M',K,K') = \\int_{0}^{2\\pi} d\\alpha \\int_{0}^{\\pi} \\sin\\beta\\, d\\beta \\int_{0}^{2\\pi} d\\gamma \\; D^{J}_{M K}(\\alpha,\\beta,\\gamma)\\, \\left[D^{J'}_{M' K'}(\\alpha,\\beta,\\gamma)\\right]^{*}\n$$\nusing the following quadrature choices and angle units:\n  - Angles are in radians.\n  - The $\\alpha$ and $\\gamma$ integrals must use an equally spaced trapezoidal rule with $N_{\\alpha} = N_{\\gamma} = 128$ nodes in $[0,2\\pi)$.\n  - The $\\beta$ integral must use Gaussâ€“Legendre quadrature with $N_{\\beta} = 64$ nodes on $[-1,1]$ applied to the change of variables $x = \\cos\\beta$, so that $\\int_{0}^{\\pi} \\sin\\beta f(\\beta)\\, d\\beta = \\int_{-1}^{1} f(\\arccos x)\\, dx$.\n- Compares the numerical integral $I(J,J',M,M',K,K')$ against the analytic value\n$$\nI_{\\text{analytic}}(J,J',M,M',K,K') = \\frac{8\\pi^{2}}{2J+1}\\, \\delta_{J J'}\\, \\delta_{M M'}\\, \\delta_{K K'}\n$$\nand returns a boolean pass/fail for each test case using the criterion\n$$\n\\left| I - I_{\\text{analytic}} \\right| \\le \\varepsilon \\times \\max\\!\\left(1, \\left| I_{\\text{analytic}} \\right| \\right),\n$$\nwith tolerance $\\varepsilon = 10^{-6}$.\n\nImplementation details and constraints:\n- Construct $\\hat{J}_{y}$ from the ladder operators $\\hat{J}_{\\pm}$ and $\\hat{J}_{z}$ in the standard $\\hat{J}_{z}$ eigenbasis $\\{ | J, m \\rangle \\}_{m=-J,\\dots,+J}$, using $\\hat{J}_{+} | J, m \\rangle = \\sqrt{J(J+1) - m(m+1)} | J, m+1 \\rangle$, $\\hat{J}_{-} = \\hat{J}_{+}^{\\dagger}$, $\\hat{J}_{x} = (\\hat{J}_{+} + \\hat{J}_{-})/2$, and $\\hat{J}_{y} = (\\hat{J}_{+} - \\hat{J}_{-})/(2i)$. Set $\\hbar = 1$.\n- Compute $d^{J}_{M K}(\\beta)$ as the $(M,K)$ matrix element of $e^{-i \\beta \\hat{J}_{y}}$. You must not use closed-form series for $d^{J}_{M K}(\\beta)$; compute it via the matrix exponential of $\\hat{J}_{y}$.\n- All angles must be handled in radians.\n- The integral must be computed by numerical quadrature as specified above, not by analytic reduction.\n\nTest suite:\nEvaluate the boolean pass/fail results for the following six cases, each specified as the tuple $(J,J',M,M',K,K')$ with all quantum numbers integers satisfying $-J \\le M,K \\le J$ and $-J' \\le M',K' \\le J'$:\n- Case $1$: $(0,0,0,0,0,0)$.\n- Case $2$: $(1,1,1,1,-1,-1)$.\n- Case $3$: $(2,2,0,1,2,2)$.\n- Case $4$: $(2,3,0,0,-1,-1)$.\n- Case $5$: $(3,3,-2,-2,1,-1)$.\n- Case $6$: $(4,4,0,0,0,0)$.\n\nRequired final output format:\n- Your program should produce a single line of output containing the results as a comma-separated list of boolean values enclosed in square brackets, in the exact order of the cases above. For example, a valid output would look like: \"[True,False,True,True,True,True]\".", "solution": "The problem requires a numerical validation of the orthogonality relation for the Wigner D-matrix elements, a fundamental property derived from the representation theory of the rotation group $SO(3)$. The relation is given by the integral:\n$$\nI(J,J',M,M',K,K') = \\int d\\Omega \\; D^{J}_{M K}(\\Omega)\\, \\left[D^{J'}_{M' K'}(\\Omega)\\right]^{*} = \\frac{8\\pi^{2}}{2J+1}\\, \\delta_{J J'}\\, \\delta_{M M'}\\, \\delta_{K K'}\n$$\nwhere $\\Omega = (\\alpha, \\beta, \\gamma)$ denotes the Euler angles and $d\\Omega = d\\alpha\\,\\sin\\beta\\,d\\beta\\,d\\gamma$ is the Haar measure. Our task is to implement a numerical procedure to compute this integral for given sets of quantum numbers $(J,J',M,M',K,K')$ and verify that the result matches the analytical formula to within a specified tolerance $\\varepsilon = 10^{-6}$.\n\nThe algorithmic solution involves four primary stages:\n1.  Construction of the matrix representation of the angular momentum operator $\\hat{J}_y$.\n2.  Computation of the Wigner d-matrix $d^J(\\beta)$ via matrix exponentiation.\n3.  Evaluation of the three-dimensional integral over $(\\alpha, \\beta, \\gamma)$ using the prescribed numerical quadrature methods.\n4.  Comparison of the numerical result with the analytical value to determine a pass/fail outcome.\n\n**1. Matrix Representation of Angular Momentum Operators**\n\nFor a system with a given total angular momentum quantum number $J$, the state space is spanned by the $2J+1$ orthonormal basis vectors $|\\,J, M\\rangle$, where the magnetic quantum number $M$ takes values $M = -J, -J+1, \\dots, J$. We can represent these basis states as column vectors in a $(2J+1)$-dimensional complex vector space. A standard convention is to map the quantum number $M$ to a zero-based matrix index $i$ via the relation $i=M+J$.\n\nThe angular momentum operators $\\hat{J}_{\\pm}$ and $\\hat{J}_z$ act on these basis states. The problem requires constructing $\\hat{J}_y$ from the ladder operators, whose actions are defined as:\n$$\n\\hat{J}_{+} |\\,J, M\\rangle = \\sqrt{J(J+1) - M(M+1)} \\,|\\,J, M+1\\rangle\n$$\n$$\n\\hat{J}_{-} |\\,J, M\\rangle = \\sqrt{J(J+1) - M(M-1)} \\,|\\,J, M-1\\rangle\n$$\nIn the chosen basis, the matrix element $\\langle J, M'| \\hat{J}_+ | J, M \\rangle$ is non-zero only for $M' = M+1$. This means $\\hat{J}_+$ is a matrix with non-zero elements only on the superdiagonal. Its Hermitian conjugate, $\\hat{J}_- = \\hat{J}_+^{\\dagger}$, has non-zero elements on the subdiagonal. With $\\hbar=1$, the matrix representation for $\\hat{J}_y$ is then calculated as:\n$$\n\\hat{J}_y = \\frac{\\hat{J}_+ - \\hat{J}_-}{2i}\n$$\nThis results in a purely imaginary, anti-symmetric $(2J+1) \\times (2J+1)$ matrix.\n\n**2. Wigner d-matrix and D-matrix Calculation**\n\nThe problem specifies the factorization of the Wigner D-matrix:\n$$\nD^{J}_{M K}(\\alpha,\\beta,\\gamma) = e^{-i M \\alpha}\\, d^{J}_{M K}(\\beta)\\, e^{-i K \\gamma}\n$$\nThe central component, the Wigner (small) d-matrix element $d^{J}_{M K}(\\beta)$, is a matrix element of the rotation operator about the y-axis:\n$$\nd^{J}_{M K}(\\beta) = \\langle J, M | e^{-i \\beta \\hat{J}_{y}} | J, K \\rangle\n$$\nAs mandated, this is computed not from an analytical formula, but by first calculating the matrix exponential $d^J(\\beta) = \\exp(-i\\beta \\hat{J}_y)$, where $\\hat{J}_y$ is the matrix constructed in the previous step. The desired element $d^{J}_{M K}(\\beta)$ is then extracted from this resulting $(2J+1) \\times (2J+1)$ matrix at row $i=M+J$ and column $j=K+J$.\n\n**3. Numerical Evaluation of the Orthogonality Integral**\n\nThe integral to be evaluated is:\n$$\nI = \\int_{0}^{2\\pi} d\\alpha \\int_{0}^{\\pi} \\sin\\beta\\, d\\beta \\int_{0}^{2\\pi} d\\gamma \\; D^{J}_{M K}(\\alpha,\\beta,\\gamma)\\, \\left[D^{J'}_{M' K'}(\\alpha,\\beta,\\gamma)\\right]^{*}\n$$\nSubstituting the factorization for $D$ and its complex conjugate gives:\n$$\nI = \\int_{0}^{2\\pi} e^{-i(M-M')\\alpha}d\\alpha \\int_{0}^{\\pi} d^{J}_{M K}(\\beta)\\left[d^{J'}_{M' K'}(\\beta)\\right]^{*} \\sin\\beta d\\beta \\int_{0}^{2\\pi} e^{-i(K-K')\\gamma}d\\gamma\n$$\nThe problem strictly requires that this triple integral be evaluated numerically using distinct methods for each dimension.\n\n**$\\alpha$ and $\\gamma$ Integrals:** These are evaluated using the trapezoidal rule with $N_\\alpha=128$ and $N_\\gamma=128$ points on the interval $[0, 2\\pi)$. For an integral of the form $\\int_0^{2\\pi} e^{-i\\Delta n \\theta} d\\theta$, the trapezoidal approximation is $\\frac{2\\pi}{N} \\sum_{j=0}^{N-1} e^{-i\\Delta n \\theta_j}$, where $\\theta_j = 2\\pi j / N$. This sum is a geometric series that evaluates to $N$ if $\\Delta n$ is a multiple of $N$ (including $0$), and $0$ otherwise. For the integer values of $M, M', K, K'$ in the test cases, $|M-M'| \\ll N_\\alpha$ and $|K-K'| \\ll N_\\gamma$. Thus, the numerical integration will be exact, yielding $2\\pi \\delta_{MM'}$ and $2\\pi \\delta_{KK'}$.\n\n**$\\beta$ Integral:** The $\\beta$ integral is $I_\\beta = \\int_0^\\pi f(\\beta) \\sin\\beta d\\beta$, where $f(\\beta) = d^{J}_{M K}(\\beta)\\left[d^{J'}_{M' K'}(\\beta)\\right]^{*}$. Applying the change of variables $x = \\cos\\beta$, so that $dx = -\\sin\\beta d\\beta$, the integral becomes $I_\\beta = \\int_{-1}^1 f(\\arccos x) dx$. This is evaluated using $N_\\beta=64$-point Gauss-Legendre quadrature. We obtain a set of nodes $x_k$ and weights $w_k$, and the integral is approximated by the sum:\n$$\nI_\\beta \\approx \\sum_{k=0}^{N_\\beta-1} w_k \\, d^{J}_{M K}(\\arccos x_k)\\left[d^{J'}_{M' K'}(\\arccos x_k)\\right]^{*}\n$$\n\nThe total numerical integral $I_{\\text{numeric}}$ is the product of the results from the three one-dimensional quadratures.\n\n**4. Comparison and Verification**\n\nFor each test case, the numerically computed integral $I_{\\text{numeric}}$ is compared against the analytical value $I_{\\text{analytic}} = \\frac{8\\pi^{2}}{2J+1}\\, \\delta_{J J'}\\, \\delta_{M M'}\\, \\delta_{K K'}$. The validation criterion is a mixed absolute-relative error test:\n$$\n\\left| I_{\\text{numeric}} - I_{\\text{analytic}} \\right| \\le \\varepsilon \\times \\max\\!\\left(1, \\left| I_{\\text{analytic}} \\right| \\right)\n$$\nwith $\\varepsilon = 10^{-6}$. This ensures that for cases where $I_{\\text{analytic}}=0$, the test becomes a check against an absolute tolerance of $\\varepsilon$, while for non-zero $I_{\\text{analytic}}$, it is a relative tolerance check. A boolean result (`True`/`False`) is returned based on this comparison.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import expm\nfrom numpy.polynomial.legendre import leggauss\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for validating the orthogonality of Wigner D-matrices.\n    \"\"\"\n    \n    # Test suite: each tuple is (J, J', M, M', K, K')\n    test_cases = [\n        (0, 0, 0, 0, 0, 0),    # Case 1\n        (1, 1, 1, 1, -1, -1), # Case 2\n        (2, 2, 0, 1, 2, 2),    # Case 3\n        (2, 3, 0, 0, -1, -1), # Case 4\n        (3, 3, -2, -2, 1, -1),# Case 5\n        (4, 4, 0, 0, 0, 0),    # Case 6\n    ]\n\n    # Memoization caches for angular momentum matrices and their exponentials\n    jy_matrices_cache = {}\n    \n    def get_jy(j_val):\n        \"\"\"\n        Constructs the matrix representation of the J_y angular momentum operator.\n        Uses memoization to avoid redundant calculations.\n        \"\"\"\n        if j_val in jy_matrices_cache:\n            return jy_matrices_cache[j_val]\n\n        if not isinstance(j_val, int) or j_val < 0:\n            raise ValueError(\"J must be a non-negative integer.\")\n        \n        dim = 2 * j_val + 1\n        m_values = np.arange(-j_val, j_val + 1)\n        \n        jp_matrix = np.zeros((dim, dim), dtype=np.float64)\n        \n        for i in range(dim - 1):\n            m = m_values[i]\n            # Matrix element <J, m+1|J+|J, m>\n            # Row index corresponds to m+1, column index to m\n            # Matrix index i maps to m, so i+1 maps to m+1\n            coeff = np.sqrt(j_val * (j_val + 1) - m * (m + 1))\n            jp_matrix[i, i + 1] = coeff\n        \n        # J- is the transpose, as J+ is real-valued\n        jm_matrix = jp_matrix.T\n        \n        # Jy = (J+ - J-) / 2i\n        jy_matrix = (jp_matrix - jm_matrix) / (2j)\n        \n        jy_matrices_cache[j_val] = jy_matrix\n        return jy_matrix\n\n    def calculate_integral(j, j_prime, m, m_prime, k, k_prime):\n        \"\"\"\n        Numerically calculates the orthogonality integral for a given set of quantum numbers.\n        \"\"\"\n        # Quadrature and tolerance parameters\n        n_alpha = 128\n        n_gamma = 128\n        n_beta = 64\n        epsilon = 1e-6\n        \n        # 1. Calculate analytic value\n        is_orthogonal = (j == j_prime) and (m == m_prime) and (k == k_prime)\n        i_analytic = (8 * np.pi**2) / (2 * j + 1) if is_orthogonal else 0.0\n\n        # 2. Calculate numeric value\n        \n        # --- Alpha and Gamma integrals using Trapezoidal rule ---\n        delta_m = m - m_prime\n        delta_k = k - k_prime\n\n        # Alpha integral\n        alpha_nodes = np.linspace(0, 2 * np.pi, n_alpha, endpoint=False)\n        alpha_integrand = np.exp(-1j * delta_m * alpha_nodes)\n        alpha_integral_val = (2 * np.pi / n_alpha) * np.sum(alpha_integrand)\n        \n        # Gamma integral\n        gamma_nodes = np.linspace(0, 2 * np.pi, n_gamma, endpoint=False)\n        gamma_integrand = np.exp(-1j * delta_k * gamma_nodes)\n        gamma_integral_val = (2 * np.pi / n_gamma) * np.sum(gamma_integrand)\n\n        # Optimization: if M!=M' or K!=K', the alpha/gamma integrals are numerically zero.\n        # The total integral will thus be zero, matching the analytic result.\n        # However, to be fully rigorous per instructions, compute beta part anyway.\n        \n        # --- Beta integral using Gauss-Legendre quadrature ---\n        x_nodes, w_weights = leggauss(n_beta)\n        beta_nodes = np.arccos(x_nodes)\n\n        jy_j = get_jy(j)\n        if j == j_prime:\n            jy_j_prime = jy_j\n        else:\n            jy_j_prime = get_jy(j_prime)\n            \n        beta_integral_val = 0.0\n        \n        for idx in range(n_beta):\n            beta_k = beta_nodes[idx]\n            w_k = w_weights[idx]\n            \n            # Compute d-matrices via matrix exponential\n            d_matrix_j = expm(-1j * beta_k * jy_j)\n            d_matrix_j_prime = expm(-1j * beta_k * jy_j_prime)\n\n            # Extract specific elements, converting quantum numbers to matrix indices\n            d_j_mk = d_matrix_j[m + j, k + j]\n            d_j_prime_mk = d_matrix_j_prime[m_prime + j_prime, k_prime + j_prime]\n            \n            integrand_val = d_j_mk * np.conj(d_j_prime_mk)\n            beta_integral_val += w_k * integrand_val\n            \n        i_numeric = alpha_integral_val * gamma_integral_val * beta_integral_val\n        \n        # 3. Compare and return boolean result\n        error = np.abs(i_numeric - i_analytic)\n        threshold = epsilon * np.max([1.0, np.abs(i_analytic)])\n        \n        return error <= threshold\n\n    results = []\n    for case in test_cases:\n        j, j_prime, m, m_prime, k, k_prime = case\n        \n        # Validate quantum numbers\n        if not (abs(m) <= j and abs(k) <= j and abs(m_prime) <= j_prime and abs(k_prime) <= j_prime):\n             raise ValueError(f\"Invalid quantum numbers in case: {case}\")\n        \n        pass_fail = calculate_integral(*case)\n        results.append(pass_fail)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3542272"}, {"introduction": "After validating the mathematical machinery, a vital next step is to perform a physical sanity check. From first principles, a quantum state that is already spherically symmetric is a pure angular momentum $J=0$ state. This practice applies our projection operator to such a rotationally invariant state, for which the theoretical outcome is known: the projection should yield a non-zero amplitude exclusively for the $J=0$ component. Successfully completing this test [@problem_id:3542237] provides confidence that our code correctly handles the interplay between the projection operator and the symmetry properties of the quantum state itself.", "problem": "Consider a mean-field Slater determinant representing an even-even, rotationally invariant Hartree-Fock (HF) state in nuclear many-body theory. Such a state is invariant under the action of the three-dimensional rotation group, so that for any Euler angles $\\Omega = (\\alpha,\\beta,\\gamma)$ in radians one has $\\,\\hat{R}(\\Omega)\\,|\\Phi\\rangle = |\\Phi\\rangle\\,$, where $\\hat{R}(\\Omega)$ is the unitary rotation operator defined by the composition of rotations parameterized by the Euler angles. The angular momentum projector $\\hat{P}^J_{MK}$ onto total angular momentum $J$ and its laboratory and intrinsic projections $M$ and $K$ is defined by a group integral over the rotation group with the Wigner $D$-functions, \n$$\n\\hat{P}^{J}_{MK} \\equiv \\frac{2J+1}{8\\pi^2} \\int_{0}^{2\\pi}\\!\\!d\\alpha\\int_{0}^{\\pi}\\!\\!d\\beta\\,\\sin\\beta\\int_{0}^{2\\pi}\\!\\!d\\gamma\\; D^{J}_{MK}(\\alpha,\\beta,\\gamma)^{*}\\,\\hat{R}(\\alpha,\\beta,\\gamma).\n$$\nFor a rotationally invariant state $|\\Phi\\rangle$, the amplitude $a_J$ associated with projecting onto $M=K=0$ is given by\n$$\na_J \\equiv \\langle \\Phi | \\hat{P}^{J}_{00} | \\Phi\\rangle = \\frac{2J+1}{8\\pi^2}\\int_{0}^{2\\pi}\\!\\!d\\alpha\\int_{0}^{\\pi}\\!\\!d\\beta\\,\\sin\\beta\\int_{0}^{2\\pi}\\!\\!d\\gamma\\; D^{J}_{00}(\\alpha,\\beta,\\gamma)^{*}\\,\\langle \\Phi | \\hat{R}(\\alpha,\\beta,\\gamma) | \\Phi\\rangle.\n$$\nBecause $|\\Phi\\rangle$ is rotationally invariant, one has $\\langle \\Phi | \\hat{R}(\\alpha,\\beta,\\gamma) | \\Phi\\rangle = 1$. Furthermore, for the special case $M=K=0$, the Wigner $D$-function reduces to the Legendre polynomial $P_J(\\cos\\beta)$, that is, $D^{J}_{00}(\\alpha,\\beta,\\gamma) = P_J(\\cos\\beta)$.\n\nYour task is to write a complete program that numerically evaluates $a_J$ for a rotationally invariant HF state, using quadrature over the Euler angles. The evaluation must be done by decomposing the triple integral into:\n- A uniform quadrature for $\\alpha \\in [0,2\\pi)$ in radians with $N_{\\alpha}$ equidistant points and corresponding weights $w_{\\alpha} = 2\\pi/N_{\\alpha}$.\n- A Gaussian-Legendre quadrature for $\\beta \\in [0,\\pi]$ in radians. Use the change of variables $x=\\cos\\beta$, so that $\\sin\\beta\\,d\\beta = -dx$, and integrate $P_J(x)$ over $x\\in[-1,1]$ with $N_{\\beta}$ Gaussian-Legendre nodes and weights.\n- A uniform quadrature for $\\gamma \\in [0,2\\pi)$ in radians with $N_{\\gamma}$ equidistant points and corresponding weights $w_{\\gamma} = 2\\pi/N_{\\gamma}$.\n\nGiven that $\\langle \\Phi | \\hat{R}(\\alpha,\\beta,\\gamma) | \\Phi\\rangle = 1$, the program must compute\n$$\na_J = \\frac{2J+1}{8\\pi^2}\\left(\\sum_{i=1}^{N_{\\alpha}} w_{\\alpha}\\right)\\left(\\sum_{k=1}^{N_{\\gamma}} w_{\\gamma}\\right)\\left(\\sum_{j=1}^{N_{\\beta}} w_j\\,P_J(x_j)\\right),\n$$\nwhere $x_j$ and $w_j$ are the Gaussian-Legendre nodes and weights on $[-1,1]$ for the $\\beta$ integral after the change of variables. The mathematical basis of this computation is the rotational invariance of $|\\Phi\\rangle$, the definition of the projector $\\hat{P}^{J}_{MK}$, and the identity $D^J_{00}(\\alpha,\\beta,\\gamma) = P_J(\\cos\\beta)$.\n\nYou must then verify the statement that the spherical HF state has nonzero amplitude only for $J=0$. For numerical verification, define a tolerance $\\epsilon$ and check that $|a_0 - 1| \\le \\epsilon$ and $|a_J| \\le \\epsilon$ for all $J \\ge 1$. The program must implement the following test suite, each test defined by parameters $(J_{\\text{max}}, N_{\\beta}, N_{\\alpha}, N_{\\gamma}, \\epsilon)$:\n- Test case $1$ (general case): $(J_{\\text{max}}=8,\\, N_{\\beta}=5,\\, N_{\\alpha}=8,\\, N_{\\gamma}=8,\\, \\epsilon=10^{-12})$.\n- Test case $2$ (boundary $\\beta$ quadrature minimal for $J=0$): $(J_{\\text{max}}=0,\\, N_{\\beta}=1,\\, N_{\\alpha}=1,\\, N_{\\gamma}=1,\\, \\epsilon=10^{-14})$.\n- Test case $3$ (edge case small grids but exact up to $J=2$): $(J_{\\text{max}}=2,\\, N_{\\beta}=2,\\, N_{\\alpha}=1,\\, N_{\\gamma}=1,\\, \\epsilon=10^{-14})$.\n\nFor each test case, your program must:\n- Compute the list $\\{a_J\\}_{J=0}^{J_{\\text{max}}}$.\n- Produce a boolean indicating whether the verification passes at the specified tolerance $\\epsilon$.\n\nFinal Output Format: Your program should produce a single line of output containing the pass/fail results for the test suite as a comma-separated list enclosed in square brackets, for example, $[{\\tt True},{\\tt False},{\\tt True}]$. Angles must be treated in radians throughout. No physical units are involved in this calculation, but all angles are specified to be in radians. Your boolean results must be deterministic given the stated tests.", "solution": "The problem requires the numerical evaluation of the amplitude $a_J$ obtained by projecting a rotationally invariant Hartree-Fock state $|\\Phi\\rangle$ onto a state of good angular momentum $J$, with projections $M=K=0$. We must then verify the fundamental property that such a spherical state is composed solely of an angular momentum $J=0$ component.\n\nThe amplitude $a_J$ is defined as the expectation value of the projector $\\hat{P}^J_{00}$ in the state $|\\Phi\\rangle$:\n$$\na_J \\equiv \\langle \\Phi | \\hat{P}^{J}_{00} | \\Phi\\rangle\n$$\nThe projector $\\hat{P}^J_{MK}$ is defined by an integral over the rotation group $SO(3)$, parameterized by Euler angles $\\Omega = (\\alpha, \\beta, \\gamma)$:\n$$\n\\hat{P}^{J}_{MK} \\equiv \\frac{2J+1}{8\\pi^2} \\int d\\Omega\\; D^{J}_{MK}(\\Omega)^{*}\\,\\hat{R}(\\Omega)\n$$\nwhere $d\\Omega = d\\alpha \\sin\\beta d\\beta d\\gamma$, and the integration limits are $\\alpha \\in [0, 2\\pi]$, $\\beta \\in [0, \\pi]$, and $\\gamma \\in [0, 2\\pi]$. $\\hat{R}(\\Omega)$ is the rotation operator and $D^{J}_{MK}(\\Omega)$ is the Wigner D-function.\n\nSubstituting the projector into the amplitude expression yields:\n$$\na_J = \\frac{2J+1}{8\\pi^2} \\int d\\Omega\\; D^{J}_{00}(\\Omega)^{*}\\,\\langle \\Phi | \\hat{R}(\\Omega) | \\Phi\\rangle\n$$\nThe problem states two key simplifications for this specific case:\n$1$. The state $|\\Phi\\rangle$ is rotationally invariant, meaning $\\hat{R}(\\Omega)|\\Phi\\rangle = |\\Phi\\rangle$. Assuming $|\\Phi\\rangle$ is normalized, $\\langle \\Phi | \\Phi \\rangle = 1$, the matrix element becomes $\\langle \\Phi | \\hat{R}(\\Omega) | \\Phi\\rangle = \\langle \\Phi | \\Phi \\rangle = 1$.\n$2$. For the case $M=K=0$, the Wigner D-function simplifies to a Legendre polynomial, $D^{J}_{00}(\\alpha, \\beta, \\gamma) = P_J(\\cos\\beta)$. Since Legendre polynomials are real, the complex conjugate is superfluous.\n\nWith these simplifications, the expression for $a_J$ becomes:\n$$\na_J = \\frac{2J+1}{8\\pi^2} \\int_{0}^{2\\pi} d\\alpha \\int_{0}^{2\\pi} d\\gamma \\int_{0}^{\\pi} d\\beta \\sin\\beta\\; P_J(\\cos\\beta)\n$$\nThe integrand is independent of $\\alpha$ and $\\gamma$, so these integrals can be evaluated directly: $\\int_{0}^{2\\pi}d\\alpha = 2\\pi$ and $\\int_{0}^{2\\pi}d\\gamma = 2\\pi$. This leads to:\n$$\na_J = \\frac{2J+1}{8\\pi^2} (2\\pi)(2\\pi) \\int_{0}^{\\pi} P_J(\\cos\\beta) \\sin\\beta \\, d\\beta = \\frac{2J+1}{2} \\int_{0}^{\\pi} P_J(\\cos\\beta) \\sin\\beta \\, d\\beta\n$$\nUsing the change of variables $x = \\cos\\beta$, for which $dx = -\\sin\\beta \\, d\\beta$, the integral over $\\beta \\in [0, \\pi]$ transforms to an integral over $x \\in [1, -1]$:\n$$\na_J = \\frac{2J+1}{2} \\int_{1}^{-1} P_J(x) (-dx) = \\frac{2J+1}{2} \\int_{-1}^{1} P_J(x) \\, dx\n$$\nThis integral can be solved analytically using the orthogonality relation for Legendre polynomials, $\\int_{-1}^{1} P_J(x) P_L(x) dx = \\frac{2}{2L+1}\\delta_{JL}$. By setting $L=0$, since $P_0(x) = 1$, we find:\n$$\n\\int_{-1}^{1} P_J(x) P_0(x) \\, dx = \\frac{2}{2(0)+1}\\delta_{J0} = 2\\delta_{J0}\n$$\nwhere $\\delta_{J0}$ is the Kronecker delta. Thus, the exact analytical result is:\n$$\na_J = \\frac{2J+1}{2} (2\\delta_{J0}) = (2J+1)\\delta_{J0}\n$$\nThis confirms that $a_0 = 1$ and $a_J = 0$ for all $J \\ge 1$, which is the expected physical result for a spherical state.\n\nThe task is to verify this result numerically using a specified quadrature scheme. The problem provides the numerical formula:\n$$\na_J = \\frac{2J+1}{8\\pi^2}\\left(\\sum_{i=1}^{N_{\\alpha}} w_{\\alpha}\\right)\\left(\\sum_{k=1}^{N_{\\gamma}} w_{\\gamma}\\right)\\left(\\sum_{j=1}^{N_{\\beta}} w_j\\,P_J(x_j)\\right)\n$$\nThe uniform quadratures for $\\alpha$ and $\\gamma$ with weights $w_{\\alpha} = 2\\pi/N_{\\alpha}$ and $w_{\\gamma} = 2\\pi/N_{\\gamma}$ yield sums that are independent of the number of points:\n$$\n\\sum_{i=1}^{N_{\\alpha}} w_{\\alpha} = N_{\\alpha} \\left(\\frac{2\\pi}{N_{\\alpha}}\\right) = 2\\pi \\quad \\text{and} \\quad \\sum_{k=1}^{N_{\\gamma}} w_{\\gamma} = N_{\\gamma} \\left(\\frac{2\\pi}{N_{\\gamma}}\\right) = 2\\pi\n$$\nTherefore, the numerical values $N_\\alpha$ and $N_\\gamma$ from the test cases are not required for the calculation, as these sums always evaluate to $2\\pi$. The numerical formula simplifies to:\n$$\na_J \\approx \\frac{2J+1}{2} \\sum_{j=1}^{N_{\\beta}} w_j\\,P_J(x_j)\n$$\nThis is the numerical approximation of the integral $\\frac{2J+1}{2} \\int_{-1}^{1} P_J(x) \\, dx$. For the numerical evaluation, we need Gaussian-Legendre quadrature nodes $x_j$ and weights $w_j$ for the interval $[-1, 1]$, which can be obtained using standard numerical libraries. An $N_{\\beta}$-point Gaussian-Legendre quadrature integrates polynomials of degree up to $2N_{\\beta}-1$ exactly. The integrand is $P_J(x)$, a polynomial of degree $J$. The numerical result for $a_J$ will therefore be exact if $J \\le 2N_{\\beta}-1$.\n\nThe algorithm for each test case $(J_{\\text{max}}, N_{\\beta}, N_{\\alpha}, N_{\\gamma}, \\epsilon)$ is as follows:\n$1$. For the given number of points $N_{\\beta}$, obtain the Gaussian-Legendre nodes $x_j$ and weights $w_j$ on $[-1, 1]$.\n$2$. For each angular momentum $J$ from $0$ to $J_{\\text{max}}$:\n    a. Construct the Legendre polynomial $P_J(x)$.\n    b. Evaluate $P_J(x_j)$ at each node.\n    c. Compute the quadrature sum $S_J = \\sum_{j=1}^{N_{\\beta}} w_j P_J(x_j)$.\n    d. Calculate the amplitude $a_J = \\frac{2J+1}{2} S_J$.\n$3$. Collect the computed amplitudes $\\{a_J\\}_{J=0}^{J_{\\text{max}}}$.\n$4$. Verify the result based on the tolerance $\\epsilon$: check if $|a_0 - 1| \\le \\epsilon$ and $|a_J| \\le \\epsilon$ for all $J \\in [1, J_{\\text{max}}]$. The test passes if all conditions are met.\n\nFor the provided test cases, the condition $J_{\\text{max}} \\le 2N_{\\beta}-1$ is always satisfied, ensuring the numerical integration is exact up to machine precision. Thus, all test cases are expected to pass.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import legendre, roots_legendre\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for angular momentum projection.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (J_max, N_beta, N_alpha, N_gamma, epsilon)\n    test_cases = [\n        (8, 5, 8, 8, 1e-12),\n        (0, 1, 1, 1, 1e-14),\n        (2, 2, 1, 1, 1e-14),\n    ]\n\n    results = []\n    for case in test_cases:\n        J_max, N_beta, N_alpha, N_gamma, epsilon = case\n        \n        # As shown in the solution, the sums over alpha and gamma quadrature points\n        # always evaluate to 2*pi, regardless of N_alpha and N_gamma.\n        # Thus, these parameters are not needed for the numerical calculation.\n        \n        # Get Gaussian-Legendre nodes (x_j) and weights (w_j) for the beta integral\n        # The integral is over x = cos(beta) from -1 to 1.\n        # scipy.special.roots_legendre provides these for the interval [-1, 1].\n        nodes, weights = roots_legendre(N_beta)\n\n        # Compute amplitudes a_J for J from 0 to J_max\n        amplitudes = []\n        for J in range(J_max + 1):\n            # Get the Legendre polynomial of degree J\n            P_J = legendre(J)\n            \n            # Evaluate P_J at each quadrature node\n            P_J_at_nodes = P_J(nodes)\n            \n            # Compute the integral over beta using Gaussian quadrature\n            # integral(P_J(x) dx) from -1 to 1 is approx. sum(w_j * P_J(x_j))\n            beta_integral_sum = np.sum(weights * P_J_at_nodes)\n            \n            # Calculate the amplitude a_J\n            # a_J = (2J+1)/2 * integral(P_J(x) dx)\n            a_J = (2 * J + 1) / 2.0 * beta_integral_sum\n            amplitudes.append(a_J)\n\n        # Verify the results against the theoretical expectation\n        # a_0 should be 1, and a_J for J>0 should be 0.\n        \n        # Check a_0\n        pass_a0 = abs(amplitudes[0] - 1.0) <= epsilon\n        \n        # Check a_J for J > 0\n        pass_aJ_gt_0 = True\n        if J_max > 0:\n            # np.all checks if all elements in the slice are True\n            pass_aJ_gt_0 = np.all(np.abs(amplitudes[1:]) <= epsilon)\n            \n        test_passes = pass_a0 and pass_aJ_gt_0\n        results.append(test_passes)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3542237"}, {"introduction": "A primary application of angular momentum projection is to generate a set of basis states for configuration interaction calculations, a method known as the projected generator coordinate method. Projecting from multiple, distinct mean-field configurations typically creates a basis that is not only non-orthogonal but also contains near-linear dependencies, which can render the final diagonalization numerically unstable. This advanced practice [@problem_id:3542310] addresses this critical issue by guiding you through canonical orthonormalization, a standard procedure for identifying and removing redundant states to construct a stable, physically meaningful basis, and allows you to study how this choice impacts the final calculated energy spectrum.", "problem": "Consider the angular-momentum projected configuration mixing of Hartree-Fock-Bogoliubov (HFB) mean-field states in nuclear many-body theory. The non-orthogonality of projected basis states leads to a generalized eigenvalue problem for the Hamiltonian in the subspace spanned by projected configurations. Your task is to implement canonical orthonormalization to address linear dependence and study the effect of cutoff thresholds on small overlap-matrix eigenvalues on the resulting energy spectrum.\n\nStart from the variational principle for stationary states in a non-orthogonal subspace: minimizing the Rayleigh quotient of the Hamiltonian over linear combinations of non-orthogonal projected states leads to a generalized eigenvalue problem of the form $H \\mathbf{c} = E S \\mathbf{c}$, where $S$ is the overlap matrix between basis states and $H$ is the Hamiltonian matrix. Linear dependence manifests as near-zero eigenvalues of $S$, and the canonical orthonormalization procedure (also known as symmetric orthonormalization) remedies both non-orthogonality and near-linear dependence by diagonalizing $S$ and discarding modes with very small norm.\n\nYou must construct, in a purely mathematical form, a symmetric positive semidefinite overlap matrix $S$ and a symmetric Hamiltonian matrix $H$ of dimension $5$, using deterministic orthogonal transformations and prescribed eigenvalues. Specifically:\n\n- Let $n = 5$.\n- Define a sequence of Givens rotations on $\\mathbb{R}^5$ parameterized by angles in radians to construct an orthogonal matrix $Q$:\n  - Rotate in the $(0,1)$-plane by angle $\\alpha = 0.3$ (radians).\n  - Rotate in the $(2,3)$-plane by angle $\\beta = -0.7$ (radians).\n  - Rotate in the $(1,2)$-plane by angle $\\gamma = 0.5$ (radians).\n  - Rotate in the $(0,4)$-plane by angle $\\delta = 0.2$ (radians).\n  The product of these rotations (applied in the stated order) defines $Q$.\n- Using $Q$, define the overlap matrix $S = Q \\,\\mathrm{diag}(s)\\, Q^{\\mathsf{T}}$ with eigenvalues $s = [\\,1.0,\\;0.5,\\;0.05,\\;10^{-8},\\;0.2\\,]$. This choice models one nearly redundant direction with eigenvalue $10^{-8}$ and other well-conditioned directions.\n- Define another orthogonal matrix $R$ by applying Givens rotations (in radians) in the following order:\n  - Rotate in the $(0,2)$-plane by angle $\\theta_1 = -0.4$.\n  - Rotate in the $(3,4)$-plane by angle $\\theta_2 = 0.65$.\n  - Rotate in the $(1,4)$-plane by angle $\\theta_3 = -0.25$.\n  - Rotate in the $(0,3)$-plane by angle $\\theta_4 = 0.15$.\n- Using $R$, define the Hamiltonian $H = R \\,\\mathrm{diag}(e)\\, R^{\\mathsf{T}}$ with energies $e = [\\,-8.0,\\,-2.0,\\;1.0,\\;3.0,\\;7.0\\,]$ (in Mega-electron Volts (MeV)).\n\nImplement canonical orthonormalization as follows, without using any shortcut formulas: diagonalize the overlap matrix $S$, discard eigenmodes whose eigenvalues are below a cutoff threshold, construct the corresponding orthonormal subspace, map the Hamiltonian into that orthonormal subspace, and solve the ordinary eigenvalue problem to obtain the energy spectrum in MeV. If no eigenmodes remain after applying the cutoff, return an empty list to indicate that no physical spectrum is defined in that case.\n\nUse the following test suite of cutoff thresholds (all in absolute value, with removal enforced for eigenvalues less than or equal to the cutoff): $\\epsilon \\in \\{\\,10^{-12},\\;10^{-6},\\;10^{-1},\\;6\\times 10^{-1},\\;2.0\\,\\}$. These cover:\n- A case that keeps almost all modes including the near-redundant one ($\\epsilon = 10^{-12}$).\n- A case that removes the near-zero mode but keeps all well-conditioned ones ($\\epsilon = 10^{-6}$).\n- A case that removes multiple small-norm modes ($\\epsilon = 10^{-1}$).\n- A boundary case leaving a single retained mode ($\\epsilon = 6\\times 10^{-1}$).\n- An extreme case that removes all modes ($\\epsilon = 2.0$).\n\nFor each threshold $\\epsilon$, compute the energies by canonical orthonormalization and diagonalization of the Hamiltonian in the retained orthonormal subspace, and return the energies sorted in ascending order. Express the energies in Mega-electron Volts (MeV) as floating-point numbers rounded to six decimals. The final output must aggregate the results for all test cases into a single line formatted as a comma-separated list enclosed in square brackets, with each per-threshold result itself a bracketed comma-separated list, for example, $\"[[E_{1}^{(1)},E_{2}^{(1)},\\dots],[E_{1}^{(2)},\\dots],\\dots]\"$, where every $E_{k}^{(i)}$ is a float in MeV. Angles are in radians throughout.", "solution": "The problem at hand is a well-posed and scientifically sound exercise in computational many-body physics, specifically addressing the numerical stabilization of the configuration interaction method built upon a non-orthogonal basis of projected mean-field states. The core task is to solve the generalized eigenvalue problem (GEP) $H \\mathbf{c} = E S \\mathbf{c}$ for the energy spectrum $E$ by applying the canonical orthonormalization procedure. This method is essential for handling the near-linear dependencies that arise in the basis set of projected Hartree-Fock-Bogoliubov (HFB) states, which manifest as near-zero eigenvalues in the overlap matrix $S$.\n\nThe solution involves three main stages:\n1.  Construction of the symmetric Hamiltonian matrix $H$ and the symmetric positive semidefinite overlap matrix $S$ according to the specified spectral decompositions.\n2.  Implementation of the canonical orthonormalization algorithm, which transforms the GEP into a standard eigenvalue problem (SEP) within a physically relevant, smaller subspace.\n3.  Application of this procedure for a series of cutoff thresholds $\\epsilon$ to study their effect on the resulting energy spectrum.\n\n**1. Construction of Matrices**\n\nThe matrices $H$ and $S$ are constructed to be of dimension $n=5$. Their spectral properties (eigenvalues) are predefined, and their eigenvectors are determined by specific orthogonal transformation matrices, $R$ and $Q$ respectively, which are themselves products of Givens rotations.\n\nA Givens rotation in the $(i,j)$-plane by an angle $\\phi$ is represented by a matrix $G_{i,j}(\\phi)$ which is an identity matrix except for four elements: $G_{ii} = G_{jj} = \\cos(\\phi)$, $G_{ij} = -\\sin(\\phi)$, and $G_{ji} = \\sin(\\phi)$.\n\nThe orthogonal matrix $Q$ for the overlap matrix $S$ is defined as the product of four successive rotations:\n$$Q = G_{0,4}(\\delta) G_{1,2}(\\gamma) G_{2,3}(\\beta) G_{0,1}(\\alpha)$$\nwith angles $\\alpha = 0.3$, $\\beta = -0.7$, $\\gamma = 0.5$, and $\\delta = 0.2$ radians. The overlap matrix $S$ is then constructed as:\n$$S = Q \\,\\mathrm{diag}(s)\\, Q^{\\mathsf{T}}$$\nwhere the specified eigenvalues are $s = [\\,1.0,\\;0.5,\\;0.05,\\;10^{-8},\\;0.2\\,]$. This construction ensures $S$ is symmetric and positive semidefinite, with one eigenvalue ($10^{-8}$) being extremely small, modeling a near-linear dependence in the basis.\n\nSimilarly, the orthogonal matrix $R$ for the Hamiltonian matrix $H$ is the product of four rotations:\n$$R = G_{0,3}(\\theta_4) G_{1,4}(\\theta_3) G_{3,4}(\\theta_2) G_{0,2}(\\theta_1)$$\nwith angles $\\theta_1 = -0.4$, $\\theta_2 = 0.65$, $\\theta_3 = -0.25$, and $\\theta_4 = 0.15$ radians. The Hamiltonian matrix $H$ is then defined as:\n$$H = R \\,\\mathrm{diag}(e)\\, R^{\\mathsf{T}}$$\nwhere the specified eigenvalues are $e = [\\,-8.0,\\,-2.0,\\;1.0,\\;3.0,\\;7.0\\,]$ in units of Mega-electron Volts (MeV). This construction ensures $H$ is symmetric, as required.\n\n**2. Canonical Orthonormalization Procedure**\n\nThe GEP $H \\mathbf{c} = E S \\mathbf{c}$ is numerically unstable to solve directly when $S$ is ill-conditioned (i.e., has a large condition number, stemming from small eigenvalues). Canonical orthonormalization proceeds as follows:\n\nFirst, the overlap matrix $S$ is diagonalized:\n$$S U = U D_s$$\nwhere $U$ is the orthogonal matrix of eigenvectors $u_i$ and $D_s$ is the diagonal matrix of corresponding eigenvalues $s_i$. These eigenvalues are non-negative.\n\nSecond, a cutoff threshold $\\epsilon$ is introduced to discard eigenmodes associated with eigenvalues $s_i$ that are too small. According to the problem specification, we retain modes for which $s_i > \\epsilon$. Let the number of such retained modes be $k$, where $k \\le n$. If $k=0$, the resulting physical space is empty, and no energy spectrum can be determined.\n\nThird, we construct a transformation matrix $X$ of dimension $n \\times k$. The columns of $X$ define the coefficients of the new $k$ orthonormal basis vectors in terms of the original $n$ non-orthogonal basis vectors. This matrix is constructed from the retained eigenvectors and eigenvalues of $S$:\n$$X = U_{kept} (D_s)_{kept}^{-1/2}$$\nwhere $U_{kept}$ is the $n \\times k$ matrix whose columns are the retained eigenvectors, and $(D_s)_{kept}^{-1/2}$ is the $k \\times k$ diagonal matrix with entries $1/\\sqrt{s_i}$ for the retained eigenvalues. The basis transformed by $X$ is orthonormal, as $X^{\\mathsf{T}}SX = I_k$, where $I_k$ is the $k \\times k$ identity matrix.\n\nFinally, the Hamiltonian is projected onto this new orthonormal subspace:\n$$\\tilde{H} = X^{\\mathsf{T}} H X$$\nThe resulting matrix $\\tilde{H}$ is a $k \\times k$ symmetric matrix. The problem is reduced to a standard eigenvalue problem in the stable subspace:\n$$\\tilde{H} \\mathbf{d} = E \\mathbf{d}$$\nThe eigenvalues $E$ of $\\tilde{H}$ form the physically meaningful energy spectrum.\n\n**3. Application to Test Cases**\n\nThis procedure is applied for each specified cutoff threshold $\\epsilon \\in \\{\\,10^{-12},\\;10^{-6},\\;10^{-1},\\;6\\times 10^{-1},\\;2.0\\,\\}$.\n\n- For $\\epsilon = 10^{-12}$: This threshold is smaller than the smallest eigenvalue of $S$ ($10^{-8}$). Thus, all $5$ eigenmodes of $S$ are retained ($k=5$), and the GEP is transformed into a $5 \\times 5$ SEP.\n- For $\\epsilon = 10^{-6}$: This threshold is larger than $10^{-8}$ but smaller than all other eigenvalues of $S$. The mode corresponding to the $10^{-8}$ eigenvalue is discarded, leading to a $4 \\times 4$ SEP ($k=4$).\n- For $\\epsilon = 10^{-1}$: The eigenvalues $10^{-8}$ and $0.05$ are $\\le \\epsilon$. Thus, two modes are discarded, resulting in a $3 \\times 3$ SEP ($k=3$).\n- For $\\epsilon = 6 \\times 10^{-1}$: Four eigenvalues ($10^{-8}, 0.05, 0.2, 0.5$) are $\\le \\epsilon$. Only the mode corresponding to the largest eigenvalue ($1.0$) is retained, yielding a $1 \\times 1$ problem ($k=1$), whose solution is a single energy value.\n- For $\\epsilon = 2.0$: All eigenvalues of $S$ are smaller than this threshold. All modes are discarded ($k=0$), and the resulting spectrum is an empty set.\n\nThe computed energies for each case are sorted in ascending order and rounded to six decimal places, as required.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the generalized eigenvalue problem Hc = ESc using canonical\n    orthonormalization for a set of cutoff thresholds.\n    \"\"\"\n    \n    # Define problem parameters\n    n = 5\n    s_eigvals = [1.0, 0.5, 0.05, 1e-8, 0.2]\n    e_eigvals = [-8.0, -2.0, 1.0, 3.0, 7.0] # in MeV\n    \n    # Angles for rotations in radians\n    alpha, beta, gamma, delta = 0.3, -0.7, 0.5, 0.2\n    theta1, theta2, theta3, theta4 = -0.4, 0.65, -0.25, 0.15\n    \n    # Test suite of cutoff thresholds\n    test_cases = [1e-12, 1e-6, 1e-1, 6e-1, 2.0]\n\n    def givens_rotation(dim, i, j, angle):\n        \"\"\"Constructs a Givens rotation matrix.\"\"\"\n        G = np.identity(dim)\n        c, s = np.cos(angle), np.sin(angle)\n        G[i, i] = c\n        G[j, j] = c\n        G[i, j] = -s\n        G[j, i] = s\n        return G\n\n    # Construct the orthogonal matrix Q for the overlap matrix S\n    G1_Q = givens_rotation(n, 0, 1, alpha)\n    G2_Q = givens_rotation(n, 2, 3, beta)\n    G3_Q = givens_rotation(n, 1, 2, gamma)\n    G4_Q = givens_rotation(n, 0, 4, delta)\n    Q = np.linalg.multi_dot([G4_Q, G3_Q, G2_Q, G1_Q])\n\n    # Construct the overlap matrix S\n    D_s = np.diag(s_eigvals)\n    S = Q @ D_s @ Q.T\n\n    # Construct the orthogonal matrix R for the Hamiltonian H\n    G1_R = givens_rotation(n, 0, 2, theta1)\n    G2_R = givens_rotation(n, 3, 4, theta2)\n    G3_R = givens_rotation(n, 1, 4, theta3)\n    G4_R = givens_rotation(n, 0, 3, theta4)\n    R = np.linalg.multi_dot([G4_R, G3_R, G2_R, G1_R])\n\n    # Construct the Hamiltonian matrix H\n    D_e = np.diag(e_eigvals)\n    H = R @ D_e @ R.T\n\n    all_results = []\n    \n    for epsilon in test_cases:\n        # Step 1: Diagonalize the overlap matrix S\n        # np.linalg.eigh returns eigenvalues in ascending order\n        s_vals, U = np.linalg.eigh(S)\n\n        # Step 2: Filter eigenmodes based on the cutoff threshold epsilon\n        # Keep modes where eigenvalue s > epsilon\n        keep_mask = s_vals > epsilon\n        num_kept = np.sum(keep_mask)\n        \n        if num_kept == 0:\n            all_results.append([])\n            continue\n\n        s_kept = s_vals[keep_mask]\n        U_kept = U[:, keep_mask]\n\n        # Step 3: Construct the transformation matrix X\n        # X = U_kept * (D_s_kept)^(-1/2)\n        X = U_kept / np.sqrt(s_kept)\n\n        # Step 4: Transform the Hamiltonian to the new orthonormal basis\n        H_tilde = X.T @ H @ X\n\n        # Step 5: Solve the standard eigenvalue problem for the transformed Hamiltonian\n        # np.linalg.eigh returns sorted eigenvalues\n        energies = np.linalg.eigh(H_tilde)[0]\n\n        # Round the resulting energies to six decimal places\n        rounded_energies = np.round(energies, 6).tolist()\n        all_results.append(rounded_energies)\n\n    # Format the final output string exactly as required\n    output_parts = []\n    for res_list in all_results:\n        # Format each number to have 6 decimal places.\n        formatted_energies = [f\"{val:.6f}\" for val in res_list]\n        inner_string = f\"[{','.join(formatted_energies)}]\"\n        output_parts.append(inner_string)\n    \n    final_output_string = f\"[{','.join(output_parts)}]\"\n    \n    print(final_output_string)\n\nsolve()\n```", "id": "3542310"}]}