{"hands_on_practices": [{"introduction": "The fundamental definition of nuclear level density, $\\rho(E)$, is combinatorial: it is the number of distinct quantum states available to a nucleus at a given excitation energy $E$. This exercise takes you to the microscopic core of this concept, tasking you with building a level density from scratch by explicitly counting particle-hole configurations within the Independent Particle Model. By implementing a recursive algorithm, you will manage the combinatorial complexity and gain a concrete, ground-up understanding of how the vast number of nuclear states arises from single-particle arrangements, a cornerstone of statistical nuclear physics [@problem_id:3575162].", "problem": "You are given finite independent single-particle spectra for protons and neutrons, specified by energy distances from their respective Fermi energies and level degeneracies. Under the Independent Particle Model (IPM) and Fermi-Dirac statistics, the microcanonical nuclear level density is defined as the count of distinct many-body configurations at fixed excitation energy. Formally, the nuclear level density at excitation energy $U$ is the number of many-body states with energy $U$ above the ground state, and can be written as a microcanonical sum over configurations that preserve particle number for protons and neutrons separately. In this setting, excitations are particle-hole rearrangements: for each species (protons or neutrons), you remove $k$ occupied single-particle states from levels below the Fermi energy (creating $k$ holes) and add $k$ particles into levels above the Fermi energy (creating $k$ particles), thereby preserving the total number of particles for that species. The excitation energy contributed by a given species is the sum of the selected particle energies above the Fermi energy plus the sum of the magnitudes of the selected hole energies below the Fermi energy; the total excitation energy is the sum over species.\n\nLet $s \\in \\{p,n\\}$ denote species (protons $p$ or neutrons $n$). For each species, let $\\{\\epsilon_{k}^{(s,+)}\\}$ be the set of positive energy distances (in megaelectronvolts) of single-particle levels above the Fermi energy, with degeneracies $\\{g_{k}^{(s,+)}\\}$, and let $\\{\\epsilon_{k}^{(s,-)}\\}$ be the set of positive energy magnitudes (in megaelectronvolts) of single-particle levels below the Fermi energy, with degeneracies $\\{g_{k}^{(s,-)}\\}$. Each degeneracy $g$ represents the number of distinct quantum substates at that level and enforces Pauli exclusion so that at most $g$ particles (or holes) can be placed in that level.\n\nDefine the species-level generating polynomials\n$$\nP_s(x,q) = \\prod_{k} \\left( \\sum_{m=0}^{g_{k}^{(s,+)}} \\binom{g_{k}^{(s,+)}}{m} x^{m} q^{m \\epsilon_{k}^{(s,+)}} \\right),\n\\quad\nH_s(x,q) = \\prod_{k} \\left( \\sum_{m=0}^{g_{k}^{(s,-)}} \\binom{g_{k}^{(s,-)}}{m} x^{m} q^{m \\epsilon_{k}^{(s,-)}} \\right),\n$$\nwhere $x$ tracks the number of selected substates and $q$ tracks energy. The equal-particle-hole constraint for fixed particle number is enforced by matching the power of $x$ in $P_s$ and $H_s$. The microcanonical species excitation distribution is obtained by summing over matched $k$ and convolving the energy contributions. Across species, the total excitation is the convolution of the proton and neutron species distributions. The microcanonical nuclear level density $\\rho(U)$ is the count of distinct many-body configurations whose total excitation energy lies within a bin of width $\\Delta U$ centered at $U$. That is, states with total energy $E$ are counted if $|E - U| \\le \\Delta U/2$.\n\nYour task is to write a complete, runnable program that, for the provided test suite, computes $\\rho(U)$ by explicit combinatorial counting using recursive partition functions (dynamic programming over levels and degeneracies), enforcing the particle-hole equality per species and performing the convolution across species. All energies must be treated in megaelectronvolts (MeV). Use exact arithmetic for energy sums so that binning is performed with respect to the interval $[U - \\Delta U/2, U + \\Delta U/2]$ in MeV.\n\nRequirements:\n1. Implement the combinatorial counting:\n   - For each species $s$, construct the distributions of particle excitation energies and hole excitation energies as a function of the number of selected substates $k$, using recursion over levels and degeneracies and the binomial factor $\\binom{g}{m}$ for selecting $m$ substates from a level of degeneracy $g$.\n   - Enforce the particle-number conservation separately for protons and neutrons by matching the number of particles and holes ($k$) for each species and convolving their energy contributions.\n   - Convolve the proton and neutron energy distributions to obtain the total excitation energy distribution.\n   - Count configurations whose total excitation energy lies within the specified bin centered at $U$ of width $\\Delta U$, i.e., satisfy $|E - U| \\le \\Delta U/2$.\n\n2. Physical units: All energies are in megaelectronvolts (MeV). The bin width $\\Delta U$ is in MeV. The excitation energy $U$ is in MeV.\n\n3. Output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3]\"), where each result is an integer count for the corresponding test case.\n\n4. Angle units are not applicable in this problem.\n\nTest Suite:\nCompute $\\rho(U)$ for the following four cases, each expressed in MeV and integers for degeneracies. In each case, the input consists of:\n- Proton levels below the Fermi energy: a list of pairs $(\\epsilon^{(p,-)}, g^{(p,-)})$ with $\\epsilon^{(p,-)} > 0$ in MeV.\n- Proton levels above the Fermi energy: a list of pairs $(\\epsilon^{(p,+)}, g^{(p,+)})$ with $\\epsilon^{(p,+)} > 0$ in MeV.\n- Neutron levels below the Fermi energy: a list of pairs $(\\epsilon^{(n,-)}, g^{(n,-)})$ with $\\epsilon^{(n,-)} > 0$ in MeV.\n- Neutron levels above the Fermi energy: a list of pairs $(\\epsilon^{(n,+)}, g^{(n,+)})$ with $\\epsilon^{(n,+)} > 0$ in MeV.\n- Bin width $\\Delta U$ in MeV.\n- Target excitation energy $U$ in MeV.\n\nCase 1 (general, mixed spectrum):\n- Protons below: $(0.8, 2)$, $(0.5, 2)$.\n- Protons above: $(0.4, 2)$, $(0.9, 1)$.\n- Neutrons below: $(0.7, 2)$.\n- Neutrons above: $(0.6, 1)$, $(1.1, 1)$.\n- $\\Delta U = 0.1$.\n- $U = 1.0$.\n\nCase 2 (boundary condition at zero excitation):\n- Protons below: $(0.8, 2)$, $(0.5, 2)$.\n- Protons above: $(0.4, 2)$, $(0.9, 1)$.\n- Neutrons below: $(0.7, 2)$.\n- Neutrons above: $(0.6, 1)$, $(1.1, 1)$.\n- $\\Delta U = 0.1$.\n- $U = 0.0$.\n\nCase 3 (single-level symmetry with rounding sensitivity):\n- Protons below: $(0.5, 3)$.\n- Protons above: $(0.5, 3)$.\n- Neutrons below: (none).\n- Neutrons above: (none).\n- $\\Delta U = 0.2$.\n- $U = 1.0$.\n\nCase 4 (higher combinatorial complexity):\n- Protons below: $(0.3, 4)$, $(0.7, 2)$.\n- Protons above: $(0.2, 3)$, $(0.9, 1)$.\n- Neutrons below: $(0.4, 3)$.\n- Neutrons above: $(0.1, 5)$, $(0.8, 1)$.\n- $\\Delta U = 0.05$.\n- $U = 1.0$.\n\nYour program must compute the integer counts $\\rho(U)$ for the four cases and print them in the exact required format on a single line.", "solution": "The user-provided problem is a valid, well-posed problem in computational nuclear physics. It is scientifically grounded in the Independent Particle Model (IPM) and utilizes standard combinatorial techniques from statistical mechanics to calculate the nuclear level density. The problem statement is complete, providing all necessary single-particle spectra, degeneracies, and parameters for the test cases. The objective is clearly defined and computationally tractable.\n\nThe solution proceeds by implementing a combinatorial enumeration of many-body particle-hole configurations. The core of the methodology is a dynamic programming algorithm that calculates the number of ways to form excitations of a given energy, which is mathematically equivalent to expanding the generating functions provided in the problem description.\n\n### Principle of the Method\n\nThe nuclear level density $\\rho(U)$ is the number of distinct quantum states in a narrow energy interval $[U - \\Delta U/2, U + \\Delta U/2]$. In the IPM, these states are constructed as particle-hole excitations relative to the ground state. A $k$-particle-$k$-hole ($k$p-$k$h) excitation involves promoting $k$ nucleons from occupied orbitals below the Fermi energy to unoccupied orbitals above it. The total excitation energy $E$ is the sum of the energies of the created particles (relative to the Fermi energy) and the absolute energies of the created holes.\n\nThe calculation is performed in three main stages:\n1.  **Exciton Energy Distribution per Species:** For each species $s \\in \\{p, n\\}$ (protons, neutrons), and separately for particles and holes, we compute the distribution of energies for creating $k$ excitons. Let $D_s^{(+)}(k_p, E_p)$ be the number of ways to place $k_p$ particles in levels above the Fermi energy with total particle energy $E_p$. Similarly, let $D_s^{(-)}(k_h, E_h)$ be the number of ways to create $k_h$ holes in levels below the Fermi energy with total hole energy $E_h$.\n2.  **Species Energy Distribution:** Particle-number conservation for each species is enforced by requiring the number of particles to equal the number of holes, i.e., $k_p = k_h = k$. The total excitation energy for species $s$ is $E_s = E_p + E_h$. The distribution of $E_s$ is found by convolving the particle and hole energy distributions for each $k$ and summing over all possible $k$.\n3.  **Total Nuclear Energy Distribution:** The total nuclear excitation energy is $E = E_p + E_n$, where $E_p$ and $E_n$ are the total excitation energies of the proton and neutron systems, respectively. The final distribution of total energy $E$ is obtained by convolving the species-specific energy distributions.\n\n### Algorithmic Implementation\n\nA dynamic programming approach is employed to compute the exciton distributions. To avoid floating-point inaccuracies in summations, all energies are scaled by a factor of $1000$ and treated as integers. The required precision for binning in Case 4, $|E - 1.0| \\le 0.05/2$, necessitates three decimal places, making a scale of $1000$ appropriate.\n\n#### 1. Computing Particle/Hole Distributions\n\nFor a given set of levels (e.g., proton particle levels) $\\{(\\epsilon_i, g_i)\\}$, we compute a map $D(k, E)$ storing the number of ways to form a $k$-exciton state with total scaled energy $E$. We initialize the distribution with the ground state (0 excitons, 0 energy, 1 way): $D(0, 0) = 1$. We then iterate through each level $(\\epsilon_i, g_i)$ and update the distribution. For each level, we consider placing $m$ excitons in it, where $1 \\le m \\le g_i$. This can be done in $\\binom{g_i}{m}$ ways and adds $m \\cdot \\epsilon_i$ to the energy. This step is equivalent to multiplying the current distribution polynomial by the level-specific polynomial $\\sum_{m=0}^{g_i} \\binom{g_i}{m} x^m q^{m\\epsilon_i}$. The process is repeated for all levels, yielding the final distribution for that set of levels. This is done for proton particles, proton holes, neutron particles, and neutron holes separately.\n\n#### 2. Enforcing Conservation and Convolution\n\nFor each species $s$, a new distribution $S_s(E_s)$ is constructed. It is initialized with $S_s(0) = 1$ for the $k=0$ ground state. Then, for each number of pairs $k \\ge 1$, we convolve the $k$-particle energy distribution with the $k$-hole energy distribution. The resulting counts for each total species energy $E_s = E_p + E_h$ are added to $S_s(E_s)$.\n\n$$ S_s(E_s) = \\sum_{k} \\sum_{E_p+E_h=E_s} D_s^{(+)}(k, E_p) \\cdot D_s^{(-)}(k, E_h) $$\n\nNext, the total nuclear energy distribution, $D_{total}(E)$, is obtained by convolving the proton and neutron species distributions, $S_p$ and $S_n$:\n\n$$ D_{total}(E) = \\sum_{E_p+E_n=E} S_p(E_p) \\cdot S_n(E_n) $$\n\nAll distributions are implemented as dictionaries mapping scaled energies to integer counts, which efficiently handles the sparse nature of the energy spectra.\n\n#### 3. Final Binning\n\nThe final step is to sum the counts of all states in $D_{total}(E)$ whose unscaled energy $E_{MeV} = E_{scaled} / 1000$ falls within the target bin $[U - \\Delta U/2, U + \\Delta U/2]$. The result is the integer level density $\\rho(U)$.", "answer": "```python\nimport math\nfrom collections import defaultdict\n\ndef get_ph_distribution(levels, scale):\n    \"\"\"\n    Computes the distribution of energies for creating k particles or k holes\n    using dynamic programming. This is equivalent to expanding the generating\n    polynomial for a set of single-particle levels.\n\n    Args:\n        levels (list): A list of tuples (energy_MeV, degeneracy).\n        scale (int): The factor to scale energies into integers for exact arithmetic.\n\n    Returns:\n        A dictionary dp[k][scaled_E] = count, representing the number of ways (count)\n        to create k excitons with a total scaled energy of scaled_E.\n    \"\"\"\n    dp = defaultdict(lambda: defaultdict(int))\n    dp[0][0] = 1\n\n    for energy, g in levels:\n        scaled_energy = int(round(energy * scale))\n        \n        # We iterate over k in reverse to update dp in-place. This is a standard\n        # knapsack-style DP optimization to ensure that contributions from the\n        # current level are correctly partitioned and not re-used.\n        k_max = max(dp.keys()) if dp else 0\n        \n        for k_prev in range(k_max, -1, -1):\n            if k_prev in dp:\n                energy_map_prev = dp[k_prev]\n                for m in range(1, g + 1):\n                    comb = math.comb(g, m)\n                    energy_contrib = m * scaled_energy\n                    k_new = k_prev + m\n                    for E_prev, count_prev in energy_map_prev.items():\n                        E_new = E_prev + energy_contrib\n                        count_new = count_prev * comb\n                        dp[k_new][E_new] += count_new\n    return dp\n\ndef get_species_distribution(hole_levels, particle_levels, scale):\n    \"\"\"\n    Computes the total excitation energy distribution for a single species\n    (e.g., protons), enforcing the constraint that the number of particles\n    equals the number of holes (k_p = k_h).\n\n    Args:\n        hole_levels (list): Single-particle levels below the Fermi energy.\n        particle_levels (list): Single-particle levels above the Fermi energy.\n        scale (int): Energy scaling factor.\n\n    Returns:\n        A dictionary species_dist[scaled_E] = count for the species.\n    \"\"\"\n    h_dist = get_ph_distribution(hole_levels, scale)\n    p_dist = get_ph_distribution(particle_levels, scale)\n\n    species_dist = defaultdict(int)\n    species_dist[0] = 1 # k=0 ground state\n\n    max_k_h = max(h_dist.keys()) if h_dist else 0\n    max_k_p = max(p_dist.keys()) if p_dist else 0\n    max_k_pairs = min(max_k_h, max_k_p)\n    \n    for k in range(1, max_k_pairs + 1):\n        if k in h_dist and k in p_dist:\n            energy_map_h = h_dist[k]\n            energy_map_p = p_dist[k]\n            \n            # Convolve the energy distributions for this k\n            for E_h, count_h in energy_map_h.items():\n                for E_p, count_p in energy_map_p.items():\n                    E_total_species = E_h + E_p\n                    count_total_species = count_h * count_p\n                    species_dist[E_total_species] += count_total_species\n    \n    return species_dist\n\ndef calculate_rho(case_data):\n    \"\"\"\n    Calculates the nuclear level density rho(U) for a given test case.\n    \"\"\"\n    p_below, p_above, n_below, n_above, dU, U = case_data\n    # A scale of 1000 is chosen to handle up to 3 decimal places,\n    # necessary for the binning in Case 4.\n    scale = 1000\n\n    p_dist = get_species_distribution(p_below, p_above, scale)\n    n_dist = get_species_distribution(n_below, n_above, scale)\n\n    # Convolve proton and neutron distributions to get the total nuclear distribution\n    total_dist = defaultdict(int)\n    for E_p, count_p in p_dist.items():\n        for E_n, count_n in n_dist.items():\n            E_total = E_p + E_n\n            count = count_p * count_n\n            total_dist[E_total] += count\n\n    # Perform binning to get the final count\n    lower_bound = U - dU / 2.0\n    upper_bound = U + dU / 2.0\n    \n    total_count = 0\n    for scaled_E, count in total_dist.items():\n        E_mev = scaled_E / scale\n        if lower_bound <= E_mev <= upper_bound:\n            total_count += count\n            \n    return total_count\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # Case 1 (general, mixed spectrum)\n        (\n            [(0.8, 2), (0.5, 2)],  # Protons below\n            [(0.4, 2), (0.9, 1)],  # Protons above\n            [(0.7, 2)],            # Neutrons below\n            [(0.6, 1), (1.1, 1)],  # Neutrons above\n            0.1, 1.0               # dU, U\n        ),\n        # Case 2 (boundary condition at zero excitation)\n        (\n            [(0.8, 2), (0.5, 2)],\n            [(0.4, 2), (0.9, 1)],\n            [(0.7, 2)],\n            [(0.6, 1), (1.1, 1)],\n            0.1, 0.0\n        ),\n        # Case 3 (single-level symmetry)\n        (\n            [(0.5, 3)],\n            [(0.5, 3)],\n            [],\n            [],\n            0.2, 1.0\n        ),\n        # Case 4 (higher combinatorial complexity)\n        (\n            [(0.3, 4), (0.7, 2)],\n            [(0.2, 3), (0.9, 1)],\n            [(0.4, 3)],\n            [(0.1, 5), (0.8, 1)],\n            0.05, 1.0\n        ),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = calculate_rho(case)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3575162"}, {"introduction": "Whether constructed from first principles or approximated by a phenomenological formula, any physically valid level density model must conform to the fundamental laws of thermodynamics. This practice shifts the focus from building a model to validating one, where you will write a program to test the consistency of various proposed forms of $\\rho(E)$. By computing the microcanonical entropy ($S$), temperature ($T$), and heat capacity ($C$), you will learn to identify pathological behaviors like negative temperatures or unphysical heat capacities, developing a critical toolkit for evaluating and debugging any statistical model in physics [@problem_id:3575214].", "problem": "You are given a proposed nuclear level density function $\\rho(E)$ as a function of excitation energy $E$ for a finite nucleus. In the microcanonical ensemble, the entropy $S(E)$, temperature $T(E)$, and heat capacity $C(E)$ must satisfy basic thermodynamic consistency conditions. Your task is to implement a program that, for a set of specified $\\rho(E)$ models, computes $S(E)$, $T(E)$, and $C(E)$ on a discrete energy grid and verifies consistency by checking the following conditions: (i) positivity of $\\rho(E)$, (ii) monotonic non-decrease of $S(E)$ as a function of $E$, (iii) positivity of $T(E)$, and (iv) absence of negative heat capacity in the specified energy regime. Energies must be treated in megaelectronvolts (MeV), temperatures must be expressed in MeV (assuming Boltzmann constant $k_{\\mathrm{B}} = 1$ so that temperature has energy units), and heat capacity $C(E)$ is dimensionless because it is measured in units of energy per unit temperature. The program must produce a single line of output containing the results for all test cases as a comma-separated list enclosed in square brackets.\n\nFundamental base and definitions:\n- The microcanonical entropy is defined by $S(E) = \\ln \\rho(E) + \\text{constant}$, where the additive constant does not affect derivatives.\n- The microcanonical temperature is defined by $\\frac{1}{T(E)} = \\frac{dS}{dE}$, hence $T(E) = \\left(\\frac{dS}{dE}\\right)^{-1}$ provided $\\frac{dS}{dE} > 0$.\n- The microcanonical heat capacity is defined by $C(E) = \\frac{dE}{dT} = \\left(\\frac{dT}{dE}\\right)^{-1}$, so $C(E) < 0$ if and only if $\\frac{dT}{dE} < 0$.\n\nAlgorithmic requirements:\n- Use a uniform energy grid $E \\in [E_{\\min}, E_{\\max}]$ with step size $\\Delta E$, all in $\\mathrm{MeV}$.\n- Compute $S(E) = \\ln \\rho(E)$ for all grid points where $\\rho(E) > 0$.\n- Approximate derivatives by finite differences using a method consistent with the discrete uniform grid, e.g., central differences or a numerical gradient that respects the spacing $\\Delta E$.\n- Compute $T(E) = \\left(\\frac{dS}{dE}\\right)^{-1}$ and $\\frac{dT}{dE}$ on the same grid.\n- Apply the consistency checks:\n  1. $\\rho(E) > 0$ for all grid points.\n  2. $S(E)$ is monotonically non-decreasing, i.e., $S(E_{i+1}) - S(E_i) \\ge 0$ for all consecutive grid points $E_i$ and $E_{i+1}$, up to a small numerical tolerance to account for finite-difference error.\n  3. $T(E) > 0$ for all grid points.\n  4. In the specified regime for each test case (defined by $E \\ge E_{\\mathrm{check}}$), there is no negative heat capacity; equivalently, $\\frac{dT}{dE} \\ge 0$ in that regime, up to a small numerical tolerance.\n\nTest suite:\n- Test case $1$ (back-shifted Fermi-gas inspired level density): $$ \\rho(E) = A \\frac{\\exp\\!\\left(2 \\sqrt{a (E - \\Delta)}\\right)}{(E - \\Delta)^{5/4}} $$ for $E > \\Delta$, with parameters $A = 10^{-9}$, $a = 6.0 \\, \\mathrm{MeV}^{-1}$, $\\Delta = 0.5 \\, \\mathrm{MeV}$; energy grid $E \\in [1.0 \\, \\mathrm{MeV}, 30.0 \\, \\mathrm{MeV}]$ with $\\Delta E = 0.05 \\, \\mathrm{MeV}$; check regime threshold $E_{\\mathrm{check}} = 1.5 \\, \\mathrm{MeV}$.\n- Test case $2$ (constant-temperature model): $$ \\rho(E) = \\frac{1}{T_0} \\exp\\!\\left(\\frac{E - E_0}{T_0}\\right) $$ with parameters $T_0 = 1.2 \\, \\mathrm{MeV}$, $E_0 = 0.0 \\, \\mathrm{MeV}$; energy grid $E \\in [0.0 \\, \\mathrm{MeV}, 30.0 \\, \\mathrm{MeV}]$ with $\\Delta E = 0.05 \\, \\mathrm{MeV}$; check regime threshold $E_{\\mathrm{check}} = 0.0 \\, \\mathrm{MeV}$.\n- Test case $3$ (oscillatory-modulated exponential, intended to exhibit pathological features): $$ \\rho(E) = \\exp(\\alpha E)\\left[1 + \\epsilon \\sin(k E)\\right] $$ with parameters $\\alpha = 0.3 \\, \\mathrm{MeV}^{-1}$, $\\epsilon = 0.9$, $k = 1.0 \\, \\mathrm{MeV}^{-1}$; energy grid $E \\in [1.0 \\, \\mathrm{MeV}, 30.0 \\, \\mathrm{MeV}]$ with $\\Delta E = 0.05 \\, \\mathrm{MeV}$; check regime threshold $E_{\\mathrm{check}} = 1.0 \\, \\mathrm{MeV}$.\n- Test case $4$ (power-law growth above a threshold): $$ \\rho(E) = (E - E_c)^p $$ for $E > E_c$ with parameters $p = 3.0$, $E_c = 0.5 \\, \\mathrm{MeV}$; energy grid $E \\in [0.6 \\, \\mathrm{MeV}, 20.0 \\, \\mathrm{MeV}]$ with $\\Delta E = 0.05 \\, \\mathrm{MeV}$; check regime threshold $E_{\\mathrm{check}} = 0.6 \\, \\mathrm{MeV}$.\n\nVerification outputs:\n- For each test case, produce a single boolean that is `True` if all four checks are satisfied and `False` otherwise. Use a numerical tolerance $ \\tau = 10^{-8} $ when assessing monotonicity and non-negativity conditions on finite differences to account for numerical differentiation error.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example `[result_1,result_2,result_3,result_4]`, where each `result_i` is the boolean for test case `i` as described above.", "solution": "The problem statement has been validated and found to be valid. It is scientifically grounded in the principles of statistical mechanics as applied to nuclear physics, well-posed with all necessary parameters and conditions specified, and objective in its formulation. The task is to computationally verify the thermodynamic consistency of four proposed nuclear level density models, $\\rho(E)$, based on a set of clear, formal criteria.\n\nThe core of the problem lies in the relationships between the level density $\\rho(E)$ and the microcanonical entropy $S(E)$, temperature $T(E)$, and heat capacity $C(E)$. These relationships are derived from fundamental statistical mechanics.\nThe entropy is defined as $S(E) = \\ln \\rho(E)$, ignoring an irrelevant additive constant.\nThe temperature is the inverse of the rate of change of entropy with energy: $T(E) = \\left(\\frac{dS}{dE}\\right)^{-1}$.\nThe heat capacity is the inverse of the rate of change of temperature with energy: $C(E) = \\left(\\frac{dT}{dE}\\right)^{-1}$.\n\nFor a thermodynamically consistent system, the following conditions must hold:\n1.  The density of states must be positive: $\\rho(E) > 0$.\n2.  Entropy must be a non-decreasing function of energy: $\\frac{dS}{dE} \\ge 0$.\n3.  Temperature must be positive: $T(E) > 0$. This implies a stricter condition on entropy, $\\frac{dS}{dE} > 0$, as $T(E)$ would be undefined or infinite if $\\frac{dS}{dE}=0$.\n4.  The heat capacity must not be negative in the regimes typical of thermal equilibrium. A negative heat capacity, $C(E) < 0$, corresponds to a situation where the system cools down upon adding energy, which is a sign of instability or a phase transition. This condition is equivalent to $\\frac{dT}{dE} \\ge 0$.\n\nThe algorithmic procedure will be implemented for each test case as follows:\n- An energy grid $E$ is constructed from $E_{\\min}$ to $E_{\\max}$ with step $\\Delta E$.\n- The level density $\\rho(E_i)$ is calculated at each grid point $E_i$.\n- The entropy $S(E_i) = \\ln \\rho(E_i)$ is then computed.\n- The derivatives $\\frac{dS}{dE}$ and $\\frac{dT}{dE}$ are approximated numerically using a second-order central finite difference method, as implemented in `numpy.gradient`, which is appropriate for a uniform grid.\n- The four consistency checks are then applied sequentially. If any check fails, the model is deemed inconsistent. A numerical tolerance of $\\tau = 10^{-8}$ is used for checks involving inequalities to account for floating-point inaccuracies.\n\nLet us analyze each test case.\n\n**Test Case 1: Back-Shifted Fermi-Gas (BSFG) Model**\n- Level density: $$ \\rho(E) = A \\frac{\\exp\\!\\left(2 \\sqrt{a (E - \\Delta)}\\right)}{(E - \\Delta)^{5/4}} $$ for $E > \\Delta$.\n- Parameters: $A = 10^{-9}$, $a = 6.0 \\, \\mathrm{MeV}^{-1}$, $\\Delta = 0.5 \\, \\mathrm{MeV}$.\n- Grid: $E \\in [1.0, 30.0] \\, \\mathrm{MeV}$, $\\Delta E = 0.05 \\, \\mathrm{MeV}$.\n- Check regime: $E \\ge E_{\\mathrm{check}} = 1.5 \\, \\mathrm{MeV}$.\n\n1.  **Check $\\rho(E) > 0$**: The energy grid starts at $E=1.0 \\, \\mathrm{MeV}$, which is greater than $\\Delta = 0.5 \\, \\mathrm{MeV}$. All terms in the expression for $\\rho(E)$ are positive, so this check will pass.\n2.  **Check $S(E)$ monotonicity ($\\frac{dS}{dE} \\ge 0$)**: The entropy is $S(E) = \\ln A + 2\\sqrt{a(E-\\Delta)} - \\frac{5}{4}\\ln(E-\\Delta)$. Its derivative is $\\frac{dS}{dE} = \\frac{\\sqrt{a}}{\\sqrt{E-\\Delta}} - \\frac{5}{4(E-\\Delta)}$. For this to be positive, we require $\\sqrt{a(E-\\Delta)} > \\frac{5}{4}$, or $E-\\Delta > \\frac{25}{16a} = \\frac{25}{16 \\times 6} \\approx 0.26 \\, \\mathrm{MeV}$. Since the grid starts where $E-\\Delta = 0.5 \\, \\mathrm{MeV}$, this condition holds for all grid points.\n3.  **Check $T(E) > 0$**: This is equivalent to $\\frac{dS}{dE} > 0$, which was just established. This check will pass.\n4.  **Check $C(E) \\ge 0$ ($\\frac{dT}{dE} \\ge 0$) for $E \\ge 1.5 \\, \\mathrm{MeV}$**: The temperature is $T(E) = (\\frac{dS}{dE})^{-1} = \\frac{E-\\Delta}{\\sqrt{a(E-\\Delta)} - 5/4}$. The sign of its derivative, $\\frac{dT}{dE}$, is determined by its numerator in the quotient rule, which is proportional to $\\frac{1}{2}\\sqrt{a(E-\\Delta)} - \\frac{5}{4}$. For $\\frac{dT}{dE} \\ge 0$, we need $\\sqrt{a(E-\\Delta)} \\ge \\frac{5}{2}$, which implies $E-\\Delta \\ge \\frac{25}{4a} = \\frac{25}{24} \\approx 1.0417 \\, \\mathrm{MeV}$, or $E \\ge 1.5417 \\, \\mathrm{MeV}$. The check regime starts at $E_{\\mathrm{check}} = 1.5 \\, \\mathrm{MeV}$. There is a portion of the check regime, from $E=1.5 \\, \\mathrm{MeV}$ to approximately $E=1.54 \\, \\mathrm{MeV}$, where we expect $\\frac{dT}{dE} < 0$. This corresponds to a region of negative heat capacity, a known feature of the microcanonical treatment of the Fermi-gas model. Therefore, this check is expected to fail.\nThe expected result for Test Case 1 is **False**.\n\n**Test Case 2: Constant-Temperature Model**\n- Level density: $$ \\rho(E) = \\frac{1}{T_0} \\exp\\!\\left(\\frac{E - E_0}{T_0}\\right) $$\n- Parameters: $T_0 = 1.2 \\, \\mathrm{MeV}$, $E_0 = 0.0 \\, \\mathrm{MeV}$.\n- Grid: $E \\in [0.0, 30.0] \\, \\mathrm{MeV}$, $\\Delta E = 0.05 \\, \\mathrm{MeV}$.\n- Check regime: $E \\ge E_{\\mathrm{check}} = 0.0 \\, \\mathrm{MeV}$.\n\n1.  **Check $\\rho(E) > 0$**: The exponential function is always positive, as is $\\frac{1}{T_0}$. This check passes.\n2.  **Check $S(E)$ monotonicity**: $S(E) = \\frac{E-E_0}{T_0} - \\ln T_0$. The derivative is $\\frac{dS}{dE} = \\frac{1}{T_0}$. Since $T_0=1.2 > 0$, $\\frac{dS}{dE}$ is a positive constant. This check passes.\n3.  **Check $T(E) > 0$**: $T(E) = (\\frac{dS}{dE})^{-1} = T_0 = 1.2 \\, \\mathrm{MeV}$. This is positive, so the check passes.\n4.  **Check $C(E) \\ge 0$ ($\\frac{dT}{dE} \\ge 0$)**: Since $T(E)$ is a constant, its derivative $\\frac{dT}{dE} = 0$. This satisfies the condition $\\frac{dT}{dE} \\ge 0$. This check passes.\nThe expected result for Test Case 2 is **True**.\n\n**Test Case 3: Oscillatory-Modulated Exponential Model**\n- Level density: $$ \\rho(E) = \\exp(\\alpha E)\\left[1 + \\epsilon \\sin(k E)\\right] $$\n- Parameters: $\\alpha = 0.3 \\, \\mathrm{MeV}^{-1}$, $\\epsilon = 0.9$, $k = 1.0 \\, \\mathrm{MeV}^{-1}$.\n- Grid: $E \\in [1.0, 30.0] \\, \\mathrm{MeV}$, $\\Delta E = 0.05 \\, \\mathrm{MeV}$.\n- Check regime: $E \\ge E_{\\mathrm{check}} = 1.0 \\, \\mathrm{MeV}$.\n\n1.  **Check $\\rho(E) > 0$**: We need $1 + \\epsilon \\sin(k E) > 0$. With $\\epsilon = 0.9$, the term $1 + 0.9 \\sin(k E)$ is always between $1 - 0.9 = 0.1$ and $1 + 0.9 = 1.9$, so it is always positive. This check passes.\n2.  **Check $S(E)$ monotonicity ($\\frac{dS}{dE} \\ge 0$)**: $S(E) = \\alpha E + \\ln(1 + \\epsilon \\sin(k E))$. The derivative is $\\frac{dS}{dE} = \\alpha + \\frac{\\epsilon k \\cos(k E)}{1 + \\epsilon \\sin(k E)}$. For this to be non-negative, we need $\\alpha \\ge -\\frac{\\epsilon k \\cos(k E)}{1 + \\epsilon \\sin(k E)}$. The minimum value of this expression occurs when the fractional term is most negative. The minimum of $\\frac{\\cos(x)}{1+\\epsilon\\sin(x)}$ is $-\\frac{1}{\\sqrt{1-\\epsilon^2}}$. So we need $\\alpha \\ge \\frac{\\epsilon k}{\\sqrt{1-\\epsilon^2}}$. Plugging in the values: $\\alpha = 0.3$ and $\\frac{0.9 \\times 1.0}{\\sqrt{1-0.9^2}} \\approx 2.06$. The condition $0.3 \\ge 2.06$ is false. There will be regions where $\\frac{dS}{dE} < 0$. This check will fail. Consequently, Check 3 ($T(E) > 0$) will also fail in those regions.\nThe expected result for Test Case 3 is **False**.\n\n**Test Case 4: Power-Law Model**\n- Level density: $$ \\rho(E) = (E - E_c)^p $$ for $E > E_c$.\n- Parameters: $p = 3.0$, $E_c = 0.5 \\, \\mathrm{MeV}$.\n- Grid: $E \\in [0.6, 20.0] \\, \\mathrm{MeV}$, $\\Delta E = 0.05 \\, \\mathrm{MeV}$.\n- Check regime: $E \\ge E_{\\mathrm{check}} = 0.6 \\, \\mathrm{MeV}$.\n\n1.  **Check $\\rho(E) > 0$**: The grid starts at $E = 0.6 \\, \\mathrm{MeV}$, which is greater than $E_c = 0.5 \\, \\mathrm{MeV}$. So $(E - E_c)$ is always positive, and $\\rho(E)$ is positive. This check passes.\n2.  **Check $S(E)$ monotonicity**: $S(E) = p \\ln(E - E_c)$. The derivative is $\\frac{dS}{dE} = \\frac{p}{E-E_c}$. Given $p=3.0>0$ and $E>E_c$, $\\frac{dS}{dE}$ is always positive. This check passes.\n3.  **Check $T(E) > 0$**: Since $\\frac{dS}{dE} > 0$, $T(E) = (\\frac{dS}{dE})^{-1} = \\frac{E-E_c}{p}$ is always positive on the grid. This check passes.\n4.  **Check $C(E) \\ge 0$ ($\\frac{dT}{dE} \\ge 0$)**: The derivative of the temperature is $\\frac{dT}{dE} = \\frac{1}{p}$. With $p=3.0$, this is a positive constant, $\\frac{1}{3}$. This satisfies the condition, so the check passes.\nThe expected result for Test Case 4 is **True**.\n\nThe final implementation will codify this logic and produce the summary boolean list.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of validating thermodynamic consistency for\n    several nuclear level density models.\n    \"\"\"\n    \n    # Numerical tolerance for inequality checks.\n    tolerance = 1e-8\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"name\": \"Back-shifted Fermi-gas\",\n            \"rho_func\": lambda E, A, a, delta: A * np.exp(2 * np.sqrt(a * (E - delta))) / (E - delta)**(5/4),\n            \"params\": {\"A\": 1e-9, \"a\": 6.0, \"delta\": 0.5},\n            \"E_min\": 1.0, \"E_max\": 30.0, \"dE\": 0.05,\n            \"E_check\": 1.5,\n        },\n        {\n            \"name\": \"Constant-temperature\",\n            \"rho_func\": lambda E, T0, E0: (1/T0) * np.exp((E - E0) / T0),\n            \"params\": {\"T0\": 1.2, \"E0\": 0.0},\n            \"E_min\": 0.0, \"E_max\": 30.0, \"dE\": 0.05,\n            \"E_check\": 0.0,\n        },\n        {\n            \"name\": \"Oscillatory-modulated exponential\",\n            \"rho_func\": lambda E, alpha, epsilon, k: np.exp(alpha * E) * (1 + epsilon * np.sin(k * E)),\n            \"params\": {\"alpha\": 0.3, \"epsilon\": 0.9, \"k\": 1.0},\n            \"E_min\": 1.0, \"E_max\": 30.0, \"dE\": 0.05,\n            \"E_check\": 1.0,\n        },\n        {\n            \"name\": \"Power-law\",\n            \"rho_func\": lambda E, p, Ec: (E - Ec)**p,\n            \"params\": {\"p\": 3.0, \"Ec\": 0.5},\n            \"E_min\": 0.6, \"E_max\": 20.0, \"dE\": 0.05,\n            \"E_check\": 0.6,\n        },\n    ]\n\n    def check_consistency(case_data):\n        \"\"\"\n        Performs the four consistency checks for a given level density model.\n        Returns True if all checks pass, False otherwise.\n        \"\"\"\n        E_min, E_max, dE = case_data[\"E_min\"], case_data[\"E_max\"], case_data[\"dE\"]\n        num_points = int(round((E_max - E_min) / dE)) + 1\n        E_grid = np.linspace(E_min, E_max, num_points)\n\n        # Calculate rho(E) on the grid\n        try:\n            # Use np.errstate to handle potential warnings from log/sqrt of small numbers\n            with np.errstate(all='raise'):\n                 rho_vals = case_data[\"rho_func\"](E_grid, **case_data[\"params\"])\n        except (FloatingPointError, ValueError):\n            # A numerical error here (e.g., sqrt of negative) implies a domain violation.\n            return False\n\n        # Check 1: rho(E) > 0\n        if not np.all(rho_vals > 0):\n            return False\n            \n        # Calculate S(E) = ln(rho(E))\n        # This is safe because we just checked rho > 0\n        S_vals = np.log(rho_vals)\n        \n        # Calculate dS/dE\n        dS_dE = np.gradient(S_vals, dE)\n\n        # Check 2: S(E) is monotonically non-decreasing (dS/dE >= 0)\n        if not np.all(dS_dE >= -tolerance):\n            return False\n            \n        # Check 3: T(E) > 0. This implies dS/dE > 0.\n        # If dS/dE is zero or negative, T is ill-defined or negative.\n        # A small positive threshold is used to avoid division by zero.\n        if not np.all(dS_dE > 0): # Using 0 as strict lower bound is sufficient\n            return False\n\n        # Calculate T(E) = (dS/dE)^-1\n        T_vals = 1.0 / dS_dE\n\n        # Calculate dT/dE\n        dT_dE = np.gradient(T_vals, dE)\n\n        # Check 4: No negative heat capacity in the check regime (dT/dE >= 0)\n        check_regime_mask = E_grid >= case_data[\"E_check\"]\n        if not np.all(dT_dE[check_regime_mask] >= -tolerance):\n            return False\n\n        # If all checks pass\n        return True\n\n    results = []\n    for case in test_cases:\n        is_consistent = check_consistency(case)\n        results.append(is_consistent)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3575214"}, {"introduction": "Advanced, realistic calculations of nuclear level densities must incorporate the detailed outputs of modern nuclear structure models and project states onto good quantum numbers like spin and parity. This capstone exercise bridges the gap between pedagogical models and research-level computations by starting from a basis of quasiparticle excitations provided by a Hartree-Fock-Bogoliubov (HFB) calculation. You will implement a weighted combinatorial counting that includes parity projection and a spin-cutoff model, allowing you to build a sophisticated, state-of-the-art level density and critically compare its predictions to standard phenomenological formulas [@problem_id:3575182].", "problem": "Write a complete and runnable program that, for each test case specified below, constructs a combinatorial nuclear level density from Hartree–Fock–Bogoliubov (HFB) quasiparticle inputs and compares it to two phenomenological models. Your program must implement the following, starting from fundamental definitions.\n\n- Adopt the microcanonical definition of the level density as a count of many-body states at excitation energy $E$, with spin $J$ and parity $\\pi$: the level density is the density of states in energy, and the parity-resolved density $\\rho(E,\\pi)$ counts only those states with parity $\\pi$. For a specified bin width $\\Delta E$, approximate the Dirac delta in the counting by binning onto a uniform grid and dividing counts by $\\Delta E$ to obtain densities in $\\text{MeV}^{-1}$.\n\n- Use the independent quasiparticle approximation. Given a set of $N$ quasiparticles indexed by $i=1,\\dots,N$, each with excitation energy $\\varepsilon_i$, parity $\\pi_i \\in \\{+1,-1\\}$, and HFB occupation probability $v_i^2$ (so $u_i^2 = 1-v_i^2$), define a configuration $S \\subseteq \\{1,\\dots,N\\}$ to have excitation energy $E_S = \\sum_{i \\in S} \\varepsilon_i$ and parity $\\pi_S = \\prod_{i \\in S} \\pi_i$. Include the vacuum configuration $S=\\varnothing$ with $E_{\\varnothing} = 0$ and $\\pi_{\\varnothing}=+1$.\n\n- Incorporate HFB occupation amplitudes by assigning to each quasiparticle $i$ a pair-breaking weight $w_i = 4 u_i^2 v_i^2$, and define the configuration weight $W_S = \\prod_{i \\in S} w_i$ (and $W_{\\varnothing}=1$). Interpret $W_S$ as a statistical weight that modulates the contribution of configuration $S$ to the level density.\n\n- Construct parity-projected, binned combinatorial densities up to $E_{\\max} = 20\\,\\text{MeV}$ on a uniform grid with bin width $\\Delta E = 0.2\\,\\text{MeV}$. Use nearest-bin assignment: the contribution $W_S$ from $E_S$ is added to the bin whose center is closest to $E_S$, provided $E_S \\le E_{\\max}$. After summing all configurations, divide each bin count by $\\Delta E$ to obtain $\\rho(E,\\pi)$ in $\\text{MeV}^{-1}$.\n\n- Project spin using the spin-cutoff model. For a bin centered at energy $E_b$, define the intrinsic excitation $U = E_b - \\delta$ (set the density to zero if $U \\le 0$ for models that require $U>0$). The spin-cutoff parameter is\n$$\n\\sigma^2(E_b) = \\alpha\\, A^{2/3}\\, \\sqrt{a\\, U},\n$$\nwith $\\alpha$ specified per test case, mass number $A$, and level-density parameter $a$ (in $\\text{MeV}^{-1}$). The discrete spin distribution for integer $J \\in \\{0,1,\\dots,J_{\\max}\\}$ is\n$$\nP(J \\mid \\sigma) \\propto (2J+1) \\exp\\left(-\\frac{J(J+1)}{2\\sigma^2}\\right),\n$$\nnormalized by $\\sum_{J=0}^{J_{\\max}} P(J \\mid \\sigma) = 1$. For $\\sigma=0$, take $P(0 \\mid \\sigma)=1$ and $P(J>0 \\mid \\sigma)=0$. Form the spin-projected densities as $\\rho(E_b,J,\\pi) = \\rho(E_b,\\pi)\\, P(J \\mid \\sigma(E_b))$ and the total density $\\rho(E_b) = \\sum_{\\pi} \\rho(E_b,\\pi)$.\n\n- Compare $\\rho(E)$ with two phenomenological models (energies in $\\text{MeV}$, densities in $\\text{MeV}^{-1}$):\n  - Constant-temperature model:\n$$\n\\rho_{\\mathrm{CT}}(E) = \\frac{1}{T} \\exp\\left(\\frac{E - E_0}{T}\\right)\n$$\nwith $T$ and $E_0$ given.\n  - Back-shifted Fermi gas (BSFG): with backshift $\\delta$, intrinsic $U = E - \\delta$, and for $U \\le 0$ set $\\rho_{\\mathrm{BSFG}}(E)=0$. For $U>0$,\n$$\n\\rho_{\\mathrm{BSFG}}(E) = \\frac{\\sqrt{\\pi}}{12} \\frac{\\exp\\left(2\\sqrt{aU}\\right)}{a^{1/4} U^{5/4}}\n$$\n\nYour program must compute, for each test case, the following four scalar diagnostics using the binned densities, with the energy-bin centers matched to $E=8\\,\\text{MeV}$ and $E=10\\,\\text{MeV}$ by nearest bin index:\n\n1. The ratio $r_{\\mathrm{CT}}(10) = \\rho(10)/\\rho_{\\mathrm{CT}}(10)$.\n2. The ratio $r_{\\mathrm{BSFG}}(10) = \\rho(10)/\\rho_{\\mathrm{BSFG}}(10)$, interpreting $0/0$ as $0$.\n3. The parity asymmetry at $E=8\\,\\text{MeV}$,\n$$\n\\mathcal{A}_\\pi(8) = \\frac{\\rho(8,+) - \\rho(8,-)}{\\rho(8,+) + \\rho(8,-)},\n$$\nwith the convention $\\mathcal{A}_\\pi(8)=0$ if the denominator is zero.\n4. The spin-projected probability $P(J=0 \\mid \\sigma(10))$ at $E=10\\,\\text{MeV}$ using the discrete normalization on $J \\in \\{0,1,\\dots,J_{\\max}\\}$.\n\nPhysical and numerical units and conventions:\n\n- All energies $\\varepsilon_i$, $E$, $E_0$, $\\delta$, $T$ are in $\\text{MeV}$. The level-density parameter $a$ is in $\\text{MeV}^{-1}$. The output densities are in $\\text{MeV}^{-1}$. The ratios and probabilities are dimensionless.\n- Angles do not appear in this problem.\n- The program must implement the binning with $\\Delta E = 0.2\\,\\text{MeV}$ and $E_{\\max}=20\\,\\text{MeV}$, and spin projection with $J_{\\max}=12$.\n- Treat the vacuum configuration $S=\\varnothing$ as described, and ignore any configuration with $E_S > E_{\\max}$.\n\nTest suite:\n\n- Global parameters: $\\Delta E = 0.2\\,\\text{MeV}$, $E_{\\max} = 20\\,\\text{MeV}$, $J_{\\max} = 12$, $\\alpha = 0.146$.\n\n- Test case $1$:\n  - $A=56$, $a=7.0\\,\\text{MeV}^{-1}$, $\\delta=1.5\\,\\text{MeV}$, $T=0.9\\,\\text{MeV}$, $E_0=-0.5\\,\\text{MeV}$.\n  - $\\{\\varepsilon_i\\} = \\{0.8, 1.0, 1.3, 1.7, 2.0, 2.6, 3.1, 3.8, 4.2, 4.9, 5.6, 6.3\\}\\,\\text{MeV}$.\n  - $\\{v_i^2\\} = \\{0.95, 0.85, 0.70, 0.55, 0.50, 0.50, 0.45, 0.35, 0.30, 0.25, 0.20, 0.15\\}$.\n  - $\\{\\pi_i\\} = \\{+1, +1, -1, -1, +1, -1, +1, -1, +1, +1, -1, -1\\}$.\n\n- Test case $2$:\n  - $A=98$, $a=12.25\\,\\text{MeV}^{-1}$, $\\delta=1.0\\,\\text{MeV}$, $T=0.8\\,\\text{MeV}$, $E_0=-0.6\\,\\text{MeV}$.\n  - $\\{\\varepsilon_i\\} = \\{0.5, 0.7, 0.9, 1.1, 1.4, 1.8, 2.2, 2.7, 3.3, 3.9, 4.6, 5.4, 6.3\\}\\,\\text{MeV}$.\n  - $\\{v_i^2\\} = \\{0.90, 0.85, 0.80, 0.70, 0.60, 0.55, 0.50, 0.45, 0.40, 0.35, 0.30, 0.25, 0.20\\}$.\n  - $\\{\\pi_i\\} = \\{+1, -1, +1, -1, +1, -1, +1, -1, +1, -1, +1, -1, +1\\}$.\n\n- Test case $3$:\n  - $A=162$, $a=20.25\\,\\text{MeV}^{-1}$, $\\delta=0.8\\,\\text{MeV}$, $T=0.6\\,\\text{MeV}$, $E_0=-0.8\\,\\text{MeV}$.\n  - $\\{\\varepsilon_i\\} = \\{0.4, 0.6, 0.8, 1.0, 1.3, 1.6, 2.0, 2.5, 3.0, 3.6, 4.3\\}\\,\\text{MeV}$.\n  - $\\{v_i^2\\} = \\{0.80, 0.75, 0.70, 0.65, 0.60, 0.55, 0.50, 0.45, 0.40, 0.35, 0.30\\}$.\n  - $\\{\\pi_i\\} = \\{-1, -1, +1, +1, -1, +1, -1, +1, -1, +1, -1\\}$.\n\nFinal output format:\n\n- Your program should produce a single line of output containing a list of three lists (one per test case). For each test case, output the four diagnostics as a list in the order $[r_{\\mathrm{CT}}(10), r_{\\mathrm{BSFG}}(10), \\mathcal{A}_\\pi(8), P(J{=}0 \\mid \\sigma(10))]$. The three lists must be aggregated into a single top-level list and printed on one line, for example:\n\"[ [x11,x12,x13,x14], [x21,x22,x23,x24], [x31,x32,x33,x34] ]\"\nwhere each $x_{ij}$ is a floating-point number.", "solution": "The problem requires the implementation of a combinatorial model for nuclear level densities based on Hartree–Fock–Bogoliubov (HFB) quasiparticle inputs. The resulting level density is then compared to standard phenomenological models, and several diagnostic quantities are computed. The solution proceeds by first constructing the weighted, parity-projected combinatorial level density and then using this result to calculate the specified diagnostics.\n\n### 1. Combinatorial Level Density Calculation\n\nThe foundation of the calculation is the independent quasiparticle approximation. A nucleus is described by a set of $N$ quasiparticles, each indexed by $i \\in \\{1, \\dots, N\\}$. Each quasiparticle is characterized by an excitation energy $\\varepsilon_i$, a parity $\\pi_i \\in \\{+1, -1\\}$, and an HFB occupation probability $v_i^2$.\n\nA many-body configuration, denoted by a set $S \\subseteq \\{1, \\dots, N\\}$, corresponds to the simultaneous excitation of the quasiparticles in $S$. The total excitation energy $E_S$ and parity $\\pi_S$ of such a configuration are defined as the sum and product of the individual quasiparticle properties, respectively:\n$$\nE_S = \\sum_{i \\in S} \\varepsilon_i\n$$\n$$\n\\pi_S = \\prod_{i \\in S} \\pi_i\n$$\nThe set of all possible configurations includes the vacuum state, $S=\\varnothing$, for which the energy is $E_{\\varnothing} = 0$ and the parity is $\\pi_{\\varnothing} = +1$.\n\nWithin the HFB framework, the creation of a quasiparticle excitation corresponds to breaking a Cooper pair. The probability of a quasiparticle state $i$ being occupied is given by $v_i^2$, and the probability of it being empty is $u_i^2 = 1 - v_i^2$. The statistical weight for breaking the pair to create the $i$-th quasiparticle excitation is given by the pair-breaking weight $w_i$:\n$$\nw_i = 4 u_i^2 v_i^2 = 4 (1 - v_i^2) v_i^2\n$$\nThe statistical weight $W_S$ of a configuration $S$ is the product of the weights of the constituent quasiparticles:\n$$\nW_S = \\prod_{i \\in S} w_i\n$$\nFor the vacuum state, the weight is $W_{\\varnothing} = 1$. This weight $W_S$ modulates the contribution of configuration $S$ to the total level density.\n\nThe core of the algorithm involves iterating through all $2^N$ possible configurations. For each configuration $S$, we compute its energy $E_S$, parity $\\pi_S$, and weight $W_S$.\n\n### 2. Discretization and Density Formulation\n\nThe nuclear level density $\\rho(E)$ is formally the density of states per unit energy. To compute this from the discrete set of configurations, we employ a binning procedure. We define a uniform energy grid with a bin width of $\\Delta E = 0.2\\,\\text{MeV}$ up to a maximum energy $E_{\\max} = 20\\,\\text{MeV}$. Let the bin centers be $E_b = k \\cdot \\Delta E$ for integer $k \\ge 0$.\n\nFor each configuration $S$ with energy $E_S \\le E_{\\max}$, its weight $W_S$ is added to the contents of the bin whose center is closest to $E_S$. The index of this bin is found by $k = \\text{round}(E_S / \\Delta E)$. The contributions are collected separately for positive and negative parity states, yielding two arrays of binned sums, $C_+(E_b)$ and $C_-(E_b)$.\n\nThe parity-projected level densities, $\\rho(E_b, +)$ and $\\rho(E_b, -)$, are then obtained by dividing these sums by the bin width $\\Delta E$:\n$$\n\\rho(E_b, +) = \\frac{C_+(E_b)}{\\Delta E}\n$$\n$$\n\\rho(E_b, -) = \\frac{C_-(E_b)}{\\Delta E}\n$$\nThe total level density at bin center $E_b$ is the sum of the parity-projected densities:\n$$\n\\rho(E_b) = \\rho(E_b, +) + \\rho(E_b, -)\n$$\n\n### 3. Comparison with Phenomenological Models\n\nThe calculated combinatorial density $\\rho(E)$ is compared with two widely-used phenomenological models at specific energies.\n\n**Constant-Temperature (CT) Model:** This model assumes the nuclear temperature $T$ is constant over a certain energy range. The level density is given by:\n$$\n\\rho_{\\mathrm{CT}}(E) = \\frac{1}{T} \\exp\\left(\\frac{E - E_0}{T}\\right)\n$$\nwhere $T$ is the nuclear temperature and $E_0$ is an energy-shift parameter.\n\n**Back-Shifted Fermi Gas (BSFG) Model:** This model is based on the Fermi gas model of the nucleus, with a correction for pairing effects via a backshift parameter $\\delta$. The level density is defined for an intrinsic excitation energy $U = E - \\delta$. For $U > 0$, the formula is:\n$$\n\\rho_{\\mathrm{BSFG}}(E) = \\frac{\\sqrt{\\pi}}{12} \\frac{\\exp\\left(2\\sqrt{aU}\\right)}{a^{1/4} U^{5/4}}\n$$\nwhere $a$ is the level density parameter. For $U \\le 0$, the density is $\\rho_{\\mathrm{BSFG}}(E) = 0$.\n\n### 4. Spin Projection and Diagnostics\n\nThe calculated level density $\\rho(E_b, \\pi)$ is an intrinsic density, meaning it is summed over all spin projections $J_z$. To obtain a spin-dependent density, we use the spin-cutoff model.\n\nThe spin distribution at a given excitation energy is assumed to be governed by the spin-cutoff parameter $\\sigma(E_b)$. For a bin centered at $E_b$, the intrinsic energy is $U = E_b - \\delta$, and the square of the spin-cutoff parameter is:\n$$\n\\sigma^2(E_b) = \\alpha A^{2/3} \\sqrt{aU}\n$$\nwhere $A$ is the mass number and $\\alpha$ is a given constant. If $U \\le 0$, this formula is not used; typically, the spin distribution is taken to be a delta function at $J=0$.\n\nThe probability of a state having a specific integer spin $J$ is given by a normalized distribution:\n$$\nP(J \\mid \\sigma) = \\mathcal{N} (2J+1) \\exp\\left(-\\frac{J(J+1)}{2\\sigma^2}\\right)\n$$\nThe normalization factor $\\mathcal{N}$ is determined by requiring the sum over all considered spins to be unity: $\\sum_{J=0}^{J_{\\max}} P(J \\mid \\sigma) = 1$. For the edge case $\\sigma = 0$, the distribution is $P(0 \\mid \\sigma) = 1$ and $P(J>0 \\mid \\sigma) = 0$.\n\nThe problem requires the calculation of four specific diagnostic quantities for each test case, using the binned combinatorial density and the models described above at energies $E=8\\,\\text{MeV}$ and $E=10\\,\\text{MeV}$.\n\n1.  **Ratio to CT model at $E=10\\,\\text{MeV}$**: $r_{\\mathrm{CT}}(10) = \\rho(10) / \\rho_{\\mathrm{CT}}(10)$.\n2.  **Ratio to BSFG model at $E=10\\,\\text{MeV}$**: $r_{\\mathrm{BSFG}}(10) = \\rho(10) / \\rho_{\\mathrm{BSFG}}(10)$, with the convention that $0/0$ evaluates to $0$.\n3.  **Parity Asymmetry at $E=8\\,\\text{MeV}$**: $\\mathcal{A}_\\pi(8) = \\frac{\\rho(8,+) - \\rho(8,-)}{\\rho(8,+) + \\rho(8,-)}$. If the denominator is zero, $\\mathcal{A}_\\pi(8)=0$.\n4.  **Spin-0 Probability at $E=10\\,\\text{MeV}$**: $P(J=0 \\mid \\sigma(10))$, calculated using the discrete normalization over $J \\in \\{0, \\dots, J_{\\max}\\}$.\n\nThese diagnostics are computed by identifying the appropriate energy bins (whose centers are at $8.0\\,\\text{MeV}$ and $10.0\\,\\text{MeV}$) and applying the respective formulas.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Solves the nuclear level density problem for the specified test cases.\n    \"\"\"\n\n    # Global parameters\n    DELTA_E = 0.2  # MeV\n    E_MAX = 20.0   # MeV\n    J_MAX = 12\n    ALPHA = 0.146\n\n    test_cases = [\n        {\n            # Test case 1\n            \"A\": 56, \"a\": 7.0, \"delta\": 1.5, \"T\": 0.9, \"E0\": -0.5,\n            \"eps\": [0.8, 1.0, 1.3, 1.7, 2.0, 2.6, 3.1, 3.8, 4.2, 4.9, 5.6, 6.3],\n            \"v2\": [0.95, 0.85, 0.70, 0.55, 0.50, 0.50, 0.45, 0.35, 0.30, 0.25, 0.20, 0.15],\n            \"pi\": [+1, +1, -1, -1, +1, -1, +1, -1, +1, +1, -1, -1],\n        },\n        {\n            # Test case 2\n            \"A\": 98, \"a\": 12.25, \"delta\": 1.0, \"T\": 0.8, \"E0\": -0.6,\n            \"eps\": [0.5, 0.7, 0.9, 1.1, 1.4, 1.8, 2.2, 2.7, 3.3, 3.9, 4.6, 5.4, 6.3],\n            \"v2\": [0.90, 0.85, 0.80, 0.70, 0.60, 0.55, 0.50, 0.45, 0.40, 0.35, 0.30, 0.25, 0.20],\n            \"pi\": [+1, -1, +1, -1, +1, -1, +1, -1, +1, -1, +1, -1, +1],\n        },\n        {\n            # Test case 3\n            \"A\": 162, \"a\": 20.25, \"delta\": 0.8, \"T\": 0.6, \"E0\": -0.8,\n            \"eps\": [0.4, 0.6, 0.8, 1.0, 1.3, 1.6, 2.0, 2.5, 3.0, 3.6, 4.3],\n            \"v2\": [0.80, 0.75, 0.70, 0.65, 0.60, 0.55, 0.50, 0.45, 0.40, 0.35, 0.30],\n            \"pi\": [-1, -1, +1, +1, -1, +1, -1, +1, -1, +1, -1],\n        }\n    ]\n\n    results = []\n\n    num_bins = int(E_MAX / DELTA_E) + 1\n\n    for case in test_cases:\n        N = len(case[\"eps\"])\n        eps = np.array(case[\"eps\"])\n        v2 = np.array(case[\"v2\"])\n        pi = np.array(case[\"pi\"])\n        u2 = 1.0 - v2\n        w = 4.0 * u2 * v2\n        \n        # Initialize binned counts for positive and negative parity\n        counts_pos = np.zeros(num_bins)\n        counts_neg = np.zeros(num_bins)\n        \n        # Iterate through all 2^N configurations\n        for i in range(1 << N):\n            E_S = 0.0\n            pi_S = 1\n            W_S = 1.0\n            \n            for j in range(N):\n                if (i >> j) & 1:\n                    E_S += eps[j]\n                    pi_S *= pi[j]\n                    W_S *= w[j]\n            \n            if E_S <= E_MAX:\n                bin_idx = int(round(E_S / DELTA_E))\n                if bin_idx < num_bins:\n                    if pi_S == 1:\n                        counts_pos[bin_idx] += W_S\n                    else:\n                        counts_neg[bin_idx] += W_S\n\n        # Convert counts to densities\n        rho_pos = counts_pos / DELTA_E\n        rho_neg = counts_neg / DELTA_E\n\n        # --- Calculate Diagnostics ---\n        \n        E_diag_1 = 8.0\n        E_diag_2 = 10.0\n        \n        # Find bin indices for diagnostic energies\n        idx_8 = int(round(E_diag_1 / DELTA_E))\n        idx_10 = int(round(E_diag_2 / DELTA_E))\n        \n        # Get combinatorial densities at diagnostic energies\n        rho_pos_8 = rho_pos[idx_8]\n        rho_neg_8 = rho_neg[idx_8]\n        rho_total_8 = rho_pos_8 + rho_neg_8\n        \n        rho_pos_10 = rho_pos[idx_10]\n        rho_neg_10 = rho_neg[idx_10]\n        rho_total_10 = rho_pos_10 + rho_neg_10\n\n        # 1. Ratio r_CT(10)\n        rho_ct_10 = (1.0 / case[\"T\"]) * np.exp((E_diag_2 - case[\"E0\"]) / case[\"T\"])\n        r_ct_10 = rho_total_10 / rho_ct_10 if rho_ct_10 != 0 else 0.0\n\n        # 2. Ratio r_BSFG(10)\n        U_10 = E_diag_2 - case[\"delta\"]\n        if U_10 <= 0:\n            rho_bsfg_10 = 0.0\n        else:\n            a_val = case[\"a\"]\n            rho_bsfg_10 = (np.sqrt(np.pi) / 12.0) * \\\n                        np.exp(2.0 * np.sqrt(a_val * U_10)) / \\\n                        (a_val**0.25 * U_10**1.25)\n        \n        if rho_bsfg_10 == 0:\n            r_bsfg_10 = 0.0 if rho_total_10 == 0 else np.inf\n        else:\n            r_bsfg_10 = rho_total_10 / rho_bsfg_10\n\n        # 3. Parity asymmetry A_pi(8)\n        if rho_total_8 == 0:\n            A_pi_8 = 0.0\n        else:\n            A_pi_8 = (rho_pos_8 - rho_neg_8) / rho_total_8\n            \n        # 4. Spin-0 probability P(J=0 | sigma(10))\n        E_b_10 = idx_10 * DELTA_E\n        U_spin = E_b_10 - case[\"delta\"]\n        p_j0_10 = 0.0\n        \n        if U_spin <= 0:\n             p_j0_10 = 1.0 # sigma = 0 case\n        else:\n            sigma2 = ALPHA * (case[\"A\"]**(2.0/3.0)) * np.sqrt(case[\"a\"] * U_spin)\n            if sigma2 == 0:\n                p_j0_10 = 1.0\n            else:\n                j_vals = np.arange(0, J_MAX + 1)\n                p_unnorm = (2 * j_vals + 1) * np.exp(-j_vals * (j_vals + 1) / (2 * sigma2))\n                \n                # P(J=0) unnormalized is always 1\n                p_j0_unnorm = 1.0\n                norm_sum = np.sum(p_unnorm)\n                \n                p_j0_10 = p_j0_unnorm / norm_sum if norm_sum > 0 else 0.0\n\n        case_results = [r_ct_10, r_bsfg_10, A_pi_8, p_j0_10]\n        results.append(case_results)\n\n    # Format the final output string precisely\n    final_output_str = \"[\"\n    for i, res_list in enumerate(results):\n        inner_str = '[' + ','.join(map(str, res_list)) + ']'\n        final_output_str += inner_str\n        if i < len(results) - 1:\n            final_output_str += ','\n    final_output_str += \"]\"\n    \n    print(final_output_str)\n\nsolve()\n```", "id": "3575182"}]}