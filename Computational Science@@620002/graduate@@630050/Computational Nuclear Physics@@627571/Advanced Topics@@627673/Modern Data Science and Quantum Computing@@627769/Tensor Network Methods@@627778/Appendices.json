{"hands_on_practices": [{"introduction": "A foundational concept in tensor network theory is the Matrix Product State (MPS), which provides an efficient representation for quantum states in one-dimensional systems that obey an area law for entanglement. The efficiency of an MPS is governed by its bond dimension, a parameter that directly relates to the amount of entanglement the state can capture. This first exercise [@problem_id:2453969] provides a concrete, analytical link between the abstract concept of bond dimension and the physical entanglement structure of a quantum state, as quantified by the Schmidt decomposition, using the iconic Greenberger–Horne–Zeilinger (GHZ) state as a minimal, non-trivial example.", "problem": "In the context of the Density Matrix Renormalization Group (DMRG) used in computational chemistry, the Matrix Product State (MPS) formalism represents a quantum state on a one-dimensional lattice of sites. Consider a chain of $N=3$ sites, each site corresponding to a spin-orbital with local occupation basis $\\{|0\\rangle, |1\\rangle\\}$. An open-boundary MPS for a state $|\\Psi\\rangle$ can be written as\n$$\n|\\Psi\\rangle=\\sum_{s_1,s_2,s_3\\in\\{0,1\\}} \\left(v_L A^{[1] s_1} A^{[2] s_2} A^{[3] s_3} v_R\\right) |s_1 s_2 s_3\\rangle,\n$$\nwhere $A^{[i] s_i}$ are site-dependent matrices (with compatible bond dimensions) associated with the physical index $s_i\\in\\{0,1\\}$, and $v_L$ and $v_R$ are boundary vectors implementing open boundaries. Consider the Greenberger–Horne–Zeilinger (GHZ) state on $3$ sites,\n$$\n|\\Psi_{\\mathrm{GHZ}}\\rangle=\\frac{1}{\\sqrt{2}}\\left(|000\\rangle+|111\\rangle\\right).\n$$\nConstruct an explicit open-boundary MPS representation that exactly produces $|\\Psi_{\\mathrm{GHZ}}\\rangle$ with correct normalization, and determine the minimal bond dimension $D_{\\min}$ required by any exact open-boundary MPS representation of $|\\Psi_{\\mathrm{GHZ}}\\rangle$ on $3$ sites. Report only the value of $D_{\\min}$ as your final answer.", "solution": "The problem is well-defined within the framework of quantum mechanics and tensor network theory, and all premises are factually and scientifically sound. We may therefore proceed directly to the formal derivation.\n\nThe objective is to determine the minimal bond dimension, denoted $D_{\\min}$, for an exact open-boundary Matrix Product State (MPS) representation of the $N=3$ site Greenberger–Horne–Zeilinger (GHZ) state:\n$$ |\\Psi_{\\mathrm{GHZ}}\\rangle=\\frac{1}{\\sqrt{2}}\\left(|000\\rangle+|111\\rangle\\right) $$\nA fundamental result in the theory of MPS states that for a one-dimensional quantum system, the minimal bond dimension $D_k$ required at the virtual link between site $k$ and site $k+1$ is precisely the Schmidt rank $\\chi_k$ of the quantum state across the bipartition separating the first $k$ sites from the remaining $N-k$ sites. The overall minimal bond dimension $D_{\\min}$ for the MPS is the maximum of these Schmidt ranks over all possible bipartitions:\n$$ D_{\\min} = \\max_{1 \\le k < N} \\chi_k $$\nFor the given system with $N=3$ sites, there are two such bipartitions to consider.\n\n1.  **Bipartition at $k=1$**: This cut separates site $1$ from sites $\\{2, 3\\}$. To find the Schmidt rank $\\chi_1$, we express $|\\Psi_{\\mathrm{GHZ}}\\rangle$ in a basis that makes this partition explicit:\n    $$ |\\Psi_{\\mathrm{GHZ}}\\rangle = \\frac{1}{\\sqrt{2}} |0\\rangle_1 \\otimes |00\\rangle_{23} + \\frac{1}{\\sqrt{2}} |1\\rangle_1 \\otimes |11\\rangle_{23} $$\n    This is the Schmidt decomposition of the state across the specified cut. The states $\\{|0\\rangle_1, |1\\rangle_1\\}$ form an orthonormal basis for the first subsystem, and the states $\\{|00\\rangle_{23}, |11\\rangle_{23}\\}$ form an orthonormal set for the second subsystem. There are two non-zero Schmidt coefficients, $\\lambda_1 = \\frac{1}{\\sqrt{2}}$ and $\\lambda_2 = \\frac{1}{\\sqrt{2}}$. The number of non-zero coefficients defines the Schmidt rank. Therefore, for this cut, the Schmidt rank is $\\chi_1 = 2$.\n\n2.  **Bipartition at $k=2$**: This cut separates sites $\\{1, 2\\}$ from site $3$. We re-express $|\\Psi_{\\mathrm{GHZ}}\\rangle$ for this partition:\n    $$ |\\Psi_{\\mathrm{GHZ}}\\rangle = \\frac{1}{\\sqrt{2}} |00\\rangle_{12} \\otimes |0\\rangle_3 + \\frac{1}{\\sqrt{2}} |11\\rangle_{12} \\otimes |1\\rangle_3 $$\n    This is again the Schmidt decomposition. The states $\\{|00\\rangle_{12}, |11\\rangle_{12}\\}$ form an orthonormal set for the first subsystem, and $\\{|0\\rangle_3, |1\\rangle_3\\}$ form an orthonormal basis for the second. As before, there are two non-zero Schmidt coefficients, $\\lambda_1 = \\frac{1}{\\sqrt{2}}$ and $\\lambda_2 = \\frac{1}{\\sqrt{2}}$. The Schmidt rank for this cut is therefore $\\chi_2 = 2$.\n\nCombining these results, the minimal bond dimension required for an exact MPS representation of $|\\Psi_{\\mathrm{GHZ}}\\rangle$ on $3$ sites is the maximum of the Schmidt ranks calculated:\n$$ D_{\\min} = \\max\\{\\chi_1, \\chi_2\\} = \\max\\{2, 2\\} = 2 $$\nThis value is both necessary, as proven by the Schmidt decomposition, and sufficient, as an explicit MPS construction with bond dimension $D=2$ exists. The problem, however, only requests the value of $D_{\\min}$.", "answer": "$$\\boxed{2}$$", "id": "2453969"}, {"introduction": "Applying tensor network methods to nuclear physics requires moving beyond simple spin models to handle the fermionic nature of protons and neutrons. The anti-commutation relations of fermionic operators introduce non-local sign factors, often handled via the Jordan-Wigner transformation, which must be correctly encoded in the local tensors of a Matrix Product Operator (MPO). This practice [@problem_id:3593647] delves into the essential machinery for building MPOs for fermionic Hamiltonians, focusing on how different orderings of the orbitals (e.g., interleaved vs. blocked by species) impact the structure of the required sign corrections, which can be managed systematically using tools like fermionic swap gates.", "problem": "Consider a one-dimensional lattice of $L$ nuclear sites, each hosting two fermionic species, protons and neutrons. The local Fock space at each site has four basis states: $\\lvert 0 \\rangle$, $\\lvert p \\rangle$, $\\lvert n \\rangle$, and $\\lvert pn \\rangle$. The fermionic creation and annihilation operators obey the canonical anticommutation relations\n$$\n\\{ \\hat{c}_{s,i}, \\hat{c}_{s',j}^\\dagger \\} = \\delta_{s,s'} \\delta_{ij}, \\quad \\{ \\hat{c}_{s,i}, \\hat{c}_{s',j} \\} = \\{ \\hat{c}_{s,i}^\\dagger, \\hat{c}_{s',j}^\\dagger \\} = 0,\n$$\nwhere $s \\in \\{p,n\\}$ labels the species and $i,j \\in \\{1,\\dots,L\\}$ label the lattice sites. The parity operator at a mode has eigenvalues $(-1)^{\\hat{n}}$ with $\\hat{n}$ the number operator.\n\nTo represent fermionic operators as spin operators, use the Jordan–Wigner (JW) transformation. In any fixed total ordering of fermionic modes, the JW transform maps each fermion operator $\\hat{c}_{m}$ to a spin-lowering operator at its position multiplied by a string of parity operators across all modes preceding $m$ in the chosen ordering. Two commonly used orderings for two-species systems are:\n- Interleaved ordering: $\\left[ p_1, n_1, p_2, n_2, \\dots, p_L, n_L \\right]$.\n- Block ordering: $\\left[ p_1, p_2, \\dots, p_L, n_1, n_2, \\dots, n_L \\right]$.\n\nIn tensor network constructions such as the Matrix Product Operator (MPO), fermionic statistics are handled by graded tensor contractions. A key building block is the fermionic swap tensor, which permutes two fermionic modes and inserts a sign $(-1)^{\\vert a \\vert \\vert b \\vert}$ when swapping states $a$ and $b$ with parities $\\vert a \\vert, \\vert b \\vert \\in \\{0,1\\}$ respectively.\n\nYour task is to implement a program that:\n1. Validates the fermionic swap tensor for two spinless fermionic modes by checking its action on the occupation basis $\\{ \\lvert 00 \\rangle, \\lvert 01 \\rangle, \\lvert 10 \\rangle, \\lvert 11 \\rangle \\}$, where $\\lvert 0 \\rangle$ denotes empty and $\\lvert 1 \\rangle$ denotes occupied. The validation should use the definition that the graded swap acts as\n$$\n\\hat{S} \\lvert 00 \\rangle = \\lvert 00 \\rangle, \\quad\n\\hat{S} \\lvert 01 \\rangle = \\lvert 10 \\rangle, \\quad\n\\hat{S} \\lvert 10 \\rangle = \\lvert 01 \\rangle, \\quad\n\\hat{S} \\lvert 11 \\rangle = - \\lvert 11 \\rangle.\n$$\nReturn a boolean for whether all four actions hold.\n\n2. For hopping-like bilinear fermionic operators $\\hat{O}_{s;i \\rightarrow j} = \\hat{c}_{s,i}^\\dagger \\hat{c}_{s,j}$ with species $s \\in \\{p,n\\}$ and sites $i \\neq j$, compute the JW parity-string sign under both interleaved and block orderings. For a fixed occupation configuration specified by proton occupations $\\mathbf{n}^{(p)} = (n^{(p)}_1,\\dots,n^{(p)}_L)$ and neutron occupations $\\mathbf{n}^{(n)} = (n^{(n)}_1,\\dots,n^{(n)}_L)$, define the JW string sign factor under a given ordering as\n$$\n\\mathrm{JW\\_sign} = (-1)^{\\sum_{k \\in \\text{between}(i,j)} \\left( n_{k}^{(\\text{mode})} \\right)},\n$$\nwhere the sum runs over all fermionic modes strictly between the positions of $\\hat{c}_{s,i}^\\dagger$ and $\\hat{c}_{s,j}$ in the chosen ordering, and $n_{k}^{(\\text{mode})}$ is the occupation number (either proton or neutron mode as appropriate for the ordering).\n\n3. Quantify ordering-induced phase cancellations in long-range MPOs by comparing the JW signs between interleaved and block orderings and relating their difference to the species that is not acted on by the operator. In particular, compute the parity of the count of the “other species” occupations strictly between the lattice sites $i$ and $j$, denoted by\n$$\n\\Delta_{s;i,j} = \\sum_{k=\\min(i,j)+1}^{\\max(i,j)-1} n_k^{(\\bar{s})} \\quad \\text{mod } 2,\n$$\nwhere $\\bar{s}$ denotes the opposite species to $s$. Return the integer $\\Delta_{s;i,j} \\in \\{0,1\\}$. Then, test whether the parity-string signs obtained under interleaved and block orderings are consistent with the cancellation implied by these inter-species crossings, by returning a boolean that is true if and only if the equality\n$$\n\\mathrm{JW\\_sign}^{(\\text{interleaved})} = \\mathrm{JW\\_sign}^{(\\text{block})} \\times (-1)^{\\Delta_{s;i,j}}\n$$\nholds.\n\nUse the following test suite. All indices $i,j$ are one-based lattice indices, and all occupations $n^{(p)}_\\ell, n^{(n)}_\\ell$ are integers in $\\{0,1\\}$.\n\n- Test Case 1 (long-range proton hop, odd inter-species crossings):\n    - $L = 4$, $s = p$, $i = 1$, $j = 4$.\n    - Proton occupations: $\\mathbf{n}^{(p)} = (0,1,0,1)$.\n    - Neutron occupations: $\\mathbf{n}^{(n)} = (0,1,0,0)$.\n- Test Case 2 (long-range neutron hop, even inter-species crossings):\n    - $L = 4$, $s = n$, $i = 2$, $j = 4$.\n    - Proton occupations: $\\mathbf{n}^{(p)} = (1,0,0,1)$.\n    - Neutron occupations: $\\mathbf{n}^{(n)} = (1,0,1,0)$.\n- Test Case 3 (reverse-order proton hop, odd inter-species crossings):\n    - $L = 4$, $s = p$, $i = 3$, $j = 1$.\n    - Proton occupations: $\\mathbf{n}^{(p)} = (0,0,1,0)$.\n    - Neutron occupations: $\\mathbf{n}^{(n)} = (0,1,1,0)$.\n- Test Case 4 (nearest-neighbor proton hop, zero inter-species crossings):\n    - $L = 4$, $s = p$, $i = 2$, $j = 3$.\n    - Proton occupations: $\\mathbf{n}^{(p)} = (1,0,1,0)$.\n    - Neutron occupations: $\\mathbf{n}^{(n)} = (0,0,1,1)$.\n\nYour program should produce a single line of output containing the following nine results as a comma-separated list enclosed in square brackets:\n\n- The boolean validation of the fermionic swap tensor action.\n- Four booleans, one for each test case, indicating whether the JW-sign equality between interleaved and block orderings holds when compensated by the parity $\\Delta_{s;i,j}$ of the “other species” crossings.\n- Four integers $\\Delta_{s;i,j}$ for the test cases, in the same order as the corresponding booleans.\n\nFor example, the final output format must be:\n$[b_{\\text{swap}}, b_1, b_2, b_3, b_4, d_1, d_2, d_3, d_4]$,\nwhere each $b$ is a boolean and each $d$ is an integer in $\\{0,1\\}$.", "solution": "The user has provided a multi-part problem in the domain of computational nuclear physics, specifically concerning the representation of fermionic operators within the tensor network framework. I will first validate the problem statement and then, if it is valid, provide a complete solution.\n\n### Step 1: Extract Givens\n-   **System**: A one-dimensional lattice of $L$ nuclear sites.\n-   **Local Hilbert Space**: Each site hosts two fermionic species (protons $p$, neutrons $n$), with a local Fock space of four states: $\\lvert 0 \\rangle$, $\\lvert p \\rangle$, $\\lvert n \\rangle$, $\\lvert pn \\rangle$.\n-   **Fermionic Operators**: Creation ($\\hat{c}_{s,i}^\\dagger$) and annihilation ($\\hat{c}_{s,i}$) operators for species $s \\in \\{p,n\\}$ at site $i \\in \\{1,\\dots,L\\}$.\n-   **Canonical Anticommutation Relations (CAR)**: $\\{ \\hat{c}_{s,i}, \\hat{c}_{s',j}^\\dagger \\} = \\delta_{s,s'} \\delta_{ij}$ and $\\{ \\hat{c}_{s,i}, \\hat{c}_{s',j} \\} = \\{ \\hat{c}_{s,i}^\\dagger, \\hat{c}_{s',j}^\\dagger \\} = 0$.\n-   **Parity**: The parity operator at a mode has eigenvalues $(-1)^{\\hat{n}}$, where $\\hat{n}$ is the number operator.\n-   **Jordan-Wigner (JW) Orderings**:\n    -   Interleaved: The fermionic modes are ordered as $\\left[ p_1, n_1, p_2, n_2, \\dots, p_L, n_L \\right]$.\n    -   Block: The modes are ordered as $\\left[ p_1, p_2, \\dots, p_L, n_1, n_2, \\dots, n_L \\right]$.\n-   **Fermionic Swap Tensor ($\\hat{S}$) Action**: For two spinless fermionic modes, the action on the occupation basis $\\{\\lvert 00 \\rangle, \\lvert 01 \\rangle, \\lvert 10 \\rangle, \\lvert 11 \\rangle\\}$ is defined as:\n    -   $\\hat{S} \\lvert 00 \\rangle = \\lvert 00 \\rangle$\n    -   $\\hat{S} \\lvert 01 \\rangle = \\lvert 10 \\rangle$\n    -   $\\hat{S} \\lvert 10 \\rangle = \\lvert 01 \\rangle$\n    -   $\\hat{S} \\lvert 11 \\rangle = - \\lvert 11 \\rangle$\n-   **Hopping Operator**: $\\hat{O}_{s;i \\rightarrow j} = \\hat{c}_{s,i}^\\dagger \\hat{c}_{s,j}$ for $i \\neq j$.\n-   **JW Sign Definition**: The sign is given by $\\mathrm{JW\\_sign} = (-1)^{\\sum_{k \\in \\text{between}(i,j)} n_{k}^{(\\text{mode})}}$, where the sum includes occupations of all fermionic modes located strictly between the modes corresponding to $\\hat{c}_{s,i}^\\dagger$ and $\\hat{c}_{s,j}$ in the specified JW ordering.\n-   **Other-Species Crossing Parity**: This quantity is defined as $\\Delta_{s;i,j} = \\left(\\sum_{k=\\min(i,j)+1}^{\\max(i,j)-1} n_k^{(\\bar{s})}\\right) \\pmod 2$, where $\\bar{s}$ is the species other than $s$.\n-   **Consistency Relation**: The equality to be tested is $\\mathrm{JW\\_sign}^{(\\text{interleaved})} = \\mathrm{JW\\_sign}^{(\\text{block})} \\times (-1)^{\\Delta_{s;i,j}}$.\n-   **Test Cases**: Four specific cases are provided with parameters $L, s, i, j$ and occupation vectors $\\mathbf{n}^{(p)}, \\mathbf{n}^{(n)}$.\n\n### Step 2: Validate Using Extracted Givens\n-   **Scientific Grounding**: The problem is based on well-established principles of quantum mechanics (fermionic statistics) and standard techniques in computational many-body physics (Jordan-Wigner transformation, tensor networks). The definitions and concepts are standard in the field. The problem is scientifically sound.\n-   **Well-Posedness**: The problem is clearly structured into three distinct tasks. For each task, all required definitions, formulas, and input data are provided. The calculations are deterministic, ensuring a unique solution. The goals are stated unambiguously: validate the swap tensor matrix, compute JW signs, calculate $\\Delta$, and test the given equality. The problem is well-posed.\n-   **Objectivity**: The problem is stated using precise, objective, and mathematical language. There are no subjective or ambiguous terms.\n-   **Completeness and Consistency**: All necessary parameters for the test cases are given. The definitions of the orderings, JW sign, and $\\Delta$ are self-contained and sufficient for implementation. A careful analysis of the definitions shows them to be internally consistent for the purposes of the required calculations.\n\n### Step 3: Verdict and Action\nThe problem is deemed **valid**. It is a well-posed, scientifically grounded problem that can be solved algorithmically based on the provided information. I will now proceed with the solution.\n\n### Principle-Based Design\nThe solution is implemented in three parts, corresponding to the tasks specified in the problem statement.\n\n**Part 1: Fermionic Swap Tensor Validation**\nThe action of the linear operator $\\hat{S}$ on the four basis states of a two-mode system, $\\{\\lvert 00 \\rangle, \\lvert 01 \\rangle, \\lvert 10 \\rangle, \\lvert 11 \\rangle\\}$, is given. We can represent these basis states as orthonormal vectors in $\\mathbb{C}^4$, for example, using the computational basis: $\\lvert 00 \\rangle \\to [1, 0, 0, 0]^T$, $\\lvert 01 \\rangle \\to [0, 1, 0, 0]^T$, etc. The matrix representation of $\\hat{S}$ can be constructed from its defined action on this basis. The columns of the matrix are the images of the basis vectors.\n-   $\\hat{S}\\lvert 00 \\rangle = \\lvert 00 \\rangle \\implies \\text{col}_1 = [1, 0, 0, 0]^T$\n-   $\\hat{S}\\lvert 01 \\rangle = \\lvert 10 \\rangle \\implies \\text{col}_2 = [0, 0, 1, 0]^T$\n-   $\\hat{S}\\lvert 10 \\rangle = \\lvert 01 \\rangle \\implies \\text{col}_3 = [0, 1, 0, 0]^T$\n-   $\\hat{S}\\lvert 11 \\rangle = -\\lvert 11 \\rangle \\implies \\text{col}_4 = [0, 0, 0, -1]^T$\nThis gives the matrix representation of the swap operator:\n$$\nS = \\begin{pmatrix} 1 & 0 & 0 & 0 \\\\ 0 & 0 & 1 & 0 \\\\ 0 & 1 & 0 & 0 \\\\ 0 & 0 & 0 & -1 \\end{pmatrix}\n$$\nThe validation consists of applying this matrix $S$ to each of the four basis vectors and verifying that the result matches the defined transformation. A boolean `True` is returned if and only if all four transformations are correctly reproduced.\n\n**Part 2: Jordan-Wigner Sign Calculation**\nThe JW sign for the operator $\\hat{c}_{s,i}^\\dagger \\hat{c}_{s,j}$ depends on the parity of the total number of occupied fermionic modes located between the positions of modes $(s,i)$ and $(s,j)$ in a chosen one-dimensional ordering. The core of this task is to:\n1.  Construct the ordered list of all $2L$ fermionic modes for both 'interleaved' and 'block' orderings.\n2.  For a given operator $\\hat{c}_{s,i}^\\dagger \\hat{c}_{s,j}$, identify the specific modes $(s,i)$ and $(s,j)$.\n3.  Find the indices (positions) of these two modes in the ordered list.\n4.  Iterate through all modes with indices strictly between these two positions.\n5.  Sum the occupation numbers of these intermediate modes. The occupation numbers are provided in the test case data.\n6.  The JW sign is $(-1)$ raised to the power of this sum.\n\nThis procedure is implemented in a function that takes the system parameters and ordering type as input and returns the calculated JW sign ($+1$ or $-1$).\n\n**Part 3: Other-Species Crossing Parity and Consistency Check**\nThis part involves two calculations:\n1.  **Compute $\\Delta_{s;i,j}$**: This is the parity of the number of occupied sites of the \"other\" species, $\\bar{s}$, strictly between the lattice sites $i$ and $j$. The sum is over site indices $k$ such that $\\min(i,j) < k < \\max(i,j)$. The result is an integer, $0$ or $1$.\n2.  **Test the Equality**: The problem posits a relationship between the JW signs from the two different orderings: $\\mathrm{JW\\_sign}^{(\\text{interleaved})} = \\mathrm{JW\\_sign}^{(\\text{block})} \\times (-1)^{\\Delta_{s;i,j}}$. After calculating the two JW signs and $\\Delta_{s;i,j}$, this equality is checked. A boolean `True` is returned if the equality holds, and `False` otherwise.\n\nThe main program executes these steps for each of the four test cases provided, collecting the boolean result of the swap tensor validation, the four boolean results of the consistency check, and the four integer values of $\\Delta_{s;i,j}$. These nine values are then formatted into the required output string. The implementation uses 0-based indexing for arrays, carefully converting from the 1-based indexing used in the problem statement for lattice sites.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem, validate the swap tensor,\n    and process all test cases for JW sign analysis.\n    \"\"\"\n\n    def validate_swap_tensor():\n        \"\"\"\n        Validates the fermionic swap tensor S by checking its action on the 4 basis states.\n        \"\"\"\n        # Basis states |00>, |01>, |10>, |11> in the computational basis\n        basis = [\n            np.array([1, 0, 0, 0]),  # |00>\n            np.array([0, 1, 0, 0]),  # |01>\n            np.array([0, 0, 1, 0]),  # |10>\n            np.array([0, 0, 0, 1])   # |11>\n        ]\n        \n        # Expected outcomes S|00>=|00>, S|01>=|10>, S|10>=|01>, S|11>=-|11>\n        expected_outcomes = [\n            basis[0],       # |00>\n            basis[2],       # |10>\n            basis[1],       # |01>\n            -1 * basis[3]   # -|11>\n        ]\n\n        # The fermionic swap tensor S as a matrix\n        S = np.array([\n            [1, 0, 0, 0],\n            [0, 0, 1, 0],\n            [0, 1, 0, 0],\n            [0, 0, 0, -1]\n        ])\n\n        for i in range(4):\n            v_in = basis[i]\n            v_out_actual = S @ v_in\n            v_out_expected = expected_outcomes[i]\n            if not np.allclose(v_out_actual, v_out_expected):\n                return False\n                \n        return True\n\n    def get_jw_sign(L, s, op_i, op_j, np_occ, nn_occ, ordering):\n        \"\"\"\n        Computes the Jordan-Wigner string sign for a given operator and ordering.\n        \"\"\"\n        # Problem uses 1-based site indices, convert to 0-based for arrays\n        site_i, site_j = op_i - 1, op_j - 1\n        \n        # Create the ordered list of all 2L fermionic modes\n        modes = []\n        if ordering == 'interleaved':\n            for k in range(L):\n                modes.append(('p', k))\n                modes.append(('n', k))\n        elif ordering == 'block':\n            for k in range(L):\n                modes.append(('p', k))\n            for k in range(L):\n                modes.append(('n', k))\n        \n        # Create a mapping from mode to occupation number for easy lookup\n        occupations = {}\n        for k in range(L):\n            occupations[('p', k)] = np_occ[k]\n            occupations[('n', k)] = nn_occ[k]\n            \n        # Find the positions of the operator's modes in the ordered list\n        mode_i = (s, site_i)\n        mode_j = (s, site_j)\n        pos_i = modes.index(mode_i)\n        pos_j = modes.index(mode_j)\n        \n        start_idx = min(pos_i, pos_j) + 1\n        end_idx = max(pos_i, pos_j)\n        \n        # Sum occupations of all modes strictly between the two operator modes\n        occupation_sum = 0\n        for k in range(start_idx, end_idx):\n            mode_k = modes[k]\n            occupation_sum += occupations[mode_k]\n            \n        return (-1)**occupation_sum\n\n    def get_delta(s, op_i, op_j, np_occ, nn_occ):\n        \"\"\"\n        Computes the parity of the count of the \"other species\" occupations.\n        \"\"\"\n        s_bar = 'n' if s == 'p' else 'p'\n        occ_bar = nn_occ if s_bar == 'n' else np_occ\n        \n        # Sum occupations of the other species strictly between sites i and j.\n        # The problem statement uses 1-based indices for the sum range.\n        start_site_1based = min(op_i, op_j) + 1\n        end_site_1based = max(op_i, op_j)\n        \n        delta_sum = 0\n        # Convert 1-based site indices to 0-based array indices for slicing\n        for k_1based in range(start_site_1based, end_site_1based):\n            delta_sum += occ_bar[k_1based - 1]\n        \n        return delta_sum % 2\n\n    # Part 1: Validate the swap tensor\n    b_swap = validate_swap_tensor()\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'L': 4, 's': 'p', 'i': 1, 'j': 4, 'np': (0, 1, 0, 1), 'nn': (0, 1, 0, 0)},\n        {'L': 4, 's': 'n', 'i': 2, 'j': 4, 'np': (1, 0, 0, 1), 'nn': (1, 0, 1, 0)},\n        {'L': 4, 's': 'p', 'i': 3, 'j': 1, 'np': (0, 0, 1, 0), 'nn': (0, 1, 1, 0)},\n        {'L': 4, 's': 'p', 'i': 2, 'j': 3, 'np': (1, 0, 1, 0), 'nn': (0, 0, 1, 1)},\n    ]\n\n    bool_results = []\n    delta_results = []\n\n    # Parts 2 and 3: Process each test case\n    for case in test_cases:\n        L, s, i, j, np_occ, nn_occ = case['L'], case['s'], case['i'], case['j'], case['np'], case['nn']\n        \n        jw_sign_interleaved = get_jw_sign(L, s, i, j, np_occ, nn_occ, 'interleaved')\n        jw_sign_block = get_jw_sign(L, s, i, j, np_occ, nn_occ, 'block')\n        \n        delta = get_delta(s, i, j, np_occ, nn_occ)\n        delta_results.append(delta)\n        \n        # Test the equality relation\n        # sign_from_delta = (-1)**delta\n        # relation_holds = (jw_sign_interleaved == jw_sign_block * sign_from_delta)\n        # Using np.isclose for robust comparison\n        relation_holds = np.isclose(jw_sign_interleaved, jw_sign_block * ((-1)**delta))\n        bool_results.append(bool(relation_holds))\n\n    # Combine all results into a single list for printing\n    all_results = [b_swap] + bool_results + delta_results\n\n    # Final print statement in the exact required format.\n    # str() of a Python bool is 'True' or 'False'\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "3593647"}, {"introduction": "Moving from theoretical representation to practical computation, the numerical manipulation of an MPS is key to algorithms like the Density Matrix Renormalization Group (DMRG). An MPS possesses a \"gauge freedom\" that allows it to be brought into various canonical forms, which are crucial for algorithmic stability and for extracting physical information. This final exercise [@problem_id:3593660] is a cornerstone of learning to implement tensor network codes: you will develop a routine to bring a random MPS into the mixed-canonical form and verify one of the most elegant and powerful properties of the formalism—that the Schmidt spectrum across any bipartition is directly revealed by a singular value decomposition at the \"orthogonality center\".", "problem": "Construct a complete, runnable program that generates a random Matrix Product State (MPS; Matrix Product State) for a one-dimensional chain of $L=8$ single-particle orbitals, each with local Hilbert space dimension $d=4$, and an internal bond dimension cap $D=50$. In computational nuclear physics, a shell-model configuration space can be represented as a tensor network, where each orbital has a finite local dimension, and the many-body state can be efficiently encoded as an MPS. The program must implement a canonicalization sweep that brings the MPS into mixed-canonical form with a specified bipartition between site $i$ and site $i+1$. The orthogonality center at this bipartition is expected to encode the Schmidt coefficients of the state across the cut.\n\nBegin from the fundamental definitions and properties that must hold in an MPS canonical form. Use the following bases:\n\n- The Schmidt decomposition: For a pure state $\\lvert\\Psi\\rangle$ written as a bipartition into left and right parts, there exists an orthonormal decomposition $\\lvert\\Psi\\rangle=\\sum_{\\alpha}\\lambda_{\\alpha}\\lvert\\alpha\\rangle_{\\text{left}}\\otimes\\lvert\\alpha\\rangle_{\\text{right}}$ with nonnegative coefficients $\\lambda_{\\alpha}$, known as the Schmidt coefficients.\n- Singular Value Decomposition (SVD; Singular Value Decomposition): For any matrix $M$, there exists a factorization $M=U\\Sigma V^{\\dagger}$ where $U$ and $V$ are unitary and $\\Sigma$ is diagonal with nonnegative entries. The nonnegative diagonal entries are equal to the singular values of $M$.\n- MPS canonical forms: A left-canonical tensor $A^{[s]}$ satisfies $\\sum_{p,\\alpha}A^{[s]}_{\\beta p \\alpha}A^{[s]}_{\\beta' p \\alpha}=\\delta_{\\beta\\beta'}$, and a right-canonical tensor satisfies $\\sum_{p,\\beta}A^{[s]}_{\\beta p \\alpha}A^{[s]}_{\\beta p \\alpha'}=\\delta_{\\alpha\\alpha'}$. In mixed-canonical form around a cut between sites $i$ and $i+1$, tensors to the left of site $i$ are left-canonical, tensors to the right of site $i+1$ are right-canonical, and the orthogonality center between them contains the Schmidt coefficients.\n\nYour program must:\n\n1. Generate a random MPS for $L=8$ sites with local dimension $d=4$. Use open boundary conditions with left bond dimension $D_{0}=1$ and right bond dimension $D_{L}=1$, and internal bonds capped by $D=50$. Initialize each MPS tensor $A^{[s]}$ with independent standard normal entries.\n2. Implement a canonicalization sweep to bring the MPS into mixed-canonical form with an orthogonality center at a specified cut between site $i$ and site $i+1$. Achieve this by:\n   - Performing a left-orthonormalization sweep from site $0$ up to site $i$ using a reduced $QR$ factorization on reshaped tensors to enforce left-canonical conditions.\n   - Performing a right-orthonormalization sweep from site $L-1$ down to site $i+1$ using a reduced $QR$ factorization on appropriate transposes to enforce right-canonical conditions.\n   - Performing a local SVD across the bond between sites $i$ and $i+1$, by contracting the two center tensors into a matrix $M$ of shape $(D_{i-1}d) \\times (d D_{i+1})$ and computing $M=U\\Sigma V^{\\dagger}$. Insert $U$ and $V^{\\dagger}$ back into the center-site tensors, and record the singular values $\\Sigma$ as the orthogonality center’s Schmidt coefficients.\n3. Independently compute the exact Schmidt coefficients across the same bipartition by reconstructing the full state vector $\\psi$ of length $d^{L}$ from the MPS and reshaping it into a matrix of shape $d^{i+1} \\times d^{L-(i+1)}$, then performing an SVD to obtain the singular values. Do not normalize the state; compare the unnormalized singular values so that both methods are consistent.\n4. Verify that the Schmidt spectrum obtained from the orthogonality center matches the exact singular values from the full state by reporting the maximum absolute difference between the two sets of singular values for selected bipartitions.\n\nDesign a test suite comprising three deterministic cases to exercise different bipartition locations and random initializations:\n\n- Case $1$: random seed $7$, cut at $i=0$.\n- Case $2$: random seed $12345$, cut at $i=3$.\n- Case $3$: random seed $9876$, cut at $i=6$.\n\nFor each case, compute the maximum absolute difference between the Schmidt coefficients extracted from the orthogonality center and those obtained from the exact full-state SVD at the same bipartition. These differences must be reported as floating-point numbers.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, $[\\Delta_{1},\\Delta_{2},\\Delta_{3}]$, where each $\\Delta_{k}$ is the maximum absolute difference for case $k$ expressed as a floating-point number. No physical units are involved in this computation, and no angles or percentages are required.", "solution": "The user requests a program to validate a core principle of Matrix Product State (MPS) theory: that the Schmidt coefficients of a quantum state across a bipartition can be found by performing a Singular Value Decomposition (SVD) at the corresponding \"orthogonality center\" of a canonically-formed MPS. The program will generate a random MPS, put it into a specific canonical form, and compare the singular values obtained from the MPS procedure with those from an exact SVD on the full, reconstructed state vector.\n\n### 1. Matrix Product State (MPS) Representation\n\nA pure quantum state $\\lvert\\Psi\\rangle$ of a one-dimensional chain of $L$ sites, where each site has a local basis $\\{\\lvert p_s \\rangle\\}_{p_s=0}^{d-1}$, can be written as:\n$$\n\\lvert\\Psi\\rangle = \\sum_{p_0, p_1, \\dots, p_{L-1}} C_{p_0 p_1 \\dots p_{L-1}} \\lvert p_0 p_1 \\dots p_{L-1} \\rangle\n$$\nThe MPS ansatz approximates the coefficient tensor $C$ as a product of smaller tensors (matrices):\n$$\nC_{p_0 p_1 \\dots p_{L-1}} = \\sum_{\\alpha_0, \\dots, \\alpha_{L-1}} A^{[0]}_{\\alpha_0 p_0 \\alpha_1} A^{[1]}_{\\alpha_1 p_1 \\alpha_2} \\cdots A^{[L-1]}_{\\alpha_{L-1} p_L \\alpha_L}\n$$\nFor a chain with open boundary conditions (OBC), the virtual bond indices $\\alpha_0$ and $\\alpha_L$ are trivial (dimension $1$), so the expression simplifies to a matrix product:\n$$\nC_{p_0 p_1 \\dots p_{L-1}} = A^{[0]p_0} A^{[1]p_1} \\cdots A^{[L-1]p_{L-1}}\n$$\nHere, $A^{[s]p_s}$ is a matrix for each physical state $p_s$. The tensor $A^{[s]}$ at site $s$ has three indices: a physical index $p_s$ of dimension $d$, a left virtual bond index $\\alpha_{s-1}$ of dimension $D_{s-1}$, and a right virtual bond index $\\alpha_s$ of dimension $D_s$. The dimension of the virtual bonds is capped by the bond dimension $D$.\n\n### 2. Random MPS Generation\n\nWe will first construct a random MPS for a system with $L=8$ sites, local dimension $d=4$, and maximum bond dimension $D=50$. The dimension of the bond $\\alpha_s$ connecting sites $s$ and $s+1$ is chosen as $D_s = \\min(D, d^{s+1}, d^{L-(s+1)})$, which is the maximum possible rank across that cut for a generic state, capped by $D$. The tensors $A^{[s]}$ are initialized with elements drawn from a standard normal distribution.\n\n### 3. Canonical Forms and Schmidt Decomposition\n\nThe MPS representation has a \"gauge\" freedom. We can insert an invertible matrix $G$ and its inverse $G^{-1}$ between any two tensors, $A^{[s]} \\to A^{[s]}G$ and $A^{[s+1]} \\to G^{-1}A^{[s+1]}$, without changing the overall physical state. This freedom is used to bring the MPS into a canonical form, which simplifies calculations and reveals physical properties.\n\nA key insight is the connection between MPS and the Schmidt decomposition. For any bipartition of the chain into a left part (sites $0$ to $i$) and a right part (sites $i+1$ to $L-1$), the state can be written as:\n$$\n\\lvert\\Psi\\rangle = \\sum_{\\alpha=1}^{k} \\lambda_{\\alpha} \\lvert \\phi_{\\alpha} \\rangle_{L} \\otimes \\lvert \\psi_{\\alpha} \\rangle_{R}\n$$\nwhere $\\{\\lvert \\phi_{\\alpha} \\rangle_{L}\\}$ and $\\{\\lvert \\psi_{\\alpha} \\rangle_{R}\\}$ are orthonormal sets of states for the left and right partitions, respectively. The non-negative values $\\lambda_{\\alpha}$ are the Schmidt coefficients, and their number $k$ is the Schmidt rank.\n\nAn MPS can be brought into a mixed-canonical form with respect to a cut $(i, i+1)$. In this form:\n- Tensors $A^{[s]}$ for $s \\le i$ are left-canonical.\n- Tensors $A^{[s]}$ for $s > i$ are right-canonical.\n\nA tensor $A^{[s]}$ is left-canonical if, when reshaped into a matrix $M_{\\beta, (p \\alpha)} = A^{[s]}_{\\beta p \\alpha}$, it satisfies $M M^\\dagger = I$. This is equivalent to:\n$$\n\\sum_{p_s, \\alpha_s} (A^{[s]}_{\\alpha_{s-1} p_s \\alpha_s})^* A^{[s]}_{\\alpha'_{s-1} p_s \\alpha_s} = \\delta_{\\alpha_{s-1} \\alpha'_{s-1}}\n$$\nA tensor $A^{[s]}$ is right-canonical if, when reshaped into a matrix $M_{(\\beta p), \\alpha} = A^{[s]}_{\\beta p \\alpha}$, it satisfies $M^\\dagger M = I$. This is equivalent to:\n$$\n\\sum_{\\alpha_{s-1}, p_s} (A^{[s]}_{\\alpha_{s-1} p_s \\alpha_s})^* A^{[s]}_{\\alpha_{s-1} p_s \\alpha'_s} = \\delta_{\\alpha_s \\alpha'_s}\n$$\nWhen an MPS is in mixed-canonical form with the orthogonality center on the bond $(i, i+1)$, the Schmidt coefficients $\\lambda_\\alpha$ are precisely the singular values of the matrix $\\Lambda$ that connects the left- and right-canonical halves of the chain.\n\n### 4. Algorithmic Procedure\n\nThe core of the program is to verify this correspondence.\n\n**Step 1: Canonicalization and MPS Schmidt Spectrum**\nWe follow the procedure specified in the problem to bring the random MPS into a mixed-canonical form centered on the cut $(i, i+1)$.\n\n1.  **Left-orthonormalization sweep**: For each site $s$ from $0$ to $i-1$, we reshape its tensor $A^{[s]}$ into a matrix $M$ of shape $(D_{s-1}d, D_s)$. We then perform a reduced QR decomposition, $M = QR$. The new tensor $A'^{[s]}$ is formed by reshaping $Q$, making it left-canonical. The matrix $R$ is contracted into the next tensor, $A^{[s+1]} \\to R A^{[s+1]}$, propagating the gauge transformation to the right. After this sweep, tensors $A'^{[0]}, ..., A'^{[i-1]}$ are left-canonical, and all remaining gauge freedom from the left part is stored in $A^{[i]}$.\n\n2.  **Right-orthonormalization sweep**: Symmetrically, for each site $s$ from $L-1$ down to $i+2$, we reshape $A^{[s]}$ into a matrix $M$ of shape $(D_{s-1}, dD_s)$. We perform a QR decomposition on its transpose, $M^T=QR$. The new tensor $A'^{[s]}$ is formed by reshaping $Q^T$, making it right-canonical. The matrix $L=R^T$ is contracted into the preceding tensor, $A^{[s-1]} \\to A^{[s-1]}L$, propagating the gauge to the left. After this, tensors $A'^{[L-1]}, ..., A'^{[i+2]}$ are right-canonical, and gauge freedom from the right part is in $A^{[i+1]}$.\n\n3.  **Center SVD**: The state is now represented by left-canonical tensors up to site $i-1$, right-canonical tensors from site $i+2$ onwards, and two tensors $A^{[i]}$ and $A^{[i+1]}$ at the center. We contract these two central tensors over their shared bond of dimension $D_i$. The resulting tensor $\\Theta = A^{[i]}A^{[i+1]}$ is reshaped into a matrix $M_{\\text{center}}$ of size $(D_{i-1}d \\times dD_{i+1})$. The Singular Value Decomposition (SVD) of this matrix, $M_{\\text{center}} = U\\Sigma V^\\dagger$, yields the singular values on the diagonal of $\\Sigma$, which are the Schmidt coefficients of the state across this cut as captured by the MPS.\n\n**Step 2: Exact Schmidt Spectrum from Full State Vector**\nTo verify this, we compute the Schmidt spectrum from first principles.\n\n1.  **Reconstruct State Vector**: We contract all the original MPS tensors $A^{[0]}, \\dots, A^{[L-1]}$ together to reconstruct the full state tensor $C_{p_0 \\dots p_{L-1}}$ of shape $(d, d, \\dots, d)$.\n\n2.  **Reshape and SVD**: We reshape this tensor into a matrix $M_{\\text{full}}$ of size $(d^{i+1} \\times d^{L-(i+1)})$, which represents the state across the bipartition $(i, i+1)$. We then compute the SVD of $M_{\\text{full}}$. The resulting singular values are the exact Schmidt coefficients of the state.\n\n**Step 3: Comparison**\nSince the canonicalization process is an exact gauge transformation, it does not alter the physical state. Therefore, the Schmidt coefficients obtained from the MPS canonical form must be identical to those from the full state vector, up to numerical floating-point precision. We calculate the maximum absolute difference between the two sets of singular values to verify this.", "answer": "```python\nimport numpy as np\nfrom scipy import linalg\n\ndef get_sv_from_canonical_mps(mps_in, L, d, cut_i):\n    \"\"\"\n    Brings an MPS to mixed-canonical form with the center at cut (i, i+1)\n    and returns the Schmidt coefficients at that cut.\n    \"\"\"\n    mps = [t.copy() for t in mps_in]\n\n    # 1. Left-orthonormalization sweep from site 0 up to i-1.\n    # This makes tensors 0 to i-1 left-canonical.\n    for s in range(cut_i):\n        d_left, _, d_right = mps[s].shape\n        # Reshape to a matrix: (d_left * d) x d_right\n        M = mps[s].reshape(d_left * d, d_right)\n\n        # Reduced QR decomposition\n        Q, R = linalg.qr(M, mode='economic')\n\n        # Replace tensor with Q part, update next tensor with R part\n        new_d_right = Q.shape[1]\n        mps[s] = Q.reshape(d_left, d, new_d_right)\n        mps[s+1] = np.tensordot(R, mps[s+1], axes=([1], [0]))\n\n    # 2. Right-orthonormalization sweep from site L-1 down to i+1.\n    # This makes tensors L-1 down to i+1 right-canonical.\n    for s in range(L - 1, cut_i, -1):\n        d_left, _, d_right = mps[s].shape\n        # Reshape to a matrix: d_left x (d * d_right)\n        M = mps[s].reshape(d_left, d * d_right)\n\n        # QR on the transpose to enforce right-canonicality\n        M_T = M.T\n        Q, R = linalg.qr(M_T, mode='economic')\n\n        # New tensor is Q.T\n        new_d_left = Q.shape[1]\n        A_new_T = Q.T\n        mps[s] = A_new_T.reshape(new_d_left, d, d_right)\n\n        # Update previous tensor with L = R.T\n        L_mat = R.T\n        mps[s-1] = np.tensordot(mps[s-1], L_mat, axes=([2], [0]))\n\n    # 3. SVD at the center cut (i, i+1)\n    A_i = mps[cut_i]\n    A_i_plus_1 = mps[cut_i + 1]\n\n    # Contract the two center tensors\n    center_tensor = np.tensordot(A_i, A_i_plus_1, axes=([2], [0]))\n\n    # Reshape into a matrix for SVD\n    dl_i, _, d_phys_ip1, dr_ip1 = center_tensor.shape\n    center_matrix = center_tensor.reshape(dl_i * d, d_phys_ip1 * dr_ip1)\n\n    # Calculate singular values\n    _, svals, _ = linalg.svd(center_matrix, full_matrices=False)\n    \n    return svals\n\ndef get_sv_from_full_state(mps, L, d, cut_i):\n    \"\"\"\n    Reconstructs the full state vector from an MPS and computes the exact\n    Schmidt coefficients across a given cut.\n    \"\"\"\n    # 1. Reconstruct the full state tensor by contracting the MPS tensors\n    psi_tensor = mps[0]\n    for s in range(1, L):\n        psi_tensor = np.tensordot(psi_tensor, mps[s], axes=([-1], [0]))\n    \n    # Remove trivial bond dimensions at the boundaries\n    psi_tensor = psi_tensor.squeeze()\n    \n    # 2. Reshape the state tensor into a matrix representing the bipartition\n    psi_matrix = psi_tensor.reshape((d**(cut_i + 1), d**(L - (cut_i + 1))))\n    \n    # 3. Calculate singular values, which are the exact Schmidt coefficients\n    _, svals, _ = linalg.svd(psi_matrix, full_matrices=False)\n    \n    return svals\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and produce the final output.\n    \"\"\"\n    # System parameters\n    L = 8\n    d = 4\n    D_max = 50\n\n    # Test cases: (random_seed, cut_position_i)\n    # cut_position_i defines the cut between site i and i+1\n    test_cases = [\n        (7, 0),\n        (12345, 3),\n        (9876, 6)\n    ]\n\n    results = []\n\n    for seed, cut_i in test_cases:\n        # Set random seed for reproducibility\n        np.random.seed(seed)\n\n        # 1. Generate a random MPS\n        bond_dims = [1] * (L + 1)\n        for s in range(L - 1):\n            # The bond dimension s is between site s and s+1\n            # Maximum possible rank, capped by D_max\n            dim = min(D_max, d**(s + 1), d**(L - (s + 1)))\n            bond_dims[s+1] = dim\n        \n        mps = []\n        for s in range(L):\n            # A[s] has shape (D_{s-1}, d, D_s)\n            shape = (bond_dims[s], d, bond_dims[s+1])\n            mps.append(np.random.randn(*shape))\n\n        # 2. Get Schmidt values from the MPS canonicalization method\n        s_mps = get_sv_from_canonical_mps(mps, L, d, cut_i)\n        \n        # 3. Get exact Schmidt values from the full state vector\n        s_exact = get_sv_from_full_state(mps, L, d, cut_i)\n        \n        # 4. Compare the two sets of singular values\n        len_mps = len(s_mps)\n        len_exact = len(s_exact)\n        max_len = max(len_mps, len_exact)\n        \n        # Pad the shorter list with zeros for comparison\n        s_mps_padded = np.zeros(max_len)\n        s_exact_padded = np.zeros(max_len)\n        \n        s_mps_padded[:len_mps] = s_mps\n        s_exact_padded[:len_exact] = s_exact\n        \n        # Calculate the maximum absolute difference\n        max_abs_diff = np.max(np.abs(s_mps_padded - s_exact_padded))\n        results.append(max_abs_diff)\n\n    # Print the final results in the specified format\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```", "id": "3593660"}]}