{"hands_on_practices": [{"introduction": "The cornerstone of Brueckner-Hartree-Fock theory is the in-medium reaction matrix, or $G$-matrix, which accounts for the repeated scattering of two nucleons in the presence of other nucleons. The $G$-matrix is the solution to the Bethe-Goldstone integral equation. This first practice [@problem_id:3545576] guides you through the essential numerical task of transforming this integral equation into a discrete matrix equation and solving it, providing a foundational skill for any BHF implementation. By using a separable potential, you can verify your numerical matrix solution against an exact analytical result, a crucial technique for building confidence in your computational methods.", "problem": "You are asked to implement a fully self-contained program that constructs a discretized matrix representation of the Bethe-Goldstone equation for the in-medium interaction (the in-medium $G$-matrix) for symmetric nuclear matter at zero total pair momentum. Your task is to start from first principles appropriate to computational nuclear physics and derive the discrete linear system that arises from a quadrature approximation, then implement and evaluate it numerically. You must use a physically plausible single-particle spectrum and a simple but nontrivial separable interaction to enable an internal consistency check. All momenta must be expressed in $\\mathrm{fm}^{-1}$, all energies in $\\mathrm{MeV}$, and angles in radians.\n\nBegin from the standard physical starting point for Brueckner-Hartree-Fock (BHF) theory: the Bethe-Goldstone equation for the in-medium two-body reaction matrix $G$, which in the $S$-wave, zero total momentum approximation can be written as a one-dimensional integral equation in the relative momentum $k$. Adopt the conventional normalization for partial waves in which the three-dimensional integral becomes a factor times an integral in $q \\in [0,\\Lambda]$ over $q^{2}\\,\\mathrm{d}q$, where $\\Lambda$ is a finite momentum cutoff. The intermediate-state Pauli operator must be taken in the angle-average and for zero total momentum reduce to a step function $Q(q,k_{F})=\\Theta(q-k_{F})$, where $k_{F}$ is the Fermi momentum. The single-particle energy must be taken to be the free kinetic spectrum $\\epsilon(q)=\\frac{\\hbar^{2}}{2m_{N}}\\,q^{2}$ with $\\frac{\\hbar^{2}}{2m_{N}}=20.735\\,\\mathrm{MeV}\\cdot\\mathrm{fm}^{2}$. The starting energy is a complex quantity of the form $\\omega + i\\,\\eta$ with real $\\omega$ and a small positive regulator $\\eta$ (with units of $\\mathrm{MeV}$) that implements the causal prescription and regularizes the energy denominator.\n\nUse the rank-$1$ separable Yamaguchi potential in momentum space,\n$$\nV(k,k')=-\\lambda\\,g(k)\\,g(k')\\,,\\qquad g(k)=\\frac{1}{k^{2}+\\beta^{2}}\\,,\n$$\nwith $\\lambda > 0$ and range parameter $\\beta > 0$. In the $S$-wave and zero center-of-mass momentum, the in-medium Bethe-Goldstone equation becomes a one-dimensional integral equation in $q$ for each pair $(k,k')$, involving the kernel $V(k,q)$, the Pauli factor $Q(q,k_{F})$, and the propagator denominator $\\left[\\omega-\\epsilon(q)-\\epsilon(q)\\right]^{-1}=\\left[\\omega-2\\,\\epsilon(q)\\right]^{-1}$. Your code must discretize the $q$-integral on a finite momentum interval $[0,\\Lambda]$ using a Gaussian quadrature with $N$ nodes and weights $\\{(q_{i},w_{i})\\}_{i=1}^{N}$. To evaluate the $G$-matrix at a specific on-shell momentum $k_{0}$, you must augment the quadrature grid by including $k_{0}$ as an additional collocation point with zero quadrature weight so that it does not alter the integral but does produce $G(k_{0},k')$ through the same linear system. In all expressions, carry the conventional $S$-wave factor explicitly as\n$$\n\\frac{2}{\\pi}\\int_{0}^{\\Lambda} q^{2}\\,\\mathrm{d}q \\,\\cdots \\, .\n$$\n\nNumerically, you must treat the energy denominator\n$$\n\\omega-\\epsilon_{p_{1}}-\\epsilon_{p_{2}}=\\omega-2\\,\\epsilon(q)=\\omega - 2 \\times 20.735\\,q^{2}\\,,\n$$\nby adding the small imaginary regulator so that the denominator is $\\omega-2\\,\\epsilon(q)+i\\,\\eta$ with $\\eta \\ge 0$. The Pauli operator $Q(q,k_{F})$ must be implemented as a sharp step function $Q(q,k_{F})=1$ if $q>k_{F}$ and $Q(q,k_{F})=0$ otherwise. You must formulate the discretized equation as a linear algebra problem on the combined grid $\\{k_{0}\\}\\cup\\{q_{i}\\}_{i=1}^{N}$ and solve for the full matrix $G(k_{a},k_{b};\\omega)$ at those grid points. Then extract the on-shell element $G(k_{0},k_{0};\\omega)$.\n\nTo verify correctness and to assess the numerical treatment of the energy denominator, compute in parallel the closed-form solution that exists for rank-$1$ separable potentials by reducing the Bethe-Goldstone equation to a scalar equation for a strength parameter and then reconstructing the on-shell $G$-matrix element. Use the same quadrature rule and Pauli operator in the scalar equation so that discrepancies reflect only the consistency of your discretization and linear algebra.\n\nTest suite and parameters. For each case below, the input parameters are $(k_{F},k_{0},\\Lambda,N,\\beta,\\lambda,\\omega,\\eta)$, in the stated units. Use exactly these four cases in this order:\n- Case A (free-space, on-shell): $k_{F}=0.0\\,\\mathrm{fm}^{-1}$, $k_{0}=1.0\\,\\mathrm{fm}^{-1}$, $\\Lambda=8.0\\,\\mathrm{fm}^{-1}$, $N=120$, $\\beta=1.4\\,\\mathrm{fm}^{-1}$, $\\lambda=200.0\\,\\mathrm{MeV}\\cdot\\mathrm{fm}^{3}$, $\\omega=2\\times 20.735\\times k_{0}^{2}\\,\\mathrm{MeV}$, $\\eta=1.0\\,\\mathrm{MeV}$.\n- Case B (normal density, on-shell above $k_{F}$): $k_{F}=1.3\\,\\mathrm{fm}^{-1}$, $k_{0}=1.6\\,\\mathrm{fm}^{-1}$, $\\Lambda=8.0\\,\\mathrm{fm}^{-1}$, $N=120$, $\\beta=1.4\\,\\mathrm{fm}^{-1}$, $\\lambda=200.0\\,\\mathrm{MeV}\\cdot\\mathrm{fm}^{3}$, $\\omega=2\\times 20.735\\times k_{0}^{2}\\,\\mathrm{MeV}$, $\\eta=1.0\\,\\mathrm{MeV}$.\n- Case C (near Fermi surface, on-shell just above $k_{F}$): $k_{F}=1.3\\,\\mathrm{fm}^{-1}$, $k_{0}=1.31\\,\\mathrm{fm}^{-1}$, $\\Lambda=8.0\\,\\mathrm{fm}^{-1}$, $N=120$, $\\beta=1.4\\,\\mathrm{fm}^{-1}$, $\\lambda=200.0\\,\\mathrm{MeV}\\cdot\\mathrm{fm}^{3}$, $\\omega=2\\times 20.735\\times k_{0}^{2}\\,\\mathrm{MeV}$, $\\eta=0.5\\,\\mathrm{MeV}$.\n- Case D (off-shell below threshold, free-space): $k_{F}=0.0\\,\\mathrm{fm}^{-1}$, $k_{0}=0.5\\,\\mathrm{fm}^{-1}$, $\\Lambda=8.0\\,\\mathrm{fm}^{-1}$, $N=120$, $\\beta=1.4\\,\\mathrm{fm}^{-1}$, $\\lambda=200.0\\,\\mathrm{MeV}\\cdot\\mathrm{fm}^{3}$, $\\omega=-20.0\\,\\mathrm{MeV}$, $\\eta=0.0\\,\\mathrm{MeV}$.\n\nYour program must, for each case, do the following:\n- Assemble the discretized matrix equation on the combined grid with $k_{0}$ as an additional collocation point of zero quadrature weight and solve for the full $G$-matrix.\n- Extract the on-shell element $G(k_{0},k_{0};\\omega)$.\n- Independently compute the corresponding on-shell element implied by the closed-form separable reduction using the same quadrature and Pauli operator.\n- Return the absolute discrepancies between the two complex numbers’ real and imaginary parts, i.e., $|\\Re G_{\\mathrm{matrix}}-\\Re G_{\\mathrm{sep}}|$ and $|\\Im G_{\\mathrm{matrix}}-\\Im G_{\\mathrm{sep}}|$, expressed in $\\mathrm{MeV}\\cdot\\mathrm{fm}^{3}$.\n\nFinal output format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered as\n$\\big[$discrepancy for Case A real part, discrepancy for Case A imaginary part, discrepancy for Case B real part, discrepancy for Case B imaginary part, discrepancy for Case C real part, discrepancy for Case C imaginary part, discrepancy for Case D real part, discrepancy for Case D imaginary part$\\big]$.", "solution": "The user requires a numerical solution and verification for the Bethe-Goldstone equation in the context of Brueckner-Hartree-Fock theory for nuclear matter. The problem is validated as scientifically grounded, well-posed, and internally consistent. It represents a standard, albeit simplified, problem in computational nuclear physics.\n\n### 1. Problem Formulation\n\nThe starting point is the Bethe-Goldstone equation for the in-medium reaction matrix, $G$, for two nucleons interacting in symmetric nuclear matter with zero total momentum. In the $S$-wave channel, this is a one-dimensional integral equation:\n$$\nG(k, k'; \\omega) = V(k, k') + \\frac{2}{\\pi} \\int_{0}^{\\Lambda} q^2 dq \\, V(k, q) \\frac{Q(q, k_F)}{\\omega + i\\eta - 2\\epsilon(q)} G(q, k'; \\omega)\n$$\nwhere:\n- $k$ and $k'$ are the initial and final relative momenta.\n- $V(k, k')$ is the nucleon-nucleon interaction in the $S$-wave channel.\n- The integral is over intermediate relative momenta $q$ up to a cutoff $\\Lambda$. The factor $\\frac{2}{\\pi}$ is a specified normalization convention.\n- $Q(q, k_F) = \\Theta(q - k_F)$ is the angle-averaged Pauli exclusion operator, which restricts intermediate states to be above the Fermi momentum $k_F$. It is $1$ for $q > k_F$ and $0$ otherwise.\n- $\\epsilon(q) = \\frac{\\hbar^2 q^2}{2m_N}$ is the single-particle energy of a free nucleon with mass $m_N$. The constant is given as $\\frac{\\hbar^2}{2m_N} = 20.735\\,\\mathrm{MeV}\\cdot\\mathrm{fm}^2$.\n- $\\omega + i\\eta$ is the complex starting energy, with $\\omega$ being the real energy and $\\eta > 0$ a small positive regulator ensuring the correct causal boundary conditions and preventing singularities in the energy denominator.\n\nThe interaction is a rank-$1$ separable Yamaguchi potential:\n$$\nV(k, k') = -\\lambda g(k) g(k') \\quad \\text{with} \\quad g(k) = \\frac{1}{k^2 + \\beta^2}\n$$\nwhere $\\lambda$ is the strength and $\\beta$ is related to the range of the interaction.\n\n### 2. Numerical Discretization and Matrix Formulation\n\nTo solve the integral equation numerically, we discretize the integral over $q \\in [0, \\Lambda]$ using an $N$-point Gaussian quadrature rule. Let the quadrature nodes be $\\{q_i\\}_{i=1}^N$ and the corresponding weights be $\\{w_i\\}_{i=1}^N$. The integral is approximated as:\n$$\n\\int_{0}^{\\Lambda} f(q) dq \\approx \\sum_{i=1}^{N} w_i f(q_i)\n$$\nThe problem requires us to evaluate the $G$-matrix at a specific momentum $k_0$. We augment the set of quadrature nodes with $k_0$ to form a combined grid of collocation points, $P = \\{p_a\\}_{a=0}^N$, where $p_0 = k_0$ and $p_a = q_a$ for $a=1, \\dots, N$. The point $k_0$ is assigned a zero quadrature weight.\n\nThe discretized Bethe-Goldstone equation becomes a system of linear equations for the values of the $G$-matrix at the grid points, $G_{ab} = G(p_a, p_b)$:\n$$\nG(p_a, p_b) = V(p_a, p_b) + \\frac{2}{\\pi} \\sum_{i=1}^{N} w_i q_i^2 V(p_a, q_i) \\frac{Q(q_i, k_F)}{\\omega + i\\eta - 2\\epsilon(q_i)} G(q_i, p_b)\n$$\nRecognizing that $q_i=p_i$ and $G(q_i, p_b)=G_{ib}$, we can write this as a matrix equation. Let us define a matrix $\\mathbf{C}$ of size $(N+1) \\times (N+1)$:\n$$\nC_{ai} = \n\\begin{cases}\n    \\frac{2}{\\pi} w_i q_i^2 V(p_a, q_i) \\frac{Q(q_i, k_F)}{\\omega + i\\eta - 2\\epsilon(q_i)} & \\text{for } i \\in \\{1, \\dots, N\\} \\\\\n    0 & \\text{for } i = 0\n\\end{cases}\n$$\nThe equation for the matrix $\\mathbf{G}$ (with elements $G_{ab}$) in terms of matrix $\\mathbf{V}$ (with elements $V_{ab}$) is:\n$$\n\\mathbf{G} = \\mathbf{V} + \\mathbf{C} \\mathbf{G} \\implies (\\mathbf{I} - \\mathbf{C})\\mathbf{G} = \\mathbf{V}\n$$\nwhere $\\mathbf{I}$ is the identity matrix. The solution is formally $\\mathbf{G} = (\\mathbf{I} - \\mathbf{C})^{-1} \\mathbf{V}$.\n\nSince the potential is separable, $\\mathbf{V}$ is a rank-1 matrix: $V_{ab} = -\\lambda g(p_a) g(p_b)$, which can be written as $\\mathbf{V} = -\\lambda \\vec{g} \\vec{g}^T$, where $\\vec{g}$ is a column vector with elements $g_a = g(p_a)$.\nThe solution for $\\mathbf{G}$ is then $\\mathbf{G} = -\\lambda (\\mathbf{I} - \\mathbf{C})^{-1} (\\vec{g} \\vec{g}^T)$.\nTo find the required element $G_{00} = G(k_0, k_0)$, we can solve the linear system $(\\mathbf{I} - \\mathbf{C})\\vec{y} = \\vec{g}$ for the vector $\\vec{y}$. The solution vector is $\\vec{y} = (\\mathbf{I} - \\mathbf{C})^{-1}\\vec{g}$, and the full $G$-matrix is then $\\mathbf{G} = -\\lambda \\vec{y} \\vec{g}^T$.\nThe specific element we need is $G_{00} = -\\lambda y_0 g_0$, where $y_0$ is the first component of $\\vec{y}$ and $g_0 = g(p_0) = g(k_0)$. This approach avoids constructing the full inverse and is computationally more efficient.\n\n### 3. Closed-Form Separable Reduction\n\nA key feature of a rank-$1$ separable potential is that the integral equation can be solved analytically, reducing it to a scalar algebraic equation. We substitute $V(k, k') = -\\lambda g(k) g(k')$ into the Bethe-Goldstone equation. The structure of the equation implies that $G(k, k')$ must also be separable, so we make the ansatz $G(k, k') = \\tau(\\omega) g(k) g(k')$. Substituting this and canceling $g(k)$ and $g(k')$ yields a scalar equation for the function $\\tau(\\omega)$:\n$$\n\\tau(\\omega) = -\\lambda + \\frac{2}{\\pi} \\int_0^\\Lambda q^2 dq \\, [-\\lambda g(q)] \\frac{Q(q, k_F)}{\\omega' - 2\\epsilon(q)} [\\tau(\\omega) g(q)]\n$$\n$$\n\\tau(\\omega) = -\\lambda - \\lambda \\tau(\\omega) \\left[ \\frac{2}{\\pi} \\int_0^\\Lambda q^2 dq \\frac{g(q)^2 Q(q, k_F)}{\\omega' - 2\\epsilon(q)} \\right]\n$$\nLet's define the loop integral $I(\\omega')$:\n$$\nI(\\omega') = \\frac{2}{\\pi} \\int_0^\\Lambda q^2 dq \\frac{g(q)^2 Q(q, k_F)}{\\omega' - 2\\epsilon(q)}\n$$\nThen $\\tau(\\omega) = -\\lambda / (1 + \\lambda I(\\omega'))$. The G-matrix is thus:\n$$\nG(k, k'; \\omega) = \\frac{-\\lambda g(k) g(k')}{1 + \\lambda I(\\omega')}\n$$\nFor verification, we compute the integral $I(\\omega')$ using the same Gaussian quadrature rule as in the matrix method:\n$$\nI(\\omega') \\approx \\frac{2}{\\pi} \\sum_{i=1}^{N} w_i q_i^2 \\frac{g(q_i)^2 Q(q_i, k_F)}{\\omega' - 2\\epsilon(q_i)}\n$$\nThe on-shell element $G(k_0, k_0; \\omega)$ is then calculated directly from this formula.\n\n### 4. Consistency Check\n\nThe problem is designed such that the matrix method and the separable reduction method are two different numerical routes to the same underlying analytical solution. As derived analytically in the thought process, both methods yield the same expression: $G(k_0, k_0) = \\frac{-\\lambda g(k_0)^2}{1+\\lambda I(\\omega')}$. Therefore, when implemented numerically using the same quadrature scheme, the results from both methods should be identical up to floating-point precision. The requested discrepancies, $|\\Re G_{\\mathrm{matrix}}-\\Re G_{\\mathrm{sep}}|$ and $|\\Im G_{\\mathrm{matrix}}-\\Im G_{\\mathrm{sep}}|$, serve as a stringent test of the correctness and consistency of the implementation of the discretized linear algebra problem.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_legendre\n\ndef solve():\n    \"\"\"\n    Main driver function to solve the problem for all specified test cases.\n    \"\"\"\n    # Test suite parameters:\n    # (k_F, k_0, Lambda, N, beta, lambda, omega, eta)\n    HBARC2_2M = 20.735  # MeV*fm^2\n\n    test_cases = [\n        # Case A (free-space, on-shell)\n        (0.0, 1.0, 8.0, 120, 1.4, 200.0, 2 * HBARC2_2M * 1.0**2, 1.0),\n        # Case B (normal density, on-shell above k_F)\n        (1.3, 1.6, 8.0, 120, 1.4, 200.0, 2 * HBARC2_2M * 1.6**2, 1.0),\n        # Case C (near Fermi surface, on-shell just above k_F)\n        (1.3, 1.31, 8.0, 120, 1.4, 200.0, 2 * HBARC2_2M * 1.31**2, 0.5),\n        # Case D (off-shell below threshold, free-space)\n        (0.0, 0.5, 8.0, 120, 1.4, 200.0, -20.0, 0.0),\n    ]\n\n    results = []\n    for case_params in test_cases:\n        d_real, d_imag = solve_case(*case_params)\n        results.append(f\"{d_real:.15e}\")\n        results.append(f\"{d_imag:.15e}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef solve_case(kF, k0, Lambda, N, beta, lam, omega, eta):\n    \"\"\"\n    Solves the Bethe-Goldstone equation for a single set of parameters\n    using both the matrix inversion method and the separable reduction,\n    and returns the discrepancies between them.\n    \"\"\"\n    # Physical constant\n    HBARC2_2M = 20.735  # MeV*fm^2\n\n    # 1. Setup Grid and Quadrature\n    # Get N Gauss-Legendre quadrature points (x) and weights (w_prime) for [-1, 1]\n    x_nodes, w_prime = roots_legendre(N)\n    \n    # Map nodes and weights to the integration interval [0, Lambda]\n    q_nodes = Lambda * (x_nodes + 1.0) / 2.0\n    w_nodes = Lambda * w_prime / 2.0\n\n    # The full momentum grid consists of k0 and the quadrature nodes.\n    # p_grid[0] = k0, p_grid[1:] = q_nodes\n    p_grid = np.concatenate(([k0], q_nodes))\n    \n    # 2. Define Physical Quantities\n    def g_form_factor(k_val):\n        return 1.0 / (k_val**2 + beta**2)\n\n    def energy_spectrum(k_val):\n        return HBARC2_2M * k_val**2\n    \n    # Evaluate quantities on the grids\n    epsilon_q = energy_spectrum(q_nodes)\n    g_p = g_form_factor(p_grid)\n    g_q = g_form_factor(q_nodes)\n    \n    # Pauli operator Q(q, kF) = 1 if q > kF, else 0\n    Q_q = (q_nodes > kF).astype(np.float64)\n\n    # Complex starting energy\n    omega_c = complex(omega, eta)\n    \n    # Propagator denominator for all quadrature points\n    propagator_denom = omega_c - 2.0 * epsilon_q\n\n    # 3. Matrix Method for G(k0, k0)\n    # The discretized B-G equation is (I - C)G = V.\n    # For a separable potential, this leads to solving (I - C)y = g_vec,\n    # and then G_00 = -lam * y_0 * g_0.\n\n    # Construct the matrix C of size (N+1) x (N+1)\n    C = np.zeros((N + 1, N + 1), dtype=np.complex128)\n    \n    # Common part of the kernel for all quadrature points\n    kernel_integrand_base = (2.0 / np.pi) * w_nodes * q_nodes**2 * Q_q / propagator_denom\n    \n    # The matrix C's columns for i=1..N are constructed. C's first column (i=0) is zero.\n    for a in range(N + 1):  # Loop over rows of C (momentum p_a)\n        # V(p_a, q_i) = -lam * g(p_a) * g(q_i)\n        # C_{a,i} for i=1..N involves V(p_a, q_{i-1}) in 0-based indexing\n        V_pa_qi = -lam * g_p[a] * g_q\n        C[a, 1:] = kernel_integrand_base * V_pa_qi\n\n    # Form the matrix M = I - C for the linear system M*y = g_vec\n    M = np.identity(N + 1, dtype=np.complex128) - C\n    \n    # The vector g_vec has components g(p_a)\n    g_vec = g_p.astype(np.complex128)\n    \n    # Solve the linear system M*y = g_vec\n    y = np.linalg.solve(M, g_vec)\n    \n    # Calculate G_matrix(k0, k0) which corresponds to G_00\n    G_matrix = -lam * g_p[0] * y[0]\n\n    # 4. Separable Reduction Method for G(k0, k0)\n    # G(k,k') = V(k,k') / (1 + lam*I)\n    # where I = (2/pi) * integral_q [ q^2 * g(q)^2 * Q(q) / (omega' - 2*eps(q)) ]\n    \n    # Evaluate the loop integral I using the same quadrature rule\n    integrand_I = (2.0 / np.pi) * q_nodes**2 * g_q**2 * Q_q / propagator_denom\n    I_val = np.sum(w_nodes * integrand_I)\n    \n    # Calculate G_sep(k0, k0)\n    G_sep = (-lam * g_p[0]**2) / (1.0 + lam * I_val)\n\n    # 5. Compute and return the absolute discrepancies\n    d_real = np.abs(G_matrix.real - G_sep.real)\n    d_imag = np.abs(G_matrix.imag - G_sep.imag)\n\n    return d_real, d_imag\n\nif __name__ == '__main__':\n    solve()\n\n```", "id": "3545576"}, {"introduction": "With the ability to calculate the in-medium interaction, we can investigate how specific features of the nuclear force shape the properties of nuclear matter. One of the early triumphs of Brueckner theory was its ability to explain nuclear saturation, a feat that is impossible at the simple Hartree-Fock level. This practice [@problem_id:3545468] allows you to explore this by implementing a model that separates the effects of central forces from the crucial second-order correlations induced by the tensor force. By computationally turning the tensor coupling 'on' and 'off,' you will directly observe its indispensable role in producing a realistic saturation point for nuclear matter.", "problem": "You are tasked with writing a complete, runnable program that, within a simplified but principled Brueckner-Hartree-Fock framework, quantifies how turning off the tensor-induced $S$–$D$ coupling in the ${}^3S_1$–${}^3D_1$ channel shifts the saturation point of symmetric nuclear matter. You must base your model on the following fundamental elements and well-tested approximations, and you must compute all energies in mega-electronvolts per nucleon (MeV per nucleon), all densities in inverse cubic femtometers (fm$^{-3}$), all wave numbers in inverse femtometers (fm$^{-1}$), and all ranges in femtometers (fm). The required output is a single line containing a list of floating-point numbers that aggregates the results for multiple test parameter sets as specified below.\n\nStart from the following base:\n\n1. Uniform symmetric nuclear matter with spin-isospin degeneracy $\\nu = 4$. The number density $\\rho$ and the Fermi momentum $k_F$ are related by\n$$\n\\rho = \\frac{\\nu k_F^3}{6\\pi^2} = \\frac{2 k_F^3}{3\\pi^2}.\n$$\n\n2. The kinetic energy per nucleon in a non-relativistic Fermi gas is\n$$\n\\frac{T}{A} = \\frac{3}{5} \\frac{\\hbar^2 k_F^2}{2m},\n$$\nwhere $\\hbar^2/(2m) = 20.735 \\ \\mathrm{MeV\\,fm^2}$.\n\n3. The potential energy per nucleon from a finite-range central force in the Hartree-Fock approximation is given by the coordinate-space expression\n$$\n\\frac{E_{\\text{central}}}{A} = \\frac{\\rho}{2} \\int d^3 r \\, V_c(r) \\left[ 1 - \\frac{1}{\\nu} \\, \\ell^2(k_F r) \\right],\n$$\nwhere $\\ell(x) = \\dfrac{3 j_1(x)}{x}$ is the Slater function with $j_1(x)$ the spherical Bessel function of order $1$. Use a two-Gaussian central potential,\n$$\nV_c(r) = V_R \\, e^{-r^2/\\alpha_R^2} + V_A \\, e^{-r^2/\\alpha_A^2},\n$$\nwith $V_R > 0$ representing short-range repulsion and $V_A < 0$ representing intermediate-range attraction. Implement the angular integration to reduce the integral to\n$$\n\\frac{E_{\\text{central}}}{A} = \\frac{\\rho}{2} \\int_{0}^{\\infty} 4\\pi r^2 \\, V_c(r) \\left[ 1 - \\frac{1}{\\nu} \\, \\ell^2(k_F r) \\right] \\, dr.\n$$\n\n4. The tensor-induced ${}^3S_1$–${}^3D_1$ coupling does not contribute at Hartree-Fock order in spin-saturated matter. To include it, approximate the second-order Brueckner correlation energy by a separable-$S$–$D$ kernel with Gaussian form factor. Model the tensor contribution per nucleon as\n$$\n\\frac{E_{\\text{tensor}}}{A} = - c_0 \\, \\frac{\\hbar^2}{2m} \\, \\frac{1}{\\Lambda} \\, \\frac{J_h(k_F;\\Lambda) \\, J_p(k_F;\\Lambda,\\kappa)}{\\rho},\n$$\nwhere $c_0$ is a dimensionless strength parameter, $\\Lambda$ is a momentum-scale cutoff, and $\\kappa$ regularizes the average particle-hole energy denominator. Use the factorized, angle-averaged integrals\n$$\nJ_h(k_F;\\Lambda) = \\int_0^{k_F} h^2 \\, e^{-2h^2/\\Lambda^2} \\, dh, \\quad\nJ_p(k_F;\\Lambda,\\kappa) = \\int_{k_F}^{\\infty} \\frac{p^2 \\, e^{-2p^2/\\Lambda^2}}{p^2 + \\kappa^2} \\, dp.\n$$\nThis factorization is obtained by approximating the energy denominator by a function of particle momentum only, $p^2 + \\kappa^2$, which is justified when particle momenta are typically larger than hole momenta in particle-hole excitations and by using a separable Gaussian form factor $g(k) = e^{-k^2/\\Lambda^2}$ for the ${}^3S_1$–${}^3D_1$ coupling.\n\n5. The total energy per nucleon is then\n$$\n\\frac{E}{A}(k_F; s) = \\frac{T}{A}(k_F) + \\frac{E_{\\text{central}}}{A}(k_F) + s \\, \\frac{E_{\\text{tensor}}}{A}(k_F),\n$$\nwith a switch parameter $s \\in \\{0,1\\}$ that represents turning the $S$–$D$ coupling off ($s=0$) or on ($s=1$).\n\nYour task:\n\n- For each parameter set in the test suite below, compute the saturation point in two scenarios: with tensor coupling ($s=1$) and with tensor coupling turned off ($s=0$). The saturation point is defined as the value of $k_F$ in a specified grid that minimizes $E/A$. If $E/A$ is monotonic over the grid, define the saturation point as the grid endpoint where $E/A$ attains its smallest value.\n- Convert each saturation Fermi momentum to saturation density using $\\rho = \\dfrac{2 k_F^3}{3\\pi^2}$.\n- Quantify the shift due to the tensor force by computing differences\n$$\n\\Delta \\rho_{\\text{sat}} = \\rho_{\\text{sat}}^{(s=1)} - \\rho_{\\text{sat}}^{(s=0)}, \\qquad\n\\Delta (E/A)_{\\text{sat}} = \\left.\\frac{E}{A}\\right|_{\\text{sat}, s=1} - \\left.\\frac{E}{A}\\right|_{\\text{sat}, s=0}.\n$$\n\nNumerical instructions and conventions:\n\n- Use $\\nu = 4$ exactly.\n- Use $\\hbar^2/(2m) = 20.735 \\ \\mathrm{MeV\\,fm^2}$ exactly.\n- For the Slater function, use $\\ell(x) = \\dfrac{3 j_1(x)}{x}$ with $j_1(x) = \\dfrac{\\sin x}{x^2} - \\dfrac{\\cos x}{x}$ and define $\\ell(0)=1$ by continuity.\n- Perform the $r$-integration for the central energy over $[0, +\\infty)$ by truncating at a large but finite upper limit. A scientifically sound choice is to use an upper limit equal to $8$ times the largest range parameter, i.e., $r_{\\max} = 8 \\, \\max(\\alpha_R,\\alpha_A)$, which is sufficient for Gaussian ranges.\n- For the tensor integrals, evaluate $J_h$ over $[0,k_F]$ and $J_p$ over $[k_F,+\\infty)$ with the exponential form factor ensuring convergence.\n- Scan the Fermi momentum on a uniform grid $k_F \\in [0.4, 1.8] \\ \\mathrm{fm^{-1}}$ with exactly $121$ points.\n- For each parameter set, return six quantities in the following order, with explicit units and rounding:\n    1. $\\rho_{\\text{sat}}^{(s=1)}$ in fm$^{-3}$, rounded to three decimals.\n    2. $\\left.\\dfrac{E}{A}\\right|_{\\text{sat}, s=1}$ in MeV per nucleon, rounded to two decimals.\n    3. $\\rho_{\\text{sat}}^{(s=0)}$ in fm$^{-3}$, rounded to three decimals.\n    4. $\\left.\\dfrac{E}{A}\\right|_{\\text{sat}, s=0}$ in MeV per nucleon, rounded to two decimals.\n    5. $\\Delta \\rho_{\\text{sat}}$ in fm$^{-3}$, rounded to three decimals.\n    6. $\\Delta (E/A)_{\\text{sat}}$ in MeV per nucleon, rounded to two decimals.\n\nTest suite (each tuple specifies $(V_R,\\alpha_R,V_A,\\alpha_A,c_0,\\Lambda,\\kappa)$ with $V_R$ and $V_A$ in MeV, $\\alpha_R$ and $\\alpha_A$ in fm, and $\\Lambda$ and $\\kappa$ in fm$^{-1}$):\n\n- Case $1$ (happy path): $(650.0, \\ 0.5, \\ -35.0, \\ 1.2, \\ 3.0, \\ 2.0, \\ 1.0)$.\n- Case $2$ (weak tensor edge): $(650.0, \\ 0.5, \\ -35.0, \\ 1.2, \\ 0.8, \\ 1.8, \\ 1.0)$.\n- Case $3$ (stronger short-range repulsion): $(800.0, \\ 0.5, \\ -30.0, \\ 1.2, \\ 3.5, \\ 2.2, \\ 1.3)$.\n\nFinal output format:\n\n- Your program should produce a single line of output containing the results for the three cases as a comma-separated list enclosed in square brackets, with the six rounded numbers for Case $1$ first, followed by the six rounded numbers for Case $2$, and then the six rounded numbers for Case $3$. For example, a syntactically correct output structure is\n$[\\rho^{(1)}_{\\text{sat}, s=1},E^{(1)}_{\\text{sat}, s=1},\\rho^{(1)}_{\\text{sat}, s=0},E^{(1)}_{\\text{sat}, s=0},\\Delta\\rho^{(1)}_{\\text{sat}},\\Delta E^{(1)}_{\\text{sat}},\\rho^{(2)}_{\\text{sat}, s=1},\\dots,\\Delta E^{(3)}_{\\text{sat}}]$.", "solution": "The problem as stated is scientifically grounded, well-posed, and objective. It presents a simplified but standard model from computational nuclear physics, specifically a Brueckner-Hartree-Fock inspired framework for symmetric nuclear matter. All components of the model, including the kinetic energy of a Fermi gas, the Hartree-Fock potential energy with a Gaussian interaction, and a separable model for second-order tensor correlations, are based on established principles. The parameters, constants, and numerical instructions are complete and consistent. Therefore, a meaningful and unique solution can be derived. We proceed with the solution.\n\nThe objective is to determine the saturation point—the density $\\rho_{\\text{sat}}$ and energy per nucleon $(E/A)_{\\text{sat}}$ at which the system is most stable—for symmetric nuclear matter. We will compute this for two cases: with the tensor-force contribution included ($s=1$) and without it ($s=0$). The shift in the saturation point will then be quantified.\n\nThe total energy per nucleon, $\\frac{E}{A}$, is a function of the Fermi momentum $k_F$ and a switch parameter $s$:\n$$\n\\frac{E}{A}(k_F; s) = \\frac{T}{A}(k_F) + \\frac{E_{\\text{central}}}{A}(k_F) + s \\, \\frac{E_{\\text{tensor}}}{A}(k_F)\n$$\nThe Fermi momentum $k_F$ is related to the nucleon number density $\\rho$ for spin-isospin symmetric matter (degeneracy $\\nu=4$) by $\\rho = \\frac{2 k_F^3}{3\\pi^2}$. We will analyze each term of the energy expression in detail.\n\n**1. Kinetic Energy per Nucleon**\nThe average kinetic energy per nucleon, $\\frac{T}{A}$, for a non-relativistic Fermi gas is given by:\n$$\n\\frac{T}{A}(k_F) = \\frac{3}{5} \\frac{\\hbar^2 k_F^2}{2m}\n$$\nThis term represents the energy arising from the quantum-mechanical motion of nucleons confined within a finite volume, as dictated by the Pauli exclusion principle. We use the provided constant $\\frac{\\hbar^2}{2m} = 20.735 \\ \\mathrm{MeV\\,fm^2}$.\n\n**2. Central Potential Energy per Nucleon**\nThe contribution from central forces, $\\frac{E_{\\text{central}}}{A}$, is calculated within the Hartree-Fock approximation. This term accounts for the direct (Hartree) and exchange (Fock) interactions between nucleons. The provided formula is:\n$$\n\\frac{E_{\\text{central}}}{A}(k_F) = \\frac{\\rho}{2} \\int_{0}^{\\infty} 4\\pi r^2 \\, V_c(r) \\left[ 1 - \\frac{1}{\\nu} \\, \\ell^2(k_F r) \\right] \\, dr\n$$\nThe components of this expression are:\n- $V_c(r) = V_R \\, e^{-r^2/\\alpha_R^2} + V_A \\, e^{-r^2/\\alpha_A^2}$: A two-range Gaussian potential, a common phenomenological form representing short-range repulsion ($V_R > 0$) and intermediate-range attraction ($V_A < 0$).\n- $\\ell(x) = \\frac{3 j_1(x)}{x}$: The Slater function, where $j_1(x)$ is the spherical Bessel function of the first kind of order one. The term $\\ell^2(k_F r)$ arises from the angle-averaging of the squared one-body density matrix and represents the effect of Pauli blocking on the two-nucleon interaction in the medium. By continuity, $\\ell(0)=1$. This integral is evaluated numerically for each $k_F$. Per the instructions, the integration range is truncated at a sufficiently large radius $r_{\\max} = 8 \\, \\max(\\alpha_R, \\alpha_A)$ to ensure convergence due to the Gaussian nature of the potential.\n\n**3. Tensor Correlation Energy per Nucleon**\nThe Hartree-Fock approximation for spin-saturated matter does not capture the effects of the strong tensor force, which is a key driver of nuclear binding and saturation. The term $\\frac{E_{\\text{tensor}}}{A}$ models this contribution as a second-order perturbation in the Brueckner G-matrix formalism. The formula given is:\n$$\n\\frac{E_{\\text{tensor}}}{A}(k_F) = - c_0 \\, \\frac{\\hbar^2}{2m} \\, \\frac{1}{\\Lambda} \\, \\frac{J_h(k_F;\\Lambda) \\, J_p(k_F;\\Lambda,\\kappa)}{\\rho}\n$$\nThis expression approximates the energy gain from virtual particle-hole excitations induced by the tensor force coupling the ${}^3S_1$ and ${}^3D_1$ partial waves. Its components are:\n- $J_h(k_F;\\Lambda) = \\int_0^{k_F} h^2 \\, e^{-2h^2/\\Lambda^2} \\, dh$: An integral over occupied \"hole\" states up to the Fermi momentum $k_F$.\n- $J_p(k_F;\\Lambda,\\kappa) = \\int_{k_F}^{\\infty} \\frac{p^2 \\, e^{-2p^2/\\Lambda^2}}{p^2 + \\kappa^2} \\, dp$: An integral over unoccupied \"particle\" states above $k_F$.\n- The Gaussian form factor $e^{-k^2/\\Lambda^2}$ reflects the finite range of the interaction in momentum space. The term $\\frac{1}{p^2+\\kappa^2}$ is a simplified angle-averaged energy denominator, where $\\kappa$ represents an average excitation energy scale. The negative sign indicates that this second-order term is attractive. These integrals are computed numerically.\n\n**Computational Procedure**\nThe core of the task is to implement a procedure to calculate $\\frac{E}{A}$ as a function of $k_F$ and find its minimum.\n1.  A uniform grid of $121$ points for $k_F$ is established in the interval $[0.4, 1.8] \\ \\mathrm{fm^{-1}}$.\n2.  For each parameter set provided in the test suite:\n    a. We compute the energy-per-nucleon curve $\\frac{E}{A}(k_F)$ across the grid for both $s=1$ (tensor on) and $s=0$ (tensor off). This involves calculating the three energy components for each $k_F$ value, using numerical integration (`scipy.integrate.quad`) for the central and tensor potential terms.\n    b. The saturation point for each scenario is identified by finding the value of $k_F$ on the grid that minimizes $\\frac{E}{A}$. If the function is monotonic on the grid, the saturation point is taken as the grid endpoint with the lower energy.\n    c. The saturation Fermi momentum, $k_{F, \\text{sat}}$, is used to calculate the saturation density $\\rho_{\\text{sat}} = \\frac{2 k_{F, \\text{sat}}^3}{3\\pi^2}$. The corresponding minimum energy is $(E/A)_{\\text{sat}}$.\n    d. Finally, the differences $\\Delta \\rho_{\\text{sat}} = \\rho_{\\text{sat}}^{(s=1)} - \\rho_{\\text{sat}}^{(s=0)}$ and $\\Delta (E/A)_{\\text{sat}} = (E/A)_{\\text{sat}}^{(s=1)} - (E/A)_{\\text{sat}}^{(s=0)}$ are calculated to quantify the impact of the tensor force.\n3.  The six resulting quantities for each test case are rounded as specified and aggregated into a single output list.\n\nThe implementation will be encapsulated in a Python program utilizing the `numpy` and `scipy` libraries for numerical calculations.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\nfrom scipy.special import spherical_jn\n\ndef solve():\n    \"\"\"\n    Computes the saturation point of symmetric nuclear matter using a\n    simplified Brueckner-Hartree-Fock framework and quantifies the shift\n    due to the tensor force.\n    \"\"\"\n\n    # --- Fixed Physical and Model Constants ---\n    HBAR2_OVER_2M = 20.735  # MeV*fm^2\n    NU = 4.0  # Spin-isospin degeneracy\n\n    # --- Test Cases ---\n    # Each tuple: (V_R, alpha_R, V_A, alpha_A, c0, Lambda, kappa)\n    test_cases = [\n        (650.0, 0.5, -35.0, 1.2, 3.0, 2.0, 1.0),\n        (650.0, 0.5, -35.0, 1.2, 0.8, 1.8, 1.0),\n        (800.0, 0.5, -30.0, 1.2, 3.5, 2.2, 1.3),\n    ]\n\n    # --- Numerical Grid ---\n    kF_grid = np.linspace(0.4, 1.8, 121)\n\n    # --- Helper Functions for Energy Calculation ---\n\n    def _density(kF):\n        \"\"\"Calculates nucleon number density from Fermi momentum.\"\"\"\n        return 2.0 * kF**3 / (3.0 * np.pi**2)\n\n    def _kinetic_energy_per_nucleon(kF):\n        \"\"\"Calculates kinetic energy per nucleon.\"\"\"\n        return (3.0 / 5.0) * HBAR2_OVER_2M * kF**2\n\n    def _slater_l(x):\n        \"\"\"\n        Calculates the Slater function l(x) = 3*j1(x)/x.\n        Handles the x=0 case by using the known limit l(0)=1.\n        \"\"\"\n        if np.isclose(x, 0.0):\n            return 1.0\n        # For precision, use spherical_jn(1,x) which computes j_1(x)\n        return 3.0 * spherical_jn(1, x) / x\n\n    def _central_energy_per_nucleon(kF, params):\n        \"\"\"Calculates the central potential energy per nucleon.\"\"\"\n        V_R, alpha_R, V_A, alpha_A, _, _, _ = params\n        rho = _density(kF)\n\n        def Vc(r):\n            return V_R * np.exp(-r**2 / alpha_R**2) + V_A * np.exp(-r**2 / alpha_A**2)\n\n        def integrand(r):\n            slater_term = _slater_l(kF * r)\n            return 4.0 * np.pi * r**2 * Vc(r) * (1.0 - (1.0 / NU) * slater_term**2)\n\n        r_max = 8.0 * max(alpha_R, alpha_A)\n        # The integral from 0 to r_max\n        integral_val, _ = quad(integrand, 0, r_max, epsabs=1e-9, limit=100)\n\n        return (rho / 2.0) * integral_val\n\n    def _tensor_energy_per_nucleon(kF, params):\n        \"\"\"Calculates the tensor correlation energy per nucleon.\"\"\"\n        _, _, _, _, c0, Lambda, kappa = params\n        \n        if np.isclose(kF, 0.0):\n            return 0.0\n\n        rho = _density(kF)\n\n        # J_h integral\n        def jh_integrand(h):\n            return h**2 * np.exp(-2.0 * h**2 / Lambda**2)\n\n        Jh, _ = quad(jh_integrand, 0, kF, epsabs=1e-9, limit=100)\n\n        # J_p integral\n        def jp_integrand(p):\n            return (p**2 * np.exp(-2.0 * p**2 / Lambda**2)) / (p**2 + kappa**2)\n\n        Jp, _ = quad(jp_integrand, kF, np.inf, epsabs=1e-9, limit=100)\n\n        return -c0 * HBAR2_OVER_2M * (1.0 / Lambda) * (Jh * Jp / rho)\n\n    def _get_saturation_properties(params, s, kF_grid):\n        \"\"\"\n        Calculates the energy-density curve and finds the saturation point.\n        s=1 for tensor ON, s=0 for tensor OFF.\n        \"\"\"\n        energies = []\n        # Pre-calculate central energies as they are independent of 's'\n        central_energies = {kF: _central_energy_per_nucleon(kF, params) for kF in kF_grid}\n\n        for kF in kF_grid:\n            e_kin = _kinetic_energy_per_nucleon(kF)\n            e_cen = central_energies[kF]\n            e_ten = 0.0\n            if s == 1:\n                e_ten = _tensor_energy_per_nucleon(kF, params)\n            \n            total_energy = e_kin + e_cen + e_ten\n            energies.append(total_energy)\n        \n        energies = np.array(energies)\n        idx_min = np.argmin(energies)\n        \n        e_sat = energies[idx_min]\n        kF_sat = kF_grid[idx_min]\n        rho_sat = _density(kF_sat)\n        \n        return rho_sat, e_sat\n\n    # --- Main Loop to Process Test Cases ---\n    final_results = []\n    for params in test_cases:\n        # Scenario s=1 (Tensor ON)\n        rho_sat_s1, e_sat_s1 = _get_saturation_properties(params, 1, kF_grid)\n\n        # Scenario s=0 (Tensor OFF)\n        rho_sat_s0, e_sat_s0 = _get_saturation_properties(params, 0, kF_grid)\n\n        # Differences\n        delta_rho = rho_sat_s1 - rho_sat_s0\n        delta_e = e_sat_s1 - e_sat_s0\n\n        # Store rounded results in the required order\n        final_results.extend([\n            round(rho_sat_s1, 3), round(e_sat_s1, 2),\n            round(rho_sat_s0, 3), round(e_sat_s0, 2),\n            round(delta_rho, 3), round(delta_e, 2)\n        ])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n\n```", "id": "3545468"}, {"introduction": "A successful many-body theory must not only reproduce experimental data but also be internally consistent. This final hands-on exercise [@problem_id:3545559] delves into this crucial aspect by tasking you with the numerical verification of the Hugenholtz-Van Hove theorem. This theorem establishes a fundamental link between the system's thermodynamic properties (chemical potential, pressure) and the single-particle energy at the Fermi surface. Successfully verifying it requires a correct treatment of the single-particle potential, forcing you to confront the concept of rearrangement energy—a subtle but critical contribution that arises from the density dependence of the $G$-matrix.", "problem": "You are asked to build a minimal, self-consistent numerical checker for the Hugenholtz–Van Hove theorem (HVH) within a simplified Brueckner–Hartree–Fock (BHF) framework for infinite symmetric nuclear matter at zero temperature. The implementation must be a complete, runnable program. The goal is to verify numerically whether the HVH equality at saturation density is satisfied under the continuous choice and to quantify deviations that arise when approximations are made in the single-particle potential or in the treatment of the Pauli blocking operator.\n\nStart from the following fundamental definitions and modeling assumptions:\n\n- Infinite symmetric nuclear matter is a homogeneous Fermi system with spin–isospin degeneracy $g = 4$. The number density is $\\,\\rho\\,$ (in $\\mathrm{fm}^{-3}$), the Fermi momentum is $\\,k_F\\,$ (in $\\mathrm{fm}^{-1}$), and the nucleon mass is $\\,m_N\\,$ (in $\\mathrm{MeV}$). Use $\\,\\hbar c = 197.3269804\\,\\mathrm{MeV\\cdot fm}\\,$ and natural units with $c=1$.\n- The relation between density and Fermi momentum is\n$$\n\\rho = \\frac{g\\,k_F^3}{6\\pi^2} \\quad\\Rightarrow\\quad k_F(\\rho) = \\left(\\frac{6\\pi^2}{g}\\rho\\right)^{1/3}.\n$$\n- The single-particle kinetic energy is $\\,t(k) = \\frac{\\hbar^2 k^2}{2 m_N}\\,$. The energy per particle of a free Fermi gas at zero temperature is\n$$\n\\frac{T}{A}(\\rho) = \\frac{3}{5} \\frac{\\hbar^2 k_F(\\rho)^2}{2 m_N}.\n$$\n- Model the interaction through a density-dependent effective Brueckner $G$-matrix of the form\n$$\nG(\\rho) = g_0 + g_1 \\rho^\\beta,\n$$\nwhere $g_0$ and $g_1$ are parameters (with appropriate units) to be calibrated, and $\\beta > 0$ is a fixed exponent that encodes the qualitative effect of intermediate-state Pauli blocking and correlation strength. The interaction energy per particle is\n$$\n\\left(\\frac{V}{A}\\right)(\\rho) = \\frac{1}{2}\\,\\rho\\,G(\\rho).\n$$\n- The total energy per particle is\n$$\ne(\\rho) \\equiv \\frac{E}{A}(\\rho) = \\frac{T}{A}(\\rho) + \\frac{1}{2}\\,\\rho\\,G(\\rho).\n$$\n- The energy density is $\\,\\varepsilon(\\rho) = \\rho\\,e(\\rho)\\,$. The chemical potential (zero-temperature) is defined by the thermodynamic derivative\n$$\n\\mu(\\rho) = \\frac{\\partial \\varepsilon}{\\partial \\rho}(\\rho).\n$$\n- The pressure is\n$$\np(\\rho) = \\rho^2\\,\\frac{d e}{d \\rho}(\\rho).\n$$\n- Under the continuous choice, the single-particle potential $\\,U(k;\\rho)\\,$ is defined for all $\\,k\\,$, and in a local-density mean-field approximation its value at the Fermi surface includes the rearrangement contribution arising from the density dependence of $\\,G(\\rho)\\,$. Consider two approximations:\n  1. Without rearrangement:\n  $$\n  U_{\\text{noR}}(k_F;\\rho) = \\rho\\,G(\\rho).\n  $$\n  2. With rearrangement:\n  $$\n  U_{\\text{R}}(k_F;\\rho) = \\frac{\\partial}{\\partial \\rho}\\left[\\frac{1}{2}\\rho^2 G(\\rho)\\right] = \\rho\\,G(\\rho) + \\frac{1}{2}\\rho^2\\,\\frac{dG}{d\\rho}(\\rho),\n  \\quad\\text{where}\\quad\n  \\frac{dG}{d\\rho}(\\rho) = \\beta g_1 \\rho^{\\beta-1}.\n  $$\n- The single-particle energy at the Fermi surface is\n$$\n\\varepsilon_{\\text{sp}}(k_F;\\rho) = t(k_F) + U(k_F;\\rho),\n$$\nwith $\\,U=U_{\\text{noR}}\\,$ or $\\,U=U_{\\text{R}}\\,$ depending on the chosen approximation.\n\nCalibration at saturation:\n- Let the empirical saturation density be $\\,\\rho_0 = 0.16\\,\\mathrm{fm}^{-3}\\,$ and the saturation energy per particle be $\\,e(\\rho_0) = e_0 = -16\\,\\mathrm{MeV}\\,$. Saturation implies $\\,p(\\rho_0) = 0\\,$. For a given exponent $\\,\\beta\\,$, determine $\\,g_0\\,$ and $\\,g_1\\,$ by enforcing simultaneously $\\,e(\\rho_0)=e_0\\,$ and $\\,p(\\rho_0)=0\\,$. These two constraints must be solved exactly using the definitions above.\n\nNumerical checks to perform:\n- For each test case, compute:\n  1. The HVH thermodynamic residual\n  $$\n  R_e(\\rho) = \\mu(\\rho) - \\left[e(\\rho) + \\frac{p(\\rho)}{\\rho}\\right],\n  $$\n  expressed in $\\mathrm{MeV}$. The HVH theorem states that, for a Fermi liquid at zero temperature, $\\,\\mu(\\rho) = e(\\rho) + p(\\rho)/\\rho\\,$.\n  2. The HVH single-particle residual\n  $$\n  R_{\\text{sp}}(\\rho) = \\mu(\\rho) - \\varepsilon_{\\text{sp}}(k_F;\\rho),\n  $$\n  expressed in $\\mathrm{MeV}$. Under the continuous choice with full self-consistency, HVH requires $\\,\\mu(\\rho) = \\varepsilon_{\\text{sp}}(k_F;\\rho)\\,$.\n\nPhysical units and constants:\n- Express energies in $\\mathrm{MeV}$, densities in $\\mathrm{fm}^{-3}$, and momenta in $\\mathrm{fm}^{-1}$. Use $\\,m_N = 938.918\\,\\mathrm{MeV}\\,$ and $\\,\\hbar c = 197.3269804\\,\\mathrm{MeV\\cdot fm}\\,$. Angles do not appear and need not be specified.\n\nTest suite:\n- Implement the following four cases that probe different aspects and edge conditions:\n  1. Case A (happy path, continuous choice with rearrangement at saturation): $\\,\\rho=\\rho_0\\,$, $\\,\\beta=1.25\\,$, $\\,U=U_{\\text{R}}\\,$.\n  2. Case B (deviation from omitting rearrangement at saturation): $\\,\\rho=\\rho_0\\,$, $\\,\\beta=1.25\\,$, $\\,U=U_{\\text{noR}}\\,$.\n  3. Case C (low-density boundary, continuous choice with rearrangement): $\\,\\rho=10^{-3}\\,\\mathrm{fm}^{-3}\\,$, $\\,\\beta=1.25\\,$, $\\,U=U_{\\text{R}}\\,$ with the same $\\,g_0,g_1\\,$ calibrated at $\\,\\rho_0\\,$.\n  4. Case D (modified density dependence mimicking angle-averaged Pauli operator effects, omission of rearrangement): $\\,\\rho=\\rho_0\\,$, $\\,\\beta=0.50\\,$, $\\,U=U_{\\text{noR}}\\,$.\n\nOutput specification:\n- Your program should produce a single line of output containing the eight residual values for the four cases as a comma-separated list enclosed in square brackets, in the order\n$$\n[R_e^{A}, R_{\\text{sp}}^{A}, R_e^{B}, R_{\\text{sp}}^{B}, R_e^{C}, R_{\\text{sp}}^{C}, R_e^{D}, R_{\\text{sp}}^{D}],\n$$\nrounded to six decimal places, each in $\\mathrm{MeV}$. For example, a valid output format is\n$$\n[\\text{float}_1,\\text{float}_2,\\ldots,\\text{float}_8].\n$$\n\nYour implementation must strictly adhere to the specified units. The program must be self-contained, require no input, and run as is. It must compute $\\,g_0\\,$ and $\\,g_1\\,$ via the saturation constraints for each chosen $\\,\\beta\\,$, then evaluate the residuals $\\,R_e\\,$ and $\\,R_{\\text{sp}}\\,$ in the four cases as described above, and finally print the single-line output in the exact format specified.", "solution": "The problem requires the numerical validation of the Hugenholtz–Van Hove (HVH) theorem within a simplified Brueckner–Hartree–Fock (BHF) model for infinite symmetric nuclear matter. This involves calibrating a model for the nucleon-nucleon interaction, calculating key thermodynamic and single-particle quantities, and then evaluating two specific residuals that quantify the adherence to or deviation from the HVH theorem under different physical approximations.\n\n**1. Theoretical Framework and Model Definitions**\n\nThe model describes infinite symmetric nuclear matter as a zero-temperature Fermi gas with spin-isospin degeneracy $g=4$. The state of the system is defined by the nucleon number density $\\rho$.\n\n- **Kinetic Energy:** The kinetic energy contribution is that of a free Fermi gas. The Fermi momentum $k_F$ is related to the density $\\rho$ by $k_F(\\rho) = (6\\pi^2\\rho/g)^{1/3}$. The average kinetic energy per particle is\n$$\n\\frac{T}{A}(\\rho) = \\frac{3}{5} t(k_F(\\rho)) = \\frac{3}{5} \\frac{\\hbar^2 k_F(\\rho)^2}{2 m_N}\n$$\nwhere $t(k) = \\hbar^2 k^2/(2m_N)$ is the single-particle kinetic energy. For implementation, we define a constant $C_{\\text{kin}} = \\hbar^2/(2m_N) = (\\hbar c)^2/(2 m_N c^2)$, where the provided values are $\\hbar c = 197.3269804\\,\\mathrm{MeV\\cdot fm}$ and $m_N = 938.918\\,\\mathrm{MeV}$.\n\n- **Interaction Energy:** The interaction is modeled by a density-dependent effective $G$-matrix, $G(\\rho) = g_0 + g_1 \\rho^\\beta$. The parameters $g_0$ and $g_1$ are to be determined by calibration, while $\\beta$ is a given exponent. The interaction energy per particle is given by\n$$\n\\left(\\frac{V}{A}\\right)(\\rho) = \\frac{1}{2}\\,\\rho\\,G(\\rho) = \\frac{1}{2}g_0\\rho + \\frac{1}{2}g_1\\rho^{1+\\beta}\n$$\n\n- **Total Energy per Particle:** The total energy per particle, $e(\\rho)$, is the sum of the kinetic and potential contributions:\n$$\ne(\\rho) = \\frac{E}{A}(\\rho) = \\frac{T}{A}(\\rho) + \\frac{1}{2}\\rho G(\\rho) = C_{\\text{kin}} \\frac{3}{5} \\left(\\frac{6\\pi^2}{g}\\right)^{2/3}\\rho^{2/3} + \\frac{1}{2}g_0\\rho + \\frac{1}{2}g_1\\rho^{1+\\beta}\n$$\n\n**2. Derived Quantities and the HVH Theorem**\n\nFrom the energy per particle $e(\\rho)$, we derive other essential thermodynamic quantities.\n\n- **Pressure ($p$):** The pressure at zero temperature is given by $p(\\rho) = \\rho^2 \\frac{de}{d\\rho}$. The saturation condition of nuclear matter implies that at the saturation density $\\rho_0$, the pressure is zero, which means $\\frac{de}{d\\rho}|_{\\rho=\\rho_0} = 0$.\n\n- **Chemical Potential ($\\mu$):** The chemical potential is the derivative of the total energy density $\\varepsilon(\\rho) = \\rho e(\\rho)$ with respect to density:\n$$\n\\mu(\\rho) = \\frac{\\partial \\varepsilon}{\\partial \\rho} = \\frac{\\partial}{\\partial \\rho}(\\rho e(\\rho)) = e(\\rho) + \\rho \\frac{de}{d\\rho}\n$$\n\n- **Hugenholtz-Van Hove Theorem:** The HVH theorem provides fundamental consistency relations.\n    1.  **Thermodynamic Relation:** The first relation connects the chemical potential, energy per particle, and pressure: $\\mu(\\rho) = e(\\rho) + p(\\rho)/\\rho$. Substituting the definitions $p(\\rho) = \\rho^2 \\frac{de}{d\\rho}$ and $\\mu(\\rho) = e(\\rho) + \\rho \\frac{de}{d\\rho}$, we see this identity holds true by definition:\n    $$\n    e(\\rho) + \\frac{p(\\rho)}{\\rho} = e(\\rho) + \\frac{\\rho^2 \\frac{de}{d\\rho}}{\\rho} = e(\\rho) + \\rho \\frac{de}{d\\rho} = \\mu(\\rho)\n    $$\n    The thermodynamic residual $R_e(\\rho) = \\mu(\\rho) - [e(\\rho) + p(\\rho)/\\rho]$ must therefore be analytically zero. A non-zero numerical result for $R_e$ would indicate an inconsistency in the implementation of the thermodynamic derivatives.\n\n    2.  **Single-Particle Relation:** The second part of the theorem states that in a self-consistent calculation, the chemical potential equals the single-particle energy at the Fermi surface, $\\mu(\\rho) = \\varepsilon_{\\text{sp}}(k_F;\\rho)$. Let's derive the explicit expression for $\\mu(\\rho)$:\n    $$\n    \\mu(\\rho) = \\frac{5}{3}\\frac{T}{A}(\\rho) + \\rho G(\\rho) + \\frac{1}{2}\\rho^2 \\frac{dG}{d\\rho}(\\rho)\n    $$\n    Since $\\frac{T}{A}(\\rho) = \\frac{3}{5}t(k_F(\\rho))$, this simplifies to:\n    $$\n    \\mu(\\rho) = t(k_F(\\rho)) + \\rho G(\\rho) + \\frac{1}{2}\\rho^2 \\frac{dG}{d\\rho}(\\rho)\n    $$\n    The single-particle energy at the Fermi surface is $\\varepsilon_{\\text{sp}}(k_F;\\rho) = t(k_F) + U(k_F;\\rho)$. The problem defines two approximations for the single-particle potential $U$:\n    -   Without rearrangement: $U_{\\text{noR}}(k_F;\\rho) = \\rho G(\\rho)$.\n    -   With rearrangement: $U_{\\text{R}}(k_F;\\rho) = \\rho G(\\rho) + \\frac{1}{2}\\rho^2 \\frac{dG}{d\\rho}(\\rho)$.\n    The single-particle residual is $R_{\\text{sp}}(\\rho) = \\mu(\\rho) - \\varepsilon_{\\text{sp}}(k_F;\\rho)$.\n    -   If $U=U_{\\text{R}}$, then $\\varepsilon_{\\text{sp}}(k_F;\\rho) = t(k_F) + U_{\\text{R}} = t(k_F) + \\rho G + \\frac{1}{2}\\rho^2 \\frac{dG}{d\\rho} = \\mu(\\rho)$. Thus, $R_{\\text{sp}}$ should be analytically zero. This choice of $U$ is \"self-consistent\" in the sense of satisfying the HVH theorem.\n    -   If $U=U_{\\text{noR}}$, then $\\varepsilon_{\\text{sp}}(k_F;\\rho) = t(k_F) + U_{\\text{noR}} = t(k_F) + \\rho G$. The residual becomes $R_{\\text{sp}} = \\mu(\\rho) - \\varepsilon_{\\text{sp}} = \\frac{1}{2}\\rho^2 \\frac{dG}{d\\rho}(\\rho)$. This residual is non-zero and isolates the \"rearrangement\" contribution to the chemical potential, which is neglected in the $U_{\\text{noR}}$ approximation.\n\n**3. Calibration of Model Parameters**\n\nFor a given exponent $\\beta$, the parameters $g_0$ and $g_1$ are determined by enforcing two empirical conditions at the saturation density $\\rho_0 = 0.16\\,\\mathrm{fm}^{-3}$:\n1.  $e(\\rho_0) = e_0 = -16\\,\\mathrm{MeV}$\n2.  $p(\\rho_0) = 0 \\implies \\frac{de}{d\\rho}|_{\\rho=\\rho_0} = 0$\n\nThese two conditions form a system of two linear equations for $g_0$ and $g_1$:\n1.  $\\frac{T}{A}(\\rho_0) + \\frac{1}{2}g_0\\rho_0 + \\frac{1}{2}g_1\\rho_0^{1+\\beta} = e_0$\n2.  $\\frac{d}{d\\rho}\\left(\\frac{T}{A}\\right)\\Big|_{\\rho_0} + \\frac{1}{2}g_0 + \\frac{1}{2}(1+\\beta)g_1\\rho_0^\\beta = 0$\n\nUsing $\\frac{d}{d\\rho}(\\frac{T}{A}) = \\frac{2}{3\\rho}\\frac{T}{A}(\\rho)$, the system can be solved analytically for $g_0$ and $g_1$:\n$$\ng_1 = \\frac{\\frac{2}{3}\\frac{T}{A}(\\rho_0) - 2e_0}{\\beta \\rho_0^{1+\\beta}}\n$$\n$$\ng_0 = \\frac{2(e_0 - \\frac{T}{A}(\\rho_0))}{\\rho_0} - g_1\\rho_0^\\beta\n$$\nThis calibration must be performed for each value of $\\beta$ specified in the test cases.\n\n**4. Numerical Implementation Strategy**\n\nThe solution is implemented in Python. A class `NuclearMatterModel` encapsulates the physics logic.\n- An instance of the class is created for a specific value of $\\beta$. Constants like $m_N$ and $\\hbar c$ are initialized.\n- The `calibrate` method implements the analytical solution for $g_0$ and $g_1$ and stores them as instance attributes.\n- Methods for all physical quantities ($k_F$, $T/A$, $e$, $p$, $\\mu$, $U_{\\text{noR}}$, $U_{\\text{R}}$, $\\varepsilon_{\\text{sp}}$) are implemented based on the derived formulas. Special care is taken to use numerically stable and efficient expressions, such as the direct analytical formula for $\\mu(\\rho)$.\n- A main function orchestrates the test suite. It creates model instances for $\\beta=1.25$ and $\\beta=0.50$, calibrates them, and then iterates through the four specified test cases.\n- For each case, it calls a method to compute the two residuals, $R_e$ and $R_{\\text{sp}}$, using the appropriate density $\\rho$ and single-particle potential choice $U$.\n- The eight resulting residual values are collected, formatted to six decimal places, and printed in the specified list format. The expected results are near-zero values for $R_e$ in all cases and for $R_{\\text{sp}}$ in cases A and C, and non-zero values for $R_{\\text{sp}}$ in cases B and D, reflecting the physical approximations being tested.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the computational nuclear physics problem to check the Hugenholtz-Van Hove theorem.\n    \"\"\"\n\n    # Define physical constants and saturation properties\n    HBARC = 197.3269804  # MeV fm\n    M_N = 938.918      # MeV (mass of nucleon, m_N*c^2)\n    G_DEGEN = 4          # Spin-isospin degeneracy for symmetric nuclear matter\n    RHO_0 = 0.16         # Saturation density in fm^-3\n    E_0 = -16.0          # Saturation energy per particle in MeV\n\n    class NuclearMatterModel:\n        \"\"\"\n        Encapsulates the physics of the simplified BHF model for nuclear matter.\n        \"\"\"\n        def __init__(self, beta, g_degen, m_n, hbarc):\n            self.beta = beta\n            self.g_degen = g_degen\n            self.m_n = m_n\n            self.hbarc = hbarc\n            \n            # Pre-calculate kinetic energy constant\n            self.c_kin = self.hbarc**2 / (2 * self.m_n)  # This is hbar^2/(2m) in units of MeV*fm^2\n            \n            self.g0 = None\n            self.g1 = None\n\n        def k_F(self, rho):\n            \"\"\"Calculates the Fermi momentum k_F in fm^-1.\"\"\"\n            if rho  0: return 0.0\n            return (6 * np.pi**2 * rho / self.g_degen)**(1/3)\n\n        def T_per_A(self, rho):\n            \"\"\"Calculates the kinetic energy per nucleon T/A in MeV.\"\"\"\n            if rho = 0: return 0.0\n            kf_sq = self.k_F(rho)**2\n            return (3/5) * self.c_kin * kf_sq\n\n        def calibrate(self, rho0, e0):\n            \"\"\"\n            Calibrates g0 and g1 parameters using saturation properties.\n            \"\"\"\n            t_A_at_rho0 = self.T_per_A(rho0)\n            \n            # From the saturation condition p(rho0)=0 => de/drho(rho0)=0\n            # and e(rho0)=e0, we derive g0 and g1.\n            \n            # Solve for g1\n            numerator_g1 = (2/3) * t_A_at_rho0 / rho0 + (1/2) * (1 + self.beta) * (e0 - t_A_at_rho0) / (0.5 * rho0**(1+self.beta))\n            numerator_g1 = (2/3) * t_A_at_rho0 + (1 + self.beta) * (e0 - t_A_at_rho0)\n            numerator_g1 = (2/3) * t_A_at_rho0 - (1+self.beta)*(t_A_at_rho0) + (1+self.beta)*e0\n            numerator_g1 = e0 * (1 + self.beta) - t_A_at_rho0 * (1/3 + self.beta) # derived from de/drho=0\n            \n            # Analytical derivation from the two linear equations:\n            # eq1: T/A + 0.5*g0*rho0 + 0.5*g1*rho0^(1+b) = e0\n            # eq2: (2/3)*T/A/rho0 + 0.5*g0 + 0.5*(1+b)*g1*rho0^b = 0\n            # From eq2: g0 = -(1+b)*g1*rho0^b - (4/3)*T/A/rho0\n            # Substitute into eq1 and solve for g1.\n            \n            t_over_rho = self.T_per_A(rho0) / rho0\n            \n            g1_num = 2 * (e0 - self.T_per_A(rho0) + (2/3) * t_over_rho * rho0)\n            g1_den = rho0**(1+self.beta) * (1 - (1+self.beta))\n            \n            # Correct derivation\n            # 1. 2(e0 - T0)/rho0 = g0 + g1 * rho0^beta\n            # 2. -2/rho0 * (2/3 T0/rho0) = g0 + (1+beta)g1*rho0^beta\n            # (1) - (2): 2(e0-T0)/rho0 + 4/3 T0/rho0^2 = -beta*g1*rho0^beta\n            # g1 = -1/(beta*rho0^beta) * [2(e0-T0)/rho0 + 4/3 T0/rho0^2]\n            \n            self.g1 = (-1.0 / (self.beta * rho0**(self.beta))) * (2 * (e0 - t_A_at_rho0) / rho0 + (4/3) * t_A_at_rho0 / rho0**2)\n            self.g0 = 2 * (e0 - t_A_at_rho0) / rho0 - self.g1 * rho0**self.beta\n\n\n        def G_matrix(self, rho):\n            \"\"\"Calculates the effective G-matrix interaction.\"\"\"\n            if rho = 0: return self.g0 # Trivial low-density limit\n            return self.g0 + self.g1 * rho**self.beta\n\n        def dG_drho(self, rho):\n            \"\"\"Calculates the derivative of the G-matrix w.r.t. density.\"\"\"\n            if rho = 0 or self.beta == 0: return 0.0\n            return self.beta * self.g1 * rho**(self.beta - 1)\n\n        def energy_per_particle(self, rho):\n            \"\"\"Calculates the total energy per particle e(rho) in MeV.\"\"\"\n            return self.T_per_A(rho) + 0.5 * rho * self.G_matrix(rho)\n\n        def de_drho(self, rho):\n            \"\"\"Calculates the derivative of energy per particle w.r.t. density.\"\"\"\n            if rho = 0: return 0.0\n            dt_drho = (2/3) * self.T_per_A(rho) / rho\n            return dt_drho + 0.5 * self.G_matrix(rho) + 0.5 * rho * self.dG_drho(rho)\n\n        def pressure(self, rho):\n            \"\"\"Calculates the pressure p(rho) in MeV/fm^3.\"\"\"\n            if rho = 0: return 0.0\n            return rho**2 * self.de_drho(rho)\n\n        def chemical_potential(self, rho):\n            \"\"\"Calculates the chemical potential mu(rho) in MeV.\"\"\"\n            if rho = 0: return 0.0\n            # Analytically simplified form derived from mu = e + rho * de/drho\n            t_kF = self.c_kin * self.k_F(rho)**2\n            g_val = self.G_matrix(rho)\n            dg_drho_val = self.dG_drho(rho)\n            return t_kF + rho * g_val + 0.5 * rho**2 * dg_drho_val\n\n        def sp_energy_kF(self, rho, U_type):\n            \"\"\"\n            Calculates the single-particle energy at the Fermi surface in MeV.\n            U_type can be 'R' (with rearrangement) or 'noR' (without).\n            \"\"\"\n            t_kF = self.c_kin * self.k_F(rho)**2\n            g_val = self.G_matrix(rho)\n\n            if U_type == 'R':\n                dg_drho_val = self.dG_drho(rho)\n                U_val = rho * g_val + 0.5 * rho**2 * dg_drho_val\n            elif U_type == 'noR':\n                U_val = rho * g_val\n            else:\n                raise ValueError(\"Invalid U_type specified.\")\n            \n            return t_kF + U_val\n\n        def calculate_residuals(self, rho, U_type):\n            \"\"\"Calculates the thermodynamic and single-particle HVH residuals.\"\"\"\n            e = self.energy_per_particle(rho)\n            p = self.pressure(rho)\n            mu = self.chemical_potential(rho)\n            esp_kF = self.sp_energy_kF(rho, U_type)\n\n            # Thermodynamic residual: R_e = mu - (e + p/rho)\n            # This should be numerically zero if thermodynamics are consistent.\n            R_e = mu - (e + p / rho) if rho > 0 else mu - e\n\n            # Single-particle residual: R_sp = mu - esp(kF)\n            R_sp = mu - esp_kF\n            \n            return R_e, R_sp\n\n    # Define the test cases\n    test_cases = [\n        {'id': 'A', 'rho': RHO_0, 'beta': 1.25, 'U_type': 'R'},\n        {'id': 'B', 'rho': RHO_0, 'beta': 1.25, 'U_type': 'noR'},\n        {'id': 'C', 'rho': 1e-3, 'beta': 1.25, 'U_type': 'R'},\n        {'id': 'D', 'rho': RHO_0, 'beta': 0.50, 'U_type': 'noR'},\n    ]\n\n    # Pre-calibrate models for each beta value to avoid redundant calculations\n    model_beta_1_25 = NuclearMatterModel(beta=1.25, g_degen=G_DEGEN, m_n=M_N, hbarc=HBARC)\n    model_beta_1_25.calibrate(RHO_0, E_0)\n\n    model_beta_0_50 = NuclearMatterModel(beta=0.50, g_degen=G_DEGEN, m_n=M_N, hbarc=HBARC)\n    model_beta_0_50.calibrate(RHO_0, E_0)\n    \n    models = {1.25: model_beta_1_25, 0.50: model_beta_0_50}\n\n    results = []\n    for case in test_cases:\n        model = models[case['beta']]\n        Re, Rsp = model.calculate_residuals(case['rho'], case['U_type'])\n        results.extend([Re, Rsp])\n\n    # Format and print the final output as a single line\n    print(f\"[{','.join([f'{x:.6f}' for x in results])}]\")\n\nsolve()\n\n```", "id": "3545559"}]}