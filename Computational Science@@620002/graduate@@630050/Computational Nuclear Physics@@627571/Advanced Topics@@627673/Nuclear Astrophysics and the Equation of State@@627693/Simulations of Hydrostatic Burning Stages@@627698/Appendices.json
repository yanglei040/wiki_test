{"hands_on_practices": [{"introduction": "The foundation of any reliable simulation is its adherence to fundamental physical principles. This first exercise focuses on the core of a nuclear reaction network: its numerical integration and the preservation of conserved quantities. By implementing a simple backward Euler step for a carbon-burning network, you will practice handling stiff equations and, more importantly, verify that your numerical scheme conserves baryon number and charge to machine precision, a critical validation step for any physics code [@problem_id:3590327].", "problem": "You are to implement a single implicit step for a reduced hydrostatic carbon-burning network and then quantify how well the step preserves the linear conservation constraints of baryon number and electric charge. Use the number abundance formalism, where the abundance of nuclide $i$ is $Y_i \\equiv n_i/(\\rho N_A)$, with $n_i$ the number density, $\\rho$ the mass density, and $N_A$ the Avogadro number. In this formalism, baryon number conservation requires $\\sum_i A_i Y_i = 1$, and, in the absence of weak interactions, charge conservation requires $\\sum_i Z_i Y_i = Y_e$, where $A_i$ and $Z_i$ are mass and proton numbers, respectively, and $Y_e$ is the electron fraction.\n\nConsider the single entrance channel $^{12}\\mathrm{C}+{}^{12}\\mathrm{C}$ with three exit branches:\n- $^{12}\\mathrm{C}+{}^{12}\\mathrm{C}\\rightarrow{}^{20}\\mathrm{Ne}+\\alpha$ with branching fraction $b_\\alpha$,\n- $^{12}\\mathrm{C}+{}^{12}\\mathrm{C}\\rightarrow{}^{23}\\mathrm{Na}+\\mathrm{p}$ with branching fraction $b_p$,\n- $^{12}\\mathrm{C}+{}^{12}\\mathrm{C}\\rightarrow{}^{24}\\mathrm{Mg}+\\gamma$ with branching fraction $b_\\gamma$,\nwith $b_\\alpha+b_p+b_\\gamma=1$. Let the species set be $i\\in\\{^{12}\\mathrm{C},^{20}\\mathrm{Ne},^{23}\\mathrm{Na},^{24}\\mathrm{Mg},\\alpha,\\mathrm{p}\\}$, with $(A,Z)$ equal to $(12,6)$, $(20,10)$, $(23,11)$, $(24,12)$, $(4,2)$, and $(1,1)$, respectively.\n\nAssume hydrostatic conditions with constant $\\rho$ and temperature $T$. The rate law for identical reactants in the $Y$-formalism gives the system of ordinary differential equations (ODEs):\n- $\\dfrac{dY_{^{12}\\mathrm{C}}}{dt} = - k(T,\\rho)\\, Y_{^{12}\\mathrm{C}}^2$,\n- $\\dfrac{dY_{^{20}\\mathrm{Ne}}}{dt} = \\dfrac{1}{2} b_\\alpha\\, k(T,\\rho)\\, Y_{^{12}\\mathrm{C}}^2$,\n- $\\dfrac{dY_{\\alpha}}{dt} = \\dfrac{1}{2} b_\\alpha\\, k(T,\\rho)\\, Y_{^{12}\\mathrm{C}}^2$,\n- $\\dfrac{dY_{^{23}\\mathrm{Na}}}{dt} = \\dfrac{1}{2} b_p\\, k(T,\\rho)\\, Y_{^{12}\\mathrm{C}}^2$,\n- $\\dfrac{dY_{\\mathrm{p}}}{dt} = \\dfrac{1}{2} b_p\\, k(T,\\rho)\\, Y_{^{12}\\mathrm{C}}^2$,\n- $\\dfrac{dY_{^{24}\\mathrm{Mg}}}{dt} = \\dfrac{1}{2} b_\\gamma\\, k(T,\\rho)\\, Y_{^{12}\\mathrm{C}}^2$,\nwhere the specific rate $k(T,\\rho)$ is the combination $k(T,\\rho)=\\rho\\, \\mathcal{R}(T_9)$ with $T_9 \\equiv T/(10^9\\,\\mathrm{K})$ and $\\mathcal{R}(T_9)$ the commonly tabulated molar rate coefficient $N_A\\langle \\sigma v \\rangle$ in $\\mathrm{cm^3\\,mol^{-1}\\,s^{-1}}$. For this problem, take the well-tested Caughlan and Fowler 1988 (CF88) style fit\n$$\n\\mathcal{R}(T_9)= 4.27\\times 10^{26}\\, T_9^{-2/3}\\, \\exp\\!\\left(-\\dfrac{84.165}{T_9^{1/3}} - 2.12\\times 10^{-3}\\, T_9^2\\right)\\,\n\\left[1 + 0.0489\\,T_9^{1/3} + 0.265\\,T_9^{2/3} + 0.270\\,T_9 + 0.017\\,T_9^{4/3} + 0.330\\,T_9^{5/3}\\right].\n$$\n\nAdvance the system by a single backward Euler step of size $\\Delta t$:\n$$\nY_i^{n+1} = Y_i^{n} + \\Delta t\\, \\left.\\dfrac{dY_i}{dt}\\right|_{Y^{n+1}},\n$$\nstarting from initial state with mass fraction $X_{^{12}\\mathrm{C}}^0=1$ and all others zero. Recall the relation $X_i = A_i Y_i$ so that $Y_{^{12}\\mathrm{C}}^0=1/12$ and $Y_e^0=\\sum_i Z_i Y_i^0 = 1/2$. You may solve the scalar implicit equation for $Y_{^{12}\\mathrm{C}}^{n+1}$ by any correct method; compute the products using the backward Euler right-hand side evaluated at $Y_{^{12}\\mathrm{C}}^{n+1}$.\n\nAfter the implicit step, compute the absolute conservation residuals\n$$\nr_A = \\left|\\sum_i A_i Y_i^{n+1} - 1\\right|,\\qquad\nr_Z = \\left|\\sum_i Z_i Y_i^{n+1} - Y_e^0\\right|.\n$$\nBased on floating-point roundoff analysis and scale considerations, propose absolute tolerances $\\tau_A$ and $\\tau_Z$ that are sufficient to assert physical fidelity of conservation for this step. Your proposal should combine a multiple of machine epsilon with a minimal engineering floor to accommodate summation error, and may be a fixed value across the test suite.\n\nImplement a program that, for each test case below, performs one backward Euler step and outputs, in order, the $4$-tuple $(r_A,r_Z,\\tau_A,\\tau_Z)$ as floats. Aggregate all cases into a single flat list in the required output format.\n\nUnits and constants:\n- Use $\\rho$ in $\\mathrm{g\\,cm^{-3}}$, $T_9$ dimensionless, and $\\Delta t$ in $\\mathrm{s}$.\n- Abundances $Y_i$, electron fraction $Y_e$, and residuals $r_A$, $r_Z$ are dimensionless.\n\nTest suite (each case specifies $(T_9,\\rho,\\Delta t)$ and a common branching $(b_\\alpha,b_p,b_\\gamma)$):\n- Case $1$: $(T_9=\\;0.8,\\;\\rho=\\;10^9\\;\\mathrm{g\\,cm^{-3}},\\;\\Delta t=\\;10^{-4}\\;\\mathrm{s})$, $(b_\\alpha=\\;0.60,\\;b_p=\\;0.39,\\;b_\\gamma=\\;0.01)$.\n- Case $2$: $(T_9=\\;0.8,\\;\\rho=\\;10^9\\;\\mathrm{g\\,cm^{-3}},\\;\\Delta t=\\;0\\;\\mathrm{s})$, $(b_\\alpha=\\;0.60,\\;b_p=\\;0.39,\\;b_\\gamma=\\;0.01)$.\n- Case $3$: $(T_9=\\;1.0,\\;\\rho=\\;2\\times 10^9\\;\\mathrm{g\\,cm^{-3}},\\;\\Delta t=\\;1\\;\\mathrm{s})$, $(b_\\alpha=\\;0.60,\\;b_p=\\;0.39,\\;b_\\gamma=\\;0.01)$.\n- Case $4$: $(T_9=\\;0.5,\\;\\rho=\\;10^8\\;\\mathrm{g\\,cm^{-3}},\\;\\Delta t=\\;10^3\\;\\mathrm{s})$, $(b_\\alpha=\\;0.60,\\;b_p=\\;0.39,\\;b_\\gamma=\\;0.01)$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order\n$[r_A^{(1)},r_Z^{(1)},\\tau_A^{(1)},\\tau_Z^{(1)},r_A^{(2)},r_Z^{(2)},\\tau_A^{(2)},\\tau_Z^{(2)},r_A^{(3)},r_Z^{(3)},\\tau_A^{(3)},\\tau_Z^{(3)},r_A^{(4)},r_Z^{(4)},\\tau_A^{(4)},\\tau_Z^{(4)}]$.\nAll numbers are to be printed as plain floats (in decimal or scientific notation). Residuals $r_A$ and $r_Z$ are dimensionless, and the tolerances $\\tau_A$ and $\\tau_Z$ are dimensionless absolute tolerances.", "solution": "The problem statement is assessed to be **valid**. It is scientifically grounded in the established principles of nuclear astrophysics and reaction network theory. The problem is well-posed, providing a complete and self-consistent set of definitions, physical constants, initial conditions, and governing equations necessary to determine a unique solution. The scenario of carbon burning under hydrostatic conditions is a standard and physically realistic problem in computational astrophysics. The numerical task, involving a backward Euler integration step for a stiff system and the subsequent verification of conservation laws, is a relevant and non-trivial exercise in scientific computing.\n\nThe core of this problem is to model a simplified reaction network for hydrostatic carbon burning. The species involved are $i\\in\\{^{12}\\mathrm{C},^{20}\\mathrm{Ne},^{23}\\mathrm{Na},^{24}\\mathrm{Mg},\\alpha,\\mathrm{p}\\}$. The process is initiated by the $^{12}\\mathrm{C}+{}^{12}\\mathrm{C}$ fusion reaction, which branches into three distinct channels. The evolution of the species abundances $Y_i$ is described by a system of coupled ordinary differential equations (ODEs). For a generic species $j$, its rate of change is given by:\n$$\n\\frac{dY_j}{dt} = f_j(Y_{^{12}\\mathrm{C}}) = c_j \\, k(T,\\rho)\\, Y_{^{12}\\mathrm{C}}^2\n$$\nwhere $k(T,\\rho)$ is the reaction rate coefficient and $c_j$ is a stoichiometric coefficient. Specifically, $c_{^{12}\\mathrm{C}} = -1$, $c_{^{20}\\mathrm{Ne}} = c_{\\alpha} = \\frac{1}{2}b_\\alpha$, $c_{^{23}\\mathrm{Na}} = c_{\\mathrm{p}} = \\frac{1}{2}b_p$, and $c_{^{24}\\mathrm{Mg}} = \\frac{1}{2}b_\\gamma$. The factor of $\\frac{1}{2}$ for product formation arises from the reaction rate definition for identical reactants.\n\nTwo fundamental physical laws must be conserved: baryon number and electric charge. In the number abundance formalism, these are expressed as linear constraints on the abundances:\n$$\n\\sum_i A_i Y_i = 1 \\quad (\\text{Baryon Number Conservation})\n$$\n$$\n\\sum_i Z_i Y_i = Y_e \\quad (\\text{Charge Conservation})\n$$\nwhere $A_i$ and $Z_i$ are the mass number and proton number of nuclide $i$, respectively, and $Y_e$ is the electron fraction. The stoichiometry of the given nuclear reactions is balanced with respect to both $A_i$ and $Z_i$. For example, for the alpha channel, $2 A_{^{12}\\mathrm{C}} = A_{^{20}\\mathrm{Ne}} + A_{\\alpha}$ and $2 Z_{^{12}\\mathrm{C}} = Z_{^{20}\\mathrm{Ne}} + Z_{\\alpha}$. A key consequence is that the ODE system possesses linear invariants. Differentiating the conservation sums with respect to time yields:\n$$\n\\frac{d}{dt} \\sum_i A_i Y_i = \\sum_i A_i \\frac{dY_i}{dt} = k Y_{^{12}\\mathrm{C}}^2 \\sum_i A_i c_i = k Y_{^{12}\\mathrm{C}}^2 \\left( -A_{^{12}\\mathrm{C}} + \\sum_{\\text{products } j} A_j c_j \\right)\n$$\nUsing the stoichiometric relations and the fact that $b_\\alpha+b_p+b_\\gamma=1$, the term in the parenthesis evaluates to zero. Thus, $\\frac{d}{dt}\\sum_i A_i Y_i = 0$. An identical argument shows $\\frac{d}{dt}\\sum_i Z_i Y_i = 0$. Consequently, an exact solution to the ODE system perfectly conserves baryon number and charge.\n\nThe problem requires advancing the system from an initial state $Y^n$ to a new state $Y^{n+1}$ over a time step $\\Delta t$ using the implicit backward Euler method:\n$$\nY_i^{n+1} = Y_i^{n} + \\Delta t\\, \\left.\\dfrac{dY_i}{dt}\\right|_{Y^{n+1}} = Y_i^{n} + \\Delta t\\, c_i\\, k\\, (Y_{^{12}\\mathrm{C}}^{n+1})^2\n$$\nFor $^{12}\\mathrm{C}$ ($c_{^{12}\\mathrm{C}}=-1$), this becomes a non-linear algebraic equation for $Y_{^{12}\\mathrm{C}}^{n+1}$:\n$$\nY_{^{12}\\mathrm{C}}^{n+1} = Y_{^{12}\\mathrm{C}}^{n} - \\Delta t\\, k\\, (Y_{^{12}\\mathrm{C}}^{n+1})^2\n$$\nRearranging gives a standard quadratic equation for $y \\equiv Y_{^{12}\\mathrm{C}}^{n+1}$:\n$$\n(\\Delta t\\,k) y^2 + y - Y_{^{12}\\mathrm{C}}^{n} = 0\n$$\nThe physically meaningful solution must be positive, which corresponds to the root:\n$$\nY_{^{12}\\mathrm{C}}^{n+1} = \\frac{-1 + \\sqrt{1 + 4\\,\\Delta t\\,k\\,Y_{^{12}\\mathrm{C}}^{n}}}{2\\,\\Delta t\\,k}\n$$\nFor small values of the dimensionless parameter $\\Delta t\\,k\\,Y_{^{12}\\mathrm{C}}^{n}$, this formula is susceptible to catastrophic cancellation. A numerically stable alternative form, derived by rationalizing the numerator, is used for implementation:\n$$\nY_{^{12}\\mathrm{C}}^{n+1} = \\frac{2\\,Y_{^{12}\\mathrm{C}}^{n}}{1 + \\sqrt{1 + 4\\,\\Delta t\\,k\\,Y_{^{12}\\mathrm{C}}^{n}}}\n$$\nOnce $Y_{^{12}\\mathrm{C}}^{n+1}$ is found, the abundances of all product species can be computed explicitly.\n\nA crucial feature of the backward Euler method is that it exactly preserves the linear invariants of the ODE system. To demonstrate this, let $\\delta_Y \\equiv \\Delta t\\,k\\,(Y_{^{12}\\mathrm{C}}^{n+1})^2$. The update equations are $Y_{^{12}\\mathrm{C}}^{n+1} = Y_{^{12}\\mathrm{C}}^{n} - \\delta_Y$ and $Y_{j}^{n+1} = Y_{j}^{n} + c_j \\delta_Y$ for products $j$. Summing the baryon conservation law over all species at step $n+1$:\n$$\n\\sum_i A_i Y_i^{n+1} = A_{^{12}\\mathrm{C}}Y_{^{12}\\mathrm{C}}^{n+1} + \\sum_{\\text{products } j} A_j Y_j^{n+1}\n= A_{^{12}\\mathrm{C}}(Y_{^{12}\\mathrm{C}}^{n} - \\delta_Y) + \\sum_{j} A_j(Y_j^n + c_j \\delta_Y)\n$$\n$$\n= \\left(A_{^{12}\\mathrm{C}}Y_{^{12}\\mathrm{C}}^{n} + \\sum_{j} A_j Y_j^n\\right) - \\delta_Y \\left( A_{^{12}\\mathrm{C}} - \\sum_{j} A_j c_j \\right) = \\sum_i A_i Y_i^n\n$$\nThe term multiplying $\\delta_Y$ is zero due to the same stoichiometric balance demonstrated for the continuous case. Therefore, $\\sum_i A_i Y_i^{n+1} = \\sum_i A_i Y_i^n$. At the start, $\\sum_i A_i Y_i^0 = A_{^{12}\\mathrm{C}} Y_{^{12}\\mathrm{C}}^0 = 12 \\times (1/12) = 1$. The method thus preserves this sum to be exactly $1$. The same holds for charge conservation, where $\\sum_i Z_i Y_i^0 = Z_{^{12}\\mathrm{C}}Y_{^{12}\\mathrm{C}}^0 = 6 \\times (1/12) = 0.5$.\n\nThe conservation residuals are defined as $r_A = |\\sum_i A_i Y_i^{n+1} - 1|$ and $r_Z = |\\sum_i Z_i Y_i^{n+1} - Y_e^0|$. Based on the analysis above, the analytical values of $r_A$ and $r_Z$ are exactly zero. Any non-zero values obtained in a numerical implementation arise solely from floating-point roundoff errors during the computation of the abundances and their weighted sums.\n\nThe absolute tolerances, $\\tau_A$ and $\\tau_Z$, reflect the maximum acceptable numerical error. Given that the conserved quantities $\\sum A_i Y_i$ and $\\sum Z_i Y_i$ are of order $1$ and $0.5$ respectively, the roundoff error is expected to scale with machine epsilon ($\\epsilon_{\\text{mach}} \\approx 2.22 \\times 10^{-16}$ for IEEE 754 double precision). A summation of $N$ floating-point numbers of magnitude $\\mathcal{O}(1)$ can accumulate an error of $\\mathcal{O}(N \\times \\epsilon_{\\text{mach}})$. For our system with $6$ species, a conservative but stringent tolerance is appropriate. We propose a fixed absolute tolerance of $\\tau_A = \\tau_Z = 10^{-14}$. This value is several orders of magnitude larger than machine epsilon, providing a robust floor to account for error accumulation across multiple floating-point operations, while still being small enough to confirm that conservation is maintained to high precision.\n\nThe algorithm proceeds as follows for each test case:\n1.  Calculate the rate coefficient $k(T,\\rho)$ using the provided formula for $\\mathcal{R}(T_9)$.\n2.  Set the initial abundances: $Y_{^{12}\\mathrm{C}}^0 = 1/12$ and all other $Y_i^0 = 0$.\n3.  If $\\Delta t = 0$, the abundances do not change, and the residuals are exactly $0$.\n4.  If $\\Delta t > 0$, compute $Y_{^{12}\\mathrm{C}}^{n+1}$ by solving the quadratic equation using the numerically stable form.\n5.  Compute the new product abundances $Y_{j}^{n+1}$ using the backward Euler formula evaluated with $Y_{^{12}\\mathrm{C}}^{n+1}$.\n6.  Calculate the sums $\\sum_i A_i Y_i^{n+1}$ and $\\sum_i Z_i Y_i^{n+1}$.\n7.  Compute the absolute residuals $r_A$ and $r_Z$ and pair them with the proposed tolerances $\\tau_A$ and $\\tau_Z$.", "answer": "```python\nimport numpy as np\n\ndef calculate_R(T9):\n    \"\"\"\n    Calculates the molar rate coefficient R(T9) using the CF88-style fit.\n    T9 is temperature in 10^9 K.\n    \"\"\"\n    if T9 <= 0:\n        return 0.0\n\n    T9_1_3 = T9**(1.0/3.0)\n    T9_2_3 = T9_1_3**2\n    T9_4_3 = T9_1_3**4\n    T9_5_3 = T9_1_3**5\n\n    poly_term = (1.0 + 0.0489 * T9_1_3 + 0.265 * T9_2_3 + 0.270 * T9 +\n                 0.017 * T9_4_3 + 0.330 * T9_5_3)\n\n    exp_term_val = -84.165 / T9_1_3 - 2.12e-3 * T9**2\n    \n    # Handle potential underflow in exp\n    if exp_term_val < -700: # np.exp(-709) is ~1e-308, below that is 0\n        exp_term = 0.0\n    else:\n        exp_term = np.exp(exp_term_val)\n\n    R = (4.27e26 * T9**(-2.0/3.0) * exp_term * poly_term)\n    return R\n\ndef solve():\n    \"\"\"\n    Main solver function to run test cases and print results.\n    \"\"\"\n    \n    # Species in the network: C-12, Ne-20, Na-23, Mg-24, alpha, proton\n    A_vals = np.array([12, 20, 23, 24, 4, 1], dtype=np.float64)\n    Z_vals = np.array([6, 10, 11, 12, 2, 1], dtype=np.float64)\n\n    # Test cases: (T9, rho, dt, (b_alpha, b_p, b_gamma))\n    test_cases = [\n        (0.8, 1e9, 1e-4, (0.60, 0.39, 0.01)),\n        (0.8, 1e9, 0.0, (0.60, 0.39, 0.01)),\n        (1.0, 2e9, 1.0, (0.60, 0.39, 0.01)),\n        (0.5, 1e8, 1e3, (0.60, 0.39, 0.01)),\n    ]\n\n    results = []\n    \n    # Initial conditions from X_C12 = 1\n    Y0_C12 = 1.0 / A_vals[0]\n    Y0 = np.zeros(len(A_vals), dtype=np.float64)\n    Y0[0] = Y0_C12\n    Ye0 = np.sum(Z_vals * Y0) # = 0.5\n\n    # Proposed absolute tolerances for conservation checks\n    tau_A = 1.0e-14\n    tau_Z = 1.0e-14\n\n    for case in test_cases:\n        T9, rho, dt, (b_alpha, b_p, b_gamma) = case\n        \n        # If timestep is zero, no change occurs.\n        if dt == 0.0:\n            Y1 = Y0.copy()\n        else:\n            # Calculate the rate coefficient k = rho * R(T9)\n            R = calculate_R(T9)\n            k = rho * R\n            # The rate k has units of cm^3 / (g * s)\n\n            # Solve for Y_C12 at step n+1 using the backward Euler method.\n            # This yields a quadratic equation for Y1_C12. We use the\n            # numerically stable solution.\n            arg_sqrt = 1.0 + 4.0 * dt * k * Y0_C12\n            Y1_C12 = (2.0 * Y0_C12) / (1.0 + np.sqrt(arg_sqrt))\n\n            # Calculate the abundances of the products at step n+1\n            dt_k_Y1_C12_sq = dt * k * Y1_C12**2\n            \n            Y1_Ne20 = 0.0 + 0.5 * b_alpha * dt_k_Y1_C12_sq\n            Y1_alpha = 0.0 + 0.5 * b_alpha * dt_k_Y1_C12_sq\n            Y1_Na23 = 0.0 + 0.5 * b_p * dt_k_Y1_C12_sq\n            Y1_p = 0.0 + 0.5 * b_p * dt_k_Y1_C12_sq\n            Y1_Mg24 = 0.0 + 0.5 * b_gamma * dt_k_Y1_C12_sq\n\n            Y1 = np.array([Y1_C12, Y1_Ne20, Y1_Na23, Y1_Mg24, Y1_alpha, Y1_p], dtype=np.float64)\n\n        # Compute conservation sums at step n+1\n        sum_AY1 = np.sum(A_vals * Y1)\n        sum_ZY1 = np.sum(Z_vals * Y1)\n\n        # Compute absolute residuals\n        # Initial baryon number sum is 1.0\n        r_A = np.abs(sum_AY1 - 1.0)\n        # Initial electron fraction is Ye0\n        r_Z = np.abs(sum_ZY1 - Ye0)\n\n        results.extend([r_A, r_Z, tau_A, tau_Z])\n\n    # Print results in the required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3590327"}, {"introduction": "Stellar models depend on thousands of input parameters, many with significant uncertainties. Understanding which parameters most strongly influence the outcomes is a central task of computational astrophysics. This practice introduces forward sensitivity analysis, a powerful technique to quantify the impact of reaction rate uncertainties on nucleosynthetic yields. You will implement this method by differentiating an implicit solver step, providing a direct measure of how the production of $^{28}\\mathrm{Si}$ responds to changes in the crucial $^{12}\\mathrm{C}+^{12}\\mathrm{C}$ reaction rate [@problem_id:3590317].", "problem": "You are tasked with quantifying the first-order sensitivity of the final molar abundance of silicon-$28$ ($^{28}\\mathrm{Si}$) to a fractional perturbation in the carbon-carbon reaction rate during a single stiff solver step in hydrostatic carbon burning. Consider a reduced, scientifically plausible reaction network with species $^{12}\\mathrm{C}$, $^{20}\\mathrm{Ne}$, $^{24}\\mathrm{Mg}$, $^{28}\\mathrm{Si}$, and $^{4}\\mathrm{He}$ (alpha). Work under hydrostatic conditions at fixed temperature and density, and assume constant thermally averaged reaction rates over the solver step.\n\nFundamental base and core definitions:\n- The system evolves according to an Ordinary Differential Equation (ODE): $\\frac{d\\boldsymbol{Y}}{dt} = \\boldsymbol{f}(\\boldsymbol{Y}; \\rho, R_1, R_2, R_3)$, where $\\boldsymbol{Y} = (Y_{\\mathrm{C}}, Y_{\\mathrm{Ne}}, Y_{\\mathrm{Mg}}, Y_{\\mathrm{Si}}, Y_{\\alpha})$ are molar abundances per baryon, $\\rho$ is the mass density, and $R_i$ denote reaction rates $R \\equiv N_A \\langle \\sigma v \\rangle$ with units $\\mathrm{cm}^3\\,\\mathrm{s}^{-1}\\,\\mathrm{mol}^{-1}$, where $N_A$ is Avogadro's number and $\\langle \\sigma v \\rangle$ is the thermally averaged cross section.\n- Use mass-action kinetics for two-body reactions. For reaction $a+b \\rightarrow \\cdots$, the per-baryon reaction rate is $\\rho R Y_a Y_b$. For identical reactants $a+a$, the per-baryon reaction rate is $\\frac{1}{2}\\rho R Y_a^2$, and the consumption of $a$ is twice that rate.\n- The reaction network:\n  1. $^{12}\\mathrm{C} + ^{12}\\mathrm{C} \\rightarrow ^{20}\\mathrm{Ne} + \\alpha$ with rate $R_1$.\n  2. $^{20}\\mathrm{Ne} + \\alpha \\rightarrow ^{24}\\mathrm{Mg} + \\gamma$ with rate $R_2$.\n  3. $^{24}\\mathrm{Mg} + \\alpha \\rightarrow ^{28}\\mathrm{Si} + \\gamma$ with rate $R_3$.\n- Define the scalar reaction flows at state $\\boldsymbol{Y}$:\n  $$r_1 = \\frac{1}{2}\\rho R_1 Y_{\\mathrm{C}}^2,\\quad r_2 = \\rho R_2 Y_{\\mathrm{Ne}} Y_{\\alpha},\\quad r_3 = \\rho R_3 Y_{\\mathrm{Mg}} Y_{\\alpha}.$$\n- The ODE components are then:\n  $$\\frac{dY_{\\mathrm{C}}}{dt} = -2 r_1,$$\n  $$\\frac{dY_{\\mathrm{Ne}}}{dt} = r_1 - r_2,$$\n  $$\\frac{dY_{\\mathrm{Mg}}}{dt} = r_2 - r_3,$$\n  $$\\frac{dY_{\\mathrm{Si}}}{dt} = r_3,$$\n  $$\\frac{dY_{\\alpha}}{dt} = r_1 - r_2 - r_3.$$\n\nStiff solver step:\n- Advance $\\boldsymbol{Y}$ from time $t_n$ to $t_{n+1} = t_n + \\Delta t$ using the Backward Differentiation Formula of order $1$ (BDF1, also known as backward Euler): solve\n  $$\\boldsymbol{G}(\\boldsymbol{Y}_{n+1}) \\equiv \\boldsymbol{Y}_{n+1} - \\boldsymbol{Y}_n - \\Delta t\\,\\boldsymbol{f}(\\boldsymbol{Y}_{n+1}) = \\boldsymbol{0}.$$\n- Let $R_1$ be perturbed fractionally, $R_1 \\mapsto (1+\\epsilon)R_1$ with small $\\epsilon$. Compute the first-order change in the final silicon-$28$ abundance $Y_{\\mathrm{Si}, n+1}$ due to this perturbation via implicit differentiation of the stiff step:\n  $$\\left[\\boldsymbol{I} - \\Delta t\\,\\boldsymbol{J}_f(\\boldsymbol{Y}_{n+1})\\right]\\boldsymbol{s} = \\Delta t\\,\\frac{\\partial \\boldsymbol{f}}{\\partial \\epsilon}(\\boldsymbol{Y}_{n+1}),$$\n  where $\\boldsymbol{J}_f(\\boldsymbol{Y}) = \\frac{\\partial \\boldsymbol{f}}{\\partial \\boldsymbol{Y}}$ is the Jacobian matrix of $\\boldsymbol{f}$ and $\\boldsymbol{s} = \\frac{d\\boldsymbol{Y}_{n+1}}{d\\epsilon}\\big|_{\\epsilon=0}$ is the sensitivity vector. The desired quantity is the first-order change $\\delta Y_{\\mathrm{Si}} = s_{\\mathrm{Si}}\\,\\epsilon$.\n- For this network, the partial derivative $\\frac{\\partial \\boldsymbol{f}}{\\partial \\epsilon}$ arises only through $r_1$ and satisfies\n  $$\\frac{\\partial r_1}{\\partial \\epsilon} = \\frac{1}{2}\\rho R_1 Y_{\\mathrm{C}}^2,$$\n  so\n  $$\\frac{\\partial \\boldsymbol{f}}{\\partial \\epsilon} = \\left(-\\rho R_1 Y_{\\mathrm{C}}^2,\\; \\frac{1}{2}\\rho R_1 Y_{\\mathrm{C}}^2,\\; 0,\\; 0,\\; \\frac{1}{2}\\rho R_1 Y_{\\mathrm{C}}^2\\right)^\\top,$$\n  evaluated at $\\boldsymbol{Y}_{n+1}$.\n\nPhysical and numerical parameters:\n- Use mass density $\\rho = 10^6$ g/cm$^3$.\n- Use reaction rates $R_1 = 10^{-7}$, $R_2 = 10^{-5}$, $R_3 = 5\\times 10^{-6}$, all in $\\mathrm{cm}^3\\,\\mathrm{s}^{-1}\\,\\mathrm{mol}^{-1}$.\n- Molar abundances are $Y_i = X_i/A_i$, where $X_i$ is the mass fraction and $A_i$ is the mass number. These $Y_i$ are dimensionless per baryon.\n\nAlgorithmic requirements:\n- Implement a Newton-Raphson solver for the BDF1 step by solving $\\boldsymbol{G}(\\boldsymbol{Y}_{n+1})=\\boldsymbol{0}$ with the analytically derived Jacobian $\\boldsymbol{J}_f(\\boldsymbol{Y})$ and the implicit Jacobian $\\boldsymbol{J}_{\\mathrm{imp}} = \\boldsymbol{I} - \\Delta t\\,\\boldsymbol{J}_f(\\boldsymbol{Y}_{n+1})$. Use damping to maintain nonnegativity of abundances.\n- After obtaining $\\boldsymbol{Y}_{n+1}$ at $\\epsilon=0$, form and solve the linear system for $\\boldsymbol{s}$:\n  $$\\boldsymbol{J}_{\\mathrm{imp}}\\,\\boldsymbol{s} = \\Delta t\\,\\frac{\\partial \\boldsymbol{f}}{\\partial \\epsilon}(\\boldsymbol{Y}_{n+1}).$$\n- Report the first-order change $\\delta Y_{\\mathrm{Si}} = s_{\\mathrm{Si}}\\,\\epsilon$ for each test case. Express the final answer in units of molar abundance (dimensionless), as floating-point numbers.\n\nTest suite:\n- Use the following initial states $\\boldsymbol{Y}_n$, time steps $\\Delta t$, and perturbations $\\epsilon$:\n  1. Case A (happy path): $Y_{\\mathrm{C}} = \\frac{0.5}{12}$, $Y_{\\alpha} = \\frac{0.1}{4}$, $Y_{\\mathrm{Ne}}=0$, $Y_{\\mathrm{Mg}}=0$, $Y_{\\mathrm{Si}}=0$, $\\Delta t = 1000$ s, $\\epsilon = 0.01$.\n  2. Case B (boundary, zero perturbation): same initial state and $\\Delta t$ as Case A, but $\\epsilon = 0$.\n  3. Case C (edge, negligible carbon): $Y_{\\mathrm{C}} = \\frac{10^{-6}}{12}$, $Y_{\\alpha} = \\frac{0.1}{4}$, other species zero, $\\Delta t = 1000$ s, $\\epsilon = 0.05$.\n  4. Case D (edge, very low alpha): $Y_{\\mathrm{C}} = \\frac{0.5}{12}$, $Y_{\\alpha} = \\frac{10^{-6}}{4}$, other species zero, $\\Delta t = 1000$ s, $\\epsilon = 0.2$.\n  5. Case E (stiff, large step): $Y_{\\mathrm{C}} = \\frac{0.5}{12}$, $Y_{\\alpha} = \\frac{0.1}{4}$, other species zero, $\\Delta t = 10^5$ s, $\\epsilon = 0.01$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3]\"). The list must contain the five floating-point values $\\delta Y_{\\mathrm{Si}}$ corresponding to the five cases above, in the same order.", "solution": "The problem is assessed to be **valid**. It is a well-posed, scientifically grounded problem in computational nuclear astrophysics that is internally consistent and provides all necessary data for a unique solution. The task requires the implementation of standard, robust numerical methods (Backward Euler, Newton-Raphson) and sensitivity analysis techniques (implicit differentiation) applied to a simplified but physically plausible stellar reaction network.\n\nThe solution proceeds in two main stages: first, numerically solving for the evolution of species abundances over a single stiff time step, and second, calculating the first-order sensitivity of the final silicon abundance to a perturbation in a key reaction rate.\n\n### 1. Stiff Time Step with Backward Euler (BDF1)\n\nThe evolution of the molar abundance vector $\\boldsymbol{Y} = (Y_{\\mathrm{C}}, Y_{\\mathrm{Ne}}, Y_{\\mathrm{Mg}}, Y_{\\mathrm{Si}}, Y_{\\alpha})^\\top$ is governed by the system of ordinary differential equations (ODEs) $\\frac{d\\boldsymbol{Y}}{dt} = \\boldsymbol{f}(\\boldsymbol{Y})$. The components of $\\boldsymbol{f}(\\boldsymbol{Y})$ are defined by the reaction flows $r_1, r_2, r_3$:\n$$r_1 = \\frac{1}{2}\\rho R_1 Y_{\\mathrm{C}}^2$$\n$$r_2 = \\rho R_2 Y_{\\mathrm{Ne}} Y_{\\alpha}$$\n$$r_3 = \\rho R_3 Y_{\\mathrm{Mg}} Y_{\\alpha}$$\nThe ODE system is:\n$$\\boldsymbol{f}(\\boldsymbol{Y}) = \\begin{pmatrix} -2 r_1 \\\\ r_1 - r_2 \\\\ r_2 - r_3 \\\\ r_3 \\\\ r_1 - r_2 - r_3 \\end{pmatrix}$$\n\nTo advance the system from time $t_n$ to $t_{n+1} = t_n + \\Delta t$, we use the first-order Backward Differentiation Formula (BDF1), also known as the backward Euler method. This implicit method is suitable for stiff systems. It requires solving the following nonlinear system of algebraic equations for the unknown state $\\boldsymbol{Y}_{n+1}$:\n$$\\boldsymbol{G}(\\boldsymbol{Y}_{n+1}) \\equiv \\boldsymbol{Y}_{n+1} - \\boldsymbol{Y}_n - \\Delta t\\,\\boldsymbol{f}(\\boldsymbol{Y}_{n+1}) = \\boldsymbol{0}$$\nwhere $\\boldsymbol{Y}_n$ is the known state at the beginning of the step.\n\nThis nonlinear system is solved using the Newton-Raphson method. Starting with an initial guess (e.g., $\\boldsymbol{Y}_{n+1}^{(0)} = \\boldsymbol{Y}_n$), we iteratively refine the solution via:\n$$\\boldsymbol{Y}_{n+1}^{(k+1)} = \\boldsymbol{Y}_{n+1}^{(k)} - [\\boldsymbol{J}_G(\\boldsymbol{Y}_{n+1}^{(k)})]^{-1} \\boldsymbol{G}(\\boldsymbol{Y}_{n+1}^{(k)})$$\nwhere $\\boldsymbol{J}_G$ is the Jacobian of $\\boldsymbol{G}$ with respect to $\\boldsymbol{Y}_{n+1}$. This implicit Jacobian is given by:\n$$\\boldsymbol{J}_G(\\boldsymbol{Y}) = \\frac{\\partial \\boldsymbol{G}}{\\partial \\boldsymbol{Y}} = \\boldsymbol{I} - \\Delta t\\,\\frac{\\partial \\boldsymbol{f}}{\\partial \\boldsymbol{Y}} = \\boldsymbol{I} - \\Delta t\\,\\boldsymbol{J}_f(\\boldsymbol{Y})$$\nHere, $\\boldsymbol{I}$ is the identity matrix and $\\boldsymbol{J}_f(\\boldsymbol{Y})$ is the Jacobian of the ODE function $\\boldsymbol{f}$. The analytical Jacobian $\\boldsymbol{J}_f$ is computed as:\n$$ \\boldsymbol{J}_f(\\boldsymbol{Y}) = \\rho \\begin{pmatrix}\n-2 R_1 Y_C & 0 & 0 & 0 & 0 \\\\\nR_1 Y_C & -R_2 Y_\\alpha & 0 & 0 & -R_2 Y_{Ne} \\\\\n0 & R_2 Y_\\alpha & -R_3 Y_\\alpha & 0 & R_2 Y_{Ne} - R_3 Y_{Mg} \\\\\n0 & 0 & R_3 Y_\\alpha & 0 & R_3 Y_{Mg} \\\\\nR_1 Y_C & -R_2 Y_\\alpha & -R_3 Y_\\alpha & 0 & -R_2 Y_{Ne} - R_3 Y_{Mg}\n\\end{pmatrix} $$\nThe iteration involves solving the linear system $\\boldsymbol{J}_G \\Delta \\boldsymbol{Y} = -\\boldsymbol{G}$ for the correction $\\Delta \\boldsymbol{Y}$. Damping is applied to the update step to ensure that all abundances remain non-negative, a crucial physical constraint. The iteration continues until the norm of the residual vector $\\boldsymbol{G}$ falls below a specified tolerance.\n\n### 2. First-Order Sensitivity Analysis\n\nAfter obtaining the converged state $\\boldsymbol{Y}_{n+1}$, we compute the sensitivity of this final state to a fractional perturbation in the rate $R_1$, defined by $R_1 \\mapsto R_1(1+\\epsilon)$. The sensitivity vector, $\\boldsymbol{s} = \\frac{d\\boldsymbol{Y}_{n+1}}{d\\epsilon}\\big|_{\\epsilon=0}$, is found by differentiating the BDF1 equation with respect to $\\epsilon$ and evaluating at $\\epsilon=0$:\n$$\\frac{d\\boldsymbol{G}}{d\\epsilon} = \\frac{\\partial \\boldsymbol{G}}{\\partial \\boldsymbol{Y}_{n+1}} \\frac{d\\boldsymbol{Y}_{n+1}}{d\\epsilon} + \\frac{\\partial \\boldsymbol{G}}{\\partial \\epsilon} = \\boldsymbol{0}$$\nRearranging gives the linear system for $\\boldsymbol{s}$:\n$$[\\boldsymbol{I} - \\Delta t\\,\\boldsymbol{J}_f(\\boldsymbol{Y}_{n+1})]\\boldsymbol{s} = \\Delta t\\,\\frac{\\partial \\boldsymbol{f}}{\\partial \\epsilon}(\\boldsymbol{Y}_{n+1})$$\nThe matrix on the left-hand side is precisely the implicit Jacobian $\\boldsymbol{J}_G$ evaluated at the converged solution $\\boldsymbol{Y}_{n+1}$, which was already computed in the final step of the Newton-Raphson solver.\n\nThe right-hand side vector depends on the partial derivative of $\\boldsymbol{f}$ with respect to $\\epsilon$. Since only $R_1$ is perturbed, this derivative arises only from the dependence of the flow $r_1$ on $\\epsilon$:\n$$\\frac{\\partial r_1}{\\partial \\epsilon} = \\frac{\\partial}{\\partial \\epsilon}\\left(\\frac{1}{2}\\rho R_1(1+\\epsilon) Y_C^2\\right) = \\frac{1}{2}\\rho R_1 Y_C^2$$\nTherefore, the source term for the sensitivity equation is:\n$$\\frac{\\partial \\boldsymbol{f}}{\\partial \\epsilon}(\\boldsymbol{Y}_{n+1}) = \\left(-\\rho R_1 Y_{\\mathrm{C}, n+1}^2,\\; \\frac{1}{2}\\rho R_1 Y_{\\mathrm{C}, n+1}^2,\\; 0,\\; 0,\\; \\frac{1}{2}\\rho R_1 Y_{\\mathrm{C}, n+1}^2\\right)^\\top$$\nBy solving the linear system $\\boldsymbol{J}_G(\\boldsymbol{Y}_{n+1})\\,\\boldsymbol{s} = \\Delta t\\,\\frac{\\partial \\boldsymbol{f}}{\\partial \\epsilon}(\\boldsymbol{Y}_{n+1})$ for $\\boldsymbol{s}$, we obtain the sensitivities of all species. The desired quantity is the first-order change in the silicon abundance, which is given by:\n$$\\delta Y_{\\mathrm{Si}} = s_{\\mathrm{Si}}\\,\\epsilon$$\nwhere $s_{\\mathrm{Si}}$ is the component of $\\boldsymbol{s}$ corresponding to $^{28}\\mathrm{Si}$. This procedure is applied for each test case to generate the final results.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the first-order sensitivity of the final 28Si abundance \n    to a perturbation in the 12C+12C reaction rate for five test cases.\n    \"\"\"\n    # Physical constants\n    RHO = 1e6  # g/cm^3\n    R1 = 1e-7  # cm^3 s^-1 mol^-1\n    R2 = 1e-5  # cm^3 s^-1 mol^-1\n    R3 = 5e-6  # cm^3 s^-1 mol^-1\n\n    # Indices for species in the abundance vector Y\n    C, NE, MG, SI, ALPHA = 0, 1, 2, 3, 4\n\n    def f_ode(Y):\n        \"\"\"Computes the RHS of the ODE system, dy/dt = f(Y).\"\"\"\n        YC, YNe, YMg, _, YAlpha = Y\n        \n        # Ensure non-negativity for physical rates\n        YC = max(0, YC)\n        YNe = max(0, YNe)\n        YMg = max(0, YMg)\n        YAlpha = max(0, YAlpha)\n        \n        r1 = 0.5 * RHO * R1 * YC**2\n        r2 = RHO * R2 * YNe * YAlpha\n        r3 = RHO * R3 * YMg * YAlpha\n        \n        dYdt = np.zeros(5)\n        dYdt[C] = -2 * r1\n        dYdt[NE] = r1 - r2\n        dYdt[MG] = r2 - r3\n        dYdt[SI] = r3\n        dYdt[ALPHA] = r1 - r2 - r3\n        \n        return dYdt\n\n    def jacobian_f(Y):\n        \"\"\"Computes the analytical Jacobian of the ODE function f(Y).\"\"\"\n        YC, YNe, YMg, _, YAlpha = Y\n\n        # Ensure non-negativity\n        YC = max(0, YC)\n        YNe = max(0, YNe)\n        YMg = max(0, YMg)\n        YAlpha = max(0, YAlpha)\n\n        J = np.zeros((5, 5))\n        \n        # Derivatives w.r.t Y_C (column 0)\n        J[C, C] = -2 * RHO * R1 * YC\n        J[NE, C] = RHO * R1 * YC\n        J[ALPHA, C] = RHO * R1 * YC\n        \n        # Derivatives w.r.t Y_Ne (column 1)\n        J[NE, NE] = -RHO * R2 * YAlpha\n        J[MG, NE] = RHO * R2 * YAlpha\n        J[ALPHA, NE] = -RHO * R2 * YAlpha\n        \n        # Derivatives w.r.t Y_Mg (column 2)\n        J[MG, MG] = -RHO * R3 * YAlpha\n        J[SI, MG] = RHO * R3 * YAlpha\n        J[ALPHA, MG] = -RHO * R3 * YAlpha\n        \n        # Derivatives w.r.t Y_Si (column 3) are all zero\n        \n        # Derivatives w.r.t Y_alpha (column 4)\n        J[NE, ALPHA] = -RHO * R2 * YNe\n        J[MG, ALPHA] = RHO * R2 * YNe - RHO * R3 * YMg\n        J[SI, ALPHA] = RHO * R3 * YMg\n        J[ALPHA, ALPHA] = -RHO * R2 * YNe - RHO * R3 * YMg\n        \n        return J\n\n    def run_case(Y_n, dt, epsilon):\n        \"\"\"Solves one BDF1 step and computes the required sensitivity.\"\"\"\n        \n        # --- Stage 1: Solve for Y_n+1 using Newton-Raphson ---\n        Y_np1 = np.copy(Y_n)\n        tol = 1e-12\n        max_iter = 50\n\n        for _ in range(max_iter):\n            G = Y_np1 - Y_n - dt * f_ode(Y_np1)\n            \n            if np.linalg.norm(G) < tol:\n                break\n            \n            J_imp = np.identity(5) - dt * jacobian_f(Y_np1)\n            \n            try:\n                dY = np.linalg.solve(J_imp, -G)\n            except np.linalg.LinAlgError:\n                # If Jacobian is singular, we cannot proceed.\n                # This may happen if the state is pathological.\n                # For this problem set, we assume it does not occur.\n                dY = np.zeros_like(Y_n)\n\n            # Damping to maintain non-negativity\n            lambda_ = 1.0\n            Y_trial = Y_np1 + lambda_ * dY\n            # Repeatedly halve lambda if any component becomes negative\n            while np.any(Y_trial < 0):\n                lambda_ /= 2.0\n                Y_trial = Y_np1 + lambda_ * dY\n                if lambda_ < 1e-8: # Failsafe\n                    dY = np.zeros_like(Y_n)\n                    break\n            \n            Y_np1 += lambda_ * dY\n\n        # --- Stage 2: Sensitivity Analysis ---\n        if epsilon == 0:\n            return 0.0\n\n        # Right-hand side of sensitivity equation: b = dt * (df/d_epsilon)\n        df_deps = np.zeros(5)\n        # Term arising from d(r1)/d(epsilon)\n        r1_pert_term = 0.5 * RHO * R1 * max(0, Y_np1[C])**2\n        \n        df_deps[C] = -2 * r1_pert_term\n        df_deps[NE] = r1_pert_term\n        df_deps[ALPHA] = r1_pert_term\n        \n        b = dt * df_deps\n        \n        # Matrix is the implicit Jacobian from the final Newton step\n        J_imp_final = np.identity(5) - dt * jacobian_f(Y_np1)\n        \n        try:\n            s = np.linalg.solve(J_imp_final, b)\n        except np.linalg.LinAlgError:\n            s = np.zeros_like(Y_n)\n\n        # First-order change = s_Si * epsilon\n        delta_Y_Si = s[SI] * epsilon\n        \n        return delta_Y_Si\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (happy path)\n        (np.array([0.5/12, 0.0, 0.0, 0.0, 0.1/4]), 1000.0, 0.01),\n        # Case B (boundary, zero perturbation)\n        (np.array([0.5/12, 0.0, 0.0, 0.0, 0.1/4]), 1000.0, 0.0),\n        # Case C (edge, negligible carbon)\n        (np.array([1e-6/12, 0.0, 0.0, 0.0, 0.1/4]), 1000.0, 0.05),\n        # Case D (edge, very low alpha)\n        (np.array([0.5/12, 0.0, 0.0, 0.0, 1e-6/4]), 1000.0, 0.2),\n        # Case E (stiff, large step)\n        (np.array([0.5/12, 0.0, 0.0, 0.0, 0.1/4]), 1e5, 0.01),\n    ]\n\n    results = []\n    for case in test_cases:\n        Yn_case, dt_case, epsilon_case = case\n        result = run_case(Yn_case, dt_case, epsilon_case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3590317"}, {"introduction": "Nuclear reactions not only transmute elements but also release vast amounts of energy, driving stellar evolution. This capstone exercise bridges the gap between microphysical reaction networks and macroscopic thermodynamics. You will simulate a neon-burning stellar zone, coupling the energy generation from nuclear reactions to the star's equation of state under a constant pressure approximation. Your task is to verify one of the most fundamental checks in a simulation: that the total energy generated by the network precisely accounts for the change in the internal energy of the plasma, confirming adherence to the First Law of Thermodynamics [@problem_id:3590315].", "problem": "You are given a simplified, yet scientifically consistent, hydrostatic trajectory model for a single Lagrangian mass zone undergoing neon burning in a massive star. The goal is to verify global energy conservation under an isobaric burning operator by comparing the time-integrated specific nuclear heating minus neutrino cooling to the change in specific internal energy along a constant-pressure path. This verification is performed in the computational nuclear physics context of hydrostatic burning stages.\n\nThe fundamental base consists of the following pillars:\n- The First Law of Thermodynamics for a Lagrangian fluid element: $d u = \\dot{\\epsilon}_{\\mathrm{nuc}}\\,dt - \\epsilon_{\\nu}\\,dt - P\\,d(1/\\rho)$, where $u$ is specific internal energy, $\\dot{\\epsilon}_{\\mathrm{nuc}}$ is nuclear heating per unit mass per unit time, $\\epsilon_{\\nu}$ is specific neutrino cooling per unit time, $P$ is pressure, and $\\rho$ is density.\n- Under an isobaric burning operator applied over short time intervals in a hydrostatic environment, mechanical relaxation is handled separately. Over the burning substep, the mechanical work term $P\\,d(1/\\rho)$ is neglected in the thermal energy update, and the constraint $P=\\mathrm{const}$ is enforced via the Equation of State (EOS). Consequently, the thermal energy update reduces to $d u = \\dot{\\epsilon}_{\\mathrm{nuc}}\\,dt - \\epsilon_{\\nu}\\,dt$, while $\\rho$ follows from the EOS at constant $P$ as the temperature $T$ evolves.\n- The Equation of State (EOS) for a fully ionized ideal gas plus radiation, assuming a constant mean molecular weight per particle $\\mu$ (including ions and electrons), is $P(\\rho,T) = \\rho \\,k_B T / (\\mu m_u) + (1/3)\\,a\\,T^4$, where $k_B$ is Boltzmann’s constant, $m_u$ is the atomic mass unit, and $a$ is the radiation constant. The specific internal energy is $u(\\rho,T) = (3/2)\\,k_B T/(\\mu m_u) + a T^4/\\rho$.\n- The pressure constraint $P=\\mathrm{const}$ provides $\\rho(T)$ implicitly via the EOS: $\\rho(T) = \\alpha \\,[P - (a/3)\\,T^4]/T$, with $\\alpha \\equiv \\mu m_u/k_B$.\n- Nuclear energy generation is represented by a single effective channel with strong temperature dependence: $\\dot{\\epsilon}_{\\mathrm{nuc}}(T,\\rho,X_{\\mathrm{Ne}}) = Q_{\\mathrm{mass}} \\,\\lambda_0\\,\\rho^{\\alpha_\\rho}\\,T_9^{n}\\,\\exp(-T^\\star/T)\\,X_{\\mathrm{Ne}}$, where $Q_{\\mathrm{mass}}$ is the energy released per unit mass of neon consumed, $\\lambda_0$ is a rate coefficient, $\\alpha_\\rho$ is the density exponent, $T_9 \\equiv T/(10^9\\,\\mathrm{K})$, $n$ is a temperature exponent, $T^\\star$ is a characteristic temperature scale, and $X_{\\mathrm{Ne}}$ is the neon mass fraction.\n- Neutrino cooling is dominated by electron-positron pair processes at these temperatures and is approximated by $\\epsilon_{\\nu}(T) = C_\\nu\\,T_9^9$.\n\nYou must write a complete, runnable program that:\n1. Implements the isobaric constraint $P=\\mathrm{const}$ by expressing $\\rho(T)$ from the EOS.\n2. Evolves the temperature $T(t)$ and neon mass fraction $X_{\\mathrm{Ne}}(t)$ using an Ordinary Differential Equation (ODE) system consistent with the reduced First Law $d u/dt = \\dot{\\epsilon}_{\\mathrm{nuc}} - \\epsilon_\\nu$, with $u(\\rho(T),T)$ as defined above.\n3. Integrates the net heating $H(t) \\equiv \\dot{\\epsilon}_{\\mathrm{nuc}}(t) - \\epsilon_\\nu(t)$ over time to obtain $\\int_0^{t_{\\mathrm{end}}} H(t)\\,dt$ while stopping the integration when $X_{\\mathrm{Ne}}$ falls to a specified target $X_{\\mathrm{end}}$.\n4. Computes the change in specific internal energy $\\Delta u = u(\\rho(T_{\\mathrm{end}}),T_{\\mathrm{end}}) - u(\\rho(T_0),T_0)$.\n5. Verifies energy conservation by comparing $\\int_0^{t_{\\mathrm{end}}} H(t)\\,dt$ to $\\Delta u$ and returns a boolean per test case indicating whether the relative discrepancy is within a prescribed tolerance.\n\nAll physical and numerical units must be adhered to:\n- Pressure $P$ in $\\mathrm{dyn}\\,\\mathrm{cm}^{-2}$.\n- Density $\\rho$ in $\\mathrm{g}\\,\\mathrm{cm}^{-3}$.\n- Temperature $T$ in $\\mathrm{K}$.\n- Time $t$ in $\\mathrm{s}$.\n- Specific energy quantities $u$, $\\dot{\\epsilon}_{\\mathrm{nuc}}$, $\\epsilon_\\nu$, and integrals in $\\mathrm{erg}\\,\\mathrm{g}^{-1}$ and $\\mathrm{erg}\\,\\mathrm{g}^{-1}\\,\\mathrm{s}^{-1}$.\n- The mean molecular weight $\\mu$ is taken as constant and dimensionless.\n- The output booleans indicate whether $|\\int H\\,dt - \\Delta u|/\\max(|\\Delta u|, \\delta) \\leq \\tau$, where $\\delta$ is a small floor and $\\tau$ is the tolerance.\n\nDerive the temperature evolution along the isobaric path from first principles:\n- With $u(T) = (3/2)\\,k_B T/(\\mu m_u) + a T^4/\\rho(T)$ and $\\rho(T) = \\alpha\\, [P - (a/3)T^4]/T$, define the effective specific heat along the isobar $c_{\\mathrm{eff}}(T) \\equiv du/dT$.\n- Use the reduced First Law to write $dT/dt = [\\dot{\\epsilon}_{\\mathrm{nuc}}(T,\\rho(T),X_{\\mathrm{Ne}}) - \\epsilon_\\nu(T)]/c_{\\mathrm{eff}}(T)$ and $dX_{\\mathrm{Ne}}/dt = -\\lambda_0\\,\\rho(T)^{\\alpha_\\rho}\\,T_9^{n}\\,\\exp(-T^\\star/T)\\,X_{\\mathrm{Ne}}$.\n- Introduce an auxiliary integral state $E(t)$ with $dE/dt = \\dot{\\epsilon}_{\\mathrm{nuc}} - \\epsilon_\\nu$ to accumulate the time integral.\n\nConstants to use:\n- Boltzmann’s constant $k_B = 1.380649 \\times 10^{-16}\\,\\mathrm{erg}\\,\\mathrm{K}^{-1}$.\n- Atomic mass unit $m_u = 1.66053906660 \\times 10^{-24}\\,\\mathrm{g}$.\n- Radiation constant $a = 7.5657 \\times 10^{-15}\\,\\mathrm{erg}\\,\\mathrm{cm}^{-3}\\,\\mathrm{K}^{-4}$.\n- Mean molecular weight $\\mu = 0.6$.\n- Density exponent $\\alpha_\\rho = 1$.\n- Temperature exponent $n = 10$.\n- Characteristic temperature $T^\\star = 1.0 \\times 10^9\\,\\mathrm{K}$.\n- Specific energy release per unit neon mass fraction consumed $Q_{\\mathrm{mass}} = 3.0 \\times 10^{17}\\,\\mathrm{erg}\\,\\mathrm{g}^{-1}$.\n- Tolerance $\\tau = 5.0 \\times 10^{-4}$ and floor $\\delta = 1.0 \\times 10^{-12}\\,\\mathrm{erg}\\,\\mathrm{g}^{-1}$.\n\nTest suite specification:\nProvide the following test cases, each as a tuple $(P, T_0, X_0, X_{\\mathrm{end}}, \\lambda_0, C_\\nu, t_{\\mathrm{max}})$:\n- Case A (happy path isobaric gas-dominated): $(1.0 \\times 10^{23}, 1.30 \\times 10^{9}, 0.50, 0.40, 1.0 \\times 10^{-9}, 8.0 \\times 10^{13}, 500.0)$.\n- Case B (neutrino-dominated cooling): $(1.0 \\times 10^{23}, 1.30 \\times 10^{9}, 0.50, 0.45, 2.0 \\times 10^{-9}, 5.0 \\times 10^{14}, 2000.0)$.\n- Case C (radiation-pressure-near boundary): $(1.50 \\times 10^{22}, 1.30 \\times 10^{9}, 0.40, 0.35, 1.0 \\times 10^{-8}, 5.0 \\times 10^{13}, 500.0)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[r_1,r_2,r_3]$), where each $r_i$ is a boolean indicating whether the relative discrepancy $|\\int H\\,dt - \\Delta u|/\\max(|\\Delta u|, \\delta)$ is less than or equal to the tolerance $\\tau$ for the corresponding test case.", "solution": "The problem statement has been critically examined and is determined to be **valid**. It presents a self-contained, scientifically consistent, and well-posed problem in computational nuclear astrophysics. The scenario describes a standard numerical verification test for an operator-split hydrodynamics code, where the goal is to confirm that the numerical integration of thermal energy evolution is consistent with the First Law of Thermodynamics under the specified simplifying assumptions. All required equations, constants, and initial conditions are provided, and no contradictions or factual errors are present.\n\nThe solution is founded upon the First Law of Thermodynamics for a fluid element, which under the problem's isobaric ($P=\\mathrm{const}$) burning operator approximation, simplifies to:\n$$\n\\frac{du}{dt} = \\dot{\\epsilon}_{\\mathrm{nuc}} - \\epsilon_{\\nu}\n$$\nwhere $u$ is the specific internal energy, $\\dot{\\epsilon}_{\\mathrm{nuc}}$ is the specific nuclear heating rate, and $\\epsilon_{\\nu}$ is the specific neutrino cooling rate.\n\nThe objective is to numerically verify that the total change in specific internal energy, $\\Delta u = u_{\\mathrm{end}} - u_0$, is equal to the time-integral of the net specific heating rate, $\\int_0^{t_{\\mathrm{end}}} (\\dot{\\epsilon}_{\\mathrm{nuc}}(t) - \\epsilon_{\\nu}(t)) dt$. This requires evolving the system's thermodynamic state—specifically its temperature $T$ and composition (neon mass fraction $X_{\\mathrm{Ne}}$)—over time. This evolution is governed by a system of ordinary differential equations (ODEs).\n\nThe state of the system can be described by a vector $\\vec{y}(t) = [T(t), X_{\\mathrm{Ne}}(t), E(t)]^T$, where $E(t)$ is an auxiliary state variable representing the accumulated net heating:\n$$\nE(t) = \\int_0^t (\\dot{\\epsilon}_{\\mathrm{nuc}}(t') - \\epsilon_{\\nu}(t')) dt'\n$$\nThe corresponding ODE for $E$ is simply $dE/dt = \\dot{\\epsilon}_{\\mathrm{nuc}} - \\epsilon_{\\nu}$.\n\nTo derive the ODE for temperature, we apply the chain rule to the left-hand side of the simplified First Law:\n$$\n\\frac{du}{dt} = \\frac{du}{dT} \\bigg|_{P=\\mathrm{const}} \\frac{dT}{dt}\n$$\nWe define the effective specific heat capacity along the isobar as $c_{\\mathrm{eff}}(T) \\equiv \\frac{du}{dT}|_{P=\\mathrm{const}}$. This allows us to write the temperature evolution equation as:\n$$\n\\frac{dT}{dt} = \\frac{\\dot{\\epsilon}_{\\mathrm{nuc}} - \\epsilon_{\\nu}}{c_{\\mathrm{eff}}(T)}\n$$\nThe derivation of $c_{\\mathrm{eff}}(T)$ is critical. The specific internal energy $u$ and density $\\rho$ are functions of temperature $T$ under the isobaric constraint. The provided Equation of State is $P = \\rho k_B T / (\\mu m_u) + (1/3) a T^4$. Defining the constant $\\alpha \\equiv \\mu m_u/k_B$, we can express density as a function of temperature:\n$$\n\\rho(T) = \\frac{\\alpha}{T} \\left(P - \\frac{1}{3} a T^4\\right)\n$$\nThe specific internal energy is given by $u(\\rho,T) = (3/2) k_B T/(\\mu m_u) + a T^4/\\rho$. Substituting $\\rho(T)$ gives $u$ as a function of $T$ alone along the isobar:\n$$\nu(T) = \\frac{3}{2\\alpha}T + \\frac{a T^4}{\\frac{\\alpha}{T}(P - \\frac{1}{3} a T^4)} = \\frac{3}{2\\alpha}T + \\frac{a T^5}{\\alpha(P - \\frac{1}{3} a T^4)}\n$$\nDifferentiating $u(T)$ with respect to $T$ via the quotient rule yields the expression for $c_{\\mathrm{eff}}(T)$:\n$$\nc_{\\mathrm{eff}}(T) = \\frac{du}{dT} = \\frac{3P^2 + 8PaT^4 - \\frac{1}{3}a^2T^8}{2\\alpha \\left(P - \\frac{1}{3}aT^4\\right)^2}\n$$\nThe evolution of the neon mass fraction $X_{\\mathrm{Ne}}$ is given by the reaction kinetics. The problem defines the destruction rate as:\n$$\n\\frac{dX_{\\mathrm{Ne}}}{dt} = -\\lambda_0\\,\\rho(T)^{\\alpha_\\rho}\\,T_9^{n}\\,\\exp(-T^\\star/T)\\,X_{\\mathrm{Ne}}\n$$\nwhere $T_9 = T / (10^9\\,\\mathrm{K})$. This is consistent with the nuclear energy generation rate $\\dot{\\epsilon}_{\\mathrm{nuc}} = -Q_{\\mathrm{mass}} (dX_{\\mathrm{Ne}}/dt)$, given the provided formulae.\n\nThe full ODE system to be solved is:\n$$\n\\frac{d}{dt}\n\\begin{pmatrix} T \\\\ X_{\\mathrm{Ne}} \\\\ E \\end{pmatrix}\n=\n\\begin{pmatrix}\n(\\dot{\\epsilon}_{\\mathrm{nuc}} - \\epsilon_{\\nu}) / c_{\\mathrm{eff}}(T) \\\\\n-\\lambda_0\\,\\rho(T)^{\\alpha_\\rho}\\,T_9^{n}\\,\\exp(-T^\\star/T)\\,X_{\\mathrm{Ne}} \\\\\n\\dot{\\epsilon}_{\\mathrm{nuc}} - \\epsilon_{\\nu}\n\\end{pmatrix}\n$$\nThis initial value problem is solved using a numerical ODE integrator, such as `scipy.integrate.solve_ivp`, starting from the initial state $[T_0, X_0, 0]$. The integration is configured to terminate when $X_{\\mathrm{Ne}}$ reaches the specified final mass fraction $X_{\\mathrm{end}}$, which is achieved using the solver's event detection capabilities.\n\nUpon termination at time $t_{\\mathrm{end}}$, the solver returns the final state $[T_{\\mathrm{end}}, X_{\\mathrm{end}}, E_{\\mathrm{integrated}}]$. The term $E_{\\mathrm{integrated}}$ is the numerically computed value for $\\int H dt$. The change in specific internal energy, $\\Delta u$, is computed independently using the initial and final states:\n$$\n\\Delta u = u(\\rho(T_{\\mathrm{end}}), T_{\\mathrm{end}}) - u(\\rho(T_0), T_0)\n$$\nFinally, energy conservation is verified by checking if the relative discrepancy between these two quantities is within the prescribed tolerance $\\tau$:\n$$\n\\frac{|\\Delta u - E_{\\mathrm{integrated}}|}{\\max(|\\Delta u|, \\delta)} \\le \\tau\n$$\nThe provided Python program implements this logic, defining helper functions for $\\rho(T)$, $u(\\rho, T)$, and $c_{\\mathrm{eff}}(T)$, and then iterating through each test case to solve the ODE and perform the verification. A high-precision solver method (`Radau`) with tight tolerances is employed to minimize numerical integration error and ensure the check properly validates the physical and mathematical consistency of the model implementation.", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\n# Physical and numerical constants\nk_B_val = 1.380649e-16  # erg K^-1\nm_u_val = 1.66053906660e-24  # g\na_val = 7.5657e-15  # erg cm^-3 K^-4\nmu_val = 0.6\nalpha_rho_val = 1.0\nn_val = 10.0\nT_star_val = 1.0e9  # K\nQ_mass_val = 3.0e17  # erg g^-1\ntau_val = 5.0e-4\ndelta_val = 1.0e-12  # erg g^-1\n\nalpha_val = mu_val * m_u_val / k_B_val  # g K erg^-1\n\ndef get_rho(T, P):\n    \"\"\"Calculates density on the isobar given T and P.\"\"\"\n    rad_pressure_part = (a_val / 3.0) * T**4\n    if P <= rad_pressure_part:\n        return np.nan\n    return alpha_val * (P - rad_pressure_part) / T\n\ndef get_u(T, rho):\n    \"\"\"Calculates specific internal energy given T and rho.\"\"\"\n    if rho <= 0:\n        return np.nan\n    # u = (3/2) * k_B * T / (mu * m_u) + a * T**4 / rho\n    # (k_B / (mu * m_u)) is 1/alpha\n    return (3.0 / 2.0) * T / alpha_val + a_val * T**4 / rho\n\ndef get_c_eff(T, P):\n    \"\"\"Calculates effective specific heat capacity along the isobar.\"\"\"\n    rad_pressure_part = (a_val / 3.0) * T**4\n    denom_factor = P - rad_pressure_part\n    if denom_factor <= 0:\n        return np.nan\n\n    P_sq = P**2\n    a_sq = a_val**2\n    T_4 = T**4\n    T_8 = T_4**2\n    \n    numerator = 3.0 * P_sq + 8.0 * P * a_val * T_4 - (1.0 / 3.0) * a_sq * T_8\n    denominator = 2.0 * alpha_val * denom_factor**2\n    return numerator / denominator\n\ndef ode_rhs(t, y, P, lambda0, C_nu):\n    \"\"\"Right-hand side of the ODE system dy/dt = f(t, y).\"\"\"\n    T, X_Ne, _ = y\n    \n    if T <= 0:\n        return [0.0, 0.0, 0.0]\n\n    T9 = T / 1.0e9\n    \n    rho = get_rho(T, P)\n    if np.isnan(rho) or rho <= 0:\n        return [0.0, 0.0, 0.0]\n\n    # Reaction rate factor\n    rate_factor = lambda0 * rho**alpha_rho_val * T9**n_val * np.exp(-T_star_val / T)\n    \n    eps_nuc = Q_mass_val * rate_factor * X_Ne\n    eps_nu = C_nu * T9**9\n    net_heating = eps_nuc - eps_nu\n    \n    c_eff = get_c_eff(T, P)\n    if np.isnan(c_eff) or c_eff <= 0:\n        return [0.0, 0.0, 0.0]\n\n    dT_dt = net_heating / c_eff\n    dX_Ne_dt = -rate_factor * X_Ne\n    dE_dt = net_heating\n    \n    return [dT_dt, dX_Ne_dt, dE_dt]\n\ndef solve():\n    \"\"\"Main function to run test cases and print results.\"\"\"\n    test_cases = [\n        # (P, T0, X0, X_end, lambda0, C_nu, t_max)\n        (1.0e23, 1.30e9, 0.50, 0.40, 1.0e-9, 8.0e13, 500.0),\n        (1.0e23, 1.30e9, 0.50, 0.45, 2.0e-9, 5.0e14, 2000.0),\n        (1.50e22, 1.30e9, 0.40, 0.35, 1.0e-8, 5.0e13, 500.0),\n    ]\n\n    results = []\n    for P, T0, X0, X_end, lambda0, C_nu, t_max in test_cases:\n        rho0 = get_rho(T0, P)\n        u0 = get_u(T0, rho0)\n        y0 = [T0, X0, 0.0]\n\n        def stop_event(t, y, P, lambda0, C_nu):\n            return y[1] - X_end\n        stop_event.terminal = True\n        \n        sol = solve_ivp(\n            fun=ode_rhs,\n            t_span=[0, t_max],\n            y0=y0,\n            args=(P, lambda0, C_nu),\n            events=stop_event,\n            dense_output=True,\n            method='Radau',\n            rtol=1e-9,\n            atol=1e-9\n        )\n\n        if not sol.t_events or not sol.t_events[0] or sol.status == -1:\n            results.append(False)\n            continue\n            \n        y_end = sol.y_events[0].flatten()\n        T_end, _, E_integrated = y_end\n        \n        rho_end = get_rho(T_end, P)\n        u_end = get_u(T_end, rho_end)\n        \n        Delta_u = u_end - u0\n        \n        discrepancy = abs(E_integrated - Delta_u)\n        denominator = max(abs(Delta_u), delta_val)\n        \n        if denominator == 0:\n             is_conserved = (discrepancy == 0)\n        else:\n            relative_discrepancy = discrepancy / denominator\n            is_conserved = relative_discrepancy <= tau_val\n            \n        results.append(is_conserved)\n\n    print(f\"[{','.join(map(str, results))}]\".lower())\n\nsolve()\n```", "id": "3590315"}]}