{"hands_on_practices": [{"introduction": "The neutron skin thickness, $\\Delta r_{np}$, can be defined in several ways. This first practice focuses on the analytical relationship between the definition based on root-mean-square (rms) radii and a simpler one based on the half-density radii of the neutron and proton distributions [@problem_id:3573370]. By performing a controlled asymptotic expansion, you will develop a deeper physical intuition for how the surface diffuseness of the nucleus creates a subtle but important correction to the simpler geometric picture of the skin.", "problem": "A spherical nucleus is modeled with two-parameter Fermi (2pF) densities for neutrons and protons. For each species $q \\in \\{n,p\\}$, the density is\n$$\n\\rho_{q}(r) = \\frac{\\rho_{0q}}{1 + \\exp\\!\\left(\\frac{r - C_{q}}{a_{q}}\\right)},\n$$\nwhere $C_{q}$ is the half-density radius, $a_{q}$ is the diffuseness, and $\\rho_{0q}$ is a central density constant. The neutron skin thickness defined from root-mean-square (rms) radii is\n$$\n\\Delta r_{np} \\equiv \\sqrt{\\langle r^{2} \\rangle_{n}} - \\sqrt{\\langle r^{2} \\rangle_{p}},\n$$\nwith\n$$\n\\langle r^{2} \\rangle_{q} \\equiv \\frac{\\displaystyle \\int_{0}^{\\infty} r^{4} \\rho_{q}(r) \\, dr}{\\displaystyle \\int_{0}^{\\infty} r^{2} \\rho_{q}(r) \\, dr}.\n$$\nAn alternative “half-density skin” is $\\Delta C \\equiv C_{n} - C_{p}$. Working in the leptodermous limit $a_{q}/C_{q} \\ll 1$ for $q \\in \\{n,p\\}$, start from the definitions above and perform a controlled asymptotic expansion of the defining integrals to leading nontrivial order in $a_{q}/C_{q}$. Use this to express $\\Delta r_{np}$ in terms of $(C_{n},a_{n})$ and $(C_{p},a_{p})$, and then determine the leading-order correction\n$$\nS \\equiv \\Delta r_{np} - \\sqrt{\\frac{3}{5}}\\,\\Delta C,\n$$\nretaining terms through order $(a_{q}/C_{q})^{2}$ and neglecting higher orders. Your final answer must be a single closed-form analytic expression for $S$ in terms of $C_{n}$, $C_{p}$, $a_{n}$, and $a_{p}$. Additionally, briefly state in words (no formulas required) which qualitative parameter regimes make the rms-based and half-density definitions diverge most strongly, but only report the analytic expression for $S$ as your final answer. No numerical evaluation is required.", "solution": "The problem requires the derivation of an expression for the quantity $S \\equiv \\Delta r_{np} - \\sqrt{\\frac{3}{5}}\\,\\Delta C$, which represents the leading-order correction between two definitions of the neutron skin thickness. The derivation will be performed in the leptodermous limit, $a_q/C_q \\ll 1$, for a nucleus described by two-parameter Fermi (2pF) densities for neutrons ($q=n$) and protons ($q=p$).\n\nThe core of the problem is the evaluation of the mean-square radius $\\langle r^2 \\rangle_q$ for each particle species $q$:\n$$\n\\langle r^2 \\rangle_{q} = \\frac{\\displaystyle \\int_{0}^{\\infty} r^{4} \\rho_{q}(r) \\, dr}{\\displaystyle \\int_{0}^{\\infty} r^{2} \\rho_{q}(r) \\, dr}\n$$\nThe density profile is given by\n$$\n\\rho_{q}(r) = \\frac{\\rho_{0q}}{1 + \\exp\\left(\\frac{r - C_{q}}{a_{q}}\\right)}\n$$\nThe integrals in the numerator and denominator are moments of a Fermi-Dirac distribution. In the leptodermous limit ($a_q \\to 0$), this distribution approaches a step function at $r = C_q$. For small but finite $a_q$, these integrals can be evaluated using the Sommerfeld expansion. For an integral of the form $I = \\int_{0}^{\\infty} H(r) f(r) dr$, where $f(r)$ is the Fermi function, the expansion is:\n$$\n\\int_{0}^{\\infty} \\frac{H(r)}{1 + \\exp\\left(\\frac{r - C}{a}\\right)} dr \\approx \\int_{0}^{C} H(r) \\, dr + \\frac{\\pi^2 a^2}{6} H'(C) + \\mathcal{O}(a^4)\n$$\nwhere $H'(C)$ is the derivative of $H(r)$ evaluated at $r=C$.\n\nLet us apply this expansion to the integrals for $\\langle r^2 \\rangle_q$. The normalization constant $\\rho_{0q}$ will cancel out in the ratio, so we can omit it.\n\nFor the numerator integral, which we denote $I_4$, we have $H(r) = r^4$. Its derivative is $H'(r) = 4r^3$. Applying the Sommerfeld expansion:\n$$\nI_4 = \\int_{0}^{\\infty} \\frac{r^4}{1 + \\exp\\left(\\frac{r - C_{q}}{a_{q}}\\right)} dr \\approx \\int_{0}^{C_q} r^4 \\, dr + \\frac{\\pi^2 a_q^2}{6} (4C_q^3) = \\frac{C_q^5}{5} + \\frac{2\\pi^2 a_q^2 C_q^3}{3}\n$$\n\nFor the denominator integral, $I_2$, we have $H(r) = r^2$. Its derivative is $H'(r) = 2r$. Applying the Sommerfeld expansion:\n$$\nI_2 = \\int_{0}^{\\infty} \\frac{r^2}{1 + \\exp\\left(\\frac{r - C_{q}}{a_{q}}\\right)} dr \\approx \\int_{0}^{C_q} r^2 \\, dr + \\frac{\\pi^2 a_q^2}{6} (2C_q) = \\frac{C_q^3}{3} + \\frac{\\pi^2 a_q^2 C_q}{3}\n$$\n\nNow, we compute the ratio $\\langle r^2 \\rangle_q = I_4 / I_2$:\n$$\n\\langle r^2 \\rangle_q \\approx \\frac{\\frac{C_q^5}{5} + \\frac{2\\pi^2 a_q^2 C_q^3}{3}}{\\frac{C_q^3}{3} + \\frac{\\pi^2 a_q^2 C_q}{3}} = \\frac{\\frac{C_q^5}{5} \\left(1 + \\frac{10\\pi^2}{3} \\frac{a_q^2}{C_q^2}\\right)}{\\frac{C_q^3}{3} \\left(1 + \\pi^2 \\frac{a_q^2}{C_q^2}\\right)}\n$$\nThis simplifies to:\n$$\n\\langle r^2 \\rangle_q \\approx \\frac{3}{5} C_q^2 \\frac{1 + \\frac{10\\pi^2}{3} \\frac{a_q^2}{C_q^2}}{1 + \\pi^2 \\frac{a_q^2}{C_q^2}}\n$$\nUsing the approximation $(1+x)^{-1} \\approx 1-x$ for small $x = \\pi^2 (a_q/C_q)^2$:\n$$\n\\langle r^2 \\rangle_q \\approx \\frac{3}{5} C_q^2 \\left(1 + \\frac{10\\pi^2}{3} \\frac{a_q^2}{C_q^2}\\right) \\left(1 - \\pi^2 \\frac{a_q^2}{C_q^2}\\right) \\approx \\frac{3}{5} C_q^2 \\left(1 + \\left(\\frac{10\\pi^2}{3} - \\pi^2\\right) \\frac{a_q^2}{C_q^2}\\right)\n$$\n$$\n\\langle r^2 \\rangle_q \\approx \\frac{3}{5} C_q^2 \\left(1 + \\frac{7\\pi^2}{3} \\frac{a_q^2}{C_q^2}\\right) = \\frac{3}{5}C_q^2 + \\frac{7\\pi^2}{5}a_q^2\n$$\nThis expression is accurate to order $(a_q/C_q)^2$ relative to the leading term.\n\nNext, we find the root-mean-square (rms) radius, $\\sqrt{\\langle r^2 \\rangle_q}$:\n$$\n\\sqrt{\\langle r^2 \\rangle_q} = \\sqrt{\\frac{3}{5}C_q^2 + \\frac{7\\pi^2}{5}a_q^2} = \\sqrt{\\frac{3}{5}} C_q \\sqrt{1 + \\frac{7\\pi^2}{3}\\frac{a_q^2}{C_q^2}}\n$$\nUsing the Taylor expansion $\\sqrt{1+x} \\approx 1 + \\frac{x}{2}$ for small $x$:\n$$\n\\sqrt{\\langle r^2 \\rangle_q} \\approx \\sqrt{\\frac{3}{5}} C_q \\left(1 + \\frac{1}{2} \\frac{7\\pi^2}{3}\\frac{a_q^2}{C_q^2}\\right) = \\sqrt{\\frac{3}{5}} C_q + \\sqrt{\\frac{3}{5}} \\frac{7\\pi^2}{6} \\frac{a_q^2}{C_q}\n$$\nThe terms retained are up to order $C_q(a_q/C_q)^2 = a_q^2/C_q$, as required by the problem's implicit accuracy target for $S$.\n\nNow we can write the rms-based neutron skin thickness, $\\Delta r_{np}$:\n$$\n\\Delta r_{np} = \\sqrt{\\langle r^2 \\rangle_{n}} - \\sqrt{\\langle r^2 \\rangle_{p}}\n$$\n$$\n\\Delta r_{np} \\approx \\left(\\sqrt{\\frac{3}{5}} C_n + \\sqrt{\\frac{3}{5}} \\frac{7\\pi^2}{6} \\frac{a_n^2}{C_n}\\right) - \\left(\\sqrt{\\frac{3}{5}} C_p + \\sqrt{\\frac{3}{5}} \\frac{7\\pi^2}{6} \\frac{a_p^2}{C_p}\\right)\n$$\n$$\n\\Delta r_{np} \\approx \\sqrt{\\frac{3}{5}} (C_n - C_p) + \\sqrt{\\frac{3}{5}} \\frac{7\\pi^2}{6} \\left(\\frac{a_n^2}{C_n} - \\frac{a_p^2}{C_p}\\right)\n$$\nUsing the definition $\\Delta C = C_n - C_p$, this becomes:\n$$\n\\Delta r_{np} \\approx \\sqrt{\\frac{3}{5}} \\Delta C + \\sqrt{\\frac{3}{5}} \\frac{7\\pi^2}{6} \\left(\\frac{a_n^2}{C_n} - \\frac{a_p^2}{C_p}\\right)\n$$\nFinally, we compute the correction term $S$:\n$$\nS = \\Delta r_{np} - \\sqrt{\\frac{3}{5}} \\Delta C\n$$\nSubstituting our expression for $\\Delta r_{np}$:\n$$\nS \\approx \\left(\\sqrt{\\frac{3}{5}} \\Delta C + \\sqrt{\\frac{3}{5}} \\frac{7\\pi^2}{6} \\left(\\frac{a_n^2}{C_n} - \\frac{a_p^2}{C_p}\\right)\\right) - \\sqrt{\\frac{3}{5}} \\Delta C\n$$\n$$\nS \\approx \\sqrt{\\frac{3}{5}} \\frac{7\\pi^2}{6} \\left(\\frac{a_n^2}{C_n} - \\frac{a_p^2}{C_p}\\right)\n$$\nThis is the desired closed-form expression for $S$ in terms of the given parameters.\n\nQualitatively, the quantity $S$ measures the deviation between the rms-based skin thickness and the simpler half-density skin definition. This deviation becomes most significant when the nuclear surfaces are more diffuse. Based on the derived expression for $S$, the divergence is largest in regimes where the diffuseness parameters ($a_n$ and $a_p$) are large and differ substantially from each other. This effect is further amplified in lighter nuclei, where the half-density radii ($C_n$ and $C_p$) are smaller, making the surface diffuseness a more prominent feature relative to the overall nuclear size.", "answer": "$$\n\\boxed{\\sqrt{\\frac{3}{5}} \\frac{7\\pi^2}{6} \\left(\\frac{a_{n}^2}{C_{n}} - \\frac{a_{p}^2}{C_{p}}\\right)}\n$$", "id": "3573370"}, {"introduction": "Before exploring complex physical phenomena, a computational scientist must first ensure their tools are reliable. This exercise moves from pure analysis to the practical challenges of numerical computation, focusing on a convergence study for the neutron skin of $^{208}\\text{Pb}$ [@problem_id:3573312]. You will implement a calculation from first principles and systematically investigate how the result is affected by numerical parameters like grid spacing and integration volume, thereby learning how to establish the accuracy and reliability of your computational results.", "problem": "You are tasked with designing and implementing a complete, runnable numerical program that performs a convergence study of the neutron skin thickness, denoted by $\\Delta r_{np}$, in a spherical nucleus. The quantities of interest are derived from first principles of continuous distributions and numerical quadrature on a finite computational domain, without relying on shortcut formulas. Your program must analyze how the computed $\\Delta r_{np}$ depends on three numerical parameters: the radial mesh spacing $dr$, the spherical box radius $R_{\\mathrm{box}}$, and the iteration tolerance $\\mathrm{tol}$ used for shape parameter determination.\n\nBegin from the following foundational base:\n- A spherically symmetric particle density $\\rho(r)$ in three dimensions contributes to the total particle number through the volume integral $N = \\int 4\\pi r^2 \\rho(r)\\,dr$ for neutrons and $Z = \\int 4\\pi r^2 \\rho(r)\\,dr$ for protons, where the integrals are over the physical space.\n- The root-mean-square radius of a species with spherical density $\\rho(r)$ is defined by $r_{\\mathrm{rms}} = \\sqrt{\\dfrac{\\int 4\\pi r^4 \\rho(r)\\,dr}{\\int 4\\pi r^2 \\rho(r)\\,dr}}$.\n- The neutron skin thickness is defined as $\\Delta r_{np} = r_{\\mathrm{rms}}^{(n)} - r_{\\mathrm{rms}}^{(p)}$, where $r_{\\mathrm{rms}}^{(n)}$ and $r_{\\mathrm{rms}}^{(p)}$ are the root-mean-square radii of neutrons and protons, respectively.\n\nModel the neutron and proton densities by two-parameter Fermi profiles (also called Woods–Saxon profiles) with spherical symmetry,\n$$\n\\rho_{q}(r;c_q,a_q,\\rho_{0,q}) = \\frac{\\rho_{0,q}}{1 + \\exp\\!\\left(\\frac{r - c_q}{a_q}\\right)} \\quad \\text{for } q \\in \\{n,p\\},\n$$\nwhere $c_q$ is the half-density radius, $a_q$ is the surface diffuseness, and $\\rho_{0,q}$ is a central density scale. Use the following physically plausible, fixed parameters for the lead nucleus with mass number $A$:\n- Nucleus: $^{208}\\text{Pb}$ with $A = 208$, neutron number $N = 126$, proton number $Z = 82$.\n- Surface diffuseness: $a_n = a_p = 0.55\\ \\mathrm{fm}$.\n- Saturation central density: $\\rho_{\\mathrm{sat}} = 0.16\\ \\mathrm{fm}^{-3}$.\n- Central densities partitioned by isospin fraction: $\\rho_{0,n} = \\rho_{\\mathrm{sat}}\\cdot \\dfrac{N}{A}$ and $\\rho_{0,p} = \\rho_{\\mathrm{sat}}\\cdot \\dfrac{Z}{A}$.\n\nCritically, determine the shape parameters $c_n$ and $c_p$ by solving the normalization conditions\n$$\n\\int_0^{R_{\\mathrm{box}}} 4\\pi r^2 \\rho_{n}(r;c_n,a_n,\\rho_{0,n})\\,dr = N, \\qquad\n\\int_0^{R_{\\mathrm{box}}} 4\\pi r^2 \\rho_{p}(r;c_p,a_p,\\rho_{0,p})\\,dr = Z,\n$$\non the finite numerical domain $r \\in [0, R_{\\mathrm{box}}]$, using a robust one-dimensional root-finding procedure that does not assume a closed-form solution. The iteration must terminate when the relative residual in normalization is below the specified $\\mathrm{tol}$, or when an upper bound on the number of iterations is reached. Your algorithm must search a valid bracket for $c_q$ (ensuring that the target normalization is attainable within $[c_{\\mathrm{min}}, c_{\\mathrm{max}}]$) and must gracefully handle the case where $R_{\\mathrm{box}}$ is too small to achieve exact normalization (in which case $c_q$ should be clamped to the largest feasible value in the bracket).\n\nOn a radial mesh $r_k = k\\cdot dr$ for integers $k$ such that $0 \\le r_k \\le R_{\\mathrm{box}}$, compute the integrals using a consistent composite numerical quadrature scheme over the mesh with spacing $dr$. The neutron skin thickness $\\Delta r_{np}$ must be evaluated in femtometers (fm). To assess convergence, define a high-accuracy reference value $\\Delta r_{np}^{\\mathrm{ref}}$ computed on a very fine mesh with large box and tight tolerance, and measure the absolute deviation\n$$\n\\varepsilon(dr, R_{\\mathrm{box}}, \\mathrm{tol}) = \\left|\\Delta r_{np}(dr, R_{\\mathrm{box}}, \\mathrm{tol}) - \\Delta r_{np}^{\\mathrm{ref}}\\right|\n$$\nin femtometers. The target precision criterion is $\\varepsilon \\le 0.005\\ \\mathrm{fm}$.\n\nImplement the program to:\n1. Construct the densities $\\rho_n(r)$ and $\\rho_p(r)$ for given $dr$, $R_{\\mathrm{box}}$, and $\\mathrm{tol}$ by determining $c_n$ and $c_p$ via iterative normalization constrained to $[0, R_{\\mathrm{box}}]$.\n2. Compute $r_{\\mathrm{rms}}^{(n)}$, $r_{\\mathrm{rms}}^{(p)}$, and hence $\\Delta r_{np}$ for each case.\n3. Compute $\\Delta r_{np}^{\\mathrm{ref}}$ using $dr_{\\mathrm{ref}} = 0.005\\ \\mathrm{fm}$, $R_{\\mathrm{box}}^{\\mathrm{ref}} = 25\\ \\mathrm{fm}$, and $\\mathrm{tol}_{\\mathrm{ref}} = 10^{-12}$.\n4. For each test case $\\{dr, R_{\\mathrm{box}}, \\mathrm{tol}\\}$, output whether the target precision threshold $\\varepsilon \\le 0.005\\ \\mathrm{fm}$ is met, as a boolean.\n\nTest Suite:\nUse the following set of eight parameter triplets to probe different aspects of convergence, including mesh coarseness, box truncation, and iteration tightness:\n- Case $1$: $dr = 0.50\\ \\mathrm{fm}$, $R_{\\mathrm{box}} = 9.0\\ \\mathrm{fm}$, $\\mathrm{tol} = 10^{-2}$.\n- Case $2$: $dr = 0.10\\ \\mathrm{fm}$, $R_{\\mathrm{box}} = 9.0\\ \\mathrm{fm}$, $\\mathrm{tol} = 10^{-8}$.\n- Case $3$: $dr = 0.20\\ \\mathrm{fm}$, $R_{\\mathrm{box}} = 14.0\\ \\mathrm{fm}$, $\\mathrm{tol} = 10^{-6}$.\n- Case $4$: $dr = 0.10\\ \\mathrm{fm}$, $R_{\\mathrm{box}} = 20.0\\ \\mathrm{fm}$, $\\mathrm{tol} = 10^{-6}$.\n- Case $5$: $dr = 0.05\\ \\mathrm{fm}$, $R_{\\mathrm{box}} = 16.0\\ \\mathrm{fm}$, $\\mathrm{tol} = 10^{-4}$.\n- Case $6$: $dr = 0.05\\ \\mathrm{fm}$, $R_{\\mathrm{box}} = 25.0\\ \\mathrm{fm}$, $\\mathrm{tol} = 10^{-8}$.\n- Case $7$: $dr = 0.02\\ \\mathrm{fm}$, $R_{\\mathrm{box}} = 25.0\\ \\mathrm{fm}$, $\\mathrm{tol} = 10^{-10}$.\n- Case $8$: $dr = 0.01\\ \\mathrm{fm}$, $R_{\\mathrm{box}} = 12.0\\ \\mathrm{fm}$, $\\mathrm{tol} = 10^{-12}$.\n\nRequired Final Output Format:\nYour program should produce a single line of output containing the results for the above eight test cases as a comma-separated list enclosed in square brackets, with entries being booleans indicating whether $\\varepsilon \\le 0.005\\ \\mathrm{fm}$ holds for each case, in the given order (for example, $\\left[\\mathrm{True},\\mathrm{False},\\ldots\\right]$). No other text should be printed.", "solution": "The problem requires a numerical convergence study of the neutron skin thickness, $\\Delta r_{np}$, for the $^{208}\\text{Pb}$ nucleus. The solution involves implementing a computational framework based on first principles, employing numerical quadrature and root-finding algorithms. The foundation of this analysis rests on modeling the neutron and proton distributions with two-parameter Fermi density profiles and then numerically solving for the parameters that ensure correct particle number normalization.\n\n**1. Theoretical and Mathematical Framework**\n\nThe neutron ($q=n$) and proton ($q=p$) density distributions are modeled by the spherically symmetric two-parameter Fermi function:\n$$\n\\rho_{q}(r; c_q, a_q, \\rho_{0,q}) = \\frac{\\rho_{0,q}}{1 + \\exp\\left(\\frac{r - c_q}{a_q}\\right)}\n$$\nwhere $r$ is the radial coordinate, $c_q$ is the half-density radius, $a_q$ is the surface diffuseness, and $\\rho_{0,q}$ is the central density parameter. For the $^{208}\\text{Pb}$ nucleus, we are given $A=208$, $N=126$, and $Z=82$. The diffuseness is fixed at $a_n = a_p = 0.55\\ \\mathrm{fm}$. The central densities are derived from the saturation density $\\rho_{\\mathrm{sat}} = 0.16\\ \\mathrm{fm}^{-3}$ as $\\rho_{0,n} = \\rho_{\\mathrm{sat}} \\cdot (N/A)$ and $\\rho_{0,p} = \\rho_{\\mathrm{sat}} \\cdot (Z/A)$.\n\nThe half-density radii, $c_n$ and $c_p$, are not given and must be determined by enforcing the normalization condition within a finite spherical volume of radius $R_{\\mathrm{box}}$. This condition states that the integral of the number density over the volume must equal the total number of particles of that species:\n$$\nN_q = \\int_0^{R_{\\mathrm{box}}} 4\\pi r^2 \\rho_q(r; c_q, a_q, \\rho_{0,q}) \\, dr\n$$\nwhere $N_n = N$ and $N_p = Z$.\n\nOnce the correctly normalized densities are obtained, the root-mean-square (rms) radius for each particle species is calculated as:\n$$\nr_{\\mathrm{rms}}^{(q)} = \\sqrt{\\frac{\\int_0^{R_{\\mathrm{box}}} 4\\pi r^4 \\rho_q(r) \\, dr}{\\int_0^{R_{\\mathrm{box}}} 4\\pi r^2 \\rho_q(r) \\, dr}}\n$$\nThe denominator in this expression is precisely the particle number $N_q$. For numerical consistency, it is crucial to use the value of the integral computed on the numerical grid, rather than the target values $N$ or $Z$.\n\nFinally, the neutron skin thickness is the difference between the neutron and proton rms radii:\n$$\n\\Delta r_{np} = r_{\\mathrm{rms}}^{(n)} - r_{\\mathrm{rms}}^{(p)}\n$$\n\n**2. Numerical Strategy and Algorithmic Design**\n\nThe core of the problem is to solve the normalization equation for $c_q$ and then compute the rms radii using numerical integration.\n\n**2.1. Numerical Quadrature**\nAll integrals are computed numerically on a discrete radial mesh. The mesh is defined by a spacing $dr$ over the interval $[0, R_{\\mathrm{box}}]$, giving points $r_k = k \\cdot dr$ for $k=0, 1, \\dots, \\lfloor R_{\\mathrm{box}}/dr \\rfloor$. A high-order composite quadrature rule is appropriate for integrating the smooth functions involved. We select the composite Simpson's rule, which offers excellent accuracy. The `scipy.integrate.simpson` function provides a robust implementation of this method that correctly handles grids with both even and odd numbers of intervals.\n\n**2.2. Root-Finding for the Half-Density Radius $c_q$**\nFor each species $q$, we must find the value of $c_q$ that satisfies the normalization condition. This is a one-dimensional root-finding problem. Let us define a function for the residual:\n$$\nf(c_q) = \\left( \\int_0^{R_{\\mathrm{box}}} 4\\pi r^2 \\rho_q(r; c_q) \\, dr \\right) - N_q = 0\n$$\nThe integral term, which we can denote as $I(c_q)$, is a monotonically decreasing function of $c_q$. A larger $c_q$ pushes the density distribution outwards, so for a fixed box radius $R_{\\mathrm{box}}$, the integrated number of particles within the box decreases. This monotonicity guarantees that if a solution for $c_q$ exists within a given search interval, it is unique.\n\nA robust bisection method is employed to find the root $c_q$. The search is conducted within the physical bracket $[c_{\\mathrm{min}}, c_{\\mathrm{max}}] = [0, R_{\\mathrm{box}}]$. The bisection algorithm proceeds as follows:\n1.  Establish the search bracket $[c_{\\mathrm{min}}, c_{\\mathrm{max}}]$.\n2.  Before starting the search, check if the target $N_q$ is bracketed by the values of the integral at the endpoints, $I(c_{\\mathrm{min}})$ and $I(c_{\\mathrm{max}})$.\n    -   If $N_q > I(c_{\\mathrm{min}})$, the integration box is too small to contain $N_q$ particles, even for the most compact density profile ($c_q = 0$). In this case, $c_q$ is set to $c_{\\mathrm{min}} = 0$, the value that maximizes the particle count.\n    -   If $N_q < I(c_{\\mathrm{max}})$, the particle count is always greater than $N_q$, even for the most diffuse profile within the bracket ($c_q = R_{\\mathrm{box}}$). Here, $c_q$ is set to $c_{\\mathrm{max}} = R_{\\mathrm{box}}$ to minimize the count.\n3.  If a root is bracketed, iterate by repeatedly bisecting the interval. At each step $i$, a midpoint $c_{\\mathrm{mid}, i}$ is tested. The bracket for the next step is updated based on whether $I(c_{\\mathrm{mid}, i})$ is greater or less than $N_q$.\n4.  The iteration terminates when the relative residual for the particle number is less than the specified tolerance $\\mathrm{tol}$, i.e., $|I(c_q) - N_q| / N_q < \\mathrm{tol}$, or after a fixed maximum number of iterations is reached.\n\n**3. Implementation and Convergence Study**\n\nThe overall program is structured to perform the calculations for a series of test cases and compare them against a high-accuracy reference case.\n\n1.  **Reference Calculation**: A reference value, $\\Delta r_{np}^{\\mathrm{ref}}$, is first computed using a very fine mesh ($dr_{\\mathrm{ref}} = 0.005\\ \\mathrm{fm}$), a large box radius ($R_{\\mathrm{box}}^{\\mathrm{ref}} = 25\\ \\mathrm{fm}$), and a strict root-finding tolerance ($\\mathrm{tol}_{\\mathrm{ref}} = 10^{-12}$). This provides a benchmark assumed to be very close to the true converged value.\n\n2.  **Test Case Evaluation**: The program then iterates through the eight provided test cases, each defined by a triplet of parameters $\\{dr, R_{\\mathrm{box}}, \\mathrm{tol}\\}$. For each case:\n    a. The half-density radii $c_n$ and $c_p$ are determined using the bisection method described above.\n    b. The rms radii $r_{\\mathrm{rms}}^{(n)}$ and $r_{\\mathrm{rms}}^{(p)}$ are computed using Simpson's rule.\n    c. The neutron skin thickness $\\Delta r_{np}$ is calculated.\n    d. The absolute deviation from the reference, $\\varepsilon = |\\Delta r_{np} - \\Delta r_{np}^{\\mathrm{ref}}|$, is computed.\n\n3.  **Output**: The a boolean value, indicating whether the deviation $\\varepsilon$ meets the precision criterion $\\varepsilon \\le 0.005\\ \\mathrm{fm}$, is determined for each case. The final output is a list of these boolean results.\n\nThe implementation is encapsulated within a Python program, leveraging `numpy` for efficient array operations and `scipy.integrate.simpson` for numerical quadrature, adhering to all specified constraints.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import integrate\n\ndef solve():\n    \"\"\"\n    Main function to perform the convergence study of the neutron skin thickness.\n    \"\"\"\n    \n    #\n    # --- Problem Constants ---\n    #\n    A = 208.0\n    N = 126.0\n    Z = 82.0\n    a_n = 0.55\n    a_p = 0.55\n    rho_sat = 0.16\n    \n    # Derived density parameters\n    rho_0_n = rho_sat * (N / A)\n    rho_0_p = rho_sat * (Z / A)\n\n    #\n    # --- Numerical Implementation ---\n    #\n\n    def find_c(dr, R_box, tol, N_target, a, rho_0):\n        \"\"\"\n        Determines the half-density radius 'c' using a bisection root-finding method.\n        \"\"\"\n        num_points = int(R_box / dr) + 1\n        r_grid = np.linspace(0.0, R_box, num_points)\n\n        def calculate_norm_at_c(c_val):\n            \"\"\"Helper function to compute the integrated particle number for a given c.\"\"\"\n            # Fermi-Dirac distribution\n            rho_vals = rho_0 / (1.0 + np.exp((r_grid - c_val) / a))\n            # Integrand for particle number\n            integrand = 4.0 * np.pi * r_grid**2 * rho_vals\n            # Numerical integration using Simpson's rule\n            return integrate.simpson(integrand, x=r_grid)\n\n        # Establish search bracket\n        c_min, c_max = 0.0, R_box\n        \n        # Calculate normalization at bracket boundaries\n        # Note: Integral is a monotonically decreasing function of c\n        norm_at_c_min = calculate_norm_at_c(c_min) # Max possible norm\n        norm_at_c_max = calculate_norm_at_c(c_max) # Min possible norm\n        \n        # Handle cases where the target cannot be bracketed\n        if N_target > norm_at_c_min:\n            # Box is too small to contain N_target particles.\n            # Return c_min to maximize the enclosed particle number.\n            return c_min\n        if N_target < norm_at_c_max:\n            # Integral is always larger than N_target.\n            # Return c_max to minimize the enclosed particle number.\n            return c_max\n\n        # Bisection search\n        max_iter = 100\n        for _ in range(max_iter):\n            c_mid = (c_min + c_max) / 2.0\n            \n            # Avoid infinite loops if float precision limit is reached\n            if c_mid == c_min or c_mid == c_max:\n                break\n            \n            norm_mid = calculate_norm_at_c(c_mid)\n            \n            # Check for convergence based on relative residual\n            if abs(norm_mid - N_target) / N_target < tol:\n                return c_mid\n            \n            # Update bracket\n            if norm_mid > N_target:\n                # I(c) too high, need to increase c to decrease I(c)\n                c_min = c_mid\n            else:\n                # I(c) too low, need to decrease c to increase I(c)\n                c_max = c_mid\n        \n        # Return best estimate if max iterations are reached\n        return (c_min + c_max) / 2.0\n\n    def calculate_rms_radius(c, dr, R_box, a, rho_0):\n        \"\"\"Computes the root-mean-square radius for a given density profile.\"\"\"\n        num_points = int(R_box / dr) + 1\n        r_grid = np.linspace(0.0, R_box, num_points)\n        \n        rho_vals = rho_0 / (1.0 + np.exp((r_grid - c) / a))\n        \n        # r^2 moment integrand\n        integrand_r2 = 4.0 * np.pi * r_grid**2 * rho_vals\n        # r^4 moment integrand\n        integrand_r4 = 4.0 * np.pi * r_grid**4 * rho_vals\n        \n        # Compute integrals\n        I_r2 = integrate.simpson(integrand_r2, x=r_grid)\n        I_r4 = integrate.simpson(integrand_r4, x=r_grid)\n        \n        if I_r2 <= 0:\n            return 0.0\n            \n        return np.sqrt(I_r4 / I_r2)\n\n    def get_skin_thickness(dr, R_box, tol):\n        \"\"\"Orchestrates the calculation of the neutron skin thickness for one case.\"\"\"\n        c_n = find_c(dr, R_box, tol, N, a_n, rho_0_n)\n        c_p = find_c(dr, R_box, tol, Z, a_p, rho_0_p)\n        \n        r_rms_n = calculate_rms_radius(c_n, dr, R_box, a_n, rho_0_n)\n        r_rms_p = calculate_rms_radius(c_p, dr, R_box, a_p, rho_0_p)\n        \n        return r_rms_n - r_rms_p\n\n    #\n    # --- Convergence Study Execution ---\n    #\n\n    # Define reference case for high-accuracy benchmark\n    dr_ref = 0.005\n    R_box_ref = 25.0\n    tol_ref = 1.0e-12\n    delta_r_np_ref = get_skin_thickness(dr_ref, R_box_ref, tol_ref)\n\n    # Define the test suite\n    test_cases = [\n        # Case 1: dr, R_box, tol\n        (0.50, 9.0, 1.0e-2),\n        # Case 2\n        (0.10, 9.0, 1.0e-8),\n        # Case 3\n        (0.20, 14.0, 1.0e-6),\n        # Case 4\n        (0.10, 20.0, 1.0e-6),\n        # Case 5\n        (0.05, 16.0, 1.0e-4),\n        # Case 6\n        (0.05, 25.0, 1.0e-8),\n        # Case 7\n        (0.02, 25.0, 1.0e-10),\n        # Case 8\n        (0.01, 12.0, 1.0e-12),\n    ]\n\n    precision_threshold = 0.005  # fm\n    results = []\n    \n    for dr, R_box, tol in test_cases:\n        delta_r_np_case = get_skin_thickness(dr, R_box, tol)\n        deviation = abs(delta_r_np_case - delta_r_np_ref)\n        results.append(deviation <= precision_threshold)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3573312"}, {"introduction": "While spherical models offer a useful starting point, a vast number of atomic nuclei exhibit non-spherical, or deformed, shapes. This final practice explores the intricate relationship between nuclear deformation and the neutron skin thickness [@problem_id:3573317]. By building a model that incorporates quadrupole deformation, you will quantify the sensitivity of $\\Delta r_{np}$ to changes in nuclear shape, providing direct insight into the coupling between the collective geometry of the nucleus and its isospin-asymmetric properties.", "problem": "You are to implement a complete, runnable program to quantify how the neutron skin thickness responds to nuclear shape-phase transitions from spherical to prolate deformation. The fundamental physical quantity is the neutron skin thickness, defined as the difference between the root-mean-square radii of the neutron distribution and the proton distribution. Let the neutron skin thickness be denoted by $\\Delta r_{np}$ and defined by $\\Delta r_{np} = \\sqrt{\\langle r^2 \\rangle_n} - \\sqrt{\\langle r^2 \\rangle_p}$, where $\\langle r^2 \\rangle_q$ for species $q \\in \\{n,p\\}$ is the mean-square radius computed from a nuclear density distribution $\\rho_q(\\mathbf{r})$.\n\nYou must work from the following foundational definitions and well-tested constructs in nuclear structure physics:\n- The root-mean-square radius for a density $\\rho_q(\\mathbf{r})$ is given by $\\sqrt{\\langle r^2 \\rangle_q}$, with $\\langle r^2 \\rangle_q = \\dfrac{\\int r^2 \\rho_q(\\mathbf{r}) \\, d^3\\mathbf{r}}{\\int \\rho_q(\\mathbf{r}) \\, d^3\\mathbf{r}}$.\n- The nuclear density distribution for species $q$ is modeled by a deformed two-parameter Fermi distribution, a widely used representation in nuclear physics, in which the surface is deformed by a quadrupole parameter. The density is constructed in spherical coordinates by adopting an angle-dependent surface radius and a radial profile controlled by a half-density radius and diffuseness parameter.\n- The quadrupole deformation is parameterized by the deformation parameter $\\beta_2$ and the real spherical harmonic $Y_{20}(\\theta)$, with the deformed surface radius given by $r_{\\text{surf}}(\\theta) = c_q \\left(1 + \\beta_2 Y_{20}(\\theta)\\right)$, where $c_q$ is the half-density radius for species $q$ and $Y_{20}(\\theta) = \\sqrt{\\dfrac{5}{16\\pi}} \\left(3 \\cos^2\\theta - 1\\right)$.\n- The two-parameter Fermi radial profile is taken as $\\rho_q(r,\\theta) = \\dfrac{1}{1 + \\exp\\left(\\dfrac{r - r_{\\text{surf}}(\\theta)}{a_q}\\right)}$, where $a_q$ is the diffuseness parameter for species $q$. In forming ratios to compute $\\langle r^2 \\rangle_q$, the overall normalization factor for $\\rho_q$ cancels and is therefore not required.\n\nYour program must compute $\\Delta r_{np}$ for two shapes of each selected isotope: the spherical case with $\\beta_2 = 0$, and a specified prolate case with a nonzero $\\beta_2$. You must then compute the sensitivity of $\\Delta r_{np}$ with respect to the deformation change using a finite-difference measure\n$$\nS = \\frac{\\Delta r_{np}(\\beta_2) - \\Delta r_{np}(0)}{\\beta_2},\n$$\nwhich is to be reported in units of femtometers per unit deformation parameter $\\beta_2$. All radii and lengths must be expressed in femtometers (fm).\n\nParameterization rules to ensure scientific realism:\n- For an isotope with mass number $A$, proton number $Z$, and neutron number $N = A - Z$, adopt a common baseline radius parameter $c_0 = r_0 A^{1/3}$ with $r_0 = 1.2 \\,\\text{fm}$.\n- Let the isospin asymmetry be $I = \\dfrac{N - Z}{A}$. Use an isovector half-density radius splitting $c_n = c_0 + \\dfrac{\\kappa I}{2}$ and $c_p = c_0 - \\dfrac{\\kappa I}{2}$ with $\\kappa = 1.0 \\,\\text{fm}$.\n- Use a baseline diffuseness $a_0 = 0.55 \\,\\text{fm}$ and allow a mild isovector modulation $a_n = a_0 \\left(1 + \\eta I\\right)$ and $a_p = a_0 \\left(1 - \\dfrac{\\eta I}{2}\\right)$ with $\\eta = 0.3$. These choices are designed to produce scientifically plausible magnitudes for $\\Delta r_{np}$ across the isotopic chain.\n\nComputational requirements:\n- Implement the integrals for $\\langle r^2 \\rangle_q$ by numerical quadrature in spherical coordinates. Use the substitution $x = \\cos\\theta$ to reduce the angular integral, noting that $\\sin\\theta \\, d\\theta = -dx$, and include the azimuthal integration factor $2\\pi$. The resulting numerator and denominator integrals should be computed over $r \\in [0, r_{\\max}]$ and $x \\in [-1,1]$, where $r_{\\max}$ is a sufficiently large cutoff to capture the density tail. The final expressions are\n$$\n\\langle r^2 \\rangle_q = \\frac{\\int_0^{r_{\\max}} \\int_{-1}^{1} 2\\pi \\, r^4 \\, \\rho_q(r,x) \\, dr \\, dx}{\\int_0^{r_{\\max}} \\int_{-1}^{1} 2\\pi \\, r^2 \\, \\rho_q(r,x) \\, dr \\, dx},\n$$\nwith $x = \\cos\\theta$ and $Y_{20}(\\theta)$ evaluated as a function of $x$.\n- Choose $r_{\\max}$ large enough to make numerical truncation negligible for the adopted $c_q$ and $a_q$. A fixed margin beyond the deformed surface is acceptable provided it is large enough relative to $a_q$.\n\nTest suite and required outputs:\n- Your program must compute the sensitivity $S$ for the following five test cases. Each test input is a tuple $(\\text{element}, A, Z, \\beta_2)$:\n    1. $(\\text{Kr}, 86, 36, 0.30)$\n    2. $(\\text{Kr}, 96, 36, 0.32)$\n    3. $(\\text{Sr}, 92, 38, 0.15)$\n    4. $(\\text{Sr}, 100, 38, 0.38)$\n    5. $(\\text{Kr}, 78, 36, 0.05)$\n- For each case, compute $S$ in femtometers per unit $\\beta_2$ as defined above. You must use radians for any angular computations internally, although the substitution eliminates explicit angles. The final outputs must be floats.\n- Final output format: Your program should produce a single line of output containing the sensitivities for the five test cases as a comma-separated list enclosed in square brackets, for example, $[\\text{result1},\\text{result2},\\text{result3},\\text{result4},\\text{result5}]$. Each entry must be a float in femtometers per unit $\\beta_2$; round each to six decimal places to standardize presentation.", "solution": "The problem is valid as it is scientifically grounded in established principles of nuclear structure physics, is well-posed with a complete and consistent set of definitions and parameters, and is expressed in objective, formalizable language. The task is to compute the sensitivity of the neutron skin thickness to quadrupole deformation for a set of specific nuclei.\n\n### 1. Principle of the Calculation\n\nThe primary objective is to calculate the sensitivity, $S$, of the neutron skin thickness, $\\Delta r_{np}$, with respect to the quadrupole deformation parameter, $\\beta_2$. The sensitivity is defined by the finite-difference formula:\n$$\nS = \\frac{\\Delta r_{np}(\\beta_2) - \\Delta r_{np}(0)}{\\beta_2}\n$$\nThis quantity measures the change in the neutron skin thickness per unit change in the deformation parameter. The neutron skin thickness itself is the difference between the root-mean-square (RMS) radii of the neutron and proton distributions:\n$$\n\\Delta r_{np} = \\sqrt{\\langle r^2 \\rangle_n} - \\sqrt{\\langle r^2 \\rangle_p}\n$$\nwhere $\\sqrt{\\langle r^2 \\rangle_q}$ is the RMS radius for a given nucleon species $q \\in \\{n, p\\}$ (neutrons or protons).\n\n### 2. Nuclear Model and Parameterization\n\nThe calculation is based on a standard model for the nuclear density distribution, $\\rho_q(\\mathbf{r})$, which is assumed to be a deformed two-parameter Fermi distribution.\n\n**Density Distribution:** The density $\\rho_q$ for species $q$ at a given position $(r, \\theta, \\phi)$ is given in spherical coordinates (with azimuthal symmetry) by:\n$$\n\\rho_q(r,\\theta) = \\frac{1}{1 + \\exp\\left(\\frac{r - r_{\\text{surf}}(\\theta)}{a_q}\\right)}\n$$\nHere, $a_q$ is the diffuseness parameter, which controls the thickness of the nuclear surface. The term $r_{\\text{surf}}(\\theta)$ represents the angle-dependent nuclear surface radius, which incorporates the quadrupole deformation:\n$$\nr_{\\text{surf}}(\\theta) = c_q \\left(1 + \\beta_2 Y_{20}(\\theta)\\right)\n$$\nwhere $c_q$ is the half-density radius (the radius at which the density drops to half its central value in the spherical case), $\\beta_2$ is the quadrupole deformation parameter, and $Y_{20}(\\theta)$ is the real spherical harmonic:\n$$\nY_{20}(\\theta) = \\sqrt{\\frac{5}{16\\pi}} \\left(3 \\cos^2\\theta - 1\\right)\n$$\n\n**Parameterization:** The model parameters $c_q$ and $a_q$ for neutrons and protons are determined based on the macroscopic-microscopic approach, linking them to the nucleus's mass number $A$, proton number $Z$, and neutron number $N=A-Z$.\n- The isospin asymmetry is defined as $I = \\frac{N - Z}{A}$.\n- A baseline half-density radius $c_0$ is scaled with the mass number, consistent with the liquid drop model: $c_0 = r_0 A^{1/3}$, with $r_0 = 1.2 \\, \\text{fm}$.\n- The neutron and proton half-density radii are split by an isovector term:\n  $$\n  c_n = c_0 + \\frac{\\kappa I}{2}, \\quad c_p = c_0 - \\frac{\\kappa I}{2} \\quad (\\text{with } \\kappa = 1.0 \\, \\text{fm})\n  $$\n- The diffuseness parameters are also modulated by isospin asymmetry, starting from a baseline value $a_0 = 0.55 \\, \\text{fm}$:\n  $$\n  a_n = a_0(1 + \\eta I), \\quad a_p = a_0\\left(1 - \\frac{\\eta I}{2}\\right) \\quad (\\text{with } \\eta = 0.3)\n  $$\nThese parameterizations ensure that for neutron-rich nuclei ($I > 0$), the neutron distribution has a larger radius and is more diffuse than the proton distribution, leading to a positive neutron skin.\n\n### 3. Computational Method\n\nThe core of the computation is the calculation of the mean-square radius $\\langle r^2 \\rangle_q$ for each nucleon species, which is defined by the integral ratio:\n$$\n\\langle r^2 \\rangle_q = \\frac{\\int r^2 \\rho_q(\\mathbf{r}) \\, d^3\\mathbf{r}}{\\int \\rho_q(\\mathbf{r}) \\, d^3\\mathbf{r}}\n$$\nUsing spherical coordinates, the volume element is $d^3\\mathbf{r} = r^2 \\sin\\theta \\, dr \\, d\\theta \\, d\\phi$. Due to the azimuthal symmetry of $\\rho_q(r, \\theta)$, the integration over $\\phi$ yields a factor of $2\\pi$. By making the standard substitution $x = \\cos\\theta$, for which $dx = -\\sin\\theta \\, d\\theta$, the integrals become two-dimensional:\n$$\n\\langle r^2 \\rangle_q = \\frac{\\int_0^{r_{\\max}} \\int_{-1}^{1} 2\\pi \\, r^4 \\, \\rho_q(r,x) \\, dx \\, dr}{\\int_0^{r_{\\max}} \\int_{-1}^{1} 2\\pi \\, r^2 \\, \\rho_q(r,x) \\, dx \\, dr}\n$$\nwhere the density $\\rho_q(r,x)$ is now a function of radius $r$ and the cosine of the polar angle, $x$. The integrals are performed numerically over $x \\in [-1, 1]$ and $r \\in [0, r_{\\max}]$. The upper radial cutoff $r_{\\max}$ must be chosen sufficiently large to ensure that the tail of the Fermi distribution is fully captured and truncation errors are negligible. A value of $r_{\\max} = 25 \\, \\text{fm}$ is chosen, which is significantly larger than any expected nuclear radius in the test cases, even when deformed.\n\n### 4. Algorithmic Design\n\nThe overall algorithm to compute the sensitivity $S$ for each test case $(\\text{isotope}, A, Z, \\beta_2)$ is as follows:\n\n1.  **Define a function to compute the RMS radius, `get_rms_radius(A, Z, beta2, species)`**:\n    - This function takes the nuclear composition ($A, Z$), the deformation $\\beta_2$, and the nucleon species ('n' or 'p') as input.\n    - It first calculates the derived parameters $I$, $c_0$, $c_q$, and $a_q$ according to the specified parameterization rules.\n    - It defines the integrand functions for the numerator ($\\propto r^4 \\rho_q$) and the denominator ($\\propto r^2 \\rho_q$). The density $\\rho_q(r, x)$ is computed internally based on the input parameters.\n    - It uses a 2D numerical quadrature routine (`scipy.integrate.dblquad`) to evaluate the numerator and denominator integrals over the domain $r \\in [0, 25]$ and $x \\in [-1, 1]$.\n    - Finally, it computes $\\langle r^2 \\rangle_q$ as the ratio of the integrals and returns its square root, $\\sqrt{\\langle r^2 \\rangle_q}$.\n\n2.  **Define a function to compute the sensitivity, `compute_sensitivity(A, Z, beta2)`**:\n    - This function orchestrates the calculation for a single test case.\n    - It computes the neutron skin thickness for the deformed case, $\\Delta r_{np}(\\beta_2)$, by calling `get_rms_radius` for both neutrons and protons with the given $\\beta_2$ and taking the difference.\n    - It computes the neutron skin thickness for the spherical case, $\\Delta r_{np}(0)$, by calling `get_rms_radius` for both neutrons and protons with $\\beta_2=0$.\n    - It calculates the sensitivity $S$ using the finite-difference formula.\n\n3.  **Main Execution Loop**:\n    - The main part of the program iterates through the list of specified test cases.\n    - For each case, it calls `compute_sensitivity` to obtain the value of $S$.\n    - The results are collected into a list.\n    - The final list of results is formatted into the required string output: a comma-separated list of floating-point numbers (rounded to six decimal places) enclosed in square brackets. This structure is implemented in the provided Python code within the `<final_answer>` tag.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import dblquad\n\ndef solve():\n    \"\"\"\n    Computes the sensitivity of the neutron skin thickness to nuclear deformation\n    for a series of test cases.\n    \"\"\"\n    \n    # Define physical and model constants as specified in the problem statement\n    R0_FM = 1.2\n    KAPPA_FM = 1.0\n    A0_FM = 0.55\n    ETA = 0.3\n    R_MAX_FM = 25.0  # Sufficiently large integration cutoff radius in fm\n\n    # Define the test cases from the problem statement.\n    # Each tuple contains: (Element Name, Mass Number A, Proton Number Z, Deformation beta_2)\n    test_cases = [\n        (\"Kr\", 86, 36, 0.30),\n        (\"Kr\", 96, 36, 0.32),\n        (\"Sr\", 92, 38, 0.15),\n        (\"Sr\", 100, 38, 0.38),\n        (\"Kr\", 78, 36, 0.05),\n    ]\n\n    def get_rms_radius(A, Z, beta2, species):\n        \"\"\"\n        Calculates the root-mean-square radius for a given species (n or p).\n        \"\"\"\n        N = A - Z\n        I = (N - Z) / A if A > 0 else 0.0\n        c0 = R0_FM * A**(1/3)\n\n        if species == 'n':\n            c_q = c0 + KAPPA_FM * I / 2.0\n            a_q = A0_FM * (1.0 + ETA * I)\n        elif species == 'p':\n            c_q = c0 - KAPPA_FM * I / 2.0\n            a_q = A0_FM * (1.0 - ETA * I / 2.0)\n        else:\n            raise ValueError(\"Species must be 'n' or 'p'\")\n\n        y20_prefactor = np.sqrt(5.0 / (16.0 * np.pi))\n\n        def rho_q(r, x):\n            \"\"\"\n            Deformed two-parameter Fermi distribution. x is cos(theta).\n            \"\"\"\n            y20 = y20_prefactor * (3.0 * x**2 - 1.0)\n            r_surf = c_q * (1.0 + beta2 * y20)\n            \n            exponent = (r - r_surf) / a_q\n            # Avoid overflow for large positive exponents\n            if exponent > 100.0:\n                return 0.0\n            return 1.0 / (1.0 + np.exp(exponent))\n\n        def integrand_num(r, x):\n            return 2.0 * np.pi * r**4 * rho_q(r, x)\n\n        def integrand_den(r, x):\n            return 2.0 * np.pi * r**2 * rho_q(r, x)\n\n        # scipy.integrate.dblquad integrates func(y, x) over x in [a,b] and y in [g(x), h(x)]\n        # Our integral is over x=cos(theta) in [-1, 1] and r in [0, R_MAX_FM]\n        # The call should be dblquad(integrand, x_min, x_max, y_min, y_max)\n        # where integrand is a function of (y, x). Here y->r, x->x\n        num_integral, _ = dblquad(integrand_num, -1.0, 1.0, 0.0, R_MAX_FM)\n        den_integral, _ = dblquad(integrand_den, -1.0, 1.0, 0.0, R_MAX_FM)\n\n        if den_integral == 0:\n            return 0.0\n\n        mean_sq_radius = num_integral / den_integral\n        return np.sqrt(mean_sq_radius)\n\n    def compute_sensitivity(A, Z, beta2):\n        \"\"\"\n        Computes the sensitivity S for a given nucleus and deformation.\n        \"\"\"\n        # Calculate Delta_r_np for the deformed case\n        rms_n_deformed = get_rms_radius(A, Z, beta2, 'n')\n        rms_p_deformed = get_rms_radius(A, Z, beta2, 'p')\n        delta_r_np_deformed = rms_n_deformed - rms_p_deformed\n\n        # Calculate Delta_r_np for the spherical case (beta2 = 0)\n        rms_n_spherical = get_rms_radius(A, Z, 0.0, 'n')\n        rms_p_spherical = get_rms_radius(A, Z, 0.0, 'p')\n        delta_r_np_spherical = rms_n_spherical - rms_p_spherical\n        \n        if beta2 == 0:\n            # The sensitivity is undefined for beta2 = 0, but problem cases have beta2 > 0.\n            # In principle, one could define it as the derivative at beta2=0.\n            # For this problem, we just avoid division by zero.\n            return 0.0\n\n        sensitivity = (delta_r_np_deformed - delta_r_np_spherical) / beta2\n        return sensitivity\n\n    results = []\n    for _, A, Z, beta2 in test_cases:\n        s = compute_sensitivity(A, Z, beta2)\n        results.append(s)\n\n    # Final print statement in the exact required format.\n    # Format each result to six decimal places to standardize presentation.\n    formatted_results = [f'{r:.6f}' for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3573317"}]}