{"hands_on_practices": [{"introduction": "The cornerstone of describing the deuteron in nonrelativistic quantum mechanics is the time-independent Schrödinger equation. This first practice brings this foundational equation to life by tasking you with solving it numerically on a discrete spatial lattice. Using a physically-motivated potential that combines long-range one-pion exchange with a short-range contact interaction, you will implement and compare two powerful numerical techniques: the finite-difference method and a spectral method. This exercise [@problem_id:3582617] is essential for developing an intuition for how continuum physics problems are translated into computationally tractable matrix forms and understanding the trade-offs in accuracy and efficiency between different discretization schemes.", "problem": "Consider the bound state of the proton–neutron system (the deuteron) in the nonrelativistic limit, modeled by the radial time-independent Schrödinger equation for the reduced radial wave function $u(r)$ in the $S$-wave channel:\n$$\n-\\frac{\\hbar^2}{2\\mu}\\frac{d^2 u(r)}{dr^2} + V(r)\\,u(r) = E\\,u(r),\n$$\nwith boundary conditions $u(0)=0$ and $u(r)\\to 0$ as $r\\to \\infty$. Here, $\\mu$ is the reduced mass of the proton–neutron system, and $E$ is the binding energy (negative for a bound state). Work in units where lengths are in femtometers and energies are in mega-electronvolts. The reduced mass $\\mu$ is computed from the proton mass $m_p$ and neutron mass $m_n$ via $\\mu = \\frac{m_p m_n}{m_p + m_n}$.\n\nAssume the nuclear interaction is given by a One-Pion Exchange (OPE) central Yukawa potential plus a regulated contact interaction, consistent with low-energy chiral effective field theory, defined by\n$$\nV(r) = V_{\\text{Y}}(r) + V_{\\text{C}}(r),\n$$\nwhere the central Yukawa potential is\n$$\nV_{\\text{Y}}(r) = -C_Y \\frac{e^{-m_\\pi r}}{r},\n$$\nand the regulated contact interaction is\n$$\nV_{\\text{C}}(r) = C_0 \\exp\\left(-\\left(\\frac{r}{R_0}\\right)^2\\right).\n$$\nUse the following constants:\n- $\\hbar c = 197.3269804$ mega-electronvolt femtometer,\n- $m_p = 938.2720813$ mega-electronvolt,\n- $m_n = 939.5654133$ mega-electronvolt,\n- $m_\\pi = 138.0$ mega-electronvolt,\n- $C_Y = 40.0$ mega-electronvolt femtometer,\n- $C_0 = -300.0$ mega-electronvolt,\n- $R_0 = 0.6$ femtometer.\n\nConvert the pion mass $m_\\pi$ to inverse femtometer using $m_\\pi^{(\\text{fm}^{-1})} = \\frac{m_\\pi}{\\hbar c}$ for use in the Yukawa factor. The box size is $L$ femtometers, and the problem is posed on the interval $r\\in[0,L]$ with Dirichlet boundary conditions $u(0)=0$ and $u(L)=0$ to approximate $u(r\\to\\infty)=0$.\n\nImplement two numerical methods to approximate the ground-state binding energy:\n1. A standard second-order central finite-difference discretization on a uniform grid with $N$ interior points and spacing $\\Delta r = \\frac{L}{N+1}$, yielding a tridiagonal Hamiltonian matrix with\n$$\nH_{jj} = \\frac{\\hbar^2}{\\mu \\Delta r^2} + V(r_j), \\quad H_{j,j\\pm 1} = -\\frac{\\hbar^2}{2\\mu \\Delta r^2},\n$$\nfor interior grid points $r_j = j \\Delta r$ with $j = 1,2,\\dots,N$, and $V(r_j)$ evaluated at those points.\n2. A spectral Galerkin method using the Fourier sine basis (pseudospectral collocation) on $[0,L]$ with $N$ basis functions $\\{\\phi_n(r)\\}_{n=1}^N$, where\n$$\n\\phi_n(r) = \\sqrt{\\frac{2}{L}}\\sin\\left(\\frac{n\\pi r}{L}\\right).\n$$\nThe kinetic-energy operator is diagonal in this basis with eigenvalues\n$$\nT_n = \\frac{\\hbar^2}{2\\mu}\\left(\\frac{n\\pi}{L}\\right)^2.\n$$\nApproximate the potential matrix elements by uniform quadrature on the same $N$ interior points $r_j = j \\Delta r$, using\n$$\nV_{nm} \\approx \\Delta r \\sum_{j=1}^N \\phi_n(r_j)\\,V(r_j)\\,\\phi_m(r_j),\n$$\nto form a dense Hamiltonian matrix $H_{nm} = T_n \\delta_{nm} + V_{nm}$.\n\nFor both methods, compute the smallest eigenvalue of the respective Hamiltonian and interpret it as the ground-state energy $E$, in mega-electronvolts. Define a high-accuracy reference solution $E_{\\text{ref}}$ by the spectral Galerkin method with a large basis size on the same box size $L$.\n\nYour program must:\n- Use the constants above and compute the reduced mass $\\mu$ from $m_p$ and $m_n$.\n- Implement both numerical methods described.\n- Compute a reference ground-state energy $E_{\\text{ref}}$ using the spectral method with $N_{\\text{ref}} = 512$ and the box size $L = 20.0$ femtometer.\n- Evaluate the absolute error $|E - E_{\\text{ref}}|$ for the following test suite:\n    - Case $1$: $L = 20.0$ femtometer, $N = 64$,\n    - Case $2$: $L = 20.0$ femtometer, $N = 128$,\n    - Case $3$: $L = 20.0$ femtometer, $N = 256$.\nFor each case, compute the absolute error for both the finite-difference and spectral methods.\n\nExpress all energies and errors in mega-electronvolts, and round the reported errors to six decimal places. Angles do not appear in this problem. Your program should produce a single line of output containing the six results in a comma-separated list enclosed in square brackets, ordered as\n$$\n[\\;|E_{\\text{FD}}^{(64)} - E_{\\text{ref}}|,\\;|E_{\\text{SP}}^{(64)} - E_{\\text{ref}}|,\\;|E_{\\text{FD}}^{(128)} - E_{\\text{ref}}|,\\;|E_{\\text{SP}}^{(128)} - E_{\\text{ref}}|,\\;|E_{\\text{FD}}^{(256)} - E_{\\text{ref}}|,\\;|E_{\\text{SP}}^{(256)} - E_{\\text{ref}}|\\;],\n$$\nwhere $E_{\\text{FD}}^{(N)}$ and $E_{\\text{SP}}^{(N)}$ denote the ground-state energies obtained by the finite-difference and spectral methods using $N$ interior points or basis functions, respectively, on the box $[0,L]$. The final output must be in the exact format \"[result1,result2,result3,result4,result5,result6]\".", "solution": "The starting point is the nonrelativistic radial Schrödinger equation for the $S$-wave deuteron, which reads\n$$\n-\\frac{\\hbar^2}{2\\mu}\\frac{d^2 u(r)}{dr^2} + V(r)\\,u(r) = E\\,u(r),\n$$\nwith boundary conditions $u(0)=0$ and $u(r\\to\\infty)=0$, and $l=0$ so that there is no centrifugal term. The reduced mass $\\mu$ of the proton–neutron system is computed from the proton mass $m_p$ and neutron mass $m_n$ by\n$$\n\\mu = \\frac{m_p m_n}{m_p + m_n}.\n$$\nWe work on a finite interval $[0,L]$ and enforce Dirichlet boundary conditions $u(0)=0$ and $u(L)=0$ to approximate the bound-state condition.\n\nThe nuclear potential is modeled as a sum of a One-Pion Exchange (OPE) central Yukawa term and a regulated contact interaction. The OPE central Yukawa term is\n$$\nV_{\\text{Y}}(r) = -C_Y \\frac{e^{-m_\\pi r}}{r},\n$$\nwhere $m_\\pi$ is the pion mass in inverse femtometers. To use $m_\\pi$ given in mega-electronvolts, we convert via\n$$\nm_\\pi^{(\\text{fm}^{-1})} = \\frac{m_\\pi^{(\\text{MeV})}}{\\hbar c},\n$$\nwith $\\hbar c$ in mega-electronvolt femtometers. The regulated contact interaction mimics short-range physics and is chosen as a Gaussian regulator:\n$$\nV_{\\text{C}}(r) = C_0 \\exp\\left(-\\left(\\frac{r}{R_0}\\right)^2\\right).\n$$\nHence, the total potential is\n$$\nV(r) = -C_Y \\frac{e^{-m_\\pi r}}{r} + C_0 \\exp\\left(-\\left(\\frac{r}{R_0}\\right)^2\\right).\n$$\n\nTo compute the bound-state energy numerically, we discretize the problem and solve the corresponding matrix eigenvalue problem. Two methods are employed:\n\n1. Finite-Difference Method (FDM):\nWe define a uniform grid with $N$ interior points and spacing\n$$\n\\Delta r = \\frac{L}{N+1},\n$$\nwith grid points $r_j = j \\Delta r$ for $j=1,2,\\dots,N$. The second derivative is approximated using the standard central finite difference:\n$$\n\\frac{d^2 u}{dr^2}\\bigg|_{r_j} \\approx \\frac{u_{j+1} - 2 u_j + u_{j-1}}{\\Delta r^2}.\n$$\nThe kinetic operator $-\\frac{\\hbar^2}{2\\mu}\\frac{d^2}{dr^2}$ then leads to a tridiagonal matrix with elements\n$$\nH_{jj} = \\frac{\\hbar^2}{\\mu \\Delta r^2} + V(r_j), \\quad H_{j,j\\pm 1} = -\\frac{\\hbar^2}{2\\mu \\Delta r^2}.\n$$\nThis $N\\times N$ tridiagonal Hamiltonian captures the Dirichlet boundary conditions implicitly via the absence of points at $r=0$ and $r=L$. The smallest eigenvalue of this matrix approximates the ground-state energy $E$.\n\n2. Spectral Galerkin Method with Fourier Sine Basis:\nWe use the orthonormal basis functions on $[0,L]$,\n$$\n\\phi_n(r) = \\sqrt{\\frac{2}{L}}\\sin\\left(\\frac{n\\pi r}{L}\\right), \\quad n=1,2,\\dots,N.\n$$\nThese basis functions satisfy the Dirichlet boundary conditions $\\phi_n(0)=\\phi_n(L)=0$. The kinetic energy operator is diagonal in this basis with eigenvalues\n$$\nT_n = \\frac{\\hbar^2}{2\\mu}\\left(\\frac{n\\pi}{L}\\right)^2.\n$$\nThe potential matrix elements are given by the integral\n$$\nV_{nm} = \\int_0^L \\phi_n(r)\\,V(r)\\,\\phi_m(r)\\,dr.\n$$\nWe approximate this integral by uniform quadrature (Riemann sum) over the same $N$ interior points $r_j = j \\Delta r$:\n$$\nV_{nm} \\approx \\Delta r \\sum_{j=1}^N \\phi_n(r_j)\\,V(r_j)\\,\\phi_m(r_j).\n$$\nThe resulting Hamiltonian matrix in this basis is\n$$\nH_{nm} = T_n \\delta_{nm} + V_{nm}.\n$$\nWe then compute the smallest eigenvalue of this dense symmetric matrix to approximate the ground-state energy $E$.\n\nReference Solution:\nTo gauge accuracy, we compute a high-accuracy reference ground-state energy $E_{\\text{ref}}$ using the spectral Galerkin method with $N_{\\text{ref}}=512$ basis functions on the box of size $L=20.0$ femtometer. This provides a benchmark against which we can compute absolute errors for other discretizations:\n$$\n\\text{error} = |E - E_{\\text{ref}}|.\n$$\n\nAlgorithmic Steps:\n- Compute constants: $\\hbar c$, $m_p$, $m_n$, and the reduced mass $\\mu = \\frac{m_p m_n}{m_p + m_n}$.\n- Convert $m_\\pi$ from mega-electronvolts to inverse femtometers via $m_\\pi^{(\\text{fm}^{-1})} = \\frac{m_\\pi}{\\hbar c}$.\n- Implement a function to evaluate $V(r)$ at any $r>0$ using the given $C_Y$, $C_0$, and $R_0$.\n- Implement the FDM Hamiltonian construction for given $N$ and $L$, and compute its smallest eigenvalue using a tridiagonal eigensolver.\n- Implement the spectral Galerkin Hamiltonian using the sine basis for given $N$ and $L$, assembling the diagonal kinetic energy and quadrature-based potential matrix, and compute its smallest eigenvalue using a dense symmetric eigensolver.\n- Compute $E_{\\text{ref}}$ using the spectral method with $N_{\\text{ref}}=512$ and $L=20.0$.\n- For the test suite cases $(N,L) = (64,20.0)$, $(128,20.0)$, and $(256,20.0)$, compute the finite-difference and spectral ground-state energies and their absolute errors relative to $E_{\\text{ref}}$.\n- Round each error to six decimal places and print them in the specified single-line list format.\n\nScientific Rationale:\nThe Schrödinger equation is the fundamental law governing the bound-state wave function of the deuteron in the nonrelativistic regime. The OPE central Yukawa potential emerges as the leading long-range component of the nuclear force in chiral effective field theory, while short-range physics is captured by regulated contact interactions. The finite-difference method discretizes the Laplacian operator on a uniform grid, providing a simple and systematic approximation. The spectral Galerkin method exploits known eigenfunctions of the kinetic operator that satisfy the boundary conditions, offering rapid convergence for smooth potentials. Comparing both methods against a high-resolution spectral reference quantifies accuracy and convergence behavior as $N$ increases while holding the box size fixed.\n\nUnits:\nAll energies (including $E$ and $E_{\\text{ref}}$) and errors must be expressed in mega-electronvolts and reported as decimal floats. The final output must be the single line\n$$\n[\\;|E_{\\text{FD}}^{(64)} - E_{\\text{ref}}|,\\;|E_{\\text{SP}}^{(64)} - E_{\\text{ref}}|,\\;|E_{\\text{FD}}^{(128)} - E_{\\text{ref}}|,\\;|E_{\\text{SP}}^{(128)} - E_{\\text{ref}}|,\\;|E_{\\text{FD}}^{(256)} - E_{\\text{ref}}|,\\;|E_{\\text{SP}}^{(256)} - E_{\\text{ref}}|\\;],\n$$\nwith each float rounded to six decimal places.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh_tridiagonal\nfrom numpy.linalg import eigh\n\n# Constants (in MeV and fm units)\nHBAR_C = 197.3269804  # MeV*fm\nM_P = 938.2720813     # MeV\nM_N = 939.5654133     # MeV\n\n# Reduced mass (MeV) in natural units (c=1)\nMU = (M_P * M_N) / (M_P + M_N)\n\n# Potential parameters\nM_PI_MEV = 138.0                 # MeV\nM_PI_FM_INV = M_PI_MEV / HBAR_C  # 1/fm\nC_Y = 40.0                       # MeV*fm for Yukawa\nC0 = -300.0                      # MeV for contact\nR0 = 0.6                         # fm for contact regulator\n\ndef potential(r):\n    \"\"\"\n    Compute the nuclear potential V(r) = Yukawa + Gaussian contact at radial distance r (fm).\n    Returns energy in MeV.\n    \"\"\"\n    # Avoid division by zero; r is never zero on interior points.\n    vy = -C_Y * np.exp(-M_PI_FM_INV * r) / r\n    vc = C0 * np.exp(-(r / R0) ** 2)\n    return vy + vc\n\ndef fd_ground_energy(N, L):\n    \"\"\"\n    Finite-difference method ground-state energy for given N interior points and box size L (fm).\n    Returns the smallest eigenvalue (MeV).\n    \"\"\"\n    dr = L / (N + 1)\n    r = (np.arange(1, N + 1)) * dr\n    V = potential(r)\n\n    # Kinetic prefactor: - (hbar^2 / (2 mu)) d^2/dr^2\n    # For the discrete Hamiltonian, diag and off-diagonal entries as per central difference.\n    kinetic_diag = (HBAR_C ** 2) / (MU * dr * dr)   # MeV\n    kinetic_off = - (HBAR_C ** 2) / (2.0 * MU * dr * dr)  # MeV\n\n    d = kinetic_diag + V                # main diagonal\n    e = np.full(N - 1, kinetic_off)     # off-diagonal entries\n\n    # Compute eigenvalues of tridiagonal symmetric matrix\n    evals = eigh_tridiagonal(d, e, select='i', select_range=(0, 0))[0]\n    return float(evals[0])\n\ndef spectral_ground_energy(N, L):\n    \"\"\"\n    Spectral Galerkin method using Fourier sine basis with N modes on [0, L] (fm).\n    Constructs the Hamiltonian in the sine basis and returns the smallest eigenvalue (MeV).\n    \"\"\"\n    dr = L / (N + 1)\n    r = (np.arange(1, N + 1)) * dr  # interior points\n    V = potential(r)\n\n    # Build the basis function values Phi[j, n] = sqrt(2/L) * sin(n*pi*r_j/L)\n    n_idx = np.arange(1, N + 1)\n    k = (n_idx * np.pi) / L\n    Phi = np.sqrt(2.0 / L) * np.sin(np.outer(r, k))  # shape (N, N)\n\n    # Kinetic energy diagonal in the sine basis: T_n = (hbar^2 / (2 mu)) * k_n^2\n    T_diag = (HBAR_C ** 2) * (k ** 2) / (2.0 * MU)\n\n    # Potential matrix via quadrature: V_nm ≈ dr * sum_j Phi[j,n] * V(r_j) * Phi[j,m]\n    # Compute S = sqrt(dr) * Phi, then V_nm = (S^T * diag(V) * S) for numerical stability\n    # But since dr is scalar, we can do directly:\n    # temp = (V[:, None] * Phi) has shape (N, N)\n    temp = V[:, None] * Phi\n    V_mat = dr * (Phi.T @ temp)  # (N, N)\n\n    # Hamiltonian in the basis\n    H = V_mat + np.diag(T_diag)\n\n    # Dense symmetric eigenvalue problem\n    evals = eigh(H)[0]\n    return float(evals[0])\n\ndef solve():\n    # Box size for all test cases\n    L = 20.0\n\n    # Reference energy using spectral method with high resolution\n    N_ref = 512\n    E_ref = spectral_ground_energy(N_ref, L)\n\n    # Test suite: (N, L) values\n    test_cases = [\n        (64, L),\n        (128, L),\n        (256, L),\n    ]\n\n    results = []\n    for N, L_case in test_cases:\n        E_fd = fd_ground_energy(N, L_case)\n        E_sp = spectral_ground_energy(N, L_case)\n        err_fd = abs(E_fd - E_ref)\n        err_sp = abs(E_sp - E_ref)\n        # Round to six decimal places as required\n        results.append(round(err_fd, 6))\n        results.append(round(err_sp, 6))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3582617"}, {"introduction": "Theoretical calculations are often performed within a finite computational volume, a necessary idealization that introduces systematic effects not present in nature. This practice explores the finite-volume correction to the deuteron's binding energy, a critical concept in bridging lattice calculations with infinite-volume experimental reality. You will move from coordinate space to a momentum-space framework using the Lippmann-Schwinger equation with a simple separable potential. By calculating the binding energy for different box sizes, you will numerically verify the famous exponential dependence of the finite-volume shift on the box size $L$ [@problem_id:3582632], providing a tangible understanding of how the infinite-volume limit is recovered.", "problem": "Consider a two-nucleon bound state (the deuteron) in nonrelativistic quantum mechanics described by the time-independent Schrödinger equation for the relative coordinate with reduced mass $\\mu$. Work in three spatial dimensions. Use the Lippmann–Schwinger equation in momentum space for the bound state and adopt a rank-one separable Yamaguchi interaction with form factor $g(\\mathbf{q})$ and coupling strength $\\lambda$ given by\n$V(\\mathbf{k},\\mathbf{k}') = -\\lambda\\, g(\\mathbf{k})\\, g(\\mathbf{k}'), \\quad g(\\mathbf{q}) = \\dfrac{1}{\\mathbf{q}^2 + \\beta^2},$\nwhere $\\beta$ is a fixed positive parameter expressed in inverse femtometers. Let $\\hbar$ denote the reduced Planck constant and $c$ the speed of light. Use the following physical constants and parameters:\n- $\\hbar c = 197.3269804\\ \\text{MeV}\\cdot\\text{fm}$,\n- proton mass $m_p = 938.2720813\\ \\text{MeV}/c^2$,\n- neutron mass $m_n = 939.5654133\\ \\text{MeV}/c^2$,\n- reduced mass $\\mu = \\dfrac{m_p m_n}{m_p + m_n}$,\n- Yamaguchi range parameter $\\beta = 1.4\\ \\text{fm}^{-1}$,\n- target infinite-volume deuteron binding energy $B_d^{(\\infty)} = 2.224575\\ \\text{MeV}$.\n\nIn infinite volume, the bound-state condition follows from the homogeneous Lippmann–Schwinger equation for the $T$-matrix and reduces, for the chosen separable interaction, to the pole condition\n$1 + \\lambda\\, J_{\\infty}(E) = 0,$\nwhere $E$ is the total energy in the center-of-mass frame (negative for a bound state) and\n$J_{\\infty}(E) = \\int \\dfrac{d^3 q}{(2\\pi)^3}\\, \\dfrac{g(\\mathbf{q})^2}{E - \\dfrac{(\\hbar c)^2 \\mathbf{q}^2}{2\\mu}}\\ .$\nIn finite volume with periodic boundary conditions in a cubic box of side $L$, the integral is replaced by a discrete sum over momenta $\\mathbf{q} = \\dfrac{2\\pi}{L}\\, \\mathbf{n}$ where $\\mathbf{n} \\in \\mathbb{Z}^3$, namely\n$J_{L}(E) = \\dfrac{1}{L^3} \\sum_{\\mathbf{n}\\in\\mathbb{Z}^3} \\dfrac{g\\!\\left(\\dfrac{2\\pi}{L}\\mathbf{n}\\right)^2}{E - \\dfrac{(\\hbar c)^2}{2\\mu}\\left(\\dfrac{2\\pi}{L}\\right)^2 \\|\\mathbf{n}\\|^2}\\ .$\nThe infinite-volume coupling $\\lambda$ must be chosen to reproduce the target binding energy $B_d^{(\\infty)}$ via the condition $1 + \\lambda\\, J_{\\infty}(-B_d^{(\\infty)}) = 0$. Then, for each finite $L$, the finite-volume binding energy $B_d(L)$ is defined by the unique negative-energy solution $E=-B_d(L)$ of $1 + \\lambda\\, J_L(E)=0$.\n\nAs $L \\to \\infty$, the finite-volume shift $\\Delta B_d(L) = B_d(L) - B_d^{(\\infty)}$ is expected to be exponentially small and controlled by the infinite-volume binding momentum $\\kappa = \\sqrt{\\dfrac{2\\mu B_d^{(\\infty)}}{(\\hbar c)^2}}$, with an asymptotic form $\\Delta B_d(L) \\propto \\dfrac{e^{-\\kappa L}}{L}$ up to subleading corrections. Your task is to implement a program that numerically:\n- calibrates $\\lambda$ from the infinite-volume condition at $E=-B_d^{(\\infty)}$ using the above $J_{\\infty}(E)$,\n- computes $B_d(L)$ for several $L$ values by solving $1 + \\lambda\\, J_L(E)=0$ with $E<0$,\n- estimates the finite-volume shifts $\\Delta B_d(L)$ and verifies the exponential-over-$L$ scaling by fitting $\\ln\\big(\\Delta B_d(L)\\, L\\big)$ versus $L$ to a straight line and extracting a numerical estimate of the slope $-\\,\\kappa_{\\text{fit}}$,\n- compares $\\kappa_{\\text{fit}}$ to the $\\kappa$ computed directly from $B_d^{(\\infty)}$ and $\\mu$.\n\nUse the following computational details to ensure a well-posed and self-contained calculation:\n- Use the discrete sum definition of $J_L(E)$ with a spherical momentum cutoff $\\Lambda$ in inverse femtometers applied to $\\|\\mathbf{q}\\| \\le \\Lambda$. Choose $\\Lambda = 6.0\\ \\text{fm}^{-1}$. Truncate the sum to all integer triplets $\\mathbf{n}$ such that $\\left\\|\\dfrac{2\\pi}{L}\\mathbf{n}\\right\\| \\le \\Lambda$; this ensures a finite and systematically improvable approximation to $J_L(E)$. No further extrapolation in $\\Lambda$ is required.\n- For $J_{\\infty}(E)$, perform the three-dimensional integral in spherical coordinates, i.e., $J_{\\infty}(E) = \\dfrac{1}{2\\pi^2}\\int_{0}^{\\infty} dq\\, \\dfrac{q^2}{E - \\dfrac{(\\hbar c)^2 q^2}{2\\mu}}\\dfrac{1}{(q^2+\\beta^2)^2}$, using a reliable numerical quadrature over $q \\in [0,\\infty)$ with sufficient accuracy to determine $\\lambda$.\n- Solve for $E=-B_d(L)$ at fixed $L$ by robust one-dimensional root finding in the negative-energy domain, using a bracket that safely encloses the root.\n\nAdopt the following test suite of box sizes (in femtometers):\n- Set $\\mathcal{A}$: $L \\in \\{12.0, 14.0, 16.0\\}$,\n- Set $\\mathcal{B}$: $L \\in \\{8.0, 10.0, 12.0\\}$,\n- Set $\\mathcal{C}$: $L \\in \\{6.0, 7.0, 8.0\\}$.\n\nFor each set, compute $\\Delta B_d(L)$ at the listed $L$ values, perform a linear least-squares fit of $y(L) = \\ln\\big(\\Delta B_d(L)\\, L\\big)$ versus $L$, and extract $\\kappa_{\\text{fit}}$ as the negative of the fitted slope. Also compute the reference $\\kappa$ from the reduced mass and $B_d^{(\\infty)}$ via $\\kappa = \\sqrt{\\dfrac{2\\mu B_d^{(\\infty)}}{(\\hbar c)^2}}$. All values of $\\kappa$ must be reported in inverse femtometers.\n\nPhysical and numerical units:\n- Energies must be computed and handled in $\\text{MeV}$.\n- Lengths and momentum-space cutoffs must be handled in $\\text{fm}$ and $\\text{fm}^{-1}$, respectively.\n- The final outputs must be expressed in $\\text{fm}^{-1}$.\n\nYour program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The required output is the list\n$[\\kappa,\\ \\kappa_{\\text{fit}}(\\mathcal{A}),\\ \\kappa_{\\text{fit}}(\\mathcal{B}),\\ \\kappa_{\\text{fit}}(\\mathcal{C})]$,\nin that order. Each entry must be a floating-point number in $\\text{fm}^{-1}$. The program must not read any input and must use the constants and parameters specified above. You may format the floating-point results with a fixed number of decimal places, but you must ensure they are valid decimal numerals. No other text should be printed.", "solution": "This problem uses the Lippmann-Schwinger equation in momentum space to analyze the deuteron bound state. The nuclear force is modeled by a simple rank-one separable potential, known as the Yamaguchi potential. This model allows for an analytic treatment that illuminates the connection between infinite-volume physics and calculations performed in a finite computational box.\n\nFirst, the strength of the potential, $\\lambda$, is calibrated. This is a crucial step in any effective theory: model parameters are fixed by matching to a known experimental observable. Here, we demand that the model reproduces the experimental deuteron binding energy, $B_d^{(\\infty)}$, in infinite volume. The condition for a bound state at energy $E = -B_d^{(\\infty)}$ is that the denominator of the scattering T-matrix vanishes, which for this potential simplifies to $1 + \\lambda J_\\infty(E) = 0$. The kernel $J_\\infty(E)$ involves an integral over all momenta, which can be computed numerically. By solving this equation for $\\lambda$, we fix the one free parameter of our model.\n\nNext, we move the problem into a finite cubic box of side length $L$ with periodic boundary conditions. This is a common setup for numerical simulations like lattice QCD. In a finite box, momentum is no longer continuous but becomes quantized: $\\mathbf{q} = \\frac{2\\pi}{L}\\mathbf{n}$ for integer vectors $\\mathbf{n}$. The integral in the kernel $J_\\infty(E)$ is replaced by a discrete sum over these allowed momenta, yielding a new kernel $J_L(E)$. This sum must be truncated at a high-momentum (ultraviolet) cutoff, $\\Lambda$, to be computationally feasible.\n\nWith the same coupling strength $\\lambda$ determined from the infinite-volume calculation, we can now find the binding energy in the finite volume, $B_d(L)$, by solving the finite-volume bound-state condition $1 + \\lambda J_L(E) = 0$ for its negative-energy root, $E = -B_d(L)$. This is typically done using a numerical root-finding algorithm.\n\nThe primary goal is to study the finite-volume correction, $\\Delta B_d(L) = B_d(L) - B_d^{(\\infty)}$, which is the difference between the energy in a box of size $L$ and the true physical energy. For a shallow bound state like the deuteron, theory predicts that this correction falls off exponentially with the box size: $\\Delta B_d(L) \\propto \\frac{e^{-\\kappa L}}{L}$. The decay rate, $\\kappa$, is the infinite-volume binding momentum, $\\kappa = \\sqrt{2\\mu B_d^{(\\infty)}/(\\hbar c)^2}$. To verify this behavior, we can rearrange the relation into a linear form, $\\ln(\\Delta B_d(L) \\cdot L) = \\text{const} - \\kappa L$. By computing $B_d(L)$ for several values of $L$, we can plot $\\ln(\\Delta B_d(L) \\cdot L)$ versus $L$ and perform a linear fit. The negative of the slope of this fit gives a numerical estimate of the binding momentum, $\\kappa_{\\text{fit}}$, which can then be compared to the value calculated directly from the experimental binding energy. This exercise provides a concrete demonstration of how physical, infinite-volume results are extracted from finite-volume simulations.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Solves the deuteron finite-volume binding energy problem as specified.\n    \"\"\"\n    # Physical constants and parameters\n    HBARC = 197.3269804  # MeV * fm\n    M_P = 938.2720813    # MeV/c^2\n    M_N = 939.5654133    # MeV/c^2\n    BETA = 1.4           # fm^-1\n    B_D_INF = 2.224575   # MeV\n    LAMBDA_CUTOFF = 6.0  # fm^-1\n\n    # Derived constants\n    MU = (M_P * M_N) / (M_P + M_N)\n    TWO_MU_OVER_HBARC_SQ = (2.0 * MU) / (HBARC**2) # fm^-2 / MeV\n\n    # --- Step 1: Calculate theoretical kappa ---\n    kappa_theory = np.sqrt(TWO_MU_OVER_HBARC_SQ * B_D_INF)\n    \n    # --- Step 2: Calibrate lambda from infinite-volume condition ---\n    \n    def integrand_J_infty(q, E):\n        \"\"\"Integrand for the J_infty integral.\"\"\"\n        # Using the formulation J = 1/(2pi^2) * int(...) dq\n        # The equation for J_infty in the problem is per d^3q/(2pi)^3\n        # J_inf = 1/(2pi^2) integral_0^inf dq q^2 * g(q)^2 / (E-T(q))\n        # This matches the provided spherical coordinate version.\n        g_q_sq = (1.0 / (q**2 + BETA**2))**2\n        T_q = q**2 / TWO_MU_OVER_HBARC_SQ\n        return (1.0 / (2.0 * np.pi**2)) * q**2 * g_q_sq / (E - T_q)\n\n    # Calculate J_infty at E = -B_d_inf\n    val_J_infty, _ = quad(integrand_J_infty, 0, np.inf, args=(-B_D_INF,), epsabs=1e-12, epsrel=1e-12)\n    \n    # Calculate lambda\n    lambda_coupling = -1.0 / val_J_infty\n\n    # --- Step 3: Functions for finite-volume calculation ---\n\n    # Store J_L results to avoid re-computation\n    j_l_cache = {}\n\n    def calc_J_L(E, L):\n        \"\"\"Calculates the finite-volume sum J_L(E).\"\"\"\n        if (E, L) in j_l_cache:\n            return j_l_cache[(E, L)]\n\n        n_sq_max_val = (L * LAMBDA_CUTOFF / (2.0 * np.pi))**2\n        n_max = int(np.floor(np.sqrt(n_sq_max_val)))\n        \n        total_sum = 0.0\n        \n        # Precompute constants for the loop\n        q_sq_factor = (2.0 * np.pi / L)**2\n        E_kin_factor = q_sq_factor / TWO_MU_OVER_HBARC_SQ\n\n        for nx in range(-n_max, n_max + 1):\n            for ny in range(-n_max, n_max + 1):\n                for nz in range(-n_max, n_max + 1):\n                    n_sq = float(nx**2 + ny**2 + nz**2)\n                    \n                    if n_sq > n_sq_max_val:\n                        continue\n                        \n                    q_sq = n_sq * q_sq_factor\n                    g_q_sq = (1.0 / (q_sq + BETA**2))**2\n                    \n                    E_kin = n_sq * E_kin_factor\n                    \n                    denominator = E - E_kin\n                    # The n=0 contribution has a pole at E=0.\n                    # This check is for robustness, though brentq should avoid E=0.\n                    if abs(denominator)  1e-15:\n                        total_sum += np.inf # Should signal issues\n                    else:\n                        total_sum += g_q_sq / denominator\n                        \n        result = total_sum / L**3\n        j_l_cache[(E, L)] = result\n        return result\n\n    def root_function(E, L):\n        \"\"\"Function whose root E gives the finite-volume energy.\"\"\"\n        return 1.0 + lambda_coupling * calc_J_L(E, L)\n\n    # --- Step 4: Calculate B_d(L) and fit for kappa ---\n\n    def calculate_kappa_fit(L_values):\n        \"\"\"\n        Calculates B_d(L) for a list of L values and performs the linear fit\n        to extract kappa_fit.\n        \"\"\"\n        delta_B_vals = []\n        \n        for L in L_values:\n            # Find the root E for B_d(L) = -E\n            # Bracket [-10, -0.1] safely encloses the root away from the E=0 pole.\n            try:\n                E_L = brentq(root_function, -10.0, -0.1, args=(L,), xtol=1e-12, rtol=1e-12)\n            except ValueError:\n                # This would happen if the function doesn't change sign in the bracket\n                print(f\"Error: Root not bracketed for L={L}.\")\n                return np.nan\n            \n            Bd_L = -E_L\n            delta_B = Bd_L - B_D_INF\n            delta_B_vals.append(delta_B)\n\n        y_fit = np.log(np.array(delta_B_vals) * np.array(L_values))\n        x_fit = np.array(L_values)\n        \n        # Perform linear fit: y = m*x + c\n        # np.polyfit returns [m, c]\n        slope, _ = np.polyfit(x_fit, y_fit, 1)\n        \n        kappa_fit = -slope\n        return kappa_fit\n\n    # Define test sets\n    test_sets = {\n        'A': [12.0, 14.0, 16.0],\n        'B': [8.0, 10.0, 12.0],\n        'C': [6.0, 7.0, 8.0]\n    }\n    \n    results = [kappa_theory]\n    for key in ['A', 'B', 'C']:\n        L_vals = test_sets[key]\n        kappa_fit = calculate_kappa_fit(L_vals)\n        results.append(kappa_fit)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(lambda x: f'{x:.8f}', results))}]\")\n\nsolve()\n```", "id": "3582632"}, {"introduction": "A physical theory is only as good as its ability to be constrained by experiment and make falsifiable predictions with quantified uncertainties. This final practice introduces you to Bayesian inference, a powerful statistical framework for calibrating the unknown parameters of a model—in this case, the low-energy constants of an effective field theory. Using a linearized model of deuteron properties, you will perform a Bayesian analysis to determine the posterior probability distribution of the model parameters based on experimental data. Furthermore, you will propagate the resulting parameter uncertainties to predictions for other observables like the quadrupole and magnetic moments [@problem_id:3582583], providing a complete and statistically sound picture of your model's predictive power.", "problem": "You will implement a linearized Bayesian calibration and uncertainty propagation for chiral Effective Field Theory (EFT) low-energy constants of the neutron-proton system, targeted to properties of the deuteron. Begin from Bayes’ theorem and the Gaussian-linear model assumptions to obtain the posterior distribution of the model parameters, then propagate that posterior to deuteron observables. Your program must be a complete, runnable program that produces the required outputs without any user input.\n\nThe unknown parameter vector is the pair of dimensionless low-energy constants $\\boldsymbol{\\theta} = [c_0, c_2]^{\\mathsf{T}}$. A first-order linearized surrogate (local emulator) maps $\\boldsymbol{\\theta}$ to low-energy data extracted from neutron-proton phase-shift analysis and to deuteron observables. The data vector consists of the triplet neutron-proton scattering length $a_t$ in femtometers, the triplet effective range $r_t$ in femtometers, and the deuteron binding energy $B_d$ in megaelectronvolts. The measurement model is\n$$\n\\mathbf{y} = \\mathbf{H}\\,\\boldsymbol{\\theta} + \\mathbf{b} + \\boldsymbol{\\varepsilon},\n$$\nwith Gaussian noise $\\boldsymbol{\\varepsilon}$ of zero mean and covariance matrix $\\mathbf{R}$. Use the following numerical values that are consistent with well-established empirical determinations:\n- The data vector is\n$$\n\\mathbf{y}_{\\text{exp}} = \\begin{bmatrix} a_t \\\\ r_t \\\\ B_d \\end{bmatrix}\n= \\begin{bmatrix} 5.419 \\\\ 1.753 \\\\ 2.224575 \\end{bmatrix},\n$$\nwhere $a_t$ and $r_t$ are in $\\mathrm{fm}$ and $B_d$ is in $\\mathrm{MeV}$.\n- The linear response matrix and baseline vector are\n$$\n\\mathbf{H} = \\begin{bmatrix}\n0.6  0.12 \\\\\n0.05  0.28 \\\\\n0.25  0.08\n\\end{bmatrix}, \\quad\n\\mathbf{b} = \\begin{bmatrix}\n5.419 \\\\ 1.753 \\\\ 2.224575\n\\end{bmatrix}.\n$$\n- The nominal data covariance is diagonal,\n$$\n\\mathbf{R} = \\mathrm{diag}\\left(\\sigma_a^2, \\sigma_r^2, \\sigma_B^2\\right),\n$$\nwith standard deviations $\\sigma_a = 0.01\\,\\mathrm{fm}$, $\\sigma_r = 0.005\\,\\mathrm{fm}$, and $\\sigma_B = 0.00001\\,\\mathrm{MeV}$.\n\nThe deuteron observables of interest are the quadrupole moment $Q_d$ in square femtometers, the magnetic dipole moment $\\mu_d$ in nuclear magnetons, and the charge radius $r_d$ in femtometers. Use a linearized surrogate map\n$$\n\\mathbf{z} = \\mathbf{L}\\,\\boldsymbol{\\theta} + \\mathbf{b}_z,\n$$\nwhere\n$$\n\\mathbf{L} = \\begin{bmatrix}\n0.006  0.020 \\\\\n0.001  -0.010 \\\\\n-0.050  -0.020\n\\end{bmatrix}, \\quad\n\\mathbf{b}_z = \\begin{bmatrix}\n0.2859 \\\\\n0.857438 \\\\\n2.127\n\\end{bmatrix},\n$$\nwith $Q_d$ in $\\mathrm{fm}^2$, $\\mu_d$ in nuclear magnetons, and $r_d$ in $\\mathrm{fm}$.\n\nAssume a Gaussian prior on $\\boldsymbol{\\theta}$ with mean $\\mathbf{m}_0$ and covariance $\\mathbf{S}_0$. Under the linear-Gaussian assumptions, use Bayes’ theorem to obtain the posterior for $\\boldsymbol{\\theta}$ given the data, and then propagate the posterior to the predictive distribution for $\\mathbf{z}$.\n\nNumerical units and outputs:\n- All inputs are provided in the units stated above and must be treated consistently.\n- Your program must report, for each specified test case, the posterior predictive mean and standard deviation for each of $Q_d$, $\\mu_d$, and $r_d$.\n- Express $Q_d$ mean and standard deviation in $\\mathrm{fm}^2$, $\\mu_d$ mean and standard deviation in nuclear magnetons, and $r_d$ mean and standard deviation in $\\mathrm{fm}$.\n- Round each reported number to exactly $6$ decimal places.\n\nTest suite specification:\nImplement three test cases that probe different prior-data regimes. For each case, use the same $\\mathbf{H}$, $\\mathbf{b}$, $\\mathbf{L}$, $\\mathbf{b}_z$, and $\\mathbf{y}_{\\text{exp}}$ given above, but vary the prior and the data covariance scaling as follows.\n- Case $1$ (data-dominated, neutral prior):\n  - Prior mean $\\mathbf{m}_0 = [0, 0]^{\\mathsf{T}}$.\n  - Prior covariance $\\mathbf{S}_0 = \\mathrm{diag}([0.5^2, 0.5^2])$.\n  - Data covariance scaling factor $s_R = 1$, meaning use $\\mathbf{R}$ as given.\n- Case $2$ (informative prior shifted from zero):\n  - Prior mean $\\mathbf{m}_0 = [0.5, -0.3]^{\\mathsf{T}}$.\n  - Prior covariance $\\mathbf{S}_0 = \\mathrm{diag}([0.2^2, 0.2^2])$.\n  - Data covariance scaling factor $s_R = 1$.\n- Case $3$ (prior-dominated via inflated data uncertainty):\n  - Prior mean $\\mathbf{m}_0 = [0, 0]^{\\mathsf{T}}$.\n  - Prior covariance $\\mathbf{S}_0 = \\mathrm{diag}([1.0^2, 1.0^2])$.\n  - Data covariance scaling factor $s_R = 100$, meaning replace $\\mathbf{R}$ by $s_R \\mathbf{R}$.\n\nFor each case:\n1. Compute the posterior mean and covariance of $\\boldsymbol{\\theta}$ given the specified prior and data model.\n2. Compute the predictive mean and covariance of $\\mathbf{z}$ by propagating the posterior through the linear map.\n3. Extract, in the stated units, the predictive mean and standard deviation (square root of the predictive covariance diagonal) of $Q_d$, $\\mu_d$, and $r_d$.\n4. Round each to exactly $6$ decimal places.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Concatenate the results for the three cases in order. For each case, list the six numbers in the order\n$$\n[ \\overline{Q}_d, \\sigma(Q_d), \\overline{\\mu}_d, \\sigma(\\mu_d), \\overline{r}_d, \\sigma(r_d) ].\n$$\nThus the full output is a flat list of $18$ numbers:\n$$\n[\\text{case 1 six numbers}, \\text{case 2 six numbers}, \\text{case 3 six numbers}],\n$$\neach rounded to $6$ decimal places, with no additional text.", "solution": "This problem requires the implementation of a Bayesian calibration and uncertainty propagation procedure for a linearized model derived from chiral Effective Field Theory (EFT). The parameters of the model are the dimensionless low-energy constants (LECs) $\\boldsymbol{\\theta} = [c_0, c_2]^{\\mathsf{T}}$. The process involves using Bayes' theorem to update the knowledge about $\\boldsymbol{\\theta}$ based on experimental data, and then propagating the resulting posterior uncertainty to predictions for other deuteron observables.\n\nThe problem is cast within the framework of Bayesian inference. The central tenet is Bayes' theorem, which relates the posterior probability of the parameters $\\boldsymbol{\\theta}$ given the experimental data $\\mathbf{y}_{\\text{exp}}$ to the likelihood of the data and the prior probability of the parameters:\n$$\np(\\boldsymbol{\\theta} | \\mathbf{y}_{\\text{exp}}) \\propto p(\\mathbf{y}_{\\text{exp}} | \\boldsymbol{\\theta}) \\, p(\\boldsymbol{\\theta})\n$$\nThe prior knowledge about the parameters $p(\\boldsymbol{\\theta})$ is specified as a multivariate Gaussian distribution $\\mathcal{N}(\\boldsymbol{\\theta} | \\mathbf{m}_0, \\mathbf{S}_0)$. The likelihood $p(\\mathbf{y}_{\\text{exp}} | \\boldsymbol{\\theta})$ is derived from the linear measurement model $\\mathbf{y} = \\mathbf{H}\\,\\boldsymbol{\\theta} + \\mathbf{b} + \\boldsymbol{\\varepsilon}$, where the noise $\\boldsymbol{\\varepsilon}$ is also Gaussian, $\\mathcal{N}(\\mathbf{0}, \\mathbf{R})$. This implies a Gaussian likelihood, $\\mathbf{y} | \\boldsymbol{\\theta} \\sim \\mathcal{N}(\\mathbf{H}\\,\\boldsymbol{\\theta} + \\mathbf{b}, \\mathbf{R})$.\n\nBecause both the prior and the likelihood are Gaussian, the posterior distribution $p(\\boldsymbol{\\theta} | \\mathbf{y}_{\\text{exp}})$ is also Gaussian, denoted $\\mathcal{N}(\\boldsymbol{\\theta} | \\mathbf{m}_1, \\mathbf{S}_1)$. The posterior covariance $\\mathbf{S}_1$ and mean $\\mathbf{m}_1$ are given by the standard formulas for a linear-Gaussian model update:\n$$\n\\mathbf{S}_1 = (\\mathbf{S}_0^{-1} + \\mathbf{H}^{\\mathsf{T}}\\mathbf{R}^{-1}\\mathbf{H})^{-1}\n$$\n$$\n\\mathbf{m}_1 = \\mathbf{S}_1 \\left( \\mathbf{S}_0^{-1}\\mathbf{m}_0 + \\mathbf{H}^{\\mathsf{T}}\\mathbf{R}^{-1}(\\mathbf{y}_{\\text{exp}} - \\mathbf{b}) \\right)\n$$\nA key simplification in this problem is that the experimental data vector $\\mathbf{y}_{\\text{exp}}$ is set to be equal to the model baseline $\\mathbf{b}$. This makes the term $(\\mathbf{y}_{\\text{exp}} - \\mathbf{b})$ a zero vector, simplifying the posterior mean to $\\mathbf{m}_1 = \\mathbf{S}_1 (\\mathbf{S}_0^{-1}\\mathbf{m}_0)$.\n\nThe final step is to use the posterior distribution of $\\boldsymbol{\\theta}$ to make predictions for a new set of observables $\\mathbf{z} = [Q_d, \\mu_d, r_d]^{\\mathsf{T}}$, which are related to the parameters by another linear model: $\\mathbf{z} = \\mathbf{L}\\,\\boldsymbol{\\theta} + \\mathbf{b}_z$. The predictive distribution for $\\mathbf{z}$ is found by propagating the posterior of $\\boldsymbol{\\theta}$ through this linear map. Since $\\boldsymbol{\\theta}$ follows a Gaussian distribution, the distribution for $\\mathbf{z}$ will also be Gaussian, $p(\\mathbf{z} | \\mathbf{y}_{\\text{exp}}) = \\mathcal{N}(\\mathbf{z} | \\mathbf{m}_z, \\mathbf{S}_z)$. The predictive mean $\\mathbf{m}_z$ and covariance $\\mathbf{S}_z$ are given by the laws of linear transformation of random variables:\n$$\n\\mathbf{m}_z = \\mathbf{L}\\mathbf{m}_1 + \\mathbf{b}_z\n$$\n$$\n\\mathbf{S}_z = \\mathbf{L}\\mathbf{S}_1\\mathbf{L}^{\\mathsf{T}}\n$$\nThe required outputs are the predictive means for each observable (the elements of $\\mathbf{m}_z$) and their corresponding standard deviations (the square roots of the diagonal elements of $\\mathbf{S}_z$). The procedure is repeated for three distinct cases that explore different balances between the influence of the prior information and the experimental data.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a linearized Bayesian calibration for chiral EFT LECs.\n    \"\"\"\n    # --- Define constants from the problem statement ---\n    # Linear response matrix for calibration data\n    H = np.array([\n        [0.6, 0.12],\n        [0.05, 0.28],\n        [0.25, 0.08]\n    ])\n    \n    # Baseline vector for calibration data (equal to y_exp)\n    b = np.array([5.419, 1.753, 2.224575])\n    y_exp = b # Experimental data vector\n    \n    # Standard deviations for the calibration data\n    sigma_a = 0.01  # fm\n    sigma_r = 0.005  # fm\n    sigma_B = 0.00001  # MeV\n    \n    # Base data covariance matrix (diagonal)\n    R_base = np.diag([sigma_a**2, sigma_r**2, sigma_B**2])\n    \n    # Linear response matrix for predicted observables\n    L = np.array([\n        [0.006, 0.020],   # Q_d\n        [0.001, -0.010],  # mu_d\n        [-0.050, -0.020]  # r_d\n    ])\n    \n    # Baseline vector for predicted observables\n    b_z = np.array([0.2859, 0.857438, 2.127])\n\n    # --- Define the test cases ---\n    test_cases = [\n        # Case 1: data-dominated, neutral prior\n        {\n            \"m0\": np.array([0.0, 0.0]),\n            \"S0_diag\": np.array([0.5**2, 0.5**2]),\n            \"sR\": 1.0\n        },\n        # Case 2: informative prior shifted from zero\n        {\n            \"m0\": np.array([0.5, -0.3]),\n            \"S0_diag\": np.array([0.2**2, 0.2**2]),\n            \"sR\": 1.0\n        },\n        # Case 3: prior-dominated via inflated data uncertainty\n        {\n            \"m0\": np.array([0.0, 0.0]),\n            \"S0_diag\": np.array([1.0**2, 1.0**2]),\n            \"sR\": 100.0\n        }\n    ]\n\n    all_results = []\n    \n    # --- Process each test case ---\n    for case in test_cases:\n        m0 = case[\"m0\"]\n        S0 = np.diag(case[\"S0_diag\"])\n        sR = case[\"sR\"]\n        \n        # 1. Construct data covariance matrix for this case\n        R = sR * R_base\n        \n        # 2. Compute inverses (numerically stable for diagonal matrices)\n        S0_inv = np.diag(1.0 / case[\"S0_diag\"])\n        R_inv = np.diag(1.0 / np.diag(R))\n        \n        # 3. Calculate posterior distribution for theta\n        # Posterior covariance S1 = (S0^-1 + H^T * R^-1 * H)^-1\n        posterior_cov_inv = S0_inv + H.T @ R_inv @ H\n        posterior_cov = np.linalg.inv(posterior_cov_inv)\n        \n        # Posterior mean m1 = S1 * (S0^-1 * m0 + H^T * R^-1 * (y_exp - b))\n        # Since y_exp = b, the second term in the parenthesis is zero.\n        posterior_mean = posterior_cov @ (S0_inv @ m0)\n\n        # 4. Propagate to predictive distribution for z\n        # Predictive mean mz = L * m1 + bz\n        predictive_mean = L @ posterior_mean + b_z\n        \n        # Predictive covariance Sz = L * S1 * L^T\n        predictive_cov = L @ posterior_cov @ L.T\n        \n        # 5. Extract means and standard deviations\n        predictive_stds = np.sqrt(np.diag(predictive_cov))\n        \n        # 6. Store results for this case\n        # Order: mean_Qd, std_Qd, mean_mu_d, std_mu_d, mean_r_d, std_r_d\n        results_for_case = []\n        for i in range(3):\n            results_for_case.append(predictive_mean[i])\n            results_for_case.append(predictive_stds[i])\n        \n        all_results.extend(results_for_case)\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"{num:.6f}\" for num in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3582583"}]}