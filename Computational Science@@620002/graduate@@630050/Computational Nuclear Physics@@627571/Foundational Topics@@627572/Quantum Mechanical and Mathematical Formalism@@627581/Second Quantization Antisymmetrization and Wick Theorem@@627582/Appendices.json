{"hands_on_practices": [{"introduction": "The power of second quantization lies in its algebraic framework for handling complex many-body systems. This practice guides you in building a foundational computational tool: a symbolic manipulator that automates the application of Wick's theorem to normal-order arbitrary operator strings. Mastering this process is a cornerstone for deriving and implementing the advanced many-body methods used in modern computational nuclear physics. [@problem_id:3589337]", "problem": "You are to write a complete, runnable program that constructs a symbolic manipulator for fermionic second-quantized operators tailored to computational nuclear physics. The manipulator must enforce canonical fermionic anti-commutation relations and perform generalized normal-ordering with respect to a fixed Slater determinant reference state. It must validate its internal logic against identities known from Many-Body Perturbation Theory (MBPT). Your program must be fully self-contained and produce a single-line output aggregating the results of prescribed test cases.\n\nThe computational basis consists of a finite set of single-particle orbitals labeled by integers. The elementary operators are fermionic annihilation operators $a_p$ and creation operators $a_p^\\dagger$, where $p$ is a single-particle orbital index. They satisfy the canonical anti-commutation relations\n$$\n\\{a_p, a_q^\\dagger\\} = \\delta_{pq}, \\quad \\{a_p, a_q\\} = 0, \\quad \\{a_p^\\dagger, a_q^\\dagger\\} = 0,\n$$\nwhere $\\delta_{pq}$ is the Kronecker delta.\n\nDefine a reference Slater determinant $\\lvert \\Phi_0 \\rangle$ by an occupation map $n_p \\in \\{0,1\\}$ for each orbital $p$. Expectation values $\\langle \\Phi_0 | \\cdot | \\Phi_0 \\rangle$ are taken with respect to this reference. Generalized normal-ordering with respect to $\\lvert \\Phi_0 \\rangle$ is defined so that the expectation value of any normal-ordered product vanishes:\n$$\n\\langle \\Phi_0 | \\, : \\! \\mathcal{O} \\! : \\, | \\Phi_0 \\rangle = 0.\n$$\nFor the purpose of algorithmic implementation, define pairwise contractions as the reference expectation values of pairs:\n$$\n\\contraction{}{a_p^\\dagger}{}{a_q} a_p^\\dagger a_q \\equiv \\langle \\Phi_0 | a_p^\\dagger a_q | \\Phi_0 \\rangle = n_p \\, \\delta_{pq},\n$$\n$$\n\\contraction{}{a_p}{}{a_q^\\dagger} a_p a_q^\\dagger \\equiv \\langle \\Phi_0 | a_p a_q^\\dagger | \\Phi_0 \\rangle = (1-n_q) \\, \\delta_{pq},\n$$\nand all other pairwise contractions are zero. Use Wick's theorem (generalized to a Slater determinant reference) to expand any operator product into a sum of its normal-ordered part plus all possible contractions with correct fermionic signs.\n\nYour manipulator must:\n- Represent operator strings as sequences of operators $a_p$ or $a_p^\\dagger$.\n- Enforce anti-commutation implicitly via graded swaps of adjacent operators combined with contraction terms arising from the canonical anti-commutators.\n- Compute the generalized normal-ordered expansion of any input operator string using Wick's theorem, including all partial contractions, with the sign for contracting operators at positions $i<j$ given by $(-1)^{j-i-1}$.\n- Aggregate expansions as dictionaries from normal-ordered operator strings to scalar coefficients, where the empty operator string represents a scalar (c-number) term.\n\nYou must validate your implementation against a set of Many-Body Perturbation Theory identities and fundamental properties. Fix the orbital set $\\{0,1,2\\}$ and the reference occupation numbers\n$$\nn_0 = 1, \\quad n_1 = 0, \\quad n_2 = 1,\n$$\nso that the reference has $2$ occupied orbitals. Use this fixed reference in all tests. You must implement and evaluate the following test suite:\n\n- Test A (operator-level anti-commutation at a hole index): Verify that the anti-commutator expansion of $\\{a_0, a_0^\\dagger\\}$ reduces exactly to a pure scalar equal to $1$, with no residual operator terms.\n- Test B (operator-level anti-commutation at a particle index): Verify that the anti-commutator expansion of $\\{a_1, a_1^\\dagger\\}$ reduces exactly to a pure scalar equal to $1$, with no residual operator terms.\n- Test C (two-body density of a Slater determinant, direct minus exchange): Compute the expectation value\n$$\n\\langle \\Phi_0 | a_0^\\dagger a_2^\\dagger a_2 a_0 | \\Phi_0 \\rangle,\n$$\nand verify that it equals $n_0 n_2 \\left(\\delta_{0,0} \\delta_{2,2} - \\delta_{0,2} \\delta_{2,0}\\right)$, which simplifies to $1$ under the given occupations and indices.\n- Test D (two-body density with mismatched indices): Compute\n$$\n\\langle \\Phi_0 | a_0^\\dagger a_2^\\dagger a_2 a_1 | \\Phi_0 \\rangle,\n$$\nand verify that it equals $n_0 n_2 \\left(\\delta_{0,1} \\delta_{2,2} - \\delta_{0,2} \\delta_{2,1}\\right)$, which simplifies to $0$.\n- Test E (normal-ordered number operator zero-body term): Define the particle-number operator\n$$\n\\hat{N} = \\sum_{p \\in \\{0,1,2\\}} a_p^\\dagger a_p.\n$$\nCompute its generalized normal-ordered expansion and verify that its scalar (c-number) term equals $\\sum_{p} n_p = 2$.\n- Test F (Pauli exclusion in a four-operator expectation): Compute\n$$\n\\langle \\Phi_0 | a_0^\\dagger a_0^\\dagger a_0 a_0 | \\Phi_0 \\rangle,\n$$\nand verify that it equals $0$.\n\nImplementation requirements:\n- Represent an operator as a pair $(\\mathrm{type}, p)$ where $\\mathrm{type} \\in \\{\\text{\"c\"}, \\text{\"a\"}\\}$ indicates $a_p^\\dagger$ and $a_p$, respectively.\n- Define a routine that, given a list of such operators, returns the generalized normal-ordered expansion as a dictionary from tuples of operators (already normal-ordered with all $a_p^\\dagger$ to the left of all $a_q$) to scalar coefficients. The scalar term is the dictionary key given by the empty tuple.\n- Use Wick's theorem recursively by contracting only with the leftmost remaining operator at each recursion level to avoid double counting. For a contraction between positions $i$ and $j$ with $i<j$, multiply by the factor $(-1)^{j-i-1}$ and the appropriate contraction value based on the above rules. The no-contraction branch contributes the purely reordered normal-ordered operator tuple with a sign equal to the parity of the required graded swaps, ignoring the $\\delta_{pq}$ terms.\n- Define an expectation-value routine that extracts the scalar term of the Wick-expanded expression; since the expectation of any normal-ordered non-scalar term is zero, this equals the sum of all completely contracted contributions.\n\nYour program must run without any external input and produce a single line of output containing a list of booleans in the order $[A,B,C,D,E,F]$, where each entry indicates whether the corresponding test passes. The output must be formatted as a Python list literal with no spaces, for example, $[ \\text{True}, \\text{False}, \\ldots ]$. The results must be exact integers or booleans; no physical units or angles are involved in this task.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4,result5,result6]\").", "solution": "The user requests the creation of a symbolic manipulator for fermionic second-quantized operators. The core of this task is to implement a function that computes the generalized normal-ordered expansion of a product of creation and annihilation operators using Wick's theorem, with respect to a given Slater determinant reference state.\n\nThe fundamental entities are the fermionic creation operator, $a_p^\\dagger$, and the annihilation operator, $a_p$, where $p$ is an integer labeling a single-particle orbital. These operators obey the canonical anti-commutation relations (CAR):\n$$\n\\{a_p, a_q^\\dagger\\} = a_p a_q^\\dagger + a_q^\\dagger a_p = \\delta_{pq}\n$$\n$$\n\\{a_p, a_q\\} = 0, \\quad \\{a_p^\\dagger, a_q^\\dagger\\} = 0\n$$\n\nThe reference state, $|\\Phi_0\\rangle$, is a Slater determinant defined by a set of occupation numbers, $n_p$, where $n_p=1$ if orbital $p$ is occupied in $|\\Phi_0\\rangle$ and $n_p=0$ otherwise.\n\nA normal-ordered product of operators, denoted by $: \\dots :$, is defined such that all creation operators are placed to the left of all annihilation operators. To ensure a unique representation, we further stipulate that operators of the same type are sorted by their orbital index. For instance, $:a_1^\\dagger a_0^\\dagger a_2 a_0: = -a_0^\\dagger a_1^\\dagger a_0 a_2$. The sign change arises from the anticommutation of operators.\n\nWick's theorem for a general reference state $|\\Phi_0\\rangle$ states that any product of creation and annihilation operators can be expressed as a sum over all possible normal-ordered products with contractions. A contraction of two operators is their expectation value in the reference state:\n$$\n\\contraction{}{A}{}{B} AB \\equiv \\langle \\Phi_0 | AB | \\Phi_0 \\rangle\n$$\nFor the elementary fermionic operators, a non-zero contraction only occurs between a creation and an annihilation operator:\n$$\n\\langle \\Phi_0 | a_p^\\dagger a_q | \\Phi_0 \\rangle = n_p \\delta_{pq}\n$$\n$$\n\\langle \\Phi_0 | a_p a_q^\\dagger | \\Phi_0 \\rangle = \\langle \\Phi_0 | \\delta_{pq} - a_q^\\dagger a_p | \\Phi_0 \\rangle = (1 - n_q) \\delta_{pq}\n$$\nAll other pairwise contractions, $\\langle a_p a_q \\rangle$ and $\\langle a_p^\\dagger a_q^\\dagger \\rangle$, are zero.\n\nThe expansion of an operator product $O_1 O_2 \\dots O_N$ is given by:\n$$\nO_1 O_2 \\dots O_N = \\sum_{\\text{all contractions}} (\\text{sign}) \\times (\\text{product of contractions}) \\times :(\\text{product of uncontracted operators}):\n$$\n\nTo implement this, we can employ a recursive strategy. Consider the expansion of a product $O_1 O_2 \\dots O_N$. The leftmost operator, $O_1$, is either not contracted or is contracted with some other operator $O_j$ ($j > 1$). This leads to a recursive formula:\n$$\n\\text{Expand}(O_1 O_2 \\dots O_N) = \\text{NormalOrder}(O_1 \\cdot \\text{Expand}(O_2 \\dots O_N)) + \\sum_{j=2}^{N} (-1)^{j-2} \\langle O_1 O_j \\rangle_c \\cdot \\text{Expand}(O_2 \\dots O_{j-1}O_{j+1} \\dots O_N)\n$$\nThe sign factor $(-1)^{j-2}$ (or $(-1)^{k-1}$ for contracting operators at 0-indexed positions $0$ and $k$) arises from permuting $O_1$ past $k-1$ other operators to bring it next to $O_k$. The term `NormalOrder` involves moving $O_1$ into its canonical position within each normal-ordered term of the expansion of the remainder, accumulating a sign from the necessary permutations.\n\nThe overall algorithm is implemented as a function, `wick_expand`, which takes a list of operators and returns a dictionary. This dictionary maps tuples of normal-ordered operators to their scalar coefficients. The empty tuple `()` is used as the key for the pure scalar (c-number) part of the expansion.\n\nThe main steps of the `wick_expand` function for a given operator list are:\n1.  **Base Case**: If the list is empty, it represents the scalar $1$. The function returns a dictionary `{(): 1}`.\n2.  **Memoization**: To handle the overlapping subproblems inherent in the recursion, results for previously-seen operator lists are cached.\n3.  **Recursive Step**:\n    a.  The first operator, $O_1_$, is separated from the rest of the list, $R = O_2 O_3 \\dots O_N$.\n    b.  **Contraction Terms**: The function iterates through each operator $O_j$ in $R$. If the contraction $\\langle O_1 O_j \\rangle_c$ is non-zero, it computes the contribution. This contribution is the product of the contraction value, the sign factor, and the recursive expansion of the list with $O_1$ and $O_j$ removed.\n    c.  **No-Contraction Term**: The function recursively expands the rest of the list, $R$. For each term in this sub-expansion, it inserts $O_1$ into the normal-ordered operator string, determining the correct sign from the number of permutations required.\n    d.  All contributions are summed into a final dictionary, which is then cached and returned.\n\nThe program then defines the specific reference state ($n_0=1, n_1=0, n_2=1$) and executes a suite of six tests to validate the implementation against known identities from many-body theory, such as the value of the canonical anti-commutator, two-body densities, the expectation value of the number operator, and the Pauli exclusion principle. The boolean result of each test is collected and printed in the specified format.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import defaultdict\n\ndef solve():\n    \"\"\"\n    Main solver function to set up and run the validation tests.\n    \"\"\"\n    OCCUPATIONS = {0: 1, 1: 0, 2: 1}\n    WICK_MEMO = {}\n\n    def get_contraction_value(op1, op2):\n        \"\"\"\n        Calculates the value of a contraction <op1 op2>.\n        op: a tuple (type, p_index) where type is 'c' or 'a'.\n        \"\"\"\n        type1, p1 = op1\n        type2, p2 = op2\n\n        if p1 != p2:\n            return 0\n        \n        if type1 == 'c' and type2 == 'a':\n            # <a_p^\\dagger a_p> = n_p\n            return OCCUPATIONS.get(p1, 0)\n        elif type1 == 'a' and type2 == 'c':\n            # <a_p a_p^\\dagger> = 1 - n_p\n            return 1 - OCCUPATIONS.get(p2, 0)\n        else:\n            # <a a> or <a^\\dagger a^\\dagger> are 0\n            return 0\n\n    def insert_and_normal_order(op, op_tuple):\n        \"\"\"\n        Inserts an operator into an already normal-ordered tuple,\n        returning the new tuple and the sign of the permutation.\n        Canonical order: creation ops, then annihilation ops, both sorted by index.\n        \"\"\"\n        op_list = list(op_tuple)\n        op_type, op_p = op\n        \n        insert_idx = 0\n        if op_type == 'c':\n            for i, current_op in enumerate(op_list):\n                if current_op[0] == 'a' or (current_op[0] == 'c' and current_op[1] > op_p):\n                    insert_idx = i\n                    break\n            else:\n                insert_idx = len(op_list)\n        else: # op_type == 'a'\n            first_a_idx = 0\n            try:\n                # Find where annihilation operators start\n                first_a_idx = [o[0] for o in op_list].index('a')\n            except ValueError:\n                first_a_idx = len(op_list)\n\n            insert_idx = first_a_idx\n            for i in range(first_a_idx, len(op_list)):\n                current_op = op_list[i]\n                if current_op[1] > op_p:\n                    insert_idx = i\n                    break\n            else:\n                insert_idx = len(op_list)\n        \n        swaps = insert_idx\n        sign = 1 if swaps % 2 == 0 else -1\n        \n        new_list = op_list[:insert_idx] + [op] + op_list[insert_idx:]\n        return tuple(new_list), sign\n\n    def wick_expand(op_list):\n        \"\"\"\n        Recursively computes the Wick expansion of a list of operators.\n        Returns a dict mapping normal-ordered operator tuples to coefficients.\n        \"\"\"\n        op_tuple = tuple(op_list)\n        if op_tuple in WICK_MEMO:\n            return WICK_MEMO[op_tuple]\n\n        if not op_list:\n            return {(): 1}\n\n        total_expansion = defaultdict(int)\n        \n        op1 = op_list[0]\n        rest_list = op_list[1:]\n\n        # --- Contraction part ---\n        for j, opj in enumerate(rest_list):\n            contract_val = get_contraction_value(op1, opj)\n            if contract_val != 0:\n                sign = 1 if j % 2 == 0 else -1\n                \n                sub_list = rest_list[:j] + rest_list[j+1:]\n                rem_expansion = wick_expand(sub_list)\n                \n                prefactor = sign * contract_val\n                for rem_ops, rem_coeff in rem_expansion.items():\n                    total_expansion[rem_ops] += prefactor * rem_coeff\n\n        # --- No-contraction part ---\n        rem_expansion = wick_expand(rest_list)\n        for rem_ops, rem_coeff in rem_expansion.items():\n            new_ops, sign = insert_and_normal_order(op1, rem_ops)\n            total_expansion[new_ops] += sign * rem_coeff\n        \n        # Clean up zero-coefficient terms\n        final_expansion = {k: v for k, v in total_expansion.items() if v != 0}\n        WICK_MEMO[op_tuple] = final_expansion\n        return final_expansion\n\n    def add_expansions(exp1, exp2):\n        \"\"\"Adds two expansion dictionaries.\"\"\"\n        res = defaultdict(int, exp1)\n        for ops, coeff in exp2.items():\n            res[ops] += coeff\n        return {k: v for k, v in res.items() if v != 0}\n\n    def get_expectation_value(op_list):\n        \"\"\"Computes the expectation value, which is the scalar part of the expansion.\"\"\"\n        expansion = wick_expand(op_list)\n        return expansion.get((), 0)\n\n    # --- Test Suite ---\n    results = []\n\n    # Test A: {a_0, a_0_dagger} = 1\n    exp1_A = wick_expand([('a', 0), ('c', 0)])\n    exp2_A = wick_expand([('c', 0), ('a', 0)])\n    total_exp_A = add_expansions(exp1_A, exp2_A)\n    results.append(total_exp_A == {(): 1})\n\n    # Test B: {a_1, a_1_dagger} = 1\n    exp1_B = wick_expand([('a', 1), ('c', 1)])\n    exp2_B = wick_expand([('c', 1), ('a', 1)])\n    total_exp_B = add_expansions(exp1_B, exp2_B)\n    results.append(total_exp_B == {(): 1})\n    \n    # Test C: <a_0_dagger a_2_dagger a_2 a_0> = 1\n    val_C = get_expectation_value([('c', 0), ('c', 2), ('a', 2), ('a', 0)])\n    results.append(val_C == 1)\n\n    # Test D: <a_0_dagger a_2_dagger a_2 a_1> = 0\n    val_D = get_expectation_value([('c', 0), ('c', 2), ('a', 2), ('a', 1)])\n    results.append(val_D == 0)\n\n    # Test E: Scalar term of Normal-ordered N_hat is sum(n_p) = 2\n    N_hat_expansion = {}\n    for p in [0, 1, 2]:\n        exp_p = wick_expand([('c', p), ('a', p)])\n        N_hat_expansion = add_expansions(N_hat_expansion, exp_p)\n    val_E = N_hat_expansion.get((), 0)\n    results.append(val_E == 2)\n\n    # Test F: Pauli exclusion <a_0_dagger a_0_dagger a_0 a_0> = 0\n    val_F = get_expectation_value([('c', 0), ('c', 0), ('a', 0), ('a', 0)])\n    results.append(val_F == 0)\n    \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3589337"}, {"introduction": "A notorious challenge in fermionic many-body calculations is correctly tracking the \"minus signs\" that arise from particle exchange, a task where errors can easily proliferate. This exercise provides a deep dive into the combinatorial origin of these signs by having you implement and compare two distinct algorithms for computing the sign of a fully contracted term. Developing a robust understanding of this sign structure is essential for writing correct and reliable many-body simulation codes. [@problem_id:3589384]", "problem": "You are to implement a robust parity-tracking system for fermionic operator contraction networks arising from the application of Wick’s theorem in second quantization. The goal is to compute the overall fermionic sign associated with a complete contraction of a product of creation and annihilation operators and to validate the implementation on carefully chosen test cases, including large fourth-order energy contraction networks.\n\nMathematical and physical foundation:\n- Consider a sequence of fermionic operators $\\{ \\hat{O}_1, \\hat{O}_2, \\dots, \\hat{O}_{2n} \\}$, each being either a creation operator $\\hat{a}^\\dagger$ or an annihilation operator $\\hat{a}$, acting on a reference Slater determinant. They satisfy the canonical anticommutation relations (CAR): $\\{ \\hat{a}_p, \\hat{a}_q \\} = 0$, $\\{ \\hat{a}_p^\\dagger, \\hat{a}_q^\\dagger \\} = 0$, and $\\{ \\hat{a}_p, \\hat{a}_q^\\dagger \\} = \\delta_{pq}$.\n- A complete contraction is defined by a perfect matching (pairing) of the operator positions into $n$ pairs, where each pair connects an annihilation operator to a creation operator. The vacuum (or reference) expectation of a fully contracted product is nonzero only for such pairings.\n- According to Wick’s theorem for fermions, the sign of any completely contracted term equals $(-1)^{N_{\\mathrm{perm}}}$, where $N_{\\mathrm{perm}}$ is the number of pairwise transpositions of adjacent fermionic operators required to transform the original operator sequence into a canonical order consistent with executing the specified contractions. Equivalently, when every pair is written as $(i,j)$ with $i<j$, the sign equals $(-1)^{N_{\\mathrm{cross}}}$, where $N_{\\mathrm{cross}}$ is the number of pairwise crossings among the pairs, i.e., the number of pairs of pairs $((i,j),(k,l))$ with $i<k<j<l$. This equivalence follows from the canonical anticommutation relations and Wick’s theorem.\n\nYour program must:\n1) Implement a function that computes the fermionic sign using a swap-count algorithm based on operator removals:\n   - Normalize each pair $(i,j)$ so that $i<j$.\n   - Process pairs in ascending order of their right endpoints $j$.\n   - Maintain the current active order of operator positions (initially $[0,1,\\dots,2n-1]$).\n   - For each pair $(i,j)$, compute the number of active operators strictly between $i$ and $j$ at the time of contraction. Each such operator passed over requires one swap of fermionic operators and flips the sign. Then remove $i$ and $j$ from the active list and continue.\n   - Return $+1$ if the total number of swaps is even, and $-1$ if it is odd.\n2) Independently implement a function that computes the sign as $(-1)^{N_{\\mathrm{cross}}}$ using only the crossing count, where $N_{\\mathrm{cross}}$ is the number of pairs of pairs $((i,j),(k,l))$ with $i<k<j<l$ after normalizing all pairs so $i<j$.\n3) Validate that both methods return identical signs for each test case and that they match the expected sign.\n\nRepresentation:\n- An operator sequence is given as a string over the alphabet $\\{-,+\\}$ of length $2n$, where $-$ represents an annihilation operator $\\hat{a}$ and $+$ represents a creation operator $\\hat{a}^\\dagger$.\n- A pairing is specified as a list of index pairs $(i,j)$ using zero-based indices, each pair connecting positions $i$ and $j$ in the operator string. You must normalize so that $i<j$ internally. The test cases below are constructed so that each pair is between a $-$ on the left and a $+$ on the right.\n\nTest suite:\nFor each case, compute the sign using both methods and compare to the expected sign. The required output is a list of boolean values, each indicating whether the case passes both checks.\n\n- Case A (empty product):\n  - Operators: empty string (length $0$).\n  - Pairs: $\\varnothing$.\n  - Expected sign: $+1$.\n\n- Case B (adjacent non-crossing):\n  - Operators: \"-+\" (length $2$).\n  - Pairs: $(0,1)$.\n  - Expected sign: $+1$.\n\n- Case C (single crossing on a short string):\n  - Operators: \"--++\" (length $4$).\n  - Pairs: $(0,2),(1,3)$.\n  - Expected sign: $-1$.\n\n- Case D (nested, non-crossing):\n  - Operators: \"--++\" (length $4$).\n  - Pairs: $(0,3),(1,2)$.\n  - Expected sign: $+1$.\n\n- Case E (fourth-order, $8$ pairs, completely non-crossing “ladder”):\n  - Operators: \"--------++++++++\" (length $16$, first $8$ are $-$, last $8$ are $+$).\n  - Pairs: $(0,8),(1,9),(2,10),(3,11),(4,12),(5,13),(6,14),(7,15)$.\n  - Expected sign: $+1$.\n\n- Case F (fourth-order, $8$ pairs, maximally crossing but even parity):\n  - Operators: \"--------++++++++\".\n  - Pairs: $(0,15),(1,14),(2,13),(3,12),(4,11),(5,10),(6,9),(7,8)$.\n  - The number of crossings is $\\sum_{k=1}^{7} k = 28$, hence even.\n  - Expected sign: $+1$.\n\n- Case G (fourth-order, $8$ pairs, single inversion at the end):\n  - Operators: \"--------++++++++\".\n  - Pairs: $(0,8),(1,9),(2,10),(3,11),(4,12),(5,13),(6,15),(7,14)$.\n  - The right endpoints in left-endpoint order are $[8,9,10,11,12,13,15,14]$ with a single inversion, hence odd parity.\n  - Expected sign: $-1$.\n\n- Case H (fourth-order, $8$ pairs, mixed pattern with odd inversion parity):\n  - Operators: \"--------++++++++\".\n  - Pairs: $(0,11),(1,8),(2,15),(3,12),(4,9),(5,14),(6,13),(7,10)$.\n  - The right endpoints in left-endpoint order are $[11,8,15,12,9,14,13,10]$, which has odd inversion parity.\n  - Expected sign: $-1$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for the cases in the order A through H (e.g., \"[True,True,False,...]\").\n- There is no input; the test suite is hard-coded.\n\nNotes:\n- All indices are zero-based and every pair $(i,j)$ is to be normalized internally to $i<j$.\n- Your implementation must rely solely on the canonical anticommutation relations and Wick’s theorem to justify the parity computation as described above.", "solution": "The problem requires the implementation and validation of two distinct algorithms for computing the sign of a fully contracted product of fermionic operators according to Wick's theorem. The problem's validity has been confirmed, as it is scientifically grounded, well-posed, and provides sufficient information for a unique solution. The core task is to implement the algorithms as mathematically specified and verify their results against provided test cases, despite some noted inconsistencies in the descriptive text accompanying the test cases.\n\n### Mathematical and Theoretical Framework\n\nWe consider a product of $2n$ fermionic operators, $\\hat{O}_1 \\hat{O}_2 \\dots \\hat{O}_{2n}$, where each $\\hat{O}_k$ is either a creation operator $\\hat{a}^\\dagger_p$ or an annihilation operator $\\hat{a}_p$. These operators obey the canonical anticommutation relations (CAR):\n$$\n\\{\\hat{a}_p, \\hat{a}_q\\} = \\hat{a}_p \\hat{a}_q + \\hat{a}_q \\hat{a}_p = 0\n$$\n$$\n\\{\\hat{a}_p^\\dagger, \\hat{a}_q^\\dagger\\} = \\hat{a}_p^\\dagger \\hat{a}_q^\\dagger + \\hat{a}_q^\\dagger \\hat{a}_p^\\dagger = 0\n$$\n$$\n\\{\\hat{a}_p, \\hat{a}_q^\\dagger\\} = \\hat{a}_p \\hat{a}_q^\\dagger + \\hat{a}_q^\\dagger \\hat{a}_p = \\delta_{pq}\n$$\nwhere $\\delta_{pq}$ is the Kronecker delta.\n\nA complete contraction of the operator string involves partitioning the $2n$ operators into $n$ pairs, where each pair consists of one annihilation operator and one creation operator. The expectation value of a single fully contracted term is non-zero, and its sign depends on the permutation needed to bring the operators in each pair adjacent to one another. According to Wick's theorem, this sign is given by $(-1)^{N_{\\mathrm{perm}}}$, where $N_{\\mathrm{perm}}$ is the number of pairwise transpositions of adjacent operators required.\n\nThe problem provides two equivalent methods for calculating this sign, which we will implement.\n\n### Algorithm 1: Swap-Count Method\n\nThis method simulates the reordering process by tracking operator removals. The sign is computed as $(-1)^{N_{\\text{swaps}}}$, where $N_{\\text{swaps}}$ is the total number of swaps required.\n\n1.  The set of operator indices is initialized to $A = \\{0, 1, ..., 2n-1\\}$, representing the active operators.\n2.  The given pairs of indices $\\{(i,j)\\}$ are first normalized such that for each pair, $i < j$.\n3.  These normalized pairs are then processed in ascending order of their right endpoint, $j$.\n4.  For each pair $(i, j)$ being processed, we count the number of swaps needed to bring the operators at positions $i$ and $j$ together. This count is equal to the number of active operators located at original positions $k$ such that $i < k < j$. Let this count be $s_{ij}$.\n5.  The total number of swaps, $N_{\\text{swaps}}$, is incremented by $s_{ij}$.\n6.  After processing the pair $(i, j)$, the indices $i$ and $j$ are removed from the set of active operators $A$.\n7.  This process is repeated for all pairs. The final sign is $(-1)^{N_{\\text{swaps}}}$.\n\nFor example, for Case C with operators at positions $\\{0, 1, 2, 3\\}$ and pairs $(0,2), (1,3)$:\n-   Initial active set $A = \\{0, 1, 2, 3\\}$. Pairs are sorted by right endpoint: $(0,2)$ then $(1,3)$.\n-   Process $(0,2)$: The active indices $k$ such that $0 < k < 2$ is just $\\{1\\}$. The swap count is $1$. $N_{\\text{swaps}}$ becomes $1$. $A$ becomes $\\{1, 3\\}$.\n-   Process $(1,3)$: The active indices $k$ such that $1 < k < 3$ is $\\{2\\}$. However, $2$ is not in the current active set $A$. The swap count is $0$. $N_{\\text{swaps}}$ remains $1$. $A$ becomes empty.\n-   Total swaps $N_{\\text{swaps}} = 1$. The sign is $(-1)^1 = -1$, which matches the expected outcome.\n\n### Algorithm 2: Crossing-Count Method\n\nThis method uses a combinatorial definition based on the topology of the contraction diagram. The sign is computed as $(-1)^{N_{\\text{cross}}}$, where $N_{\\text{cross}}$ is the number of crossings.\n\n1.  As before, the given pairs $\\{(i,j)\\}$ are normalized such that $i < j$.\n2.  The number of crossings, $N_{\\text{cross}}$, is defined as the number of pairs of pairs, $((i,j), (k,l))$, that satisfy the condition $i < k < j < l$.\n3.  To calculate $N_{\\text{cross}}$, one can simply iterate through all unique pairs of contractions. For every two distinct normalized pairs $p_1 = (i,j)$ and $p_2 = (k,l)$, we check if they satisfy the crossing condition. To avoid overcounting and ambiguity, we can impose an order, for instance by comparing their first elements, e.g., assume $i < k$. Then the condition is $i < k < j < l$.\n4.  The total count $N_{\\text{cross}}$ is accumulated. The final sign is $(-1)^{N_{\\text{cross}}}$.\n\nFor example, for Case C with pairs $(0,2), (1,3)$:\n-   Let the pairs be $p_1 = (0,2)$ and $p_2 = (1,3)$.\n-   Let $(i,j) = p_1$ and $(k,l) = p_2$. We have $i=0, j=2, k=1, l=3$.\n-   We check the condition $i < k < j < l$, which is $0 < 1 < 2 < 3$. The condition holds.\n-   There is exactly one such pair of pairs. So, $N_{\\text{cross}} = 1$.\n-   The sign is $(-1)^1 = -1$, which again matches the expected outcome.\n\n**Clarification on Problem Statement Inconsistencies**: It must be noted that the descriptive text for some test cases contains inconsistencies. For instance, Case E is described as \"completely non-crossing\", but the provided crossing definition ($i < k < j < l$) yields $N_{\\text{cross}} = 28$. Similarly, Case F is stated to have $N_{\\text{cross}} = 28$, but the definition yields $N_{\\text{cross}} = 0$. However, in both cases, the calculated sign, $(-1)^{28} = +1$ and $(-1)^0 = +1$ respectively, matches the provided expected sign. The provided notes on \"inversion parity\" for Cases G and H are also based on a different (though related) counting method which is not one of the two specified algorithms. Our implementation will strictly adhere to the two explicitly defined algorithms, as this procedure correctly reproduces all expected signs.\n\n### Implementation and Validation Plan\n\nThe final program will implement both algorithms in separate functions.\n-   `compute_sign_swap_count(num_operators, pairs)`: Implements Algorithm 1.\n-   `compute_sign_crossing_count(num_operators, pairs)`: Implements Algorithm 2.\nA main function will iterate through the hard-coded test suite (Cases A through H). For each case, it will:\n1.  Call both sign computation functions.\n2.  Verify that the signs returned by both functions are identical.\n3.  Verify that this sign matches the expected sign for the test case.\n4.  Store a boolean result (`True` if both checks pass, `False` otherwise).\nThe final output will be a list of these boolean results, printed in the specified format. The empty product (Case A) is handled as a base case, correctly yielding a sign of $+1$ from both algorithms due to zero swaps and zero crossings.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the fermionic sign problem by implementing and validating\n    two different algorithms based on Wick's theorem.\n    \"\"\"\n\n    def compute_sign_swap_count(num_operators, pairs):\n        \"\"\"\n        Computes the fermionic sign using the swap-count (operator removal) method.\n        The sign is (-1)^N_swaps, where N_swaps is the number of active operators\n        passed over during contraction.\n        \"\"\"\n        if not pairs:\n            return 1\n\n        # Normalize pairs to (i, j) with i < j\n        normalized_pairs = [tuple(sorted(p)) for p in pairs]\n        \n        # Process pairs in ascending order of their right-hand index\n        sorted_pairs = sorted(normalized_pairs, key=lambda p: p[1])\n        \n        active_indices = set(range(num_operators))\n        total_swaps = 0\n        \n        for i, j in sorted_pairs:\n            # Count active operators strictly between i and j\n            swaps_for_this_pair = sum(1 for k in active_indices if i < k < j)\n            total_swaps += swaps_for_this_pair\n            \n            # Remove the contracted operators from the active set\n            active_indices.remove(i)\n            active_indices.remove(j)\n            \n        return 1 if total_swaps % 2 == 0 else -1\n\n    def compute_sign_crossing_count(num_operators, pairs):\n        \"\"\"\n        Computes the fermionic sign using the crossing-count method.\n        The sign is (-1)^N_cross, where N_cross is the number of pairs of pairs\n        ((i,j), (k,l)) with i < k < j < l.\n        \"\"\"\n        if not pairs:\n            return 1\n            \n        # Normalize pairs to (i, j) with i < j\n        normalized_pairs = [tuple(sorted(p)) for p in pairs]\n        \n        num_pairs = len(normalized_pairs)\n        crossing_count = 0\n        \n        for idx1 in range(num_pairs):\n            for idx2 in range(idx1 + 1, num_pairs):\n                p1 = normalized_pairs[idx1]\n                p2 = normalized_pairs[idx2]\n                \n                # To apply the formula i<k<j<l, we must have a consistent\n                # ordering for i and k. We ensure i is from the pair\n                # with the smaller first index.\n                if p1[0] < p2[0]:\n                    i, j = p1\n                    k, l = p2\n                else:\n                    i, j = p2\n                    k, l = p1\n\n                if i < k < j < l:\n                    crossing_count += 1\n                    \n        return 1 if crossing_count % 2 == 0 else -1\n\n\n    test_cases = [\n        # Case A (empty product)\n        {\"ops\": \"\", \"pairs\": [], \"expected_sign\": 1},\n        # Case B (adjacent non-crossing)\n        {\"ops\": \"-+\", \"pairs\": [(0, 1)], \"expected_sign\": 1},\n        # Case C (single crossing on a short string)\n        {\"ops\": \"--++\", \"pairs\": [(0, 2), (1, 3)], \"expected_sign\": -1},\n        # Case D (nested, non-crossing)\n        {\"ops\": \"--++\", \"pairs\": [(0, 3), (1, 2)], \"expected_sign\": 1},\n        # Case E (fourth-order, 8 pairs, completely non-crossing \"ladder\")\n        {\"ops\": \"--------++++++++\", \"pairs\": [(0, 8), (1, 9), (2, 10), (3, 11), (4, 12), (5, 13), (6, 14), (7, 15)], \"expected_sign\": 1},\n        # Case F (fourth-order, 8 pairs, maximally crossing but even parity)\n        {\"ops\": \"--------++++++++\", \"pairs\": [(0, 15), (1, 14), (2, 13), (3, 12), (4, 11), (5, 10), (6, 9), (7, 8)], \"expected_sign\": 1},\n        # Case G (fourth-order, 8 pairs, single inversion at the end)\n        {\"ops\": \"--------++++++++\", \"pairs\": [(0, 8), (1, 9), (2, 10), (3, 11), (4, 12), (5, 13), (6, 15), (7, 14)], \"expected_sign\": -1},\n        # Case H (fourth-order, 8 pairs, mixed pattern with odd inversion parity)\n        {\"ops\": \"--------++++++++\", \"pairs\": [(0, 11), (1, 8), (2, 15), (3, 12), (4, 9), (5, 14), (6, 13), (7, 10)], \"expected_sign\": -1},\n    ]\n\n    results = []\n    for case in test_cases:\n        num_ops = len(case[\"ops\"])\n        pairs = case[\"pairs\"]\n        expected = case[\"expected_sign\"]\n\n        sign1 = compute_sign_swap_count(num_ops, pairs)\n        sign2 = compute_sign_crossing_count(num_ops, pairs)\n        \n        is_valid = (sign1 == sign2) and (sign1 == expected)\n        results.append(is_valid)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3589384"}, {"introduction": "The formalism of second quantization and normal ordering is not merely a calculational convenience; it is a powerful lens for revealing the emergent physics of interacting systems. In this practice, you will apply Wick's theorem to a two-body operator to derive the \"induced\" effective one-body operator that arises from interactions within the fermionic medium. This exercise powerfully demonstrates how complex, higher-body interactions can be systematically renormalized into simpler, effective forms that capture the essential physics. [@problem_id:3589347]", "problem": "Consider a system of spinless fermions in a finite orthonormal single-particle basis labeled by integers $p \\in \\{0,1,\\dots,M-1\\}$ with creation and annihilation operators $a_p^\\dagger$ and $a_p$ obeying the canonical anticommutation relations $\\{a_p,a_q^\\dagger\\}=\\delta_{pq}$ and $\\{a_p,a_q\\}=\\{a_p^\\dagger,a_q^\\dagger\\}=0$. Let $\\lvert \\Phi_0 \\rangle$ be a Slater-determinant reference state characterized by occupation numbers $n_i \\in \\{0,1\\}$ such that $a_i^\\dagger a_i \\lvert \\Phi_0 \\rangle = n_i \\lvert \\Phi_0 \\rangle$, and let normal ordering $:\\,\\cdot\\,:$ and contractions be defined with respect to $\\lvert \\Phi_0 \\rangle$. The contraction between a creation and an annihilation operator is defined as the vacuum expectation value with respect to $\\lvert \\Phi_0 \\rangle$, namely $\\contraction{}{a_q^\\dagger}{}{a_s} a_q^\\dagger a_s \\equiv \\langle \\Phi_0 \\lvert a_q^\\dagger a_s \\rvert \\Phi_0 \\rangle = \\delta_{qs} n_q$, and all other contractions vanish.\n\nDefine an antisymmetrized two-body long-range current operator $J^{(2)}$ in second quantization by\n$$\nJ^{(2)} \\equiv \\frac{1}{4} \\sum_{p q r s} \\overline{J}_{pq,rs}\\, a_p^\\dagger a_q^\\dagger a_s a_r,\n$$\nwith matrix elements $\\overline{J}_{pq,rs}$ that are antisymmetric under exchange of incoming or outgoing indices: $\\overline{J}_{pq,rs} = -\\overline{J}_{qp,rs} = -\\overline{J}_{pq,sr} = \\overline{J}_{qp,sr}$. For this problem, $\\overline{J}_{pq,rs}$ is constructed from a model long-range one-body kernel $K_{pr}$ as\n$$\n\\overline{J}_{pq,rs} \\equiv K_{pr}\\,\\delta_{qs} - K_{ps}\\,\\delta_{qr} - K_{qr}\\,\\delta_{ps} + K_{qs}\\,\\delta_{pr},\n$$\nwhere\n$$\nK_{pr} \\equiv g \\exp\\!\\left(-\\frac{(p-r)^2}{2 R^2}\\right),\n$$\nwith coupling amplitude $g>0$ and range parameter $R>0$. All quantities are dimensionless.\n\nUsing Wick's theorem, normal order $J^{(2)}$ with respect to $\\lvert \\Phi_0 \\rangle$ and compute the induced one-body operator $J_{\\mathrm{ind}}^{(1)}$ arising from single-contraction terms such that\n$$\nJ^{(2)} = :J^{(2)}: \\;+\\; J_{\\mathrm{ind}}^{(1)} \\;+\\; \\text{zero-body term}.\n$$\nYour task is to compute the matrix elements $\\left(J_{\\mathrm{ind}}^{(1)}\\right)_{pr}$ by explicitly summing the single-contraction contributions implied by Wick's theorem using the definitions above. Then, define the impulse-approximation one-body operator $J_{\\mathrm{imp}}^{(1)}$ by\n$$\n\\left(J_{\\mathrm{imp}}^{(1)}\\right)_{pr} \\equiv K_{pr}.\n$$\nFor a given set of parameters $(M,N,g,R)$, where $M$ is the basis dimension and $N$ is the number of occupied orbitals in $\\lvert \\Phi_0 \\rangle$ (assume the lowest $N$ orbitals $i=0,1,\\dots,N-1$ are occupied, so $n_i=1$ for $i<N$ and $n_i=0$ otherwise), compute the Frobenius-norm ratio\n$$\n\\mathcal{R}(M,N,g,R) \\equiv \\frac{\\left\\| J_{\\mathrm{ind}}^{(1)} \\right\\|_F}{\\left\\| J_{\\mathrm{imp}}^{(1)} \\right\\|_F},\n$$\nwhere $\\left\\| A \\right\\|_F \\equiv \\sqrt{\\sum_{p,r} \\lvert A_{pr} \\rvert^2}$.\n\nImplement a program that carries out this computation for the following test suite of parameter sets:\n- Case 1 (happy path, empty reference): $(M,N,g,R) = (4,0,1.0,2.0)$.\n- Case 2 (partial filling, moderate range): $(M,N,g,R) = (4,2,1.0,2.0)$.\n- Case 3 (larger space, very long range): $(M,N,g,R) = (6,3,1.0,10.0)$.\n- Case 4 (near-full occupancy, shorter range): $(M,N,g,R) = (6,5,0.5,1.0)$.\n- Case 5 (full occupancy): $(M,N,g,R) = (5,5,1.0,1.5)$.\n\nRequirements:\n- Use Wick's theorem and the normal-ordering definitions given above to compute $J_{\\mathrm{ind}}^{(1)}$ by summing single-contraction contributions with respect to the specified Slater-determinant reference state.\n- Use the model kernel $K_{pr}$ specified above to define both $\\overline{J}_{pq,rs}$ and $J_{\\mathrm{imp}}^{(1)}$.\n- All quantities are dimensionless; no physical units are required in the output.\n- Your program should produce a single line of output containing the results as a comma-separated list of the five values $\\left[\\mathcal{R}_1,\\mathcal{R}_2,\\mathcal{R}_3,\\mathcal{R}_4,\\mathcal{R}_5\\right]$, where $\\mathcal{R}_k$ is $\\mathcal{R}$ for Case $k$, each rounded to six decimal places.\n- The program must not read any input and must run as-is.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4,result5]\") in the specified order of cases.", "solution": "The user wants to compute the ratio of Frobenius norms of two one-body operators, $J_{\\mathrm{ind}}^{(1)}$ and $J_{\\mathrm{imp}}^{(1)}$, for a system of spinless fermions. This requires deriving the matrix elements of the induced one-body operator $J_{\\mathrm{ind}}^{(1)}$ by applying Wick's theorem to a given two-body operator $J^{(2)}$.\n\n**1. Problem Validation**\nThe problem statement is scientifically sound, well-posed, and objective. It provides a complete set of definitions and parameters for a standard many-body physics calculation involving second quantization and Wick's theorem. The definitions of the operators, reference state, and contractions are standard in the field, with the minor ambiguity of \"all other contractions vanish\" being contextually resolvable. Specifically, for the given operator string $a_p^\\dagger a_q^\\dagger a_s a_r$, only contractions of the type $\\langle a^\\dagger a \\rangle$ are possible, as contractions of two creation or two annihilation operators are identically zero. The problem is thus deemed valid.\n\n**2. Derivation of the Induced One-Body Operator $J_{\\mathrm{ind}}^{(1)}$**\n\nThe two-body operator is given by:\n$$\nJ^{(2)} = \\frac{1}{4} \\sum_{p,q,r,s=0}^{M-1} \\overline{J}_{pq,rs}\\, a_p^\\dagger a_q^\\dagger a_s a_r\n$$\nwhere the matrix elements $\\overline{J}_{pq,rs}$ are fully antisymmetric: $\\overline{J}_{pq,rs} = -\\overline{J}_{qp,rs} = -\\overline{J}_{pq,sr}$.\n\nAccording to Wick's theorem, the general operator product $A_1 A_2 A_3 A_4$ can be expanded into its normal-ordered product plus all possible single and double contractions. The induced one-body operator $J_{\\mathrm{ind}}^{(1)}$ arises from the sum of all single-contraction terms in the expansion of $a_p^\\dagger a_q^\\dagger a_s a_r$.\n\nThe string of operators is $a_p^\\dagger a_q^\\dagger a_s a_r$. The non-zero contractions are defined as $\\contraction{}{a_i^\\dagger}{}{a_j} a_i^\\dagger a_j = \\langle \\Phi_0 | a_i^\\dagger a_j | \\Phi_0 \\rangle = \\delta_{ij} n_j$. The single-contraction terms, including the sign $(-1)^P$ from permuting fermion operators to bring them together, are:\n\\begin{enumerate}\n    \\item $C_1: \\contraction{}{a_q^\\dagger}{}{a_s} a_p^\\dagger a_q^\\dagger a_s a_r = \\delta_{qs} n_q :a_p^\\dagger a_r:$ (0 crossings, sign +1)\n    \\item $C_2: \\contraction{a_p^\\dagger}{a_q^\\dagger}{a_s}{a_r} a_p^\\dagger a_q^\\dagger a_s a_r = -\\delta_{qr} n_q :a_p^\\dagger a_s:$ (1 crossing, sign -1)\n    \\item $C_3: \\contraction{}{a_p^\\dagger}{a_q^\\dagger}{a_s} a_p^\\dagger a_q^\\dagger a_s a_r = -\\delta_{ps} n_p :a_q^\\dagger a_r:$ (1 crossing, sign -1)\n    \\item $C_4: \\contraction{}{a_p^\\dagger}{...}{a_r} a_p^\\dagger a_q^\\dagger a_s a_r = \\delta_{pr} n_p :a_q^\\dagger a_s:$ (2 crossings, sign +1)\n\\end{enumerate}\nHere, $: \\cdot :$ denotes normal ordering with respect to the reference state $|\\Phi_0\\rangle$. For a one-body operator, $:a_i^\\dagger a_j:$ can be replaced by $a_i^\\dagger a_j$ as the subtraction term $\\langle a_i^\\dagger a_j \\rangle$ is part of the zero-body operator.\n\n$J_{\\mathrm{ind}}^{(1)}$ is the sum of these terms, weighted by $\\frac{1}{4}\\overline{J}_{pq,rs}$ and summed over all indices:\n$$\nJ_{\\mathrm{ind}}^{(1)} = \\frac{1}{4} \\sum_{pqrs} \\overline{J}_{pq,rs} \\left( \\delta_{qs} n_q a_p^\\dagger a_r - \\delta_{qr} n_q a_p^\\dagger a_s - \\delta_{ps} n_p a_q^\\dagger a_r + \\delta_{pr} n_p a_q^\\dagger a_s \\right)\n$$\nWe can simplify this sum using the antisymmetry of $\\overline{J}_{pq,rs}$.\nConsider the term with $C_3$: $\\sum_{pqrs} \\overline{J}_{pq,rs}(-\\delta_{ps} n_p a_q^\\dagger a_r)$. By swapping the dummy summation indices $p \\leftrightarrow q$, this becomes $\\sum_{qprs} \\overline{J}_{qp,rs}(-\\delta_{qs} n_q a_p^\\dagger a_r) = \\sum_{pqrs} (-\\overline{J}_{pq,rs})(-\\delta_{qs} n_q a_p^\\dagger a_r) = \\sum_{pqrs} \\overline{J}_{pq,rs}(\\delta_{qs} n_q a_p^\\dagger a_r)$, which is the term with $C_1$.\nSimilarly, the term with $C_4$ can be shown to be equal to the term with $C_2$.\nTherefore, the total contribution from $C_1+C_3$ is $2 \\times (\\text{contribution from } C_1)$, and from $C_2+C_4$ is $2 \\times (\\text{contribution from } C_2)$.\n$$\nJ_{\\mathrm{ind}}^{(1)} = \\frac{1}{4} \\cdot 2 \\sum_{pqrs} \\overline{J}_{pq,rs} \\left( \\delta_{qs} n_q a_p^\\dagger a_r - \\delta_{qr} n_q a_p^\\dagger a_s \\right) = \\frac{1}{2} \\left( T_1 - T_2 \\right)\n$$\nwhere $T_1 = \\sum_{pqrs} \\overline{J}_{pq,rs} \\delta_{qs} n_q a_p^\\dagger a_r$ and $T_2 = \\sum_{pqrs} \\overline{J}_{pq,rs} \\delta_{qr} n_q a_p^\\dagger a_s$.\nNow, consider $T_2$. By swapping dummy summation indices $r \\leftrightarrow s$, we get:\n$T_2 = \\sum_{pqsr} \\overline{J}_{pq,sr} \\delta_{qs} n_q a_p^\\dagger a_r$. Using the antisymmetry $\\overline{J}_{pq,sr} = -\\overline{J}_{pq,rs}$, this becomes $T_2 = \\sum_{pqrs} (-\\overline{J}_{pq,rs}) \\delta_{qs} n_q a_p^\\dagger a_r = -T_1$.\nSubstituting this back, we get:\n$$\nJ_{\\mathrm{ind}}^{(1)} = \\frac{1}{2} (T_1 - (-T_1)) = T_1 = \\sum_{pqrs} \\overline{J}_{pq,rs} \\delta_{qs} n_q a_p^\\dagger a_r\n$$\nSumming over the index $s$ collapses the delta function:\n$$\nJ_{\\mathrm{ind}}^{(1)} = \\sum_{pqr} \\overline{J}_{pq,rq} n_q a_p^\\dagger a_r = \\sum_{pr} \\left( \\sum_q n_q \\overline{J}_{pq,rq} \\right) a_p^\\dagger a_r\n$$\nFrom this, we identify the matrix elements of the induced one-body operator as:\n$$\n\\left(J_{\\mathrm{ind}}^{(1)}\\right)_{pr} = \\sum_q n_q \\overline{J}_{pq,rq}\n$$\nNow, we substitute the definition of $\\overline{J}_{pq,rs}$:\n$$\n\\overline{J}_{pq,rq} = K_{pr}\\delta_{qq} - K_{pq}\\delta_{qr} - K_{rq}\\delta_{pq} + K_{qq}\\delta_{pr}\n$$\nSumming over $q$ with the weight $n_q$:\n\\begin{align*}\n\\left(J_{\\mathrm{ind}}^{(1)}\\right)_{pr} &= \\sum_q n_q \\left( K_{pr} - K_{pq}\\delta_{qr} - K_{rq}\\delta_{pq} + K_{qq}\\delta_{pr} \\right) \\\\\n&= K_{pr} \\sum_q n_q - \\sum_q n_q K_{pq}\\delta_{qr} - \\sum_q n_q K_{rq}\\delta_{pq} + \\delta_{pr} \\sum_q n_q K_{qq}\n\\end{align*}\nWe use the facts that $\\sum_q n_q = N$ (the total number of occupied states), $K_{pr}$ is symmetric ($K_{pr} = K_{rp}$), and $K_{qq} = g$.\n\\begin{align*}\n\\left(J_{\\mathrm{ind}}^{(1)}\\right)_{pr} &= N K_{pr} - n_r K_{pr} - n_p K_{rp} + \\delta_{pr} \\sum_q n_q g \\\\\n&= N K_{pr} - n_r K_{pr} - n_p K_{pr} + gN\\delta_{pr} \\\\\n&= (N - n_p - n_r) K_{pr} + gN\\delta_{pr}\n\\end{align*}\nwhere $n_p=1$ if $p<N$ and $0$ otherwise (similarly for $n_r$). This is the final expression for the matrix elements.\n\n**3. Algorithmic Implementation**\n\nThe computation proceeds as follows for each parameter set $(M,N,g,R)$:\n1.  Construct the $M \\times M$ matrix $J_{\\mathrm{imp}}^{(1)}$ whose elements are given by $\\left(J_{\\mathrm{imp}}^{(1)}\\right)_{pr} = K_{pr} = g \\exp\\!\\left(-\\frac{(p-r)^2}{2 R^2}\\right)$.\n2.  Calculate the Frobenius norm $\\left\\| J_{\\mathrm{imp}}^{(1)} \\right\\|_F$.\n3.  Construct the $M \\times M$ matrix $J_{\\mathrm{ind}}^{(1)}$ using the derived formula $\\left(J_{\\mathrm{ind}}^{(1)}\\right)_{pr} = (N - n_p - n_r) K_{pr} + gN\\delta_{pr}$. This requires constructing the occupation number vectors $n_p$ and $n_r$.\n4.  Calculate the Frobenius norm $\\left\\| J_{\\mathrm{ind}}^{(1)} \\right\\|_F$.\n5.  Compute the ratio $\\mathcal{R} = \\frac{\\left\\| J_{\\mathrm{ind}}^{(1)} \\right\\|_F}{\\left\\| J_{\\mathrm{imp}}^{(1)} \\right\\|_F}$.\n\nThis procedure is implemented in Python using the `numpy` library for efficient matrix operations.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the Frobenius-norm ratio of an induced one-body operator to an\n    impulse-approximation operator for a series of test cases in a fermionic system.\n\n    The induced operator's matrix elements are derived using Wick's theorem.\n    \"\"\"\n    test_cases = [\n        # (M, N, g, R)\n        # Case 1: happy path, empty reference\n        (4, 0, 1.0, 2.0),\n        # Case 2: partial filling, moderate range\n        (4, 2, 1.0, 2.0),\n        # Case 3: larger space, very long range\n        (6, 3, 1.0, 10.0),\n        # Case 4: near-full occupancy, shorter range\n        (6, 5, 0.5, 1.0),\n        # Case 5: full occupancy\n        (5, 5, 1.0, 1.5),\n    ]\n\n    results = []\n    for M, N, g, R in test_cases:\n        # Define the single-particle basis indices as broadcastable arrays\n        p = np.arange(M, dtype=float).reshape(-1, 1)\n        r = np.arange(M, dtype=float).reshape(1, -1)\n\n        # 1. Compute the impulse-approximation operator J_imp and its norm.\n        # Its elements are defined by the one-body kernel K_pr.\n        K_pr = g * np.exp(-(p - r)**2 / (2 * R**2))\n        J_imp = K_pr\n        norm_imp = np.linalg.norm(J_imp, 'fro')\n\n        # 2. Compute the induced one-body operator J_ind and its norm.\n        # The matrix elements are (J_ind)_pr = (N - n_p - n_r) * K_pr + g*N*delta_pr.\n\n        # Define the occupation number vector n_i (1 for i<N, 0 otherwise).\n        n_vec = np.zeros(M)\n        if N > 0:\n            n_vec[:N] = 1.0\n            \n        # Reshape n_vec for broadcasting with the M x M matrices.\n        n_p = n_vec.reshape(-1, 1)\n        n_r = n_vec.reshape(1, -1)\n        \n        # The Kronecker delta is represented by the identity matrix.\n        delta_pr = np.eye(M)\n        \n        # Calculate the J_ind matrix using the derived formula.\n        J_ind = (N - n_p - n_r) * K_pr + g * N * delta_pr\n        norm_ind = np.linalg.norm(J_ind, 'fro')\n\n        # 3. Compute the ratio of the Frobenius norms.\n        # A check for norm_imp == 0 is included for robustness, though g>0 ensures it's non-zero.\n        if norm_imp == 0:\n            ratio = 0.0 if norm_ind == 0.0 else np.inf\n        else:\n            ratio = norm_ind / norm_imp\n            \n        results.append(f\"{ratio:.6f}\")\n\n    # Print the final list of results in the specified format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3589347"}]}