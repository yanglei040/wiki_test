{"hands_on_practices": [{"introduction": "The power of Gaussian quadrature lies not just in its high accuracy for smooth functions, but in its extensibility to integrands with known non-polynomial behavior. By choosing a weight function that matches the integrand's dominant structure, we can achieve remarkable efficiency. This practice [@problem_id:3561541] explores this principle for integrals common in nuclear physics, where a centrifugal barrier introduces a power-law term $r^{\\ell}$. You will reason about how to select the optimal parameter $\\alpha$ in generalized Gauss-Laguerre quadrature to absorb this behavior, transforming a difficult numerical problem into one that the quadrature can solve with ease.", "problem": "In computational nuclear physics, radial matrix elements frequently involve integrals over the radial coordinate $r \\in [0,\\infty)$ with near-origin behavior influenced by the centrifugal barrier, typically contributing a factor $r^{\\ell}$, where $\\ell$ is the orbital angular momentum quantum number. Consider integrals of the form\n$$\nI_{\\ell}[F] \\equiv \\int_{0}^{\\infty} r^{\\ell}\\, e^{-b r}\\, F(r)\\, dr,\n$$\nwhere $b>0$ sets an exponential range scale (for example, related to the range of a nuclear potential or an inverse oscillator length) and $F(r)$ is a sufficiently smooth function that is regular at $r=0$ and decays no slower than a polynomial as $r\\to\\infty$. In many practical matrix elements, the spherical volume element contributes an additional factor $r^{2}$, leading to\n$$\n\\widetilde{I}_{\\ell}[F] \\equiv \\int_{0}^{\\infty} r^{\\ell+2}\\, e^{-b r}\\, F(r)\\, dr.\n$$\nA standard approach for numerical evaluation is to rescale $x = b r$ and apply generalized Gauss–Laguerre quadrature, which approximates integrals of the form\n$$\n\\int_{0}^{\\infty} x^{\\alpha} e^{-x} f(x)\\, dx\n$$\nusing the zeros of the generalized Laguerre polynomial with parameter $\\alpha>-1$. It is a core property of this quadrature that, with $n$ nodes, it integrates exactly any integrand $x^{\\alpha} e^{-x} p(x)$ where $p(x)$ is a polynomial of degree at most $2n-1$.\n\nUsing only these foundational facts and the rescaling $x = b r$, reason about how the choice of the Laguerre parameter $\\alpha$ impacts accuracy when the integrand exhibits a centrifugal barrier $r^{\\ell}$ (or $r^{\\ell+2}$ when the spherical volume element is included). Which of the following statements are correct?\n\nA. After the rescaling $x=b r$, choosing $\\alpha=\\ell$ makes the quadrature exact for the model integral with $F(r)\\equiv 1$ and, more generally, improves accuracy when $F(r)$ is smooth at $r=0$ because the non-polynomial behavior at the origin is absorbed into the weight.\n\nB. Choosing $\\alpha=0$ is universally optimal for all $\\ell$ because it maximizes the density of quadrature nodes near $r=0$, thereby best resolving the centrifugal barrier irrespective of $\\ell$.\n\nC. For any fixed $n$, choosing $\\alpha>\\ell$ strictly improves accuracy as $\\alpha$ increases, because the increased weight $x^{\\alpha}$ shifts nodes to larger $x$ and emphasizes the tail where the exponential $e^{-x}$ is small.\n\nD. When the spherical volume element is present, i.e., for integrals of the form $\\widetilde{I}_{\\ell}[F]$, setting $\\alpha=\\ell+2$ after the same rescaling $x=b r$ captures the composite near-origin power and yields the same type of accuracy benefit as in option A.\n\nE. Setting $\\alpha=-\\ell$ cancels the centrifugal factor and therefore yields superior accuracy for any smooth $F(r)$, since the remaining factor is closer to a polynomial; this holds for all $\\ell\\ge 1$.", "solution": "The user has provided a problem concerning the application of generalized Gauss-Laguerre quadrature to integrals common in computational nuclear physics. I will first validate the problem statement and then proceed to a full solution and evaluation of the given options.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n- Integral of type 1: $I_{\\ell}[F] \\equiv \\int_{0}^{\\infty} r^{\\ell}\\, e^{-b r}\\, F(r)\\, dr$\n- Integral of type 2: $\\widetilde{I}_{\\ell}[F] \\equiv \\int_{0}^{\\infty} r^{\\ell+2}\\, e^{-b r}\\, F(r)\\, dr$\n- Domain and parameters: $r \\in [0,\\infty)$, $\\ell$ is the orbital angular momentum quantum number (a non-negative integer), $b>0$.\n- Function properties: $F(r)$ is sufficiently smooth, regular at $r=0$, and decays no slower than a polynomial as $r\\to\\infty$.\n- Numerical method: Rescaling $x = b r$ and applying generalized Gauss-Laguerre quadrature.\n- Generalized Gauss-Laguerre Quadrature: Approximates integrals of the form $\\int_{0}^{\\infty} x^{\\alpha} e^{-x} f(x)\\, dx$.\n- Quadrature parameter constraint: $\\alpha>-1$.\n- Exactness property: With $n$ nodes, the quadrature is exact for any integrand $x^{\\alpha} e^{-x} p(x)$ where $p(x)$ is a polynomial of degree at most $2n-1$.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem statement is scientifically grounded. The integrals are standard radial matrix elements in quantum mechanics, incorporating a term $r^\\ell$ from the radial part of the wavefunction's solution near the origin (centrifugal barrier) and sometimes an $r^2$ factor from the spherical volume element. The use of generalized Gauss-Laguerre quadrature for integrals on $[0,\\infty)$ with a weight of the form $x^\\alpha e^{-x}$ is a canonical technique in numerical analysis and computational physics.\n\nThe problem is well-posed. It asks for a reasoned analysis of different strategies for choosing the quadrature parameter $\\alpha$, based on a clearly stated property of the quadrature method. All necessary information is provided.\n\nThe problem is objective and uses precise terminology. The terms \"smooth\" and \"regular at $r=0$\" have clear mathematical meanings in this context, implying that $F(r)$ has a well-defined Taylor series expansion around $r=0$.\n\nThe problem does not violate any of the invalidity criteria. It is not scientifically unsound, non-formalizable, incomplete, unrealistic, or ill-posed. It is a standard conceptual problem in numerical methods.\n\n**Step 3: Verdict and Action**\nThe problem statement is valid. I will now proceed with the solution.\n\n### Derivation and Option Analysis\n\nThe fundamental principle of generalized Gaussian quadrature is to choose the weight function, in this case $w(x) = x^{\\alpha} e^{-x}$, to capture the most \"difficult\" or \"non-polynomial\" part of the integrand. The quadrature method is then exceptionally efficient at integrating the remaining, relatively smooth part of the function, which it implicitly approximates with a high-degree polynomial.\n\nLet us first analyze the integral $I_{\\ell}[F]$. We are given\n$$\nI_{\\ell}[F] \\equiv \\int_{0}^{\\infty} r^{\\ell}\\, e^{-b r}\\, F(r)\\, dr\n$$\nWe apply the specified change of variables, $x = b r$. This implies $r = x/b$ and $dr = dx/b$. Substituting these into the integral gives:\n$$\nI_{\\ell}[F] = \\int_{0}^{\\infty} \\left(\\frac{x}{b}\\right)^{\\ell}\\, e^{-x}\\, F\\left(\\frac{x}{b}\\right)\\, \\frac{dx}{b}\n$$\n$$\nI_{\\ell}[F] = \\frac{1}{b^{\\ell+1}} \\int_{0}^{\\infty} x^{\\ell}\\, e^{-x}\\, F\\left(\\frac{x}{b}\\right)\\, dx\n$$\nThis transformed integral is in a form suitable for generalized Gauss-Laguerre quadrature. We are to approximate an integral of the form $\\int_{0}^{\\infty} g(x)\\,dx$, where $g(x) = x^{\\ell}\\, e^{-x}\\, F(x/b)$. To apply the quadrature rule for a parameter $\\alpha$, we must identify the integrand as a product of the weight $x^{\\alpha}e^{-x}$ and a function $f(x)$.\n$$\n\\int_{0}^{\\infty} x^{\\ell}\\, e^{-x}\\, F\\left(\\frac{x}{b}\\right)\\, dx = \\int_{0}^{\\infty} x^{\\alpha}e^{-x} f(x) dx\n$$\nThe most effective strategy is to choose $\\alpha$ to match the power-law behavior of the integrand, thereby absorbing it into the weight function. The function $F(r)$ is assumed to be smooth and regular at $r=0$, meaning it has a Taylor expansion $F(r) = c_0 + c_1 r + \\dots$. Thus, $F(x/b) = c_0 + c_1 (x/b) + \\dots$ is a well-behaved function that is readily approximated by a polynomial. The term $x^{\\ell}$ is the difficult part to approximate with a polynomial, especially for larger $\\ell$.\n\nBy choosing $\\alpha = \\ell$, we set the weight function to be $w(x) = x^{\\ell} e^{-x}$. The remaining function is $f(x) = F(x/b)$. Since $F(r)$ is smooth, $f(x)$ is also smooth and is the ideal candidate for polynomial approximation by the quadrature rule. This choice optimally leverages the power of the quadrature method.\n\nNow, we evaluate each option based on this principle.\n\n**A. After the rescaling $x=b r$, choosing $\\alpha=\\ell$ makes the quadrature exact for the model integral with $F(r)\\equiv 1$ and, more generally, improves accuracy when $F(r)$ is smooth at $r=0$ because the non-polynomial behavior at the origin is absorbed into the weight.**\n\nApplying the logic above, choosing $\\alpha=\\ell$ is the correct general strategy. This choice makes the function to be approximated by the quadrature $f(x) = F(x/b)$. Since $F(r)$ is smooth, this $f(x)$ is well-approximated by a polynomial, leading to high accuracy. The statement correctly identifies that the non-polynomial behavior $x^\\ell$ is absorbed into the weight.\nLet's check the specific claim for $F(r) \\equiv 1$. In this case, $f(x) = F(x/b) = 1$. The function to be approximated is $p(x) = 1$, which is a polynomial of degree $0$. The quadrature rule is exact for polynomials of degree up to $2n-1$. Since $0 \\le 2n-1$ for any number of nodes $n \\ge 1$, the quadrature will be exact. This statement is entirely correct.\n**Verdict: Correct**\n\n**B. Choosing $\\alpha=0$ is universally optimal for all $\\ell$ because it maximizes the density of quadrature nodes near $r=0$, thereby best resolving the centrifugal barrier irrespective of $\\ell$.**\n\nIf we set $\\alpha=0$, we are using the standard (not generalized) Gauss-Laguerre quadrature. The weight is $e^{-x}$. For our transformed integral, we must identify the function to be approximated as $f(x) = x^{\\ell} F(x/b)$. The quadrature rule will attempt to approximate this entire function with a polynomial. The term $x^{\\ell}$ is not \"polynomial-like\" in the sense that it requires a high-degree polynomial for a good approximation, especially if $\\ell$ is large. This is an inefficient use of the quadrature points. The optimal choice of $\\alpha$ makes the remaining function $f(x)$ as close to a polynomial as possible. Choosing $\\alpha=0$ actively works against this goal. The reasoning about node density is misleading; while the nodes for $\\alpha=0$ are closer to the origin than for $\\alpha=\\ell>0$, their positions are optimal for the weight $e^{-x}$, not for an integrand that behaves like $x^\\ell e^{-x}$. This choice is far from universally optimal.\n**Verdict: Incorrect**\n\n**C. For any fixed $n$, choosing $\\alpha>\\ell$ strictly improves accuracy as $\\alpha$ increases, because the increased weight $x^{\\alpha}$ shifts nodes to larger $x$ and emphasizes the tail where the exponential $e^{-x}$ is small.**\n\nIf we choose $\\alpha > \\ell$, our integral must be rewritten as $\\int_{0}^{\\infty} x^{\\alpha}e^{-x} \\left[ x^{\\ell-\\alpha} F\\left(\\frac{x}{b}\\right) \\right] dx$. The function to be approximated by the quadrature is $f(x) = x^{\\ell-\\alpha} F(x/b)$. Since $\\alpha > \\ell$, the exponent $\\ell-\\alpha$ is negative. As $F(r)$ is regular at $r=0$, $F(0) = c_0 \\neq 0$ in general. Therefore, $f(x) \\approx c_0 x^{\\ell-\\alpha}$ as $x \\to 0$. This function has a singularity at $x=0$. Approximating a function with a singularity using a polynomial is a known cause of catastrophic error in numerical integration. The accuracy will be extremely poor, not improved.\n**Verdict: Incorrect**\n\n**D. When the spherical volume element is present, i.e., for integrals of the form $\\widetilde{I}_{\\ell}[F]$, setting $\\alpha=\\ell+2$ after the same rescaling $x=b r$ captures the composite near-origin power and yields the same type of accuracy benefit as in option A.**\n\nLet's analyze the integral $\\widetilde{I}_{\\ell}[F] = \\int_{0}^{\\infty} r^{\\ell+2}\\, e^{-b r}\\, F(r)\\, dr$. Applying the rescaling $x = br$ as before:\n$$\n\\widetilde{I}_{\\ell}[F] = \\int_{0}^{\\infty} \\left(\\frac{x}{b}\\right)^{\\ell+2}\\, e^{-x}\\, F\\left(\\frac{x}{b}\\right)\\, \\frac{dx}{b} = \\frac{1}{b^{\\ell+3}} \\int_{0}^{\\infty} x^{\\ell+2}\\, e^{-x}\\, F\\left(\\frac{x}{b}\\right)\\, dx\n$$\nThe integrand's dominant power-law behavior near the origin is $x^{\\ell+2}$. Following the same logic as for $I_\\ell[F]$, the optimal strategy is to absorb this entire factor into the weight function. This is achieved by choosing the quadrature parameter $\\alpha = \\ell+2$. The weight becomes $w(x) = x^{\\ell+2}e^{-x}$, and the function to be approximated becomes $f(x) = F(x/b)$. As before, this $f(x)$ is smooth and well-behaved, leading to high accuracy. This statement correctly identifies that $\\alpha=\\ell+2$ captures the composite power $r^{\\ell} \\cdot r^2 = r^{\\ell+2}$ and that this provides the same benefit as choosing $\\alpha=\\ell$ for the first integral.\n**Verdict: Correct**\n\n**E. Setting $\\alpha=-\\ell$ cancels the centrifugal factor and therefore yields superior accuracy for any smooth $F(r)$, since the remaining factor is closer to a polynomial; this holds for all $\\ell\\ge 1$.**\n\nThis statement has two major flaws. First, the generalized Gauss-Laguerre quadrature is defined for $\\alpha > -1$. For any orbital angular momentum quantum number $\\ell \\ge 1$, the choice $\\alpha = -\\ell$ results in $\\alpha \\le -1$. For $\\alpha \\le -1$, the weight function $w(x) = x^{\\alpha}e^{-x}$ is not integrable on $[0, \\infty)$, and the moments required to define the orthogonal polynomials do not exist. Therefore, the proposed quadrature is not well-defined.\nSecond, even if we ignored the invalidity of $\\alpha$, the reasoning is incorrect. The idea is to approximate $\\int x^{\\ell} e^{-x} F(x/b) dx$. If we were to use a weight $w(x) = x^{-\\ell}e^{-x}$, the remaining function would be $f(x) = (x^{\\ell} e^{-x} F(x/b)) / (x^{-\\ell}e^{-x}) = x^{2\\ell} F(x/b)$. This does not \"cancel\" the factor; it squares the power, making the resulting function *less* polynomial-like and much harder to approximate, not more.\n**Verdict: Incorrect**", "answer": "$$\\boxed{AD}$$", "id": "3561541"}, {"introduction": "Many problems in computational physics, particularly momentum-space calculations, involve integrals over vast logarithmic scales. A standard quadrature with linearly spaced nodes is profoundly inefficient, wasting points in regions of slow variation and failing to resolve features in others. This hands-on exercise [@problem_id:3561470] demonstrates a powerful and widely used solution: adapting a standard Gauss-Legendre quadrature to a logarithmic grid via a change of variables. You will not only implement this technique but also analyze its numerical stability, gaining insight into how the transformation creates a more robust and accurate tool for multi-scale problems.", "problem": "Consider momentum-space integrals that arise in computational nuclear physics, where a typical Three-Dimensional (3D) radial momentum integral reduces to a one-dimensional integral of the form $\\int f(p)\\,dp$ over a wide dynamic range of momenta. To resolve stiffness across decades, a logarithmic mapping $x=\\log p$ is used so that the quadrature proceeds in the variable $x$. Starting from the change-of-variables theorem and the core definition of Gaussian quadrature (without assuming any specialized formula beyond the mapping and the linear interval transformation for Gaussian quadrature on $[-1,1]$), derive the transformation of Gaussian nodes and weights when passing from the $p$-domain with $p\\in[10^{-3}\\Lambda,10^{3}\\Lambda]$ to the $x$-domain with $x\\in[\\log(10^{-3}\\Lambda),\\log(10^{3}\\Lambda)]$ under the mapping $x=\\log p$. The argument of the logarithm must be dimensionless; therefore, work in units where momenta are scaled by a fixed reference scale $\\Lambda$ and define the dimensionless momentum $q=p/\\Lambda$, so that $q\\in[10^{-3},10^{3}]$ and $x=\\log q$.\n\nYour task is to implement Gaussian quadrature with and without the logarithmic mapping for a set of stiff test integrands representative of momentum kernels, and to assess stability. Use the following foundational base:\n- The change-of-variables theorem for integrals: if $q=\\phi(x)$ is a differentiable bijection on $[a,b]$ then $\\int_{q(a)}^{q(b)} f(q)\\,dq=\\int_{a}^{b} f(\\phi(x))\\,\\phi'(x)\\,dx$.\n- The definition of Gauss-Legendre quadrature on $[-1,1]$: for a sufficiently smooth function $g(x)$, $\\int_{-1}^{1} g(x)\\,dx\\approx\\sum_{i=1}^{N} w_i\\,g(t_i)$, where $t_i$ and $w_i$ are the Gauss-Legendre nodes and weights, and the linear mapping transfers this quadrature to any finite interval.\n\nFormulate the quadrature after mapping $x=\\log q$ for integrals of the form $\\int_{10^{-3}}^{10^{3}} f(q)\\,dq$ and discuss how the transformed weights depend on $x$. Define a numerical stability metric for a given quadrature evaluation as the ratio\n$$\nR=\\frac{\\max_i \\left|c_i\\right|}{\\sum_{j} \\left|c_j\\right|},\n$$\nwhere $c_i$ are the individual weighted contributions of each node to the quadrature sum. Explain how $R$ reflects dominance by a small number of nodes and how this relates to stiffness. Design and implement a numerically stable summation strategy.\n\nImplement two quadrature schemes:\n- Direct Gauss-Legendre on $q\\in[10^{-3},10^{3}]$.\n- Log-mapped Gauss-Legendre via $x=\\log q$ on $x\\in[\\log 10^{-3},\\log 10^{3}]$.\n\nUse $N=64$ nodes for both schemes. For a high-accuracy reference, use an adaptive integrator to compute $\\int_{10^{-3}}^{10^{3}} f(q)\\,dq$ with tight tolerances.\n\nTest Suite:\nWork with the following dimensionless integrands $f(q)$ on $q\\in[10^{-3},10^{3}]$, chosen to exercise a variety of stiffness characteristics. All results are dimensionless, so no physical units are required.\n1. Happy path (regulated bulk): $f_1(q)=q^2\\,e^{-q^2}$.\n2. Narrow localized peak near $q=1$: with $\\gamma=10^{-3}$, $f_2(q)=\\dfrac{q^2\\,e^{-q^2}}{(q-1)^2+\\gamma^2}$.\n3. Heavy-tail suppression: $f_3(q)=\\dfrac{q^2}{1+q^8}$.\n4. Edge-localized near the lower boundary: with $\\gamma=10^{-4}$, $f_4(q)=\\dfrac{q^2}{(q-10^{-3})^2+\\gamma^2}$.\n5. Edge-localized near the upper boundary: with $\\gamma=1$, $f_5(q)=\\dfrac{q^2}{(q-10^{3})^2+\\gamma^2}$.\n\nFor each $f_k$, compute:\n- The relative error of the log-mapped quadrature, $E^{\\mathrm{log}}_k=\\left|\\dfrac{I^{\\mathrm{log}}_k-I^{\\mathrm{ref}}_k}{I^{\\mathrm{ref}}_k}\\right|$, where $I^{\\mathrm{log}}_k$ is the $N=64$ log-mapped Gauss-Legendre estimate and $I^{\\mathrm{ref}}_k$ is the high-accuracy reference.\n- The relative error of the direct quadrature on $q$, $E^{\\mathrm{dir}}_k=\\left|\\dfrac{I^{\\mathrm{dir}}_k-I^{\\mathrm{ref}}_k}{I^{\\mathrm{ref}}_k}\\right|$.\n- The stability metric $R^{\\mathrm{log}}_k$ using the log-mapped contributions.\n- The stability metric $R^{\\mathrm{dir}}_k$ using the direct contributions.\n\nNumerical summations must employ a compensation method to reduce round-off error. Express all angles, if any occur, in radians; none of the test functions involve angles. All outputs are dimensionless real numbers. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered as\n$$\n\\left[ E^{\\mathrm{log}}_1,E^{\\mathrm{dir}}_1,R^{\\mathrm{log}}_1,R^{\\mathrm{dir}}_1,\\;E^{\\mathrm{log}}_2,E^{\\mathrm{dir}}_2,R^{\\mathrm{log}}_2,R^{\\mathrm{dir}}_2,\\;\\dots,\\;E^{\\mathrm{log}}_5,E^{\\mathrm{dir}}_5,R^{\\mathrm{log}}_5,R^{\\mathrm{dir}}_5\\right].\n$$\nEach entry must be printed as a decimal floating-point number. Use at least $N=64$ Gauss-Legendre nodes for both quadrature schemes and tight absolute and relative tolerances for the reference integration.\n\nYour derivation and implementation must be grounded in the change-of-variables theorem and the definition of Gaussian quadrature. Do not provide shortcut formulas; show how the transformed weights and nodes arise from first principles, and analyze how the stability metric captures stiffness in the quadrature sum.", "solution": "The problem requires the derivation and implementation of two Gaussian quadrature schemes for momentum-space integrals on a wide logarithmic scale, and an analysis of their numerical stability. We begin by deriving the quadrature formulas from first principles, as stipulated.\n\nLet the integral of interest be $I = \\int_{q_a}^{q_b} f(q) dq$, where the integration domain is $[q_a, q_b] = [10^{-3}, 10^{3}]$ for the dimensionless momentum $q$. The foundation for both schemes is the $N$-point Gauss-Legendre quadrature rule on the canonical interval $[-1, 1]$:\n$$\n\\int_{-1}^{1} g(t)\\,dt \\approx \\sum_{i=1}^{N} w_i^{\\text{std}} g(t_i^{\\text{std}})\n$$\nwhere $t_i^{\\text{std}}$ are the nodes (zeros of the $N$-th Legendre polynomial) and $w_i^{\\text{std}}$ are the corresponding weights.\n\n**1. Direct Gauss-Legendre Quadrature on $q \\in [q_a, q_b]$**\n\nTo apply Gaussian quadrature to the interval $[q_a, q_b]$, we introduce a linear transformation that maps the canonical variable $t \\in [-1, 1]$ to the physical variable $q \\in [q_a, q_b]$. Let this mapping be $q(t) = c_1 t + c_0$. The boundary conditions $q(-1) = q_a$ and $q(1) = q_b$ determine the constants:\n$$\n-c_1 + c_0 = q_a \\quad \\text{and} \\quad c_1 + c_0 = q_b\n$$\nSolving this system yields $c_1 = \\frac{q_b - q_a}{2}$ and $c_0 = \\frac{q_b + q_a}{2}$. The transformation is:\n$$\nq(t) = \\frac{q_b - q_a}{2}t + \\frac{q_b + q_a}{2}\n$$\nThe differential element transforms as $dq = \\frac{dq}{dt}dt = \\frac{q_b - q_a}{2}dt$. Substituting this into the original integral, we obtain an integral over the canonical interval $[-1, 1]$:\n$$\nI = \\int_{q_a}^{q_b} f(q)\\,dq = \\int_{-1}^{1} f(q(t)) \\frac{dq}{dt}\\,dt = \\int_{-1}^{1} f\\left(\\frac{q_b - q_a}{2}t + \\frac{q_b + q_a}{2}\\right) \\frac{q_b - q_a}{2}\\,dt\n$$\nApplying the Gauss-Legendre rule, the integral is approximated by the sum:\n$$\nI^{\\text{dir}} \\approx \\sum_{i=1}^{N} w_i^{\\text{std}} \\left[ f\\left(\\frac{q_b - q_a}{2}t_i^{\\text{std}} + \\frac{q_b + q_a}{2}\\right) \\right] \\left( \\frac{q_b - q_a}{2} \\right)\n$$\nThis can be expressed as a standard quadrature sum $I^{\\text{dir}} = \\sum_{i=1}^{N} w_i^{\\text{dir}}f(q_i)$, where the nodes $q_i$ and weights $w_i^{\\text{dir}}$ in the $q$-domain are:\n$$\nq_i = \\frac{q_b - q_a}{2}t_i^{\\text{std}} + \\frac{q_b + q_a}{2}\n$$\n$$\nw_i^{\\text{dir}} = w_i^{\\text{std}} \\left( \\frac{q_b - q_a}{2} \\right)\n$$\nThe individual contributions to the sum are $c_i^{\\text{dir}} = w_i^{\\text{dir}}f(q_i)$.\n\n**2. Log-Mapped Gauss-Legendre Quadrature**\n\nFor integrals over a wide dynamic range, a logarithmic change of variables is often advantageous. We apply the mapping $x = \\log q$, which implies $q = e^x$. The differential transforms as $dq = e^x dx$. The integration limits in the new variable $x$ become $x_a = \\log q_a$ and $x_b = \\log q_b$.\nThe integral transforms according to the change-of-variables theorem:\n$$\nI = \\int_{q_a}^{q_b} f(q)\\,dq = \\int_{x_a}^{x_b} f(e^x)e^x\\,dx\n$$\nLet us define the transformed integrand as $G(x) = f(e^x)e^x$. The problem is now to evaluate $I = \\int_{x_a}^{x_b} G(x)\\,dx$. We again use a linear mapping from the canonical interval $t \\in [-1, 1]$ to the $x$-domain interval $[x_a, x_b]$:\n$$\nx(t) = \\frac{x_b - x_a}{2}t + \\frac{x_b + x_a}{2}\n$$\nThe differential is $dx = \\frac{x_b - x_a}{2}dt$. The integral becomes:\n$$\nI = \\int_{-1}^{1} G(x(t)) \\frac{dx}{dt}\\,dt = \\int_{-1}^{1} G\\left(\\frac{x_b - x_a}{2}t + \\frac{x_b + x_a}{2}\\right) \\frac{x_b - x_a}{2}\\,dt\n$$\nApplying the Gauss-Legendre rule yields the approximation:\n$$\nI^{\\text{log}} \\approx \\sum_{i=1}^{N} w_i^{\\text{std}} \\left[ G\\left(\\frac{x_b - x_a}{2}t_i^{\\text{std}} + \\frac{x_b + x_a}{2}\\right) \\right] \\left( \\frac{x_b - x_a}{2} \\right)\n$$\nTo interpret this in terms of the original integrand $f(q)$, we substitute back $G(x) = f(e^x)e^x$. The nodes in the $x$-domain are $x_i = \\frac{x_b - x_a}{2}t_i^{\\text{std}} + \\frac{x_b + x_a}{2}$. The corresponding nodes in the original $q$-domain are $q_i = e^{x_i}$. The quadrature sum is:\n$$\nI^{\\text{log}} = \\sum_{i=1}^{N} w_i^{\\text{std}} \\left[ f(e^{x_i})e^{x_i} \\right] \\left( \\frac{x_b - x_a}{2} \\right) = \\sum_{i=1}^{N} w_i^{\\text{std}} \\left[ f(q_i) q_i \\right] \\left( \\frac{\\log q_b - \\log q_a}{2} \\right)\n$$\nThis can be written as a sum of the form $I^{\\text{log}} = \\sum_{i=1}^{N} w_i^{\\text{log}}f(q_i)$, where the effective weights $w_i^{\\text{log}}$ in the $q$-domain are:\n$$\nw_i^{\\text{log}} = w_i^{\\text{std}} \\cdot q_i \\cdot \\left( \\frac{\\log q_b - \\log q_a}{2} \\right)\n$$\nThe individual contributions are $c_i^{\\text{log}} = w_i^{\\log}f(q_i)$. Unlike the direct method, these effective weights are not constant; they are proportional to the node location $q_i$. This means that nodes at larger momenta are given more weight, which counteracts the $1/q$ density with which the nodes $q_i=e^{x_i}$ are distributed.\n\n**3. Numerical Stability Metric and Stiffness**\n\nThe stability metric is defined as $R = \\frac{\\max_i |c_i|}{\\sum_j |c_j|}$, where $c_i$ are the weighted contributions $w_i f(q_i)$ from each node. This metric quantifies the uniformity of the contributions to the integral's total value.\n- A small value of $R$ (approaching the ideal value of $1/N$) indicates that many nodes contribute significantly to the sum. The quadrature is stable, as the result is an average over many points, making it robust against small errors in function evaluation or node placement.\n- A large value of $R$ (approaching $1$) signifies that the sum is dominated by a single contribution. The integral is effectively approximated by one point, $I \\approx c_k = w_k f(q_k)$. This signals a \"stiff\" problem for the chosen quadrature scheme. The result is numerically unstable: it is highly sensitive to the precise location of the dominant node $q_k$ and prone to large truncation error because the quadrature grid fails to resolve the structure of the integrand. Such dominance often occurs when the integrand has a sharp, narrow peak that is missed by most nodes.\n\nThe direct quadrature distributes nodes with a density that is approximately uniform near the center of $[q_a, q_b]$ and increases towards the endpoints. If the integrand has features localized on a logarithmic scale (e.g., a sharp peak at small $q$ or a heavy tail over many decades), this linear node placement is inefficient. It may allocate too few nodes to the region of interest, leading to a large stability metric $R^{\\text{dir}}$ and poor accuracy.\n\nThe log-mapped quadrature distributes nodes $q_i=e^{x_i}$ such that the number of nodes per decade of momentum is constant. This is highly effective for integrands with multi-scale behavior, sharp features at low momentum, or power-law tails. By changing variables, the integrand is often transformed into a smoother function in the new coordinate $x$, for which standard Gauss-Legendre quadrature is very efficient. This results in more evenly distributed contributions $|c_i^{\\text{log}}|$ and hence a smaller, more desirable stability metric $R^{\\text{log}}$.\n\nTo ensure accurate summation, especially when contributions $c_i$ vary over many orders of magnitude, a compensated summation algorithm (like Kahan summation) is required to mitigate the loss of precision from floating-point round-off errors.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Derives, implements, and compares direct and log-mapped Gaussian quadrature\n    for stiff integrands in computational physics.\n    \"\"\"\n\n    def kahan_sum(arr):\n        \"\"\"Numerically stable summation using the Kahan algorithm.\"\"\"\n        s = 0.0\n        c = 0.0\n        for x in arr:\n            y = x - c\n            t = s + y\n            c = (t - s) - y\n            s = t\n        return s\n\n    # Problem Parameters\n    N = 64\n    q_min, q_max = 1e-3, 1e3\n    \n    # Test suite of integrands\n    gamma2 = 1e-3\n    gamma4 = 1e-4\n    gamma5 = 1.0\n\n    functions = [\n        (\"f1\", lambda q: q**2 * np.exp(-q**2)),\n        (\"f2\", lambda q: (q**2 * np.exp(-q**2)) / ((q - 1.0)**2 + gamma2**2)),\n        (\"f3\", lambda q: q**2 / (1.0 + q**8)),\n        (\"f4\", lambda q: q**2 / ((q - q_min)**2 + gamma4**2)),\n        (\"f5\", lambda q: q**2 / ((q - q_max)**2 + gamma5**2)),\n    ]\n\n    # Standard Gauss-Legendre nodes and weights on [-1, 1]\n    t_std, w_std = np.polynomial.legendre.leggauss(N)\n\n    # --- Direct Gauss-Legendre Quadrature Setup ---\n    # Linear mapping t -> q\n    # q(t) = a*t + b, where a = (q_max-q_min)/2, b = (q_max+q_min)/2\n    a_q = 0.5 * (q_max - q_min)\n    b_q = 0.5 * (q_max + q_min)\n    q_nodes_dir = a_q * t_std + b_q\n    w_dir = a_q * w_std\n\n    # --- Log-Mapped Gauss-Legendre Quadrature Setup ---\n    x_min, x_max = np.log(q_min), np.log(q_max)\n    # Linear mapping t -> x\n    # x(t) = a*t + b, where a = (x_max-x_min)/2, b = (x_max+x_min)/2\n    a_x = 0.5 * (x_max - x_min)\n    b_x = 0.5 * (x_max + x_min)\n    x_nodes = a_x * t_std + b_x\n    q_nodes_log = np.exp(x_nodes)\n    \n    # Effective weights in q-space for log mapping\n    # w_log_i = w_std_i * q_i * (x_max - x_min) / 2\n    w_log_factor = a_x\n    w_log = w_std * q_nodes_log * w_log_factor\n\n    results = []\n\n    for name, f in functions:\n        # 1. High-accuracy reference integral\n        i_ref, _ = quad(f, q_min, q_max, epsabs=1e-15, epsrel=1e-15, limit=200)\n\n        # 2. Direct Quadrature\n        f_vals_dir = f(q_nodes_dir)\n        contributions_dir = w_dir * f_vals_dir\n        i_dir = kahan_sum(contributions_dir)\n        \n        abs_contributions_dir = np.abs(contributions_dir)\n        r_dir = np.max(abs_contributions_dir) / kahan_sum(abs_contributions_dir) if kahan_sum(abs_contributions_dir) != 0 else 1.0\n        e_dir = np.abs((i_dir - i_ref) / i_ref) if i_ref != 0 else 0.0\n\n        # 3. Log-Mapped Quadrature\n        f_vals_log = f(q_nodes_log)\n        contributions_log = w_log * f_vals_log\n        i_log = kahan_sum(contributions_log)\n\n        abs_contributions_log = np.abs(contributions_log)\n        r_log = np.max(abs_contributions_log) / kahan_sum(abs_contributions_log) if kahan_sum(abs_contributions_log) != 0 else 1.0\n        e_log = np.abs((i_log - i_ref) / i_ref) if i_ref != 0 else 0.0\n\n        results.extend([e_log, e_dir, r_log, r_dir])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3561470"}, {"introduction": "A key mark of expertise is knowing not only how to use a tool, but also when *not* to use it. While Gaussian quadrature is a versatile workhorse, it fails dramatically for highly oscillatory integrals, such as the Fourier-Bessel transforms used to calculate form factors. This conceptual practice [@problem_id:3561481] challenges you to compare the performance of Gaussian quadrature against specialized methods designed explicitly for oscillation. By analyzing the trade-offs in accuracy, computational cost, and robustness to noise, you will develop the critical judgment needed to select the most appropriate numerical method for one of the most challenging classes of integrals in physics.", "problem": "In spherical momentum-space analyses of nucleon densities, one often computes the monopole form factor as a spherical Fourier–Bessel transform. Consider the integral\n$$\nI_0(k) \\equiv \\int_{0}^{R} 4\\pi\\, r^2\\, \\rho(r)\\, j_0(k r)\\, dr,\n$$\nwhere $k>0$ is the momentum magnitude, $\\rho(r)$ is a smooth, bounded radial density supported on $[0,R]$, and $j_0(kr)=\\dfrac{\\sin(kr)}{kr}$ is the order-$0$ spherical Bessel function. A closely related model integral frequently used to study numerical quadrature behavior is\n$$\nI(k) \\equiv \\int_{0}^{R} f(r)\\, J_0(k r)\\, r\\, dr,\n$$\nwhere $J_0$ is the order-$0$ Bessel function of the first kind and $f$ is a smooth amplitude. Both $I_0(k)$ and $I(k)$ become highly oscillatory as $kR$ increases, and they arise in the evaluation of response functions and scattering amplitudes in computational nuclear physics.\n\nTwo broad families of quadrature strategies are commonly considered:\n- Gaussian rules, such as Gauss–Legendre quadrature on $[0,R]$ with a change of variables to $[-1,1]$, which do not explicitly encode the oscillatory kernel.\n- Oscillatory-aware rules, such as Levin-type methods or Filon-type methods, which approximate the slowly varying amplitude and treat the known oscillatory kernel analytically.\n\nStarting from basic definitions of quadrature accuracy for smooth functions and the qualitative behavior of oscillatory integrals under increasing frequency, evaluate the following statements about asymptotic cost/error and practical regimes. Select all statements that are correct.\n\nA. For $I(k)$ with smooth $f$, to maintain a fixed error tolerance as $kR$ increases, the number of Gauss–Legendre nodes $N$ must grow proportionally to $kR$ (up to a constant factor), whereas Levin- or Filon-type methods can attain comparable accuracy with $N$ essentially independent of $k$ by incorporating the oscillatory kernel analytically.\n\nB. When $f$ is available only as noisy tabulated data (for example, from Monte Carlo sampling) with limited smoothness, Gauss–Legendre with moderate order and interval partitioning can outperform Levin- or Filon-type methods at the same tolerance, because oscillatory-aware schemes rely on smooth interpolation and, in some variants, derivatives of $f$ that are unstable under noise.\n\nC. In the preasymptotic regime $kR\\ll 1$, the integrand is only weakly oscillatory, so Levin- or Filon-type methods lose their main advantage; a high-order Gauss–Legendre rule (or even a low-order composite rule) can achieve the target accuracy with fewer total function evaluations.\n\nD. In many-$k$ evaluations with a fixed $f$, Gauss–Legendre quadrature is never competitive because the function values cannot be reused across different $k$, while Levin- or Filon-type methods can reuse all computed quantities.\n\nE. For kernels with linear phase (such as $\\sin(kr)$ or $J_0(kr)$ on $[0,R]$), Gauss–Legendre nodes can be chosen to exactly integrate the oscillations so that, for fixed $N$, the error of Gauss–Legendre decays exponentially as $k$ increases without refining the grid.\n\nF. If evaluating $f(r)$ dominates the cost and one needs $I(k)$ for many values of $k$ with the same $f$, then using a fixed Gauss–Legendre grid can be competitive because the values $f(r_i)$ at the quadrature nodes $r_i$ are reusable while the $k$-dependence enters only through the inexpensive evaluation of the known kernel; by contrast, Levin- or Filon-type methods typically require $k$-dependent preprocessing or moments that must be recomputed (at least in part) for each $k$.\n\nSelect all correct options.", "solution": "### Problem Validation\n\n#### Step 1: Extract Givens\n\nThe problem statement provides the following definitions and context:\n1.  An integral for the monopole form factor: $I_0(k) \\equiv \\int_{0}^{R} 4\\pi\\, r^2\\, \\rho(r)\\, j_0(k r)\\, dr$.\n2.  Definitions for the entities in $I_0(k)$:\n    -   $k > 0$ is the momentum magnitude.\n    -   $\\rho(r)$ is a smooth, bounded radial density supported on $[0,R]$.\n    -   $j_0(kr) = \\frac{\\sin(kr)}{kr}$ is the order-$0$ spherical Bessel function.\n3.  A related model integral: $I(k) \\equiv \\int_{0}^{R} f(r)\\, J_0(k r)\\, r\\, dr$.\n4.  Definitions for the entities in $I(k)$:\n    -   $J_0$ is the order-$0$ Bessel function of the first kind.\n    -   $f$ is a smooth amplitude.\n5.  A key property: Both integrals become highly oscillatory as $kR$ increases.\n6.  Two families of quadrature strategies are described:\n    -   **Gaussian rules**: Example is Gauss–Legendre quadrature. They do not explicitly encode the oscillatory kernel.\n    -   **Oscillatory-aware rules**: Examples are Levin-type and Filon-type methods. They approximate the slowly varying amplitude and treat the known oscillatory kernel analytically.\n\nThe task is to evaluate a series of statements about the asymptotic cost/error and practical regimes of these methods.\n\n#### Step 2: Validate Using Extracted Givens\n\n-   **Scientifically Grounded**: The problem is firmly rooted in computational physics and numerical analysis. The integrals $I_0(k)$ and $I(k)$ are standard forms of spherical Fourier-Bessel transforms, which are fundamental in nuclear and particle physics for calculating form factors from charge or nucleon densities. The descriptions of Gaussian, Levin, and Filon quadrature methods are accurate representations of established numerical techniques.\n-   **Well-Posed**: The problem is a conceptual evaluation of established numerical methods under different, clearly described conditions. It asks for an assessment of the correctness of several statements, which is a well-defined task. The statements concern the performance (accuracy, cost, robustness) of these methods, which are standard metrics in numerical analysis.\n-   **Objective**: The problem is stated in objective, technical language. It defines the context and methods clearly and asks for an evaluation based on their known mathematical properties. There are no subjective or opinion-based claims in the problem setup.\n\nThe problem contains no scientific or factual unsoundness, is formalizable, is relevant to the topic, is self-contained, is realistic, and is well-structured.\n\n#### Step 3: Verdict and Action\n\nThe problem statement is valid. It is a well-posed and scientifically sound question comparing standard numerical quadrature methods for a common class of problems in computational physics. Proceeding to the solution.\n\n### Solution Derivation\n\nThe problem requires a comparative analysis of two classes of numerical quadrature methods for highly oscillatory integrals of the form $\\int_a^b f(x) K(k,x) dx$, where $K(k,x)$ is an oscillatory kernel like $J_0(kx)$ or $j_0(kx)$.\n\n1.  **Gaussian Quadrature (e.g., Gauss-Legendre)**: This method approximates the entire integrand, $g(x) = f(x) K(k,x)$, with a single high-degree polynomial. The quadrature sum is $\\int_{-1}^1 G(u) du \\approx \\sum_{i=1}^N w_i G(u_i)$, where $G(u)$ is the transformed integrand on the interval $[-1,1]$. The error of an $N$-point rule is proportional to the $(2N)$-th derivative of the integrand. For an oscillatory integrand, the derivatives scale with high powers of the frequency $k$. For instance, $\\frac{d^{2N}}{dx^{2N}} (f(x) \\sin(kx)) \\approx k^{2N} f(x) \\sin(kx + N\\pi)$. Consequently, to maintain a fixed error tolerance as $k$ increases, the number of nodes $N$ must grow proportionally to the number of oscillations across the interval, i.e., $N \\propto k(R-0) = kR$.\n\n2.  **Oscillatory-Aware Methods (Levin/Filon)**: These methods are based on rewriting the integral by partitioning the integrand into a slowly varying part $f(x)$ and a known oscillatory kernel $K(k,x)$. They approximate only the smooth part, $f(x)$, by a polynomial, $p(x) \\approx f(x)$. The integral is then computed as $\\int_a^b p(x) K(k,x) dx$. The terms $\\int_a^b x^j K(k,x) dx$, known as moments, are computed analytically or by other specialized means. The error depends on how well $p(x)$ approximates $f(x)$, which is independent of the frequency $k$. Therefore, for a fixed smooth function $f(x)$, the number of nodes $N$ required to achieve a given accuracy is largely independent of $k$.\n\nWith these principles, we can evaluate each statement.\n\n### Option-by-Option Analysis\n\n**A. For $I(k)$ with smooth $f$, to maintain a fixed error tolerance as $kR$ increases, the number of Gauss–Legendre nodes $N$ must grow proportionally to $kR$ (up to a constant factor), whereas Levin- or Filon-type methods can attain comparable accuracy with $N$ essentially independent of $k$ by incorporating the oscillatory kernel analytically.**\nThis statement accurately captures the fundamental asymptotic behavior of the two classes of methods. As derived above, standard Gaussian quadrature requires a number of points sufficient to resolve every oscillation of the integrand, leading to the requirement $N \\propto kR$. In contrast, oscillatory-aware methods achieve accuracy by approximating the smooth envelope $f(r)$, making the required number of points $N$ for a given accuracy largely independent of $k$.\n**Verdict: Correct.**\n\n**B. When $f$ is available only as noisy tabulated data (for example, from Monte Carlo sampling) with limited smoothness, Gauss–Legendre with moderate order and interval partitioning can outperform Levin- or Filon-type methods at the same tolerance, because oscillatory-aware schemes rely on smooth interpolation and, in some variants, derivatives of $f$ that are unstable under noise.**\nThis statement addresses a crucial practical consideration. Filon-type methods explicitly require derivatives of the function $f(r)$ at interpolation points. For instance, the classical Filon method uses $f(a)$, $f'(a)$, $f(b)$, $f'(b)$, etc. Levin-type methods involve finding an auxiliary function whose derivatives are related to $f(r)$, which is also sensitive to the smoothness of $f(r)$. If $f(r)$ is noisy, its derivatives are ill-defined or extremely noisy, which can destroy the accuracy of these methods. Composite Gauss-Legendre, on the other hand, operates by averaging function values. While noise still impacts accuracy, the method is far more robust because it does not rely on unstable numerical differentiation.\n**Verdict: Correct.**\n\n**C. In the preasymptotic regime $kR\\ll 1$, the integrand is only weakly oscillatory, so Levin- or Filon-type methods lose their main advantage; a high-order Gauss–Legendre rule (or even a low-order composite rule) can achieve the target accuracy with fewer total function evaluations.**\nWhen $kR \\ll 1$, the argument of the Bessel function $kr$ is small across the entire integration interval $[0,R]$. For small arguments, $J_0(x) \\approx 1 - x^2/4$, which is a very smooth, polynomial-like function. The entire integrand $f(r)J_0(kr)r$ is therefore a smooth function. Gauss-Legendre quadrature is designed to be optimally efficient for integrating smooth (analytic) functions, often achieving exponential convergence. The specialized machinery of Levin/Filon methods, such as the computation of oscillatory moments, represents an unnecessary overhead for non-oscillatory problems. Thus, a standard Gaussian rule will be more efficient.\n**Verdict: Correct.**\n\n**D. In many-$k$ evaluations with a fixed $f$, Gauss–Legendre quadrature is never competitive because the function values cannot be reused across different $k$, while Levin- or Filon-type methods can reuse all computed quantities.**\nThis statement is factually incorrect. For a many-$k$ evaluation using Gauss-Legendre on a fixed grid $\\{r_i\\}$, the function values $\\{f(r_i)\\}$ are computed only once. For each new $k$, one simply evaluates the inexpensive kernel $J_0(kr_i)$ and re-sums: $\\sum_i w_i f(r_i) J_0(k r_i) r_i$. Conversely, Filon/Levin methods require moments like $M_j(k) = \\int_0^R r^j J_0(kr) dr$. These moments depend explicitly on $k$ and must be recomputed for each value of $k$. Therefore, it is the oscillatory-aware methods that cannot reuse all computed quantities. The premise of the statement is reversed.\n**Verdict: Incorrect.**\n\n**E. For kernels with linear phase (such as $\\sin(kr)$ or $J_0(kr)$ on $[0,R]$), Gauss–Legendre nodes can be chosen to exactly integrate the oscillations so that, for fixed $N$, the error of Gauss–Legendre decays exponentially as $k$ increases without refining the grid.**\nThis statement fundamentally misrepresents Gauss-Legendre quadrature. The nodes and weights of an $N$-point Gauss-Legendre rule are determined solely by the properties of Legendre polynomials to integrate any polynomial of degree up to $2N-1$ exactly, with respect to the weight function $w(x)=1$ on $[-1,1]$. They are independent of the specific function being integrated. For a fixed $N$, as $k$ increases, the integrand becomes more oscillatory, and the error of Gauss-Legendre quadrature does not decay; it grows rapidly. There exist special \"Gaussian\" quadratures designed for oscillatory kernels (e.g., using $\\sin(kx)$ as a weight function), but that is not what standard Gauss-Legendre quadrature is. The described behavior is the opposite of reality.\n**Verdict: Incorrect.**\n\n**F. If evaluating $f(r)$ dominates the cost and one needs $I(k)$ for many values of $k$ with the same $f$, then using a fixed Gauss–Legendre grid can be competitive because the values $f(r_i)$ at the quadrature nodes $r_i$ are reusable while the $k$-dependence enters only through the inexpensive evaluation of the known kernel; by contrast, Levin- or Filon-type methods typically require $k$-dependent preprocessing or moments that must be recomputed (at least in part) for each $k$.**\nThis statement accurately describes a practical trade-off in computational cost, directly contradicting the false claim in option D. In a scenario where $f(r)$ is very expensive to evaluate (e.g., it comes from a complex simulation), one can pre-compute $f(r_i)$ on a dense, fixed grid. The evaluation of $I(k)$ for many different $k$ then becomes a series of inexpensive summations. Although a very large $N$ might be needed for Gauss-Legendre to be accurate at high $k$, the ability to amortize the expensive $f(r_i)$ evaluations across many $k$ values makes it a competitive strategy. The contrast with Filon/Levin methods, which require $k$-dependent and often costly preprocessing (recomputing moments, etc.) for each new $k$, is also correctly stated.\n**Verdict: Correct.**\n\n### Summary\n\nThe correct statements are A, B, C, and F. They accurately describe the asymptotic performance, practical limitations, and computational cost trade-offs between standard Gaussian quadrature and specialized oscillatory quadrature methods.", "answer": "$$\\boxed{ABCF}$$", "id": "3561481"}]}