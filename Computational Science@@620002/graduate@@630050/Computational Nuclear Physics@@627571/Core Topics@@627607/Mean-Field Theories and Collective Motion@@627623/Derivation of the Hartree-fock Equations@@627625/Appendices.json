{"hands_on_practices": [{"introduction": "This first practice grounds our study in the foundational principles of deriving the Hartree-Fock (HF) equations. Starting from a given energy functional, we will apply the variational principle to obtain the single-particle Schrödinger-like equations that govern the nucleon orbitals. This exercise [@problem_id:3555821] is crucial as it demonstrates how a complex many-body problem is mapped onto a more tractable mean-field picture, and it explicitly handles the distinct nature of protons and neutrons, including the essential Coulomb interaction for protons through both its direct (Hartree) and exchange (Fock) components, the latter treated in the widely used Slater local-density approximation.", "problem": "Consider a two-component system of nucleons in a finite nucleus: protons and neutrons. Let the single-particle orbitals be $\\{\\phi_{p,i}(\\mathbf{r},\\sigma)\\}$ for protons and $\\{\\phi_{n,i}(\\mathbf{r},\\sigma)\\}$ for neutrons, where $\\sigma$ denotes the spin coordinate and $i$ indexes occupied orbitals. The total energy functional is modeled as a sum of kinetic energies, a nuclear interaction contribution, and the proton-proton Coulomb interaction, which is decomposed into a classical Hartree (direct) part and a Slater local-density approximation to the Fock (exchange) part. Specifically, take\n$$\nE[\\{\\phi_{p,i}\\},\\{\\phi_{n,i}\\}] \\;=\\; \\sum_{i\\in \\text{occ}} \\left\\langle \\phi_{p,i} \\left| -\\frac{\\hbar^2}{2m_p}\\nabla^2 \\right| \\phi_{p,i} \\right\\rangle \\;+\\; \\sum_{i\\in \\text{occ}} \\left\\langle \\phi_{n,i} \\left| -\\frac{\\hbar^2}{2m_n}\\nabla^2 \\right| \\phi_{n,i} \\right\\rangle \\;+\\; E_{\\text{N}}[\\rho_p,\\rho_n] \\;+\\; E_{\\text{C}}^{\\text{dir}}[\\rho_p] \\;+\\; E_{\\text{C}}^{\\text{x}}[\\rho_p],\n$$\nwhere the local densities are\n$$\n\\rho_p(\\mathbf{r}) \\;=\\; \\sum_{i\\in \\text{occ}} \\sum_{\\sigma} |\\phi_{p,i}(\\mathbf{r},\\sigma)|^2, \n\\qquad\n\\rho_n(\\mathbf{r}) \\;=\\; \\sum_{i\\in \\text{occ}} \\sum_{\\sigma} |\\phi_{n,i}(\\mathbf{r},\\sigma)|^2,\n$$\nthe nuclear interaction energy $E_{\\text{N}}[\\rho_p,\\rho_n]$ is a differentiable functional of $(\\rho_p,\\rho_n)$ representing short-range strong interactions (e.g., a Skyrme-type energy density functional), the proton-proton Coulomb Hartree energy is\n$$\nE_{\\text{C}}^{\\text{dir}}[\\rho_p] \\;=\\; \\frac{e^2}{2} \\int d^3\\mathbf{r} \\int d^3\\mathbf{r}' \\; \\frac{\\rho_p(\\mathbf{r})\\,\\rho_p(\\mathbf{r}')}{|\\mathbf{r}-\\mathbf{r}'|},\n$$\nand the Slater local-density approximation to the Coulomb exchange energy is\n$$\nE_{\\text{C}}^{\\text{x}}[\\rho_p] \\;=\\; -\\frac{3}{4}\\,e^2 \\left(\\frac{3}{\\pi}\\right)^{1/3} \\int d^3\\mathbf{r} \\; [\\rho_p(\\mathbf{r})]^{4/3}.\n$$\nEnforce separate particle-number constraints for protons and neutrons with distinct Lagrange multipliers $\\lambda_p$ and $\\lambda_n$:\n$$\n\\int d^3\\mathbf{r}\\;\\rho_p(\\mathbf{r}) \\;=\\; N_p, \n\\qquad \n\\int d^3\\mathbf{r}\\;\\rho_n(\\mathbf{r}) \\;=\\; N_n.\n$$\nTasks:\n1) Starting from the principle of stationary action for the energy functional under the above constraints, derive the Hartree-Fock (HF) single-particle equations for protons and neutrons. Express the proton mean-field potential as the sum of the nuclear, Coulomb direct, and Slater-exchange local contributions obtained by functional differentiation with respect to $\\rho_p(\\mathbf{r})$. Similarly, write the neutron HF equation, noting the absence of Coulomb terms.\n2) In the local-density approximation, consider the interior of a spherical even-even nucleus where the proton density may be regarded as approximately constant with value $\\rho_{p,0}$ over the region where the proton Fermi-level orbitals have significant support. Treat the Coulomb exchange as a local potential $V_{\\text{C}}^{\\text{x}}(\\mathbf{r})$ added to the proton single-particle Hamiltonian. Derive an analytic expression for the exchange-induced shift of the proton Fermi energy, $\\Delta \\epsilon_{F,p}$, defined as the change in $\\epsilon_{F,p}$ when turning on $E_{\\text{C}}^{\\text{x}}[\\rho_p]$ while keeping all other contributions fixed. Express your final answer as a closed-form analytic expression in terms of $e$ and $\\rho_{p,0}$. No numerical evaluation is required.\nYour final answer must be a single analytical expression. If you introduce physical constants or densities, keep them symbolic. Do not include units in the final boxed answer.", "solution": "The problem is valid as it is well-posed, scientifically grounded in the principles of quantum mechanics and nuclear physics (specifically, mean-field theory and density functional theory), and uses precise, objective definitions. It does not violate any of the specified invalidity criteria. We proceed with the solution.\n\n### Task 1: Derivation of the Hartree-Fock Equations\n\nThe Hartree-Fock (HF) equations are derived by applying the variational principle to the total energy functional $E$, subject to the constraint that the single-particle orbitals remain orthonormal. This is achieved by minimizing the functional $\\mathcal{L} = E - \\sum_{\\alpha \\in \\{p,n\\}} \\sum_{i,j \\in \\text{occ}} \\epsilon_{\\alpha,ij} (\\langle \\phi_{\\alpha,i} | \\phi_{\\alpha,j} \\rangle - \\delta_{ij})$, where $\\epsilon_{\\alpha,ij}$ are Lagrange multipliers. A unitary transformation among the occupied orbitals of a given type (proton or neutron) can diagonalize the matrix of Lagrange multipliers without changing the total energy, which depends only on the total density. Thus, we can simplify the problem to minimizing $E$ subject to $\\langle \\phi_{\\alpha,i} | \\phi_{\\alpha,i} \\rangle = 1$, which leads to the canonical HF equations:\n$$\n\\frac{\\delta E}{\\delta \\phi_{\\alpha,i}^*(\\mathbf{r},\\sigma)} = \\epsilon_{\\alpha,i} \\phi_{\\alpha,i}(\\mathbf{r},\\sigma)\n$$\nwhere $\\epsilon_{\\alpha,i}$ are the single-particle energies.\n\nWe will derive the equations for protons and neutrons separately.\n\n**Proton Hartree-Fock Equation:**\n\nWe compute the functional derivative of the total energy $E$ with respect to a proton orbital $\\phi_{p,i}^*(\\mathbf{r},\\sigma)$.\n\n$1$. **Kinetic Energy Term:**\nThe proton kinetic energy is $E_{\\text{kin},p} = \\sum_{j\\in \\text{occ}} \\left\\langle \\phi_{p,j} \\left| -\\frac{\\hbar^2}{2m_p}\\nabla^2 \\right| \\phi_{p,j} \\right\\rangle$. Its functional derivative with respect to $\\phi_{p,i}^*$ is:\n$$\n\\frac{\\delta E_{\\text{kin},p}}{\\delta \\phi_{p,i}^*(\\mathbf{r},\\sigma)} = -\\frac{\\hbar^2}{2m_p}\\nabla^2 \\phi_{p,i}(\\mathbf{r},\\sigma)\n$$\nThe neutron kinetic energy term $E_{\\text{kin},n}$ is independent of $\\phi_{p,i}$, so its derivative is zero.\n\n$2$. **Density-Dependent Terms:**\nThe remaining terms, $E_{\\text{N}}$, $E_{\\text{C}}^{\\text{dir}}$, and $E_{\\text{C}}^{\\text{x}}$, are functionals of the densities $\\rho_p$ and $\\rho_n$. We use the chain rule for functional derivatives. First, we find the derivative of the proton density $\\rho_p(\\mathbf{r}')$ with respect to $\\phi_{p,i}^*(\\mathbf{r},\\sigma)$:\n$$\n\\rho_p(\\mathbf{r}') = \\sum_{j\\in \\text{occ}} \\sum_{\\sigma'} \\phi_{p,j}^*(\\mathbf{r}',\\sigma')\\phi_{p,j}(\\mathbf{r}',\\sigma')\n$$\n$$\n\\frac{\\delta \\rho_p(\\mathbf{r}')}{\\delta \\phi_{p,i}^*(\\mathbf{r},\\sigma)} = \\phi_{p,i}(\\mathbf{r}',\\sigma') \\delta(\\mathbf{r}-\\mathbf{r}') \\delta_{\\sigma\\sigma'}\n$$\nFor a general energy functional $E_{int}[\\rho_p]$, its derivative is:\n$$\n\\frac{\\delta E_{int}[\\rho_p]}{\\delta \\phi_{p,i}^*(\\mathbf{r},\\sigma)} = \\int d^3\\mathbf{r}' \\frac{\\delta E_{int}}{\\delta \\rho_p(\\mathbf{r}')} \\frac{\\delta \\rho_p(\\mathbf{r}')}{\\delta \\phi_{p,i}^*(\\mathbf{r},\\sigma)} = \\int d^3\\mathbf{r}' \\frac{\\delta E_{int}}{\\delta \\rho_p(\\mathbf{r}')} \\phi_{p,i}(\\mathbf{r}',\\sigma') \\delta(\\mathbf{r}-\\mathbf{r}')\\delta_{\\sigma\\sigma'} = \\frac{\\delta E_{int}}{\\delta \\rho_p(\\mathbf{r})} \\phi_{p,i}(\\mathbf{r},\\sigma)\n$$\nThis defines the local potential corresponding to $E_{int}$. We apply this to each of the three interaction terms.\n\na) **Nuclear Potential:** The contribution from the nuclear energy functional is $U_{N,p}(\\mathbf{r}) \\phi_{p,i}(\\mathbf{r},\\sigma)$, where the local potential is:\n$$\nU_{N,p}(\\mathbf{r}) = \\frac{\\delta E_{\\text{N}}[\\rho_p, \\rho_n]}{\\delta \\rho_p(\\mathbf{r})}\n$$\n\nb) **Coulomb Direct (Hartree) Potential:** For $E_{\\text{C}}^{\\text{dir}}[\\rho_p] = \\frac{e^2}{2} \\int d^3\\mathbf{r}' \\int d^3\\mathbf{r}'' \\frac{\\rho_p(\\mathbf{r}')\\,\\rho_p(\\mathbf{r}'')}{|\\mathbf{r}'-\\mathbf{r}''|}$, the functional derivative is:\n$$\nV_{\\text{C}}^{\\text{dir}}(\\mathbf{r}) = \\frac{\\delta E_{\\text{C}}^{\\text{dir}}}{\\delta \\rho_p(\\mathbf{r})} = \\frac{e^2}{2} \\int d^3\\mathbf{r}' \\int d^3\\mathbf{r}'' \\frac{\\delta(\\mathbf{r}-\\mathbf{r}')\\rho_p(\\mathbf{r}'') + \\rho_p(\\mathbf{r}')\\delta(\\mathbf{r}-\\mathbf{r}'')}{|\\mathbf{r}'-\\mathbf{r}''|} = e^2 \\int d^3\\mathbf{r}' \\frac{\\rho_p(\\mathbf{r}')}{|\\mathbf{r}-\\mathbf{r}'|}\n$$\n\nc) **Coulomb Exchange (Slater) Potential:** For $E_{\\text{C}}^{\\text{x}}[\\rho_p] = -\\frac{3}{4}e^2 \\left(\\frac{3}{\\pi}\\right)^{1/3} \\int d^3\\mathbf{r}' [\\rho_p(\\mathbf{r}')]^{4/3}$, the functional derivative is:\n$$\nV_{\\text{C}}^{\\text{x}}(\\mathbf{r}) = \\frac{\\delta E_{\\text{C}}^{\\text{x}}}{\\delta \\rho_p(\\mathbf{r})} = -\\frac{3}{4}e^2 \\left(\\frac{3}{\\pi}\\right)^{1/3} \\cdot \\frac{4}{3} [\\rho_p(\\mathbf{r})]^{1/3} = -e^2 \\left(\\frac{3}{\\pi}\\right)^{1/3} [\\rho_p(\\mathbf{r})]^{1/3}\n$$\n\n**Assembling the Proton HF Equation:**\nCombining all terms, the HF equation for a proton in orbital $\\phi_{p,i}$ is:\n$$\n\\left[ -\\frac{\\hbar^2}{2m_p}\\nabla^2 + U_p(\\mathbf{r}) \\right] \\phi_{p,i}(\\mathbf{r},\\sigma) = \\epsilon_{p,i} \\phi_{p,i}(\\mathbf{r},\\sigma)\n$$\nwhere the total proton mean-field potential $U_p(\\mathbf{r})$ is the sum of the nuclear, Coulomb direct, and Coulomb exchange parts:\n$$\nU_p(\\mathbf{r}) = U_{N,p}(\\mathbf{r}) + V_{\\text{C}}^{\\text{dir}}(\\mathbf{r}) + V_{\\text{C}}^{\\text{x}}(\\mathbf{r})\n$$\nwith the individual potentials as derived above.\n\n**Neutron Hartree-Fock Equation:**\n\nThe derivation for the neutron HF equation is analogous. We take the functional derivative of $E$ with respect to a neutron orbital $\\phi_{n,i}^*(\\mathbf{r},\\sigma)$.\n\n$1$. **Kinetic Energy Term:** The derivative of $E_{\\text{kin},n}$ gives $-\\frac{\\hbar^2}{2m_n}\\nabla^2 \\phi_{n,i}(\\mathbf{r},\\sigma)$. The proton kinetic term is independent of $\\phi_{n,i}$.\n\n$2$. **Interaction Terms:** The Coulomb terms $E_{\\text{C}}^{\\text{dir}}$ and $E_{\\text{C}}^{\\text{x}}$ depend only on the proton density $\\rho_p$, so their derivatives with respect to $\\phi_{n,i}^*$ are zero. Only the nuclear energy functional $E_{\\text{N}}[\\rho_p, \\rho_n]$ depends on the neutron density $\\rho_n$. The corresponding potential is:\n$$\nU_n(\\mathbf{r}) = \\frac{\\delta E_{\\text{N}}[\\rho_p, \\rho_n]}{\\delta \\rho_n(\\mathbf{r})}\n$$\n\n**Assembling the Neutron HF Equation:**\nThe HF equation for a neutron in orbital $\\phi_{n,i}$ is:\n$$\n\\left[ -\\frac{\\hbar^2}{2m_n}\\nabla^2 + U_n(\\mathbf{r}) \\right] \\phi_{n,i}(\\mathbf{r},\\sigma) = \\epsilon_{n,i} \\phi_{n,i}(\\mathbf{r},\\sigma)\n$$\nwhere the neutron mean-field potential $U_n(\\mathbf{r})$ contains only the nuclear contribution, as neutrons do not participate in the Coulomb interaction. The particle number constraints for $N_p$ and $N_n$ are satisfied by populating the lowest $N_p/2$ proton orbitals and $N_n/2$ neutron orbitals (for spin-saturated systems). The Lagrange multipliers $\\lambda_p$ and $\\lambda_n$ mentioned in the problem statement correspond to the Fermi energies (chemical potentials) of the proton and neutron systems, respectively.\n\n### Task 2: Shift in Proton Fermi Energy\n\nThe second task is to find the exchange-induced shift of the proton Fermi energy, $\\Delta \\epsilon_{F,p}$. We are to assume a constant proton density, $\\rho_p(\\mathbf{r}) = \\rho_{p,0}$, which is a good approximation for the interior of a heavy nucleus (uniform nuclear matter).\n\nThe proton single-particle Hamiltonian from Task 1 is $h_p = T_p + U_p$, where $T_p = -\\frac{\\hbar^2}{2m_p}\\nabla^2$. The exchange potential is given by $V_{\\text{C}}^{\\text{x}}(\\mathbf{r}) = -e^2 \\left(\\frac{3}{\\pi}\\right)^{1/3} [\\rho_p(\\mathbf{r})]^{1/3}$.\n\nUnder the approximation of constant proton density $\\rho_{p,0}$, the exchange potential $V_{\\text{C}}^{\\text{x}}(\\mathbf{r})$ becomes a spatially constant value:\n$$\nV_{\\text{C}}^{\\text{x}} = -e^2 \\left(\\frac{3}{\\pi}\\right)^{1/3} [\\rho_{p,0}]^{1/3}\n$$\nThe problem asks for the shift in the proton Fermi energy $\\epsilon_{F,p}$ when \"turning on\" the exchange energy contribution $E_{\\text{C}}^{\\text{x}}$, while keeping other contributions fixed. This is equivalent to adding the potential $V_{\\text{C}}^{\\text{x}}$ to the single-particle Hamiltonian that excludes it.\n\nAdding a constant potential $V_0$ to a Hamiltonian $H_0$ shifts all of its energy eigenvalues by that constant amount:\nIf $H_0|\\psi\\rangle = E|\\psi\\rangle$, then $(H_0 + V_0)|\\psi\\rangle = (E + V_0)|\\psi\\rangle$.\n\nTherefore, the energy of every proton single-particle level, including the Fermi level (the highest occupied level), is shifted by the constant value of the exchange potential. The exchange-induced shift of the proton Fermi energy, $\\Delta \\epsilon_{F,p}$, is thus equal to this constant potential.\n$$\n\\Delta \\epsilon_{F,p} = V_{\\text{C}}^{\\text{x}}(\\rho_{p,0}) = -e^2 \\left(\\frac{3}{\\pi}\\right)^{1/3} \\rho_{p,0}^{1/3}\n$$\nThis expression represents the change in the proton chemical potential due to the Coulomb exchange interaction in a uniform proton gas of density $\\rho_{p,0}$. The negative sign indicates that the exchange interaction is attractive and lowers the single-particle energies.", "answer": "$$\n\\boxed{-e^2 \\left(\\frac{3}{\\pi}\\right)^{1/3} \\rho_{p,0}^{1/3}}\n$$", "id": "3555821"}, {"introduction": "Having derived the form of the Hartree-Fock equations, the next critical step is to solve them. Since the mean-field potential depends on the orbitals which are themselves solutions to the equations, the problem is nonlinear and must be solved iteratively until self-consistency is achieved. This exercise [@problem_id:3555808] guides you through building a complete self-consistent field (SCF) solver from scratch for a schematic but instructive model. Furthermore, it introduces the powerful technique of constrained calculations, using a Lagrange multiplier to explore the nuclear energy landscape as a function of collective variables like the quadrupole moment, a standard practice for studying nuclear deformation.", "problem": "Consider a system of identical spinless fermions confined to a finite orthonormal single-particle basis of dimension $M$, with a one-body Hamiltonian $\\hat{h}_0$ and a schematic separable two-body interaction of quadrupole-quadrupole type, characterized by a strength parameter $\\kappa$. Let $\\hat{Q}_{20}$ denote the axial mass quadrupole operator represented in the single-particle basis. The many-body trial state is restricted to Slater determinants built from $N$ orthonormal orbitals $\\{\\phi_k\\}$, $k = 1,\\dots,N$, which are columns of a unitary matrix that diagonalizes a self-consistent mean-field operator. You will incorporate a quadrupole constraint using a Lagrange multiplier $\\lambda_Q$, derived at the level of the variational principle with constraints. Your tasks are as follows.\n\nTask A (derivation from first principles): Starting from the Ritz variational principle for the expectation value of the energy and enforcing:\n- orthonormality of the single-particle orbitals,\n- fixed particle number $N$,\n- a linear constraint on the axial quadrupole moment via a Lagrange multiplier $\\lambda_Q$,\nshow how the Euler-Lagrange equations lead to single-particle equations with a modified, state-independent one-body operator that depends self-consistently on the occupied orbitals and the Lagrange multiplier. Use only the following as your starting base:\n- the definition of the Slater determinant and one-body density matrix $\\rho$,\n- the quadratic form of the separable interaction energy in the mean-field approximation,\n- the Rayleigh-Ritz principle with Lagrange multipliers for constraints,\n- the orthonormality condition for orbitals.\n\nExplicitly identify:\n- the structure of the mean-field contribution from a separable interaction $-\\frac{\\kappa}{2}\\hat{Q}_{20}\\hat{Q}_{20}$ in terms of the average quadrupole moment $\\langle \\hat{Q}_{20} \\rangle$,\n- how the quadrupole constraint modifies the effective single-particle operator,\n- the self-consistency condition that closes the equations.\n\nDo not use any pre-quoted target formulas; derive them.\n\nTask B (computational self-consistency): Implement a self-consistent solver for the constrained mean-field problem in a fixed single-particle basis with the following data (all in arbitrary units):\n- Basis dimension $M = 6$ and particle number $N = 3$.\n- One-body Hamiltonian $\\hat{h}_0$ represented by the diagonal matrix\n$$\nh_0 = \\mathrm{diag}\\left(0.0,\\;0.9,\\;1.7,\\;2.8,\\;4.2,\\;6.0\\right).\n$$\n- Axial quadrupole operator $\\hat{Q}_{20}$ represented by the symmetric real matrix\n$$\nQ = \\begin{pmatrix}\n-2.0 & 0.20 & 0.05 & 0 & 0 & 0 \\\\\n0.20 & -0.8 & 0.20 & 0.05 & 0 & 0 \\\\\n0.05 & 0.20 & 0.3 & 0.20 & 0.05 & 0 \\\\\n0 & 0.05 & 0.20 & 0.9 & 0.20 & 0.05 \\\\\n0 & 0 & 0.05 & 0.20 & 1.6 & 0.20 \\\\\n0 & 0 & 0 & 0.05 & 0.20 & 2.2\n\\end{pmatrix}.\n$$\n- Interaction strength $\\kappa = 0.25$.\n\nYour solver should:\n- initialize a density matrix $\\rho$ by occupying the $N$ lowest eigenstates of $\\hat{h}_0$,\n- iterate the following until convergence:\n  - build the effective one-body operator implied by Task A,\n  - diagonalize it to obtain new single-particle states and energies,\n  - occupy the $N$ lowest-energy states to update $\\rho$ and the average quadrupole $\\langle \\hat{Q}_{20} \\rangle = \\mathrm{Tr}(\\rho Q)$,\n  - use simple linear mixing on the scalar $\\langle \\hat{Q}_{20} \\rangle$ to stabilize convergence,\n- declare convergence when the change in $\\langle \\hat{Q}_{20} \\rangle$ is below $\\tau = 10^{-10}$ or a maximum of $10^4$ iterations is reached.\n\nFor each converged solution, compute:\n- the Hartree-Fock (HF) mean-field energy\n$$\nE_{\\mathrm{HF}}[\\rho] = \\mathrm{Tr}(\\rho h_0) - \\frac{\\kappa}{2}\\,\\langle \\hat{Q}_{20} \\rangle^2,\n$$\n- the Routhian (constrained functional)\n$$\n\\mathcal{R}(\\lambda_Q) = E_{\\mathrm{HF}}[\\rho(\\lambda_Q)] + \\lambda_Q \\,\\langle \\hat{Q}_{20} \\rangle.\n$$\n\nNumerical verification (sensitivity of spectrum and variational derivative): For each test value of $\\lambda_Q$ below, after convergence report:\n- the converged quadrupole moment $\\langle \\hat{Q}_{20} \\rangle$,\n- the lowest $N$ self-consistent single-particle eigenvalues (ordered ascending) to quantify the effect on the spectrum,\n- a boolean flag that is true when the central-difference approximation to $\\frac{d\\mathcal{R}}{d\\lambda_Q}$ at the given $\\lambda_Q$ equals the converged $\\langle \\hat{Q}_{20} \\rangle$ within a tolerance $\\delta = 5 \\times 10^{-5}$. Use a central difference with increment $\\Delta\\lambda = 10^{-5}$ and fully re-converge the self-consistent solution at $\\lambda_Q + \\Delta \\lambda$ and $\\lambda_Q - \\Delta \\lambda$ to evaluate $\\mathcal{R}(\\lambda_Q \\pm \\Delta \\lambda)$.\n\nPhysical and numerical units: Treat all energies in arbitrary energy units and the quadrupole moment as dimensionless. Angles do not appear. Express numerical outputs as real numbers rounded to $6$ decimals, and express the boolean as an integer ($1$ for true, $0$ for false).\n\nTest suite: Run your solver for the following Lagrange multiplier values:\n- Case $1$: $\\lambda_Q = -0.8$,\n- Case $2$: $\\lambda_Q = -0.2$,\n- Case $3$: $\\lambda_Q = 0.0$,\n- Case $4$: $\\lambda_Q = 0.6$.\n\nFinal output format: Your program should produce a single line of output containing the results for all cases as a comma-separated list enclosed in square brackets. Each case should itself be a sub-list of the form\n$$\n\\left[\\langle \\hat{Q}_{20} \\rangle,\\; \\epsilon_1, \\epsilon_2, \\epsilon_3,\\; b\\right],\n$$\nwhere $\\epsilon_1, \\epsilon_2, \\epsilon_3$ are the $N$ lowest self-consistent single-particle energies and $b \\in \\{0,1\\}$ is the boolean flag defined above. The overall output should thus look like\n$$\n\\big[\\,[\\cdots],\\,[\\cdots],\\,[\\cdots],\\,[\\cdots]\\,\\big],\n$$\nwith each real number rounded to $6$ decimals and no units printed.", "solution": "The problem requires the derivation of the constrained Hartree-Fock equations for a schematic model and their numerical solution. The problem is well-posed, scientifically sound, and contains all necessary information.\n\n### Task A: Derivation from First Principles\n\nThe objective is to find the set of $N$ orthonormal single-particle orbitals $|\\phi_k\\rangle$, $k=1, \\dots, N$, that minimize the expectation value of the total energy of the system, subject to a constraint on the average quadrupole moment. The total many-body Hamiltonian is $\\hat{H} = \\hat{h}_0 + \\hat{V}$, where $\\hat{h}_0$ is the one-body part and $\\hat{V} = -\\frac{\\kappa}{2} \\hat{Q}_{20} \\hat{Q}_{20}$ is the separable two-body interaction. The many-body state $|\\Psi\\rangle$ is a Slater determinant constructed from the orbitals $|\\phi_k\\rangle$.\n\nWithin the Hartree-Fock (or simply Hartree, for this interaction) approximation, the expectation value of the separable interaction is given by $E_V = \\langle \\hat{V} \\rangle \\approx -\\frac{\\kappa}{2} \\langle \\hat{Q}_{20} \\rangle^2$. Here, $\\langle \\hat{Q}_{20} \\rangle$ is the expectation value of the quadrupole operator in the many-body state $|\\Psi\\rangle$, which for a Slater determinant is the sum of single-particle expectation values over occupied orbitals:\n$$\n\\langle \\hat{Q}_{20} \\rangle = \\langle \\Psi | \\hat{Q}_{20} | \\Psi \\rangle = \\sum_{k=1}^N \\langle \\phi_k | \\hat{Q}_{20} | \\phi_k \\rangle = \\mathrm{Tr}(\\rho \\hat{Q}_{20})\n$$\nwhere $\\rho = \\sum_{k=1}^N |\\phi_k\\rangle\\langle\\phi_k|$ is the one-body density matrix.\n\nThe total energy functional to be minimized is thus:\n$$\nE_{\\mathrm{HF}}[\\{\\phi_k\\}] = \\langle \\hat{h}_0 \\rangle - \\frac{\\kappa}{2} \\langle \\hat{Q}_{20} \\rangle^2 = \\sum_{k=1}^N \\langle \\phi_k | \\hat{h}_0 | \\phi_k \\rangle - \\frac{\\kappa}{2} \\left( \\sum_{k=1}^N \\langle \\phi_k | \\hat{Q}_{20} | \\phi_k \\rangle \\right)^2\n$$\n\nWe use the Ritz variational principle with constraints. We want to find a stationary point of the energy functional $E_{\\mathrm{HF}}$ subject to a constraint on the quadrupole moment. This is achieved by finding a stationary point of a modified functional (a Routhian), where the constraint is incorporated via a Lagrange multiplier $\\lambda_Q$. The functional to be made stationary is:\n$$\n\\mathcal{F}[\\{\\phi_k\\}] = E_{\\mathrm{HF}}[\\{\\phi_k\\}] + \\lambda_Q \\langle \\hat{Q}_{20} \\rangle\n$$\nThis form corresponds to finding a state that minimizes the Routhian operator $\\hat{R} = \\hat{H} + \\lambda_Q \\hat{Q}_{20}$ in the mean-field approximation. The sign convention for $\\lambda_Q$ is consistent with the problem's definition of the numerical Routhian $\\mathcal{R}$.\n\nTo enforce the orthonormality of the orbitals, $\\langle \\phi_i | \\phi_j \\rangle = \\delta_{ij}$, we introduce a matrix of Lagrange multipliers $\\epsilon_{ij}$ and form the full Lagrangian:\n$$\n\\mathcal{L}[\\{\\phi_k\\}] = \\mathcal{F}[\\{\\phi_k\\}] - \\sum_{i,j=1}^N \\epsilon_{ij} (\\langle \\phi_i | \\phi_j \\rangle - \\delta_{ij})\n$$\nSubstituting the expressions for $E_{\\mathrm{HF}}$ and $\\langle \\hat{Q}_{20} \\rangle$:\n$$\n\\mathcal{L} = \\sum_{k=1}^N \\langle \\phi_k | \\hat{h}_0 | \\phi_k \\rangle - \\frac{\\kappa}{2} \\left( \\sum_{i=1}^N \\langle \\phi_i | \\hat{Q}_{20} | \\phi_i \\rangle \\right)^2 + \\lambda_Q \\sum_{k=1}^N \\langle \\phi_k | \\hat{Q}_{20} | \\phi_k \\rangle - \\sum_{i,j=1}^N \\epsilon_{ij} (\\langle \\phi_i | \\phi_j \\rangle - \\delta_{ij})\n$$\nTo find the optimal orbitals, we require the functional derivative of $\\mathcal{L}$ with respect to each $\\langle\\phi_k|$ to be zero. For a specific orbital $\\langle\\phi_j|$:\n$$\n\\frac{\\delta \\mathcal{L}}{\\delta \\langle \\phi_j|} = \\hat{h}_0 |\\phi_j\\rangle - \\frac{\\kappa}{2} \\cdot 2 \\left( \\sum_{i=1}^N \\langle \\phi_i | \\hat{Q}_{20} | \\phi_i \\rangle \\right) \\hat{Q}_{20}|\\phi_j\\rangle + \\lambda_Q \\hat{Q}_{20}|\\phi_j\\rangle - \\sum_{i=1}^N \\epsilon_{ji}|\\phi_i\\rangle = 0\n$$\nRecognizing that $\\langle \\hat{Q}_{20} \\rangle = \\sum_i \\langle \\phi_i | \\hat{Q}_{20} | \\phi_i \\rangle$, this simplifies to:\n$$\n\\left( \\hat{h}_0 - \\kappa \\langle \\hat{Q}_{20} \\rangle \\hat{Q}_{20} + \\lambda_Q \\hat{Q}_{20} \\right) |\\phi_j\\rangle = \\sum_{i=1}^N \\epsilon_{ji} |\\phi_i\\rangle\n$$\nThe equation holds for each occupied orbital $j=1,\\dots,N$. The operator on the left is the effective single-particle Hamiltonian, which we call $\\hat{h}_{\\mathrm{eff}}$:\n$$\n\\hat{h}_{\\mathrm{eff}} = \\hat{h}_0 - \\kappa \\langle \\hat{Q}_{20} \\rangle \\hat{Q}_{20} + \\lambda_Q \\hat{Q}_{20}\n$$\nThe matrix of Lagrange multipliers $\\epsilon_{ji}$ is Hermitian. We can always find a unitary transformation among the occupied orbitals $|\\phi_k\\rangle$ that diagonalizes this matrix, leading to a set of \"canonical\" orbitals $|\\psi_k\\rangle$ that satisfy the eigenvalue equations:\n$$\n\\hat{h}_{\\mathrm{eff}} |\\psi_k\\rangle = \\epsilon_k |\\psi_k\\rangle\n$$\nwhere $\\epsilon_k$ are the real eigenvalues, identified as the single-particle energies. The ground state of the system is then formed by occupying the $N$ single-particle orbitals corresponding to the $N$ lowest eigenvalues of $\\hat{h}_{\\mathrm{eff}}$.\n\nThe explicit identifications are as follows:\n1.  **Structure of the mean-field contribution:** The term $-\\kappa \\langle \\hat{Q}_{20} \\rangle \\hat{Q}_{20}$ is the one-body potential generated by the separable two-body interaction. It depends on the quadrupole moment of the state itself, making the problem non-linear.\n2.  **Modification by the quadrupole constraint:** The term $+\\lambda_Q \\hat{Q}_{20}$ is added to the Hamiltonian due to the constraint. This term acts as an external field that drives the system towards a specific deformation. A positive $\\lambda_Q$ penalizes states with positive $\\langle \\hat{Q}_{20} \\rangle$, thus favoring negative values, and vice-versa, to minimize the functional $\\mathcal{F}$.\n3.  **Self-consistency condition:** The effective Hamiltonian $\\hat{h}_{\\mathrm{eff}}$ depends on $\\langle \\hat{Q}_{20} \\rangle$. However, $\\langle \\hat{Q}_{20} \\rangle$ is calculated using the orbitals that are solutions to the eigenvalue problem involving $\\hat{h}_{\\mathrm{eff}}$ itself: $\\langle \\hat{Q}_{20} \\rangle = \\sum_{k=1}^N \\langle \\psi_k | \\hat{Q}_{20} | \\psi_k \\rangle$. This interdependence forms a self-consistency loop that must be solved iteratively.\n\n### Task B: Computational Self-Consistency\n\nThe derivation in Task A provides the basis for the numerical solver. The self-consistent procedure involves iteratively constructing and diagonalizing the effective Hamiltonian $\\hat{h}_{\\mathrm{eff}}$ until the input and output quadrupole moments converge.\n\nThe algorithm is structured as follows:\n1.  **Initialization**: Define the basis dimension $M=6$, particle number $N=3$, constants $\\kappa, \\tau$, and the matrix representations of $\\hat{h}_0$ and $\\hat{Q}_{20}$. The initial density matrix $\\rho$ is constructed by occupying the $N=3$ lowest-energy eigenstates of $\\hat{h}_0$. Since $\\hat{h}_0$ is diagonal, this corresponds to a diagonal $\\rho$ with $1$s for the first $N$ entries. From this, an initial guess for the quadrupole moment, $\\langle Q \\rangle_{\\text{in}} = \\mathrm{Tr}(\\rho Q)$, is computed.\n2.  **Iteration**: A loop runs until convergence or for a maximum of $10^4$ iterations. In each step:\n    a. The effective Hamiltonian matrix $h_{\\mathrm{eff}} = h_0 - \\kappa \\langle Q \\rangle_{\\text{in}} Q + \\lambda_Q Q$ is constructed.\n    b. $h_{\\mathrm{eff}}$ is diagonalized to find its eigenvalues (single-particle energies) and eigenvectors (single-particle orbitals).\n    c. A new density matrix is formed from the $N$ eigenvectors corresponding to the $N$ lowest eigenvalues.\n    d. A new output quadrupole moment, $\\langle Q \\rangle_{\\text{out}} = \\mathrm{Tr}(\\rho_{\\text{new}} Q)$, is calculated.\n    e. Convergence is checked by comparing the input and output moments: $|\\langle Q \\rangle_{\\text{out}} - \\langle Q \\rangle_{\\text{in}}| < \\tau$.\n    f. If not converged, the input for the next iteration is updated using simple linear mixing: $\\langle Q \\rangle_{\\text{in}} \\leftarrow (1-\\alpha)\\langle Q \\rangle_{\\text{in}} + \\alpha \\langle Q \\rangle_{\\text{out}}$, where $\\alpha$ is a mixing parameter (e.g., $0.5$) to stabilize convergence.\n3.  **Post-Processing**: Upon convergence, the required quantities are calculated:\n    a. The converged quadrupole moment $\\langle \\hat{Q}_{20} \\rangle$.\n    b. The lowest $N$ single-particle energies (eigenvalues of the final $h_{\\mathrm{eff}}$).\n    c. The HF energy $E_{\\mathrm{HF}} = \\mathrm{Tr}(\\rho_{\\text{conv}} h_0) - \\frac{\\kappa}{2} \\langle \\hat{Q}_{20} \\rangle^2$.\n    d. The Routhian $\\mathcal{R}(\\lambda_Q) = E_{\\mathrm{HF}} + \\lambda_Q \\langle \\hat{Q}_{20} \\rangle$.\n4.  **Numerical Verification**: To check the relation $\\frac{d\\mathcal{R}}{d\\lambda_Q} \\approx \\langle \\hat{Q}_{20} \\rangle$, the entire self-consistent calculation is repeated for $\\lambda_Q \\pm \\Delta\\lambda$. The Routhians at these points, $\\mathcal{R}(\\lambda_Q \\pm \\Delta\\lambda)$, are used to compute a central-difference approximation of the derivative. This numerical derivative is then compared to the converged $\\langle \\hat{Q}_{20} \\rangle$ at the central point $\\lambda_Q$.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the constrained Hartree-Fock problem for a schematic model.\n    \"\"\"\n    # --- Problem Data ---\n    M = 6\n    N = 3\n    kappa = 0.25\n\n    h0 = np.diag([0.0, 0.9, 1.7, 2.8, 4.2, 6.0])\n    Q = np.array([\n        [-2.0, 0.20, 0.05, 0.0, 0.0, 0.0],\n        [0.20, -0.8, 0.20, 0.05, 0.0, 0.0],\n        [0.05, 0.20, 0.3, 0.20, 0.05, 0.0],\n        [0.0, 0.05, 0.20, 0.9, 0.20, 0.05],\n        [0.0, 0.0, 0.05, 0.20, 1.6, 0.20],\n        [0.0, 0.0, 0.0, 0.05, 0.20, 2.2]\n    ])\n\n    test_cases = [-0.8, -0.2, 0.0, 0.6]\n\n    # --- Solver Parameters ---\n    max_iterations = 10000\n    convergence_tau = 1.0e-10\n    mixing_alpha = 0.5\n    \n    # --- Derivative Check Parameters ---\n    delta_lambda = 1.0e-5\n    delta_check = 5.0e-5\n\n    def run_scf(lambda_q):\n        \"\"\"\n        Performs the self-consistent field iteration for a given lambda_q.\n        \"\"\"\n        # Initialization\n        rho_initial = np.zeros((M, M))\n        for i in range(N):\n            rho_initial[i, i] = 1.0\n        \n        q_in = np.trace(rho_initial @ Q)\n\n        for i in range(max_iterations):\n            h_eff = h0 - kappa * q_in * Q + lambda_q * Q\n            \n            eigenvalues, eigenvectors = np.linalg.eigh(h_eff)\n            \n            # Form new density matrix from lowest N states\n            occupied_vectors = eigenvectors[:, :N]\n            rho_new = occupied_vectors @ occupied_vectors.T\n            \n            q_out = np.trace(rho_new @ Q)\n            \n            if abs(q_out - q_in)  convergence_tau:\n                # Converged, return final quantities\n                final_q = q_out\n                final_rho = rho_new\n                final_s_p_energies = eigenvalues[:N]\n                return final_q, final_rho, final_s_p_energies\n\n            # Mix for next iteration\n            q_in = (1 - mixing_alpha) * q_in + mixing_alpha * q_out\n\n        # If loop finishes without convergence\n        raise RuntimeError(f\"SCF failed to converge for lambda_q = {lambda_q}\")\n\n    def calculate_routhian(lambda_q):\n        \"\"\"\n        Runs SCF and calculates the Routhian for a given lambda_q.\n        \"\"\"\n        q_conv, rho_conv, _ = run_scf(lambda_q)\n        \n        # Calculate HF energy\n        e_hf = np.trace(rho_conv @ h0) - (kappa / 2.0) * q_conv**2\n        \n        # Calculate Routhian\n        routhian = e_hf + lambda_q * q_conv\n        return routhian\n\n    results = []\n    for lambda_q_val in test_cases:\n        # Main calculation for the central lambda_q\n        q_converged, _, sp_energies = run_scf(lambda_q_val)\n\n        # Numerical derivative check\n        r_plus = calculate_routhian(lambda_q_val + delta_lambda)\n        r_minus = calculate_routhian(lambda_q_val - delta_lambda)\n        \n        dR_dlambda = (r_plus - r_minus) / (2.0 * delta_lambda)\n        \n        is_derivative_ok = 1 if abs(dR_dlambda - q_converged)  delta_check else 0\n        \n        # Format results\n        case_result = [\n            round(q_converged, 6),\n            round(sp_energies[0], 6),\n            round(sp_energies[1], 6),\n            round(sp_energies[2], 6),\n            is_derivative_ok\n        ]\n        results.append(case_result)\n\n    # Final output formatting\n    output_str = \"[\" + \",\".join([str(r) for r in results]) + \"]\"\n    output_str = output_str.replace(\"'\", \"\") # Clean up string representation of lists\n    print(output_str)\n\nsolve()\n```", "id": "3555808"}, {"introduction": "In our previous exercises, we derived the Hartree-Fock potentials by manually applying the rules of variational calculus. While fundamental, this process can become exceedingly complex and prone to error for the sophisticated energy density functionals (EDFs) used in modern nuclear physics. This final practice [@problem_id:3555825] introduces a powerful and general computational alternative: automatic differentiation (AD). You will first derive a discrete gradient from first principles using summation by parts, and then build a simple reverse-mode AD engine to compute the same result, revealing how the functional derivative $h[\\rho] = \\delta E / \\delta \\rho$ can be obtained numerically for any valid EDF, thereby automating a crucial step in the theoretical development.", "problem": "You are asked to derive, discretize, and automatically differentiate the single-particle field for a one-dimensional periodic system in the context of Energy Density Functional (EDF) theory used in nuclear Hartree-Fock. The goal is to construct a computational scheme that, given a discretized density field, returns the discrete gradient of the total energy with respect to the discrete density, which represents the discrete analog of the functional derivative $h[\\rho] = \\delta E / \\delta \\rho$. Your derivation and implementation must be based on first principles of variational calculus and on a discrete representation suitable for computation.\n\nDefinitions and setup:\n- Consider a one-dimensional ring (periodic domain) represented by $N$ grid points with uniform lattice spacing $\\Delta x$. Let the discrete density be the vector $\\boldsymbol{\\rho} = (\\rho_0,\\rho_1,\\dots,\\rho_{N-1})$, which approximates the continuous density $\\rho(x)$ at grid points $x_i = i \\Delta x$. Periodic boundary conditions enforce $\\rho_{i+N} = \\rho_i$.\n- Consider energy functionals of the general EDF form $E[\\rho,\\tau,\\mathbf{J},\\nabla \\rho,\\dots]$ but restrict to a discrete prototype that uses only $\\rho$ and $\\nabla \\rho$, namely an energy functional that is a Riemann-sum discretization of a sum of a local term and a gradient-squared term:\n$$\nE_D[\\boldsymbol{\\rho}] = \\sum_{i=0}^{N-1} \\Delta x\\,\\Big( a\\,\\rho_i^2 + b\\,\\rho_i^3 \\Big) \\;+\\; \\sum_{i=0}^{N-1} \\Delta x\\, c\\, \\big( D \\rho \\big)_i^2,\n$$\nwhere $(D \\rho)_i$ is the discrete central difference approximation to $\\partial_x \\rho$ with periodic boundary conditions:\n$$\n(D \\rho)_i \\equiv \\frac{\\rho_{i+1} - \\rho_{i-1}}{2\\,\\Delta x}.\n$$\nHere $a$, $b$, and $c$ are constants.\n\nTasks:\n- From the definition of the functional derivative and the principle of stationary action, derive the discrete gradient $\\partial E_D/\\partial \\rho_i$ using first principles for the above $E_D[\\boldsymbol{\\rho}]$. That is, compute the discrete variational derivative for the local term and for the gradient-squared term under periodic boundary conditions, starting from the definition of a variation $\\delta \\rho_i$ and discrete summation by parts. Do not assume any “shortcut” formulas; derive the discrete Euler–Lagrange expressions.\n- Design and implement a reverse-mode automatic differentiation scheme specialized to scalar functionals of many variables. Your scheme must:\n  - Represent each scalar variable as a node carrying a value and an adjoint (gradient accumulator).\n  - Track a computational graph of primitive operations (addition, subtraction, multiplication, scalar power) and a summation reduction.\n  - Support a linear periodic central-difference operator $D$ acting elementwise on vectors of variables.\n  - On calling a backward pass from the scalar energy $E_D$, propagate adjoints back to the input $\\rho_i$ to produce the gradient vector $g_i = \\partial E_D / \\partial \\rho_i$.\n- Validate your automatic differentiation gradient against analytic discrete gradients that you must derive for each toy functional specified in the test suite below. Your validation metric for each test case is the maximum absolute error\n$$\n\\varepsilon_{\\max} = \\max_{i} \\left| g^{(\\mathrm{AD})}_i - g^{(\\mathrm{analytic})}_i \\right|.\n$$\n\nTest suite:\nProvide a program that computes the automatic differentiation gradient and the derived analytic discrete gradient for each of the following three test cases, and then outputs the three values of $\\varepsilon_{\\max}$ in a single line as specified below.\n\n- Test A (local-only functional):\n  - $N = 8$, $\\Delta x = 0.5$, $a = 1.1$, $b = -0.7$, $c = 0$.\n  - Density: $\\rho_i$ is a linearly spaced profile from $0.05$ to $0.40$ inclusive across the $N$ points.\n- Test B (gradient-only functional; constant density edge case):\n  - $N = 10$, $\\Delta x = 0.3$, $a = 0$, $b = 0$, $c = 0.6$.\n  - Density: $\\rho_i = 0.2$ for all $i$.\n- Test C (combined functional; periodic nontrivial mode):\n  - $N = 12$, $\\Delta x = 0.2$, $a = 0.8$, $b = 0.3$, $c = 0.4$.\n  - Density: $\\rho_i = \\sin\\!\\big( 2\\pi i / N \\big) + 0.5 \\cos\\!\\big( 4\\pi i / N \\big)$ for $i = 0,1,\\dots,N-1$.\n\nOutput specification:\n- Your program must compute the three $\\varepsilon_{\\max}$ values for Tests A, B, and C in that order, each as a floating-point number in scientific notation with exactly $12$ significant digits.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example:\n\"[1.234567890123e-12,2.345678901235e-13,3.456789012346e-12]\".\n- No physical units are required for this problem, and angles, where present, must be interpreted in radians.\n\nConstraints:\n- Your derivations must start from the definition of the functional derivative and discrete summation by parts under periodic boundary conditions, not from any pre-memorized formula.\n- The automatic differentiation scheme must be coded by you and must not rely on any external automatic differentiation library.\n- The runtime environment is restricted to Python with basic numerical libraries; see the final answer specification for exact constraints.\n\nYour program should implement the above and print only the specified single-line output.", "solution": "The problem is to derive, discretize, and implement an automatic differentiation (AD) scheme for the single-particle field, $h[\\rho] = \\delta E / \\delta \\rho$, in a one-dimensional periodic system described by a simple Energy Density Functional (EDF). We must first derive the analytical form of the discrete gradient and then develop a custom reverse-mode AD framework to compute the same gradient numerically. Finally, we validate the AD result against the analytical one.\n\n### Derivation of the Analytic Discrete Gradient\n\nThe goal is to compute the discrete functional derivative, or gradient, $g_j = \\partial E_D / \\partial \\rho_j$ for the given discrete energy functional $E_D[\\boldsymbol{\\rho}]$. The gradient is defined through the first-order variation of the energy, $\\delta E_D$, with respect to a small, arbitrary perturbation of the density, $\\delta \\boldsymbol{\\rho} = (\\delta \\rho_0, \\delta \\rho_1, \\dots, \\delta \\rho_{N-1})$:\n$$ \\delta E_D = \\sum_{j=0}^{N-1} \\frac{\\partial E_D}{\\partial \\rho_j} \\delta \\rho_j $$\nThe provided energy functional is a sum of a local term, $E_{\\text{loc}}$, and a gradient term, $E_{\\text{grad}}$:\n$$ E_D[\\boldsymbol{\\rho}] = E_{\\text{loc}}[\\boldsymbol{\\rho}] + E_{\\text{grad}}[\\boldsymbol{\\rho}] $$\nwhere\n$$ E_{\\text{loc}}[\\boldsymbol{\\rho}] = \\sum_{i=0}^{N-1} \\Delta x\\,\\Big( a\\,\\rho_i^2 + b\\,\\rho_i^3 \\Big) $$\n$$ E_{\\text{grad}}[\\boldsymbol{\\rho}] = \\sum_{i=0}^{N-1} \\Delta x\\, c\\, \\big( D \\rho \\big)_i^2 $$\nBy linearity of the derivative, we can compute the gradient of each part separately.\n\n**1. Gradient of the Local Term, $E_{\\text{loc}}$**\n\nThe local term $E_{\\text{loc}}$ is a sum where each term depends only on a single $\\rho_i$. The derivative with respect to a specific $\\rho_j$ is non-zero only for the term where $i=j$ in the summation.\n$$\n\\frac{\\partial E_{\\text{loc}}}{\\partial \\rho_j} = \\frac{\\partial}{\\partial \\rho_j} \\left[ \\sum_{i=0}^{N-1} \\Delta x\\,\\Big( a\\,\\rho_i^2 + b\\,\\rho_i^3 \\Big) \\right] = \\Delta x \\, \\frac{d}{d\\rho_j} \\Big( a\\,\\rho_j^2 + b\\,\\rho_j^3 \\Big)\n$$\n$$\n\\frac{\\partial E_{\\text{loc}}}{\\partial \\rho_j} = \\Delta x \\, \\Big( 2a\\,\\rho_j + 3b\\,\\rho_j^2 \\Big)\n$$\n\n**2. Gradient of the Gradient Term, $E_{\\text{grad}}$**\n\nThe gradient term involves nearest-neighbor couplings through the discrete derivative operator $(D\\rho)_i$. We will use the principle of discrete summation by parts, starting from the variation $\\delta E_{\\text{grad}}$.\n$$\nE_{\\text{grad}} = \\sum_{i=0}^{N-1} \\Delta x\\, c\\, \\left( \\frac{\\rho_{i+1} - \\rho_{i-1}}{2\\,\\Delta x} \\right)^2 = \\frac{c}{4\\,\\Delta x} \\sum_{i=0}^{N-1} (\\rho_{i+1} - \\rho_{i-1})^2\n$$\nThe first-order variation is:\n$$\n\\delta E_{\\text{grad}} = \\frac{c}{4\\,\\Delta x} \\sum_{i=0}^{N-1} 2\\,(\\rho_{i+1} - \\rho_{i-1}) \\, \\delta(\\rho_{i+1} - \\rho_{i-1}) = \\frac{c}{2\\,\\Delta x} \\sum_{i=0}^{N-1} (\\rho_{i+1} - \\rho_{i-1}) (\\delta\\rho_{i+1} - \\delta\\rho_{i-1})\n$$\nWe expand the product and split the summation:\n$$\n\\delta E_{\\text{grad}} = \\frac{c}{2\\,\\Delta x} \\left[ \\sum_{i=0}^{N-1} (\\rho_{i+1} - \\rho_{i-1}) \\delta\\rho_{i+1} - \\sum_{i=0}^{N-1} (\\rho_{i+1} - \\rho_{i-1}) \\delta\\rho_{i-1} \\right]\n$$\nTo isolate the coefficient of a generic $\\delta\\rho_j$, we perform a discrete summation by parts by re-indexing the summations. The indices are considered modulo $N$ due to periodic boundary conditions.\n\nFor the first sum, let $j = i+1$. This implies $i = j-1$. As $i$ runs from $0$ to $N-1$, $j$ runs from $1$ to $N$, which is equivalent to $0$ to $N-1$ under periodicity.\n$$\n\\sum_{i=0}^{N-1} (\\rho_{i+1} - \\rho_{i-1}) \\delta\\rho_{i+1} = \\sum_{j=0}^{N-1} (\\rho_{j} - \\rho_{j-2}) \\delta\\rho_{j}\n$$\nFor the second sum, let $j = i-1$. This implies $i = j+1$. As $i$ runs from $0$ to $N-1$, $j$ runs from $-1$ to $N-2$, which is also equivalent to $0$ to $N-1$ under periodicity.\n$$\n\\sum_{i=0}^{N-1} (\\rho_{i+1} - \\rho_{i-1}) \\delta\\rho_{i-1} = \\sum_{j=0}^{N-1} (\\rho_{j+2} - \\rho_{j}) \\delta\\rho_{j}\n$$\nSubstituting these re-indexed sums back into the expression for $\\delta E_{\\text{grad}}$:\n$$\n\\delta E_{\\text{grad}} = \\frac{c}{2\\,\\Delta x} \\sum_{j=0}^{N-1} \\left[ (\\rho_{j} - \\rho_{j-2}) - (\\rho_{j+2} - \\rho_{j}) \\right] \\delta\\rho_{j}\n$$\n$$\n\\delta E_{\\text{grad}} = \\sum_{j=0}^{N-1} \\left[ \\frac{c}{2\\,\\Delta x} (2\\rho_j - \\rho_{j+2} - \\rho_{j-2}) \\right] \\delta\\rho_j\n$$\nBy comparing this with the definition $\\delta E_{\\text{grad}} = \\sum_j (\\partial E_{\\text{grad}}/\\partial \\rho_j) \\delta\\rho_j$, we identify the gradient:\n$$\n\\frac{\\partial E_{\\text{grad}}}{\\partial \\rho_j} = \\frac{c}{2\\,\\Delta x} (2\\rho_j - \\rho_{j+2} - \\rho_{j-2})\n$$\nThis can be written in terms of a five-point stencil for a second derivative operator on a staggered grid:\n$$\n\\frac{\\partial E_{\\text{grad}}}{\\partial \\rho_j} = - \\frac{c}{2\\,\\Delta x} (\\rho_{j+2} - 2\\rho_j + \\rho_{j-2})\n$$\n\n**3. Total Analytic Gradient**\n\nCombining the contributions from the local and gradient terms, the total discrete gradient is:\n$$\ng_j^{(\\text{analytic})} = \\frac{\\partial E_D}{\\partial \\rho_j} = \\Delta x \\, \\Big( 2a\\,\\rho_j + 3b\\,\\rho_j^2 \\Big) - \\frac{c}{2\\,\\Delta x} (\\rho_{j+2} - 2\\rho_j + \\rho_{j-2})\n$$\nThe indices $j+2$ and $j-2$ are evaluated with periodic boundary conditions, i.e., modulo $N$.\n\n### Automatic Differentiation Scheme\n\nWe implement a reverse-mode automatic differentiation (AD) scheme. This involves two main phases: a forward pass to build a computational graph and compute the final scalar value, and a backward pass to propagate gradients from the output back to the inputs.\n\n**1. Computational Graph**\n\nEach scalar variable in the computation is represented by a `Node` object. A `Node` stores:\n- `value`: The scalar result of an operation.\n- `grad`: The adjoint, or gradient, $\\partial E_D / \\partial(\\text{value})$, initialized to $0.0$.\n- `_prev`: A set of `Node` objects that were inputs (children) to the operation that created this `Node`.\n- `_backward`: A function that implements the chain rule for the operation, propagating the `Node`'s own gradient to its children's gradients.\n\nStandard arithmetic operators (`+`, `*`, `**`, etc.) are overloaded for the `Node` class. When an operation like `c = a + b` is performed on `Node` objects, a new `Node` `c` is created. Its `value` is computed, its children `_prev` are set to `{a, b}`, and its `_backward` function is defined to execute `a.grad += c.grad` and `b.grad += c.grad`. This process dynamically constructs a directed acyclic graph (DAG) representing the computation from the input densities $\\rho_i$ to the final energy $E_D$.\n\n**2. Composite Operators**\n\nThe summation and the discrete derivative `D` are handled as composite operations on vectors of `Node`s.\n- `sum_nodes(nodes)`: Takes a list of `Node`s, computes their sum, and returns a single output `Node`. Its backward pass adds the output `Node`'s gradient to the gradient of each input `Node`.\n- `D_op(rho_nodes, delta_x)`: Takes a list of `Node`s representing $\\boldsymbol{\\rho}$ and returns a list of `Node`s for $(D\\boldsymbol{\\rho})$. Each output node $(D\\boldsymbol{\\rho})_i$ is constructed using the overloaded operators: `(rho_nodes[i+1] - rho_nodes[i-1]) / (2 * delta_x)`. The graph structure for this linear transformation is thus built automatically.\n\n**3. Backward Pass**\n\nThe backward pass computes the gradients $\\partial E_D / \\partial \\rho_i$ and is triggered by a function call `backward(E_D_node)`.\n1.  **Topological Sort**: The function first performs a topological sort of the computational graph starting from the final energy `Node`, $E_D$. This produces an ordered list of all `Node`s that contributed to the final result.\n2.  **Gradient Propagation**: The gradients of all nodes in the sorted list are reset to $0.0$. The gradient of the final `Node`, $E_D$, is seeded with $1.0$ (since $\\partial E_D / \\partial E_D = 1$). The algorithm then iterates through the topologically sorted list in reverse order, calling the `_backward` function for each `Node`. This ensures that when a `Node`'s gradient is propagated to its children, the `Node`'s own gradient has been fully accumulated from all its parents in the graph.\n3.  **Result**: After the pass is complete, the `grad` attribute of each initial input `Node`, $\\rho_i$, contains the desired gradient, $g_i^{(\\text{AD})} = \\partial E_D / \\partial \\rho_i$.\n\nThis custom-built AD machinery is then used to compute the gradient for the test cases, and the results are compared to the analytic formula to verify correctness.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# A custom, minimalist reverse-mode automatic differentiation engine.\n\nclass Node:\n    \"\"\"\n    A Node in the computational graph. It holds a scalar value, its gradient\n    (adjoint), and the logic to backpropagate gradients to its children.\n    \"\"\"\n    def __init__(self, value, _children=(), _op=''):\n        self.value = float(value)\n        self.grad = 0.0\n        # _prev holds the nodes that this node was computed from.\n        self._prev = set(_children)\n        # _backward is a function to propagate this node's grad to its children.\n        self._backward = lambda: None\n        self._op = _op\n\n    def __repr__(self):\n        return f\"Node(value={self.value:.4f}, grad={self.grad:.4f})\"\n\n    def __add__(self, other):\n        other = other if isinstance(other, Node) else Node(other)\n        out = Node(self.value + other.value, _children=(self, other), _op='+')\n        def _backward():\n            self.grad += 1.0 * out.grad\n            other.grad += 1.0 * out.grad\n        out._backward = _backward\n        return out\n\n    def __mul__(self, other):\n        other = other if isinstance(other, Node) else Node(other)\n        out = Node(self.value * other.value, _children=(self, other), _op='*')\n        def _backward():\n            self.grad += other.value * out.grad\n            other.grad += self.value * out.grad\n        out._backward = _backward\n        return out\n\n    def __pow__(self, n):\n        assert isinstance(n, (int, float)), \"Power must be a scalar number.\"\n        out = Node(self.value ** n, _children=(self,), _op=f'**{n}')\n        def _backward():\n            selfif_val_is_zero = abs(self.value)  1e-9 and n-1  0\n            grad_val = (n * self.value**(n-1)) if not selfif_val_is_zero else 0.0\n            self.grad += grad_val * out.grad\n        out._backward = _backward\n        return out\n\n    def __neg__(self):\n        return self * -1\n\n    def __sub__(self, other):\n        return self + (-other)\n    \n    def __rsub__(self, other):\n        other = other if isinstance(other, Node) else Node(other)\n        return other - self\n\n    __radd__ = __add__\n    __rmul__ = __mul__\n\n\ndef backward(final_node: Node):\n    \"\"\"\n    Performs the backward pass to compute gradients for all nodes\n    in the graph culminating in `final_node`.\n    \"\"\"\n    # 1. Perform topological sort of the graph.\n    topo = []\n    visited = set()\n    def build_topo(v):\n        if v not in visited:\n            visited.add(v)\n            for child in v._prev:\n                build_topo(child)\n            topo.append(v)\n    \n    build_topo(final_node)\n\n    # 2. Reset gradients and initialize the final node's gradient.\n    for n in topo:\n        n.grad = 0.0\n    final_node.grad = 1.0\n\n    # 3. Propagate gradients in reverse topological order.\n    for v in reversed(topo):\n        v._backward()\n\n# --- Helper functions for AD ---\n\ndef sum_nodes(nodes):\n    \"\"\"Creates a Node representing the sum of a list of Nodes.\"\"\"\n    if not nodes:\n        return Node(0.0)\n    total_val = sum(n.value for n in nodes)\n    out = Node(total_val, _children=tuple(nodes), _op='sum')\n    def _backward():\n        for n in nodes:\n            n.grad += out.grad\n    out._backward = _backward\n    return out\n\ndef D_op(rho_nodes, delta_x):\n    \"\"\"Applies the periodic central difference operator D to a list of Nodes.\"\"\"\n    N = len(rho_nodes)\n    d_rho_nodes = []\n    const = 1.0 / (2.0 * delta_x)\n    for i in range(N):\n        rho_p1 = rho_nodes[(i + 1) % N]\n        rho_m1 = rho_nodes[(i - 1 + N) % N]\n        # This reuses overloaded operators, building the graph automatically.\n        d_rho_i = (rho_p1 - rho_m1) * const\n        d_rho_nodes.append(d_rho_i)\n    return d_rho_nodes\n\n\ndef solve():\n    \"\"\"Main function to run test cases and produce the final output.\"\"\"\n    test_cases = [\n        {\n            \"id\": \"A\", \"N\": 8, \"dx\": 0.5, \"a\": 1.1, \"b\": -0.7, \"c\": 0,\n            \"rho_func\": lambda N: np.linspace(0.05, 0.40, N)\n        },\n        {\n            \"id\": \"B\", \"N\": 10, \"dx\": 0.3, \"a\": 0, \"b\": 0, \"c\": 0.6,\n            \"rho_func\": lambda N: np.full(N, 0.2)\n        },\n        {\n            \"id\": \"C\", \"N\": 12, \"dx\": 0.2, \"a\": 0.8, \"b\": 0.3, \"c\": 0.4,\n            \"rho_func\": lambda N: np.sin(2*np.pi*np.arange(N)/N) + 0.5*np.cos(4*np.pi*np.arange(N)/N)\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        N, dx, a, b, c = case['N'], case['dx'], case['a'], case['b'], case['c']\n        rho_vals = case['rho_func'](N)\n\n        # --- 1. Analytic Gradient Calculation ---\n        grad_analytic = np.zeros(N)\n        # Local part\n        grad_loc = dx * (2 * a * rho_vals + 3 * b * rho_vals**2)\n        # Gradient part\n        if c != 0:\n            rho_p2 = np.roll(rho_vals, -2)\n            rho_m2 = np.roll(rho_vals, 2)\n            grad_grad = (c / (2 * dx)) * (2 * rho_vals - rho_p2 - rho_m2)\n        else:\n            grad_grad = np.zeros(N)\n        grad_analytic = grad_loc + grad_grad\n\n        # --- 2. Automatic Differentiation Gradient Calculation ---\n        # Create input nodes\n        rho_nodes = [Node(val) for val in rho_vals]\n        \n        # Build the graph for E_D\n        E_loc = Node(0.0)\n        if a != 0 or b != 0:\n            terms_loc = [dx * (a * r**2 + b * r**3) for r in rho_nodes]\n            E_loc = sum_nodes(terms_loc)\n\n        E_grad = Node(0.0)\n        if c != 0:\n            d_rho = D_op(rho_nodes, dx)\n            terms_grad = [dx * c * (d**2) for d in d_rho]\n            E_grad = sum_nodes(terms_grad)\n            \n        E_total = E_loc + E_grad\n\n        # Perform backpropagation\n        backward(E_total)\n        \n        grad_ad = np.array([node.grad for node in rho_nodes])\n\n        # --- 3. Validation ---\n        max_error = np.max(np.abs(grad_ad - grad_analytic))\n        # Format to 12 digits of precision in scientific notation (1.12d)\n        # Example format: 1.234567890123e-12\n        results.append(f\"{max_error:.12e}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3555825"}]}