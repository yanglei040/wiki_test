{"hands_on_practices": [{"introduction": "Before building complex computational models, it is essential to develop a physical intuition for the energy scales involved in the liquid drop model. This exercise [@problem_id:3568545] provides a direct way to estimate the strength of the nuclear pairing force and compare its magnitude to the dominant surface and Coulomb energies. This back-of-the-envelope calculation helps to appreciate the hierarchy of interactions within the nucleus.", "problem": "A central element of macroscopic mass models based on the liquid drop picture is the semi-empirical mass formula, which decomposes the nuclear binding energy into bulk, surface, Coulomb, asymmetry, and pairing contributions. One manifestation of pairing correlations is the odd-even staggering of nuclear binding energies. For mid-shell nuclei, the empirical neutron or proton pairing gap is often characterized by a baseline scaling $\\,\\Delta \\approx 12/\\sqrt{A}\\,$ in megaelectronvolts, consistent with a broad range of data. In the liquid drop parameterization, the pairing contribution is conventionally written as $\\,\\delta(A,Z) = \\pm a_p A^{-1/2}\\,$, where $\\,a_p\\,$ is a constant pairing coefficient, with the $+$ sign for even-even nuclei, $0$ for odd-$A$, and $-$ for odd-odd nuclei. \n\nStarting from the above baseline and the liquid drop picture, use the odd-even mass staggering concept to estimate the pairing coefficient $\\,a_p\\,$ in the pairing term $\\,\\delta(A,Z)\\,$. Then, for a representative mid-shell nucleus with $\\,A=120\\,$ and $\\,Z=50\\,$, quantify how the typical even-even pairing energy scale compares to the surface and Coulomb contributions by computing the following dimensionless ratio:\n$$\nR \\equiv \\frac{|\\delta_{\\text{even-even}}|}{a_s A^{2/3} + a_c \\frac{Z(Z-1)}{A^{1/3}}}\\,,\n$$\nwhere $\\,a_s\\,$ and $\\,a_c\\,$ are the surface and Coulomb coefficients, respectively. Use the representative values $\\,a_s = 17.23\\,\\text{MeV}\\,$ and $\\,a_c = 0.714\\,\\text{MeV}\\,$ for this estimate. \n\nAssume the mass-number dependence of $\\,A^{\\pm 1/3}\\,$ is sufficiently smooth that $\\,A\\,$ can be treated as constant across the odd-even staggering used to connect $\\,\\Delta\\,$ with $\\,a_p\\,$. Express your final answer as the numerical value of $\\,R\\,$, rounded to four significant figures. The final answer must be dimensionless (no units).", "solution": "The solution proceeds in two parts: first, we estimate the pairing coefficient $a_p$, and second, we compute the ratio $R$.\n\n**Part 1: Estimation of the Pairing Coefficient $a_p$**\n\nThe semi-empirical mass formula includes a pairing term, $\\delta(A,Z)$, to account for the observed odd-even staggering in nuclear binding energies. This term reflects the fact that nuclei with an even number of protons and/or neutrons are more tightly bound than those with odd numbers. The pairing energy, $\\delta(A,Z)$, is given as:\n$$\n\\delta(A,Z) =\n\\begin{cases}\n+a_p A^{-1/2} & \\text{for even-even nuclei} \\\\\n0 & \\text{for odd-}A\\text{ nuclei} \\\\\n-a_p A^{-1/2} & \\text{for odd-odd nuclei}\n\\end{cases}\n$$\nThe empirical pairing gap, $\\Delta$, quantifies the magnitude of this staggering. It represents the energy gained by having a complete pair of nucleons (protons or neutrons) versus having an unpaired nucleon. The problem states that for mid-shell nuclei, this gap is empirically found to be $\\Delta \\approx 12 A^{-1/2}\\,\\text{MeV}$.\n\nThe pairing term for an even-even nucleus, $\\delta_{\\text{even-even}} = +a_p A^{-1/2}$, represents precisely this extra binding energy gained due to the presence of both even protons and even neutrons, relative to the smooth average described by the other terms in the mass formula. Therefore, we can directly equate the magnitude of the pairing energy for an even-even system with the empirical pairing gap $\\Delta$.\n$$\n|\\delta_{\\text{even-even}}| = \\Delta\n$$\nSubstituting the given expressions:\n$$\na_p A^{-1/2} \\approx 12 A^{-1/2}\\,\\text{MeV}\n$$\nFrom this comparison, we can directly estimate the pairing coefficient $a_p$:\n$$\na_p = 12\\,\\text{MeV}\n$$\n\n**Part 2: Calculation of the Ratio $R$**\n\nWe are asked to compute the dimensionless ratio $R$ for a nucleus with mass number $A=120$ and proton number $Z=50$.\n$$\nR = \\frac{|\\delta_{\\text{even-even}}|}{a_s A^{2/3} + a_c \\frac{Z(Z-1)}{A^{1/3}}}\n$$\nThe nucleus has $Z=50$ (even) and the number of neutrons is $N = A - Z = 120 - 50 = 70$ (even). Thus, it is an even-even nucleus.\n\nFirst, we calculate the numerator, which is the magnitude of the pairing energy for this even-even nucleus.\n$$\n|\\delta_{\\text{even-even}}| = |+a_p A^{-1/2}| = a_p A^{-1/2}\n$$\nUsing our estimated $a_p = 12\\,\\text{MeV}$ and the given $A=120$:\n$$\n|\\delta_{\\text{even-even}}| = 12 \\times (120)^{-1/2} = \\frac{12}{\\sqrt{120}}\\,\\text{MeV} \\approx 1.095445\\,\\text{MeV}\n$$\n\nNext, we calculate the denominator, which is the sum of the surface energy ($E_s$) and the Coulomb energy ($E_c$).\nThe surface energy term is:\n$$\nE_s = a_s A^{2/3} = 17.23 \\times (120)^{2/3}\\,\\text{MeV}\n$$\n$$\nE_s \\approx 17.23 \\times 24.328703\\,\\text{MeV} \\approx 419.18453\\,\\text{MeV}\n$$\nThe Coulomb energy term is:\n$$\nE_c = a_c \\frac{Z(Z-1)}{A^{1/3}} = 0.714 \\times \\frac{50(50-1)}{(120)^{1/3}}\\,\\text{MeV}\n$$\n$$\nE_c = 0.714 \\times \\frac{50 \\times 49}{(120)^{1/3}}\\,\\text{MeV} = \\frac{0.714 \\times 2450}{(120)^{1/3}}\\,\\text{MeV}\n$$\n$$\nE_c \\approx \\frac{1749.3}{4.932424}\\,\\text{MeV} \\approx 354.65993\\,\\text{MeV}\n$$\nThe total energy in the denominator is:\n$$\n\\text{Denominator} = E_s + E_c \\approx 419.18453 + 354.65993\\,\\text{MeV} \\approx 773.84446\\,\\text{MeV}\n$$\n\nFinally, we compute the ratio $R$:\n$$\nR = \\frac{1.095445}{773.84446} \\approx 0.00141558\n$$\nThe problem requires the answer to be rounded to four significant figures.\n$$\nR \\approx 0.001416\n$$\nThis result quantifies that for a typical mid-shell heavy nucleus, the pairing energy is a very small correction (about $0.14\\%$) compared to the dominant macroscopic liquid-drop terms like the surface and Coulomb energies.", "answer": "$$\\boxed{0.001416}$$", "id": "3568545"}, {"introduction": "A key task in computational physics is to compare and validate competing theoretical models against data. This practice [@problem_id:3568528] guides you through fitting two variants of the semi-empirical mass formula—one with a simple symmetry term and one with an added surface-symmetry correction—using ordinary least squares. By testing the models' predictions for the two-neutron separation energy, a sensitive differential quantity, you will learn a critical technique for assessing a model's physical realism beyond its ability to fit raw data.", "problem": "You are to implement, fit, and assess two macroscopic nuclear mass models grounded in the liquid drop picture. The goal is to compare a pure volume-symmetry parameterization to a mixed volume-plus-surface symmetry parameterization by fitting the nuclear binding energy and testing residuals of the Two-Neutron Separation Energy (S2n). You must produce a complete, runnable program that performs the specified computations and outputs the required metrics in the exact format described below.\n\nFundamental base and definitions:\n- The nuclear binding energy for a nucleus with mass number $A$, proton number $Z$, and neutron number $N=A-Z$ can be modeled by a macroscopic expansion consistent with the liquid drop picture. This expansion includes leading contributions from volume, surface, Coulomb, symmetry energy, and pairing. Finite-size effects motivate an additional surface-symmetry contribution that modifies the neutron–proton asymmetry energy in finite nuclei.\n- The macroscopic binding energy model can be represented as a linear combination of basis functions $g_j(A,Z)$ with unknown coefficients $c_j$, allowing estimation by ordinary least squares.\n\nModels to be compared:\n- Model $\\mathcal{M}_1$ (pure volume-symmetry): Uses the basis set\n  $$\n  \\{\\, g_1(A,Z)=A,\\; g_2(A,Z)=A^{2/3},\\; g_3(A,Z)=\\frac{Z(Z-1)}{A^{1/3}},\\; g_4(A,Z)=\\frac{(N-Z)^2}{A},\\; g_5(A,Z)=\\frac{s(A,Z)}{A^{1/2}} \\,\\},\n  $$\n  where $s(A,Z)$ is the pairing-sign factor.\n- Model $\\mathcal{M}_2$ (mixed volume-plus-surface symmetry): Extends $\\mathcal{M}_1$ with an additional basis function\n  $$\n  g_6(A,Z)=\\frac{(N-Z)^2}{A^{4/3}},\n  $$\n  which represents a surface-symmetry contribution to the symmetry energy.\n\nDataset and synthetic \"experimental\" binding energies:\n- Consider only even-even nuclei so that the pairing-sign factor is $s(A,Z)=+1$ for all entries. Use the following set of isotopes:\n  - Calcium chain: $(A,Z)\\in\\{(40,20),(42,20),(44,20),(46,20),(48,20)\\}$.\n  - Nickel chain: $(A,Z)\\in\\{(56,28),(58,28),(60,28),(62,28),(64,28)\\}$.\n  - Tin chain: $(A,Z)\\in\\{(100,50),(102,50),(104,50),(106,50),(108,50)\\}$.\n  - Lead chain: $(A,Z)\\in\\{(204,82),(206,82),(208,82)\\}$.\n- Define the \"experimental\" binding energy $B_{\\mathrm{exp}}(A,Z)$ by an extended macroscopic model with known ground-truth constants and a simple schematic shell correction at selected magic neutron numbers:\n  $$\n  B_{\\mathrm{exp}}(A,Z) \\equiv a_v^{\\star} A \\;-\\; a_s^{\\star} A^{2/3} \\;-\\; a_c^{\\star} \\frac{Z(Z-1)}{A^{1/3}} \\;-\\; a_a^{\\star} \\frac{(N-Z)^2}{A} \\;-\\; a_{ss}^{\\star} \\frac{(N-Z)^2}{A^{4/3}} \\;+\\; a_p^{\\star} \\frac{s(A,Z)}{A^{1/2}} \\;+\\; S_{\\mathrm{magic}}(N),\n  $$\n  with constants\n  $$\n  a_v^{\\star}=15.75\\,\\mathrm{MeV},\\quad a_s^{\\star}=17.80\\,\\mathrm{MeV},\\quad a_c^{\\star}=0.711\\,\\mathrm{MeV},\\quad a_a^{\\star}=23.0\\,\\mathrm{MeV},\\quad a_{ss}^{\\star}=12.0\\,\\mathrm{MeV},\\quad a_p^{\\star}=12.0\\,\\mathrm{MeV},\n  $$\n  and a schematic shell correction\n  $$\n  S_{\\mathrm{magic}}(N)=\n  \\begin{cases}\n  2.0\\,\\mathrm{MeV}, & \\text{if } N \\in \\{20,28,50,82,126\\},\\\\\n  0.0\\,\\mathrm{MeV}, & \\text{otherwise}.\n  \\end{cases}\n  $$\n  All energies are in megaelectronvolts (MeV).\n\nFitting task:\n- For each model $\\mathcal{M}_1$ and $\\mathcal{M}_2$, estimate the coefficients $c_j$ by minimizing the sum of squared residuals\n  $$\n  \\sum_{i} \\left[ B_{\\mathrm{exp}}(A_i,Z_i) - \\sum_{j} c_j\\, g_j(A_i,Z_i) \\right]^2,\n  $$\n  using ordinary least squares across the full dataset.\n\nTwo-Neutron Separation Energy (S2n):\n- For a fixed proton number $Z$, the Two-Neutron Separation Energy (S2n) is defined as\n  $$\n  S_{2n}(A,Z) \\equiv B(A,Z) - B(A-2,Z),\n  $$\n  where $B$ denotes a binding energy from either the experimental definition or a model prediction. Compute $S_{2n,\\mathrm{exp}}(A,Z)$ from $B_{\\mathrm{exp}}(A,Z)$ and $S_{2n,\\mathrm{th}}(A,Z)$ from each fitted model $B_{\\mathrm{th}}(A,Z)=\\sum_j c_j g_j(A,Z)$.\n\nTest suite:\n- Evaluate $S_{2n}$ residuals for the following isotopic-chain pairs (each pair is a valid $(A,Z)$ with $(A-2,Z)$ present in the dataset):\n  - Calcium: $(A,Z)\\in\\{(42,20),(44,20),(46,20),(48,20)\\}$.\n  - Nickel: $(A,Z)\\in\\{(58,28),(60,28),(62,28),(64,28)\\}$.\n  - Tin: $(A,Z)\\in\\{(102,50),(104,50),(106,50),(108,50)\\}$.\n  - Lead: $(A,Z)\\in\\{(206,82),(208,82)\\}$.\n- For each model, compute the root-mean-square (RMS) of the $S_{2n}$ residuals across all pairs:\n  $$\n  \\mathrm{RMS} \\equiv \\sqrt{\\frac{1}{M}\\sum_{k=1}^{M}\\left[S_{2n,\\mathrm{th}}(A_k,Z_k)-S_{2n,\\mathrm{exp}}(A_k,Z_k)\\right]^2},\n  $$\n  where $M$ is the total number of pairs in the test suite.\n\nOutput specification:\n- Your program must produce a single line containing a comma-separated list enclosed in square brackets with three floating-point numbers rounded to six decimal places:\n  1. The RMS of $S_{2n}$ residuals for $\\mathcal{M}_1$ in $\\mathrm{MeV}$.\n  2. The RMS of $S_{2n}$ residuals for $\\mathcal{M}_2$ in $\\mathrm{MeV}$.\n  3. The difference $\\Delta$ defined by $\\Delta=\\mathrm{RMS}_{\\mathcal{M}_1}-\\mathrm{RMS}_{\\mathcal{M}_2}$ in $\\mathrm{MeV}$.\n- The units are megaelectronvolts (MeV). The final output format must be exactly of the form\n  $$\n  [\\mathrm{RMS}_{\\mathcal{M}_1},\\mathrm{RMS}_{\\mathcal{M}_2},\\Delta],\n  $$\n  for example, \"[0.123456,0.078901,0.044555]\".\n\nImplementation constraints:\n- The program must be self-contained, require no user input, read no external files, and produce the exact single-line output described. Use a deterministic computation of $B_{\\mathrm{exp}}(A,Z)$ according to the definition above. Use double-precision floating-point arithmetic.", "solution": "The problem requires a comparative analysis of two macroscopic nuclear mass models, $\\mathcal{M}_1$ and $\\mathcal{M}_2$, both derived from the liquid drop picture. The assessment involves fitting these models to a synthetic dataset of nuclear binding energies and then evaluating their predictive accuracy for the Two-Neutron Separation Energy ($S_{2n}$). The models differ in their treatment of the symmetry energy: $\\mathcal{M}_1$ uses a pure volume-symmetry term, while $\\mathcal{M}_2$ adds a surface-symmetry correction.\n\nThe solution proceeds in four main stages:\n1.  **Generation of Synthetic Experimental Data**: We first compute the \"experimental\" binding energies, $B_{\\mathrm{exp}}(A,Z)$, for a specified set of $18$ even-even nuclei.\n2.  **Model Fitting via Ordinary Least Squares (OLS)**: For each model, $\\mathcal{M}_1$ and $\\mathcal{M}_2$, we determine the optimal set of coefficients by fitting the model's theoretical binding energy formula to the synthetic data.\n3.  **Calculation of Two-Neutron Separation Energies**: Using both the synthetic data and the fitted models, we compute the $S_{2n}$ values for a specified test suite of nuclei.\n4.  **Performance Evaluation**: We calculate the root-mean-square (RMS) error of the predicted $S_{2n}$ values for each model and compare their performance.\n\n**1. Synthetic Experimental Binding Energy, $B_{\\mathrm{exp}}(A,Z)$**\n\nThe problem provides a precise formula for the synthetic \"experimental\" binding energy $B_{\\mathrm{exp}}(A,Z)$ for a nucleus with mass number $A$ and proton number $Z$. Let $N = A - Z$ be the neutron number. The formula is:\n$$\nB_{\\mathrm{exp}}(A,Z) = a_v^{\\star} A - a_s^{\\star} A^{2/3} - a_c^{\\star} \\frac{Z(Z-1)}{A^{1/3}} - a_a^{\\star} \\frac{(N-Z)^2}{A} - a_{ss}^{\\star} \\frac{(N-Z)^2}{A^{4/3}} + a_p^{\\star} \\frac{s(A,Z)}{A^{1/2}} + S_{\\mathrm{magic}}(N)\n$$\nThe constants are given as $a_v^{\\star}=15.75$, $a_s^{\\star}=17.80$, $a_c^{\\star}=0.711$, $a_a^{\\star}=23.0$, $a_{ss}^{\\star}=12.0$, and $a_p^{\\star}=12.0$, all in units of $\\mathrm{MeV}$. Since all nuclei in the dataset are even-even, the pairing-sign factor is $s(A,Z)=+1$. The schematic shell correction $S_{\\mathrm{magic}}(N)$ is $2.0\\,\\mathrm{MeV}$ for magic neutron numbers $N \\in \\{20,28,50,82,126\\}$ and $0$ otherwise. We first compute these $B_{\\mathrm{exp}}$ values for all nuclei in the dataset, which serve as the ground truth for the fitting procedure.\n\n**2. Model Formulation and Ordinary Least Squares (OLS) Fitting**\n\nThe theoretical binding energy, $B_{\\mathrm{th}}(A,Z)$, for both models is expressed as a linear combination of basis functions $g_j(A,Z)$:\n$$\nB_{\\mathrm{th}}(A,Z) = \\sum_{j} c_j g_j(A,Z)\n$$\nThe coefficients $c_j$ are unknown parameters to be determined. This problem structure lends itself to a solution using ordinary least squares (OLS). For a dataset of $n$ nuclei, we can construct a linear system $\\mathbf{y} \\approx \\mathbf{X}\\mathbf{c}$, where:\n- $\\mathbf{y}$ is a column vector of size $n$ containing the experimental binding energies, $y_i = B_{\\mathrm{exp}}(A_i, Z_i)$.\n- $\\mathbf{X}$ is the $n \\times k$ design matrix, where $k$ is the number of basis functions in the model. Each entry $X_{ij}$ is the value of the $j$-th basis function for the $i$-th nucleus, $X_{ij} = g_j(A_i, Z_i)$.\n- $\\mathbf{c}$ is the column vector of the $k$ unknown coefficients $c_j$.\n\nThe OLS method finds the vector $\\mathbf{c}$ that minimizes the sum of squared residuals, $\\|\\mathbf{y} - \\mathbf{X}\\mathbf{c}\\|^2$. The solution is given by $\\mathbf{c} = (\\mathbf{X}^T\\mathbf{X})^{-1}\\mathbf{X}^T\\mathbf{y}$.\n\n**Model $\\mathcal{M}_1$ (Volume Symmetry):**\nThis model uses $k=5$ basis functions:\n- Volume: $g_1(A,Z) = A$\n- Surface: $g_2(A,Z) = A^{2/3}$\n- Coulomb: $g_3(A,Z) = \\frac{Z(Z-1)}{A^{1/3}}$\n- Symmetry (volume): $g_4(A,Z) = \\frac{(N-Z)^2}{A}$\n- Pairing: $g_5(A,Z) = \\frac{s(A,Z)}{A^{1/2}} = A^{-1/2}$ (since $s(A,Z)=+1$)\n\nWe construct the $18 \\times 5$ design matrix $\\mathbf{X}_1$ and the target vector $\\mathbf{y}$ from the dataset of $18$ nuclei. We then solve for the coefficient vector $\\mathbf{c}_1$.\n\n**Model $\\mathcal{M}_2$ (Volume + Surface Symmetry):**\nThis model extends $\\mathcal{M}_1$ with a sixth basis function ($k=6$), representing the surface contribution to the symmetry energy:\n- Symmetry (surface): $g_6(A,Z) = \\frac{(N-Z)^2}{A^{4/3}}$\n\nWe construct the $18 \\times 6$ design matrix $\\mathbf{X}_2$ and solve for the coefficient vector $\\mathbf{c}_2$ using the same target vector $\\mathbf{y}$.\n\nA numerically robust implementation for solving these linear systems is `numpy.linalg.lstsq`, which we utilize.\n\n**3. Calculation of Two-Neutron Separation Energy ($S_{2n}$)**\n\nThe Two-Neutron Separation Energy is defined as the energy required to remove two neutrons from a nucleus:\n$$\nS_{2n}(A,Z) = B(A,Z) - B(A-2,Z)\n$$\nWe compute this quantity for the specified test suite of $M=14$ nuclei pairs.\n- $S_{2n,\\mathrm{exp}}(A,Z)$ is calculated using the synthetic $B_{\\mathrm{exp}}$ values.\n- $S_{2n,\\mathrm{th},1}(A,Z)$ is calculated using the theoretical binding energies $B_{\\mathrm{th},1}(A,Z) = \\sum_{j=1}^{5} c_{1,j} g_j(A,Z)$ with the fitted coefficients $\\mathbf{c}_1$.\n- $S_{2n,\\mathrm{th},2}(A,Z)$ is calculated using $B_{\\mathrm{th},2}(A,Z) = \\sum_{j=1}^{6} c_{2,j} g_j(A,Z)$ with coefficients $\\mathbf{c}_2$.\n\n**4. Performance Evaluation via RMS Error**\n\nThe final step is to quantify how well each model reproduces the experimental $S_{2n}$ values. We use the root-mean-square (RMS) of the residuals for this purpose. For each model $\\mathcal{M}_k$:\n$$\n\\mathrm{RMS}_{\\mathcal{M}_k} = \\sqrt{\\frac{1}{M}\\sum_{i=1}^{M}\\left[S_{2n,\\mathrm{th},k}(A_i,Z_i) - S_{2n,\\mathrm{exp}}(A_i,Z_i)\\right]^2}\n$$\nThe sum runs over the $M=14$ pairs in the $S_{2n}$ test suite. We compute $\\mathrm{RMS}_{\\mathcal{M}_1}$ and $\\mathrm{RMS}_{\\mathcal{M}_2}$. The difference, $\\Delta = \\mathrm{RMS}_{\\mathcal{M}_1} - \\mathrm{RMS}_{\\mathcal{M}_2}$, provides a direct measure of the improvement gained by including the surface-symmetry term. A positive $\\Delta$ indicates that model $\\mathcal{M}_2$ is more accurate. The shell correction term $S_{\\mathrm{magic}}(N)$ in the synthetic data is not part of either model's basis set, acting as a source of unmodeled physics. The ability of each model to handle this missing physics, particularly in a differential quantity like $S_{2n}$, is the core of this test.\n\nThe program implements these steps sequentially, ensuring all calculations are performed with double-precision floating-point arithmetic, and formats the final results as specified.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements, fits, and assesses two macroscopic nuclear mass models.\n    \"\"\"\n    # Ground-truth constants for synthetic experimental data in MeV\n    A_V_STAR = 15.75\n    A_S_STAR = 17.80\n    A_C_STAR = 0.711\n    A_A_STAR = 23.0\n    A_SS_STAR = 12.0\n    A_P_STAR = 12.0\n\n    # Dataset of even-even nuclei for fitting (A, Z)\n    fit_dataset = [\n        (40, 20), (42, 20), (44, 20), (46, 20), (48, 20),  # Calcium\n        (56, 28), (58, 28), (60, 28), (62, 28), (64, 28),  # Nickel\n        (100, 50), (102, 50), (104, 50), (106, 50), (108, 50),  # Tin\n        (204, 82), (206, 82), (208, 82)  # Lead\n    ]\n\n    # Test suite for S2n residuals (A, Z)\n    s2n_test_suite = [\n        (42, 20), (44, 20), (46, 20), (48, 20),\n        (58, 28), (60, 28), (62, 28), (64, 28),\n        (102, 50), (104, 50), (106, 50), (108, 50),\n        (206, 82), (208, 82)\n    ]\n\n    magic_neutron_numbers = {20, 28, 50, 82, 126}\n\n    # Helper functions for basis functions g_j(A, Z)\n    # s(A,Z) is +1 for all nuclei in the dataset.\n    def g1(A, Z): return A  # Volume\n    def g2(A, Z): return A**(2/3)  # Surface\n    def g3(A, Z): return Z * (Z - 1) / A**(1/3)  # Coulomb\n    def g4(A, Z):  # Symmetry (volume)\n        N = A - Z\n        return (N - Z)**2 / A\n    def g5(A, Z): return A**(-1/2)  # Pairing\n    def g6(A, Z):  # Symmetry (surface)\n        N = A - Z\n        return (N - Z)**2 / A**(4/3)\n\n    # Function to calculate synthetic experimental binding energy\n    def calculate_b_exp(A, Z):\n        N = A - Z\n        s_magic = 2.0 if N in magic_neutron_numbers else 0.0\n        \n        b_exp = (A_V_STAR * g1(A, Z) -\n                 A_S_STAR * g2(A, Z) -\n                 A_C_STAR * g3(A, Z) -\n                 A_A_STAR * g4(A, Z) -\n                 A_SS_STAR * g6(A, Z) +\n                 A_P_STAR * g5(A, Z) +\n                 s_magic)\n        return b_exp\n\n    # --- Generate synthetic \"experimental\" data ---\n    y_exp = np.array([calculate_b_exp(A, Z) for A, Z in fit_dataset])\n    b_exp_map = {nucleus: b for nucleus, b in zip(fit_dataset, y_exp)}\n\n    rms_results = []\n    models = {\n        'M1': [g1, g2, g3, g4, g5],\n        'M2': [g1, g2, g3, g4, g5, g6]\n    }\n\n    for model_name, basis_functions in models.items():\n        # --- Model Fitting via OLS ---\n        # Construct the design matrix X\n        X = np.array([[func(A, Z) for func in basis_functions] for A, Z in fit_dataset])\n        \n        # Solve for coefficients c using least squares\n        coeffs, _, _, _ = np.linalg.lstsq(X, y_exp, rcond=None)\n        \n        # --- Calculate Theoretical Binding Energies ---\n        b_th_map = {}\n        for i, (A, Z) in enumerate(fit_dataset):\n            b_th_map[(A, Z)] = np.dot(X[i, :], coeffs)\n\n        # --- Calculate S2n and Residuals ---\n        s2n_residuals = []\n        for A, Z in s2n_test_suite:\n            A_minus_2 = A - 2\n            \n            # S2n experimental\n            s2n_exp = b_exp_map[(A, Z)] - b_exp_map[(A_minus_2, Z)]\n            \n            # S2n theoretical\n            s2n_th = b_th_map[(A, Z)] - b_th_map[(A_minus_2, Z)]\n            \n            s2n_residuals.append(s2n_th - s2n_exp)\n            \n        # --- Performance Evaluation (RMS) ---\n        rms = np.sqrt(np.mean(np.square(s2n_residuals)))\n        rms_results.append(rms)\n\n    rms_m1 = rms_results[0]\n    rms_m2 = rms_results[1]\n    delta = rms_m1 - rms_m2\n\n    print(f\"[{rms_m1:.6f},{rms_m2:.6f},{delta:.6f}]\")\n\nsolve()\n```", "id": "3568528"}, {"introduction": "Finding the best-fit parameters for a model is often just the beginning; understanding how well those parameters are constrained by the data is equally important. This advanced exercise [@problem_id:3568593] introduces Hessian analysis, a powerful method for diagnosing parameter sensitivity. You will compute the curvature of the $\\chi^2$ cost function at its minimum to identify which combinations of the model's parameters are well-determined ('stiff') and which are poorly constrained ('sloppy'), providing deep insight into the model's structure and its relationship with the data.", "problem": "You are asked to implement and analyze a Macroscopic Nuclear Mass Model based on the liquid drop picture. Use the Semi-Empirical Mass Formula (SEMF) as the model for the nuclear binding energy. The unknown model parameters are the coefficients $a_v$, $a_s$, $a_c$, $a_a$, and $a_p$, which multiply the volume, surface, Coulomb, asymmetry, and pairing terms, respectively. Assume the go-to form of the SEMF where the pairing correction $\\delta$ depends on whether neutron number $N$ and proton number $Z$ are even or odd. The model binding energy $B_{\\text{th}}(A,Z;\\boldsymbol{\\theta})$ is constructed from powers of $A$, $Z$, $N$, and includes the pairing correction that follows the standard even-even, odd-odd, and odd-even rules, with pairing strength scaled by $A^{-1/2}$. All energies must be treated in mega-electronvolts (MeV). The cost function is the canonical least-squares sum\n$$\n\\chi^2(\\boldsymbol{\\theta}) \\equiv \\sum_{i=1}^{M} \\left( \\frac{B_{\\text{th}}(A_i,Z_i;\\boldsymbol{\\theta}) - B_{\\text{ref}}(A_i,Z_i)}{\\sigma_i} \\right)^2,\n$$\nwhere $B_{\\text{ref}}$ are reference binding energies and $\\sigma_i$ are weights with units of MeV. Treat $A$ and $Z$ as integers, $N \\equiv A - Z$, and $\\boldsymbol{\\theta} \\equiv (a_v,a_s,a_c,a_a,a_p)$.\n\nFundamental base to use:\n- The total binding energy of a nucleus is the difference between the rest-mass energy of the constituent nucleons and the nuclear rest-mass energy. In macroscopic models, $B_{\\text{th}}$ is modeled by well-tested bulk terms obeying approximate scaling with $A$ and $Z$. Use the standard SEMF terms for volume, surface, Coulomb, asymmetry, and a pairing correction that is positive for even-even, negative for odd-odd, and zero for odd-even nuclei.\n- Weighted least squares defines $\\chi^2$ as above. At an optimum $\\boldsymbol{\\theta}_\\star$, the stiffness of parameter combinations is characterized by the Hessian matrix of second derivatives of $\\chi^2$ with respect to the parameters.\n\nData generation and reference:\n- Do not use external data. Instead, generate synthetic but physically realistic reference binding energies $B_{\\text{ref}}$ by evaluating the same SEMF model at the following \"true\" coefficients (all in MeV): $a_v^{\\text{true}}=15.8$, $a_s^{\\text{true}}=18.3$, $a_c^{\\text{true}}=0.714$, $a_a^{\\text{true}}=23.2$, $a_p^{\\text{true}}=12.0$. This ensures a scientifically sound and self-consistent reference set.\n- For the pairing correction, use $\\delta(A,Z)=+a_p A^{-1/2}$ if both $N$ and $Z$ are even, $\\delta(A,Z)=-a_p A^{-1/2}$ if both $N$ and $Z$ are odd, and $\\delta(A,Z)=0$ otherwise.\n- The nuclei to use are specified below as $(A,Z)$ pairs:\n  - Full set: $\\{(12,6),(16,8),(40,20),(48,20),(56,26),(90,40),(100,50),(118,50),(132,50),(208,82),(238,92)\\}$.\n  - Reduced set: $\\{(16,8),(40,20),(48,20),(132,50),(208,82)\\}$.\n\nOptimization requirement:\n- Determine the optimal parameters $\\boldsymbol{\\theta}_\\star$ by minimizing $\\chi^2$ with respect to the free parameters using nonlinear least squares. Use physically reasonable initialization and bounds that keep parameters within plausible macroscopic scales. All energies are in MeV.\n\nHessian requirement:\n- Compute the Hessian matrix $H_{jk}(\\boldsymbol{\\theta}_\\star) \\equiv \\frac{\\partial^2 \\chi^2}{\\partial \\theta_j \\partial \\theta_k}\\big|_{\\boldsymbol{\\theta}_\\star}$ numerically by central finite differences. Use a relative step $h_j = \\varepsilon \\max(1,|\\theta_{\\star,j}|)$ with a small $\\varepsilon$ for each parameter direction, and assemble the full matrix via finite-difference differentiation of the gradient. Symmetrize the result by taking $\\frac{1}{2}(H+H^\\top)$ to remove numerical asymmetries. The Hessian entries have units of $\\text{MeV}^{-2}$ because $\\chi^2$ is dimensionless.\n\nEigenanalysis requirement:\n- Diagonalize the Hessian at $\\boldsymbol{\\theta}_\\star$ to obtain eigenvalues and eigenvectors. Sort eigenvalues in descending order. Large eigenvalues correspond to stiff combinations; small eigenvalues correspond to sloppy combinations. Report eigenvalues only. Express eigenvalues in $\\text{MeV}^{-2}$ as floating-point numbers.\n\nTest suite and outputs:\nImplement four test cases that exercise different aspects of stiffness and data/weighting:\n1. Test $1$: Full nucleus set, uniform weights $\\sigma_i = 1.0$ MeV; all five parameters free. Output the list of eigenvalues of the $5 \\times 5$ Hessian at the optimum, sorted descending, in $\\text{MeV}^{-2}$, rounded to six significant digits.\n2. Test $2$: Full nucleus set, uniform weights $\\sigma_i = 2.0$ MeV; all five parameters free. Output the list of eigenvalues of the $5 \\times 5$ Hessian at the optimum, sorted descending, in $\\text{MeV}^{-2}$, rounded to six significant digits.\n3. Test $3$: Full nucleus set, uniform weights $\\sigma_i = 1.0$ MeV; fix $a_p=0$ identically during the fit and compute the Hessian with respect to the remaining four free parameters $(a_v,a_s,a_c,a_a)$. Output the list of eigenvalues of the $4 \\times 4$ Hessian at the optimum, sorted descending, in $\\text{MeV}^{-2}$, rounded to six significant digits.\n4. Test $4$: Reduced nucleus set, uniform weights $\\sigma_i = 1.0$ MeV; all five parameters free. Output the list of eigenvalues of the $5 \\times 5$ Hessian at the optimum, sorted descending, in $\\text{MeV}^{-2}$, rounded to six significant digits.\n\nNumerical and unit specifications:\n- All energies must be in MeV and angles are not involved.\n- Finite-difference steps must be chosen to balance truncation and round-off; use a relative step size $\\varepsilon$ of the order of $10^{-5}$.\n- The final eigenvalues must be expressed in $\\text{MeV}^{-2}$ and rounded to six significant digits.\n\nFinal output format:\n- Your program should produce a single line of output containing the results for all test cases as a comma-separated list enclosed in square brackets, where each element is itself a comma-separated list of the eigenvalues for that test case, also enclosed in square brackets. For example: \"[[e11,e12,...],[e21,e22,...],[e31,e32,...],[e41,e42,...]]\" with no spaces and all numbers rounded to six significant digits.", "solution": "The problem requires the implementation and analysis of a macroscopic nuclear mass model, specifically the Semi-Empirical Mass Formula (SEMF), to determine the stiffness of its parameters. This is accomplished by performing a weighted least-squares fit to synthetic data and subsequently analyzing the Hessian matrix of the cost function at the found parameter optimum. The analysis involves four distinct test cases designed to probe the model's structural properties under different data sets and constraints.\n\n### Step 1: Theoretical Framework\n\nThe core of the model is the Semi-Empirical Mass Formula (SEMF), which approximates the nuclear binding energy $B_{\\text{th}}$ of a nucleus with mass number $A$ and atomic number $Z$. The parameter vector is $\\boldsymbol{\\theta} = (a_v, a_s, a_c, a_a, a_p)$. The formula is a sum of five terms:\n\n$$\nB_{\\text{th}}(A, Z; \\boldsymbol{\\theta}) = T_v - T_s - T_c - T_a + T_p\n$$\n\nwhere the coefficients $a_i$ are assumed to be positive and the terms represent:\n1.  **Volume Term ($T_v$)**: $a_v A$. This term represents the bulk binding energy, proportional to the number of nucleons.\n2.  **Surface Term ($T_s$)**: $a_s A^{2/3}$. This is a correction for nucleons on the surface, which are less tightly bound.\n3.  **Coulomb Term ($T_c$)**: $a_c \\frac{Z(Z-1)}{A^{1/3}}$. This term accounts for the electrostatic repulsion between protons. The $Z(Z-1)$ form is used for accuracy with a finite number of protons.\n4.  **Asymmetry Term ($T_a$)**: $a_a \\frac{(A-2Z)^2}{A}$. This term, arising from the Pauli exclusion principle, penalizes deviations from the stable $N=Z$ line, where $N=A-Z$ is the neutron number.\n5.  **Pairing Term ($T_p$)**: $\\delta(A,Z)$. This quantum-mechanical correction accounts for the increased stability from paired nucleons. Its form is:\n    $$\n    \\delta(A,Z) =\n    \\begin{cases}\n    +a_p A^{-1/2} & \\text{if } N \\text{ is even and } Z \\text{ is even (even-even nuclei)} \\\\\n    -a_p A^{-1/2} & \\text{if } N \\text{ is odd and } Z \\text{ is odd (odd-odd nuclei)} \\\\\n    0 & \\text{if } A \\text{ is odd (odd-A nuclei)}\n    \\end{cases}\n    $$\nAll energies are specified in units of mega-electronvolts (MeV), and coefficients have corresponding units to ensure $B_{\\text{th}}$ is in MeV.\n\n### Step 2: Parameter Optimization\n\nThe optimal parameters $\\boldsymbol{\\theta}_\\star$ are determined by minimizing the weighted least-squares cost function, $\\chi^2(\\boldsymbol{\\theta})$:\n\n$$\n\\chi^2(\\boldsymbol{\\theta}) = \\sum_{i=1}^{M} \\left( \\frac{B_{\\text{th}}(A_i,Z_i;\\boldsymbol{\\theta}) - B_{\\text{ref}}(A_i,Z_i)}{\\sigma_i} \\right)^2\n$$\n\nHere, $B_{\\text{ref}}$ are reference binding energies generated using the SEMF itself with a set of \"true\" parameters $\\boldsymbol{\\theta}^{\\text{true}} = (15.8, 18.3, 0.714, 23.2, 12.0)$ MeV. This technique ensures that a perfect fit with $\\chi^2(\\boldsymbol{\\theta}^{\\text{true}}) = 0$ exists, providing a well-defined ground truth for the optimization. The optimization is performed using the `scipy.optimize.least_squares` function, which is well-suited for such problems.\n\n### Step 3: Hessian Analysis for Parameter Sensitivity\n\nThe sensitivity and correlations of the model parameters are encoded in the Hessian matrix $H(\\boldsymbol{\\theta}_\\star)$ of the cost function, evaluated at the optimal parameter set $\\boldsymbol{\\theta}_\\star$:\n\n$$\nH_{jk} = \\frac{\\partial^2 \\chi^2}{\\partial \\theta_j \\partial \\theta_k}\\bigg|_{\\boldsymbol{\\theta}=\\boldsymbol{\\theta}_\\star}\n$$\n\nThe Hessian describes the curvature of the $\\chi^2$ surface. Its eigenvalues quantify the stiffness of the model along the directions of the corresponding eigenvectors in parameter space. Large eigenvalues correspond to \"stiff\" directions, where the cost function is very sensitive to parameter changes, implying these parameter combinations are well-constrained by the data. Small eigenvalues correspond to \"sloppy\" directions, where the cost function is insensitive, indicating poorly constrained parameter combinations.\n\nThe Hessian is computed numerically using a second-order central finite-difference scheme. As specified, the gradient of $\\chi^2$ is first computed, and then the gradient itself is differentiated.\nThe gradient $\\mathbf{g} = \\nabla \\chi^2$ at $\\boldsymbol{\\theta}_\\star$ has components:\n$$\ng_k = \\frac{\\partial \\chi^2}{\\partial \\theta_k} \\approx \\frac{\\chi^2(\\boldsymbol{\\theta}_\\star + \\frac{h_k}{2}\\mathbf{e}_k) - \\chi^2(\\boldsymbol{\\theta}_\\star - \\frac{h_k}{2}\\mathbf{e}_k)}{h_k}\n$$\nThe columns of the Hessian matrix are then computed by differentiating the gradient:\n$$\nH_{:,j} = \\frac{\\partial \\mathbf{g}}{\\partial \\theta_j} \\approx \\frac{\\mathbf{g}(\\boldsymbol{\\theta}_\\star + \\frac{h_j}{2}\\mathbf{e}_j) - \\mathbf{g}(\\boldsymbol{\\theta}_\\star - \\frac{h_j}{2}\\mathbf{e}_j)}{h_j}\n$$\nThe step size for each parameter direction $j$ is chosen as $h_j = \\varepsilon \\max(1, |\\theta_{\\star,j}|)$ with a small relative step $\\varepsilon = 10^{-5}$ to balance truncation and round-off errors. The resulting numerical matrix is symmetrized via $H \\leftarrow \\frac{1}{2}(H + H^T)$ to correct for any minor floating-point asymmetries. The units of the Hessian elements are $\\text{MeV}^{-2}$, as $\\chi^2$ is dimensionless and the parameters are in MeV.\n\n### Step 4: Algorithmic Implementation\n\nThe solution is implemented in Python using the `numpy` and `scipy` libraries.\n1.  A function `binding_energy(A, Z, params)` implements the SEMF.\n2.  For each of the four test cases, the corresponding set of nuclei and weights $\\sigma_i$ are used. Reference energies $B_{\\text{ref}}$ are pre-calculated using the true parameters.\n3.  A residual function, which computes the array of terms $\\left( \\frac{B_{\\text{th}} - B_{\\text{ref}}}{\\sigma} \\right)$, is defined for use with `scipy.optimize.least_squares`. For Test 3, a wrapper function constrains $a_p=0$ during the fit.\n4.  After optimization yields $\\boldsymbol{\\theta}_\\star$, a function `compute_hessian` calculates the Hessian matrix of the `chi_squared` function at $\\boldsymbol{\\theta}_\\star$ using the numerical differentiation scheme described above.\n5.  `numpy.linalg.eigvalsh` is used to compute the eigenvalues of the symmetric Hessian matrix.\n6.  The eigenvalues are sorted in descending order, formatted to six significant digits, and assembled into the specified string format for the final output. The relationship between the eigenvalues of Test 1 and Test 2 (a factor of $1/ \\sigma^2 = 1/4$) serves as a validation check for the implementation.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import least_squares\n\ndef solve():\n    \"\"\"\n    Implements the full analysis for the macroscopic nuclear mass model problem.\n    \"\"\"\n    # Define constants and data sets specified in the problem\n    TRUE_PARAMS = np.array([15.8, 18.3, 0.714, 23.2, 12.0])\n    FULL_SET = np.array([\n        (12, 6), (16, 8), (40, 20), (48, 20), (56, 26), (90, 40),\n        (100, 50), (118, 50), (132, 50), (208, 82), (238, 92)\n    ])\n    REDUCED_SET = np.array([(16, 8), (40, 20), (48, 20), (132, 50), (208, 82)])\n    EPSILON = 1e-5\n\n    def binding_energy(A, Z, params):\n        \"\"\"Calculates the binding energy using the SEMF.\"\"\"\n        av, a_s, ac, aa, ap = params\n        N = A - Z\n        \n        vol_term = av * A\n        surf_term = -a_s * A**(2/3)\n        coul_term = -ac * Z * (Z - 1) * A**(-1/3)\n        asym_term = -aa * (A - 2*Z)**2 / A\n        \n        pair_term = 0.0\n        if A % 2 == 0:  # N and Z have the same parity\n            if Z % 2 == 0:  # Even-even\n                pair_term = ap * A**(-0.5)\n            else:  # Odd-odd\n                pair_term = -ap * A**(-0.5)\n        \n        return vol_term + surf_term + coul_term + asym_term + pair_term\n\n    def residuals(params, nuclei, b_ref, sigma):\n        \"\"\"Calculates the weighted residuals for the least-squares fit.\"\"\"\n        b_th = np.array([binding_energy(A, Z, params) for A, Z in nuclei])\n        return (b_th - b_ref) / sigma\n\n    def chi_squared(params, *args):\n        \"\"\"Calculates the chi-squared cost function.\"\"\"\n        res = residuals(params, *args)\n        return np.sum(res**2)\n\n    def compute_hessian(cost_func, x0, epsilon, args_tuple):\n        \"\"\"Computes the Hessian matrix via finite differences of the gradient.\"\"\"\n        n = len(x0)\n        \n        # Use relative step size as specified\n        h = epsilon * np.maximum(1.0, np.abs(x0))\n        h_inv = 1.0 / h\n\n        # Gradient function using central differences\n        def gradient(x, *args):\n            grad = np.zeros_like(x)\n            for i in range(len(x)):\n                h_i_half = h[i] / 2.0\n                xp = x.copy()\n                xp[i] += h_i_half\n                xm = x.copy()\n                xm[i] -= h_i_half\n                grad[i] = (cost_func(xp, *args) - cost_func(xm, *args)) * h_inv[i]\n            return grad\n        \n        # Hessian from gradient using central differences\n        hessian = np.zeros((n, n))\n        for j in range(n):\n            h_j_half = h[j] / 2.0\n            xp = x0.copy()\n            xp[j] += h_j_half\n            xm = x0.copy()\n            xm[j] -= h_j_half\n            \n            grad_p = gradient(xp, *args_tuple)\n            grad_m = gradient(xm, *args_tuple)\n            \n            hessian[:, j] = (grad_p - grad_m) * h_inv[j]\n        \n        # Symmetrize to remove numerical noise\n        return 0.5 * (hessian + hessian.T)\n\n    # Define the four test cases\n    test_cases = [\n        {'nuclei': FULL_SET, 'sigma': 1.0, 'n_params': 5, 'id': 1},\n        {'nuclei': FULL_SET, 'sigma': 2.0, 'n_params': 5, 'id': 2},\n        {'nuclei': FULL_SET, 'sigma': 1.0, 'n_params': 4, 'id': 3},\n        {'nuclei': REDUCED_SET, 'sigma': 1.0, 'n_params': 5, 'id': 4},\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        nuclei = case['nuclei']\n        sigma = case['sigma']\n        n_params = case['n_params']\n\n        # Generate reference binding energies using the true parameters\n        B_ref = np.array([binding_energy(A, Z, TRUE_PARAMS) for A, Z in nuclei])\n\n        if n_params == 5:\n            # Standard 5-parameter fit\n            p0 = TRUE_PARAMS * 1.1  # Initial guess perturbed from true values\n            bounds = ([0.0] * 5, [100.0] * 5)\n            \n            # The residual function takes 5 parameters\n            res_func = residuals\n            \n            # The cost function for Hessian calculation\n            cost_func_for_hessian = chi_squared\n            \n        else: # n_params == 4 for Test 3\n            p0 = TRUE_PARAMS[:4] * 1.1\n            bounds = ([0.0] * 4, [100.0] * 4)\n\n            # Wrapper for residuals that fixes a_p=0\n            def res_func_4p(p4, nuclei_data, b_ref_data, sigma_val):\n                p5 = np.array([p4[0], p4[1], p4[2], p4[3], 0.0])\n                return residuals(p5, nuclei_data, b_ref_data, sigma_val)\n            res_func = res_func_4p\n\n            # Wrapper for chi_squared for Hessian calculation\n            def cost_func_4p(p4, nuclei_data, b_ref_data, sigma_val):\n                p5 = np.array([p4[0], p4[1], p4[2], p4[3], 0.0])\n                return chi_squared(p5, nuclei_data, b_ref_data, sigma_val)\n            cost_func_for_hessian = cost_func_4p\n        \n        # Perform non-linear least-squares optimization\n        opt_result = least_squares(res_func, p0, args=(nuclei, B_ref, sigma), bounds=bounds)\n        p_opt = opt_result.x\n        \n        # Compute the Hessian at the optimum\n        hessian_matrix = compute_hessian(cost_func_for_hessian, p_opt, EPSILON, (nuclei, B_ref, sigma))\n        \n        # Compute and sort eigenvalues\n        eigenvalues = np.linalg.eigvalsh(hessian_matrix)\n        eigenvalues_sorted = np.sort(eigenvalues)[::-1]\n        \n        all_results.append(eigenvalues_sorted)\n\n    # Format the final output string exactly as required\n    result_str = \",\".join([\n        f\"[{','.join([f'{val:.6g}' for val in ev_list])}]\"\n        for ev_list in all_results\n    ])\n    \n    print(f\"[{result_str}]\")\n\nsolve()\n```", "id": "3568593"}]}