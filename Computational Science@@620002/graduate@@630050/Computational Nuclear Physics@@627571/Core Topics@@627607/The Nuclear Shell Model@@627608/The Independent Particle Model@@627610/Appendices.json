{"hands_on_practices": [{"introduction": "The success of the Independent Particle Model hinges on the inclusion of a strong spin-orbit interaction, which correctly reproduces the nuclear magic numbers. This first practice provides a foundational exercise in the quantum mechanical treatment of this crucial term. By deriving the expectation value of the $\\mathbf{l}\\cdot\\mathbf{s}$ operator, you will gain a first-principles understanding of how it splits energy levels based on the coupling of orbital and spin angular momentum. [@problem_id:3602406]", "problem": "Consider a single nucleon moving in a spherically symmetric mean field within the independent particle model of the nucleus. The nonrelativistic Hamiltonian is taken as a sum of a central part and a spin-orbit interaction,\n$$\nH \\;=\\; T \\,+\\, U(r) \\,+\\, H_{ls},\n$$\nwhere $T$ is the kinetic energy operator, $U(r)$ is a central potential, and\n$$\nH_{ls} \\;=\\; W_{ls}(r)\\,\\mathbf{l}\\cdot\\mathbf{s}\n$$\nis the spin-orbit interaction with $W_{ls}(r)$ a scalar function of $r$. Assume the nucleon has intrinsic spin $s=\\tfrac{1}{2}$ and that $H_{ls}$ can be treated by first-order perturbation theory for a bound single-particle eigenstate labeled by $(n,l,j)$, where $n$ is the principal quantum number, $l$ is the orbital angular momentum, and $j$ is the total angular momentum from coupling $\\mathbf{j}=\\mathbf{l}+\\mathbf{s}$.\n\nStarting from angular momentum addition rules and the definition of $\\mathbf{j}^2$, derive the general expression for the expectation value $\\langle \\mathbf{l}\\cdot\\mathbf{s}\\rangle$ in the single-particle state $(n,l,j)$. Then, using first-order perturbation theory, express the spin-orbit energy shift $\\Delta E_{j}$ in terms of $\\langle W_{ls}(r)\\rangle_{nl}$ and $\\langle \\mathbf{l}\\cdot\\mathbf{s}\\rangle$, where\n$$\n\\langle W_{ls}(r)\\rangle_{nl} \\;\\equiv\\; \\int_{0}^{\\infty} |R_{nl}(r)|^{2}\\,W_{ls}(r)\\,r^{2}\\,\\mathrm{d}r\n$$\nis the radial expectation value for the $(n,l)$ state with radial wave function $R_{nl}(r)$.\n\nNow consider a neutron in an $(n=2,l=3)$ state in a nucleus with mass number $A=40$, for which a numerical computation of the radial expectation gives $\\langle W_{ls}(r)\\rangle_{nl} = C_{nl} = 0.9$ $\\mathrm{MeV}$. Use your expression for $\\langle \\mathbf{l}\\cdot\\mathbf{s}\\rangle$ to estimate the spin-orbit energy splitting\n$$\n\\Delta E_{\\mathrm{so}} \\;\\equiv\\; E_{j=l+\\tfrac{1}{2}} \\;-\\; E_{j=l-\\tfrac{1}{2}}\n$$\nfor this $(n,l)$ configuration. Provide the final numerical value of $\\Delta E_{\\mathrm{so}}$ in $\\mathrm{MeV}$. No rounding is required; report the exact value implied by the given data.", "solution": "The solution proceeds in three parts. First, we derive the general expression for the expectation value $\\langle \\mathbf{l}\\cdot\\mathbf{s}\\rangle$. Second, we use this result within first-order perturbation theory to find the energy splitting $\\Delta E_{\\mathrm{so}}$. Third, we compute the numerical value for the given case.\n\nThe total angular momentum operator $\\mathbf{j}$ is the sum of the orbital angular momentum operator $\\mathbf{l}$ and the spin angular momentum operator $\\mathbf{s}$:\n$$\n\\mathbf{j} = \\mathbf{l} + \\mathbf{s}\n$$\nSquaring this operator gives:\n$$\n\\mathbf{j}^2 = (\\mathbf{l} + \\mathbf{s}) \\cdot (\\mathbf{l} + \\mathbf{s}) = \\mathbf{l}^2 + \\mathbf{s}^2 + 2\\,\\mathbf{l}\\cdot\\mathbf{s}\n$$\nWe can rearrange this equation to express the spin-orbit coupling operator $\\mathbf{l}\\cdot\\mathbf{s}$ in terms of the squared angular momentum operators:\n$$\n\\mathbf{l}\\cdot\\mathbf{s} = \\frac{1}{2} (\\mathbf{j}^2 - \\mathbf{l}^2 - \\mathbf{s}^2)\n$$\nThe single-particle states, denoted by $|n, l, j, m_j\\rangle$, are simultaneous eigenstates of the operators $\\mathbf{j}^2$, $\\mathbf{l}^2$, and $\\mathbf{s}^2$. The eigenvalues of these operators are given by:\n- $\\mathbf{j}^2 |n, l, j, m_j\\rangle = j(j+1)\\hbar^2 |n, l, j, m_j\\rangle$\n- $\\mathbf{l}^2 |n, l, j, m_j\\rangle = l(l+1)\\hbar^2 |n, l, j, m_j\\rangle$\n- $\\mathbf{s}^2 |n, l, j, m_j\\rangle = s(s+1)\\hbar^2 |n, l, j, m_j\\rangle$\n\nIn nuclear physics, it is conventional to use dimensionless angular momentum operators. The operator in the Hamiltonian is given as $\\mathbf{l}\\cdot\\mathbf{s}$, which is treated as a dimensionless quantity. Therefore, the expectation value of this operator is found by replacing the operators with their corresponding eigenvalues without the $\\hbar^2$ factor.\n$$\n\\langle \\mathbf{l}\\cdot\\mathbf{s}\\rangle = \\langle n, l, j, m_j | \\frac{1}{2} (\\mathbf{j}^2 - \\mathbf{l}^2 - \\mathbf{s}^2) | n, l, j, m_j \\rangle = \\frac{1}{2} [j(j+1) - l(l+1) - s(s+1)]\n$$\nFor a nucleon, the spin is $s=\\frac{1}{2}$, so $s(s+1) = \\frac{1}{2}(\\frac{1}{2}+1) = \\frac{3}{4}$. The expression becomes:\n$$\n\\langle \\mathbf{l}\\cdot\\mathbf{s}\\rangle = \\frac{1}{2} \\left[ j(j+1) - l(l+1) - \\frac{3}{4} \\right]\n$$\nThe total angular momentum quantum number $j$ can take two possible values for a given $l > 0$: $j=l+\\frac{1}{2}$ and $j=l-\\frac{1}{2}$.\n- For $j = l+\\frac{1}{2}$:\n$$\n\\langle \\mathbf{l}\\cdot\\mathbf{s}\\rangle_{j=l+1/2} = \\frac{1}{2} \\left[ \\left(l+\\frac{1}{2}\\right)\\left(l+\\frac{3}{2}\\right) - l(l+1) - \\frac{3}{4} \\right] = \\frac{1}{2} \\left[ \\left(l^2 + 2l + \\frac{3}{4}\\right) - (l^2+l) - \\frac{3}{4} \\right] = \\frac{1}{2}l\n$$\n- For $j = l-\\frac{1}{2}$:\n$$\n\\langle \\mathbf{l}\\cdot\\mathbf{s}\\rangle_{j=l-1/2} = \\frac{1}{2} \\left[ \\left(l-\\frac{1}{2}\\right)\\left(l+\\frac{1}{2}\\right) - l(l+1) - \\frac{3}{4} \\right] = \\frac{1}{2} \\left[ \\left(l^2 - \\frac{1}{4}\\right) - (l^2+l) - \\frac{3}{4} \\right] = \\frac{1}{2}(-l-1) = -\\frac{l+1}{2}\n$$\n\nNext, we apply first-order perturbation theory to find the energy shift $\\Delta E_j$ due to the spin-orbit interaction $H_{ls} = W_{ls}(r)\\mathbf{l}\\cdot\\mathbf{s}$. The energy shift is the expectation value of the perturbation in the unperturbed state $|n,l,j,m_j\\rangle$.\n$$\n\\Delta E_j = \\langle n,l,j,m_j | W_{ls}(r)\\mathbf{l}\\cdot\\mathbf{s} | n,l,j,m_j \\rangle\n$$\nSince the operator $W_{ls}(r)$ acts only on the radial part of the wavefunction and $\\mathbf{l}\\cdot\\mathbf{s}$ acts only on the spin-angular part, the expectation value can be separated into a product of radial and spin-angular expectation values.\n$$\n\\Delta E_j = \\left( \\int_{0}^{\\infty} |R_{nl}(r)|^{2}\\,W_{ls}(r)\\,r^{2}\\,\\mathrm{d}r \\right) \\cdot \\langle \\mathbf{l}\\cdot\\mathbf{s} \\rangle_{lj}\n$$\nUsing the notation from the problem statement, this is:\n$$\n\\Delta E_j = \\langle W_{ls}(r)\\rangle_{nl} \\langle \\mathbf{l}\\cdot\\mathbf{s}\\rangle_{lj}\n$$\n\nThe spin-orbit energy splitting $\\Delta E_{\\mathrm{so}}$ is the difference between the energies of the two possible $j$ states for a given $l$. The unperturbed energy $E^{(0)}_{nl}$ depends on $n$ and $l$ but not on $j$. Thus, the splitting is simply the difference in the first-order energy shifts.\n$$\n\\Delta E_{\\mathrm{so}} = E_{j=l+\\tfrac{1}{2}} - E_{j=l-\\tfrac{1}{2}} = (E^{(0)}_{nl} + \\Delta E_{l+1/2}) - (E^{(0)}_{nl} + \\Delta E_{l-1/2}) = \\Delta E_{l+1/2} - \\Delta E_{l-1/2}\n$$\nSubstituting the expressions for the energy shifts:\n$$\n\\Delta E_{\\mathrm{so}} = \\langle W_{ls}(r)\\rangle_{nl} \\langle \\mathbf{l}\\cdot\\mathbf{s}\\rangle_{j=l+1/2} - \\langle W_{ls}(r)\\rangle_{nl} \\langle \\mathbf{l}\\cdot\\mathbf{s}\\rangle_{j=l-1/2}\n$$\n$$\n\\Delta E_{\\mathrm{so}} = \\langle W_{ls}(r)\\rangle_{nl} \\left( \\langle \\mathbf{l}\\cdot\\mathbf{s}\\rangle_{j=l+1/2} - \\langle \\mathbf{l}\\cdot\\mathbf{s}\\rangle_{j=l-1/2} \\right)\n$$\nUsing the derived values for $\\langle \\mathbf{l}\\cdot\\mathbf{s}\\rangle$:\n$$\n\\Delta E_{\\mathrm{so}} = \\langle W_{ls}(r)\\rangle_{nl} \\left( \\frac{l}{2} - \\left(-\\frac{l+1}{2}\\right) \\right) = \\langle W_{ls}(r)\\rangle_{nl} \\left( \\frac{l+l+1}{2} \\right)\n$$\n$$\n\\Delta E_{\\mathrm{so}} = \\langle W_{ls}(r)\\rangle_{nl} \\frac{2l+1}{2}\n$$\n\nFinally, we substitute the numerical values provided for the neutron in the $(n=2,l=3)$ state. We are given $l=3$ and $\\langle W_{ls}(r)\\rangle_{nl} = 0.9$ $\\mathrm{MeV}$.\n$$\n\\Delta E_{\\mathrm{so}} = (0.9 \\; \\mathrm{MeV}) \\cdot \\frac{2(3)+1}{2} = (0.9 \\; \\mathrm{MeV}) \\cdot \\frac{7}{2}\n$$\n$$\n\\Delta E_{\\mathrm{so}} = (0.9 \\; \\mathrm{MeV}) \\cdot 3.5 = 3.15 \\; \\mathrm{MeV}\n$$\nThe calculated spin-orbit splitting for the $l=3$ levels is $3.15$ $\\mathrm{MeV}$.", "answer": "$$\n\\boxed{3.15}\n$$", "id": "3602406"}, {"introduction": "Building upon the analytical result for the spin-orbit splitting, this computational exercise allows you to visualize its structural impact on the entire nuclear shell system. You will implement a simplified yet powerful shell model based on a harmonic oscillator potential and observe how varying the spin-orbit strength, $V_{ls}$, reshapes the single-particle spectrum. This practice demonstrates vividly how the correct magic numbers emerge from the interplay between the central potential and the spin-orbit force. [@problem_id:3602363]", "problem": "You are asked to implement a computational study of the independent particle model for nucleons in a spherically symmetric mean field with a spin–orbit interaction. Begin with the spherical three-dimensional harmonic oscillator as the baseline mean field and add a one-body spin–orbit term. The central idea is to model the single-particle spectrum and observe how the spin–orbit strength breaks degeneracy patterns within major shells and how the inferred magic numbers change as the spin–orbit strength varies.\n\nUse the following physically standard and widely accepted starting points:\n\n- In the independent particle model, a single nucleon moves in an average mean-field potential. For a spherical harmonic oscillator, the unperturbed energy is given by $E_{\\mathrm{HO}} = \\hbar\\omega\\left(N + \\tfrac{3}{2}\\right)$, where $N = 2n + l$ is the major oscillator quantum number, $n \\in \\{0,1,2,\\dots\\}$ is the radial quantum number, and $l \\in \\{0,1,2,\\dots\\}$ is the orbital angular momentum quantum number.\n\n- The one-body spin–orbit operator is $V_{ls}\\,\\mathbf{l}\\cdot\\mathbf{s}$, where $V_{ls}$ is a strength parameter (in $\\mathrm{MeV}$), $\\mathbf{l}$ is the orbital angular momentum operator, and $\\mathbf{s}$ is the spin operator for a nucleon with spin $s = \\tfrac{1}{2}$.\n\n- For a spherical basis state labeled by $(N,l,j)$ with total angular momentum $j \\in \\{l \\pm \\tfrac{1}{2}\\}$ (with only $j=\\tfrac{1}{2}$ for $l=0$), the expectation value is $\\langle \\mathbf{l}\\cdot\\mathbf{s} \\rangle = \\tfrac{1}{2}\\left[j(j+1)-l(l+1)-s(s+1)\\right]$, with $s(s+1) = \\tfrac{3}{4}$.\n\n- The degeneracy (capacity) of a given $(l,j)$ level for a single species (either neutrons or protons) is $g = 2j+1$.\n\nDefine the single-particle energies by\n$$\nE_{Nlj} = \\hbar\\omega\\left(N + \\tfrac{3}{2}\\right) + V_{ls}\\,\\tfrac{1}{2}\\left[j(j+1)-l(l+1)-\\tfrac{3}{4}\\right],\n$$\nwith $\\hbar\\omega$ a fixed scale and $V_{ls}$ varied. In this problem, you must take $\\hbar\\omega = 10\\,\\mathrm{MeV}$ and sweep $V_{ls}$ over negative values to observe how degeneracies are broken and how magic numbers change.\n\nAlgorithmic specification:\n\n1. Enumerate all spherical harmonic oscillator orbitals $(N,l,j)$ with $N \\in \\{0,1,2,3,4,5,6\\}$ (i.e., $N_{\\max}=6$). For each $N$, include all allowed $l \\in \\{N, N-2, \\dots, 0 \\text{ or } 1\\}$, and for each $l>0$ include both $j=l-\\tfrac{1}{2}$ and $j=l+\\tfrac{1}{2}$, while for $l=0$ include only $j=\\tfrac{1}{2}$.\n\n2. For a given $V_{ls}$, compute every $E_{Nlj}$ in $\\mathrm{MeV}$ and the corresponding degeneracy $g=2j+1$. Sort all levels by ascending energy $E_{Nlj}$.\n\n3. Define the cumulative occupancy $C_{k}$ as the running sum of degeneracies after filling levels in order of increasing energy, i.e., $C_{k} = \\sum_{i=1}^{k} g_{i}$. To determine magic numbers from the spectrum, introduce a fixed \"significant gap\" threshold $\\Delta_{\\mathrm{gap}}$ (in $\\mathrm{MeV}$). Whenever there is an energy gap between consecutive levels that satisfies $\\Delta E_{k} = E_{k+1} - E_{k} \\ge \\Delta_{\\mathrm{gap}}$, register $C_{k}$ as a magic number (interpreted as a filled-shell closure for a single nucleon species). Use $\\Delta_{\\mathrm{gap}} = 5\\,\\mathrm{MeV}$.\n\n4. Only report magic numbers up to and including $126$ (that is, report any $C_{k} \\le 126$ and ignore larger closures). This corresponds to the standard range of well-established magic numbers for a single species.\n\nPhysical units:\n\n- All energies must be handled in $\\mathrm{MeV}$. The output magic numbers are dimensionless integers.\n\nAngle units are not applicable to this problem.\n\nTest suite:\n\n- Use the following spin–orbit strengths (in $\\mathrm{MeV}$): $V_{ls} \\in \\{0, -2.5, -5.0, -7.5, -10.0\\}$.\n- For each of these values, compute the list of magic numbers defined by the rule above.\n\nFinal output format:\n\n- Your program must produce a single line of output containing the results as a comma-separated list of lists, enclosed in square brackets, with no spaces. For example, for three test cases with outputs $[2,8]$, $[2,8,20]$, and $[2,8,20,28]$, the required output would be exactly \"[[2,8],[2,8,20],[2,8,20,28]]\".\n- In this problem, your program’s single-line output must be a list of five lists, corresponding to $V_{ls} = 0$, $-2.5$, $-5.0$, $-7.5$, and $-10.0$ in that order.", "solution": "The solution to this problem involves computationally modeling the single-particle energy spectrum of a nucleon in a mean field and identifying magic numbers, which correspond to fully occupied shells separated by significant energy gaps. The model starts with a spherical three-dimensional quantum harmonic oscillator and adds a spin-orbit interaction term, which is crucial for reproducing the empirically observed magic numbers beyond $20$.\n\nThe energy of a single-particle state, or orbital, characterized by the quantum numbers for the major oscillator shell ($N$), orbital angular momentum ($l$), and total angular momentum ($j$), is given by the sum of the harmonic oscillator energy and the spin-orbit energy correction:\n$$\nE_{Nlj} = E_{\\mathrm{HO}} + E_{ls}\n$$\nThe unperturbed harmonic oscillator energy depends only on the major shell number $N=2n+l$, where $n$ is the radial quantum number. With the given energy scale $\\hbar\\omega = 10\\,\\mathrm{MeV}$, this is:\n$$\nE_{\\mathrm{HO}} = \\hbar\\omega\\left(N + \\frac{3}{2}\\right) = 10\\left(N + \\frac{3}{2}\\right)\\,\\mathrm{MeV}\n$$\nIn the absence of other interactions, all orbitals within a given $N$ shell are degenerate, leading to magic numbers at $2$, $8$, $20$, $40$, $70$, and $112$.\n\nThe spin-orbit interaction, $V_{ls}\\,\\mathbf{l}\\cdot\\mathbf{s}$, breaks this degeneracy. The energy correction $E_{ls}$ is the expectation value of this operator. For a state with quantum numbers $l$ and $j$, where $j$ can be $l \\pm \\frac{1}{2}$ (for $l > 0$), and with nucleon spin $s=\\frac{1}{2}$, the expectation value is:\n$$\nE_{ls} = V_{ls}\\,\\langle \\mathbf{l}\\cdot\\mathbf{s} \\rangle = V_{ls}\\,\\frac{1}{2}\\left[j(j+1)-l(l+1)-s(s+1)\\right]\n$$\nSubstituting $s(s+1) = \\frac{3}{4}$, this simplifies to two cases for $l > 0$:\n1.  For $j=l+\\frac{1}{2}$ (spin and orbital angular momentum aligned): $\\langle \\mathbf{l}\\cdot\\mathbf{s} \\rangle = \\frac{l}{2}$. The energy shift is $V_{ls}\\frac{l}{2}$.\n2.  For $j=l-\\frac{1}{2}$ (spin and orbital angular momentum anti-aligned): $\\langle \\mathbf{l}\\cdot\\mathbf{s} \\rangle = -\\frac{l+1}{2}$. The energy shift is $-V_{ls}\\frac{l+1}{2}$.\n\nFor $l = 0$, we must have $j=\\frac{1}{2}$, and the spin-orbit energy shift is zero. Since the physical spin-orbit strength $V_{ls}$ is negative, the \"aligned\" ($j=l+\\frac{1}{2}$) orbitals are lowered in energy, while the \"anti-aligned\" ($j=l-\\frac{1}{2}$) orbitals are raised. The magnitude of this splitting increases with $l$. This effect is most pronounced for the highest-$l$ orbital in each shell, which can be shifted down in energy enough to become part of the shell below, restructuring the shell gaps and producing the correct sequence of magic numbers.\n\nThe algorithmic procedure to find the magic numbers is as follows:\n\n1.  **Enumerate States**: Systematically generate all allowed single-particle states $(N, l, j)$ for major shell numbers $N$ from $0$ to $6$. For each $N$, the allowed orbital angular momenta are $l = N, N-2, \\dots, 0$ or $1$. For each $l$, the corresponding $j$ values are determined.\n\n2.  **Calculate Level Properties**: For each generated state and a given spin-orbit strength $V_{ls}$, calculate its energy $E_{Nlj}$ using the formula above. Also, calculate its degeneracy (the number of nucleons of one type it can hold), which is given by $g = 2j+1$.\n\n3.  **Sort by Energy**: Create a list of all states with their corresponding energies and degeneracies. Sort this list in ascending order of energy. This sorted order represents the sequence in which the orbitals are filled by nucleons.\n\n4.  **Identify Gaps**: Traverse the sorted list of energy levels. Maintain a running sum of the degeneracies, known as the cumulative occupancy ($C_k = \\sum_{i=1}^{k} g_i$). After processing each level, calculate the energy gap to the next level, $\\Delta E_k = E_{k+1} - E_k$. If this gap is greater than or equal to the specified threshold, $\\Delta_{\\mathrm{gap}} = 5\\,\\mathrm{MeV}$, then the current cumulative occupancy $C_k$ is registered as a magic number, provided it does not exceed the specified maximum of $126$.\n\nThis procedure is repeated for each value of $V_{ls}$ in the test suite $\\{0, -2.5, -5.0, -7.5, -10.0\\}\\,\\mathrm{MeV}$ to observe how the shell structure and magic numbers evolve with the strength of the spin-orbit interaction.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes nuclear magic numbers based on the independent particle model\n    with a harmonic oscillator potential and a spin-orbit term.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a single value for the spin-orbit strength V_ls in MeV.\n    test_cases = [0.0, -2.5, -5.0, -7.5, -10.0]\n\n    # Global parameters from the problem\n    HW = 10.0  # MeV, Harmonic oscillator energy scale h-bar * omega\n    DELTA_GAP = 5.0  # MeV, Threshold for identifying a magic number gap\n    N_MAX = 6  # Maximum major oscillator quantum number\n    MAX_MAGIC_NUMBER = 126  # Report magic numbers up to this value\n\n    all_results = []\n\n    for v_ls in test_cases:\n        levels = []\n        \n        # Step 1: Enumerate all single-particle states (N, l, j) and\n        # calculate their energies and degeneracies.\n        for N in range(N_MAX + 1):\n            # The allowed orbital angular momenta l have the same parity as N\n            # and satisfy l = N.\n            for l in range(N, -1, -2):\n                e_ho = HW * (N + 1.5)\n                \n                if l == 0:\n                    # For l=0, only j=1/2 is possible. The spin-orbit term is zero.\n                    j = 0.5\n                    ls_expectation = 0.0\n                    energy = e_ho + v_ls * ls_expectation\n                    degeneracy = 2 * j + 1\n                    levels.append({'energy': energy, 'degeneracy': degeneracy})\n                else:\n                    # For l > 0, two j values are possible: j = l +/- 1/2.\n                    # Case 1: j = l + 1/2 (spin-aligned)\n                    j_plus = l + 0.5\n                    ls_expectation_plus = 0.5 * l\n                    energy_plus = e_ho + v_ls * ls_expectation_plus\n                    degeneracy_plus = 2 * j_plus + 1\n                    levels.append({'energy': energy_plus, 'degeneracy': degeneracy_plus})\n\n                    # Case 2: j = l - 1/2 (spin-anti-aligned)\n                    j_minus = l - 0.5\n                    ls_expectation_minus = -0.5 * (l + 1)\n                    energy_minus = e_ho + v_ls * ls_expectation_minus\n                    degeneracy_minus = 2 * j_minus + 1\n                    levels.append({'energy': energy_minus, 'degeneracy': degeneracy_minus})\n        \n        # Step 2: Sort the levels by ascending energy to determine the filling order.\n        levels.sort(key=lambda x: x['energy'])\n\n        # Step 3: Identify magic numbers by finding large energy gaps in the sorted spectrum.\n        magic_numbers = []\n        cumulative_occupancy = 0\n        for i in range(len(levels) - 1):\n            # Accumulate the number of particles filling shells up to the current level.\n            cumulative_occupancy += levels[i]['degeneracy']\n            \n            # Calculate the energy gap to the next level.\n            energy_gap = levels[i+1]['energy'] - levels[i]['energy']\n            \n            # If the gap is significant, the cumulative occupancy is a magic number.\n            if energy_gap >= DELTA_GAP:\n                if cumulative_occupancy = MAX_MAGIC_NUMBER:\n                    magic_numbers.append(int(cumulative_occupancy))\n\n        all_results.append(magic_numbers)\n\n    # Final print statement in the exact required format.\n    # e.g., \"[[2,8,20],[2,8,20,28],...]\"\n    outer_parts = [f'[{\",\".join(map(str, sublist))}]' for sublist in all_results]\n    print(f\"[{','.join(outer_parts)}]\")\n\nsolve()\n```", "id": "3602363"}, {"introduction": "A realistic physical model is not just defined by its structure, but also by the values of its parameters, which must be constrained by experimental data. This advanced practice introduces a powerful technique from modern data science—Bayesian inference—to determine the parameters of a mean-field model. By fitting the model to a set of single-particle energies, you will not only find the most probable parameter values but also quantify their uncertainties and correlations, reflecting a more sophisticated and realistic approach to physical modeling. [@problem_id:3602413]", "problem": "Consider the Independent Particle Model (IPM), in which nucleons move in a static mean field and single-particle energy levels are characterized by quantum numbers. Let the theoretical single-particle energy for an orbit labeled by principal radial quantum number $n$, orbital angular momentum $l$, and total angular momentum $j$ be represented by a linear mean-field ansatz\n$$\nE_{\\text{th}}(n,l,j \\mid \\boldsymbol{\\theta}) \\equiv \\theta_0 + \\theta_1 K(n,l) + \\theta_2 l(l+1) + \\theta_3 \\Delta(l,j),\n$$\nwhere $K(n,l) = 2n + l$ and $\\Delta(l,j) = j(j+1) - l(l+1) - s(s+1)$ with spin $s = \\tfrac{1}{2}$. For $j = l + \\tfrac{1}{2}$ one has $\\Delta(l,j) = l$, and for $j = l - \\tfrac{1}{2}$ one has $\\Delta(l,j) = -(l+1)$.\n\nYou are to determine the Bayesian posterior for the parameter vector $\\boldsymbol{\\theta} = (\\theta_0,\\theta_1,\\theta_2,\\theta_3)^{\\mathsf{T}}$ from known single-particle energies, and then analyze the posterior correlations among the parameters. Use Bayes' theorem as your fundamental basis: posterior is proportional to likelihood times prior. Assume a Gaussian likelihood for each data point with known standard deviation and a multivariate normal prior with diagonal covariance that reflects naturalness (scales of order a few mega-electron-volts). The Independent Particle Model (IPM) hypothesis and these Gaussian assumptions are your modeling premises; you must derive and implement the resulting posterior without using any pre-specified shortcut formulas.\n\nAll energies must be handled and interpreted in mega-electron-volts (MeV). The final outputs to be printed are dimensionless Pearson correlation coefficients between selected parameter pairs, computed from the posterior covariance.\n\nData and priors are organized into three test cases. For each test case, you are given:\n- A set of orbits $(n,l,j)$ with measured energies $E_{\\text{exp}}$ and measurement standard deviations $\\sigma$ (all in $\\text{MeV}$).\n- A diagonal prior covariance specified by its component standard deviations (all in $\\text{MeV}$), and a prior mean vector.\n\nLet each observation index $i$ construct a design row via\n$$\n\\mathbf{x}_i = \\begin{bmatrix} 1  K(n_i,l_i)  l_i(l_i+1)  \\Delta(l_i,j_i) \\end{bmatrix},\n$$\nand $y_i = E_{\\text{exp},i}$. Assume observational errors are independent.\n\nYour program must:\n1. Derive and implement the closed-form Bayesian posterior for the linear-Gaussian model by starting from Bayes’ theorem and the Gaussian definitions, assembling the design matrix and weights from first principles.\n2. Compute the posterior covariance matrix $\\boldsymbol{\\Sigma}_{\\text{post}}$ and then the Pearson correlation coefficients\n$$\n\\rho_{ab} \\equiv \\frac{\\Sigma_{\\text{post},ab}}{\\sqrt{\\Sigma_{\\text{post},aa}\\,\\Sigma_{\\text{post},bb}}},\n$$\nfor the parameter index pairs $(a,b)$ in the set $\\{(0,1),(1,2),(2,3),(0,3)\\}$, corresponding to $\\{(\\theta_0,\\theta_1),(\\theta_1,\\theta_2),(\\theta_2,\\theta_3),(\\theta_0,\\theta_3)\\}$.\n\nTest suite:\n- Test Case $1$ (balanced dataset, moderate priors):\n  - Orbits and data (all energies in $\\text{MeV}$): \n    - $n=0$, $l=0$, $j=\\tfrac{1}{2}$, $E_{\\text{exp}}=-40.0$, $\\sigma=0.6$.\n    - $n=0$, $l=1$, $j=\\tfrac{3}{2}$, $E_{\\text{exp}}=-20.5$, $\\sigma=0.4$.\n    - $n=0$, $l=1$, $j=\\tfrac{1}{2}$, $E_{\\text{exp}}=-18.3$, $\\sigma=0.4$.\n    - $n=0$, $l=2$, $j=\\tfrac{5}{2}$, $E_{\\text{exp}}=-5.5$, $\\sigma=0.5$.\n    - $n=1$, $l=0$, $j=\\tfrac{1}{2}$, $E_{\\text{exp}}=-3.2$, $\\sigma=0.5$.\n    - $n=0$, $l=2$, $j=\\tfrac{3}{2}$, $E_{\\text{exp}}=-4.0$, $\\sigma=0.5$.\n  - Prior mean: $\\boldsymbol{\\mu}_0 = (0,0,0,0)^{\\mathsf{T}}$.\n  - Prior standard deviations: $(\\sigma_{\\theta_0},\\sigma_{\\theta_1},\\sigma_{\\theta_2},\\sigma_{\\theta_3}) = (20,5,2,2)$.\n\n- Test Case $2$ (same data, stronger priors):\n  - Orbits and data: identical to Test Case $1$.\n  - Prior mean: $\\boldsymbol{\\mu}_0 = (0,0,0,0)^{\\mathsf{T}}$.\n  - Prior standard deviations: $(\\sigma_{\\theta_0},\\sigma_{\\theta_1},\\sigma_{\\theta_2},\\sigma_{\\theta_3}) = (10,2,1,1)$.\n\n- Test Case $3$ (reduced spin-orbit sensitivity):\n  - Orbits and data (all energies in $\\text{MeV}$):\n    - $n=0$, $l=0$, $j=\\tfrac{1}{2}$, $E_{\\text{exp}}=-40.0$, $\\sigma=0.6$.\n    - $n=0$, $l=1$, $j=\\tfrac{3}{2}$, $E_{\\text{exp}}=-20.5$, $\\sigma=0.4$.\n    - $n=0$, $l=2$, $j=\\tfrac{5}{2}$, $E_{\\text{exp}}=-5.5$, $\\sigma=0.5$.\n  - Prior mean: $\\boldsymbol{\\mu}_0 = (0,0,0,0)^{\\mathsf{T}}$.\n  - Prior standard deviations: $(\\sigma_{\\theta_0},\\sigma_{\\theta_1},\\sigma_{\\theta_2},\\sigma_{\\theta_3}) = (20,5,2,2)$.\n\nImplementation and output requirements:\n- Implement the posterior derivation and computation using the specified assumptions without external inputs.\n- Compute the four correlation coefficients $\\rho_{01}$, $\\rho_{12}$, $\\rho_{23}$, $\\rho_{03}$ for each test case.\n- Your program should produce a single line of output containing the $12$ results (four per test case, ordered by the parameter pairs as specified, and ordered by test case $1$, then $2$, then $3$), as a comma-separated list enclosed in square brackets. For example, the output format must be of the form\n$$\n[\\rho_{01}^{(1)},\\rho_{12}^{(1)},\\rho_{23}^{(1)},\\rho_{03}^{(1)},\\rho_{01}^{(2)},\\rho_{12}^{(2)},\\rho_{23}^{(2)},\\rho_{03}^{(2)},\\rho_{01}^{(3)},\\rho_{12}^{(3)},\\rho_{23}^{(3)},\\rho_{03}^{(3)}],\n$$\nwith each number rounded to $6$ decimal places and expressed as a plain decimal (no percentage sign).", "solution": "The theoretical single-particle energy, $E_{\\text{th}}$, is given by a linear ansatz:\n$$\nE_{\\text{th}}(n,l,j \\mid \\boldsymbol{\\theta}) = \\theta_0 \\cdot 1 + \\theta_1 K(n,l) + \\theta_2 l(l+1) + \\theta_3 \\Delta(l,j)\n$$\nwhere $\\boldsymbol{\\theta} = (\\theta_0, \\theta_1, \\theta_2, \\theta_3)^{\\mathsf{T}}$ is the parameter vector. For a set of $N$ experimental observations, this can be expressed in matrix form as $\\mathbf{E}_{\\text{th}} = \\mathbf{X}\\boldsymbol{\\theta}$, where $\\mathbf{E}_{\\text{th}}$ is an $N \\times 1$ vector of theoretical energies and $\\mathbf{X}$ is the $N \\times 4$ design matrix. Each row $\\mathbf{x}_i$ of $\\mathbf{X}$ corresponds to the $i$-th observation and is constructed as:\n$$\n\\mathbf{x}_i = \\begin{bmatrix} 1  K(n_i,l_i)  l_i(l_i+1)  \\Delta(l_i,j_i) \\end{bmatrix}\n$$\nThe problem is to infer $\\boldsymbol{\\theta}$ given a vector of experimental energies $\\mathbf{Y} = (E_{\\text{exp},1}, \\dots, E_{\\text{exp},N})^{\\mathsf{T}}$.\n\nThe solution is derived from Bayes' theorem, which states that the posterior probability distribution is proportional to the product of the likelihood and the prior probability distribution:\n$$\np(\\boldsymbol{\\theta} | \\mathbf{Y}, \\mathbf{X}) \\propto p(\\mathbf{Y} | \\mathbf{X}, \\boldsymbol{\\theta}) p(\\boldsymbol{\\theta})\n$$\n\nThe specified likelihood is Gaussian. For each observation $y_i = E_{\\text{exp},i}$, the error is assumed to be normally distributed with zero mean and known standard deviation $\\sigma_i$. The model prediction for $y_i$ is $\\mathbf{x}_i \\boldsymbol{\\theta}$. Thus,\n$$\np(y_i | \\mathbf{x}_i, \\boldsymbol{\\theta}) = \\mathcal{N}(y_i | \\mathbf{x}_i \\boldsymbol{\\theta}, \\sigma_i^2) = \\frac{1}{\\sqrt{2\\pi\\sigma_i^2}} \\exp\\left( -\\frac{(y_i - \\mathbf{x}_i \\boldsymbol{\\theta})^2}{2\\sigma_i^2} \\right)\n$$\nAssuming the observational errors are independent, the likelihood for the entire dataset $\\mathbf{Y}$ is the product of individual likelihoods:\n$$\np(\\mathbf{Y} | \\mathbf{X}, \\boldsymbol{\\theta}) = \\prod_{i=1}^N p(y_i | \\mathbf{x}_i, \\boldsymbol{\\theta}) \\propto \\exp\\left( -\\frac{1}{2} \\sum_{i=1}^N \\frac{(y_i - \\mathbf{x}_i \\boldsymbol{\\theta})^2}{\\sigma_i^2} \\right)\n$$\nThis can be written in matrix form. Let $\\boldsymbol{\\Sigma}_{\\text{noise}}$ be the diagonal covariance matrix of the noise, with diagonal entries $\\sigma_i^2$. Its inverse, $\\boldsymbol{\\Sigma}_{\\text{noise}}^{-1}$, is also diagonal with entries $1/\\sigma_i^2$. The exponent is then $-\\frac{1}{2} (\\mathbf{Y} - \\mathbf{X}\\boldsymbol{\\theta})^{\\mathsf{T}} \\boldsymbol{\\Sigma}_{\\text{noise}}^{-1} (\\mathbf{Y} - \\mathbf{X}\\boldsymbol{\\theta})$.\n\nThe prior distribution for the parameters $\\boldsymbol{\\theta}$ is a multivariate normal distribution with mean $\\boldsymbol{\\mu}_0$ and diagonal covariance matrix $\\boldsymbol{\\Sigma}_0$:\n$$\np(\\boldsymbol{\\theta}) = \\mathcal{N}(\\boldsymbol{\\theta} | \\boldsymbol{\\mu}_0, \\boldsymbol{\\Sigma}_0) \\propto \\exp\\left( -\\frac{1}{2} (\\boldsymbol{\\theta} - \\boldsymbol{\\mu}_0)^{\\mathsf{T}} \\boldsymbol{\\Sigma}_0^{-1} (\\boldsymbol{\\theta} - \\boldsymbol{\\mu}_0) \\right)\n$$\n\nCombining the likelihood and prior, the posterior distribution is:\n$$\np(\\boldsymbol{\\theta} | \\mathbf{Y}, \\mathbf{X}) \\propto \\exp\\left( -\\frac{1}{2} \\left[ (\\mathbf{Y} - \\mathbf{X}\\boldsymbol{\\theta})^{\\mathsf{T}} \\boldsymbol{\\Sigma}_{\\text{noise}}^{-1} (\\mathbf{Y} - \\mathbf{X}\\boldsymbol{\\theta}) + (\\boldsymbol{\\theta} - \\boldsymbol{\\mu}_0)^{\\mathsf{T}} \\boldsymbol{\\Sigma}_0^{-1} (\\boldsymbol{\\theta} - \\boldsymbol{\\mu}_0) \\right] \\right)\n$$\nThe term in the exponent is a quadratic function of $\\boldsymbol{\\theta}$. This implies that the posterior distribution is also a multivariate normal, say $\\mathcal{N}(\\boldsymbol{\\mu}_{\\text{post}}, \\boldsymbol{\\Sigma}_{\\text{post}})$. To find its parameters, we complete the square for $\\boldsymbol{\\theta}$. The argument of the exponential, ignoring terms not dependent on $\\boldsymbol{\\theta}$, is:\n$$\n\\begin{aligned}\n-\\frac{1}{2} \\left( \\mathbf{Y}^{\\mathsf{T}}\\boldsymbol{\\Sigma}_{\\text{noise}}^{-1}\\mathbf{Y} - 2\\mathbf{Y}^{\\mathsf{T}}\\boldsymbol{\\Sigma}_{\\text{noise}}^{-1}\\mathbf{X}\\boldsymbol{\\theta} + \\boldsymbol{\\theta}^{\\mathsf{T}}\\mathbf{X}^{\\mathsf{T}}\\boldsymbol{\\Sigma}_{\\text{noise}}^{-1}\\mathbf{X}\\boldsymbol{\\theta} + \\boldsymbol{\\theta}^{\\mathsf{T}}\\boldsymbol{\\Sigma}_0^{-1}\\boldsymbol{\\theta} - 2\\boldsymbol{\\mu}_0^{\\mathsf{T}}\\boldsymbol{\\Sigma}_0^{-1}\\boldsymbol{\\theta} + \\boldsymbol{\\mu}_0^{\\mathsf{T}}\\boldsymbol{\\Sigma}_0^{-1}\\boldsymbol{\\mu}_0 \\right) \\\\\n= -\\frac{1}{2} \\left( \\boldsymbol{\\theta}^{\\mathsf{T}} ( \\mathbf{X}^{\\mathsf{T}}\\boldsymbol{\\Sigma}_{\\text{noise}}^{-1}\\mathbf{X} + \\boldsymbol{\\Sigma}_0^{-1} ) \\boldsymbol{\\theta} - 2 ( \\mathbf{Y}^{\\mathsf{T}}\\boldsymbol{\\Sigma}_{\\text{noise}}^{-1}\\mathbf{X} + \\boldsymbol{\\mu}_0^{\\mathsf{T}}\\boldsymbol{\\Sigma}_0^{-1} ) \\boldsymbol{\\theta} \\right) + \\text{const.}\n\\end{aligned}\n$$\nThe general form for a multivariate normal posterior $p(\\boldsymbol{\\theta}) \\propto \\exp(-\\frac{1}{2}(\\boldsymbol{\\theta} - \\boldsymbol{\\mu}_{\\text{post}})^{\\mathsf{T}}\\boldsymbol{\\Sigma}_{\\text{post}}^{-1}(\\boldsymbol{\\theta} - \\boldsymbol{\\mu}_{\\text{post}}))$ has an exponent which, when expanded, contains terms $-\\frac{1}{2} (\\boldsymbol{\\theta}^{\\mathsf{T}}\\boldsymbol{\\Sigma}_{\\text{post}}^{-1}\\boldsymbol{\\theta} - 2\\boldsymbol{\\mu}_{\\text{post}}^{\\mathsf{T}}\\boldsymbol{\\Sigma}_{\\text{post}}^{-1}\\boldsymbol{\\theta})$.\n\nBy comparing the quadratic and linear terms in $\\boldsymbol{\\theta}$, we identify the inverse posterior covariance and a term related to the posterior mean.\nThe quadratic term in $\\boldsymbol{\\theta}$ gives the inverse of the posterior covariance matrix, $\\boldsymbol{\\Sigma}_{\\text{post}}$:\n$$\n\\boldsymbol{\\Sigma}_{\\text{post}}^{-1} = \\mathbf{X}^{\\mathsf T}\\boldsymbol{\\Sigma}_{\\text{noise}}^{-1}\\mathbf{X} + \\boldsymbol{\\Sigma}_0^{-1}\n$$\nTherefore, the posterior covariance is:\n$$\n\\boldsymbol{\\Sigma}_{\\text{post}} = \\left( \\mathbf{X}^{\\mathsf T}\\boldsymbol{\\Sigma}_{\\text{noise}}^{-1}\\mathbf{X} + \\boldsymbol{\\Sigma}_0^{-1} \\right)^{-1}\n$$\nThe linear term in $\\boldsymbol{\\theta}$ gives the posterior mean, $\\boldsymbol{\\mu}_{\\text{post}}$:\n$$\n\\boldsymbol{\\mu}_{\\text{post}}^{\\mathsf{T}}\\boldsymbol{\\Sigma}_{\\text{post}}^{-1} = \\mathbf{Y}^{\\mathsf{T}}\\boldsymbol{\\Sigma}_{\\text{noise}}^{-1}\\mathbf{X} + \\boldsymbol{\\mu}_0^{\\mathsf{T}}\\boldsymbol{\\Sigma}_0^{-1} \\implies \\boldsymbol{\\mu}_{\\text{post}} = \\boldsymbol{\\Sigma}_{\\text{post}} ( \\mathbf{X}^{\\mathsf{T}}\\boldsymbol{\\Sigma}_{\\text{noise}}^{-1}\\mathbf{Y} + \\boldsymbol{\\Sigma}_0^{-1}\\boldsymbol{\\mu}_0 )\n$$\nWhile the posterior mean is part of the full solution, it is not required for this problem, which asks only for correlations derived from the posterior covariance matrix.\n\nThe task is to compute the Pearson correlation coefficient $\\rho_{ab}$ between parameters $\\theta_a$ and $\\theta_b$, which is defined as:\n$$\n\\rho_{ab} = \\frac{\\Sigma_{\\text{post},ab}}{\\sqrt{\\Sigma_{\\text{post},aa} \\cdot \\Sigma_{\\text{post},bb}}}\n$$\nwhere $\\Sigma_{\\text{post},ab}$ is the entry in the $a$-th row and $b$-th column of $\\boldsymbol{\\Sigma}_{\\text{post}}$ (using $0$-based indexing, $a,b \\in \\{0, 1, 2, 3\\}$).\n\nThe algorithm is as follows:\n1. For each test case, parse the set of orbits $(n_i, l_i, j_i)$, measured energies $E_{\\text{exp},i}$, and standard deviations $\\sigma_i$.\n2. Construct the $N \\times 4$ design matrix $\\mathbf{X}$. For each orbit $i$, the row vector is $[1, 2n_i+l_i, l_i(l_i+1), \\Delta(l_i,j_i)]$. The term $\\Delta(l, j)$ is $l$ if $j = l + \\frac{1}{2}$ and $-l-1$ if $j = l - \\frac{1}{2}$.\n3. Construct the diagonal $N \\times N$ inverse noise covariance matrix $\\boldsymbol{\\Sigma}_{\\text{noise}}^{-1}$, where the $i$-th diagonal element is $1/\\sigma_i^2$.\n4. Construct the diagonal $4 \\times 4$ inverse prior covariance matrix $\\boldsymbol{\\Sigma}_0^{-1}$, where the $k$-th diagonal element is $1/\\sigma_{\\theta_k}^2$, using the given prior standard deviations.\n5. Compute the posterior covariance matrix $\\boldsymbol{\\Sigma}_{\\text{post}}$ using the derived formula.\n6. From $\\boldsymbol{\\Sigma}_{\\text{post}}$, calculate the four specified correlation coefficients: $\\rho_{01}$, $\\rho_{12}$, $\\rho_{23}$, and $\\rho_{03}$.\nThis procedure is repeated for all three test cases.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Bayesian linear regression problem for three test cases\n    to find posterior parameter correlations.\n    \"\"\"\n    test_cases = [\n        {\n            \"name\": \"Test Case 1 (balanced, moderate priors)\",\n            \"data\": [\n                (0, 0, 0.5, -40.0, 0.6),\n                (0, 1, 1.5, -20.5, 0.4),\n                (0, 1, 0.5, -18.3, 0.4),\n                (0, 2, 2.5, -5.5, 0.5),\n                (1, 0, 0.5, -3.2, 0.5),\n                (0, 2, 1.5, -4.0, 0.5),\n            ],\n            \"prior_mean\": np.array([0.0, 0.0, 0.0, 0.0]),\n            \"prior_std\": np.array([20.0, 5.0, 2.0, 2.0]),\n        },\n        {\n            \"name\": \"Test Case 2 (same data, stronger priors)\",\n            \"data\": [\n                (0, 0, 0.5, -40.0, 0.6),\n                (0, 1, 1.5, -20.5, 0.4),\n                (0, 1, 0.5, -18.3, 0.4),\n                (0, 2, 2.5, -5.5, 0.5),\n                (1, 0, 0.5, -3.2, 0.5),\n                (0, 2, 1.5, -4.0, 0.5),\n            ],\n            \"prior_mean\": np.array([0.0, 0.0, 0.0, 0.0]),\n            \"prior_std\": np.array([10.0, 2.0, 1.0, 1.0]),\n        },\n        {\n            \"name\": \"Test Case 3 (reduced spin-orbit sensitivity)\",\n            \"data\": [\n                (0, 0, 0.5, -40.0, 0.6),\n                (0, 1, 1.5, -20.5, 0.4),\n                (0, 2, 2.5, -5.5, 0.5),\n            ],\n            \"prior_mean\": np.array([0.0, 0.0, 0.0, 0.0]),\n            \"prior_std\": np.array([20.0, 5.0, 2.0, 2.0]),\n        },\n    ]\n\n    all_results = []\n    \n    # Pairs of parameter indices for which to compute correlations\n    # (theta_0, theta_1), (theta_1, theta_2), (theta_2, theta_3), (theta_0, theta_3)\n    corr_pairs = [(0, 1), (1, 2), (2, 3), (0, 3)]\n\n    for case in test_cases:\n        data = case[\"data\"]\n        prior_std = case[\"prior_std\"]\n        \n        num_observations = len(data)\n        num_params = 4\n\n        # 1. Construct design matrix X\n        X = np.zeros((num_observations, num_params))\n        for i, (n, l, j, _, _) in enumerate(data):\n            K = 2 * n + l\n            l_term = l * (l + 1)\n            \n            # Delta term for spin-orbit coupling\n            if np.isclose(j, l + 0.5):\n                delta = l\n            else: # j = l - 0.5\n                delta = -(l + 1)\n            \n            X[i, :] = [1, K, l_term, delta]\n\n        # 2. Extract experimental energies and their standard deviations\n        y = np.array([d[3] for d in data])\n        sigmas = np.array([d[4] for d in data])\n\n        # 3. Construct inverse noise covariance matrix (Sigma_noise^-1)\n        sigma_noise_inv = np.diag(1.0 / (sigmas**2))\n\n        # 4. Construct inverse prior covariance matrix (Sigma_0^-1)\n        sigma_0_inv = np.diag(1.0 / (prior_std**2))\n\n        # 5. Compute posterior covariance matrix\n        # Sigma_post_inv = X^T * Sigma_noise_inv * X + Sigma_0_inv\n        X_T = X.T\n        term1 = X_T @ sigma_noise_inv @ X\n        sigma_post_inv = term1 + sigma_0_inv\n        \n        # Sigma_post = (Sigma_post_inv)^-1\n        sigma_post = np.linalg.inv(sigma_post_inv)\n        \n        # 6. Compute Pearson correlation coefficients for specified pairs\n        case_results = []\n        for a, b in corr_pairs:\n            cov_ab = sigma_post[a, b]\n            var_a = sigma_post[a, a]\n            var_b = sigma_post[b, b]\n            rho_ab = cov_ab / np.sqrt(var_a * var_b)\n            case_results.append(rho_ab)\n        \n        all_results.extend(case_results)\n\n    # Format the results for the final output string\n    # Round to 6 decimal places and join with commas\n    output_str = \",\".join([f\"{val:.6f}\" for val in all_results])\n    print(f\"[{output_str}]\")\n\nsolve()\n```", "id": "3602413"}]}