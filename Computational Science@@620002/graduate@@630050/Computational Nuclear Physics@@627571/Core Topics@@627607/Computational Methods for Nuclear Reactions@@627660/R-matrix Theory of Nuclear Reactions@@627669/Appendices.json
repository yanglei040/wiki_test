{"hands_on_practices": [{"introduction": "This problem explores a foundational concept of R-matrix theory: the distinction between unphysical model parameters and physical observables. The channel radius $a$ is a key parameter that defines the boundary between the internal and external regions, yet its value is not fixed by physics. This exercise [@problem_id:421956] challenges you to demonstrate how other model parameters, like the distant-level background $R^\\infty$, must be adjusted to ensure that a physical quantity like the scattering length remains invariant, providing insight into the internal consistency of the theory.", "problem": "In the Wigner-Eisenbud R-matrix theory of nuclear reactions, physical observables are connected to the properties of the compound nucleus within a defined channel radius, $a$. For low-energy s-wave ($l=0$) neutron scattering in a single channel, the scattering phase shift $\\delta_0$ is related to the energy-dependent R-matrix, $R_0(E)$. In the limit of zero kinetic energy ($E \\to 0$), this relationship can be used to define the s-wave scattering length, $a_s$, which is a key physical observable. The relationship is given by:\n$$a_s = a(1 - R_0(0))$$\nwhere $R_0(0)$ is the R-matrix evaluated at zero energy.\n\nIn many practical applications, the R-matrix is approximated by summing over a few nearby resonance levels and adding a background term, $R^\\infty$, to account for the collective effect of all distant levels. In a situation where there are no prominent low-energy resonances, the R-matrix can be approximated solely by this background term, i.e., $R_0(0) \\approx R^\\infty$.\n\nThe channel radius $a$ is, to some extent, an arbitrary parameter of the model. The physical scattering length $a_s$, however, must be independent of the choice of $a$. This implies that if we change the channel radius, the parameters of the R-matrix model must be adjusted to keep the physical observables invariant.\n\nSuppose the channel radius is changed by a small amount from $a$ to $a+\\delta a$. To ensure the scattering length $a_s$ remains constant, the distant-level parameter $R^\\infty$ must be adjusted by a corresponding amount $\\delta R^\\infty$. Assuming $\\delta a$ is infinitesimal, find an expression for the required change $\\delta R^\\infty$ in terms of the initial parameters $a$, $R^\\infty$, and the change $\\delta a$.", "solution": "The problem requires us to find the change $\\delta R^\\infty$ needed to keep the s-wave scattering length $a_s$ invariant under a small change $\\delta a$ in the channel radius.\n\n1.  **State the Invariance Principle and the Governing Equation.**\n    The physical s-wave scattering length $a_s$ must be independent of the choice of the unphysical channel radius $a$. The relationship between these quantities, within the given model, is:\n    $$a_s = a(1 - R^\\infty)$$\n    where we have used the approximation $R_0(0) \\approx R^\\infty$.\n\n2.  **Introduce the Perturbation.**\n    We consider a change in the channel radius from its initial value $a$ to a new value $a' = a + \\delta a$. To maintain the invariance of $a_s$, the distant-level parameter $R^\\infty$ must change from its initial value to a new value $R'^\\infty = R^\\infty + \\delta R^\\infty$.\n\n3.  **Set up the Invariance Condition.**\n    The scattering length calculated with the new parameters must be equal to the original scattering length. Let the original scattering length be $a_s$ and the new one be $a_s'$. The condition is $a_s' = a_s$.\n    Using the governing equation for both the initial and final states, we have:\n    $$a'(1 - R'^\\infty) = a(1 - R^\\infty)$$\n    Substituting the expressions for $a'$ and $R'^\\infty$:\n    $$(a + \\delta a)(1 - (R^\\infty + \\delta R^\\infty)) = a(1 - R^\\infty)$$\n\n4.  **Expand the Equation.**\n    We expand the left-hand side of the equation:\n    $$(a + \\delta a)(1 - R^\\infty - \\delta R^\\infty) = a(1 - R^\\infty - \\delta R^\\infty) + \\delta a(1 - R^\\infty - \\delta R^\\infty)$$\n    $$= a - a R^\\infty - a \\delta R^\\infty + \\delta a - \\delta a R^\\infty - \\delta a \\delta R^\\infty$$\n\n5.  **Apply the First-Order Approximation.**\n    The problem specifies that the change $\\delta a$ is infinitesimal. Consequently, the induced change $\\delta R^\\infty$ will also be infinitesimal. The product of two infinitesimal quantities, $\\delta a \\delta R^\\infty$, is of second order and can be neglected in a first-order analysis.\n    The expanded equation becomes:\n    $$a(1 - R^\\infty) - a \\delta R^\\infty + \\delta a (1 - R^\\infty) \\approx a(1 - R^\\infty)$$\n\n6.  **Solve for the Change $\\delta R^\\infty$.**\n    We can cancel the term $a(1 - R^\\infty)$ from both sides of the approximation:\n    $$-a \\delta R^\\infty + \\delta a (1 - R^\\infty) \\approx 0$$\n    Rearranging the terms to solve for $\\delta R^\\infty$:\n    $$a \\delta R^\\infty \\approx \\delta a (1 - R^\\infty)$$\n    Finally, dividing by $a$ (assuming $a \\neq 0$), we obtain the expression for the required change in the distant-level parameter:\n    $$\\delta R^\\infty = \\frac{1 - R^\\infty}{a} \\delta a$$\n    This expression represents the first-order correction to $R^\\infty$ necessary to preserve the physical scattering length when the channel radius is infinitesimally varied.", "answer": "$$ \\boxed{\\frac{(1 - R^\\infty) \\delta a}{a}} $$", "id": "421956"}, {"introduction": "Practical applications of R-matrix theory hinge on the numerical inversion of the level matrix, $A(E)$. This matrix can become nearly singular, particularly at energies close to a resonance, leading to severe numerical instability and unreliable results. This hands-on coding practice [@problem_id:3585517] guides you through implementing and comparing a naive inversion with a robust, industry-standard stabilization technique using matrix scaling and Singular Value Decomposition (SVD), a vital skill for any practitioner in computational nuclear physics.", "problem": "Consider the multi-level, multi-channel Wigner–Eisenbud $R$-matrix representation of nuclear reactions. The level matrix $A_{\\lambda\\lambda'}(E)$ for $N_\\lambda$ compound-nucleus levels coupled to $N_c$ open channels is defined by the following ingredients:\n\n1. A set of real level energies $E_\\lambda$ in megaelectronvolts (MeV).\n2. Real reduced-width amplitudes $\\gamma_{\\lambda c}$ with units of the square root of energy, specifically $\\sqrt{\\text{MeV}}$, for each level $\\lambda$ and channel $c$.\n3. Real channel boundary-condition constants $B_c$ (dimensionless).\n4. Complex channel functions $L_c(E)$ (dimensionless), with $L_c(E) = S_c(E) + i P_c(E)$, where $S_c(E)$ is the real shift function and $P_c(E)$ is the real penetration factor. In this problem, assume neutral $s$-wave channels with a hard-sphere boundary, so $S_c(E) = 0$ and $P_c(E) = \\rho_c(E)$ with $\\rho_c(E) = k_c(E) a_c$, channel radius $a_c$ in femtometers (fm), reduced mass $\\mu_c$ in megaelectronvolts (MeV) understood as $\\mu_c c^2$, and wave number $k_c(E)$ given by $k_c(E) = \\sqrt{2 \\mu_c E}/(\\hbar c)$. Use $\\hbar c = 197.3269804\\,\\text{MeV}\\cdot\\text{fm}$.\n\nUnder these assumptions, the level matrix is\n$$\nA_{\\lambda\\lambda'}(E) = (E_\\lambda - E)\\,\\delta_{\\lambda\\lambda'} - \\sum_{c=1}^{N_c} \\gamma_{\\lambda c}\\,\\big[L_c(E) - B_c\\big]\\,\\gamma_{\\lambda' c},\n$$\nwhich is generally complex and energy-dependent.\n\nFrom the Wigner–Eisenbud construction, the channel–channel $R$-matrix $R_{cc'}(E)$ is obtained by\n$$\nR_{cc'}(E) = \\sum_{\\lambda=1}^{N_\\lambda}\\sum_{\\lambda'=1}^{N_\\lambda} \\gamma_{\\lambda c}\\,\\big[A^{-1}(E)\\big]_{\\lambda\\lambda'}\\,\\gamma_{\\lambda' c'}.\n$$\nUnder the same hard-sphere simplification with zero hard-sphere phase, the collision (scattering) matrix $U_{cc'}(E)$ is\n$$\nU(E) = I - 2 i\\,P(E)^{1/2}\\,R(E)\\,P(E)^{1/2},\n$$\nwhere $P(E) = \\operatorname{diag}\\big(P_1(E),\\dots,P_{N_c}(E)\\big)$ and $I$ is the $N_c\\times N_c$ identity matrix. The matrix $U(E)$ should be approximately unitary when the model assumptions are satisfied and numerical errors are controlled.\n\nThe inversion of $A(E)$ can be ill-conditioned, especially near resonances where $E \\approx E_\\lambda$ or when reduced-width amplitudes span several orders of magnitude. To improve conditioning, implement a diagonal scaling and a singular value decomposition (SVD) pseudoinverse. Specifically:\n\n1. Construct $A(E)$ from the given inputs.\n2. Compute a naive inverse of $A(E)$ via direct dense inversion when possible.\n3. Compute a scaled-SVD pseudoinverse of $A(E)$:\n   (a) Define a real, positive diagonal scaling matrix $S(E) = \\operatorname{diag}(s_1,\\dots,s_{N_\\lambda})$ with\n   $$\n   s_\\lambda = \\left(|E_\\lambda - E|^2 + \\sum_{c=1}^{N_c} |\\gamma_{\\lambda c}|^2\\,\\big|L_c(E) - B_c\\big|^2\\right)^{-1/2}.\n   $$\n   (b) Form the scaled matrix $A_s(E) = S(E)\\,A(E)\\,S(E)$.\n   (c) Compute the SVD $A_s(E) = U \\Sigma V^\\dagger$ with non-negative singular values $\\sigma_i$ on the diagonal of $\\Sigma$.\n   (d) Form a truncated pseudoinverse $\\Sigma^+$ by replacing each $\\sigma_i$ with $\\sigma_i^{-1}$ if $\\sigma_i \\ge \\tau$, and $0$ otherwise, with a tolerance $\\tau = \\epsilon\\,\\sigma_{\\max}\\,N_\\lambda$, where $\\epsilon$ is machine epsilon for double precision.\n   (e) Set $A_s^+(E) = V\\,\\Sigma^+ U^\\dagger$ and unscale to obtain $A^+(E) \\approx S(E)\\,A_s^+(E)\\,S(E)$ as a stabilized approximation to $A^{-1}(E)$.\n4. Compute $R(E)$ and two versions of $U(E)$: $U_{\\text{naive}}(E)$ from the naive inverse and $U_{\\text{svd}}(E)$ from the scaled-SVD pseudoinverse.\n5. Assess the numerical impact on $U(E)$ using the following diagnostics:\n   (a) The condition number of $A(E)$, defined by $\\kappa\\big(A(E)\\big) = \\sigma_{\\max}/\\sigma_{\\min}$ from the SVD of $A(E)$, with the convention $\\kappa = 10^{18}$ when $\\sigma_{\\min}$ is numerically zero.\n   (b) The condition number of the scaled matrix $A_s(E)$ defined similarly.\n   (c) The deviation from unitarity of $U_{\\text{naive}}(E)$ and $U_{\\text{svd}}(E)$ measured by the Frobenius norm $\\|U^\\dagger U - I\\|_F$.\n   (d) The Frobenius norm $\\|U_{\\text{naive}}(E) - U_{\\text{svd}}(E)\\|_F$.\n\nAll energies must be handled in megaelectronvolts (MeV), masses $\\mu_c$ in MeV (interpreted as $\\mu_c c^2$), and radii $a_c$ in femtometers (fm). Angles do not appear; there is no angle unit to specify. The outputs are dimensionless floats.\n\nImplement a program that computes these quantities for the following fixed data and test suite. Use $N_\\lambda = 3$ levels and $N_c = 2$ channels with the default parameters unless a test case overrides them:\n\n- Levels: $E_\\lambda = [0.30,\\,1.10,\\,2.00]\\,\\text{MeV}$.\n- Reduced masses: $\\mu_1 = 469.0\\,\\text{MeV}$, $\\mu_2 = 931.5\\,\\text{MeV}$.\n- Channel radii: $a_1 = 5.0\\,\\text{fm}$, $a_2 = 5.5\\,\\text{fm}$.\n- Boundary constants: $B_1 = 0.0$, $B_2 = 0.0$.\n- Reduced-width amplitudes in $\\sqrt{\\text{MeV}}$:\n  $$\n  \\gamma = \\begin{bmatrix}\n  0.050 & 0.030\\\\\n  0.020 & 0.040\\\\\n  0.010 & 0.025\n  \\end{bmatrix}.\n  $$\n\nTest suite (each case specifies the energy $E$ in MeV and any overrides):\n\n1. Case 1 (near resonance, default $B_c$ and $\\gamma$): $E = 1.10$.\n2. Case 2 (near threshold, default $B_c$ and $\\gamma$): $E = 0.001$.\n3. Case 3 (higher energy, default $B_c$ and $\\gamma$): $E = 2.00$.\n4. Case 4 (non-zero boundary conditions): $E = 1.10$, $B_1 = 0.30$, $B_2 = -0.20$.\n5. Case 5 (ill-conditioned widths): $E = 1.10$, override\n   $$\n   \\gamma = \\begin{bmatrix}\n   0.0001 & 0.0001\\\\\n   0.2000 & 0.2500\\\\\n   0.0001 & 0.0001\n   \\end{bmatrix}.\n   $$\n\nYour program should produce a single line of output containing the results as a comma-separated list of lists enclosed in square brackets. For each test case, output a list of five floats in the following order:\n$[\\kappa(A),\\,\\kappa(A_s),\\,\\|U_{\\text{naive}}^\\dagger U_{\\text{naive}} - I\\|_F,\\,\\|U_{\\text{svd}}^\\dagger U_{\\text{svd}} - I\\|_F,\\,\\|U_{\\text{naive}} - U_{\\text{svd}}\\|_F]$.\n\nFormat example (with placeholders): \"[[condA1,condAs1,unitNaive1,unitSvd1,diff1],[condA2,condAs2,unitNaive2,unitSvd2,diff2],...]\".", "solution": "The problem statement is critically validated and determined to be valid. It is scientifically grounded in the Wigner-Eisenbud R-matrix theory of nuclear reactions, a well-established formalism in computational nuclear physics. The problem is well-posed, providing a complete and consistent set of definitions, parameters, and equations necessary for a unique numerical solution. The language is objective and precise, and the proposed task—comparing a naive matrix inversion with a stabilized SVD-based pseudoinverse—is a standard and meaningful exercise in numerical analysis applied to physics.\n\nThe solution proceeds by implementing the specified calculations in a step-by-step manner for each test case provided.\n\n**1. R-Matrix Formalism Setup**\nThe calculation begins by defining the energy-dependent quantities for the given $N_c=2$ channels at a specified incident energy $E$. For neutral $s$-wave scattering, the shift function $S_c(E)$ is zero, and the penetration factor $P_c(E)$ is given by $\\rho_c(E) = k_c(E) a_c$. The wave number $k_c(E)$ is calculated using the non-relativistic kinetic energy expression adapted for MeV units:\n$$k_c(E) = \\frac{\\sqrt{2 \\mu_c E}}{\\hbar c}$$\nwhere $\\mu_c$ is the reduced mass in MeV (as $\\mu_c c^2$) and the constant $\\hbar c = 197.3269804\\,\\text{MeV}\\cdot\\text{fm}$. The complex channel function $L_c(E)$ therefore simplifies to $L_c(E) = S_c(E) + i P_c(E) = i P_c(E)$. These quantities are computed for each open channel.\n\n**2. Level Matrix Construction**\nThe $N_\\lambda \\times N_\\lambda$ (in this problem, $3 \\times 3$) complex level matrix $A(E)$ is constructed. Its elements are given by the formula:\n$$A_{\\lambda\\lambda'}(E) = (E_\\lambda - E)\\,\\delta_{\\lambda\\lambda'} - \\sum_{c=1}^{N_c} \\gamma_{\\lambda c}\\,\\gamma_{\\lambda' c}\\,\\big[L_c(E) - B_c\\big]$$\nIn matrix notation, this is expressed as $A(E) = \\operatorname{diag}(E_\\lambda - E) - \\gamma D(E) \\gamma^T$, where $\\gamma$ is the $N_\\lambda \\times N_c$ matrix of reduced-width amplitudes and $D(E)$ is a diagonal $N_c \\times N_c$ matrix with elements $L_c(E) - B_c$. This matrix is complex and symmetric, but not necessarily Hermitian. The term $(E_\\lambda - E)$ on the diagonal can become zero if the energy $E$ matches a level energy $E_\\lambda$, which is a primary source of ill-conditioning.\n\n**3. Naive Inversion and Collision Matrix**\nThe first approach is to compute the inverse of $A(E)$ directly using a standard linear algebra library function.\n$$A^{-1}_{\\text{naive}}(E) = \\operatorname{inv}\\big(A(E)\\big)$$\nThe channel-channel R-matrix $R_{cc'}$ is then computed via matrix multiplication:\n$$R_{\\text{naive}}(E) = \\gamma^T A^{-1}_{\\text{naive}}(E) \\gamma$$\nFinally, the naive collision matrix $U_{\\text{naive}}(E)$ is calculated according to the problem's hard-sphere formula:\n$$U_{\\text{naive}}(E) = I - 2 i\\,P(E)^{1/2}\\,R_{\\text{naive}}(E)\\,P(E)^{1/2}$$\nwhere $I$ is the $N_c \\times N_c$ identity matrix and $P(E)^{1/2}$ is the diagonal matrix with elements $\\sqrt{P_c(E)}$.\n\n**4. Scaled SVD Pseudoinverse Stabilization**\nThe second, more numerically robust method involves several steps to stabilize the inversion of $A(E)$.\n(a) **Scaling**: A diagonal scaling matrix $S(E) = \\operatorname{diag}(s_1, \\dots, s_{N_\\lambda})$ is introduced to precondition the level matrix. The scaling factors are defined to approximately normalize the rows of $A(E)$:\n$$s_\\lambda = \\left(|E_\\lambda - E|^2 + \\sum_{c=1}^{N_c} |\\gamma_{\\lambda c}|^2\\,\\big|L_c(E) - B_c\\big|^2\\right)^{-1/2}$$\nThis results in a real, positive, diagonal matrix $S(E)$.\n(b) **Scaled Matrix**: The original matrix is symmetrically scaled to balance the magnitudes of its elements:\n$$A_s(E) = S(E)\\,A(E)\\,S(E)$$\nThis scaling is designed to improve the condition number of the matrix prior to inversion.\n(c) **SVD**: The singular value decomposition of the scaled matrix $A_s(E)$ is computed:\n$$A_s(E) = U \\Sigma V^\\dagger$$\n(d) **Truncated Pseudoinverse**: A pseudoinverse of the singular value matrix, $\\Sigma^+$, is formed. Singular values $\\sigma_i$ below a certain tolerance $\\tau$ are treated as zero to filter out numerical noise arising from ill-conditioning. The tolerance is defined relative to the largest singular value $\\sigma_{\\max}$ to adapt to the matrix's scale:\n$$\\tau = \\epsilon\\,\\sigma_{\\max}\\,N_\\lambda$$\nwhere $\\epsilon$ is machine epsilon for double-precision floating-point numbers. The diagonal elements of $\\Sigma^+$ are set to $\\sigma_i^{-1}$ if $\\sigma_i \\ge \\tau$, and $0$ otherwise.\n(e) **Unscaling**: The pseudoinverse of the scaled matrix, $A_s^+(E) = V \\Sigma^+ U^\\dagger$, is computed. This is then unscaled to obtain the stabilized pseudoinverse of the original level matrix:\n$$A^+(E) = S(E)\\,A_s^+(E)\\,S(E)$$\n\n**5. SVD-based Collision Matrix**\nUsing this stabilized pseudoinverse $A^+(E)$, the corresponding R-matrix and collision matrix are calculated analogously to the naive case:\n$$R_{\\text{svd}}(E) = \\gamma^T A^+(E) \\gamma$$\n$$U_{\\text{svd}}(E) = I - 2 i\\,P(E)^{1/2}\\,R_{\\text{svd}}(E)\\,P(E)^{1/2}$$\n\n**6. Numerical Diagnostics**\nTo compare the two methods, five diagnostics are computed for each test case:\n- **Condition Numbers**: $\\kappa(A)$ and $\\kappa(A_s)$, calculated as the ratio $\\sigma_{\\max}/\\sigma_{\\min}$ from the SVD of the respective matrices. A value of $10^{18}$ is assigned if $\\sigma_{\\min}$ is numerically indistinguishable from zero, signifying singularity or extreme ill-conditioning.\n- **Unitarity Deviation**: The deviation of $U$ from a unitary matrix is quantified by the Frobenius norm $\\|U^\\dagger U - I\\|_F$ for both $U_{\\text{naive}}$ and $U_{\\text{svd}}$. For a complete model space, $U$ should be unitary; deviation from this property highlights numerical errors.\n- **Method Difference**: The Frobenius norm of the difference, $\\|U_{\\text{naive}} - U_{\\text{svd}}\\|_F$, measures how much the stabilization procedure alters the final physical observable. A large difference suggests that the naive method is producing unreliable results.\n\nThe algorithm is applied to each of the five test cases, and the resulting set of five diagnostic values for each case is collected and formatted into the required output structure.", "answer": "```python\nimport numpy as np\n\n# A meticulous and exacting professor in the STEM fields.\n\ndef solve():\n    \"\"\"\n    Main function to run the R-matrix calculations for all test cases.\n    \"\"\"\n    # Global constants for the calculation\n    HBARC = 197.3269804  # MeV*fm\n    MACHINE_EPSILON = np.finfo(np.float64).eps\n    ILL_COND_THRESHOLD = 1e-18  # Threshold to declare a matrix singular for condition number\n\n    # Default parameters as specified in the problem\n    DEFAULT_E_LAMBDA = np.array([0.30, 1.10, 2.00])\n    DEFAULT_MU_C = np.array([469.0, 931.5])  # in MeV\n    DEFAULT_A_C = np.array([5.0, 5.5])  # in fm\n    DEFAULT_B_C = np.array([0.0, 0.0])\n    DEFAULT_GAMMA = np.array([\n        [0.050, 0.030],\n        [0.020, 0.040],\n        [0.010, 0.025]\n    ])  # in sqrt(MeV)\n\n    def calculate_diagnostics(E, E_lambda, mu_c, a_c, B_c, gamma):\n        \"\"\"\n        Performs the R-matrix calculations for a given set of parameters.\n        \"\"\"\n        N_lambda = len(E_lambda)\n        N_c = len(mu_c)\n\n        if E < 0:\n            raise ValueError(\"Energy E must be non-negative.\")\n        \n        # Step A: Calculate channel-dependent quantities\n        k_c = np.sqrt(2 * mu_c * E) / HBARC\n        P_c = k_c * a_c\n        L_c = 1j * P_c  # S_c(E) = 0 for simplified hard-sphere channels\n\n        # Step B: Construct the level matrix A(E)\n        A = np.diag(E_lambda - E).astype(np.complex128)\n        for c in range(N_c):\n            gamma_c = gamma[:, c:c+1]\n            A -= (gamma_c @ gamma_c.T) * (L_c[c] - B_c[c])\n\n        # Step C: Compute diagnostics for A(E)\n        s_A = np.linalg.svd(A, compute_uv=False)\n        sigma_max_A = np.max(s_A) if s_A.size > 0 else 0\n        sigma_min_A = np.min(s_A) if s_A.size > 0 else 0\n        \n        if sigma_min_A < ILL_COND_THRESHOLD:\n            kappa_A = 1e18\n        else:\n            kappa_A = sigma_max_A / sigma_min_A\n\n        # Step D: Naive inversion and collision matrix\n        try:\n            A_inv_naive = np.linalg.inv(A)\n            R_naive = gamma.T @ A_inv_naive @ gamma\n            P_sqrt_mat = np.diag(np.sqrt(P_c))\n            U_naive = np.eye(N_c, dtype=np.complex128) - 2j * (P_sqrt_mat @ R_naive @ P_sqrt_mat)\n            unitarity_naive = np.linalg.norm(U_naive.conj().T @ U_naive - np.eye(N_c), 'fro')\n        except np.linalg.LinAlgError:\n            U_naive = np.full((N_c, N_c), np.nan, dtype=np.complex128)\n            unitarity_naive = np.inf\n\n        # Step E: Scaled SVD pseudoinverse\n        # (a) Define scaling matrix S\n        s_lambda = np.zeros(N_lambda)\n        for l_idx in range(N_lambda):\n            term1_sq = (E_lambda[l_idx] - E)**2\n            term2 = sum(gamma[l_idx, c_idx]**2 * (B_c[c_idx]**2 + P_c[c_idx]**2) for c_idx in range(N_c))\n            s_lambda[l_idx] = 1.0 / np.sqrt(term1_sq + term2)\n        S_mat = np.diag(s_lambda)\n        \n        # (b) Form scaled matrix A_s\n        A_s = S_mat @ A @ S_mat\n        \n        # (c) Compute SVD of A_s and its condition number\n        U_s, s_s, Vh_s = np.linalg.svd(A_s)\n        sigma_max_As = np.max(s_s) if s_s.size > 0 else 0\n        sigma_min_As = np.min(s_s) if s_s.size > 0 else 0\n        \n        if sigma_min_As < ILL_COND_THRESHOLD:\n            kappa_As = 1e18\n        else:\n            kappa_As = sigma_max_As / sigma_min_As\n\n        # (d) Form truncated pseudoinverse of singular values\n        tau = MACHINE_EPSILON * sigma_max_As * N_lambda\n        s_plus_diag_vals = np.array([1/s if s >= tau else 0 for s in s_s])\n        Sigma_plus = np.diag(s_plus_diag_vals)\n\n        # (e) Compute pseudoinverse A_plus\n        As_plus = Vh_s.conj().T @ Sigma_plus @ U_s.conj().T\n        A_plus = S_mat @ As_plus @ S_mat\n\n        # Step F: Calculate R_svd and U_svd\n        R_svd = gamma.T @ A_plus @ gamma\n        P_sqrt_mat = np.diag(np.sqrt(P_c))\n        U_svd = np.eye(N_c, dtype=np.complex128) - 2j * (P_sqrt_mat @ R_svd @ P_sqrt_mat)\n\n        # Step G: Compute final diagnostics\n        unitarity_svd = np.linalg.norm(U_svd.conj().T @ U_svd - np.eye(N_c), 'fro')\n        diff_U = np.linalg.norm(U_naive - U_svd, 'fro') if not np.any(np.isnan(U_naive)) else np.inf\n\n        return [kappa_A, kappa_As, unitarity_naive, unitarity_svd, diff_U]\n\n    test_cases = [\n        # Case 1: E on a resonance, default params\n        {'E': 1.10, 'B_c': DEFAULT_B_C, 'gamma': DEFAULT_GAMMA},\n        # Case 2: Near threshold, default params\n        {'E': 0.001, 'B_c': DEFAULT_B_C, 'gamma': DEFAULT_GAMMA},\n        # Case 3: E on another resonance, default params\n        {'E': 2.00, 'B_c': DEFAULT_B_C, 'gamma': DEFAULT_GAMMA},\n        # Case 4: Non-zero boundary conditions\n        {'E': 1.10, 'B_c': np.array([0.30, -0.20]), 'gamma': DEFAULT_GAMMA},\n        # Case 5: Ill-conditioned widths\n        {'E': 1.10, 'B_c': DEFAULT_B_C, 'gamma': np.array([\n            [0.0001, 0.0001],\n            [0.2000, 0.2500],\n            [0.0001, 0.0001]\n        ])}\n    ]\n\n    results = []\n    for case in test_cases:\n        res = calculate_diagnostics(\n            case['E'],\n            DEFAULT_E_LAMBDA,\n            DEFAULT_MU_C,\n            DEFAULT_A_C,\n            case['B_c'],\n            case['gamma']\n        )\n        results.append(res)\n    \n    # Format the final output string exactly as specified, without spaces\n    print(str(results).replace(' ', ''))\n\nsolve()\n```", "id": "3585517"}, {"introduction": "Beyond stability, computational efficiency is paramount in modern R-matrix analyses, which can involve thousands of resonance levels. Direct inversion of the level matrix scales poorly with the number of levels. This advanced exercise [@problem_id:3585560] tasks you with exploiting the underlying low-rank structure of the channel-coupling term to derive and implement a highly efficient inversion method based on the Sherman-Morrison-Woodbury formula, demonstrating how a deeper mathematical understanding leads to powerful computational speed-ups.", "problem": "Consider a many-level, few-channel formulation of the R-matrix theory of nuclear reactions where the level matrix depends on the energy $E$ and the coupling vectors. In the Wigner–Eisenbud formalism with channel boundary conditions chosen so that the boundary constant equals the shift function, the level matrix can be written as\n$$\nA(E) = D(E) + U\\,W(E)\\,U^{\\mathsf T},\n$$\nwhere $D(E)$ is a diagonal matrix of size $N \\times N$ with entries $d_\\lambda(E) = E_\\lambda - E$ for each level index $\\lambda = 1,\\dots,N$, $U$ is the $N \\times C$ matrix whose columns are the level-to-channel reduced width amplitude vectors $\\gamma_c$ for channel indices $c = 1,\\dots,C$, and $W(E)$ is a diagonal $C \\times C$ matrix with entries $w_c(E) = i\\,P_c(E)$, with $i$ the imaginary unit and $P_c(E)$ the penetration factor of channel $c$ at energy $E$. This structure reflects the low-rank property of the coupling term because $U\\,W(E)\\,U^{\\mathsf T}$ has rank at most $C$ even when $N \\gg C$.\n\nFor the single-channel neutral $s$-wave case, the penetration factor can be modeled as $P(E) = k(E)\\,a$, where $k(E) = \\sqrt{2\\,\\mu\\,E}/\\hbar$ is the wave number, $\\mu$ is the reduced mass, $a$ is the channel radius, and $\\hbar$ is the reduced Planck constant. Using the conventional units for computational nuclear physics, take $\\hbar c = 197.3269804$ MeV·fm, so that $k(E)$ can be computed from $E$ in mega-electron-volts (MeV), $\\mu$ in MeV$/c^2$, and $a$ in femtometers (fm), yielding a dimensionless penetration factor $P(E)$. For multi-channel cases, define a distinct $P_c(E) = k_c(E)\\,a_c$ per channel with corresponding $\\mu_c$ and $a_c$.\n\nThe channel-channel R-matrix is defined by\n$$\nR(E) = U^{\\mathsf T}\\,A(E)^{-1}\\,U,\n$$\nwhich is a $C \\times C$ complex symmetric matrix. With the boundary constant equal to the shift function (so the real dispersive shift is absorbed), the collision matrix (also known as the scattering matrix) reduces to\n$$\nU(E) = I_C - 2i\\,P(E)^{1/2}\\,R(E)\\,P(E)^{1/2},\n$$\nwhere $I_C$ is the $C \\times C$ identity matrix and $P(E)^{1/2}$ is the diagonal matrix with entries $\\sqrt{P_c(E)}$. This $U(E)$ is unitary in the ideal mathematical model.\n\nYour task is to design and implement a program that, for a specified set of level energies $E_\\lambda$, reduced width amplitudes in $U$, and channel parameters $(\\mu_c, a_c)$, computes $U(E)$ across several energies using two inversion strategies for $A(E)$:\n- A direct dense inversion of $A(E)$.\n- An inversion update that leverages the low-rank structure of $U\\,W(E)\\,U^{\\mathsf T}$ starting from $D(E)$ and applying a principled matrix identity to avoid inverting the full $N \\times N$ matrix.\n\nYou must:\n1. Start from foundational linear algebra and R-matrix definitions and derive, implement, and use the efficient inverse update mathematically guaranteed for low-rank modifications to a diagonal matrix without relying on any pre-stated shortcut formulas.\n2. Compute the collision matrix $U(E)$ using both inversions for each energy and quantify the numerical error as the maximum absolute entrywise difference between the two $U(E)$ matrices for each energy.\n3. Aggregate the error per test case as the maximum over the specified energy set.\n4. Express all energies in mega-electron-volts (MeV), masses in mega-electron-volts per speed of light squared (MeV$/c^2$), radii in femtometers (fm), and report the final errors as dimensionless floats.\n5. Ensure numerical stability by avoiding energies that make any diagonal entry of $D(E)$ exactly zero.\n\nTest Suite and Parameters:\n- Case 1 (single channel, off- and near-resonance, neutral $s$-wave):\n  - Levels: $N=3$, with $E_\\lambda = [0.2,\\,1.0,\\,3.0]$ MeV.\n  - Reduced mass: $\\mu = 469.5$ MeV$/c^2$.\n  - Channel radius: $a = 5.0$ fm.\n  - Reduced width amplitudes: $\\gamma = [0.06,\\,0.02,\\,0.01]$ in $\\sqrt{\\text{MeV}}$.\n  - Energies: $E = [0.05,\\,0.1999,\\,0.5,\\,1.0]$ MeV.\n- Case 2 (single channel, near threshold):\n  - Levels: $N=5$, with $E_\\lambda = [0.01,\\,0.5,\\,1.5,\\,2.5,\\,4.0]$ MeV.\n  - Reduced mass: $\\mu = 469.5$ MeV$/c^2$.\n  - Channel radius: $a = 5.0$ fm.\n  - Reduced width amplitudes: $\\gamma = [0.03,\\,0.015,\\,0.008,\\,0.004,\\,0.002]$ in $\\sqrt{\\text{MeV}}$.\n  - Energies: $E = [10^{-6},\\,10^{-4},\\,10^{-2}]$ MeV.\n- Case 3 (two channels, multi-level):\n  - Levels: $N=4$, with $E_\\lambda = [0.4,\\,0.8,\\,1.6,\\,2.8]$ MeV.\n  - Channel 1: $\\mu_1 = 469.5$ MeV$/c^2$, $a_1 = 4.5$ fm, reduced width amplitudes $\\gamma_1 = [0.05,\\,0.02,\\,0.03,\\,0.01]$ in $\\sqrt{\\text{MeV}}$.\n  - Channel 2: $\\mu_2 = 300.0$ MeV$/c^2$, $a_2 = 6.0$ fm, reduced width amplitudes $\\gamma_2 = [0.04,\\,0.015,\\,0.02,\\,0.008]$ in $\\sqrt{\\text{MeV}}$.\n  - Energies: $E = [0.3,\\,0.8,\\,1.6,\\,2.5]$ MeV.\n- Case 4 (single channel, ill-conditioned near resonance):\n  - Levels: $N=3$, with $E_\\lambda = [1.0000,\\,1.5000,\\,2.0000]$ MeV.\n  - Reduced mass: $\\mu = 469.5$ MeV$/c^2$.\n  - Channel radius: $a = 5.0$ fm.\n  - Reduced width amplitudes: $\\gamma = [0.10,\\,0.05,\\,0.02]$ in $\\sqrt{\\text{MeV}}$.\n  - Energies: $E = [0.9999,\\,1.0001,\\,1.2]$ MeV.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[r_1,r_2,r_3,r_4]$), where each $r_j$ is the maximum absolute entrywise difference between the two computed collision matrices $U(E)$ across the energies for the $j$-th case, reported as a float in a dimensionless unit.", "solution": "The problem requires the computation of the nuclear collision matrix, denoted $U(E)$, using two distinct computational strategies for inverting the level matrix $A(E)$. The results from these two methods, direct inversion and an efficient low-rank update, will be compared to quantify the numerical error. The theoretical foundation is the R-matrix theory of nuclear reactions.\n\n### Theoretical Framework\n\nThe problem is situated within the Wigner–Eisenbud formulation of R-matrix theory. The key quantities are defined as follows:\n\n1.  **Level Matrix, $A(E)$**: An $N \\times N$ complex matrix, where $N$ is the number of included resonance levels.\n    $$A(E) = D(E) + U\\,W(E)\\,U^{\\mathsf T}$$\n    -   $D(E)$ is a diagonal matrix with entries $d_\\lambda(E) = E_\\lambda - E$, where $E_\\lambda$ are the level energies and $E$ is the scattering energy.\n    -   $U$ is an $N \\times C$ real matrix whose columns are the reduced width amplitude vectors $\\gamma_c$ for each of the $C$ reaction channels. An element $U_{\\lambda c}$ corresponds to the amplitude $\\gamma_{\\lambda c}$.\n    -   $W(E)$ is a $C \\times C$ diagonal matrix with entries $w_c(E) = i\\,P_c(E)$, where $i$ is the imaginary unit and $P_c(E)$ is the penetration factor for channel $c$.\n\n2.  **Penetration Factor, $P_c(E)$**: For a neutral particle in an $s$-wave ($l=0$) channel, this is given by $P_c(E) = k_c(E)\\,a_c$.\n    -   $k_c(E)$ is the wave number, $k_c(E) = \\sqrt{2\\mu_c E}/\\hbar$. Using the provided constant $\\hbar c = 197.3269804 \\text{ MeV}\\cdot\\text{fm}$, and expressing the reduced mass $\\mu_c$ in $\\text{MeV}/c^2$ and energy $E$ in MeV, the wave number in units of $\\text{fm}^{-1}$ is:\n        $$k_c(E) = \\frac{\\sqrt{2(\\mu_c c^2)E}}{\\hbar c}$$\n    -   $a_c$ is the channel radius in fm, making $P_c(E)$ a dimensionless quantity.\n\n3.  **R-Matrix, $R(E)$**: A $C \\times C$ complex symmetric matrix that relates the value of the wave function to its derivative on the boundary of the internal region. It is calculated via the level matrix inverse:\n    $$R(E) = U^{\\mathsf T}\\,A(E)^{-1}\\,U$$\n\n4.  **Collision Matrix, $U(E)$**: A $C \\times C$ unitary matrix whose elements $U_{cc'}(E)$ relate incoming and outgoing wave amplitudes. Under the specified boundary conditions, it is given by:\n    $$U(E) = I_C - 2i\\,P(E)^{1/2}\\,R(E)\\,P(E)^{1/2}$$\n    -   $I_C$ is the $C \\times C$ identity matrix.\n    -   $P(E)^{1/2}$ is the diagonal matrix with entries $\\sqrt{P_c(E)}$. Since $E > 0$ and $\\mu_c > 0$, $P_c(E)$ is real and non-negative, so its square root is well-defined and real.\n\n### Computational Methods for $A(E)^{-1}$\n\nThe core task is to compute $R(E)$, which requires the inverse of $A(E)$. We will implement two methods.\n\n**Method 1: Direct Dense Inversion**\n\nThis is the most straightforward approach. For a given energy $E$:\n1.  Construct the $N \\times N$ diagonal matrix $D(E)$.\n2.  Construct the $N \\times C$ matrix $U$ and the $C \\times C$ diagonal matrix $W(E)$.\n3.  Compute the full $N \\times N$ matrix $A(E) = D(E) + U\\,W(E)\\,U^{\\mathsf T}$.\n4.  Invert $A(E)$ using a standard numerical linear algebra routine to obtain $A(E)^{-1}$.\n5.  Compute the R-matrix: $R_{\\text{direct}}(E) = U^{\\mathsf T}\\,A(E)^{-1}\\,U$.\n\nThis method is computationally expensive for large $N$, with the matrix inversion step typically scaling as $\\mathcal{O}(N^3)$. It can also suffer from numerical instability if $A(E)$ is ill-conditioned, which can occur near a resonance energy $E_\\lambda$.\n\n**Method 2: Low-Rank Update Inversion**\n\nThis method exploits the fact that the term $U\\,W(E)\\,U^{\\mathsf T}$ is a low-rank update to the simple diagonal matrix $D(E)$. The rank of the update is at most $C$, the number of channels, which is typically much smaller than $N$. We can derive a more efficient expression for $R(E)$ without explicitly forming or inverting the full $N \\times N$ matrix $A(E)$. The derivation proceeds as follows, starting from the definition of $R(E)$ and the inverse of $A(E)$:\n\nLet $x$ be an $N \\times C$ matrix defined as $x = A(E)^{-1}U$. Then by definition, the R-matrix is $R(E) = U^{\\mathsf T}x$.\nWe can write an equation for $x$ by multiplying by $A(E)$:\n$$A(E)x = U$$\nSubstitute the expression for $A(E)$:\n$$(D(E) + U\\,W(E)\\,U^{\\mathsf T})x = U$$\nExpand the left side:\n$$D(E)x + U\\,W(E)\\,(U^{\\mathsf T}x) = U$$\nRecognize that the term in parentheses, $U^{\\mathsf T}x$, is the R-matrix $R(E)$:\n$$D(E)x + U\\,W(E)\\,R(E) = U$$\nSince $D(E)$ is diagonal, its inverse $D(E)^{-1}$ is also a diagonal matrix with entries $1/(E_\\lambda - E)$, and is trivial to compute provided $E \\neq E_\\lambda$ for all $\\lambda$. We can solve for $x$:\n$$D(E)x = U - U\\,W(E)\\,R(E) = U(I_C - W(E)\\,R(E))$$\n$$x = D(E)^{-1}\\,U\\,(I_C - W(E)\\,R(E))$$\nNow, substitute this expression for $x$ back into the definition of the R-matrix, $R(E) = U^{\\mathsf T}x$:\n$$R(E) = U^{\\mathsf T}\\,[D(E)^{-1}\\,U\\,(I_C - W(E)\\,R(E))]$$\n$$R(E) = (U^{\\mathsf T}D(E)^{-1}U)\\,(I_C - W(E)\\,R(E))$$\nLet us define the $C \\times C$ matrix $Z(E) = U^{\\mathsf T}D(E)^{-1}U$. This matrix is central to the efficient method. Its elements are given by $Z_{cd}(E) = \\sum_{\\lambda=1}^N \\frac{\\gamma_{\\lambda c} \\gamma_{\\lambda d}}{E_\\lambda - E}$. The equation becomes:\n$$R(E) = Z(E)\\,(I_C - W(E)\\,R(E)) = Z(E) - Z(E)\\,W(E)\\,R(E)$$\nWe can now algebraically solve for $R(E)$:\n$$R(E) + Z(E)\\,W(E)\\,R(E) = Z(E)$$\n$$(I_C + Z(E)\\,W(E))\\,R(E) = Z(E)$$\nFinally, provided the matrix $(I_C + Z(E)W(E))$ is invertible, we obtain the expression for the R-matrix:\n$$R_{\\text{update}}(E) = (I_C + Z(E)\\,W(E))^{-1} \\, Z(E)$$\nThis derivation fulfills the requirement of starting from first principles. The computational advantage is substantial: the most expensive step is the inversion of a $C \\times C$ matrix, which scales as $\\mathcal{O}(C^3)$. Since $C \\ll N$ in many practical applications, this is far more efficient than the $\\mathcal{O}(N^3)$ scaling of the direct method.\n\n### Implementation and Error Analysis\n\nThe algorithm for the comparison is as follows. For each test case:\n1.  Initialize a maximum error for the case, $\\epsilon_{\\text{max}} = 0$.\n2.  Iterate through each specified scattering energy $E$.\n3.  At each $E$, compute the collision matrix $U_{\\text{direct}}(E)$ using the direct inversion method for $R(E)$.\n4.  At the same $E$, compute $U_{\\text{update}}(E)$ using the low-rank update method for $R(E)$.\n5.  Calculate the element-wise absolute difference matrix, $\\Delta U(E) = |U_{\\text{direct}}(E) - U_{\\text{update}}(E)|$.\n6.  Find the maximum entry in this difference matrix, $\\epsilon(E) = \\max_{ij} \\Delta U_{ij}(E)$.\n7.  Update the case maximum error: $\\epsilon_{\\text{max}} = \\max(\\epsilon_{\\text{max}}, \\epsilon(E))$.\n8.  After iterating through all energies, the final result for the test case is $\\epsilon_{\\text{max}}$.\n\nThis procedure will be carried out for all four test cases, and the resulting maximum errors will be reported. This comparison serves as a verification of the derived low-rank update formula and also highlights potential numerical precision differences between the two mathematically equivalent paths.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the R-matrix problem for four test cases, comparing direct and \n    low-rank update inversion methods for the collision matrix.\n    \"\"\"\n    HBAR_C = 197.3269804  # MeV·fm\n\n    def get_P_matrices(E, mu_vec, a_vec):\n        \"\"\"Calculates the diagonal P(E) and P(E)^(1/2) matrices.\"\"\"\n        C = len(mu_vec)\n        p_diag = np.zeros(C, dtype=np.float64)\n        for c in range(C):\n            # E can be zero or very close to it, sqrt will be handled correctly.\n            # The calculation is valid for E >= 0.\n            if E >= 0:\n                k_c = np.sqrt(2 * mu_vec[c] * E) / HBAR_C\n                p_diag[c] = k_c * a_vec[c]\n        \n        P_matrix = np.diag(p_diag)\n        P_sqrt_matrix = np.diag(np.sqrt(p_diag))\n        return P_matrix, P_sqrt_matrix\n\n    def calculate_U_direct(E, E_levels, U_mat, mu_vec, a_vec):\n        \"\"\"Computes the collision matrix U(E) using direct inversion.\"\"\"\n        N, C = U_mat.shape\n        I_C = np.identity(C, dtype=np.complex128)\n        \n        # Diagonal matrix D(E)\n        d_diag = E_levels - E\n        D_matrix = np.diag(d_diag)\n\n        # Diagonal matrix W(E)\n        P_matrix, P_sqrt_matrix = get_P_matrices(E, mu_vec, a_vec)\n        W_matrix = 1j * P_matrix\n        \n        # Level matrix A(E)\n        A_matrix = D_matrix.astype(np.complex128) + U_mat @ W_matrix @ U_mat.T\n        \n        # R-matrix R(E)\n        try:\n            A_inv = np.linalg.inv(A_matrix)\n        except np.linalg.LinAlgError:\n            # This should not happen with the given test cases, but is good practice.\n            return np.full((C, C), np.nan, dtype=np.complex128)\n            \n        R_matrix = U_mat.T @ A_inv @ U_mat\n        \n        # Collision matrix U(E)\n        U_collision_matrix = I_C - 2j * P_sqrt_matrix @ R_matrix @ P_sqrt_matrix\n        \n        return U_collision_matrix\n\n    def calculate_U_update(E, E_levels, U_mat, mu_vec, a_vec):\n        \"\"\"Computes the collision matrix U(E) using the low-rank update method.\"\"\"\n        N, C = U_mat.shape\n        I_C = np.identity(C, dtype=np.complex128)\n\n        # Inverse of D(E)\n        d_inv_diag = 1.0 / (E_levels - E)\n        D_inv_matrix = np.diag(d_inv_diag)\n        \n        # Z(E) matrix\n        Z_matrix = U_mat.T @ D_inv_matrix.astype(np.complex128) @ U_mat\n        \n        # W(E) matrix and P_sqrt\n        P_matrix, P_sqrt_matrix = get_P_matrices(E, mu_vec, a_vec)\n        W_matrix = 1j * P_matrix\n        \n        # R-matrix R(E) using the derived formula\n        M_matrix = I_C + Z_matrix @ W_matrix\n        \n        try:\n            M_inv = np.linalg.inv(M_matrix)\n        except np.linalg.LinAlgError:\n            return np.full((C, C), np.nan, dtype=np.complex128)\n            \n        R_matrix = M_inv @ Z_matrix\n        \n        # Collision matrix U(E)\n        U_collision_matrix = I_C - 2j * P_sqrt_matrix @ R_matrix @ P_sqrt_matrix\n        \n        return U_collision_matrix\n\n    # Test cases defined in the problem statement.\n    test_cases = [\n        { # Case 1\n            \"E_levels\": np.array([0.2, 1.0, 3.0]),\n            \"U_mat\": np.array([[0.06], [0.02], [0.01]]),\n            \"mu_vec\": np.array([469.5]),\n            \"a_vec\": np.array([5.0]),\n            \"energies\": np.array([0.05, 0.1999, 0.5, 1.0])\n        },\n        { # Case 2\n            \"E_levels\": np.array([0.01, 0.5, 1.5, 2.5, 4.0]),\n            \"U_mat\": np.array([[0.03], [0.015], [0.008], [0.004], [0.002]]),\n            \"mu_vec\": np.array([469.5]),\n            \"a_vec\": np.array([5.0]),\n            \"energies\": np.array([1e-6, 1e-4, 1e-2])\n        },\n        { # Case 3\n            \"E_levels\": np.array([0.4, 0.8, 1.6, 2.8]),\n            \"U_mat\": np.array([\n                [0.05, 0.04], [0.02, 0.015], [0.03, 0.02], [0.01, 0.008]\n            ]),\n            \"mu_vec\": np.array([469.5, 300.0]),\n            \"a_vec\": np.array([4.5, 6.0]),\n            \"energies\": np.array([0.3, 0.8, 1.6, 2.5])\n        },\n        { # Case 4\n            \"E_levels\": np.array([1.0, 1.5, 2.0]),\n            \"U_mat\": np.array([[0.10], [0.05], [0.02]]),\n            \"mu_vec\": np.array([469.5]),\n            \"a_vec\": np.array([5.0]),\n            \"energies\": np.array([0.9999, 1.0001, 1.2])\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        max_case_error = 0.0\n        for E in case[\"energies\"]:\n            U_direct = calculate_U_direct(E, case[\"E_levels\"], case[\"U_mat\"], case[\"mu_vec\"], case[\"a_vec\"])\n            U_update = calculate_U_update(E, case[\"E_levels\"], case[\"U_mat\"], case[\"mu_vec\"], case[\"a_vec\"])\n\n            # Quantify numerical error\n            error_E = np.max(np.abs(U_direct - U_update))\n            if error_E > max_case_error:\n                max_case_error = error_E\n        \n        results.append(max_case_error)\n\n    # Format output as specified\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```", "id": "3585560"}]}