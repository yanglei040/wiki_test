{"hands_on_practices": [{"introduction": "The optical potential is complex, with its real part describing refraction and its imaginary part describing absorption. These two parts are not independent. The fundamental principle of causality, which dictates that an effect cannot precede its cause, mathematically requires the optical potential to be an analytic function in the upper half of the complex energy plane. The Kramers-Kronig relations are a direct consequence of this analyticity, linking the real and imaginary parts of the potential through an integral transform. This practice [@problem_id:3605865] provides a hands-on verification of this profound physical principle. By numerically evaluating the dispersion integral for a model potential, you will gain a deeper appreciation for the connection between causality and the structure of the optical potential while mastering the computation of Cauchy principal value integrals.", "problem": "You are to verify the dispersive optical model consistency for elastic scattering by numerically checking the Kramers–Kronig relations between the real and imaginary parts of an energy-dependent optical potential. The verification will be performed for a model optical potential that is analytic in the upper half of the complex energy plane, ensuring causality.\n\nBegin from the fundamental base that a causal response function $U(E)$ is analytic in the upper half-plane, which implies that its real and imaginary parts are linked via the Kramers–Kronig relations. To ensure convergence for functions that do not vanish sufficiently rapidly at infinity, one uses the subtracted dispersion relation at a subtraction point $E_0$:\n$$\n\\Re U(E) - \\Re U(E_0)\n= \\frac{1}{\\pi}\\,\\mathcal{P}\\!\\!\\int_{-\\infty}^{+\\infty} \\Im U(E')\n\\left[\n\\frac{1}{E' - E} - \\frac{1}{E' - E_0}\n\\right]\\,\\mathrm{d}E' ,\n$$\nwhere $\\mathcal{P}$ denotes the Cauchy principal value. In computations, the integral will be approximated over a finite energy window $[E_{\\min}, E_{\\max}]$, which is justified if $\\Im U(E)$ is sufficiently localized so that tails beyond the window are negligible.\n\nFor numerical testing with quantifiable ground truth, use the analytic optical potential model\n$$\nU(E) = \\frac{A}{E - E_c + i\\,\\Gamma},\n$$\nwith $A$ a positive constant with units of $\\mathrm{MeV}^2$, $E_c$ a centroid energy in $\\mathrm{MeV}$, and $\\Gamma$ a width parameter in $\\mathrm{MeV}$. This yields\n$$\n\\Re U(E) = A\\,\\frac{E - E_c}{(E - E_c)^2 + \\Gamma^2},\n\\qquad\n\\Im U(E) = -A\\,\\frac{\\Gamma}{(E - E_c)^2 + \\Gamma^2},\n$$\nboth in $\\mathrm{MeV}$. By analyticity, the above subtracted Kramers–Kronig relation must hold exactly for the infinite limits; numerically, you will check whether it holds to within small error when the principal value integral is truncated to $[E_{\\min},E_{\\max}]$.\n\nYour program must:\n- Implement $\\Im U(E)$ and $\\Re U(E)$ for the analytic model given above.\n- For each test case, evaluate the subtracted dispersion-relation prediction\n$$\nD(E;E_0) \\equiv \\frac{1}{\\pi}\\,\\mathcal{P}\\!\\!\\int_{E_{\\min}}^{E_{\\max}} \\Im U(E')\n\\left[\n\\frac{1}{E' - E} - \\frac{1}{E' - E_0}\n\\right]\\,\\mathrm{d}E'\n$$\nfor a set of energies $E$ inside the integration window, and compare it to the exact difference $\\Re U(E) - \\Re U(E_0)$.\n- Use the Cauchy principal value definition for the integrals at points $E$ and $E_0$.\n- Report, for each test case, the single scalar result equal to the maximum absolute deviation over the provided $E$ grid:\n$$\n\\max_{E\\in \\mathcal{E}} \\left| \\left(\\Re U(E) - \\Re U(E_0)\\right) - D(E;E_0) \\right|,\n$$\nexpressed in $\\mathrm{MeV}$.\n\nAll energies, widths, and potential values must be treated in $\\mathrm{MeV}$. Your final printed outputs must be floats in $\\mathrm{MeV}$.\n\nTest Suite:\n- Case 1 (general case):\n  - $A = 150\\,\\mathrm{MeV}^2$, $E_c = 40\\,\\mathrm{MeV}$, $\\Gamma = 8\\,\\mathrm{MeV}$.\n  - Subtraction point $E_0 = 30\\,\\mathrm{MeV}$.\n  - Integration window $[E_{\\min},E_{\\max}] = [-160\\,\\mathrm{MeV},\\,240\\,\\mathrm{MeV}]$.\n  - Evaluation set $\\mathcal{E} = \\{10,\\,20,\\,30,\\,40,\\,50,\\,60,\\,80\\}\\,\\mathrm{MeV}$.\n- Case 2 (boundary case with $E_0$ equal to one evaluation energy):\n  - $A = 80\\,\\mathrm{MeV}^2$, $E_c = 50\\,\\mathrm{MeV}$, $\\Gamma = 12\\,\\mathrm{MeV}$.\n  - Subtraction point $E_0 = 50\\,\\mathrm{MeV}$.\n  - Integration window $[E_{\\min},E_{\\max}] = [-250\\,\\mathrm{MeV},\\,350\\,\\mathrm{MeV}]$.\n  - Evaluation set $\\mathcal{E} = \\{20,\\,40,\\,50,\\,60,\\,80,\\,100\\}\\,\\mathrm{MeV}$.\n- Case 3 (edge case with very narrow width):\n  - $A = 100\\,\\mathrm{MeV}^2$, $E_c = 10\\,\\mathrm{MeV}$, $\\Gamma = 0.5\\,\\mathrm{MeV}$.\n  - Subtraction point $E_0 = 0\\,\\mathrm{MeV}$.\n  - Integration window $[E_{\\min},E_{\\max}] = [-100\\,\\mathrm{MeV},\\,120\\,\\mathrm{MeV}]$.\n  - Evaluation set $\\mathcal{E} = \\{5,\\,9.5,\\,10.0,\\,10.5,\\,20,\\,40\\}\\,\\mathrm{MeV}$.\n\nFinal Output Format:\n- Your program should produce a single line of output containing the three results as a comma-separated list enclosed in square brackets, in $\\mathrm{MeV}$, each rounded to six decimal places. For example, the output should look like\n$$\n[\\text{result}_1,\\text{result}_2,\\text{result}_3].\n$$", "solution": "The problem requires the numerical verification of the subtracted Kramers–Kronig (KK) dispersion relation for a model optical potential, $U(E)$, used in elastic scattering theory. The verification process involves comparing the analytically known real part of the potential against a value computed by integrating its imaginary part.\n\nThe foundational principle is causality. In physics, a response function that is causal (i.e., the effect does not precede the cause) is mathematically represented by a function that is analytic in the upper half of the complex frequency (or energy) plane. A direct consequence of this analyticity, established by Titchmarsh's theorem, is that the real and imaginary parts of the function are not independent but are related by the Kramers–Kronig relations. For an optical potential $U(E)$ that does not vanish sufficiently quickly as $|E| \\to \\infty$, a subtracted form of the dispersion relation is used to ensure convergence of the integral. At a chosen subtraction energy $E_0$, this relation is:\n$$\n\\Re U(E) - \\Re U(E_0) = \\frac{1}{\\pi}\\,\\mathcal{P}\\!\\!\\int_{-\\infty}^{+\\infty} \\Im U(E') \\left[ \\frac{1}{E' - E} - \\frac{1}{E' - E_0} \\right]\\,\\mathrm{d}E'\n$$\nwhere $\\mathcal{P}$ denotes the Cauchy principal value of the integral.\n\nThe problem provides a specific analytic model for the potential, which has a single pole in the lower half-plane, thereby satisfying the causality requirement. The potential is given by:\n$$\nU(E) = \\frac{A}{E - E_c + i\\,\\Gamma}\n$$\nwhere $A$ is a strength parameter in units of $\\mathrm{MeV}^2$, $E_c$ is a resonance energy in $\\mathrm{MeV}$, and $\\Gamma$ is a width parameter in $\\mathrm{MeV}$, with $\\Gamma  0$. The real and imaginary parts of this potential are:\n$$\n\\Re U(E) = A\\,\\frac{E - E_c}{(E - E_c)^2 + \\Gamma^2}\n$$\n$$\n\\Im U(E) = -A\\,\\frac{\\Gamma}{(E - E_c)^2 + \\Gamma^2}\n$$\n\nThe task is to numerically evaluate the right-hand side of the KK relation over a finite integration window $[E_{\\min}, E_{\\max}]$, denoted as $D(E; E_0)$:\n$$\nD(E;E_0) \\equiv \\frac{1}{\\pi}\\,\\mathcal{P}\\!\\!\\int_{E_{\\min}}^{E_{\\max}} \\Im U(E') \\left[ \\frac{1}{E' - E} - \\frac{1}{E' - E_0} \\right]\\,\\mathrm{d}E'\n$$\nand to quantify its deviation from the analytically known left-hand side, $\\Re U(E) - \\Re U(E_0)$. The maximum absolute deviation over a prescribed set of evaluation energies $\\mathcal{E}$ is the final result for each test case.\n\nThe numerical challenge lies in the evaluation of the Cauchy principal value integral. The integrand has singularities at $E' = E$ and $E' = E_0$. The integral for $D(E; E_0)$ can be decomposed into two separate principal value integrals:\n$$\nD(E; E_0) = \\frac{1}{\\pi} \\left( \\mathcal{P}\\!\\!\\int_{E_{\\min}}^{E_{\\max}} \\frac{\\Im U(E')}{E' - E}\\,\\mathrm{d}E' - \\mathcal{P}\\!\\!\\int_{E_{\\min}}^{E_{\\max}} \\frac{\\Im U(E')}{E' - E_0}\\,\\mathrm{d}E' \\right)\n$$\nEach integral is of the form $\\mathcal{P}\\int_a^b \\frac{g(x)}{x-c}\\,\\mathrm{d}x$. Such integrals can be computed robustly using specialized numerical quadrature routines. The `scipy.integrate.quad` function in Python's SciPy library is ideally suited for this, offering a `weight='cauchy'` option that takes the function $g(x)$ and the singularity location $c$ (as `wvar`) as arguments to compute the principal value.\n\nThe overall algorithm proceeds as follows:\n1.  For each test case, the parameters $(A, E_c, \\Gamma)$, the subtraction point $E_0$, the integration window $[E_{\\min}, E_{\\max}]$, and the set of evaluation energies $\\mathcal{E}$ are defined.\n2.  Functions are implemented to compute $\\Re U(E)$ and $\\Im U(E)$ according to their analytic formulas.\n3.  A loop iterates through each evaluation energy $E \\in \\mathcal{E}$.\n4.  Inside the loop, for each $E$:\n    a. The \"exact\" difference, $\\Delta_{\\text{exact}} = \\Re U(E) - \\Re U(E_0)$, is calculated directly.\n    b. The dispersion integral term, $D(E; E_0)$, is computed. If $E = E_0$, the integrand is identically zero, so $D(E_0; E_0) = 0$. Otherwise, the two principal value integrals are computed using `scipy.integrate.quad` with the Cauchy weight, and their difference is scaled by $1/\\pi$.\n    c. The absolute deviation, $|\\Delta_{\\text{exact}} - D(E; E_0)|$, is calculated.\n5.  The maximum of these deviations across all $E \\in \\mathcal{E}$ is found and stored as the result for the test case. The small, non-zero result quantifies the error introduced primarily by truncating the infinite integration range to $[E_{\\min}, E_{\\max}]$, as the model function $\\Im U(E')$ has tails extending to $\\pm\\infty$.\n6.  This procedure is repeated for all three specified test cases, and the results are formatted as requested.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    It verifies the dispersive optical model consistency by checking the\n    Kramers-Kronig relation for a model potential.\n    \"\"\"\n\n    def Re_U(E, A, Ec, Gamma):\n        \"\"\"\n        Calculates the real part of the model optical potential.\n        \n        Args:\n            E (float): Energy in MeV.\n            A (float): Strength parameter in MeV^2.\n            Ec (float): Centroid energy in MeV.\n            Gamma (float): Width parameter in MeV.\n        \n        Returns:\n            float: Real part of the potential in MeV.\n        \"\"\"\n        return A * (E - Ec) / ((E - Ec)**2 + Gamma**2)\n\n    def Im_U(E_prime, A, Ec, Gamma):\n        \"\"\"\n        Calculates the imaginary part of the model optical potential.\n\n        Args:\n            E_prime (float): Integration variable for energy in MeV.\n            A (float): Strength parameter in MeV^2.\n            Ec (float): Centroid energy in MeV.\n            Gamma (float): Width parameter in MeV.\n        \n        Returns:\n            float: Imaginary part of the potential in MeV.\n        \"\"\"\n        return -A * Gamma / ((E_prime - Ec)**2 + Gamma**2)\n\n    def calculate_dispersion_integral(E, E0, Emin, Emax, A, Ec, Gamma):\n        \"\"\"\n        Calculates the subtracted dispersion integral D(E; E0) using a\n        Cauchy principal value numerical integration.\n        D(E;E0) = (1/pi) * P.V. integral[Im_U(E') * (1/(E'-E) - 1/(E'-E0))] dE'\n        \"\"\"\n        # If the evaluation energy is the same as the subtraction point,\n        # the integrand is zero everywhere, so the integral is zero.\n        if E == E0:\n            return 0.0\n\n        # The function passed to quad should be Im_U(E'). The (1/(E'-c)) part\n        # is handled by the 'cauchy' weight.\n        args_for_Im_U = (A, Ec, Gamma)\n\n        # Calculate the first principal value integral, with singularity at E.\n        integral_1, _ = quad(Im_U, Emin, Emax, args=args_for_Im_U, weight='cauchy', wvar=E)\n        \n        # Calculate the second principal value integral, with singularity at E0.\n        integral_2, _ = quad(Im_U, Emin, Emax, args=args_for_Im_U, weight='cauchy', wvar=E0)\n\n        # Combine results according to the dispersion relation formula.\n        D_E_E0 = (1.0 / np.pi) * (integral_1 - integral_2)\n        return D_E_E0\n\n    def solve_case(params):\n        \"\"\"\n        Solves a single test case.\n        \n        Args:\n            params (dict): A dictionary containing all parameters for the case.\n            \n        Returns:\n            float: The maximum absolute deviation in MeV.\n        \"\"\"\n        A = params['A']\n        Ec = params['Ec']\n        Gamma = params['Gamma']\n        E0 = params['E0']\n        Emin, Emax = params['window']\n        E_set = params['E_set']\n        \n        max_deviation = 0.0\n\n        for E_eval in E_set:\n            # Calculate the expected difference from the analytic formula for Re(U).\n            exact_diff = Re_U(E_eval, A, Ec, Gamma) - Re_U(E0, A, Ec, Gamma)\n            \n            # Calculate the difference from the numerical dispersion integral.\n            numerical_D = calculate_dispersion_integral(E_eval, E0, Emin, Emax, A, Ec, Gamma)\n            \n            # Calculate the absolute deviation.\n            deviation = np.abs(exact_diff - numerical_D)\n            \n            # Update the maximum deviation found so far.\n            if deviation > max_deviation:\n                max_deviation = deviation\n                \n        return max_deviation\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"A\": 150.0, \"Ec\": 40.0, \"Gamma\": 8.0,\n            \"E0\": 30.0,\n            \"window\": [-160.0, 240.0],\n            \"E_set\": [10.0, 20.0, 30.0, 40.0, 50.0, 60.0, 80.0]\n        },\n        {\n            \"A\": 80.0, \"Ec\": 50.0, \"Gamma\": 12.0,\n            \"E0\": 50.0,\n            \"window\": [-250.0, 350.0],\n            \"E_set\": [20.0, 40.0, 50.0, 60.0, 80.0, 100.0]\n        },\n        {\n            \"A\": 100.0, \"Ec\": 10.0, \"Gamma\": 0.5,\n            \"E0\": 0.0,\n            \"window\": [-100.0, 120.0],\n            \"E_set\": [5.0, 9.5, 10.0, 10.5, 20.0, 40.0]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_case(case)\n        results.append(result)\n\n    # Format the output as a comma-separated list of floats with 6 decimal places,\n    # enclosed in square brackets.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3605865"}, {"introduction": "Once an optical potential is defined, the next step is to solve the Schrödinger equation to obtain the scattering wavefunction, typically by integrating the equation numerically. When the potential is complex and describes absorption, the underlying Hamiltonian is non-Hermitian, leading to wavefunctions with exponentially growing and decaying components. This behavior can cause severe numerical instabilities in standard integration algorithms, where small round-off errors are exponentially amplified. This exercise [@problem_id:3605853] takes you to the heart of robust numerical implementation, where you will learn to identify the source of this instability and develop a practical strategy—adaptive step-size control—to ensure the accuracy of your scattering calculations.", "problem": "Consider the radial elastic scattering of a nucleon from a nucleus described by the optical model, where the central potential has a real and an absorptive imaginary component. Let the reduced mass be approximated by the nucleon mass so that the ratio $\\hbar^2 / (2\\mu)$ is the constant $20.735$ in units of $\\mathrm{MeV \\cdot fm^2}$. The radial Schrödinger equation for a partial wave with orbital angular momentum $\\ell$ for the reduced radial wave function $u(r)$ is\n$$\n\\frac{d^2 u(r)}{dr^2} + K(r)\\,u(r) = 0,\n$$\nwith\n$$\nK(r) = \\frac{2\\mu E}{\\hbar^2} - \\frac{2\\mu V(r)}{\\hbar^2} - \\frac{\\ell(\\ell+1)}{r^2},\n$$\nwhere $E$ is the laboratory energy in $\\mathrm{MeV}$, $r$ is the radial coordinate in $\\mathrm{fm}$, $\\ell$ is an integer, and $V(r)$ is the complex optical potential in $\\mathrm{MeV}$. Take a Woods–Saxon form for the central potential\n$$\nV(r) = V_{\\mathrm{r}}\\,f(r) + i\\,W\\,f(r), \\quad f(r) = \\frac{1}{1 + \\exp\\left(\\frac{r - R}{a}\\right)},\n$$\nwith $V_{\\mathrm{r}}$ the real depth in $\\mathrm{MeV}$, $W$ the imaginary depth in $\\mathrm{MeV}$ such that absorptive potentials have $W  0$, $R = r_0 A^{1/3}$ the radius in $\\mathrm{fm}$ for mass number $A$, and $a$ the diffuseness in $\\mathrm{fm}$.\n\nDefine the log-derivative $Y(r) = \\frac{u'(r)}{u(r)}$. The log-derivative satisfies the Riccati equation\n$$\n\\frac{dY(r)}{dr} = -K(r) - Y(r)^2.\n$$\nA common numerical approach propagates $Y(r)$ over a small step $h$ by assuming $K(r)$ is constant across the step, which reduces the local equation to $u''(r) + K\\,u(r) = 0$ with constant $K$. Let $\\kappa = \\sqrt{K}$ be the principal square root of $K$. Over one step of size $h$, the exact constant-$K$ update for the log-derivative is a Möbius transform\n$$\nY_{+} = \\frac{Y_{-}\\cos(\\kappa h) - \\kappa \\sin(\\kappa h)}{\\cos(\\kappa h) + \\frac{Y_{-}}{\\kappa}\\sin(\\kappa h)},\n$$\nwhere $Y_{-}$ and $Y_{+}$ are the log-derivative values at the beginning and end of the step, respectively. The sensitivity (conditioning) of the update with respect to $Y_{-}$ is quantified by the magnitude of the derivative $\\left|\\frac{\\partial Y_{+}}{\\partial Y_{-}}\\right|$. Evaluated at the fixed point $Y = +i\\kappa$ corresponding to an outgoing wave, it simplifies to the closed form\n$$\n\\left|\\frac{\\partial Y_{+}}{\\partial Y_{-}}\\right| = \\left|e^{i\\,\\kappa h}\\right|^{-2} = \\exp\\left(2\\,\\mathrm{Im}(\\kappa)\\,h\\right).\n$$\nThis expression shows that strong absorption, which yields $\\mathrm{Im}(\\kappa)  0$, causes an exponential amplification of numerical perturbations over each step, making the propagation increasingly ill-conditioned as $h$ grows. A step-size control mitigation to enforce a conditioning cap $c_{\\max}  1$ is to require\n$$\n\\exp\\left(2\\,\\mathrm{Im}(\\kappa(r))\\,h\\right) \\le c_{\\max}\n\\quad\\Rightarrow\\quad\nh \\le \\frac{\\ln(c_{\\max})}{2\\,\\mathrm{Im}(\\kappa(r))},\n$$\napplied pointwise for each $r$ where $\\mathrm{Im}(\\kappa(r)) > 0$.\n\nYour task is to implement a program that, for a given set of optical-model parameters and a uniform step size $h$ in $\\mathrm{fm}$, computes the conditioning profile\n$$\nC(r; h) = \\exp\\left(2\\,\\mathrm{Im}(\\kappa(r))\\,h\\right),\n$$\nover a radial interval $[r_{\\min}, r_{\\max}]$, and reports:\n- the maximum conditioning value $C_{\\max}(h) = \\max_{r \\in [r_{\\min}, r_{\\max}]} C(r; h)$ as a floating-point number, and\n- the recommended step size $h_{\\mathrm{rec}}$ in $\\mathrm{fm}$ that guarantees $C(r; h) \\le c_{\\max}$ for all $r \\in [r_{\\min}, r_{\\max}]$, computed by\n$$\nh_{\\mathrm{rec}} = \\min\\left(\\min_{r \\in [r_{\\min}, r_{\\max}],\\,\\mathrm{Im}(\\kappa(r))0} \\frac{\\ln(c_{\\max})}{2\\,\\mathrm{Im}(\\kappa(r))},\\, h_{\\mathrm{cap}}\\right),\n$$\nwhere $h_{\\mathrm{cap}}$ is a user-imposed upper cap in $\\mathrm{fm}$ to ensure resolution of potential variations even in the absence of absorption. Use $h_{\\mathrm{cap}} = 0.5$ in $\\mathrm{fm}$, $r_{\\min} = 0.2$ in $\\mathrm{fm}$, and $r_{\\max} = 15.0$ in $\\mathrm{fm}$. If there is no absorption so that $\\mathrm{Im}(\\kappa(r)) \\approx 0$ for all $r$, then $h_{\\mathrm{rec}} = h_{\\mathrm{cap}}$.\n\nPhysical units must be respected: all energies are in $\\mathrm{MeV}$, all lengths are in $\\mathrm{fm}$, and the step sizes must be reported in $\\mathrm{fm}$. No angles are used. Your program should implement the following test suite of cases and produce the specified outputs:\n- Case $1$ (happy path, moderate absorption): $A = 40$, $E = 50$, $V_{\\mathrm{r}} = 50$, $W = -5$, $\\ell = 0$, $r_0 = 1.25$, $a = 0.65$, $h = 0.05$, $c_{\\max} = 10$.\n- Case $2$ (centrifugal barrier influence): $A = 208$, $E = 30$, $V_{\\mathrm{r}} = 60$, $W = -20$, $\\ell = 6$, $r_0 = 1.25$, $a = 0.65$, $h = 0.05$, $c_{\\max} = 10$.\n- Case $3$ (strong absorption, potential stiffness): $A = 208$, $E = 10$, $V_{\\mathrm{r}} = 50$, $W = -50$, $\\ell = 0$, $r_0 = 1.25$, $a = 0.65$, $h = 0.05$, $c_{\\max} = 10$.\n- Case $4$ (no absorption boundary): $A = 40$, $E = 80$, $V_{\\mathrm{r}} = 40$, $W = 0$, $\\ell = 0$, $r_0 = 1.25$, $a = 0.65$, $h = 0.05$, $c_{\\max} = 10$.\n\nFor each case, compute $C_{\\max}(h)$ and $h_{\\mathrm{rec}}$ as defined above. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets with the pattern\n$$\n[\\;C_{\\max}^{(1)},\\,h_{\\mathrm{rec}}^{(1)},\\,C_{\\max}^{(2)},\\,h_{\\mathrm{rec}}^{(2)},\\,C_{\\max}^{(3)},\\,h_{\\mathrm{rec}}^{(3)},\\,C_{\\max}^{(4)},\\,h_{\\mathrm{rec}}^{(4)}\\;],\n$$\nwhere each entry is a floating-point number in standard decimal notation.", "solution": "The problem statement has been validated and is determined to be sound. It is scientifically grounded in the principles of computational nuclear physics, specifically the optical model of elastic scattering. All parameters, definitions, and constraints are well-defined, self-consistent, and physically plausible, rendering the problem well-posed and solvable. We may therefore proceed with the derivation and implementation of the solution.\n\nThe core of the problem is to analyze the numerical conditioning of the integration of the radial Schrödinger equation when using a log-derivative method. The conditioning is related to the imaginary part of the local wave number, $\\kappa(r)$. Our task is to compute two quantities for several parameter sets: the maximum conditioning factor $C_{\\max}(h)$ over a radial interval for a fixed step size $h$, and a recommended step size $h_{\\mathrm{rec}}$ to keep the conditioning below a specified threshold $c_{\\max}$.\n\nThe algorithmic procedure is as follows:\n\nFirst, we define all relevant physical quantities as functions of the radial coordinate, $r$. The constant ratio $\\frac{\\hbar^2}{2\\mu}$ is given as $c_0 = 20.735 \\, \\mathrm{MeV \\cdot fm^2}$.\n\nThe Woods-Saxon form factor, $f(r)$, which describes the shape of the nuclear potential, is given by:\n$$\nf(r) = \\frac{1}{1 + \\exp\\left(\\frac{r - R}{a}\\right)}\n$$\nwhere the nuclear radius $R$ is determined by the mass number $A$ and a radius parameter $r_0$ as $R = r_0 A^{1/3}$. The parameter $a$ is the diffuseness.\n\nThe complex optical potential, $V(r)$, is a sum of a real (refractive) part with depth $V_{\\mathrm{r}}$ and an imaginary (absorptive) part with depth $W$:\n$$\nV(r) = (V_{\\mathrm{r}} + i\\,W) f(r)\n$$\nA negative value of $W$ corresponds to absorption, as is standard in nuclear reaction theory.\n\nFrom the potential, we construct the position-dependent squared wave number, $K(r)$, which appears in the radial Schrödinger equation. Its definition is:\n$$\nK(r) = \\frac{2\\mu E}{\\hbar^2} - \\frac{2\\mu V(r)}{\\hbar^2} - \\frac{\\ell(\\ell+1)}{r^2}\n$$\nUsing the provided constant $c_0$, this becomes:\n$$\nK(r) = \\frac{E - V(r)}{c_0} - \\frac{\\ell(\\ell+1)}{r^2}\n$$\nHere, $E$ is the kinetic energy and the term involving the orbital angular momentum $\\ell$ is the centrifugal potential. $K(r)$ is a complex-valued function.\n\nThe local wave number is then the principal square root of $K(r)$:\n$$\n\\kappa(r) = \\sqrt{K(r)}\n$$\nSince $K(r)$ is complex, $\\kappa(r)$ will also be complex, with $\\kappa(r) = \\mathrm{Re}(\\kappa(r)) + i\\,\\mathrm{Im}(\\kappa(r))$. The imaginary part, $\\mathrm{Im}(\\kappa(r))$, is central to the problem. If $\\mathrm{Im}(\\kappa(r))  0$, the wave function exhibits exponential behavior which, in the context of numerical integration, leads to the amplification of errors.\n\nThe problem defines the conditioning profile $C(r; h)$ for a step size $h$ as:\n$$\nC(r; h) = \\exp\\left(2\\,\\mathrm{Im}(\\kappa(r))\\,h\\right)\n$$\n\nTo find the maximum conditioning factor, $C_{\\max}(h)$, and the recommended step size, $h_{\\mathrm{rec}}$, we must evaluate these functions over the specified radial interval $[r_{\\min}, r_{\\max}] = [0.2, 15.0]$. Since these are continuous functions, we adopt a numerical approach by discretizing the interval into a fine grid of points, $\\{r_j\\}$. We will use a grid of $15000$ points to ensure high resolution.\n\nThe algorithm to compute the required outputs for each test case is as follows:\n\n1.  **Discretize the Domain**: Generate an array of radial points $r_j$ from $r_{\\min} = 0.2 \\, \\mathrm{fm}$ to $r_{\\max} = 15.0 \\, \\mathrm{fm}$.\n2.  **Evaluate Functions on the Grid**: For each point $r_j$ in the grid, compute the sequence of values: $f(r_j)$, $V(r_j)$, $K(r_j)$, and finally $\\kappa(r_j) = \\sqrt{K(r_j)}$. This yields a corresponding grid of complex $\\kappa_j$ values.\n3.  **Compute $C_{\\max}(h)$**:\n    a. Extract the imaginary part of each $\\kappa_j$ value to get an array $\\mathrm{Im}(\\kappa_j)$.\n    b. Calculate the conditioning value at each grid point: $C_j = \\exp\\left(2 \\cdot \\mathrm{Im}(\\kappa_j) \\cdot h\\right)$, using the given step size $h$.\n    c. The maximum conditioning factor is the maximum value in the array of $C_j$: $C_{\\max}(h) = \\max_j \\{C_j\\}$.\n4.  **Compute $h_{\\mathrm{rec}}$**:\n    a. Identify all grid points $r_j$ for which $\\mathrm{Im}(\\kappa_j)$ is greater than zero (within a small numerical tolerance to handle floating-point artifacts).\n    b. If no such points exist (i.e., for a purely real potential where $K(r)$ is always positive), the problem specifies $h_{\\mathrm{rec}} = h_{\\mathrm{cap}}$, where $h_{\\mathrm{cap}} = 0.5 \\, \\mathrm{fm}$.\n    c. If there are points with $\\mathrm{Im}(\\kappa_j)  0$, calculate the local step-size limit for each of these points:\n    $$\n    h_{\\mathrm{lim}, j} = \\frac{\\ln(c_{\\max})}{2\\,\\mathrm{Im}(\\kappa_j)}\n    $$\n    d. Find the minimum of these limits: $h_{\\mathrm{lim}}^{\\min} = \\min_j \\{h_{\\mathrm{lim}, j}\\}$. This value is the most restrictive step-size constraint imposed by the absorptive potential.\n    e. The recommended step size $h_{\\mathrm{rec}}$ is the smaller of this minimum and the global cap, $h_{\\mathrm{cap}}$:\n    $$\n    h_{\\mathrm{rec}} = \\min(h_{\\mathrm{lim}}^{\\min}, h_{\\mathrm{cap}})\n    $$\n\nThis procedure is implemented for each of the four test cases provided, and the resulting pairs of $(C_{\\max}(h), h_{\\mathrm{rec}})$ are collected and formatted as specified.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the conditioning profile and recommended step size for the optical model\n    of elastic scattering as described in the problem statement.\n    \"\"\"\n    # Define the physical constant\n    HBAR2_OVER_2MU = 20.735  # MeV * fm^2\n\n    # Define the test suite of cases\n    # Each case is a tuple: (A, E, V_r, W, l, r_0, a, h, c_max)\n    test_cases = [\n        # Case 1 (happy path, moderate absorption)\n        (40, 50, 50, -5, 0, 1.25, 0.65, 0.05, 10),\n        # Case 2 (centrifugal barrier influence)\n        (208, 30, 60, -20, 6, 1.25, 0.65, 0.05, 10),\n        # Case 3 (strong absorption, potential stiffness)\n        (208, 10, 50, -50, 0, 1.25, 0.65, 0.05, 10),\n        # Case 4 (no absorption boundary)\n        (40, 80, 40, 0, 0, 1.25, 0.65, 0.05, 10),\n    ]\n\n    # Fixed parameters for the calculation\n    R_MIN = 0.2  # fm\n    R_MAX = 15.0  # fm\n    H_CAP = 0.5  # fm\n    NUM_POINTS = 15000  # Number of points in the radial grid\n\n    # Generate the radial grid for numerical evaluation\n    r_grid = np.linspace(R_MIN, R_MAX, NUM_POINTS)\n    \n    # List to store all final results\n    all_results = []\n\n    for case in test_cases:\n        A, E, V_r, W, l, r0, a, h, c_max = case\n\n        # Calculate the nuclear radius a.k.a. R\n        R_nuc = r0 * A**(1/3)\n\n        # Calculate the Woods-Saxon form factor f(r) over the grid\n        f_of_r = 1.0 / (1.0 + np.exp((r_grid - R_nuc) / a))\n\n        # Calculate the complex optical potential V(r)\n        V_of_r = (V_r + 1j * W) * f_of_r\n\n        # Calculate the centrifugal term. r_grid does not contain 0, so this is safe.\n        centrifugal_term = l * (l + 1) / (r_grid**2)\n\n        # Calculate the K(r) function\n        # K(r) = ( E - V(r) ) / (hbar^2/2mu) - l(l+1)/r^2\n        K_of_r = (E - V_of_r) / HBAR2_OVER_2MU - centrifugal_term\n\n        # Calculate kappa(r) = sqrt(K(r)) using the principal square root\n        kappa_of_r = np.sqrt(K_of_r)\n\n        # Extract the imaginary part of kappa(r)\n        im_kappa = np.imag(kappa_of_r)\n        \n        # --- Task 1: Compute C_max(h) ---\n        # C(r; h) = exp(2 * Im(kappa(r)) * h)\n        conditioning_profile = np.exp(2 * im_kappa * h)\n        C_max_val = np.max(conditioning_profile)\n        \n        # --- Task 2: Compute h_rec ---\n        # Find indices where Im(kappa)  0 using a small tolerance\n        pos_im_kappa_indices = np.where(im_kappa > 1e-15)\n        \n        if pos_im_kappa_indices[0].size == 0:\n            # If no absorption, h_rec is capped by the user-defined maximum\n            h_rec_val = H_CAP\n        else:\n            # Filter for positive imaginary parts of kappa\n            im_kappa_positive = im_kappa[pos_im_kappa_indices]\n            \n            # h_allowed = ln(c_max) / (2 * Im(kappa(r)))\n            h_allowed = np.log(c_max) / (2 * im_kappa_positive)\n            \n            # Find the most restrictive (minimum) step size\n            h_min_allowed = np.min(h_allowed)\n            \n            # h_rec is the minimum of the calculated limit and the user cap\n            h_rec_val = min(h_min_allowed, H_CAP)\n            \n        all_results.append(C_max_val)\n        all_results.append(h_rec_val)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "3605853"}, {"introduction": "The non-Hermitian nature of the optical model Hamiltonian has profound consequences for the underlying quantum mechanical formalism, as the familiar properties of Hermitian operators no longer apply. For a non-Hermitian Hamiltonian, the \"left\" and \"right\" eigenstates form a bi-orthogonal set, meaning the inner product of a left eigenstate with its corresponding right eigenstate can be normalized, but the states are not orthogonal in the usual sense. This comprehensive practice [@problem_id:3605869] demonstrates a cornerstone of non-Hermitian quantum mechanics: physical observables like the differential cross-section are invariant under the choice of bi-orthogonal normalization. By implementing a full scattering calculation, you will verify this invariance explicitly and gain confidence that the optical model, despite its mathematical peculiarities, provides a consistent and predictive physical theory.", "problem": "You are asked to design and implement a complete numerical program that demonstrates bi-orthogonal normalization for non-Hermitian scattering in the Optical Model (OM) for elastic nucleon-nucleus scattering, and verifies that the observable differential cross section remains invariant under such normalization choices. The setting is a central, complex Woods–Saxon optical potential and partial-wave scattering of a neutron. The base of your derivation must start from the time-independent Schrödinger equation and the fundamental definition of bi-orthogonality for non-Hermitian Hamiltonians.\n\nConstruct the following, starting from first principles:\n- Consider the radial time-independent Schrödinger equation for a neutron of mass $m$ scattering elastically from a spherically symmetric complex optical potential $U(r)$ in the partial wave $l$, on the radial interval $r \\in [0,R_{\\text{max}}]$. You must start from the equation of motion and impose the finite-at-origin regularity condition. Use $m$ equal to the neutron mass. Treat the reduced mass as $m$ (which is valid for a very heavy target).\n- Treat the Optical Model potential as a Woods–Saxon form $U(r) = V f(r) + i W f(r)$ with $f(r) = [1 + \\exp((r - R)/a)]^{-1}$. Use $R = r_0 A^{1/3}$.\n- For each partial wave $l$ in a specified range, compute the \"right\" radial solution $u_R(r)$ of the non-Hermitian Schrödinger equation with $U(r)$ and the \"left\" radial solution $u_L(r)$ of the adjoint equation with $U^*(r)$. Impose identical regular boundary conditions at small $r$, and integrate outward to $R_{\\text{max}}$ along a uniform grid using a high-accuracy three-point method suitable for second-order differential equations. Define the bi-orthogonal inner product as $\\langle u_L|u_R\\rangle = \\int_0^{R_{\\text{max}}} u_L^*(r)\\,u_R(r)\\,dr$.\n- Normalize $\\{u_L,u_R\\}$ for each $l$ so that $\\langle u_L|u_R\\rangle = 1$ holds. Demonstrate that there are infinitely many such bi-orthogonal normalizations: for any nonzero scaling factor $\\alpha \\in \\mathbb{R}$ applied to $u_R$, there exists a reciprocal complex scale applied to $u_L$ that preserves $\\langle u_L|u_R\\rangle=1$. Implement two distinct normalization choices characterized by $\\alpha_1$ and $\\alpha_2$, and ensure in both cases that $\\langle u_L|u_R\\rangle = 1$ is satisfied separately for each $l$.\n- From the asymptotic region beyond the range of $U(r)$ (use a matching radius $R_{\\text{match}}$ where the potential is negligible), derive and compute the scattering matrix $S_l$ for each partial wave using the outward-integrated $u_R(r)$ and the free-space asymptotic basis. Assemble the on-shell scattering amplitude $f(\\theta)$ from the $S_l$ and the Legendre polynomials, and then compute the differential cross section $d\\sigma/d\\Omega = |f(\\theta)|^2$.\n- Verify explicitly that the normalization choices characterized by $\\alpha_1$ and $\\alpha_2$ do not alter the observable $d\\sigma/d\\Omega$ at any angle. Quantify numerical agreement by computing, for each test case, the maximum absolute difference between the two $d\\sigma/d\\Omega(\\theta)$ sets across a prescribed list of angles.\n\nUse the following physical and numerical units:\n- Energies are in megaelectronvolts (MeV).\n- Radii are in femtometres (fm).\n- The angle $\\theta$ is in radians.\n- The neutron mass $m$ is $939.565\\ \\text{MeV}$ in natural units where $c=1$, and $\\hbar c = 197.3269804\\ \\text{MeV fm}$; use $\\hbar$ expressed in $\\text{MeV fm}$. Express $d\\sigma/d\\Omega$ in $\\text{fm}^2/\\text{sr}$.\n\nTest suite:\n- Case 1 (absorptive optical model, multiple partial waves): $A=90$, $E=10$ MeV, $V=-50$ MeV, $W=-5$ MeV, $r_0=1.25$ fm, $a=0.65$ fm, $l_{\\max}=3$, $R_{\\text{max}}=20$ fm, $R_{\\text{match}}=18$ fm, angles $\\theta \\in \\{0.0, 0.5, 1.0, 1.5, \\pi\\}$, $\\alpha_1=0.5$, $\\alpha_2=3.0$.\n- Case 2 (Hermitian limit, $s$-wave only): $A=208$, $E=5$ MeV, $V=-50$ MeV, $W=0$ MeV, $r_0=1.25$ fm, $a=0.65$ fm, $l_{\\max}=0$, $R_{\\text{max}}=20$ fm, $R_{\\text{match}}=18$ fm, angles $\\theta \\in \\{0.0, \\pi/3, 2\\pi/3, \\pi\\}$, $\\alpha_1=1.0$, $\\alpha_2=2.0$.\n- Case 3 (strong absorption, higher energy): $A=40$, $E=50$ MeV, $V=-40$ MeV, $W=-20$ MeV, $r_0=1.25$ fm, $a=0.6$ fm, $l_{\\max}=4$, $R_{\\text{max}}=20$ fm, $R_{\\text{match}}=18$ fm, angles $\\theta \\in \\{0.0, 0.3, 0.9, 1.5, \\pi\\}$, $\\alpha_1=0.7$, $\\alpha_2=1.8$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each entry is the maximum absolute difference in $d\\sigma/d\\Omega$ between the two normalization choices for that case, in $\\text{fm}^2/\\text{sr}$, ordered as Case 1, Case 2, Case 3. For example, an output like \"[$x_1,x_2,x_3$]\" where each $x_i$ is a floating-point number.", "solution": "We begin from the time-independent Schrödinger equation for a neutron scattering elastically from a spherically symmetric complex potential. In natural units with speed of light $c=1$, the reduced mass is taken as the neutron mass $m$. The radial equation for partial wave $l$ and radial function $u(r)$ is\n$$\n\\frac{d^2 u(r)}{dr^2} + \\left[k^2 - \\frac{2 m}{\\hbar^2} U(r) - \\frac{l(l+1)}{r^2}\\right] u(r) = 0,\n$$\nwhere $k$ is the asymptotic wave number determined by the kinetic energy $E$ via\n$$\nE = \\frac{\\hbar^2 k^2}{2 m} \\quad \\Rightarrow \\quad k = \\sqrt{\\frac{2 m E}{\\hbar^2}}.\n$$\nThe Optical Model (OM) potential is chosen to be a complex Woods–Saxon form,\n$$\nU(r) = V f(r) + i W f(r), \\quad f(r) = \\frac{1}{1 + \\exp\\left(\\frac{r - R}{a}\\right)}, \\quad R = r_0 A^{1/3},\n$$\nwith real parameters $V$ and $W$ and target mass number $A$. The centrifugal term $\\frac{l(l+1)}{r^2}$ enforces regular behavior at the origin; the regular solution satisfies $u(r) \\sim r^{l+1}$ as $r \\to 0$.\n\nFor non-Hermitian $U(r)$, the Hamiltonian $H = T + U$ is not equal to its adjoint $H^\\dagger = T + U^*$. Right eigenfunctions satisfy $(T + U) u_R = E u_R$, while left eigenfunctions satisfy $(T + U^*) u_L = E u_L$. The natural bi-orthogonal inner product pairing between left and right functions is\n$$\n\\langle u_L | u_R \\rangle = \\int_0^{R_{\\text{max}}} u_L^*(r)\\,u_R(r)\\,dr,\n$$\nwhere $R_{\\text{max}}$ is a finite radial cutoff beyond which the potential is negligible and the solutions approach free behavior. For scattering states, this pairing is defined over the finite interval with consistent boundary conditions and grid.\n\nBi-orthogonal normalization and scaling invariance:\nSuppose we have computed a pair $(u_{L,0}, u_{R,0})$ for a given $l$, with inner product\n$$\nI_0 = \\int_0^{R_{\\text{max}}} u_{L,0}^*(r)\\,u_{R,0}(r)\\,dr.\n$$\nFor any nonzero real scaling $\\alpha$, define a rescaled pair\n$$\nu_R(r) = \\alpha\\, u_{R,0}(r), \\quad u_L(r) = \\beta\\, u_{L,0}(r),\n$$\nwith $\\beta$ chosen so that $\\langle u_L|u_R\\rangle = 1$. Since\n$$\n\\langle u_L|u_R\\rangle = \\int_0^{R_{\\text{max}}} (\\beta u_{L,0})^*(r)\\,(\\alpha u_{R,0}(r))\\,dr\n= \\alpha\\,\\beta^*\\, I_0,\n$$\nthe condition $\\langle u_L|u_R\\rangle = 1$ is satisfied by choosing\n$$\n\\beta^* = \\frac{1}{\\alpha I_0} \\quad \\Rightarrow \\quad \\beta = \\frac{1}{\\alpha I_0^*}.\n$$\nThus, there is a one-parameter family of bi-orthogonal normalizations indexed by $\\alpha \\in \\mathbb{R}\\setminus\\{0\\}$.\n\nScattering matrix from asymptotic matching:\nBeyond a matching radius $R_{\\text{match}}$ where $U(r)$ is negligible, the radial solution can be expressed as a superposition of free spherical waves. For each $l$, an external solution can be represented using spherical Hankel functions $h_l^{(\\pm)}(x) = j_l(x) \\pm i y_l(x)$, where $x = k r$, $j_l$ and $y_l$ are spherical Bessel and Neumann functions. A standard representation uses\n$$\nu(r) \\propto h_l^{(-)}(kr) - S_l\\, h_l^{(+)}(kr),\n$$\nwhere $S_l$ is the partial-wave scattering matrix element. Let $u_m = u(R_{\\text{match}})$ and $u'_m = \\left.\\frac{du}{dr}\\right|_{r=R_{\\text{match}}}$ for the outward-integrated right solution. Define the logarithmic derivative at the matching radius\n$$\nL_l = \\frac{u'_m}{u_m}.\n$$\nLet $x_m = k R_{\\text{match}}$, $h_\\pm = h_l^{(\\pm)}(x_m)$, and $h'_\\pm = \\left.\\frac{dh_l^{(\\pm)}(x)}{dx}\\right|_{x=x_m}$. Matching $u$ and $u'$ to the external form yields the algebraic relation\n$$\nS_l = \\frac{k h'_-(x_m) - L_l\\, h_-(x_m)}{k h'_+(x_m) - L_l\\, h_+(x_m)}.\n$$\nThis expression depends on the ratio $L_l = u'_m/u_m$ and not on the absolute normalization of $u$. Therefore, any uniform scaling $u \\to \\alpha u$ cancels in $L_l$ and leaves $S_l$ invariant. Since the observable differential cross section $d\\sigma/d\\Omega$ is constructed from $\\{S_l\\}$, it is invariant under such rescaling.\n\nScattering amplitude and differential cross section:\nFor a central potential, the elastic scattering amplitude is given by the partial-wave expansion\n$$\nf(\\theta) = \\frac{1}{2 i k} \\sum_{l=0}^{l_{\\max}} (2 l + 1)\\,\\left(S_l - 1\\right)\\,P_l(\\cos\\theta),\n$$\nwhere $P_l$ are Legendre polynomials and $\\theta$ is the scattering angle in radians. The observable differential cross section is\n$$\n\\frac{d\\sigma}{d\\Omega}(\\theta) = |f(\\theta)|^2,\n$$\nin units of $\\text{fm}^2/\\text{sr}$ when $k$ is in $\\text{fm}^{-1}$.\n\nAlgorithmic design:\n- Compute constants: use $\\hbar c = 197.3269804\\ \\text{MeV fm}$ and $m = 939.565\\ \\text{MeV}$; then $\\hbar = \\hbar c$ and $k = \\sqrt{2 m E}/\\hbar$ for each case.\n- Construct a uniform radial grid $r_n$ from a small $r_0$ (avoid $r=0$) to $R_{\\text{max}}$ with step $h$. For each $l$, form\n$$\nQ_l(r) = k^2 - \\frac{2 m}{\\hbar^2} U(r) - \\frac{l(l+1)}{r^2},\n$$\nand integrate $u'' + Q_l u = 0$ using Numerov's method, which for a second-order linear differential equation with smoothly varying $Q(r)$ provides high accuracy. Impose regular initial conditions $u(r_0) = r_0^{l+1}$ and $u(r_0 + h) = (r_0 + h)^{l+1}$, and integrate outward.\n- For the left solution, integrate the adjoint equation with $U^*(r)$ to obtain $u_L(r)$ starting from the same regular initial conditions. Compute the inner product\n$$\nI_0^{(l)} = \\int_0^{R_{\\text{max}}} u_L^*(r)\\,u_R(r)\\,dr\n$$\nusing numerical quadrature (e.g., the trapezoidal rule). For each $l$, construct two normalization choices $\\alpha_1$ and $\\alpha_2$, and paired scalings $\\beta_1^{(l)} = 1/(\\alpha_1 [I_0^{(l)}]^*)$ and $\\beta_2^{(l)} = 1/(\\alpha_2 [I_0^{(l)}]^*)$, so that $\\langle u_L|u_R\\rangle = 1$ holds for each choice separately for every $l$.\n- For each normalization choice, compute the logarithmic derivative $L_l$ at $R_{\\text{match}}$ using the rescaled $u_R$ and $u'_R$ (via finite differences). Then compute $S_l$ using spherical Bessel and Neumann functions to form $h_l^{(\\pm)}$ and their derivatives. Since $L_l$ is invariant under uniform scaling, $S_l$ will be numerically equal across both normalization choices.\n- Assemble $f(\\theta)$ from $\\{S_l\\}$ and compute $d\\sigma/d\\Omega(\\theta) = |f(\\theta)|^2$ for the prescribed angles. For each test case, compute the maximum absolute difference between the two $d\\sigma/d\\Omega(\\theta)$ sets across its angle list; this value should be numerically very close to $0$ because the observable is invariant under bi-orthogonal rescaling.\n\nOutputs and units:\n- The final program prints one line containing a list of three floating-point values, one per test case, representing the maximum absolute difference in $d\\sigma/d\\Omega$ across angles between the two normalization choices, in $\\text{fm}^2/\\text{sr}$. Angles are in radians, energies in MeV, and radii in fm.\n\nThis construction tests:\n- In Case 1, a typical absorptive OM with several partial waves and multiple angles.\n- In Case 2, the Hermitian limit ($W=0$) and $s$-wave only ($l_{\\max}=0$) as a boundary case.\n- In Case 3, stronger absorption at higher energy and more partial waves.\n\nThe invariance result follows from the dependence of $S_l$ on the logarithmic derivative $L_l$ only, which cancels any overall $u_R$ scaling, and from the fact that the OM amplitude and $d\\sigma/d\\Omega$ are determined by $\\{S_l\\}$ independently of the bi-orthogonal normalization imposed on $\\{u_L,u_R\\}$. Numerically, any small residual differences would arise only from finite discretization and floating-point roundoff, and should be negligible compared to the absolute scale of the cross section.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import spherical_jn, spherical_yn, lpmv\n\n# Physical constants in natural units (c=1)\nHBAR_C = 197.3269804  # MeV fm\nHBAR = HBAR_C         # MeV fm\nM_NEUTRON = 939.565   # MeV\n\ndef woods_saxon(r, V, W, R, a):\n    \"\"\"Complex Woods–Saxon potential U(r) = (V + i W) f(r).\"\"\"\n    f = 1.0 / (1.0 + np.exp((r - R) / a))\n    return (V + 1j * W) * f\n\ndef numerov_integrate(l, k, U_arr, r, m, hbar):\n    \"\"\"\n    Integrate u'' + Q(r) u = 0 with Q(r) = k^2 - (2m/hbar^2) U(r) - l(l+1)/r^2\n    using the Numerov method. Returns complex u(r).\n    \"\"\"\n    h = r[1] - r[0]\n    # Avoid division by zero at r=0: assume r[0]  0\n    Q = k**2 - (2.0 * m / (hbar**2)) * U_arr - (l * (l + 1)) / (r**2)\n    N = len(r)\n    u = np.zeros(N, dtype=np.complex128)\n    # Regular initial conditions near the origin: u ~ r^{l+1}\n    u[0] = r[0]**(l + 1)\n    u[1] = r[1]**(l + 1)\n    # Numerov recurrence\n    # u_{n+1} = [2 u_n (1 - 5 h^2 Q_n/12) - u_{n-1} (1 + h^2 Q_{n-1}/12)] / (1 + h^2 Q_{n+1}/12)\n    h2 = h * h\n    for n in range(1, N - 1):\n        c1 = 2.0 * u[n] * (1.0 - (5.0 * h2 * Q[n] / 12.0))\n        c2 = u[n - 1] * (1.0 + (h2 * Q[n - 1] / 12.0))\n        denom = (1.0 + (h2 * Q[n + 1] / 12.0))\n        # Avoid zero denominator by small regularization (rare)\n        if denom == 0:\n            denom = 1e-16 + 0j\n        u[n + 1] = (c1 - c2) / denom\n    return u\n\ndef log_derivative(u, r, r_match_index):\n    \"\"\"Compute logarithmic derivative L = u'/u at r_match using central difference for u'.\"\"\"\n    h = r[1] - r[0]\n    n = r_match_index\n    # Use central difference where possible; fall back to one-sided at boundaries\n    if 1 = n = len(r) - 2:\n        uprime = (u[n + 1] - u[n - 1]) / (2.0 * h)\n    elif n == 0:\n        uprime = (u[1] - u[0]) / h\n    else:\n        uprime = (u[n] - u[n - 1]) / h\n    if u[n] == 0:\n        return np.inf + 0j\n    return uprime / u[n]\n\ndef S_l_from_match(l, k, L, r_match):\n    \"\"\"Compute S_l using matching formula with spherical Hankel functions at r_match.\"\"\"\n    x = k * r_match\n    # Spherical Hankel functions h^{(+)} = j + i y, h^{(-)} = j - i y\n    j = spherical_jn(l, x)\n    y = spherical_yn(l, x)\n    jp = spherical_jn(l, x, derivative=True)\n    yp = spherical_yn(l, x, derivative=True)\n    h_plus = j + 1j * y\n    h_minus = j - 1j * y\n    h_plus_p = jp + 1j * yp  # derivative with respect to x\n    h_minus_p = jp - 1j * yp\n    # S = (k h_- ' - L h_-)/(k h_+ ' - L h_+)\n    num = k * h_minus_p - L * h_minus\n    den = k * h_plus_p - L * h_plus\n    # Avoid division by zero\n    if den == 0:\n        return np.nan + 0j\n    return num / den\n\ndef scattering_amplitude(k, S_list, thetas):\n    \"\"\"Compute f(theta) = (1/(2ik)) sum_{l}(2l+1)(S_l - 1) P_l(cos theta).\"\"\"\n    fvals = []\n    cos_t = np.cos(thetas)\n    for ct in cos_t:\n        f = 0.0 + 0.0j\n        for l, S in enumerate(S_list):\n            P_l = lpmv(0, l, ct)  # Legendre polynomial P_l(ct)\n            f += (2 * l + 1) * (S - 1.0) * P_l\n        f *= 1.0 / (2.0j * k)\n        fvals.append(f)\n    return np.array(fvals, dtype=np.complex128)\n\ndef differential_cross_section(fvals):\n    \"\"\"Return dσ/dΩ = |f(theta)|^2 in fm^2/sr.\"\"\"\n    return np.abs(fvals)**2\n\ndef inner_product_biorth(uL, uR, r):\n    \"\"\"Compute ⟨uL|uR⟩ = ∫ uL^*(r) uR(r) dr using trapezoidal rule.\"\"\"\n    integrand = np.conjugate(uL) * uR\n    return np.trapz(integrand, r)\n\ndef compute_case(case):\n    \"\"\"\n    Compute the maximum absolute difference in dσ/dΩ between two bi-orthogonal normalizations.\n    case: dict with parameters.\n    \"\"\"\n    # Unpack parameters\n    A = case[\"A\"]\n    E = case[\"E\"]  # MeV\n    V = case[\"V\"]\n    W = case[\"W\"]\n    r0 = case[\"r0\"]\n    a = case[\"a\"]\n    lmax = case[\"lmax\"]\n    Rmax = case[\"Rmax\"]\n    Rmatch = case[\"Rmatch\"]\n    angles = np.array(case[\"angles\"], dtype=float)\n    alpha1 = case[\"alpha1\"]\n    alpha2 = case[\"alpha2\"]\n\n    # Compute derived parameters\n    R = r0 * (A ** (1.0 / 3.0))\n    m = M_NEUTRON  # MeV\n    hbar = HBAR    # MeV fm\n    k = np.sqrt(2.0 * m * E) / hbar  # fm^{-1}\n\n    # Radial grid\n    h = 0.01  # fm step\n    # Avoid r=0 to handle centrifugal term; start at a small r0g = h\n    r = np.arange(h, Rmax + h/2.0, h, dtype=float)\n    # Matching index closest to Rmatch\n    idx_match = int(np.argmin(np.abs(r - Rmatch)))\n    r_match = r[idx_match]\n\n    # Precompute potential on grid\n    U_arr = woods_saxon(r, V, W, R, a)\n    U_adj_arr = np.conjugate(U_arr)\n\n    # For each l, compute right and left solutions, and two normalizations\n    # Store S_l for both normalizations; invariance should hold\n    S_list_1 = []\n    S_list_2 = []\n\n    for l in range(lmax + 1):\n        # Integrate right and left equations\n        uR0 = numerov_integrate(l, k, U_arr, r, m, hbar)\n        uL0 = numerov_integrate(l, k, U_adj_arr, r, m, hbar)\n\n        # Compute inner product I0^l\n        I0 = inner_product_biorth(uL0, uR0, r)\n\n        # Build normalization 1: alpha1 for uR, beta1 = 1/(alpha1 * I0^*)\n        beta1 = 1.0 / (alpha1 * np.conjugate(I0))\n        uR1 = alpha1 * uR0\n        uL1 = beta1 * uL0\n        # Check inner product (not printed): should be ~1\n        # I1 = inner_product_biorth(uL1, uR1, r)\n\n        # Normalization 2: alpha2 for uR, beta2 similarly\n        beta2 = 1.0 / (alpha2 * np.conjugate(I0))\n        uR2 = alpha2 * uR0\n        uL2 = beta2 * uL0\n        # I2 = inner_product_biorth(uL2, uR2, r)\n\n        # Compute logarithmic derivatives at match for both uR variants\n        L1 = log_derivative(uR1, r, idx_match)\n        L2 = log_derivative(uR2, r, idx_match)\n\n        # Compute S_l for both normalizations\n        S1 = S_l_from_match(l, k, L1, r_match)\n        S2 = S_l_from_match(l, k, L2, r_match)\n\n        S_list_1.append(S1)\n        S_list_2.append(S2)\n\n    # Assemble amplitudes and cross sections for both normalizations\n    f1 = scattering_amplitude(k, S_list_1, angles)\n    f2 = scattering_amplitude(k, S_list_2, angles)\n    dsdo1 = differential_cross_section(f1)\n    dsdo2 = differential_cross_section(f2)\n\n    # Maximum absolute difference across angles\n    max_diff = float(np.max(np.abs(dsdo1 - dsdo2)))\n    return max_diff\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"A\": 90, \"E\": 10.0, \"V\": -50.0, \"W\": -5.0,\n            \"r0\": 1.25, \"a\": 0.65,\n            \"lmax\": 3,\n            \"Rmax\": 20.0, \"Rmatch\": 18.0,\n            \"angles\": [0.0, 0.5, 1.0, 1.5, np.pi],\n            \"alpha1\": 0.5, \"alpha2\": 3.0\n        },\n        {\n            \"A\": 208, \"E\": 5.0, \"V\": -50.0, \"W\": 0.0,\n            \"r0\": 1.25, \"a\": 0.65,\n            \"lmax\": 0,\n            \"Rmax\": 20.0, \"Rmatch\": 18.0,\n            \"angles\": [0.0, np.pi/3, 2*np.pi/3, np.pi],\n            \"alpha1\": 1.0, \"alpha2\": 2.0\n        },\n        {\n            \"A\": 40, \"E\": 50.0, \"V\": -40.0, \"W\": -20.0,\n            \"r0\": 1.25, \"a\": 0.6,\n            \"lmax\": 4,\n            \"Rmax\": 20.0, \"Rmatch\": 18.0,\n            \"angles\": [0.0, 0.3, 0.9, 1.5, np.pi],\n            \"alpha1\": 0.7, \"alpha2\": 1.8\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_case(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3605869"}]}