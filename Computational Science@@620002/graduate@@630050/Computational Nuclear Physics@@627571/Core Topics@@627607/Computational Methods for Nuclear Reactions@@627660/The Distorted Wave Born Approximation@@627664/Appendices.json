{"hands_on_practices": [{"introduction": "A powerful piece of physical intuition in nuclear reactions is the semi-classical connection between the reaction's geometry and the angular momenta involved. This practice explores this link by modeling a reaction with a surface-peaked transition operator. By calculating the contributions from different partial waves, you will quantitatively see how the interaction radius $R$ and momentum $k$ select a dominant orbital angular momentum $\\ell$, validating the simple estimate $\\ell \\approx kR$. [@problem_id:3598601]", "problem": "Consider a simplified Distorted Wave Born Approximation (DWBA) analysis of inelastic nuclear scattering with a central, spin-independent transition operator that is surface-peaked. The DWBA amplitude is given by the overlap of incoming and outgoing distorted waves with the transition operator, integrated over three-dimensional space. Begin from the fundamental scattering formulation: the DWBA transition amplitude between an initial channel and a final channel is the volume integral of the product of the outgoing distorted wave, the transition operator, and the incoming distorted wave. Use spherical coordinates and the partial wave expansion of scattering states to argue how the angular dependence is separated by spherical harmonics and how monopole angular structure preserves orbital angular momentum. Adopt the following toy-model assumptions grounded in standard scattering theory to obtain a radial integral that can be evaluated numerically:\n\n- The distorted waves are approximated by spherical Bessel functions and spherical harmonics, that is, the incoming and outgoing radial distorted waves are taken as $u_{\\ell}(k,r) \\propto j_{\\ell}(k r)$, where $j_{\\ell}$ is the spherical Bessel function of order $\\ell$ and $k$ is the wave number. This approximation corresponds to the plane-wave limit for the radial part and is suitable for a surface-peaked operator analysis.\n- The transition operator is surface-peaked and given by the radial form $$V_{tr}(r) = V_0 \\exp\\left(-\\frac{(r - R)^2}{a^2}\\right),$$ where $V_0$ sets the scale (take $V_0$ as an arbitrary positive scalar), $R$ is the characteristic radius, and $a$ is the surface diffuseness.\n- Due to the angular selection rules for a monopole operator, only equal incoming and outgoing orbital angular momenta contribute; therefore, one can study the $\\ell$-resolved radial integral that defines the partial contribution to the DWBA amplitude.\n\nYour task is to implement a program that, for each specified parameter set, computes the relative weights of partial-wave contributions and determines which orbital angular momentum $\\ell$ dominates the DWBA amplitude. Specifically:\n\n1. Derive from first principles why the partial wave amplitude for a monopole transition can be reduced to a radial integral of the form of an overlap between $j_{\\ell}(k r)$ functions and $V_{tr}(r)$, integrated with the radial volume element. Argue the key role of angular momentum conservation and the orthogonality of spherical harmonics in eliminating cross terms with $\\ell \\neq \\ell'$.\n2. For each $\\ell$ in a range $\\ell = 0, 1, \\dots, \\ell_{\\max}$, numerically evaluate a radial integral proportional to\n$$\nT_{\\ell} \\propto \\int_{0}^{\\infty} r^2 \\, j_{\\ell}(k r) \\, j_{\\ell}(k r) \\, V_{tr}(r) \\, dr,\n$$\nwith the Gaussian $V_{tr}(r)$ defined above. To make the integral numerically tractable, replace the upper limit $\\infty$ by a sufficiently large finite cutoff determined from $R$, $a$, and $k$ so that the Gaussian factor and oscillatory terms are adequately captured.\n3. Form the normalized weights\n$$\nw_{\\ell} = \\dfrac{|T_{\\ell}|^2}{\\sum_{\\ell'=0}^{\\ell_{\\max}} |T_{\\ell'}|^2},\n$$\nand identify the dominant orbital angular momentum $\\ell_{\\text{dom}}$ that maximizes $w_{\\ell}$ for each parameter set. The normalization ensures the results are dimensionless and independent of the absolute scale $V_0$.\n4. Use the following scientifically plausible test suite of parameter sets. All radii $R$ are in femtometers, all diffuseness values $a$ are in femtometers, and all wave numbers $k$ are in inverse femtometers. The program should consider $\\ell$ values from $0$ up to $\\ell_{\\max}$ as specified in each case. Note that the output is unitless. Test cases:\n   - Case $1$: $R = 5.0$, $a = 0.4$, $k = 1.0$, $\\ell_{\\max} = 12$.\n   - Case $2$: $R = 5.0$, $a = 2.0$, $k = 0.3$, $\\ell_{\\max} = 8$.\n   - Case $3$: $R = 2.0$, $a = 0.3$, $k = 1.2$, $\\ell_{\\max} = 10$.\n   - Case $4$: $R = 0.0$, $a = 0.2$, $k = 1.0$, $\\ell_{\\max} = 6$.\n5. Your program should produce a single line of output containing the dominant $\\ell$ for the four test cases as a comma-separated list enclosed in square brackets, for example, $[2,5,3,0]$. No additional text should be printed.\n\nYour derivation must start from the foundational DWBA amplitude definition and standard properties of spherical harmonics and spherical Bessel functions. Avoid introducing any nonphysical assumptions. The numerical evaluation must be robust with respect to oscillatory behavior of $j_{\\ell}(k r)$ and the surface-peaked Gaussian. The final line of output must be unitless integers as specified, and the angle unit is not applicable in this problem because no explicit angular quantities are returned.", "solution": "The problem is scientifically and mathematically well-posed. The assumptions, though simplifying, are grounded in the standard formalism of quantum scattering theory, specifically the Distorted Wave Born Approximation (DWBA). All parameters are clearly defined, and the task is to derive a standard result and implement its numerical evaluation. Therefore, I will proceed with a full solution.\n\nThe solution is divided into two parts: first, a derivation of the partial-wave radial integral from the fundamental DWBA transition amplitude, and second, the design of the numerical algorithm to compute the dominant angular momentum contribution.\n\n### 1. Derivation of the Partial-Wave Radial Integral\n\nThe Distorted Wave Born Approximation (DWBA) transition amplitude, $T_{fi}$, for a scattering process from an initial channel $i$ to a final channel $f$ is given by the matrix element of the transition operator $V_{tr}$ between the final and initial scattering states, $\\Psi_f^{(-)}(\\mathbf{r})$ and $\\Psi_i^{(+)}(\\mathbf{r})$:\n$$\nT_{fi} = \\langle \\Psi_f^{(-)} | V_{tr} | \\Psi_i^{(+)} \\rangle = \\int \\Psi_f^{(-)*}(\\mathbf{r}) V_{tr}(\\mathbf{r}) \\, d^3\\mathbf{r}\n$$\nHere, $\\Psi_i^{(+)}(\\mathbf{r})$ represents the initial state with incoming-wave boundary conditions, and $\\Psi_f^{(-)}(\\mathbf{r})$ is the final state with outgoing-wave boundary conditions. The problem specifies a central, spin-independent transition operator, meaning it depends only on the radial coordinate $r = |\\mathbf{r}|$, so $V_{tr}(\\mathbf{r}) = V_{tr}(r)$.\n\nThe scattering states are expanded in partial waves using spherical harmonics $Y_{\\ell m}(\\hat{\\mathbf{r}})$ as the angular basis. The problem states that the radial part of the distorted waves is approximated by spherical Bessel functions, which is a simplification corresponding to the Plane Wave Born Approximation. A general partial wave expansion for a scattering state is of the form:\n$$\n\\Psi_{\\mathbf{k}}(\\mathbf{r}) = \\sum_{\\ell=0}^{\\infty} \\sum_{m=-\\ell}^{\\ell} A_{\\ell m} \\frac{\\chi_{\\ell}(k,r)}{r} Y_{\\ell m}(\\hat{\\mathbf{r}})\n$$\nwhere $A_{\\ell m}$ are expansion coefficients and $\\chi_{\\ell}(k,r)$ is the radial wave function. With the given approximation, $\\chi_{\\ell}(k,r)/r$ is proportional to the spherical Bessel function of order $\\ell$, $j_{\\ell}(kr)$. Let's assume the initial and final states are expanded as:\n$$\n\\Psi_i^{(+)}(\\mathbf{r}) \\propto \\sum_{\\ell m} C_{\\ell m}^{(i)} j_{\\ell}(k_i r) Y_{\\ell m}(\\hat{\\mathbf{r}})\n$$\n$$\n\\Psi_f^{(-)*}(\\mathbf{r}) \\propto \\sum_{\\ell' m'} C_{\\ell' m'}^{(f)*} j_{\\ell'}(k_f r) Y_{\\ell' m'}^*(\\hat{\\mathbf{r}})\n$$\nFor this analysis, we assume near-elastic scattering, so the initial and final wave numbers are approximately equal, $k_i \\approx k_f = k$.\n\nSubstituting these expansions into the expression for $T_{fi}$ and using the volume element in spherical coordinates, $d^3\\mathbf{r} = r^2 dr \\, d\\Omega$, we get:\n$$\nT_{fi} \\propto \\int \\left( \\sum_{\\ell' m'} C_{\\ell' m'}^{(f)*} j_{\\ell'}(kr) Y_{\\ell' m'}^*(\\hat{\\mathbf{r}}) \\right) V_{tr}(r) \\left( \\sum_{\\ell m} C_{\\ell m}^{(i)} j_{\\ell}(kr) Y_{\\ell m}(\\hat{\\mathbf{r}}) \\right) r^2 dr \\, d\\Omega\n$$\nSince $V_{tr}(r)$ is independent of angle, we can separate the integral into radial and angular parts and rearrange the sums:\n$$\nT_{fi} \\propto \\sum_{\\ell m} \\sum_{\\ell' m'} C_{\\ell' m'}^{(f)*} C_{\\ell m}^{(i)} \\left( \\int_0^\\infty r^2 j_{\\ell'}(kr) j_{\\ell}(kr) V_{tr}(r) \\, dr \\right) \\left( \\int Y_{\\ell' m'}^*(\\hat{\\mathbf{r}}) Y_{\\ell m}(\\hat{\\mathbf{r}}) \\, d\\Omega \\right)\n$$\nThe key step is to evaluate the angular integral, which relies on the orthogonality of spherical harmonics:\n$$\n\\int Y_{\\ell' m'}^*(\\hat{\\mathbf{r}}) Y_{\\ell m}(\\hat{\\mathbf{r}}) \\, d\\Omega = \\delta_{\\ell \\ell'} \\delta_{m m'}\n$$\nThe Kronecker deltas, $\\delta_{\\ell \\ell'}$ and $\\delta_{m m'}$, enforce the conservation of orbital angular momentum and its projection. They are non-zero only when $\\ell = \\ell'$ and $m = m'$, which eliminates all cross-terms in the double summation. This selection rule is a direct consequence of the operator $V_{tr}(r)$ being central (a scalar operator). The problem statement refers to a \"monopole\" transition, which implies the transfer of zero angular momentum ($L=0$), correctly leading to $\\ell_{\\text{initial}} = \\ell_{\\text{final}}$.\n\nApplying the orthogonality relation, the transition amplitude simplifies to a single sum over partial waves:\n$$\nT_{fi} \\propto \\sum_{\\ell m} C_{\\ell m}^{(f)*} C_{\\ell m}^{(i)} \\int_0^\\infty r^2 j_{\\ell}(kr) j_{\\ell}(kr) V_{tr}(r) \\, dr\n$$\nThe total amplitude is a coherent sum of contributions from each partial wave $\\ell$. The radial integral, which we denote as $T_{\\ell}$, determines the strength of the contribution for a given $\\ell$:\n$$\nT_{\\ell} = \\int_0^\\infty r^2 [j_{\\ell}(kr)]^2 V_{tr}(r) \\, dr\n$$\nThis is the integral form provided in the problem statement, and its derivation from first principles is now complete. The problem asks to analyze the relative weights of these partial waves, which are proportional to $|T_{\\ell}|^2$. Since $T_{\\ell}$ is an integral of real-valued functions, $|T_{\\ell}|^2 = T_{\\ell}^2$.\n\n### 2. Numerical Evaluation and Algorithm Design\n\nThe goal is to find the dominant orbital angular momentum $\\ell_{\\text{dom}}$, which is the value of $\\ell$ that maximizes the partial-wave contribution. This is achieved by computing the normalized weights $w_{\\ell}$:\n$$\nw_{\\ell} = \\frac{T_{\\ell}^2}{\\sum_{\\ell'=0}^{\\ell_{\\max}} T_{\\ell'}^2}\n$$\nThe numerical algorithm proceeds as follows:\n\n1.  **Define the Integrand**: The transition operator is $V_{tr}(r) = V_0 \\exp\\left(-\\frac{(r-R)^2}{a^2}\\right)$. Since the weights $w_{\\ell}$ are normalized, the constant $V_0$ cancels out and can be set to $1$. The integrand for $T_{\\ell}$ is:\n $$ f(r; \\ell, k, R, a) = r^2 [j_{\\ell}(kr)]^2 \\exp\\left(-\\frac{(r - R)^2}{a^2}\\right) $$\n2.  **Set Integration Limits**: The integral is over $[0, \\infty)$. For numerical computation, the upper limit is replaced by a finite cutoff $r_{\\max}$ chosen to be large enough such that the integrand becomes negligible. The Gaussian factor $\\exp(-((r-R)/a)^2)$ decays rapidly for $r > R + Na$ for some $N$. The Bessel functions $j_{\\ell}(kr)$ oscillate, and their first main peak is located approximately at $kr \\approx \\ell$. A robust cutoff must accommodate both behaviors. A suitable choice is $r_{\\max} = \\max(R + 15a, (\\ell_{\\max} + 20)/k)$, which ensures the Gaussian tail is captured and the integration range is wide enough to include the primary features of all relevant Bessel functions up to $\\ell_{\\max}$.\n\n3.  **Compute Partial-Wave Integrals**: For each parameter set $(R, a, k, \\ell_{\\max})$, the algorithm iterates $\\ell$ from $0$ to $\\ell_{\\max}$. In each iteration, the integral $T_{\\ell} = \\int_0^{r_{\\max}} f(r; \\ell, k, R, a) \\, dr$ is computed using a standard numerical quadrature routine, such as `scipy.integrate.quad`.\n\n4.  **Determine Dominant $\\ell$**: After computing the array of $T_{\\ell}$ values for $\\ell \\in [0, \\ell_{\\max}]$, the squared values $T_{\\ell}^2$ are calculated. The dominant angular momentum, $\\ell_{\\text{dom}}$, is the index of the maximum value in this array of squared integrals. This is equivalent to finding the $\\ell$ that maximizes $w_{\\ell}$.\n\nThis procedure is repeated for each of the four test cases provided in the problem statement to find the corresponding $\\ell_{\\text{dom}}$.", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import quad\nfrom scipy.special import spherical_jn\n\ndef solve():\n    \"\"\"\n    Computes the dominant orbital angular momentum for inelastic nuclear scattering\n    using a simplified Distorted Wave Born Approximation (DWBA) model.\n    \"\"\"\n\n    # Test cases: (R, a, k, l_max)\n    # R: characteristic radius (fm)\n    # a: surface diffuseness (fm)\n    # k: wave number (fm^-1)\n    # l_max: maximum orbital angular momentum to consider\n    test_cases = [\n        (5.0, 0.4, 1.0, 12),\n        (5.0, 2.0, 0.3, 8),\n        (2.0, 0.3, 1.2, 10),\n        (0.0, 0.2, 1.0, 6)\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        R, a, k, l_max = case\n\n        # V_0 is set to 1.0 as it cancels out in the normalized weights.\n        V0 = 1.0\n        \n        # The integrand for the radial integral T_ell\n        def integrand(r, l, k_val, R_val, a_val):\n            # Transition operator V_tr(r)\n            v_tr = V0 * np.exp(-((r - R_val) / a_val)**2)\n            \n            # Spherical Bessel function term [j_l(kr)]^2\n            # spherical_jn can return a list, we need the l-th element.\n            # For a scalar l and r, it returns an array of size l+1.\n            # We take the last element which corresponds to order l.\n            # A more robust way is to call it with a specific order `l`.\n            jn_val = spherical_jn(l, k_val * r)\n            \n            return r**2 * jn_val**2 * v_tr\n\n        # Determine a safe upper integration limit\n        # It must be large enough to contain the Gaussian and Bessel function peaks.\n        r_cutoff_gauss = R + 15.0 * a\n        # k can be zero or very small, handle potential division by zero\n        r_cutoff_bessel = (l_max + 20.0) / k if k > 1e-9 else float('inf')\n        r_max = max(r_cutoff_gauss, r_cutoff_bessel)\n        # In case k is very small, r_cutoff_bessel could be huge, cap it.\n        if r_max == float('inf'): r_max = 500.0\n\n\n        T_ell_values = []\n        l_range = range(l_max + 1)\n        \n        for l in l_range:\n            # Numerically compute the radial integral T_ell\n            integral_val, _ = quad(\n                integrand, \n                0, \n                r_max, \n                args=(l, k, R, a),\n                limit=200 # Increase limit for better accuracy with oscillatory functions\n            )\n            T_ell_values.append(integral_val)\n        \n        # The weights w_ell are proportional to |T_ell|^2.\n        # Since T_ell are real, this is T_ell^2.\n        # To find the dominant l, we find the index of the max value of T_ell^2.\n        # Note: np.argmax directly on T_ell_values gives the same index if all values are positive,\n        # which they are, as the integrand is non-negative.\n        # We use T_ell_values**2 to be formally correct.\n        T_ell_sq_arr = np.array(T_ell_values)**2\n        \n        # Find the dominant orbital angular momentum l_dom\n        l_dom = np.argmax(T_ell_sq_arr)\n        results.append(l_dom)\n\n    # Print the final result in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3598601"}, {"introduction": "The predictive power of DWBA relies heavily on the accuracy of the nuclear structure inputs, particularly the bound-state wavefunctions. This exercise investigates the crucial role of the wavefunction's asymptotic tail, which is quantified by the Asymptotic Normalization Constant (ANC). You will numerically demonstrate that peripheral reactions, which are sensitive to the long-range part of the wavefunction, are ideal tools for extracting ANCs, while being relatively insensitive to the complex details of the nuclear interior. [@problem_id:3598529]", "problem": "You will implement a computational model to analyze how the asymptotic normalization constant (ANC) of the bound-state wavefunction alters the distorted wave Born approximation (DWBA) transition amplitude and to demonstrate that angular distributions at forward angles are most sensitive to ANCs rather than to interior structure. The analysis must be carried out by deriving the governing integral from standard scattering theory and then evaluating it numerically for a physically reasonable one-dimensional radial model.\n\nStarting point and definitions: begin from the first Born approximation and the Distorted Wave Born Approximation (DWBA) statements in scattering theory. For a single-nucleon transfer reaction, the DWBA transition amplitude can be written as an integral over the radial coordinate, where the integrand consists of the product of the transition form factor, a bound-state radial wavefunction, and the overlap of initial and final distorted waves. In a plane-wave surrogate for the distorted waves, the angular dependence enters through the momentum transfer. Use the following model and definitions:\n\n- Let the DWBA amplitude be modeled as\n$$\nT_{fi}(\\theta) \\propto \\int_0^{\\infty} r^2\\, u_B(r)\\, f_{\\mathrm{WS}}(r;R_0,a_0)\\, j_0\\!\\big(q(\\theta)\\, r\\big)\\, \\mathrm{d}r,\n$$\nwhere $u_B(r)$ is the bound-state radial wavefunction, $f_{\\mathrm{WS}}(r;R_0,a_0)$ is a Woods–Saxon surface-localized form factor representing the transition potential and surface sensitivity, $j_0(x)$ is the spherical Bessel function of order $0$, and $q(\\theta)$ is the momentum transfer as a function of the scattering angle $\\theta$.\n\n- Define the Woods–Saxon form factor by\n$$\nf_{\\mathrm{WS}}(r;R_0,a_0) = \\frac{1}{1+\\exp\\!\\left(\\frac{r-R_0}{a_0}\\right)},\n$$\nwith parameters $R_0$ and $a_0$ specified below.\n\n- Model the bound-state radial wavefunction as a smooth sum of an interior component and an asymptotic tail weighted by the asymptotic normalization constant (ANC) $C$, switched by a smooth matching function,\n$$\nu_B(r) = u_{\\mathrm{int}}(r)\\,\\big(1-S(r;R_m,a_m)\\big) + C\\,e^{-\\kappa r}\\,S(r;R_m,a_m),\n$$\nwith interior component\n$$\nu_{\\mathrm{int}}(r) = N_{\\mathrm{int}}\\, r\\, e^{-r/R_{\\mathrm{int}}},\n$$\nand matching function\n$$\nS(r;R_m,a_m) = \\frac{1}{1+\\exp\\!\\left(\\frac{R_m - r}{a_m}\\right)}.\n$$\nHere $N_{\\mathrm{int}}$ scales the interior amplitude independently of the ANC $C$, $R_{\\mathrm{int}}$ sets the interior scale, and $(R_m,a_m)$ control where and how the tail switches on.\n\n- The separation energy $S_B$ for the bound state determines the tail inverse length scale\n$$\n\\kappa = \\frac{\\sqrt{2\\,\\mu_B\\, S_B}}{\\hbar c},\n$$\nwhere $\\mu_B$ is the reduced mass for the bound configuration and $\\hbar c$ is the usual constant.\n\n- The momentum transfer $q(\\theta)$ is computed from\n$$\nq(\\theta) = 2\\,k\\,\\sin\\!\\left(\\frac{\\theta}{2}\\right), \\quad\nk = \\frac{\\sqrt{2\\,\\mu\\,E}}{\\hbar c},\n$$\nwith $\\mu$ the reduced mass in the entrance channel and $E$ the laboratory kinetic energy of the projectile.\n\nUnits and constants:\n- Use $\\hbar c = 197.3269804$ in $\\mathrm{MeV\\cdot fm}$.\n- Use $\\mu = 469.459$ in $\\mathrm{MeV}$ for the entrance-channel reduced mass.\n- Use $\\mu_B = 469.459$ in $\\mathrm{MeV}$ for the bound-state reduced mass.\n- Use $E = 50.0$ in $\\mathrm{MeV}$.\n- Use $R_0 = 6.0$ in $\\mathrm{fm}$, $a_0 = 0.6$ in $\\mathrm{fm}$, $R_{\\mathrm{int}} = 2.0$ in $\\mathrm{fm}$, $R_m = 6.0$ in $\\mathrm{fm}$, and $a_m = 0.5$ in $\\mathrm{fm}$.\n- All distances $r$ must be in $\\mathrm{fm}$, angles $\\theta$ must be in radians, and energies must be in $\\mathrm{MeV}$.\n\nNumerical evaluation:\n- Evaluate the integral numerically on a uniform radial grid from $r=0$ to $r=r_{\\max}$ with $r_{\\max} = 30.0$ in $\\mathrm{fm}$ and a step size chosen to ensure convergence. Use a numerically stable method to integrate $r^2\\,u_B(r)\\, f_{\\mathrm{WS}}(r;R_0,a_0)\\, j_0(qr)$.\n\nSensitivity quantification:\n- For a given angle $\\theta$ and separation energy $S_B$, define the sensitivity to the ANC by computing the ratio\n$$\nR_C(\\theta;S_B) = \\frac{\\left|T_{fi}(\\theta;C_2)\\right|}{\\left|T_{fi}(\\theta;C_1)\\right|},\n$$\nfor two ANCs $C_2$ and $C_1$. Forward-angle sensitivity implies $R_C(\\theta)$ close to $C_2/C_1$ when $\\theta$ is small, whereas sensitivity diminishes at larger $\\theta$.\n- To contrast ANC with interior sensitivity, similarly define\n$$\nR_{\\mathrm{int}}(\\theta;S_B) = \\frac{\\left|T_{fi}(\\theta;N_{\\mathrm{int},2})\\right|}{\\left|T_{fi}(\\theta;N_{\\mathrm{int},1})\\right|},\n$$\nwith fixed $C$ and varying interior amplitude $N_{\\mathrm{int}}$.\n\nTest suite:\n- Compute the following five ratios with the parameters specified above, where $C_1$, $C_2$, $N_{\\mathrm{int},1}$, $N_{\\mathrm{int},2}$, and $S_B$ are given for each case. All angles are in radians, and results are dimensionless.\n    1. $R_C(\\theta;S_B)$ at $\\theta = 0.05$, $S_B = 1.0$, with $C_1 = 1.0$ and $C_2 = 1.5$.\n    2. $R_C(\\theta;S_B)$ at $\\theta = 0.7$, $S_B = 1.0$, with $C_1 = 1.0$ and $C_2 = 1.5$.\n    3. $R_C(\\theta;S_B)$ at $\\theta = 0.001$, $S_B = 1.0$, with $C_1 = 1.0$ and $C_2 = 1.5$.\n    4. $R_{\\mathrm{int}}(\\theta;S_B)$ at $\\theta = 0.05$, $S_B = 1.0$, with $C = 1.0$ fixed and $N_{\\mathrm{int},1} = 1.0$, $N_{\\mathrm{int},2} = 1.5$.\n    5. $R_C(\\theta;S_B)$ at $\\theta = 0.05$, $S_B = 0.2$, with $C_1 = 1.0$ and $C_2 = 1.5$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results for the five test cases as a comma-separated list of floats rounded to $6$ decimal places and enclosed in square brackets, for example, $\\big[0.000000,0.000000,0.000000,0.000000,0.000000\\big]$.", "solution": "The problem has been validated and is deemed a well-posed, scientifically grounded exercise in computational nuclear physics. It accurately represents a simplified but physically meaningful model for studying single-nucleon transfer reactions within the distorted wave Born approximation (DWBA) framework. All necessary parameters, functions, and constants are provided, and the stated objective is to numerically verify a key tenet of reaction theory: the sensitivity of forward-angle cross sections to the asymptotic normalization constant (ANC) of the bound-state wavefunction.\n\nThe solution proceeds by developing a numerical implementation of the provided theoretical model. The core of the problem is the evaluation of the DWBA transition amplitude, $T_{fi}(\\theta)$, which is given by the integral:\n$$\nT_{fi}(\\theta) \\propto \\int_0^{\\infty} r^2\\, u_B(r)\\, f_{\\mathrm{WS}}(r;R_0,a_0)\\, j_0\\!\\big(q(\\theta)\\, r\\big)\\, \\mathrm{d}r\n$$\nThis integral represents the overlap between the initial and final states, mediated by a transition potential. In this model, the integrand is composed of four key components:\n\n1.  The phase space factor $r^2$.\n2.  The bound-state radial wavefunction $u_B(r)$. This function describes the spatial distribution of the transferred nucleon in its final bound state. It is modeled with an interior part and an asymptotic tail, governed by the ANC, $C$.\n3.  A surface-peaked transition form factor, $f_{\\mathrm{WS}}(r;R_0,a_0)$, represented by a Woods-Saxon function. This localizes the interaction to the nuclear surface, a common feature of direct reactions.\n4.  The distorted wave overlap, approximated here by the spherical Bessel function $j_0(q(\\theta)r)$. This term arises from a plane-wave approximation for the scattering states and introduces the dependence on the scattering angle $\\theta$ through the momentum transfer $q(\\theta)$.\n\nThe numerical evaluation of $T_{fi}(\\theta)$ is structured as follows:\n\nFirst, we define all physical constants and model parameters as specified. This includes the reduced masses $\\mu$ and $\\mu_B$, the kinetic energy $E$, the nuclear radii and diffuseness parameters ($R_0$, $a_0$, $R_{\\mathrm{int}}$, $R_m$, $a_m$), and the physical constant $\\hbar c$.\n\nSecond, we calculate the derived kinematic quantities that depend on the specific reaction conditions ($\\theta$, $S_B$).\n- The entrance-channel wave number, $k$, is computed from the projectile's kinetic energy $E$ and the reduced mass $\\mu$:\n  $$k = \\frac{\\sqrt{2\\,\\mu\\,E}}{\\hbar c}$$\n- The momentum transfer, $q(\\theta)$, is then calculated as a function of the scattering angle $\\theta$:\n  $$q(\\theta) = 2\\,k\\,\\sin\\!\\left(\\frac{\\theta}{2}\\right)$$\n- The decay constant of the bound-state tail, $\\kappa$, depends on the nucleon's separation energy $S_B$ and the bound-state reduced mass $\\mu_B$:\n  $$\\kappa = \\frac{\\sqrt{2\\,\\mu_B\\, S_B}}{\\hbar c}$$\n\nThird, we implement the functions that constitute the integrand.\n- The Woods-Saxon form factor $f_{\\mathrm{WS}}(r;R_0,a_0) = \\left(1+\\exp\\left(\\frac{r-R_0}{a_0}\\right)\\right)^{-1}$.\n- The bound-state wavefunction $u_B(r)$, assembled from its interior component $u_{\\mathrm{int}}(r) = N_{\\mathrm{int}}\\, r\\, e^{-r/R_{\\mathrm{int}}}$, its asymptotic tail $C\\,e^{-\\kappa r}$, and the smooth matching function $S(r;R_m,a_m) = \\left(1+\\exp\\left(\\frac{R_m - r}{a_m}\\right)\\right)^{-1}$.\n- The zeroth-order spherical Bessel function, $j_0(x) = \\frac{\\sin(x)}{x}$. A numerically stable implementation is used, which correctly evaluates to $1$ at $x=0$.\n\nFourth, we perform the numerical integration. The integral's infinite upper limit is replaced by a sufficiently large radius $r_{\\max} = 30.0\\,\\mathrm{fm}$, beyond which the integrand is negligible due to the exponential decay of both the bound-state wavefunction and the Woods-Saxon form factor. The radial coordinate $r$ is discretized on a uniform grid from $r=0$ to $r_{\\max}$ with a step size small enough to ensure numerical convergence. The integrand is evaluated at each point on this grid, and the definite integral is computed using the trapezoidal rule, a standard numerical quadrature method available in `NumPy`.\n\nFinally, to address the core question of sensitivity, we compute the ratios $R_C$ and $R_{\\mathrm{int}}$. For each of the five test cases, the transition amplitude $T_{fi}(\\theta)$ is calculated for two different parameter sets (e.g., with $C_1$ and $C_2$, or $N_{\\mathrm{int},1}$ and $N_{\\mathrm{int},2}$). The ratio of the absolute values of these amplitudes is then computed as specified:\n$$\nR_C(\\theta;S_B) = \\frac{\\left|T_{fi}(\\theta;C_2)\\right|}{\\left|T_{fi}(\\theta;C_1)\\right|} \\quad \\text{and} \\quad R_{\\mathrm{int}}(\\theta;S_B) = \\frac{\\left|T_{fi}(\\theta;N_{\\mathrm{int},2})\\right|}{\\left|T_{fi}(\\theta;N_{\\mathrm{int},1})\\right|}\n$$\nThe value of the proportionality constant in the definition of $T_{fi}(\\theta)$ is irrelevant as it cancels out in these ratios. For cases where a parameter is not explicitly varied (e.g., $N_{\\mathrm{int}}$ in an $R_C$ calculation), a default value of $1.0$ is used, as implied by the problem's structure. The resulting five ratios are then formatted and presented as the final answer. This procedure provides a direct, quantitative measure of how changes in the wavefunction's asymptotic tail versus its interior affect the reaction observable at different angles.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# This script implements a computational model for the distorted wave Born\n# approximation (DWBA) to analyze the sensitivity of the transition amplitude\n# to the asymptotic normalization constant (ANC) and interior part of a\n# bound-state wavefunction.\n\n# Define global constants and model parameters in a dictionary for clarity.\nPARAMS = {\n    'hbarc': 197.3269804,  # MeV*fm\n    'mu': 469.459,         # Entrance-channel reduced mass in MeV\n    'mu_B': 469.459,       # Bound-state reduced mass in MeV\n    'E': 50.0,             # Laboratory kinetic energy in MeV\n    'R0': 6.0,             # Woods-Saxon radius for form factor in fm\n    'a0': 0.6,             # Woods-Saxon diffuseness for form factor in fm\n    'R_int': 2.0,          # Scale of the interior wavefunction in fm\n    'R_m': 6.0,            # Matching radius in fm\n    'a_m': 0.5,            # Matching diffuseness in fm\n    'r_max': 30.0,         # Maximum integration radius in fm\n    'n_points': 4001,      # Number of points for the radial integration grid\n}\n\ndef woods_saxon(r, R, a):\n    \"\"\"\n    Calculates the Woods-Saxon function.\n    f(r; R, a) = 1 / (1 + exp((r - R) / a))\n    \"\"\"\n    return 1.0 / (1.0 + np.exp((r - R) / a))\n\ndef matching_function(r, R_m, a_m):\n    \"\"\"\n    Calculates the smooth matching (switch-on) function S.\n    S(r; R_m, a_m) = 1 / (1 + exp((R_m - r) / a_m))\n    \"\"\"\n    return 1.0 / (1.0 + np.exp((R_m - r) / a_m))\n\ndef u_interior(r, N_int, R_int):\n    \"\"\"\n    Calculates the interior component of the bound-state wavefunction.\n    u_int(r) = N_int * r * exp(-r / R_int)\n    \"\"\"\n    return N_int * r * np.exp(-r / R_int)\n\ndef u_bound(r, C, N_int, kappa):\n    \"\"\"\n    Calculates the full modeled bound-state radial wavefunction u_B(r).\n    u_B(r) = u_int(r)*(1-S(r)) + C*exp(-kappa*r)*S(r)\n    \"\"\"\n    u_int = u_interior(r, N_int, PARAMS['R_int'])\n    S = matching_function(r, PARAMS['R_m'], PARAMS['a_m'])\n    u_tail = C * np.exp(-kappa * r)\n    return u_int * (1.0 - S) + u_tail * S\n\ndef spherical_bessel_j0(x):\n    \"\"\"\n    Calculates the spherical Bessel function of order 0, j0(x) = sin(x)/x,\n    using a numerically stable method that handles x=0 correctly.\n    \"\"\"\n    # np.sinc(x/pi) is defined as sin(x)/x\n    return np.sinc(x / np.pi)\n\ndef calculate_T_fi(theta, S_B, C, N_int):\n    \"\"\"\n    Calculates the DWBA transition amplitude integral T_fi.\n\n    Args:\n        theta (float): Scattering angle in radians.\n        S_B (float): Separation energy in MeV.\n        C (float): Asymptotic normalization constant (ANC).\n        N_int (float): Amplitude of the interior wavefunction component.\n\n    Returns:\n        float: The value of the transition amplitude integral.\n    \"\"\"\n    # Calculate derived kinematic and bound-state parameters.\n    k = np.sqrt(2.0 * PARAMS['mu'] * PARAMS['E']) / PARAMS['hbarc']\n    kappa = np.sqrt(2.0 * PARAMS['mu_B'] * S_B) / PARAMS['hbarc']\n    q = 2.0 * k * np.sin(theta / 2.0)\n    \n    # Set up the radial grid for numerical integration.\n    r = np.linspace(0, PARAMS['r_max'], PARAMS['n_points'])\n    \n    # Calculate the components of the integrand on the grid.\n    u_b_r = u_bound(r, C, N_int, kappa)\n    f_ws_r = woods_saxon(r, PARAMS['R0'], PARAMS['a0'])\n    j0_qr = spherical_bessel_j0(q * r)\n    \n    # Form the full integrand: r^2 * u_B(r) * f_WS(r) * j0(q*r).\n    integrand = r**2 * u_b_r * f_ws_r * j0_qr\n    \n    # Perform numerical integration using the trapezoidal rule.\n    t_fi = np.trapz(integrand, r)\n    \n    return t_fi\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the five test cases from the problem statement.\n    # Each case is a dictionary specifying the parameters for the calculation.\n    test_cases = [\n        # 1. R_C at a small forward angle.\n        {'type': 'C', 'theta': 0.05, 'S_B': 1.0, 'val1': 1.0, 'val2': 1.5, 'fixed_param': 1.0},\n        # 2. R_C at a large angle.\n        {'type': 'C', 'theta': 0.7, 'S_B': 1.0, 'val1': 1.0, 'val2': 1.5, 'fixed_param': 1.0},\n        # 3. R_C at a very small (near-zero) forward angle.\n        {'type': 'C', 'theta': 0.001, 'S_B': 1.0, 'val1': 1.0, 'val2': 1.5, 'fixed_param': 1.0},\n        # 4. R_int at a small forward angle.\n        {'type': 'N_int', 'theta': 0.05, 'S_B': 1.0, 'val1': 1.0, 'val2': 1.5, 'fixed_param': 1.0},\n        # 5. R_C for a more weakly bound state (smaller S_B).\n        {'type': 'C', 'theta': 0.05, 'S_B': 0.2, 'val1': 1.0, 'val2': 1.5, 'fixed_param': 1.0},\n    ]\n\n    results = []\n    for case in test_cases:\n        if case['type'] == 'C':\n            # Vary ANC C, keep N_int fixed.\n            C1, C2 = case['val1'], case['val2']\n            N_int = case['fixed_param']\n            T_fi_1 = calculate_T_fi(case['theta'], case['S_B'], C1, N_int)\n            T_fi_2 = calculate_T_fi(case['theta'], case['S_B'], C2, N_int)\n        elif case['type'] == 'N_int':\n            # Vary interior amplitude N_int, keep C fixed.\n            N_int1, N_int2 = case['val1'], case['val2']\n            C = case['fixed_param']\n            T_fi_1 = calculate_T_fi(case['theta'], case['S_B'], C, N_int1)\n            T_fi_2 = calculate_T_fi(case['theta'], case['S_B'], C, N_int2)\n        \n        # Calculate the ratio of the absolute values of the amplitudes.\n        ratio = np.abs(T_fi_2) / np.abs(T_fi_1)\n        results.append(ratio)\n        \n    # Format and print the final output as a single-line comma-separated list.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\n# Execute the solver.\nsolve()\n\n```", "id": "3598529"}, {"introduction": "A full DWBA calculation requires summing a series of partial-wave amplitudes, which must be truncated at some maximum angular momentum $\\ell_{\\max}$. Choosing this cutoff is a critical numerical task that balances computational cost and accuracy. This practice guides you through implementing and testing a robust heuristic to automatically determine a sufficient $\\ell_{\\max}$, ensuring that the calculated transition amplitude converges to a specified precision. [@problem_id:3598571]", "problem": "Consider a computational study of the convergence of the partial-wave expansion for the Distorted Wave Born Approximation (DWBA) transition amplitude. The starting point is the standard partial-wave decomposition for a transition amplitude expressed as a sum over orbital angular momentum quantum number $\\ell$, constructed on the basis of the time-independent Schrödinger equation and the superposition of angular momentum eigenstates. To make the problem self-contained and numerically stable, work with the following surrogate DWBA model for the partial-wave coefficients:\n$$\nt_\\ell = i^\\ell \\, j_\\ell(q a)\\,\\big(e^{i\\,\\delta_\\ell} - 1\\big),\n$$\nwhere $j_\\ell$ is the spherical Bessel function of the first kind, $q a$ is a dimensionless momentum-transfer–radius product, and $\\delta_\\ell$ is a model nuclear phase shift that decays for large $\\ell$ due to the short range of the interaction. The truncated transition amplitude at $\\ell_{\\max}$ is\n$$\nT_{fi}^{(\\ell_{\\max})} = \\sum_{\\ell=0}^{\\ell_{\\max}} (2\\ell+1)\\,t_\\ell.\n$$\nAssume the phase shift has the form\n$$\n\\delta_\\ell = \\delta_0 \\exp\\!\\left(-\\left(\\frac{\\ell}{\\ell_0}\\right)^p\\right),\n$$\nwith constants $\\delta_0$, $\\ell_0$, and $p$ chosen to represent different light and heavy target scenarios. In this surrogate, the envelope $j_\\ell(q a)$ captures the angular-momentum selectivity from the finite-range transition form factor, while the factor $e^{i\\delta_\\ell} - 1$ ensures that the contribution decays when $\\delta_\\ell \\to 0$, consistent with the physical expectation that high-$\\ell$ waves feel negligible nuclear distortion.\n\nYour task is to design and implement a quantitative heuristic to choose the smallest $\\ell_{\\max}$ that guarantees a specified relative accuracy $\\varepsilon$ on the complex amplitude, using only the asymptotic decay behavior of $\\delta_\\ell$ and the computed magnitudes of the successive partial-wave contributions. Specifically:\n\n- Define the magnitude of the $\\ell$th contribution as\n$$\na_\\ell = (2\\ell+1)\\,\\big|t_\\ell\\big| = (2\\ell+1)\\,\\big|j_\\ell(q a)\\big|\\,\\big|e^{i\\,\\delta_\\ell} - 1\\big|.\n$$\n- Use a rolling geometric tail heuristic based on $a_\\ell$ to estimate the remainder. Let $r_\\ell = a_\\ell/\\max(a_{\\ell-1},\\eta)$ with a small stabilizer $\\eta$, and define a rolling window average of the most recent $w$ ratios, denoted $\\bar{r}_\\ell$. Starting from $\\ell \\ge \\lceil q a \\rceil$, wait until $\\bar{r}_\\ell \\le r_{\\mathrm{trig}}$ to declare that the tail is approximately geometric. Then estimate the tail magnitude by \n$$\nR_{\\mathrm{est}}(\\ell) = \\frac{a_\\ell \\,\\bar r_\\ell}{1-\\bar r_\\ell}.\n$$\nTerminate at the smallest $\\ell_{\\max}$ such that\n$$\nR_{\\mathrm{est}}(\\ell_{\\max}) \\le \\varepsilon \\,\\max\\!\\left(\\big|T_{fi}^{(\\ell_{\\max})}\\big|, A_{\\mathrm{floor}}\\right).\n$$\nHere $\\varepsilon$ is the target relative tolerance, and $A_{\\mathrm{floor}}$ prevents premature termination when $\\big|T_{fi}^{(\\ell)}\\big|$ is accidentally small due to cancellations. Use $w = 3$, $r_{\\mathrm{trig}} = 0.9$, $\\eta = 10^{-30}$, and $A_{\\mathrm{floor}} = 10^{-12}$.\n\n- For validation, compute a high-accuracy reference using $\\ell_{\\mathrm{full}} = 400$:\n$$\nT_{fi}^{(\\ell_{\\mathrm{full}})} = \\sum_{\\ell=0}^{\\ell_{\\mathrm{full}}} (2\\ell+1)\\,t_\\ell,\n$$\nand report the achieved relative error\n$$\n\\mathrm{err} = \\frac{\\big|T_{fi}^{(\\ell_{\\mathrm{full}})} - T_{fi}^{(\\ell_{\\max})}\\big|}{\\big|T_{fi}^{(\\ell_{\\mathrm{full}})}\\big|}.\n$$\n\nImplement the above for the following test suite of parameter sets $\\{(\\delta_0, \\ell_0, p, q a, \\varepsilon)\\}$, designed to probe light versus heavy targets, small versus large momentum transfer, and slowly versus rapidly decaying phase-shift tails:\n\n- Case $\\#1$ (light, moderate range): $(\\delta_0, \\ell_0, p, q a, \\varepsilon) = (0.6, 3.0, 2.0, 4.0, 10^{-7})$.\n- Case $\\#2$ (heavy, slower decay): $(\\delta_0, \\ell_0, p, q a, \\varepsilon) = (2.0, 15.0, 1.0, 14.0, 10^{-6})$.\n- Case $\\#3$ (very low momentum transfer): $(\\delta_0, \\ell_0, p, q a, \\varepsilon) = (0.4, 2.0, 2.0, 0.5, 10^{-9})$.\n- Case $\\#4$ (broad tail, challenging): $(\\delta_0, \\ell_0, p, q a, \\varepsilon) = (3.0, 25.0, 0.7, 20.0, 2\\times 10^{-6})$.\n\nAll quantities in this problem are dimensionless. Angles are in radians. There are no physical units to report.\n\nYour program must:\n- Implement the above surrogate model and heuristic selection of $\\ell_{\\max}$.\n- For each case, compute the integer $\\ell_{\\max}$ returned by the heuristic and the achieved relative error $\\mathrm{err}$ using the $\\ell_{\\mathrm{full}}$ reference. Also compute a boolean flag that is true if $\\mathrm{err} \\le \\varepsilon$ and false otherwise.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each case is reported as a list of the form $[\\ell_{\\max}, \\mathrm{err}, \\mathrm{ok}]$. The float $\\mathrm{err}$ must be rounded to $6$ decimal places. For example: $[[12,0.000123,True],[\\dots]]$.", "solution": "The problem statement is validated as scientifically grounded, well-posed, and objective. It outlines a detailed computational task within the domain of nuclear physics, providing a self-contained surrogate model and a clear, deterministic heuristic for numerical convergence. All required parameters, constants, and validation metrics are explicitly defined. No contradictions, ambiguities, or factual unsoundness are present. The problem is a valid exercise in computational science.\n\nThe overall objective is to determine a suitable cutoff, $\\ell_{\\max}$, for a partial-wave series, which is a common task in quantum scattering calculations. The partial-wave series for the transition amplitude, truncated at $\\ell_{\\max}$, is given by\n$$\nT_{fi}^{(\\ell_{\\max})} = \\sum_{\\ell=0}^{\\ell_{\\max}} (2\\ell+1)\\,t_\\ell\n$$\nThe problem provides a surrogate model for the partial-wave coefficients $t_\\ell$, which depend on the orbital angular momentum quantum number $\\ell$. This model is\n$$\nt_\\ell = i^\\ell \\, j_\\ell(q a)\\,\\big(e^{i\\,\\delta_\\ell} - 1\\big)\n$$\nHere, $i^\\ell$ is the complex phase factor, $j_\\ell(q a)$ is the spherical Bessel function of the first kind evaluated at the dimensionless argument $q a$, and $\\delta_\\ell$ is a model for the nuclear phase shift. The phase shift itself is given by a generalized exponential decay model:\n$$\n\\delta_\\ell = \\delta_0 \\exp\\!\\left(-\\left(\\frac{\\ell}{\\ell_0}\\right)^p\\right)\n$$\nThis form ensures that for large $\\ell$, $\\delta_\\ell \\to 0$, causing $t_\\ell \\to 0$ and ensuring the convergence of the series. The algorithm's goal is to find the smallest $\\ell_{\\max}$ that satisfies a given relative tolerance $\\varepsilon$.\n\nThe core of the task is to implement a specific heuristic algorithm to find $\\ell_{\\max}$. This algorithm relies on the asymptotic behavior of the series terms. We first define the magnitude of the $\\ell$-th contribution to the sum as\n$$\na_\\ell = (2\\ell+1)\\,\\big|t_\\ell\\big| = (2\\ell+1)\\,\\big|j_\\ell(q a)\\big|\\,\\big|e^{i\\,\\delta_\\ell} - 1\\big|\n$$\nThe heuristic tracks the ratio of successive term magnitudes, $r_\\ell = a_\\ell / \\max(a_{\\ell-1}, \\eta)$, where $\\eta$ is a small regularization constant to prevent division by zero. A rolling average of these ratios, $\\bar{r}_\\ell$, is maintained over a window of size $w=3$.\n\nThe search for $\\ell_{\\max}$ proceeds as follows:\n1.  The partial-wave sum $T_{fi}^{(\\ell)}$ and the magnitudes $a_\\ell$ are computed iteratively, increasing $\\ell$ from $0$.\n2.  The algorithm waits for $\\ell$ to become sufficiently large, specifically $\\ell \\ge \\lceil qa \\rceil$, before it begins checking for tail behavior. This is physically motivated, as the behavior of $j_\\ell(x)$ changes significantly around $\\ell \\approx x$.\n3.  Once in this asymptotic region, the algorithm waits for the rolling ratio average to fall below a threshold: $\\bar{r}_\\ell \\le r_{\\mathrm{trig}}$, with $r_{\\mathrm{trig}} = 0.9$. This signals that the tail of the series is behaving like a geometric series with a common ratio less than $1$.\n4.  Once this \"tail trigger\" is activated, the algorithm estimates the magnitude of the remainder of the series (the \"tail\") using the formula for the sum of a geometric series. The problem statement uses $R_{\\mathrm{est}}(\\ell) = \\frac{a_\\ell \\,\\bar r_\\ell}{1-\\bar r_\\ell}$, which estimates the sum of the series from term $\\ell+1$ onward. This is the magnitude of the truncation error.\n5.  The iteration terminates at the first $\\ell$ (which we call $\\ell_{\\max}$) for which this estimated error is smaller than the target tolerance $\\varepsilon$ relative to the magnitude of the current partial sum. A floor value $A_{\\mathrm{floor}}$ is used to prevent premature termination if the partial sum happens to be near zero due to destructive interference. The condition is:\n$$\nR_{\\mathrm{est}}(\\ell_{\\max}) \\le \\varepsilon \\,\\max\\!\\left(\\big|T_{fi}^{(\\ell_{\\max})}\\big|, A_{\\mathrm{floor}}\\right)\n$$\nUpon finding $\\ell_{\\max}$, we validate the effectiveness of this heuristic. A high-precision reference amplitude $T_{fi}^{(\\ell_{\\mathrm{full}})}$ is computed using a large, fixed cutoff $\\ell_{\\mathrm{full}} = 400$. The achieved relative error is then calculated as:\n$$\n\\mathrm{err} = \\frac{\\big|T_{fi}^{(\\ell_{\\mathrm{full}})} - T_{fi}^{(\\ell_{\\max})}\\big|}{\\big|T_{fi}^{(\\ell_{\\mathrm{full}})}\\big|}\n$$\nFinally, we check if this achieved error meets the target tolerance, i.e., if $\\mathrm{err} \\le \\varepsilon$.\n\nThe implementation will be carried out in Python, utilizing the `numpy` library for efficient handling of complex numbers and arrays, and the `scipy.special.spherical_jn` function to compute the spherical Bessel functions. For each test case, we pre-compute all terms up to $\\ell_{\\mathrm{full}}$ to streamline the subsequent heuristic search and reference calculation.", "answer": "```python\nimport numpy as np\nfrom scipy.special import spherical_jn\n\ndef solve():\n    \"\"\"\n    Implements the DWBA surrogate model and the heuristic for selecting l_max,\n    and validates it against a high-precision reference calculation.\n    \"\"\"\n    test_cases = [\n        # (delta0, l0, p, qa, eps)\n        (0.6, 3.0, 2.0, 4.0, 1e-7),      # Case #1\n        (2.0, 15.0, 1.0, 14.0, 1e-6),     # Case #2\n        (0.4, 2.0, 2.0, 0.5, 1e-9),      # Case #3\n        (3.0, 25.0, 0.7, 20.0, 2e-6),    # Case #4\n    ]\n\n    # Heuristic constants\n    w = 3\n    r_trig = 0.9\n    eta = 1e-30\n    A_floor = 1e-12\n    l_full = 400\n\n    results = []\n\n    for case in test_cases:\n        delta0, l0, p, qa, eps = case\n        \n        # --- 1. Pre-computation of all terms up to l_full ---\n        l_vals = np.arange(l_full + 1)\n\n        # Phase shifts delta_l\n        delta_l = delta0 * np.exp(-((l_vals / l0)**p))\n\n        # Spherical Bessel functions j_l(qa)\n        # scipy.special.spherical_jn(n, z) computes for n=0, 1, ..., max(n)\n        j_l_qa = spherical_jn(l_vals, qa)\n\n        # Complex phase factor i^l\n        i_power_l = 1j**l_vals\n\n        # Partial-wave coefficients t_l\n        t_l = i_power_l * j_l_qa * (np.exp(1j * delta_l) - 1)\n\n        # Full terms of the summation (2l+1)*t_l\n        full_terms = (2 * l_vals + 1) * t_l\n        \n        # Magnitudes a_l = |(2l+1)*t_l|\n        a_l_vals = np.abs(full_terms)\n\n        # --- 2. High-accuracy reference calculation ---\n        T_fi_full = np.sum(full_terms)\n\n        # --- 3. Iterative search for l_max using the heuristic ---\n        l_max = -1  # Sentinel value\n        T_fi_current = 0.0 + 0.0j\n        ratios_window = []\n        tail_triggered = False\n        l_start_check = int(np.ceil(qa))\n\n        # The loop runs up to l_full. If the condition is not met, l_max will remain -1,\n        # indicating failure to converge within the l_full limit.\n        for l in range(l_full + 1):\n            T_fi_current += full_terms[l]\n\n            if l == 0:\n                continue\n\n            r_l = a_l_vals[l] / np.maximum(a_l_vals[l - 1], eta)\n            ratios_window.append(r_l)\n            if len(ratios_window) > w:\n                ratios_window.pop(0)\n\n            if len(ratios_window) == w:\n                r_bar = np.mean(ratios_window)\n                \n                # Check for tail trigger condition\n                if l >= l_start_check and not tail_triggered:\n                    if r_bar = r_trig:\n                        tail_triggered = True\n\n                # If triggered, check for termination\n                if tail_triggered:\n                    # The denominator is safe because r_bar = r_trig = 0.9\n                    R_est = (a_l_vals[l] * r_bar) / (1 - r_bar)\n                    \n                    threshold = eps * np.maximum(np.abs(T_fi_current), A_floor)\n\n                    if R_est = threshold:\n                        l_max = l\n                        break\n        \n        if l_max == -1: # Fallback if convergence not found\n            l_max = l_full\n\n        # --- 4. Validation ---\n        T_fi_lmax = np.sum(full_terms[:l_max + 1])\n        \n        # Avoid division by zero if reference amplitude is zero\n        if np.abs(T_fi_full) > eta:\n            err = np.abs(T_fi_full - T_fi_lmax) / np.abs(T_fi_full)\n        else:\n            # If reference is zero, error is just the magnitude of the difference\n            err = np.abs(T_fi_full - T_fi_lmax)\n\n        ok = err = eps\n        \n        results.append([l_max, round(err, 6), bool(ok)])\n\n    # --- 5. Final Output Formatting ---\n    # The str() representation of a list is '[...]' and of a bool is 'True'/'False',\n    # which matches the required output format.\n    output_str = f\"[{','.join(map(str, results))}]\"\n    print(output_str)\n\nsolve()\n```", "id": "3598571"}]}