{"hands_on_practices": [{"introduction": "Permutation matrices are not merely theoretical constructs; they are fundamental working components in many core numerical algorithms. One of the most common places they appear is in Gaussian elimination, where row interchanges are necessary to ensure numerical stability. This practice provides a concrete, step-by-step application of Gaussian elimination with partial pivoting, guiding you through the process of deriving the $PA=LU$ factorization for a given matrix. By performing this foundational calculation [@problem_id:3564697], you will gain a practical understanding of how the permutation matrix $P$ emerges and how the factorization can be used to solve related problems like finding the determinant.", "problem": "Let $A \\in \\mathbb{R}^{3 \\times 3}$ be the matrix\n$$\nA \\;=\\; \\begin{pmatrix}\n0 & 2 & 3\\\\\n4 & 0 & 6\\\\\n1 & 5 & 0\n\\end{pmatrix}.\n$$\nUsing Gaussian elimination with partial pivoting based on the definition that, at each elimination step $k$, one selects as the pivot the entry of maximal absolute value in column $k$ among the rows $k,k+1,\\ldots,n$ and enacts the corresponding row swap via a permutation matrix, perform the following:\n\n1. Determine explicitly the permutation matrix $P$, the unit lower triangular matrix $L$, and the upper triangular matrix $U$ such that $PA = LU$. Here a permutation matrix is defined as a square matrix obtained from the identity by permuting its rows, and a unit lower triangular matrix is a lower triangular matrix with all diagonal entries equal to $1$.\n\n2. Verify directly that $PA = LU$.\n\n3. Using only foundational properties of determinants, compute $\\det(A)$ from your $P$, $L$, and $U$.\n\nProvide the final value of $\\det(A)$ as an exact integer. Do not round.", "solution": "The problem asks for the $PA=LU$ decomposition of a given $3 \\times 3$ matrix $A$ using Gaussian elimination with partial pivoting, a verification of the result, and the computation of $\\det(A)$ from the decomposition.\n\nThe given matrix is:\n$$\nA \\;=\\; \\begin{pmatrix}\n0 & 2 & 3\\\\\n4 & 0 & 6\\\\\n1 & 5 & 0\n\\end{pmatrix}\n$$\n\n### Part 1: Determine $P$, $L$, and $U$\n\nWe will perform Gaussian elimination with partial pivoting. We augment the matrix $A$ with an identity matrix that will become $P$ and keep track of the multipliers for $L$.\n\n**Step $k=1$:**\nThe initial matrix is $A^{(1)} = A$. We look at the first column of $A^{(1)}$, which is $(0, 4, 1)^T$. The element with the maximal absolute value is $4$ in row $2$. The pivoting rule requires swapping row $1$ and row $2$.\nWe start with $P$ as the identity matrix $I_3 = \\begin{pmatrix} 1 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix}$. Swapping rows $1$ and $2$ of $P$ gives the first permutation matrix $P_1 = \\begin{pmatrix} 0 & 1 & 0 \\\\ 1 & 0 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix}$.\nApplying this permutation to $A$:\n$$\nA' = P_1 A = \\begin{pmatrix} 0 & 1 & 0 \\\\ 1 & 0 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} \\begin{pmatrix} 0 & 2 & 3 \\\\ 4 & 0 & 6 \\\\ 1 & 5 & 0 \\end{pmatrix} = \\begin{pmatrix} 4 & 0 & 6 \\\\ 0 & 2 & 3 \\\\ 1 & 5 & 0 \\end{pmatrix}\n$$\nThe pivot element is $a'_{11}=4$. Now we perform elimination on column $1$.\nThe entry $a'_{21}$ is already $0$. The multiplier is $l_{21} = \\frac{0}{4} = 0$.\nTo eliminate $a'_{31}=1$, we use the multiplier $l_{31} = \\frac{1}{4}$. We perform the row operation $R_3 \\leftarrow R_3 - \\frac{1}{4} R_1$.\nThe new row $3$ is: $(1, 5, 0) - \\frac{1}{4}(4, 0, 6) = (1-1, 5-0, 0-\\frac{6}{4}) = (0, 5, -\\frac{3}{2})$.\nThe matrix after the first step of elimination is:\n$$\nA^{(2)} = \\begin{pmatrix} 4 & 0 & 6 \\\\ 0 & 2 & 3 \\\\ 0 & 5 & -\\frac{3}{2} \\end{pmatrix}\n$$\nThe multipliers for this step are $l_{21}=0$ and $l_{31}=1/4$.\n\n**Step $k=2$:**\nWe now consider the submatrix from row $2$, column $2$ downwards. The second column entries are $(2, 5)^T$. The element with maximal absolute value is $5$ in row $3$ of the current matrix $A^{(2)}$. So we must swap row $2$ and row $3$.\nThe permutation is applied to the current permutation matrix and to the matrix $A^{(2)}$.\nThe permutation matrix for this step is $P_2 = \\begin{pmatrix} 1 & 0 & 0 \\\\ 0 & 0 & 1 \\\\ 0 & 1 & 0 \\end{pmatrix}$.\nThe total permutation matrix $P$ is $P_2 P_1$:\n$$\nP = \\begin{pmatrix} 1 & 0 & 0 \\\\ 0 & 0 & 1 \\\\ 0 & 1 & 0 \\end{pmatrix} \\begin{pmatrix} 0 & 1 & 0 \\\\ 1 & 0 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} = \\begin{pmatrix} 0 & 1 & 0 \\\\ 0 & 0 & 1 \\\\ 1 & 0 & 0 \\end{pmatrix}\n$$\nApplying the swap to $A^{(2)}$:\n$$\nA'' = \\begin{pmatrix} 4 & 0 & 6 \\\\ 0 & 5 & -\\frac{3}{2} \\\\ 0 & 2 & 3 \\end{pmatrix}\n$$\nThe pivot element is now $a''_{22}=5$. We eliminate the entry $a''_{32}=2$ using the multiplier $l_{32} = \\frac{2}{5}$. We perform the row operation $R_3 \\leftarrow R_3 - \\frac{2}{5} R_2$.\nThe new row $3$ is: $(0, 2, 3) - \\frac{2}{5}(0, 5, -\\frac{3}{2}) = (0, 2-2, 3-(-\\frac{3}{5})) = (0, 0, \\frac{15}{5}+\\frac{3}{5}) = (0, 0, \\frac{18}{5})$.\nThe final upper triangular matrix $U$ is:\n$$\nU = \\begin{pmatrix} 4 & 0 & 6 \\\\ 0 & 5 & -\\frac{3}{2} \\\\ 0 & 0 & \\frac{18}{5} \\end{pmatrix}\n$$\n\n**Constructing $L$:**\nThe matrix $L$ is a unit lower triangular matrix containing the multipliers. The row swaps must be applied to the multipliers as they are generated.\nAfter step $1$, we had multipliers $l_{21}=0$ and $l_{31}=1/4$.\nIn step $2$, we swapped rows $2$ and $3$. This means we must also swap the stored multipliers for these rows. Thus, the multiplier for position $(2,1)$ becomes $1/4$ and for $(3,1)$ becomes $0$.\nThe multiplier from step $2$, $l_{32}=2/5$, fills the $(3,2)$ position.\nSo, the matrix $L$ is:\n$$\nL = \\begin{pmatrix} 1 & 0 & 0 \\\\ l_{21} & 1 & 0 \\\\ l_{31} & l_{32} & 1 \\end{pmatrix} \\rightarrow L = \\begin{pmatrix} 1 & 0 & 0 \\\\ \\frac{1}{4} & 1 & 0 \\\\ 0 & \\frac{2}{5} & 1 \\end{pmatrix}\n$$\nThe final matrices are:\n$$\nP = \\begin{pmatrix} 0 & 1 & 0 \\\\ 0 & 0 & 1 \\\\ 1 & 0 & 0 \\end{pmatrix}, \\quad L = \\begin{pmatrix} 1 & 0 & 0 \\\\ \\frac{1}{4} & 1 & 0 \\\\ 0 & \\frac{2}{5} & 1 \\end{pmatrix}, \\quad U = \\begin{pmatrix} 4 & 0 & 6 \\\\ 0 & 5 & -\\frac{3}{2} \\\\ 0 & 0 & \\frac{18}{5} \\end{pmatrix}\n$$\n\n### Part 2: Verify that $PA = LU$\n\nFirst, we compute the product $PA$:\n$$\nPA = \\begin{pmatrix} 0 & 1 & 0 \\\\ 0 & 0 & 1 \\\\ 1 & 0 & 0 \\end{pmatrix} \\begin{pmatrix} 0 & 2 & 3 \\\\ 4 & 0 & 6 \\\\ 1 & 5 & 0 \\end{pmatrix} = \\begin{pmatrix} 4 & 0 & 6 \\\\ 1 & 5 & 0 \\\\ 0 & 2 & 3 \\end{pmatrix}\n$$\nNext, we compute the product $LU$:\n$$\nLU = \\begin{pmatrix} 1 & 0 & 0 \\\\ \\frac{1}{4} & 1 & 0 \\\\ 0 & \\frac{2}{5} & 1 \\end{pmatrix} \\begin{pmatrix} 4 & 0 & 6 \\\\ 0 & 5 & -\\frac{3}{2} \\\\ 0 & 0 & \\frac{18}{5} \\end{pmatrix}\n$$\n$$\nLU = \\begin{pmatrix} 1(4)+0+0 & 1(0)+0+0 & 1(6)+0+0 \\\\ \\frac{1}{4}(4)+1(0)+0 & \\frac{1}{4}(0)+1(5)+0 & \\frac{1}{4}(6)+1(-\\frac{3}{2})+0 \\\\ 0(4)+\\frac{2}{5}(0)+1(0) & 0(0)+\\frac{2}{5}(5)+1(0) & 0(6)+\\frac{2}{5}(-\\frac{3}{2})+1(\\frac{18}{5}) \\end{pmatrix}\n$$\n$$\nLU = \\begin{pmatrix} 4 & 0 & 6 \\\\ 1 & 5 & \\frac{3}{2}-\\frac{3}{2} \\\\ 0 & 2 & -\\frac{3}{5}+\\frac{18}{5} \\end{pmatrix} = \\begin{pmatrix} 4 & 0 & 6 \\\\ 1 & 5 & 0 \\\\ 0 & 2 & \\frac{15}{5} \\end{pmatrix} = \\begin{pmatrix} 4 & 0 & 6 \\\\ 1 & 5 & 0 \\\\ 0 & 2 & 3 \\end{pmatrix}\n$$\nThe products are identical, so we have verified that $PA=LU$.\n\n### Part 3: Compute $\\det(A)$\n\nThe equation $PA=LU$ relates the determinants of the matrices:\n$$\n\\det(PA) = \\det(LU)\n$$\nUsing the property $\\det(XY) = \\det(X)\\det(Y)$, we have:\n$$\n\\det(P)\\det(A) = \\det(L)\\det(U)\n$$\nWe can solve for $\\det(A)$:\n$$\n\\det(A) = \\frac{\\det(L)\\det(U)}{\\det(P)}\n$$\nWe compute the determinant of each matrix based on its properties:\n1.  $\\det(L)$: $L$ is a unit lower triangular matrix. The determinant of any triangular matrix is the product of its diagonal entries.\n    $$\n    \\det(L) = 1 \\cdot 1 \\cdot 1 = 1\n    $$\n2.  $\\det(U)$: $U$ is an upper triangular matrix. Its determinant is also the product of its diagonal entries.\n    $$\n    \\det(U) = 4 \\cdot 5 \\cdot \\frac{18}{5} = 4 \\cdot 18 = 72\n    $$\n3.  $\\det(P)$: $P$ is a permutation matrix. Its determinant is $(-1)^s$, where $s$ is the number of row swaps used to obtain $P$ from the identity matrix. We performed two row swaps ($R_1 \\leftrightarrow R_2$ and then $R_2 \\leftrightarrow R_3$). So, $s=2$.\n    $$\n    \\det(P) = (-1)^2 = 1\n    $$\n    Alternatively, $P$ corresponds to the permutation $(1 \\to 3 \\to 2 \\to 1)$ on the rows, which is a $3$-cycle. The sign of a $k$-cycle is $(-1)^{k-1}$, so $\\det(P) = (-1)^{3-1}=1$.\n\nNow, we can compute $\\det(A)$:\n$$\n\\det(A) = \\frac{1 \\cdot 72}{1} = 72\n$$\nThe determinant of $A$ is $72$.", "answer": "$$\\boxed{72}$$", "id": "3564697"}, {"introduction": "While algorithms like Gaussian elimination may generate a permutation, the task of applying that permutation to a vector or matrix is a critical operation in itself, especially in high-performance computing. A naive implementation can be inefficient, requiring extra memory to store a copy of the data. This exercise challenges you to think algorithmically, using the cycle decomposition of a permutation to design an elegant in-place algorithm that reorders a vector's elements [@problem_id:3564698]. Mastering this technique is essential for writing memory-efficient and performant numerical code, as it achieves the permutation in linear time $O(n)$ with only constant extra space $O(1)$.", "problem": "Let $n \\in \\mathbb{N}$ with $n \\geq 1$. A permutation of the index set $\\{0,1,\\dots,n-1\\}$ is a bijection $\\pi:\\{0,1,\\dots,n-1\\}\\to\\{0,1,\\dots,n-1\\}$. The corresponding permutation matrix $P \\in \\mathbb{R}^{n \\times n}$ is defined by $P_{i,j} = 1$ if and only if $j = \\pi(i)$, and $P_{i,j} = 0$ otherwise. For any vector $x \\in \\mathbb{R}^n$, left multiplication by $P$ reorders its entries as $(Px)_i = x_{\\pi(i)}$, and left multiplication by the transpose $P^{\\top}$ applies the inverse permutation $(P^{\\top}x)_i = x_{\\pi^{-1}(i)}$. The cycle decomposition of $\\pi$ partitions the set $\\{0,1,\\dots,n-1\\}$ into disjoint cycles $(i_0,i_1,\\dots,i_{k-1})$ such that $\\pi(i_j) = i_{j+1}$ for $j \\in \\{0,\\dots,k-2\\}$ and $\\pi(i_{k-1}) = i_0$.\n\nDesign an in-place algorithm to apply $\\pi$ and $\\pi^{-1}$ to a vector $x \\in \\mathbb{R}^n$ using cycle decomposition. The algorithm must:\n- Operate in-place on $x$ (that is, overwrite $x$ with $Px$ or $P^{\\top}x$).\n- Use $O(1)$ additional memory beyond a constant number of scalar temporaries. You are permitted to temporarily modify the permutation array $p \\in \\{0,1,\\dots,n-1\\}^n$ that encodes $\\pi$ via $p[i] = \\pi(i)$, provided you restore $p$ to its original values before the function returns. You may mark visited indices by subtracting $n$ from $p[j]$ and recover the original value as $p[j] + n$ when $p[j] < 0$.\n- Perform $O(n)$ arithmetic and indexing operations in the worst case.\n\nProvide a rigorous justification from first principles in numerical linear algebra that the algorithm is correct, uses $O(1)$ additional memory, and performs $O(n)$ operations. Your justification must derive the algorithmâ€™s behavior from the definitions of a permutation, a permutation matrix, and cycle decomposition, and must not assume any shortcut facts.\n\nImplement the algorithm in the Python programming language and apply it to the following test suite. Use zero-based indexing throughout. For each test case, let $x$ be the initial vector and $p$ be the permutation array. Let $y$ denote the reference forward application computed out-of-place as $y_i = x_{p[i]}$; and let $z$ denote the reference inverse application computed out-of-place as $z_i = x_{\\pi^{-1}(i)}$, where $\\pi^{-1}$ is the inverse of $\\pi$.\n\nTest Suite:\n1. General case with mixed cycles:\n   - $n = 8$\n   - $p = [\\,2,\\,5,\\,0,\\,7,\\,1,\\,3,\\,4,\\,6\\,]$\n   - $x = [\\,0.1,\\,-1.5,\\,2.7,\\,3.3,\\,-0.4,\\,9.0,\\,1.2,\\,-2.2\\,]$\n2. Boundary case of a single element:\n   - $n = 1$\n   - $p = [\\,0\\,]$\n   - $x = [\\,42.0\\,]$\n3. Multiple disjoint cycles:\n   - $n = 7$\n   - $p = [\\,1,\\,2,\\,0,\\,4,\\,3,\\,6,\\,5\\,]$\n   - $x = [\\,10.0,\\,20.0,\\,30.0,\\,40.0,\\,50.0,\\,60.0,\\,70.0\\,]$\n4. Identity permutation:\n   - $n = 5$\n   - $p = [\\,0,\\,1,\\,2,\\,3,\\,4\\,]$\n   - $x = [\\,-0.0,\\,1.0,\\,-1.0,\\,2.5,\\,-2.5\\,]$\n5. Single long cycle:\n   - $n = 10$\n   - $p = [\\,1,\\,2,\\,3,\\,4,\\,5,\\,6,\\,7,\\,8,\\,9,\\,0\\,]$\n   - $x = [\\,0.5,\\,1.5,\\,2.5,\\,3.5,\\,4.5,\\,5.5,\\,6.5,\\,7.5,\\,8.5,\\,9.5\\,]$\n\nFor each test case, your program must produce a list of three boolean values:\n- The first boolean is true if the in-place forward application produces the same vector as the out-of-place reference $y$.\n- The second boolean is true if the in-place inverse application, applied to the in-place forward result, recovers the original $x$.\n- The third boolean is true if the permutation array $p$ is restored to its original values after each in-place operation.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to one test case and is itself a list of three boolean values. For example, the output format must be exactly like\n`[[True,True,True],[True,True,True],...]`.", "solution": "The problem requires the design and implementation of an in-place algorithm to apply a permutation $\\pi$ and its inverse $\\pi^{-1}$ to a vector $x \\in \\mathbb{R}^n$. The algorithm must operate with $O(1)$ auxiliary space and $O(n)$ time complexity.\n\n### **Problem Validation**\n\n**Step 1: Extract Givens**\n- The dimension of the vector space is $n \\in \\mathbb{N}$ with $n \\geq 1$.\n- A permutation is a bijection $\\pi: \\{0,1,\\dots,n-1\\} \\to \\{0,1,\\dots,n-1\\}$.\n- The permutation matrix $P \\in \\mathbb{R}^{n \\times n}$ is defined by $P_{i,j} = 1$ if $j = \\pi(i)$ and $P_{i,j} = 0$ otherwise.\n- The forward permutation of a vector $x \\in \\mathbb{R}^n$ is defined by the matrix-vector product $Px$, whose components are $(Px)_i = x_{\\pi(i)}$. This is a \"gather\" operation.\n- The inverse permutation of $x$ is defined by $P^{\\top}x$, whose components are $(P^{\\top}x)_i = x_{\\pi^{-1}(i)}$. This is a \"scatter\" operation. Note that since $P$ is a permutation matrix, it is orthogonal, so $P^{\\top} = P^{-1}$.\n- The permutation $\\pi$ is encoded in an array $p$ such that $p[i] = \\pi(i)$.\n- The algorithm must be in-place, use $O(1)$ additional memory, and perform $O(n)$ operations.\n- The permutation array $p$ may be temporarily modified but must be restored to its original state. A specific marking scheme is suggested: $p[j] \\leftarrow p[j] - n$ to mark index $j$ as visited, with recovery via $p[j] + n$.\n- The test suite provides five explicit test cases for $n$, $p$, and $x$.\n- The program output for each test case is a list of three boolean values: correctness of forward application, correctness of recovery by inverse application, and restoration of the permutation array $p$.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is well-defined and scientifically sound, situated within the domain of numerical linear algebra and algorithm design.\n- **Scientific Grounding**: The definitions of a permutation, permutation matrix, cycle decomposition, and matrix-vector products $(Px)_i = x_{\\pi(i)}$ and $(P^{\\top}x)_i = x_{\\pi^{-1}(i)}$ are standard and mathematically correct. The properties of permutation matrices (e.g., $P^\\top = P^{-1}$) are fundamental facts.\n- **Well-Posedness**: The problem is well-posed. It asks for an algorithm with specific, achievable constraints ($O(n)$ time, $O(1)$ space, in-place). A unique and stable solution in terms of output exists.\n- **Completeness and Consistency**: The problem statement is self-contained, providing all necessary definitions, constraints, and test data. The constraints are challenging but not contradictory.\n\n**Step 3: Verdict and Action**\nThe problem is valid. A reasoned solution will be developed.\n\n### **Algorithmic Design and Justification**\n\n**1. Underlying Principle: Cycle Decomposition**\n\nA permutation $\\pi$ on a finite set of indices can be decomposed into a set of disjoint cycles. A cycle $(i_0, i_1, \\dots, i_{k-1})$ represents the mapping $\\pi(i_0) = i_1, \\pi(i_1) = i_2, \\dots, \\pi(i_{k-1}) = i_0$. Since the cycles are disjoint, they partition the index set $\\{0, 1, \\dots, n-1\\}$. The permutation of the entire vector $x$ can be achieved by permuting the elements of $x$ corresponding to each cycle independently. An in-place algorithm can process one cycle at a time. To avoid processing any index more than once, we iterate through all indices $i \\in \\{0, 1, \\dots, n-1\\}$ and start a cycle traversal only if index $i$ has not yet been visited.\n\n**2. Forward Permutation ($y = Px$, \"Gather\")**\n\nThe forward permutation is defined by $y_i = x_{\\pi(i)}$. For a cycle $(i_0, i_1, \\dots, i_{k-1})$, the new values $x'_{\\cdot}$ are related to the old values $x_{\\cdot}$ as follows:\n$$x'_{i_0} = x_{\\pi(i_0)} = x_{i_1}$$\n$$x'_{i_1} = x_{\\pi(i_1)} = x_{i_2}$$\n$$\\vdots$$\n$$x'_{i_{k-1}} = x_{\\pi(i_{k-1})} = x_{i_0}$$\nThis transformation is a cyclic right-shift of the values $(x_{i_0}, x_{i_1}, \\dots, x_{i_{k-1}})$. To perform this in-place for a cycle starting at index $s$, we can use the following procedure, which uses a single temporary variable to hold a value:\n1. Save the value at the starting index: `saved_val = x[s]`.\n2. Start from the predecessor of $s$ in the cycle and move values forward. However, finding the predecessor requires traversing the cycle, which is inefficient.\n3. A more efficient approach is to \"chase the hole.\" We want to move the value from $x_{\\pi(i)}$ to $x_i$.\n   a. Let $s$ be the starting index of the cycle.\n   b. Store `saved_val = x[s]`.\n   c. Let `prev_idx = s` and `curr_idx = p[s]`.\n   d. In a loop, move the value from the current index to the previous index: `x[prev_idx] = x[curr_idx]`.\n   e. Advance both pointers along the cycle: `prev_idx = curr_idx`, `curr_idx = p[curr_idx]`.\n   f. Repeat until the entire cycle is shifted. The last element to be placed is `saved_val`, which goes into the final `prev_idx`.\n\n**3. Inverse Permutation ($y = P^{\\top}x$, \"Scatter\")**\n\nThe inverse permutation is defined by $y_i = x_{\\pi^{-1}(i)}$, which is equivalent to $y_{\\pi(i)} = x_i$. For a cycle $(i_0, i_1, \\dots, i_{k-1})$, the transformation is:\n$$x'_{i_1} = x'_{\\pi(i_0)} = x_{i_0}$$\n$$x'_{i_2} = x'_{\\pi(i_1)} = x_{i_1}$$\n$$\\vdots$$\n$$x'_{i_0} = x'_{\\pi(i_{k-1})} = x_{i_{k-1}}$$\nThis is a cyclic left-shift of the values $(x_{i_0}, x_{i_1}, \\dots, x_{i_{k-1}})$. An efficient in-place algorithm operates by \"chasing\" a value through the cycle:\n1. Let $s$ be the starting index of the cycle.\n2. Store the initial value to be moved: `val_to_move = x[s]`.\n3. Let `curr_idx = s`.\n4. In a loop, find the next index `next_idx = p[curr_idx]`.\n5. Swap `val_to_move` with the value at the next position: `val_to_move, x[next_idx] = x[next_idx], val_to_move`. This places the correct value at `x[next_idx]` and picks up the next value to be moved.\n6. Advance to the next index: `curr_idx = next_idx`.\n7. Repeat until we return to the start of the cycle.\n\n**4. Overall Algorithm and Complexity Analysis**\n\nThe complete algorithm combines these cycle-based procedures with a mechanism to process each cycle exactly once.\n\n**Algorithm:**\n1. Iterate with an index $i$ from $0$ to $n-1$.\n2. To track visited indices, use the permutation array $p$. Since all $p[j] \\ge 0$, a negative value can serve as a marker. We use the scheme $p[j] \\leftarrow p[j] - n$. An index $j$ is unvisited if $p[j] \\ge 0$.\n3. If $p[i] \\ge 0$, index $i$ is the start of a new cycle.\n4. Based on whether a forward or inverse permutation is required, apply the corresponding in-place cyclic shift algorithm (right-shift or left-shift) to the elements of $x$ whose indices are in the cycle starting at $i$.\n5. During the traversal of the cycle, mark each visited index $j$ by updating $p[j] \\leftarrow p[j] - n$. This must be done after using $p[j]$ to find the next index in the cycle to avoid breaking the traversal chain.\n6. After the main loop over $i$ completes, the permutation of $x$ is finished.\n7. Before the function returns, restore the permutation array $p$ by iterating from $j=0$ to $n-1$ and, if $p[j] < 0$, updating $p[j] \\leftarrow p[j] + n$.\n\n**Correctness:** The algorithm correctly permutes the vector because the decomposition into disjoint cycles is a fundamental property of permutations. By processing each cycle independently and in-place, and by ensuring every index is part of exactly one processed cycle, the entire vector is correctly rearranged according to the specified permutation. The right-shift and left-shift procedures correctly implement the value movements for forward and inverse permutations, respectively.\n\n**Memory Complexity ($O(1)$):** The algorithm operates directly on the input arrays $x$ and $p$. For each cycle, only a constant number of scalar variables are used for temporary storage (`saved_val`, `curr_idx`, indices, etc.). No auxiliary data structures with size dependent on $n$ or cycle length $k$ are allocated. Thus, the additional memory complexity is $O(1)$.\n\n**Time Complexity ($O(n)$):** The main loop iterates $i$ from $0$ to $n-1$. The `if p[i] \\ge 0` condition ensures that the cycle-processing logic is executed only once per cycle. Each index $j \\in \\{0, \\dots, n-1\\}$ is part of exactly one cycle. It is visited and marked once. The work done per cycle of length $k$ is $O(k)$. The sum of the lengths of all disjoint cycles is $n$. Therefore, the total work done across all cycles is $\\sum O(k_j) = O(\\sum k_j) = O(n)$. The final restoration of the array $p$ takes an additional $O(n)$ operations. The overall time complexity is therefore $O(n) + O(n) = O(n)$.", "answer": "```python\nimport numpy as np\n\ndef apply_permutation(x, p, forward=True):\n    \"\"\"\n    Applies a permutation to a vector in-place.\n\n    Args:\n        x (np.ndarray): The vector to be permuted.\n        p (np.ndarray): The permutation array where p[i] = pi(i).\n        forward (bool): If True, applies the forward permutation (Px).\n                        If False, applies the inverse permutation (P^T x).\n    \"\"\"\n    n = len(x)\n    if n == 0:\n        return\n\n    try:\n        # Main loop to find and process cycles\n        for i in range(n):\n            # p[i] >= 0 indicates the start of an unvisited cycle.\n            if p[i] >= 0:\n                start_idx = i\n                \n                # A cycle of length 1 needs no data movement, just marking.\n                if p[start_idx] == start_idx:\n                    p[start_idx] -= n\n                    continue\n\n                if forward:\n                    # Forward permutation (y[i] = x[p[i]]): right-rotation of values\n                    # (v0, v1, ..., vk-1) -> (v1, v2, ..., v0)\n                    saved_val = x[start_idx]\n                    prev_idx = start_idx\n                    \n                    while True:\n                        curr_idx = p[prev_idx]\n                        p[prev_idx] -= n  # Mark previous index as visited\n                        \n                        if curr_idx == start_idx:\n                            x[prev_idx] = saved_val\n                            break\n                        \n                        x[prev_idx] = x[curr_idx]\n                        prev_idx = curr_idx\n                else:\n                    # Inverse permutation (y[p[i]] = x[i]): left-rotation of values\n                    # (v0, v1, ..., vk-1) -> (vk-1, v0, ..., vk-2)\n                    val_to_move = x[start_idx]\n                    curr_idx = start_idx\n\n                    while True:\n                        next_idx = p[curr_idx]\n                        p[curr_idx] -= n  # Mark current index as visited\n                        \n                        if next_idx == start_idx:\n                            x[start_idx] = val_to_move\n                            break\n                        \n                        # Swap val_to_move with the value at the next position\n                        val_to_move, x[next_idx] = x[next_idx], val_to_move\n                        curr_idx = next_idx\n    finally:\n        # Restore the permutation array p by adding n to all marked (negative) elements.\n        for i in range(n):\n            if p[i] < 0:\n                p[i] += n\n\ndef solve():\n    \"\"\"\n    Runs the test suite for the in-place permutation algorithm.\n    \"\"\"\n    test_cases = [\n        # 1. General case with mixed cycles\n        {\n            \"n\": 8,\n            \"p\": np.array([2, 5, 0, 7, 1, 3, 4, 6]),\n            \"x\": np.array([0.1, -1.5, 2.7, 3.3, -0.4, 9.0, 1.2, -2.2])\n        },\n        # 2. Boundary case of a single element\n        {\n            \"n\": 1,\n            \"p\": np.array([0]),\n            \"x\": np.array([42.0])\n        },\n        # 3. Multiple disjoint cycles\n        {\n            \"n\": 7,\n            \"p\": np.array([1, 2, 0, 4, 3, 6, 5]),\n            \"x\": np.array([10.0, 20.0, 30.0, 40.0, 50.0, 60.0, 70.0])\n        },\n        # 4. Identity permutation\n        {\n            \"n\": 5,\n            \"p\": np.array([0, 1, 2, 3, 4]),\n            \"x\": np.array([-0.0, 1.0, -1.0, 2.5, -2.5])\n        },\n        # 5. Single long cycle\n        {\n            \"n\": 10,\n            \"p\": np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 0]),\n            \"x\": np.array([0.5, 1.5, 2.5, 3.5, 4.5, 5.5, 6.5, 7.5, 8.5, 9.5])\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        p_orig = case[\"p\"].copy()\n        x_orig = case[\"x\"].copy()\n        \n        # --- Test 1: Forward permutation ---\n        p_fwd = p_orig.copy()\n        x_fwd_inplace = x_orig.copy()\n        apply_permutation(x_fwd_inplace, p_fwd, forward=True)\n        \n        # Reference forward \"gather\" operation: y[i] = x[p[i]]\n        y_ref = x_orig[p_orig]\n        \n        check1 = np.allclose(x_fwd_inplace, y_ref)\n        check3_fwd = np.array_equal(p_fwd, p_orig)\n\n        # --- Test 2: Inverse on forward result ---\n        x_inv_on_fwd = x_fwd_inplace.copy()\n        p_inv = p_orig.copy()\n        apply_permutation(x_inv_on_fwd, p_inv, forward=False)\n        \n        check2 = np.allclose(x_inv_on_fwd, x_orig)\n        check3_inv = np.array_equal(p_inv, p_orig)\n        \n        # The third check is whether p is restored after BOTH operations\n        check3 = check3_fwd and check3_inv\n        \n        results.append([check1, check2, check3])\n\n    # Final print statement in the exact required format.\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n\n```", "id": "3564698"}, {"introduction": "Beyond their role in algorithms, permutation matrices possess a rich mathematical structure that connects combinatorics and linear algebra. The cycle decomposition of a permutation $\\sigma$ directly reveals the complete spectral decomposition (eigenvalues and eigenvectors) of its corresponding matrix $P_{\\sigma}$. This advanced practice [@problem_id:3564745] leverages this profound connection to perform a sophisticated calculation: finding the trace of a polynomial function of a permutation matrix, $f(P_{\\sigma})$. This exercise demonstrates the power of the spectral theorem and provides a gateway to understanding more general matrix functions and their applications.", "problem": "Let $\\sigma \\in S_{14}$ be the permutation with cycle decomposition\n$$(1\\ 4\\ 7)\\ (2\\ 3)\\ (5\\ 6\\ 8\\ 9)\\ (10\\ 11\\ 12\\ 13\\ 14).$$\nLet $P_{\\sigma} \\in \\mathbb{R}^{14 \\times 14}$ be the permutation matrix acting on the standard basis vectors by $P_{\\sigma} e_{i} = e_{\\sigma(i)}$. Consider the polynomial\n$$f(x) = 7 - 2 x + 3 x^{2} - 5 x^{3} + 4 x^{4} - x^{5} + 6 x^{6} - 8 x^{7} + 9 x^{8}.$$\nStarting from first principles about permutation matrices as unitary operators decomposing into cyclic shifts on invariant subspaces induced by the cycle decomposition of $\\sigma$, construct a complete eigenbasis for $P_{\\sigma}$ and then use the resulting spectral representation together with the polynomial functional calculus for normal matrices to compute the exact value of the trace of $f(P_{\\sigma})$. Express your final answer as a single exact integer with no rounding.", "solution": "The problem is well-posed and mathematically sound. We proceed with a complete solution.\n\nLet the given permutation be $\\sigma \\in S_{14}$, with its disjoint cycle decomposition\n$$ \\sigma = (1\\ 4\\ 7)\\ (2\\ 3)\\ (5\\ 6\\ 8\\ 9)\\ (10\\ 11\\ 12\\ 13\\ 14) $$\nLet the cycles be denoted as $C_1 = (1\\ 4\\ 7)$, $C_2 = (2\\ 3)$, $C_3 = (5\\ 6\\ 8\\ 9)$, and $C_4 = (10\\ 11\\ 12\\ 13\\ 14)$. The lengths of these cycles are $k_1=3$, $k_2=2$, $k_3=4$, and $k_4=5$, respectively.\n\nThe permutation matrix $P_{\\sigma} \\in \\mathbb{R}^{14 \\times 14}$ is defined by its action on the standard basis vectors $\\{e_i\\}_{i=1}^{14}$ of $\\mathbb{R}^{14}$: $P_{\\sigma} e_{i} = e_{\\sigma(i)}$. Since permutation matrices satisfy $P_{\\sigma} P_{\\sigma}^T = P_{\\sigma}^T P_{\\sigma} = I$, they are orthogonal, and as real matrices, they are a specific case of normal matrices. This allows for the application of the spectral theorem and polynomial functional calculus.\n\nThe vector space $\\mathbb{C}^{14}$ decomposes into a direct sum of subspaces that are invariant under the action of $P_{\\sigma}$. These subspaces are spanned by the basis vectors corresponding to the indices in each cycle of $\\sigma$.\nLet $V_j = \\text{span}\\{ e_i \\mid i \\in C_j \\}$ for $j=1, 2, 3, 4$. Then $\\mathbb{C}^{14} = V_1 \\oplus V_2 \\oplus V_3 \\oplus V_4$. The matrix $P_{\\sigma}$ is block-diagonal with respect to the basis formed by concatenating the bases for each $V_j$. The block corresponding to $V_j$ is a $k_j \\times k_j$ cyclic permutation matrix.\n\nThe problem requires constructing a complete eigenbasis. For a generic $k$-cycle $C=(i_1\\ i_2\\ \\dots\\ i_k)$, the restriction of $P_\\sigma$ to $V = \\text{span}\\{e_{i_1}, \\dots, e_{i_k}\\}$ has eigenvalues that are the $k$-th roots of unity, $\\lambda_m = \\omega_k^m = \\exp(2\\pi i m / k)$ for $m=0, 1, \\dots, k-1$. The corresponding eigenvector for the eigenvalue $\\lambda_m$ is given by $v_m = \\sum_{j=1}^{k} \\lambda_m^{-j} e_{i_j}$. An eigenbasis for $P_\\sigma$ is the union of the eigenbases for each of its cyclic blocks.\n\nThe polynomial functional calculus for a normal matrix $A$ with spectral decomposition $A=UDU^*$ defines $f(A) = Uf(D)U^*$, where $f(D)$ is the diagonal matrix with entries $f(\\lambda_i)$ for each eigenvalue $\\lambda_i$ of $A$. The trace of $f(P_{\\sigma})$ is then\n$$ \\text{tr}(f(P_{\\sigma})) = \\text{tr}(U f(D) U^*) = \\text{tr}(f(D) U^* U) = \\text{tr}(f(D)) = \\sum_{i=1}^{14} f(\\lambda_i) $$\nwhere $\\{\\lambda_i\\}_{i=1}^{14}$ is the set of all eigenvalues of $P_{\\sigma}$. This set is the multiset union of the eigenvalues of its cyclic blocks. The calculation of the trace thus decomposes into sums over the eigenvalues for each cycle:\n$$ \\text{tr}(f(P_{\\sigma})) = \\sum_{\\lambda \\in \\text{eig}(P_{C_1})} f(\\lambda) + \\sum_{\\lambda \\in \\text{eig}(P_{C_2})} f(\\lambda) + \\sum_{\\lambda \\in \\text{eig}(P_{C_3})} f(\\lambda) + \\sum_{\\lambda \\in \\text{eig}(P_{C_4})} f(\\lambda) $$\nLet $S_j$ be the sum corresponding to cycle $C_j$. The polynomial is $f(x) = 7 - 2 x + 3 x^{2} - 5 x^{3} + 4 x^{4} - x^{5} + 6 x^{6} - 8 x^{7} + 9 x^{8}$.\n\n1.  **Cycle $C_1 = (1\\ 4\\ 7)$ of length $k_1=3$:**\n    The eigenvalues are the $3$-rd roots of unity: $\\{1, \\omega_3, \\omega_3^2\\}$, where $\\omega_3 = \\exp(2\\pi i/3)$. For any such root $\\lambda$, we have $\\lambda^3=1$. We can evaluate $f(\\lambda)$ by reducing the polynomial $f(x)$ modulo $x^3-1$.\n    $x^3 \\equiv 1$, $x^4 \\equiv x$, $x^5 \\equiv x^2$, $x^6 \\equiv (x^3)^2 \\equiv 1$, $x^7 \\equiv x$, $x^8 \\equiv x^2$.\n    $f(x) \\equiv 7 - 2x + 3x^2 - 5(1) + 4(x) - (x^2) + 6(1) - 8(x) + 9(x^2) \\pmod{x^3-1}$\n    $f(x) \\equiv (7 - 5 + 6) + (-2 + 4 - 8)x + (3 - 1 + 9)x^2 \\pmod{x^3-1}$\n    $f(x) \\equiv 8 - 6x + 11x^2 \\pmod{x^3-1}$.\n    Let $r_1(x) = 8 - 6x + 11x^2$. The sum is $S_1 = \\sum_{m=0}^{2} f(\\omega_3^m) = \\sum_{m=0}^{2} r_1(\\omega_3^m)$.\n    $S_1 = \\sum_{m=0}^{2} (8 - 6\\omega_3^m + 11(\\omega_3^m)^2) = 8 \\sum_{m=0}^{2} 1 - 6 \\sum_{m=0}^{2} \\omega_3^m + 11 \\sum_{m=0}^{2} (\\omega_3^2)^m$.\n    Using the property that $\\sum_{m=0}^{k-1} (\\omega_k^j)^m = 0$ for $j \\not\\equiv 0 \\pmod k$ and $k$ for $j \\equiv 0 \\pmod k$:\n    $S_1 = 8 \\cdot 3 - 6 \\cdot 0 + 11 \\cdot 0 = 24$.\n\n2.  **Cycle $C_2 = (2\\ 3)$ of length $k_2=2$:**\n    The eigenvalues are the $2$-nd roots of unity: $\\{1, -1\\}$.\n    $S_2 = f(1) + f(-1)$.\n    $f(1) = 7 - 2(1) + 3(1)^2 - 5(1)^3 + 4(1)^4 - (1)^5 + 6(1)^6 - 8(1)^7 + 9(1)^8 = 7 - 2 + 3 - 5 + 4 - 1 + 6 - 8 + 9 = 13$.\n    $f(-1) = 7 - 2(-1) + 3(-1)^2 - 5(-1)^3 + 4(-1)^4 - (-1)^5 + 6(-1)^6 - 8(-1)^7 + 9(-1)^8 = 7 + 2 + 3 + 5 + 4 + 1 + 6 + 8 + 9 = 45$.\n    $S_2 = 13 + 45 = 58$.\n\n3.  **Cycle $C_3 = (5\\ 6\\ 8\\ 9)$ of length $k_3=4$:**\n    The eigenvalues are the $4$-th roots of unity: $\\{1, i, -1, -i\\}$. For any such root $\\lambda$, $\\lambda^4=1$. We reduce $f(x)$ modulo $x^4-1$.\n    $x^4 \\equiv 1$, $x^5 \\equiv x$, $x^6 \\equiv x^2$, $x^7 \\equiv x^3$, $x^8 \\equiv (x^4)^2 \\equiv 1$.\n    $f(x) \\equiv 7 - 2x + 3x^2 - 5x^3 + 4(1) - (x) + 6(x^2) - 8(x^3) + 9(1) \\pmod{x^4-1}$\n    $f(x) \\equiv (7 + 4 + 9) + (-2 - 1)x + (3 + 6)x^2 + (-5 - 8)x^3 \\pmod{x^4-1}$\n    $f(x) \\equiv 20 - 3x + 9x^2 - 13x^3 \\pmod{x^4-1}$.\n    Let $r_3(x) = 20 - 3x + 9x^2 - 13x^3$. The sum is $S_3 = \\sum_{m=0}^{3} f(\\omega_4^m) = \\sum_{m=0}^{3} r_3(\\omega_4^m)$.\n    $S_3 = 20 \\sum_{m=0}^{3} 1 - 3 \\sum_{m=0}^{3} \\omega_4^m + 9 \\sum_{m=0}^{3} (\\omega_4^2)^m - 13 \\sum_{m=0}^{3} (\\omega_4^3)^m$.\n    All sums of powers of roots of unity are zero except the first one.\n    $S_3 = 20 \\cdot 4 - 3 \\cdot 0 + 9 \\cdot 0 - 13 \\cdot 0 = 80$.\n\n4.  **Cycle $C_4 = (10\\ 11\\ 12\\ 13\\ 14)$ of length $k_4=5$:**\n    The eigenvalues are the $5$-th roots of unity. For any such root $\\lambda$, $\\lambda^5=1$. We reduce $f(x)$ modulo $x^5-1$.\n    $x^5 \\equiv 1$, $x^6 \\equiv x$, $x^7 \\equiv x^2$, $x^8 \\equiv x^3$.\n    $f(x) \\equiv 7 - 2x + 3x^2 - 5x^3 + 4x^4 - (1) + 6(x) - 8(x^2) + 9(x^3) \\pmod{x^5-1}$\n    $f(x) \\equiv (7 - 1) + (-2 + 6)x + (3 - 8)x^2 + (-5 + 9)x^3 + 4x^4 \\pmod{x^5-1}$\n    $f(x) \\equiv 6 + 4x - 5x^2 + 4x^3 + 4x^4 \\pmod{x^5-1}$.\n    Let $r_4(x) = 6 + 4x - 5x^2 + 4x^3 + 4x^4$. The sum is $S_4 = \\sum_{m=0}^{4} f(\\omega_5^m) = \\sum_{m=0}^{4} r_4(\\omega_5^m)$.\n    $S_4 = 6 \\sum_{m=0}^{4} 1 + 4 \\sum_{m=0}^{4} \\omega_5^m - \\dots$\n    Again, only the constant term contributes to the sum.\n    $S_4 = 6 \\cdot 5 = 30$.\n\nFinally, the total trace is the sum of these individual contributions:\n$$ \\text{tr}(f(P_{\\sigma})) = S_1 + S_2 + S_3 + S_4 = 24 + 58 + 80 + 30 $$\n$$ \\text{tr}(f(P_{\\sigma})) = 82 + 110 = 192 $$\nThe exact value of the trace is $192$.", "answer": "$$\\boxed{192}$$", "id": "3564745"}]}