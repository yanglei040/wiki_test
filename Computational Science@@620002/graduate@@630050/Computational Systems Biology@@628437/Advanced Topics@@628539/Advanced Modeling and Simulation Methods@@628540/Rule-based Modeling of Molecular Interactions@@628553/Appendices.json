{"hands_on_practices": [{"introduction": "A rule-based model is built upon a precise definition of molecular components and their potential states. This first exercise [@problem_id:3347082] solidifies your understanding of the fundamental syntax used in languages like the BioNetGen Language (BNGL). By correctly interpreting a molecule's declaration, you can enumerate all its possible internal and bonding states, a crucial first step before defining the rules that govern their interactions.", "problem": "In the BioNetGen Language (BNGL), a molecule type declaration specifies the set of sites on a molecule, which sites can carry internal states, and which sites can participate in bonds. Internal states are enumerated using the tilde symbol $\\,\\sim\\,$, and bonds are indicated by matching numeric labels introduced with the exclamation mark symbol $\\!\\,$. According to BNGL’s well-established semantics: a site declared with an internal state enumeration has exactly those internal states available; a site declared without an internal state enumeration has no internal states; each site can participate in at most one bond at a time; and numeric bond labels have no intrinsic identity other than pairing the two sites that share the same label within a pattern. Consider the molecule types $A(s1\\sim U\\sim P,\\, s2)$ and $B(b)$, where $A$ has two sites $s1$ and $s2$ with $s1$ having internal states $U$ and $P$, and $B$ has one site $b$.\n\nFrom these definitions and constraints alone, determine which option correctly enumerates both the possible bond states specifically between $A.s2$ and $B.b$, and the internal states available to $A.s1$. Choose the single best option that lists all and only the permitted possibilities implied by the molecule type declarations and BNGL bonding rules.\n\nA. Bond states between $A.s2$ and $B.b$: exactly $2$ possibilities — unbound (no shared bond label, e.g., $A(s2)$ and $B(b)$ without any $!n$ linking them) and singly bound (e.g., $A(s2!1).B(b!1)$). Internal states available to $A.s1$: exactly $2$ possibilities — $A(s1\\sim U)$ and $A(s1\\sim P)$.\n\nB. Bond states between $A.s2$ and $B.b$: countably many possibilities distinguished by bond labels $!n$ with $n\\in\\mathbb{N}$ (e.g., $A(s2!1).B(b!1)$, $A(s2!2).B(b!2)$, etc.). Internal states available to $A.s1$: exactly $2$ possibilities — $A(s1\\sim U)$ and $A(s1\\sim P)$.\n\nC. Bond states between $A.s2$ and $B.b$: $3$ possibilities — unbound, singly bound, or bound through two distinct bonds simultaneously (double bond). Internal states available to $A.s1$: exactly $2$ possibilities — $A(s1\\sim U)$ and $A(s1\\sim P)$.\n\nD. Bond states between $A.s2$ and $B.b$: exactly $2$ possibilities — unbound and singly bound. Internal states available to $A.s1$: $3$ possibilities — $A(s1\\sim U)$, $A(s1\\sim P)$, and a wildcard $A(s1\\sim ?)$ representing an additional unspecified state.\n\nE. Bond states between $A.s2$ and $B.b$: exactly $2$ possibilities — unbound and singly bound. Internal states available to $A.s1$: none, because $A(s1\\sim U\\sim P)$ only constrains rule matching but does not define actual internal states for $s1$.", "solution": "### Problem Validation\n\n#### Step 1: Extract Givens\nThe problem provides the following definitions, rules, and constraints for the BioNetGen Language (BNGL):\n- **Molecule Declaration:** A molecule type declaration specifies the set of sites, which sites can carry internal states, and which sites can participate in bonds.\n- **Internal States:** Internal states are enumerated using the tilde symbol $\\,\\sim\\,$.\n- **Bonds:** Bonds are indicated by matching numeric labels introduced with the exclamation mark symbol $\\!\\,$.\n- **Semantics of Internal States (1):** \"a site declared with an internal state enumeration has exactly those internal states available\".\n- **Semantics of Internal States (2):** \"a site declared without an internal state enumeration has no internal states\".\n- **Semantics of Bonds (1):** \"each site can participate in at most one bond at a time\".\n- **Semantics of Bonds (2):** \"numeric bond labels have no intrinsic identity other than pairing the two sites that share the same label within a pattern\".\n- **Specific Molecule Types:**\n    - `$A(s1\\sim U\\sim P,\\, s2)$`: Molecule `$A$` has two sites, `$s1$` and `$s2$`. Site `$s1$` has internal states `$U$` and `$P$`. Site `$s2$` has no declared internal states.\n    - `$B(b)$`: Molecule `$B$` has one site, `$b$`, with no declared internal states.\n- **Question:** Determine the possible bond states between `$A.s2$` and `$B.b$` and the internal states available to `$A.s1$`.\n\n#### Step 2: Validate Using Extracted Givens\nThe problem statement will be validated against the specified criteria.\n\n- **Scientifically Grounded:** The problem is based on the formal syntax and semantics of the BioNetGen Language (BNGL), a well-established software tool and language used in computational systems biology for rule-based modeling of biochemical networks. The rules provided are standard and accurate representations of BNGL's core principles. The problem is firmly grounded in a formal, scientific system.\n- **Well-Posed:** The problem is clearly defined. The rules are deterministic and provide a complete basis for deducing a unique set of possibilities for the states in question. The question asks for an enumeration of possibilities, which is a well-defined task given the formal rules.\n- **Objective:** The language is precise and technical, relying on the defined semantics of BNGL. It is free of ambiguity, subjectivity, or opinion.\n\nThe problem does not exhibit any of the listed flaws:\n1.  **Scientific or Factual Unsoundness:** The premises are factually correct regarding BNGL semantics.\n2.  **Non-Formalizable or Irrelevant:** The problem is about a formal language and is directly relevant to the topic of rule-based modeling.\n3.  **Incomplete or Contradictory Setup:** All necessary rules and definitions are provided. The givens, such as the rule that a site can have at most one bond, are consistent.\n4.  **Unrealistic or Infeasible:** The problem is a conceptual analysis of a formal system, and questions of physical realism are not directly applicable, but the system itself is designed to model real biological systems. There are no inconsistent data.\n5.  **Ill-Posed or Poorly Structured:** The problem is well-structured and leads to a unique, meaningful answer.\n6.  **Pseudo-Profound, Trivial, or Tautological:** The problem requires a careful application of several distinct rules and an understanding of their interplay, particularly the distinction between a bond label and a bond state. It is a substantive question of language semantics.\n7.  **Outside Scientific Verifiability:** The answer can be verified by consulting the official BNGL documentation and semantic definitions.\n\n#### Step 3: Verdict and Action\nThe problem statement is **valid**. It is a well-formed question about the semantics of a formal language used in a scientific context. The solution process can proceed.\n\n### Derivation of the Correct Answer\n\nThe problem requires a determination of two distinct sets of possibilities based on the provided BNGL rules: (1) the internal states of site `$A.s1$`, and (2) the bond states between sites `$A.s2$` and `$B.b$`.\n\n#### 1. Internal States Available to $A.s1$\n\nThe molecule type declaration for `$A$` is given as `$A(s1\\sim U\\sim P,\\, s2)$`. The problem explicitly states the semantic rule: \"a site declared with an internal state enumeration has exactly those internal states available\".\n\n- The site `$s1$` is declared with the enumeration `$\\sim U\\sim P$`.\n- According to the rule, this means the set of all possible internal states for `$s1$` is precisely `$\\{U, P\\}$`.\n- Therefore, there are exactly $2$ possible internal states for `$A.s1$`. In BNGL patterns, these would be represented as `$A(s1\\sim U)$` and `$A(s1\\sim P)$`.\n\n#### 2. Bond States Between $A.s2$ and $B.b$\n\nThe analysis of bond states concerns the relationship between two specific sites, `$A.s2$` and `$B.b$`. We must consider all possible connection statuses between them.\n\n- The first relevant rule is: \"each site can participate in at most one bond at a time\".\n- This rule immediately imposes a strong constraint. Any given site, such as `$A.s2$` or `$B.b$`, can be in one of two conditions: unbound, or bound to exactly one partner site. The possibility of being bound to multiple partners simultaneously (e.g., a \"double bond\" to the same partner, or bonds to two different partners) is explicitly forbidden.\n\nLet's enumerate the possibilities for the pair of sites (`$A.s2$`, `$B.b$`):\n\n- **Possibility 1: Unbound.** The sites `$A.s2$` and `$B.b$` are not connected by a bond. This is a valid state. In BNGL, this would be represented by the absence of a shared bond label, for example, `$A(s2), B(b)$` existing as separate species or parts of a larger complex without a direct link between these sites. This constitutes one distinct \"bond state\" (the state of being unbound).\n\n- **Possibility 2: Bound.** The site `$A.s2$` is connected to the site `$B.b$` by a bond.\n    - The rule \"each site can participate in at most one bond at a time\" means that if they are bound, it must be via a single bond.\n    - Now we must consider the second rule for bonds: \"numeric bond labels have no intrinsic identity other than pairing the two sites that share the same label within a pattern\". This is a critical semantic point. While one can write the bond using different labels, such as `$A(s2!1).B(b!1)$` or `$A(s2!5).B(b!5)$`, these are not different *types* of bonds or different *states* of connectivity. They all represent the same logical state: `$A.s2$` is bound to `$B.b$`. The number is merely an index for correctly pairing partners within a complex pattern, not a property of the bond itself.\n    - Therefore, there is only one \"bound\" state between `$A.s2$` and `$B.b$`.\n\nCombining these findings, there are exactly $2$ possible bond states between `$A.s2$` and `$B.b$`: unbound and singly bound.\n\n#### Summary of Results\n- **Internal states of $A.s1$**: Exactly $2$ possibilities (`$U$` and `$P$`).\n- **Bond states between $A.s2$ and $B.b$**: Exactly $2$ possibilities (unbound and singly bound).\n\n### Option-by-Option Analysis\n\n**A. Bond states between $A.s2$ and $B.b$: exactly $2$ possibilities — unbound (no shared bond label, e.g., $A(s2)$ and $B(b)$ without any $!n$ linking them) and singly bound (e.g., $A(s2!1).B(b!1)$). Internal states available to $A.s1$: exactly $2$ possibilities — $A(s1\\sim U)$ and $A(s1\\sim P)$.**\n- The analysis of bond states is correct. There are exactly two: unbound and singly bound.\n- The analysis of internal states is correct. There are exactly two: `$U$` and `$P$`.\n- **Verdict: Correct.**\n\n**B. Bond states between $A.s2$ and $B.b$: countably many possibilities distinguished by bond labels $!n$ with $n\\in\\mathbb{N}$ (e.g., $A(s2!1).B(b!1)$, $A(s2!2).B(b!2)$, etc.). Internal states available to $A.s1$: exactly $2$ possibilities — $A(s1\\sim U)$ and $A(s1\\sim P)$.**\n- The analysis of bond states is incorrect. It misinterprets the role of bond labels. The problem explicitly states that \"numeric bond labels have no intrinsic identity\". Different labels `$!1, !2, \\ldots$` do not create different states of being bound.\n- **Verdict: Incorrect.**\n\n**C. Bond states between $A.s2$ and $B.b$: $3$ possibilities — unbound, singly bound, or bound through two distinct bonds simultaneously (double bond). Internal states available to $A.s1$: exactly $2$ possibilities — $A(s1\\sim U)$ and $A(s1\\sim P)$.**\n- The analysis of bond states is incorrect. A \"double bond\" would require each site to participate in two bonds, which is explicitly forbidden by the rule \"each site can participate in at most one bond at a time\".\n- **Verdict: Incorrect.**\n\n**D. Bond states between $A.s2$ and $B.b$: exactly $2$ possibilities — unbound and singly bound. Internal states available to $A.s1$: $3$ possibilities — $A(s1\\sim U)$, $A(s1\\sim P)$, and a wildcard $A(s1\\sim ?)$ representing an additional unspecified state.**\n- The analysis of internal states is incorrect. The problem states that the declared enumeration is exact: \"a site declared with an internal state enumeration has exactly those internal states available\". The wildcard `$?$` is a feature for matching patterns in rules, not a concrete state that a molecule can adopt. The set of available states is `$\\{U, P\\}$`, which has cardinality $2$.\n- **Verdict: Incorrect.**\n\n**E. Bond states between $A.s2$ and $B.b$: exactly $2$ possibilities — unbound and singly bound. Internal states available to $A.s1$: none, because $A(s1\\sim U\\sim P)$ only constrains rule matching but does not define actual internal states for $s1$.**\n- The analysis of internal states is incorrect. This statement directly contradicts the given rule: \"a site declared with an internal state enumeration has exactly those internal states available\". The declaration `$s1\\sim U\\sim P$` is what *defines* the available states.\n- **Verdict: Incorrect.**\n\nBased on the rigorous application of the provided semantic rules, only option A accurately describes both the possible bond states and internal states.", "answer": "$$\\boxed{A}$$", "id": "3347082"}, {"introduction": "Rules drive the dynamics of a model by specifying transformations that can occur in the system. The rate of a rule-based reaction is determined by counting the number of \"embeddings\"—or valid matches—of its pattern in the current molecular mixture. This practice problem [@problem_id:3347060] challenges you to apply the formal definition of pattern matching, including contextual constraints, to calculate the number of eligible opportunities for a rule to fire.", "problem": "Consider a rule-based model of molecular interactions following the conventions of the Kappa language and the BioNetGen Language (BNGL), where an agent is a typed entity with named sites that can carry discrete internal states and binding states. A rule consists of a left-hand side pattern that must be embedded into the current mixture and a right-hand side that specifies the transformation. An embedding is a mapping from the left-hand side pattern into the mixture that preserves agent types, site names, site internal states, and site binding states, subject to any contextual constraints specified by the rule. The propensity contribution of a rule application is proportional to the number of such embeddings.\n\nLet agent $A$ have a single site $s$ with an internal state that can be either $U$ or $P$, and a binding state that can be either unbound or bound. Consider the unary rule whose left-hand side pattern is $A(s\\sim U)$ and whose right-hand side updates the internal state to $P$, written informally as $A(s\\sim U) \\to A(s\\sim P)$. The rule additionally carries the contextual constraint that the site $s$ must be unbound at the time of matching. The mixture contains $N$ distinct instances of $A$ in which site $s$ is in internal state $U$ and unbound, and $M$ distinct instances of $A$ in which site $s$ is bound (regardless of the internal state). Assume that each agent instance is distinguishable for purposes of counting embeddings and that the left-hand side pattern contains exactly the single agent $A$ with the single site $s$.\n\nUsing only the formal definition of pattern embedding in rule-based modeling as a graph homomorphism preserving labels, site internal states, and binding states, and the fact that a contextual constraint must be satisfied by any valid embedding, derive from first principles the total number of embeddings of the left-hand side pattern into the mixture that are eligible for firing under this rule. Express your final answer as a closed-form expression in terms of $N$ and $M$. No rounding is required. No units are required.", "solution": "The problem requires the derivation of the total number of eligible embeddings for a given rule in a rule-based modeling context, based on first principles. An embedding is a mapping from the rule's left-hand side pattern to the mixture of agents that preserves all specified properties and satisfies any additional contextual constraints.\n\nFirst, let us formalize the components of the problem.\n\n1.  **The Left-Hand Side (LHS) Pattern:** The LHS pattern, which we can denote as $\\mathcal{P}$, is specified as $A(s\\sim U)$. This pattern consists of a single agent of type $A$. It has one specified site, $s$, which must be in the internal state $U$. The binding state of site $s$ is not specified within the pattern itself.\n\n2.  **The Contextual Constraint:** The rule carries an additional condition that is not part of the LHS pattern but must be satisfied for an embedding to be valid. This constraint is that the site $s$ of the matched agent must be unbound.\n\n3.  **Conditions for a Valid Embedding:** For an agent instance in the mixture to be a valid target for an embedding of the pattern $\\mathcal{P}$ under the given rule, it must satisfy all conditions from both the pattern and the contextual constraint. Let an agent in the mixture be denoted by $a$. A valid embedding maps the single agent in $\\mathcal{P}$ to an agent $a$ such that:\n    a. The agent type of $a$ is $A$.\n    b. The site $s$ of agent $a$ has an internal state of $U$.\n    c. The site $s$ of agent $a$ is unbound (due to the contextual constraint).\n\n4.  **The Mixture Composition:** The problem describes the state of the system, i.e., the mixture of agents. The mixture contains agents of type $A$ which can be partitioned into disjoint sets based on the properties of their site $s$. We are given:\n    *   A set of $N$ distinct instances of agent $A$ where site $s$ is in internal state $U$ and is unbound. Let us call this set $S_U$.\n    *   A set of $M$ distinct instances of agent $A$ where site $s$ is bound. The internal state of site $s$ for these agents is not specified. Let us call this set $S_B$.\n\n5.  **Counting the Embeddings:** An embedding maps the single agent in the pattern $\\mathcal{P}$ to a specific, distinguishable agent instance in the mixture. Therefore, the total number of valid embeddings is equal to the number of agent instances in the mixture that satisfy all three conditions listed in point 3.\n\nLet us examine each set of agents in the mixture:\n\n*   **Agents in set $S_U$**: There are $N$ such agents. For any agent $a \\in S_U$:\n    1.  Its type is $A$. This matches the pattern.\n    2.  Its site $s$ has internal state $U$. This matches the pattern.\n    3.  Its site $s$ is unbound. This satisfies the contextual constraint.\n    Since each of the $N$ agents in $S_U$ satisfies all required conditions, each of them constitutes a valid target for an embedding. As the agent instances are distinguishable, this gives $N$ distinct and valid embeddings.\n\n*   **Agents in set $S_B$**: There are $M$ such agents. For any agent $a \\in S_B$:\n    1.  Its type is $A$, which matches the pattern.\n    2.  Its site $s$ is bound. This directly violates the contextual constraint that the site must be unbound.\n    Because the contextual constraint is not met, none of the $M$ agents in this set can be targets for a valid embedding, regardless of the internal state of their site $s$. Therefore, this set contributes $0$ valid embeddings.\n\nThe total number of eligible embeddings is the sum of the valid embeddings from all disjoint sets of agents in the mixture.\nTotal Embeddings = (Embeddings from $S_U$) + (Embeddings from $S_B$)\nTotal Embeddings = $N + 0 = N$.\n\nThe information about the $M$ bound agents is provided to test the correct application of the contextual constraint. These agents are part of the state space but are not eligible for this particular rule application. The derivation from first principles thus leads to the conclusion that only the $N$ agents that are both in state $U$ and unbound can be matched. Therefore, the total number of embeddings is exactly $N$.", "answer": "$$\\boxed{N}$$", "id": "3347060"}, {"introduction": "The power of rule-based modeling is realized through simulation, but not all simulation algorithms are created equal. This final practice [@problem_id:3347103] moves from theory to application, asking you to analyze the computational performance scaling of network-based versus network-free simulators. By fitting a model to hypothetical runtime data, you will gain insight into how algorithmic choices for pattern matching and network generation impact simulation efficiency, a critical consideration for any large-scale modeling project.", "problem": "You are asked to design and implement a program that compares the computational cost scaling of two simulation paradigms in rule-based modeling of molecular interactions: network-based simulation and network-free simulation. In rule-based modeling, rules operate on structured species (e.g., site-graphs). A network-based simulator enumerates the full reaction network implied by a set of rules before or during simulation, while a network-free simulator operates on-the-fly, using pattern-matching to identify reaction events without enumerating the network. We assume the dominant runtime cost per trajectory segment is well-approximated by a multiplicative power-law model in the number of molecular species and rules. Specifically, let $S$ denote the number of species and $R$ the number of rules. For a given simulator type $m \\in \\{\\mathrm{nb}, \\mathrm{nf}\\}$ (network-based, network-free), the expected wall-clock runtime $T_m$ (in seconds) is modeled as\n$$\nT_m = c_m \\, S^{\\alpha_{S,m}} \\, R^{\\alpha_{R,m}},\n$$\nwhere $c_m$ is a constant, and $\\alpha_{S,m}$ and $\\alpha_{R,m}$ are dimensionless scaling exponents to be estimated empirically. This power-law form is a standard starting point when the microscopic per-event complexity aggregates multiplicatively over independent extensive factors.\n\nYour task is to:\n- Fit $\\alpha_{S,\\mathrm{nb}}$, $\\alpha_{R,\\mathrm{nb}}$, $\\alpha_{S,\\mathrm{nf}}$, and $\\alpha_{R,\\mathrm{nf}}$ from data by linear regression in logarithmic space using base-$e$ logarithms, estimating the intercept $\\log c_m$ as well.\n- Analyze boundary cases where only one of $S$ or $R$ varies, fitting the relevant single exponent.\n- Use the fitted parameters to predict a runtime ratio at a query point.\n\nUse the following self-consistent test suite of measured runtimes in seconds. When both $S$ and $R$ vary, the measurements are given as aligned lists corresponding to the Cartesian product order $(S,R) \\in \\{(10,50),(10,100),(10,200),(20,50),(20,100),(20,200),(40,50),(40,100),(40,200)\\}$.\n\nTest Suite:\n- Case A (joint variation; fit both exponents for each method):\n  - Species values: $S \\in \\{10,20,40\\}$.\n  - Rule values: $R \\in \\{50,100,200\\}$.\n  - Network-based runtimes $T_{\\mathrm{nb}}$ in seconds (aligned with the above order):\n    $[0.25,\\,0.5,\\,1.0,\\,0.5,\\,1.0,\\,2.0,\\,1.0,\\,2.0,\\,4.0]$.\n  - Network-free runtimes $T_{\\mathrm{nf}}$ in seconds (aligned with the above order):\n    $[0.14142135624,\\,0.2,\\,0.28284271247,\\,0.28284271247,\\,0.4,\\,0.56568542495,\\,0.56568542495,\\,0.8,\\,1.13137084990]$.\n- Case B (boundary; vary $S$ only at fixed $R$ for the network-based method):\n  - Fixed rules: $R=100$.\n  - Species values: $S \\in \\{5,10,20,40\\}$.\n  - Network-based runtimes $T_{\\mathrm{nb}}$ in seconds: $[0.25,\\,0.5,\\,1.0,\\,2.0]$.\n- Case C (boundary; vary $R$ only at fixed $S$ for the network-free method):\n  - Fixed species: $S=20$.\n  - Rule values: $R \\in \\{25,50,100,200,400\\}$.\n  - Network-free runtimes $T_{\\mathrm{nf}}$ in seconds: $[0.2,\\,0.28284271247,\\,0.4,\\,0.56568542495,\\,0.8]$.\n- Case D (query; compare cost at a new point using the jointly fitted parameters from Case A):\n  - Query point: $(S,R)=(30,150)$.\n  - Compute the predicted ratio $T_{\\mathrm{nb}}/T_{\\mathrm{nf}}$ using the fitted $(c_{\\mathrm{nb}},\\alpha_{S,\\mathrm{nb}},\\alpha_{R,\\mathrm{nb}})$ and $(c_{\\mathrm{nf}},\\alpha_{S,\\mathrm{nf}},\\alpha_{R,\\mathrm{nf}})$ from Case A.\n\nMathematical and algorithmic requirements:\n- Adopt the model $T_m = c_m \\, S^{\\alpha_{S,m}} \\, R^{\\alpha_{R,m}}$ and transform it with the natural logarithm to obtain a linear model in $\\log S$ and $\\log R$:\n$$\n\\log T_m = \\log c_m + \\alpha_{S,m} \\log S + \\alpha_{R,m} \\log R.\n$$\n- For boundary cases where only one variable varies, fit the corresponding single-exponent linear model in logarithmic space.\n- Use ordinary least squares to estimate the intercept and slope(s). The result should be independent of the order in which the data points are processed.\n- All times are in seconds. All exponents are dimensionless. The ratio in Case D is dimensionless.\n- Numerical output requirements:\n  - Round all reported floating-point results to three decimal places.\n  - The final program output must be a single line containing the results aggregated as a comma-separated list enclosed in square brackets in the following order:\n    $[\\alpha_{S,\\mathrm{nb}}^{(A)},\\alpha_{R,\\mathrm{nb}}^{(A)},\\alpha_{S,\\mathrm{nf}}^{(A)},\\alpha_{R,\\mathrm{nf}}^{(A)},\\alpha_{S,\\mathrm{nb}}^{(B)},\\alpha_{R,\\mathrm{nf}}^{(C)},(T_{\\mathrm{nb}}/T_{\\mathrm{nf}})^{(D)}]$,\n    where superscripts $(A)$, $(B)$, $(C)$, and $(D)$ indicate the case used to compute the value.\n- Your program must not read any input and must not access any external files or networks. It must compute its results from the constants given above and print the single required output line.\n\nScientific realism and interpretability:\n- Begin your reasoning from the core definitions of rule-based modeling and the fact that pattern matching and event selection costs are the dominant contributors to runtime in typical implementations.\n- Explain, in your accompanying solution, how differences between network-based and network-free exponents can arise from the complexity of reaction network enumeration versus on-the-fly pattern matching and indexing.", "solution": "We begin from the core definitions of rule-based modeling and standard computational cost reasoning. In a rule-based model, a small set of graph-rewrite rules specifies interactions among structured species. A network-based simulator constructs or traverses the full reaction network implied by the rules and species, so its computational cost aggregates over the number of reactions that can be enumerated or traversed as a function of the number of species and the number of rules. A network-free simulator avoids full enumeration, instead repeatedly performing pattern matching of rule left-hand sides against the current system state to identify enabled events. In both paradigms, the per-trajectory segment runtime is often dominated by the multiplicative accumulation of costs associated with traversing species-level data and rule-level pattern operations. This justifies the multiplicative power-law model\n$$\nT_m = c_m\\, S^{\\alpha_{S,m}} R^{\\alpha_{R,m}},\n$$\nwhere $m \\in \\{\\mathrm{nb},\\mathrm{nf}\\}$ distinguishes network-based and network-free methods, $S$ is the number of species, $R$ is the number of rules, $c_m$ is a constant prefactor reflecting implementation details and units, and the exponents $\\alpha_{S,m}$ and $\\alpha_{R,m}$ capture how the dominant costs scale with $S$ and $R$.\n\nTo estimate the exponents empirically from measurements, we take natural logarithms, yielding a linear model in logarithmic space:\n$$\n\\log T_m = \\log c_m + \\alpha_{S,m} \\log S + \\alpha_{R,m} \\log R.\n$$\nFor joint-variation data (Case A), we fit the intercept $\\log c_m$ and the two slopes $\\alpha_{S,m}$, $\\alpha_{R,m}$ via ordinary least squares using the design matrix with columns $[1, \\log S, \\log R]$. For boundary cases (Case B or Case C) where only one of $S$ or $R$ varies, we fit the single-variable linear model in logarithmic space, e.g.,\n$$\n\\log T_{\\mathrm{nb}} = \\log c'_{\\mathrm{nb}} + \\alpha_{S,\\mathrm{nb}} \\log S \\quad \\text{at fixed } R,\n$$\nor\n$$\n\\log T_{\\mathrm{nf}} = \\log c'_{\\mathrm{nf}} + \\alpha_{R,\\mathrm{nf}} \\log R \\quad \\text{at fixed } S.\n$$\nIn all regressions, we use base-$e$ logarithms; the least-squares solution for parameters $\\boldsymbol{\\beta}$ in $\\mathbf{y} = \\mathbf{X} \\boldsymbol{\\beta}$ is\n$$\n\\widehat{\\boldsymbol{\\beta}} = (\\mathbf{X}^\\top \\mathbf{X})^{-1} \\mathbf{X}^\\top \\mathbf{y},\n$$\nwhich is well-defined here because $\\mathbf{X}$ has full column rank by construction of the test suites.\n\nWe now apply this to the provided data. The Case A data are generated by a power-law with exact multiplicative structure, so the log-linear regression will recover, up to numerical precision, the true exponents. For the network-based method in Case A, the measured runtimes exhibit proportionality to $S \\cdot R$, which implies $\\alpha_{S,\\mathrm{nb}} \\approx 1$ and $\\alpha_{R,\\mathrm{nb}} \\approx 1$. For the network-free method in Case A, runtimes scale proportionally to $S \\cdot R^{1/2}$, implying $\\alpha_{S,\\mathrm{nf}} \\approx 1$ and $\\alpha_{R,\\mathrm{nf}} \\approx 1/2$. The boundary cases provide cross-checks under one-dimensional variation: in Case B (network-based, fixed $R$), the fitted $\\alpha_{S,\\mathrm{nb}}$ is approximately $1$, and in Case C (network-free, fixed $S$), the fitted $\\alpha_{R,\\mathrm{nf}}$ is approximately $1/2$.\n\nWith the fitted parameters from Case A, we then predict the runtimes at the query point $(S,R)=(30,150)$ using\n$$\n\\widehat{T}_m = \\exp(\\widehat{\\log c_m}) \\, S^{\\widehat{\\alpha}_{S,m}} R^{\\widehat{\\alpha}_{R,m}},\n$$\nand report the dimensionless ratio $\\widehat{T}_{\\mathrm{nb}} / \\widehat{T}_{\\mathrm{nf}}$.\n\nInterpretation via pattern-matching complexity: The network-based simulator’s exponent $\\alpha_{R,\\mathrm{nb}} \\approx 1$ reflects that costs scale extensively with the number of rules due to explicit network enumeration or traversal, which introduces reaction channels linearly dependent on both the number of species and the number of rules. The network-free simulator’s sublinear rule exponent $\\alpha_{R,\\mathrm{nf}} \\approx 1/2$ here is consistent with on-the-fly pattern matching that does not require exploring all rule-induced reactions; efficient indexing structures reduce dependence on the total number of rules, yielding a weaker-than-linear $R$-dependence (in this synthetic dataset, approximately proportional to $R^{1/2}$). Meanwhile, both methods scale approximately linearly with $S$ because the number of candidate matches or reaction propensities typically aggregates over species instances, producing $\\alpha_{S,\\mathrm{nb}} \\approx 1$ and $\\alpha_{S,\\mathrm{nf}} \\approx 1$. These conclusions are consistent with the fitted exponents derived from the provided measurements.\n\nFinally, we round all reported outputs to three decimal places and print them in the required single-line format:\n$$\n[\\alpha_{S,\\mathrm{nb}}^{(A)},\\alpha_{R,\\mathrm{nb}}^{(A)},\\alpha_{S,\\mathrm{nf}}^{(A)},\\alpha_{R,\\mathrm{nf}}^{(A)},\\alpha_{S,\\mathrm{nb}}^{(B)},\\alpha_{R,\\mathrm{nf}}^{(C)},(T_{\\mathrm{nb}}/T_{\\mathrm{nf}})^{(D)}].\n$$", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef fit_power_law_exponents_joint(S_vals, R_vals, T_vals):\n    \"\"\"\n    Fit log T = a + b log S + c log R via least squares.\n    Returns (a, b, c) where a = log c0, b = alpha_S, c = alpha_R.\n    \"\"\"\n    S_vals = np.asarray(S_vals, dtype=float)\n    R_vals = np.asarray(R_vals, dtype=float)\n    T_vals = np.asarray(T_vals, dtype=float)\n    # Design matrix: [1, log S, log R]\n    X = np.column_stack([np.ones_like(S_vals), np.log(S_vals), np.log(R_vals)])\n    y = np.log(T_vals)\n    beta, *_ = np.linalg.lstsq(X, y, rcond=None)\n    return beta  # a, b, c\n\ndef fit_power_law_single_x(x_vals, T_vals):\n    \"\"\"\n    Fit log T = a + b log x via least squares for single varying variable.\n    Returns (a, b).\n    \"\"\"\n    x_vals = np.asarray(x_vals, dtype=float)\n    T_vals = np.asarray(T_vals, dtype=float)\n    X = np.column_stack([np.ones_like(x_vals), np.log(x_vals)])\n    y = np.log(T_vals)\n    beta, *_ = np.linalg.lstsq(X, y, rcond=None)\n    return beta  # a, b\n\ndef solve():\n    # Case A data: joint variation over S in {10,20,40} and R in {50,100,200}\n    S_list = [10, 20, 40]\n    R_list = [50, 100, 200]\n    # Cartesian product in specified order:\n    pairs = [(10,50),(10,100),(10,200),(20,50),(20,100),(20,200),(40,50),(40,100),(40,200)]\n    S_A = [s for (s, r) in pairs]\n    R_A = [r for (s, r) in pairs]\n    T_nb_A = [0.25, 0.5, 1.0, 0.5, 1.0, 2.0, 1.0, 2.0, 4.0]\n    T_nf_A = [0.14142135624, 0.2, 0.28284271247, 0.28284271247, 0.4, 0.56568542495, 0.56568542495, 0.8, 1.13137084990]\n\n    # Fit joint exponents for network-based and network-free (Case A).\n    a_nb_A, alphaS_nb_A, alphaR_nb_A = fit_power_law_exponents_joint(S_A, R_A, T_nb_A)\n    a_nf_A, alphaS_nf_A, alphaR_nf_A = fit_power_law_exponents_joint(S_A, R_A, T_nf_A)\n\n    # Case B: boundary varying S only at fixed R for network-based.\n    S_B = [5, 10, 20, 40]\n    T_nb_B = [0.25, 0.5, 1.0, 2.0]\n    a_nb_B, alphaS_nb_B = fit_power_law_single_x(S_B, T_nb_B)\n\n    # Case C: boundary varying R only at fixed S for network-free.\n    R_C = [25, 50, 100, 200, 400]\n    T_nf_C = [0.2, 0.28284271247, 0.4, 0.56568542495, 0.8]\n    a_nf_C, alphaR_nf_C = fit_power_law_single_x(R_C, T_nf_C)\n\n    # Case D: predicted ratio at (S,R)=(30,150) using joint fits from Case A.\n    S_D, R_D = 30.0, 150.0\n    # Predicted constants from intercepts:\n    c_nb_hat = np.exp(a_nb_A)\n    c_nf_hat = np.exp(a_nf_A)\n    T_nb_D = c_nb_hat * (S_D ** alphaS_nb_A) * (R_D ** alphaR_nb_A)\n    T_nf_D = c_nf_hat * (S_D ** alphaS_nf_A) * (R_D ** alphaR_nf_A)\n    ratio_D = T_nb_D / T_nf_D\n\n    # Prepare results rounded to three decimals in the specified order:\n    results = [\n        f\"{alphaS_nb_A:.3f}\",\n        f\"{alphaR_nb_A:.3f}\",\n        f\"{alphaS_nf_A:.3f}\",\n        f\"{alphaR_nf_A:.3f}\",\n        f\"{alphaS_nb_B:.3f}\",\n        f\"{alphaR_nf_C:.3f}\",\n        f\"{ratio_D:.3f}\",\n    ]\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3347103"}]}