{"hands_on_practices": [{"introduction": "The foundation of many trajectory inference methods is the concept of turning cell-cell similarities into a measure of developmental progression, or pseudotime. This practice guides you through the implementation of two core strategies for this task. You will compute pseudotime first using geodesic distances on a cell neighborhood graph and then using path lengths on its Minimum Spanning Tree (MST), a common simplification used to define a trajectory backbone [@problem_id:3356250]. This comparison directly illuminates how the choice of graph representation fundamentally shapes the inferred cellular timeline.", "problem": "You are given a small number of weighted, undirected cell-cell graphs that model a neighborhood graph used in trajectory inference. For a specified root cell, define two pseudotime functions over the nodes: (i) the geodesic pseudotime on the original graph defined as the single-source shortest-path distance from the root, and (ii) the tree-projection pseudotime defined as the path length along a Minimum Spanning Tree (MST) from the same root to each node. You will compute both, derive node orderings, and quantify how the orderings agree.\n\nFoundational starting points and definitions:\n- Let a weighted, undirected graph be denoted by $G = (V, E, w)$, with $|V| = n$, vertices labeled $\\{0, 1, \\dots, n-1\\}$, edges $E \\subseteq \\{\\{u,v\\} : u \\neq v, u,v \\in V\\}$, and nonnegative weights $w : E \\to \\mathbb{R}_{\\ge 0}$. The distance of a walk is the sum of edge weights.\n- The geodesic pseudotime $d_G(i)$ of node $i$ from a root $r \\in V$ is the minimal total weight among all walks from $r$ to $i$. This equals the single-source shortest-path distance, computable by Dijkstra’s algorithm for nonnegative weights.\n- A Minimum Spanning Tree (MST) $T$ of $G$ is a spanning tree that minimizes $\\sum_{e \\in T} w(e)$. There may be multiple MSTs if weights allow ties. In this problem, you must construct $T$ deterministically using Kruskal’s algorithm with the following total order on edges: sort by weight ascending; on ties, sort by the lexicographically smallest unordered pair $(\\min(u,v), \\max(u,v))$ ascending; include edges that do not create a cycle until $n-1$ edges are included.\n- The tree-projection pseudotime $d_T(i)$ is defined as the length of the unique path from $r$ to $i$ in the MST $T$, namely the sum of $w(e)$ along that path.\n- Pseudotime induces a total order on nodes by sorting $d(\\cdot)$ ascending. To make ordering deterministic, use an absolute tolerance $\\varepsilon = 10^{-9}$: if $|d(i) - d(j)| \\le \\varepsilon$, then break ties by the smaller node index. Apply this rule identically to both $d_G$ and $d_T$ orderings.\n- To quantify ordering agreement between two total orders on the same node set, compute the inversion count. If $\\pi_G$ and $\\pi_T$ are the two permutations of $\\{0,1,\\dots,n-1\\}$ representing the induced orders, define the inversion count as the number of pairs $(i,j)$ with $0 \\le i < j \\le n-1$ where the relative order of $\\pi_G[i]$ and $\\pi_G[j]$ is reversed in $\\pi_T$. The inversion count is an integer and equals $0$ if and only if the orders are identical.\n- To quantify rank agreement with ties, compute the Spearman rank correlation between the two pseudotime vectors using average ranks for ties. For a vector $x \\in \\mathbb{R}^n$, define its rank vector $R(x) \\in \\mathbb{R}^n$ by setting $R_i(x)$ to the average of the $1$-based positions that $x_i$ occupies among all entries equal to $x_i$ under ascending sort with equality determined by the same $\\varepsilon$. The Spearman correlation between $x$ and $y$ is then the Pearson correlation of $R(x)$ and $R(y)$:\n$$\n\\rho_s(x,y) \\;=\\; \\frac{\\sum_{i=1}^n \\left(R_i(x) - \\overline{R(x)}\\right)\\left(R_i(y) - \\overline{R(y)}\\right)}{\\sqrt{\\sum_{i=1}^n \\left(R_i(x) - \\overline{R(x)}\\right)^2}\\,\\sqrt{\\sum_{i=1}^n \\left(R_i(y) - \\overline{R(y)}\\right)^2}} \\,,\n$$\nwhere $\\overline{R(x)} = \\frac{1}{n}\\sum_{i=1}^n R_i(x)$. If a denominator is zero, treat $\\rho_s$ as undefined; the provided tests avoid that case.\n\nTasks to implement for each test case:\n1. Compute $d_G(i)$ for all nodes $i \\in V$ from the given root $r$ using Dijkstra’s algorithm.\n2. Build the MST $T$ with the deterministic Kruskal rule given above, then compute $d_T(i)$ for all nodes as path lengths from $r$ within $T$.\n3. Construct the two total orders $\\pi_G$ and $\\pi_T$ using the $\\varepsilon$ tie rule.\n4. Compute three outputs:\n   - An equality indicator $q \\in \\{0,1\\}$ where $q = 1$ if $\\pi_G$ and $\\pi_T$ are identical and $q = 0$ otherwise.\n   - The inversion count $I \\in \\mathbb{Z}_{\\ge 0}$ between $\\pi_G$ and $\\pi_T$.\n   - The Spearman rank correlation $\\rho_s \\in \\mathbb{R}$ between the pseudotime vectors $d_G$ and $d_T$ computed with average ranks for ties.\n\nOutput format:\n- For all test cases in order, output a single line containing a comma-separated list enclosed in square brackets. Each test case contributes a bracketed, comma-separated triple $[q,I,\\rho_s]$, where $q$ and $I$ are integers and $\\rho_s$ is a real number rounded to exactly $6$ decimal places. For example: $[[1,0,1.000000],[0,3,0.750000]]$.\n\nTest suite:\n- Test case $1$ (tree “line” graph): $n = 5$, $r = 0$, edges with weights\n  - $\\{0,1\\}$ with weight $1.0$,\n  - $\\{1,2\\}$ with weight $1.5$,\n  - $\\{2,3\\}$ with weight $0.5$,\n  - $\\{3,4\\}$ with weight $2.0$.\n- Test case $2$ (graph where the MST path lengths differ in ordering from geodesic distances): $n = 5$, $r = 0$, edges with weights\n  - $\\{0,1\\}$ with weight $10.0$,\n  - $\\{1,2\\}$ with weight $1.0$,\n  - $\\{2,3\\}$ with weight $1.0$,\n  - $\\{3,4\\}$ with weight $1.0$,\n  - $\\{0,4\\}$ with weight $2.0$,\n  - $\\{0,2\\}$ with weight $2.1$.\n- Test case $3$ (ties): $n = 3$, $r = 0$, edges with weights\n  - $\\{0,1\\}$ with weight $1.0$,\n  - $\\{1,2\\}$ with weight $1.0$,\n  - $\\{0,2\\}$ with weight $1.0$.\n\nYour program must embed these test cases, require no input, and print exactly one line in the format described. Round $\\rho_s$ to exactly $6$ decimal places. Use $\\varepsilon = 10^{-9}$ for all tie decisions.", "solution": "The user-provided problem is assessed to be valid. It is scientifically grounded in computational biology and graph theory, well-posed with deterministic rules, and objective in its formulation. The problem is a concrete algorithmic task that is complete, consistent, and verifiable.\n\nThe solution proceeds by implementing the specified algorithms and measures in a step-by-step manner for each test case.\n\n1.  **Graph Representation**: The input graph $G = (V, E, w)$ for each test case is represented as a sparse adjacency matrix. For an undirected graph with $n = |V|$ vertices, this is an $n \\times n$ matrix where the entry at $(i, j)$ is the weight $w(\\{i,j\\})$ if an edge exists, and zero otherwise. The `scipy.sparse.csr_matrix` format is used for efficient storage and computation.\n\n2.  **Geodesic Pseudotime ($d_G$)**: The geodesic pseudotime $d_G(i)$ for each node $i$ from a given root $r$ is the length of the shortest path from $r$ to $i$. For graphs with non-negative weights, this is computed using Dijkstra's algorithm. The `scipy.sparse.csgraph.dijkstra` function is applied to the graph's adjacency matrix with the specified root node $r$. This yields the vector $d_G$ of pseudotime values.\n\n3.  **Minimum Spanning Tree (MST) and Tree-Projection Pseudotime ($d_T$)**:\n    *   **MST Construction**: A deterministic Minimum Spanning Tree $T$ is constructed using Kruskal's algorithm. To adhere to the problem's strict tie-breaking rule, the graph edges $E$ are first sorted into a total order. The primary sorting key is the edge weight $w(e)$ in ascending order. Ties are broken by sorting the edge's vertices $\\{u,v\\}$ as a pair $(\\min(u,v), \\max(u,v))$ and using lexicographical ascending order. A Disjoint Set Union (DSU) data structure is employed to efficiently track connected components and detect cycles. Edges from the sorted list are iteratively added to the MST if they connect two previously disconnected components, until $n-1$ edges have been selected.\n    *   **Tree-Projection Pseudotime Calculation**: The resulting MST, $T$, is itself a graph. The tree-projection pseudotime $d_T(i)$ is the length of the unique path from the root $r$ to each node $i$ within $T$. These path lengths are computed by applying Dijkstra's algorithm on the adjacency matrix representation of the MST. The resulting vector is $d_T$.\n\n4.  **Pseudotime-Induced Node Ordering ($\\pi_G$ and $\\pi_T$)**: The pseudotime vectors $d_G$ and $d_T$ are used to derive total orderings of the nodes, denoted by permutations $\\pi_G$ and $\\pi_T$. The nodes are sorted based on their pseudotime values in ascending order. A deterministic tie-breaking rule is critical: if two nodes $i$ and $j$ have pseudotime values $d(i)$ and $d(j)$ such that their absolute difference $|d(i) - d(j)|$ is less than or equal to a tolerance $\\varepsilon = 10^{-9}$, the tie is broken by placing the node with the smaller index first. This custom sorting logic is implemented using a comparison function.\n\n5.  **Comparison Metrics**:\n    *   **Equality Indicator ($q$)**: The two permutations $\\pi_G$ and $\\pi_T$ are compared. The indicator $q$ is set to $1$ if they are identical and $0$ otherwise.\n    *   **Inversion Count ($I$)**: The inversion count quantifies the difference in ordering between $\\pi_G$ and $\\pi_T$. It is calculated by counting the number of pairs of nodes whose relative order in $\\pi_G$ is reversed in $\\pi_T$. This is equivalent to computing the number of inversions in the permutation $\\pi_T^{-1} \\circ \\pi_G$, where $\\pi_T^{-1}$ maps each node to its position in the $\\pi_T$ ordering.\n    *   **Spearman Rank Correlation ($\\rho_s$)**: This metric assesses the correlation between the rank-transformed pseudotime vectors $d_G$ and $d_T$.\n        *   **Ranking with Ties**: For each pseudotime vector, a rank vector is computed. Nodes are first sorted by their pseudotime values. Any group of nodes whose pseudotime values are within the tolerance $\\varepsilon = 10^{-9}$ of each other are considered tied. All nodes in a tied group are assigned the average of their 1-based positions in the sorted list.\n        *   **Correlation Calculation**: Once the rank vectors $R(d_G)$ and $R(d_T)$ are obtained, the Spearman correlation $\\rho_s$ is calculated as the Pearson correlation coefficient between these two rank vectors, using the formula:\n            $$ \\rho_s = \\frac{\\sum_{i=0}^{n-1} (R_i(d_G) - \\overline{R(d_G)})(R_i(d_T) - \\overline{R(d_T)})}{\\sqrt{\\sum_{i=0}^{n-1} (R_i(d_G) - \\overline{R(d_G)})^2} \\sqrt{\\sum_{i=0}^{n-1} (R_i(d_T) - \\overline{R(d_T)})^2}} $$\n            The final value is rounded to six decimal places as specified.", "answer": "```python\nimport numpy as np\nfrom scipy.sparse import csr_matrix\nfrom scipy.sparse.csgraph import dijkstra\nfrom functools import cmp_to_key\n\nclass DSU:\n    \"\"\"A minimal Disjoint Set Union (DSU) data structure for Kruskal's algorithm.\"\"\"\n    def __init__(self, n):\n        self.parent = list(range(n))\n\n    def find(self, i):\n        if self.parent[i] == i:\n            return i\n        self.parent[i] = self.find(self.parent[i])\n        return self.parent[i]\n\n    def union(self, i, j):\n        root_i = self.find(i)\n        root_j = self.find(j)\n        if root_i != root_j:\n            self.parent[root_j] = root_i\n            return True\n        return False\n\ndef get_ranks(values, epsilon):\n    \"\"\"Computes ranks for a list of values, handling ties with an epsilon tolerance.\"\"\"\n    n = len(values)\n    # Sort values while keeping original indices\n    indexed_values = sorted([(values[i], i) for i in range(n)])\n    \n    ranks = np.zeros(n, dtype=float)\n    i = 0\n    while i < n:\n        j = i\n        # Find the end of the current tie group\n        while j + 1 < n and abs(indexed_values[j + 1][0] - indexed_values[i][0]) <= epsilon:\n            j += 1\n        \n        # Calculate the average rank for the tie group (1-based positions)\n        avg_rank = sum(range(i + 1, j + 2)) / (j - i + 1)\n        \n        # Assign the average rank to all members of the group\n        for k in range(i, j + 1):\n            original_index = indexed_values[k][1]\n            ranks[original_index] = avg_rank\n            \n        i = j + 1\n        \n    return ranks\n\ndef solve():\n    \"\"\"Main function to solve the problem for all specified test cases.\"\"\"\n    test_cases = [\n        (5, 0, [(0, 1, 1.0), (1, 2, 1.5), (2, 3, 0.5), (3, 4, 2.0)]),\n        (5, 0, [(0, 1, 10.0), (1, 2, 1.0), (2, 3, 1.0), (3, 4, 1.0), (0, 4, 2.0), (0, 2, 2.1)]),\n        (3, 0, [(0, 1, 1.0), (1, 2, 1.0), (0, 2, 1.0)])\n    ]\n    epsilon = 1e-9\n    \n    results = []\n\n    for n, r, edges_list in test_cases:\n        # Part 1: Geodesic Pseudotime d_G\n        rows, cols, data = [], [], []\n        for u, v, w in edges_list:\n            rows.extend([u, v])\n            cols.extend([v, u])\n            data.extend([w, w])\n        graph = csr_matrix((data, (rows, cols)), shape=(n, n))\n        d_G = dijkstra(csgraph=graph, directed=False, indices=r)\n\n        # Part 2: Tree-Projection Pseudotime d_T\n        # 2a: Deterministic MST using Kruskal's\n        sorted_edges = sorted(edges_list, key=lambda e: (e[2], min(e[0], e[1]), max(e[0], e[1])))\n        \n        mst_edges = []\n        dsu = DSU(n)\n        for u, v, w in sorted_edges:\n            if dsu.union(u, v):\n                mst_edges.append((u, v, w))\n            if len(mst_edges) == n - 1:\n                break\n        \n        # 2b: Path lengths in MST\n        mst_rows, mst_cols, mst_data = [], [], []\n        for u, v, w in mst_edges:\n            mst_rows.extend([u, v])\n            mst_cols.extend([v, u])\n            mst_data.extend([w, w])\n        mst_graph = csr_matrix((mst_data, (mst_rows, mst_cols)), shape=(n, n))\n        d_T = dijkstra(csgraph=mst_graph, directed=False, indices=r)\n        \n        # Part 3: Total Orders pi_G and pi_T\n        def compare_pseudotime(d):\n            def compare(i, j):\n                diff = d[i] - d[j]\n                if abs(diff) <= epsilon:\n                    return i - j\n                return 1 if diff > 0 else -1\n            return compare\n\n        pi_G = sorted(range(n), key=cmp_to_key(compare_pseudotime(d_G)))\n        pi_T = sorted(range(n), key=cmp_to_key(compare_pseudotime(d_T)))\n\n        # Part 4: Compute outputs\n        q = 1 if pi_G == pi_T else 0\n\n        pos_T = {node: i for i, node in enumerate(pi_T)}\n        perm = [pos_T[node] for node in pi_G]\n        I = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                if perm[i] > perm[j]:\n                    I += 1\n\n        R_G = get_ranks(d_G, epsilon)\n        R_T = get_ranks(d_T, epsilon)\n        \n        mean_R_G = np.mean(R_G)\n        mean_R_T = np.mean(R_T)\n        num = np.sum((R_G - mean_R_G) * (R_T - mean_R_T))\n        den_G = np.sqrt(np.sum((R_G - mean_R_G)**2))\n        den_T = np.sqrt(np.sum((R_T - mean_R_T)**2))\n        den_prod = den_G * den_T\n        \n        rho_s = num / den_prod if den_prod > 0 else (1.0 if np.all(R_G == R_T) else 0.0)\n        \n        results.append(f\"[{q},{I},{rho_s:.6f}]\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3356250"}, {"introduction": "Biological processes are seldom linear, often involving forks where cells commit to different fates. A primary goal of trajectory inference is to automatically detect these branching events from the data. This hands-on exercise challenges you to implement a foundational method for identifying the topology of a cellular trajectory, including its branchpoints [@problem_id:3356218]. By constructing a Minimum Spanning Tree (MST) and analyzing its structural properties, such as node degree and betweenness centrality, you will learn to translate the abstract idea of a cellular decision point into a concrete, algorithmically identifiable feature of the cell-state manifold.", "problem": "You are given small point clouds in two-dimensional Euclidean space intended to represent simplified single-cell state manifolds with an underlying lineage topology. From these points, you must construct a symmetric union $k$-nearest neighbor ($k$-NN) graph, compute a Minimum Spanning Tree (MST) with Euclidean distances as edge weights, identify branchpoints using node degree and betweenness centrality, and provide a topology classification derived from first principles. Your program must implement the following, starting from the base definitions of graphs, shortest paths, spanning trees, and centrality, without relying on any specialized graph libraries beyond generic sparse linear algebra.\n\nDefinitions and requirements:\n- Let $X \\in \\mathbb{R}^{n \\times d}$ denote the coordinates of $n$ points in $d$-dimensional Euclidean space with $d = 2$. For each dataset:\n  - Compute the pairwise Euclidean distance $d_{ij} = \\lVert x_i - x_j \\rVert_2$ for all $i,j \\in \\{0,\\dots,n-1\\}$.\n  - Construct a symmetric union $k$-NN graph $G = (V,E)$ with $V = \\{0,\\dots,n-1\\}$ and weighted adjacency matrix $W \\in \\mathbb{R}_{\\ge 0}^{n \\times n}$ as follows: for each node $i$, find the set $N_k(i)$ of indices of its $k$ nearest neighbors (excluding $i$ itself). Include an undirected edge $\\{i,j\\}$ if $i \\in N_k(j)$ or $j \\in N_k(i)$, and set $W_{ij} = W_{ji} = d_{ij}$ for such edges, and $W_{ij} = 0$ otherwise.\n  - Compute a Minimum Spanning Tree $T$ on $G$ that minimizes the total weight $\\sum_{\\{i,j\\} \\in T} W_{ij}$, subject to $T$ being a spanning tree on the connected graph induced by $G$.\n  - Compute the degree $\\deg_T(v)$ for each node $v$ in the MST $T$.\n  - Compute the (unnormalized) betweenness centrality $C_B(v)$ for each node $v$ in the MST $T$ defined by\n    $$C_B(v) = \\sum_{\\substack{s \\ne v \\ne t \\\\ s \\ne t}} \\frac{\\sigma_{st}(v)}{\\sigma_{st}},$$\n    where $\\sigma_{st}$ is the number of shortest paths between $s$ and $t$, and $\\sigma_{st}(v)$ is the number of those paths that pass through $v$. For a tree with strictly positive edge weights, there is a unique simple path between any two distinct nodes $s$ and $t$, so $\\sigma_{st} = 1$ and the sum counts the number of unordered pairs whose unique path passes through $v$.\n  - Identify the set of branchpoints\n    $$B = \\left\\{ v \\in V \\;:\\; \\deg_T(v) \\ge 3 \\;\\wedge\\; C_B(v) \\ge \\overline{C_B} \\right\\},$$\n    where $\\overline{C_B}$ is the arithmetic mean of $C_B$ over all nodes of $T$.\n  - Define a topology classification code $c$ as follows:\n    - $c = 0$ if there is no branching, that is, $\\max_v \\deg_T(v) \\le 2$ (a linear trajectory).\n    - $c = 1$ if there is a single branching event with exactly one branchpoint and $\\max_v \\deg_T(v) = 3$ (a single bifurcation-like topology).\n    - $c = 2$ otherwise (multi-furcation or multiple branching events).\n\nYour program must implement the above procedure for each dataset in the test suite below and produce aggregate results.\n\nTest suite:\nFor each case, you are given a point set $X$ and a neighborhood size $k$. Points are listed as ordered pairs with their zero-based indices. Use the coordinates exactly as specified.\n\n- Case $1$ (intended single bifurcation):\n  - $k = 2$.\n  - Points $X \\subset \\mathbb{R}^2$ with indices:\n    - $0$: $(0,-2)$,\n    - $1$: $(0,-1)$,\n    - $2$: $(0,0)$,\n    - $3$: $(1,1)$,\n    - $4$: $(2,2)$,\n    - $5$: $(3,3)$,\n    - $6$: $(-1,1)$,\n    - $7$: $(-2,2)$,\n    - $8$: $(-3,3)$.\n\n- Case $2$ (intended linear trajectory):\n  - $k = 2$.\n  - Points $X \\subset \\mathbb{R}^2$ with indices:\n    - $0$: $(0,0)$,\n    - $1$: $(1,0)$,\n    - $2$: $(2,0)$,\n    - $3$: $(3,0)$,\n    - $4$: $(4,0)$.\n\n- Case $3$ (intended single branching with three arms from the origin):\n  - $k = 2$.\n  - Points $X \\subset \\mathbb{R}^2$ with indices:\n    - $0$: $(0,0)$,\n    - $1$: $(1,0)$,\n    - $2$: $(2,0)$,\n    - $3$: $(3,0)$,\n    - $4$: $(-0.5,0.866)$,\n    - $5$: $(-1,1.732)$,\n    - $6$: $(-1.5,2.598)$,\n    - $7$: $(-0.5,-0.866)$,\n    - $8$: $(-1,-1.732)$,\n    - $9$: $(-1.5,-2.598)$.\n\nRequired final output for each case:\n- A list with four elements $[b, m, c, I]$ where:\n  - $b$ is the number of identified branchpoints $|B|$ (an integer).\n  - $m$ is the maximum degree $\\max_v \\deg_T(v)$ (an integer).\n  - $c$ is the classification code as defined above (an integer).\n  - $I$ is the sorted list of zero-based indices of identified branchpoints $B$.\n\nFinal output format for the program:\n- Your program should produce a single line of output containing the results for all cases as a comma-separated list enclosed in square brackets with no spaces, where each case’s result is the four-element list described above. For example, the output format must be exactly like\n  $$[[b_1,m_1,c_1,[i_{1,1},\\dots]],[b_2,m_2,c_2,[i_{2,1},\\dots]],[b_3,m_3,c_3,[i_{3,1},\\dots}]]$$\nwith no whitespace characters in the printed line.\n\nThere are no physical units, angle units, or percentages required for this problem.", "solution": "The user has provided a computational problem in the domain of single-cell trajectory inference. I will first validate the problem statement and then provide a full solution adhering to the specified constraints.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n\n- **Input Data**: Point sets $X \\in \\mathbb{R}^{n \\times 2}$ and an integer $k$.\n- **Procedure**:\n    1.  **Distance Matrix**: Compute pairwise Euclidean distances $d_{ij} = \\lVert x_i - x_j \\rVert_2$.\n    2.  **Symmetric k-NN Graph**: Construct a graph $G=(V, E)$ with edge weights $W_{ij} = d_{ij}$. An undirected edge $\\{i,j\\}$ exists if node $i$ is in the set of $k$ nearest neighbors of $j$, $N_k(j)$, or if $j \\in N_k(i)$.\n    3.  **Minimum Spanning Tree (MST)**: Compute an MST, denoted $T$, on the graph $G$.\n    4.  **Node Degree**: Compute the degree $\\deg_T(v)$ for each node $v$ in the MST.\n    5.  **Betweenness Centrality**: Compute the unnormalized betweenness centrality $C_B(v) = \\sum_{s \\ne v \\ne t} \\frac{\\sigma_{st}(v)}{\\sigma_{st}}$ for each node $v$ in $T$. In a tree, this counts the number of unique paths between node pairs $(s,t)$ that pass through $v$.\n    6.  **Branchpoint Identification**: A node $v$ is a branchpoint if it belongs to the set $B = \\{ v \\in V \\mid \\deg_T(v) \\ge 3 \\wedge C_B(v) \\ge \\overline{C_B} \\}$, where $\\overline{C_B}$ is the mean of all $C_B(v)$ values.\n    7.  **Topology Classification**: Assign a code $c$ based on the following rules:\n        - $c = 0$ if $\\max_v \\deg_T(v) \\le 2$.\n        - $c = 1$ if $|B| = 1$ and $\\max_v \\deg_T(v) = 3$.\n        - $c = 2$ otherwise.\n- **Test Cases**: Three distinct datasets are provided, each with a point set $X$ and a value for $k$.\n- **Output Format**: For each case, produce a list $[b, m, c, I]$, where $b=|B|$, $m=\\max_v \\deg_T(v)$, $c$ is the classification code, and $I$ is the sorted list of branchpoint indices. The final output must be a single line containing a list of these results, formatted without whitespace.\n\n**Step 2: Validate Using Extracted Givens**\n\n- **Scientific Grounding**: The problem is well-grounded in computational systems biology, specifically mirroring common procedures for trajectory inference from single-cell data. The methods used (k-NN graphs, MST, centrality) are standard in algorithms like Monocle and TSCAN. The problem is scientifically valid and relevant.\n- **Well-Posed**: The problem is specified with mathematical precision. All terms like \"symmetric union k-NN graph,\" \"MST,\" \"betweenness centrality,\" and the criteria for \"branchpoint\" and \"topology classification\" are unambiguously defined. Given the input, the procedure is deterministic and will produce a unique, meaningful solution.\n- **Objective**: The problem statement is formal and quantitative, free of any subjective or opinion-based language.\n- **Completeness and Consistency**: All necessary data (point coordinates, $k$) and definitions are provided. The definitions are logically consistent and the classification scheme is exhaustive. The problem is self-contained.\n- **Feasibility**: The datasets are small and the computations are well within the capacity of standard numerical libraries, even with from-scratch implementations of core algorithms as requested. The setup is a simplified but realistic representation of biological state manifolds.\n\n**Step 3: Verdict and Action**\n\n- **Verdict**: The problem is **VALID**.\n- **Action**: I will now proceed with a complete solution.\n\n### Solution\n\nThe solution will be implemented as a Python program that processes each test case according to the specified pipeline. The core algorithms—Kruskal's for the MST and the centrality calculation on a tree—will be implemented from first principles as required.\n\n**1. Pairwise Distance Calculation**\nFor a given set of $n$ points in $X \\in \\mathbb{R}^{n \\times 2}$, we first compute the symmetric $n \\times n$ matrix of pairwise Euclidean distances, $D$, where $D_{ij} = \\lVert x_i - x_j \\rVert_2$.\n\n**2. Symmetric Union k-NN Graph Construction**\nWe initialize an $n \\times n$ adjacency matrix $W$ with zeros. For each point $i$, we identify the indices of its $k$ nearest neighbors by sorting the distances in the $i$-th row of $D$. Let $N_k(i)$ be this set of indices (excluding $i$ itself). The symmetric union rule states an edge $\\{i,j\\}$ exists if $i \\in N_k(j)$ or $j \\in N_k(i)$. This can be implemented by iterating through all points $i$, finding their neighbors $N_k(i)$, and for each $j \\in N_k(i)$, setting both $W_{ij}$ and $W_{ji}$ to the distance $D_{ij}$. This procedure correctly forms the union.\n\n**3. Minimum Spanning Tree (MST) Calculation**\nWe use Kruskal's algorithm to find the MST of the graph represented by $W$.\n- First, we create a list of all unique edges $\\{i,j\\}$ with their weights $W_{ij} > 0$.\n- We sort this list of edges in non-decreasing order of weights.\n- We use a Disjoint Set Union (DSU) or Union-Find data structure, initialized with $n$ sets, one for each node.\n- We iterate through the sorted edges. For each edge $(u,v)$ with weight $w$, if the leaders of the sets containing $u$ and $v$ (found via `find(u)` and `find(v)`) are different, we add the edge to our MST and merge the two sets using `union(u,v)`.\n- We stop once we have accumulated $n-1$ edges, which completes the spanning tree. The resulting MST is stored as an adjacency list for efficient traversal.\n\n**4. Degree and Betweenness Centrality Calculation**\n- **Degree**: The degree $\\deg_T(v)$ of a node $v$ in the MST is simply the number of edges connected to it, which is the length of its entry in the adjacency list. The maximum degree $m$ is found by taking the maximum over all nodes.\n- **Betweenness Centrality**: For a tree, the centrality $C_B(v)$ of a node $v$ is the number of pairs of other nodes $(s,t)$ for which the unique simple path from $s$ to $t$ passes through $v$. This can be computed efficiently. Removing node $v$ splits the MST into $\\deg_T(v)$ components (subtrees). Let the sizes of these components be $s_1, s_2, \\dots, s_{\\deg_T(v)}$. Any path from a node in component $i$ to a node in component $j$ (where $i \\ne j$) must pass through $v$. The number of such paths is the sum of products of the component sizes taken pairwise:\n$$ C_B(v) = \\sum_{1 \\le i < j \\le \\deg_T(v)} s_i s_j $$\nTo implement this, we first root the tree arbitrarily (e.g., at node $0$). We perform a graph traversal (e.g., Breadth-First Search or Depth-First Search) to determine the parent-child relationships and then a post-order traversal to compute the size of the subtree rooted at each node. With the subtree sizes, the component sizes for any removed node $v$ can be determined, allowing for the calculation of $C_B(v)$.\n\n**5. Branchpoint Identification and Topology Classification**\n- We compute the arithmetic mean $\\overline{C_B}$ of all centrality values.\n- We identify the set of branchpoints $B$ by selecting all nodes $v$ that satisfy both $\\deg_T(v) \\ge 3$ and $C_B(v) \\ge \\overline{C_B}$. We count the number of branchpoints, $b = |B|$, and create a sorted list of their indices, $I$.\n- Finally, we apply the classification rules provided:\n    - If the maximum degree $m \\le 2$, the topology is linear ($c=0$).\n    - If there is exactly one branchpoint ($b = 1$) and the maximum degree is exactly $3$ ($m = 3$), the topology is a single bifurcation ($c=1$).\n    - In all other cases (e.g., multiple branchpoints, or branchpoints with degree greater than $3$), the topology is classified as complex ($c=2$).\n\nThis entire procedure is encapsulated in a function that is called for each test case, and the results are aggregated and printed in the specified format.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport sys\n\n# Increase recursion limit for deep DFS traversals, a good practice for graph algorithms.\nsys.setrecursionlimit(2000)\n\nclass DSU:\n    \"\"\"Disjoint Set Union (Union-Find) data structure for Kruskal's algorithm.\"\"\"\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.num_sets = n\n\n    def find(self, i):\n        if self.parent[i] == i:\n            return i\n        self.parent[i] = self.find(self.parent[i])\n        return self.parent[i]\n\n    def union(self, i, j):\n        root_i = self.find(i)\n        root_j = self.find(j)\n        if root_i != root_j:\n            self.parent[root_j] = root_i\n            self.num_sets -= 1\n            return True\n        return False\n\ndef process_case(X, k):\n    \"\"\"\n    Processes a single point cloud to determine its lineage topology.\n    \"\"\"\n    n = X.shape[0]\n\n    # 1. Compute pairwise Euclidean distance matrix\n    # Using broadcasting for efficiency.\n    diff = X[:, np.newaxis, :] - X[np.newaxis, :, :]\n    dist_matrix = np.linalg.norm(diff, axis=-1)\n\n    # 2. Construct symmetric union k-NN graph\n    adj_matrix = np.zeros((n, n))\n    for i in range(n):\n        # np.argsort is stable, which aids reproducibility in case of distance ties.\n        # We take indices [1:k+1] to exclude the point itself (distance 0).\n        neighbors = np.argsort(dist_matrix[i, :])[1:k + 1]\n        for j in neighbors:\n            # Symmetric union: add edge if i is neighbor of j or j is neighbor of i.\n            # This implementation correctly builds the union.\n            adj_matrix[i, j] = dist_matrix[i, j]\n            adj_matrix[j, i] = dist_matrix[j, i]\n\n    # 3. Compute Minimum Spanning Tree (MST) using Kruskal's algorithm\n    edges = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            if adj_matrix[i, j] > 0:\n                edges.append((adj_matrix[i, j], i, j))\n    \n    edges.sort()\n\n    dsu = DSU(n)\n    mst_adj = {i: [] for i in range(n)}\n    mst_edges_count = 0\n    for weight, u, v in edges:\n        if dsu.union(u, v):\n            mst_adj[u].append(v)\n            mst_adj[v].append(u)\n            mst_edges_count += 1\n            if mst_edges_count == n - 1:\n                break\n    \n    # 4. Compute MST node degrees\n    degrees = np.array([len(mst_adj[i]) for i in range(n)])\n\n    # 5. Compute betweenness centrality for each node in the MST\n    centrality = np.zeros(n)\n    \n    # Handle the case of an empty or single-node graph\n    if n <= 1:\n        return [0, 0 if n == 0 else degrees[0], 0, []]\n\n    # Root the tree arbitrarily at node 0 for traversal\n    root = 0\n    parent = {i: None for i in range(n)}\n    children = {i: [] for i in range(n)}\n    \n    # Build parent/child relationships using BFS\n    q = [root]\n    visited = {root}\n    head = 0\n    while head < len(q):\n        u = q[head]\n        head += 1\n        for v in mst_adj[u]:\n            if v not in visited:\n                visited.add(v)\n                parent[v] = u\n                children[u].append(v)\n                q.append(v)\n\n    # Compute subtree sizes using a post-order traversal\n    subtree_size = {}\n    nodes_post_order = []\n    visited_post = set()\n    \n    def build_post_order(u):\n        visited_post.add(u)\n        for v_child in children[u]:\n            if v_child not in visited_post:\n                build_post_order(v_child)\n        nodes_post_order.append(u)\n    \n    if root not in visited_post:\n      build_post_order(root)\n\n    for u in nodes_post_order:\n        size = 1 + sum(subtree_size[v_child] for v_child in children[u])\n        subtree_size[u] = size\n\n    # Compute centrality based on component sizes\n    for v in range(n):\n        if degrees[v] <= 1:\n            centrality[v] = 0\n            continue\n        \n        component_sizes = []\n        for child in children[v]:\n            component_sizes.append(subtree_size[child])\n        if parent[v] is not None:\n            component_sizes.append(n - subtree_size[v])\n        \n        # Centrality is the sum of products of component sizes taken pairwise\n        cb_v = 0\n        total_sum = sum(component_sizes)\n        sum_of_squares = sum(s**2 for s in component_sizes)\n        cb_v = (total_sum**2 - sum_of_squares) / 2\n        centrality[v] = cb_v\n        \n    # 6. Identify branchpoints\n    mean_centrality = np.mean(centrality)\n    branchpoint_indices = []\n    for v in range(n):\n        if degrees[v] >= 3 and centrality[v] >= mean_centrality:\n            branchpoint_indices.append(v)\n    \n    b = len(branchpoint_indices)\n    I = sorted(branchpoint_indices)\n    \n    # 7. Classify topology\n    m = int(np.max(degrees)) if n > 0 else 0\n    \n    c = 0\n    if m <= 2:\n        c = 0\n    elif b == 1 and m == 3:\n        c = 1\n    else:\n        c = 2\n        \n    return [b, m, c, I]\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, run the analysis, and print results.\n    \"\"\"\n    test_cases = [\n        (\n            2, # k\n            np.array([\n                [0,-2], [0,-1], [0,0], [1,1], [2,2], [3,3], [-1,1], [-2,2], [-3,3]\n            ])\n        ),\n        (\n            2, # k\n            np.array([\n                [0,0], [1,0], [2,0], [3,0], [4,0]\n            ])\n        ),\n        (\n            2, # k\n            np.array([\n                [0,0], [1,0], [2,0], [3,0], \n                [-0.5,0.866], [-1,1.732], [-1.5,2.598],\n                [-0.5,-0.866], [-1,-1.732], [-1.5,-2.598]\n            ])\n        ),\n    ]\n\n    results = []\n    for k, X in test_cases:\n        result = process_case(X, k)\n        results.append(result)\n\n    # Format the final output string precisely as required, with no spaces.\n    results_str = [str(r).replace(\" \", \"\") for r in results]\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```", "id": "3356218"}, {"introduction": "After identifying branchpoints in a trajectory, the next critical question is to determine the fate of cells approaching the bifurcation. This practice introduces a powerful probabilistic model to quantify lineage commitment for each cell. By treating cell-state transitions as a random walk on the neighborhood graph, you will calculate the probability that a cell will ultimately progress toward one terminal state over another [@problem_id:3356200]. This exercise demonstrates how to use the concept of absorption probabilities from Markov chain theory to assign a quantitative \"fate bias\" to cells, providing a dynamic understanding of lineage decisions.", "problem": "Consider a diffusion-like random walk on a cell-cell graph used for trajectory inference in single-cell state space. The graph contains $3$ non-terminal cells, labeled $X_{1}$, $X_{2}$, and $X_{3}$, and $2$ terminal (absorbing) states, labeled $A$ and $B$, which represent lineage endpoints. A random walker at a non-terminal cell transitions to its neighbors or to a terminal state in one step with the probabilities specified below; once a terminal state is reached, the walker remains there forever. In the context of trajectory inference and pseudotime reconstruction, the absorption probability of a non-terminal cell into $A$ (respectively $B$) is interpreted as this cell’s branch allocation probability toward terminal branch $A$ (respectively $B$).\n\nThe one-step transition probabilities from each non-terminal cell are as follows:\n- From $X_{1}$: to $X_{2}$ with probability $\\frac{1}{2}$, to $X_{3}$ with probability $\\frac{1}{4}$, to $A$ with probability $\\frac{1}{4}$, and to $B$ with probability $0$.\n- From $X_{2}$: to $X_{1}$ with probability $\\frac{1}{3}$, to $X_{3}$ with probability $\\frac{1}{3}$, to $A$ with probability $0$, and to $B$ with probability $\\frac{1}{3}$.\n- From $X_{3}$: to $X_{2}$ with probability $\\frac{1}{2}$, to $A$ with probability $\\frac{1}{4}$, to $B$ with probability $\\frac{1}{4}$, and to $X_{1}$ with probability $0$.\n\nAssume that terminal states $A$ and $B$ are absorbing: from $A$ to $A$ with probability $1$ (and to all others with probability $0$), and from $B$ to $B$ with probability $1$ (and to all others with probability $0$). Using only the Markov property and the law of total probability as fundamental bases, derive and compute the exact absorption probabilities into $A$ and into $B$ for each non-terminal cell $X_{1}$, $X_{2}$, and $X_{3}$.\n\nAnswer specification:\n- Express your final answer as a single row matrix listing the six branch allocation probabilities in the order $(X_{1}\\!\\to\\!A)$, $(X_{1}\\!\\to\\!B)$, $(X_{2}\\!\\to\\!A)$, $(X_{2}\\!\\to\\!B)$, $(X_{3}\\!\\to\\!A)$, $(X_{3}\\!\\to\\!B)$.\n- Provide exact rational numbers in simplest fractional form. Do not round.\n- No units are required.", "solution": "The problem asks for the absorption probabilities of a random walk on a finite graph into two absorbing states, $A$ and $B$. This is a classic problem concerning discrete-time Markov chains. The states are {$X_1, X_2, X_3, A, B$}. The states $X_1, X_2, X_3$ are transient, while $A$ and $B$ are absorbing. The absorption probability for a cell (e.g., $X_i$) into a terminal state (e.g., $A$) is the probability that a random walker starting at $X_i$ will eventually reach state $A$.\n\nLet $p_{iA}$ be the absorption probability into state $A$ for a random walk starting at cell $X_i$, for $i \\in \\{1, 2, 3\\}$. Similarly, let $p_{iB}$ be the absorption probability into state $B$ starting from $X_i$. We need to compute the six values: $p_{1A}$, $p_{1B}$, $p_{2A}$, $p_{2B}$, $p_{3A}$, and $p_{3B}$.\n\nThe core principle for solving this is first-step analysis, which utilizes the law of total probability and the Markov property. The probability of being absorbed into a specific terminal state from a starting cell $X_i$ is the sum of the probabilities of being absorbed, conditioned on the first step taken from $X_i$.\n\nLet's first calculate the absorption probabilities for terminal state $A$. For any transient state $X_i$, the absorption probability $p_{iA}$ can be expressed as:\n$$p_{iA} = \\sum_{j \\in \\{X_1, X_2, X_3, A, B\\}} P(\\text{next state is } j | \\text{start state is } X_i) \\times P(\\text{absorption in A } | \\text{start state is } j)$$\nThe probabilities $P(\\text{absorption in A } | \\text{start state is } j)$ are simply $p_{1A}$, $p_{2A}$, and $p_{3A}$ if $j$ is one of the transient states. If the walk starts at an absorbing state, the probabilities are defined by the nature of absorption:\n$P(\\text{absorption in A } | \\text{start state is } A) = 1$\n$P(\\text{absorption in A } | \\text{start state is } B) = 0$\n\nUsing the given one-step transition probabilities, we can set up a system of linear equations for $p_{1A}$, $p_{2A}$, and $p_{3A}$.\n\nFor starting state $X_1$:\n$$p_{1A} = P(X_2|X_1)p_{2A} + P(X_3|X_1)p_{3A} + P(A|X_1) \\cdot 1 + P(B|X_1) \\cdot 0$$\n$$p_{1A} = \\frac{1}{2}p_{2A} + \\frac{1}{4}p_{3A} + \\frac{1}{4} \\quad (1)$$\n\nFor starting state $X_2$:\n$$p_{2A} = P(X_1|X_2)p_{1A} + P(X_3|X_2)p_{3A} + P(A|X_2) \\cdot 1 + P(B|X_2) \\cdot 0$$\n$$p_{2A} = \\frac{1}{3}p_{1A} + \\frac{1}{3}p_{3A} + 0$$\n$$p_{2A} = \\frac{1}{3}(p_{1A} + p_{3A}) \\quad (2)$$\n\nFor starting state $X_3$:\n$$p_{3A} = P(X_1|X_3)p_{1A} + P(X_2|X_3)p_{2A} + P(A|X_3) \\cdot 1 + P(B|X_3) \\cdot 0$$\n$$p_{3A} = 0 \\cdot p_{1A} + \\frac{1}{2}p_{2A} + \\frac{1}{4}$$\n$$p_{3A} = \\frac{1}{2}p_{2A} + \\frac{1}{4} \\quad (3)$$\n\nWe now have a system of three linear equations with three unknowns ($p_{1A}, p_{2A}, p_{3A}$). We can solve this system.\nFrom equation $(3)$, we can express $p_{2A}$ in terms of $p_{3A}$:\n$$\\frac{1}{2}p_{2A} = p_{3A} - \\frac{1}{4} \\implies p_{2A} = 2p_{3A} - \\frac{1}{2}$$\n\nNext, we substitute this expression for $p_{2A}$ into equation $(2)$:\n$$2p_{3A} - \\frac{1}{2} = \\frac{1}{3}(p_{1A} + p_{3A})$$\n$$6p_{3A} - \\frac{3}{2} = p_{1A} + p_{3A}$$\n$$p_{1A} = 5p_{3A} - \\frac{3}{2}$$\n\nNow we have expressions for both $p_{1A}$ and $p_{2A}$ in terms of $p_{3A}$. We substitute these into equation $(1)$:\n$$p_{1A} = \\frac{1}{2}p_{2A} + \\frac{1}{4}p_{3A} + \\frac{1}{4}$$\n$$5p_{3A} - \\frac{3}{2} = \\frac{1}{2}\\left(2p_{3A} - \\frac{1}{2}\\right) + \\frac{1}{4}p_{3A} + \\frac{1}{4}$$\n$$5p_{3A} - \\frac{3}{2} = p_{3A} - \\frac{1}{4} + \\frac{1}{4}p_{3A} + \\frac{1}{4}$$\n$$5p_{3A} - \\frac{3}{2} = p_{3A} + \\frac{1}{4}p_{3A}$$\n$$5p_{3A} - \\frac{3}{2} = \\frac{5}{4}p_{3A}$$\n$$5p_{3A} - \\frac{5}{4}p_{3A} = \\frac{3}{2}$$\n$$\\frac{20p_{3A} - 5p_{3A}}{4} = \\frac{3}{2}$$\n$$\\frac{15}{4}p_{3A} = \\frac{3}{2}$$\n$$p_{3A} = \\frac{3}{2} \\cdot \\frac{4}{15} = \\frac{12}{30} = \\frac{2}{5}$$\n\nNow we can back-substitute to find $p_{2A}$ and $p_{1A}$:\n$$p_{2A} = 2p_{3A} - \\frac{1}{2} = 2\\left(\\frac{2}{5}\\right) - \\frac{1}{2} = \\frac{4}{5} - \\frac{1}{2} = \\frac{8-5}{10} = \\frac{3}{10}$$\n$$p_{1A} = 5p_{3A} - \\frac{3}{2} = 5\\left(\\frac{2}{5}\\right) - \\frac{3}{2} = 2 - \\frac{3}{2} = \\frac{1}{2}$$\n\nSo, the absorption probabilities into state $A$ are:\n$p_{1A} = \\frac{1}{2}$\n$p_{2A} = \\frac{3}{10}$\n$p_{3A} = \\frac{2}{5}$\n\nSince $A$ and $B$ are the only absorbing states in the system, any random walk starting from a transient state must eventually be absorbed into either $A$ or $B$. Therefore, for each starting state $X_i$, the sum of the absorption probabilities into $A$ and $B$ must be $1$.\n$$p_{iA} + p_{iB} = 1$$\nThis allows us to easily compute the absorption probabilities into state $B$:\n$$p_{1B} = 1 - p_{1A} = 1 - \\frac{1}{2} = \\frac{1}{2}$$\n$$p_{2B} = 1 - p_{2A} = 1 - \\frac{3}{10} = \\frac{7}{10}$$\n$$p_{3B} = 1 - p_{3A} = 1 - \\frac{2}{5} = \\frac{3}{5}$$\n\nThe six required branch allocation probabilities are:\n$P(X_1 \\to A) = p_{1A} = \\frac{1}{2}$\n$P(X_1 \\to B) = p_{1B} = \\frac{1}{2}$\n$P(X_2 \\to A) = p_{2A} = \\frac{3}{10}$\n$P(X_2 \\to B) = p_{2B} = \\frac{7}{10}$\n$P(X_3 \\to A) = p_{3A} = \\frac{2}{5}$\n$P(X_3 \\to B) = p_{3B} = \\frac{3}{5}$", "answer": "$$\n\\boxed{\\begin{pmatrix} \\frac{1}{2} & \\frac{1}{2} & \\frac{3}{10} & \\frac{7}{10} & \\frac{2}{5} & \\frac{3}{5} \\end{pmatrix}}\n$$", "id": "3356200"}]}