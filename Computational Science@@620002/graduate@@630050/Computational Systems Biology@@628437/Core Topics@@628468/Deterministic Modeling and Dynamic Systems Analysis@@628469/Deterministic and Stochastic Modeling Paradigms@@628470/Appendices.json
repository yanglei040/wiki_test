{"hands_on_practices": [{"introduction": "This first exercise establishes a crucial baseline relationship between deterministic and stochastic modeling paradigms. By analyzing a simple birth-death process, you will analytically solve both the deterministic rate equation and the equations for the mean and variance of the corresponding stochastic model. This practice demonstrates how the deterministic view correctly captures the average behavior while the stochastic framework provides a richer, more complete description that includes the intrinsic noise inherent in the system [@problem_id:3300946].", "problem": "Consider a well-mixed, isothermal reaction system in a fixed volume where species $A$ is synthesized and removed via interaction with a chemostatted species $B$. The network consists of the following reactions:\n\n1. Zeroth-order synthesis: $\\varnothing \\rightarrow A$ with rate constant $k_0$ having units $\\mathrm{mol}\\,\\mathrm{L}^{-1}\\,\\mathrm{s}^{-1}$.\n2. $B$-catalyzed removal: $A + B \\rightarrow B$ with mass-action rate constant $k_1$ having units $\\mathrm{L}\\,\\mathrm{mol}^{-1}\\,\\mathrm{s}^{-1}$.\n3. First-order degradation: $A \\rightarrow \\varnothing$ with rate constant $k_2$ having units $\\mathrm{s}^{-1}$.\n\nAssume that $[B](t)$ is maintained constant by a chemostat at $[B](t) = [B](0)$ for all time, and focus on the special case $k_2 = 0$. Using the law of mass action and standard deterministic chemical kinetics, derive the ordinary differential equation for the concentration trajectory $[A](t)$ and solve it analytically for $k_2 = 0$ under the assumption that $[B](t)$ is constant. Then, for the stochastic description based on the Chemical Master Equation (CME), model the molecule count of $A$ as a continuous-time birth-death process in a volume $V$ (in $\\mathrm{L}$), with births at propensity $\\lambda = k_0 V N_\\mathrm{A}$ and deaths at propensity $\\mu n$ where $\\mu = k_1 [B](0)$, $n$ is the molecule count of $A$, and $N_\\mathrm{A} = 6.02214076 \\times 10^{23}\\,\\mathrm{mol}^{-1}$ is Avogadro's constant. Derive the mean $E[n(t)]$ and the variance $\\mathrm{Var}[n(t)]$ for this process in terms of $\\lambda$, $\\mu$, and the initial molecule count $n(0)$, assuming the initial molecule count is known exactly (initial variance zero).\n\nYour program must implement the analytic deterministic solution for $[A](t)$, along with the CME mean $E[n(t)]$ and variance $\\mathrm{Var}[n(t)]$ at a specified evaluation time $T$. For numerical evaluation, use the following scientifically plausible test suite with fixed physical units. In all cases, concentrations must be expressed in $\\mathrm{mol}\\,\\mathrm{L}^{-1}$, time in $\\mathrm{s}$, and molecule counts are dimensionless integers in principle, though expectations and variances may be non-integer real numbers.\n\nTest suite (each case provides $(V, k_0, k_1, [B](0), [A](0), n(0), T)$):\n\nCase $1$ (general \"happy path\"):\n- $V = 1.0 \\times 10^{-15}\\,\\mathrm{L}$\n- $k_0 = 2.0 \\times 10^{-8}\\,\\mathrm{mol}\\,\\mathrm{L}^{-1}\\,\\mathrm{s}^{-1}$\n- $k_1 = 1.0 \\times 10^{6}\\,\\mathrm{L}\\,\\mathrm{mol}^{-1}\\,\\mathrm{s}^{-1}$\n- $[B](0) = 5.0 \\times 10^{-7}\\,\\mathrm{mol}\\,\\mathrm{L}^{-1}$\n- $[A](0) = 1.0 \\times 10^{-7}\\,\\mathrm{mol}\\,\\mathrm{L}^{-1}$\n- $n(0) = 60$ (a consistent, fixed integer initialization)\n- $T = 10.0\\,\\mathrm{s}$\n\nCase $2$ (boundary condition with $[B](0) = 0$, no removal):\n- $V = 1.0 \\times 10^{-15}\\,\\mathrm{L}$\n- $k_0 = 1.0 \\times 10^{-9}\\,\\mathrm{mol}\\,\\mathrm{L}^{-1}\\,\\mathrm{s}^{-1}$\n- $k_1 = 5.0 \\times 10^{5}\\,\\mathrm{L}\\,\\mathrm{mol}^{-1}\\,\\mathrm{s}^{-1}$\n- $[B](0) = 0.0\\,\\mathrm{mol}\\,\\mathrm{L}^{-1}$\n- $[A](0) = 0.0\\,\\mathrm{mol}\\,\\mathrm{L}^{-1}$\n- $n(0) = 0$\n- $T = 100.0\\,\\mathrm{s}$\n\nCase $3$ (fast relaxation with large $[B](0)$):\n- $V = 1.0 \\times 10^{-15}\\,\\mathrm{L}$\n- $k_0 = 5.0 \\times 10^{-9}\\,\\mathrm{mol}\\,\\mathrm{L}^{-1}\\,\\mathrm{s}^{-1}$\n- $k_1 = 2.0 \\times 10^{7}\\,\\mathrm{L}\\,\\mathrm{mol}^{-1}\\,\\mathrm{s}^{-1}$\n- $[B](0) = 1.0 \\times 10^{-6}\\,\\mathrm{mol}\\,\\mathrm{L}^{-1}$\n- $[A](0) = 3.0 \\times 10^{-7}\\,\\mathrm{mol}\\,\\mathrm{L}^{-1}$\n- $n(0) = 181$\n- $T = 0.1\\,\\mathrm{s}$\n\nRequired outputs for each test case $i$ at time $T$:\n- Deterministic concentration $[A](T)$ in $\\mathrm{mol}\\,\\mathrm{L}^{-1}$, rounded to six decimal places.\n- Stochastic mean molecule count $E[n(T)]$, rounded to six decimal places.\n- Stochastic variance $\\mathrm{Var}[n(T)]$, rounded to six decimal places.\n\nFinal output format:\nYour program should produce a single line of output containing the aggregated results for the three test cases, in order, as a comma-separated list enclosed in square brackets, where the $i$-th case contributes three consecutive floating-point numbers in the order specified above. For example, the output must have the form\n$[a_1,m_1,v_1,a_2,m_2,v_2,a_3,m_3,v_3]$,\nwhere $a_i$ is $[A](T)$ in $\\mathrm{mol}\\,\\mathrm{L}^{-1}$, $m_i$ is $E[n(T)]$, and $v_i$ is $\\mathrm{Var}[n(T)]$, all rounded to six decimal places.", "solution": "The user wants me to solve a problem in computational systems biology.\n\nHere's my plan:\n1.  **I must first validate the problem statement.** I'll follow the strict protocol outlined.\n    *   **Step 1: Extract Givens.** I will list all the given reactions, parameters, definitions, and test cases verbatim.\n    *   **Step 2: Validate.** I will check the problem for scientific soundness, well-posedness, objectivity, and all other criteria.\n        *   The reactions are standard chemical kinetics: zeroth-order synthesis, second-order reaction (effectively first-order since [B] is constant), and first-order degradation. This is scientifically grounded.\n        *   The problem asks for derivations of ODEs and moment equations for a birth-death process. This is a standard task in both deterministic and stochastic modeling.\n        *   The provided parameters and units seem consistent. I should double-check the units.\n            *   $k_0$: $\\mathrm{mol}\\,\\mathrm{L}^{-1}\\,\\mathrm{s}^{-1}$. Rate of change of concentration. Good.\n            *   $k_1$: $\\mathrm{L}\\,\\mathrm{mol}^{-1}\\,\\mathrm{s}^{-1}$. Rate constant for $A+B \\rightarrow B$. Rate law is $k_1[A][B]$, units are $(\\mathrm{L}\\,\\mathrm{mol}^{-1}\\,\\mathrm{s}^{-1}) (\\mathrm{mol}\\,\\mathrm{L}^{-1}) (\\mathrm{mol}\\,\\mathrm{L}^{-1}) = \\mathrm{mol}\\,\\mathrm{L}^{-1}\\,\\mathrm{s}^{-1}$. Good.\n            *   $k_2$: $\\mathrm{s}^{-1}$. Rate constant for $A \\rightarrow \\varnothing$. Rate law is $k_2[A]$, units are $(\\mathrm{s}^{-1}) (\\mathrm{mol}\\,\\mathrm{L}^{-1}) = \\mathrm{mol}\\,\\mathrm{L}^{-1}\\,\\mathrm{s}^{-1}$. Good.\n        *   The problem defines the stochastic model's propensities:\n            *   Birth propensity $\\lambda = k_0 V N_\\mathrm{A}$. Let's check units. $k_0$ is $\\mathrm{mol}\\,\\mathrm{L}^{-1}\\,\\mathrm{s}^{-1}$. $V$ is $\\mathrm{L}$. $N_\\mathrm{A}$ is $\\mathrm{mol}^{-1}$. So $\\lambda$ has units $(\\mathrm{mol}\\,\\mathrm{L}^{-1}\\,\\mathrm{s}^{-1}) (\\mathrm{L}) (\\mathrm{mol}^{-1}) = \\mathrm{s}^{-1}$. This is the unit for a propensity of a zeroth-order reaction, representing events per unit time. This is correct.\n            *   Death propensity $\\mu n$. Where $\\mu = k_1 [B](0)$. Let's check units. $k_1$ is $\\mathrm{L}\\,\\mathrm{mol}^{-1}\\,\\mathrm{s}^{-1}$. $[B](0)$ is $\\mathrm{mol}\\,\\mathrm{L}^{-1}$. So $\\mu$ has units $(\\mathrm{L}\\,\\mathrm{mol}^{-1}\\,\\mathrm{s}^{-1}) (\\mathrm{mol}\\,\\mathrm{L}^{-1}) = \\mathrm{s}^{-1}$. This is the rate constant for a first-order process. The propensity is $\\mu n$, which is standard for a first-order reaction where $n$ is the number of molecules. This is also correct.\n        *   The problem states to focus on the special case $k_2=0$. This is a valid simplification.\n        *   The test cases provide all necessary parameters.\n            *   The initial conditions $[A](0)$ and $n(0)$ are provided for deterministic and stochastic models respectively. I should check if they are consistent. $n(0) = [A](0) \\times V \\times N_\\mathrm{A}$.\n                *   Case 1: $1.0 \\times 10^{-7}\\,\\mathrm{mol}\\,\\mathrm{L}^{-1} \\times 1.0 \\times 10^{-15}\\,\\mathrm{L} \\times 6.02214076 \\times 10^{23}\\,\\mathrm{mol}^{-1} = 60.2214...$. The problem gives $n(0) = 60$. This is a slight discrepancy but is explicitly stated as \"a consistent, fixed integer initialization\". This means we should use $n(0)=60$ for the stochastic part, not the value calculated from $[A](0)$. This is a deliberate choice in the problem statement to use an integer number of molecules, which is physically realistic. It does not make the problem invalid, it just specifies different initial conditions for the two models. This is common when comparing deterministic and stochastic simulations.\n                *   Case 2: $[A](0) = 0.0 \\implies n(0)$ should be $0$. The problem gives $n(0) = 0$. This is consistent.\n                *   Case 3: $3.0 \\times 10^{-7}\\,\\mathrm{mol}\\,\\mathrm{L}^{-1} \\times 1.0 \\times 10^{-15}\\,\\mathrm{L} \\times 6.02214076 \\times 10^{23}\\,\\mathrm{mol}^{-1} = 180.664...$. The problem gives $n(0) = 181$. Again, a deliberate integer initialization.\n        *   The problem's structure is clear. It asks for specific derivations and then numerical calculations. It is well-posed and objective.\n    *   **Step 3: Verdict and Action.** The problem seems entirely valid. It is a standard problem from chemical kinetics and stochastic processes, well-defined, and scientifically sound. I will proceed with the solution.\n\n2.  **Derive the deterministic solution.**\n    *   The reactions are:\n        1.  $\\varnothing \\stackrel{k_0}{\\longrightarrow} A$\n        2.  $A + B \\stackrel{k_1}{\\longrightarrow} B$\n        3.  $A \\stackrel{k_2}{\\longrightarrow} \\varnothing$\n    *   The rate law for the concentration of A, $[A]$, is given by the law of mass action:\n        $$ \\frac{d[A]}{dt} = (\\text{rate of production}) - (\\text{rate of consumption}) $$\n        $$ \\frac{d[A]}{dt} = k_0 - k_1[A][B] - k_2[A] $$\n    *   The problem states $[B](t) = [B](0)$ (constant) and we must consider the case $k_2=0$.\n    *   So, the ODE simplifies to:\n        $$ \\frac{d[A]}{dt} = k_0 - k_1[B](0)[A] $$\n    *   Let's define a constant $\\mu' = k_1[B](0)$. The units of $\\mu'$ are $(\\mathrm{L}\\,\\mathrm{mol}^{-1}\\,\\mathrm{s}^{-1})(\\mathrm{mol}\\,\\mathrm{L}^{-1}) = \\mathrm{s}^{-1}$.\n    *   The ODE is:\n        $$ \\frac{d[A]}{dt} = k_0 - \\mu' [A] $$\n    *   This is a first-order linear ordinary differential equation. We can solve it by separating variables.\n    *   Let's separate variables:\n        $$ \\frac{d[A]}{k_0 - \\mu' [A]} = dt $$\n    *   Integrate both sides from initial state $([A](0), 0)$ to $([A](t), t)$:\n        $$ \\int_{[A](0)}^{[A](t)} \\frac{d[A]'}{k_0 - \\mu' [A]'} = \\int_0^t dt' $$\n        Assuming $\\mu' \\neq 0$:\n        $$ \\left[ -\\frac{1}{\\mu'} \\ln|k_0 - \\mu' [A]'| \\right]_{[A](0)}^{[A](t)} = t $$\n        $$ \\ln\\left(\\frac{k_0 - \\mu' [A](t)}{k_0 - \\mu' [A](0)}\\right) = -\\mu' t $$\n        $$ k_0 - \\mu' [A](t) = (k_0 - \\mu' [A](0)) e^{-\\mu' t} $$\n        $$ \\mu' [A](t) = k_0 - (k_0 - \\mu' [A](0)) e^{-\\mu' t} $$\n        $$ [A](t) = \\frac{k_0}{\\mu'} - \\left(\\frac{k_0}{\\mu'} - [A](0)\\right) e^{-\\mu' t} $$\n    *   The steady-state concentration is $[A]_{ss} = k_0 / \\mu'$. The solution can be written as:\n        $$ [A](t) = [A]_{ss} + ([A](0) - [A]_{ss}) e^{-\\mu' t} $$\n        where $\\mu' = k_1 [B](0)$.\n    *   Special case: If $\\mu' = 0$ (which occurs when $[B](0) = 0$), the ODE becomes:\n        $$ \\frac{d[A]}{dt} = k_0 $$\n    *   Integrating with the initial condition $[A](0)$ gives:\n        $$ [A](t) = [A](0) + k_0 t $$\n\n3.  **Derive the stochastic mean and variance.**\n    *   The system is modeled as a linear birth-death process for the molecule count $n$ of species $A$.\n    *   Birth reaction: $\\varnothing \\rightarrow A$. Propensity is constant: $a_1 = \\lambda = k_0 V N_\\mathrm{A}$.\n    *   Death reaction: $A \\rightarrow \\varnothing$. Propensity is linear in $n$: $a_2(n) = \\mu n$, where $\\mu = k_1 [B](0)$. Note the consistency $\\mu'=\\mu$.\n    *   The time evolution of the mean $\\langle n(t) \\rangle = E[n(t)]$ is governed by the ODE:\n        $$ \\frac{d\\langle n \\rangle}{dt} = \\sum_{j} \\langle a_j(n) v_j \\rangle = \\langle \\lambda \\cdot (+1) \\rangle + \\langle \\mu n \\cdot (-1) \\rangle = \\lambda - \\mu \\langle n \\rangle $$\n    *   This is a linear first-order ODE for $\\langle n \\rangle$. Assuming $\\mu \\neq 0$, the solution, with initial condition $n(0)$, is identical in form to the deterministic case:\n        $$ \\langle n(t) \\rangle = \\frac{\\lambda}{\\mu} + \\left(n(0) - \\frac{\\lambda}{\\mu}\\right)e^{-\\mu t} $$\n    *   If $\\mu = 0$, the ODE is $\\frac{d\\langle n \\rangle}{dt} = \\lambda$. The solution is:\n        $$ \\langle n(t) \\rangle = n(0) + \\lambda t $$\n    *   To find the variance $\\mathrm{Var}[n(t)] = V(t) = \\langle n^2 \\rangle - \\langle n \\rangle^2$, we first derive the ODE for the second moment, $\\langle n^2 \\rangle$:\n        $$ \\frac{d\\langle n^2 \\rangle}{dt} = \\sum_{j} \\langle a_j(n) ((n+v_j)^2 - n^2) \\rangle $$\n        $$ \\frac{d\\langle n^2 \\rangle}{dt} = \\langle \\lambda((n+1)^2 - n^2) \\rangle + \\langle \\mu n((n-1)^2 - n^2) \\rangle $$\n        $$ \\frac{d\\langle n^2 \\rangle}{dt} = \\langle \\lambda(2n+1) \\rangle + \\langle \\mu n(-2n+1) \\rangle $$\n        $$ \\frac{d\\langle n^2 \\rangle}{dt} = \\lambda(2\\langle n \\rangle+1) + \\mu(-2\\langle n^2 \\rangle+\\langle n \\rangle) = -2\\mu\\langle n^2 \\rangle + (2\\lambda+\\mu)\\langle n \\rangle + \\lambda $$\n    *   Now, we derive the ODE for the variance $V(t)$:\n        $$ \\frac{dV}{dt} = \\frac{d\\langle n^2 \\rangle}{dt} - \\frac{d\\langle n \\rangle^2}{dt} = \\frac{d\\langle n^2 \\rangle}{dt} - 2\\langle n \\rangle \\frac{d\\langle n \\rangle}{dt} $$\n        $$ \\frac{dV}{dt} = [-2\\mu\\langle n^2 \\rangle + (2\\lambda+\\mu)\\langle n \\rangle + \\lambda] - 2\\langle n \\rangle(\\lambda - \\mu \\langle n \\rangle) $$\n        $$ \\frac{dV}{dt} = -2\\mu\\langle n^2 \\rangle + 2\\lambda\\langle n \\rangle + \\mu\\langle n \\rangle + \\lambda - 2\\lambda\\langle n \\rangle + 2\\mu\\langle n \\rangle^2 $$\n        $$ \\frac{dV}{dt} = -2\\mu(\\langle n^2 \\rangle - \\langle n \\rangle^2) + \\mu\\langle n \\rangle + \\lambda $$\n        $$ \\frac{dV}{dt} = -2\\mu V(t) + \\mu\\langle n(t) \\rangle + \\lambda $$\n    *   This is a linear first-order ODE for $V(t)$. We solve it using an integrating factor $e^{2\\mu t}$, with the initial condition $V(0)=0$ (since $n(0)$ is a known integer).\n        $$ V(t) = e^{-2\\mu t} \\int_0^t e^{2\\mu s} (\\mu\\langle n(s) \\rangle + \\lambda) ds $$\n    *   Substituting $\\langle n(s) \\rangle = \\frac{\\lambda}{\\mu} + (n(0) - \\frac{\\lambda}{\\mu})e^{-\\mu s}$:\n        $$ \\mu\\langle n(s) \\rangle + \\lambda = \\mu\\left(\\frac{\\lambda}{\\mu} + \\left(n(0) - \\frac{\\lambda}{\\mu}\\right)e^{-\\mu s}\\right) + \\lambda = 2\\lambda + \\mu\\left(n(0) - \\frac{\\lambda}{\\mu}\\right)e^{-\\mu s} $$\n    *   The integral becomes:\n        $$ \\int_0^t e^{2\\mu s} \\left( 2\\lambda + \\mu\\left(n(0) - \\frac{\\lambda}{\\mu}\\right)e^{-\\mu s} \\right) ds $$\n        $$ = \\int_0^t 2\\lambda e^{2\\mu s} ds + \\int_0^t \\mu\\left(n(0) - \\frac{\\lambda}{\\mu}\\right) e^{\\mu s} ds $$\n        $$ = 2\\lambda \\left[\\frac{e^{2\\mu s}}{2\\mu}\\right]_0^t + \\mu\\left(n(0) - \\frac{\\lambda}{\\mu}\\right) \\left[\\frac{e^{\\mu s}}{\\mu}\\right]_0^t $$\n        $$ = \\frac{\\lambda}{\\mu}(e^{2\\mu t} - 1) + \\left(n(0) - \\frac{\\lambda}{\\mu}\\right)(e^{\\mu t} - 1) $$\n    *   Multiplying by $e^{-2\\mu t}$:\n        $$ V(t) = \\frac{\\lambda}{\\mu}(1 - e^{-2\\mu t}) + \\left(n(0) - \\frac{\\lambda}{\\mu}\\right)(e^{-\\mu t} - e^{-2\\mu t}) $$\n    *   Special case: If $\\mu = 0$, the variance ODE becomes $\\frac{dV}{dt} = \\lambda$. With $V(0)=0$, the solution is:\n        $$ V(t) = \\lambda t $$\n\n4.  **Numerical Calculation Strategy**\n    For each test case, we extract the parameters $(V, k_0, k_1, [B](0), [A](0), n(0), T)$. We also use the constant $N_\\mathrm{A} = 6.02214076 \\times 10^{23}\\,\\mathrm{mol}^{-1}$.\n    First, calculate the composite parameters for the deterministic and stochastic models:\n    - Deterministic decay rate: $\\mu' = k_1 [B](0)$.\n    - Stochastic birth rate (propensity): $\\lambda = k_0 V N_\\mathrm{A}$.\n    - Stochastic death rate constant: $\\mu = k_1 [B](0)$.\n    We check if $\\mu = 0$.\n    If $\\mu > 0$:\n    - $[A](T) = (k_0/\\mu') + ([A](0) - k_0/\\mu') e^{-\\mu' T}$\n    - $E[n(T)] = (\\lambda/\\mu) + (n(0) - \\lambda/\\mu) e^{-\\mu T}$\n    - $\\mathrm{Var}[n(T)] = (\\lambda/\\mu)(1 - e^{-2\\mu T}) + (n(0) - \\lambda/\\mu)(e^{-\\mu T} - e^{-2\\mu T})$\n    If $\\mu = 0$:\n    - $[A](T) = [A](0) + k_0 T$\n    - $E[n(T)] = n(0) + \\lambda T$\n    - $\\mathrm{Var}[n(T)] = \\lambda T$\n\nThe results for each case are then calculated using these formulas and formatted to six decimal places.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the deterministic concentration, and stochastic mean and variance\n    for a chemical reaction system under three different test cases.\n    \"\"\"\n    \n    # Avogadro's constant\n    NA = 6.02214076e23  # mol^-1\n\n    # Test suite: (V, k0, k1, B0, A0, n0, T)\n    test_cases = [\n        # Case 1 (general \"happy path\")\n        {\n            \"V\": 1.0e-15,      # L\n            \"k0\": 2.0e-8,      # mol L^-1 s^-1\n            \"k1\": 1.0e6,       # L mol^-1 s^-1\n            \"B0\": 5.0e-7,      # mol L^-1\n            \"A0\": 1.0e-7,      # mol L^-1\n            \"n0\": 60,          # dimensionless\n            \"T\": 10.0          # s\n        },\n        # Case 2 (boundary condition with B0 = 0)\n        {\n            \"V\": 1.0e-15,\n            \"k0\": 1.0e-9,\n            \"k1\": 5.0e5,\n            \"B0\": 0.0,\n            \"A0\": 0.0,\n            \"n0\": 0,\n            \"T\": 100.0\n        },\n        # Case 3 (fast relaxation with large B0)\n        {\n            \"V\": 1.0e-15,\n            \"k0\": 5.0e-9,\n            \"k1\": 2.0e7,\n            \"B0\": 1.0e-6,\n            \"A0\": 3.0e-7,\n            \"n0\": 181,\n            \"T\": 0.1\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        V = case[\"V\"]\n        k0 = case[\"k0\"]\n        k1 = case[\"k1\"]\n        B0 = case[\"B0\"]\n        A0 = case[\"A0\"]\n        n0 = case[\"n0\"]\n        T = case[\"T\"]\n        \n        # Calculate composite parameters\n        mu = k1 * B0          # s^-1 (for both models)\n        lambd = k0 * V * NA   # s^-1 (stochastic birth rate)\n\n        # Initialize results for the current case\n        det_A_T = 0.0\n        stoch_mean_T = 0.0\n        stoch_var_T = 0.0\n\n        if mu > 0:\n            # Deterministic solution\n            A_ss = k0 / mu\n            det_A_T = A_ss + (A0 - A_ss) * np.exp(-mu * T)\n            \n            # Stochastic mean\n            n_ss = lambd / mu\n            stoch_mean_T = n_ss + (n0 - n_ss) * np.exp(-mu * T)\n            \n            # Stochastic variance\n            term1 = n_ss * (1 - np.exp(-2 * mu * T))\n            term2 = (n0 - n_ss) * (np.exp(-mu * T) - np.exp(-2 * mu * T))\n            stoch_var_T = term1 + term2\n        else: # mu == 0 case\n            # Deterministic solution\n            det_A_T = A0 + k0 * T\n            \n            # Stochastic mean\n            stoch_mean_T = n0 + lambd * T\n            \n            # Stochastic variance\n            stoch_var_T = lambd * T\n            \n        results.extend([det_A_T, stoch_mean_T, stoch_var_T])\n\n    # Format output to six decimal places as required\n    formatted_results = [f'{val:.6f}' for val in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3300946"}, {"introduction": "While the first practice focused on the first two moments (mean and variance), this exercise goes deeper by solving for the entire steady-state probability distribution using the Chemical Master Equation (CME). You will employ the principle of detailed balance for a canonical birth-death process, a powerful analytical technique for certain classes of problems. This approach reveals that the system settles into a well-known Poisson distribution, reinforcing the connection between the stochastic mean and the deterministic steady state for these fundamental linear systems [@problem_id:3300898].", "problem": "Consider a well-mixed single-cell system in which the copy number $n(t) \\in \\{0,1,2,\\dots\\}$ of a gene product evolves as a continuous-time Markov jump process with the following elementary reactions: production (birth) adds one molecule at a constant rate $k_b > 0$, and degradation (death) removes one molecule at a rate proportional to the current copy number with rate constant $k_d > 0$. This corresponds to the reaction scheme $\\varnothing \\xrightarrow{k_b} X$ and $X \\xrightarrow{k_d} \\varnothing$, with mass-action degradation. Let $P(n,t)$ denote the probability that the system has $n$ molecules at time $t$.\n\nStarting from the Kolmogorov forward equation (also called the Chemical Master Equation (CME)) for $P(n,t)$ implied by these reactions, derive the stationary probability mass function $P(n)$ for $n \\in \\mathbb{N}_0$ under the assumption that a stationary distribution exists and the chain is positive recurrent. Express the stationary distribution in closed form and identify it in terms of a well-known discrete distribution, together with its mean. Then, using the deterministic counterpart $dn/dt = k_b - k_d n$ for the expected copy number in the limit of large system size, discuss the consistency of the deterministic steady state with the mean of the stationary stochastic distribution.\n\nYour final answer must be the closed-form expression for the stationary $P(n)$ as a function of $n$, $k_b$, and $k_d$. No rounding is required, and no units are required since $P(n)$ is dimensionless.", "solution": "The problem statement has been validated and is deemed sound, well-posed, and scientifically grounded. It presents a canonical birth-death process, a fundamental model in stochastic chemical kinetics. We may proceed with the solution.\n\nThe system is described by two elementary reactions:\n1. Production: $\\varnothing \\xrightarrow{k_b} X$, with a constant propensity $a_1(n) = k_b$. This reaction increases the molecule count $n$ by $1$.\n2. Degradation: $X \\xrightarrow{k_d} \\varnothing$, with a mass-action propensity $a_2(n) = k_d n$. This reaction decreases the molecule count $n$ by $1$. The parameters $k_b$ and $k_d$ are positive real constants.\n\nThe state of the system is the integer copy number $n \\in \\{0, 1, 2, \\dots\\}$. Let $P(n,t)$ be the probability of being in state $n$ at time $t$. The time evolution of $P(n,t)$ is governed by the Kolmogorov forward equation, also known as the Chemical Master Equation (CME). The rate of change of $P(n,t)$ is given by the balance of probability fluxes into and out of state $n$:\n$$\n\\frac{dP(n,t)}{dt} = (\\text{flux in}) - (\\text{flux out})\n$$\nFor a general state $n \\ge 1$, the flux into state $n$ comes from production from state $n-1$ (at rate $k_b$) and degradation from state $n+1$ (at rate $k_d(n+1)$). The flux out of state $n$ goes to state $n+1$ via production (at rate $k_b$) and to state $n-1$ via degradation (at rate $k_d n$). Thus, for $n \\ge 1$:\n$$\n\\frac{dP(n,t)}{dt} = k_b P(n-1,t) + k_d(n+1)P(n+1,t) - (k_b + k_d n)P(n,t)\n$$\nFor the boundary case $n=0$, the state $n-1$ is not possible. Flux into state $0$ can only occur from state $1$ via degradation. Flux out of state $0$ can only occur to state $1$ via production. Therefore:\n$$\n\\frac{dP(0,t)}{dt} = k_d P(1,t) - k_b P(0,t)\n$$\nThe problem asks for the stationary probability mass function, $P(n)$, which is the limit of $P(n,t)$ as $t \\to \\infty$. At steady state, $\\frac{dP(n,t)}{dt} = 0$ for all $n$. Let $P(n)$ denote the stationary probability $P(n, \\infty)$. The system of equations becomes:\nFor $n \\ge 1$:\n$$\n0 = k_b P(n-1) + k_d(n+1)P(n+1) - (k_b + k_d n)P(n) \\quad (*_1)\n$$\nFor $n=0$:\n$$\n0 = k_d P(1) - k_b P(0) \\quad (*_2)\n$$\nThis is a birth-death process, for which the steady-state condition implies that the net probability flux between any two adjacent states must be zero. This condition is known as detailed balance. The flux from state $n$ to $n+1$ is due to production ($k_b P(n)$), and the flux from state $n+1$ to $n$ is due to degradation ($k_d(n+1)P(n+1)$). The detailed balance condition is:\n$$\nk_b P(n) = k_d(n+1)P(n+1) \\quad \\text{for } n \\ge 0\n$$\nThis single recurrence relation is equivalent to the infinite set of linear equations $(*_1)$ and $(*_2)$. For example, for $n=0$, it gives $k_b P(0) = k_d P(1)$, which is exactly equation $(*_2)$. Substituting $k_d(n+1)P(n+1) = k_b P(n)$ and, by shifting the index, $k_d n P(n) = k_b P(n-1)$ into equation $(*_1)$, we get $0 = k_d n P(n) + k_b P(n) - (k_b + k_d n)P(n) = 0$, confirming its validity.\n\nWe can solve this recurrence relation for $P(n)$ in terms of $P(0)$:\n$$\nP(n+1) = \\frac{k_b}{k_d(n+1)} P(n)\n$$\nLet's iterate to find the general form:\nFor $n=0$: $P(1) = \\frac{k_b}{k_d(1)}P(0)$\nFor $n=1$: $P(2) = \\frac{k_b}{k_d(2)}P(1) = \\frac{k_b}{k_d(2)}\\frac{k_b}{k_d(1)}P(0) = \\frac{1}{2 \\cdot 1}\\left(\\frac{k_b}{k_d}\\right)^2 P(0)$\nFor $n=2$: $P(3) = \\frac{k_b}{k_d(3)}P(2) = \\frac{k_b}{k_d(3)} \\frac{1}{2}\\left(\\frac{k_b}{k_d}\\right)^2 P(0) = \\frac{1}{3 \\cdot 2 \\cdot 1}\\left(\\frac{k_b}{k_d}\\right)^3 P(0)$\nBy induction, the general expression for $P(n)$ is:\n$$\nP(n) = \\frac{1}{n!} \\left(\\frac{k_b}{k_d}\\right)^n P(0)\n$$\nTo find $P(0)$, we use the normalization condition that the sum of all probabilities must be unity:\n$$\n\\sum_{n=0}^{\\infty} P(n) = 1\n$$\nSubstituting our expression for $P(n)$:\n$$\n\\sum_{n=0}^{\\infty} \\frac{1}{n!} \\left(\\frac{k_b}{k_d}\\right)^n P(0) = 1\n$$\n$$\nP(0) \\sum_{n=0}^{\\infty} \\frac{1}{n!} \\left(\\frac{k_b}{k_d}\\right)^n = 1\n$$\nThe sum is the Taylor series expansion for the exponential function, $\\sum_{k=0}^{\\infty} \\frac{x^k}{k!} = \\exp(x)$. With $x = k_b/k_d$, we have:\n$$\nP(0) \\exp\\left(\\frac{k_b}{k_d}\\right) = 1\n$$\nThis gives $P(0) = \\exp\\left(-\\frac{k_b}{k_d}\\right)$.\nSubstituting this back into the expression for $P(n)$, we obtain the final closed-form expression for the stationary probability mass function:\n$$\nP(n) = \\frac{1}{n!} \\left(\\frac{k_b}{k_d}\\right)^n \\exp\\left(-\\frac{k_b}{k_d}\\right)\n$$\nThis is the probability mass function of a Poisson distribution with parameter $\\lambda = \\frac{k_b}{k_d}$. The mean of a Poisson-distributed random variable with parameter $\\lambda$ is $\\lambda$. Therefore, the mean copy number at steady state is:\n$$\n\\langle n \\rangle = \\frac{k_b}{k_d}\n$$\nNext, we analyze the deterministic counterpart. The deterministic rate equation for the copy number $n$ is given as:\n$$\n\\frac{dn}{dt} = k_b - k_d n\n$$\nThe deterministic steady state, $n_{ss}$, is found by setting the time derivative to zero:\n$$\n0 = k_b - k_d n_{ss}\n$$\nSolving for $n_{ss}$ yields:\n$$\nn_{ss} = \\frac{k_b}{k_d}\n$$\nUpon comparison, we find that the mean of the stationary stochastic distribution, $\\langle n \\rangle$, is exactly equal to the steady state of the deterministic rate equation, $n_{ss}$. This perfect correspondence is a specific feature of systems with only zero-order and first-order reactions (i.e., linear propensities). The deterministic model, which can be viewed as an approximation that neglects fluctuations, correctly predicts the average behavior of the full stochastic system in this case. For systems involving higher-order reactions (non-linear propensities), this identity generally does not hold, and the mean of the stochastic model will deviate from the prediction of the deterministic model.", "answer": "$$\n\\boxed{\\frac{1}{n!} \\left( \\frac{k_b}{k_d} \\right)^{n} \\exp\\left(-\\frac{k_b}{k_d}\\right)}\n$$", "id": "3300898"}, {"introduction": "Deterministic and stochastic models diverge most dramatically in nonlinear systems, where noise can create entirely new behaviors. This final practice explores a classic genetic toggle switch, a system exhibiting bistability where the deterministic model predicts two distinct, stable states. You will see how stochastic fluctuations can induce spontaneous switching between these states—a phenomenon invisible to the deterministic framework—and implement an advanced computational method, Forward Flux Sampling (FFS), to calculate the rate of these rare but biologically crucial events [@problem_id:3300870].", "problem": "Consider a mutual-repression toggle-switch gene network modeled at the level of proteins, with two species $X$ and $Y$ whose copy numbers in the system state are given by $(x,y)\\in\\mathbb{N}_0^2$. Production of $X$ is repressed by $Y$, and production of $Y$ is repressed by $X$. The stochastic dynamics are governed by the Chemical Master Equation (CME), which models a continuous-time Markov chain on the lattice of nonnegative integer pairs with reactions and propensities specified as follows. The reactions are: (1) production of $X$ with stoichiometric change $(+1,0)$, (2) degradation of $X$ with stoichiometric change $(-1,0)$, (3) production of $Y$ with stoichiometric change $(0,+1)$, and (4) degradation of $Y$ with stoichiometric change $(0,-1)$. The corresponding propensity functions are $a_1(x,y)=\\alpha_X/(1+(y/K)^n)$, $a_2(x,y)=\\delta_X x$, $a_3(x,y)=\\alpha_Y/(1+(x/K)^n)$, and $a_4(x,y)=\\delta_Y y$, where $\\alpha_X$ and $\\alpha_Y$ are maximal production rates (in $\\text{molecules}\\cdot\\text{min}^{-1}$), $K$ is a repression threshold (in $\\text{molecules}$), $n$ is a Hill coefficient, and $\\delta_X$ and $\\delta_Y$ are first-order degradation rates (in $\\text{min}^{-1}$). The CME infinitesimal generator $\\mathcal{L}$ acts on functions $f:\\mathbb{N}_0^2\\to\\mathbb{R}$ by\n$$\n(\\mathcal{L}f)(x,y)=\\sum_{j=1}^4 a_j(x,y)\\left[f\\big((x,y)+\\nu_j\\big)-f(x,y)\\right],\n$$\nwhere $\\nu_1=(1,0)$, $\\nu_2=(-1,0)$, $\\nu_3=(0,1)$, and $\\nu_4=(0,-1)$.\n\nIn the deterministic limit (mean-field), the expected concentrations satisfy ordinary differential equations $dx/dt=\\alpha_X/(1+(y/K)^n)-\\delta_X x$ and $dy/dt=\\alpha_Y/(1+(x/K)^n)-\\delta_Y y$. For suitable parameter values, the system exhibits bistability with two basins of attraction corresponding to high $Y$ and low $X$ (denote this basin $A$) and high $X$ and low $Y$ (denote this basin $B$). Stochasticity induces rare switching events from $A$ to $B$.\n\nYour task is to set up the CME state representation per the above and implement a rare-event simulation strategy to estimate the switching rate $k_{A\\to B}$ (in $\\text{min}^{-1}$) from basin $A$ to basin $B$, using Forward Flux Sampling (FFS). Use the scalar order parameter $\\phi(x,y)=x-y$, and define the following regions and interfaces in the state space: basin $A$ as $\\{\\phi\\le \\phi_A\\}$, basin $B$ as $\\{\\phi\\ge \\phi_B\\}$, and intermediate interfaces $\\lambda_0<\\lambda_1<\\cdots<\\lambda_{m-1}$ with $\\phi_A<\\lambda_0$ and $\\lambda_{m-1}<\\phi_B$.\n\nForward Flux Sampling estimates the rate $k_{A\\to B}$ by the product\n$$\nk_{A\\to B}=\\Phi_A \\times \\prod_{k=0}^{m-1} P(\\lambda_{k+1}\\mid \\lambda_k),\n$$\nwhere $\\Phi_A$ is the flux of trajectories crossing $\\lambda_0$ while originating in $A$, and $P(\\lambda_{k+1}\\mid\\lambda_k)$ is the conditional probability of reaching interface $\\lambda_{k+1}$ before returning to $A$, given that the trajectory is at $\\lambda_k$. In implementation terms:\n- Estimate $\\Phi_A$ by simulating the stochastic dynamics with the Stochastic Simulation Algorithm (SSA; also known as the Gillespie algorithm), starting from an initial state deep in $A$, accumulating the total time spent in $A$ and counting crossings of $\\lambda_0$ that occur directly from $A$. Compute $\\Phi_A$ as the number of such crossings divided by the total time spent in $A$.\n- For each stage $k$, starting from a set of saved crossing states at $\\lambda_k$, launch a fixed number of trial SSA trajectories terminating upon either returning to $A$ or reaching the next interface (or $B$ at the final stage). Estimate $P(\\lambda_{k+1}\\mid\\lambda_k)$ as the fraction of trials that succeed. For $k<m-1$, collect successful crossing states at $\\lambda_{k+1}$ to seed the next stage.\n\nYou must implement the CME-based SSA exactly as outlined, using the above propensity functions and reaction stoichiometries. All time must be measured in $\\text{minutes}$, and all rates must be reported in $\\text{min}^{-1}$ as real-valued floats. Angles are not involved. No percentages appear.\n\nTest suite. Run your program on the following three parameter sets to produce $k_{A\\to B}$ estimates:\n- Case $1$ (symmetric, moderate bistability): $\\alpha_X=\\alpha_Y=20$, $\\delta_X=\\delta_Y=1$, $K=10$, $n=2$, $\\phi_A=-14$, interfaces $\\lambda=\\{-12,-8,-4,0,4,8\\}$, $\\phi_B=12$, initial state $(x_0,y_0)=(0,20)$, flux sampling time budget in $A$ equal to $T_A=250$ minutes, maximum stored crossings at $\\lambda_0$ equal to $N_0=20$, and trials per stage equal to $M=10$.\n- Case $2$ (asymmetric production favoring $X$): $\\alpha_X=22$, $\\alpha_Y=18$, $\\delta_X=\\delta_Y=1$, $K=10$, $n=2$, $\\phi_A=-14$, interfaces $\\lambda=\\{-12,-8,-4,0,4,8\\}$, $\\phi_B=12$, initial state $(x_0,y_0)=(0,18)$, $T_A=250$ minutes, $N_0=20$, $M=10$.\n- Case $3$ (higher copy-number, reduced noise): $\\alpha_X=\\alpha_Y=26$, $\\delta_X=\\delta_Y=1$, $K=10$, $n=2$, $\\phi_A=-14$, interfaces $\\lambda=\\{-12,-8,-4,0,4,8\\}$, $\\phi_B=12$, initial state $(x_0,y_0)=(0,26)$, $T_A=300$ minutes, $N_0=20$, $M=10$.\n\nFor each case, estimate $k_{A\\to B}$ using Forward Flux Sampling as described. Your program should produce a single line of output containing the three estimated rates, in $\\text{min}^{-1}$, as a comma-separated list enclosed in square brackets, in the order of the test suite cases, for example $[r_1,r_2,r_3]$. Use a fixed pseudorandom seed so the output is reproducible.", "solution": "The problem requires the estimation of the rare-event switching rate, $k_{A\\to B}$, for a stochastic model of a genetic toggle switch. The estimation is to be performed using the Forward Flux Sampling (FFS) algorithm. The solution is presented by first detailing the mathematical model and the simulation principles, followed by an algorithmic description of the FFS implementation.\n\n**1. System Model and Dynamics**\n\nThe system consists of two mutually repressing protein species, $X$ and $Y$. The state of the system is given by the integer-valued copy numbers of these proteins, $(x,y) \\in \\mathbb{N}_0^2$. The stochastic evolution of the system is modeled as a continuous-time Markov chain, governed by the Chemical Master Equation (CME). The dynamics are defined by four fundamental reactions: production and degradation for each species.\n\nThe reactions and their corresponding state transition vectors $\\nu_j$ are:\n1. Production of $X$: $\\nu_1 = (+1, 0)$\n2. Degradation of $X$: $\\nu_2 = (-1, 0)$\n3. Production of $Y$: $\\nu_3 = (0, +1)$\n4. Degradation of $Y$: $\\nu_4 = (0, -1)$\n\nThe rate of each reaction is determined by its propensity function, $a_j(x,y)$:\n1. $a_1(x,y) = \\frac{\\alpha_X}{1 + (y/K)^n}$ (Production of $X$, repressed by $Y$)\n2. $a_2(x,y) = \\delta_X x$ (First-order degradation of $X$)\n3. $a_3(x,y) = \\frac{\\alpha_Y}{1 + (x/K)^n}$ (Production of $Y$, repressed by $X$)\n4. $a_4(x,y) = \\delta_Y y$ (First-order degradation of $Y$)\n\nHere, $\\alpha_X$ and $\\alpha_Y$ are the maximal production rates, $\\delta_X$ and $\\delta_Y$ are the degradation rate constants, $K$ is the repression threshold, and $n$ is the Hill coefficient controlling the steepness of the repression.\n\n**2. Stochastic Simulation Algorithm (SSA)**\n\nTo generate dynamically exact trajectories of this stochastic system, we employ the Gillespie Stochastic Simulation Algorithm (SSA). The SSA is a Monte Carlo procedure that simulates every reaction event. For a system in state $(x,y)$ at time $t$, a single SSA step involves:\n1. Calculating all propensity functions $a_j(x,y)$ for $j \\in \\{1,2,3,4\\}$.\n2. Computing the total propensity, $a_{\\text{tot}}(x,y) = \\sum_{j=1}^4 a_j(x,y)$.\n3. Generating the time until the next reaction, $\\Delta t$, by drawing from an exponential distribution with rate $a_{\\text{tot}}$: $\\Delta t = \\frac{1}{a_{\\text{tot}}} \\ln(\\frac{1}{r_1})$, where $r_1$ is a random number uniformly distributed in $(0,1]$.\n4. Determining which reaction occurs. The $j$-th reaction is chosen with probability $a_j/a_{\\text{tot}}$. This is achieved by drawing a second uniform random number $r_2 \\in (0,1]$ and finding the smallest integer $j$ that satisfies $\\sum_{k=1}^j a_k(x,y) \\ge r_2 a_{\\text{tot}}(x,y)$.\n5. Updating the system state and time: $(x,y) \\to (x,y) + \\nu_j$ and $t \\to t + \\Delta t$.\n\n**3. Forward Flux Sampling (FFS) for Rare Event Rate Estimation**\n\nThe transition from the high-$Y$/low-$X$ basin ($A$) to the high-$X$/low-$Y$ basin ($B$) is a rare event. FFS is an efficient method to estimate the rate $k_{A \\to B}$ by breaking the transition into a sequence of more probable sub-events. This is achieved by defining a series of non-intersecting interfaces in state space between basins $A$ and $B$.\n\nAn order parameter, $\\phi(x,y) = x-y$, is used to distinguish the basins and define the interfaces. Basin $A$ is defined as the set of states where $\\phi \\le \\phi_A$, and basin $B$ where $\\phi \\ge \\phi_B$. A set of $m$ interfaces, $\\lambda_0, \\lambda_1, \\ldots, \\lambda_{m-1}$, are placed between the basins such that $\\phi_A < \\lambda_0 < \\lambda_1 < \\cdots < \\lambda_{m-1} < \\phi_B$.\n\nThe FFS algorithm estimates the rate $k_{A\\to B}$ as the product of the flux of trajectories leaving basin $A$ and crossing the first interface $\\lambda_0$, and a series of conditional probabilities of reaching the next interface:\n$$\nk_{A\\to B} = \\Phi_A \\times P(\\lambda_1 \\mid \\lambda_0) \\times P(\\lambda_2 \\mid \\lambda_1) \\times \\cdots \\times P(\\phi_B \\mid \\lambda_{m-1}) = \\Phi_A \\prod_{k=0}^{m-1} P(\\lambda_{k+1} \\mid \\lambda_k)\n$$\nwhere $\\lambda_m$ is taken to be the boundary of basin $B$, $\\phi_B$.\n\nThe implementation proceeds in two main stages:\n\n**Stage 1: Flux Estimation $(\\Phi_A)$**\nAn SSA simulation is initiated in a state deep within basin $A$. The simulation is run for a long duration, during which the total time the system spends in basin $A$, denoted $T_A^{sim}$, is accumulated. We count the number of times, $N_c$, that the trajectory crosses from a state with $\\phi \\le \\phi_A$ to a state with $\\phi > \\lambda_0$. The flux is then estimated as $\\Phi_A = N_c / T_A^{sim}$. During this stage, a collection of $N_0$ unique states just after crossing $\\lambda_0$ are saved to initialize the next stage of the algorithm.\n\n**Stage 2: Conditional Probability Estimation $(P(\\lambda_{k+1} \\mid \\lambda_k))$**\nThis stage is iterative. For each interface $\\lambda_k$ (for $k=0, \\ldots, m-1$):\n1. A set of $M$ trial trajectories is launched. The starting states for these trials are chosen by sampling (with replacement) from the collection of configurations saved at interface $\\lambda_k$.\n2. Each SSA trial is simulated until it terminates by either returning to basin $A$ (a state with $\\phi \\le \\phi_A$, counted as a failure) or reaching the next interface $\\lambda_{k+1}$ (a state with $\\phi \\ge \\lambda_{k+1}$, counted as a success).\n3. The conditional probability $P(\\lambda_{k+1} \\mid \\lambda_k)$ is estimated as the fraction of successful trials: $N_{\\text{success}} / M$.\n4. The states of the successful trajectories upon crossing $\\lambda_{k+1}$ are collected. This new collection of states is used as the starting pool for the trials at the next interface, $\\lambda_{k+1}$.\n\nIf at any stage there are no configurations to start from (because no trials in the previous stage were successful), the chain is broken, and the overall rate $k_{A\\to B}$ is zero. Finally, the total rate is computed by multiplying the flux $\\Phi_A$ and all the estimated conditional probabilities. The provided code implements this logic for each of the three test cases.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements the Forward Flux Sampling algorithm to estimate the switching rate \n    for a stochastic toggle-switch model for three specified test cases.\n    \"\"\"\n\n    # Set a fixed seed for reproducibility as required by the problem.\n    np.random.seed(42)\n\n    def calculate_propensities(state, params):\n        \"\"\"Calculates the propensities for the four reactions.\"\"\"\n        x, y = state\n        alpha_X, alpha_Y, delta_X, delta_Y, K, n = params['alpha_X'], params['alpha_Y'], params['delta_X'], params['delta_Y'], params['K'], params['n']\n        \n        a1 = alpha_X / (1 + (y / K)**n)  # Production of X\n        a2 = delta_X * x                 # Degradation of X\n        a3 = alpha_Y / (1 + (x / K)**n)  # Production of Y\n        a4 = delta_Y * y                 # Degradation of Y\n        \n        return np.array([a1, a2, a3, a4])\n\n    def ssa_step(state, params):\n        \"\"\"Performs a single step of the Gillespie SSA.\"\"\"\n        propensities = calculate_propensities(state, params)\n        total_propensity = np.sum(propensities)\n        \n        if total_propensity == 0:\n            return state, np.inf\n        \n        # Time to next reaction\n        dt = np.random.exponential(1.0 / total_propensity)\n        \n        # Choose which reaction occurs\n        r = np.random.uniform(0, 1) * total_propensity\n        \n        stoichiometry = np.array([[1, 0], [-1, 0], [0, 1], [0, -1]])\n        \n        if r  propensities[0]:\n            reaction_idx = 0\n        elif r  propensities[0] + propensities[1]:\n            reaction_idx = 1\n        elif r  propensities[0] + propensities[1] + propensities[2]:\n            reaction_idx = 2\n        else:\n            reaction_idx = 3\n            \n        new_state = tuple(np.add(state, stoichiometry[reaction_idx]))\n        \n        return new_state, dt\n\n    def order_parameter(state):\n        \"\"\"Calculates the order parameter phi(x,y) = x - y.\"\"\"\n        return state[0] - state[1]\n\n    def run_ffs_case(case_params):\n        \"\"\"Runs the full Forward Flux Sampling simulation for a single case.\"\"\"\n        \n        # --- Phase 0: Flux Estimation (Phi_A) ---\n        time_in_A = 0.0\n        crossings_of_lambda0 = 0\n        saved_crossings = []\n        \n        state = case_params['initial_state']\n        \n        # Unpack FFS parameters\n        interfaces = case_params['interfaces']\n        phi_A = case_params['phi_A']\n        phi_B = case_params['phi_B']\n        lambda_0 = interfaces[0]\n        T_A_budget = case_params['T_A']\n        N_0_max = case_params['N_0']\n\n        # Flux sampling phase\n        while time_in_A  T_A_budget:\n            phi_before = order_parameter(state)\n            \n            new_state, dt = ssa_step(state, case_params)\n            \n            if phi_before = phi_A:\n                time_in_A += dt\n                phi_after = order_parameter(new_state)\n                # Check for crossing from A to outside lambda_0\n                if phi_after > lambda_0:\n                    crossings_of_lambda0 += 1\n                    if len(saved_crossings)  N_0_max:\n                        saved_crossings.append(new_state)\n            \n            state = new_state\n\n        if time_in_A == 0:\n            flux_A = 0.0\n        else:\n            flux_A = crossings_of_lambda0 / time_in_A\n        \n        if flux_A == 0.0 or not saved_crossings:\n            return 0.0\n            \n        # --- Interface Sampling Phases ---\n        cond_probs = []\n        current_configs = saved_crossings\n        \n        full_interface_list = interfaces + [phi_B]\n        \n        for k in range(len(interfaces)):\n            if not current_configs:\n                # If no configurations reached the previous interface, the chain is broken.\n                cond_probs.append(0.0)\n                continue\n                \n            lambda_k_plus_1 = full_interface_list[k+1]\n            \n            num_trials = case_params['M']\n            successes = 0\n            next_configs = []\n            \n            # Sample starting configurations for the trials, with replacement\n            start_indices = np.random.randint(0, len(current_configs), size=num_trials)\n            \n            for idx in start_indices:\n                trial_state = current_configs[idx]\n                \n                # Run trial SSA from the starting configuration\n                while True:\n                    phi = order_parameter(trial_state)\n                    \n                    # Check for termination conditions\n                    if phi = phi_A: # Returned to basin A (failure)\n                        break \n                    if phi >= lambda_k_plus_1: # Reached next interface (success)\n                        successes += 1\n                        next_configs.append(trial_state)\n                        break\n                    \n                    trial_state, _ = ssa_step(trial_state, case_params)\n            \n            prob_k = successes / num_trials if num_trials > 0 else 0.0\n            cond_probs.append(prob_k)\n            \n            current_configs = next_configs\n\n        # --- Final Rate Calculation ---\n        total_prob_product = np.prod(cond_probs)\n        k_A_to_B = flux_A * total_prob_product\n        \n        return k_A_to_B\n\n    test_cases = [\n        # Case 1 (symmetric, moderate bistability)\n        {\n            'alpha_X': 20, 'alpha_Y': 20, 'delta_X': 1, 'delta_Y': 1, 'K': 10, 'n': 2,\n            'phi_A': -14, 'interfaces': [-12, -8, -4, 0, 4, 8], 'phi_B': 12,\n            'initial_state': (0, 20), 'T_A': 250, 'N_0': 20, 'M': 10\n        },\n        # Case 2 (asymmetric production favoring X)\n        {\n            'alpha_X': 22, 'alpha_Y': 18, 'delta_X': 1, 'delta_Y': 1, 'K': 10, 'n': 2,\n            'phi_A': -14, 'interfaces': [-12, -8, -4, 0, 4, 8], 'phi_B': 12,\n            'initial_state': (0, 18), 'T_A': 250, 'N_0': 20, 'M': 10\n        },\n        # Case 3 (higher copy-number, reduced noise)\n        {\n            'alpha_X': 26, 'alpha_Y': 26, 'delta_X': 1, 'delta_Y': 1, 'K': 10, 'n': 2,\n            'phi_A': -14, 'interfaces': [-12, -8, -4, 0, 4, 8], 'phi_B': 12,\n            'initial_state': (0, 26), 'T_A': 300, 'N_0': 20, 'M': 10\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        rate = run_ffs_case(case)\n        results.append(rate)\n\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\n# Execute the solver\nsolve()\n\n```", "id": "3300870"}]}