{"hands_on_practices": [{"introduction": "The FASTQ format is the cornerstone for storing raw next-generation sequencing data, bundling nucleotide sequences with their corresponding quality scores. This exercise ([@problem_id:3291731]) provides direct practice in decoding the vital information embedded in a FASTQ quality string. By converting ASCII characters to Phred scores and then to error probabilities, you will gain a tangible understanding of how sequencing accuracy is quantified, a foundational skill for filtering data and performing downstream analyses like variant calling.", "problem": "You are given a single-read record in the FASTQ format (Sanger encoding). In the Sanger standard, American Standard Code for Information Interchange (ASCII) characters on the quality line are mapped to integer Phred quality scores (Phred) by subtracting an offset of $33$, that is, for a quality character $c$ with ASCII code $\\mathrm{ord}(c)$, the quality score is $Q(c) = \\mathrm{ord}(c) - 33$. The Phred quality score $Q$ is defined by the relationship $Q = -10 \\log_{10}(p)$, where $p$ is the probability that the corresponding base call is incorrect.\n\nConsider the following logically defined FASTQ record (the nucleotide sequence content is irrelevant to the computation but has length $100$):\n\n@read0001\nACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGTACGT\n+\nThe quality line is the concatenation of $25$ occurrences of the character ‘I’, followed by $25$ occurrences of the character ‘5’, followed by $20$ occurrences of the character ‘@’, followed by $20$ occurrences of the character ‘C’, followed by $10$ occurrences of the character ‘+’.\n\nUsing only the definitions above as the foundational starting point:\n- Compute the mean Phred quality score $\\bar{Q}$ across the read of length $100$.\n- Compute the expected error rate for the read, defined as the arithmetic mean of the per-base error probabilities implied by the Phred scores.\n\nReport the expected error rate as your final answer, expressed as a unitless decimal, rounded to five significant figures. Do not report any intermediate values as part of your final answer.", "solution": "The problem asks for the expected error rate of a sequencing read, which is the arithmetic mean of the per-base error probabilities. We must first convert the ASCII quality characters into Phred scores and then convert those scores into probabilities.\n\n**Step 1: Convert ASCII Characters to Phred Scores**\n\nThe problem provides the Sanger encoding formula: $Q(c) = \\mathrm{ord}(c) - 33$, where $\\mathrm{ord}(c)$ is the ASCII value of character $c$. We apply this to each unique character in the quality string.\n\n*   For character ‘I’: $\\mathrm{ord}('I') = 73$. The Phred score is $Q_I = 73 - 33 = 40$.\n*   For character ‘5’: $\\mathrm{ord}('5') = 53$. The Phred score is $Q_5 = 53 - 33 = 20$.\n*   For character ‘@’: $\\mathrm{ord}('@') = 64$. The Phred score is $Q_@ = 64 - 33 = 31$.\n*   For character ‘C’: $\\mathrm{ord}('C') = 67$. The Phred score is $Q_C = 67 - 33 = 34$.\n*   For character ‘+’: $\\mathrm{ord}('+') = 43$. The Phred score is $Q_+ = 43 - 33 = 10$.\n\n**Step 2: Compute the Mean Phred Score $\\bar{Q}$**\n\nWhile not the final answer, computing the mean Phred score is a requested intermediate step. The quality string has $100$ bases in total.\nThe sum of all Phred scores is:\n$$ \\sum Q = (25 \\times 40) + (25 \\times 20) + (20 \\times 31) + (20 \\times 34) + (10 \\times 10) $$\n$$ \\sum Q = 1000 + 500 + 620 + 680 + 100 = 2900 $$\nThe mean Phred score is:\n$$ \\bar{Q} = \\frac{\\sum Q}{100} = \\frac{2900}{100} = 29 $$\n\n**Step 3: Convert Phred Scores to Error Probabilities**\n\nThe relationship between Phred score $Q$ and error probability $p$ is $Q = -10 \\log_{10}(p)$. We solve for $p$:\n$$ p = 10^{-Q/10} $$\nNow we calculate the probability for each score:\n*   $p_I = 10^{-40/10} = 10^{-4} = 0.0001$\n*   $p_5 = 10^{-20/10} = 10^{-2} = 0.01$\n*   $p_@ = 10^{-31/10} = 10^{-3.1}$\n*   $p_C = 10^{-34/10} = 10^{-3.4}$\n*   $p_+ = 10^{-10/10} = 10^{-1} = 0.1$\n\n**Step 4: Compute the Expected Error Rate**\n\nThe expected error rate is the arithmetic mean of the per-base error probabilities, $\\bar{p}$.\n$$ \\bar{p} = \\frac{1}{100} \\sum_{i=1}^{100} p_i $$\nWe can compute this using the counts of each probability:\n$$ \\bar{p} = \\frac{1}{100} \\left( (25 \\times p_I) + (25 \\times p_5) + (20 \\times p_@) + (20 \\times p_C) + (10 \\times p_+) \\right) $$\n$$ \\bar{p} = \\frac{1}{100} \\left( (25 \\times 10^{-4}) + (25 \\times 10^{-2}) + (20 \\times 10^{-3.1}) + (20 \\times 10^{-3.4}) + (10 \\times 10^{-1}) \\right) $$\nLet's evaluate the terms:\n$$ \\text{Sum of probabilities} = (25 \\times 0.0001) + (25 \\times 0.01) + (20 \\times 0.000794328...) + (20 \\times 0.000398107...) + (10 \\times 0.1) $$\n$$ \\text{Sum of probabilities} = 0.0025 + 0.25 + 0.01588656... + 0.00796214... + 1.0 = 1.2763487... $$\nNow we calculate the mean:\n$$ \\bar{p} = \\frac{1.2763487...}{100} = 0.012763487... $$\n\n**Step 5: Round to Five Significant Figures**\n\nThe problem requires the result to be rounded to five significant figures. The value is $0.012763487...$. The first five significant figures are $1, 2, 7, 6, 3$. The next digit is $4$, so we round down.\n$$ \\bar{p} \\approx 0.012763 $$", "answer": "$$ \\boxed{0.012763} $$", "id": "3291731"}, {"introduction": "Genomic annotations provide the map for interpreting a genome, but their complexity requires computational methods to parse and utilize them effectively. This practice ([@problem_id:3291684]) challenges you to work with the Generic Feature Format version 3 (GFF3), a standard for representing gene models. By implementing an algorithm that reconstructs transcript structures from exon features, you will learn to programmatically navigate hierarchical data, respect strand-specific biological rules, and validate the integrity of annotation files.", "problem": "You are given a description and constraints based on the Generic Feature Format version 3 (GFF3) data standard, used extensively in computational systems biology to represent genomic features and their relationships. The goal is to reconstruct transcript exon chains from GFF3-compliant feature records and to detect invalid Parent relationships according to the specification.\n\nFundamental base: Use the canonical rules of the GFF3 specification. The Generic Feature Format version 3 (GFF3) is a tab-delimited format with nine fields per feature line: sequence identifier, source, type, start, end, score, strand, phase, and attributes. The attributes field contains key-value pairs such as identifiers and relationships. The following facts are used as foundational rules:\n- Coordinates are $1$-based and inclusive. A feature has start coordinate $s$ and end coordinate $e$ where $s \\le e$.\n- Parent-child relationships are expressed via attributes with keys $ID$ and $Parent$. A child lists its parent(s) via the $Parent$ tag; multiple parents are separated by commas.\n- Features of type gene, messenger RNA (mRNA), and exon must conform to the following parentage constraints: an mRNA’s $Parent$ must reference a gene, and an exon’s $Parent$ must reference an mRNA. A gene should not have a $Parent$ tag.\n- Transcript exon chain order depends on strand: on the positive strand $+$, order by ascending genomic coordinate; on the negative strand $-$, order by descending genomic coordinate. A tie in start should be broken by end.\n\nTask: For each provided GFF3 snippet, reconstruct the exon chains for each mRNA and detect whether there exists any invalid $Parent$ reference, where invalid means either:\n- a $Parent$ identifier does not exist among the defined feature $ID$s, or\n- a $Parent$ exists but is of the wrong type (for example, an exon referencing a gene), or\n- a gene line has a $Parent$ attribute at all.\n\nAlgorithmic requirement:\n- Parse features and build a mapping from $ID$ to type and strand for mRNA.\n- For each exon, associate it to each $Parent$ mRNA if the parent exists and is of type mRNA.\n- For each mRNA, sort its associated exons to form its exon chain. Sorting is by $(s,e)$ ascending for $+$, and by $(s,e)$ descending for $-$, with ties broken by $e$.\n- Detect invalid $Parent$ references using the rules above.\n- The computational complexity should be justified from principles, relying on dictionary lookups and sorting.\n\nInput model: Your program must internally embed the test suite as strings; no external input is allowed. Each GFF3 snippet comprises valid tab-delimited records using the nine fields and attributes containing $ID$ and $Parent$ tags.\n\nTest suite:\n- Case $1$ (positive strand, single transcript, ordered exons): gene $g1$, mRNA $t1$ ($Parent=g1$), exons at coordinates $[100,200]$ and $[300,400]$, both with $Parent=t1$ and strand $+$.\n- Case $2$ (negative strand, single transcript, out-of-order exons): gene $g2$, mRNA $t2$ ($Parent=g2$), exons at $[450,480]$ and $[500,600]$, both with $Parent=t2$ and strand $-$; output exon chain must be ordered by descending start, yielding exon starts $500$ before $450$.\n- Case $3$ (invalid parent reference): gene $g3$, mRNA $t3$ ($Parent=g3$); exons at $[200,250]$ with $Parent=t3$ and at $[260,300]$ with $Parent=mr\\_unknown$ (nonexistent). Invalid $Parent$ detection must be true; the exon chain for $t3$ must include only its valid exon.\n- Case $4$ (multiple parents with one invalid): gene $g4$, mRNA $t4$ ($Parent=g4$); exon at $[150,180]$ with $Parent=t4,t4b$ (where $t4b$ is missing) and another exon at $[800,900]$ with $Parent=t4$. Invalid $Parent$ detection must be true; $t4$’s chain must include both exons in ascending order on strand $+$.\n- Case $5$ (boundary conditions: tie-breaking in sorting and multiple transcripts): gene $g5$; mRNAs $t5$ and $t5b$ (both $Parent=g5$), all on strand $+$. For $t5$, exons at $[100,150]$, $[100,120]$, and $[160,170]$. For $t5b$, exons at $[210,220]$ and $[300,320]$. The $t5$ chain must sort $[100,120]$ before $[100,150]$ due to tie-breaking on end, then $[160,170]$. The $t5b$ chain must be $[210,220]$ followed by $[300,320]$.\n\nOutput format:\n- For each test case, output a list in the form $[B,N,C]$ where $B$ is a boolean indicating whether any invalid $Parent$ reference was detected, $N$ is an integer equal to the number of mRNAs reconstructed, and $C$ is a list of exon chains (one per mRNA sorted lexicographically by mRNA $ID$). Each exon chain must be a list of integers formed by concatenating the start and end coordinates as $[s_1,e_1,s_2,e_2,\\dots]$ in transcript order.\n- Your program should produce a single line of output containing the results for the five test cases as a comma-separated list enclosed in square brackets, for example: $[[\\dots],[\\dots],[\\dots],[\\dots],[\\dots]]$.\n\nAnswer types: All outputs must be booleans, integers, floats, or lists of these types. There must be no strings in the output beyond the enclosing brackets that are produced by standard list formatting.\n\nYour program must be a complete, runnable Python program that embeds the test suite internally and adheres to the specified output format. No external inputs or files are permitted.", "solution": "The problem requires the reconstruction of transcript exon chains and the validation of parent-child relationships according to the Generic Feature Format version 3 (GFF3) specification. The solution is implemented as a systematic, multi-pass algorithm that first parses and indexes all genomic features, then validates their relationships and reconstructs transcript models, and finally assembles and formats the output.\n\nThe core of the algorithm relies on efficient data structures, primarily dictionaries (hash maps), to store and retrieve feature information. This ensures that operations such as finding a feature by its identifier ($ID$) are performed in average-case constant time, which is crucial for performance.\n\nThe process for each GFF3 snippet is as follows:\n\n**Step 1: Parsing and Indexing**\n\nFirst, we process the raw GFF3 data. Each line, representing a single genomic feature, is parsed into its nine constituent fields. Of these, we are interested in the feature `type` (field $3$), `start` and `end` coordinates (fields $4$ and $5$), `strand` (field $7$), and `attributes` (field $9$).\n\nThe `attributes` field, a semicolon-separated list of `key=value` pairs, is parsed to extract the unique feature `ID` and any `Parent` identifiers. Since the `Parent` attribute can specify multiple parents in a comma-separated list, these are parsed into a list of strings.\n\nAll parsed features are stored in a primary dictionary, let's call it `feature_map`. This dictionary maps each feature's `ID` to an object containing its essential properties: `type`, `strand`, and a list of `Parent` IDs. Coordinates are temporarily stored with exon features for later use. This indexing is critical, as it allows for rapid lookups ($O(1)$ average time) when validating parent-child links. A separate list of all `mRNA` feature `ID`s is also maintained.\n\n**Step 2: Validation and Exon Association**\n\nThe second pass iterates through all parsed features to validate the parentage rules specified in the problem and to associate exons with their parent mRNAs. A boolean flag, `invalid_parent_detected`, is initialized to false and is set to true if any rule violation is found.\n\nThe validation rules are applied as follows:\n1.  **Gene with Parent**: If a feature of `type` 'gene' is found to have a `Parent` attribute, `invalid_parent_detected` is set to true.\n2.  **mRNA Parentage**: For each feature of `type` 'mRNA', we iterate through its `Parent` IDs. For each parent ID `p_id`:\n    - If `p_id` is not a key in `feature_map`, the parent does not exist. `invalid_parent_detected` is set to true.\n    - If `p_id` exists, we check if `feature_map[p_id].type` is 'gene'. If not, the parent is of the wrong type, and `invalid_parent_detected` is set to true.\n3.  **Exon Parentage**: For each feature of `type` 'exon', we iterate through its `Parent` IDs. For each parent ID `p_id`:\n    - If `p_id` is not in `feature_map`, `invalid_parent_detected` is set to true.\n    - If `p_id` exists, we check if `feature_map[p_id].type` is 'mRNA'. If it is not, `invalid_parent_detected` is set to true. If it is a valid 'mRNA' parent, the exon's coordinates $(s, e)$ are added to a list associated with that `p_id` in a separate dictionary, `mrna_to_exons`. This dictionary maps each mRNA `ID` to a list of its constituent exons.\n\n**Step 3: Exon Chain Assembly and Sorting**\n\nAfter validation, the `mrna_to_exons` dictionary contains all valid mRNA-to-exon associations. The final step is to construct the ordered exon chains for each mRNA.\n\nFirst, the mRNA `ID`s are sorted lexicographically to ensure a deterministic output order for the final list of chains. Then, for each mRNA:\n- The list of associated exons is retrieved.\n- The `strand` of the mRNA is looked up from the `feature_map`.\n- The sorting order of exons is determined by the `strand`:\n    - For a positive strand (`+`), exons are sorted by their `start` coordinate in ascending order. Ties in `start` are broken by the `end` coordinate, also in ascending order. This corresponds to sorting pairs $(s, e)$ lexicographically.\n    - For a negative strand (`-`), exons are sorted by their `start` coordinate in descending order. Ties are broken by the `end` coordinate, also in descending order. This is equivalent to reverse lexicographical sorting of pairs $(s, e)$.\n- The sorted list of exon coordinate pairs is then flattened into a single list of integers of the form $[s_1, e_1, s_2, e_2, \\dots]$.\n\n**Final Output Generation**\n\nFor each test case, the final result is a $3$-element list $[B, N, C]$ where:\n- $B$ is the `invalid_parent_detected` boolean flag.\n- $N$ is the total number of `mRNA` features found in the input snippet.\n- $C$ is the list of flattened, sorted exon chains, ordered according to the lexicographically sorted mRNA `ID`s.\n\n**Computational Complexity**\n\nLet $N$ be the number of features (lines) in the GFF3 snippet.\n- The parsing and indexing phase (Step 1) requires a single pass over the $N$ lines, with dictionary insertions taking $O(1)$ average time. This phase is $O(N)$.\n- The validation and association phase (Step 2) involves another pass over the $N$ features. For each feature, we may check a small number of parents. Each check is a dictionary lookup ($O(1)$). This phase is also approximately $O(N)$.\n- The assembly and sorting phase (Step 3) is dominated by sorting the exons for each mRNA. If there are $K$ mRNAs and the $k$-th mRNA has $E_k$ exons, the total time is $\\sum_{k=1}^{K} O(E_k \\log E_k)$. In the worst case, where all $N$ features are exons of a single transcript, this becomes $O(N \\log N)$. Sorting the $K$ mRNA IDs takes $O(K \\log K)$.\nThe overall complexity is therefore dominated by sorting, resulting in an efficient $O(N \\log N)$ algorithm.", "answer": "```python\ndef solve():\n    \"\"\"\n    Solves the GFF3 transcript reconstruction and validation problem.\n    This function embeds the test suite and processes each case according to GFF3 rules.\n    \"\"\"\n    test_cases_gff3 = [\n        # Case 1: positive strand, single transcript, ordered exons\n        \"\"\"\nchr1\\t.\\tgene\\t100\\t400\\t.\\t+\\t.\\tID=g1\nchr1\\t.\\tmRNA\\t100\\t400\\t.\\t+\\t.\\tID=t1;Parent=g1\nchr1\\t.\\texon\\t100\\t200\\t.\\t+\\t.\\tID=e1;Parent=t1\nchr1\\t.\\texon\\t300\\t400\\t.\\t+\\t.\\tID=e2;Parent=t1\n        \"\"\",\n        # Case 2: negative strand, single transcript, out-of-order exons\n        \"\"\"\nchr2\\t.\\tgene\\t450\\t600\\t.\\t-\\t.\\tID=g2\nchr2\\t.\\tmRNA\\t450\\t600\\t.\\t-\\t.\\tID=t2;Parent=g2\nchr2\\t.\\texon\\t500\\t600\\t.\\t-\\t.\\tID=e3;Parent=t2\nchr2\\t.\\texon\\t450\\t480\\t.\\t-\\t.\\tID=e4;Parent=t2\n        \"\"\",\n        # Case 3: invalid parent reference (nonexistent)\n        \"\"\"\nchr3\\t.\\tgene\\t200\\t300\\t.\\t+\\t.\\tID=g3\nchr3\\t.\\tmRNA\\t200\\t300\\t.\\t+\\t.\\tID=t3;Parent=g3\nchr3\\t.\\texon\\t200\\t250\\t.\\t+\\t.\\tID=e5;Parent=t3\nchr3\\t.\\texon\\t260\\t300\\t.\\t+\\t.\\tID=e6;Parent=mr_unknown\n        \"\"\",\n        # Case 4: multiple parents with one invalid\n        \"\"\"\nchr4\\t.\\tgene\\t150\\t900\\t.\\t+\\t.\\tID=g4\nchr4\\t.\\tmRNA\\t150\\t900\\t.\\t+\\t.\\tID=t4;Parent=g4\nchr4\\t.\\texon\\t150\\t180\\t.\\t+\\t.\\tID=e7;Parent=t4,t4b\nchr4\\t.\\texon\\t800\\t900\\t.\\t+\\t.\\tID=e8;Parent=t4\n        \"\"\",\n        # Case 5: boundary conditions: tie-breaking and multiple transcripts\n        \"\"\"\nchr5\\t.\\tgene\\t100\\t320\\t.\\t+\\t.\\tID=g5\nchr5\\t.\\tmRNA\\t100\\t170\\t.\\t+\\t.\\tID=t5;Parent=g5\nchr5\\t.\\tmRNA\\t210\\t320\\t.\\t+\\t.\\tID=t5b;Parent=g5\nchr5\\t.\\texon\\t100\\t150\\t.\\t+\\t.\\tID=e9;Parent=t5\nchr5\\t.\\texon\\t100\\t120\\t.\\t+\\t.\\tID=e10;Parent=t5\nchr5\\t.\\texon\\t160\\t170\\t.\\t+\\t.\\tID=e11;Parent=t5\nchr5\\t.\\texon\\t210\\t220\\t.\\t+\\t.\\tID=e12;Parent=t5b\nchr5\\t.\\texon\\t300\\t320\\t.\\t+\\t.\\tID=e13;Parent=t5b\n        \"\"\"\n    ]\n\n    results = []\n    \n    for gff3_data in test_cases_gff3:\n        lines = [line for line in gff3_data.strip().split('\\n') if line.strip()]\n        \n        feature_map = {}\n        all_features = [] # To iterate over in the second pass\n\n        # Pass 1: Parse and index all features\n        for line in lines:\n            fields = line.strip().split('\\t')\n            seqid, source, ftype, start, end, score, strand, phase, attributes_str = fields\n            start, end = int(start), int(end)\n\n            # Parse attributes\n            attrs = {}\n            for part in attributes_str.split(';'):\n                if '=' in part:\n                    key, value = part.split('=', 1)\n                    attrs[key] = value\n\n            feature_id = attrs.get('ID')\n            parents = attrs.get('Parent', '').split(',') if attrs.get('Parent') else []\n\n            feature_info = {\n                'id': feature_id,\n                'type': ftype,\n                'start': start,\n                'end': end,\n                'strand': strand,\n                'parents': parents\n            }\n            \n            if feature_id:\n                feature_map[feature_id] = feature_info\n            \n            all_features.append(feature_info)\n\n        invalid_parent_found = False\n        mrna_ids = sorted([fid for fid, finfo in feature_map.items() if finfo['type'] == 'mRNA'])\n        mrna_to_exons = {mid: [] for mid in mrna_ids}\n        \n        # Pass 2: Validate relationships and associate exons\n        for feature in all_features:\n            ftype = feature['type']\n            parents = feature['parents']\n\n            if ftype == 'gene' and parents:\n                invalid_parent_found = True\n\n            elif ftype == 'mRNA':\n                if not parents: # An mRNA must have a parent\n                  invalid_parent_found = True\n                for parent_id in parents:\n                    if parent_id not in feature_map:\n                        invalid_parent_found = True\n                    elif feature_map.get(parent_id, {}).get('type') != 'gene':\n                        invalid_parent_found = True\n            \n            elif ftype == 'exon':\n                if not parents: # An exon must have a parent\n                  invalid_parent_found = True\n                for parent_id in parents:\n                    if parent_id not in feature_map:\n                        invalid_parent_found = True\n                    else:\n                        parent_feature = feature_map.get(parent_id)\n                        if parent_feature and parent_feature.get('type') == 'mRNA':\n                            # This check handles cases where an exon parent is a valid mRNA\n                            # but that mRNA is not in the list of mRNAs to be processed (e.g. from another gene).\n                            if parent_id in mrna_to_exons:\n                                mrna_to_exons[parent_id].append((feature['start'], feature['end']))\n                        else:\n                            invalid_parent_found = True\n        \n        # Pass 3: Sort exons and format output\n        exon_chains = []\n        for mrna_id in mrna_ids:\n            exons = mrna_to_exons[mrna_id]\n            strand = feature_map[mrna_id]['strand']\n            \n            if strand == '+':\n                exons.sort(key=lambda x: (x[0], x[1]))\n            elif strand == '-':\n                exons.sort(key=lambda x: (x[0], x[1]), reverse=True)\n            \n            chain = [coord for exon_coords in exons for coord in exon_coords]\n            exon_chains.append(chain)\n\n        results.append([invalid_parent_found, len(mrna_ids), exon_chains])\n\n    # Format the final output string exactly as specified.\n    # The default string representation of lists, booleans, and integers is used.\n    output_str = '[' + ','.join(map(str, results)) + ']'\n    print(output_str)\n\nsolve()\n```", "id": "3291684"}, {"introduction": "For data to be truly useful and reproducible, it must be well-documented according to the FAIR (Findable, Accessible, Interoperable, and Reusable) principles. This exercise ([@problem_id:3291672]) moves from parsing existing formats to the crucial task of designing and enforcing a new data standard for experimental metadata. You will develop a JSON Schema to ensure single-cell RNA-seq sample information is complete and consistent, providing a practical lesson in how to build robust, interoperable, and FAIR-compliant data pipelines from the ground up.", "problem": "You are tasked with designing and programmatically enforcing a data standard for sample metadata in a single-cell ribonucleic acid sequencing (scRNA-seq; single-cell RNA sequencing) study. The goal is to translate first principles of data integrity and interoperability, such as Findable, Accessible, Interoperable, Reusable (FAIR), into a concrete validation scheme for tabular records represented in JavaScript Object Notation (JSON; JavaScript Object Notation). From the perspective of mathematical logic and set theory, a schema specifies admissible values by establishing type constraints, set membership (enumerations), and numeric order relations over specified domains.\n\nStarting from the following foundational bases:\n- Types as sets: a string field takes values from a set of all finite character sequences, an integer field takes values from the set of integers $\\mathbb{Z}$, and a numeric field takes values from the set of real numbers $\\mathbb{R}$.\n- Set membership constraints: enumeration constraints require $x \\in S$ where $S$ is an explicitly listed finite set.\n- Order constraints: numeric ranges are expressed as $a \\le x \\le b$ for lower bound $a$ and upper bound $b$ within $\\mathbb{R}$ or $\\mathbb{Z}$.\n\nPropose a JSON Schema that enforces the following properties over each record $r$:\n- Required fields and their types:\n  - $sample\\_id$: string.\n  - $species$: string, with enumeration $S\\_{\\text{species}} = \\{\\text{\"Homo sapiens\"}, \\text{\"Mus musculus\"}\\}$.\n  - $tissue$: string, with enumeration $S\\_{\\text{tissue}} = \\{\\text{\"lung\"}, \\text{\"liver\"}, \\text{\"kidney\"}\\}$.\n  - $platform$: string, with enumeration $S\\_{\\text{platform}} = \\{\\text{\"10x Genomics\"}, \\text{\"Smart-seq2\"}, \\text{\"Drop-seq\"}\\}$.\n  - $umi\\_count$: integer with range constraint $1 \\le umi\\_count \\le 10^6$.\n  - $mito\\_fraction$: number with range constraint $0 \\le mito\\_fraction \\le 1$, expressed as a decimal (do not use a percentage sign).\n  - $doublet\\_probability$: number with range constraint $0 \\le doublet\\_probability \\le 1$, expressed as a decimal (do not use a percentage sign).\n  - $age\\_years$: integer with range constraint $0 \\le age\\_years \\le 120$, expressed in years.\n  - $sex$: string, with enumeration $S\\_{\\text{sex}} = \\{\\text{\"male\"}, \\text{\"female\"}, \\text{\"unknown\"}\\}$.\n- Optional fields may be present but are not required. Any present field must comply with its declared type and any applicable constraints.\n- Additional properties not listed above may be present; they do not affect validation outcomes provided all required fields satisfy constraints.\n\nYour program must:\n1. Construct the above schema as an internal data object.\n2. Validate a test suite of five records against the schema, producing a boolean validity for each record, where $\\text{True}$ indicates the record conforms to the schema and $\\text{False}$ indicates a violation.\n3. Demonstrate detection of three specific malformed records:\n   - Missing required field.\n   - Enumeration violation (value not in the required set).\n   - Numeric range violation (value outside the required bounds).\n4. Use the following test suite with explicit values:\n   - Record A (happy path): $sample\\_id$ = \"SC0001\", $species$ = \"Homo sapiens\", $tissue$ = \"lung\", $platform$ = \"10x Genomics\", $umi\\_count$ = $50000$, $mito\\_fraction$ = $0.08$, $doublet\\_probability$ = $0.05$, $age\\_years$ = $34$, $sex$ = \"female\".\n   - Record B (boundary conditions): $sample\\_id$ = \"SC0002\", $species$ = \"Mus musculus\", $tissue$ = \"liver\", $platform$ = \"Smart-seq2\", $umi\\_count$ = $1$, $mito\\_fraction$ = $0.0$, $doublet\\_probability$ = $1.0$, $age\\_years$ = $0$, $sex$ = \"male\".\n   - Record C (missing required field): $sample\\_id$ = \"SC0003\", $tissue$ = \"kidney\", $platform$ = \"Drop-seq\", $umi\\_count$ = $20000$, $mito\\_fraction$ = $0.12$, $doublet\\_probability$ = $0.1$, $age\\_years$ = $12$, $sex$ = \"unknown\". The $species$ field is intentionally omitted.\n   - Record D (enumeration violation): $sample\\_id$ = \"SC0004\", $species$ = \"Drosophila melanogaster\", $tissue$ = \"lung\", $platform$ = \"10x Genomics\", $umi\\_count$ = $30000$, $mito\\_fraction$ = $0.07$, $doublet\\_probability$ = $0.02$, $age\\_years$ = $5$, $sex$ = \"female\".\n   - Record E (numeric range violation): $sample\\_id$ = \"SC0005\", $species$ = \"Homo sapiens\", $tissue$ = \"liver\", $platform$ = \"Smart-seq2\", $umi\\_count$ = $500000$, $mito\\_fraction$ = $1.2$, $doublet\\_probability$ = $0.03$, $age\\_years$ = $27$, $sex$ = \"male\".\n5. The final output format must be a single line containing the results as a comma-separated list enclosed in square brackets. For example, if your results for records A through E are $[v\\_A, v\\_B, v\\_C, v\\_D, v\\_E]$ with $v\\_i \\in \\{\\text{True}, \\text{False}\\}$, print exactly \"[True,False,True,False,True]\".\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4,result5]\"). The answers for all test cases must be booleans.", "solution": "The solution is grounded in established principles of data integrity and formal semantics of schemas. We start from the view that a schema defines a subset of the Cartesian product of field domains, enforcing constraints by intersection with sets defined by type, enumeration, and interval bounds.\n\n1. Define types as sets. For each field $f$, assign a type $T\\_f$:\n   - For strings, $T\\_f$ is the set of finite character sequences.\n   - For integers, $T\\_f = \\mathbb{Z}$.\n   - For numbers, $T\\_f = \\mathbb{R}$.\n\n2. Define required fields. Let $R$ be the set of required field names. A record $r$ is admissible only if $\\forall f \\in R$, $f \\in \\text{dom}(r)$, where $\\text{dom}(r)$ is the set of keys present in $r$. This enforces presence.\n\n3. Enforce type constraints. For each present field $f$, check $r[f] \\in T\\_f$. In code, this is a runtime type test. For integer fields, we must ensure $r[f] \\in \\mathbb{Z}$ and exclude boolean values because in many programming languages booleans are a subtype of integers; thus we explicitly require $r[f]$ to be an integer and not a boolean.\n\n4. Enforce enumeration constraints. For fields with enumeration, let $S\\_f$ be the finite allowed set. Require $r[f] \\in S\\_f$. This implements the set membership predicate $x \\in S$.\n\n5. Enforce numeric ranges. For numeric fields with inclusive bounds, a value $x$ is valid if $a \\le x \\le b$ where $a$ and $b$ are the minimum and maximum respectively. Here:\n   - $1 \\le umi\\_count \\le 10^6$ for the unique molecular identifier count.\n   - $0 \\le mito\\_fraction \\le 1$ and $0 \\le doublet\\_probability \\le 1$ with values expressed as decimals.\n   - $0 \\le age\\_years \\le 120$.\n\n6. Compose the validator. The validator function iterates through required fields to check presence, then iterates over properties to:\n   - assert types,\n   - apply enumeration checks when defined,\n   - apply minimum and maximum checks when defined.\n   Any violation yields a boolean $\\text{False}$; otherwise return $\\text{True}$.\n\n7. Apply to the test suite:\n   - Record A satisfies all constraints: types match, all required fields present, enumerations valid, and numeric values inside ranges; therefore it is $\\text{True}$.\n   - Record B checks boundary inclusivity: $umi\\_count = 1$, $mito\\_fraction = 0.0$, $doublet\\_probability = 1.0$, $age\\_years = 0$ are all within inclusive bounds, and enumerations are valid; therefore it is $\\text{True}$.\n   - Record C omits $species$, a required field. By step $2$, $\\exists f \\in R$ such that $f \\notin \\text{dom}(r)$, thus it is $\\text{False}$.\n   - Record D sets $species$ to \"Drosophila melanogaster\" which violates $S\\_{\\text{species}}$. Since $r[\\text{species}] \\notin S\\_{\\text{species}}$, it is $\\text{False}$.\n   - Record E sets $mito\\_fraction = 1.2$ which violates $0 \\le mito\\_fraction \\le 1$. Because $1.2 \\notin [0,1]$, it is $\\text{False}$.\n\n8. Output aggregation. Collect the five booleans $[v\\_A, v\\_B, v\\_C, v\\_D, v\\_E]$ and print them as a single line in the required format. This satisfies the testability requirement and demonstrates schema-based validation detecting the three malformed records.\n\nThis approach directly implements the intersection of constraints from types, enumerations, and numeric intervals, aligning with the FAIR principles by making data interoperable through strict conformance to a shared schema.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\n# We use only the Python standard library.\nfrom typing import Any, Dict, List\n\ndef is_integer(value: Any) -> bool:\n    # Exclude booleans (which are subclasses of int in Python)\n    return isinstance(value, int) and not isinstance(value, bool)\n\ndef is_number(value: Any) -> bool:\n    # Accept ints and floats, but exclude booleans\n    return (isinstance(value, int) and not isinstance(value, bool)) or isinstance(value, float)\n\ndef validate_record(record: Dict[str, Any], schema: Dict[str, Any]) -> bool:\n    # Check required fields presence\n    for req in schema.get(\"required\", []):\n        if req not in record:\n            return False\n\n    properties = schema.get(\"properties\", {})\n\n    # Validate each property that appears in the record and is defined in the schema\n    for key, prop in properties.items():\n        if key not in record:\n            # If not present, skip unless it's required (handled above)\n            continue\n        value = record[key]\n        # Type checks\n        expected_type = prop.get(\"type\")\n        if expected_type == \"string\":\n            if not isinstance(value, str):\n                return False\n        elif expected_type == \"integer\":\n            if not is_integer(value):\n                return False\n        elif expected_type == \"number\":\n            if not is_number(value):\n                return False\n        else:\n            # Unknown type in schema; for robustness, consider invalid\n            return False\n\n        # Enumeration check\n        enum_values = prop.get(\"enum\")\n        if enum_values is not None:\n            if value not in enum_values:\n                return False\n\n        # Range checks (minimum and maximum, inclusive)\n        if expected_type in (\"integer\", \"number\"):\n            if \"minimum\" in prop:\n                if value < prop[\"minimum\"]:\n                    return False\n            if \"maximum\" in prop:\n                if value > prop[\"maximum\"]:\n                    return False\n\n    # All checks passed\n    return True\n\ndef solve():\n    # Define the JSON Schema as a Python dictionary\n    schema = {\n        \"type\": \"object\",\n        \"required\": [\n            \"sample_id\",\n            \"species\",\n            \"tissue\",\n            \"platform\",\n            \"umi_count\",\n            \"mito_fraction\",\n            \"doublet_probability\",\n            \"age_years\",\n            \"sex\"\n        ],\n        \"properties\": {\n            \"sample_id\": {\"type\": \"string\"},\n            \"species\": {\n                \"type\": \"string\",\n                \"enum\": [\"Homo sapiens\", \"Mus musculus\"]\n            },\n            \"tissue\": {\n                \"type\": \"string\",\n                \"enum\": [\"lung\", \"liver\", \"kidney\"]\n            },\n            \"platform\": {\n                \"type\": \"string\",\n                \"enum\": [\"10x Genomics\", \"Smart-seq2\", \"Drop-seq\"]\n            },\n            \"umi_count\": {\n                \"type\": \"integer\",\n                \"minimum\": 1,\n                \"maximum\": 10**6\n            },\n            \"mito_fraction\": {\n                \"type\": \"number\",\n                \"minimum\": 0.0,\n                \"maximum\": 1.0\n            },\n            \"doublet_probability\": {\n                \"type\": \"number\",\n                \"minimum\": 0.0,\n                \"maximum\": 1.0\n            },\n            \"age_years\": {\n                \"type\": \"integer\",\n                \"minimum\": 0,\n                \"maximum\": 120\n            },\n            \"sex\": {\n                \"type\": \"string\",\n                \"enum\": [\"male\", \"female\", \"unknown\"]\n            },\n            # Optional fields example (not required)\n            \"library_prep\": {\n                \"type\": \"string\",\n                \"enum\": [\"polyA\", \"totalRNA\"]\n            },\n            \"batch_id\": {\"type\": \"string\"}\n        },\n        # Allow additional properties without affecting validation\n        \"additionalProperties\": True\n    }\n\n    # Define the test cases (records A-E)\n    test_cases: List[Dict[str, Any]] = [\n        # Record A (happy path)\n        {\n            \"sample_id\": \"SC0001\",\n            \"species\": \"Homo sapiens\",\n            \"tissue\": \"lung\",\n            \"platform\": \"10x Genomics\",\n            \"umi_count\": 50000,\n            \"mito_fraction\": 0.08,\n            \"doublet_probability\": 0.05,\n            \"age_years\": 34,\n            \"sex\": \"female\"\n        },\n        # Record B (boundary conditions)\n        {\n            \"sample_id\": \"SC0002\",\n            \"species\": \"Mus musculus\",\n            \"tissue\": \"liver\",\n            \"platform\": \"Smart-seq2\",\n            \"umi_count\": 1,\n            \"mito_fraction\": 0.0,\n            \"doublet_probability\": 1.0,\n            \"age_years\": 0,\n            \"sex\": \"male\"\n        },\n        # Record C (missing required field: species)\n        {\n            \"sample_id\": \"SC0003\",\n            \"tissue\": \"kidney\",\n            \"platform\": \"Drop-seq\",\n            \"umi_count\": 20000,\n            \"mito_fraction\": 0.12,\n            \"doublet_probability\": 0.1,\n            \"age_years\": 12,\n            \"sex\": \"unknown\"\n        },\n        # Record D (enumeration violation: species not allowed)\n        {\n            \"sample_id\": \"SC0004\",\n            \"species\": \"Drosophila melanogaster\",\n            \"tissue\": \"lung\",\n            \"platform\": \"10x Genomics\",\n            \"umi_count\": 30000,\n            \"mito_fraction\": 0.07,\n            \"doublet_probability\": 0.02,\n            \"age_years\": 5,\n            \"sex\": \"female\"\n        },\n        # Record E (numeric range violation: mito_fraction > 1)\n        {\n            \"sample_id\": \"SC0005\",\n            \"species\": \"Homo sapiens\",\n            \"tissue\": \"liver\",\n            \"platform\": \"Smart-seq2\",\n            \"umi_count\": 500000,\n            \"mito_fraction\": 1.2,\n            \"doublet_probability\": 0.03,\n            \"age_years\": 27,\n            \"sex\": \"male\"\n        },\n    ]\n\n    results = []\n    for rec in test_cases:\n        result = validate_record(rec, schema)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3291672"}]}