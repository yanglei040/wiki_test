{"hands_on_practices": [{"introduction": "The convergence speed of Optimized Schwarz Methods hinges on the careful design of transmission conditions at artificial subdomain interfaces. This exercise provides a foundational, physics-based approach to deriving these conditions by modeling the iterative process as wave reflection [@problem_id:3302402]. By minimizing the reflection coefficient at the interface, you will derive the optimal impedance for the Robin transmission condition, revealing how it relates to the intrinsic impedance $\\sqrt{\\mu/\\epsilon}$ of the local medium.", "problem": "Consider time-harmonic Maxwell equations in a stratified, isotropic medium with fields varying only in the normal direction to planar interfaces. Let the time dependence be $\\exp(-i \\omega t)$ with angular frequency $\\omega > 0$. A computational domain is split into two non-overlapping subdomains by a planar interface $\\Gamma$ at $x=0$, with the outward unit normal from the left subdomain pointing in the $+x$ direction. The subdomain problems are solved using the Finite Element Method (FEM) and coupled by a Domain Decomposition Method (DDM) of the Optimized Schwarz Method (OSM) type that employs Robin transmission conditions on $\\Gamma$.\n\nAssume a transverse electric polarization at normal incidence, so the nonzero components are the tangential electric field $E_{t}(x)$ and the tangential magnetic field $H_{t}(x)$. The left subdomain is locally homogeneous in a neighborhood of $\\Gamma$ with permittivity $\\epsilon_{-}>0$ and permeability $\\mu_{-}>0$. The right subdomain is a semi-infinite heterogeneous stack of planar layers for $x>0$ with piecewise-constant $\\epsilon(x)$ and $\\mu(x)$, terminating in a semi-infinite homogeneous half-space; denote by $Y_{\\mathrm{in}}$ the exact input admittance of this semi-infinite stack as “seen” at $x=0^{+}$ by an outgoing wave, i.e., the Dirichlet-to-Neumann (DtN) map on $\\Gamma$ has the form $n \\times H_{t} - Y_{\\mathrm{in}} E_{t} = 0$.\n\nOn the left subproblem, the OSM Robin transmission condition is\n$n \\times H_{t} - \\frac{1}{Z} E_{t} = 0$\non $\\Gamma$, where $Z>0$ is a real tuning parameter (the “Robin impedance”). For a plane wave at normal incidence, model the interfacial error dynamics by the reflection of a wave at an impedance termination, and treat the mismatch between the exact DtN $Y_{\\mathrm{in}}$ and the Robin admittance $1/Z$ as the sole source of interfacial reflection in the DDM iteration.\n\nStarting only from the frequency-domain Maxwell equations and the plane-wave relations they imply in homogeneous media, do the following:\n\n- Derive the input admittance $Y_{\\mathrm{in}}$ for a semi-infinite homogeneous half-space to the right in terms of the local material parameters. Then define $Y_{\\mathrm{in}}$ for a heterogeneous semi-infinite stack as the ratio of the outgoing-wave traces $H_{t}(0^{+})/E_{t}(0^{+})$ at $\\Gamma$.\n\n- Using wave variables referenced to the exact input impedance of the right stack, derive the interfacial reflection coefficient $\\mathcal{R}(Z)$ induced by imposing $n \\times H_{t} - \\frac{1}{Z} E_{t} = 0$ in place of the exact DtN $n \\times H_{t} - Y_{\\mathrm{in}} E_{t} = 0$, and express $\\mathcal{R}(Z)$ in closed form as a function of $Z$ and the effective input impedance $\\eta_{\\mathrm{in}} = 1/Y_{\\mathrm{in}}$.\n\n- Minimize $|\\mathcal{R}(Z)|$ over real positive $Z$ and obtain the corresponding optimal Robin parameter $Z_{\\mathrm{opt}}$.\n\nFinally, specialize to the scientifically realistic and practically important case that the interface $\\Gamma$ lies strictly inside a single homogeneous layer of the heterogeneous stack with local material parameters $\\mu$ and $\\epsilon$ (so that multiple reflections are accounted for inside the right subdomain). Under this assumption, express your final result for $Z_{\\mathrm{opt}}$ solely in terms of $\\mu$ and $\\epsilon$. Provide your final answer as a single closed-form analytic expression. Do not include units in the final answer.", "solution": "The problem asks for the derivation of an optimal Robin transmission condition parameter for a domain decomposition method applied to the 1D time-harmonic Maxwell's equations. The process involves analyzing wave reflection at the interface between subdomains.\n\nFirst, we establish the governing equations. For a time dependence of $\\exp(-i \\omega t)$, Maxwell's equations in a source-free, isotropic, homogeneous medium with permittivity $\\epsilon$ and permeability $\\mu$ are:\n$$\n\\nabla \\times \\vec{E} = i \\omega \\mu \\vec{H} \\\\\n\\nabla \\times \\vec{H} = -i \\omega \\epsilon \\vec{E}\n$$\nThe problem specifies a transverse electric (TE) polarization with fields varying only in the $x$-direction, $E_t(x)$ and $H_t(x)$. To satisfy $\\nabla \\cdot \\vec{E}=0$ and $\\nabla \\cdot \\vec{H}=0$ for a 1D field variation, the fields must be purely transverse to the $x$-direction. We consider the specific polarization where $\\vec{E} = E_y(x) \\hat{y}$ and $\\vec{H} = H_z(x) \\hat{z}$. The tangential fields are thus $E_t(x) = E_y(x)$ and $H_t(x) = H_z(x)$. The 1D Maxwell's equations become:\n$$\n\\frac{d E_t}{dx} = i \\omega \\mu H_t \\\\\n\\frac{d H_t}{dx} = i \\omega \\epsilon E_t\n$$\nCombining these equations yields the Helmholtz equation for $E_t$:\n$$\n\\frac{d^2 E_t}{dx^2} + k^2 E_t = 0, \\quad \\text{where } k = \\omega \\sqrt{\\mu\\epsilon} \\text{ is the wavenumber.}\n$$\nThe general solution is a superposition of a forward (right-propagating) wave and a backward (left-propagating) wave:\n$$\nE_t(x) = E^+ \\exp(ikx) + E^- \\exp(-ikx)\n$$\nThe corresponding magnetic field is:\n$$\nH_t(x) = \\frac{1}{i\\omega\\mu} \\frac{dE_t}{dx} = \\frac{k}{\\omega\\mu} \\left( E^+ \\exp(ikx) - E^- \\exp(-ikx) \\right)\n$$\nWe define the intrinsic impedance of the medium as $\\eta = \\frac{\\omega\\mu}{k} = \\frac{\\omega\\mu}{\\omega\\sqrt{\\mu\\epsilon}} = \\sqrt{\\frac{\\mu}{\\epsilon}}$. The magnetic field can then be written as:\n$$\nH_t(x) = \\frac{1}{\\eta} \\left( E^+ \\exp(ikx) - E^- \\exp(-ikx) \\right)\n$$\n\nNow, we address the specific tasks.\n\n**1. Input Admittance of a Homogeneous Half-Space**\n\nConsider a semi-infinite homogeneous half-space for $x>0$ with parameters $\\mu_r, \\epsilon_r$. An outgoing wave from the interface at $x=0$ propagates into this domain. The physical requirement that there are no sources at infinity imposes a radiation condition, meaning there can be no backward-propagating wave component. Thus, $E^- = 0$. The fields for $x>0$ are purely forward-propagating:\n$$\nE_t(x) = E^+ \\exp(ik_r x) \\\\\nH_t(x) = \\frac{1}{\\eta_r} E^+ \\exp(ik_r x)\n$$\nwhere $k_r = \\omega\\sqrt{\\mu_r \\epsilon_r}$ and $\\eta_r = \\sqrt{\\mu_r / \\epsilon_r}$. The problem defines the input admittance $Y_{\\mathrm{in}}$ as the ratio $H_t(0^+)/E_t(0^+)$ for such an outgoing wave.\n$$\nY_{\\mathrm{in}} = \\frac{H_t(0^+)}{E_t(0^+)} = \\frac{(1/\\eta_r) E^+ \\exp(0)}{E^+ \\exp(0)} = \\frac{1}{\\eta_r} = \\sqrt{\\frac{\\epsilon_r}{\\mu_r}}\n$$\n\n**2. Input Admittance of a Heterogeneous Stack**\n\nFor a semi-infinite heterogeneous stack for $x>0$, the problem defines the input admittance $Y_{\\mathrm{in}}$ as the ratio of the total tangential fields for an outgoing wave at the interface: $Y_{\\mathrm{in}} = H_t(0^+) / E_t(0^+)$. The corresponding input impedance is $\\eta_{\\mathrm{in}} = 1/Y_{\\mathrm{in}} = E_t(0^+) / H_t(0^+)$. Due to multiple reflections within the stack, $\\eta_{\\mathrm{in}}$ is generally a complex quantity, even for lossless layers.\n\n**3. Interfacial Reflection Coefficient $\\mathcal{R}(Z)$**\n\nThe core of the problem is to find the reflection coefficient that governs the convergence of the Optimized Schwarz Method. This coefficient arises from the mismatch between the exact Dirichlet-to-Neumann (DtN) condition and the approximate Robin transmission condition at the interface $\\Gamma$. The problem states these conditions in vector form. The exact DtN is $n \\times H_{t} - Y_{\\mathrm{in}} E_{t} = 0$, and the approximate Robin condition is $n \\times H_{t} - \\frac{1}{Z} E_{t} = 0$. For our 1D setting with $n=\\hat{x}$, $\\vec{E}_t = E_t \\hat{y}$, and $\\vec{H}_t = H_t \\hat{z}$, both vector equations reduce to scalar proportionality relations between $E_t$ and $H_t$. The physical system imposes an impedance relation $E_t = \\eta_{in} H_t$, while the numerical method imposes $E_t = Z H_t$.\n\nThe reflection coefficient is derived by modeling the effect of this impedance mismatch. We use the framework of wave variables referenced to the exact input impedance of the right stack, $\\eta_{\\mathrm{in}}$. The total fields $E_t, H_t$ at the interface are decomposed into incident ($a$) and reflected ($b$) components relative to the characteristic impedance $\\eta_{\\mathrm{in}}$:\n$$\nE_t = a + b \\\\\nH_t = \\frac{1}{\\eta_{\\mathrm{in}}}(a - b)\n$$\nThe reflection coefficient is defined as $\\mathcal{R} = b/a$. These total fields must satisfy the imposed Robin condition, which dictates the impedance of the termination: $E_t = Z H_t$. Substituting the wave variable expressions into this condition:\n$$\na+b = Z \\left(\\frac{1}{\\eta_{\\mathrm{in}}}(a - b)\\right)\n$$\n$$\n\\eta_{\\mathrm{in}}(a+b) = Z(a-b)\n$$\n$$\na\\eta_{\\mathrm{in}} + b\\eta_{\\mathrm{in}} = aZ - bZ\n$$\n$$\nb(Z + \\eta_{\\mathrm{in}}) = a(Z - \\eta_{\\mathrm{in}})\n$$\n$$\n\\mathcal{R}(Z) = \\frac{b}{a} = \\frac{Z - \\eta_{\\mathrm{in}}}{Z + \\eta_{\\mathrm{in}}}\n$$\nThis is the standard expression for reflection coefficient at a load impedance $Z$ for a wave medium with characteristic impedance $\\eta_{\\mathrm{in}}$.\n\n**4. Minimization of $|\\mathcal{R}(Z)|$**\n\nTo optimize the convergence of the DDM, we must minimize the magnitude of the interfacial reflection coefficient, $|\\mathcal{R}(Z)|$, with respect to the real, positive parameter $Z$. The input impedance $\\eta_{\\mathrm{in}}$ may be complex, so let $\\eta_{\\mathrm{in}} = R + iI$, where $R = \\Re(\\eta_{\\mathrm{in}})$ and $I = \\Im(\\eta_{\\mathrm{in}})$.\n$$\n|\\mathcal{R}(Z)|^2 = \\left| \\frac{Z - (R+iI)}{Z + (R+iI)} \\right|^2 = \\frac{|(Z-R) - iI|^2}{|(Z+R) + iI|^2} = \\frac{(Z-R)^2 + I^2}{(Z+R)^2 + I^2}\n$$\nTo find the minimum, we differentiate with respect to $Z$ and set the result to zero. Let $f(Z) = |\\mathcal{R}(Z)|^2$.\n$$\n\\frac{df}{dZ} = \\frac{2(Z-R)((Z+R)^2 + I^2) - ((Z-R)^2 + I^2)2(Z+R)}{((Z+R)^2 + I^2)^2} = 0\n$$\nThe numerator must be zero. For passive media, $\\Re(\\eta_{\\mathrm{in}}) = R \\ge 0$. Assuming $R \\ne 0$:\n$$\n(Z-R)((Z+R)^2 + I^2) = (Z+R)((Z-R)^2 + I^2)\n$$\n$$\n(Z-R)(Z^2+2ZR+R^2+I^2) = (Z+R)(Z^2-2ZR+R^2+I^2)\n$$\nExpanding and simplifying:\n$$\n(Z^2-R^2)(Z+R) + I^2(Z-R) = (Z^2-R^2)(Z-R) + I^2(Z+R)\n$$\n$$\n(Z^2-R^2)((Z+R)-(Z-R)) = I^2((Z+R)-(Z-R))\n$$\n$$\n(Z^2-R^2)(2R) = I^2(2R)\n$$\nSince $R \\neq 0$, we can divide by $2R$:\n$$\nZ^2 - R^2 = I^2 \\implies Z^2 = R^2 + I^2 = (\\Re(\\eta_{\\mathrm{in}}))^2 + (\\Im(\\eta_{\\mathrm{in}}))^2 = |\\eta_{\\mathrm{in}}|^2\n$$\nAs $Z$ must be positive, the optimal value is $Z_{\\mathrm{opt}} = |\\eta_{\\mathrm{in}}|$.\n\n**5. Specialization and Final Answer**\n\nThe final step is to apply this result to the case where the artificial interface $\\Gamma$ is located inside a homogeneous layer with parameters $\\mu$ and $\\epsilon$. In the practical application and theory of Optimized Schwarz Methods, the optimal transmission conditions are typically derived by approximating the non-local DtN operator with a local operator whose parameters depend only on the local properties of the medium at the interface. This is equivalent to assuming the subdomain is semi-infinite and homogeneous with these local material properties.\n\nTherefore, under this scientifically pertinent assumption, we replace the full, complex input impedance of the heterogeneous stack, $\\eta_{\\mathrm{in}}$, with the local intrinsic impedance of the medium at $x=0$.\n$$\n\\eta_{\\mathrm{in}} \\approx \\eta_{\\mathrm{local}} = \\sqrt{\\frac{\\mu}{\\epsilon}}\n$$\nThis impedance is a real, positive quantity. Substituting this into our expression for the optimal parameter $Z_{\\mathrm{opt}}$:\n$$\nZ_{\\mathrm{opt}} = |\\eta_{\\mathrm{in}}| \\approx \\left| \\sqrt{\\frac{\\mu}{\\epsilon}} \\right| = \\sqrt{\\frac{\\mu}{\\epsilon}}\n$$\nThis provides the optimal Robin impedance parameter solely in terms of the local material parameters $\\mu$ and $\\epsilon$ at the interface.", "answer": "$$\\boxed{\\sqrt{\\frac{\\mu}{\\epsilon}}}$$", "id": "3302402"}, {"introduction": "Building on the theoretical understanding of optimal transmission conditions, this practice transitions from derivation to implementation. You will construct a complete one-dimensional Finite Element Method (FEM) solver for the Helmholtz equation and embed it within an iterative Optimized Schwarz framework [@problem_id:3302374]. This hands-on coding exercise demonstrates how the abstract weak formulation, boundary conditions, and iterative data exchange translate into a functional DDM solver, bridging the gap between theory and practical application.", "problem": "Consider the time-harmonic Maxwell equations in a homogeneous, isotropic, source-driven medium with permittivity $\\epsilon$ and permeability $\\mu$, written in the frequency domain as\n$$\n\\nabla \\times \\mathbf{H} = \\mathbf{J} + i \\omega \\epsilon \\mathbf{E}, \\quad \\nabla \\times \\mathbf{E} = - i \\omega \\mu \\mathbf{H},\n$$\nwhere $\\mathbf{E}$ and $\\mathbf{H}$ are the electric and magnetic fields, $\\mathbf{J}$ is a given current density, and $\\omega$ is the angular frequency. Under a Transverse Electric (TE) or Transverse Magnetic (TM) reduction in a one-dimensional uniform medium, the governing equation for the relevant scalar component reduces to the Helmholtz equation\n$$\n- \\frac{d^2 u}{dx^2} - k^2 u = f(x),\n$$\non a finite interval $x \\in [0, L]$, where $u(x)$ denotes a scalar field component, $k = \\omega \\sqrt{\\mu \\epsilon}$ is the wavenumber, and $f(x)$ is the scalar source term derived from $\\mathbf{J}$. At the physical boundaries, a first-order absorbing boundary condition consistent with the Silver-Müller radiation condition is imposed in one dimension:\n$$\n\\frac{du}{dx}(0) + i k\\, u(0) = 0, \\quad -\\frac{du}{dx}(L) + i k\\, u(L) = 0.\n$$\nWe aim to solve this boundary value problem using a two-subdomain domain decomposition method based on the Optimized Schwarz approach. Let the interval $[0, L]$ be partitioned into two overlapping subdomains $\\Omega_1 = [0, a]$ and $\\Omega_2 = [b, L]$ with overlap length $\\delta = a - b \\ge 0$. Denote by $p \\in \\mathbb{C}$ the Robin transmission parameter. The Optimized Schwarz iteration enforces Robin-type transmission conditions at the artificial interfaces:\n$$\n\\frac{du_1}{dx}(a) + p\\, u_1(a) = -\\frac{du_2}{dx}(a) + p\\, u_2(a), \\quad -\\frac{du_2}{dx}(b) + p\\, u_2(b) = \\frac{du_1}{dx}(b) + p\\, u_1(b),\n$$\nwhere $u_1$ and $u_2$ are the subdomain solutions on $\\Omega_1$ and $\\Omega_2$, respectively. The absorbing boundary conditions at $x=0$ and $x=L$ are retained for the physical boundaries. The algorithm alternates between solving on $\\Omega_1$ and $\\Omega_2$ using the most recent data to update the Robin transmission conditions.\n\nStarting from the weak formulation of the one-dimensional Helmholtz equation with Robin boundary conditions, derive the finite element method using continuous, piecewise linear functions on a uniform mesh. Show how the Robin boundary terms enter the bilinear form and the linear form at both physical boundaries and artificial interfaces. Then, implement a program that:\n- Assembles the one-dimensional finite element matrices for the Helmholtz operator using a uniform partition of $[0, L]$ with $N$ elements.\n- Solves the two-subdomain Optimized Schwarz iteration with Robin transmission using the coefficient $p$, where the inhomogeneous Robin data at the artificial boundaries is equalized across subdomains as specified above.\n- Uses the source term $f(x) = e^{i k x}$ and initializes the subdomain iterates to zero.\n- At each iteration, forms the interface data using one-sided derivatives consistent with the outward normal of each subdomain and checks convergence by evaluating the maximum norm of the two transmission mismatches:\n$$\nr_1 = \\left(\\frac{du_1}{dx}(a) + p\\, u_1(a)\\right) - \\left(-\\frac{du_2}{dx}(a) + p\\, u_2(a)\\right), \\quad\nr_2 = \\left(-\\frac{du_2}{dx}(b) + p\\, u_2(b)\\right) - \\left(\\frac{du_1}{dx}(b) + p\\, u_1(b)\\right).\n$$\nConvergence is declared when $\\max(|r_1|, |r_2|)$ is less than a prescribed tolerance.\n\nThe final output must be the number of iterations required to reach convergence for each of the specified test cases (or $-1$ if no convergence within the maximum number of iterations). No physical units are required in the output because the result is a unitless iteration count.\n\nImplement your solution for the following test suite:\n1. $L = 1.0$, $k = 20.0$, $p = i k$, overlap length $\\delta = 0.2$, $N = 400$, tolerance $10^{-8}$, maximum iterations $200$.\n2. $L = 1.0$, $k = 20.0$, $p = 1.0$, overlap length $\\delta = 0.2$, $N = 400$, tolerance $10^{-8}$, maximum iterations $200$.\n3. $L = 1.0$, $k = 40.0$, $p = i k$, overlap length $\\delta = 0.0$ (non-overlapping), $N = 800$, tolerance $10^{-8}$, maximum iterations $200$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3]\").", "solution": "The user has requested a solution to a one-dimensional Helmholtz boundary value problem using a two-subdomain Optimized Schwarz domain decomposition method, implemented with the Finite Element Method (FEM).\n\n### Step 1: Problem Validation\n\nThe problem specifies the governing equation, a one-dimensional Helmholtz equation, derived from Maxwell's equations under TE/TM assumptions:\n$$\n- \\frac{d^2 u}{dx^2} - k^2 u = f(x), \\quad x \\in [0, L]\n$$\nwith first-order absorbing boundary conditions at the physical boundaries $x=0$ and $x=L$:\n$$\n\\frac{du}{dx}(0) + i k\\, u(0) = 0, \\quad -\\frac{du}{dx}(L) + i k\\, u(L) = 0\n$$\nThe domain $[0, L]$ is partitioned into two overlapping subdomains $\\Omega_1 = [0, a]$ and $\\Omega_2 = [b, L]$. The core of the problem is to implement the Optimized Schwarz iteration with Robin transmission conditions at the artificial interfaces $x=a$ and $x=b$:\n$$\n\\frac{du_1}{dx}(a) + p\\, u_1(a) = -\\frac{du_2}{dx}(a) + p\\, u_2(a)\n$$\n$$\n-\\frac{du_2}{dx}(b) + p\\, u_2(b) = \\frac{du_1}{dx}(b) + p\\, u_1(b)\n$$\nThe problem further requires using a continuous, piecewise linear FEM discretization, specifies the source term $f(x) = e^{i k x}$, initialization, and a convergence criterion based on the mismatch in the transmission conditions.\n\nThe problem is scientifically grounded, well-posed, and objective. It provides all necessary information: the partial differential equation, boundary conditions, domain decomposition framework, numerical method details (FEM with linear basis functions), source term, and convergence tolerance. The parameters for the test cases are physically and computationally reasonable. The problem is a standard exercise in computational science and numerical analysis for PDEs.\n\n**Verdict:** The problem is valid.\n\n### Step 2: Theoretical Formulation\n\n#### Weak Formulation\nWe derive the weak formulation for a generic subdomain $[x_L, x_R]$ governed by $-u'' - k^2 u = f$, with general Robin boundary conditions. Multiplying by a test function $v$ and integrating by parts over $[x_L, x_R]$ yields:\n$$\n\\int_{x_L}^{x_R} u'(x)v'(x) \\,dx - [u'(x)v(x)]_{x_L}^{x_R} - k^2 \\int_{x_L}^{x_R} u(x)v(x) \\,dx = \\int_{x_L}^{x_R} f(x)v(x) \\,dx\n$$\nThe boundary term is $-u'(x_R)v(x_R) + u'(x_L)v(x_L)$. We incorporate the specific boundary conditions for each subdomain problem.\n\n**Subproblem 1 on $\\Omega_1 = [0, a]$**:\nThe boundary conditions are:\n1.  Physical BC at $x=0$: $\\frac{du_1}{dx}(0) + i k u_1(0) = 0 \\implies u_1'(0) = -i k u_1(0)$.\n2.  Transmission BC at $x=a$: $\\frac{du_1}{dx}(a) + p u_1(a) = g_1^{(n)}$, where $g_1^{(n)} = -\\frac{du_2^{(n)}}{dx}(a) + p u_2^{(n)}(a)$. This implies $u_1'(a) = g_1^{(n)} - p u_1(a)$.\n\nSubstituting these into the boundary term for $\\Omega_1$ gives:\n$$\n-u_1'(a)v(a) + u_1'(0)v(0) = -(g_1^{(n)} - p u_1(a))v(a) + (-i k u_1(0))v(0)\n$$\nThe weak form for $\\Omega_1$ is to find $u_1 \\in H^1(\\Omega_1)$ such that for all $v \\in H^1(\\Omega_1)$:\n$$\n\\int_{0}^{a} (u_1'v' - k^2 u_1v) \\,dx + p u_1(a)v(a) - i k u_1(0)v(0) = \\int_{0}^{a} fv \\,dx + g_1^{(n)} v(a)\n$$\n\n**Subproblem 2 on $\\Omega_2 = [b, L]$**:\nThe boundary conditions are:\n1.  Transmission BC at $x=b$: $-\\frac{du_2}{dx}(b) + p u_2(b) = g_2^{(n)}$, where $g_2^{(n)} = \\frac{du_1^{(n)}}{dx}(b) + p u_1^{(n)}(b)$. This implies $u_2'(b) = p u_2(b) - g_2^{(n)}$.\n2.  Physical BC at $x=L$: $-\\frac{du_2}{dx}(L) + i k u_2(L) = 0 \\implies u_2'(L) = i k u_2(L)$.\n\nSubstituting these into the boundary term for $\\Omega_2$ gives:\n$$\n-u_2'(L)v(L) + u_2'(b)v(b) = -(i k u_2(L))v(L) + (p u_2(b) - g_2^{(n)})v(b)\n$$\nThe weak form for $\\Omega_2$ is to find $u_2 \\in H^1(\\Omega_2)$ such that for all $v \\in H^1(\\Omega_2)$:\n$$\n\\int_{b}^{L} (u_2'v' - k^2 u_2v) \\,dx - i k u_2(L)v(L) + p u_2(b)v(b) = \\int_{b}^{L} fv \\,dx + g_2^{(n)} v(b)\n$$\n\n#### Finite Element Discretization\nWe use continuous, piecewise linear basis functions (\"hat\" functions) $\\phi_j(x)$ on a uniform mesh of size $h=L/N$. The approximate solution is $u_h(x) = \\sum_j U_j \\phi_j(x)$. Substituting this into the weak forms results in two linear algebraic systems, one for each subdomain, of the form $A \\mathbf{U} = \\mathbf{b}$.\n\nThe elemental stiffness and mass matrices for an element of length $h$ are:\n$$\nK^e = \\frac{1}{h} \\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix}, \\quad M^e = \\frac{h}{6} \\begin{pmatrix} 2 & 1 \\\\ 1 & 2 \\end{pmatrix}\n$$\nThe full system matrix for an operator $-u''-k^2 u$ is assembled from $A^e = K^e - k^2 M^e$.\n\nThe Robin boundary conditions contribute terms to the diagonal entries of the matrices and to the right-hand side vectors:\n- For $\\Omega_1$: The term $-i k u_1(0)v(0)$ adds $-i k$ to the matrix entry $A_{1}[0,0]$. The term $p u_1(a)v(a)$ adds $p$ to $A_{1}[N_1,N_1]$. The term $g_1^{(n)}v(a)$ adds $g_1^{(n)}$ to the RHS vector $b_1$ at index $N_1$.\n- For $\\Omega_2$: The term $p u_2(b)v(b)$ adds $p$ to the matrix entry $A_{2}[0,0]$. The term $-i k u_2(L)v(L)$ adds $-i k$ to $A_{2}[m,m]$, where $m$ is the last index. The term $g_2^{(n)}v(b)$ adds $g_2^{(n)}$ to the RHS vector $b_2$ at index $0$.\n\nThe source vector components $b_j = \\int f(x)\\phi_j(x) \\,dx$ are computed numerically using two-point Gaussian quadrature over each element for accuracy.\n\n### Step 3: Algorithm Implementation\n\nThe solution is implemented as a parallel Schwarz iteration (Jacobi-type).\n\n1.  **Initialization**: Define mesh and subdomain parameters ($h, N_1, N_2$). Initialize subdomain solution vectors $U_1$ and $U_2$ to zero. Pre-assemble the FEM matrices for each subdomain, including the constant contributions from physical and transmission boundary conditions.\n2.  **Iteration**: For each iteration up to `max_iter`:\n    a.  **Compute Transmission Data**: Calculate the Robin data $g_1$ and $g_2$ from the previous iteration's solutions $U_1$ and $U_2$. The derivatives are approximated using one-sided finite differences consistent with the geometry (e.g., $u_1'(b) \\approx (U_{1,N_2+1} - U_{1,N_2})/h$).\n    b.  **Solve Subproblems**: Update the right-hand side vectors $b_1$ and $b_2$ with $g_1$ and $g_2$. Solve the linear systems $A_1 U_1^{\\text{new}} = b_1$ and $A_2 U_2^{\\text{new}} = b_2$ to obtain the new solutions.\n    c.  **Check Convergence**: Calculate the residuals $r_1$ and $r_2$ as the jump in the Robin traces at the interfaces, using the newly computed solutions $U_1^{\\text{new}}$ and $U_2^{\\text{new}}$. Convergence is achieved if $\\max(|r_1|, |r_2|)$ is below the specified tolerance.\n    d.  **Update**: Replace the old solutions with the new ones: $U_1 \\leftarrow U_1^{\\text{new}}$, $U_2 \\leftarrow U_2^{\\text{new}}$.\n3.  **Termination**: If convergence is achieved, return the iteration count. If `max_iter` is reached without convergence, return $-1$.\n\nThe final code implements this algorithm for the specified test suite.", "answer": "```python\nimport numpy as np\nfrom scipy import sparse\nfrom scipy.sparse.linalg import spsolve\n\ndef assemble_1d_helmholtz(nodes, k, h, f_func):\n    \"\"\"\n    Assembles the 1D FEM system matrix A and source vector b for -u'' - k^2 u = f.\n    Boundary condition terms are added separately.\n    \"\"\"\n    num_nodes = len(nodes)\n    \n    # Elemental matrices\n    Ke = (1 / h) * np.array([[1, -1], [-1, 1]])\n    Me = (h / 6) * np.array([[2, 1], [1, 2]])\n    Ae = Ke - k**2 * Me\n\n    # Assembly\n    A = np.zeros((num_nodes, num_nodes), dtype=np.complex128)\n    for i in range(num_nodes - 1):\n        A[i:i+2, i:i+2] += Ae\n\n    # Assemble RHS vector b using 2-point Gaussian Quadrature\n    b = np.zeros(num_nodes, dtype=np.complex128)\n    gq_pts = np.array([-1/np.sqrt(3), 1/np.sqrt(3)])\n    gq_wts = np.array([1, 1])\n    \n    for i in range(num_nodes - 1):\n        x_i, x_ip1 = nodes[i], nodes[i+1]\n        phys_pts = 0.5 * (x_ip1 - x_i) * gq_pts + 0.5 * (x_ip1 + x_i)\n        \n        f_vals = f_func(phys_pts)\n        phi_i_vals = 0.5 * (1 - gq_pts)\n        phi_ip1_vals = 0.5 * (1 + gq_pts)\n        \n        integral_factor = 0.5 * h\n        b[i] += integral_factor * np.sum(gq_wts * f_vals * phi_i_vals)\n        b[i+1] += integral_factor * np.sum(gq_wts * f_vals * phi_ip1_vals)\n\n    return A, b\n\ndef run_schwarz_iteration(L, k, p, delta, N, tol, max_iter):\n    h = L / N\n    x = np.linspace(0, L, N + 1)\n    \n    f_func = lambda x_val: np.exp(1j * k * x_val)\n\n    # Subdomain definitions\n    if delta >= 0:\n        b = (L - delta) / 2\n        a = b + delta\n        N2 = int(round(b / h))\n        N1 = int(round(a / h))\n    \n    nodes1 = x[0:N1+1]\n    nodes2 = x[N2:N+1]\n    \n    u1 = np.zeros(len(nodes1), dtype=np.complex128)\n    u2 = np.zeros(len(nodes2), dtype=np.complex128)\n    \n    # Pre-assemble matrices and source vectors\n    A1_base, b1_base = assemble_1d_helmholtz(nodes1, k, h, f_func)\n    A2_base, b2_base = assemble_1d_helmholtz(nodes2, k, h, f_func)\n    \n    # Add matrix contributions from boundary conditions\n    # Physical BC on Omega1 at x=0: u' + iku = 0 => add -ik to A[0,0]\n    A1_base[0, 0] += -1j * k\n    # Transmission BC on Omega1 at x=a: u' + pu = g1 => add p to A[-1,-1]\n    A1_base[-1, -1] += p\n    \n    # Transmission BC on Omega2 at x=b: -u' + pu = g2 => add p to A[0,0]\n    A2_base[0, 0] += p\n    # Physical BC on Omega2 at x=L: -u' + iku = 0 => add -ik to A[-1,-1]\n    A2_base[-1, -1] += -1j * k\n    \n    A1_sparse = sparse.csr_matrix(A1_base)\n    A2_sparse = sparse.csr_matrix(A2_base)\n\n    for n_iter in range(max_iter):\n        # 1. Compute transmission data g1, g2 from previous step\n        idx_a_in_2 = N1 - N2\n        u2_at_a = u2[idx_a_in_2]\n        du2dx_at_a = (u2[idx_a_in_2] - u2[idx_a_in_2 - 1]) / h if idx_a_in_2 > 0 else 0\n        g1 = -du2dx_at_a + p * u2_at_a\n        \n        idx_b_in_1 = N2\n        u1_at_b = u1[idx_b_in_1]\n        du1dx_at_b = (u1[idx_b_in_1 + 1] - u1[idx_b_in_1]) / h if idx_b_in_1  len(u1) -1 else 0\n        g2 = du1dx_at_b + p * u1_at_b\n        \n        # 2. Solve on subdomains\n        b1 = b1_base.copy()\n        b1[-1] += g1\n        \n        b2 = b2_base.copy()\n        b2[0] += g2\n        \n        u1_new = spsolve(A1_sparse, b1)\n        u2_new = spsolve(A2_sparse, b2)\n        \n        # 3. Check for convergence using new solutions\n        # Residual at x=a\n        du1new_dx_at_a = (u1_new[-1] - u1_new[-2]) / h\n        term1_r1 = du1new_dx_at_a + p * u1_new[-1]\n        \n        du2new_dx_at_a = (u2_new[idx_a_in_2] - u2_new[idx_a_in_2 - 1]) / h if idx_a_in_2 > 0 else 0\n        term2_r1 = -du2new_dx_at_a + p * u2_new[idx_a_in_2]\n        r1 = term1_r1 - term2_r1\n        \n        # Residual at x=b\n        du2new_dx_at_b = (u2_new[1] - u2_new[0]) / h if len(u2_new) > 1 else 0\n        term1_r2 = -du2new_dx_at_b + p * u2_new[0]\n        \n        du1new_dx_at_b = (u1_new[idx_b_in_1 + 1] - u1_new[idx_b_in_1]) / h if idx_b_in_1  len(u1_new) - 1 else 0\n        term2_r2 = du1new_dx_at_b + p * u1_new[idx_b_in_1]\n        r2 = term1_r2 - term2_r2\n        \n        residual = max(abs(r1), abs(r2))\n        \n        if residual  tol:\n            return n_iter + 1\n        \n        # 4. Update solutions\n        u1, u2 = u1_new, u2_new\n        \n    return -1\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # (L, k, p, delta, N, tol, max_iter)\n        (1.0, 20.0, 1j * 20.0, 0.2, 400, 1e-8, 200),\n        (1.0, 20.0, 1.0, 0.2, 400, 1e-8, 200),\n        (1.0, 40.0, 1j * 40.0, 0.0, 800, 1e-8, 200),\n    ]\n\n    results = []\n    for case in test_cases:\n        L, k, p, delta, N, tol, max_iter = case\n        n_iters = run_schwarz_iteration(L, k, p, delta, N, tol, max_iter)\n        results.append(n_iters)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3302374"}, {"introduction": "Advanced FEM simulations often employ $p$-adaptivity, where different polynomial orders are used in different subdomains to enhance efficiency. This practice tackles the resulting challenge of connecting non-conforming discretizations at interfaces while preserving physical laws [@problem_id:3302373]. You will design and implement a projection operator that ensures the continuity of tangential fields between spaces of different polynomial degrees by enforcing the conservation of integral moments, a cornerstone of high-order $H(\\mathrm{curl})$-conforming methods.", "problem": "Consider the time-harmonic Maxwell boundary value problem in two spatial dimensions, where the electric field is represented by a vector field whose tangential component must be continuous across interior interfaces in the absence of surface currents. In substructuring for the Finite Element Method (FEM) using Domain Decomposition Methods (DDM), the computational domain is partitioned into subdomains with a shared interface. For edge-based $H(\\mathrm{curl})$ (Sobolev space of square-integrable vector fields with square-integrable curl) finite elements of Nédélec type, the tangential trace of the electric field along an interior edge must be made continuous across subdomains. In a $p$-adaptive setting, different subdomains can use different polynomial orders, which forces the design of projection operators that transfer tangential traces between nonmatching polynomial spaces while preserving curl-conformity implied by Stokes’ theorem and Maxwell’s interface conditions.\n\nAssume two subdomains share a straight interface $\\Gamma$, which is parameterized as the interval $[0,1]$ with coordinate $y \\in [0,1]$. The tangential trace space on $\\Gamma$ for a polynomial order $p \\in \\mathbb{N}_0$ is the space of polynomials of degree at most $p$ in $y$. Use the orthonormal basis $\\{\\phi_i(y)\\}_{i=0}^{p}$ on $[0,1]$ defined as follows: for each integer $i \\ge 0$, let $P_i(x)$ be the Legendre polynomial of degree $i$ on $[-1,1]$ with the normalization $P_i(1)=1$. Define\n$$\n\\phi_i(y) \\equiv \\sqrt{2 i + 1}\\, P_i(2y - 1),\n$$\nwhich satisfies\n$$\n\\int_{0}^{1} \\phi_i(y) \\, \\phi_j(y) \\, dy = \\delta_{ij}\n$$\nfor all integers $i,j \\ge 0$.\n\nLet the left subdomain use polynomial order $p_{\\mathrm{L}} \\in \\mathbb{N}_0$ and the right subdomain use polynomial order $p_{\\mathrm{R}} \\in \\mathbb{N}_0$. A tangential trace on $\\Gamma$ from the left subdomain is represented by its coefficient vector $\\mathbf{c}_{\\mathrm{L}} \\in \\mathbb{R}^{p_{\\mathrm{L}}+1}$ with respect to the basis $\\{\\phi_i\\}_{i=0}^{p_{\\mathrm{L}}}$; analogously, the right trace uses $\\mathbf{c}_{\\mathrm{R}} \\in \\mathbb{R}^{p_{\\mathrm{R}}+1}$ with respect to $\\{\\phi_i\\}_{i=0}^{p_{\\mathrm{R}}}$. The orientation of the unit tangent on $\\Gamma$ may be opposite between the two subdomains; denote this by an orientation parameter $\\sigma \\in \\{+1,-1\\}$, where $\\sigma=-1$ indicates that the right subdomain’s local tangent is opposite to that of the left subdomain, and $\\sigma=+1$ indicates the same orientation.\n\nYour tasks are:\n\n- From the weak form of Maxwell’s equations and Stokes’ theorem, formulate a principled, basis-independent condition that a linear projection operator mapping $\\mathbf{c}_{\\mathrm{L}} \\mapsto \\mathbf{c}_{\\mathrm{R}}$ must satisfy so that:\n  1. When $\\sigma = -1$, the interface contributions to curl moments cancel in the global assembly, i.e., for every test polynomial $q$ from the right trace space, the signed moments of the left and right traces sum to zero.\n  2. When $\\sigma = +1$, the tangential moments match between the two sides for all test polynomials from the common trace space.\n  Your formulation must rely only on conservation of tangential moments consistent with $H(\\mathrm{curl})$ conformity and must not assume any a priori matching of polynomial orders.\n\n- Specialize your formulation to the polynomial basis $\\{\\phi_i\\}$ and derive an implementable algorithm that, given $(p_{\\mathrm{L}}, p_{\\mathrm{R}}, \\sigma, \\mathbf{c}_{\\mathrm{L}})$, computes $\\mathbf{c}_{\\mathrm{R}}$ by enforcing the moment conditions using a numerically assembled inner product on $[0,1]$ computed via Gauss–Legendre quadrature. Your algorithm must be robust for all nonnegative integers $p_{\\mathrm{L}}$ and $p_{\\mathrm{R}}$ and both orientations $\\sigma \\in \\{+1,-1\\}$.\n\n- Implement the algorithm as a complete runnable program in the specified environment that:\n  1. Constructs the orthonormal basis $\\{\\phi_i\\}$ on $[0,1]$ using Legendre polynomials.\n  2. Assembles the required inner-product matrices by Gauss–Legendre quadrature, using a quadrature order sufficient to integrate exactly all polynomials arising from products of basis functions up to degree $\\max(2 p_{\\mathrm{L}}, 2 p_{\\mathrm{R}})$.\n  3. Computes the projection $\\mathbf{c}_{\\mathrm{R}}$ from $\\mathbf{c}_{\\mathrm{L}}$ for each test case below.\n  4. Verifies curl-conformity at the interface by checking moment cancellation or matching, as appropriate:\n     - For $\\sigma=-1$, check that for each index $j \\in \\{0,1,\\dots,p_{\\mathrm{R}}\\}$,\n       $$\n       \\left| \\int_0^1 \\left(\\sum_{i=0}^{p_{\\mathrm{L}}} \\mathbf{c}_{\\mathrm{L}}[i] \\, \\phi_i(y)\\right) \\, \\phi_j(y) \\, dy \\;+\\; \\int_0^1 \\left(\\sum_{k=0}^{p_{\\mathrm{R}}} \\mathbf{c}_{\\mathrm{R}}[k] \\, \\phi_k(y)\\right) \\, \\phi_j(y) \\, dy \\right| \\le \\varepsilon,\n       $$\n       with tolerance $\\varepsilon = 10^{-10}$.\n     - For $\\sigma=+1$, check that for each index $j \\in \\{0,1,\\dots,\\min(p_{\\mathrm{L}},p_{\\mathrm{R}})\\}$,\n       $$\n       \\left| \\int_0^1 \\left(\\sum_{i=0}^{p_{\\mathrm{L}}} \\mathbf{c}_{\\mathrm{L}}[i] \\, \\phi_i(y)\\right) \\, \\phi_j(y) \\, dy \\;-\\; \\int_0^1 \\left(\\sum_{k=0}^{p_{\\mathrm{R}}} \\mathbf{c}_{\\mathrm{R}}[k] \\, \\phi_k(y)\\right) \\, \\phi_j(y) \\, dy \\right| \\le \\varepsilon,\n       $$\n       with the same tolerance $\\varepsilon = 10^{-10}$.\n\nTest suite:\n\n- Case $1$ (happy path, higher to lower with opposite orientation): $p_{\\mathrm{L}}=4$, $p_{\\mathrm{R}}=2$, $\\sigma=-1$, $\\mathbf{c}_{\\mathrm{L}} = [\\,0.5,\\,-0.3,\\,0.2,\\,-0.4,\\,0.1\\,]^{\\top}$.\n- Case $2$ (boundary case, both lowest order, opposite orientation): $p_{\\mathrm{L}}=0$, $p_{\\mathrm{R}}=0$, $\\sigma=-1$, $\\mathbf{c}_{\\mathrm{L}} = [\\,0.123456789\\,]^{\\top}$.\n- Case $3$ (equal orders, opposite orientation): $p_{\\mathrm{L}}=3$, $p_{\\mathrm{R}}=3$, $\\sigma=-1$, $\\mathbf{c}_{\\mathrm{L}} = [\\,0.1,\\,0.2,\\,-0.1,\\,0.05\\,]^{\\top}$.\n- Case $4$ (lower to higher with same orientation): $p_{\\mathrm{L}}=2$, $p_{\\mathrm{R}}=5$, $\\sigma=+1$, $\\mathbf{c}_{\\mathrm{L}} = [\\,0.7,\\,-0.25,\\,0.33\\,]^{\\top}$.\n- Case $5$ (stress case, strongly nonconforming, opposite orientation): $p_{\\mathrm{L}}=5$, $p_{\\mathrm{R}}=1$, $\\sigma=-1$, $\\mathbf{c}_{\\mathrm{L}} = [\\,0.0,\\,1.0,\\,0.0,\\,-0.2,\\,0.3,\\,-0.1\\,]^{\\top}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[{\\tt True},{\\tt False},{\\tt True}]$), where each entry is a boolean indicating whether the corresponding case satisfies the respective curl-conformity moment conditions within the given tolerance. No physical units are required. Angles are not involved. Percentages are not involved.", "solution": "The problem requires the formulation and implementation of a projection operator for tangential traces of vector fields between non-matching polynomial spaces on a shared interface, a common task in $p$-adaptive domain decomposition methods for finite element analysis of Maxwell's equations.\n\n### Step 1: Formulation of the Projection Operator\n\nLet the computational domain $\\Omega$ be partitioned into subdomains, including a left subdomain $\\Omega_{\\mathrm{L}}$ and a right subdomain $\\Omega_{\\mathrm{R}}$ sharing a common interface $\\Gamma$. For $H(\\mathrm{curl})$-conforming finite elements, continuity of the tangential component of the electric field, $\\mathbf{E}_{\\tau}$, must be enforced across $\\Gamma$.\n\nLet $\\mathbf{t}_{\\mathrm{L}}$ and $\\mathbf{t}_{\\mathrm{R}}$ be the unit tangent vectors defining the local parameterizations on $\\Gamma$ for the left and right subdomains, respectively. The orientation parameter $\\sigma \\in \\{+1, -1\\}$ relates them by $\\mathbf{t}_{\\mathrm{R}} = \\sigma \\mathbf{t}_{\\mathrm{L}}$. The tangential electric fields are vector quantities given by $\\mathbf{E}_{\\tau, \\mathrm{L}} = u_{\\mathrm{L}} \\mathbf{t}_{\\mathrm{L}}$ and $\\mathbf{E}_{\\tau, \\mathrm{R}} = u_{\\mathrm{R}} \\mathbf{t}_{\\mathrm{R}}$, where $u_{\\mathrm{L}}$ and $u_{\\mathrm{R}}$ are the scalar tangential trace functions.\n\nThe physical condition of tangential continuity is $\\mathbf{E}_{\\tau, \\mathrm{L}} = \\mathbf{E}_{\\tau, \\mathrm{R}}$. Substituting the local representations gives:\n$$\nu_{\\mathrm{L}}(y) \\mathbf{t}_{\\mathrm{L}} = u_{\\mathrm{R}}(y) \\mathbf{t}_{\\mathrm{R}} = u_{\\mathrm{R}}(y) (\\sigma \\mathbf{t}_{\\mathrm{L}})\n$$\nThis implies the strong, pointwise condition on the scalar traces: $u_{\\mathrm{L}}(y) = \\sigma u_{\\mathrm{R}}(y)$.\n\nIn a weak formulation, this condition is enforced by requiring it to hold in an integral sense when tested against a suitable space of functions. A principled choice for defining a projection from the left trace space $V_{\\mathrm{L}} = \\mathrm{span}\\{\\phi_i\\}_{i=0}^{p_{\\mathrm{L}}}$ to the right trace space $V_{\\mathrm{R}} = \\mathrm{span}\\{\\phi_k\\}_{k=0}^{p_{\\mathrm{R}}}$ is to enforce the condition against all basis functions of the target space, $V_{\\mathrm{R}}$. This is a form of $L^2$ projection.\n\nThe basis-independent condition is to find $u_{\\mathrm{R}} \\in V_{\\mathrm{R}}$ such that for a given $u_{\\mathrm{L}} \\in V_{\\mathrm{L}}$:\n$$\n\\int_{\\Gamma} \\left( u_{\\mathrm{L}}(y) - \\sigma u_{\\mathrm{R}}(y) \\right) q(y) \\, dy = 0, \\quad \\forall q(y) \\in V_{\\mathrm{R}}\n$$\nThis is equivalent to $\\int_{\\Gamma} u_{\\mathrm{L}}(y) q(y) \\, dy = \\sigma \\int_{\\Gamma} u_{\\mathrm{R}}(y) q(y) \\, dy$. This formulation is consistent with the problem's requirements for both $\\sigma=-1$ (moment cancellation) and $\\sigma=+1$ (moment matching).\n\n### Step 2: Derivation of the Algorithm\n\nWe specialize the formulation to the given orthonormal basis $\\{\\phi_i(y)\\}$. Let $u_{\\mathrm{L}}(y) = \\sum_{i=0}^{p_{\\mathrm{L}}} \\mathbf{c}_{\\mathrm{L}}[i] \\phi_i(y)$ and $u_{\\mathrm{R}}(y) = \\sum_{k=0}^{p_{\\mathrm{R}}} \\mathbf{c}_{\\mathrm{R}}[k] \\phi_k(y)$. The test functions are $q(y) = \\phi_j(y)$ for $j \\in \\{0, 1, \\dots, p_{\\mathrm{R}}\\}$.\n\nSubstituting into the weak condition:\n$$\n\\int_{0}^{1} \\left( \\sum_{i=0}^{p_{\\mathrm{L}}} \\mathbf{c}_{\\mathrm{L}}[i] \\phi_i(y) \\right) \\phi_j(y) \\, dy = \\sigma \\int_{0}^{1} \\left( \\sum_{k=0}^{p_{\\mathrm{R}}} \\mathbf{c}_{\\mathrm{R}}[k] \\phi_k(y) \\right) \\phi_j(y) \\, dy\n$$\nThe right-hand side simplifies due to the orthonormality of the basis $\\{\\phi_k(y)\\}_{k=0}^{p_{\\mathrm{R}}}$. Since $j \\le p_{\\mathrm{R}}$, we have $\\int_{0}^{1} \\phi_k(y) \\phi_j(y) \\, dy = \\delta_{kj}$:\n$$\n\\sigma \\sum_{k=0}^{p_{\\mathrm{R}}} \\mathbf{c}_{\\mathrm{R}}[k] \\delta_{kj} = \\sigma \\mathbf{c}_{\\mathrm{R}}[j]\n$$\nThe left-hand side is a projection of $u_{\\mathrm{L}}$ onto the basis function $\\phi_j$:\n$$\n\\sum_{i=0}^{p_{\\mathrm{L}}} \\mathbf{c}_{\\mathrm{L}}[i] \\int_{0}^{1} \\phi_i(y) \\phi_j(y) \\, dy\n$$\nCombining these, we obtain an explicit formula for each coefficient of $\\mathbf{c}_{\\mathrm{R}}$:\n$$\n\\mathbf{c}_{\\mathrm{R}}[j] = \\frac{1}{\\sigma} \\sum_{i=0}^{p_{\\mathrm{L}}} \\mathbf{c}_{\\mathrm{L}}[i] \\int_{0}^{1} \\phi_i(y) \\phi_j(y) \\, dy\n$$\nSince $\\sigma^2=1$, we have $1/\\sigma = \\sigma$. Let's define the $(p_{\\mathrm{R}}+1) \\times (p_{\\mathrm{L}}+1)$ mass matrix $M$ with entries $M_{ji} = \\int_{0}^{1} \\phi_i(y) \\phi_j(y) \\, dy$. The entire projection can be written as a matrix-vector product:\n$$\n\\mathbf{c}_{\\mathrm{R}} = \\sigma M \\mathbf{c}_{\\mathrm{L}}\n$$\n### Step 3: Implementation Details\n\nThe algorithm consists of the following steps for each test case $(p_{\\mathrm{L}}, p_{\\mathrm{R}}, \\sigma, \\mathbf{c}_{\\mathrm{L}})$:\n1.  **Basis Functions**: Implement the function $\\phi_i(y) = \\sqrt{2 i + 1}\\, P_i(2y - 1)$, where $P_i$ are the standard Legendre polynomials available in `scipy.special`.\n2.  **Quadrature**: Set up a Gauss-Legendre quadrature rule on $[0,1]$ of sufficient order to compute the matrix entries exactly. The integrand $\\phi_i(y)\\phi_j(y)$ is a polynomial of degree $i+j$. The highest degree encountered is in the verification step, which is $\\max(p_{\\mathrm{L}}, p_{\\mathrm{R}}) + p_{\\mathrm{R}}$. The problem specifies a quadrature order $N_q$ sufficient for polynomials of degree up to $\\max(2p_{\\mathrm{L}}, 2p_{\\mathrm{R}})$. This implies choosing $N_q = \\max(p_{\\mathrm{L}}, p_{\\mathrm{R}}) + 1$, which is more than sufficient.\n3.  **Matrix Assembly**: Compute the matrix $M$ by numerically evaluating each integral $M_{ji}$ using the quadrature rule: $M_{ji} \\approx \\sum_{k=1}^{N_q} w'_k \\phi_i(y_k) \\phi_j(y_k)$, where $(y_k, w'_k)$ are the quadrature points and weights on $[0,1]$.\n4.  **Projection**: Compute the projected coefficient vector $\\mathbf{c}_{\\mathrm{R}}$ using the matrix-vector product $\\mathbf{c}_{\\mathrm{R}} = \\sigma M \\mathbf{c}_{\\mathrm{L}}$.\n5.  **Verification**: For each test case, verify the appropriate moment condition using the same numerical quadrature scheme.\n    -   For $\\sigma = -1$, check if $|\\int_0^1 (u_{\\mathrm{L}} + u_{\\mathrm{R}}) \\phi_j(y) \\, dy| \\le \\varepsilon$ for all $j \\in \\{0, \\dots, p_{\\mathrm{R}}\\}$.\n    -   For $\\sigma = +1$, check if $|\\int_0^1 (u_{\\mathrm{L}} - u_{\\mathrm{R}}) \\phi_j(y) \\, dy| \\le \\varepsilon$ for all $j \\in \\{0, \\dots, \\min(p_{\\mathrm{L}}, p_{\\mathrm{R}})\\}$.\n    The integrals are computed numerically as sums over quadrature points. The boolean result of this check is the output for the case. By construction, these checks should pass up to the precision of floating-point arithmetic.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import legendre\n\ndef run_case(p_L, p_R, sigma, c_L):\n    \"\"\"\n    Computes the projection and verifies the moment conditions for a single test case.\n\n    Args:\n        p_L (int): Polynomial order for the left subdomain.\n        p_R (int): Polynomial order for the right subdomain.\n        sigma (int): Orientation parameter, either +1 or -1.\n        c_L (np.ndarray): Coefficient vector for the left trace.\n\n    Returns:\n        bool: True if the moment conditions are satisfied within tolerance, False otherwise.\n    \"\"\"\n    epsilon = 1e-10\n\n    # 1. Define basis functions using Legendre polynomials\n    # The basis is phi_i(y) = sqrt(2i+1) * P_i(2y-1) for y in [0,1].\n    # scipy.special.legendre P_i are normalized with P_i(1)=1.\n    p_max_basis = max(p_L, p_R)\n    legendre_polys = {i: legendre(i) for i in range(p_max_basis + 1)}\n    \n    def phi(i, y):\n        # y can be a scalar or a numpy array\n        return np.sqrt(2 * i + 1) * legendre_polys[i](2 * y - 1)\n\n    # 2. Set up Gauss-Legendre quadrature on [0, 1]\n    # Quadrature order sufficient to integrate polynomials of degree up to max(2*p_L, 2*p_R)\n    # requires 2*N_q - 1 >= 2*p_max, so N_q = p_max + 1.\n    p_max_quad = max(p_L, p_R)\n    N_q = p_max_quad + 1\n    \n    # Get nodes and weights for [-1, 1] and scale to [0, 1]\n    x_q, w_q = np.polynomial.legendre.leggauss(N_q)\n    y_q = (x_q + 1) / 2.0\n    w_q_scaled = w_q / 2.0\n\n    # 3. Assemble the (p_R+1) x (p_L+1) mass matrix M_ji = integral(phi_i * phi_j dy)\n    phi_vals_L = np.array([phi(i, y_q) for i in range(p_L + 1)]) # Shape (p_L+1, N_q)\n    phi_vals_R = np.array([phi(j, y_q) for j in range(p_R + 1)]) # Shape (p_R+1, N_q)\n    \n    M = phi_vals_R @ (phi_vals_L.T * w_q_scaled[:, np.newaxis])\n    \n    # 4. Compute projected coefficients c_R = sigma * M @ c_L\n    c_R = sigma * (M @ c_L)\n    \n    # 5. Verify curl-conformity moment conditions using numerical quadrature\n    u_L_at_yq = c_L @ phi_vals_L\n    u_R_at_yq = c_R @ phi_vals_R\n    \n    all_checks_passed = True\n    if sigma == -1:\n        # Check condition for j in {0, ..., p_R}\n        for j in range(p_R + 1):\n            phi_j_at_yq = phi_vals_R[j, :]\n            \n            moment_L = np.sum(w_q_scaled * u_L_at_yq * phi_j_at_yq)\n            moment_R = np.sum(w_q_scaled * u_R_at_yq * phi_j_at_yq)\n            \n            error = np.abs(moment_L + moment_R)\n            if error > epsilon:\n                all_checks_passed = False\n                break\n    elif sigma == 1:\n        # Check condition for j in {0, ..., min(p_L, p_R)}\n        p_min = min(p_L, p_R)\n        for j in range(p_min + 1):\n            # Test functions phi_j are from the right space's basis\n            phi_j_at_yq = phi_vals_R[j, :]\n            \n            moment_L = np.sum(w_q_scaled * u_L_at_yq * phi_j_at_yq)\n            moment_R = np.sum(w_q_scaled * u_R_at_yq * phi_j_at_yq)\n            \n            error = np.abs(moment_L - moment_R)\n            if error > epsilon:\n                all_checks_passed = False\n                break\n                \n    return all_checks_passed\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (4, 2, -1, [0.5, -0.3, 0.2, -0.4, 0.1]),\n        (0, 0, -1, [0.123456789]),\n        (3, 3, -1, [0.1, 0.2, -0.1, 0.05]),\n        (2, 5, 1,  [0.7, -0.25, 0.33]),\n        (5, 1, -1, [0.0, 1.0, 0.0, -0.2, 0.3, -0.1]),\n    ]\n\n    results = []\n    for p_L, p_R, sigma, c_L in test_cases:\n        is_valid = run_case(p_L, p_R, sigma, np.array(c_L))\n        results.append(is_valid)\n\n    # Final print statement in the exact required format.\n    # Convert booleans to uppercase 'True'/'False' as per standard Python practice\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3302373"}]}